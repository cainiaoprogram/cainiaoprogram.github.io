<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f48eacdb1cf8062bad8b7c26de2f6f32/" rel="bookmark">
			图像傅里叶变换的幅度谱、相位谱以及双谱重构原图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的求取下灰度图像的幅度谱和相位谱并进行双谱重构：
直接上代码：
clear all Picture = imread('E:\others\Picture\Library.jpg'); Picture_Gray = rgb2gray(Picture);%灰度处理 Picture_FFT = fft2(Picture_Gray);%傅里叶变换 Picture_FFT_Shift = fftshift(Picture_FFT);%对频谱进行移动，是0频率点在中心 Picture_AM_Spectrum = log(abs(Picture_FFT_Shift));%获得傅里叶变换的幅度谱 Picture_Phase_Specture = log(angle(Picture_FFT_Shift)*180/pi);%获得傅里叶变换的相位谱 Picture_Restructure = ifft2(abs(Picture_FFT).*exp(j*(angle(Picture_FFT))));%双谱重构 figure(1) subplot(221) imshow(Picture_Gray) title('原图像') subplot(222) imshow(Picture_AM_Spectrum,[])%显示图像的幅度谱，参数'[]'是为了将其值线性拉伸 title('图像幅度谱') subplot(223) imshow(Picture_Phase_Specture,[]); title('图像相位谱') subplot(224) imshow(Picture_Restructure,[]); title('双谱重构图') 运行结果：
图像的幅度谱代表的是图像各像素点的亮度信息，即该像素应该显示什么颜色，但是做出来的幅度谱却不知道每一点在原图像中具体是哪一点，即幅度谱虽然存储了各个像素点的幅值信息，但是原像素点的位置已经被打乱，所以仅凭幅度谱是没有办法重构原图像的。幅度谱的中心是低频部分，越亮的地方代表的幅度越大。幅度谱中“十”字形亮线表示原图像中水平和垂直方向的分量较其他方向要多，因为在人们周围的自然场景中水平和垂直的线条出现的可能性较大。
来看下仅有幅度谱重构出来的原图像：
Picture_Restructure = ifft2(abs(Picture_FFT));%幅度谱重构 可以看到仅有幅度谱重构出来的图像啥也不是，，，
而相位谱记录的是所有点的相位信息，看起来相位谱是一团噪声，这也说明相位信息是以一种更为隐蔽的方式出现在人们面前的，但它非常重要，因为相位信息中携带者图像的位置信息，没有它将无法从品频谱还原出原图像。
相位谱重构原图像：
Picture_Restructure = ifft2(exp(j*(angle(Picture_FFT))));%相位谱重构 可以看到仅有相位谱重构出来的图像还是可以看到一些轮廓信息的，利用相位谱记录的位置信息和幅度谱记录的亮度信息，就可以用双谱重构的方法恢复出原图像。
参考资料：
https://zhidao.baidu.com/question/324052986.html
https://blog.csdn.net/wujian_1205/article/details/56852399
https://blog.csdn.net/Struggle_For_M/article/details/51207370
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b537606a6359d5d28a86cf5a0e3393b/" rel="bookmark">
			BMC通过PECI接口获取CPU温度实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载于网络，侵权删。
PECI是用于监测CPU及芯片组温度的一线总线(one-wirebus)，全称是Platform Environment Control Interface。它最主要的应用是监测CPU温度，最新版本的PECI接口还包括一些其他的功能。
1 Intel Processor的温控机制 在CPU中，通常每个CPU核心都有一个数字温度传感器。在PC平台下，处理器可以通过MSR(Mode specific registers)获得处理器自身的温度、调节风扇转速度，从而实现温度控制。在服务器平台下，温度控制通常是由BMC来做的，业务CPU本身没有办法控制机框的风扇转速度。BMC直接或间接通过PECI总线获取到CPU核心温度，再根据所有温度值调整风扇转速。
MSR方式读取CPU温度读取到的是即时温度，PECI方式读取到的是256ms时间窗内的平均温度。MSR方式是需要CPU处理C0状态才能读取。PECI方式在C0~C6均可以使用。
图表1 PECI接中的连接方式
Intel Pentium M 开始在处理器中引入DTS（数字温度传感器）。温度传感器通常是每个CPU核心一个。
图表2 Intel温控组件
1.1 TM1 为了保护CPU不会在过热时被烧坏，从Pentium4开始，处理器中又加入了一个温度监示器Thermal Monitor 1，简称TM1。TM1会监示数字温度传感器的读数，当读数高于阈值Tjmax时，TM1会调节处理器时钟的占空比，以降低功耗，降低温度。这里所谓的调节时钟占空比与传统意义上的时钟占空比不同，这里调节的是时钟信号的开闭时间比例，比如说，它会在某一段时间内，37.5%的时间打开CPU时钟，让CPU工作，另62.5%的时间关闭CPU时钟，让CPU停止工作以降低功耗和温度。
Figure 1 TM1调整CPU时钟占空比
1.2 TM2 TM2是Pentium M时引入的，它提供了另一种降低CPU温度的办法。在CPU某个核心的温度超过Tjmax时，它会尝试降低时钟频率和供电电压来降低功耗和温度。TM1和TM2是两个单独的机制，或以分别启用和禁用。Intel推荐两个机制同时使用。它们的启用和禁用是通过BIOS设置IA32_MISC_ENABLE这个模式寄存器的第3、13位来实现的。BIOS打开这两个机制后，OS和用户程序不可关闭。
1.3 温度阈值 Tjmax是我们所知的第一个阈值，当CPU上任意一个核心的温度达到这个阈值时，CPU会产生一个PROCHOT#信号（processor hot）。该信号可触发TM1和TM2。处理器时会通过调节时钟占空比、降低时钟频率和供电电压的方式来降低功耗和温度。产生PROCHOT#信号的同时，温度监示器还会产生一个中断给CPU，其中断向量号通过LAPIC和LVT来设置。模式寄存器IA32_THERM_INTERRUPT有两个位用于高温中断使能（温度超过Tjmax时产生中断）和低温中断使能（温度回到低于Tjmax的范围时产生中断）。
PROCHOT#通过CPU的一个引脚拉出，并且可以连接在外设上，由外设来发生这个信号。比如说一个系统中有另一个设备的温度超过阈值，它可以拉低使能这个信号，从而使CPU也一起降温，从而降低机箱内的温度，制造一个更好的散热环境。
如果TM1和TM2启动后温度没能降低下来，并且继续升高到可能造成CPU物理损坏的温度时，核心会触发THERMTRIP#信号，并且关闭CPU电源。
CPU硬件实现的温度控制机制是用于CPU自我保存的温控机制，当这些机制不足以降温时，CPU会断电，从而造成系统突然掉电，造成数据损失。因而一般要求BMC在要以一定的周期读取CPU核心温度，根据温度调整风扇转速，并且当温度超过Tjmax-10时，让风扇全速转动。
2 相关MSR 2.1 IA32_THERM_INTERRUPT IA32_THERM_INTERRUPT寄存的地址为0x19B。BIOS通过IA32_THERM_INTERRUPT模式寄存器使能温度相关的中断，其各字段定义如下：
表格 1 IA32_THERM_INTERRUPT 0x19B
位
描述
0
High temperature interrupt enable
1
Low temperature interrupt enable
2
PROCHOT# interrupt enable
3
FORCEPR# interrupt enable
4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b537606a6359d5d28a86cf5a0e3393b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89451a2748cd645f6174eeb5271a6657/" rel="bookmark">
			Linux各文件夹的结构说明及用途介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux各文件夹的结构说明及用途介绍 /bin：二进制可执行命令。 /dev：设备特殊文件。 /etc：系统管理和配置文件。 /etc/rc.d：启动的配置文件和脚本。 /home：用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示。 /lib：标准程序设计库，又 叫动态链接共享库，作用类似windows里的.dll文件。 /sbin：系统管理命令，这 里存放的是系统管理员使用的管理程序。 /tmp：公用的临时文件存储 点。
/root：系统管理员的主目 录。 /mnt：系统提供这个目录是 让用户临时挂载其他的文件系统。 /lost+found：这个 目录平时是空的，系统非正常关机而留下“无家可归”的文件就在这里。 /proc：虚拟的目录，是系 统内存的映射。可直接访问这个目录来获取系统信息。 /var：某些大文件的溢出 区，比方说各种服务的日志文件。 /usr：最庞大的目录，要用 到的应用程序和文件几乎都在这个目录。其中包含： /usr/x11r6：存放x window的目录。 /usr/bin：众多的应用程序。 /usr/sbin：超级用户的一些管理程序。
/usr/doc：linux文档。
/usr/include：linux下开发和编译应用程序所需要的头文件。 /usr/lib：常用的动态链接库和软件包的配置文件。 /usr/man：帮助文档。
/usr/src：源代码，linux内核的源代码就放在/usr/src/linux 里。 /usr/local/bin：本地增加的命令。 /usr/local/lib：本地增加的库根文件系统。
通常情况下，根文件系统所占空间一般应该比较小，因为其中的绝大部分文件都不需要经常改动，而且包括严格的文件和一个小的 不经常改变的文件系统不容易损坏。除了可能的一个叫/vmlinuz标准的系统引导映像之外，根目录一般不含任何文 件。所有其他文件在根文件系统的子目录中。 1. /bin目录 /bin目录包含了引导启动所需的命令或普通用户可能用的命令(可能在引导启动后)。这些命 令都是二进制文件的可执行程序(bin是binary的简称)，多是系统中重要的系统文件。 2. /sbin目录 /sbin目录类似/bin ，也用于存储二进制文件。因为其中的大部分文件多是系统管理员使用的基本的系统程序，所以虽然普通用户必要且允许时可以使用，但一般不给普通用户使 用。 3. /etc目录 /etc目录存放着各种系统配置文件，其中包括了用户信息文件/etc/passwd， 系统初始化文件/etc/rc等。linux正是靠这些文件才得以正常地运行。 4. /root目录 /root目录是超级用户的目录。 5. /lib目录 /lib目录是根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文件。 这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副本，故可以使得可执行文件变得更小，节省空间。 6. /lib/modules目录 /lib/modules目录包含系统核心可加载各种模块，尤其是那些在恢复损坏的系统时重 新引导系统所需的模块(例如网络和文件系统驱动)。 7. /dev目录 /dev目录存放了设备文件，即设备驱动程序，用户通过这些文件访问外部设备。比如，用户可 以通过访问/dev/mouse来访问鼠标的输入，就像访问其他文件一样。 8. /tmp目录 /tmp目录存放程序在运行时产生的信息和数据。但在引导启动后，运行的程序最好使用/var/tmp来 代替/tmp，因为前者可能拥有一个更大的磁盘空间。 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89451a2748cd645f6174eeb5271a6657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ced4557f258054ec700f04af6cd88142/" rel="bookmark">
			mysql 数据库练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们学习mysql数据库时需要一些题目进行练习，所以我将一些视频中的练习题来分享给大家 库文件代码，将这段代码复制到文件中后缀名改为.sql就可以用了
drop table if exists dept; drop table if exists salgrade; drop table if exists emp; create table dept( deptno int(10) primary key, dname varchar(14), loc varchar(13) ); create table salgrade( grade int(11), losal int(11), hisal int(11) ); create table emp( empno int(4) primary key, ename varchar(10), job varchar(9), mgr int(4), hiredate date, sal double(7,2), comm double(7,2), deptno int(2) ); insert into dept(deptno,dname,loc) values(10,'ACCOUNTING','NEW YORK'); insert into dept(deptno,dname,loc) values(20,'RESEARCHING','DALLAS'); insert into dept(deptno,dname,loc) values(30,'SALES','CHICAGO'); insert into dept(deptno,dname,loc) values(40,'OPERATIONS','BOSTON'); insert into salgrade(grade,losal,hisal) values(1,700,1200); insert into salgrade(grade,losal,hisal) values(2,1201,1400); insert into salgrade(grade,losal,hisal) values(3,1401,2000); insert into salgrade(grade,losal,hisal) values(4,2001,3000); insert into salgrade(grade,losal,hisal) values(5,3001,5000); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7369,'SIMITH','CLERK',7902,'1980-12-17',800,null,20); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7499,'ALLEN','SALESMAN',7698,'1981-02-20',1600,300,30); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7521,'WARD','SALESMAN',7698,'1981-02-22',1250,500,30); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7566,'JONES','MANAGER',7839,'1981-04-02',2975,null,20); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7654,'MARTIN','SALESMAN',7698,'1981-09-28',1250,1400,30); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7698,'BLAKE','MANAGER',7839,'1981-05-01',2850,null,30); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7782,'CLARK','MANAGER',7839,'1981-06-09',2450,null,10); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7788,'SCOTT','ANALYST',7566,'1987-04-19',3000,null,20); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7839,'KING','PRESIDENT',null,'1981-11-17',5000,null,10); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7844,'TURNER','SALESMAN',7698,'1981-09-08',1500,null,30); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7876,'ADAMS','CLERK',7788,'1987-05-23',1100,null,20); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7900,'JAMES','CLERK',7698,'1981-12-03',950,null,30); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7902,'FORD','ANALYST',7566,'1981-12-03',3000,null,20); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7934,'MILLER','CLERK',7782,'1982-01-23',1300,null,10); select * from dept; select * from salgrade; select * from emp; 一，作业
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ced4557f258054ec700f04af6cd88142/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe87c1aa6228a0393af48f9eb8710c4/" rel="bookmark">
			接口测试与接口性能测试总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口测试与接口性能测试总结 这段时间在自己搭建公司的测试平台框架，基本已经成型，可以满足编写接口、接口自动化、接口性能、数据展示等功能，回过头来看可以使用的工具，发现还是尽量保持“工具引用，不依赖工具”的思想，这里做一个总结。
首先只会独立使用工具，会带来很大的局限性；
比如，我们会使用jmeter来写几个接口，会用postman来做接口，还有其它的工具，那么，我认为这只能局限在你的接口测试的最基础层面。通过阅读工具的文档，谁都可以通过UI页面的操作，搭建接口测试，然后执行，产生报告。但是遇到稍微复杂点的接口，你就无从下手了。我举个例子，我在测试微信小程序的时候，微信会根据每次登录产生一个不同的code，一但code被使用，就失效，这个时候，就需要自己来写一个服务器后台接口来主动接受code值，然后将code值实时保存给接口工具。这样，如果只会jmeter，postman等独立的工具，你根本没有办法很容易的建立接口测试，所以，单独的工具是不完美的。
确定语言阵营；
不同的工具，使用的脚本语言并不一样，至少主推的脚本语言是完全不同的。jmeter是纯java，首推的脚本语言是java脚本；postman主推的脚本语言是JavaScript；python接口测试用python3（不建议选择python2）。所以，做为一个具有编码能力的测试人员，你要选好你的语言阵营，至少是主要语言。当你选择了主要语言，那么，主要工具的选择才能明确。搭建测试框架的时候，就遇到这样的问题。首先，我选择的主语言是python3，所有，我用django做外层框架。python去写接口没有问题，但在接口性能的组合上，遇到了情况，目前，最流行的开源性能测试是jmeter，但如何将jmeter和python相结合使用？本身2者就各为其主，当然没有很好的合体方式。于是，既然是python阵营，那么就要选择python的性能测试工具，于是，用locust来做内部框架中负责性能的部分，问题解决。
不要盲目崇拜工具；
这个问题实际跟现在的大环境本身就浮躁有关。我们面试任何一家公司的测试岗位时，都会被问到，会不会性能、自动化、安全测试等，会不会用loadrunner，会不会selenium，会不会写脚本。但真正进了公司后才发现，TMD天天做功能，老板还时不时的要你去写需求文档，跑市场，公司的软件不超过100个人使用，测试都没有完成，用户就急忙要，赶工期时恨不得来一个“意念测试”，一秒中出结果。而像jmeter、loadrunner这样的工具，实际上是很强大的，你能用好10%就很不错了，你的公司能用上10%就算你的公司牛逼了。很多公司到“注销”的那一天，都没有去想过使用这些工具的目的是什么。所以，不要盲目崇拜工具，而要实事求是的根据公司自己的情况来选择工具，不一定你一定需要这些工具。
从基础做起 接口测试，我建议用python自己写出来。每一个接口，自己一行代码一行代码的实现，这样是最能理解接口的方式。也许你会认为很费时间，很难，其实，只是你自己能力不够，自己不愿意做而已，技术的东西，本身就是因为“懒”而被创造的，只要你愿意开始，真的不难。python编码能力是最基本的，也非常重要，只有这样你才能做更多的测试内容，才能扩展更多的测试方式。同学，用python一步一步把接口写出来吧
接口测试、性能测试的大小维度，实际上很广 这个问题取决于维度的大小。你写一个get去访问百度，用jmeter去压测百度，我们也叫你做过接口测试和性能测试了，对吧。你用postman去测试了一个模块的几十个接口，那也叫你做过这方面的测试了，对吧。但我认为，做测试，也要像软件开发一样，一定要有项目的概念，将测试定义为项目的维度去做。这样的好处是
（1）所有测试成果可以被“沉淀”到一个地方；
（2）所有测试工作可以被“控制”在一个界限中；
（3）避免测试工作的重复性；
（4）测试工作生成物可在一个标准下被最大化复用；
（5）工作透明；
还有其它的很多好处，大家试了才知道！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16e53dc5e946a580c1d314f09a43a9c6/" rel="bookmark">
			解决Python报错UnicodeDecodeError: &#39;gbk&#39; codec can&#39;t decode byte 0x80 in position 658: illegal multibyte
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决Python报错–UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x80 in position 658: illegal multibyte sequence 今天在anaconda上新建一个python3.6环境后，使用时报错了：
(base) C:\Users\peter&gt;activate tf (tf) C:\Users\peter&gt;python Python 3.6.7 (default, Feb 28 2019, 07:28:18) [MSC v.1900 64 bit (AMD64)] on win32 Type "help", "copyright", "credits" or "license" for more information. Failed calling sys.__interactivehook__ Traceback (most recent call last): File "C:\Users\peter\AppData\Local\Continuum\anaconda3\envs\tf\lib\site.py", line 410, in register_readline readline.read_history_file(history) File "C:\Users\peter\AppData\Local\Continuum\anaconda3\envs\tf\lib\site-packages\pyreadline\rlmain.py", line 165, in read_history_file self.mode._history.read_history_file(filename) File "C:\Users\peter\AppData\Local\Continuum\anaconda3\envs\tf\lib\site-packages\pyreadline\lineeditor\history.py", line 82, in read_history_file for line in open(filename, 'r'): UnicodeDecodeError: 'gbk' codec can't decode byte 0x80 in position 658: illegal multibyte sequence 网上查阅资料后发现这是win10下特有的问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16e53dc5e946a580c1d314f09a43a9c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4db033ea5cf7bc2e43497d1c16ff082f/" rel="bookmark">
			一文让你搞懂WebSocket原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小编最近在工作上碰到了用WebSocket方式连接客户端和服务端的问题，顺便研究了一下WebSocket，现在做一下归纳总结，希望通过此文可以帮助您搞懂WebSocket原理。
一、WebSocket简述
首先，象征性的来说说WebSocket是个啥，标准的定义是：
WebSocket是一种在单个TCP连接上进行全双工通信的协议。
说人话就是：WebSocket是一个通信协议，基于这种协议客户端和服务端都可以在同一个TCP连接上主动发起通信请求。
二、WebSocket特点
对于初学者来说，记住WebSocket以下几个特点即可：
使用很简单
支持双向通信，即时性强
长连接
较少的控制开销
三、WebSocket握手原理
在WebSocket API中，客户端和服务端只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。啥都不说，直接看小编我在调试过程中抓包获取的握手协议。
1、客户端：申请协议升级
GET /ums/websocket?id=01030212080000026&amp;terminalType=1&amp;appKey=seeCloud HTTP/1.1 Upgrade: websocket Connection: Upgrade Host: 192.168.15.167:9700 Sec-WebSocket-Key: hkFKN6jn3BRX9hEPWU1zvA== Sec-WebSocket-Version: 13 熟悉HTTP的童鞋可能就发现了，这段类似HTTP协议的握手请求中，多了几个东西。
Upgrade:websocket：表示我发起的是websocket协议请求。
Connection:Upgrade：表示要升级协议
Sec-WebSocket-Key：是一个Base64 encode的值，这个是浏览器随机生成的，告诉服务器，不要忽悠我，我要通过这个验证你是不是真的升级到WebSocket。这个Key与后面服务端响应首部的 Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。
Sec-WebSocket-Version:13：表示WebSocket的版本。
2、服务端：响应协议升级​​​​​​​
HTTP/1.1 101 Switching Protocols Connection: Upgrade Sec-WebSocket-Accept: K9phjpOTC23muj7pYwH/Dn/Jq6o= Server: Jetty(9.3.10.v20160621) Upgrade: WebSocket 其中Upgrade和Connection就是告诉客户端，我服务端已经切换成Websocket协议啦。
Sec-WebSocket-Accept则是返回经过服务器确认，并且加密过后的 Sec-WebSocket-Key。客户端拿到这个key解密就知道服务端是不是忽悠啦~
四、WebSocket通信
以前很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点就是浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。下面我们来看一段对话：​​​​​​​
客户端：有没有新信息(Request) 服务端：没有（Response） 客户端：有没有新信息(Request) 服务端：没有。。（Response） 客户端：有没有新信息(Request) 服务端：没有啊。。。（Response） 客户端：有没有新消息（Request） 服务端：好啦好啦，有啦给你。（Response） 客户端：有没有新消息（Request） 服务端：。。。。。没。。。。没。。。没有（Response） 通过上面这个例子，我们可以看出，这种方式需要很多资源，而根据我们的理解最好的方式就是我需要你，你就在，你需要我，恰好我也在。小编在谈恋爱的时候，也稀饭这种感觉，屏幕前的你呢？哈哈哈~~~~
而WebSocket的出现完美的解决了这么一个问题。于是就出现了下面的对话：​​​​​​​
客户端：洞幺，我要建立WebSocket协议，需要的服务：WebSocket协议版本：13（HTTP Request） 服务端：洞两，ok，确认，已升级为WebSocket协议（HTTP Protocols Switched） 客户端：我需要消息。。。 服务端：暂时没有，有的时候会告诉你的。 服务端：起床了 服务端：吃早饭了。。。 服务端：上班了。。。。 服务端：笑死我了哈哈哈哈哈哈哈 就是这样，只需要客户端经过一次HTTP请求，服务端就可以做到源源不断的给客户端传送信息了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4db033ea5cf7bc2e43497d1c16ff082f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af23648532c59bb404b8d520c0874f7d/" rel="bookmark">
			6.Python3标准库--数学运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		''' 作为一种通用的变成语言，Python经常用来解决数学问题。它包含一些用于管理整数和浮点数的内置类型，这很适合完成一般应用中可能出现的基本数学运算。 而标准库中包含一些用于满足更高级需求的模块。 Python的内置浮点数在底层C语言中是double类型，对于大多数数学运算需求的程序来说，这已经足够精确。 但是如果需要非整数值更为精确的表示，那么decimal和fractions模块会很有用。小数和分数值的算术运算可以保证精度，但是不如原生float的运算速度快 random模块则包含了一个均匀分布的伪随机数生成器，还提供了一些函数用于模拟很多常用的非均匀分布 math模块则包含一些高级数学函数的快速实现，如对数、三角函数。这个模块对原生平台C库中常见的IEEE函数提供了全面的补充 ''' （一）decimal：定点数和浮点数的数学运算 1.Decimal import decimal ''' 小数值被表示为Decimal类的实例。 构造函数取一个整数或字符串作为参数。 在使用浮点数创建Decimal之前，可以先将浮点数转换为一个字符串，以使调用者能够显示地处理值的位数，因为如果使用硬件浮点数表示则可能无法准确的描述。 或者，类方法from_float可以把一个浮点数转换为精确的小数表示 ''' print(f"{'input':&lt;25} {'output':&lt;25}") print("-"*25, "-"*25) # integer print(f"{5:&lt;25} {decimal.Decimal(5):&lt;25}") # string print(f"{'3.14':&lt;25} {decimal.Decimal('3.14'):&lt;25}") # float print(f"{3.14:&lt;25} {decimal.Decimal.from_float(3.14)}") ''' input output ------------------------- ------------------------- 5 5 3.14 3.14 3.14 3.140000000000000124344978758017532527446746826171875 ''' # Decimal还可以使用元组创建，但是不太方面，这里不推荐了。 2.格式化 import decimal ''' Decimal对应Python的字符串格式化协议，使用与其他数值类型一样的语法和选项 ''' d = decimal.Decimal(1.1) print(f"{d:.1f}") # 1.1 print(f"{d:.2f}") # 1.10 print(f"{d:.10f}") # 1.1000000000 3.算术运算 import decimal ''' Decimal重载了简单的算术操作符，所以可以采用与内置数值类型相同的方法来处理Decimal实例 ''' a = decimal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af23648532c59bb404b8d520c0874f7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4128f97064f6ee25be71c65077dc5cce/" rel="bookmark">
			基于vue解决大数据表格卡顿问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点我在线体验Demo(请用电脑查看)
亲测苹果电脑，chrome浏览器无卡顿现象，其它浏览器并未测试，如遇到卡顿请备注系统和浏览器，方便我后续优化，谢谢
先看一下效果,一共1000 X 100 = 10W个单元格基本感受不到卡顿，而且每个单元格点击可以编辑，支持固定头和固定列
Github项目源代码 觉得可以就Star一下,哪里有问题也欢迎指出，感谢 解决问题核心点：根据可视区域，横向滚动加载，竖向滚动加载，控制dom数量 项目背景 笔者最近在做广告排期功能，需要进行点位预占，大的合同可能需要对多个资源排期，周期可能到几年这样，然后我们的页面交互是这样
横向每个月30个单元格，最多的3年，36个月，每行36*30=1080个单元格
竖向100个资源，总共约️10W个单元格，然后每个单元格里面会有一个输入框，一个库存总数，所以总数是20W个，内网使用，接口请求根本不是问题，可以浏览器渲染就扛不住了接口回来之后会出现几十秒的白屏，整个页面处于卡死状态
这还不算，加载出之后页面操作也是非常卡，滑动延迟严重，页面基本处于瘫痪状态
之前的功能是基于jquery开发的，项目重构用的vue,UI采用了ElementUI，ElmentUI中的表格在数据量较大是有严重的性能问题，最直接的表现就是白屏时间较长，而且会出现渲染错乱
所以就想着自己实现一个表格，解决卡顿问题
实现思路 表格拆分，动态加载 表格横向按月拆分，每个月份单独一个table，月份table外层放一个占位div，根据横向滚动位置控制展示
竖向按资源拆分，同样包裹一个占位div,按照滚动位置动态加载，始终保持dom数量上线
动态编辑，按需生成编辑输入框 不同的标签在浏览器渲染时性能是不一样的，比如input这种标签就比span等标签重许多，所以不能满屏input 方案就是点击单元格展示输入框，焦点丢失移除，此处的展示非display控制显示隐藏，而是v-if控制dom是否加载
代码分解 固定头 &lt;div class="table-head"&gt; &lt;div class="module" v-bind:style="{ transform: 'translateX(' + scrollLeft + 'px)' }" v-for="(item, index) in monthData" v-bind:key="index"&gt; &lt;table cellspacing="0" cellpadding="0"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td colspan="30"&gt;{{item.month}}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width="100" v-for="(d_item, d_index) in item.days" v-bind:key="d_index" style="min-width:100px"&gt;{{d_item}}&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; 复制代码 固定列 &lt;div class="table-fix-cloumns"&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4128f97064f6ee25be71c65077dc5cce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24cf8f109b8bc88eca1ab68e88eb3068/" rel="bookmark">
			mac系统下使用ll命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开终端，输入
echo "alias ll='ls -l'"&gt;&gt;.bash_profile source ~/.bash_profile 再输入ll就可以使用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e396abee173cfa558c7e62764367284/" rel="bookmark">
			SQL“一对多”查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的业务中我们都会发现到订单就是一个非常显眼的“一对多”典例。
结构：一个大的订单可以有多个“小订单”（订单详情），每个“小订单”都对应有多个商品。
首先看下表结构：
订单表：（SYS_Order）
订单ID (OrderID) int
订单名称 （OrderName）char
订单日期（OrderDate）date
订单详情表：(SYS_OrderDetaile)
订单详情ID (OrderDetaileID) int
订单ID (OrderID) int
商品ID (GoodsID) int
数量 （GoodsNumber）int
商品表：(PW_Goods)
商品ID (GoodsID) int
商品名称 (GoodName) char
查询某天之前的所有订单内容，包括订单名称、商品名称
SQL代码
select * from SYS_Order Right Join SYS_OrderDetaile on SYS_Order.OrderID = SYS_OrderDetaile.OrderID Inner Join PW_Goods on SYS_OrderDetaile.GoodsID = PW_Goods.GoodsID where SYS_Order.OrderDate &lt;= GETDATE() 右连接 运行结果截图：
上图中，用 right join 右连接 SYS_OrderDetaile表，这样连接是因为这两张表的关系：SYS_Order
是SYS_OrderDetaile 的父表。所以要查出这个订单在SYS_OrderDetaile 中的所有子数据用了 right join ,所以这个订单的所有详情内容都通过 右连接 在子表中查询出来。
我自己是这样记的：谁的数据多就连谁，上图中是订单详情的数据多，那么我就右连接它。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e396abee173cfa558c7e62764367284/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bb8e7f25f0f07e1cb5ea631d101abfb/" rel="bookmark">
			如何在电脑端调试钉钉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，要在钉钉开发者版本中启动微应用调试。启用步骤如下：
进入“我的”(个人资料页)
选择“设置”
选择“通用”
选择“开发者选项”
打开“微应用调试”
其次，用数据线连接安卓手机。
第三，在安卓手机的开发者选项中开启手机的USB调试。
第四，在Chrome浏览器中输入chrome://inspect/#devices，找到要调试的页面，点击“inspect”。
第五，连接上***，这样才能打开调试的窗口，否则弹出的窗口可能是空白或者显示404之类。
转载于:https://www.cnblogs.com/zhb7769/p/10556689.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db79dc258c00ebcf01315676506d6dda/" rel="bookmark">
			【C&#43;&#43;】 为什么建议代码尽量不要使用 using namespace std
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using namespace std； 首先我们要知道，这句代码的意思是：打开标准命名空间，即告诉编辑器我们将要使用名字空间std中的函数或者对象。
using 顾名思义就是正在使用的意思。
namespace 的引用是为了解决不同space中命名相同导致命名冲突的问题。使用using namespace …的引用可以让编译器准确的找到我们需要的函数或者对象，能有效的提高程序员写代码的效率，但这些都和性能无关，仅仅对程序员有利。
std 是个名称空间标识符，C++标准库中的函数或者对象都是在命名空间std中定义的，所以我们要使用标准库中的函数或者对象都要用std::来限定。
只是在std 标准空间里，包含了原来的库和头文件。但是在C++ 中因为我们要使用的STL中有部分名称是没有加下划线的保留标记的，而这些名称如果再用在自己的源代码中 就会引发未定义的后果。
所以当我们在写成熟的代码的时候，一般不建议将标准命名空间全部打开，而是需要用库里的什么就打开什么。这就有效的防止了命名冲突
下面是std中常用的标准对象 cin&gt;&gt;标准输入，cout&lt;&lt;标准输出，endl 换行和函数string 字符串 在代码中的三种使用。
第一种使用：使用using namespace std; 完全打开std 命名空间 --不安全，超简单 需包含&lt; iostream&gt;头文件，再在include后面使用 using namespace std;
注意： 此时可以直接使用std中包含的所有函数和对象。
#include &lt;iostream&gt; using namespace std; int main() { string a; //定义a为字符串 cin &gt;&gt; a; //标准输入a cout &lt;&lt; a&lt;&lt;endl; //标准输出a，并换行 return 0; } 第二种使用：提前打开需要使用的std 中对象/函数 --安全，推荐 需包含&lt; iostream&gt;头文件，再在include后面使用using std::(名称) 依次打开需要的对象。
注意： 使用提前打开的对象时可直接使用，使用未提前打开的对象时需先打开再使用。
#include &lt;iostream&gt; using std::string; // 提前打开需要的名字 using std::cout; using std::endl; using std::cin; //没有打开会报错 int main() { string a; cin &gt;&gt; a; cout &lt;&lt; a&lt;&lt;endl; //运行结果与上面相同 return 0; } 第三种使用：什么时候用什么时候打开std 中对象/函数 --安全，较复杂 需包含&lt; iostream&gt;头文件，每次在使用的地方都用 std::(名称) 打开需要的对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db79dc258c00ebcf01315676506d6dda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df72f54de50975d746ac774491caa8d/" rel="bookmark">
			python pip运行出错 Fatal error in launcher: Unable to create process using &#39;&#34;&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行python pip工具出错的提示： Fatal error in launcher: Unable to create process using '"' 之前还以为是环境变量没有配好，可是我已经检查过了，我的环境变量是已经配过的，
环境变量没问题的同学不用看这一步
没有配过环境变量的，会出现这种问题：
pip的路径一般在安装目录下面的Scripts目录
C:\Users\Administrator\AppData\Local\Programs\Python\Python36\Scripts
把该路径添加到path里面
计算机--&gt;右键----&gt;属性---&gt;高级系统设置---&gt;环境变量
这样，环境变量就配置好了
解决主要的问题：
首先找到python的安装包，注意是安装包
4
打开cmd,输入pip测试：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8be833fb29d4657047749377a03810f3/" rel="bookmark">
			【GPS】在线经纬度距离计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 链接 http://www.hhlink.com/经纬度
输入 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409123d028ffa907d5065f98d255ccaa/" rel="bookmark">
			java消费kafka的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!--kafka依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;/dependency&gt; @Test public void KafkaTests(){ //1.配置属性值 Properties properties = new Properties(); //kafka是服务器地址 properties.put("bootstrap.servers", "192.168.239.200:9092"); //定义消费者组 properties.put("group.id", "test"); //自动提交（offset） properties.put("enable.auto.commit", "true"); //自动处理的间隔时间1秒 properties.put("auto.commit.interval.ms", "1000"); //key和values的持久化设置 properties.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer"); properties.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer"); //2.创建消费者 KafkaConsumer&lt;String, String&gt; kafkaConsumer = new KafkaConsumer&lt;&gt;(properties); //3.订阅消费topic(可以有多个topic) kafkaConsumer.subscribe(Arrays.asList("cctv1")); //4.执行消费的操作 while (true) { //100ms消费一次 //kafkaConsumer.poll(100)读出来，读到records ConsumerRecords&lt;String, String&gt; records = kafkaConsumer.poll(100); for (ConsumerRecord&lt;String, String&gt; record : records) { System.out.println("-----------------"); //打印偏移量，key，value System.out.printf("offset = %d, value = %s"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/409123d028ffa907d5065f98d255ccaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3a043ae29420bfddac5f4f5a7409a53/" rel="bookmark">
			spring restdocs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring restdocs 最近不知道怎么了，我和一个同事疯狂了迷恋上了spring的一些工具型框架，不为人所知但是功能也很强大，今天就记录一下对springrestdocs的研究记录。
rest-docs翻译一下restful风格的文档，这么说跟swagger很像喽？后来我才发现太小看swagger了，作为一个功能性框架springrestdocs的原理没什么亮点，它的功能是生成接口文档，那么springrestdocs跟swagger有什么区别呢？
swagger是在线文档（传说也可以生成离线的），springrestdocs是离线文档swagger是自动生成的，springrestdocs是手动生成的swagger是不可以修改文档格式样式的，springrestdocs是可以修改的（毕竟离线后生成的是个html）swagger是对业务代码中有入侵性的，springrestdocs是不需要修改业务代码的 所以，总体来讲没有swagger好用，但有其优点，对代码没有入侵性，代码里不需要做任何修改这一点甩apidoc几条街，可以自定义文档的格式有好有坏吧，个人还是偏好swagger一点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9821b3df352be25a816fa8f2343b3d6d/" rel="bookmark">
			开源超美css动态背景 可直接引入html文件使用 含注释、可更改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开源超美css动态背景 可直接引入html文件使用 含注释、可更改 1.背景样式 本背景为动态蜘蛛网背景。
上图：
2.如何在html里面引用，作为html背景 1文件目录
放在同一目录下
2 在index.html内引用
&lt;html&gt; &lt;script src="change.js" type="text/javascript"&gt;&lt;/script&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 直接引用就好了，所以很方便可以当做自己以后设计网页的专用包、背景那样。
3.js代码 注：此代码是在网上下载的，要看懂可能需要一点小功夫。所以我给js代码里面加了很多注释，方便大家修改background、一些样式、等等等等
上js代码：
window.onload=function(){ //定义body的margin由默认值8px-&gt;0px document.body.style.margin="0"; document.body.style.background="#30333F"; //创建canvas画布 document.body.appendChild(document.createElement('canvas')); var canvas = document.querySelector('canvas'), ctx = canvas.getContext('2d') //ctx返回一个在canvas上画图的api/dom canvas.width = window.innerWidth; canvas.height = window.innerHeight; canvas.style.position='fixed'; ctx.lineWidth = .3; ctx.strokeStyle = (new Color(150)).style; //定义鼠标覆盖范围 var mousePosition = { x: 30 * canvas.width / 100, y: 30 * canvas.height / 100 }; var dots = { nb: 1000,//Dot的总数 distance: 50, d_radius: 100, array: [] }; //创建颜色类，Color类返回字符串型rgba（*,*,*,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9821b3df352be25a816fa8f2343b3d6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9019fde5e1a154b970185405b9a9f1a/" rel="bookmark">
			教你搭建属于自己的私人云服务器 再也不怕网盘关闭了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		还记得两年前的幸福时光，那时候115网盘如火如荼，360网盘36T的超大容量也在免费送，百度云还免费，趁机撸到的3T百度云盘用的妥妥的。配合上百度云盘的客户端，实时同步文件，感觉那不是一般的爽。但是好景不长，最近的一年多时间，百度云开始收费了，115也挂了。最不能忍的就是百度云，限速不是一般的蛋疼。区区不到100kb/s的速度，和家里100M的宽带相比，真心不能忍了。
随着国内网盘越来越靠不住，自建网盘无疑是一个不错的选项，下面来讲讲如何搭建属于自己的私人云服务器，即私有网盘。搭建私有云可以用自己的电脑，也可以购买云服务器，通过“尊托云数zuntop.cn”购买国内大品牌云服务器可以享受高达7500元代金券免费领取及50%优惠。
搭建私有云网盘，有几个不错的网盘程序可以选择:
Seafile
安全、可靠、快速的企业云盘 Seafile 是一款开源的企业云盘，注重可靠性和性能。支持 Windows, Mac, Linux, iOS, Android 平台。支持文件同步或者直接挂载到本地访问。很好用的同步云，全平台支持，饱受好评。官网：https://www.seafile.com/home/
KODExplorer
可道云-资源管理器，功能十分丰富强大，而且界面精致友好，可道私有云软件具有以下特色：
像使用操作系统一样使用体验,右键操作,拖拽,快捷键……
完美取代FTP管理：可用于服务器文件管理,支持图片、音乐、视频预览，在线解压缩，文件夹拖拽上传……。
框中选择,拖拽移动,拖拽上传,在线编辑器,影音播放器,解压缩。全面ajax保证性能和体验！
各个功能直接无缝连接；以对话框形式存在,多任务管理等功能
完备的中文支持，各种情况下乱码解决；
超快的速度：全面采用Ajax+Json进行数据通信,毫秒级的响应速度；
全平台兼容性：Win Linux Mac (Apache、Nginx、IIS)
完备的中文支持，各种情况下乱码解决；
官网地址：//www.kalcaddle.com/
接下来我们看看用可道云如何搭建私人云服务器网盘
可道云采用windows操作界面，具有专业在线编辑器，支持Office的在线预览和编辑，可多人协同编辑作业，文档历史版本回溯；更有Photoshop、Ai、AutoCAD等专业文档的在线预览，很适合办公用户。作为网盘使用，具有一键分享文件，支持生成外链；扫描二维码，手机即可快速查看；可设定到期时间、提取密码、下载权限，满足更多场景需求，轻松将文件分享给客户、同事查看。还有很多插件可供选择。当然可道云很大的优点就是无需数据库，在服务器、VPS、虚拟空间、各种NAS、甚至部分路由器上都可以直接安装使用。
安装分为linux环境安装和Windows下安装，先windows下的安装：
一、配置PHP环境（本教程使用Xampp 安装包）
1.下载Xampp 安装包。
中文官网下载地址 ： https://www.apachefriends.org/zh_cn/download.html。
2.安装xampp。下载后一步步点击安装即可。
3. xmapp服务的开启。
点击Apache 中的start开启服务；
点击mysql中的start开启服务 ；
点击Apache中的admin 访问 http://localhost/xampp/splash.php
点击“中文”访问：http://localhost/xampp/index.php ，出现以下页面，基本完成了xampp的安装了。
下面是linux环境下的安装：
PHP环境配置
1、可以在串口使用getconf LONG_BIT 命令来查看并确定linux操作系统版本
输出：32表面系统是32位。
输出：64表面系统是64位。
2、下载与自己操作系统相适应版本的xampp
[32bit] wget https://sourceforge.net/projects/xampp/files/XAMPP%20Linux/5.6.14/xampp-linux-5.6.14-4-installer.run
[64bit] wget http://sourceforge.net/projects/xampp/files/XAMPP%20Linux/5.6.14/xampp-linux-x64-5.6.14-0-installer.run
3、安装xampp，为私有云安装构建阿帕奇和php环境
4、启动xampp，执行/opt/lampp/lampp start启动服务
三、下载和安装可道云kodexplorer
1、下载最新版本的可道云KodExplorer程序
下载地址：http://kodcloud.com/download.html
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9019fde5e1a154b970185405b9a9f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cdc50fcf677f868e49873d9071b8940/" rel="bookmark">
			18B20驱动小经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写命令时P14拉高在最后
在读命令时P14在拉低后拉高
转载于:https://www.cnblogs.com/a1113775906/p/10546637.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c00b95556463ca4242c3eddaa977f96/" rel="bookmark">
			机器学习中的特征程与模型调优，sklearn用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据处理、特征工程、特征选择 数据处理
分析数据的分布模式，发现异常值/噪声（boxplot、quantile）pandas工具库：数据类型(时间型读成字符串），数字形态的类别型（没有大小关系）缺失值：缺失比例，缺失数据为数据型/类别型时间序列：趋势分析(连续值displot、类别型countplot/value_counts)，主要包括单维度分析、关联维度(corr,heatmap)业务数据中做建模：最有效的特征通常时统计特征（怎么做统计、有那些类别的列可以作为groupby的对象，有哪些数据类型的列可以用于统计聚合)。特别留意置信度，总数很小的时候，统计值不稳定，比例型特征稳定度高于绝对值 特征工程
数值型
幅度缩放(归一化)
离散化/分箱分桶(等距pd.cut、等频pd.qut)(非线性/加速/特征交叉/健壮性)
统计值（max min quantile)
四则运算
幅度变换（有一些模型对于输入数据有分布假设，lr假设输入连续值特征符合正态分布，可以使用log1p/exp）
监督学习分箱（用决策树建模，用决策树学习连续值划分方式，把决策树中间节点取出来作为组合特征），sklearn.DecisionTree中有个apply函数，可以用于监督学习分箱
类别型
one-hot-encoding
label-encoding
binary-encoding
category-encoding(利用贝叶斯的先验做一些变换)
时间型
时间点/时间段（星期几、几点钟）
时间分组（工作日、周末、法定节假日…)
时间间隔（距离当前为止…)
和数值型一起做统计特征的时候，会选区不同的时间窗
文本型
词袋模型
tf-idf
lda
word2vec/word embedding
特征选择
过滤型(filter)，可以根据一些卡方检验等做一些过滤
包裹型(wrapper)
嵌入型（embedded)
基于树模型去判断特征的重要去，做实验去筛选
简单工具 缺失值处理
pandas fillna
age = df_train['Age'].fillna(value=df_train['Age'].mean()) df_train.loc[:,'Age']=age sklearn Imputer
from sklearn.preprocessing import Imputer imp = Imputer(missing_values='NaN', strategy='mean', axis=0) age = imp.fit_transform(df_train[['Age']].values) df_train.loc[:,'Age']=age 幅度变换 numpy+apply
import numpy as np log_age = df_train['Age'].apply(lambda x:np.log(x)) df_train.loc[:,'log_age'] = log_age #对几列数据同时进行操作 import pandas as pd import numpy as np df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c00b95556463ca4242c3eddaa977f96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85a7526dc60fc348d91f7959af152679/" rel="bookmark">
			Opencv--findHomography 与 getPerspectiveTransform异同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 两者联系：
都用于计算单应矩阵，即解一个线性方程组。由于单应矩阵有8个未知数（3*3，其中第9个数为1），所以至少需要4个点（每个点-x,y,提供2个约束方程）。
两者区别：
1.计算方法不同：通过跟踪源码，发现getPerspectiveTransform用的是SVD分解，findHomography看不出是用什么方法（没注释，一堆等式）。但两者计算结果是一样的。
2.输入参数不同：getPerspectiveTransform只会拿前4个点去计算，findHomography则会拿一堆点(&gt;=4)去计算(其是不断从一堆点中重复拿出4个点去计算出一个结果，再采用一些优化算法RANSAC/LMEDS去筛选出最优解)。
转载自：https://blog.csdn.net/abc20002929/article/details/8709902 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/087512a335fd311a6e5882a1afa5f405/" rel="bookmark">
			Python数据挖掘学习笔记（7）频繁模式挖掘算法----FP-growth
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、相关原理 FP-Growth算法是韩嘉炜等人在2000年提出的关联分析算法，它采取如下分治策略：将提供频繁项集的数据库压缩到一棵频繁模式树（FP-tree），但仍保留项集关联信息。在算法中使用了一种称为频繁模式树（Frequent Pattern Tree）的数据结构。FP-tree是一种特殊的前缀树，由频繁项头表和项前缀树构成。FP-Growth算法基于以上的结构加快整个挖掘过程。
FP-growth算法只需要对数据库进行了两次扫描，而Apriori算法对于每个潜在的频繁项集都会扫描数据集判定给定模式是否频繁，因此FP-growth算法的速度要比Apriori算法快。在小规模数据集上，这不是什么问题，但是当处理大规模数据集时，就会产生很大的区别。大致流程如下图：
关于FP-growth算法需要注意的两点是：
（1）该算法采用了与Apriori完全不同的方法来发现频繁项集
（2）该算法虽然能更为高效地发现频繁项集，但不能用于发现关联规则。
从FP-growth算法挖掘频繁项集这个流程图中可以看出，FP-growth算法主要有两个步骤，即构建FP树以及从FP树中挖掘频繁项集。
其他相关原理可查看相关文章，推荐机器学习实战一书。
二、编写代码 1、数据初始化方法：
#创建数据集 def loadSimpDat(): simpDat = [['r', 'z', 'h', 'j', 'p'], ['z', 'y', 'x', 'w', 'v', 'u', 't', 's'], ['z'], ['r', 'x', 'n', 'o', 's'], ['y', 'r', 'x', 'z', 'q', 't', 'p'], ['y', 'z', 'x', 'e', 'q', 's', 't', 'm']] return simpDat #数据格式化 def createInitSet(dataSet): retDict = {} for trans in dataSet: #print(trans) fset = frozenset(trans) #print(fset) retDict.setdefault(fset, 0) #返回指定键的值，如果没有则添加一个键 #print(retDict) retDict[fset] += 1 #print(retDict) return retDict 2、FP的数据结构类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/087512a335fd311a6e5882a1afa5f405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f6950366b061d15251a750e778dcb0/" rel="bookmark">
			jquery怎么获取name的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 name是input标签的属性值，jQuery提供了attr() 方法用于设置/改变属性值
$("input:text").attr("name"); $("input:text").prop("name"); // 也可以使用prop()方法获取属性` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eaab50fc5b5ccba9c2e0366bad79dcf/" rel="bookmark">
			二进制和位运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2进制 什么2进制？计算机为什么使用2进制 逢2进1的计数规则
电子设备设计成处理2进制，其成本最优。
计算机如何解决人类和计算机直接的机制矛盾 所有编程语言都是一种人和计算机之间的翻译工具，人的数组语言翻译成二进制给计算机读取，然后把计算机的二进制数据翻译成人类的语言呈现出来。
16进制 16进制用于缩写（简写）2进制，将2进制从后向前 每4位数转换为1位16进制。
补码 补码： 将固定位数的2进制数分一半作为负数使用的编码规则。其目的是为了解决负数计算问题。
以4位补码为例研究补码的编码规则! 将4位2进制分一半作为负数使用。
这种规则下减法也可以用加法来计算，相邻两个数顺时针方向增加1。
二进制的换算 从0到最大值的计算无需多说，就按二进制来算就行。
负数的二进制换算方法：负数可以跟-1比较，-1是所有位都为1，拿到一个二进制负数，只要看它比-1小多少就可以算出它对应的十进制数：
11111111 11111111 11111111 11101010
11111111 11111111 11111111 111111111（-1）
以上面这个数为例，上面这个数比-1少了（1+4+16=21），所以它的十进制就是-1-21=-22.
相反数的对应关系 在这种编码规则下还有个特点，就是一个数求反再加一就是它的相反数，即：n=~n+1;
经典面试题目：
System.out.println(~100+1); 如上代码的输出结果： A. -99 B.-100 C.-101 D.-102 答案：B 100 00000000 00000000 00000000 01100100 ~100 11111111 11111111 11111111 10011011 -101 ~100+1 11111111 11111111 11111111 10011100 -100 System.out.println(~100); 如上代码的输出结果： A. -99 B.-100 C.-101 D.-102 答案：C 2进制运算(位运算) 位运算符有：
与 &amp; 、 或| 、异或^、取反~ 、左移位&lt;&lt; 、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eaab50fc5b5ccba9c2e0366bad79dcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa0107ac56e59befad8030f7c7edba40/" rel="bookmark">
			解决一次服务器病毒被杀的情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 下午查看服务器的时候，突然发现服务器突然变得很卡。查看进程的时候发现有个叫blil的进程占有大量CPU资源，最高达到CPU60%的资源。
第一步，直接删除病毒和定时启动程序 搜索blil地址，在/etc/下，调用rm -rf /etc/blil删除该文件
清空/var/spool/cron/root内容，解决定时启动的问题。
结果：解决失败，病毒文件会定期生成，并启动。
第二步，查询日志 boot.log 系统启动日志
cron.log 定时器日志
secure SSH日志
message 系统消息
最后发现，最新的日志，基本都被删除了，看不到数据，恰好在历史上看到过去的记录没有删除。
结果：找到了c.21-2n.com ，问了下度娘，基本可以确定是挖矿的病毒网站，经友人提示，还是门罗币的挖矿病毒。
第三步，分析病毒文件 shz.sh，主要是去w.3ei.xyz下载病毒文件。涉及w.3ei.xyz 这个域名
initdz，这是个主要的病毒传播软件，分析结果如下
软件的主要目录是在/etc下
使用一个另外的目录替换了rm程序。
在/etc/init.d/目录下创建了一个执行程序，执行ats文件，这个ats大概意思就是在重启的时候，启动initdz程序
他会自动去指定的网站下下载病毒文件，并反复执行
解决方案
删除修改hosts和hosts.deny，把那些可以下载病毒文件的网站都加入黑名单。
备份并删除相关病毒文件
文件列表
删除程序的文件的过程中，发现病毒程序还会把文件给锁定，防止删掉。
结果：发现病毒文件还是会执行，而且这次换方式了，会不停的生成一个新的文件名来，然后执行。
第四步，检查监听常驻程序 因为那个文件是定时自动生成的，每次删除后，每隔一会就会自动生成，所以怀疑还有个病毒文件以某种情况启动，并定时检查病毒文件的状态，并启动挖矿软件。
怀疑有病毒驻在内存，检查服务服务状态systemctl，因为有一个病毒文件改名成systemctl放在上面，怀疑以service方式启动。发现没有问题
检查ps线程，ps -A 命令可以查看当前用户线程，初步没有查看到异常线程。初步没发现线程
怀疑还是通过系统漏洞进来的，开启系统防火墙，关闭非必要的一切其他接口。
结果：问题解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05bd32c985e9803b476cb2a3d9ff4fce/" rel="bookmark">
			Java16个原子类介绍-基于JDK8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 emmmm，在写文章前我也翻阅了好多资料和书籍，其实大家在对原子类方法的使用介绍基本都没问题，但是对于java中原子类的个数是五花八门，下面我就把自己都认知和书籍资料结合起来给大家简单都介绍下java中原子类的应用。
参考文献
《Java并发编程的艺术》
正文 关于原子类个数说明 在JDK7包括7之前，java原子类有12个，图片如下，有些资料说有13个，多出来的是 AtomicBooleanArray 类，可是我在JDK8之前的源码里并没有发现有这个类，当然我也没去8以上的版本去看，所以这里不确定这个类到底在哪个版本中存在。
在JDK8时出现了4个原子操作类，分别是如下图片所示
原子更新基本类型类 使用原子的方式更新基本类型，Atomic包提供了以下3个类。
AtomicBoolean: 原子更新布尔类型。 AtomicInteger: 原子更新整型。 AtomicLong: 原子更新长整型。 以上3个类提供的方法几乎一模一样，以AtomicInteger为例进行详解，AtomicIngeter的常用方法如下： int addAndGet(int delta): 以原子的方式将输入的数值与实例中的值相加，并返回结果。 boolean compareAndSet(int expect, int update): 如果输入的值等于预期值，则以原子方式将该值设置为输入的值。 int getAndIncrement(): 以原子的方式将当前值加 1，注意，这里返回的是自增前的值，也就是旧值。 void lazySet(int newValue): 最终会设置成newValue,使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 int getAndSet(int newValue): 以原子的方式设置为newValue,并返回旧值。
代码示例
static AtomicInteger ai =new AtomicInteger(1); public static void main(String[] args) { System.out.println(ai.getAndIncrement()); System.out.println(ai.get()); } 输出结果
1
2
下面我们看看getAndIncrement() 是如何实现原子操作的
public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1); } public final int getAndAddInt(Object var1, long var2, int var4) { int var5; do { var5 = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05bd32c985e9803b476cb2a3d9ff4fce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6905f09f7bfdc52e9dcb5a8862082953/" rel="bookmark">
			/lib64/libc.so.6: version `GLIBC_2.14&#39; not found问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Ubuntu 制作好的交叉编译工具链，在Red Hat中执行时报错：/lib64/libc.so.6: version `GLIBC_2.14' not found
本文使用的Red Hat系统的信息如下图所示
出现这个错误的原因是：Red Hat系统的glibc版本太低，而编译arm-linux交叉编译工具链的Ubuntu 系统中使用了较高版本的glibc
1、查看系统glibc支持的版本
2、查看系统已安装的glibc
所以编译一个glibc来解决这个问题，本文使用的是glibc-2.14.tar.xz这个版本。
wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.xz tar -Jxvf glibc-2.14.tar.xz cd glibc-2.14 mkdir build cd build/ ../configure --prefix=/opt/glibc-2.14 make -j4 make install export LD_LIBRARY_PATH=/opt/glibc-2.14/lib:$LD_LIBRARY_PATH 最后，验证问题是否解决。
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4396dab4fab434f638d1d24fef62ca57/" rel="bookmark">
			sql语句---用户权限设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、创建用户（基于mysql.user表）
2、授权
（1）给数据库中的表赋予权限
（2）查询权限
用户授权
用户名user主机host密码password 1、创建用户（基于mysql.user表） 创建用户 CREATE USER 用户名@主机; 创建用户并添加密码 CREATE USER 用户名@主机 IDENTIFIED BY "密码"; 允许用户远程登录 create user laobian1@'%' iidentified by "1234"; //允许10.10.65.0~10.10.65.255以laobian1登录mysql： create user laobian@'10.10.65.%' identified by "1234"; 允许10.10.65.250~10.10.65.255以laobian2登录mysql: create laobian2@'10.10.65.25%' identified by "1234"; 允许10.10.65.20~10.10.65.29以laobian3登录mysql: create laobian3@'10.10.65.2_' identified by "1234"; 删除用户 drop user laobian@10.10.65.250; 2、授权 常规权限(增删改查)
查询权限select插入权限insert更新权限update删除权限delete创建权限create （1）给数据库中的表赋予权限 GRANT COMMAND ON DATABASE.TABLE TO USER@HOST grant select,insert,delete,update,create on laobian2.* to 'laobian2'@'10.10.65.%'; grant insert on laobian2.person2 to 'laobian2'@'10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4396dab4fab434f638d1d24fef62ca57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cb6d31a0eeb8d54c71f0915fcd7c907/" rel="bookmark">
			spring boot拦截器中获取request post请求中的参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有一个需要从拦截器中获取post请求的参数的需求，这里记录一下处理过程中出现的问题。
首先想到的就是request.getParameter(String )方法，但是这个方法只能在get请求中取到参数，post是不行的，后来想到了使用流的方式，调用request.getInputStream()获取流，然后从流中读取参数，如下代码所示：
String body = ""; StringBuilder stringBuilder = new StringBuilder(); BufferedReader bufferedReader = null; InputStream inputStream = null; try { inputStream = request.getInputStream(); if (inputStream != null) { bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); char[] charBuffer = new char[128]; int bytesRead = -1; while ((bytesRead = bufferedReader.read(charBuffer)) &gt; 0) { stringBuilder.append(charBuffer, 0, bytesRead); } } else { stringBuilder.append(""); } } catch (IOException ex) { e.printStackTrace(); } finally { if (inputStream !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cb6d31a0eeb8d54c71f0915fcd7c907/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbb8d5d91be6ea4f0bb06ae7254cc4ce/" rel="bookmark">
			C&#43;&#43;常见崩溃问题分析处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++常见崩溃问题分析处理 使用Visual Studio 2013进行c++编码的时候经常会遇到一些编译不通过或者编译通过了链接出错，好不容易运行了又出现崩溃的问题，第一种问题编译器会自动检测出来，这种只需要仔细看错误描述就能知道问题出在哪，最麻烦的就是运行中崩溃了。
我整理了一些c++常见的错误，并进行了分析，给出了解决方案。（记录下来以便后面解决问题）
1、编译链接错误 （1）error C1083：很明显可以看出是找不到该头文件；
解决方案：去编译环境（debug/release）查看是否有该头文件，添加上头文件即可解决；
（2）error LNK2001：无法解析的外部符号，目前发现有三种可导致该错误
① 在.h文件中定义了静态变量num，却没有在.cpp文件中进行显式初始化；
解决方式：在.cpp文件中加上int CMainWnd::num=0;
② 在使用动态库时候，没有包含相应的lib；
解决方案：#pragma comment( lib,“xxxx.lib”)；
③ 函数只在类中声明了而没有进行定义；
解决方案：为声明的函数添加函数实现；
（3）error MSB8020：移植项目的时候经常会出现这个问题，描述是平台工具v141找不到；
解决方案：右键项目属性-配置属性-常规-平台工具集下将工具改成自己的即可解决（通过下图可以很清楚的看到问题，v141未安装，需要选择自己常用的平台工具）；
（4）error C1189：提示信息是使用/md[d]（crt dll版本）生成MFC应用程序需要MFC共享dll版本；
解决方案一：右键项目属性-配置属性-常规-MFC的使用改为在共享dll中使用MFC；
解决方案二：右键项目属性-配置属性-C/C+±代码生成-运行库改为多线程调试（/MTd）；
（5）error C2146，error C4430：提示信息是缺少“ ; ”，可是你会发现无论怎么看这个第9行的代码都没有问题，此刻就需要关注这个类型PCMainWnd，右键查找定义，会发现它其实被定义在.cpp文件中，却在.h中使用就会出现这种错误；
解决方案：如果必须在.h中使用这个类型，就先声明这个类，再定义这个类型PCMainWnd，即可编译通过（具体修改看下方代码）；
class CMainWnd; typedef CMainWnd *PCMainWnd; class CMakePNG { private: PCMainWnd m_pWnd; }; 2、运行崩溃 上面列举了几个编译链接出错的问题，接下来看一些运行崩溃的问题，今天先说一下访问内存出错。访问内存出错的几个常见问题如下表：
内存访问出错原因数组越界下标为负数或大于数组的长度指针越界超出指针分配的范围字符串越界字符串结束符不存在或目标字符串缓冲区小于源字符串访问野指针内存已被回收后又使用这个指针，会造成无法预估的错误访问空指针指针所指地址为NULL （1）数组越界，不一定报错，但是数据会被破坏，还有可能造成死循环
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPSTR /*lpCmdLine*/, int nCmdShow) { int i = 0; int arr[10] = { 0 }; for (i = 0; i &lt;= 15; i++) { arr[i] = 0; } return 0; } 上面这段代码就会造成死循环，局部变量都在栈上存储，先定义的i在高地址，数组的地址是随着小标的增长而增长，后定义的arr数组，&amp;arr[9]是数组的最后一个地址，当数组越界到合适的时候就到了i的位置，会存在&amp;arr[x]=&amp;i；将arr[x]改为0的同时，i值也变为0，会再次从i=0进行循环，就造成了死循环。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbb8d5d91be6ea4f0bb06ae7254cc4ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ed25f485a9b3acf94bd9f71c3443f2f/" rel="bookmark">
			@Select注解的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Select注解的使用 简便、快速去操作sql 简便、快速去操作sql 在我们平常的应用中往往需要用到mybatis去操作一些原生的sql，也可以应用到一些复杂的应用场景， 面对这些场景我们难免会自己编写sql。 不过多解释，一下两种是自己对一些简单的实现常见操作sql的应用：
1、 只需要在mapper中方法上加入@Select()，然后在括号中写入需要实现的sql语句即可
例如：
@Select(“select * from System where id = #{id, jdbcType=LONG} and code= #{code, jdbcType=VARCHAR}”)
SystemConfig selectSysConfigById(@Param(“id”) Long id, @Param(“code”) String code);
当然上面的例子中jdbcType类型可以省略，只需字段的类型对齐好数据库中的字段类型即可。
2、 另外一种方式就是像我们通常写的xml类似，在注解中使用等相关的标签来实现我们复杂的语句，但是必须在外面一层用标签将sql语句含入进去
例如：
@Select("&lt;script&gt;select COUNT(p.ID) from MM_LIST p, USER c where p.USER_ID = #{userId} and p.USER_ID = c.ID &lt;if test=“status != null and status != ‘’”&gt;and p.STATUS = #{status}&lt;/if&gt; &lt;if test=“code!= null and code!= ‘’”&gt;and p.CODE = #{code}&lt;/if&gt;&lt;/script&gt;")
Long selectUserListCount(@Param(“code”) String code, @Param(“status”)String status, @Param(“userId”)Long userId);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ed25f485a9b3acf94bd9f71c3443f2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6a406a5b52ac0f8032bfe9b392fd6ec/" rel="bookmark">
			mybatis驼峰命名属性功能与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.本例环境: springboot + mybatis + IntelliJ IDEA 2.功能:
数据库字段,一般都用下划线分隔例如employee表的姓名字段last_name;但是Model等实体对象中的属性,一般用驼峰命名,例如lastName;使用mybatis驼峰命名属性后,表字段last_name能自动映射到表对应实体对象的lastName.
3.springboot集成mybatis后可以如下配置
方式一:
在application.yml配置
mybatis: # 指定sql映射文件位置 mapper-locations: classpath:mybatis/mapper/*.xml configuration: #开启驼峰命名 map-underscore-to-camel-case: true 方式二:
1&gt;.在application.yml配置
mybatis: # 指定全局配置文件位置 config-location: classpath:mybatis/mybatis-config.xml # 指定sql映射文件位置 mapper-locations: classpath:mybatis/mapper/*.xml 2&gt;.在mybatis-config.xml配置
&lt;settings&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;/settings&gt; 方式三:
1&gt;.在在application.yml配置
mybatis: # 指定sql映射文件位置 mapper-locations: classpath:mybatis/mapper/*.xml 2&gt;.添加自动自动配置类
@Configuration public class MybatisConfig { @Bean public ConfigurationCustomizer configurationCustomizer(){ return new ConfigurationCustomizer(){ @Override public void customize(org.apache.ibatis.session.Configuration configuration) { configuration.setMapUnderscoreToCamelCase(true); } }; } } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6a406a5b52ac0f8032bfe9b392fd6ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9236fc0f92c6720be8105d7a8d090bb8/" rel="bookmark">
			docker-compose创建网桥，添加子网，删除网卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建docker网卡
[root@i ~]# brctl addbr docker0 [root@i ~]# ip addr add 192.168.42.1/24 dev docker0 # 这里的ip是给docker内部用的, 随意配置一个即可 [root@i ~]# ip link set dev docker0 up [root@i ~]# ip addr show docker0 # 查看docker [root@i ~]# systemctl restart docker [root@i ~]# systemctl restart docker # 启动docker服务 2.添加子网
[root@i ~]# docker network create backend # 这样我们就创建了backend子网，docker-compose就可以直接使用这个network # 如果无法常见子网，则使用下面的命令，跳过安全问题 [root@i ~]# docker network create backend --subnet 172.24.24.0/24 [root@i ~]# docker network ls NETWORK ID NAME DRIVER SCOPE 6afff4d90f05 backend bridge local 57de7f32064e bridge bridge local 4b44a5340d6e host host local ac8e8ffe243f none null local 这里可以看到有backend 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9236fc0f92c6720be8105d7a8d090bb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b219068d242b96b0a3f90266eea8ee7/" rel="bookmark">
			5G时代需要什么样的服务器和数据中心？ | MWC 2019
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 “云+端”的产业模式正向“云边端”迁移，在部分行业已经是正在发生的事实，“云+端”在以连接人与人为中心的移动互联网时代得到长足发展，面向5G开启的万物互联时代，“云边端”将开启下一个十年。 边缘计算的兴起 云边端中的边，指的就是边缘计算。边缘计算的出现解决了三大问题：带宽、时延和安全。 带宽：全球已有500亿终端设备，2120亿的传感器，产生数据44ZB。由于带宽受限，85%的数据没有回传至云端，海量数据价值没有被挖掘————边缘计算让海量数据无需回传云端，就近在边缘计算进行分析，节省了大量的网络带宽资源，海量数据分析成为现实； 时延：未来新兴应用将十分依赖低延时，如自动驾驶、VR/AR等，现有互联网的延时优化手段已无法满足此类应用需求————边缘计算缩短了感知终端与服务器之间通信距离，降低了互联网依赖。让终端与服务器交互高实时性成为现实； 安全：终端数据通过互联网上传云端，网络安全、云端泄密隐患等问题均威胁到了用户的隐私安全————边缘计算可实现在终端敏感数据预处理，将非敏感的分析数据上传云端，可提升IT平台对隐私数据的保护性。 关于边缘计算的定义不一而同，整体意思相近，业界一致同意边缘计算是一种将主要处理和数据存储放在网络的边缘节点的分布式计算形式。有意思的是，随着5G技术的逐步成熟，MEC( Multi-Access Edge Computing，也被称为 Mobile Edge Computing )——在网络边缘为应用开放者和内容服务商提供所需的云端计算功能和IT服务环境，成为行业集中关注的话题。 这也表明，此时的边缘计算已经发生内涵的变化。最早的边缘计算可以追溯到20世纪90年代，Akamai推出了内容交付网络(CDN)，在地理上靠近最终用户的位置引入了节点，相比传统意义上的边缘计算，当下的边缘计算不只是为数据中央端局采集传递数据，“边缘”逐渐变成处理爆炸式数据的主要来源与关键节点。 在云计算时代，终端与云端、核心网互联，在5G与物联网时代，计算能力进一步前移，云与终端之间产生了边缘层，提供边缘计算能力。更重要的是，边缘计算远不仅仅是计算能力，MEC就给行业一个启示，参考中心化的云计算模型已经是一种标准的IT服务平台，边缘计算的未来方向也是如此。 根据B2B分析师MarketsandMarkets的数据，到2022年，边缘计算市场的价值将达到67.2亿美元，年复合增长率35.4％，关键驱动因素是物联网和5G网络的出现，“智能”应用程序数量的增加以及云基础架构负载的增加。 边缘计算服务器 在近日结束的MWC（世界移动通信展），浪潮发布首款基于OTII标准的边缘计算服务器NE5260M5，抱着对边缘计算服务器的好奇心，雷锋网在展台也简单观察了一番，希望透过这款面向运营商定制化的服务器，一窥边缘计算基础设施服务器端的变化。 OTII全称Open Telcom IT Infrastructure，是由中国移动联合中国电信、中国联通、中国信通院和Intel共同发起的服务器开放项目，2017年11月在ODCC服务器工作组立项，目标是形成运营商行业面向电信应用的深度定制、开放标准、统一规范的服务器技术方案及原型产品，浪潮是ODCC核心会员，也是OTII的的重要服务器参与厂商。 浪潮服务器产品部副总经理陈彦灵告诉雷锋网(公众号：雷锋网)，边缘计算服务器对浪潮是一个全新的品类，NE5260M5从2017年开始研发，边缘计算服务器研发的最大问题就是业务场景差异非常大，不同场景需要不同形态的服务器，服务器厂商需要根据不同的场景或者应用进行开发，面对最先落地的通信行业边缘应用场景，浪潮首先开发出适合通信边缘计算的服务器。 第二个挑战是产品形态，通用服务器深度的深度都在700mm以上，浪潮调研了很多边缘侧数据机房，一般在450mm深度，而且不方便维护，和数据中心两面都存在可维护空间完全不同，边缘计算服务器直接背靠机房墙壁，还没有专业散热设备如空调等，这些都是边缘侧服务器和通用服务器不一样的地方。 第三个挑战是远程控制，边缘计算服务器部署地点是网络的边缘，地处偏僻而非集中部署，考虑到运维成本，边缘计算服务器需要有完善的远程维护机制，应对突然掉电等情况，即使在升级过程突然掉电情况，也能恢复到上一个版本继续使用，而不必派专人现场操作。 尽管浪潮官网还没有这款新品参数，但可以确定的是，这款产品机箱尺寸采用了电信设备标准，而非服务器标准，高度为2U，宽19英寸，深度为430mm，仅有传统标准服务器深度的1/2稍多，可以直接与电信设备混合部署在通信中心机架上。 在部署层面，为应对边缘计算机房的简陋条件，NE5260M5针对边缘机房进行了大量的适应性设计，例如壁挂设计wall Mount，可使NE5260M5直接悬挂在墙壁上而不需要机架，适合于环境简陋的边缘数据中心，在耐高温、防尘、耐腐蚀、电磁兼容、抗震等方面也做了增强。 一位通信行业人士表示，网络切片是5G网络的一大特性，这就要求服务器基础设施在硬件层面支持NFV、SDN。X86服务器主要面向计算密集型业务，对NFV的支持不足，因此面向5G时代的边缘计算服务器需要针对NFV应用特点，优化配置均衡成本，NFV服务器的部署也不同于计算、存储服务器的集中模式，对管理的要求会更高。 NE5260M5采用NUMA-Balance架构，一台计算机分成多个节点，节点内部使用共有的内存控制器，节点之间通过互联模块进行连接和信息交互，是时下边缘计算领域受欢迎的架构，同时该产品还支持QAT、远程管理和调试等专用技术。 在有限的空间内，边缘计算服务器需要满足尽可能强大的性能需求，据浪潮介绍，NE5260M5支持2颗英特尔下一代可扩展处理器，16个DIMM，6个PCI-E插槽，6块2.5寸硬盘，2个M.2 SSD，可以满足视频监控、智能制造、物联网等多种边缘计算应用的需求。 数据中心两线生长 腾讯PCG技术运营部总经理刘昕告诉雷锋网，5G时代对于服务器的需求不如说是对数据中心需求产生变化，云计算推动超大型数据中心发展，5G结合边缘计算 将推动模块化、低成本、低功耗数据中心技术发展。 Gartner称，到2025年，80％的企业将关闭其传统数据中心，而2018年则为10％，由各种业务需求驱动的数据处理是这种基础设施发展的关键驱动因素。当然了，这并不是说内部部署或云中心已经死亡，有些数据总是需要在集中位置进行存储和处理，这里所指的传统数据中心指的是集中式，管理一切的数据中心。 陈彦灵认为，边缘计算随着智能化、5G等应用场景不断发展，对应的是新的应用需求，部分原来部署在数据中心的应用会迁移到边缘侧，但对原有的数据中心建设不会有太大影响。 在雷锋网看来，数据中心将呈两条线发展，一条是以云架构定义的超大规模数据中心，一条则是边缘云数据中心，两者结合造就Infrastructure Everywhere的业态。不少厂商已经察觉到了市场变化的风向，比如浪潮，在超大规模数据中心领域拥抱开放计算，在边缘数据中心领域加入OTII，开发适合边缘机房的服务器。 以往数据中心服务器主要两种模式：“单项冠军模式”和“全能冠军模式”，“单项冠军模式”针对于某种特定的服务（比如：需要大量数据转发，需要AI训练或者机器学习）进行深度优化，达到单一场景下的性能极致和各项指标最优。“全能冠军”则更均衡，比如云服务器往往需要综合通用性能，在各个应用中都表现比较全面的硬件设备。 行业客户对于边缘服务器的需求是“全能冠军模式”，希望满足边缘业务部署种类较多，业务范围较广的属性。但是实际条件下，边缘服务器的需求差异非常大，受到边缘硬件的实际物理运行环境的限制，目前服务器厂商只能针对不同的边缘环境开发不同规格的边缘硬件。 据IDC数据统计，到2020年将有超过500亿的终端与设备联网，未来超过50%的数据需要在网络边缘侧进行分析、处理与存储。智能互联的网络边缘侧面临着连接海量异构设备、业务实时性要求、应用智能化要求、安全与隐私要求等众多挑战，与此同时这也是一片新的蓝海，给服务器等厂商增添了新的想象空间。 相关文章： 除了大书特书的自动驾驶，NVIDIA在加密货币、云计算、云游戏和数据中心领域做了些什么？ 用户全程“零感知”？ UCloud是这样做云数据中心整体热迁移的 华为CloudEngine 16800首秀 如何推动数据中心网络从云迈入AI时代 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446305152988d68304aa698b6a43c38a/" rel="bookmark">
			AriaNg 无法连接 aria
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天想做个下载机，然后搞了个aria，但是不可能远程控制使用命令下载，因为退出的时候会自动杀死
安装什么的都不说了
主要问题是，AriaNg 一直无法连接 aria
本来以为rpc没开，然后又重新弄了一番。结果还是不行
突然想起想看6800 端口：
是没有被使用的
想了很久，在宝塔 里面好像有个安全的设置：
尝试把6800给加进去：
然后再看AriaNg：
好吧，可以了。。
//下面这个是查询 端口号被那个占用： netstat -ap|grep :6800 //下面是根据PID杀死某个进程 : //例如： //tcp 0 0 192.168.0.102:6800 192.168.0.101:9815 ESTABLISHED 4206/aria2c kill -9 4206 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a63dd00269da03b4fe52c22929ac389e/" rel="bookmark">
			HIT 软件构造2019春 Lab2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		update: 3/13/2019 未考虑checkRep，RI，AF
update：3/17/2019 改一下MyExp继承RuntimeException
update：3/23/2019 修改P1 poet题目理解，更新poem的stream写法
update：3/24/2019 Edge Immutable条件
Trick： 使用Collection.stream处理满足map-filter-reduce的序列。
DEF： 关于checkRep，RI，AF
QA： 如何检查输入合法？
自定义类继承RuntimeException，如果继承自Exception则需要明确对抛出的Exception进行声明，这里选择RuntimeException，与直接继承Exception相比不需要显示抛出（函数声明throws...），同时也不强制使用try catch捕获（ArrayIndexOutOfBoundsException是一个例子），可以直接在catch中打印错误信息。
MyExp示例：
package P3; public class MyExp extends RuntimeException { //错误信息 private String expMsg="MyException"; public MyExp(String msg) { this.expMsg = msg; } public String getExpMsg() { return expMsg; } public void setExpMsg(String expMsg) { this.expMsg = expMsg; } @Override public String toString() { return this.expMsg+"\t 请重新输入"; } //实现assertTrue的断言功能，如果cond为假则抛出异常，使用该函数进行输入合法判断 public static void assertTrue(boolean cond,String msg) throws MyExp { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a63dd00269da03b4fe52c22929ac389e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcf26a1140da7705535e8b689b9ea46f/" rel="bookmark">
			Linux下关闭防火墙与NetworkManager（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关闭防火墙：
系统：Redhat 7.2
方式：systemctl status firewalld----------查看防火墙状态
systemctl start firewalld ---------- 开启防火墙
systemctl stop firewalld ----------- 关闭防火墙
systemctl disable firewalld ------------ 永久关闭防火墙
systemctl enable firewalld ------------- 开启防火墙
这里，disable与enable只是创建与移除firewalld.service的symlink，再次用status去查看时，并未有变化（网上看别人发的图是变化的）。
系统：Redhat 6.2
方式：service iptables status ---------------------查看防火墙状态
service iptables start ---------------------开启防火墙
service iptables stop ----------------- 关闭防火墙
iptables -L ----------------查看防火墙运行状况，如果没有结果，意味着防火墙并未起作用
iptables -F -----------------清除所有防火墙规则
关闭NetworkManager：
系统：RedHat 7.2
方式：
systemctl status NetworkManager
systemctl start NetworkManager 等等
系统：RedHat 6.2
service NetworkManager status | start | stop
作者：养猫的老鼠
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcf26a1140da7705535e8b689b9ea46f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67942b222c93d17e0f39e639f5a2c058/" rel="bookmark">
			Qt编写通用主界面V2019
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实是2018年做出来的这个界面效果，用该界面做了三四个项目，今天抽空特意提取出来单独的demo，集成到了皮肤生成器中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cfab7bcc6980e0a8834dcd8f5a52aad/" rel="bookmark">
			Love2D游戏引擎制作贪吃蛇游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码地址如下：
http://www.demodashi.com/demo/15051.html
Love2D游戏引擎制作贪吃蛇游戏 内附有linux下的makefile，windows下的生成方法请查看：
for windows
预览游戏 love2d游戏引擎重要函数 详情：
love2d wiki
love.load：当游戏开始时被调用且仅调用一次
love.draw：回调函数，每帧更新一次游戏画面
love.update：回调函数，每帧更新一次游戏状态
love.keypressed：回调函数，当有按键被按下时触发
love.filesystem.load：加载一个lua脚本文件但不执行
！其他的函数在用到时再做解释
版本区别以及初始化资源 ！首先要注意的是，本次使用的游戏引擎时love 0.9版本，与最新的love 11.x版本稍有区别。在0.9版本中颜色使用0～255来表示，而在11.x版本中是0～1来表示。
因为需要制作的游戏非常小，所以我们将所用到的资源在第一时间将其初始化并加载到内存中，以便使用。使用到的资源主要有：
字体
颜色
声音
窗口大小与块大小
标题
边框
所用到的函数：
love.window.setMode：设置窗口大小，以及样式
love.window.setTitle：设置标题
love.graphics.newFont：加载字体文件，大小自定义，返回Font类型
love.audio.newSource：加载音效文件
代码如下：
function love.load () -- 块大小，窗口宽高，标题 cellSize = 20 width = 20 * 40 height = 20 * 25 title = 'SNAKE !' -- 设置窗口大小和标题 love.window.setMode (width, height) love.window.setTitle (title) -- 加载不同大小字体 fonts = { pixies100 = love.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cfab7bcc6980e0a8834dcd8f5a52aad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be4e6463e9c0f6323580c0251f6d19f5/" rel="bookmark">
			免Root实现Android静默安装（非无障碍）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日科技快讯
3月12日，据国外媒体报道，美团点评最新公布的2018年第四季度财报显示，其当季营收增长近一倍。在微信运营商腾讯的支持下，美团正投入巨资与阿里巴巴旗下的外卖平台饿了么以及旅游平台飞猪展开激战。由自2018年IPO筹集42亿美元以来，美团股价已经下跌了15%。
作者简介
本篇来自 gtf 的投稿文章，和大家分享了免Root实现静默安装和点击任意位置（非无障碍），希望对大家有所帮助！
gtf 的博客地址：
https://www.jianshu.com/u/0568a9803652
正文
最近有了个需求：免 root 实现任意位置点击和静默安装。这个做过的小伙伴应该都知道正常情况下是不可能实现的。无障碍只能实现对已知控件的点击，并不能指定坐标。但是确实有人另辟蹊径做出来了，譬如做游戏手柄的飞智，他们是用一个激活器，手机开 usb 调试，然后插在激活器上并授权，飞智游戏厅就被「激活」了，然后可以实现任意位置点击。如果不了解的可以去他们官网了解下，在这里不多赘述了。无独有偶，黑域也使用了类似的手段，也可以用电脑的usb调试激活。我们知道，任意位置坐标xy点击是可以在 pc 上通过 shell 命令「input tap x y」来实现的，也不需要 root 权限。但是在应用内通过「Runtime.getRuntime().exec」执行这个 shell 命令却提示「permission denied」也就是权限不足。但是飞智或者黑域却好像使用了某种魔法，提升了自己的权限，那么问题来了：如何用 usb 调试给 app 提权？
原理揭晓
「如何用 usb 调试给 app 提权」这个问题乍一看确实没问题，但是知乎有个回答是「先问是不是，再问为什么」我觉得说的很好。我被这个问题给困扰了很久，最后发现我问错了。先放出结论「并不是给 app 提权，而是运行了一个有 shell 权限的新程序」。
刚才的问题先放一边，我来问大家个新问题，怎样让 app 获取 root 权限？这个问题答案已经有不少了，网上一查便可知其实是获取「Runtime.getRuntime().exec」的流，在里面用su提权，然后就可以执行需要 root 权限的 shell 命令，比如挂载 system 读写，访问 data 分区，用 shell 命令静默安装，等等。话说回来，是不是和我们今天的主题有点像，如何使 app 获取 shell 权限？嗯，其实差不多，思路也类似，因为本来 root 啦， shell 啦，根本就不是 Android 应用层的名词呀，他们本来就是 Linux 里的名词，只不过是 Android 框架运行于 Linux 层之上， 我们可以调用 shell 命令，也可以在shell 里调用 su 来使shell 获取 root 权限，来绕过 Android 层做一些被限制的事。然而在 app 里调用 shell 命令，其进程还是 app 的，权限还是受限。所以就不能在 app 里运行 shell 命令，那么问题来了，不在 app 里运行在哪运行？答案是在 pc 上运行。当然不可能是 pc 一直连着手机啦，而是 pc 上在 shell 里运行独立的一个 java 程序，这个程序因为是在 shell 里启动的，所以具有 shell 权限。我们想一下，这个 Java 程序在 shell 里运行，建立本地 socket 服务器，和 app 通信，远程执行 app 下发的代码。因为即使拔掉了数据线，这个 Java 程序也不会停止，只要不重启他就一直活着，执行我们的命令，这不就是看起来 app 有了 shell 权限？现在真相大白，飞智和黑域用 usb 调试激活的那一下，其实是启动那个 Java 程序，飞智是执行模拟按键，黑域是监听系统事件，你想干啥就任你开发了。「注：黑域和飞智由于进程管理的需要，其实是先用 shell 启动一个 so ，然后再用 so 做跳板启动 Java 程序，而且 so 也充当守护进程，当 Java 意外停止可以重新启动，读着有兴趣可以自行研究，在此不多做说明」。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be4e6463e9c0f6323580c0251f6d19f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca6bf76751cdc83766fc0d2875124f8f/" rel="bookmark">
			程序员C&#43;&#43;代码实现超酷炫表白，用过的人都找到了对象...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在情人节送给自己的女朋友玫瑰花，对于程序员来说是不是太普通了呢？ 为什么不试试让情人节变得更特别一些呢？作为一名程序员，可以用自己的技术创造出不一样的浪漫！让你的女朋友眼前一亮，印象深刻。这些浪漫的技术表白，你值得拥有。
下面是小编整理好的一套C/C++资料，加小编C/C++学习群825414254获取系统性学习C/C++的学习资料 百度资深的程序员“Peter”，为了给心爱女孩表白悄悄溜进了百度大楼的是中央控制室，写下控制智能灯的程序，在后台定义了文字和动态功效。随后百度大楼上出现了灯光组合的“Ilove u贝贝”字样
I Love You Batch le 送她一个惊喜怎么样？情人节向她示爱，让她的电脑自动关机，然后显示你的表白留言。
具体操作如下：
1.创建一个新的文本文件。
2.将以下代码复制到新创建的文件中
3.将文件的扩展名从“.txt”更改为“.bat”
4.最后一步想办法让你的女朋友打开文件
C++ 我爱你的程序 如果你想像CPP程序员那样求婚，请运行这个
C++ Love Proposal 代码：
程序员C++代码实现表白特效，用过的人都找到了对象…
C语言代码：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f38d9409c6cdee616bd62464e8247ef6/" rel="bookmark">
			Docker搭建MariaDB/Mysql MHA高可用集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker搭建MariaDB MHA高可用集群 制作需要使用的相关镜像 mha4mysql是日本工程师Yoshinori Matsunobu开发的一款MySQL高可用软件。mha4mysql分为两部分，一是管理器部分mha4mysql-manager，二是结点部分mha4mysql-node。mha4mysql-node要运行在每台受管理的MySQL服务器上；而mha4mysql-manager所在服务器则不需要MariaDB，但需要mha4mysql-node。因为mha4mysql-manager依赖mha4mysql-node，即安装mha4mysql-manager前必须先安装mha4mysql-node。
下面讲解一下，基于debian:jessie制作mha4mariadb-manager的Docker镜像和
基于mariadb:10.2.22制作mha4mysql-node的Docker镜像。
mha4mariadb-manager Dockerfile如下
FROM debian:jessie COPY ./mha4mysql-manager.tar.gz /tmp/ COPY ./mha4mysql-node.tar.gz /tmp/ RUN build_deps='ssh sshpass perl libdbi-perl libmodule-install-perl libdbd-mysql-perl libconfig-tiny-perl liblog-dispatch-perl libparallel-forkmanager-perl make' \ &amp;&amp; apt-get update \ &amp;&amp; apt-get -y --force-yes install $build_deps \ &amp;&amp; tar -zxf /tmp/mha4mysql-node.tar.gz -C /opt \ &amp;&amp; cd /opt/mha4mysql-node \ &amp;&amp; perl Makefile.PL \ &amp;&amp; make \ &amp;&amp; make install \ &amp;&amp; tar -zxf /tmp/mha4mysql-manager.tar.gz -C /opt \ &amp;&amp; cd /opt/mha4mysql-manager \ &amp;&amp; perl Makefile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f38d9409c6cdee616bd62464e8247ef6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26d97c8cc17405873f6b94ea1e443ef4/" rel="bookmark">
			VSCode内npm run build编译打包时候报错：code ELIFECYCLE - （已解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 win10系统使用VSCode打包项目进行build编译的时候，报错：Module build failed: Error: "extract-text-webpack-plugin" loader ······？出现该报错问题的原因分析：**`临时解决办法：`**bug截图：相关参考 · 阅读： win10系统使用VSCode打包项目进行build编译的时候，报错：Module build failed: Error: “extract-text-webpack-plugin” loader ······？ 大概的报错内容：Module build failed: Error: "extract-text-webpack-plugin" loader
win7的系统就不会报错。关键是win10的系统单独使用cmd命令编译打包也是OK的！
你说奇怪不奇怪？
出现该报错问题的原因分析： 是？ 环境变量的配置问题？是？ 网络的问题？是？ Win10的坑？ 无论怎么样，误打误撞，好在解决了。（具体原因还在组团深入分析中··· 欢迎留言讨论。）
临时解决办法： 首先：Win + X然后：单击 A调用“以管理员身份运行” CMD面板，cd到项目根目录，最后，执行 npm run build ,应该能正常编译完成。 bug截图： 相关参考 · 阅读： VUE打包时候报错：code ELIFECYCLE，npm install 正常，npm run build 时报错：code ELIFECYCLE
extract-text-webpack-plugin配置出错的解决办法
以上就是关于“ VSCode内npm run build编译打包时候报错：code ELIFECYCLE - （已解决） ” 的全部内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95e1de8cbbeeedfad3bfbe316e3aa332/" rel="bookmark">
			C&#43;&#43;代码实现贪吃蛇游戏，非常适合C&#43;&#43;初学者入门的项目！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一款容易上手的游戏，我相信大家都不会陌生，至少这款游戏是我曾经的回忆。
直到今天。。。。。
下面是小编整理好的一套C/C++系统性学习的资料，加小编C/C++学习群（825414254）获取C/C++一整套学习教程哦！ 我用C++开发了一个简单的自动寻路贪吃蛇游戏：功能和界面比较的单一
功能：
1.自动寻路：开始游戏后小蛇无需人工操作，小蛇自动寻路，吃掉食物
小蛇起始位置10*10坐标(3节蛇)
食物起始位置由食物算法决定
界面：easyx图形库
1.600*600大小的地图
2.背景： 黑色 正方形
3.蛇： 黄色 正方形
4.食物： 红色 矩形
知识点：
对整个贪吃蛇游戏框架需要有一个基本的概念
(1)环境：
1.win10搭建VS2013。
2.VS2013的基本使用。
(2)软件：
1.C++基本的语法与算法。
2.C++类的创建及简单使用。
3.C++多线程。
4.C++定时器与回调函数的简单使用。
5.C++所需要用到的API的简单使用。
创建一个类，所有的函数实现封装在这个类里面，应用层调用即可。
线程实现的思路
多线程：不同的线程负责做不同的事，防止出现单线程系统中的卡死现象，提高实时性。
（线程一）的实现
1.初始化地图。
2.判断游戏是否正常启动(线程开启)。
3.监听键盘是否按下(启动游戏相关操作)。
4.检测蛇是否撞自己或者撞墙(死亡)。
5.绘制小蛇与显示小蛇的移动。
6.判断蛇是否吃到食物。
7.游戏难度系数处理。
（线程二）的实现
判断线程与游戏是否正常启动。
判断地图上面是否有食物
没有食物（食物被吃掉），则开始计算食物坐标位置，计算坐标时根据游戏难度系数来控制食物的位置，食物不能出现在蛇身上，地图范围以外，等等。
计算完坐标后，绘制食物，绘制完成后，再次检测地图上面是否有食物，有就将标志位开启，说明有食物。
（线程三）的实现
1.判断线程与游戏是否正常启动。
2.监听图形界面中的数据，将监听到的数据与正确的数据对比，如果一致说明正常，如果不一致，说明显示的数据有误，开始对显示有误的数据清除并再次显示与再次判断，直到与正确数据一致为止。
（线程四）的实现
1.判断线程与游戏是否正常启动。
2.输入计数值，1000/ms=1秒。
3.启动定时器，开始监听。
4.运行回调函数，回调函数实现
(数据结构) (秒+1)，包含时间算法，逻辑实现。
回调函数
（线程五）的实现
程序的核心算法：自动寻路
关于自动寻路算法对于programmer来说，可能并不陌生，同时对于使用过地图软件的人来说，也不陌生，当你从一个位置到另一个位置的时候，就会用到寻路算法，地图里面的路径规划就是寻路，当你使用地图软件开始导航时，软件就会给出相关的路径，让你参考，这些路径就是由寻路算法根据起点数据和终点数据来计算得到的路径数据。
目前我个人了解到的比较常见的寻路算法有深度寻路，广度寻路，A寻路，B寻路等。
我对这些算法进行了一定的了解与学习，这些算法都各有各的优缺点，大致的了解了这些算法的实现原理。于是开始写自己的算法，完成了自动寻路。
（当然肯定还有BUG）
下面来对本次算法的实现原理及过程进行分析分析
这是一张190*190大小的地图，有三节蛇和一个食物。
判断当前蛇头的四个方向是否可以走。
程序实现
根据上图，我们可以得知，蛇的
上面是墙壁（不能走）----&gt;false
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95e1de8cbbeeedfad3bfbe316e3aa332/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79193a98c4f689ffaf999bdeb10edcf5/" rel="bookmark">
			c语言编写加法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先创建项目
int main() //主函数
{
int x,y,sum; //定义变量
printf (“请输入两个数 x和y：\n”) ; // /n 表示换行
scanf ("%d %d",&amp;x,&amp;y); //scanf的用法是：scanf(“格式控制字符串”,输入参数一，输入参数二)；
// %d 十进制有符号整数 &amp;是一个取地址符,&amp;x表示变量x的地址
sum=x+y; // 改变符号即可加减乘除
printf (“结果为%d\n”,sum); //打印sum的值
}
编译运行
输入数值
scanf ("%d %d",&amp;x,&amp;y); 注意 %d 和%d 之间要有间隔
输入完成 回车 即可打印出结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e78d83dd9fd3c5edf3fbd7723cb21ba8/" rel="bookmark">
			引用类型数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 什么叫引用类型数组？
基本类型数组的元素中放的都是基本数据类型（int等）。
引用类型数组的元素中放的是从基本类型构造而来的类和其他复杂数据类型的地址。
两种类型数组的图解 基本类型数组：arr是引用，放在栈内存中，new的部分属于对象，在堆内存中。arr里存的是对象的地址。
引用类型数组： 第一句话：stus是引用类型数组的变量（简称引用），存在栈内存，里面放的是对象实体的地址，new Student[3]在堆内存建立了一个Student[]数组对象实体，内部的元素都是存放的一个Student对象的引用，也就是对象的地址。第二句话：在此之前仅仅是建立的一个由Student对象的引用所组成的数组，这些引用并没有指向某个地址，值为空，第二句话是在新建了一个Student对象，并把它的地址赋给stus[0]。 引用类型数组的赋值：
类似基本类型数组的赋值方法，只是代码较多，看起来有些复杂 //第一种：先定义数组，然后分别赋值 Student[] stus = new Student[3]; //创建Student数组对象 stus[0] = new Student("zhangsan",25,"LF"); //创建Student对象 stus[1] = new Student("lisi",26,"JMS"); stus[2] = new Student("wangwu",27,"SD"); System.out.println(stus[0].name); //输出第1个学生的名字 stus[1].age = 22; //给第2个学生的年龄赋值为22 stus[2].sayHi();	//第3个学生和大家问好 //第二种方法，声明的同时并赋值，注意中间是逗号 Student[] stus = new Student[]{ new Student("zhangsan",25,"LF"), new Student("lisi",26,"JMS"), new Student("wangwu",27,"SD") }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ac54722f894780d72c02854b31e0012/" rel="bookmark">
			spring怎么解决bean的循环依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在实际工作中，经常由于设计不佳或者各种因素，导致类之间相互依赖。这些类可能单独使用时不会出问题，但是在使用Spring进行管理的时候可能就会抛出BeanCurrentlyInCreationException等异常 。当抛出这种异常时表示Spring解决不了该循环依赖，本文将简要说明Spring对于循环依赖的解决方法。
循环依赖的产生和解决的前提 循环依赖的产生可能有很多种情况，例如：
A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象
A的构造方法中依赖了B的实例对象，同时B的某个field或者setter需要A的实例对象，以及反之
A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象，以及反之
当然，Spring对于循环依赖的解决不是无条件的，首先前提条件是针对scope单例并且没有显式指明不需要解决循环依赖的对象，而且要求该对象没有被代理过。同时Spring解决循环依赖也不是万能，以上三种情况只能解决两种，第一种在构造方法中相互依赖的情况Spring也无力回天。结论先给在这，下面来看看Spring的解决方法，知道了解决方案就能明白为啥第一种情况无法解决了。
Spring对于循环依赖的解决
Spring循环依赖的理论依据其实是Java基于引用传递，当我们获取到对象的引用时，对象的field或者或属性是可以延后设置的。
Spring单例对象的初始化其实可以分为三步：
1、createBeanInstance， 实例化，实际上就是调用对应的构造方法构造对象，此时只是调用了构造方法，spring xml中指定的property并没有进行populate
2、populateBean，填充属性，这步对spring xml中指定的property进行populate
3、initializeBean，调用spring xml中指定的init方法，或者AfterPropertiesSet方法。
会发生循环依赖的步骤集中在第一步和第二步。
三级缓存 对于单例对象来说，在Spring的整个容器的生命周期内，有且只存在一个对象，很容易想到这个对象应该存在Cache中，Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至使用了“三级缓存”。
“三级缓存”主要是指
/** Cache of singleton objects: bean name --&gt; bean instance */ private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256); /** Cache of singleton factories: bean name --&gt; ObjectFactory */ private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16); /** Cache of early singleton objects: bean name --&gt; bean instance */ private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16); 从字面意思来说：singletonObjects指单例对象的cache，singletonFactories指单例对象工厂的cache，earlySingletonObjects指提前曝光的单例对象的cache。以上三个cache构成了三级缓存，Spring就用这三级缓存巧妙的解决了循环依赖问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ac54722f894780d72c02854b31e0012/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee3b089814d4b71ebc69bd845c7d151d/" rel="bookmark">
			什么是Autosar？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Autosar官网：https://www.autosar.org/
现如今汽车电子进入的了高速发展的时代，据统计一辆高档的汽车其内部的代码量差已经超过了1kw行，超过上百个ECU。而随着顾客对功能需求的增加，以及整车厂对顾客需求的满足，这个数字还会不断的增加。日益增加的功能需求与软件复杂度之间似乎有一个不可逾越的横沟！因为在传统的E/E开发流程中存在着如下现状：
电子系统复杂性的爆炸性增长软件代码急速上升生命周期差别：整车的生命周期往往长于ECU的生命周期嵌入式系统不支持硬件抽象有限的软件模块化软件重用性差：当硬件型号（处理器型号）更换后，软件往往要倒推重写五花八门的硬件平台 这是因为上述现状，各大厂商纷纷开始寻求解决办法，而当他们发现这些矛盾不是以一己之力就能解决的时候，Autosar就诞生了！
首先什么是Autosar？ Autosar（AUTomotive Open System ARchitecture）就是汽车开放式系统架构。这是一个由整车厂，零配件供应商，以及软件、电子、半导体公司合起来成立的一个组织。AUTOSAR组织成立于2003年7月，其核心成员由德国宝马、戴姆勒及博世等9家公司构成。在汽车行业，由于车载软件和重复利用和转移的发展，汽车电子和电气 (E/E) 系统日益复杂。该组织成立的初衷是为越来越复杂的汽车ECU软件建立一个标准化平台，以减少其设计复杂度，增加其灵活性，提高其开发效率。成立至今的近15年时间里，得到了越来越多的行业认可，成员已超过几百个。
为啥要成立它呢？ 现如今由硬件与部件驱动的开发流程正在被由功能与需求的开发方式所取代。作为一个工程师，不仅优化一个单一组件，而且要在系统级别上优化软件！可是不同的供应商来说，软件架构往往是不相同的，所以就需要一个可以交换的、升级的标准系统。可是单单以一个公司而言，这是不可能完成的。所以一群整车厂、供应商等等公司就打算成立一个组织来设计整个标准的软件架构，其核心思想就是软件组件的重复利用，力求在整体上降低整车软件的复杂度。
在引入AUTOSAR之前，OSEK / VDX和HIS就已经在进行车载软件标准化。然而，其应用范围因各种原因受到限制，汽车制造厂都使用不同的专用或推荐的平台，或ECU供应商自身的平台，硬件等的抽象方法也各不相同。
在这里无需用具体的数字进行陈述，可以说汽车控制软件的开发规模在呈爆发式增加。虽然作为再利用的有效解决方案，以往有些企业或者组织内部已经率先采用了一些标准化方法，例如，使用抽象度更高的概念等。但现在，整个业界要努力做到全行业通用的再利用。最近，关注度特别高的、以各种各样的形态或形式开展的基于模型的开发就是其中之一。另外，在验证的过程中，在很多方面所实现的自动化，也是一种很大意义的再利用。
在整个行业，为了提高效率，需要重新审视再利用工作的分工以及通用性架构的定义。例如，即便是将应用部分作为控制模型来描述、自动生成代码，那如果与运行的底层的接口不同的话，模型以及底层的集成和验证就需要单独进行。而且，在各种自动化中，虽然定义了对象的工作模型，但假如最终产品的形态以及开发流程的定义不一样，也需要特殊处理。
从长远来考虑的话，若需要单独开发和应对时，就会将再利用和自动化的经济效益降低，可再利用的空间就会减少。为了实现更多的可能性，实现与底层软件、接口方式、产品的形态以及开发的流程相通的定义会发挥很大的作用
AUTOSAR中，以提高软件再利用率和应对项目变更等为目标，在以下三个领域进行标准化活动。
Software Architecture
Methodology
Application Interface
关于以上3个项目，接下来会论述其概要。
标准是由AUTOSAR Premium Partner以上的会员企业在参加Work Package中经过讨论而制成/修订的。讨论的过程是通过邮件或者各种会议（包括电话会议）等方式进行的。而且，其标准文件以及相关文件/数据等一般都是公开的，可以通过网页下载。在R（Release）4.2 Rev.1中文件数为218个。
而且，在AUTOSAR中，并没有对实现做标准化定义（在COMASSO中定义）。“谁在做什么”、“应该负责哪个部分”这种由厂商和ECU供货商共同讨论的部分（职责/任务的分解）虽然没有具体的规定，但是提供了一些对具有指导意义的文件（例如对开发流程的共通性理解）。
Autosar成员有哪些？ Autosar成员包括四类：Core Parteners（核心成员），Premium Partners（高级成员），Development Partners（开发成员），Associate Partners（一般成员）。
核心合作伙伴（9家企业）
分别为：博世，大陆，大众，丰田，通用，PSA，福特，宝马，奔驰。
高级合作伙伴（57家公司/团队）年度会费：17,500€；年度贡献：1.5 FTE(FTE：全职人力工时)
一般合作伙伴（47家公司/团队）年度会费：2000€；年度贡献：0.5 FTE
开发合作伙伴（127家公司/团队）年度会费：10,000€；
观察员（127家公司/团队）
官方网站上公开了AUTOSAR标准，会员以外的浏览者也可以查看到，其内容还包括每个成员公司的知识产权。但AUTOSAR标准的商业使用权只有成为AUTOSAR会员才能获得（至少是合作伙伴）。此外，如果您想要在AUTOSAR标准中的加入特殊要求，至少需要成为高级合作伙伴才有这个权利。
基本类型成员所拥有的权利/义务，其量级关系简单地如下排列：
核心合作伙伴&gt;高级合作伙伴&gt;合作伙伴
Autosar的目标有哪些？ 最重要的目标就是基本系统功能与函数接口的标准化！这使得开发合作伙伴可以在车载网络里直接进行数据的整合、交换、传输功能！使得整车E/E架构由传统的基于ECU的开发（ECU-based）转变为基于功能的开发（function-based）。
Autosar有啥好处？ 1. 整体优点
提高软件的重复利用度增加设计的灵活性明确的集成设计规则在长期上可以减少开发成本非竞争模块的重用提高软件质量（各个厂商均采用标准的软件测试方法）更加专注于竞争模块的开发 2. OEM
特定的功能模块可以独立开发验收测试的标准化实现创新的分享 3. 零配件商
减少软件版本的扩散供应商之间的发展共享提高功能开发的效率新的商业模式的出现为即将到来的软件容量增加预先做好准备 4. 工具链提供商
工具链提供商共同的接口与开发流程减少漏洞、可管理、任务优化 5. 创业者
透明与定义的接口与商业模式明确的任务分配与外包 Autosar是如何提高软件质量的？ Autosar通过高度的软件重用（re-use），减少相同/类似模块的开发（减少bug），从而提高软件的成熟度。并且Autosar方法论与标准接口可以减轻ECU、系统集成的难易程度，提高软件质量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee3b089814d4b71ebc69bd845c7d151d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91b891c325b00abc23b143ba974e270f/" rel="bookmark">
			Ubuntu解决没有可安装候选软件包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法：可以使用apt-cache search &lt;package_name&gt;寻找。
例如：
E: 软件包 libqglviewer-dev 没有可安装候选
解决方法：
apt-cache search libqglviewer-dev 执行命令出现：
libqglviewer-dev-qt4 - OpenGL 3D viewer library based on Qt4 - development files libqglviewer-dev-qt5 - OpenGL 3D viewer library based on Qt5 - development files 选择下面你要安装的软件包即可，我安装了第二个
sudo apt-get install libqglviewer-dev-qt5 最后就能完成替代了。
转载于:https://www.cnblogs.com/darklights/p/10510279.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/412/">«</a>
	<span class="pagination__item pagination__item--current">413/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/414/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>