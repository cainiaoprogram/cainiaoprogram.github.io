<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c09a6236e95b12d1e07cab7b01650138/" rel="bookmark">
			Machine Learning（study notes）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		There is no studying without going crazy
Studying alwats drives us crazy
course from 吴恩达机器学习系列课程
文章目录 DefineMachine LearningSupervised Learning（监督学习）Regression problemClassidication Unspervised LearningClustering StudyModel representation（模型概述）const functionHow to use and tsolve problem gradient descentThe summary to gradient descentGradient descent for linear regression Matrices and vectors（basic knowledge）Addition and scalar multiplicationMatrix-vector multiplicationMatrix-matrix multiplicationMatrix multiplication propertiesIdentity Matrix Inverse and transpose Multiple featuresGradient descent for multiple variablesGradient descent in practice（多元梯度下降法）I : Feature Scaling(1：特征缩放)II : Learning rate Features and polynomial regressionNormal equation Define Machine Learning A computer program is said to learn from experience E with respect to some task T and some performance measure P , if its performance on T, as measued
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c09a6236e95b12d1e07cab7b01650138/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b6f5f91389148b522951d527c9adda6/" rel="bookmark">
			LLaVA和LLaVA-Plus视觉指令微调及工具使用构建多模态智能体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		认识和理解视觉内容，以及基于人类指令对视觉世界进行推理，长久以来一直是一个具有挑战性问题。得益于大规模预训练，OpenAI 的 GPT-4V 展示了在自然语言处理任务和复杂视觉理解中令人印象深刻的能力。
智源社区邀请到了LLaVA的一作柳昊天以及LLaVA-Plus的一作刘世隆，共同分享《LLaVA和LLaVA-Plus视觉指令微调及工具使用构建多模态智能体》欢迎大家观看。
主题一、Visual Instruction Tuning（柳昊天）在这次演讲中，我将介绍 LLaVA，第一个在图像理解和推理方面具有类似 GPT-4V 级别的能力的开源项目。我们证明了这种方法可以以较低成本构建可定制的多模态大模型。首先，我将介绍创建如何利用大语言模型，不需要大量手动注释的情况下，创建多模态指令微调数据集；并且这个方法成本可控，利用现有的预训练的大语言模型和视觉编码器，无需从头开始训练。此外，我将展示 LLaVA-1.5，仅通过对原始 LLaVA 进行简单修改，LLaVA-1.5 在 11 个基准测试中取得了SoTA。LLaVA-1.5 使用全公开数据集，一天内在单个 8-A100 节点上完成训练，并超过了包括Qwen-VL-Chat（使用十亿级数据）在内的方法。最后，我将展示一些 LLaVA 有趣的能力和限制，并概述我们渴望探索的方向。
Recognizing and understanding visual content, as well as reasoning about the visual world based on human instructions, has long been a challenging problem. Recently, OpenAI GPT-4V has showcased impressive capabilities in both NLP tasks and complex visual understanding challenges, thanks to large-scale pretraining and extensive instruction tuning. In this talk, I will introduce LLaVA, the first open-sourced project to demonstrate GPT-4V level capabilities in image understanding and reasoning.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b6f5f91389148b522951d527c9adda6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e323b0647b3a77630d80b443364b145/" rel="bookmark">
			单片机在执行memcpy函数时卡住
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 单片机在执行memcpy函数时卡住。
原因 memcpy中第二个参数，本来是一个指针，但是在给这个指针初始化时，漏使用取地址运算符（&amp;）。
解决办法 在给指针赋值时，添加上取地址运算符。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63aede7cd8c42aef751caeacb59a0b47/" rel="bookmark">
			RuntimeError: Inference tensors do not track version counter.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： Testing DataLoader 0: 0%| | 0/78 [00:00&lt;?, ?it/s]Failed to collect metadata on function, produced code may be suboptimal. Known situations this can occur are inference mode only compilation involving resize_ or prims (!schema.hasAnyAliasInfo() INTERNAL ASSERT FAILED); if your situation looks different please file a bug to PyTorch. Traceback (most recent call last): File "/home/buty/.local/lib/python3.8/site-packages/torch/_functorch/aot_autograd.py", line 1674, in aot_wrapper_dedupe fw_metadata, _out = run_functionalized_fw_and_collect_metadata( File "/home/buty/.local/lib/python3.8/site-packages/torch/_functorch/aot_autograd.py", line 606, in inner flat_f_outs = f(*flat_f_args) File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63aede7cd8c42aef751caeacb59a0b47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cac2454b6124e28909115b3c5a48158b/" rel="bookmark">
			solidity 重入漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 重入漏洞的原理
2. 重入漏洞的场景
2.1 msg.sender.call 转账
2.2 修饰器中调用地址可控的函数
1. 重入漏洞的原理 重入漏洞产生的条件：
合约之间可以进行相互间的外部调用 恶意合约 B 调用了合约 A 中的 public funcA 函数，在函数 funcA 的代码中，又调用了别的合约的函数 funcB，并且该合约地址可控。当恶意合约 B 实现了 funcB，并且 funcB 的代码中又调用了合约 A 的 funcA，就会导致一个循环调用，即 step 2 =&gt; step 3 =&gt; step 2 =&gt; step 3 =&gt; ....... 直到 合约 gas 耗尽或其他强制结束事件发生。
2. 重入漏洞的场景 2.1 msg.sender.call 转账 msg.sender.call 转账场景下重入漏洞产生的条件：
合约之间可以进行相互间的外部调用使用 call 函数发送 ether，且不设置 gas记录款项数目的状态变量，值变化发生在转账之后 恶意合约 B 调用了合约 A 的退款函数；合约 A 的退款函数通过 call 函数给合约 B 进行转账，且没有设置 gas，合约 B 的 fallback 函数自动执行，被用来接收转账；合约 B 的 fallback 函数中又调用了合约 A
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cac2454b6124e28909115b3c5a48158b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76ed4637ee4bcccf54878c626e7f8c6f/" rel="bookmark">
			基于EasyDarwin、ffmpeg实现rtsp推流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 安装EasyDarwin
2 编译安装ffmpeg
3 启动EasyDarwin
4 ffmepg推流
5 百度网盘备份
某项目中测试时需要用到推流，于是用EasyDarwin、ffmpeg实现了RTSP推流，简单记录下过程，
1 安装EasyDarwin 这个可以去官网下载：EasyDarwin音视频流媒体行业聚合与分享 - EasyDarwin
2 编译安装ffmpeg FFmpeg
具体过程省略，因为我把我编译后的都传到了百度网盘，以后我再次使用会省略掉这一步。
3 启动EasyDarwin 直接用start.sh启动
4 ffmepg推流 ffmpeg -re -stream_loop -1 -i ./test.mp4 -rtsp_transport udp -vcodec h264_nvenc -f rtsp rtsp://192.168.1.10/test 然后就可以用vlc取流了，
5 百度网盘备份 以上所有东西都放到了你的百度网盘里面了，下次可以直接下载使用
参考文献：
基于EasyDarwin、ffmpeg实现rtsp推流，及VLC播放-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b72a3c77fcf669a251b6d98d171b52b/" rel="bookmark">
			CSS 网页制作-学成在线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 准备工作 1.1 项目目录 网站根目录是指存放网站的第一层文件夹，内部包含当前网站的所有素材，包含HTML、CSS、图片、JavaScript等等。
1.2 版心效果 可以发现都是呈现版心居中的效果，但是每次都写一次太麻烦了，可以把版心居中的代码放到一个类选择器里面，之后要使用版心居中效果的时候就使用这个类选择器就好了。
2、网页制作思路 1.布局思路：先整体在局部，从外到内，从上到下，从左到右
2.CSS实现思路
（1）画盒子，调整盒子范围 ---&gt;宽高背景色
（2）调整盒子位置 ---&gt; flex布局、内外边距
（3）控制图片、文字内容样式
3、header 区域-布局 通栏：宽度与浏览器窗口相同的盒子
3.1 logo制作技巧 logo功能：
单击跳转到首页搜索引擎优化：提升网站百度搜索排名 实现方法：
标签结构：h1 &gt; a &gt; 网站名称（搜索关键字）CSS样式 3.2 导航制作技巧（nav） 导航功能
单击跳转页面 实现方法：
标签结构：ul &gt; li*3 &gt; a优势：避免堆砌 a 标签，网站搜索排名降级布局思路 li 设置 右侧 margina 设置 左右 padding 3.3 搜索区域（search） 实现方法：
3.4 用户区域（user） 实现方法：
标签结构： .user &gt; a &gt; img + span 4、 banner区域-布局 4.1 左侧侧导航（left） 实现方法：
标签结构：.left &gt; ul &gt; li * 9 &gt; a布局思路 a 默认状态：背景图为白色右箭头 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b72a3c77fcf669a251b6d98d171b52b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/173d8f77b29e52b633e83d5952a77532/" rel="bookmark">
			页面悬浮按钮可拖动实现（vue和js写法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：
1. 每个页面都能自动加上悬浮按钮
2. 可拖拽
3. 点击返回首页
效果图：
方式一：js原生写法：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; let div = document.createElement('div'); let clientWidth = document.documentElement.clientWidth	// 获取手机的像素宽度 let clientHeight = document.documentElement.clientHeight// 获取手机的像素高度 div.style.boxShadow = '0px 0px 0px 0.5em #e0e1e9' ; div.style.width = "24px"; div.style.height = "24px"; div.style.left = clientWidth - 50+'px'; console.log("初始位置left"+div.style.left) div.style.top = clientHeight * 0.6+'px'; div.style.zIndex = '100000'; div.style.position= 'fixed'; div.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/173d8f77b29e52b633e83d5952a77532/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65b8767fd4f8e0742a90589a1beeea2c/" rel="bookmark">
			UNIX Linux系统 启动PPOCRLabel报错[已放弃 (核心已转储)]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参照官方教程安装后，启动PPOCRLabel报错：[已放弃 (核心已转储)]
官方链接地址：PPOCRLabelv2
$~ PPOCRLabel --lang ch QObject::moveToThread: Current thread (0x561534309430) is not the object's thread (0x56153929eac0). Cannot move to target thread (0x561534309430) qt.qpa.plugin: Could not load the Qt platform plugin "xcb" in "/home/zhangchang/gitlab/ocr-data-analysis/venv/lib/python3.8/site-packages/cv2/qt/plugins" even though it was found. This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: xcb, eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, wayland-egl, wayland, wayland-xcomposite-egl, wayland-xcomposite-glx, webgl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65b8767fd4f8e0742a90589a1beeea2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612718745ea8089958ac205d3d9be2a3/" rel="bookmark">
			Android Studio 模拟器无法访问互联网解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述: Android Studio 中的安卓模拟器无法访问互联网
解决方法: 打开模拟器, 对WALN中的 AndroidWifi的 DNS进行修改 1: 打开AS, 启动模拟器 (版本30, Android11 ), 进入设置, 点击 网络和互联网, ----&gt; 进入WLAN
2: 点击 AndroidWifi, 点击高级选项, 此时显示出网络详情, 记住 ip和网关, 记不住用手机拍照。
3: 然后点击该界面上方的 笔图案(修改按钮), 此时会显示一个弹窗, 点击DHCP -&gt; 选择静态。
现在对 ip和网关进行修改, 刚才记住的ip和网关此时填写在此处, 其他不要改动。
4: 电脑界面, 设置 --&gt; 网络 --&gt; 状态 --&gt; 已连接网络 ---&gt; 属性, 下拉到底部。
找到 ipv4 DNS 服务器那里, 有两个DNS(这是我电脑上的192.168.0.1 114.114.114.114)。
记住这两个DNS, 将模拟器上的Dns也改成这两, 注意点击保存。
5: 网络状态还是没有变的话, 第4步保存的那里, 多保存几下试下, 或者等一会等这模拟器刷新状态
6: 最后状态应该从 无法访问互联网 -&gt; 网络连接受限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/612718745ea8089958ac205d3d9be2a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1290cd34f4e083616925bfa3a6195d3/" rel="bookmark">
			error while loading shared libraries: libva.so.1: cannot open shared object file: No such file or di
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做某项目的时候遇到这个问题，
error while loading shared libraries: libva.so.1: cannot open shared object file: No such file or directory 然后问bing ai说要从github下载源码然后配置编译安装，太麻烦了，但是其实自己电脑中是有这个库的，只不过软连接的名字不一样，解决方法如下
ldconfig -p | grep libva.so.2 libva.so.2 (libc6,x86-64) =&gt; /usr/lib/x86_64-linux-gnu/libva.so.2 然后 ll /usr/lib/x86_64-linux-gnu/libva.so.2 lrwxrwxrwx 1 root root 16 4月 3 2018 /usr/lib/x86_64-linux-gnu/libva.so.2 -&gt; libva.so.2.100.0 这里可以看到自己电脑中是把 libva.so.2.100.0链接为libva.so.2，所以，那我再软连接个libva.so.1就行了，
sudo ln -s /usr/lib/x86_64-linux-gnu/libva.so.2.100.0 /lib/x86_64-linux-gnu/libva.so.1 问题解决。
参考文献：https://github.com/stepmania/stepmania/issues/2186
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f47c8c0cc07a8ac607216473c98ec832/" rel="bookmark">
			标准的英文文献引用格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标准的英文文献引用格式通常遵循一定的规范，其中最常见的是美国心理学会（American Psychological Association，简称APA）和现代语言协会（Modern Language Association，简称MLA）的引用格式。以下是它们的一些基本要素：
APA 引用格式： 对于书籍（Book）：
Author, A. A. (Year of publication). Title of work: Capital letter also for subtitle. Publisher.
对于期刊文章（Journal Article）：
Author, A. A., Author, B. B., &amp; Author, C. C. (Year). Title of article. Title of Journal, volume number(issue number), page range. DOI or URL
McMahan, H. B., Moore, E., Ramage, D., Hampson, S., &amp; Agüera y Arcas, B. (2017). Communication-Efficient Learning of Deep Networks from Decentralized Data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f47c8c0cc07a8ac607216473c98ec832/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/259b84375cb81ea69d43112ea417d249/" rel="bookmark">
			MATLAB | 圣诞节快到了，一起画两款动态圣诞树吧~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hey, 圣诞节又双要到了，提前祝各位MATLABer，各位准研究生们，圣诞快乐，旗开得胜！~
今天带来两款圣诞树哈，都是可以旋转的：
原理和我去年发的圣诞树非常像，大家如果感兴趣可以去自行搜一下哈，这里就不浪费大篇幅写原理啦，此外，金色圣诞树的外形参考了以下两部分工作：
Hanchu Wang (2023). Rotating Christmas Tree(https://www.mathworks.com/matlabcentral/fileexchange/103980-rotating-christmas-tree)Weisstein, Eric W. “Conical Spiral.” From MathWorld–A Wolfram Web Resource. https://mathworld.wolfram.com/ConicalSpiral.html 以下给出完整代码：
金色圣诞树 function XmasTree2023_1 fig = figure('Units','normalized','Position',[.1,.1,.5,.8],'Color',[0,9,33]/255); ax = axes('Parent',fig,'Position',[-1/4,-1/3,1+1/2,1+2/3],'UserData',[18,11,0,13,3,0,17,4,17]+97,... 'XLim',[-7,7],'YLim',[-7,7],'ZLim',[-6,18],'Color',[0,9,33]/255); hold on; view(-40,15); disp(char(ax.UserData)); % rng(5) ax.DataAspectRatio=[1,1,1.2]; XMT = @(h,r,a,z) deal((h-z)./h.*r.*cos(a.*z), (h-z)./h.*r.*sin(a.*z), z); OFS = @(x,y,z,p) deal(x+rand(size(x)).*p-p/2, y+rand(size(y)).*p-p/2, z+rand(size(z)).*p-p/2); %% ======================================================================== % 绘制圣诞树主体，参考：Hanchu Wang (2023). Rotating Christmas Tree % (https://www.mathworks.com/matlabcentral/fileexchange/103980-rotating-christmas-tree) h = 10.05; r = h/(1+sqrt(5)); [X,Y,Z] = XMT(h,r,100*pi,rand(3000,1).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/259b84375cb81ea69d43112ea417d249/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f46c6eb4b2494ea0906e7ff1c8254e5/" rel="bookmark">
			MS17_010渗透win 7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
什么是MS17_010
1.开启虚拟网卡
2.准备两台虚拟机：kali和win 7.开启kali和win 7
3.实现kali与win 7互通
4.回到kali系统，进入攻击框架
5.win 7的配置，开启远程登录
6.卸载漏洞补丁更新程序，关闭防火墙
7.搜索ms17_010漏洞，使用漏洞
8.设置路径，设置主机IP地址和靶机IP地址
什么是MS17_010 MS17_010也就是我们常说的永恒之蓝漏洞，爆发于2017年4月14日晚，是一种利用Windows系统的SMB协议漏洞来获取系统的最高权限，以此来控制被入侵的计算机。甚至于2017年5月12日， 不法分子通过改造“永恒之蓝”制作了wannacry勒索病毒，使全世界大范围内遭受了该勒索病毒，甚至波及到学校、大型企业、政府等机构，只能通过支付高额的赎金才能恢复出文件。不过在该病毒出来不久就被微软通过打补丁修复。
1.开启虚拟网卡 2.准备两台虚拟机：kali和win 7.开启kali和win 7 3.实现kali与win 7互通 4.回到kali系统，进入攻击框架 5.win 7的配置，开启远程登录 6.卸载漏洞补丁更新程序，关闭防火墙 7.搜索ms17_010漏洞，使用漏洞 8.设置路径，设置主机IP地址和靶机IP地址 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/616167475b5ac4c1e8116394abc368cf/" rel="bookmark">
			Vue实现动态路由【记录学习的快乐】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是动态路由？
2、动态路由的好处
3、动态路由如何实现
1、什么是动态路由？ 动态路由，动态即不是写死的，是可变的。我们可以根据自己不同的需求加载不同的路由，做到不同的实现及页面的渲染。动态的路由存储可分为两种，一种是将路由存储到前端。另一种则是将路由存储到数据库。动态路由的使用一般结合角色权限控制一起使用。
总结：
1：路由可变，不是写死的，动态加载；
2：存储分两种：存储前端、存储数据库
2、动态路由的好处 使用动态路由可以跟灵活，无需手工维护，我们可以使用一个页面对路由进行维护。如果将路由存储到数据库，还可以增加安全性。
总结：
1：灵活，无需手工维护；
2：增加安全性
3、动态路由如何实现 在此以路由存储在数据库为例
流程：一般我们在登录的时候，根据登录用户的角色返回此角色可以访问的页面的路由，前端将路由存储到vuex(vuex存储的数据必须可持久的，不要一刷新页面就不见),我们在路由前置守卫处动态添加拿到的路由，对页面进行渲染。
1）此为我的router目录，index.js对路由添加，守卫拦截等处理。static-route.js为前端定义的静态路由，不需要动态加载的，如登陆页面，忘记密码页面，404页面等。
index.js文件
import Vue from 'vue' import $cookies from 'vue-cookies' import VueRouter from 'vue-router' import store from '../store'​ import staticRoute from './static-route.js'​​​ Vue.use(VueRouter)​​ const router = new VueRouter({ mode: 'history', base: process.env.BASE_URL, routes: staticRoute //staticRoute为静态路由，不需动态添加 })​ let isToken = true router.beforeEach(async (to, from, next) =&gt; { //定义isToken为true和vuex不为空时添加路由 if (isToken &amp;&amp; store.state.routers.routers.length != 0) { //从vuex中获取动态路由 const accessRouteses = await store.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/616167475b5ac4c1e8116394abc368cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82186f06742a1fe91cdab9a665e74abd/" rel="bookmark">
			dotnet nuget push nuget 包出现 error: Response status code does not indicate success: 405 (Not Allowed)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 我在执行
dotnet nuget push 包.nupkg -k &lt;apikey&gt; -s &lt;url&gt; 脚本推送nuget包的时候一直返回一个错误
error: Response status code does not indicate success: 405 (Not Allowed).
解决方案 后来发现我iis中安装了一个服务【WebDav创作规则】
把这玩意卸载就可以正常运行了
卸载方式 1.打开【启用或关闭Windows功能】
2.点击Internet Information Services
3.万维网服务
4.常见HTTP功能
5.WebDAV发布 前面的勾选去掉
6.点击确定，完成卸载
效果 最后直接成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a5ecbbae8070eb9b10910b858038d8f/" rel="bookmark">
			hive命令启动出现classnotfound
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：ambari集群三个节点node104、node105和node106，其中node105上有hiveserver2，并且三个节点均有HIVE CLIENT
注意：“./”指hive安装目录
其中装有hiveserver2的node105节点，由于某种需要向lib目录下上传了某些jar包，并且通过ambari web修改了此项参数的值
做完以上变更后，发现在node104和node106上的hive安装目录下启动./bin/hive，进入hive命令行执行hive sql会出现classNotFoundexception的问题，而node105上启动./bin/hive则不会：
这个错误信息提示很明显， 该类无法被找到，发现无法找到的这个类和我之前修改的配置项的值相同，初步怀疑是./bin/hive在启动时会读取配置文件，当读取到此项配置项时，而lib目录下没有对应的jar包（上文中我提过，我仅在node105上lib目录下上传了某些jar包，而node104和node106上均未上传）
通过vim ./bin/hive查看hive命令，发现其中有两处可以支持我的猜想
解决办法：在node104、node106上启动./bin/hive命令时，通过-hiveconf来规避参数变动带来的影响
hive.exec.post.hooks的默认值为空，所以设置“hive.exec.post.hooks=”
./bin/hive -hiveconf hive.exec.post.hooks= 成功进入执行./bin/hive命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cabf5afc3800f225b7e78749c778d89/" rel="bookmark">
			LLVM学习笔记（30）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.4.4.3. 生成代码如何辅助指令选择
3.4.4.3.1. 概述
我们首先以一个例子来说明这个过程是怎么开始的，这个例子来自Eli Bendersky的a deeper look into the llvm code generator part I：
Eli Bendersky给出了这样一些简单的IR：
define i64 @imul(i64 %a, i64 %b) nounwind readnone {
entry:
%mul = mul nsw i64 %b, %a
ret i64 %mul
}
它是在x64机器上用Clang（选项-emit-llvm）编译下面的C代码得到的：
long imul(long a, long b) {
return a * b;
}
代码生成器完成的第一件事是把IR转换为一个selectionDAG表示。下图是刚开始的DAG，就在构建出来之后。
实际上这个SelectionDAG是从最顶上的EntryToken开始构建的（即以函数的语句顺序），节点保存在ilist&lt;SDNode&gt;类型的容器里（SelectionDAG的AllNodes，这个容器是一个链式容器，图中没有显示将各个节点连接起来的边）。
在进行指令选择之前，会对这个容器进行一次拓扑排序，然后以反拓扑序对SelectionDAG遍历，即从最底下的GraphRoot节点开始，自底向上遍历。需要这个次序，是因为指令选择后得到的节点将替换被选中的节点，即被选中节点的使用者需要使用选择得到节点来代替被选中的节点。而且这个次序对维持节点间chain与glue的关联关系也是最高效的。这样的次序使得只要一次遍历就能完成指令选择与替换。
在指令选择后DAG的外观如下。在图中原有的mul节点被X86特定的IMUL64rr指令节点所替代。另外RET_FLAG节点被X86的RET指令节点替代。
注意，其中chain节点间的次序是受保护的，而glue节点所连接的节点则是：在调度期间，指令调度器不会在它们中间插入其他代码。关于chain与glue属性的声明，一方面，我们可以在声明描述操作的SDNode定义时通过SDNPHasChain与SDNPInGlue，SDNPOutGlue来声明这些属性。另一方面，部分操作节点目前还不是通过SDNode来描述的，比如上面的CopyToReg及CopyFromReg，则在构建具体的节点时确定其chain与glue属性。基本上访问内存的操作节点会带有chain属性，操作数进行算术操作的节点一般会带有glue属性。
Chain操作数如果存在的话，总是第一个操作数，而glue操作数如果存在的话，则总是最后一个操作数。这是TableGen强制的规定。
3.4.4.2. 基本数据结构
3.4.4.2.1. SDNode
在被前端处理后，源代码会被转换为LLVM IR形式，在经过一系列优化处理后，在指令选择前，这个形式被称为SelectionDAG。此时，这个DAG中的节点是SDNode的实例。类SDNode定义在文件SelectionDAGNodes.h中，它包含了下列的数据：
324 class SDNode : public FoldingSetNode, public ilist_node&lt;SDNode&gt; {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cabf5afc3800f225b7e78749c778d89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d813ecf6dded683557b2701c25cb7cd8/" rel="bookmark">
			需求：通过按钮的点击事件控制另一个输出框/按钮的点击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一章 接到需求
第二章 了解需求
第三章 解决需求 第四章 优化代码
第五章 解决问题
第一章 接到需求 最近开发的时候遇到这么一个事，技术经理是个全栈，已经把接口生成了，而且前端页面也写好了一个初稿，操作什么的功能基本上已经布局好了，如下： 经理说需求了：这里有两个按钮，一个是导入文件的，一个是导入机构的，你看看怎么把这按钮功能实现，把excel文件导入进去，后台的接口已经写好了 第二章 了解需求 然后小编接到需求了，clone下代码，根据路由找到对应的页面代码(注释的部分是小编已经写好的代码)： 发现这里就是两个按钮，然后设置了权限一些其他配置。（注意事项：我们很多人有的时候为了语义化一些特别容易出现一个问题：就是会用到关键字，比如小编一开始看这个代码的时候，上面写的是@click="import(scope.row.id)"，好家伙，不细看不知道，代码一跑吓一跳，直接控制台报错，一定要留意，import是关键字，我们不要直接定义！！！语义化命名不要命名到关键字！！！）好了，接下来进入正题：当我们拿到这么一个需求，首先我们分析一下，很明显，我们拿到的需求是一个上传文件的功能实现，平常我们上传文件很多时候会用到element、antd等等一些框架类的东西来实现这么一个功能。那么问题来了，我们这里就只有按钮，样式、布局都确定了，而且不管我们怎么点击，都没反应。那么接下来我们考虑的是不是给按钮添加点击事件 -&gt; 调出本地文件管理器 -&gt; 点击我们需要上传的文件 -&gt; 上传成功拿到文件的二进制流 -&gt; 准备上传的参数 -&gt; 像后端发送请求 -&gt; 后端返回成功/失败的数据 -&gt; 前端拿到数据进行处理，那么难点在哪呢：一个按钮，怎么能调出本地的文件管理器呢，又怎么知道我们点击文件上传了呢，对于用很多组件的我们来说可能就麻烦了，去找组件啥啥啥，但是小编觉得，是的，组件或许能帮我们实现这么个需求，但是我们难道没有别的方法了吗？原生标签：input！！！小编回忆，最开始学习html的时候有个标签input，小编也不绕圈了，设置type="file"就是文件上传的按钮！！ 回忆一下，看如下文档： HTML input type 属性 | 菜鸟教程
第三章 解决需求 好了，用到的工具有了，现在的问题在于如何解决我们利用导入的按钮操作文件上传的按钮？思路：小编为按钮与input都绑定唯一识别的ref（vue）/id（正常的html页面）以及click点击事件，原生js会告诉我们，当我们绑定id时，获取到DOM之后，我们能通过DOM.click获取到DOM上绑定的点击事件。问题解决！大家根据小编的代码理解逻辑：（小编会逐步解释的） html： // 这里是element-ui的button组件 &lt;el-button v-if="hasPermission('book:book:import')" // 通过权限控制图标显示隐藏(可忽略) type="text" //button的type(可忽略) icon="el-icon-import" // 图标类名(可忽略) size="small" // 尺寸 @click="toImportBookList(scope.row.id)"&gt; // 按钮的点击事件,传的参数是该行数据的id 导入&lt;/el-button&gt; // 原生的input &lt;input type="file" // 上传文件的类型 accept=".xls,.xlsx" // 限制上传的文件格式 :ref="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d813ecf6dded683557b2701c25cb7cd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b105c5a9f53ab615b765ffbedcd5b53/" rel="bookmark">
			【Git】Git基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Git 是什么Git 的优点Git 安装Linux UbuntuLinux CentOsWindows Git 基本操作1. 创建 Git 本地仓库2. 配置 Git3. Git工作区、暂存区和版本库4. 添加文件5. 查看 .git 文件6. 修改文件7. 版本回退 Git 是什么 Git是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。它采用分布式方式，避免中心服务器的单点故障，保障系统的高可用性和稳定性。Git可以作为一种过渡方案来替代BitKeeper，帮助管理Linux内核开发等。总之，Git是一种高效、灵活的版本控制系统，适用于各种规模的项目，是开发人员和管理人员的得力工具。
假设我们在公司中，老板让我们完成一个项目的项目规划书，当我们花了三天写出来这个项目规划书之后，我们就将这个规划书给老板看，但是老板看了之后呢，觉得不满意，让你回去做修改。你又花了一天的时间在上次规划书的基础上对项目规划书做出了修改，你又交给了老板，让老板看修改的是否满意，但是老板还是不同意，又让你回去做出修改，于是你又花了一天的时间在上个规划书的基础上做出修改，这次你将修改后的规划书交给老板看，老板觉得还是不满意，并且说：“我觉得你第二次的项目书写的还不错，就使用第二次的为最终的项目规划书吧。”听到这，你脑子一晕，顿时想把这个项目规划书甩到老板的脸上说：“你耍我呢？”。
那么如何避免上面发生的问题呢？其实我们只需要将每次做出的修改的原稿给保存下来，当修改的时候我们不修改原稿，而是重新拿一个稿子，在之前规划书的基础上进行修改，这样就能够保存每次修改之后的规划书，当老板需要哪一份的时候，我们只需要拿出那个版本的原稿就行了。而我们的 Git 的作用就是这样的。
为了能够更⽅便我们管理这些不同版本的⽂件，便有了版本控制器。所谓的版本控制器，就是能让你了解到⼀个⽂件的历史，以及它的发展过程的系统。通俗的讲就是⼀个可以记录⼯程的每⼀次改动和版本迭代的⼀个管理系统，同时也⽅便多⼈协同作业。
⽬前最主流的版本控制器就是 Git。Git 可以控制电脑上所有格式的⽂件，例如doc、excel、dwg、dgn、rvt等等。对于我们开发⼈员来说，Git最重要的就是可以帮助我们管理软件开发项⽬中的源代码⽂件。
Git 的优点 分布式版本控制系统：Git是一个分布式版本控制系统，与传统的中央仓库版本控制系统不同。每个开发人员都可以在自己的本地仓库中进行版本控制，无需依赖中央仓库。这使得版本控制更加灵活，提高了团队协作的效率。高效的性能：Git在版本控制方面具有高效的性能，能够快速地完成各种操作，如提交、查看历史记录、合并分支等。这使得开发人员能够更加专注于编码工作，而不是频繁地切换到版本控制工具。强大的分支管理：Git提供了强大的分支管理功能，可以方便地创建、切换、合并分支。这使得团队协作更加方便，不同开发人员可以同时处理不同的功能分支，提高了开发效率。回滚和撤销操作：Git提供了回滚和撤销操作功能，可以轻松地恢复到以前的版本或者撤销错误的操作。这使得开发人员能够更加放心地进行代码修改，减少了因为误操作而带来的损失。跨平台支持：Git可以在各种操作系统上运行，包括Windows、Linux和Mac等。这使得开发人员可以在不同的平台上进行协作，提高了团队协作的效率。强大的社区支持：Git是一个开源项目，拥有庞大的社区支持。开发人员可以轻松地找到相关的资料和解决方案，快速解决问题。同时，社区中还有很多开源项目和工具可以使用，进一步提高了开发效率。 注意事项：
还需要再明确⼀点，所有的版本控制系统，Git 也不例外，其实只能跟踪⽂本⽂件的改动，⽐如 TXT ⽂件，⽹⻚，所有的程序代码等等。版本控制系统可以告诉你每次的改动，⽐如在第5⾏加了⼀个单词 “Linux”，在第8⾏删了⼀个单词 “Windows”。
⽽图⽚、视频这些⼆进制⽂件，虽然也能由版本控制系统管理，但没法跟踪⽂件的变化，只能把⼆进制⽂件每次改动串起来，也就是只知道图⽚从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。
Git 安装 Linux Ubuntu 首先使用 git 命令，看是否已经下载 Git。
如果出现的是下面的页面，表示的是已经下载了 Git。
而出现了 Command 'git' not found, but can be installed with: 则表示未安装 Git。这时就需要使用 apt install git 命令来下载 Git。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b105c5a9f53ab615b765ffbedcd5b53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/797ca3911354d8e4755485d75cb1dd13/" rel="bookmark">
			数据质量问题管理实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据质量是数据管理的核心，只有高质量的数据才能为数据消费者应用，助力企业更好的使用数据来获得洞察力、做决策和服务业务。而企业许多直接的成本，也与质量问题相关，如错误数据驱动的错误业务决策造成损失、因缺乏良好信誉而导致业务损失等等。
然而，没有一个企业能拥有完美的业务流程、完美的技术流程或完美的数据管理实践，所有组织都会不可避免的遇到与数据质量相关的问题。因此，需要行之有效的问题管理措施，如进行数据质量问题处理、进行数据质量问题分析、进行数据质量问题验收等。
01
数据质量改进方法论
PDCA循环是质量最常用的方法论中，又称戴明环，是全面质量管理的思想基础和方法依据。PDCA循环的含义是将质量管理分为四个阶段，即Plan（计划）、Do（执行）、Check（检查）和 Act（处理）。在质量管理活动中，要求把各项工作按照作出计划、计划实施、检查实施效果，然后将成功的纳入标准，不成功的留待下一循环去解决。
而处理阶段，就主要包括质量问题记录、分析、处理。找出影响质量问题的主要原因。并且针对主要原因，提出解决的措施并执行。而随着问题原因的评估和解决方案的提出，循环也将重新开始。
02
数据质量问题产生的原因
数据质量问题在数据生命周期的任何节点都可能出现，原因多种多样。有如下常见原因：
（1）缺乏系统的数据管理和治理。如领导和员工缺乏质量意识、缺乏治理手段、缺乏领导力和管理能力、没有选择合适的质量工具；
（2）数据输入过程引起的问题。如数据输入接口问题、字段重载、业务流程的变更、业务流程执行混乱等；
（3）数据处理功能引起的问题。如没有定义正确的业务规则、变更数据结构等；
（4）系统设计引起的问题。如由于丢失的数据被分配为默认值而导致数据准确性、未执行唯一性约束、编码不准确等。
03
数据质量问题管理两个典型场景
高质量的数据是为了满足业务的需求，而业务的规则是数据质量规则的重要输入，因此，需要业务人员与技术人员一起，承担起质量问题管理的责任。
场景一：由业务人员在使用数据时发现数据质量问题
场景二：现有数据质量规则定期监控发现问题
04
数据质量问题管理工具实践
进行行之有效的数据质量问题管理和跟踪需要做到以下几点：
（1）标准化数据质量问题和活动。统一企业/组织内部描述数据问题的术语以及定义，以简化问题的分类，上下游人员沟通更加通畅。
（2）提供数据问题的分配过程。数据质量问题发生后，可以由数据治理专员分配给具体责任人或专家进行诊断，并提供解决方案，可下发给具有特定专业领域知识的人员推动问题解决。
（3）管理问题分级机制。数据质量问题处理能通过分级分类，区分问题影响，需要根据问题的影响、持续时间或紧急程度制定明确的升级机制，明确不同问题在数据质量SLA中的地位。
（4）管理数据质量解决方案工作流。制定数据质量SLA规范，规定监控、控制和解决的目标，所有这些定义了操作工作流的集合。能通过事件跟踪系统支持工作流管理，以跟踪问题诊断和解决的进度。
工欲善其事，必先利其器，以往有大量的客户依靠传统的人工线下手工维护问题，并通过邮件分配问题。针对疑似数据质量问题，有些部门的解释原因直接由业务核查同事直接回复给IT，没有流程化和系统化。长期下来，历史异常和质量问题，依靠手工整理和邮件，无法追溯和解决，数据治理效率低下。
Easydata数据质量中心的问题管理模块，可以实现数据质量问题的跟踪记录，能够收集与解决问题、分配问题处理和验收工作、统计问题数量和发生频率，以及维护计划解决方案、处理记录处理时长等信息。可以推动数据质量监控进行持续的、有依据的改进。目前在制造业、金融行业均有客户落地应用。
数据质量问题管理模块，可将所有数据质量问题汇总留存，并进行处理。支持用户主动提报问题，也可以通过配置在质量规则异常时自动进行问题提报。
可配置问题表单的自定义属性，支持移动其在表单中的展示位置及选择是否必填。用户可以自定义问题管理是要包含的字段信息。
质量问题将自定义资源目录的一种分组管理形式，系统内置校验类型和严重等级两个资源目录。
流程协作中心可自定义设计处理流程和整改流程。
问题详情中可以查看和维护问题的基本信息，也可以关联质量监控规则或者规则的某次执行结果。
问题处理有多种方式，问题处理人可以自行直接处理或关闭问题，也可派发工单加签或转办问题。
最后，可以周期性的订阅数据质量报告，定时跟踪数据质量问题情况。
05
总结
数据质量问题不是通过一些工具和口号就能改进的，还依赖企业内部自上到下的质量观念树立和资源支持。比如建设数据质量问题管理计划、拉通业务人员和IT人员、关注数据质量报告和问题处理状态、强化培训等等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/832485fb8ed3b41630cc2ea73ab6bc6a/" rel="bookmark">
			概率转移路径搜索算法（Beam search, Viterbi算法，）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每个时刻的状态概率给定，我们希望计算整个路径（所有时刻）的最大概率状态。
贪心算法（Greedy Algorithm）动态规划： Beam search：选定当前时刻k个最佳状态。k=N时计算复杂度和维特比相同，但可能不如维特比好，因为没有假设独立并且每个时刻保存前k个状态可能都是当前时刻的同一状态（比如 [A, B, C] -&gt; [AA, BA, CA] 都是A而没有A’B‘）。维特比算法Viterbi：马尔可夫假设，只考虑相邻时刻的所有状态。比如 [A, B, C] -&gt; [AA, AB, BC] Beam search 当num_beams=1时集束搜索就退化成了贪心搜索。
维特比算法 从开始状态之后每走一步，就记录下到达该状态的所有路径的概率最大值，然后以此最大值为基准继续向后推进。
假设给定[[隐马尔可夫模型|隐式马尔可夫模型]]（HMM）状态空间 S，共有k个状态，初始状态 i 的概率为 ，从状态 i 到状态 j 的转移概率(transition probability)为 。 令观察到的输出为 。 产生观察结果的最有可能的状态序列 由递推关系给出：
此处 是前 t 个最终状态为 k 的观测结果最有可能对应的状态序列的概率。 通过保存向后指针记住在第二个等式中用到的状态 x 可以获得维特比路径。声明一个函数 ，它返回若 时计算 用到的 x 值 或若 时的 k . 这样:
算法复杂度为 具有隐藏状态的概率转移路径（HMM模型） 隐马尔可夫三大问题 给定模型，如何有效计算产生观测序列的概率？换言之，如何评估模型与观测序列之间的匹配程度？给定模型和观测序列，如何找到与此观测序列最匹配的状态序列？换言之，如何根据观测序列推断出隐藏的模型状态？给定观测序列，如何调整模型参数使得该序列出现的概率最大？换言之，如何训练模型使其能最好地描述观测数据？ 前两个问题是模式识别的问题：1) 根据隐马尔科夫模型得到一个可观察状态序列的概率(评价)；2) 找到一个隐藏状态的序列使得这个序列产生一个可观察状态序列的概率最大(解码)。第三个问题就是根据一个可以观察到的状态序列集产生一个隐马尔科夫模型（学习）。
对应的三大问题解法：
向前算法(Forward Algorithm)、向后算法(Backward Algorithm)维特比算法(Viterbi Algorithm)鲍姆-韦尔奇算法(Baum-Welch Algorithm) (约等于EM算法) 前向算法（算出观测序列的概率）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/832485fb8ed3b41630cc2ea73ab6bc6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d1a0ca7b3ba78138a0409ba77320247/" rel="bookmark">
			NLP入门- 分布语义学（Distributional Semantics）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从语料库中直接学习单词含义，这个领域也被称为 分布语义学（Distributional Semantics）
分布假设：可以通过其周围的上下文单词来了解一个目标单词共现文档通常指示了主题（文档（document） 作为上下文）局部上下文反映了一个单词的语义类别（单词窗口（word window） 作为上下文）给定 100 个非常好的例句，我们可以基于这些单词是否出现在这些例句中，将其转换为 100 维的向量。每一行都可以视为一个 词向量（word vector）。 它描述了单词的分布特性（目标单词附近的上下文单词信息）。捕获各种语义关系，例如：同义（synonymy）、类比（analogy）等另一种词向量：词嵌入（word embeddings） 1. 基于计数的方法 向量空间模型（Vector Space Model，VSM）：将单词含义表示为一个向量。 文档（documents）视为上下文。TF-IDF 基于文档的词频向量优化PMI 基于上下词的词频向量优化 1.1 向量空间模型 一个文档由其所包含的单词表示，一个单词由其出现过的文档表示
单元格中的数字表示该单词在对应文档中出现的频率。如果我们观察每一行，我们可以将其视为每个文档的词袋模型表示；如果我们观察每一列，我们可以将其视为每个单词的词向量表示。
比单纯的词频更好的加权方法：
TF-IDF (Term Frequency-Inverse Document Frequency)：通过TF（term-frequency）矩阵，计算该单词对应的 IDF（inverse document frequency）值。
。 |D|是文档总数，df_w是该单词在共多少文档中出现的次数。
TF矩阵。 df 表示每个单词 的文档频率，即该单词在所有文档（即语料库）中出现的总次数 分别计算每个单词的 IDF 值，并将其和对应单元格的 TF 值相乘，我们可以得到下面的 TF-IDF 矩阵：
TF-IDF 矩阵。 假设有500文档，那么the值为0 TF-IDF 的核心思想在于：对于在大部分文档中都频繁出现的单词（例如：“the”），我们给予更低的权重，因为它们包含的信息量很少。
tf-idf权重计算方法经常会和余弦相似性（cosine similarity）一同使用于向量空间模型中，用以判断两份文件之间的相似性tf-idf算法是建立在这样一个假设之上的：对区别文档最有意义的词语应该是那些在文档中出现频率高，而在整个文档集合的其他文档中出现频率少的词语，所以如果特征空间坐标系取tf词频作为测度，就可以体现同类文本的特点。另外考虑到单词区别不同类别的能力，tf-idf法认为一个单词出现的文本频数越小，它区别不同类别文本的能力就越大。因此引入了逆文本频度idf的概念在本质上idf是一种试图抑制噪声的加权，并且单纯地认为文本频率小的单词就越重要，文本频率大的单词就越无用，显然这并不是完全正确的。idf的简单结构并不能有效地反映单词的重要程度和特征词的分布情况，使其无法很好地完成对权值调整的功能，所以tf-idf法的精度并不是很高 我们也可以单词作为上下文：
我们可以选择目标单词附近固定范围（”窗口大小“）内的某些单词作为上下文 原始频率存在一个明显的问题：整个矩阵被常见单词所主导。但是这里，我们无法采用 TF-IDF，因为这里我们没有涉及到文档。相应地，这里我们可以采用点互信息（PMI）的方法来处理这个问题。
点互信息（Pointwise Mutual Information，PMI）：衡量两个事物之间的相关性
PPMI（正点互信息）
会偏向于给予低频单词较大的 PMI 值colocationness 还行 1.2 TF-idf和pmi总结 我们已经学习了将文档作为上下文的 TF-IDF 矩阵，以及将单词作为上下文的 PMI/PPMI 矩阵。很重要的一点是，无论我们采用文档还是单词作为上下文信息，我们都可以利用 SVD 来创建密集向量。但是，通过不同的上下文信息所捕获到的关系是不一样的，如果我们采用 TF-IDF，我们捕获到的语义学信息会更加宽泛，通常和某种主题关联；如果我们采用 PMI/PPMI，我们捕获到的词向量更多是关于局部单词上下文的语义学信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d1a0ca7b3ba78138a0409ba77320247/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52d55089d672a0e84e757ceba5d6019a/" rel="bookmark">
			UE4 UE5 一直面向屏幕
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直面相屏幕，方法很简单
新建一个蓝图，如下添加组件：
蓝图如下：
Rotation Actor ：需要跟随镜头旋转的物体
Update：一个timeline（替代event tick 只是为了循环）
Timeline：
蓝图直接可以复制：网址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4948009c9e18079ac018fb7c3b4fb4d4/" rel="bookmark">
			Spring 解决循环依赖为什么需要三级缓存，而不是两级缓存?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 作者主页： 有来技术
🔥 开源项目： youlai-mall 🍃 vue3-element-admin 🍃 youlai-boot
🌺 仓库主页： Gitee 💫 Github 💫 GitCode
💖 欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请纠正！
目录 前言什么是循环依赖？Sprring 的三级缓存为什么需要三级缓存？Spring 循环依赖流程三级缓存源码解析结语 前言 在深入探索Spring框架的高级特性时，一个经常被提及的话题是“循环依赖”，特别是如何通过缓存机制来解决这个问题。循环依赖发生在两个或多个Bean相互依赖的情况下，如果没有合适的处理机制，就会导致应用启动失败或运行时错误。Spring框架通过引入一个三级缓存的机制来优雅地解决这一问题。这引发了一个有趣的问题：为什么是三级缓存而不是两级缓存？在本文中，我们将探讨Spring处理循环依赖的具体机制，尤其是为什么三级缓存是解决这一问题的关键。
什么是循环依赖？ Spring循环依赖指的是两个或多个Bean之间存在直接或间接的循环引用关系。这种情况下，Bean A依赖于Bean B，同时Bean B又依赖于Bean A，形成一个循环依赖关系。在Spring容器中，如果不加以处理，这样的循环依赖可能导致程序无法正常启动或运行时出现异常。
举例说明，假设有两个服务类 A 和 B：
// A.java @Service public class A { private B b; @Autowired public A(B b) { this.b = b; } } // B.java @Service public class B { private A a; @Autowired public B(A a) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4948009c9e18079ac018fb7c3b4fb4d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/694a1f7f638d21110a774060435dc325/" rel="bookmark">
			gitlab修改代码库的名称、路径和分组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言修改过程具体需求修改项目名修改访问路径修改分组 总结 前言 工作项目的源码使用gitlab进行管理，通常情况下不会修改代码库和路径，但是非一般的情况总是存在，比如刚刚立项时多次调整项目名，甚至改变管理层级，所以还是有这类需求的，一开始我本打算将旧的代码库和提交记录推送到新的地址和分组，后来在gitlab后台里翻了翻，结合网络大神们的指点，发现可以直接修改代码库的名称和分组，总共需要修改3个配置，一起来看下。
修改过程 具体需求 假设需求是将项目名从 A 改为 B，同时将访问路径从 git@gitlab.example.cn:APrject/AGroup/A.git 改为 git@gitlab.example.cn:APrject/AGroup/B.git，这里一共有三处需要修改：项目名、访问路径、以及分组，下面依次列举出修改的方法：
修改项目名 导航路径【Settings】-&gt;【General】-&gt;【Naming, topics, avatar】-&gt;【Project name】，只需填入新的项目名，点击 “Save changes” 按钮即可，页面展示如下：
修改访问路径 做完上一步只是修改了项目名字，如果使用 git clone 命令下载整个库，路径是没有发生变化的，修改访问路径需要调整 “Path”
导航路径【Settings】-&gt;【General】-&gt;【Advanced】-&gt;【Expand】-&gt;【Change path】，只能修改最后一段Path，其中不能再包含 /，修改后点击 “Change path” 即可，页面展示如下：
修改分组 上面修改路径这一步只允许修改Path的最后一段，不能直接调整分组路径，想要调整前面的路径需要调整分组
导航路径【Settings】-&gt;【General】-&gt;【Advanced】-&gt;【Expand】-&gt;【Transfer project】，这一步只能选择已有的分组，选择好目标分组，点击 “Transfer project” 按钮即可，页面展示如下：
总结 gitlab后台可以直接修改代码库的名称、路径和分组等信息，不必重新创建项目在修改名称、路径和分组等信息后需要相关人员更新对原有代码库的引用，否则会找不到使用 git remote set-url origin &lt;new-url&gt; 命令可以更新已有仓库的URL ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== 对未来的迷茫以及内心的不安，让我们在现有社会经济条件下，沦为被金钱和物质所统治的行尸走肉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bb1b834122ad648cd598c87c153c199/" rel="bookmark">
			jdk 线程池与 tomcat 线程池对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、线程池的作用 1. 提高性能：线程的创建需要开辟虚拟机栈、本地方法栈、程序计数器等线程私有空间，同时也会一比一的创建一个内核线程，在线程销毁时需要回收这些系统资源。频繁地创建和销毁线程会大大浪费系统资源，这时候就需要线程池来管理线程，提高线程的复用
2. 控制并发度：限制同时执行的线程数量，通过控制并发度来避免资源过度占用和系统过载。
3. 任务排队：提供任务队列，可以将所有待执行的任务进行排队，保证任务按照一定的顺序执行，避免因为线程不足而导致任务丢失
二、java 自带线程池 ThreadPoolExecutor Java JUC下提供了一套 Executor 框架，主要支持以下几种线程池的创建
a. FixedThreadPool（固定大小线程池）：维护固定数量的线程，任务提交后会立即执行。如果所有线程都被占用，新任务会被放入任务队列中等待。适用于并发任务数固定且较小的情况。
b. CachedThreadPool（缓存线程池）：线程池大小不固定，根据任务量动态创建和回收线程。如果当前有空闲线程，则会直接使用，如果没有则会创建新的线程。适用于并发任务数较大或者任务执行时间较短的情况。
c. SingleThreadPool（单线程池）：线程池中只有一个线程，所有的任务按照顺序执行。适用于保证任务执行顺序的场景，如任务间有依赖关系或需要按照提交顺序执行。
d. ScheduledThreadPool（定时线程池）：用于定时执行任务和周期性执行任务。可以设置线程数量和延迟时间来执行任务
不推荐使用 Executors 工厂模式创建上述四种线程池，缺少很多线程池的参数设置且默认参数并不合理，容易出现性能问题或者资源浪费。推荐使用 ThreadPoolExecutor类 (类结构图如下) 手动创建线程池，可以自定义线程池的大小、任务队列、拒绝策略以及其他参数。这样可以根据具体的业务需求和系统资源状况来优化线程池的性能和稳定性。
ThreadPoolExecutor 核心参数 corePoolSize（核心线程数）：表示线程池中保持活动状态的线程数量。在没有任务执行时，核心线程也会一直存在。当有新任务提交时，线程池会优先创建核心线程来处理任务。maximumPoolSize（最大线程数）：表示线程池中允许存在的最大线程数。当线程池中的线程数达到最大线程数并且任务队列已满时，新提交的任务会触发拒绝策略。keepAliveTime（线程空闲时间）：表示当线程池中的线程数量超过核心线程数时，空闲线程在被终止之前要等待新任务的时间。线程空闲时间的单位由TimeUnit参数指定。unit（时间单位）：用于指定keepAliveTime的时间单位，可以是秒、毫秒、微秒等。workQueue（任务队列）：用于存储待执行的任务的队列。线程池中的线程会从任务队列中取出任务进行执行。ThreadPoolExecutor提供了多种实现供选择，如ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue等。threadFactory（线程工厂）：用于创建新线程的工厂，默认使用Executors.defaultThreadFactory()。 handler（拒绝策略）：当线程池无法处理新提交的任 如果 corePoolSize 长时间无效占用线程数量，可通过 allowCoreThreadTimeOut 设置项要求线程池：将包括“核心线程”在内的，没有任务分配的所有线程，在等待 keepAliveTime 时间后全部回收掉。
线程池的线程分配流程 三、tomcat 线程池 StandardThreadExecutor 不同于 jdk 自带的线程池，tomcat 应用的场景基本都是IO密集型请求，即系统请求非常消耗CPU的占比比较低，所以tomcat在设计线程池的时候，重新设计了线程池分配原则，请求进来时会优先创建并分配线程而不是进入等待队列
设计点1: 增加继承 LinkedBlockingQueue 的 TaskQueue private transient volatile ThreadPoolExecutor parent = null; @Override public boolean offer(Runnable o) { // 如果线程池为空,直接入队列 if (parent==null) return super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bb1b834122ad648cd598c87c153c199/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cba5b69f0192e68f534ea3427b1b580/" rel="bookmark">
			neo4j-Py2neo使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		neo4j-Py2neo(一)：基本库介绍使用 py2neo的文档地址：https://neo4j-contrib.github.io/py2neo/
py2neo的本质是可以采用两种方式进行操作，一种是利用cypher语句，一种是使用库提供的DataTypes，Data类的实例需要和远程的数据库中一一对应。
类说明Core Graph API直接可以直接从py2neo引用的几个核心类。负责具体执行提交的类。Data Typesneo4j的核心，节点关系等。也就是py2neo.data，这个类下面的所有成员都可以直接从py2neo引用。Cyphercypher语言执行后的结果如何访问，在这个类中。Bulk批量执行cypher语句。Object-Graph Mapping将图谱映射到python类中，比如整个数据库，已知节点。 from py2neo import Graph graph = Graph("bolt://localhost:7687", auth=("neo4j", "password")) # 不指定name, 就用默认数据库 graph.run("UNWIND range(1, 3) AS n RETURN n, n * n as n_sq") Node 1, 创建节点 ,Node(*labels, **properties)。节点就是两个部分组成：标签、属性。
from py2neo import Node # 或者 from py2neo.data import Node a = Node('Person', name='alice') b = Node(*['Person', 'Man', 'Manager'], **{'name':'Joey'}) # 查看标签 list(a.labels) # 是否具有标签 a.has_label() # 添加标签 a.add_label('Woman') # 删除标签 a.remove_label('Person') # 删除所有标签 a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cba5b69f0192e68f534ea3427b1b580/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/434e26311d7f613e8ae4c4ce19fe86a0/" rel="bookmark">
			数据结构：图文详解 队列 | 循环队列 的各种操作（出队，入队，获取队列元素，判断队列状态）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
队列的概念
队列的数据结构
队列的实现
入队
出队
获取队头元素
获取队列长度
循环队列的概念
循环队列的数据结构
循环队列的实现
判断队列是否为空
判断队列是否已满
入队
出队
得到队头元素
得到队尾元素
队列的概念 队列（Queue）是一种数据结构，是一种先进先出（First-In-First-Out，FIFO）的线性数据结构。它只允许在列表的一端进行插入操作（入队），在另一端进行删除操作（出队），即队头进行删除操作，队尾进行插入操作。队列常用的操作有入队（Enqueue）、出队（Dequeue）、获取队头元素（Front/Peek）、获取队列长度（Size/Length）等。
图示如下：
队列的特点是按照元素加入的先后顺序进行操作，先加入队列的元素会先被取出，后加入的元素会后被取出。这种特性常常被用于模拟实际生活中的排队场景，例如银行柜台排队、CPU任务调度等。
队列的数据结构 队列可以用数组或链表来实现。数组实现的队列需要预先分配一定的空间，但是在操作中效率较高；链表实现的队列没有固定的空间限制，但是在操作中可能需要更多的时间和空间。
这里笔者以链表进行演示：
public class MyQueue { static class ListNode { int val;//存放数据 ListNode pre;//前驱指针 ListNode next;//后驱指针 public ListNode(int val) { this.val = val; } } private ListNode head;//记录头节点 private ListNode last;//记录尾部节点 } 队列的实现 入队 因为我们使用的是链表来模拟实现，所以对于入队的操作就相当于使用尾插法(头插法)，入队图示：
当队列为空的时候需要进行特殊处理，不然会造成空指针异常，队列为空的时候让我们的头指针和尾指针都指向这个节点就可以，如果队列不为空就正常的使用尾插法，尾插法图示：
//入队 public void enqueue(int val) { ListNode newNode = new ListNode(val); if (head == null) { head = newNode; last = newNode; }else { newNode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/434e26311d7f613e8ae4c4ce19fe86a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e812bf84a08117d83f7cbbd9a1eb2f20/" rel="bookmark">
			2023 软考信息安全工程师 知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 知识点总结2023软考总结选择题问答题 考试通过啦 知识点总结 军用不对外公开的信息系统安全等级至少应该&gt;=三级 数据中心的耐火等级不应低于二级 政府网站的信息安全等级原则上不应低于二级 第一代交换机以集线器为代表，工作在OSI物理层 第二代交换机以太网交换机，工作在OSI数据链路层，称为二代交换机，识别数据中的MAC，并根据MAC地址选择转发 第三代交换机三层交换机，工作在OSI网络层 第四代交换机增加业务功能，比如防火墙、负载均衡、IPS等 第五代交换机支持软件定义网络SDN，具有强大的QOS的能力 《国家安全法》 2015/7/1 《网络安全法》 2017/6/1 《等保》 2019/12/1 《密码法》 2020/1/1 《数据安全法》 2021/9/1 《关键信息基础设施安全保护条例》 2021/9/1 《个人信息保护法》 2021/11/1 《网络安全审查办法》 2022/2/15 专用IP地址（私网地址）范围： - A类：10.0.0.0 ~ 10.255.255.255 - B类：172.16.0.0 ~ 172.31.255.255 - C类：192.168.0.0 ~ 192.168.255.255 169.254.X.X是保留地址。这类地址又称为自动专用IP地址。APIPA是IANA保留的一个地址快。 《计算机信息系统安全保护条例》是由中华人民共和国（国务院令）第147号发布的 等保步骤：定级、备案、建设整改、等级测评、监督检查 五个等级：用户自主保护级、系统保护审计级、安全标记保护级、结构化保护级、访问验证保护级 信息系统的安全保护等级由两个定级要素决定：等级保护对象受到破坏时所侵害的客体和对客体造成侵害的程度。 受侵害的客体包括：公民、法人和其他组织的合法权益；社会秩序、公共利益；国家安全 对客体的侵害程度：一般损害；严重损害；特别严重损害 DES密钥长度56位，子密钥长度为48位，分组长度为64位 S盒变换是一种压缩变换，通过S盒将48位输入变为32位输出。共有8个S盒并行作用。每个S盒有6个输入，4个输出，是非线性压缩变换。 AES密钥长度128、192、256 对称加密缺点：密钥分发和管理困难，同时不具有哈希函数的单向性 ECC和RSA实现数字签名的主要区别：ECC签名后的内容中包含原文，而RSA签名后的内容中没有原文 RSA签名原理：分别利用自己的私钥和对方的公钥加密，签名后的内容是加密后的密文； ECC签名原理：利用密钥生成两个数附加在原始明文后一同发送。 RSA密码中，明文消息M的取值必须是整数且小于n。 整数a、b关于模n同余的充分必要条件是n整除a-b，记为n|a-b 在SSL VPN技术规范中非对称加密算法：ECC（256）、SM9、RSA（1024） 弱密钥：存在k,使得EK (EK (m)) = m，弱密钥不受任何循环移位的影响，并且只能得到相同的子密钥，DES有4个弱密钥 半弱密钥：存在K1,K2,使得EK1 (EK2 (m)) = m，有些种子密钥只能生成两个不同的子密钥，DES有12个半弱密钥，形成6对 弱密钥和半弱密钥使得原本多轮迭代的复杂结构简单化和容易分析 一个密码仅当它能经得起已知明文攻击时才是可取的。 在传输模式IPSec应用情况中，（传输层及上层数据报文）可受到加密安全保护 网闸： 采用了“代理+摆渡”的方式 代理的思想就是（可看成数据“拆卸”，拆除应用协议的“包头和包尾”） 摆渡的思想就是内外网进行隔离，分时对网闸中的存储进行读写，间接实现信息交换；内外网之间不能建立网络连接，不能通过网络协议互相访问 网闸的主要实现技术： 实时开关技术、单向连接技术、网络开关技术 sniffer网卡模式：混杂模式；多播模式；广播模式；任意模式 Wireshark过滤命令: 主机过滤： ip.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e812bf84a08117d83f7cbbd9a1eb2f20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad89f51df652b5cf98488fe94200157b/" rel="bookmark">
			Go-语言容器1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Go语言数组 数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，所以在Go语言中很少直接使用数组。
和数组对应的类型是 Slice（切片），Slice 是可以增长和收缩的动态序列，功能也更灵活，但是想要理解 slice 工作原理的话需要先理解数组。
Go语言数组的声明 数组的声明语法如下：
var 数组变量名 [元素数量]Type 语法说明如下所示：
数组变量名：数组声明及使用时的变量名。元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。 数组的每个元素都可以通过索引下标来访问，索引下标的范围是从 0 开始到数组长度减 1 的位置，内置函数 len() 可以返回数组中元素的个数。
var a [3]int // 定义三个整数的数组 fmt.Println(a[0]) // 打印第一个元素 fmt.Println(a[len(a)-1]) // 打印最后一个元素 // 打印索引和元素 for i, v := range a { fmt.Printf("%d %d\n", i, v) } // 仅打印元素 for _, v := range a { fmt.Printf("%d\n", v) } 默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说就是 0，同时也可以使用数组字面值语法，用一组值来初始化数组：
var q [3]int = [3]int{1, 2, 3} var r [3]int = [3]int{1, 2} fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad89f51df652b5cf98488fe94200157b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13776e581132190cb2c35fc7da844cea/" rel="bookmark">
			【MATLAB/Simulink】控制系统中常用的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最小实现/零极点相消——minreal(sys) sysr = minreal(sys)
作用：消除状态空间模型中不可控或不可观测的状态，或消除传递函数中的零极点对。输出系统具有与原模型系统相同的最小顺序和响应特性。
系统降阶——reduce（sys, order） sysr = reduce(sys, order)
作用：将系统sys，降为所需阶数order
【未完待续】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b59ccd65d69a3b47eed150f0ac2985/" rel="bookmark">
			链表基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链式结构：通过结构成员的指向同类型结构的指针成员，指针成员把一个结构和另一个结构链接起来，利用指针成员可以实现多种形式的数据组织，如线性链表、二叉链表、邻接表等。一个结构中包括数据域和指针域，数据域是存放数据的，指针域是链接单元。
定义示例：
struct node { int data; struct node *next;//用结构体名称定义一个指针 }; typedef struct node Node; 链表的实现：
1、创建链表：若要使用链表，需要在声明节点之后先创建链表，并对链表初始化。链表的创建实质上是头节点的创建。若创建一个空链表，则链表节点的指针应指向NULL，数据域存储的链表长度应为0.
pHead *createList() { pHead *ph=(ListNode*)malloc(sizeof(ListNode));//创建头指针 ph-&gt;data = 0; //初始化链表长度 ph-&gt;next = NULL; //初始化头指针指向 return ph; } 2、插入节点：单链表通过节点的指针域来记录下一个节点的位置，从而实现所有节点的连接。因此，当插入一个新元素时，修改节点指针域的指向关系，再修改链表头节点中链表的长度，使其值加1即可。
（1）头插法：是向链表头部插入新元素，即将新元素插入链表节点之后。代码演示：
int insertHead(pHead *ph,int data) { //创建新节点 ListNode *newNode = (ListNode *)malloc(sizeof(ListNode)); if(NULL = newNode) return -1; newNode-&gt;data = data; //插入新节点 newNode-&gt;next = ph-&gt;next; ph-&gt;next = newNode; //链表长度加1 ph-&gt;data++; return 0; } （2）尾插法：将待插入的节点插入到最后一个节点之后，使得插入节点成为尾节点。代码演示：
int insertTail(pHead *ph,int data) { pHead *p = ph; //找到尾节点 while(p-&gt;next!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3b59ccd65d69a3b47eed150f0ac2985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a196a3f92815ff5c81446f3d3d9a4b6/" rel="bookmark">
			华为Vlan的基本配置与地址的vlan划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vlan的创建与基本配置
VLAN（虚拟局域网）是一种将网络设备逻辑上划分为多个虚拟网络的技术。在华为模拟器上进行VLAN的配置和管理可以带来许多重要的好处。以下是VLAN的重要性的讲述：
1. 提高网络性能：VLAN可以帮助减少广播风暴和冲突，提高网络的性能和效率。通过将设备和用户分组到不同的VLAN中，可以减少广播流量和碰撞，提高网络的可用带宽。
2. 增强网络安全性：VLAN可以增强网络的安全性。通过将敏感数据和关键设备分隔到不同的VLAN中，可以减少未经授权的访问和攻击的风险。此外，VLAN还可以提供隔离网络流量的能力，防止恶意软件和攻击从一个VLAN传播到另一个VLAN。
3. 简化网络管理：VLAN可以简化网络管理。通过将设备和用户根据其功能、部门或位置划分到不同的VLAN中，可以更轻松地管理网络资源。管理员可以根据需要对每个VLAN进行独立的配置和管理，而无需影响其他VLAN。
4. 支持虚拟化和云计算：VLAN是支持虚拟化和云计算的基础。通过将虚拟机分配到不同的VLAN中，可以实现虚拟机之间的隔离和安全性。此外，VLAN可以帮助在云环境中实现多租户的隔离，确保不同租户之间的数据和资源不会相互干扰。
5. 支持灵活的网络设计：VLAN可以支持灵活的网络设计。通过使用VLAN，可以根据需要创建不同的逻辑网络，并将其映射到物理网络上。这样可以实现更灵活的网络架构，提高网络的可扩展性和适应性。
6. 降低成本：VLAN可以降低网络部署和维护的成本。通过使用VLAN，可以减少物理设备的数量和复杂性。此外，VLAN还可以简化网络故障排除和变更管理，从而降低维护成本。
VLAN在华为模拟器上的配置和管理具有重要的意义。它可以提高网络性能、增强网络安全性、简化网络管理、支持虚拟化和云计算、支持灵活的网络设计以及降低成本。通过合理使用VLAN，我们可以更好地优化和管理网络资源，提供更安全、高效和可靠的网络环境。
实验目的: 学会创建Vlan的指令，允许相同Vlan之间的通信：
学会每台交换机端口配置为Access Trunk Hybrid的指令
学会限制Trunk链路上允许传输Vlan的指令 一.将PC与交换机如图所示摆好，并根据所需配置好PC机的网段。
二.在交换机上创建Vlan
想要在交换机上配置Vlan，我们可以使用两种方法。第一种方法是逐个创建Vlan，在输入创建一个Vlan的指令后，用户便会进入Vlan配置视图中。第二种方法是通过一条指令批量创建多个Vlan，这种指令不会使用户进入某个Vlan的配置视图中。
2-1.在交换机S1上创建Vlan
在全局配置模式下，使用“vlan vlan-id”命令创建一个新的VLAN。其中，“vlan-id”是你想要创建的VLAN的ID号。例如，输入“vlan 10”命令创建一个ID为10的VLAN
在交换机S2上创建Vlan
创建完毕后，可以使用“name vlan-name”命令为刚刚创建的VLAN设置一个名称。其中，“vlan-name”是你想要设置的VLAN的名称。例如，输入“name VLAN10”命令为刚刚创建的VLAN设置名称为“VLAN10”。
三.端口的Vlan划分
首先，我们需要将接口加入到已创建的VLAN中。使用“interface interface-type interface-number”命令进入到你想要加入VLAN的接口配置模式。其中，“interface-type”是接口类型（如Ethernet、GigabitEthernet等），“interface-number”是接口编号。例如，输入“interface GigabitEthernet 0/0/1”命令进入到GigabitEthernet 0/0/1接口配置模式。
其次，在接口配置模式下，使用“port Access vlan vlan-id”命令将接口划分到指定的VLAN中。其中，“vlan-id”是你想要划分的VLAN的ID号。例如，输入“Port Access VLAN 10”命令将该接口划分到ID为10的VLAN中。 如果你有多个接口需要加入到VLAN中，可以重复执行步骤四和步骤五，将其他接口加入到相应的VLAN中。
3-1.在S1中配置E0/0/1~e0/0/3端口
在S2中配置E0/0/1 E0/0/2端口
配置好端口后，可以使用指令:dispaly vlan 来检查端口是否配置成功。
端口上Trunk的配置 交换机之间的互联链路上通常需要承载多个Vlan的流量，我们会把这条链路设置为Trunk模式，并且限制它只能传输Vlan20和Vlan30的流量。配置Trunk链路的常用指令有:
Inteface_interface-type_interface-number 进入相应端口的接口配置视图中
Port_link-type_trunk 将端口设置为Trunk模式.
Port_trunk_allow-pass_vlan[{vlan-id} {vlan-id1_to_vlan-id2} {all}] 设置允许Trunk传输的Vlan。如需要允许连续编号的Vlan，我们可以在第一个Vlan与最后一个Vlan之间添加一个to,如果需要允许所有的Vlan，可以使用关键词all。
4-1.配置S1端口上的Trunk的配置
配置S2端口上的Trunk的配置
五.通过地址划分Vlan段
1.为了实现基于IP地址的VLAN划分，我们需要进行一些额外的配置。首先，进入到VLAN接口配置模式。使用"interface vlan vlan-id"命令进入到指定VLAN的接口配置模式。例如，输入"interface vlan 10"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a196a3f92815ff5c81446f3d3d9a4b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e8276a4aefd8eccd28cefec44799d3/" rel="bookmark">
			Could not find a package configuration file provided by “catkin“ : catkinConfig.cmake 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 自己的测试环境：
Ubuntu18.04
ROS-Melodic
一、问题描述 自己编译 Autoware 的时候遇到如下问题：
CMake Error at CMakeLists.txt:4 (find_package): By not providing "Findcatkin.cmake" in CMAKE_MODULE_PATH this project has asked CMake to find a package configuration file provided by "catkin", but CMake did not find one. Could not find a package configuration file provided by "catkin" with any of the following names: catkinConfig.cmake catkin-config.cmake Add the installation prefix of "catkin" to CMAKE_PREFIX_PATH or set "catkin_DIR" to a directory containing one of the above files.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14e8276a4aefd8eccd28cefec44799d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9dd4a28cd4ec1de26f987cc6e97522c/" rel="bookmark">
			如何启动 polkit.service服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要启动 PolicyKit (polkit) 服务在 Linux 系统上，你可以使用 `systemctl` 命令。以下是启动 polkit 服务的步骤：
1. 打开终端。
2. 使用以下命令确保 dbus 服务正在运行，因为 polkit 依赖于 dbus：
```bash
sudo systemctl restart dbus.service
```
3. 然后，使用以下命令启动 polkit 服务：
```bash
sudo systemctl start polkit.service
```
4. 如果你想在系统启动时自动启动 polkit，可以使用以下命令：
```bash
sudo systemctl enable polkit.service
```
5. 验证 polkit 服务是否已成功启动，可以使用 `systemctl status` 命令：
```bash
sudo systemctl status polkit.service
```
如果服务成功启动，输出应显示 "active (running)" 状态。如果有任何问题，输出中可能会包含错误消息或警告，可以帮助你诊断问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8760fe4f02984c28e2c067919242750e/" rel="bookmark">
			STM32通过PWM输出使蜂鸣器实现播放音乐功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码下载链接[点击跳转]
1.什么是PWM输出 PWM，全称Pulse Width Modulation，即脉宽调制技术，是一种通过改变信号的占空比来控制电路的技术。在PWM信号中，周期是固定的，而占空比则可以根据需要进行调整。通过改变占空比，可以控制电路输出的电压、电流等物理量的大小，从而实现对电路的控制。PWM频率是指一秒钟内从高电平时间在到低电平时间，再从低电平跳到高电平的瞬间次数，也就是一秒钟内有多少个PWM的周期。PWM周期是指一秒钟内从高电平时间在到低电平时间。PWM占空比是指一个周期内高电平时间和总时间的比值。
PWM的基本产生如下图，即面积等效法，当b的占空比为百分之百的时候，a输出为高电平，而当b在一个周期占空比为其他数值的时候，根据定积分产生的正弦波面积则不同，经过多个周期不同占空比的时候，就会产生不同的面积波形，即产生了一个模拟信号。
PWM在生活中有很多应用，例如通过PWM输出控制LED亮度，当频率太小的时候，一个周期时间太长肉眼就能看到LED亮灭的过程，而当频率足够高的时候，LED的灯光的亮灭速度赶不上开关速度(LED灯还没完全亮就又熄灭了)由于视觉暂留作用人眼不感觉电灯在闪烁，而是感觉灯的亮度减小了，从而达到了控制LED亮度的效果。
2.如何让蜂鸣器发出不同频率的声音 2.1设置预分频 void TIMx_BEEP_Config(void){ //......省略部分代码 TIM_TimeBaseStructure.TIM_Period = 1;//当定时器从0计数到255，即为256次，为一个定时周期 TIM_TimeBaseStructure.TIM_Prescaler = 72-1;//设置预分频 TIM_TimeBaseStructure.TIM_ClockDivision = 0;//设置时钟分频系数：不分频 TIM_OCInitStructure.TIM_Pulse = 0;//占空比0	//......省略部分代码 } 由代码可见预分频值为71，则为72分频（多少分频都可以，72分配只是为了方便后面计算），由于STM32的默认系统时钟频率为72MHz，分频后则为1MHz。此时定时器会在一秒内计数1M次，且由 知道，可以通过改变周期T来得到任意频率f。
通过固件库函数TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload);修改自动重装载寄存器周期的值即可得到任意频率的PWM输出。
通过TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);来修改比较寄存器中的比较值，改变PWM输出的占空比。
2.2音调频率对照图： 在有了音调频率对照图后只需要通过调整PWM输出频率即可控制蜂鸣器发出不同的音调，实现通过蜂鸣器播放音乐。
由上述可知，分频后频率为1MHz，且,频率已知，因此可以算出所需的T的值。例如低音1的。
2.3定义一个修改占空比和寄存器周期值的函数 定义一个set_beep(uint16_t f)函数，变量f为音调频率，通过该函数即可实现让蜂鸣器发出任意频率的声音。
void set_beep(uint16_t f){ if(f==0){ TIM_SetAutoreload(TIM1,1); TIM_SetCompare1(TIM1,0); }else{ TIM_SetAutoreload(TIM1,(1000000/f)); TIM_SetCompare1(TIM1,(1000000/f)/15); } } 3.孤勇者乐谱 4.实例代码 main.c #include "stm32f10x.h" #include "Beep.h" #include "SysTick.h"//里面写了一个延时函数，不重要，因此不上传该部分的代码 #define L1 262-1//低调 do 的频率 #define L2 294-1//低调 re 的频率 #define L3 330-1//低调 mi 的频率 #define L4 350-1//低调 fa 的频率 #define L5 392-1//低调 sol 的频率 #define L6 440-1//低调 la 的频率 #define L7 494-1//低调 si 的频率 #define M1 524-1//中调 do 的频率 #define M2 588-1//中调 re 的频率 #define M3 660-1//中调 mi 的频率 #define M4 700-1//中调 fa 的频率 #define M5 784-1//中调 sol 的频率 #define M6 880-1//中调 la 的频率 #define M7 988-1//中调 si 的频率 #define H1 1048-1//高调 do 的频率 #define H2 1176-1//高调 re 的频率 #define H3 1320-1//高调 mi 的频率 #define H4 1480-1//高调 fa 的频率 #define H5 1640-1//高调 sol 的频率 #define H6 1760-1//高调 la 的频率 #define H7 1976-1//高调 si 的频率 #define S 0//不发音 int16_t music[]= { M3,M3,S,S,M1,M2,M1,M3,M3,S, //都是勇敢的 M1,M2,M1,M2,M3,L6,M1,L6,M1,L6,M1,M2,M1,L7,L7,S,S, //你额头的伤口你的不同你犯的错 M3,M3,S,S,M1,M2,M1,M3,M3,S, //都不必隐藏 M1,M2,M1,M2,M3,L6,M1,L6,M1,L6,M1,M3,M2,L7,L7,S,S, //你破旧的玩偶你的面具你的自我 L6,M1,M6,M6,M6,M5,M6,M6,M5,M6,M5,M6,M5,M3,M3,M3,S,S, //他们说要带着光驯服每一头怪兽 L6,M1,M6,M6,M6,M5,M6,M5,M7,M7,M7,M6,M7,M7,M6,M3,M3,S,S, //他们说要缝好你的伤没人爱小丑 M3,M5,M3,M2,M3,M2,M3,M2,S, //为何孤独不可光荣 M3,M5,M3,M5,M3,M2,M3,M2,M3,M2,S, //人只有不完美值得歌颂 M1,M2,M3,L6,M1,M3,M2,M3,M2,M1,M1,L6,L6,S,S,//谁说污泥满身的不算英雄 M6,M7,H1,H2,M7,H1,H1,S,	//爱你孤身走暗巷 H1,M7,H1,H2,M7,H1,H1,S, //爱你不跪的模样 H1,H2,H3,H2,H3,H2,H3,H3,H2,H3,H5,H3,S, //爱你对峙过绝望不肯哭一场 M6,M7,H1,H2,M7,H1,H1,H1,M7,H1,H2,M7,H1,H1,S, //爱你破烂的衣裳却敢堵命运的枪 H1,H2,H3,H2,H3,H2,H3,H3,H2,H3,H5,H3,S, //爱你和我那么像缺口一样 H5,H3, //去吗 H5,H3,S, //配吗 H5,H3,H5,H6,H3,H5,S, //这褴褛的披风 H5,H3,//战吗 H5,H3,S, //战啊 H5,H3,H5,H6,H3,H5,H5,H5,H3,H2,H2,H2,H1,H3,H3,H2,H2,H2,H1,H1,M6,M6,S,S, //以最卑微的梦致那黑夜中的呜咽与怒吼 H5,H5,H3,H2,H2,H2,H1,H3,H3,H2,H2,H2,H1,H1,M6,M6,S,S, //谁说站在光里才算英雄 }; int main(void) {	uint16_t i; TIMx_BEEP_Config(); while(1) { for(i=0;i&lt;sizeof(music)/sizeof(music[0]);i++) { set_beep(music[i]); delay_ms(250); } } } Beep.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8760fe4f02984c28e2c067919242750e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f0d7057e91cb860be9838d873ddbcd6/" rel="bookmark">
			git log实用指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gi查看提交历史 在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 git log 命令
当你在此项目中运行 git log 命令时，可以看到下面的输出：
$ git log commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Author: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test commit a11bef06a3f659402fe7563abf99ad00de2209e6 Author: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Sat Mar 15 10:31:28 2008 -0700 first commit git log 有许多选项可以帮助你搜寻你所要找的提交， 下面我们会介绍几个最常用的选项。
其中一个比较有用的选项是 -p 或 --patch ，它会显示每次提交所引入的差异（按 补丁 的格式输出）。 你也可以限制显示的日志条目数量，例如使用 -2 选项来只显示最近的两次提交：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f0d7057e91cb860be9838d873ddbcd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40073058dbcfce97b21c6ba974b0ab12/" rel="bookmark">
			WarAgent使用多智能体理解人类历史和预防未来国际冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们能否避免历史十字路口上的战争？这个问题已经被个人、学者、政策制定者和组织在人类历史中追寻了很长时间。在这项研究中，我们尝试根据人工智能（AI）和大型语言模型（LLM）的最新进展来回答这个问题。
本文试图通过使用人工智能和大型语言模型，回答人类历史上的战争问题：我们能否在历史的十字路口避免战争？同时，本文还试图探索如何使用AI来理解人类历史和预防未来国际冲突。本文提出了一个基于大型语言模型的多智能体系统WarAgent，用于模拟历史国际冲突，包括第一次世界大战，第二次世界大战和中国古代的战国时期。通过评估模拟的有效性，本文考察了当今前沿AI系统在研究国际冲突等复杂人类行为方面的能力和局限性。通过模拟中智能体之间的相互作用，本文提供了一个新的视角来研究导致战争的触发器和条件。
本文使用大型语言模型和人工智能技术来研究历史国际冲突，提出了一个基于多智能体系统的模拟框架，称为WarAgent。本文的贡献是提供了一种新的方法来理解历史和预防未来的国际冲突。本文还提供了数据集和代码，并探讨了当今前沿AI系统在研究复杂人类行为方面的能力和局限性。
最近在这个领域中，还有一些相关的研究，包括使用机器学习来预测战争爆发的研究，例如“Predicting War: A Machine Learning Approach to Understanding Conflict”（2017）和“Forecasting International Conflict Using Ensemble Models and Hybrid Features”（2019）。此外，还有一些研究使用模拟来研究国际冲突，例如“Simulating War: Studying Conflict through Agent-Based Models”（2017）。
https://github.com/agiresearch/WarAgent
https://simg.baai.ac.cn/paperfile/2263b292-29dd-40ec-a40b-aa72b48ca38a.pdf
为了大模型直接叙述历史事件，我们对资料进行匿名化和模糊化，并保证内容尽量接近历史。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2f5076bf34b1263cb5e78439402bdd0/" rel="bookmark">
			@rollup/plugin-html 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@rollup/plugin-html 是 Rollup 的一个插件，用于生成 HTML 文件，并将打包后的 JS 文件引入到 HTML 文件中。
该插件的配置选项如下：
- `fileName`: 指定生成的 HTML 文件的文件名，默认为 `index.html`。
- `template`: 指定 HTML 文件的模板路径，可以是一个本地文件路径或者是一个模板字符串。如果未指定模板，则会使用默认的模板。
- `publicPath`: 指定生成的 HTML 文件中引入 JS 文件的路径，默认为 `/`。
- `title`: 指定生成的 HTML 文件的标题。
- `attributes`: 指定生成的 HTML 文件的 `&lt;html&gt;` 标签上的属性，可以是一个对象或者一个函数。
- `templateParams`: 指定传递给模板的参数，可以是一个对象或者一个函数。
- `inject`: 指定 JS 文件的引入位置，可以是一个字符串或者一个函数。
- `favicon`: 指定生成的 HTML 文件的 favicon 图标的路径。
- `meta`: 指定生成的 HTML 文件的 `&lt;head&gt;` 标签中的 `&lt;meta&gt;` 标签，可以是一个对象或者一个函数。
- `minify`: 指定是否压缩生成的 HTML 文件，默认为 `false`。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2f5076bf34b1263cb5e78439402bdd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebbea71e78ff1771544bbcbc439a7775/" rel="bookmark">
			Kafka-配置Kerberos安全认证(JDK8、JDK11)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、相关配置 1、JAAS 配置文件
KafkaClient { com.sun.security.auth.module.Krb5LoginModule required useKeyTab=true storeKey=true serviceName="kafka" keyTab="D:/code/demo/conf/kafka.service.keytab" principal="kafka/hdp-1"; }; 2、keytab 文件（kafka.service.keytab）
从 Kerberos 服务器上拷贝到目标机器 或 找运维人员要一份
3、Kerberos 配置文件（krb5.conf）
krb5文件参数说明：krb5.conf(5)
从 Kerberos 服务器上拷贝到目标机器 或 找运维人员要一份
# Configuration snippets may be placed in this directory as well # JDK11此行配置要去掉 includedir /etc/krb5.conf.d/ [logging] default = FILE:/var/log/krb5libs.log kdc = FILE:/var/log/krb5kdc.log admin_server = FILE:/var/log/kadmind.log [libdefaults] default_realm = HADOOP.COM dns_lookup_realm = false dns_lookup_kdc = false ticket_lifetime = 24h renew_lifetime = 7d forwardable = true rdns = false udp_preference_limit = 1 [realms] HADOOP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebbea71e78ff1771544bbcbc439a7775/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba61ad06141467b234602cb3cc1c33b1/" rel="bookmark">
			SCS【37】hdWGCNA在空间转录组学中的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简 介 生物系统是非常复杂的，在不同分子、细胞、器官和有机体之间严格调节的相互作用的基础上，被组织成一个多尺度的功能细胞层次。虽然实验方法能够在数百万个细胞中进行转录组范围的测量，但流行的生物信息学工具不支持系统级分析。在这里，我们提出了hdWGCNA，这是一个全面的框架，用于分析高维转录组学数据中的共表达网络，如单细胞和空间RNA测序(RNA-seq)。hdWGCNA提供网络推理、基因模块识别、基因富集分析、统计测试和数据可视化等功能。除了传统的单细胞RNA-seq, hdWGCNA能够使用长读单细胞数据进行同型水平的网络分析。我们利用自闭症谱系障碍和阿尔茨海默病大脑样本的数据展示了hdWGCNA，确定了与疾病相关的共表达网络模块。hdWGCNA与Seurat直接兼容，Seurat是一个广泛使用的R包，用于单细胞和空间转录组学分析，我们通过分析包含近100万个细胞的数据集来证明hdWGCNA的可扩展性。
hdWGCNA工作流程及其在人类前额皮质中的应用综述：
(A)scRNA-seq数据集上标准hdWGCNA工作流程的示意图概述。UMAP图显示了来自11名认知正常供体的36671个细胞Zhou等人的前额皮质(PFC)数据集。ASC,星形胶质细胞;EX，兴奋性神经元;INH，抑制性神经元;毫克,小胶质细胞;ODC,少突胶质细胞;OPC,少突胶质祖细胞。
(B)密度图显示单细胞(sc)表达矩阵和元细胞表达基因之间的成对Pearson相关性分布具有变化的K近邻参数K值的矩阵。
(C)每种细胞类型中不同K值的sc、伪体积(pb)和元细胞矩阵的表达矩阵密度(1，稀疏度)。
(D)kME对INH-M6、EX-M2、ODC-M3、OPC-M2、ASC-M18和MG-M14中前5个枢纽基因的标度基因表达热图。
(E)(D)中所选模块的snRNA-seq用模块特征基因(ME)着色的UMAP。
(F)ODC共表达网络的UMAP图。每个节点代表一个基因，边缘代表基因与模块集线器之间的共表达链接基因。点的大小按kME缩放。节点通过共表达式模块分配来着色。每个模块的前两个中心基因被标记。网络边缘是为视觉清晰度下采样。
(G) 10个ODC共表达模块(F)的snRNA-seq UMAP (A)，用MEs标记。
(H) Morabito et al.12人类PFC数据集中ODC模块的模块保存分析。
软件包安装 R 包 hdWGCNA 安装时候依赖很多其他的包，并且加载时总是断掉，因此大家多尝试几次，保证网速，即可实现安装成功。
devtools::install_github('smorabit/hdWGCNA', ref='dev') install.packages("WGCNA") BiocManager::install("impute") 数据读取 首先，加载所需要软件包，如下：
# single-cell analysis package library(Seurat) # package to install the mouse brain dataset library(SeuratData) # plotting and data science packages library(tidyverse) library(cowplot) library(patchwork) # co-expression network analysis packages: library(WGCNA) library(hdWGCNA) # install this package, which allows us to compute distance between the spots # install.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba61ad06141467b234602cb3cc1c33b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec881c4e2272cbd0b29a53624bcf96c2/" rel="bookmark">
			如何在 Kubernetes Pod 中构建 Docker 镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本指南重点介绍了使用 Kaniko 镜像生成器在 Kubernetes pod 中设置 Docker 映像构建的分步过程。
当涉及到CI / CD时，可能会有基于VM和容器的应用程序。理想情况下，应使用现有的 VM 基础结构来构建 Docker 映像。但是，如果您有容器化基础结构，最好将其用于 CI/CD 工作流。
在 Docker 中构建 Docker 在 CI 中，其中一个主要阶段是构建 Docker 镜像。在容器化构建中，您可以在 Docker 工作流中使用 Docker。
但这种方法有以下缺点。
Docker 生成容器在特权模式下运行。这是一个很大的安全问题，它为恶意攻击打开了一扇门。Kubernetes 从其核心中删除了 Docker。因此，除非您将 docker 添加到所有 Kubernetes 节点，否则将来无法装载到主机。docker.sock 这些问题可以使用 Kaniko 解决。
还有一个名为 podman 的实用程序，它可以在没有 root 权限的情况下运行和创建容器。
使用 Kaniko 在 Kubernetes 中构建 Docker 镜像 kaniko 是 Google 创建的开源容器镜像构建工具。
它不需要对主机进行特权访问即可生成容器映像。
Kaniko的工作原理，
有一个专用的 Kaniko 执行器镜像用于构建容器镜像。建议使用 gcr.io/kaniko-project/executor 镜像以避免任何可能的问题。因为此镜像仅包含静态 go 二进制文件和从注册表推送/拉取映像的逻辑。Kaniko 接受了三个参数。Dockerfile、生成上下文和远程 Docker 注册表。部署 kaniko 镜像时，它会读取 Dockerfile 并使用 FROM 指令提取基本镜像文件系统。然后，它执行 Dockerfile 中的每条指令，并在用户空间中拍摄快照。每次快照后，kaniko 仅将更改的镜像图层附加到基础镜像并更新镜像元数据。Dockerfile 中的所有指令都会发生这种情况。最后，它将镜像推送到给定的注册表。 如您所见，所有镜像构建操作都发生在 Kaniko 容器的用户空间内，并且不需要对主机进行任何特权访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec881c4e2272cbd0b29a53624bcf96c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/102c50401e5b4bef6e2c2ccff2b7d17a/" rel="bookmark">
			Qt/C&#43;&#43;开发经验小技巧291-295
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国内站点：https://gitee.com/feiyangqingyun
国际站点：https://github.com/feiyangqingyun
关于在pro中区分linux系统，在Qt4套件是不认识 linux 标记的，需要用 unix:!macx 表示。所以如果有兼容Qt4的需求，建议用 unix:!macx 表示。 //如果是linux上的Qt4套件则下面只会打印 unix linux //如果是linux上的Qt5/Qt6套件则下面会打印 linux unix linux linux {message(linux)} unix {message(unix)} unix:!macx {message(linux)} 对于一些跨平台的项目，尤其是需要引入第三方库，需要根据不同的系统不同的位数引入对应文件夹中的库文件，这就需要项目中去识别处理。 #区分不同的系统 path_sys = win win32 { path_sys = win } linux { path_sys = linux } #Qt4套件不认识linux标记 unix:!macx { path_sys = linux } macx { path_sys = mac } android { path_sys = android } #区分不同的位数 x86_64/amd64/arm64/arm64-v8a path_bit = 32 contains(QT_ARCH, x.*64) { path_bit = 64 } else:contains(QT_ARCH, a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/102c50401e5b4bef6e2c2ccff2b7d17a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90371ad582916225afb250c69b0fb3f/" rel="bookmark">
			【stable diffusion】图片批量自动打标签、标签批量修改（BLIP、wd14）用于训练SD或者LORA模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考： B站教学视频【：AI绘画】新手向！Lora训练！训练集准备、tag心得、批量编辑、正则化准备】官方教程：https://github.com/darkstorm2150/sd-scripts/blob/main/docs/train_README-en.md#automatic-captioning 一、sd-webui通用的打标界面 1.1 打标界面
根据需求，选择通用打标模型（BLIP）还是动漫打标模型（deepbooru）
设置好后，选择预处理，会开始下载模型，可开代理加速
1.2 BLIP打标结果
1.3 Deepbooru标注结果 （标签效果比下一段介绍的wd-14差一些）
二、sd-webui插件下wd14自动对动漫打标 插件名称： stable-diffusion-webui-wd14-tagger
安装与下载方式 可参考
stable-diffusion-webui 扩展模块安装
在 extensions/文件夹下拉取源码
git clone https://github.com/toriato/stable-diffusion-webui-wd14-tagger.git extensions/tagger 2.1 选择Tagger下的Batch from directory 2.2 输入图片的路径 图片与服务器应在同一台电脑
批量打标 单张图片看效果 可以了解到一些打标签原理，他是一个多类分类器，输出得每个词都是有概率的，一般输出置信度40%以上的词。
2.3 等待模型自动下载（可能卡住） 2.4 打标结果 图片与对应tag结果1
图片与对应tag结果2
三、sd-webui编辑标签 3.1 导入自动打标后的图片 3.2 批量修改添加 首先在所有tag前面加一个风格tag: cike567
打开txt查看 3.3 批量删除 四、lora训练集成开发工具自动打标 dreambooth、lora、sd模型微调的GUI环境安装（cuda驱动、pytorch、xformer）
（下载模型时间长，过程是类似的，本文暂不介绍了）
4.1 BLIP打标 首先会下载模型，下载非常慢
附录 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4435cfaadf3d83b6b1623836cf26804/" rel="bookmark">
			【webUI】gradio基础使用2——Gallery组件显示多张图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://www.gradio.app/docs/gallery | 参考代码（老版本，有错误）
gradio基础使用1：https://blog.csdn.net/imwaters/article/details/131400571
说明 基于python的浏览器上多图片显示，是很多复杂程序基本环节，本文写出最简单形式方便大家修改。
应用：例如上传一张图片，经过处理，输出查询结果。
注意官网文档不完善，如果不使用 gradio.Gallery().style() 是无法控制显示图片的布局的
本文 gradio_version 3.34.0
完整代码 # -*- coding: utf-8 -*- # @Time : 2023/10/12 13:48 # @Author : XyZeng import os import gradio as gr def get_img_lits(img_dir): imgs_List=[ os.path.join(img_dir,name) for name in sorted(os.listdir(img_dir)) if name.endswith(('.png','.jpg','.webp','.tif','.jpeg'))] return imgs_List def input_text(dir): img_paths_list=get_img_lits(dir) # 注意传入自定义的web # 结果为 list,里面对象可以为 return img_paths_list ''' gr.Gallery() 必须要使用.style()才能控制图片布局 ''' demo = gr.Interface( fn=input_text, inputs=gr.inputs.Textbox(default='./dir_show'), # inputs=gr.inputs.Image(type="pil"), outputs=gr.Gallery( label="最终的结果图片").style(height='auto',columns=4), title='显示某路径下的所有图片的缩略图23.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4435cfaadf3d83b6b1623836cf26804/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ec9036654f01d9cc4908b321cbce91b/" rel="bookmark">
			context标准库的介绍和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		context标准库 context 翻译成中文是 上下文 的意思，它可以对 API 和进程之间传递截止日期、取消信号和其他请求范围的值。
使用上下文的程序应遵循以下规则：
保持包之间的接口一致不要在结构类型中存储上下文上下文应该是第一个参数，通常命名为ctx上下文值仅用于传输进程和API的请求范围数据，而不用于向函数传递可选参数 context 是 Golang 开发常用的并发编程技术。
Context 实际上只定义了接口，凡是实现该接口的类都可称为是一种 context，官方包实现了几个常用的context，分别可用于不同的场景。
1. context类型 1.1 空 context context包中定义了一个空的context，名为emptyCtx，用于 context 的根节点，空的 context 只是简单的实现了 context，本身不包含任何值，仅用于其他 context 的父节点。
type emptyCtx int func (*emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (*emptyCtx) Done() &lt;-chan struct{} { return nil } func (*emptyCtx) Err() error { return nil } func (*emptyCtx) Value(key any) any { return nil } func (e *emptyCtx) String() string { switch e { case background: return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ec9036654f01d9cc4908b321cbce91b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f53333cb3c75dae1c74132a7c331319c/" rel="bookmark">
			HTML&#43;CSS&#43;JS网页期末作业 源码评论区自取(海绵宝宝网页设计)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课代表来给大家整理一下（HTML+CSS+JS网页期末作业 源码评论区自取 【源码领取方式】：1 .评论“已三连，学习”
2. 然后点击私信按钮✉， 发送关键词“学习” ，机器人会自动回复的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d50ce9200c3138ad4f72498c3368da/" rel="bookmark">
			js常用快捷封装方法utils工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		判断数据是否为空 function isEmpty(data){ return data == undefined || data == "undefined" || data == null || data == "null" || data == '' || data.length == 0; } 判断是否为数组 function isArray(arr){ return Object.prototype.toString.call(arr) === '[object Array]';; } 判断是否为对象 function isObject(obj){ return Object.prototype.toString.call(obj) === '[object Object]';; } 浅拷贝 /** // 扩展运算符浅拷贝 var newObj = { ...obj } // 通过Object.assign方法实现 Object.assign(newObj, obj[, obj2,...]) */ // forin拷贝 function shallowClone(obj){ const newObj = {}; for (const key in obj1) { if (obj1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05d50ce9200c3138ad4f72498c3368da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f8075c0896ec41de96a57c986b414a2/" rel="bookmark">
			linux ubuntu 修改ssh端口号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看ssh端口 netstat -atunlp | grep sshd 修改端口号 目标文件【/etc/ssh/sshd_config】
修改port
重启ssh sudo systemctl restart ssh 再次查看ssh端口 netstat -atunlp | grep sshd 成功
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/52/">«</a>
	<span class="pagination__item pagination__item--current">53/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/54/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>