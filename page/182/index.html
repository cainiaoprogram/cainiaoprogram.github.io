<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9570f003379ada9780f9a6619cc8313/" rel="bookmark">
			redis底层数据结构之压缩列表(ziplist)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
压缩列表(ziplist)
1 压缩列表结构
2 压缩列表节点结构
3 encoding编码类型
1) 字节数组类型
2) 整数类型
4 压缩列表示意图
5 连锁更新现象
压缩列表(ziplist) 压缩列表(ziplist)是redis 为了节约内存而开发的，由连续内存块组成的顺序型数据结构，适用于长度较小的值
存取的效率高，内存占用小，但由于内存是连续的，在修改的时候要重新分配内存
同时满足以下两个条件时，使用ziplist:
1) 元素长度都小于64Byte
2) 元素数量小于512个
1 压缩列表结构 struct ziplist&lt;T&gt; { int32 zlbytes; int32 zltail_offset; int16 zllength; T[] entries; int8 zlend; } 其中:
zlbytes：整个压缩列表占用的字节数，占4Byte
zltail_offset：最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个元素，占4Byte
zllength：压缩列表的元素个数，占2Byte
entries：压缩列表的元素，可以包含多个节点，每个节点可以保存一个字节数组或者一个整数值
zlend：压缩列表结束标志，值等于 0xFF，占1Byte
2 压缩列表节点结构 typedef struct zlentry { unsigned int prevrawlensize, prevrawlen; unsigned int lensize, len; unsigned int headersize; unsigned char encoding; unsigned char *p; } zlentry; 其中:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9570f003379ada9780f9a6619cc8313/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc6b44ce6ec4de6554a0d36de3066f2/" rel="bookmark">
			NMS与Soft NMS算法解析以及numpy实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. NMS算法 1.1 什么是NMS算法 NMS全称为Non Maximum Suppression，中文意思是非极大值抑制，字面意思就是不是极大值的元素被抑制掉，其实就是筛选出局部最大值得到最优解。NMS算法被广泛运用于目标检测算法处理网络输出的边界框。
1.2 为什么在目标检测中要使用NMS算法 在目标检测中如果不是用NMS算法，则网络的输出结果就会向如下图所示，许多预测框都框住了目标，但是这些框并不是我们都想要的，我们想要的是其中框出来最好的那一个预测框。此时，我们就需要利用NMS算法去筛选出最适合的预测框。
1.3 在目标检测中怎么样使用NMS算法 我们以检测人脸为例，在目标检测中使用NMS算法的流程：
首先，需要通过置信度阈值消除小于阈值的预测框，比如阈值为0.5，如图下图所示，得到过滤后的预测框。 将所有的预测框的置信度降序排列，得到置信度最大的预测框，如下图红色框： 再设置一个IOU阈值，所谓IOU就是两个框面积的交并比，遍历其余的框，如果和当前最高分框的IOU大于一定阈值，我们就将框删除，如下图所示。 再重复1、2、3步骤，得到最终的结果。 Python代码如下：
代码来自：https://github.com/rbgirshick/fast-rcnn/blob/master/lib/utils/nms.py
import numpy as np def nms(dets, thresh): # ------------------------------------ # # 获取所有预测框的左上角x1, y1、右上角x2, y2以及置信度scores # ------------------------------------ # x1 = dets[:, 0] y1 = dets[:, 1] x2 = dets[:, 2] y2 = dets[:, 3] scores = dets[:, 4] # ------------------------------------ # # 获取所有预测框的面积 # ------------------------------------ # areas = (x2 - x1 + 1) * (y2 - y1 + 1) # ------------------------------------ # # 所有预测框降序排列（保存的是下标） # ------------------------------------ # order = scores.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dc6b44ce6ec4de6554a0d36de3066f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c32c1a9b009fbda6abf910bf40a69ce5/" rel="bookmark">
			【C&#43;&#43;】C&#43;&#43;引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、引用的概念二、引用的特性三、常引用四、引用的使用场景1.做参数2.做返回值 五、性能比较1.传值、传引用效率比较2.值和引用的作为返回值类型的性能比较 六、引用和指针的区别七、总结 前言 对于习惯使用C进行开发的朋友们，在看到c++中出现的&amp;符号，可能会犯迷糊，因为在C语言中这个符号表示了取地址符，取地址符常常用来用在函数传参中的指针赋值。引用是C++引入的新语言特性，是C++常用的一个重要内容之一。在C++中它却有着不同的用途，掌握C++的&amp;符号，是提高代码执行效率和增强代码质量的一个很好的办法。
一、引用的概念 引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量**共用同一块内存空间。
引用的声明方法：类型标识符 &amp;引用名=目标变量名；
类型&amp; 引用变量名(对象名) =引用实体；
引用的符号和C语言中取地址的符号一样为&amp;，在某类型名的后面加上引用符号(&amp;)就成为了引用类型，设计引用的目的是简化指针的使用，但是C++中引用不能完全替代指针，引用不能引用多个对象，所以C++也没有摆脱指针，JAVA则完全摆脱了指针。在C++中，引用和指针相辅相成，引用的底层是通过指针实现的。
#include &lt;iostream&gt; using namespace std; int main() { int a = 10; int&amp; ra = a;//&lt;====定义引用类型 printf("%p\n", &amp;a); printf("%p\n", &amp;ra); return 0; } 注意：引用类型必须和引用实体是同种类型的
【说明】
​ （1）&amp;在此不是求地址运算，而是起标识作用。
（2）类型标识符是指目标变量的类型。
（3）声明引用时，必须同时对其进行初始化。
（4）引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。ra=1; 等价于 a=1;
（5）声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。&amp;ra与&amp;a相等。
（6）不能建立数组的引用。因为数组是一个由若干个元素所组成的集合，所以无法建立一个数组的别名。
二、引用的特性 1.引用在定义时必须初始化
2.一个变量可以有多个引用
3.引用一旦引用一个实体，再不能引用其他实体
int main() { int a = 10; // int&amp; ra; // 该条语句编译时会出错 int&amp; ra = a; int&amp; x = a; int&amp; y = a; x++; y++; a++; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c32c1a9b009fbda6abf910bf40a69ce5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadb22f9e8cf630cf0457082c43f907e/" rel="bookmark">
			【python】详解使用numpy模块来拼接矩阵，二维矩阵和三维矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，使用下面的代码，创建3个2×2的矩阵A、B、C。
import numpy as np A = [[1, 2], [3, 4]] B = [[5, 6], [7, 8]] C = [[9, 9], [9, 9]] 二维矩阵-&gt;二维矩阵 在python中，进行矩阵拼接的语句为：
M = np.concatenate((m1, m2, m3), axis=k) 其中，m1、m2、m3为需要进行拼接的矩阵，axis表示为在哪一个维度进行拼接。
例如：
M = np.concatenate((A, B, C), axis=0) 这行语句表示将A、B、C三个矩阵在第0维（列方向）进行拼接，那么得到的M矩阵为：
如果使用的axis为1（行方向），即：
M = np.concatenate((A, B, C), axis=1) 那么得到的拼接矩阵如下：
二维矩阵-&gt;三维矩阵 从上面的演示可知，通过选择不同的axis值，可以使矩阵在不同的维度进行拼接，那么我如果想让A、B、C三个矩阵堆叠在一起，形成一个2×2×3的三维矩阵呢？
例如，希望得到如下矩阵：
显然直接改成axis=2是行不通的。
M = np.concatenate((A, B, C), axis=2) 因为会产生如下报错：
Traceback (most recent call last): File "D:\Anaconda\envs\py37\lib\code.py", line 90, in runcode exec(code, self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cadb22f9e8cf630cf0457082c43f907e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ffe15edc1c1a2c931cdf78424f0388/" rel="bookmark">
			fiddler手机抓包/模拟器抓包配置代理没有网络问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近工作需要对app进行网络抓包，安装了fiddler工具，使用夜神模拟器模拟手机抓包，各种配置都配置完了，但是app还是不能联网，现将解决方法记录如下：
【问题原因】
当我们在手机或者模拟器安装fiddler证书时，证书都是安装在用户证书目录下的，Android7.0版本之后的应用是默认只信任系统证书，不信任用户证书的，所以我们有两种方法去解决这个问题。1、将Fiddler证书装到系统证书目录下，伪装成系统证书，2、使用Android5.0版本的手机或者模拟器，下面使用第一种方法。
1、导出fiddler证书 1、在此之前请确保你的fiddler已经安装配置完成！
2、首先关闭fiddler，然后下载fiddlercertmaker.exe工具，双击下载好的fiddlercertmaker.exe（确保已关闭Fiddler），会弹出提示导入证书成功这个对话框，点击确定
3、导出fiddler证书到电脑桌面，Tools -&gt; Options -&gt; HTTPS -&gt; Actions -&gt; Export Root Certificate to Desktop
完成之后在电脑桌面会出现一个FiddlerRoot.cer证书
2、安装openssl 1、到openssl下载地址下载好windows版的openssl
2、点击安装，一路点击下一步
3、安装完成后需要配置环境变量，将安装目录的bin目录配置到环境变量
4、打开终端输入openssl version 或者输入openssl出现下图信息表示安装成功
3、证书格式转换 1、将Fiddler cer证书转pem证书，在cmd输入如下命令：openssl x509 -inform DER -in 电脑桌面证书路径.cer -out 电脑桌面证书路径.pem
openssl x509 -inform DER -in C:\Users\Administrator\Desktop\FiddlerRoot.cer -out C:\Users\Administrator\Desktop\FiddlerRoot.pem 2、计算pem证书的hash值，输入如下命令：openssl x509 -inform PEM -subject_hash_old -in 电脑桌面证书路径
openssl x509 -inform PEM -subject_hash_old -in C:\Users\Administrator\Desktop\FiddlerRoot.pem 上图的e5c3944b就是pem证书的hash值。
3、使用e5c3944b对pem证书重命名，命令如下：ren 电脑桌面证书路径 证书hash值.0
ren C:\Users\Administrator\Desktop\FiddlerRoot.pem e5c3944b.0 4、安装证书到系统目录 这里我使用的是夜神模拟器
1、打开终端输入adb connect 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50ffe15edc1c1a2c931cdf78424f0388/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b67f357c88c64fca11d88cbf1b7b7e7/" rel="bookmark">
			四轮两驱小车（一）：STM32驱动AS4950
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言：
效果展示：
车体展示：
前言：
在前两周的时间里，我对上个版本的小车进行了一个更新换代，将原本的4驱小车换成了4轮两驱小车，舍弃了树莓派4B作为上位机。新版小车采用两个520直流减速电机搭配AS4950电机芯片来差速行进，后面采用两个万向轮带着，5路灰度传感器循迹，用HC_SR04超声波模块中断式测距，用HC_08蓝牙模块与手机进行通信，同时搭载MPU6050模块来拐直角弯。
效果展示： 新版小车功能效果展示
车体展示： 正文开始： 本次改进依旧沿用上次制作的电路板，板载了AS4950电机芯片，在这款电机芯片的帮助下，我甚至连死区时间都不用配置，AS4950自行帮我们处理。
如图就是AS4950及其原理图
根据AS4950的数据手册，我们可以整理一下，得到一个表格
IN1IN2电机驱动状态任意任意停止00停止01正转10反转11刹车 从这里，我们就可以看到AS4950有4种驱动状态：
1：IN1端口输入PWM，IN2端口输入低电平，芯片输出正电流，电机正转；
2：IN1端口输入低电平，IN2端口输入PWM，芯片输出负电流，电机反转；
3：IN1端口输入高电平，IN2端口输入PWM，芯片输出正电流，电机正传；
4；IN1端口输入PWM，IN2端口输入高电平，芯片输出负电流，电机反转；
我这里就选择了方式1和方式4来控制电机正反转，利用两轮差速来循迹和拐弯，使用TIM8的CH2（PC7）CH3(PC8)作为PWM输出，CH2N（PB0）CH3N(PB1)作为推挽输出。在输出PWM上，我选择了输出比较模式，通过修改CCR寄存器来调整占空比
代码部分： void Motor3_Init() { //PC7 -&gt; TIM8_CH2 GPIO_InitTypeDef GPIO_InitStructure; TIM_TimeBaseInitTypeDef	TIM_TimeBaseStructure; TIM_OCInitTypeDef	TIM_OCInitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8|RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOC,ENABLE); GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//PC7为PWM GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOC, &amp;GPIO_InitStructure);//PC7 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;//PB0用做推挽输出 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure);//PB0 GPIO_WriteBit(GPIOB, GPIO_Pin_0, Bit_RESET);// 0 0 状态是AS4950休眠状态 TIM_TimeBaseStructure.TIM_ClockDivision = 0x0; TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseStructure.TIM_Period = 9999; TIM_TimeBaseStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b67f357c88c64fca11d88cbf1b7b7e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fba9221bdef143c9d4b3073f076fd0c/" rel="bookmark">
			SpringBoot&#43;Prometheus&#43;Grafana 实现自定义监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Spring Boot 工程集成 Micrometer 1.1引入依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.micrometer&lt;/groupId&gt; &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt; &lt;/dependency&gt; 1.2配置
management.server.port=9003 management.endpoints.web.exposure.include=* management.endpoint.metrics.enabled=true management.endpoint.health.show-details=always management.endpoint.health.probes.enabled=true management.endpoint.prometheus.enabled=true management.metrics.export.prometheus.enabled=true management.metrics.tags.application=voice-qc-backend 这里management.endpoints.web.exposure.include=*配置为开启 Actuator 服务，因为Spring Boot Actuator 会自动配置一个 URL 为/actuator/Prometheus的 HTTP 服务来供 Prometheus 抓取数据，不过默认该服务是关闭的，该配置将打开所有的 Actuator 服务。
management.metrics.tags.application配置会将该工程应用名称添加到计量器注册表的 tag 中去，方便后边 Prometheus 根据应用名称来区分不同的服务。
1.3监控jvm信息
然后在工程启动主类中添加 Bean 如下来监控 JVM 性能指标信息：
@SpringBootApplication public class GatewayDatumApplication { public static void main(String[] args) { SpringApplication.run(GatewayDatumApplication.class, args); } @Bean MeterRegistryCustomizer&lt;MeterRegistry&gt; configurer( @Value("${spring.application.name}") String applicationName) { return (registry) -&gt; registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fba9221bdef143c9d4b3073f076fd0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e3f625d4ba0b27bfed498836a581ef0/" rel="bookmark">
			程序猿的福音——猿如意使用有感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		猿如意介绍： 猿如意是一款面向开发者的辅助开发工具箱，包含了效率工具、开发工具下载，教程文档，代码片段搜索，全网博文搜索等功能模块。帮助开发者提升开发效率，帮你从“问题”找到“答案”。
猿如意的下载地址： https://devbit.csdn.net/?source=csdn_ad_article&amp;stype=chat
猿如意使用体验： 从UI上来说，整体简洁大方，看着舒服，不会给人乱糟糟的感觉，是我喜欢的风格。
分为6个模块：首页、效率办公、开发工具、教程文档、一行代码、ChatGPT.
截止到2022-12-16，上面共有58个效率工具，还是挺多挺实用的，运行起来也比较流畅，同时会把最近使用的工具放在首页位置，方便使用，同时对工具进行了系统工具、格式转换、压缩编码、图像处理、数据模拟分类，方便查找对应工具。（开发工具如此）
教程文档功能也是很简洁清爽，别网页端直观舒服多了，但是有个小建议，是否可以把分类显示为多行，而不是后面的箭头，或者可以用户自主排序，例如本人是系统工程师和网络工程师，我浏览最多的肯定是操作系统和网络相关的。
一行代码，我也比较喜欢，刚刚还用里面的爱心树向我老婆秀了一把狗粮，哈哈，没得说。这里面还有一个很使用的功能：AI助手生成代码，可以将A代码转换为其他语言的代码；还是和教程文档一样，希望可以多行显示或自定义显示语言排序。
重点说下 ChatGPT:
优点：显示上比较清爽简洁，一目了然；
缺点：等待时间略长，而且显示的时候是一行一行的蹦出来，还是希望”唰“一下全出来。
整体使用总结： 非常推荐：猿如意集成了日常使用较频繁的工具以及编程语言，界面清爽、简洁大方，是程序猿很友好的办公工具。
猿如意的下载地址： https://devbit.csdn.net/?source=csdn_ad_article&amp;stype=chat
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac84165dd929e7b55bea8dd92c77f0cb/" rel="bookmark">
			Qt扫盲-QTabWidget理论总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QTabWidget理论总结 1. 简述2. 用法流程3. 选项卡设置3. 页面信息3. 外观4. 扩展 1. 简述 QTabWidget 提供一个选项卡栏和一个“页面区域”，用于显示与每个选项卡相关的页面。默认情况下，选项卡栏显示在页面区域上方，但可以使用不同的配置（可以设置到上下左右）。每个选项卡都与不同的QWidget（称为页面）相关联。页面区域中仅显示当前页面；所有其他页面均处于隐藏状态。用户可以通过单击其选项卡或按其 Alt+字母快捷方式（如果有）来显示不同的页面。
最典型的就像Windows系统的详细属性，在对话框的顶部有一系列的选项卡可以使用来切换不同页面。
2. 用法流程 使用 QTabWidget 的正常方法是执行以下操作：
创建一个 QTabWidget。为选项卡对话框中的每个页面创建一个 QWidget，但不为它们指定父小部件。将每个页面需要的控件 放置 到页面中，使用布局将它们正常定位。调用 addTab() 或 insertTab() 将第 2 步 的页面和选项卡绑定并插入到 QTabWidget中，为每个选项卡提供一个合适的标签和一个可选的键盘快捷键。 3. 选项卡设置 我们可以使用 setTabText() 或 setTabIcon() 更改选项卡的文本和图标。可以使用 removeTab() 把选项卡及其关联的页面 删除。每个选项卡在任何给定时间都处于启用或禁用状态（请参阅 setTabEnabled()）。如果启用了选项卡，则会正常绘制选项卡文本，用户可以选择该选项卡。如果禁用，则以不同的方式绘制选项卡，用户无法选择该选项卡。请注意，即使禁用了选项卡，页面仍可见，例如，如果所有选项卡都恰好被禁用。因为选项卡必定有一个选中的，这个用控件封装好的，可以不管的。
3. 页面信息 当前页面索引可用作 currentIndex()，同时 currentWidget() 指向当前页面。我们可以使用 widget() 检索指向具有给定索引的页面的指针，并且可以使用 indexOf() 查找小部件的索引位置。使用 setCurrentWidget() 或 setCurrentIndex() 显示特定页面。
同时，我们还可以监控页面发生改变时得情况，当用户选择页面时发出信号 currentChanged()。
3. 外观 选项卡的位置由 tabPosition 定义，其形状由 tabShape 定义。
可以设置选项卡的两种形状，方形或者三角形的
可以设置 选项卡是否带按钮 （通过 setTabsClosable()）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac84165dd929e7b55bea8dd92c77f0cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9460929b44572dd36ec81867509799d/" rel="bookmark">
			超微A&#43; Server 4124GS-TNR做主板集成RAID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 开机进BIOS，查看BIOS的启动模式 UEFI
如果是UEFI则查看Advanced选项下面的Marvell Boot optimized M.2/SATA Raid controller
查看物理磁盘 创建RAID 选项2块硬盘，然后NEXT 改成Yes然后Next 创建成功，接着按OK 验证 当然如果BIOS启动是Dual或是Legacy开机自检的过程会出现：Ctrl+M的提示按组合键进入配置介面 按回车键，选择配置 按空格键和上下键选择2块硬盘，注意硬盘前面得带上*号，说明选上了 按着按回车键 用上下键，选择Next 回车，会出现提示，按Y同意创建 至此RAID创建成功 按F10按Y键，保存退出，重启 剩下的就是开始安装OS了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b86afa54667f85be5aeea7bdbbf1d9e0/" rel="bookmark">
			pytest &#43; yaml 框架 -13.多环境配置切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 当我们在测试环境写好自动化的代码，领导说你把代码部署到联调环境再测一测，这时候去改用例里面的配置是很痛苦的。
所以我们在设计自动化用例的时候，就先要想到多环境的配置与切换。
多环境配置 如果需用到多套环境 test/uat 等，那么应该在用例的根目录(pytest.ini 同级文件)创建一个config.py 文件
pip 安装插件
pip install pytest-yaml-yoyo 多套环境切换功能在 v1.1.0 版本上实现
class Config: """多套环境的公共配置""" version = "v1.0" class TestConfig(Config): """测试环境""" BASE_URL = 'http://192.168.1.1:8000' MYSQL_HOST = "192.168.1.1" MYSQL_USER = "root" MYSQL_PASSWORD = "123456" MYSQL_PORT = 3306 MYSQL_DATABASE = "xxx" # 连接数据的库名 class UatConfig(Config): """联调环境""" BASE_URL = 'http://192.168.1.3:8080' MYSQL_HOST = "http://192.168.1.3" MYSQL_USER = "root" MYSQL_PASSWORD = "654321" MYSQL_PORT = 3306 MYSQL_DATABASE = "xxx" # 连接数据的库名 # 环境关系映射，方便切换多环境配置 env = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b86afa54667f85be5aeea7bdbbf1d9e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cbcc89eb9df4b290a20d4c857be7acb/" rel="bookmark">
			新征程-猿如意试用一波！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		猿如意传送门（必带）
猿如意下载地址：猿如意-程序员的如意兵器,工具代码,一搜就有
猿如意使用了几次了，今天来想分享一下我对于猿如意的使用感受吧！！
先说结论：值得每个程序员都在电脑里安装一个
作为一名程序员，猿如意真的帮了我挺多忙的！比如里面各种开发工具、效率文具、一行代码功能等等，都是非常实用的，而且用起来也比较方便。
可能很多人还不知道猿如意是什么，先给大家科普一下
猿如意是一款面向开发者的辅助开发工具箱，包含了效率工具、开发工具下载，文档教程，代码片段搜索，全网搜索等功能模块。帮助开发者提升开发效率，帮你从“问题”找到“答案”。
再来说说里面有哪些我觉得值得一用的功能
先来说说我最常用的“教程文档”搜索功能。进入猿如意首页之后，点击左侧的教程文档，就可以搜索你想要的各种开发教程、文档等等。
使用场景描述：
主观感受：对于开发人员或者说技术人员来说工具是必不可少的一个东西，“磨刀不误砍柴工”。有一个好的工具非常的重要，看看上图中的分类是不是有大家所使用或者熟悉的工具visual studio code pycharm 等等。。。
收录的工具还是蛮多，蛮全的大家可能尝试一把。还有一些可用的代码片段。。
认为此功能不足的地方：
不足之处，总的来说还可以，
1、就是使用起来还是要丝滑一些。。。。
2、工具也可能整个排行或都评分什么的会不会更好一点
最后总结：
CSDN上还是有不少大牛的，“磨刀不误砍柴工”，有个好工具可以事半功倍，大家可以尝试下。
猿如意传送门（必带）
猿如意下载地址：猿如意-程序员的如意兵器,工具代码,一搜就有
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31fde047102d0567fb6904bcc272120e/" rel="bookmark">
			windows 连接蓝牙耳机失败 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows 连接蓝牙耳机失败 解决方法 如果我们在windows7或windows10电脑中连接蓝牙却出现了连接失败的状况，这要怎么办呢，可能是我们没有打开电脑的蓝牙功能，这时我们点击打开蓝牙网络的属性，勾选Bluetooth设置的选项即可，也可能是没有开启蓝牙服务哦，打开服务列表，找到Bluetooth服务，将启动类型改为启动，就能正常连接蓝牙耳机了。
原因有以下几种：
电脑端蓝牙驱动安装错误（win10驱动一般问题少，win7驱动缺少比较多）电脑端蓝牙服务是否正常开启电脑端蓝牙设置错误蓝牙协议不匹配配对操作时机错误 windows7连接蓝牙耳机失败解决方法
一、没有开启蓝牙
1、打开“控制面板”，打开“网络和共享中心”
2、点击左边“更改适配器设置”，右键蓝牙网络，打开“属性”
3、进入Bluetooth，点击“Bluetooth设置”，确认这三项都勾选开启后，点击“确定”保存
二、蓝牙服务
1、如果还是不行，右键计算机打开“管理”，进入左边的“服务”选项
2、双击打开其中的“Bluetooth”服务
3、将启动类型改为“自动”并点击下面“启动”再保存就可以连接了
三、选择了错误的蓝牙服务项目
不同蓝牙设备支持不同类别的功能服务，要结合自身设备正确选择，通用驱动安装的话，往往会选择了过多的功能服务。
在“开始”里点击“控制面版”，点击“硬件和声音”找到“添加设备”。如图。 将蓝牙耳机关机后，长按蓝牙耳机电源键，进入配对模式（不同蓝牙耳机配对方法可以稍有不同），之后在电脑端选择要添加的蓝牙耳机 。
系统就会提示正在与蓝牙适配器连接 ，然后提示添加成功。
点击“开始”-“设备和打印机”，就可以看到添加的蓝牙耳机了，如图。
在蓝牙耳机上点击右键，选择“属性”，在弹出的窗口中选择“服务” ，如图。
耳机的选项并没打√，就无法使用蓝牙耳机听音乐了，要勾选，勾选后系统会提示安装驱动，驱动安装成功后，在系统右下角找到喇叭图标点击右键-【播放设备】，就看到蓝牙音频选项了。这一步要根据不同耳机设备，尝试选择不同的选项。选择错误的话，在设备管理器中可能会出现“bluetooth外围设备”感叹号提示
四、查看电脑蓝牙适配器及蓝牙设备版本
蓝牙配件有时需要满足最低的蓝牙规格（版本）要求，才能充分发挥功能。
1、在任务栏上的搜索框中，键入“设备管理器”，然后从结果列表中选择它。
2、选择“蓝牙”旁边的箭头以将其展开。
3、选择蓝牙无线收发器列表（你的蓝牙无线收发器可能只列为无线设备）。
4、选择“高级”选项卡，然后在“固件”或“固件版本”区域查找 LMP（链路管理器协议）列表。你可通过该编号了解设备上的 LMP 版本。
在下表中查找你的版本号，找到与你的 LMP 版本对应的蓝牙核心规格编号。这是你的设备完全支持的最高核心规格。具有较高规格的配件可能仍可以工作，但功能将受到限制。
链路管理器协议 (LMP) 版本蓝牙核心规格LMP 0蓝牙核心规格 1.0b（已撤销）LMP 1蓝牙核心规格 1.1（已撤销）LMP 2蓝牙核心规格 1.2（已撤销）LMP 3蓝牙核心规格 2.0 + EDR（已撤销）LMP 4蓝牙核心规范 2.1 + EDR （已弃用、待撤销）LMP 5蓝牙核心规范 3.0 + HS （已弃用、待撤销）LMP 6蓝牙核心规格 4.0LMP 7蓝牙核心规格 4.1LMP 8蓝牙核心规格 4.2LMP 9蓝牙核心规格 5.0LMP 10蓝牙核心规格 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31fde047102d0567fb6904bcc272120e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183cea2cde38ce8912a55b0a83a39f2c/" rel="bookmark">
			Chapter 06:连接多个图像显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着本专栏的学习，你可以快速的掌握如何使用Opencv，请注意更多的学习内容还请看官方文档，本专栏是为了给对于视觉方向比较感兴趣的新手所写，带领它们做好一个基础的框架，让他们快速学会如何通过这个框架调取函数做自己感兴趣的项目，同时我也正在更新我的Opencv项目实战专栏，你可以搭配着一起学习。
订阅此专栏， (2条消息) Opencv项目实战_夏天是冰红茶的博客-CSDN博客
这次我们要实现的效果是让让多张图片在一个窗口中显现，我们使用matplotlib，也可以实现，但今天我们自己创一个函数来实现这个功能，有的时候，我们在做实时检测时可以用到它，与原来进行对比。
先来开个小菜，比如，如果只是实现水平、垂直的合并，非常简单。我们只需要用到np.hstack和np.vstack来实现。
import cv2 import numpy as np img = cv2.imread('Resources/lena.png') img=cv2.resize(img,(0,0),None,0.5,0.5) imgHor = np.hstack((img,img)) imgVer = np.vstack((img,img)) # 水平，垂直 cv2.imshow("Horizontal",imgHor) cv2.imshow("Vertical",imgVer) cv2.waitKey(0) ​​
如果只有两个，无可厚非，但我们有时候，要面对四个、六个、八个就捉襟见肘了。我们需要封装一个函数，让他通过传入图像构成的列表，使其能够显示我们的窗口。
import cv2 import numpy as np def stackImages(scale,imgArray): rows = len(imgArray) #行 cols = len(imgArray[0]) #列 rowsAvailable = isinstance(imgArray[0], list) width = imgArray[0][0].shape[1] height = imgArray[0][0].shape[0] if rowsAvailable: for x in range ( 0, rows): for y in range(0, cols): if imgArray[x][y].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/183cea2cde38ce8912a55b0a83a39f2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f4d9a4759fc79fdc90615a9862d164/" rel="bookmark">
			win11设置右键显示全部菜单内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先用鼠标右键点击“开始”按钮(或者按Win+X键)，选择点击 “Windows 终端(管理员)”
然后在终端里粘贴如下代码并回车； reg.exe add "HKCU\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\InprocServer32" /f /ve 操作成功之后，重启Win11系统，重启后，再右键，发现菜单回来了，可以全部显示出来了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/153582b0e303efa2880ea7084e692467/" rel="bookmark">
			python 作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python程序设计第10周实验报告
班级：19数据 成绩：
实验日期： 2020 年 11 13日
实验目的： 体会有难度的Python函数
实验内容：
一、编程题
1、题目要求：
举例说明在函数内部修改形参的值不会影响实参。
程序文件名是 addone.py
程序源代码：
def addone(a):
print(a)
a+=1
print(a)
程序运行结果：
==========
a=3
addone(a)
3
4
a
3
分析：在函数内部修改了形参a的值，但是当函数运行结束时，实参a的值并没有被修改
2、题目要求：
举例说明位置参数。
程序文件名是 girth.py
程序源代码：
def girth(width,height):
return 2*(width+height)
print(girth(3))
程序运行结果：
Traceback (most recent call last):
File “F:\python\19数据班60号庄楠楠第10周实验报告（python)\girth.py”, line 3, in print(girth(3))
TypeError: girth() missing 1 required positional argument: ‘height’
girth(5,12)
34
============ RESTART: F:\python\19数据班60号庄楠楠第10周实验报告（python)\girth.py ===========
Traceback (most recent call last):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/153582b0e303efa2880ea7084e692467/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c61d71c7dbaa083262f4ce49aad0d9b0/" rel="bookmark">
			vue3&#43;element-plus 配套使用日期时间选择器默认英文修改为中文 完整引入和按需引入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 默认情况行如下： 一、按需引入的解决方案： 在你使用 日期选择器的vue文件夹
1、引入： import zhCn from "element-plus/lib/locale/lang/zh-cn"; 2、在setup下面声明一个变量 （别问我什么意思，我也不知道，网上是这样说的） setup(props, context) { let locale = zhCn; return { locale }; }, 3、然后用下面组件包裹你使用的日期选择器 就像这样 注意：你声明的的变量要绑定在组件上
&lt;el-config-provider :locale="locale"&gt;&lt;/el-config-provider&gt; &lt;el-form-item label="时间筛选："&gt; &lt;el-config-provider :locale="locale"&gt; &lt;el-date-picker type="datetime" placeholder="选择开始时间" /&gt; -- &lt;el-date-picker type="datetime" placeholder="选择结束时间" /&gt; &lt;/el-config-provider&gt; &lt;/el-form-item&gt; 二、完整引入 在main.ts文件夹里面下，如下： import locale from 'element-plus/lib/locale/lang/zh-cn'; 然后注册全局 app.use(ElementPlus,{locale}) 注意： 使用完整引入需要引入element-plus官网引入完整引入的方法 如下：
import ElementPlus from 'element-plus' import 'element-plus/dist/index.css' import locale from 'element-plus/lib/locale/lang/zh-cn';//写了他就能变成中文 const app = createApp(App) app.use(ElementPlus,{locale}) 使用后效果如下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58d7f87a991fd42d195f132eeb0bc912/" rel="bookmark">
			【深度学习】(5) ShuffleNetV2 代码复现，网络解析，附pytorch完整代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天和各位分享一下如何使用 Pytorch 构建 ShuffleNetV2 卷积神经网络模型。
ShuffleNetV2 的原理和 TensorFlow2 实现方法可以看我下面这篇博文，建议大家一定要看一下，原理部分本文不再赘述
https://blog.csdn.net/dgvv4/article/details/123431553
1. 网络简介 ShuffleNetV2 网络模型是在 2018 年，由旷视科技和清华研究组的相关学者在 ECCV 会议上提出的。该模型证明了在同等复杂度的情况下，ShuffleNetV2 要比 ShuffleNetV1 和 MobileNetV1 更加准确。
这个网络的优势在于：（1）作为轻量级的卷积神经网络，ShuffleNetV2 相比其他轻量级模型速度稍快，准确率也更高；（2）轻量级不仅体现在速度上，还大大地减少了模型的参数量，并且通过设定每个单元的通道数便可以灵活地调整模型的复杂度。
在同一硬件实验设备下，使用相同的数据集，则得到的各模型的准确率和模型大小的平衡大小比较，如下图所示。
可以看出，作为高性能的轻量级设计的 CNN，ShuffleNetV2 网络很好地权衡了速度和准确率之间的关系。首先 ShuffleNetV2 网络内部的卷积块 Stage2，Stage3 和 Stage4 是由一个下采样单元和多个基础单元连接构成，如下图所示。
ShuffleNetV2 在基于 ShuffleNetV1 的版本上遵循了以下四个准则： （1）图像通道宽度均衡可以使内存访问成本（MAC）最小化 对承担大部分计算开销的逐点卷积进行分析，假定输入通道数 和输出通道数 ，通过网络各层时特征图的空间大小为 ，那么 卷积核的计算量（FLOPs）为 ，因前提是内存足够的情况下，其内存消耗 ，则 B 的公式：
即仅当 时，MAC 取得最小值。因此，本模型的基本单元块和下采样单元的输入输出通道都相等。
（2）增加组卷积的同时将使得内存访问成本的增加 分析组卷积，计算量 （g 为组数），则内存消耗 。假设固定输入 和计算量 B，则 MAC 又可表示为：
观察公式，若组数 g 增加时，内存量 MAC 也会增大。 （3）网络碎片化操作将会降低并行度 若采用如 Inception 网络那样的“多路”结构，即一个网络块中有多个卷积或池化操作。这样便容易造成网络碎片化，从而运行速度变慢，并行度降低。 （4）元素操作不可忽略 实验也发现像元素级的操作（ReLU 函数，Add 等）会带来较大的内存消耗（MAC），即使它们的运算量较小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58d7f87a991fd42d195f132eeb0bc912/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aad7ecacbbecb74413906cd58c9f8b35/" rel="bookmark">
			vulhub靶场框架漏洞复现手册（strusts2\shiro\weblogic）附工具链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
一、struts2远程代码执行
s2-029
s2-061
s2-001
二、shiro反序列化漏洞复现
总结
前言 工具+手工复现vulhub靶场下的框架漏洞，包括struts2远程代码执行(2-029,s2-061，s2-001),shiro反序列化漏洞（CVE-2016-4437）,weblogic反序列化漏洞（CVE-2017-10271,CVE-2018-2628,CVE-2018-2894,CVE-2020-14882,ssrf,weak-password）。持续更新中...
一、struts2远程代码执行 漏洞介绍：Struts2是apache项目下的一个web 框架，普遍应用于阿里巴巴、京东等互联网、政府、企业门户网站
漏洞特征：
1. 查看被测应用系统的源码，URL接口地址以 “.action” “.do” 结尾或地址中包含“!”符号，或者在被测应用的服务器上查看应用所在目录/WEB-INF/lib/下的jar文件，若存在struts2-core-
2.*.**.jar或xwork-core-2.*.**.jar格式的jar文件，则需检测是否存在Struts2远程代码执行漏洞。
s2-029 1. 拉取漏洞环境镜像
docker pull medicean/vulapps:s_struts2_s2-029 2. 启动漏洞环境
docker run -d -p 8080:8080 medicean/vulapps:s_struts2_s2-029 3. 测试靶场
访问kali ip:8080，出现如下代表靶场搭建成功
4. 使用工具利用漏洞
（1）Liqun验证
验证结果：存在漏洞
命令执行
工具链接：https://pan.baidu.com/s/1aLIAJkEUlv-6lsuCO9lEZw 提取码：8lk3
（2） Strusts2_Test工具
命令执行
工具链接：https://pan.baidu.com/s/1tsP2yPeX-QtKHAmuD1ITSA 提取码：8lk3
（3） Strusts2漏洞检查工具
命令执行
工具链接：https://pan.baidu.com/s/1ffOoxKGnuTXp7-Mvbu__2Q 提取码：8lk3
5. 手工利用漏洞
（1） 刷新页面抓包，发送到repeater。如果url的位置只有ip:8080，就手动在后面添加/default.action?message=。之后在message=后拼接poc
#POC (%23_memberAccess['allowPrivateAccess']=true,%23_memberAccess['allowProtectedAccess']=true,%23_memberAccess['excludedPackageNamePatterns']=%23_memberAccess['acceptProperties'],%23_memberAccess['excludedClasses']=%23_memberAccess['acceptProperties'],%23_memberAccess['allowPackageProtectedAccess']=true,%23_memberAccess['allowStaticMethodAccess']=true,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream())) 返回包爆出了用户权限
s2-061 1. 进入vulhub目录用docker拉取镜像启动环境。如果没有启动成功是因为上一个开启的靶场占用了8080端口。重启一下docker就行。
重启docker命令：systemctl restart docker 开启环境命令：docker-compose up -d 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aad7ecacbbecb74413906cd58c9f8b35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2332d9bcc74d79dffb3dd57274b84361/" rel="bookmark">
			A&#43;B Problem C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 继上次发表的A+B Problem C语言后，今天我们来学习一下A+B Problem C++
正文 什么是C++？ C++既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。C++擅长面向对象程序设计的同时，还可以进行基于过程的程序设计。简单来说，C++就是一种计算机语言。
了解了这些，我们就可以来做题了。我绝对不会告诉你，注释在代码里。
AC代码 #include &lt;iostream&gt; using namespace std; int main(){ // io speed up const char endl = '\n';//这里用的是char,也可以用其他的 std::ios::sync_with_stdio(false); cin.tie(nullptr); int a, b; while (cin &gt;&gt; a &gt;&gt; b){//输入a+b cout &lt;&lt; a+b &lt;&lt; endl;//输出a+b } return 0; } 个人认为，这道题还是很简单了。 对了，如果有错误的话可以在下方留言
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcd8d985ba30159316c45258bd2133a2/" rel="bookmark">
			redis7知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. redis单线程为啥会这么快2. redis数据类型和底层存储结构2.1 string类型2.1.1 SDS 2.2 hash类型2.3 list类型2.4 set类型（集合）2.5 zset类型（有序集合）2.6 ziplist压缩列表2.7 listpack2.8 quicklist-快速列表2.9 skiplist 跳表 3. redis高可用方案（集群策略）4. redis淘汰key算法5. redis过期key删除策略6. redis分布式锁7. redis数据持久化8. redis如何配置key的过期时间，实现原理9. redis主从复制原理10. redis高并发问题11. 热点数据缓存重建问题 1. redis单线程为啥会这么快 基于内存操作，一条命令几十纳秒单线程，减少线程切换使用io多路复用技术使用高效的数据存储结构，链表和数组 2. redis数据类型和底层存储结构 参考： Redis的五种数据结构的底层实现原理
type数据类型，对应的是value五种数据类型。
字符串：REDIS_STRING；
哈希：REDIS_HASH；
列表：REDIS_LIST；
集合：REDIS_SET；
有序集合：REDIS_ZSET
encoding类型如下图
String类型的编码方式，即encoding有三种：int、embstr、raw。
value的值是整数，encoding为int，没有对应底层数据结构；
value长度小于32，encoding为embstr，长度大于，32编码为raw，embstr和raw都使用SDS数据结构存储。
2.1 string类型 By default, a single Redis string can be a maximum of 512 MB.
2.1.1 SDS 参考： Redis 源码解读——sds
sds优势
提升性能，sds直接使用len字段获取长度，时间复杂度是o(1), c语言中获取字符串长度是遍历，直到遇到‘\0’,时间复杂度是o(n)保证二进制安全，sds遇到‘\0’不会结束，c语言字符串遇到‘\0’结束减少内存再分配次数， sds修改字符串不一定会重新分配内存，采用的是空间与分配和惰性空间释放策略来避免内存再分配，len小于1M，会分配2len(str)的空间，修改时，空间够则不进行分配，不够则再分配2len(总str), 修改后字符串长度大于1M，则再分配1m的未使用空间， 当c语言修改字符串，会进行内存再分配策略
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcd8d985ba30159316c45258bd2133a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f7ab22a650d47eb346ccf1a87dbfcee/" rel="bookmark">
			pycharm输出中文乱码解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在使用pycharm运行print时，发现运行后控制台输出的是乱码。
控制台输出如下
这是只需要 File-&gt; settings-&gt; Editor-&gt; General-&gt; Console
发现这时默认的编码是GBK，只需将其改成与文件编码一致的UTF-8即可。
如下图，并选择OK进行确认：
此时再运行一下程序，这是已经可以成功输出中文！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88cb285ee0e5b88c55c3a4fc2ba58a70/" rel="bookmark">
			A&#43;B Problem C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：你的任务是计算A+B，这是专门为初学者提供的。 输入：输入两个整数A，B（0≤A，B≤1000）
输出：输出A+B的和
样例输入：1 5
样例输出：6
众所周知，A+B Problem是C/C++中最简单的一道题，所以这期我们简单了解一下做法就可以了
话不多说，直接上c语言代码
#include &lt;stdio.h&gt;//头文件 int main(){ int a, b; while(scanf("%d %d",&amp;a, &amp;b) != EOF){ printf("%d\n", a + b);//a+b的值 } return 0; } 最后，点个赞再走吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b66823a0e9a03e583fec1fe62b29e8/" rel="bookmark">
			Android事件分发机制之dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
Android事件分发机制可以说是我们android工程师面试中必考题，弄懂它的原理是我们避不开的任务，随意长痛不如短痛，花点时间干掉他，我们开始吧
Android事件分发机制简介
Android事件分发机制的发生在View与View之间或者ViewGroup与View之间具有镶嵌的视图上，而且视图上必须为点击可用。当一个点击事件产生后，它的传递过程遵循如下顺序：Activity -&gt; Window-&gt;View,即事件先传递给Activity,再到Window,再到顶级View,才开始我们的事件分发；
Android事件分发相关概念
Android事件分发机制主要由三个重要的方法共同完成的
1. dispatchTouchEvent:用于点击事件的分发
2. onInterceptTouchEvent：用于点击事件的拦截
3. onTouchEvent:用于处理点击事件
主要注意View中是没有onInterceptTouchEvent()方法的
Android事件分发机制的分发例子
这里两个ViewGroup嵌套View来演示，
一、MyView
继承View并覆写其三个构造方法，覆写dispatchTouchEvent和onTouchEvent
public class MyView extends View {
public MyView(Context context) {
super(context);
}
public MyView(Context context, AttributeSet attrs, int defStyleAttr) {
super(context, attrs, defStyleAttr);
}
public MyView(Context context, AttributeSet attrs) {
super(context, attrs);
}
@Override
public boolean dispatchTouchEvent(MotionEvent event) {
System.out.println("MyView dispatchTouchEvent");
return super.dispatchTouchEvent(event);
}
@Override
public boolean onTouchEvent(MotionEvent event) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54b66823a0e9a03e583fec1fe62b29e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20f0ec485c9420b81b02d8542dd7d718/" rel="bookmark">
			linux tc流量控制（一）：classless qdisc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是tc tc全称为traffic control，是iproute2包中控制内核中流量的工具。在内核的网络协议栈中，专门有这样一个处理网络流量的地方（在XDP之后，netfilter之前），tc就是在这个地方读取网络数据包（此时已经是sk_buffer）进行控制、分发、丢弃等操作。需要注意的是，tc既可以处理传出的数据包（egress），也可以处理传入的数据包（ingress），但对传入的数据包处理的功能较少。本文不涉及ingress内容。
核心概念：qdisc 我们使用tc的时候，最先会遇到一个叫做qdisc的名词，其实我们经常能看见它，就是在每次我们执行ip命令的时时候
root@ubuntu:~# ip l 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000 link/ether 00:0c:29:58:48:55 brd ff:ff:ff:ff:ff:ff altname enp2s1 比如在这里，我们可以看到每个网络设备都在mtu后面都有一个qdisc，qdisc后面还有一个词，上面的lo的qdisc是noqueue，ens33的qdisc是fq_codel。
qdisc实际是queueing discipline的缩写，我们可以将其看作一个具有一定规则的队列。当tc处理网络包时，会将包入队到qdisc中，这些包会根据指定的规则被内核按照一定顺序取出。tc中已经内置了很多不同的qdisc，有些qdisc可以带参数，比如ens33上面的qdisc参数是这样的。
root@ubuntu:~# tc qdisc show dev ens33 qdisc fq_codel 0: root refcnt 2 limit 10240p flows 1024 quantum 1514 target 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20f0ec485c9420b81b02d8542dd7d718/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aef93c224adc3b7239a9dfc2315778c/" rel="bookmark">
			linux 更改用户权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一直在忙项目上的事情，没时间更新，项目基本上已经接近尾声，主要是一些部署的收尾工作，在部署的过程中，也遇到了一些问题。先慢慢记录吧，今天主要记录的是：
如何提升普通运行为管理员身份？在日常开发过程中，调用第三方程序（该程序由于内部实现的原因，必须采用管理员身份运行，尴尬了，不好的实现方式，但也没办法，只能硬着头皮自己整）。这里就需要用到普通用户提升为管理员身份。
详细步骤如下：
1.在桌面打开终端，在终端中输入如下命令：
ls -l /etc/ | grep sudoers,运行结果如下图所示：
可以看到sudoers文件只有读权限，没有写权限，需要给文件增加写权限；
在终端中输入命令如下命令：
sudo chmod u+w /etc/sudoers,回车，输入密码，如下图所示。
此时，该文件已经有了写权限，这时候，我们可以通过vim或vi，直接打开文件，如下图所示：
忘了一点：需要用echo $USER,查看当前用户名：或者用whoami，查看当前用户名是什么
2.在终端中输入如下命令：
sudo vim /etc/sudoers,如下图所示：
在红色方框内添加用户名，如下图所示：
3.终端中输入reboot，即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c41ac7520534fa5909c2cfb8ba5b9d7c/" rel="bookmark">
			微信小程序(uniapp)-实现分享图片给微信好友
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官方地址： 微信开放文档 | wx.showShareImageMenu(Object object) 示例代码： // 结构 &lt;view @click="shareImg" class="yks-sub1"&gt;分享&lt;/view&gt; // 行为 shareImg(){ wx.downloadFile({ url: 'https://res.wx.qq.com/wxdoc/dist/assets/img/demo.ef5c5bef.jpg',//分享的图片的链接 success: (res) =&gt; { wx.showShareImageMenu({ path: res.tempFilePath }) } }) }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4e06d6aacaca736f1a56f3efc76abb2/" rel="bookmark">
			Docker安装 Nacos 单机超详细教程（配合宝塔）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、事前准备 CentOs系统，安装了宝塔面板，安装了docker，云平台防火墙里开放8848端口，官网地址
宝塔-安全放行8848端口
记得使用firewall-cmd --list-port 查看一下linux有没有开放nacos的8848端口，未开启的需要在宝塔里开启或通过命令行开启。
当前我的是开放了8848端口，如果小伙伴没有开放呢，可以使用开启，–permanent表示永久有效，如果不加当前命令，表示重启后就不生效了。宝塔开启也是可以的。
firewall-cmd --zone=public --add-port=8848/tcp --permanent 开放后记得重启防火墙
firewall-cmd --reload 二、安装 1、镜像仓库中拉取最新版本 https://hub.docker.com/r/nacos/nacos-server
docker pull nacos/nacos-server 2、创建日志文件夹 mkdir -p /home/nacos/logs/ 3、创建配置文件夹 mkdir -p /home/nacos/init.d/ 4、nacos数据库导入 宿主机的mysql新建nacos的数据库，并执行脚本 sql脚本地址如下：
https://github.com/alibaba/nacos/blob/master/config/src/main/resources/META-INF/nacos-db.sql
5、运行nacos docker run \ --name nacos -d \ -p 8848:8848 \ -p 9848:9848 \ -p 9849:9849 \ --privileged=true \ --restart=always \ -e JVM_XMS=256m \ -e JVM_XMX=256m \ -e MODE=standalone \ -e PREFER_HOST_MODE=hostname \ -e SPRING_DATASOURCE_PLATFORM=mysql \ -e MYSQL_SERVICE_HOST=172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4e06d6aacaca736f1a56f3efc76abb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764e234ee125c4d3a428194d61e13441/" rel="bookmark">
			Neural Collaborative Filtering 论文阅读和复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Neural Collaborative Filtering 论文阅读和复现 AbstractMethodsExperiments and ResultsData set首先是数据理解 功能快捷键合理的创建标题，有助于目录的生成如何改变文本的样式插入链接与图片如何插入一段漂亮的代码片生成一个适合你的列表创建一个表格设定内容居中、居左、居右SmartyPants 创建一个自定义列表如何创建一个注脚注释也是必不可少的KaTeX数学公式新的甘特图功能，丰富你的文章UML 图表FLowchart流程图导出与导入导出导入 Abstract 首先非常感谢推荐系统论文共读 | Datawhale202212小组，让我有机会和各位小伙伴们一起学习推荐系统的入门知识。在这里主要是想要记录一下阅读Neural Collaborative Filtering论文的笔记和复现算法的过程。
Methods 对于方法部分，我先占时不写了，等后面在来补充吧，由于最近赶着修改论文，实在是没有时间，先把要做的工作记录在这里，希望课程结束之前我能有时间来把论文算法的详细过程补充在这里。
Experiments and Results Data set 用于序列召回的数据是一个已经经过预处理的Movielens-20M的数据集。
首先是数据理解 读入进来的数据是 用户ID 项目ID 时间轴
最后需要将数据处理成 用户ID 项目ID label的形式
数据怎么处理输入embedding 层没太搞明白
明天抽时间继续吧
我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：
全新的界面设计 ，将会带来全新的写作体验；在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；全新的 KaTeX数学公式 语法；增加了支持甘特图的mermaid语法1 功能；增加了 多屏幕编辑 Markdown文章功能；增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z
重做：Ctrl/Command + Y
加粗：Ctrl/Command + B
斜体：Ctrl/Command + I
标题：Ctrl/Command + Shift + H
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/764e234ee125c4d3a428194d61e13441/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c04f96d8aaabcc4430c21b6c3c7994/" rel="bookmark">
			基于STM32与PCA9685制作四足机器人（代码开源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本文为手把手教学基于STM32的四足机器人项目——JDY-31蓝牙控制，特别地，本次项目采用的是STM32作为MCU。四足机器人的支架为3D打印件，SG90舵机驱动机器人实现姿态运动。借助PCA9685舵机驱动板实现12路PWM波控制，更多的舵机可以实现机器人更多运动姿态。本文将以STM32作为核心控制板搭配JDY-31蓝牙模块制作一个远程可控的蓝牙四足机器人，采用三角法去解析机器人的步态运动，实现较高自由度的平稳运动。（文末代码与资料开源！）
实验硬件：STM32F103C8T6；PCA9685舵机驱动板；SG90舵机；JDY-31蓝牙模块；0.96寸OLED；四足机器人3D打印件
硬件实物图：
效果图：
引脚连接：
PCA9685驱动板引脚：
VCC --&gt; 5V
GND --&gt; GND
SCL --&gt; PB6
SDA --&gt; PB7
JDY-31蓝牙模块引脚：
VCC --&gt; 3.3V
GND --&gt; GND
RX--&gt; PA9
TX --&gt; PA10
0.96寸OLED引脚：
VCC --&gt; 3.3V
GND --&gt; GND
SCL --&gt; PB10
SDA --&gt; PB11
一、机器人介绍 1.1 机器人简介 机器人（Robot）是一种能够半自主或全自主工作的智能机器。机器人能够通过编程和自动控制来执行诸如作业或移动等任务。机器人具有感知、决策、执行等基本特征，可以辅助甚至替代人类完成危险、繁重、复杂的工作，提高工作效率与质量，服务人类生活，扩大或延伸人的活动及能力范围。
近些年来，随着深度学习以及芯片计算能力的快速发展，全球出现了各式各样的优秀机器人。例如，波士顿动力（Boston Dynamics）的Atlas与Spot，国内小米公司的铁蛋1号等。这些机器人都或多或少代表了人类目前顶尖的机器人制造技术，当然随着科学技术的进一步发展，相信不久之后科幻电影中的高性能、高智商和高自由度的机器人将出现在世人眼中。
1.2 机器人项目概述 机器人的制作无论在工程应用还是学术研究方面都存在着许多高深知识点，其涉及到运动控制算法，机械结构设计与数据通讯等诸多方面。每一个环节的设计与研发都对最终的机器人成品有着决定性作用，一个优秀的产品肯定是需要精雕细琢的！
当然，本项目的四足机器人借鉴了国外众多优秀开源的四足机器人机械结构，项目主体框架采用PLA材质的3D打印件，具有很高的性价比与机械硬度。12路SG90舵机的设计带给机器人更多的运动姿态，更稳定的步态。项目中四足机器人的控制则采用JDY-31蓝牙模块与手机上位机蓝牙助手APP进行通讯，方便开发简单易上手。总之，本项目设计的四足机器人基础框架具有很高的上限值，感兴趣的读者朋友可以尝试复现后再优化。
二、PCA9685舵机驱动板 PCA9685驱动板是一款基于IIC总线通信的12位精度16通道PWM波输出的芯片，该芯片最初由NXP(恩智浦)推出时主要面向LED开关调光，16路12位PWM信号发生器，可用于控制舵机、LED、电机等设备。利用IIC通信读写关键寄存器内的数据来控制多路PWM信号发送，节省主机引脚资源。灵活使用PCA9685驱动板，就可以真正实现舵机自由(理论上最高可以控制64路舵机)。
PCA9685驱动板厉害之处在于成功通过IIC通讯去解决了MCU的PWM波引脚较少的窘境，通过对PCA9685对应的寄存器写入相关的数据进行配置PCA9685的时钟初始化后，再对现有的16路引脚对应的寄存器写入需要的寄存器数值实现16路PWM的控制输出。详情的资料可以参考恩智浦公司提供的技术文档，如下：
技术文档网址：PCA9685 | NXP Semiconductors
特别注意：PCA9685模块有2个电源引脚，其中绿色接线柱处为16路舵机的电源供应引脚，切忌此处接入的移动电源电压不得超过舵机额定电压。（考虑到多路舵机同时工作，建议使用大电流电源）
三、JDY-31蓝牙模块 JDY-31蓝牙模块基于蓝牙3.0 SPP设计，这样可以支持 Windows、Linux、android数据透传，工作频段 2.4GHZ，调制方式GFSK，最大发射功率8db，最大发射距离30米，支持用户通过AT命令修改设备名、波特率等指令，方便快捷使用灵活。
其通常使用时接入串口引脚（UART）即可，成功与蓝牙模块建立通信后会发送CONNECTED。简单的说，JDY-31蓝牙模块本质上就是一个蓝牙转串口的设备，使用的时候直接当串口通讯进行使用即可。
而上位机作者则选用现成开源的蓝牙调试器APP，直接创建一个针对本项目机器人的控制上位机工程。利用该APP极大的缩短了上位机开发的时间与工作量，也可以快速检验出机器人的运动控制是否满足要求（需要蓝牙调试APP的可以私信作者提供）。
JDY-31蓝牙模块的AT指令集：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c04f96d8aaabcc4430c21b6c3c7994/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/664402a2ae831d38e0e3c0bc96d9488a/" rel="bookmark">
			分享一个DEM数据下载的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 DEM，又称数字高程模型，是常见的一类栅格数据，也是每一个做GIS的GISer机场也会用到的一类数据。本文，跟大家分享一个DEM数据下载的方法。
操作 本文分享的DEM数据源自地理空间数据云 (gscloud.cn)。
点击”DEM数字高程数据”，就可以看到公开出来的DEM的数据，有90m和30m两种分辨率的共8种数据。我们以最后一个”GDEMV3 30M 分辨率数字高程数据”为例，说一下怎么从该网站获取DEM数据。
点击进去，页面如下：
找到对应的经纬度，输入条带号和行编号，104,38,查询出来的数据如下：
此时，我们打开F12，切换到Network面板，回车重新查询，此时会重新发送请求，如下图：
将上图中的dataid复制出来，新开一浏览器面板，在地址栏输入如下地址或在下载软件如迅雷中新建下载任务，地址输入如下地址：
// https://bjdl.gscloud.cn/sources/download/310/dataid?sid=&amp;uid=None https://bjdl.gscloud.cn/sources/download/310/ASTGTM2_N38E104?sid=&amp;uid=None 下载下来的数据用QGIS打开，如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12dfe080dc9bc9f19fc6274d428370dc/" rel="bookmark">
			Windows专用网络链接实现局域网文件共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 被访问的计算机，名称为DESKTOP-A，系统为win10专业版21H2。
访客计算机，名称为DESKTOP-B，系统为win11专业版22H2。
其中A是旧笔记本，其中1T左右的文件需要在B上处理，B是新买的台式。用移动硬盘转移数据不方便，云盘又太慢，而且台式B因为用的无线网卡恰好空出一个LAN，所以尝试折腾了一下网线直连+Windows文件共享的方式。
在这种方式下，A和B组成一个小局域网，和它们各自连不连WiFi无关，所以A没有接入互联网，而是用网线直接和B通信，速度快而且安全性没得说，这里记录一下踩的坑。
前置要求 开启SMB功能 大部分要检查和更改的设置都是在被访问的计算机上。首先，需要确保两台计算机的【控制面板】-【程序】-【程序与功能】-【启用或关闭 Windows 功能】中的 SMB直连 程序已经启用。
A和B：启用SMB
SMB是应用层的传输协议，Windows 用它在局域网内实现端到端通信，默认为明文通信，因此一个友善的提醒就是不要在互联网公网使用SMB，不过据说国内几乎所有地区的运营商都禁用了SMB端口。
网络设置 将以太网识别为专用网络 网线直连后，通常 Windows 在这种场合会把它标识为“未识别的网络”，或者会把它识别为公用网络，基于SMB的网络共享服务会被挡在防火墙外。
现有的很多教程都是在 Windows防火墙的高级设置中关闭相应的防火墙功能，但这是不安全的做法，而且还要记得重新启用防火墙，十分麻烦。
解决方法是把这个以太网设置为专用网络。
以太网的IPv4协议 在以太网属性中，找到IPv4。
A和B：启用IPv4
双击IPv4这一栏，进入IP设置。
IP设置 此处把B当做主机，IP通常为192.168.1.1，具体可以在B的【网络和Internet】-【以太网】中查看。
B：查看IPv4协议的IP地址
然后在A的以太网在设置中，把B的IPv4地址作为网关填入。
A：设置IPv4协议网关
这一步也可以在【网络与共享中心】以太网属性的IPv4协议那一栏设置。
然后在A的Windows设置选项中就可以设置：【网络和Internet】-【以太网】然后点击当前接入的以太网：
A：设置专用网络
专用网络的共享选项 在A的【网络和共享中心】-【高级共享选项】中，对专用网络进行设置：
A：专用网络启用网络发现和文件共享
如果不进行这一步，即使局域网成功连接，也无法在B的计算机【网络】中找到A。
另外，这里的所有网络设置中，推荐使用有密码的共享保护。
A：高级共享设置启用密码保护
至此局域网的设置已经完成。这一步网络设置和下一步共享设置可以交换顺序。
共享设置 在A上完成对文件夹或磁盘的共享设置。Windows下文件夹或磁盘的【属性】中可以找到共享选项和安全选项。
共享选项 按照下图步骤，在最后的搜索结果中找到本机登录的Window用户。此处为hyq。
A：设置文件夹或磁盘的共享选项 - 添加组或用户名
添加完成后，设置权限为完全控制。
A：设置文件夹或磁盘的共享选项 - 设置本地用户的权限为完全控制
然后即共享完成，在计算机B上的【网络】中可以看到计算机A。但是由于我们之前设置了访问需要密码，因此试图访问计算机A时，会提示输入凭据。
Windows凭据 记住你的Windows用户名和密码（注意不是Microsoft用户名和密码，而是仅仅是这个操作系统的密码）。
它在Windows设置的【账户】-【登录选项】- 【密码】中。
A：Windows登录密码作为计算机B的访问凭据
可以在B的【控制面板】-【用户账户】-【管理Windows凭据】中看到所使用的访问凭据，直到下一次注销该凭据会一直保留。
B：管理Windows凭据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42e5690fc67fb4549cfd87c6a1181928/" rel="bookmark">
			记录h5文件数据转为npy和csv格式类型的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做数据分析，需要把h5文件转成npy，然后再转成csv格式，因此记录一下方法。
首先利用Pandas读取.h5数据文件，
import pandas as pd import numpy as np # path处填入.h5文件绝对路径 df = pd.read_hdf(r'path') 然后转换并保存为npy形式的数据，
# 路径部分依旧根据自己需要设置 np.save("F:/data/df.npy", df) 最后，利用Pandas转为csv格式的数据文件，
（注：这里不推荐使用np.savetxt()的方式保存，一是内存大，二是设置繁琐，仅个人观点）
pd.DataFrame(df).to_csv('F:/data/df.csv', header=None, index=None) 大功告成，美滋滋！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eba491ec97e3bc361fda6edad170f9ae/" rel="bookmark">
			报错解决：Loading PDSC Debug Description Failed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在打开由STM32Cubemx生成的工程之后，给我弹出了一个错误，这里上网搜了一下解决办法，填上这个小坑
正篇开始： 当我们下载了STM32G4系列的包之后，Keil ARM会给我们弹出一个错误提示，Loading PDSC Debug Description Failed.......什么的，这个是需要我们在Keil.STM32G4xx_DFP.pdsc文件里做出一些修改的。
首先找到我们的Keil.STM32G4xx_DFP.pdsc文件位置，我的路径是如下图所示，虽然大家的安装路径可能会有所不同，但大多数应该是差别不大的。
双击Keil.STM32G4xx_DFP.pdsc文件，选择用记事本打开
然后在记事本里搜索Message(2, "Not a genuine ST Device! Abort connection.");直接删除
然后保存一下，只不过这里要注意的是，千万不是保存成.txt类型，要保存成.pdsc类型，也就是替换一下文件。到这里还没完，还需要修改Keil.STM32G4xx_DFP.pdsc的属性。
这样就不会再报错了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3762f68ce55a2f2569b6e030647be0e5/" rel="bookmark">
			py语法基础014_集合操作介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# encoding=utf-8 """ 三、集合操作 1、集合(set) 集合是无序、可变、元素不可重复的序列 集合底层实现是字典，只有字典的键对象，不可重复且唯一 （1）集合是盛放多个数据的一种类型，是基础数据类型之一 （2）用于存储一组无序的，唯一的、不重复的，不可修改类型的数据 2、创建 （1）创建空集合：集合名=set() （2）创建非空集合：集合名={元素1，元素2...} | 集合名=set(元素1，元素2...) 3、特点 （1）集合是无序的 （2）集合中的元素是不重复的，唯一的 （3）集合中存储的数据必须是不可变的数据类型 （4）集合是可变的数据类型 4、增加操作 （1）集合名.add(数据)：添加不可变类型数据，若添加可变类型数据会报错 （2）集合名.update(可迭代数据)：将可迭代对象中和集合中不重复的元素添加到集合中 5、删除操作 （1）集合名.pop()：将集合中的元素随机删除，返回删除的值 （2）集合名.remove(元素)：删除指定的元素，元素不存在会报错 （3）集合名.discard(元素)：删除指定的元素，元素不存在会报错 （4）集合名.clear()：将集合清空，剩余空集合 （5）del 集合名：删除整个集合变量 6、应用场景：去重 （1）元素在集合中只能存储一次，可以用来把重复项从其他数据类型中过滤掉，只要把其他类型转换为一个集合(set)，再转换回来即可去重 （2）在处理较大的数据集合的时候，两个集合的交集包含了两个领域中共有的对象，并集包含了两个集合中的所有项目 7、数学计算 （1）集合1.difference(集合2)：获取两个集合的差集 == 集合1-集合2--&gt;第一个集合有，第二个集合没有 （2）集合1.difference_update(集合2)：获取两个集合的差集并将结果更新到前面集合中 == 集合1-=集合2 （3）集合1.symmetric_difference(集合2)：获取两个集合共同的差集/反交集 == 集合1^集合2--&gt;取非公共部分 （4）集合1.symmetric_difference_update(集合2)：获取两个集合共同的差集并更新到前面集合中 == 集合1^=集合2 （5）集合1.isdisjoint(集合2)：判断两个集合是否没有交集 （6）集合1.intersection(集合2)：获取两个集合的交集 == 集合1&amp;集合2--&gt;取公共部分 （7）集合1.intersection_update(集合2)：获取两个集合的交集并将结果更新到前面集合中 == 集合1&amp;集合2 （8）集合1.union(集合2)：获取两个集合的并集 == 集合1|集合2--&gt;取所有部分，不包括重复数据 （9）集合1.update(集合2)：获取两个集合的并集，并将数据更新到前面集合中 == 集合1|=集合2 （10）集合1.issubset(集合2)：子集-判断前面集合中的数据是不是包含在后面集合中 == 集合1&lt;集合2--&gt;判断集合是不是另一集合的子集 （11）集合1.issuperset(集合2)：超集-判断后面集合中的数据是不是包含在前面集合中 == 集合1&gt;集合2 """ set1=set() print("声明空集合：",set1) # 普通集合 set2 = {1,2,3,4,5,6,7,8,9,1,2,3,1,2,3,1,2,3} print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3762f68ce55a2f2569b6e030647be0e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481733c59cfb3b4543b9b15f2dbad573/" rel="bookmark">
			CSS 入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS (Cascading Style Sheets，层叠样式表），是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言，CSS 文件扩展名为 .css。css 一般与 html 结合使用效果更佳。
css 规则由两个主要的部分构成：选择器 + 一条或多条声明。如：
p { color:red; text-align:center; } p 为选择器，由大括号包起来的部分就为声明。
选择器通常是需要改变样式的 HTML 元素。每条声明由一个属性和一个值组成，即 key-value 模式。每个属性对应一个值，属性和值用冒号分开。规范来讲，每行只描述一个属性，同时，属性和值之间不必保留空格。
css 注释以 /* 开始, 以 */ 结束。
在 html 文件中插入 css 样式表的方法有以下三种：
外部样式表(External style sheet)内部样式表(Internal style sheet)内联样式(Inline style) 外部样式表
当某一个样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，我们可以通过改变一个文件来改变整个站点的外观。每个页面使用 &lt;link&gt; 标签链接到样式表。 &lt;link&gt; 标签在（文档的）头部：
&lt;head&gt; &lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt; &lt;/head&gt; 浏览器会从文件 mystyle.css 中读到样式声明，并根据它来格式文档。
外部样式表可以在任何文本编辑器中进行编辑。文件不能包含任何的 html 标签。样式表应该以 .css 扩展名进行保存。
内部样式表
当单个文档需要特殊的样式时，就应该使用内部样式表。我们可以通过使用 &lt;style&gt; 标签在文档头部定义内部样式表，如下所示，为 html 文件中的 &lt;hr&gt;、&lt;p&gt;、&lt;body&gt; 标签设置样式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/481733c59cfb3b4543b9b15f2dbad573/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88d0a8b32899548ee64bcdd0e18fb366/" rel="bookmark">
			VS code连接远程服务器，搭建Ubuntu开发环境加速模型训练方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天为大家带来的内容是关于如何使用VS code（Visual Studio Code）软件连接远程服务器方法。可以说它是一款轻量级的Pycharm，用起来还是蛮方便的，尤其是不用陷入pycharm连接远程服务器时会出现的一些配置bug。在我们平时研究深度学习，期望使用远程云服务器或者工作站服务器进行GPU加速来说，是一个不错的借鉴。
在我们下载好VS code之后，打开界面，左侧菜单栏点击扩展模块然后，安装Remote-SSH和Remote - SSH: Editing Configuration Files (Nightly)插件，会出现远程资源管理器图标，点击然后会出现SSH TARGETS，点击add添加，会出现提示添加你的服务器的IP地址窗口，输入的格式是SSH @用户名 IP地址。这时，复制粘贴好你的服务器用户名和IP，填写上去点击回车就可以啦！这时我们已经添加上了远程服务器的IP，现在我们要打开服务器窗口输入服务器密码，点击下图中的小加号框，选择linux环境，且输入自己的连接密码。就大功告成啦！
安装的相关视频可以参照某位大佬B站链接：https://www.bilibili.com/video/BV1wD4y1o7WV?from=search&amp;seid=12535740929778225364
另外，如果我们想上传文件到服务器中，比如一些数据之类的，可以使用MobaXterm软件进行文件传输，也是非常方便的方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adaa850027e86c4f862bfc0fbedbd145/" rel="bookmark">
			DSMM数据安全能力成熟度模型及配套实施指南笔记（附原文下载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 《GBT 37988-2019 信息安全技术 数据安全能力成熟度模型》和《数据安全能力建设实施指南》原文下载链接在文末
2020年3月1日《GBT 37988-2019 信息安全技术 数据安全能力成熟度模型》正式实施，该标准适用于对企业、组织对数据安全能力进行评估和作为数据安全能力建设的实施依据。为便于学习和理解DSMM标准模型，相关起草单位还同步制定了配套的数据安全能力建设实施指南，以数据安全能力成熟度三级为目标，解读如何实施和落地相应数据安全措施。
本文以下内容是在学习实施指南时的记录笔记，以梳理结构、体现重点为原则，适用于对DSMM和数据安全知识有一定了解的人群。若在此之前没有了解过DSMM，建议先在文章末尾链接处下载原文通读后再学习本文。
笔记 37988数据安全能力成熟度模型 配套指南，以等级三级为目标
1.数据安全能力建设框架 2.数据安全组织建设 1）决策层
高管、数据安全官、其他业务的高管
制定组织的数据安全目标和愿景数据安全的策略和规划、制度与规范进行发布对组织的数据安全建设的提供必要的资源对公司的重大数据安全事件做协调和决策 2）管理层
数据安全管理团队，数据安全工作最核心的部门
制定数据安全整体解决方案并组织实施制定数据安全管理策略和规划，统一数据安全规范体系建立监控审计机制数据安全技术和意识培训做组织架构的运作机制与外部组织机构保持沟通 3）执行层
数据安全专职人员、业务部门的数据安全接口人、数据所有者
数据安全风险的评估和改进数据安全运营工作数据安全事件的跟进和处理做数据分类分级工作数据安全专项管理和实施 4）员工和合作伙伴（第三方）
履行组织对数据安全的要求，部署数据安全工作培训、考试、学习等提升数据安全意识识别安全风险、判断风险并降低风险 5）监督层
具备独立性、组织内部的审计部门
监督数据安全制度落地执行情况监督数据安全工具执行有效性监控与审计数据安全风险 -------------------------------------------------------------------------------
不同部门之间联动
业务新增、业务运营、外部合作、安全事件、安全执行
人力资源
安全遵守要求、人员违规的处置
IT部门
介质安全管理、防护措施部署、管理策略执行
法务部门
政策法规、数据安全合规
风险管理
数据安全管理的协助，风控
公共关系部门
信息发布的敏感信息控制
3.数据安全人员能力 4.数据安全制度流程 5.数据安全技术工具 6.数据安全各阶段实施解读 1）数据采集 数据分类分级
制度流程：说明 分类分级的角色和职责、分类分级原则、实施流程、不同级别数据的保护细则、建立和变更审核流程技术工具： 采集安全管理
制度流程： 数据采集规则：采集目的、采集用途、采集方式、采集范围
采集岗位职责：负责采集相关的工作岗位和职责
数据采集评估：风险评估方法、评估周期、评估对象、整改要求
采集过程保护：保护数据类型、安全措施、审计要求
合规性说明：相关法律法规和监督要求
技术工具：采集工具、采集过程的防泄漏安全技术措施 数据源鉴别及记录
制度流程： 数据采集来源管理
数据溯源管理
技术工具 采集数据的识别和记录：元数据管理、数据血缘
数据源的识别和记录：身份鉴别机制、指纹识别机制
数据质量管理
制度流程：数据质量定义、数据质量校验方法、质量管理实施流程、质量管理规范技术工具：对离线数据采取波动值校验、固定值比较的校验方式 2）数据传输 数据传输加密
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adaa850027e86c4f862bfc0fbedbd145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed29908fc1b2d2818d81d93cdd733a1e/" rel="bookmark">
			附指南原文下载-《GB/T 39725-2020 信息安全技术 健康医疗数据安全指南》解读（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文由指南内容的精简总结和笔者个人理解编写而成，指南原文链接在文末。不同数据使用场景的下的安全保护措施因篇幅问题单独编写一章，链接在文末。 目录
一、背景
二、数据分类分级
1.数据分类
2.数据分级
3.数据开放形式
三、数据安全管理要求和技术要求
1.数据安全建设实施流程
2.数据安全实施指南
1）组织保障体系
2）数据生命周期各阶段安全措施要点
3）应急处置
指南原文：
解读（二）
一、背景 《GB/T 39725-2020 信息安全技术 健康医疗数据安全指南》于2022年12月14日发布，2021年7月1日正式实施。
指南中数据分类、分级、开放安全要求、不同场景下的措施、安全管理等内容做了详细指导说明，但从目前已经实施的案例中可以得出，数据安全的实施基本上都是按照分模块、分体系的方式展开的，因为本文将指南拆解后按照常见实施思路重新整合，说明医疗行业数据安全实施要点。
二、数据分类分级 健康医疗数据：个人健康医疗数据、个人健康医疗数据加工后得到的健康医疗相关电子数据
（包括群体分析结果、疾病防治统计等）。
个人健康医疗数据：个人过去、现在或将来的生理和心理健康状况、医疗服务和医疗费用。
1.数据分类 数据类别类别定义范围个人属性数据单独或与其他信息结合能够识别特定自然人的数据 1)人口统计信息，包括姓名、出生日期、性别、民族、国籍、职业、住址、工作单位、家庭成员信息、联系人信息、收入、婚姻状况等；
2)个人身份信息，包括身份证、工作证、居住证、社保卡、可识别个人的影音图像、健康卡号、住院号、各类检查检验相关单号等；
3)个人通讯信息，包括个人电话号码、邮箱、账号及关联信息等；
4)个人生物识别信息，包括基因、指纹、声纹、掌纹、耳廓、虹膜、面部特征；
5)个人健康监测传感设备ID等
健康状况数据能反映个人健康情况或同个人健康情况有着密切关系的数据主诉、现病史、既往病史、体征、家族史、症状、检验检查数据、遗传咨询数据、可穿戴设备采集的健康相关数据、生活方式、基因测序、转录产物测序、蛋白质分析测定、代谢小分析检测、人体微生物检测医疗应用数据能反映医疗保健、问诊、住院、出院和其他医疗服务情况的数据门（急）诊病例、住院医嘱、检查检验报告、用药信息、病程记录、手术记录、麻醉记录、输血记录、护理记录、入院记录、出院小结、转诊（院）记录、知情告知信息医疗支付数据医疗或保险等服务中所涉及的与费用相关的数据 1)医疗交易信息，包括医保支付信息、交易金额、交易记录等
2)保险信息，包括保险状态、保险金额等
卫生资源数据反映卫生服务人员、卫生计划和卫生体系的能力与特征的数据医院基本数据、医院运营数据等公共卫生数据关系到国家或地区大众健康的公共事业相关数据环境卫生数据、传染病疫情数据、疾病监测数据、疾病预防数据、出生死亡数据等 2.数据分级 1）数据级别定义
根据对个人健康医疗数据主体可能造成的损害和影响，将数据分为5级。
数据级别级别定义示例适用场合1级可完全公开使用的数据 可直接在互联网上面向公众公开的数据
例：剩余床位、剩余可就诊号
公告2级可在较大范围内供访问使用的数据 不能标识个人身份的数据
例：卫生服务信息
管理、研究、教育与统计分析3级可在中等范围内供访问使用的数据 仅限于获得授权项目组范围内使用的数据
例：门诊叫号
服务对象告知4级可在较小范围内反问使用的数据，一旦泄露对数据主体造成较高程度损害 可直接标识个人身份的数据，例如身份证号码
例：患者身份证号码
个性化服务于管理5级仅能在极小范围内严格限制条件供访问使用的数据，一旦泄露会对数据主体造成严重程度的损害 例如特殊病种、隐私性病种
例：艾滋病
特殊疾病诊疗 2）不同级别数据安全措施要点
数据分类分级的结果是协助用户归类数据、判断数据安全管控措施，而并非绝对定义数据安全管控措施。不同级别数据需实施不同的安全保护措施，但安全保护措施的实施同时会因数据使用场景、数据范围、使用对象等情况综合考虑而定。
数据级别安全措施要点1级审计是否可公开2级去标识化处理3级 个人信息遮蔽
数据数量和接收人员范围限制
4级数据数量、数据环境、接收人员严格限制5级 身份鉴别
访问控制
3.数据开放形式 数据分类分级的目的就是要实现在数据流动过程中对不同级别数据实施不同的安全措施，而数据只有在流动中才有其价值。无论数据是在内部流动还是内外部之间流动，都会面临数据开放这一需求，根据开放范围和数据接受对象，有多种数据开放形式和开放要求。通常对公众完全开放数据称为“数据开放”，数据在组织内部之间流动称为“数据共享”，但本指南中并未严格区分，统称为“数据开放”。 1）数据开放共享类型：
完全公开共享：完全可以向大众开放且可以下载的数据。受控公开共享：在共享过程中需要满足脱敏、范围控制、权限要求等条件的数据领地公开共享：仅限于在某个平台或系统上共享的数据，且一般只能在该平台上实现查询和分析，不可将结果下载或导出。 常见数据开放形式和安全措施要点 开放形式说明公开共享类型安全措施要点网站公开统计概要类数据或经匿名处理后的数据，向大众开放，可自行下载分析完全公开共享数据安全委员会审批文件共享Sftp接口设备、移动介质共享受控公开共享 1）共享数据加密
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed29908fc1b2d2818d81d93cdd733a1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8755d493facbbe6d593106365516e566/" rel="bookmark">
			Could not autowire. No beans of ‘RedisConnectionFactory‘ type found.已解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Could not autowire. No beans of 'RedisConnectionFactory' type found. 问题描述： 在创建redisTemplate时，形参列表爆出了如下错误 Could not autowire. No beans of ‘RedisConnectionFactory’ type found.
原因：
在这里是因为我的主启动类还没有写好，所以idea编译器检测不到这是一个springboot项目，所以无法通过形参注入成功。
如果不是这个原因的可以尝试下面这个方法：
先把boot项目的简单架子搭起来（比如只有一个controller的项目），让项目先跑起来，验证前后端是通的，然后再把redisTemplate方法加进去试试，因为可能是一些基础的依赖或配置我们没有注意到，所以导致idea的编译器检测报错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb5061da9b6000d8dc99366fe4f422b5/" rel="bookmark">
			Vue3 el-date-picker是英文使用el-config-provide语言切换器 更改为中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.按需引入
import zhCn from "element-plus/lib/locale/lang/zh-cn"; 2.返回locale
export default { setup(){ let locale = zhCn; return { locale }; }, }, 3.用el-config-provide包裹el-date-picker
&lt;el-config-provider :locale="locale"&gt; &lt;span class="demonstration"&gt;开始时间&lt;/span&gt; &lt;el-date-picker v-model="shedule.shedule.startDateAndTime" type="datetime" placeholder="请选择时间和日期" :default-time="defaultTime" :locale="locale" /&gt; &lt;span class="demonstration"&gt;结束时间&lt;/span&gt; &lt;el-date-picker v-model="shedule.shedule.endDateAndTime" type="datetime" placeholder="请选择时间和日期" :default-time="defaultTime" :locale="locale" /&gt; &lt;/el-config-provider&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fc7820b0b5fb962a1a40a8118bb3e2b/" rel="bookmark">
			ansible-playbook【2】ansible对服务器进行批量优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ansible对服务器进行批量优化 一、准备工作1、服务器准备 二、配置解释1、配置文件如下2、配置文件解释（1）playbook脚本文件如下（2）主机清单列表如下（3）全局环境变量配置文件如下（4）备份脚本如下（5）缓存清理脚本如下（6）磁盘格式化脚本如下（7）优化脚本如下（8）任务集合配置文件如下 三、执行脚本1、测试下执行的主机是否正确2、执行playbook脚本文件 四、结果验证1、验证lvm磁盘挂载情况2、验证备份脚本和缓存脚本是否正常3、验证 /data 目录下常见目录的创建情况4、验证优化情况 一、准备工作 1、服务器准备 IP地址服务器作用系统其他192.168.80.88ansible服务器centos 7.9部署好ansible，配置完免交互192.168.80.10测试服务器1centos 7.9硬盘50G192.168.80.20测试服务器2centos 7.9硬盘50G 二、配置解释 1、配置文件如下 [root@ansible ansible]# tree /etc/ansible/ /etc/ansible/ ├── auto_install.yml	## playbook脚本文件	├── group_vars	│ └── global.yml	## 全局环境变量配置文件 ├── hosts	## 主机清单列表 └── roles	## 角色 └── optimization	## 自定义的角色名称 ├── files │ ├── Backup.sh	## 备份脚本 │ ├── clean_cache.sh	## 缓存清理脚本 │ ├── disk.sh	## 磁盘格式化脚本 │ ├── lvm2.tar	## lvm的rpm包 │ └── server_optimize.sh	## 优化脚本 └── tasks	└── main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fc7820b0b5fb962a1a40a8118bb3e2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19db334c970982685ac868045d56043a/" rel="bookmark">
			Android 开发viewBinding使用及其需要注意的事项（Activity做弹窗Dialog）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先写一下viewbinding的用法，再提一下当activity作为弹窗时，还用viewbinding需要注意的事项：
build.gradle添加：
viewBinding { enabled = true } 如果布局文件是：activity_main.xml
则在Activity中写作：
public class MainActivity extends AppCompatActivity { ActivityMainBinding mainBinding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mainBinding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(mainBinding.getRoot()); } } 需要注意的事项（非常重要）：
如果你要用Activity做全局弹窗（dialog）之类的，千万不要这么写——
ActivityMainBinding mainBinding; protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION); mainBinding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(mainBinding.getRoot()); } 这么写会导致这两句无效——
requestWindowFeature(Window.FEATURE_NO_TITLE); getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION); 正确的写法（如果还是要用viewBinding）——
ActivityMainBinding mainBinding; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION); setContentView(R.layout.activity_main); mainBinding = ActivityMainBinding.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19db334c970982685ac868045d56043a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ae370152109f29a849aa9ecf7f7acfc/" rel="bookmark">
			使用devtools安装monocle3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 源码编译R 环境：
module purge
module load compiler/gcc/7.3.1
源码编译R
./configure --with-pcre1 --prefix=/path/to/install-R
make
make install
vim env-R.sh
export PATH=/path/to/install-R/bin: $PATH
export LD_LIBRARY_PATH=/path/to/install-R/lib: $LD_LIBRARY_PATH
source env-R.sh
2. 安装devtools 在刚刚安装R的环境下
再module load compiler/cmake/3.23.1
（安装devtools下载的包需要高版本的cmake）
启动R，R
install.packages(“devtools”)
会下载下来很多包，然后依次安装这些包，有的包R下载一次不下来，如果是网络中断而出现的报错，重复这个命令。重复多次，有的包R还是下载不下来，复制网址wget到集群上指定 路径安装会比较方便。
例如stringi这个包，R下载不下来，后还报ICUDM的错，就可以install的时候指定包的位置和ICUDM的位置：
install.packages(“/work/home/xiaxx/packages/monocle3/stringi_1.7.8.tar.gz”,repo=NULL,type=“source”,configure.vars=“ICUDT_DIR=/work/home/xiaxx/packages/monocle3”)
3. 安装monocle3需要的依赖 devtools::install_github(‘cole-trapnell-lab/monocle3’)
（115个，好多依赖，好吓人）
静静等待，多次重复，最后还剩4个包没装好
依次查看每个包编不过的原因
（1）units报错解决办法 — 安装udunits-2.2.20 找不到libudunits2.so，百度搜下这个包
wget https://download-ib01.fedoraproject.org/pub/epel/7/SRPMS/Packages/u/udunits2-2.2.20-2.el7.src.rpm
集群的普通用户使用
rpm2cpio xxx.rpm |cpio -idvm后
是一个tar.gz安装包，解压进入目录
./configure --prefix=/work/home/xiaxx/packages/monocle3/udunits-2.2.20
make
make install
安装好后指定环境：
export UDUNITS2_INCLUDE=/work/home/xiaxx/packages/monocle3/udunits-2.2.20/include
export UDUNITS2_LIBS=/work/home/xiaxx/packages/monocle3/udunits-2.2.20/lib
export LD_LIBRARY_PATH=/work/home/xiaxx/packages/monocle3/udunits-2.2.20/lib: $LD_LIBRARY_PATH
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ae370152109f29a849aa9ecf7f7acfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b42913730a01d25a7f8ae3d8ed7915ec/" rel="bookmark">
			【GPU高性能编程 CUDA实战】学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CUDA By Example - an Introduction to General-Purpose GPU Programming 第1章 为什么需要CUDA第2章 入门第3章 CUDA C第4章 CUDA C并行编程第5章 线程协作第6章 常量内存与事件第7章 纹理内存第8章 图形互操作性第9章 原子性第10章 流第11章 多GPU系统上的CUDA C第12章 后记附录 高级原子操作 第1章 为什么需要CUDA 在2000年早期，GPU的主要目标都是通过可编程计算单元为屏幕上的每个像素计算出一个颜色值，这些计算单元也称为像素着色器（Pixel Shader）。
第2章 入门 开发环境：
支持CUDA的图形处理器NVIDIA设备驱动程序CUDA开发工具箱标准C编译器 第3章 CUDA C 了解为**主机（Host）编写的代码与为设备（Device）**编写的代码之间的区别。
如何从主机上运行设备代码
了解如何在支持CUDA的设备上使用设备内存
一个空的函数kernel()，并且带有修饰符_global_。
对这个空函数的调用，并且带有修饰符&lt;&lt;&lt;1,1&gt;&gt;&gt;。
可以像调用C函数那样将参数传递给核函数
当设备执行任何有用的操作时，都需要分配内存，例如将计算值返回给主机。
设备信息，被课程全在NVIDIA 750Ti下测试。
--- General Information for device 0 --- Name: NVIDIA GeForce GTX 750 Ti Compute capability: 5.0 Clock rate: 1084500 Device copy overlap: Enabled Kernel execution timeout : Enabled --- Memory Information for device 0 --- Total global mem: 2097414144 Total constant Mem: 65536 Max mem pitch: 2147483647 Texture Alignment: 512 --- MP Information for device 0 --- Multiprocessor count: 5 Shared mem per mp: 49152 Registers per mp: 65536 Threads in warp: 32 Max threads per block: 1024 Max thread dimensions: (1024, 1024, 64) Max grid dimensions: (2147483647, 65535, 65535) 第4章 CUDA C并行编程 &lt;&lt;&lt;[线程块数量], [每个线程块中线程数量]&gt;&gt;&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b42913730a01d25a7f8ae3d8ed7915ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc58c960c9b38e042c37e8f07b5942ea/" rel="bookmark">
			深度学习之心得——dropout
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作用： 防止过拟合
什么时候过拟合： 网络参数多，训练数据少的时候，容易过拟合。
原理： 前向传播过程中暂时屏蔽一些节点，暂时不更新它的参数，这样就可以训练多个不同的网络，降低过拟合的可能。
Dropout层的位置 Dropout一般放在全连接层防止过拟合，提高模型返回能力，由于卷积层参数较少，很少有放在卷积层后面的情况，卷积层一般使用batch norm。
全连接层中一般放在激活函数层之后。
BatchNorm BatchNorm归一化放在激活层前后好像都有，最初LeNet有一种归一化放在了激活层池化层后面，而现在普遍放在激活层前。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b396cef7f2b6741c181d780df1d78bf3/" rel="bookmark">
			Android 视图绑定实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 视图绑定实践 背景：视图绑定替代findViewById，获得更简洁的代码效果
一、如何引入视图绑定
将 viewBinding 元素添加到其 build.gradle 文件中，如图所示
二、生成视图绑定时如何忽略某个布局文件
当我们引入视图绑定并且不忽略布局文件时，会在app/build/intermediates/javac/debug/classes/com/example/kotlint/databinding，如图所示
如果在生成绑定类时忽略某个布局文件，则可以添加tools:viewBindingIgnore="true"属性
这时候我们会发现，在页面上引用binding已经报错不可用了
三、如何在Activity中引用
四、如何在Fragment中使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eb9525108117da3345285728bedf101/" rel="bookmark">
			vue 使用了组件使用了ref，this.$refs却没有值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在vue中如果我们要像jquery那样实现dom操作，可以给元素使用ref这个属性
但是今天我遇到了一个问题，就是明明标注了ref，console.log(this.$refs)时却没有输出该元素
由上图可以看到，没有输出我标注的 operationButton元素，最后这个问题还是解决了，效果如下图所示：
解决的方案是你可以看一下该元素是否有使用到v-if如果使用到了 就将v-if换成v-show。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6fe0c52bcdfd1295513a07083e50aac/" rel="bookmark">
			内存溢出的几种原因和解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于JVM的内存写过的文章已经有点多了，而且有点烂了，不过说那么多大多数在解决OOM的情况，于此，本文就只阐述这个内容，携带一些分析和理解和部分扩展内容，也就是JVM宕机中的一些问题，OK，下面说下OOM的常见情况：
第一类内存溢出，也是大家认为最多，第一反应认为是的内存溢出，就是堆栈溢出：
那什么样的情况就是堆栈溢出呢？当你看到下面的关键字的时候它就是堆栈溢出了：
java.lang.OutOfMemoryError: …java heap space…
也就是当你看到heap相关的时候就肯定是堆栈溢出了，此时如果代码没有问题的情况下，适当调整-Xmx和-Xms是可以避免的，不过一定是代码没有问题的前提，为什么会溢出呢，要么代码有问题，要么访问量太多并且每个访问的时间太长或者数据太多，导致数据释放不掉，因为垃圾回收器是要找到那些是垃圾才能回收，这里它不会认为这些东西是垃圾，自然不会去回收了；主意这个溢出之前，可能系统会提前先报错关键字为：
java.lang.OutOfMemoryError:GC over head limit exceeded
这种情况是当系统处于高频的GC状态，而且回收的效果依然不佳的情况，就会开始报这个错误，这种情况一般是产生了很多不可以被释放的对象，有可能是引用使用不当导致，或申请大对象导致，但是java heap space的内存溢出有可能提前不会报这个错误，也就是可能内存就直接不够导致，而不是高频GC.
第二类内存溢出，PermGen的溢出，或者PermGen 满了的提示，你会看到这样的关键字：
关键信息为:
java.lang.OutOfMemoryError: PermGen space
原因：系统的代码非常多或引用的第三方包非常多、或代码中使用了大量的常量、或通过intern注入常量、或者通过动态代码加载等方法，导致常量池的膨胀，虽然JDK 1.5以后可以通过设置对永久带进行回收，但是我们希望的是这个地方是不做GC的，它够用就行，所以一般情况下今年少做类似的操作，所以在面对这种情况常用的手段是：增加-XX:PermSize和-XX:MaxPermSize的大小。
第三类内存溢出：在使用ByteBuffer中的allocateDirect()的时候会用到，很多javaNIO的框架中被封装为其他的方法
溢出关键字：
java.lang.OutOfMemoryError: Direct buffer memory
如果你在直接或间接使用了ByteBuffer中的allocateDirect方法的时候，而不做clear的时候就会出现类似的问题，常规的引用程序IO输出存在一个内核态与用户态的转换过程，也就是对应直接内存与非直接内存，如果常规的应用程序你要将一个文件的内容输出到客户端需要通过OS的直接内存转换拷贝到程序的非直接内存（也就是heap中），然后再输出到直接内存由操作系统发送出去，而直接内存就是由OS和应用程序共同管理的，而非直接内存可以直接由应用程序自己控制的内存，jvm垃圾回收不会回收掉直接内存这部分的内存，所以要注意了哦。
如果经常有类似的操作，可以考虑设置参数：-XX:MaxDirectMemorySize
第四类内存溢出错误：
溢出关键字：
java.lang.StackOverflowError
这个参数直接说明一个内容，就是-Xss太小了，我们申请很多局部调用的栈针等内容是存放在用户当前所持有的线程中的，线程在jdk 1.4以前默认是256K，1.5以后是1M，如果报这个错，只能说明-Xss设置得太小，当然有些厂商的JVM不是这个参数，本文仅仅针对Hotspot VM而已；不过在有必要的情况下可以对系统做一些优化，使得-Xss的值是可用的。
第五类内存溢出错误：
溢出关键字：
java.lang.OutOfMemoryError: unable to create new native thread
上面第四种溢出错误，已经说明了线程的内存空间，其实线程基本只占用heap以外的内存区域，也就是这个错误说明除了heap以外的区域，无法为线程分配一块内存区域了，这个要么是内存本身就不够，要么heap的空间设置得太大了，导致了剩余的内存已经不多了，而由于线程本身要占用内存，所以就不够用了，说明了原因，如何去修改，不用我多说，你懂的。
第六类内存溢出：
溢出关键字
java.lang.OutOfMemoryError: request {} byte for {}out of swap
这类错误一般是由于地址空间不够而导致。
六大类常见溢出已经说明JVM中99%的溢出情况，要逃出这些溢出情况非常困难，除非一些很怪异的故障问题会发生，比如由于物理内存的硬件问题，导致了code cache的错误（在由byte code转换为native code的过程中出现，但是概率极低），这种情况内存 会被直接crash掉，类似还有swap的频繁交互在部分系统中会导致系统直接被crash掉，OS地址空间不够的话，系统根本无法启动，呵呵；JNI的滥用也会导致一些本地内存无法释放的问题，所以尽量避开JNI；socket连接数据打开过多的socket也会报类似：IOException: Too many open files等错误信息。
JNI就不用多说了，尽量少用，除非你的代码太牛B了，我无话可说，呵呵，这种内存如果没有在被调用的语言内部将内存释放掉（如C语言），那么在进程结束前这些内存永远释放不掉，解决办法只有一个就是将进程kill掉。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6fe0c52bcdfd1295513a07083e50aac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f665d8c4fdbf7293a3b305057bf1dd34/" rel="bookmark">
			抖音视频拼接怎么做？推荐一款高效实用的软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抖音视频拼接怎么做？可以用手机里已有的软件，如果想要方便又快捷的处理抖音视频拼接的话，可以先用万兴喵影把视频拼接好，再在抖音里使用哦！
其实对于万兴喵影来说，拼接视频只是最基础的操作之一，只要在在官网下载安装并启动万兴喵影，再在媒体库把需要拼接的视频逐个拖到相同的轨道上，拼接完成以后点击“导出”就行了。
万兴喵影作为风靡全球的一款国产剪辑神器，可以给创作者带来无限的创意，据说全球用户已经过亿啦！
智能初剪可以一键剪切无声片段，快速提升剪辑的效率。
分屏可以多屏展示多方位的精彩视角。
节拍检测可以自动检测音频的节奏，让视频轻松踩点。
运动跟踪可以自定义跟踪素材，玩转动态效果。
万兴喵影自研自设的贴纸、花字、特效、转场、滤镜等，配合着强大的NewBlue素材库，让视频剪辑小白也能轻松做成大片。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/181/">«</a>
	<span class="pagination__item pagination__item--current">182/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/183/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>