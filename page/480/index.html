<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cfd13ac4748019c90155b80c88956f7/" rel="bookmark">
			C# Array.sort
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Array.sort 有3种方式：
待排序对象实现了IComparable&lt;T&gt; 接口 class Person :IComparable&lt;Person&gt;{ private String firstname; public String Firstname { get { return firstname; } set { firstname = value; } } private String lastname; public String Lastname { get { return lastname; } set { lastname = value; } } public Person(String f,String l) { this.firstname = f; this.lastname = l; } public int CompareTo(Person other) { int result = this.Firstname.CompareTo(other.Firstname); if (result.Equals(0)) { result = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cfd13ac4748019c90155b80c88956f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247de92b12305d34fb30d6748d418fc5/" rel="bookmark">
			SRAM和SDRAM的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DRAM，动态随机存取存储器，需要不断的刷新，才能保存数据。而且是行列地址复用的，许多都有页模式。 SRAM，静态的随机存取存储器，加电情况下，不需要刷新，数据不会丢失，而且，一般不是行列地址复用的。 SDRAM，同步的DRAM，即数据的读写需要时钟来同步。 DRAM和SDRAM由于实现工艺问题，容量较SRAM大。但是读写速度不如SRAM，但是现在，SDRAM的速度也已经很快了，时钟好像已经有150兆的了。那么就是读写周期小于10ns了。SDRAM虽然工作频率高，但是实际吞吐率要打折扣。以PC133为例，它的时钟周期是7.5ns，当CAS latency=2 时，它需要12个周期完成8个突发读操作，10个周期完成8个突发写操作。不过，如果以交替方式访问Bank，SDRAM可以在每个周期完成一个读写操作（当然除去刷新操作）。其实现在的主流高速存储器是SSRAM（同步SRAM）和SDRAM（同步DRAM）。目前可以方便买到的SSRAM最大容量是8Mb/片，最大工作速度是166MHz；可以方便买到的SDRAM最大容量是128Mb/片，最大工作速度是133MHz。 SRAM是Static Random Access Memory的缩写，中文含义为静态随机访问存储器，它是一种类型的半导体存储器。“静态”是指只要不掉电，存储在SRAM中的数据就不会丢失。这一点与动态RAM（DRAM）不同，DRAM需要进行周期性的刷新操作。然后，我们不应将SRAM与只读存储器（ROM）和Flash Memory相混淆，因为SRAM是一种易失性存储器，它只有在电源保持连续供应的情况下才能够保持数据。“随机访问”是指存储器的内容可以以任何顺序访问，而不管前一次访问的是哪一个位置。 SRAM中的每一位均存储在四个晶体管当中，这四个晶体管组成了两个交叉耦合反向器。这个存储单元具有两个稳定状态，通常表示为0和1。另外还需要两个访问晶体管用于控制读或写操作过程中存储单元的访问。因此，一个存储位通常需要六个MOSFET。对称的电路结构使得SRAM的访问速度要快于DRAM。SRAM比DRAM访问速度快的另外一个原因是SRAM可以一次接收所有的地址位，而DRAM则使用行地址和列地址复用的结构。 SRAM不应该与SDRAM相混淆，SDRAM代表的是同步DRAM（Synchronous DRAM），这与SRAM是完全不同的。SRAM也不应该与PSRAM相混淆，PSRAM是一种伪装成SRAM的DRAM。 从晶体管的类型分，SRAM可以分为双极性与CMOS两种。从功能上分，SRAM可以分为异步SRAM和同步SRAM（SSRAM）。异步SRAM的访问独立于时钟，数据输入和输出都由地址的变化控制。同步SRAM的所有访问都在时钟的上升/下降沿启动。地址、数据输入和其它控制信号均于时钟信号相关。 DRAM：动态随机存取存储器，需要不断的刷新，才能保存数据。而且是行列地址复用的，许多都有页模式。 SRAM：静态的随机存取存储器，加电情况下，不需要刷新，数据不会丢失，而且，一般不是行列地址复用的。 SDRAM：同步的DRAM，即数据的读写需要时钟来同步。主要是存储单元结构不同导致了容量的不同。一个DRAM存储单元大约需要一个晶体管和一个电容（不包括行读出放大器等），而一个SRAM存储单元大约需要六个晶体管。DRAM和SDRAM由于实现工艺问题，容量较SRAM大，但是读写速度不如SRAM。一个是静态的，一个是动态的，静态的是用的双稳态触发器来保存信息，而动态的是用电子，要不时的刷新来保持。 内存（即随机存贮器RAM）可分为静态随机存储器SRAM，和动态随机存储器DRAM两种。我们经常说的“ 内存”是指DRAM。而SRAM大家却接触的很少。 SRAM其实是一种非常重要的存储器，它的用途广泛。SRAM的速度非常快，在快速读取和刷新时能够保 持数据完整性。SRAM内部采用的是双稳态电路的形式来存储数据。所以SRAM的电路结构非常复杂。制造相同容量的SRAM比DRAM的成本高的多。正因为如此，才使其发展受到了限制。因此目前SRAM基本上只用于CPU 内部的一级缓存以及内置的二级缓存。仅有少量的网络服务器以及路由器上能够使用SRAM。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7507919e566ff378ea40fe8edf07a086/" rel="bookmark">
			2n个整数分为两组，使两组和差的绝对值最小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://blog.sina.com.cn/s/blog_6f194ed3010114vt.html
最近建模看到作业这个题，一开始想了很久。在网上发现竟然没有完备的算法。不过最后想到一个可以Lingo实现的线性规划模型。
严格说，这不是一个算法，Lingo是如何实现0-1规划的我并不清楚。有可能也是枚举法，不过对于具体问题至少可以解决。因为是TeX编译的，重新打一遍太麻烦，所以正文用截图。最后提一个不成熟的算法。 问题重述：有2n个整数，试将其平均分为两组（每组n个），使两组元素和的差值最小。 （这里有一点打错了。“从另一个角度看”后的等式要加绝对值号。另外这里要注意需要限定S1较大，之所以如此是因为带绝对值号的min显然是比较难实现的。不过我并不清楚Lingo能不能实现绝对值的min...我接触Lingo才几天。） 这个问题可以扩展到多维变量，并可扩展到分为多组。下面就多元、多组的情况讨论一个想法。 一开始我设想了一个算法，但是感觉问题多多，只能有时间再深入想： 多元统计分析中有一个动态算法：K均值聚类。其基本思想是，假定目标是聚为k类，任意划分为k组，并分别计算其均值。然后任选一个样本点，计算其到所有k类中心的距离。寻找最小距离，若对应的中心不是自身所在组，则将其调至改组，再重新计算各组中心，并重复本步骤；如果其对自身所在组中心的距离为最小，则保持不变，继续寻找下一个点，直到所有的点都不需要调整。 类似这个想法，是否可以反其道行之，每次都将较远的元素与组调在一起。假设存在一个调整，可以使组内均值向量更靠近总体均值向量，则进行该调整，直到不存在调整空间，则停止算法。 这个问题看起来好像没什么实际意义，纯粹是一个数字游戏，其实可以很广泛的加以应用。比如给定你一队人马，每个人能力不同，如何分配才能保证每组实力相近以求得公平？或者一些施工人员，你想要他们产生竞争激励，分组时就不应该偏心而应尽可能保证每组实力接近。该问题就是这些实际问题的抽象。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c403dee3d9796819a12afb06825d469e/" rel="bookmark">
			IOCP原理-----转载至tiwlin（写的非常不错）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IOCP原理 要想彻底征服IOCP，并应用好IOCP这个模型，首先就让我们穿越到遥远的计算机青铜器时 代（以出现PC为标志），那时候普通的PC安装的还是DOS平台，微软公司主要靠这个操作系统在IT界的原始丛林中打拼，在DOS中编写程序，不得不与很 多的硬件直接打交道，而最常操作的硬件无非是键盘、声显卡、硬盘等等，这些设备都有一个特点就是速度慢，当然是相对于PC平台核心CPU的速度而言，尤其 是硬盘这个机械电子设备，其速度对于完全电子化得CPU来说简直是“相对静止”的设备。很多时候CPU可以干完n件（n&gt;1000）事情的时间中， 这些硬件可能还没有完成一件事情，显然让CPU和这些硬件同步工作将是一种严重的浪费，并且也不太可能，此时，聪明的硬件设计师们发明了一种叫做中断的操 作方式，用以匹配这种速度上的严重差异。中断工作的基本原理就是，CPU首先设置一个类似回调函数的入口地址，其次CPU对某个硬件发出一个指令，此时 CPU就去干别的活计了，最后那个慢的象蜗牛一样的硬件执行完那个指令后，就通知CPU，让CPU暂时“中断”手头的工作，去调用那个“回调函数”。至此 一个完整的中断调用就结束了。这个模型曾经解决了显卡与CPU不同步的问题，最重要的是解决了硬盘速度与CPU速度严重不匹配的问题，并因此还派生出了更 有名的DMA（直接内存访问技术，主要是指慢速硬件可以读写原本只能由CPU直接读写的内存）硬盘IO方式。（注意这里说的中断工作方式只是中断工作方式 的一种，并不是全部，详细的中断原理请参阅其它专业文献。）
其实“中断”方式更 像是一种管理模型，比如在一个公司中，如果要老板时时刻刻盯着员工作事情，那么除非是超人，否则无人能够胜任，同时对于老板这个稀缺资源来说也是一种极起 严重的浪费。更多时候老板只是发指令给员工，然后员工去执行，而老板就可以做别的事情，或者干脆去打高尔夫休息，当员工完成了任务就会通过电话、短信、甚 至e-mail等通知老板，此时老板就去完成一个响应过程，比如总结、奖罚、发出新指令等等。由此也看出如果一个公司的“老板占用率”（类似CPU占用 率）太高，那么就说明两种情况：要么是它的员工很高效，单位时间内完成的指令非常多；要么是公司还没有建立有效的“中断”响应模型。如果你的公司是后者， 那么你就可以试着用这个模型改造公司的管理了，由此你可以晋升到管理层，而不用再去管你的服务端程序有没有使用IOCP了，呵呵呵。
如果真的搞明白了这个传说中的“中断”操作方式，那么理解IOCP的基本原理就不费劲了。
结 束了计算机的青铜时代后，让我们穿越到现在这个“计算机蒸汽”时代，（注意不是“计算机IT”时代，因为计算机还没法自己编写程序让自己去解决问题）。在 现代，Windows几乎成了PC平台上的标准系统，而PC平台上的几大件还是没有太大的变化，除了速度越来越快。而因为操作系统的美妙封装，我们也不用 再去直接同硬件打交道了，当然编写驱动程序的除外。
在Windows平台上，我 们不断的调用着WriteFile和ReadFile这些抽象的函数，操作着“文件”这种抽象的信息集合，很多时候调用这些函数时，是以一种“准同步”的 方式操作硬件的，比如要向一个文件中写入1M的信息，只有等到WriteFile函数返回，操作才算结束，这个过程中，我们的程序则类似死机一样，等待硬 盘写入操作的结束（实际是被系统切换出了当前的CPU时间片）。于此同时，调用了WriteFile的线程则无法干别的任何事情。因为整个线程是在以一种 称为过程化的模型中运行，所有的处理流程全部是线性的。对于程序的流畅编写来说，线性化的东西是一个非常好的东西，甚至几乎早期很多标准的算法都是基于程 序是过程化得这一假设而设计的。而对于一些多任务、多线程环境来说，这种线性的工作方式会使系统严重低效，甚至造成严重的浪费，尤其在现代多核CPU已成 为主流的时候，显然让一个CPU内核去等待另一个CPU内核完成某事后再去工作，是非常愚蠢的一种做法。
面 对这种情况，很多程序员的选择是多线程，也就是专门让一个线程去进行读写操作，而别的线程继续工作，以绕开这些看起来像死机一样的函数，但是这个读写线程 本身还是以一种与硬盘同步的方式工作的。然而这并不是解决问题的最终方法。我们可以想象一个繁忙的数据库系统，要不断的读写硬盘上的文件，可能在短短的一 秒钟时间就要调用n多次WriteFile或ReadFile，假设这是一个网站的后台数据库，那么这样的读写操作有时还可能都是较大的数据块，比如网站 的图片就是比较典型的大块型数据，这时显然一个读写线程也是忙不过来的，因为很有可能一个写操作还没有结束，就会又有读写操作请求进入，这时读写线程几乎 变成了无响应的一个线程，可以想象这种情况下，程序可能几乎总在瘫痪状态，所有其它的线程都要等待读写操作线程完活。也许你会想多建n个线程来进行读写操 作，其实这种情况会更糟糕，因为不管你有多少线程，先不说浪费了多少系统资源，而你读写的可能是相同的一块硬盘，只有一条通道，结果依然是一样的，想象硬 盘是独木桥，而有很多人（线程）等着过桥的情形，你就知道这更是一个糟糕的情形。所以说在慢速的IO面前，多线程往往不是“万灵丹”。
面 对这种情形，微软公司为Windows系统专门建立了一种类似“青铜时代”的中断方式的模型来解决这个问题。当然，不能再像那个年代那样直接操作硬件了， 需要的是旧瓶装新酒了。微软是如何做到的呢，实际还是通过“回调函数”来解决这个问题的，大致也就是要我们去实现一个类似回调函数的过程，主要用于处理来 自系统的一些输入输出操作“完成”的通知，相当于一个“中断”，然后就可以在过程中做输入输出完成的一些操作了。比如在IO操作完成后删除缓冲，继续发出 下一个命令，或者关闭文件，设备等。实际上从逻辑的角度来讲，我们依然可以按照线性的方法来分析整个过程，只不过这是需要考虑的是两个不同的函数过程之间 的线性关系，第一个函数是发出IO操作的调用者，而第二个函数则是在完成IO操作之后的被调用者，。而被调用的这个函数在输入输出过程中是不活动的，也不 占用线程资源，它只是个过程（其实就是个函数，内存中的一段代码而已）。调用这些函数则需要一个线程的上下文，实际也就是一个函数调用栈，很多时候，系统 会借用你进程空间中线程来调用这个过程，当然前提条件是事先将可以被利用的线程设置成“可警告”状态，这也是线程可警告状态的全部意义，也就是大多数内核 同步等待函数bAlertable（有些书翻译做可警告的，我认为应该理解为对IO操作是一种“时刻警惕”的状态）参数被传递TRUE值之后的效果。比 如：WaitForSingleObjectEx、SleepEx等等。
当然上 面说的这种方式其实是一种“借用线程”的方式，当进程中没有线程可借，或者可借的线程本身也比较忙碌的时候，会造成严重的线程争用情况，从而造成整体性能 低下，这个方式的局限性也就显现出来了。注意“可警告”状态的线程，并不总是在可以被借用的状态，它们本身往往也需要完成一些工作，而它调用一些能够让它 进入等待状态的函数时，才可以被系统借用，否则还是不能被借用的。当然借用线程时因为系统有效的保护了栈环境和寄存器环境，所以被借用的线程再被还回时线 程环境是不会被破坏的。
鉴于借用的线程的不方便和不专业，我们更希望通过明确的 “创建”一批专门的线程来调用这些回调函数（为了能够更深入的理解，可以将借用的线程想象成出租车，而将专门的线程想象成私家车），因此微软就发明了 IOCP“完成端口”这种线程池模型，注意IOCP本质是一种线程池的模型，当然这个线程池的核心工作就是去调用IO操作完成时的回调函数，这就叫专业！ 这也是IOCP名字的来由，这就比借用线程的方式要更加高效和专业，因为这些线程是专门创建来做此工作的，所以不用担心它们还会去做别的工作，而造成忙碌 或不响应回调函数的情况，另外因为IO操作毕竟是慢速的操作，所以几个线程就已经足可以应付成千上万的输入输出完成操作的请求了（还有一个前提就是你的回 调函数做的工作要足够少），所以这个模型的性能是非常高的。也是现在Windows平台上性能最好的输入输出模型。它首先就被用来处理硬盘操作的输入输 出，同时它也支持邮槽、管道、甚至WinSock的网络输入输出。
至此对于完成端口的本质原理应该有了一个比较好的理解，尤其是掌握了IOCP是线程池模型的这一本质，那么对于之后的IOCP实际应用就不会有太多的疑问了。接下去就让我们从实际编程的角度来了解一下IOCP，也为彻底掌握IOCP编程打下坚实的基础。
要应用IOCP，首先就要我们创建一个叫做IOCP的内核对象，这需要通过CreateIoCompletionPort这个函数来创建，这个函数的原型如下：
HANDLE WINAPI CreateIoCompletionPort(
__in HANDLE FileHandle,
__in HANDLE ExistingCompletionPort,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c403dee3d9796819a12afb06825d469e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da71411c1ca356b7ae85ee43e12d86e5/" rel="bookmark">
			服务器安全狗怎么样?好用吗?【转载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 什么是服务器安全狗 很多人不知道什么是服务器安全狗（ www.safedog.cn ）?服务器安全狗指的是一种服务器安全防护软件，它是由互联网安全实验室研发的，为IDC运营商logo、虚拟主机服务商、企业主机、服务器管理者等用户提供服务器安全防范的实用系统。服务器安全狗的功能非常强大，主要包括服务器系统优化、服务器漏洞补丁修复、服务器程序守护、风险帐号扫描、DDOS防火墙、ARP防火墙、安全策略设置以及邮件实时告警等等。有了服务器安全狗，你就不用害怕你的服务器被黑客攻击了。 服务器安全狗怎么样?好用吗? 公司机房的工作是非常繁琐的。有时候网络受到攻击以后，就有可能导致整个网络瘫痪。笔者在公司会经常处理一些攻击时间。记得那段时间，每天晚上都会忙到半夜才休息。后来慢慢的接触多了，懂得东西也多了，发现了一款安全辅助类的工具服务器安全狗。大家或许都不知道服务器安全狗怎么样?其实安全狗的界面非常简单，而且特别容易上手。自己在几台服务器上安装了安全狗，感觉效果还不错，特别一些客户服务器网站出现问题之后，用安全狗可以扫描网站挂马和隔离。使用服务器安全狗可以让我很快找到挂马文件和黑客的攻击形式。最初的时候也只是使用这个简单的功能，在这段时间以前安全狗使用一直没有什么问题，但在去年暑假的时候吧，我在公司网站发布建议所有用户安装安全狗的公告，同时安全狗更新了一个新版本之后，安装时导致服务器网卡信息会清空，这个情况使我在一段时间内无法安装使用安全狗服务器版，只能使用网站狗扫描网站漏洞和后门挂马，也因为此问题，导致经常必须到机房去给客户处理由于安装服务器狗导致的无法远程连接故障。 后来经过一段时间的测试发现，安装过其他安全类软件之后在安装安全狗就会出现此类情况，此后每次在给客户安装安全狗之前必定卸载和停止其他安全类软件，首先，大多数服务器管理员认为杀毒软件可以保护服务器的安全，实际上我个人认为并非如此，桌面版杀毒软件可以对恶意程序进行查杀，但对加密后的恶意代码却无法识别，这个时候杀毒软件就会变成瞎子，结果就是服务器被入侵利用。 当你给自己的服务器安装服务器安全狗以后，就会发现被攻击和入侵的纪律明显减少了。已经安装安全狗软件的客户对此也非常的认可。虽然在一定程度上来说，服务器的维护是一件非常复杂的工作，但安全狗为广大服务器管理员提供了快速便捷的安全解决方案，希望安全狗能够更好的发展和持续下去。 小编综述 以上内容介绍了什么事服务器安全狗以及服务器安全狗怎样的相关内容。笔者建议广大服务器维护工作者可以了解下服务器安全狗的相关内容。 转自：安徽网新 转载于:https://my.oschina.net/safedog/blog/125522
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95d6e82cd154c9214047a8e0dda2b1f6/" rel="bookmark">
			Flex, version 2.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flex, version 2.5 A fast scanner generator Edition 2.5, March 1995 Vern Paxson Copyright (C) 1990 The Regents of the University of California.All rights reserved.
This code is derived from software contributed to Berkeley byVern Paxson.
The United States Government has rights in this work pursuantto contract no. DE-AC03-76SF00098 between the United StatesDepartment of Energy and the University of California.
Redistribution and use in source and binary forms are permittedprovided that: (1) source distributions retain this entirecopyright notice and comment, and (2) distributions includingbinaries display the following acknowledgement: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95d6e82cd154c9214047a8e0dda2b1f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6053a59d72464472a2bcc5948c625af/" rel="bookmark">
			Deployment Procces by Rowan Simpson
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		This is Part II in a two-part series. Part I covers the Trade Me application architecture.
Tim’s second lot of questions are about our dev tools and process:
Q: Any third party tools in the software or the dev/management process?
Q: What source control software do you use, and how do you use it?
Q: How do you manage roll outs? Dev/Staging/Live?
Q: Do you use pair programming, or adopt any other methodologies from the agile world?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6053a59d72464472a2bcc5948c625af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89dc68df76625a1fa8f35779b62d8301/" rel="bookmark">
			最长单调子序列（DP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：给定某一组无序的数，求其中最长的单调序列的长度（该单调序列不一定是连续的），如在 5 6 1 2 4 7 5 中最长上升增序列是1 2 4 7 或者1 2 4 5。
该题可以用动态规划的方法解决，时间复杂度为O（n^2）：
设A[t]表示序列中的第t个数，F[t]表示从1到t这一段中以t结尾的最长上升子序列的长度。
动态规划方程：F[t] = max{1, F[j] + 1} ，其中( j = 1, 2, ..., t - 1, 且A[j] =&lt; A[t] )。 （注意：这篇文章我们假设是非严格单调上升，如果严格作单调上升则为：A[j] &lt; A[t]，下同）
通过以上公式求得最长上升子序列的长度为max( F(t) )。
printResultSeq函数通过递归的方法来打印出所有的最长子序列。
参考代码：
1 //seq：保存当前已经计算好的序列，(从后往前计算); 2 //len：最长子序列的长度; 3 //tmpresult：当前要求得子序列长度; 4 //end：在F中查找长度为tmpresult的位置，查找范围为[0,end); 5 //A:原始序列; 6 //F :对应正文算法分析中的F; 7 void printResultSeq(int A[],int F[],int end,int tmpresult,int seq[],int len) 8 { 9 for(int i=0;i&lt;end;i++) 10 { 11 if(tmpresult==F[i] &amp;&amp; A[i]&lt;=seq[tmpresult+1]) 12 { 13 seq[tmpresult]=A[i]; 14 if(tmpresult==1) 15 { 16 for(int k=1;k&lt;=len;k++) 17 cout&lt;&lt;seq[k]&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89dc68df76625a1fa8f35779b62d8301/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3082adfd29086388ca13b8d89aee0b2/" rel="bookmark">
			GPS坐标（大地坐标）转高斯平面坐标，并计算 GPS 坐标（大地坐标）两点间的距离...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知道啥时候在网上找到的算法，经实验发现貌似挺精确的，经修改后备用：
#include &lt;cmath&gt; //高斯平面坐标系 struct CRDCARTESIAN { double x; double y; double z; } ; //大地坐标系（可以是 北京54坐标系，西安80坐标系，WGS84坐标系（GPS 坐标）） struct CRDGEODETIC { double longitude; //经度 double latitude; //纬度 double height; //大地高,可设为0 }; #define WGS84 84 //WGS84坐标系（GPS 坐标） #define BJ54 54 //北京54坐标系 #define XIAN80 80 //西安80坐标系 #define ZONEWIDE3 3 //投影带宽度 3 #define ZONEWIDE6 6 //投影带宽度 6 //--------------------------------------------------------------------------- void BLTOXY(CRDCARTESIAN * pcc, CRDGEODETIC * pcg, int Datum, int zonewide) { double B = pcg-&gt;latitude; //纬度 double L = pcg-&gt;longitude; //经度//纬度度数 double L0; //中央经线度数 double N; //卯酉圈曲率半径 double q2; double x; //高斯平面纵坐标 double y; //高斯平面横坐标 double s; //赤道至纬度B的经线弧长 double f; //参考椭球体扁率 double e1; //椭球第一偏心率 double a; //参考椭球体长半轴 //double b; //参考椭球体短半轴 double a1, a2, a3, a4; double b1, b2, b3, b4; double c0, c1, c2, c3; const double IPI = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3082adfd29086388ca13b8d89aee0b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33901d995b26bde3b1a655b68e6e01f2/" rel="bookmark">
			Android应用程序资源的编译和打包过程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道，在一个APK文件中，除了有代码文件之外，还有很多资源文件。这些资源文件是通过Android资源打包工具aapt（Android Asset Package Tool）打包到APK文件里面的。在打包之前，大部分文本格式的XML资源文件还会被编译成二进制格式的XML资源文件。在本文中，我们就详细分析XML资源文件的编译和打包过程，为后面深入了解Android系统的资源管理框架打下坚实的基础。
《Android系统源代码情景分析》一书正在进击的程序员网（http://0xcc0xcd.com）中连载，点击进入！
在前面Android资源管理框架（Asset Manager）简要介绍和学习计划一文中提到，只有那些类型为res/animator、res/anim、res/color、res/drawable（非Bitmap文件，即非.png、.9.png、.jpg、.gif文件）、res/layout、res/menu、res/values和res/xml的资源文件均会从文本格式的XML文件编译成二进制格式的XML文件，如图1所示：
图1 Android应用程序资源的编译和打包过程
这些XML资源文件之所要从文本格式编译成二进制格式，是因为：
1. 二进制格式的XML文件占用空间更小。这是由于所有XML元素的标签、属性名称、属性值和内容所涉及到的字符串都会被统一收集到一个字符串资源池中去，并且会去重。有了这个字符串资源池，原来使用字符串的地方就会被替换成一个索引到字符串资源池的整数值，从而可以减少文件的大小。
2. 二进制格式的XML文件解析速度更快。这是由于二进制格式的XML元素里面不再包含有字符串值，因此就避免了进行字符串解析，从而提高速度。
将XML资源文件从文本格式编译成二进制格式解决了空间占用以及解析效率的问题，但是对于Android资源管理框架来说，这只是完成了其中的一部分工作。Android资源管理框架的另外一个重要任务就是要根据资源ID来快速找到对应的资源。
在前面Android资源管理框架（Asset Manager）简要介绍和学习计划一文中提到，为了使得一个应用程序能够在运行时同时支持不同的大小和密度的屏幕，以及支持国际化，即支持不同的国家地区和语言，Android应用程序资源的组织方式有18个维度，每一个维度都代表一个配置信息，从而可以使得应用程序能够根据设备的当前配置信息来找到最匹配的资源来展现在UI上，从而提高用户体验。
由于Android应用程序资源的组织方式可以达到18个维度，因此就要求Android资源管理框架能够快速定位最匹配设备当前配置信息的资源来展现在UI上，否则的话，就会影响用户体验。为了支持Android资源管理框架快速定位最匹配资源，Android资源打包工具aapt在编译和打包资源的过程中，会执行以下两个额外的操作：
1. 赋予每一个非assets资源一个ID值，这些ID值以常量的形式定义在一个R.java文件中。
2. 生成一个resources.arsc文件，用来描述那些具有ID值的资源的配置信息，它的内容就相当于是一个资源索引表。
有了资源ID以及资源索引表之后，Android资源管理框架就可以迅速将根据设备当前配置信息来定位最匹配的资源了。接下来我们在分析Android应用程序资源的编译和打包过程中，就主要关注XML资源的编译过程、资源ID文件R.java的生成过程以及资源索引表文件resources.arsc的生成过程。
Android资源打包工具在编译应用程序资源之前，会创建一个资源表。这个资源表使用一个ResourceTable对象来描述，当应用程序资源编译完成之后，它就会包含所有资源的信息。有了这个资源表之后， Android资源打包工具就可以根据它的内容来生成资源索引表文件resources.arsc了。
接下来，我们就通过ResourceTable类的实现来先大概了解资源表里面都有些什么东西，如图2所示：
图2 ResourceTable的实现
ResourceTable类用来总体描述一个资源表，它的重要成员变量的含义如下所示：
--mAssetsPackage：表示当前正在编译的资源的包名称。
--mPackages：表示当前正在编译的资源包，每一个包都用一个Package对象来描述。例如，一般我们在编译应用程序资源时，都会引用系统预先编译好的资源包，这样当前正在编译的资源包除了目标应用程序资源包之外，就还有预先编译好的系统资源包。
--mOrderedPackages：和mPackages一样，也是表示当前正在编译的资源包，不过它们是以Package ID从小到大的顺序保存在一个Vector里面的，而mPackages是一个以Package Name为Key的DefaultKeyedVector。
--mAssets：表示当前编译的资源目录，它指向的是一个AaptAssets对象。
Package类用来描述一个包，这个包可以是一个被引用的包，即一个预先编译好的包，也可以是一个正在编译的包，它的重要成员变量的含义如下所示：
--mName：表示包的名称。
--mTypes：表示包含的资源的类型，每一个类型都用一个Type对象来描述。资源的类型就是指animimator、anim、color、drawable、layout、menu和values等。
--mOrderedTypes：和mTypes一样，也是表示包含的资源的类型，不过它们是Type ID从小到大的顺序保存在一个Vector里面的，而mTypes是一个以Type Name为Key的DefaultKeyedVector。
Type类用来描述一个资源类型，它的重要成员变量的含义如下所示：
--mName：表示资源类型名称。
--mConfigs：表示包含的资源配置项列表，每一个配置项列表都包含了一系列同名的资源，使用一个ConfigList来描述。例如，假设有main.xml和sub.xml两个layout类型的资源，那么main.xml和sub.xml都分别对应有一个ConfigList。
--mOrderedConfigs：和mConfigs一样，也是表示包含的资源配置项，不过它们是以Entry ID从小到大的顺序保存在一个Vector里面的，而mConfigs是以Entry Name来Key的DefaultKeyedVector。
--mUniqueConfigs：表示包含的不同资源配置信息的个数。我们可以将mConfigs和mOrderedConfigs看作是按照名称的不同来划分资源项，而将mUniqueConfigs看作是按照配置信息的不同来划分资源项。
ConfigList用来描述一个资源配置项列表，它的重要成员变量的含义如下所示：
--mName：表示资源项名称，也称为Entry Name。
--mEntries：表示包含的资源项，每一个资源项都用一个Entry对象来描述，并且以一个对应的ConfigDescription为Key保存在一个DefaultKeyedVector中。例如，假设有一个名称为icon.png的drawable资源，有三种不同的配置，分别是ldpi、mdpi和hdpi，那么以icon.png为名称的资源就对应有三个项。
Entry类用来描述一个资源项，它的重要成员变量的含义如下所示：
--mName：表示资源名称。
--mItem：表示资源数据，用一个Item对象来描述。
Item类用来描述一个资源项数据，它的重要成员变量的含义如下所示：
--value：表示资源项的原始值，它是一个字符串。
--parsedValue：表示资源项原始值经过解析后得到的结构化的资源值，使用一个Res_Value对象来描述。例如，一个整数类型的资源项的原始值为“12345”，经过解析后，就得到一个大小为12345的整数类型的资源项。
ConfigDescription类是从ResTable_config类继承下来的，用来描述一个资源配置信息。ResTable_config类的成员变量imsi、locale、screenType、input、screenSize、version和screenConfig对应的实际上就是在前面Android资源管理框架（Asset Manager）简要介绍和学习计划一文提到的18个资源维度。
前面提到，当前正在编译的资源目录是使用一个AaptAssets对象来描述的，它的实现如图3所示：
图3 AaptAssets类的实现
AaptAssets类的重要成员变量的含义如下所示：
--mPackage：表示当前正在编译的资源的包名称。
--mRes：表示所包含的资源类型集，每一个资源类型都使用一个ResourceTypeSet来描述，并且以Type Name为Key保存在一个KeyedVector中。
--mHaveIncludedAssets：表示是否有引用包。
--mIncludedAssets：指向的是一个AssetManager，用来解析引用包。引用包都是一些预编译好的资源包，它们需要通过AssetManager来解析。事实上，Android应用程序在运行的过程中，也是通过AssetManager来解析资源的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33901d995b26bde3b1a655b68e6e01f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19064dc4a5c2298796bca42bf25cbcec/" rel="bookmark">
			shell脚本里的\r字符。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在windows上用notepadd++编辑一个shell脚本，死活出错，回到linux下，编辑，还是有这个\r，搜索了下，是这样的：
http://bluemood.blog.51cto.com/1142811/1030925
‘
由于在shell处理了windows里的字符文件，导致本该输出成两行的字符串变成了一行，而第一行行首的一些字符被第二行覆盖了
这是由于windows和linux下的/r ^M 字符的区别导致，可以将异常字符都筛选掉再进行输出：如sed 's/[^0-9,.:A-Za-z]//g'把不符合规则的字符过滤掉
转载了下面的可以参考下：
Unix体系里，每行结尾只有“&lt;换行&gt;”，即“\n”；Windows体系里面，每行结尾是“&lt;换行&gt;&lt;回 车&gt;”，即“\n\r”。一个直接结果是，Unix体系下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix下打开的话，在每行的结尾可能会多出一个^M符号。
好了，所以我的题目就出在被处理惩罚的文件的每行末尾都有^M符号，而这凡是是看不出来的。可以用"cat -A test.file"号令查看。是以当我想在行尾添加字符的时辰，它老是添加在行首且会覆盖掉本来行首的字符。
要把文件转换一下，有两种办法：
1.号令dos2unix test.file
2.去掉"\r" ，用号令sed -i ""s/\r//"" test.file
好了，如许处理惩罚完，就OK啦！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d71578180519e8ac442532f870e6f05b/" rel="bookmark">
			Setup Factory 7.0打包工具(写注册表)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件下载地址：
http://ishare.iask.sina.com.cn/f/5932461.html
http://www.onlinedown.net/soft/35348.htm
教程地址：
http://wenku.baidu.com/view/89895c4e2e3f5727a5e962c4.html
http://wenku.baidu.com/view/88b2423043323968011c9243.html
写注册表：
http://wenku.baidu.com/view/fde44b0a763231126edb1129.html
脚本：
result = Registry.DoesKeyExist(HKEY_LOCAL_MACHINE, "SOFTWARE\\MozillaPlugins"); if (result) then -- 要执行的语句 Registry.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\MozillaPlugins\\yutek"); Registry.SetValue(HKEY_LOCAL_MACHINE, "SOFTWARE\\MozillaPlugins\\yutek", "Description", "testtek", REG_SZ); Registry.SetValue(HKEY_LOCAL_MACHINE, "SOFTWARE\\MozillaPlugins\\yutek", "Path", SessionVar.Get("%AppFolder%").."\\npmachinecode.dll", REG_SZ); Registry.SetValue(HKEY_LOCAL_MACHINE, "SOFTWARE\\MozillaPlugins\\yutek", "ProductName", "testtek", REG_SZ); Registry.SetValue(HKEY_LOCAL_MACHINE, "SOFTWARE\\MozillaPlugins\\yutek", "Vendor", "testtek.inc", REG_SZ); Registry.SetValue(HKEY_LOCAL_MACHINE, "SOFTWARE\\MozillaPlugins\\yutek", "Version", "1.0", REG_SZ); else -- 要执行的 else 语句 Registry.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Wow6432Node\\MozillaPlugins\\yutek"); Registry.SetValue(HKEY_LOCAL_MACHINE, "SOFTWARE\\Wow6432Node\\MozillaPlugins\\yutek", "Description", "testtek", REG_SZ); Registry.SetValue(HKEY_LOCAL_MACHINE, "SOFTWARE\\Wow6432Node\\MozillaPlugins\\yutek", "Path", SessionVar.Get("%AppFolder%").."\\npmachinecode.dll", REG_SZ); Registry.SetValue(HKEY_LOCAL_MACHINE, "SOFTWARE\\Wow6432Node\\MozillaPlugins\\yutek", "ProductName", "testtek", REG_SZ); Registry.SetValue(HKEY_LOCAL_MACHINE, "SOFTWARE\\Wow6432Node\\MozillaPlugins\\yutek", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d71578180519e8ac442532f870e6f05b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f1ba9bc0219265ebd7f7f634b49cdfa/" rel="bookmark">
			自动化运维面临的挑战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么80%的码农都做不了架构师？&gt;&gt;&gt; 我这里所说的挑战，是在达到一定规模的IT公司，或者对计算机较为依赖的各个行业公司都会遇到的，在全球信息化的今天，是很难回避的问题，特此叙述一下，欢迎大家来讨论： 分布在全国（全球）各地的网络节点
网络节点通常和机房等价，一个大公司在北上广，乃至国外各有一个机房再正常不过了。每个机房自身是独立的局域网，对外有一个（或者多个，特别是双线机房）出口交换机，每个机房由本地网管日常维护。 成百上千台服务器，型号多种多样，配置五花八门，操作系统不统一
像谷歌和淘宝这类巨无霸，万台才算起步啊！品牌一般就是这几家：IBM、Dell、华为、浪潮等，型号不同，各种硬件可就多了去了，DIY组装的服务器也有不少，操作系统可以粗分为windows和linux2大类，微软的还好，而linux的发行版碎片化严重（想到了安卓也有这个问题）。
半手工化的软件安装方式
服务器出厂时，多半只有一个操作系统，其他公司要用的软件要靠网管人肉安装，一台机器装个把小时，如果来上一批机器，网管都想跳楼，效率可想而知。
稍微好一点的做法是远程控制，弄个安装脚本让机器自己下载、自己安装——这很考验网管的脚本编写水平，用于不同业务的机器装的软件当然各不相同，脚本得跟着换模块和参数（顺带提一句，网管为此累积的不少脚本很好使哈）。不管怎么说，和第一种相比，网管总算可以轻松不少，至少可以一边喝着咖啡，一边上网，一边监控着一批机器的安装进度。
服务器实时状态的监控和预警
为了实现负载监控，业内通常的做法是安装开源的监控软件，如mrtg、Nagios等经典工具，不得不佩服国外的大牛们。遗憾的是这些开源软件适用性和扩容性需要公司针对自己的业务，二次开发，这方面请咨询业内高手，非我擅长。 远程控制
只远控一台机器，用ssh就足够用了。现在问题来了，如果有一批机器需要修改某个相同的配置文件，怎么办？一台台ssh？网管晕倒在地 以上是我的一点看法，此外还有和财务资产系统对接等问题，就不提了。关于我的解决方案稍后再写 ^_^ 转载于:https://my.oschina.net/yygh/blog/121489
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bcc83b0c93a0d02a7337844ea6a59ea/" rel="bookmark">
			nginx echo 输出 检查配置正确性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上篇文章中，我们有用到变量去控制该域名是否允许访问，在配置过程中，其实变量的值一直是我们想象的，无法确认具体步骤的变量值，因此我希望能在每个步骤中将变量的值打印出来，这是nginx 的echo模块粉墨登场。1.nginx 的echo模块的介绍 echo模块式国人编写的nginx的第三方模块，下载官方nginx后需要再下载echo模块，并且配合nginx编译安装，安装此模块后可以在nginx的url访问中可以通过echo命令输出字符到用户的浏览器中，可用于检测nginx的可访问性，检测nginx的配置的正确性（这是当前我需要用的nginx的主要功能），可用于打印你希望了解的http代理相关http参数，总之在调试配置nginx环节，echo命令非常有用。详情见：http://www.oschina.net/question/12_457352.nginx的echo安装 安装第三方模块的时候不能使用rpm以及yum方式安装nginx，如果以前用以上方式安装过nginx的话，请先卸载掉。 2.1 我们下载nginx的源码包（http://nginx.org/download/nginx-1.2.7.tar.gz）以及echo模块的源码包（https://github.com/agentzh/echo-nginx-module/tags）选择最新版本 2.2 分别加压nginx源码包以及echo模块源码包，例如此处我解压的路径为：nginx的路径：/opt/nginx-source ;echo模块的路径:/opt/nginx-echo-source 2.3 命令cd进入nginx源码路径，此处:cd /opt/nginx-source ; 2.4 配置nginx编译文件，执行编译配置命令：./configure --prefix=/opt/nginx --add-module=/opt/nginx-echo-source配置时屏幕会输出日志，检查配置过程中是否有error，如果有请自行修复，一般是缺少类库，缺少啥类库，先安装，如果安装后还是报找不到路径就下载类库的源码包并配置源码包的跟路径，记住，配置过程需要的是源码包的跟路径 2.5 编译nginx，在nginx源码目录中执行命令： make 2.6 编译安装nginx，在nginx 源码目录中执行命令：make install 3.nginx的echo使用测试 配置nginx的配置文件
server { listen 8083; server_name _; access_log /var/log/nginx/cn-camm.server.access.log main; set $tag "0"; if ( $host !~ ^appbuilder.vicp.cc$ ){ set $tag "$tag,1"; } if ( $host !~ ^localhost$ ){ set $tag "$tag,2"; } if ( $tag ~ ^0,1,2$ ){ return 403; } location / { echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bcc83b0c93a0d02a7337844ea6a59ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d6e24d494af575a598fb5167766ee1/" rel="bookmark">
			安装程序无法定位现有系统分区,也无法创建新的系统分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一般出现在使用U盘安装win7的时候，具体原因是安装时加载到安装程序中的u盘变成了主引导盘而引起的。
解决办法：在出现那个错误提示之前的各个界面挨个拔一次U盘试试，提示没有正确的安装光盘再把U盘插上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd5e1751aa284f7ca9b4a3f051e33e86/" rel="bookmark">
			C&#43;&#43; 去除字符串中的重复字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个字符串，要求去除其中的重复字符。例如 abcbs ，操作后得到 abcs 。
方法一：不考虑时间和空间，最简单直接的方法是 另外开辟一个 string 数组，用于保存unique字符。
主函数中的 isUnique(mystr) 见我的上一篇博文。 string duplicate(string str){if(str.size()&lt;2)return str;string tmp_str("\0");tmp_str+=str[0];string::size_type j;for(string::size_type i=1 ; i&lt;str.size() ; i++){for(j=0 ; j&lt;tmp_str.size() ; j++){if(tmp_str[j]==str[i])break;}if(j==tmp_str.size())tmp_str+=str[i];}return tmp_str;}int _tmain(int argc, _TCHAR* argv[]){string mystr;string dest;while(cin&gt;&gt;mystr){if(isUnique(mystr))cout&lt;&lt;mystr&lt;&lt;" is Unique!"&lt;&lt;endl;else{cout&lt;&lt;mystr&lt;&lt;" is not Unique!"&lt;&lt;endl;dest = duplicate(mystr);cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd5e1751aa284f7ca9b4a3f051e33e86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/075b7d3bd3bbe7767f7ef62f430bc22b/" rel="bookmark">
			rman
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RMAN是 ORACLE提供的一个备份与恢复的工具，可以用来备份和还原数据库文件、 归档日志和控制文件。它也可以用来执行完全或不完全的数据库恢复。 RMAN可以由命令行接口或者 OEM的 Backup Manager GUI 来控制。 4.1 基本知识 4.1.1 RMAN的组件、概念 1． RMAN 主要包括以下组件： Target Database: (目标数据库) 就是需要 RMAN 对其进行备份与恢复的数据库，RMAN 可以备份数据文件，控制文 件，归档日志，spfile。(注意：RMAN不能用于备份联机日志、初始化参数文件和口令文件) Server Session: (服务器会话) RMAN启动数据库上的 Oracle服务器进程，将建立一个与目标数据库的会话。由目标 数据库上的服务器进程进行备份、还原、恢复的实际操作。 服务器进程 RMAN 的服务进程是一个后台进程，用于与 RMAN工具与数据库之间的通信，也用于 RMAN 工具与磁盘/磁带等 I/O 设置之间的通信，服务进程负责备份与恢复的所有工作， 在如下情况将产生一个服务进程： 当连接到目标数据库 分配一个新的通道 Channel: (通道) 一个通道是 RMAN和目标数据库之间的一个连接，"allocate channel"命令在目标数据库 启动一个服务器进程，同时必须定义服务器进程执行备份或者恢复操作使用的 I/O类型。 通道控制命令可以用来： ? 控制 RMAN使用的 O/S资源，影响并行度 ? 指定 I/O带宽的限制值（设置 limit read rate 参数） ? 定义备份片大小的限制（设置 limit kbytes） ? 指定当前打开文件的限制值（设置 limit maxopenfiles） recovery catalog: (恢复目录) 用来保存备份与恢复信息的一个数据库，不建议创建在目标数据库上。RMAN 利用恢 复目录记载的信息去判断如何执行需要的备份恢复操作。 如果不采用恢复目录，备份信息可以存在于目标数据库的 control file 中。 如果存放在目标数据库的 control file 中，控件文件会不断增长，不能保存 RMAN 的 Script。 CONTROL_FILE_RECORD_KEEP_TIME (default=7)：控件文件中 RMAN 信息保存的 最短时间。 使用恢复目录的优势： 可以存储脚本，记载较长时间的备份恢复操作。 RMAN Repository: (RMAN 恢复目录数据库) 存放 recovery catalog(恢复目录)的数据库。建议为恢复目录数据库创建一个单独的数据 库。 MML: (媒体管理库) Media Management Layer (MML)是第三方工具或软件，用于管理对磁带的读写与文件的 跟踪管理。如果你想直接通过 RMAN 备份到磁带上，就必须配置媒体管理层，媒体管理层 的工具如备份软件可以调用 RMAN来进行备份与恢复。 2．概念述语 Backup Sets (备份集合) 备份集合的特性：包括一个或多个数据文件或归档日志，以 oracle专有的格式保存，有 一个完全的所有的备份片集合构成，构成一个完全备份或增量备份。 Backup Pieces (备份片) 一个备份集由若干个备份片组成。每个备份片是一个单独的输出文件。一个备份片的大 小是有限制的；如果没有大小的限制， 备份集就只由一个备份片构成。备份片的大小不能 大于使用的文件系统所支持的文件长度的最大值。 Image Copies 镜像备份 镜像备份是独立文件（数据文件、归档日志、控制文件）的备份。它很类似操作系统级 的文件备份。它不是备份集或备份片，也没有被压缩。 Full backup Sets 全备份集合 全备份是一个或多个数据文件中使用过的数据块的的备份。没有使用过的数据块是不被 备份的，也就是说，oracle 进行备份集合的压缩。 Incremental backup sets 增量备份集合 增量备份是指备份一个或多个数据文件的自从上一次同一级别的或更低级别的备份以 来被修改过的数据块。 与完全备份相同，增量备份也进行压缩。 File multiplexing 多个数据文件可以在一个备份集中。 Recovery catalog resyncing 恢复目录同步 使用恢复管理器执行 backup、copy、restore 或者 switch 命令时，恢复目录自动进行更 新，但是有关日志与归档日志信息没有自动记入恢复目录。需要进行目录同步。使用 resync catalog命令进行同步。 RMAN&gt; resync catalog; Incarnation 对应物 在不完全恢复完成之后，通常需要使用 resetlogs 选项来打开数据库。resetlogs 表示一个 数据库逻辑生存期的结束和另一个数据库逻辑生存期的开始。数据库的逻辑生存期也被称为 一个对应物(incarnation)。每次使用 resetlogs 选项来打开数据库后都会创建一个新的数据库 对应物。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/075b7d3bd3bbe7767f7ef62f430bc22b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b0f56f453a27a58b7eda497bde9b42b/" rel="bookmark">
			Android资源管理框架（Asset Manager）简要介绍和学习计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android应用程序主要由两部分内容组成：代码和资源。资源主要就是指那些与UI相关的东西，例如UI布局、字符串和图片等。代码和资源分开可以使得应用程序在运行时根据实际需要来组织UI。这样就可使得应用程序只需要编译一次，就可以支持不同的UI布局。这种特性使得应用程序在运行时可以适应不同的屏幕大小和密度，以及不同的国家和语言等。在本文中，我们就简要介绍Android的资源管理框架，以及制定学习计划。
《Android系统源代码情景分析》一书正在进击的程序员网（http://0xcc0xcd.com）中连载，点击进入！
在软件开发中，说到代码与资源分离，最容易想到的可能就是Web开发了。在Web开发中，我们一般会通过CSS文件来描述HTML页面的展现形式，也就是通过CSS来控制HTML页面的UI。这样就可以很方便地进行Web开发和维护。例如，当我们要更改HTML页面的UI时，只要修改相应的CSS文件就可以了。注意，这些CSS文件都是在运行时加载的。这样我们就可以根据HTML页面的运行环境来加载不同的CSS文件，例如，根据不同的地区或者语言来选择不同的CSS文件，从而实现国际化。
再来看PC客户端软件的开发。开始的时候，微软的MFC应用程序框架非常流行。在开发MFC程序的时候，代码和资源同样也是分开的，例如，程序的界面一般都是通过一个RC文件来描述的。不过我们一般都是在Visual Studio里面通过可视化界面来编辑RC文件的，即一般都不会直接手动去操作RC文件，所以我们一般都不怎么意识到其实RC文件和CSS文件一样，都是用来描述程序的界面的。实际上，RC文件和CSS文件一样，都是可以看作是一个界面配置文件，而且它们的配置信息都是通过文字来描述的，只不过这些文字描述要遵循一定的规范。
随着PC客户端软件的发展，微软的MFC应用程序框架显得有些力不从心了，其中的一个原因就是它的界面比较丑陋。如果要对MFC应用程序的UI进行美化以及个性化的话，是要费比较大的劲的，这严重地影响了软件开发效率，特别是不适合要进行快速迭代开发的互联网客户端软件。微软后来又开发了另外一套应用程序开发框架WPF。WPF同样是使用一种称为XAML的文件来描述应用程序的界面的。实际上，包括现在Win 8的Metro界面，也同样是通过XAML文件来描述应用程序界面的。XAML文件是一种XML文件，它具有更好的可读性，非常方便编辑以及维护。
在PC客户端软件的发展过程中，还有一种不得不提的应用程序框架——QT。QT最初由Trolltech公司开发，后来被Nokia收购。随着Meego的没落，如日冲天的Nokia也没落了，Qt又被卖给了芬兰的另外一家IT服务公司Digia。QT也算得是一套优秀的应用程序框架，而且它是跨平台的。QT同样也是通过一种称为QML的文件来描述应用程序的界面的，不过QML文件不是XML格式的，它的格式有点类似Web页面的CSS。
类似这种采用XML文件来描述界面的PC客户端软件开发框架其实还有很多，例如，迅雷用的Bolt界面引擎，以及腾讯QQ用的GF界面引擎，它们都同样是通过XML文件来描述程序界面的，并且做成代码和界面描述文件分离。
最后看iOS应用程序的开发，它的界面和代码同样是分开，并且通过一种称为XIB的文件来描述界面。XIB文件实际上也是一个XML文件，因此，它也是非常方便编辑以及维护的。
从上面的分析就可以看出，无论是Web应用程序，还是PC客户端应用程序，以及移动客户端应用程序，它们都无一例外地将代码与界面分离，并且界面都是通过描述性的文字来描述的，这种描述性的文字越来越倾向于使用XML格式。
Android应用程序作为一种移动客户端应用程序，它同样也是毫无意外地将代码逻辑和界面资源进行分离，但是它的资源管理方式与传统的Web应用程序和PC客户端应用程序以及iOS应用程序相比会更复杂一些，这是因为Android应用程序可能会运行在各种大小和密度不等的设备之上。接下来我们就将注意力集中在Android应用程序资源的组织和管理之上。
我们首先看Android应用程序资源的分类。Android应用程序资源可以分为两大类，分别是assets和res：
1. assets。assets类资源放在工程根目录的assets子目录下，它里面保存的是一些原始的文件，可以以任何方式来进行组织。这些文件最终会被原装不动地打包在apk文件中。如果我们要在程序中访问这些文件，那么就需要指定文件名来访问。例如，假设在assets目录下有一个名称为filename的文件，那么就可以使用以下代码来访问它：
AssetManager am= getAssets(); InputStream is = assset.open("filename"); 2. res。res类资源放在工程根目录的res子目录下，它里面保存的文件大多数都会被编译，并且都会被赋予资源ID。这样我们就可以在程序中通过ID来访问res类的资源。res类资源按照不同的用途可以进一步划分为以下9种子类型： --animator。这类资源以XML文件保存在res/animator目录下，用来描述属性动画。属性动画通过改变对象的属性来实现动画效果，例如，通过不断地修改对象的坐标值来实现对象移动动画，又如，通过不断地修改对象的Alpha通道值来实现对象的渐变效果。
--anim。这类资源以XML文件保存在res/anim目录下，用来描述补间动画。补间动画和属性动画不同，它不是通过修改对象的属性来实现，而是在对象的原来形状或者位置的基础上实现一个变换来得到的，例如，对对象施加一个旋转变换，就可以获得一个旋转动画，又如，对对象实施一个缩放变换，就可以获得一个缩放动画。从数学上来讲，就是在对象的原来形状或者位置的基础上施加一个变换矩阵来实现动画效果。注意，在动画的执行过程中，对象的属性是始终保持不变的，我们看到的只不过是它的一个变形副本。
--color。这类资源以XML文件保存在res/color目录下，用描述对象颜色状态选择子。例如，我们可以定义一个选择子，规定一个对象在不同状态下显示不同的颜色。对象的状态可以划分为pressed、focused、selected、checkable、checked、enabled和window_focused等7种。
--drawable。这类资源以XML或者Bitmap文件保存在res/drawable目录下，用来描述可绘制对象。例如，我们可以在里面放置一些图片（.png, .9.png, .jpg, .gif），来作为程序界面视图的背景图。注意，保存在这个目录中的Bitmap文件在打包的过程中，可能会被优化的。例如，一个不需要多于256色的真彩色PNG文件可能会被转换成一个只有8位调色板的PNG面板，这样就可以无损地压缩图片，以减少图片所占用的内存资源。
--layout。这类资源以XML文件保存在res/layout目录下，用来描述应用程序界面布局。
--menu。这类资源以XML文件保存在res/menu目录下，用来描述应用程序菜单，例如，Options Menu、Context Menu和Sub Menu。
--raw。这类资源以任意格式的文件保存在res/raw目录下，它们和assets类资源一样，都是原装不动地打包在apk文件中的，不过它们会被赋予资源ID，这样我们就可以在程序中通过ID来访问它们。例如，假设在res/raw目录下有一个名称为filename的文件，并且它在编译的过程，被赋予的资源ID为R.raw.filename，那么就可以使用以下代码来访问它：
Resources res = getResources(); InputStream is = res .openRawResource(R.raw.filename); --values。这类资源以XML文件保存在res/values目录下，用来描述一些简单值，例如，数组、颜色、尺寸、字符串和样式值等，一般来说，这六种不同的值分别保存在名称为arrays.xml、colors.xml、dimens.xml、strings.xml和styles.xml文件中。 --xml。这类资源以XML文件保存在res/xml目录下，一般就是用来描述应用程序的配置信息。
注意，上述9种类型的资源文件，除了raw类型资源，以及Bitmap文件的drawable类型资源之外，其它的资源文件均为文本格式的XML文件，它们在打包的过程中，会被编译成二进制格式的XML文件。这些二进制格式的XML文件分别有一个字符串资源池，用来保存文件中引用到的每一个字符串，包括XML元素标签、属性名称、属性值，以及其它的一切文本值所使用到的字符串。这样原来在文本格式的XML文件中的每一个放置字符串的地方在二进制格式的XML文件中都被替换成一个索引到字符串资源池的整数值。这样做有两个好处：
A. 文件占用更小。例如，假设在原来的文本格式的XML文件中，有四个地方使用的都是同一个字符串，那么在最终编译出来的二进制格式的XML文件中，字符串资源池只有一份字符串值，而引用它的四个地方只占用一个整数值。
B. 解析速度更快。由于在二进制格式的XML文件中，所有的XML元素标签和属性等值都是使用整数来描述的，因此，在解析的过程中，就不再需要进行字符串解析，这样就可以提高解析速度。
还有另外一个地方需要注意的是，每一个res资源在编译的打包完成之后，都会被分配一个资源ID，这些资源ID被终会被定义为Java常量值，保存在一个R.java文件中，与应用程序的其它源文件一起被编译到程序中，这样我们就可以在程序或者资源文件中通过这些ID常量来访问指定的资源。
我们接下来再看应用程序资源的组织。应用程序资源的组织方式有18个维度，如图1所示：
图1 应用程序资源的组织方式
注意，图1的表格是来自于官方文档的，它的详细描述可以参考：http://developer.android.com/guide/topics/resources/providing-resources.html#AlternativeResources。这里有一点需要说明的是，表格中的18个维度是按照优先级从最大到小排列的，这个优先级次序可以帮助系统根据机器的本地配置来在应用程序资源目录中找到最合适的资源来使用。
具体来说，Android资源管理框架按照图2所示的算法流程来在应用程序资源目录中选择最合适的资源：
图2 应用程序资源的匹配算法
注意，图2的算法流程图是来自于官方文档的，它的详细描述可以参考：http://developer.android.com/guide/topics/resources/providing-resources.html#BestMatch。我们同样是通过上述官方文档中的例子来说明上述应用程序资源匹配算法的执行过程。
假设一个应用程序的drawable资源按照以下方式来组织：
drawable/ drawable-en/ drawable-fr-rCA/ drawable-en-port/ drawable-en-notouch-12key/ drawable-port-ldpi/ drawable-port-notouch-12key/ 并且该应用程序所运行在的设置的配置情况如下所示： Locale = en-GB Screen orientation = port Screen pixel density = hdpi Touchscreen type = notouch Primary text input method = 12key 根据图2所示的算法，Android资源管理框架按照以下步骤来选择一个drawable资源： Step 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b0f56f453a27a58b7eda497bde9b42b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ed5f705478abf8a78dab0e5a7d63c18/" rel="bookmark">
			Compression algorithm (deflate)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Compression algorithm (deflate) http://www.gzip.org/algorithm.txt
1. Compression algorithm (deflate) The deflation algorithm used by gzip (also zip and zlib) is a variation of LZ77 (Lempel-Ziv 1977, see reference below). It finds duplicated strings in the input data. The second occurrence of a string is replaced by a pointer to the previous string, in the form of a pair (distance, length). Distances are limited to 32K bytes, and lengths are limited to 258 bytes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ed5f705478abf8a78dab0e5a7d63c18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8c847297ae504517299124b8517c2d7/" rel="bookmark">
			和菜鸟一起学linux之bluez学习记录1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于蓝牙协议栈体系结构
底层硬件模块
RF
1、利用2400M～2483.5M频带
2、采用调频方式传输数据，一共有79/EDR,40/BLE个hops,每秒
3、采用GFSK（DQPSK和8DPSK)调制方式
4、信道间隔（1MHZ/EDR模式,2MHZ/BLE模式）
BB
蓝牙系统提供点对点或点对多点的连接，在连接中设备共享物理信道，称为piconet。一个设备做为master，其他的设备作为slave。pico网中最多可支持7个活动的slave。其他的处于非活动状态。这些非活动slave仍需要保持与master的同步，通道的访问由master来控制。
对所有调制方式，符号率均为1Ms/s。这样BR是1Mbps，EDR DQPSK是2Mbps，EDR 8DPSK是3Mbps。
包格式
蓝牙地址
1、物理通道
2、蓝牙物理通道由伪随机频率hopping序列，特定的时间slot，访问码和包头编码构成。
3、两个设备为了通信，需要使用共享信道，这样就需要两者必须在同一时刻使用相同的频 率。
4、hopping序列有蓝牙设备地址中UAP和LAP决定，timeslot长度取决于物理通道，在连接状态下最大的hop率为1600hops/s，inquiry和page状态下为3200hops/s。
四种物理通道
1、基本pico网通道 2、自适应pico网通道 3、Page scan物理通道 4、inquiryscan物理通道
物理连接
包括电源控制，link监控，加密和链路管理协议，通道数据率变化，多slot包控制。
五种逻辑传输
1、SCO 基于同步连接逻辑传输 2、ESCO扩展SCO 3、ACL 异步逻辑传输
4、ASB 活动Slave广播 5、PSB Parked Slave广播
LMP
1、链路管理协议
2、用于链路的建立和控制，信号在链路管理层被解析和过滤，不会传递至上层。
3、协议由一系列的消息构成，这些消息通过ACL-C逻辑传输。
传输示意图
包格式
主要功能
1）连接控制：连接建立，断开，电源控制，自适应频率hopping，通道分类， 链路监控，通道质量驱动数据率变化，Qos，Paging参数，多slot包控制，EDR，LMP PDU封装。
2）安全：认证，配对，改变link key，改变当前link key类型，加密，请求加密keysize，简单安全配对。
3）信息请求
4）功能切换
5）操作模式
6）逻辑传输
7）测试模式
HCI
为控制器定义了统一的命令接口
1）流控制
2）HCI数据格式
3）HCI配置参数
4）HCI命令和事件
HCI流控制
Host到控制器数据流控制
基于包的数据流控制
基于块的数据流控制
控制器到Host数据流控制
命令流控制
断开行为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8c847297ae504517299124b8517c2d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a4b7a9cc6bb488f8fe7c8a57da48222/" rel="bookmark">
			eclipse经常未响应解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象：启动eclipse缓慢，启动完成经常出现未响应情况。偶然在打开一个项目时候，也出现未响应。
原因：虚拟内存不足，或者电脑本身内存不足。但是目前绝大多数PC而言，内存应该是充足的，因此可以修改虚拟内存参数来解决。
解决办法：
在eclipse安装目录下，将eclipse.ini文件最后几行与下面最后几行黑体字进行替换。
-startup
plugins/org.eclipse.equinox.launcher_1.1.0.v20100507.jar
--launcher.library
plugins/org.eclipse.equinox.launcher.win32.win32.x86_1.1.0.v20100503
-product
org.eclipse.epp.package.jee.product
--launcher.defaultAction
openFile
--launcher.XXMaxPermSize
256M
-showsplash
org.eclipse.platform
--launcher.XXMaxPermSize
256m
--launcher.defaultAction
openFile
-vmargs
-Dosgi.requiredJavaVersion=1.5
-Xms256m
-Xmx512m
-XX:PermSize=128M
-XX:MaxPermSize=128M
-XX:+UseParallelGC
-Xverify:none
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24c789d1b89381d9c1aeaac040e656d/" rel="bookmark">
			Web UI技术综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是UI？什么是UI设计师？ 1、什么是UI 按照Wiki的解释： In the industrial design field of human–machine interaction, the user interface is the space where interaction between humans and machines occurs. 其实就是：User Interface（用户界面）的简称。UI设计则是指对软件的人机交互、操作逻辑、界面美观的整体设计。好的UI设计不仅是让软件变得有个性有品味，还要让软件的操作变得舒适、简单、自由、充分体现软件的定位和特点。 2、什么是UI设计师 UI设计师根据职责分为研究工具、研究人机界面、研究人三个方向。国内目前大部分UI工作者都是从事这个行业。也有人称之为美工，但实际上不是单纯意义上的美术工人，而是软件产品的产品外形设计师。 在XXT公司，大家也通常会把UI理解为“美工”，如“赵工”。她们需要具有良好的美术功底与创意能力；她们被理解为网页美工，需要会CSS/HTML等网络语言；她们需要熟悉各种平面设计软件，如PHOTOSHOP、FLASH、Dreamweaver等软件，能设计出好看的页面，再好点儿的，或者层次再高点儿的需要懂JAVASCRIPT或者Flex语言。她们根据原型图设计出静态页面，供开发人员开发。她们不做交互，只负责页面是不是好看：包括网页的布局、颜色的搭配、图标的选择、网站模板的设计等工作，这就是我们这些开发人员通俗上对UI 和 UI设计师的理解。 所以，我们开发过程中，或者开发完毕之后，经常会说：“赵工，这个样式帮我美化下吧”。 二、什么是交互设计？什么是交互设计师？ 交互设计：interaction designer，它是UI设计的一个方向---研究人与界面的关系。交互设计师的工作内容就是在软件产品编码之前进行交互设计，并且确立交互模型，交互规范。 交互设计师：就是设计和改进界面产品原型设计的人。她们需要通过分析和讨论以及与用户沟通，不断改进界面产品原型的设计，给用户最好的功能操作和体验。她们需要懂得平面设计、视觉设计；她们需要熟悉UI设计的基本规范，具有良好的创意设计能力；她们需要熟练运用Photoshop，Dreamweaver等设计工具，具备良好的客户服务意识；她们还需要具备良好的沟通能力，哈哈，要求太高了。 在XXT公司，这部分工作被两个部门的人所承担，网站组和开发组。网站组负责原型的设计，她们会做简单的原型，但是不懂平面设计、不懂视觉设计、不懂基本的UI规范，她们多是半道转过来的。技术人员也不懂平面设计、不懂视觉设计、但是他们懂一些UI规范，知道模仿，就可以从其他网站模仿出来交互的效果，进而加以改进。这个工作似乎不该让技术开发人员来承担，但是目前的现状确实是如此，我们不得不承担交互的大部分工作。突然想起鲁迅他老人家在《故乡》中的一句话：世界上本没有路，走的人多了，也就成了路。 三、Web UI技术的前世今生 回到主题，当前Web前端技术就像个百花筒，只要你有创意，什么都可以展示出来。好的Web UI设计的代表，苹果网站的体验就不说了，可以看看雅虎的UI，淘宝的UI，腾讯的UI，看人家就像看美女，养眼，舒服（当然，MM可以当帅锅看）。 从Web1.0到现在的Web2.0，除了更多的互动性的互联网服务，如SNS，blog等，Web技术的发展也是最主要的。在这个历史的变迁过程中，我们看看发生了哪些变化： 纯文本网页：只有最简单的文字和超链接 静态HTMl页：包括了文字、图片，融入了字体、样式、背景、框架和一些特效。这时的Web页面已经具备了较强的静态展示能力，丰富多彩的展示效果，被越来越多的人所接受。 WebUI成熟期：96年JavaScript和Css相继产生，W3c规范出炉，这一切都使得UI发展更加成熟。 动态页面：随着CGI、ASP、JSP、PHP等服务器端脚本技术的产生，开始出现了动态页面。服务器端根据用户提交的请求，将数据也网页动态的拼装出HTMl文本输出到浏览器。 随着技术的进一步发展，Struct、Webwork、JSF等基于J2EE技术的Web框架开始日趋成熟。在此过程中，随着Web2.0的发展，基于Ajax的交互技术、基于JavaScript的Ui框架，Flash技术、Flex技术都开始展露头角，并在Web2.0发挥了极大的作用。这就造就了Web2.0的的迅猛发展和WebUI的日益强大。 从入职XXT公司到现在，一致在做开发，无论是前端的，还是后端的。刚入职时，每天面对的就是JSP、JS这些代码，现在来看，这些依然是我们开发时的主要技术点。再根据网上找的，看看Web技术主要有哪些吧： 代表技术： JS和Css应该是做前端技术所必备的两大武器了，如果你不会JS，不懂Css，可想，前端的你是很悲哀的。 Ajax：它很强大，它的争议也很多，但是不可否认它在当前的Web开发中占据了不可替代的作用。它为浏览器提供了在不提交整个页面的情况下动态的与服务器交互的能力，使得Web应用的用户体验性得到了极大的提高。所以，连市场和策划的同事，在看我们做的产品时，都会说“这个地方能不能不刷新整个页面，让它局部刷新”。目前主流的客户端Ajax框架有：JQuery，DoJo，ProtoType，我们目前在用JQuery。 基于JS的UI技术：基于JS的UI技术的出现，将WebUI的控制权从设计人员转换到了程序员，即可以直接在Web前端使用JavaScript的脚本描述一个UI组件模型，在运行时，由浏览器的脚本解释器调用UI框架来转换成HTML的UI界面。此类技术有：ExtJS，Yahoo UI，其中ExtJS框架是比较完善且易于使用的。对于ExtJS的赞美我也不去说了，自己到百度上google吧。By the way , 我们还没有开始使用这些，但经过最近一个项目的开发，大家也都想看看ExtJS。 Flash：这个技术大家都不陌生吧，在hi.xxt.cn的页面上也小小的用了下，还是很形象而生动的。借助Flash可以做出很漂亮的用户界面、绚丽的动画效果。想想上大学时，Flash是何其流行，大概每个学计算机的都跃跃欲试，不是为了追求技术，而是为了用来追求MM。 Flex：这个玩意最近几年挺火的，我没有用过，也没学过，只是听大个、阿黄等几个人谈论过，它使用基于XML的MXML语言，提供多种常用组件，可实现WebService、Drag and Drop、列排序、图标、视频播放器等。目标是开发出更好的RIA应用程序（RIA : Rich Internet Applications, 富互联网应用，具有高度互动性、丰富的用户体验以及强大的客户端功能）。最近在做的视频，学到了这个玩意。 其它的还有很多，不一一列举了。 四、当前公司Web技术概述 入职XXT公司已经快三年了，虽然也做设计、做需求，但更多时候还是战斗在开发的一线。从入职到现在，也伴随着技术部技术的发展。从纯jsp到Webwork到spring+ibatis，从js到Jquery，这些也都一直在学习。对前端这样一个概念，应该是在09年底才提出来的。新人的到来，人员的丰富，使得技术也补充了新鲜血液，我们也开始有了前端开发的概念，考虑开发的分工。 在做宝贝计划项目的时候第一次引入了JQuery，那是还感觉很新鲜，大家一起学习，一起进步，到后来，慢慢的往熟练工过度，在到后来zxw开发时，前端技术的制约，才发现我们对前端的理解这么肤浅，知之甚少不知者甚多。 我们开始考虑前端发展的方向、前端的代码规范、在前端引入成熟的框架。开始有意识的重新学习js、css等。回归基础，退一步海阔天空。 我们开始更多了解新的互联网产品，模仿、学习，接触更广阔的世界，不能局限于当前这个小环境，这是个交流与共享的世界，共享设计、共享创意、共享知识与成果。 五、前端一些积累。 好的东西是用来分享的，可以多看看，哪怕暂时用不到。 淘宝UED： http://ued.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c24c789d1b89381d9c1aeaac040e656d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf2069d14f4f685638238ccfcd188fec/" rel="bookmark">
			Windows7 如何安装如何安装ADSI EDIT工具(远程访问ldap)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正常安装方法如下：
微软的很多产品都离不开AD，所以免不了要和AD打交道。而AD中对象的属性名十在很难都记得住，所以ADSI Edit这个工具还是非常有用的。
注： Zip包中包括adsiedit.dll和adsiedit.msc两个文件，需要手动把他们拷到指定路径下，比如：
C: /windows/system32/adsiedit.dll 然后还需要进行注册，如运行中执行:regsvr32 C: /windows/system32/adsiedit.dll
按照上面的方法在XP系统上是能够正常安装的，但是在win7系统下由于有权限的问题所以要做一些特殊的限制：
前面方法都一样，就是在执行regsvr32 C:/windows/system32/adsiedit.dll这条命令时要先通过：开始-》所有程序-》附件-》命令提示符-》右键点击命令提示符-》选择以管理员身份执行-》然后在弹出的命令行窗口中执行regsvr32 C:/windows/system32/adsiedit.dll这条命令就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847b2b0afcc02643188fe8fef50f06e7/" rel="bookmark">
			一个经典例子让你彻彻底底理解java回调机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转帖请注明本文出自xiaanming的博客（http://blog.csdn.net/xiaanming/article/details/17483273），请尊重他人的辛勤劳动成果，谢谢
以前不理解什么叫回调，天天听人家说加一个回调方法啥的，心里想我草，什么叫回调方法啊？然后自己就在网上找啊找啊找，找了很多也不是很明白，现在知道了，所谓回调：就是A类中调用B类中的某个方法C，然后B类中反过来调用A类中的方法D，D这个方法就叫回调方法，这样子说你是不是有点晕晕的，其实我刚开始也是这样不理解，看了人家说比较经典的回调方式：
Class A实现接口CallBack callback——背景1 class A中包含一个class B的引用b ——背景2 class B有一个参数为callback的方法f(CallBack callback) ——背景3 A的对象a调用B的方法 f(CallBack callback) ——A类调用B类的某个方法 C然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D 大家都喜欢用打电话的例子，好吧，为了跟上时代，我也用这个例子好了，我这个例子采用异步加回调
有一天小王遇到一个很难的问题，问题是“1 + 1 = ?”，就打电话问小李，小李一下子也不知道，就跟小王说，等我办完手上的事情，就去想想答案，小王也不会傻傻的拿着电话去等小李的答案吧，于是小王就对小李说，我还要去逛街，你知道了答案就打我电话告诉我，于是挂了电话，自己办自己的事情，过了一个小时，小李打了小王的电话，告诉他答案是2
/** * 这是一个回调接口 * @author xiaanming * */ public interface CallBack { /** * 这个是小李知道答案时要调用的函数告诉小王，也就是回调函数 * @param result 是答案 */ public void solve(String result); } /** * 这个是小王 * @author xiaanming * 实现了一个回调接口CallBack，相当于-----&gt;背景一 */ public class Wang implements CallBack { /** * 小李对象的引用 * 相当于-----&gt;背景二 */ private Li li; /** * 小王的构造方法，持有小李的引用 * @param li */ public Wang(Li li){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847b2b0afcc02643188fe8fef50f06e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9608b633441776f6298c5459efe01598/" rel="bookmark">
			Valid signing identity not found解决办法（原有IDP私钥丢失）及Certificate、App ID、Devices、Provisioning Profiles之间区别...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
刚刚把mini换成了macbookair，之前一直在mini上进行开发，到换air之前，第一个项目刚刚上线，第一次申请测试，发布证书等等都是在mini上完成的，由于粗心未能料到，换成air后，就把mini的全部清空，然后二手卖了，之前的开发证书也被我删除了，其实应该备份和导出的。。。。
导致现在在新air上，登陆网站：
想直接下载之前建立好的证书，可是下载双击后，在钥匙串里发现：
总是感觉少点东西，终于发现，我们download的这个证书没有之前开发电脑上的小钥匙了，就是所谓的私人秘钥。
然后在网站的provision标签里下载项目的provisioning文件，看看效果如何：
下载后双击，打开Xcode----organizer，看一看provising files里的status，坏了：
系统识别不了了，也就是说，我们缺少那个之前开发电脑的个人秘钥，就是按照当时首次真机调试网上流程，生成CertificateSigningRequest.certSigningRequest上传，下载的那个私人证书秘钥！！
你是不是也遇到了我这种情况，而现如今，之前开发时的电脑还找不到了，也就是说，无法导出来了。
1，Valid signing identity not found解决办法 解决办法：
一：沿用原来的证书
找到之前开发电脑的证书，导出-导入，这是最简单简便省事的方法！
1，在原来电脑上点开钥匙串访问 工具，找到我们iphone developer 开发证书，然后右键导出
注意那条小钥匙，必须带这个才能导出p12。
右击证书，导出，(p12方式),输入密码，这个密码任意，记住就好。
然后将这个文件拷到新电脑，双击导入，输入刚刚的密码即可。
如果Organizer里面没有显示，则再次双击mobileprovision证书，就可以看到绿色的“Valid profile”。大功告成！
通过P12和证书文件，使用另一Account真机调试
如果你想使用别人的account来真机调试，确保他会发给你以下文件：证书文件、授权文件和p12文件
双击development和distribution的cer以及他们的p12文件（有秘钥的话需要输入秘钥），自己的钥匙串会有如下：
再双击dev和distProfile文件（mobileprovision）然后在自己项目的TARGETS和PROJECT中更改Provisioning Profile和Code Signing，更改profile为对方account的Developer和Distribution，如下：
最后，运行如果失败，如下提示：
查看工程的PROJECT下的Code Signing是否更换成了目标account证书，如果没问题，确保目标account添加了你真机测试的Devices！
二、revoke掉，重新生成（建议只有在原来的找不到的情况下）
删掉钥匙串里所有的相关证书，主要是下面这个： 然后到Provisioning Portal， 删掉以前的东西，重新来一次，revoke。 revoke后，发现又回到了最初时的状态，如下图： 很熟悉的样子，又回到了我们第一次上传私钥的步骤，我们在重新制作证书前，先看一下此时distribution标签下的发布证书还有没有，如下图所示，发布证书么有收到牵连，还存在，表明还可以使用： 继续看一下devices栏下的设备是否存在： 继续看一下provisioning files 是否还存在，貌似status变成了invalid的，不过后面有modify选项，貌似可以激活，回头等更新版本时，再来尝试： 继续切换distribution标签的provision files，status还是活跃的，到目前为止，仿佛明白，真机调试，需要具备私钥+（公钥）；而发布时，拥有符合的公钥就可以了？ 继续下一步，我们看看APP ID 还是否存在，如下图所示：跟之前的一样 综上所述，revoke后，只有对调试的provision files有些影响，其余的都可以照常使用，哪么，我们就可以放心的重新制作证书啦。 我们用钥匙串工具，生成本地的私人秘钥（CertificateSigningRequest.certSigningRequest），通过点击网页上的request Certificate 上传后，apple验证我们的开发者身份，并签名生成（私有+公有）开发证书，按照当时创建的教程再重复一遍。 双击新制作的ios_development.cer之后再打开xocde-organizer，就会发现，provisioning files可以使用了（记得在网站上modify后再下载下来） 2，在MAC下建立多用户进行ios开发时证书和Provisionfile的问题 情景：在一台MAC机上，创建了一个新的用户，然后切换到新用户下，进行ios开发，此时发现真机连接后，在Organizer提示Valid signing identity not found~~~我尝试把主用户下的私钥和证书都拷贝到新用户下，还是不行。可是我在切换回主用户下，一切又没问题了，由此推断：【同一台电脑，建立不同的用户，钥匙串不能共享？】 所以我们目前只有公钥，缺少一个私钥，mac os 下，不同的用户，相当于不同的mac了，我们只能各自生成一个私钥。接下来的步骤，你应该都是熟悉的，打开developer.apple.com网站 1，添加Add iOS Certificate （如果IOS APP Development不能选择，那么说明你需要revoke掉一个development证书了） 2，在当前用户下生成私钥 钥匙串访问-证书助理-从证书颁发机构请求证书-邮件-名称-存储到磁盘=生成-CertificateSigningRequest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9608b633441776f6298c5459efe01598/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda32419de09bd109f5e21567e19423b/" rel="bookmark">
			USB UMS MTP设置过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择MTP，PTP，UMS的选项界面就定义在UsbSettings.java，选择其中一个选项时会执行以下代码。
packages/apps/Settings/src/com/android/settings/deviceinfo/UsbSettings.java
if (preference == mMtp) { mUsbManager.setCurrentFunction(UsbManager.USB_FUNCTION_MTP, true); updateToggles(UsbManager.USB_FUNCTION_MTP); } else if (preference == mPtp) { mUsbManager.setCurrentFunction(UsbManager.USB_FUNCTION_PTP, true); updateToggles(UsbManager.USB_FUNCTION_PTP); } else if(preference == mUms) { mUsbManager.setCurrentFunction(UsbManager.USB_FUNCTION_MASS_STORAGE, true); updateToggles(UsbManager.USB_FUNCTION_MASS_STORAGE); } updateToggle就是去让执行某些选项的选中与取消工作。
其中最重要的是mUsbManager.setCurrentFunction()，mUsbManger是这样得到的：
@Override public void onCreate(Bundle icicle) { super.onCreate(icicle); mUsbManager = (UsbManager)getSystemService(Context.USB_SERVICE); } 它的实现在frameworks/base/core/java/android/hardware/usb/UsbManager.java。 它的接口实现在frameworks/base/core/java/android/hardware/usb/IUsbManager.aidl
frameworks/base/services/java/com/android/server/usb/UsbService.java
/** * UsbService manages all USB related state, including both host and device support. * Host related events and calls are delegated to UsbHostManager, and device related * support is delegated to UsbDeviceManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cda32419de09bd109f5e21567e19423b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6479a717308a69a5a72efcbedec2345/" rel="bookmark">
			office使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：方框内如何打钩？
以下方法仅供参考:
单独插入 ：word里有插入,特殊符号可以插入框和对号及叉号
具体：（1）插入勾叉：插入—特殊符号—-数学符号—-选择勾，叉
（2） 插入框：插入—特殊符号—-选择方框
在方框中插入勾叉，推荐第一种方法：
法一 格式—中文 版式—带圈字符—根据需要在文字里面选择勾（√）或者叉（×），然后在圈号里面选择方框，确定即可。
当我们在样式上选择无、缩小文字、增大圈号时，出来的效果依次为左边的情况，朋友们可以根据需要选择。如果大家有好的建议或者问题，可以留言一起探讨！
法二（在 小方框里打勾）在word里输入大写的“R”，然后字体改成“Wingdings 2”，就OK了！大小的话，可以选择字体大小来控制！
（在小方框里打叉）在word里输入大写的“S”，然后字体改成“Wingdings 2”，就OK了！大小的话，可以选择字体大小来控制！
法三 在word中选择视图-工具栏-控件工具箱既有选择要插入的控件，比如小方框带个小勾的那个 编辑完退出，在文档中点击方框即可实现钩选/取消钩
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ea7eedf9e0c66b9c1ad7c8d1c997d2/" rel="bookmark">
			对zebra的一点思考(Think Of ZEBRA)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/xuyanbo2008/article/details/7439936
===================================================
此文并不针对zebra的应用，甚至不是一个架构的分析，只是对于Zebra的一点儿思考。 Zebra 设计得是如此简洁明快。每一种数据结构均对应于一定的应用，它们之间以一种松耦合的方式共存，而多种数据结构组成的功能模块几乎完美的结合在一起，完成了非常复杂的功能。它的设计思想就在于对C语言面向对象式的应用。 虽然很多程序均借鉴面向对象设计方式，但是Zebra的代码风格是易读的，非常易于理解和学习，与此同时，Zebra使用了丰富的数据结构，比 如链表、向量、表和队列等，它的松耦合方式使得每一数据结构封装的功能模块很容易被精简剥离出来，以备我们特殊的应用。这就是我写下Think Of ZEBRA非常重要的原因！ 1.ZEBRA中的thread 提起thread就会让人想起线程，Linux中的线程被称为pthread，这里的thread 不是pthread，因为它只是对线程的应用层模拟。ZEBRA借助自己的thread结构，将所有的事件（比如文件描述的读写事件，定时事件等）和对应 的处理函数封装起来，并取名为struct thread。然后这些threads又被装入不同的“线程“链表挂载到名为thread_master的结构中，这样所有的操作只需要面向 thead_master。
/* Thread itself. */
struct thread
{
unsigned char type; /* thread type */
struct thread *next; /* next pointer of the thread */
struct thread *prev; /* previous pointer of the thread */
struct thread_master *master; /* pointer to the struct thread_master. */
int (*func) (struct thread *); /* event function */
void *arg; /* event argument */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1ea7eedf9e0c66b9c1ad7c8d1c997d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff11be484d35d06f495018ea459a4c14/" rel="bookmark">
			qjh.py
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		x=1
while x==1:
print "hello word!"
break
print "i can done"
#利用重定向，向文件中写数据
f=open("d:\\qujinhua.log","w")
print &gt;&gt;f,"haha,wo ye hui e"
f.close()
#利用write（）方法写数据
f=open("d:\\qujinhua1006.log","w")
f.write("qu ni de ,qu ni ma de \n")
f.close()
#读出数据
f=open("d:\\qujinhua1006.log")
print " "
print f.read()
f=open("d:\\qujinhua.log")
print f.read()
#pt=raw_input("please input your word:")
#print pt
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b9c685c6bad43ef1d5f7d2407452c9a/" rel="bookmark">
			如何计算网络带宽需求?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【TechTarget中国原创】不同网络的带宽需求的不同的。计算每秒在网络中的流量以及每个应用程序所使用的带宽总量对于建立或维护一个快速高效的网络来说至关重要。
如同大多数网络管理人员所说的，网络带宽是设计和维护高效LAN或WAN的最关键因素。和服务器不同，服务器可以在网络中任意配置，但是带宽在设计网络初期就做了最佳优化。在设计网络时，你如何计算你需要的带宽总量？需要考虑哪些具体应用？在本文中，我们将就这几个问题做出回答。
带宽是指通过网络连接或网络连接接口的数据速率。通常用每秒比特（bps），或有时用每秒字节（Bps）来表述。带宽描述了网络连接的性能，重要的是我们要理解理论上的吞吐量和实际结果之间的差别。例如， 1000BASE-T（使用非屏蔽双绞线）千兆以太网（GbE）网络，理论上可支持1,000兆每秒（Mbit/s），但由于硬件和系统软件等各方面的综合影响，实际根本不可能达到这个水平。所以想要精确计算带宽总量还是充满了挑战。
那你该如何计算你所需的带宽总量呢？首先你需要提出正确的问题——网络中都运行了哪些应用程序，这些应用程序的性能服务水平协议（SLA）如何？我认识一些网络管理人员，他们只关心VLAN中的用户人数。其实你真正该关心的是这些用户在网络中都在做什么。也许就算是有200个用户，他们也不一定会造成网络拥堵，相反，可能因为一些客户端服务器应用程序，就算是只有几个用户的网络也有可能出现瘫痪。
计算网络带宽
计算带宽有两个基本步骤：
1． 确定网络中可用的带宽。
2． 确定特殊应用程序所需的平均利用水平。
这两方面的数据都可以用Bps来表示。如果你的网络是GbE，那你可能会得到差不多125,000,000 bps。按千兆以太网计算，就是用10亿bps除以8得到字节数。(1,000,000,000 bps / 8 = 125,000,000 Bps)
确定了网络的带宽之后，你需要确定网络中每个应用程序所用的带宽。可以用专门的网络分析工具来测量网络中应用程序所占的Bps数据。在这之前，你需要打开网络分析工具的Cumulative Bytes。之后，你需要做的事包括：
1. 捕获运行应用程序的测试工作站上通过的流量。
2. 在译码摘要窗口，标注出文件传输起始时的数据包。
3. 查询秒级时间戳，之后查看累积的字段。
如果经过所有的测试你得出应用程序所用数据为200,000 Bps，那你就可以根据这个信息得出结果：125,000,000 / 200,000 = 625。在这种情况下，即使有几百个用户同时占用网络，都不成问题。但如果你的网络容量为100mbps，你可以看看会发生什么情况。就算是不超过60个用户，如果他们同时运行某个应用程序网络都难以承受。所以说，带宽是非常重要的！
我习惯于按每十秒为单位捕获数据，再看看结果。我同样比较倾向于使用多个工作站，这样得出的结果更能反映普遍状况。与此同时，你还需要弄清楚当前使用者的数量。显然，两个还是20个用户对带宽的影响还是有一定差别的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74e0b4f1dce913d9a97a5041d9b327d0/" rel="bookmark">
			Shell_scp expect实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Shell_scp expect实现 时间:2012-10-23 08:52 来源:未知 作者:zhibj 点击: 199 次 使用expect实现自动登录的脚本，网上有很多，可是都没有一个明白的说明，初学者一般都是照抄、收藏。可是为什么要这么写却不知其然。本文用一个最短的例子说明脚本的原理。 南京嵌入式培训 脚本代码如下： ############################################## # 使用expect实现自动登录的脚本，网上有很多，可是都没有一个明白的说明，初学者一般都是照抄、收藏。可是为什么要这么写却不知其然。本文用一个最短的例子说明脚本的原理。
南京嵌入式培训
脚本代码如下：
##############################################
#!/usr/bin/expect
set timeout 30
spawn ssh -l username 192.168.1.1
expect "password:"
send "ispass\r"
interact ##############################################
1. ［#!/usr/bin/expect］
这一行告诉操作系统脚本里的代码使用那一个shell来执行。这里的expect其实和linux下的bash、windows下的cmd是一类东西。
注意：这一行需要在脚本的第一行。
2. ［set timeout 30］
基本上认识英文的都知道这是设置超时时间的，现在你只要记住他的计时单位是：秒
3. ［spawn ssh -l username 192.168.1.1］
spawn是进入expect环境后才可以执行的expect内部命令，如果没有装expect或者直接在默认的SHELL下执行是找不到spawn命 令的。所以不要用 “which spawn“之类的命令去找spawn命令。好比windows里的dir就是一个内部命令，这个命令由shell自带，你无法找到一个dir.com 或 dir.exe 的可执行文件。
它主要的功能是给ssh运行进程加个壳，用来传递交互指令。南京嵌入式培训
4. ［expect "password:"］
这里的expect也是expect的一个内部命令，有点晕吧，expect的shell命令和内部命令是一样的，但不是一个功能，习惯就好了。这个命 令的意思是判断上次输出结果里是否包含“password:”的字符串，如果有则立即返回，否则就等待一段时间后返回，这里等待时长就是前面设置的30秒 南京嵌入式培训
5. ［send "ispass\r"］
这里就是执行交互动作，与手工输入密码的动作等效。
温馨提示： 命令字符串结尾别忘记加上“\r”，如果出现异常等待的状态可以核查一下。
6. ［interact］
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74e0b4f1dce913d9a97a5041d9b327d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85235e9400e21b3e6c2e908c90697fd/" rel="bookmark">
			ETL三大主流工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://chenjinglys.blog.163.com/blog/static/16657571620113211381934/
ETL是数据仓库建设的重要环节。相对于关系数据库，数据仓库技术没有严格的数学理论基础，它更面向实际工程应用。所以从工程应用的角度来考虑，按着物理数据模型的要求加载数据并对数据进行一些系列处理，处理过程与经验直接相关，同时这部分的工作直接关系数据仓库中数据的质量，从而影响到联机分析处理和数据挖掘的结果的质量。
数据仓库建设是一个独立的数据环境，需要通过抽取过程将数据从联机事务处理环境、外部数据源和脱机的数据存储介质导入到数据仓库中；在技术上，ETL 主要涉及到关联、转换、增量、调度和监控等几个方面；数据仓库系统中数据不要求与联机事务处理系统中数据实时同步，所以ETL可以定时进行。但多个ETL 的操作时间、顺序和成败对数据仓库中信息的有效性至关重要。
ETL作为BI/DW（Business Intelligence）的核心和灵魂，能够按照统一的规则集成并提高数据的价值，是负责完成数据从数据源向目标数据仓库转化的过程，是实施数据仓库的重要步骤。如果说数据仓库的模型设计是一座大厦的设计蓝图，数据是砖瓦的话，那么ETL就是建设大厦的过程。在整个项目中最难部分是用户需求分析和模型设计，而ETL规则设计和实施则是工作量最大的，约占整个项目的60%～80%，这是国内外从众多实践中得到的普遍共识。
ETL工具中典型的代表产品有Informatica的PowerCent、Ascential的Datastage、Oracle的OWB、 Microsoft SQLServer2000的DTS、Microsoft SQLServer2005的SSIS服务等。目前在数据抽取过程中经常采用三种方法，第一种是借助专业的ETL工具实现；第二种是SQL编程方式实现；第三种是ETL工具和SQL相结合。前两种方法各有优缺点，借助工具可以快速的建立起ETL工程，屏蔽复杂的编码任务，提高速度，降低难度，但缺少灵活性。SQL编程的优点是灵活，提高ETL运行效率，但是编码复杂，对技术要求比较高。第三种综合了前两种的优点，极大的提高ETL的开发速度和效率。
在数据环境改造和数据库工程实施中（包括统一数据中心的建设过程中），我们可根据业主方的具体情况推荐相应的ETL工具采购或进行ETL及调度软件的定制研发，在节省投入、提高效率的前提下推进数据库/数据仓库的建设，贯彻落实好规划成果。
ETL（extract, transform and load）产品乍看起来似乎并不起眼，单就此项技术本身而言，几乎也没什么特别深奥之处，但是在实际项目中，却常常在这个环节耗费太多的人力，而在后续的维护工作中，更是往往让人伤透脑筋。之所以出现这种状况，恰恰与项目初期没有正确估计ETL工作、没有认真考虑其工具支撑有很大关系。
做ETL产品的选型，仍然需要从以前说的四点（即成本、人员经验、案例和技术支持）来考量。在此，主要列举三种主流ETL产品：Ascential公司的Datastage、Informatica公司的Powercenter、 NCR Teradata公司的ETL Automation。其中，ETL Automation相对其他两种有些特别之处，放在后面评述。
旗鼓相当：Datastage与Powercenter
就Datastage和Powercenter而言，这两者目前占据了国内市场绝大部分的份额，在成本上看水平相当，虽然市面上还有诸如Business Objects公司的Data Integrator、Cognos公司的DecisionStream，但尚属星星之火，未成燎原之势。
谈Datastage和Powercenter，如果有人说这个就是比那个好，那听者就要小心一点了。在这种情况下有两种可能：他或者是其中一个厂商的员工，或者就是在某个产品上有很多经验而在另一产品上经验缺乏的开发者。为什么得出这一结论？一个很简单的事实是，从网络上大家对它们的讨论和争执来看，基本上是各有千秋，都有着相当数量的成功案例和实施高手。确实，工具是死的，人才是活的。在两大 ETL工具技术的比对上，可以从对ETL流程的支持、对元数据的支持、对数据质量的支持、维护的方便性、定制开发功能的支持等方面考虑。
一个项目中，从数据源到最终目标表，多则上百个ETL过程，少则也有十几个。这些过程之间的依赖关系、出错控制以及恢复的流程处理，都是工具需要重点考虑。在这一方面，Datastage的早期版本对流程就缺乏考虑，而在6版本则加入Job Sequence的特性，可以将Job、shell脚本用流程图的方式表示出来，依赖关系、串行或是并行都可以一目了然，就直观多了。 Powercenter有Workflow的概念，也同样可以将Session串联起来，这和Datastage Sequence大同小异。
ETL的元数据包括数据源、目标数据的结构、转换规则以及过程的依赖关系等。在这方面，Datastage和Powercenter从功能上看可谓不分伯仲，只是后者的元数据更加开放，存放在关系数据库中，可以很容易被访问。此外，这两个厂家又同时提供专门的元数据管理工具，Ascential有Metastage，而Informatica拥有Superglue。你看，就不给你全部功能，变着法子从你口袋里面多掏点钱。
数据质量方面，两种产品都采用同样的策略——独立出ETL产品之外，另外有专门的数据质量管理产品。例如和Datastage配套用的有ProfileStage和QualityStage，而Informatica最近也索性收购了原先OEM的数据质量管理产品FirstLogic。而在它们的ETL产品中，只是在Job或是Session前后留下接口，所谓前过程、后过程，虽然不是专为数据质量预留的接口，不过至少可以利用它外挂一些数据质量控制的模块。
在具体实现上看，Datastage通过Job实现一个ETL过程，运行时可以通过指定不同参数运行多个实例。Powercenter通过Mapping表示一个ETL过程，运行时为Session，绑定了具体的物理数据文件或表。在修改维护上，这两个工具都是提供图形化界面。这样的好处是直观、傻瓜式的；不好的地方就是改动还是比较费事（特别是批量化的修改）。
定制开发方面，两者都提供抽取、转换插件的定制，但笔者认为，Datastage的定制开发性要比Powercenter要强那么一点点。因为Datastage至少还内嵌一种类BASIC语言，可以写一段批处理程序来增加灵活性，而 Powercenter似乎还缺乏这类机制。另外从参数控制上，虽然两者的参数传递都是比较混乱的，但Datastage至少可以对每个job设定参数，并且可以job内部引用这个参数名；而Powercenter显得就有些偷懒，参数放在一个参数文件中，理论上的确可以灵活控制参数，但这个灵活性需要你自己更新文件中的参数值（例如日期更新）。另外，Powercenter还不能在mapping或session中引用参数名，这一点就让人恼火。
总起来看，Datastage和Powercenter可谓旗鼓相当，在国内也都有足够的支持能力，Datastage在2005年被IBM收购之后，可以说后劲十足。而Informatica则朝着BI全解决方案提供商方向发展，Powercenter显然还将是它的核心产品。
独树一帜：Teradata的ETL Automation
继续要说的第三种产品是Teradata的ETL Automation。之所以拿它单独来说是因为它和前面两种产品的体系架构都不太一样。与其说它是ETL工具，不如说是提供了一套ETL框架。它没有将注意力放在如何处理“转换”这个环节上，而是利用Teradata数据库本身的并行处理能力，用SQL语句来做数据转换的工作，其重点是提供对ETL流程的支持，包括前后依赖、执行和监控等。
这样的设计和Datastage、Powercenter风格迥异，后两者给人的印象是具有灵活的图形化界面，开发者可以傻瓜式处理ETL工作，它们一般都拥有非常多的“转换”组件，例如聚集汇总、缓慢变化维的转换。而对于Teradata的 ETL Automation，有人说它其实应该叫做ELT，即装载是在转换之前的。的确，如果依赖数据库的能力去处理转换，恐怕只能是ELT，因为转换只能在数据库内部进行。从这个角度看，Automation对数据库的依赖不小，似乎是一种不灵活的设计。也正是这个原因，考虑它的成本就不单单是ETL产品的成本了。
其实，在购买现成的工具之外，还有自己从头开发ETL程序的。
ETL工作看起来并不复杂，特别是在数据量小、没有什么转换逻辑的时候，自己开发似乎非常节省成本。的确，主流的ETL工具价格不菲，动辄几十万；而从头开发无非就是费点人力而已，可以控制。至于性能，人大多是相信自己的，认为自己开发出来的东西知根知底，至少这些程序可以完全由自己控制。
就目前自主开发的ETL程序而言，有人用c语言编写，有人用存储过程，还有人用各种语言混杂开发，程序之间各自独立。这很危险，虽然能够让开发者过足编码的瘾，却根本不存在架构。
有位银行的朋友，他们几年前上的数据仓库系统，就是集成商自己用c语言专门为他们的项目开发的。单从性能上看似乎还不赖，然而一两年下来，项目组成员风雨飘零，早已物是人非，只有那套程序还在那里；而且，按照国内目前的软件工程惯例，程序注释和文档是不全或者是不一致的，这样的程序已经对日常业务造成很大阻碍。最近，他们已经开始考虑使用ETL工具重新改造了.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/918cbfc016b76d7396d8b55e1f03368e/" rel="bookmark">
			100行代码实现最简单的基于FFMPEG&#43;SDL的视频播放器（SDL1.x）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		=====================================================
最简单的基于FFmpeg的视频播放器系列文章列表：
100行代码实现最简单的基于FFMPEG+SDL的视频播放器（SDL1.x）
最简单的基于FFMPEG+SDL的视频播放器 ver2 （采用SDL2.0）
最简单的基于FFmpeg的解码器-纯净版（不包含libavformat）
最简单的基于FFMPEG+SDL的视频播放器：拆分-解码器和播放器
最简单的基于FFMPEG的Helloworld程序
=====================================================
简介 FFMPEG工程浩大，可以参考的书籍又不是很多，因此很多刚学习FFMPEG的人常常感觉到无从下手。我刚接触FFMPEG的时候也感觉不知从何学起。
因此我把自己做项目过程中实现的一个非常简单的视频播放器（大约100行代码）源代码传上来，以作备忘，同时方便新手学习FFMPEG。
该播放器虽然简单，但是几乎包含了使用FFMPEG播放一个视频所有必备的API，并且使用SDL显示解码出来的视频。
并且支持流媒体等多种视频输入，处于简单考虑，没有音频部分，同时视频播放采用直接延时40ms的方式
平台使用VC2010，使用了新版的FFMPEG类库。
SourceForge项目主页：
https://sourceforge.net/projects/simplestffmpegplayer/
注：本文SDL采用1.x版本。另一版本采用SDL2.0，可参考：
基于FFMPEG+SDL的视频播放器 ver2 （采用SDL2.0）：http://blog.csdn.net/leixiaohua1020/article/details/38868499
流程图 没想到这篇文章中介绍的播放器挺受FFMPEG初学者的欢迎，因此再次更新两张流程图，方便大家学习。此外在源代码上添加了注释，方便理解。
该播放器解码的流程用图的方式可以表示称如下形式：
SDL显示YUV图像的流程图：
简单解释几句：
SDL_Surface就是使用SDL的时候弹出的那个窗口。在SDL1.x版本中，只可以创建一个SDL_Surface。
SDL_Overlay用于显示YUV数据。一个SDL_Overlay对应一帧YUV数据。
SDL_Rect用于确定SDL_Overlay显示的位置。注意：一个SDL_Overlay可以指定多个不同的SDL_Rect，这样就可以在SDL_Surface不同位置显示相同的内容。
它们的关系如下图所示：
下图举了个例子，指定了4个SDL_Rect，可以实现4分屏的显示。
simplest_ffmpeg_player（标准版）代码 /** * 最简单的基于FFmpeg的视频播放器 * Simplest FFmpeg Player * * 雷霄骅 Lei Xiaohua * leixiaohua1020@126.com * 中国传媒大学/数字电视技术 * Communication University of China / Digital TV Technology * http://blog.csdn.net/leixiaohua1020 * * 本程序实现了视频文件的解码和显示（支持HEVC，H.264，MPEG2等）。 * 是最简单的FFmpeg视频解码方面的教程。 * 通过学习本例子可以了解FFmpeg的解码流程。 * This software is a simplest video player based on FFmpeg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/918cbfc016b76d7396d8b55e1f03368e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cdee98dd1396a514b01c9a5c8b24901/" rel="bookmark">
			linux中文文件夹如何改回英文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/ablo_zhou
2010.3.18
其实我已经忍了很久。
ubuntu在中文界面下面，自动创建了“桌面”，“文档”，图片 、公共的 、下载、 音乐、 视频等中文目录。
在命令行下操作的时候，要么切换到中文输入法，要么粘贴。如果在没有输入法的环境，可能操作这些目录都存在困难。
总觉得很别扭。我用Linux是为了提高效率，可是总是为了操作这些目录多按几个键甚至中断操作，得不偿失嘛。
windows操作系统虽然也有桌面，文档，图片，音乐之类的文件夹。但windows体贴的地方是，看到的是中文，而目录其实是英文。这样在没有中文环境下也可以进入。这就是所说的虚拟目录。
忍无可忍，无须再忍。放狗一找，原来这东西还有些来历，此前也并不是这样的。并且有很多人为此而苦恼，甚至干脆用英文系统，眼不见心不烦。
原来这是freedesktop.org为了方便群众搞的xgd-users-dirs，在不同的语言下自动创建一些经常用到的目录。
xdg-user-dirs-update 这个工具会在系统登录阶段运行，它读取配置文件和用户目录信息，并创建用户本地语言版本的常用目录。设置到$(XDG_CONFIG_HOME)/user-dirs.dirs (XDG_CONFIG_HOME defaults to ~/.config)，以便应用程序读取和使用这些目录。
1. 我们可以先将目录都改成英文的。 export LANG=en_US
执行
xdg-user-dirs-gtk-update
这时会弹出一个配置界面，将所有中文的用户目录切换到英文。选中不再提示，确定。
这时，会删除没有内容的用户目录，但有内容的用户目录会保持。并创建相应的英文目录：
Desktop/Download/Templates/Public/Documents/Music/Pictures/Videos
此时，在位置里看到的常用中文目录已经换成英文目录。只需将原中文目录的内容拷贝到相应英文目录，并删除中文目录即可。
然后再执行
export LANG=zh_CN.UTF-8
以显示中文。
如果记不住该命令，很简单。注销。在登录界面选英语，进来后该对话框就会弹出来提示你是否切换用户目录了。切换完了注销，再切换成中文界面，但这时不要切换用户目录了。
2.显示中文，但实际是英文目录
这时，桌面也对应/home/zhouhh/Desktop，但“位置”里面，“主文件夹”，“桌面”点开都对应英文目录。
理想化的解决方案，是看到的目录是中文，但打开的目录是英文。和Windows操作系统一致。这样免得中英夹杂，影响视觉和心情。
其实这也是可以办到的。
点“位置”-&gt;"主文件夹"，打开文件浏览器（Nautilus),
在书签菜单，选编辑书签
这时，可以将各英文用户目录的显示改成中文对应的“桌面”，“文档”，图片 、公共的 、下载、 音乐、 视频等。
改完，在任务栏的“位置”，看到也变成了中文。而打开的目录，却是英文。
这样，终于舒坦了。
3.相关配置 cd /etc/xdg zhouhh@zhh64:/etc/xdg$ ls user* user-dirs.conf user-dirs.defaults zhouhh@zhh64:/etc/xdg$ vi user-dirs.defaults # Default settings for user directories # # The values are relative pathnames from the home directory and # will be translated on a per-path-element basis into the users locale DESKTOP=Desktop DOWNLOAD=Downloads TEMPLATES=Templates PUBLICSHARE=Public DOCUMENTS=Documents MUSIC=Music PICTURES=Pictures VIDEOS=Videos # Another alternative is: #MUSIC=Documents/Music #PICTURES=Documents/Pictures #VIDEOS=Documents/Videos 该文件是xdg-user-dirs-update工具在用户登录时需要读取的目录配置。并根据user-dirs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cdee98dd1396a514b01c9a5c8b24901/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/306ff1f765454976116cd1d471b15fde/" rel="bookmark">
			魔塔教程源代码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我把教程的源代码整理了一下，大部分都已经提供了源代码零积分下载。
这里我说一点这个教程提供的源代码都是基于cocos2d-1.0版本的，今天上传
了一个用cocos2d-2.0制作的完整代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a4cddf1f77d06223adbb99c002b244/" rel="bookmark">
			嵌入式web监控小车文档以及代码开放下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常有人QQ上问我要嵌入式web监控小车的代码，我也懒得发了，这里共享给大家去下载，6分不算多吧，这可是我的毕业设计。
这个压缩包包括实现代码，根文件系统，以及相关文档
http://download.csdn.net/detail/ayangke/5097807
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c8e3e21bcfe0bf361503911de8eb2b/" rel="bookmark">
			c语言那些细节之a&#43;1和&amp;a&#43;1的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先a是一个数组名，当看到这个a与&amp;a时，一般我们的理解都是这个数组的首地址。没错，如果加上打印的话，确实两个值是一样的。
不过&amp;a是整个数组的首地址，a则是数组首元素的地址，虽然值一样，但是意义却不相同。
在此之前有必要先看下c程序在内存中的分布图。
下面来看一个例子吧还是。
示例代码：
#include &lt;stdio.h&gt; int main(int argc, char *argv[]) { int i; int a[]={1, 2, 3, 4, 5}; int s; int *p = (int *)(&amp;a+1); printf(" a = %p\n&amp;a = %p\n", a, &amp;a); for(i = 0; i &lt; 5; i++) printf("a[%d] = %p\n", i, &amp;a[i]); printf(" p = %p\n&amp;p = %p\n&amp;s = %p\n", p, &amp;p, &amp;s); return 0; } 运行结果：
a = 0022FF40 &amp;a = 0022FF40 a[0] = 0022FF40 a[1] = 0022FF44 a[2] = 0022FF48 a[3] = 0022FF4C a[4] = 0022FF50 p = 0022FF54 &amp;p = 0022FF38 &amp;s = 0022FF3C 由上面的运行结果，我们可以知道a和&amp;a的区别了。可得下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30c8e3e21bcfe0bf361503911de8eb2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c246bc674aa5186ad3ad38d0db1f8371/" rel="bookmark">
			什么是图形加速卡（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：http://www.azillionmonkeys.com/qed/accelerator.html
作者：Paul Hsieh
-潘宏 译
-2013年2月
-email: popyy@netease.com
-weibo.com/panhong101
（译注：本文写于2000年左右，很多内容稍显过时。但作为理解GPU发展的历史性、技术性材料，本文真是不可多得）
显示器刷新
最后一个瓶颈，是关于显示器刷新问题的。如我们在显存带宽一节中所说，显卡会消耗一定量的内存带宽用来更新显示器。然而为了避免画面撕裂（Tearing）和闪烁（Flickering），3D应用程序一般会采用双缓冲。也就是在两个帧缓冲之间进行切换的过程中，显示器会使用当前没有被更新的那个帧缓冲（稳定的、可显示的那个缓冲）来刷新自己。如果你想更深入地了解非硬件加速的，用来解决闪烁问题的双缓冲机制，可以阅读我的这篇“无闪烁动画”文章。
在任何情况下，当准备用显存的某一部分刷新屏幕以更新画面前，为了避免画面撕裂，必须等到当前刷新动作（还没完成的）完成后才能继续进行。通常这需要等待“垂直回扫（Vertical Retrace）”的完成。然而该“等待周期”，是由显示器本身的规格决定，而非CPU或者显卡决定，这和处理器标准相比太慢了（比如，在一个72Hz的显示模式下，该速度是平均1/36秒刷新一次）。
下图展示了显示器扫描枪的路径：
如图所示，有些固有的实时事件会按时发生（否则显示器就无法正确工作）。每个事件的长度由显示器的当前模式所决定，这些模式被编好，并放入显存数模转换器中，该转换器通常被称为RAMDAC。RAMDAC必须拥有一定的显存用于在需要时立即执行行刷新（Line Refresh）。有些旧式显卡由于显存带宽限制而无法工作在特定模式下。甚至一些现代显卡也会因严格的显存带宽原因，在高分辨率下（比如1280x1024x24，72Hz）运行缓慢，或根本无法工作。
前文曾提到，VRAM最初用于试图解决带宽问题（允许每周期多次显存访问），但它的成本较高，并且由于其复杂度导致时钟频率受限。较新的解决方案，是简单地将前面刷新时访问到的数据，缓冲（Buffer）到RAMDAC中的一个小的缓存（Cache）中，这样新的行刷新数据访问，就可以和之前访问时的RAMDAC输出，或水平回扫事件，存在时间上的交集。这种方案比较经济，比VRAM方案有更好的伸缩性，但要在技术上达到准确，这需要一个灵敏的显存仲裁器。
一般来说显卡厂商并不会开发精密的显存仲裁器，而只会给予足够大的显存带宽，以满足任何实际的带宽需求。这就导致在特定（经常会重复发生）情况下（比如一个比较大的通过总线传输的数据进入帧缓冲中），画面会产生“闪烁”，因为它无法访问到还没有传输完成的必要数据，以更新屏幕的特定部分。但市场证明了该方案无法被消费者接受，因此显卡厂商要么降低了最大刷新率，要么禁止了高分辨率，都是为了避免这样的显示问题。
过去还有一种方案，就是显示器的“交错模式（Interlaced Mode）”。这种模式下，每次屏幕刷新时只进行隔行刷新，奇数行和偶数行交替进行（NTSC制式的电视就是这种模式）。这降低了一半带宽，但导致了低质量、不稳定的输出。这种方案仍无法被市场接受，从此消失了。
在任何情况下，准确决定翻转帧缓冲的时机都是很重要的。大多数显卡都配有一个内存映射寄存器，用来返回当前正扫描的模拟信号显示行，也可能配有一个标识回扫结束的触发器或中断这种能够被主机监测到的机制。所以很简单：等待命令队列清空，接着等待扫描枪光束抵达屏幕底部，然后就开始翻转帧缓冲（把扫描地址设置为另一个帧缓冲的首地址）。如果显卡的渲染速度大于等于显示器刷新率，就不会对渲染速度产生影响，但在当前（1998）的技术水平下，这基本无法做到，因此高分辨率往往会产生较大的性能波动。
以上这个同步问题很棘手，这促使了厂商Ziff-Davis让两个评测软件（3D WinBench以及他们的一个新的纯应用评测程序）避开了这个同步问题。此行为让我感到很厌恶。Ziff-Davis还有那些对其施压让其就范的显卡公司，难道就不能意识到，完全可以通过适当的架构而不费力地解决该瓶颈吗？就像我们解决遇到的其他那些问题一样。
总之，这里的主旨是尽量避免“回扫等待”。对此我提出过一些实施策略，这里我通过一个例子来概述了我的观点（MS-Word DOC格式，StarOffice也能打开它）。文章的中心思想是：越靠近RAMDAC做帧缓冲翻转，所需等待的时间就越短。另外这些策略也没有什么开销。
最后，为了避免在SGI流水线架构下的各种等待开销，显卡必须必须引入一个三缓冲模式，这在我的“无闪烁动画”文章中有所描述。这当然不是最令人满意的方案，因为专用的纹理显存经常会带来更全面的性能提升。
当然，如果显卡厂商仍然很白痴（比如nVidia）的话，就算三缓冲也并不能解决所有问题。实现三缓冲机制的一个典型错误，就是当两个后备缓冲填充完毕的时候，渲染被暂停以等待前缓冲完成其显示，然后再按照顺序翻转两个后备缓冲，这总是以特定的顺序进行。这种错误的实现方式只会不断地导致暂停而没有根本解决该问题（这让人们错误地以为，未来他们应该需要四缓冲、五缓冲、六十九缓冲...）。
正确的实现会分清楚4种显示缓冲类型：
（1）当前正在显示的；
（2）当前正在填充的；
（3）填充完毕还没显示的；
（4）废弃的或还没填充的。
基本上规则是：显示指针会被设置到（3），然后把之前指向的缓冲设置为（4）。当要找一个新的缓冲来渲染的时候，应该选择（4）或者最长时间没有更新的（3），完成后把缓冲设置为（3）。使用这个规则，显卡或主机都不需要暂停。
以上我们分析了在SGI架构下所有可能产生回扫延迟的可能。然而，延迟渲染（Deferred Render）却产生了更多的延迟可能，这将在后面架构一节进行讨论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc07b6fb2f0d1e285320945a3a18178/" rel="bookmark">
			50多个开源PDF阅读编辑工具汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PDF Editing &amp; Creation: 50+ open source/free alternatives to Adobe Acrobat 文章来源于这里, 版权归原作者所有.
Adobe Acrobat is expensive, but that doesn’t mean you have to live a life without portable documents. What many people don’t realize is that PDF is a Federal Information Processing Standard, which means the specifications behind the format are widely published. Numerous developers take advantage of this fact and create programs that offer effective alternatives to Acrobat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbc07b6fb2f0d1e285320945a3a18178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c48b1d1b2329a1361e9c10b44f44ea84/" rel="bookmark">
			开启Windows server2012中的休眠功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		买了一台HP笔记本，由于硬件优化原因，好几个系统在上面跑都不太理想，最后没办法逼着装了一个WINDOWS SERVER 2012，装上之后现发整体速度还不错，而且自事的HYPER-V虚拟机非常好用，所以就这么用了。
用的时候发现与WIN7之类的系统有很多的差异，最常用的一个休眠功能竟然找不到在哪开启，后来寻思不会是因为是SERVER版本的原因吧，SEVER的东西本来的设计思想是长时间不关机运行，没有过多考虑当桌面系统使用的问题。后来想想也不对，睡眠（等机）功能都有，凭什么没有休眠呢？经过一阵研究，总算搞定，具体的方法如下：
1、打开PowerShell ,输入powercfg /H on启用休眠功能
2、依次打开控制面板-&gt;硬件-&gt;电源选项
3、在左侧的菜单中找到唤醒时需要密码
4、往下看有一些关机设置，但都是不可选的，这时需要先点击一下上面的更改当前不可用的设置链接，这样就可以更改了，把需要的东西勾上吧。 到这一步按Alt+F4已经能看到休眠了，但是通过关机按钮点击后还只有关机和重启两项，网上有一些描述Win8的设置，在Windows server 2012里没有找到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4e145f98fd154791ab293bc4c8f946f/" rel="bookmark">
			java 4种方式读取配置文件 &#43; 修改配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一：采用ServletContext读取，读取配置文件的realpath，然后通过文件流读取出来。 因为是用ServletContext读取文件路径，所以配置文件可以放入在web-info的classes目录中，也可以在应用层级及web-info的目录中。文件存放位置具体在eclipse工程中的表现是：可以放在src下面，也可放在web-info及webroot下面等。因为是读取出路径后，用文件流进行读取的，所以可以读取任意的配置文件包括xml和properties。缺点：不能在servlet外面应用读取配置信息。
具体举例如下：
//ServletContext.getRealPath(name)读取路径
privatevoid test1(HttpServletRequest request, HttpServletResponseresponse)
throwsServletException,IOException {
//response.setContentType("text/html;charset=utf-8");
String path = "/WEB-INF/jdbc_connection.properties"; //读取WEB-INF中的配置文件
String realPath = getServletContext().getRealPath(path);//getServletContext()相当于http://localhost/demo05
//所以后面的path只需要以应用demo/开头具体的部署目录路径即可，如上面的/web-in…
System.out.println(realPath);
InputStreamReader reader =new InputStreamReader(newFileInputStream(realPath),"utf-8");
Properties props = new Properties();
props.load(reader); //load个人建议还是用Reader来读，因为reader体系中有个InputStreamReader可以指定编码
String jdbcConValue = props.getProperty("jdbc_con");
System.out.println(jdbcConValue);
System.out.println("加载src包下的资源------------------------");
path = "/WEB-INF/classes/com/test/servlet/jdbc_connection.properties"; //读取WEB-INF中的配置文件
realPath=getServletContext().getRealPath(path);
System.out.println(realPath);
reader = new InputStreamReader(new FileInputStream(realPath),"utf-8");
props.load(reader); //load个人建议还是用Reader来读，因为reader体系中有个InputStreamReader可以指定编码
jdbcConValue = props.getProperty("jdbc_con");
System.out.println("second::"+jdbcConValue);
}
方式二：采用ResourceBundle类读取配置信息， 优点是：可以以完全限定类名的方式加载资源后，直接的读取出来，且可以在非Web应用中读取资源文件。
缺点：只能加载类classes下面的资源文件且只能读取.properties文件。
/** * 获取指定配置文件中所以的数据 * @param propertyName * 调用方式： * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4e145f98fd154791ab293bc4c8f946f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3df07690094a9cfed46b131088f2c82/" rel="bookmark">
			Linux修改文件时候出现崩溃，产生了一个.swap交换文件,如何修复？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候在用vim打开文件时提示类似以下的信息：
E325: 注意 发现交换文件 ".exportcert.cpp.swp" 所有者: liuchuanliang 日期: Thu Mar 1 17:15:41 2012 文件名: ~liuchuanliang/ftsafe/EnterSafe-Shuttle-Linux-111114/i386/sample2/source/ExportCert/exportcert.cpp 修改过: 是 用户名: liuchuanliang 主机名: liuchuanliang-desktop 进程 ID: 4434 正在打开文件 "exportcert.cpp" 日期: Thu Mar 8 10:56:17 2012 比交换文件新！ (1) 另一个程序可能也在编辑同一个文件。 如果是这样，修改时请注意避免同一个文件产生两个不同的版本。 退出，或小心地继续。 (2) 上次编辑此文件时崩溃。 如果是这样，请用 ":recover" 或 "vim -r exportcert.cpp" 恢复修改的内容 (请见 ":help recovery")。 如果你已经进行了恢复，请删除交换文件 ".exportcert.cpp.swp" 以避免再看到此消息。 交换文件 ".exportcert.cpp.swp" 已存在！ 以只读方式打开([O]), 直接编辑((E)), 恢复((R)), 删除交换文件((D)), 退出((Q)), 中止((A)):
这是因为，在用vim打开一个文件时，其会产生一个filename.swap文件，用于保存数据，当文件非正常关闭时，可用此文件来恢复，当正常关闭时，此文件会被删除，非正常关闭时，不会被删除，所以提示存在.swap文件，此时你可以恢复文件：
vim -r filename.c
恢复以后把.swap文件删掉，在打开时就不会用提示良，注意.swap文件是个隐藏文件。可用：la查看。以.开头的是隐藏文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd0d783a0467d4d6d117596a7268de56/" rel="bookmark">
			dedecms横向登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在index.htm中加入js代码
&lt;!--横向登录开始--&gt; &lt;script language="javascript" type="text/javascript" src="{dede:global.cfg_cmsurl/}/include/dedeajax2.js"&gt;&lt;/script&gt; &lt;script language="javascript" type="text/javascript"&gt; function CheckLogin(){ var taget_obj = document.getElementById('_userlogin'); myajax = new DedeAjax(taget_obj,false,false,'','',''); myajax.SendGet2("{dede:global.cfg_cmspath/}/member/ajax_loginsta.php"); DedeXHTTP = null; } &lt;/script&gt; &lt;!--横向登录结束--&gt; 2、在head.htm中加入js代码:
&lt;script language="javascript" type="text/javascript"&gt;CheckLogin();&lt;/script&gt; 来判断是否登录
3、修改member/ajax_loginsta.php文件，该文件是显示登录成功后的样式。
转载于:https://blog.51cto.com/okowo/1135405
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b33ef4a26d293988f202546d6ce0166/" rel="bookmark">
			TUXEDO配置参数详解 远程客户端配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TUXEDO应用系统的配置
1.1 TUXEDO应用系统的常见配置
配置文件UBBCONFIG介绍
一个TUXEDO应用系统的所有资源都在一个文本文件中进行定义，该文件称为UBBCONFIG，在配置完成后，UBBCONFIG被编译成一个二进制的文件TUXCONFIG.在TUXEDO系统启动时,从该文件中读取系统的配置信息。UBBCONFIG文件类似WINDOWS下的*.INI文件。它包括以下9大部分,我们称之为节,RESOURCES，MACHIENS，GROUPS
这三个节必须的，其他的节是可选的。
RESOURCES(必需): 与整个系统有关的配置信息
MACHINES(必需): 一个TUXEDO应用系统可以跨越多台服务器,在该节中配置与每台服务
器有关的信息
GROUPS(必需): TUXEDO中的服务可被分为多个组,在该节中配置与组有关的信息
SERVERS(可选): 与SERVER有关的信息在该节配置
SERVICES(可选): 与SERVICES有关的信息在该节配置
NETWORK(可选):与网络有关的信息在该节配置
ROUTING(可选) :路由规则在该节配置
NETGROUPS(可选):与网络分组有关的信息在该节配置
名称解释：
TUXEDO应用系统
一个TUXEDO应用系统包括服务端，客户端，服务端安装在服务器上，客户端一般安装在PC机上，从开发角度看，一个TUXEDO应用系统包括服务端程序，客户端程序，一个配置文件。此外，一个TUXEDO应用系统可以部署在一台服务器上，也可以部署在多台服务器上。
SERVER：
服务端程序用C或COBAL编写，每一个程序文件编译成一个相应可执行文件，该可执行文件在运行时称为SERVER，它实际上就是一个进程。每个SERVER都有一个名字，也就是该进程的名字。为与TUXEDO应用系统的服务端区分，我们在本书中，我们用SERVER表示该进程，用服务端表示TUXEDO应用系统的服务端。
SERVICE：
在每个服务端程序中，主要是一个个的函数，在TUXEDO中称这些函数为SERVICE，一般
也称之为服务。在该SERVICE中实现业务逻辑，在客户端中调用这些SERVICE来实现各
种操作，如在前面的例子simpapp中，服务端程序为simpserv.c，它编译成可执行文件
simperv, simpserv就是一个SERVER，该SERVER包括SERVICE：TOUPPER。
下面我们给出一个配置文件的例子：
*RESOURCES
IPCKEY 123456
MASTER simple
UID 0
GID 0
PERM 0666
MAXACCESSERS 100
DOMAINID simpapp
MODEL SHM
LDBAL Y
SCANUNIT 10
SANITYSCAN 12
BLOCKTIME 6
NOTIFY DIPIN
MAXCONV 10
*MACHINES
"MYSYS" LMID="simple"
TUXCONFIG="d:\tuxdemo\pbdemo\tuxconfig"
TUXDIR="d:\tuxedo65"
APPDIR="d:\tuxdemo\pbdemo"
TLOGDEVICE="d:\tuxdemo\pbdemo\TLOG"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b33ef4a26d293988f202546d6ce0166/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6951037669195f0a08b1d01d2b945b0c/" rel="bookmark">
			什么是图形加速卡（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：http://www.azillionmonkeys.com/qed/accelerator.html
作者：Paul Hsieh
-潘宏 译
-2013年2月
-email: popyy@netease.com
-weibo.com/panhong101
（译注：本文写于2000年左右，很多内容稍显过时。但作为理解GPU发展的历史性、技术性材料，本文真是不可多得）
硬件特性和主机模拟
现阶段显卡市场受三个因素影响：价格，对游戏的支持度，以及Benchmark评分。早期PC平台上的图形加速还只局限于2D（伴随着1989年IBM 8514显示标准问世）。但随着DirectDraw、Direct3D（最早叫3DDI）的出现，以及支持3D加速游戏（雷神之锤）的发展，3D显卡开始领军。
别看显卡厂商2D玩得转，面对3D可就为了难。不仅渲染需求复杂一大截，输出模式也增加不少。但幸运的是，对于PC供应商，前段时间以来（大概从1994年开始），大量SGI的3D加速领域专家，已开始由于SGI对PC市场的漠视态度而表现出强烈的不满（同时也对SGI要购买Cray超级计算机的疯狂想法不满）。再加上诸多高端图形公司（比如Kubota，ShowGraphics，以及Convex）先后倒闭，相关人才市场又开始活跃起来。
有的公司（ATI，nVidia，3DFX，Chromatic Research，Rendition）抓住了这个时机，开始招兵买马，攻城夺地，在整个图形市场掀起了一场3D大战。而另一些公司（比如Cirrus，TSENG以及Trident）则损失惨重，失败出局。
总之，很多早期的3D基本问题现今都得到了解决并产品化。下面这个次序不分先后的列表向你展示了3D行业的血泪史：
nVidia NV1（Diamond公司推出的EDGE 3D系列显卡所采用的芯片）使用了特殊的API来加速二次面片（Quadratic Patches）的渲染。然而，这块芯片却自立标准，并且运行缓慢，还申请了专利。这一切注定了它的灭亡（nVidia因此放弃了该方案，走D3D专用显卡路线，并强调显卡品质）。ATI Rage 3D－尽管在市场上表现良好，但它最初版本的架构却不尽如人意，而且还无法正确地进行纹理透视矫正。（Ziff-Davis对于该缺陷的公开评测和宣传对ATI产生了必然的影响。）Virge－如Rage一样，在市场上表现良好，但这主要归功于其低价格。它无法对纹理映射进行3D加速，并且需要非常频繁地和主机进行交互。（消费者对于该产品的失望态度，导致了S3几乎一年的亏本。虽然后来他们对“Savage”架构进行了精简并收到了一些市场反馈，但却是杯水车薪，并在近期被VIA收购。）Matrox Mystique－也没有对纹理映射进行硬件加速，该架构由于主要采用软件渲染，失去了同真3D显卡的竞争力。（Matrox已经重新设计了3D架构并与推出了G系列显卡，完全抛弃了之前的产品。）MPACT媒体处理器－对3D完全设计不足。尽管架构有所创新且功能强大，但并未针对现代3D性能进行优化。（Chromatic被分拆并卖给了ATI和mcc在线。）Pyramid 3D－其超长指令字（VLIW）并不能作为超标量（Superscalar）硬件图形管线的替代品。像MPACT一样，它设计得足够灵活，可以支持的基本特性包括：凹凸贴图、置换贴图、非三角形图元，但不支持行业标准API，所以也就没法产品化。（TriTech已不再支持Pyramid 3D架构。Pyramid 3D已经更名为“BitBoys Oy”，其架构师们早已在开发一个叫做Glaze3D的新架构，但该架构仍差强人意。） 现在消费者都追捧nVidia RIVA 128这样的显卡。它完美支持D3D API，没多余特性，而对于微软的图形要求又毫不含糊。OpenGL仍是二等公民，但越来越多的显卡厂商开始采用它来支持Quake，这让微软也不得不给它留有余地（这是一个重要参考信息）。
基本上，支持透视矫正纹理映射就可以称为一块3D显卡。然而，显卡所支持的特性却越来越丰富，这主要由于厂商竞争加剧，以及大量的软件图形需求，包括：内建三角形装配，mipmap，雾化，双线性、三线性以及各向异性纹理过滤，alpha混合，（边缘）抗锯齿，图像点画/抖动，纹理压缩以及多重纹理。
这些特性在SGI架构下经常被分成一个大的3D流水线的不同阶段。流水线大致如下所示：
我同一些硬件专家进行过讨论，追求3D流水线的最高性能，其实可以归结为“靠门电路解决问题”。举个例子来说，某些特定阶段有必要多周期化（Multicycle），比如透视矫正除法。但是一个除法（或者其近似）可以通过完全流水线化的单独时钟周期来完成。所以除法阶段可以转换成多个部分的除法周期。这虽增加了等待延迟（Latency）但允许吞吐量增加到每时钟周期一个像素。
为了超越每周期一个像素的吞吐量，可以用多条流水线在每个周期计算多个像素。最简单直接的办法就是并行地计算和该像素邻接的一堆像素。这也是nVidia的TNT所使用的方法。然而有些厂商（3DFX）则采取了扫描线交错方式。该方法实际上更简单，因为它可以被分解到多个处理器中（对于后面的内存带宽分解来说也方便一些），但这种方式对于硬件的使用并非高效，因为并非所有阶段都可以被重复，或需要被重复。也就是说很多重复的门电路应该可以重新排布以提高性能。3DFX经常将其标榜为保持“扩展性”的绝佳方案，因为这是一个提高3D性能的快速方案，而不是等待公司重新设计一个架构。（这也是为什么Voodoo架构代替了RIVA成为领头羊，直到遭遇TNT架构。）
三角形装配在输出到扫描线之前，需要花费几个周期进行预计算（排序、增量计算、边界设定）。所以，很容易将其并行化，以很高的速率进行扫描线输出，并将结果缓冲到扫描线队列中。通过这种方式，前面被输出到相应扫描线的三角形就可以被后面输出到这些扫描线的三角形在必要时自然地覆盖掉。这种缓冲方式也可用于补偿未被缓存的纹理源初始访问开销。
最后一个方法，也就是粗暴地增加一个更大的纹理缓存，这只不过是“靠门电路解决问题”的另一个更贴切的例子。其实这也就是门电路数量如此简单的事儿。
硬件端不支持某个渲染特性，经常意味着软件端会在无该特性下继续运行，当然质量会降低一些。来自微软、图形厂商以及软件开发商三方的合力将会提高硬件特性的标准，并让传统桌面PC纳入到图形工作站市场。
像MPACT媒体处理器或者Rendition Verite这样的可编程架构，在产品定型后仍允许在软件中加入一些特性。可惜的是，由于市场并未大量接受这样的产品，这样的产品灵活性也并未被实现。
更新（译注：本文跨越多年，作者不断对其补充更新）：ATI已经增加了多个MPEG加速组件（动态补偿以及IDCT）。nVidia已经增加了蜡板缓冲（译注：或模板缓冲，Stencil Buffer）（一种低成本的基于OpenGL的方法，以用于实现阴影或其他类型的投影）。Matrox增加了凹凸贴图。3DFX以及BitBoys将增加积累缓冲以应付抗锯齿（3DFX管它叫T-Buffer）。ATI、3DFX以及Matrox已经加入TV信号接收能力。高端市场中，3DLabs增加了板载的变换与光照处理（T&amp;L）硬件。这些近期的硬件特性，极具代表性地体现了图形市场的不断创新精神。如3DFX的多重纹理特性所体现出地，所有这些硬件特性终归会被所有厂商所支持。
更新：nVidia和ATI增加了T&amp;L，以及复杂的像素着色器，以支持逐像素凹凸映射以及光照效果。3DFX的T-Buffer已经出了，幸运地受到了好评（特别是对比其竞争对手们通过软件实现的该特性）。但我们还没有看到Matrox的任何动作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9af0d4941e529294c270b132230d513/" rel="bookmark">
			无法从 读取大纲，未安装该文件类型的文本转换程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常遇到打开powerpoint文档时提示：powerpoint无法从XX读取大纲，未安装该文件类型的文本转换程序
这个问题有好多人认为是版本或补丁问题，把该PPT文档的后缀名改一下，即将“.ppt”改成“.pptx”（因为Office 2003和Office 2007生成的文档后缀名是不一样的，Office 2003文档的后缀名是 .ppt，而Office 2007文档的后缀名是 .pptx）
或者说需要安装office 2007 与 2003 兼容包 即可。
但实际上以上的方法都解决不了问题，根本原因是这个PPT使用了个性化特殊模板，因为换到其它电脑上打开时没相应的模板所导致，所以叫这个文件的原作者更改为大众模板后再发给你就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60f4a221d6bd9a4114f0fb23fcea3716/" rel="bookmark">
			python修饰符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修饰符基础——闭包 什么是闭包呢？标准的概念大家可以看wikipedia上的解释 点击打开链接 举个例子： def do_add(base): def add(increase): return base + increase return add do_add函数里嵌套了一个内层函数add，这个内层函数就是一个闭包，其实可以也不用管这个“闭包”的概念，先来看下这种模式解决些什么问题. 调用do_add函数：a = do_add(23)，由于内层的函数add里的逻辑用到了do_add函数的入参，而这时这个入参base绑定了值23，由于do_add函数返回的是函数add，所以这时的a其实就是内部的add绑定了23的函数add；同理可知，b = do_add(44)，这里的b就是内部add绑定了44的函数add，a和b这两个add函数是不相同的，因为内部add绑定的值不同，只是两个函数的模板相同罢了，这时我们执行a(100)得到结果是123，b(100)得到结果是144。这样做有什么用呢？其实可以这样看：我们可以把a = do_add(23)和b = do_add(44)看成是配置过程，23和44是配置信息，a(100)和b(100)根据不同的配置获得不同的结果，这样我们就可以解决开发中“根据配置信息不同获得不同结果”的问题
而修饰符实际上就是闭包一种形式，只是配置过程参数是所修饰的一个函数，并且用@符号代替了a=do_add(23)这样的配置方式，下面看一下修饰符的用法 修饰符用法 修饰符无参数，原函数无参数 import time def timeit(func): def wrapper(): start = time.clock() func() end =time.clock() print 'used:', end - start return wrapper @timeit def foo(): print 'in foo()' foo() 如上代码：对所修饰函数运行时间的进行统计，最后修饰过的 foo() 等价于 foo=timeit(foo) 而timeit返回wrapper，归根到底真正执行的是wrapper
在实际应用中，函数很少没有参数，所以我们看看foo有参数的情况下，修饰符怎么用
修饰符无参数，原函数有参数 import time def timeit(func): def wrapper(args): start = time.clock() func(args) end =time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60f4a221d6bd9a4114f0fb23fcea3716/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9de7dd06f6326c4f488ebf1cfc6e4a3/" rel="bookmark">
			什么是图形加速卡（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：http://www.azillionmonkeys.com/qed/accelerator.html
作者：Paul Hsieh
-潘宏 译
-2013年1月
-email: popyy@netease.com
-weibo.com/panhong101
（译注：本文写于2000年左右，很多内容稍显过时。但作为理解GPU发展的历史性、技术性材料，本文真是不可多得）
主机和显卡的通信
粗略来说，将图形操作从主机传送到显卡，会通过某种命令队列（或者FIFO）来完成。主机端的图形API（比如GDI，DirectDraw/3D/X，或者OpenGL）会被分解为显卡的特定命令。这些命令会被显卡执行，完后以先进先出的方式出队。对命令队列进行写入以及调度，经常会牵扯到对内存映射显卡寄存器，或IO端口的读写。此外，也可能会牵扯写系统内存，以及使用显卡DMA等策略（我相信nVidia和3DLabs，以及Matrox都会这么做）。
早期显卡的瓶颈之一是命令队列经常过短（通常有16个位置，原始ATI Mach64即如此），以至于主机和显卡不能充分并行工作。为此，主机端驱动程序通常可能被阻塞，等待着队列给下一个操作腾出足够位置。现代显卡中，队列的位置都进行了大量扩充，通常都会超过512个。此外，尽管显卡寄存器窗口（译注：寄存器窗口（Register Window）技术用来改善因处理器寄存器有限而造成的公共操作性能问题）已预留了一个小型队列，但仍有一部分显存会被用来当作一个溢出队列（Spill Queue），这实质上是对寄存器窗口队列的一个扩展（我认为S3是这样的）。
有些显卡使用另一个技巧来改善队列访问性能，就是把队列内存映射到连续的内存地址上，这样，显卡将有机会利用主机芯片组的PCI突发传送（Bursting Capabilities）能力（MPACT和3DFX都是这样）。
三角形剔除（Culling）也是越来越重要的显卡特性。对此存在一个争议：剔除应该在主机端执行以减少PCI带宽，还是在显卡中执行以最小化计算开销。问题是很多软件都是自己做剔除（因此不需要显卡驱动或显卡本身帮着弄）。究其原因，是在这些软件中，被渲染的物体往往携带诸多复杂属性，因此提前进行裁剪有利于减少后面牵扯这些复杂属性的计算开销。这也有弊端，因为有些写得比较保守的图形库程序本身也会进行背面剔除，这会导致二次剔除开销。所以，提供某种“渲染前请不要剔除这些三角形”开关，可能非常有用（对！微软，就是在提醒你！）。
对此，我认为nVidia的方案会是：利用AGP的更高吞吐量（这就不算个瓶颈了），把所有数据都丢给显卡，让它做剔除。
通常情况下，显卡会配有一个快速的（在PCI总线情况下足以说快了）帧缓冲，所以若需要，CPU会代替显卡，或者同显卡一道，对显存进行更新。有些显卡，比如TSENG ET6000，实际上会维护一个帧缓冲和PCI总线之间的缓存，这种情况下来自主机的访问可能只需最小的延迟等待（这可能是图形系统中RAM仲裁器的一部分）。因为没有使用任何并行机制（这对于显卡的高性能来说是关键），大家也就不奇怪为何ET6000不是顶级显卡了。
说到主机和显卡并发存取显存，这种技术鲜为使用，因为这需要一个先进的仲裁系统，用来隔离将被用于显卡操作的显存区域。Chromatic的MPACT媒体处理器实际上有这么个仲裁特性，它对于增强Windows DIB（桌面应用程序使用的2D位图数据结构）的性能特别有用。而对于3D性能提升，MPACT存在设计上的问题。但MPACT媒体处理器软件的并行性，可以说在它的时代是最好的。
几乎所有的显卡都有个共性，就是当主机有读写显存之需求时，显卡都要先等待所有积压的图形操作完成，命令队列被清空，才继续进行。这样，也就造成了写显存的额外代价，就是在访问显存的间隔时间中，那些积压的图形操作所产生的总等待时间（Latency）的均值。大多数显卡厂商都认定，减少操作本身的等待延迟才是唯一的解决方案。我不同意此观点。
当前方案有这样一个前提机制来保证：一个复杂的多存取显存仲裁机制并不需要同等复杂的硬件来支持。用个简单的“操作计数器”机制就能搞定了。基本思想是，每当一个图形操作完成，操作计数器（用内存映射寄存器，或者只是显存中的一个值来保存）就递增。实际工作时，显卡驱动程序会保存一个计数的拷贝（用一个主机端计数器影射图形端计数器），该计数就是针对相应内存对象（表面、前缓冲、后备缓冲、Windows位图等等）进行操作，最终完成时的累加值。有了这个值用于计数比较，也有了命令队列长度限制用于避免计数器越界回绕，你就能知道显卡针对某个内存对象，什么时候完成了所有操作（这需要很稳定的硬件和软件以避免显存崩溃而导致死机）。
而我的方案是：减少主机等待延迟，从而提高显存带宽。该方法的一个典型应用情景是：有一些图形操作正在传输，还有一些被积压等待执行，此时主机突然通过PCI发送了一个操作请求过来，接着显卡马上挂起当前动作，并排空内部显存仲裁器（PCI事务必须比其它设备访问内存有更高的优先级）。所以实际上，从显卡角度看，这种方式会强烈冲击性能。然而从主机角度看，直接PCI显存访问在很大程度上，可以说用马上用，不用等了（不像过去，因为过度担心安全性，必须得等到所有积压的操作完成，才能访问显存），这也就减少了主机等待。换言之，在这种方案中，系统在每个周期可以干更多活。
我这办法不错吧？过去我跟行业里的人说过这想法，他们都不以为然，很诧异地觉得我在忽悠。现在不管那些了，反正这些东西都做出来了，也看到它们确实提高性能了，我已经证明了自己。这办法确实有用。可编程显卡，比如MPACT媒体处理器和Rendition的Verite，甚至Matrox GXXX系列，都可以毫无压力地使用我这个方法。如果是通过纯硬件方法而没有用我的办法，那还是做个硬件的操作计数器吧。
最后，我想对前面提到的那个DMA概念，再多说一点。拥有总线控制能力（BUS-mastering）的显卡，可以通过PCI或者AGP总线，在无需CPU插手的情况下，访问非cache的系统内存（需要通过DMA）。使用这种机制进行纹理交换，以及其他内存传输操作，可增强主机和显卡间的并行性。但还得注意，这仍存在一些协调性问题（试想主机怎么能知道当前DMA传输完成？）。关于这一点，我在前面已经讨论过了（最近经常被提到的Permedia 3显卡，就可以把系统内存当作其内存控制器中的L3缓存一样使用——这提高了纹理传输的透明性和效率。比如，如果只需要某张纹理的一部分，那么显卡就可以通过AGP总线以DMA的方式，直接从系统内存里拿走那部分纹理）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3da472df17e0fea421ff9444c67722d2/" rel="bookmark">
			python 内建排序 HOW TO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		list.sort()与sorted() python 有两个内建排序函数：一个是list.sort(),对调用该函数的list进行原地排序；另一个是sorted()，可以对任意迭代器进行排序，返回list类型的序列。二者有两个区别。
第一,list.sort()没有返回值，只对list原地排序；而sorted()将排序后序列作为新list返回，如下实例：
&gt;&gt;&gt; sorted([5, 2, 3, 1, 4]) [1, 2, 3, 4, 5] &gt;&gt;&gt; a = [5, 2, 3, 1, 4] &gt;&gt;&gt; a.sort() &gt;&gt;&gt; a [1, 2, 3, 4, 5] 第二，list.sort()只应用于list，而sorted()可用于任意迭代器，如下实例：
&gt;&gt;&gt; sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'}) [1, 2, 3, 4, 5] 另外，二者都有相同参数：1.key 2.reverse 3.cmp，并且使用方法相同，下面通过sorted()进行详细说明
key参数的使用 基本说明：
key参数指定一个函数，这个函数的实参为每个迭代器的item，经过该函数运算，返回值为每个item中需要进行对比的项（key），如下实例：
&gt;&gt;&gt; sorted("This is a test string from Andrew".split(), key=str.lower) ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] 简单说，key参数值必须是一个函数，且这个函数只有一个参数，并且返回一个key值，作为比较使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3da472df17e0fea421ff9444c67722d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8837e5c06f5ddca5ab8361593a8a96b/" rel="bookmark">
			jQuery实例--Ajax信息的增删改查等操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery实例&lt;/title&gt; &lt;style&gt; &lt;/style&gt; &lt;script type="text/javascript" src="jquery-1.8.2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function(){ //调用加载数据函数 loadstu(); //为添加按钮绑定一个添加动作 $("#aid").click(function(){ $("#fill").show(); $("#myform").show(); }); }); //加载学生信息 function loadstu(){ $.ajax({ url:"./model/action.php?a=index", type:"GET", dataType:"json", success:function(data){ //alert(data); var str=null; for(var i=0;i&lt;data.length;i++){ str+="&lt;tr&gt;"; str+="&lt;td&gt;"+data[i].id+"&lt;/td&gt;"; str+="&lt;td&gt;"+data[i].name+"&lt;/td&gt;"; str+="&lt;td&gt;"+data[i].sex+"&lt;/td&gt;"; str+="&lt;td&gt;"+data[i].age+"&lt;/td&gt;"; str+="&lt;td&gt;"+data[i].classid+"&lt;/td&gt;"; str+="&lt;td&gt;&lt;a href=\"javascript:void(0);\" οnclick='doDel("+data[i].id+",this)'&gt;删除&lt;/a&gt;&lt;/td&gt;"; str+="&lt;/tr&gt;"; } $("#stuid tbody").empty(); $("#stuid tbody").append(str); } }); } //删除函数 function doDel(sid,ob){ //执行ajax删除 if(confirm("确定要删除吗？")) $.ajax({ url:"./model/action.php?a=del", type:"POST", data:{id:sid}, dataType:"json", success:function(res){ //判断是否删除成功 if(res.num&gt;0){ //alert(res.num); $(ob).parents("tr").remove(); } }, error:function(){ alert('error'); } }); } //执行添加 function doAdd(form){ //alert($(form).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8837e5c06f5ddca5ab8361593a8a96b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/479/">«</a>
	<span class="pagination__item pagination__item--current">480/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/481/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>