<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d46a4b5dbbf88fe6254ff60d65447aa/" rel="bookmark">
			java异常处理之Scanner整数接受异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在java异常练习的时候，有这样一个问题： 如题： 1. 写一个方法，从键盘输入一个整数，如果输入的不是整数，则提示输入有误，请重新输入，直到输入正确为止。
分析如下：使用Scanner的nextInt时，如果输入的是一个字符的话，那么会有InputMismatchException异常产生，那么我使用一个while(true)循环，在循环中输入的时候捕获该异常，如果没有异常，那么就是说nextInt能够获取到正确值，那么下一句直接break结束循环，然后打印输出；如果捕获到异常，那么继续循环。
实际运行的时候发现，如果输入了字符，结果会一直输出异常信息（在catch中加入了printStackTrace），想了想，大概和C中类似，输入缓冲区中的字符不能正常获取，所以“卡”在那里，那么如何清空输入缓冲区呢，，C下可以使用fflush(stdin)的方式，Java下没有呀，而使用Scanner的时候传入了System.in，那如果我再new一个Scanner就会指向这个新创建的Scanner。
package cn.lfsenior.throwexercise; import java.util.Scanner; /** * * @author wingsgod * */ public class Demo1 { static Scanner input = new Scanner(System.in); public static void main(String[] args) { while (true) { try { acceptPrint(); break; } catch (Exception e) { // TODO Auto-generated catch block input = new Scanner(System.in); } } } public static void acceptPrint() { System.out.println("请输入一个整数："); int temp = input.nextInt(); System.out.println(temp); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a886d5557b52cb51de688f786b3aa9b/" rel="bookmark">
			WAP上网 AT&#43;CGDCONT=1,&#34;IP&#34;,&#34;cmwap&#34; 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过在modem的高级–额外的初始化命命中加入AT+CGDCONT=1,”IP”,”cmwap”来上wap网。 AT+CGDCONT=1,”IP”,”cmwap” 命令相信很多人都在使用 at+ ：modem命令的标头，有它才执行。如 执行 at 返回一个 ok 表示modem接通正常。 CGDCONT=1 ：定义PDP（分组数据协议类型）上下文，用于规定分组数据协议类型的字符串参数 当你拨*99***1#　就表示用CGDCONT=1 定义的分组数据协议类型来上网。 在后面加上IP 表示使用因特网协议，如果用 PPP 表示点对点协议。如 AT+CGDCONT=1,”PPP”,”cmwap” 点对点协议 wap 接入点。 ：（接入点名称）一个字符串参数，作为逻辑名称用于选择GGSN或外部分组数据网络。如使用cmnet接入点就要改成: AT+CGDCONT=1,”IP”,”cmnet” TCP/IP协议 net 接入点。 AT +CGDCONT=1, “IP”, “internet”; TCP/IP协议 internet 接入点。 相关资料 使用AT命令调试调制解调器 最早生产调制解调器公司是贺氏，后来组建厂家制造调制解调器都与HAYS兼容。大部分通信软件使用菜单来对调制解调器进行配置、检测。有些通信软件要求用户直接发命令给调制解调器，这种情况 下必须使用AT命令。 AT命令集是调制解调器通信接口工业标准，AT命令是调制解调器可以识别并执行命令。AT命令简单，容易掌握，使用它可以配置调制解调器,配合通信软件工作，与远端系统通信，发起或应答一个呼叫。 使用AT命令设置调制解调器时，用户使用通信软件必须提供一个到调制解调器直接连接状态，使你能够从命令行输入所需AT命令。如WINDOWS95下“超级终端”中建立一个直接到串口连接便可使用AT命 令。也可使用ONLAN/PC软件终端方式。不能操作系统下（如：DOS下）直接使用AT命令。 AT命令基本格式为：AT+命令字符及相关设置参数，例如：ATDT0,2043506这个命令表示使用音频拨号方式拨外线电话2043506。AT是前导符，D是命令字符，表示拨号，T这个参数表示用音频拨号。先拨“0，紧随其后逗号表示延迟处理下一个字符，称为拨号修正符。（可以设置S8寄存器值定义延迟时间，默认为2秒。范围为0~65秒）。 应用一：将调制解调器与电话连一起时，当有电话拨入时，振铃之后，对方会听到调制解调器应答风暴声，这确很讨厌。当与调制解调器相连计算机充做终端时，我们用它来向服务器拨号，请求建立通信连接，这时候自动应答功能并不需要。当与调制解调器相连计算机充当主机时，当有连接请求时，调制解调器自动应答功能可以响应请求。这时候自动应答功能是需要。普通调制解调器用户都可以将自动应答功能去掉。下面AT命令可以去掉调制解调器自动应答功能。 ATS0=0（进行设置） AT&amp;W（保存设置） 这个命令用来设置寄存器S0值，调制解调器出厂值为1，允许自动应答；值为0，则禁止自动应答。 应用二：测试调制解调器。当我们拿到一个调制解调器，安装它之前,总想测试一下它好坏。目前我们没有好办法，一般是安装它驱动程序，然后下列顺序单击开始 设置 控制面板，双击调制解调器， 单击诊断 详细信息，计算机开始测试调制解调器，最后给出调制解调器状况报告。这与正式安装一个调制解调器没有什么区别。其实使用AT命令就可以对调制解调器进行测试。 使用超级终端，输入ATDT电话号码，即可听到调制解调器拨号声,能够拨通，那么调制解调器就没问题，否则可能有问题。阅读调制解调器自带说明手册。一般可以找到一个包含自检测命命令表。通常自测命令标识为&amp;Tn(n表示数字)。它们工作详细解释会包含手册中。第一个命令为&amp;T1，从超级终端命令行键入 at&amp;f2 at&amp;t1 我们应该能够看到类似下面信息： CONNEC33600/ARQ/V34/LAPM/V42BIS,接着我们可以键入一连串字符，键入它们时，终端屏幕上应该同时现。 我们键入字符和屏幕显示字符是一致，那么测试，调制解调器没有问题。然后键入“+++”，按下回车键断开连接。测试失败,那么调制解调器硬件确实有问题。所有这些&amp;Tn命令是AT命令集标准 部分，我们可以敲入它并执行。 下面列举一下一般测试命令及其功能： &amp;t0结束测试 &amp;t1初始化模拟回环测试 &amp;t2备用 &amp;t3初始化本数字回环测试 &amp;t4启动远程数字回环测试 &amp;t5禁止远程数字回环测试 &amp;t6初始化远程数字回环测试 &amp;t7初始化带自测试远程数字回环测试 &amp;t8初始化带自测试远程模拟回环测试 应用之三：设置自动拨号。使用远程终端与UNIX服务器连接时，每次都需要拨相同电话号码，建立通信链路与服务器连通，那么能不能把调制解调器设成一加电或一进入远程终端应用程序即开始拨号呢，答案是肯定。 使用如下命令即可实现此功能。 AT&amp;F2（恢复出厂设置） ATS13=24(当S13=8时，一有DTR信号，即开始拨存放Z0中电话码； 当S13=16时，当一加电或复位时,即开始自动拨存放Z0中电话号码, 如S13值为24，则两个功能都有。) AT&amp;Z0=P3506（设置要自动拨电话号码，将其存放Z0中） AT&amp;W（保存设置） 以上列举了AT命令三个小应用，其实你仔细研究它，你会发现多有趣知识，它能够帮你从硬件低层了解调制解调器，使你运用调制解调器更心应手。 简要AT命令介绍 FUNCTIONS AT COMMANDS DETAILS 厂家认证 AT+CGMI 获厂家标识 模式认证 AT+CGMM 查询支持频段 修订认证 AT+CGMR 查询软件版本 生产序号 AT+CGSN 查询IMEI NO.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a886d5557b52cb51de688f786b3aa9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77a34a9df3987ebb98d2df25a2af46d/" rel="bookmark">
			有N级的台阶，你一开始在底部，每次可以向上迈最多K级台阶（最少1级），问到达第N级台阶有多少种不同方式。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有N级的台阶，你一开始在底部，每次可以向上迈最多K级台阶（最少1级），问到达第N级台阶有多少种不同方式。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long LL; const int maxn = 100000 + 10; int dp[maxn]; void solve() { int n,k; scanf("%d%d",&amp;n,&amp;k); for(int i =1;i&lt;=k;i++) dp[i] = 1; for(int i = 2;i&lt;=n;i++) { for(int j = 1;j&lt;=k&amp;&amp;j&lt;=i;j++) { dp[i] = (dp[i]+dp[i-j])%100003; } } printf("%d\n",dp[n]); } int main() { solve(); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7a0c08f615715249ae8bb31460ca77b/" rel="bookmark">
			获取手机的IMSI码,并判断是中国移动\中国联通\中国电信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android--获取手机的IMSI码,并判断是中国移动\中国联通\中国电信 .
TelephonyManager telManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
/** 获取SIM卡的IMSI码
* SIM卡唯一标识：IMSI 国际移动用户识别码（IMSI：International Mobile Subscriber Identification Number）是区别移动用户的标志，
* 储存在SIM卡中，可用于区别移动用户的有效信息。IMSI由MCC、MNC、MSIN组成，其中MCC为移动国家号码，由3位数字组成，
* 唯一地识别移动客户所属的国家，我国为460；MNC为网络id，由2位数字组成，
* 用于识别移动客户所归属的移动网络，中国移动为00，中国联通为01,中国电信为03；MSIN为移动客户识别码，采用等长11位数字构成。
* 唯一地识别国内GSM移动通信网中移动客户。所以要区分是移动还是联通，只需取得SIM卡中的MNC字段即可
*/
String imsi = telManager.getSubscriberId();
if(imsi!=null){
if(imsi.startsWith("46000") || imsi.startsWith("46002")){//因为移动网络编号46000下的IMSI已经用完，所以虚拟了一个46002编号，134/159号段使用了此编号
//中国移动
}else if(imsi.startsWith("46001")){
//中国联通
}else if(imsi.startsWith("46003")){ //中国电信
}
}
备注:1。移动联通2G制式GSM，电信2G制式CDMA，移动3G制式TD-CDMA，联通3G制式WCDMA，电信3G制式CDMA2000。移动4G制式TD-LTE，联通和电信4G制式一样是FDD-LTE
2。国内电信卡比较特殊：
确实，电信的新卡都是国际漫游卡，全都是多IMSI的，
一个CDMA 46003开头 IMSI，目的是国内3G EVDO用；
一个LTE 46011开头 IMSI，国内4G LTE用；
还有一个Vodafone的UMTS IMSI 20404开头，目的是国外UMTS用。
IMSI：国际移动用户识别码（唯一标识），IMSI = MCC + MNC + MSIN，其中MCC是指移动台国家代码（3 位，中国460），MNC是指移动网代码（2 位中国00），MSIN是指移动用户识别号码(10 位 )
IMSI共有15位，其结构如下：
MCC+MNC+MSIN ，（MNC+MSIN=NMSI）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7a0c08f615715249ae8bb31460ca77b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d0eacefcd1b177193549fe99405a9a/" rel="bookmark">
			JAVA集合类实现原理简述-Part1  Map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 HashMap Hashmap的底层数据结构为散列表，底层实现结构为数组和链表，当一个key-val对要插入时，会根据key计算出hashcode，然后映射到数组的某个位置。如果数组的位置已经被占用且发生了冲突。则通过链表地址发来解决这个冲突。
插入过程
put（key,val）,对key进行HASH得到hashcode,通过hashcode得到位置如果未占用，直接将这个key-val存放。 如果发生了冲突，则通过链地址法来解决冲突，从这个位置关联一个链表，在链表的节点上（bucket）上讲key-val存放其中。 取值过程
get（key）,对key进行HASH得到hashcode,通过hashcode在数组上找到这个位置，如果这个 位置上只有一个entry对（即没有关联链表），则直接取出即可。 如果这个位置上有多个entry对，即有关联一个链表，则对这个链表进行遍历，如果entry对的 key等于要查询的key，则将entry对取出。 与HashTable的区别 Hashtable的所有方法都加了synchronized是线程安全的，HashMap是非线程安全的 Hashtable不可以设置Null的key,而HashMap是可以设置为Null的key 单线程时Hashtable速度较慢
通过HashMap达到线程安全目的 我们也可以让HashMap同步 Map m = Collections.synchronizeMap(hashMap); 这样是通过一个互斥的对象锁，来达到线程同步的目的 但这样的实现在并发场景上效率太低 后来concurrent包下的ConcurrentHashMap，通过在数据结构上真正的实现了对高并发的支持
2 TreeMap 线程不安全内部红黑树实现 3 LinkedHashMap 内部的entry&lt; k,v &gt;除了保存当前元素的引入，还保存前一个、后一个元素的引用是从HashMap继承对插入顺序是有序的可实现LRU算法线程不安全 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/441f6cfabb6ac7c6d96836c91bc27a15/" rel="bookmark">
			Java开发相关面试题-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Leo哥遇到过的一些面试题 1 为什么考虑用SSM框架
2 Mybatis的事务是怎么处理的
3 分布式系统的session处理、如果存redis当中，那么存储哪些内容、
4 mysql的having用法
5 对java多线程的了解
6 分布式爬虫任务分配的实现
7 jvm的参数设置相关
8 日志记录过程中的瓶颈问题
9 怎么样应对大规模的日志写入请求的冲击。我一直在围绕怎写入文件做文章。其实把
10 请求转发给kafka异步返回，kafka的消费者自己持久化日志消息
11 除了spring的注解，你还用到哪些特性
12 你们为什么还用ESB企业总线，这种比较沉重的东西
13 了解多线程吗
1 怎么设计一个SOA架构
2 RPC架构和SOA架构的比较
3 了解多线程吗
4 常用的集合类的底层实现
5 HashMap的底层实现
6 分布式事务管理器
7 有没有遇到过什么系统性能问题，是怎么解决的
8 为什么选Zookeeper，应用如何在Zookeeper向应用同步配置的
9 现在有很多开源的分布式事务管理器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/486535eb197502cd6a0aaf48733effd0/" rel="bookmark">
			JAVA设计模式示例-2 抽象工厂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2 抽象工厂 主要是满足当我们的工厂内，需要生产新的类型的产品时的问题，解决办法是引进新的生成线。将N个简单工厂，都通过为一个Factory Producer的类来创建。代码如下：
代码说明：实现一个游戏抽象工厂，具有生产英雄，和生成物品的两个简单工厂。这样我们就可以生产英雄和物品，这两种类型不同的产品了。 Step1 定义生成两种产品类型的抽象工厂
public interface GameFactory { public abstract Goods getGoods(String goodsName); public abstract Hero getHero(String heroName) ; } Step2 定义Hero英雄和Good物品这两种产品，每个产品又有具体的实现规格,如英雄-(PcNj,Timo),物品(Shoes,Sword)
public abstract class Hero { /*英雄必须实现进行攻击的方法*/ public abstract void attack(); }; public class PcNj extends Hero{ @Override public void attack() { System.out.println("皮城女警正在用狙击枪进行攻击"); } } public class Timo extends Hero{ @Override public void attack() { System.out.println("提莫放的蘑菇对敌人进行了伤害"); } } public abstract class Goods { public abstract void cost(); } public class Shoes extends Goods { @Override public void cost() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/486535eb197502cd6a0aaf48733effd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2aeeaad23ad778f3388e404f280bcf6/" rel="bookmark">
			numpy的array和python中自带的list之间相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		a=([3.234,34,3.777,6.33])
a为python的list类型
将a转化为numpy的array: np.array(a)
array([ 3.234, 34. , 3.777, 6.33 ])
将a转化为python的list
a.tolist()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb7e14a84fefade0681e91cd4edf11e/" rel="bookmark">
			linux 开机默认进入命令行模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ﻿﻿ 如果linux系统开机默认进入图形界面，可通过以下方法进行修改：
打开终端，
1.执行命令
sudo vim /etc/inittab 2.在默认的 run level 设置中,可以看到有一行书写如:id:5:initdefault:(默认的 run level 等级为 5,即图形界面)
将id:5:initdefault行的 5 修改为 3 即可。 执行1中命令后按 i 即进入了vim编辑器的insert模式，然后找到对应位置修改内容即可 3.保存文件 按Esc键，然后输入 :wq!回车 4.保存文件后重启系统你就可以看见是启动的命令行界面了，也可以直接执行命令：
reboot 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a91d6f03ed987cb07be8f7e1ec5cec0/" rel="bookmark">
			structs2和lo4j2的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在学习structs2 2.5.5的版本的时候碰到2个问题。第一个网上下的包里面差log4j-core这个包。
虽然程序可以运行，但控制台会报这个错误。
ERROR StatusLogger Log4j2 could not find a logging implementation. Please add log4j-core to the classpath. Using SimpleLogger to log to the console...
在添加了这个包后在再次运行程序。
控制台提示
ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console.
找不到log4j2的配置文件
网上google之。找到文档。原来只要在classpath下的目录添加一个log4j2.xml。就可以了
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Configuration status="warn"&gt; &lt;Appenders&gt; &lt;Console name="Console" target="SYSTEM_OUT"&gt; &lt;PatternLayout pattern="[%-5p] %d %c - %m%n" /&gt; &lt;/Console&gt; &lt;File name="File" fileName="dist/my.log"&gt; &lt;PatternLayout pattern="%m%n" /&gt; &lt;/File&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Logger name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a91d6f03ed987cb07be8f7e1ec5cec0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d7b6cbd1c5d806cfc84dfac99943e46/" rel="bookmark">
			c&#43;&#43; 定义常量的两种方式 和 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用常量的好处就显而易见，用常量的有下面一些好处： 1：增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。
2：如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。
常量是在程序运行中不能被改变的标识符。 C++中定义常量可以用#define 、const 这两种方法。 例如:
#define PRICE 10 //定义单价常量10 const int PRICE = 10; //定义单价常量10 区别： 其中#define是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而constant 则是定义含有变量类型的常量。 一般说来推荐使用constant定义常量，它在编译时会做语法检查。Effective c++ 的条款1中：“尽量用编译器而不用预处理”，因为#define经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。
两者比较：
(1) const 常量有数据类型,而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换,没有类型安全检查,并且在字符替换可能会产生意料不到的错误(边际效应) 。 (2) 有些集成化的调试工具可以对 const 常量进行调试, 但是不能对宏常量进行调试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c99af02dc498c264fc9a46cb748e24b3/" rel="bookmark">
			让JavaScript的Alert弹出框失效的方法禁止弹出警告框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为现在都提倡绿色上网环境，弹出框难免会影响你的心情，所以通过以下代码可将Js弹出框屏蔽掉。
? 1 2 3 4 5 6 7 &lt;script LANGUAGE= "JavaScript" &gt; &lt;!-- window.alert = function (str){ return ; } alert( "不能弹出警示框" ); //--&gt; &lt;/script&gt; 实现思路是对“alert”方法重写，重写的语法为：“旧方法=function(参数){新方法的内容}”。返回值要为“false”，表示不执行任何操作。也可以在地址栏输入：javascript:alert(window.alert=function(str){return;});
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6758ed9db9b892aa2ef392c007cfd873/" rel="bookmark">
			Linux 修改时区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1：使用tzselect设置时区 a 查看当前时区：date -R 系统目前时区是东八区
[root@localhost ~]# date -R Thu, 17 Nov 2016 23:27:24 +0800 b 将时区设置成纽约时间 tzselect =&gt;2(Americas)=&gt; 49(United States) =&gt;1(Eastern Time)，选定纽约时间，再选择1 确认
[root@localhost ~]# tzselect Please identify a location so that time zone rules can be set correctly. Please select a continent or ocean. 1) Africa 2) Americas 3) Antarctica 4) Arctic Ocean 5) Asia 6) Atlantic Ocean 7) Australia 8) Europe 9) Indian Ocean 10) Pacific Ocean 11) none - I want to specify the time zone using the Posix TZ format.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6758ed9db9b892aa2ef392c007cfd873/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2949d42b76f1b6741658d744c9c5823c/" rel="bookmark">
			XMind思维导图使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 51cto视频教程（共5课时 · 1小时37分钟）： http://edu.51cto.com/course/course_id-6060.html
思维导图的结构 思维导图平衡图（向上、向下、顺时针、逆时针）组织结构图（向上、向下）树状图（向右、向左）逻辑图（向右、向左）时间轴（水平、垂直）鱼骨图（头向右、头向左）矩阵（行、列） 思维导图的内容 【中心主题】：位于XMind的中心位置不可拖动，思维导图的开始地方 【自由主题】：可以随意拖动位置的主题 【分支主题】：直接从【中心主题】扩散的一级主题 【子主题】：从【分支主题】、【自由主题】、【子主题】扩散的主题 【超链接】：用于链接 网络、文件（图片、文档等）和主题 【附件】：用于附属任意类型的文件【图片】：用于展示图片， 图片来源可以是来自文件、来自网络、来自剪贴画【图标】：用于显示在子主题文字前面的小图标【标签】：【备注】：【录音】：【概要】：用于总结多个分支【批注】：【外框】：将多个主题圈在一起，矩形、圆角矩形、扇贝形、张力形、波浪形、多边形、圆角多边形【联系】：用于说明两个主题间的关系 操作快捷键 Tab: 添加选中主题的子主题 Enter：添加选中主题的兄弟主题 \： 收缩所有主题 * ：展开所有主题
属性 针对整个XMind的属性：
背景色墙纸彩虹色线条渐变渐变效果 针对一个主题的属性：
外形或边框线条 示例效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e3e4d3884f0afd2a440de8ca9a00d98/" rel="bookmark">
			usb-phy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		usb 的phy 协议发展历程 UTMI * UTMI USB 2.0 Transceiver Macrocell Interace* defines an interface between two IP blocks: the USB Transceiver Macrocell (IP) and the USB Link layer (SIE). The UTMI interface provides functionality for USB peripherals only, not for USB hosts or On-The-Go.
UTMI+ adds host and On-The-Go capabilities to the USB system.
UTMI+ incrementally adds new functionality and interface signals to the Link and PHY. 协议升级到UTMI+之后UTMI就被定义为UTMI LEVEL0 ULPI: UTMI+ Low Pin Interface** The ULPI specification reduces the Link to PHY interface to 12 or 8 signals, with support for all the features needed by USB peripherals, hosts, and OTG.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e3e4d3884f0afd2a440de8ca9a00d98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abec1b0013104f40c4510d8bbdf28834/" rel="bookmark">
			如何安装最精简的ubuntu桌面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Step1 安装ubuntu server 版本(就是只有命令行的系统) Step2 A:安装 最简 Unity Desktop sudo apt-get install --no-install-recommends ubuntu-desktop B: 安装 最简 KDE Desktop sudo apt-get install --no-install-recommends kubuntu-desktop 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b29180ed06973763fd4080dc90fb846c/" rel="bookmark">
			Android Camera的预览回调接口PreviewCallback使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明出处： http://blog.csdn.net/lb377463323/article/details/53338045
首先定义一个类实现Camera.PreviewCallback接口，然后在它的onPreviewFrame(byte[] data, Camera camera)方法中即可接收到每一帧的预览数据，也就是参数data。 然后使用setPreviewCallback()、setOneShotPreviewCallback或setPreviewCallbackWithBuffer()注册回调接口，下面介绍一下这些方法： 1，void setPreviewCallback (Camera.PreviewCallback cb) 一旦使用此方法注册预览回调接口，onPreviewFrame()方法会一直被调用，直到camera preview销毁
注意，onPreviewFrame()方法跟Camera.open()是运行于同一个线程，所以为了防止onPreviewFrame()会阻塞UI线程，将Camera.open()放置在子线程中运行。
2，void setOneShotPreviewCallback (Camera.PreviewCallback cb) 使用此方法注册预览回调接口时，会将下一帧数据回调给onPreviewFrame()方法，调用完成后这个回调接口将被销毁。也就是只会回调一次预览帧数据。 3，void setPreviewCallbackWithBuffer (Camera.PreviewCallback cb) 它跟setPreviewCallback的工作方式一样，但是要求指定一个字节数组作为缓冲区，用于预览帧数据，这样能够更好的管理预览帧数据时使用的内存。它一般搭配addCallbackBuffer方法使用，伪代码如下：
byte[] mPreBuffer = new byte[size];//首先分配一块内存作为缓冲区，size的计算方式见第四点中 mCamera.addCallbackBuffer(mPreBuffer); mCamera.setPreviewCallbackWithBuffer(Camera.PreviewCallback cb); mCamera.startPreview(); @Override public void onPreviewFrame(byte[] data, Camera camera) { if (mPreBuffer == null) { mPreBuffer = new byte[size]; } mCamera.addCallbackBuffer(mPreBuffer);//将此缓冲区添加到预览回调缓冲区队列中 } setPreviewCallbackWithBuffer需要在startPreview()之前调用，因为setPreviewCallbackWithBuffer使用时需要指定一个字节数组作为缓冲区，用于预览帧数据，所以我们需要在setPreviewCallbackWithBuffer之前调用addCallbackBuffer，这样onPreviewFrame的data才有值。
总结一下，设置addCallbackBuffer的地方有两个，一个是在startPreview之前，一个是在onPreviewFrame中，这两个都需要调用，如果在onPreviewFrame中不调用，那么预览帧数据就不会回调给onPreviewFrame了
4，void addCallbackBuffer (byte[] callbackBuffer) 添加一个预分配的缓冲区到预览回调缓冲区队列中。应用程序可一添加一个或多个缓冲器到这个队列中。当预览帧数据到达时并且缓冲区队列仍然有至少一个可用的缓冲区时，这个 缓冲区将会被消耗掉然后从队列中移除，然后这个缓冲区会调用预览回调接口。如果预览帧数据到达时没有剩余的缓冲区，这帧数据将会被丢弃。当缓冲区中的数据处理完成后，应用程序应该将这个缓冲区添加回缓冲区队列中。 对于非YV12的格式，缓冲区的Size是预览图像的宽、高和每个像素的字节数的乘积。宽高可以使用getPreviewSize()方法获取。每个像素的字节数可以使用ImageFormat.getBitsPerPixel(mCameraParameters.getPreviewFormat()) / 8获取。 对于YU12的格式，缓冲区的Size可以使用setPreviewFormat(int)里面的公式计算，具体详见官方文档。 这个方法只有在使用setPreviewCallbackWithBuffer(PreviewCallback)时才有必要使用。当使用setPreviewCallback(PreviewCallback) 或者setOneShotPreviewCallback(PreviewCallback)时，缓冲区会自动分配。当提供的缓冲区如果太小了，不能支持预览帧数据时，预览回调接口将会return null，然后从缓冲区队列中移除此缓冲区。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e6ee253d070437220f4725e48f65601/" rel="bookmark">
			Java 8 中 Date与LocalDateTime、LocalDate、LocalTime互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 8中 java.util.Date 类新增了两个方法，分别是from(Instant instant)和toInstant()方法
// Obtains an instance of Date from an Instant object.
public static Date from(Instant instant) {
try {
return new Date(instant.toEpochMilli());
} catch (ArithmeticException ex) {
throw new IllegalArgumentException(ex);
}
}
// Converts this Date object to an Instant.
public Instant toInstant() {
return Instant.ofEpochMilli(getTime());
}
这两个方法使我们可以方便的实现将旧的日期类转换为新的日期类，具体思路都是通过Instant当中介，然后通过Instant来创建LocalDateTime（这个类可以很容易获取LocalDate和LocalTime），新的日期类转旧的也是如此，将新的先转成LocalDateTime，然后获取Instant，接着转成Date，具体实现细节如下：
// 01. java.util.Date --&gt; java.time.LocalDateTime
public void UDateToLocalDateTime() {
java.util.Date date = new java.util.Date();
Instant instant = date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e6ee253d070437220f4725e48f65601/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5850faaeda111bcb120330a9f52524d1/" rel="bookmark">
			cs231n课程作业assignment1（SVM）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标签（空格分隔）： 机器学习
前言： 以斯坦福cs231n课程的python编程任务为主线，展开对该课程主要内容的理解和部分数学推导。 该课程相关笔记参考自知乎-CS231n官方笔记授权翻译总集篇发布 课程材料和事例参考自-cs231n
SVM分类器简介： SVM-支持向量机(Support Vector Machine)，是一个有监督的线性分类器 线性分类器：在本模型中，我们从最简单的函数开始，一个线性映射： f(xi,W,b)=Wxi+b 这个公式就是平时最常见到的线性函数，常为一维线性函数（即 W 为一维的）。当这种函数扩展到多维度的情况下时就是我们SVM要面临的情况。首先我们要做的处理是将每个图像数据都拉长为一个长度为D的列向量，大小为 [D * 1] 。其中大小为 [K * D] 的矩阵W和大小为 [K 1] 列向量 b 为该函数的参数。以CIFAR-10为例，CIFAR-10中一个图像的大小等于 [32*32*3] ,含了该图像的所有像素信息，这些信息被拉成为一个 [3072 * 1] 的列向量*， W 大小为 [10*3072] ， b 的大小为 [10*1] 。因此，3072个数字（素数值）输入函数，函数输出10个数字（不同分类得到的评分）。参数 W 被称为权重（weights）。 b 被称为偏差向量（bias vector）。 理解线性分类器 线性分类器计算图像中3个颜色通道中所有像素的值与权重的矩阵乘，从而得到分类分值。根据我们对权重设置的值，对于图像中的某些位置的某些颜色，函数表现出的得分即对该点的接受程度。例如对于飞机来说，飞机图片中包含有大量的蓝色天空，白色的云彩以及白色的飞机，那么这个飞机分类器就会在蓝色通道上的权重比较多，而在其他通道上的权重就较少,正如笔记中指出的：
一个将图像映射到分类分值的例子。为了便于可视化，假设图像只有4个像素（都是黑白像素，这里不考虑RGB通道），有3个分类（红色代表猫，绿色代表狗，蓝色代表船，注意，这里的红、绿和蓝3种颜色仅代表分类，和RGB通道没有关系）。首先将图像像素拉伸为一个列向量，与W进行矩阵乘，然后得到各个分类的分值。需要注意的是，这个W一点也不好：猫分类的分值非常低。从上图来看，算法倒是觉得这个图像是一只狗。
现在考虑高维度情况：还是以CIFAR-10为例，CIFAR-10中的图片转化成一个向量（3072维）后，就是一个高维度问题，而一个向量（3色通道转化而来）可以看作是3072维空间中的一个点，而线性分类器就是在高维度空间中的一个超平面，将各个空间点分开。如图所示：
图像空间的示意图。其中每个图像是一个点，有3个分类器。以红色的汽车分类器为例，红线表示空间中汽车分类分数为0的点的集合，红色的箭头表示分值上升的方向。所有红线右边的点的分数值均为正，且线性升高。红线左边的点分值为负，且线性降低。
目标：而我们要做的就是寻找一个W和一个b,使得这个超平面能很好的区分各个类。寻找方法就是不停的改变w和b的值，即不停的旋转平移，直到它使分类的偏差较小。
SVM的组成： 图像数据预处理：在上面的例子中，所有图像都是使用的原始像素值（从0到255）。在机器学习中，对于输入的特征做归一化（normalization）是必然的。在图像处理中，每个像素点可以看作是一个简单的特征,在一般使用过程中，我们都先将特征“集中”，即训练集中所有的图像计算出一个平均图像值，然后每个图像都减去这个平均值，这样图像的像素值就大约分布在[-127, 127]之间了，下一个常见步骤是，让所有数值分布的区间变为[-1, 1]。
损失函数（loss function）：如何评判分类器的偏差就是当前的问题，解决这问题的方法就是损失函数: Li=∑j≠yimax(0,sj−syi+Δ) 这个函数得到的就是当前分类的偏差值。
举例：用一个例子演示公式是如何计算的。假设有3个分类，并且得到了分值s=[13,-7,11]。其中第一个类别是正确类别，即 yi=0 。同时假设 Δ 是10。上面的公式是将所有不正确分类加起来，所以得到两个部分： Li=max(0,−7−13+10)+max(0,11−13+10) 可以看到第一个部分结果是0，这是因为[-7-13+10]得到的是负数，经过函数处理后得到0。这一对类别分数和标签的损失值是0，这是因为正确分类的得分13与错误分类的得分-7的差为20，高于边界值10。而SVM只关心差距至少要大于10，更大的差值还是算作损失值为0。第二个部分计算[11-13+10]得到8。虽然正确分类的得分比不正确分类的得分要高（13&gt;11），但是比10的边界值还是小了，分差只有2，这就是为什么损失值等于8。简而言之，SVM的损失函数想要正确分类类别的分数比不正确类别分数高，而且至少要高。如果不满足这点，就开始计算损失值。 那么在这次的模型中，我们面对的是线性评分函数（f(x_i,W)=Wx_i），所以我们可以将损失函数的公式稍微改写一下： Li=∑j≠yimax(0,wTjxi−wTyixi+Δ) 其中w_j是权重W的第j行，被变形为列向量。然而，一旦开始考虑更复杂的评分函数f公式，这样做就不是必须的了。 正则化(Regularization):上面损失函数有一个问题。假设有一个数据集和一个权重集W能够正确地分类每个数据（即所有的边界都满足，对于所有的i都有）。问题在于这个W并不唯一：可能有很多相似的W都能正确地分类所有的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5850faaeda111bcb120330a9f52524d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7100ffcd27bfe105d667f0ce4fec42b4/" rel="bookmark">
			java8前后对Collections集合排序操作对比，以及java8版本后的使用lambda对集合Collections操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在java8之前的排序,Collections.sort()中的对象要实现Comparable接口，或者匿名内部类的方式，有些繁琐，如下
public class SortTest { public static void main(String[] args) { List&lt;String&gt; lists = new ArrayList&lt;String&gt;(); lists.add("5"); lists.add("2"); lists.add("9"); //lists中的对象String本身含有compareTo方法，所以可以直接调用sort方法，按自然顺序排序，即升 序排序 Collections.sort(lists); } 当list中存放的是对象时，对象要实现Comparable接口或者匿名内部类的方式
定义A和B两个对象，其中A对象用实现接口方式，B对象匿名内部类方式
class A implements Comparable&lt;A&gt;{ private String name; private Integer order; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getOrder() { return order; } public void setOrder(Integer order) { this.order = order; } @Override public String toString() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7100ffcd27bfe105d667f0ce4fec42b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d4ca997cf0bce19b91a832c37dbcf32/" rel="bookmark">
			C语言_“/”和“%”运算符详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言_“/”和“%”运算符详解：
除法运算符"/"：
二元运算符，具有左结合性。参与运算的量均为整型时，结果为整型，舍去小数。如果运算量中有一个为实型，结果为双精度实型。除号的正负取舍和一般的算数一样，符号相同为正，相异为负。例如：
5/2=2，1/2=0
5/2.0=2.5 取模运算符"%"：
二元运算符，具有左结合性。参与运算的量均为整型。并且参与运算的量可以为负数。取模运算的结果等于两个数相除后的余数。
例如：5%2=1，1%2=1
5%2.0和5.0%2//error C2297: “%”: 非法，右操作数包含“double”类型
int a = 23%-3;//a = 2
int b = -23%3;//b = -2//注明：求余符号的正负取舍和被除数符号相同
当前面的数小于后面的数时，其实求余运算可以看成(如下)，如果a&lt;b的话，这样的商为0,余数就是a
a%b=a-(int)(a/b)*b 1%2=1 2%5=2 a % b 这个关系表达式a%b == a-(int)(a/b)*b 是这么解释的：先运算（a/b)然后a-((a/b的值)乘以b) 例1. 50%2
50除以2=25
结果为整数，则取值为0 （原因就是50除以2的值是整数，余数为0） 例2. 7%2
7除以2=3.5
则还是用3乘以2=6
再用7-6，结果就是余数 1
C语言中，任意一个正整数对1求余结果为0还是1？是0，如24%1=0
注意：
Java中的/和C、C++中的/在计算结果、正负判断上是相同的；Java中的%虽然在结果的正负判断上和C、C++中是相同的，但是Java中的%的操作数允许小数出现，但是C、C++中却规定参与运算的量必须为整数。
Java： System.out.println(5.5%1.0); //right//0.5
C++： cout&lt;&lt;5.5%1.0&lt;&lt;endl; //error
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36a8d6c749325bc2beb932888a57393b/" rel="bookmark">
			宏定义与宏替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. c /c++语言中使用宏的主要目的主要有 3 个： 1. 提高代码的可读性； 把用到的常量定义成有意义的名字； 2. 无需函数调用，运行效率高； 对于一些简单的操作，无需调用函数，虽然编程是强调模块化，但是函数调用时，需要保护现场和恢复现场。这些都需要耗时。对于复杂的操作来讲，这些耗时可以不计，但是对于简单的操作，则效率低下。利用宏来代替简单的操作，则可以提高程序的运行效率。 3. 可维护行好； 对于用得比较多的常量或者简单操作，一旦需要修改，则只需要修改宏定义处，不需要逐条修改。
二. 宏定义命令 ： #define 1 . #define命令主要是将一个标识符替换为一个字符串，该标识符称为宏名，被替换的字符串被称为替换文本。 2. 用法： 主要有两种格式，一个是简单的宏定义，另一个是带参数的宏定义； 简单的宏定义： #define &lt;宏名&gt; &lt;替换文本&gt; 例： #define pi 3.1415 带参数的宏定义：#define &lt;宏名&gt; （&lt;参数列表&gt;） &lt;宏体&gt; 例： #define A(x) x
三. 宏替换 当宏定义好后，在程序中使用宏名就称为宏替换。当程序进行编译时实际上经过了预处理，编译（生成中间代码，即从源程序翻译为中间语言，即汇编），汇编（将汇编语言翻译成机器代码，即二进制代码），链接（将目标文件生成 .exe文件）。宏替换就发生在预处理（也叫预编译）阶段，也就是说在编译之前（生成二进制文件之前）就已经完成了文本的替换工作。 关于预处理主要完成的工作是： 1.文件包含，将#include包含的文件找到，并在#include处进行展开； 2.条件编译，根据#if #ifdef 等编译命令及其后的条件，将源程序的一部分包含进来或排除在外，通常把排除在外的语句换成空行。 3.宏展开，将程序中所用到的宏展开成宏定义的替换文本。经过宏展开之后的程序与之前的源程序的只是简单的文本替换，并无计算功能。这是理解宏的要点。 四. 使用宏要注意的问题 1.使用简单宏出现的问题
#include&lt;stdio.h&gt; #define n 2+2 int main() { int a = 0; a = n * n; return 0; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36a8d6c749325bc2beb932888a57393b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a46d2966499bbe368c0cd561a2da0a78/" rel="bookmark">
			Android 二维码ZXing使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二维码 (QRCode)：最早是日本的一家公司，所定义的一个编码标准，全称 Quick Response Code。它通过在一个矩形区域内使用黑白两种像素来进行编码，它具有高纠错性、高可用性、高识别性。
现在二维码在世界上的使用非常常见，很多app都把它作为信息传递的方式。而且使用起来也非常的方便。也正是因为手机的普及，二维码才可以去广泛传播
二维码的实现和解析是非常复杂的，但是现在有很多的第三方的库已经将这样一个解析的过程封装起来了，而开发者只需要调用其封装好的API即可完成二维码的生成和解析。
这样的二维码的第三方有很多，做的比较出色的那就是ZXing。
ZXing是一个开放源码的，用Java实现的多种格式的1D/2D条码图像处理库，它包含了联系到其他语言的端口。ZXing可以实现使用手机的内置的摄像头完成条形码的扫描及解码。
ZXing的项目地址：https://github.com/zxing/zxing
首先，打开GitHub项目地址，下载项目
这个项目非常大，有120多兆，然而这并没有什么卵用，因为ZXing的功能是非常强大的，不仅仅是对扫描二维码，还可以扫描很多其他的编码，同时也不光在Android上可以使用，在其他比如JavaSE，JavaScript等很多平台上都可以使用，所以这样一个很庞大的源代码，我们很难去对他进行使用，所以必须对这个源代码进行精简。也就是把没有的给干掉。
当然，网上也有很多人，把仅仅在Android 端的编码，解码，扫码部分的工能代码抽取了出来，来作为Android 端的一个库来使用。不过需要注意的是，大部分都基于ZXing旧的版本精简的，很多功能已经过时了。
这里我已经为大家精简好了：http://download.csdn.net/detail/a704225995/9693642
打开AndroidStudio，创建新的项目，并导入库文件，开始开发。
1.创建布局文件
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.example.smart.newapp.MainActivity"&gt; &lt;Button android:id="@+id/main_btn_scan" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="扫一扫!" android:onClick="scan" /&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="扫描结果：" /&gt; &lt;TextView android:id="@+id/main_tv_scan_result" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="18sp" /&gt; &lt;EditText android:id="@+id/main_et_input" android:layout_width="match_parent" android:layout_height="wrap_content" android:textSize="16sp" android:hint="输入生成二维码的文字" /&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="点击生产二维码" android:onClick="makeQRCode" /&gt; &lt;CheckBox android:id="@+id/main_cb_is_add_logo" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="是否添加Logo" /&gt; &lt;ImageView android:id="@+id/main_iv_qrcode" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a46d2966499bbe368c0cd561a2da0a78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/523b715e5c02bc7117dc94a3dca04d2c/" rel="bookmark">
			UTC时间与北京时间相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法 时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。
public class HomeController : Controller { public ActionResult Index() { //本地时间(北京时间) DateTime dt = Convert.ToDateTime("2016-06-11 23:59:59"); //TimeZone类表示时区，TimeZone.CurrentTimeZone方法：获取当前计算机的时区。 TimeZone tz = TimeZone.CurrentTimeZone; //获取当前计算机的时区与utc时间的时间差（北京时间和utc时间相差8个小时） TimeSpan ts = tz.GetUtcOffset(dt); //将当前计算机所在时区的时间(即:北京时间) 转换成UTC时间 DateTime dtGMT = tz.ToUniversalTime(dt); //将UTC时间转换成本地时间 DateTime localtime = tz.ToLocalTime(dtGMT); return View(); } } 第二种方法 public class HomeController : Controller { public ActionResult Index() { //本地时间(北京时间) DateTime dt = Convert.ToDateTime("2016-06-11 23:59:59"); //将北京时间转换成utc时间 （北京时间是utc时间+8小时，所以此时utc时间应该是 2016-06-11 15:59:59） DateTime utcNow = dt.ToUniversalTime(); //将utc时间转换成秒 (即将1970-01-01 00:00:00 到 2016-06-11 15:59:59的时间转换成秒) double utc = ConvertDateTimeInt(utcNow); //将秒数转换成北京时间 (其实就是将utc时间转换成北京时间),所以又得到2016-06-11 23:59:59 DateTime dtime = ConvertIntDatetime(utc); return View(); } /// &lt;summary&gt; /// 将时间转换成秒(这个秒是指1970-1-1 00:00:00 到你指定的时间之间的秒数) /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/523b715e5c02bc7117dc94a3dca04d2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fbb2b9aabc1cd4d0020776399e11c42/" rel="bookmark">
			手机的IMEI、MEID、ICCID、UDID、IMSI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近的项目比较关注Android 手机的IMEI、IMSI 标识信息，以下是两个比较简明的解释：
IMEI (International Mobile Equipment Identity)是国际移动设备身份码的缩写，国际移动装备辨识码，是由15位数字组成的"电子串号"，它与每台手机一一对应，而且该码是全世界唯一的。每一部手机在组装完成后都将被赋予一个全球唯一的一组号码，这个号码从生产到交付使用都将被制造生产的厂商所记录。
IMEI是区别移动设备的标志，储存在移动设备中，可用于 监控被窃或无效的移动设备。IMEI可用移动终端设备通过键入“*#06#”查得（不同厂商的手机所需输入的内容不同，同一厂商不同手机所需输入的内容也可能不同）。其总长为15位，每位数字仅使用0～9的数字（含义见下文）。 IMEI俗称“串号”，存储在手机的EEPROM（俗称“码片”）里，熟悉并了解这个号码对我们今后识别手机会起到非常大的作用。首先TAC码（IMEI的前六位数字）前三位在不同的时期会发生变化，而且即使同一部手机在不同的时期也会有不同的TAC码，如大家最熟悉的8210升级8250。再如 爱立信的同一型号手机T39MC在不同地区的地方亦会有不同的号码： 大陆行货为520406， 香港则为520407。 IMEI为TAC + FAC + SNR + SP。
IMEI码由GSM（全球移动通信协会）统一分配，授权BABT（英国通信认证管理委员会）审受。
修改工具：EasyIMEIChanger
MEID Mobile Equipment IDentifier（MEID）是全球唯一的56bit移动终端标识号。标识号会被烧入终端里，以后可以被修改。可用来对移动式设备进行身份识别和跟踪。由于ESN号段是有限的资源，基本上耗尽，可能还有少量回收利用的号段，所以制定了56位的MEID号段，用来取代32位的ESN号段。MEID主要分配给CDMA制式的手机。
MEID的格式： 如上图所示，MEID由14个十六进制字符标识，第15位为校验位，不参与空中传输。
RR：范围A0-FF，由官方分配 XXXXXX：范围 000000-FFFFFF，由官方分配 ZZZZZZ：范围 000000-FFFFFF，厂商分配给每台终端的流水号 C/CD：0-F，校验码 MEID号码的查看，没有一个通用的方法，由各手机制造商自己设置。可以通过查看手机说明书得到查看MEID号码的方法。 相关修改工具：MEID ESN一键修改工具等
ICCID ICCID（Integrate circuit card identity） 集成电路卡识别码（固化在手机SIM卡中）
ICCID为IC卡的唯一识别号码，共有20位数字组成，其编码格式为：XXXXXX 0MFSS YYGXX XXXXX。分别介绍如下： 前六位运营商代码：中国移动的为：898600；中国联通的为：898601。
有不少丢友通过iccid找回方法找回了自己的iphone，简单的描述就是当窃贼盗取手机之后进行刷机激活，会将手机卡的iccid上传到服务器，通过某种渠道可以查询到刷机时间和iccid，通过运营商解析号码从而了解到手机的去向。（但此方法涉嫌泄漏隐私）
另外一个E文的解释也比较清楚：
What is the difference between ICCID, IMSI and IMEI numbers? IMSI = International Mobile Subscriber Identity. This is a unique identifier that defines a subscriber in the wireless world, including the country and mobile network to which the subscriber belongs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fbb2b9aabc1cd4d0020776399e11c42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92c1b65b511e6d26a38dc61c6ba6ca88/" rel="bookmark">
			xcode中的.h和.m文件分别是什么意思？各有什么用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.h 表示头文件，用来声明各种成员变量，方法，属性之类的。在import的时候用头文件。 .m 主要用来实现.h 里声明的方法。举个例子，如果要写一个方法，你要在.h里先声明： － （void）myMethod ; 然后在.m 里具体实现： - (void) myMethod{ NSLog(@"This is my new method"); }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd940d9f26a96856df0c74b9a54aefd9/" rel="bookmark">
			JSONObject 的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import net.sf.json.JSONObject; public static void main(String[] args) { Map map=new HashMap(); map.put("我","妹"); map.put("你","妹"); map.put("他","妹"); JSONObject json = JSONObject.fromObject(map); System.out.println(json); } 輸出的結果 {"我":"妹","你":"妹","他":"妹"} 首先一个javabean对象
public class Student { private int id ; private String name; private int age; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd940d9f26a96856df0c74b9a54aefd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/528750b287c5f86abc7de57a08edea2d/" rel="bookmark">
			搞懂移动端网页中viewport、retina、高清图、dp单位等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直以来，web移动端都有这么几个问题困扰着我：
单位太多，除了px、rem，其他单位到底啥意思？ 设计师经常会问前端，我到底按照什么尺寸出设计稿？
高清图怎么做出来的？
边框1px，为什么在不同手机中粗细完全不同？
妈蛋，为何移动端总要在meta中width=device-width, initial-scale=1…写这么一句
什么是viewport？
我相信我的问题也困扰着你，且听我娓娓道来… 一、单位 先来罗列下学习移动页面重构的过程中可能看到过迷糊过放弃过的一些单位：
px、pt、pc、sp、em、rem、dp、dip、ppi、dpi、ldpi、mdpi、hdpi、xhdpi、xxhdpi……
接下来分类给大家介绍下：
① 什么是绝对长度单位？什么是相对长度单位？
② 什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？
③ 什么是ppi、dpi、dp、dip、sp、px？他们之间的关系是什么？
④ 什么是mdpi、hdpi、xdpi、xxdpi？
⑤ dpi和转换参数的关系？
⑥dpr是什么？
（1）什么是绝对长度单位？什么是相对长度单位？
绝对长度单位：in（inch英寸）、cm（厘米）、mm（毫米）、pt（磅）、pc（pica）。网页中应用比较少。
相对长度单位：是网页设计中使用最多的长度单位，包括px、em、rem等。
（2）什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？
屏幕尺寸：指屏幕的对角线的长度，单位是英寸，1英寸=2.54厘米。常见的屏幕尺寸有2.4、2.8、3.5、3.7、4.2、5.0、5.5、6.0等。
屏幕分辨率：指在横纵向上的像素点数，单位是px，1px=1个像素点。一般以纵向像素*横向像素来表示一个手机的分辨率，如1960*1080。（忽略图片中的蓝色点，主要看红色点）
屏幕像素密度：屏幕上每英寸可以显示的像素点的数量，单位是dpi或ppi。在单一变化条件下，屏幕尺寸越小、分辨率越高，像素密度越大，反之越小。
最明显的就是iPhone 3GS和iPhone 4的区别。屏幕尺寸一样，屏幕分辨率相差一倍，屏幕像素密度也相差一倍。
计算像素密度的公式：
勾股定理算出对角线的分辨率：√(1920^2+1080^2)≈2203px
对角线分辨率除以屏幕尺寸：2203/5≈440dpi。
（3）什么是ppi、dpi、dp、dip、sp、px？
ppi和dpi：屏幕上每英寸可以显示的像素点的数量，即屏幕像素密度。ppi和dpi是同一个概念，Android比较喜欢使用dpi，IOS比较喜欢使用ppi。
dp、dip：都是密度独立像素，可以想象成是一个物理尺寸，使同样的设置在不同手机上显示的效果看起来是一样的。
（如图所示蓝色点，虽然不同分辨率的手机，但是其物理大小一样）
px：将显示器分成非常细小的方格，每个方格就是一个像素（上图所示红色点）。从上图可以看出不同屏幕下的每个px大小是不一样的。
（4）什么是mdpi、hdpi、xdpi、xxdpi？
Google官方指定按照下列标准区分不同设备的dpi：
苹果的区分则更为简单：非高清屏、高清屏、超高清屏。（dpi值越大越清晰）
（5） dpi和转换参数的关系？
dpi我们都知道，是指像素密度；转换参数是指，dp与px之间的转换系数。
如下图，dp指蓝色块，px指红色块，很明显密度更大的右图中每个dp含有的px个数更多。转换参数 = px / dp （公式自己总结，可以忽略），可以得出结论：dpi密度越大，转换参数越大。
根据上面得出结论，dpi越大的，转换参数就会越大，例如下图中160dpi，对应的转换参数为“1x”；而240dpi，为“1.5x”。
具体转换参数1x，1.5x等如何算出来的，你可以不用理会，只要知道xxxdpi对应下图哪种系列的转换参数即可。
转换参数的作用，举个栗子：
在Android中，规定以160dpi的转换参数是1x，那么1dp=1px。如果密度是320dpi参数属于2x，则1dp=2px，以此类推。
（6）dpr是什么？
要了解dpr，先要知道物理像素和设备独立像素。
物理像素：
其实就是指设备最小像素点，其实就是下图中的红点，原谅我总用一张图。
设备独立像素：
就是下图蓝点，和dp有点像，但是概念不要混淆。它也是一样的，不同设备物理大小总是一样。
在不同的屏幕上(普通屏幕 vs retina屏幕)，设备独立像素所呈现的大小(物理尺寸)是一致的，不同的是1个设
备独立像素（蓝点）所对应的物理像素（红点）个数是不一致的。
在普通屏幕下，1个设备独立像素 对应 1个物理像素(1:1)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/528750b287c5f86abc7de57a08edea2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04ea545048ddd6fefdfd957deb3798d6/" rel="bookmark">
			WebStorm  开发nodejs（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快捷键 以下列出WebStorm常用快捷键
ctrl + shift + n: 打开工程中的文件，目的是打开当前工程下任意目录的文件。 ctrl + j: 输出模板 ctrl + b: 跳到变量申明处 ctrl + alt + T: 围绕包裹代码(包括zencoding的Wrap with Abbreviation) ctrl + []: 匹配 {}[] ctrl + F12: 可以显示当前文件的结构 ctrl + x: 剪切(删除)行，不选中，直接剪切整个行，如果选中部分内容则剪切选中的内容 alt + left/right:标签切换 ctrl + r: 替换 ctrl + shift + up: 行移动 shift + alt + up: 块移动(if(){},while(){}语句块的移动) ctrl + d: 行复制 ctrl + shift + ]/[: 选中块代码 ctrl + / : 单行注释 ctrl + shift + / : 块注释 ctrl + shift + i : 显示当前CSS选择器或者JS函数的详细信息 ctrl + ‘-/+’: 可以折叠项目中的任何代码块，它不是选中折叠，而是自动识别折叠。 ctrl + ‘.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04ea545048ddd6fefdfd957deb3798d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de11aeeebf7c873b131c7a3c2409484a/" rel="bookmark">
			基于全连接孪生网络的目标跟踪（siamese-fc）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fully-Convolutional Siamese Networks for Object Tracking 这两年可以说deeplearning已经占领了visual object tracking这个领域，但是对于跟踪问题来说，这些基于DL的做法虽然能够很好的提升跟踪的效果，但是在时效性这一方面却做的很差，这是因为DL复杂的模型往往需要很大的计算量，尤其是当使用的DL模型在跟踪的时候对模型进行更新的话，可能使用GPU都没法达到实时。今年出现了一些使用CNN进行跟踪，同时又具有很高的效率的跟踪算法，比如今年ECCV的GOTURN（我的这篇博客里进行了介绍，http://blog.csdn.net/autocyz/article/details/52648776），以及我将要介绍的这篇《Fully-Convolutional Siamese Networks for Object Tracking》。 文章题目叫：《Fully-Convolutional Siamese Networks for Object Tracking》 算法主页：http://www.robots.ox.ac.uk/~luca/siamese-fc.html code：https://github.com/bertinetto/siamese-fc 一、算法总体框架 图1 算法总体框架 图中z代表的是模板图像，算法中使用的是第一帧的groundtruth；x代表的是search region，代表在后面的待跟踪帧中的候选框搜索区域； ϕ 代表的是一种特征映射操作，将原始图像映射到特定的特征空间，文中采用的是CNN中的卷积层和pooling层；6*6*128代表z经过 ϕ 后得到的特征，是一个128通道6*6大小feature，同理，22*22*128是x经过 ϕ 后的特征；后面的*代表卷积操作，让22*22*128的feature被6*6*128的卷积核卷积，得到一个17*17的score map，代表着search region中各个位置与模板相似度值。 从图一和文章题目我们可以很容易理解算法的框架，算法本身是比较搜索区域与目标模板的相似度，最后得到搜索去区域的score map。其实从原理上来说，这种方法和相关性滤波的方法很相似。其在搜索区域中逐点的目标模板进行匹配，将这种逐点平移匹配计算相似度的方法看成是一种卷积，然后在卷积结果中找到相似度值最大的点，作为新的目标的中心。
上图所画的 ϕ 其实是CNN中的一部分，并且两个 ϕ 的网络结构是一样的，这是一种典型的孪生神经网络，并且在整个模型中只有conv层和pooling层，因此这也是一种典型的全卷积（fully-convolutional）神经网络。
二、具体实现 1、损失函数 在训练模型的时肯定需要损失函数，并通过最小化损失函数来获取最优模型。本文算法为了构造有效的损失函数，对搜索区域的位置点进行了正负样本的区分，即目标一定范围内的点作为正样本，这个范围外的点作为负样本，例如图1中最右侧生成的score map中，红色点即正样本，蓝色点为负样本，他们都对应于search region中的红色矩形区域和蓝色矩形区域。文章采用的是logistic loss，具体的损失函数形式如下： 对于score map中了每个点的损失： l(y,v)=log(1+exp(−yv)) 其中 v 是score map中每个点真实值，y∈{+1,−1}是这个点所对应的标签。 上面的是score map中每个点的loss值，而对于score map整体的loss，则采用的是全部点的loss的均值。即： L(y,v)=1|D|∑u∈Dl(y[u],v[u]) 这里的 u∈D 代表score map中的位置。 有了损失函数，那就可以用SGD对模型进行训练啦～～ 2、训练所用数据库 与以前的算法不一样的是，起训练的数据库并不是传统的VOT，ALOV，OTB这三个跟踪benchmark，而是ILSVRC（ImageNet Large Scale Visual Recognition Challenge）中用于视频目标检测中的视频，这个数据集一共有4500个videos，4500个，4500….
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de11aeeebf7c873b131c7a3c2409484a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15195c9e789d6592de6908cb8c89fd24/" rel="bookmark">
			js和java 中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为在jsp中对中文进行了编码的时候用的是UTF-8的编码方式，而在servlet中调用request.getParameter();方法的时候使用服务器指定的编码格式自动解码一次，所以前台编码一次后台解码一次而解码和编码的方式不用所以造成了乱码的出现；
解决方法一：
JavaScript：
window.self.location="searchbytext.action?searchtext="+encodeURIComponent(encodeURIComponent(seartext));
Java：
searchtext=java.net.URLDecoder.decode(searchtext,"UTF-8");
为什么要两次编码的原因：后台java代码给searchtext赋值的时候，本身已经使用了一次解码，不过解码的结果依然不对。所以我们可以在页面上进行两次编码操作，这样后台自动的那次就可以抵消掉一次，然后在使用searchtext=java.net.URLDecoder.decode(searchtext,"UTF-8");进行一次解码就好了。
(ps:不行就多转几次 多试几次 这个就是一个坑
fileNameTemp= java.net.URLDecoder.decode(fileNameTemp,"UTF-8");
//System.out.println(fileNameTemp);
fileNameTemp= java.net.URLDecoder.decode(fileNameTemp,"UTF-8");
)
解决方法二：
另外还有一种方法是JavaScript进行一次编码，后台java处理时换种想法就好了：
java代码：
String s = new String(request.getParameter("name").getBytes("ISO8859-1"), "UTF-8");
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1bd7e32f10f3b4bc604e244ad352af2/" rel="bookmark">
			Bootstrap 之Table样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将&lt;table&gt;标签添加class=‘table’ 类后的样式 &lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width" /&gt; &lt;title&gt;Table样式&lt;/title&gt; &lt;link href="~/bootstrap/css/bootstrap.css" rel="stylesheet" /&gt; &lt;script src="~/bootStrapPager/js/jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script src="~/bootstrap/js/bootstrap.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table class="table"&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;编号&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;001&lt;/td&gt;&lt;td&gt;郭靖&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;002&lt;/td&gt;&lt;td&gt;黄蓉&lt;/td&gt;&lt;td&gt;23&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;003&lt;/td&gt;&lt;td&gt;杨过&lt;/td&gt;&lt;td&gt;24&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 我们可以看到，Table是可以自由缩放的（不是响应式，应该是流媒体式） class='table table-striped' 条纹状表格（隔行变色） &lt;body&gt; &lt;table class="table table-striped"&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;编号&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;001&lt;/td&gt;&lt;td&gt;郭靖&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;002&lt;/td&gt;&lt;td&gt;黄蓉&lt;/td&gt;&lt;td&gt;23&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;003&lt;/td&gt;&lt;td&gt;杨过&lt;/td&gt;&lt;td&gt;24&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; class="table table-bordered" 给表格添加边框 &lt;body&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;编号&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;001&lt;/td&gt;&lt;td&gt;郭靖&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;002&lt;/td&gt;&lt;td&gt;黄蓉&lt;/td&gt;&lt;td&gt;23&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;003&lt;/td&gt;&lt;td&gt;杨过&lt;/td&gt;&lt;td&gt;24&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; class="table table-hover" 鼠标悬停变色 &lt;body&gt; &lt;table class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1bd7e32f10f3b4bc604e244ad352af2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5de08d6b905881184a9c6d7c0880ea7c/" rel="bookmark">
			GSM模块_STM32实现GPRS与服务器数据传输经验总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件环境
MCU：STM32F103RET6 （调试器：J-Link）
GSM模块：Ai-Thinker_A6 （安信可）（还需要配一个串口打印工具，当初选这个模块纯粹是因为价格是最便宜的）
------------------------------------------------------------------------- 软件环境
Keil4
------------------------------------------------------------------------- 开篇废话
经过两周时间的编码、调试，终于实现了GSM模块通过GPRS连接服务器的功能，并成功移植到了公司自己的项目里面。趁着有点空，我就把整个开发调试的过程记录下来，给自己做个备忘，也给大家做个参考。
------------------------------------------------------------------------- 时间列表
2天时间完成底层驱动部分函数的编写。
4天时间完成模块与服务器的连接，测试实例：获取服务器的RTC信息。
1天时间移植到公司的项目，纯代码搬运工作。
3天时间测试修复BUG并优化代码，找BUG的这几天，有1天只修改了1条代码，我也是醉了。
------------------------------------------------------------------------- 函数清单和注意事项
（底层驱动部分）
1. IO口初始化：控制 IO 和通讯 IO，控制包括电源控制，复位和低功耗模式，通讯就是串口啦，相信大家应该都很熟悉了。
当然在这个基础上还可以组合出复位的功能，复位在GPRS连接出错的时候会用到。
2. 串口初始化：模块的波特率为115200，8位数据位，1位停止位，没有校验位和流控。
串口还需要两个发送函数，发送一个字节和发送一串字符串的。串口中断处理函数放到后面说。
3. AT指令操作：发送AT指令
设置GPRS数据长度
发送GPRS数据内容
接收GPRS数据内容
AT指令/GPRS数据解析
4. 串口中断函数：包含AT指令/GPRS数据解析 和 接收GPRS数据内容，判断AT指令是否发送成功。
AT指令返回的结束符除了设置GPRS数据长度的是'&gt;'，其他都是"\r\n"。但是在判断接收结束的时候不能只考虑这两种情况，还有一个情况需要特殊处理，那就是当接收到GPRS数据的时候，完全有可能会出现'\r','\n'对应的十六进制数。解决的办法就是在接收到"+CIPRCV:xxx,"的时候，附带判断接收到的数据长度，"xxx"代表的是GPRS数据长度信息，字符型格式，在这里还需要做一个格式转换。数据长度的位数根据字符 ','来进行判断，',' 将AT命令和GPRS数据进行分割。"xxx"换算过来的数值决定了 ',' 后面接收到的数据长度。
由于目前采用的SIM卡模块内部没有自带缓冲区，在GPRS数据接收的时候，需要另外开辟一个存储空间用于数据的临时存储，建议采用环形缓冲区Buffer， 将串口接收到的数据按顺序存储，这个部分在串口中断函数里面实现。在大循环里面将数据取出处理，并设置相关标志位。我一开始设计的时候只开辟了一个非环形的缓冲区，每次接收到完整的数据，会从缓冲区的0地址重新开始存储，那么就会导致未及时处理的数据被新的数据冲掉。 不知道有没有别家的SIM卡模块是自带缓冲区的。 （主循环部分）
1. TCP/IP连接流程控制：
step1、"AT\r\n"//检测模块串口工作
step2、"AT+CCID\r\n"//检查是否插卡
step3、"AT+CREG?\r\n"//检查网络注册情况
step4、"AT+CGATT=1\r\n"//附着网络
step5、"AT+CGDCONT=1,\"IP\",\"CMNET\"\r\n"//设置PDP参数
step6、"AT+CGACT=1,1\r\n"//激活网络 step7、 "AT+CIPSTART=\"TCP\",\"121.41.xxx.xxx\",port\r\n"//连接TCPIP服务器
我用的这个模块硬件初始化差不多就要10秒了，在硬件初始化完成后，按照以上七步进行服务器连接，测试下来，连接的成功率还是蛮高的。前面两步是硬件检测用的，如果这两步都测不过，那就需要检查下硬件是否完整。三到六步如果返回ERROR，可重复发送，直至返回OK，每一步之间可间隔数秒。最后一步如果失败，需先关闭连接，再重新发起连接。如果第七步一直连接不成功，那么可以通过控制 IO 复位模块，当然也可以先确认下你的服务器的端口是否打开。
我的经验是连接和通讯的过程中，如果出现错误的情况，复位模块是最有效和快捷的方式。在确认硬件连接正常的情况下，如果多次发送命令失败，返回ERROR的话，那你还是乖乖的复位它吧。
另外两个AT命令也很好用
"AT+CIPCLOSE\r\n"//关闭TCPIP连接 "ATE0\r\n"//关闭回显，关闭自己发给模块的串口数据，调试的时候可以不开启这个功能，方便观察
2. 数据链路层数据处理：实现GPRS数据接收/发送控制，存储串口中断接收到的数据，发送GPRS数据长度和GPRS数据内容。
这个函数里面需要注意的是发送GPRS长度和数据的操作，需要在一次操作流程里面完成。我一开始脑残的将GPRS数据长度和数据发送分开处理，导致设置完数据长度后，发送状态处于准备好的状态，此时只要检测到有数据是需要发送的，便会通过GPRS发送出去，而无法保证是当前数据长度对应的数据帧（我在这里一共开辟了8个数据缓存，但是没有对发送状态进行分开判断）。在设置完数据长度后，需要判断是否接收到字符'&gt;'，大概需要50毫秒的时间。一开始分开发送也是和这个'&gt;'字符的操作有关的，我已经帮大家试过了，连在一起发就好了。
发送完GPRS长度帧后，返回字符'&gt;'，接着发送数据帧，在模块返回"OK"之前，发送的数据都会被发送到服务器，导致通讯出错。所以在数据发送后，需要等待判断模块是否已经发送成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5de08d6b905881184a9c6d7c0880ea7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb5318ba411192723dc893aeeb4fbedb/" rel="bookmark">
			Android 使用Face&#43;&#43;进行人脸识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		识别精度很好，可获取的信息也很多，比如左右眼睛的位置、鼻子的位置、嘴巴的位置、人脸的大小、年龄、性别、微笑程度等等
首先，要在Face++官网上注册一个账号，获取key和secret
然后创建一个应用
进入管理中查看key和secret
然后下载SDK http://www.faceplusplus.com.cn/dev-tools-sdks/
接下来在Android Studio中创建一个项目
导入SDK jar包
MainActivity.java
import android.app.Activity; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.os.Bundle; import android.util.Log; import android.view.ViewGroup; import android.widget.ImageView; import com.facepp.error.FaceppParseException; import com.facepp.http.HttpRequests; import com.facepp.http.PostParameters; import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import java.io.ByteArrayOutputStream; public class MainActivity extends Activity { private ImageView mIv; private Bitmap mFaceBitmap; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //创建一个ImageView，加载到Activity视图上 mIv = new ImageView(this); setContentView(mIv, new ViewGroup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb5318ba411192723dc893aeeb4fbedb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e477ccdc6edfced17155af5e56da59c6/" rel="bookmark">
			Android网络数据JSON解析使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一．JSON基础知识 （一）什么是json JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但 是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。
（二）JSON建构于两种结构 1.“名称/值”对的集合（A collection of name/value pairs）。 不同的语言中，它被理解为对象（object），哈希表 （hash table），有键列表（keyed list），或者关联数组 （associative array）等等。 2.值的有序列表（An ordered list of values）。 在大部分语言中，它被理解为数组 （array）。 这些都是常见的数据结构。事实上大部分现代计算机语言都以某种形式支持它们。这使得一种数据格式在同样基于这些结构的编程语言之间交换成为可能。
（三）JSON形式 1.对象是一个无序的“‘名称/值’对”集合。 一个对象以“{”（左括号）开始，“}”（右括 号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号） 分隔。 2.数组是值（value）的有序集合。 一个数组以“[”（左中括号）开始，“]”（右中括号）结 束。值之间使用“,”（逗号）分隔。 3.值（value）可以是双引号括起来的字符串（string）、数值(number)、true、false、 null、 对象（object）或者数组（array）。这些结构可以嵌套。 4.几个例子 （1）例子： Array里面包含对象(object) [ {“id”:1,”name”:”小猪” ,”age”:22} , {“id”:2,”name”:”小猫”,”age”:23} , …….] Array里面的对象数据是有序的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e477ccdc6edfced17155af5e56da59c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3c0f508324863553994a54514ddf331/" rel="bookmark">
			[软工]概要设计说明书(GB8567-88)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.【引言】 1.1 编写目的 设计软件结构的具体任务是将一个复杂系统按功能进行模块划分、建立模块的层次结构及调用关系、确定模块间的接口及人机界面等。数据结构设计包括数据特征的描述、确定数据的结构特性、以及数据库的设计。
此概要设计说明书是为了说明整个系统的体系架构，以及需求用例的各个功能点在架构中的体现，为系统的详细设计人员进行详细设计师的输入参考文档。
1.2 背景 说明：
a. 待开发软件系统的名称：机房收费系统
b. 此项目的任务提出者：米新江教授
c. 开发者：刘竞博
d. 用户以及将运行该软件的计算站（中心）：廊坊师范学院机房电脑以及学生或教师个人笔记本电脑
1.3 定义 列出本文件中用到的专门术语的定义和外文首字母组词的原词组。
1.4 参考资料 列出有关的参考文件，如：
a. 软件需求说明书（GB856T-88） b. 《软工视频》张洪志
c. 《SQL Server入门经典》敖富江译
2.【总体设计】 2.1 需求规定 功能
输入
处理
输出
注册
学生基本信息
添加到数据库
学生基本信息
添加管理员
管理员基本信息
添加到数据库
管理员基本信息
充值
充值卡号、充值金额
添加到数据库
充值金额、总余额
查询上机纪录（等记录）
学号或卡号
查询数据库
学生上机纪录（等记录）
退卡
卡号
删除数据库信息
退卡金额
2.2 运行环境 软件系统运行环境：Windows XP及以上系统
2.3 基本设计概念和处理流程 2.4 结构 用一览表及框图的形式说明本系统的系统元素（各层模块、子程序、公用程序等）的划分，扼要说明每个系统元素的标识符和功能，分层次地给出各元素之间的控制与被控制关系.
2.5 功能器求与程序的关系 管理端
学生(教师)端
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3c0f508324863553994a54514ddf331/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8573d40a9b5ca0fccad9bc06e8b8e654/" rel="bookmark">
			用Cookie保存登录信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、认识Cookie
指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。
Cookie 是在 HTTP 协议下，服务器或脚本可以维护客户工作站上信息的一种方式。Cookie 是由 Web 服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户链接到服务器，Web 站点都可以访问 Cookie 信息。
二、如何将Cookie写入客户端
服务器端写Cookie时，要使用以下步骤
1.实例化一个Cookie对象，确定Cookie的名称和值。一般使用构造函数
public Cookie(String name,String value); 其中，name表示Cookie对应的名称，value表示Cookie对应的值。
如：
Cookie cookie = new Cookie("account","zhangsan");//实例化一个Cookie对象，名为account,值为zhangsan 2.将Cookie写入客户端
response.addCookie(Cookie c); 3.也可以给Cookie对象设置存活时间
Cookie.setMaxAge(int second);//参数表示存活的秒数 例子：将用户的账号和密码保存到客户端
&lt;body&gt; &lt;% //实例化一个Cookie Cookie cookie1 = new Cookie("account","smith"); Cookie cookie2 = new Cookie("password","123456"); //设置Cookie的生命期限10分钟 cookie1.setMaxAge(600); //添加Cookie到客户端 response.addCookie(cookie1); response.addCookie(cookie2); %&gt; Cookie成功写到客户端 &lt;/body&gt; 三、如何读取客户端的Cookie
服务器读取客户端传来的Cookie时，使用以下步骤：
1.从客户端获取Cookie内容。
Cookie[] request.getCookies();//读取客户端传过来的Cookie，以数组形式返回 2.读取数组之后，对数组进行遍历，可以使用以下两个方法得到Cookie的信息
①获取Cookie名称
String Cookie.getName();
②获取Cookie的值：
String Cookie.getValue();
例子：读取客户端传来的所有Cookie的名称和值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8573d40a9b5ca0fccad9bc06e8b8e654/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f271081d05edc5872a5de6823687806/" rel="bookmark">
			jquery easyui：EasyUI Treegrid 树形网格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用jquery easyui 的 Treegrid 树形网格 进行数据展示，不过官网的API 和 demo 让我愣了好久，摸索后整理出来供大家详细参看。 jquery easyui 官网：http://www.jeasyui.net/plugins/186.html 下面以城市为例子，先展示最终效果图 第一步：引入JS和CSS
&lt;link rel="stylesheet" type="text/css" href="../../themes/default/easyui.css"&gt; &lt;link rel="stylesheet" type="text/css" href="../../themes/icon.css"&gt; &lt;link rel="stylesheet" type="text/css" href="../demo.css"&gt; &lt;script type="text/javascript" src="../../jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../../jquery.easyui.min.js"&gt;&lt;/script&gt; 第二步：使用 javascript 创建树形网格（treegrid）。（喜欢用HTML的人可以替换）
&lt;table id="tt"&gt;&lt;/table&gt; 因为为了详细讲解下，就用自己的字段信息参数不用demo
$(function(){ $('#tt').treegrid({ url:'${pageContext.request.contextPath}/city/getCityList', method:'post', //请求方式 idField:'id', //定义标识树节点的键名字段 treeField:'name', //定义树节点的字段 fit:true, //网格自动撑满 fitColumns:true, //设置为 true，则会自动扩大或缩小列的尺寸以适应网格的宽度并且防止水平滚动。 columns:[[ {field:'name',title:'名称',width:100}, {field:'_parentId',title:'所属父级',width:100}, ]] }); }); idField ：一般定义成主键就可以 treeField：是指定那列要展示成树形 左边是以“name”定义，右边是以“_parentId”定义 第三步：定义实体类 红色框内是easyui-tree 自带的属性值，也是效果的主要展示
_parentId （必须）：记得前面有“_” ，他是用来记录父级节点，没有这个属性，是没法展示父级节点 其次就是这个父级节点必须存在，不然信息也是展示不出来，在后台遍历组合的时候，如果父级节点不存在或为0时，此时 _parentId 应该不赋值。如果赋值 “0” 则显示不出来 state：是否展开 checked：是否选中（用于复选框） iconCls：选项前面的图标，如果自己不设定，父级节点默认为文件夹图标，子级节点为文件图标 其他属性字段可自行添加。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f271081d05edc5872a5de6823687806/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67beb6a60d29922cbe1a184fb87eef52/" rel="bookmark">
			Linux select 文件描述符1024限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近系统出现宕机的情况，分析core文件，所有的线程都在select处。
最后怀疑是文件描述符超过了1024。但是想到Apache也是采用select的io模型。所以还是很不理解。
查看了Linux的内核源码linux-2.6.32。
static __inline__ void __FD_SET(unsigned long fd, __kernel_fd_set *fdsetp)
{
unsigned long _tmp = fd / __NFDBITS;
unsigned long _rem = fd % __NFDBITS;
fdsetp-&gt;fds_bits[_tmp] |= (1UL&lt;&lt;_rem);
}
#define __NFDBITS (8 * sizeof(unsigned long))
typedef struct {
unsigned long fds_bits [__FDSET_LONGS];
} __kernel_fd_set;
#define __FDSET_LONGS (__FD_SETSIZE/__NFDBITS)
#define __FD_SETSIZE 1024
起关键作用的就是红字部分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/676492b4e2014006671cd738942f71ee/" rel="bookmark">
			LINUX服务器定时重启设置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 LINUX服务器定时重启设置方法 使用SSH工具成功登陆后台后,运行如下命令: crontab -e 然后在文档中根据需要插入如下内容: 0 2 * * * /sbin/reboot ( 0 2表示每天凌晨两点重启.. 0 3表示凌晨3点..) 06 2 * * * /sbin/reboot ( 06 2表示每天凌晨两点零六分重启.. 06 3表示凌晨3点零6分..) 0 4 * * * /sbin/reboot ( 0 4表示每天凌晨四点重启.. 0 3表示凌晨3点..) 同上，备份数据库和站点目录： 30 2 * * * /home/bin/oraclebackup.sh 30 3 * * * /home/bin/cmsbackup.sh 30 2 * * * /home/bin/oraclebackup.sh :wq保存退出后,执行如下命令重启crond 服务即可. /etc/rc.d/init.d/crond stop /etc/rc.d/init.d/crond start 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/985b74c2d39d90eb0ea65f35490c9394/" rel="bookmark">
			select真的有限制吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select真的有限制吗 Jun 1st, 2014 12:00 am 在刚开始学习网络编程时，似乎莫名其妙地就会被某人/某资料告诉select函数是有fd(file descriptor)数量限制的。在最近的一次记忆里还有个人笑说select只支持64个fd。我甚至还写过一篇不负责任甚至错误的博客(突破select的FD_SETSIZE限制)。有人说，直接重新定义FD_SETSIZE就可以突破这个select的限制，也有人说除了重定义这个宏之外还的重新编译内核。
事实具体是怎样的？实际上，造成这些混乱的原因恰好是不同平台对select的实现不一样。
Windows的实现 MSDN.aspx)上对select的说明：
int select( _In_ int nfds, _Inout_ fd_set *readfds, _Inout_ fd_set *writefds, _Inout_ fd_set *exceptfds, _In_ const struct timeval *timeout ); nfds [in] Ignored. The nfds parameter is included only for compatibility with Berkeley sockets. 第一个参数MSDN只说没有使用，其存在仅仅是为了保持与Berkeley Socket的兼容。
The variable FD_SETSIZE determines the maximum number of descriptors in a set. (The default value of FD_SETSIZE is 64, which can be modified by defining FD_SETSIZE to another value before including Winsock2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/985b74c2d39d90eb0ea65f35490c9394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ff98f80848dbc80507c2ee9e55ef38c/" rel="bookmark">
			Delphi 动态分配内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 动态分配内存 ① GetMem(var P: Pointer; Size: Integer);//分配 ② AllocMem(Size: Cardinal):Pointer; //分配Size大小空间,并初始化为0 返回分配到的指针 ③ FreeMem(Var P: Pointer); //释放以上分配方式分配的内存 ④ New(var P:Pointer) //New分配的大小由指针类型决定,不要使用无类型指针Pointer ⑤ 释放四这种分配方式用 Dispose(var P: Pointer); //强制数据类型转换 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707d90d76858528b99bb9e9312820b2b/" rel="bookmark">
			muduo网络库学习笔记(13)：TcpConnection生命期的管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇通过分析muduo中TcpConnection对断开连接事件的处理，来学习muduo网络库对TcpConnection生命期的管理。
TcpConnection对连接断开事件的处理 首先，我们来看一下TcpConnection处理连接断开事件时函数调用的流程： 我们这里所指的连接断开，都是指被动关闭，即对方先关闭连接，本地read(2)返回0，触发关闭逻辑。
分析：一个服务器（TcpServer）维护了一个连接列表，当一个连接断开时，TcpConnection中的通道处于活跃的状态，EventLoop的事件循环返回了这个活跃的通道，然后调用通道的handleEvent()函数来处理。连接关闭是可读事件，进而回调了TcpConnection的handleRead()函数，handleRead()中又调用了read()返回为0，判断read()返回为0又会调用handleClose()函数。handleClose()函数会回调TcpServer的removeConnection()函数，其中会调用erase()将该连接从连接列表移除。
这里我们需要注意的是——一般情况下，将连接从连接列表移除后，我们就可以将这个连接对象销毁（delete）掉了，但是在这里我们不能立即销毁这个连接对象，原因如下：
如果我们销毁了这个对象，TcpConnection所包含的Channel对象也就跟着被销毁了，而我们当前正在调用Channel对象的handleEvent()函数，就会出现core dump。所以，我们必须保证TcpConnection的生存期长于Channel::handleEvent()函数。
muduo选择用智能指针shared_ptr来管理TcpConnection的生命期，并且让TcpConnection类继承自boost::enable_shared_from_this。
源码分析 具体代码改动如下：
代码片段1：Channel的改动 文件名：Channel.cc // 析构函数中会判断Channel是否仍处于事件处理状态 // 在事件处理期间Channel对象不会析构 Channel::~Channel() { assert(!eventHandling_); } // 开始处理事件之前，会将事件处理标志位置为true // 直到事件处理完，事件处理标志位再置为false void Channel::handleEventWithGuard(Timestamp receiveTime) { eventHandling_ = true; if ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN)) { if (logHup_) { LOG_WARN &lt;&lt; "Channel::handle_event() POLLHUP"; } if (closeCallback_) closeCallback_(); } if (revents_ &amp; POLLNVAL) { LOG_WARN &lt;&lt; "Channel::handle_event() POLLNVAL"; } if (revents_ &amp; (POLLERR | POLLNVAL)) { if (errorCallback_) errorCallback_(); } if (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP)) { if (readCallback_) readCallback_(receiveTime); } if (revents_ &amp; POLLOUT) { if (writeCallback_) writeCallback_(); } eventHandling_ = false; } 代码片段2：TcpConnection::handleRead()函数的改动 文件名：TcpConnection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707d90d76858528b99bb9e9312820b2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca4344a4c571e0ed15f8c6fa7631cafa/" rel="bookmark">
			Contrastive Loss (对比损失)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Contrastive Loss (对比损失) 在caffe的孪生神经网络（siamese network）中，其采用的损失函数是contrastive loss，这种损失函数可以有效的处理孪生神经网络中的paired data的关系。contrastive loss的表达式如下： L=12N∑n=1Nyd2+(1−y)max(margin−d,0)2 其中 d=||an−bn||2 ，代表两个样本特征的欧氏距离，y为两个样本是否匹配的标签，y=1代表两个样本相似或者匹配，y=0则代表不匹配，margin为设定的阈值。 这种损失函数最初来源于Yann LeCun的Dimensionality Reduction by Learning an Invariant Mapping，主要是用在降维中，即本来相似的样本，在经过降维（特征提取）后，在特征空间中，两个样本仍旧相似；而原本不相似的样本，在经过降维后，在特征空间中，两个样本仍旧不相似。
观察上述的contrastive loss的表达式可以发现，这种损失函数可以很好的表达成对样本的匹配程度，也能够很好用于训练提取特征的模型。当y=1（即样本相似）时，损失函数只剩下 ∑yd2 ，即原本相似的样本，如果在特征空间的欧式距离较大，则说明当前的模型不好，因此加大损失。而当y=0时（即样本不相似）时，损失函数为 ∑(1−y)max(margin−d,0)2 ，即当样本不相似时，其特征空间的欧式距离反而小的话，损失值会变大，这也正好符号我们的要求。
这张图表示的就是损失函数值与样本特征的欧式距离之间的关系，其中红色虚线表示的是相似样本的损失值，蓝色实线表示的不相似样本的损失值。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7685d372a7523bf003809e8889fe16ff/" rel="bookmark">
			开发日记：KBEngine&#43;Unity&#43;php做个扑克小游戏-DAY2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么办，这很尴尬，为啥呢，因为kbe的某些原因让我放弃了使用它所以本打算继续更新的，说一下原因：
在DAY1中我希望kbe能够开启一个http服务，并让php端做一个web请求将消息传递给对应的用户，可是这个http服务我是写起来了，发送消息的函数也写出来（花了不少时间，kbe的注释和文档都不多，特别是kbe把BaseHttpServer这个python库另外弄了个名字，用http.server import as 才导入成功）尴尬的就是http服务和发消息的函数怎么也放不到一起：
1.一旦某个class不继承自KBEngine.Base,那么他就无法访问KBEngine的几乎所有静态函数、属性，就无法获取到对应用户的mailbox完成消息发送
2.一旦继承KBEgine.Base，你就做不了HTTP 服务，因为你的handler必须继承baseHandler，你继承不了，且即使你继承到baseHandler去访问KBEgine.Base的mailbox之类的又回到刚的死逻辑之中
3.系统库的HTTP服务会阻塞进程，这个文档还是写了，不过替代框架太麻烦，且调试太不方便，且语法太熟悉，且…………虽然我想说一万个且，只能说明我无能啊…………
当然论坛和官网当中也有人反应类似的问题，例如第三方接口访问KBE的成员/属性问题，不过看起来好像并没有现成的解决方案，最后的最后。。。我放弃了
然后呢~~我自己老老实实写了一个消息服务器(基于socket ，with WPF .net 4.5+)以及消息协议
消息协议采用http://msgpack.org/ 基本上支援所有的语言，因此实际上我这个消息服务器可以服务任何类型的客户端，不管你啥平台啥语言
1.0版协议（还没名字呢）规定:
1.BasePack代表发送的包，BaseAckPack代表回执包，BaseAckPack继承自BasePack
2.每个Pack长度为1024字节，且第0~4字节转换成int代表pack类型， BasePack及其子类从1.2.3...10... BaseAckPack 及其子类从1001,1002,1003...1010...(有考虑负数，其实应该也ok)
为啥这样做？ 这里很奇特，你在把这1024个字节用msgpack转成对象之前，你并不知道这个pack是哪个对象，你不能统一按某一个特定的对象去转，比如LoginPack比BasePack只多了2个属性，你在不知道它是一个LoginPack还是一个BasePack之前，你无法拆开他，你按任何一种来拆开都有可能出错(属性多了或少了，熟悉iOS 的KVC的应该很清楚)，所以必须先把前面4个字节腾出来，可选的，第5~8个字节放长度(mespack可以长度大于内容拆开没问题)，读8个字节之后再读剩下的1016(当然不一定每个包一定得是1024，可以更大，毕竟我目前够用了)个字节
using System; //send包 namespace Packs { //基础包 public class BasePack&lt;T&gt; { public int packType; public int fromId; public int toId; public int messageId; //将基本包转bytes public byte[] PackToBytes() { var encode = MsgPack.Serialization.MessagePackSerializer.Get&lt;T&gt;(); byte[] packContent = encode.PackSingleObject(this); byte[] type = BasePack.intToBytes(this.packType); byte[] len = BasePack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7685d372a7523bf003809e8889fe16ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fd1242972f26b22c1b6fc0b54cd1ba9/" rel="bookmark">
			自定义控件---类似添加邮件收件人效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义控件：增加控件时会则适应高度，宽度不够时会跳至下一行；无焦点可以控制高度，有焦点显示最大高度。
直接上代码：
public class LineWrapViewGroup extends ViewGroup { private int lineHeight = 0; private int hSpacing = 0; private int vSpacing = 0; public LineWrapViewGroup(Context context) { super(context); init(context, null, 0); } public LineWrapViewGroup(Context context, AttributeSet attrs) { super(context, attrs); init(context, attrs, 0); } public LineWrapViewGroup(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); init(context, attrs, defStyle); } private void init(Context context, AttributeSet attrs, int defStyle) { TypedArray a = context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fd1242972f26b22c1b6fc0b54cd1ba9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e984f035125a30c4d2068e195ddd392b/" rel="bookmark">
			zTree树插件实现点击左侧树，右侧展示文章列表页面实现思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者新建了一个QQ群：571278542 。欢迎大家加入！
上一篇文章中说了zTree树插件编写过程。接来下，谈谈zTree树插件实现点击左侧树，右侧展示文章列表页面过程。
效果展示 2.这里就说说思路。
channel.jsp
&lt;div class="pos-a" style="width:280px;left:0;top:0; bottom:0; height:100%; border-right:1px solid #e5e5e5; background-color:#f5f5f5"&gt; &lt;ul id="channelTree" class="ztree"&gt; &lt;/ul&gt; &lt;/div&gt; &lt;iframe id="listChannel" Name="listChannel" frameborder=0 src="" scrolling=auto width=100% height=900px &gt;&lt;/iframe&gt; 要想实现上面图片中的效果，就是建立2个jsp页面，channel.jsp和channelChild.jsp。
&lt;iframe id="listChannel" Name="listChannel" frameborder=0 src="" scrolling=auto width=100% height=900px &gt;&lt;/iframe&gt; 就是上面channel.jsp中那段代码。点击左侧树，右侧切换靠的就是channelChild.jsp子页面。 那么怎么实现？原理就是点击左侧树的时候，传递url地址给iframe 中src即可(至于iframe 标签 的用法大家可以去查一下)。这样就要依赖jquery来实现了。 以下zTree.js插件中，我已经写上去了。大家可以参考来写。
/* 插件树：传入setting原型扩展方法 */ var zTreeObj = null;// (function($) { $.fn.mytree = function(opts) { var setting = $.extend({ view: { selectedMulti: false, dblClickExpand:true }, async: { enable: true, type:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e984f035125a30c4d2068e195ddd392b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fadd96d885d43f251d0c16941af5960/" rel="bookmark">
			详解Linux下安装配置Nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说说在Linux系统下安装配置Nginx的详细过程。
1. 从Nginx官网下载Nginx。目前最新的稳定版为：1.6.2.
2. 将下载下来的Nginx上传到/opt/nginx目录下。运行“tar -zxvf nginx-1.6.2.tar.gz”进行解压。
3. 切换到/opt/nginx/nginx-1.6.2目录下，运行./configure进行初始化配置。如出现下面的提示，说明该机器没有安装PCRE，而Nginx需要依赖PCRE，需要手动安装PCRE，见 http://www.linuxidc.com/Linux/2015-03/114986.htm。
4. 安装完PCRE后，再次运行./configure进行初始化即可。注意这里生成的配置文件，尤其箭头所指的方向，是启动nginx时的路径。
5. 运行 make install 进行编译。
6. 切换到步骤4生成的nginx运行目录下，运行./nginx，启动Nginx。
如出现下面所述的错误，在已安装PCRE库的情况下，需要配置PCRE共享库。具体操作看这里 http://www.linuxidc.com/Linux/2015-03/114985.htm 。
./nginx: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory
7. 在浏览器中输入IP：端口号，出现如下图所示，说明安装成功。
如出现nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)。可能是端口号被占用，切换到/usr/local/nginx/conf/目录下，更改nginx.conf下的端口号。也有可能是不小心nginx重启了多次，关闭nginx进程，重启即可。
8. 关闭Nginx
使用 ps -ef|grep nginx 查看nginx的进程，可以看到nginx有两个进程：
[root@linuxidc sbin]# ps -ef|grep nginx root 7276 1 0 14:21 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fadd96d885d43f251d0c16941af5960/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fabfc8a9f233179a53d2f0270ed2f1b7/" rel="bookmark">
			MQTT broker 集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在近期的一个项目中，被问到公司自研的MQTT push服务器是否支持HA部署，从我了解的情况看目前还不支持。
[转载] 一篇使用 Apache activeMQ的集群部署实例，以后参考：
主要是利用HAProxy作为负载均衡器，利用activeMQ作为broker的集群。
1，准备4台服务器，默认操作系统为Ubuntu14.04，三台服务器安装activeMQ, 另外一台服务器安装HAProxy作为负载均衡。
2，安装和配置activeMQ
安装jre
sudo apt-get install default-jre export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64/jre 安装activeMQ
wget http://ftp.meisei-u.ac.jp/mirror/apache/dist/activemq/5.12.0/apache-activemq-5.12.0-bin.tar.gz tar zxvf apache-activemq-5.12.0-bin.tar.gz 启动activeMQ
cd [activemq_install_dir]/bin ./activemq console 3，配置activeMQ集群
假设三台broker服务器的地址分别是10.80.1.1, 10.80.1.2, 10.80.1.3，在三台服务器上分别配置如下
在服务器10.80.1.1上添加如下networkConnectors配置
&lt;networkConnectors&gt;
&lt;networkConnector uri="static:(tcp://10.80.1.2:61616,tcp://10.80.1.3:61616)"/&gt;
&lt;/networkConnectors&gt;
在服务器10.80.1.2上添加如下networkConnectors配置
&lt;networkConnectors&gt;
&lt;networkConnector uri="static:(tcp://10.80.1.1:61616,tcp://10.80.1.3:61616)"/&gt;
&lt;/networkConnectors&gt;
在服务器10.80.1.3上添加如下networkConnectors配置
&lt;networkConnectors&gt;
&lt;networkConnector uri="static:(tcp://10.80.1.1:61616,tcp://10.80.1.2:61616)"/&gt;
&lt;/networkConnectors&gt;
4，可通过如下web console添加topic
http://10.80.1.1:8161/admin/
http://10.80.1.2:8161/admin/
http://10.80.1.3:8161/admin/
默认用户名和密码是admin和admin
分别添加一个topic，比如presence
5,安装并配置HAProxy，假设服务器地址为10.80.1.4
安装HAProxy请参考如下的文档
https://www.vultr.com/docs/installing-and-configuring-haproxy-on-ubuntu-14-04
在HAProxy配置文件里面添加如下配置并重启
frontend mqtt_proxy bind *:1883 mode tcp default_backend mqtt_agent backend mqtt_agent mode tcp option tcplog balance roundrobin server mqtt_01 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fabfc8a9f233179a53d2f0270ed2f1b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cad5e38ee3b83531b73205852300a197/" rel="bookmark">
			echo print() print_r() var_dump()的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的输出语句
echo()
可以一次输出多个值，多个值之间用逗号分隔。echo是语言结构(language construct)，而并不是真正的函数，因此不能作为表达式的一部分使用。
print()
函数print()打印一个值（它的参数），如果字符串成功显示则返回true，否则返回false。
print_r()
可以把字符串和数字简单地打印出来，而数组则以括起来的键和值得列表形式显示，并以Array开头。但print_r()输出布尔值和NULL的结果没有意义，因为都是打印"\n"。因此用var_dump()函数更适合调试。
var_dump()
判断一个变量的类型与长度,并输出变量的数值,如果变量有值输的是变量的值并回返数据类型。此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。
看下面的代码form1.php
1 &lt;html&gt; 2 &lt;head&gt; 3 &lt;title&gt;&lt;/title&gt; 4 &lt;/head&gt; 5 &lt;body&gt; 6 &lt;form action="formprocess1.php" method="post"&gt; 7 &lt;table&gt; 8 &lt;tr&gt; 9 &lt;td&gt;Name&lt;/td&gt; 10 &lt;td&gt;&lt;input type="text" name="name" id="name"/&gt;&lt;/td&gt; 11 &lt;/tr&gt; 12 &lt;tr&gt; 13 &lt;td colspan="2" style="text-aligh:center"&gt; 14 &lt;input type="Submit" name="Submit" value="Submit" /&gt; 15 &lt;/td&gt; 16 &lt;/tr&gt; 17 &lt;/table&gt; 18 &lt;/form&gt; 19 &lt;/body&gt; 20 &lt;/html&gt; formprocess1.php
1 &lt;html&gt; 2 &lt;head&gt; 3 &lt;title&gt;&lt;/title&gt; 4 &lt;body&gt; 5 &lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cad5e38ee3b83531b73205852300a197/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/458/">«</a>
	<span class="pagination__item pagination__item--current">459/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/460/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>