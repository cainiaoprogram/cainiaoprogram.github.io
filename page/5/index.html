<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46276a1fb5baa3feaeb4e3978cc91fda/" rel="bookmark">
			android APP修改为鸿蒙APP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将一个Android应用（Android APP）修改为鸿蒙应用（HarmonyOS APP）需要进行一些适配和重构工作，因为两者的底层架构和开发模型存在一些差异。下面是一些通用的步骤和考虑事项，希望对大家有所帮助。北京木奇移动技术有限公司，专业的软件外包开发公司，欢迎交流合作。
1.了解鸿蒙开发文档：
在开始转换之前，仔细阅读鸿蒙开发文档，了解鸿蒙的开发模型、API和工具。这将有助于你理解如何在鸿蒙平台上进行应用开发。
2.项目结构调整：
鸿蒙应用的项目结构与Android应用可能有所不同。调整项目结构，确保符合鸿蒙的目录结构和规范。
3.替换Android API调用：
替换Android特有的API调用，因为Android和鸿蒙的API不同。一些核心组件和功能在鸿蒙中可能有不同的实现方式。
4.UI层适配：
鸿蒙使用分布式UI编程模型，要考虑如何适配Android应用的UI层。鸿蒙提供了类似Android的界面布局，但也引入了分布式UI的概念，可以在多个设备上呈现。
5.原生库和第三方库处理：
处理原生库和第三方库的适配问题。某些Android原生库和第三方库可能不适用于鸿蒙，需要寻找鸿蒙平台上的替代方案或进行相应的修改。
6.权限处理：
鸿蒙和Android的权限管理可能有一些差异，确保你的应用在鸿蒙平台上能够正确处理权限请求和管理。
7.调试和测试：
利用鸿蒙开发工具进行调试和测试。鸿蒙提供了HarmonyOS DevEco Studio等开发工具，用于在鸿蒙设备上测试和调试应用。
8.设备适配：
鸿蒙支持多种设备类型，包括手机、平板、电视等。确保你的应用在不同设备上能够正确适配和展示。
9.性能优化：
鸿蒙和Android可能有不同的性能优化要求。根据鸿蒙的性能最佳实践进行优化，以确保应用在鸿蒙平台上表现良好。
10.发布和分发：
使用鸿蒙平台的分发工具发布你的应用。鸿蒙应用可以通过华为应用市场等渠道进行分发。
请注意，具体的适配工作会因应用的复杂性而异。在转换为鸿蒙应用之前，建议先对应用进行全面的分析，了解应用中涉及的各种组件、功能和依赖项，以便更好地进行适配工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b9d9e9ce1569ea17220c6372c9b4c3f/" rel="bookmark">
			要想成为黑客，离不开这十大基础知识，这一篇保证你学得明明白白
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 黑客就像计算机幽灵一样，来无影去无踪。很多朋友对他们的高超技术羡慕不已，都想知道成为一名黑客，都需要掌握哪些基本技能。其实，总结起来也就以下十项基础技能。
1、专业英语 计算机最早诞生于美国，天生自带“英文”属性。虽然我们普通人可以使用简体中文，但人和计算机的交互命令全部都是英文命令。如果你连英文都不过关，那基本就谈不上当黑客了，尤其是计算机专业英语。
同时，最新的计算机技术资料基本都是英文版本的。等到翻译成中文，需要延后蛮长一段时间（1个月到1年不等）。而对于计算机漏洞来说，从发现开始计时，越往后越无效。因为安全厂商早就开始全面修补漏洞了。所以，黑客的英文必须好，而且经常浏览国外有名的英文网站。
2、网络协议 黑客之所以叫做黑客，就是因为他们“隐身”于计算机网络世界中。他们对各种网络协议都非常精通，并且能够熟练使用各种网络工具。这里说的精通不是懂得配置和优化，而是非常精通其工作原理。比如：
OSI七层网络模型中网络数据传输的各种封装，包括数据帧、数据包、报文段等。黑客经常需要通过网络扫描嗅探，也需要通过篡改数据来进行伪装。
TCP传输的三次握手、传输窗口、重传机制。黑客可以利用这些机制的弱点来制造麻烦。目前安全防御最难对付的就是DDOS攻击。
MAC地址、ARP、静态路由、动态路由、VPN、VLAN、NAT等工作机制。黑客可以通过入侵网络设备来窃取重要的数据。
IPv4、IPv6的规划、寻址技术，这是计算机在互联网上的身份证。黑客必须了解得明明白白。
DHCP、DNS、RDP、SSH、FTP、telnet、SCP等常见的网络应用。黑客经常利用这些常见的网络应用的漏洞来达到入侵的目的。
其他网络技术
3、linux操作系统 操作系统是计算机的基础软件，而Linux系统又是服务器端使用较多的操作系统。作为一个合格的黑客，自然需要精通linux系统的基础知识。同时，由于linux的开放性，很多攻击性强的黑客工具都是在linux下开发出来的。黑客如果对linux不熟悉，就连驾驭黑客工具都比较费劲，更谈不上入侵了。当然，这里并不是说windows系统就不需要掌握，只是linux显得更为重要一点罢了。windows毕竟在桌面终端上使用也是很广泛的。
4、社会工程学 社会工程学是指通过各种社会机制（包括伪装身份沟通）来获得信息的手段。很多人觉得这个和黑客技术没啥关系，感觉更像是小偷、骗子之类的。其实不然，社会工程学是黑客攻击的常用手段。他们可以伪装成单位的维修电工，将机房的全部电力切断。也可以通过伪装维护人员致电来获取系统的远程登录账号、密码。这可比暴力破解密码来得轻松很多。所以，现在的网络安全也包括提高人们的安全意识。
5、数据库技术 数据库是业务系统存储重要数据的场所，而很多黑客的攻击目的就是为了获取有用的数据。所以，黑客必须掌握市面上主流的数据技术，比如：oracle、db2、mysql、ms-sqlserver等等。同时，数据库周边的相关软件技术也是黑客需要掌握的，比如：备份软件。
6、web应用 web应用因为是对互联网提供服务，通常是黑客攻击的首要目标。因为它是完全公开暴露在互联网上的应用，所以比较容易被攻击。黑客攻击成功后，可以通过web服务器一步一步突防到核心业务系统。很多不注重安全的中小企业，经常会碰到网站被篡改、被挂马。这些都是黑客行为所致。黑客通常非常熟悉HTML、ASP、JSP、PHP等语言。
7、加解密 信息加密原本是“间谍”为了交换信息最常用的手段，但现在的网络中已经普遍使用加密传输、数据加密等技术。黑客们在长期的破解加密的过程中，也学会了利用加密系统。比如：这些年流行的勒索病毒就是黑客将用户的重要数据进行了高强度加密，导致用户无法读取这些数据不得不缴纳“解密费”。所以，黑客对加密和解密技术也是必须掌握的，不然很难突破用户的安全体系。包括：对称加密的DES、AES；非对称加密的RSA、DSA；散列算法SHA和MD5等。
8、编程技术 编程技术是计算机软件开发的必要技术。黑客们虽然不自己开发商业软件，但为了成功入侵系统，高级一点的黑客都会自己开发入侵工具。他们一般都擅长cgi、perl、php、python等脚本语言或者编程方法，可以轻松用这些工具来编写代码。
9、逆向工程 逆向工程通常用于破解商业软件，而黑客则可以通过逆向工程来发现软件的漏洞。当然，黑客也可以通过逆向工程对现有病毒或者恶意软件中的功能进行升级或者重构，形成新的强攻击力的恶意软件。
10、“隐身”技术 真正的黑客除了成功入侵系统外，还需要消除自己的入侵痕迹，做到网络“隐身”。因为，计算机系统、网络系统、安全设备都有完备的日志系统，他们会记录一切对系统的操作。黑客如果无法消除自己的访问痕迹，就算成功入侵了也很容易被安全部门抓获。所以，黑客必须非常清楚网络的数字取证技术，要知道如何规避自己被取证。
编程语言选择 如果想成为一名黑客,肯定需要一门精通的高级语言.这里推荐使用python语言入门.当然这只是我个人的意见。
Python介绍
是一种面向对象、直译式电脑编程语言，具有近二十年的发展历史，成熟且稳定。它包含了一组完善而且容易理解的标准库，能够轻松完成很多常见的任务。它的语法简捷和清晰，尽量使用无异义的英语单词，与其它大多数程序设计语言使用大括号不一样，它使用缩进来定义语句块。
与Scheme、Ruby、Perl、Tcl等动态语言一样，Python具备垃圾回收功能，能够自动管理内存使用。它经常被当作脚本语言用于处理系统管理任务和网络程序编写，然而它也非常适合完成各种高级任务。Python虚拟机本身几乎可以在所有的作业系统中运行。使用一些诸如py2exe、PyPy、PyInstaller之类的工具可以将Python源代码转换成可以脱离Python解释器运行的程序。
黑客学习资源分享 一、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、学习软件 工欲善其事必先利其器。学习Python常用的开发软件都在这里了，给大家节省了很多时间。
三、全套PDF电子书 书籍的好处就在于权威和体系健全，刚开始学习的时候你可以只看视频或者听某个人讲课，但等你学完之后，你觉得你掌握了，这时候建议还是得去看一下书籍，看权威技术书籍也是每个程序员必经之路。
四、入门学习视频 我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
四、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
五、清华编程大佬出品《漫画看学Python》 用通俗易懂的漫画，来教你学习Python，让你更容易记住，并且不会枯燥乏味。
六、面试资料 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
这份完整版的Python全套学习资料已经上传至CSDN官方，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费获取【保证100%免费】。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3aa73ce1d5034181145f82cdff455a1/" rel="bookmark">
			工业以太网的网络安全与数据传输性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工业以太网主要是一种用于工业控制系统的网络通信协议，它基于以太网技术，将其应用于工业环境中，以实现高速、可靠、安全的数据传输。跟传统的专用工业网络比较， 工业以太网具有更大的带宽、更低的成本以及更好的扩展性，因此被广泛应用于各种工业领域。
工业以太网的网络安全与数据传输性能
工业以太网在工业自动化领域中扮演着重要的角色，特别是在网络安全和数据传输方面。
工业以太网的核心优势之一是其高速数据传输能力。它支持千兆以太网或更高速率的通信，使得实时监测、远程控制和数据采集等任务能够以极低的延迟完成。这对于工业自动化和过程控制非常重要，能够确保生产系统的高效运行，并实现对生产过程的精确控制。
另一个工业以太网的关键特点是其可靠性和稳定性。在工业环境中，网络通信必须能够应对电磁干扰、温度变化、振动和噪声等各种干扰因素。工业以太网通过采用抗干扰技术和可靠的通信协议，确保数据传输的稳定性和可靠性。此外，工业以太网还支持网络冗余和备份机制，以提供高可用性和容错能力，即使在部分网络故障的情况下也能保持通信的连续性。
工业以太网的安全性也备受重视。在现代制造业中，关键的生产数据和机密信息需要在网络中传输，因此数据的安全性至关重要。为了确保数据的机密性和完整性，工业以太网采用了各种安全机制，包括身份验证、数据加密和访问控制等，利用这些措施可以防止未经授权的访问和潜在的网络攻击，保护生产系统的稳定运行和知识产权的安全。
综上所述，工业以太网在网络安全和数据传输方面具有显著的优势。它通过高速、可靠的数据传输和各种安全机制，为工业自动化提供了坚实的网络基础，从而确保了生产系统的高效、安全运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d905a33cda2011fa743e9de90e2f469/" rel="bookmark">
			【C语言】ipoib驱动 - ipoib_cm_post_receive_nonsrq_rss函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ipoib_cm_post_receive_nonsrq_rss函数定义 static int ipoib_cm_post_receive_nonsrq_rss(struct net_device *dev, struct ipoib_cm_rx *rx, int id) { struct ipoib_dev_priv *priv = ipoib_priv(dev); struct ipoib_recv_ring *recv_ring = priv-&gt;recv_ring + rx-&gt;index; struct ib_sge *sge; struct ib_recv_wr *wr; int i, ret; sge = recv_ring-&gt;cm.rx_sge; wr = &amp;recv_ring-&gt;cm.rx_wr; wr-&gt;wr_id = id | IPOIB_OP_CM | IPOIB_OP_RECV; for (i = 0; i &lt; IPOIB_CM_RX_SG; ++i) sge[i].addr = rx-&gt;rx_ring[id].mapping[i]; ret = ib_post_recv(rx-&gt;qp, wr, NULL); if (unlikely(ret)) { ipoib_warn(priv, "post recv failed for buf %d (%d)\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d905a33cda2011fa743e9de90e2f469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24414dbc07d9602f1ac10864fec05f6/" rel="bookmark">
			UniApp调试支付宝沙箱（安卓）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看下这里完整的交互的图：小程序文档 - 支付宝文档中心
一、打包
不管怎样，先打个包先。可以直接使用云端证书、云端打包，只需要指定包名即可。
二、在支付宝开放平台创建应用
这个参考官方的过程就可以了，只要有刚才打的包，就可以提交创建。（登录 - 支付宝）
这里说的只是可以提交创建，但是因为缺少很多材料（比如营业执照等）在正式环境肯定调不通。
当然，提交审核大概率也会被打回。
三、后端接入-获取订单信息：
参考：小程序文档 - 支付宝文档中心
注意上面链接参考代码里面的编码是"BGK"，在传值有中文的情况下即使是沙箱都会报“商品订单数据错误”之类的报错，需要改成“UTF-8”。
这个页面里还有一个功能是它会帮忙检查产品的准备情况，正式接入前可参考下，沙箱可忽略：
四、前端获取后端的订单信息并且调用uniapp封装好的支付接口：
uniapp端的前端参考要参考这个链接：开通 | uni-app官网（关键字是：uni.requestPayment）
针对沙箱修改后的参考代码：
onLoad() {
var EnvUtils = plus.android.importClass("com.alipay.sdk.app.EnvUtils");
EnvUtils.setEnv(EnvUtils.EnvEnum.SANDBOX);
},
methods: {
goToAliPay() {
request({
url: '/alipaytest/getOrderInfo',
method: 'get',
data: {
orderId: this.orderId,
subject: this.subject,
totalAmount: this.totalAmount
}
}).then(response =&gt; {
console.log(response.msg)
uni.getProvider({
service: 'payment',
success: function(res) {
console.log(res.provider)
if (~res.provider.indexOf('alipay')) {
uni.requestPayment({
"provider": "alipay", //固定值为"alipay"
"orderInfo": response.msg, //此处为服务器返回的订单信息字符串
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f24414dbc07d9602f1ac10864fec05f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4799f29634bea0e05a7efcdb4f5f3016/" rel="bookmark">
			代码&#43;视频，超详细的R语言svykm函数绘制复杂抽样设计数据cox回归生存曲线(Kaplan-Meier)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在既往的文章《R语言绘制复杂抽样设计数据cox回归生存曲线(Kaplan-Meier)》中介绍了怎么使用jskm包的svykm函数绘制复杂抽样设计数据cox回归生存曲线(Kaplan-Meier)，今天来视频操作一下
超详细的R语言svykm函数绘制复杂抽样设计数据cox回归生存曲线(Kaplan-Meier)
代码
library(jskm) library(survey) #公众号回复：胆管炎数据，可以获得数据 pbc&lt;-read.csv("E:/r/test/pbc.csv",sep=',',header=TRUE) # age：年龄，trt：治疗方案：1D-青霉烯，2安慰剂，edema：水肿， # status: 结局变量0/1/2表示审查、移植、死亡。 pbc$randomized &lt;- with(pbc, !is.na(trt) &amp; trt&gt;0) biasmodel &lt;- glm(randomized~age*edema,data=pbc) pbc$randprob &lt;- fitted(biasmodel) #生成预测值randprob后我们就可以正式分析了，我们先生成一个调查数据 dpbc &lt;- svydesign(id=~1, prob=~randprob, strata=~edema, data=subset(pbc,randomized)) s1 &lt;- svykm(Surv(time,status&gt;0)~sex, design=dpbc,se=T) #绘图 svyjskm(s1) #更改X轴，Y轴标签和标题 svyjskm(s1,xlabs = "时间",ylabs = "生存率",main = "时间与生存率关系图") #对图例进行修改 svyjskm(s1,xlabs = "时间",ylabs = "生存率",ystrataname = "性别",ystratalabs=c("男","女")) #对X轴的范围进行限制，对Y轴也是一样的 svyjskm(s1,xlabs = "时间",ylabs = "生存率",ystrataname = "性别", ystratalabs=c("男","女"),xlims=c(0,3000)) #把Y轴改成以百分比显示 svyjskm(s1,xlabs = "时间",ylabs = "生存率",ystrataname = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4799f29634bea0e05a7efcdb4f5f3016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50dbb677c4f5a878356c253e2f7c4216/" rel="bookmark">
			Java零基础教学文档第四篇：HTML_CSS_JavaScript（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日新篇章
【CSS】
【主要内容】
CSS简介
CSS基础语法
CSS选择器
CSS常用属性
CSS元素分类
CSS定位
【学习目标】
1.CSS的简介 1.1 CSS定义与解释**
CSS是Cascading Style Sheets（层叠样式表单）的简称，CSS就是一种叫做样式表（stylesheet）的技术。它用于定义HTML元素的显示形式，是一种格式化网页内容的技术。CSS现在已经被大多数浏览器所支持，成为网页设计者必须掌握的技术之一。
W3C自1996年12月发布第一个CSS正式推荐版CSS 1.0以来，一直在对CSS标准进行修订、升级。1999年1月，CSS 2.0 正式推荐版发布，增加了对其它媒体（打印机、视觉设备）、可下载字体、元素定位和表格的支持。最新标准的CSS 3.0已经发部，其主要的影响是可以使用新的可用的选择器和属性，这些会允许你实现新的设计效果（譬如动态和渐变），而且可以很简单的设计出以前需要JavaScript才能设计出来的效果。
1.2 CSS替我们解决什么问题
通过前面我们知道CSS也只是一个技术或一个东西的代名词，那究竟CSS作用是什么，CSS能帮我们解决什么问题呢？
DIV + CSS 作用与解决问题：
1.CSS技术帮我们控制网页中的字体大小、页面宽度、页面内容靠左靠右、字体样式、某些网页里区域背景图片、背景颜色、超链接鼠标事件样式、图片居中、文字居中、网页中内容板块间隔等样式。
2.CSS的最核心作用：实现将内容与表现形式相分离。
2. CSS基础语法 2.1 CSS语法**
CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。
选择器 { 属性1: 值1; 属性2: 值2; … 属性N: 值N; }
选择器通常是您需要改变样式的 HTML 元素。
每条声明由一个属性和一个值组成，属性和值用冒号(“ : ”)分开，多条声明用分号(“ ; ”)分开。
下面这行代码的作用是将 h1 元素内的文字颜色定义为红色，同时将字体大小设置为 14 像素。
在这个例子中，h1 是选择器，color 和 font-size 是属性，red 和 14px 是值。
h1 {color: red; font-size:14px;}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50dbb677c4f5a878356c253e2f7c4216/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07be12141a12827872f55e11e41fab8f/" rel="bookmark">
			Android Gradle Plugin、Gradle、Android Studio版本关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接
Android Gradle Plugin 与 gradle 对应关系 插件版本所需的最低 Gradle 版本8.38.48.28.28.18.08.08.07.47.57.37.47.27.3.37.17.27.07.04.2.0+6.7.14.1.0+6.5+4.0.0+6.1.1+3.6.0 - 3.6.45.6.4+3.5.0 - 3.5.45.4.1+3.4.0 - 3.4.35.1.1+3.3.0 - 3.3.34.10.1+3.2.0 - 3.2.14.6+3.1.0+4.4+3.0.0+4.1+2.3.0+3.3+2.1.3 - 2.2.32.14.1 - 3.52.0.0 - 2.1.22.10 - 2.131.5.02.2.1 - 2.131.2.0 - 1.3.12.2.1 - 2.91.0.0 - 1.1.32.2.1 - 2.3 Android Gradle 插件和 Android Studio 兼容性 Android Studio 构建系统以 Gradle 为基础，并且 Android Gradle 插件 (AGP) 添加了几项专用于构建 Android 应用的功能。下表列出了各个 Android Studio 版本所需的 AGP 版本。
如果您的项目不受某个特定版本的 Android Studio 支持，您仍然可以使用旧版 Android Studio 打开和更新项目。
Android Studio 版本所需的 AGP 版本Iguana | 2023.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07be12141a12827872f55e11e41fab8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff0fad498afd5c879d4b9fb49bec0fcd/" rel="bookmark">
			uniapp微信小程序投票系统实战 (SpringBoot2&#43;vue3.2&#43;element plus ) -用户投票实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		锋哥原创的uniapp微信小程序投票系统实战：
uniapp微信小程序投票系统实战课程 (SpringBoot2+vue3.2+element plus ) ( 火爆连载更新中... )_哔哩哔哩_bilibiliuniapp微信小程序投票系统实战课程 (SpringBoot2+vue3.2+element plus ) ( 火爆连载更新中... )共计21条视频，包括：uniapp微信小程序投票系统实战课程 (SpringBoot2+vue3.2+element plus ) ( 火爆连载更新中... )、第2讲 投票项目后端架构搭建、第3讲 小程序端 TabBar搭建等，UP主更多精彩视频，请关注UP账号。https://www.bilibili.com/video/BV1ea4y137xf/新建用户投票详情表t_vote_detail:
create table `t_vote_detail` ( `id` int (11), `vote_id` int (11), `vote_item_id` int (11), `vote_date` datetime , `openid` varchar (600) ); 新建VoteDetail实体：
package com.java1234.entity; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableName; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import lombok.Data; import java.util.Date; /**投票详情 * @author java1234_小锋 （公众号：java1234） * @site www.java1234.vip * @company 南通小锋网络科技有限公司 */ @TableName("t_vote_detail") @Data public class VoteDetail { private Integer id; // 编号 private Integer voteId; // 投票ID private Integer voteItemId; // 投票选项ID private String openid; // 投票人openid @TableField(select=false,exist = false) private WxUserInfo wxUserInfo; @JsonSerialize(using=CustomDateTimeSerializer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff0fad498afd5c879d4b9fb49bec0fcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0927387be32cf121328aa713a180c009/" rel="bookmark">
			Memory Controller Unit (MCU)内存控制器介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Memory Controller Unit (MCU)内存控制器介绍1. MCU基本概念和功能地址映射读写操作缓存控制内存刷新1.1 地址映射1.2 读写操作1.3 缓存控制1.4 内存刷新 2. MCU的工作原理接收CPU的请求地址转换执行操作管理缓存 3. MCU的类型SDRAM控制器DDR控制器Flash控制器 4. MCU的设计挑战性能并发复杂性功耗 Memory Controller Unit (MCU)内存控制器介绍 Memory Controller Unit，简称MCU，是一种关键的硬件组件，用于管理系统内存的访问。在现代计算机系统中，它是至关重要的部分，它负责处理CPU与内存之间的所有交互。MCU不仅确保了数据的正确和有效性，还对内存操作进行优化以提高整体性能。
1. MCU基本概念和功能 MCU是一个复杂的硬件设备，其主要功能如下：
地址映射 MCU将CPU发出的逻辑地址转换为物理内存中的实际地址。
读写操作 当CPU需要从内存中读取或写入数据时，MCU会执行相应的操作。
缓存控制 MCU也负责管理系统的缓存，包括L1，L2和L3缓存等，以减少CPU访问内存的延迟。
内存刷新 某些类型的内存（如DRAM）需要定期刷新以保持其内容，这项工作由MCU完成。
1.1 地址映射 在CPU和MCU之间，有一个地址映射过程。CPU通过逻辑地址来访问内存，然后MCU将这个逻辑地址转换成物理地址，并在物理内存上执行相应的操作。这种映射方法使得操作系统可以方便地管理内存，而不需要关心物理内存的具体布局。
1.2 读写操作 当CPU需要从内存中读取或写入数据时，它会发出一个请求，并提供要访问的地址和操作类型（读或写）。然后，MCU将这个请求转换为适合物理内存的格式，并执行相应的操作。
1.3 缓存控制 为了提高性能，现代计算机系统通常包含一级、二级和三级缓存。MCU负责管理这些缓存，包括决定哪些数据应该被缓存，以及在何时将数据从缓存移动到主内存。
1.4 内存刷新 对于某些类型的内存，如动态随机存取内存（DRAM），需要定期进行刷新操作以保持其内容。这是因为DRAM使用电容来存储信息，而电容会随着时间的推移而自然放电。MCU负责周期性地刷新DRAM，以防止数据丢失。
2. MCU的工作原理 MCU的工作原理非常复杂，但基本上可以分为以下几个步骤：
接收CPU的请求 首先，MCU会接收来自CPU的内存访问请求。这个请求包含了访问的类型（读或写）、要访问的地址和可能需要写入的数据。
地址转换 接着，MCU会将CPU提供的逻辑地址转换为物理地址。这个过程通常涉及到页表查找和地址计算。
执行操作 一旦得到物理地址，MCU就可以在内存上执行相应的操作了。如果是读操作，MCU会从指定的地址读取数据并将其返回给CPU；如果是写操作，MCU会将数据写入指定的地址。
管理缓存 在整个过程中，MCU还需要管理系统的缓存。它需要决定哪些数据应该被缓存，以及何时将数据从缓存移动到主内存。
3. MCU的类型 根据系统的不同需求，有多种类型的MCU可供选择。以下是几种常见的MCU类型：
SDRAM控制器 这种类型的MCU主要用于控制同步动态随机存取内存（SDRAM）。SDRAM是现代计算机系统中最常用的内存类型。
DDR控制器 这种类型的MCU用于控制双倍数据速率同步动态随机存取内存（DDR SDRAM）。DDR SDRAM是SDRAM的一种改进型，提供了更高的性能。
Flash控制器 这种类型的MCU用于控制闪存。闪存是一种非易失性的存储介质，通常用于存储固件或其他重要的系统数据。
每种MCU都有其特定的功能和优点，选择哪种类型的MCU取决于系统的具体需求和应用场景。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0927387be32cf121328aa713a180c009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d198b36bee661e42fd1458f34ced39/" rel="bookmark">
			【Linux】 nohup命令使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nohup命令 nohup是Linux和Unix系统中的一个命令，其作用是在终端退出时，让进程在后台继续运行。它的全称为“no hang up”，意为“不挂起”。nohup命令可以让你在退出终端或关闭SSH连接后继续运行命令。
nohup 命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。
著者 由Jim Meyering撰写。
语法 nohup 命令 [参数]... nohup 选项 nohup命令 -Linux手册页 选项及作用 执行令 ： nohup --help
执行命令结果
常用命令示例 命令：nohup test5.sh &amp; 以下命令在后台执行 test5.sh 脚本。
命令：nohup test5.sh &gt; test5_5.txt &amp; 标准输出重定向到test5_5.txt 文件。
命令：nohup test5.sh &gt;/dev/null 2&gt;&amp;1 /dev/null文件是一个无底洞，任何东西都可以定向到这里，但是却无法打开。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f93113e2a65333898674094900cb3b/" rel="bookmark">
			Ubuntu 22.0.4 忘记重置 MySQL 密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 22.0.4 忘记重置 MySQL 密码 一、问题描述二、解决办法 一、问题描述 Ubuntu 22.0.4 忘记了 MySQL的密码，需要重新设置密码
环境描述：
系统：Ubuntu 22.0.4
MySQL：8.0.35 （通过 apt install mysql-sever 安装的）
二、解决办法 1. 停止 MySQL 服务：
sudo systemctl stop mysql 2. 以不加载授权表的方式启动 MySQL 服务器：
sudo mysqld_safe --skip-grant-tables --skip-networking &amp; 如果在这一步出现了
mysqld_safe Directory ‘/var/run/mysqld’ for UNIX socket file don’t exists 则可以试试如下的命令：这个需要在第二个终端输入下面的命令，
sudo mkdir -p /var/run/mysqld sudo chown mysql:mysql /var/run/mysqld 输入完成后，回到第一个终端重新输入上面的命令
以下操作均在第二个终端执行
3. 用以下命令连接到 MySQL 服务器：
mysql -u root 4. 进入 MySQL 后，使用以下命令来更改密码。将 new_password 替换为你想要设置的新密码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4f93113e2a65333898674094900cb3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/271d05fdcd38b8f3bf38f166d2724dd0/" rel="bookmark">
			MYSQL数据库主从复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么要做主从复制？ 在业务复杂的系统中，mysql主从复制有这样几个情景，
1、有个SQL语句需要锁表，导致暂时不能使用读的服务，那么就影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运行。
2、做数据的热备，主库宕机后能够及时替换主库，保证业务可用性及连续性。
3、架构的扩展，业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。
二、MySQL主从复制的原理 MySQL主从复制也可以称为MySQL主从同步，它是构建数据库高可用集群架构的基础。它通过将一台主机的数据复制到其他一台或多台主机上，并重新应用relay log中的SQL语句来实现复制功能。MySQL支持单向、双向、链式级联、异步复制，MySQL 5.5版本之后加入的半同步复制，5.6版本之后的GTID复制，MySQL 5.7的多源复制、并行复制、loss-less复制。
MySQL主从复制是一个异步的复制过程，主库发送更新事件到从库，从库读取更新记录，并执行更新记录，使得从库的内容与主库保持一致。
几个概念需要了解下：
binlog：binary log，主库中保存所有更新事件日志的二进制文件。binlog是数据库服务启动的一刻起，保存数据库所有变更记录（数据库结构和内容）的文件。在主库中，只要有更新事件出现，就会被依次地写入到binlog中，之后会推送到从库中作为从库进行复制的数据源。
binlog输出线程：每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。 对于每一个即将发送给从库的SQL事件，binlog输出线程会将其锁住。一旦该事件被线程读取完之后，该锁会被释放，即使在该事件完全发送到从库的时候，该锁也会被释放。在从库中，当复制开始时，从库就会创建从库I/O线程和从库的SQL线程进行复制处理。
从库I/O线程：当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。 从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。
从库的SQL线程：从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。对于每一个主从复制的连接，都有三个线程。拥有多个从库的主库为每一个连接到主库的从库创建一个binlog输出线程，每一个从库都有它自己的I/O线程和SQL线程。
从库通过创建两个独立的线程，使得在进行复制时，从库的读和写进行了分离。因此，即使负责执行的线程运行较慢，负责读取更新语句的线程并不会因此变得缓慢。比如说，如果从库有一段时间没运行了，当它在此启动的时候，尽管它的SQL线程执行比较慢，它的I/O线程可以快速地从主库里读取所有的binlog内容。这样一来，即使从库在SQL线程执行完所有读取到的语句前停止运行了，I/O线程也至少完全读取了所有的内容，并将其安全地备份在从库本地的relay log，随时准备在从库下一次启动的时候执行语句。
主从同步过程中主服务器有一个工作线程I/O dump thread，从服务器有两个工作线程I/O thread和SQL thread。主库把外界接收的SQL请求记录到自己的binlog日志中，从库的I/O thread去请求主库的binlog日志，并将binlog日志写到relay log中继日志中，然后从库重做中继日志的SQL语句。主库通过I/O dump thread给从库I/O thread传送binlog日志。
三、常见的几种主从架构 1）单向主从模式：Master ——&gt; Slave
2）双向主从模式：Master &lt;====&gt; Master
3）级联主从模式：Master ——&gt; Slave1 ——&gt; Slave2
4）一主多从模式
5）多主一从模式
四、mysql高可用HA架构 1、MySQL Cluster
MySQL Cluster(MySQL集群)是一个高性能、可扩展、集群化数据库产品，其研发设计的初衷就是要满足许多行业里的最严酷应用要求。这些应用中经常要求数据库运行的可靠性要达到99.999%。
MySQL Cluster是基于无共享的可由多台服务器组成的、同时对外提供数据管理服务的分布式集群系统。通过合理的配置，可以将服务请求在多台物理机上分发实现负载均衡 ；同时内部实现了冗余机制，在部分服务器宕机的情况下，整个集群对外提供的服务不受影响，从而能达到99.999%以上的高可用性。 MySQL Cluster设计之初出于性能考虑，将数据完全存放在内存当中，因此MySQL Cluster可以当作一种分布式的内存数据库。随着MySQL Cluster技术的成熟和需求的增加，目前MySQL Cluster已支持磁盘存储，可以指定数据表存储在磁盘上，减少MySQL Cluster集群对内存的需求，从而实现存储更大的容量。
2、MySQL Cluster（NDB）
MySQL从结构看，由3类节点(计算机或进程)组成，分别是： 管理节点: 用于给整个集群其他节点提供配置、管理、仲裁等功能。
数据节点: MySQL Cluster的核心，存储数据、日志，提供数据的各种管理服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/271d05fdcd38b8f3bf38f166d2724dd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/406fbbbf6e91a10cd7cc33e5c9702151/" rel="bookmark">
			html和Vue中div可以嵌套使用div吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		答案是可以 1.在html中如何嵌套使用div 是的，`&lt;div&gt;` 元素可以嵌套在另一个 `&lt;div&gt;` 元素内部。实际上，在 HTML 中，`&lt;div&gt;` 是一个通用的块级容器元素，用于创建和布局页面的结构。
你可以使用嵌套的 `&lt;div&gt;` 元素来实现更复杂的布局，将页面划分为多个部分，并对这些部分应用样式或添加内容。
以下是一个简单的示例，展示了如何嵌套使用 `&lt;div&gt;` 元素：
&lt;div class="container"&gt; &lt;div class="header"&gt; &lt;!-- header content goes here --&gt; &lt;/div&gt; &lt;div class="sidebar"&gt; &lt;!-- sidebar content goes here --&gt; &lt;/div&gt; &lt;div class="content"&gt; &lt;!-- main content goes here --&gt; &lt;/div&gt; &lt;div class="footer"&gt; &lt;!-- footer content goes here --&gt; &lt;/div&gt; &lt;/div&gt; 在上面的示例中，我们使用一个外层的 `&lt;div class="container"&gt;` 包裹了多个子元素。
每个子元素也是一个 `&lt;div&gt;`，分别有不同的类名来标识其用途，例如 `header`、`sidebar`、`content` 和 `footer`。 通过嵌套使用 `&lt;div&gt;` 元素，你可以更好地组织和布局网页的内容，并用 CSS 样式对这些元素进行处理。
2.在Vue中如何嵌套使用div 当在 Vue 中编写模板时，可以嵌套使用 `&lt;div&gt;` 元素或其他 HTML 元素，以构建复杂的组件结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/406fbbbf6e91a10cd7cc33e5c9702151/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27acbcf1cfbe1998e333ea5caa6425cd/" rel="bookmark">
			如何在 Windows 中使用Copilot AI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows Copilot 是 Windows 中的一个新功能，它可以让你与一个智能助理进行对话，获取信息，执行任务，甚至创造内容。Windows Copilot 使用了 Bing Chat 的技术，它是一个基于 OpenAI 的 GPT-4 模型的聊天机器人。
目录
一、Windows 中使用Copilot 操作步骤
1.1 更新系统至最新版
1.2 更改电脑的区域和语言
1.3 下载 ViVeTool 工具
1.4 运行ViVeTool 工具
1.5 重启电脑
一、Windows 中使用Copilot 操作步骤 1.1 更新系统至最新版 你可以在设置 &gt;Windows 更新 &gt; Windows 预览体验计划中加入 Insider 计划，并选择 DevChannel 来获取最新的更新。如果你已经是 Insider 成员，你可以直接在 Windows 更新中检查更新，并安装最新的版本。 windows 10 系统需要下载并安装 build 19045.3754 或更高版本
Windows 11 系统需要下载并安装23H2最新版本，也就是 Insider Preview Build 23493 或更高版本。 1.2 更改电脑的区域和语言 需要确保你的电脑的区域和语言设置为美国和英语。因为 Windows Copilot 目前只支持英语，并且只在美国地区开放。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27acbcf1cfbe1998e333ea5caa6425cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9af155653e504b1acc135fa20fa4ffc5/" rel="bookmark">
			移动安全-certutil
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 需求 需求1：获取应用文件的MD5
CertUtil -hashfile 文件路径 MD5 2 语法 C:\&gt;certutil -? 动词: -dump -- 转储配置信息或文件 -dumpPFX -- 转储 PFX 结构 -asn -- 分析 ASN.1 文件 -decodehex -- 解码十六进制编码的文件 -decode -- 解码 Base64 编码的文件 -encode -- 将文件编码为 Base64 -deny -- 拒绝挂起的申请 -resubmit -- 重新提交挂起的申请 -setattributes -- 为挂起申请设置属性 -setextension -- 为挂起申请设置扩展 -revoke -- 吊销证书 -isvalid -- 显示当前证书部署 -getconfig -- 获取默认配置字符串 -ping -- Ping Active Directory 证书服务申请接口 -pingadmin -- Ping Active Directory 证书服务管理接口 -CAInfo -- 显示 CA 信息 -ca.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9af155653e504b1acc135fa20fa4ffc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a44cbc6d20377852b3466ed9c86cab4/" rel="bookmark">
			C语言基础入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注博主 Mindtechnist 或加入【Linux C/C++/Python社区】一起学习和分享Linux、C、C++、Python、Matlab，机器人运动控制、多机器人协作，智能优化算法，滤波估计、多传感器信息融合，机器学习，人工智能等相关领域的知识和技术。
预处理pragma 1. 预处理指令2. #pragma详细用法 专栏：《精通C语言》
1. 预处理指令 ANSI标准定义的C语言预处理指令
预处理指令含义#define宏定义，在预处理阶段进行文本替换。#undef撤销已定义的宏#include引入其他源文件#if #else #elif #endif#if 的一般含义是如果#if 后面的常量表达式为true，则编译它与#endif 之间的代码，否则跳过这些代码。命令#endif 标识一个#if 块的结束。#else命令的功能类似于C 语言中的else ，#else 建立另一选择分支（和# if 搭配）。#elif 命令意义与else if 相同，它形成一个if else-if语句，可进行多种编译选择分支。#ifdef #ifndef条件编译，#ifdef表示如果已经定义了某个宏，#ifndef表示如果没有定义某个宏。#line改变当前行数和文件名，在编译程序中预先定义的标识符，用法为#line number[“filename”]。#error编译程序时，如果遇到#error则产生一个编译错误的提示消息，并且会停止编译。#pragma指定编译器实现特定功能。比如，#pragma once表示只包含一次头文件，#pragma pack(1)指定字节对齐方式等等。 ANSI标准C定义的宏：
__LINE__	//正在编译的文件的行号 __FILE__	//正在编译的文件的名字 __DATA__	//表示编译时刻的日期字符串 __TIME__	//表示编译时刻的时间字符串 __STDC__ //判断该文件是不是定义成标准C程序 #include
#include提供文件包含的功能，在预处理阶段完成，它可以把多个源文件连接成一个源文件，实际上#include是宏替换的一种延伸。使用#include包含文件主要有两种方式，两种方式的区别在于搜索策略不同。
#include &lt;path/filename&gt;
在搜索时直接从编译器指定的路径进行搜索，如果找到文件，则把文件内容替换到#include语句处，如果找不到则报错。一般系统提供的头文件使用尖括号包含。
#include “path/filename”
在搜索时首先从运行程序所在的目录处搜索，如果搜索失败再从编译器指定的路径处搜索，如果仍然搜索失败则报错。用户自定义的头文件必须用双引号包含。
#运算符
#也可以看作一种预处理指令，用法如下
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define PRINT1(x) printf("square of x is %d\n", x * x) #define PRINT2(x) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a44cbc6d20377852b3466ed9c86cab4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33e628dec558a14056faa566c7b575e0/" rel="bookmark">
			弹跳小球加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果演示 实现了一个加载动画，可以用来显示页面正在加载中的状态。具体来说，它使用了CSS的动画和变换来实现一个弹跳的圆圈和一个向右移动的线条。当页面加载完成后，这个动画会自动消失。
Code &lt;div class="loader"&gt;&lt;/div&gt; body { height: 100vh; display: flex; justify-content: center; align-items: center; background-color: #212121; } .loader { position: relative; width: 120px; height: 90px; margin: 0 auto; } .loader:before { content: ""; position: absolute; bottom: 30px; left: 50px; height: 30px; width: 30px; border-radius: 50%; background: #2a9d8f; animation: loading-bounce 0.5s ease-in-out infinite alternate; } .loader:after { content: ""; position: absolute; right: 0; top: 0; height: 7px; width: 45px; border-radius: 4px; box-shadow: 0 5px 0 #f2f2f2, -35px 50px 0 #f2f2f2, -70px 95px 0 #f2f2f2; animation: loading-step 1s ease-in-out infinite; } @keyframes loading-bounce { 0% { transform: scale(1, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33e628dec558a14056faa566c7b575e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b6ef93e69aec41a9f8047b4984a1a6/" rel="bookmark">
			css设置内嵌样式阴影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.box{ box-shadow: inset 0 0 10px #f1e227, inset 0 0 10px #b6b70f, inset 0 0 10px #879017, inset 0 0 10px #485b22, inset 0 0 10px #0a272e; /* 这是一个CSS的box-shadow属性的值，用于创建一个元素的内部阴影效果。具体的意思是在元素的边界内部添加五个不同颜色和大小的阴影效果。 inset表示阴影是内部阴影，而不是外部阴影。 0 0 10px表示阴影的偏移量和模糊半径。这里的偏移量是0，表示阴影与元素重叠，模糊半径是10px，表示阴影的边缘有10像素的模糊效果。 #f1e227, #b6b70f, #879017, #485b22, #0a272e是五个不同颜色的阴影颜色值。每个阴影颜色值对应一个内部阴影效果。 总之，这个属性值可以创建一个具有多个内部阴影效果的元素。每个阴影可以具有不同的颜色和大小。 */ } 这是一个CSS样式代码，用于为一个元素添加一个内阴影效果。具体解释如下：
box-shadow:
inset 0 0 10px #f1e227,inset 0 0 10px #b6b70f,inset 0 0 10px #879017,inset 0 0 10px #485b22,inset 0 0 10px #0a272e; 这段代码添加了五个内阴影效果，每个效果都具有相同的偏移量（0 0），模糊度（10px），颜色分别为#f1e227，#b6b70f，#879017，#485b22，#0a272e。
这个样式可以让一个元素的边框内部产生阴影效果，可以通过修改偏移量、模糊度和颜色来调整阴影效果的样式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cba8d9aaa316b8093f2bc613e8bc763/" rel="bookmark">
			移动安全-keytool
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 需求 需求1：获取应用签名的CN、OU、O字段
keytool -printcert -jarfile C:\Contacts_MFV.apk | findstr CN= 需求2：获取应用签名的MD5
2 语法 C:\Program Files\java\jdk-19.0.1\bin&gt;keytool 密钥和证书管理工具 命令: -certreq 生成证书请求 -changealias 更改条目的别名 -delete 删除条目 -exportcert 导出证书 -genkeypair 生成密钥对 -genseckey 生成密钥 -gencert 根据证书请求生成证书 -importcert 导入证书或证书链 -importpass 导入口令 -importkeystore 从其他密钥库导入一个或所有条目 -keypasswd 更改条目的密钥口令 -list 列出密钥库中的条目 -printcert 打印证书内容 -printcertreq 打印证书请求的内容 -printcrl 打印 CRL 文件的内容 -storepasswd 更改密钥库的存储口令 -showinfo 显示安全相关信息 -version 输出程序版本 使用 "keytool -?, -h, or --help" 可输出此帮助消息 使用 "keytool -command_name --help" 可获取 command_name 的用法。 使用 -conf &lt;url&gt; 选项可指定预配置的选项文件。 C:\Program Files\java\jdk-19.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cba8d9aaa316b8093f2bc613e8bc763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84f252f11b3f2b94e2a1a22354b0a78c/" rel="bookmark">
			QT上位机开发（属性页面的设计）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【 声明：版权所有，欢迎转载，请勿用于商业用途。 联系信箱：feixiaoxing @163.com】
窗口设计的时候，如果很多内容一个page放不下，那么这个时候我们一般都会选择使用tab来进行处理。安装了tab之后，就相当于一个windows里面有好几个page，展示和可操作的内容一下子就扩大了，这应该就是tab页面的优势所在。tab是界面开发中很常见的一个属性，大家可以好好掌握一下。
1、创建一个带widget的基础工程 创建带widget的基础工程，主要是建立一个qt编译框架，实际代码未必用得上。
2、编写代码 代码的部分也很简单，主要的内容就是mainWindow里面放置一个QTabWidget，它可以看成是tab的总合体。而每一个tab item就是一个独立的QWidget，QWidget部署好了之后呢，就会加入到QTabWidget当中。另外每一个tab里面，我们放置了一个按钮，按钮还配置了对应的回调函数，主要是qDebug()打印，大家可以看下代码。
#include &lt;QApplication&gt; #include &lt;QTabWidget&gt; #include &lt;QWidget&gt; #include &lt;QVBoxLayout&gt; #include &lt;QPushButton&gt; #include &lt;QDebug&gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); // 创建主窗口 QWidget mainWindow; mainWindow.setWindowTitle("Qt TabWidget Demo"); mainWindow.resize(600,450); // 创建一个 QTabWidget QTabWidget tabWidget(&amp;mainWindow); // 创建第一个标签页 QWidget tab1; QVBoxLayout layout1(&amp;tab1); // 创建Button 1，并为其添加点击事件槽函数 QPushButton button1("Button 1 in Tab1"); QObject::connect(&amp;button1, &amp;QPushButton::clicked, [&amp;]() { qDebug() &lt;&lt; "Button 1 clicked!"; }); layout1.addWidget(&amp;button1); tabWidget.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84f252f11b3f2b94e2a1a22354b0a78c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6110d1751d16864c33d89cf5106e0dc7/" rel="bookmark">
			maven--解决下载依赖很慢的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文网址：maven--解决下载依赖很慢的问题_IT利刃出鞘的博客-CSDN博客
简介 本文介绍解决maven下载依赖很慢的方法。
方法是：使用国内镜像加快速度。
第一步：新建settings.xml文件 创建一个settings.xml文件：
localRepository是存放依赖的地方，可以自己修改，占空间会很大，不要放到C盘。mirror是指定镜像，本处使用国内的阿里镜像，速度很快，也是最常用的。 文件内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6110d1751d16864c33d89cf5106e0dc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ba5eb6629a9c6c919d9f93e43af3b1/" rel="bookmark">
			Java中的规则引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 中的规则引擎为我们提供了一个以灵活且定义的方式管理和执行业务规则的框架。这些引擎使开发人员能够在不更改核心应用程序的情况下更轻松地修改和理解规则，从而将业务逻辑与应用程序代码分开。
规则引擎旨在评估条件并根据指定规则触发操作。它们还为我们提供了一种更加动态和适应性更强的方法来处理复杂的决策过程。本文介绍了允许开发人员自动化其软件应用程序逻辑的各种规则引擎。通过集成这些规则引擎，开发人员可以为业务策略的自动化做出重大贡献，最终产生更强大、更有效的软件应用程序。
Java 中的规则引擎是什么？
Java中的规则引擎确实是强大的工具，可以自动化业务逻辑，从而实现更高效的决策过程。这些引擎允许开发人员独立于应用程序代码定义和管理业务规则，提供灵活的条件和操作，从而允许动态决策方法来处理复杂的决策场景。将业务规则与核心应用程序逻辑分离有助于更好的代码组织、可重用性和易于维护。
规则引擎的好处：
它为我们提供了很好的代码可重用性。由于规则引擎独立于相关应用程序代码运行，因此无需直接操作源代码，从而降低了复杂性。它还提供了可读性和灵活性，我们可以在不更改源代码中的任何内容的情况下更改规则。它允许将业务规则与应用程序代码分离，而不影响核心程序。它有助于业务专家和开发人员在不了解高级编码技能的情况下进行协作，从而使决策非常有效和合乎逻辑。 规则引擎如何工作？
第 1 步：设置您的 Java 项目
要设置 Java 项目，您需要创建一个新的 Java 项目，也可以使用现有项目。在 Java 项目中实现规则引擎之前，您必须准备一个 Java 项目，并在 Java 项目中配置所需的设置。
步骤 2：在 pom.xml 文件或 yml 文件中添加规则引擎工具依赖项。
例如，如果您使用的是Maven，则在 xml 文件中添加 Drools 引擎的依赖项。
org.drools drools-core 7.65.0.Final 第 3 步：创建事实类
事实类是指表示将应用规则的数据或事实的类，在以下示例中，“Person”类被视为事实类。通常在规则引擎中，特别是在Drools规则引擎的情况下，class.java被替换为事实类并且通常表示为class.java或person.java。
// Person.java public class Person { private String name; private int age; private boolean eligibleForDiscount; private boolean specialStatus; // Your Getters and setters
}
第 4 步：在 Java 项目中编写规则
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71ba5eb6629a9c6c919d9f93e43af3b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/420f08b2cf0341fb582c4972f4253135/" rel="bookmark">
			【MOOC】华中科技大学计算机组成原理慕课答案-第八章-输入输出系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应一个同学后台留言，说让我发就发全，那我干脆把剩的这一章测验也发了吧。
以下解析由GPT生成，不保证可读可解释，仅保证答案正确。
单选 1　(单选(2分)) ‎某中断系统中，每抽取一个输入数据就要中断CPU一次，中断处理程序接收取样的数据，并将其保存到主存缓冲区内。该中断处理需要X秒。另一方面，缓冲区内每存储N个数据，主程序就将其取出进行处理，这种处理需要Y秒，因此该系统可以跟踪到每秒（ ）次中断请求。
‌A. N /（X + Y）N
B. max[1 / X ,1 / Y]
√C. N /（NX + Y）
D. min[1 / X ,1 / Y]
A. 因为这个公式没有考虑Y的影响，所以错
B. 因为这个公式没有考虑数据的数量N，所以错
C. 因为中断处理X秒一次，处理N个数据需要NX秒，加上处理数据的Y秒，所以每秒能处理N / (NX + Y)次中断请求，所以对
D. 因为这个公式没有考虑数据的数量N和处理数据的时间Y，所以错
2　(单选(2分)) ‏中断向量地址是（ ）。
‎A. 中断返回地址
√B. 中断服务例行程序入口地址的指示器
C. 子程序入口地址
D. 中断服务例行程序入口地址
A. 中断返回地址是中断处理后CPU返回被中断程序的地址，与中断向量地址不同，所以错
B. 中断向量地址是中断服务程序入口地址的指针，正确
C. 子程序入口地址与中断向量地址不是同一概念，所以错
D. 中断服务例行程序入口地址是具体的地址，而非地址本身，所以错
3　(单选(2分)) ‎为了便于实现多级中断，保存现场信息最有效的办法是采用（ ）。
‍A. 外存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/420f08b2cf0341fb582c4972f4253135/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e15d9ab515f8c0f22d18106959eeb905/" rel="bookmark">
			家庭在线记账理财管理系统PHP源码，附带系统安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码介绍
家庭在线记账理财管理系统：掌控你的财务，简单又直观
源码开放，让你对自己的开支有深入的了解。其图形化的操作界面，使得记账变得轻松简单，非常适合个人或家庭使用。即使是杂货铺，也能通过这个系统轻松管理财务。
系统界面简洁而不失优雅，操作直观且简单，让你在短时间内就能熟练掌握。强大的后台功能支持数据导入，让你的财务管理更加高效。不论是日常的记账需求，还是复杂的财务分析，这个系统都能满足你的需求。
搭建教程
1、上传到网站根目录
2、用phpMyadmin导入数据库文件sjk.sql
3、修改数据库链接文件 /data/config.php
（记得不要用记事本修改，否则可能会出现验证码显示不了问题，建议用Notepad++）
4、帐号 admin 密码 123456
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b89a1617dfc0844224d4a9ece5c3ace4/" rel="bookmark">
			在Linu上安装Gitlab：使用rpm方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、下载rpm安装包二、环境准备三、安装rpm包四、修改配置文件gitlab.rb五、修改配置文件gitlab-http.conf六、让配置生效，然后启动gitlab七、常用指令八、其他说明信息九、访问gitlab十、修改gitlab配置1、设置界面语言为中文2、去除注册限制 十一、官方部署参考文档 一、下载rpm安装包 考虑到网速和清华大学镜像站会删除部分镜像的原因，这里给大家提供gitlab-ce-15.2.0-ce.0.el7.x86_64.rpm的百度网盘下载地址：
链接：https://pan.baidu.com/s/1fT9QxrG5D1CAgR65Igl4RQ?pwd=3li8
提取码：3li8
如果大家想下载其他版本rpm包，可以去清华大学开源镜像站下载
二、环境准备 // 1、准备一个不低于2核4G的Centos7环境，内存尽量再大一点，避免gitlab宕机 // 2、安装常用工具 sudo yum install -y curl policycoreutils-python openssh-server perl // 3、开启SSH访问 sudo systemctl enable sshd sudo systemctl start sshd // 4、去除防火墙对 HTTP、HTTPS访问的限制，这是官方推荐的，而我是自己使用，所以我直接永久把防火墙给禁用了（先禁用防火墙，然后在关闭防火墙，达到永久禁用的目的） systemctl disable firewalld systemctl stop firewalld 三、安装rpm包 rpm -Uvh gitlab-ce-15.2.0-ce.0.el7.x86_64.rpm 四、修改配置文件gitlab.rb // 1、编辑/etc/gitlab/gitlab.rb vi /etc/gitlab/gitlab.rb // 2、找到external_url，然后将后面的域名改成虚拟机ip和port，其中port是gitlab在浏览器上的访问端口 // 例如：external_url 'http://192.168.56.10:10001' external_url 'http://主机ip:gitlab页面访问端口' // 3、在上面配置后面添加nginx监听端口信息 // 例如：nginx['listen_port'] = 10001 nginx['listen_port'] = gitlab页面访问端口 // 4、找一个合适位置，添加以下内容，用来关闭无用组件 prometheus['enable'] = false prometheus['monitor_kubernetes'] = false alertmanager['enable'] = false node_exporter['enable'] = false redis_exporter['enable'] = false postgres_exporter['enable'] = false gitlab_exporter['probe_sidekiq'] = false prometheus_monitoring['enable'] = false grafana['enable'] = false 修改结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b89a1617dfc0844224d4a9ece5c3ace4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0824bcce6dab35590dc624b4d921ea4b/" rel="bookmark">
			C&#43;&#43;中什么时候应该使用结构体，什么时候应该使用类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一点：
在C++中，结构体和类都可以用来定义自定义数据类型，
它们之间的主要区别在于默认的访问控制和成员变量的默认初始化方式。
结构体：
- 结构体的成员变量默认为public访问权限。
- 结构体的成员变量默认为公共可见的，可以直接通过结构体实例对象来访问和修改。
- 结构体通常用于组织和存储相关的数据，不包含复杂的行为和方法。
类：
- 类的成员变量默认为private访问权限。
- 类的成员变量默认为私有可见的，只能通过类的成员函数来访问和修改。
- 类可以包含成员函数，用于定义类的行为和操作。
- 类可以使用继承、多态等特性，具有更强大的抽象能力和代码组织能力。
因此，当你只需要简单地组织和存储数据时，可以使用结构体。
而当你需要更复杂的行为和方法时，应该使用类。
第二点：
结构体也可以显式地使用访问控制关键词，如果你声明的变量或方法没有写在任何访问控制关键词下，那么默认为public。
struct MyStruct { private: int privateVar; public: int publicVar; private: void privateFunc() { // 私有函数的实现 } public: void publicFunc() { // 公共函数的实现 } }; 而如果你在一个类中同样将一个成员变量，放在访问控制关键词外面，默认则是private。
class Person { int age; // 私有成员，默认为private public: void setAge(int a) { age = a; } void display() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0824bcce6dab35590dc624b4d921ea4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f66b778676fdf45de2e30db264cbf681/" rel="bookmark">
			Nginx上对同一IP访问的特定URL进行限流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在Nginx上对同一IP访问的特定URL进行限流，您可以使用ngx_http_limit_req_module模块。以下是一个简单的配置示例：
http { limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; server { location /your-url { limit_req zone=one burst=5; # 此处添加其他配置 } # 其他服务器配置... } } 这个配置将每秒限制同一IP对指定URL的访问速率为1次，并且允许在短时间内累积最多5个请求（burst=5）。您可以根据需要调整rate和burst的值。
设置更大的时间区间 如果您想设置更大的时间区间，您可以调整rate参数的值。rate参数表示每秒允许的请求数量。例如，如果您希望每分钟限制为60个请求，可以将rate设置为60。
http { limit_req_zone $binary_remote_addr zone=one:10m rate=60r/m; server { location /your-url { limit_req zone=one burst=5; # 添加其他配置 } # 其他服务器配置... } } 在这个示例中，rate=60r/m表示每分钟允许60个请求。您可以根据需要调整这个值。
安装 ngx_http_limit_req_module 模块 主机上直接安装 nginx 和 ngx_http_limit_req_module 模块 ngx_http_limit_req_module 模块是 Nginx 的官方模块，通常是通过编译 Nginx 时启用的。以下是安装步骤：
1. 检查现有 Nginx 模块 在开始之前，您可以使用以下命令检查您的 Nginx 是否已启用 ngx_http_limit_req_module 模块：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f66b778676fdf45de2e30db264cbf681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fb017a563c5aaa40b37b030ae129e88/" rel="bookmark">
			嵌出式学习又一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于485通讯
485属于串口通信，属于物理层的，规定为2线，半双工的多点通信标准，它的电气特性不一样，用缆线两端电压差值来表示传递信号，rs485仅仅规定了接收端和发送端的电气特性，没有规定任何数据协议。
rs485特点如下：
1.接口电平低，不易损坏芯片，接口信号电平比232低，不易损坏芯片，高电平1以两线的电压差表示2-6v 低电平以两线电压-（2-6）v表示，且该电平与TTL电平兼容（TTL电平信号规定，+5V等价于逻辑“1”，0V等价于逻辑“0”）
2.传输速率高
3.抗干扰能力强
4.传输距离远
rs485可以用于线型和总线型，不可用于星形和环形
理想情况下485需要两个匹配电阻，其阻值一般要求等于传输电缆线的阻抗（一般为120Ω）
直流（DC） 交流（AC）
阻抗越小导电性能越好
PD7控制485的收发，当0表示接收 1表示发送
R14和R17是偏置电阻用来保证空闲的时候电压差大于200mv用来表示逻辑1，避免造成逻辑错乱
#include "sys.h" #include "rs485.h" #include "delay.h" #ifdef EN_USART2_RX //如果使能了接收 //接收缓存区 u8 RS485_RX_BUF[64]; //用一个数组来接收缓冲,最大 64 个字节. //接收到的数据长度 u8 RS485_RX_CNT=0; void USART2_IRQHandler(void)//中断处理事件 { u8 res; if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET) //接收到数据 { res =USART_ReceiveData(USART2); //读取接收到的数据 if(RS485_RX_CNT&lt;64) { RS485_RX_BUF[RS485_RX_CNT]=res; //记录接收到的值 RS485_RX_CNT++; //接收数据增加 1 } } } #endif //初始化 IO 串口 2 //bound:波特率 void RS485_Init(u32 bound) { GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOD, ENABLE); //使能 GPIOA,D 时钟 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);//使能串口 2 时钟 GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fb017a563c5aaa40b37b030ae129e88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0700a067a6d8bc84b82c3295d4363cf7/" rel="bookmark">
			【LeetCode】27. 移除元素（简单）——代码随想录算法训练营第1天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 示例 1：
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0700a067a6d8bc84b82c3295d4363cf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8392f675f447cd1e90431802de0ff30f/" rel="bookmark">
			“编程语言大比拼：Python、JavaScript、Java与C#的优劣与选择“。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一篇关于不同编程语言特性的比较和选择的文章。
在当今的编程世界中，有许多种不同的编程语言可供选择。每种语言都有其独特的特性和优点，这使得选择最适合特定项目的语言变得复杂。本文将比较几种流行的编程语言，以帮助您了解它们的特性和适用场景。
Python：Python是一种高级的、动态类型的解释型语言，以其简洁的语法和易读性而闻名。它适用于多种应用，包括Web开发、数据科学、机器学习、网络爬虫等。Python的强大社区和丰富的库使其成为许多开发者的首选语言。
JavaScript：JavaScript是一种流行的编程语言，主要用于Web开发。它是一种动态类型的脚本语言，可以在浏览器中直接运行。由于其广泛的应用，JavaScript已成为前端和后端开发的必备语言。
Java：Java是一种静态类型的编译型语言，具有高度的可移植性。它适用于大型的企业级应用程序，如数据库、服务器和桌面应用程序等。Java有大量的库和框架，使其成为许多企业和开发者的首选语言。
C#：C#是微软开发的面向对象的编程语言，与Java有许多相似之处。它适用于Windows应用程序、游戏开发、桌面应用程序等。C#具有强大的类型系统和强大的IDE支持，使其成为.NET开发人员的理想选择。
选择正确的编程语言取决于多个因素，包括项目的需求、开发团队的技能和经验、以及特定任务的性能要求等。在选择编程语言时，您应该考虑语言的语法、学习曲线、性能、社区支持以及可用的库和框架等因素。
最后，不要忘记尝试不同的编程语言，亲自体验它们的特性和功能。这将有助于您找到最适合您项目和技能的最佳语言。
嵌入式物联网需要学的东西真的非常多，千万不要学错了路线和内容，导致工资要不上去！
分享大家一个资料包，差不多150多G。里面学习内容、面经、项目都比较新也比较全！
扫码进群领资料https://s.pdb2.com/pages/20230519/16QijNiGb32IFIn.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c758808b6a8c206336bb490e0db5031b/" rel="bookmark">
			计算机基础面试题 |22.精选计算机基础面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤍 前端开发工程师（主业）、技术博主（副业）、已过CET6
🍨 阿珊和她的猫_CSDN个人主页
🕠 牛客高级专题作者、在牛客打造高质量专栏《前端面试必备》
🍚 蓝桥云课签约作者、已在蓝桥云课上架的前后端实战课程《Vue.js 和 Egg.js 开发企业级健康管理项目》、《带你从入门到实战全面掌握 uni-app》
文章目录 如果资源在缓存中过期了，应该如何通知客户端浏览器重新获取？使用HTTPS协议的缺点是什么？如何解决HTTPS的兼容性问题？ 如果资源在缓存中过期了，应该如何通知客户端浏览器重新获取？ 当资源在缓存中过期时，客户端浏览器通常会自动发送新的请求到服务器以获取最新的资源。
服务器可以通过以下方式通知客户端浏览器资源已经过期：
设置合适的缓存控制头：在服务器的响应中设置适当的 Cache-Control 头部，指示浏览器和缓存服务器如何缓存响应。例如，设置较短的缓存时间或设置 no-cache 来指示浏览器不要缓存该资源。
使用ETag 头部：ETag 头部是一个唯一标识资源的标识符。当服务器发送响应时，它可以将资源的 ETag 值包含在响应头部中。客户端在后续请求中会将这个 ETag 值作为请求头部的一部分发送给服务器。服务器可以通过比较 ETag 值来判断资源是否发生了变化，如果资源发生了变化，服务器会返回新的资源。
使用Last-Modified 头部：Last-Modified 头部是一个表示资源最后修改时间的时间戳。当服务器发送响应时，它可以将资源的最后修改时间包含在响应头部中。客户端在后续请求中会将这个最后修改时间作为请求头部的一部分发送给服务器。服务器可以通过比较最后修改时间来判断资源是否发生了变化，如果资源发生了变化，服务器会返回新的资源。
通过使用这些头部信息，客户端浏览器可以根据服务器的指示来决定是否使用缓存的资源或重新向服务器请求最新的资源。当资源在缓存中过期时，客户端会自动发送新的请求到服务器以获取最新的内容。这样可以确保客户端始终获取到最新的资源，同时减少不必要的网络传输和服务器负载。
使用HTTPS协议的缺点是什么？ 使用 HTTPS 协议的缺点包括以下几个方面：
性能开销：与 HTTP 相比，HTTPS 协议由于需要进行加密和解密操作，会增加一些性能开销。这可能会导致页面加载时间稍微延长，尤其是在处理大量请求或传输大量数据时。
证书成本：要使用 HTTPS，网站必须购买和配置安全证书。证书的购买和维护需要一定的成本，特别是对于大型网站或多个域名的情况。
证书管理复杂性：证书需要定期更新和续期，这可能涉及到一些管理工作和成本。同时，如果证书配置不当或过期，可能会导致网站访问出现问题。
兼容性问题：某些旧的或不支持 SSL/TLS 的设备或浏览器可能无法正确地与 HTTPS 网站进行通信。这可能会限制一部分用户的访问。
需要注意的是，尽管存在这些缺点，但 HTTPS 协议的优点远远超过了缺点。它提供了关键的安全性和数据保护功能，确保用户与网站之间传输的数据是加密的，防止窃听和中间人攻击。对于涉及敏感信息的网站，如电子商务、银行、医疗等，使用 HTTPS 是必不可少的。同时，随着技术的不断发展和优化，HTTPS 的性能问题也在逐渐得到改善。
如何解决HTTPS的兼容性问题？ 要解决 HTTPS 的兼容性问题，可以考虑以下几个方面：
支持最新的加密和协议版本：确保服务器和客户端都支持最新的 SSL/TLS 协议版本和加密套件，以提供更好的兼容性。
提供 HTTPS 回退机制：对于不支持 HTTPS 的旧设备或浏览器，可以提供 HTTPS 回退机制，即在检测到不支持 HTTPS 时自动重定向到 HTTP 版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c758808b6a8c206336bb490e0db5031b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fc91d5c61fb38d6b4b7d41aeef4c466/" rel="bookmark">
			redis复习笔记04（小滴课堂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新版SpringBoot2.X项目创建
在线创建springboot项目选择web和redis依赖就行。
SpringBoot2.x整合Redis客户端+单元测试
SpringDataRedis配置RedisTemplate介绍
1.编写配置文件
2.单元测试进行测试：
可以看到我们设置进的值，乱码后面会解决。
获取不到设置的，证明这两个是不共通的。
可以看到区别。
RedisTemplate的序列和反序列化机制讲解
我们发现一个乱码，一个不乱码。
会报错我们没有序列化。
再去运行接口：
自定义序列化和反序列化机制配置实战
使用的时候直接复制粘贴过来即可。
实体类不用实现序列化。
运行测试：
不再乱码了。
可以拿到同样的值了。
SpringBoot整合Jedis+Lettuce客户端连接池配置实战
使用jedis排除lettuce:
配置改成jedis配置：
也可以不这样做。
使用配置文件指定使用哪种方式：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5843ffb4dd647b8e9a803f42d1db21b8/" rel="bookmark">
			计算机基础面试题 |21.精选计算机基础面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤍 前端开发工程师（主业）、技术博主（副业）、已过CET6
🍨 阿珊和她的猫_CSDN个人主页
🕠 牛客高级专题作者、在牛客打造高质量专栏《前端面试必备》
🍚 蓝桥云课签约作者、已在蓝桥云课上架的前后端实战课程《Vue.js 和 Egg.js 开发企业级健康管理项目》、《带你从入门到实战全面掌握 uni-app》
文章目录 如何确保POST请求的数据在传输过程中不会被篡改？在选择请求方法时，是否需要考虑服务器的性能和负载？如何配置服务器以使其有效地利用 HTTP 缓存？ 如何确保POST请求的数据在传输过程中不会被篡改？ 为了确保 POST 请求的数据在传输过程中不会被篡改，可以采取以下几个措施：
使用 HTTPS 协议：HTTPS 是一种安全的网络传输协议，它通过 SSL/TLS 协议对数据进行加密，确保数据在传输过程中不被窃听或篡改。
使用数字签名：数字签名是一种使用非对称加密算法对数据进行签名的技术。发送方使用自己的私钥对数据进行签名，接收方使用发送方的公钥对签名进行验证。如果签名验证通过，说明数据在传输过程中没有被篡改。
使用消息摘要：消息摘要是一种使用哈希函数对数据进行计算得到的固定长度的值。发送方可以将数据和消息摘要一起发送给接收方，接收方使用相同的哈希函数计算数据的摘要，并与发送方发送的摘要进行比较。如果两个摘要相同，说明数据在传输过程中没有被篡改。
使用令牌：令牌是一种由服务器生成的随机字符串，它与用户的会话相关联。在 POST 请求中，发送方可以将令牌作为参数传递给服务器，服务器在处理请求时会验证令牌的合法性。如果令牌无效，说明请求可能被篡改。
使用防篡改库：一些防篡改库可以提供更高级的保护措施，例如使用数字证书、时间戳等技术来确保数据的完整性和不可篡改性。
综合使用以上措施可以大大提高 POST 请求数据的安全性，确保数据在传输过程中不会被篡改。
在选择请求方法时，是否需要考虑服务器的性能和负载？ 在选择请求方法时，需要考虑服务器的性能和负载。不同的请求方法对服务器的资源消耗和处理能力要求不同。
一些请求方法，如 GET，通常用于获取数据，相对来说对服务器的负担较小。它们只是从服务器获取信息，不需要对服务器进行大量的数据处理或修改。
而其他请求方法，如 POST、PUT、DELETE 等，通常涉及到对服务器上的数据进行创建、更新或删除操作。这些操作可能需要更多的服务器资源和处理能力，因为服务器需要执行相应的数据库操作、文件操作或其他复杂的逻辑。
特别是在处理大量并发请求或处理大量数据时，选择合适的请求方法可以对服务器的性能和负载产生重要影响。例如，如果需要批量更新数据，可以考虑使用批量请求或分批处理的方式，以避免对服务器造成过大的负载。
此外，还可以考虑使用缓存机制、优化数据库查询、使用异步处理等技术来提高服务器的性能和处理能力。
因此，在选择请求方法时，需要根据具体的业务需求和服务器的性能特点进行综合考虑，以确保服务器能够高效地处理请求，并提供良好的用户体验。同时，还可以进行性能测试和负载测试，以评估不同请求方法对服务器性能的影响，并做出相应的优化和调整。
如何配置服务器以使其有效地利用 HTTP 缓存？ 为了使服务器有效地利用 HTTP 缓存，可以采取以下配置和优化措施：
设置合适的缓存控制头：在服务器的响应中设置适当的 Cache-Control、Expires 和 ETag 头部，指示浏览器和缓存服务器如何缓存响应。例如，可以设置较长的缓存时间，以便在一段时间内无需再次向服务器请求相同的资源。
利用缓存验证机制：使用 ETag 或 Last-Modified 头部来标识资源的版本或最后修改时间。这样，当客户端再次请求资源时，服务器可以根据这些头部进行缓存验证，只有在资源发生变化时才返回最新的内容。
配置合适的缓存策略：根据不同类型的资源和业务需求，设置适当的缓存策略。例如，可以对静态资源设置较长的缓存时间，而对动态或个性化的内容设置较短的缓存时间或不进行缓存。
优化资源的 URL：使用具有唯一标识符的 URL，以便缓存服务器可以准确地缓存和引用资源。避免使用包含查询参数或会话信息的 URL，因为这些可能导致缓存失效。
考虑代理服务器和 CDN：利用代理服务器或内容分发网络（CDN）来缓存和分发资源。这些中间服务器可以在靠近用户的位置提供缓存服务，减少对源服务器的请求。
监控和优化缓存性能：定期监控缓存的命中率和失效情况，分析缓存的效果和性能。根据实际情况进行调整和优化，以提高缓存的效率和用户体验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5843ffb4dd647b8e9a803f42d1db21b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f5e0a7b444b3fa7c5a72d34a56ff41a/" rel="bookmark">
			海量数据处理数据结构之Hash与布隆过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 随着网络和大数据时代的到来，我们如何从海量的数据中找到我们需要的数据就成为计算机技术中不可获取的一门技术，特别是近年来抖音，快手等热门短视频的兴起，我们如何设计算法来从大量的视频中获取当前最热门的视频信息呢，这就是我们今天即将谈到的Hash和布隆过滤器。以下是Hash和布隆过滤器的一些常见应用：
使用word文档时，如何判断某个单词是否拼写正确？网络爬虫程序时，怎么让它不去爬相同的url页面(将已经爬过的url页面放到数据库中)垃圾邮件过滤算法如何设计？（当多少人将同一封邮件视为垃圾邮件时，就放到数据库中，当其他人在收到相同的邮件时，直接放到垃圾邮箱中）数据库缓存穿透问题如何解决?(对于redis和数据库中都不存在的数据，在服务器端使用布隆过滤器进行过滤掉，如果服务器的布隆过滤器没有过滤掉，则说明数据库可能存在，对于误判的情况，即不存在的数据判断为存在，则在redis中保存为&lt;key,null&gt;,这样就可以防止数据库不存在的数据对应的数据时，就不会去访问数据库了,后面还会提到，这里先提前说明下) 背景 假如我们需要从海量数据中查询某个字符串是否存在？如果让你设计一种数据结构，你会想到哪些数据结构呢？链表和数组(直接排除，查询复杂度为0(n))，二叉树(红黑树，AVL树，时间复杂度o(log（n）)，可以考虑)，平衡多叉树(B树，B+树等，时间复杂度为h.log(n),其中h为树的层高)，Hash(时间复杂度为O(1))，下面分别介绍这些数据结构
平衡二叉树 增删改查时间复杂度为O(logn) ：比如100万个节点，最多比较 20 次；10 亿个节点，最多比较 30 次；
平衡的目的时保证二叉树的左右节点的高度都差不多，这样二叉树才能保证时间复杂度为O(logn),否则最坏的情况，二叉树的时间复杂度为O(n),退化为线性表，插入数据的时候时按顺序插入的。
平衡二叉树是中序遍历有序(左子树的key&lt;根节点的key&lt;右子树的key)，每次比较都能保证到左子树或者右子树，每次都能排除一半的元素达到快速索引的目的.元素的比较是使用的二分查找(每次搜索都能排除一半)，使用到二分查找的结构如下图所示：
有序数组和平衡二叉搜索树使用二分查找无可厚非，对于B树和B+树而言，其实跟平衡二叉搜索树类似，只是B树的一个节点有多个KEY，每个节点有多个孩子，每个节点内的KEY都是有序的。因此在查找KEY位于哪个节点时，也使用到了二分查找，关于跳表的数据结构请参考其他博客。
如果对平衡二叉树和平衡多叉树有兴趣的同学，可以参考我的博客
1.B树和B+树的分析和实现
2.红黑树的分析与实现
散列表 前面提到的平衡二叉树的时间复杂度为O(log(n)),效率还是蛮高的，不过对于像字符串作为的key时而进行比较时，还是比较耗时的，因此有没有一种更高效的算法来完成字符串的比较呢，那就是使用散列表来完成，散列表是使用hash函数将一个key映射到一个数据表中，这样在没有冲突的情况下，根本不需要字符串的比较，只要在查询的时候，如果相应的key映射的下标中存在元素，即可完成数据的查询。
散列表是根据key计算key在表中的位置的数据结构，是 key 和其所在存储地址的映射关系；在插入数据时，需要将散列表的节点中的key和value一起存储到表中。 为什么需要存储key，这时因为在查询时，需要将查询的key和表中的key进行比较，看是否相等，如果不等，则代表这次查询失败(不等，则代表存在哈希冲突，表中的这个位置被其他key所拥有)
hash函数 映射函数 Hash(key)=addr ；hash 函数可能会把两个或两个以上的不同 key 映射到同一地址，这种情况称之为冲突（或者 hash 碰撞）；由于存在冲突情况，因此在选择hash函数时，需要满足以下2个条件，这样才能保证冲突的概率最小化和查询效率。
计算速度快(满足查询效率)强随机分布（等概率、均匀地分布在整个地址空间），这样才能保证hash冲突的概率最小化 通常常用的哈希函数有：murmurhash1，murmurhash2，murmurhash3，siphash（redis6.0当中使⽤，rust等大多数语言选用的hash算法来实现hashmap），cityhash 都具备强随机分布性；测试地址如下：https://github.com/aappleby/smhasher，siphash主要 解决了字符串接近的强随机分布性，作为redis的hash算法时因为，在redis中，经常使用uid:1000和uid:1001这样的key，这2个key很接近，如果使用其他的算法，很可能都映射到同一个地址，而siphash却可以让这2个key映射到不同的地址。
负载因子 数组存储元素的个数 / 数据长度；用来形容散列表的存储密度；负载因子越小，冲突越小，负载因子越大，冲突越大；
冲突处理 不管如何优秀的hash算法，都不可避免的让不同的key映射到同一个地址，那么如何处理这样的情况，即如何处理hash冲突呢。主要有链表法和开发寻址法
链表法 引用链表来处理哈希冲突；也就是将冲突元素用链表链接起来；这也是常用的处理冲突的⽅
式；但是可能出现一种极端情况，冲突元素比较多，该冲突链表过长，这个时候可以将这个
链表转换为红黑树；由原来链表时间复杂度 转换为红黑树时间复杂度 ；那么判断该链表过长的依据是多少？可以采⽤超过 256（经验值）个节点的时候将链表结构转换为红黑树结构；
开放寻址法 将所有的元素都存放在哈希表的数组中，不使用额外的数据结构；一般使用线性探查的思路
解决；
当插入新元素的时，使用哈希函数在哈希表中定位元素位置；检查数组中该槽位索引是否存在元素。如果该槽位为空，则插⼊，否则3；在 2 检测的槽位索引上加一定步长接着检查2； 加⼀定步长分为以下几种： i+1,i+2,i+3,i+4, … ,i+ni- ,i+ ,i- ,1+ , … 这两种都会导致同类 hash 聚集；也就是近似值它的hash
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f5e0a7b444b3fa7c5a72d34a56ff41a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d00b8b83fbbb11622e0653e0221974b/" rel="bookmark">
			js_BOM&amp;Dom&amp;Ajax
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结 讲解自定义对象 在ES5中没有像Java中一样专门的class关键字定义类（ES6中可以用class定义类），所以在ES5中创建类其实和创建函数是一样的语法:
function 对象名/类名/方法名(){ } 一种语法代表了多重含义，在JavaScript中若想清楚的区分定义的到底是方法还是类性质的对象，那么建议方法名称小写，建议类或对象名称首字母大写
一种语法代表了多重含义，在JavaScript中若想清楚的区分定义的到底是方法还是类性质的对象，那么建议方法名称小写，建议类或对象名称首字母大写
类中定义方法，有下列形式：
(1) 通过new的实例化对象添加方法(特点：这种方式添加的方法只属于当前实例) (2) 在对象中使用this关键字(特点：这种方式添加的属性和方法属于所有实例) (3) 通过prototype添加方法(特点：这种动态添加的属性和方法属于所有实例，而且不会影响以前的功能) &lt;body&gt; &lt;!-- 讲解自定义对象 --&gt; &lt;script&gt; function Person() { // 函数名大驼峰是一个对象，小驼峰是函数 // 属性 var name; var age; // 方法 this.getName = function() { return this.name; } this.setName = function(n) { this.name = n; } this.getAge = function() { return this.age; } this.setAge = function(a) { this.age = a; } } // 创建对象 // var person = new Person(); // person.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d00b8b83fbbb11622e0653e0221974b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c115b93a58be8b14fc07c70f35d8fc6/" rel="bookmark">
			jQuery入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jQuery jQuery是继prototype之后一个优秀的开源的JavaScript代码库（或JavaScript框架），它封装JavaScript常用的功能代码。我们首先来看看jquery的核心特点：
(1) 具有独特的链式语法，可以把多个操作写在一行代码里，更加简洁 (2) 拥有大量的选择器，不仅有高效灵活的css选择器【id,类，元素】，并且可对CSS选择器进行扩展 (3) 拥有便捷的插件扩展机制和丰富的插件（树形菜单、日期控件、图片切换插件、弹出窗口等） (4) 这个就厉害了，jQuery兼容各种主流浏览器，包括互联网十大垃圾之一IE6. (5) 很多API都方法化了 jQuery的核心思想：（write less，do more）写得更少，做得更多
引入jQuery &lt;script src="./dist/js/jQuery.js"&gt;&lt;/script&gt; 编写jQuery入口函数即页面加载事件 1.jQuery页面加载事件都会执行，而js中的页面加载事件只会执行最后一个(多个$(function(){})中的代码都会执行，多个window.onload只会执行最后一个) 2.jQuery页面加载事件优先执行($(function(){})比window.onload加载快) 注意：jQuery3.x的不一定比window.onload加载快 &lt;script&gt; //js中的页面加载事件：当整个页面加载完成(节点，样式，图片等)之后才会执行里面的代码 window.onload = function(){ alert(111); } window.onload = function(){ alert(222); } //jQuery页面加载事件：加载时机是节点加载完成就执行了 $().ready(function(){ alert(333); }) jQuery(function(){ alert(444); }); //333 - 444 - 222 &lt;/script&gt; jQuery===$ 在Js中，=先比较类型，再比较值，而jQuery= 返回值为 t r u e 。所以使用 返回值为true。所以使用 返回值为true。所以使用的地方就可以使用jQuery，但是必须jQuery严格区分大小写，写成jquery都不行
之所以这样做得原因是因为其他的js框架也可能使用$符号，那么这时就可以使用jQuery来区分
DOM对象与jQuery对象转换 dom对象: 用js代码获取的对象就是dom对象：通过id，class,标签名等，this,window- dom对象
jQuery对象: 通过 ( ) 和选择器获取的对象就是 j Q u e r y 对象（通过选择器和 ()和选择器获取的对象就是jQuery对象（通过选择器和 ()和选择器获取的对象就是jQuery对象（通过选择器和函数获取的节点对象。实质是通过jQuery包装DOM对象后产生的对象）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c115b93a58be8b14fc07c70f35d8fc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1019cf97d52cadbc525d6c40f5ab4469/" rel="bookmark">
			【深入理解计算机系统 第三版 导读】第六章 存储器的层次结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第六章 存储器的层次结构 文章目录 第六章 存储器的层次结构1. 存储技术1.1. 随机访问存储器1.1.1. 层次结构1.1.2. 随机访问存储器1.1.3. DRAM内存模块 1.2. 磁盘存储1.2.1. 磁盘构造1.2.2. 磁盘容量1.2.3. 磁盘操作1.2.4. 时间估计1.2.5. 练习题 1.3. 固态硬盘 2. 局部性3. 存储器层次结构3.1. 存储器层次结构中的缓存 4. 高速缓存存储器4.1. 通用的高速缓存存储器组织结构4.2. 直接映射高速缓存4.3. 组相联高速缓存4.4. 全相联高速缓存 5. 后记 在本章中我们会看看基本的存储技术——SRAM存储器、DRAM存储器、ROM存储器以及旋转的和固态的硬盘——并描述它们是如何被组织成层次结构的
1. 存储技术 1.1. 随机访问存储器 1.1.1. 层次结构 如果程序需要的数据是存储在CPU寄存器中的，那么在指令的执行期间，在0个时钟周期就可以访问到它们，如果存储在高速缓存中，需要4-75个周期，如果存储在主存中，需要上百个周期，而如果存储在磁盘上，需要大约几千万个周期。
1.1.2. 随机访问存储器 随机访问存储器RAM分为两类：静态的和动态的。静态的SRAM比动态的DRAM更快，但也更贵。SRAM用来作为高速缓存存储器可以在CPU芯片上也可以在片下。一个桌面系统的SRAM不会超过几兆字节，但是DRAM却有几百或几千兆字节。
SRAM：SRAM将每一个位存储在一个双稳态的存储单元里，每个单元是用一个六晶体管电路来实现的。这个电路有一个属性，它可以无限期保持在两个不同电压配置或状态之一。从不稳定的状态开始，电路会迅速转移到两个稳定状态中的一个——双稳态特性，由于SRAM存储器单元具有双稳态特性，只要有电，他就会永远保持它的值(0或1)，即使有干扰，当干扰消除时，电路也会恢复到它的稳定值——抗干扰。
DRAM：DRAM使用非常小的电容来存储每个位，电容的典型值是几十毫微微法拉；由于电容容易漏电所以DRAM需要周期性地刷新来维持存储的数据(计算机运行的时钟周期是以纳秒来衡量的，DRAM漏电是在几十毫秒内)；DRAM 单元由一个晶体管和一个电容组成，因此它能够以更高的密度存储更多的数据，但这也意味着它的速度较慢。
常规的DRAM： 为了读出超单元(i,j)的内容，内存控制器将行地址i(RAS)和列地址j(CAS)发送到DRAM，DRAM把相应的内容发回给控制器作为相应。过程：发送行地址i，然后DRAM将整个行复制到一个内部行缓冲区，再发送列地址j，最后DRAM从内部行缓冲区中复制相应的内容发送到内存控制器（为什么这样设计：DRAM芯片是一个二维的，而不是一个线性的数组，通过这样来获取数据，可以减少芯片上地址引脚的数量，但会增加数据的访问时间）。每个超单元可以存储8bit的数据。
1.1.3. DRAM内存模块 图中展示了一个内存模块，示例用8个DRAM芯片。每个DRAM芯片大小是8M×8，也就是8MB，所以这个内存模块是64MB的。每个超单元可以存储8bit的数据，那么对于8字节的数据就要使用8个超单元来存储。不过这8个超单元并不在同一个DRAM芯片上，而是平均分布在8个DRAM芯片上，其中DRAM0存储低8位，DRAM1存储下一个8位，以此类推。内存控制器需要这些数据时，会发送行地址和列地址，然后内存模块会将行地址和列地址广播到每个DRAM，每个DRAM都会输出它们对应的超单元数据，最终内存模块会将所有超单元的数据合并成一个64bit的数据返回给内存控制器。
1.2. 磁盘存储 前面的随机访问存储器是在有点的情况下才能存储信息，而磁盘存储在断电的情况下也能保存信息。
1.2.1. 磁盘构造 磁盘是由多个盘片构成的，每个盘片都有两面被称为表面，表面覆盖了磁性记录材料。盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转，通常是5400-15000转每分钟(RPM)。磁盘表面存在着一组被称为磁道的同心圆，磁道以主轴为中心向外扩散，每个磁道被分为一组扇区，每个扇区包含相等的数据位，通常是512字节，这些数据被编码在扇区的磁性材料中。扇区之间用一些间隙分隔开，这些间隙中不存储数据位，而是用来存储扇区的格式化位。
1.2.2. 磁盘容量 记录密度：位/英寸 磁道一英寸的段中可以放入的位数。磁道密度：到/英寸 从盘片中心出发半径上一英寸的段内可以有的磁道数。面密度：位/平方英寸 记录密度与磁道密度的乘积。 1.2.3. 磁盘操作 磁盘用读/写头来读写存储在磁性表面的位，读写头在一个传动臂上，它们的运动叫做寻道。一旦读写头定位到了期望的磁道上，那么当磁道上的每一个位通过它下面时，读写头可以感知，也可以修改有多个盘片的磁盘针对于每一个盘面都有一个独立的读写头，读写头垂直排列，一致行动。 1.2.4. 时间估计 对扇区的访问时间有三个主要的部分：寻道时间、旋转时间、传送时间。
寻道时间：平均寻道时间是3~9ms，最高可达20ms。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1019cf97d52cadbc525d6c40f5ab4469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2922e0608a31555dae71fd9d002eff19/" rel="bookmark">
			k8s云原生环境搭建笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、使用kubeadmin方式安装k8s1、准备虚拟机2、安装前置环境（注意：所有虚拟机都执行）2.1、基础环境2.2、docker环境（在所有虚拟机上都执行下列指令即可）2.3、安装k8s核心组件（在所有虚拟机上都执行相同指令即可）2.4、导入k8s所需镜像2.5、导入calico镜像 3、初始化master节点（注意：只能在master节点虚拟机上执行）3.1、确定master节点ip3.2、找到合适的service地址区间、pod地址区间3.3、执行kubeadm init操作3.4、根据初始化结果来执行操作3.4.1、复制相关文件夹3.4.2、导出环境变量3.4.3、导入calico.yaml3.4.4、修改calico.yaml（注意：必须修改）3.4.5、执行calico.yaml 4、初始化worker节点（注意：只能在所有worker节点虚拟机上执行）5、设置ipvs模式（推荐执行，但是不执行也没影响；注意：只能在master节点虚拟机上执行）5.1、设置ipvs模式5.2、找到kube-proxy的pod5.3、删除kube-proxy的pod5.4、查看pod启动情况 6、部署k8s-dashboard（注意：只能在master节点虚拟机上执行）6.1、下载并执行recommended.yaml6.1.1、下载recommended.yaml6.1.2、执行recommended.yaml 6.2、下载并执行dashboard-admin.yaml6.2.1、下载dashboard-admin.yaml6.2.2、执行dashboard-admin.yaml 6.3、找到k8s-dashboard访问端口6.4、访问k8s-dashboard 二、k8s卸载1、只有master节点执行2、master和worker节点都要执行 三、安装其他组件1、安装nfs1.1、master节点安装nfs（说明：可以是其他节点也行）1.2、所有node节点安装nfs 2、安装nfs动态供应2.1、概念2.2、安装步骤（只用在nfs主节点执行）2.2.1、三合一操作（注意：本节操作之后，下面2.2.2、2.2.3、2.2.4就不用操作了）2.2.2、创建存储类（根据自己要求设置，可以设置多个）2.2.3、设置供应商信息2.2.4、设置rbac权限 2.3、验证 3、安装helm3.1、helm安装包3.2、解压3.3、移动3.4、验证3.5、添加repo仓库 4、安装prometheus和grafana4.1、charts下载4.2、修改values.yaml4.3、导入镜像4.4、创建命名空间4.5、安装4.6、保证pod运行完好4.7、改变prometheus、grafana的service暴露方式4.8、使用浏览器访问prometheus、grafana4.9、在grafana中导入查看k8s集群信息的dashboard页面 5、安装harbor5.1、charts下载5.2、修改values.yaml5.3、导入镜像5.4、创建命名空间5.5、安装5.6、保证pod运行完好5.7、使用浏览器访问harbor5.8、在linux上使用docker login XXX方式登录harbor注意事项操作步骤5.8.1、更改所有节点的daemon.json5.8.2、重启docker5.8.3、测试在linux上登录harbor 5.9、测试通过docker命令推送镜像到harbor5.10、测试通过docker命令从harbor仓库下载镜像 6、安装jenkins6.1、导入镜像6.2、创建jenkins.yaml6.3、应用jenkins.yaml6.4、访问jenkins6.5、解锁 Jenkins6.6、插件下载6.7、创建第一个管理员用户6.8、实例配置6.9、更改jenkins插件镜像源6.10、使用public over ssh插件完成jenkins构建全过程6.10.1、安装publish over ssh插件6.10.2、配置ssh连接信息6.10.3、把相关项目奉上6.10.4、先来观察JenkinsFile文件内容6.10.5、再来观察YamlStatefulSet.yaml文件内容6.10.6、再来观察Dockerfile文件内容6.10.7、再来观察application.properties文件内容6.10.8、剩余操作 7、使用docker安装Kuboard7.1、安装文档7.2、安装命令7.3、登录kuboard7.4、添加k8s集群到kuboard 8、使用k8s安装gitlab9、安装单机版mysql9.1、创建名称空间9.2、创建mysql5.79.2.1、创建ConfigMap9.2.2、创建mysql的Service 9.3、创建mysql8.0.2 10、安装minIO10.1、单机版10.2、集群版10.2.1、注意点10.2.2、yaml 11、安装rabbitmq11.1、单机版11.2、集群版 12、安装redis12.1、单机版 13、安装nacos13.1、集群版13.1.1、创建nacos数据库13.1.2、创建nacos13.1.3、访问nacos 14、安装sonar14.1、单机版14.1.1、安装sonar-db14.1.2、安装sonarqube 15、单机版mongodb安装16、单机版Elasticsearch安装16.1、ES7简单安装16.2、ES8简单安装16.3、ES8全面安装 17、安装nexus18、安装onlyoffice19、常用缩写20、常用命令 一、使用kubeadmin方式安装k8s 1、准备虚拟机 2台虚拟机即可，一台做master节点，另外一台做worker节点不会安装的可以看这个：在VMvare中安装CentOS，建议安装centos7
安装之后需要配置静态ip和语言，记得先切换root用户（CentOS如何切换超级用户/root用户），然后根据以下文章配置即可：
Centos的英文环境设置为中文，并修改时区为亚洲上海CentOS配置静态IP 2、安装前置环境（注意：所有虚拟机都执行） 2.1、基础环境 修改虚拟机名称（注意：每个虚拟机单独执行，不能是localhost，每个虚拟机的主机名称必须不同，比如可以是k8s-01、k8s-02……）：
# 例如：hostnamectl set-hostname k8s-01 hostnamectl set-hostname 主机名称 修改其他配置，直接复制执行即可（注意：在所有虚拟机上都执行相同指令即可）
######################################################################### #关闭防火墙： 如果是云服务器，需要设置安全组策略放行端口 # https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#check-required-ports systemctl stop firewalld systemctl disable firewalld # 查看修改结果 hostnamectl status # 设置 hostname 解析 echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2922e0608a31555dae71fd9d002eff19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d24655099289d01489458ef2f7d5fb/" rel="bookmark">
			git 上传小知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git init git add .
git commit -m "存储到本地仓库中去" （将内容存储到本地master分支）
git push -u origin master “上传到远程master分支上”
如若要写login登录页，假设此时是在新分支上写的
git checkout -b login （在本地创建并且切换到本地login分支上）
写完login分支之后
git add .
git commit -m “完成简单的login界面” （将内容存储到本地的login分支上去）
注意此时远程仓库还是只有一个默认的master分支
此时：
git push -u origin login （远程上会自动出现远程的login分支用于提交本地login分支的内容）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12431996ed05b67a0c4f6b14362523f2/" rel="bookmark">
			win7添加access的odbc数据源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从控制面板打开odbc数据源；如果像下面没有access的驱动程序，
根据资料，打开C盘-Windows-SysWow64-odbcad32.exe，看一下就有了；
然后添加用户DSN，选中access的驱动程序，
自己输入一个数据源名，连接数据库的时候将使用此名称；说明写对此数据源的注释；然后选中一个access数据库，这里是.mdb的，确定；
然后就有了一个用户DSN；用户DSN只对当前用户可见；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e95b7b0f2b9c3b85402fa7d82b2a5a71/" rel="bookmark">
			【ASP.NET Core 基础知识】--MVC框架--Views和Razor语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Views和Razor语法基础 1.1 Views概述 在ASP.NET Core的MVC（Model-View-Controller）框架中，View 扮演着呈现用户界面的角色。View负责展示应用程序的数据给用户，并接收用户的输入。它与Model和Controller协同工作，通过模型绑定从Controller获取数据，然后使用Razor语法或其他视图引擎将数据呈现为用户可见的HTML。
视图的作用
数据呈现： 主要职责是将数据从Controller层传递到用户界面，展示给用户。这包括显示数据库查询结果、业务逻辑计算的输出等。用户交互： Views能够接收用户的输入，并将用户的请求传递给Controller层进行处理。这使得用户能够与应用程序进行交互，例如填写表单、点击按钮等。 Razor语法
在ASP.NET Core中，主要使用Razor作为默认的视图引擎。Razor语法是一种简洁且强大的语法，它允许在HTML中嵌入C#代码，使得在视图中能够方便地处理数据和逻辑。以下是Razor语法的一些基本特征：
代码块： 使用 @ 符号表示C#代码块，可以在HTML中嵌入C#逻辑。&lt;p&gt;Total items: @Model.Items.Count&lt;/p&gt; 变量和表达式： 使用 @ 符号表示C#表达式，可以直接在HTML中输出变量的值。&lt;p&gt;Welcome, @User.Name!&lt;/p&gt; 循环和条件语句： 使用C#的循环和条件语句来实现动态的HTML生成。@foreach (var item in Model.Items) { &lt;li&gt;@item.Name&lt;/li&gt; } 视图文件结构
在ASP.NET Core中，Views通常存放在项目的特定文件夹中（例如Views文件夹），并按照Controller的结构进行组织。每个Controller都有一个对应的文件夹，其中包含该Controller的所有视图。
视图布局
Views支持布局，可以使用主布局文件（_Layout.cshtml）定义整个应用程序的共同结构。通过使用布局，可以实现页面的一致性和重用。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;@ViewBag.Title - My ASP.NET Core App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="header"&gt; &lt;!-- Header content --&gt; &lt;/div&gt; &lt;div id="main"&gt; @RenderBody() &lt;/div&gt; &lt;div id="footer"&gt; &lt;!-- Footer content --&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e95b7b0f2b9c3b85402fa7d82b2a5a71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e662d5aecbf9e05ec3000a54ce0cbfd/" rel="bookmark">
			QT上位机开发（键盘绘图控制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【 声明：版权所有，欢迎转载，请勿用于商业用途。 联系信箱：feixiaoxing @163.com】
绘图是qt很基础的一个功能。通常，我们进行qt绘图的时候，一般会先创建一个qt view，这个相当于视图。接着创建一个场景scene，场景和视图是一对多的关系，比如相同的场景可以正着看、反着看、旋转着看等等，这样就会有多个view。有了场景之后呢，我们就可以在上面添加物体了，这个物体就是各种各样形状的内容。今天，我们借着键盘绘图的需求，看下qt下面view-scene-item是怎么一个情况。
1、首先创建一个widget工程 widget工程是我们开发的一个基础，虽然里面的代码基本不用，但是需要这样的一个基本框架。
2、接着创建绘制的物体 绘制的物体一般都要继承QGraphicsPolygonItem，后期这个类就会被添加到scene当中。因为本次的需求是响应各种按键功能，所以还要重写一下keyPressEvent函数。
#include &lt;QApplication&gt; #include &lt;QGraphicsView&gt; #include &lt;QGraphicsScene&gt; #include &lt;QGraphicsPolygonItem&gt; #include &lt;QKeyEvent&gt; class TriangleItem : public QGraphicsPolygonItem { public: TriangleItem(QGraphicsItem* parent = nullptr) : QGraphicsPolygonItem(parent) { QPolygonF triangle; triangle &lt;&lt; QPointF(0, -50) &lt;&lt; QPointF(25, 25) &lt;&lt; QPointF(-25, 25); setPolygon(triangle); } ~TriangleItem() {} void keyPressEvent(QKeyEvent* event) override { QPointF currentPosition = pos(); switch (event-&gt;key()) { case Qt::Key_Up: currentPosition.setY(currentPosition.y() - 10); break; case Qt::Key_Down: currentPosition.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e662d5aecbf9e05ec3000a54ce0cbfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0e16c4014da81c2293959122878e4aa/" rel="bookmark">
			听GPT 讲Rust Cargo源代码(3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注！
File: cargo/src/bin/cargo/commands/fix.rs 在Rust Cargo的源代码中，cargo/src/bin/cargo/commands/fix.rs文件的作用是实现了cargo fix命令。cargo fix命令用于自动修复源代码中的一些错误和不规范的代码风格，以提高代码的可读性、可维护性和性能。
具体而言，fix.rs文件中的代码实现了以下功能：
导入依赖：首先，会导入一些必要的依赖包，例如cargo::core::Workspace和cargo::util::important_paths等。
参数解析：解析并处理命令行参数，获取要修复的代码路径、修复的级别、是否输出详细信息等。
初始化工作空间：通过调用Workspace::new方法，初始化一个工作空间，表示待修复的代码项目。
获取待修复的 crate 标识符：通过调用workspace.current()方法获取当前代码项目的 crate 标识符。这个标识符会用于后续的操作，例如构建、编译等。
构建代码：调用prepare()方法，构建待修复的代码项目。这个过程会检查是否有更新的依赖包、是否需要重新编译等。
根据修复级别执行修复：根据解析得到的修复级别参数，调用不同的修复函数。例如，如果修复级别是high，则调用cargo_fixer::fix方法来执行高级别的修复操作。修复操作可能包括修改错误用法、改进代码风格等。
输出修复结果：根据需要，输出修复结果的详细信息。例如，如果设置了输出详细信息的参数，则会打印修复过程中的详细日志。
总体而言，cargo/src/bin/cargo/commands/fix.rs文件实现了cargo fix命令的主要逻辑。它通过解析命令行参数，初始化工作空间，构建代码项目，并根据修复级别执行修复操作。其目的是为了提供给开发者一种便捷的方式来自动修复源代码中的一些常见问题。
File: cargo/src/bin/cargo/commands/clean.rs cargo/src/bin/cargo/commands/clean.rs 这个文件是 Rust Cargo 工具中的一个命令文件，它实现了 cargo clean 命令的功能。cargo clean 命令用于清理当前项目的构建输出和临时文件。
在 clean.rs 文件中，主要完成以下几个任务：
获取命令行参数和配置：首先，该文件会调用 App 结构体创建命令行应用程序，定义了 clean 命令的名称、版本、用法和描述等信息。然后，通过 args 函数解析命令行参数，并读取配置文件中的相关配置。
构建清理目标列表：接下来，main 函数通过调用 clean 函数来构建清理目标列表。clean 函数会遍历当前项目中的所有包，并根据其类型和配置，构建需要清理的目标列表。清理目标主要包括项目的构建目录、生成的二进制可执行文件、生成的库文件和临时文件等。
执行清理操作：最后，main 函数会遍历清理目标列表，并逐个执行清理操作。清理操作主要包括删除文件和目录，调用系统命令来清理构建产物。
总体来说，clean.rs 文件通过定义 cargo clean 命令的行为和逻辑，实现了清理当前项目构建输出和临时文件的功能。通过调用系统命令和删除文件操作，清理产物可以帮助用户节省磁盘空间，并确保项目在下一次构建时从头开始。
File: cargo/src/bin/cargo/commands/report.rs 在Rust Cargo的源代码中，cargo/src/bin/cargo/commands/report.rs文件的作用是定义了cargo report命令的行为和处理逻辑。cargo report命令用于生成有关当前项目的统计报告。
该文件首先导入了一些必要的库和模块，并定义了一个cargo_report函数作为cargo report命令的入口点。cargo_report函数使用clap库创建和定义了cargo report命令的参数和用法说明。
在参数和用法被定义之后，函数会通过ArgMatches结构体获取用户输入的参数和选项，并根据不同的参数执行相应的操作。例如，用户可以选择生成带有依赖关系的报告或只生成带有包名称和版本号的报告。
此后，函数会调用report函数来生成报告。report函数会根据用户选择生成不同类型的报告。生成报告的过程包括遍历当前项目的依赖关系、版本号等信息，并将这些信息格式化为指定的报告格式。最后，生成的报告会输出到标准输出流或写入到指定的文件中。
除了生成报告，cargo_report函数还实现了一些其他功能。例如，当用户没有指定要生成的报告类型时，函数会打印错误信息并提供帮助信息。在处理过程中，函数还会处理一些异常情况，并打印相应的错误信息。
总之，cargo/src/bin/cargo/commands/report.rs文件的作用是定义了cargo report命令的行为和处理逻辑，负责生成有关当前项目的统计报告，并提供了相应的参数和选项供用户选择报告类型和输出方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0e16c4014da81c2293959122878e4aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e47f9d8161a07edcb28d27c5e7c19620/" rel="bookmark">
			听GPT 讲Rust Cargo源代码(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注！
File: cargo/crates/mdman/src/main.rs 在Rust Cargo的源代码中，cargo/crates/mdman/src/main.rs这个文件的作用是实现了一个用于管理Markdown文件的命令行工具。从命名可以看出，mdman是Markdown Manager的意思。
该文件中定义的struct和enum是实现mdman命令行工具所需的选项，也就是Options。在这个文件中，定义了几个不同的Options结构体，用于表示不同的命令行选项和参数。
Options: 这是一个顶层的Options结构体，表示mdman命令行工具的选项。它包含了全局的选项，如--version（显示版本号）和--help（显示帮助信息）。
InitOptions: 这个结构体表示init命令的选项，用于初始化一个新的Markdown文档仓库。它包含了一些初始化参数，如仓库的路径和可选的作者和描述信息。
NewOptions: 这个结构体表示new命令的选项，用于创建一个新的Markdown文件。它包含了文件名和文件所属的目录路径。
OpenOptions: 这个结构体表示open命令的选项，用于打开一个Markdown文件。它包含了文件名和可选的编辑器选项。
EditOptions: 这个结构体表示edit命令的选项，用于编辑一个Markdown文件。它也包含了文件名和可选的编辑器选项。
CompileOptions: 这个结构体表示compile命令的选项，用于编译Markdown文件为其他格式的文件。它包含了文件名和可选的输出格式选项。
通过定义这些不同的Options结构体，我们可以根据不同的命令行参数解析和处理对应的选项。这使得mdman命令行工具具有了较好的灵活性和可扩展性。
File: cargo/crates/mdman/src/hbs.rs 在Rust Cargo的源代码中，cargo/crates/mdman/src/hbs.rs这个文件的作用是处理Handlebars模板引擎相关的辅助功能。Handlebars是一个Rust库，用于生成动态内容的模板引擎。
该文件中定义了三个struct：OptionsHelper&lt;'a&gt;、OptionHelper&lt;'a&gt;和ManLinkHelper&lt;'a&gt;。
OptionsHelper&lt;'a&gt;：这个结构体是用来处理命令行选项的辅助功能。它包含了设置和获取命令行选项的各种方法，如add_flag、add_option等。通过使用OptionsHelper&lt;'a&gt;，可以更方便地管理和处理命令行选项。
OptionHelper&lt;'a&gt;：这个结构体是用于处理命令行选项的帮助信息的辅助功能。它提供了生成帮助消息、生成版本信息等方法。OptionHelper&lt;'a&gt;使得生成命令行帮助信息更加简单。
ManLinkHelper&lt;'a&gt;：这个结构体是用于生成man页链接的辅助功能。它包含了生成链接、转义文本等方法。ManLinkHelper&lt;'a&gt;可以用来在生成man页的过程中，处理和生成合适的链接和文本。这样，使用ManLinkHelper&lt;'a&gt;可以更方便地生成规范和易读的man页链接。
总之，cargo/crates/mdman/src/hbs.rs是一个辅助功能文件，用于处理Handlebars模板引擎相关的功能。OptionsHelper、OptionHelper和ManLinkHelper这三个struct则分别提供了处理命令行选项、生成帮助信息以及生成man页链接的辅助方法。这些辅助方法通过封装底层的逻辑，使得使用Handlebars模板引擎更加方便和简单。
File: cargo/crates/mdman/src/format/man.rs 在Rust Cargo的源代码中，cargo/crates/mdman/src/format/man.rs文件的作用是实现了对Markdown文档生成man页格式的功能。Man页是一种Unix系统中的文档格式，主要用于手册页的格式化和显示。
ManFormatter是一个结构体，实现了Formatter trait，并提供了将Markdown文档格式化为man页格式的功能。它定义了各种markdown元素如标题、段落、代码块、列表等在man页中的显示方式，并提供了相关操作的实现。
ManRenderer&lt;'e&gt;是一个结构体，它实现了Renderer trait，并负责将解析后的Markdown文档渲染到man页输出文件中。它处理了文档的各种元素，如标题、段落、代码块、列表等，并使用ManFormatter进行格式化。
Font是一个枚举类型，定义了在man页中的不同字体样式。它包括Italic（斜体）、Bold（粗体）和Underline（下划线）三种字体样式，用于在man页中标识文本的不同格式。
总之，ManFormatter是实现Markdown文档格式化为man页格式的工具，ManRenderer负责将渲染后的结果写入man页文件，而Font则定义了在man页中不同字体样式的表示方式。这些结构体和枚举类型的协作使得Cargo可以将Markdown文档生成为适合Unix系统中man页格式的文档。
File: cargo/crates/mdman/src/format/text.rs 在Rust Cargo的源代码中，cargo/crates/mdman/src/format/text.rs文件是用于定义文本格式的文件。它包含了TextFormatter、TextRenderer和Table三个结构体。
TextFormatter结构体是一个用于格式化文本的工具，它实现了从AST（抽象语法树）生成文本的功能。它将AST中的标记转换为相应的文本格式，并处理了行的缩进、对齐等格式要求。通过TextFormatter，可以将AST转换成可读性强的文本输出。
TextRenderer是一个文本渲染器，它负责将格式化后的文本输出到指定的输出设备，例如终端或文件。TextRenderer中包含了一个TextFormatter实例，并提供了一些方法来渲染和显示文本。
Table结构体是一个用于呈现表格形式的结构。它实现了在终端上输出格式化的表格，并提供了一些方法来定义表头、列宽、填充内容等。通过Table，可以将数据以表格形式展示出来，使其更易读和理解。
这些结构体共同协作，用于将AST表示的Markdown文档转换为可读的文本输出，并提供了适当的格式化和渲染功能，以便用户可以在终端或其他输出设备上正确显示文本。
File: cargo/crates/mdman/src/format/md.rs 在Rust Cargo的源代码中，cargo/crates/mdman/src/format/md.rs文件的作用是定义Markdown格式器（MdFormatter），该格式器用于格式化Markdown文本。
MdFormatter结构体是格式器的主要结构体，它具有以下作用：
实现了MdWriter trait：MdFormatter包含了一个内部的实现了MdWriter trait（Markdown写入器）的结构体Writer。MdWriter trait 定义了可以向Markdown文本中写入各种元素的方法。 提供了创建MdFormatter实例的函数：MdFormatter结构体提供了一个new()函数，可用于创建MdFormatter实例。该函数接受一个io::Write trait的实现类型作为参数，用于指定输出流。通过传递io::stdout()或其他实现了io::Write的类型，可以输出到标准输出或其他文件中。 定义了各种格式化Markdown元素的方法：MdFormatter结构体实现了MdWriter trait 中定义的方法，用于格式化Markdown文本中的不同元素，如标题、段落、列表、代码块等。例如，MdFormatter结构体中定义了write_heading()方法，用于写入Markdown标题。 除了MdFormatter结构体，md.rs文件还定义了其他辅助结构体和函数，以支持Markdown的格式化和写入。以下是MdFormatter文件中的一些重要结构体和函数：
Writer：内部结构体，实现了MdWriter trait的方法，用于将Markdown元素写入到指定的输出流。 MdLink：结构体，表示一个Markdown链接元素。包含链接的文本、URL和可选的标题。 MdFormatter::new()：函数，用于创建MdFormatter实例。 MdFormatter::write_paragraph()：方法，用于向Markdown文本中写入段落。 MdFormatter::write_heading()：方法，用于向Markdown文本中写入标题。 MdFormatter::write_list()：方法，用于向Markdown文本中写入列表。 MdFormatter::write_code_block()：方法，用于向Markdown文本中写入代码块。 通过使用MdFormatter结构体和相关函数，开发者可以方便地在Cargo中格式化和写入Markdown文本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e47f9d8161a07edcb28d27c5e7c19620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7f04fc199b7b8e6f177563fdf2b0a57/" rel="bookmark">
			听GPT 讲Rust Cargo源代码(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注！
File: cargo/build.rs 在Rust Cargo的源代码中，cargo/build.rs这个文件是一个常见的Cargo Build脚本，用于在构建过程中自定义构建行为。该文件的作用是在运行cargo build命令时自动执行一些额外的任务。
首先，cargo/build.rs文件是一个Rust源文件，其中包含一些特定的注释和代码。它通常位于项目的根目录下，并在Cargo.toml文件中通过build字段进行配置。当执行cargo build命令时，Cargo会在构建过程的某个阶段编译和运行build.rs文件。
cargo/build.rs文件常用于执行以下任务：
环境变量设置：可以在build.rs文件中设置环境变量，用于在构建过程中指定编译器参数、目标平台等信息。这些环境变量在后续的编译过程中被Cargo使用。
构建脚本生成代码：build.rs文件可以用于生成一些源代码，这些源代码可以在构建过程中被编译并链接到最终的可执行文件中。这对于自动生成一些常量、配置文件等非常有用。
第三方构建工具的调用：build.rs文件支持调用其他构建工具和脚本，以执行一些额外的构建任务。例如，可以在构建过程中调用CMake或Make等工具来生成一些原生依赖文件。
构建警告和错误检查：build.rs文件可以用于执行一些额外的代码检查，以捕获潜在的错误和问题。例如，可以使用Clippy或rustfmt等工具来检查代码规范和风格问题。
条件性构建：build.rs文件可以根据一些条件来选择性地执行某些构建任务。例如，可以根据不同的操作系统或目标平台来执行不同的构建逻辑。
总结来说，cargo/build.rs文件是Rust Cargo中的一个重要组成部分，用于自定义构建过程中的一些任务。它使开发者能够更灵活地控制构建过程，并在需要时自动执行一些额外的构建任务。
File: cargo/credential/cargo-credential-1password/src/main.rs cargo/credential/cargo-credential-1password/src/main.rs是Rust Cargo的源代码中的一个文件，它的作用是实现与1Password凭据管理器之间的交互。
其中，OnePasswordKeychain结构体是1Password凭据管理器的抽象表示。它允许用户将其1Password账户与Cargo进行集成，并使用其凭据进行身份验证。
Login结构体代表一个1Password登录凭据，包含有关登录的详细信息，如用户名和密码。
Field结构体表示1Password中某一项的字段，包含有关字段的名称和值。
ListItem结构体表示1Password中的一个列表项，包含有关该项的详细信息。
Url结构体用于表示一个1Password中的URL，包含有关该URL的信息。
OnePasswordCredential结构体表示一个1Password凭据，包含有关该凭据的信息，如标题、标签和登录凭据等。
这些结构体的作用是为了在Rust Cargo和1Password之间进行数据交换，并提供在Cargo项目中配置和使用1Password凭据的功能。其中，OnePasswordKeychain负责管理凭据的读取和写入，Login和Field等结构体则用于封装1Password中的各种信息，以便在Cargo中使用。
File: cargo/credential/cargo-credential-wincred/src/lib.rs cargo-credential-wincred/src/lib.rs 是 Cargo 的源代码中的 wincred 身份验证程序的实现文件。
在 Windows 操作系统上，Cargo 使用 wincred 身份验证程序来存储和管理用户的凭据，以便进行身份验证。该文件中包含了用于管理这些凭据的代码。
在该文件中定义了几个结构体，其中最重要的是 WindowsCredential 结构体。WindowsCredential 结构体用于表示一个 Windows 凭据对象，它包含了凭据的各种属性和方法。具体来说：
WindowsCredential 结构体具有属性，用于存储凭据的用户名、密码、目标等信息。这些属性可以被访问和设置。
WindowsCredential 结构体实现了一些方法，比如 save()、load()、delete() 等。这些方法用于将凭据保存到 Windows 凭据管理器中、从凭据管理器中加载凭据、从凭据管理器中删除凭据等。
除了 WindowsCredential 结构体，该文件还定义了其他一些辅助结构体和函数，用于支持凭据的管理和操作。
总结起来，cargo-credential-wincred/src/lib.rs 文件的作用是实现了一个用于管理 Windows 凭据的身份验证程序。WindowsCredential 结构体用于表示和操作 Windows 凭据，提供了各种方法来管理凭据的存储和获取。
File: cargo/credential/cargo-credential-macos-keychain/src/lib.rs 在Rust Cargo的源代码中，cargo-credential-macos-keychain模块是用于处理macOS上的密钥链凭据的。它的作用是提供一个实现，用于在macOS上访问和管理密钥链存储中的身份验证凭据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7f04fc199b7b8e6f177563fdf2b0a57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/552f52911c7c05a510c8ef55f4e65c4c/" rel="bookmark">
			基于java的私人牙科诊所管理系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java的私人牙科诊所管理系统设计与实现
I. 引言 A.研究背景和动机 基于java的私人牙科诊所管理系统设计与实现的研究背景和动机，主要是为了满足私人牙科诊所日常管理和服务需求，提高诊所管理效率和患者就诊体验。随着人们生活水平的提高，对口腔健康的需求也越来越高，而私人牙科诊所作为口腔医疗服务的主要形式之一，其管理效率和患者就诊体验的提高也成为了当务之急。
因此，基于java的私人牙科诊所管理系统设计与实现就显得尤为重要。该系统可以实现诊所管理、患者预约、就诊记录、处方管理、药品管理等功能，为牙科诊所提供全方位的管理和服务支持。通过该系统，牙科诊所可以更好地管理患者信息、处方信息和药品信息，提高管理效率，为患者提供更好的就诊体验。
同时，基于java的私人牙科诊所管理系统还可以实现数据共享和权限控制，为牙科诊所提供更安全、更可靠的管理支持。通过该系统，牙科诊所可以更好地管理患者信息、处方信息和药品信息，提高管理效率，为患者提供更好的就诊体验。
综上所述，基于java的私人牙科诊所管理系统设计与实现的研究背景和动机，是为了满足私人牙科诊所日常管理和服务需求，提高诊所管理效率和患者就诊体验。该系统可以实现诊所管理、患者预约、就诊记录、处方管理、药品管理等功能，为牙科诊所提供全方位的管理和服务支持。通过该系统，牙科诊所可以更好地管理患者信息、处方信息和药品信息，提高管理效率，为患者提供更好的就诊体验。
B.目标和意义 基于Java的私人牙科诊所管理系统设计与实现的目标和意义是提高牙科诊所的管理效率，降低成本，为患者提供更安全、更优质的医疗服务。该系统包括牙科诊所的预约管理、患者管理、药品管理、医疗记录管理、财务管理等多个方面，具有极高的实用价值和市场竞争力。该系统采用高效的云计算技术，能够实现数据的安全存储和共享，为牙科诊所的经营提供了有力的支持。同时，该系统还具有灵活的扩展性和可定制性，能够满足不同牙科诊所的个性化需求。
II. 相关技术和工具 A.Java语言 Java语言是一种高级编程语言，由Sun Microsystems（现在是Oracle公司）于1995年发布。它是一种面向对象的语言，拥有丰富的类库和API，被广泛应用于Web开发、移动应用开发和企业应用开发领域。Java语言的主要特点是简单易学、跨平台性、面向对象、内存管理、多线程支持和安全性。
Java语言简单易学是其最受欢迎的特点之一。与其它编程语言相比，Java语言的语法非常清晰、简洁，容易学习和理解。此外，Java语言还拥有丰富的类库和API，可以轻松实现各种功能和操作。
Java语言的跨平台性也是其受欢迎的原因之一。Java虚拟机（JVM）可以在不同的操作系统和硬件架构上运行Java程序，使得Java程序可以在不同的环境下运行。这种跨平台性使得Java程序可以轻松地移植到不同的操作系统和硬件上。
面向对象是Java语言的第三个主要特点。Java语言是一种真正的面向对象编程语言，它支持封装、继承和多态等面向对象的概念。这种面向对象的编程方式使得Java程序具有更好的结构化、可读性和可维护性。
内存管理是Java语言的第四个主要特点。Java语言支持自动垃圾回收机制，可以自动管理内存资源，从而避免了内存泄漏和野指针等问题。这种内存管理方式使得Java程序更加高效、稳定和安全。
多线程支持是Java语言的第五个主要特点。Java语言支持多线程编程，可以同时执行多个线程，从而提高程序的性能和响应能力。此外，Java语言还支持锁、条件变量和线程同步等机制，可以保证线程的安全性和稳定性。
安全性是Java语言的第六个主要特点。Java语言对安全性有着很高的重视，在设计上考虑了各种安全因素，如通过字节码验证、安全管理器等机制来防止恶意代码的执行。此外，Java语言还支持加密和身份验证等机制，可以保护程序的安全性和稳定性。
综上所述，Java语言是一种简单易学、跨平台性、面向对象、内存管理、多线程支持和安全性极高的编程语言。它拥有丰富的类库和API，可以轻松实现各种功能和操作。在Web开发、移动应用开发和企业应用开发等领域，Java语言已经成为了首选的编程语言之一。
B.数据库技术 数据库技术是一种用于存储、管理和操作数据的技术。它能够让多个用户共享和访问同一份数据，并支持数据的安全性和完整性。数据库技术是一种非常强大的工具，能够帮助我们解决各种问题，例如数据存储、数据查询、数据分析等等。
数据库技术分为两种类型：关系型数据库和非关系型数据库。关系型数据库是指一种基于表格结构的数据库，它能够支持数据的完整性、一致性和可靠性。非关系型数据库则是指一种没有固定结构的数据存储方式，它能够支持数据的灵活性和可扩展性。
关系型数据库是一种非常流行的数据库类型，它通常被用于企业级应用和大型系统。例如，MySQL、Oracle和Microsoft SQL Server等都是关系型数据库的典型代表。这些数据库支持数据的安全性、完整性和可扩展性，并且能够支持高并发和高吞吐量的应用。
非关系型数据库则通常被用于小型应用和移动设备等场景。例如，MongoDB、Cassandra和Redis等都是非关系型数据库的典型代表。这些数据库支持数据的灵活性和可扩展性，并且能够支持高并发和高吞吐量的应用。
无论选择哪种类型的数据库，都需要注意数据的安全性和完整性。为了保证数据的安全性，我们需要采取各种措施，例如数据加密、访问控制、备份和恢复等等。为了保证数据的完整性，我们需要采取各种措施，例如数据备份、数据同步和数据一致性等等。
总之，数据库技术是一种非常重要的技术，它能够帮助我们解决各种问题，并且能够支持各种应用场景。在选择数据库技术时，我们需要根据自己的需求和应用场景来选择合适的技术，并且需要注意数据的安全性和完整性。
C.GUI技术 GUI（Graphical User Interface，图形用户界面）技术是现代软件开发中不可或缺的一部分。GUI技术可以让用户通过图形化的界面与计算机进行交互，从而更加方便快捷地完成各种任务。
在GUI技术中，最基本的组件是窗口。窗口是GUI系统中的基本元素，用户可以通过窗口来完成各种操作，例如打开文件、查看文本、播放音乐等等。
除了窗口之外，GUI技术还包括菜单、按钮、文本框、标签、列表等等。这些组件可以通过组合使用来创建各种复杂的界面，例如系统登录界面、文本编辑器界面、浏览器界面等等。
除了这些基本的组件之外，GUI技术还包括各种其他的特性，例如窗口大小调整、菜单折叠、鼠标悬停等等。这些特性可以让用户更加方便地完成各种任务，例如调整窗口大小、打开或关闭菜单、查看或编辑文本等等。
总之，GUI技术是现代软件开发中不可或缺的一部分。通过使用GUI技术，用户可以更加方便快捷地完成各种任务，从而提高工作效率和生活品质。
III. 系统需求分析与设计 A.系统功能需求 基于Java的私人牙科诊所管理系统设计与实现的系统功能需求主要包括以下几个方面：
用户管理：包括用户信息的注册、登录、修改、删除等操作。预约管理：用户可以预约牙科诊疗时间，预约成功后可以收到预约确认信息。诊室管理：管理牙科诊室的信息，包括诊室名称、地址、医生信息等。治疗管理：包括患者信息的录入、修改、删除等操作，包括治疗过程的跟踪和管理。财务管理：包括患者就诊的收费管理、医保卡管理等。数据备份：定期备份系统数据，保证数据的安全性。数据安全：采用数据加密技术，保证数据的安全性。数据可视化：将数据可视化，方便用户查看和管理。 B.业务流程分析 基于Java的私人牙科诊所管理系统设计与实现的业务流程分析，首先需要设计数据库结构，包括牙科诊所信息、患者信息、药品信息等。然后需要设计系统界面，包括登录界面、预约界面、就诊界面等。接下来，需要编写系统代码，包括数据访问层、业务逻辑层、用户界面层等。最后，需要测试和调试代码，确保系统的稳定性和安全性。
C.数据库设计 牙科诊所管理系统数据库设计
一、表结构
Patient（患者）表 PatientID：患者ID，主键Name：患者姓名Age：患者年龄Gender：患者性别Phone：患者联系电话Email：患者邮箱Address：患者住址 Treatment（治疗）表 TreatmentID：治疗ID，主键TreatmentName：治疗名称Price：治疗价格TreatmentPic：治疗图片 Visit（就诊）表 VisitID：就诊ID，主键PatientID：患者ID，外键TreatmentID：治疗ID，外键VisitTime：就诊时间VisitPic：就诊图片 Order（订单）表 OrderID：订单ID，主键TreatmentID：治疗ID，外键OrderTime：订单时间OrderPic：订单图片 Doctor（医生）表 DoctorID：医生ID，主键Name：医生姓名Age：医生年龄Gender：医生性别Phone：医生联系电话Email：医生邮箱Address：医生住址
二、关系 Patient（患者）表与Doctor（医生）表的外键关系： 医生可以给患者提供治疗服务 Treatment（治疗）表与Doctor（医生）表的外键关系： 医生可以为患者提供治疗服务 Visit（就诊）表与Doctor（医生）表的外键关系： 医生可以为患者提供就诊服务 Order（订单）表与Doctor（医生）表的外键关系： 医生可以为患者提供订单服务 Visit（就诊）表与Treatment（治疗）表的外键关系： 患者可以选择不同的治疗方式进行就诊 Order（订单）表与Treatment（治疗）表的外键关系： 患者可以选择不同的治疗方式进行订单
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/552f52911c7c05a510c8ef55f4e65c4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c9e203a9267e2a245a8e3a1149e7dd6/" rel="bookmark">
			基于java的视频播放程序系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java的视频播放程序系统设计与实现
I. 引言 A.研究背景和动机 随着网络技术的不断发展，视频播放成为了人们生活中不可或缺的一部分。然而，传统视频播放程序的局限性也越来越明显。在用户体验方面，传统播放器往往会卡顿、延迟、界面设计不友好等问题。为了解决这些问题，一些基于Java的视频播放程序应运而生。
Java是一种跨平台的编程语言，具有高效、稳定、安全性高等优点。因此，基于Java的视频播放程序可以实现跨平台、高效、稳定等特点。此外，Java具有丰富的类库和API，使得开发者可以轻松地开发出功能强大的播放器程序。
动机：
基于Java的视频播放程序具有以下动机：
提高用户体验：基于Java的播放器程序可以采用多线程、多进程等技术，实现程序的快速响应和流畅播放。此外，还可以采用Java的UI框架，如Swing、JavaFX等，实现友好的界面设计。实现跨平台：基于Java的播放器程序可以实现跨平台，可以在不同的操作系统和设备上运行。提高程序效率：基于Java的播放器程序可以采用多线程、多进程等技术，实现程序的快速响应和流畅播放。此外，还可以采用Java的缓存机制，实现程序的缓存和优化。提升程序的安全性：基于Java的播放器程序可以采用Java的加密技术，实现程序的加密和权限控制，保证用户数据的安全性。
基于Java的视频播放程序具有广泛的应用前景，可以应用于个人、企业、学校等各个领域。因此，基于Java的视频播放程序系统设计与实现的研究具有重要的研究价值和应用价值。 B.目标和意义 实现基于Java的视频播放功能，能够播放多种视频格式，包括MPEG-1、MPEG-2、MPEG-4、WMV、FLV、AVI等，并支持多种视频质量。实现视频播放程序的用户交互界面，包括菜单、播放进度条、音量控制等功能，用户可以方便地控制播放进度和音量。实现视频播放程序的缓存功能，能够将已经播放过的视频缓存下来，避免用户多次重复播放同样的视频。实现视频播放程序的播放列表功能，用户可以添加、删除、修改视频播放列表中的视频，并能够按照不同的分类方式对播放列表进行排序。实现视频播放程序的音效功能，包括背景音乐、音量控制、音量均衡器等，能够为用户提供更好的观影体验。
基于Java的视频播放程序系统设计与实现的意义在于，它能够为用户提供更加丰富、多样化的视频播放体验，同时能够支持多种不同的视频格式和音效，满足用户不同的需求和口味。此外，基于Java的视频播放程序系统设计与实现也能够为用户提供更好的安全性保障，避免用户数据泄露和视频文件丢失等问题。 II. 相关技术和工具 A.Java语言 Java语言是一种面向对象的高级编程语言，由Sun Microsystems（现在是Oracle公司）于1995年发布。它被设计成可移植、可靠、安全和简单易学的语言，以及具有优秀的性能和高效的垃圾回收机制。Java语言可以用于开发各种类型的应用程序，包括Web应用程序、移动应用程序和桌面应用程序等。Java语言还具有丰富的类库和API，可以轻松地实现各种功能。Java语言还可以与许多其他编程语言进行交互，包括C++和Python等。Java语言具有良好的跨平台性能，可以运行在不同的操作系统上。Java语言还具有优秀的性能和可靠性，这使得它在许多企业应用和大规模项目中得到广泛应用。
B.数据库技术 数据库技术是计算机科学领域的重要分支之一，它主要研究如何设计、实现和维护数据库。数据库技术可以用于存储、管理和操作数据，它可以大大提高数据的存储和检索效率，为企业和个人提供更好的数据管理服务。目前，数据库技术已经广泛应用于企业、政府、科研、教育等领域，它已经成为现代信息化社会不可或缺的基础设施之一。在介绍数据库技术之前，我们需要了解数据库的基本概念和基本原理。数据库是指一组相关数据的集合，它可以存储在计算机、服务器或其他设备中。数据库中包含的数据可以分为数据表、数据字段和数据行。数据表是数据库中存储数据的集合，数据字段是数据表中的列，数据行是数据表中的记录。数据库可以通过关系模型来描述数据之间的关系，关系模型是一种用于描述实体、属性和关系之间关系的模型。数据库还可以通过多种方式进行操作，如SQL、NoSQL、MVC等。SQL是一种用于描述关系数据库的语言，NoSQL是一种用于描述非关系数据库的语言，MVC是一种用于描述分布式数据库的语言。
C.GUI技术 GUI技术是计算机图形用户界面的一种技术，它使用图形和文本来呈现信息，让用户更加直观地与计算机进行交互。GUI技术包括桌面应用、嵌入式设备、移动设备等多个领域，是现代计算机技术中不可或缺的一部分。
在桌面应用领域，GUI技术被广泛应用于各种应用程序，如浏览器、电子邮件、文本编辑器、图形图像处理软件等。嵌入式设备领域，GUI技术被应用于各种智能设备，如智能手表、智能手机、智能电视等。在移动设备领域，GUI技术被广泛应用于各种移动应用程序，如社交媒体、游戏、浏览器等。
GUI技术的基础是图形和文本。图形是指屏幕上的各种元素，如按钮、文本、图像等，文本是指用户输入的文本信息。GUI技术使用图形和文本来呈现信息，让用户更加直观地与计算机进行交互。用户可以通过鼠标、触摸屏等方式来操作计算机，从而实现各种操作。
GUI技术的发展可以追溯到20世纪70年代，当时人们开始使用图形界面来代替命令行界面。随着计算机技术的不断发展，GUI技术也不断发展壮大。现在，GUI技术已经成为现代计算机技术中不可或缺的一部分，被广泛应用于各种领域。
III. 系统需求分析与设计 A.系统功能需求 用户登录功能：用户可以通过用户名和密码进行登录，登录后可以访问个人信息、上传和下载视频等功能。视频播放功能：用户可以上传自己制作的视频，并播放。播放时可以设置播放器显示的参数，如视频质量、亮度、对比度等。视频下载功能：用户可以下载自己上传的视频，下载时可以选择保存路径、文件格式等。视频录制功能：用户可以在没有网络连接的情况下录制视频，录制的视频可以通过服务器下载。视频上传功能：用户可以上传自己制作的视频，并设置视频的标题、分类等信息。视频分享功能：用户可以将自己上传的视频分享到其他社交媒体平台，如微信、微博等。视频评论功能：用户可以对其他用户上传的视频进行评论和点赞，同时也可以查看其他用户对自己的视频评论。视频搜索功能：用户可以通过关键词搜索自己上传的视频，并查看相关视频。视频下载链接管理功能：用户可以查看自己上传的视频的下载链接，并进行管理。视频备份功能：用户可以将自己上传的视频备份到本地，并在需要时进行下载。 B.业务流程分析 一、需求分析
1.1 需求：设计一个视频播放程序，支持多种视频格式的播放。
1.2 需求：程序应具有播放、暂停、停止、上一曲、下一曲等基本操作功能。
1.3 需求：程序应具有视频格式的检测和处理功能，包括将视频文件格式转换为Java支持的视频格式。
1.4 需求：程序应具有视频播放时的进度条显示功能，让用户可以随时查看播放进度。
1.5 需求：程序应具有视频播放时的音频控制功能，包括音量大小、静音、切换音频模式等。
1.6 需求：程序应具有视频播放时的播放列表管理功能，包括添加、删除、修改播放列表等。
1.7 需求：程序应具有视频播放时的字幕管理功能，包括添加、删除、修改字幕等。
二、系统设计
2.1 视频播放程序的基本框架设计，包括UI界面、程序核心、数据处理模块等。
2.2 视频格式的检测和处理模块的设计，包括Java支持的视频格式的检测和转换。
2.3 视频播放的进度条显示模块的设计，包括进度条的显示和更新。
2.4 视频播放的音频控制模块的设计，包括音量大小、静音、切换音频模式等。
2.5 视频播放的播放列表管理模块的设计，包括添加、删除、修改播放列表等。
2.6 视频播放的字幕管理模块的设计，包括添加、删除、修改字幕等。
三、系统实现
3.1 UI界面的实现，包括程序的布局、控件的添加、功能的实现等。
3.2 程序核心的实现，包括视频播放的实现、数据处理模块的实现等。
3.3 数据处理模块的实现，包括视频文件的读取、格式转换、播放控制等。
3.4 视频播放的进度条显示模块的实现，包括进度条的显示和更新。
3.5 视频播放的音频控制模块的实现，包括音量大小、静音、切换音频模式等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c9e203a9267e2a245a8e3a1149e7dd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23bd1642f2d0ec5225279ec0d34d7deb/" rel="bookmark">
			我的 AI 成长星球，邀请你加入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好啊，我是董董灿。
2023年终总结时我这个小白坚持写作一整年，赚了多少？提到了一点，2024希望自己创建一个免费星球。
其实一直就想弄一个高质量的 AI 知识交流平台，方便大家一起交流和学习，同时提高对 AI 的认知。
前段时间弄了一个微信群，因为有人加进来就会直接发广告，很难维护、效果不好，就解散了。
今天从一个大佬那里弄到了一个免费知识星球的邀请码，果断就创建了一个，也算是先把其中一个 flag 立住，后面争取努力把星球做好。
星球提供如下内容 星球是一个社群，更是一个圈子，鼓励大家分享优质内容，以上所有内容如分享了优质文字，均有机会被设为精华。
星球需要大家一起维护，欢迎加入并积极主动分享自己的认知、文字、工具和资料。
星球目前还处于试运营阶段，很多板块和内容还不完善，期待大家的加入，一起完善星球内容，创建一个高质量的 AI 社群。
（由于这里不好放二维码）如果你感兴趣，点击（如果打不开，可复制到浏览器打开）：https://mp.weixin.qq.com/s?__biz=MzAwOTc2NDU3OQ==&amp;mid=2649038714&amp;idx=1&amp;sn=a1c24ed02f282bacf8ac5ddab6881ed0&amp;chksm=834b14f6b43c9de06e78f1183e7ae9dee6ca5bacb9a2f98683667ae293ced25b50b4c9095d65&amp;token=1640843523&amp;lang=zh_CN#rd
加入吧，一起玩转AI，学会AI。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fd4785c65a32aff0c711bd093b05e67/" rel="bookmark">
			Vue 自定义仿word表单录入之日期输入组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因项目需要，要实现仿word方式录入数据，要实现鼠标经过时才显示编辑组件，预览及离开后则显示具体的文字。
鼠标经过时显示
正常显示及离开时显示
组件代码
&lt;template &gt; &lt;div class="paper-input flex flex-col border-box " &gt; &lt;div class="font-l border-box text margin-left-m text" style="font-family: FangSong;"&gt;{{text}}&lt;/div&gt; &lt;div class="flex flex-col input hidden"&gt; &lt;input type="text" v-model="value1" maxlength="4" ref="date1" @input="changeToNext1(value1)"/&gt; 年 &lt;input type="text" v-model="value2" maxlength="2" ref="date2" @input="changeToNext2(value2)"/&gt; 月 &lt;input type="text" v-model="value3" maxlength="2" ref="date3" @input="changeToNext3(value3)"/&gt; 日 &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default{ name:'PagerInput', data() { return { val:"", text:"年 月 日", value1:"", value2:"", value3:"", } }, props: { value:{} }, model: { prop: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fd4785c65a32aff0c711bd093b05e67/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/4/">«</a>
	<span class="pagination__item pagination__item--current">5/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/6/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>