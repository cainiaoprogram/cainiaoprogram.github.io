<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/507ba74e6ac85f5b2e9839cfccf3b54a/" rel="bookmark">
			latex如何在一段话前面加一个点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 LaTeX 中，可以使用 \dot{} 命令在一段话前面加上点。例如，在一段话 "hello world" 前面加上点的 LaTeX 代码如下：
\dot{hello world} 在编译后就会显示为 。hello world
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6627c05339a08377736349243a105c44/" rel="bookmark">
			SpringBoot 整合 FastJson 及用法举例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考地址： https://blog.csdn.net/cold___play/article/details/124525519
一、fastjson介绍 Fastjson是一个Java语言编写的高性能功能完善的JSON库。它采用一种“假定有序快速匹配”的算法，把JSON Parse的性能提升到极致，是目前Java语言中最快的JSON库。Fastjson接口简单易用，已经被广泛使用在缓存序列化、协议交互、Web输出、Android客户端等多种应用场景。
主要特点：
快速FAST (比其它任何基于Java的解析器和生成器更快，包括jackson）强大（支持普通JDK类包括任意Java Bean Class、Collection、Map、Date或enum）零依赖（除了JDK没有依赖其它任何类库） 二、fastjson使用 maven依赖，这里使用最新的版本号2.0.22，具体可查看 https://github.com/topics/fastjson
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;2.0.22&lt;/version&gt; &lt;/dependency&gt; 三、fastjson常用API public static final Object parse(String text); // 把JSON文本parse为JSONObject或者JSONArray public static final JSONObject parseObject(String text)； // 把JSON文本parse成JSONObject public static final &lt;T&gt; T parseObject(String text, Class&lt;T&gt; clazz); // 把JSON文本parse为JavaBean public static final JSONArray parseArray(String text); // 把JSON文本parse成JSONArray public static final &lt;T&gt; List&lt;T&gt; parseArray(String text, Class&lt;T&gt; clazz); //把JSON文本parse成JavaBean集合 public static final String toJSONString(Object object); // 将JavaBean序列化为JSON文本 public static final String toJSONString(Object object, boolean prettyFormat); // 将JavaBean序列化为带格式的JSON文本 public static final Object toJSON(Object javaObject); //将JavaBean转换为JSONObject或者JSONArray。 四、用法示例 （1）接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6627c05339a08377736349243a105c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b04ea34c04e83d18cad908b3cd559fd7/" rel="bookmark">
			JavaScript 库之 vanilla-tilt（一个平滑的 3D 倾斜库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript 库之 vanilla-tilt（一个平滑的 3D 倾斜库） 参考描述获取vanilla-tilt特点 使用示例使用1. data-tilt2. VanillaTilt.init() 优先级示例 配置选项其他 参考 项目描述GitHub前往Vanilla-tilt.js前往 描述 项目描述操作系统Windwos 10 专业版Edge108.0.1462.54 (正式版本) (64 位)vanilla-tilt.js1.8.0 获取 Vanilla-tilt.jsGitHubnpm npm install vanilla-tilt vanilla-tilt vanilla-tilt.js 是 JavaScript 中的一个平滑的 3D 倾斜库，该库存在 JQuery 版本——Tilt.js 。
特点 vanilla-tilt 存在以下特点：
轻量级无依赖项使用简单60 FPS丝滑 使用 示例 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;vanilla-tilt&lt;/title&gt; &lt;style&gt; *{ /* 去除元素默认的内外边距 */ margin: 0px; padding: 0px; } body{ /* 设置显示区域的最小高度值为显示窗口的高度值 */ min-height: 100vh; /* 使 body 中的元素居中显示 */ display: flex; justify-content: center; align-items: center; } #card{ /* 为目标元素指定宽高并为其设置渐变背景颜色 */ width: 200px; height: 200px; background: linear-gradient(to right bottom, rgb(108, 240, 255), rgb(118, 255, 180)); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b04ea34c04e83d18cad908b3cd559fd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad74403e9b6f7208ccb4f5c784012f8/" rel="bookmark">
			微服务循环依赖调用引发的血案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序员的成长之路
互联网/程序员/技术/资料共享 关注
阅读本文大概需要 4 分钟。
来自：juejin.cn/post/7090331001485787149
1.问题表现 最近的迭代转测后，遇到了一个比较有意思的问题。系统在测试环境整体运行还算平稳，但是过一段时间之后，就开始有接口超时了，日志中出现非常多的 “java.net.SocketTimeoutException: Read timed out”。试了几次重启大法，每次都是坚持一会之后，就再次出现 SocketTimeoutException。
注意，在测试环境于遇到问题重启服务，并不是一个好的实践，因为重启可能会让不容易出现的问题现场被破坏。如果问题在测试环境不能再重新，却在发版后出现在生产环境的话，那不仅会造成生产运维事件，还要顶着巨大的压力去解决问题，有过经验的小伙伴一定知道个中滋味。
2.初步分析 顺着测试汇报的出现问题的场景，跟踪调用链上相关服务的日志，发现出现了微服务之间循依赖调用。大致情况可以抽象如下所示（图中所有调用都是 http 协议）：
Client 调用服务 Foo.hello()
Foo.hello() 逻辑中会调用服务 Boo.boo()
Boo.boo() 又调用回服务 Foo 的另外一个方法 another()
当然真实的场景要比较这个复杂，调用链更长，不过最终形成了环形依赖调用。至于这个环形依赖为什么回导致超时，当时想了多种可能，比如数据库慢查询、数据库锁、分布式锁等等。但是整个调用链上都是查询请求，而且查询相关的数据量也非常小，不会出现慢查询。发生问题的时候也没有与查询数据相关的数据库写请求。
鉴于这个环形依赖调用确实是这个迭代版本中引入的变更，虽然没有理清其中的因果关系原理，但是这个环性依赖调用还是很可疑的，而且这个环形调用是可以通过其他方法消除的。就抱着将环形依赖调用去掉试试看的态度，做了修复。修复完后，SocketTimeoutException不再出现了。问题解决了。
3.探寻原因 问题虽然不再出现，但是凭运气解决的问题，通常有可能不是真的的解决。只有弄清楚背后的原理，我们才能真正的确认问题是不是这个原因导致的，这样的修复是不是真的把问题解决了。
通过假设环形调用就是导致调用超时的直接原因。我们看看能不能推出因果关系。通过把Foo 服务容器画的更详细一点，如下图：
通过这个图示，我们可以发现，如果容器中接收请求的线程池如果都在等待服务Boo.boo()的响应，而 Boo 又需要调用回服务 Foo.another()。这个时候，如果所有的线程都处于这样的状态，我们就会发现服务 Foo 容器中以及没有线程来处理 Boo 的请求了。某种程度上来说就是死锁了。
到这里，我们就可以很确定了，这个环形依赖调用就是导致出现调用超时的罪魁祸首。当 client 发起的请求速度大于这个环形调用链的处理速度的时候，慢慢的就会导致服务 Foo 的所有线程都进入这种死锁状态。
4.验证 这里只列出关键的代码，具体的代码可以参考 gitee 工程：
https://gitee.com/donghbcn/CircularDependency
4.1 Eureka 服务器 建个简单工程将Eureka server启动起来。
4.2 服务 Foo 创建 SpringBoot 工程实现 Foo 服务。Foo 通过 FeignClient 调用 Boo 服务。设置缺省的容器 Tomcat 的最大线程数为 16，Tomcat 默认配置最大线程数 200，对于验证这个场景有点了大了，要看到效果需要等的时间有点长。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ad74403e9b6f7208ccb4f5c784012f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaf765ea60ca952063242627f7239675/" rel="bookmark">
			Python 之数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章收集于网络，如有版权，请联系作者
一、引子 1 什么是数据？
x=10，10是我们要存储的数据
2 为何数据要分不同的类型
数据是用来表示状态的，不同的状态就应该用不同的类型的数据去表示
3 数据类型
数字、字符串、列表、元组、字典、集合
二、基础数据类型 2.1 数字 int 数字主要是用于计算用的，使用方法并不是很多，就记住一种就可以：
int() 可以把其他类型转化为数字类型，并自动除去空格，但是前提是转化的数字
# bit_length() 当十进制用二进制表示时，最少使用的位数 v = 11 data = v.bit_length() print(data) 2.2 布尔值bool 布尔值就两种：True，False
真 1 True 假 0 False int:0 list:[] tuple:{} str:'' 转化为布尔值是False，其他的都是True 2.3 字符串str 2.3.1 字符串的索引与切片。 索引即下标，就是字符串组成的元素从第一个开始，初始索引为0，以此类推。
a = 'ABCDEFGHIJK' print(a[0]) # A print(a[3]) # D print(a[-1]) # K 切片就是通过索引（索引：索引：步长）截取字符串的一段，形成新的字符串（原则就是顾头不顾腚）。
a = 'ABCDEFGHIJK' print(a[0:3]) print(a[2:5]) print(a[0:]) # 默认到最后 ABCDEFGHIJK print(a[0:-1]) # -1 是列表中最后一个元素的索引，但是要满足顾头不顾腚的原则，所以取不到K元素 print(a[0:5:2]) # 加步长 ACE print(a[5:0:-2]) # 反向加步长 FDB 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaf765ea60ca952063242627f7239675/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/961f9fea417679de6a8afa96f2f8e648/" rel="bookmark">
			sklearn的mnist_784数据集可视化代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下面是用 matplotlib 库可视化 sklearn 的 mnist_784 数据集的代码示例:
from sklearn.datasets import fetch_openml import matplotlib.pyplot as plt # 加载数据集 mnist = fetch_openml('mnist_784') X, y = mnist['data'], mnist['target'] # 选取一张图片进行可视化 some_digit = X[0] some_digit_image = some_digit.reshape(28, 28) plt. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/945b40548e8635c5a768dc5044a5ce41/" rel="bookmark">
			Pgsql中如何进行循环遍历与执行传递进行的变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 我需要对表数据进行批量注释。示例代码如下：
do $$ declare -- 声明变量 i record; BEGIN for i in select nspname,relname,table_name -- 循环遍历 from table_1 loop -- 执行表名的焊接 raise notice '%',format('comment on table %I.%I is %L;', i.nspname,i.relname,i.table_name); EXECUTE format('comment on table %I.%I is %L;', i.nspname,i.relname,i.table_name); end loop; EXCEPTION WHEN invalid_schema_name THEN raise notice 'nspname的信息填写错误'; WHEN undefined_table THEN raise notice 'relname的信息填写错误'; WHEN undefined_column THEN raise notice 'attname的信息填写错误'; end; $$; 提示：异常捕抓错误，需要指定是什么错误，与python有一点不一样，具体的错误代码可以参考链接：Postgresql错误代码：错误编号对应的错误信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70100fdcb118470cd1fb74674a2202dc/" rel="bookmark">
			神经网络模型训练及验证套路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0. 数据集CIFAR10
1. 神经网络模型训练套路：
1.1 网络模型搭建：
1.2 网络模型训练： 1.3 GPU加速：
法（一）：
法（二）：
1.4 网络模型保存
1.5 训练结果
2. 神经网络模型验证套路
2.1 网络模型加载
2.2 网络模型验证
0. 数据集CIFAR10 以数据集CIFAR10为例，搭建网络模型进行训练、验证。
pytorch上关于CIFAR10数据集的文档： 获取数据集：
train_data = torchvision.datasets.CIFAR10(root="../dataset", train=True, transform=torchvision.transforms.ToTensor(), download=True) test_data = torchvision.datasets.CIFAR10(root="../dataset", train=False, transform=torchvision.transforms.ToTensor(), download=True) debug结果： 可获取数据集 class 与 targets (即label）的关系。
1. 神经网络模型训练套路： step1. 准备数据集dataset，及数据加载dataloader
step2.搭建网络模型
step3.创建损失函数、优化器
step4.设置训练参数（epoch..)
step5.网络进入训练状态（调用model.train()）
(1) 从train_dataloader中加载数据
(2) 计算损失函数
(3) 反向传播，优化器优化
(4) print, tensorboard 展示输出
step7. 每个epoch训练完成后，网络进入测试状态（调用model.eval())
(1) 在with torch.no_grad下进行（只测试，无梯度优化）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70100fdcb118470cd1fb74674a2202dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be1963b30181aad1f8b75ab86fdc25d9/" rel="bookmark">
			82.长短期记忆网络（LSTM）以及代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 长短期记忆网络 忘记门：将值朝0减少输入门：决定不是忽略掉输入数据输出门：决定是不是使用隐状态 2. 门 3. 候选记忆单元 4. 记忆单元 5. 隐状态 6. 总结 7. 从零实现的代码 我们首先加载时光机器数据集。
import torch from torch import nn from d2l import torch as d2l batch_size, num_steps = 32, 35 train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps) 7.1 初始化模型参数 接下来，我们需要定义和初始化模型参数。 如前所述，超参数num_hiddens定义隐藏单元的数量。 我们按照标准差 0.01 的高斯分布初始化权重，并将偏置项设为 0 。
def get_lstm_params(vocab_size, num_hiddens, device): num_inputs = num_outputs = vocab_size def normal(shape): return torch.randn(size=shape, device=device)*0.01 def three(): return (normal((num_inputs, num_hiddens)), normal((num_hiddens, num_hiddens)), torch.zeros(num_hiddens, device=device)) W_xi, W_hi, b_i = three() # 输入门参数 W_xf, W_hf, b_f = three() # 遗忘门参数 W_xo, W_ho, b_o = three() # 输出门参数 W_xc, W_hc, b_c = three() # 候选记忆元参数 # 输出层参数 W_hq = normal((num_hiddens, num_outputs)) b_q = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be1963b30181aad1f8b75ab86fdc25d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1521d200c0420e20f5460d4b6f5bbab9/" rel="bookmark">
			super-jacoco环境部署和使用--支持环境全量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
superjacoco本身是滴滴开源出来的，但是不知道为什么，他们改造只支持了增量的覆盖率，反而把原有的全量覆盖率给搞没了~我咨询了一下开源组，貌似也没有给我这边答复，大概的意思就是，不支持全量覆盖~
二、改造
其实要改动的地方不多，就几行，如图~ 比较简单，也可以加一些其他判断，我就做了最简单的判断，传入的type为2的时候，做增量，其他都做全量~各位也可以按照需求改造
三、效果
图一为做增量代码
图二为做全量代码
三、接口请求
1)启动覆盖率收集 URL：/cov/triggerEnvCov 调用方法：POST 参数（body方式传入）：{"uuid":"uuid","type":1,"gitUrl":"git@git","subModule":"","baseVersion":"master","nowVersion":"feature"，"address":"127.0.0.1","port":"8087"} 说明：address参数为部署的应用服务地址，如参数port就是在启动时添加-javaagent时的端口 返回：{"code":200,"data":true,"msg":"msg"} 备注： IP和port为模块部署服务器的IP和端口，在dump jacoco.exec时使用，需要提前把org.jacoco.agent-0.8.5-runtime.jar包拷贝到服务器:/home/xxx/目录，服务启动时需要添加启动参数： -javaagent:/home/xxx/org.jacoco.agent-0.8.5-runtime.jar=includes=*,output=tcpserver,address=127.0.0.1,port=8087 端口为开放的未占用的端口 备注2：改造后，type传入2为增量，其他都是全量 2)获取覆盖率结果 URL：/cov/getEnvCoverResult 调用方法：GET 参数：uuid(String) 返回：{"code":200,"data":{"coverStatus":1,"errMsg":"msg","lineCoverage":100.0,"branchCoverage":100.0,"logFile":"file content","reportUrl":"http://"},"msg":"msg"} 备注：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0e54b01fea5fdb203af256a67650c2d/" rel="bookmark">
			maya_Arnold_Aov分层渲染插件 v1.1.0 更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插件简介： arnold默认提供了渲染分层工具，但物体id，材质id 以及物体的 ao occ 、Rim边缘光，线框等通道都没提供自动生成方法，要手动通过后期aiUtility节点创建。这个插件蓝色部分分层就是创建此类分层的。arnold渲染器没有预设保存功能，此工具提供了此类功能。这个工具对于批量处理大量镜头的分层管理提供了些方便。
一、版本更新： v1.1.0更新说明：
1、更直观的分层渲染面板，预设保存，快速管理分层选项。
2、增加了原有分层选项没有的分层类型（蓝色区分类）：如 物体id、材质id 、rim边缘光、物体的 ao occ 、线框效果 等自定义通道输出。
3、增加了物体组id 的创建，材质id创建功能。
4、优化了正题UI面板的结构，将层操作加到右键快捷菜单中，更加的简洁方便。
v1.0.5更新说明： 1. 增加了最新arnold3.1.1版 新aovs pass层的支持。
2. 主菜单增加了preset reset 功能，和新的预设集菜单。
3. 界面UI顺序调整，更合理。
4. 增加了新的arnold 物体id的创建与提取方法。
v1.0.1更新说明： 1、增加了快速渲染分层批量创建、关闭、开启、反选、删除通道等操作。
2、增加了运动模糊层 motionvector 快速摄像机设置开关和恢复工具。
首先创建一个 motionvector pass层，之后点击Create motionvector Setting按钮即可。最后要记得reset还原设置。此快速工具会开启全局动感模糊，并根据全局参数，设置摄像机的arnold参数shutter start、shutter end。
3、新的Rim 物体自定义边缘发光层，使用的是sample info节点。
4、新的object id层创建方式。使用方法: 首先创建一个 object_id 层，之后选择多个物体，点击Create Object Id Set按钮即可。为多个物体创建相同id，可以点击Auto Object_Id Seperately按钮，自动为每个物体创建独立id。提供了nuke提取方法。
原理说明：这里使用的是aiUserDataFloat节点，自定义一个float浮点变量arnold专有变量objectID（此名为随意自定义的），将此节点练到aiUtility的flat类色彩上用作物体的id通道色彩类型，并在每个选择物体的shape节点添加自定义变量不同的值，从而区分不同物体的id，保证id的唯一性。此方式的优点是通过类似景深通道的方式，读取每个物体的id，效率很快，在nuke中可以通过grade节点来获取每个物体的id rgb信息，并用nuke primatte插件进行alpha快速提取即可。此方式的优点是可以避免多色彩混合方式色值接近，不好区分的麻烦，保证每个物体只有一个深度色彩。
5. 新的灰度mat_id 材质id层方式，选择材质节点，设置一个id灰度，创建即可。提供了nuke提取方法。
二、下载地址 最新版免费下载：链接：百度网盘 请输入提取码 密码：cnmd
三、使用教程 1、安装方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0e54b01fea5fdb203af256a67650c2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3cbf093ce84c82b55e178c82f3b9d9a/" rel="bookmark">
			windows系统更改谷歌浏览器安装位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows系统更改谷歌浏览器安装位置 谷歌浏览器可以说是一名开发者必备浏览器了，嗷，你要是问“都开发者了为什么不是mac本”，那我只能说学生狗没钱
google默认是安装C盘的，那越用肯定占用空间肯定越大了，所以我们需要手动移动到非系统盘
开整！
下载安装包 Google Chrome 网络浏览器
安装 移动到非系统盘 图标右键打开文件位置 定位到父文件夹 剪切到非系统盘 更改文件软链接 任务栏搜索框搜索cmd-&gt;管理员身份运行
输入格式命令
mklink "谷歌浏览器原安装路径" "谷歌浏览器新路径" 比如我的就是
mklink "C:\Program Files\Google" "G:\AppDataFile\Google" 之前的快捷图标删掉，创建新的快捷图标
成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33776e3886238971e8171e1cfc0428a0/" rel="bookmark">
			【超级视客营】基于超算平台的MMYOLO实践过程记录（自定义数据集实现YOLO v5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇博文我们搭建好了超算平台对MMYOLO编译环境，并通过单张图片加载训练好的模型进行推理。本篇文章参考MMYOLO官方发布的自定义数据集 标注+训练+测试+部署 全流程文档，进一步在超算平台中实现yolo v5网络的训练。
1.数据集的构建和可视化分析 1.1 MIDOG公开数据集介绍 本次实验采用的是病理图像有丝分裂检测数据集，边界框标注了两个类别： mitosis figure表示该细胞为有丝分裂细胞，not mitosis figure为比较容易与有丝分裂状态混淆的其他阶段的细胞。关于该数据集的详细介绍可以参考之前的两篇文章。
有丝分裂检测竞赛，MICCAI举办。
200张训练图像，每张图片大小为组织切片感兴趣区域，尺寸大约为5k*5k pix
染色标准相同：UMC Utrecht病理实验室制备得到
扫描设备不同：50 each from Hamamatsu XR nanozoomer 2.0 (HXR), Hamamatsu S360 0.5 NA (HS360), Aperio ScanScope CS2 (ACS), and Leica GT450
1.2 数据格式的转换 解析MIDOG的标注文件.json → df = get_bbox_df()
训练集和测试集划分 → train_test_split(df)
图像块生成：不重叠裁剪成512*512尺寸的patch → mask_segmentor()
from PatchSeg_functions import mask_segmentor from Data_functions import get_bbox_df, train_test_split ############ Preparation ################## Get dataset and generate 512x512 crops from the original WSIs df = get_bbox_df() df_train, df_test = train_test_split(df) image_ids=list(df['file_name'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33776e3886238971e8171e1cfc0428a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f8736a1fa678e76ec1d3a319dbcb325/" rel="bookmark">
			商品期货跨期套利实战笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		合约对：IC2301&amp;IC2302
价差计算
前-后（6082-6079.8）
做多价差开仓（预期价差变大）
买2301（前）
卖2302（后）
做空价差开仓（预期价差变小）：
买2302（后）
卖2301（前）
二、交割时间
股指期货交割日为每月第三个周5，节假日顺延
棕榈油期货的交割月份为1-12月,最后交易日为交割月第十个交易日,最后交割日为最后交易日后第三个交易日
（例：P2301，最后交易日为1月13日，1月16日已无交易）
商品主力合约只产生在1月/5月/9月三个合约当中，例如1401，1405，1409会随着时间轮流的做为主力合约；
股指则是当月合约为主力合约。
三、软件选择
快期缺少前后腿操作，一年下来估计滑点也有万把块了。
尽量在默认合约里选，K线好像比较完整
四、观察现象解释
回测中的低点和极星软件中低点价差不同
9：30分前是集合竞价，回测程序中选取每天9：30之后的数据
2016年1月1日起,调整IF、IH、IC交易时间调整为集合竞价时间为每个交易日9:25-9:30,其中9:25-9:29为指令申报时间,9:29-9:30为指令撮合时间。连续竞价时间为每个交易日9:30-11:30为指令撮合时间。连续竞价时间为每个交易日9:30-11:30(第一节)和13:00-15:00(第二节)。”
当前课题：
商品期货套利观察
豆油和棕榈油
豆粕与和菜粕
玉米和玉米淀粉
螺纹钢和热卷
豆二和豆粕
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57a547a2d346ee8716346efb7c5601db/" rel="bookmark">
			矩阵翻转的七种类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		花式旋转 | 螺旋升天
我们有时会遇到一类题，给定或让你输入一个矩阵，输出各式各样翻转后的矩阵。这不禁引起我们深思，这矩阵怎么这么能转呢？
今天这里归纳了7种类型的矩阵翻转的做法
顺时针旋转90°逆时针旋转90°以主对角线为轴翻转以副对角线为轴翻转左右翻转上下翻转中心翻转 No.1 输入 #include&lt;stdio.h&gt; int main() { int N; scanf("%d",&amp;N); int a[N][N],b[N][N];//N*N的矩阵 for(int i=0;i&lt;N;i++)//输入数组 { for(int j=0;j&lt;N;j++) { scanf("%d",&amp;a[i][j]); } } 以输入一个5*5的矩阵为例
No.2 顺时针旋转90° printf("\n顺时针旋转90°：\n"); for(int i=0;i&lt;N;i++) { for(int j=0;j&lt;N;j++) { b[i][j]=a[N-1-j][i];//数组每行或每列最大下标是N-1 printf("%2d ",b[i][j]); } printf("\n"); } No.3 逆时针旋转90° printf("\n逆时针旋转90°：\n"); for(int i=0;i&lt;N;i++) { for(int j=0;j&lt;N;j++) { b[i][j]=a[j][N-1-i];//数组每行或每列最大下标是N-1 printf("%2d ",b[i][j]); } printf("\n"); } No.4 以主对角线为轴翻转 printf("\n左上、右下对角线为轴翻转：\n"); for(int i=0;i&lt;N;i++) { for(int j=0;j&lt;N;j++) { b[i][j]=a[j][i];//数组每行或每列最大下标是N-1 printf("%2d ",b[i][j]); } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57a547a2d346ee8716346efb7c5601db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61bb9d167d54c38f3959bfcbfb17e99b/" rel="bookmark">
			内存映射(Linux)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概念
内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。
API
内存映射相关系统调用，使用man 2 mmap查看帮助
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 功能：将一个文件或者设备的数据映射到内存中参数 addr：设置为 NULL时, 由内核指定（推荐做法）length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度，获取文件的长度：stat ，lseekprot : 对申请的内存映射区的操作权限
PROT_EXEC ：可执行的权限
PROT_READ ：读权限
PROT_WRITE ：写权限
PROT_NONE ：没有权限flags
MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项
MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）fd: 需要映射的那个文件的文件描述符，通过open得到，open的是一个磁盘文件offset：偏移量，一般进行特殊指定（指定为0即可），如果使用必须指定的是 4k 的整数倍，0表示不偏移返回值：返回创建的内存的首地址。失败返回MAP_FAILED(即(void *) -1) int munmap(void *addr, size_t length); 功能：释放内存映射参数
addr : 要释放的内存的首地址
length : 要释放的内存的大小，要和mmap函数中的length参数的值一样 适合的进程间通信种类
有关系的进程（父子进程）
还没有子进程的时候，通过唯一的父进程，先创建内存映射区
有了内存映射区以后，创建子进程
父子进程共享创建的内存映射区没有关系的进程间通信
准备一个大小不是0的磁盘文件
进程1 通过磁盘文件创建内存映射区，得到一个操作这块内存的指针
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61bb9d167d54c38f3959bfcbfb17e99b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1e4873e15967b657f97be144c7bc3d0/" rel="bookmark">
			Qt之make: Nothing to be done for ‘first‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在修改了pro,cpp,h等文件，重新编译时，出现了标题所示的内容。如下图1所示
和同事讨论了一下，主要有几个问题，可能导致make不成功。
1）工程文件内容没有变化，直接make。
2）删除工程文件中的编译生成的文件后再编译。执行qmake;make clean;make
以上两种方式都尝试了后，发现没有解决问题。然后还原工程文件代码到前一版本，发现能够正常编译。
进而挨个文件查找，首先核对pro文件。结果就出来了第3中解决方案。
3）在编写pro时，一定要注意反斜杠\的运用。
如下图2示的反斜杠“\”会引起上图1中的问题。
下图3中的反斜杠“\”可以正常编译通过。
下图4中不带反斜杠“\”可以正常编译通过。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2279bc697c86309cadd348f222701870/" rel="bookmark">
			JavaScript数字转字符串的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 String(number)，number.toString()，number+''
注意：不能直接数字后跟 .toString()方法，这是错误的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13e69a3a33da957673ec5c655e8b5e6e/" rel="bookmark">
			vue 父组件监听子组件的数据变化 父组件监听子组件的data
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		子组件的data data(){ return{ form:{ age: '' } } }, mounted(){ this.form.name = '李四' // 不会触发监听 this.$set(this.form, 'name', '王五') // 会触发监听 this.form.age = '18' // 会触发监听 } 父组件 &lt;template&gt; &lt;div&gt; &lt;!-- 子组件 --&gt; &lt;son ref="sonRef"&gt;&lt;/son&gt; &lt;/div&gt; &lt;/template&gt; 父组件script部分代码 &lt;script&gt; import son from './son.vue' export default { components: { son }, mounted(){ this.$nextTick(() =&gt; { // 拿取子组件data const useData = this.$refs.sonRef.$data // 监听 this.$watch(() =&gt; { return useData },(val) =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13e69a3a33da957673ec5c655e8b5e6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85fa84173b9617c19f0883c4a09f4b53/" rel="bookmark">
			mysql练习：经典50道基础题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、环境准备50道题目练习1、查询"01"课程比"02"课程成绩高的学生的信息及课程分数2、查询学生选课存在" 01 "课程但可能不存在" 02 "课程的情况（不存在时显示为 null）3、查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩4、查询在 SC 表存在成绩的学生信息5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的成绩总和6、查询「李」姓老师的数量7、查询学过「张三」老师授课的同学的信息8、查询没有学全所有课程的同学的信息9、查询至少有一门课与学号为"01"的同学所学相同的同学的信息10、查询和"01"号的同学学习的课程完全相同的其他同学的信息11、查询没学过"张三"老师讲授的任一门课程的学生姓名12、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩13、查询"01"课程分数小于 60，按分数降序排列的学生信息14、按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩15、查询各科成绩最高分、最低分和平均分16、按各科成绩进行排序，并显示排名， Score 重复时保留名次空缺17、查询学生的总成绩，并进行排名，总分重复时保留名次空缺18、查询学生的总成绩，并进行排名，总分重复时不保留名次空缺19、统计各科成绩各分数段人数：课程编号，[100-85)，[85-70)，[70-60)，[60-0] 及所占百分比20、查询各科成绩前三名的记录21、查询每门课程被选修的学生数22、查询出只选修两门课程的学生学号和姓名23、查询男生、女生人数24、查询名字中含有「风」字的学生信息25、查询同名同性学生名单，并统计同名人数26、查询 1990 年出生的学生名单27、查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列28、 查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩29、查询课程名称为「数学」，且分数低于 60 的学生姓名和分数30、查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）31、查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数32、查询不及格的课程33、查询课程编号为 01 且课程成绩在 60 分以上的学生的学号和姓名34、求每门课程的学生人数35、成绩没有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩36、成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩37、查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩38、查询每门课程成绩最好的前两名39、统计每门课程的学生选修人数（超过 5 人的课程才统计）40、检索至少选修两门课程的学生学号41、查询选修了全部课程的学生信息42、查询各学生的年龄，只按年份来算43、按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一44、查询本周过生日的学生45、查询下周过生日的学生46、查询本月过生日的学生47、查询下月过生日的学生48、查询下周过生日的学生49、查询本月过生日的学生50、查询下月过生日的学生 参考文章 一、环境准备 建表共4张表，分别对应学生信息（Student）、课程信息（Course）、教师信息（Teacher）以及成绩信息（SC）
-- 学生表 create table Student(sid varchar(10),sname varchar(10),sage datetime,ssex nvarchar(10)); insert into Student values('01' , '赵雷' , '1990-01-01' , '男'); insert into Student values('02' , '钱电' , '1990-12-21' , '男'); insert into Student values('03' , '孙风' , '1990-05-20' , '男'); insert into Student values('04' , '李云' , '1990-08-06' , '男'); insert into Student values('05' , '周梅' , '1991-12-01' , '女'); insert into Student values('06' , '吴兰' , '1992-03-01' , '女'); insert into Student values('07' , '郑竹' , '1989-07-01' , '女'); insert into Student values('08' , '王菊' , '1990-01-20' , '女'); -- 课程表 create table Course(cid varchar(10),cname varchar(10),tid varchar(10)); insert into Course values('01' , '语文' , '02'); insert into Course values('02' , '数学' , '01'); insert into Course values('03' , '英语' , '03'); -- 教师表 create table Teacher(tid varchar(10),tname varchar(10)); insert into Teacher values('01' , '张三'); insert into Teacher values('02' , '李四'); insert into Teacher values('03' , '王五'); -- 成绩表 create table SC(sid varchar(10),cid varchar(10),score decimal(18,1)); insert into SC values('01' , '01' , 80); insert into SC values('01' , '02' , 90); insert into SC values('01' , '03' , 99); insert into SC values('02' , '01' , 70); insert into SC values('02' , '02' , 60); insert into SC values('02' , '03' , 80); insert into SC values('03' , '01' , 80); insert into SC values('03' , '02' , 80); insert into SC values('03' , '03' , 80); insert into SC values('04' , '01' , 50); insert into SC values('04' , '02' , 30); insert into SC values('04' , '03' , 20); insert into SC values('05' , '01' , 76); insert into SC values('05' , '02' , 87); insert into SC values('06' , '01' , 31); insert into SC values('06' , '03' , 34); insert into SC values('07' , '02' , 89); insert into SC values('07' , '03' , 98); 50道题目练习 1、查询"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85fa84173b9617c19f0883c4a09f4b53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1ea440f6eebb081095d72c81796efc7/" rel="bookmark">
			树莓派ubuntu mate系统安装pycharm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，安装步骤
1.pycharm下载地址：
Download PyCharm: Python IDE for Professional Developers by JetBrains
下载arm64版本
2.在download目录下执行代码：
tar -xvzf pycharm...2022.5.1.tar.gz
3.打开 pycharm...2022.5.1/bin 目录，在目录下执行代码：
sh pycharm.sh
二，创建pycharm桌面图标
1.在桌面创建pycharm.desktop文档,并复制下列代码到文档中
[Desktop Entry]
Type=Application
Name=Pycharm
GenericName=Pycharm
Comment=Pycharm IDE
Exec=sh 绝对路径1
Icon=绝对路径2
Terminal=false
Categories=Application;Network;
其中，绝对路径1：/home/（user name）/Downloads/pycharm-2022.3.1/bin/pycharm.sh
绝对路径2：/home/（user name）/Downloads/pycharm-2022.3.1/bin/pycharm.png
保存
2. 在桌面目录下，运行代码：sudo cp ./pycharm.desktop usr/share/applications/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c884ce1aeb822da802b707a41b09798a/" rel="bookmark">
			DDR4 Spec 第五章 终端电阻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ODT（On-Die Termination，终端电阻）是DDR4的一个特点，对于x4和x8器件，其允许DRAM改变每个DQ，DQS_t，DQS_c和DM_n的终端电阻阻值，对于x8器件，当MR1的A11=1时，还能改变TDQS_t和TDQS_c的阻值。改变阻值的方式为利用ODT pin脚或写命令或MR寄存器中设置的默认值（这个默认值英文中带有“Parking”一词，Park本身便有停靠的意思）。对于x16器件，ODT可以用于每个DQU, DQL, DQSU_t, DQSU_c, DQSL_t, DQSL_c, DMU_n and DML_n信号。ODT用于提高信号完整性。更多信息详见以下章节：
5.1章节描述了ODT控制模式5.2章节描述了同步ODT模式5.3章节描述了动态ODT功能5.4章节描述了异步ODT功能5.5章节描述了关闭ODT模式 在自刷新模式下，ODT功能是被关闭的。图174展示了简明的ODT功能。其中DQ，DQS，DM，TDQS信号上方有RTT电阻，电阻旁边有个开关，当开关接通，则说明信号接上了RTT电阻。开关的是否关断/闭合取决于内部的ODT控制逻辑，该逻辑由外部的ODT pin脚和MR寄存器的设置以及其它别的控制信息决定。RTT的阻值可根据MR寄存器的设置而改变，可理解为初中物理的变阻器。在自刷新模式下，以及MR1的A[10:8]=000的情况下，DRAM将会忽略外部的ODT pin脚的输入。
5.1 ODT模式寄存器和ODT状态表 DDR4的ODT有四种状态：电阻disable、RTT_WR、RTT_NOM以及RTT_PARK。如果MR1 A[10:8]或MR2 A[10:9]或MR5 A[8:6]其中的一个或几个不是全零的情况下，则会使能ODT模式，同时，这些MR寄存器中也设置了终端电阻的阻值到底是多少。
进入自刷新模式后，DRAM自动disable ODT电阻并无视MR的设置将其设置为高阻态。
应用举例：内存控制器可以结合ODT pin，在WR/RD命令时控制每个RTT的阻值具体是多少。
RTT_WR：无论ODT pin的电平为高还是为低，当rank（注意这里是rank）接收写入颗粒的数据时，终端电阻阻值为RTT_WR。RTT_NOM：假设MR1的ODT没有被disable，当ODT pin拉高时，此时终端电阻阻值为RTT_NOM。RTT_PARK：给MR5以合适的设置，且当ODT pin脚为低时，终端电阻阻值为RTT_PARK。电阻Disable：在发送READ命令后，DRAM驱动数据回传到控制器时，会disable终端电阻。disable的时间起点为发送READ命令之后的(RL-X)个CK周期，持续时长为BL/2 + X个CK周期。其中X为前导时钟长度。 RTT阻值的优先级如下：电阻Disable &gt; RTT_WR &gt; RTT_NOM &gt; RTT_PARK。优先级表明，当ODT pin为高电平时，如果WR命令到来，则此时对应的终端电阻为RTT_WR而非RTT_NOM；如果此时为RD命令，即使ODT pin为高，回传数据时DARM将会disable终端电阻。
表72为具体的终端电阻状态。
当发送READ命令后，DRAM将会在回传读数据的时候将终端电阻设置为高阻态。当RTT_WR使能后，在发送写命令的时候无论ODT pin以及其它MR的设置如何，其终端电阻值都为RTT_WR。当disable RTT_NOM，ODT receiver的供电将关闭以降低功耗。 终端电阻的有效值Rtt可以为240,120,80,60,48,40,34欧姆。
图175展示了RTT阻值的计算方式。
表73展示了，当经过ZQ校准后，在不同的Vout的情况下，在整个温度范围内，RTT阻值的取值范围为。其中最左列为RTT的标准取值。
5.2 同步ODT模式 当DLL打开并被锁定时，都将选择同步的ODT模式。同步ODT模式包括：
当CKE为高时任何bank被激活当CKE为高时的刷新当CKE为高时DRAM的idle状态Active Power downw模式Precharge Power down模式 其中第四点和第五点要根据4.28章节的Power Down内容给出解释，如下：
如果任何命令完成后，所有的bank都被关闭，此时进入power down模式，称为precharge Power Down模式；如果命令完成后，有任何一个bank打开，此时进入Power down模式称为active power down模式。详见表56的描述。
在同步ODT模式中，当CK上升沿采样到ODT pin为高时，经DODTLon个CK周期后，终端电阻值变为RTT_NOM，当在CK上升沿采样ODT pin为低时，经DODTLoff个CK周期后，终端电阻阻值不再为RTT_NOM。ODT开启和关闭的延迟与Write Latency有关，WL = CL+AL+PL，DODTLon=WL-2，DODTLoff=WL-2。前导时钟为2tCK时，DODTLon=WL-3，DODTLoff=WL-3。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c884ce1aeb822da802b707a41b09798a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cf3b9dee359e29b2ef39de3c20a0d22/" rel="bookmark">
			SQL语句基础用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据库定义语句（DDL语句） 1，CREATE DATABASE 创建数据库
CREATE DATABASE USERDB 注：CREATE 表示创建的意思，DATABASE后加新建数据库名
2，USE USERDB GO 指定给数据库
USE USERDBGO AS 注：USE 后加数据库，主要是指新建查询后，不是在你想要的数据库中，可以使用该语句转过去
3，创建视图
CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition 注:创建视图时可以先写好查询语句，多表使用内连接。然后把下面的select语句替换就好了
4，CREATE TABLE 创建一张表
CREATE TABLE table_name( column_name1 data_type(size), column_name2 data_type(size), column_name2 data_type(size),....) 注：DATABASE后加表名，括号中写列名，空格加列的数据类型。逗号后写你需要添加的列。
5，CONSTRAINT 约束
CREATE TABLE table_name( column_name1 data_type(size) constraint_name, column_name2 data_type(size) constraint_name, column_name3 data_type(size) constraint_name, .... ); 注：constraint_name可以换成约束的语句，这里写的不是很详细，可以百度
（1）NOT NULL - 指示某列不能存储 NULL 值。（非空）
（2）UNIQUE - 保证某列的每行必须有唯一的值（主键）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cf3b9dee359e29b2ef39de3c20a0d22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b788223cc98ff5dcdf4c7f201dbd123/" rel="bookmark">
			MindOpt安装配置教程(Windows系统)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 官网有很多的说明文档、教程，但是可能有些地方（这里仅仅补充安装配置部分，其他操作建议自行去官网进行探索）不是很详细，踩了一些坑，所以进行了一些总结。
2 下载安装 url：求解器SDK下载和安装
下载windows64/文件：mindopt-0.23.0.msi。
点击安装下载就可以了，基本是next--&gt;next的操作，可以自行更改安装路径，对于不想安装在C盘。
安装完成后会在【环境变量】----&gt;【用户变量】中的【Path】增加了下面的。
3 LicenseKey设置 url：快速入门（开通和使用）
上面的官方链接文档写得详细，按着操作即可。
LicenseKey购买（0元）申请成功的样子如下：
4 阿里云鉴权账号配置 url：快速入门（开通和使用）
新建一个文件夹，用于存放fl_client.ini配置文件，我放在存在安装文件的同一目录。
[security] # key for client authentication aliyun_license_key = xxx #请修改成您购买服务的LicenseKey信息，见控制台的已购服务列表（开通服务中描述） aliyun_ak_id= xxx #请修改成您阿里云账号的AccessKey信息 aliyun_ak_secret= xxx #请修改成您阿里云账号的AccessKey Secret信息 #以下内容复制后，无特殊情况不需要更改 [server] # license server host name = opt.cn-beijing.aliyuncs.com # 请修改为您购买区域的endpoint，当前仅开放的北京区，不需要修改。 # license server port 80 if absent port = 443 # license server is https protocol https = true # client side request timeout in second request_timeout = 2 修改地方3处
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b788223cc98ff5dcdf4c7f201dbd123/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b7c140353a753cc0925407a61476af/" rel="bookmark">
			TCP/IP连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP/IP连接
手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。
建立起一个TCP连接需要经过“三次握手”:
第一次握手：客户端主动向服务器发送SYN(SYN=1)包以及序列号seq(seq=x)到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态。
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
注意：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。
四次挥手：
第一次断开：客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
第二次断开：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
第三次断开：客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK(最后确认)状态，等待客户端的确认。
第四次断开：客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb7e55dc0d0827b6895ec89c58b5a32/" rel="bookmark">
			kali root 密码忘记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1.在登录界面直接按E进入配置界面
2. 找到linux那一行 更改ro为rw （光标前边的会被改变） 3.然后在这一行后边加上 init=/bin/bash
3. 接下来按Ctrl x 进入单用户模式
4.键入passwd root
5.然后连续两次键入新密码即可
6.接下来重新启动kali输入用户名root 和刚改的密码就可以啦
1.在登录界面直接按E进入配置界面 2. 找到linux那一行 更改ro为rw （光标前边的会被改变） 3.然后在这一行后边加上 init=/bin/bash init=/bin/bash 改完后如下图：
3. 接下来按Ctrl x 进入单用户模式 passwd 用户名可以更改对应用户名的密码
这里要修改root
4.键入passwd root passwd root 5.然后连续两次键入新密码即可 （注意尽量不要用右边的小键盘输入数字 因为有可能小键盘的锁没有打开 建议用键盘上边那一排数字键）
6.接下来重新启动kali输入用户名root 和刚改的密码就可以啦 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/097efa9ac4bea5b8a4a3c8afda7db6ed/" rel="bookmark">
			HTML的基本使用(适用于Java后端)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
注释
基本标签
双标签：
样式标签：
单标签：注意斜杠在后面
常用转移符号：转义符全部以&amp;开头
列表
无序列表
有序列表
定义列表:
表格
表单
语义化表单：
​编辑
HTML5新特性
表单：
视频：video
正则校验
音频：audio
布局标签
内联框架：iframe
CSS
css有三种写法：
基本选择器：
复合选择器：
后代选择器：空格(具有继承性)
交集选择器：
并集选择器 : h1,h2,h3
子代选择器：上级&gt;当前级
相邻同辈选择器：例如h4+h1。
通用同辈选择器：例如h4~h1。
伪类选择器：选中标签后带一个冒号的叫伪类选择器
盒子模型
常见css样式和标签：
圆角边框 一些案例
列表案例1(普通列表)：
列表案例2(定义列表)：
注释 css中 /**/
html中 &lt;!-- --&gt;
基本标签 双标签： 标题标签：&lt;h1&gt;只有1-6&lt;/h6&gt;
段落标签：&lt;p&gt;两个相邻的p标签会换行&lt;/p&gt;
超链接：&lt;a href="如果是自己写的网页，一般填相对路径"&gt;&lt;/a&gt;
锚链接:&lt;a href="hello.html#maodian"&gt;&lt;/a&gt; 前提是在hello页面存在锚点 &lt;a name="maodian"&gt;&lt;/a&gt;
功能邮件:&lt;a href="mailto:308418817@qq.com"&gt;请联系我，点击该标签会直接触发邮件功能&lt;/a&gt;
a标签搭配样式：
target="_blank" 新开窗口
target="_self" 在当前窗口打开(默认)
text-decoration:none;去除下划线
text-decoration:line-through;横穿下划线
text-decoration:underline;下划线(默认)
text-decoration:overline;上划线
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/097efa9ac4bea5b8a4a3c8afda7db6ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d13a11647a4f920acf59c4b85a7d7aab/" rel="bookmark">
			srand和rand详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 srand 使用srand引用头文件#include&lt;stdlib.h&gt;
在rand调用之前设置srand，若不设置当rand调用时随机数种子默认为1，随机数种子一样则每次打印出来的值也是一样的。
设置srand
srand( (unsigned int )time(NULL) )
如上所示，我们给一个持续变化的量，什么是持续变化的量呢？时间就是持续变化的量又称时间戳,使用time函数需要引头文件#include&lt;time.h&gt;
srand不要重复定义否则会导致rand()输出的值并不随机且相等。设置srand不超过1s,值相同（重复定义）。
如：
rand 头文件#include&lt;stdlib.h&gt;
rand产生随机数,范围rand()会返回一个范围在0到RAND_MAX（至少32767）之间的伪随机数。
伪随机（pseudorandom）就是由算法生成的随机数，真随机是真正随机的数 。
rand范围rand()%1000～99rand()%100+11~100 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/893798edd8db6ee45f8b257dfcf67213/" rel="bookmark">
			【C#】运算符重载(operator)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述可重载运算符不可重载运算符示例来源 概述 用户定义的类型可重载预定义的 C# 运算符。 也就是说，当一个或两个操作数都是某类型时，此类型可提供操作的自定义实现。
使用 operator 关键字来声明运算符。 运算符声明必须符合以下规则：
同时包含 public 和 static 修饰符。一元运算符有一个输入参数。 二元运算符有两个输入参数。 在每种情况下，都至少有一个参数必须具有类型 T 或 T?，其中 T
是包含运算符声明的类型。 可重载运算符 运算符说明+x, -x, !x, ~x, ++, --, true, falsetrue和 false 运算符必须一起重载。x + y, x - y, x * y, x / y, x % y,
x &amp; y, x | y, x ^ y,
x &lt;&lt; y, x &gt;&gt; y, x &gt;&gt;&gt; yx == y, x !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/893798edd8db6ee45f8b257dfcf67213/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/661bdaf47ee3c00a356f80d7ee8bb2e8/" rel="bookmark">
			机器学习笔记之深度玻尔兹曼机(一)玻尔兹曼机系列整体介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习笔记之深度玻尔兹曼机——玻尔兹曼机系列整体介绍 引言关于含隐变量模型的对数似然梯度玻尔兹曼机受限玻尔兹曼机深度信念网络深度玻尔兹曼机 引言 从本节开始，将介绍玻尔兹曼机系列的最后一个模型——深度玻尔兹曼机(Deep Boltzmann Machine,DBM)
关于含隐变量模型的对数似然梯度 在之前介绍的包含隐变量的能量模型如波尔兹曼机、受限波尔兹曼机，其能量模型的结构均可表示为如下形式：
本质上就是包含隐变量的马尔可夫随机场~
P ( X ) = 1 Z ∑ i = 1 K ψ i ( x C i ) \begin{aligned} \mathcal P(\mathcal X) = \frac{1}{\mathcal Z} \sum_{i=1}^{\mathcal K} \psi_{i}(x_{\mathcal C_i}) \end{aligned} P(X)=Z1​i=1∑K​ψi​(xCi​​)​
其中 X \mathcal X X表示随机变量集合(包含隐变量、观测变量); x C i ( i = 1 , 2 , ⋯ , K ) x_{\mathcal C_i}(i=1,2,\cdots,\mathcal K) xCi​​(i=1,2,⋯,K)表示极大团;对应的 ψ i ( x C i ) \psi_i(x_{\mathcal C_i}) ψi​(xCi​​)表示该极大团对应的势函数。由于势函数的非负性质，因此如果从能量模型的角度观察势函数，可将 P ( X ) \mathcal P(\mathcal X) P(X)表示为如下形式:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/661bdaf47ee3c00a356f80d7ee8bb2e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac4b8725a441f24f3af256e80d8db5b/" rel="bookmark">
			to_hdf提示：ImportError: Missing optional dependency ‘tables‘. Use pip or conda to install tables.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用to_hdf保存文件
提示：ImportError: Missing optional dependency ‘tables‘. Use pip or conda to install tables.
stack overflow回答：
I ran into the same thing. The error tells you (unhelpfully) that the missing package is called tables when in fact, it’s called pytables. Doing conda install pytables is all I needed to do to be able to read h5 files with pandas.
提示安装pytables
网上流行的方法：
conda install pytables pip install tables pytables和tables都尝试安装，仍未解决问题
pip install tables==3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ac4b8725a441f24f3af256e80d8db5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/161dd8c0835a99e1df79a6bc3cba6d04/" rel="bookmark">
			SQL多表查询：SQL JOIN连接查询各种用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，设定两张表，作为下面例子的操作对象。
表1 学生信息表
表2 专业班级表
再来个SQL JOIN连接查询各种用法的大合影，先预热一下。
No.1 【INNER JOIN】内连接 这是最常用的，获取两个表中指定字段满足匹配关系的记录。
内连接通常有两种情况：
等值连接：查找两个表中连接字段相等的记录。
--查询每个学生的学号、姓名、籍贯、年龄、专业、班级 --涉及到student和major两张表，用共有字段“学号”为连接字段 --写法1：使用INNER JOIN SELECT A.学号,A.姓名,A.籍贯,A.年龄,B.专业,B.班级 FROM student A INNER JOIN major B ON A.学号=B.学号 --写法2：--省去了INNER，直接写JOIN，与INNER JOIN没有区别 SELECT A.学号,A.姓名,A.籍贯,A.年龄,B.专业,B.班级 FROM student A JOIN major B ON A.学号=B.学号 --写法3： --使用WHERE，已经逐渐被淘汰 SELECT A.学号,A.姓名,A.籍贯,A.年龄,B.专业,B.班级 FROM studentA,majorB WHERE A.学号=B.学号 --上面三种写法的结果都是一样的，推荐使用写法2 自身连接：就是和自己进行连接查询，给一张表取两个不同的别名，然后附上连接条件。
--要在学生表里查询与 HH 同龄且籍贯也相同的学生信息 SELECT B.学号,B.姓名,B.性别,B.籍贯,B.年龄 FROM student A JOIN student B ON A.年龄=B.年龄 AND A.籍贯=B.籍贯 AND A.姓名='HH' No.2 【LEFT JOIN】左连接 获取左表中的所有记录，即使在右表没有对应匹配的记录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/161dd8c0835a99e1df79a6bc3cba6d04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e3f3b8e055ea2a857c3cfa447b04d61/" rel="bookmark">
			NumberFormatException: For input string的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示的异常信息 java.lang.NumberFormatException: For input string: "1613989034357489665" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) ~[na:1.8.0_333] at java.lang.Integer.parseInt(Integer.java:583) ~[na:1.8.0_333] at java.lang.Integer.parseInt(Integer.java:615) ~[na:1.8.0_333] at com.douyin.service.impl.UserServiceImpl.register(UserServiceImpl.java:96) ~[classes/:na] at com.douyin.service.impl.UserServiceImpl$$FastClassBySpringCGLIB$$e03aaf42.invoke(&lt;generated&gt;) ~[classes/:na] at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:685) ~[spring-aop-5.2.4.RELEASE.jar:5.2.4.RELEASE] at com.douyin.service.impl.UserServiceImpl$$EnhancerBySpringCGLIB$$5d82ad2e.register(&lt;generated&gt;) ~[classes/:na] at com.douyin.controller.UserController.register(UserController.java:30) ~[classes/:na] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_333] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_333] at 分析原因 这个异常是字符转化为int的时候出现问题了
我是做一个注册接口，需求是前端需求传过来注册的用户名和密码，要返回一个int型的id（主键）
我一开始的方案id的主键策略用的是Mybatis Plus自带的雪花算法来生成id，所以生成的id是一个19位数字的随机数，要求又要我转化为int返回，生成的是String类型的，我在转化的过程中把19位数组的字符串转化为int的时候，就出现了这个异常，因为19位数字是超过int长度的。
所以出现报错
于是我把id换成了123再进行转化，发现就没有出现这种错误了
解决方案 我把mybatis-plus的主键策略从雪花算法改成了主键自增策略，数据库id类型也从varchar改成了int型，因为前端的app是已经写好了的，他就要求我返回int型的id
最后就解决了这种问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15d183dd0c3915ce5845496ffabd471d/" rel="bookmark">
			Linux系统开关机命令和启动级别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统开关机命令和启动级别 1.常用关机,重启命令 shutdown init rebbot poweroff half 1.shutdown 关机命令 作用:关机,重启,定时关机 语法:shutdown [选项] 参数 1.常用参数: -r 重启计算机 -h 关机;定时关机 2.实例: $ shutdown -h +10 #10分钟之后关机 $ shutdown -h 23:30 #指定具体的时间点进行关机 $ shutdown -r 20:00 #20:00 以后重启 $ shutdown -h now #立即关机 2.Linux系统的7个启动级别 作用:切换系统运行级别 语法:init 0-6 1. 启动级别 0 系统停机模式,系统默认运行级别不能设置为0,否则不能正常启动,机器关机
1 单用户模式,root权限,用于系统维护,禁止远程登陆,就像Windows下的安全模式登录
2 多用户模式,没有NFS和网络支持
3 完整的多用户文本模式,有NFS和网络,登陆后进入控制台命令模式
4 系统未使用，保留一般丌用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置
5 图形化模式，登陆后进入图形 GUI 模式，X Window 系
6. 重启模式，默认运行级别丌能设为 6，否则丌能正常启劢。运行 init 6 机器就会重启
1.范例 [root@localhost ~]# init 0 #关机 [root@localhost ~]# init 3 #进入 3 级别字符界面 [root@localhost ~]# init 5 #进入 5 级别图形界面 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15d183dd0c3915ce5845496ffabd471d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c33afd670d49da9c9fce5e959cd58d18/" rel="bookmark">
			怎么查看mysql密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL数据库查看密码的方法如下：
以系统管理员身份运行cmd.
查看mysql是否已经启动，如果已经启动，就停止：net stop mysql.
切换到MySQL安装路径下：D:WAMPMySQL-5.6.36in；如果已经配了环境变量，可以不用切换了。
在命令行输入：mysqld -nt --skip-grant-tables
重启以管理员身份运行一个cmd，输入：mysql -uroot -p，Enter进入数据库。
如果不想改密码，只是想看原来的密码的话，可以在命令行执行这个语句select host,user,password from mysql.user;//即可查看到用户和密码
如果要修改密码的话，在命令行下 依次 执行下面的语句use mysql
update user set password=password(“new_pass”) where user=“root”;// ‘new_pass’ 这里改为你要设置的密码
flush privileges;
exit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76d5435f840833c3b124867783599611/" rel="bookmark">
			Java学习（95）Java泛型——泛型作为方法参数和方法重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java泛型——泛型作为方法参数和方法重载 泛型作为方法参数案例需求前置条件定义抽象类Goods和抽象方法sell() 定义一个商品销售类GoodsSeller，模拟销售测试 泛型作为方法重载 泛型作为方法参数 案例需求 (1) 定义一个抽象类Goods，包含抽象方法sell()
(2) 分别定义类Book、Clothes和Shoes继承Goods，并实现sell()方法，输出一句话，如：sell books
(3) 定义一个商品销售类GoodsSeller，模拟销售，包括方法：
public void sellGoods(List goods)，循环调用List对象的sell()方法
(4) 测试
前置条件 定义抽象类Goods和抽象方法sell() package com.study.generic; public abstract class Goods { public abstract void sell(); } ### 定义子类：Book、Clothes和Shoes ```java package com.study.generic; public class Book extends Goods { @Override public void sell() { System.out.println("sell books"); } } public class Clothes extends Goods { @Override public void sell() { System.out.println("sell clothes"); } } public class Shoes extends Goods { @Override public void sell() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76d5435f840833c3b124867783599611/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8db2928875292061423dbf747316d6d8/" rel="bookmark">
			跨链桥安全事件总结分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跨链桥事件总结分析 Poly Network 跨链桥事件 Relayer的不完整检验
源链上(Ontology)的relayer没有对上链的交易做语义校验，因此包含修改keeper恶意交易可以被打包到poly chain上
目标链上(以太坊)上的relayer虽然对交易做了校验，但是攻击者可以直接调用以太坊上的EthCrossChainManager合约最终调用EthCrossChainData合约完成签名修改
攻击者精心够着了能导致hash冲突的函数签名，从而调用putCurEpochConPubKeyBytes完成对签名的修改
见攻击步骤的具体分析
Poly Network事件分析
Polygon Plasma Bridge漏洞 外部验证+乐观验证 该漏洞可以伪造铸币证明，导致双花攻击
完整的一次Withdraw交易过程如下：
用户在Polygon上发起Withdraw交易，该交易会burn掉用户在Polygon的代币；经过一个检查点间隔（大约30分钟），等待该withdraw交易被包含到检查点中；超过2/3的验证者签名后将其提交到以太坊，此时用户调用ERC20PredicateBurnOnly合约中的startExitWithBurntTokens()校验checkpoint是否包含burn交易；校验通过，则铸造一个NFT退款凭证发给用户用户等待7天挑战期调用WithdrawManager.processExits()销毁NFT，并退款给用户 Polygon为了防止交易重放（双花攻击），使用NFT作为退款凭证，来唯一标识一笔Withdraw交易。但是，由于NFT的ID生成缺陷，造成了攻击者可以构造参数利用同一笔有效的Withdraw交易，生成多个不同ID的NFT，再利用这些NFT进行退款交易，从而实现“双花攻击”。
addExitToQueue()会调用_addExitToQueue()铸造一个NFT,NFT的ID是由Plasma Bridge的age优先级生成WithdrawManager.verifyInclusion()函数对这样的withdraw交易进行校验，并生成对应的age交易的校验和age的生成过程，都依赖参数data解码出的branchMaskBytes交易的校验过程调用_getNibbleArray()对branceMaskBytes 进行了转码操作。
该函数将对应的HP编码，转成对应的Hex编码。
如果传入的HP编码后的值b的第一个十六进制位（半个字节）是1或3，就解析第二个十六进制位。否则，就直接忽略第一个字节。那么如果攻击者构造一个branchMaskBytes参数，使得其第一个十六进制位不等于1和3，则共有14*16 = 224种方式，能够获得相同的转码后的值 Hex转HP [6,3,6,1,7,4,10] Hex编码 [20,63,61,74] HP编码 HP转Hex [15,23,45,32,62] HP编码 [5,2,3,4,5,3,2,6,2]Hex编码 [20，45，76，34]HP编码 [23，...]HP编码 [4，5，7，6，3，4，10]Hex编码 Polygon事件分析CN
Polygon事件分析Eng
Meter.io 跨链桥事件 绕过源链上代币的锁定过程，却获得了代币的锁定证明，进而在目标链铸造资产
deposit()用于ERC20代币的存款，depositETH()用于WETH/WBNB代币的存款。Bridge合约提供了两种方法：deposit()和depositETH()用于上述两种代币的存款，但是deposit()并没有阻止WETH/WBNB的存款交易，并且存在有着缺陷的逻辑判断。 当tokenAddress不为_wtokenAddress地址时进行 ERC20 代币的销毁或锁定，若为_wtokenAddress则直接跳过该部分处理.
跨链桥合约中的depositETH函数会将链平台币转为wToken后转至depositHandler地址，所以在depositHandler执行deposit逻辑时，已处理过代币转移，故跳过代币处理逻辑
但跨链桥合约的deposit函数中并没有处理代币转移及校验，在转由deposiHandler执行deposit时，若data数据构造成满足tokenAddress == _wtokenAddress即可绕过处理
慢雾Meter.io跨链桥分析
Meter.io跨链桥分析
Wormhole Bridge跨链桥事件 利用虚假的签名，在目标链Solana链上mint了12万个WETH。
Wormhole中引入了Validator角色–即guardians
Wormhole中没有leader角色，所有的guardians都对其监听到的on-chain event执行相同的计算，同时对Validator Action Approval (VAA)签名。若有⅔+的大多数guardian节点使用各自私钥对同一event签名，则在所有链上的Wormhole合约都将自动认为其是有效的，并触发相应的mint/burn操作。 攻击者在Ethereum上向Solana转入0.1ETH在Solana上铸造Wormhole ETH的交易触发了Wormhole函数complete_wrapped函数的参数之一是transfer message ,guardians 签名的消息，说明铸造的代币和数量transfer message 是通过触发post_vaa函数创建的，检查guardians的签名来检查消息是否有效实际上post_vaa并不检查签名，典型的Solana方式，智能合约通过调用verify_signatures函数创建verify_signatures 函数的输入之一是Solana内置的system程序，在verify_signatures中调用Secp256k1签名验证函数Wormhole合约使用函数load_instruction_at来检查Secp256k1函数是否被首先调用load_instruction_at 函数最近被弃用了，因为它不检查它是否针对实际系统地址执行攻击者创建自己的账户地址，存储与Instrcutions sysvar相同的数据。使用这个伪造的system程序，攻击者可以有效地谎报签名检查程序已被执行，但根本没有检查签名 Wormhole Bridge跨链桥事件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8db2928875292061423dbf747316d6d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18eb20449ac762535c532a6554566079/" rel="bookmark">
			使用ASM框架创建ClassVisitor时遇到IllegalArgumentException的一种可能解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 ASM是java语言中最为广泛使用的插装框架，其优点在于可以动态地在运行时改变java系统的行为，加入我们自己的逻辑。在软件测试领域应用广泛。但是其使用难度很高，一方面使用asm框架需要对java底层知识有较高的了解，另一方面网上关于asm的资料较少出现问题经常难以搜索到解决方案。参考资料[1]-[3]提供了一些关于asm的基础介绍。
使用ASM时一个非常大的问题在于我们往往需要将自己的少量逻辑插入到复杂的目标系统中进行测试，而我们对目标系统却没有很深的理解。这样当由于目标系统一些特性使得我们的插装代码出错时，我们就很容易处于一种无处下手的状态。
我在使用ASM插装一个不算太复杂的框架raft-java时，创建ClassVisitor总是会在构造函数出爆出IllegalArgumentException，这个问题困扰了我两天，最后发现是由于系统中多次引用asm后声明版本号不一致导致。在此记录下来以供其他的asm初学者进行参考。
问题描述 使用ASM插装raft-java时，遇到问题如下：
raft-java插装点：ServerMain类的main方法的server.start()语句前。
在server.start()执行前插入我们自己的函数逻辑。
插装逻辑如下图。
ClassReader cr = new ClassReader(input); ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS); RaftDownCLassVIsitor rcv = new RaftDownCLassVIsitor(ASM9, cw); cr.accept(rcv, 0); byte[] contents = cw.toByteArray(); 其中RaftDownClassVisitor是我自己写的插装类，这里只摘录其构造函数和visitMethod函数。
public RaftDownCLassVIsitor(int api, ClassVisitor classVisitor) { super(api, classVisitor); } @Override public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) { logger.info("visitMethod" + name); MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions); if (className.equals("com/github/wenweihu86/raft/example/server/ServerMain")) { logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18eb20449ac762535c532a6554566079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7621a56a8f6eaba22d3569b606d0789a/" rel="bookmark">
			Fiddler打开后提示:AppContainer Configuration
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fiddler打开后提示:AppContainer Configuration 这是Fiddle打开后的一个警告消息，表示Windows系统上的“AppContainer”隔离技术可能会干扰来自沉浸式应用程序和Edge浏览器的流量捕获，建议使用Fiddler Classic的winConfig工具来启用流量捕获。Windows的AppContainer技术对于一些应用程序和浏览器的网络流量进行了隔离，Fiddler无法直接捕获到这些流量。点击“Yes”进入Windows官网详细了解，点击“No”关闭窗口，点击“Cancel”禁用这个警告。如果要启用这个功能，可以在Fiddler Classic 的工具栏中单击“winConfig”按钮可以启用流量捕获。
沉浸式应用程序 沉浸式应用程序是一种特殊的应用程序，可以在Windows系统中充分利用所有硬件资源，提供更高的用户体验。沉浸式应用程序通常可以运行在全屏模式，并且可以访问系统底层的硬件和服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d008fade348f24d6b2b3a3f0f475db5a/" rel="bookmark">
			Pandas 安装与教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Pandas 是 Python 语言的一个扩展程序库，用于数据分析。
Pandas 是一个开放源码、BSD 许可的库，提供高性能、易于使用的数据结构和数据分析工具。
Pandas 名字衍生自术语 "panel data"（面板数据）和 "Python data analysis"（Python 数据分析）。
Pandas 一个强大的分析结构化数据的工具集，基础是 Numpy（提供高性能的矩阵运算）。
Pandas 可以从各种文件格式比如 CSV、JSON、SQL、Microsoft Excel 导入数据。
Pandas 可以对各种数据进行运算操作，比如归并、再成形、选择，还有数据清洗和数据加工特征。
Pandas 广泛应用在学术、金融、统计学等各个数据分析领域。
数据结构 Series 是一种类似于一维数组的对象，它由一组数据（各种Numpy数据类型）以及一组与之相关的数据标签（即索引）组成。
DataFrame 是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型值）。DataFrame 既有行索引也有列索引，它可以被看做由 Series 组成的字典（共同用一个索引）。
安装 安装 pandas 需要基础环境是 Python，开始前我们假定你已经安装了 Python 和 Pip。
使用 pip 安装 pandas:
pip install pandas 安装成功后，我们就可以导入 pandas 包使用：
import pandas 实例 - 查看 pandas 版本
import pandas T = pandas.__version__ # 查看版本 print(T) # 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d008fade348f24d6b2b3a3f0f475db5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15685a77e83def658410c4ad03b118c8/" rel="bookmark">
			[ 环境搭建篇 ] 安装python环境并配置环境变量(附python3.10.3安装包)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍬 博主介绍 👨‍🎓 博主介绍：大家好，我是 _PowerShell ，很高兴认识大家~
✨主攻领域：【渗透领域】【数据通信】 【通讯安全】 【web安全】【面试分析】
🎉点赞➕评论➕收藏 == 养成习惯（一键三连）😋
🎉欢迎关注💗一起学习👍一起讨论⭐️一起进步📝文末有彩蛋
🙏作者水平有限，欢迎各位大佬指点，相互学习进步！
文章目录 🍬 博主介绍一、下载安装python1、下载python2、安装python1.选择安装方式2.配置安装选项3.开始安装4.查看安装目录5.进入python交互式解释器6.检查环境变量 二、python环境变量配置过程1、配置环境变量2、配置成功 三、相关资源 一、下载安装python 1、下载python 下载链接在文末给出，下载之后是一个python的exe程序
也可以去官网下载：
https://www.python.org/downloads/windows/ 2、安装python 下载之后双击exe程序安装就OK了
1.选择安装方式 双击打开exe文件开始安装
勾选Add Python 3.6 to PATH 这个选项
在安装python的过程中，自动添加了环境变量，在3.0以前，环境变量都是手动添加的，很多人都在这里卡很久。
点击Customize installation
这种安装方式允许我们自由配置安装选项。
2.配置安装选项 这里它默认都勾选上了，直接点击下一步，进入下一个配置界面
这里我们勾选Install for all users，勾上这个选项后，会在系统的环境变量里加入python，有关python的环境变量会设置在系统变量中，Path的值里面你刚刚安装好的python和python目录里的Scripts目录。
当在cmd命令窗口执行python或者pip命令时，计算机会从Path所设置的文件夹中寻找python.exe文件或者pip.exe文件，如果找不到就会报出类似“xx不是内部或外部命令”的错误。
修改python的安装位置，我这里是靶机，我就直接默认了，你可以根据自己的电脑情况选择安装。
3.开始安装 上面我们点击install就开始安装了，能看到如下面板，需要等一会儿
这是安装结束时的界面，出现了successful，关闭安装界面就可以了
4.查看安装目录 进入跟目录，默认是C:\Program Files\Python310
如果你没有安装在默认路径，你就打开自己的安装路径
在这个安装目录里，我们注意Scripts文件夹和python.exe， 这个python.exe就是python解释器，你在配置pycharm的时候还会用到它。
Scripts文件夹里放的是pip和easy_install第三方库管理工具
Lib\site-packages目录，是安装存储第三方库的地方。
5.进入python交互式解释器 打开运行窗口，输入python即可
在交互式解释器里，可以验证一些简单的代码
交互式是指你写的代码，会立刻被执行并显示结果，这样及时反馈，有助于学习基础。
复杂的代码，例如函数，虽然也可以在这里编写，但写起来不方便，而且无法保存代码。
6.检查环境变量 在系统变量里找到Path变量，由于我们勾选Add Python 3.6 to PATH和Install for all users，所以，有关python的环境变量会自动配置。我们来检查一下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15685a77e83def658410c4ad03b118c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/956f153f6b5286c52c6f3dc932d90521/" rel="bookmark">
			Matlab通信工具箱comm.ErrorRate思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原函数Mathworks介绍地址：Compute bit or symbol error rate of input data - MATLAB- MathWorks 中国
其实函数本质很好懂，给定待比较的两个向量，计算差异值，给出ber或ser信息。
不过Matlab的这个函数在小细节处需要留意：
这个函数主要是比较原始数字信号和接受数字信号的误bit率或误码率，支持传入bit流和symbol流
如果在BPSK 调制下比较：发送了[0 1 1 0] ,经过调制和信道传输后收到了[0 0 1 0]
函数会识别到 ber是0.25，一共发生1 bit错误，总共处理了4个bit;
返回值是向量[0.25, 1, 4]；这没有问题，很好理解，因为此时ber数值上就等于ser。
如果在QPSK 格雷码调制下比较：发送了bit流[0 1 1 0]，symbol符号意义即（[1 2]），经过调制和信道传输后收到了[0 0 1 0] symbol符号意义即（[0 2]）
如果函数的输入是bit流，则会识别到ber是0.25，发生1bit错误，总共处理4bit（4个样本）；
但如果给函数输入的不是bit流，而是让他比较[1 2] ,[0 2], 也能识别出发生1bit错误， 但由于处理样本只有2(symbol)，所以返回值会变成[0.5, 1, 2]，本质是就是返回了误码率ser
所以如果输入不是bit流， 使用此函数的结果并不是ber而是ser，需要手动更新返回值，否则可能会影响ber仿真作图效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/333c725621358b2f4e926f4f7118acd8/" rel="bookmark">
			python的webdriver应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文总结如何使用python的webdriver插件，应用自动化测试以及爬虫抓取数据。
工具选择 谷歌版本下载：https://www.iplaysoft.com/tools/chrome/
webdriver版本：http://npm.taobao.org/mirrors/chromedriver/ 或https://chromedriver.storage.googleapis.com/index.html
webdriver和谷歌的版本需要对应，比如谷歌的版本是109，就得下载109版本的webdriver
vscode开发工具：https://code.visualstudio.com/
python3.7：https://www.python.org/downloads/
vscode的python插件 1、首先安装python3.7软件 window的cmd下，输入python若出现以下的提示，就是安装完成。
2、安装python插件 点击左侧栏Extension (或输入 Ctrl + shift + X) 进入插件面板。
3、创建venv虚拟目录 该目录下的文件，独立存放python的第三方软件包。比如在D盘新建一个文件夹venv，在vscode终端中运行以下命令。
D: #进入D盘 md venv #新建venv文件夹 python -m venv /venv #使用Python创建venv环境 cd /venv source bin/activate #激活venv环境，可以看到虚拟环境中的 Package 只有最基础的 pip、setuptools cd /venv deactivate #退出venv环境 使用pyvenv.cfg简化venv的开关，这样，vscode在运行相关Python程序的时候，就能自动开关venv环境了。
打开vscode，使用快捷键ctrl+shift+' 或 菜单栏-terminal-new terminal，打开终端
D: cd /venv source bin/activate deactivate 通常，vscode就会在该目录下，自动创建一个pyvenv.cfg文件。
今后只要用vscode打开这个目录，直接运行Python程序，就会自动切换到venv模式下运行。
到这里就可以使用python自带pip工具，安装一个第三方软件selenium
pip3 install selenium 第一支脚本 webdriver是selenium的组件，Selenium 是一个 Web 的自动化测试工具，最初是为网站自动化测试而开发的。Selenium 自己不带浏览器，不支持浏览器的功能，它需要与第三方浏览器结合在一起才能使用。它支持所有主流的浏览器（包括 IE、Firefox、Safari、Opera 和 Chrome 等）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/333c725621358b2f4e926f4f7118acd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05bffc2bf73ea7c498077abd30b9f849/" rel="bookmark">
			C&#43;&#43;的MFC实现DDA算法画直线，从目录创建到完整代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先给他一个菜单栏的按钮
然后在属性处给他一个ID 然后在类视图右键你的view（是你的项目名称后面带一个view的那个）点击属性
然后 在消息栏给他一个消息，会自动生成一个空函数体
然后取事件栏给他一个事件，会生成一个空函数体void CMFCApplication1View::OnDdaLine()
给void CMFCApplication1View::OnDdaLine()加以下代码：
void CMFCApplication1View::OnDdaLine() { // TODO: 在此添加命令处理程序代码 MenuDrawType = 2; PressNum = 0; } 然后给void CMFCApplication1View::OnLButtonDown(UINT nFlags, CPoint point)添加代码
void CMFCApplication1View::OnLButtonDown(UINT nFlags, CPoint point) {// TODO: 在此添加消息处理程序代码和/或调用默认值 CClientDC dc(this);//定义当前绘图区 CRect rect; else if (MenuDrawType == 2) {//拿的是DDA //GetClientRect(&amp;rect);//获得客户区大小 if (PressNum == 0) {//第一次点击 startP = point; endP = point;//使线段一直都在，终点始终是鼠标 PressNum++; } else {//第二次点击 endP = point; int dx = endP.x - startP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05bffc2bf73ea7c498077abd30b9f849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/319795213e12ba7273d221e0cb3a299b/" rel="bookmark">
			微信小程序 - 实现手机号登录--授权并获取手机号保存至本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详细代码请见文档最下方，仅供参考，更多需要请查看官方文档 一、 微信官方文档 | 获取手机号
这是服务端的 这是我们前端获取手机号需要给接口传递的两个参数 注意：
参数一：获取access_token需要用到小程序密钥，这个需要从服务端获取，也就是需要请求后端接口获取access_token，千万不要将小程序密钥写在前端代码中，必须要从服务端获取。
参数二：code的获取我们可以点击后面的 "手机号获取凭证" 查看用法，很简单。下面 二、 就是手机号获取凭证地址。
二、 微信官方文档 | 手机号获取凭证
注意：这里有基础库版本限制，所以我们最好做一下低版本兼容处理；
个人使用时碰到的坑：
微信开放社区 | 使用getPhoneNumber获取手机号code，微信PC拿不到code，手机端可以获取到？ 详细实现代码：
&lt;template&gt; &lt;view class="flex"&gt; &lt;view class="title"&gt; &lt;view class="logo"&gt; &lt;image src="/static/image/logo.png" mode="widthFix" /&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 手机号登录 --授权并获取手机号保存至本地 --&gt; &lt;button type="default" class="loginButton" open-type="getPhoneNumber" @getphonenumber="getPhoneNumber" &gt; &lt;view class="row"&gt; &lt;view class="icon"&gt; &lt;u-icon name="weixin-fill" size="28"&gt;&lt;/u-icon&gt; &lt;/view&gt; &lt;view style="font-size: 30rpx"&gt;微信登录&lt;/view&gt; &lt;/view&gt; &lt;/button&gt; &lt;!-- 协议选择 --&gt; &lt;view class="serve-rule"&gt; &lt;u-checkbox-group size="24" @click="changeCheckStatus"&gt; &lt;u-checkbox class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/319795213e12ba7273d221e0cb3a299b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeb8f78769dbf669e40443db956cd626/" rel="bookmark">
			elementPlus日历英文转换为中文问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题说明 开发中运用到了elementPlus日历组件，然后发现组件内出现英文问题；
这就很奇怪，年月是中文，周是英文，然后通过阅读官方文档给出以下解决方案
二、解决方案 1.如果组件内全是英文 //在你的全局配置里引入中文文件 import ElementPlus from 'element-plus' import zhCn from 'element-plus/dist/locale/zh-cn.mjs' app.use(ElementPlus, { locale: zhCn, }) 2.如果出现部分英文 //可以再按照这个方法继续引入 import 'dayjs/locale/zh-cn' 通过反复对文档的解读，我认为出现这样的问题可能是文档内的日历组件是有bug的，之所以能解决出现部分英文的问题，我想应该是Day.js中设置的有合适的区域来进行细致的区分
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/459af587e3f0d128d4c35d5c2ba27a04/" rel="bookmark">
			HTML嵌入CSS样式（四种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML 仅能呈现一些信息，表现能力非常有限，需要结合 CSS 一起使用，以使页面更加精美。
CSS 样式既可以作为单独的文件（.css类型的文件）引入到 HTML 文档中，也可以直接写在 HTML 文档中，大致分为如下四种方法：
行内样式：使用 HTML 标签的 style 属性定义 CSS 样式；内嵌样式：使用 &lt;style&gt; 标签在 HTML 文档头部（&lt;head&gt; 和 &lt;head&gt; 之间）定义 CSS 样式；链接式：使用 &lt;link&gt; 标签引入外部 CSS 样式表文件。导入式：使用 @import 命令导入外部 CSS 样式表文件。 第1种和第2种方法都是将 CSS 样式写到当前 HTML 文档中，第3种和第4种方法都是将 CSS 样式放在外部文件中，然后再导入到当前 HTML 文档中。
1. 行内样式（内联样式） 行内样式就是把 CSS 样式直接放在代码行内的标签中，一般都是放入标签的style属性中，由于行内样式直接插入标签中，故是最直接的一种方式，同时也是修改最不方便的样式。
【示例1】针对段落、&lt;h2&gt; 标签、&lt;em&gt; 标签、&lt;strong&gt;标签以及 &lt;div&gt; 标签，分别应用 CSS 行内样式。
&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;行内样式&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p style="background-color: #999900"&gt;行内元素，控制段落-1&lt;/p&gt; &lt;h2 style="background-color: #FF6633"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/459af587e3f0d128d4c35d5c2ba27a04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16215945c84c75ad9dbcbe10a4fd0b9a/" rel="bookmark">
			Python-Django毕业设计畅玩电竞网咖购物点餐网站（程序&#43;LW）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
SSM + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
3.1 可行性分析 一个完整的系统，可行性分析是必须要有的，因为他关系到系统生存问题，对开发的意义进行分析，能否通过本网站来补充线下购物点餐管理模式中的缺限，去解决其中的不足等，通过对本网站，不仅能使工作量不断地减少，还能使工作和管理的效率更加高。所以开发该网站能实现更大的意义和价值， 网站完成后，能否达到预期效果就要通过可行性分析，分析之后，决定此系统是否开发。该畅玩电竞网咖购物点餐网站的开发设计中，对技术、经济、操作方面进行了可行性分析； 3.1.1 技术可行性 本系统开发选择php技术，它被研究的目的就是在于能够为网页创建等可以看到的信息。随着移动互联网技术的不断发展和创新，php技术俨然已成为下一代互联网的Web标准。所以后台设计选择使用mysql数据库主要用来的建立和维护信息。对于前台开发要求应具备功能完善、易于操作等优点，后台数据库的要求则是能够建立和维护数据信息的统一性和完整性。
3.1.2 操作可行性 现在随着科技的飞速发展，计算机早已经进入了人们的日常生活中，人们的工作环境也不像以前有那么多的要求，需要员工一定要到公司办公，有的工作在家也可以完成。这使得人们的工作效益有了很大的提高。操作的多样性也变高了。因此，管理的计算机化，智能化是社会发展而带来的必然趋势，各种智能的软件层出不穷，不同的软件能完成用户不同的需求，这不仅提高了工作效率还能完成一些客户特定的一些需求。本系统不仅界面简洁明了还采用可视化界面，用户只要用鼠标和键盘就可以完成对相关信息的修改，删除，添加等操作。因为这个系统的操作十分简单，方便上手，对于第一次使用系统的人，只需要很少的时间就可以上手操作。由此可见，本系统在操作上是可行的。
3.1.3经济可行性 基于php的畅玩电竞网咖购物点餐网站，该网站软件开发仅需要一台普通的计算机便可完成实现开发，其成本很低。另外，作为毕业设计作品来讲，开发成本基本上可以忽略不计，且该系统软件的投入使用，可以实现更加快速高效的畅玩电竞网咖购物点餐管理，同时还能实现对人力资源和管理资源的有效节约，该畅玩电竞网咖购物点餐网站在经济上完全可行。
3.2 系统设计规则与运行环境 软件系统的优劣很大程度上是由系统设计的完善与否决定的。世间万物都必须遵循生老病死的法则，这是大自然的规则不能违反，软件设计也一样需要遵循系统设计规则。因此，在设计过程中必须遵循系统设计规则。
规则如下：
简单性：为了扩大系统使用者的受众面，系统设计应该本着操作越简单约好的原则，这样不仅能提高系统的使用率更能够扩大系统使用面。。
针对性：一个系统针对性越强，所能提供的功能必然越完善，用户体验肯定更好，所以应该明确指定系统针对性。
实用性：实用永远是检验一个系统是否成功的唯一标准，使用的语言再高端，使用的结构再新颖但不能满足管理员及用户的要求那就是失败。
运行环境：
本系统是一个利用B/S结构来开发的程序，数据库在服务器上部署MySQL数据库即可，其他包括My Eclipse等常规开发程序。硬件要求：CPU：酷睿i3 -3.0GHZ；内存：4G以上；硬盘：128GB。软件平台：操作系统：Windows 10；数据库：MySQL。
3.3 需求分析
利用php、MyEclipse和mysql数据库等知识点，结合相关设计模式、以及软件工程的相关知识，设计一个畅玩电竞网咖购物点餐网站，来进行记录用户的信息，以及系统信息的增删改查的功能，根据实现需求，系统需完成这些基本功能：
（1）系统合理显示畅玩电竞网咖购物点餐网站系统界面，管理员界面和后台用户界面等界面。
（2）用户和管理员所有的信息都保存与数据库中。
（3）对畅玩电竞网咖购物点餐信息能够进行查询、修改、删除、添加等操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16215945c84c75ad9dbcbe10a4fd0b9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d565286a116b24872a6ed1a9caaeb773/" rel="bookmark">
			Python&#43;Django毕业设计智能超市导购系统（程序&#43;LW&#43;部署）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
SSM + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
3.1 需求分析 开发系统的过程中，去调查用户的功能诉求，对需要存在的功能进行需求分析是特别重要的，且对于系统的开发有着实际的意义，设计智能超市导购系统通过对用户的需求进行分析，结合实际情况进行开发研究，对用户的所有需求做出一个完整的基本的框架，然后一步一步的完成、实现。需求分析可以为系统的开发提供一个目标，只有按照这个目标进行开发设计，才能进行完整的开发，这样设计出的系统才有使用的意义，才能在竞争激烈的软件市场中生存，才能真正的帮助人们解决问题，提高实际的效率。
3.2 系统可行性分析 3.2.1 技术可行性
本系统采取的是目前应用最广泛的程序进行技术的支持，主要的技术支持是java语言，他作为一个相当成熟的语言程序，在众多的软件开发中起着很大作用。而且用java语言编辑出来程序可以直接运行，不需要借助其他的翻译器进行翻译。所以在技术方面是完全可以行的。
3.2.2 经济可行性
本项目开发的初衷就是为了节约，因为系统开发的所有过程都是我自己开发的我，而且在开发过程使用到的技术也都是市面上常见的容易操作的，所以不需要请专业的人士花资金来进行系统的开发，而且在项目开发的过程中我也学到了更多的知识。开发的这个软件可以在网络中进行免费的下载，对计算机的软硬件没有很高的要求，因此这个项目是非常实惠的，在经济方面是完全可性的。
3.2.3 操作可行性
操作可行性也就是系统的可用性，一个系统的操作是否容易决定着这个系统的使用度，在系统的操作方面的设计我都是采取简洁易懂的方式，操作的整个菜单界面整齐有序，所有的功能都有序的排列，不会出现重叠或者需要转换的现象，用户想要哪方面的操作都可以直接进行操作，所以该系统任何人都可以进行操作，不需要有相关专业的技术这样用户在操作起来就容易很多。
3.3 项目设计目标与原则 1、关于智能超市导购系统的基本要求
（1）功能要求：管理员可以对所有的商品进行查看管理，可以对商品进行管理，可以及时的查看管理的情况，还可以对留言进行查看和管理等功能模块。
（2）性能：因为超市管理中有很多的信息需要存储，因此对于系统的存储量有很大的要求，需要有一个强大的数据库的支持才能确保所有的信息都能安全稳定的进行存储。
（3）安全与保密要求：用户都必须通过管理员审核才能进入系统。
（4）环境要求：支持Windows系列、Vista系统等多种操作系统使用。
2、开发目标
智能超市导购系统的主要开发目标如下：
（1）用户可以实时查看最新的商品信息，以及相关资讯；
（2）用户可以对比各大商品的信息，选择自己较为满意的商品；
（3）用户可以通过留言互相交流购买商品心得；
（4）管理员可以在后台方便管理前台网页的各种信息；
3、设计原则
本智能超市导购系统采用SSM技术，Mysql数据库开发，充分保证了系统稳定性、完整性。
（1）系统响应效率：由于是智能超市导购系统，因此就需要系统的响应效率是非常高的，并且可以支持很多人同时进行系统的使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d565286a116b24872a6ed1a9caaeb773/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a1a14c5545acbbd9fd651ee08e69e6f/" rel="bookmark">
			JS数组合并的7种常见方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 项目过程中，经常会遇到 JS 数组合并的情况，时常为这个纠结。这里整理一下
1、ES6解构 […arr, …arr2] 会生成新的数组
let arr = [1, 2] let arr2 = [3, 4] arr = [...arr, ...arr2] console.log(arr) // [1, 2, 3, 4] 2、concat arr.concat(arr2) 会生成新的数组
let arr = [1, 2] let arr2 = [3, 4] arr = arr.concat(arr2) console.log(arr) // [1, 2, 3, 4] 3、push push 结合 …[] 来实现。
会变更原数组
let arr = [1, 2] let arr2 = [3, 4] arr.push(...arr2) console.log(arr) // [1, 2, 3, 4] 4、arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a1a14c5545acbbd9fd651ee08e69e6f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/174/">«</a>
	<span class="pagination__item pagination__item--current">175/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/176/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>