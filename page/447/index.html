<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48048cb8e3150e80114fb9a48c5745da/" rel="bookmark">
			C&#43;&#43; BMP图片转换为PNG图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;windows.h&gt; #include &lt;gdiplus.h&gt; #include &lt;stdio.h&gt; using namespace Gdiplus; BOOL GetEncoderClsid(WCHAR* pFormat,CLSID* pClsid) { GdiplusStartupInput gdiplusStartupInput; ULONG_PTR gdiplusToken; GdiplusStartup(&amp;gdiplusToken, &amp;gdiplusStartupInput, NULL); UINT num = 0,size = 0; ImageCodecInfo* pImageCodecInfo = NULL; GetImageEncodersSize(&amp;num,&amp;size); if (size == 0) { return FALSE; } pImageCodecInfo = (Gdiplus::ImageCodecInfo*)(malloc(size)); if (pImageCodecInfo == NULL) { return FALSE; } GetImageEncoders(num,size,pImageCodecInfo); BOOL bfound = FALSE; for (UINT i = 0;!bfound &amp;&amp; i &lt; num; i++) { if (_wcsicmp(pImageCodecInfo[i].MimeType,pFormat) == 0) { *pClsid = pImageCodecInfo[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48048cb8e3150e80114fb9a48c5745da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/119ef5eaa3919c3984d476dbd65b137d/" rel="bookmark">
			Wget下载整个网站（包含图片/JS/CSS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我会向你展示10个 Wget 命令的实际案例. Wget 是一个用于下载文件的免费工具，它支持大多数常用的Internet协议，包括 HTTP, HTTPS, 以及 FTP.
Wget这个名字来源于 World Wide Web + get. Wget 有很多功能，可以很方便地做到下载大型文件,递归下载,一次下载多个文件以及镜像web网站和FTP站点.
Wget是非交互式的，但是使用起来相当的灵活. 你可以在脚本，cron任务，终端等地方调用它. 它可以在用户未登陆的情况下运行在后台. 也就是说你可以开始下载文件，然后退出系统，wget会在后台运行直到完成任务.
在本文中，我将演示一些wget的使用例子, 这些例子都很常见,比如下载文件，比如镜像整个网站.
在演示前,我们先在 [[https://www.rosehosting.com/ubuntu-vps.html][Ubuntu 16.04]] [[https://www.rosehosting.com/ubuntu-vps.html][VPS]] 上安装wget.
请注意，虽然该演示是在 Ubuntu 16.04 上进行的, 但是这些命令在其他 [[https://www.rosehosting.com/linux-vps-hosting.html][Linux]] 发行版中同样适用.
登陆服务器并安装wget 第一步是 [[https://www.rosehosting.com/blog/connect-to-your-linux-vps-via-ssh/][通过SSH登陆服务器]].
使用下面命令更新你的服务器:
apt-get update apt-get upgrade 然后安装wget软件包:
apt-get install wget 安装完成后，就可以开始使用wget命令了.
1. 下载单个文件 wget最常用也是最简单的用法就是用来下载单个文件.
你可以用下面命令想下载最新版的WordPress
wget https://wordpress.org/latest.zip 你会看到如下输出:
--2017-10-14 03:46:06-- https://wordpress.org/latest.zip Resolving wordpress.org (wordpress.org)... 66.155.40.250, 66.155.40.249 Connecting to wordpress.org (wordpress.org)|66.155.40.250|:443... connected. HTTP request sent, awaiting response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/119ef5eaa3919c3984d476dbd65b137d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb496c7008cc2db6317baa7e5e0bad9d/" rel="bookmark">
			IOS百度地图开发问题汇总（附解决方案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人也是刚刚开始接触地图模块，在百度地图初步的学习中遇到一些问题，在此汇总以及总结
1.在使用CocoaPods自动配置时，在终端有可能出现找不到‘BaiduMapKit’使用位置的情况，也就是在终端输入Pod install后会出现报错，这里应该是你的Podfile文件中导入信息的描述不完全，可能你只写了你想要导入的‘BaiduMapKit’，没有做具体的描述，Podfile文件中的完整阐述应该是：
platform :ios, '7.0' #手机的系统 target 'YourProjectTarget' do #工程名字 pod “BaiduMapKit” #百度地图SDK end 这样的一段形容（要根据自己实际版本和工程名进行改动） 2.在写好Demo之后，要对其中的一些地方进行改动保证程序正确的启动，
在info.plist文件中要注意以下几点（这里的info.plist文件指的是Main处的info文件，注意位置）：
（1）运行提示添加Bundle Display name,则需要在info.plist文件中添加一项Bundle Display name，文件描述就是你的项目名称
（2）获取GPS权限，在info.plist文件中添加一行NSLocationWhenInUseUsageDescription
这里的第一行为输入NSLocationWhenInUseUsageDescription后的自动跳转
（3）最后一个在info.plist中添加的是
这里要提一句，我不记得在哪个地方看见有人说NSLocationWhenInUseUsageDescription这一项要放在App Transport Security Settings上面，正确性和必要性以及原因我也不太清楚，这里提一句，默认放在上面就行了。
3.最后一点，在Xcode模拟器中，我第一次运行，直接定位到旧金山，我还以为是定位服务启动失败了，确定代码无误后，我发现，这是模拟器特有的现象，默认定位在Apple旧金山总部，要调到自己的位置，需要自己设置经纬度，在模拟器设置的custom location中输入你的位置即可：
以上为我现阶段遇到的所有问题，希望对大家有帮助
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41db1c9a8276cff8f72839262591055d/" rel="bookmark">
			DPDK原理概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、DPDK特点 DPDK全称为Date planedevelopment kit，是一个用来进行包数据处理加速的软件库。与传统的数据包处理相比，DPDK具有以下特点：
1) 轮询：在包处理时避免中断上下文切换的开销，
2) 用户态驱动：规避不必要的内存拷贝和系统调用，便于快速迭代优化
3) 亲和性与独占：特定任务可以被指定只在某个核上工作，避免线程在不同核间频繁切换，保证更多的cache命中
4) 降低访存开销：利用内存大页HUGEPAGE降低TLB miss，利用内存多通道交错访问提高内存访问有效带宽
5) 软件调优：cache行对齐，预取数据，多元数据批量操作
2、DPDK框架 图1 DPDK框图
在上图中，核心库Core Libs提供系统抽象、大页内存、缓存池、定时器及无锁环等基础组件。
PMD库，提供全用户态驱动，以便通过轮询和线程绑定得到极高网络吞吐，支持各种本地和虚拟网卡。
Classify库，支持精确匹配，最长匹配和通配符匹配，提供常用包处理的查表操作。
Qos库，提供网络服务质量相关组件，限速和调度。
Mellanox DPDK中保留了Linux内核态驱动，框图如下：
图2 MellanoxDPDK框图
Mellanox DPDK在用户空间使用PMD驱动，与网卡之间有两条路径，控制路径使用user verbs，经过内核，用于对象的创建、初始化、修改、查询和释放。数据路径之间访问网卡，进行数据的收发。
Mellanox DPDK与传统的Linux内核态驱动可以共存，当前未被DPDK使用的端口可以通过Linux网络协议栈进行报文收发。
图3 MellanoxDPDK与传统内核态驱动
3、Hugepage配置 DPDK中，如果有多个核可能需要同时访问一个网卡，那DPDK中会为每个核准备一个单独的接收队列/发送队列，这样避免了竞争，也避免了cache一致性问题。
一般的常规页大小为4K字节，使用大页时页大小设置为2M或1G字节。修改方式如下：
Bashrc文件内添加：
非NUMA系统
Echo 1024&gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages
预留了1024个2M大页，即2GB内存。
NUMA系统
Echo 1024&gt;/sys/devices/system/node/node0/hugepages/hugepages-2048kB/nr_hugepages
Echo 1024&gt;/sys/devices/system/node/node1/hugepages/hugepages-2048kB/nr_hugepages
上述命令为每个节点各预留了1024个2M大页，即4GB内存。
/etc/fstab内添加
挂载2M大页：Nodev /mnt/huge hugetlbfs defaults 0 0
挂载1G大页：Nodev /mnt/huge_1GB hugetlbfs pagesize=1GB 0 0
4、多线程配置 DPDK线程基于pthread接口创建，属于抢占式线程模型，受内核调度支配。通过在多核设备上创建多个线程，每个线程绑定到单独的核上，减少线程调度的开销，以提高性能。控制线程一般绑定到MASTER核上，接受用户配置，并传递配置参数给数据线程等；数据线程分布在不同核上处理数据包。
DPDK中初始化及执行任务分发示例如下图所示：
图4 lcore初始化及执行任务分发
上图中一共使用了三个cpu核，master core负责进行任务初始化和分发，两个lcore执行任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41db1c9a8276cff8f72839262591055d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a1b4c6ec1cfd3ced102cde351e2dcea/" rel="bookmark">
			HTTP 协议 与 golang web 应用服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP 协议 与 golang web 应用服务 本文仅是介绍 golang web 应用与服务的 hello world 的工作原理，开发工具等。
本文要点： 1. 分布式计算 “C/S架构”知识 2. HTTP 协议基础知识；协议分析工具 curl 3. Golang web 应用搭建、工作原理、源代码阅读、程序设计技巧 4. Web 应用框架，压力测试工具 ab
前提条件： 1. OO 思想在 Golang 应用 2. OS 并发基础知识 3. 了解 socket 通讯与 stream 4. 了解 python tornado 框架、Java web 应用服务器框架最好
本文档代码位置：https://github.com/pmlpml/golang-learning/tree/master/web
1、C/S 架构 在分布式计算中，计算机之间协作最基础、最简单的结构就是 C/S 架构 。一个 进程 扮演 Server 提供服务，一个或多个 进程 扮演 Client 发起服务请求。C/S架构（ Client–Server model ）应用及其广泛，从关系数据库服务、到web应用、电子邮局、FTP服务、以及我们现在见到的大多数 云服务 都是C/S架构应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a1b4c6ec1cfd3ced102cde351e2dcea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a5e5b085128458c994d287f2a42a8ad/" rel="bookmark">
			JS实现html页面点击下载文件（共两种实现方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.使用&lt;a&gt;标签来完成 &lt;a href="/user/test/xxxx.txt" download="文件名.txt"&gt;点击下载&lt;/a&gt; 这样当用户打开浏览器点击链接的时候就会直接下载文件。
但是有个情况，比如txt,png,jpg等这些浏览器支持直接打开的文件是不会执行下载任务的，而是会直接打开文件，这个时候就需要给a标签添加一个属性“download”;
以下为例子
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="http://171.**.96.**:****/d/c833945c11/files/?p=/plugins.maintain.CheckLinePartTask/cebab687-6dc5-4128-b7d9-8bc2fe369598.png&amp;raw=1" download="test.png"&gt;点击下载&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 其中download后面的属性是下载后文件的文件名字
如果url指向同源资源，是正常的。
如果url指向第三方资源，download会失效，表现和不使用download时一致——浏览器能打开的文件，浏览器会直接打开，不能打开的文件，会直接下载。浏览器打开的文件，可以手动下载。
解决方案一：将文件打包为.zip/.rar等浏览器不能打开的文件下载。
解决方案二：通过后端转发，后端请求第三方资源，返回给前端，前端使用file-saver等工具保存文件。
2.使用按钮进行监听 按钮监听又可以分为两种方法，
一是window.open()
var $eleBtn1 = $("#btn1"); var $eleBtn2 = $("#btn2"); //已知一个下载文件的后端接口：https://codeload.github.com/douban/douban-client/legacy.zip/master //方法一：window.open() $eleBtn1.click(function(){ window.open("https://codeload.github.com/douban/douban-client/legacy.zip/master"); }); 二是表单提交
//方法二：通过form $eleBtn2.click(function(){ var $eleForm = $("&lt;form method='get'&gt;&lt;/form&gt;"); $eleForm.attr("action","https://codeload.github.com/douban/douban-client/legacy.zip/master"); $(document.body).append($eleForm); //提交表单，实现下载 $eleForm.submit(); }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/913d963ea51bb53a6d47df86e1fcb14f/" rel="bookmark">
			JAVA集合（容器）类知识点汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汇总集合（容器）类的详细知识点 总结写在前面： Java有多种方式保存对象（应该说是对象的引用）。数组将数字与对象联系起来。保存基本类型的数据，保存数据类型明确的对象，取对象时也不需要对对象进行类型转换。它可以是多维的。数组一旦生成容量不能改变。Collection保存单一的元素，Map保存相关联的键值对，通过泛型，可以指定容器中存放的类型，这样获取元素时才不必进行类型转换，否则，获取的元素则为Object对象，需要进行强制类型转换。集合类会自动调整尺寸。容器类不能持有基本类型，但是Java的自动拆箱装箱机制会自动执行基本类型到容器中所持有的包装器类型之间的相互转换。List像数组一样建立数字索引与对象的关联，List是有序的，自动扩充尺寸。如果需要进行大量的随机访问，用ArrayList；如果经常插入或删除元素，用LinkedList。LinkedList提供了方法以支持队列的行为，并且实现了Queue接口。各种Queue和栈的行为，由LinkedList提供支持。Map是将对象与对象关联起来的键值对（key-value）设计。HashMap用来快速访问；TreeMap按照比较结果升序保存键，保持键始终处于排序状态。LinkedHashMap保持元素插入的顺序，但是通过散列提供了快速访问能力。Set不会保存重复的元素。HashSet提供最快的查询速度，TreeSet保持元素处于排序状态。LinkedHashSet以插入顺序保存元素。 借用别人的一张集合框架图 (原地址)：
点线框表示接口，实线框表示普通的类。一共只有四种容器：Map、List、Set、Queue，它们各有2-3个实现版本，常用的容器类四个：ArrayList、LinkedList、HashMap、HashSet。任意的Collection都可以生成Iterator，List可以生成ListIterator（也能生成Iterator，因为List继承自Collection）。
常用集合的元素是否有序，元素是否重复的区别：
一、泛型和类型安全的容器，添加一组元素 未使用泛型时的不安全写法：
class Apple{ public String color; } class Orange{ public int id; } ArrarList apples = new ArrayList(); for(int i = 0;i &lt; 3;i++) apples.add(new Apple()); apples.add(new Orange()); for(int i = 0;i &lt; apples.size();i++) Apple a = (Apple)apples.get(i);//Orange只有在遍历到的时候才会检测到 Java中如果一个类没有显式的声明继承自哪个类，那么自动继承自Object(有点万事万物皆对象的意思)。Apple和Orange是有区别的，它们除了是Object之外没有任何共性。因为ArrayList保存的是Object，因此既可以添加Apple，又可以添加Orange，无论在编译期还是运行时都不会有问题。当在使用ArrayList的get()方法来读取对象时，得到的只是Object引用，必须将其强制转型为Apple。当读取到ArrayList中的Orange对象时，试图将Orange转型为Apple就会报错。这样就很不安全了。
使用泛型时的写法：
ArrarList&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;(); for(int i = 0;i &lt; 3;i++) apples.add(new Apple()); //apples.add(new Orange()); for(int i = 0;i &lt; apples.size();i++) Apple a = apples.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/913d963ea51bb53a6d47df86e1fcb14f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ec32c297d75865ae35c185c4e16551/" rel="bookmark">
			mybatis查询sql：where语句“查询时间字段书写问题”引发的索引失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天碰巧看到了网友的《Oracle date和timestamp类型混用时需要注意的索引失效问题》这篇文章，2年前遇到了类似问题，很有同感，特此转载。
我当时的遇到问题的场景：
前提：
Oracle数据库字段trade_time类型为DATE
mybatis
调整前：
beginDate为java.util.Date类型
mybatis查询sql中where条件写法：trade_time&gt;=#{beginDate,jdbcType=TIMESTAMP}
结果trade_time字段没走索引，查询极慢
调整后：
beginDateStr为字符串类型的日期查询参数
mybatis查询sql中where条件写法：trade_time &gt;= to_date(#{beginDateStr,jdbcType=VARCHAR},'yyyy-mm-dd hh24:mi:ss')
结果：查询飞快！
以下为网友原文
【JDBC,数据库】Oracle date和timestamp类型混用时需要注意的索引失效问题
http://singleant.iteye.com/blog/1310395
2011-12-14 15:27
1.关于 Oracle date和timestamp类型
Date ：只能精确到秒。
TimeStamp：可以 精确到微秒。
关于具体类型不过多介绍。可以参考：
http://www.databasejournal.com/features/oracle/article.php/2234501/A-Comparison-of-Oracles-DATE-and-TIMESTAMP-Datatypes.htm
2.问题
生产环境在一条sql里使用到了 gmt_create &gt; :1 and gmt_create&lt;:2的条件语句。
数据库里的gmt_create字段是date类型。Ibatis里传入的类型是java.util.Date类型。gmt_create字段是有索引的，但是执行时没有走到索引，导致很慢。
3.原因分析
我们ORM使用的是ibatis。ibatis在处理传入到数据库的变量时候，如果为java.util.date类型的时候，解析为timestamp类型。可以看代码：
Java代码 1. public void setParameter(PreparedStatement ps, int i, Object parameter, String jdbcType) 2. throws SQLException { 3. ps.setTimestamp(i, new java.sql.Timestamp(((Date) parameter).getTime())); 4. } 以下原因是重点 ：
如果数据库中时间字段定义为date类型，由于timestamp类型的精度比date类型的精度高，所以oracle会对数据库里的date类型做出隐身转换，将date类型转换为timestamp类型，由于加了函数，那么创建在date类型上的索引将不会使用到；(好像是oracle9i后开始才有的问题)
网上翻查资料，有不少人遇到同样问题，这里面有两个同样的案例和解释：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ec32c297d75865ae35c185c4e16551/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/705eff03082be26799549bd4004a6709/" rel="bookmark">
			Java org.json基本用法（JSONObject/JSONArray）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.json.JSONObject JSONObject内部封装了一个HashMap&lt;String, Object&gt;，用于存储json对象的属性名和属性值。其中属性名为String类型。
//JSONObject构造1 JSONObject obj = new JSONObject(); System.out.println(obj.toString());//输出空对象: {} obj.put("key1", 1); obj.put("key2", 2); System.out.println(obj.toString());//输出: {"key2":2,"key1":1} //JSONObject构造2，参数传入json格式的字符串 JSONObject obj2 = new JSONObject(obj.toString()); System.out.println(obj2.toString()); //JSONObject属性遍历 Iterator&lt;String&gt; it = obj2.keySet().iterator(); while (it.hasNext()) { String key = it.next(); System.out.println(key+"="+(int)obj2.get(key)); } //获取JSONObject对象某个属性的值 String key = "key1"; if(obj.has(key)) { System.out.println(obj.get(key)); } TIPS: 在用get(String key)获取JSONObject对象的属性值的时候，出于健壮性的考虑应通过has(String key)判断一下，否则可能会抛JSONException异常，可能不同版本JSONObject实现会有差异。
org.json.JSONArray org.json.JSONArray内部实现则是封装了一个ArrayList&lt;Object&gt;
//JSONArray构造1 JSONArray array = new JSONArray(); array.put(obj);//这里是put,而不是add array.put(obj); System.out.println(array.toString()); //JSONArray构造2，传入json数组格式的字符串 String jsonArrStr = "[{\"1000\":2,\"100\":111},{\"1000\":2,\"100\":222}]"; array = new JSONArray(jsonArrStr); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/705eff03082be26799549bd4004a6709/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29fc283912a5efa67f7fb3bcd6af0881/" rel="bookmark">
			十月工作总结：勿忘初心，继续前行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久没有更新博客了，偶然间翻开自己的博客列表，最近一篇还是在八月初时候写的。而且最近也没有硬文章或者是干货来放送。再不更新啊，估计博客就真的荒废了。 不经意间，十月份又过去了，现在来为十月份做一份总结。纵使在公司被差别对待，貌似免去了写周报或者月报的麻烦。但公司的月(周)报是拿给领导看的，而我博客的月报是给将来的自己看的。
回望十月 伴随着前几天淅淅沥沥的小雨，北京的天气便开始冷了起来，想起高中语文课本描写北京冬天到来的语句“真的是一场秋雨一场凉啦~ ~ ~”，这个“啦”字一般拉的老长老长！饭后出去走走，莫名其妙的复杂起来，莫名其妙的想起这个月的种种，突然间想起给这个平凡的十月写起一些回忆起来。回忆起这十月份来，发现还是Get到几项技能的。首先是在国庆中秋长假中学完了WebService,用的是传智播客的视频教程，案例写起来还是有点吃劲儿，也许是不习惯看文档资料，又或许是长久不用视频教程学习方式了，总感觉老师讲完了，还是模模糊糊，动起手来没有代码感觉，就是没有那个fell。
为什么要学WebService?其实没有多少高大上的原因，就是因为下一个项目组的需要。上一个项目组是大庆移动来着的，项目计划是在9月19号验收，由于客户公司说要等另一个项目完成再一起验收，客户难得请一次专家来分开验收两个项目。所以不得不推迟了验收时间，所以上个月到大庆出差16天，项目最终也还是没有验收。
然而A7项目组这边缺少人，所以我一遍兼职着大庆移动一边调到A7这边做开发。去大庆移动项目组之前，我已经在A7呆过一周的时间，当时翻开交接文档看到这个老项目的时候我被吓傻了，因为用到的技术太老了，SSH加原生JS做的，Struts还是1.x版本的，Spring还没有用到注解功能，前端连个jQuery的$特有符号一个都找不到，真实要崩溃的感觉。浏览了一遍交接文档，发现除了WebService之外，其他技术都已经学过了的。所以在国庆期间就恶补起WebService来。
Get到另一项技术是学会了润乾报表的制作。在学润乾报表之前，我以为所谓的报表就是POI,POI就是报表。POI是制作Microsoft Office的一套Java API，在车贷贷就经常用这哥们来导入和导出Excel，他们经常称为”报表”。所以我一直以为POI就是报表后台框架，前端用eChart或者HightChart来画就可以了。接触了润乾报表之后，才知道还有这么好用的东西来画报表，而且不用写后台代码就能完成Excel,Word的导出。
润乾报表的几个概念：数据集，网格式报表，分组报表，交叉报表，参数传递，报表模板等。学报表最重要的概念估计就是数据集了，数据集简单理解就是SQL查询出来的结果集，但是这个结果集并不是直接显示在报表的单元格里面，而是这些数据是一些待显示的数据，具体怎么显示就得让润乾报表的表达式来完成。好比是MyBatis这个持久层框架只负责对数据库进行增删改查，而得到的数据结果怎么显示，显示多少条，数据显示格式或者是精度等等，都可以让前端JSP的EL表达式来完成类似。所以，又不得不学了一些润乾报表的一些函数，常用的select(),group(),sum(),now()等等。
这个月的主要主要任务是优化A7 1.0系统的报表。优化这种东西在我看来本来就是高深莫测的东西，只能意会，不能言传。老早就听到有人说某某系统过于太慢，某某牛人过来优化一下，系统就快了起来。所以喊我去优化系统的报表，我是一脸蒙圈，不过不会就去学嘛，你可以觉得自己很菜，但是不能对自己很菜这件事束手无策和坐已待毙。咨询了其他人，他们连个参考资料都没有。我是不信这个邪，我自己登录到润乾的官网，找到了润乾报表的官方文档，所以说别人没有的东西，不代表这世界上就没有，你自己去查找就怎么知道是真的没有呢？
此外还意外的发现这哥们还有Linux版本，果然Java做的东西就是跨平台。在本地安装了和配置了环境之后，发现润乾也是挺简单的，还有一大堆的PDF教程，看了两周，终于到入门教程看完了。其实看了入门教程和照教程写Demo花了差不多10个晚上的时间。关掉教程，自己看着官方给的Demo一边回忆一遍动手写，才花2个晚上。尼码，我都不知道官方的教程说的是啥！一些概念和操作从不说为什么要这样做，或者是想要达到什么效果就得怎么样做！而是一味的告诉你点击这个，然后点击那个就行了。但是条条道路通罗马，我为什么要这样做呢？所以，有时候看完官方教程，你可以回过头去看看官方的Demo,回忆回忆之前官方是推荐怎么做的，我能不能在不看教程的提前下依葫芦花飘出来。
等我把润乾的官方文档教程看了一遍之后，发现项目租的报表优化工作也不知道如何入手啊！参考了润乾的性能手册，实在是可优化的空间不大，又或许是我功力尚潜？面对项目组组长（一挺高的美女）给我的工作量：这个月底前得把这这这报表提速起来。因为在8月份的时候我的组长给某处长推荐系统的时候，打开报表正想演示，发现速度慢的出奇，我出差回来之后就赶紧把报表优化这件事提到日程。可是我现在对报表优化没有什么思路啊，完不成工作下场肯定是很惨的！
这样想着想着，某次机缘巧合我发现一个惊天的大的秘密：每张报表页面的首次进入默认的统计数据时间都是从1990-01-01开始，到目前为止这段时间。用报表设计器打开，运行输入参数的时候，直接把设计器卡死。刚开始我以为这日期具有特殊含义，去看了页面代码发现就是当时的程序员偷懒嘛！咨询组长这个日有没有特殊含义，得到没有的答案之后，便肯定了起来：明显的就是当时程序员偷懒给定了一个固定的死的日期了呗！懒得计算当前日期的上一个月或者前一年，导致每张报表用户点击进入统计的都是1990年1月1号到2017年10月这27年的数据，而用户又不需要看这么多的数据，能不托慢速度么？页面都差点被卡死了。
发现了这个秘密，我如发现宝贝似的心里暗笑：嗨，这报表速度慢的原因也忒简单了吧？前端页面传入报表的参数，计算一下，统计上个月到今天的数据，只让它计算一个月。嘿，一下子就快了起来，本来十多秒的速度，一下子几秒钟页面就显示了。
我把这个秘密告诉平时关系较好的哥们的时候，他说：就这么简单？
我得意的笑笑：就这么简单！
他：那我也可以来优化报表啊！
我: ……
Get的第三项技能是学习了工作流，虽然还是在起步学习阶段，但至少克服了之前的恐惧。之前遇到工作流则一脸蒙逼，我也尝试去读别人写的工作流部分的业务逻辑代码，发现这不是我等常人能够理解的，于是乎就是在网上搜罗搜罗教程。搜来搜去，还是发现以前汤阳光的视频较好，12天的OA教程中，有4天是讲JBPM工作流的。以前断断续续学他12天OA教程，都没有学完，这下下定决心必须学完。
继续前行 十九大刚刚闭幕，记得这次的主题就是“勿忘初心，继续前行”。我觉得这句话对我也还是挺适合的。做人容易满足，尤其是在一个封闭的圈子，当上级要求你用某项新技术去完成指定的工作的时候，你心里或许很慌，然后不得不逼迫自己去学。学了一段时间，能够干活了，就觉得自己学的够了，觉得可以了，发现同样工作经验别人完成不成的任务我完成了，我就可以蹦哒了。这种自满和自负容易自我麻痹。所以，还不是到自己放松的时间，得勿忘初心，继续前行。记得某次和我妹打电话的时候，我妹问了我一个问题：哥，大学毕业之后你还在看书么？
我：大学时候我放弃了很多门课程，丢掉好多书，毕业之后我得必须得重拾起来。计算机技术日新月薪，而要想站在时代和技术的前沿就得逼迫自己不断的去学习。当哪天我觉得累了，想休息了，想安逸了，又或者学不动了，那天也应该到了远离IT的时刻了！
先给十一月预订几个小目标吧。第一，把汤阳光12天OA部分坚持看完，之后分享代码到GitHub,并整理成OA专栏，其实这部分专栏今年五月份就申请了的，只是没有写完这专栏的博客就中断了。做事得有始有终，十一月发一些技术干货来充实自己的专栏。第二，把EasyUI部分继续深入学习，大庆移动项目PC端用到了各种前端技术：AngularJS,IONic,EasyUI,我在菜鸟教程上把这些技术过一遍，就以为Get到手了。前几天我们部门的一应届生哥们问我一个EasyUi问题，我辞穷！大庆移动上周五又出问题了，看着AngularJs的代码，似乎很熟悉，但却不知道如何下手！这时候我才明白，原来好多东西我只是了解了皮毛！
十一月，勿忘初心，继续前行！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bd04a0ceaed8781f157a36a82af2541/" rel="bookmark">
			Android Binder机制 - interface_cast和asBinder源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		研究Android底层代码时，尤其是Binder跨进程通信时，经常会发现interface_cast和asBinder，很容易被这两个函数绕晕，下面通过分析源码来讲解一下：
interface_cast 下面根据下述ICameraClient例子进行分析一下：
//伪代码 sp&lt;ICameraClient&gt; cameraClient = interface_cast&lt;ICameraClient&gt;(BpBinder(handle)); 看下interface_cast的实现，其代码在IInterface.h中
template&lt;typename INTERFACE&gt; inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj) { return INTERFACE::asInterface(obj); } //这是一个模板函数，展开即为： inline sp&lt;ICameraClient &gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj) { return ICameraClient ::asInterface(obj); } 那ICameraClient的asInterface在哪实现的呢？发现找了ICameraClient.h和ICameraClient.cpp只有下面两个定义：
//frameworks/av/include/camera/android/hardware/ICameraClient.h DECLARE_META_INTERFACE(CameraClient); //frameworks/av/camera/ICameraClient.cpp IMPLEMENT_META_INTERFACE(CameraClient, "android.hardware.ICameraClient"); DECLARE_META_INTERFACE和IMPLEMENT_META_INTERFACE函数是其父类IInterface（frameworks\native\include\binder\IInterace.h）的宏定义：
//声明asInterface函数 #define DECLARE_META_INTERFACE(INTERFACE) static const android::String16 descriptor; //声明asInterface函数 static android::sp&lt;I##INTERFACE&gt; asInterface( const android::sp&lt;android::IBinder&gt;&amp; obj); virtual const android::String16&amp; getInterfaceDescriptor() const; I##INTERFACE(); virtual ~I##INTERFACE(); 展开为： #define DECLARE_META_INTERFACE(CameraClient) //增加一个描述符 static const android::String16 descriptor; //声明asInterface函数 static android::sp&lt;ICameraClient&gt; asInterface( const android::sp&lt;android::IBinder&gt;&amp; obj); //获取描述符函数 virtual const android::String16&amp; getInterfaceDescriptor() const; //构造函数以及折构函数 ICameraClient(); virtual ~ICameraClient(); //实现asInterface函数 #define IMPLEMENT_META_INTERFACE(INTERFACE, NAME) const android::String16 I##INTERFACE::descriptor(NAME); const android::String16&amp; I##INTERFACE::getInterfaceDescriptor() const { return I##INTERFACE::descriptor; } android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface( const android::sp&lt;android::IBinder&gt;&amp; obj) { android::sp&lt;I##INTERFACE&gt; intr; if (obj !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bd04a0ceaed8781f157a36a82af2541/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e77f323a3cf32ca5bf06514fdd14472/" rel="bookmark">
			异步处理rest服务-多线程提升rest性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 异步处理的优点 异步编程最大的特点是吞吐量大，延迟小，因为没有堵塞，这就容易挖掘现有硬件和操作系统等底层系统的潜力，同样的成本投入，异步系统要比传统铁板一块的同步系统更能应付爆发式涌潮的瞬间大流量 传统处理流程： 异步处理流程： 在tomcat 线程池中线程的数量的有限的，是线程达到上限请求就没法处理了。使用异步处理的话，主线程就可以空闲下来处理其他请求这样，服务器的吞吐量就会明显的提升。
2.同步处理 编写一个简单的controller 测试一下
@GetMapping public String asyncSuccess() { logger.info("主线程开始"); try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } logger.info("主线程结束"); return "success"; } 运行程序打出日志发现主线程消耗一秒钟多返回 3.runnable异步处理 使用callable方式编写测试controller代码
@GetMapping("/runnable") public Callable&lt;String&gt; asyncSuccessRunnable() { logger.info("主线程开始"); Callable&lt;String&gt; result=new Callable&lt;String&gt;(){ public String call() throws Exception { logger.info("副线程开始"); Thread.sleep(1000); logger.info("副线程结束"); // TODO Auto-generated method stub return null; } } ; return result; } 运行程序打出日志发现主线程立即结束了，业务逻辑交给副线程去做了。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e77f323a3cf32ca5bf06514fdd14472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53111d91e9e8c8e5eb87b780d7897331/" rel="bookmark">
			微信小程序用console.log打印json数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON.stringify(fun.nav_more(cp_nav_state)) JSON.parse()和JSON.stringify() JSON.parse() 方法用于将一个 JSON 字符串转换为对象。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;从 JSON 字符串中创建一个对象&lt;/h2&gt; &lt;p id="demo"&gt;&lt;/p&gt; &lt;script&gt; var text = '{"employees":[' + '{"name":"菜鸟教程","site":"http://www.runoob.com" },' + '{"name":"Google","site":"http://www.Google.com" },' + '{"name":"Taobao","site":"http://www.taobao.com" }]}'; obj = JSON.parse(text); document.getElementById("demo").innerHTML = obj.employees[1].name + " " + obj.employees[1].site; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意：单引号写在{}外，每个属性名都必须用双引号，否则会抛出异常。 结果
从 JSON 字符串中创建一个对象 Google http://www.Google.com详细：http://www.runoob.com/js/javascript-json-parse.html JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串。 &lt;script&gt; var str = {"name":"菜鸟教程", "site":"http://www.runoob.com"} str_pretty1 = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53111d91e9e8c8e5eb87b780d7897331/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ef0071eb8473485086abd555fba63b/" rel="bookmark">
			《算法4》深入理解红黑树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		红黑树是一种性能非常优秀的数据结构，关键在于它能保证最坏的性能也是对数的，主要是因为它是一种平衡的树，所以也叫平衡查找树。要理解红黑树，最好先看看我的上一篇博客《算法4》符号表以及二叉查找树，了解二叉查找树以及我们为什么需要平衡查找树。
2-3查找树 二叉查找树中树高会受到输入数据的影响，极端情况下一棵树和一个链表没什么区别，所以我们需要一种树，它的所有叶节点到根节点的距离都是相等的，这种树为平衡树，并且随着数据的加入，这种平衡性会一直保持。下面介绍一种理论上的平衡树——2-3查找树。
2-3树示意图
2-3树的主要特点就是树由普通的2节点和一种三节点组成。2节点和二叉查找树中的特性相同。对于3节点，它的键有两个，并且有三个链接，左链接指向的左子树中的所有元素都小于3节点中的两个键，中间链接指向的子树大小在两个键之间，右链接指向的子树中的元素都大于两个键。
查找 对于查找操作和二叉查找树基本相同，递归比较要查找的键和树的根节点，小于就向左继续查找，大于就向右查找，相等就查找命中。不同的就是对于3节点，还要有中间节点的情况，在三节点两个键的大小之间的情况，要向中间子树递归。最后如果查找到叶节点的空连接就直接返回null。
插入 2-3树的插入相对来说是比较复杂的，因为它是保证树本身平衡性的关键。我们分几种情况来论述。
向2节点插入 插入先是要查找，查找到了就直接更新，如果未命中就插入新元素，插入新元素一定是在叶节点的空连接上，如果叶节点是一个2节点，那么就直接插入，让特们合成一个3节点。显然这时树高没有变化。示意图如下 这就是向一个2节点插入的情况。
向3节点插入 假如向一个3节点中插入，我们首先可以做的是像2节点一样把他们暂时合在一起形成一个4节点（有三个元素），然后再对这个4节点进行分解，将中间的元素插入他们的父元素剩下两个元素变成两个2节点。注意：只能是中间的元素拿上去，因为这样才能保证树的有序性，即左边和右边的元素相对于根元素的大小关系，然后再考察父节点，如父节点原来是一个2节点，那么此时直接插入将其变成一个3节点，插入操作就完成了。如果原来父节点就是一个3节点，那么依然可以再重复这个过程，不断将中间元素加入父节点，如果这个过程持续到了根节点，那么我们就分裂形成的一个暂时的4节点的根节点，得到三个2节点，同时整个的树高增加1。 上图为根节点分裂的示意图
这种插入相当于把元素插入这个会引起树的高度变化的不利因素放在3节点中储存起来，随着3节点的插入将这种不利因素不断传导至根节点，然后通过根节点的分裂将整个的树高加1，可以看出，3节点以及相关的插入方法是保证平衡性的关键，也可以看出2-3树的生长是从下往上通过根节点生长的。2-3树就可以实现在最坏条件下也有对数性能。
下面我们就可以看到一种2-3树的具体实现——红黑二叉查找树，以下简称红黑树。
红黑树 前文已经提到3节点是实现平衡性的关键，这里我们用红链接即一条红色的左链接来表示3节点 而2节点就用普通的黑色连接来表示。 那么一棵红黑树应该是完美黑色平衡的，即从任意空连接出发到根节点所经历的黑连接数目应该是相同的。再加入一个条件：没有任意一个节点同时和两个红链接相连，那么此时红黑树就可以和2-3树一一对应。
节点代码 private static final boolean RED = true;//定义RED为true private static final boolean BLACK = false; private Node root; private class Node{ Key key; Value value; int N; Node left, right; boolean color;//表示颜色 Node(Key key, Value value,int N,boolean color){ this.key = key; this.value = value; this.N = N; this.color = color; } } private boolean isRed(Node x){ if (x==null) return false; return x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7ef0071eb8473485086abd555fba63b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acbb19fca177526ecd0d7184dce11836/" rel="bookmark">
			DELL 远程访问管理卡iDRAC  默认帐号密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iDRAC又称为Integrated Dell Remote Access Controller，也就是集成戴尔远程控制卡
远程控制卡有2个版本，
随机版: 只能查看服务器状态信息，不能控制
企业版: 可查看服务器状态，也可实现远程控制管理
初始帐号
用户名是root,密码是calvin
附件为早期DELL 服务器的idrac 卡，bios 设置步骤。另说现在都用LCD 屏设置。老的版本也记录下！
日常服务器最好都配备此卡，方便远程管理
转载于:https://blog.51cto.com/68240021/1976989
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/909bf6d711615e9b91ce9d9b514da00d/" rel="bookmark">
			荐号｜10个优质的大数据、人工智能公众号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 陈皓：很多程序员喜欢调侃说自己是“码农”：编码的农民工，在工作上被各种使唤，各种加班，累得像个牲口。在职业发展上各种迷茫和彷徨，完全看不到未来的希望，更别说可以成为一个手艺人用自己的技能变现了。 但是在这个信息高度流通，获取信息门栏越来越低的社会，主动的“学会学习”往往比被动接受任务更有利于自己的职业生涯发展。
本次筛选的一批公众号，主要与大数据、人工智能、机器学习相关，更有一线大厂的技术团队经营的号，希望对你有所帮助！ AI前线 ID: ai-front
▲长按图片识别二维码关注
面向AI爱好者、开发者和科学家，提供最新最全AI领域技术资讯、一线业界实践案例、搜罗整理业界技术分享干货、最新AI论文解读。每周一节技术分享公开课，助力你全面拥抱人工智能技术。《深入浅出TensorFlow》迷你书现已发布，关注公众号并回复关键字：“TF”，可获取下载链接。
大数据文摘
ID：bigdatadigest
▲长按图片识别二维码关注
成立于2013年7月，专注数据领域最新资讯、精品案例、一线技术，已成为数据行业最有影响力的新媒体，致力于打造精准数据分析社区。团队成员是一群对数据充满激情、有能力、乐于分享的专业人员、欢迎你来看看不一样的大数据。
待字闺中
ID：daiziguizhongren
▲长按图片识别二维码关注
一个由陈利人和他的朋友共同创建的公众号【待字闺中】，深度分析大数据、深度学习、人工智能等技术，切中实际应用场景，为大家授业解惑，间或，还会介绍国内外相关领域有趣的面试题。得到了小道消息冯大辉推荐。
DBAplus社群
ID：dbaplus
▲长按图片识别二维码关注
DBAplus社群：数据连接未来！围绕数据库、大数据、PaaS云，顶级大咖、技术干货，每天精品原创文章推送、每周线上技术分享、每月线下技术沙龙，场场爆满、受众过十万，成为运维圈最专注围绕“数据”的学习交流和专业社群！
R语言中文社区
ID: R_shequ
▲长按图片识别二维码关注
国内最大的R语言专业学习平台| R官方学习实践社区，提供R核心网站学习、视频直播 、R核心学习资源库、R全球会议资讯、R实战案例等服务。关注我，掌握R语言全球最新资讯与成果！
携程技术中心
ID：ctriptech
▲长按图片识别二维码关注
携程技术中心官方账号，分享来自携程技术人的一手干货文章，发起线上线下技术活动，发布热招岗位信息，和技术圈小伙伴一起学习成长~
THU数据派
ID：datapi
▲长按图片识别二维码关注
依托清华大学独特的师资和生源优势,旨在提供大数据产业链的思维碰撞与资源对接平台。发布全球大数据资讯，定期组织优质线下活动，分享前沿产业动态。
硅发布
ID：guifabucom
▲长按图片识别二维码关注
科技中心硅谷又出现了什么好玩东西和创新模式？我们来给你答案。
HULK一线技术杂谈 ID：hulktalk ▲长按图片识别二维码关注
『HULK一线技术杂谈』是由360云平台团队打造的技术分享公众号，内容涉及云计算、数据库、大数据、监控、泛前端、自动化测试等众多技术领域，通过夯实的技术积累和丰富的一线实战经验，为你带来最有料的技术分享~
美团点评技术团队
ID：meituantech
▲长按图片识别二维码关注
美团点评技术团队是美团·大众点评多个研发组织的统称，负责支撑和驱动美团、大众点评多个业务的发展。该公众账号将面向互联网开发/产品从业者，提供我们研发及部分产品岗位的招聘信息，发布优质原创技术内容或发起相关活动，欢迎关注。
扫描下方二维码了解更多内容 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c86f7d864ddac10e604d7ac336affde/" rel="bookmark">
			啪啪动物城 源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏地址：http://www.4399.com/flash/192131.htm
啪啪动物城源码：https://files.cnblogs.com/files/gamedaybyday/%E5%95%AA%E5%95%AA%E5%8A%A8%E7%89%A9%E5%9F%8E.rar
转载于:https://www.cnblogs.com/gamedaybyday/p/7739762.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d7904ec2f7587b14e95beaefec74b28/" rel="bookmark">
			IOS下Libevent编译步骤，及引入Xcode备忘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.先用：ls -al /usr/lib | grep libevent 查看是否已安装，如果已安装且版本低于1.3，则先通过：rpm -e libevent —nodeps 进行卸载。 1.下载libevent安装包：libevent-2.0.22-stable.tar.gz，然后解压。 2.切换到解压后的 libevent 主目录：cd libevent-2.0.22-stable 3.依次执行： ./configure –prefix=/usr （或 ./configure --program-prefix=/usr） make make install ----ARM64 ./configure --prefix=/Users/XX/lv --host=arm-apple-darwin --enable-static=yes --enable-shared=no CC=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cc CFLAGS="-arch arm64 -pipe -std=c99 -Wno-extended-offsetof -Wno-trigraphs -fpascal-strings -O2 -Wreturn-type -Wunused-variable -fmessage-length=0 -fvisibility=hidden -miphoneos-version-min=6.0 -I/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS10.0.sdk/usr/include -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS10.0.sdk" AR=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ar LDFLAGS="-arch arm64 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS10.0.sdk -miphoneos-version-min=6.0" ---lipo lipo -create /Users/XX/lv/lib/libevent_pthreads.a /Users/XX/build/built/iPhoneOS10.0-arm64.sdk/lib/libevent_pthreads.a -output /Users/xx/lv-all/libevent_pthreads.a
*注意替换路径
生成IOS平台的库文件(libevent_core.a,libevent_extra.a,libevent_pthreads.a)放到$path/ios/libraries中,注意:是IOS的库文件,不是linux的
头文件放到$path/ios/libevent
xcode中增加head search path 和 添加刚才的3个库文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6a76d9d9ca1291f10b0a7477e563db9/" rel="bookmark">
			Eventbus3.0入（踩）门（坑）之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先祭出eventbus gayhub地址！
第一步： 导包：compile ‘org.greenrobot:eventbus:3.0.0’ 第二步： 需要一个class,它的作用就是接受传过来的信息，你可以理解成调用接口返回封装了数据的类
public class FirstEvent { private String mMsg; public FirstEvent(String msg) { mMsg = msg; } public String getMsg(){ return mMsg; } } 第三步： 在你需要接受消息的地方来一个这个（其实就是订阅），这个地方sticky = true暂可忽略，后面说。
@Subscribe(sticky = true,threadMode = ThreadMode.MAIN) public void postingME(FirstEvent event){ Log.i("robin1", "postingME222: "+event.getMsg()); } 然后注册eventbus，比如在activity里面（这个地方可以抽取到baseactivity里面去，但是有坑，之后再说）
@Override public void onStart() { super.onStart(); EventBus.getDefault().register(this); } @Override public void onStop() { super.onStop(); EventBus.getDefault().unregister(this); } 第四步： 发送！注意，发送的数据类型要和Subscribe的方法的参数保持一致。
EventBus.getDefault().post(new FirstEvent("这是发送的文本111")); 上面就是官方介绍，说说使用场景吧，用过MVP模式的同学都知道，presenter拿到model的数据（其实就是接口返回的数据）之后，可以post出去，然后再view（activity）中接收，做一些UI的改变。 对，这是一般的情况，我突发奇想，两个activity之间传值可不可以？既然叫，事件总线，那么肯定是可以的，于是乎！ 在activity1中post数据，在activity2中注册eventbus,解注册eventbus，然后，订阅方法。一气呵成，跑起来：wtf?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6a76d9d9ca1291f10b0a7477e563db9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12e037ac7d03f227a358c63c4aa699b6/" rel="bookmark">
			TMS320C6748_UART_EDMA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过EDMA来实现UART的收发，可以减轻CPU的负担。主函数如下： int main(void) { // 外设使能配置 PSCInit(); // DSP 中断初始化 InterruptInit(); // EDMA3 中断初始化 EDMA3InterruptInit(); // EDMA3 初始化 EDMA3UARTInit(); // 初始化串口终端使用串口2 UARTStdioInit(); // 申请串口 EDMA3 发送通道 EDMA3RequestChannel(SOC_EDMA30CC_0_REGS, EDMA3_CHANNEL_TYPE_DMA, EDMA3_CHA_UART2_TX, EDMA3_CHA_UART2_TX, EVT_QUEUE_NUM); // 注册回调函数 cb_Fxn[EDMA3_CHA_UART2_TX] = &amp;callback; // 申请串口 EDMA3 接收通道 EDMA3RequestChannel(SOC_EDMA30CC_0_REGS, EDMA3_CHANNEL_TYPE_DMA, EDMA3_CHA_UART2_RX, EDMA3_CHA_UART2_RX, EVT_QUEUE_NUM); // 注册回调函数 cb_Fxn[EDMA3_CHA_UART2_RX] = &amp;callback; volatile char enter[] = "Tronlong UART2 EDMA3 Application......\n\rPlease Enter 20 bytes from keyboard\r\n"; volatile char buffer[RX_BUFFER_SIZE]; unsigned int buffLength = 0; // 发送数据 buffLength = strlen((constchar *)enter); UartTransmitData(EDMA3_CHA_UART2_TX, EDMA3_CHA_UART2_TX, enter, buffLength); // 使能串口 DMA 模式 UARTDMAEnable(SOC_UART_2_REGS, UART_RX_TRIG_LEVEL_1 | \ UART_DMAMODE | \ UART_FIFO_MODE ); // 等待从回调函数返回 while(flag == 0); flag = 0; // 接收数据 UartReceiveData(EDMA3_CHA_UART2_RX, EDMA3_CHA_UART2_RX, buffer); // 使能串口 DMA 模式 UARTDMAEnable(SOC_UART_2_REGS, UART_RX_TRIG_LEVEL_1 | \ UART_DMAMODE | \ UART_FIFO_MODE ); // 等待从回调函数返回 while(flag == 0); flag = 0; // 发送数据 UartTransmitData(EDMA3_CHA_UART2_TX, EDMA3_CHA_UART2_TX, buffer, RX_BUFFER_SIZE); // 使能串口 DMA 模式 UARTDMAEnable(SOC_UART_2_REGS, UART_RX_TRIG_LEVEL_1 | \ UART_DMAMODE | \ UART_FIFO_MODE ); // 等待从回调函数返回 while(flag == 0); flag = 0; // 释放 EDMA3 通道 EDMA3FreeChannel(SOC_EDMA30CC_0_REGS, EDMA3_CHANNEL_TYPE_DMA, EDMA3_CHA_UART2_TX, EDMA3_TRIG_MODE_EVENT, EDMA3_CHA_UART2_TX, EVT_QUEUE_NUM); EDMA3FreeChannel(SOC_EDMA30CC_0_REGS, EDMA3_CHANNEL_TYPE_DMA, EDMA3_CHA_UART2_RX, EDMA3_TRIG_MODE_EVENT, EDMA3_CHA_UART2_RX, EVT_QUEUE_NUM); // 主循环 for(;;) { } } 主函数中，先是对EDMA3中断初始化，EDMA3InterruptInit();，函数如下： void EDMA3InterruptInit(void) { IntRegister(C674X_MASK_INT4, Edma3ComplHandlerIsr); IntRegister(C674X_MASK_INT5, Edma3CCErrHandlerIsr); IntEventMap(C674X_MASK_INT4, SYS_INT_EDMA3_0_CC0_INT1); IntEventMap(C674X_MASK_INT5, SYS_INT_EDMA3_0_CC0_ERRINT); IntEnable(C674X_MASK_INT4); IntEnable(C674X_MASK_INT5); } 函数中，注册了4号和5号CPU可屏蔽中断C674X_MASK_INT4和C674X_MASK_INT5的服务函数，分别为Edma3ComplHandlerIsr和Edma3CCErrHandlerIsr，然后将8号中断事件SYS_INT_EDMA3_0_CC0_INT1（EVT8）映射到C674X_MASK_INT4，将56号中断事件SYS_INT_EDMA3_0_CC0_ERRINT（EVT56）映射到C674X_MASK_INT5，并使能这两个CPU可屏蔽中断。SYS_INT_EDMA3_0_CC0_INT1为EDMA3_0模块的通道控制器0影子区域1传输完成的中断标志，6748有两个EDMA3模块，分别为EDMA3_0和EDMA3_1，每个EDMA_n模块都只有一个通道控制器CC0（channel controller 0）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12e037ac7d03f227a358c63c4aa699b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0285bc9ce7ee39a74802d646fdb030e1/" rel="bookmark">
			GDAL联合OpenCV进行图像处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一名图像处理方面的工程师，在面对大数据量的遥感影像时，往往会利用到强大的GDAL库，但是GDAL库却没有方面的算法函数进一步进行处理；同时我们看到Opencv库能提供强大的算法支持，却对大数据影像没有办法，因此两者的结合就显得十分有必要。
以本篇博客为开头，首先利用GDAL进行影像的读取，实现转换成OpenCV库中的Mat格式。
cv::Mat GDAL2Mat(string strName) { GDALAllRegister(); // 注册。。。 GDALDataset *poDataset = (GDALDataset *)GDALOpen(strName.c_str(),GA_ReadOnly); //GDAL读取栅格影像 int nCols = poDataset-&gt;GetRasterXSize(); int nRows = poDataset-&gt;GetRasterYSize(); int nBandSize = poDataset-&gt;GetRasterCount(); double *padfGeoTransform = new double[6]; poDataset-&gt;GetGeoTransform(padfGeoTransform); QVector &lt;cv::Mat&gt; imgMat; // 每个波段 float *pafScan = new float[nCols*nRows]; // 存储数据 for(int i = 0;i&lt; nBandSize;i++) //按波段转换存储 { GDALRasterBand *pBand = poDataset-&gt;GetRasterBand(i+1); //pafScan = new float[tmpCols*tmpRows]; pBand-&gt;RasterIO(GF_Read,0,0,tmpCols,tmpRows,pafScan, tmpCols,tmpRows,GDT_Float32,0,0); cv::Mat img = cv::Mat(nRows,nCols,CV_32FC1,pafScan); imgMat.push_back(img.clone()); } delete []pafScan; pafScan = NULL; cv::Mat imgDst; imgDst.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0285bc9ce7ee39a74802d646fdb030e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a441e558ffc961fcd86b76d351beda2/" rel="bookmark">
			DDR3 寻址及原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		寻址数据范围为：行： 2的15次方，列：2的10次方，bank：2的3次方，CS片选：2的2次方, 数据线32位
2^15 x 2^10 x 2^3 x 2^2 x 32 = 32Gb
最大容量为32Gb
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96b927536245bd6af456cf1a0f74897c/" rel="bookmark">
			Caused by: java.sql.SQLException: connection holder is null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用阿里巴巴的druid连接池报错：Caused by: java.sql.SQLException: connection holder is null
错误原因：因业务程序本身运行比较慢长或程序异常后没有关闭连接，导致的数据库连接超过了removeAbandonedTimeout规定的时间没有主动关闭，连接池启用自我保护机制把连接关了，当程序再使用这个连接就报错了。
解决方案：
把连接池配置中的removeAbandonedTimeout参数调整为30分钟，如下：
&lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name="removeAbandonedTimeout" value="1800" /&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f577c1f0b08367850aff9965708d683b/" rel="bookmark">
			HEX文件合并的方法简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、用TXT文本的方式分别打开要合并要的HEX文件（例如：A.hex和B.hex）
2、鉴别HEX文件内容中的起始地址(例如：A.hex起始地址小于B.hex)
3、选择裁剪起始地址比较大的HEX文件，裁剪第一行（文件头）和最后一行（文件尾）；（裁剪：B.hex文件）
4、全选裁剪后的hex文件，粘贴到A文件中的倒数第一行前面（将裁剪后的B.hex插入A.hex文件中）
主要应用于嵌入式软件中的程序文件合并，完成一次烧录程序的过程准备工作！此文在于描述怎么解决问题，如有不理解的地方，请了解HEX文件的格式简述！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/683e2de65bebf081adcb4b237aa53b79/" rel="bookmark">
			C语言头文件函数声明是否加extern
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看创龙的DSP程序，忽然遇到一个C语言的语法问题，感觉非常纠结，归根结底还是以前C语言学的不扎实，所以才会卡在这种小的语法问题上。我的问题是这样的，在看UART_EDMA例程的时候，main函数调用了UARTStdioInit();函数，UARTStdioInit();在uartStdio.c文件里，然后UARTStdioInit();函数里又调用了UARTConsoleInit();函数，该函数在UARTConsole.c文件里。
然后，在UARTConsoleInit();函数里，又调用了
PSCModuleControl(SOC_PSC_1_REGS,13, 0, PSC_MDCTL_NEXT_ENABLE);函数，问题来了。我在查看声明PSCModuleControl函数的头文件psc.h的时候，看到了PSCModuleControl函数声明没有加extern关键字，而另外又有两个函数声明，却是加了extern关键字的。如下图所示：
回头再看main函数，发现有些函数也没加extern关键字。比如
（main函数）
（edma.h文件）
而有些却加了，比如：
（main函数）
（uartStdio.h文件）
那么，到底什么时候加extern关键字，什么时候不加？我想了很久，最后暂时得出这样的解释，加不加无所谓！
主函数中，这两个函数，
一个是加了extern，一个没加，我试了去掉加了extern的函数声明的extern关键字，结果发现编译没有任何问题，运行也可以，所以，总结就是，没必要加。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de23128250dab175a4aed86775a48873/" rel="bookmark">
			微服务“新秀”之Service Mesh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		女主宣言
本文出自于ADDOPS团队，该文章的译者霍明明参与了360 HULK云平台容器化及虚拟化平台相关服务建设，对微服务有着独到的见解。今天的主角Istio是Google/IBM/Lyft联合开发的开源项目，估计很多同学在此之前可能完全没有听过这个名字，请不必介意，因为Istio出世也才五个月而已。让我们跟着作者一起揭开Service Mesh的神秘面纱。
PS：丰富的一线技术、多元化的表现形式，尽在“HULK一线技术杂谈”，点关注哦！
前言
有人将 Service Mesh 看成是一次 "Network Application Revolution"，我还是非常认同的，所以也就有了进一步了解和学习Service Mesh的动力。
在看本文章前，强烈建议先看一下这两篇文章《深度剖析Service Mesh服务网格新生代Istio》，《从分布式到微服务，深挖Service Mesh》，了解一下Service Mesh的历史。
1
Envoy 简介
在 Service Mesh 模式中，每个服务都配备了一个代理“sidecar”，用于服务之间的通信。这些代理通常与应用程序代码一起部署，并且它不会被应用程序所感知。Service Mesh 将这些代理组织起来形成了一个轻量级网络代理矩阵，也就是服务网格。这些代理不再是孤立的组件，它们本身是一个有价值的网络。其部署模式如图所示：
绿色部分代表应用程序
蓝色部分则是sidecar
服务网格是用于处理服务到服务通信的“专用基础设施层”。它通过这些代理来管理复杂的服务拓扑，可靠地传递服务之间的请求。 从某种程度上说，这些代理接管了应用程序的网络通信层。
Envoy是 Service Mesh 中一个非常优秀的 sidecar 的开源实现。我们就来看看 Envoy 都是做些什么工作。
2
Envoy 用到的几个术语
Host: 通常我们将 Host 看做是一个具备网络通信功能的实体(可以是一台物理机，也可以是一台移动设备等等) 。在 Envoy 中，host 是一个逻辑网络中的应用. 可能运行在由有多个主机组成的底层硬件，只要它们各自独立寻址。
Downstream: 请求发起者(服务请求方)。
Upstream: 请求接收者(服务提供方)。
Listener: 服务(程序)监听者。就是真正干活的。 envoy 会暴露一个或者多个listener监听downstream的请求。
Cluster: upstream 集群。Envoy 通过服务发现定位集群成员并获取服务。具体请求到哪个集群成员是由负载均衡策略决定。通过健康检查服务来对集群成员服务状态进行检查。
Mesh: 在本文中 "Envoy mesh" 指的是由一组 Envoy 代理组成的，为不同服务之间可靠传递请求的服务网格。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de23128250dab175a4aed86775a48873/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e9c1c18a0be91b38ac7cf27c23dabd/" rel="bookmark">
			postMessage 跨文档消息传递
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		postMessage作用在于解决，来自不同域的页面之间的消息传递，而且稳妥又方便。
假设此时有一个文档A，要向文档B传递消息C，就可在文档A中直接写：
B.postMessage(C, B.domain); postMessage()方法接收两个参数，第一个为要传递的消息，第二个为消息接收方所处的域。第二个参数的作用在于保障通信安全。即防止把消息发送到不安全的地方。若要把消息发送到来自任何域的文档，可把第二个参数写为 ‘*’ 。
当文档接收到消息，就会触发window对象的message事件，此事件以异步形式触发。比如上面写到的，当文档B收到文档A发来的消息C，即触发message事件，可在文档B中设置事件处理函数来判断。如：
window.addEventListener('message', function(event){ //if(event.origin != ''){return;} event.source.postMessage('received, data is '+event.data,'*'); }) 该事件对象event包含三方面的重要信息：
data：作为postMessage()的第一个参数传入的字符串数据；origin：发送消息的文档所在的域，可用来检测消息来源。source：发送消息的文档的window对象的代理。注意，因为只是代理，只用它来调用postMessage()就好。 试着写个demo，按下按钮，就可以获取iframe中的背景色并用他修改box的背景色。 A.html
&lt;div id='box' style="width: 100px;height: 100px;background: blue;"&gt;&lt;/div&gt; &lt;button id="color"&gt;changeColor&lt;/button&gt; &lt;div&gt; &lt;iframe src="b.html"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var btn = document.getElementById('color'); btn.onclick = function(){ window.frames[0].postMessage('give me the color','*'); } window.addEventListener('message', function(event){ var box = document.getElementById('box'); box.style.backgroundColor = event.data; }) &lt;/script&gt; B.html
&lt;p id="box" style="width: 100px;height: 100px;background: red;"&gt;heiheihei&lt;/p&gt; &lt;script type="text/javascript"&gt; var box=document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9e9c1c18a0be91b38ac7cf27c23dabd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de65a37629904e35b8787da678d51477/" rel="bookmark">
			Codeforces883E-Field of Wonders
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		E. Field of Wonders time limit per test 3 seconds memory limit per test 256 megabytes input standard input output standard output Polycarpus takes part in the "Field of Wonders" TV show. The participants of the show have to guess a hidden word as fast as possible. Initially all the letters of the word are hidden.
The game consists of several turns. At each turn the participant tells a letter and the TV show host responds if there is such letter in the word or not.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de65a37629904e35b8787da678d51477/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c905d229947746e247d7018ccde4a1c/" rel="bookmark">
			SQLserver2008错误5120的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天我在添加数据库的时候一直添加不上，总是弹出5120的错误，真的很头疼，相信大家也和我遇到同样的问题，所以在这里给出解决方法！
有问题咱们就开始解决问题，
首先，给出3张图片
这是错误信息。
解决方法：1：以管理员的身份运行SQLserver2008，连接之后进行添加，成功，这是对数据库的进行操作的，如果这种方法没有成功还有第二种方法。
2；把你需要附加的数据库，右击你要添加的数据库，点击安全选项
如上图所示；对数据库文件和日志文件都要进行如上操作即可；（点击“右键”-&gt;“属性”-&gt;"安全"-在组或用户名处添加Authenticated Users-
更改该组权限为完全权限，再次附加成功。）添加完成。
注意
这两个文件都要进行上面操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd9c57e33e8e653dea02c037e4e32827/" rel="bookmark">
			hive 创建表时遇到问题   Failed to recognize predicate &#39;xxx&#39;. Failed rule: &#39;identifier&#39; in column specificat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题描述 在Hive1.2.2版本运行如下HQL时：
select dt as date, comMap['searchType'] as search_type, comMap['clickType'] as click_type from search_click where dt = '20170614'; 会抛出如下异常：
Failed to recognize predicate 'date'. Failed rule: 'identifier' in column specification 2. 问题分析 在Hive1.2.0版本开始增加了如下配置选项，默认值为true：
hive.support.sql11.reserved.keywords 该选项的目的是：是否启用对SQL2011保留关键字的支持。 启用后，将支持部分SQL2011保留关键字。
3.　解决方案 从上面可以知道是因为启用了对保留关键字的支持导致的，上面语句中date是保留关键字．所以解决方案如下：
弃用保留关键字date select dt, comMap['searchType'] as search_type, comMap['clickType'] as click_type from search_click where dt = '20170614'; 弃用对保留关键字的支持 sudo -uwirelessdev hive -e " set hive.support.sql11.reserved.keywords = false ; select dt, comMap['searchType'] as search_type, comMap['clickType'] as click_type from search_click where dt = '20170614'; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd9c57e33e8e653dea02c037e4e32827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70845078489befd634d6a3258acfa003/" rel="bookmark">
			item()和iteritem(),python3.X中items()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字典items()方法和iteritems()方法，是python字典的内建函数，分别会返回Python列表和迭代器，下面一起来看下字典items()和iteritems()的具体操作方法。 作用 python字典的items方法作用：是可以将字典中的所有项，以列表方式返回。如果对字典项的概念不理解，可以查看Python映射类型字典基础知识一文。因为字典是无序的，所以用items方法返回字典的所有项，也是没有顺序的。 python字典的iteritems方法作用：与items方法相比作用大致相同，只是它的返回值不是列表，而是一个迭代器。 调用格式 字典items()与iteritems()都是函数，调用标准格式和其它函数格式是一样的：变量.方法() 操作方法 字典items()操作方法：
&gt;&gt;&gt; x = {'title':'python web site','url':'www.iplaypy.com'} &gt;&gt;&gt; x.items() [('url', 'www.iplaypy.com'), ('title', 'python web site')] 从结果中可以看到，items()方法是将字典中的每个项分别做为元组，添加到一个列表中，形成了一个新的列表容器。如果有需要也可以将返回的结果赋值给新变量，这个新的变量就会是一个列表数据类型。
&gt;&gt;&gt;a=x.items() &gt;&gt;&gt; a [('url', 'www.iplaypy.com'), ('title', 'python web site')] &gt;&gt;&gt;type(a) &lt;type 'list'&gt; dict iteritems()操作方法：
&gt;&gt;&gt; f = x.iteritems() &gt;&gt;&gt; f &lt;dictionary-itemiterator object at 0xb74d5e3c&gt; &gt;&gt;&gt; type(f) &lt;type 'dictionary-itemiterator'&gt; #字典项的迭代器 &gt;&gt;&gt; list(f) [('url', 'www.iplaypy.com'), ('title', 'python web site')] 字典.iteritems()方法在需要迭代结果的时候使用最适合，而且它的工作效率非常的高
!!!!Python 3.x 里面，iteritems() 和 viewitems() 这两个方法都已经废除了，而 items() 得到的结果是和 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70845078489befd634d6a3258acfa003/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ab1f8eca2d46be3c437637527fcdcce/" rel="bookmark">
			谈谈malloc()和free()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.函数原型
(void *)malloc(int size) malloc函数的返回值是一个void类型的指针，参数为int类型数据，即申请分配的内存大小，单位是byte。 内存分配成功之后，malloc函数返回这块内存的首地址。你需要一个指针来接收这个地址。但是由于函数的返回值是void *类型的，所以必须强制转换成你所接收的类型。也就是说，这块内存将要用来存储什么类型的数据。
比如： char * p = (char *)malloc(100); 在堆上分配了100个字节内存，返回这块内存的首地址，把地址强制转换成char 类型后赋给char 类型的指针变量p。同时告诉我们这块内存将用来存储char类型的数据。也就是说你只能通过指针变量p来操作这块内存。这块内存本身并没有名字，对它的访问是匿名访问。
申请内存失败：
如果所申请的内存块大于目前堆上剩余内存块（整块），则内存分配会失败，函数返回NULL。注意这里说的“堆上剩余内存块”不是所有剩余内存块之和，因为malloc函数申请的是连续的一块内存。既然malloc函数申请内存有不成功的可能，那我们在使用指向这块内存的指针时，必须用if（NULL！=p）语句来验证内存确实分配成功了。
申请0字节内存 ：
此时函数并不返回NULL，而是返回一个正常的内存地址。但是你却无法使用这块大小为0的内存。这 好比尺子上的某个刻度，刻度本身并没有长度，只有某两个刻度一起才能量出长度。对于这 一点一定要小心，因为这时候if（NULL！=p）语句校验将不起作用。
内存释放：
free函数可以释放malloc申请的空间，它只有一个参数，就是所要释放的内存块的首地址。 free(p)实质作用：斩断指针变量与这块内存的关系。free(p)后，p就不能操作这块空间了，但注意了此时p里面还是存着这块空间的地址，所以还有把p指空(p = NLLL) 注意：不能对P连续2次以上使用free函数。malloc和free必须是一一对应，如果是多对一会发生内存泄漏，一对多会发生错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9f33ce7e9e8c7dffe5c9d051483bb13/" rel="bookmark">
			js实现常见排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，冒泡排序。 顾名思义，就是从头开始，每两个相邻元素相互比较，把大的放后面，这样子经过一次循环，最大的数就被冒泡到最后面了。下一次循环也是这样，只是需要循环的长度减一（排除最后一个数字）
function bubbleSort(arr){ var len = arr.length; for(var i = 0; i &lt; len; i++){ for(var j = 0; j &lt; len - 1 - i; j++){ if(arr[j] &gt; arr[j+1]){ var tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; } } } return arr; } 2，选择排序。就是每次从头到尾寻找一个最小的数字，把他放到最前面，下一次循环也是这样，循环长度减1（去掉最前面的最小数）
function selectSort(arr){ var minIndex,len = arr.length; for(var i = 0; i &lt; len - 1; i++){ minIndex = i; for(var j = i + 1; j &lt; len; j++){ if(arr[j] &lt; arr[minIndex]){ minIndex = j; } } var tmp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = tmp; } return arr; } 3，选择排序。就跟打扑克一样，从左到右，每次把当前的数字跟前面的比较，比他小就插到他前面。在代码中就是先用current表示当前数字，跟他前面的数字比较，比他小就把前面的数字往后放一位，这样，就空出来一个位置。当前面的数字比current小，就把current放到空出来的位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9f33ce7e9e8c7dffe5c9d051483bb13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcbcd30958ef9ad4762baa5173ef078e/" rel="bookmark">
			pycharm常用设置和用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、pycharm使用外部参数时候的设置 使用pycharm的时候 如果脚本需要调用外部参数的时候需要进行一些设置，
调用sys方法需要引入sys模块。 argv[] 代表调用脚本外部参数，arg[0] 输出脚本本身的名字 arg[1] 输出第一个参数，arg[2]输出第二个，这个用法在Linux下 同样适用。
import sys print(sys.argv[0]) print(sys.argv[1]) 我们在pycharm下面内置的cmd下打开运行该脚本： D:\pyProject&gt;python one.py hello one.py hello 如果我们不加参数直接运行这个脚本的话将会报错，我们需要设置一下。 shift+alt+f10 这个三个键一起按，选择第一个Edit Configurations 编辑，设置默认参数 在Script parameters:写下参数，例如one，多个参数就用空格隔开，例如one two,点击Apply,Run D:/pyProject/one.py one 整体测试一下，设置参数后的结果：
` import sys print(sys.argv[0]) print(sys.argv[1]) print(sys.argv[2]) 按下 shift + f10 D:/pyProject/one.py one two`
2 pycharm 常用快捷键 1、ctrl + c 不需要选中当前行，直接将光标放在当前行任意位置就可整行复制 2、ctrl + x 剪切，原理同ctrl +c 3、ctrl + d 直接复制上一行代码，到下一行，非常好用 4、ctrl +shift +n 通过文件名快速查找工程内文件，当我们写完代码，格式不正确想调整时 5、ctrl a 全部选中代码后，ctrl +alt+l 能自动调整代码格式为我们需要的格式 6、alt + enter 选中os,然后点击导入os模块就可以了 7、光标选中代码块，ctrl +/ 实现批量注释，打开注释，再操作一遍就行了 8、光标选中代码块，tab 键实现批量向后移动，批量向前移动：shift + tab 9、shift +enter 不用考虑光标位置，直接往下跳一行，ctrl + enter 是往上跳一行来进行开发
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcbcd30958ef9ad4762baa5173ef078e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/321cad69bf0159d61810e34bce6de995/" rel="bookmark">
			getter 和 setter 方法有什么意义？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 来自《 API design for C++ 》 1. 有效性验证（可以在setter里检查设置的值是否在许可区间里） 2. 惰性求值（比如一个成员计算过于耗时，而这个类的用户（这里的用户指其他程序员）不一定需要时，可以在 getter 方法调用的时候再计算） 3. 缓存额外的操作（比如用户调用setter方法时，可以把这个值更新到配置文件里） 4. 通知（其它模块可能需要在某个值发生变化的时候做一些操作，那么就可以在setter里实现） 5. 调试（可以方便的打印设置日志，从而追踪错误） 6. 同步（如果多线程访问需要加锁的话，setter里加锁不是很容易么） 7. 更精细的权限访问（比如private变量只有 getter 没有setter，那客户对该变量就是只读了，而类的内部代码可以读写） 8. 维护不变式关系（比如一个类内部要维持连个变量a和b有a = b * 2的关系，那么在a和b的setter里计算就能维持这样的关系） 我再说个，还可以不对外暴露内部的数据组织方式，即使类数据的组织结构发生变化也不需要修改外部用户的代码。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/909cf37add05a5614f0b3f8900df1d3d/" rel="bookmark">
			6-4 二叉树求深度和叶子数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写函数计算二叉树的深度以及叶子节点数。二叉树采用二叉链表存储结构 函数接口定义：
int GetDepthOfBiTree ( BiTree T); int LeafCount(BiTree T); 其中 T是用户传入的参数，表示二叉树根节点的地址。函数须返回二叉树的深度（也称为高度）。 裁判测试程序样例：
//头文件包含 #include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; #include&lt;malloc.h&gt; //函数状态码定义 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define OVERFLOW -1 #define INFEASIBLE -2 #define NULL 0 typedef int Status; //二叉链表存储结构定义 typedef int TElemType; typedef struct BiTNode{ TElemType data; struct BiTNode *lchild, *rchild; } BiTNode, *BiTree; //先序创建二叉树各结点 Status CreateBiTree(BiTree &amp;T){ TElemType e; scanf("%d",&amp;e); if(e==0)T=NULL; else{ T=(BiTree)malloc(sizeof(BiTNode)); if(!T)exit(OVERFLOW); T-&gt;data=e; CreateBiTree(T-&gt;lchild); CreateBiTree(T-&gt;rchild); } return OK; } //下面是需要实现的函数的声明 int GetDepthOfBiTree ( BiTree T); int LeafCount(BiTree T); //下面是主函数 int main() { BiTree T; int depth, numberOfLeaves; CreateBiTree(T); depth= GetDepthOfBiTree(T); numberOfLeaves=LeafCount(T); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/909cf37add05a5614f0b3f8900df1d3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dacf9f85fdba669ff16fc3ad0a1f0c7/" rel="bookmark">
			C&#43;&#43;保存数据到本地文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 保存数据到本地文件常用的有两种方法：
1， 使用ofstream
#include &lt;fstream&gt; int main() { std::ofstream outFile; //打开文件 outFile.open("F:\\Test.txt"); int arr[5] = {1, 2, 3, 4, 5}; int i; for(i = 0; i &lt; 5; i++) { //写入数据 outFile &lt;&lt; arr[i]; } //关闭文件 outFile.close(); } 结果如下：
2，使用fprintf
#include &lt;stdio.h&gt; int main() { //打开文件 FILE *outFile = fopen("F:\\Test.txt", "w"); int arr[5] = {1, 2, 3, 4, 5}; int i; for(i = 0; i &lt; 5; i++) { //写入数据 fprintf(outFile, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dacf9f85fdba669ff16fc3ad0a1f0c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51d078ce1d38f195e9f59c1d058d76f6/" rel="bookmark">
			VMDK（VMWare Virtual Machine Disk Format）是虚拟机VMware创建的虚拟硬盘格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下内容摘自百度百科：https://baike.baidu.com/item/vmdk
VMDK（VMWare Virtual Machine Disk Format）是虚拟机VMware创建的虚拟硬盘格式，文件存在于VMware文件系统中，被称为VMFS（虚拟机文件系统）.
关于VMDK格式:
VMDK（VMWareVirtual Machine Disk Format）是虚拟机VMware创建的虚拟硬格式，文件存在于VMware文件系统中，被称为VMFS（虚拟机文件系统）。一个VMDK文件代表VMFS在虚拟机上的一个物理硬盘驱动。所有用户数据和有关虚拟服务器的配置信息都存储在VMDK文件中。
通常而言，VMDK文件容易比较大，所以，2TB大小的文件都不足为奇。正因为如此，他们被描述为“大的、块级I/O模式”。任何用户数据变化或虚拟服务器配置变化，VMDK文件都要更新。由于VMDK没有增量类型数据获取功能，任何对文件的更改意味着整个文件需要重新备份。
使用
VMDK文件的使用：
1vmware workstation里创建new virtual machine，到disk这一步时，选use an existing virtual disk，然后在下一屏Existing disk file浏览到你下载的这个.vmdk就可以使用了。
2.WinMount支持挂载 VMDK 磁盘文件到一个虚拟磁盘，可以很方便地读取、修改、添加、删除磁盘内容，并保存修改到原始VMDK文件中。WinMount支持将虚拟机硬盘镜像VHD(VirtualPC)、VDI(Virtual Box)、VMDK(VMWare)挂载为虚拟磁盘，并提供只读和可写两种打开方式。
VMDK的容器定位
为了使用VMware更强大的功能，VMDK容器一般需要存放在共享存储上。在主机硬盘上不大可能会找到VMDK容器。
要找到相应的VMDK的位置，可以使用vSphere内嵌的“Maps”标签页
该Maps视图显示了虚拟机和对应的包含该虚拟机VMDK容器的存储介质之间的关系。
现在我们既然已经知道了VMDK容器的位置，我们需要创建一个运行虚拟机的快照。创建一个快照从字面上理解就是将虚拟机的父磁盘冻结。当创建一个快照时，一个新的子磁盘会被创建同时所有的写操作都会转到该子磁盘中，这样父磁盘就处于一个静止的状态。另外，父磁盘(*flat.vmdk)本质上是一个物理磁盘的抽象，因此，他相当于（以dd或者原始格式）进行逐位复制。简而概之，在取证的时候我们总是想要逐位复制，因为这可以提供已分配和未分配的磁盘空间。如果是传统的对物理硬盘的文件拷贝，那只会提供已分配的磁盘空间，如此一来你就不能恢复那些已经删除的文件。
我这里项目面临的一个问题是这样的具体描述：
在win7系统环境内，给定一个.vmdk的文件，通过实现在win7上的程序来解析.vmdk的内容，比如可以给定这个.vmdk的一段位置来分析是什么内容。这里不运行虚拟机，也不是从虚拟机里面来获取里面的信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/239e40fe3b82cb07a228260705e98e52/" rel="bookmark">
			pycharm第一次使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pycharm简介 PyCharm是一种Python IDE，带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，是我们用作开发工具的不二选择。Pycharm有两种版本可选，专业版（收费）和社区版（免费），我们用社区版的就可以了。 下载链接：https://www.jetbrains.com/pycharm/download/download-thanks.html?platform=windows&amp;code=PCC，下载完后，由于win下的特性，下一步 下一步就可以了。
Pycharm 设置 python环境设置: 一般创建项目的时候会选定python环境，如果没有的时候需要手动设置，设置如下： file&gt;&gt;setting&gt;Project Interperoreter&gt;&gt;选择python版本环境 字体设置： file&gt;&gt;setting&gt;&gt;Editor&gt;&gt;font,然后在下面可以，点击Font 来选择自己喜欢的字体，点击size选择合适自己的尺寸。下面是我自己的喜好： 脚本头文件默认设置： file&gt;&gt;setting&gt;&gt;Editor &gt;&gt;File and Code Templates &gt;&gt;Python Script 设置参数：
#!/usr/bin/python # -*- coding:utf-8 -*- # @Time : ${DATE} ${TIME} # @Author : liaochao # @File : ${NAME}.py 点击Ok,以后创建脚本的时候都会帮你自动生成头文件
pycharm下的第一个python程序：
#!/usr/bin/python # -*- coding:utf-8 -*- # @Time : 2017/10/17 0017 10:17 # @Author : liaochao # @File : one.py name = raw_input('Plase input you name: ') print ('hello ' + name) 点击shitf + F10 运行该程序： D:\Python27\python.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/239e40fe3b82cb07a228260705e98e52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2170603ea7b92cfffab0e8e230cceb9/" rel="bookmark">
			C&#43;&#43;使用函数式代替泛型迭代器设计接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++使用函数式代替泛型迭代器设计接口 C++ 标准库使用迭代器作为索引下一值的部件。这在许多方面是有利的。
比如我们有一个生成平方列表的函数：
template &lt;typename _Iter&gt; vector&lt;int&gt; get_square_list(_Iter begin, _Iter end) { vector&lt;int&gt; v; for (auto iter = begin; iter != end; ++iter) { auto e = *iter; v.push_back(e * e); } return v; } int main(void) { vector&lt;int&gt; v { 1, 2, 3, 4, 5 }; list&lt;int&gt; l { 5, 4, 3, 2, 1 }; auto vlist = get_square_list(v.begin(), v.end()); auto llist = get_square_list(l.begin(), l.end()); for (auto e : vlist) { cout &lt;&lt; e &lt;&lt; endl; } for (auto e : llist) { cout &lt;&lt; e &lt;&lt; endl; } } 以上示例证明，在泛型编程中，使用模板+迭代器的接口，具有很大的优势。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2170603ea7b92cfffab0e8e230cceb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ee7a894b197f38d1681b03f850fa8f/" rel="bookmark">
			win10安装autocad 2013出现command line option syntax error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这种问题，很有可能是你的安装文件所在目录的路径包含中文，修改即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8440a6587801ff6b5bbfdd02fa2cf623/" rel="bookmark">
			Django报错——Migration admin.0001_initial is applied before its dependency users.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这种问题的原因是之前执行过run manage.py task中的：
migrate 然后再次执行：
migrate users #users为app名称 解决办法是，删掉数据库中的所有表，并删除app下的migrations文件夹，然后再执行：
makemigrations users migrate users 即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e3abcf25eae335340be5ca35c20693e/" rel="bookmark">
			C&#43;&#43;中 Unicode 与 UTF-8 编码互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简述
最近在发送网络请求时遇到了中文字符乱码的问题，在代码中调试字符正常，用抓包工具抓的包中文字符显示正常，就是发送到服务器就显示乱码了，那就要将客户端和服务器设置统一的编码（UTF-8），而我们程序中 一般用的是Unicode编码，所以这就需要将中文字符转为UTF-8格式的，其他英文字符和数字就不需要转了。下面就讲述一下方法。
2、代码之路
Unicode 转 UTF-8
char* UnicodeToUtf8(const wchar_t* unicode) { int len; len = WideCharToMultiByte(CP_UTF8, 0, unicode, -1, NULL, 0, NULL, NULL); char *szUtf8 = (char*)malloc(len + 1); memset(szUtf8, 0, len + 1); WideCharToMultiByte(CP_UTF8, 0, unicode, -1, szUtf8, len, NULL, NULL); return szUtf8; } int main(int argc, char *argv[]) { wchar_t* wCharUnicode = L"中国"; char* cCharUtf = UnicodeToUtf8(wCharUnicode); return 0; } 结果如下： 我们看到转为UTF-8之后在VS中查看时显示为其他字符。为了验证我们转的字符是否正确，我们可以借用NotePad++这个工具。我们新建一个文件，用NotePad++打开，文件编码默认为ANSI格式，这里显示的跟VS中调试时显示的值是一样的。 我们修改文件编码为UTF-8之后再看一下，是不是显示正常了，所以验证了转换代码正确。 UTF-8 转 Unicode
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e3abcf25eae335340be5ca35c20693e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3287310f8fcd7dfc4d8bf479cc859c7f/" rel="bookmark">
			【tensorflow】Input to reshape is a tensor with xxx values, but the requested shape requires a multipl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天写了一个简单的3DCNN，结果在跑的时候出现一个问题，
tensorflow.python.framework.errors.InvalidArgumentError: Input to reshape is a tensor with xxx values, but the requested shape requires a multiple of xxx values
好气！！
错误定位到了加载数据那里。
感觉上应该数输入数据的shape处理出了点问题，但我检查了好几遍，都没发现哪里写错了。
也查了很多博客，也验证了我的猜想，就是shape出了问题。
这个地方指出，
然后我又仔细推导了一遍我的卷积、池化操作，看shape的改变是否对应，终于发现了问题，我的池化操作，本来步长应该是[1,1,2,2,1]的，结果我步长都写作了1，结果自然导致我的数据shape无法对应，修改后错误解决。
关键是我检查好几遍才发现这个步长写错，是因为我把池化操作封装在一个函数中，每次调用函数我默认我是写的步长是对的，就没有仔细检查，真是罪过啊！！
所以说，出现这种类似的问题，一般都是你数据shape搞错了，认真手推一波，一定能发现哪里写错的。
以此为戒，记录自己的粗心大意。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0726a25f71a635c74b71d96a8cea98c/" rel="bookmark">
			centos的screen使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明，screen 是一款安装在服务器，在单一终端窗口进行多任务切换的软件。好处在于。(1)，使用多个窗口进行任务切换操作.
1，安装
(1)，yum 安装 ： yum install -y screen
(2)，prm包安装：
1),下载prm包
wget ftp://bo.mirror.garr.it/1/slc/centos/7.1.1503/os/x86_64/Packages/screen-4.1.0-0.19.20120314git3c2946.el7.x86_64.rpm rpm -ivh screen-4.1.0-0.19.20120314git3c2946.el7.x86_64.rpm
2),安装
which screen screen -v
2,使用
(1), 输入screen启动。
(2),查看窗口 screen --list
(2),alt+a+c 增加一个窗口
(3),alt+a+n/p窗口切换
(4),退出当前窗口exit
(5),锁定 alt + a + s, 解除 alt + a +
3，官网 http://www.gnu.org/software/screen/
转载于:https://www.cnblogs.com/bubaya/p/7668497.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/841611a20b1f251491b143dc678940e4/" rel="bookmark">
			普通用户centos6.3 如何安装cmake3.9.4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个Linux小白，并且还只是一个普通用户，不在sudoers 里面，更没有root权限，安装cmake花费了好几天时间，所以记录下来，写的不好大家不要喷。
首先安装包的下载，就没那么容易！！！
我最开始下载的是右下角红框圈出的这种，然后按照“三步法”， ./configure; make; make install. 可是第一步就走不通，总是提示“没有那个文件或目录”，查了好久资料才知道，原来./configure 是 源代码 安装的第一步，而我下载的是编译好的二进制文件，正如左上角红框所示，而我根本不知道还有源代码和二进制包这两种不同的安装包，最终才下到了源代码包：
然后tar -zxvf cmake-3.9.4.tar.gz， 解压完成，cd到解压后的目录，这下第一步./configure就走通了，然后make很顺利，再接着make install 就出问题啦！！！
具体提示的错误当时没有截图，现在不记得了，大概就是我的权限不够，查了资料之后得知我应该设置一下安装的路径，安装在自己的目录下，在第一步configure那里就要设置，./configure --help可以看到有一个--prefix选项，这个就是用来设置安装目录的，
比如我设置的安装目录为./configure --prefix=/home/me/cmake-3.9.4，然后make, make install就安装好了。接下来就要设置环境变量，在cmake解压后的目录下，ls -a,可以看到有一个.bashrc文件，就是要把自己的cmake的bin目录添加到这个文件里，以 "." 开头，说明这是一个隐藏文件，如果只用ls命令，不加-a选项，是看不到的（我也是查了之后才知道的），在这个文件末尾添加一行
export PATH=/home/me/cmake-3.9.4/bin:$PATH ，当然这是我自己的路径，大家根据自己的路径添加，反正就是解压的cmake下的bin目录。然后保存，再在命令行执行一句
source /home/me/.bashrc
这样子就可以永久的把这个环境变量保存下来，在下一次打开终端的时候这个环境变量还在，否则就只能在当前终端生效。
echo $PATH可以看到环境变量已经添加进去。
然后cmake --version就可以输出cmake version 3.9.4，表示已经安装成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/384ec3faa8df3ea6f898b9898297b4a6/" rel="bookmark">
			@PropertySource和@ConfigurationProperties
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @ConfigurationProperties(prefix=”author”) 没有指定classpath时，IDEA提示没有找到classpath。
在浏览器中访问的结果是null 0是由于在没指定路劲的情况下，默认在resource下的applications.properties中查找，如果找到则返回值，如果没有找到则返回默认值null/0/false…
分析 出现spring boot Configuration Annotation Proessor not found in classpath的提示是在用了@ConfigurationProperties这个注解时，所以问题出现在ConfigurationProperties注解。根据提示的not found in classpath,查询此注解的使用关于怎么指定classpath,进而查询location，spring boot1.5以上版本@ConfigurationProperties取消location注解解决方案： 在配置类中采用@Component的方式注册为组件，然后使用@PropertySource来指定自定义的资源目录.(本人测试用@Service代替@Component也可以的) 有以下三种解决方案： 第一种：在resource中创建author.properties，并指明@PropertySource(“author.properties”) ,即默认在resource下找此文件，找到返回一个值，找不到则报错，报文件找不到，打不开。
第二种： 在resource下创建config文件夹，把author.properties放在config下，访问方式为：@PropertySource(“classpath:config/book.properties”)
第三种： 直接写在application.properties中（不建议这么做，但如果时全局变量提倡这种方法），当写在此文件中时，不需要指明资源文件路劲，只需要指明前缀即可。如下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c964d769f9ff60f3b2ad8c24b2d1e9a/" rel="bookmark">
			大数据圈儿微信公众号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据圈儿主要围绕大数据学习、大数据资源、大数据博客、大数据资讯等方面进行优质内容的分享，共享的学习资源主要包括各大培训结构的大数据相关网络可能，全部百度云，希望能对大数据感兴趣的圈里人提供一些帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8839cc112ce35264f031694c09ebb188/" rel="bookmark">
			Eclipse使用Maven创建工程时在quickstart那一步出错Could not resolve archetype ......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Eclipse自带的Maven插件创建工程时时报错：
Could not resolve archetype org.apache.maven.archetypes:maven-archetype-webapp:RELEASE from any of the configured repositories.
Could not resolve artifact org.apache.maven.archetypes:maven-archetype-webapp:pom:RELEASE
Failed to resolve version for org.apache.maven.archetypes:maven-archetype-webapp:pom:RELEASE: Could not find metadata org.apache.maven.archetypes:maven-archetype-webapp/maven-metadata.xml in local (C:\Users\liujunguang\.m2\repository)
Failed to resolve version for org.apache.maven.archetypes:maven-archetype-webapp:pom:RELEASE: Could not find metadata org.apache.maven.archetypes:maven-archetype-webapp/maven-metadata.xml in local (C:\Users\liujunguang\.m2\repository)
错误如图：
这里强调下，不一定非要创建web工程时才会出现这样的错误
解决方案：
在Eclipse Maven配置中添加新的Catalog配置：
http://repo1.maven.org/maven2/archetype-catalog.xml 也可以下载到本地，然后再添加，这样比较快，eclipse联网比较慢
如图：
接下来在使用刚添加的catalog创建web工程
这个时候就可以看到Eclipse联网下载了：
这个时候看一下是不是创建成功了
如果还是不能创建或者问题没有解决可以安装下面的方法：
1.删除maven已经下载的文件路径：.m2\repository\org\apache\maven
删除之后再试下，这时候如果看到有进度，只需要耐心等待就行了
2.Maven下载jar慢可以使用国内阿里镜像
具体配置文件（settings.xml）如下，放在.m2文件夹下，.m2一般位于用户目录下
[html] view plain copy &lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8839cc112ce35264f031694c09ebb188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0a39a8e7458b90090387bc1d6d4640d/" rel="bookmark">
			mysql 时间类型查询条件写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天在写一个sql查询3个月前的历史数据时，直接在时间字段上用“&lt;2010-07-09”来过滤，结果sql执行一直报warning：Incorrect date value: '1988' for column 'gmt_create' at row 1 今天再次做了验证，发现如下： 表结构 root@test 02:38:59&gt;show create table xc\G *************************** 1. row *************************** Table: xc Create Table: CREATE TABLE `xc` ( `id` int(10) unsigned NOT NULL auto_increment, `gmt_create` date NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=gbk 1 row in set (0.00 sec) 数据 root@test 02:51:13&gt;select * from xc; +----+------------+ | id | gmt_create | +----+------------+ | 1 | 2010-10-05 | | 2 | 2010-10-06 | | 3 | 2010-09-25 | +----+------------+ 3 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0a39a8e7458b90090387bc1d6d4640d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/446/">«</a>
	<span class="pagination__item pagination__item--current">447/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/448/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>