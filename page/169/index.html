<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2863d97dfa1f9148ded091f1d162d97/" rel="bookmark">
			八皇后问题汇总（C&#43;&#43;版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		八皇后问题汇总（C++版） 八皇后问题八皇后问题（来源：openjudge）八皇后（来源：openjudge）[P1219 [USACO1.5]八皇后 Checker Challenge（来源：洛古）](https://www.luogu.com.cn/problem/P1219) 八皇后问题 八皇后问题（英文：Eight queens），是由国际象棋棋手马克斯·贝瑟尔于1848年提出的问题，是回溯算法的典型案例。
问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。如果经过±90度、±180度旋转，和对角线对称变换的摆法看成一类，共有42类。
放置第i个（行）皇后的算法为：
int search(int i){ int j; for(j=1;j&lt;=8;j++){ if(本行本列允许放置皇后) 放置第i个皇后； 对放置皇后的位置进行标记； if(i==8)输出//已经放完8个皇后 else search(i+1);//放置第i+1个皇后 释放标记，尝试下一个位置是否可行； } } 【算法分析】
显然问题的关键在于如何判定某个皇后所在的行、列、斜线上是否有别的皇后。
可以从矩阵的特点上找到规律，如果在同一行，则行号相同；如果在同一列，则列号相同；
如果在/斜线上，则行列值之和相同，如果在\斜线上，则行列值之差相同。
考虑到每行有且只有一个皇后，设一维数组a[1…8]表示皇后的放置：第i行皇后放在第j列，用a[i]=j来表示，即下标是行数，内容是列数。例如：a[3]=5就表示第3个皇后在第3行第5列上。
判断皇后是否安全，即检查同一列、同一对角线是否已有皇后，建立标志数组b[1…8]控制同一列只能有一个皇后，若两皇后在同一对角线上，则其行列坐标之和或行列坐标之差相等，故亦可建立标志数组c[1…16],d[-7…7]控制同一对角线上只能有一个皇后。
【参考程序】
#include&lt;bits/stdc++.h&gt; using namespace std; bool d[17]={0},b[9]={0},c[17]={0}; int sum=0,a[9]; int search(int); int print(); int main(){ search(1); cout&lt;&lt;sum&lt;&lt;endl; return 0; } int search(int i){ int j; for(j=1;j&lt;=8;j++){ if((!b[j])&amp;&amp;(!c[i+j])&amp;&amp;(!d[i-j+7])){//!b[j]---&gt;表示不能在同一列 //!c[i+j]---&gt;表示不能在正对角线上 //!d[i-j+7]---&gt;表示不能在反对角线上 a[i]=j; b[j]=1; c[i+j]=1; d[i-j+7]=1; if(i==8)print(); else search(i+1); b[j]=0; c[i+j]=0; d[i-j+7]=0; } } } int print() {	int i; sum++; for(int i=1;i&lt;=8;i++) cout&lt;&lt;a[i]&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2863d97dfa1f9148ded091f1d162d97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0307cb7b48d8323b7045922eea21e47f/" rel="bookmark">
			C&#43;&#43;算法——搜索与回溯算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五、搜索与回溯算法 搜索与回溯算法 迷宫问题： 例5.1素数环：将1到20这20个数摆成一个环，要求相邻的两个数的和是一个素数。例5.2：设有n个整数的集合｛1,2，……，n｝，从中任意取出r个数进行排列（r&lt;n）,试列出所有的排列。例5.3： 任何一个大于1的自然数n，总可以拆分成若干个小于n的自然数之和。 搜索与回溯算法 搜索与回溯是计算机解题过程中常用的算法，很多问题无法根据某种确定的计算机法则来求解，可以利用搜索与回溯的技术求解。回溯是搜索算法中的一种控制策略。它的基本思想是：为了求得问题的解，先选择某一种可能的情况向前探索，在探索过程中，一旦发现原来的选择是错误的，就退回一步重新选择，继续向前探索，如此反复进行，直至得到解或证明无解。
迷宫问题： 进入迷宫后，先随意选择一个前进方向，一步步向前试探前进，如果碰到死胡同，说明前进方向已无路可走。这时，首先看其他方向是否还有路可走：如果有，则沿该方向再次向前试探；否则退回一步，再看其他方向是否还有路可走。按此原则下不断搜索回溯再搜索，直到找到新的出路或从原路返回入口处无解为止。
递归回溯算法框架1
int search(int k){ for(i=1;i&lt;=算符种数;i++){ if(满足条件)｛ 保存结果; if(到目的地)输出解; else search(k+1); //恢复：保存结果之前的状态 ｝ } } 递归回溯算法框架2
int search(int k){ if(到目的地)输出解; else for(i=1;i&lt;=算符种数;i++){ if(满足条件)｛ 保存结果; search(k+1); //恢复：保存结果之前的状态 ｝ } } 例5.1素数环：将1到20这20个数摆成一个环，要求相邻的两个数的和是一个素数。 【算法分析】
非常明显，这是一道回溯的题目。将1开始，每个空位有20种可能，只要填进去的数合法：与前面的数不相同；与左边相邻的数的和是一个素数。第20个数还要判断和第1个数的和是否是素数。
【算法流程】
（1）数据初始化；（2）递归填数：判断第i个数是否合法。
如果合法：填数；判断是否达到目标（20个已填完）：是，打印结果；不是递归填下一个。如果不合法：选择下一种可能。 【参考程序】
//由于20个数的素数环方案太多，该代码以6个数为例（仅两种方案） #include&lt;bits/stdc++.h&gt; using namespace std; bool b[21]={0,1};//判断是否可用 int total=0,a[21]={0,1};//计数、存储数据 int search(int );//回溯过程 int print();//输出方案 bool pd(int ,int );//判断素数 int n=20; int main(){ search(2); cout&lt;&lt;total&lt;&lt;endl; return 0; } int search(int t){ int i; for(i=2;i&lt;=n;i++){//有20个数可选 if(pd(a[t-1],i)&amp;&amp;(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0307cb7b48d8323b7045922eea21e47f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9be9a8fdc97cd2e5637ddd5ca161086/" rel="bookmark">
			测试学习从小白开始到XX级别需要经历的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小白就是首先要会梳理场景，然后把场景转换成文档，到时候按照你的文档进行执行就可以，这是第一步 第二部进阶就是你要学会使用工具进行测试，比如接口调试工具，F12，Charles，wireshark
第三步就是会写sql以及简单的脚本
第四步就是能够进行单元测试
第五步就是进行系统工具的开发
高级资深就是全栈能够搭建测试环境以及部署服务
深度讲解个别词汇：
场景：正向场景，异向场景，用到的测试case编写有等价替换，有效值，无效值等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a22bbd14a3ef031a1f57ef9ef36a5b5a/" rel="bookmark">
			Android 新增加Audio Codec ，遇到的编译问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android S 上新增加Audio Codec Support ,遇到如下编译问题，记录一下处理方法，
1. error 1
******************************************************
error: VNDK library: libstagefright_foundation's ABI has EXTENDING CHANGES Please check compatibility report at: out/soong/.intermediates/frameworks/av/media/libstagefright/foundation/libstagefright_foundation/android_vendor.31_arm64_armv8-a_cortex-a73_shared/libstagefright_foundation.so.abidiff
******************************************************
2.error 2
******************************************************
error: VNDK library: libaudioutils's ABI has EXTENDING CHANGES Please check compatibility report at: out/soong/.intermediates/system/media/audio_utils/libaudioutils/android_vendor.31_arm64_armv8-a_cortex-a73_shared/libaudioutils.so.abidiff
******************************************************
分析error：
1.针对error 1 查看libstagefright_foundation.so.abidiff这个文件提示如下，
lib_name: "libstagefright_foundation" arch: "arm64" global_vars_added { name: "android::MEDIA_MIMETYPE_AUDIO_AVS3" source_file: "frameworks/av/media/libstagefright/foundation/include/media/stagefright/foundation/MediaDefs.h" linker_set_key: "_ZN7android25MEDIA_MIMETYPE_AUDIO_AVS3E" referenced_type: "const char *" access: public_access } added_elf_objects { name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a22bbd14a3ef031a1f57ef9ef36a5b5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df5b6f3dda659dcbe79bb54f7c009732/" rel="bookmark">
			python实现api接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import sys sys.path.append("./src") # 把代码路径加入进去防止引用自定义模块报错 from fastapi import FastAPI from src.DiffProcess import Run # 写的程序入口 res = Run() # 程序返回结果得到 app = FastApi() @app.get("./") # get请求方法可以用浏览器直接请求 def GetResult(subnetId:str): return res[subnetId] # 显示结果一定要是字典形式 在终端中运行：
main:app --reload 或者直接在主程序中加：
if __name__ == "__main__": import uvicorn uvicorn.run(app = app,host="0.0.0.0",port=8000,workers=1) 运行即可
在浏览器中输入：
http://127.0.0.1:8000/?subnetId=71-1 即可得到返回结果，？标识参数调用，直接传入到@app装饰的函数之中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4667c58e2d19621bb25aec58e7a2668a/" rel="bookmark">
			SAS文件管理/datasets
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SAS文件夹管理/datasets proc datasets 是对逻辑库及其中的文件进行描述和操作的过程步，主要功能有：
处理SAS文件查看逻辑库中文件信息（名称、类型、观测数量、变量个数、标签、文件大小、修改时间）重命名文件、删除文件、删除标签和格式创建索引查看 处理SAS文件（复制、命名、删除） LIBNAME dest1 'SAS-library-1'; LIBNAME dest2 'SAS-library-2'; LIBNAME health 'SAS-library-3'; proc datasets library=health details; delete tension a2(mt=catalog); change a1=postdrug; exchange weight=bodyfat; copy out=dest1 move memtype=view; select spdata; select etest1-etest5 / memtype=catalog; copy out=dest2; exclude d: mlscl oxygen test2 vision weight; quit; 保存一部分文件删除剩下的文件 保存逻辑库elder中的chronic、aging、clinics数据文件，删除其他文件；
LIBNAME elder 'SAS-library'; proc datasets lib=elder; save chronic aging clinics / memtype=data; run; 删除标签和格式 proc format; value clsfmt 1='Freshman' 2='Sophmore' 3='Junior' 4='Senior'; run; data class; format z clsfmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4667c58e2d19621bb25aec58e7a2668a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da36fd0f7734c1e9745e29a9a6d06acd/" rel="bookmark">
			2.4G-WiFi连接路由器过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 WiFi的数据通信基于802.11协议进行，无线AP在工作时会定时向空中发送beacon数据包，基站（STA）从beacon中解析出AP的名称、加密方式等信息，从而发起连接。
二、WiFi连接路由器的详细过程 WiFi连接过程主要可以分为3部分：扫描、认证和关联：
2.1、扫描过程 2.1.1、主动扫描 WiFi的的扫描过程分为主动扫描和被动扫描。主动扫描情况下，STA会依次向各个信道广播发送探寻请求（Probe Request）管理帧，AP在收到Probe Request帧之后会定向回复探寻响应帧（Probe Ack），其中包含AP的SSID、MAC地址、加密方式等信息，之后STA根据路由器返回的信息进行连接和认证。
主动扫描有助于STA更快的发现周围的AP，但同时也会带来更高的功耗。
路由器返回的Probe Rsp中携带的信息和Beacon帧大同小异，下图是使用omipeek抓到的Probe Rsp包在wireshark中解析到的信息：
2.1.2、被动扫描 被动扫描，STA被动接收AP发送的Beacon管理帧，并且只会向无线AP所在信道发送Probe Request，它和主动扫描相比的优势在于可以降低功耗。
使用wireshark可以看到Beacon帧的结构如下图：
Beacon帧是广播，而Probe Response帧则是针对特定请求返回的单播数据。
2.2、认证 路由器的beacon帧和其返回的Probe Response帧中都包含路由器的SSID、加密方式等信息，STA在获得这些信息之后，使用提前设置好的密码按照正确的加密方式即可发起认证过程。
认证过程主要由认证请求（Auth Request）和认证响应（Auth Response）两部分组成：
STA向AP发起认证请求：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gJuQFHkq-1676278372975)(https://note.youdao.com/yws/res/6/WEBRESOURCEdd8b4d68d00522c3fc3b900bc1f7e366)]AP响应认证请求：
认证请求和认证响应的帧格式类似，但是源地址和目的地址不同，认证请求的源地址是STA的地址，认证响应的源地址是AP地址。
2.3、关联 认证之后，STA向AP发送连接请求（Association Request），AP响应连接请求（Association Response）。
Association Request：
Association Response
参考：https://www.modb.pro/db/146335
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19c8fcf56389a8f437426cdad8340f5f/" rel="bookmark">
			usbmon&#43;tcpdump&#43;wireshark USB抓包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 usbmon抓包及配合wireshark解析 usbmon抓包及配合wireshark解析 usbmon首先编译为内核模块，然后通过modprobe usbmon加载到linux sys文件系统中
root@root-PC:~# modprobe usbmon ​ 而后 linux系统下安装 tcpdump
root@root-PC:~# apt-get install tcpdump ​ 首先找到 USB 设备是挂接到那条USB总线上的：
​ 可使用 lsusb 命令，也可以直接 访问sys文件系统下usb设备查看所有usb设备的详情（例如下述要找的是U盘设备）：
root@root-PC:~# cat /sys/kernel/debug/usb/devices T: Bus=04 Lev=02 Prnt=03 Port=02 Cnt=01 Dev#= 7 Spd=5000 MxCh= 0 D: Ver= 3.10 Cls=00(&gt;ifc ) Sub=00 Prot=00 MxPS= 9 #Cfgs= 1 P: Vendor=058f ProdID=6387 Rev= 0.02 S: Manufacturer=aigo S: Product=MiniKing S: SerialNumber=BEFCBCC3 C:* #Ifs= 1 Cfg#= 1 Atr=80 MxPwr=800mA I:* If#= 0 Alt= 0 #EPs= 2 Cls=08(stor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19c8fcf56389a8f437426cdad8340f5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f425ca505fa3221bbe8e3f4440d8fa38/" rel="bookmark">
			如何保证软件系统的稳定性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		保证软件系统稳定性的方法有很多，其中一些常见的方法如下：
良好的代码实践：使用良好的编码标准，设计模式和代码评审来保证代码的质量。
单元测试：使用单元测试来验证代码是否按预期运行。
功能测试：使用功能测试来验证软件是否满足用户需求。
性能测试：使用性能测试来评估软件的效率和稳定性。
异常处理：编写代码以处理预期外的异常情况，以避免系统崩溃。
负载测试：使用负载测试来评估软件在高负载下的表现。
系统监控：实施系统监控，以检测并解决性能问题。
以上是一些保证软件系统稳定性的常用方法，但不同的软件系统可能需要采取不同的措施，因此需要根据实际情
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c4cee7f87bc0f6f95754539606c8a9/" rel="bookmark">
			使用Python三行代码生成验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import random from captcha.image import ImageCaptcha source = ['0','1','2','3','4','5','6','7','8','9','A', 'B', 'C', 'D', 'E', 'F', 'G', 'H','I','J', 'K','L', 'M', 'N','O','P','Q','R','S', 'T', 'U', 'V', 'W', 'Z','X', 'Y'] img = ImageCaptcha() code = "".join(random.sample(source,4)) img.write(code,"out.png") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d788f96c7062d9b4ef3b8158b2707214/" rel="bookmark">
			CSS 实现水平和垂直居中的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绝对定位 + 负边距：使用绝对定位并设置左右负边距和上下负边距，就可以实现水平和垂直居中的效果。 .center-element { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } flex 布局：使用 flex 布局可以轻松实现水平和垂直居中。 .center-container { display: flex; align-items: center; justify-content: center; height: 100%; } grid 布局：使用 grid 布局也可以实现水平和垂直居中。 .center-container { display: grid; place-items: center; } 这些方法都可以实现水平和垂直居中的效果，您可以根据需要选择一种方法使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/676ff2a029e24db78e804af9c9b08714/" rel="bookmark">
			chat gbt在未来几年中，无法正常替代，程序员
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chart GBT，作为一款聊天软件，不可避免的被人为操控，可以确信的事，各国都不会允许人民去依赖一款聊天软件来完成工作，根据我国的条约
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86fb8527eef00056f93498318ac14120/" rel="bookmark">
			学习笔记——吴恩达《神经网络与深度学习》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络与深度学习 1. 基础知识神经网络用神经网络进行监督学习 2. 神经网络基础知识二分分类logistic回归logistic回归损失函数梯度下降法导数计算图logistic回归中的梯度下降法m个样本的梯度下降向量化Python中的广播 3. 浅层神经网络神经网络概述神经网络表示计算神经网络的输出多个样本的向量化激活函数激活函数的倒数神经网络的梯度下降法随机初始化 4. 深层神经网络深层神经网络概述深层网络中的前向传播核对矩阵的维数为什么使用深层表示搭建深层神经网络块前向和反向传播参数 VS 超参数 1. 基础知识 神经网络 深度学习指的是训练神经网络，神经网络的一部分神奇之处在于：当你实现他之后，你要做的只是输入x，就能得到输出y（不管训练集有多大），所有的中间过程 它都会自己完成。
这有四个输入的神经网络，输入的特征可能是卧室的数量、邮政编码 和周边的富裕程度，已知这些输入的特征，神经网络的工作就是预测对应的价格。
对于神经网络，只有你喂给它足够多的数据（关于x和y的数据），给到足够的x、y训练样本，神经网络非常擅长于计算从x到y的 精准映射函数。
用神经网络进行监督学习 在监督学习中，输入x，习得一个函数映射到输出y。比如我们之前看到的应用于房价预测的例子，输入房屋的一些特征，就能输出或者预测价格y。
在图像领域里，我们经常应用的是卷积神经网络，通常缩写为CNN对于序列数据，经常使用循环神经网络RNN。音频是随着时间播放的 所以音频很自然地被表示为一维时间序列。
结构化数据是数据的数据库，例如在房价预测中，你可能有一个数据库或者数据列，告诉你房间的大小和卧室数量，这就是结构化数据。结构化数据意味着每个特征，比如说房屋大小 卧房数量都有着清晰的定义。
相反，非结构化数据指的是比如音频、原始音频、图像。这里的特征可能是图像中的像素值，或者是文本中的单个单词。
2. 神经网络基础知识 二分分类 神经网络的计算过程中，通常有一个正向过程（正向传播步骤），接着会有一个反向步骤（反向传播步骤）。
logistic回归是一个用于二分分类的算法，这有一个二分分类问题的例子：假如你有一张图片作为输入，你想输出识别此图的标签，如果是猫输出1，如果不是则输出0，我们用y来表示输出的结果标签。
来看看一张图片在计算机中是如何表示的,计算机保存一张图片要保存三个独立矩阵，分别对应图片中的红、绿、蓝三个颜色通道。如果输入图片是64×64像素的，就有三个64×64的矩阵分别对应图片中 红、绿、蓝三种像素的亮度。
为了把这些像素值取出放入特征向量，就要像下面这样定义一个特征向量x以表示这张图片，我们把所有的像素值都取出来 例如255、231这些，最后得到一个很长的特征向量。如果图片是64×64的，那么向量x的总维度就是64×64×3。我们用nx=12288来表示输入的特征向量x的维度。
在二分分类问题中，目标是训练出一个分类器。它以图片的特征向量x作为输入，预测输出的结果标签y是1还是0。用一对(x,y) 来表示一个单独的样本，x是nx维的特征向量，标签y 值为0或1。训练集由m个训练样本构成，(x(1) ，y(1))表示样本一的输入和输出。
用更紧凑的符号表示训练集，我们定义一个矩阵 用大写的X表示，它由训练集中的x1、x2这些组成，把x(1)放进矩阵的第一列，x(2)是第二列 …… xm是第m列，最后得到矩阵X。这个矩阵有m列，这个矩阵的高度记为nx。
logistic回归 已知的输入特征向量x，你希望把识别出这是不是猫图，你需要一个算法可以给出一个预测值，我们说预测值y帽就是你对y的预测。你希望y帽是一个概率，当输入特征x满足条件时y就是1。
已知Logistic回归的参数是w（也是一个nx维向量），而b就是一个实数。所以已知输入x和参数w和b，y帽可以定义为y帽 = wT x +b，即输入x的线性函数。但这不是一个非常好的二元分类算法，因为你希望y帽是y=1的概率，所以y帽应该介于0和1之间，但实际上这很难实现 因为wTx+b，可能比1大得多或者甚至是负值，这样的概率是没意义的。
所以在Logisitc回归中 我们的输出变成：y帽等于sigmoid函数作用到这个量上，sigmoid(z)就是这样的从0到1的光滑函数。所以当你实现logistic回归时，你要做的是学习参数w和b，所以y帽变成了比较好的估计。
logistic回归损失函数 为了训练logistic回归模型的参数w以及b，需要定义一个成本函数，用logistic回归来训练的成本函数。为了让模型来通过学习调整参数，要给一个m个样本的训练集。你想通过在训练集找到参数w和b来得到你的输出。
我们通过定义损失函数L，来衡量你的预测输出值y帽 和y的实际值有多接近。误差平方看起来似乎是一个合理的选择，但用这个的话梯度下降法就不太好用。在logistic回归中 ，我们使用如下一个误差函数，我们也想让他尽可能的小。
当y=1时，就是-log(y帽) 。你想让-log(y帽)尽可能小，这意味着想让log(y帽)够大尽可能地大，这样就意味你想要y帽够大，但是因为y帽是simoid函数得出的（永远不会比1大），所以你要让y帽接近1。当y=0时，就只有损失函数的第二项，想让损失函数小一些，也就意味着你想要log(1-y帽)够大，即y帽尽可能地小接近0。 损失函数是在单个训练样本中定义的，它衡量了在单个训练样本上的表现。
成本函数它衡量的是在全体训练样本上的表现。成本函数为1/m分之所有训练样本的损失函数和
梯度下降法 损失函数是衡量单一训练样例的效果，成本函数用于衡量参数w和b的效果（在全部训练集上来衡量）。我们要得到使得成本函数J(w, b)尽可能小的w和b。
为了找到更好的参数值，我们要做的就是用某初始值初始化w和b，通常用0来进行初始化。
梯度下降法所做的就是从初始点开始，朝最陡的下坡方向走一步。
为了方便，先忽略b，仅仅是用一维曲线来代替多维曲线，梯度下降法是这样做的，我们将重复执行以下的更新操作：让w=w-αdJ(w)/dw，直到算法收敛。α表示学习率，学习率可以控制每一次迭代或者梯度下降法中的步长，dJ(w)/dw这就是对参数w的更新或者变化量，导数的定义是函数在这个点的斜率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86fb8527eef00056f93498318ac14120/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b3604bd4a9a73d174421107af7b31bd/" rel="bookmark">
			最详细的IP地址及子网划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络层位于数据链路层与传输层之间。网络层中包含了许多协议，其中最为重要的协议就是IP协议。网络层提供了IP路由功能。理解IP路由除了要熟悉IP协议的工作机制之外，还必须理解IP编址以及如何合理地使用IP地址来设计网络。
学完本篇以后，我们应该能够：
掌握IP报文及字段含义
掌握IP编址
掌握网络地址规划
1、IP报文 IP报头格式如图所示，I IP报文头部长度为20到60字节，报文头中的信息可以用来指导网络设备如何将报文从源设备发送到目的设备。同一个网段内的数据转发通过数据链路层即可实现，而跨网段的数据转发需要使用网络设备的路由功能。分片是指数据包超过最大转发长度时，需要被划分成不同的片段使其能够在网络中传输。
图1 ：IP报头
为了更透彻理解IP报头，现将IP报头内部字段含义整理为下表所示。
表1： IP报头字段
IP报文头部长度为20到60字节，报文头中的信息可以用来指导网络设备如何将报文从源设备发送到目的设备。其中，版本字段表示当前支持的IP协议版本，当前的版本号为4。DS字段早期用来表示业务类型，现在用于支持QoS中的差分服务模型，实现网络流量优化。源和目的IP地址是分配给主机的逻辑地址，用于在网络层标识报文的发送方和接收方。根据源和目的IP地址可以判断目的端是否与发送端位于同一网段，如果二者不在同一网段，则需要采用路由机制进行跨网段转发。
2、IP编址 2.1、IP地址格式 什么是IP地址？
前面学习的MAC地址是一个物理地址相当于我们的身份证，那么IP地址就相当于我们各自的电话号码——逻辑地址。用来标识我们在网络中的逻辑位置，一共有两个版本分别是IPv4和IPv6。
IP地址本质上是32位二进制数，共四个字节。一般情况下我们看到的表现形式为点分十进制，它也可以用二进制数表示。如图4-2IP地址两种表现形式。
图2： IP地址表现形式
两种地址表现形式差异很大，如何进行换算？首先我们要知道进制之间的换算关系。
2.2、进制 网络中的数据可以采用二进制、十进制或十六进制来表示。每种进制使用不同的基值表示每一位的数值。二进制每一位只有0和1两个值，基值为2，二进制数的每一位都可以用2的x次幂来表示，x表示二进制数的位数。十六进制的每一位可以有16个数值，范围为0-F（即0-9和A-F），A对应十进制的10，F对应十进制的15（二进制的1111）。
进制的书写形式有两种如下：
数值用括号括起来，进制号下标在右括号，例如：（101）2，表示二进制数101。
用进制简称标识即可，各进制简称如下：
二进制：B
十进制：D
十六进制：H
表2： 常用进制
在IP地址学习阶段经常会进行二进制与十进制的换算，其换算关系如下表所示。
表3：二进制与十进制之间换算关系
我们举个例子：IP地址为172.16.25.3，用二进制形式如何表示？
查找计算：
172=128+32+8+4=（10101100）2
16=16=（00010000）2
25=16+8+1=（00011001）2
3=2+1=（00000011）2
172.16.25.3=10101100.00010000.00011001.00000011
2.3、IP地址分类 从图2中我们可以看出IP地址组成包括两部分，第一部分是网络位，这一部分用来表示所属的网段，第二部分是主机位，用来唯一标识本网段上的某台网络设备。IPv4地址被划分为A、B、C、D、E五类，每类地址的网络号包含不同的字节数。A类，B类和C类地址为可分配IP地址，每类地址支持的网络数和主机数不同。32位的IP地址分为4个字节，每个字节有256（0-255）个取值。因此，理论上IPv4可以有4294967296个IP地址，但实际上只有其中一部分地址可以分配给网络设备使用。如图3中IP地址分类详情。
A类地址：第一个bit必须为0，这样就能计算出A类地址的第一个字节的取值范围为0-127或（00000000）2-（01111111）2，第一个字节为网络位区间，后三个字节为主机位区间。在A类地址中当第一个字节为0或127时，它不归属于A类网络，我们在4.2.3中介绍。
B类地址：前2bit必须为10，那么B类网络地址第一个字节的取值范围为128-191或（10000000）2-（10111111）2，前两个字节段为网络位区间，后两个字节段为主机位区间。
C类地址：前3bit必须为110，第一个字节取值范围为192-223或（11000000）2-（11011111）2。C类地址前三个字节为网络位区间，第四个字节为主机位区间。
D类地址：这一类被定义为组播地址。
E类地址：用于科学研究。
关于D类，E类地址具体范围如图4-3，其详情本节不做讨论。
图3 IP地址分类
2.3.1特殊地址 除了D类E类这两个特殊类地址外，下面还列举了特殊的网络地址。
0.0.0.0：全网络地址，表示所有网络。
255.255.255.255：全局广播地址。
网络地址：网络位不变，主机位全为0；网络地址是一个网段的开端地址。
广播地址：网络位不变，主机位全为1；广播地址是一个网段的结束地址。
127.0.0.0/8： 环回地址，用于诊断网络是否正常。
2.3.2私有IP地址 现阶段世界上所有终端系统和网络设备都需要IP地址，远远超过了32位IPv4地址所能支持的最大地址数为4，294，967，296。网络工程师们为节省IP地址将A、B、C类地址段中都预留了特定范围的地址作为私有地址——内网使用地址。为主机分配私有地址节省了公网地址，这样可以用来缓解IP地址短缺的问题。企业网络中普遍使用私有地址，不同企业网络中的私有地址可以重叠。默认情况下，网络中的主机无法使用私有地址与公网通信；当需要与公网通信时，私有地址必须转换成公网地址。
各类别私有地址具体范围如下
A类：10.0.0.0~10.255.255.255 B类：172.16.0.0~172.31.255.255
C类：192.168.0.0~192.168.255.255
3、子网划分 3.1、子网掩码 与IP地址结构类似，子网掩码由32bit（四字节）组成，以点分十进制表示。子网掩码并不是IP地址，只是用于区分网络部分和主机部分。子网掩码中的1表示网络位，0表示主机位，连续的1数量称为一个子网掩码的长度。举个例子，子网掩码255.255.0.0 转换为二进制11111111.11111111.00000000.00000000，观察得出他是一个16位掩码。每个IP地址和子网掩码一起可以用来唯一的标识一个网段中的某台网络设备。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b3604bd4a9a73d174421107af7b31bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/295c111a7f0848ca5aa7f5eafb9430ac/" rel="bookmark">
			腾讯xSRC[linux&#43;docker]搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯xSRC[linux+docker]搭建教程 1.下载镜像 docker pull xsrc/xsrc:v1.0.1 2.启动镜像 1️⃣启动镜像 docker run -it -d --name xsrc_web -p 60080:80 -p 63306:3306 --privileged=true xsrc/xsrc:v1.0.1 注意将3306端口映射到8806端口，以便于远程连接访问容器内数据库
查看容器ID
docker ps -a 2️⃣设置容器自启 docker update --restart=always 容器ID 3.进入容器 1️⃣进入容器 docker exec -it 容器ID /bin/bash 注：容器ID可只写前三个字符
2️⃣修改ThinkPHP报错参数 网站路径：/usr/share/nginx/html/
注：这里是方便看错然后先改了，网站正式运行测试无误后建议改回
vi /usr/share/nginx/html/ThinkPHP/Tpl/dispatch_jump.tpl “程序错误，请重试！” 修改为 &lt;?php echo($error);?&gt; 改为
3️⃣开启mysql服务 service mysql start //修改默认密码 mysql -uroot -pxSRC_2nv_Cha1gEMe ALTER USER 'root'@'localhost' IDENTIFIED VIA mysql_native_password USING PASSWORD("新密码"); //root@localhost仅能本地连接，创建一个新账户赋予全部数据库权限，且能远程连接 grant all privileges on *.* to root@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/295c111a7f0848ca5aa7f5eafb9430ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96b1e48190219f07b39a7ff5348b3d51/" rel="bookmark">
			Allegro如何隐藏GND网络飞线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行PCB设计的时候，通常会隐藏掉GND网络的飞线，让PCB界面不会显得那么乱，有利于快速的走线。
（1）首先给GND网络分配一个颜色。
选择快捷菜单栏上的assign color（分配颜色）图标
然后在Options选项卡下选择一个暗一点的颜色
随便点击一个GND的网络
（2）然后选择Generaledit（一般编辑模式），选择网络
然后点击Edit菜单选择→Properties（属性），点击GND网络
跳出下面的对话框。找到No_Rat（无飞线）点击，选项就会跳到到右侧，然后点击应用，点击确认。即可。
回到PCB界面可以看到GND网络飞线已经隐藏
博主专注职场硬件设计，如果文章对你有帮助，请关注，点赞，收藏。成长路上有前行者。博主将会定期或不定期分享PADS，Allegro设计技巧和经验。
Allegro provides a good and interactive working interface and powerful functions, and its front-end products Cadence, OrCAD, Capture, the combination of high-speed, high-density, multi-layer complex PCB design routing provides the most perfect solution.
Allegro has perfect Constraint Settings, users only need to set the wiring rules according to the requirements, and the design requirements of the wiring can be achieved without violating the DRC when routing, thus saving the tedious manual inspection time and improving the work efficiency!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96b1e48190219f07b39a7ff5348b3d51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32e28b0d21536a5f65de0cf8f9bdbd0b/" rel="bookmark">
			Scrapy 中 ImagesPipeline 无法保存原图exif信息的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前遇到一个需求，就是需要爬取并下载网站的图片，并带有图片的exif信息，使用了Scrapy， ImagesPipeline 这个处理的pipeline，但是后来发现，这个类有一个大坑，如果是需要下载原图，这个类默认会对图片进行处理，从而覆盖掉原来图片的exif信息，
Scrapy 中 ImagesPipeline 这个类，有一个方法
def convert_image(self, image, size=None): if image.format == 'PNG' and image.mode == 'RGBA': background = self._Image.new('RGBA', image.size, (255, 255, 255)) background.paste(image, image) image = background.convert('RGB') elif image.mode == 'P': image = image.convert("RGBA") background = self._Image.new('RGBA', image.size, (255, 255, 255)) background.paste(image, image) image = background.convert('RGB') elif image.mode != 'RGB': image = image.convert('RGB') if size: image = image.copy() image.thumbnail(size, self._Image.ANTIALIAS) buf = BytesIO() image.save(buf, 'JPEG') return image, buf 会对图片进行一些处理，我就是因为这个坑找了一天，后来不使用这个类自己写的pipeline
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b83a7c13eeee57f11dd3e69051c591a/" rel="bookmark">
			微信小程序vantui安装及使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用npm安装vantui 1在文件终端打开cmd
2输入npm init进行初始化项目，中途一直回车确认即可
出现is this ok？就代表初始化完成
3输入npm i @vant/weapp -S --production开始下载资源
4修改相关配置
4.1将 app.json 中的 "style": "v2" 去除
4.2 修改 project.config.json添加配置
"packNpmRelationList": [ { "packageJsonPath": "./package.json", "miniprogramNpmDistDir": "./miniprogram/" } ] 5点击工具选择构建npm包
6使用，引入组件在app.json文件中
"usingComponents": { "van-button": "@vant/weapp/button/index" } 对应wxml
&lt;van-button type="primary"&gt;按钮&lt;/van-button&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43331a3aa5614ac5dcd0c348645280af/" rel="bookmark">
			DS18B20高精度温度传感器，使用介绍【400字】【原创】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 实物用途特点功能介绍温度转换规则配置寄存器 实物 ds18b20高精度温度传感器（小数点后四位）
1=VDO，2=DO，3=GND
用途 单总线通讯，三个引脚，中间是数据总线，发送接收一根线，体积小，精度高
特点 功能介绍 1宽电压供电，寄生电源是只接两根线，不接vcc线，数据线供电（说明18b20
功耗很低）和地线
2单线接口技术，只需要一条线，全双工
3可多个18b20并联并接在同一根大总线实现多点组网测试，这时每个18b20都有一个编号，实现准确读取某一个点的温度值
4使用时不需要复杂外设电路，本身是一个三极管封装，51需要加上拉电阻，而32内部可设置上拉，内部上拉模式，有时温度读取不准就是没有上拉电阻
5可读取负温度，精度可编程，可实现小数点后四位9 （1）10（2） 11 （3）12（4）
6具备校验能力
7芯片接反时，不会损坏
8具有报警功能（配置一些参数）（一般不用刘洋没用过）
9 64位序列号
10 48位就是前面提到的编号（身份码） 可实现并网分辨，校验就是系列码+序列码是否=crc
11 51单片机也可使用18b20 上电默认12位 两个字节就是16位（刚好保存12位），延时750 不启动保持低功耗状态
温度转换规则 取反加一取反加一 * 0.0625
配置寄存器 ds18b20市面上普遍使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d357cf9134ef672ce37d530c4c5434/" rel="bookmark">
			20个 Git 命令玩转版本控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要在团队中处理代码时有效协作并跟踪更改，版本控制发挥着至关重要的作用。Git 是一个版本控制系统，可以帮助开发人员跟踪修订、识别文件版本，并在必要的时候恢复旧版本。Git 对于有一定编程经验的用户来说虽然不算太难，但是想要玩转一些高级功能也并不是件容易的事情。在这篇文章中，我将向你展示一些最实用的 Git 命令，手把手教你成为 Git 专家。
1. git config git config 是你需要熟知的基本 Git 命令之一。该命令有助于设置电子邮件、用户名、文件格式、首选文件算法和许多其他属性的配置值。命令示例如下：
# configure the user which will be used by Git # this should be not an acronym but your full name $ git config --global user.name "Firstname Lastname" # configure the email address $ git config --global user.email "your.email@example.org" 2. git init git init 是最常用的 Git 命令之一，用于适合初始化 Git 仓库（创建新仓库）。.git 文件夹通常保持隐藏状态，如果是 Windows，需要在查看中选择“隐藏的项目”。对于 Linux，可以使用“ls –a”命令查看.git 目录。建议任何人都不要篡改 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4d357cf9134ef672ce37d530c4c5434/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e70cb5114e84c275ddf8d2aebb15c1/" rel="bookmark">
			【Linux】企业实战项目rsync&#43;inotify实现实时同步（inotify安装及介绍、rsync &#43; inotify 实现实时同步、rsync &#43; inotify实现开机自启 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、企业实战项目rsync+inotify实现实时同步 rsync与传统的cp、tar备份方式相比，rsync具有安全性高、备份迅速、支持增量备份等优点，通过rsync可以解决对实时性要求不高的数据备份需求，例如定期的备份文件服务器数据到远端服务器，对本地磁盘定期做数据镜像等。
随着应用系统规模的不断扩大，对数据的安全性和可靠性也提出的更好的要求，rsync在高端业务系统中也逐渐暴露出了很多不足，首先，rsync同步数据时，需要扫描所有文件后进行比对，进行差量传输。如果文件数量达到了百万甚至千万量级，扫描所有文件将是非常耗时的。而且正在发生变化的往往是其中很少的一部分，这是非常低效的方式。其次，rsync不能实时的去监测、同步数据，虽然它可以通过linux守护进程的方式进行触发同步，但是两次触发动作一定会有时间差，这样就导致了服务端和客户端数据可能出现不一致，无法在应用故障时完全的恢复数据。基于以上原因，rsync+inotify组合出现了
何为 inotify Inotify是一种强大的、细粒度的、异步的文件系统事件监控机制，linux内核从2.6.13起，加入了Inotify支持，通过Inotify可以监控文件系统中添加、删除，修改、移动等各种细微事件，利用这个内核接口，第三方软件就可以监控文件系统下文件的各种变化情况，而inotify-tools就是这样的一个第三方软件。
Inotify 监控文件系统操作，比如读取、写入和创建，基于事件驱动，可以做到对事件的实时响应，高效，而且没有轮询造成的系统资源消耗。
在前面有讲到，rsync可以实现触发式的文件同步，但是通过crontab守护进程方式进行触发，同步的数据和实际数据会有差异，而inotify可以监控文件系统的各种变化，当文件有任何变动时，就触发rsync同步，这样刚好解决了同步数据的实时性问题。
inotify能监控非常多的文件系统事件，通过监控这些事件来监控文件是否发生变更，然后通过rsync来更新发生变更的文件 inotify安装及介绍 安装 ①检查当前系统内核是否支持 inotify
方法一：
若内核版本大于 2.6.13 则支持；
uname -r 方法二：
若输出 CONFIG_INOTIFY_USER=y，则支持；
grep INOTIFY_USER /boot/config-$(uname -r) ②安装
yum install epel-release -y yum install inotify-tools -y 命令 inotify-tools 包含了两个命令：inotifywait 与 inotifywatch。
inotifywait：在被监控的文件或目录上等待特定文件系统事件发生，执行后处于阻塞状态，适合在shell脚本中使用。
阻塞状态 (Blocked):阻塞状态是线程因为某种原因放弃CPU的使用权，暂时停止运行。 inotifywatch：用于收集文件系统的统计数据，例如发生了多少次 inotify 事件，某文件被访问了多少次等等。
内核参数 /proc/sys/fs/inotify/ 目录下包含三个文件，分别设置 inotify 相关的三个内核参数。
max_queued_events：inotify 事件队列可容纳的事件数量，超出的事件被丢弃，但会触发队列溢出Q_OVERFLOW事件。
max_user_instances：每个用户可运行的 inotifywait 或 inotifywatch 命令的进程数。
max_user_watches：每个 inotifywait 或 inotifywatch 命令可以监控的文件数量。如果监控的文件数目巨大，需要根据情况适当增加此值。
默认设置：
事件 inotify 监控的文件系统事件：
access：文件被访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e70cb5114e84c275ddf8d2aebb15c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/970144a8aa4f09aff269cc5eb8a9e19f/" rel="bookmark">
			信噪比的概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 什么是信噪比 在无线通信环境中，为了获得更好的收发性能，那么无线设备需要从监听的信号提取出该设备需要的合法信息， 并忽略掉频谱中的任何背景信号， 该概念称之为信噪比(Signal Noise Rate, SNR)。
信噪比定义为接收到的无线信号与噪底之间的差值，如下图所示，如果无线设备接收到无线信号大小是-75dBm，噪底是-90dBm，那么接收到的有效信号强度是15dB，也即SNR是15dB。
接收到的信号离噪底越远，信号质量越好。接近噪底的信号可能会变噪声淹没，导致接收到的信号无法解析，最终导致发送端到接收端数据的重传， 导致无线系统收发性能。
例如， 对于802.11协议， SNR=30dB， 可能使用11g的24M
SNR=15dB，可能只用使能11g的6M
参考 Signal-to-Noise Ratio (SNR) and Wireless Signal Strengthdefine_SNR_values 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2548531048579abfbfe6db16540a3c51/" rel="bookmark">
			C#获取文件夹下的所有文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、获得当前运行程序的路径
string rootPath = Directory.GetCurrentDirectory(); 2、获得该文件夹下的文件，返回类型为FileInfo
string path=@"X:\XXX\XX"; DirectoryInfo root = new DirectoryInfo(path); FileInfo[] files=root.GetFiles(); 3、获得该文件夹下的子目录，返回类型为DirectoryInfo
string path=@"X:\XXX\XX"; DirectoryInfo root = new DirectoryInfo(path); DirctoryInfo[] dics=root.GetDirectories(); 4、获得文件夹名​​​​​​​
string path=@"X:\XXX\XX"; DirectoryInfo root = new DirectoryInfo(path); string dicName=root.Name; 5、获得文件夹完整的路径名​​​​​​​
string path=@"X:\XXX\XX"; DirectoryInfo root = new DirectoryInfo(path); string dicName=root.FullName; 6、获取文件的Name和FullName
string path=@"X:\XXX\XX"; DirectoryInfo root = new DirectoryInfo(path); foreach (FileInfo f in root.GetFiles()) { string name=f.Name; string fullName=f.FullName; } #只获取目录下一级的文件夹与文件 String path = @"X:\xxx\xxx"; //第一种方法 string[] files = Directory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2548531048579abfbfe6db16540a3c51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e82a6422a1da4042b74fe0754aec658/" rel="bookmark">
			基于opencv（c&#43;&#43;）和matlab的usb双目相机标定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人由于实际需要入手了一款双目免驱usb摄像头，因为需要做深度估计，故需要标定内参，双目相机标定主要是为了获得摄像头的内参(f,1/dx,1/dy,cx,cy)、畸变参数(k1,k2,k3,p1,p1)和外参(R,t)，用于接下来的双目校正和深度图生成。
具体标定步骤如下：
一、获得棋盘格图像
大多数双目标定都是用棋盘格进行标定，如下所示：
这里有一段c++代码，用于生成棋盘格图像：
//双目采集图像程序 #include&lt;opencv2/opencv.hpp&gt; #include&lt;stdlib.h&gt; using namespace cv; using namespace std; #define WIDTH 1280 //双目分辨率，根据自己摄像头型号选择数值 #define HEIGHT 480 //双目分辨率，根据自己摄像头型号选择数值 int main(int argc, char *argv[]) { VideoCapture capture(0); if (!capture.isOpened()) { cout&lt;&lt;"can not open the camera"&lt;&lt;endl; cin.get(); exit(1); } capture.set(CV_CAP_PROP_FRAME_WIDTH, WIDTH); capture.set(CV_CAP_PROP_FRAME_HEIGHT, HEIGHT); string left_road; string right_road; int num = 0; int count = 0; Rect leftRect(0, 0, WIDTH/2, HEIGHT); //创建一个Rect框，属于cv中的类，四个参数代表x,y,width,height Rect rightRect(WIDTH/2, 0, WIDTH/2, HEIGHT); while (1) { Mat frame; capture&gt;&gt;frame; //载入图像 if (frame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e82a6422a1da4042b74fe0754aec658/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97244e4e2501d5cf911a0c7e465b383d/" rel="bookmark">
			数学建模拓展内容：卡方检验和Fisher精确性检验（附有SPSS使用步骤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卡方检验和Fisher精确性检验 卡方拟合度检验卡方独立性检验卡方检验的前提假设Fisher精确性检验 卡方拟合度检验 卡方拟合度检验概要：卡方拟合度检验也被称为单因素卡方检验，用于检验一个分类变量的预期频率和观察到的频率之间是否存在显著差异。
卡方拟合度检验举例分析：例如将一个六个面的骰子投掷36次可以得到不同点数的出现频数。在正常情况下，各个点数的出现频率应该大致相等，如果通过卡方拟合度检验判断实际频率和预期频率确实存在显著差异，那么我们就有理由认为骰子本身存在问题。
卡方独立性检验 卡方独立性检验概要：卡方独立性检验也被称为双因素卡方检验，用于检验两个类别变量之间是否相互独立。
交叉表：
交叉表作用：当同一个个体可以被以两种划分方式分为两种类别时，可以通过交叉表进行直观的类别判定。交叉表样例：可以将一个总体人群中的人按照性别分为男性和女性，所有人按照啤酒嗜好又可以分为喜欢淡啤酒、喜欢普通啤酒、喜欢黑啤酒三类。也就是说，对于原始人群，可以分别按照两种方式进行分类，而交叉表就是综合两种分类结果的直观展示，原始数据和对应的交叉表如下所示：（表格中的性别和啤酒嗜好都已经转换为了虚拟变量）
使用SPSS绘制交叉表和进行卡方独立性检验：
导入原始数据后依次点击：数据→个案加权。
选择个案加权系数，将频数作为个案加权系数后点击确定。
依次点击：分析→描述统计→交叉表。
选择两个指定的类别变量作为交叉表的行和列，并在窗口左下角勾选显示簇状条形图。
打开精确窗口，选择精确。
打开统计窗口，选择卡方。
单击确定。
SPSS进行卡方独立性检验的结果分析：
交叉表：
卡方独立性检验结果：
这里的渐近显著性和精确显著性即对应的P值，一般看渐近显著性。如果渐近显著性的值小于给定的显著性水平，那么就认为两个分类变量之间不是相互独立的。
一般只需要判定皮尔逊卡方结果的渐近显著性即可。在大样本情况下，皮尔逊卡方和似然比检验的结果会比较接近。条形图：
卡方检验的前提假设 每个观测值都会落入一个，且只能落入一个类别中。每个观测值之间相互独立。卡方独立性检验的适用情况：最好在样本个数大于40，且每个类别的期望频数都大于等于5时才使用卡方独立性检验。 Fisher精确性检验 Fisher精确性检验概述：Fisher精确性检验的作用与卡方独立性检验类似，但是适用于小样本的情况，在卡方独立性检验不满足适用条件时可以采用Fisher精确性检验。
Fisher精确性检验的适用情况：超过20%的交叉表元素的期望值小于5或者至少存在一个交叉表元素的期望值小于1。
SPSS进行Fisher精确性检验的结果：
Fisher精确性检验的结果也在卡方独立性检验的结果表格中。表格的第三行费希尔精确性检验即为进行Fisher精确性检验的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d41d205bf9f52dc42f4e6a9dbcd1ff36/" rel="bookmark">
			R语言用加性多元线性回归、随机森林、弹性网络模型预测鲍鱼年龄和可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近我们被客户要求撰写关于鲍鱼年龄的研究报告，包括一些图形和统计输出。
视频：从决策树到随机森林：R语言信用卡违约分析信贷数据实例 从决策树到随机森林：R语言信用卡违约分析信贷数据实例
，时长10:11
介绍 鲍鱼是一种贝类，在世界许多地方都被视为美味佳肴。铁和泛酸的极好来源，是澳大利亚、美国和东亚的营养食品资源和农业。100 克鲍鱼可提供超过 20% 的每日推荐摄入量。鲍鱼的经济价值与其年龄呈正相关。因此，准确检测鲍鱼的年龄对于养殖者和消费者确定其价格非常重要。
然而，目前决定年龄的技术是相当昂贵且低效的。
养殖者通常会切开贝壳并通过显微镜计算环数来估计鲍鱼的年龄。因此，判断鲍鱼的年龄很困难，主要是因为它们的大小不仅取决于它们的年龄，还取决于食物的供应情况。而且，鲍鱼有时会形成所谓的“发育不良”种群，其生长特征与其他鲍鱼种群非常不同。这种复杂的方法增加了成本并限制了其普及。我们在这份报告中的目标是找出最好的指标来预测鲍鱼的环，然后是鲍鱼的年龄。
数据集 背景介绍 这个数据集来自一项原始（非机器学习）研究。
数据集可在UCI机器学习资源库网站上找到。
有30多篇论文引用了这个数据集。
从原始数据中删除了有缺失值的例子（大多数预测值缺失），连续值的范围被缩放用于NA（通过除以200）。在本分析中，我们将通过乘以200的方式将这些变量恢复到其原始形式。
数据集中的观测值总数：4176
数据集中的变量总数：8个
给出的是属性名称、属性类型、测量单位和简要描述。环数是要预测的值，是一个连续值。
变量列表 变量数据类型测量描述性别分类（因子）M、F 和 I（婴儿）长度连续毫米最长壳测量直径连续毫米垂直长度高度连续毫米带壳肉整体重量连续克整只鲍鱼去壳重量连续克肉的重量内脏重量连续克肠道重量外壳重量连续克晒干后鲍鱼的环连续+1.5 给出以年为单位的年龄 下面是分析
“使用回归预测鲍鱼的年龄” 方法 #加载所有必要的软件包 library(readr) library(dplyr) library(car) library(lmtest) library(ggplot2) 数据汇总与统计 readcsv("abalone.csv") balne$Sx &lt;- s.acor(aalne$Sex) kale(abaoe[1:10,],fomt 'madw') 分类变量 数值变量 看一下数据集的摘要，我们可以看到，数据在雄性、雌性和婴儿这三个因素水平之间的分布是相当均匀的。
此外，我们还看到有四种不同的重量测量方法，即：全重、去壳重、内脏重和壳重。全重是其他重量预测指标与剥壳过程中损失的未知水/血质量的线性函数。我们还观察到，预测器高度的最小值是0。
因变量 因果变量Rings包含在数据集中。它被测量为切割和检查鲍鱼后观察到的环的数量。虽然它不能直接表示一个给定的鲍鱼的年龄，但它可以或多或少完美地确定它。一个鲍鱼的年龄等于环数+1.5。由于这种关系是可靠的，环数将被视为因变量。数据中测量的环数从1到29不等，大多数鲍鱼的环数在5到15之间。分布也有轻微的正偏斜，但没有问题。(见下面的图)
配对图 pairs(aalone, es(colour =Sex, aph = 0.) 从配对图中观察到的情况。
首先要注意的是数据的高度相关性。例如，直径和长度之间的相关性非常高（约98.7）。
同样，Whole_weight似乎与其他重量预测因子高度相关，是Shucked_weight、Viscera_weight和Shell_weight之和。
其次，预测因子Sex的分布与所有其他预测因子的因子水平值雌性和雄性非常相似。
对于雌性和雄性的因子水平，分布的形状也是非常相似的。
我们可以考虑重新定义这一特征，将性别定义为婴儿与非婴儿（其中非婴儿=雌性和雄性都是）。
大多数的abalones环都在5到15之间。
数据质量 增加变量。我们将更新鲍鱼数据集，创建名为 "婴儿 "的新变量，它的值将基于性别变量的原始值。当性别变量为I时，它的值为I，否则为NI。
我们还观察到，预测高度的最小值是0，实际上这是不可能的，我们将调查这些观察结果，仔细研究。
##高度为0的数据质量检查 kable(abloe[aban$Height == 0,]) 我们看到，有两个观测值的高度可能没有被正确记录，因为其他预测因子似乎都有有效的值。另外，如果我们看一下预测因子Whole_weight，我们会发现这些值与其他观察值相比真的很小，而且低于第一个四分法。这告诉我们，这可能不是一个数据错误，因此我们不能将这些数据从我们的数据集中排除。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d41d205bf9f52dc42f4e6a9dbcd1ff36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e86a1ad2de2acfc3d3f430b3914791/" rel="bookmark">
			C# 处理内存泄漏问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 处理内存泄漏问题 背景什么是 CLR？什么是内存泄漏？如何知道产生了内存泄漏？ 调试方法什么是调试器？调试的原理调试示例 内存泄漏检测方法：SOSDumpHeap 背景 参考链接：nvestigating .NET Memory Management and Garbage Collection
在 CLR 中，GC（垃圾收集器，Garbage Collection） 管理一切内存。之所以会有内存泄漏，是因为 GC 不能总是正确的释放内存。本文最后将介绍如何使用 SOS（Son of Strike）来检查内存和对象分配
什么是 CLR？ 参考：CLR
CLR（Common Language Runtime）是公共语言运行时环境
.NET 提供了一个称为公共语言运行时的运行时环境，可以编写利用托管执行环境的代码。 使用面向运行时的语言编译器开发的代码称为托管代码。
简而言之，就是类似于 Java 虚拟机，你写的代码运行在这上面，你申请的内存，释放的内存都由 CLR 进行管理。
托管代码具有许多优点
垃圾回收。性能改进能够轻松使用用其他语言开发的组件类库提供的可扩展类型语言功能，如面向对象的编程的继承、接口和重载允许创建多线程的可缩放应用程序的显式自由线程处理支持结构化异常处理支持自定义特性支持使用委托取代函数指针，从而增强了类型安全和安全性 什么是内存泄漏？ 简单来说，就是在分配内存时，无论出于何种原因，你的程序运行后都不会释放该内存，于是就导致了内存泄漏。 在.NET语言中，您可以通过创建对象来分配内存，并通过允许对该对象的引用出现范围来释放内存。例如：
void MethodName() { Object o = new Object(); //Create a new Object and store a reference to it as o DoSomethingWith(o); //Use the new Object by passing the reference to o o = null; //Lose the reference to the new Object, it is now eligible for freeing } //o is now out of scope so can be freed 当 o 在作用域范围内，GC 可以检查对象是否有任何引用。 如果没有什么引用对象，则可以释放。 如果 DoSomethingWith 方法存储对象 o 的引用，那么当 GC 检查是否正在使用时，仍然会有引用，因此它将无法释放内存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61e86a1ad2de2acfc3d3f430b3914791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5f72dca2540de540a4988ede2e67dc9/" rel="bookmark">
			Flutter Windows端解决应用多次被打开问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter 开发Windows端程序时，是默认可以多次打开同一个应用的，有时候需要限制只能打开一次，再次点击快捷方式打开之前已经打开的页面。
处理方式如下：找到windows/runner/main.cpp
原代码如下：
#include &lt;flutter/dart_project.h&gt; #include &lt;flutter/flutter_view_controller.h&gt; #include &lt;windows.h&gt; #include "flutter_window.h" #include "utils.h" int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev, _In_ wchar_t *command_line, _In_ int show_command) { // Attach to console when present (e.g., 'flutter run') or create a // new console when running with a debugger. if (!::AttachConsole(ATTACH_PARENT_PROCESS) &amp;&amp; ::IsDebuggerPresent()) { CreateAndAttachConsole(); } // Initialize COM, so that it is available for use in the library and/or // plugins.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5f72dca2540de540a4988ede2e67dc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d71fdb0502537574036bc99f038688a/" rel="bookmark">
			【英语七下】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一,七下单词；
Unit 1 Can you play the guitar
Unit 2 What time do you go to school
Unit 3 How do you get to school
Unit 4 Don’t eat in class
Unit 5 What do you like pandas
Unit 6 I’m watching TV
Unit 7 It's raining!
Unit 8 Is there a post office near here?
Unit 9 What does he look like?
Unit 10 I'd like some noodles.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d71fdb0502537574036bc99f038688a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce31094ec8d8ca5c94d201fda83f43ab/" rel="bookmark">
			从零编写linux0.11 - 第九章 文件系统（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从零编写linux0.11 - 第九章 文件系统（一） 编程环境：Ubuntu 20.04、gcc-9.4.0
代码仓库：https://gitee.com/AprilSloan/linux0.11-project
linux0.11源码下载（不能直接编译，需进行修改）
本章目标 完成文件系统的部分功能。能够读取文件，打印输出。
1.qemu 接下来的章节将使用 qemu 模拟器运行程序。为什么使用 qemu 而不使用 bochs 呢？
1.bochs 无法看 C 语言源码。只看汇编代码调试 C 语言程序还是挺麻烦的。使用 gdb-dashboard 插件后，可以同时查看 C 语言源码、编译后的汇编代码和寄存器，十分不错，就是看内存有点麻烦。
2.bochs 运行程序出错。bochs 读取软盘扇区时会发生奇怪的错误，让我百思不得其解，同样的代码在 qemu 上却能运行。
综上，最终决定使用 qemu。不过 qemu 也有些问题，它没法调试 main 函数之前的汇编代码。
首先，我们需要安装 qemu。运行下面的指令。
sudo apt-get install gcc-multilib qemu-system-x86 接下来要修改 Makefile。
CC	=gcc CFLAGS	=-Wall -g -O -m32 -fomit-frame-pointer -fno-stack-protector -no-pie -fno-pic -Iinclude all: run Image: clean mkimg boot/bootsect.bin boot/setup.bin system objcopy -O binary -R .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce31094ec8d8ca5c94d201fda83f43ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3edb2a381be94d597d2f91d29acbed56/" rel="bookmark">
			macOs安装mysql5.7，并修改字符问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面：用于个人记录，备忘，旁人慎用
去官网下载dmg包
注意有的版本是没有dmg安装包的
安装到本地
安装的时候如果报了隐私安全错误，记得打开
这里面，放开拦截，然后就是无脑点下一步。
但是要记得完成的时候有个对话框有默认密码
这个可以保存一下，后面会用得到配置环境变量
安装成功后，你使用mysql -V 仍然没有任何反应 ，是因为服务的脚本命令还没有写进path路径去
要在.bash_profile 和.zshrc文件中加入 export PATH=$PATH:/usr/local/mysql/bin export PATH=$PATH:/usr/local/mysql/support-files 然后source以下 就可以使用 mysql -V 查看版本了
修改密码 开启mysql服务命令
sudo mysql.server start
mysql -uroot -p
输入刚才复制的
set password = password(‘123456’);
sudo mysql.server stop (关闭命令)
解决字符乱码问题 mysql&gt; show variables like 'character%'; +--------------------------+-----------------------------------------------------------+ | Variable_name | Value | +--------------------------+-----------------------------------------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | latin1 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | latin1 | | character_set_system | utf8 | | character_sets_dir | /usr/local/mysql-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3edb2a381be94d597d2f91d29acbed56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61c2259a92dcb431c7c3019f1b0dc427/" rel="bookmark">
			vitepress 最详细教程之开始使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始使用 文章目录 开始使用写在前面创建项目安装 vitepress启动项目vitepress 的目录结构写在最后 写在前面 关于为什么要写这个教程，原因有二，其一是因为 vitepress 才刚出来，中文版的教程不详细，英文版的教程可能大部分人看起来比较麻烦；其二是因为作者最近刚用 vitepress 搭建了一个组件库展示网站，就想趁此机会写个文档吧 😄！
以后可能会出开发自己组件库的教程，如果有兴趣可以私信我，人多的话可能就会提前安排上 🎉，目前文档已在我的 GitHub 仓库了，是我参加青训营的团队一起完成的，但是文档的搭建是我一个人负责的，悄悄夸一下自己 👍。
如果大家想看看效果，其实我没有部署到 GitHub 上，这个以后也会教大家，现在使用方法如下：
首先去克隆我的组件库项目，喜欢的话可以 Star 🌟 一下哈 $ git clone https://github.com/ox4f5da2/seven-bit-docs.git 然后安装依赖 $ pnpm i 对了如果没有安装 pnpm 的可以全局安装一下，运行如下命令即可：
$ npm i pnpm -g 如果提示说无权限写入文件夹的话那就加 sudo 安装即可
然后运行命令启动项目 $ pnpm run docs:dev 最后打开链接应该就能看到了，希望大家喜欢这个文档网站 顺便说一下，我还写了一个刷算法题的网站，都是用 js 写的，网址在这里，想看的可以看看，这是用 vuepress 写的，如果您有 vuepress 基础那么会非常容易上手，好了废话不多说，接下来就介绍怎么使用 vitepress。
创建项目 首先选一个自己喜欢的文件及，然后在这个文件夹里创建一个 vitepress 项目文件夹，自己想叫啥叫啥，然后进入这个文件夹即可，如果大家觉得麻烦可以进入文件夹后运行如下命令：
$ mkdir vitepress &amp;&amp; cd vitepress 然后使用自己喜欢的包管理方式，可以是 npm、yarn、pnpm，初始化项目即可：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61c2259a92dcb431c7c3019f1b0dc427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/143de0a97cecb5727d754ab94a756e75/" rel="bookmark">
			vitepress 最详细教程之Home Page的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Home Page 文章目录 Home Page简单介绍Home Page 的基本使用Hero 部分标题部分图片部分按钮部分 Features 部分写在最后 简单介绍 Home Page 页面是文档的主页面，拥有一个好看的主页可以大大吸引用户的注意力，增加自己文档网站的流量，接下来的内容就是介绍如何拥有一个好看的主页。
下图这是作者自己配置的组件库的主页，大家觉得不错可以慢慢看下去，看完教程后我觉得你一定也可以拥有比这更好看的主页 👍。
Home Page 的基本使用 我们在上一节已经介绍了文档的大致目录结构，如果没看过的可以在vitepress 最详细教程之开始使用的目录结构部分查看。
目前效果如下：
首先我们需要在 index.md 中把原有内容清空，然后写入如下内容：
--- layout: home --- 这样我们就开启了首页的布局配置，然而，仅此选项不会有多大作用，你可以通过设置其他选项（如 hero 和 features）向主页添加几个不同的预模板 sections。
Hero 部分 Hero 部分位于主页顶部，下面是如何配置 Hero 部分。
标题部分 layout: home hero: name: VitePress text: Vite &amp; Vue powered static site generator. tagline: Lorem ipsum... 其中：
name 是文档标题text 是类似于文档副标题tagline 是文档标语
现在不清楚不要紧，文章会在最后列出详细注释让你们明白每个配置的作用
现在页面应该是这样的： 不用奇怪为什么没加配置还会出现两个按钮和图片，即使你不写也会按默认配置来的
图片部分 我们在上述例子中可以发现，我们右侧的图片不显示，那么本节教大家如何配置图片。
hero: image: src: /logo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/143de0a97cecb5727d754ab94a756e75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84fc269affccf88ab85818e170dd9335/" rel="bookmark">
			C语言柔性数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 什么是柔性数组柔性数组的使用 什么是柔性数组 柔性数组是在C99中定义的
结构体的最后一个元素允许是未知大小的数组，这就叫柔性书组
柔性数组的长度可以写成0，也可以不规定数组长度
下面两种写法都是正确的
struct S { int i; int a[0];//柔性数组成员 } struct S { int i; int a[];//柔性数组成员 } 结构体中的柔性数组成员前面至少有一个其他成员sizeof返回的这种结构体的大小不包括柔性数组的大小包含柔性数组成员的结构体用malloc ()函数进行内存的动态分配，并且分配的内存应该大于结构的大
小，以适应柔性数组的预期大小。 柔性数组的使用 typedef struct S { int i; char c[];//c是柔性数组 }S; int main() { S* p = (S*)malloc(sizeof(S) + 10 * sizeof(char)); if (p == NULL) { perror("malloc"); return 1; } p-&gt;i = 10; for (int i = 0; i &lt; 10; i++) { p-&gt;c[i] = 'a'; } free(p); p = NULL; return 0; } 在malloc开辟空间时，开辟空间大小为sizeof(S) + 10 * sizeof(char)，前面的sizeof(S)其实是表示结构体中int i的大小，后面则是给c开辟了10个字节大小的连续空间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84fc269affccf88ab85818e170dd9335/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e3d495cf8e5103e1064f5fc734f1f48/" rel="bookmark">
			python编写神经网络算法代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用 Python 编写神经网络算法代码需要使用一些深度学习库，例如 TensorFlow、PyTorch 等。这些库提供了大量的模块和工具，方便用户编写和训练神经网络。
以下是一个使用 TensorFlow 实现的简单的神经网络代码示例：
import tensorflowas tf # 定义输入数据 x = tf.placeholder(tf.float32, [None, 784]) # 定义权重和偏置项 W = tf.Variable(tf.zeros([784, 10])) b = tf.Variable(tf.zeros([10])) # 定义输出数据 y = t 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/159c29db988d4ef03009b9876cf093f0/" rel="bookmark">
			Pytorch 实现中文字的任意旋转的准确识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Pytorch 中实现中文字任意旋转的准确识别，需要使用一些图像处理技术和计算机视觉方法。
首先，可以使用预处理技术对图像进行预处理，以便对图像中的字符进行分割和预处理。然后，可以使用计算机视觉方法，如二值化和形态学处理，来识别图像中的字符。
接下来，可以使用卷积神经网络 (CNN) 对识别的字符进行分类。在训练 CNN 模型之前，需要将图像数据增广，以便模型能够对任意旋转的字符进行识别。这可以通过随机旋转、缩放、平移等方式来实现。
最后，可以在训练好的 CNN 模型上使用测试数据，评估识别准确率。如果准确率不理想，可以对模型进行进一步优化，如增加更多层或更改网络结构。
总的来说，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee51c20324395700453483f32e2f1066/" rel="bookmark">
			malloc函数的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		malloc与new都可以分配空间，但却有很大的差别下面我将来介绍一下malloc函数。
定义 malloc动态内存分配函数，用于申请一块连续的指定大小的内存块区域以void*类型返回分配的内存区域地址。
malloc函数是一种分配长度为num_bytes字节的内存块的函数，可以向系统申请分配指定size个字节的内存空间。malloc的全称是memory allocation（动态内存分配），当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存。返回类型是 void* 类型。void* 表示未确定类型的指针。C,C++规定，void* 类型可以通过类型转换强制转换为任何其它类型的指针
malloc函数原型 void *malloc(int size); malloc 向系统申请分配指定size个字节的内存空间。返回类型是 void* 类型。void* 表示未确定类型的指针。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。
malloc的头文件 #include&lt;malloc.h&gt; malloc函数返回值 如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。
malloc与new的区别 从函数声明上可以看出。malloc 和 new 至少有两个不同: new 返回指定类型的指针，并且可以自动计算所需要大小。而 malloc 则必须由我们计算要字节数，并且在返回后强行转换为实际类型的指针。　#include&lt;iostream&gt; #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int *p=new int;//new自动计算大小 int *str=(int *)malloc(sizeof(int));//自己计算大小 return 0; } malloc为数组分配空间 #include&lt;iostream&gt; #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int n=10; int *arr=(int *)malloc(sizeof(int)*n); return 0; } malloc注意事项 关于malloc所开辟空间类型：malloc只开辟空间，不进行类型检查，只是在使用的时候进行类型的强转。
mallo函数返回的实际是一个无类型指针，必须在其前面加上指针类型强制转换才可以使用
指针自身 = (指针类型*）malloc（sizeof（指针类型）*数据数量）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee51c20324395700453483f32e2f1066/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb0d84b6c0c480e98f1660f7470662b9/" rel="bookmark">
			Win10系统Chrome浏览器启用独立显卡提升3D程序渲染性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Windows系统中为何你的浏览器卡顿？尤其是运行web端3D程序的时候卡顿，有可能没有开启硬件加速。没开启硬件加速，只能使用集成显卡或者模拟程序，就会卡顿、慢。而且会导致3D程序中一些细节的渲染效果会花掉，例如阴影、雾、灯光等，会出现块状或者条状的显示问题。
下面这张图是没有开启硬件加速，导致阴影显示问题：
正确的效果如下图示：
源程序可以在这里打开：Vox APP
注：因为颜色和灯光是随机值，所以上面两张图有差异。但不影响阴影的差异对比。
下面逐步讲解如何开启硬件加速。
开启浏览器自身的硬件加速设置方式如下图所示:
如果硬开启了，那可能是使用了性能比较低的集成显卡。
如果你的电脑有集成显卡也有独立显卡，那么浏览器默认是系统自动设定，大概率是使用集成显卡而不是独立显卡。
集成显卡性能差，看视频和玩3D应用(或游戏)会卡顿不流畅，而且会占用比较多的CPU消耗。
可以用如下的办法让浏览器启用独立显卡(以Chrome谷歌浏览器为例), 还是一步一步上图说明吧。
进入系统设置之前，先确认显示器高清线已经正常插到独立显卡，正常插入情况如下图:
第一步:
第二步:
第三步:
第四步(输入Chrome程序路径 C:\Program Files\Google\Chrome\Application, 按下回车键):
第五步:
最后一步:
至此，重启浏览器就能感受独立显卡的性能了。
切记不能选择: 让Windows决定
看看我的设置之后的GPU状态截图:
在多说依一句: 记得开启浏览器自身的硬件加速设置，如下图(Chrome浏览器)：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efc58d6182d683768e84354a8b4424fa/" rel="bookmark">
			Python获取搜索引擎结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 想快速获取各个高校的博士招生网站，于是通过python先获取出有可能包含高校博士招生网站的URL，然后通过人为筛选得到了想要的招生网站（注意，并非直接爬取，是间接获取的）。
整理了一份网站名单，以方便查阅各大高校博士招生信息。
整理好的博客在这里：
全国各大985/211博士招生网站
全国各大985/211博士招生网站
Python获取 1. 根据搜索引擎关键字获取内容 常见搜索引擎搜索格式[1]：
百度搜索引擎：
http://www.baidu.com.cn/s?wd=’ 关键词’&amp;pn=‘分页’。
wd是搜索的关键词，pn是分页的页面，由于百度搜索每页的结果是十个（最上面的可能是广告推广，不是搜索结果），所以pn=0是第一页，第二页是pn=10…
例如https://www.baidu.com/s?wd=python&amp;pn=0，得到的是关于python的第一页搜索结果。必应搜索引擎：
http://global.bing.com/search?q=‘关键词’搜狗搜索引擎
https://www.sogou.com/web?query=‘关键词’360搜索引擎
https://www.so.com/s?q=‘关键词’ 这里，我采用必应搜索引擎。比如，我想搜索北京大学的博士招生信息，对应搜索指令为http://global.bing.com/search?q=北京大学+博士招生
所以现在需要解决的第一个问题就是如何利用python获取搜索引擎的搜索结果。
参考了如下文章后[2]，修改了自己的代码，实现了如下功能：自定义搜索关键字，获取搜索结果第一页结果，输出结果网页的标题及其对应URL到文件中，等待后续处理文件。
代码如下：
import re import requests from lxml.html import etree import time # 重定向输出结果到./data/original_data.txt import sys sys.stdout = open('./data/original_data.txt', 'w', encoding='utf-8') def get_bing_url(keywords): keywords = keywords.strip('\n') bing_url = re.sub(r'^', 'https://cn.bing.com/search?q=', keywords) bing_url = re.sub(r'\s', '+', bing_url) return bing_url if __name__ == '__main__': # base_keys是读取基础的搜索关键字，这里是“+博士招生+2023”， 你可以自定义其他搜索关键字，加号表示空格，即搜索结果中需要包含的关键字 base_keys = open('./data/base.txt', 'r', encoding='utf-8') for key in base_keys: # added_keys是读取附加的搜索关键字，比如“北京大学” added_keys = open('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efc58d6182d683768e84354a8b4424fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06a1d5e0772da42673c9ad6d87b1d816/" rel="bookmark">
			【数据库】 mysql用户授权详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MySQL用户授权
一，密码策略
1，查看临时密码
2，查看数据库当前密码策略：
二， 用户授权和撤销授权
1、创建用户
2，删除用户
3，授权和回收权限
MySQL用户授权 一，密码策略 mysql刚安装时，临时密码会存储在 /var/log/mysqld.log
1，查看临时密码 方法一：直接给出密码
[root@localhost ~]# awk '/temporary password/ {print $NF}' /var/log/mysqld.log *2D):irrJ_!_ 方法二：查到的语句的最后为密码
[root@localhost ~]# grep 'password' /var/log/mysqld.log 2023-02-07T13:07:17.842453Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: *2D):irrJ_!_ 2，查看数据库当前密码策略： mysql8.0.30 [(none)]&gt;show VARIABLES like"%password%"; 二， 用户授权和撤销授权 MySql8有新的安全要求，不能像之前的版本那样一次性创建用户并授权。需要先创建用户，再进行授权操作。
mysql8.0.30 [(none)]&gt;grant all privileges on *.* to 'xiaoming'@'%';
ERROR 1410 (42000): You are not allowed to create a user with GRANT
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06a1d5e0772da42673c9ad6d87b1d816/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a14fb2531e131abc6bfb8b984575fcb/" rel="bookmark">
			英语发音规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字母 元音字母 ： a，e，i，o，u
辅音字母 ： 除元音外的其他字母
元音（20个）
12个单元音
长元音 [i:][ə:][ɔ:][u:][a:]念长元音时，一定要注意音的长度。学长元音时的通病是；念的长度不够，甚至念得和短元音一样。
短元音 [i][ə][ɔ][u][æ][e][ʌ] 念短元音时；一定要念得短而自然。一般来说，清辅音前的短元音应念得非常短。
8个双元音
[ai][ei][ɔi][iə][ɛə][uə][əu][au]发音时由一个元音向另一个元音滑动，口型有变化。前一个元音发音清晰响亮，且时间长；后一个元音发音模糊软弱，且时间短。
辅音（28个）
清辅音
[p][t][k][f][s][θ][ʃ][tʃ][tr][ts]发音时声带不震动。
浊辅音
[b][d][g][v][z][ð][ʒ][dʒ][dr][dz] 几乎不送气，声带震动。
鼻音（3个）
[m] [n] [ŋ]发音时软腭下垂,使气流从鼻腔逸出而产生的一种语音。
似拼音（3个）
[h] [r] [l]它们三个的发音非常相似。
半元音（2个）
[w] [j]语音学上指擦音中气流较弱，摩擦较小，介于元音跟辅音之间的音。
音节 开音节 ：
以发音的元音字母结尾的单节。例如，he，be。以辅音字母（r除外）+ 不发音的字母e结尾的音节。例如，make，like。 *在重读的开音节中，元音字母按字母名称读音
闭音节 ：
以一个或几个辅音字母（r除外）结尾，而中间只有一个元音字母的音节。例如，map，desk，is。
*在重读的闭音节中，元音字母读作短元音
发音 1. 元音字母在重读音节中的读音
Aa
Ee
Ii
Oo
Uu
开音节
ei
i:
ai
əʊ
ju:
name,take
be,he
like,bike
note,no
mute,use
闭音节
æ
e
i
ɒ
ʌ
map,bag
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a14fb2531e131abc6bfb8b984575fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3a502935d6c1ed477e5e11050a0b9fb/" rel="bookmark">
			网卡聚合（bond）模式简介及交换机侧配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网卡绑定mode共有七种(0~6) ：
bond0、bond1、bond2、bond3、bond4、bond5、bond6
第一种模式：mode=0 ，即：(balance-rr) Round-robin policy（平衡抡循环策略，需要配置交换机静态聚合）
第二种模式：mode=1，即： (active-backup) Active-backup policy（主-备份策略）
第三种模式：mode=2，即：(balance-xor) XOR policy（平衡策略，需要配置交换机静态聚合）
第四种模式：mode=3，即：broadcast（广播策略，需配置交换机静态聚合）
第五种模式：mode=4，即：(802.3ad) IEEE 802.3ad Dynamic link aggregation（IEEE 802.3ad 动态链接聚合，需要交换机动态聚合）
第六种模式：mode=5，即：(balance-tlb) Adaptive transmit load balancing（适配器传输负载均衡）
第七种模式：mod=6，即：(balance-alb) Adaptive load balancing（适配器适应性负载均衡）
通过网口绑定(bond)技术,可以很容易实现网口冗余，负载均衡，从而达到高可用高可靠的目的。
ps: 一定要关闭，不关会对做bonding有干扰
systemctl stop NetworkManager.service # 停止NetworkManager服务
systemctl disable NetworkManager.service # 禁止开机启动NetworkManager服务
在各种网站上，已经有许多的网卡（服务器侧）的介绍与使用方法，而交换机侧的较少，这篇文章主要介绍下在使用bond时，交换机侧的配置与使用。
交换机侧 mode0、2、3需要配置交换机静态聚合口，mode4需要配置交换机动态聚合口。
链路聚合的定义：
链路聚合 （Link Aggregation），也称为端口捆绑、端口聚集或链路聚集。
链路聚合是将多个端口聚合在一起形成1个聚合组，以实现出/入负荷在各成员端口中的分担。
链路聚合提供了更高的连接可靠性，当有一条链路断开，流量会自动在剩下链路间重新分配。
链路聚合在数据链路层上实现。
在交换机中，聚合口称为smartgroup.
SmartGroup的定义：
SmartGroup是将多个同种类型的以太网接口捆绑成一个SmartGroup逻辑接口。在ZXR10 5960-H中，martGroup功能可以为用户提供更加灵活、更加高效的组网解决方案。使得在利用ZXR10系列产品进行网络规划、组网设计时，有了更大的灵活性，同时可以大大提高网络的稳定性，尤其是对于以太网组网环境和应用以太网接口的网络环境。利用SmartGroup功能可以扩展带宽、增强稳定性、使网络建设成本更加合理。
SmartGroup原理:
SmartGroup的链路聚合（Link Aggregation） 是将多个端口聚合在一起形成一个聚合组，以实现出/入负荷在各成员端口中的分担，同时也提供了更高的连接可靠性，从外面看起来，一个聚合组好象就是一个端口。端口聚合的负载分担类型分为负载分担聚合和非负载分担聚合。
链路聚合控制协议(LACP)：提供了一种在链路上交换伙伴系统间信息的标准化途径。该协议允许链路聚合控制实体们在链路聚合群统一性上达成一致，以及允许把链路归属于链路聚合群，对链路的接收和发送函数按序使能。
LACP的实现原理主要包括以下几点：
1.LACP协议是运行在单个物理端口上的，依赖信息和状态的传输，而不是命令的传输。
2.LACP协议是一个两端不断协商的过程，有两种模式：主动协商模式（Active） 、被动协商模式（Passive），只有Active模式的端口才会主动进行报文的收发。
3.协商成功的端口状态为Active，不成功的为Inactive。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3a502935d6c1ed477e5e11050a0b9fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9933e11684393d6ace72dc49ac212361/" rel="bookmark">
			npm ERR! code ELIFECYCLE解决方案，npm犯错!myweb@1.0.0构建脚本失败。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题
npm ERR! code ELIFECYCLE
npm ERR! errno 1
npm ERR! myweb@1.0.0 build: webpack --config config/webpack.config.js
npm ERR! Exit status 1
npm ERR!
npm ERR! Failed at the myweb@1.0.0 build script.
npm犯错!代码ELIFECYCLE
npm犯错!errno 1
npm犯错!myweb@1.0.0 build: webpack——config config/webpack.config.js
npm犯错!退出状态1
npm犯错!
npm犯错!myweb@1.0.0构建脚本失败。
引起这个原因是因为webpack.config.js配置出错的问题，其实就是路径配置错误了，在webpack.config.js中有些路径配置是按package.json的文件位置来配置的，一些是按当前文件位置来配置的，配置时候人们往往会搞混。
2.解决方案
2.1 解决方案一：
填写正确的路径，出现这个问题往往是路径配置错误引起的。参考下面模板，我将解读路径配置：
entry:‘./src/js/index.js’ //这个路径是基于package.json文件为基准的文件路径（而非webpack.config.js文件）
plugins中的template: ‘src/index.html’ //这个也是基于package.json文件为基准的文件路径
而path:path.resolve(__dirname,‘…/dist’) //__dirname是当前文件所在的目录，以webpack.config.js文件项目根路径为基准，创建一个dist文件夹
const path=require('path'); //调用node.js中的路径 const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports={ entry:'./src/js/index.js', //需要打包的文件（这个路径按package.json位置来写） output:{ filename:'bundle.js', //打包文件名 //__dirname代表：main.js的位置，指定生成的文件目录（按当前文件位置写） path:path.resolve(__dirname,'../dist') }, module: { rules: [ { test: /\.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9933e11684393d6ace72dc49ac212361/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79464f083ca07b165e4bc59992ee5b1c/" rel="bookmark">
			autojs自动获取短信验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AutoJS 是一种基于 JavaScript 的自动化脚本语言，可以用于在 Android 设备上自动化操作。
如果你想使用 AutoJS 自动获取短信验证码，你可以使用 Android 的短信 API，在 AutoJS 中编写代码读取短信内容，然后从中提取验证码。
不过，请注意，由于隐私保护原因，不建议在没有用户授权的情况下读取短信内容，否则可能会遭到用户投诉或违反相关法律法规。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba5ba955a3c9324226b491c76ca9d3e4/" rel="bookmark">
			【搞一点AUTOSAR】基于TC397的MACL-ADC配置解读（使用EB）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【搞一点AUTOSAR】基于TC397的MACL-ADC配置解读（使用EB） 文章目录 【搞一点AUTOSAR】基于TC397的MACL-ADC配置解读（使用EB）前言一、ADC模块介绍1、ADC模块的功能2、模块相关概念首字母缩略介绍： 二、基于TC397的EB_MCAL_ADC模块介绍1.Config Variant与AdcConfigSet2. AdcGeneral3.AdcPublishedInformation 前言 本文描述的配置基于英飞凌TC397芯片，ADC模块是MCAL相当重要的部分，本文先对模块，API函数等做基本介绍，下一篇描述如何完成基本的ADC配置
一、ADC模块介绍 1、ADC模块的功能 初始化并控制微控制器的内部模拟数字转换器单元(s)。它提供启动和停止转换的服务，以启用和禁用转换的触发源。此外，它还提供服务来启用和禁用通知机制和例程，以查询转换的状态和结果。
ADC模块在的ADC通道组上工作，这是由的ADC通道构建的。ADC通道组将模拟输入引脚（ADC Channel）、所需的ADC电路本身和转换结果寄存器组合成一个实体，它可以通过ADC模块进行单独控制和访问。
2、模块相关概念首字母缩略介绍： DEM ：Diagnostic Event Manager 诊断事件管理
DET ：Default Error Tracer 默认错误跟踪器
ADC :Analogue Digital Converter 模数转换器
MCU :Microcontroller Unit 微控制器管理单元
API :Application Programming Interface 应用程序接口
HW :Hardware 硬件
SW :Software 软件
ADC HW Unit : ADC硬件模块，表示一种微控制器输入电子设备，它包括执行“模拟到数字转换”所需的所有部件。
ADC Module ：ADC基本软件模块ADC驱动程序，也缩写为ADC驱动程序
ADC Channel ：表示绑定到一个端口引脚的逻辑ADC实体。多个ADC实体可以映射到同一个端口引脚。
ADC Channel Group ：连接到同一ADC硬件单元的一组ADC通道（例如，一个采样和保持转换器和一个A/D转换器）。整个组的转换是由一个触发源触发。
ADC Result Buffer (ADC Streaming Buffer, ADC Stream Buffer) ：ADC驱动程序的用户必须为每个组提供一个缓冲区。如果选择了流媒体访问模式（streaming access mode）该缓冲区可以保存同一组通道的多个样本。如果选择了单一访问模式，缓冲组中保留每个通道的一个样本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba5ba955a3c9324226b491c76ca9d3e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92d2fb9088be675b40991fe1e9dd71e6/" rel="bookmark">
			＜Linux内核学习＞文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：Linux 0.11 / Linux 3.4.2 参考书籍：Linux内核完全剖析基于0.11内核-赵炯 一、Linux中使用文件系统的部分 1.1关于Linux中高速缓冲区的管理程序
1.2文件系统的底层通用函数(对于硬盘的读写，分配释放等，对于目录节点inode的管理，以及内存和磁盘的映射
1.3文件数据进行读写的操作模块(vfs:虚拟文件系统 硬件驱动和文件系统的关系)
1.4文件系统与其他程序接口的实现(fopen fclose等等)
二、文件系统的基本概念 对于一个硬盘设备，通常都会划分出几个盘片，每个盘片存放着一个不同的文件系统。比如下图将一个硬盘分成了4个分区，包含了4个不同的文件系统。其中主引导扇区中存放着磁盘引导程序和分区表信息（指明硬盘上的每个分区的类型）。
对于Linux0.11内核采用的文件系统是MINIX文件系统，它的分布如下图哦所示：
① 引导块：用来引导设备的，通常在上电时由BIOS自动读入运行的数据。对于非引导设备的盘引导块内容为空。
② 超级快：相当于文件系统的描述符，定义如下：
struct super_block { unsigned short s_ninodes; unsigned short s_nzones; unsigned short s_imap_blocks; unsigned short s_zmap_blocks; unsigned short s_firstdatazone; unsigned short s_log_zone_size; unsigned long s_max_size; unsigned short s_magic; /* These are only in memory */ struct buffer_head * s_imap[8]; struct buffer_head * s_zmap[8]; unsigned short s_dev; struct m_inode * s_isup; struct m_inode * s_imount; unsigned long s_time; struct task_struct * s_wait; unsigned char s_lock; unsigned char s_rd_only; unsigned char s_dirt; }; s_ninode表示当前块设备的inode节点数。每个inode代表一个文件。 s_nzones表示当前块设备上以逻辑块为大小 （1KB）的逻辑块数。 s_imap_blocks与s_zmap_blocks分别表示当前块设备的inode节点位图和逻辑块位图所占用的逻辑块数。 逻辑块位图用于描述当前设备每个磁盘块的使用情况。如果为0，表示对应的磁盘块是空闲的，可以分配使用。当一个磁盘块被分配占用后，对应的逻辑块位图的比特位被置1 根据超级块数据结构中定义，s_zmap是一个数组，它占用了8块磁盘块大小，每个块大小 是1024字节，因此总共可以管理8192*8个比特位，每个比特位分别对应一个数据磁盘块，总计这8个磁盘块大小可以管理655356数据磁盘块。 inode节点位图是用来标记iNode节点的使用情况。与逻辑块位图 类似，当创建一个文件时候，我们分配一个iNode数据结构，并且些iNode实例对应的inode位图数组对应的位需要被置1。 s_firstdatazones表示当前块设备上数据区开始位置占用的第一个逻辑块的块号。 s_max_size表示当前块设备上，以字节为单位的最大文件 的长度。 s_magic表示文件系统的魔数，标示了文件系统的类型。 ④ i节点位图：类似逻辑块位图。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92d2fb9088be675b40991fe1e9dd71e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c38aa6b77f0f69cf2c64b7547661673/" rel="bookmark">
			anaconda详细介绍、安装及使用（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		anaconda详细介绍、安装及使用 1 介绍1.1 简介1.2 特点1.3 版本下载 2 Anaconda管理Python包命令3 安装3.1 windows安装 4 操作4.1 Conda 操作4.2 Anaconda Navigator 操作4.3 Spyder 操作4.4 Jupyter Notebook 操作 5 示例参考 1 介绍 1.1 简介 Anaconda是用于科学计算（数据科学、机器学习应用程序、大规模数据处理、预测分析等）的Python和R编程语言的发行版，旨在简化包管理和部署。该发行版包括适用于Windows、Linux和macOS的数据科学包。它由 Anaconda, Inc. 开发和维护，该公司由 Peter Wang 和Travis Oliphant于 2012 年创立。 作为 Anaconda, Inc. 的产品，它也被称为Anaconda Distribution或Anaconda Individual Edition，而该公司的其他产品是 Anaconda Team Edition 和 Anaconda Enterprise Edition，两者都不是免费的。Anaconda，中文大蟒蛇，是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。Anaconda包括Conda、Python以及一大堆安装好的工具包，比如：numpy、pandas等。
Miniconda包括Conda、Python。conda是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换。 1.2 特点 开源安装过程简单高性能使用Python和R语言免费的社区支持 1.3 版本下载 官网下载
https://www.anaconda.com/products/distribution国内镜像下载 清华镜像 https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ 2 Anaconda管理Python包命令 windows下打开Anaconda Prompt工具，通过命令检测conda相关信息：
是否被安装 conda --version conda 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c38aa6b77f0f69cf2c64b7547661673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7793b6e71e5da7fa806ba070f779250d/" rel="bookmark">
			学习方法 今天的收获
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这几天写了5-6篇文章 ，都是关于编程的。
但是这次我想写一个关于学习方法的文章
虽然我才初中，但说实话，我这一次的收获十分的大。
话不多说，开始总结：
一，总结（初中） 都说要打好学习习惯，但你们有没有想过，什么是最好的学习习惯？
是复习？ 是预习？ 是写笔记？ 是总结归纳？
其实都不是！
按我们以前的思维来说，学习的步骤就是：1.预习 2.听课（做笔记）3.复习 4.写作业
但其实这些都不一定都是最好的；
先定义一下最好的学习习惯：就是用了这个学习习惯就可以出一个好成绩；
1. 那预习算不算呢，其实不算，比如我认识的某位同学，他学整式的乘除，那些公式自己都推
出来了
1. 那预习算不算呢，其实不算，比如我认识的某位同学，他学整式的乘除，那些公式自己都推 出来了 2. 听课算不算呢，不算，有的人自学成才 3. 复习算不算呢，不算，有的人考试前不复习依然数学150； 4. 写作业算不算呢，有的人认为这就应该算了吧，可能在编程上是这样，但在学习上，对不起， 依然不是！因为都考150了，都熟练了，为什么还要练？ 其实最重要的学习习惯是： 多思考！！！ 因为刚刚说的那些公式自己都推出来的，自学成才的，考试前不复习依然数学150的，他们的共同特点都是多思考！！！
所以，多思考是所有学霸学神的共同特点。
注：以下内容试于普通学生； 二,初一 初一的内容其实并没有多难，初一主要是配用学习习惯；
除了学霸（天才型，但大部分人不是🤭），按我们思维来说，学习的步骤就是：1.预习 2.听课（做笔记）3.复习 4.写作业 5.改错
这些于我们的成绩息息相关，非常重要；
和成绩的关系度：听讲与笔记40% ， 作业10%，改错20%，总结30%.
具体方法：听讲，笔记，时间分配：80%时间听讲，20%时间记笔记；
听讲听什么：老师对一个题目的思路突破分析，一个题目或者一类题目的总结，自己用疑问
的地方。
笔记记什么：
（1）基础知识的定义，定理，性质（一定要理解记忆）
（2）自己课上的灵感
（3）自己有疑问的地方
（4）老师的归纳总结
作业：认真完成作业是对课堂知识的落实，十分重要
改错：对自己没掌握的知识的及时弥补与修正；
总结：总结的时间不需要太长时间，但是对能力提升很重要。把自己的知识体系归纳总结，编
织成网。
最后一点：按时完成老师部署的各科作业 这个要在每天及时将作业完成，效率很重要！不能一边做一边玩，要高效率学习高效率的玩！
初中学业任务重，效率很重要！
------------ 2023年 2月 10日 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/213f685275cd0d09481191db0e9d320b/" rel="bookmark">
			如何修改element-ui 文字提示tooltip的背景颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加背景颜色类
&lt;el-tooltip content="分享" placement="left" popper-class="=share_atooltip"&gt; &lt;el-button&gt;分享&lt;/el-button&gt; &lt;/el-tooltip&gt; //背景颜色 .share_atooltip{ background: #515b62 !important; } 如果是页面中样式使用了scoped，则需要写在全局的css下面或者写在app.vue这个文件里面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f8cc62686140a3b7a1c266c71611a59/" rel="bookmark">
			SpringDataRedis之RedisTemplate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SpringDataRedis简介 1、Redis redis是一款开源的Key-Value数据库，运行在内存中，由C语言编写。企业开发通常采用Redis来实现缓存。同类的产品还有memcache 、memcached 等。
2、Jedis Jedis是Redis官方推出的一款面向Java的客户端，提供了很多接口供Java语言调用。可以在Redis官网下载，当然还有一些开源爱好者提供的客户端，如Jredis、SRP等等，推荐使用Jedis。
3、Spring Data Redis Spring-data-redis是spring大家族的一部分，提供了在srping应用中通过简单的配置访问redis服务，对reids底层开发包(Jedis, JRedis, and RJC)进行了高度封装，RedisTemplate提供了redis各种操作、异常处理及序列化，支持发布订阅，并对spring 3.1 cache进行了实现。
spring-data-redis针对jedis提供了如下功能：
连接池自动管理，提供了一个高度封装的“RedisTemplate”类
针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口
ValueOperations：简单K-V操作
SetOperations：set类型数据操作
ZSetOperations：zset类型数据操作
HashOperations：针对map类型的数据操作
ListOperations：针对list类型的数据操作
提供了对key的“bound”(绑定)便捷化操作API，可以通过bound封装指定的key，然后进行一系列的操作而无须“显式”的再次指定Key，即BoundKeyOperations：
BoundValueOperations
BoundSetOperations
BoundListOperations
BoundSetOperations
BoundHashOperations
将事务操作封装，有容器控制。
针对数据的“序列化/反序列化”，提供了多种可选择策略(RedisSerializer)
JdkSerializationRedisSerializer：POJO对象的存取场景，使用JDK本身序列化机制，将pojo类通过ObjectInputStream/ObjectOutputStream进行序列化操作，最终redis-server中将存储字节序列。是目前最常用的序列化策略。
StringRedisSerializer：Key或者value为字符串的场景，根据指定的charset对数据的字节序列编码成string，是“new String(bytes, charset)”和“string.getBytes(charset)”的直接封装。是最轻量级和高效的策略。
JacksonJsonRedisSerializer：jackson-json工具提供了javabean与json之间的转换能力，可以将pojo实例序列化成json格式存储在redis中，也可以将json格式的数据转换成pojo实例。因为jackson工具在序列化和反序列化时，需要明确指定Class类型，因此此策略封装起来稍微复杂。【需要jackson-mapper-asl工具支持】
二、RedisTemplate中API使用 1、pom依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2、配置文件 # Redis服务器连接端口 spring.redis.port=6379 # Redis服务器地址 spring.redis.host=127.0.0.1 # Redis数据库索引（默认为0） spring.redis.database=0 # Redis服务器连接密码（默认为空） spring.redis.password= # 连接池最大连接数（使用负值表示没有限制） spring.redis.jedis.pool.max-active=8 # 连接池最大阻塞等待时间（使用负值表示没有限制） spring.redis.jedis.pool.max-wait=-1ms # 连接池中的最大空闲连接 spring.redis.jedis.pool.max-idle=8 # 连接池中的最小空闲连接 spring.redis.jedis.pool.min-idle=0 # 连接超时时间（毫秒） spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f8cc62686140a3b7a1c266c71611a59/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/168/">«</a>
	<span class="pagination__item pagination__item--current">169/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/170/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>