<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/332355e77c1109a83a67a887b3cd38dc/" rel="bookmark">
			动态启用/禁用 datagrid中editor编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 动态启用/禁用 datagrid中editor编辑
onClickRow:function OnClickRowListItemSelected(index,row){ //if (endEditing()) { if (row.REPAIR_STATUS == '已維修' || row.REPAIR_STATUS == '已更換'||row.REPAIR_STATUS == '已疏通') { $('#dg').datagrid('selectRow', index).datagrid('beginEdit', index);//必须加上这一句，不然dd会为空 var dd = $('#dg').datagrid('getEditor', { index: index, field: 'REPAIR_LEVEL' }); $(dd.target).combobox('disable'); editIndex = index; //} } else { //$('#dg').datagrid('selectRow', editIndex); $('#dg').datagrid('selectRow', index).datagrid('beginEdit', index); var editor = $('#dg').datagrid('getEditor', { index: index, field: "REPAIR_LEVEL" }); editor.target.focus(); } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a55b298ae55263e49030034c655db381/" rel="bookmark">
			POSTMAN客户端在列表里切换不同接口卡顿的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尝试了：
1. 重装
2. 删除C盘下，indexDB/partitions等文件夹（直接打不开了）
最后解决了
1. win系统配置添加POSTMAN_DISABLE_GPU = true
2. 重启电脑（重启完还是不行）
3. postman客户端登出，重新登陆就不卡了（搞不好一开始重新登陆就能解决）
网上看了前人的经验，
Postman will no longer load as of 6.1.2 (GPU issue) · Issue #4594 · postmanlabs/postman-app-support · GitHub
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872733a20e418a5750231685a35cd1b6/" rel="bookmark">
			PyTorch判断是否使用GPU以及哪些数据需要放到GPU上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打印模型 model 和数据 data 在 gpu 上还是 cpu 上。 通过判断模型 model 的参数是否在 cuda 上来判定模型是否在 gpu 上。 print ('Is model on gpu: ', next (model.parameters ()).is_cuda)
输出若是 True，则 model 在 gpu 上；若是 False，则 model 在 cpu 上。
输出数据 data 的 device 字段。 print ('data device: ', data.device)
输出 gpu 则在 gpu 上，输出 cpu 则在 cpu 上。
哪些数据需要放到 GPU 上 import torch import time #1.通常用法 device = torch.device("cuda" if torch.cuda.is_available() else "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/872733a20e418a5750231685a35cd1b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbd1c111c5ba71070e43bfd5e93bf4f8/" rel="bookmark">
			使用OpenCV处理图片的亮度、对比度、曝光、高光、阴影、饱和度、色温，色相（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		屏幕录制2023-05-22 22.09.32
集成opencv的方式请参照上一个帖子
OpenCV在iOS端的集成及Mat和UIImage互相转化（附源码）
废话不多说直接上代码，伸手党福利：
代码中记得引入头文件及命名空间
#import &lt;opencv2/opencv.hpp&gt; #import "CVTools.h" //对应的.h文件 命名空间在自己的.h文件后定义 using namespace cv; using namespace std; 下面的处理方法统一对使用最多的8bit图片处理，如果是16bit的图片需要修改对应的格式，在使用的方法内需要改动的如下:
255 调整为 65535
Vec4b 调整为 Vec4w
uchar 调整为 ushort
UCHAR_MAX 调整为 USHRT_MAX
1.亮度 //调整亮度 +(UIImage *)brightInPutImage:(UIImage *)inputImage value:(float)beta{ Mat g_srcImage = [CVTools cvMatFromUIImage:inputImage]; if(g_srcImage.empty()){ return nil; } Mat g_dstImage=Mat::zeros(g_srcImage.size(),g_srcImage.type()); g_srcImage.convertTo(g_dstImage, -1, 1, beta); return [CVTools UIImageFromCVMat:g_dstImage]; } 2.对比度 //调整对比度 +(UIImage *)contrasInPutImage:(UIImage *)inputImage value:(CGFloat)alpha{ Mat g_srcImage = [CVTools cvMatFromUIImage:inputImage]; if(g_srcImage.empty()){ return nil; } Mat g_dstImage=Mat::zeros(g_srcImage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbd1c111c5ba71070e43bfd5e93bf4f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f89fdbf9f106f174f6f217f0abda0797/" rel="bookmark">
			华为OD机试之拼接URL（Java源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拼接URL 题目描述
给定一个url前缀和url后缀,通过","分割 需要将其连接为一个完整的url
如果前缀结尾和后缀开头都没有/，需要自动补上/连接符
如果前缀结尾和后缀开头都为/，需要自动去重
约束：不用考虑前后缀URL不合法情况
输入描述
url前缀(一个长度小于100的字符串) url后缀(一个长度小于100的字符串)
输出描述
拼接后的url
输入输出说明/acm,/bb/acm/bb无/abc,/bcd/abc/bcd无/acd,bef/acd/bef无,/无 源码和解析
解析：
1.可以很轻松获得url的前缀和后缀
2.无论前缀后缀是否有/，都可以去掉
3.直接拼接即可
示例代码：
public class T17 { public static void main(String[] args) { String input = "/acd,bef"; String wordArr[] = input.split(","); if (wordArr.length == 0) { System.out.println("/"); return; } if (wordArr.length == 1) { System.out.println("/" + wordArr[0]); return; } String prefix = wordArr[0]; if (prefix.startsWith("/")) prefix = prefix.replaceFirst("/", ""); String suffix = wordArr[1]; if (suffix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f89fdbf9f106f174f6f217f0abda0797/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3528a9d607cc90d7b9b7e9d41bd7be9/" rel="bookmark">
			华为OD机试之非严格递增连续数字序列（Java源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非严格递增连续数字序列 题目描述
输入一个字符串仅包含大小写字母和数字，求字符串中包含的最长的非严格递增连续数字序列的长度，（比如12234属于非严格递增连续数字序列）。
输入描述
输入一个字符串仅包含大小写字母和数字，输入的字符串最大不超过255个字符。
输出描述
最长的非严格递增连续数字序列的长度
输入输出说明abc2234019A334bc42234为最长的非严格递增连续数字序列，所以长度为4。 源码和解析
解析：
可以用双指针来做 根据自己需求来 如果对指针使用不是很擅长的。可以考虑不用指针
示例代码1：
public class T18 { public static void main(String[] args) { String input = "abc2234567019A334bc"; int left = 0; int right = 0; int max = 0; for (int i = 0; i &lt; input.length() - 1; i++) { if (input.charAt(right + 1) - input.charAt(right) == 1 || input.charAt(right + 1) - input.charAt(right) == 0) { right++;// 右指针右移一个 } else { right++; if (right - left &gt; max) { max = right - left; } left = right; } } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3528a9d607cc90d7b9b7e9d41bd7be9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/202cb121ec2324ffdc8eabeff8790929/" rel="bookmark">
			HC-05蓝牙模块的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我最近刚刚开始学习嵌入式，在第一次使用蓝牙模块HC-05的时候遇到了很多问题， 甚至连接线都不会，因此下面我会十分详细地介绍我一步一步探索的步骤，直到完成使用手机APP和51单片机收发数据。
调试步骤 首先，我们需要明确一个观点，这也是我这次排错过程中最大的收获，即：我们需要有一个合理的排错流程。而不是盲目、急躁地反复尝试，结果反复出错，最后耽误我们的项目进度。这样的试错时间其实是完全可以避免的，有时我们称呼它为“走弯路”。
所以下面我会介绍我第一次调试蓝牙模块的步骤：
（图片来源于B站up主斌哥单片机）
我们接下来就按照这个步骤进行调试
先使用USB转串口模块（我用的是CP2102模块），直接将HC-05模块插到电脑上进行测试，这样可以排除HC-05模块出错和电脑串口助手出错 两种可能；同时还可以进行AT指令配置，将波特率设置到自己目标波特率（默认是9600），显示为9600,0,0。也可以设置名称、密码等，我建议只设置名称即可（注意：1.插上USB前需要按住HC-05的小按钮，且电脑要先安装相应驱动；2.输入AT指令时需要回车），然后用手机串口助手连接并测试收发数据是否正常。（注意：我使用的是大夏龙雀的蓝牙助手APP，需要设置UUID为BT16模块） 将HC-05模块与单片机相连。注意由于此时需要用杜邦线将其TXD和RXD与单片机上的相连，而在烧录程序时两者是会冲突的的，所以在烧录时需要先拔掉HC-05模块的TXD和RXD两根线，烧录完后在插上，重新上电（注意！这里上电时不需要按那个小按钮了）。然后直接用手机串口助手连接，搜索到后，成功连接后，勾选十六进制收发，在电脑端也选择十六进制收发，并将波特率调整为自己设置的波特率，如下图： 然后就可以正常收发数据啦^_^
试错步骤 我总结了可能会出错的几种可能，大家可以按照下面这几种坑依次尝试排除，从而得到成功解
蓝牙模块本身硬件有问题。（包括接线错误之类）这个可以通过调试步骤的第一步排除手机串口助手APP设置有问题。比如我用的这个app就需要设置UUID波特率设置有问题。（最有可能的一点）未采用十六进制输入输出。（这个不是一定的，比如我测试时使用USB转串口模块就可以通过文本模式正常收发） 过程中有很多坑，大家一定要注意别再踩哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/949cddde85fde0205969ab723ef3ee43/" rel="bookmark">
			新手学编程必会的100个代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是本文的目录 前言 1、for循环中的else条件2、数字求和3、随机数生成4、将列表中的所有元素作为参数传递给函数5、获取列表的所有中间元素6、使用一行代码赋值多个变量7、Python清空列表8、通过Enum枚举同一标签或一系列常量的集合9、重复字符串10、计算每个月天数11、输出指定范围内的素数12、计算两数差值13、奇数移到偶数前14、顺序表元素逆置15、删除顺序表最小值元素16、删除值在x~y之间的所有数据17、打印九九乘法表18、更多资源文末获取 零基础Python学习资源介绍 👉Python学习路线汇总👈👉Python必备开发工具👈👉Python学习视频600合集👈👉实战案例👈👉100道Python练习题👈👉面试刷题👈 资料领取好文推荐 前言 我记得刚开始接触编程的时候，觉得太难了。
也很好奇，写代码的那些人也太厉害了吧？全是英文的，他们的英文水平一定很好吧？
他们是怎么记住这么多代码格式的？而且错了一个标点符号，整个程序都会有影响。
一个程序几千行，错一个标点符号都不行这也太难了吧？
带着新手的灵魂拷问，作为从业单片机编程10年的开发者，我来为大家拨开云雾。
看完以后你就会明白，其实他们也没那么厉害！即便你是初中文凭，也照样能编程。
对于python语言来说，要记得东西其实不多，基本就是几个常用语句加一些关键字而已。
你所看到的那些几千甚至上万行的代码，都是用这些语句和关键词来重复编写的。
只是他们逻辑功能不一样，另外的那些英文，都是程序员自己起的，比如说一些变量的名字，函数的名字。
如果你喜欢你定义成abc都可以，只不过为了程序大了以后为了方便阅读和维护，我们一般起跟要实现的功能相同的英文缩写代替。
比如说我要存储一个电压值，那你可以定义一个变量，名字叫VoltageValue,或者这两个词的缩写VoltVal。
所以，大家不要把这个想得这么神秘和高大上。
1、for循环中的else条件 这是一个for-else方法，循环遍历列表时使用else语句。
下面举个例子，比如我们想检查一个列表中是否包含奇数。
那么可以通过for循环，遍历查找。
numbers = [2, 4, 6, 8, 1] for number in numbers: if number % 2 == 1: print(number) break else: print("No odd numbers") 2、数字求和 # -*- coding: UTF-8 -*- # Filename : test.py # author by : www.runoob.com # 用户输入数字 num1 = input('输入第一个数字：') num2 = input('输入第二个数字：') # 求和 sum = float(num1) + float(num2) # 显示计算结果 print('数字 {0} 和 {1} 相加结果为：{2}'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/949cddde85fde0205969ab723ef3ee43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5addb662a79afd858f46712480ec4bae/" rel="bookmark">
			【嵌入式Linux】U-boot移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		U-boot移植 配置编译 官网下载 //http://www.denx.de/wiki/U-Boot/WebHome -&gt; https://source.denx.de/u-boot/u-boot //-&gt;选最新的稳定版本 如v2022.01 -&gt; 下载得u-boot.v2022.01.tar.bz2 $ tar -xvf u-boot.v2022.01.tar.bz2 //注意，不能再共享目录解压 $ make p3450-0000_defconfig /*导入官方配置 见p3450由来，https://docs.nvidia.com/jetson/archives/l4t-archived/l4t-3261/index.html 的u-boot构建 里面的 命令中的占位符 里面可查到 jetson nano 板子的id号 p3450-0000 p3450-0000_defconfig配置在configs下可查到，这是英伟达官方已做好的 报错： /bin/sh: 1: bison: not found 解决：sudo apt-get install bison 报错： /bin/sh: 1: flex: not found 解决：sudo apt-get install flex */ $ make CROSS_COMPILE=aarch64-linux-gnu- /* 编译时 需指定 交叉编译工具链（不用ARCH=arm指定 cpu体系结构，因前面导入配置里已指定） 报错：include/image.h:1133:12: fatal error: openssl/evp.h: 没有那个文件或目录 解决：sudo apt-get install libssl-dev */ $ cp u-boot.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5addb662a79afd858f46712480ec4bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acbe03f03ed74a0ce0d3b300efb4e235/" rel="bookmark">
			Android源码环境搭建（aosp Ubuntu 16.04）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android源码环境搭建（aosp Ubuntu 16.04） 作者：千里马
课程要求：
电脑配置：双核，内存最少 16G，硬盘 200G 以上，独立安装 Ubuntu16.4 系统(http://releases.ubuntu.com/16.04/下面的ubuntu-16.04.7-desktop-amd64.iso，如果网速慢自己百度找一个阿里镜像)
（优先考虑直接电脑安装Ubuntu &gt; windows和Ubuntu双系统 &gt; windows上安装VMware方式，不要不建议安装virtualbox）
学员要求：最少 1 年以上应用开发经验，推荐在 3 年左右 Android 应用开发经验，
熟悉 Java 语言，可以看懂 C/C++
1、安装 ubuntu16.04（因为这个版本可以直接安装 openjdk-8，如果其他版本自行找方法）
2、openjdk 8 的安装
sudo apt-get install openjdk-8-jdk
3、设置默认 java 和 javac(可选)
由于本人当前 Ubuntu 上没有安装其他版本的 jdk，所以跳过此步骤
sudo update-alternatives --config java
sudo update-alternatives --config javac
4、 检查版本
java -version
打印如下：
openjdk version “1.8.0_252”
OpenJDK Runtime Environment (build 1.8.0_252-8u252-b09-1~16.04-b09)
OpenJDK 64-Bit Server VM (build 25.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acbe03f03ed74a0ce0d3b300efb4e235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea3207cbe475a362063acc8c445abf7/" rel="bookmark">
			数据结构 -最短路径dijkstra（迪杰斯特拉）算法讲解及代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迪杰斯特拉算法是一种广义的贪心算法，求出局部最优解，再去求全局最优解
图文讲解： 举例图：（起始点为1）
辅助数组：
s：记录了目标顶点到其他顶点的最短路径是否求得（求得为1，否则为0）
p：目标顶点到其他顶点的最短路径的前驱节点
（如，求得1-&gt;7-&gt;5的最短路径，那么5的前驱节点为7）
d：记录目标顶点到其他顶点最短距路径的长度 首先利用二维数组构建图中各个顶点的辅助数组的初始化关系：
初始化的解析：初始化只知道目标顶点：顶点1到自己的最短路径也就是0，所以s1为1其余没有求得标记为0，p中目标顶点v1到1 3 4 5顶点都没有弧也就是没有目标顶点到此节点的前驱节点设为-1，
d为目标顶点v1到与他有弧的节点的弧长度（权重），没有弧的则设置为无穷（32767） 步骤：（x集合为记录已经找到最短路径的节点，最初x：v1（目标节点））
1.每次从d中找到最小的数，并找到其节点下标，将此节点的s标记为1意味已找到目标节点到此节点的最短路径，再把此节点加入到我们的x集合当中。
2.把已经找到的最小路径的节点当作中专点，判断目标顶点到当前节点的路径+当前节点到其他节点的路径是都小于目标节点到其他节点的路径长度，如过小于则更新目标节点的长度。
（如v1-v3为无穷，v1-v2-v3为22，小于无穷所以把v1-v3的路径改为22：d2为22）
3.重复1，2的操作直到x集合标记完所有节点（s数组元素全部为1）。
代码实现： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MAX 32767 typedef struct Graph { char* vexs;//顶点 int** arcs;//边（用二级指针存放存放边的一级指针，一级指针存放边） int vexsNum;//顶点的个数 int arcsNum;//边的个数 }Graph; Graph* initGraph(int vexNum) { Graph* G = (Graph*)malloc(sizeof(Graph)); G-&gt;vexs = (char*)malloc(sizeof(char)*vexNum); G-&gt;arcs = (int**)malloc(sizeof(int*)*vexNum); for (int i = 0; i &lt; vexNum; i++) { G-&gt;arcs[i] = (int*)malloc(sizeof(int) * vexNum); } G-&gt;vexsNum = vexNum; G-&gt;arcsNum = 0; return G; } void crativeGraph(Graph* G, char* vexs, int* arcs) { for (int i = 0; i &lt;G-&gt;vexsNum; i++) { G-&gt;vexs[i] = vexs[i];//（Graph中的顶点数组存放顶点的“名字”） for (int j = 0; j &lt; G-&gt;vexsNum; j++) { G-&gt;arcs[i][j] = *(arcs + i * G-&gt;vexsNum + j);//二维数组加一个数表示第i+1个元素（相当于把二维数组全排成一行） if (G-&gt;arcs[i][j] &gt; 0 &amp;&amp; G-&gt;arcs[i][j] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ea3207cbe475a362063acc8c445abf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb1e13fdbbdea3503f46c1ad284b97f2/" rel="bookmark">
			k8s批量启动、批量删除pod、强制删除pod命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		批量修改同一命名空间下的副本 1、删除pod，批量修改副本replicas为0
kubectl get deploy -n {NAMESPACE} | grep -v NAME | awk ‘{print $1}’ | xargs -I ARG kubectl scale deploy ARG -n {NAMESPACE} --replicas=0
2、启动pod，批量修改副本replicas为1
kubectl get deploy -n {NAMESPACE} | grep -v NAME | awk ‘{print $1}’ | xargs -I ARG kubectl scale deploy ARG -n {NAMESPACE} --replicas=1
强制删除pod 1、查看pods
kubectl get pods -n {NAMESPACE}
2、删除指定pod
kubectl delete pod -n {NAMESPACE} {POD_NAME} --grace-period=0 --force
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c40c8e677364f7812904e21e69f6cbc1/" rel="bookmark">
			Gitlab的使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gitlab的基本介绍：
Gitlab是利用Ruby on Rails 一个开源的版本管理系统，实现一个自托管的git项目仓库，可通过web界面进行访问公开或私有的项目。
与GitHub类似，Gitlab能够浏览源代码、管理缺陷和注释、可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序Wall进行交流。
它还提供了一个代码片段收集功能可以轻松地实现代码复用，便于日后有需要的时候进行查找。
Git家族成员：
1）Git是一个版本控制系统，是一个命令，是一种工具；
2）Gitlib：是用于实现Git功能的开发库；
3）GitHub：是一个基于Git实现的在线代码托管仓库，包括一个网站界面，向互联网开放。
4）Gitlab：是一个基于Git实现的在线代码仓库托管软件，你可以用gitlab自己搭建一个类似于GitHub一样的系统，一般用于企业、学校等内部网络搭建git私服。
Gitlab的服务构成：
1）Nginx：静态web服务器；
2）gitlab-shell：用于处理git命令和修改authorized keys列表；
3）gitlab-workhorse：轻量级的反向代理服务器；
4）logratate：日志文件管理工具；
5）postgresql：数据库；
6）redis：缓存数据库；
7）sidekiq：用于在后台执行队列任务（异步执行）；
8）unicorn：An HTTP Server for Rack applications，Gitlab Rails应用是托管在这个服务器上面的。
Gitlab工作流程：
Gitlab shell：
Gitlab shell有两个作用：为Gitlab处理git命令、修改authorized keys列表。
当通过ssh访问Gitlab Server的时候，Gitlab Shell会：
1）限制执行预定义好的Git命令：git push git pull git annex
2）调用Gitlab Rail API 检查权限；
3）执行pre-receive钩子（在Gitlab企业版中叫做Git钩子）
4）执行你请求的动作，处理Gitlab的post-receive动作
5）处理自定义的post-receive动作。
当通过https访问Gitlab Server的时候，工作流程取决于你是从Git仓库拉取pull代码还是向Git仓库推送push代码。
如果你是从Git仓库拉取pull代码，Gitlab Rails应用会全权处理用户鉴权和执行Git命令的工作。
如果你是向Git仓库推送(push)代码，GitLab Rails应用既不会进行用户鉴权也不会执行Git命令，它会把以下工作交由GitLab Shell进行处理：
调用GitLab Rails API 检查权限
执行pre-receive钩子（在GitLab企业版中叫做Git钩子）
执行你请求的动作
处理GitLab的post-receive动作
处理自定义的post-receive动作
GitLab Workhorse
GitLab Workhorse是一个敏捷的反向代理。它会处理一些大的HTTP请求，比如文件上传、文件下载、Git push/pull和Git包下载。其它请求会反向代理到GitLab Rails应用，即反向代理给后端的unicorn。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c40c8e677364f7812904e21e69f6cbc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a6c46f429175538a5869223d9622fab/" rel="bookmark">
			利用rsync断点续传scp中断的文件传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器经常需要备份，但是长时间的下载，难免会出现下载中断的情况。
一直使用scp下载备份好的文件，以前数据量少的时候，直接重新下载就可以了。随着网站上数据越来越多，下载的时间越来越长，完全重新开始变得不现实了。有时候下载到90%以上的时候，失败了，完全重传是没有必要的。
我们只需要下载缺失的部分就好了，幸运的是rsync支持这种需求。
具体的做法是将如下的选项组合传递给rsync，-checksum（文件分块计算校验和，只传输校验和不一致的部分），-in-place（将文件原地替换，因为rsync通常会写一个临时文件，然后移动）和-no-whole-file（告诉rsync不要复制整个文件，而是使用deltas（部分传输））。
例如：
$ rsync -Pa --checksum --inplace --no-whole-file --progress remote.server:file local.file
下面是一个真实的例子：
1
2
3
4
5
$ rsync -Pa --checksum --inplace --no-whole-file --progress -e 'ssh -p 22' user@www.mobibrw.com:~/backup/wordpress.20181203.tar.gz wordpress.20181203.tar.gz
receiving incremental file list
sent 19 bytes received 76 bytes 0.22 bytes/sec
total size is 8379088896 speedup is 88200935.75
整个过程非常的快，比完全重传快多了。
scp命令拷贝文件非常好用，但在拷贝大文件时存在一个问题就是连接经常会断开，此时再使用scp进行拷贝会重新拷贝文件，为了解决这个问题。我们可以使用rsync命令来进行断点续传。命令如下：
1
$ rsync -P --rsh=ssh xxx.zip 192.168.0.1:~/
为了使用方便可以设置alias:
1
$ alias rscp="rsync -P --rsh=ssh"
参考链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a6c46f429175538a5869223d9622fab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64133c1dd913637d879cf63e689efad6/" rel="bookmark">
			vue3 封装组件 ——懒加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片的懒加载功能是通过IntersectionObserver来实现的。
以下是封装的组件
&lt;template&gt; &lt;div&gt; &lt;img :src="placeholderImage" alt="" :data-src="src" ref="lazyimg" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { onMounted, ref } from 'vue' export default { props: { src: { type: String, required: true } }, setup() { const placeholderImage = ref('') const lazyimg = ref(null) const Lazy = () =&gt; { // 创建 IntersectionObserver 实例 const observer = new IntersectionObserver((entries) =&gt; { entries.forEach((entry) =&gt; { if (entry.isIntersecting) { // isIntersecting是 是否进入可视区 true // 判断进入可视区时,将被观察的targe 的值img // 当在HTML中使用data-前缀定义自定义数据属性时, // 可以通过dataset属性访问这些属性的值。 // 当进入可视区时 将自定义的数据 dataset 赋给src const img = entry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64133c1dd913637d879cf63e689efad6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6037d85951e0c8a809a7424de40ac056/" rel="bookmark">
			redis连接Unable to connect to Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 今天本地springboot项目配置连接redis，一直报连接失败
Unable to connect to Redis; nested exception is io.lettuce.core.RedisConnectionException: Unable to connect to localhost:6379 Caused by: io.lettuce.core.RedisConnectionException: Unable to connect to localhost:6379 Caused by: io.lettuce.core.RedisCommandExecutionException: NOAUTH HELLO must be called with the client already authenticated, otherwise the HELLO AUTH &lt;user&gt; &lt;pass&gt; option can be used to authenticate the client and select the RESP protocol version at the same time 这样保持报错
下面来看如何解决的
解决方法 修改redis配置
1、设置可连接redis的网卡 指定了bind，则说明只允许来自指定网卡的Redis请求。如果没有指定或者指定为：0.0.0.0，就说明可以接受来自任意一个网卡的Redis请求。
查看网卡指令：ifconfig
bind 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6037d85951e0c8a809a7424de40ac056/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a57b1e7972d007cbf4d132b0b9900217/" rel="bookmark">
			什么是单域名证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
SSL证书是一种数字证书，它是由受信任的数字颁发机构所颁发的，SSL证书是加密传输协议，它的安全性是很高的，如果没有安装SSL证书，那么之前网站的通信协议是http，那么网站的数据传输是明文传输的，但是安装了是SSL证书之后，网站的通信协议是https，所以申请SSL证书是很有必要的，不过SSL证书的种类比较多，那么单域名证书是什么？什么是域名证书？
百科：
一般情况下，单域名SSL证书可以保护一个域名，它只能保护一个网站的域名，一般单域名SSL证书有免费的，不过免费的SSL证书它的安全性没有收费的SSL证书的安全性高，不过单域名SSL证书它的价格也不是很高，单域名证书适合的是网站域名少的网站，单域名SSL证书在验证的时候，有DV SSL证书、OV SSL证书、EV SSL证书这三种安全级别，他们的安全等级是不同的。
好处：
1.加密传输数据；加密保护浏览器/App 与服务器之间的数据传输安全。
采用 HTTPS 加密 App 及网页通讯，防止数据在传送过程中被窃取、篡改，确保数据的完整性；防止运营商的流量劫持、网页植入广告现象；同时有效抵挡中间人的攻击，大大提升安全性。
2.提升搜索排名；采用 HTTPS 有利于提升网站的搜索排名及站点可信度。2014年 Google 调整了搜索引擎算法，“比起同等 HTTP 网站，采用 HTTPS 加密的网站在搜索结果中的排名将会更高”，同时国内的搜索引擎厂商也在加强对 HTTPS 的重视，采用 HTTPS 可以辅助站点的 SEO 优化。
3.业务系统需要符合相关安全评测的要求。
如业务系统需要通过信息安全测评、等级保护测评等上级主管部门安全要求，而评测细则中明确要求网站必须通过https方式进行加密。
总结：
在申请获得SSL证书的时候，需要注意的就是证书的品牌机构，如果证书是在不正规的CA机构所申请的，那么这个证书的安全性就会被影响了。像JoySSL就是国产正规机构，提供免费版单域名证书，使用效果不错！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/153a7e8e30d66c7ee6d5052d8f544c3c/" rel="bookmark">
			2.文件加密没办法修改？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在文件加密的情况下，可以通过打印成OneNote或者WPS下的PDF模式，就可以修改了：）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8486a834b0c8b4ae886f6680a486899d/" rel="bookmark">
			1.如何减小ppt文件大小？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【文件】–【选项】–【常规与保存】–【将字体嵌入文件】适用于文件定稿不再进行修改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/285deafc9dbafba898fe16d6faeadadd/" rel="bookmark">
			rtl仿真器-incisive安装和测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要的文件 安装文件 incisive : http://pan.baidu.com/s/1dFC9KZn 提取码 k3cb
path:
license:
IScape: 安装的图形界面
IScape下载链接: https://pan.baidu.com/s/1FvpOto5fAIRjQARcbMbjZQ
密码: k1cb
目录结构 需要四个目录
安装目录:INCISIVE151
path 存放解密工具
license 存放密钥
incisiv151 存放安装文件
iscape 存放安装图形界面工具的
INCISIVE151 是最终的安装目录
安装步骤 安装iscape 解压InstallScape后，依次输入以下指令：
1.cd ./IScape （ 进入解压后软件包所放的目录）
2.sudo chmod -R 777 …/IScape （更改cadence文件夹的写入权限）
3.sudo zcat IScape04.23-s010lnx86.t.Z | sudo tar -xvf - (解压IScape04.23)
4.cd IScape/iscape/bin （进入iscape下bin文件夹）
5.sudo ./iscape.sh （启动IScape安装界面，如下图）
安装incisive 选安装镜像
选安装的版本
选择安装目录
安装
解 cd INCISIVE151/patch/
tar -xvf patch.tar
sudo cp -r patch cadence
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/285deafc9dbafba898fe16d6faeadadd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6b8c0f5cb727e16a2defe7c6b26f5b8/" rel="bookmark">
			libevent高并发网络编程 - 04_libevent实现http服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 evhttp简介2 相关的APIevhttp_new()evhttp_free()evhttp_bind_socket()evhttp_set_gencb()evhttp_set_cb()evhttp_request_get_uri()evhttp_request_get_command()evhttp_request_get_input_headers()evhttp_request_get_input_buffer()evhttp_request_get_output_headers()evhttp_add_header()evhttp_request_get_output_buffer()evhttp_send_reply() http服务器例子http服务器代码index.html文件运行效果 链接: C/C++Linux服务器开发/后台架构师【零声教育】-学习视频教程-腾讯课堂 1 evhttp简介 在libevent中，HTTP的实现主要是通过evhttp模块来完成的。evhttp提供了一个高层次的HTTP服务器接口，可以处理HTTP请求并发送HTTP响应。
在源码中，libevent的HTTP协议处理主要是通过evhttp模块来完成的。当客户端发起一个HTTP请求时，libevent将该请求解析为struct evhttp_request结构体表示，并调用用户设置的请求处理函数进行处理。
struct evhttp_request结构体定义了HTTP请求的各个字段，如请求行、请求头、请求正文等。例如，以下是struct evhttp_request结构体的部分定义：
struct evhttp_request { int major; // 主版本号 int minor; // 次版本号 enum evhttp_cmd_type type; // 请求方法（GET、POST等） char *uri; // 请求URI struct evkeyvalq *input_headers;// 请求头 struct evbuffer *input_buffer; // 请求正文 }; enum evhttp_cmd_type { EVHTTP_REQ_GET = 1 &lt;&lt; 0, EVHTTP_REQ_POST = 1 &lt;&lt; 1, EVHTTP_REQ_HEAD = 1 &lt;&lt; 2, EVHTTP_REQ_PUT = 1 &lt;&lt; 3, EVHTTP_REQ_DELETE = 1 &lt;&lt; 4, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6b8c0f5cb727e16a2defe7c6b26f5b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd3426f896daaba2a9ecab5ce30e5883/" rel="bookmark">
			libevent高并发网络编程 - 06_基于libevent的C&#43;&#43;线程池实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 功能简介线程池的初始化线程池执行流程 2 线程池类的设计线程类XThreadXThread.hXThread.cpp 线程池类XThreadPoolXThreadPool.hXThreadPool.cpp 任务基类taskXTask.h 3 自定义任务的例子自定义任务类ServerCMDServerCMD.hServerCMD.cpp 测试程序运行效果 链接: C/C++Linux服务器开发/后台架构师【零声教育】-学习视频教程-腾讯课堂 1 功能简介 本文利用libevent，实现一个C++线程池，，可自定义用户任务类，继承于任务task基类，重写任务基类的纯虚函数实现多态。比如将定义定义处理客户端的请求任务类，实现对客户端请求的并发处理。
工作队列：可以理解为线程的队列，一个线程同时可以处理一个任务，空闲的线程回从任务队列取出任务执行。当工作队列空时，线程会睡眠。
任务队列：用户将任务加入任务队列，然后通知工作队列，取出一个任务到线程中执行。
线程池的初始化 线程池执行流程 2 线程池类的设计 线程类XThread 线程类的接口功能 Start() -&gt;	管道可读就激活线程；设置管道属性；进入事件循环，等待管道可读激活线程执行任务 Setup() -&gt;	设置管道属性，将管道读事件绑定到event_base中，等待触发，调用回调 Main() -&gt;	此函数只进入事件循环，等待事件循环退出 Notify() -&gt;	读取管道数据，从当前线程对象的任务队列中取出任务，执行任务 AddTask() -&gt;	将任务对象加入线程对象的任务队列，将线程的事件处理器base，保存到任务对象中 Activate() -&gt;	通过管道发送启动标志，来激活线程，发送一个字符'c'激活相当于加入一个任务对象到当前线程的任务队列，通过Notify()处理。 调用多次Activate表示加入多个任务，任务顺序被执行。 XThread.h #pragma once #include &lt;vector&gt; /*线程类声明*/ class XThread; /*任务类声明*/ class XTask; /*线程池类*/ class XThreadPool { public: //单例模式创建返回唯一对象 static XThreadPool* GetInstance(); //初始化所有线程并启动线程 void Init(int threadCount); //分发线程 void Dispatch(XTask* task); private: //将构造函数的访问属性设置为 private //将构造函数构造声明成私有不使用 //声明成私有不使用 XThreadPool(){} //无参构造 XThreadPool(const XThreadPool&amp;); //拷贝构造 XThreadPool&amp; operator= (const XThreadPool&amp;); //赋值运算符重载 //线程数量 int threadCount = 0; //用来标记下一个使用的线程号 int lastThread = -1; //线程对象数组 std::vector&lt;XThread *&gt; threads; //线程池对象 static XThreadPool* pInstance; }; XThread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd3426f896daaba2a9ecab5ce30e5883/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ab9f5b5b74af393795ff718750e312a/" rel="bookmark">
			dp。P1164 小A点菜 ，洛谷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目背景 uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。
uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。
题目描述 不过 uim 由于买了一些书，口袋里只剩 �M 元 (�≤10000)(M≤10000)。
餐馆虽低端，但是菜品种类不少，有 �N 种 (�≤100)(N≤100)，第 �i 种卖 ��ai​ 元 (��≤1000)(ai​≤1000)。由于是很低端的餐馆，所以每种菜只有一份。
小 A 奉行“不把钱吃光不罢休”，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。
由于小 A 肚子太饿，所以最多只能等待 11 秒。
输入格式 第一行是两个数字，表示 �N 和 �M。
第二行起 �N 个正数 ��ai​（可以有相同的数字，每个数字均在 10001000 以内）。
输出格式 一个正整数，表示点菜方案数，保证答案的范围在 int 之内。
输入输出样例 输入 #1复制
4 4 1 1 2 2 输出 #1复制
3 定义一个二维数组f[n][m]
f[i][j]表示前i个菜花掉j元的方案数
则各种情况的判断如下：
if (j == arr[i])
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ab9f5b5b74af393795ff718750e312a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/016b439988a845645dbfe143bd992c52/" rel="bookmark">
			KVM（一）Linux部署KVM及新建虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、准备工作
1.1 防火墙、SElinux
二、安装KVM
2.1 yum源
2.2 安装工具包
2.3 安装KVM组件
2.4 查看磁盘/新建目录
2.5 安装Linux GUI可视化界面
三、KVM桌面版新建虚拟机
3.1 挂载目录
3.2 新建raw/qcow2文件
3.3 新建虚拟机
3.4 KVM命令行新建虚拟机
一、准备工作 1.1 防火墙、SElinux 关闭防火墙关闭防火墙自启动、关闭SElinuxg
systemctl stop firewalld systemctl disable firewalld 修改/etc/selinux/config 文件 将SELINUX=enforcing改为SELINUX=disabled 重启后生效 reboot 二、安装KVM 2.1 yum源 备份yum源且下载新yum源
[root@localhost ~]# cd /etc/yum.repos.d/ [root@localhost yum.repos.d]# mkdir bak [root@localhost yum.repos.d]# mv *.repo bak/ [root@localhost yum.repos.d]# curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo [root@localhost yum.repos.d]# ls bak CentOS-Base.repo 2.2 安装工具包 base是一个命令工具包，包含ifconfig、service、chkconfig等命令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/016b439988a845645dbfe143bd992c52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2abee32dd1a70bc361330dedf14902f/" rel="bookmark">
			KVM（二）命令行新建虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、准备工作
二、新建虚拟机
2.1 文件准备
2.2 正式安装
2.3 时区设置
2.4 安装设置
2.5 设置root用户密码
2.6 vm2安装完成
三、进入虚拟机vm2
四、网络设置
五、参考链接
若还未部署KVM，请参考第一节：
KVM（一）Linux部署KVM及新建虚拟机_luo_guibin的博客-CSDN博客
一、准备工作 1.1 开启透传 开启主机“透传”功能，新建kvm-nested.conf文件，需要重启服务器：
echo "options kvm_intel nested=1" &gt;&gt; /etc/modprobe.d/kvm-nested.conf “透传”：嵌套式虚拟nested是一个可通过内核参数来启用的功能。它能够使一台虚拟机具有物理机CPU特性,支持vmx或者svm(AMD)硬件虚拟化，比如具备在虚拟机里再建虚拟机的能力。
查询透传是否开启（Y或N）：
cat /sys/module/kvm_intel/parameters/nested 如果你没有重启服务器，是显示N的，重启后就会显示Y了。
二、新建虚拟机 2.1 文件准备 创建文件夹，镜像需先提前传入iso文件夹，推荐使用CentOS7.9Minimal版，minimal表示最小安装版本，比较简洁，大概1G。
centos-7.9.2009-isos-x86_64安装包下载_开源镜像站-阿里云
#新建文件夹 mkdir /kvm cd /kvm mkdir iso img cd /kvm/img #新建8G的qcow2格式的虚拟机存储，不会占用真实存储空间，用来存储虚拟机。 qemu-img create -f qcow2 /kvm/vm2.qcow2 8G #需提前将CentOS7.9镜像存放在/kvm/iso下 mv /kvm/iso/CentOS-7-x86_64-Minimal-2009.iso centos7.iso 2.2 正式安装 新建虚拟机，名为vm2，vcpu为1核，内存为2G，存放位置为/kvm/img/vm2.qcow2，镜像地址为/kvm/iso/centos7.iso。主要需要修改的地方是：n、r、vcpus、disk、location、network，根据实际情况更改。
virt-install \ -n vm2 \ -r 2048 \ --vcpus 1 \ --disk /kvm/img/vm2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2abee32dd1a70bc361330dedf14902f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6d6b1c03760bf2f07929baa624bbda9/" rel="bookmark">
			tinymce富文本编辑器使用到二开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tinymce tinymce 一款现代化的富文本编辑器，有专门团队维护，是目前主流的富文本编辑器选择。
安装注意事项：
有两种方案分别是安装对应的vue/react组件，然后直接用组件，或者直接使用tinymce去按原生操作会报找不到文件的错误，你需要把tinymce都复制
到public里 安装 tinymce 和 @tinymce/tinymce-vue （react组件 @tinymce/tinymce-react）
页面引入： &lt;template&gt; &lt;nav&gt; &lt;div id="mytinymce"&gt;&lt;/div&gt; &lt;/nav&gt; &lt;/template&gt; &lt;script setup&gt; import tinymce from "tinymce"; import { onMounted } from "vue"; onMounted(()=&gt;{ tinymce.init({ selector:"#mytinymce" // 选择节点树 }) }) &lt;/script&gt; &lt;style lang="less"&gt; &lt;/style&gt; 报错解决方案： 在node_modules文件夹中找到文件 复制放到public下 的js文件夹下
隐藏不需要的部分： 组件的使用方式： import Editor from "@tinymce/tinymce-vue"; let initObj = { selector: "#mytinymce", // 选择节点树 statusbar: true, menubar: true, toolbar: true, }; &lt;Editor id="mytinymce" :init="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6d6b1c03760bf2f07929baa624bbda9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d168d541c155bd47e898c40018736d/" rel="bookmark">
			‘android.support.v4.content‘ that cannot be safely rewritten错误解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在运行一些古老的开源项目时会遇到这样的问题:
The given artifact contains a string literal with a package reference ‘android.support.v4.content’ that cannot be safely rewritten. Libraries using reflection such as annotation processors need to be updated manually to add support for androidx.
引起这种问题的可能是ButterKnife的问题
具体报错信息如下： org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':app:javaPreCompileDebug'. Caused by: org.gradle.api.internal.artifacts.ivyservice.DefaultLenientConfiguration$ArtifactResolveException: Could not resolve all files for configuration ':app:debugAnnotationProcessorClasspath' Caused by: org.gradle.api.internal.artifacts.transform.TransformException: Failed to transform artifact 'butterknife-compiler.jar (com.jakewharton:butterknife-compiler:8.5.1)' to match attributes {artifactType=processed-jar, org.gradle.usage=java-runtime-jars}. Caused by: org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2d168d541c155bd47e898c40018736d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f4f9eae885344f610718e134bc3c06f/" rel="bookmark">
			Linux 用户账号管理-用户间切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 用户账号管理-用户间切换 在Linux系统中，管理用户账号是非常重要的。其中，用户间切换是经常用到的一种操作，可以切换到其他账户的身份以执行相关任务。本文将介绍Linux系统中用户间切换的方法，包括语法、实操和各种用户间切换方法之间的区别。
用户间切换命令 Linux系统中，有两种用户间切换的命令：su和sudo。
su命令 su命令是最基础的用户切换命令，可以在不退出当前用户的情况下，切换到其他用户的账户。通常，su命令会使用root账户或者其他特权用户的权限来执行命令。su命令的语法如下所示：
su [选项] 用户名 其中，选项表示su命令的操作参数，常用的选项有：
-：切换成指定用户，并连带该用户的工作环境（包括PATH变量、MAIL变量等）一起切换。-l或--login：在切换用户身份的同时，也完整切换工作环境。-p或--preserve-environment：表示切换为指定用户的身份，但不改变当前的工作环境（不使用切换用户的配置文件）。-c 命令：仅切换用户执行一次命令，执行后自动切换回来。 sudo命令 sudo命令用于临时授权普通用户执行特定的系统命令，可以实现不退出当前用户的情况下，执行特权操作。sudo命令的语法如下所示：
sudo [选项] 命令 其中，选项表示sudo命令的操作参数，常用的选项有：
-u 用户名：指定要切换到哪个用户下执行命令。-s：表示以root用户的权限执行命令。-i或--login：切换用户身份的同时，完整切换环境变量。 用户间切换实操 接下来，我们通过实操来演示su和sudo命令的使用。
su命令实操 使用su命令切换到root账户，并连带该用户的工作环境一起切换：
$ su - 密码： 使用su命令切换到其他账户（例如lamp）：
$ su - lamp 密码： 使用su命令执行一条命令后自动切换回来：
$ su -c "ls /root" 密码： su命令中选项的区别 命令说明su user以指定用户的身份执行命令su -切换为root用户并打开新的终端su - user切换到指定用户并打开新的终端 注：在终端输入su命令后不带user参数，表示切换到root用户身份。
su命令语法演示 su [options] [user] 其中，options表示su命令的操作参数，常用的选项有：
-：切换成指定用户，并连带该用户的工作环境（包括PATH变量、MAIL变量等）一起切换。-l或--login：在切换用户身份的同时，也完整切换工作环境。-c 命令：仅切换用户执行一次命令，执行后自动切换回来。 注：当命令中没有指定user时，会默认切换为root账户。
su命令使用实操例子 假设当前用户为user1，我们需要切换到user2账户并执行一条命令，可以使用以下命令：
su -c "command" user2 其中，command表示要执行的命令。这样就可以在不退出当前用户的情况下，以user2的身份执行该命令了。
注：如果当前用户没有sudo权限，则需要知道目标用户的密码才能切换。
sudo命令实操 使用sudo命令执行一个需要特权的命令：
$ sudo apt-get install nginx 使用sudo命令切换到root账户下，并完整切换环境变量：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f4f9eae885344f610718e134bc3c06f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a2445a5df2c58046c44faa021163a99/" rel="bookmark">
			如何将map与对象进行转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot内置了一个强大的JSON转换器Jackson，可以实现将JSON字符串或Map类型的数据转换成Java对象。以下是将Map类型的数据转换成Java对象的示例代码：
import com.fasterxml.jackson.databind.ObjectMapper; //定义Java对象 public class User { private String name; private int age; //getters和setters } //转换Map成Java对象 ObjectMapper objectMapper = new ObjectMapper(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("name", "Tom"); map.put("age", 25); User user = objectMapper.convertValue(map, User.class); 在上面的代码中，我们使用了ObjectMapper的convertValue方法，将Map类型的数据转换成User类型的Java对象。
需要注意的是，转换过程中，必须保证Map的key和Java对象的属性名一致，否则会出现转换失败的情况。同时也需要引入Jackson的依赖，这里提供Maven坐标：
&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt; &lt;/dependency&gt; 若对象的属性比map还要多，但是我想将匹配的对象进行赋值，怎么办？
如果对象的属性比map还要多，可以使用JavaBean的属性拷贝工具类，例如Apache Commons BeanUtils的BeanUtils类，进行转换。以下是示例代码：
import org.apache.commons.beanutils.BeanUtils; //定义Java对象 public class User { private String name; private int age; private String email; //getters和setters } //转换Map成Java对象 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a2445a5df2c58046c44faa021163a99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f48c3805ea1597ce3f2c652c66671ae/" rel="bookmark">
			中文Python（5）中文Python的while条件循语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文Python（5）中文Python的while条件循语句
Python是一种流行的编程语言，其简单而直观的语法吸引了很多人学习和使用。中文Python则是针对中文用户开发的一种版本。中文Python原先为了给不懂编写程序的人写量化程序，我们开发了中文Python编辑系统，并提供了开发工具小白量化中文Python研学实控系统CPIDE。这个开发工具支持中文关键字Python语法，降低了学习Python难度。同时支持英文关键字Python语法，支持中英关键字转换等多个功能。
在中文Python中，我们同样可以使用while语句来实现循环操作。
while语句是一种循环结构，它能够反复执行某个代码块，直到指定条件不满足为止。在Python中，while语句的语法如下：
while 布尔表达式: 循环语句体 其中，布尔表达式的值为True或False。只有当为True时，while语句才会反复执行循环语句体。
下面，让我们看几个简单的例子，来理解while语句的具体用法。
例1：计算1到100的总和
sum = 0 i = 1 while i &lt;= 100: sum = sum + i i = i + 1 print("1到100的总和为：", sum) 在这个例子中，我们使用while语句来计算1到100的总和。首先，我们定义两个变量sum和i，分别用来存储总和和当前的数字。然后，我们使用while语句来反复执行计算操作，直到i大于100为止。在每次循环中，我们都要更新sum和i的值，以便继续执行下一次循环。
例2：猜数字游戏
import random number = random.randint(1, 100) guess = 0 while guess != number: guess = int(input("请猜一猜数字是多少：")) if guess &gt; number: print("猜大了！") elif guess &lt; number: print("猜小了！") print("恭喜你，猜对了！") 在这个例子中，我们使用while语句来实现一个简单的猜数字游戏。首先，我们随机生成一个1到100之间的数字，然后让用户一遍又一遍地猜测。在每次猜测中，我们都要使用if语句来判断猜测的数字与随机数的大小关系，并输出相应的提示信息。只有当用户猜中了这个数字，while语句才会停止执行。
这些例子虽然比较简单，但它们展示了while语句的强大之处。通过使用while语句，我们能够实现很多有趣和实用的功能，例如计算总和、查找最大值、猜数字游戏等等。
如和用中文Python怎么写猜数游戏呢，我们下面给一个中文Python猜数游戏代码。
#猜数游戏 #中文Python学习交流811379766 导入 random 从 hanhua 导入 * 我的数字=random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f48c3805ea1597ce3f2c652c66671ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0ba63eb42e7a3176bd7ac96bb2e2e0/" rel="bookmark">
			中文Python（4）中文Python的if语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文Python（4）中文Python的if语句
在Python语法中，if语句作为最常用的逻辑控制语句之一，发挥着重要的作用。if语句可以根据条件的真假来执行相应的代码块，常常用于判断数据或用户行为等。在中文Python中，if语句同样有着高度的易读性，帮助开发者更加简单易懂地完成程序开发。
一、Python语法中的if语句
在Python中，if语句一般由条件语句和一段需要被执行的代码组成。比如：
if 10 &gt; 5: print("10大于5") 此语句的执行逻辑为：如果10大于5，则执行代码块中的print语句，输出“10大于5”。
如果if语句中的条件为假，则跳过当前代码块，执行下一个语句。
if 10 &lt; 5: print("10小于5") print("条件不成立") 此语句的执行逻辑为：由于10不小于5，if语句的代码块将不会被执行，直接输出下一行代码块，输出“条件不成立”。
二、中文Python的if语句
在中文Python中，if语句的特点就在于高度的易读性。从语句的结构到关键字的翻译，都考虑了中文读者的习惯和理解。
比如，在上述Python语法的if语句中，可以使用中文Python的if语句改写：
如果 10 &gt; 5: 输出("10大于5") 同样，条件语句中的关键字也可以使用中文改写：
如果 数字 &gt; 0 : 输出("数字大于0") 这种语句在阅读和理解时更加符合中文读者的习惯和认知，能够简化程序开发过程中的思维负担，让代码更加易于理解和维护。
三、if语句的嵌套
在实际的程序开发中，if语句往往需要进行嵌套，以处理更加复杂的逻辑控制。
比如，我们需要判断一个数值是否在某个范围之内：
数字 = 3 如果 数字 &gt; 0 : 如果 数字 &lt; 10 : 输出("数字在0到10之间") 上述语句中，if语句进行了嵌套，分别对数字的大小进行了判断，如果数字既大于0又小于10，则输出“数字在0到10之间”。
四、中文Python示例
我们用中文Python编写一个程序做一个简单的示例。
#中文Python学习交流群934165481 输出() #英文成绩=88 #ABCDE 英文成绩2=输入('请输入英文成绩:') #输入字符串 英文成绩=int(英文成绩2) #字符串转为数字 如果 英文成绩&gt;=0 并且 英文成绩&lt;20: 输出('成绩E') 否则如果 英文成绩&gt;=20 并且 英文成绩&lt;40: 输出("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf0ba63eb42e7a3176bd7ac96bb2e2e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/701c4ca4258d9b67ff5a1b56f8cd2670/" rel="bookmark">
			Centos7上搭建hadoop2.6.5详细图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本 VM 15 Pro
Centos 7
Hadoop 2.6.5
FinalShell 3.9.2.2
步骤 1. 安装虚拟机、Centos，配置网络环境 创建虚拟机；配置网络；配置操作系统；进入GUI界面配置；配置静态网络并验证网络连通性；使用FinalShell连接Centos 详细步骤：
VMWare上搭建Centos7并配置网络用FinalShell连接（详细图文教程）
2. 创建三台虚拟机并相互连通 （1）克隆虚拟机 先关闭虚拟机
鼠标右键单击Master虚拟机，点击管理里的克隆
点击下一步
创建完整克隆
完成克隆
再根据自己需求去调整Slave1的内存和磁盘大小
以此方式，再克隆出Slave2
参考文章:
虚拟机的克隆（带图详解）
（2）连通三台虚拟机网络 1）修改主机名，以Master为例 sudo vi /etc/hostname Slave1和Slave2，分别修改为slave1和slave2
reboot重启，使主机名生效
2）根据设置的IP地址范围，规划网络 再进入centos中，修改配置主机配置文件
三个节点中都需要更改，以Master为例
[admin@master ~]$ sudo vi /etc/hosts 规划master、slave1和slave2的IP地址如上
再更改网络接口配置信息，三个节点中都需要更改，以master为例：
sudo vi /etc/sysconfig/network-scripts/ifcfg-ens33 在Slave1和Slave2中的IPADDR分别改为192.168.44.102和192.168.44.103
再输入命令行重启网络服务：
sudo service network restart | systemctl restart network.service 验证宿主机和虚拟机之间的连通性，虚拟机上的DNS服务
正常连通，salve1和slave2的方式同上
再在FinalShell上设置三个主机的连接信息
3）关闭系统防火墙和内核防火墙 由于hadoop中的程序都是网络服务，需要监听端口，这些端口默认会被linux防火墙挡住。因此要把hadoop中的端口一个个打开，或者把防火墙关掉。由于都是内网，所以将三台虚拟机的防火墙直接全部关闭就行
永久关闭内核防火墙
输入命令行sudo vi /etc/selinux/config
先临时关闭防火墙
sudo systemctl stop firewalld
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/701c4ca4258d9b67ff5a1b56f8cd2670/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad5f1c738bc63992b225da35d31e3ef9/" rel="bookmark">
			基于Java的员工考勤系统设计与实现(论文&#43;源码)_kaic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
随着企业信息化建设的程度逐渐完善。学企业内部的各类管理工作需要依托信息化的管理平台进行数据的整合以及维护。培训系统、部门管理系统、招聘系统、宿舍管理系统的结合以及应用，对于企业的企业内管理来说具有重要的作用随着企业内数据管理需求的不断增多，企业考勤管理作为众多管理工作的一种，需要针对每个员工、考勤人员的考勤需求进行数据的维护。避免员工缺勤以及老师缺勤的情况发生，以及需要对各类数据进行存储，能够规范化企业内秩序，使员工的办公质量不断的增高。基于此目的，根据企业、员工以及考勤人员的考勤管理需求，进行企业考勤管理系统的开发。
本系统为基于SSM框架的企业考勤管理系统，根据企业内企业考勤管理需求以及办公秩序的管理要求，需要针对考勤管理需求进行数据的整合，以信息化的管理模式搭建线上平台，并将考勤相关的数据存储在MYSQL数据库当中，进行数据的统一管理，并根据实际业务需求分为不同的用户角色，规范化数据的维护，使系统的实际应用更符合企业的业务需求。系统功能主要包括员工考勤管理、考勤人员考勤管理、站内消息管理，系统公告管理等等。根据考勤管理需求，搭建线上平台，完成企业考勤管理系统的开发与实现。
系统完成后，可以对考勤数据进行实时更新，并根据考勤记录的统计来了解员工与考勤人员的出勤情况。规范化企业内的企业考勤管理秩序可以减少管理工作所投入的时间和成本。企业考勤管理系统满足企业信息化建设的需求，针对考勤和企业考勤管理秩序的要求，能够简化管理流程，提高管理效率。
关键词 企业考勤管理系统，SSM框架，MySQL
Abstract
With the gradual improvement of the degree of informatization construction in colleges and universities. All kinds of management work within the school need to rely on the information management platform for data integration and maintenance. The combination and application of examination system, course management system, course selection system and dormitory management system play an important role in the school's internal managementWith the increasing demand for school data management, classroom management as one of many management work, needs to maintain data for the classroom attendance needs of each student and teacher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad5f1c738bc63992b225da35d31e3ef9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4064cf593062e44711b3d6a259ab399c/" rel="bookmark">
			BI技巧丨计算组柱形图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PowerBI中，我们经常使用柱形图来进行趋势对比分析，通过柱形图我们可以直观展示每个月之间的差异。
但是在实际需求中，PowerBI原生的柱形图仅能展示一个数据标签，如果我们想要展示同环比的变化情况，往往需要将同环比的度量值放置到工具提示中。
这对用户来说，体验其实是很不友好的，用户期望的往往是一眼可以获取到所有想知道的关键信息。
面对用户的这一需求，我们可以通过计算组来实现。
案例数据：
将其导入到PowerBI中，通过以下代码，添加日期表。
Date = GENERATE ( CALENDAR ( MIN ( 'Sales'[DATE] ), MAX ( 'Sales'[DATE] ) ), VAR DA = [Date] VAR YEAR = YEAR ( DA ) VAR QUARTER = "Q" &amp; FORMAT ( DA, "Q" ) VAR MONTE = FORMAT ( DA, "MM" ) VAR DAY = DAY ( DA ) RETURN ROW ( "Year", YEAR, "Quarter", QUARTER, "Month", MONTE, "DayOfMonth", DAY, "YearQuarter", YEAR &amp; QUARTER, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4064cf593062e44711b3d6a259ab399c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c37bf51eabf5e618f030b94a073a688/" rel="bookmark">
			Mybatis多表联查的几种办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 开发过程中，对数据库多表连接查询是常规操作。Mybatis（plus）在多表连接查询上提供了很好的支持。通常，表与表之间存在四种映射关系：一对一映射、多对一映射、一对多映射、多对多映射。在处理的过程中，多对一和一对一映射一般采用同一种操作方式，一对多和多对多映射一般采用同一种操作方式。而且，对于Mybatis的运用，我们通常使用xml的方式。因此，本文主要介绍xml方式下一对一多表联查和一对多多表联查。
一、一对一多表联查 1.1 两表联查 在数据库中建立学生表和专业表两张数据表，并假设一个学生只有一个专业。表结构大致如下
DROP TABLE IF EXISTS `student`; CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL, `birthday` date DEFAULT NULL, `phonenum` varchar(20) DEFAULT NULL, `mid` int(11) NOT NULL, PRIMARY KEY (`stu_id`) USING BTREE, ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC; DROP TABLE IF EXISTS `major`; CREATE TABLE `major` ( `mid` int(11) NOT NULL AUTO_INCREMENT, `mname` varchar(255) DEFAULT NULL, PRIMARY KEY (`oid`) USING BTREE, ) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC; 在运用Mybatis进行数据查询前，需要先建立实体类模型。在实体类建立的过程中，应当注意：在假设前提下，每名学生有一个专业，在类属性中需包含专业对象。学生实体类大致如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c37bf51eabf5e618f030b94a073a688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64e803e8140f24db9046ac9132b62031/" rel="bookmark">
			哨兵二号（Sentinel-2）数据下载方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欧空局数据下载链接：https://scihub.copernicus.eu/dhus/#/home
登录/注册账号后，按下图所示进行操作：
搜索后选择适合的影像数据，加入购物车后点击下载按钮；
部分数据可以直接进行下载；
如果下载不成功（不论弹出什么窗口）我们只需等待3~5小时后便可正常进行下载。
（注：浏览器下载速度慢的话，可以使用迅雷进行下载，30min可下载一个影像。）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc26684b9f5a8600f133cfc1fede81f2/" rel="bookmark">
			MMCV注册机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
1. Introduction
2. MMCV核心组件——Config &amp; Registry 2.1 Config类
2.2 从配置文件中生成Config类
2.3预定义变量解析
2.4 配置文件的继承
2.5 Registry
2.6 示例 2.7 自定义构建函数（Build Function）
2.8 层次注册
引言 MMCV学习 最近在学习mmcv这个基础库，所以写一个博客记录一下。一来是作为学习笔记，方便日后查阅，二来是和大家分享交流一下我得学习心得。mmcv是由OpenMMLab开源的一个计算机视觉的基础库，支持了OpenMMLab众多开源的优秀仓库(比如，MMDetection、MMSegmentation、MMSelfSup等等)。
1. Introduction mmcv作为一个基础库，主要提供了以下的功能模块：
统一可扩展的 io api支持非常丰富的图像/视频处理算子图片/视频的标注文件可视化常用的工具类例如 timer 和 progress bar 等等上层框架需要的 hook 机制以及可以直接使用的 runner高度灵活的 cfg 模式和注册器机制高效高质量的 cuda op 2. MMCV核心组件——Config &amp; Registry 2.1 Config类 官网解释：
Config class is used for manipulating config and config files. It supports loading configs from multiple file formats including python, json and yaml.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc26684b9f5a8600f133cfc1fede81f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0db263db42ff428e6311cb48a7fa7b4a/" rel="bookmark">
			C&#43;&#43;游戏开发——坦克大战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言： 就是练C++而已的。
代码： 工具类
lag.h
#pragma once #include &lt;time.h&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;conio.h&gt; #include &lt;stdlib.h&gt; #include &lt;iostream&gt; #include &lt;windows.h&gt; #include &lt;graphics.h&gt; #include &lt;mmsystem.h&gt; #pragma comment(lib,"winmm.lib") // 播放音频 using namespace std; /* 功能：窗口居中 参数：hWnd-窗口句柄 */ void myCenterWindow(HWND hWnd); /* 功能：得到某范围内的随机整数 参数：min - 最小值 max - 最大值 返回：某范围内的随机整数 */ int myRandom(int min, int max); /* 功能：定时器 参数：interval - 延时间隔（毫秒） id - 编号 (0-max) 返回：true-已到时，false-未到时 */ bool myTimer(int interval, int id); /* 功能：播放音频 参数：fileName - 音频文件 repeat - 是否循环播放（true-循环，false-不循环） 返回：无 */ void myPlayAudio(const string&amp; fileName, bool repeat = false); /* 功能：判断某键是否被按下 参数：keyCode - 键值 返回：true-按下，false-未按下 */ bool myKeyDown(int keyCode); /* 功能：判断两个矩形是否相交 参数：x1 - 第一个矩形的左上角X坐标 y1 - 第一个矩形的左上角Y坐标 w1 - 第一个矩形的宽度 h1 - 第一个矩形的高度 x2 - 第二个矩形的左上角X坐标 y2 - 第二个矩形的左上角Y坐标 w2 - 第二个矩形的宽度 h2 - 第二个矩形的高度 返回：true-相交，false-不相交 */ bool myRectIntersectRect(int x1, int y1, int w1, int h1, int x2, int y2, int w2, int h2); /* 功能：绘制透明图片 参数：dstX - 目的X坐标 dstY - 目的Y坐标 pSrcImg - 源图像指针 winWidth - 窗口宽度（判断图片位置是否超出窗口范围，不录则默认为0，表示该参数不用） winHeight - 窗口高度（判断图片位置是否超出窗口范围，不录则默认为0，表示该参数不用） 返回：无 */ void myDrawImage(int dstX, int dstY, IMAGE* pSrcImg, int winWidth = 0, int winHeight = 0); /* 功能：绘制字符串 参数：text - 字符串内容 x - X坐标 y - Y坐标 返回：无 */ void myDrawString(int x, int y, const string&amp; text); lag.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0db263db42ff428e6311cb48a7fa7b4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101fc9c38b899a213ffcccc9278d4a12/" rel="bookmark">
			MyBatis映射（一对多查询）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.一对多查询
2.1 数据库准备
2.2 实体类
2.2.1 Orders.java
2.2.2 Users.java
2.3 用户配置接口
2.3.1 OrdersMapper.java
2.3.2 UsersMapper.java
2.4 用户配置文件
2.4.1 OrdersMapper.xml
2.4.2 UsersMapper.xml
2.5 解决办法
2.5.1 嵌套查询方式
1.一对多查询 2.1 数据库准备 代码：
USE mybatis; # 创建一个名称为tb_user的表 CREATE TABLE tb_user ( id int(32) PRIMARY KEY AUTO_INCREMENT, username varchar(32), address varchar(256) ); # 插入3条数据 INSERT INTO tb_user VALUES ('1', '小明', '北京'); INSERT INTO tb_user VALUES ('2', '李华', '上海'); INSERT INTO tb_user VALUES ('3', '李刚', '上海'); # 创建一个名称为tb_orders的表 CREATE TABLE tb_orders ( id int(32) PRIMARY KEY AUTO_INCREMENT, number varchar(32) NOT NULL, user_id int(32) NOT NULL, FOREIGN KEY(user_id) REFERENCES tb_user(id) ); # 插入3条数据 INSERT INTO tb_orders VALUES ('1', '1000011', '1'); INSERT INTO tb_orders VALUES ('2', '1000012', '1'); INSERT INTO tb_orders VALUES ('3', '1000013', '2'); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/101fc9c38b899a213ffcccc9278d4a12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bd3ff08542a2aab5df8ceaa3a3f7656/" rel="bookmark">
			我的CSDN文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 指令集架构篇SOC原理篇linux篇裸机篇虚拟化篇简单总线篇复杂协议及总线篇无线协议篇工具篇我的小项目 指令集架构篇 ARMv7&amp;ARMv6
ARMv8
RISCV32+RISCV64
RISC 指令集 各个实现指令集与寄存器对比
SOC soc架构 原理篇 buildroot 实例&amp;buildroot框架external debug - 基于 jtag linux篇 linux 硬件架构相关代码 视图u-boot 实例,基于ok6410linux 设备管理linux驱动框架linux内存管理 第一刷linux驱动中的低速总线协议相关框架 i2s sdio spi gpio i2c uartlinux 第二刷 大而全 裸机篇 cortex-m单片机裸机存储管理 虚拟化篇 QEMU-KVM 简单总线篇 i2s sdio spi gpio i2c uart 复杂协议及总线篇 接口 总线 协议 [总线协议基础
[高速总线协议基础
以太网协议
USB协议
PCIe总线
无线协议篇 [无线通信基础,射频蓝牙协议[WIFI协议 工具篇 svn &amp; gitapt &amp; yumgdbnfs &amp; samba &amp; tftp 我的小项目 基于ok6410a 的整体系统移植,包括u-boot,linux,buildroot基于LFS,搭建的x86 OS一步步写嵌入式操作系统-ARM编程的方法与实践 的 代码演练兼容arm32/arm64/rv32/rv64的一个裸机工程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9046c43219d8e25796dad413cba8e089/" rel="bookmark">
			linux添加超级用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Linux中，可以通过以下步骤添加超级用户（即具有root权限的用户）： 1.以root用户登录系统。 2.打开终端或控制台，并输入以下命令以创建新用户：
sudo adduser &lt;username&gt;
其中，&lt;username&gt;是新用户的用户名，可以根据实际需要进行替换。 3.设置新用户的密码：
sudo passwd &lt;username&gt;
其中，&lt;username&gt;是新用户的用户名。 4.将新用户添加到sudoers文件中，以授予其sudo权限：
sudo usermod -aG sudo &lt;username&gt;
其中，&lt;username&gt;是新用户的用户名。 5.注销当前用户并用新用户重新登录系统，以确保sudo权限已生效。 注意：使用超级用户权限时需要格外小心，以免对系统造成意外的损坏。
-aG：-a表示追加（append），-G表示用户组（group），这个选项的意思是将用户加入到指定的用户组中。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1652264068eda69363223d15cf8e4ec/" rel="bookmark">
			使用SpringBoot记录用户操作日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工作中我们可能会遇到一个需求，就是记录用户的操作信息，接下来使用spring的aop特性实现这一需求
一、首先引入我们必要的一些依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- aop依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- oracle驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;6.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid数据源驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; 二、自定义一个注解，用于标注需要监控的方法
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Log { String value() default ""; } 三、在数据库中创建一张表，用来保存用户的操作日志
字段可以有 用户名 用户操作 请求方法 请求参数 响应时间 IP地址和创建时间
CREATE TABLE "SCOTT"."SYS_LOG" ( "ID" NUMBER(20) NOT NULL , "USERNAME" VARCHAR2(50 BYTE) NULL , "OPERATION" VARCHAR2(50 BYTE) NULL , "TIME" NUMBER(11) NULL , "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1652264068eda69363223d15cf8e4ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84fb2f1060ebcc0c4b1e838cfeae009f/" rel="bookmark">
			STM32CubeMX(14) ——基于Cubemax的FreeRTOS移植与LED点灯测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FreeRTOS移植与LED点灯测试 前言
一、CubeMax移植FreeRTOS
时钟配置 时钟树配置
嘀嗒时钟配置
FreeRTOS配置
FreeRTOS任务配置
IO口配置
二、代码编写
前言 之前的代码其实一直都是裸机在跑，即本质上就是在一个while(1)中在跑，这对于任务量较小的程序来说，没有什么问题。但最近遇到一些工程性的代码，其参考代码均采用了FreeRTOS操作系统，以此来记录一下自己的学习过程。
一、CubeMax移植FreeRTOS 废话不多说，想把FreeRTOS配置起来，再说一些其他东西。
时钟配置 时钟树配置 这个地方主要根据自己的开发板配置下面两个部分
嘀嗒时钟配置 如果使用FreeRTOS，嘀嗒时钟源要使用定时器产生的，这里不说原因，先配置就好。
FreeRTOS配置 这里下面的配置功能，等有特殊功能需要，再介绍，这里不需要动（其实也就是打开或者关闭一些功能）
FreeRTOS任务配置 我们这里配置两个任务来实现两个LED的翻转任务。
主要点击Tasks and Queues的Taks下的add来添加任务，我这里已经添加了两个了。
里面的一些配置主要就是有关任务优先级，堆栈大小，入口函数名字等。
IO口配置 简单配置两个LED的IO口
然后生成代码就OK了。
二、代码编写 生成代码后，我们点开生成的freertos.c文件
在文件里可以看到创建的两个任务的入口函数名字，在其中编写LED翻转代码即可。这里用了osDelay函数，现在简单的把他当成是ms级延长就可以。
下载程序，如果两个LED闪烁时间不一致，就代码移植配置成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af6a051ae222f0ad81de1f6cf7b0c088/" rel="bookmark">
			STM32CubeMX(10) ——利用一阶卡尔曼滤波处理超声波数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用卡尔曼滤波处理超声波数据 文章目录 利用卡尔曼滤波处理超声波数据前言一、卡尔曼滤波1.预测方程第一个方程第二个方程 2.更新方程观测矩阵第三个方程第四个方程第五个方程 二、代码1.创建有关卡尔曼滤波的结构体2.初始化3.一维卡尔曼滤波函数 实验结果总结 前言 上节我们通过中断捕获，得到了超声波返回的数据，但可以看到，由超声波模块返回的数据含有噪音，这次，我们将使用卡尔曼滤波去处理超声波的数据，使得在后续的处理中更加方面和稳定。
STM32 Cubemax(九) ——利用输入捕获中断实现超声波测距
一、卡尔曼滤波 如果对卡尔曼滤波没有了解的同学，建议看看下面的视频，个人感觉讲的比较清楚和透彻。
【官方中字】什么是卡尔曼滤波器 (Kalman Filters) ？(全7P) MATLAB&amp;Simulink
我们这里重点讲如何应用卡尔曼滤波的五个方程到我们实际中。
1.预测方程 第一个方程 第一个方程表示的是——当前最优的先验预测值 = 上一次的最优后验值 + 当前的输入值
参数含义：A表示的是 NxN 的状态转移矩阵，B是当前输入增益矩阵。
在我们超声波的案例，A是等于一的，因为我们是静态测量，正常来说，当前的值应该和上一次的值没有很大区别。如果我们不是静态测量，假如是具有匀速运动关系。则我们这时候的x最优估计值包含位置p和速度v两个参量， 根据运动公式可以等到下式。
而我们的整个系统是不存在输入的，则B等于0。
—————————————————————————————————————————————
第二个方程 第二个方程表示的是——当前预测协方差矩阵 = 上一次的最优协方差矩阵 + 过程噪声
参数含义：这个方程的公式是由协方差矩阵的公式推导的。
其中Q代表过程噪声，也是我们卡尔曼滤波中需要调节的参数之一，其代表运动模型过程中忽略的噪声因素，比如小车在运动过程中，常常忽略摩擦力，而在我们本例超声波中，不存在明显的影响因素，可以直接设定为0
—————————————————————————————————————————————
2.更新方程 在讲更新方程前，还有一个方程为观测矩阵。
观测矩阵 这个方程代表的是——观测量 = 测量量 * 增益 + 测量噪声
在本实验中，我们的观测量即等于传感器测量的值，故H=1。举个例子，一个系统的位置P（x，y）由x的测量量和y的测量组成，此时既有
而测量噪声，则是传感器本身带有的噪声，是我们这次重点调参的对象。
—————————————————————————————————————————————
第三个方程 先说明一下，观察矩阵的H和卡尔曼增益计算中的C是同一个东西，不同的写法。
第三个方程即为卡尔曼增益的计算公式，这个参数本质上的意思相当于是一个比例，代表我们是相信预测值的比重大还是相信测量值的比重大的一个权重。
—————————————————————————————————————————————
第四个方程 第四个方程，即表示当前的最优值 = 预测值与测量值的一个权重比例加和。
如果更加相信预测值，此时卡尔曼增益Kg应该小。
如果更加相信测量值，此时卡尔曼增益Kg应该大
—————————————————————————————————————————————
第五个方程 第五个方程即为更新协方差矩阵。
在本实验中为一维数据，I=1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af6a051ae222f0ad81de1f6cf7b0c088/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5eda4e63f60699b87fb230c5b2dae91/" rel="bookmark">
			STM32CubeMX(7) —— 单级PID控制带编码器的直流减速电机速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单级PID控制带编码器的直流减速电机速度 目录
STM32 Cubemax(七) —— 单级PID控制带编码器的直流减速电机速度
文章目录
前言
一、PID控制
二、PID代码
三、利用PID控制器控制电机输出
四、如何确定PID中的参数
总结
前言 前面的文章介绍了如何去读取带编码器电机中编码器的值，并对此值进行处理得到了电机当前的转速值。而带编码器的电机最大的作用也就是可以让我们得到电机的速度反馈，利用PID或者其他控制算法，去控制其达到我们设定的速度。
如有看电机控制相关，请先看看我的上篇博客
STM32 Cubemax(六) —— STM32利用定时器编码器模式处理带编码器直流电机
一、PID控制 PID控制作为一种经典的控制算法，如果你听过这个控制算法，那你也一定对其有算了解了，不管是书还是各种网站视频，都有讲的十分好的教程，如果对此还有不了解的，可以去b站或者CSDN上看看相关视频，具体原理这里就不多阐述了。
而我们这次要控制的对象则为电机的速度，我们很容易可以得出下图。
我们的目标即是通过编码器得到的速度值，通过PID控制器，来控制电机达到我们预定的设定值。
二、PID代码 我们首先创建PID.h文件并在其中定义有关PID的结构体 #define LIMIT(x,min,max) (x)=(((x)&lt;=(min))?(min):(((x)&gt;=(max))?(max):(x))) //限幅定义 typedef struct _PID { float kp,ki,kd; //PID的三个参数 float error,lastError; //当前误差和上一次的误差 float integral,maxIntegral; //积分量和积分的限幅 float output,maxOutput; //PID的输出量和PID的最大输出量 }PID; 2. 定义PID的初始化函数
//PID初始化函数 void PID_Init(PID *pid,float p,float i,float d,float maxI,float maxOut) { pid-&gt;kp=p; pid-&gt;ki=i; pid-&gt;kd=d; pid-&gt;maxIntegral=maxI; pid-&gt;maxOutput=maxOut; } 3.最后是关键的PID计算函数，其实也十分简单，就是根据PID的原理编写
//单级PID计算，需要传入的参数，PID结构体，目标值，反馈值 void PID_SingleCalc(PID *pid,float reference,float feedback) { pid-&gt;lastError = pid-&gt;error; //更新上一次的误差 pid-&gt;error = reference-feedback; //更新当前误差 //下面分别是P，I，D的计算 pid-&gt;output += pid-&gt;error*pid-&gt;kp; //P为根据当前误差计算输出量 pid-&gt;integral += pid-&gt;error*pid-&gt;ki; //I为累计误差的输出量 LIMIT(pid-&gt;integral,-pid-&gt;maxIntegral,pid-&gt;maxIntegral); //限制I的输出，抑制超调 pid-&gt;output += pid-&gt;integral; pid-&gt;output = (pid-&gt;error - pid-&gt;lastError)*pid-&gt;kd; //D以当前误差减去上次误差作为微分环节 LIMIT(pid-&gt;output,-pid-&gt;maxOutput,pid-&gt;maxOutput); //限制PID总输出 } 三、利用PID控制器控制电机输出 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5eda4e63f60699b87fb230c5b2dae91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daa4b6d488ddd6194ad992104abec6d1/" rel="bookmark">
			Python数据分析教程08：pandas进行外卖订单数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
功能点1：将订单以天为单位输出为单个文件
功能点2：提取数据表某列中，不是某个给定值的数据
功能点3：统计一个订单从下单到完成配送时刻之间的时间差
功能点4：绘制订单的持续时间曲线
功能点5：提取数据库中的某些以符号区分的订单
功能点6：按照某个给定的规则进行数据统计
功能点1：将订单以天为单位输出为单个文件 该功能点的实现思路为首先根据下单时间，确定每个订单是几号，然后根据几号进行数目分组，并将分组结果逐天导出为单个的excel文件。
testData = pd.read_excel('2016年11月.xlsx') # 读取测试数据 testData['stime'] = testData['下单时间'].astype('datetime64') # 获取下单时间数据列，将其转化为时间戳 testData['day'] = testData['stime'].dt.day # 新建day列，将其标记为每天的天数 separatedDataList = list(testData.groupby(['day'])) # 按天进行数据分组 for separatedData in separatedDataList: # 列表中每个元素包含2个部分：第0部分为分组数字，也就是几号；第1部分是一天的数据 ouname = separatedData[0] print(ouname) separatedData[1].to_excel(f'cf/{ouname}.xlsx') # 数据导出到excel表格 功能点2：提取数据表某列中，不是某个给定值的数据 在外卖订单中，订单被分为两类，一类是预约订单，也就是顾客下单后并不要求立即送达，而指定一个较晚的时间送达；例如一个顾客8:00AM下单，希望下午18:00PM送达；一类是即时订单，也就是顾客下单后，必须在其下单后的45分钟内完成配送。下面代码的目的是从数据表中提取即时单。
filterData = testData[~testData['是否及时单'].str.contains('预约')] 如果要获取预约单，对应的代码为：
​filterData = testData[testData['是否及时单'].str.contains('预约')] 功能点3：统计一个订单从下单到完成配送时刻之间的时间差 def calDurationTime(): ''' 计算订单的持续时间，并转化为分钟 :return: 以分钟为单位计算的订单持续时间 ''' testData = pd.read_excel('data20c.xlsx') # 读取测试数据 xiadanSJ = testData['下单时间'] # 读取起始事件的时刻 wanchengSJ = testData['完成时间'] # 读取结束事件的时刻 diff = wanchengSJ-xiadanSJ # 单位为秒 diffMin = [d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daa4b6d488ddd6194ad992104abec6d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2942e4b87f706ed079575e863501a9bd/" rel="bookmark">
			如何安装Anaconda（linux版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 更多软件安装 详见&gt;&gt;
常用开发软件安装 目录导航帖
1 所需材料 首先打开Anaconda官网，下载对应平台的安装包
Anaconda官网
我们这里安装的包是Anaconda3-2022.05-Linux-x86_64.sh
2 安装步骤 接下来开始正式安装Anaconda，打开terminal，将安装包上传到服务器，运行命令
bash Anaconda3-2022.05-Linux-x86_64.sh 等待安装，安装结束后，在terminal输入python，应该能够跳转到解释器：
至此，Anaconda就成功安装完毕了！
3 更换镜像源 初始化.condarc文件
conda config --set show_channel_urls yes 此时，输入命令ls -alh，可以看到已经有.condarc文件了
修改.condarc文件成如下所示：
vi .condarc PC端
channels: - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - http://mirrors.aliyun.com/anaconda/pkgs/main - http://mirrors.aliyun.com/anaconda/pkgs/r - http://mirrors.aliyun.com/anaconda/pkgs/msys2 show_channel_urls: true custom_channels: conda-forge: http://mirrors.aliyun.com/anaconda/cloud msys2: http://mirrors.aliyun.com/anaconda/cloud bioconda: http://mirrors.aliyun.com/anaconda/cloud menpo: http://mirrors.aliyun.com/anaconda/cloud pytorch: http://mirrors.aliyun.com/anaconda/cloud simpleitk: http://mirrors.aliyun.com/anaconda/cloud 服务器端
channels: - defaults show_channel_urls: true channel_alias: https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2942e4b87f706ed079575e863501a9bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e03c4a48628868e07bd6fb7a8da145e/" rel="bookmark">
			如何安装Anaconda（Windows版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 更多软件安装 详见&gt;&gt;
常用开发软件安装 目录导航帖
1 所需材料 首先打开Anaconda官网，下载对应平台的安装包
Anaconda官网
我们这里安装的包是Anaconda3-2022.10-Windows-x86_64.exe
2 安装步骤 接下来我们开始安装Anaconda
（1）双击exe文件，开始安装
等待安装结束（这里选择Just me即可）
注：这里有一种方法可以自动添加环境变量，在安装的过程中，勾选自动添加到Path选项即可！这样做可跳过下面的步骤（2）
（2）安装完成后，点击系统属性设置——添加环境变量（安装时勾选自动添加到Path选项的可跳过此步骤）：
在系统Path路径下添加（高亮部分的两行内容，具体的安装路径以机器上为准）：
\Anaconda3\Scripts
\Anaconda3\Library\bin
（3）打开CMD命令，输入conda，能正常显示，说明已经安装成功了：
3 更换镜像源 （1）初始化.condarc文件
conda config --set show_channel_urls yes 这个时候，我们打开C盘用户下，可以看到多了一个.condarc文件
（2）打开这个文件，按照以下的方式进行编辑：
先设置虚拟环境的根目录
envs_dirs: - D:\software\Anaconda3\envs 然后添加channels：
清华大学镜像（安装速度快，但有时最新版不一定能安装成功）
channels: - defaults show_channel_urls: true channel_alias: https://mirrors.tuna.tsinghua.edu.cn/anaconda default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud 阿里云镜像（安装速度慢，但package内容较全）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e03c4a48628868e07bd6fb7a8da145e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6cdd69f1280fcae663f6289f7247489/" rel="bookmark">
			requests详细参数说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-1. timeout：请求超时时间，单位为秒。
```python
import requests
response = requests.get(url, timeout=5) # 设置5秒超时
```
2. verify：请求SSL证书验证。
```python
import requests
response = requests.get(url, verify=False) # 不进行证书验证
```
3. cert：SSL证书路径
```python
import requests
response = requests.get(url, cert=('path/to/cert.pem', 'path/to/key.pem'))
```
4. stream：是否以流方式获取响应内容。
```python
import requests
response = requests.get(url, stream=True) # 以流方式获取响应内容
```
5. headers：请求头
```python
import requests
headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'}
response = requests.get(url, headers=headers)
```
6. cookies：Cookie值
```python
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6cdd69f1280fcae663f6289f7247489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/364b3a194505b478be83adadb2940a05/" rel="bookmark">
			教你接入Midjourney，不用梯子也能玩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、效果 话不多说，先上最终出图效果， 我给的关键词是一只白色的猫
2、接入流程 API文档可以来这里查（可以白嫖100次midjourney出图和10次gpt4体验），我这里精简一下接入流程，方便大家快速接入
2.1、文字生图 首先是先通过文字生图，token可以去api文档中复制粘贴过来即可，请求如下：
const { data } = await axios({ url: 'https://api.zhishuyun.com/midjourney/imagine?token=your token', method: 'POST', timeout: 60000, headers: { 'content-type': 'application/json' }, data: { prompt: 'a white cat', callback_url: `https://xxx.com/api/xxx`, }, }); prompt参数，必填，就是要输入的文字，注意必需是英文，中文是不准确的，你可以前置接入一个翻译工具把用户输入的文字变成英文，我的解决办法是前置接入了一个gpt 3.5，给的prompt是：
"messages": [ { content: "请将我接下来的描述翻译成英文，不要夹带其他文字，如果准备好了，请回复", role: "user" }, { content: "If you are ready, please reply.", role: "system" }, { content: text, role: "user" }, ] callback_url参数，非必填，是一个回调地址就是当图片生成好后，会把生成结果发到这个地址，如果不填这个参数，那这个接口会一直pedding，指到图片生成结束，在把结果返给你，这个我建议是加上去不然对服务器压力很大，毕竟要pedding不少时间，我们看看他返回的结果，如下的一个json
我们只要关注几个等会需要用到的字段，分别是image_id和actions，然后我们其中image_url就是生成的图片，我们查看一下效果，效果还是很不错的
会发现是4张图合成一张图，这其实是midjourney的一种节省资源的策略，之后我们可以对这张图做两种操作，分别是变换和放大，对接也十分简单
2.2、变换 选择一张图片，变换成同等风格的其他图片，比如我们想对左下角的图片做变换，我们就新增两个参数，分别是image_id表示刚才那张四宫格的图片image_id，另一个就是action，如果传upsample4代表要变换右下角那张图，其他操作上面都可以根据上一张图返回的actions字段来，如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/364b3a194505b478be83adadb2940a05/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/133/">«</a>
	<span class="pagination__item pagination__item--current">134/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/135/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>