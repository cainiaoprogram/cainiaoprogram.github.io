<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ecb761c599052e9675597138ff2d253/" rel="bookmark">
			大创项目推荐 深度学习人脸表情识别算法 - opencv python 机器视觉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 技术介绍1.1 技术概括1.2 目前表情识别实现技术 2 实现效果3 深度学习表情识别实现过程3.1 网络架构3.2 数据3.3 实现流程3.4 部分实现代码 4 最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 深度学习人脸表情识别系统
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：4分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 技术介绍 1.1 技术概括 面部表情识别技术源于1971年心理学家Ekman和Friesen的一项研究，他们提出人类主要有六种基本情感，每种情感以唯一的表情来反映当时的心理活动，这六种情感分别是愤怒（anger）、高兴(happiness)、悲伤
(sadness)、惊讶(surprise)、厌恶(disgust)和恐惧(fear)。
尽管人类的情感维度和表情复杂度远不是数字6可以量化的，但总体而言，这6种也差不多够描述了。
1.2 目前表情识别实现技术 2 实现效果 废话不多说，先上实现效果
3 深度学习表情识别实现过程 3.1 网络架构 面部表情识别CNN架构（改编自 埃因霍芬理工大学PARsE结构图）
其中，通过卷积操作来创建特征映射，将卷积核挨个与图像进行卷积，从而创建一组要素图，并在其后通过池化（pooling）操作来降维。
3.2 数据 主要来源于kaggle比赛，下载地址。
有七种表情类别： (0=Angry, 1=Disgust, 2=Fear, 3=Happy, 4=Sad, 5=Surprise, 6=Neutral).
数据是48x48 灰度图，格式比较奇葩。
第一列是情绪分类，第二列是图像的numpy，第三列是train or test。
3.3 实现流程 3.4 部分实现代码 ​
import cv2 import sys import json import numpy as np from keras.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ecb761c599052e9675597138ff2d253/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9534846b72d470b5ad2a8ceaf271ed03/" rel="bookmark">
			vim常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vim常用操作 1、前言2、 vim 的命令集2.1、底行模式2.2、命令模式 1、前言 普通模式 / 命令模式（Normal mode）：控制屏幕光标的移动，字符、字或行的删除，移动复制某区段插入模式（Insertmode）：文字输入底行模式（Last line mode）：文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作替换模式（Replace mode）视图模式（Visual mode） 进入命令模式：输入命令vim testvim.c打开vim默认进入 命令模式，当前目录下没有同名文件会新建一个命令模式 -&gt; 插入模式： 按键i，界面左下角出现– INSERT –字样，此时转化成插入模式，光标不移动按键a，进入插入模式，同时光标向后移动一个按键o，进入插入模式，同时光标向下移动一排按键s，进入插入模式，同时删除光标所在字符 命令模式 -&gt; 底行模式： 按键shift + :，左下出现冒号字样，可以进行保存退出等操作 命令模式 -&gt; 替换模式： shift + r，左下出现– REPLACE –字样，此时转化成替换模式 任意模式 -&gt; 命令模式：
按键[ESC]，此时模式提醒消失，返回了命令模式 2、 vim 的命令集 2.1、底行模式 退出保存:
q：不保存只退出q!：强制退w：只保存（可以撤销之前的命令）wq ：写入并退出（再次打开不可撤销之前的命令）wq!：强制保存并退出!命令行命令：返回执行命令行的命令，但是不退出vim 文本文件编辑
set nu / set noun：设置行号、去掉行号/xxx：字符串查找%s/当前字符串/替换字符串/g：查找并替换字符串vs 文件名：将输入文件分屏至左侧，如当前目录下没有找到该文件，会自动创建一个ctrl + ww：切换光标到另一个分屏界面 2.2、命令模式 复制粘贴
u：撤销 命令ctrl + r：对撤销进行撤销yy / nyy：复制当前光标所在行、复指当前行在内及之下的指定若干行dd / ndd：剪切当前光标所在行、剪切当前行在内及之下的指定若干行（如果只dd不粘贴，就是删除）p / np：粘贴 一行、粘贴内容相同的n行，到当前光标所在行之下 ️光标定位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9534846b72d470b5ad2a8ceaf271ed03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb381d75db5bc9601ba682d19a8cb42f/" rel="bookmark">
			pod详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发布和yaml文件的初步了解。
pod环节；
pod的生命周期
kubectl get cs
kubectl get node
kubectl get pod -n kube-system
kubectl create deployment nginx2 --image=nginx:1.22 --replicas=1
kubectl get pod 查看是否能正常创建pod
检查环境
pod是什么？ pod是k8s中最小的资源管理组件。
pod也是最小化运行容器化的应用的资源管理对象。
pod是一个抽象的概念，可以理解为一个或者多个容器化应用的集合。
在一个pod当中运行一个容器是最常用的方式。
在一个pod当中同时运行多个容器，在一个pod当中可以同时封装几个需要耦合的互相协作的容器。
这些多个容器共享资源，也可以互相协作组成一个service单位。
不论运行一个容器还是多个容器，k8s管理的都是pod而不是容器。
一个pod内的容器，必须都运行在同一个节点上。基于现代容器技术的要求，一个pod运行一个容器，一个容器只运行一个进程。横向扩展，方便扩缩容。
解耦：一个pod内运行多个容器，耦合度太高，一旦一个进程失败，整个pod将全部失败。
（一个pod只运行一个容器）实现解耦，基于一个pod可以创建多个副本，实现高可用和负载均衡。
管理方便，简单直观。
pause pod内的容器可以共享资源。共享机制：pause底层基础容器来提供共享资源的机制。
pause容器是基础容器，也可以成为父容器。管理pod内容器的共享操作。
pause还可以管理容器的生命周期。
k8s提供了pause容器
1、为pod内的所有容器提供一个命名空间
2、启动容器的pid命名空间，每个pod中都作为pid为1的进程（init进程。所有pod的父进程），回收僵尸进程。
也就是pause进程是这个pod内的所有进程的父进程
pod里面是容器，容器运行的是进程 每个进程都有pid
pause 父进程 1 在pod内部管理容器的进程。
3、创建pod时，先创建pause容器，然后拉取镜像，生成容器，形成pod。
由pause提供pod的基础环境
LNMP
Linux pause容器
n
m
p 都运行在Linux系统上
注：kubelet来管理node节点，节点上的容器还是它来管理
pause的作用是管理pod内的容器
第一步：master节点发出指令，pod使用的镜像nginx，pod的副本数
第二步：kube-scheduler来分配执行的node节点
第三步：node节点的kubelet收到master指令
第四步：pause容器先启动，提供命名空间，进程管理pid1 来为pod内的容器提供共享服务以及容器的进程管理。
pause内的容器共享两种资源 网络： 每个pod都会被分配一个集群内部的唯一ip地址。和pod内的容器共享网络，pod在集群内部的ip地址和端口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb381d75db5bc9601ba682d19a8cb42f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0eceaf7840403546dd001af6aa11969/" rel="bookmark">
			大模型语言模型：从理论到实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大模型语言模型：从理论到实践 一、资源获取链接二、概念整理定义发展历程 大模型的基本构成 一、资源获取链接 《大规模语言模型：从理论到实践》、复旦大学课件
链接/提取码：x7y6
二、概念整理 定义 大规模语言模型（Large Language Models，LLM），也称大语言模型或大型语言模型，是一种由包含数百亿以上参数的深度神经网络构建的语言模型，通常使用自监督学习方法通过大量无标注文本进行训练。
自2018年以来，Google、OpenAI、Meta、百度、华为等公司和研究机构都相继发布了包括BERT，GPT等在内多种模型，并在几乎所有自然语言处理任务中都表现出色。2019年大模型呈现爆发式的增长，特别是2022年11月ChatGPT（Chat Generative Pre-trained Transformer）发布后，更是引起了全世界的广泛关注。用户可以使用自然语言与系统交互，从而实现包括问答、分类、摘要、翻译、聊天等从理解到生成的各种任务。大规模语言模型展现出了强大的对世界知识掌握和对语言的理解能力。
深度神经网络训练需要采用有监督方法，使用标注数据进行训练，因此，语言模型的训练过程也不可避免需要构造训练语料。
但是由于训练目标可以通过无标注文本直接获得，从而使得模型的训练仅需要大规模无标注文本即可。语言模型也成为了典型的自监督学习（Self-supervised Learning）任务。
互联网的发展，使得大规模文本非常容易获取，因此训练超大规模的基于神经网络的语言模型也成为了可能。
以ELMo为代表的动态词向量模型开启了语言模型预训练的大门。此后，以GPT和BERT为代表的基于Transformer 架构的大规模预训练语言模型的出现，使自然语言处理全面进入预训练微调范式新时代。这类方法通常称为预训练语言模型（Pre-trained Language Models，PLM）。
2020 年，OpenAI 发布了由包含1750 亿参数的神经网络构成的生成式大规模预训练语言模型GPT-3（Generative Pre-trained Transformer 3）。开启了大语言模型的新时代。在不同任务上都进行微调需要消耗大量的计算资源，因此预训练微调范式不再适用于大语言模型。
通过语境学习（In-Context Learning，ICL）等方法，直接使用大语言模型就可以在很多任务的少样本场景下取得很好的效果。此后，研究人员提出了面向大语言模型的提示词（Prompt）学习方法、模型即服务范式（Model as a Service，MaaS）、指令微调（Instruction Tuning）等方法。
发展历程 大语言模型的发展历程虽然只有短短不到五年，但是发展速度相当惊人，截止2023 年6 月，国内外有超过百种大模型相继发布。
大模型的基本构成 预训练（Pretraining）阶段需要利用海量的训练数据，数据来自互联网网页、维基百科、书籍、GitHub、论文、问答网站等，构建包含数千亿甚至数万亿单词的具有多样性的内容。
利用由数千块高性能GPU 和高速网络组成超级计算机，花费数十天完成深度神经网络参数训练，构建基础语言模型（Base Model）
有监督微调（Supervised Finetuning），也称为指令微调，利用少量高质量数据集合，包含用户输入的提示词和对应的理想输出结果。用户输入包括问题、闲聊对话、任务指令等多种形式和任务。
利用这些有监督数据，使用与预训练阶段相同的语言模型训练算法，在基础语言模型的基础上进行训练，得到有监督微调模型（SFT 模型）。
经过训练的SFT 模型具备初步的指令理解能力和上下文理解能力，能够完成开放领域问答、阅读理解、翻译、生成代码等任务，也具备了一定的对未知任务的泛化能力。
很多类ChatGPT的模型都属于该类型，包括Alpaca、Vicuna、MOSS、ChatGLM-6B 等。很多这类模型的效果非常好，甚至在一些评测中达到了ChatGPT 的90% 的效果。
奖励建模（Reward Modeling）阶段的目标是构建一个文本质量对比模型，对于同一个提示词，SFT 模型给出的多个不同输出结果的质量进行排序。奖励模型（RM 模型）可以通过二分类模型，对输入的两个结果之间的优劣进行判断。RM 模型与基础语言模型和SFT 模型不同，RM 模型本身并不能单独提供给用户使用。
奖励模型的训练通常和SFT 模型一样，使用数十块GPU，通过几天时间完成训练。由于RM 模型的准确率对强化学习阶段的效果有至关重要的影响，因此通常需要大规模的训练数据对该模型进行训练。
强化学习（Reinforcement Learning）阶段根据数十万用户给出的提示词，利用前一阶段训练的RM模型，给出SFT模型对用户提示词补全结果的质量评估，并与语言模型建模目标综合得到更好的效果。
使用强化学习，在SFT 模型基础上调整参数，使得最终生成的文本可以获得更高的奖励（Reward）。该阶段需要的计算量相较预训练阶段也少很多，通常仅需要数十块GPU，数天即可完成训练。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/711f6842e228e63854309136289ccb9c/" rel="bookmark">
			Linux常用指令二：目录以及文件夹的常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.切换目录
2.查看当前位置以及文件夹信息
3.查看文件夹权限并修改
4.文件夹的增删操作
5.文件夹复制与移动
6.文件夹重命名
7.文件夹中查找文件
1.切换目录 cd 目标文件夹 切换到目标文件夹 cd / 切换到根目录 cd .. 切换到上一级目录 cd ~ 切换到home目录 cd - 切换到上次访问的目录 2.查看当前位置以及文件夹信息 pwd 查看当前目录所在位置 ls 查看当前目录下的所有目录和文件 ls -a 查看当前目录下的所有目录和文件（包括隐藏文件） ls -l 列表查看，显示更多信息(文件的用户、组、大小、创建时间、权限信息、文件类型等) ls- lh 会以KB、MB等为单位进行显示更加直观(ls -l，会显示成字节大小） 3.查看文件夹权限并修改 Linux中修改权限（文件夹和文件的修改方法相同）有数字表示法和符号表示法，并且有很多种情况。 详细可以看看这篇Linux文件权限管理
懒得看并且也没有什么重要私密文件的话，直接用值777就可以进行查询修改等操作了。
ls -l folder 查看文件夹权限 chmod 777 folder/file 将folder/file权限设为所有用户可读写执行 4.文件夹的增删操作 mkdir new_folder 创建一个名为new_folder的文件夹 rmdir new_folder 删除空文件夹new_folder rm -r folder 删除非空文件夹folder rm -rf folder 强制删除folder目录，不询问 5.文件夹复制与移动 cp -r folder /new/ 将文件夹folder复制到目录new下 mv folder /new/ 将文件夹folder移动到目录new下 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/711f6842e228e63854309136289ccb9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b37e7ddb60909f77c19467cd05737bc5/" rel="bookmark">
			图片格式怎么转换jpg？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&amp;nbsp; 图片格式怎么转换jpg？随着数字化时代的发展，图片在我们的生活和工作中扮演着越来越重要的角色。转换为JPG格式的优点在于其广泛兼容性，由于jpg是一个通用的图片格式，这种格式几乎在所有的设备和应用程序当中都是能够去进行使用的，让你轻松的在各种不同的平台上面打开来进行编辑和共享。而且尺寸压缩能力也会相对来说变的非常的明显的。在色彩丰富方面，也能够呈现出各种非常丰富的色彩和细节的，使它能够在摄影、艺术和设计等领域中被广泛的应用到。然而，不同的设备和应用程序所支持的图片格式却存在差异，这可能会导致在使用图片时出现不兼容的问题。比如，有些图片只能在特定的软件或设备上打开，而在其他应用程序上则无法正常显示。
&amp;nbsp; 为了解决这个问题，我们需要将图片格式转换成更普遍、更通用的格式，比如JPG格式。但是，如何将图片格式转换成JPG格式呢？是否有一种简单快捷的方法呢？下面就让我们一起来探究一下吧！
方法一：使用图片处理软件进行转换
今天小编将为大家推荐一个名为“优速图片格式转换器”的软件，这个软件具有十个功能，可以上将十多种不同格式的图片转成jpg，下面有详细的转换步骤，一起看看吧。
步骤1，把“优速图片格式转换器”软件下载安装在电脑桌面上，等安装好之后双击打开它，并且在它的首页左边的功能列表中，点击“格式转换”功能选项，此功能可以将png、jpeg、heic、gif、BMP、jfif、webp、tiff、tif、svg、tga图片转成jpg。
&amp;nbsp;
步骤2，等软件将“格式转换”的功能页面打开来之后，接着点击页面左上角的“添加文件”或是用鼠标把图片拖拽到软件中添加，不过需要知道的是，该软件中是能够对多张图片进行格式转换操作的。
&amp;nbsp;
步骤3，上传好选中的图片文件之后，你能够在软件对上传进去的图片文件预览和转换后对的格式设置的，这里默认的格式转换结果是“jpg”。若是大家想要更换成其它的格式的话，可以点击下拉选项框，来进行选择的，这里面的图片格式都是非常普遍的。
&amp;nbsp;
步骤4，设置好一切之后，去软件的右上角点击“开始转换”按钮，让软件开启转换程序，等软件完成了转换操作之后，会将输出文件夹打开来，便于查看转换成的jpg图片。
&amp;nbsp;
步骤5，最终从下图可以看到，我们成功的将多张不同格式的图片全部转为了jpg格式。
&amp;nbsp;
方法二：使用在线图片转换工具进行转换
很多图片处理小白可能还不知道，其实网上还有很多能够进行图片格式转换的工具网站，我们称之为在线工具，使用起来还是非常方便的，今天要给大家推荐的这个在线转换工具叫作“快转图”，那么如何用它将图片格式转成jpg呢？请看详细步骤：
1、我们使用电脑上的任何一个浏览器就能将这个在线转换工具打开并使用，随后我们点击导航栏上的“图片转格式”功能选项进入下一步。
&amp;nbsp;
2、随后点击页面上的红色按键，之后弹出文件添加窗口，我们就可以使用它将需要转化格式的图片上传到网站里面了，可以批量上传批量格式转换哦。
&amp;nbsp;
3、如下图所示，先点击“选择要转换的格式”下拉框，将转换后的格式设置为“jpg”；之后就可以点击“开始转换”按钮，正式开启图片格式的转换程序了。
&amp;nbsp;
4、转换结束后，点击页面上的“打包下载”绿色按钮，就可以将所有转换成的jpg图片下载到电脑本地进行使用了。
&amp;nbsp;
方法三：使用ps软件进行转换
Photoshop是一个功能强大的图像编辑软件，它支持多种图像格式转换成jpg，可以将png、gif、tiff、bmp、raw等格式图片转换成jpg。Photoshop软件使用起来比较困难，并且软件的安装就比较麻烦，不太适合新手使用，具体如何转换，请大家往下看看吧。
① 打开需要转换格式的图片文件。在菜单栏中选择“文件”-&gt;“另存为”。
② 在保存对话框中输入新文件名称，并选择JPEG文件格式。
③ 根据需要调整JPEG文件的质量设置。可以通过拖动滑块或手动输入数字来调整质量设置。通常，JPEG文件的质量范围为0到100，值越高，图像质量越好，但文件大小也会相应增加。
④ 点击“保存”按钮，即可将图片保存为JPEG格式。
&amp;nbsp;&amp;nbsp;如果你需要批量转换多个图片格式，可以使用Photoshop中的批处理功能来实现。具体操作步骤如下：
① 打开Photoshop软件，在菜单栏中选择“文件”-&gt;“脚本”-&gt;“图像处理器”。
② 在弹出的“图像处理器”窗口中，选择要转换格式的图片文件夹，并选择输出文件夹。
③ 在“文件类型”中选择JPEG文件格式，并根据需要调整JPEG文件的质量设置。
④ 点击“运行”按钮，即可批量转换多个图片格式。
总之，将图片格式转换为JPG格式可以提高其通用性和兼容性，使其更易于在不同设备和应用程序中使用。无论您是想将图片从PNG、BMP、GIF或其他格式转换为JPG，或者有其他格式转换的需求，都可以通过各种图片编辑软件、在线转换工具或专用的格式转换器来实现。希望本文提供的方法和指导能够帮助您顺利完成图片格式转换，并在日常使用中更加方便地处理和共享您的图片。如果您还有任何疑问或需要进一步的帮助，请随时向我提问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcf0d34b7253607f8821ea3c4b0399af/" rel="bookmark">
			uniapp中组件库丰富的Switch 开关选择器使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
#平台差异说明
#基础使用
#加载中
#禁用switch
#自定义尺寸
#自定义颜色
#自定义样式
#异步控制
API
#Switch Props
#Switch Event
选择开关用于在打开和关闭状态之间进行切换。
#平台差异说明 App（vue）App（nvue）H5小程序√√√√ #基础使用 通过v-model绑定一个布尔值变量，这个变量是双向绑定的，当用户开或关选择器的时候，在父组件的该值也会相应的变为true或者false，也就是说， 您不用监听change事件，也能知道选择器当前处于开或者关的状态。
我们为其提供了加载中 禁用 自定义尺寸 自定义颜色 自定义样式 异步控制等六种能力，并在以下案例中为您展示
&lt;u-switch v-model="value" @change="change"&gt;&lt;/u-switch&gt; &lt;!-- methods --&gt; change(e) { console.log('change', e); }, #加载中 设置loading属性，默认为true，可以让switch处于加载中的状态，这时switch是不可操作的，您可以通过:loading='loading'以动态设置加载状态
&lt;u-switch v-model="value3" loading &gt;&lt;/u-switch&gt; &lt;u-switch v-model="value4" loading &gt;&lt;/u-switch&gt; &lt;!-- data --&gt; value3: false, value4: true, #禁用switch 设置disabled属性,默认为true，即可禁用某个组件，让用户无法点击，禁用分为两种状态：
一是关闭情况下的禁用，这时只显示一个白色的区域。二是打开后再禁用，这时会在原有的颜色上加一个opacity透明度，但此时依然是不可操作的。 &lt;u-switch v-model="value" disabled &gt;&lt;/u-switch&gt; #自定义尺寸 设置size属性，可以让您自定义switch的尺寸，单位为px
&lt;u-switch v-model="value3" size="28" &gt;&lt;/u-switch&gt; &lt;u-switch v-model="value4" size="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcf0d34b7253607f8821ea3c4b0399af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468e47028c51a5a5efafdf540af64c44/" rel="bookmark">
			uniapp中组件库的Radio 单选框丰富的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
#平台差异说明
#基本使用
#自定义形状
#禁用radio
#是否禁止点击提示语选中复选框
#自定义颜色
#横向排列形式
#横向两端排列形式
API
#Radio Props
#radioGroup Props
#radio Event
#radioGroup Event
单选框用于有一个选择，用户只能选择其中一个的场景。
#平台差异说明 App（vue）App（nvue）H5小程序√√√√ #基本使用 该组件需要搭配radioGroup组件使用，以便用户进行操作时，获得当前单选框组的选中情况通过v-model给radioGroup组件绑定一个变量，对应的name将会被选中 &lt;template&gt; &lt;u-radio-group v-model="radiovalue1" placement="column" @change="groupChange" &gt; &lt;u-radio :customStyle="{marginBottom: '8px'}" v-for="(item, index) in radiolist1" :key="index" :label="item.name" :name="item.name" @change="radioChange" &gt; &lt;/u-radio&gt; &lt;/u-radio-group&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { // 基本案列数据 radiolist1: [{ name: '苹果', disabled: false }, { name: '香蕉', disabled: false }, { name: '橙子', disabled: false }, { name: '榴莲', disabled: false } ], // u-radio-group的v-model绑定的值如果设置为某个radio的name，就会被默认选中 radiovalue1: '苹果', }; }, methods: { groupChange(n) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/468e47028c51a5a5efafdf540af64c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f827e5d149654c0e46a00dad9d66fa66/" rel="bookmark">
			【论文&#43;在线运行】AnyText：能准确写汉字的AI绘图工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码：https://github.com/tyxsspa/AnyText
阿里在线运行: https://modelscope.cn/studios/damo/studio_anytext/summary
论文：2311.AnyText: Multilingual Visual Text Generation And Editing
一、AnyTexT是什么？ 是一个基于扩散模型的（diffusion-based）
多语言（multilingual）视觉文字（visual text）生成和编辑的模型，
专注于在图像中渲染准确和连贯(accurate and coherent)的文本。
能做什么？ 功能：生成图片同时，在指定位置生成中文、英文、日文等，还可对已有图片进行编辑
不足：未来的工作将集中在探索极小字体（extremely small fonts）的生成和研究具有可控属性（controllable attributes.）的文本生成
图1 生成图片示例： 对于文本生成，AnyText可以将指定的文本从提示渲染到指定的位置，并生成视觉吸引力的图像
对于文本编辑，AnyText可以在输入图像中的指定位置(specified position)修改文本内容，同时保持与周围文本样式的一致性(maintaining consistency with)。
下图括号中为提示中的非英语单词提供翻译，蓝色框表示文本编辑位置（可输入修改位置）
图3 生成指定位置、不规则弯曲的文字 美人鱼的标志（a logo of a mermaid），上面写着（ with the words）“星巴克（STARBUCKS）”和“咖啡(COFFEE)”写着“2023”和“冠军”的横幅(a banner that reads)一个精致礼盒的照片(photo of )，上面写着“新婚快乐”，(数码单反照片)街上写着“禁止超速（禁止超速行驶）指示牌(`sign on that xx says) 图4 多语言图片生成 大楼上的牌子上写着 “我理解英语” （Sign on the building that reads）
图5，比较效果: SD-XL1.0 、Bing Image Creator3、DALL-E2, 以及 DeepFloyd IF 图6 中文生成效果比较 中文文本生成中GlyphDraw、ControlNet和AnyText的比较示例，全部摘自GlyphDraw的原始论文
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f827e5d149654c0e46a00dad9d66fa66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba0d18c4b34cad059fb678dbc8861557/" rel="bookmark">
			MATLAB逻辑与流程控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB逻辑与流程控制 文章目录 MATLAB逻辑与流程控制1、循环结构1.1、for ...end1.2、while ... end 2、分支结构2.1、if ...else2.1、if ...else ... end2.2、switch ... case ... end 1、循环结构 1.1、for …end 格式：
其中，步长的默认值为1,可以省略；初值、步长，终值可以是正数也可以是负数,还可以是整数，也可以是小数，只要符合数学逻辑即可。
例子：
sum = 0; for n = 1:5 %n从1-5递增，步长为1可以省略 sum = sum + n^2; end 1.2、while … end 格式：
例子：
s= 0; n= 1; while n&lt;=10 s=s +n; n=n+1; end 2、分支结构 2.1、if …else 格式：
2.1、if …else … end 格式：
if 表达式 语句体1 else 语句体2 end 例子：
2.2、switch … case … end 结构：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3880c55ad94335540748c886d875cc3e/" rel="bookmark">
			逻辑回归（LR）----机器学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本原理
逻辑回归（Logistic Regression，LR）也称为"对数几率回归"，又称为"逻辑斯谛"回归。
logistic回归又称logistic 回归分析 ，是一种广义的线性回归分析模型，常用于数据挖掘，疾病自动诊断，经济预测等领域。 逻辑回归根据给定的自变量数据集来估计事件的发生概率，由于结果是一个概率，因此因变量的范围在 0 和 1 之间。
知识点提炼
分类，经典的二分类算法！
逻辑回归就是这样的一个过程：面对一个回归或者分类问题，建立代价函数，然后通过优化方法迭代求解出最优的模型参数，然后测试验证我们这个求解的模型的好坏。
Logistic 回归虽然名字里带“回归”，但是它实际上是一种分类方法，主要用于两分类问题（即输出只有两种，分别代表两个类别）
回归模型中，y 是一个定性变量，比如 y = 0 或 1，logistic 方法主要应用于研究某些事件发生的概率。
逻辑回归的本质：极大似然估计
逻辑回归的激活函数：Sigmoid
逻辑回归的代价函数：交叉熵
逻辑回归的优缺点
优点：
1）速度快，适合二分类问题
2）简单易于理解，直接看到各个特征的权重
3）能容易地更新模型吸收新的数据
缺点：
对数据和场景的适应能力有局限性，不如决策树算法适应性那么强
逻辑回归中最核心的概念是 Sigmoid 函数，Sigmoid函数可以看成逻辑回归的激活函数。
下图是逻辑回归网络：
对数几率函数（Sigmoid）：
y = σ ( z ) = 1 1 + e − z y = \sigma (z) = \frac{1}{1+e^{-z}} y=σ(z)=1+e−z1​
通过对数几率函数的作用，我们可以将输出的值限制在区间[0，1]上，p(x) 则可以用来表示概率 p(y=1|x)，即当一个x发生时，y被分到1那一组的概率。可是，等等，我们上面说 y 只有两种取值，但是这里却出现了一个区间[0, 1]，这是什么鬼？？其实在真实情况下，我们最终得到的y的值是在 [0, 1] 这个区间上的一个数，然后我们可以选择一个阈值，通常是 0.5，当 y &gt; 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3880c55ad94335540748c886d875cc3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09cbcaa871770dc2993713d39e80cfc8/" rel="bookmark">
			MATLAB矩阵操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB矩阵操作 文章目录 MATLAB矩阵操作1.矩阵的定义与构造2.矩阵的四则运算3.矩阵的下标 1.矩阵的定义与构造 A = [1 2 3 4 5 6] %矩阵的定义 B = 1:2:9 %1-9当中的数字，每2个数字跳过，并且不可以缺省 C = repmat(B,3,1) %对B数组横着重复1次，竖着重复3次 D = ones(2,4) %生成两行四列，都为1的矩阵 2.矩阵的四则运算 A = [1 2 3 4] %定义 B = [1 2 3 4] C = A + B %对应相加 D = A - B %对应相减 E = A * B' %A*B的转置 F = A .* B %对应相乘 G = A / B %相当于A乘以B的逆==&gt;A*inv(B) H = A .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09cbcaa871770dc2993713d39e80cfc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5eb7d6eb50e2159ac6f2d19dc2d56f0/" rel="bookmark">
			虚幻UE 材质-进阶边界混合之距离场限制PDO范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础边界混合那篇文章：虚幻UE 材质-边界混合之PDO像素深度偏移量
可以通过抖动来进行混合，但是有问题的点在与抖动发生的位置只需要在两物体的交界处
所以本篇文章会通过距离场限制来限制抖动的位置，防止其他地方发生抖动影响画面。
文章目录 一、概述二、优化过程1、整体节点2、节点分析 一、概述 通过限制像素抖动值过大时抖动的范围，来达到优化不需要抖动出画面的抖动、虚影来达到边界混合。
与DFAO冲突，只能二选一，因为该技术需要借助距离场来计算范围。
上图是使用了距离限制抖动范围的效果图。
二、优化过程 1、整体节点 2、节点分析 根据距离场来得到物体的绝对坐标系中物体的位置的像素点
offset部分是不需要计算部分的像素点，通过subtract减法后剩余需要抖动计算的像素点
falloff部分是把剩余需要计算部分进行分块来实现渐变效果
saturate是把值限制在0 和 1之间和默认的clamp一样，但是消耗的资源更低
contrast通过次方的方式控制颜色对比度的大小
反转需要抖动来进行边界混合的范围，现在变成在物体下部分才需要进行抖动优化边界混合，
上部分只需要照常显示就行
注意：需要关闭距离场光照
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e55e9d9b6e9b0862a4869d12aac81bed/" rel="bookmark">
			网页爬虫对于网络安全有哪些影响？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今信息爆炸的时代，网络已经成为人们获取信息、交流思想和开展业务的重要平台。然而，随着网络的普及和技术的不断发展，网络安全问题也日益凸显，其中网页爬虫对网络安全的影响不容忽视。本文将就网页爬虫对网络安全的影响进行深入分析，并提出相应的应对措施。
一、网页爬虫的定义与分类
网页爬虫，也称为网络爬虫或网络机器人，是一种自动化的程序，能够在互联网上抓取、收集和存储网页信息。根据其目的和行为方式的不同，可以将网页爬虫分为以下几类：
搜索引擎爬虫：这类爬虫的主要目的是为搜索引擎提供内容。它们按照一定的规则和算法，在互联网上抓取网页信息，建立索引数据库，以便用户能够通过关键词搜索快速找到所需内容。恶意爬虫：这类爬虫的主要目的是利用网站漏洞获取敏感信息，或者对网站进行恶意攻击。它们会大量、快速地访问目标网站，给服务器带来巨大压力，导致网站性能下降甚至瘫痪。数据挖掘爬虫：这类爬虫的主要目的是收集特定数据。它们通过对目标网站进行深度抓取，提取有用信息，进行分析和利用。 二、网页爬虫对网络安全的影响
数据泄露与隐私侵犯：恶意爬虫往往会利用网站的漏洞，非法获取用户的个人信息、交易数据等敏感信息，导致数据泄露和隐私侵犯。这些信息一旦被不法分子利用，将对用户的财产安全和个人安全造成严重威胁。服务器压力与性能下降：大量恶意爬虫同时访问目标网站，会给服务器带来巨大压力，导致服务器性能下降甚至瘫痪。这不仅会影响用户体验，还可能给网站所有者带来经济损失。网站结构与内容篡改：恶意爬虫可以对目标网站的页面进行篡改，改变网站的结构和内容，从而达到欺诈、传播恶意信息等目的。这不仅会对网站的正常运营造成影响，还可能损害用户的利益和安全。法律风险与责任问题：对于网站所有者而言，如果其网站被爬虫恶意攻击或用于非法目的，可能会面临法律风险和责任问题。在某些情况下，网站所有者可能需要承担相应的法律责任。 三、应对措施与建议
针对网页爬虫对网络安全的影响，我们可以采取以下措施和建议：
加强技术防范：网站所有者应该加强自身网站的安全防护措施，建立完善的安全管理体系。例如，定期更新和升级服务器软件、设置有效的访问控制策略、使用验证码机制等，以防止恶意爬虫的入侵和攻击。提升用户体验：网站所有者可以通过优化网站性能、提高网页加载速度、提供个性化的内容等方式，提升用户体验，降低用户对恶意爬虫的感知和反感。及时响应与处理：一旦发现恶意爬虫的存在，网站所有者应该及时采取措施，如关闭相关功能、拦截访问请求等，以防止事态扩大。同时，还应该积极配合相关部门进行调查和处理，及时消除安全隐患。法律法规与政策引导：政府应该加强对网络安全法律法规的建设和完善，明确网络爬虫行为的合法性标准和监管要求。同时，通过政策引导和技术支持，鼓励企业和个人加强网络安全防护，提高网络安全意识和能力。行业自律与合作：相关行业应该建立自律机制，制定行业标准和规范，加强对网页爬虫行为的监督和管理。同时，鼓励企业和个人之间加强合作，共同应对网络安全挑战，维护网络空间的安全和稳定。 总之，网页爬虫对网络安全的影响不容忽视，需要各方共同努力，采取有效的措施和策略，共同维护网络空间的安全和稳定。
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6177fade679e4ce8c3ba32a7f06b31ef/" rel="bookmark">
			从txt从前往后与从后往前读取起始时间并获得持续时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.io.*; import java.time.LocalTime; import java.time.temporal.ChronoUnit; public class Main { public static void main(String[] args) { String resultPath = "……\\result.txt"; File file = new File(resultPath); StringBuilder builder = new StringBuilder(); String beginTime = null; String endTime = null; try (RandomAccessFile randomAccessFile = new RandomAccessFile(file, "r")) { BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(resultPath))); String readLine = null; while ((readLine = reader.readLine()) != null) { if (readLine.contains("Start Time")) { String[] tmp = readLine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6177fade679e4ce8c3ba32a7f06b31ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94ca8d717c055a309a8ff01c24f74742/" rel="bookmark">
			笔记 | Bash 中 if 判断选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Bash 脚本中，if 语句可以使用多种条件检测选项来测试文件、字符串以及其他条件。以下是一些常见的测试选项：
文件测试 -d FILE：如果 FILE 存在且是一个目录，则为真。-e FILE：如果 FILE 存在，则为真。-f FILE：如果 FILE 存在且是一个普通文件，则为真。-r FILE：如果 FILE 存在且可读，则为真。-s FILE：如果 FILE 存在且其大小不为零，则为真。-w FILE：如果 FILE 存在且可写，则为真。-x FILE：如果 FILE 存在且可执行，则为真。-L FILE：如果 FILE 存在且是一个符号链接，则为真。 字符串测试 -z STRING：如果 STRING 的长度为零，则为真。-n STRING 或 STRING（没有任何标志）：如果 STRING 的长度非零，则为真。STRING1 = STRING2：如果两个字符串相同，则为真。STRING1 != STRING2：如果两个字符串不相同，则为真。 整数比较 INT1 -eq INT2：如果两个整数相等，则为真。INT1 -ne INT2：如果两个整数不相等，则为真。INT1 -lt INT2：如果 INT1 小于 INT2，则为真。INT1 -le INT2：如果 INT1 小于或等于 INT2，则为真。INT1 -gt INT2：如果 INT1 大于 INT2，则为真。INT1 -ge INT2：如果 INT1 大于或等于 INT2，则为真。 复合条件 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94ca8d717c055a309a8ff01c24f74742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/248ad75defb84a6161f3d00f9075f2ca/" rel="bookmark">
			如何解决大型语言模型的「幻觉」问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言什么是大型语言模型的「幻觉」？1. 事实错误和虚构例子分析 2. 数据解释错误例子分析 3. 缺乏充分证据的断言例子分析 原因分析1. 数据偏见数据来源问题数据质量的重要性 2. 算法局限算法理解的限制算法的改进需求 3. 上下文限制上下文理解的困难上下文理解的提升策略 解决方案1. 提高数据质量实施措施 2. 算法改进技术进步 3. 上下文增强方法论 4. 人工监督人工干预 结语 引言 大型语言模型（LLM）的「幻觉」问题是一个引起广泛讨论的现象。在本文中，我们将探讨这一现象的本质，为什么会出现这种情况，以及可能的解决方案。
在人工智能领域，特别是在自然语言处理（NLP）的研究和应用中，大型语言模型已成为一项关键技术。这些模型，如GPT-3和BERT，因其在理解和生成人类语言方面的卓越能力而受到广泛关注。然而，随着它们在各种应用中的普及，从文本生成到对话系统，模型产生的信息不准确或失真的情况也逐渐显现。这种现象被称为「幻觉」，不仅对用户体验构成挑战，也引发了关于模型可靠性和安全性的重要讨论。
「幻觉」问题不仅仅是技术上的挑战，它还涉及到模型的伦理和责任问题。当模型生成不准确或误导性的信息时，可能对用户造成误解，甚至在某些情况下带来风险。因此，理解和解决「幻觉」问题，不仅是提升模型性能的问题，也是确保人工智能负责任和伦理应用的关键。
本文将深入探讨「幻觉」的具体表现，分析其产生的原因，并提出一系列可能的解决策略，旨在为研究人员、开发者以及对AI伦理感兴趣的读者提供深刻的洞见。
什么是大型语言模型的「幻觉」？ 「幻觉」是指大型语言模型（LLM）在生成文本时产生不真实或不准确的信息。这种现象在多个层面上展现，主要表现在以下几个方面：
1. 事实错误和虚构 大型语言模型有时会创造出完全不存在的事实或事件。这可能是因为模型在处理大量、复杂的信息时，无法区分真实与虚构。
例子分析 虚构人物或事件：模型可能会生成关于不存在的人物或事件的详细描述。例如，它可能编造一个历史人物的生平故事，尽管这个人物从未在历史上出现过。错误的历史事实：模型可能错误地陈述历史事件或数据。例如，它可能错误地描述一个重要事件的时间、地点或参与者。 2. 数据解释错误 模型在解释已有数据时可能会犯错误，这通常是由于缺乏对特定领域深入了解所致。
例子分析 科学数据误解：在处理科学数据或研究时，模型可能会错误地解释其含义。比如，在分析一个科学实验的结果时，模型可能会错误地解释实验数据，得出错误的结论。经济数据错误分析：模型可能会对经济数据做出不准确的预测或分析。例如，在预测经济趋势时，它可能会忽视关键的经济指标或错误解释这些指标的意义。 3. 缺乏充分证据的断言 模型有时会在没有充分证据支持的情况下，做出明确的断言或结论。
例子分析 无根据的预测：对未来事件的预测可能没有足够的数据支持。例如，模型可能会预测某项技术在未来几年内的发展趋势，但这种预测缺乏科学依据和实际数据支撑。假设性结论：在缺乏确凿证据的情况下，模型可能会提出假设性结论。比如，在分析一个复杂的社会现象时，模型可能会基于有限的信息做出过于笼统或不准确的假设。 原因分析 大型语言模型的「幻觉」问题产生的原因可以归纳为以下几点：
1. 数据偏见 模型训练所使用的数据集可能包含偏见或错误信息，导致模型在生成内容时重复这些偏见或错误。
数据来源问题 文化、性别、种族偏见：由于数据集可能来源于特定的地区或群体，因此可能包含特定文化、性别或种族的偏见。例如，一个以某一地区或语言为主的数据集可能无法全面代表全球多元文化。错误或过时的信息：在快速发展的科技和医学领域，信息更新迅速，导致模型训练中使用的数据可能已经过时。此外，数据集中可能包含事实错误，这些错误会被模型学习并反映在其输出中。 数据质量的重要性 数据集的多样性：确保数据集覆盖广泛，可以减少单一来源带来的偏见。数据清洗和验证：定期对数据进行清洗和验证，确保其准确性和时效性。 2. 算法局限 当前的算法可能还不足以完全理解和处理复杂的人类语言和知识。
算法理解的限制 处理语言的多义性和复杂性：人类语言复杂多变，含有大量的隐喻、双关语和文化背景。模型可能在理解这些细微差别上存在限制。情感和语境理解的不足：模型可能无法充分理解语言中蕴含的情感色彩和语境背景，导致输出内容可能与人类的真实意图不符。 算法的改进需求 深入理解语言的细节：开发能更精准理解语言细节和变化的算法。情感分析的加强：加强对语言情感色彩的分析能力，使模型能更好地理解和表达人类情感。 3. 上下文限制 模型在处理给定的输入时，可能无法完全理解上下文，从而产生不准确的输出。
上下文理解的困难 长篇连贯文本的处理挑战：在处理长篇连贯文本时，模型需要保持对整个文本上下文的理解和记忆，这对目前的模型是一个挑战。特定领域知识的理解：在特定领域（如法律、医学、科技）中，需要对该领域的专业知识有深入理解，模型可能在这方面存在不足。 上下文理解的提升策略 增强长文本处理能力：改进模型的长文本处理机制，使其能够更好地理解和记忆长篇文本中的上下文。培养特定领域的专业知识：为模型提供特定领域的深入学习机会，使其能更准确地处理相关领域的文本。 通过理解这些原因，并采取相应的改进措施，我们可以有效地减少大型语言模型在生成文本时出现的「幻觉」问题，提高其输出的准确性和可靠性。
解决方案 针对大型语言模型的「幻觉」问题，我们可以采取以下策略来解决或减轻这一问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/248ad75defb84a6161f3d00f9075f2ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f97264001a0158679ecaa0b0a24268a8/" rel="bookmark">
			基于RuoYi-Vue集成 Lombok&#43;Mybatis-Plus&#43;Undertow&#43;SpringDoc&#43;Hutool 重写所有原生业务 定期与RuoYi-Vue同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平台简介 RuoYi-Vue-Plus 是重写 RuoYi-Vue 针对 分布式集群 场景全方位升级(不兼容原框架)
系统演示: 传送门
功能介绍使用技术文档地址特性注意事项当前框架RuoYi-Vue-PlusRuoYi-Vue-Plus文档重写RuoYi-Vue全方位升级(不兼容原框架)微服务分支RuoYi-Cloud-Plus微服务分支地址重写RuoYi-Cloud全方位升级(不兼容原框架)单体分支RuoYi-Vue-Plus-fastfast分支地址单体应用结构Vue3分支RuoYi-Vue-Plus-UIUI地址由于组件还未完善 仅供学习原框架RuoYi-VueRuoYi-Vue官网定期同步需要的功能前端开发框架Vue、Element UIElement UI官网后端开发框架SpringBootSpringBoot官网容器框架UndertowUndertow官网基于 XNIO 的高性能容器权限认证框架Sa-Token、JwtSa-Token官网强解耦、强扩展关系数据库MySQLMySQL官网适配 8.X 最低 5.7关系数据库OracleOracle官网适配 11g 12c关系数据库PostgreSQLPostgreSQL官网适配 13 14关系数据库SQLServerSQLServer官网适配 2017 2019缓存数据库RedisRedis官网适配 6.X 最低 4.X数据库框架Mybatis-PlusMybatis-Plus文档快速 CRUD 增加开发效率数据库框架p6spyp6spy官网更强劲的 SQL 分析多数据源框架dynamic-datasourcedynamic-ds文档支持主从与多种类数据库异构序列化框架JacksonJackson官网统一使用 jackson 高效可靠Redis客户端RedissonRedisson文档支持单机、集群配置分布式限流RedissonRedisson文档全局、请求IP、集群ID 多种限流分布式队列RedissonRedisson文档普通队列、延迟队列、优先队列 等分布式锁Lock4jLock4j官网注解锁、工具锁 多种多样分布式幂等RedissonLock4j文档拦截重复提交分布式日志TLogTLog文档支持跟踪链路日志记录、性能分析、链路排查分布式任务调度Xxl-JobXxl-Job官网高性能 高可靠 易扩展文件存储MinioMinio文档本地存储文件存储七牛、阿里、腾讯OSS使用文档云存储短信模块阿里、腾讯短信使用文档短信发送监控框架SpringBoot-AdminSpringBoot-Admin文档全方位服务监控校验框架ValidationValidation文档增强接口安全性、严谨性 支持国际化Excel框架Alibaba EasyExcelEasyExcel文档性能优异 扩展性强文档框架Knife4jKnife4j文档美化接口文档工具类框架Hutool、LombokHutool文档减少代码冗余 增加安全性代码生成器适配MP、Knife4j规范化代码Hutool文档一键生成前后端代码部署方式DockerDocker文档容器编排 一键部署业务集群国际化SpringMessageSpringMVC文档Spring标准国际化方案 参考文档 使用框架前请仔细阅读文档重点注意事项
初始化项目 必看
https://gitee.com/JavaLionLi/RuoYi-Vue-Plus/wikis/关于初始化项目?sort_id=4164117
部署项目 必看
https://gitee.com/JavaLionLi/RuoYi-Vue-Plus/wikis/关于应用部署?sort_id=4219382
参考文档 Wiki
https://gitee.com/JavaLionLi/RuoYi-Vue-Plus/wikis/pages
软件架构图 贡献代码 欢迎各路英雄豪杰 PR 代码 请提交到 dev 开发分支 统一测试发版
框架定位为 通用后台管理系统(分布式集群强化) 原则上不接受业务 PR
其他 同步升级 RuoYi-VueGitHub 地址 RuoYi-Vue-Plus-github单模块 分支 RuoYi-Vue-Plus-fast微服务 分支 RuoYi-Cloud-Plus用户扩展项目 扩展项目列表 加群与捐献 加群与捐献
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f97264001a0158679ecaa0b0a24268a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/633ec4fc41439cd7f47cab4ed794748b/" rel="bookmark">
			Lumeical Script------Script Prompt 中的两种输出方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lumeical Script------Script Prompt 中的两种输出方式 引言正文方法1方法2 引言 有时候，和众多编程语言一样，我们需要在 Script Prompt 中打印一些我们已经得到的数据，这样可以方便我们调试代码和查看代码中是否有错误。关于在 Script Prompt 中打印数据，Lumerical Script 提供了两种方法。
正文 方法1 mode1 = 1.677360; ?mode1; 方法2 mode1 = 1.677360; print(mode1); 如果大家觉得有用，就请点个赞吧~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a9709e2cf5a3523269660360b243e86/" rel="bookmark">
			Mybatis源码基本原理--XML版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 mybatis是什么架构设计首先建立起Mapper的代理工程和代理映射器的注册和使用XML文件解析数据源解析、创建和使用SQL执行器（Executor）的定义与实现SQL解析参数处理器：策略模式实现封装处理结果注解 mybatis 是什么 MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。
——来自官方文档
架构设计 通过XMLConfigBuilder解析xml文件放到Configuration对象中
首先建立起Mapper的代理工程和代理 代理类
package cn.mybatis.binding; import java.io.Serializable; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.Map; public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable { private static final long serialVersionUID = -6424540398559729838L; private Map&lt;String, String&gt; sqlSession; private final Class&lt;T&gt; mapperInterface; public MapperProxy(Map&lt;String, String&gt; sqlSession, Class&lt;T&gt; mapperInterface) { this.sqlSession = sqlSession; this.mapperInterface = mapperInterface; } @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable { if(Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a9709e2cf5a3523269660360b243e86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3ee7b377549c67a4dc18562b93024ed/" rel="bookmark">
			【Python】项目打包：如何使用PyInstaller打包python程序(exe)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、PyInstaller二、安装PyInstaller库三、PyInstaller的使用1.命令行+参数2.py文件+参数2.1配置文件config.py2.2打包文件pyTexe.py2.3 执行pyTexe.py 四、exe附加参数执行总结 前言 常用python的开发者现在也是很多的，用python可以做很多事情，如果涉及到python桌面开发一定会使用PyInstaller将程序打包成执行程序，如果要求更高的话还会再次封装成安装程序（工具inno setup）。
执行程序就是复制到其他电脑可以直接运行，不需要安装配置python环境。
安装程序就是我们日常安装的软件，会指引下一步安装，可以选择安装位置。
一、PyInstaller PyInstaller是一个在Windows、GNU/Linux、macOS等平台下将Python程序冻结（打包）为独立可执行文件的工具, 用于在未安装Python的平台上执行Python编写的应用程序。其实主要还是看参数如何使用。
二、安装PyInstaller库 本片博客是使用清华pip源安装。官方文档请看PyInstaller。
pip install PyInstaller -i https://pypi.tuna.tsinghua.edu.cn/simple/ 三、PyInstaller的使用 本博客主要介绍2种方式，这2种方式都会生成.spec文件，PyInstaller就是以spec文件来完成打包工作的。
1.命令行+参数 这是我们常用的方式，也是很多人百度得到的结果，大多数都是直接服用他人的命令和参数。
代码如下（示例）：
# 基础命令 pyinstaller myscript.py # 初次打包建议添加-c参数，可以同过cmd黑窗口查看打包问题 pyinstaller -c myscript.py # 生成一个单独的exe文件，适合无文件操作的程序 pyinstaller -F myscript.py # 生成一个单独的exe文件，适用windows系统，适合无文件操作的程序，下面2个是一样的效果。 pyinstaller -F -w myscript.py pyinstaller -F --windowed myscript.py # 生成一个文件夹，文件夹中包含exe执行程序，适合有一定文件夹或文件的操作程序。 pyinstaller -D --windowed myscript.py # 针对文件生成的最终位置，使用--distpath=参数指定 pyinstaller -D --windowed --distpath='C:\Users\lenovo\PycharmProjects\程序打包文件' myscript.py # 针对文件生成的exe文件名字，使用--name=TYQT参数指定 pyinstaller -D --windowed --distpath='C:\Users\lenovo\PycharmProjects\程序打包文件' --name='TYQT' myscript.py # 针对文件生成的exe的图标，使用--icon=参数指定,zaiwindows系统下，需要使用ico图标，如果是png直接百度在线转 pyinstaller -D --windowed --distpath='C:\Users\lenovo\PycharmProjects\程序打包文件' --name='TYQT' --icon='icon.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3ee7b377549c67a4dc18562b93024ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e0cd45039d38e9b3112de95013e17e/" rel="bookmark">
			获取CNN/DM适用于评估Bart的格式的数据集（类似于test.source、test.source.tokenized）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： 复现文本摘要任务评估CNN/DM数据集
问题描述 abisee老哥的代码获取的是bin格式的数据集
时间久远，一些依赖的配置版本难以复现
笔者需要能评估Bart 格式的数据集
形式类似于test.source、test.source.tokenized
解决方案： 经过坚持不懈的爬楼找到了有用的生成代码，并且测试成功，故此记录一下
首先指路github地址
此处有更新后的预处理脚本
1 下载数据 从这里下载并解压缩CNN和每日邮报的 stories 目录。
2.处理为.source和.target文件 Run 运行
python make_datafiles.py /path/to/cnn/stories /path/to/dailymail/stories 将 /path/to/cnn/stories·替换为您保存下载的 cnn/stories 目录的路径;类似于dailymail/stories。
对于每个URL列表（ all_train.txt 、 all_val.txt 和 all_test.txt ），从文件中读取相应的故事并将其写入文本文件 train.source 、 train.target 、 val.source 、 val.target 以及 test.source 和 test.target 。它们将被放置在新创建的 cnn_dm 目录中。
输出现在适合于馈送到BART微调的BPE预处理步骤。
3.完成后的结算画面 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a96f8993b4feaa19bd97963a8649fd9/" rel="bookmark">
			Android adb查看系统时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 记录下 adb 查看系统时间的方法，adb shell 后执行 date 命令即可。
使用 AS 模拟器测试的。
手动更换系统时间后，再次执行，时间会更新为更换后的。
generic_x86:/ # date Tue Jan 5 07:50:13 GMT 2021 generic_x86:/ # 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9858f1902653bd87f07aa87565791bac/" rel="bookmark">
			Unity 打包前，通过代码对 AndroidManifest 增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了实现不同Android渠道，采用不同的 AndroidManifest 配置。
需要在Unity打包前，通过代码自动修改 AndroidManifest.xml 文件的内容，实现自动化一键生成，减少了生成 android studio 工程后再修改的麻烦。
首先，Unity 提供了打包前和打包后调用的接口(interface)
IPreprocessBuildWithReport.OnPreprocessBuild ​ IPostprocessBuildWithReport.OnPostprocessBuild 其次，C# 提供了修改 XML 文件的库 System.Xml
方便了我们对 AndroidManifest.xml 文件进行增删改查
最后，为了实现灵活配置，采用了 Json 文件作为配置文件
独立的 Json 文件便于管理，保存在工程特定目录。
我这里使用的为 Newtonsoft.Json 库，小巧
using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using UnityEditor.Build; using UnityEditor.Build.Reporting; using System.IO; using System.Xml; using Newtonsoft.Json; /// &lt;summary&gt; /// created by lymancao @ 2023.08.23 /// 说明： /// 为了针对不同Android渠道，进行 AndroidManifest 文件的不同配置，特意实现此功能。 /// 利用 Unity 提供的打包前调用接口，C#的XML库 /// 引入 Newtonsoft.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9858f1902653bd87f07aa87565791bac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d03f3b2507797239d884052de7f6dcd4/" rel="bookmark">
			adb 查看顶层应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 做 android 开发，常常需要调试查看当前是哪个应用、哪个页面，可用这两个命令查看
adb shell 后执行
1.dumpsys activity activities | grep mResumedActivity2.dumpsys window windows | grep mFocusedApp3.dumpsys activity activities | grep topResumedActivity ，在安卓 13 上 ，前两个失效，可以用这个 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6c0a0ece4727d22d711a95850a31726/" rel="bookmark">
			Python Web框架FastAPI——一个比Flask和Tornada更高性能的API框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、FastAPI框架概述
二、FastAPI与Flask和Tornado的性能对比
1、路由性能
2、请求处理性能
3、内存占用
三、FastAPI的优点与特色
四、代码示例
五、注意事项
六、结论
在当今的软件开发领域，快速、高效地构建API成为了许多项目的关键需求。为了满足这一需求，Python开发者社区提供了多种Web框架，其中FastAPI、Flask和Tornado都是备受欢迎的选择。然而，在这三者之间，FastAPI以其卓越的性能和简洁的语法脱颖而出，成为了许多开发者的首选。本文将深入剖析FastAPI的特点，并与Flask和Tornado进行对比，从而证明其作为高性能API框架的价值。
一、FastAPI框架概述 FastAPI是一个现代、快速（高性能）的Web框架，用于构建API。它基于Python 3.6+的类型提示，并利用了Starlette和Pydantic这两个流行的库。FastAPI的目标是提供最佳的开发体验和生产就绪功能，同时保持其简洁、易读和易于维护的特性。
二、FastAPI与Flask和Tornado的性能对比 1、路由性能 在路由性能方面，FastAPI表现出了显著的优势。相较于Flask和Tornado，FastAPI的路由匹配速度更快。这主要得益于FastAPI使用的Pydantic模型和Starlette的路由机制。在处理大量路由时，FastAPI能够提供更高的性能。
2、请求处理性能 在请求处理方面，FastAPI同样具有出色的性能。FastAPI使用了Starlette的异步Web框架，使得其处理请求的速度远超Flask和Tornado。对于需要处理大量并发请求的应用程序，FastAPI的高性能特性尤为重要。
3、内存占用 在内存占用方面，FastAPI同样具有显著的优势。由于其简洁的代码结构和高效的内部实现，FastAPI在运行时的内存占用远低于Flask和Tornado。这对于资源受限的环境或需要处理大量并发请求的应用程序来说，是一个重要的考量因素。
三、FastAPI的优点与特色 快速开发：FastAPI提供了简洁、易读的代码结构，使得开发者能够快速构建应用程序。同时，FastAPI支持自动生成文档，大大提高了开发效率。高性能：FastAPI在路由匹配、请求处理和内存占用等方面均表现出卓越的性能，能够满足各种规模的应用程序需求。异步支持：FastAPI支持异步编程，使得应用程序能够更好地利用系统资源，提高并发处理能力。类型提示：FastAPI充分利用了Python 3.6+的类型提示功能，提高了代码的可读性和可维护性。同时，类型提示也有助于发现潜在的错误，减少运行时错误的风险。易于扩展：FastAPI的设计鼓励模块化开发，使得应用程序易于扩展和维护。此外，FastAPI支持与各种数据库和缓存系统的集成，为开发者提供了丰富的功能。社区支持：FastAPI作为一个新兴的Web框架，得到了广泛的社区支持。随着越来越多的开发者采用FastAPI，社区将不断壮大和完善，为开发者提供更多优质的资源和支持。 四、代码示例 # 导入所需的库 from fastapi import FastAPI, Form, Body from pydantic import BaseModel # 创建FastAPI实例 app = FastAPI() # 定义用户模型 class User(BaseModel): username: str password: str = None email: str = None # 创建路由和对应的方法 @app.post("/users/") async def create_user(user: User = Body(...)): return {"user": user.dict()} @app.get("/users/") async def read_users(): return [{"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6c0a0ece4727d22d711a95850a31726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f3eaeb9ddd9dae9e1fdf0f1a764991d/" rel="bookmark">
			Wargames与bash知识07
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Wargames与bash知识07 Bandit Level 13 关卡提示：
密码保存在文件/etc/bandit_pass/band14，但是这个文件只有bandit14用户能够读取。正因为如此，如果使用当前用户bandit13是无法获取的密码的。好的一点是您可以使用私钥免密登录bandit14.
注意： localhost代表的是本地主机。
命令提示：
ssh, telnet, nc, openssl, s_client, nmap
到目前为止，我们在大部分情况下使用的终端工具登录ssh服务器，比如我使用的MobaXterm，正因为如此，目前我们对ssh在命令行的用法还很陌生。下面我们看看ssh在命令行的用法。
ssh SH（Secure Shell）是一种网络协议，用于通过加密的方式在网络上进行安全的远程登录和执行命令。下面是一些常用的SSH命令参数的详解：
-p：指定SSH服务器的端口号，默认是22端口。 例如：ssh -p 2222 user@host
-l：指定要登录的用户名。 例如：ssh -l username host
-i：指定用于身份验证的私钥文件。 例如：ssh -i private_key.pem user@host
-C：启用压缩功能，可以提高传输速度。 例如：ssh -C user@host
-X：启用X11转发，可以在远程主机上显示图形界面程序。 例如：ssh -X user@host
-N：不执行远程命令，只进行连接，常用于建立隧道。 例如：ssh -N -L 8080:localhost:80 user@host
-L：本地端口转发，将本地端口转发到远程主机。 例如：ssh -L 8080:localhost:80 user@host
-R：远程端口转发，将远程端口转发到本地主机。 例如：ssh -R 8080:localhost:80 user@host
-D：动态端口转发，可以将本地主机作为代理服务器使用。 例如：ssh -D 1080 user@host
localhost 在计算机网络中，localhost（意为“本地主机”，指“这台计算机”）是给回路网络接口（loopback）的一个标准主机名，相对应的IP地址为127.0.0.1（IPv4）和[::1]（IPv6）。
现在可以解题了：
bandit13@bandit:~$ ls sshkey.private bandit13@bandit:~$ ssh -i .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f3eaeb9ddd9dae9e1fdf0f1a764991d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30dd9696b662193f953987d6cac654bc/" rel="bookmark">
			Node.js商城APP的开发 毕业设计-附源码 97200
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 在传统的商业模式中，对于日常各类商品，人们习惯于到各种商家店铺购买。然而在快节奏的新时代中，人们不一定能为购买各类商品腾出时间，更不会耐心挑选自己想要的商品。所以设计一个商城APP，既是迎合电子商务的大潮流，也是传统商品销售行业的一个突破口，可以给传统销售行业带来转变和机遇。
本系统主要是提供给用户一个购买各类商品的APP，通过价格优势吸引众多消费者来购买，实现正常运营。该系统采取面对对象的开发模式进行软件的开发和硬体的架设，能很好的满足实际使用的需求，完善了对应的软体架设以及程序编码的工作系统采取Mysql作为后台数据的主要存储单元，运用软件工程原理和开发方法，采用node.js的koa技术构建的一个管理系统，实现了本系统的全部功能。目标是实现一个以销售为中心的计算机系统，构建用户信息与账号，账号与订单信息有机结合的业务系统。
关键词：商城APP；线上购物；Node.js
Development of Node.js Mall APP ABSTRACT in the traditional business model, people are used to buying various kinds of daily goods in various stores. However, in the fast-paced new era, people may not be able to spare time for purchasing various kinds of goods, let alone patiently select the goods they want. Therefore, designing a mall APP is not only to meet the trend of e-commerce, but also a breakthrough in the traditional commodity sales industry, which can bring changes and opportunities to the traditional sales industry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30dd9696b662193f953987d6cac654bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a80b122e132475c7e4ce09b00fd875e0/" rel="bookmark">
			opencv图像金字塔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下采样：
#include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; int main() { // 读取图像 cv::Mat src = cv::imread("C:/Users/10623/Pictures/adf4d0d56444414cbeb809f0933b9214.png"); if (src.empty()) { std::cout &lt;&lt; "无法加载图像" &lt;&lt; std::endl; return -1; } // 创建一个与源图像同样大小的 Mat 对象，用于存储结果 cv::Mat dst1,dst2,dst3; // 使用 pyrDown 进行向下采样 cv::pyrDown(src, dst1); cv::pyrDown(dst1, dst2); cv::pyrDown(dst2, dst3); // 显示原始图像和下采样后的图像 cv::imshow("Original Image", src); cv::imshow("Downsampled Image", dst1); cv::imshow("2",dst2); cv::imshow("3",dst3); cv::waitKey(0); return 0; } #include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; int main() { // 读取图像 cv::Mat src = cv::imread("path_to_your_image.jpg"); if (src.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a80b122e132475c7e4ce09b00fd875e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e08db75979985dc0bf4bb15b9a3c5438/" rel="bookmark">
			Spring Boot日志配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在今天的数字化时代，日志记录已经成为任何应用程序不可或缺的一部分，它们是我们理解系统行为、诊断问题和监控应用性能的关键。对于使用Spring Boot的开发者来说，有效的日志管理就像是进行一场精确的数据舞蹈，需要精心编排每一个步骤。
日志管理的重要性 日志记录不仅仅是为了在出现问题时进行调试，它还帮助我们监控应用程序的健康状况，了解用户行为，甚至是作为安全审计的重要工具。在微服务架构和分布式系统中，日志更是联系服务之间复杂交互的纽带。没有有效的日志管理，我们将处于一片黑暗之中，无法看清系统的真实运行状况。
Spring Boot的日志架构 Spring Boot为日志管理提供了强大的支持，它默认集成了SLF4J（简单日志门面）和Logback。SLF4J作为抽象层，允许你在底层使用任何日志框架，而Logback则是默认的日志实现，它强大、灵活且速度快。
import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class MyBean { private static final Logger logger = LoggerFactory.getLogger(MyBean.class); public void doSomething() { logger.info("Doing something"); } } 在Spring Boot中，你可以轻松地通过配置文件来控制日志级别、输出格式和目标。
配置日志级别 日志级别是决定你想看到哪些日志的关键。在Spring Boot中，你可以在application.properties或application.yml文件中设置日志级别。
# application.properties logging.level.root=WARN logging.level.com.yourpackage=INFO # application.yml logging: level: root: WARN com.yourpackage: INFO 日志格式化 日志的格式化关系到日志信息的可读性。Spring Boot允许你自定义日志输出格式。
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n logging.pattern.file=%d{yyyy-MM-dd} [%thread] %-5level %logger{36} - %msg%n 这些配置能帮助你输出包含日期、时间、线程、日志级别和消息的日志行。
日志记录最佳实践 要有效地记录日志，你需要遵守一些最佳实践：
使用正确的日志级别：根据信息的重要性选择合适的级别。避免日志污染：不要记录太多不必要的信息。结构化日志数据：尽量以结构化的格式记录日志，便于分析。异步记录日志：考虑使用异步方式记录日志，避免阻塞主应用流程。 调试应用 在开发过程中，你可能需要更详细的日志来帮助调试。Spring Boot允许你临时增加日志级别，以便于调试。
logging.level.com.yourpackage=DEBUG 日志持久化 对于生产环境，将日志写入文件或传输到外部系统是常见需求。Spring Boot可以配置日志文件路径和文件滚动策略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e08db75979985dc0bf4bb15b9a3c5438/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b9787fb425556314b81eec8aaac2185/" rel="bookmark">
			用HTML的原生语法实现两个div子元素在同一行中排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下：
&lt;div id="level1" style="display: flex;"&gt; &lt;div id="level2-1" style="display: inline-block; padding: 10px; border: 1px solid #ccc; margin: 5px;"&gt; 这是第一个元素。 &lt;/div&gt; &lt;div id="level2-2" style="display: inline-block; padding: 10px; border: 1px solid #ccc; margin: 5px;"&gt; 这是第二个元素。 &lt;/div&gt; &lt;/div&gt; 当外层的父元素的背景设为黑色，字体为白色的情况下，效果如下：
当然可以把边框去掉，去掉边框的代码如下：
&lt;div id="level1" style="display: flex;"&gt; &lt;div id="level2-1" style="display: inline-block; padding: 10px; margin: 5px;"&gt; 这是第一个元素。 &lt;/div&gt; &lt;div id="level2-2" style="display: inline-block; padding: 10px; margin: 5px;"&gt; 这是第二个元素。 &lt;/div&gt; &lt;/div&gt; 当外层的父元素的背景设为黑色，字体为白色的情况下，效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c861f4c510ea67e393e11fdc395883e/" rel="bookmark">
			flutter获取本地图片高度、宽度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*获取本地图片宽度 * */ getLocalImageWidth(String path){ int width; Completer&lt;int&gt; completer = new Completer&lt;int&gt;(); Image image = Image.file(File.fromUri(Uri.parse(path))); // 预先获取图片信息 image.image.resolve(new ImageConfiguration()).addListener( new ImageStreamListener((ImageInfo info, bool _) { width = info.image.width; print('height===$width'); completer.complete(width); })); return completer.future; } /*获取本地图片高度 * */ getLocalImageHeight(String path){ int height; Completer&lt;int&gt; completer = new Completer&lt;int&gt;(); Image image = Image.file(File.fromUri(Uri.parse(path))); // 预先获取图片信息 image.image.resolve(new ImageConfiguration()).addListener( new ImageStreamListener((ImageInfo info, bool _) { height = info.image.height; print('height===$height'); completer.complete(height); })); return completer.future; } //使用 int originalWidth,originalHeight; originalWidth = await Utils().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c861f4c510ea67e393e11fdc395883e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87896059cae68b3f350a21906a5e56b0/" rel="bookmark">
			uniapp中组件库的Checkbox 复选框 的丰富使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
#平台差异说明
#基本使用
#自定义形状
#禁用checkbox
#自定义形状
#自定义颜色
#横向排列形式
#横向两端排列形式
API
#Checkbox Props
#CheckboxGroup Props
#CheckboxGroup Event
复选框组件一般用于需要多个选择的场景，该组件功能完整，使用方便
#平台差异说明 App（vue）App（nvue）H5小程序√√√√ #基本使用 &lt;template&gt; &lt;view&gt; &lt;u-checkbox-group v-model="checkboxValue1" placement="column" @change="checkboxChange" &gt; &lt;u-checkbox :customStyle="{marginBottom: '8px'}" v-for="(item, index) in checkboxList1" :key="index" :label="item.name" :name="item.name" &gt; &lt;/u-checkbox&gt; &lt;/u-checkbox-group&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { checkboxValue1:[], // 基本案列数据 checkboxList1: [{ name: '苹果', disabled: false }, { name: '香蕉', disabled: false }, { name: '橙子', disabled: false } ], } }, methods: { checkboxChange(n) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87896059cae68b3f350a21906a5e56b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cfda3917b152936ed3f809f153c54fc/" rel="bookmark">
			SpringBoot自定义拦截器Interceptor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言示例1. 自定义拦截器2. 配置类 前言 SpringBoot 自定义一个拦截器
示例 1. 自定义拦截器 import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @Slf4j @Component public class MyInterceptor implements HandlerInterceptor { /** * 执行Controller方法之前 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info("MyInterceptor 执行 preHandle, request uri={}, url={}", request.getRequestURI(), request.getRequestURL()); return true; // 返回false，请求将被拦截，返回true代表放行 } /** * 执行Controller方法之后，响应给前端之前 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cfda3917b152936ed3f809f153c54fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba5ea6ab9e64b917eca4a221c19a3ea2/" rel="bookmark">
			Android 使用 retrofit2 解析XML响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 处理JSON使用 converter-gson，一下子来个XML，搜索依赖发现有个 converter-simplexml，IDE提示 converter-simplexml 已经过时，然后改用 converter-jaxb，后来到github看文档才知道 converter-jaxb 在 Android 上用不了，simplexml 又提示不支持XML1.1，再一看文档，Android上使用 simplexml 要去除几个依赖，然后就搞定了，kts配置如下：
implementation("com.squareup.retrofit2:converter-simplexml:2.9.0") { exclude( module= "stax") exclude (module= "stax-api") exclude (module = "xpp3") } groovy配置如下：
implementation('com.squareup.retrofit2:converter-simplexml:2.9.0') { exclude module: 'stax' exclude module: 'stax-api' exclude module: 'xpp3' } 最后附上几个参考链接：
Simple XML Converter
Parsing XML using Retrofit2 in Kotlin 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe15dd7181e67e8735dad5e938b4a804/" rel="bookmark">
			uniapp中组件库的Textarea 文本域的丰富使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
#平台差异说明
#基本使用
#字数统计
#自动增高
#禁用状态
#下划线模式
#格式化处理
API
#List Props
#Methods
#List Events
文本域此组件满足了可能出现的表单信息补充，编辑等实际逻辑的功能，内置了字数校验等
注意：
由于在nvue下，u-textarea名称被uni-app官方占用，在nvue页面中请使用u--textarea名称，在vue页面中使用u--textarea或者u-textarea均可。
#平台差异说明 App（vue）App（nvue）H5小程序√√√√ #基本使用 &lt;u--textarea v-model="value1" placeholder="请输入内容" &gt;&lt;/u--textarea&gt; &lt;script&gt; export default { data() { return { value1: '', } }, } &lt;/script&gt; #字数统计 设置count属性实现字数统计
&lt;u--textarea v-model="value2" placeholder="请输入内容" count &gt;&lt;/u--textarea&gt; &lt;script&gt; export default { data() { return { value2: '统计字数', } }, } &lt;/script&gt; #自动增高 设置autoHeight属性实现自动增高
&lt;u--textarea v-model="value3" placeholder="请输入内容" autoHeight &gt;&lt;/u--textarea&gt; &lt;script&gt; export default { data() { return { value3: '', } }, } &lt;/script&gt; #禁用状态 设置disabled属性实现进行禁用，您也可以动态设置是否禁用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe15dd7181e67e8735dad5e938b4a804/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/916ad4d0ac67348d719948bb2c8a3ac7/" rel="bookmark">
			STM32 ADC最大采样频率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 stm32f103 ADC 外设时钟频率 72/6 = 12MHZ
每次采样 = 固定周期 + 12.5个周期 则最小采样时间 = 14T 最快采样频率 = 12 / 14 = 0.857MHZ 不足1M
据说STM32 F3系列 采样频率可以达到 5MHZ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24f28e0840c8e1e0cfe60888b55c9504/" rel="bookmark">
			处理自己的视频数据并训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取视频数据的信息 import cv2 if __name__ == "__main__": video_path = "视频路径" cap = cv2.VideoCapture(video_path) # 视频总的帧数 frame_num = cap.get(7) # 图片帧率 fps = cap.get(5) while True: ret, frame = cap.read() print(f"视频帧率{fps} 视频总帧数{frame_num } 视频分辨率{frame.shape}") 通过上述代码就能获取到视频帧率、帧数、分辨率信息，根据需求自行确立采样的分辨率与帧数。
将视频数据转换为npy数据 npy数据的好处：读取速度快，省去了解码时间
坏处：增加了空间
这是一种时间换空间的策略
import cv2 import numpy as np if __name__ == "__main__": video_path = "视频路径" cap = cv2.VideoCapture(video_path) # 获取帧率 fps = int(cap.get(5)) frame_lists = [] while True: ret, frame = cap.read() if not(ret): break # 对图片数据做缩小，缩小为224*224 frame = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24f28e0840c8e1e0cfe60888b55c9504/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4be321f0a86ed577b1a8252fe3457180/" rel="bookmark">
			SQL注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手动
查找主人的
自动
扫描注入点
尝试各种组合语法
sql注入
sql语句复习
show databases
使用库 use 库
查看默认库 select database();
查看所有表：show tables;
查看标结构：desc 表
查看创建表sql语句：show create table user\G
查看当前默认用户 ：select user()
查询所有字段：select *from users;
查询指定字段：select user,password from users
条件查询:select *from users where user='admin'
逻辑与：select * from users where user='admin' and user_id=6
逻辑或：select * from users where user='admin' and user_id=5
UNION语句：sql注入漏洞
作用：将两条sql语句联合起来查询
语法：sql1 union sql2
两条sql语句查询字段数必须相同
select user,password from mysql.user;
union
select user,password from mysql.users;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4be321f0a86ed577b1a8252fe3457180/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7858c6271ca4963e2e525e753fdc35ec/" rel="bookmark">
			leetcode12 整数转罗马数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：给定一个整数，将其转换为罗马数字。罗马数字由七个字符表示：I（1）、V（5）、X（10）、L（50）、C（100）、D（500）和M（1000）。通常情况下，小的数字位于大的数字的右边。但有特殊情况，如4表示为IV（5-1），9表示为IX（10-1），40表示为XL（50-10），90表示为XC（100-10），400表示为CD（500-100），900表示为CM（1000-100）。编写一个程序，将给定的整数转换为相应的罗马数字表示。
示例：
输入: num = 1994 输出: "MCMXCIV" 解释: M = 1000, CM = 900, XC = 90, IV = 4. 方法1 模拟（来源于力扣官解） 思路：给定一个数字number，找到不超过该数字的罗马符号对应的值（这个值应为最大的那个），比如1100这个数字，为1000；888则为500；然后循环往复，按这个套路一直减，然后得到的对应罗马符号挨个拼起来，直到无法再减，也就是他喵的这个数字最后为0，停止运行，下面以特定的数字进行演示，如下图所示：
c++完整代码： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; //创建一个名为valueSymbols的pair，并进行初始化 const pair&lt;int, string&gt; valueSymbols[] = { {1000, "M"}, {900,"CM"}, {500,"D"}, {400,"CD"}, {100,"C"}, {90,"XC"}, {50,"L"}, {40,"XL"}, {10,"X"}, {9,"IX"}, {5,"V"}, {4,"IV"}, {1,"I"}, }; class Solution{ public: string intToRoman(int num){ string roman; for(const auto &amp;[value,symbol]:valueSymbols){ while(num &gt; value){ num -= value; //当前数减去特定的罗马字符对应的数字 roman += symbol; //罗马字符进行累加 } if(num == 0){ //当前数字为0时 break; } } return roman;//返回罗马字符 } }; int main(){ int number = 3333; Solution solution; std::string roman = solution.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7858c6271ca4963e2e525e753fdc35ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fc194f1ea3bf4c8f55d3e5b8a306902/" rel="bookmark">
			java 的synchronized和volatile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java代码安全性的三大要素 在Java并发编程中，原子性、可见性和有序性是保证代码安全性的三大要素。为了解决这些问题，Java提供了多个关键字和机制。
原子性是指一个或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么就都不执行。对于原子性，Java的synchronized关键字和Lock相关的工具类可以起到保障作用，它们可以确保整个过程中的操作要么全部完成，要么就都不完成，从而保证了原子性。
以下是使用synchronized关键字的代码： public class AtomicExample { private int count = 0; public synchronized void increment() { count++; } public synchronized void decrement() { count--; } public synchronized int getCount() { return count; } } 可见性是指当一个线程修改了一个变量的值，其他线程能够立即看到这个修改。volatile关键字在Java中主要用于保证变量的可见性，它可以确保当一个线程修改了volatile变量的值，新值对于其他线程立即可见。
有序性是指程序中的语句按照代码的先后顺序依次执行。在Java中，可以使用synchronized关键字来保证有序性，因为它会锁定代码块，确保同一时刻只有一个线程能够访问该代码块，从而避免了编译优化和处理器指令重排导致的有序性问题。
以下是使用volatile关键字的代码：
public class VolatileExample { private volatile boolean flag = false; public void setFlag() { flag = true; } public boolean checkFlag() { return flag; } public static void main(String[] args) throws InterruptedException { VolatileExample example = new VolatileExample(); // 创建两个线程，分别设置和检查flag的值 Thread t1 = new Thread(example::setFlag); Thread t2 = new Thread(() -&gt; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fc194f1ea3bf4c8f55d3e5b8a306902/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f6370ead8d5638efd6809896255b756/" rel="bookmark">
			序列化与反序列化xml bin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、XML XML（可扩展标记语言）序列化是一种将对象的数据结构转换为XML格式的过程，以便将其存储在文件中、通过网络传输或与其他系统进行数据交换。在C#中，你可以使用.NET框架提供的XmlSerializer类来执行对象到XML的序列化和XML到对象的反序列化操作。
using System; using System.IO; using System.Xml.Serialization; // 定义一个简单的类 [Serializable] public class Person { public string Name { get; set; } public int Age { get; set; } } class Program { static void Main() { // 创建一个Person对象 Person person = new Person { Name = "Alice", Age = 30 }; // 序列化 XmlSerializer serializer = new XmlSerializer(typeof(Person)); using (TextWriter writer = new StreamWriter("person.xml")) { serializer.Serialize(writer, person); } Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f6370ead8d5638efd6809896255b756/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/136add4ad014d13d916fce76b1c8396c/" rel="bookmark">
			oracle 子查询和窗口函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述：给定一张学生学科成绩表base_student_grade,字段id表示学生学号，name为姓名，subject表示学科，grade为某学科成绩。使用子查询和窗口函数查询每个学生成绩最高的学科和分数。
select id,name,subject,grade from ( select id,name,subject,grade, row_number() over(partition by id,name order by grade desc) as rn from base_student_grade ) where rn=1 注：
1. row_number() ：窗口函数。为结果集中的每一行生成一个唯一的行号。
2. partition by：将数据按照id,name进行分区，即将具有相同id,name的行分为同一个分区。
3. order by grade desc：每个分区按照grade降序排列。
4. rn=1：选取每个分区内的第一行，rn=2：选取每个分区内的第二行，rn&lt;=2：选取每个分区内的前两行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60dfd5e15dcc3a1dad4bb2cd0a547d8d/" rel="bookmark">
			【EI会议--快速录用】2024年应用力学与半导体国际学术会议(IACAMS 2024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【EI会议--快速录用】2024年应用力学与半导体国际学术会议(IACAMS 2024)
2024 International Conference Applied Mechanics and Semiconductors
一、【会议简介】
本次会议的主题为“应用力学与半导体技术的融合与发展”。我们将围绕这一主题展开深入的探讨和研究，内容涵盖了应用力学的各个方面，包括材料力学、结构力学、流体力学等，以及半导体技术的前沿进展，包括半导体材料、制造工艺、器件性能等。
我们荣幸地邀请您参加2024年应用力学与半导体国际学术会议。本次会议旨在为从事应用力学和半导体研究的专家、学者和业界人士提供一个平台，分享最新的研究成果、交流学术思想和技术创新。
二、【征稿主题】主题包括但不限于以下
力学与工程学
材料力学
弹性力学
固体力学
流体力学
水力学
土力学
岩石力学
结构力学
爆炸力学
空气动力学
塑性断裂与损伤力学
材料建模
受力分析
理论力学与应用力学
材料科学
半导体自旋物理与拓扑现象
半导体纳米与器件
宽/窄的带隙半导体
化合物半导体
磁性半导体
有机半导体
先进光刻胶
光电和光伏器件
半导体物理学
半导体量子计算
半导体材料与器件可靠性
半导体制造与应用
新兴半导体技术
智能制造
3D半导体器件技术
传感器
全集成自动化
机器人学
自动检测
三、【重要信息】
大会官网：http://www.iacams.com
投稿邮箱：iac_info@163.com
投稿时请邮箱正文备注：论文投稿+苏老师推荐+投稿人姓名
最终截稿时间：请查看官网
接受/拒稿：投稿后2-3日内通知
四、【论文提交】
1. 文章需全英文，重复率低于30%。
2. 文章必须要有题目、作者、单位、邮箱、关键词、摘要、必要的图表、结论、参考文献等。
3. 投稿流程：投稿→审稿→录用→注册→开具增值税普票（专票）→电子版→纸质版→检索。
4. 请勿一稿多投，所有稿件将接受两三名专家进行评审
五、【联系我们】
会议官网：http://www.iacams.com
邮箱：iac_info@163.com
工作邮箱：s19113133262@163.com
备注：你的名字+苏老师推荐，享投稿优惠+优先审稿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02d27ff92c99946fe0f6da40af1f564d/" rel="bookmark">
			winform简易用户权限管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、功能简介
1. 数据库可使用sqlite、mssql、mysql等
2. 管理员账号不管控，其余账号进行权限管控（左侧菜单，表单按钮），且只能看到自己创建的角色、用户
二、操作界面
1. 管理员账号登陆后，左侧菜单栏自动添加 “菜单管理” ，菜单选择 Menu / Button
2. 角色分配权限
3. 用户绑定角色
4. 游客登陆后界面
三、数据库表
四、源码结构
五、权限控制代码
1. 菜单栏
public static void SetTreeView(TreeView treeView1, ImageList imageList1, string checkList, bool onlyMenu = false) { if (null == checkList) checkList = string.Empty; treeView1.Nodes.Clear(); treeView1.ImageList = imageList1; // 管理员特别权限 if (onlyMenu &amp;&amp; LoginUser.Root) { TreeNode tn = new TreeNode(); tn.Text = "菜单管理"; treeView1.Nodes.Add(tn); } var list = FreeSqlHelper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02d27ff92c99946fe0f6da40af1f564d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f6048959d788a9edf819bc1fd65721c/" rel="bookmark">
			【高录用-快速见刊-EI稳定检索】2024年计算机建模与信号处理国际学术会议（ICCMSP 2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【高录用-快速见刊-EI稳定检索】2024年计算机建模与信号处理国际学术会议（ICCMSP 2024）
2024 International Conference on Computer Modeling and Signal Processing 一、【会议简介】
尊敬的各位专家、学者和与会嘉宾：
欢迎来到2024年计算机建模与信号处理国际学术会议！本次会议旨在为计算机建模与信号处理领域的专家、学者和业界人士提供一个交流与合作的平台，共同探讨该领域的新技术、新方法和新应用。
计算机建模与信号处理是一门重要的学科，已经广泛应用于通信、医疗、交通、能源等领域。随着技术的不断发展，该领域面临着越来越多的挑战和机遇。本次会议将聚焦于计算机建模与信号处理的最新研究成果，探讨未来发展方向和趋势。
本次会议邀请了来自世界各地的专家、学者和业界人士共同参与。会议将涵盖计算机建模与信号处理的各个方面，包括模型设计、算法优化、信号检测与恢复、数据处理与分析等。同时，会议还将组织专题研讨、技术展示和合作洽谈等活动，为与会者提供更多的交流机会。
在本次会议中，您将有机会：
1. 了解计算机建模与信号处理领域的最新研究成果和发展趋势；
2. 与来自世界各地的专家、学者和业界人士进行深入交流，共同探讨合作机会；
3. 展示您的研究成果和项目，扩大您的学术影响力和知名度；
4. 参加专题研讨和技术展示等活动，了解更多关于计算机建模与信号处理的技术和应用。
我们期待您的参与！让我们共同探讨计算机建模与信号处理领域的新未来和发展前景。
二、【重要信息】
最终截稿时间：请查看官网
接受/拒稿：投稿后2-3日内通知
三、【征稿主题】（包括但不限于）
建模与仿真方法
可视化和建模中的感知问题
模拟和建模中的数学和数值方法
高性能计算与仿真
普适计算与仿真
离散和数值模拟
并行与分布式计算仿真
实时建模和仿真
仿真优化
电力系统仿真
统计建模
物理建模
数学建模
设备仿真与建模
机器人系统仿真
工业仿真建模
交通工程仿真
航空航天系统仿真
基于物理的建模与仿真
材料工程仿真
信号处理与检测
雷达和声纳信号处理
通信信号处理
音频和声音信号处理
传感器阵列和多通道信号处理
多媒体信号处理
语音和语言处理
图像和视频处理
计算机视觉和机器人技术的信号处理
优化方法
计算成像/光谱成像
机器学习
通过图形和网络进行信号处理
压缩感知和稀疏建模
非线性信号处理
统计信号处理
物联网信号处理
信息取证和安全
教育信号处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f6048959d788a9edf819bc1fd65721c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93484d6fe17d44999fe64d425994d52c/" rel="bookmark">
			清风数学建模笔记-多分类-fisher线性判别分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 内容：Fisher线性判别分析
一.介绍：
1.给定的训练姐，设法投影到一维的直线上，使得同类样例的投影点尽可能接近和密集，异类投影点尽可能远离。
2.如何同类尽可能接近：方差越小
3.如何异类尽可能远离：计算距离大
二.SPSS进行线性判别分析
1.分析-分类-判别式
分析结果： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/850946d4cce961d2e29fc4a00878cc1b/" rel="bookmark">
			Vue&#43;JavaSpingBoot笔记(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前后端通信参数问题 1.集合【字典】类型 Vue前端传递参数:
export default { methods: { test(){ // 将 filteredData 中的每一行值放入 newData 对象数组中 const newData = filteredData.map(item =&gt; ({ key1: item.Value1, key2: item.Value2, key3: "测试" })); request({ url: '/url/ag', method: 'post', data: newData }).then(res =&gt; { if (res.code == 200) { this.$modal.msgSuccess('成功！') this.getList() } }) } } } java后端接收参数
controller:
@PostMapping("/ag") // 处理Post请求 public ResultBean again(@RequestBody List&lt;Map&lt;String,Object&gt;&gt; requestBody){ service.方法(requestBody); } service:
List&lt;Map&lt;String,Object&gt;&gt; maplist 直接遍历使用 2.字典+集合类型 Vue前端:
export default { methods: { test(){ // 字典数据 const dictData = { To: 值1, Key1: 'A', Key2: 值2, }; // 列表数据示例 const listData = []; request({ url: '/url/ag', method: 'post', data: { dictData: dictData, listData: listData } }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/850946d4cce961d2e29fc4a00878cc1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/310f03d5a0f86baab7e7b1fd88e96c7b/" rel="bookmark">
			python django 个人记账管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python django 个人记账管理系统。
功能：登录，新用户注册，个人信息修改，收入，支出记录，收入记账管理，支出记账管理，收入，支出统计
技术：python django，mysql，html。
环境：python3 mysql，pycharm。
源码下载地址：
https://download.csdn.net/download/m0_74433188/88677125?spm=1001.2014.3001.5503
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/563fd7298832e8e9da3a3c918d11febd/" rel="bookmark">
			获取网页信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每次copy &amp; paste总是很麻烦，现在有点问题，先记录下来。
需求：获取url 里Feature list，并输出表格形式
可以用Convert curl commands to code：得到get请求的header，cookie等 import requests import re from json2html import json2html from bs4 import BeautifulSoup cookies = { '_ga': 'GA1.2.1362872320.1699326902', '_fbp': 'fb.1.1703745569173.788449175', '_zm_visitor_guid': 'ab14067a105b55591ca36931e79a6fc0', '_zm_mtk_guid': 'b214987e283ec1df03f09df41170675b', '_ds_id': '8c2d2994-3b41-4b59-be95-2b8717ffe0e6', '__utmzz': 'source=(direct)|medium=(none)|campaign=(not set)', 'AMP_MKTG_0753e77572': 'JTdCJTdE', '_gcl_au': '1.1.55355038.1703817513', 'OnetrustActiveGroups': 'C0004C0003C0002C0001', 'AMP_0753e77572': 'JTdCJTIyZGV2aWNlSWQlMjIlM0ElMjJkYWQyMGM3NS0xYzdkLTRmODYtYjI4Yi03MTNmZTNlY2E5ZjglMjIlMkMlMjJzZXNzaW9uSWQlMjIlM0ExNzAzODE3NTEyNDY3JTJDJTIyb3B0T3V0JTIyJTNBZmFsc2UlMkMlMjJsYXN0RXZlbnRUaW1lJTIyJTNBMTcwMzgxNzUxMzMxMiUyQyUyMmxhc3RFdmVudElkJTIyJTNBMyU3RA==', '_yjsu_yjad': '1703817513.e9d3aadf-244b-4756-90c8-d8152831b27e', '_uetvid': '5c32b050a5f311ee8e0337e664efcd94', 'iv': '51a85645-5246-4995-9a5b-627ccafbae0b', '_cs_c': '0', '_cs_id': '0b459793-a9d5-a89c-c1e2-70499565b08c.1703817514.2.1703833540.1703833540.1.1737981514343', '_gid': 'GA1.2.1035150089.1704176623', 'BIGipServerpool_zoomus': '2f6ba358017c66e5283571a5c5fc3b1a', 'JSESSIONID': '2C44F6D93F6593E571F97C2BAE1AF4DB', 'glide_user_route': 'glide.de6ecf26cf6f93e1b52b94d2be12e7df', 'glide_language': 'zh', 'OptanonAlertBoxClosed': '2024-01-03T04:07:00.123Z', 'OptanonConsent': 'isGpcEnabled=0&amp;datestamp=Wed+Jan+03+2024+12%3A07%3A00+GMT%2B0800+(%E4%B8%AD%E5%9B%BD%E6%A0%87%E5%87%86%E6%97%B6%E9%97%B4)&amp;version=202310.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/563fd7298832e8e9da3a3c918d11febd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/39/">«</a>
	<span class="pagination__item pagination__item--current">40/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/41/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>