<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ff78143c5f4d2f9b75d79a016c8f38/" rel="bookmark">
			pip install configuration 报错，问题大同小异(已解决)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题发生 最近在研究selenium时，碰巧需要装configuration包，于是乎用pip在命令行安装
结果报了：
Preparing metadata (setup.py) ... error error: subprocess-exited-with-error × python setup.py egg_info did not run successfully. │ exit code: 1 ╰─&gt; [6 lines of output] Traceback (most recent call last): File "&lt;string&gt;", line 2, in &lt;module&gt; File "&lt;pip-setuptools-caller&gt;", line 34, in &lt;module&gt; File "C:\Users\Administrator\AppData\Local\Temp\pip-install-7uh8r2t5\configuration_a37d2a431105423c8797f1fceee8d6c2\setup.py", line 30, in &lt;module&gt; description = file(os.path.join(here, 'README.txt')).read() NameError: name 'file' is not defined [end of output] 2.问题解决 2.1 上网查浏览器 于是开始上浏览器搜，一开始全是升级setuptools，这里贴出来几句，可能你们的问题就解决了
pip install --upgrade pip pip install --upgrade setuptools pip install ez_setup 可我把这些执行了一遍，没解决问题，只是少了几行错(上面的图不是最开始的错)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86ff78143c5f4d2f9b75d79a016c8f38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468a8fdcf19c9589f78c295d51b64e47/" rel="bookmark">
			【ChatGPT】《在线AutoGPT工具 cognosys.ai》- 知识点目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 《在线AutoGPT工具 cognosys.ai》 网站：cognosys.ai/create
感觉还是挺有意思的~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccec0b4480a4f27c3dbaa51c3eda1d0f/" rel="bookmark">
			k8s 安装redis-cluster集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s 安装redis-cluster集群，文件如下
[root@k8s-1 redis-cluster]# cat redis-cluster.yaml #redis配置文件 apiVersion: v1 kind: ConfigMap metadata: name: redis-conf data: redis.conf: | port 6379 masterauth haoke.com requirepass haoke.com appendonly yes dir /var/lib/redis cluster-enabled yes cluster-config-file /var/lib/redis/nodes.conf cluster-node-timeout 5000 --- #redis-proxy配置文件 apiVersion: v1 kind: ConfigMap metadata: name: redis-proxy data: proxy.conf: | cluster redis-cluster:6379 bind 0.0.0.0 port 7777 threads 8 daemonize no auth haoke.com enable-cross-slot yes log-level error --- apiVersion: apps/v1 kind: StatefulSet metadata: name: redis-node annotations: reloader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccec0b4480a4f27c3dbaa51c3eda1d0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f2a70963d10f176b51863cd00656555/" rel="bookmark">
			利用ChatGPT优化代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，ChatGPT是一个基于大规模预训练语言模型的对话系统，由OpenAI开发。它可以帮助我们查找资料，进行内容创作，翻译语言等。那么，对于程序猿来说，可以利用ChatGPT干些什么呢？下面给大家看下ChatGPT另外一个好用的地方–代码优化！
ChatGPT体验之利用ChatGPT优化代码，如图：
优化前：
switch (key) { case 1: return '待审核' break case -2: return '已关闭' break case -1: return '已退回' break case 3: return '已通过' break case 2: return '已通过' break default: return '--' break } 优化后：
const statusMap = { 1: '待审核', '-2': '已关闭', '-1': '已退回', 2: '已通过', 3: '已通过', } return statusMap[key] || '--' 这里定义了一个名为 statusMap 的对象，其中每个属性都对应一个状态码及其对应的状态描述。在返回值时，可以根据传入的 key 直接从 statusMap 对象中取出对应的状态描述，如果没有找到则返回 --。这样的写法不仅更简洁，而且代码可维护性也更高，因为只需要维护 statusMap 对象即可，而不需要修改 switch 语句中的多个 case 分支。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3acd530cfa49fb8bb5e14a3a8f498ed9/" rel="bookmark">
			偷偷告诉mysql这47个SQL性能优化技巧，赶紧收藏了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、先了解MySQL的执行过程
了解了MySQL的执行过程，我们才知道如何进行sql优化。
（1）客户端发送一条查询语句到服务器；
（2）服务器先查询缓存，如果命中缓存，则立即返回存储在缓存中的数据；
（3）未命中缓存后，MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树，MySQL解析器将使用MySQL语法进行验证和解析。例如，验证是否使用了错误的关键字，或者关键字的使用是否正确；
（4）预处理是根据一些MySQL规则检查解析树是否合理，比如检查表和列是否存在，还会解析名字和别名，然后预处理器会验证权限；
根据执行计划查询执行引擎，调用API接口调用存储引擎来查询数据；
（5）将结果返回客户端，并进行缓存；
2、数据库常见规范
（1）所有数据库对象名称必须使用小写字母并用下划线分割；
（1）所有数据库对象名称禁止使用mysql保留关键字；
（3）数据库对象的命名要能做到见名识意，并且最后不要超过32个字符；
（4）临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀；
（5）所有存储相同数据的列名和列类型必须一致；
3、所有表必须使用Innodb存储引擎
没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）。
Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。
4、每个Innodb表必须有个主键
Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。
Innodb是按照主键索引的顺序来组织表的：
（1）不要使用更新频繁的列作为主键，不适用多列主键；
（2）不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）；
（3）主键建议使用自增ID值；
5、数据库和表的字符集统一使用UTF8
兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储emoji表情的需要，字符集需要采用utf8mb4字符集。
6、查询SQL尽量不要使用select *，而是具体字段
select *的弊端：
（1）增加很多不必要的消耗，比如CPU、IO、内存、网络带宽；
（2）增加了使用覆盖索引的可能性；
（3）增加了回表的可能性；
（4）当表结构发生变化时，前端也需要更改；
（5）查询效率低；
7、避免在where子句中使用 or 来连接条件
（1）使用or可能会使索引失效，从而全表扫描；
（2）对于or没有索引的salary这种情况，假设它走了id的索引，但是走到salary查询条件时，它还得全表扫描；
（3）也就是说整个过程需要三步：全表扫描+索引扫描+合并。如果它一开始就走全表扫描，直接一遍扫描就搞定；
（4）虽然mysql是有优化器的，处于效率与成本考虑，遇到or条件，索引还是可能失效的；
8、尽量使用数值替代字符串类型
（1）因为引擎在处理查询和连接时会逐个比较字符串中每一个字符；
（2）而对于数字型而言只需要比较一次就够了；
（3）字符会降低查询和连接的性能，并会增加存储开销；
9、使用varchar代替char
（1）varchar变长字段按数据内容实际长度存储，存储空间小，可以节省存储空间；
（2）char按声明大小存储，不足补空格；
（3）其次对于查询来说，在一个相对较小的字段内搜索，效率更高；
10、财务、银行相关的金额字段必须使用decimal类型
非精准浮点：float,double
精准浮点：decimal
（1）Decimal类型为精准浮点数，在计算时不会丢失精度；
（2）占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节；
（3）可用于存储比bigint更大的整型数据；
11、避免使用ENUM类型
（1）修改ENUM值需要使用ALTER语句；
（2）ENUM类型的ORDER BY操作效率低，需要额外操作；
（3）禁止使用数值作为ENUM的枚举值；
12、去重distinct过滤字段要少
（1）带distinct的语句占用cpu时间高于不带distinct的语句
（2）当查询很多字段时，如果使用distinct，数据库引擎就会对数据进行比较，过滤掉重复数据
（3）然而这个比较、过滤的过程会占用系统资源，如cpu时间
13、where中使用默认值代替null
（1）并不是说使用了is null或者 is not null就会不走索引了，这个跟mysql版本以及查询成本都有关；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3acd530cfa49fb8bb5e14a3a8f498ed9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc26f255c8997d91d3b826335994e488/" rel="bookmark">
			k8s部署mysql一主二从，数据持久化部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql-configmap.yaml
apiVersion:v1 kind:ConfigMap metadata: name:mysql labels: app:mysql data: master.cnf:| # Apply this config only on the master. [mysqld] log-bin log_bin_trust_function_creators=1 lower_case_table_names=1 slave.cnf:| # Apply this config only on slaves. [mysqld] super-read-only log_bin_trust_function_creators=1 mysql-service.yaml
apiVersion: v1 kind: Service metadata: name: mysql labels: app: mysql spec: ports: - name: mysql port: 3306 clusterIP: None selector: app: mysql --- apiVersion: v1 kind: Service metadata: name: mysql-read labels: app: mysql spec: ports: - name: mysql port: 3306 selector: app: mysql mysql-statefulset.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc26f255c8997d91d3b826335994e488/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed8b8005d8873e911f277b4106e6cce4/" rel="bookmark">
			k8s1.26 nfs-provisioner配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nfs-provisioner配置相对简单：
rbac配置 [root@k8s-1 nfs-provisioner]# cat sa.yaml apiVersion: v1 kind: ServiceAccount metadata: name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1 metadata: name: nfs-client-provisioner-runner rules: - apiGroups: [""] resources: ["nodes"] verbs: ["get", "list", "watch"] - apiGroups: [""] resources: ["persistentvolumes"] verbs: ["get", "list", "watch", "create", "delete"] - apiGroups: [""] resources: ["persistentvolumeclaims"] verbs: ["get", "list", "watch", "update"] - apiGroups: ["storage.k8s.io"] resources: ["storageclasses"] verbs: ["get", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed8b8005d8873e911f277b4106e6cce4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7165759818cd35506f06be30e1095191/" rel="bookmark">
			人工智能中的顶级期刊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文描述了获取人工智能顶级期刊列表的方法，方便读者通过阅读顶级期刊中的论文跟踪人工智能前沿。同时，本文还介绍了获取人工智能顶级期刊投稿信息的方法，帮助读者提高论文的录用率。
1. 顶级期刊列表的获取方法
要查找某个领域的顶级期刊有两种方法，一种是通过谷歌学术的Metrics栏目，另外一种就是通过期刊引用报告数据库（Journal Citation Report，简称JCR）。通过谷歌学术的Metrics栏目查找某一研究领域的顶级期刊的方式与《人工智能中的顶级会议》中已经介绍过的通过歌学术的Metrics栏目查找某一研究领域的顶级会议的方式类似，这里不再重复。
JCR是一个独特的多学科期刊评价工具，基于Web of Science权威的引文数据库，使用量化的统计信息对全球领先的学术期刊进行公正而严格地评价。JCR官方网站的网址为：https://clarivate.com/webofsciencegroup/solutions/journal-citation-reports。通过JCR数据库来查找某一领域的顶级期刊列表，必须所在机构已经购买该数据库，否则无法使用该数据库。具体的查找方式见图 6‑17。先打开JCR网站得到界面1，然后在界面1中点击椭圆圈出的“Go to product”，弹出界面2，然后在界面2中点击“Browse by Category”，弹出界面3，在界面3中点击“Select Categories”，弹出界面4，在界面4的研究领域选择框中选中“COMPUTER SCIENCE, ARTIFICIAL INTELLIGENCE”然后点“Submit”，弹出界面5，在界面5中点击该研究领域的期刊总数，弹出界面6，即得到了计算机科学学科下面的人工智能领域的期刊列表（这里只截取了前三位的期刊）。默认的是按照影响因子由高到低的顺序排列的，基本上这一顺序就代表了期刊的等级排序，越排在前面的期刊其质量越高。
图 6‑17 使用JCR查找顶级期刊列表的具体步骤
上面介绍的是查询任意研究领域的顶级期刊列表的方法。如果只关心计算机领域的顶级期刊列表，可以直接在中国计算机学会官网的“CCF推荐会议/期刊目录”栏目下查看计算机学科各子领域的顶级期刊列表，中国计算机学会网站的地址为https://www.ccf.org.cn。中国计算机学会网站给出的计算机领域的顶级期刊列表分为A、B、C三个档次。
中国计算机学会推荐的AI领域A类期刊见表 6‑5，TPAMI和AI期刊是人工智能领域里面非常著名的、广泛认可的顶级期刊，发表的难度很大。IJCV是计算机视觉领域最顶级的期刊之一。JMLR是机器学习领域的最顶级的期刊之一。
表 6‑5 中国计算机学会推荐的人工智能领域A类期刊
序号
刊物简称
刊物全称
出版社
网址
1 AI Artificial Intelligence Elsevier http://dblp.uni-trier.de/db/journals/ai/
2 TPAMI IEEE Trans on Pattern Analysis and Machine Intelligence IEEE http://dblp.uni-trier.de/db/journals/pami/
3 IJCV International Journal of Computer Vision Springer http://dblp.uni-trier.de/db/journals/ijcv/
4 JMLR Journal of Machine Learning Research MIT Press http://dblp.uni-trier.de/db/journals/jmlr/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7165759818cd35506f06be30e1095191/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee7a4f1c1227d0d20da0349bfe3bc633/" rel="bookmark">
			零基础读懂Stable Diffusion（II）：怎么训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：零基础读懂Stable Diffusion（II）：怎么训练 - 知乎
前几个月AIGC可谓是大热了一把，各种高质量的生成图片层出不穷，而其中最重要的开源模型Stable Diffusion也受到了各种技术商业上的热捧，以很快的速度不断的向前迭代着。之前作为一个没有相关知识基础的小白，为了了解相关的技术知识，找了很多文章看，最后还是发现Jay Alammar的这篇文章讲的最为通俗易懂，于是决定简单翻译一下，方便更多人从零开始了解这项强大的技术。
由于原文篇幅较长，所以这里分为三篇文章进行讲解：
第一篇，主要讲“是什么”的问题，包括Stable Diffusion是什么，里面的各个模块是什么，上一篇的链接在这里。第二篇，也就是本篇，主要讲“怎么办”的问题，也就是Diffusion怎么训练以及怎么使用的问题。第三篇，主要讲“如何控制”的问题，具体阐述语义信息到底是怎么影响生成图片的过程的。 其中，第一篇文章也可以点击这张卡片阅读：
曾飞飞：零基础读懂Stable Diffusion（I）：怎么组成308 赞同 · 5 评论文章正在上传…重新上传取消
接下来正式进入第二篇的介绍，谈谈训练Diffusion该怎么去训练和怎么去使用的问题。
原文链接： The Illustrated Stable Diffusion 有能力和时间的小伙伴还是更推荐阅读原文噢 作者： Jay Alammar 译者：曾飞飞（知乎） 上文讲到，Stable Diffusion中有着三个主要的模块，包括一个Text Understander处理语义信息，一个Image Information Creator生成图片的隐变量，一个Image Decoder利用隐变量生成真正的图片。同时，对于整个图片生成的过程，我们也有了更加深入的了解。我们不仅仅知道了向量通过各个阶段时的形状变化，还可视化了过程中噪声变为图片的全过程。因此，在大概了解Stable Diffusion的工作流程之后，我们接下来要开始学会训练这个模型了。
一，Diffusion怎么训练 Diffusion模型能够生成高质量图片，其核心原因在于我们现在有着极其强大的计算机视觉模型。只要数据集够大，我们强大的模型就能学习到任何复杂的操作。那具体diffusion里面让unet学习了怎样一个操作呢？简单来说，就是“去噪”。
那如何为去噪的任务设计数据集呢？很简单，我们只要向普通的照片里添加噪声，不就有了加噪的图片了嘛。假定我们现在有一张金字塔的图片，我们用random函数生成从强到弱各个强度的噪声，比如下图中0~3共计4个强度的噪声。现在我们选定个某个强度的噪声，比如下图中选了噪声1，并且把这个噪声添加到图片里：
训练集如何制作：1，选张图片 2，生成从强到弱各个强度的噪声 3，从中选个噪声（比如强度1） 4，加到图片里
现在，我们就制作完成了训练集里面的一张图片。按照这样的操作，选一张图片，再选一种强度的噪声混合，我们还可以制作很多训练集。比如下面就选了图书馆的一张照片，混合了强度为2的噪声，创造了一个更模糊一点的训练样本：
上面仅仅作为一个简单的例子，所以噪声只设置了四个档位。实际上我们可以更细腻地划分噪声的等级，将其分为几十个甚至上百个档位，这样就可以创建出成千上万个训练集。比如我们现在噪声设置成100个档位，下面就展示了利用不同的档位结合不同的图片创建6张训练集的过程：
这样的话，一组训练集包括了三样东西：噪声强度(上图数字)，加噪后的图片(上图左列图片)，以及噪声图（上图右列图片）就可以了。训练的时候我们的unet只要在已知噪声强度的条件下，学习如何从加噪后的图片中计算出噪声图就可以了。注意，我们并不直接输出无噪声的原图，而是让unet去预测原图上所加过的噪声。当需要生成图片的时候，我们用加噪图减掉噪声就能恢复出原图了。
具体的一个训练过程就如下图所示，一共分四步走：
从训练集中选取一张加噪过的图片和噪声强度，比如下面的加噪街道图和噪声强度3。输入unet，让unet预测噪声图，比如下图的unet prediction。计算和真正的噪声图之间的误差通过反向传播更新unet的参数。 那完成训练后，我们该如何生成图片呢？
二，Diffusion怎么生成图片 假设我们现在已经按照上面的步骤训练好了一个unet，这就意味着它就可以成功从一个加噪的图片中推断出噪声了。如下图中，知道噪声强度的情况下，给unet输入一张有噪图，unet就输出有噪图上面加过的噪声：
只要知道噪声强度，训练好的unet就可以成功推断出噪声
既然现在噪声图能够被推断出来，我们只要把加噪后的图片减去这个噪声图，就可以轻松得到一张略微去噪的图片了：
重复这个过程，预测噪声图，再减去噪声图，进行第二步去噪：
不断地重复这个过程，不断的去除一张噪声图片的噪声，最终我们就可以得到一张很棒的图片。这个图片是接近训练集分布的，它和训练集保有相同的像素规律。比如你用一个艺术家数据集去训练，它就会遵循美学的颜色分布，你用真实世界的训练集去训练，它的结果就会尽量遵循真实世界的规律。现在，你已经了解了Diffusion模型的基本规律了，这不仅仅适用于Stable Diffusion，也适用于OpenAI的Dall-E 2和Google的Imagen。
注意到上面这个过程中我们暂时还没有引入文字和语义向量的控制。也就是说，如果单纯的按照上面的流程走，我们可能能得到一些很炫酷的图片，但我们没有办法去控制最后的结果到底是什么。那如何引入文字控制呢？这就要使用语言模型和Attention机制来引入语义啦，这一部分内容我们放到下篇中讲解。
三、总结 在上一篇我们介绍完Stable Diffusion的各个模块和工作流程后，这一篇我们着重讲述了Diffusion是如何训练和推理的。文章的结尾，这里简单总结一下这篇的内容：
Diffusion's Training: 利用 “噪声强度、噪声图、加噪后图片”组成训练集，训练unet，使其学习如何从加噪后的图片推断出所加的噪声。Diffusion's Inference: 利用训练好的unet，从纯噪声中一步一步去噪，得到合理正常的图片。 至于语义信息是如何控制生成图片的过程的，我们就留到下篇中再做叙述啦。下篇文章可以点击这里阅读：
曾飞飞：零基础读懂Stable Diffusion（III）：怎么控制252 赞同 · 38 评论文章正在上传…重新上传取消
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee7a4f1c1227d0d20da0349bfe3bc633/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d2154da6a73dfa7076c6a565a5b4a9b/" rel="bookmark">
			PyTorch学习笔记07——模型的保存和加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型的保存和加载 序列化与反序列化断点续训练举个栗子理解 序列化与反序列化 模型的保存与加载也称序列化与反序列化
模型在内存中是以对象的形式存储的，而在硬盘中是以二进制序列保存的
序列化：是指将内存当中的某一个对象以二进制序列的形式存储到硬盘中，就可以长久的存储。
反序列化：将硬盘中的二进制数反序列化的放到内存中，得到对象，这样就可以使用模型了。
对应pytorch中的函数：
torch.save
主要参数： obj：对象（模型、张量、parameters、dict 等等）f：输出路径（指定一个硬盘中的路径去保存） 模型保存有两种方法：
法1：保存整个Module
torch.save(net, path) 法2：保存模型参数
state_dict = net.state_dict() torch.save(state_dict, path) 比如：
net = LeNet2(classes=2019) # "训练" print("训练前: ", net.features[0].weight[0, ...]) net.initialize() print("训练后: ", net.features[0].weight[0, ...]) path_model = "./model.pkl" path_state_dict = "./model_state_dict.pkl" # 保存整个模型 torch.save(net, path_model) # 保存模型参数 net_state_dict = net.state_dict() torch.save(net_state_dict, path_state_dict) torch.load
主要参数： f：文件路径（对应save中的f）map_location：指定存放位置，cpu or gpu（主要针对用gpu的时候） torch.load(path) 比如：
# ================================== load net =========================== # flag = 1 flag = 0 if flag: path_model = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d2154da6a73dfa7076c6a565a5b4a9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c2dda3ccdf9456cebeab5bd5f4f71fc/" rel="bookmark">
			思科、华为路由协议优先级——管理距离AD值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思科设备
路由协议的类型 默认距离值（优先级）直连路由（Direct)0静态路由（Static）1增强型内部网关路由协议 (EIGRP) 汇总路由 5外部边界网关协议 (BGP) 20内部 EIGRP 90IGRP100OSPF 110IS-IS（中间系统到中间系统）115路由信息协议 (RIP) 120Exterior Gateway Protocol (EGP) 140按需路由 (ODR) 160外部 EIGRP 170内部 BGP 200未知* 255 L - 标识分配给一个路由器接口的地址。这使路由器能够有效确定何时收到的数据包是指向该接口的，而不必进行转发。C - 标识一个直连网络。S - 标识为了到达某个特定网络而创建出来的静态路由。O - 标识使用 OSPF 路由协议从另一台路由器动态学习到的网络。* - 这条路由是默认路由的候选 华为设备
路由协议的类型路由协议的外部优先级路由协议的内部优先级直连路由（Direct)00OSPF 内部路由1010IS-IS 路由1515（level-1）18（level-2）静态路由（Static）6060RIP 路由100100OSPF ASE 路由150150OSPF NSSA 路由150150IBGP 路由255200EBGP 路由25520 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c4c140443027fc169c36fb4eb590d3d/" rel="bookmark">
			Mediator模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mediator模式 What “Mediator”：中介、调解者
（注：在《图解设计模式》一书中，又被译为独裁者，对于这个翻译我还是很认可的，所以中译的话我就沿用书中的译文，独裁者模式）
顾名思义，独裁者模式的核心应当为由一个人来做决定，但是在程序中，经常是多个类根据对方的状态做出不同的反应，这也叫做通信，说的比较抽象，举个例子，比方说A类和B类关联，那么怎么个关联法呢，通常的情形便是A类根据B类的状态而执行某段函数，或者对属性做出某些改变。其实如果只有A、B两个类，那么直接互相通信显然会比使用Mediator模式来得更方便，但是在程序的设计过程中，应当尽量符合开闭原则，也就是对扩展开放，对修改关闭，为了方便拓展，减少代码修改，使用独裁者模式在未来若有C类加入程序，与A，B关联，就无需修改A、B类的代码，仅需在独裁者一处进行修改。
How 创建两个接口，Mediator和Colleague，通俗的讲也就是老板和员工。
public interface Mediator { void createColleagues(); void colleagueChanged(); } public interface Colleague { void setMediator(Mediator mediator); void setColleagueEnabled(boolean enabled); } 老板处需要有一个招员工的方法，还得给员工留个电话号码，也就是createColleagues()和colleagueChanged()，员工需要知道自己的老板是谁，还得执行老板的指示，也就是setMediator()和setColleagueEnabled()。
上面的是概念老板和概念员工，接下来需要真老板和真员工了。于是创建了LoginFrame类和ColleagueButton、ColleagueCheckbox、ColleagueTextField三个员工类。
public class LoginFrame extends Frame implements ActionListener, Mediator { private ColleagueCheckbox checkGuest; private ColleagueCheckbox checkLogin; private ColleagueTextField textUser; private ColleagueTextField textPass; private ColleagueButton buttonOk; private ColleagueButton buttonCancel; public LoginFrame(String title) { super(title); setBackground(Color.lightGray); setLayout(new GridLayout(4, 2)); createColleagues(); add(checkGuest); add(checkLogin); add(new Label("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c4c140443027fc169c36fb4eb590d3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5dc653e84b5dabe22d4793ba83035f7/" rel="bookmark">
			【Spring应用】SPEL表达式使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring框架中的SpEL（Spring Expression Language，Spring表达式语言）是一种基于字符串的表达式语言，用于支持在运行时动态地计算表达式的值。它可以在Spring的多个模块中使用，如Spring MVC、Spring Security等，是Spring框架中一个重要的特性。
SpEL解析器的主要作用是将SpEL表达式解析成Java对象，并在运行时计算表达式的值。Spring框架中提供了一个标准的SpEL解析器SpelExpressionParser，它可以在应用程序中进行SpEL表达式的解析和计算。
SpEL表达式由一个或多个表达式元素组成，可以包含变量、方法、运算符、常量等。例如，下面是一个简单的SpEL表达式：
#{2 + 3} 这个表达式表示对2和3进行加法运算，其结果为5。在Spring应用程序中，可以使用SpEL表达式来进行如下操作：
1、获取Bean的属性值或方法的返回值，例如：
#{user.name} // 获取user对象的name属性值 #{user.getName()} // 调用user对象的getName()方法 2、进行运算或逻辑判断，例如：
#{2 + 3} // 返回5 #{age &gt; 18 ? 'adult' : 'child'} // 如果age大于18，返回'adult'，否则返回'child' 3、调用静态方法或实例方法，例如：
#{T(java.lang.Math).PI} // 调用Math类的静态属性PI #{user.getAge().compareTo(18)} // 调用user对象的getAge()方法并进行比较 SpEL表达式的解析和计算是在运行时动态进行的，因此具有很大的灵活性和可扩展性，可以在不改变代码的情况下实现复杂的运算和逻辑判断。同时，SpEL表达式还支持类型转换、集合操作、正则表达式等高级特性，使得它在Spring应用程序中的使用非常广泛。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e95842a330fce05a3093e341dc833fa/" rel="bookmark">
			在线体验AutoGPT（AgentGPT）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个Auto-GPT部署在线上的网站，你只需要有ChatGPT 的API 就可以体验。尽管Auto-GPT是一个基于GPT4的项目，但ChatGPT3.5 API 也可以用。
agentgpt.链接
左下角setting点开然后选择chatgpt3.5 或者4，然后复制好你的openai key
下面还能设置temperature
save之后填写你的任务name和目标（Goal）然后点击Deploy Agent就可以开始干活了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/455c03e92bea4c82c714129f9f863cd3/" rel="bookmark">
			机器学习笔记（一）之特征工程、特征处理方法、特征构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特征工程 特征使用方案可用性评估 特征获取方案特征处理特征清洗预处理单个特征多特征衍生变量 特征处理 特征构建特征提取方法 特征使用方案 这里我们要思考要实现我们的目标需要哪些数据
答：基于我们的专业知识，尽可能找出对因变量有影响的所有自变量。
举个例子：
评价一个车是否是好车，我们有很多的参数，那么当我们训练一个模型帮助我们去判断车的好坏时候，就需要考虑各种各样的参数。有时候训练结果的不好，修改各类参数也无法得到较好的结果时，可以返回最初的数据集特征的选择。极端：如果仅选择颜色作为评价车好坏的特征，那结果一定也不如意。
可用性评估 在尽可能思考全面特征的情况下，再进行可用性评估。
1.获取难度
2.覆盖度
3.准确率
由于我处理的数据大多是卫星数据，很多时候，结果的验证就是一个问题。
有时候，需要尽可能的去寻找辅助数据，搜索监测站数据是否有需要的数据。还有一些数据则不好获取。比如研究水藻，思考是否水藻的漂浮和悬浮在对位于不同生长周期判断方面有区别呢？这个是否可以作为判断生长周期的一个依据呢？可若以此为特征，数据的获取将会十分困难。如果目标是建立一个遥感卫星实时监测平台，更是无法将此作为特征，总不能实时实地检测，实时监测，哈哈。（例子若有不妥之处，欢迎指正。）
特征获取方案 对于不同格式数据的处理在很多时候是至关重要的。
1.如何获取这些特征？
2.如何存储？
许多数据是TIFF格式，有的则是NC格式，还有部分是HDF格式。获取数据的方式网络有很多人做了分享，不再赘述。有时候csdn平台若无法提供较好的数据处理转换办法，可以去GitHub去进行深一步的探索，有许多分享的宝贵资料。只是大多是英文展示。
特征处理 特征清洗 1.清洗异常样本
2.采样
①数据不均衡
②样本权重
预处理 单个特征 1.归一化
2.离散化
3.Dummy Coding(代码编号)
4.缺失值
5.数据变换
①log
②指数
③Box-Cox变换
Box-Cox变换之后，可以一定程度上减小不可观测的误差和预测变量的相关性。
多特征 1.降维
PCA
LDA
线性判别分析(LDA),同PCA类似,也是一种降维算法,不一样的是,LDA是一种监督算法,它需要用到类别信息。
2.特征选择
①Filter
1）思路：自变量和目标变量之间的关联
2）相关系数
3）卡方验证
4）信息增益、互信息
熵H(Y)与条件熵H(Y|X)之差称为互信息,决策树学习中的信息增益等价于训练数据集中类与特征的互信息。
②Wrapper（封装器，侧重特征子集，实质是一个分类器）
1）思路：通过目标函数AUC/MSE,来决定是否加入一个变量
2）迭代：产生特征子集，评价：
1完全搜索
2启发式搜索
3*随机搜索：GA or SA
③Embedded（集成方法）
1)思路：学习器自身自动选择特征
2）正则化：
1* L1—Lasso
2* L2—Ridge
3* 决策树—熵、信息增益
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/455c03e92bea4c82c714129f9f863cd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/663e4c648a307621f43b52fd1454ad39/" rel="bookmark">
			Zdal 配置的几种方式（SOFABoot）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		至于选哪种方式呢，就看你自己了
二 传统 xml 方式 &lt;!-- datasource --&gt; &lt;bean id="testerDataSource" class="com.alipay.zdal.client.jdbc.ZdalDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="appName" value="xxx"/&gt; &lt;property name="appDataSourceName" value="xxx_ds"/&gt; &lt;property name="version" value="xxx"/&gt; &lt;property name="configProperties"&gt; &lt;map&gt; &lt;entry key="zdal_password_encrypt" value="true"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="sqlSessionFactoryBeanName" value="testerSqlSessionFactory"/&gt; &lt;!-- mapper 包的位置 --&gt; &lt;property name="basePackage" value="com.xxx.xxx.dal.mapper"/&gt; &lt;/bean&gt; &lt;bean id="testerTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="testerDataSource"/&gt; &lt;/bean&gt; &lt;bean id="testerTransactionTemplate" class="org.springframework.transaction.support.TransactionTemplate"&gt; &lt;property name="transactionManager"&gt; &lt;ref bean="testerTransactionManager"/&gt; &lt;/property&gt; &lt;/bean&gt; 二 代码方式 1 配置 ZdalDataSource 代码的方式要注释写着三个的类要加上 @Configuration
配置数据源的文档参考步骤三
/** * 第一种 */ @Bean(initMethod = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/663e4c648a307621f43b52fd1454ad39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbdcb7792512d185ae1002f82eb069c8/" rel="bookmark">
			try-catch处理异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. try-catch处理异常
2. finally
3. throw 和 throws
3. 自定义异常
4. 总结
6. 内部类
1. try-catch处理异常 使用 try-catch 处理异常
try：表示将有可能出现异常的代码书写在 try 代码块中
catch：用于捕获 try 代码块中有可能出现的异常
try不能单独使用必须结合 catch 或者 finally 或者 catch-finally
catch不能单独使用 必须结合try
情况1：出现异常 并且能够被捕获到
public class TestTryCatch1 { public static void main(String[] args) { try{ Scanner in = new Scanner(System.in); System.out.print("请输入被除数:"); int num1 = in.nextInt(); System.out.print("请输入除数:"); int num2 = in.nextInt(); System.out.println(num1+"/"+ num2 +"="+ num1/ num2); } catch(InputMismatchException exception){ exception.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbdcb7792512d185ae1002f82eb069c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83fd2d86f113ac6132ee82529d25dd79/" rel="bookmark">
			Faster RCNN详解（个人理解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Faster RCNN的四个主要内容 图1 Faster-RCNN基本结构
如上图所示，整个Faster RCNN模型可以分为四个模块：
1） Conv layers，特征提取网络 输入为一张图片，输出为一张图片的特征，即feature map。通过一组conv+relu+pooling层提取图像的feature map，用于后续的RPN网络和全连接层。
2） Region proposal Network，区域候选网络 输入为第一步中的feature map，输出为多个兴趣区域（ROI）。输出的每个兴趣区域具体表示为一个概率值（用于判断anchor是前景还是背景）和四个坐标值，概率值表示该兴趣区域有物体的概率，这个概率是通过softmax对每个区域进行二分类得到的；坐标值是预测的物体的位置，在进行训练时会用这个坐标与真实的坐标进行回归使在测试时预测的物体位置更加准确。
3） ROI pooling，兴趣域池化 这一层以RPN网络输出的兴趣区域和Conv layers输出的feature map为输入，将两者进行综合后得到固定大小的区域特征图（proposal feature map）并输出到后面的全连接网络中进行分类。
4） Classification and Regression，分类和回归 输入为上一层得到proposal feature map，输出为兴趣区域中物体所属的类别以及物体在图像中精确的位置。这一层通过softmax对图像进行分类，并通过边框回归修正物体的精确位置。
2. Faster RCNN四个模块详解 如下图所示，这是Faster R-CNN模型的具体网络结构
图2 Faster RCNN网络结构
2.1 Conv layers 图3 Conv layers网络结构
这部分的作用是提取输入图像的特征得到特征图。Conv layers中共包含了conv、pooling、relu三种层。本项目中是采用python中的VGG16模型作为特征提取网络。如上面的网络结构图所示，Conv layers部分共包含了13个conv层，13个relu层，4个pooling层。并且：
1）所有的conv层都是：kernel_size=3，pad=1，stride=1
2）所有的pooling层都是：kernel_size=2，pad=0，stride=2
因此一个MxN大小的图像经过Conv layers固定变为(M/16)x(N/16)，这样Conv layers生成的feature maps都可以和原图对应起来。
2.2 Region proposal Network 这一部分的作用是生成较好的建议框（Proposal），RPN包含五个子模块：
2.2.1 Anchor生成
RPN对输入的feature map上每一个点都生成了9个anchor（3种尺度(128, 256, 512)和3种宽高比(1:2, 1:1, 2:1)），这些不同大小、宽高的anchor对应到原图可以覆盖所有可能出现的物体。因此共生成了(M/16)x(N/16)x9个anchor。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83fd2d86f113ac6132ee82529d25dd79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a631bd0e71cd3650eaf95e736da628bd/" rel="bookmark">
			零基础小白怎么入门网络安全（黑客）？看这篇就够啦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我刚入门网络安全，该怎么学？要学哪些东西？有哪些方向？怎么选？
不同于Java、C/C++等后端开发岗位有非常明晰的学习路线，网路安全更多是靠自己摸索，要学的东西又杂又多，难成体系。
【----帮助网安学习，以下所有学习资料文末免费领！----】
网络安全分支
其实在网络安全这个概念之上，还有一个更大的概念：信息安全。本文不去探讨二者在学术划分上的区别，如无特殊说明，文中将其视为一个概念，我们来看下实际工作方向上，有哪些细分路线。
渗透测试工程师 安全服务工程师 等级保护工程师 安全运营工程师 高级渗透工程师 红队评估工程师 网络渗透（渗透测试工程师）
这个方向更符合于大部分人对“黑客”的认知，他们能够黑手机、黑电脑、黑网站、黑服务器、黑内网，万物皆可黑。
相比二进制安全方向，这个方向初期更容易入门一些，掌握一些基本技术，拿起各种现成的工具就可以开黑了。
【----帮助网安学习，以下所有学习资料文末免费领！----】
不过，要想从脚本小子变成黑客大神，这个方向越往后，需要学习和掌握的东西就多了：
网络渗透的方向更偏向于“实战”，因此对技术在广度上有更高的要求，从网络硬件设备、网络通信协议、网络服务（web、邮件、文件、数据库等）、到操作系统、攻击手法等等都需要了解。更偏向于一个全能型的计算机专家，将各种技术融会贯通，以用于“实战”。
渗透方向的工作有下面几个方向：
安全服务，俗称乙方，这是最主要的一个方向，为甲方公司提供安全能力支持，如渗透测试，产品安全检测等。
安全能力建设，俗称甲方，国内稍微有点规模的公司都有自己的SRC（安全应急响应中心），也就是有自己的安全团队。
国家队：你懂的
二进制安全
二进制安全方向，这是安全领域两大技术方向之一。
这个方向主要涉及到软件漏洞挖掘、逆向工程、病毒木马分析等工作，涉及操作系统内核分析、调试与反调试、反病毒等技术。因为经常都是与二进制的数据打交道，所以久而久之用二进制安全来统称这个方向。
这个方向的特点是：需要耐得住寂寞。
比不上安全研发可以有实实在在的产品输出，也比不上网络渗透方向听起来的狂拽炫酷，这个方向更多时间是在默默的分析和研究。
以漏洞挖掘为例，光是学习五花八门的攻击手法就需要花不少的时间。在这个领域，为了研究一个问题，可能花费数月甚至数年时间，这绝非一般人能坚持下来的。不仅如此，不是勤奋就可以成功，更多还要靠天分。
像腾讯几大安全实验室的掌门人，业界知名的TK教主、吴石这些人物，他们已经深谙漏洞挖掘的奥义，并将这门绝技融会贯通，做个梦都能想到新的玩法。不过像这样的天才实在是少之又少，绝大多数人都无法企及。
【----帮助网安学习，以下所有学习资料文末免费领！----】
如果说程序员是苦逼的话，那二进制安全研究就是苦逼Plus。
如果看了这些你还是有勇气进入这个领域，那下面这些东西是你需要学的：
这个方向比起安全研发，不仅技术难度更大，提供这些岗位的公司也很少，且基本上分布于北上广深几个一线城市。
小结 不管你是想从事哪个岗位和方向，首先要先打好基础！
第一步：计算机基础
这第一步，其实跟网络安全关系都不太大，而是进入IT领域的任何一个人都要掌握的基础能力。下面五大课程，是大学老师当年教给我们不管你是什么技术方向最好都好好学的技术，如今看来，仍然不过时：
计算机网络
计算机组成原理
操作系统
算法与数据结构
数据库
这每一门课程其实都内有乾坤，基本都不能做到一次学习就能掌握，而是伴随每个人的职业生涯，不同的技术阶段都会有不一样的认识和感受。
具体学起来建议参考敏捷开发，不断迭代：有一个粗略的认识--有了进一步的认识--彻底掌握--温故而知新。不用纠缠于把一门课程全部学完学懂才进入下一门课程。
第二步：编程能力
有了上面的一些基本功后，这个时候就需要动手，来写点代码，锤炼一下编程的功底。
下面三项，是安全行业的从业者都最好能掌握的语言：
1.Shell脚本
掌握常用的Linux命令，能编写简单的Shell脚本，处理一些简单的事务。
2.C语言（C++可选）
C语言没有复杂的特性，是现代编程语言的祖师爷，适合编写底层软件，还能帮助你理解内存、算法、操作系统等计算机知识，建议学一下。
3.Python（PHP可选）
C语言帮助你理解底层，Python则助你编写网络、爬虫、数据处理、图像处理等功能性的软件。是程序员，尤其是黑客们非常钟爱的编程语言，不得不学。
第三步：安全初体验
有了前面两步的打底，是时候接触一些网络安全的技术了，刚刚开始这个阶段，仍然不要把自己圈起来只学某一个方向的技术。这个阶段，我的建议是：但当涉猎，见往事耳。
网络协议攻击、Web服务攻击、浏览器安全、漏洞攻击、逆向破解、工具开发都去接触一下，知道这是做什么的，在这个过程中去发现自己的兴趣，让自己对网络安全各种领域的技术都有一个初步的认识。
第四步：分方向
在第三步中，慢慢发现自己的兴趣点，是喜欢做各种工具的开发，还是喜欢攻破网站，还是痴迷于主机电脑的攻击···
这个时候就可以思考自己后面的方向，然后精力开始聚焦在这个方向上，通过上面思维导图中各自方向的技术去持续深耕，成为某一个领域的大拿。
学习方法和学习路线
上面介绍了技术分类，这里来谈一下学习方法和学习路线
看书学习，这是最最基础的
实际动手，开发路线需要多写代码，阅读优秀开源代码，二进制路线多分析样本，编写EXP等等，渗透测试多拿网站练手（合法方式）等
打CTF，多参与一些网络安全比赛，接近实战的环境下锻炼动手能力
混圈子，多混一些安全大牛出没的社群、社区、论坛，掌握行业信息，了解最新技术变化趋势(高清版思维导图有)
【----帮助网安学习，以下所有学习资料文末免费领！----】
总结 以上就是我对刚入行网络安全的朋友的一些个人的建议，最后有一点需要说明一下：
上面列举到的不同方向的技术不是严格意义独立的，相反，很多时候是相辅相成，需要结合起来，融会贯通。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a631bd0e71cd3650eaf95e736da628bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25d039befb95a764706c30f48728f847/" rel="bookmark">
			java 多线程下载网络图片、视频等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程下载网络图片、视频等 一、使用准备二、一个文件实现多线程下载三、多个文件实现多线程四、封装使用示例 一、使用准备 创建一个StartThread 类继承 Runnable 实现多线程
import java.io.File; import java.io.InputStream; import java.io.RandomAccessFile; import java.net.HttpURLConnection; import java.net.URL; public class StartThread implements Runnable { private String urlLocation; private String filePath; private long start; private long end; public StartThread(String urlLocation, String filePath, long start, long end) { this.urlLocation = urlLocation; this.filePath = filePath; this.start = start; this.end = end; } @Override public void run() { try { System.out.println("进入多线程方法"); HttpURLConnection conn = getHttp(); conn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25d039befb95a764706c30f48728f847/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24858a4dd0929762e24c5152540175af/" rel="bookmark">
			MySQL学习-基础篇-事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
p51-基础-事务-简介
p52-基础-事务-操作演示
p53-基础-事务-四大特性ACID
p54-基础-事务-并发事务问题
p55-基础-事务-并发事务演示及隔离级别
p56-基础-事务-小结
p57-基础篇总结
p51-基础-事务-简介 p52-基础-事务-操作演示 -- 数据准备 create table account( id int auto_increment primary key comment '主键ID', name varchar(10) comment '姓名', money int comment '余额' ) comment '账户表'; insert into account(id, name, money) VALUES (null,'张三',2000),(null,'李四',2000); -- 1. 查询张三账户余额 select * from account where name = '张三'; -- 2. 将张三账户余额-1000 update account set money = money - 1000 where name = '张三'; -- 3. 将李四账户余额+1000 update account set money = money + 1000 where name = '李四'; -- 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24858a4dd0929762e24c5152540175af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f535038eb7cb57417d80d84c5ecb401c/" rel="bookmark">
			【Python_Scrapy学习笔记（六）】Scrapy框架基本使用流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scrapy框架基本使用流程 前言 本文中介绍 Scrapy 框架的基本使用流程，并以抓取汽车之家二手车数据为例进行讲解。
正文 1、Scrapy框架基本使用流程 创建爬虫项目：scrapy startprojecct 项目名
cd到项目文件夹：cd 项目名
创建爬虫文件：scrapy genspider 爬虫文件名 浏览器地址栏中的域名
定义抓取的数据结构：编写 items.py 文件
import scrapy class 项目名item(scrapy.Item): scrapy.Field() price = scrapy.Field() link = scrapy.Field() ... ... 爬虫文件解析提取数据：编写 爬虫文件名.py 文件
import scrapy from ..items import 项目名item class 类名Spider(scrapy.Spider): name = "爬虫文件名" # 爬虫名 allowed_domains = ["浏览器地址栏中的域名"] # 允许爬取的域名：在创建爬虫文件的时候指定的域名 start_urls = [""] # 第一页的url地址 def parse(self, response): 解析提取数据 item=项目名item() item["name"]=xxx # 数据交给管道文件处理的方法 yield item # 需要进行跟进的url地址，如何交给调度器入队列 yield scrapy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f535038eb7cb57417d80d84c5ecb401c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e4d9dda87e3c21d18d5958e5497d2a/" rel="bookmark">
			Linux 修改系统时间的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：更新系统时间的方式 1、手动修改 通过相关工具来手动修改系统的时间。
2、自动同步 使用NTP自动同步系统时间。
二：手动修改系统时间 1、date工具 作用：显示和设置系统时间
选项：
-d &lt;字符串&gt; 显示字符串所指的日期与时间，比如："-1 day" 表示当前日期的前一天,必须要加双引号 -s &lt;字符串&gt; 设置当前的时间和日期 #年月日使用（-）分隔，时分秒使用（:）分隔 时间格式：
# 显示时间格式： date [+指定的格式] # 相关格式说明： %T：time，显示时分秒，24小时制（hh:mm:ss） %F：full date，显示年月日，%Y-%m-%d # 说明： Y: 年 m：月 d：日 H：时 M：分 S：秒 例如：显示年月日时分秒
# 格式: date "+%F %T" # 需要用双引号括起来 表示这是一个整体 root@ubuntu1804:~# date Tue 28 Mar 2023 11:07:08 AM CST root@ubuntu1804:~# date +"%F" 2023-03-28 root@ubuntu1804:~# date +"%T" 11:07:18 root@ubuntu1804:~# date +"%F %T" 2023-03-28 11:07:29 只修改年月日：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4e4d9dda87e3c21d18d5958e5497d2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f82b4f1c20e1a673f0f9078a0e7198b2/" rel="bookmark">
			C&#43;&#43;设计模式—— 抽象工厂模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抽象工厂模式（Abstract Factory） 动机（Motivation） 在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作同时，由于需求的变化，往往存在更多系列对象的创建工作。
如何应对这种变化?如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合?
模式定义 提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。 ——《设计模式》GoF
结构（Struture） 实例 //步骤1 为形状创建一个接口 class Shape { public: virtual void draw() = 0; }; //步骤2 创建实现形状接口的实体类 class Circle : public Shape { public: void draw() { cout &lt;&lt; "Inside Circle::draw() method." &lt;&lt; endl; } }; class Square : public Shape { public: void draw() { cout &lt;&lt; "Inside Square::draw() method." &lt;&lt; endl; } }; class Rectangle : public Shape { public: void draw() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f82b4f1c20e1a673f0f9078a0e7198b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93bce8b93948d76bfea6bada4759f90f/" rel="bookmark">
			数据增强有哪些方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据增强也叫做数据扩增，数据增广，意思是在不实质增加数据的情况下，从有限的数据产生更多变种，让有限的数据产生等驾驭更多的数据价值
数据增强：降低成本，提高模型的泛化能力
基本数据增强方法：
采用固定的预设规则进行数据扩增，包括单样本数据增强和多样本数据增强
单样本：几何操作类和颜色操作类
几何操作对像素空间重新分布
多尺度裁剪，先裁剪再进行缩放
多样本增强：离散样本点连续化来进行插值拟合 smot方法对一不平衡的比例确定好采样倍率
samplepairing：随机抽取两张图片分别经过基础数据增强操作（如随机反转）处理后，直接叠加合成一个新的样本，标签为原样本标签中的一种
Mixup：facebook提出的对图像和标签都进行了线性插值
开源库imgaug 覆盖了主流的数据增强方法
在特定领域有特定的数据增强思路 比如人脸
自动数据增强方法：
aotoaugment框架：学习已有的数据增强的组合，不同的任务，需要不同的数据增强操作 有16个数据操作
从零生成性的数据（无中生有）： 生成对抗网络，生成新的数据
from torchvision import transforms #常见的数据增强方法 # torchvision.transforms.RandomCrop() #随机位置裁剪 # torchvision.transforms.RandomHorizontalFlip(p=1) #以一定的比列，随机水平反转 # torchvision.transforms.RandomVerticalFlip(p=1) #以一定比列随机上下翻转 # torchvision.transforms.RandomRotation() #随机旋转一个角度 # torchvision.transforms.ColorJitter(brightness=1) # #对于颜色的变换 可以设置亮度， # #contrast 对比度，saturation 饱和度，hue 随机调整颜色 # # torchvision.transforms.RandomGrayscale(p=0.5)#随机灰度化 #测试时不需要做数据增强 只对train数据增强 train_transformer = torchvision.transforms.Compose([transforms.Resize(224,224), transforms.RandomCrop(192,192), transforms.RandomHorizontalFlip(), transforms.RandomRotation(0.2), transforms.ColorJitter(brightness=0.5), transforms.ColorJitter(contrast=4), transforms.ToTensor(), transforms.Normalize(mean=[0.5,0.5,0.5],std=[0.5,0.5,0.5])]) test_transformer = torchvision.transforms.Compose([transforms.Resize(192,192), transforms.ToTensor(), transforms.Normalize(mean=[0.5,0.5,0.5],std=[0.5,0.5,0.5])]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f7f25d42a6ab0469d36ad446e6d140/" rel="bookmark">
			Elastic-job架构图（plantuml生成）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用plant uml绘制elastic job架构图。
下面是效果图。
plant uml可选组件只有这些：
packagenodefolderframeclouddatabase 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48c67a51094f88e733622192d9ef659/" rel="bookmark">
			iOS 吸顶效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中，在列表向上滚动时，有时需要将某个控件置顶，这就是我们常见的吸顶效果。
1. UITableView 吸顶效果 UITableView是自带吸顶效果，我们把需要置顶的控件设置为SectionHeaderView，这样在滚动时，该控件会自动置顶。
- (UITableView *)tableView { if (!_tableView) { _tableView = [[UKNestedTableView alloc] init]; _tableView.bounces = NO; _tableView.showsVerticalScrollIndicator = NO; _tableView.delegate = self; _tableView.dataSource = self; [_tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@"CellId"]; } return _tableView; } #pragma mark - UITableViewDataSource - - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { return 2; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { if (section == 0) { return 1; } return 20; } - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath { if (indexPath.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b48c67a51094f88e733622192d9ef659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8a153fd5887805379625d533b1d1bcc/" rel="bookmark">
			创建Google play开发者账号，并验证身份通过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、注册前准备 最好准备一台没有怎么用过Google的电脑和🪜准备一个没有注册过Google的手机号准备一张信用卡或者借记卡（需要支付$25），支持的类型如下图 这里还需注意：最后账号注册成功还需要验证身份也就是实名认证，那么Google去审核的时候就是与付款资料中的信息做对比，这里尤其要注意注册账号的时候选择的国家，下面会说到。 以上这些都是为了提高注册成功率，同时最后一次性注册通过，不然容易出现其他问题
二、第一步肯定是需要先创建一个Google账户 进入accounts.google.com注册一个账号创建好后就可以进入play console进行开发者账号注册了，如下页面 三、我这里选择的账号类型是单位，如下： 这里就需要重点注意这里选择的工作地址：最后验证身份的时候就需要这个国家政府颁发的有效证件，不然的话是无法验证通过的。 总结下来就是：验证身份的时候需要付款银行卡持有人的工作地址国家的有效证件才可以。比如： 注册的时候选的工作地址是：新加坡，付款银行卡是张三的。那么实名的时候就需要张三的新加坡的有效证件注册的时候选的工作地址是：中国，付款银行卡是李四的。那么实名的时候就需要李四的中国身份证 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7f5ef92409386840240a951e50aaaaf/" rel="bookmark">
			C&#43;&#43;设计模式——工厂方法模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工厂方法模式（Factory Method） **工厂方法模式(Factory Method Pattern)：**定义一个用于创建对象的接口，让子类决定将哪一个类实 例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。
“对象创建”模式 通过“对象创建”模式绕开new，来避免对象创建 (new) 过程中所导致的紧耦合(依赖具体类)，从而支持对象创建的稳定。它是接口抽象之后的第一步工作。
典型模式： Factory Method
Abstract Factory
Prototype
Builder
动机（Motivation） 在软件系统中，经常面临着创建对象的工作;由于需求的变化需要创建的对象的具体类型经常变化。
如何应对这种变化?如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合?
模式定义 定义一个用于创建对象的接口，让子类决定实例化哪一个类Factory Method使得一个类的实例化延迟 (目的:解耦，手段: 虚函数)到子类。 ——《设计模式》GoF
结构（Struture） 在工厂方法模式结构图中包含如下几个角色：
Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品 对象的公共父类。
ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工 厂创建，具体工厂和具体产品之间一一对应。
Crereator（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产 品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。
ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并 可由客户端调用，返回一个具体产品类的实例。 与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可 以是抽象类或者具体类。
实例 设定如下场景，因为文件日志与数据库日志的初始化方式不同，所以无法使用简单工厂模式进行简单的 统一创建。 需要对每个类型进行特化版本的工厂创建。 即工厂方法模式
class Logger { public: virtual void writeLog()const = 0; virtual ~Logger() {} }; class FileLogger :public Logger { private:c FILE* fp; public: FileLogger() { } ~FileLogger() { } void writeLog() const { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7f5ef92409386840240a951e50aaaaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09304e13ad71de5af7b543dcff31963c/" rel="bookmark">
			vue3中使用base64加密(两种方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi,今天分享一个在vue中使用base64对用户名、密码进行加密的小案例。
我们是可以有两种方法的：
1.使用插件:js-base64
2.引入文件。
插件--js-base64 1.首先我们安装插件
npm install --save js-base64 2.项目中引入
import {Base64} from 'js-base64' 3.使用
let encodePwd=Base64.encode(password);//加密 let decodePwd=Base64.decode(encodePwd);//解密 文件形式 1.创建utils/base64.js文件夹,复制以下代码
//1.加密解密方法使用： //1.加密 // var str = '124中文内容'; // var base = new Base64(); // var result = base.encode(str); // //document.write(result); // //2.解密 // var result2 = base.decode(result); // document.write(result2); // //2.加密、解密算法封装： function Base64(this: any) { // private property var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; // public method for encoding this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09304e13ad71de5af7b543dcff31963c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35f0eb289b93440bf84a1ffc1a819c5e/" rel="bookmark">
			C&#43;&#43;设计模式——桥模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		桥模式（Bridge） 动机（Motivation） 由于某些类型的固有实现逻辑，使得他们具有两个变化的维度，乃至多个维度的变化
如何应对这种“多维度的变化”？如何利用面向对象技术来使得类型可以轻松沿着两个乃至多个方向变化，而不引入额外复杂度？
模式定义 将抽象部分（业务功能）与实现部分（平台实现）分离，使他们都可以独立的变化。 ——《设计模式》GoF
结构（Struture） （1）Abstraction（抽象类）
用于定义抽象类的接口，其中定义了一个Implementation（实现类接口）的对象并可以维护该对象，它与 Implementation具有关联关系。
（2）Refined Abstraction（扩充抽象类）
扩充由Abstraction定义的接口，通常它不再是抽象类而是具体类。提供控制逻辑的变体。与其父类一样，它们通过通用实现接口与不同的实现进行交互
提供高层控制逻辑，依赖于完成底层实际工作的实现对像
（3）Implementation（实现类接口）
为所有具体实现声明通用接口。抽象部分仅能通过在这里声明的方法与实现对象交互
（4）ConcreateImplementations（具体实现类）
包括特定的实现代码
（5）Client（客户端）
仅关心如何与抽象部分合作。但是，Client需要将抽象对象与一个实现对象连接起来。
实例 如手机支付方式微信、支付宝APP，而每种APP支持三种付款验证方式，密码、指纹、人脸，则桥接模式的实现方式如下：
IPayMode类是实现类，定义了基本操作security()，用于设置验证方式，其子类提供了实现，它位于桥接模式的抽象层。
#include &lt;iostream&gt; using namespace std; // 实现类接口 Implementation（实现类接口）：支付模式 class IPayMode { public: virtual bool security(string Uid) = 0; }; // 具体实现类：密码支付 class PayCypher : public IPayMode { public: bool security(string uId) override { cout &lt;&lt; "Password to pay" &lt;&lt; endl; return true; } }; // 具体实现类：人脸支付 class PayFaceMode : public IPayMode { public: bool security(string uId) override { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35f0eb289b93440bf84a1ffc1a819c5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/445e6006d3fb4900379a0bfab579b314/" rel="bookmark">
			Linux下获取时间的方法对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 概述Linux下获取时间的方法背景内核函数time+ localtime特点范例 gettimeofday + localtime特点范例 clock_gettime + localtime特点范例 rdtsctsc介绍使用rstsc获取代码段的执行时间rdtsc获取时间的优点优点 rdtsc的缺陷rdtsc的进化CPU降频问题 不同Core的TSC同步问题程序乱序执行的问题TSC计数器溢出可能rdtsc 获取程序运行时间的范例 性能对比 linux下配置各个节点的的时间一致性date 命令调整系统时间ntp 调整系统时间ntp 工作原理ntp 报文ntp使用检测 ntp 是否已安装用ntpdate自动更新系统时间用 ntp 搭建自己的时间服务器 参考 概述 linux系统中的时间机制
在linux系统中有两种时钟，一种是硬件时钟，一种是系统时钟。
1.1 The Hardware Clock 硬件时钟跟运行在cpu上的程序是独立不相关的，甚至在服务器关机之后仍然可以正常运行，这就保证了服务器时间的正常运行，硬件时间也有着各种各样的称呼，例如：hardware clock, real time clock, RTC, BIOS clock以及CMOS clock等，在目前主流的服务器都采用RTC芯片实现：
该芯片采用32768HZ的晶振来满足计时的需求，同时拥有独立的电源可以保证断电之后依然可以正常计时，在系统中可以看到硬件时钟的值：
1.2 The System Clock
在linux 内核中还有一个称为系统时钟或者系统时间的概念，这就是我们平时在系统中经常接触到时间，也是应用程序在执行与时间相关的操作会用到的时间，它只是在系统运行时存在，其记录形式为UTC时间（the number of seconds since 00:00:00 January 1, 1970 UTC）。
硬件时钟和系统时间的关系应该如何定义呢？
硬件时钟是用来保证在操作系统关机之后仍然可以正常计时必要硬件，而系统时间是我们在日常操作中才会经常使用到的时间，仅仅在操作系统初始化时，操作系统才会去RTC芯片中拿到硬件时钟的值，之后便是独立运行和独立计时。
由上面的分析，我们可以知道在正常应用中是不会去使用硬件时间，一般都会考虑用系统时间
Linux系统时间分类： （1）日历时间。该值是自协调世界时(UTC)1970年1月1日00:00:00这个特定时间以来所经过的秒数累计值。基本数据类型用time_t保存。最后通过转换才能得到我们平时所看到的24小时制或者12小时间制的时间。
（2）进程时间。也被称为CPU时间，用以度量进程使用的中央处理器资源。进程时间以时钟滴答计算。
进程时间是进程被创建后使用CPU的时间 ，进程时间被分为以下两个部分：
用户CPU时间：在用户态模式下使用CPU的时间
内核CPU时间：在内核态模式下使用CPU的时间。这是执行内核调用或其他特殊任务所需要的时间。
Linux下获取时间的方法 背景 用户空间获取代码段的执行时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/445e6006d3fb4900379a0bfab579b314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b080f1e1d2ff46da0d446ae4352c3be/" rel="bookmark">
			人工智能中的顶级会议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当搭建好了AI领域的知识架构，即具备了较好的数学、编程及专业领域知识后，如果想在AI领域追踪前沿研究，就不能再只看教材了。毕竟AI领域的发展一日千里，教材上的知识肯定不是最新的。此时，应该将关注的重点转向AI领域的会议和期刊论文，特别是会议论文，会议论文包含着AI领域的最新研究成果。AI领域的会议论文非常多，如果没有选择的技巧，无疑是大海捞针，费力而不讨好。这里需要强调一点，要看顶级会议的论文。顶级会议是高手过招的地方，好比是武林中的华山论剑。
什么是顶级会议？哪些会议是顶级会议？如何获取顶级会议的投稿信息？本文将重点描述这些内容。
1. 什么是顶级会议？ 顶级会议好比一个演唱会，只有大牌明星云集的演唱会才算是顶级演唱会，自然地，只有顶级AI学者云集的会议才算是顶级会议。事实上，经过这么多年的发展，AI领域有些会议受到了广大从业人员的深度认可，形成了巨大的品牌效应。大家争相投稿这些会议，导致录用率比大多数期刊的录用率都低很多，这些会议就是AI领域的顶级会议。
2. 哪些会议是顶级会议？ 通过顶级会议的列表可以很方便地查找哪些会议是顶级会议。如何评价一个会议是否是顶级会议，没有统一的标准。因此顶级会议的列表也有很多种版本。读者不用担心各个版本的顶级会议列表会造成冲突和混乱，以至出现不知道应该以哪个版本的顶级会议列表为准的情况。这是因为虽然顶级会议列表的版本有很多种，但是对于顶级会议的评价，各个版本都比较接近。所以参考其中任何一个版本差别都不会太大。顶级会议的列表从哪里去找？这里介绍三种方法，一是通过谷歌学术，二是通过各个学会组织或机构的官网，三是通过中国计算机学会的官网。
通过谷歌学术查找顶级会议列表的具体步骤见图 6‑15。首先打开谷歌学术网站得到界面1，然后在界面1中点击椭圆圈出的“选项按钮”，弹出界面2，然后在界面2中点击“Metrics”，弹出界面3，在界面3中点击“Categories”，弹出界面4，在界面4中点击“Engineering &amp; Computer Science”，弹出界面5，在界面5中点击“Subcategories”，弹出界面6，在界面6中点击“Artificial Intelligence”，弹出界面7，即得到了顶级期刊和会议的混合列表（这里只截取了前4位）。
图 6‑15 使用谷歌学术查找顶级会议列表的具体步骤
通过学会组织或机构的官网也可以查询这些单位推荐的顶级会议列表，例如清华大学、上海交通大学等单位为了规范学术会议论文的发表就发布了各自的顶级会议论文列表，列表中列出了各学科自己推荐的本领域的顶级会议名单，为高质量的学术论文发表指明了方向。这些列表在网上都可以搜索到并可以免费下载，读者可以使用搜索引擎搜索“单位名称 顶级会议列表”下载，例如“上海交通大学 顶级会议列表”。
中国计算机学会发布的《CCF推荐会议/期刊列表》得到了广大计算机领域从业人员的认可。中国计算机学会网站的地址为https://www.ccf.org.cn，界面如图 6‑16所示。通过中国计算机学会的官网查找顶级学术会议列表，只需先打开其官网。然后，点击“CCF推荐会议/期刊列表”栏目（见图 6‑16中用方框标出的栏目），即可看到相关列表。CCF将顶级会议分成了A、B、C三个类别。
图 6‑16 中国计算机学会网站界面
中国计算机学会推荐的人工智能领域A类会议见表 6‑2。表中给出了会议的简称、全称、出版社、网址。注意网址并不是会议的官网，给出的是下载会议论文全文的链接。由于会议基本上都是每年举办一次，也有一些是两年或以上举办一次，所以会议的官网每年都不同。如需查找会议的官网，只需在Google中以会议简称加年份进行搜索即可，例如搜索“CVPR 2021”。表 6‑2中，AAAI和IJCAI代表了人工智能大领域的顶级会议的最高水平。NeurIPS和ICML则代表了机器学习领域顶级会议的最高水平。CVPR和ICCV代表了计算机视觉和模式识别领域顶级会议的最高水平。ACL代表了自然语言处理领域顶级会议的最高水平。
表 6‑2 中国计算机学会推荐的人工智能领域A类会议
序号
会议简称
会议全称
出版社
网址
1
AAAI
AAAI Conference on Artificial Intelligence
AAAI
http://dblp.uni-trier.de/db/conf/aaai/ 2
NeurIPS
Annual Conference on Neural Information Processing Systems
MIT Press
http://dblp.uni-trier.de/db/conf/nips/ 3
ACL
Annual Meeting of the Association for Computational Linguistics
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b080f1e1d2ff46da0d446ae4352c3be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c6ff148fdfe2d75af5fab396160e23/" rel="bookmark">
			Mybatis：多对多查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 查询⽤户同时查询出该⽤户的所有⻆⾊
Bean public class User implements Serializable { private Integer id; private String username; //表示用户关联的角色 private List&lt;Role&gt; roleList = new ArrayList&lt;&gt;(); } public class Role { private Integer id; private String roleName; private String roleDesc; } 第一种方式XML Mapper public interface IUserMapper { //查询所有用户、同时查询每个用户关联的角色信息 public List&lt;User&gt; findAllUserAndRole(); } XML &lt;resultMap id="userRoleMap" type="com.lagou.pojo.User"&gt; &lt;result property="id" column="userid"&gt;&lt;/result&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;collection property="roleList" ofType="com.lagou.pojo.Role"&gt; &lt;result property="id" column="roleid"&gt;&lt;/result&gt; &lt;result property="roleName" column="roleName"&gt;&lt;/result&gt; &lt;result property="roleDesc" column="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30c6ff148fdfe2d75af5fab396160e23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/643ac1a8f14925d6698181dcdedb35c5/" rel="bookmark">
			QPSK调制解调过程,包括串并转换,电平转换,载波调制,相干解调,抽样判决等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、理论基础
二、核心程序
三、仿真结论
一、理论基础 QPSK是英文Quadrature Phase Shift Keying的缩略语简称，意为正交相移键控，是一种数字调制方式。在19世纪80年代初期,人们选用恒定包络数字调制。这类数字调制技术的优点是已调信号具有相对窄的功率谱和对放大设备没有线性要求,不足之处是其频谱利用率低于线性调制技术。19世纪80年代中期以后,四相绝对移相键控(QPSK)技术以其抗干扰性能强、误码性能好、频谱利用率高等优点,广泛应用于数字微波通信系统、数字卫星通信系统、宽带接入、移动通信及有线电视系统之中。通过完成设计内容， 学习QPSK调制解调的基本原理，同时也要复习通信系统的主要组成部分，了解调制解调方式中最基础的方法。了解QPSK的实现方法及数学原理。并对“通信”这个概念有个整体的理解，学习数字调制中误码率测试的标准及计算方法。同时还要复习随机信号中时域用自相关函数，频域用功率谱密度来描述平稳随机过程的特性等基础知识，来理解高斯信道中噪声的表示方法，以便在编程中使用。 理解QPSK调制解调的基本原理，并使用MATLAB编程实现QPSK信号在高斯信道和瑞利衰落信道下传输，以及该方式的误码率测试。复习MATLAB编程的基础知识和编程的常用算法以及使用MATLAB仿真系统的注意事项，并锻炼自己的编程能力，通过编程完成QPSK调制解调系统的仿真，以及误码率测试，并得出响应波形。在完成要求任务的条件下，尝试优化程序。
通过本次实验，除了培养了自主动手学到了知识之外，还可以将次研究作为一种推广，让自己来深入一层的了解QPSK以至其他调制方式的原理和实现方法。可以方便自己进行测试和对比。
正交相移键控（Quadrature Phase Shift Keying，QPSK）是一种数字调制方式。它分为绝对相移和相对相移两种。由于绝对相移方式存在相位模糊问题，所以在实际中主要采用相对移相方式DQPSK。QPSK是一种四进制相位调制，具有良好的抗噪特性和频带利用率，广泛应用 于卫星链路、数字集群等通信业务。
OQPSK是在QPSK基础上发展起来的一种恒包络数字调制技术。恒包络技术是指已调波的包络保持为恒定，它与多进制调制是从不同的两个角度来考虑调制技术的。恒包络技术所产生的已调波经过发送带限后，当通过非线性部件时，只产生很小的频谱扩展。这种形式的已调波具有两个主要特点，其一是包络恒定或起伏很小；其二是已调波频谱具有高频快速滚降特性，或者说已调波旁瓣很小，甚至几乎没有旁瓣。采用这种技术已实现了多种调制方式。OQPSK信号，它的频带利用率较高，理论值达1b/s/Hz。在QPSK中，当码组0011或0110时，产生180°的载波相位跳变。这种相位跳变引起包络起伏，当通过非线性部件后，使已经滤除的带外分量又被恢复出来，导致频谱扩展，增加对相邻波道的干扰。为了消除180°的相位跳变，在QPSK基础上提出了OQPSK。
一个已调波的频谱特性与其相位路径有着密切的关系，因此，为了控制已调波的频率特性，必须控制它的相位特性。恒包络调制技术的发展正是始终围绕着进一步改善已调波的相位路径这一中心进行的。
OQPSK也称为偏移四相相移键控，是QPSK的改进型。它与QPSK有同样的相位关系，也是把输入码流分成两路，然后进行正交调制。不同点在于它将同相和正交两支路的码流在时间上错开了半个码元周期。由于两支路码元半周期的偏移，每次只有一路可能发生极性翻转，不会发生两支路码元极性同时翻转的现象。因此，OQPSK信号相位只能跳变0°、±90°，不会出现180°的相位跳变。QPSK信号可以看作两个载波正交2PSK信号的合成，所以QPSK正调制器可参考通信原理
QPSK信号调制效果如下所示：
通过上面对QPSK信号的调制，我门对QPSK有了更加深刻的认识。那么它的解调可以采用与2PSK信号类似的解调方法进行解调。同相支路和正交支路分别采用相干解调方式解调，之后可以得到二者的和，经过抽样判决和串、并交换器，将上下之路得到的并行数据恢复为串行数据。
QPSK解调原理:
QPSK解调结果如下：
四相相移调制是利用载波的四种不同相位差来表征输入的数字信息，是四进制移相键控。QPSK是在M=4时的调相技术，它规定了四种载波相位，分别为45°，135°，225°，315°，调制器输入的数据是二进制数字序列，为了能和四进制的载波相位配合起来，则需要把二进制数据变换为四进制数据，这就是说需要把二进制数字序列中每两个比特分成一组，共有四种组合，即00，01，10，11，其中每一组称为双比特码元。每一个双比特码元是由两位二进制信息比特组成，它们分别代表四进制四个符号中的一个符号。
在数字信号的调制方式中QPSK四相移键控是目前最常用的一种卫星数字信号调制方式,它具有较高的频谱利用率、较强的抗干扰性、在电路上实现也较为简单。目前已经广泛应用于无线通信中，成为现代通信中一种十分重要的调制解调方式。
QPSK是一种频谱利用率高、抗干扰性强的数调制方式, 它被广泛应用于各种通信系统中. 适合卫星广播。例如，数字卫星电视DVB-S2 标准中，信道噪声门限低至4. 5 dB，传输码率达到45M b&amp;ouml;s，采用QPSK 调制方式，同时保证了信号传输的效率和误码性能。
在数字信号的调制方式中，所学的2ASP、2FSP、2KSP是比较早的理论，随着时代的发展，科技的进步，人民生活水平的提高，对通信行业有着越来越高的要求。QPSK技术的出现，解决了许多技术上的问题。和QPSK最接近的是2PSK技术。2PSK技术是运用“0”和“1”进行编码；而QPSK运用四个相位进行编码。也就是说QPS利用载波的四种不同相位来表示数字信息。对输入的码元进行划分，每两个比特码编为一组。然后用四种不同的相位来表示。所以QPSK又被称为双比特码元。由于每一种载波相位代表两个比特信息，因此每个四进制码元可以用两个二进制码元的组合来表示。
二、核心程序 ................................................................ y3=z2.*y2; subplot(212) plot(t1,y3) axis([0 0.4 -3 3 ]); title('Q支路分量相干解调信号') xlabel('时间/s') ylabel('幅值') grid on; %加噪信号通过滤波器 [b,a]=butter(3,0.1); x3=filter(b,a,x3); [b,a]=butter(2,0.1); y3=filter(b,a,y3); figure(6) subplot(211) plot(t1,x3); axis([0 0.2 -3 3 ]); title('I支路分量相干解调信号通过滤波器') xlabel('时间/s') ylabel('幅值') grid on; subplot(212) plot(t1,y3); axis([0 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/643ac1a8f14925d6698181dcdedb35c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b18ab242c5d0f4e77868b8adb470babc/" rel="bookmark">
			多台电脑连接惠普打印机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日新进了一台打印机，之前我们连接打印机的方式都是单独接一个闲置电脑，打印机接在这台闲置电脑上，然后再通过win的“远程桌面连接”对电脑进行访问，复制粘贴相关文件进行打印，然而最近这台电脑不闲了，但是怎么连接新打印机成个问题。
新打印机：
1、可以微信小程序打印（日常办公不方便，要先打开微信，上传文件才能打印）
2、也可以连接wifi无线打印（前提是同一个局域网，可是部分电脑不符合条件）
3、可以接网线（那怎么能同时满足具有独立网口和连接路由器的电脑访问呢？）
网上搜了一堆，也没看出个所以然，最后索性拿根网线直接把打印机接入网口，然后尝试直接搜寻打印机，这里分两种情况（仅在win10电脑上尝试）：
1. 电脑直接接网口上网的（IP为172开头的） “开始”–“设置”–“设备”–“打印机和扫描仪”–“添加打印机或扫描仪”
即可查询到打印机，搜寻到之后电脑会自动下载相应驱动，完成后即可直接打印
2. 电脑接路由器上网的（IP为192开头的） “开始”–“设置”–“设备”–“打印机和扫描仪”–“添加打印机或扫描仪”
和情况一同样的步骤，但是找不到
选择“我需要的打印机不在列表中”–“使用IP地址或主机名添加打印机”–“设备类型选择自动检测或者TCP/IP设备”即可–输入“IP地址”
打印机的IP地址折腾了半天，以HP的M233sdw为例，在打印机主控台点击感叹号按钮，即可获得一张关于该台打印机的详细信息，其中就包括了IP地址，其他型号不能保证这种方式一定可以，如不行，请自行搜索查询IP的方式
之后输入“端口名称”
其实会发现在输入IP地址的时候，端口名称也会随之输入，也就是在输入完IP地址后，端口名称和IP地址相同，这里建议在后面加个_X，这个X可以是不同的数字，为避免多台电脑使用相同端口而无法访问（本人猜测，若不需要可直接忽略）
“下一页”（耐心等待检测）
“等待通信”–“选择相应的厂商和打印机”–“下一页”直至成功添加打印机
以HP的m233sdw为例，添加后，还需要回到“打印机和扫描仪”的界面，打开打印机应用(HP Smart，请关闭VPN使用）再次添加一下打印机（手动点一下就能自动检测到了），添加完成之后方可正常使用。
折腾一番发现直接连接打印机还是比先连接远程电脑再打印方便，无论是打印、复印、扫描都很方便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c01327de3df1b3436bc8cb241ad308d9/" rel="bookmark">
			目标检测-yolov50-火灾识别可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用yolov5模型对利用开源火灾数据集进行训练模型，实现对照片、视频以及摄像头的火焰烟雾的检测。
详细的环境配置见：目标检测-YOLOV5-口罩检测
学习目标： 数据集的准备 预训练权重 训练模型 训练模型路径的修改 模型测试 pyqt可视化 重要的事情，出错请去查看！！！ 目标检测-YOLOV5-口罩检测
一、数据集的准备 1.数据集的下载 链接：https://pan.baidu.com/s/1LLfnSOEBdlgOnL_iEyMIsA
提取码：ghaq
2.划分数据集为训练集和验证集 该数据集的标签是xml格式，训练yolo模型需要txt类型的标签。需要先将xml类型的标签转换为txt类型，再划分数据集。
需要新建几个文件夹，具体如下：
划分数据集的py文件
split_train_val.py
# coding=utf-8 import xml.etree.ElementTree as ET import pickle import os from os import listdir, getcwd from os.path import join import random from shutil import copyfile classes = ["fire", "smoke"] # classes=["ball"] TRAIN_RATIO = 80 #训练集和验证集的比例，说明80%的训练集，20%的验证集 def clear_hidden_files(path): dir_list = os.listdir(path) for i in dir_list: abspath = os.path.join(os.path.abspath(path), i) if os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c01327de3df1b3436bc8cb241ad308d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa2d5cddbcd01f8ac0e0b53089b39a08/" rel="bookmark">
			NX二次开发 UFUN根据图纸视图抽取边2D对象找到对应的3D对象实体边 UF_DRAW_ask_drafting_curve_parents
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 NX二次开发 UFUN根据图纸视图抽取边2D对象找到对应的3D对象实体边 UF_DRAW_ask_drafting_curve_parents
//NX8.0+VS2010 #include &lt;uf_assem.h&gt; #include &lt;uf_part.h&gt; #include &lt;uf_obj.h&gt; #include &lt;uf_modl.h&gt; #include &lt;uf_view.h&gt; #include &lt;uf_draw.h&gt; extern DllExport void ufsta(char* param, int* returnCode, int rlen) { if (UF_initialize()) return; tag_t input_curve_tag = 49132;//图纸视图上抽取边的tag int parents_count = 0; tag_t *parents = NULL_TAG; UF_DRAW_ask_drafting_curve_parents(input_curve_tag, &amp;parents_count, &amp;parents); //打印抽取边对应的三维实体边tag char msg[257]; for (int i = 0; i &lt; parents_count; i++) { sprintf(msg, "tag = %d", parents[i]); uc1601(msg, 1); } UF_free(parents); UF_terminate(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1a29f4866bfa287d281c0d2db2fbf49/" rel="bookmark">
			cf Educational Codeforces Round 141 E. Game of the Year
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原题：
E. Game of the Year
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Monocarp and Polycarp are playing a computer game. This game features n bosses for the playing to kill, numbered from 1 to n.
They will fight each boss the following way:
Monocarp makes k
attempts to kill the boss;
Polycarp makes k
attempts to kill the boss;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1a29f4866bfa287d281c0d2db2fbf49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26b0321048f8b8db07581651691ae42c/" rel="bookmark">
			QT基础之【QDialog】对话框类详解，示例源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标准基本对话框应用 通过一个实例来介绍Qt5中对于各类对话框的应用。这个实例中具有以下这几种QT的标准对话框：
标准文件对话框（QFileDialog）
标准颜色对话框（QColorDialog）
标准字体对话框（QFontDialog）
标准输入对话框（QInputDialog）
标准消息对话框（QMessageBox）
效果展示 各种基本对话框都是通过调用各自不同的静态函数来完成其功能。具体如下：
类类说明静态函数函数说明QFileDialog类标准文件对话框getOpenFileName获得用户选择的文件名––getSaveFileName获得用户保存的文件名––getExistingDirectory获得用户选择的已存在的目录名––getOpenFileNames获得用户选择的文件名列表QColorDialog类标准颜色对话框getColor获得用户选择的颜色值QFontDialog类标准字体对话框getFont获得用户选择的字体QInputDialog类标准输入对话框getText标准字符串输入对话框––getItem下拉表条目输入框––getIntint类型数据输入对话框––getDoubledouble类型数据输入对话框QMessageBox类消息对话框QMessageBox::questionquestion消息框––QMessageBox::informationinformation消息框––QMessageBox::warningwarning消息框––QMessageBox::criticalcritical消息框––QMessageBox::aboutabout消息框––QMessageBox::aboutQtabout Qt消息框 函数详细介绍看Qt帮助文档 源码如下 文件分组 dialog.h 主界面头文件以及信号槽的定义
#ifndef DIALOG_H #define DIALOG_H #include &lt;QDialog&gt; #include &lt;QLineEdit&gt; #include &lt;QPushButton&gt; #include &lt;QGridLayout&gt; #include "inputdialog.h" #include "msgboxdlg.h" QT_BEGIN_NAMESPACE namespace Ui { class Dialog; } QT_END_NAMESPACE class Dialog : public QDialog { Q_OBJECT private: QLineEdit* filePathEdit; QPushButton* fileBtn; QPushButton* colorBtn; QGridLayout* mainLayout; QFrame* colorFrame; QPushButton* fontBtn; QLineEdit* fontLineEdit; QPushButton* inputBtn; QPushButton* infoBtn; InputDlog* indialog; MsgBoxDlg* msgbox; QPushButton* customBtn; QLabel* label; private slots: void showFile(); void showcolor(); void showfont(); void showInput(); void showMsgBox(); void showCustom(); public: Dialog(QWidget *parent = nullptr); ~Dialog(); private: Ui::Dialog *ui; }; #endif // DIALOG_H dialog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26b0321048f8b8db07581651691ae42c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/924e73bcd82debadec72d240999ed055/" rel="bookmark">
			一文搞懂using namespace std【命名空间】【C&#43;&#43;初阶】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章将打开C++学习新篇章，欢迎与博主一起学习交流。
目录
前言
一、命名空间的定义
二、命名空间的使用
1、三种使用方法
2、局部域&gt;全局域/已展开的命名空间&gt;未展开的命名空间
三、建议
总结
前言 在C语言学习中，我们如果定义了一个变量的名字跟头文件中的某个函数冲突了，编译器就会报错；一些变量，函数和类都存在于全局变量中，可能会导致很多冲突，为了解决这个问题，cpp就引入了命名空间（namespace）这个概念。
一、命名空间的定义
使用命名空间的目的是对标识符的名称进行本地化，以免命名冲突或名字污染。
一个命名空间就定义了一个新的作用域，命名空间中所有内容都局限在该命名空间中。
定义： namespace(关键字）+命名空间的名字+{命名空间的成员}
namespace jy { int rand = 10; int Add(int left,int right) { return left+right; } struct Node { struct Node*next; int val; }; } 注意：
命名空间可以嵌套定义
同一个工程中允许存在多个相同名称的命名空间，最后编译器会合成同一个命名空间中。
二、命名空间的使用 namespace N { int a = 1; } 1、三种使用方法 （1）加命名空间名称及作用域限定符(::)
int main() { printf("%d", N::a); return 0; } 注：若作用域限定符（：：)左边为空，则代表全局
eg：
int a=1; int main() { int a=0; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/924e73bcd82debadec72d240999ed055/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/167bf91b3867acf9c2f3dd332e0ddcd7/" rel="bookmark">
			gcc 非管理员用户升级9.4.0版本教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Aliases:gcc 非管理员升级版本
Tags: 服务器
date: 2023-04-15 由于现阶段，集群的 gcc4.x 版本已经不能满足自己的需求，但是由于项目要求大于5.x 的 gcc 版本，所以又不得不升级。
报错如下：
RuntimeError: The current installed version of g++ (4.8.5) is less than the minimum required version by CUDA 11.4 (6.0.0). Please make sure to use an adequate version of g++ (&gt;=6.0.0, &lt;=10.0.0). [end of output] 1.官网下载 gcc9.4的压缩包 https://ftp.gnu.org/gnu/gcc/gcc-9.4.0/gcc-9.4.0.tar.gz
2.tar -xzf 命令解压 tar -xzf gcc-9.4.0.tar.gz 这个会将压缩包解压到当前目录
3.新建文件夹，安装 gcc(在当前目录新建，官网新建的目录名为 objdir，我换了个名) mkdir gcc-9.4.0-build ​cd gcc-9.4.0-build 需要在gcc-9.4.0-build文件夹中执行命令，安装gcc包
../configure --disable-checking --enable-languages=c,c++,fortran --disable-multilib --prefix=/path/to/install/gcc-9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/167bf91b3867acf9c2f3dd332e0ddcd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/351fa0134434f4a66d17576e1cee9d13/" rel="bookmark">
			ssh链接 git@github.com: Permission denied (publickey).
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误原因：没有在config文件中指定平台所用的私钥路径，默认用平台文件名私钥去配对了。
第一步：在ssh目录下查看是否有config文件，没有就在终端ssh目录下输入
touch config 第二步：编辑config文件
# GitHub Host github.com HostName github.com User git IdentityFile ~/.ssh/id_custome_name //创建的私钥名 第三步：再次测试
ssh -T git@github.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7fce00466b1bf64b47c65f36de9d9a9/" rel="bookmark">
			MyBatis-Plus 还手写 Join 联表查询？一个依赖轻松搞定，真香！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“Java基基”，选择“设为星标”
做积极的人，而不是积极废人！
每天 14:00 更新文章，每天掉亿点点头发...
源码精品专栏
原创 | Java 2021 超神之路，很肝~
中文详细注释的开源项目
RPC 框架 Dubbo 源码解析
网络应用框架 Netty 源码解析
消息中间件 RocketMQ 源码解析
数据库中间件 Sharding-JDBC 和 MyCAT 源码解析
作业调度中间件 Elastic-Job 源码解析
分布式事务中间件 TCC-Transaction 源码解析
Eureka 和 Hystrix 源码解析
Java 并发源码
来源：网络
使用方法
仓库地址
安装
使用
核心类MPJLambdaWrapper和MPJQueryWrapper
MPJLambdaWrapper用法
String形式用法（MPJQueryWrapper）
众所周知，Mybatis Plus 封装的 mapper 不支持 join，如果需要支持就必须自己去实现。但是对于大部分的业务场景来说，都需要多表 join，要不然就没必要采用关系型数据库了。
那么有没有一种不通过硬 SQL 的形式，通过框架提供 join 能力呢？答案是，可以有，今天专门拉出来再说一下，确实能提高不少的开发效率！
使用方法 仓库地址 https://gitee.com/best_handsome/mybatis-plus-join
安装 Maven
&lt;dependency&gt; &lt;groupId&gt;com.github.yulichang&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-join-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.4&lt;/version&gt; &lt;/dependency&gt;Gradle
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7fce00466b1bf64b47c65f36de9d9a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6643b5c87855130ab340ec6bfc05ac1e/" rel="bookmark">
			Centos7部署torch环境 配合pyCharm远程调试开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python目标版本3.6，torch目标版本1.8.1
部署环境总是代码开发者离不开的一个问题，通常会有几种解决路线。
1. 每个环境单独部署一套，windows一套，unix一套，需要什么依赖就装什么。
2. 引入conda环境，为每个类型的项目创建一个属于自己的虚拟环境。
3. 引入Docker，直接把代码运行所需要的操作系统以及库依赖全部打包。
4. 服务器-本地结合的开发形式。
本文主要尝试第二点与第四点相结合，利用已有的闲置服务器，配合本地IDE进行开发。
首先在Centos7上部署conda 在CentOS7环境下部署Anaconda，需要进行以下步骤：
在home下创建一个目录，名为miniconda2，我们目标是下载Miniconda
Miniconda是一个轻量级的Python发行版本，它包含了conda、python等180多个科学包及其依赖项，适合空间要求严格的用户。Miniconda相当于conda+python+pip，它的安装包比Anaconda更小，功能也更少，但是仍然能够满足一般用户的需求。
Anaconda是一个完整的Python发行版本，包含了conda、python等所有必要的包，适合需要安装所有包的用户。Anaconda的安装包比Miniconda更大，功能也更多，但是对于需要安装特定包的用户来说，Anaconda可能更适合。
国内镜像源的地址为：Index of /anaconda/miniconda/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror
具体的下载指令为：
mkdir /home/miniconda2 cd /home/miniconda2 wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda2-4.7.12.1-Linux-x86_64.sh 下载完毕后执行安装命令：
cd /home/miniconda2 chmod 777 Miniconda2-4.7.12.1-Linux-x86_64.sh #给执行权限 bash Miniconda3-latest-Linux-x86_64.sh 中间可以根据自己的需要确定安装路径。 如果我们执行conda init，系统提示： conda command not find
那我们需要将安装路径添加到系统的PATH当中，我们需要修改两个文件
sudo vim /etc/profile # 在最后一行加上: export PATH=$PATH:~/anaconda3/bin sudo vim ~/.bashrc # 在最后一行加上: export PATH=$PATH:~/anaconda3/bin 我们再执行一行语句，激活环境
source ~/.bashrc 之后我们再执行版本查看
conda -V 输出结果：即可。 然后创建一个pytorch环境，这里由于服务器性能限制，安装CPU版本即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6643b5c87855130ab340ec6bfc05ac1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7029ee39c79d5bfbbade4a8fa29cd8d/" rel="bookmark">
			open3d（python）读取点云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import open3d as o3d import numpy as np pcd = o3d.io.read_point_cloud('guan_R.ply',remove_nan_points = True,remove_infinite_points = True) # 读取点云 print('原始点云个数是:',np.array(pcd.points).shape[0]) # 打印点云点数 pcd.paint_uniform_color([0, 0, 0]) # 点云颜色 o3d.visualization.draw_geometries([pcd]) # 可视化点云o3d.io.write_point_cloud("guan_R.pcd", new_cloud) # 保存点云 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21a986b2f9f54cca52f7f292a9d13c85/" rel="bookmark">
			golang分布式中间件之ElasticSearch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ElasticSearch是一个基于Lucene的分布式搜索引擎，它提供了全文搜索、实时分析和数据可视化等功能。ElasticSearch具有高度可扩展性，并可以处理大量的数据。在本文中，我们将介绍如何使用Go语言来实现ElasticSearch分布式中间件，并探讨ElasticSearch的一些核心概念和特性。
一、ElasticSearch的核心概念
索引（Index）
索引是ElasticSearch中的最基本概念之一，类似于数据库中的表。每个索引都包含多个文档，而文档则是索引中的最小存储单元。索引使用唯一的名称来进行标识，可以在其上执行各种操作，包括搜索、添加、删除等。
文档（Document）
文档是ElasticSearch中的另一个重要概念，它包含了实际存储的数据。每个文档都具有唯一的ID，可以根据ID进行检索、更新或删除。文档由一个或多个字段组成，每个字段都具有一个名称和一个值。
分片（Shard）
为了实现数据的高度可扩展性，ElasticSearch将每个索引分成多个分片。每个分片是一个独立的Lucene索引，可以存储一部分文档。分片数量可以在索引创建时指定，并且可以在后续进行更改。
节点（Node）
节点是ElasticSearch集群中的一个实例，它负责存储和处理数据。每个节点都具有唯一的名称，并可以通过其他节点来发现。节点可以随时加入或退出集群，以实现高可用性和可伸缩性。
集群（Cluster）
集群是一组相互连接的ElasticSearch节点，共同协作来处理数据。集群由一个唯一的名称来进行标识，节点可以在不同的物理服务器上，也可以在同一台机器上运行。
映射（Mapping）
映射定义了索引中每个字段的类型、分析器等信息。它可以用于确定如何将文档中的值映射到字段中，以及如何对字段中的值进行搜索和过滤。
二、使用Go语言实现ElasticSearch分布式中间件
安装go-elasticsearch库
go-elasticsearch是一个基于Elasticsearch官方客户端库开发的开源库，提供了简单、高效的Elasticsearch客户端实现。它支持所有的Elasticsearch版本，并提供了对TLS加密和认证的支持。
可以使用以下命令来安装go-elasticsearch库：
go get github.com/elastic/go-elasticsearch/v7
连接Elasticsearch集群
下面是一个连接Elasticsearch集群的示例代码：
package main import ( "context" "fmt" es "github.com/elastic/go-elasticsearch/v7" ) func main() { // 配置Elasticsearch连接信息 cfg := es.Config{ Addresses: []string{ "http://localhost:9200", }, } // 创建一个新的Elasticsearch客户端 client, err := es.NewClient(cfg) if err != nil { fmt.Println("failed to create elasticsearch client:", err) return } // 检查集群状态 res, err := client.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21a986b2f9f54cca52f7f292a9d13c85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b365b842d2030e7446b66102cef5b7c7/" rel="bookmark">
			Pytorch安装与测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Anaconda安装 官方网址:www.anaconda.com
找到anaconda的历史安装版本,我安装的是此版本
一直使用默认安装下来即可
1.1安装下来打开终端，创建python环境 1.2创建完成后 创建完成后，通过pip list发现没有torch
2.pytorch安装 进入pytorch官网:PyTorch，选择相应版本
注意:下载pytorch之前，要提前下载cuda与cuDNN，同时不要用pytorch的镜像，通常选用清华镜像
2.1清华镜像配置 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
conda config --set show_channel_urls yes
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/
运行截图如下:
（注：红框圈出来的为上述要输入的四行代码。蓝色圈出来的是自己已经添加好channels,会给你提示已经存在，看到之后不用理会，继续下面操作）
2.2查看一下自己的驱动版本 命令如下:
nvidia-smi
2.3下载pytorch
注意：输入到cmd中要把最后的 “ -c python ”删掉，不要复制进去。因为 “-c python”是从pytorch下载，我们设置的是清华园下载！！！
下载完后：
输入import torch,会正常到下一个命令行而不报错，则说明安装pytorch成功
官方教程
CUDA：Installation Guide Windows :: CUDA Toolkit Documentation
cuDNN：Installation Guide :: NVIDIA Deep Learning cuDNN Documentation
详细参考此文章:CUDA安装教程（超详细）_Billie使劲学的博客-CSDN博客
当输入torch.cude.is_available(),返回True时，说明都安装成功，可以利用电脑GPU来进行训练了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b78d7fbf388ea204b657d70ec17c95c2/" rel="bookmark">
			三角形（初一数学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一， 三角形基础 1. 三角形的判定： 1，边的判定：设三边分别为：a,b,c;
条件为：a+b&gt;c, a+c&gt;b, b+c&gt;a;
2.角的判定：三个角加起来为180°
例题：
以三角形的性质来计算一下题目：
|a+b+c|+|a-b-c|-|a+b-c|
解：原式= a+b+c+(b-a+c)-a-b+c
=a+b+c+b-a+c-a-b+c
=b+c+c+c-a
=b+3c-a
三角形分类：
三角形角形式分类 锐角三角形三个角都是锐角 直角三角形一个直角，其余两个角是锐角钝角三角形一个钝角，其余两个角是锐角 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c657ac69f74b0a499b5d579351f39e54/" rel="bookmark">
			docker安装青龙面板薅羊毛（新手教程，大佬可略过）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当然如果没有服务器的，强烈推荐腾讯云，1核2G的服务器，一年原价1000多块的服务器，现在有活动新用户一年也就70元，也就一顿外卖钱。完全白嫖啊。本博客用的就是腾讯云 1核2G的轻量服务器，速度怎么样可以自己感受一下。建议直接买满3年。
几十块钱的服务器性能远超几百上千的VPS服务器。
下面说下怎么安装青龙脚本：
一、安装青龙面板
SSH连接上你的服务器，可以使用Xshell这类软件连接，或者直接在宝塔里运行命令安装。
先安装 docker管理器
1.安装docker（如果有安装宝塔面板，直接应用市场搜索安装）
1.1检查yum源且更新
sudo yum check-update
1.2下载docker
curl -fsSL https://get.docker.com/ | sh
正在上传…重新上传取消
如果有出现这个，不用管，继续往下执行。
1.3.启动docker
sudo systemctl start docker
1.4.查看docker状态
sudo systemctl status docker.service
1.5.设置开机自启
sudo systemctl enable docker
2 安装青龙面板 2.1.拉取青龙面板
wget -q https://raw.githubusercontents.com/shufflewzc/VIP/main/Scripts/sh/ql.sh -O ql.sh &amp;&amp; bash ql.sh
一键脚本，一直回车到最后就行了，可以认真的看看内容，单不要去修改一键脚本的设置，就一直回车到安装成功。
防火墙注意放行 5700 5701 端口
登录面板面板地址：http://服务器IP:5700默认账号：admin默认密码：adminadmin当您使用以上密码首次登录后，面板会显示已初始化密码请在SSH终端内查看新密码（输出的结果就是实际的密码了 {“username”:”admin”,”password”:””} ），如果忘记记录下后台密码也没关系，执行以下代码即可找回后台账号： docker exec -it qinglong cat /ql/config/auth.json
2.自己通过命令
拉取镜像
docker pull whyour/qinglong:latest sudo docker run -dit \ -v $PWD/ql/config:/ql/config \ -v $PWD/ql/log:/ql/log \ -v $PWD/ql/db:/ql/db \ -p 5700:5700 \ --name qinglong \ --hostname qinglong \ --restart always \ whyour/qinglong:latest 以上最终完成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c657ac69f74b0a499b5d579351f39e54/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/145/">«</a>
	<span class="pagination__item pagination__item--current">146/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/147/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>