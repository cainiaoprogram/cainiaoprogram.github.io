<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ddd34e9e396ae4e15f6017a28c3d5b/" rel="bookmark">
			豆瓣8.9分的C&#43;&#43;经典之作，十五年后重磅升级！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01
学习C++模板技术的经典之作
C++ 技术爱好者们，特大喜讯来啦！《C++ Templates（第2版）中文版》将要上市，第 2 版相距第 1 版已有15年，这一次更新可以说是全面拥抱了现代 C++ 的语言特性。
▼点击下方，即可购书
C++ 程序员都知道，模板技术是一种强大的特性，可以让程序员编写尽可能通用的代码，使其能够处理多种不同的数据类型和数据结构。通过使用模板，可以创建可重用的函数和类，以适应不同的数据类型。
要掌握好模板技术，要知道的知识可不少，除了坚实的 C++ 语法基础，还要弄懂模板的语法、类型推导规则、模板特化和偏特化、模板元编程，以及在工作中如何应用等。
所以当《C++ Templates》第 1 版上市时，立即让无数迷茫的程序员如获至宝，通过学习这本书真正掌握了模板技术。本书第 1 版的豆瓣评分高达 8.9，足以说明其影响力之深远。
02
拥抱现代C++，焕发新生命之力
C++ 发展历史上的一个重要节点就是 C++11 标准的推出，100多项新特性让 C++ 获得了“现代C++”的称号。以至于 C++ 之父 Bjarne Stroustrup 也说：“C++11 看起来像一门新的语言。”
不过本书第 1 版的内容还只适用于 C++98、C++03 标准，因此，第 2 版最大的变化就是基于 C++11 之后的标准对内容进行了全面的改写，不仅删除了过时的技术实现，而且对新旧标准之间的变化也没有过多描述。
这意味着第 2 版内容完全建立在 C++11、C++14 和 C++17 标准之上，专注于说明 C++ 模板的设计与使用。已经熟悉现代 C++ 的程序员学习这本书的时候会感觉如丝般顺畅自然。
我们具体了解一下本书介绍了哪些与语言新特性相关的模板知识。
C++11：
· 变参模板；
· 别名模板；
· 移动语义、右值引用和完美转发；
· 标准类型特征。
C++14、C++17：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2ddd34e9e396ae4e15f6017a28c3d5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77110b123738565ca77d680a261626d4/" rel="bookmark">
			第十五章 创建Callout Library - 处理 UNIX 信号处理错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第十五章 创建Callout Library - 处理 UNIX 信号处理错误处理 `UNIX` 信号处理错误`sigrtclr()``dzfalarm()``sigrtchk()` 第十五章 创建Callout Library - 处理 UNIX 信号处理错误 处理 UNIX 信号处理错误 在 UNIX 及相关操作系统下运行时，如果进程收到信号，某些系统调用可能会失败，最常见的是打开、读取、写入、关闭、ioctl 和暂停。如果函数使用任何这些系统调用，代码必须能够区分真正的错误、Ctrl-C 和应重新启动的调用。
以下函数允许检查异步事件并在 $ZF 中设置新的警报处理程序。函数声明包含在 iris-cdzf.h 中：
sigrtclr() int sigrtclr(); — 清除重试标志。应在使用 sigrtchk() 之前调用一次。
dzfalarm() int dzfalarm(); — 建立新的 `SIGALRM 处理程序。
进入 $ZF 时，会自动保存先前的处理程序。退出时会自动恢复。用户程序不应改变任何其他信号的处理。
sigrtchk() int sigrtchk(); — 检查异步事件。每当以下系统调用之一失败时就应该调用：open、close、read、write、ioctl、pause 或进程收到信号时失败的任何调用。它返回一个代码，指示用户应采取的操作：
-1 — 不是信号。检查 I/O 错误。查看 errno 变量的内容。0 — 其他信号。从中断点重新开始操作。1 — SIGINT/SIGTERM。使用 SIGTERM“return 0”退出 $ZF。这些信号被适当地捕获。 用于控制某些设备的典型 $ZF 函数将使用类似于以下伪代码的逻辑：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77110b123738565ca77d680a261626d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bacc939a059fe16160bbe5422924a53a/" rel="bookmark">
			Java修仙之路，十万字吐血整理全网最完整Java学习笔记（基础篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航：
【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/黑马旅游/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码-CSDN博客
推荐视频：
黑马程序员全套Java教程_哔哩哔哩
尚硅谷Java入门视频教程_哔哩哔哩
推荐书籍：
《Java编程思想 （第4版）》 《Java核心技术·卷I（原书第12版） : 开发基础》
目录
零、引言
0.1 背景和写作目的
0.2 本期更新内容
一、环境准备
1.1 JDK8
1.1.1 下载
1.1.2 安装
1.1.3 配置环境变量
1.1.4 验证
1.1.5 知识加油站：JDK、JRE、JVM、Java的区别
1.1.6 知识加油站：Java8新特性
1.2 记事本体验Hello World
二、Java编译器：IDEA
2.1 下载安装配置
2.1.1 下载安装
2.1.2 配置
2.1.2.1 编码配置UTF-8
2.1.2.2 配置Maven路径
2.1.3 安装插件
2.1.3.1 基础插件
2.1.3.2 高级插件
2.1.5 编写Hello World
2.1.6 常用快捷键
2.2 断点调试 2.2.1 断点
2.2.2 调试 2.2.3 知识加油站：高级断点调试
2.2.3 丢帧（退帧）
2.2.4 强制返回
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bacc939a059fe16160bbe5422924a53a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3de49f7d2e52a8085145a9251f37a5bb/" rel="bookmark">
			uniapp使用tcp和udp的区别和例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Node.js中，主要有三种socket：TCP，UDP和Unix域套接字。以下分别介绍这TCP/UDP的使用方法和示例：
TCP socket
TCP socket提供了可靠的、面向连接的通信流，适用于需要可靠传输的应用，例如Web浏览器的HTTP请求。在Node.js中，可以使用net模块创建TCP服务器和客户端。以下是一个创建TCP服务器和客户端的示例：
服务器端代码（app.js）：
var express = require('express'); var app = express(); var net = require('net'); var HOST = '127.0.0.1'; var PORT = 8081; net.createServer(function(sock) { console.log('获得一个连接'); sock.on('data', function(data) { console.log('从客户端接受的数据: ' + data); sock.write('向客户端回发数据 "' + data + "\n"); sock.end("关闭socket"); // 触发客户端和服务端的close事件监听 }); }).listen(PORT, HOST);
客户端代码（client.js）：
var net = require('net'); var HOST = '127.0.0.1'; var PORT = 8081; var client = net.createConnection(PORT, HOST); client.on('connect', function() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3de49f7d2e52a8085145a9251f37a5bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a0c7bfde969e373d09415bb89b7bc78/" rel="bookmark">
			MEW-UNet：医学图像分割中的频域多轴表示学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘要1、简介2、相关研究2.1、医学图像分割2.2、基于ViT的技术 3、我们的方法3.1、准备工作3.2、多轴外部权重块3.3、外部权重生成器 4、实验4.1、数据集4.2、实现细节4.3、与当前最佳方法的比较4.4、消融实验4.5、可视化 5、结论声明 摘要 https://arxiv.org/pdf/2312.17030v1.pdf
最近，视觉Transformer (ViT)在医学图像分割（MIS）中得到了广泛应用，这归功于其在空间域应用自注意力机制来建模全局知识。然而，许多研究都侧重于改进空间域模型，而忽略了频率域信息的重要性。因此，我们提出了基于U-shape架构的多轴外部权重UNet（MEW-UNet），通过将ViT中的自注意力替换为我们的多轴外部权重块。具体来说，我们的块对输入特征的三个轴进行傅里叶变换，并在频率域中分配由我们的外部权重生成器生成的外部权重。然后，进行逆傅里叶变换以将特征变回空间域。我们在Synapse、ACDC、ISIC17和ISIC18数据集上评估了我们的模型，由于其有效地利用了频率域信息，我们的方法表现出了竞争力。
代码：https://github.com/jcruan519/mew-unet
关键词：医学图像分割、注意力机制、频率域信息
1、简介 医学图像分割（MIS）具有巨大的实用价值，因为它可以帮助相关医务人员定位病变区域，提高临床治疗的效率。近年来，基于U-shape架构的编码器-解码器模型UNet被广泛应用于MIS，因为它具有较强的可扩展性。因此，基于U-shape架构的研究有很多，如UNet++（Zhou等，2018），它通过引入密集连接减少了编码器和解码器之间的语义鸿沟。此外，Att-UNet（Oktay等，2018）引入了门控机制，使模型能够专注于特定的目标。
上述改进都是基于卷积神经网络（CNNs）的，由于卷积操作的固有局部性，它们在获取全局信息方面表现不佳。相比之下，ViT（Dosovitskiy等，2020a）引入了自注意力机制（SA），增强了长距离依赖关系的建模能力，并有效地捕获了图像语义信息的整体图像语义信息，使其成为图像分割等密集预测任务的理想选择。因此，最近的进展可以分为两类。一方面，结合CNN和ViT的混合结构越来越受欢迎。例如，UCTransNet（Wang等，2022a）用CTrans模块替换了UNet中的跳过连接，缓解了编码器和解码器之间不兼容特征的问题。MT-UNet（Wang等，2022c）在浅层使用CNN，在深层使用局部全局SA和外部注意力机制，以获得更丰富的表示信息。另一方面，一些研究利用了纯ViT，如Swin-UNet（Cao等，2021），它用Swin Transformer Block替换了U-Net中的卷积操作，并取得了优越的结果。
尽管上述模型在医学图像领域或其他视觉领域（Xiang等，2022，2023b）取得了显著的成果，但它们主要集中在空间域上，并且缺乏从频率域角度研究医学图像分割（MIS）的研究。在一般的计算机视觉中，已经在频率域中展示了特征提取是一种强大的方法（Zhong等，2022；Rao等，2021）。例如，GFNet（Rao等，2021）利用二维离散傅里叶变换（2D DFT）将特征从空间域转换为频率域，并在频率域中使用滤波器进行学习表示。对于MIS，许多病理区域在空间域中很难提取，而在频率域中更容易提取（Huang等，2021）。然而，之前的方法仅在单个轴上提取频率域信息，导致某些信号仍然难以区分，这可以通过图1进行解释。在图1（a）中，从空间域的角度来看，很难从视觉上区分这三个区域。相比之下，图1（b）显示了三个区域在频率域中的信号强度，揭示了它们之间信号强度相对明显的差异。然而，在仅对单个轴（高度-宽度轴）使用DFT的情况下，绿色和红色曲线之间仍存在一些信号强度交集。通过同时考虑三个轴的频率域信号强度（如图1（c）所示），很明显三条曲线之间没有信号强度交集。受此观察的启发，我们提出使用多轴方法提取和融合特征。
基于上述发现，我们提出了多轴外部权重机制（MEW），它可以同时捕获更全面的全局和局部信息。具体来说，特征图沿通道维度被分为四个分支。对于前三个分支，特征通过沿三个不同轴（高度-宽度、通道-宽度和通道-高度轴）的二维离散傅里叶变换（2D DFT）转换为频率域。随后，使用相应的可学习权重乘以频率域映射，以获得频率域信息和全局知识。此外，对于剩下的分支，使用深度分离卷积操作（DW convolution operation）来获取局部信息。此后，MEW通过替换SA模块集成到ViT中，形成多轴外部权重块（MEWB）。最后，基于MEWB和U-shape架构，提出了一个强大的医学图像分割网络，称为MEW-UNet。
为此，我们工作的主要贡献可以总结如下：
提出了多轴外部权重块（MEW），以同时获取全局和局部信息，并引入频率域特征信号，更有效地理解上下文。
基于U-shape和ViT的结构，我们将ViT中的自注意力块替换为我们提出的块，从而构建了一个强大的医学图像分割模型，称为MEW-UNet。
在四个数据集上进行了全面实验，并获得了最佳结果，证明了我们的方法的有效性。
本文其余部分的结构如下。在第2节中，我们介绍了与医学图像分割和基于ViT的技术的相关研究，然后简要介绍了我们的方法。在第3节中，我们介绍了基于U-shape架构的多轴外部权重UNet的细节。在第4节中，我们对提出的方法进行了与当前最佳方法的全面比较和评估，并对所提出的方法进行了全面分析。最后，第5节提供了本文的结论和对未来工作的讨论。
2、相关研究 2.1、医学图像分割 本质上，医学图像处理在疾病诊断方面要求极高精度（Chen等，2023）。在医学成像中，分割是指像素级或体素级的分割。一般来说，多细胞和器官之间的边界在图像上很难区分。
首先，很多研究集中于分割过程。这些方法克服了常规医学分割技术在各种限制。然而，没有一种策略被认为对不同类型的图像来说是更好的技术；这些技术只适用于特定图像和其他应用（Xiang等，2023d）。
其次，医学图像是从各种医疗设备获取的，这些设备和CT/MR3机器的标注或性能标准并不统一。因此，与深度学习相关的训练模型只适用于特定场景（Xiang等，2023c）。同时，泛化能力较弱的深度网络可能容易从分析的医学图像中捕获错误的特征。此外，负样本和正样本的大小之间总是存在显著的不平等，这可能对分割产生更大的影响。然而，U-Net提供了一种方法，可以在减少过度拟合问题上取得更好的性能。
2.2、基于ViT的技术 Transformer模型（Dosovitskiy等，2020b）完全依赖于自注意力机制来构建长距离依赖关系，这在几乎所有的自然语言处理任务中都取得了巨大的成功（Gao等，2023）。Vision Transformer（ViT）（Xiang等，2023a）是较早将Transformer模型引入视觉任务的尝试之一，它采用纯Transformer架构对非重叠的图像块进行图像分类，并取得了最先进的准确度。由于ViT模型在捕获空间信息方面表现出色，它们也被扩展到更具挑战性的任务中，包括动作检测（Li等，2023）、图像检索（Xiang等，2020）和分割（You等，2023）。例如，UCTransNet（Wang等，2022b）用通道Transformer（CTrans）模块替换了跳过连接。Karimi等（Karimi等，2021）通过修改视觉变换器的MHSA机制，在相邻图像块之间应用了自注意力。尽管在多个图像分割任务中表现出色，但视觉变换器仍然存在计算负载过大的问题，这一问题尚未解决。
为了解决这个问题，在这项工作中，我们首次尝试利用频率域信息来提高医学图像分割任务的性能。据我们所知，这是首次尝试利用多轴外部权重机制（MEW），可以同时捕获更全面的全局和局部信息。我们希望这项工作能为医学图像领域潜在的任务提供新的思路。
3、我们的方法 3.1、准备工作 医学图像分割问题通常可以表述为优化一个适当定义的目标函数的问题。目标函数通常是复杂的、多模态的、不连续的，并且不能用可以解析求解的封闭数学形式来描述。在这项工作中，我们做出了新的尝试，并提出了一个用于全局和局部信息的全新多轴外部权重块。在此基础上，引入了频率域特征信号，以帮助模型充分理解上下文。总的来说，本文的目标是利用频率域信息来学习用于下游医学图像分割任务的鉴别性嵌入。图2展示了所提出架构的概述。
3.2、多轴外部权重块 在医学图像分割中，最近的方法主要集中在获取空间域的信息，而忽略了频率域的重要性。在空间域中，分割对象和背景之间的边界往往是模糊的，而在频率域中，对象位于不同的频率上，可以很容易地区分出来（Huang等，2021）。虽然利用频率域的想法在之前的作品中已经介绍过（Huang等，2021）和（Rao等，2021），但在单个轴上提取频率域特征阻止了模型进一步清晰地区分分割边界，导致性能下降。因此，我们提出了基于不同轴的2D DFT的MEW，以获取更全面的频率域信息，如图2（b）所示。
考虑一个输入特征图 X ∈ R C × H × W X \in \mathbb{R}^{C \times H \times W} X∈RC×H×W，其中 C C C、 H H H和 W W W分别表示图的通道、高度和宽度。 X X X首先沿着通道维度被分为四个相等的部分，然后被送入四个不同的分支。MEW机制由式1至式4表示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a0c7bfde969e373d09415bb89b7bc78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7801f8514837460b6a4e29c8c80c4299/" rel="bookmark">
			微信小程序：flex常用布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们平时微信小程序开发过程中为了页面能达到设计小伙伴的预期，追求还原度，那我们肯定会使用很多常用的布局方式，那我们今天就介绍一下微信小程序中常用的一些flex布局
1、常用flex布局 /** 水平垂直居中 **/ .flex-center { display: flex; justify-content: center; align-items: center; } /** 纵向依次排列 **/ .direction-column { flex-direction: column; } /** 平分，一左一右排列 **/ .flex-between { display: flex; justify-content: space-between; align-items: center; } /** 从左往右垂直居中依次排列 **/ .flex-start { display: flex; justify-content: flex-start; align-items: center; } /** 从右往左垂直居中依次排列 **/ .flex-end { display: flex; justify-content: flex-end; align-items: center; } /** 从左往右依次排列，底部(基线)对齐 **/ .flex-start-base { display: flex; justify-content: flex-start; align-items: baseline; } 2、其它布局 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7801f8514837460b6a4e29c8c80c4299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4ca4508bb55393623d8758db0beae03/" rel="bookmark">
			轻松掌握NVM安装与使用：提升Node.js管理效率的实用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是NVM二、NVM命令三、安装NVM⛅下载node版本并进行配置 四、NVM镜像切换⛵小结 一、什么是NVM nvm全英文也叫node.js version management，是一个nodejs的版本管理工具。nvm和n都是node.js版本管理工具，为了解决node.js各种版本存在不兼容现象可以通过它可以安装和切换不同版本的node.js。
下载NVM
可在点此在github上下载最新版本,本次下载安装的是windows版本。目前最新版本v1.1.10,更新日期：2022-11-01。
下载链接：nvm 1.1.10-setup.zip网盘链接：nvm 1.1.10-setup.zip 二、NVM命令 nvm arch：显示node是运行在32位还是64位。nvm install &lt;version&gt; [arch] ：安装node， version是特定版本也可以是最新稳定版本latest。可选参数arch指定安装32位还是64位版本，默认是系统位数。可以添加–insecure绕过远程服务器的SSL。nvm list [available] ：显示已安装的列表。可选参数available，显示可安装的所有版本。list可简化为ls。nvm on ：开启node.js版本管理。nvm off ：关闭node.js版本管理。nvm proxy [url] ：设置下载代理。不加可选参数url，显示当前代理。将url设置为none则移除代理。nvm node_mirror [url] ：设置node镜像。默认是https://nodejs.org/dist/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。nvm npm_mirror [url] ：设置npm镜像。https://github.com/npm/cli/archive/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。nvm uninstall &lt;version&gt; ：卸载指定版本node。nvm use [version] [arch] ：使用制定版本node。可指定32/64位。nvm root [path] ：设置存储不同版本node的目录。如果未设置，默认使用当前目录。nvm version ：显示nvm版本。version可简化为v。 三、安装NVM nvm官网：https://nvm.uihtm.com/
下载完毕文件后，双击打开，弹出以下界面
点击同意，下一步即可
这里选择node存放的地址，建议新建个地址，并指向新建的文件夹
接下来就是等着安装完成，输入nvm进行测试，弹出以下版本信息即可安装成功！
⛅下载node版本并进行配置 配置本地淘宝镜像，这样下载node会快一些
下载 指定版本node
下载成功后，使用
查看安装的node列表
查看当前Node版本
四、NVM镜像切换 命令行切换(注意：请切换国内镜像后再安装node版本，否则会很慢)
阿里云镜像
nvm npm_mirror https://npmmirror.com/mirrors/npm/ nvm node_mirror https://npmmirror.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4ca4508bb55393623d8758db0beae03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ab461a0f3d8c2b5e11d612e5508617b/" rel="bookmark">
			深度学习 Day24——J3-1DenseNet算法实战与解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍨 本文为🔗365天深度学习训练营 中的学习记录博客🍖 原作者：K同学啊 | 接辅导、项目定制🚀 文章来源：K同学的学习圈子 文章目录 前言1 我的环境2 pytorch实现DenseNet算法2.1 前期准备2.1.1 引入库2.1.2 设置GPU（如果设备上支持GPU就使用GPU,否则使用CPU）2.1.3 导入数据2.1.4 可视化数据2.1.4 图像数据变换2.1.4 划分数据集2.1.4 加载数据2.1.4 查看数据 2.2 搭建densenet121模型2.3 训练模型2.3.1 设置超参数2.3.2 编写训练函数2.3.3 编写测试函数2.3.4 正式训练 2.4 结果可视化2.4 指定图片进行预测2.6 模型评估 3 知识点详解3.1 nn.Sequential和nn.Module区别与选择3.1.1 nn.Sequential3.1.2 nn.Module3.1.3 对比3.1.4 总结 3.2 python中OrderedDict的使用 总结 前言 关键字： pytorch实现DenseNet算法，nn.Sequential和nn.Module区别与选择，python中OrderedDict的使用
1 我的环境 电脑系统：Windows 11语言环境：python 3.8.6编译器：pycharm2020.2.3深度学习环境：
torch == 1.9.1+cu111
torchvision == 0.10.1+cu111
TensorFlow 2.10.1显卡：NVIDIA GeForce RTX 4070 2 pytorch实现DenseNet算法 2.1 前期准备 2.1.1 引入库 import torch import torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ab461a0f3d8c2b5e11d612e5508617b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b1b02c4bb4ece7e67c56bfab6aa670/" rel="bookmark">
			如何借助于AI自研一款换脸app
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景涉及的关键技术解析技术流程详解后续待补充 背景 在当今的数字时代，人工智能（AI）技术已经深入到各个领域，其中之一就是换脸技术。现在，有一个免费的AI换脸应用程序，可以让用户轻松地将自己的脸型与明星、朋友或者任何其他人的脸型进行交换，创造出独特的视觉效果。
这个免费的AI换脸应用程序利用了最先进的人工智能技术，包括深度学习和神经网络，能够准确地识别和复制人脸部的各种细节，包括表情、角度和光照等。用户只需要打开应用程序，上传一张自己的照片，然后选择想要换脸的目标照片，程序就会自动将用户的脸型与目标照片的脸型进行融合，生成一张独特的照片。
这个应用程序不仅提供了娱乐和创意的元素，还可以用于一些实际的应用场景。例如，它可以帮助人们更好地了解不同人种或地区的脸部特征和表情，促进跨文化交流和理解。此外，它还可以用于制作虚拟现实（VR）游戏或电影中的角色模型，以及为演员提供面部捕捉技术，帮助他们更好地塑造角色形象。
总之，这个免费的AI换脸应用程序是一个有趣、实用的工具，可以帮助用户探索自己和他人的脸部特征和表情，创造出独特的视觉效果。无论你是想和朋友分享欢乐时光，还是想在虚拟现实世界中探索不同的角色形象，这个应用程序都是一个值得一试的选择。
涉及的关键技术解析 AI换脸App是一个结合了多种先进技术的应用程序。以下是该App可能涉及的一些关键技术：
深度学习与神经网络：这是AI换脸App的核心技术。深度学习模型（如卷积神经网络CNN）被用来学习和理解输入图像中的人脸特征，包括面部形状、肤色、纹理、细微特征等。这些模型通过大量的训练数据来“学习”如何识别和复制人脸部的各种细节。
人脸检测与对齐：在AI换脸过程中，首先需要准确地检测和定位输入图像中的人脸位置。这通常涉及到人脸检测算法，如Haar Cascades或深度学习模型（如MTCNN）。检测到人脸后，还需要进行对齐操作，确保人脸的位置和角度是正确的，以便后续的换脸操作。
特征提取与映射：在获取到人脸图像后，AI换脸App需要从输入图像中提取出人脸的特征，并与目标图像中的人脸特征进行匹配。这涉及到特征提取和映射技术，如主成分分析（PCA）、线性判别分析（LDA）等。
图像合成与融合：在提取出人脸特征后，AI换脸App需要将这些特征应用到目标图像上，生成最终的换脸结果。这涉及到图像合成与融合技术，如图像混合、边缘平滑等。
实时优化与反馈：为了提供更好的用户体验，AI换脸App还需要具备实时优化的能力，根据用户的反馈和需求，不断调整和优化换脸效果。这涉及到机器学习中的在线学习技术。
隐私与安全：在处理用户的人脸图像时，AI换脸App需要严格遵守隐私和安全规定，确保用户数据不被滥用或泄露。这涉及到数据加密、访问控制、审计等安全措施。
综上所述，AI换脸App是一个结合了深度学习、人脸检测、特征提取、图像合成等多种技术的复杂应用。它为用户提供了一个有趣、创意的平台，同时也面临着数据隐私和安全等方面的挑战。
技术流程详解 AI换脸技术是一种基于人工智能的图像处理技术，能够将一个人的面部特征和表情以及动作，替换到另一个人的面部上，实现头像的换脸效果。以下是使用AI换脸技术的详细流程：
人脸检测：这是AI换脸技术的第一步，通过人脸检测算法来识别输入图像中的人脸位置。这一步的关键在于准确快速地检测出人脸的位置和轮廓，以便后续步骤能够顺利进行。
人脸对齐：在人脸检测的基础上，系统会通过人脸对齐算法对输入图像和目标图像中的人脸进行对齐处理，以确保两张人脸的特征点位置一致。这一步的目的是为了消除不同人脸之间的差异，使换脸过程更加准确和自然。
特征提取：利用深度学习模型对输入图像和目标图像中的人脸进行特征提取，包括面部的各种细节特征、表情、姿态、光照等。这些特征将被用于后续的换脸过程中，确保生成的面部与目标图像中的面部特征相匹配。
特征融合：将输入图像中的人脸特征与目标图像中的其他特征进行融合，生成一个新的图像。这一步的关键在于实现自然、无缝的融合效果，使生成的面部看起来真实可信。
图像渲染：将生成的新图像进行渲染，使其与目标图像的背景、光照等环境相匹配。这一步是为了提高生成图像的逼真度，使其更加符合目标图像的场景和氛围。
实时优化与反馈：在换脸过程中，会根据用户的反馈和需求，不断调整和优化换脸效果。这可以通过实时优化算法来实现，根据用户的反馈和需求，自动调整模型参数和算法设置，以提供更加个性化、精准的换脸效果。
后续待补充 可以先体验体验呀，直接扫描二维码安装哈（安卓和ios均可）：https://72portrait.com/share72.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e7da6defa2e93c8dbb9999f924dfe6c/" rel="bookmark">
			前端怎么定位到发生错误的元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前端开发中，可以使用以下方法定位到发生错误的元素：
使用浏览器的开发者工具：现代浏览器都提供了开发者工具，可以方便地进行页面调试和错误定位。在开发者工具的控制台中，可以查看页面的错误信息和警告信息，同时还可以查看页面的 DOM 结构和 CSS 样式，从而定位到发生错误的元素。使用调试工具：在开发过程中，可以使用调试工具，如 Vue Devtools、React Devtools 等，可以方便地进行 Vue、React 等框架的调试和错误定位。这些调试工具通常提供了组件树、状态变量和事件监听器等详细信息，可以帮助开发者更准确地定位到发生错误的组件或元素。使用日志输出：在代码中加入日志输出语句，可以记录页面的关键操作和变量信息，从而帮助开发者更准确地定位到发生错误的位置。日志输出通常包括时间戳、操作名称、变量值等信息，可以在控制台或者其他工具中进行查看和分析。使用第三方错误追踪工具：可以使用第三方错误追踪工具，如 Sentry、Bugsnag 等，可以帮助开发者自动捕获和分析页面的错误信息，并提供详细的报告和分析结果，从而帮助开发者快速定位和解决问题。 总之，在前端开发中，定位到发生错误的元素需要结合多种方法和工具进行分析和定位，通过多次尝试和调试，找到准确的问题所在，并采取相应的措施进行解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d262fa61cb124cfd748fddef2aa84b7b/" rel="bookmark">
			计算机毕业设计 基于Java的供应商管理系统的设计与实现 Java实战项目 附源码&#43;文档&#43;视频讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌从事软件开发10年之余，专注于Java技术领域、Python人工智能及数据挖掘、小程序项目开发和Android项目开发等。CSDN、掘金、华为云、InfoQ、阿里云等平台优质作者✌
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
————————————————
计算机毕业设计《1000套》✌
目录
1、项目介绍及开发技术
1.1 项目介绍
1.2 开发技术
2、系统功能设计结构图
3、功能截图
4、数据库表结构设计
5、关键代码
5.1 供应商信息Controller模块 5.2 供应商信息Service模块 5.3 供应商信息ServiceImpl模块
5.4 供应商信息Dao模块
6、论文目录结构
7、源码获取
1、项目介绍及开发技术 1.1 项目介绍 近年来，信息化管理行业的不断兴起，使得人们的日常生活越来越离不开计算机和互联网技术。首先，根据收集到的用户需求分析，对设计系统有一个初步的认识与了解，确定供应商管理系统的总体功能模块。然后，详细设计系统的主要功能模块，通过数据库设计过程将相关的数据信息存储到数据库中，再通过使用关键的开发工具，如IDEA开发平台、AJAX技术等，编码设计相关的功能模块。接着，主要采用功能测试的方式对系统进行测试，找出系统在运行过程中存在的问题，以及解决问题的方法，不断地改进和完善系统的设计。最后，总结本文介绍的系统的设计和实现过程，并且针对于系统的开发提出未来的展望工作。本系统的研发具有重大的意义，在安全性方面，用户使用浏览器访问网站时，采用注册和密码等相关的保护措施，提高系统的可靠性，维护用户的个人信息和财产的安全。在方便性方面，促进了供应商管理系统的信息化建设，极大的方便了相关的工作人员对供应商管理系统信息进行管理。
1.2 开发技术 Java开发语言、SpringBoot、MyBatisPlus、MySQL数据库、Maven、IDEA开发工具、JDK1.8+、Vue、HTML、CSS、JS。
2、系统功能设计结构图 3、功能截图 管理员可以选择任一浏览器打开网址，输入信息无误后，以管理员的身份行使相关的管理权限。
商品管理：管理员可以通过选择商品管理，管理相关的商品信息记录，比如进行查看商品信息标题，修改商品信息来源等操作。
公告管理： 管理员可以通过选择公告管理，管理相关的公告信息记录，比如进行查看公告详情,删除错误的公告信息,发布公告等操作。
公告类型管理：管理员可以通过选择公告类型管理，管理相关的公告类型信息，比如查看所有公告类型,删除无用公告类型,修改公告类型,添加公告类型等操作。
供应商管理: 新增供应商,修改供应商,删除供应商。
供应商类型管理： 新增供应商类型,修改供应商类型,删除供应商类型。
4、数据库表结构设计 CREATE DATABASE /*!32312 IF NOT EXISTS*/`gongyingshang` /*!40100 DEFAULT CHARACTER SET utf8 */; USE `gongyingshang`; /*Table structure for table `config` */ DROP TABLE IF EXISTS `config`; CREATE TABLE `config` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `name` varchar(100) DEFAULT NULL COMMENT '配置参数名称', `value` varchar(100) DEFAULT NULL COMMENT '配置参数值', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='配置文件'; /*Data for the table `config` */ /*Table structure for table `dictionary` */ DROP TABLE IF EXISTS `dictionary`; CREATE TABLE `dictionary` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `dic_code` varchar(200) DEFAULT NULL COMMENT '字段', `dic_name` varchar(200) DEFAULT NULL COMMENT '字段名', `code_index` int(11) DEFAULT NULL COMMENT '编码', `index_name` varchar(200) DEFAULT NULL COMMENT '编码名字 Search111 ', `super_id` int(11) DEFAULT NULL COMMENT '父字段id', `beizhu` varchar(200) DEFAULT NULL COMMENT '备注', `create_time` timestamp NULL DEFAULT NULL COMMENT '创建时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8 COMMENT='字典'; /*Data for the table `dictionary` */ insert into `dictionary`(`id`,`dic_code`,`dic_name`,`code_index`,`index_name`,`super_id`,`beizhu`,`create_time`) values (1,'sex_types','性别类型',1,'男',NULL,NULL,'2023-04-06 16:50:52'),(2,'sex_types','性别类型',2,'女',NULL,NULL,'2023-04-06 16:50:52'),(3,'jinyong_types','账户状态',1,'启用',NULL,NULL,'2023-04-06 16:50:52'),(4,'jinyong_types','账户状态',2,'禁用',NULL,NULL,'2023-04-06 16:50:52'),(5,'gongyingshang_types','供应商类型',1,'供应商类型1',NULL,NULL,'2023-04-06 16:50:53'),(6,'gongyingshang_types','供应商类型',2,'供应商类型2',NULL,NULL,'2023-04-06 16:50:53'),(7,'gongyingshang_xinyongdengji_types','供应商信用等级类型',1,'一级',NULL,NULL,'2023-04-06 16:50:53'),(8,'gongyingshang_xinyongdengji_types','供应商信用等级类型',2,'二级',NULL,NULL,'2023-04-06 16:50:53'),(9,'gongyingshang_xinyongdengji_types','供应商信用等级类型',3,'三级',NULL,NULL,'2023-04-06 16:50:53'),(10,'shangpin_types','商品类型',1,'水果',NULL,NULL,'2023-04-06 16:50:53'),(11,'shangpin_types','商品类型',2,'生活用品',NULL,NULL,'2023-04-06 16:50:53'),(12,'shangpin_erji_types','二级类型',1,'香蕉',1,NULL,'2023-04-06 16:50:53'),(13,'shangpin_erji_types','二级类型',2,'苹果',1,NULL,'2023-04-06 16:50:53'),(14,'shangpin_erji_types','二级类型',3,'卫生纸',2,NULL,'2023-04-06 16:50:53'),(15,'shangpin_erji_types','二级类型',4,'笔记本',2,NULL,'2023-04-06 16:50:53'),(16,'shangpin_churu_inout_types','出入库类型',1,'出库',NULL,NULL,'2023-04-06 16:50:53'),(17,'shangpin_churu_inout_types','出入库类型',2,'入库',NULL,NULL,'2023-04-06 16:50:53'),(18,'gonggao_types','公告类型',1,'公告类型1',NULL,NULL,'2023-04-06 16:50:53'),(19,'gonggao_types','公告类型',2,'公告类型2',NULL,NULL,'2023-04-06 16:50:53'),(20,'jinhuodan_types','进货类型',1,'进货类型1',NULL,NULL,'2023-04-06 16:50:53'),(21,'jinhuodan_types','进货类型',2,'进货类型2',NULL,NULL,'2023-04-06 16:50:53'),(22,'tuihuodan_types','退货类型',1,'退货类型1',NULL,NULL,'2023-04-06 16:50:53'),(23,'tuihuodan_types','退货类型',2,'退货类型2',NULL,NULL,'2023-04-06 16:50:53'),(24,'tuihuodan_types','退货类型',3,'退货类型3',NULL,'','2023-04-06 17:15:48'),(25,'shangpin_erji_types','二级类型',5,'碗',2,'','2023-04-06 17:16:13'); /*Table structure for table `gonggao` */ DROP TABLE IF EXISTS `gonggao`; CREATE TABLE `gonggao` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键 ', `gonggao_name` varchar(200) DEFAULT NULL COMMENT '公告名称 Search111 ', `gonggao_types` int(11) NOT NULL COMMENT '公告类型 Search111 ', `insert_time` timestamp NULL DEFAULT NULL COMMENT '发布时间', `gonggao_content` longtext COMMENT '公告详情 ', `create_time` timestamp NULL DEFAULT NULL COMMENT '创建时间 show1 show2 nameShow', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8 COMMENT='公告'; /*Data for the table `gonggao` */ insert into `gonggao`(`id`,`gonggao_name`,`gonggao_types`,`insert_time`,`gonggao_content`,`create_time`) values (1,'公告名称1',2,'2023-04-06 16:51:02','公告详情1','2023-04-06 16:51:02'),(2,'公告名称2',2,'2023-04-06 16:51:02','公告详情2','2023-04-06 16:51:02'),(3,'公告名称3',1,'2023-04-06 16:51:02','公告详情3','2023-04-06 16:51:02'),(4,'公告名称4',2,'2023-04-06 16:51:02','公告详情4','2023-04-06 16:51:02'),(5,'公告名称5',1,'2023-04-06 16:51:02','公告详情5','2023-04-06 16:51:02'),(6,'公告名称6',2,'2023-04-06 16:51:02','公告详情6','2023-04-06 16:51:02'),(7,'公告名称7',1,'2023-04-06 16:51:02','公告详情7','2023-04-06 16:51:02'),(8,'公告名称8',2,'2023-04-06 16:51:02','公告详情8','2023-04-06 16:51:02'),(9,'公告名称9',1,'2023-04-06 16:51:02','公告详情9','2023-04-06 16:51:02'),(10,'公告名称10',1,'2023-04-06 16:51:02','公告详情10','2023-04-06 16:51:02'),(11,'公告名称11',2,'2023-04-06 16:51:02','公告详情11','2023-04-06 16:51:02'),(12,'公告名称12',1,'2023-04-06 16:51:02','公告详情12','2023-04-06 16:51:02'),(13,'公告名称13',1,'2023-04-06 16:51:02','公告详情13','2023-04-06 16:51:02'),(14,'公告名称14',2,'2023-04-06 16:51:02','公告详情14','2023-04-06 16:51:02'); /*Table structure for table `gongyingshang` */ DROP TABLE IF EXISTS `gongyingshang`; CREATE TABLE `gongyingshang` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键 ', `gongyingshang_uuid_number` varchar(200) DEFAULT NULL COMMENT '供应商唯一编号', `gongyingshang_name` varchar(200) DEFAULT NULL COMMENT '供应商名称 Search111 ', `lianxiren_name` varchar(200) DEFAULT NULL COMMENT '联系人姓名 Search111 ', `lianxiren_phone` varchar(200) DEFAULT NULL COMMENT '联系人手机号', `lianxiren_address` varchar(200) DEFAULT NULL COMMENT '地址', `gongyingshang_types` int(11) DEFAULT NULL COMMENT '供应商类型', `gongyingshang_xinyongdengji_types` int(11) DEFAULT NULL COMMENT '信用等级 Search111 ', `gongyingshang_content` longtext COMMENT '供应商详情', `create_time` timestamp NULL DEFAULT NULL COMMENT '创建时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8 COMMENT='供应商信息'; /*Data for the table `gongyingshang` */ insert into `gongyingshang`(`id`,`gongyingshang_uuid_number`,`gongyingshang_name`,`lianxiren_name`,`lianxiren_phone`,`lianxiren_address`,`gongyingshang_types`,`gongyingshang_xinyongdengji_types`,`gongyingshang_content`,`create_time`) values (1,'1680771062428','供应商名称1','联系人姓名1','17703786901','地址1',2,3,'供应商详情1','2023-04-06 16:51:02'),(2,'1680771062433','供应商名称2','联系人姓名2','17703786902','地址2',1,1,'供应商详情2','2023-04-06 16:51:02'),(3,'1680771062435','供应商名称3','联系人姓名3','17703786903','地址3',2,2,'供应商详情3','2023-04-06 16:51:02'),(4,'1680771062435','供应商名称4','联系人姓名4','17703786904','地址4',2,1,'供应商详情4','2023-04-06 16:51:02'),(5,'1680771062453','供应商名称5','联系人姓名5','17703786905','地址5',1,2,'供应商详情5','2023-04-06 16:51:02'),(6,'1680771062429','供应商名称6','联系人姓名6','17703786906','地址6',2,3,'供应商详情6','2023-04-06 16:51:02'),(7,'1680771062422','供应商名称7','联系人姓名7','17703786907','地址7',2,2,'供应商详情7','2023-04-06 16:51:02'),(8,'1680771062444','供应商名称8','联系人姓名8','17703786908','地址8',1,2,'供应商详情8','2023-04-06 16:51:02'),(9,'1680771062421','供应商名称9','联系人姓名9','17703786909','地址9',2,2,'供应商详情9','2023-04-06 16:51:02'),(10,'1680771062412','供应商名称10','联系人姓名10','17703786910','地址10',2,3,'供应商详情10','2023-04-06 16:51:02'),(11,'1680771062480','供应商名称11','联系人姓名11','17703786911','地址11',2,2,'供应商详情11','2023-04-06 16:51:02'),(12,'1680771062384','供应商名称12','联系人姓名12','17703786912','地址12',1,3,'供应商详情12','2023-04-06 16:51:02'),(13,'1680771062406','供应商名称13','联系人姓名13','17703786913','地址13',1,1,'供应商详情13','2023-04-06 16:51:02'),(14,'1680771062435','供应商名称14','联系人姓名14','17703786914','地址14',2,2,'&lt;p&gt;供应商详情14个搭嘎第三个&lt;/p&gt;','2023-04-06 16:51:02'); /*Table structure for table `jinhuodan` */ DROP TABLE IF EXISTS `jinhuodan`; CREATE TABLE `jinhuodan` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键 ', `yuangong_id` int(11) DEFAULT NULL COMMENT '员工', `gongyingshang_id` int(11) DEFAULT NULL COMMENT '供应商', `jinhuodan_uuid_number` varchar(200) DEFAULT NULL COMMENT '进货单编号', `jinhuodan_name` varchar(200) DEFAULT NULL COMMENT '进货单名称 Search111 ', `jinhuodan_file` varchar(200) DEFAULT NULL COMMENT '进货单', `jinhuodan_types` int(11) DEFAULT NULL COMMENT '进货类型 Search111', `caozuo_time` timestamp NULL DEFAULT NULL COMMENT '进货时间', `jinhuodan_content` longtext COMMENT '进货单内容', `jinhuodan_beizhu_content` longtext COMMENT '备注', `insert_time` timestamp NULL DEFAULT NULL COMMENT '录入时间', `create_time` timestamp NULL DEFAULT NULL COMMENT '创建时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8 COMMENT='商品进货'; /*Data for the table `jinhuodan` */ insert into `jinhuodan`(`id`,`yuangong_id`,`gongyingshang_id`,`jinhuodan_uuid_number`,`jinhuodan_name`,`jinhuodan_file`,`jinhuodan_types`,`caozuo_time`,`jinhuodan_content`,`jinhuodan_beizhu_content`,`insert_time`,`create_time`) values (1,1,1,'1680771062420','进货单名称1','upload/file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d262fa61cb124cfd748fddef2aa84b7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2918c6a9868727655fe1588700e1baff/" rel="bookmark">
			16.Linux Bash Shell通过`read`命令读取用户输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux Shell获取用户输入处理简单输入控制等待隐藏输入从文件中读取 欢迎访问个人网络日志🌹🌹知行空间🌹🌹
Linux Shell获取用户输入 处理简单输入 shell与用户交互式输入使用的是read命令，一个简单的例子：
#!/bin/bash echo "Please Input Your Name: " read name echo "The Input Name Is $name" 执行，
bash test.sh # Please Input Your Name: # Lee # The Input Name Is Lee read命令本身支持多种选项，使用-p选项可以将输入提示符"Please Input Your Name: "放到read命令那一行：
#!/bin/bash echo read -p "Please Input Your Name: " name echo "The Input Name Is $name" 这样输入和提示符就都放在同一行了，
执行，
bash test.sh # Please Input Your Name: Job Lee # The Input Name Is Job Lee 不过从上面的输入可以看到，Job Lee被解析成了一个值，虽然中间有空格。这是因为read命令后面只有一个变量接收参数，如果期望接收多个参数，就在read命令后面多放几个变量即可，如果输入的参数比接收的变量多，那么多余的参数都会被放在最后一个变量中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2918c6a9868727655fe1588700e1baff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa613db33845e063dfaf9a116634e61e/" rel="bookmark">
			MySQL：约束&amp;主键&amp;唯一键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表的约束：表中一定有约束，通过约束让插入表中的数据是符号预期的
约束的本质是通过技术手段，倒逼程序员插入正确的数据
Null约束 这里的Null表示在插入的时候，该属性能否为空，如果是NO，则插入时候必须有数据
create table t1(
id int not null
);
该语句显示出来就是NO default约束 create table t1(
id int not null
age tinyint default 18,
);
insert into t1 (id) values (‘张三’);
id不能插null，age可以插null，如果插入时候省略age，默认age是18
not null default，default不为空就行
列描述 create table t1(
id int not null comment ‘用户id号’
age tinyint default 18,
);
这就是一个单纯的注释
zerofill 上图中，int括号中的数字是11，并且有zerofill修饰时，存储某个数的长度不够11位就用0填充
int最大取值范围是21亿多，共10位，另一位是符号位
主键 一张表有一列信息标定数据的唯一性
主键只有一个，要么没有
一个主键可以被添加到一列，或者多列上
primary key修饰
alter table 表名 add primary key (字段)
alter table 表名 drop primary key
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa613db33845e063dfaf9a116634e61e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d59918f3701f2a5650b6c47397a61679/" rel="bookmark">
			（二）STM32F407 cubemx按键点灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（二）STM32F407 cubemx按键点灯 这篇文章主要是个人的学习经验，想分享出来供大家提供思路，如果其中有不足之处请批评指正哈。 废话不多说直接开始主题，本人是基于STM32F407VET6芯片，但是意在你看懂这篇文章后，不管是F1,F4,H7等一系列系统点灯按键配置都能明白如何通过参考手册去学习配置。而不是Ctrl c，Ctrl v。
首先要明白一个知识点，led灯、按键需要用到什么，引脚输出功能，引脚读取功能？这些功能具体到底是什么？
数据手册内容 1.首先我得看看我F407开发板的原理图，我发现我的开发板电流是涌入电流（injected current）PC13，PC13需要拉低才能点亮LED。
总注入电流(所有I/O和控制引脚之和)，F407涌入的电流之和不能大于25mA，3.3V/360Ω=9.1mA满足条件。
输出驱动电流
gpio(通用输入/输出)可以吸收或源高达±8ma，吸收或源高达±20ma(放宽VOL /VOH)，但PC13, PC14和PC15可以吸收或源高达±3mA。PC13 ~ PC15的gpio在输出模式时，速度不能超过2mhz，最大负载30pf。这一部分内容是对于引脚拉高向外输出电流的必要知识点，但说实在的尽量不要用PC13-15去驱动led避免未知的麻烦，但是我这块开发板偏偏就是PC13，改不了了。
参考手册内容 根据原理图，
若是上拉电阻：按键未按下时引脚读取的是VDD高电平1，若按键按下input被短接直接读取GND低电平0，状态有明确对应关系符合要求。
若是下拉电阻：按键未按下时引脚读取电平为GND低电平0，当若按键按下input被短接直接读取GND低电平0，不管按下还是不按都没有变化始终是低电平0。不符合要求。
cubemx配置 时钟配置详见文一。
输入模式根据要求配置成上拉模式，cubemx配置完成。
函数调用 去hal库里面看看有什么函数是可以调用的。
读取引脚函数，读取引脚输入状态，这个函数可以供按键使用。
状态改变函数，可改变输出状态。
go to definition后找到变量出处，SET对应1，RESET对应0。由上图知PC13需要为低电平0才可点亮LED灯，即选择状态为GPIO_PIN_RESET点亮。
toggled切换状态函数，可用于按键按下后翻转当前状态。
基于以上编写主程序。
int main(void) { /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration--------------------------------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init(); /* USER CODE BEGIN Init */ /* USER CODE END Init */ /* Configure the system clock */ SystemClock_Config(); /* USER CODE BEGIN SysInit */ /* USER CODE END SysInit */ /* Initialize all configured peripherals */ MX_GPIO_Init(); /* USER CODE BEGIN 2 */ HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13,GPIO_PIN_SET); //熄灭LED HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13,GPIO_PIN_RESET); //点亮LED /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_15)==0) { HAL_Delay(50); if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_15)==0) { while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_15)==0); //必须松开按键方可进入下一行程序 HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_13); } } } /* USER CODE END 3 */ } 这一步作用是下载完程序之后自动复位，若没有此过程需要人工手动复位。切记下载完程序是需要复位的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d59918f3701f2a5650b6c47397a61679/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f640d5482edc7f91b245d88a980c99a/" rel="bookmark">
			Spring 与 Spring Boot：深入解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring 与 Spring Boot：深入解析 前言:
欢迎来到本篇博客，今天我们将深度挖掘 Java 开发领域的两个主要框架——Spring 和 Spring Boot。尽管它们之间有着紧密的联系，但在某些方面却存在显著的区别。让我们逐步深入，挖掘它们的特性、适用场景以及在实际项目中的运用。
1. 什么是 Spring？
Spring 不仅仅是一个框架，它是一个生态系统，致力于简化企业级应用的开发。提供的功能包括但不限于依赖注入、面向切面编程（AOP）、事务管理等，旨在帮助开发者构建可维护和灵活的应用。
2. 什么是 Spring Boot？
Spring Boot 是 Spring 生态系统的一个子项目，专注于简化 Spring 应用的开发和部署。通过提供约定大于配置的方式，Spring Boot 显著降低了开发者的工作量，使得快速创建独立、基于 Spring 的应用变得轻而易举。
3. 主要区别：
依赖管理：
Spring: 需要手动管理所有项目依赖，包括版本控制。Spring Boot: 提供自动化的依赖管理，通过引入相关的“Starter”简化依赖配置。 配置方式：
Spring: 大量 XML 配置文件，相对繁琐。Spring Boot: 注解和默认配置的使用，极大简化了配置，提高了开发效率。 开发速度：
Spring: 手动配置较多，开发速度相对较慢。Spring Boot: 约定大于配置，快速构建项目，提高了开发效率。 4. 实际案例：
案例1: 使用 Spring 进行数据访问
// Spring 传统方式 @Repository public class UserRepositoryImpl implements UserRepository { @Autowired private JdbcTemplate jdbcTemplate; // 具体实现.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f640d5482edc7f91b245d88a980c99a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e7c0878b601c9b6d0e1890fe9c7e866/" rel="bookmark">
			自动驾驶预测-决策-规划-控制学习（1）：自动驾驶框架、硬件、软件概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言：无人驾驶分级一、不同level的无人驾驶实例分析1.L2级别2.L3级别3.L4级别①如何在减少成本的情况下，实现类似全方位高精度的感知呢？②路侧终归是辅助，主车的智能才是重中之重：融合深度学习 二、无人驾驶的责任问题如何界定量化？三、自动驾驶研究的编程语言①C++:高效、实时性强②Python：开发门槛低、库丰富、易于深度学习③matlab：同python、计算能力强④ROS：机器人操作系统。自动驾驶可以认为是轮式智能机器人，但不同的是，自动驾驶车辆更专注于在道路上进行安全和高效的交通运输，而轮式智能机器人更专注于在室内或特定环境中执行特定任务。所以自动驾驶核心问题是处理数据的运行速度，即实时性。 四、L4自动驾驶系统架构：软件与硬件硬件1 感知传感器：2 定位系统传感器： 软件解决定位中IMU的累计误差的方法： 五、自动驾驶的软件研究问题a、感知（perception）b、预测（Prediction）c、决策与规划d、控制 前言：无人驾驶分级 以下为《汽车驾驶自动化分级》具体标准：
~
0 级驾驶自动化（应急辅助）：
驾驶自动化系统不能持续执行动态驾驶任务中的车辆横向或纵向运动控制，但具备持续执行动 态驾驶任务中的部分目标和事件探测与响应的能力。
需要指出的是，0级驾驶自动化不是无驾驶自动化，0级驾驶自动化可感知环境，并提供报警、辅助或短暂介入以辅助驾驶员（如车道偏离预警、前碰撞预警、自动紧急制动等应急辅助功能）。
此外，不具备目标和事件探测与响应的能力的功能（如:定速巡航、电子稳定性控制等）不在驾驶自动化考虑的范围内。
1 级驾驶自动化（部分驾驶辅助）：
驾驶自动化系统在其设计运行条件内持续地执行动态驾驶任务中的车辆横向或纵向运动控制，且具备与所执行的车辆横向或纵向运动控制相适应的部分目标和事件探测与响应的能力。对于1级驾驶自动化，驾驶员和驾驶自动化系统共同执行动态驾驶任务，并监管驾驶自动化系统的行为和执行适当的响应或操作。
2 级驾驶自动化（组合驾驶辅助）：
驾驶自动化系统在其设计运行条件内持续地执行动态驾驶任务中的车辆横向和纵向运动控制，且具备与所执行的车辆横向和纵向运动控制相适应的部分目标和事件探测与响应的能力。与1级类似的是，对于2级驾驶自动化，驾驶员和驾驶自动化系统也是共同执行动态驾驶任务，并监管驾驶自动化系统的行为和执行适当的响应或操作。
3 级驾驶自动化（有条件自动驾驶）：
驾驶自动化系统在其设计运行条件内持续地执行全部动态驾驶任务。
对于 3 级驾驶自动化，动态驾驶任务接管用户以适当的方式执行动态驾驶任务接管。
4 级驾驶自动化（高度自动驾驶）：
驾驶自动化系统在其设计运行条件内持续地执行全部动态驾驶任务和执行动态驾驶任务接管。
对于 4 级驾驶自动化，系统发出接管请求时，若乘客无响应，系统具备自动达到最小风险状态的能力。
5 级驾驶自动化（完全自动驾驶）：
驾驶自动化系统在任何可行驶条件下持续地执行全部动态驾驶任务和执行动态驾驶任务接管。对于5级驾驶自动化，系统发出接管请求时，乘客无需进行响应，系统具备自动达到最小风险状态的能力。此外，5级驾驶自动化在车辆可行驶环境下没有设计运行条件的限制（商业和法规因素等限制除外）。
`
L0,简单点理解，就是传统的人来驾驶。
L1,巡航定速（adaptive cruise control，ACC），巡航装置可以纵向控制车辆，加速减速；
L2，车道保持辅助（Lane keeping）系统可以纵向控制也可以横向控制汽车，但车市辅助的，人才是主导；
L2.5，可以提供简单路况下的变道能力，如目前的Tesla；
L2和L3之间有一个鸿沟，权责问题（出了事故，谁的责任）；
L3,在L2的基础上提供变道能力，在某一时间段内车是责任主体。如最新款奥迪A8
L4,相当于全无人驾驶，就是大部分时间由车来做主导。如waymo,Baidu；
L5,驾驶能力上，几乎和人类没有关系，l5的车辆没有方向盘以及脚踏板以及其他接管设备。
当前，市场上L4人才需求最高，许多车企都是以这个级别作为目标的。
一、不同level的无人驾驶实例分析 1.L2级别 比如特斯拉，L2的视觉感知技术对应车道线和周边情况的观察效果很好，但是如果是复杂的十字路口，没有车道线的话，视觉方案就会存在弊端。
2.L3级别 L3级别的责任，是奥迪车企负责的，但是要进入自动驾驶状态的条件苛刻，否则仍然认为是手动驾驶。
3.L4级别 激光雷达成本高，开销巨大。但是激光雷达具有视觉不具备的好处，在夜间、雾天等极端天气的感知更加精准。
①如何在减少成本的情况下，实现类似全方位高精度的感知呢？ 车路协同+边缘计算：借助RSU和OBU实现。
–RSU（路侧单元）：比如红绿灯的摄像头确定的斑马线的行人位置信息，传送给无人车；
–OBU（车载单元）：无人车上，接收RSU发送过来的信息模块
车路协同是指车辆与道路基础设施之间的信息交互和协同工作。通过车辆与交通基础设施之间的通信，可以实现实时的交通信息共享、交通管理和智能交通控制。例如，交通信号灯可以根据道路上的车辆流量和拥堵情况进行智能调整，以优化交通流畅度和减少交通拥堵。
边缘计算是一种分布式计算模型，它将计算资源和数据处理能力推向网络的边缘，靠近数据源和终端设备。边缘计算可以在离用户更近的位置进行数据处理和决策，减少数据传输延迟和网络带宽消耗。在车路协同中，边缘计算可以用于处理车辆和道路基础设施之间的通信数据，进行实时的数据分析和决策，以提供更高效的交通管理和服务。
综合起来，车路协同和边缘计算可以结合使用，通过车辆与道路基础设施之间的信息交互和边缘计算的数据处理能力，实现智能交通管理和优化。例如，车辆可以通过边缘计算节点与交通信号灯进行通信，交换交通信息并接收优化的信号灯控制策略，从而实现更顺畅的交通流动。
②路侧终归是辅助，主车的智能才是重中之重：融合深度学习 二、无人驾驶的责任问题如何界定量化？ RSS模型的目的是，为自动驾驶车辆与人类的责任概念提供具体可衡量的参数，并通过对所记录在案的交通数据涉及行为和环境进行分析统计，为自动驾驶汽车界定一个可计量的“安全状态”。如果有了这个规则，软件能偶做出最安全的决策。
三、自动驾驶研究的编程语言 ①C++:高效、实时性强 C++：C++ 是一种高效且功能强大的编程语言，被广泛用于自动驾驶系统的开发。它提供了对硬件的底层访问和控制，适合实现实时的感知、决策和控制算法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e7c0878b601c9b6d0e1890fe9c7e866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c86ab3e94daab6079736ada4a257255/" rel="bookmark">
			shell sshpass 主机交互 在另外一台主机上执行某个命令 批量管理主机 以及一些案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 作用安装 sshpasssshpass 用法在远程主机执行某个命令 案例批量传输密匙批量拷贝文件批量修改密码 作用 就是用一台主机 控制另外一台主机免交互任务管理工具方便批量管理主机使用方法就是在ssh 前边加一个 sshpass 安装 sshpass # 安装 sshpass yum -y install sshpass # 卸载 yum -y reomve sshpass sshpass 用法 #第一次登录时候需要输入yes 执行之后会登录到目标主机 sshpass -p{密码} ssh -p {端口} -o StrictHostKeyChecking=no root@{ip} sshpass -proot ssh -p 22 -o StrictHostKeyChecking=no root@192.168.1.102 在远程主机执行某个命令 #使用sshpass获取ip地址 sshpass -p{密码} shh -p {端口} root@{ip} "{命令}" sshpass -proot ssh root@192.168.1.102 -p 22 "ip a" # 指定文件 echo "passwd" &gt; passwd sshpass -f -p@Baipiao123 ssh root@{123.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c86ab3e94daab6079736ada4a257255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/085b6ba19788c38a7246058a21945f18/" rel="bookmark">
			类和对象及其关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类 类概述：
类是对现实生活中一类具有共同属性和行为事物的抽象 类特点：
1、类是对象的数据类型 2、类是具有相同属性和行为的一组对象的集合 // 类是对象的数据类型 class Student{} class Test{ public static void main(String[] args){ // int a = 20; 类比 Student s = new Student(); } } 类的定义（成员变量 和 成员方法）
1、类的定义，就是 定义成员变量(属性) 定义成员方法(行为) public class Test{ // 成员变量 public int age; private String name; // 成员方法 public void play(){ System.out.println("我正在玩游戏！"); } } 类的使用（创建对象）
格式： 类名 对象名 = new 类名(); 例子： Test t = new Test(); 对象 概念：：对象具有的各种特征
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/085b6ba19788c38a7246058a21945f18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb2b8f464955f6545886ab3c9675f82d/" rel="bookmark">
			推荐一个刚开源很火的Github项目：OpenVoice（即时语音克隆）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主最近在逛Github，发现一个刚推出的Star指数迅速上升的Github开源项目，该项目可实现提取部分语音的片段就可以仿照说话者的特色去生成不同语言，甚至不同情感、口音、韵律、停顿和语调，也就是使用它可以细致地控制语音风格。这个项目是myshell-ai开源的OpenVoice项目。
项目地址：https://github.com/myshell-ai/OpenVoice
仅开源了不到三周，就有了6.1k的star，还是可以的。
OpenVoice除了灵活的语音风格控制外，还实现了零样本跨语言语音克隆，也就是不需要庞大说话者训练集中的语言，与先前的方法不同，先前的方法通常需要为所有语言提供大规模说话者多语言（MSML）数据集，而OpenVoice可以在没有该语言的大规模说话者训练数据的情况下将语音克隆到新语言中，下面是它的功能详细介绍：
We introduce OpenVoice, a versatile voice cloning approach that requires only a short audio clip from the reference speaker to replicate their voice and generate speech in multiple languages. OpenVoice represents a significant advancement in addressing the following open challenges in the field: 1) Flexible Voice Style Control. OpenVoice enables granular control over voice styles, including emotion, accent, rhythm, pauses, and intonation, in addition to replicating the tone color of the reference speaker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb2b8f464955f6545886ab3c9675f82d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f00c13d89639890f278ef5e6df909e4/" rel="bookmark">
			双指针-＞算法实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		综述 移除元素：leetcode27
删除有序数组中的重复项：leetcode26
移动零：leetcode283
有序数组的平方：leetcode977
反转字符串：leetcode344
替换数字：非leetcode原题
反转字符串中的单词：leetcode151
三数之和：leetcode15
四数之和：leetcode18
引言 刷题总结 对于 移除元素，删除有序数组中的重复项，移动零 都是使用的 快慢指针 进行操作的，快慢指针很方便
很多数组填充类的问题，其做法都是先预先给数组扩容到填充后的大小，然后在从后向前进行操作。
比如：替换数字----非leetcode原题
对于 反转字符串中的单词，需要多做几遍，因为代码中的坑很多，不容易 bug free，可能需要多次 debug
三数之和 和 四数之和 经典中的经典，可以多看看
移除元素 题目 leetcode27
题解 暴力：直接移动数组元素进行覆盖，时间复杂度是 O(n^2)
双指针：一个指针从前向后遍历，一个指针从后向前遍历，前向指针遍历到和 val 相等的元素，就和后向指针指向的元素交换，前提是后向指针指向的元素和 val 不相等
class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int j = nums.size() - 1; for (int i = 0; i &lt;= j; i++) { while (nums[j] == val) { //最后一个元素是 val，就 j--，使得交换的时候是 nums[j] 不是 val j--; if (j &lt; 0) return j + 1; //防止减到0导致数组角标越界 } if (i &gt; j) break; //用于遍历到 i==j 时，如果 nums[j]==val，j就--，此时 j &lt; i，如果再进行交换的话就出错了 if (nums[i] == val) { std::swap(nums[i], nums[j]); j--; } } return j + 1; } }; 时间复杂度是 O(n)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f00c13d89639890f278ef5e6df909e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb64cf5737e45f39bea4aeb081d1ec9c/" rel="bookmark">
			node.js安装web3.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步 node.js和npm 首先你需要有node.js和npm
可参考菜鸟教程
第二步 初始化nodejs项目 在项目文件夹打开命令行，输入
npm init -y 此代码意为创建一个nodejs项目，默认配置。
然后安装web3.js，命令行输入安装命令
npm install web3 npm会自动安装web3及其依赖项。
第三步 测试web3安装成功 创建一个main.js文件，如下所示
main.js代码为
const { Web3 } = require('web3'); console.log("Version:",Web3.version); 在命令行中运行代码
node main.js 输出结果如下：
表示安装运行成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cc04866134e5fb3a6ea893070ce6632/" rel="bookmark">
			Qt实现Excel表操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt中的QAxObject类可以实现读写excel文件，但是QAxObject在使用时需要系统中安装了offie或wps，这种方法不推荐使用；因为如果安装了wps，可能部分功能用不了；同时安装了office、wps在使用时可能有问题；或者电脑里安装了一些pdf阅读器则直接不能使用了。而QXlsx不依赖于系统环境，使用时打开excel文件将所有数据读入内存，然后就关闭文件了，也不存在文件被占用的情况。
1.源码下载 下载网址：https://gitcode.net/mirrors/QtExcel/QXlsx?utm_source=csdn_github_accelerator使用Git命令下载 git clone git@github.com:QtExcel/QXlsx.git 2.加载QXlsx库 （1）将QXlsx源码文件夹拷贝到创建的Qt工程路径下（也可以是其它路径）
（2）在工程的.pro文件中添加下列代码（注意QXlsx文件夹的路径改成自己的）
include($$PWD/QXlsx/QXlsx.pri) # QXlsx源代码 INCLUDEPATH += $$PWD/QXlsx 3.创建excel文件 Document xlsx; if(!xlsx.saveAs("1.xlsx")){ qDebug()&lt;&lt;"创建失败"; } 4.打开excel文件 Document *m_xlsx; m_xlsx = new Document("1.xlsx",this); if(!m_xlsx-&gt;load()){ qDebug()&lt;&lt;"打开失败"; } 5.关闭excel文件 delete m_xlsx; m_xlsx = nullptr; 6.写入excel m_xlsx-&gt;write("A1","1"); m_xlsx-&gt;write("B1","2"); m_xlsx-&gt;write("C1","3"); m_xlsx-&gt;write("D1","4"); m_xlsx-&gt;write(1,2,"xmr1"); m_xlsx-&gt;write(2,2,"xmr1"); m_xlsx-&gt;write(3,2,"xmr1"); m_xlsx-&gt;write(4,2,"xmr1"); m_xlsx-&gt;save(); 7.读取excel int row = m_xlsx-&gt;dimension().rowCount(); int col = m_xlsx-&gt;dimension().columnCount(); for(int i = 0;i &lt; row;i++){ for(int j = 0;j &lt; col;j++){ qDebug()&lt;&lt;m_xlsx-&gt;read(i,j)&lt;&lt;m_xlsx-&gt;read(QString("%1%2").arg(char(64+i)).arg(j)); } } //另存为 m_xlsx-&gt;saveAs("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cc04866134e5fb3a6ea893070ce6632/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e174ad8cfb3b758fd3b1088e3270122d/" rel="bookmark">
			基于WSN网络的定向步幻影路由算法matlab仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.程序功能描述
2.测试软件版本以及运行结果展示
3.核心程序
4.本算法原理
4.1 NDRW路由原理
4.2 定向步幻影路由原理
5.完整程序
1.程序功能描述 系统设计背景技术介绍与现状简介：现在是信息爆炸的一个时代，因此对于个人的隐私以及信息的隐私保护都应该被实时重视着的问题；无线传感器网络其所采用的无线多跳通信方式易收到攻击者的攻击，引发严重的位置隐私泄露问题。在本课题中，我们将对比NDRW路由和定向步幻影路由。对比对应的安全时间和能耗。
2.测试软件版本以及运行结果展示 MATLAB2022a版本运行
安全时间指的是在攻击者成功找到源位置之前，源节点传输的数据包个数。图5是对于不同的源节点到汇聚节点的距离，进行100次的反向追踪实验得到的平均结果。显然，最短路径路由的安全时间是最小的．因为它的传输路径是固定不变的，所以攻击者很容易就能定位源节点。幻影路由通过定向随机步制造随机的幻影源，避免真实源位置被攻击者发现，所以能比最短路径路由提供更长的安全时间。NDRW路由的安全时间最大，因为在NDRW路由中数据包的传输路径在动态的变化，而且数据包传输过程中避免连续使用相同的节点，攻击者就不可能连续偷听到数据包传输，而不得不在同一个节点等待更长的时间。同时图5显示随着源节点与汇聚节点之间距离的增大，NDRW的安全时间迅速增加，显示了其优势。
通信开销即为节点转发数据包的次数，幻影路由消耗了较多的能量，因为幻影路由在制造幻影源的随机步阶段要消耗额外的能量。当源节点与汇聚节点之间距离比较小时，NDRW路由的能量消耗要小于幻影路由，因为幻影路由在随机步阶段有可能把数据包传往远离汇聚节点的方向，而NDRW路由中节点只会把数据包转发给近邻居和等邻居节点。
3.核心程序 ............................................................................... for ij = 1:length(dst) ij for k = 1:1000 rng(k); X = SCALE*rand(1,Node); Y = SCALE*rand(1,Node); %基站位置 X0 = 2000; Y0 = 2000; X = [X,X0]; Y = [Y,Y0]; dmatrix= zeros(Node,Node); for i = 1:Node+1 for j = 1:Node+1 Dist = sqrt((X(i) - X(j))^2 + (Y(i) - Y(j))^2); %a link; if Dist &lt;= Radius dmatrix(i,j) = Dist; else dmatrix(i,j) = inf; end; end; end; %计算当前距离下可能的源节点 Dist2=[]; for i = 1:Node Dist2(i) = abs(sqrt((X(i) - X(end))^2 + (Y(i) - Y(end))^2)-dst(ij)); end [dd,Node_indx] = min(Dist2); Sn = Node_indx; %源位置 En = Node+1; %汇聚节点 %% %定向步幻影路 %基于跳数的定向随机步路由hwalk Dist2= []; indx = []; for i = 1:Node Dist2(i) = abs(sqrt((X(i) - X(Sn))^2 + (Y(i) - Y(Sn))^2)); if Dist2(i) &lt;= Radius &amp; Dist2(i) &gt; 0 indx = [indx,i]; end end %随机12 Index2 = randperm(length(indx)); Index2_= indx(Index2(1:min(hwalk,length(Index2)))); %段是最短路径路 [paths,costs] = func_dijkstra(Index2_(end),En,dmatrix); path_distance = 0; for d=2:length(paths) path_distance = path_distance + dmatrix(paths(d-1),paths(d)); end %安全时间 Time1(k,ij) = package_speed*length(paths); %能量消耗 E1(k,ij) = Energy*path_distance; end end 12_039m 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e174ad8cfb3b758fd3b1088e3270122d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1aa243539e5893302fd5193bebb7fa1/" rel="bookmark">
			2023年工作初体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		23年终于正式入职，参与了正式上线的电商平台、crm平台等项目的研发，公司规模较小，气氛融洽，没有任何勾心斗角、末位淘汰，几乎没什么压力。虽然是我的第一家公司，但实际是个适合养老的公司（笑
总结下今年工作学到的实践经验
交流方面 多交流、多沟通，老员工知道哪个地方有现成的接口。重点还有多与需求方沟通，不要觉得自己刚来不好意思交流。
刚来在业务流程上的问题尤其要大胆说，说错了也没问题，新人本来就不熟悉业务，说出一个错误选项让师兄或业务部排除，比自己去看不熟悉的代码要省时间。
一定要会砍需求！我tm直接砍砍砍！其实和运营部门和产品经理关系还挺好的。网上互怼的段子也有不少。如果不砍需求做了无用功，还是自己吃亏，绩效也受影响。
工作流程 公司使用阿里云效进行需求管理，类似gitlab
用github比喻的话，“需求/任务”对应issue；可以在对应的需求/issue上建立有对应编号的分支；
提交到自己分支，然后在jenkins测试环境选中自己的分支构建，就可以让需求的提出者/测试人员也线上测试效果了；
测试通过的话就可以提交到master分支。同github相同，新建请求合并（pr）时可以选择评审人，由评审人负责code review
经验方面 idea 提取函数;比起复制粘贴老代码，还是提取为函数，方便以后统一修改（dry原则，don’t repeat yourself，避免同一功能重复使用）；如果只记得修改一个地方，那其他几处就成了bug；
代码风格：给我做code review的这位，指出了使用stream 和 lambda表达式代替for循环赋值hashmap的问题。过去我比较喜欢朴素的写法，今后要保持风格一致。
性能 在遍历中最好不要有跨服务、跨接口、数据库的操作。我曾写过一个在遍历中调用dubbo远程接口查询订单的程序，耗时非常长；可以利用缓存"空间换时间"的思路，把数据取过来缓存在hashMap中。
之前开发的时候我只知道在For循环里查询数据库可能会对性能造成影响，现在知道了参与微服务开发后，在循环里遍历远程接口同样会对性能造成压力；而且接口都是设置了超时时限的，可能导致调用失败。
数据库 谨慎添加新字段。我刚入职添加了好多新字段，因为当时临近节假日，技术经理又放婚嫁去了，时间紧任务重，又是个性格内向的新人，进来没有好好了解需求和曾经的表结构。导致在数据库里加了不少多余字段（另一位师兄也很忙来不及细看）。一定要认真和产品经理（或类似提需求的职位，本文统称产品经理）好好交流那些内容需要哪些不需要；另外也要早点儿熟悉公司代码和表结构，有些冗余字段其实没必要加，可以用多表查询，同其他表的字段保持一致。
测试 公司唯一的测试妹子离职了，现在是自测+产品经理测，很多时候我这个不熟悉业务的新人测不出问题\bad
在实践中终于学会了打断点，并且再断点中改变数据进行测试。
postman测试
请求头中content type以填写的请求体为准，不能更改，要去选请求体的格式
测试的直接把验证码相关的校验给我注释起来口牙！
本地与开发环境配置 虽然.gitignore文件可以使git忽略一些文件，但在环境方面却有些难用，比如刚修改.gitignore后git默认还会追踪之前的那些文件；开发者本地开发时需要修改本地/测试/开发环境配置文件中的信息（比如有的开发者不会把开发环境放在本机127.0.0.1或是常用端口），需要提交时忽略这些更改，但此时的.gitignore确是公有库中大家都在使用的，不论是新增忽略文件、暂时忽略某些配置文件都挺难办；
师兄的解决办法是每次提交时在idea手动忽略；
我的办法是在idea的启动参数中指定环境，那里优先级高，覆盖掉配置文件的内容；这样每次启动时就会用本地环境，而且不用动任何文件；
规范与习惯 git提交消息：以需求编号开头
跟随前人的习惯写：项目新老代码交替，代码风格和技术栈多变。有的导出Excel功能用poi，有的用easyExcel;有的判空用==null三元表达式，有的用Objects.isNull()，还有的写if/else。我们代码好用==的三元表达式，那用同一个文件里统一用，不要一会if/else一会儿三元表达式。
不要用魔数，不要写这么复杂，有Objects.nonNull这个方法
public boolean equals(Object obj) { if (obj instanceof Integer) { return value == ((Integer)obj).intValue(); } return false; } instanceof是不会空指针的
interface中定义常量
contains用List不如Set
分布式事务 找一个中间的一致性管理？成本和复杂性太高，金融之类的强制要求可能需要
A调用B，B也有事务，A还没提交，B只能读老数据
要么A搞个接口让B读，也挺麻烦
要是改隔离级别，可能产生脏数据。
可以搞个job晚上自动核对数据，甚至发个报警让人工处理。每天几千笔极小交易的公司也是这么处理。
多表的update保持一致要加事务，但是分布式事务成本很高，所以用消息队列？主要还是为了异步吧，事务该被拆开还是拆开了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1aa243539e5893302fd5193bebb7fa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2feae4adaa299983a3470fee6924c87/" rel="bookmark">
			【Nodejs】基于node http模块的博客demo代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
package.json
www.js
db.js
app.js
routes/blog.js
controllers/blog.js
mysql.js
responseModel.js
无开发，不安全。
这个demo项目实现了用Promise异步处理http的GET和POST请求，通过mysql的api实现了博客增删改查功能，但因没有写登录身份认证功能，所以限制具体博客增删时的权限就用了假数据。
下面直接贴出源码：
package.json { "name": "nodetest", "version": "1.0.0", "description": "", "main": "bin/www.js", "scripts": { "dev": "nodemon bin/www.js" }, "keywords": [], "author": "", "license": "ISC", "devDependencies": { "nodemon": "^3.0.2" }, "dependencies": { "mysql": "^2.18.1" } } 这里用的是nodemon监视文件系统的更改，并自动重启 Node.js 应用程序
运行：npm run dev
www.js //创建服务器 const http=require('http'); const serverHandler=require('../app'); const PORT =5000; const server=http.createServer(serverHandler); server.listen(PORT,()=&gt; { console.log('server running at port 5000...'); }) db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2feae4adaa299983a3470fee6924c87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72cbd69a20ae388ab6d1ae1ef712bdc0/" rel="bookmark">
			Elasticsearch查询多个条件组合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Elasticsearch（ES）中，你可以使用"bool"查询来组合多个条件。 下面是一个简单的例子，演示如何在一个查询中使用多个字段：
假设你有一个索引（Index）叫做"my_index"，里面包含了一个文档类型（Type）为"my_type"的文档。文档有两个字段，分别是"title"和"content"。现在，你想要在这两个字段中搜索包含特定关键字的文档。
以下是一个基本的例子：
jsonCopy code{ "query": { "bool": { "should": [ { "match": { "title": "关键字" } }, { "match": { "content": "关键字" } } ] } } } 在上述查询中，"bool"查询使用了"should"子句，它表示其中的条件之一满足即可。在这个例子中，我们使用了两个"match"查询，分别对"title"和"content"字段执行搜索。
请根据你的实际需求调整查询条件和字段。这只是一个简单的示例，Elasticsearch提供了许多其他功能和查询类型，可以根据具体需求进行更复杂的查询。
在Elasticsearch中对同一个字段执行多个关键字搜索 在Elasticsearch中，你可以使用 “bool” 查询来执行对同一个字段的多个关键字搜索。以下是一个简单的例子，演示如何在同一个字段上执行多个关键字的搜索：
jsonCopy code{ "query": { "bool": { "should": [ { "match": { "your_field": "关键字1" } }, { "match": { "your_field": "关键字2" } }, { "match": { "your_field": "关键字3" } } // 添加更多关键字的匹配条件 ] } } } 在上述查询中，“bool” 查询使用了 “should” 子句，表示其中的任何一个条件匹配即可。每个条件都是一个 “match” 查询，用于匹配相应的关键字。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72cbd69a20ae388ab6d1ae1ef712bdc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92d3dd9613de86e5031636345755979b/" rel="bookmark">
			用数据结构python写大数计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是一个基于Python的大数计算器的示例代码：
class BigNumberCalculator: def __init__(self, num1, num2): self.num1 = num1 self.num2 = num2 @staticmethod def add(num1, num2): result = '' carry = 0 len1, len2 = len(num1), len(num2) max_len = max(len1, len2) for i in range(max_len): digit1 = int(num1[len1 - 1 - i]) if i &lt; len1 else 0 digit2 = int(num2[len2 - 1 - i]) if i &lt; len2 else 0 temp_sum = digit1 + digit2 + carry carry = temp_sum // 10 digit_sum = temp_sum % 10 result = str(digit_sum) + result if carry &gt; 0: result = str(carry) + result return result @staticmethod def multiply(num1, num2): result = '' len1, len2 = len(num1), len(num2) product = [0] * (len1 + len2) for i in range(len1-1, -1, -1): for j in range(len2-1, -1, -1): digit1 = int(num1[i]) digit2 = int(num2[j]) temp_product = digit1 * digit2 + product[i+j+1] product[i+j+1] = temp_product % 10 product[i+j] += temp_product // 10 for digit in product: result += str(digit) result = result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92d3dd9613de86e5031636345755979b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fce7480ab6d2c2874ff6f7fc5aab7e88/" rel="bookmark">
			VRPSolverEasy：可求解多种VRP变体（rich vehicle routing）问题的精确算法python包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前运筹优化领域的研究者在使用 branch-cut-and-price (BCP) 算法求解车辆路径问题 (VRP)的最优解方面取得了重大进展。BCP算法是VRPSolver中常用的算法，在许多 VRP变体的求解中表现优异。然而，其复杂的底层数学模型使其对于路径规划从业者（入门者）而言难以理解。为了解决这个问题，Najib Errami等人开发了VRPSolverEasy这个python工具包（Najib Errami, Eduardo Queiroga, Ruslan Sadykov, Eduardo Uchoa (2023) VRPSolverEasy: A Python Library for the Exact Solution of a Rich Vehicle Routing Problem. INFORMS Journal on Computing），VRPSolverEasy 提供了一个 Python 接口，无需任何混合整数规划建模知识即可使用的VRPSolver。在使用时，可以直接以VRP问题常用元素定义，例如仓库、客户、链接和车辆类型。VRPSolverEasy 可以处理多种流行的 VRP 变体及其任意组合。
目录 1. VRPSolverEasy安装2. VRPSolverEasy模块介绍2.1 添加车场节点（depot points）2.2 添加客户节点（customer points）2.3 添加弧（link）2.4 添加车辆类型（vehicle type） 3. VRPTW算例4. VRPSolverEasy可求解的其它类型VRP部分算例4.1 CVRP4.2 MDVRP4.3 RICHVRP 5. 性能 1. VRPSolverEasy安装 VRPSolverEasy包提供了两种使用模式，一种是免费版本，该版本中使用了开源线性规划求解器COIN-OR CLP（果然开源才是王道，COIN-OR还有其它的开源求解器，具体可参考文章开源建模框架+开源求解器 | 使用pyomo建模框架实现交通物流优化问题的求解 (shortest path p），直接使用pip安装就可获取免费版本。 python3 -m pip install VRPSolverEasy 另一个版本是学术版本（其实是使用商业版本的CPLEX求解器），该版本提供了一些基于MIP的启发式方法，在求解性能上更强，更容易获取可行解，但是安装起来稍微有点麻烦，需要以下四个步骤： 将VRPSolverEasy python包克隆到本地安装CPLEX下载并安装Bapcod，Bapcod是基于C++写的branch-and-price包，也是VRPSolverEasy python包的求解内核，一直在保持持续更新，可能也是感觉使用C++怕别人觉得困难，也推出了python接口 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fce7480ab6d2c2874ff6f7fc5aab7e88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/780342c9499dcf70cb481e92ced683ce/" rel="bookmark">
			深入理解 Golang 中的值类型和引用类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Golang 的内存模型
值类型
引用类型
值类型与引用类型在函数传递中的差异
指针类型（Pointer Types）
值类型与引用类型的比较
小结
在 Golang 中，数据类型可以分为两大类：值类型（Value Types）和引用类型（Reference Types）。理解这两种类型的区别对于理解 Golang 中的数据传递和内存管理是很重要的。
Golang 的内存模型 Golang 在内存分配上有两个主要的区域：栈（stack）和堆（heap）。栈用于存储函数调用时的局部变量和函数参数，特点是分配和回收速度快。而堆则用于存储那些可能需要跨函数存活的数据，由垃圾回收器管理。
值类型 值类型是指变量直接存储了实际的数据，并且每个变量都拥有独立的存储空间。当一个值类型的变量被赋给另一个变量时，会进行值拷贝，对其中一个变量的修改不会影响到原始变量。
在 Golang 中，值类型包括以下几种：
基本数据类型：整型（int、uint、int8等）、浮点型（float32、float64）、复数（complex64, complex128）、布尔型（bool）、字符串型（string）复合数据类型：数组（array）、结构体（struct） 值类型有以下特点：
直接存储值，不存储地址。变量间赋值或作为函数参数传递时进行值复制。值类型的变量副本是独立的，修改一个变量的副本不会影响另一个。值类型的复制会涉及整个值的拷贝，因此对于大的结构体或数组，复制操作可能会较慢。值类型通常在栈上分配，除非是通过 new 函数分配的，或者是作为闭包中的变量被分配到堆上。 看一个简单的示例：
package main import "fmt" func main() { x := 10 y := x x++ fmt.Println(x, y) // 输出：11 10 } 在这个例子中，x 和 y 都是整型值，y 是 x 的一个副本。对 x 的修改不会影响到 y，因此 y 的值仍然是10。
引用类型 引用类型并不直接存储数据本身，而是存储指向数据的指针，当复制一个引用类型的变量时，复制的是指针，新旧变量将指向相同的底层数据。
在 Golang 中，引用类型主要包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/780342c9499dcf70cb481e92ced683ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9fe1b5392ef539b1f74994e84fa1d8a/" rel="bookmark">
			Pytorch从零开始实战15
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pytorch从零开始实战——ResNeXt-50算法实战 本系列来源于365天深度学习训练营
原作者K同学
文章目录 Pytorch从零开始实战——ResNeXt-50算法实战环境准备数据集模型选择开始训练可视化总结 环境准备 本文基于Jupyter notebook，使用Python3.8，Pytorch2.0.1+cu118，torchvision0.15.2，需读者自行配置好环境且有一些深度学习理论基础。本次实验的目的是了解并使用ResNeXt-50模型。
第一步，导入常用包
import torch import torch.nn as nn import matplotlib.pyplot as plt import torchvision import torchvision.transforms as transforms import torchvision.datasets as datasets import torch.nn.functional as F import random from time import time import numpy as np import pandas as pd import datetime import gc import os import copy import warnings os.environ['KMP_DUPLICATE_LIB_OK']='True' # 用于避免jupyter环境突然关闭 torch.backends.cudnn.benchmark=True # 用于加速GPU运算的代码 设置随机数种子
torch.manual_seed(428) torch.cuda.manual_seed(428) torch.cuda.manual_seed_all(428) random.seed(428) np.random.seed(428) 检查设备对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9fe1b5392ef539b1f74994e84fa1d8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/030b0e6b84f23cd559a7cc295119657d/" rel="bookmark">
			虚幻UE 增强输入-第三人称模板增强输入分析与扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇是增强输入模块，作为UE5.0新增加的模块。
其展现出来的功能异常地强大！
让我们先来学习学习一下第三人称模板里面的增强输入吧！
文章目录 前言一、增强输入四大概念二、使用步骤1、打开增强输入模块2、添加IA输入动作2、添加IMC输入映射内容3、绑定IMC到EIPS增强输入本地用户子系统4、具体按键实现逻辑 三、测试其他特性1、同一按键 不同Map先后2、不同按键（组合键3、运行时按键控制 总结参考 前言 为什么要开发出一个新的输入模式呢？
是因为旧的输入模式不好吗？其实并不是，而是不够灵活、方便，
且一般只能实现简单的功能，如果需要复杂的功能得自己写逻辑了，
比如按住、双击、联合输入等
所以就开发了一个新的输入模式----增强输入（Enhanced Input System）
一、增强输入四大概念 增强输入主要提出了四个概念：
输入动作（UInputAction）： 是增强输入系统和项目代码之间的通信链接。 和我们的按键无关，只知道按键的状态，也就是是否按下。 输入修改器（UInputModifier）：用于修改来自用户设备的原始输入值。 也就是可以对按键的状态进行修改 输入触发器（UInputTrigger）： 使用经过修饰器修改的输入值， 或者使用其他输入动作的输出值，来确定是否激活输入动作。 输入映射内容（UInputMappingContext）： 将用户输入映射到输入动作， 并可以动态地为每个用户添加、移除或安排优先次序。和按键有关。 二、使用步骤 1、打开增强输入模块 开启增强输入插件
修改默认的输入模式为增强输入
2、添加IA输入动作 原先的Action绑定:
原先的Axis绑定:（也可以把左右移动、上下移动写在一个IA里，用2D来表示
2、添加IMC输入映射内容 按键绑定：（修改器中Negate是相反的意思，就是把修饰器修改的输入值，
或者使用其他输入动作的输出值进行取反
3、绑定IMC到EIPS增强输入本地用户子系统 4、具体按键实现逻辑 这样一个简单的第三人称模板的输入就搞定了！
注意：我们这里接触到是输入修改器（UInputModifier）暂时只有Negate反向，
但其实在第三人称模板内，还涉及了：
盲区DeadZone为了解决两个问题：
1、如果用户没有按下任何键，系统通常会将输入视为无效或忽略。
2、当用户只是暂时释放了按键，但很快又按下时，系统可能无法正确地响应他们的输入。
解决方式：当用户在一定时间内没有按下任何键时，系统可以忽略他们的输入，以避免误操作或干扰游戏进程。同时，当用户按下某个键时，系统可以快速地响应并执行相应的动作，提供更好的游戏体验。
拌合输入轴值Mixed Axis Values为了解决的问题：
1、将1D输入（例如键盘按键）映射到2D或3D空间的问题。
简单的来说就是同时按下W和A键时，如何判断移动的方向？
拌合输入轴值允许开发者将多个轴值组合在一起，形成更复杂的输入动作。
三、测试其他特性 两份功能一模一样的IA和IMC
1、同一按键 不同Map先后 结论：后进先出 1、改变优先级 优先级越大越优先 2、consume input为false（默认为true，如果最后mapping的那个为false的话不会影响其他的输入 Consume Input 允许开发者控制输入事件是否被处理或传递给其他系统或组件。 通过使用 Consume Input，开发者可以拦截用户的输入行为，并进行自定义处理， 而不需要将输入传递给其他组件或系统。 2、不同按键（组合键 组合键
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/030b0e6b84f23cd559a7cc295119657d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e8bd5db5e5f29ec10c7e15ed43c12ce/" rel="bookmark">
			【UnityShader入门精要学习笔记】第三章（1）Unity Shader介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列为作者学习UnityShader入门精要而作的笔记，内容将包括：
书本中句子照抄 + 个人批注项目源码一堆新手会犯的错误潜在的太监断更，有始无终 总之适用于同样开始学习Shader的同学们进行有取舍的参考。
文章目录 Unity Shader概述Unity中的材质Unity Shader Unity Shader基础之ShaderLab什么是ShaderLab Unity Shader的结构命名材质和Unity Shader的桥梁：Properties重要的部分：SubShader状态（[RenderSetup])SubShader的标签（Tag）Pass语义块后路：FallbackShaderLab的其他语义 从本章节开始我们要学习Shader相关的知识了，诸位看客可能有的人很高兴了，“太好了终于可以写Shader了，我已经迫不及待了”。其实还没有，第三章我们只是介绍Shader的基础知识。“那下章就可以写Shader了”，其实也不是，下章我们要学习数学基础。起码要下下章才能开始学习编写Shader代码，还得从最基本的语法开始学习，路漫漫其修远兮，心急吃不了热豆腐。
Unity Shader概述 根据第二章中我们学习的知识，我们知道了渲染管线中有各种可编程的着色器阶段和许多可以配置的渲染设置。其实UnityShader的作用就是对各类着色器代码以及渲染设置进行管理。
经常接触3D开发的开发者们都知道，在Unity中，想要为一个模型网格体渲染出强大的视觉效果，往往离不开两个东西：
材质（Material）Shader 一个常见的网格体渲染设置的流程是：
创建一个材质
创建一个UnityShader，并把它赋给上一步中创建的材质（或是选择Unity预设的Shader）
把材质赋给要渲染的对象
在材质面板中调整UnityShader的属性，以得到满意的效果
下图显示了Shader和材质是如何一起工作来控制物体的渲染的：
UnityShader中定义了渲染所需的各种代码（如顶点着色器和片元着色器）、属性（如使用哪些纹理等）和指令（渲染和标签设置等）。而材质则允许我们调节这些属性，并最终赋值给相应的模型。
Unity中的材质 我们知道了如果需要为网格渲染需要赋予材质，而材质需要赋予Shader。空白的网格体其实相当于一张空白画布，把材质赋予网格体相当于在画布上绘画，而Shader就像是材质的调色板，可以通过改变Shader中的属性来修改网格上画面的属性和渲染状态。
在此处，我认为有必要理清材质（Material）、着色器（Shader）、贴图（Map）、纹理（Texture）的关系 。首先从集合上的包含关系来看，材质Material（包含着色器）&gt;贴图Map&gt;纹理Texture 。
Material本质上是一个数据集，它包含了Shader的渲染设置，以及供Shader读取的那些数据（包括了纹理texture和各类贴图map），而实际上纹理应当被贴图包含，纹理的全称应该被称为Texture Map，也就是纹理贴图，以上图为例，unity中的Albedo其实是反射率贴图，用于表示模型的纹理和颜色，因此我们常常把纹理贴图赋值给这个属性。
而贴图不仅仅包含了基本的纹理，实际上还包含了UV坐标，各种输入输出控制等其他信息，所以会有很多贴图，Height Map（光照贴图），Normal Map（法线贴图）。
本质上贴图的英文Map代表的不是位图bitmap，这个Map是一个动词，翻译过来是“映射”，其功能就是把纹理通过 UV 坐标映射到3D 物体表面。
（上述答案可能有误，关于贴图和纹理的关系网上众说纷纭，其实没必要咬文嚼字）
Unity Shader 为了和前面通用的Shader语义进行区分，我们把Unity中的Shader文件统称为Unity Shader。因为Unity Shader和我们之前提到的渲染管线的Shader有很大不同（这将在后文中解释）。
我们可以在资源栏右键创建一个Unity Shader，Unity为我们提供了四种模板（上图是2022版本，提供了5种）。
Standard Surface Shader 会产生一个包含标准光照模型的表面着色器模板。UnlitShader会产生一个不包含光照（但包含雾效）的基本的顶点/片元着色器。Image Effect Shader 为我们实现各种屏幕的后处理效果提供一个基本的模板。Compute Shader 会产生一种特殊的Shader 文件，这类Shader旨在利用GPU的并行性来进行一些与常规渲染流水线无关的计算。Ray Tracing Shader是利用RTX显卡实现光线追踪的Shader。
Standard Surface Shader是一种典型的表面着色器的实现方法。但是本书的重点在于如何在Unity中编写顶点/片元着色器，因此后续的学习中我们通常会使用Unlit Shader来编写Shader。
在Shader的面板上，我们可以看到该Shader的面板属性（这些属性在材质中是可以直接通过编辑器来赋值和调整的）,也对应了最下方的Properties： 显示的属性（Properties显示了属性名和其类型，方便我们在C#中通过代码进行调用）。
在Shader的Imported Object面板上，我们可以看到一些和该Unity Shader相关的信息，例如它是否是一个表面着色器（Surface shader）、是否是固定函数着色器（Fixed Function）等来判断其着色器类型，还有一些信息是我们在UnityShader中的标签设置相关，例如是否计算阴影（Cast shadows），使用的渲染队列（Render queue）、LOD层级等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e8bd5db5e5f29ec10c7e15ed43c12ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a08ae549de5a724a1926202e41202c91/" rel="bookmark">
			BUU-crypto-刷题记录20
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[RoarCTF2019]RSA 题目
A=(((y%x)**5)%(x%y))**2019+y**316+(y+1)/x p=next_prime(z*x*y) q=next_prime(z) A = 2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724 n = 117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127 c = 41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747 885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128 解题
已知n、c
将n分解得到：
p = 842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458569 q = 139916095583110895133596833227506693679306709873174024876891023355860781981175916446323044732913066880786918629089023499311703408489151181886568535621008644997971982182426706592551291084007983387911006261442519635405457077292515085160744169867410973960652081452455371451222265819051559818441257438021073941183 e未知，需要爆破一下（e最小为2)
注意，[RoarCTF2019]的默认flag形式为RoarCTF{***}
import sympy from gmpy2 import * from Crypto.Util.number import long_to_bytes #记得导入数据 phi=(p-1)*(q-1) flag="RoarCTF{" e = 2 while(e&lt;100000): e = next_prime(e) d = invert(e,phi) m = pow(c,d,n) s = str(long_to_bytes(m)) if flag in s: print(s) break 出现错误
ZeroDivisionError: invert() no inverse exists
对出错语句加上异常处理：
while(e&lt;100000): e = next_prime(e) try: d = invert(e,phi) except: continue else: m = pow(c,d,n) s = str(long_to_bytes(m)) if flag in s: print(s) break 运行得到
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a08ae549de5a724a1926202e41202c91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc74fb44a6e106fa56badbff92f1f87a/" rel="bookmark">
			华为云CES监控与飞书通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为云负载均衡连接数监控与飞书通知 在云服务的日常运维中，持续监控资源状态是保障系统稳定性的关键步骤之一。本文通过一个实际案例展示了如何使用华为云的Go SDK获取负载均衡器的连接数，并通过飞书Webhook发送通知到团队群组，以便运维人员及时获取最新的监控信息。本来准备直接使用ces告警，但是看了一下模版以及最佳实践貌似没有很好的支持webhook，就直接自己使用go sdk实现了！
背景知识 在华为云上，负载均衡服务（ELB）用于分发来自客户端的网络请求到多个云服务器，确保系统在面对不同的负载情况时，仍能够提供稳定、可靠的服务。ELB的性能指标，如每分钟连接数（CPS），是反映当前系统承载能力的重要数据。通常情况下，我们希望能够实时监控这些关键指标。
随着云服务技术的成熟，大型企业往往会将监控数据集成到实时通讯工具中，便于团队成员即时查看和响应潜在的问题。本案例中选择的通讯工具是飞书，华为云Go SDK则是我们与华为云服务交互的媒介。
环境准备 华为云提供的Go SDK是一套围绕华为云API构建的开发工具包，使得开发者可以在Go语言环境中便捷地调用云服务。在这里，我们利用Cloud Eye Service (CES) 的API，通过SDK检索ELB的CPS指标数据。
安装华为云Go SDK 首先需要安装华为云Go SDK。可以通过go get命令安装所需的SDK包：
go get -u github.com/huaweicloud/huaweicloud-sdk-go-v3 安装完成后，即可在项目中引入相关的SDK模块。
初始化客户端 要与华为云的服务交互，我们需要创建并初始化一个SDK客户端。如下示例中，我们创建了用于CES（Cloud Eye Service）服务的客户端，并使用了之前提到的AK和SK进行了认证。
package main // 导入相关的包 import ( "fmt" "bytes" "json" "http" "ioutil" "time" "github.com/huaweicloud/huaweicloud-sdk-go-v3/core/auth/basic" "github.com/huaweicloud/huaweicloud-sdk-go-v3/services/ces/v1" ces "github.com/huaweicloud/huaweicloud-sdk-go-v3/services/ces/v1/model" ) const ( feishuWebhookURL = "xxxx" // 飞书Webhook URL ak = "xxx" // Access Key sk = "xxxxx" // Secret Key ) func main() { // 构建认证信息 auth := basic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc74fb44a6e106fa56badbff92f1f87a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf9bc15514b7da4dd3ee0d254affae71/" rel="bookmark">
			深度学习-模型转换_所需算力相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型转换相关 tensflow转onnx python -m tf2onnx.convert \ --graphdef /root/autodl-tmp/warren/text-detection-ctpn/data/ctpn.pb \ --output ./model.onnx --inputs Placeholder:0 --outputs Reshape_2:0，rpn_bbox_pred/Reshape_1:0 pytorch转onnx #!/usr/bin/env python3 import torch from simple_net import SimpleModel # Load the pretrained model and export it as onnx model = SimpleModel() model.eval() checkpoint = torch.load("weight.pth", map_location="cpu") model.load_state_dict(checkpoint) # Prepare input tensor input = torch.randn(1, 1, 28, 28, requires_grad=True)#batch size-1 input cahnne-1 image size 28*28 # Export the torch model as onnx torch.onnx.export(model, input, 'model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf9bc15514b7da4dd3ee0d254affae71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53fdc4ded5f8957b4e1e2c43d00b312b/" rel="bookmark">
			每日coding
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天无意点进一个回文串的题目，对于回文串我第一印象就用双指针，但是确实没写出来，看了评论区题解，绝大多数都是用dp来做的，但是找到一个用双指针做的，刚好延续思路，先把题目贴出来。
5、最长回文子串 给你一个字符串 s，找到 s 中最长的回文子串。
如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。
示例 1：
输入：s = "babad" 输出："bab" 解释："aba" 同样是符合题意的答案。 示例 2：
输入：s = "cbbd" 输出："bb" 提示：
1 &lt;= s.length &lt;= 1000s 仅由数字和英文字母组成 这道题目之前一直做不对的原因是，我一直想的是回文串的中心点只能从给的字符串中心点取，这就思想有问题了。okok，看看这道题目双指针的解法，先说复杂度，时间复杂度o（n^2），空间复杂度o（1）。核心思想其实是，回文串就两种可能，一种是中间一个数值，一种是中间两个数值，因此就一个一个试，然后找到最长的，但是需要记录下来最长的start和end，这个公式反正有点迷糊，但是一写还真是这样。
class Solution { public: string longestPalindrome(string s) { int len = s.size(); if(len == 0 || len == 1) return s; int start = 0; int end = 0; int mlen = 0; for(int i = 0;i &lt; len;++i){ int len1 = expendaroundcenter(s, i, i); int len2 = expendaroundcenter(s, i, i+1); mlen = max(max(len1, len2), mlen); if(mlen &gt; end - start + 1){ start = i - (mlen-1) / 2; end = i + mlen / 2; } } return s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53fdc4ded5f8957b4e1e2c43d00b312b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04cd6032c8c4d5412d156ad7e26cf10a/" rel="bookmark">
			MySQL之基于代价的慢查询优化建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景 慢查询是指数据库中查询时间超过指定阈值（美团设置为 100ms）的 SQL，它是数据库的性能杀手，也是业务优化数据库访问的重要抓手。
如何优化慢查询呢？最直接有效的方法就是选用一个查询效率高的索引。关于高效率的索引推荐，主要在日常工作中，基于经验规则的推荐随处可见，对于简单的、SQL，如
select * from sync_test1 where name like 'Bobby%'， 直接添加索引 IX(name) 就可以取得不错的效果；但对于稍微复杂点的 SQL，如
select from sync_test1 where name like 'Bobby%' and dt &gt; '2021-07-06' 到底选择 IX(name)、IX(dt)、IX(dt,name) 还是 IX(name,dt)，该方法也无法给出准确的回答。更别说像多表 Join、子查询这样复杂的场景了。所以采用基于代价的推荐来解决该问题会更加普适，因为基于代价的方法使用了和数据库优化器相同的方式，去量化评估所有的可能性，选出的是执行 SQL 耗费代价最小的索引。
2.基于代价的优化器介绍 2.1 SQL 执行与优化器 一条 SQL 在 MySQL 服务器中执行流程主要包含：SQL 解析、基于语法树的准备工作、优化器的逻辑变化、优化器的代价准备工作、基于代价模型的优化、进行额外的优化和运行执行计划等部分。具体如下图所示：
2.2 代价模型介绍 而对于优化器来说，执行一条 SQL 有各种各样的方案可供选择，如表是否用索引、选择哪个索引、是否使用范围扫描、多表 Join 的连接顺序和子查询的执行方式等。如何从这些可选方案中选出耗时最短的方案呢？这就需要定义一个量化数值指标，这个指标就是代价 (Cost)，我们分别计算出可选方案的操作耗时，从中选出最小值。
代价模型将操作分为 Server 层和 Engine（存储引擎）层两类，Server 层主要是CPU 代价，Engine 层主要是 IO 代价，比如 MySQL 从磁盘读取一个数据页的代价io_block_read_cost 为 1，计算符合条件的行代价为 row_evaluate_cost 为 0.2。除此之外还有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04cd6032c8c4d5412d156ad7e26cf10a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcee0b76e3732acafd698e0728685832/" rel="bookmark">
			prometheus与zabbix监控的对比介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、普米与zabbix基本介绍 1、prometheus介绍 Prometheus的基本原理是Prometheus Server通过HTTP周期性抓取被监控组件的监控数据，任意组件只要提供对应的HTTP接口并且符合Prometheus定义的数据格式，就可以接入Prometheus监控。
工作流程大致分为收集数据，存储数据，展示监控数据，监控告警。
核心组件包括：
Exporters：监控数据采集器
Prometheus Server：负责对监控数据的获取，存储以及查询
AlertManager：告警流程管理
PushGateway：当网络需求无法满足时就可以使用PushGateway作为中转站。
Prometheus后端数据库用的自带的时序数据库TSDB，按时间索引性能更高。也支持其他远端数据库，但效率会有所下降。
普米架构图
2、Zabbix介绍 Zabbix的基础原理是Zabbix Server抓取监控组件的监控数据或者接收主动推送监控数据。支持在每个网络区域内部署一个Zabbix Proxy，即 Zabbix 的代理服务器，代理服务器采集当前区域的监控组件的监控数据。并将采集到的数据推送给 Zabbix Server 进行后续处理，
工作流程大致分为agent发送数据，sever存储数据，展示监控数据，监控告警。
核心组件：
Agent：主要负责采集数据并通过主动或者被动的方式采集数据发送到Server/Proxy，除此之外，为了扩展监控项，Agent还支持执行自定义脚本。
Server：要负责接收Agent/Proxy发送的监控信息，并进行汇总存储，触发告警等。
Zabbix Web ： zabbix的GUI接口，通常与server运行在同一台机器上
Proxy：可选组件，常用于分布式监控环境中，代理Server收集部分被监控数据并统一发往Server端，减轻Sever端负载。
Zabbix Database支持常用的关系型数据库，如MySQL、PostgreSQL、Oracle等，默认是MySQL。现6.0版本支持TimescaleDB，关系数据库较常用，学习成本低。
zabbix架构图
二、功能测试对比 1、基础监控指标对比 注：本次监控指标测试以主要在用的LINUX、mysql对象为例。
监控LINUX主机指标对比：
Zabbix内置指标通过agent进行采集，agent安装后需要配置文件。
prometheus由官方提供node_exporter采集器进行采集。直接解压缩运行。
监控mysql指标对比：
Zabbix支持agent、agent2两种客户端，agent2集成部分数据库、ceph、red采集插件，不需要在客户端另外配置。
Prometheus由官方提供mysqld_exporter采集器进行采集。
监控指标测试结论：
采集指标项上：Prometheus相较zabbix监控指标项更细。
采集频率上：zabbix可根据指标自定义频率，prometheus通过统一参数scrape_interval配置采集频率。
自定义监控指标上：zabbix提供agent+自定义脚本方式采集、配置繁琐， prometheus需要对源码进行二次开发困难。
采集分组情况上：Zabbix可通过agent采集多个业务组件，管理方便。 Prometheus需要部署多个exporter采集不同的业务组件，服务端口不固定。
2、云原生k8s监控对比 Zabbix 6.0 LTS新增Kubernetes监控功能
多个维度采集指标：
Kubernetes节点和pods的自动发现和监控
无代理方式采集Kubernetes pods和节点的信息
获取Kubernetes节点主机高水平信息：
kube-controller-manager、kube-apiserver、kube-scheduler、kubelet
监控部署方式
ZABBIX6.0提供HELM方式部署，将ZABBIX AGENT和ZABBIX PROXY等部署在Kubernetes集群中。并提供相应的模板，对Kubernetes集群进行自动发现及数据采集。
测试结论
ZABBIX6.0LTS版本虽然支持Kubernetes监控，原生模板监控项目前无法满足所需采集指标，需再自定义定制更丰富的监控项。
Prometheus监控Kubernetes更有优势，k8s组件自带采集接口，普米自动发现k8s组件Targets，抓取metrics数据，且两者出自于统一基金会，适配度更佳，对集群数据采集更全面。
3、高可用架构对比 zabbix高可用 Zabbix6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcee0b76e3732acafd698e0728685832/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/816a175e4bb9c34cbb255f862731dca5/" rel="bookmark">
			【MySQL】字符集与排序规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MySQL数据库中，字符集（Character Set）和排序规则（Collation,也称字符集校验规则）是重要的概念，它们对于正确存储和比较数据至关重要。
字符集与排序规则 字符集是一组字符的集合，与数字编码之间建立了对应关系。它定义了数据库中可以存储的字符种类和范围。常见的字符集有UTF-8、Latin1、GBK等。字符集决定了数据库可以处理的语言和字符的能力。
排序规则定义了字符在排序和比较操作中的顺序。它决定了字符串排序的方式，包括字母的大小写敏感性、特殊字符的处理等。排序规则也叫字符集校对规则
每个字符集可以有多个排序规则。即排序规则是和字符集结合使用的，二者配合规定了数据库对字符串的存储范围、排序方式、大小写美感性、特殊字符的处理等。
MySQL支持的字符集 MySQL 提供了 SQL 用于查看数据库支持的字符集。
MySQL 环境如下图所示：
执行 show charset; 查看该数据库支持的字符集。
mysql&gt; show charset; +----------+---------------------------------+---------------------+--------+ | Charset | Description | Default collation | Maxlen | +----------+---------------------------------+---------------------+--------+ | armscii8 | ARMSCII-8 Armenian | armscii8_general_ci | 1 | | ascii | US ASCII | ascii_general_ci | 1 | | big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 | | binary | Binary pseudo charset | binary | 1 | | cp1250 | Windows Central European | cp1250_general_ci | 1 | | cp1251 | Windows Cyrillic | cp1251_general_ci | 1 | | cp1256 | Windows Arabic | cp1256_general_ci | 1 | | cp1257 | Windows Baltic | cp1257_general_ci | 1 | | cp850 | DOS West European | cp850_general_ci | 1 | | cp852 | DOS Central European | cp852_general_ci | 1 | | cp866 | DOS Russian | cp866_general_ci | 1 | | cp932 | SJIS for Windows Japanese | cp932_japanese_ci | 2 | | dec8 | DEC West European | dec8_swedish_ci | 1 | | eucjpms | UJIS for Windows Japanese | eucjpms_japanese_ci | 3 | | euckr | EUC-KR Korean | euckr_korean_ci | 2 | | gb18030 | China National Standard GB18030 | gb18030_chinese_ci | 4 | | gb2312 | GB2312 Simplified Chinese | gb2312_chinese_ci | 2 | | gbk | GBK Simplified Chinese | gbk_chinese_ci | 2 | | geostd8 | GEOSTD8 Georgian | geostd8_general_ci | 1 | | greek | ISO 8859-7 Greek | greek_general_ci | 1 | | hebrew | ISO 8859-8 Hebrew | hebrew_general_ci | 1 | | hp8 | HP West European | hp8_english_ci | 1 | | keybcs2 | DOS Kamenicky Czech-Slovak | keybcs2_general_ci | 1 | | koi8r | KOI8-R Relcom Russian | koi8r_general_ci | 1 | | koi8u | KOI8-U Ukrainian | koi8u_general_ci | 1 | | latin1 | cp1252 West European | latin1_swedish_ci | 1 | | latin2 | ISO 8859-2 Central European | latin2_general_ci | 1 | | latin5 | ISO 8859-9 Turkish | latin5_turkish_ci | 1 | | latin7 | ISO 8859-13 Baltic | latin7_general_ci | 1 | | macce | Mac Central European | macce_general_ci | 1 | | macroman | Mac West European | macroman_general_ci | 1 | | sjis | Shift-JIS Japanese | sjis_japanese_ci | 2 | | swe7 | 7bit Swedish | swe7_swedish_ci | 1 | | tis620 | TIS620 Thai | tis620_thai_ci | 1 | | ucs2 | UCS-2 Unicode | ucs2_general_ci | 2 | | ujis | EUC-JP Japanese | ujis_japanese_ci | 3 | | utf16 | UTF-16 Unicode | utf16_general_ci | 4 | | utf16le | UTF-16LE Unicode | utf16le_general_ci | 4 | | utf32 | UTF-32 Unicode | utf32_general_ci | 4 | | utf8mb3 | UTF-8 Unicode | utf8_general_ci | 3 | | utf8mb4 | UTF-8 Unicode | utf8mb4_0900_ai_ci | 4 | +----------+---------------------------------+---------------------+--------+ 41 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/816a175e4bb9c34cbb255f862731dca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c70ea10dbd96c5fa8adb21911bedac0/" rel="bookmark">
			听GPT 讲Rust源代码--compiler(11)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		File: rust/compiler/rustc_mir_transform/src/simplify.rs 在Rust源代码中，rust/compiler/rustc_mir_transform/src/simplify.rs文件是Rust编译器中一系列进行MIR（中间表示）简化的转换的实现。MIR是Rust编译器中用于进行优化和代码生成的中间表示。
文件中的主要结构体包括：CfgSimplifier、OptApplier、UsedLocals和LocalUpdater。这些结构体用于实现不同的功能：
CfgSimplifier&lt;'a, 'tcx, OptApplier&lt;'tcx&gt;, UsedLocals, LocalUpdater&lt;'tcx&gt;&gt;: 这个结构体是MIR简化的核心实现。它接收一个OptApplier用于应用不同的优化器，UsedLocals用于追踪使用的局部变量，LocalUpdater用于更新局部变量。
OptApplier&lt;'tcx&gt;: 这个结构体定义了应用于MIR的不同优化器。它根据优化规则对MIR进行转换。
UsedLocals: 这个结构体用于追踪哪些局部变量在MIR中被使用。
LocalUpdater&lt;'tcx&gt;: 这个结构体用于更新MIR中的局部变量。
除了以上结构体，simplify.rs文件还定义了一些辅助结构体和函数。其中，SimplifyCfg和SimplifyLocals是两个enum，它们定义了不同的简化策略：
SimplifyCfg: 这个enum定义了不同的MIR控制流图简化策略。每个选项对应一个简化策略，例如合并块、消除无用块等。
SimplifyLocals: 这个enum定义了不同的局部变量简化策略。每个选项对应一个简化策略，例如消除未使用的局部变量、合并复制等。
这些结构体和枚举类型的实现组合在一起，通过对MIR的简化转换，优化代码的执行效率和生成的机器码。
File: rust/compiler/rustc_mir_transform/src/coverage/graph.rs 在Rust编译器的源代码中，rust/compiler/rustc_mir_transform/src/coverage/graph.rs文件的作用是实现代码覆盖率相关的图数据结构和算法。
以下是对各个结构体的详细介绍：
CoverageGraph：表示代码覆盖率的图数据结构。它由一系列的基本覆盖块（BasicCoverageBlock）和之间的跳转边（BcbBranch）组成。
BasicCoverageBlock：表示基本的覆盖块（Basic Block），即一连串没有跳转语句的代码片段。每个基本覆盖块都有一个唯一标识符和一组出边（跳转到其他基本覆盖块）。
BasicCoverageBlockData：基本覆盖块的数据结构，附加在基本覆盖块上。它保存了基本块的覆盖率信息，包括是否已执行等。
BcbBranch：表示基本覆盖块之间的跳转边。跳转边有源基本覆盖块和目标基本覆盖块，并且可能有一个条件用于判断是否跳转。
TraversalContext：遍历上下文的数据结构，用于在遍历图时记录和管理遍历状态。
TraverseCoverageGraphWithLoops：通过循环进行图遍历的算法，用来遍历覆盖率图并获取覆盖率信息。
ShortCircuitPreorder：短路预排序（Short-Circuit Preorder）算法的实现，用来对覆盖率图中的基本覆盖块进行预排序。短路预排序算法通过图的拓扑排序策略来分析和遍历基本覆盖块，以提高算法效率。
这些结构体和算法的目的是为了实现对Rust代码的覆盖率分析，其中 CoverageGraph 是整个覆盖率图的数据结构，通过使用其他结构体和算法，可以对这个图进行遍历和分析，以实现代码覆盖率统计等功能。
File: rust/compiler/rustc_mir_transform/src/coverage/debug.rs 在Rust编译器的源代码中，rust/compiler/rustc_mir_transform/src/coverage/debug.rs 文件的作用是为代码覆盖率调试提供支持。
具体来说，以下是每个结构体的功能说明：
DebugOptions：该结构体定义了用于调试选项的选项集。它包含多个布尔字段，用于控制不同调试功能的开启和关闭。
ExpressionFormat：该结构体定义了用于表达式格式化的选项。它允许定义表达式输出的格式，如显示变量名或显示变量类型。
DebugCounters：该结构体定义了用于记录调试计数器的信息。它包含多个字段，例如 num_expressions、num_constants、num_operations 等，用于记录不同类型的表达式数量。
DebugCountersState：该结构体用于存储和更新调试计数器的状态。它包含一个 HashMap 字段，用于存储每个计数器的当前值。
DebugCounter：该结构体定义了一个调试计数器。它包含一个 id 字段用于唯一标识计数器，并跟踪计数器的值。
GraphvizData：该结构体在调试期间用于生成 Graphviz 数据。它包含多个字段，例如节点列表和边列表，用于表示 MIR（中间表示）的数据结构。
GraphvizDataState：该结构体用于存储和更新 Graphviz 数据的状态。它包含多个字段，例如跟踪已访问的节点和边的集合。
UsedExpressions：该结构体定义了用于跟踪已使用的表达式的集合。它包含一个 HashSet 字段，用于存储已使用的表达式的唯一标识。
UsedExpressionsState：该结构体用于存储和更新已使用表达式的状态。它包含一个 UsedExpressions 字段，用于存储已使用的表达式，并提供了添加、删除和查询表达式的方法。
这些结构体的目的是为代码覆盖率调试提供必要的工具和数据结构，以帮助开发人员分析代码的执行路径，并进行相关的调试和优化。
File: rust/compiler/rustc_mir_transform/src/coverage/spans.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c70ea10dbd96c5fa8adb21911bedac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02d0eac7b0cca039e374449c63dc79d/" rel="bookmark">
			React Hooks之useState、useRef
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 React Hooks之useStateReact HooksuseStatedemo：在函数式组件中使用 useState Hook 管理计数器demo：ant-design-pro 中EditableProTable组件使用 useRef React Hooks之useState React Hooks 在 React 16.8 版本中引入了 Hooks，它是一项新的特性，使得我们在函数组件中可以使用状态（state）和其他 React 特性，而无需编写类组件。
Hook 是一些可以让你在函数组件中“钩入” React 状态及生命周期等特性的函数，它可用于增强函数组件的功能，以解决类组件难以解决的问题。
useState 在 React 中，我们可以使用 useState Hook 来管理函数组件的内部状态。
useState 是一种 Hook，它接收一个初始状态值，并返回一个由当前状态值以及一个更新状态值的函数组成的数组。通常，我们将 useState 的返回值解构为数组的形式，然后使用 ES6 数组解构的方式获取当前状态值和更新状态值的函数。
demo：在函数式组件中使用 useState Hook 管理计数器 以下是一个简单的例子，在函数式组件中使用 useState Hook 管理计数器的状态：
import React, { useState } from 'react' function Counter() { const [count, setCount] = useState(0) return ( &lt;div&gt; &lt;p&gt;Count: {count}&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt; &lt;button onClick={() =&gt; setCount(count - 1)}&gt;-1&lt;/button&gt; &lt;/div&gt; ) } export default Counter 在 Counter 组件中调用 useState Hook，初始化计数器的状态值为 0。count 表示当前状态的值，setCount 表示更新状态的函数。在 JSX 中，我们可以通过 { count } 的方式引用当前状态值，通过 { () =&gt; setCount(count + 1) } 的方式更新状态值。每次更新状态后，React 都会重新渲染组件使其展示新的页面。 demo：ant-design-pro 中EditableProTable组件使用 上一个例子结构比较简单，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f02d0eac7b0cca039e374449c63dc79d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8862cd68f15fd72533971dafd82983f2/" rel="bookmark">
			【我的Rust库】get_local_info 0.1.5发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		get_local_info是一个获取linux本地信息的Rust三方库，其目标是降低获取本地linux系统信息的难度。支持银河麒麟10、UOS、鸿蒙等国产系统。
项目维护：长期
当前版本0.1.5
当前功能：
1.获取活动网卡信息：网卡，IPv4，IPv6，mac
2.获取网络接口信息
3.获取系统版本
Kylin10支持2017及以上版本
Ubuntu支持22.04及以上版本
UOS20支持1020及以上版本
4.进程检测，虚拟机检测
怎么使用：
执行cargo add get_local_info，然后导入调用接口：
extern crate get_local_info; fn main() { println!("{}", get_local_info::get_pc_net_card_name()); println!("{}", get_local_info::get_pc_ipv4()); println!("{}", get_local_info::get_pc_ipv6()); println!("{}", get_local_info::get_pc_mac()); println!("{:?}", get_local_info::get_pc_net_card_info()); // osname: ubuntu or uos or kylin let osname = "uos"; println!("{}", get_local_info::get_pc_system_ver(osname)); //check proccess name let pname = "gnome"; println!("{}", get_local_info::get_pc_system_check_pname(pname)); // flase is Real machine, true is vm println!("{}", get_local_info::get_pc_system_is_vm()); } About the Author
Liu Qiang in Wuhan, China
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8862cd68f15fd72533971dafd82983f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d6e5b59b815386744fee5fd08189f0/" rel="bookmark">
			gitlab 8.13.0 关闭注册功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新版本基本都可以在网上找到关闭注册的教程，但是老版本会比较麻烦，可以通过如下路径在网页中设置（root 管理员登录）
​​​​​​http://ip:port/admin/application_settings
最后保存即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9db7d127dbf8ee00599e7d7a55309314/" rel="bookmark">
			案例精选｜淄博绿能燃气工程有限公司日志审计系统建设方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		淄博绿能燃气工程有限公司，成立于1994年，前身为淄博市煤气公司管道液化气分公司。公司业务主要涉及天然气、液化气等市政工程施工及城镇燃气供应等领域，具有市政公用工程施工总承包二级资质，《压力管道安装许可证》压力管道安装GB1、GB1(PE)、GC2级，公用管道GB2级安装资质，燃气经营许可证，燃气燃烧器具安装、维修许可证。曾先后获评“全国燃气工程建设50强企业”、“全国工程建设全面达标单位”、“淄博市最具影响力诚信企业（示范诚信企业）”、“新进基层党组织”等多项称号。
经营及服务范围包括：压力管道安装（限GB1、GBI(PE)、GC2级，备注：无损检测分包）、公用管道GB（限GB2(2)级，备注：无损探伤分包）、燃气经营、市政公用工程施工、管件、阀门、管材、防腐保温材料销售、设备租赁、燃气、燃烧器具销售、安装、维修等。目前，淄博绿能燃气工程有限公司施工工程已遍及河南、湖北、陕西及山东等各省，主管线总计长达200余公里，民用户多达5万多户，另外还包括鲁泰、凤阳、兰雁、齐鲁华信等中国知名企业在内的工商用户70余户，日供气量高达12万立方米，成为服务淄博万千用户的优质燃气供应企业。
项目建设背景 城市地下纵横交错的管道，给人们生活带来便利的同时，同时也埋藏着巨大的安全隐患。安全生产是实现能源行业高质量发展的重要保障。近年来，淄博绿能燃气工程有限公司不断加大信息化、智能化的建设投入，其部署的大型生产设备、能源设备、安全设备、运维系统等软硬件设备数量日益增多。但是，伴随而来的是公司资产运营管理与网络安全问题变得越来越复杂。
面对业务繁多、生产数据愈发庞大，各设备产生的日志分散记录在各处，无法全面采集与保存，如何实现安全运维的提质增效。
面对网络攻击、恶意连接等各类网络威胁行为泛滥，如何加强监测与预警，及时发现并告警，在事后提供审计溯源支撑。
面对燃气泄露、安全事故发生，如何第一时间抢险维修，增强应急突发事件的反应能力和处置能力，避免生产网络宕机。
因此，对淄博绿能燃气工程有限公司而言，现阶段全面保障燃气、液化气等管道设备系统的“可用性”、“完整性”、“保密性”是当前工作的首要任务和目标。
建设效果 针对淄博绿能燃气工程有限公司的具体需求，聚铭网络提出了采用聚铭综合日志分析系统（SAS）协助其推动网络安全防护建设的解决方案。该方案通过统一收集各终端、服务器、网络设备等设备日志，并进行集中关联审计分析，从而达到快速定位安全隐患的目的，为客户的管道安全保驾护航。
在信息集中采集和设备协调联动方面，聚铭综合日志分析系统以资产为核心，紧密结合淄博绿能燃气工程有限公司网络安全设备的实际情况，通过API、协议、镜像流量等手段接入现有安全设备和操作系统所产生的日志数据，实现了日志信息的统一采集和存储，打破了异构资产之间存在的壁垒，使其在应对威胁时能够做到统一协调、联防联控。
为了解决客户在日志分析方面存在的事件误报、效率难以提高等问题，聚铭综合日志分析系统通过利用三大网络日志分析引擎和四种流量安全分析策略，以及安全监控模版，能够将淄博绿能燃气工程有限公司内网系统中出现的网络攻击、设备故障、系统运行情况等信息进行多维度的关联分析，提高日志数据分析效率。并且系统内置了全球地理信息库，在面对黑客攻击等网络威胁时，能够准确、高效地定位威胁来源，为用户提供实时的全球攻击溯源展现。
最后，聚铭综合日志分析系统能够凭借每秒亿级（TB）日志查询能力，实时监控安全状态、告警安全异常，并留存日志信息180天以上。同时，系统内置多种合规模版，默认提供等级保护三级、SOX法案的分类，充分满足《网络安全法》、《关保条例》的相关要求。对于淄博绿能燃气工程有限公司后续推进等保合规建设，是切实必要的。
客户反馈 “以前我们总是担心生产安全问题，现在部署了聚铭产品，心里踏实多了。它能实时监控网络，一有异常就提醒我们，故障点定位超给力，妥妥的就是个“安全守护神”！而且，聚铭团队还给我们的运维实施人员做了系统性培训，包括日常安全操作、应急演练等，极大地弥补了我们在应急响应机制上的缺失，让我们的安全防护更加完善。安全没有假期，未来，绿能燃气将用实际行动去守护千家万户的用气安全！”
——淄博绿能燃气工程有限公司生产部负责人
关于聚铭 聚铭网络是由腾讯、国家中小企业发展子基金、江苏高投毅达宁海创业投资基金等投资的国内领先的安全运营商。公司先后荣获了“高新技术企业”、“江苏省专精特新企业”、“江苏省规划布局内重点软件企业”、“江苏省软件企业技术中心认定企业”、“南京市工程技术研究中心认定企业”、“双软企业”、“创新型企业家培育企业”、“创业南京高层次创业人才引进企业”、“国家工业信息安全监测应急支撑单位”、“数据安全10强企业”、“重点纳税企业”等荣誉，公司专注于网络安全智能分析和检测，提供全面的信息安全防护，为达成“让安全更简单”的使命而不懈努力。
凭借先进的技术和优质的服务，目前公司产品已服务教育、医疗、政府、电信、能源、金融等行业超10000家政企客户，云端托管客户超6500家。公司在北京、南京建立了双总部中心，同时在各地设有分支机构，公司业务覆盖全国31个省市及香港地区。
聚铭网络将始终秉承“客户导向、真诚合作、互利共赢、优势共享”的服务理念，以先进的技术、优秀的产品和专业的配套服务，引领国内网络安全行业的发展方向。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76ce650c5bfdf6b007471a8110e68fdd/" rel="bookmark">
			Linux安全之iptables的target
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux安全之iptables的target动作
我们在 iptables 中使用 target 动作，需要使用 -j 来指定动作，如 ACCEPT、 DROP、 REJECT等。
常用的动作
动作含义解释
ACCEPT
允许数据包通过
DROP
直接丢弃数据包，不给任何回应信息，客户端会感觉请求泥牛入海，直到过了超时时间才会有反应
REJECT
拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息
SNAT
源地址转换，解决内网用户用同一个公网地址上网的问题
DNAT
目标地址转换，请求响应时需要
MASQUERADE
是 SNAT 的一种特殊形式，适用于动态的、临时会变的IP 上
REDIRECT
在本机做端口映射
LOG
在/var/log/messages 文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca4c93436da461836af1bf3611a4144/" rel="bookmark">
			【Mybatis】我抄袭了Mybatis，手写一套MyMybatis框架：编写一个引入MyMybatis框架的正常项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章中，我们学习了使用mybatis框架连接mysql。在这篇文章中，我们将聚焦于我们的调用方，即相应的实际项目，其中包含了对mymybatis框架的引用。以一个常见而又典型的例子来说明这一点——制作一款学生管理系统（伪）。这个所谓的“项目”显然无法像之前那样，依靠创建jdbc连接并且一条一条地编写SQL语句来解决问题，因为任何一项正常的开发流程都不应该如此生硬。
我们需要根据实际情况，创造性地制定并设置一份含有相关内容的文档文件（也被称为“配置文件”）。其中，包含了各种数据库的具体参数信息。接下来，我们只需专注于编写具体的功能性代码以及正确传递所需的参数，并在这个基础上编写适当的SQL语句即可，与我们平常使用mybatis框架的场景无异，即和上一篇文章无太大的差别。
首先我们需要创建一个正常的maven项目。这里我们就叫做：my-mybatis-demo
正常的项目都会像我们这样引入一个jar包在pom文件中。
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.masiyi&lt;/groupId&gt; &lt;artifactId&gt;my-mybatis&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.masiyi&lt;/groupId&gt; &lt;artifactId&gt;my-mybatis-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.masiyi&lt;/groupId&gt; &lt;artifactId&gt;my-mybatis-core&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 这里面我们先暂且取名叫做my-mybatis-core，最基础的我们要有一个对应表数据结构的一个实体类。就是我们在上一篇中的user表。这里我们使用驼峰命名法。
package com.masiyi.entity; import lombok.Data; @Data public class User { private Integer id; private String name; private Integer age; } 这里的@Data是lombok中的注解，待会我们会在我们框架中引入，我们先不管。
之后我们需要有一个接口去定义我们的方法以实现SQL的编写。这里我们就叫userdao，里面定义了两个方法，一个是findAll()查询全部，一个是findById(Integer id)根据id查询。返回值则全是 List&lt;User&gt;。
package com.masiyi.dao; import com.masiyi.entity.User; import java.util.List; public interface UserDao { /** * 查询全部 * @return */ List&lt;User&gt; findAll(); /** * 根据id查询 * @param id * @return */ List&lt;User&gt; findById(Integer id); } 用过mybatis框架的同学肯定知道每一个dao接口肯定是有一个xml文件去对应的。而xml文件里面就是写我们sql的地方,这里面我们取名叫做UserMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dca4c93436da461836af1bf3611a4144/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d864954579aa50145146ab8c97a388/" rel="bookmark">
			批量插入数据库数据脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插5w条数据到表里面，如果一条一条insert会很麻烦
mysql版本：
DELIMITER $$：这行代码设置了新的定界符为$$，以替代默认的分号;。这是因为存储过程中可能包含多个SQL语句，为了区分每个语句的结束，需要使用不同于默认分号的定界符。
CREATE PROCEDURE InsertData()：这行代码定义了一个名为InsertData的存储过程。CREATE PROCEDURE是用于创建存储过程的语句。InsertData是存储过程的名称，您可以根据需要进行更改。
BEGIN和END：这两行代码标记存储过程的开始和结束。
DECLARE i INT DEFAULT 1;：这行代码声明一个名为i的整数型变量，并将其初始值设为1。在循环中，我们将使用这个变量来迭代插入操作。
WHILE i &lt;= 10 DO和END WHILE;：这两行代码定义了一个循环结构，只要i小于等于10，循环内的代码块就会被执行。
INSERT INTO your_table (column1, column2) VALUES (value1, value2);：这行代码表示插入一条数据到名为your_table的表中。您需要将your_table替换为实际的表名，将column1和column2替换为要插入数据的列名，将value1和value2替换为具体的值。
SET i = i + 1;这行代码将变量i的值递增1，以便进行下一次迭代。
最后，DELIMITER ;将定界符恢复为默认的分号;。
创建一个存储过程
DELIMITER $$
CREATE PROCEDURE insert_data()
BEGIN
DECLARE i INT DEFAULT 1;
WHILE i &lt;= 50000
DO
INSERT INTO your_table1(column1，column2) VALUES (value1, value2);
INSERT INTO your_table2(column1，column2) VALUES (value1, value2);
SET i = i + 1;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9d864954579aa50145146ab8c97a388/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df629f4914b7c164997c0d0a9a599dfa/" rel="bookmark">
			Fiber Golang 中的路由和中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		掌握 GoLang Fiber 中的路由和中间件艺术，以进行高效的 Web 开发 在网络开发领域中，创建一个有效地路由和管理各种任务的 Web 应用程序至关重要。路由决定了如何处理传入的请求，而中间件在执行任务，如身份验证、日志记录和请求解析等方面起着关键作用。在 GoLang Fiber 中构建 Web 应用程序时，理解路由并实现中间件是开发可扩展和高效 Web 应用程序的关键。在这个全面的指南中，我们将探讨 Fiber 中的路由细节，学习如何创建和处理路由，深入了解使用路由参数的动态路由，并掌握在 Fiber 应用程序中实现中间件的艺术。
Fiber 中的路由 路由是 Web 应用程序开发的核心。它定义了应用程序如何处理传入的请求。在 Fiber 框架中，路由是一个基本概念，允许您将 URL 映射到特定的函数，为应用程序的端点提供清晰的结构。
Fiber 的路由受到 Express.js 的启发，这是 JavaScript 世界中的一个流行的 Web 框架。它采用了简单直观的语法，开发者容易掌握。让我们深入了解 Fiber 中的路由。
创建和处理路由 要在 Fiber 中创建和处理路由，首先需要创建一个 Fiber 应用程序实例，然后为其定义路由。以下是在 Fiber 中创建和处理路由的基本示例：
package main import ( "github.com/gofiber/fiber/v2" ) func main() { app := fiber.New() // 定义根 URL 的路由 app.Get("/", func(c *fiber.Ctx) error { return c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df629f4914b7c164997c0d0a9a599dfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cc7de59865e516f35982f14b55b6782/" rel="bookmark">
			Mysql群集MHA高可用配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前瞻
什么是 MHA
MHA 的组成
MHA Node（数据节点）
MHA Manager（管理节点）
MHA 原理
MHA 的特点
搭建Mysql MHA高可用集群
实验流程
实验准备
实验要求 实验步骤 关闭防火墙，安全机制
修改 Master、Slave1、Slave2 节点的主机名
修改 Master、Slave1、Slave2 节点的 Mysql主配置文件/etc/my.cnf 在 Master、Slave1、Slave2 节点上都创建两个软链接
配置 mysql 一主两从
安装 MHA 软件
在所有服务器上配置无密码认证
在 manager 节点上配置 MHA
第一次配置需要在 Master 节点上手动开启虚拟IP
在 manager 节点上测试 ssh 无密码认证，如果正常最后会输出 successfully，如下所示。
在 manager 节点上测试 mysql 主从连接情况，最后出现 MySQL Replication Health is OK 字样说明正常。如下所示。
在 manager 节点上启动 MHA
查看 MHA 状态，可以看到当前的 master 是 mysql1 节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cc7de59865e516f35982f14b55b6782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2eb4b75a1177ce7e819c65416ce44b8/" rel="bookmark">
			嵌入式（二）单片机基础 | 单片机特点 内部结构 最小系统 电源 晶振 复位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章我们介绍了嵌入式系统
嵌入式系统（Embedded System）是一种特定用途的计算机系统，它通常嵌入在更大的产品或系统中，用于控制、监测或执行特定的任务。这些系统通常由硬件和软件组成，旨在满足特定的需求，如嵌入在家电、汽车、医疗设备、工业自动化、消费电子产品、通信设备等各种应用领域。
简单说嵌入式：就是嵌入到对象体中的专用计算机系统 三要素 嵌入 专用 计算机
嵌入式系统往往是一个较为复杂的系统，由单片机和硬件平台和嵌入式计算机系统等组成，其中的核心是嵌入式处理器
我们主要讲解单片机
文章目录 1 单片机基本介绍1.1 单片机组成1.2 单片机特点1.3 单片机分类1.4 单片机内部结构 2. 8051单片机内部结构2.1 CPU 核心2.2 ROM Flash 程序存储空间2.3 RAM 数据存储空间2.4 SFR 特殊功能寄存器 3 CC2530芯片介绍3.1 组成 4 单片机最小系统4.1 电源4.2 晶振4.2.1 定义种类4.2.2 基本时序周期 4.3 复位 5 编程 1 单片机基本介绍 1.1 单片机组成 单片机系统是经典的嵌入式系统
单片微型计算机简称单片机，他不是完成某一个逻辑功能的芯片，而是把一个计算机系统集成到一块芯片上，往往集合了如下一些部分
​ （1）CPU中央处理器
​ （2）RAM 随机存取存储器
​ （3）ROM 只读存储器
​ （4）定时/计数器/ IO接口
采用哈佛结构 Harvard结构
将程序 指令储存和数据储存分开的存储器 结构。拥有独立的指令总线和数据 总线，可以让取指与数据访问分开 进行，提高了执行效率。
而不是传统我们熟悉的冯诺依曼结构
1.2 单片机特点 1）高集成度，体积小，高可靠性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2eb4b75a1177ce7e819c65416ce44b8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/34/">«</a>
	<span class="pagination__item pagination__item--current">35/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/36/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>