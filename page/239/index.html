<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/348a789d5a9a32ad00f6a116603594dc/" rel="bookmark">
			YARN UI界面日志详解二——某个任务详细日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/NC_NE/article/details/118281875
一、任务日志在哪
前面我们已经了解了ResourceManager UI界面参考上一篇文章YARN UI界面日志详解一，我们也看到了下图：
就在Applications下的几个状态中，只要你是提交到yarn来管理的任务那一定在这几个状态中的某一个，所以弄清楚这几个状态的日志信息那我们就能知道某个任务的运行状况了。
在实际工作中NEW、NEW_SAVING、SUBMITTED这三个用到的概率还是非常低的，而ACCEPTED、RUNNING、FINISHED、FAILE、KILLED这五个那是经常使用的，所以我们重点关注：
ACCEPTED：接受状态，已经被队列（queue）接受，但是还没有开始执行。如果生产中有任务一直停留在这个状态，那就可能是队列资源是不充足。
RUNNING：运行状态，获得我集群资源正在计算，我们也看一下点进去查看运行的日志
FINISHED：完成状态，表示任务运行完成
FAILE：失败状态，表示任务运行失败，这个时候我们就应该点进去查看日志寻找失败的原因
KILLED：被杀死状态，这个一般都是人为强制kill的
二、某个任务Finished状态详解
我们点击FINISHED如图：
我们点击History就可以跳转到当前任务详细信息界面
我们看到三个重要的框，左边框Job是当前任务信息的菜单，每一个都是非常重要的对于了解当前任务的运行情况，我们详细讲解。
Overview：也就是我们上面看到的这张图，当前任务的概况
Counters：作业计数器，表示hive作业在Input,Map,Shuffle,Reduce,Output等各个阶段的定量数据，我们能够非常直观的看到任务处理的数据量，处理耗时和使用资源，这个非常有利于开发定位问题和后期性能优化
我们点击Counters链接，可以看到任务计数器的页面，分为如下7个部分(因为图太长我们分段讲解)：
1、File System Counters：文件系统计数器
注意：
HDFS: Number of read operations：表示一个作业内读取HDFS的次数，读取HDFS操作都是在map阶段，所以读取次数等于所操作表在Hdfs中的文件个数
HDFS: Number of write operations：表示一个作业写入HDFS的次数，写HDFS操作一般只发生在reduce阶段，所以写入次数就等于HDFS 的文件个数
FILE: Number of read operations：表示一个作业内读取本地文件的次数，读取本地文件一般只发生在reduce阶段读取数据操作（如果数据源来自本地那么map阶段会被统计到）
FILE: Number of write operations：表示一个作业写入本地文件次数，写入本地文件发生在shuffle阶段，还有reduce拉取数据阶段。
2、Job Counters：作业计数器
3、Map-Reduce Framework：MapReduce框架计数器
4、HIVE：hive计数器
5、Shuffle Errors：shuffle错误计数器
6、File Input Format Counters：文件输入格式的计数器
7、File Output Format Counters：文件输出格式计数器
Configuration：就是任务提交的时候的xml配置文件，里面都是一些相关的参数配置
Map tasks：当前任务的map tasks的详细信息
Reduce tasks：当前任务的reduce的详细信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e47eacb2f423900cfc6762f749847e0/" rel="bookmark">
			Vue3.0 为什么采用 Proxy？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Object.defineProperty() 作用：在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。
1. 基本使用
语法：Object.defineProperty(obj, prop, descriptor)
参数：
要添加属性的对象要定义或修改的属性的名称或 [Symbol]要定义或修改的属性描述符 看一个简单的例子
let person = {}; let personName = 'Li'; Object.defineProperty(person, 'namep', { get: function() { console.log('触发了get方法'); return personName; }, set: function(val) { console.log('触发了set方法'); personName = val; } }); console.log(person.namep); personName = 'Chelsy'; console.log(person.namep); person.namep = 'Allen'; console.log(person.namep); // 触发了get方法; // Li; // 触发了get方法; // Chelsy; // 触发了set方法; // 触发了get方法; // Allen; 通过这种方法，我们成功监听了person上的name属性的变化。
2.监听对象上的多个属性
上面的使用中，我们只监听了一个属性的变化，但是在实际情况中，我们通常需要一次监听多个属性的变化。
这时我们需要配合Object.keys(obj)进行遍历。这个方法可以返回obj对象上的所有可枚举属性组成的字符数组。（其实用for in遍历也可以)
下面是该API一个简单的使用效果：
var obj = { 0: 'a', 1: 'b', 2: 'c' }; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e47eacb2f423900cfc6762f749847e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80998cbc659bfae93462b8ac9180751c/" rel="bookmark">
			【红锁】Redis Jedis springboot 低版本 普通红锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文借鉴了CSDN和知乎上很多内容，不在此一一列举，在此对那些贡献自己知识和经验的人儿致敬。
目标
简单在Jedis低版本（JedisClient小于3.0）中实现Redis的红（宏）锁功能，解决集群环境对业务功能或代码块（定时任务、消息队列消费场景）进行加锁处理，解决并发下产的重复执行或并发执行导致的数据固话问题，仅供参考。
红锁简介 这个小白比较懒，摘录个简介（暂时不收引流费用，等我火的）：
https://blog.csdn.net/zlg40/article/details/123325830
必须的巨人肩膀依赖 &lt;!-- 大于等于3.0版本的有更成熟的包装可以用SetParams替换Lua脚本直接实现--&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt; &lt;/dependency&gt; 核心加解锁 /** * 加锁 * @author：reoverflow@qq.com * @param keyPrefix 键值前缀 * @return */ public boolean lock(KeyPrefix keyPrefix){ // 标记当前线程，防止误删其它线程锁 String uuid = UUIDUtil.uuid(); return this.lock(keyPrefix, "general", uuid); } /** * 加锁 * @author：reoverflow@qq.com * @param keyPrefix 键值前缀 * @param key 加锁唯一标识 * @param value 释放锁唯一标识 */ @SneakyThrows public boolean lock(KeyPrefix keyPrefix, String key, String value) { String realKey = keyPrefix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80998cbc659bfae93462b8ac9180751c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/825827d8e4a718050384ab79c9b202ec/" rel="bookmark">
			甜甜C语言—malloc()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一：函数简介二：函数机制（一）头文件函数原型（二）函数功能（三）返回值（四）参数传递 三：空间的释放（一）free()函数 四：函数使用（一）例题(二) 解题思路（三）答案示例 五：浅析与C++中new()函数的区别 一：函数简介 malloc的全称是memory allocation，中文叫动态内存分配，用于申请一块连续的指定大小的内存块区域。适用于我们事先不知道需要多大空间的情况。
说白了就是给系统要空间。
例如问题
首先输入一个整数n(1&lt;=n&lt;=100)，表示学生人数；
然后输入n行，每行包含一个学生的信息。
💕💕宝儿~在不了解“动态申请空间”之前，貌似这种问题我们也能够解决，就例如说直接定义一个“足够大”的数组，现在来想想这种行为就是“莽夫宝儿行为”，🔥🔥🔥哈哈哈哈。
什么叫“足够大”，现在是不是觉得有点儿可笑？
🚀🚀接下来我们学习使用malloc（）函数，通过n的具体值来进行内存空间的申请。
🚀🚀简单来说就是，你需要多少空间你就申请要多少，我会尽量满足你的要求。
注意是尽量满足，说明有时候动态申请空间不一定会申请成功。
具体要看我们申请空间的大小，以及系统能够提供的空间大小。
二：函数机制 （一）头文件 #include&lt;stdlib.h&gt; ;
或者#include&lt;malloc.h&gt;;
包含这两个头文件都可以正常使用malloc()和free(）函数。
malloc.h 动态存储分配函数头文件,当对内存区进行操作时,调用相关函数.
ANSI标准建议使用stdlib.h头文件,但许多C编译要求用malloc.h,使用时应查阅有关手册。
一般来说stdlib.h包含malloc.h。（搜的）
💕💕宝儿~，要我说咱们还是干脆直接使用stdlib.h头文件吧
函数原型 void *malloc(unsigned int size)；
返回指针，接收正整型参数。
（二）函数功能 其作用就是动态申请一个空间大小为 size 字节的内存空间。
（三）返回值 🚀若申请成功，则返回空间的首地址；
🚀若申请失败，则返回NULL指针；
这也就意味着，我们需要用一个指针来接收 malloc() 函数的返回值。
（四）参数传递 malloc() 接受的参数需要是字节数（正整数，这不用讲了吧，字节数都是正整数吧）
既然是这样，
那我们干脆使用sizeof（）函数求出一个对象所需要占用得字节数，
然后乘以n值，拿来当作所传递的参数，这不就行了吗，
简简单单，跟着我的节奏起飞✈️✈️✈️。
例1：
🚀int *num=(int *)malloc(n*sizeof(int)); //int类型 动态申请空间
实际过程是：利用 malloc() 函数动态申请了大小为 n*sizeof(int) 的内存空间，
然后强制转化成为 (int *) 类型，再赋值给指向 int 类型的指针 num
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/825827d8e4a718050384ab79c9b202ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ed3c12f594381286951c4e44e8b25d/" rel="bookmark">
			密码学-模幂运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模幂运算是对给定的整数p、n、a，计算，这个运算在密码学中应用极为普遍，RSA、ElGamal、DH交换等重要密码方案中都涉及模幂运算。
1、算法原理
模重复平方计算法：
算法步骤：
①将n表示为二进制， ，用一个数组保存n的各个数位，n共有r+1位。
②循环计算（用数组b保存所有中间结果）：先循环计算一系列结果：a^2 mod p，a^4 mod p，a^8 mod p，…，再把指数n的二进制表示中取值为1的位对应的a的幂相乘，即可得到最终结果。
2、代码实现
int main(int argc, char *argv[]) { int n,a,p; int nn[30],aa[30],bb[30]; cout&lt;&lt;"please input a and n: "; cin&gt;&gt;a; // 将键盘输入的值赋给a cin&gt;&gt;n; cout&lt;&lt;"Input a prime, p= "; cin&gt;&gt;p; cout&lt;&lt;endl; //将指数n表示为二进制 int temp,num,r; int i=0; temp=n; while(temp != 0) {	num = temp%2; nn[i] = num; i++; temp = temp/2; } r=i-1; cout&lt;&lt;"指数的二进制表示为: "; for (num=i-1;num&gt;=0;num--) //输出指数的二进制 cout&lt;&lt;nn[num]&lt;&lt;" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7ed3c12f594381286951c4e44e8b25d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1fb11734d11f6c400820ad920fa55d6/" rel="bookmark">
			回溯法求解简单装载问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：有一批集装箱要装上一艘载重量为W的轮船，其中编号为i(0&lt;= i&lt;=n-1)的集装箱的重量为wi。现要从n个集装箱中选出若干个装上轮船，使得他们的重量之和恰好为W。如果找到任何一种解，返回true,否则返回false。
思路：其实这道题运用了回溯法一个非常明显的特点，就是剪枝法。也就是狭义回溯法定义“回溯法=DFS+剪枝法”；另一种广义定义就是递归喽。
#include&lt;iostream&gt; using namespace std; int w[] = { 0,5,2,6,4,3 }; int x[100]; //这个x[]是用来判断是否选择装载，存放最优解向量的 int n = 5,W=10; int maxw = 0; void dfs(int i, int tw, int rw, int op[]) //求解简单装载问题 { //tw表示选择的集装箱重量和，rw代表剩下集装箱重量和，op表示一种装载方案 if (i &gt; n) //这个代表它把所有的集装箱都判断了是否装载，是走出递归的条件 { if (tw &gt; maxw) { maxw = tw; for (int j = 1;j &lt;= n;j++) { x[j] = op[j]; //这个x[]是用来判断是否选择装载，存放最优解向量的 } } } else { if (tw + w[i] &lt;= W) //左孩子结点剪枝 { op[i] = 1; //选取第i个集装箱 dfs(i + 1, tw + w[i], rw - w[i], op); } if (tw + rw - w[i] &gt; maxw) //虽然这步我有点小蒙，但是确实是如此 { op[i] = 0; dfs(i + 1, tw, rw - w[i], op); } } } void displaySolution(int n) { for (int i = 1;i &lt;= n;i++) { if (x[i] == 1) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1fb11734d11f6c400820ad920fa55d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6022653cce0e9fb0907fa8418279a83/" rel="bookmark">
			任务分配（分支限界法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
假设有n个任务需要分配给n个人执行，每个人只执行一个任务，每个任务只由一个人执行。第i个人执行第j个任务的成本是Cij(1&lt;=i,j&lt;=n), 求解初最小成本的分配方案。
下面这个表格就是代表成本
人员任务1任务2任务3任务419278264373581847694 优先队列的分支限界法：就是谁的lb小谁先出队列，就先进行拓展，然后一下子到叶子节点得出mincost=13,然后又轮到第二层的第一个，慢慢进行比较剪枝。
struct Node //队列结点类型
{
int no; //结点编号
int i; //表示当前结点属于解空间的第i层（根节点的层次为0），即准备为人员i分配任务
int x[MAXN]; //x[i]为人员i分配的任务编号
bool worker[MAXN]; //worker[i]=true表示任务i已经分配
int cost; //已经分配任务所需要的成本
int lb; //下界
bool operator&lt;(const Node&amp; s) const //重载&lt;关系函数&gt;
{
return lb &gt; s.lb; //这个就是lb按照升序进行排序
}
};
void bound(Node&amp; e) //求结点e的限界值
{
int minsum = 0;
for (int i1 = e.i + 1;i1 &lt;= n;i1++) //寻找每一行的最小值
{
int minc = INF;
for (int j1 = 1;j1 &lt;= n;j1++)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6022653cce0e9fb0907fa8418279a83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f81318ec90e48e36c50a18e0cd07c22/" rel="bookmark">
			当微软拼音输入法使用ctrl&#43;.打不出中文标点的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当微软拼音输入法使用 ctrl+. 打不出中文标点 那一定是你,打开了 设置/时间和语言/语言&amp;区域/微软拼音输入法/常规中的 “中文输入时使用英文标点”, 这个开关。 在这种情况下,无论你怎么切换组合键(CTRL+.),你都只能输出英文的标点符号,
这说明,'中文输入时使用英文标点’这个开关的优先级非常高,高于 CTRL+.的组合键.
所以,如果想解决使用组合键 CTRL+. 切换 中/英 标点符号,却打不出中文标点符号的问题, 就要首先关闭 '中文输入时使用英文标点’这个开关, 这样,才能让优先级低的,组合键 CTRL+. 正常生效工作. 另外附上,突然 win11 不见了输入法的解决方案, 这个方案是,百度经验大神-沈绻绻,给出的解决方案,亲测有效,
1.)右键开始按钮,
在弹出的下拉菜单中,点选’计算机管理’
2.)进入’计算机管理’,
在左侧半区列表中,点选’任务计划程序’
3.)展开’任务计划程序’到出现’TextServicesFramework’并点选它,
目录路径:任务计划程序/任务计划程序库/Microsoft/Windows/TextServicesFramework
4.)在中部窗口中,可以看到名称为’MsCtfMonitor’的,任务,
基本信息如下:
名称:MsCtfMonitor
位置:\Microsoft\Windows\TextServicesFramework
描述:TextServicesFramework monitor task
5.)在带有“状态,触发器,下次运行时间,上次运行时间,上次运行结果”的条目上,右键点击,
在弹出的下拉菜单中,点击’运行’,然后,查看’上次运行结果’字段是否变化成操作成功完成,
当此字段的值为:操作成功完成。（0x0）时,
任务栏右侧将出现之前消失了的输入法指示器.
至此,win11 输入法消失的问题,在不重启计算机的情况下,得以解决.
感谢,百度经验大神,沈绻绻,的无私分享,特此敬礼.
December the 13th 2021
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba03e256f8c14010330389b9987e779/" rel="bookmark">
			《复杂约束下的多目标优化算法》阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：约束多目标优化问题(CMOP)由于需要同时考虑目标和约束，特别是当约束极其复杂时，处理起来比较困难。最近的一些算法在处理具有简单可行域的CMOP时工作得很好，然而，对于具有复杂可行域的CMOP，大多数算法的有效性显著降低。针对这一问题，本文提出了一种多阶段进化算法，在进化的不同阶段逐一添加约束，并对约束进行处理。具体地说，该算法在初始阶段只考虑了少量的约束条件，可以使种群高效地收敛到具有良好多样性的潜在可行域。随着算法进入后期阶段，在前一阶段获得的解的基础上，考虑更多的约束条件来搜索最优解。此外，还提出了一种根据对无约束Pareto前沿的影响对约束处理优先级进行排序的策略，从而加快了算法的收敛速度。在五个基准测试套件和三个实际应用上的实验结果表明，该算法在处理复杂约束的多目标进化算法时，尤其是在处理复杂约束的问题时，性能优于几种最新的约束多目标进化算法。
文章目录 1 Introduction2 Related works and motivation2.1 现有的CMOEAs2.2 写作动机 3 The proposed algorithm3.1 MSCMO的概述3.2 算法中的关键技术3.3 对MSCMO的分析 4 Experimental study5 ConclusionReferences 1 Introduction CMOP(Constrained multi-objective optimization problems)可以被描述为：
M i n i m i z e F ( x ) = ( f 1 ( x ) , . . . , f m ( x ) ) ) s u b j e c t t o x ∈ Ω g i ( x ) ≤ 0 , i = 1 , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ba03e256f8c14010330389b9987e779/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae64ebe575baca9acb95fb791125a596/" rel="bookmark">
			MATLAB符号计算相关函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1．建立符号变量和符号常量 MATLAB提供了两个建立符号对象的函数：sym和syms，两个函数的用法不同。
(1) sym函数
sym函数用来建立单个符号量，一般调用格式为：
符号量名=sym(‘符号字符串’)
该函数可以建立一个符号量，符号字符串可以是常量、变量、函数或表达式。
应用sym函数还可以定义符号常量，使用符号常量进行代数运算时和数值常量进行的运算不同。下面的命令用于比较符号常量与数值常量在代数运算时的差别。
(2) syms函数
函数sym一次只能定义一个符号变量，使用不方便。MATLAB提供了另一个函数syms，一次可以定义多个符号变量。syms函数的一般调用格式为：
syms 符号变量名1 符号变量名2 … 符号变量名n
用这种格式定义符号变量时不要在变量名上加字符串分界符(‘)，变量间用空格而不要用逗号分隔。
2．建立符号表达式 含有符号对象的表达式称为符号表达式。建立符号表达式有以下3种方法：
(1)利用单引号来生成符号表达式。
(2)用sym函数建立符号表达式。
(3) 使用已经定义的符号变量组成符号表达式。
9.1.2 符号表达式运算
1．符号表达式的四则运算
符号表达式的加、减、乘、除运算可分别由函数symadd、symsub、symmul和symdiv来实现，幂运算可以由sympow来实现。
2．符号表达式的提取分子和分母运算
如果符号表达式是一个有理分式或可以展开为有理分式，可利用numden函数来提取符号表达式中的分子或分母。其一般调用格式为：
[n,d]=numden(s)
该函数提取符号表达式s的分子和分母，分别将它们存放在n与d中。
3．符号表达式的因式分解与展开 MATLAB提供了符号表达式的因式分解与展开的函数，函数的调用格式为：
factor(s)：对符号表达式s分解因式。
expand(s)：对符号表达式s进行展开。
collect(s)：对符号表达式s合并同类项。
collect(s,v)：对符号表达式s按变量v合并同类项。
4．符号表达式的化简 MATLAB提供的对符号表达式化简的函数有：
simplify(s)：应用函数规则对s进行化简。
simple(s)：调用MATLAB的其他函数对表达式进行综合化简，并显示化简过程。
5．符号表达式与数值表达式之间的转换 利用函数sym可以将数值表达式变换成它的符号表达式。
函数numeric或eval可以将符号表达式变换成数值表达式。
符号表达式中变量的确定 MATLAB中的符号可以表示符号变量和符号常量。findsym可以帮助用户查找一个符号表达式中的的符号变量。该函数的调用格式为：
findsym(s,n)
函数返回符号表达式s中的n个符号变量，若没有指定n，则返回s中的全部符号变量。
符号矩阵 符号矩阵也是一种符号表达式，所以前面介绍的符号表达式运算都可以在矩阵意义下进行。但应注意这些函数作用于符号矩阵时，是分别作用于矩阵的每一个元素。
由于符号矩阵是一个矩阵，所以符号矩阵还能进行有关矩阵的运算。MATLAB还有一些专用于符号矩阵的函数，这些函数作用于单个的数据无意义。例如
transpose(s)：返回s矩阵的转置矩阵。
determ(s)：返回s矩阵的行列式值。
其实，曾介绍过的许多应用于数值矩阵的函数，如diag、triu、tril、inv、det、rank、eig等，也可直接应用于符号矩阵。
符号微积分 符号极限 limit函数的调用格式为：
(1) limit(f,x,a)：求符号函数f(x)的极限值。即计算当变量x趋近于常数a时，f(x)函数的极限值。
(2) limit(f,a)：求符号函数f(x)的极限值。由于没有指定符号函数f(x)的自变量，则使用该格式时，符号函数f(x)的变量为函数findsym(f)确定的默认自变量，即变量x趋近于a。
(3) limit(f)：求符号函数f(x)的极限值。符号函数f(x)的变量为函数findsym(f)确定的默认变量；没有指定变量的目标值时，系统默认变量趋近于0，即a=0的情况。
(4) limit(f,x,a,’right’)：求符号函数f的极限值。’right’表示变量x从右边趋近于a。
(5) limit(f,x,a,‘left’)：求符号函数f的极限值。‘left’表示变量x从左边趋近于a。
例9-1 求下列极限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae64ebe575baca9acb95fb791125a596/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03f166b1a0bddb8440f5a6ce21a08677/" rel="bookmark">
			机器学习图像特征提取—Hu矩（Hu不变矩）原理及代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 矩的概念
2 Hu不变矩
3 利用opencv-python计算Hu矩
1 矩的概念 图像识别的一个核心问题是图像的特征提取，简单描述即为用一组简单的数据（图像描述量）来描述整个图像，这组数据越简单越有代表性越好。良好的特征不受光线、噪点、几何形变的干扰。图像识别发展几十年，不断有新的特征提出，而图像不变矩就是其中一个。
矩是概率与统计中的一个概念，是随机变量的一种数字特征。设X为随机变量，c为常数，k为正整数。则量E[(x−c)k]称为X关于c点的k阶矩。
比较重要的有两种情况：
1. c=0。这时ak=E(Xk)称为X的k阶原点矩
2. c=E(X)。这时μk=E[(X−EX)k]称为X的k阶中心矩。
一阶原点矩就是期望。一阶中心矩μ1=0，二阶中心矩μ2就是X的方差Var(X)。在统计学上，高于4阶的矩极少使用。μ3可以去衡量分布是否有偏。μ4可以去衡量分布（密度）在均值附近的陡峭程度如何。
针对于一幅图像，我们把像素的坐标看成是一个二维随机变量(X,Y)，那么一幅灰度图像可以用二维灰度密度函数来表示，因此可以用矩来描述灰度图像的特征。
不变矩(Invariant Moments)是一处高度浓缩的图像特征，具有平移、灰度、尺度、旋转不变性。M.K.Hu在1961年首先提出了不变矩的概念。1979年M.R.Teague根据正交多项式理论提出了Zernike矩。
2 Hu不变矩 Hu 距值具有旋转、缩放、镜像和平移不变性，也就是说相同或相似的形状经过旋转、缩放、平移变换后，其 Hu 矩值不变。对于彩色帐篷形状固定的障碍物，在无人机飞行过程中会产生缩放、平移等变化，但其 Hu 矩值变化不大；而对于火焰由于其面积和轮廓的无规律变化，其 Hu 矩值也会呈相应的无规律变化。Hu 矩是通过二阶和三阶中心矩可求得 7 个不变矩组，如下式所示。
由Hu矩组成的特征量对图片进行识别，优点就是速度快，缺点是识别率比较低，对于纹理比较丰富的图片，识别率低。
Hu不变矩一般用于识别图像中大的物体，对于物体的形状描述得比较好，图像的纹理特征不能太复杂，像识别水果形状，或者对于车牌中的简单字符的识别效果会相对好一些。
3 利用opencv-python计算Hu矩 #============hu不变矩============== # Hu不变矩的性质：（1）图像形状平移不变性；（2）图像形状尺度不变性；（3）图像形状旋转不变性。 # Hu不变矩的应用与意义：（1）图像形状匹配；（2）图像形状区分；（3）图像形状相似度计算。 import cv2 from datetime import datetime import numpy as np def test(img): moments = cv2.moments(img) humoments = cv2.HuMoments(moments) # 因为直接计算出来的矩可能很小或者很大，因此取对数好比较,这里的对数底数为e,通过对数除法的性质将其转换为以10为底的对数，一般是负值，因此加一个负号将其变为正的 humoments = -(np.log(np.abs(humoments)))/np.log(10) # 同样建议取对数 print(humoments) if __name__ == '__main__': #t1 = datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03f166b1a0bddb8440f5a6ce21a08677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dff3879476c62e38ff2dbfae69b07acd/" rel="bookmark">
			2022-05-12 Druid源码阅读——poolPreparedStatements是如何控制缓存游标的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Druid预编译SQL时，会检查是否开启poolPreparedStatements参数缓存预编译SQL，这些预编译的SQL存放在哪里？在什么时候进行存放？
1.如何开启poolPreparedStatements(PSCache)功能 需要注意的是，maxPoolPreparedStatementPerConnectionSize的加载顺序在poolPreparedStatements之后，如果将maxPoolPreparedStatementPerConnectionSize设置为负数，则poolPreparedStatements无法生效。
将druid.poolPreparedStatements配置项设置为true,此时maxPoolPreparedStatementPerConnectionSize默认为10。将druid.maxPoolPreparedStatementPerConnectionSize参数值设置为&gt;0的整数，也会开启此功能 2.预编译的SQL缓存在哪里？ 通过分析预编译SQL部分，可以发现这些内容被存放在连接持有者的statementPool属性中。
public final class DruidConnectionHolder { protected PreparedStatementPool statementPool; /** * 获得语句池 */ public PreparedStatementPool getStatementPool() { //如果语句池为空，则新建语句池，否则返回当前所持有的 if (statementPool == null) { statementPool = new PreparedStatementPool(this); } return statementPool; } } 也就是说，预编译的SQL，会被存放在当前连接的持有者中，这些预编译的内容不会被其他连接所共享。
3.预编译的SQL是什么时候被添加进缓存的？ 由于预编译SQL时，没有将语句缓存到语句池中，推测是在语句关闭时进行处理。
@Override public void close() throws SQLException { //如果当前语句已经被关闭(内部状态判断),则不进行处理 if (isClosed()) { return; } //判断当前连接是否被关闭(同样通过内部状态进行判断，此时如果为true，该连接处于等待回收或正在回收) boolean connectionClosed = this.conn.isClosed(); // Reset the defaults //如果当前开启了PSCache，并且连接没有被关闭，重置数值到默认 if (pooled &amp;&amp; !connectionClosed) { try { if (defaultMaxFieldSize !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dff3879476c62e38ff2dbfae69b07acd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ff9371177d000c582b2a4a57411d55/" rel="bookmark">
			docker-compose快速部署clickhouse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ClickHouse 是俄罗斯第一大搜索引擎 Yandex 开发的列式储存数据库。令人惊喜的是，这个列式储存数据库的性能大幅超越了很多商业 MPP 数据库软件，比如 Vertica,InfiniDB.
相比传统的数据库软件，ClickHouse 要快 100-1000X:
100Million 数据集:
ClickHouse 比 Vertica 约快 5 倍，比 Hive 快 279 倍，比 My SQL 快 801 倍
1Billion 数据集:
ClickHouse 比 Vertica 约快 5 倍，MySQL 和 Hive 已经无法完成任务了
1. 部署 Clickhouse 服务 1.1 创建clickhouse 数据存储目录
cd /data
mkdir clickhouse
1.2 创建clickhouse 工作目录
cd /home
mkdir clickhouse
cd clickhouse
mkdir config
1.3 docker-compose 启动镜像
version: '3' services: clickhouse: image: yandex/clickhouse-server:21.3.20-alpine container_name: clickhouse restart: always networks: - deng ports: - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27ff9371177d000c582b2a4a57411d55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83b87d0c421a5f3b8ed6b37fc49c801a/" rel="bookmark">
			图像或轮廓的Hu矩的定义、优缺点、适用范围,并利用OpenCV的函数HuMoments()和matchShapes()实现Hu矩的计算和轮廓匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文承接博主的上一篇博文：
什么叫图像或轮廓的空间矩、中心矩、归一化中心矩？并利用OpenCV的类Moments计算轮廓的这几个矩和质心位置
继续介绍Hu矩的相关知识。
Hu矩是由二阶和三阶中心距计算得到七个不变矩，Hu矩具有旋转、平移和缩放不变性，因此在图像具有旋转和放缩的情况下Hu矩具有更广泛的应用领域。
在博主的上一篇博文中介绍了归一化的中心矩的计算式。我们回顾一下：
我们令 n u j i = η j i nu_{ji}=η_{ji} nuji​=ηji​ ，则有Hu矩的七个矩的计算式如下：
h u [ 0 ] = η 20 + η 02 h u [ 1 ] = ( η 20 − η 02 ) 2 + 4 η 11 2 h u [ 2 ] = ( η 30 − 3 η 12 ) 2 + ( 3 η 21 − η 03 ) 2 h u [ 3 ] = ( η 30 + η 12 ) 2 + ( η 21 + η 03 ) 2 h u [ 4 ] = ( η 30 − 3 η 12 ) ( η 30 + η 12 ) [ ( η 30 + η 12 ) 2 − 3 ( η 21 + η 03 ) 2 ] + ( 3 η 21 − η 03 ) ( η 21 + η 03 ) [ 3 ( η 30 + η 12 ) 2 − ( η 21 + η 03 ) 2 ] h u [ 5 ] = ( η 20 − η 02 ) [ ( η 30 + η 12 ) 2 − ( η 21 + η 03 ) 2 ] + 4 η 11 ( η 30 + η 12 ) ( η 21 + η 03 ) h u [ 6 ] = ( 3 η 21 − η 03 ) ( η 21 + η 03 ) [ 3 ( η 30 + η 12 ) 2 − ( η 21 + η 03 ) 2 ] − ( η 30 − 3 η 12 ) ( η 21 + η 03 ) [ 3 ( η 30 + η 12 ) 2 − ( η 21 + η 03 ) 2 ] \begin{array}{l} hu[0]= \eta _{20}+ \eta _{02} \\ hu[1]=( \eta _{20}- \eta _{02})^{2}+4 \eta _{11}^{2} \\ hu[2]=( \eta _{30}-3 \eta _{12})^{2}+ (3 \eta _{21}- \eta _{03})^{2} \\ hu[3]=( \eta _{30}+ \eta _{12})^{2}+ ( \eta _{21}+ \eta _{03})^{2} \\ hu[4]=( \eta _{30}-3 \eta _{12})( \eta _{30}+ \eta _{12})[( \eta _{30}+ \eta _{12})^{2}-3( \eta _{21}+ \eta _{03})^{2}]+(3 \eta _{21}- \eta _{03})( \eta _{21}+ \eta _{03})[3( \eta _{30}+ \eta _{12})^{2}-( \eta _{21}+ \eta _{03})^{2}] \\ hu[5]=( \eta _{20}- \eta _{02})[( \eta _{30}+ \eta _{12})^{2}- ( \eta _{21}+ \eta _{03})^{2}]+4 \eta _{11}( \eta _{30}+ \eta _{12})( \eta _{21}+ \eta _{03}) \\ hu[6]=(3 \eta _{21}- \eta _{03})( \eta _{21}+ \eta _{03})[3( \eta _{30}+ \eta _{12})^{2}-( \eta _{21}+ \eta _{03})^{2}]-( \eta _{30}-3 \eta _{12})( \eta _{21}+ \eta _{03})[3( \eta _{30}+ \eta _{12})^{2}-( \eta _{21}+ \eta _{03})^{2}] \\ \end{array} hu[0]=η20​+η02​hu[1]=(η20​−η02​)2+4η112​hu[2]=(η30​−3η12​)2+(3η21​−η03​)2hu[3]=(η30​+η12​)2+(η21​+η03​)2hu[4]=(η30​−3η12​)(η30​+η12​)[(η30​+η12​)2−3(η21​+η03​)2]+(3η21​−η03​)(η21​+η03​)[3(η30​+η12​)2−(η21​+η03​)2]hu[5]=(η20​−η02​)[(η30​+η12​)2−(η21​+η03​)2]+4η11​(η30​+η12​)(η21​+η03​)hu[6]=(3η21​−η03​)(η21​+η03​)[3(η30​+η12​)2−(η21​+η03​)2]−(η30​−3η12​)(η21​+η03​)[3(η30​+η12​)2−(η21​+η03​)2]​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83b87d0c421a5f3b8ed6b37fc49c801a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0fb12d657ae88bd1cfaf56ce77c69d5/" rel="bookmark">
			Git Bash 中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 git bash 中查看文件列表或者执行 git status 的时候，中文文件名字显示不正常，会转译成反斜杠加3个数字的8进制 ASCII 编码。
解决方案： 第一步：设置终端显示的编码，git bash 窗口右键设置支持中文字符，选择 Options -&gt;Text，选择zh_CN、UTF-8
第二步：在 git bash 终端执行以下命令：
git config --global core.quotepath false git config --global gui.encoding utf-8 git config --global i18n.commitencoding utf-8 git config --global i18n.logoutputencoding utf-8 export LESSCHARSET=utf-8 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36b3fa3a713c87c56179f5c36c987fdd/" rel="bookmark">
			Mybatis-plus保存save并返回对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们使用mybatis-plus是使用this.save(pojo)后发现，后面的业务需要用到pojo的id，但是pojo的id是自动生成的，这时候就…，我们可以定义业务层的父接口去实现。上代码
1.定义父接口
import com.baomidou.mybatisplus.extension.service.IService; public interface IBaseService&lt;T&gt; extends IService&lt;T&gt; { /** * 保存并返回的方法 * @param t * @return */ T saveAndReturn(T t); } import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.forum.service.common.IBaseService; public class IServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt; extends ServiceImpl&lt;M , T&gt; implements IBaseService&lt;T&gt; { @Override public T saveAndReturn(T t){ this.saveOrUpdate(t); return t; } } 2.业务层sevice
@Service public interface UserService{ User saveAndReturnUser(User pt); } @Service @Transactional public class UserServiceImpl extends IServiceImpl&lt;UserMapper, User&gt; implements UserService { @Override public User saveAndReturnUser(User pt) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36b3fa3a713c87c56179f5c36c987fdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58271c0f1e42c9670bd7c88ace820cbb/" rel="bookmark">
			Mybatis/Mybatis-plus启动自动建表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用acttable实现
1.引入pom依赖
&lt;!--根据实体类生成表--&gt; &lt;mybatis-enhance-actable.version&gt;1.4.9.RELEASE&lt;/mybatis-enhance-actable.version&gt; ............. &lt;dependency&gt; &lt;groupId&gt;com.gitee.sunchenbin.mybatis.actable&lt;/groupId&gt; &lt;artifactId&gt;mybatis-enhance-actable&lt;/artifactId&gt; &lt;version&gt;${mybatis-enhance-actable.version}&lt;/version&gt; &lt;/dependency&gt; 2.修改配置文件application.properties或者.yml
添加如下配置
# 可以设置为create（纯创建）、add（添加新的不删除内容）、update（更新内容，推荐用）、none（啥都不干） actable.table.auto = update # 用于创建数据表的待扫描目录，该目录下的类如果有@Table注解，就会进行扫描 #你的实体类放的包 actable.model.pack = com.forum.entities # 创建类型，目前仅支持mysql actable.database.type = mysql # mybatis-plus自有的配置信息，key也可能是：mybatis.mapperLocations #看你用的是mybatis-plus还是mybatis，为这里用的是mybatis-plus mybatis-plus.mapper-locations = classpath*:com/gitee/sunchenbin/mybatis/actable/mapping/*/*.xml 3.修改启动类注解
@SpringBootApplication //mapper接口路径 @MapperScan(basePackages = {"com.gitee.sunchenbin.mybatis.actable.dao.*","com.forum.mapper"}) //扫包路径 @ComponentScan(basePackages = {"com.gitee.sunchenbin.mybatis.actable.manager.*","com.forum.*"}) @Slf4j public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 4.实体类 IBasePojo不用理会
import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableId; import com.baomidou.mybatisplus.annotation.TableName; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58271c0f1e42c9670bd7c88ace820cbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef68b7b95ee157faf86fd2c137ea986f/" rel="bookmark">
			Abp VNext 本地化Location(多语言)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、新建Common类库
CommonModule.cs
[DependsOn( typeof(AbpLocalizationModule), typeof(AbpVirtualFileSystemModule) )] public class CommonModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { Configure&lt;AbpVirtualFileSystemOptions&gt;(options =&gt; { options.FileSets.AddEmbedded&lt;CommonModule&gt;(baseNamespace: "Common"); }); Configure&lt;AbpLocalizationOptions&gt;(options =&gt; { options.Resources .Add&lt;Langue&gt;("en") //默认语言 .AddBaseTypes(typeof(AbpValidationResource)) .AddVirtualJson("/Localization/Resources"); options.DefaultResourceType = typeof(Langue); }); Configure&lt;AbpExceptionLocalizationOptions&gt;(options =&gt; { options.MapCodeNamespace("Langue", typeof(Langue)); }); } } } Langue.cs
[LocalizationResourceName("Langue")] public class Langue { } en.json
{ "culture": "en",//语种 "texts": { "HelloWorld": "Hello aaa!" } } zh.json
{ "culture": "zh", "texts": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef68b7b95ee157faf86fd2c137ea986f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1efecc3eae35bfdb2a03f9d8c1aa482/" rel="bookmark">
			Lenet 进行手写数字识别(pytorch)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：初入门深度学习，记录自己第一个成功的小实验，无参考意义
在我的Python项目下一共两个文件，一个用来定义模型，一个用来训练
目录 定义模型训练函数实验效果 定义模型 注意：由于Minist 手写数字是灰色图片即单通道，所以我们在经过两个卷积层之后只有16个通道，并且我在Lenet 的网络中加入了BatchNormal 正则化，经实验可以提高模型精度这里提出一个值得注意的点： x = x.view(-1, 16 x 4 x 4)，这里是将卷积层展开为全连接层，但是我看到网上都是写的(16 x 5 x 5)，我将自己图片经过卷积层后的输出通过计算得到的是(16 x 4 x 4)，于是我将它写为（16 x 4 x 4）并成功运行，经过实验我的想法是对的(原来我发现我的第一层卷积填充padding=0,所以计算后是(16 x 4 x4))，所以有些东西一定要自己思考且实践验证，这里给出一个计算卷积后输出大小的公式 ⌊(nh − kh + ph + sh)/sh⌋ × ⌊(nw − kw + pw + sw)/sw⌋. 即：输入高或宽nh 卷积核大小kernal_size(kh) 填充 padding(ph) 步幅 strid(sh) ,一定要对应好输出
import torch.nn as nn import torch.nn.functional as F class LeNet(nn.Module): def __init__(self): super(LeNet, self).__init__() self.conv1 = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1efecc3eae35bfdb2a03f9d8c1aa482/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65fa9e59c7238609072249288b4b89df/" rel="bookmark">
			《ROS2圆通》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装 参考：【1】《技术分享 | 详解ROS 2的安装步骤》
【2】《《动手学ROS2》2.3ROS2的安装》
【3】若网络受限，则使用镜像 《ros2镜像》
二、错误集解 2.1 ros2用colcon build出现错误：ModuleNotFoundError: No module named ‘catkin_pkg’ 错误如下：
Starting &gt;&gt;&gt; fishbot_navigation2 --- stderr: fishbot_navigation2 Traceback (most recent call last): File "/opt/ros/foxy/share/ament_cmake_core/cmake/core/package_xml_2_cmake.py", line 21, in &lt;module&gt; from catkin_pkg.package import parse_package_string ModuleNotFoundError: No module named 'catkin_pkg' CMake Error at /opt/ros/foxy/share/ament_cmake_core/cmake/core/ament_package_xml.cmake:94 (message): execute_process(/home/ros2/miniconda3/bin/python3 /opt/ros/foxy/share/ament_cmake_core/cmake/core/package_xml_2_cmake.py /home/ros2/code/fishbot_ws/src/fishbot_navigation2/package.xml /home/ros2/code/fishbot_ws/build/fishbot_navigation2/ament_cmake_core/package.cmake) returned error code 1 Call Stack (most recent call first): /opt/ros/foxy/share/ament_cmake_core/cmake/core/ament_package_xml.cmake:49 (_ament_package_xml) /opt/ros/foxy/share/ament_lint_auto/cmake/ament_lint_auto_find_test_dependencies.cmake:31 (ament_package_xml) CMakeLists.txt:34 (ament_lint_auto_find_test_dependencies) --- Failed &lt;&lt;&lt; fishbot_navigation2 [0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65fa9e59c7238609072249288b4b89df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05abd3c567cbbb59dd8b575135b0bfb9/" rel="bookmark">
			Asp.Net Core swagger接口文档添加Header
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、添加Filter类
public class JwtHeaderFilter : IOperationFilter { public void Apply(OpenApiOperation operation, OperationFilterContext context) { var isAuthorized = context.MethodInfo.GetCustomAttributes(typeof(AuthorizeAttribute),false); if (isAuthorized == null || isAuthorized.Length == 0) isAuthorized = ((Microsoft.AspNetCore.Mvc.Controllers.ControllerActionDescriptor)context.ApiDescription.ActionDescriptor).ControllerTypeInfo.GetCustomAttributes(typeof(AuthorizeAttribute), false); var allowAnonymous = context.MethodInfo.GetCustomAttributes(typeof(AllowAnonymousAttribute), false); if (allowAnonymous == null || allowAnonymous.Length == 0) allowAnonymous = ((Microsoft.AspNetCore.Mvc.Controllers.ControllerActionDescriptor)context.ApiDescription.ActionDescriptor).ControllerTypeInfo.GetCustomAttributes(typeof(AllowAnonymousAttribute), false); if (isAuthorized != null &amp;&amp; isAuthorized.Length &gt;= 1 &amp;&amp; (allowAnonymous == null || allowAnonymous.Length == 0)) { if (operation.Parameters == null) operation.Parameters = new List&lt;OpenApiParameter&gt;(); operation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05abd3c567cbbb59dd8b575135b0bfb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c7f23126ebd1e7c2c677ea44ec2d18/" rel="bookmark">
			JS基本语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.remainder 求余运算符 % 返回两个数相除得到的余数const remainder = 11%3;只要用%就行
2.在 JavaScript 中，可以通过在引号前面使用反斜杠（\）来转义引号。
const sampleStr = "Alan said, \"Peter is learning JavaScript\".";
3.
\' 单引号 \" 双引号
\\ 反斜杠
\n 换行符
\r 回车符
\t 制表符
\b 退格
\f 换页符
4.pop()是取出第最后数组，.shift()是取出第一个数组，而.unshift()是在数组头部加一个数组，b.push(a),在数组b里面添加a,a.slice(a, b) 截取数组以a开始，以b结束的数组，【a数组虽然被截取，但是原a数组不变】.splice(a,b,c,d)删除数组,两个参数，a是从索引为a的开始删除,b是删除b个数组，后面的参数是在索引为a后面加上c,d。
const threeArr = [1, 4, 6]; const oneDown = threeArr.pop(); console.log(oneDown); console.log(threeArr); 第一个 console.log 将显示值 6，第二个将显示值 [1, 4] console.log(threeArr .slice(2, 3)); 结果为6； 4.1.indexOf('a'),检查是否有a这个数组，没有返回-1，有就会返回数组的索引，同时也可以在字符串中使用，indexOf('a',3),从下标为开始查找.lastIndexOf(),跟indexOf一样是从后往前面寻找
（1）Math.max(...arr) 取出数组中最大的值
5.对象和 arrays 类似，区别在于数组使用索引来访问和修改数据，而对象中的数据是通过 properties 访问的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0c7f23126ebd1e7c2c677ea44ec2d18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e1c2e57b0b5e800c41233ce37a8d0c0/" rel="bookmark">
			.net core 3.1 使用jwt完成登录验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nuget安装：Microsoft.AspNetCore.Authentication.JwtBearer 3.1.0 版本
一、添加配置文件
"Authentication": { "JwtBearer": { "IsEnabled": "true", "SecurityKey": "Demo_C421AAEE0D114E9C1", "Issuer": "Demo", "Audience": "Demo", "Expiration": 60 //token过期时间 （单位：分钟） } } 二、添加一个扩展类和jwt配置文件类
public static class AuthConfigure { public static void ConfigureJwt(this IServiceCollection services, IConfiguration configuration) { if (bool.Parse(configuration["Authentication:JwtBearer:IsEnabled"])) { services.AddAuthentication(options =&gt; { options.DefaultAuthenticateScheme = "JwtBearer"; options.DefaultChallengeScheme = "JwtBearer"; }).AddJwtBearer("JwtBearer", options =&gt; { options.Audience = configuration["Authentication:JwtBearer:Audience"]; options.TokenValidationParameters = new TokenValidationParameters { // The signing key must match! ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e1c2e57b0b5e800c41233ce37a8d0c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95ab3d2698d2563da5839f94f36197b4/" rel="bookmark">
			gnome-shell cpu占用过高问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 gnome-shell cpu占用过高问题 gnome-shell cpu占用过高问题 网上搜了答案，结果都不能解决问题，当然了提升硬件性能也没什么问题，资源占用一样，性能提升占用就会下来了，我的电脑是4代i7 4770K，有点久远了。但是即使这样在用VMWare的时候也不至于虚拟机里面开个浏览器CPU都会飙到70%，整体操作起来的感受就是卡卡的。
最后想到打开浏览器都占用成这样了，浏览器一般会调用GPU资源，就想是不是没开启GPU图形加速的支持（server系统版本不需要），然后打开如下图的开关：
图形内存一般1GB足够了，我这个有点夸张了。重新打开虚拟机测试，不卡了CPU占用只有20%（操作的时候，不操作是个位数），GPU会看到有占用了，问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9c62760ed91876bdd5fa0cf6c017e07/" rel="bookmark">
			理解回溯法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理解回溯法 溯的本质是穷举，穷举所有可能，然后选出我们想要的答案。
回溯法解决的所有问题都可以抽象为树形结构！因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度构成的树的深度。
应用场景 回溯法，一般可以解决如下几种问题：
组合问题：N个数里面按一定规则找出k个数的集合切割问题：一个字符串按一定规则有几种切割方式子集问题：一个N个数的集合里有多少符合条件的子集排列问题：N个数按一定规则全排列，有几种排列方式棋盘问题：N皇后，解数独等等 局限性 耗时高，需要剪枝优化 代码模板 void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 回溯四部曲 1. 抽象出树形结构 把搜索过程抽象成树形结构。
最初的集合作为树的第一层；每次从集合中选取元素，可选择的范围随着选择的进行而收缩，需调整可选择的范围。 每次选取操作对应产生一个结果，作为树的下一层节点；当前集合中所有可能的选取操作，对应的结果构成树的下一层。 2. 回溯函数返回值以及参数 3. 回溯函数终止条件 达到终止条件后清空结果，回溯开始
4. 单层搜索的过程 回溯法的搜索过程就是一个树型结构的遍历过程，for循环用来横向遍历，递归的过程是纵向遍历。
通过控制变量（如索引）记录选取的位置，计算下一层递归开始的位置。
for (int i = startIndex; i &lt;= n; i++) { // 控制树的横向遍历 curPath.add(i); // 处理节点 backtracking(n, k, i + 1, curPath); // 递归：控制树的纵向遍历，下一层搜索要从i+1开始 curPath.remove(Integer.valueOf(i)); // 回溯：撤销处理的节点，重置到下一步横向遍历开始的状态 } 剪枝优化 回溯法虽然是暴力搜索，但有时候可以通过剪枝优化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9c62760ed91876bdd5fa0cf6c017e07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aac5c23333ce6638cc4c23f8619d26e/" rel="bookmark">
			vue-ant-design的Tree(树形结构)的父子节点关联问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 树形结构父子节点有关联的逻辑是：父节点选中，子节点自动选中，子节点全都选中，父节点自动选中。
项目需求是：父节点可以控制子节点，也就是点击选中父节点时，子节点全部选中，点击取消父节点时，子节点也随之取消；但是点击子节点选中或者取消都不会影响到父节点。
第一步：切断父子节点之间的关联。
checkStrictly控制父子节点关联，默认为false，表示父子节点有关联，将他的值改为true，切断父子节点之间的关联。
第二步：监控check事件，操作绑定数据checkedKeys。
点击复选框，e.checked为true，表示选中，为false，表示取消。
为true时，filter数据treeData，将父节点e.node.eventKey的子节点children里的key赋值给checkedKeys，这就完成了点击父节点，子节点自动选中的需求；
为false时，filter数据checkedKeys.checked，将父节点e.node.eventKey的子节点children里的key从checkedKeys里筛选出去，这就完成了取消父节点，子节点自动取消的需求。
onCheck(checkedKeys, e) { if (e.checked) { const arr1 = this.treeData.filter((item) =&gt; { return item.key === e.node.eventKey; }); if (arr1.length) { if (arr1[0].children) { arr1[0].children.filter((item) =&gt; { this.checkedKeys.checked.push(item.key); return item; }); } } } else { this.checkedKeys.checked = this.checkedKeys.checked.filter((item) =&gt; { return !item.startsWith(e.node.eventKey); }); } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47737c9c51e2955fa7760c198576b841/" rel="bookmark">
			网络安全 kali虚拟机中的渗透实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用工具：kali虚拟机 一台靶机（准备的WindowsXP靶机）
渗透实验过程
用kali攻击Windows的XP系统
1、 先扫描找漏洞（已经准备好了一个微软平台的08年的漏洞MS08.67）
2、 渗透成功之后，建立一个反弹的连接
3、 运用权限，远程建立一个用户
4、 留后门的工作暂时先不进行
5、 成功之后返回
登陆XP（靶机）虚拟机，使用cmd（win+R），ipconfig，得到ip地址
登陆kali虚拟机，打开命令行，使用命令msfconsole（注意：msfconsole命令使用之后，下面的图形是随机的）
show命令
serach命令（serach 你要找的内容）
复制整个name：exploit/windows/smb/ms08_067_netapi （漏洞名称）
利用漏洞：use命令，后接漏洞名称
有红色选取的内容代表已经进入攻击模块中了
蓝色*后：反弹连接还没有配置，to后是需要配置的路径，使用关键字set payload +路径
set payload命令:
Show option：上面是攻击机，下面是靶机
所有打上yes都要设置，上面还有RHOSTS没设置，使用set设置
target也没设置，要设置
通过show target来查看版本序列号，我们用的是XP SP2的中文简体，序列号是10
然后将target设置为10
在show option查看是否都已经补全了
发起攻击exploit
攻击成功之后会改成meterpreter
Shell命令：（进入目标系统的交互命令）
我打码的是我的IP和靶机IP 自己运行的是看看是不是自己的就行
Shell之后就进入了XP机，可以使用ipconfig命令查看现在的ip地址：
远程添加一个管理员帐号，用户名名tjn，密码：111111
使用net命令把新建的用户添加到Administrators管理员组中：
切换到XP中，开始——控制面板——用户账户中查看是否多出了你新建的用户
由此，攻击成功
切回kali
Exit退出攻击系统，ctrl+z退出msfconsole
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1be790f6b2b1f78a50fdc94a3c0bc1ac/" rel="bookmark">
			包含静态库.a文件编译报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 gcc/linux-x86/arm/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/lib/libg.a(lib_a-sbrkr.o): In function `_sbrk_r': sbrkr.c:(.text._sbrk_r+0x18): undefined reference to `_sbrk' /gcc/linux-x86/arm/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/lib/libg.a(lib_a-writer.o): In function `_write_r': writer.c:(.text._write_r+0x20): undefined reference to `_write' gcc/linux-x86/arm/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/lib/libg.a(lib_a-closer.o): In function `_close_r': closer.c:(.text._close_r+0x18): undefined reference to `_close' gcc/linux-x86/arm/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/lib/libg.a(lib_a-lseekr.o): In function `_lseek_r': lseekr.c:(.text._lseek_r+0x20): undefined reference to `_lseek' gcc/linux-x86/arm/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/lib/libg.a(lib_a-readr.o): In function `_read_r': readr.c:(.text._read_r+0x20): undefined reference to `_read' 包含了 printf 函数调用
检查是否包含 printf
nm libstatic.a |grep -wE "printf|malloc|fopen|fread" U printf 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff614460b776e568f8df37eb6ec1d475/" rel="bookmark">
			SSD（pytorch）自建数据集训练及测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据集准备 SSD代码：GitHub - amdegroot/ssd.pytorch: A PyTorch Implementation of Single Shot MultiBox Detector
采用的VOC格式的数据集，在data文件夹下新建文件夹VOCdevkit/VOC2007，数据集放在该路径下。数据集包括Annotations（放xml文件）、ImageSets、JPEGImages（放图片），ImageSets下又Main，包含test.txt、train.txt、val.txt、trainval.txt，用于划分数据集。
yolo格式数据集转VOC格式的代码如下：
24行：更改类别名，顺序要按yolo标注的顺序写
67、101行：更改图片格式
107行：更改图片的路径
216、218、220行：更改文件夹路径地址
# -*- coding: utf-8 -*- import os import xml.etree.ElementTree as ET from xml.dom.minidom import Document import cv2 ''' import xml xml.dom.minidom.Document().writexml() def writexml(self, writer: Any, indent: str = "", addindent: str = "", newl: str = "", encoding: Any = None) -&gt; None ''' class YOLO2VOCConvert: def __init__(self, txts_path, xmls_path, imgs_path): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff614460b776e568f8df37eb6ec1d475/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e85c1cc3f8279100a90a730a6f20dca/" rel="bookmark">
			【LINUX】Linux软件三种安装方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用三种安装方法： tar解压安装，相当于win便携版软件rpm命令安装，相当于win的exe文件直接安装yum在线安装，相当于win的点击exe会先下载然后安装 1. tar解压安装 安装包格式：tar、tar.gz 、tar.bz
tar -zxvf apache-tomcat-9.0.62.tar.gz -C /usr/ //解压即安装。 2. rpm命令安装 列出所有软件：rpm -qa安装软件： rpm -ivh [安装包]卸载软件： rpm -evh [package_name]查询安装路径：rpm -ql [package_name]升级软件：rpm -Uvh [package_name] 3. yum在线安装 安装： yum install [package_name]卸载： yum remove [package_name]查询： yum list installed 清除缓存命令:
yum clean packages: 清除缓存目录下的软件包
yum clean headers: 清除缓存目录下的 headers
yum clean oldheaders: 清除缓存目录下旧的 headers
yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f634e224ab4a5c991a8aa0c134b057c/" rel="bookmark">
			shell修改bin文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		od -tx1 old.bin 0000000 c8 00 00 00 55 01 00 00 dc 05 00 00 68 06 00 00 0000020 echo " c8 00 00 00 55 01 00 00 dc 05 00 00 68 06 00 00" | awk '{ gsub(" ","\s*"); print $0}' \s*c8\s*00\s*00\s*00\s*55\s*01\s*00\s*00\s*dc\s*05\s*00\s*00\s*68\s*06\s*00\s*00 od -An -v -tx1 old.bin | sed -e 's/^\s*c8\s*00\s*00\s*00\s*55\s*01\s*00\s*00\s*dc\s*05\s*00\s*00\s*68\s*06\s*00\s*00/c8 00 00 00 55 01 00 00 dc 05 00 00 68 06 00 00 af/g' | xxd -r -ps - new.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f634e224ab4a5c991a8aa0c134b057c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db1c703abbbeeed385ff7b22521f21a2/" rel="bookmark">
			解决安装ENVI5.3报错：the installation of MSVC_2010_SP1_x64_32bit has failed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前一阵子需要用到ENVI5.3软件，一直装不上老是报 the installation of MSVC_2010_SP1_x64_32bit has failed。setup will now exit的错，在网上找了很多参考的解决方法还是没能解决，最后自己瞎摸索着装上了，希望对大家有所帮助。
亲测有效！ 问题说明： 安装ENVI5.3时出现如下错误：
原因就是之前有安装过，因为很多软件都需要这个运行库。
解决办法： 找到无法安装Microsoft Visual C++ 2010 Redistributable原因
1、首先手动下载Microsoft Visual C++ 2010 SP1 Redistributable Package Microsoft Visual C++ 2010 SP1 Redistributable Package下载：
http://download.microsoft.com/download/C/6/D/C6D0FD4E-9E53-4897-9B91-836EBA2AACD3/vcredist_x86.exe（X86版）
http://download.microsoft.com/download/A/8/0/A80747C3-41BD-45DF-B505-E9710D2744E0/vcredist_x64.exe（X64版）
注意：这两个版本都需要下载
2、然后进行手动安装（X86与X64两个版本都需要操作） 1）执行安装包进行安装，会出现错误，注意这时一定先不要关闭安装窗口
2）去D盘或E盘找到名如“092b5421b8ec3b3b0cd1”一类的文件夹（可能会不一样）
3）将文件夹复制进行备份保留，然后关闭安装窗口
4）打开刚刚备份的文件夹找到“vc_red.msi"然后执行（如果出错去看第三步）
5）然后在控制面板中找到”Microsoft Visual C++ 2010 Redistributable“，然后进行卸载
这时电脑才具备安装Microsoft Visual C++ 2010 Redistributable的条件，再次安装envi即可成功
3、若第二步中执行”vc_red.msi“出错 如下图：
原因是注册表无法打开 XXX 由于某个错误无法打开该密钥
解决办法： 1、win+R输入：regedit
找到错误信息提示的路径，例如：
计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\UserData\S-1-5-18\Components\C7C03442DA9C85F5C81AC7DBAC07C526\0BDE39D306B8E0647874124EF06BDD09
2、修改注册表权限
1、右键——》权限——》高级
更改所有者——》高级——》立即查找，然后选择Administrators确定即可
2、
添加——》选择主体——》高级——》立即查找，然后选择Administrators确定
然后修改权限
应用即可。
再次运行备份文件夹中的vc_red.msi，可能会再次报错，然后一直按上述方法修改权限直到不报错为止（可能需要十几次）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db1c703abbbeeed385ff7b22521f21a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d57cc6135ac02871c4ea5bed896351ee/" rel="bookmark">
			数据源连接测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先需要打开MySQL并创建名为test的数据库，这里为了方便测试直接在命令行里执行：
mysql -hlocalhost -uroot -p
CREATE DATABASE test；
SHOW DATABASE;
2.需要在配置文件中导入几个坐标
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.testng&lt;/groupId&gt; &lt;artifactId&gt;testng&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3.连接测试
@Test //测试手动创建c3p0数据源 public void test1() throws Exception{ ComboPooledDataSource dataSource=new ComboPooledDataSource(); dataSource.setDriverClass("com.mysql.jdbc.Driver"); dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/test"); dataSource.setUser("root"); dataSource.setPassword("1234"); Connection connection=dataSource.getConnection(); System.out.println(connection); connection.close(); } @Test //测试手动创建druid数据源 public void test2() throws Exception { DruidDataSource dataSource = new DruidDataSource(); dataSource.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d57cc6135ac02871c4ea5bed896351ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/574142048f68ec9b5a29616e487584d4/" rel="bookmark">
			java两个时间戳如何求出相差小时数，且保留小数点后两位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两个时间戳求差 很简单的一个运算法则，假设开始时间与结束时间都能取到 分别为 startTime和endTime，都为Date类型。这时候要求取它们之间的差集，就把他们相减就可以了
差集 = endTime - startTime
此时需要注意 所取得的差集是一个long型的时间戳，要转换为小时，就要将这个差集除以一小时的毫秒数。
double 小时= (double)差集/60*60*1000
注意，此时用double转换这个小时呢，就是为了将其转换为有小数点的类型，因为一小时是3600000毫秒，如果两者差集小于这个数字，那么这样运算出来就为0，与我们想得到的结果就不符了。
但得到double类型是一个很长的小数，后面可能不止两位，这时候我们就要将其来个四舍五入，小数点后保留两位(当然这个保留多少位都是自己定义的)
BigDecimal a= BigDecimal.valueOf(小时); double waitTime = a.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue(); 这时候获取道得waitTime就是我们要得到的小数点后保留两位的小时数了。例如：0.5小时
具体代码如下：
long times = endTime -startTime; double hours = (double) times/(60*60*1000); BigDecimal a= BigDecimal.valueOf(hours); double waitTime = a.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue(); 通过这个例子举一反三，就可以算出相差多少年、月、日、时、分、秒啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39b746edaf9689c400038ba20a3da132/" rel="bookmark">
			Vue简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue 1：vue.js是什么 Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。（官网介绍）
2：前端工程化 模块化是对js的复用，组件化是对ui结构的复用
企业中的vue项目是基于工程化的方式进行的开发
3：vue起步 尝试 Vue.js 最简单的方法是使用 Hello World 例子。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以创建一个 .html 文件，然后通过如下方式引入 Vue：
&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"&gt;&lt;/script&gt; 或者：
&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2"&gt;&lt;/script&gt; 更多关于vue的基础在本文就不在介绍（菜鸟也不懂很多的知识，学习中）
更多关于vue的基础介绍详情请见：介绍 — Vue.js (vuejs.org)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd845eae5c676cb365ba30a0e5fce4c6/" rel="bookmark">
			Kubernetes 学习总结（28）—— Kubernetes 常见问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何删除不一致状态下的 rc、deployment、service 在某些情况下经常发现 kubectl 进程挂起现象,然后在 get 时候发现删了一半而另外的删除不了
[root@k8s-master ~]# kubectl get -f fluentd-elasticsearch/ NAME DESIRED CURRENT READY AGE rc/elasticsearch-logging-v1 0 2 2 15h NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deploy/kibana-logging 0 1 1 1 15h Error from server (NotFound): services "elasticsearch-logging" not found Error from server (NotFound): daemonsets.extensions "fluentd-es-v1.22" not found Error from server (NotFound): services "kibana-logging" not found 删除这些 deployment,service 或者 rc 命令如下:
kubectl delete deployment kibana-logging -n kube-system --cascade=false kubectl delete deployment kibana-logging -n kube-system --ignore-not-found delete rc elasticsearch-logging-v1 -n kube-system --force now --grace-period=0 1|2删除不了后如何重置etcd 删除不了后如何重置 etcd rm -rf /var/lib/etcd/* 删除后重新 reboot master 结点。reset etcd 后需要重新设置网络
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd845eae5c676cb365ba30a0e5fce4c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8973d6b566c282ee8a9cfc460d12bc5/" rel="bookmark">
			2022.05.10 Druid源码阅读——Druid预编译SQL的执行过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.检查连接状态 在Druid执行一条SQL预编译之前，将会通过内部状态检查当前连接状态，如果当前连接状态不可用(连接处于closed、disable、或者不被连接池所持有)，将不会继续进行SQL预编译
public void checkState() throws SQLException { final boolean asyncCloseEnabled; if (holder != null) { //从连接池中取出对应状态配置，否则默认为false asyncCloseEnabled = holder.getDataSource().isAsyncCloseConnectionEnable(); } else { asyncCloseEnabled = false; } //通过内部状态检查连接是否被关闭或处于关闭中 if (asyncCloseEnabled) { //如果开起了异步关闭连接选项，对当前连接加锁处理 lock.lock(); try { checkStateInternal(); } finally { lock.unlock(); } } else { checkStateInternal(); } } /** * 通过内部状态检查数据库连接，如果内部状态存在异常，将抛出异常 * @throws SQLException */ private void checkStateInternal() throws SQLException { if (closed) { if (disableError != null) { throw new SQLException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8973d6b566c282ee8a9cfc460d12bc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/905596f56dabb5f5af9f42df3a44d2f8/" rel="bookmark">
			v-model绑定子组件失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在父组件register.vue中注册并使用子组件Input（输入框）子组件部分代码如下
&lt;template&gt; &lt;input type="text" :placeholder="placeHolder" @focus="befocu = true" @blur="befocu = false" :class="{ beFocu: befocu }" /&gt; &lt;/template&gt; &lt;script&gt; export default { name: "Input", props: { placeHolder: { type: String, default: "", }, }, data() { return { befocu: false, //input框是否获得焦点 }; }, methods: {}, }; &lt;/script&gt; 父组件部分代码如下
&lt;Input v-model="uname" placeHolder="用户名" /&gt; &lt;Input v-model="pwd" placeHolder="密码" /&gt; &lt;Input v-model="phone" placeHolder="手机号" /&gt; &lt;Input v-model="code" placeHolder="验证码" class="code" /&gt; 在对输入框进行操作时父组件的data并没有发生变化
解决方法 在子组件中加入@input="(e) =&gt; $emit('input', e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/905596f56dabb5f5af9f42df3a44d2f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2908c48dd8bbbfc022023fd5cc3cc8a6/" rel="bookmark">
			[C&#43;&#43;] 一篇带你搞懂引用（&amp;）-- C&#43;&#43;入门（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题引入
在我们日常的生活中每个人都或多或少存在一个"外号"，例如《西游记》中孙悟空就有诸多外号：美猴王，孙行者，齐天大圣等等。那么在C++中，也可以给一个已经存在的变量取别名，这就是引用。
那么接下来深入来探讨一下引用
目录
1.引用的概念
1.1引用的表示方法
1.2引用特性
1.3常引用 引用权限
1.4引用的使用场景
1.4.1做参数
1.4.2做返回值 传值的底层过程：
引用导致野指针：
1.5值和引用作为返回值类型的性能比较
1.6引用和指针的区别
1.引用的概念 引用 不是新定义一个变量，而 是给已存在变量取了一个别名 ，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。 1.1引用的表示方法 类型 &amp; 引用变量名 ( 对象名 ) = 引用实体； 如果熟悉C语言的同学可能会发现引用符号(&amp;)看上去就像取地址运算符(&amp;)或者按位AND运算符(&amp;)，其实这是一个运算符重载的例子。通过重载，同一个运算符将会有不同的含义。编译器会通过上下文来确定运算符的含义。除了这里所提到的，其实在C++中还有一些运算符重载的情况。例如：* 即表示乘法，又表示对指针的解引用操作；&lt;&lt;即表示插入运算符，又表示按位左移运算符等。
代码实例：
int main() { //引用：取别名 int a = 10; int&amp; b = a;//定义引用类型 int&amp; c = b; return 0; } 本段代码我们可以得知，a变量取了b，c两个别名。
我们也可以通过调试观察他们的内存：
通过调取内存我们可以发现，a,b,c所指向的是同一块内存空间。
注意： 引用类型 必须和引用 实体 是 同种类型 的 1.2引用特性 引用有三个特性，分别是：
1. 引用在 定义时必须初始化 2. 一个变量可以有多个引用 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2908c48dd8bbbfc022023fd5cc3cc8a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7e73aa8a28c8680be599e81fd747b3/" rel="bookmark">
			Linux-京东字节百度提前批，一面二面都被问到了awk——实例篇（2）去重统计排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去年提前批我投了京东、字节和百度，一面，二面都被问到了awk，如果你会，并且还很熟悉，那肯定算是一个加分项了！好感度up up up！
基本原理本篇不再赘述。请阅读：
总结了200篇面经中的awk面试题，看看面试官会问什么！——原理篇
总结了200篇面经中的awk面试题，看看面试官会问什么！——实例篇
可能看完原理篇你还不是太清晰要怎么用，但是看完实例，绝对都能懂了！！
重复的实例，代码只写一遍，看的时候举一反三。涉及到的其他命令，在第一次出现时会进行说明。有需要注意的格式、重点等等，在讲到具体实例的时候会附上说明。 本篇讲解——实例篇（2）去重统计排序
文章目录 log.txt,统计一个文件中"ABCD"出现的次数（grep或awk）读入一个文件，文件每行按空格分开字符串，统计字符串a的个数——快手二面awk统计日志访问时间——58同城一面。统计当前目录下（包含子目录） java文件的代码总行数——字节电商一面删除一个文本文件中重复的行，且不改变原文件顺序给了一个10行10列数据，都是以逗号分隔，其中第五列数据可能有重复的，统计第五列不同数据出现次数——上海美团C++一面写Linux命令，给定下面的文件，对file和dir按照第二列分别排序，输出最大的那个——字节后端一面 互联网求职&amp;交流 优质资源共享 log.txt,统计一个文件中"ABCD"出现的次数（grep或awk） 用grep:
grep -o "ABCD" test.txt|wc -l grep用于查找字符串，常与|、cat、ps一起使用
grep -o只打印匹配到的字符，如果一行里面有多个匹配的字符串必须用-o
wc命令使用-l统计行数
用awk，（文件内容没有@@@）
awk '{s+=gsub("ABCD","@@@")}END{print s}' log.txt #用替换来解决 awk 'BEGIN{RS="111"}END {print --NR}' log.txt #用行分隔符来解决，注意出现的次数为行号-1 gsub(r,s [,t])全局替换，字符串t中所有与正则表达式r匹配的项都被替换为字符串s。函数返回值为替换的数量。如果省略t，则默认对$0（全部内容）进行替换。
RS：Record Separator，记录行分隔符；找到某某标志，让每个某某后的内容重新变成一行！！
读入一个文件，文件每行按空格分开字符串，统计字符串a的个数——快手二面 cat test.txt | awk -F" " '{print $0}' |grep -o "a"| wc -l awk统计日志访问时间——58同城一面。 如test.log如下：
123.125.72.61 - - [05/Dec/2018:00:00:02 +0000] "GET /index?page=1 HTTP/1.1" 200 16739 "-" "Mozilla/5.0 (compatible; YandexBot/3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a7e73aa8a28c8680be599e81fd747b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44657abb1b673f232f58da3d1386618b/" rel="bookmark">
			JAVAEE ---EL表达式和JSTL标签大总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该文是JSP程序设计学习的一部分
后续会更新系列笔记
文章目录 EL表达式和JSTL标签7.1EL表达式7.1.1EL表达式的概念及用法EL基本格式1.EL表达式可以访问数组元素2.EL表达式简单访问对象3.EL表达式获取类中属性的值 7.1.2EL隐藏对象1.参数访问对象1.1param对象1.2paramValues对象 2.作用域访问对象1.pageScope对象2.requestScope对象3.sessionScope对象4.applicationScope对象例--登录控制 7.2JSTL入门7.2.1JSTL概述7.2.2JSTL用法1.创建动态Web过程，，导入JSTL资源包2.新建JSP页面，在页面顶部加入taglib指令3.使用JSTL标签 7.3JSTL常用标签7.3.1表达式操作标签1.&lt; c:out&gt;2.&lt; c:set&gt;3.&lt; c:remove&gt;实例-改写登录案例 7.3.2条件标签1.&lt; c:if&gt;标签2.&lt; c:choose&gt; &lt; c:when&gt; &lt; c:otherwise&gt; 7.3.3迭代标签1.&lt; c:forEach&gt;例子-已知整型数组 2.&lt; c:forTokens&gt;例子--输入学号，年龄，姓名中间用逗号隔开(info)，要求数据分开 7.4JSTL其他标签7.4.1URL标签相关1.&lt; c:import&gt;2.&lt; c:url&gt;3.&lt; c:redirect&gt; 7.4.2国际化格式标签简介1.&lt; fmt:requestEncoding&gt;2.&lt; fmt:formatdate&gt; EL表达式和JSTL标签 7.1EL表达式 7.1.1EL表达式的概念及用法 EL表达式可以获取参数的值，获取隐含对象作用域中的属性的值，从而代替JSP页面中的复制代码。
是一种简单，容易使用的语言，简化了寻常获取页面数据的方式。
EL基本格式 ${表达式}
功能：计算花括号内表达式的值，将其转换成Sting类型并进行显示。
1.EL表达式可以访问数组元素 String name[]={"tom","jack"}; #将数组name存储在request对象范围中 request.setAttribute("arr_name",name); #用EL表达式获取其值 ${arr_name[0]} #输出tom 2.EL表达式简单访问对象 #str存储在request范围中 request.setAttribute("str","hello world"); #用java代码获取值 request.getAttribute("str"); #用EL表达式获取值 ${str} 3.EL表达式获取类中属性的值 #emoloyee表中有id，name属性 并有对应的方法 #jsp代码 request.getAttribute("emp.id"); request.getAttribute("emp.name"); #EL代码 ${emp.id} ${emp.name} EL表达式有两种操作符 .或[]
${emp.id}等同于 ${emp[id]}
[]适应性更广–当对象的属性名包含特殊字符或属性名是一个变量的值时候，只能用[]
7.1.2EL隐藏对象 根据功能可以分为：参数访问对象，作用域访问对象，上下文访问对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44657abb1b673f232f58da3d1386618b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/207537b1cf78120585c25159d246c027/" rel="bookmark">
			操作系统常见「名词解释」、「简答题」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下述名词和概念为查阅教材《计算机操作系统》汤小丹等著，和王道《操作系统考研复习指导》所得，部分源于网络。如有不当之处欢迎指出。
第 1 章 操作系统引论 1. 名词解释 操作系统
操作系统是控制和管理整个计算机硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其它软件提供方便接口和环境的程序集合。
分布式系统
分布式系统是网络操作系统更高级的形式，是一个统一的操作系统，资源进一步共享，对用户是透明的。处于分布式系统的多个主机处于平等地位，无主从关系。处理能力增强、速度更快、可靠性增强。
嵌入式系统
嵌入式系统是指在各种设备、装置或系统中，完成特定功能的软硬件系统。
并发
多个事件在同一时间间隔内发生。
微内核
微内核把操作系统分成若干分别完成一组特定功能的服务进程，等待客户提出请求。而系统内核只实现操作系统的基本功能，将更多操作系统功能放在核心之外，作为独立的服务进程运行。
2. 简答题 2.1 操作系统的目标是什么？它的主要作用是什么？
主要目标：方便性、有效性、可扩充性和开放性；
主要作用：
OS 作为用户与计算机硬件之间的接口OS 作为计算机系统资源的管理者OS 实现了对计算机资源的抽象 2.2 推动 OS 发展的主要动力表现在哪五个方面？
不断提高计算机资源利用率；方便用户；器件的不断更新换代；计算机体系结构的不断发展；不断提出新的应用需求； 2.3 简述操作系统与用户之间的接口有哪些？
操作系统提供的接口主要有两类：一类是命令接口，另一类是程序接口。
其中命令接口又分为联机命令接口（交互式命令接口）和脱机命令接口（批处理命令接口）。
2.4 操作系统的基本特征有哪些？它们之间的关系？
操作系统具有四个基本特征，分别是：
并发。多个事件在同一时间间隔内发生；共享。资源可供内存中多个并发执行的进程（线程）使用；虚拟。通过某种技术把一个物理实体变为若干个逻辑上的对应物，主要目的在于提高资源的利用率；异步。也称不确定性，指进程的执行顺序和执行时间的不确定性。 它们之间的关系为：
并发和共享是相互依存的。资源共享以程序（进程）的并发执行为条件，对资源共享实施有效管理，协调好诸多程序对共享资源的访问，提高程序并发执行的程度虚拟是实现独占资源共享的方式；异步是并发执行的表现形式。 2.5 简述微内核操作系统的优点和缺点
优点如下：
提高了系统的可扩展性；增强了系统的可靠性；可以移植性强；提供了对分布式系统的支持；融入了面向对象技术。 缺点如下：
微内核操作系统的运行效率有所降低 第 2 章 进程的描述与控制 1. 名词解释 进程
进程是程序的一次执行；进程是一个程序及其数据在处理机上顺序执行时所发生的活动；进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。 线程
线程是一个基本的 CPU 执行单元，也是程序执行流的最小单元，是被系统独立调度和分配的基本单位。
进程控制块 PCB
系统利用 PCB 来描述进程的基本情况和活动过程，进而控制和管理进程；PCB 是进程实体的一部分，是进程存在的唯一标志。 进程同步
在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。
进程互斥
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/207537b1cf78120585c25159d246c027/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d330107fba800804140d69021bcda21c/" rel="bookmark">
			213. 打家劫舍 II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原题链接：213. 打家劫舍 II
solution:
这题和打家劫舍的思路是一样的.
状态表示：dp[i]表示从前1~i个房子中选择,获得的最大金额
属性：求解的最大值
状态计算：以选或不选i进行判断。
①不选择i的时候:那么问题转化为从前1~i - 1中进行选择，获得的最大值dp[i - 1]
②选择i的时候：由于不能选择相邻的房子,因此最大值为dp[i - 2] + nums[i]
综上所述状态转移方程：dp[i] = max(dp[i - 1],dp[i - 2] + nums[i]]
！！！本题还有个特殊条件房间成一个环状,因此第一个房子和最后一个房子不能同时选择，因此只需要分情况进行讨论就行,分为dp1[1 ~ i - 1]和dp2[2 ~ i]，最后取最大值
class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(!n) return 0; if(n == 1) return nums[0]; vector&lt;int&gt; dp1(n + 1),dp2(n + 1); dp1[1] = nums[0]; for(int i = 2;i &lt;= n - 1;i++) { dp1[i] = dp1[i - 1]; dp1[i] = max(dp1[i],dp1[i - 2] + nums[i - 1]); } dp2[2] = nums[1]; for(int i = 3;i &lt;= n;i++) { dp2[i] = dp2[i - 1]; dp2[i] = max(dp2[i],dp2[i - 2] + nums[i - 1]); } return max(dp1[n - 1],dp2[n]); } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e89bf320998d9fe48bb11c8c2ac68b31/" rel="bookmark">
			前台RequestPayload传值 后台RequestBody 接收不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前台RequestPayload传值 后台RequestBody 接收不到 问题描述 字段值为standard_model的药具规格 后台接受值为null 问题定位：xss拦截 scriptPattern = Pattern.compile("and", Pattern.CASE_INSENSITIVE); input = scriptPattern.matcher(input).replaceAll(""); 后台进行了xss拦截 过滤器的原因 对and字符进行了过滤 导致参数standard_model变成了stard_model 由此后台取值出现问题 此类问题在之后漏洞修复的时候要注意 附：正确解决方法 /** * xss请求处理类 * */ public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper { HttpServletRequest orgRequest = null; private boolean isIncludeRichText = false; public static Pattern pattern_select = Pattern.compile("select",Pattern.CASE_INSENSITIVE); public static Pattern pattern_insert = Pattern.compile("insert",Pattern.CASE_INSENSITIVE); public static Pattern pattern_update = Pattern.compile("update",Pattern.CASE_INSENSITIVE); public static Pattern pattern_drop = Pattern.compile("drop",Pattern.CASE_INSENSITIVE); public static Pattern pattern_delete = Pattern.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e89bf320998d9fe48bb11c8c2ac68b31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8888bacc01a497131fd678b1b746bed9/" rel="bookmark">
			6 种数组扁平化实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式1：使用最基础的递归遍历方式 使用基础遍历的方式，然后遍历的item项是否为数组，如果是数组递归执行扁平化函数，并把执行的结果与之前concat，如果item项非数组，则直接将值push到最初定义的数组中。
function flatten (array) { let result = []; for (const item of array) { if (Array.isArray(item)) { result = result.concat(flatten(item)) } else { result.push(item) } } return result; } let array = [1, [2, 34, [12, 4]], 23]; console.log(flatten(array)); 方式2：使用reduce函数进行递归操作 function flatten (array) { return array.reduce((pre, current, currentIndex, array) =&gt; { if (Array.isArray(current)) { return pre.concat(flatten(current)) } else { return pre.concat(current) } }, []) } 方式3：while循环结合findIndex与扩展运算符 实现思路：使用while循环，循环判断条件，concat以后的数组中是否包含数组类型，如果包含，使用...扩展运算符进行展开并合并。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8888bacc01a497131fd678b1b746bed9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e08fa8dbdc5fd65e61e1e3fb7ab1ede6/" rel="bookmark">
			e.target 和 e.currentTarget 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		冒泡 &amp; 捕获 当触发一个元素的事件的时候，该事件从该元素的祖先元素传递下去，此过程为捕获，而到达此元素之后，又会向其祖先元素传播上去，此过程为冒泡。
&lt;div id="a"&gt; &lt;div id="b"&gt; &lt;div id="c"&gt; &lt;div id="d"&gt;哈哈哈哈哈&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; addEventListener addEventListener是为元素绑定事件的方法，他接收三个参数：
第一个参数：绑定的事件名第二个参数：执行的函数第三个参数： false：默认，代表冒泡时绑定true：代表捕获时绑定 target &amp; currentTarget false
我们给四个div元素绑定事件，且addEventListener第三个参数不设置，则默认设置为false。
const a = document.getElementById('a') const b = document.getElementById('b') const c = document.getElementById('c') const d = document.getElementById('d') a.addEventListener('click', (e) =&gt; { const { target, currentTarget } = e console.log(`target是${target.id}`, `currentTarget是${currentTarget.id}`) }) b.addEventListener('click', (e) =&gt; { const { target, currentTarget } = e console.log(`target是${target.id}`, `currentTarget是${currentTarget.id}`) }) c.addEventListener('click', (e) =&gt; { const { target, currentTarget } = e console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e08fa8dbdc5fd65e61e1e3fb7ab1ede6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d5ea0e8f58e523e6e3389e4bf6867af/" rel="bookmark">
			使用基础粒子群(PSO)算法求解一元及二元方程的Python代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看清风的数学建模视频，其中有两道题：
求一元函数的最值问题 题目
求函数 y = 11 s i n ( x ) + 7 c o s ( 5 x ) y =11sin(x)+7cos(5x) y=11sin(x)+7cos(5x)在 x ∈ [ − 3 , 3 ] x∈[-3,3] x∈[−3,3]内的最大值。流程图
代码实现 # 第一步，绘制函数图像 import numpy as np import matplotlib.pyplot as plt def func(x): return 11*np.sin(x)+7*np.cos(5*x) x0 = np.linspace(-3,3,1000) y0 = func(x0) fig,ax = plt.subplots() ax.plot(x0,y0) ax.set_title('y = 11sin(x)+7cos(5x)') # 第二步，设置粒子群算法的参数 n = 10 # 粒子数量 narvs = 1 # 变量个数 c1 = 2 # 个体学习因子 c2 = 2 # 社会学习因子 w = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d5ea0e8f58e523e6e3389e4bf6867af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce1d4828cc7a064082b34fac43e3fdc0/" rel="bookmark">
			【解决方案】MacOS遇到“无法打开xxx，因为Apple无法检查其是否包含恶意软件”，怎么处理。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 如图所示，“无法打开’xxx’，因为Apple无法检查其是否包含恶意软件”时，应该怎么处理？
解决方案 1.上述窗口不要关闭
2.打开“系统偏好设置”-&gt;“安全性与隐私”-&gt;“通用”，会看到如下所示的界面，选择“仍要打开”。
3.再次重新打开索要安装的Application，会看到如下界面，选择“打开”即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/426fbf828094c68735a940cd8e06320d/" rel="bookmark">
			完整的模型验证（测试，demo）套路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整的模型验证（测试，demo）套路：利用已经训练好的模型，然后给它提供输入（对外应用） import torch import torchvision.transforms from PIL import Image from torch import nn # 找到img.png图片----》相对路径的考察 img_path = "../image/airplane.png" # 读取图片 img = Image.open(img_path) print(img) # 输出：&lt;PIL.PngImagePlugin.PngImageFile image mode=RGB size=650x558 at 0x23C3CD62160&gt; # 已知 模型输入为32*32，所以需要对此图片进行变化 # 首先对png的通道数进行变化，png格式是四个通道，除RGB三通道外，还有一个透明通道 img = img.convert('RGB') # 然后对img size进行改变 transform = torchvision.transforms.Compose([torchvision.transforms.ToTensor(), torchvision.transforms.Resize((32, 32))]) img = transform(img) print(img.shape) # 输出torch.Size([3, 32, 32]) # 拷贝网络模型 class Peipei(nn.Module): def __init__(self): super(Peipei, self).__init__() self.model = nn.Sequential( nn.Conv2d(3, 32, 5, 1, 2), nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/426fbf828094c68735a940cd8e06320d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06eb0b9db6bb9f85db5d45b7ac1d10cc/" rel="bookmark">
			Focal and Global Knowledge Distillation for Detectors
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 概述 论文地址：链接
代码地址：链接
论文简介：
此篇论文是在CGNet上增加部分限制loss而来核心部分是将gt框变为mask进行蒸馏 注释：仅为阅读论文和代码，未进行试验，如有漏错请不吝指出。文章的疑惑和假设仅代表个人想法。
二. 详细 2.1 Focal Distillation 2.1.1 mask计算 此篇文章在目标检测蒸馏中对FPN层进行限制，正常的操作如下公式(1)所示：
\[L_{f e a}=\frac{1}{C H W} \sum_{k=1}^{C} \sum_{i=1}^{H} \sum_{j=1}^{W}\left(F_{k, i, j}^{T}-f\left(F_{k, i, j}^{S}\right)\right)^{2} \] 此篇文章将gt的mask引入到蒸馏中：
如下公式(2)，目标为1，背景为0，获得mask矩阵\(M_{i,j}\)
\[M_{i, j}= \begin{cases}1, &amp; \text { if }(i, j) \in r \\ 0, &amp; \text { Otherwise }\end{cases} \] 但是会出现一个问题，小目标的mask区域太小，比例严重失调会导致小目标的蒸馏效果比较差，解决方法是进行归一化操作，如下公式(3)所示，引用一个尺度(缩放)量\(S_{i,j}\) ， 前景尺度目标大小倒数，目标越大mask越大，但数值越小。背景为mask=0的倒数。也就是每个gt数值和为1，全部背景为1。
疑惑一： 假设前景gt为10，那么前景数值和为10，背景和为1，会不会导致比例失调？
\[\begin{gathered} S_{i, j}= \begin{cases}\frac{1}{H_{r} W_{r}}, &amp; \text { if }(i, j) \in r \\ \frac{1}{N_{b g}}, &amp; \text { Otherwise }\end{cases} \\ N_{b g}=\sum_{i=1}^{H} \sum_{j=1}^{W}\left(1-M_{i, j}\right) \end{gathered} \] 假设一： 假设修改为前景和为1，背景和也为1。前景每个gt数值和相同。如下公式(4)所示，\(N_{gt}\) 为gt的数量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06eb0b9db6bb9f85db5d45b7ac1d10cc/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/238/">«</a>
	<span class="pagination__item pagination__item--current">239/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/240/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>