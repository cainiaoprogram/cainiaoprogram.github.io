<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61b9558c49c8d60bbc13ba69d9231ec0/" rel="bookmark">
			回溯法解决8皇后问题(C&#43;&#43;实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在8×8的棋盘中，同一行，同一列。同一斜线上只能有一个“皇后”棋子
#include&lt;iostream&gt; using namespace std; #define MAX 8 int queue[8], sum = 0; void output() { for (int i = 0; i&lt;MAX; i++) { cout &lt;&lt; queue[i] + 1&lt;&lt; ' '; } cout &lt;&lt; endl; sum++; } int check(int n) { for (int i = 0; i&lt;n; i++) { if (queue[i] == queue[n] || queue[i] - queue[n] == n - i || queue[n] - queue[i] == n - i)	//判断斜率 return 1; } return 0; } void DFS(int n) { for (int i = 0; i&lt;MAX; i++) { queue[n] = i;	if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61b9558c49c8d60bbc13ba69d9231ec0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/184b9495c6717b2b6155f3f6ce764010/" rel="bookmark">
			用实际项目分析高并发-抢霸王餐（川味观）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 高并发的经验是许多网络开发人员追求的梦想，有了这样的经验在哪里找工作都有优势，同样的资质，有这个硬指标，那你就自信很多。而在实际工作中一些中小型公司很难碰到高并发场景，在这种场景下，如何提高吞吐量？如何降低响应时间？从这两个指标开始折腾到底。所以要获得高并发的经验：首先要有场景，有了场景，需要自己去了解方方面面相关的知识，在架构调优的同时，自己也能跟着成长了。
二、高并发设计核心 2.1 硬件层面 服务器加配（内存，硬盘） 2.2 软件层面 LSV，nginx负载均衡（分流）数据库分库分表，读写分离缓存：空间换时间（解决读）异步：慢慢处理（解决写） 2.3 架构方面 动静资源分离：图片，js，css资源文件前后台分离页面静态化（html进行缓存） 2.4 保证服务稳定性 限流 控制并发 Semaphone控制访问速率（令牌桶RateLimiter，漏桶） 降级熔断（保险丝）重试 三、实际项目如何落地 那我们了解要设计一个高并发项目大概需要的核心要点后，那在真实项目中是如何落地的呢？有没有一些比较成熟的中间件来帮助我们快速实现？这里分2种服务：dubbo，http(网关)
3.1 网关-Hystrix 1.协议转换：dubbo协议转换为http协议
2.统一api管理：环境隔离，api分组，api文档
3.提高效率：管理，开发
功能分析
1.签名鉴权
2.登录验证
3.数据Mock
4.参数校验
5.国际化翻译
6.熔断
7.降级
8.限流
9.扩展点
总结：网关统一对服务进行管理，我们通过网关后台配置，就可以简单对我们服务配置超时，限流，降级，熔断策略。（Hystrix实现原理后面再分析）
3.2 Dubbo-Sentinel 在复杂的生产环境下可能部署着成千上万的服务实例，当流量持续不断地涌入，服务之间相互调用频率陡增时，会产生系统负载过高、网络延迟等一系列问题，从而导致某些服务不可用。如果不进行相应的流量控制，可能会导致级联故障，并影响到服务的可用性，因此如何对高流量进行合理控制，成为保障服务稳定性的关键。Sentinel是面向分布式服务架构的轻量级限流降级框架，以流量为切入点，从流量控制、熔断降级和系统负载保护等多个维度来帮助用户保障服务的稳定性。
dubbo服务怎么引入sentinel?
Sentinel 提供了与 Dubbo 适配的模块 – Sentinel Dubbo Adapter，包括针对服务提供方的过滤器和服务消费方的过滤器。使用时用户只需引入相关模块，Dubbo的服务接口和方法（包括调用端和服务端）就会成为 Sentinel 中的资源，在配置了规则后就可以自动享受到 Sentinel 的防护能力。同时提供了灵活的配置选项，例如若不希望开启Sentinel Dubbo Adapter中的某个Filter，可以手动关闭对应的Filter。
sentinel控制台？
Sentinel的控制台（Dashboard）是流量控制、熔断降级规则统一配置和管理的入口，同时它为用户提供了多个维度的监控功能。在Sentinel控制台上，我们可以配置规则并实时查看流量控制效果。
总结：通过dubbo整合sentinel后，我们只需要通过sentinel控制台进行配置就可以轻松实现流控，降级等规则。
四、实际项目分析-抢霸王餐 我们要知道设计一个高并发系统更多的是依赖于我们所在公司的架构，比如是否有分库分表（读写分离），是否使用CDN，是否是分布式服务，是否实现负载均衡等，然后加上我们一个好的架构设计，更大程度上的提高系统的并发量（流量肖峰，缓存预热）；最后通过限流，降级，熔断保证服务的稳定性。
4.1 项目背景 前有淘宝“双十一”、京东“618”、小红书“66.过平台的影响力，来玩七点一刻抢霸王餐的活动，活动每晚七点一刻准时开始，手速最快的可以抢到霸王餐或赢免单机会，以此刺激消费者涌向我们平台，同时，分享活动给好友还可以提升中奖机会，刺激用户分享，为我们带来裂变式的传播；商家参与此活动，一来可以降低获客成本，为之带来私域流量，二来“赢免单机会”打的是心理战，可以促进消费。
4.2 项目预览 每晚进行直播，然后7.15进行抢霸王餐活动，领取现金红包。
1）创建霸王餐券
2）主播端
3）观众端
4.3 简要讲述一下设计要点 其实抢券和抢票，秒杀等都是同类问题。（抢券会少了个下单的过程）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/184b9495c6717b2b6155f3f6ce764010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e0389a9f8658750df532bd65aa7f21d/" rel="bookmark">
			注册和登录Github
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub 是一个面向开源及私有 软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。 GitHub 于 2008 年 4 月 10 日正式上线，除了 Git 代码仓库托管及基本的 Web 管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。GitHub 去年为漏洞支付了 16.6 万美元赏金。 2018年6月，GitHub被微软以75亿美元的价格收购。
github官网：https://github.com/
点击右上角 Sign In 注册：
注册后，点击 Sign up 登录
登录成功后，进入主页面：
（建议读一读 Read the guide）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d14a76a6302bb5191b9821ee77a4309b/" rel="bookmark">
			scrapy初学：爬百度图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫初学：基于Pycharm用scrapy爬取百度图片 初学爬虫选择工具功能说明具体内容和代码踩过的坑 初学爬虫 本人最近初学爬虫的相关知识和实现，这里简单介绍一下对如何用scrapy进行百度图片的抓取，记录一下自己踩过的坑。
选择工具 Pycharm 2020.1Scrapypython 3.8 功能说明 制作百度图片的scrapy爬虫，能够根据关键字下载百度图片并标明序号和进行存储。
具体内容和代码 由于scrapy工具有出色的表现和良好的口碑，因此一直想学习用scrapy来爬取数据。
在Pycharm中安装scrapy，运用Pycharm安装库方法即可，打开Pycharm后，点击File-&gt;Setting-&gt;Project
Interpreter后，选择弹出对话框的+，从选择包中选择scrapy安装即可。! 在这里插入图片描述
其中踩过的坑在后续章节中会写明。
安装完scrapy, 即可在Pycharm终端处通过命令
scrapy startproject projectname
建立爬虫项目，生成pipeline, setting等相关文件。这里我写的项目名称是BaiduScrapy。在./BaiduScrapy/Spiders文件夹下的新建爬虫的python文件：BaiduPicSpider.py，作为爬虫的类。
生成的项目目录如下图：
3.
后续修改以下程序实现目标工程：
Settings.py处增加：
ROBOTSTXT_OBEY = False MAX_PAGE = 30 IMAGES_STORE = './images' ITEM_PIPELINES = { 'BaiduScrapy.pipelines.BaiduImagePipeline': 300, } BaiduPicScrapy.py的代码为：
# -*- coding: utf-8 -*- # Define here the models for image scrape from scrapy import Spider, Request from urllib.parse import quote from BaiduScrapy.items import BaiduImageItem import json class ImageSpider(Spider): name = 'image' allowed_domain = ['images.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d14a76a6302bb5191b9821ee77a4309b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf2e63a4d0219c260f29b6d9114e399b/" rel="bookmark">
			多值依赖 模式分解 （学习感想）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模式分解，是关系规范化的手段，而关系规范化的实质就是概念的单一化，一事一地，（这里书上讲得挺好的），从而避免或减少增删改的异常/繁琐（以下统称异常）。
对于一个只有函数依赖的模式而言，我们把它分解到BCNF这个层次，那就彻底解决了增删改的异常，如（学生S，系Sd，宿舍D）有S→Sd，Sd→D，当我们把它分解为（学生S，系Sd）和（系Sd，宿舍D），就不用再考虑语义上的啥啥函数依赖了，增删学生或系，都不会造成异常，修改系主任名字也不用那么繁琐，当然了你要是修改系名，两个表都得改一下，毕竟你要满足参照完整性。至于如何把一个只含函数依赖的模式分解到BCNF，我在此就不多赘述了。
而对于含有非平凡非函数依赖的多值依赖的模式而言，如何分解到BCNF，如何分解到4NF呢？
我们先讲策略：在我们对一个含有函数依赖和非平凡非函数依赖的多值依赖的模式进行分解到BCNF时，不用考虑那个非平凡非函数依赖的多值依赖，直接忽略，就观察它的函数依赖，把它分解到BCNF即可。而要分解到4NF，同前面步骤一样，在BCNF的基础上，观察分解得到的各个BCNF关系，看是否仍存在非平凡非函数依赖的多值依赖，如果不存在那就是4NF，不用变了，如果有BCNF表仍存在双非多值依赖，那么按照书上定理，将双非多值依赖分解为平凡的非函数依赖的多值依赖即可，那么按照定理，它就是4NF。
回过头来说，对于一个只有函数依赖的模式而言，在分解它时，我们要考虑它的函数依赖和无损链接。无损链接是为了避免数据的丢失，而函数依赖是为了避免增删改的异常。这就是我们一般用到的模式分解的准则。
对于函数依赖而言，BCNF就已经到终极了。但对于双非多值（越写越短，下次非多）而言，这貌似才刚刚开始。但开始的晚并不意味它还能活很久，至少对于我们而言，到下一步的4NF就over了。
对于双，不对，非…，害算了，就叫双非多值叭，对于双非多值而言，其实书上，你们观察下书上的说法，存在双非多值依赖，增删改很不方便，数据冗余也很明显。然后提出利用4NF来消除双非，但4NF怎么就减少冗余了，4NF怎么就避免或减少增删改的异常了，emmm，它没有说。但，很明显的，减少存储冗余，那是显而易见的。
我举个很常见的多值依赖的例子，（课程C，老师T，参考书B）（全码，BCNF），分解为（课程C，老师T）和（课程C，参考书B）（都是4NF），这是书上的例子，很直观的，它减少了数据的存储冗余，这确实。但避免了增删改的异常了吗？就单这个例子而言，它确实也很直观的避免或减少了。如课程C1，有T1，T2两位老师，B1B2B3三本书，在原表中我要给C1加一位老师T3，那我就得添加3个元组，而在分解后的（课程C，老师T）和（课程C，参考书B）中只要加一个元组即可。
但你要说4NF对双非多值而言就像BCNF对于函数依赖而言那样，彻底解决它带来的增删改异常，这是不准确的。
对于简单的多值依赖，一个模式（X,Y,Z），只有X→→Y，你分解为4NF后确实彻底解决了增改异常（我也不知道有没有彻底解决，但我觉得挺彻底的），但你拿0129问的那道题：R（A,B,C,D）,有A→→C和C→→BD。分解为（AC）和（CBD），它的增删改仍是会异常，你在CBD中若只添加一个元组，就有可能破坏A→→C这一关系，所以还是很复杂的，你在原表中在不破坏它多值依赖的基础上对它增删改，其本身就是一个很复杂的事，而在4NF中仍然很复杂，不像BCNF中的函数依赖那样彻底解决。所以4NF对于多值依赖增删改的优化是有限的，越复杂的多值依赖，增删改越复杂。
题目中，要求的是把模式分解到4NF，那就按4NF定义，按分解定理分解到4NF就可以了，就像题目要求分解到3NF一样，3NF虽然没有彻底摆脱函数依赖带来的异常，但它是3NF呀，4NF虽然可能没有彻底解决双非多值带来的异常，但它是4NF。
我之所以会想这么多，就是步入误区了，我感觉0129发的那道题，答案不对呀，我在CBD中插入一个元组，并没有保持它原本的双非多值呀。这个思维是错的，当我们判断一种分解方式，如将模式分解为3NF，BCNF，是否正确，不是看我插入一个或删除一个元组，原本函数依赖是否不被破坏，而是根据定义BCNF、3NF各自的定义去判断的。又如我们在进行分解为3NF，BCNF时，都是要始终考虑原模式的函数依赖和无损连接的，只要跟着策略始终关注，那么求出的就是BCNF，就是3NF。
举个书上的例子，（学生S，教师T，课程J），它是3NF，那我在3NF种插入个元组，这个元组和已在的一个元组有点联系，S不一样，J不一样，但T一样（毕竟依赖时是一种语义，这样插入时也没破坏什么完整性，当然可能是我没接触到），这样插入后原本的函数依赖T→S就被破坏了呀，但你就就此否定它是3NF啦？这和我一开始步入的误区是一样的。你要说它不是3NF，你得给我什么证据，你得告诉我存在某个非主属性函数确定某个非主属性或者某个非主属性部分依赖候选码，要类似于违背3NF定义的证据。
而分解为4NF的话，就是要在BCNF基础上再考虑双非多值，按照策略分解出的就是4NF，而0129发的那题的答案就是按照策略求解出来的，我要说它不是4NF，我就得找到，这其中存在的双非多值。
最后补充一句，无损链接是基础要求，不管分解成什么，你都要无损连接。判断是否保持函数依赖，判断是否有无损连接性，判断是否分解成了3NF，各自的要求是不一样的，前两者出问题，那整个模式分解就是错的，而分解没问题还要看看是否达到3NF的标准。有功夫判断是否无损，说不定一看就看出哪哪哪不满足3NF定义了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09fa9a834cc259207db4356c3c66d781/" rel="bookmark">
			Docker学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五、Docker 1、简介 Docker是一个开源的应用容器引擎；是一个轻量级容器技术；
Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；
运行中的这个镜像称为容器，容器启动是非常快速的。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1hzHsWsw-1592984462082)(E:/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180303145450.png)]
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LhbSvZKc-1592984462085)(E:/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180303145531.png)]
2、核心概念 docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；
docker客户端(Client)：连接docker主机进行操作；
docker仓库(Registry)：用来保存各种打包好的软件镜像；
docker镜像(Images)：软件打包好的镜像；放在docker仓库中；
docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2fABJMZM-1592984462088)(E:/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180303165113.png)]
使用Docker的步骤：
1）、安装Docker
2）、去Docker仓库找到这个软件对应的镜像；
3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；
4）、对容器的启动停止就是对软件的启动停止；
3、安装Docker 1）、安装linux虚拟机 ​ 1）、VMWare、VirtualBox（安装）；
​ 2）、安装centos7
​ 3）、双击启动linux虚拟机;使用 root/ 960614登陆
​ 4）、使用客户端连接linux服务器进行命令操作；
​ 7）、查看linux的ip地址
ip addr ​ 8）、使用客户端连接linux；
2）、在linux虚拟机上安装docker 步骤：
1、检查内核版本，必须是3.10及以上 uname -r 2、安装docker yum install docker 3、输入y确认安装 4、启动docker [root@localhost ~]# systemctl start docker [root@localhost ~]# docker -v Docker version 1.12.6, build 3e8e77d/1.12.6 5、开机启动docker [root@localhost ~]# systemctl enable docker Created symlink from /etc/systemd/system/multi-user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09fa9a834cc259207db4356c3c66d781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42359d0464e160833f40364c920dc50b/" rel="bookmark">
			LTE信令流程——去附着
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LTE信令流程 去附着 去附着流程允许UE通知网络侧，UE不想再进入EPS，或是网络侧通知UE不允许再进入EPS网络。按照去附着的触发源不同，可以分为UE发起的去附着和网络发起的去附着。对于无线侧来说，常见的UE发起的去附着。
1. 连接态UE发起的去附着 具体流程如下：
处于RRC_Connection态的UE进行DETACH过程，向eNB发送 UL NAS Transfer 消息，包含NAS层的Detach Request 消息eNB 向MME发送 上行直传UPLINK NAS Transport消息，包含NAS层的Detach Request 消息MME 向 Serving-GW发送 Delete Session Request消息，以删除 EPS承载Serving-GW 向MME 发送 Delete Session Response消息，以确认 EPS承载删除MME向基站发送下行直传DOWNLINK NAS TRANSPORT消息，包含NAS层Detach accept消息eNB向UE发送DLInformationTransfer消息，包含NAS层Detach accept消息MME向eNB发送UE CONTEXT RELEASE COMMAND消息，请求eNB释放UE上下文信息eNB接收到UE CONTEXT RELEASE COMMAND消息，向UE发送RRCConnectionRelease消息，释放RRC连接eNB释放UE上下文信息，向MME发送UE CONTEXT RELEASE COMPLETE消息进行响应 2. 连接态MME发起的去附着 MME发起的Detach过程与UE发起的类似，只是Detach Request消息由MME发起
3. HSS发起的去附着 由 HSS 向MME/SGSN 发送 Cancel Location 消息，通知MME/SGSN 进行去附着MME/SGSN 发送 去附着请求 给UEMME/SGSN向 Serving-GW发送 Delete Session Request消息，Serving-GW转发给PDN GW，以删除EPS承载PDN GW回复 Delete Session Response 消息给Serving-GW，Serving-GW转发给MME/SGSNUE向MME/SGSN发送 Detach Accept 消息，通知其接受去附着请求MME/SGSN向HSS回复 Cancel Location ACK消息UE到 MME/SGSN 的信令连接被释放，详细步骤同（1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42359d0464e160833f40364c920dc50b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76400ed086c46f5d5a244c45065c698d/" rel="bookmark">
			【Java学习-进阶】-Spring Boot 的Log4j2配置和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在pom.xml中加入maven依赖 pom.xml加入log4j2，并同时把spring boot默认的logging去掉（解决依赖冲突）
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt;&lt;!-- 去掉默认配置 --&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!-- 引入log4j2依赖 --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、添加配置文件 在src/main/resource加入log4j2-spring.xml配置文件，取名一定是log4j2-spring，这样省的在application.yml配置
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt; &lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&gt; &lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt; &lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt; &lt;configuration scan="true" scanPeriod="600 seconds"&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。 --&gt; &lt;springProperty scope="context" name="appName" source="spring.application.name"/&gt; &lt;springProperty scope="context" name="hostIp" source="spring.cloud.client.ip-address"/&gt; &lt;springProperty scope="context" name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76400ed086c46f5d5a244c45065c698d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b520497007d880e6ab7d2236d390a37f/" rel="bookmark">
			tensorflow各个版本与cuda版本的对应关系~10月最新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux/ubuntu系统
macOS
Windows10系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70a3173de378a917b4abe2be0954b3a8/" rel="bookmark">
			最小二乘法——拟合平面方程（深度相机外参标定、地面标定）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.最小二乘法 最小二乘法（又称最小平方法）是一种数学优化技术。它通过最小化误差的平方和寻找数据的最佳函数匹配。利用最小二乘法可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最小。最小二乘法还可用于曲线拟合。其他一些优化问题也可通过最小化能量或最大化熵用最小二乘法来表达。
最小二乘法的矩阵形式为：
A x = b Ax=b Ax=b
其中 A A A 为 n ∗ k n * k n∗k 的矩阵， x x x 为 k ∗ 1 k*1 k∗1 的列向量， b b b 为 n ∗ 1 n*1 n∗1 的列向量。如果 n &gt; k n&gt;k n&gt;k（方程的个数大于未知量的个数），这个方程系统称为矛盾方程组 Over Determined System，如果 n &lt; k n&lt;k n&lt;k（方程的个数小于未知量的个数），这个系统就是Under Determined System。
当找到向量 x x x 使得 ∣ ∣ A x − b ∣ ∣ ||Ax-b|| ∣∣Ax−b∣∣ 最小，则 x x x 为该方程的最小二乘解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70a3173de378a917b4abe2be0954b3a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc84deea1d221112bacd070cc35d8dbe/" rel="bookmark">
			安装Windows Server 2016操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先准备镜像文件 进入msdn官网
https://msdn.itellyou.cn/
选择你需要安装的版本 这里以下面为例
2.复制之后打开迅雷 输入复制内容 下载
3.打开虚拟机（VMware）
4.选择新建虚拟机，选择自定义 点下一步
5.接着上面的下一步 这步继续下一步（我这里是12的版本 你也许是15的版本 总之下一步就好了）
6.看图所示
7.看图
8.选择安装路径
9.如下图
10.处理器配置
如何确定上面的数字怎么填写 找到你的windows资源管理器(此电脑)右击选择管理
找到处理器
可以看出来我又8个 处理器数量成以每个处理器的内核数不能超过8 超过了用不了注意一下 所以我才用2*2
11.为了快点 选择4GB
12.就选着这个默认的 不要选其他的
13.继续默认
14.因为自己使用 不需要多文件（多文件给人分享的时候单独一个的内存小好分享） 此处选择单文件 当然看需求
15默认下一步即可
16完成即可
至此创建完成
到此虚拟机创建完成
现在开始装操作系统
第一步 别点击打开虚拟机
1.看箭头看图 下面不再赘述
2.重点： 现在点击打开虚拟机 点击鼠标让虚拟机获取焦点 同时快速按任意键执行安装 如果失败就重启虚拟机 再次这么操作
在这里重启
成功后：（如果你想鼠标出来ctrl+Alt）
下一步 然后开始安装
自定义
新建
然后点应用 会有弹出框 点确定 不点下一步着
然后就是一个漫长的安装过程
输入密码必须复杂：数字+字母+特殊字符 且自己的记得住 弄好点击完成
然后就自己来到桌面 按提示解锁即可
收入刚才的密码
到此成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc84deea1d221112bacd070cc35d8dbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c93ae3bfcbc34638f8cae1ad2ce58a42/" rel="bookmark">
			【node报错解决方案】Error: Cannot find module http-errors
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出错描述 在node里面用express新建一个项目之后，输入
npm start 系统报错，报错如图：
解决方案 在新建项目之后，应再输入命令：
npm install 把其他的一些依赖模块装入。然后再输入
npm start 就可以正常开启项目了。
出错原因 express创建项目的时候，对于一些库，例如http-errors，这些库不是node自带的核心模块，但是确是express框架必须要用到的。所以得用命令
npm install 初始化一下，把这些express依赖的库装入。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af4ae162ecffeca950b57653d25f118f/" rel="bookmark">
			ES-cat相关命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /_cat/allocation #查看单节点的shard分配整体情况 /_cat/shards #查看各shard的详细情况 /_cat/shards/{index} #查看指定分片的详细情况 /_cat/master #查看master节点信息 /_cat/nodes #查看所有节点信息 /_cat/indices #查看集群中所有index的详细信息 /_cat/indices/{index} #查看集群中指定index的详细信息 /_cat/segments #查看各index的segment详细信息,包括segment名, 所属shard, 内存(磁盘)占用大小, 是否刷盘 /_cat/segments/{index}#查看指定index的segment详细信息 /_cat/count #查看当前集群的doc数量 /_cat/count/{index} #查看指定索引的doc数量 /_cat/recovery #查看集群内每个shard的recovery过程.调整replica。 /_cat/recovery/{index}#查看指定索引shard的recovery过程 /_cat/health #查看集群当前状态：红、黄、绿 /_cat/pending_tasks #查看当前集群的pending task /_cat/aliases #查看集群中所有alias信息,路由配置等 /_cat/aliases/{alias} #查看指定索引的alias信息 /_cat/thread_pool #查看集群各节点内部不同类型的threadpool的统计信息, /_cat/plugins #查看集群各个节点上的plugin信息 /_cat/fielddata #查看当前集群各个节点的fielddata内存使用情况 /_cat/fielddata/{fields} #查看指定field的内存使用情况,里面传field属性对应的值 /_cat/nodeattrs #查看单节点的自定义属性 /_cat/repositories #输出集群中注册快照存储库 /_cat/templates #输出当前正在存在的模板信息 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b55bd8e6207cb264a75e2681904a9e90/" rel="bookmark">
			win10查看设备序列号、硬盘序列号、mac地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 设备序列号
wmic bios get serialnumber
2. 查看硬盘序列号
wmic diskdrive get serialnumber
3. mac地址
控制面板\网络和 Internet\网络连接\以太网\详细信息
4. 查看磁盘ID
（1）打开cmd
（2）执行diskpart命令，windows会打开一个新的cmd窗口
（3）执行list disk命令，cmd窗口会展示磁盘列表并排好序了
（4）依据排序执行查询命令：select disk 0, 代表选中第0个磁盘，界面会提示当前已进入指定磁盘
（5） 执行命令：detail disk，查看详细信息。此时展示的信息中，“磁盘ID”就是我们要的硬盘序列号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ea81a19f46f2b8688bc4f6d9ef6d92a/" rel="bookmark">
			mercurial使用_使用Mercurial管理源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UNIX和Linux系统上的源代码管理 识别并跟踪多个开发人员所做的更改，并将其合并到一个最新的代码库中，便可以进行协作的多开发人员项目。 VCS软件（也称为修订控制系统（RCS）或源代码管理（SCM）系统）使多个用户可以将更改提交到相同的文件或项目，而一个开发人员的更改不会意外覆盖另一人的更改。 Linux®和UNIX®系统深深扎根于VCS软件中，从诸如RCS和并发版本系统（CVS）的恐龙到诸如Arch，Bazaar，Git，Subversion和Mercurial的更现代的系统。 像Git一样，Mercurial最初是作为名为BitKeeper的商业源代码管理系统的开源替代品，该系统用于维护和管理Linux内核的源代码。 自成立以来，Mercurial已经发展成为一种流行的VCS系统，许多开放源代码和商业项目都在使用该系统。 使用Mercurial的项目包括Mozilla，IcedTea和MoinMoin Wiki。 请参阅相关主题的链接，这些，还有更多的例子。 VCS系统通常引用每个源代码集合，在其中可以进行更改并作为存储库进行跟踪。 开发人员如何与存储库交互是更传统的VCS系统（例如称为CVC和Subversion）（称为集中式VCS系统）与更灵活的VCS系统（例如Mercurial和Git）（称为分布式VCS系统）之间的主要区别。 开发人员使用客户端/服务器模型与集中式VCS系统进行交互，在该模型中，对源代码的本地副本所做的更改只能推回到中央存储库中。 开发人员使用对等模型与分布式VCS系统进行交互，在该模型中，中央存储库的任何副本本身就是可以向其提交更改并可以与任何其他副本共享更改的存储库。 分布式VCS系统实际上没有中央主存储库的概念，但是几乎总是由策略定义的，因此存在一个用于构建，测试和维护软件主版本的存储库。 为什么选择水银？ Mercurial是一个小型，功能强大的分布式VCS系统，易于入门，同时仍提供VCS高级用户可能需要（或想要）使用的高级命令。 Mercurial的分布式特性使您可以轻松地在本地处理项目，通过本地提交来跟踪和管理您的更改，并在必要时将这些更改推送到远程存储库。 在现代的分布式VCS系统中，最接近Mercurial的VCS系统是Git。 Mercurial和Git之间的一些区别如下： 多个内置的撤消操作 ：Mercurial的revert ， backout和rollback命令使您可以轻松地返回到特定文件的先前版本或先前提交的更改集。 Git提供了一个内置的revert命令，它具有典型的仅限火箭科学家的语法。 内置的Web服务器 ：Mercurial提供了一个简单的集成Web服务器，可以轻松地快速托管资源库，以供其他人使用。 推送需要忽略安全性或支持安全套接字层（SSL）的更复杂的设置。 复制/移动操作期间的历史记录保留 ：Mercurial的copy和move命令均保留完整的历史记录信息，而Git在任何情况下均不保留历史记录。 分支机构 ：Mercurial自动共享所有分支机构，而Git要求每个存储库都设置自己的分支机构（在本地创建分支机构或通过将其映射到远程存储库中的特定分支机构）。 全局和本地标签 ：Mercurial支持在存储库之间共享的全局标签，这使共享代码开发中特定点的信息变得容易，而无需分支。 Windows平台上的本机支持 ：Mercurial用Python编写，Microsoft®Windows®系统支持。 因此，Mercurial可作为Windows可执行文件使用（请参阅参考资料 ）。 Windows上的Git更为复杂-您可以选择msysGit，使用Cygwin下的标准git或使用基于Web的托管系统和存储库。 自动存储库打包 ：Git要求您显式打包和垃圾回收其存储库，而Mercurial会自动执行其等效操作。 但是，对于相同的代码库，Mercurial存储库往往大于Git存储库。 Mercurial和Git爱好者也很高兴讨论每个VCS系统命令集的学习曲线，优点和可用性。 空格阻止了此处的讨论，但是围绕该主题的网络搜索将提供许多有趣的阅读材料。 创建和使用Mercurial存储库 Mercurial提供了两种为项目的源代码创建本地存储库的基本方法：通过显式创建存储库或克隆现有的远程存储库： 要创建本地存储库 ，请使用hg init [REPO-NAME]命令。 执行此命令时提供存储库名称，将在指定位置为该存储库创建目录。 不提供存储库的名称会将当前工作目录转换为存储库。 当为现有代码库创建Mercurial存储库时，后者非常方便。 要克隆现有存储库 ，请使用hg clone REPO-NAME [LOCALNAME]命令。 Mercurial支持用于访问远程存储库的超文本传输​​协议（HTTP）和安全外壳（SSH）协议。 清单1显示了一个示例hg命令以及通过SSH克隆存储库时产生的结果输出。 清单1.通过SSH克隆Mercurial存储库 $ hg clone ssh://codeserver//home/wvh/src/pop3check wvh@codeserver's password: destination directory: pop3check requesting all changes adding changesets adding manifests adding file changes added 1 changesets with 12 changes to 12 files updating to branch default 12 files updated, 0 files merged, 0 files removed, 0 files unresolved remote: 1 changesets found 注意 ：要使用HTTP协议访问Mercurial存储库，必须在该存储库中启动Mercurial的内部Web服务器（ hg serve -d ），或者使用Mercurial的hgweb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ea81a19f46f2b8688bc4f6d9ef6d92a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bca2c629b8c6cce9d0e8d099cb2f0df7/" rel="bookmark">
			我真的懂索引吗？——groupby、resample结果无法输出，重新设置索引reset_index
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键字：Pandas，groupby，resample
结果，列名，表头，多层，错行，多行
重新设置索引，索引转换为数据
一直很难描述这个问题，陆陆续续困扰了好久
dataframe格式数据，经过groupby、resample等操作后
结果显示表头（列名）不止一行
想把前2列也作为结果记录到数据库，或者读取整行4个字段信息，一直没有好的办法
在网上找了这些问题
1、dataframe表头多行，列名多行，
2、dataframe多层列名，多层表头
3、列名错行、表头错行、标题错行
4、dataframe groupby，resample后保存
5、dataframe groupby，resample后第一行为空
这应该是一个高手沉默，小白流泪的问题了。。。
没人带路真的要走好多弯路
直到我慢慢意识到，前2列应该是索引
那么问题就转成了，索引能不能转换为数据？或者能不能重新设置索引？
重设索引？
重设索引我会啊！
df= df.reset_index() # .reset_index()函数 难道就这么简单？输出看看：
世界安静了有木有！！！
整个人都好了有木有！！！
经常写的reset_index()居然有这个效果！！！
原因就是我不知道前两列原来就叫：“索引”。。。
送给和我一样彷徨过的朋友们，good luck
另一个方法：
df.groupby(‘books’, as_index=False).sum()
可以对比一下as_index=True的区别
grouby(by=None, axis=0, level=None, as_index=True, sort=True, group_keys=True, squeeze=False, **kwargs)
参考文献：https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
附录：
reset_index()
函数原型:DataFrame.reset_index(level=None, drop=False, inplace=False, col_level=0, col_fill=’’)
参数解释:
level：int、str、tuple或list，默认无，仅从索引中删除给定级别。默认情况下移除所有级别。控制了具体要还原的那个等级的索引
drop：drop为False则索引列会被还原为普通列，否则会丢失
inplace：默认为false，适当修改DataFrame(不要创建新对象)
col_level：int或str，默认值为0，如果列有多个级别，则确定将标签插入到哪个级别。默认情况下，它将插入到第一级。
col_fill：对象，默认‘’，如果列有多个级别，则确定其他级别的命名方式。如果没有，则重复索引名
注：reset_index还原分为两种类型，第一种是对原DataFrame进行reset，第二种是对使用过set_index()函数的DataFrame进行reset
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25a5eec4911dc0b45282f7e26aa92928/" rel="bookmark">
			解决windows10网络适配器出现问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事情是这样的：用的好好的忽然搜索不了无线局域网了
在控制面板里的“网络和Internet”里找不到无线适配器，只有一个蓝牙的适配器：
右键我的电脑，管理，打开设备管理器，发现
无线驱动适配器有个感叹号：
双击查看情况：
就可能是长期没有更新，系统自己禁用了这个适配器
有一种方法是直接卸载掉当前的适配器，然后
在操作里面点击“扫描检测硬件改动”，系统会自动安装一个合适的适配器
这里歪打正着，不忍心卸载，直接点了一下禁用设备，然后重新启用了一下：
惊喜的发现适配器上的感叹号不见了，无线网可以搜索局域网了!
适配器也出现了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa33d20e1fa3d89dcdfb4c360702562b/" rel="bookmark">
			Java多线程：线程8锁案例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程8锁案例分析 通过分析代码，推测打印结果，并运行代码进行验证
1、两个线程调用同一个对象的两个同步方法 被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法的调用者是同一个，所以两个方法用的是同一个锁，先调用方法的先执行。 public class Demo { public static void main(String[] args) { Number number = new Number(); new Thread(() -&gt; number.getOne()).start(); new Thread(() -&gt; number.getTwo()).start(); } } class Number { public synchronized void getOne() { System.out.println("one"); } public synchronized void getTwo() { System.out.println("two"); } } 输出结果如下：
one
two
2、新增Thread.sleep()给某个方法 被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法的调用者是同一个，所以两个方法用的是同一个锁，先调用方法的先执行，第二个方法只有在第一个方法执行完释放锁之后才能执行。 public class Demo { public static void main(String[] args) { Number number = new Number(); new Thread(() -&gt; number.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa33d20e1fa3d89dcdfb4c360702562b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b8d257b7ff1237614d88f98ea0652ed/" rel="bookmark">
			Java连接mysql数据库并执行sql语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		弄这个主要是为了方便测试单个sql的性能，尝试用java连接数据库并查询，将结果的JDBC ResultSet结果集转成List并输出。
import java.sql.*; import java.sql.DriverManager; import com.mysql.jdbc.Connection; //需要这个jar包 mysql-connector-java-5.1.49.jar import java.util.List; import java.util.ArrayList; import java.util.Map; import java.util.HashMap; public class Test { public void action() throws Throwable { try { int ColumnCount; //int RowCount; String driver = "com.mysql.jdbc.Driver"; String url = "jdbc:mysql://127.0.0.1:3306/test"; //换成要连接的数据库信息 String user = "root"; String password = "password"; Class.forName ( driver ); Connection conn = (Connection) DriverManager.getConnection ( url, user, password ); if (!conn.isClosed ()) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b8d257b7ff1237614d88f98ea0652ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/037f1ae297ee1e8479e39e909111872f/" rel="bookmark">
			Qt图片交互——QGraphicsView&#43;鼠标选点&#43;放大缩小&#43;OpenCV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.功能目标 通过 QGraphicsView 实现 OpenCV Mat 的显示，并且可以响应鼠标事件，绘制选择的点，同时可以进行放大缩小操作。
备注：QLabel 也能够完成同样的操作，但是QLabel的放缩是对控件本身缩放，像素显示会自动插值，图片放大时无法显示单个像素点，控件放大太大时响应会很慢，如果仅固定大小图片进行展示，可以选择使用QLabel。需要放缩操作时，QGraphicsView 更好用。
2.核心代码 2.1.初始化 在窗体中增加QGraphicsView控件，示例中命名为 imageBox。
窗体类中增加变量：
//控制缩放的比例因子 double m_scaleFactor; //场景 QGraphicsScene * m_scene; //画布 QGraphicsPixmapItem * m_imageItem; //绘制的OpenCV图像 cv::Mat m_imageShow; 变量初始化：
//缩放因子初始化为1 m_scaleFactor = 1.0; m_scene = new QGraphicsScene(); m_imageItem = new QGraphicsPixmapItem(); //场景增加画布 m_scene-&gt;addItem(m_imageItem); //控件绑定场景 ui.imageBox-&gt;setScene(m_scene); //对QGraphcisView控件注册事件响应 ui.imageBox-&gt;installEventFilter(this); //使能QGraphcisView控件的鼠标跟踪 ui.imageBox-&gt;setMouseTracking(true); 2.2.图片绘制、放大缩小 将 OpenCV Mat 绘制到控件上的代码如下：
//将OpenCV Mat绘制到QGraphicsView ShowImage(const cv::Mat &amp; image) { //记录绘制图片 m_imageShow = image.clone(); //三通道RGB if (image.type() == CV_8UC3) m_imageItem-&gt;setPixmap(QPixmap::fromImage(QImage((const unsigned char*)image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/037f1ae297ee1e8479e39e909111872f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae9980d184408f51a8fba80ab0f0a0c8/" rel="bookmark">
			循环神经网络系列RNN、LSTM及变种
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要
循环神经网络（Recurrent Neural Network, RNN）是一类以序列（sequence）数据为输入，在序列的演进方向进行递归（recursion）且所有节点（循环单元）按链式连接的递归神经网络（recursive neural network）。
人脑记忆原理：
对信息的预测和记忆功能 语言模型对当前输入信息的先后顺序 人脑的存储方式 人脑的记忆算法功能 序列
自然语言处理问题。x1可以看做是第一个单词，x2可以看做是第二个单词，依次类推。 语音处理。此时，每个元素是每帧的声音信号。 时间序列问题。例如每天的股票价格等。 RNN原理
运行过程：
其中每个圆圈可以看作是一个单元，而且每个单元做的事情也是一样的， 因此可以折叠呈左半图的样子。用一句话解释RNN，就是一个单元结构重复使用。 RNN结构的变种
N 对 1
应用：
判断处理序列分类问题，如输入一段文字判别它所属的类别， 输入一个句子判断其情感倾向，输入一段视频并判断它的类别等。 结构图：
1 对 N
应用：
从类别生成语音或音乐，从图像生成文字（image caption）， 此时输入的X就是图像的特征，而输出的y序列就是一段句子。 结构图：
N 对 M
同时也是一种Encoder-Decoder模型。
应用：
机器翻译：Encoder-Decoder的最经典应用，事实上这一结构就是在机器翻译领域最先提出的 文本摘要：输入是一段文本序列，输出是这段文本序列的摘要序列。 阅读理解：将输入的文章和问题分别编码，再对其进行解码得到问题的答案。 语音识别：输入是语音信号序列，输出是文字序列。 结构图：
RNN的训练方法
CNN的训练过程是一个损失递减优化的过程而RNN不同于CNN。
BPTT （back-propagation through time)
沿着需要优化的参数的负梯度方向不断寻找更优的点直至收敛。
sigmoid函数的缺点：
导数值范围为(0,0.25]，反向传播时会导致“梯度消失“。 tanh函数导数值范围更大，相对好一点。 sigmoid函数不是0中心对称，tanh函数是，可以使网络收敛的更好。 激活函数问题用RELU函数解决。 LSTM
LSTM网络通过精妙的门控制将短期记忆与长期记忆结合起来， 并且一定程度上解决了梯度消失的问题。 解决长期依赖问题
例如在语言模型中，需要预测的词本应该在上下文位置较近时， RNN可以使用先前的信息并正确预测，而位置较远时，反之。 举例： LSTM网络结构
原始结构：
使用tanh激活函数对上层细胞和本层输入进行激活后更新细胞状态。 整体上除了h在随时间流动，细胞状态c也在随时间流动，细胞状态c就代表着长期记忆。 LSTM结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae9980d184408f51a8fba80ab0f0a0c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e45cd3a39842a95c4086d0a33eb1d204/" rel="bookmark">
			Javase基础（二）——数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Javase基础（二）——数据类型 Javase基础（二）——数据类型和运算常量进制概述和二,八,十六进制进制转换 源码、反码、补码原码反码补码 变量的概述及格式变量相加和常量相加的区别 数据类型基本数据类型分类(4类8种)字符和字符串char数据类型 占用空间转义字符自动类型转换字符串与基本类型转换小数准确运算注意事项 隐式转换强制转换算术运算符算术运算符++和-- 赋值运算符关系运算符逻辑运算符短路运算区别 位运算符位异或运算符的特点 三元运算符键盘录入选择结构循环结构转义字符方法方法重载 数组数组动态初始化数组遍历数据类型参数传递 Javase基础（二）——数据类型和运算 常量 什么是常量：在程序执行的过程中其值不可以发生改变
常量的分类
字面值常量 5， 10 ，99 之类的自定义常量(面向对象部分讲) final PI=3.14159字面值常量的分类 字符串常量 用双引号括起来的内容 "avadsfasdfasdf"整数常量 所有整数小数常量 所有小数字符常量 用单引号括起来的内容,里面只能放单个数字,单个字母或单个符号(注意，单引号里面什么也不放是不行的)布尔常量 较为特殊，只有true和false空常量 null(当数组引用属于局部变量且未初始化时候) 进制概述和二,八,十六进制 进制：就是进位制，是人们规定的一种进位方法。 对于任何一种进制–X进制，就表示某一位置上的数运算时是逢X进一位。二进制就是逢二进一，八进制是逢八进一，十进制是逢十进一，十六进制是逢十六进一。
不同进制表现同一个数据的形式特点：进制越大，表现形式越短
二进制的数据表现形式
由0,1组成。以0b(b可以大写也可以小写)开头(JDK1.7版本可以表示二进制了)
八进制的数据表现形式
由0,1,…7组成。以0开头
十进制的数据表现形式
由0,1,…9组成。整数默认是十进制的
十六进制的数据表现形式
由0,1,…9,a,b,c,d,e,f(大小写均可)。以0x开头
进制转换 任意进制到十进制的转换原理 系数：就是每一位上的数据。基数：X进制，基数就是X。权：在右边，从0开始编号，对应位上的编号即为该位的权。结果：把系数*基数的权次幂相加即可。 十进制到任意进制的转换 除积倒取余法
8421码
8421码是中国大陆的叫法，8421码是BCD代码中最常用的一种。在这种编码方式中每一位二值代码的1都是代表一个固定数值，把每一位的1代表的十进制数加起来，得到的结果就是它所代表的十进制数码。
通过8421码的方式进行二进制和十进制的相互转换
二进制到八进制的简易方式：三个二进制数为一组
二进制到十六进制的简易方式：四个二进制数为一组
源码、反码、补码 原码 就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。通过一个字节,也就是8个二进制位表示+7和-70(符号位) 00001111(符号位) 0000111 反码 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 补码 计算机计算时候都是以补码形式运算的
正数的补码与其原码相同；负数的补码是在其反码的末位加1。 例子：
已知原码求补码
0b10110100 原 0b11001011 反//符号位不变 0b11001100 补 已知补码求原
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e45cd3a39842a95c4086d0a33eb1d204/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c0907746c28c010b714f434c77640c/" rel="bookmark">
			图像分割系列概述FCN、UNet、DeepLab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要
图像分割的本质是像素级别的分割。广泛应用于医疗成像、自动驾驶领域等。
图像分割的类型：
普通分割：将不同类别不同物体的像素区域分开，比如分开前景和后景。
语义分割：在普通分割基础上，分类出每块区域的语义（什么物体）。将画面中所有物体都指出各自的类别。
实例分割：在语义分割的基础上， 识别并给出每个相同的物体的编号。
FCN
普通CNN网络用于输出图像级别的分类和回归任务。它的尾部是全连接输出固定的值。而FCN将CNN最后一层全连接层替换为卷积层，输出一张Label好的图片。这种结构就是一种编解码的结构。但是FCN得到的结果还是不够精细，上采样的结果还是比较模糊和平滑，细节敏感性低。concat不够，应用了池化，像素位置有问题。
基于FCN框架的UNet
采用FCN的思想，四个下采样提取目标特征，再通过四个上采样，最后逐个对其像素点进行分类，那么这实际上是一个基于编码器（encode）-解码器（decode）思想。
网络模型结构：
下采样方法（压缩图像的特征）：使用大步长的卷积；池化；使用Padding的卷积。
上采样方法：像素插值（双线性插值、邻近插值——信息丢失少，速度适中），反卷积（转置卷积T.conv——参数少，速度快），反池化（Unpooling），像素融合（通道信息平铺，不丢失信息）
在Unet中使用了转置卷积实现上采样，在Unet中每一个上采样Block里，运用了一个跳连接把前面一部分特征Concat到了上采样后的特征图上。（思想类似ResNet），目的是使上采样后的特征图有更多的浅层语义信息，增强分割精度，在最后一层直接使用sigmoid二分类把mask分为前景和背景。
损失函数：常见的图像分割损失函数有，Binary crossentropy（BCE），Dice coefficient，Focal loss（解决类别不平衡）。Unet使用如下的损失函数。
存在的问题：网络是固定层数，对不同的分割需求是冗余的。可以改进模型结构，适应不同的分割需求。
UNet ++
论文:https://arxiv.org/abs/1807.10165
UNet++根据UNet模型的结构进行优化。可以把UNet++看成多个不同深度，不同池化的Unet 的集合模型。提出了Deep Supervision 深监督，作用类似辅助loss，可以加快模型收敛速度。在训练时是集合训练，在测试使用时，可以通过不同剪枝来选择更简单合适的模型。
两个问题：
为什么UNet++可以剪枝？
模型是长连接加短连接，所以每一层都可以单独剪下来去使用，结构决定。
如何剪枝？
应用了一个深监督模型1*1的卷积，监督他每一层的输出，都要去训练单独使用。
好处：适应各种简单或复杂的任务。
为什么测试时剪枝？而不是剪枝后再去训练？
剪完枝后去训练没有共同促进的作用，而且剪完训练后使用也更复杂，无法判断哪个模型适应哪个任务，只能主观判断。而测试的时候剪枝可以通过模型的dice系数在哪一层的效果最好去决定。
DeepLab v1-v3
论文：
V1 https://arxiv.org/pdf/1412.7062v3.pdf
V2 https://arxiv.org/pdf/1606.00915.pdf
V3 https://arxiv.org/pdf/1706.05587.pdf
V3+ https://arxiv.org/pdf/1802.02611.pdf
DeepLab系列使用了空洞卷积，ASPP结构，Encoder-Decoder（编解码）结构，CNN与PGM（概率图模型）结合，。
空洞卷积：
这里的Input stride理解为空洞的洞的大小，这里洞为1，在3x3的卷积核下，使用了Input stride使原本3x3的卷积核有了5x5大小的感受野，但是原始卷积核还是没变。
ASPP结构：
目的是通过不同的比例rate构建不同感受野大小的卷积核，来获取多尺度的物体信息。
CRF：
条件随机场
在V3中，作者把解决多尺度的问题的方法分为4类：
图像金字塔、编解码、网络层最后加入其它模块如DenseCRF或串联不同感受野大小的卷积、在网络层最后并行空间金字塔池化模块获取不同尺度物体信息。
V3在实验中主要做了两个改进：
使用残差网络结构时通过串联结构，做到了更深的空洞卷积；
优化了ASPP。
V3+：
把原DeepLabv3当作encoder，添加decoder得到新的模型（DeepLabv3+），也就是把ASPP模块与E-Dcoder融合为一体。使用了深度可分离卷积和膨胀卷积。
网络结构：
在Encoder部分使用空洞卷积，得到多尺度的特征图，再将这部分拼接在一起后使用1x1的卷积，将通道变小后上采样（使用双线性插值）输入Decoder。
在Decoder部分先将前面的低维度特征通过1x1卷积变换通道后，将Encoder的输出拼接。使用3x3的卷积、上采样输出。
由于普通卷积学习的是像素之间的关系，具有平移不变性，而在这里用在图像语义分割上不好。而平移同变性指位置发生变换，相应的侦测输出也会变化。我们希望图像分割任务能够及时响应物体位置的变化。
同一个像素在同一图像上，在某一位置是前景，而在另外一位置可能变成了后景。在不同的位置具有不同的语义信息。
高级语义：抽象程度高，用于检测分类回归任务。
低级语义：像素点的定位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96c0907746c28c010b714f434c77640c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/047aaa2c078e162fab34f01754082f1e/" rel="bookmark">
			Graylog3 布署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 因为先前的日志收集系统存在一些功能缺陷，经过一番了解，最后决定布署Graylog3，本文包含Graylog3服务器&amp;客户端的布署
服务器组件列表 OS: Centos 7
oracle jdk: jdk-8u251-linux-x64.tar.gz
mongodb: mongodb-linux-x86_64-3.6.13.tgz
elasticsearch : elasticsearch-6.8.3.rpm
graylogserver: graylog-3.1-repository_latest.rpm
客户端组件 Windows: graylog-sidecar: graylog_sidecar_installer_1.0.2-1.exe
Linux: graylog-sidecar: graylog-sidecar-1.0.0-1.x86_64.rpm
filebeat: filebeat-7.4.0-x86_64.rpm
服务器ip: 172.24.42.11
安装 jdk 到官网下载 jdk1.8
下载页面: https://www.oracle.com/java/technologies/javase-downloads.html
# mkdir /home/java # tar -zxvf jdk-8u251-linux-x64.tar.gz -C /home/java 修改环境变量
# vim /etc/profile 添加 export JAVA_CMD=/home/java/jdk1.8.0_251/bin export JAVA_HOME=/home/java/jdk1.8.0_251 export PATH=$PATH:$JAVA_HOME/bin 生效
# source /etc/profile 验证
# java -version java version "1.8.0_251" Java(TM) SE Runtime Environment (build 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/047aaa2c078e162fab34f01754082f1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f1f3a0410f4636cd4f34a9a643bd5e2/" rel="bookmark">
			CentOS 7 安装SonarQube 8.3版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7 安装SonarQube 8.3版本 官方文档
下载地址
准备工作 准备一台CentOS 7服务器SonarQube 8.3版本只支持Java 11 (下载Java 11)安装pgAdmin 安装PostgreSQL 12.0 yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm yum install postgresql12-server /usr/pgsql-12/bin/postgresql-12-setup initdb systemctl enable postgresql-12 systemctl start postgresql-12 # 安装后的数据库data目录 cd /var/lib/pgsql/12/data # 修改配置 vi pg_hba.conf host all all 0.0.0.0/0 md5 vi postgresql.conf listen_addresses = '*' systemctl restart postgresql-12 # 客户端程序目录 cd /usr/pgsql-12/bin # 安装的时候会自动创建postgres用户密码为空 su postgres bash-4.2$ psql psql (12.3) 输入 "help" 来获取帮助信息. # 修改管理员密码(默认是随机密码) ALTER USER postgres WITH PASSWORD 'postgres'; # 退出 \q 安装服务端程序 # 上传SQ v8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f1f3a0410f4636cd4f34a9a643bd5e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096a8c4c8b28e79bbc0751f71cbded5a/" rel="bookmark">
			目标检测模型发展概览R-CNN系列、YOLO V3（V1、v2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要
目标检测目前应用广泛，国内很多算法工程师都是在做这方面工作的。目标检测发展可以看成是从单一单目标到多个多目标的过程。在算法方面也是从最初的机器学习方法到传统机器学习与深度学习算法结合，再到现在的全深度学习框架。
YOLO算法系列目前已经到了V5阶段（V4、V5我还没看），而且YOLO模型在工业应用方面可以说是最常用最万能的检测模型了。我们思考一个目标检测解决方法时，总是会先考虑YOLO能不能在这里用上。忘了…本文是原理篇，感谢您的阅读。
感觉直接说YOLO有点突兀，直接说V3不说V1 V2也突兀。所以就开始慢慢侃吧。
一、小猫图的说明
来上一张很常见的小猫图片：
目标检测最开始呢，当然是识别我这样一幅图片里有没有我想要的那个物体（Cat），有的话就输出为1，没有就是0。所以我们把这样一个问题看作是图片分类的问题。进阶一下：可是我不只是想要知道有没有，我还想知道在哪里。所以呢我们在分类基础上增加了一个回归目标框的问题。当然这是对单个目标。
再后来，我还想要找到这副图片里的其他物体（Dog and Duck…），那我就是要多目标检测了，在加上上面的定位问题。这里就比较复杂起来了。最难的是：我现在不仅仅要得出一个框，我要图片里的所以我想要的物体，并且我要把他们分割出来。猫就是猫类，狗是狗类。这样还不够的呢？我还想要他知道这是什么品种的猫，波斯，橘猫等等。。。哇！ 你想想，这样是不是太难了。
不过现在我们已经可以做到上面的所有任务了。算法方面呢，就是一个层次递进的过程。
我们知道将图片输入侦测模型，模型只能提取到每个像素点的信息和这样一个分布信息。对于RGB图像，输入网络的是一个3个维度的由（0-255）组成的矩阵。我们构建的模型，就是找出这样的矩阵中存在目标物体的矩阵，并且输出对应的物体类型，和位置信息。这是一个看似最简单不过的过程。而所有的机器学习、深度学习算法也都是在做这样一个事情。
最简单的一个过程：我们利用CNN去学习这样的图像信息，通过给某类物体的标签和坐标值让他拟合出最佳的一套权重参数。在后续的推理过程中，利用这套权重参数和CNN模型就能达到预测类似物体的目的。
二、传统方法
机器学习方法中的传统方法：通过使用选择性搜索、构建特征提取器和分类器的方式得到输出。
选择性搜索：Selective Search 通过在原图上滑动一个窗口，得出建议框位置。
特征提取器：HOG、SIFT、Haar等。
分类器：SVM、Adaboost等。
传统方法：在原图上滑动窗口这点类似卷积过程的滑动窗口，但是由于通过选择性搜索，这种方式得出的建议框一般多达1-2k个，再逐一使用特征提取器提取特征，再使用分类器分类，最后使用NMS去过滤重复候选框。缺点便是：算法冗余严重、检测速度很慢、效果平平。
三、深度学习加传统方法
1、Regions with CNN
论文：https://arxiv.org/pdf/1311.2524v5 .pdf
开辟：
传统的滑动窗口方法和回归框；使用了ROI 。
如图示流程：
1、使用选择性搜索的输出得到~2k个 ROI（感兴趣区域）；
2、Warp候选区域为同一Size；
3、将Warped regions输入卷积神经网络后；
4、使用Linear Regression输出Bounding box的偏移量；
5、使用SVMs对Regions进行分类。
缺陷：每个框CNN提特征+SVM分类（卷积过程耗时、未全部抛弃机器学习算法）
2、SPP-Net
论文：https://arxiv.org/pdf/1406.4729v4.pdf
开辟：取代Crop/Warp操作为空间金字塔池化，使得对于神经网络有全连接层输出时的输入图像size可以是不固定的。也改善了Crop/Warp的形变问题。
流程：
关于SPP-Net 翻译及解释。
3、Fast RCNN
论文：https://arxiv.org/pdf/1504.08083v2 .pdf
以上R-CNN和SPP-Net的缺陷在此论文中概括为：
1、训练是一个多阶段的过程；
2、训练在空间和时间上成本高；
3、检测速度慢。
开辟：
训练方面：是单一阶段，使用多任务损失；更新所有网络层；
使用ROI Pooling，SVM替换为Softmax分类；
可以达到实时检测！
流程：
输入图像和多个感兴趣区域(ROIS)被输入到全卷积网络中。每个ROI集合成一个固定大小的特征映射，然后通过完全连接层(FCS)映射到一个特征向量。该网络每个ROI有两个输出向量：Softmax概率和每类bounding-box回归偏移量。
其中的ROI层是SPP的特例，只使用了1个金字塔级别的池化。
缺陷：选择性搜索无法GPU运算，耗时很多，有~2K个候选框，冗余。
4、Faster RCNN
论文：https://arxiv.org/pdf/1506.01497v3.pdf
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/096a8c4c8b28e79bbc0751f71cbded5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37370915178849f4f0d3a0fb0546bfff/" rel="bookmark">
			lotus v0.4.0 testnet 远程矿工
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lotus v0.4.0 testnet 远程矿工 1，miner矿工运行1.1 修改miner配置 2，运行worker3，运行日志4，CPU，内存使用4.1，miner节点4.2，worker节点 1，miner矿工运行 --max-parallel 并行sector数量，128GB内存运行1个 nohup lotus-storage-miner run &gt;&gt; /storage/miner.log 2&gt;&amp;1 &amp; nohup lotus-storage-miner run --max-parallel 1 &gt;&gt; /storage/miner.log 2&gt;&amp;1 &amp; 1.1 修改miner配置 vim lotusstorage/config.toml [API] # ListenAddress = "/ip4/127.0.0.1/tcp/2345/http" ListenAddress = "/ip4/192.168.1.11/tcp/2345/http" # RemoteListenAddress = "127.0.0.1:2345" RemoteListenAddress = "192.168.1.11:2345" [Storage] AllowPreCommit1 = false AllowPreCommit2 = false AllowCommit = false AllowUnseal = true 设置存储目录 mkdir attachstorage lotus-storage-miner storage attach --init=true --store=true /storage/lotuswork/attachstorage # lotus-storage-miner storage list a73: [||| Unsealed: 0; Sealed: 0; Caches: 0 Weight: 10; Use: Store Local: /storage/lotuswork/attachstorage 2，运行worker 远程矿工计算seal_pre_commit_phase1、seal_pre_commit_phase2、seal_commit_phase1、seal_commit_phase2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37370915178849f4f0d3a0fb0546bfff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f0daceae0478d7413556edffb0f7d30/" rel="bookmark">
			A. XXXXX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Ehab loves number theory, but for some reason he hates the number xx. Given an array aa, find the length of its longest subarray such that the sum of its elements isn't divisible by xx, or determine that such subarray doesn't exist.
An array aa is a subarray of an array bb if aa can be obtained from bb by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f0daceae0478d7413556edffb0f7d30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a9e32336422530779dfa5468f8d83d/" rel="bookmark">
			Nginx 如何自定义变量？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前的两篇文章 Nginx 变量介绍以及利用 Nginx 变量做防盗链 讲的是 Nginx 有哪些变量以及一个常见的应用。那么如此灵活的 Nginx 怎么能不支持自定义变量呢，今天的文章就来说一下自定义变量的几个模块以及 Nginx 的 keepalive 特性。
通过映射新变量提供更多的可能性：map 模块 功能：基于已有变量，使用类似 switch {case: … default: …} 的语法创建新变量，为其他基于变量值实现功能的模块提供更多的可能性模块：ngx_http_map_module 默认编译进 Nginx，通过 --without-http_map_module 禁用 指令 Syntax: map string $variable { ... } Default: — Context: http Syntax: map_hash_bucket_size size; Default: map_hash_bucket_size 32|64|128; Context: http Syntax: map_hash_max_size size; Default: map_hash_max_size 2048; Context: http 我们主要看一下 map string $variable { ... } 这个指令。所谓类似 switch case 的语法是指，string 的值可以有多个，可以根据 string 值的不同，来给 $variable 赋不同的值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44a9e32336422530779dfa5468f8d83d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c81425e6141394735cc478467d4c6f1/" rel="bookmark">
			Python3，字符串函数整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rsplit从后往前分割
&gt;&gt;&gt; "banana".split("n",1) ['ba', 'ana'] &gt;&gt;&gt; "banana".rsplit("n",1) ['bana', 'a'] capitalize首字母大写
&gt;&gt;&gt; 'GrEat'.capitalize() 'Great' casefold：lower() 方法只对ASCII编码，也就是‘A-Z’有效，对于其他语言（非汉语或英文）中把大写转换为小写的情况只能用 casefold() 方法。
&gt;&gt;&gt; 'GreaTEr'.casefold() 'greater' 非字母后的第一个字母将转换为大写字母
&gt;&gt;&gt; "This is a 3g3g".title() 'This Is A 3G3G' center，ljust，rjust
&gt;&gt;&gt; "great".center(20, '*') '*******great********' &gt;&gt;&gt; "great".ljust(20, '*') 'great***************' &gt;&gt;&gt; "great".rjust(20, '*') '***************great' count计数
"This is a dog".count("s") 2 expandtabs制表符转换为空格
&gt;&gt;&gt; '\t'.expandtabs() ' ' &gt;&gt;&gt; '\t\t'.expandtabs() ' ' partition、rpartition分割成三个元素并放入到元组中
&gt;&gt;&gt; "This is a pig".partition("is") ('Th', 'is', ' is a pig') &gt;&gt;&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c81425e6141394735cc478467d4c6f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911e7359042fb398c630ac74233a29ea/" rel="bookmark">
			Qt界面美化QSS——（一）使用方式、语法（选择器、伪状态）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QSS——Qt Style Sheet，Qt通过样式表设置控件样式进行个性化定制、界面美化。
1.使用方式 1.1.Qt Designer 在Qt Designer中，每个控件都有styleSheet属性，通过键入样式表，即可设置该控件的样式。如下图：
使用该方式的好处在于，可以直观看到设计效果，通过Ctrl+R就可以预览窗体设计。并且在编辑样式表窗口中添加资源、添加渐变、添加颜色、添加字体，方便直接编辑特定样式的颜色。此类方式编辑的样式表会作用于当前控件及其所有子控件。
1.2.QSS文件 使用QFile读入样式表，使用setStyleSheet进行设置。示例代码如下：
QApplication app(argc, argv); QFile qss("StyleSheet.qss"); qss.open(QFile::ReadOnly); app.setStyleSheet(qss.readAll()); qss.close(); 此通过加载StyleSheet文件，对整个软件的所有控件样式进行设置。这种方式“一劳永逸”，可以设计自己的风格，所有软件重复使用。
Qt Designer方便直接界面调试，并且可以对颜色进行编辑。适合设计时使用，当然也可以直接用作界面美化。当Qt Desinger编辑的样式表固定好之后，可以组织保存到QSS文件中，直接代码加载即可。
2.语法 2.1.基础语法 QSS同CSS语法规则类似，形式如下：
selector{attribute:value};
其中：
selector选择器：通常情况下为控件类名（如QPushButton）；
attribute属性：待设置的样式表属性（如background-color）；
value值：属性赋值（如rgb(40, 85, 20);）；
QPushButton { color: red } Qt样式表通常不区分大小写(即，color、Color、color和color指的是同一属性)。但是是类名、对象名和Qt属性名，它们区分大小写。
2.2.共享属性 对于共享属性部分可以使用下面形式：
QCheckBox,QComboBox,QSpinBox { color:rgb(255,0,0); background-color:rgb(255,255,255); font:bold; } 这样就设置了所有作用范围内的QCheckBox、QComboBox、QSpinBox的前景色、背景色和字体。
2.3.选择器（selector） Qt样式表支持CSS2中定义的所有选择器。下表总结了最有用的选择器类型。
选择器举例解释通用选择器*所有 Qt 的 widget，即不声明选择器时，属性作用于所有组建类型选择器QPushButton作用于QPushButton及其子类的实例。属性选择器QPushButton[flat=“false”]作用于非平面（flat=“false”）的QPushButton实例。类选择器.QPushButton作用于QPushButton的实例，但不匹配其子类的实例。（加了个’.’)ID选择器QPushButton#okButton作用于对象名称为okButton的所有QPushButton实例。后代选择器QDialog QPushButton匹配作为QDialog的子体(子级、孙级等)的所有QPushButton实例。子选择器QDialog &gt; QPushButton匹配作为QDialog的直接子级的所有QPushButton实例。子控制QComboBox::drop-down要设置复杂 widget 的样式，需要访问 widget 的子控件，如QComboBox的下拉按钮或QSpinBox的上下箭头。选择器可以包含子控件，从而可以将规则的应用限制到特定的 widget 子控件。 2.4.伪状态（Pseudo-States） 用户在操作时，可以根据不同的交互状态展示不同的用户样式，界面能够识别用户操作，不需要代码控制即可响应不同状态下的样式。例如：
QPushButton { border: 1px solid #555; padding: 4px; min-width: 65px; min-height: 12px; } QPushButton:hover { background-color: #999; } QPushButton:pressed { background-color: #333; border-color: #555; color: #AAA; } QPushButton:disabled { color: #333333; } QPushButton在hover、pressed、disabled状态时，分别展示不同的样式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/911e7359042fb398c630ac74233a29ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3766194b1766dcb97b0740146cad9b8/" rel="bookmark">
			You have no right to access this object because of bucket acl.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是使用阿里云OSS上传文件服务时报的错，这是由于新建的子用户AccessKey没有配置相应的权限所导致的。
解决方法，配置上相应权限。
找到相关子用户，添加权限：
添加上权限后即可正常上传文件了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53236dfb72de05a78c125c6fdea0290c/" rel="bookmark">
			obs内录电脑声音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 obs内录电脑声音
如果电脑上连着耳机，桌面音频2选择耳机即可；电脑没连耳机的话，选择扬声器即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99025ee0376c7427aaf5990cd2a1d78a/" rel="bookmark">
			实战问题解决：pyechart轴数据赋值出错  TypeError: add_yaxis() got an unexpected keyword argument yaxis_data
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 line = ( Line() .add_xaxis(xaxis_data=x_data) .add_yaxis( series_name='商家销量', yaxis_data=y_data,	# 此处有错 label_opts=opts.LabelOpts(is_show=False), ) ) 注意：X轴和Y轴的赋值参数名格式不一样
X轴：xaxis_data
Y轴：y_axis
如果把Y轴赋值如上面代码写成yaxis_data
就会提示TypeError: add_yaxis() got an unexpected keyword argument ‘yaxis_data’
应修改为：
y_axis= y_data 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a45acfb882e4bad8f317b6c100260ed2/" rel="bookmark">
			免费复制百度文库的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开网页，按F12调出开发者工具，选择“Console（中文则为控制台）”一栏，输入代码（可能需要拉动滚动条到最下面再输入）“document.body.contentEditable=’true’;”并回车，然后该页面的内容可以自由编辑，可以添加、删减以及修改内容，还可以进行剪切操作，对百度文库也有效，不过需要自行排版，而且只能剪切文字，对于图片和其它东西可能没有效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab9b03913fb986fc4157a9b739b1dafd/" rel="bookmark">
			MIT软件构造Reading
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态检查Static Checking 静态类型与动态类型 我们在编程敲代码的时候，很容易就会不小心敲错字母，从而导致无法识别关键字、变量名称未定义等情况发生。有时候会写关于运算的代码，比如a/b，在实际中b是不可以为0的，但是在程序中需要追踪检查b值变化情况，若b为0，则会出错。
我们手动输入的内容无法保证一定是正确的，因此，程序都需要进行对错误的检查。但是应该在什么时候进行检查呢？
1）在写程序时报错。
2）在编译时报错。
3）在程序运行时报错。
4）不报错
编程语言有类型检查的机制，确保并强制声明的变量的类型（常量，布尔值，数字，变量，数组，对象）与指定的值相匹配，其目的就是为了避免程序发生一些不好的情况。
编程语言按照类型检查可以分为两大类：静态类型 (Static Typing) 和 动态类型 (Dynamic Typing)。静态类型语言在编译时执行类型检查，是基于对程序源代码的分析来验证程序的类型安全性的过程。而动态类型的语言在运行时执行类型检查,验证程序的类型安全性的过程。
例如：
Java是一种静态类型的语言。所有变量的类型在编译时（程序运行之前）都是已知的，因此编译器也可以推导出所有表达式的类型。即若声明变量a和b为int类型，则a+b也为int类型。对于敲错字母导致的错误，许多开发工具提供在编写代码时执行检查操作的服务，在敲入代码时，会有许多错误提示。C++也是一种静态类型的语言，用它编写的源程序必须先进行编译，编译通过才可以进行运行；若编译不通过，则会报错。
Python是一种动态类型语言，这种检查将推迟到运行时（程序运行时）进行。
静态类型是一种特殊的静态检查，这意味着在编译时检查错误。错误是编程的祸根。静态类型可以防止大量的bug影响程序，确切地说，是由于对错误类型的参数执行操作而导致的bug。
检查类型 静态检查，动态检查，不检查
静态检查：在程序运行之前会自动发现该错误。
动态检查：执行代码后会自动发现错误。
不检查：根本无法帮助找到错误。编程人员必须自己注意，否则最终会得到错误的答案。
不可否认的是，静态捕获错误要比动态捕获更好，而动态捕获总比根本不捕获要好。即三者的考虑顺序为静态检查&gt;动态检查&gt;不检查
静态检查可以发现的错误类型： 1.语法错误，例如多余的标点符号或虚假单词。
2.错误的名称，
3.参数数量错误，
4.错误的参数类型，
5.错误的返回类型，
动态检查可以发现的错误类型： 1.语法错误，类似Python这样的动态类型语言也进行这种静态检查。如果您的Python程序出现缩进错误，则会在程序开始运行之前先进行查找。
2.非法参数值。例如，整数表达式x/y只有在y实际上为零时才是错误的。否则它会起作用。因此，在此表达式中，被零除不是静态错误，而是动态错误。
3.无法代表的返回值，即当特定的返回值无法在类型中表示时。
4.超出范围的索引，例如，在字符串上使用负数或太大的索引。
5.在null对象引用上调用方法（null类似于Python None）。
静态检查的优点 1.避免错误。 静态检查通过在运行时捕获类型错误和其他错误来帮助提高安全性。
2. 容易明白。 因为类型在代码中明确声明，所以有助于理解。
3. 准备好进行更改。静态检查可以通过识别需要串联更改的其他位置来更轻松地更改代码。例如，当您更改变量的名称或类型时，编译器会立即在使用该变量的所有位置显示错误，并提醒您也更新它们。
静态检查往往与类型有关，而错误与变量具有的特定值无关。类型是一组值。静态类型保证变量将具有该集合中的某个值，但是直到运行时我们才确切知道它具有哪个值。因此，如果错误仅由某些值引起，例如被零除或超出范围的索引，则编译器将不会对此引发静态错误。动态检查往往涉及由特定值引起的错误。
静态检查和动态检查各自有各自的有点，我们不能简单地就说某一种一定比另外一种好，好不好是根据需要、个人习惯爱好有关的。比如说，习惯边写边纠正、首先保证名称类型等正确，就会觉得静态检查能在编译时就能发现类型上的错误，更早的找到简单错误，方便快速。
总的而言，静态类型，如Java 和 C++，比较适合大型的软件工程项目，简单错误早发现早解决，方便后期进行其他操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/699759f1d249c2f6b7eba85fcbf7c1d9/" rel="bookmark">
			计算机体系结构量化研究方法学习笔记（一）——第一章 量化设计与分析基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 量化设计与分析基础 1、引言2、计算机的分类3、计算机体系结构的定义4、技术趋势5、集成电路中的功率和能耗6、成本趋势7、可信任度8、性能的测量、报告和汇总9、计算机设计的量化原理10、融会贯通：性能、价格和功耗 1、引言 发展过程：
20世纪80年代早期，开发出新体系结构——RISC（精简指令集计算机）。主要关注两点：指令级并行的开发、缓存的使用。
基于RISC的计算机抬高了性能指标。促使了1986-2003，计算机性能以超过50%的年增长率持续增长17年。
然而，由于风冷芯片最大功耗和无法有效地开发更多指令级并行这两大孪生瓶颈，单处理器性能受限了。
2004年，Intel取消了高性能单核处理器项目，这是标志着历史性转折的里程碑信号。处理器性能从单纯依赖指令级并行（ILP）转向了数据级并行（DLP）和线程级并行（TLP）。
2、计算机的分类 一、5种计算机分类
个人移动设备（PMD）、桌面计算、服务器、集群、仓库级计算机、嵌入式计算机
二、并行度与并行体系结构的分类
多级别的并行度是计算机设计的推动力量，能耗和成本是主要约束条件。
1、应用程序的两种并行方式：
数据级并行（DLP）： 可以同时操作许多数据项
任务级并行（TLP）： 创建了一些能够单独处理但大量采用并行方式执行的工作任务。
2、计算机硬件以4种方式实现这两种应用并行：
指令级并行
向量体系结构和图形处理器（GPU）
线程级并行
请求级并行
3、根据多处理器最受约束组件中指令流及数据流的并行，将所有计算机分为以下4类：
单指令流、单数据流（SISD）：单处理器，但是可以利用指令级并行。
单指令流、多数据流（SIMD）：同一指令由多个使用不同数据流的处理器执行。SIMD计算机开发数据及并行。
多指令流、单数据流（MISD）：还没有
多指令流、多数据流（MIMD）：每个处理器都提取自己的指令，对自己的数据进行操作，他针对的是任务机并行。
3、计算机体系结构的定义 一、指令集体系结构（ISA）
本书用ISA代指程序员可以看到的实际指令集。ISA的作用相当于区分软件和硬件的界限。
1、ISA分类
寄存器-存储器ISA：可以在许多指令中访问存储器。如80x86。
载入-存储ISA：只能用载入或存储指令来访问存储器。如ARM和MIPS。
补：
上述两个词没见过，但是学计组的时候，学过RISC和CISC的区别，其中之一就有：RISC只有load/store指令可以访存，CISC不加限制。想必是和这两类ISA是对应的。
2、存储器寻址
几乎所有计算机都用字节寻址来访问存储器操作数。ARM和MIPS要求对齐，80x86不用对齐。
二、真正的计算机体系结构：组成和硬件
组成：有时也称微体系结构。包含了计算机设计的高阶内容，如存储器系统、存储器互联等。
硬件：指的是具体实现。
本书中，体系结构 = 指令集体系结构、组成、硬件。
设计计算机必须要满足功能需求，同时达到价格、功耗、性能、可用性指标。
4、技术趋势 一、五大重要技术：
1、集成电路逻辑技术。即晶体管技术的进步，摩尔定律。
2、半导体DRAM。
3、半导体闪存。
4、磁盘技术。
5、网络技术。
二、晶体管性能与连线的发展
随着特征尺寸下降，晶体管性能线性提升，晶体管密度（数目）却以平方曲线提升，计算机架构就变得重要。
5、集成电路中的功率和能耗 一方面，必须将功率分配给芯片，另一方面功率以热的形式耗散，必须消除。
一、功率和能耗：系统观点
系统架构师要考虑三个方面：
1、处理器需要的最大功耗。保证性能。
2、持续功耗。普遍称为热设计功耗（TDP），决定了冷却需求。
3、能耗和能耗效率。
二、微处理器内部的能耗和功率
对CMOS芯片，一次（0-&gt;1或1-&gt;0）的能耗：
动态能耗 = 1/2 * 容性负载 * 电压² 每个晶体管的功率：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/699759f1d249c2f6b7eba85fcbf7c1d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c067fd3173cedc40fd580bed1c5fb3/" rel="bookmark">
			【Java学习-进阶】-java线程池ThreadPoolExecutor八种拒绝策略浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到一篇非常好的文章分享给大家。
前言 谈到java的线程池最熟悉的莫过于ExecutorService接口了，jdk1.5新增的java.util.concurrent包下的这个api，大大的简化了多线程代码的开发。而不论你用FixedThreadPool还是CachedThreadPool其背后实现都是ThreadPoolExecutor。ThreadPoolExecutor是一个典型的缓存池化设计的产物，因为池子有大小，当池子体积不够承载时，就涉及到拒绝策略。JDK中已经预设了4种线程池拒绝策略，下面结合场景详细聊聊这些策略的使用场景，以及我们还能扩展哪些拒绝策略。
池化设计思想 池话设计应该不是一个新名词。我们常见的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。就好比你去食堂打饭，打饭的大妈会先把饭盛好几份放那里，你来了就直接拿着饭盒加菜即可，不用再临时又盛饭又打菜，效率就高了。除了初始化资源，池化设计还包括如下这些特征：池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。
线程池触发拒绝策略的时机 和数据源连接池不一样，线程池除了初始大小和池子最大值，还多了一个阻塞队列来缓冲。数据源连接池一般请求的连接数超过连接池的最大值的时候就会触发拒绝策略，策略一般是阻塞等待设置的时间或者直接抛异常。而线程池的触发时机如下图：
如图，想要了解线程池什么时候触发拒绝粗略，需要明确上面三个参数的具体含义，是这三个参数总体协调的结果，而不是简单的超过最大线程数就会触发线程拒绝粗略，当提交的任务数大于corePoolSize时，会优先放到队列缓冲区，只有填满了缓冲区后，才会判断当前运行的任务是否大于maxPoolSize，小于时会新建线程处理。大于时就触发了拒绝策略，总结就是：当前提交任务数大于（maxPoolSize + queueCapacity）时就会触发线程池的拒绝策略了。
JDK内置4种线程池拒绝策略 拒绝策略接口定义
在分析JDK自带的线程池拒绝策略前，先看下JDK定义的 拒绝策略接口，如下：
public interface RejectedExecutionHandler { void rejectedExecution(Runnable r, ThreadPoolExecutor executor); } 接口定义很明确，当触发拒绝策略时，线程池会调用你设置的具体的策略，将当前提交的任务以及线程池实例本身传递给你处理，具体作何处理，不同场景会有不同的考虑，下面看JDK为我们内置了哪些实现：
CallerRunsPolicy（调用者运行策略）
public static class CallerRunsPolicy implements RejectedExecutionHandler { public CallerRunsPolicy() { } public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { r.run(); } } } 功能：当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。
使用场景：一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。
AbortPolicy（中止策略）
public static class AbortPolicy implements RejectedExecutionHandler { public AbortPolicy() { } public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { throw new RejectedExecutionException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33c067fd3173cedc40fd580bed1c5fb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54aad9b1597e3bdf048048a306747224/" rel="bookmark">
			MyBatis-Plus使用笔记（二）：MyBatis-Plus增删改查、Wapper条件查询、分页、逻辑删除、性能分析、
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、insert 1、插入操作 测试：
@SpringBootTest class MybatisPlusApplicationTests { @Autowired UserMapper userMapper; @Test void insertUser() { User user = new User(); user.setName("Ada"); user.setAge(30); user.setEmail("ada@qq.com"); int i = userMapper.insert(user); System.out.println("insert : " + i); } } 结果：
**注意：**数据库插入id值默认为：全局唯一id（雪花算法生成，下面会介绍）
2、常见主键生成策略 1）数据库自增长序列或字段
最常见的方式。利用数据库，全数据库唯一。
优点：
简单，代码方便，性能可以接受。数字ID天然排序，对分页或者需要排序的结果很有帮助。 缺点：
在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦。分表分库的时候会有麻烦。 2）UUID
常见的方式。可以利用数据库也可以利用程序生成，一般来说全球唯一。
优点：
简单，代码方便。生成ID性能非常好，基本不会有性能问题。全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对。 缺点：
没有排序，无法保证趋势递增UUID往往是使用字符串存储，查询的效率比较低。存储空间比较大，如果是海量数据库，就需要考虑存储量的问题。传输数据量大 3）Redis生成ID
当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。
可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。各个Redis生成的ID为：
A：1,6,11,16,21
B：2,7,12,17,22
C：3,8,13,18,23
D：4,9,14,19,24
E：5,10,15,20,25
优点：
不依赖于数据库，灵活方便，且性能优于数据库。数字ID天然排序，对分页或者需要排序的结果很有帮助。 缺点：
如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。需要编码和配置的工作量比较大。 4）Twitter的snowflake算法
snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看https://github.com/twitter-archive/snowflake/releases/tag/snowflake-2010
snowflake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数以及统一毫秒可以能的并发数来调整在算法中所需要的bit数。
优点：
不依赖于数据库，灵活方便，且性能优于数据库。ID按照时间在单机上是递增的。 缺点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54aad9b1597e3bdf048048a306747224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a4335d39e322dd7d0198689735f4aa2/" rel="bookmark">
			C&#43;&#43; 中的 Unicode 与 UTF-8 字符编码互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Unicode 转 UTF-8 std::string UnicodeToUTF8(const std::wstring&amp; wstr) { int ansiiLen = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, nullptr, 0, nullptr, nullptr); char* pAssii = (char*)malloc(sizeof(char) * ansiiLen); WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, pAssii, ansiiLen, nullptr, nullptr); std::string ret_str = pAssii; free(pAssii); return ret_str; } UTF-8 转 Unicode char* UTF8ToUnicode(char* szU8) { int wcsLen = ::MultiByteToWideChar(CP_UTF8, NULL, szU8, strlen(szU8), NULL, 0); wchar_t* wszString = new wchar_t[wcsLen + 1]; ::MultiByteToWideChar(CP_UTF8, NULL, szU8, strlen(szU8), wszString, wcsLen); wszString[wcsLen] = '\0'; char* m_char; int len = WideCharToMultiByte(CP_ACP, 0, wszString, wcslen(wszString), NULL, 0, NULL, NULL); m_char = new char[len + 1]; WideCharToMultiByte(CP_ACP, 0, wszString, wcslen(wszString), m_char, len, NULL, NULL); m_char[len] = '\0'; return m_char; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bd07f1599be31c346d932e7c7349ddc/" rel="bookmark">
			Android 9.0 Bluetooth源码分析（三）蓝牙配对流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 UI
蓝牙配对开始于settings设备列表 /packages/apps/Settings/src/com/android/settings/bluetooth/DeviceListPreferenceFragment.java中。
DeviceListPreferenceFragment是蓝牙扫描到的设备列表，点击其中一个蓝牙设备，调用onPreferenceTreeClick方法开始蓝牙的配对过程。
@Override
public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen,
Preference preference) {
if (KEY_BT_SCAN.equals(preference.getKey())) {
mLocalAdapter.startScanning(true);
return true;
}
if (preference instanceof BluetoothDevicePreference) { BluetoothDevicePreference btPreference = (BluetoothDevicePreference) preference; CachedBluetoothDevice device = btPreference.getCachedDevice(); mSelectedDevice = device.getDevice(); //配对连接 onDevicePreferenceClick(btPreference); return true; } return super.onPreferenceTreeClick(preferenceScreen, preference); } 在本地onDevicePreferenceClick方法中调用/packages/apps/Settings/src/com/android/settings/bluetooth/BluetoothDevicePreference.java的onClicked方法：
void onClicked() {
Context context = getContext();
int bondState = mCachedDevice.getBondState();// 获取设备的绑定状态
final MetricsFeatureProvider metricsFeatureProvider = FeatureFactory.getFactory(context).getMetricsFeatureProvider(); if (mCachedDevice.isConnected()) { metricsFeatureProvider.action(context, MetricsEvent.ACTION_SETTINGS_BLUETOOTH_DISCONNECT); askDisconnect(); // 已连接，询问是否断开连接 } else if (bondState == BluetoothDevice.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bd07f1599be31c346d932e7c7349ddc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5556a9066b789864561b6978869c5e00/" rel="bookmark">
			“八皇后问题”之回溯法——C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序分析：在8*8的棋盘上安置八个皇后且相互不能攻击。
一个皇后的攻击范围如下图所示：
其中一种摆法如下：
C++代码：
方法一：
#include &lt;iostream&gt; using namespace std; const int ArSize = 8;//这个数等于几，就是几皇后。 int num = 0; bool check(bool arr[ArSize][ArSize], int row, int column){ // 判断皇后的落点是否合规 if (row == 0){ return true; } int i, j; for (i = 0; i &lt; row; ++i){ // 判断纵向是否有冲突 if (arr[i][column]){ return false; } } i = row - 1; j = column - 1; while (i &gt;= 0 &amp;&amp; j &gt;= 0){ // 判断正斜对角线是否有冲突 if (arr[i][j]){ return false; } --i; --j; } i = row - 1; j = column + 1; while (i &gt;= 0 &amp;&amp; j &lt;= ArSize - 1){ // 判断负斜对角线是否有冲突 if (arr[i][j]){ return false; } --i; ++j; } return true; } void outPut(bool arr[ArSize][ArSize]){ // 打印每种正确的解法 ++num; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5556a9066b789864561b6978869c5e00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b72f872d5bd1579767dde237fb54dd4/" rel="bookmark">
			IDEA导入数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、找到右边的Database 点击
2、点击+ 光标放到Data Source 然后找到你对应的数据类型 这里以MySQL为例子
3、点mysql进来的页面为
4、需要写的内容为 1.User(你的数据库用户名) 2.password(数据库密码 后面选择让记住密码)3.Database(你的对应表的数据库名字) 只需要填写3三出处就可以点下面的Test Connection 如果成功就Appy应用即可
5.如果没成功修改下面的URL 或者下载版本最下面
jdbc:mysql://localhost:3306/customer?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC
也就是在前面基础上加上 ?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC
6、Apply成功之后如图所示
每次加那个不方便 因此 你要是不想换成5.1的话 还有一个措施
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b32acd56f7c5e33800340ca21ca7099/" rel="bookmark">
			JavaEE大作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javaee大作业-学生作业管理系统 项目简介：学生作业管理系统基于mybatis创建的，tomcat服务器版本8.5.42，数据库基于mysql8.
主要功能：
学生登录系统，查看教师布置的作业和提交作业
教师登陆系统，添加学生，添加作业和批改作业
项目结构：
controller层，dao层，model层，utils层，mapper层和web层。
dao层是接口，mapper层是实现到、层接口的xml文件，model层是实体类层，controller是实现功能控制层，webapp是jsp文件用于前端界面的显示。
数据库表如下：
s_student和s_techer是用于存放学生和教师信息
s_homework为教师布置的作业表
s_student_homework用于存放学生提交的作业
功能如下：
登录功能：学生和用户选择对应类型输入账号密码
学生登录成功界面：有用户信息的提示，学生可以对作业内容进行编辑然后提交作业
教师登录后可以选择添加作业，添加学生，批改作业
选择添加学生时：输入学号和姓名，选择添加时间，点击添加即可添加学生
选择添加作业：输入作业id，作业标题和选择发布时间，点击添加即可添加学生
查看作业：教师查看学生提交的作业，对作业进行评分，然后提交分数即可
docker image使用commit的方法，将tomcat，jdk和项目打包后放入创建的docker容器内，让后push到存储库。
项目运行选择github地址获取代码的方式要方便于docker images方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/627b091498bdbac2c03600fb35c022a3/" rel="bookmark">
			Greenplum6.x安装PXF插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Greenplum6.x安装PXF插件目录 1 安装Hadoop与Hive的客户端 1.1 在大数据平台的主节点(namenode)上打包客户端 1.2 把文件scp到Greenplum的master节点上 2 Greenplum的master节点解压文件配置环境变量 2.1 解压文件 2.2 对文件重命名 2.3 为 gpadmin配置环境变量 3 PXF安装 3.1 PXF 初始化 3.2 创建新的文件夹 3.3 修改pxf-env.sh配置文件 3.4 把配置文件复制到目录下 3.5 PXF 同步文件 3.6 开启PXF 4 测试PXF 4.1 查看hive与hdfs数据 4.1 测试PXF连接Hive 4.2 测试PXF连接Haddop 5 PXF单节点安装说明 1 安装Hadoop与Hive的客户端 以下实例是在ambari管理的大数据平台,hdp版本是2.6.5.0
1.1在大数据平台的主节点(namenode)上打包客户端 1、登录到ambari的主节点，登录hdfs用户，进入到/usr/hdp/2.6.5.0-292下 2、以此打包安装好的hadoop与hive与hbase的组件 [hdfs@*** 2.6.5.0-292]$ zip -r hadoop-2.6.zip hadoop [hdfs@*** 2.6.5.0-292]$ zip -r hive-2.6.zip hive [hdfs@*** 2.6.5.0-292]$ zip -r hbase-2.6.zip hbase 1.2把文件scp到Greenplum的master节点上 [hdfs@*** 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/627b091498bdbac2c03600fb35c022a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32ecc96020f70d8e84b8c5b07aee6a28/" rel="bookmark">
			gcode指令大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		G代码是数控程序中的指令。一般都称为G指令。
代码功能
G代码
代码名称-功能简述
G00------快速定位
G01------直线插补
G02------顺时针方向圆弧插补
G03------逆时针方向圆弧插补
G04------定时暂停
G05------通过中间点圆弧插补
G06------抛物线插补
G07------Z 样条曲线插补
G08------进给加速
G09------进给减速
G10------数据设置
G16------极坐标编程
G17------加工XY平面
G18------加工XZ平面
G19------加工YZ平面
G20------子程序调用
G22------半径尺寸编程方式
G220-----系统操作界面上使用
G23------直径尺寸编程方式
G230-----系统操作界面上使用
G24------子程序结束
G25------跳转加工
G26------循环加工
G30------倍率注销
G31------倍率定义
G32------等螺距螺纹切削，英制
G33------等螺距螺纹切削，公制
G34------增螺距螺纹切削
G35------减螺距螺纹切削
G40------刀具补偿/刀具偏置注销
G41------刀具补偿——左
G42------刀具补偿——右
G43------刀具偏置——正
G44------刀具偏置——负
G45------刀具偏置+/+
G46------刀具偏置+/-
G47------刀具偏置-/-
G48------刀具偏置-/+
G49------刀具偏置0/+
G50------刀具偏置0/-
G51------刀具偏置+/0
G52------刀具偏置-/0
G53------直线偏移，注销
G54------直线偏移x
G55------直线偏移y
G56------直线偏移z
G57------直线偏移xy
G58------直线偏移xz
G59------直线偏移yz
G60------准确路径方式（精）
G61------准确路径方式（中）
G62------准确路径方式（粗）
G63------攻螺纹
G68------刀具偏置，内角
G69------刀具偏置，外角
G70------英制尺寸 寸
G71------公制尺寸 毫米
G74------回参考点(机床零点)
G75------返回编程坐标零点
G76------车螺纹复合循环
G80------固定循环注销
G81------外圆固定循环
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32ecc96020f70d8e84b8c5b07aee6a28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/379a65851e0e6ae57d6decd505ba71ee/" rel="bookmark">
			python实现一个简单的猜数游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要求：预设一个0-9之间的整数，让用户猜一猜并输入所猜的数，如果大于预设的数，显示“太大”；小于预设的数，显示“太小”；如此循环，直至猜中该数，显示“恭喜！你猜中了！”
代码：
def guessNum(guess): ''' guess: 要猜的数 num： 输入的数 ''' num = int(input()) if guess == num: print('恭喜！你猜中了！') else: if num &gt; guess: print('太大') return guessNum(guess) else: print('太小') return guessNum(guess) if __name__ == "__main__": guess = int(input('预设一个0-9之间的整数:')) # 预设一个0-9之间的整数 guessNum(guess) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c400fe037c24489a95460bf938b7f29a/" rel="bookmark">
			损失函数 Loss、梯度 grad、参数 ω 和 学习率 lr 之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		举一个简单的函数 y = x 2 y = x^2 y=x2，梯度为 g ( x ) = ∂ y ∂ x = 2 x g(x) = \frac{\partial{y}}{\partial{x}} = 2x g(x)=∂x∂y​=2x。设学习率为 l r lr lr，那么
更新一次梯度后为： x 1 = x 0 − l r ∗ g ( x 0 ) = x 0 − l r ∗ 2 x 0 = ( 1 − 2 ∗ l r ) x 0 x_1 = x_0 - lr * g(x_0) = x_0 - lr * 2x_0 = (1 - 2 * lr)x_0 x1​=x0​−lr∗g(x0​)=x0​−lr∗2x0​=(1−2∗lr)x0​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c400fe037c24489a95460bf938b7f29a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38eb3af95386e7dd37fe3fb749c7c666/" rel="bookmark">
			初学卷积——卷积的计算过程及应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面：
因为本人初学科学计算这一块，这两天遇到了卷积的问题，有点琢磨不透，就了解了一下卷积的计算过程及使用场景，因为时间太短，这里只能写下一点点个人的心得体会，希望大家多多包函与指教。
目录 一、卷积公式二、卷积的翻转和平移1.卷积的翻转2.卷积的平移 三、卷积的计算方法四、卷积的边缘效应五、卷积的实际意义六、convolve说明七、参考 一、卷积公式 由于还没学习到二维卷积，所以我们这里只进行一维卷积的讨论。
离散卷积：
离散的数据，就好比是我们平时的考试成绩（0,1,2,…,100），离散卷积的公式如下：
这里i的定义域为负无穷到正无穷，当然具体的问题要具体分析，比如成绩（100分满分），那么i的定义域就是（0-100）。连续卷积：
连续的数据，我们还是说成绩，但是这个老师比较牛*，他打分甚至可以个给你打根号，也就是说是0-100之间的所有实数。连续卷积的公式如下：
这里定积分的下限是负无穷，上限是正无穷，同理，还是具体情况具体分析，如果还是那个打分情况，那么就是下限为0，上限为100。
注：这里的*是卷积的符号，不是乘法。公式说明：
我们可以从这两个公式中发现一个情况，就是无论是离散情况还是连续情况，都会有n = i + (n - i)和t = τ + (t - τ)，那么这个问题我们后续在卷积翻转的时候再说明。 二、卷积的翻转和平移 1.卷积的翻转 卷积的翻转也即“卷”字的由来，由于本人技术有限绘制不了git图，所以这里用静态图片说明。
我们先讲解离散的情况（主要是连续的图太难画了呜呜呜）。我们以小学教学为例，只有语文和数学，各科满分100，且两者是相互独立的，互不干扰，那么假设小明总分195分，于是小明会有如下几个情况：
语文：95分；数学：100分。(出现的概率：g(195) = c(95) · m(100))语文：96分；数学：99分。(出现的概率：g(195) = c(96) · m(99))语文：97分；数学：98分。(出现的概率：g(195) = c(97) · m(98))语文：98分；数学：97分。(出现的概率：g(195) = c(98) · m(97))语文：99分；数学：96分。(出现的概率：g(195) = c(99) · m(96))语文：100分；数学：95分。(出现的概率：g(195) = c(100) · m(95)) 那么所有的概率即上述六个的求和，也即离散的那个公式。相应的图示如下：
从上面的图看出这个线条错综复杂，是不是和你早上起来枕头上的头发一样凌乱，所以这里使用卷积的“卷”，对“语文”进行翻转，让他看的清晰一些。如下图所示：
这样的线条不凌乱了，但是数字还是倒着的，所以再对每个数字翻转一次。如下图所示：
这样那么卷积的翻转就完成了，接下来就是卷积的平移问题。
2.卷积的平移 我们刚刚讨论的是195分的情况，那么如果是196分、197分甚至200分呢？那么就是上面（或者下面）的框框平移的过程了。如果学过计算机网络的同学，可以类比一下停止等待协议里面的滑动窗口，比较方便理解。
那么来到196分，196分的情况就比之前少了一种，各种情况分别是：
语文：96分；数学：100分。(出现的概率：g(196) = c(96) · m(100))语文：97分；数学：99分。(出现的概率：g(196) = c(97) · m(99))语文：98分；数学：98分。(出现的概率：g(196) = c(98) · m(98))语文：99分；数学：97分。(出现的概率：g(196) = c(99) · m(97))语文：100分；数学：96分。(出现的概率：g(196) = c(100) · m(96)) 而对应的翻转后的图片如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38eb3af95386e7dd37fe3fb749c7c666/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ea7b947f8e0290e8173c9a6e0be8528/" rel="bookmark">
			vue之src图片路径地址动态拼接的方法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 很常见的需求了。根据后台返回的数据，展示本地对应的图片。这个时候，需要对图片地址的src进行拼接。
由于静态资源路径，方式不对，很容易导致地址有问题。
1、方式一： &lt;template&gt; &lt;div v-for="(item,index) in menus :key="index&gt; &lt;img :src="require(`../../assets/images/${item.icon}`)" /&gt; &lt;span&gt;{{item.name}}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; 后台返回的数据譬如
menus: [ { "icon": "icon_1.png", "name: "首页" }, { "icon": "icon_2.png", "name: "副页" } ] 一句话，在:src中，使用require 和模板字符串，就可以拼接引入正确的路径地址。
2、方式二， ：src 绑定一个函数，然后在methods中定义这个函数，函数内部还是使用require来获取到正确的地址后，返回出去。
&lt;template&gt; &lt;div v-for="(item,index) in menus :key="index&gt; &lt;img :src="bindIcon(item.icon)" /&gt; &lt;span&gt;{{item.name}}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; bindIcon(icon) { return require("@/assets/images/"+icon); } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/363/">«</a>
	<span class="pagination__item pagination__item--current">364/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/365/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>