<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f32c8882f72b14c822fca794abe1ce9/" rel="bookmark">
			Cocos2d-x关于ScrollView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天在学关于cocos2d-x中关于ScrollView的相关东西。
要使用CCScrollView的相关方法要包含头文件cocos-ext.h，而命名空间的使用的是USING_NS_CC_EXT;
CCScrollVIew的主要方法：
//滑动方向 typedef enum { kCCScrollViewDirectionNone = -1, kCCScrollViewDirectionHorizontal = 0, kCCScrollViewDirectionVertical, kCCScrollViewDirectionBoth } CCScrollViewDirection; 滑动方向的一个枚举；
class CCScrollViewDelegate { public: virtual ~CCScrollViewDelegate() {} virtual void scrollViewDidScroll(CCScrollView* view) = 0; //滑动调用 virtual void scrollViewDidZoom(CCScrollView* view) = 0; //缩放调用 }; 这个是关于ScrollView的一个代理，一般我们要写一个自己的ScrollView的时候要继承这个代理；
//关于容器坐标的方法 void setContentOffset(CCPoint offset,bool animated=false) CCPoint getContentOffset(); //设置和获取容器的方法 CCNode* getContainer(); void setContainer(CCNode* pContainer); //设置和获取容器大小 virtual void setContentSize(const CCSize&amp; size); virtual const CCSize&amp; getContentSize()const: //设置和获取是否有弹性效果 bool isClippingToBounds() {return m_bClippingToBounds; } void setClippingToBounds(bool bClippingToBounds) { m_bClippingToBounds = bClippingToBounds; } //获得和设置滑动方向的方法 CCScrollViewDirection getDirection() { return m_eDirection;} virtual void setDirection(CCScrollViewDirection eDirection) { m_eDirection = eDirection; } 以上是这两天学习的时候用到的相关方法，这个CCScrollView还有其他的方法，合理的使用能得到非常好的效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f32c8882f72b14c822fca794abe1ce9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f95093e7143e9e47e26fdb3609cc3419/" rel="bookmark">
			JAVA学习笔记（二）JAVA箭头函数，Lambda表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://www.cnblogs.com/goodshred/p/9882764.html
// 1. 不需要参数,返回值为 5 () -&gt; 5 // 2. 接收一个参数(数字类型),返回其2倍的值 x -&gt; 2 * x // 3. 接受2个参数(数字),并返回他们的差值 (x, y) -&gt; x – y // 4. 接收2个int型整数,返回他们的和 (int x, int y) -&gt; x + y // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) (String s) -&gt; System.out.print(s)
String[] atp = {"Rafael Nadal", "Novak Djokovic", "Stanislas Wawrinka", "David Ferrer","Roger Federer", "Andy Murray","Tomas Berdych", "Juan Martin Del Potro"}; List&lt;String&gt; players = Arrays.asList(atp); // 以前的循环方式 for (String player : players) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f95093e7143e9e47e26fdb3609cc3419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8604b0db5adf043ff5f3308d7606411f/" rel="bookmark">
			11-字符数组和字符串函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组 int float double
char 字符数组
一、字符数组
1、字符数组的一般形式
char 数组名[常量表达式]
char cArray[5];
2、字符数组的引用跟其他类型是一样，用下标。
char cArray[5];
cArray[0]='H';
cArray[1]='e';
cArray[2]='l';
cArray[3]='l';
cArray[4]='o';
3、字符数组的初始化
(1)逐个元素进行初始化，初始化时可以省略下标。
char cArray[5] = { 'H', 'e','l','l','o' };
char cArray[] = { 'H', 'e', 'l', 'l', 'o' };
(2)用字符串对数组赋值，初始化时可以省略下标
char cArray[5] = {"hello"};
char cArray[]={"hello"};
char cArray[]="hello"; (最常用)
注意：1、使用字符串进行初始化，系统会自动在数组里面加上一个'\0'，作为字符串结束的标志
char cArray[]="hello"; 等效于char cArray[] = { 'H', 'e', 'l', 'l', 'o','\0' };
printf("%d\n", sizeof(cArray));
printf("%d\n", sizeof(cArray1));
注意：2、用中文的字符串 一个中文的字节数为2.
printf("%d", sizeof("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8604b0db5adf043ff5f3308d7606411f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d044bc4880c4f4b605607a86baea2594/" rel="bookmark">
			电商项目实战--收货地址相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		27. 收货地址-分析 关于“收货地址”数据的管理，涉及的功能有：增加，修改，删除，设为默认，显示列表。
以上功能的开发顺序应该是：增加 &gt; 显示列表 &gt; 设为默认 &gt; 删除 &gt; 修改。
28. 收货地址-创建数据表 创建收货地址数据表：
CREATE TABLE t_address ( aid INT AUTO_INCREMENT COMMENT '收货地址id', uid INT COMMENT '用户id', name VARCHAR(50) COMMENT '收货人姓名', province_code CHAR(6) COMMENT '省代号', province_name VARCHAR(50) COMMENT '省名称', city_code CHAR(6) COMMENT '市代号', city_name VARCHAR(50) COMMENT '市名称', area_code CHAR(6) COMMENT '区代号', area_name VARCHAR(50) COMMENT '区名称', zip CHAR(6) COMMENT '邮编', address VARCHAR(100) COMMENT '详细地址', phone VARCHAR(20) COMMENT '手机', tel VARCHAR(20) COMMENT '固话', tag VARCHAR(30) COMMENT '地址类型', is_default INT COMMENT '是否默认，0-非默认，1-默认', created_user VARCHAR(50) COMMENT '创建人', created_time DATETIME COMMENT '创建时间', modified_user VARCHAR(50) COMMENT '最后修改人', modified_time DATETIME COMMENT '最后修改时间', PRIMARY KEY (aid) ) DEFAULT CHARSET=UTF8; 29.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d044bc4880c4f4b605607a86baea2594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f004d1d4da27a18eb37391e1af12ea03/" rel="bookmark">
			要开始准备找工作了，昨天闲时就自己写了个数据结构排序类，包括了堆排序，归并排序，速度排序，插入排序。...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要开始准备找工作了，昨天闲时就自己写了个数据结构排序类，包括了堆排序，归并排序，速度排序，插入排序，正在继续完善中......
SortAlgorithm.h 代码如下：
#pragma once
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;
class SortAlgorithm
{
public:
SortAlgorithm(void);
~SortAlgorithm(void);
void heapsort(vector&lt;int&gt; &amp;n);
void mergesort(vector&lt;int&gt; &amp;n);
void quicksort(vector&lt;int&gt; &amp;n);
void insertsort(vector&lt;int&gt; &amp;n);
private:
void Down(vector&lt;int&gt; &amp;n, int hole, int L);
void mergeSort(vector&lt;int&gt; &amp;n, vector&lt;int&gt; &amp;tmp, int s, int e);
void merge(vector&lt;int&gt; &amp;n, vector&lt;int&gt; &amp;tmp, int s, int mid, int e);
void quickSort(vector&lt;int&gt; &amp;n, int s, int e);
int getMidVal(vector&lt;int&gt; &amp;n, int s, int e);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f004d1d4da27a18eb37391e1af12ea03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24d2d31228d4d82a1a1faee43b21b84c/" rel="bookmark">
			c语言图形函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言图形函数 封闭图形的填充 填充就是用规定的颜色和图模填满一个封闭图形。 一、先画轮廓再填充 TURBO C提供了一些先画出基本图形轮廓, 再按规定图模和颜色填充整个封 闭图形的函数。在没有改变填充方式时, TURBO C以默认方式填充。 下面介绍这 些函数。 void far bar(int x1, int y1, int x2, int y2); 确定一个以(x1, y1)为左上角, (x2, y2)为右下角的矩形窗口, 再按规定图 模和颜色填充。 说明: 此函数不画出边框, 所以填充色为边框。 void far bar3d(int x1, int y1, int x2, int y2, int depth, int topflag); 当topflag为非0时, 画出一个三维的长方体。当topflag为0时, 三维图形不 封顶, 实际上很少这样使用。 说明: bar3d()函数中, 长方体第三维的方向不随任何参数而变, 即始终为 45度的方向。 void far pieslice(int x, int y, int stangle, int endangle, int radius); 画一个以(x, y)为圆心, radius为半径, stangle为起始角度, endangle 为 终止角度的扇形, 再按规定方式填充。当stangle=0, endangle=360 时变成一个 实心圆, 并在圆内从圆点沿X轴正向画一条半径。 void far sector(int x, int y, int stanle, intendangle, int xradius, int yradius); 画一个以(x, y)为圆心分别以xradius, yradius为x轴和y轴半径, stangle 为起始角, endangle为终止角的椭圆扇形, 再按规定方式填充。 二、设定填充方式 TURBO C有四个与填充方式有关的函数。下面分别介绍: void far setfillstyle(int pattern, int color); color的值是当前屏幕图形模式时颜色的有效值。pattern的值及与其等价的 符号常数如表7所示。 表7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24d2d31228d4d82a1a1faee43b21b84c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba3932dbaf9baa350f58af59f63146c2/" rel="bookmark">
			昨天看了一本c#的教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天看了一本c#的教程 昨天看了一本c#的教程,那是本很早前就买了的书,虽然也不是没看过,但是昨天重新看了下,感觉收获还是不小的,从c#的类型,到它的方法,还有就是面向对象的一些概念(覆盖,继承……)。我不敢说我学到了多少，但是我很喜欢 posted on 2006-02-28 10:34 Aween's Blog 阅读( ...) 评论( ...) 编辑 收藏 转载于:https://www.cnblogs.com/aween/archive/2006/02/28/339388.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e52a190bed8e4aeefdf9e1d07399d78/" rel="bookmark">
			js继承优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在看《js设计模式》中，作者提到了js中的两种继承方式：类继承 或 原型继承，或许是本人才疏学浅，竟发现一些问题。
一、类继承
思路：作者的思路是使用基于类来继承，并且做了一个extend函数，在第一时间就吸引了我的眼球，函数如下：
1 function extend(subClass, superClass){
2 var F = function (){};
3 F.prototype = superClass.prototype;
4 subClass.prototype = new F();
5 subClass.prototype.constructor = subClass;
6 } 在js中sunClass和superClass分别是子类和父类的名字(即函数的名字).
在使用的时候作者的思路类似是这样:
1 function Person()
2 {
3 this .attr1 = 1 ;
4 this .attr2 = 2 ;
5 this .attr3 = 3 ;
6 }
7 8 function Author()
9 {
10 Person.apply( this );
11 }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e52a190bed8e4aeefdf9e1d07399d78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91fc9a0e78350c65087d22053dac1a3a/" rel="bookmark">
			linux系统中socket错误码：EINTR和EAGAIN的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
人为重启被中断的系统调用
安装信号时设置 SA_RESTART属性
忽略信号
永远阻塞的系统调用，被信号中断，导致其不继续等待，转而去执行signal_handler
1、什么是慢系统调用？ 该术语适用于那些可能永远阻塞的系统调用。永远阻塞的系统调用是指调用永远无法返回，多数网络支持函数都属于这一类。如：若没有客户连接到服务器上，那么服务器的accept调用就会永远阻塞。
慢系统调用可以被永久阻塞，包括以下几个类别：
（1）读写‘慢’设备（包括pipe，终端设备，网络连接等）。读时，数据不存在，需要等待；写时，缓冲区满或其他原因，需要等待。
（2）当打开某些特殊文件时，需要等待某些条件，才能打开。例如：打开中断设备时，需要等到连接设备的modem响应才能完成。
（3）pause和wait函数。pause函数使调用进程睡眠，直到捕获到一个信号。wait等待子进程终止。
（4）某些ioctl操作。
（5）某些IPC操作。
2、EINTR错误产生的原因-（阻塞的系统调用、或者非阻塞的系统调用） 如果进程在一个慢系统调用(slow system call)中阻塞时，当捕获到某个信号且相应信号处理函数返回时，这个系统调用不再阻塞而是被中断，就会调用返回错误（一般为-1）&amp;&amp;设置errno为EINTR（相应的错误描述为“Interrupted system call”）。
如下表所示的系统调用就会产生EINTR错误，当然不同的函数意义也不同。
系统调用函数errno为EINTR表征的意义write由于信号中断，没写成功任何数据。The call was interrupted by a signal before any data was written.open由于信号中断，没读到任何数据。The call was interrupted by a signal before any data was read.recv sem_wait函数调用被信号处理函数中断。The call was interrupted by a signal handler. 3、解决办法 既然系统调用会被中断，那么别忘了要处理被中断的系统调用。有三种处理方式：
解决方法1：重启被中断的系统调用 当碰到EINTR错误的时候，有一些可以重启的系统调用要进行重启，而对于有一些系统调用是不能够重启的。例如：accept、read、write、select、和open之类的函数来说，是可以进行重启的。不过对于套接字编程中的connect函数是不能重启的，若connect函数返回一个EINTR错误的时候，我们不能再次调用它，否则将立即返回一个错误。针对connect不能重启的处理方法是，必须调用select来等待连接完成。
理解“重启”？一些IO系统调用执行时，如 read 等待输入期间，如果收到一个信号，系统将中断read， 转而执行信号处理函数. 当信号处理返回后， 系统遇到了一个问题： 是重新开始这个系统调用? 还是让系统调用失败?早期UNIX系统的做法是：中断系统调用，并让系统调用失败， 比如read返回 -1， 同时设置 errno 为EINTR中断了的系统调用是没有完成的调用，它的失败是临时性的，如果再次调用则可能成功，这并不是真正的失败，所以要对这种情况进行处理， 典型的方式为“重启”，采用accept函数为例子，代码如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91fc9a0e78350c65087d22053dac1a3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/002181f10156c6277d763953d544b5a1/" rel="bookmark">
			SQL Server 数据库文件路径迁移步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用背景 实际项目中，经常由于数据库服务器磁盘空间不足，导致现场数据无法及时入库，引发系统无法访问的问题，这种情况一般是清理服务的磁盘空间，主要有，删除不必要的日志、备份文件或不必要的软件等；但是，对于数据库服务器而言，除了必要的软件外，一般不在安装其他软件，保存的基本上为现场数据文件，所以，针对这种情况，一般我们只能做数据迁移，迁移至空间更大的磁盘或者其他服务器中。这里以SQL Server数据为例，简要说明涉及到的步骤。
二、实现步骤 1.更改数据库实例（含数据文件和日志文件）的保存路径 使用SQL Server自带的连接工具，SQL Server Management Studio，连接后，在连接名处，右击，选择“属性”，在属性框，定位至“数据库设置”选项卡，在“数据库默认位置”设置新的路径，如下图：
点击“确定”，保存修改，此时，会及时生效，不需要重启服务；
2.更改用户数据库（含数据库文件和日志文件）的保存路径 a）新建查询语句，分别输入以下命令，查询用户数据库存储位置 select database_id,name,physical_name AS CurrentLocation,state_desc,size from sys.master_files where database_id=db_id(N'prd_poms');
其中，prd_poms表示用户自己定义的数据库名称，该语句用于查询，prd_poms数据库的数据文件和日志文件的名称，以及对应的路径，便于后续步骤使用。
查询结果可能如下图：
b）更改用户数据库的保存路径 输入以下语句：
alter database prd_poms modify file ( name = prd_poms, filename = 'D:\Program Files\Microsoft SQL Server\MSSQL11.MSSQLSERVER\MSSQL\DATA\prd_poms.mdf');
alter database prd_poms modify file ( name = prd_poms_log, filename = 'D:\Program Files\Microsoft SQL Server\MSSQL11.MSSQLSERVER\MSSQL\DATA\prd_poms_log.ldf');
上述语句中，粗体红色的部分为数据库的名称，与步骤a）中的数据库名称一致，斜体红色部分对应步骤a）中查询的结果，分别表是文件名称，而红色斜体黄色背景部分为，文件更改后最终需要保存的路径。
c）执行后，在文件正确的情况下，会提示修改成功。 注：由于SQL Server数据库还有系统数据库，因此，还需要对系统数据库按照上述步骤做同样的修改，这里不再累述。
3.修改完成后，需要重启数据库服务，才能使设置生效。 a）暂定数据库服务，打开SQL Server 配置管理器（数据库自带工具），找到SQL Server服务，停止服务，如下图：
或者直接在系统的“服务”中，找到SQL Server服务，停止服务也OK。
b）停止数据库服务后，要确保新的路径已经存在，否则会导致数据库无法启动，以及其他异常。所以，没有的路径，请新建路径。再将原来数据库文件（含数据和日志文件）均复制到新的目录中。注：数据库服务必须要停止，否则无法复制相关文件。
3.重启数据库服务，使所有配置生效
三、出现的问题 若出现无法启动的情况，且从系统的“事件查看器”中，发现原因为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/002181f10156c6277d763953d544b5a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b200c7199338e2ed0444cc7c85d6dc9e/" rel="bookmark">
			UIWebView获得内容的高  高度自适应 宽度自适应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UIWebView获得内容的高－作出自适应高的UIWebView
- (void)webViewDidFinishLoad:(UIWebView *)webView { NSString *height_str= [webView stringByEvaluatingJavaScriptFromString: @"document.body.offsetHeight"]; int height = [height_str intValue]; webView.frame = CGRectMake(0,0,320,height); NSLog(@"height: %@", [webView stringByEvaluatingJavaScriptFromString: @"document.body.offsetHeight"]); } IOS UIWebView截获html并修改便签内容,宽度自适应 iosuiwebview宽度自适应 需求：混合应用UIWebView打开html后，UIWebView有左右滚动条，要去掉左右滚动效果； 方法：通过js截获UIWebView中的html，然后修改html标签内容； 实例代码： 服务器端html Java代码 收藏代码 &lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; &lt;title&gt;网曝四川省一考场时钟慢半小时 老师称这就是命&lt;/title&gt;&lt;/head&lt;body&gt;网曝四川省一考场时钟慢半小时 老师称这就是命&lt;/body&gt;&lt;/html&gt; 这样显示的结果网页的最小宽度会是device-width；但有时候不需要这个宽度，就需要修改width=device-width为width=myWidth; 客户端代码 Java代码 收藏代码 - (void)webViewDidFinishLoad:(UIWebView *)webView { //修改服务器页面的meta的值 NSString *meta = [NSString stringWithFormat:@"document.getElementsByName(\"viewport\")[0].content = \"width=%f, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\"", webView.frame.size.width]; [webView stringByEvaluatingJavaScriptFromString:meta]; } 这样问题就可以解决了 新增代码： Java代码 收藏代码 //给网页增加utf-8编码 [webView stringByEvaluatingJavaScriptFromString: @"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b200c7199338e2ed0444cc7c85d6dc9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cfd832eb6e9a9200759b3de2c0e1887/" rel="bookmark">
			iOS   JSON 和  Mode l转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MJExtension 是我们项目开发常用的一个第三方框架 很好用.
https://github.com/CoderMJLee/MJExtension
映射 json value key 直接使用 非常方便
eg:
#import "NSObject+MJKeyValue.h" interestingActivityModel = [InterestingActivityModel objectWithKeyValues:result_data]; InterestingActivityModel 是我自己写的一个 模型 参数 要和 key 一一对应 一模一样
result_data 是返回的 json 就对应上了
遇到问题具体情况具体分析
这个MJ 第三方库很不错 收藏 转载于:https://www.cnblogs.com/someonelikeyou/p/4955885.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c2a0701998f3c8d895cb8e0d715b375/" rel="bookmark">
			IOS  UItableView 滚动到底 触发事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发过程中，在使用UItableView 总会遇到加载更多的问题，到底是手势响应瀑布流的方法好？
还是添加一个底端cell点击触发加载更多好？我也想有自己的判断。但是我们老板总说了算，没办法，谁叫我给人家打工呢？
cell触发式略，这个很简单。
下边讲下怎么响应瀑布流。
主要有上拉刷新 和下提加载 这两种操作。关键是判断何时执行:滚动到最上边，滚动到最下边
给出一个方法，目前我是这么做的，有更好的方法我再备份。
- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate{ if(NO) { } else { CGPoint offset1 = scrollView.contentOffset; CGRect bounds1 = scrollView.bounds; CGSize size1 = scrollView.contentSize; UIEdgeInsets inset1 = scrollView.contentInset; float y1 = offset1.y + bounds1.size.height - inset1.bottom; float h1 = size1.height; if (y1 &gt; tabView.frame.size.height) { flagShuaxin = YES; } else if (y1 &lt; tabView.frame.size.height) { flagShuaxin = NO; } else if (y1 == tabView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c2a0701998f3c8d895cb8e0d715b375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f18f45a4c392585c784b5209d10a1e/" rel="bookmark">
			Word Search
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
For example,
Given board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word = "ABCCED", -&gt; returns true,
word = "SEE", -&gt; returns true,
word = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00f18f45a4c392585c784b5209d10a1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f46cbeb0e6e835632567edd3ea0f8163/" rel="bookmark">
			《oracle大型数据库系统在AIX/unix上的实战详解》讨论十二：关于读书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢大家对这本书的热情和踊跃来信。这段日子有几位朋友都提出了类似于下面问题的问题：
我在找这方面的工作，想学习您这本书进这一行，您看看怎么看合适，太厚了。 我想开始阅读《oracle大型数据库系统在AIX/unix上的实战详解》这本书，请问您有什么好的建议，比如：阅读哪些关键的章节，因为我司的部分客户有这方面需求，如何合理在unix系统上规划oracle数据库，如何建立数据库以及用户权限规划和分配等。 书太厚了，我想挑着看，从哪里看合适呢？请问。 我是辽河油田的，以前上过您的课，在时代朝阳。文老师给个建议吧，怎么这本书好一些 …………………………. 还是先得感谢大家的厚爱！
我是这么看的: 该书结合平台，读者也都是这个平台上的用户，似乎需要什么读什么为好。
1：也没必要从头看，这个章内容相对独立，如您需要了解集群，那就看集群就行了，如需备份，则备份那部分！
2：如果是初学者，前四章需要看，这里理论基础。当然，需要参考一些更基础的东西为好。
3：如果是多系统的管理员，最后一章看看。
4：如果系统仍属构架阶段，则倒数第二章看看。
5：如果您是学生，从头看好，艺多不压身，知识无捷径！
个人浅见，大家斟酌之！
最后，祝大家新年顺利、有所成就！
转载于:https://www.cnblogs.com/dbserver/archive/2010/01/09/1642789.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9846bce8b5ba047248f27ba4cd825408/" rel="bookmark">
			《Oracle大型数据库在AIX UNIX上的实战详解》的集中讨论十一 AIX条带化、存储条带化、ASM条带化...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天若干朋友集中在这个问题进行讨论： AIX支持条带、ASM支持条带，买的存储（如DS4700）支持条带，都用？都不用？用部分？
1：我不认为条带越多越好。
2：如果存储设置了条带（如RAID 0+1的条带和镜像），在AIX创建逻辑卷的时候再次创建条带化，这就是第二次的条带化，会导致读性能下降。
3：原因分析：二次条带中，AIX中会将数据分裂为各个stripe，然后每个stripe在存储上再次打散为若干个stripe。这对写操作可以认为接近好事，但是读时由于数据在再聚合，以及物理磁盘缓存（cache）的无用化，二次条带将导致读性能的下降。
4：ASM可以使用。使用ASM的话，最好使用外部冗余机制，道理类似。 以上是我对这个问题的看法，个人观点，仅供参考！ 文平
转载于:https://www.cnblogs.com/dbserver/archive/2010/01/06/1640734.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ac664ee20cff58d5068afe4e2ea8271/" rel="bookmark">
			Android journey3 @点击事件的4种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于android布局中的控件，如Button等会有相应的点击事件去响应它所需要的功能，今天我们就以电话拨号器的代码说明下几种点击事件：
1 package com.itheima.phone; 2 3 import android.net.Uri; 4 import android.os.Bundle; 5 import android.app.Activity; 6 import android.content.Intent; 7 import android.view.Menu; 8 import android.view.View; 9 import android.view.View.OnClickListener; 10 import android.widget.Button; 11 import android.widget.EditText; 12 import android.widget.Toast; 13 14 public class MainActivity extends Activity implements OnClickListener { 15 private EditText et_number; 16 17 // 当activity被启动的时候 调用的方法. 18 @Override 19 protected void onCreate(Bundle savedInstanceState) { 20 super.onCreate(savedInstanceState); 21 setContentView(R.layout.activity_main); 22 Button bt_dail = (Button) findViewById(R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ac664ee20cff58d5068afe4e2ea8271/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcae51e3969f64d9b8ab1666ff15d2c5/" rel="bookmark">
			实例详解JSP内置对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jsp九种内置对象：request, reponse, out, session, application, config, pagecontext, page, exception. 一.request对象：该对象封装了用户提交的信息，通过调用该对象相应的方法可以获取封装的信息，即使用该对象可以获取用户提交信息。
1.Request对象可以使用getParameter(string s)方法获取该表单通过text提交的信息。如：
Request.getParameter(“boy”)
例：request1.jsp：
&lt;%@ page contentType="text/html;charset=GB2312" %&gt;
&lt;HTML&gt;
&lt;BODY bgcolor=green&gt;&lt;FONT size=1&gt;
&lt;FORM action="tree.jsp" method=post name=form&gt;
&lt;INPUT type="text" name="boy"&gt; &lt;INPUT TYPE="submit" value="Enter" name="submit"&gt;
&lt;/FORM&gt; &lt;/FONT&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
tree.jsp：
&lt;%@ page contentType="text/html;charset=GB2312" %&gt;
&lt;HTML&gt;
&lt;BODY bgcolor=green&gt;&lt;FONT size=1&gt;　&lt;P&gt;获取文本框提交的信息：
&lt;%String textContent=request.getParameter("boy");
%&gt;
&lt;BR&gt;
&lt;%=textContent%&gt; &lt;P&gt; 获取按钮的名字：
&lt;%String buttonName=request.getParameter("submit");
%&gt;
&lt;BR&gt;
&lt;%=buttonName%&gt; &lt;/FONT&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
使用request对象获取信息要格外小心，要避免使用空对象，否则会出现NullPointerException异常，所以我们可以作以下处理.
request3.jsp
&lt;%@ page contentType="text/html;charset=GB2312" %&gt;
&lt;HTML&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcae51e3969f64d9b8ab1666ff15d2c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3a49c4fd4e35b599eb0ef3912b3aad5/" rel="bookmark">
			怎样学习新语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个C++出身的程序员，好多语言看起来都很陌生，但是又十分有吸引力
Python Perl Ruby Lisp Lua Haskell Ocaml 其实学习一门语言的过程并不简单，需要花费很多的时间来与它建立亲密的关系，浅尝辄止基本上是不能领会其中的奥秘的。
但是无论如何，学习的脚本不能停止。
对于零碎时间的合理利用，以及良好的规划，可以让这个进程更加有效。
其次是对于各种语言的第一印象，以及事先考虑可以从这门语言中汲取什么方面的营养，可以让这个进程更加有目的性。
Lua以小而快见称，因此学习Lua，并且将其与其他语言结合使用会更加符合其设计理念。
Ruby最强大的是元编程，这其实是C++语言很欠缺的功能，可以在实际应用中补充C++语言的弱项。
再次，规划好每种语言的应用场合，可以使这个进程更加有产出。
比如学习Perl中对于正则表达式的处理，并且结合Linux Shell应用会是一个很有产出的过程。
转载于:https://www.cnblogs.com/long123king/p/3934571.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b378b491dc659d4fe24c7a595e43c74/" rel="bookmark">
			Linux用户空间内存区域的匿名映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 在调用mmap系统调用时，可以指定的标志(flag)参数：
1: #define MAP_SHARED 0x01 /* Share changes */ 2: #define MAP_PRIVATE 0x02 /* Changes are private */ 3: #define MAP_TYPE 0x0f /* Mask for type of mapping */ 4: #define MAP_FIXED 0x10 /* Interpret addr exactly */ 5: #define MAP_ANONYMOUS 0x20 /* don't use a file */ 6: #ifdef CONFIG_MMAP_ALLOW_UNINITIALIZED 7: # define MAP_UNINITIALIZED 0x4000000 /* For anonymous mmap, memory could be uninitialized */ 8: #else 9: # define MAP_UNINITIALIZED 0x0 /* Don't support this flag */ 10: #endif MAP_SHARED
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b378b491dc659d4fe24c7a595e43c74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55bb6e683118e8ec9dceaf306b64c382/" rel="bookmark">
			[JavaScript]Cookie详解(转)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cookie概述
假如利用一个不变的框架来存储购物栏数据，而商品显示页面是不断变化的，尽管这样能达到一个模拟全局变量的功能，但并不严谨。例如在导航框架页面内右击，单击快捷菜单中的【刷新】命令，则所有的JavaScript变量都会丢失。因此，要实现严格的跨页面全局变量，这种方式是不行的， JavaScript中的另一个机制：cookie，则可以达到真正全局变量的要求。
cookie 是浏览器提供的一种机制，它将document对象的cookie属性提供给JavaScript。可以由JavaScript对其进行控制，而并不是 JavaScript本身的性质。cookie是存于用户硬盘的一个文件，这个文件通常对应于一个域名，当浏览器再次访问这个域名时，便使这个 cookie可用。因此，cookie可以跨越一个域名下的多个网页，但不能跨越多个域名使用。
不同的浏览器对cookie的实现也不一样，但其性质是相同的。例如在Windows 2000以及Windows xp中，cookie文件存储于documents and settings\userName\cookie\文件夹下。通常的命名格式为：userName@domain.txt。
cookie机制将信息存储于用户硬盘，因此可以作为全局变量，这是它最大的一个优点。它可以用于以下几种场合。
1.保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个月、一年等。
2.跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便。
3.定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。
4.创建购物车。正如在前面的例子中使用cookie来记录用户需要购买的商品一样，在结账的时候可以统一提交。例如淘宝网就使用cookie记录了用户曾经浏览过的商品，方便随时进行比较。
当然，上述应用仅仅是cookie能完成的部分应用，还有更多的功能需要全局变量。cookie的缺点主要集中于安全性和隐私保护。主要包括以下几种：
1.cookie可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能；
2.cookie是与浏览器相关的。这意味着即使访问的是同一个页面，不同浏览器之间所保存的cookie也是不能互相访问的；
3.cookie可能被删除。因为每个cookie都是硬盘上的一个文件，因此很有可能被用户删除；
4.cookie安全性不够高。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。
设置cookie
每个cookie都是一个名/值对，可以把下面这样一个字符串赋值给document.cookie：
document.cookie=”userId=828″;
如果要一次存储多个名/值对，可以使用分号加空格（; ）隔开，例如：
document.cookie=”userId=828; userName=hulk”;
在cookie 的名或值中不能使用分号（;）、逗号（,）、等号（=）以及空格。在cookie的名中做到这点很容易，但要保存的值是不确定的。如何来存储这些值呢？方法是用escape()函数进行编码，它能将一些特殊符号使用十六进制表示，例如空格将会编码为“20%”，从而可以存储于cookie值中，而且使用此种方案还可以避免中文乱码的出现。例如：
document.cookie=”str=”+escape(”I love ajax”);
相当于：
document.cookie=”str=I%20love%20ajax”;
当使用escape()编码后，在取出值以后需要使用unescape()进行解码才能得到原来的cookie值，这在前面已经介绍过。
尽管document.cookie看上去就像一个属性，可以赋不同的值。但它和一般的属性不一样，改变它的赋值并不意味着丢失原来的值，例如连续执行下面两条语句：
document.cookie=”userId=828″;
document.cookie=”userName=hulk”;
这时浏览器将维护两个cookie，分别是userId和userName，因此给document.cookie赋值更像执行类似这样的语句：
document.addCookie(”userId=828″);
document.addCookie(”userName=hulk”);
事实上，浏览器就是按照这样的方式来设置cookie的，如果要改变一个cookie的值，只需重新赋值，例如：
document.cookie=”userId=929″;
这样就将名为userId的cookie值设置为了929。
获取cookie的值
下面介绍如何获取cookie的值。cookie的值可以由document.cookie直接获得：
var strCookie=document.cookie;
这将获得以分号隔开的多个名/值对所组成的字符串，这些名/值对包括了该域名下的所有cookie。
在实际开发中，cookie常常需要长期保存，例如保存用户登录的状态。这可以用下面的选项来实现：
document.cookie=”userId=828; expires=GMT_String”;
其中GMT_String是以GMT格式表示的时间字符串，这条语句就是将userId这个cookie设置为GMT_String表示的过期时间，超过这个时间，cookie将消失，不可访问。
删除cookie
为了删除一个cookie，可以将其过期时间设定为一个过去的时间．
指定可访问cookie的路径
默认情况下，如果在某个页面创建了一个cookie，那么该页面所在目录中的其他页面也可以访问该cookie。如果这个目录下还有子目录，则在子目录中也可以访问。例如在　www.xxxx.com/html/a.html　中所创建的cookie，可以被　www.xxxx.com/html/b.html　或　www.xxx.com/html/ some/c.html　所访问，但不能被　www.xxxx.com/d.html　访问。
为了控制cookie可以访问的目录，需要使用path参数设置cookie，语法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55bb6e683118e8ec9dceaf306b64c382/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b05685e78443f4e1bb9af75ac8100eab/" rel="bookmark">
			TKmybatis和mybatisplus哪个好用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档连接 ：http://baomidou.oschina.io/mybatis-plus-doc/#/?id=%E7%AE%80%E4%BB%8B
https://gitee.com/hengboy/mybatis-enhance
https://gitee.com/free/Mapper/wikis/1.3-spring-boot?sort_id=208198
https://durcframework.gitee.io/fastmybatis/
注： mybatis-enhance也同样可以跟相同namespace的mapper.xml自动合并
转载于:https://www.cnblogs.com/Jeremy2001/p/11123703.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/917ec123ee4ff7dec02a0a8530d52f51/" rel="bookmark">
			Linux性能监测：磁盘IO篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux性能监测：磁盘IO篇 计算机最慢的子系统，也是最容易出现性能瓶颈的地方，因为磁盘离 CPU 距离最远而且 CPU 访问磁盘要涉及到机械操作，比如转轴、寻轨等。访问硬盘和访问内存之间的速度差别是以数量级来计算的，就像1天和1分钟的差别一样。要监测 IO 性能，有必要了解一下基本原理和 Linux 是如何处理硬盘和内存之间的 IO 的。 AD： 磁盘通常是计算机最慢的子系统，也是最容易出现性能瓶颈的地方，因为磁盘离 CPU 距离最远而且 CPU 访问磁盘要涉及到机械操作，比如转轴、寻轨等。访问硬盘和访问内存之间的速度差别是以数量级来计算的，就像1天和1分钟的差别一样。要监测 IO 性能，有必要了解一下基本原理和 Linux 是如何处理硬盘和内存之间的 IO 的。
内存页 上一篇 Linux 性能监测：Memory 提到了内存和硬盘之间的 IO 是以页为单位来进行的，在 Linux 系统上1页的大小为 4K。可以用以下命令查看系统默认的页面大小：
$ /usr/bin/time -v date ... Page size (bytes): 4096 ... 缺页中断 Linux 利用虚拟内存极大的扩展了程序地址空间，使得原来物理内存不能容下的程序也可以通过内存和硬盘之间的不断交换（把暂时不用的内存页交换到硬盘，把需要的内存页从硬盘读到内存）来赢得更多的内存，看起来就像物理内存被扩大了一样。事实上这个过程对程序是完全透明的，程序完全不用理会自己哪一部分、什么时候被交换进内存，一切都有内核的虚拟内存管理来完成。当程序启动的时候，Linux 内核首先检查 CPU 的缓存和物理内存，如果数据已经在内存里就忽略，如果数据不在内存里就引起一个缺页中断（Page Fault），然后从硬盘读取缺页，并把缺页缓存到物理内存里。缺页中断可分为主缺页中断（Major Page Fault）和次缺页中断（Minor Page Fault），要从磁盘读取数据而产生的中断是主缺页中断；数据已经被读入内存并被缓存起来，从内存缓存区中而不是直接从硬盘中读取数据而产生的中断是次缺页中断。
上面的内存缓存区起到了预读硬盘的作用，内核先在物理内存里寻找缺页，没有的话产生次缺页中断从内存缓存里找，如果还没有发现的话就从硬盘读取。很显然，把多余的内存拿出来做成内存缓存区提高了访问速度，这里还有一个命中率的问题，运气好的话如果每次缺页都能从内存缓存区读取的话将会极大提高性能。要提高命中率的一个简单方法就是增大内存缓存区面积，缓存区越大预存的页面就越多，命中率也会越高。下面的 time 命令可以用来查看某程序第一次启动的时候产生了多少主缺页中断和次缺页中断：
$ /usr/bin/time -v date ... Major (requiring I/O) page faults: 1 Minor (reclaiming a frame) page faults: 260 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/917ec123ee4ff7dec02a0a8530d52f51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a990a04326d1b2cfeb5fcccfab70587e/" rel="bookmark">
			Using Ldp.exe to Find Data in the Active Directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Using Ldp.exe to Find Data in the Active Directory This article applies to Windows 2000. Support for Windows 2000 ends on July 13, 2010. The Windows 2000 End-of-Support Solution Center (http://support.microsoft.com/?scid=http%3a%2f%2fsupport.microsoft.com%2fwin2000) is a starting point for planning your migration strategy from Windows 2000. For more information see the Microsoft Support Lifecycle Policy (http://support.microsoft.com/lifecycle/) . NoticeThis article applies to Windows 2000. Support for Windows 2000 ends on July 13, 2010. The Windows 2000 End-of-Support Solution Center (http://support.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a990a04326d1b2cfeb5fcccfab70587e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e66a31970b04ac960e62f0970ec02787/" rel="bookmark">
			Ubuntu上架设PPPoE Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一。安裝 PPPoE Server Software 1)sudo apt-get install ppp 2)rp-pppoe(非apt套件) wget -c http://www.roaringpenguin.com/files/download/rp-pppoe-3.10.tar.gz sudo tar zxvf rp-pppoe-3.6.tar.gz -C /opt/ sudo chown -R root:root /opt/rp-pppoe-3.6/ 3) 安裝軟體開發函示庫： sudo apt-get install libc6-dev 4) 產生需要的pppoe server程式 sudo /opt/rp-pppoe-3.6/go 二。配置： allan @allan-desktop:~#sudo vim /etc/ppp/options ####### ms-dns 4.2.2.2 ms-dns 172.25.5.1 -pap +chap ....... ####### 具体的不详述，根据文件的描述加上自己的sense配就是。 三。添加用户： allan @allan-desktop:~#sudo vim /etc/ppp/chap-secrets ############################## # Secrets for authentication using CHAP # client server secret IP addresses ting * "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e66a31970b04ac960e62f0970ec02787/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6498ddb9d7bfae23da1969fb9a71d747/" rel="bookmark">
			PPPoE Server Under Ubuntu/Debian
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://imranasghar.blogspot.com/2009/05/pppoe-server-under-ubuntudebian.html
----------------------------
PPPoE Server Setup:
Operating System: Ubuntu Desktop(8.04)
1) Installation of Softwares:
Server Side
a) ppp
apt-get install ppp
b) pppoe
apt-get install pppoe
c) rp-pppoe (I used rp-pppoe-3.10.tar.gz)
RP PPPoE; can be obtained from,
http://www.roaringpenguin.com/products/pppoe
After download
Move it to some place e.g /var/tmp, unpack and change permission
root@pppoe:/var/tmp# mv /home/imran/Desktop/rp-pppoe-3.10.tar.gz /var/tmp/
root@pppoe:/var/tmp# tar -xvf rp-pppoe-3.10.tar.gz
root@pppoe:/var/tmp# chown imran:imran rp-pppoe-3.10
root@pppoe:/var/tmp# ls -l
total 220
drwxr-xr-x 8 imran imran 4096 2008-06-30 16:00 rp-pppoe-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6498ddb9d7bfae23da1969fb9a71d747/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa80a403a5ac597268345963c9faa8a0/" rel="bookmark">
			qrfcview (RFC reader in Linux)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sudo aptitude install qrfcview
转载于:https://www.cnblogs.com/kungfupanda/p/3270741.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e2b20ecf4b630f8cae6c2f212c8d560/" rel="bookmark">
			Configuring ISC DHCPv6 Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Configuring ISC DHCPv6 Server Contents [hide] 1 Preface 1.1 Stateless Configuration1.2 Stateful Configuration2 Installation 2.1 Softwaredownload2.2 Sampleconfigurations3 Serverconfiguration 3.1 Preconfigurationsteps3.2 Adding the Serverinterface to your Subnet 3.2.1 ifconfig3.2.2 ip3.3 The Expected IP Flow3.4 DHCP Server Configfiles (Create a Range) 3.4.1 stateful configuration4 Starting the Server 4.1 Manually4.2 Automatically with /etc/init.d/5 Lets Start the engine Preface This article should give you a short overview how to install a DHCPv6 Server and configure it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e2b20ecf4b630f8cae6c2f212c8d560/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df0236e3e085e26eef2d60a2e8d6c385/" rel="bookmark">
			信息学奥赛C&#43;&#43;语言：乘车费用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】
星期天上午小明乘出租车去本市的外婆家。出租车计价方案为：2公里以内起步价是6元，超过2公里之后按1.8元/公里计价，超过10公里之后在1.8元/公里的基础上加价50%，另外，停车等候则按时间计费：1元/3分（注：不满3分钟不计费）。已知：小明到外婆家路程为N公里，中间停车等候时间总共M分钟，请计算小明到外婆家的出租车费用是多少元?
【输入】
N M（N，M都是整数）。
【输出】
一个实数（表示车费，精确到0.1元）。
【输入样例】
8 7
【输出样例】
18.8
代码
#include&lt;cstdio&gt; using namespace std; int n,m,a; double t; int main() { scanf("%d%d",&amp;n,&amp;m); if(n&lt;=2) t=6; if(n&gt;2&amp;&amp;n&lt;=10) t=6+(n-2)*1.8; if(n&gt;10) t=6+(n-2)*1.8+n*0.9; a=m/3; t=t+a*1; printf("%.1lf",t); return 0; } #include&lt;iostream&gt; using namespace std; int n,m,a; double t; int main() { cin&gt;&gt;n&gt;&gt;m; if(n&lt;=2) t=6; if(n&gt;2&amp;&amp;n&lt;=10) t=6+(n-2)*1.8; if(n&gt;10) t=6+(n-2)*1.8+n*0.9; a=m/3; t=t+a*1; cout&lt;&lt;t; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbc11caa5bda99f77e6fb4dabd882e7d/" rel="bookmark">
			arguments
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		arguments是什么？
答 是一个对象，是一个长的很像数组的对象
arguments内容是什么？
答 arguments是函数运行时的实参列表 函数运行期间，关键的三个对象
AO--本函数AO上没有某属性，则继续去外层函数的AO上找，直到全局对象，也叫 作用域链
arguments--每个函数有自己的callee 但不向外层找arguments的相关属性，即不成链
this
1.作为普通函数来调用 window
2.作为对象的方法来调用 this.指向方法的调用者，即对象
3.函数作为构造函数时调用时
js中没有类的概念，创建对象是构造函数来完成，或者直接用json格式
Call apply调用
函数.call(对象，参数1，参数2)
解释
函数.call（对象，参数1，参数2、、、参数N）
运行如下
a:fn函数中的this -- 指向--》对象 abj
b:运行fn（参数1，参数2，参数N）
总结
当一个函数运行的时候，函数内部能映起的变量有这么集中
AO---作用域链是指AO链
arguments this
对于arguments 和this 每个函数都有自己独特的arguments和this，切不进行链查询。
转载于:https://www.cnblogs.com/DJYBlog/p/4233891.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b86f6a91b90061293bcd1680dcd090a7/" rel="bookmark">
			网页中上传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于SpringMVC的文件上传(Upload：上载) 目标 在页面中点击浏览按钮，可以将指定的文件上传到服务器。
创建项目 创建Maven Project，Group Id为cn.tedu.spring，Artifact Id为SPRINGMVC-UPLOAD，Packaging为war，创建好项目后，生成web.xml文件，添加spring-webmvc依赖，添加Tomcat运行环境(必须保证Eclipse中的Servers项目是打开的)，复制spring的配置文件，删除所有已经存在的配置，复制前序项目中web.xml中的配置。
另外，为了实现文件上传，还需要添加依赖：
&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; 页面 在webapp下创建index.html页面，并在页面中设计：
&lt;form method="post" enctype="multipart/form-data" action=""&gt; &lt;p&gt;请选择要上传的文件：&lt;/p&gt; &lt;p&gt;&lt;input type="file" name="file" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="上传" /&gt;&lt;/p&gt; &lt;/form&gt; 以上代码中，&lt;form&gt;的method属性值必须是post，enctype属性值必须是multipart/form-data，且上传控件的type属性值必须是file。
使用控制器接收请求 确定页面中表单的action属性的值为upload.do。
检查spring.xml中配置的组件扫描为cn.tedu.spring。
创建cn.tedu.spring.UploadController控制器类，并在类之前添加@Controller注解，然后，添加处理请求的方法：
@Controller public class UploadController { @RequestMapping("upload.do") @ResponseBody public String upload() { System.out.println("UploadController.upload()"); return "OK"; } } 处理上传 在SpringMVC框架中，使用了CommonsMultipartResolver对上传的数据进行处理，需要在spring.xml中配置该类：
&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;/bean&gt; 在配置时，必须指定id，且值必须是multipartResolver。
关于以上节点，可以暂不配置详细信息。
然后，在处理请求的方法中，添加MultipartFile file参数，该参数就是用户上传的文件的数据，并在参数之前添加@RequestParam注解。
最后，调用参数对象的void transferTo(File dest)方法即可将用户上传的文件保存到服务器的硬盘中！
@RequestMapping("upload.do") @ResponseBody public String upload( @RequestParam("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b86f6a91b90061293bcd1680dcd090a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74cf115d7a4b885b5204bea6d44b92cf/" rel="bookmark">
			c&#43;&#43;Primer Plus学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++ Primer Plus笔记　方便自己下载 转载于:https://www.cnblogs.com/nniixl/archive/2007/03/24/685958.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/062e0f30e074252b9f5669f394bcedec/" rel="bookmark">
			20060518: Alert!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Alert Received, Shrink My Blog! 转载于:https://www.cnblogs.com/yidinghe/archive/2006/05/18/403089.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3503eaa738cc346c298f083baed1d0a/" rel="bookmark">
			FTP 读取文件后，所在文件夹为空的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现业务流程是，读取FTP某目录下面的文件，读取完毕后把文件移到另外一个目录下。
//列出目录下所有的文件
FTPFile[] fs = ftpClient.listFiles();
for (FTPFile ftpFile : fs) {
//遍历循环该文件夹下的文件
remoteAbsoluteFile = ftpFile.getName();
//获取远程文件的输入流
ins = ftpClient.retrieveFileStream(remoteAbsoluteFile);
//读取文件
read = new BufferedReader(new InputStreamReader(ins));
String lineTxt = null;
while ((lineTxt = read.readLine()) != null) {
list.add(lineTxt);
//System.out.println(lineTxt);
}
//这一行格外的重要，是告诉 FTP 传输完毕，这样过后，可以继续跳转其他路径
ftpClient.completePendingCommand();
uploadFile(ftpClient, “test”,remoteAbsoluteFile, ins);
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ea7d419a4caeb912e745b3ceaa518e7/" rel="bookmark">
			[RQNOJ]PID1-明明的随机数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.rqnoj.cn/problem/1
1 #include &lt;stdio.h&gt; 2 #include &lt;stdlib.h&gt; 3 4 /*用法：void qsort(void *base,int nelem,int width,int (*fcmp)(const void *,const void *)); 5 *参数： 6 *-----&gt;1 待排序数组首地址。 7 *-----&gt;2 数组中待排序元素数量。 8 *-----&gt;3 各元素的占用空间大小。 9 *------&gt;4 指向函数的指针，用于确定排序的顺序。*/ 10 int comp(const void *a,const void *b);/*升序*/ 11 12 /* 13 *函数功能：数组去重 14 *参数： 15 *-----&gt;1 待排序数组首地址。 16 *-----&gt;2 数组中待排序元素数量。*/ 17 int PID1_duplicateRemoval(int *data,int n); 18 19 /* 20 *函数功能：数组初始化 21 *参数： 22 *-----&gt;1 待排序数组首地址。 23 *-----&gt;2 数组中待排序元素数量。*/ 24 void PID1_initialization(int *data,int n); 25 26 /* 27 *函数功能：结果输出 28 *参数： 29 *-----&gt;1 待排序数组首地址。 30 *-----&gt;2 数组中待排序元素数量。*/ 31 void PID1_output(int *data,int n); 32 33 int main(){ 34 int i; 35 int n,data[100]; 36 while(scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ea7d419a4caeb912e745b3ceaa518e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d5b6b624774ae4ac80bec56d3830d0b/" rel="bookmark">
			Unity LWRP/HDRP使用体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先给大家展示一下(本人非专业美术，效果不好请见谅）
左图：虚幻4.20-照片级渲染官方案例（渲染后）
右图：Unity2018.3HDRP笔者从虚幻中导出（未渲染，仅平行光）
随着2019版本到来，2018版本也逐渐稳定，笔者最近尝试了下最新的LWRP/HDRP(5.16.1)。下面是一些分享；
LWRP 比较不错的低配适配方案，一些旧的材质也能够很快替换。
个人感受：需要进行一些使用，Shader Graph目前来说还是有些操作不便（相比较而言还是比Shader Forge和Amplify Shader插件有一些差距），操作比不是特别流畅，默认快捷键太少，还需要改进。不过相比起2018年的bug过多，2019年已经可以商用了，修正许多bug。
学习成本：UE4/Shader forge/Amplify shader 老手：0.5~2天基本可以完全掌握
新手：需要知道一些图形、材质基础知识：2~3天基本可以掌握
项目：可以使用。
HDRP 这个效果确实有了很大的提高，一些基本材质效果也很逼真
个人感受：需要使用者进行试验以及研究一下，毕竟跟之前的材质系统有较大改变。总体效果不错。
注意：安装时一定要注意所需其他插件版本，不然无法使用HDRP
HDRP使用后场景天空盒变黑，此时在Herachy面板中，右键，Rendering，Scene Settings，并修改天空盒参数即可（Skybox的设置不在Lighting面板中，整合到Scene Settings设置）
左：刚切换HDRP时，右：创建SceneSettings后
学习成本：UE4/Shader forge/Amplify shader 老手：1~2天基本可以完全掌握
新手：需要知道一些图形、材质基础知识：2~5天基本可以掌握
项目：虽然可以使用，需要计算学习成本，美工在一周至两周左右熟悉新版材质、灯光、阴影、反射、后处理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3624eed815961581fd36c4044e09a4da/" rel="bookmark">
			AudioManager 蓝牙sco连接相关接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做APP的蓝牙相关功能，想记录一下蓝牙的有关知识。俗话说的好呀，“好记忆，不如烂笔头”，关键我好像记性还不太好，哈哈哈~~
蓝牙耳机连接之后，发现音频发声的还是终端，并没有转换到蓝牙耳机发声。网上搜索相关资料，发现是蓝牙耳机需要建立链路来播放音频。
简单介绍下蓝牙耳机的两种链路：A2DP（异步链路）及SCO（同步链路）。A2DP是一种单向的高品质音频数据传输链路，通常用于播放立体声音乐；而SCO则是一种双向的音频数据的传输链路，该链路只支持8K及16K单声道的音频数据，只能用于普通语音的传输。我试过建立SCO连接后播放音乐效果一般。SCO主要用来传输对时间要求很高的数据通信，可以录音也能播放。A2DP只能播放。我做的app是关于语音对讲的，设置SCO就可以了。
设置SCO的相关AudioManager接口 1.AudioManager简介 AudioManager 音频管理器，该类位于Android.Media包下。提供了音量控制与铃声模式相关操作。
//获得AudioManager对象实例
AudioManager am = (AudioManager)context.getSystemService(Context.AUDIO_SERVICE); 2.具体接口 当蓝牙耳机连接后，将音频从终端转换到蓝牙耳机。蓝牙耳机断开后，将音频从蓝牙耳机转换到终端。
2.1打开SCO
/** * 进入SCO模式 */ public void enterScoMode(){ if(isBTConnected()){ //确保蓝牙连接 AudioManager mAudioManager = (AudioManager)getSystemService(Context.AUDIO_SERVICE); mAudioManager.startBluetoothSco(); //打开SCO； mAudioManager.setBluetoothScoOn(true); //蓝牙录音的关键，启动SCO连接，耳机话筒才起作用； setAudioMode(AudioManager.MODE_IN_COMMUNICATION);//将音频模式设为AudioManager.MODE_IN_COMMUNICATION，SCO才会真正生效。 } } 2.2关闭SCO
/** * 关闭SCO */ public void exitSCOMode(){ AudioManager mAudioManager = (AudioManager)getSystemService(Context.AUDIO_SERVICE); mAudioManager.setBluetoothScoOn(false); mAudioManager.stopBluetoothScoOn(); mAudioManager.setAudioMode(AudioManager.MODE_NORMAL ); } 2.3判断通信是否使用蓝牙sco
isBluetoothScoOn() 2.4判断蓝牙耳机是否连接
public void isBTConncected(BluetoothHeadset mBluetoothHeadset){ boolean bt = false; if(mBluetoothHeadset != null){ List&lt;BluetoothDevice&gt; devices = mBluetoothHeadset.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3624eed815961581fd36c4044e09a4da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df3293f19d6cd02781fe7e4d439f9c8/" rel="bookmark">
			Cytoscape——实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将具体操作怎样用Cytoscape绘制网络图
Cytoscape所支持的数据格式：
1.*.sif格式：
nodeA&lt;interaction&gt;nodeB
nodeC&lt;interaction&gt;nodeD
…
即文件分为三列，第一列和第三列是有相互作用关系的基因名或蛋白质名等，第二列是相互作用的名称
*.sif格式简单，容易处理，但它不能规定每个节点的位置、大小、形状等。
2. xgmml格式，它是一种xml格式，可以规定节点和边的许多信息，但也更复杂。
3.*.txt格式：用tab分割的纯文本文件
可以将文件设置成两列，每一列都是基因名（或蛋白质名），同一行的两个基因（或者蛋白质等）代表有互作关系；也可以加其他参数放在第三列，例如两基因调控的强弱系数
本文以txt格式的数据进行演示绘制网络图
网络文件：net.txt：共表达网络；共四列，前两列是gene id，第三列是共表达类别（正1/负-1），第四列是相关系数，以tab键分隔
节点属性文件： 步骤：
导入网络文件：file-&gt;import-&gt;network-&gt;file(net.txt)
其中不同标识代表着不同的含义
导入后
导入节点属性文件：file-&gt;import-&gt;table-&gt;file(node.txt)(此处为table而非network)
注：node.txt：节点属性文件。四列，包含三种属性；第一列为gene id，与网络文件中一致，第二列为gene name（symbol），第三列为分子类型（蛋白编码基因/lncRNA），第四列为节点在网络中的度。
上方红色方框中“Target Table Data”的信息表示将导入的节点属性表与之前的网络图相关联，其中“Network Collection”选择的是我们之前导入的网络文件，其他参数默认如下，可不用修改，如为其他选项，则需要通络下拉列表重新选择。
下方红色方框中“Preview”中：gene，name，molecular type，degree
第一列gene，设置为“Key”，保证gene id不重复，第二三四列均为属性“Attribute”，如需修改，同样点击名称右侧的三角形标志。
点击确定后，乍看感觉图形没有变化，但此时下方的Table Panel中已自动多出了molecular type，degree两列
可以通过style中进行简单网络图格式设置
得到网络图：
也可以自行拖拽进行微调
导出文件：数据的导出可以是网络文件，表格文件或者是图片文件，图片文件包括多种图片格式以及pdf格式，在工具栏中对应选择即可
点击菜单栏的图片导出*.pdf（同样可以采用export导出其它格式）
注：注意调整网络图后再保存，否则会出现网络图不完整
转载于:https://www.cnblogs.com/wangshicheng/p/11120719.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bd7cbbbd6ddea5e04742b53f53d2b60/" rel="bookmark">
			anaconda安装jieba（被折腾了很久）终于搞定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天打算在anaconda下安装jieba，总感觉直接pip install jieba可以轻松搞定，最后发现too young to simple。
我首先使用pip install jieba或者conda install jieba（或者一些类似的变种方法）等方法安装都成功安装了0.39版本，在anaconda prompt下import jieba也能成功，不会报错，但在jupyter notebook测试报错，在pycharm下import jieba也是报错。
最后解决方法如下：
1、从官网下载jieba压缩包（超级慢，稳住我们能赢。）
https://pypi.org/project/jieba/#files
2、将压缩包解压到anaconda的pkgs目录。
3、打开anaconda prompt,切换目录至比如我的D:/anaconda/pkgs/jieba-0.39
然后执行python setup.py install即可。
4、再次打开jupyter notebook 测试import jieba，正常
pycharm中 import jieba ，正常。
参考：
https://blog.csdn.net/zhaohaibo_/article/details/79253740
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3b3f0dafa92bcbde7f896c4d6616a35/" rel="bookmark">
			关于SETUP FACTORY %AppFolder%写入注册表问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于SETUP FACTORY %AppFolder%写入注册表问题
关于SETUP FACTORY %AppFolder%写入注册表问题 在SETUP FACTORY 6版本修改注册表，Registry.SetValue(HKEY_LOCAL_MACHINE, “Software\ODBC\ODBC.INI\my”, “Start”, “%AppFolder%\dbeng7 -d -Q -c512”, REG_SZ);注册表Software\ODBC\ODBC.INI\my\Star对应的值 ：安装目录（绝对路径）\ dbeng7 -d -Q -c512 。但是在SETUP FACTORY 7 以及更高版本,就不行了
解决办法 Registry.SetValue(HKEY_LOCAL_MACHINE, “Software\ODBC\ODBC.INI\my”, “Start”, SessionVar.Expand("%AppFolder%\dbeng7 -d -Q -c512"), REG_SZ);这样就可以了
SessionVar.Expand()会把%AppFolder%展开为绝对路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c3bfdcfc1a8f949284a51943b2b2252/" rel="bookmark">
			tensorflow.python.framework.errors_impl.InvalidArgumentError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tensorflow.python.framework.errors_impl.InvalidArgumentError: Input to reshape is a tensor with 695726080 values, but the requested shape has 21741440
在使用keras构建网络时，出现上述错误，原因是，在自定义层的compute_output_shape函数里，output_shape计算错误，导致实际输出和给定的输出shape不一致而报错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09fe8749dede78dd9ac8e5079759f733/" rel="bookmark">
			windows 下搭建 Jmeter  &#43; InfluxDB &#43; Grafana 测试性能监控平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/smooth00/article/details/79926294 【综合】
https://www.cnblogs.com/yyhh/p/5990228.html 【综合】
https://blog.csdn.net/qq_41059320/article/details/84231476 【InfluxDB】
https://blog.csdn.net/zuozewei/article/details/82911173 【Grafana】
目录
概述
引言
解决方案
1. 安装InfluxDB
1.1、InfluxDB简介
1.2、Windows 下的 InfluxDB 安装和运行
1.2.1、解压后修改配置文件 influxdb.conf 1.2.2、命令行启动
1.2.3、influxdb 连接测试
2、配置 jmeter
2.1、添加线程组
2.2、添加一个Java请求
2.3、添加结果树，方便查看结果
2.4、添加 “Backend Listener”
2.5、运行测试
3、安装 Grafana
3.1、安装并运行
3.2、配置数据源
3.3、配置图表
3.3.1、自定义图表
3.3.2、导入图表（Dashboard）模板
概述 本文我们将介绍如何使用 jmeter + InfluxDB + Grafana 打造压测可视化实时监控。
本文各软件版本：jmeter-5.1 ； InfluxDB-1.7.6-1 ； Grafana-6.2.5
引言 我们很多时候在使用JMeter做性能测试，我们很难及时察看压测过程中应用的性能状况，总是需要等到测试完成后去看Report，如果是长时间压测，比如压测1~2天，那就更烦人了。
解决方案 JMeter 3.2 开始 Backend Listener 中引入的 InfluxDBBackendListenerClient 允使用UDP或HTTP协议将统计指标发送到InfluxDB。通过配置 Grafana (开源的WEB可视化看板)数据源连接到 Influxdb，我们就可以创建炫酷的可视化看板，并可以实时获取到测试指标数据。
1. 安装InfluxDB 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09fe8749dede78dd9ac8e5079759f733/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e4b125c4fda1d9d359b09be877bc6f/" rel="bookmark">
			解决Spring Boot和Feign中使用Java 8时间日期API（LocalDate等）的序列化问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LocalDate 、 LocalTime 、 LocalDateTime 是Java 8开始提供的时间日期API，主要用来优化Java 8以前对于时间日期的处理操作。然而，我们在使用Spring Boot或使用Spring Cloud Feign的时候，往往会发现使用请求参数或返回结果中有 LocalDate 、 LocalTime 、 LocalDateTime 的时候会发生各种问题。本文我们就来说说这种情况下出现的问题，以及如何解决。
问题现象 先来看看症状。比如下面的例子：
@SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } @RestController class HelloController { @PostMapping("/user") public UserDto user(@RequestBody UserDto userDto) throws Exception { return userDto; } } @Data @NoArgsConstructor @AllArgsConstructor static class UserDto { private String userName; private LocalDate birthday; } } 上面的代码构建了一个简单的Spring Boot Web应用，它提供了一个提交用户信息的接口，用户信息中包含了 LocalDate 类型的数据。此时，如果我们使用Feign来调用这个接口的时候，会得到如下错误：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2e4b125c4fda1d9d359b09be877bc6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b0ab82a0b7fd75c2dfd9bcd112eea37/" rel="bookmark">
			java8 .stream().map().collect()用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		API: https://www.runoob.com/java/java8-streams.html
mylist.stream() .map(myfunction-&gt;{ return item; }).collect(Collectors.toList()); 说明：
steam():把一个源数据，可以是集合，数组，I/O channel， 产生器generator 等，转化成流。
forEach():迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数.
Random random = new Random(); random.ints().limit(10).forEach(System.out::println); map():用于映射每个元素到对应的结果。以下代码片段使用 map 输出了元素对应的平方数：
List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); // 获取对应的平方数 List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList()); filter():filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：
List&lt;String&gt;strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl"); // 获取空字符串的数量 int count = strings.stream().filter(string -&gt; string.isEmpty()).count(); limit limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据： Random random = new Random(); random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b0ab82a0b7fd75c2dfd9bcd112eea37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/575a84ec3de03cae390bebd9d0dc5e7a/" rel="bookmark">
			CMOS Parallel Sensor 一些基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMOS Parallel Sensor 一些基础知识
1S秒 = 1000 ms毫秒 = 1000_1000 us微妙 = 1000_000_000 ns纳秒
1GHz = 1000 MHz = 1000_000 KHz = 1000_000_000 Hz
2592(H) x 1944(V)
曝光时间以行长为单位； PCLK以Hz为单位；
行长以周期数为单位，帧长以行长数为单位；其中周期数就是频率
T 周期以ms为单位；f 频率以Hz为单位；f = 1 / T；周期和频率都是时间单位，只是表现形式不同
Hsync = Dummy Pixel = HTotal = HTS = H_Size + H_Blank // 行长; 会增加曝光时间，会影响帧率（FPS）
Vsync = Dummy Line = VTotal = VTS = V_Size + V_Blank // 帧长; 不占用曝光时间，但是会影响帧率（FPS）
FPS = PCLK / （VTS * HTS ）// 计算FPS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/575a84ec3de03cae390bebd9d0dc5e7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/268400c18c895e6fb8f7ef8bb49b83d0/" rel="bookmark">
			ArcEngine的ToolbarControl解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ToolbarControlClass有三个主要的接口: IToolbarControl, IToolbarControl2, IToolbarControlDefault　其中,IToolbarControl2是IToolbarControl的新版本.而IToolbarControlDefault is a 'pure' dispatch interface,始终是IToolbarControl的最新的版本,也就是如果有 了IToolbarControl3,那么IToolbarControlDefault就是IToolbarControl3.
在IToolbarControlDefault中有三个Members可以向ToolbarControl添加项:
AddItem():向ToolbarControl添加一个item,支持实现了 ICommand, IMenuDef, IToolbarMenu, ITool, IToolControl, IPaletteDef and IToolbarPalette的类. AddMenuItem():向ToolbarControl添加一个menu item,是AddItem的一个简略(剪切)版,支持实现了 IMenuDef,IToolbarMenu的类
AddToolbarDef():向 ToolbarControl添加定制的工具item.
下面以AddItem 为例:
第一个参数是object类型,基本可以是这:UID,ProgID,接口(ICommand,IToolBarDef ...),例如
//Adding a command by UID
UID uID = new UIDClass();
uID.Value = "esriControls.ControlsMapFullExtentCommand";
axToolbarControl1.AddItem(uID,-1,-1,false,0,esriCommandStyles.esriCommandStyleIconOnly);
//Adding a command by ProgID
string progID = "esriControls.ControlsMapFullExtentCommand";
axToolbarControl1.AddItem(progID,-1,-1,false,0,esriCommandStyles.esriCommandStyleIconOnly);
//Adding a command by ICommand
ICommand command = new ControlsMapFullExtentCommandClass();
axToolbarControl1.AddItem(command,-1,-1,false,0,esriCommandStyles.esriCommandStyleIconOnly); ToolbarControl内部有一个CommandPool,用来存放管理Command.当向ToolbarControl中添加一项的时候,AddItem检查CommandPool中是否已经存在该Command.如果没有,这个Command被created,并被加入CommandPool,这个Command的使用计数被置为1.如果这个Command已经存在,它将被重用,使用计数加1.
注意ESRI.ArcGIS.Controls内置的Controls. 像ControlsMapZoomInFixedCommandClass这种以CommandClass结尾的一般是实现了ICommand接口. 这个Command会持久地与MapControl交互就需要ITool接口,像ControlsMapZoomInToolClass这种以ToolClass结尾的都是实现了ITool的类.ControlsFeatureSelectionToolbarClass这种实现了IToolBarDef接口的. 实现了不同接口的类在使用时也有所不同:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/268400c18c895e6fb8f7ef8bb49b83d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57740a37448f94c711562a399908f903/" rel="bookmark">
			ajax提交 的编码小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天用ajax的post方法提交数据给webservice,由于有email的缘故发现,注册方法调用总是报错,打开报文一看提交的 发现@符号被变成了%40 , abc@126.com 即abc%40126.com.开始我还以为他没有编码.后来百度搜索发现. 他默认是进过urlencode编码.
为什么PHP接收到的$_POST数据里的邮箱符号@变成了%40 好像因为表单提交过来的数据会进行urlencode,你可以在php后台用urldecode看看，是否一致
后来在发布端用httpUnility.Decode()解码成功解决了.
Server.UrlEncode、HttpUtility.UrlDecode的区别 在对URL进行编码时，该用哪一个？这两都使用上有什么区别吗？ 测试： string file="文件上（传）篇.doc"; string Server_UrlEncode=Server.UrlEncode(file); string Server_UrlDecode=Server.UrlDecode(Server_UrlEncode); string HttpUtility_UrlEncode=System.Web.HttpUtility.UrlEncode(file); string HttpUtility_UrlDecode=System.Web.HttpUtility.UrlDecode(HttpUtility_UrlEncode); Response.Write("原数据："+file); SFun.WriteLine("Server.UrlEncode："+Server_UrlEncode); SFun.WriteLine("Server.UrlDecode："+Server_UrlDecode); SFun.WriteLine("HttpUtility.UrlEncode："+HttpUtility_UrlEncode); SFun.WriteLine("HttpUtility.UrlDecode："+HttpUtility_UrlDecode); 输出： 原数据：文件上（传）篇.doc Server.UrlEncode：%ce%c4%bc%fe%c9%cf%a3%a8%b4%ab%a3%a9%c6%aa.doc Server.UrlDecode：文件上（传）篇.doc HttpUtility.UrlEncode：%e6%96%87%e4%bb%b6%e4%b8%8a%ef%bc%88%e4%bc%a0%ef%bc%89%e7%af%87.doc HttpUtility.UrlDecode：文件上（传）篇.doc 区别在于： HttpUtility.UrlEncode()默认是以UTF8对URL进行编码，而Server.UrlEncode()则以默认的编码对URL进行编码。 在用 ASP.Net 开发页面的时候, 我们常常通过 System.Web.HttpUtility.UrlEncode 和 UrlDecode 在页面间通过 URL 传递参数. 成对的使用 Encode 和 Decode 是没有问题的. 但是, 我们在编写文件下载的页面的时候, 常常用如下方法来指定下载的文件的名称: Response.AddHeader("Content-Disposition","attachment; filename=" + HttpUtility.UrlEncode(fileName, Encoding.UTF8)); 之所以转换成 UTF8 是为了支持中文文件名. 这 时候问题就来了, 因为 HttpUtility.UrlEncode 在 Encode 的时候, 将空格转换成加号('+'), 在 Decode 的时候将加号转为空格, 但是浏览器是不能理解加号为空格的, 所以如果文件名包含了空格, 在浏览器下载得到的文件, 空格就变成了加号.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57740a37448f94c711562a399908f903/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/192a7e3b80872ea0bf7ac8ffdf68d159/" rel="bookmark">
			WinDbg内核调试常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看所有驱动和设备名 lm !object \ 查看根目录 !object \device 查看所有设备名 dt _DEVICE_OBJECT XXXX 查看设备对象内容 !devobj XXXX 查看设备对象内容 !object \Driver 查看所有驱动名 dt _DRIVER_OBJECT XXXX 查看驱动对象内容 !drvobj XXXX 查看设备对象内容 !devnode 显示PnpManger 创建的第一个PDO !devnode XXXX 显示设备对象 转载于:https://www.cnblogs.com/fanzi2009/archive/2009/05/07/1452212.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a76593a33ca9cf90599a57e0e331ef5/" rel="bookmark">
			Test and Set
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BTS 指令，一般用在自旋锁上或者类似概念。自旋锁核心操作就是InterlockedBitTestAndSet。
InterlockedBitTestAndSet有两种实现：
1. ReactOS方法
static __inline__ BOOLEAN InterlockedBitTestAndSet(IN LONG volatile *Base, IN LONG Bit) { LONG OldBit; __asm__ __volatile__("lock " // 总线加锁 "btsl %2,%1/n/t" "sbbl %0,%0/n/t" :"=r" (OldBit),"=m" (*Base) :"Ir" (Bit) : "memory"); return OldBit; } 2. Windows方法
BOOLEAN bRet = InterlockedBitTestAndSet(&amp;num,3); 0042F9D5 lea eax,[num] 0042F9D8 lock bts dword ptr [eax],3 0042F9DD setb cl 0042F9E0 mov byte ptr [bRet],cl 转载于:https://www.cnblogs.com/fanzi2009/archive/2012/04/12/2444279.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a1af53e523c98c10f1548a5f0084930/" rel="bookmark">
			operater int()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class Number { int number; public: explicit Number(int n){number = n;} operator int() //注意一定不能声明返回值 { return number; } }; int main () { Number n1 = Number(100); int n2= n1; cout &lt;&lt; n2 &lt;&lt; endl; return 0; }
转载于:https://www.cnblogs.com/fanzi2009/archive/2011/11/10/2244339.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/402/">«</a>
	<span class="pagination__item pagination__item--current">403/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/404/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>