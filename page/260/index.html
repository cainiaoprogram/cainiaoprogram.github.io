<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09af3919ed8b96ae8490f64c8ffc2d4f/" rel="bookmark">
			Go strings.HasPrefix函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
描述
语法
参数
返回值
使用示例
源码分析
描述 strings.HasPrefix函数用来检测字符串是否以指定的前缀开头。
语法 需要导入 strings包
strings.Hasprefix(s, prefix) 参数 参数说明备注s待检测的字符串字符串类型的参数prefix指定的前缀 字符串类型的参数
返回值 返回一个布尔值。如果字符串s是以prefix开头，则返回true，否则返回false。
使用示例 package main import ( "fmt" "strings" ) func main() { flavor := "hw:numa_notes" if strings.HasPrefix(flavor, "hw") { fmt.Println("It's a 'hw' flavor.") } else { fmt.Println("Unknown flavor.") } } 运行结果
It's a 'hw' flavor. 源码分析 下面是go 1.12 HasPrefix()函数的源码。
可以看出当s长度小于prefix时，HasPrefix返回False。
当s长度不小于prefix时，且s在区间[0, len(prefix))上的子字符串等于prefix，HasPrefix()返回True。
// HasPrefix tests whether the string s begins with prefix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09af3919ed8b96ae8490f64c8ffc2d4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70a2c2f2502633b0cd3f9260086fb027/" rel="bookmark">
			（软件工程复习核心重点）第十二章软件项目管理-第二节：进度计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一：相关概念（1）任务集合（2）项目管理者的工作A：目标B：方法 （3）进度安排A：定义B：流程 二：估算开发时间（1）利用成本估算模型估算开发时间（2）特殊情况A：描述B：原因 （3）项目组规模与项目组总生产率的关系A：通信路径B：平均生产力C：总生产率 三：甘特图(Gantt)（1）例子（2）甘特图的优缺点 四：工程网络（1）定义（2）表示 五：估算工程进度（1）完善工程网络（2）最早时刻EET（3）最迟时刻LET 六：关键路径（1）定义（2）特点 七：机动时间（1）定义（2）计算（3）表示 一：相关概念 （1）任务集合 一个有效的软件过程应该定义一个适用于当前项目的任务集合。一个任务集合包括一组软件工程工作任务、里程碑和可交付的产品。为一个项目所定义的任务集合，必须包括为获得高质量的软件产品而应该完成的所有任务，但是同时又不能让项目组承担不必要的工作
（2）项目管理者的工作 A：目标 定义全部项目任务，识别出关键任务，跟踪关键任务的进展状况，保证及时发现拖延进度的情况
B：方法 管理者必须制定一个足够详细的进度表，以便监督项目进度并控制整个项目
（3）进度安排 A：定义 软件项目的进度安排通过把工作量分配给特定的软件工程任务并规定完成各项任务的起止日期，从而将估算出的项目工作量分布于计划好的项目持续期内。进度计划将随着时间的流逝而不断演化
B：流程 在项目计划的早期，制定一个宏观的进度安排表，标识出主要的软件工程活动和这些活动影响到的产品功能随着项目的进展，把宏观进度表中的每个条目都精化成一个详细进度表，标识出完成一个活动所必须实现的一组特定任务，并安排好实现这些任务的进度 二：估算开发时间 （1）利用成本估算模型估算开发时间 Walston_Feilix模型： T = 2.5 E 0.35 T=2.5E^{0.35} T=2.5E0.35原始的COCOMO模型： T = 2.5 E 0.38 T=2.5E^{0.38} T=2.5E0.38COCOMO2模型： T = 3.0 E 0.33 + 0.2 × ( b − 1.01 ) T=3.0E^{0.33+0.2×(b-1.01)} T=3.0E0.33+0.2×(b−1.01)Putnam模型： T = 2.4 E 1 3 T=2.4E^{\frac{1}{3}} T=2.4E31​ 其中E是以人月为单位的开发工作量，T是以月为单位的开发时间
（2）特殊情况 A：描述 随着开发小组规模的扩大，个人生产率将下降，以致开发时间与从事开发工作的人数并不成反比关系
B：原因 小组变得更大时，每个人需要用更多时间与组内其他成员讨论问题、协调工作，因此增加了通信开销如果在开发过程中增加小组人员，最初一段时间内项目组总生产率不仅不会提高反而会下降。因为新成员在开始时不是生产力，且在他们学习期间需花费小组其他成员的时间Brooks规律：向一个已经延期的项目增加人力，只会使得它更加延期 （3）项目组规模与项目组总生产率的关系 A：通信路径 项目组成员之间的通信路径数，由项目组人数和项目组结构决定。通信路径数大约在 P P P~ P 2 2 \frac{P^{2}}{2} 2P2​的范围内变化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70a2c2f2502633b0cd3f9260086fb027/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a0f680d386c8cfda31cb92d2ec6b50/" rel="bookmark">
			ubuntu pycharm虚拟环境报错Failed to create virtual environment
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述： 在ubuntu pycharm中添加虚拟环境时遇到
Failed to create virtual environment
的报错信息
解决方案： 重新安装下pip即可解决
sudo apt install pip 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e5b0167c7054c3ad487fdd47753ba32/" rel="bookmark">
			使用ConfigurationProperties提示错误解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 提示错误为未配置SpringBoot配置注解处理器解决方法 解决方案:在pom.xml中添加一个依赖，然后重启Idea即可 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79c6924b9b03edf5e383940e98a40839/" rel="bookmark">
			【SuperSocket 2.0】SuperSocket 2.0从入门到懵逼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SuperSocket 2.0从入门到懵逼 SuperSocket 2.0从入门到懵逼 1 使用SuperSocket 2.0在AspNetCore项目中搭建一个Socket服务器 1.1 引入SuperSocket 2.01.2 在AspNetCore中搭建一个Socket服务器 2 基本的协议概念 2.1 基本协议种类 2.1.1 固定头格式协议2.1.2 固定头尾标识协议2.1.3 固定包大小协议2.1.4 命令行协议2.1.5 一些其它协议PS: 关于协议的一些硬件厂商的私有协议比较奇葩, 他们的协议五花八门的…不过我们这里不做阐述, 有时间我会再讲 3 SuperSocket中的几个基本概念 3.1 Package Type3.2 PipelineFilter Type3.3 使用PackageType和PipelineFilter Type创建SuperSocket 4 SuperSocket中的PipelineFilter, 实现自己的PipelineFilter 4.1 内置的PipelineFilter模板4.2 基于内置模板实现PipelineFilter 4.2.1 FixedHeaderPipelineFilter-头部格式固定并且包含内容长度的协议 4.2.3 另一种挂载解析器的方式 7 扩展AppSession和SuperSocketService 7.1 扩展AppSession 7.2 如何自己实现SuperSocketService?8 扩展SuperSocket的功能 8.1 多协议切换 9 搭建WebSocket服务器 9.1 番外: WebSocket传参 10 多服务器以及不同服务间的协同More 1 协议的编解码器开发预览More 2 DotNetty 附带实现, 讲解, 与部分源代码解读
1 使用SuperSocket 2.0在AspNetCore项目中搭建一个Socket服务器 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79c6924b9b03edf5e383940e98a40839/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec0de17bfdb9fd3043ad8af5a5683feb/" rel="bookmark">
			mysql-installer安装教程（详细图文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.安装
2.配置系统环境变量
3.配置初始化my.ini文件
4.MySQL彻底删除
5.Navicat 安装
1.安装 先去官网下载需要的msi，在这放出官网下载地址下载地址
这里我具体以8.0.28 为安装例子，除了最新版安装界面有些变动以往的都是差不多的。
过去的版本在这里
打开8.0.28的下载页面，点击图片进入到8.0.28版本的msi下载页面
第一个是在线安装，安装时需要连接网络
第二个离线，我们选择离线的
我在这里下载的是离线版的
下载完后打开安装包进入安装界面
点击 NEXT
点击 NEXT
第一个路径是安装路径，第二个是数据文件存储路径，选定后点击 NEXT
点击 NEXT
点击 Execute
然后静待它安装完成
点击 NEXT
点击 NEXT
服务器端口配置：
默认选择第一个
若仅本地使用不需要连接网络则可不勾选TCP/IP这个选项，
端口默认是3306
named pipe是局域网用的协议，需要可以勾上
shared memory协议，仅可以连接到同一台计算机上运行的 SQL Server 实例，需要可以勾上。
点击NEXT
点击 NEXT
这里是设置登入密码
点击 NEXT
这里不用改，直接点击 NEXT
直接点击 Excute
到此就安装完成了
2.配置系统环境变量 右键桌面我的电脑→属性→高级系统设置→环境变量
在系统变量那里找到PATH，编辑，新建C:\Program Files\MySQL\MySQL Server 8.0\bin
（这个路径是你下载的mysql路径）找到安装路径后在这里点右键复制地址然后粘贴
3.配置初始化my.ini文件 首先可以看见安装目录下没有my.ini文件或者my-default.ini文件,于是自己在安装目录下创建一个my.ini文件（创建一个txt文件，改后缀名就行）,文件内容如下:
[mysqld] # 设置3306端口 port=3306 # 设置mysql的安装目录 basedir=C:\Program Files\MySQL\MySQL Server 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec0de17bfdb9fd3043ad8af5a5683feb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42dcfde71e2c2a331998da1b4aa1dc0a/" rel="bookmark">
			docker compose容器管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.安装环境
CentOS7-64
镜像
nginx
mysql/mysql-server:5.7
1.什么是docker-compose
Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排
通过编写docker-compose文件可对多个服务同时进行启动/停止/更新(可定义依赖，按顺序启动服务)
docker-compose将所管理的容器分为3层结构：
project 1 一个微服务项目
service N 由N个微服务组成
container N 而每个微服务又由N个节点组成
docker-compose.yml组成一个project，project里包括多个service，每个service定义了容器运行的镜像（或构建镜像），
网络端口，文件挂载，参数，依赖等，每个service可包括同一个镜像的多个容器实例。
即 project 包含 service ，service 包含 container
注1：Docker-Compose的工程配置文件默认为docker-compose.yml
注2：compose英文意思：组成
2.为什么要使用docker-compose
前面我们使用 Docker 的时候，定义 Dockerfile 文件，然后使用 docker build、docker run 等命令操作容器。
然而微服务架构的应用系统一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，
那么效率之低，维护量之大可想而知
。而使用 Docker Compose 可以轻松、高效的管理容器，
它是一个用于定义和运行多容器 Docker 的应用程序工具。
注1：images/01 docker与docker-compose区别.jpg
使用compose基本上是一个三步过程：
1）用dockerfile，或者镜像定义应用程序的环境，以便在任何地方复制。
2）在docker-compose.yml中定义组成应用程序的服务，以便它们可以在单独的环境中一起运行。
3）运行docker compose up启动并运行整个应用程序。
3.docker-compose安装与配置
1.安装方式有3种
官网的方式去安装
pip进行安装
离线安装(本章介绍)，官网下载速度太慢了，离线方式更快
2.离线安装
#1.下载安装文件
访问Releases · docker/compose · GitHub，下载 docker-compose-Linux-x86_64，我是复制链接地址，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42dcfde71e2c2a331998da1b4aa1dc0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15d150021cb928346db01f2c9b35f4f1/" rel="bookmark">
			Window下80端口被PID=4进程占用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在windows10下面安装ngnix时，发现启动报错。
原因是80端口bind不了，被占用了。
通过Window+R打开运行窗口，输入cmd，打开命令输入窗口，输入以下命令查看80端口情况。
netstat -aon |findstr "80" 发现80端口被pid为4的进程占用。打开任务管理器，查看pid为4的进程，发现是System。这些就一脸蒙了。被系统占用了？ 后来在网上查询了一下，使用如下命令，查看http服务状态快照。 netsh http show servicestate 看到请求的进程ID是5644，在任务管理器中找到这个pid，发现是ReportingServicesServer服务。运行services.msc，开服务窗口，找到这个服务。
看到这个服务就知道了，我的机器上面安装了SqlServer服务，禁用这个服务，改为手动启动即可。
之后再次运行命令：
netstat -aon |findstr "80" 已经没有占用这个端口的进程了。
原文链接:https://www.jianshu.com/p/78993e1ebc63
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320ffc8dabcb1a0437fd66da11105761/" rel="bookmark">
			常见的时间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的算法时间复杂度由小到大依次为：
常数阶 &lt; 对数阶 &lt; 线性阶 &lt; 线性对数阶 &lt; 平方阶 &lt; 立方阶 &lt; 指数阶
O() &lt; O() &lt; O() &lt; O() &lt; O() &lt; O() &lt; O()
随着 ​ 的规模不断增大，上述时间复杂度不断增大，算法的执行效率越低
常数阶 O() 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就是O()
int i = 1; int j = 2; ++i; j++; int m = i + j; ​代码执行的时候，并不随着某个变量的增长而增长，那么无论代码有多少行，即使有几万几十万行，它的时间复杂度都是O（1）
对数阶 O() int i = 1； while(i &lt; n){ i = i * 2; } 在while循环里面，每次都将i乘以2，乘完之后，i距离n就越来越近，假设循环x次后，i 就大于n了，此时这个循环就退出了，也就是说2的x次方等于n，那么x = 也就是说当循环次后，这个代码就结束了，因此这个代码的时间复杂度为O（）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/320ffc8dabcb1a0437fd66da11105761/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c3c6866c8c660e654497c7fe7338039/" rel="bookmark">
			位运算的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		位运算的介绍
运算符名称及其规则例子~取反（~1 = 0， ~0 = 1）~11101 = 10&amp;按位与（1&amp;1 = 1， 0&amp;1 = 1&amp;0 = 0&amp;0 = 0）11001 &amp; 10100 = 10000|按位或（1|1 = 0|1 = 1|0 = 1， 0|0 = 0）1001 | 10 = 1011^按位异或（0^1 = 1^0 = 1, 0^0 = 1^1 = 0）101001 ^ 11000 = 1001&lt;&lt;左移1000 &lt;&lt; 1 = 10000&gt;&gt;右移1000 &gt;&gt; 1 = 100 位运算的一些使用
异或，与，或都满足交换律和结合律：
a^b = b^a, a^b^b= a^(b^b)， a&amp;b = b&amp;a, a&amp;b&amp;b = a&amp;(b&amp;b)，a|b = b|a, a|b|b = a|(b|b)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c3c6866c8c660e654497c7fe7338039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f24f0da016e078042e6a6970318415a/" rel="bookmark">
			网站存在后门 收到公安的网络安全限期整改通知书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户网站因存在漏洞，被上报到了国家网络与信息安全信息通报中心，分发给当地网警，并给下发了网络安全监督检查限期整改通知书，并电话以及邮件告知了客户，要求3天内对漏洞进行修复以及网络安全防护，对网站进行全面的安全加固，防止漏洞再次的发生。客户第一次碰到这种情况，也不知道该如何解决，找了当时设计网站的公司，他们竟然回复解决不了。 客户才找到我们SINESAFE安全公司，说实在的，很多客户遇到这种情况，第一时间想到的是网站建设公司，并不会想到找网站安全公司来解决问题。在这里再跟大家解释一下，代码设计是功能方面以及外观方面的设计，像开发一个会员注册功能，都是代码设计的范围，可当会员注册存在漏洞，这就是属于网站漏洞修复的范畴，应该找网站漏洞修复公司来处理。
我们来看下网络安全监督检查限期整改通知书：
根据《中华人民共和国网络安全法》《中华人民共和国人民警察法》《中华人民共和国计算机信息系统安全保护条例》等法律法规规定，我单位于近日对你单位网络安全保护工作进行了监督检查，现将有关情况反馈如下:详见附件，根据《中华人民共和国网络安全法》《中华人民共和国计算机信息系统安全保护条例》《信息安全等级保护管理办法》《公安机关互联网安全监督检查规定》，请你单位于2022年1月18日前完成整改，并在期限届满前将整改情况函告我单位。
在期限届满之前，你单位应当采取必要的安全保护管理和技术措施，确保网络安全。对于未按期限完成整改的，我单位将依据《中华人民共和国网络安全法》、《中华人民共和国计算机信息系统安全保护条例》、《信息安全等级保护管理办法》的规定开展行政处罚工作。
关于“ 北京某某有限公司 ”存在安全隐患的情况通报，跟据国家网络与信息安全信息通报中心 监测发现： “ 北京某某有限公司 ”存在 的安全隐患， 细节详见附件 1 。 请你单位迅速调查处置，核实事件影响及危害程度，做好网络安全防护，处置情况请按附表 2 要求及时回复我中心。
附件 1 ：网站安全隐患详情
附件 2 ：网站安全隐患处置上报信息
以上就是客户收到的通知，通报的漏洞是网站存在sql注入漏洞，我们SINE安全技术对该网站页面下的功能代码，进行了详细的人工代码安全审计，发现该代码是一段搜索功能的代码，在输入搜索关键词这里，代码里并未对get、post、cookies方式的提交进行过过滤，导致可以插入任意的sql注入语句，并到网站后台进行数据库语句的执行。所以才产生该SQL注入漏洞，针对这个漏洞，我们SINESAFE进行了紧急的安全应急响应，对该漏洞进行修复，对代码进行了过滤拦截：对用户输入的特殊字符进行严格过滤，如’、”、&lt;、&gt;、/、*、;、+、-、&amp;、|、(、)、and、or、select、union。对客户网站下的其他代码也进行了全面的检查，在其他代码里也发现了sql注入漏洞，也进行了修复与安全加固。
整体的网站漏洞修复以及网站安全加固好后，我们写了一份漏洞整改报告，写明漏洞的原因以及修复方法，包括后续做了哪些安全加固，什么时间完成的，以及后续工作中发现并验证了哪些隐患漏洞、恶意程序。如果您对整改修复以及报告不会处理的话可以向网站漏洞整改修复公司寻求帮助，也写了处置上报信息，具体上报的截图如下：
因为漏洞修复和整改报告回执后，网安那边收到后还得详细的对网站存在的漏洞进行检查，通过网安技术人员对目前网站的漏洞进行测试，确保没问题后，才能认为网站整改是没有问题的，否则被再次检测出漏洞的话直接会被处罚。
邮件收到后，请回复一下.回复内容格式为“姓名+单位全称+职务+手机号码”。详细阅读本邮件，并按以下要求及时进行整改、反馈.如系统被篡改，被植入恶意代码、木马病毒、后门文件，存在僵尸网络、主机异常访问行为，请先备份被墓改网页、恶意代码、木马病毒、后门文件，保留好日志记录.请你单位核实漏洞情况，并开展网络安全隐患全面排查，彻底修复漏洞.请于2个工作日内反馈2整改报告(盖章)、3附件2(可编辑版)、4网站安全案事件调查处置情况记录单(首页盖章)、5墓改网页、恶意代码、木马病毒、后门文件(电子版)、6能够记录攻击行为的日志(应用层面的、中间件的、主机层面的、安全产品层面的日志记录)(电子版)、)7攻击线索调查(可编辑版)。将上述文件(盖章版的为扫描件)打包，以“单位全称”命名压缩包文件名，将压缩包发送至wachuhi@bjchy.gov.cn邮箱.注:5、6、⑦文件为发生网络攻击事件的单位提供，其它单位不用提供。网络攻击事件包括系统被篡改,被植入恶意代码、后门文件、木马病毒程序，存在僵尸网络、主机异常访问行为等。
网络安全案事件现场处置时间2022年2月18日14：30需你单位3名工作人员到场。来访人员需为1法定代表人、2首席执行官或网络安全负责人(需为企业副总、党政机关国企事业单位分管领导)、3具体工作负责人.携带以下材料到分局：1、携带介绍信、法人身份证复印件或身份证明、其他来访人员身份证原件及复印件、工商营业执照(或事业单位登记证书、社会团体登记证书等}副本原件及复印件等证件材料。2、拱带填写完整并加盖公章的整改报告；页面被簋改、被植入恶意代码、后门文件、木马病毒程序的截图，光盘(被篓改页面或被植入恶意代码、后门文件、木马病毒程序的文件、日志记录文件)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29d4e351d26b867fe5b358809c5afc40/" rel="bookmark">
			力扣网页PC端无法进入（问题得到解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近发现在不同地方，使用不同WiFi时，有些地点出现力扣网页PC端无法加载的问题。
按照网上方法进行了调试，发现帖子推荐改hosts文件，将自己电脑https://leetcode-cn.com/的对应IP加入hosts文件。此种方法，试了后，并没有解决问题。
还进一步试了更新DNS缓存，也没有解决问题。
浏览器卸载重装，问题依然存在。
到了晚上，发现相同浏览器又可以进去了，所以，根本原因还是在于网络问题，和电脑网络的配置没有关系。
之前所讲，以为是网速的问题，后来发现不是，其他网页都可以进去，打游戏延迟也很低，唯独进力扣网页遇到问题。
问题所在：
需要配置电脑的DNS，如下图所示，将“自动获取DNS”改为“手动输入DNS”，输入如下DNS，就可以解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d417a564afb16b3074e9f1398a985cf2/" rel="bookmark">
			Batch Normalization层的均值和方差的shape?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BN层的均值和标准差的shape是什么样子的？ 首先，BN的工作原理是： # t is the incoming tensor of shape [B, H, W, C] # mean and stddev are computed along 0 axis and have shape [H, W, C] mean = mean(t, axis=0) stddev = stddev(t, axis=0) for i in 0..B-1: out[i,:,:,:] = norm(t[i,:,:,:], mean, stddev) 可以看到，均值和方差是[H, W, C]的样子，只在B这个维度上做gather。
但是，Conv层有一个特点，那就是权重共享，卷积核的shape是[h,w,c]的，这并不是全连接的（不是每个像素都有单独的权重），这个卷积核会划过整个图像，因此，图像处理中的BN操作，也就没有理由针对每个像素单独设计，而是也采用和卷积类似的共享参数方法： # t is still the incoming tensor of shape [B, H, W, C] # but mean and stddev are computed along (0, 1, 2) axes and have just [C] shape mean = mean(t, axis=(0, 1, 2)) stddev = stddev(t, axis=(0, 1, 2)) for i in 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d417a564afb16b3074e9f1398a985cf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d411e29acf59c832498a9358db64fa6/" rel="bookmark">
			在“信创”大背景下 美信时代的业务思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据量的飞速增长，并不是单纯对云端进行扩容就可以完全应对的。大量的数据汇聚到云端进行处理，带来的延迟逐渐让人无法忍受。在移动智能设备终端，延迟往往令实时互动滞后，严重影响体验；在制造业领域，监控瞬时数据量巨大，留给异常数据的处理窗口很小，传输延迟可能会造成巨大损失。若要完全借助“云计算”实现生活、生产的大数据处理，还要解决传输延迟，那投入的硬件成本将难以估量。
在“信创”大背景下，美信时代“被集成”的业务思路，有助于赋能信创产业“云边端协同”生态建设。产品的易用性以及低代码的开发环境，瓦解了用户企业产业升级的技术壁垒，使得信创产品得以向下游企业快速落地，让国内产业吃到降本增效的技术红利。
回顾美信时代产品落地生产应用的过程不难发现，“云边端协同”虽说是企业数字化转型以及生产向物联网过度的必然结果，但打造与之相匹配的体系，却需要循序渐进。“云边端协同”体系首先要满足技术自主，再面向场景提炼共性，而后根据主流需求进行产品升级，再指导配套设施迭代和投入设施升级后的再生产。遵循这样的产业规律，才能在避免资源浪费、解决兼容性问题的基础上，在国内实现如此市场规模的产业升级。
北京美信时代科技有限公司（简称“美信时代”）创立于2007年，坚定不移走自主创新之路,产品全面适配信创国产化，拥有监控易-泛IT系统一体化综合运维管控平台、美之信工业物联网平台、Big River超融合数据库等一系列产品和解决方案。美信时代产品广泛应用于能源、金融、教育、医疗等领域，服务过的客户包括国家部委、省级、地市级政府机构和数千家央企、大型国企、知名外企和500强名企，纳管设备超百万数量级，并获得来自知名VC真格、达内集团和云智慧、天旦的投资。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f99c846fc637a44fe4a89b84ff6e4605/" rel="bookmark">
			关于IDEA中log爆红问题的解决（插件的安装【自动&amp;手动】）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、问题由来
二、问题解决
1、解决log爆红
2、解决Marketplace无反应
3、手动添加插件
4、自动安装
一、问题由来 其实啊，这是一次做课设的过程，因为之前没怎么用过IntelliJ IDEA，所以在抛异常的时候遇到了图1-1所示的问题。
图1-1 可以看到，这个地方出现了错误，但是如图1-2所示，此时包是已经导入了的。
图1-2 所以就展开了此次问题的解决，相信也有像我一样的小白会有这样的问题。
二、问题解决 1、解决log爆红 首先我找到了两个解决log爆红的文章，链接如下IntelliJ IDEA log.info 报红如何解决？_深拥不弃0924的博客-CSDN博客_idea log报红https://blog.csdn.net/qq_44746074/article/details/103870299 上面这个比较简介，与此同时我还找到一个会伴随着出现的问题，就是下面这个链接缺失Lombok插件（现象：log爆红，@Data注解失效，set&amp;get方法爆红） - 砰砰的猿 - 博客园 (cnblogs.com)https://www.cnblogs.com/pengpengdeyuan/p/14392735.html
看到这个文章以后我才意识到我的@Data和set get方法还得自己手动生成才可以调用。进行尝试后我发现我的IDEA没有Plugins–&gt;Browse repositories，这个应该是版本的问题，然后我猜测是在那个marketplace里面搜索，但是打开以后一直加载不出来，然后还报那种类似超时重连的字
2、解决Marketplace无反应 于是乎，我就找了解决IDEA无法打开Marketplace的文章解决IDEA无法打开Marketplace的三种方案_Tiger_li的博客-CSDN博客https://blog.csdn.net/weixin_44161378/article/details/110295965
第一种尝试后没起到效果，第二种就是手动添加（后面会讲到），第三种我只切换了一下手机流量，也没起到效果。换代理、关防火墙啥的我感觉还不如直接手动添加来的直接。所以我果断选择了手动添加。
3、手动添加插件 首先需要去官网IntelliJ IDEA Ultimate Plugins and Themes | JetBrains Marketplace查找lombok，如图2-1所示。
图2-1 接着在version里面找自己需要的版本，Compatibility range是兼容性版本，我的是2019.1，点击Download下载。
图2-2 图2-3 然后继续在setting——&gt;Plugins点击这个“齿轮”，如图2-4
图2-4 找到自己下载下来的压缩包地址，如图2-5。点击OK，然后重启就完事了。
图2-5 ———这块你可以看到我的Marketplace出来了，这是为什么呢？哈哈，是这样的，在我手动下载完这个插件后，莫名其妙的显示出来了，可能是第一种方式反应的比较慢，还没等到我就开始了手动。如果是样的话，那么上面的三种办法中第一种就是奏效的。
如果手动安装还有问题，那么下面这个链接也许会帮到你
idea手动安装lombok插件_成为世间你想看见的改变的博客-CSDN博客_lombok手动安装https://blog.csdn.net/qq_34244479/article/details/86717367
4、自动安装 当然我最后还是用的自动，毕竟害怕手动下载的又出了啥问题，不过我之后还是尝试了一下手动的没有问题。鉴于上面的marketplace显示出来了，所以干脆我就在这儿又整理了我解决问题的时候自动安装的方式。 上面的链接里面也有，我就不一步一步介绍了，过程就是下面的过程：
然后就好啦，其他的set get方法也不用先写好了再调用了。
这个问题虽然简单，但是我在此总结了一下我解决问题的整个过程，希望对一些小伙伴有用。另外，这个问题的解决是靠参考这四篇文章共同的结果，对于附上链接的四篇文章的作者表示感谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f0c23141e32c033f691cd277dffce03/" rel="bookmark">
			05. 基础篇 - 多表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多表关系 一对多（多对一） 多对多 一对一 多表查询概述 内连接 -- 查询每一个员工的姓名，及关联部门名称(隐式内连接) -- 表结构：name，dept -- 连接条件：emp.dept_id = dept_id select emp.name ,dept.name from emp, dept where emp.dept_id = dept_id; -- 查询每一个员工的姓名，及关联部门名称(显式内连接) -- 表结构：name，dept -- 连接条件：emp.dept_id = dept_id select e.name ,d.name from emp e inner join dept d on e.dept_id = d.id; 外连接 -- 查询emp表的所有数据，和对应的部门信息（左外连接） -- 表结构：emp dept -- 连接条件：emp.dept_id = dept.id select e.* ,d.name from emp e left outer join dept d on e.dept_id = d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f0c23141e32c033f691cd277dffce03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c00c35f56b295eefdca7f909ebbad5/" rel="bookmark">
			关于 FullNat 模式的 Toa 实现原理【转】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 背景获取client ip的几种方法toa/uoa 获取client ip原理tcp option 字段lvs中的toa格式与插入格式插入 后端获取client ipss/netstat 和 toa的关系其他实现方式 参考 背景 FullNat 模式的特点，比如跨机房、可运维性强等优势。不过会存在一个问题，在后端服务器上，应用程序能够获取到的请求源 IP 是 lvs 的 LocalIP，并不是真实客户端的 ClientIP。而现在大多数业务都需要对用户信息进行分析画像，也有一些敏感业务需要对用户进行溯源，所以获取用户的真实客户端 IP 地址是非常重要和必要的。
获取client ip的几种方法 有一定流量的业务基本上都要经过负载均衡设备，所以后端服务器要获取客户端真实IP地址，也是常见的问题和需求，这里先罗列几种常见的获取源 IP 的方式：
通过 L3 转发时，源 IP 不变。
比如 lvs 的 dr、nat、tunnel 模式，后端服务器可以直接获取到真实客户端 IP 地址。通过 proxy protocol 协议实现源 IP 传递。
原理是在三次握手后，发送请求数据前，在四层头之后插入一个 proxy protocol 数据包，数据包中可以携带 src ip、src port 等信息，该协议是由 haproxy 提出的，目前常见的 web 服务器都已经支持。通过 toa 模块获取源 IP。
在三次握手最后一个 ack 数据包的 tcp option 中插入源 IP 和源 Port 等信息；后端服务器在调用 getpeername 获取源 IP 时读取 tcp option 数据即可获取真实客户端的 IP 地址。通过七层的 XFF 字段。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18c00c35f56b295eefdca7f909ebbad5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833d7f724c10220660297a62f56fcfd3/" rel="bookmark">
			cdh组件之间的端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f70767e349896849db785fca7d8867/" rel="bookmark">
			java.lang.UnsupportedOperationException: For security reasons, WebView is not allowed in privileged
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做的项目，用webview加载网页，自测好好的，突然有一天，项目赋予了系统级应用能力，这个时候，webview不能用了；
狗血，怎么办呢？
因为应用是系统级别的，在AndroidManifest.xml中添加了android:sharedUserId=“android.uid.system”
根据异常分析，是安全问题限制了webview控件使用
追溯源码发现有这样的判断
if (uid == android.os.Process.ROOT_UID || uid == android.os.Process.SYSTEM_UID || uid == android.os.Process.PHONE_UID || uid == android.os.Process.NFC_UID || uid == android.os.Process.BLUETOOTH_UID) { throw new UnsupportedOperationException( "For security reasons, WebView is not allowed in privileged processes"); } 如果进程ID是root或者system，就会抛出UnsupportedOperationException。
为什么会有这种安全机制呢？因为webview允许运行js，如果用户通过js注入安全代码，那么js就可以肆无忌惮的使用系统权限，这无疑是一个漏洞。
解决方案：
方案一：换控件
就是android:sharedUserId="android.uid.system"的问题，因为是系统应用所以只能修改基础调试库的展示控件，把展示调试信息的webview改为textview。
方案二：修改framework层代码
禁用判断条件
因为我们是做硬件的，所以可以支持修改framework层代码，通过OTA更新来解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/507ba2618536cc74a1ca6f1f62b8f4d9/" rel="bookmark">
			剑指 Offer 63. 股票的最大利润
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		剑指 Offer 63. 股票的最大利润 题目题目链接解题思路题解代码 题目 题目链接 https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/
解题思路 题解 动态规划
利润计算：加入第 a 天买入，第 b 天卖出，利润为 prices[b] - price[a]，且 b &gt; a此时假设，第 a 天的价格是这几天中最低的，且假设第 b 天为这几天中最高价，此时 prices[b] - price[a] 就为最大利润此时在 2 的基础上，假如今天是第 c 天，此时最大利润：Math.max(price[c], price[b] - price[a]) 代码 class Solution { public int maxProfit(int[] prices) { // 最大利润 int maxProfit = 0; // 最小价格 int minPrice = 0; for (int i = 0; i &lt; prices.length; i++) { // 刚开始不存在所谓的利润，此时第一日就为最小价格 if (i == 0) { minPrice = prices[i]; continue; } // 今天加个比最小的还小，替换最小值 if (prices[i] &lt; minPrice) { minPrice = prices[i]; continue; } // 最大利润：今天加个 - 最小价格 与 已经计算过的最大差价比较，去更大的那个 maxProfit = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/507ba2618536cc74a1ca6f1f62b8f4d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f7187cb50c6c04719812d5180c0be22/" rel="bookmark">
			【matlab数字图像处理】数字图像处理中的坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用坐标系 数字图像是二维的离散信号，故有一个坐标系定义上的特殊性。
为什么要理解坐标系？ 1、在通过for循环去遍历像素时，要注意 i 和 j 对应的是col还是row。。。刚上手的时候不好理解的。
for i = 1:hm for j = 1:wn temp = NoiseI(max(i-w,1):min(i+w,hm),max(j-w,1):min(j+w,wn)); Gr = exp(-(temp-NoiseI(i,j)).^2/(2*sigma_r^2)); W = Gr .* Gs((max(i-w,1):min(i+w,hm))-i+w+1, ... (max(j-w,1):min(j+w,wn))-j+w+1); result(i,j) = sum(W(:).* temp(:))/sum(W(:)); end end 2、在索引像素位置的时候，不懂坐标系对应的规则就找不对，很真实。。。
一图说清三者关系 数字图像处理中坐标系的分类 在不同的仿真工具和不同格式的图像中，表示方式有些区别，但常用的一般以下三种：矩阵坐标系、直角坐标系、像素坐标系。
1、矩阵坐标系 按照行列顺序定位数据。矩阵坐标系原点定位在左上角，图像A(i,j)，i表示行，向下；j表示列，向右。Matlab当中一般采用这种矩阵方式。
2、直角坐标系 就是中学学的坐标系。
3、像素坐标系 原点在左上角，与矩阵坐标系相同。图像 f(x，y)，x表示列，向右；y表示行，向下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5765f4b066a50e43edb7c735c04b69e2/" rel="bookmark">
			运行Scrapy程序时出现No module named win32api问题的解决思路和方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Scrapy的时候，发现创建项目一切顺利，但是在执行Scrapy爬虫程序的时候却出现下列报错：“No module named win32api”，如下图所示，但是不知道怎么破，今天就这个问题讲解一下解决方案。
出现这个报错是因为在Windows下我们缺少一个包，叫pypiwin32，这个报错一般只是在Windows下出现。很多人看到“No module named win32api”，于是乎便想着直接输入安装命令“pip install win32api”，结果系统给出下图提示：
“Could not find aversion that satisfies the requirement win32api (from versions: ) No matchingdistribution found for win32api”。
原来是没有找对安装包，正确的姿势是安装pypiwin32才是，输入安装命令“pip install pypiwin32”，结果如下图所示：
再尝试从豆瓣源上进行下载该库，结果如下图所示：
还是报错，确实是好尴尬。
接下来就该求助Python包网站https://www.lfd.uci.edu/~gohlke/pythonlibs/，里边的Python包专门用于Windows下的安装的。在网页中找到pypiwin32安装包，然后选择本机Python对应版本和电脑系统位数的安装包，小编的电脑是64位的，而且Python版本是Python3.4，所以下载的包如下图红色框框所示。
下载之后，将安装包放到site-packages文件夹下，如下图所示：
之后执行安装命令“pip install pywin32-223.1-cp34-cp34m-win_amd64.whl”，如下图所示，显示“pywin32-223.1-cp34-cp34m-win_amd64.whlis not a supported wheel on this platform.”，无支持的平台。
此时仍需要get一个小技巧，之前在Scrapy安装的问题总结一文中也有提及，这里再次借助这个方法进行实现，直接将.whl改为.zip，尔后进行解压即可，输入“pip list”进行查看。
可以看到pywin32已经在里边了，并不是pypiwin32，怀着试一试的心态，再次执行爬虫命令，可以看到不再报这个错误了，竟然解决了这个问题。
PS：因为爬虫程序的主题文件还没有任何的逻辑实现，所以返回的pipelines数据为空。
最后安利一个小技巧。最近有的小伙伴在群里问，如果不小心没有记住Scrapy爬虫项目的名字，又不想去Pycharm中进行查看爬虫主体文件，这该怎么办？这里介绍一个小技巧，可以帮助你找到爬虫的名字。直接在命令行中输入“scrapy list”即可看到爬虫的名字，如下图所示。
到这里，关于“No module namedwin32api”的报错问题已经得到了解决，下次可以直接输入安装命令“pip install pywin32”即可，如果有报错的话，可以再尝试文中的解决问题的思路和方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2029da214a4806cf3090881cf87ce289/" rel="bookmark">
			关于shell输出重定向，tee的使用，以及time无法被重定向的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于重定向的使用 使用重定位符可以将命令的输出结果保存到文件
&gt;&gt; 进入追加模式。
如果命令执行错误，可以使用 2&gt;&amp;1 将命令的输出和错误保存到同一个文件中。
tee 命令可以将执行结果显示在屏幕的同时，将结果写进文件。
tee 命令 -a 选项进入附加模式 command | tee -a file.txt
==注意：管道 和 重定向无法同时使用。（管道符的" | "的作用只是把前一个程序的标准输出流(stdout)的数据 作为后一个程序 的标准输入流stdin的数据。而输出重定向是将输出到一个文件重定向到另一个文件。）
很明显我们的输出重定向无法直接处理管道数据，和许多命令类似的（例如echo命令），我们可以借助 xargs 命令将标准输入中读取内容，传递给它要协助的命令。
对于特殊的命令，例如 time 命令 time 可以用于测量一个命令执行的时间。但是我发现time 输出的内容和被测量命令输出的内容不是绑定在一起输出的。
通过简单的测试发现，time命令无论是从1 还是 2 都无法被重定向，对于管道也是无法使用。
同时，我们使用tee也是无法将 time的输出结果写进文件的。
通过查阅资料了解到：
time是shell的关键字，shell做了特殊处理，它会把time命令后面的命令行作为一个整体来进行处理，在重定向时，实际上是针对后面的命令来的处理的。且time命令的输出信息是打印在标准错误输出上的（类似的还有dd命令）
这里有两种办法将其结果重定向至文件：
一种是通过 {}将整个命令的输出结果视为一个整体第二种方法就是使用()通过子shell执行命令，将子shell的输出视为一个整体。 第一种方法：
第二中方法：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c43bc4350081b31dbd493dd6bcc11496/" rel="bookmark">
			Spring Boot 整合FastJson
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Pom配置FastJson测试类全局配置 Pom配置FastJson 首先去掉本来自带的jackson，再加上FastJson依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.79&lt;/version&gt; &lt;/dependency&gt; 测试类 User实体类：
public class User { private String username; private Date birthday; Get set方法省略 UserController类：
@RestController public class UserController { @GetMapping("/user") public User getuser(){ User user = new User(); user.setUsername("dong"); user.setBirthday(new Date()); return user; } } 全局配置 编写config类，配置FastJson @Configuration public class WebMvcconfig { @Bean FastJsonHttpMessageConverter getconvers(){ FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter(); FastJsonConfig jsonConfig = new FastJsonConfig(); jsonConfig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c43bc4350081b31dbd493dd6bcc11496/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc31a8b2fa9527264c821313e53376bb/" rel="bookmark">
			MATLAB绘制地图超详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		worldmap和usamap是axesm的子类，worldmap是用于生成世界地图坐标区域，usamap用于生成美国地图坐标区域，本文先在worldmap函数基础上讲解如何导入各种数据绘制各种类型图片，略提一下如何使用usamap，再讲解axesm的各种属性以满足更多元化的地图绘制需求，并在最后总结地图绘制其他可用函数。
Mapping Toolbox工具箱安装 请通过如下步骤安装工具箱：
点击附加功能：
搜索Mapping Toolbox，并点击进入介绍界面：
点安装一路点确定：
worldmap及usamap
首先是最简单的海岸线世界地图：
% 创建世界地图坐标区域 worldmap('World') % 导入海岸线数据 load coastlines % 绘制海岸线 plotm(coastlat,coastlon) 附带陆地区域、湖泊、河流、城市的世界地图：
% 创建世界地图坐标区域 ax=worldmap('World'); setm(ax,'Origin',[0 180 0]) % 绘制陆地 land=shaperead('landareas.shp','UseGeoCoords',true); geoshow(ax,land,'FaceColor',[0.5 0.7 0.5]) % 绘制湖泊 lakes=shaperead('worldlakes.shp','UseGeoCoords',true); geoshow(lakes,'FaceColor','blue') % 绘制河流 rivers=shaperead('worldrivers.shp','UseGeoCoords',true); geoshow(rivers, 'Color', 'blue') % 绘制城市 cities=shaperead('worldcities.shp','UseGeoCoords',true); geoshow(cities,'Marker','.','Color','red') 可以看到绘制的主要流程就是：
创建地图坐标区域(通过axesm、worldmap、usamap)导入数据(通过load或者shaperead)通过geoshow、plotm、scatterm绘制图像(大部分普通坐标区域axes中出现的函数加个m就变成了用于地图坐标区域的函数) worldmap创建地图坐标区域部分：
大家肯定想知道worldmap()里面支持哪些参数，这个连官网都没有写，事实上只要无参数运行一下函数worldmap()就会蹦出来一个地区选择框，大家可以试一下啊：
同时worldmap函数支持直接输入经纬度范围，例如：
latlim=[-50 50]; lonlim=[160 -30]; worldmap(latlim,lonlim) 数据导入部分：
其中可以通过load导入的MATLAB自带数据有：
coastlines - 世界海岸线经纬度矢量conus - 用于连接的美国(conus)、五大湖、州际边界的经纬度阵列geoid60c - 全球大地水准面高度网格（以米为单位）/度greatlakes - 显示结构阵列中的北美五大湖korea5c - 朝鲜半岛的地形和水深测量koreaEQdata - 地震位置和震级layermtx - 用于教学的地理定位地形网格mapmtx - 用于教学的地理定位地形网格moonalb20c - 克莱门汀全球月球反照率图moontopo60c - 月球的克莱门汀激光雷达地形oceanlo - 显示结构数组中的海洋遮罩多边形russia - 网格化土地、水域、边界、外部区域seatempm -全球多通道海面温度网格stars - 4500+颗恒星的天体坐标和星等usamtx - 美国各州的数据网格，每度五个单元格usgslulegend - USGS 土地利用类别列表 其中可以通过shaperead导入的MATLAB自带数据有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc31a8b2fa9527264c821313e53376bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da7cd911de1505eb3bd783b61b385c9/" rel="bookmark">
			金蝶云星空与聚水潭系统对接方案项目经验分享（聚水潭主管库存）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案简介 对于曾从事传统线下业务的企业而言，在开展电子商务销售之前往往购置了ERP系统，并已经应用于线下销售业务。由于在线销售的形态和线下销售迥异，传统ERP往往无法适应在线销售。采用“轻易云集成方案”的解决方案，不仅能解决在线销售管理问题，也能低成本地对接现有的传统ERP系统。
打破企业内部数据孤岛，无需繁琐的处理工序，与数据集成服务完美结合，让数据真正通起来。 资源互补：汇集各种行业解决方案，资源互补，企业管理融合提升。
集成系统 聚水潭与金蝶云星空系统集成
可以快速的可视化配置集成方案
系统集成数据流程图 集成方案明细 01-商品同步物料集成方案 源系统查询接口：sku.query（普通商品资料查询 按sku查询）目标系统写入接口：batchSave（创建物料） 标准方案参考：01-JK商品同步物料集成方案- 轻易云系统集成方案
集成方案字段明细
序号
源系统-字段
源系统-字段名
目标系统-字段
目标系统-字段名
描述
1
datas.name
固定值
FName
名称
2
sku_id
商品编码
FNumber
编码
3
固定值
FDescription
描述
4
100
固定值
FCreateOrgId
创建组织
5
100
固定值
FUseOrgId
使用组织
6
datas.properties_value
固定值
FSpecification
规格型号
7
固定值
FMnemonicCode
助记码
8
固定值
FMaterialGroup
物料分组
9
datas
商品列表
SubHeadEntity
基本
10
1
固定值
SubHeadEntity.FErpClsID
物料属性
11
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9da7cd911de1505eb3bd783b61b385c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b90b9443455f0f398bc1eda1e32b3d2/" rel="bookmark">
			基于深度学习的腹部CT的肝脏肿瘤分割的项目笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言：
1 这个肝脏肿瘤分割项目是我们大二下学期（2020年1月开始）申请的一个大创项目。
此前我有参与过一个关于深度学习的项目（基于深度学习的视频识别），但在这个项目中我算是摸摸鱼的角色，but 也还是有收获的啦！比如：对做这些项目的流程算是有一个大致的了解 ？ 打开了深度学习的门。。。
2 写这篇文章就是想记录一下我做第二个项目的历程。（因为今天10.24，又在晚上刚好把代码调通了！！！真的是过节了吖！！！所以就写个回忆散记来庆祝这激动人心的时刻嘻嘻~）
二、关于肝项目的经历和想法：
总体来说，项目的过程其实是不太顺畅的。。。现在凭借我感人的记忆力按时间顺序回忆一些难忘的过程节点。（不想看太多我这平凡琐碎的经历的话，可以直接看最后精华的两点噢~哈哈哈）
1 首先，一开始我们还没想到用云服务器来跑代码（算是走了点弯路）。所以，之后在尝试跑别人的代码的时候，由于本地环境配置的问题，异常艰难！！！好吧，就是一次都没跑通过。环境问题一直有报错，这就费了我们几个月时间，现在想起来，真的太费时间！
2 在项目整个前半段（有六七个月的时间了），我们是在网上找各种资料（收藏了等于看了 ）在知网阅读文献、在CSDN看相关项目的文章、在知乎看大佬的医学图像处理的专栏文章、还有在github上查找和学习相关代码等等。
3 在前期找资料时，在CSDN发现了一篇博客，偶买噶！！这不就是我们想要的项目指导书吗？
就是这篇：医学图像分割 基于深度学习的肝脏肿瘤分割 实战(一）_normol的博客-CSDN博客
这文章写得太详细啦！小白真是太感动了！第一篇是分割肝脏的，然后还有第二篇是分割肿瘤的。
我们想着就按照这两篇博客来完成这个项目。但是美好的想法还是和现实进展有点距离的。在这篇博客下面的评论中收获到很多有用的信息，并且下载了源代码，但是，由于前面说的，当时是用本地的pycharm来跑代码的，就一言难尽（由于环境的配置问题，一直有各种奇奇怪怪的报错），心态逐渐崩了昂。但是也是有认真学习了博主的方法和代码。印象中应该是花了一两个月来研究和尝试跑通这份代码的，但是很可惜并没有成功。。。
期间，在评论区的一位大佬帮助过程中，我了解到了百度的深度学习框架飞桨PaddlePaddle-源于产业实践的开源深度学习平台
4 接着，九月一号一开学就要进行项目中期汇报了。但是我们的项目仿佛没有实质性的成果。噢！我的老天鹅，这就有点尴尬了。
本着毛主席说的“东方不亮西方亮”，我们尝试找其他参考资料。然后又发现了一篇博客！！Tensorflow 2.0 医学图像分割（肝脏CT图像分割）_qq_38412266的博客-CSDN博客
（并且这个博主小哥太nice啦，给我很多帮助！真是十分感谢！！）
但是呢，这份代码只是将腹部CT图的肝脏分割出来了，肿瘤部分还得再搜寻搜寻。。。然后在博主大佬的帮助下，我学了用kaggle云服务器来跑代码。在kaggle上面还有很多有趣的开源项目，之后有时间可以运行玩一下噢~
5 然后就在十月初的时候，我找到了两份github上的代码。（但是现在我忘了当时是在什么机缘偶合的情况下找到的。。。找的时候，我也会顺着他们github的个人主页来看一下有没有相关的代码~）
https://github.com/zz10001/Thesis-LiTS2017/blob/master/preprocessing.py
重点是下面这一份！！
Confusezius/unet-lits-2d-pipeline: Liver Lesion Segmentation with 2D Unets
这份代码，作者的README里面的步骤写的很详细！！我跑的就是这一份代码~ 这个README得认真看，看懂每一步（一开始我以为他的大小Net都要运行，之后才觉悟二选一就行）
一开始一直都是用kaggle的云服务器，但是后来中途报错显示爆内存了（kaggle和colab都有13G内存好像）。然后就转到去谷歌的Colab了。
这也是我第一次用Google Colab，百度一下怎么用，还是很快上手的噢~不得不说真的太赞了！体验很好吖，用着很顺手哈哈哈。（我是之前在干第一个视频识别项目的时候，注册了谷歌的账号）Google Colab——用谷歌免费GPU跑你的深度学习代码
之后，在colab我就跟着README里面的步骤，敲命令来运行的，某个代码有报错的话，就改了代码再重新把这个.py上传到谷歌的云端硬盘（不能直接在云盘改的噢），虽然感觉反复上传更新很复杂，其实也没有很复杂噢，上传py文件还是很快的。感觉代码主要是改一下路径，报错也不是很牛角尖的错，在stack overflow都有方法~
然鹅，就在过节的今天（1024），代码全部调通了哈哈哈！！
但是有个问题就是，我就上传了三四个nii文件作为数据集（因为怕内存不够），所以训练出来的效果不太行。肝脏分割的DICE参数是0.91（还不错噢），但是肿瘤分割的DICE参数只有0.16，所以出来的结果是一大片肿瘤区域。
下面两幅图，第一个是原数据集中的标准肝脏和白色的肿瘤，第二个是训练出来的分割结果。(我是用ITK-SNAP来打开nii文件的)
现在项目算是完成百分之六七十啦~
下一步试一下加多nii数据的数量来训练~
二、结语
emmm 这项目笔记就写到这儿叭，很遗憾，这虎头蛇尾的。
很抱歉不能一一回复私信，因为我可能有心无力去解答。。。
嗐，之后也不读研，所以深度学习的学习可能就到此为止啦~~
（遗憾离场）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4748f9e9fead7b9bf8e225606a27c74/" rel="bookmark">
			前言--写在前面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据分析定量分析常见应用场景
二、数据分析的整体思路
数据分析最重要的部分不是编程，而是分析框架、分析思路和数据敏感性。
1.分析框架：提出问题定义需求，收集数据，数据整理，数据建模与分析，和解释结果和应用。
2.分析思路：描述性统计分析（数据分布情况分析、单变量分析），确认性数据分析（假设分析、A/B测试），探索性数据分析（双变量分析、多变量分析）。
3.数据敏感性：是指对具体业务的熟悉程度，越熟悉越能输出高质量的分析方案。
有个明显拉开差距的地方是对数据模型和算法的掌握上。
以上内容有部分转自https://zhuanlan.zhihu.com/p/149962215
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852612702f6a85cdb472126e253efb68/" rel="bookmark">
			前端HTML5/HTML&#43;CSS3/CSS学习笔记(六)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表单的应用 认识表单创建表单 认识表单 注：表单”是网页上用于输入信息的区域，用来实现网页与用户的交互、沟通。例如注册页面中的用户名和密码输入、性别选择、提交按钮等都是用表单相关的标记定义的。
创建表单 在HTML5中，&lt;form&gt;&lt;/form&gt;标记被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，&lt;form&gt;&lt;/form&gt;中的所有内容都会被提交给服务器。
&lt;form action="url地址" method="提交方式" name="表单名称"&gt;
各种表单控件
&lt;/form&gt;
&lt;form&gt;与&lt;/form&gt;之间的表单控件是由用户自定义的，action、method为表单标记&lt;form&gt;的常用属性。
在HTML5中，表单拥有多个属性，通过设置表单属性可以实现提交方式、自动完成、表单验证等不同的表单功能。 action属性：	action属性用于指定接收并处理表单数据的服务器程序的url地址。 method属性：	method属性用于设置表单数据的提交方式，其取值为get或post。 name属性：	name属性用于指定表单的名称，以区分同一个页面中的多个表单。 autocomplete属性：	autocomplete属性用于指定表单是否有自动完成功能 novalidate属性：	novalidate属性指定在提交表单时取消对表单进行有效的检查。 input元素及属性
&lt;input /&gt;元素是表单中最常见的元素，网页中常见的单行文本框、单选按钮、复选框等都是通过它定义的。
属性	属性值	描述 type	text	单行文本输入框 password	密码输入框 radio	单选按钮 checkbox	复选框 button	普通按钮 submit	提交按钮 reset	重置按钮 image	图像形式的提交按钮 hidden	隐藏域 file	文件域 email	e-mail地址的输入域 url	URL地址的输入域 number	数值的输入域 range	一定范围内数字值的输入域 Date pickers (date, month, week, time, datetime, datetime-local)	日期和时间的输入类型 search	搜索域 color	颜色输入类型 tel	电话号码输入类型 name	由用户自定义	控件的名称 value	由用户自定义	input控件中的默认文本值 size	正整数	input控件在页面中的显示宽度 readonly	readonly	该控件内容为只读（不能编辑修改） disabled	disabled	第一次加载页面时禁用该控件（显示为灰色） checked	checked	定义选择控件默认被选中的项 maxlength	正整数	控件允许输入的最多字符数 autocomplete	on/off	设定是否自动完成表单字段内容 autofocus	autofocus	指定页面加载后是否自动获取焦点 form form元素的id	设定字段隶属于哪一个或多个表单 list	datalist元素的id	指定字段的候选数据值列表 multiple	multiple	指定输入框是否可以选择多个值 min、max和step 数值	规定输入框所允许的最大值、最小值及间隔 pattern	字符串	验证输入的内容是否与定义的正则表达式匹配 placeholder	字符串	为input类型的输入框提供一种提示 required	required	规定输入框填写的内容不能为空 input元素的type属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/852612702f6a85cdb472126e253efb68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/383c187cf07138f48314b7c189c750f1/" rel="bookmark">
			使用LSTM预测股票数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据集：股票数据集.
数据集来源：:https://www.kaggle.com/dsadads/databases
1 加载数据集 import numpy as np import pandas as pd import datetime stock = pd.read_csv('dataset/SH600519.csv') stock_data = pd.read_csv('dataset/SH600519.csv') stock_data.set_index(['date'], inplace=True) stock_data Unnamed: 0openclosehighlowvolumecodedate2010-04-267488.70287.38189.07287.362107036.136005192010-04-277587.35584.84187.35584.68158234.486005192010-04-287684.23584.31885.12883.59726287.436005192010-04-297784.59285.67186.31584.59234501.206005192010-04-307883.87182.34083.87181.52385566.70600519........................2020-04-2024951221.0001227.3001231.5001216.80024239.006005192020-04-2124961221.0201200.0001223.9901193.00029224.006005192020-04-2224971206.0001244.5001249.5001202.22044035.006005192020-04-2324981250.0001252.2601265.6801247.77026899.006005192020-04-2424991248.0001250.5601259.8901235.18019122.00600519 2426 rows × 7 columns
2 绘制收盘价图 import matplotlib.pyplot as plt from matplotlib import ticker # 调整坐标轴 from matplotlib.pylab import date2num # 日期转换 stock = stock[100:200] stock['close'].plot(grid = True) &lt;AxesSubplot:&gt; 3 计算涨跌幅 stock_data.shape[0] 2426 stock_data.iloc[101:102,].values array([[1.75000e+02, 1.06990e+02, 1.08749e+02, 1.08858e+02, 1.06475e+02, 1.85480e+04, 6.00519e+05]]) quote_change = [] for i in range(stock_data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/383c187cf07138f48314b7c189c750f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18ebbfe6065c5f815919bf871e7ec447/" rel="bookmark">
			模型压缩：剪枝算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过参数化主要是指在训练阶段，在数学上需要进行大量的微分求解，去捕抓数据中的微小变化信息，一旦完成迭代式的训练之后，网络模型推理的时候就不需要这么多参数。而剪枝算法正是基于过参数化的理论基础而提出的。
剪枝算法核心思想就是减少网络模型中参数量和计算量，同时尽量保证模型的性能不受影响。
那在AI框架中，实际上剪枝主要作用在右下角的端侧模型推理应用场景中，为的就是让端侧模型更小，无论是平板、手机、手表、耳机等小型IOT设备都可以轻松使用AI模型。而实际在训练过程更多体现在剪枝算法和框架提供的剪枝API上面。
剪枝算法分类 实际上大部分刚接触剪枝算法的时候，都会从从宏观层面去划分剪枝技术，主要是分为Drop Out和Drop Connect两种经典的剪枝算法，如下图所示。
1）Drop Out：随机的将一些神经元的输出置零，称之为神经元剪枝。
2）Drop Connect：随机将部分神经元间的连接Connect置零，使得权重连接矩阵变得稀疏。
结构化剪枝 VS 非结构化剪枝 下面会把剪枝的更多种方式呈现出来，可能会稍微复杂哈。从剪枝的粒度来划分，可以分为结构化剪枝和非结构化剪枝，2个剪枝结构方法。下面来看看具体的剪枝方法有4种：
1) 细粒度剪枝(fine-grained)：即对连接或者神经元进行剪枝，是粒度最小的剪枝，上面Drop Out和Drop Connect都是属于细粒度剪枝。
2) 向量剪枝(vector-level)：它相对于细粒度剪枝粒度稍大，属于对卷积核内部(intra-kernel) 的剪枝。
3) 核剪枝(kernel-level)：即去除某个卷积核，丢弃对输入通道中对应卷积核的计算。
4) 滤波器剪枝(Filter-level)：对整个卷积核组进行剪枝，推理过程中输出特征通道数会改变。
细粒度剪枝、向量剪枝、核剪枝在参数量与模型性能之间取得了一定的平衡，但是网络模型单层的神经元之间的组合结构发生了变化，需要专门的算法或者硬件结构来支持稀疏的运算，这种叫做结构化剪枝（Unstructured Pruning）。
其中，非结构化剪枝能够实现更高的压缩率，同时保持较高的模型性能，然而会带来网络模型稀疏化，其稀疏结构对于硬件加速计算并不友好，除非底层硬件和计算加速库对稀疏计算有比较好的支持，否则剪枝后很难获得实质的性能提升。
滤波器剪枝（Filter-level）主要改变网络中的滤波器组和特征通道数目，所获得的模型不需要专门的算法和硬件就能够运行，被称为结构化剪枝（Structured Pruning）。结构化剪枝又可进一步细分：可以是channel-wise，也可以是filter-wise，还可以是在shape-wise。
结构化剪枝与非结构化剪枝恰恰相反，可以方便改变网络模型的结构特征，从而达到压缩模型的效果，例如知识蒸馏中的student网络模型、NAS搜索或者如VGG19和VGG16这种裁剪模型，也可以看做变相的结构化剪枝行为。
剪枝算法流程 虽然剪枝算法的分类看上去很多，但是核心思想还是对神经网络模型进行剪枝，目前剪枝算法的总体流程大同小异，可以归结为三种：标准剪枝、基于子模型采样的剪枝、以及基于搜索的剪枝，如下图所示。
标准剪枝算法流程 标准剪枝是目前最流行的剪枝流程，在Tensorflow、Pytroch都有标准的接口。主要包含三个部分：训练、剪枝、以及微调。
1）训练：首先是对网络模型进行训练。在剪枝流程中，训练部分主要指预训练，训练的目的是为剪枝算法获得在特定基础SOTA任务上训练好的原始模型。
2) 剪枝：在这里面可以进行如细粒度剪枝、向量剪枝、核剪枝、滤波器剪枝等各种不同的剪枝算法。其中很重要的就一点，就是在剪枝之后，对网络模型结构进行评估。确定一个需要剪枝的层，设定一个裁剪阈值或者比例。实现上，通过修改代码加入一个与参数矩阵尺寸一致的Mask矩阵。Mask矩阵中只有0和1，实际上是用于微调网络。
3）微调：微调是恢复被剪枝操作影响的模型表达能力的必要步骤。结构化模型剪枝会对原始模型结构进行调整，因此剪枝后的模型参数虽然保留了原始的模型参数，但是由于模型结构的改变，剪枝后模型的表达能力会受到一定程度的影响。实现上，微调网络模型，参数在计算的时候先乘以该Mask，Mask为1的参数值将继续训练通过BP调整梯度，而Mask为0的部分因为输出始终为0则不对后续部分产生影响。
4）再剪枝：再剪枝过程将微调之后的网络模型再送到剪枝模块中，再次进行模型结构评估和执行剪枝算法。目的是使得每次剪枝都在性能更优的模型上面进行，不断迭代式地进行优化剪枝模型，直到模型能够满足剪枝目标需求。
最后输出模型参数储存的时候，因为有大量的稀疏，所以可以重新定义储存的数据结构， 仅储存非零值以及其矩阵位置。重新读取模型参数的时候，就可以还原矩阵。
基于子模型采样流程 除标准剪枝之外，基于子模型采样的剪枝《EagleEye: Fast sub-net evaluation for efficient neural network pruning》最近也表现出比较好的剪枝效果。得到训练好的模型之后，进行子模型采样过程。一次子模型采样过程为：
1）对训练好的原模型中可修剪的网络结构，按照剪枝目标进行采样，采样过程可以是随机的，也可以按照网络结构的重要性或者通过KL散度计算进行概率采样。
2）对采样后的网络结构进行剪枝，得到采样子模型。子模型采样过程通常进行 次，得到 个子模型（ ≥1）, 之后对每一个子模型进行性能评估。子模型评估结束之后，选取最优的子模型进行微调以得倒最后的剪枝模型。
基于搜索的剪枝流程 基于搜索的剪枝主要依靠强化学习等一系列无监督学习或者半监督学习算法，也可以是神经网络结构搜索相关理论。
给定剪枝目标之后，基于搜索的剪枝在网络结构中搜索较优的子结构，这个搜索过程往往伴随着网络参数的学习过程，因此一些基于搜索的剪枝算法在剪枝结束后不需要再进行微调。
剪枝的发展 这几年神经网络剪枝pruning作为模型压缩技术的四小龙之一，正在受到越来越多的关注。当然，各种更好的pruning参数选取方法一定还会层出不穷。另外，从趋势来看，以下几个方向值得关注：
打破固定假设：挑战已有的固有的假设，例如ICLR2019会议的best paper彩票假说《The Lottery Ticket Hypothesis: Finding Sparse, Trainable Neural Networks 》的出现。还有一开始提到的对于over-parameterization，与重用已有参数是否有有益的反思非常有意思。这样的工作会给剪枝算法非常大的启发，从而根本改变解决问题的思路。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18ebbfe6065c5f815919bf871e7ec447/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4c1dc5603b1c772a037a8efa29b3f29/" rel="bookmark">
			智能手机相机测试中的功能测试和性能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相机测试分两部分：
1.功能部分
2.性能部分（包括响应时间，主观测试和客观测试）
功能测试：
1.基本功能测试。就是每个菜单及每一个功能用一遍，主要菜单，在测试时，等级要定高一点，比较偏的菜单，等级相对要低点，方便在回归测试时，选择测试用例。
2.异步测试。使用功能时，来电话，来短信，来微信，插拔充电器，低电压拍照等等，当然常用的异步测试，等级也要订高一点，例如来电话。
3.边缘测试及压力测试。例如：手机内存快满的时候，进行拍照；连续拍照一百次，连续录像20分钟等等。
性能测试：
1.响应时间。例如：对焦时间；进入相机时间；拍照时间（从按下快门开始到拍照结束）；不同模式之间切换时间等。
2.主观测试。实际场景测试，包括晴天场景，室内场景，阴天场景，夜景，微距测试，闪光灯测试，HDR， 然后根据拍照图片进行分析，包括锐度sharpness，细节，白平衡，动态范围，暗态噪声，照片是否偏暗，最好和对比机一起拍摄。
3.客观测试。客观测试目前常用的软件时IE和 Imatest，具体可以去官方网站上查看相关色卡及测试工具。
常用测试卡24色卡，西门子星图，SFR plus，ISO-15739等等。客观测试对一般没有实验室的公司比较麻烦，一般这些工具测试卡都比较贵。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b86b335ef6baa6b6e5b0745f420037/" rel="bookmark">
			使用for循环转置n*n矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public MmatrixTranspose(matrix: Float64Array) { const length: number = Math.sqrt(matrix.length); if (length % 1 === 0 &amp;&amp; matrix.length &gt; 3) { const matrixt: Float64Array = new Float64Array(matrix.length); for (let m: number = 0; m &lt; length; m++) { for (let i: number = 0; i &lt; length; i++) { matrixt[m * length + i] = matrix[i * length + m]; } } return matrixt; } else { console.warn("请确定传入的矩阵长度能正常开方"); return undefined; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bf82a20afcf2c1dad1342c3cf83d6a7/" rel="bookmark">
			【mysql】整数类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 整数类型1. 类型介绍2. 可选属性2.1 M2.2 UNSIGNED2.3 ZEROFILL 3. 适用场景4. 如何选择？ 整数类型 1. 类型介绍 整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。
它们的区别如下表所示：
整数类型字节有符号数取值范围无符号数取值范围TINYINT1-128~1270~255SMALLINT2-32768~327670~65535MEDIUMINT3-8388608~83886070~16777215INT、INTEGER4-2147483648~21474836470~4294967295BIGINT8-9223372036854775808~92233720368547758070~18446744073709551615 举例1：
CREATE TABLE test_int1( f1 TINYINT, f2 SMALLINT, f3 MEDIUMINT, f4 INTEGER, f5 BIGINT ); DESC test_int1; INSERT INTO test_int1(f1) VALUES(12), (-12), (-128), (127) SELECT * FROM test_int1; 当超出给定的范围时，就会出错
在mysql为5.7时，可以看到生成的类型都有默认值，如：tinyint(4) 表示的是在 tinyint 范围内 -128~127 的符号位是4位（符号+数字位数），所以默认数据的宽度为 4 ，其他同上。 2. 可选属性 整数类型的可选属性有三个： 2.1 M INT(M): M表示显示宽度，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用字符填满宽度。该项功能需要配合“ZEROFILL”使用，表示用“0”填满宽度，否则指定显示宽度无效。
如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？
答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即显示宽度与类型可以存储的值范围无关。从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性。
案例说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bf82a20afcf2c1dad1342c3cf83d6a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdeef10564b94e244503bdf9c0303e65/" rel="bookmark">
			金蝶云星空与聚水潭系统对接方案（金蝶主管库存）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案简介 对于曾从事传统线下业务的企业而言，在开展电子商务销售之前往往购置了ERP系统，并已经应用于线下销售业务。由于在线销售的形态和线下销售迥异，传统ERP往往无法适应在线销售。采用“轻易云集成方案”的解决方案，不仅能解决在线销售管理问题，也能低成本地对接现有的传统ERP系统。
通过轻易云系统集成平台完美结合：打破企业内部数据孤岛，无需繁琐的处理工序，与数据集成服务完美结合，让数据真正通起来。 资源互补：汇集各种行业解决方案，资源互补，企业管理融合提升。
轻易云系统集成无需任何代码知识，即可建立自动化与智能化业务流程，企业各个业务部门皆可使用。
集成系统 金蝶云星空与聚水潭系统集成
通过轻易云集成平台可以快速的可视化配置集成方案
系统集成数据流程图 集成方案明细 01-物料同步商品集成方案 源系统查询接口：executeBillQuery（查询物料）目标系统写入接口：jushuitan.itemsku.upload（普通商品资料上传） 标准方案参考：01-KJ物料同步商品集成方案- 轻易云系统集成方案
集成方案字段明细
序号
源系统-字段
源系统-字段名
目标系统-字段
目标系统-字段名
描述
1
FNumber
编码
sku_id
商品编码
商品编码
2
FBaseUnitId_FName
基本单位.名称
unit
单位
单位
3
固定值
shelf_life
保质期
保质期
4
FName
名称
i_id
款式编码
款式编码
5
F_ABCD_ASSISTANT
品牌-自定义
brand
品牌，可更新
品牌，可更新
6
固定值
vc_name
虚拟分类，可更新
虚拟分类，可更新
7
固定值
c_name
商品分类，必须是[商品类目管理]中的叶子节点，可更新
商品分类，必须是[商品类目管理]中的叶子节点，可更新
8
1
固定值
s_price
基本售价，可更新
基本售价，可更新
9
成品
固定值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdeef10564b94e244503bdf9c0303e65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1975264c027a00c939779e9565d619d8/" rel="bookmark">
			原生 select 标签选择后的边框修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 左图是初始化边框样式，右图是选择后，自带了粗边框。太丑了....要去除，修改如下：
select:focus-visible { /* outline: -webkit-focus-ring-color auto 1px; 这是谷歌浏览器的原生样式*/ outline: none; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a24c96ba08b5a05b7ab08544a0fb09/" rel="bookmark">
			mybatis-plus 实现一对多查询，返回VO对象某个字段为List
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类关系 Animal类下包含一个List&lt;Dog》，两表可用type字段关联。
@Data @TableName("animal") public class Animal { @TableId private String id; private Integer type; private List&lt;Dog&gt; dogList; } @Data @TableName("dog") public class Dog { @TableId private String id; private Integer type； private String name; private Integer age; private String color; } 表中数据：
问题 期望获得：
{ "id": "1", "type": 1, "dogList": [ { "id": "1", "type": "1", "name": "dogA", "age": 3, "color": "black" }, { "id": "2", "type": "1", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3a24c96ba08b5a05b7ab08544a0fb09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a4b7e3a077c79980c5a2eab0e99e8d4/" rel="bookmark">
			[Math] 二阶行列式和三阶行列式的几何意义的证明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		证明：二阶行列式和三阶行列式的几何意义的证明 今天突发奇想去复习线性代数（主要是看数值分析发现自己线代忘得差不多了），然后就突然看见一句话，说是二阶行列式的几何意义就是其平行四边形的面积，三阶行列式的几何意义是其六面体的体积，尝试证明
二阶行列式 直观证明
如图可见，由于平行四边形的定义，面积由底边和底边所对应的高决定，因此在下图平移过程中，蓝色和灰色的平行四边形的面积适中保持不变的，移动到合适位置时，可以显而易见的看到 以(a,b)和(c,d)为边的平行四边形是 以(a,0)和(0,d)为底边的长方形 与 以(c,0)和(0,b)为底边的长方形 的面积之差。
图片来源 Matrix67: The Aha Moments算式证明：平行四边形面积S = a b → × c d → \overrightarrow{ab} \times\overrightarrow{cd} ab ×cd = ∣ a b → ∣ ∣ c d → ∣ |\overrightarrow{ab} ||\overrightarrow{cd}| ∣ab ∣∣cd ∣ s i n θ sin\theta sinθ = a d − b c ad-bc ad−bc ?
由于 a b → ⋅ c d → \overrightarrow{ab} \cdot\overrightarrow{cd} ab ⋅cd = ∣ a b → ∣ ∣ c d → ∣ |\overrightarrow{ab} ||\overrightarrow{cd}| ∣ab ∣∣cd ∣ c o s θ cos\theta cosθ，即 c o s θ cos\theta cosθ = a b → ⋅ c d → ∣ a b → ∣ ∣ c d → ∣ \frac{\overrightarrow{ab} \cdot\overrightarrow{cd}}{|\overrightarrow{ab} ||\overrightarrow{cd}|} ∣ab ∣∣cd ∣ab ⋅cd ​，即 s i n θ sin\theta sinθ = 1 − c o s 2 θ \sqrt{1-cos^2\theta} 1−cos2θ ​ = 1 − ( a b → ⋅ c d → ∣ a b → ∣ ∣ c d → ∣ ) 2 \sqrt{1-(\frac{\overrightarrow{ab} \cdot\overrightarrow{cd}}{|\overrightarrow{ab} ||\overrightarrow{cd}|})^2} 1−(∣ab ∣∣cd ∣ab ⋅cd ​)2 ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a4b7e3a077c79980c5a2eab0e99e8d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/200d1712cec415e712030e36c749aa4e/" rel="bookmark">
			linux shell脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述 服务器最近经常出现jar运行一段时间后自动停止，可能原因是服务器资源不足，例如内存不够用；
shell自动重启服务脚本制作 文件名称：monitor.sh
完整版：
#!/bin/bash # “#!” 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行 # 变量 jarName=test.jar jarUrl=/data/solitasu webUrl=https://www.baidu.com/ # grep -v grep： 在文档中过滤掉包含有grep字符的行 # awk '{print $2}'： 按空格截取第二个 pid=`ps -ef|grep $jarName |grep -v grep| awk '{print $2}'` # wc -l： jar包进程的数量 num=`ps -ef|grep $jarName |grep -v grep| awk '{print $2}'| wc -l` MonitorFunction(){ # 输出文本 echo "[info]进入监控脚本"`date +'%Y-%m-%d %H:%M:%S'` # -eq: 等于 if [[ $num -eq 0 ]]; then echo "[error]进程不存在，重启"`date +'%Y-%m-%d %H:%M:%S'` # &gt;&gt; /dev/null : jar包生成日志不打印到此脚本日志中 java -jar $jarUrl/$jarName &gt;&gt; /dev/null &amp; else # 获取页面访问状态 # -m 10： 最多查询10s --connect-timeout 10：10秒连接超时 -o /dev/null： 屏蔽原有输出信息 -s: silent -w %{http_code}: 控制额外输出 code=`curl -s -o /dev/null -m 10 --connect-timeout 10 $webUrl -w %{http_code}` # -ne: 不等于 if [[ $code -ne 200 ]]; then echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/200d1712cec415e712030e36c749aa4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f09f745428bafff4841e7628a39fdae/" rel="bookmark">
			mmdetecion 中类注册的实现（@x.register_module()）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mmdetecion 中类注册的实现（@DETECTORS.register_module()） mmdetecion中，每一个类使用注册器（Registry）来进行注册，只要引入过该文件，就可以自动注册，在配置文件中使用（type=‘XXX’）的方式引用，例如
@DETECTORS.register_module() class FasterRCNN(TwoStageDetector): """Implementation of `Faster R-CNN &lt;https://arxiv.org/abs/1506.01497&gt;`_""" def __init__(self, backbone, rpn_head, roi_head, train_cfg, test_cfg, neck=None, pretrained=None, init_cfg=None): super(FasterRCNN, self).__init__( backbone=backbone, neck=neck, rpn_head=rpn_head, roi_head=roi_head, train_cfg=train_cfg, test_cfg=test_cfg, pretrained=pretrained, init_cfg=init_cfg) 上述是fasterRCNN的实现，@DETECTORS.register_module()是它的注册语法糖
python@语法糖： 首先来看一个例子
def funcA(fn): do_something() fn() do_someting() return "haha" def funcB(): return "B" funcA和funcB是两个单独的函数，我们现在用@funcA来修饰B
def funcA(fn): do_something() fn() do_someting() return "haha" @funcA def funcB(): return "B" 经过funcA的修饰，此时的B与以下代码等价：
def funcA(fn): do_something() fn() do_someting() return "haha" def funcB(): return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f09f745428bafff4841e7628a39fdae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2057ed35d8f97784f7ec178933d2f995/" rel="bookmark">
			使用docker-compose构建springcloud项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先准备两个服务,一个后台服务，一个网关
1）ormis-admin
2）ormis-gateway
2、为两个服务准备各自的Dockerfile
1）ormis-admin
#基于java8 FROM java:8 #创建一个目录存放jar包 RUN mkdir -p /opt/ormis/ormis-admin/config /opt/ormis/ormis-admin/logs #复制jar包以及相关配置文件 COPY ormis-admin-1.0-SNAPSHOT.jar /ormis-admin-1.0-SNAPSHOT.jar #添加进入docker容器后的目录 WORKDIR /opt/ormis/ormis-admin #配置项目端口 CMD ["--server.port=7001"] #对外暴露的端口号 EXPOSE 7001 #修改文件的创建修改时间 RUN bash -c 'touch /ormis-admin-1.0-SNAPSHOT.jar' #运行脚本，启动springboot项目 ENTRYPOINT ["java","-jar","/ormis-admin-1.0-SNAPSHOT.jar","-Dspring.config.location=/opt/ormis/ormis-admin/config/bootstrap.properties,/opt/ormis/ormis-admin/config/application.yml --logging.config=/opt/ormis/ormis-admin/config/log4j2-dev.xml &gt; /opt/ormis/ormis-admin/logs/ormis-admin.log 2&gt;&amp;1 &amp;"] 2）ormis-gateway
#基于java8 FROM java:8 #创建一个目录存放jar包 RUN mkdir -p /opt/ormis/ormis-gateway/config /opt/ormis/ormis-gateway/logs #复制jar包以及相关配置文件 COPY ormis-gateway-1.0-SNAPSHOT.jar /ormis-gateway-1.0-SNAPSHOT.jar #添加进入docker容器后的目录 WORKDIR /opt/ormis/ormis-gateway #配置项目端口 CMD ["--server.port=8888"] #对外暴露的端口号 EXPOSE 8888 #修改文件的创建修改时间 RUN bash -c 'touch /ormis-gateway-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2057ed35d8f97784f7ec178933d2f995/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8331ed8afd5c80772b5afb824413a4dd/" rel="bookmark">
			ORA-00600: internal error code, arguments: [kcbzib_kcrsds_1]模拟与修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天和大家分享下一个最近遇到的ORA-600的报错，就是标题所提及的ORA-00600: internal error code, arguments: [kcbzib_kcrsds_1]。本文共分为两个部分，第一部分为模拟报错，第二部分为故障解决。
一、问题的模拟与重现
测试环境：
数据库版本：19.3.0.0.0 no-cdb
session1-构造数据
create user test123 identified by oracle; grant dba to test123; SQL&gt; conn test123/oracle Connected. SQL&gt; create table t as select * from dba_objects; Table created. SQL&gt; insert into t select * from t; 75040 rows created. SQL&gt; / 150080 rows created. SQL&gt; / 300160 rows created. SQL&gt; / 600320 rows created. SQL&gt; / 1200640 rows created. session2-破坏环境
[ora11g@primary ~]$ cd /ora11g/app/ora11g/ [ora11g@primary ora11g]$ ps -ef|grep pmon ora11g 2177 1 0 10:45 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8331ed8afd5c80772b5afb824413a4dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9265db9a4cbd4a7e47b49332ee84478a/" rel="bookmark">
			【WEB安全】轻松检测钓鱼网站的技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你可能会认为钓鱼网站很难检测和跟踪，但实际上，许多钓鱼网站都包含唯一标识它们的HTML片段。
你可能会认为钓鱼网站很难检测和跟踪，但实际上，许多钓鱼网站都包含唯一标识它们的HTML片段。本文就以英国皇家邮政(Royal Mail)钓鱼网站为例来进行说明，它们都包含字符串css_4WjozGK8ccMNs2W9MfwvMVZNPzpmiyysOUq4_0NulQo。
这些长而随机的字符串是追踪钓鱼网站的绝佳指标，几乎可以肯定，任何含有css_4WjozGK8ccMNs2W9MfwvMVZNPzpmiyysOUq4_0NulQo的网页都是皇家邮政钓鱼工具的实例。
但是，像这样的独特字符串最终如何成为检测网络钓鱼工具标识的呢？
不幸的是，我们并不是RFC 3514的模仿者，在RFC 3514中，如果所有的IP数据包是恶意的，那么它们都包含一个标志信号。不，这些识别字符串完全是由钓鱼工具开发者无意中包含的。
→【网络安全更多技术学习资料包】←
钓鱼工具是如何诞生的？ 钓鱼网站试图尽可能接近他们真正的目标网站，然而，大多数钓鱼者并不具备复制公司网站的技能。相反，他们采用了快捷方式，只是假冒了原始网站的HTML并对其进行了一些小的调整。
假冒目标网站并将其变成钓鱼工具的过程大致如下:
1.使用诸如HTTrack之类的工具复制目标网站，甚至只需在网络浏览器中点击文件→保存即可。
2.调整HTML以添加一个请求受害者个人信息的表单。
3.将其与PHP后端粘合在一起，以保存收集到的数据。
然后，可以将该工具包轻松部署到便宜的托管服务提供商上，并准备收集受害者的详细信息。
4.通过复制整个网页，钓鱼者几乎不需要什么技巧或精力即可获得一个超级逼真的钓鱼页面。但是，这种假冒模式意味着他们的钓鱼页面充满了他们实际上并不需要的东西。
特别是，原始网站中的任何特殊字符串都有可能意外地出现在最终的钓鱼工具中。这对我们来说很好，因为寻找特殊字符串是一种非常容易和可靠的方法来检测钓鱼网站。
所谓的特殊字符串就是一个足够长或复杂的字符串，该字符串在整个互联网上都是独一无二的，这可能是因为它是随机字符(如64a9e3b8)或只是因为它足够长。
那么，问题来了：为什么在最初的网站中会有这些字符串?事实证明，在现代开发实践中，网站到处都是这些足够长或复杂的字符串。
网页中长或复杂的字符串是怎么来的？ 现代网站很少是100%静态的内容，当前的开发实践和网络安全特性意味着，有多种方法可以使冗长的随机字符串最终出现在网站中。以下是我所见过的各种来源的概述：
1.文件名中的哈希
现代网站通常使用诸如Webpack或Parcel之类的“捆绑包”进行处理，这些捆绑包将所有JavaScript和CSS组合成一组文件。例如，网站的sidebar.css和footer.css可能合并为一个styles.css文件。
为了确保浏览器获得这些文件的正确版本，捆绑程序通常在文件名中包含一个哈希。昨天你的网页可能使用的是styles.64a9e3b8.css，但是在更新你的样式表之后，它现在使用的是styles.a4b3a5ee.css。这个文件名的改变迫使浏览器获取新的文件，而不是依赖于它的缓存。
但这些足够长或复杂的文件名正是最近皇家邮政(Royal Mail)的钓鱼工具被发现的原因。
当钓鱼者假冒真正的皇家邮政网站时，HTML看起来是这样的:
不幸的是，不管他们用什么技术来假冒网站，文件名都没有改变。因此，通过urlscan.io查找大量使用CSS文件的钓鱼网站是很容易的:
2. 版本控制参考
网络钓鱼者针对的任何网站很可能都是由一个团队开发的，他们很可能会使用git等版本控制系统（VCS）进行协作。
一个合理的常见的选择是在网站的每一个构建中嵌入一个来自VCS的参考，这有助于完成诸如将漏洞报告与当时正在运行的代码版本相关联之类的任务。
例如，Monzo网站使用一个小的JavaScript代码片段嵌入了git commit哈希：
VCS参考资料对于安防人员来说非常有用，因为它们很容易在版本控制系统中找到。如果你发现一个钓鱼网站无意中包含了VCS参考，你就可以直接查找该网站的编写时间(也就是该网站被假冒的时间)。
3.SaaS的API密钥
网站经常使用各种第三方服务，如对讲机或reCAPTCHA。为了使用这些服务，网站通常需要包含相关的JavaScript库以及一个API密钥。
例如，Tide使用reCAPTCHA，并将这段代码作为其集成的一部分：
因为reCAPTCHA “sitekey” 对每个网站来说都是唯一的，因此任何包含字符串6Lclb0UaAAAAAJJVHqW2L8FXFAgpIlLZF3SPAo3w且不在tide.co上的页面都很可能是假冒的网站。
虽然SaaS API密钥是非常独特的，并且具有很好的指示作用，但它们变化非常少，因此无法区分从同一网站假冒出来的不同钓鱼工具。一个网站可能会使用相同的API密钥达数年之久，因此在那时创建的所有工具包都将包含相同的密钥。出于同样的原因，API密钥对于识别何时创建网络钓鱼工具包也没有任何帮助。
4. 跨站请求伪造(CSRF)令牌
事实证明，许多网络安全最佳实践也使网络钓鱼成为重要的指标。其中最常见的可能是“跨网站请求伪造”（CSRF）令牌。
简单地说，CSRF是一个漏洞，恶意网站可以借此诱骗用户在目标网站上执行经过身份验证的操作。例如，此HTML创建了一个按钮，点击该按钮可将POST请求发送到https://example.com/api/delete-my-account"：
如果example.com不能防御CSRF，它将处理此请求并删除毫无戒心的用户帐户。
防御CSRF的最常见方法是使用所谓的CSRF令牌，这是一个嵌入在每个网页中的随机值，服务器希望将其与敏感请求一起发送回去。例如，example.com的“删除我的账户”按钮应该是这样的：
服务器将拒绝任何不包含预期随机值的请求。
CSRF令牌非常适合检测钓鱼网站，因为从设计上看，它们是独一无二的。
5. 内容安全策略随机数
内容安全策略（CSP）是一种较新的安全手段，可帮助防御跨网站脚本（XSS）攻击。它允许开发人员指定策略，比如只允许特定域的&lt; script &gt;标记，或更有趣的是，对于我们的用例，仅允许包含指定“nonce”的&lt; script &gt;标记。
要使用基于随机数的CSP，网站需要包含以下政策：
并使用具有匹配随机值的脚本标签：
这有助于防止XSS攻击，因为恶意注入的JavaScript不会具有匹配的现时值，因此浏览器将拒绝运行它。
就像CSRF令牌一样，CSP随机数也构成了完美的网络钓鱼工具包检测器：它们的设计不可篡改，因此通常会为每个请求随机生成长且复杂的字符串。
6. 子资源完整性哈希
现代浏览器中可用的另一个安全功能是子资源完整性（SRI），通过允许你指定期望内容的哈希值，可以保护你免受恶意修改的JavaScript / CSS的侵害。当浏览器加载受SRI保护的JavaScript / CSS文件时，它将对内容进行哈希处理并将其与HTML中的预期哈希进行比较。如果不匹配，则会引发漏洞。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9265db9a4cbd4a7e47b49332ee84478a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a4fa3885387395bfd3e96566866378/" rel="bookmark">
			CSS中的BFC是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是BFC
一个块格式化上下文（block formatting context） 是Web页面的可视化CSS渲染出的一部分。它是块级盒布局出现的区域，也是浮动层元素进行交互的区域。
二、触发BFC的条件
1、根元素或其它包含它的元素（略过不谈）
2、浮动元素 (元素的 float 不是 none)
3、绝对定位元素 (元素具有 position 为 absolute 或 fixed)
4、内联块 (元素具有 display: inline-block)
5、表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)
6、表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)
7、具有overflow 且值不是 visible 的块元素，
8、display: flow-root （推荐使用）
9、column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。
三、BFC特性
1.内部的Box会在垂直方向上一个接一个的放置。
2.垂直方向上的距离由margin决定
3.bfc的区域不会与float的元素区域重叠。
4.计算bfc的高度时，浮动元素也参与计算
5.bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。
为什么要使用触发BFC？
1、BFC可以解决子元素浮动导致父元素高度塌陷问题
2、BFC可以解决两个兄弟盒子之间的垂直距离是由他们的外边距所决定的，但不是他们的两个外边距之和，而是以较大的为准，即margin重叠问题
3、不被浮动元素覆盖
4、防止文字环绕
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/434f11d7906ce1c2170461eb5acd7412/" rel="bookmark">
			2.《剑指Java面试-Offer直通车》--数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 如何设计一个关系型数据库
————存储管理【数据逻辑-物理逻辑管理】————缓存模块————SQL解析模块————权限划分————索引————锁
2. order by排序怎么理解？
————当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的
3. 联合索引、索引覆盖？也是全覆盖索引
————索引：加快查询，避免进行全表扫描 目前绝大多数情况下使用的数据库索引都是使用B+树实现的
————联合索引：INDEX idx_test(col_a, col_b) 包含多个字段的索引 险 = 耳朵 + （6-8画）
————最左前缀匹配：如果查询条件为where col_b = 1，则无法使用索引idx_test
————如果要查询的字段有索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），也就是说：不需要回表
————那么如果我们只是想要验证险字的偏旁是否是双耳旁“阝”呢？这种情况下，我们只要在部首索引中阝下游的叶子节点中找到了险字就足够了。这种在索引中就获取到了SQL语句中需要的所有字段，所以不需要再回表查询的情况中，这个索引就被称为这个SQL语句的全覆盖索引
————在现代的操作系统中，把数据从外存读到内存所使用的单位一般被称为“页”，每次读取数据都需要读入整数个的“页”
————varchar(50) 最多存放50个字符 （50）和（200）存储hello所占用的空间一样，但是后者在排序的时候，会消耗更多的内存
4. 百万级别数据如何删除？
————索引维护【innodb说是单独文件，修改删除都会对索引操作，需要多次io】1. 删除索引 2. 删除数据 3. 重新创建索引
5. 聚集索引/非聚集索引？
————聚集索引：将数据存储与索引放到了一块，找到索引也就找到了数据。 在MySQL数据库的InnoDB存储引擎中，主键索引就是聚集索引，所有数据都会按照主键索引进行组织 新华字典的拼音索引就是聚集索引
————非聚集索引：某种情况下需要回表
6. 索引根据添加分为？
————1. 主键索引 2. 唯一索引 3. 普通索引
7. 如何分析慢查询问题？
————1. 开启慢查询 2. explain 3. 修改sql添加索引
8. myisam为什么count快？
————因为无需计算，直接返回 ——存储特性问题 —— 没有where条件的场景下才有意义
————myisam没有事务，时候频繁count的场景
9. 为什么特殊情况下select count 使用的不是主键索引？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/434f11d7906ce1c2170461eb5acd7412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4132e1f06726489f8163d05a747cdbfa/" rel="bookmark">
			Python&#43;scrcpy&#43;pyminitouch实现自动化（二）——pyminitouch的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是pyminitouch？
minitouch是openstf基于ndk + Android开发的用于模拟人类点击行为的操作库。这个库以高稳定性、反应快著称，比起adb操作与uiautomator（两分钟搞懂UiAutomator自动化测试框架 - 知乎）都要更灵敏，被广泛应用于Android设备的精细操作。
然而它的使用与其安装方式都较为繁琐，无法定位打元素，使得它在自动化的应用领域上远远比不上uiautomator。它的体验感也较为一般，么此都要给手机重复安装指定版本的minitouch、建立、socket、然后再编辑操作命令，而且操作命令也很难阅读清楚。
pyminitouch = python + minitouch，降低使用成本，直接使用简洁的API调用
二、安装minitouch
准备工作：
（1）minitouch需要ndk，ndk下载：NDK 下载 | Android NDK | Android Developers
（2）下载相应的压缩包后进行解压。
（3）讲解压的目录添加到path环境变量中。
右击我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;找到path变量-&gt;新建-&gt;将文件目录路径粘贴进去
（4）运行ndk -build看是否运行成功，若像下面一样运行成功则说明安装成功。
最后出那个错是因为它找不到Android项目。
（5）安装adb：https://dl.google.com/android/repository/platform-tools-latest-windows.zip
将下载下来的文件添加到环境变量中，方法如上面的步骤。如果安装成功执行adb会有相应的提示。
minitouch的下载：
下载需要自行安装git，windows系统不像Linux自带git功能：
下载地址： Git - Downloads
打开后进入安装页面：
一直往下安装就可以了
下载项目源码
git clone https://github.com/openstf/minitouch.git 进入minitouch的目录，执行下面的命令： cd C:\Users\auus\minitouch 进入文件夹后，按顺序执行下面两句：
git submodule init git submodule update 执行到这一步后，再次执行ndk-build：
在文件中出现以上则说明安装成功。
三、安装pyminitouch
需要在python 3 上安装：
pip install pyminitouch 四、开始研究任务
在cmd中输入下面语句查询自己设备的平台：
adb shell getprop ro.product.cpu.abi 将minitouch文件push到设备上（注意：Android的有些目录是无法之心结果二进制文件的，所以一般放在/data/local/tmp目录中） adb push minitouch /data/local/tmp 进入文件夹查看文件，进入shell模式 adb shell 切换到/data/local/tmp目录 cd /data/local/tmp 执行命令查看minitouch是否存在，存在则就安装完成 ls 如果使用时提示没有权限，使用shell模式进入/data/local/tmp目录执行 chmod 751 minitouch 在上面的步骤我们已经实现将minitouch push到手机上了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4132e1f06726489f8163d05a747cdbfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25491b2306fe1460c83c3fde0286db82/" rel="bookmark">
			Windows下使用Doxygen&#43;GrapViz生成类图和调用图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一 、需求 查看代码文档或者查看函数调用或发布时生成相应的文档
二 下载安装 2.1 下载地址(最新版本即可) Doxygen：Doxygen download | SourceForge.net GraphViz：https://graphviz.org/download/
2.2 下载解压安装到任意目录 三 使用Doxygen和GrapViz 3.1 打开doxygen安装目录bin/doxywizard.exe 3.2 配置doxywizard 1.配置Wizard Tab项 2.配置Expert Tab项 3.配置Run Tab项 四 使用Doxygen和GrapViz生成效果图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d144ac9961bfcc38a555bfa4fe2307c2/" rel="bookmark">
			JAVA8 lambda表达式中Collectors.toMap()方法/List转Map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用lambda表达式中Collectors.toMap()方法将一个list转化成一个Map： 1. List &lt; Entity&gt; 转 Map&lt;Entity.getId,Entity&gt; 例：
Map&lt;Long, VipEntity&gt; vipMap = vipList.stream().collect(Collectors.toMap(VipEntity::getUserId, v -&gt; v, (v1, v2) -&gt; v1));
说明：
.collect(Collectors.toMap(VipEntity::getUserId, v -&gt; v, (v1, v2) -&gt; v1))
第一个参数： VipEntity::getUserId 表示选择 VipEntity 的 getUserId 作为map的key值；
第二个参数： v -&gt; v 表示选择将原来list中的每一个VipEntity对象作为map的key对应的每一个value值；
第三个参数：(v1, v2) -&gt; v1 这一行去掉的话，一般情况下也是可以正常执行的；但是，偶然情况下，vipList中
的VipEntity对象是有可能存在重复的，而我们是取VipEntity中的UserId作为Map的key值，众所周知，Map的key是不能相同的，所以此时两个相同的UserId都要作为map的key值，如果不做处理就会直接报异常；而我们**(v1, v2) -&gt; v1**的意思呐就是：当map的key出现重复的时候，我们取第一个key和value作为基准，忽略相同的情况。
另外：
1.你也可以这么写：(v1, v2) -&gt; v2，很明显，这样的意思就是：当map的key出现重复的时候，我们取第2个key和value作为基准，忽略相同的情况；
2.map的key你当然也可以使用别的，上面的例子中VipEntity::getUserId是以UserId作为map的key值，你也可以选择VipEntity::getPhoneNum，以PhoneNum作为map的key值，等等。。。
2. 基础类型的转换：List &lt; Long&gt; 转 Map&lt;Long,Long&gt; 例：
List&lt;Long&gt; list = new ArrayList&lt;&gt;(); list.add(1L); list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d144ac9961bfcc38a555bfa4fe2307c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f43b22baa77ea48e925e3f7a2f1f1a0/" rel="bookmark">
			【C&#43;&#43; Primer】第10章 泛型算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第10章 泛型算法 不同容器都能用的算法
经典算法的公共接口：如排序，搜索
10.1 概述 大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数组泛型算法。
int val = 42; auto res = find(vec.cbegin(), vec.end(), val); cout &lt;&lt; "The value " &lt;&lt; val &lt;&lt; (res == vec.cend() ? "找到" : "未找到") &lt;&lt;endl; string val = "a value"; auto res = find(lst.cbegin(), lst.cend(), val); int ia[] = {27,210,12,47,109,83}; int val = 83; int* res = find(begin(ia), end(ia), val); auto res = find(ia+1, ia+4, val); 只需要传入迭代器，但不依赖容器类型；但算法依赖于元素类型的操作
习题10.1
class Solution{ public: int targetNum(vector&lt;int&gt;&amp; v, int target){ int num = count(v.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f43b22baa77ea48e925e3f7a2f1f1a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f813ddae1e1aa716735aebaf78f0871a/" rel="bookmark">
			寻找两个正序数组的中位数(python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leecode题目----寻找两个正序数组的中位数 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
算法的时间复杂度应该为 O(log (m+n)) 。
示例 1：
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
示例 2：
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
def findmidnumber(nums1, nums2): """ 求出两个正序数组的中位数 这里主要用到了二路归并排序算法 :param nums1: 有序的数组，如[1,2,3] :param nums2: 有序的数组，如[3,4,5] :return: 两个正序数组的中位数，例如：3 """ len_left = len(nums1) len_right = len(nums2) left_point, right_point = 0, 0 # left_point是nums1的下标，right_point是nums2的下标，从零开始 cover_num = [] # 合并后的列表 while left_point &lt; len_left and right_point &lt; len_right: # 根据数组下标与数组长度的关系判断是否继续执行 if nums1[left_point] &lt;= nums2[right_point]: # 如果nums1的数较小，就先放nums1 cover_num.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f813ddae1e1aa716735aebaf78f0871a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/259/">«</a>
	<span class="pagination__item pagination__item--current">260/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/261/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>