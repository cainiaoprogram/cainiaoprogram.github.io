<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dce4fabd6593008b6c454abeb5f5b9d7/" rel="bookmark">
			一个前后端分离的，基于Thinkphp Vue ElementUI的，快速开发脚手架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个是一个典型的，前后端分离的开发框架，而且很多前后端代码，都可以很好的生成，无需写代码，大大减少程序员编写代码的数量。提高效率，降低成本！
基于Thinkphp+Vue+ElementUI的快速开发系统，是一个为个人和团队准备的快速开发脚手架系统，只要您懂数据库，有Thinkphp,Vue基础就可以实现开箱即用；
主要特点：
CRUD前后端代码一键生成 完全契合实际项目的CRUD前后端代码，无效任何修改即可使用
自由设定表单类型 内置众多表单组件，下拉，选择支持多种数据源；图片、文件一键上传；
常见操作方法一键生成 除了CRUD外，还支持诸如导入、导出、打印、跳转、弹窗，等各种方法；
一键生成前端API 标准化的前端API生成规则，支持多种验证方法，支持后端模块一键生成API
功能强大的数据表 高性能表格组件，支持虚拟滚动，海量数据操作无卡顿，同时具有高度灵活的可定制特性；
其他特点 无论是单表，多表，一对多都可灵活处理，支持基于部门的数据隔离，帮助友好，入门简单；
开箱即用操作步骤
获取源代码（Q:11905091）安装依赖： 进入源码根目录执行：composer install
进入源码/ui/目录下执行：yarn install 或者 npm install
创建数据库，配置数据库，导入数据 创建数据库mytest
复制.example.env文件到.env文件，修改数据库名为mytest，用户名和密码按照实际填写
导入数据：mysql登录数据库，切换数据库：use mytest;执行source data.sql
启动后端项目 进入源码根目录执行：php think run
启动前端项目 进入源码ui目录下执行：npm run serve
体验地址：http://demo.raiseinfo.cn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/011ccf06b606e6fb862555249a18d000/" rel="bookmark">
			Mission Planner初学者安装调试教程指南（APM或PIX飞控）6——富斯i6通过mission planner设置飞行模式（结合二挡三挡开关设置六种飞行模式）及主要飞行模式简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、遥控器设置
第一步要对遥控器进行设置。不同的教程有不同的推荐数值，这是一种测试可用的方案。missionplanner可以在初始设置飞行模式设置六种模式。
警告⚠️
1.飞行模式需要其他模块的支持，例如气压计，高度计，指南针🧭，不正确的设置飞行模式可能因为缺少硬件支撑而无法发挥作用。
2.不恰当的设置飞行模式可能导致危险，例如自行升空遇到障碍物炸机。自行执行航线缺乏避障炸机等。
3.飞行模式切换应当充分预估目标达成度。例如电量是否允许。
4.应在具备安全防护措施的区域对所需的模式进行测试调试，必要时采取系留措施。
5.无人机结构不牢固可能因切换模式时的剧烈运动导致无人机失控直至炸机。
6.部分飞行模式切换会带来高度的突然上升或下降。
7.部分飞行模式无法解锁无人机，无法安全降落或无法停机，错误操作可能加剧无人机失控。
8.设置最熟悉的档位可以便捷切换到自稳模式，紧急情况可以立即夺回控制权。
二、飞行模式设置
（一）设置方法
（二）关于简单模式和超简单模式
（三）主要飞行模式
1.稳定模式
2.高度保持模式
3.悬停模式
4.RTL模式
5.自动模式
一、遥控器设置 第一步要对遥控器进行设置。不同的教程有不同的推荐数值，这是一种测试可用的方案。missionplanner可以在初始设置飞行模式设置六种模式。 警告⚠️ 1.飞行模式需要其他模块的支持，例如气压计，高度计，指南针🧭，不正确的设置飞行模式可能因为缺少硬件支撑而无法发挥作用。 2.不恰当的设置飞行模式可能导致危险，例如自行升空遇到障碍物炸机。自行执行航线缺乏避障炸机等。 3.飞行模式切换应当充分预估目标达成度。例如电量是否允许。 4.应在具备安全防护措施的区域对所需的模式进行测试调试，必要时采取系留措施。 5.无人机结构不牢固可能因切换模式时的剧烈运动导致无人机失控直至炸机。 6.部分飞行模式切换会带来高度的突然上升或下降。 7.部分飞行模式无法解锁无人机，无法安全降落或无法停机，错误操作可能加剧无人机失控。 8.设置最熟悉的档位可以便捷切换到自稳模式，紧急情况可以立即夺回控制权。 二、飞行模式设置 （一）设置方法 打开初始设置——必要硬件——飞行模式。
切换遥控器的飞行模式开关（通道5），绿色高光就会移动到不同的位置，然后选择对应的模式
一般情况flyskyi6遥控器使用swc挡位可以设置三个模式，如果设置更多的挡位，可以通过混控来设置6个模式。
完成后点击——保存模式，完成设置。
（二）关于简单模式和超简单模式 Simple and Super Simple Modes “Simple” and “Super Simple” modes allow the pilot to control the movement of the copter from the pilot’s point of view regardless of which way the copter is facing.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/011ccf06b606e6fb862555249a18d000/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0906dcea748779d4c95840fd46df23c/" rel="bookmark">
			Pycharm使用终端时报错解决方案(Windows)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般终端报错都是因为本地终端地址没有设置，一般只需要设置一下就可以了
1.点击终端
2. 点击图中画框框的这个按钮
3. 点击里边的设置
4.根据我画框框的位置，调整你自己的设置
# 本地终端地址 C:/Windows/system32/cmd.exe 这里，我把cmd的文件路径放在下边
C:\Windows\System32\cmd.exe 最后只要点击确定即可，问题应该已经得到了解决
一般，pycharm使用的是power shell，但power shell我们一般情况下用不到，所以我们只用cmd就可以了，power shell本地地址也放在下边了
# power shell 本地地址（WIN10） C:\Users\lizhuolong\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Windows PowerShell 感谢阅读的博客，感谢支持！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452bfb3cdf5bfc7b96020f4b81b1e3ca/" rel="bookmark">
			闪贷Dapp的调研及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置知识 区块链应用Dapp
概念：去中心化应用（Decentralized Application, DApp）为建构于区块链上的应用程序，也被称之为分散式应用。
架构：传统网站：前端→API→数据库。
DApp类似于传统的Web应用程序，前端使用完全相同的技术来呈现页面，它包含一个与区块链通信的“wallet”，管理加密密钥和区块链地址。公钥基础结构用于用户标识和身份验证。与连接数据库的API不同，wallet so - ware触发了智能合约的活动，该智能合约与区块链交互：
Web3.0网站：前端（包括wallet）→智能合约→区块链。
智能合约：通常指代运行在 EVM 兼容网络中的 Solidity 或其他合约语言代码，他们负责与用户交易我们发行的资产并储存 DApp 的链上状态。DApp：整合合约接口以及其他功能的应用程序界面，目前，它们大部分是 Web App，你可以用流行的框架例如 React/Vue 来进行编写。Provider/Signer: 这是一个 DApp 架构中特殊的角色，它负责与区块链进行通信，并进行合约的读/写操作。Metamask 是一个流行的 InjectProvider（Web3Provider）你也可以使用其他 JSON-RPC Provider 与区块链进行通信。Relay: 这个角色隐藏在 Provider/Signer 之后，是真正负责我们与区块链的某一个节点同步状态的服务器集群，它保存了所有账本（全节点）它通常是 Infura、Alchemy、Quicknode、Moralis 或者 Pocket 提供的服务。服务端（可选）：大部分 DApp 仍然有他们的服务端逻辑，这意味着，你需要自己搭建服务环境，或使用流行的 BasS/FaaS 服务，你可以使用深度整合区块链的 Moralis 来完成服务端的开发，也可以使用成熟的 Firebase 体系。当然，你也可以挑战完全不依赖服务端的方式来构建 DApp，就像 Uniswap 所做的那样。 开发步骤：
准备： 公链：公链节点rpc接口，公链钱包，公链gas对应的代币学习公链接口的访问形式准备dapp浏览器或钱包插件 开发： 开发智能合约（ETH、bsc、tron合约，solidity语言）部署智能合约（在测试网申请测试币后部署智能合约，remix工具）开发dapp前端（vue框架，涉及钱包连接、合约调用、数据查询）后端开发 技术: web3，web3.jsvue框架metamask插件truffle框架简化Dapp开发流程 闪电贷flash loans
概念：用户在借到款之后，可以利用借到的资产进行其他操作，然后在交易结束的时候，用户只要把借到的款项及手续费及时归还就可以，否则该笔交易就会回滚，就像什么也没有发生过一样。DeFi 项目： Aave是最早将闪电贷进行实际应用的DeFi 协议，主要原理是通过调用 Aave 中 lendingPool 合约中的 flashLoan() 函数实现借贷，通过executeOperation() 函数实现具体的业务逻辑。dYdX 是一个针对专业交易者的去中心化交易所，本身并没有闪电贷功能，但是可以通过对 SoloMargin 合约执行一系列操作来实现类似闪电贷功能。其主要原理是通过继承 DydxFlashloanBase 合约编写initiateFlashLoan() 回调 callFunction() 实现借贷、套利、还款等操作。 业务流程与重要函数 说明：参考Aave(基于ETH公链)的业务流程与源码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/452bfb3cdf5bfc7b96020f4b81b1e3ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09c95d07ed1d2eace5e7004fdde4798c/" rel="bookmark">
			keil 之Vscode编辑器插件、格式化代码插件和最新注册机分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 如果程序通代码文件格式很乱，这时需要对每个位置进行整理很麻烦，所以这个时候装个插件很有必要。
使用AStyle进行代码格式化 Astyle 下载链接 ：链接：https://share.weiyun.com/5FsV7Ob 密码：aqfkk3 下载并把软件解压keil5单击Tools菜单—&gt;Customize Tools Menu
添加Astyle All Files 和Astyle Current File自定义菜单(可以使用中文) 添加格式化当前文件菜单的方法： 新建命令为格式化当前文件
添加Command命令：单击…按钮，选择Astyle.exe。
Arguments：
Astyle Current File即格式化当前文件菜单填写 !E
点击OK
添加格式化project中的所有文件菜单的方法： 新建命令为格式化project中的所有文件
添加Command命令：单击…按钮，选择Astyle.exe。
Arguments：
Astyle All Files即格式化项目所有文件菜单填写 “ E ∗ . c " " E*.c" " E∗.c""E*.h”
点击OK
注：!E 表示的是当前获得焦点且正在编辑的文件。
E∗.c和E*.h代表当前获得焦点且正在编辑文件所在目录下所有.c和.h文件（参考keil uVision的帮助文档）
使用的是Astyle默认格式来格式化文件，另外也可以自定义格式，自定义格式参考Astyle的帮助文档。默认格式化后，会备份原文件为源文件名.orig。如果不想让Astyle备份文件，可以使用-n参数。 如：-n !E （表示格式化当前文件，不备份）
使用 在keil中的使用效果：生成的菜单出现在Tools的下拉菜单中，Astyle的运行结构出现在keil的Build Output窗口中。
KEIL注册机分享（到2032年） 链接：https://pan.baidu.com/s/19kfSULFyco6lMAJTV9nzvQ
提取码：sdas
Keil添加外部编辑器Vscode 第一步：进入工具菜单配置界面
第二步：添加快捷方式
最终点击OK后，完成配置。点击Tool,则会出现以下快捷入口用VScode打开工程源码文件。
效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47fde5148952620df520c20782d0f83c/" rel="bookmark">
			collection接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97cfb4172cb5c5d39807a82c8dd8115d/" rel="bookmark">
			Win11 Windows聚焦不更新了怎么解决？聚焦锁屏图片不更换怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win11系统Windows聚焦不更新了怎么解决？聚焦锁屏图片不更换怎么办？很多朋友会遇到这个问题，这到底应该如何解决呢，为啥现在锁屏后都一直是同一张图片，Windows聚焦为什么不推荐新的锁屏壁纸？
这里有系统安装的方法可以看看
​
方法一：
1、首先，按下键盘上的win + S组合键，或单击任务栏上的搜索图标，打开Windows搜索窗口，在顶部的搜索框，输入CMD，然后单击以管理员身份运行命令提示符应用程序。
2、管理员：命令提示符窗口，输入并按回车执行以下命令：
del /f /s /q /a "%userprofile%/appdatalocalpackagesmicrosoft.windows.contentdeliverymanager_cw5n1h2txyewylocalstateassets"
3、管理员：命令提示符窗口，输入并按回车执行以下命令：
del /f /s /q /a "%userprofile%/appdatalocalpackagesmicrosoft.windows.contentdeliverymanager_cw5n1h2txyewysettings"
4、管理员：命令提示符窗口，输入并按回车执行以下命令：
powershell -executionpolicy unrestricted -command “&amp; {$manifest = (get-appxpackage *contentdeliverymanager*).installlocation + 'appxmanifest.xml' ; add-appxpackage -disabledevelopmentmode -register $manifest}"
方法二：
1、设置“个性化”锁屏界面“个性化锁屏界面切换到图片。
2、打开文件资源管理器，点击查看导航栏中的“显示”查看隐藏项。
3、打开c:用户你的用户appdatalocalpackagesmicrosoft.windows.contentdeliverymanager_xxxxxxxlocalstateassets 删除所有文件（历史聚焦图片）。
4、打开c:用户你的用户名appdatalocalpackagesmicrosoft.windows.contentdeliverymanager_xxxxxxxsettings 删除所有文件（若提示文件占用，个性化里切回windows聚焦再切图片）。
5、个性化锁屏界面切换回windows聚焦。
6、稍等片刻，然后按Win + L查看效果。
7、打开assets文件夹。如果有新文件，则更新成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5fbacf0228b1ad56b651843d2737ce5/" rel="bookmark">
			【YOLOV5-5.x 源码讲解】整体项目文件导航
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这个项目是github的开源项目，YOLOV5：https://github.com/ultralytics/yolov5，目前已经有14.1k个Star 和 4.9k 个Folk了，非常的火。下面我会给大家逐个的文件介绍这个项目中的所有代码，希望能帮到大家。
原本我下的2021年4月12日更新的v5.0版本，整个项目我做了一点点的文件位置的改变，也加了点自己在其他论文中学到的tricks。不过由于yolov5这个版本迭代的速度非常快，我这个代码也并不是和官网下载v5.0的那个版本就一模一样，而且我也参考了一些后面的版本代码，还是稍微改动了一些的，不过总体来说还是差不了太多的。下面我会按文件逐个函数的进行攻破，因为我本人也还是研一，肯定会有很多的不足，希望大家指正！！！
现在是2021-07-23，目标是在一个月内写完，也就是最迟2021-8-23日更完整个项目的所有的代码。
拖几天，还有3个文件！！！
写完了，断断续续写了35天，主要是最近比较忙，好在没拖到开学。希望对大家有些帮助！
注释版全部项目文件已上传至GitHub: yolov5-5.x-annotations.
有几个想法（最近找工作中，所以需要搁浅一段时间，后面会补上这个坑）
想在yolov5的基础上加一个分支进行分割任务yolov5 + Circular Smooth Label -&gt; 旋转目标检测yolov5剪枝轻量化 已实现：
YOLOv5 Head解耦： 【YOLOv5 Head解耦】yolov5+shufflenetv2轻量化【项目二、蜂巢检测项目】二、模型改进：YOLOv5s-ShuffleNetV2 一、导航 YOLOV5-U
data
hyp.scratch.yamlcoco128.yaml models
activations.pycommon.pyexperimental.pyyolo.pyexport.pyyolov5s.yaml utils
autoanchor.pydatasets.pygeneral.pygoogle_utils.pyloss.pymetrics.pyplots.pytorch_utils.py train.py
val(test).py
detect.py
二、尚存在的问题 AWS Inferentia？
不是很清楚这其中的原理 AWS Inferentia 和 正常的推理公式有什么区别？
更新：亚马逊的一个部署推理使用, 和整体的模型算法关系不大，一般用不太到，不用太关注。
non_max_suppression中的autolabelling是什么？这样子作不就导致最终mAP过高了吗？为什么这么做？
更新：已解决，在general.py的non_max_suppression函数中有详细解释！！！
计算损失函数置信度损失这一步时为什么要对置信度进行排序？？？排不排序效果不是一样的吗？
更新：已解决，在loss.py的ComputeLoss类中已经解释清楚！
Reference Github: https://github.com/ultralytics/yolov5.Github: https://github.com/Laughing-q/yolov5_annotations.BiliBili: yolov5讲解.BiliBili 霹雳吧啦Wz: yolov3讲解.BiliBili 人工智能打游戏系列课程1：基于深度学习的目标检测算法: yolov3讲解.CSDN Laughing-q: YOLOV5讲解.CSDN 幻灵H_Ling: YOLOv5源代码导读.CSDN 昌山小屋: YOLOV5讲解.CSDN 恩泽君: (yolo v3)使用自己数据集k-means聚类产生的anchor效果反而变差解决方法.CSDN TheOldManAndTheSea: 目标检测 YOLOv5 - Sample Assignment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5fbacf0228b1ad56b651843d2737ce5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b6242d5d97ab07a45c899b000ed920c/" rel="bookmark">
			Open Street Map介绍以及相关使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看不太懂，但感觉有用的东西。Openstreetmap 是什么？
用来入门（或者说先知道这是什么）简单的百度百科介绍
这个链接展示了如何下载一定格式的地图（shp、osm格式）。
OpenStreetMap开源地图数据下载方法（含shp格式）
那问题来了，shp和osm格式都是什么东西呀？
android中osm开发，也许没什么用的，但里边的链接还蛮多的OpenStreetMap初探（二）——osm的数据结构 用python解读osm数据：
xml方式 Python处理OpenStreetMap(OSM)数据似乎是什么提取交通网络，不是很需要。Python实现OSM地图数据解析——OSM2GMNSpython读取文件可视化,如何在Python中从OSM文件提取和可视化数据osm数据下载 python_用Python解锁处理OSM数据的全部姿势pyosmium doc 最后如何使用还是要看：
官方doc
osmium文档
先熟悉python的各个接口
osmium.osm.Node class示例：
osmium.osm.Way 示例：
In Osmium, ways can optionally also have a location for each node
reference. This will usually be empty but can be filled, for instance
using the NodeLocationsForWays handler (see below). This is very
convenient for many use cases.
看起来从way的WayNodeList找到的node 不太对，记录reference，再查下。直接拿会错。
目前只能通过ref，再次寻找地图点来确定位置。git源码就是这么做的。
但如果用了
h.apply_file("test.osm.pbf", locations=True, idx='dense_file_array,example.nodecache') 则也许location里是有内容的，待验证。
验证成功可以用。
osmium.osm.Relation 示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b6242d5d97ab07a45c899b000ed920c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b77641f47473138947b636ddb7dcf7a/" rel="bookmark">
			Python训练自定义损失函数与评价指标的XGBoost，并在Java环境调用模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. XGBoost自定义损失函数与评价指标（python） 在python中，有两种调用xgboost模型的方法，分别成为xgboost原生接口方法，和xgboost的sklearn接口方法。损失函数就是指目标函数，也就是深度学习中常说的loss目标，是一个可以优化的函数。评价指标是指在训练过程中关注的评价模型质量的指标，如f1、auc等。 以下以多分类问题为例，分别解释。
1.1 xgboost原生接口方法 该方法使用xgboost原生接口，一般使用形式为：
import xgboost as xgb dtrain = xgb.DMatrix(Train_data, label=Train_label) dval = xgb.DMatrix(Val_data, label=Val_label) params = {'booster': 'gbtree', 'num_class': 8, 'seed': 777, 'objective': 'multi:softprob', 'eta': 0.05, 'gamma': 0.1, 'min_child_weight': 3, 'max_depth': 5, 'lambda': 10, 'subsample': 0.8, 'colsample_bytree': 0.4, 'colsample_bylevel': 0.7, 'tree_method': 'exact' } watchlist = [(dtrain, 'train'), (dval, 'eval')] evals_result = {} xgboost_clf = xgb.train(params=params, dtrain=dtrain, num_boost_round=250, evals=watchlist, evals_result=evals_result) 1.1.1 自定义损失函数 xgboost原生接口的损失函数”objective“可以使用模型里面自带的。对于多分类问题来说，可以使用"multi:softmax"和“multi:prob"。前者输出标签，后者输出多分类概率。当需要自定义损失函数时，只需要将参数中的”objective“指定为自定义的损失函数名即可。举一个栗子：
def custom_loss(y_pred, dTrain): # 获取真实标签， 是一个一维的 y_true = dtrain.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b77641f47473138947b636ddb7dcf7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/240890a5bdd2e3c9502dee185fb93939/" rel="bookmark">
			GPIOB-＞CRH&amp;=0XFFFF0FFF；GPIOB-＞CRH|=(u32)8＜＜12；(学习笔记)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看原子哥的IIC.h文件看到这两个语句有点懵，去找了半天资料才懵懵懂懂，下面简单记录一下，以防下次又忘了
就拿这个举例把~，GPIO一组有（0-15）一共16个
前（0-7）是底8位，写成CRL
后（8-15）是高8位，所以就写成CRH
#define SDA_IN() {GPIOB-&gt;CRL&amp;=0X0FFFFFFF;GPIOB-&gt;CRL|=(u32)8&lt;&lt;28;}
8个F分别对应红圈圈的八个圈圈，有CNF0和M0DE0的圈圈对应着蓝色的F，依此对应。
GPIOB-&gt;CRL&amp;=0X0FFFFFFF这个语句的意思：把用到的B7端口清0；
#define SDA_IN() {GPIOB-&gt;CRL&amp;=0X0FFFFFFF;GPIOB-&gt;CRL|=(u32)8&lt;&lt;28;}
28的意思是：因为一个F是4个二进制位，第7位所以是7*4=28。
8的意思：就是1000，10的对应上拉/下拉模式，00对应输入模式。（下面的红圈圈）
原图：
新手笔记，不知道有没有错误，希望大佬指点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19551a96ba001b458dc5ecefd5e2c4bb/" rel="bookmark">
			@ConfigurationProperties在方法上的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天在看到SpringBoot配置Druid连接池的方法时产生了疑问，先上代码：
@Configuration public class MyDataSourceConfig { @ConfigurationProperties("spring.datasource") @Bean public DataSource dataSource(){ DruidDataSource druidDataSource = new DruidDataSource(); return druidDataSource; } } 可以看到，这边的@ConfigurationProperties放在了带有@Configuration的配置类的方法的上面。经过查看官网文档知道@ConfigurationProperties除了放在pojo类上以外，也可以在这种情况下使用。效果就是可以将返回的类内的属性进行赋值。但是在使用时需要注意：在正常的类上添加@ConfigurationProperties时需要将类上配置@Component，这会将类注册到Spring容器中，交由Spring管理，才能使的属性得到正常注入。但是在使用配置类的方法创建对象时，由于是配置类会将方法返回的对象注入容器，所以我们在创建类的时候不需要添加@Component。如果对类添加@Component的话，则会向容器中注入一个没有注入属性的对象。此时容器中有两个对象，分别是未注入属性值的对象和在配置类中返回的已经注入的对象。在调用@autowired时spring可能会选择该没有注入属性的对象。从而导致对象属性都为初始值。
正确的使用方法如下：
@Data public class Person { private String name; private int age; } @Configuration public class TestConfig { @Bean @ConfigurationProperties(prefix = "person") public Person injectData(){ return new Person(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5da175e04a3b83f12b6d426d14dc67da/" rel="bookmark">
			Restful接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Restful接口 一、非Rest设计，以往我们都会这么写：二、Rest架构：三、请求方式四、状态码 一、非Rest设计，以往我们都会这么写： http://localhost:8080/admin/getUser （查询用户）
http://localhost:8080/admin/addUser （新增用户）
http://localhost:8080/admin/updateUser （更新用户）
http://localhost:8080/admin/deleteUser （删除用户）
总结：以不同的URL（主要为使用动词）进行不同的操作。
二、Rest架构： GET http://localhost:8080/admin/user （查询用户）
POST http://localhost:8080/admin/user （新增用户）
PUT http://localhost:8080/admin/user （更新用户）
DELETE http://localhost:8080/admin/user （删除用户）
总结：URL只指定资源，以HTTP方法动词进行不同的操作。用HTTP STATUS/CODE定义操作结果。
三、请求方式 【GET】 /users # 查询用户信息列表
【GET】 /users/1001 # 查看某个用户信息
【POST】 /users # 新建用户信息
【PUT】 /users/1001 # 更新用户信息(全部字段)
【PATCH】 /users/1001 # 更新用户信息(部分字段)
【DELETE】 /users/1001 # 删除用户信息
【PATCH】一般不用，用【PUT】
四、状态码 分类分类描述1**信息，服务器收到请求，需要请求者继续执行操作2**成功，操作被成功接收并处理3**重定向，需要进一步的操作以完成请求4**客户端错误，请求包含语法错误或无法完成请求5**服务器错误，服务器在处理请求的过程中发生了错误 状态码状态码英文名称中文描述100Continue继续。客户端应继续其请求101Switching Protocols切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议200OK请求成功。一般用于GET与POST请求201Created已创建。成功请求并创建了新的资源202Accepted已接受。已经接受请求，但未处理完成203Non-Authoritative Information非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本204No Content无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档205Reset Content重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域206Partial Content部分内容。服务器成功处理了部分GET请求300Multiple Choices多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择301Moved Permanently永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替302Found临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI303See Other查看其它地址。与301类似。使用GET和POST请求查看304Not Modified未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源305Use Proxy使用代理。所请求的资源必须通过代理访问306Unused已经被废弃的HTTP状态码307Temporary Redirect临时重定向。与302类似。使用GET请求重定向400Bad Request客户端请求的语法错误，服务器无法理解401Unauthorized请求要求用户的身份认证402Payment Required保留，将来使用403Forbidden服务器理解请求客户端的请求，但是拒绝执行此请求404Not Found服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5da175e04a3b83f12b6d426d14dc67da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3510d2b2491de86df604226644ced6d/" rel="bookmark">
			OpenCV-针对不同分辨率的匹配操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对不同分辨率的匹配操作 项目要求OpenCV模板匹配模板匹配的工作方式模板匹配的匹配方式模板匹配存在的问题 解决方法方法1：直方图+自适应模板匹配结果 方法二：SIFT效果 方法三：灰度匹配+模板匹配结果和结论 项目要求 有一个需要，在UI自动化中，我们需要匹配某个元素在app中的位置，如何获取该元素的位置呢？一般可以通过Automation ID或者XPath，但是，有些控件或者元素，它无法通过这种方法定位，所以，我们把问题抽象成在一张图片中，框出目标元素的位置。
OpenCV模板匹配 模板匹配的工作方式 模板匹配的工作方式跟直方图的反向投影基本一样，大致过程是这样的：通过在输入图像上滑动图像块对实际的图像块和输入图像进行匹配。
假设我们有一张100x100的输入图像，有一张10x10的模板图像，查找的过程是这样的：
（1）从输入图像的左上角(0,0)开始，切割一块(0,0)至(10,10)的临时图像；
（2）用临时图像和模板图像进行对比，对比结果记为c；
（3）对比结果c，就是结果图像(0,0)处的像素值；
（4）切割输入图像从(0,1)至(10,11)的临时图像，对比，并记录到结果图像；
（5）重复（1）～（4）步直到输入图像的右下角。
大家可以看到，直方图反向投影对比的是直方图，而模板匹配对比的是图像的像素值；模板匹配比直方图反向投影速度要快一些，但是我个人认为直方图反向投影的鲁棒性会更好。
模板匹配的匹配方式 在OpenCv和EmguCv中支持以下6种对比方式： CV_TM_SQDIFF 平方差匹配法：该方法采用平方差来进行匹配；最好的匹配值为0；匹配越差，匹配值越大。 CV_TM_CCORR 相关匹配法：该方法采用乘法操作；数值越大表明匹配程度越好。 CV_TM_CCOEFF 相关系数匹配法：1表示完美的匹配；-1表示最差的匹配。 CV_TM_SQDIFF_NORMED 归一化平方差匹配法 CV_TM_CCORR_NORMED 归一化相关匹配法 CV_TM_CCOEFF_NORMED 归一化相关系数匹配法 根据我的测试结果来看，上述几种匹配方式需要的计算时间比较接近（跟《学习OpenCV》书上说的不同），我们可以选择一个能适应场景的匹配方式。
模板匹配存在的问题 1.对于分辨率不同的图片，它无法正常匹配。在实际的任务中，我们的模板图片可能发生分辨率的改变。
2.对于些许形变的图片，它也无法正常匹配。
3.截图内容无法匹配。
原图：
传统匹配结果：
关于自适应屏幕显示：
#include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; using namespace cv; using namespace std; void Show_Picture() { Mat src = imread("C:/Users/wenhaofu/Desktop/Multi-Scale-Template-Matching-master/test3.png"); if (src.empty()) { printf("could not load image...\n"); return; } namedWindow("input", WINDOW_NORMAL); imshow("input", src); waitKey(0); return; } int main(int artc, char** argv) { Show_Picture(); return 0; } 但是为了完整得显示图片，多次尝试发现，flag参数为WINDOW_NORMAL时才可以在手动调整窗口的条件下显示完整的图片。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3510d2b2491de86df604226644ced6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7fd6458c83185debdf4c543d066a198/" rel="bookmark">
			【数据结构与算法】删除线性表中的零元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 删除顺序结构线性表中的零元素，不改变原表的顺序。
input： 10,2,0,0,5,7,0,4,0,0 output: 10,2,5,7,4 解决 解法一
发现一个零元素，就删除一个。将后面的元素前移，数组长度减一。
解法二
开始：设置两个指针变量，储存数组的下标。
在遍历数组过程中，让左指针指向非零元素后出现的第一个零元素，右指针指向零元素后出现的第一个非零元素。
达成条件后，交换左右指针所指元素，左指针右移一位。
交换完毕后继续遍历，直到数组右侧全是零元素。
结束：此时左指针指向第一位零元素，只需要将数组的长度设置为左指针减一即可。
解法三
遍历数组，当出现零元素的时候，用一个变量k记录数组中为零元素的长度，碰见非零元素的时候，让非零元素前移k个位置。
直到数组遍历完毕。将数组的长度设置为原长减k即可。
吐槽： 解法三我在看的时候，还以为会漏掉元素，或者，受前一个用交换的解法惯性影响担心：用前移的办法，后面的非零元素没有改变，会影响到下一次 “交换” 操作。但是这个解法没有用上交换，而是在前移的过程中直接覆盖掉前面遗留下来的元素。这其实很好理解，由零元素长度形成的一个不断增长的挡板将判断过的非零元素覆盖掉，因而不用改变后面的非零元素，最后挡板移到数组末尾，问题解决。 延伸 这类问题可以理解为在遍历线性表时，记录下满足条件的元素个数k（可以是x—y范围内的元素个数），对于不满足条件（x—y范围外的元素），前移k个位置，最后修改线性表的长度。
对于原题，这个条件范围缩小到等于0，非零元素前移。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6114f795d3fc07438b74326f36497b/" rel="bookmark">
			超声波模块工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超声波测距模块工作原理 （1）采用IO口TRIG触发测距，给至少10us的高电平信号; （2）模块自动发送8个40khz的方波，自动检测是否有信号返回； （3）有信号返回，通过IO口ECHO输出一个高电平，高电平持续的时间就是超声波从发射到返回的时间。测试距离=（高电平时间*声速（340M/S））/2;
（4）本模块使用方法简单，一个控制口发一个10US以上的高电平，就可以在接收口等待高电平输出。一有输出就可以开定时器计时，当此口变为低电平时就可以读定时器的值，此时就为此次测距的时间，方可算出距离。如此不断的周期测，即可以达到你移动测量的值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/476cc15a9a3c49456db7d41a6261eee5/" rel="bookmark">
			提高国内访问 github 速度的方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. GitHub 文件加速 利用 Cloudflare Workers 对 github release 、archive 以及项目文件进行加速，部署无需服务器且自带CDN.
https://gh.api.99988866.xyz
以上网站为演示站点，如无法打开可以查看开源项目：gh-proxy-GitHub(https://hunsh.net/archives/23/) 文件加速自行部署。
2. Github 加速下载 只需要复制当前 GitHub 地址粘贴到输入框中就可以代理加速下载！
地址：http://toolwa.com/github/
3. 加速你的 Github https://github.zhlh6.cn
输入 Github 仓库地址，使用生成的地址进行 git ssh 等操作
4. 谷歌浏览器 GitHub 加速插件(推荐) 如果小伙伴在线安装不便，可以在公众号后台回复 github加速。
5. GitHub raw 加速 GitHub raw 域名并非 github.com 而是 raw.githubusercontent.com，上方的 GitHub 加速如果不能加速这个域名，那么可以使用 Static CDN 提供的反代服务。
将 raw.githubusercontent.com 替换为 raw.staticdn.net 即可加速。
6. GitHub + Jsdelivr jsdelivr 唯一美中不足的就是它不能获取 exe 文件以及 Release 处附加的 exe 和 dmg 文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/476cc15a9a3c49456db7d41a6261eee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a21a01be3588c67e7bb716eef808e9d/" rel="bookmark">
			小知识点系列-基于H2数据库单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 单元测试（Unit Test），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般情况下是一个方法或是一段逻辑，使用单元测试可以在不启动整体程序而进行局部逻辑和用例测试，提前在开发过程中发现问题，降低问题在生产环境发生的可能。 对于业务逻辑层一般情况下是通过mock外部的接口和DAO层的接口，而针对DAO层的逻辑多数情况要么不进行单元测试或是直接连接线下DB进行测试。如果线下数据库不稳定或是数据存在变化的情况下将会导致测试用例不能每次都跑通过，进而对研发效率造成影响，本文重点介绍通过内存数据库来实现轻量级别的DAO测试的技术方案。
1. 内存数据库是什么 内存数据库依赖于系统内存而不是磁盘数据存储空间。因为内存访问比磁盘访问快。当我们不需要持久化数据时，我们使用内存数据库。内存数据库是嵌入式数据库。默认情况下，内存数据库是易失性的，当我们重新启动应用程序时，所有存储的数据都会丢失。广泛使用的内存数据库是 H2数据库，基于内存数据库H2比较广泛的实践则为单元测试的持久层的解决方案
2. H2数据源初始化 通过SpringBoot配置类Configuration进行相关数据源初始化，与传统数据库DataSource一样，需要配置数据源相关的配置，相关参数参考如下，除此之外与普通数据源不同的在于需要增加一个内存数据库创建的Bean，用于在启动时生成H2数据库，对应的Bean为DataSourceInitializer。
@Configuration public class H2DbConfig { @Bean public DataSource dataSource() { SimpleDriverDataSource simpleDriverDataSource = new SimpleDriverDataSource(); simpleDriverDataSource.setDriverClass(org.h2.Driver.class); simpleDriverDataSource.setUrl("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;MODE=MySQL"); simpleDriverDataSource.setUsername("test"); simpleDriverDataSource.setPassword(""); DataSource dataSource = simpleDriverDataSource; return dataSource; } @Bean public DataSourceInitializer dataSourceInitializer(DataSource dataSource) { DataSourceInitializer initializer = new DataSourceInitializer(); initializer.setDataSource(dataSource); ResourceDatabasePopulator resourceDatabasePopulator = new ResourceDatabasePopulator(); resourceDatabasePopulator.addScript(new ClassPathResource("h2/sql/schema.sql")); resourceDatabasePopulator.setContinueOnError(Boolean.TRUE); resourceDatabasePopulator.setIgnoreFailedDrops(Boolean.TRUE); initializer.setDatabasePopulator(resourceDatabasePopulator); return initializer; } } 3. H2数据库结构定义 上面在定义H2数据库时指定了表结构的配置文件在ClassPath下的h2/sql/schema.sql下，通过schema我们定义我们DAO测试所需要的表结构，可以直接通过MySQL导出建表语句。
drop table if exists user; create table user ( id INT AUTO_INCREMENT PRIMARY KEY, first_name VARCHAR(250) NOT NULL, last_name VARCHAR(250) NOT NULL, email VARCHAR(250) DEFAULT NULL ); 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a21a01be3588c67e7bb716eef808e9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/258064865297244b51c86f5cc8e98cc1/" rel="bookmark">
			【数据集处理】读取.pkl文件，转换为csv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题： 数据集原来的编码encoding格式未知，只有一个.pkl文件用.txt格式查看数据太乱了，所以想将.pkl转换为.csv文件来看，同时也方便后续行列处理。现在需要将其转变为易处理的csv文件。
代码如下： import pickle as pkl import pandas as pd with open(r'PATH', "rb") as f: object = pkl.load(f,encoding='latin1') df = pd.DataFrame(object) df.to_csv(r'newPATH.csv') 注意：object =pkl.load(f,encoding='latin1')容易在encoding处报错，可以根据实际pkl的编码规则更改为encoding='utf-8'
完成文件类型转换之后，查看csv文件每一行的大小
import pandas as pd df = pd.read_csv('newcsv.csv') # 下面是console里面查看句子长度 len(df.iloc[7]) # 查看第8个对话里话语的数量 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b935ad58b761aa6c656758f2cccb136c/" rel="bookmark">
			java修改Excel文件内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地版 背景:将一个excel中第三列的数据提取出中文,并填写到第四列中
参考代码如下:
try { //文件路径 String filePath = "C:\\Users\\admin\\Desktop\\test.xlsx"; FileInputStream inputStream = new FileInputStream(filePath); ExcelReader reader = ExcelUtil.getReader(inputStream); Workbook workbook = reader.getWorkbook(); Sheet sheetAt = workbook.getSheetAt(0); //获取总行数 int lastRowNum = sheetAt.getLastRowNum(); logger.info("文件总行数:{}", lastRowNum); //遍历所有行:从第2列开始,第1列是标题 for (int i = 1; i &lt; lastRowNum; i++) { Row row = sheetAt.getRow(i); if (Objects.isNull(row)) continue; //获取第3列数据 Cell cell = row.getCell(2); String str = cell.getStringCellValue(); logger.info("文本内容:{}", str); //提取文本的中文 String str2 = str.replaceAll("[^\u4E00-\u9FA5]", ""); logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b935ad58b761aa6c656758f2cccb136c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0675ac2ee1251b88aa7c35d41825637a/" rel="bookmark">
			Win11新Bug任务栏图标不显示的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期有部分用户刚更新完Win11系统，就遇到了任务栏图标不显示的问题，导致出现这一情况的原因在于Windows 11系统的IRIS服务，这个服务疑似与Windows聚焦等功能有关，那么应该如何解决呢？
这里有系统安装的方法可以看看
解决方法如下：
1、首先，按键盘上的【 Win + X 】组合键，或右键点击任务栏上的【Windows开始徽标】，在打开的右键菜单项中，选择【Windows 终端 （管理员）】；
2、打开【管理员： Windows PowerShell】窗口，①位置点击【下拉箭头】，②位置【按住 Ctrl 并单击以管理员身份打开】命令提示符；
3、这就可以打开【管理员： 命令提示符】窗口；
4、管理员： 命令提示符窗口，输入以下命令：
reg delete HKCUSOFTWAREMicrosoftWindowsCurrentVersionIrisService /f &amp;&amp; shutdown -r -t 0
输入该命令后，系统会自动重启。
该命令会删除IRIS服务的注册表值，从而解决问题。
近期有部分用户刚更新完Win11系统，就遇到了任务栏图标不显示的问题，导致出现这一情况的原因在于Windows 11系统的IRIS服务，这个服务疑似与Windows聚焦等功能有关，那么应该如何解决呢？
这里有系统安装的方法可以看看
解决方法如下：
1、首先，按键盘上的【 Win + X 】组合键，或右键点击任务栏上的【Windows开始徽标】，在打开的右键菜单项中，选择【Windows 终端 （管理员）】；
2、打开【管理员： Windows PowerShell】窗口，①位置点击【下拉箭头】，②位置【按住 Ctrl 并单击以管理员身份打开】命令提示符；
3、这就可以打开【管理员： 命令提示符】窗口；
4、管理员： 命令提示符窗口，输入以下命令：
reg delete HKCUSOFTWAREMicrosoftWindowsCurrentVersionIrisService /f &amp;&amp; shutdown -r -t 0
输入该命令后，系统会自动重启。
该命令会删除IRIS服务的注册表值，从而解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0e21eddfa03e1b4ff49f5d6a5fa0e65/" rel="bookmark">
			百度OCR识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已知痛点 在web页面登录的时候，很多小伙伴都会遇到这个问题，登录的时候，需要输入图片中的验证码，验证通过之后才登录成功；往往一些操作，都是需要登录之后才能往下操作，这对我们进行接口测试(接口自动化、UI自动化)产生了极大的困扰
痛点解决方案 测试环境无所谓，直接叫开发改成万能验证码，或者测试环境关闭验证码验证使用Python OCR库进行识别，如tesserocr使用第三方 OCR服务(api)，例如阿里云，百度云，腾讯云 方案分析 改一下代码或者配置文件即可屏蔽验证码，测试环境无所谓，线上根本不行！此方案可作为备用方案通过tesserocr库去识别验证码，前期需要我们学习一下这个库相关的api，未知领域探索，可能需要花较长时间~此方案作为备用方案调用第三方OCR服务，通常都会完善的API文档或者对应的SDK，第三方OCR识别成功率还可以，此方案推荐！ 方案选择 我这边选择了方案3，第三方 OCR服务(百度云)，最主要是集成SDK，下载SDK即可调用，而且还是免费，可以白嫖，每个月有一定的免费次数，足够你使用了！用这高大上的第三方OCR服务，领导听了之后，马上说牛逼！还能给你加KPI(手动狗头)，虽然每个月拿着A还会扣钱，但是为了不被扣那么多嘛，必须得用！ 推荐推荐推荐！
方案实现过程(rap2登录) rap2登录时要输入验证码，我们通过百度OCR识别这个验证码，通过请求登录接口(账号+密码+验证码)模拟前端向后台发起请求，获取登录态后，再获取接口文档数据
OCR服务申请 百度智能云地址：login.bce.baidu.com/
首先我们去到百度智能云里，在左边菜单栏的产品服务中搜索"文字识别"，点击【领取免费资源】，将所有的免费资源领取，领取之后要半个小时之后才能生效。
回到主面板，我们要进行创建应用，填写相关的信息即可创建成功，应用创建好之后会生成AppID、API Key和Secret Key，注意这3项不要告诉别人哦！
阅读官方文档 文字识别官方文档：cloud.baidu.com/doc/OCR/ind…
点击应用名称，查看该应用详情，里面有个查看文档，我们先可以看看是怎么用的里面有两种方式，一种是API，另一种是SDK 识别demo 先来识别这张图片试试
看了一下官方的SDK demo，少量代码即可实现识别功能 先通过pip install baidu-aip下载SDK 按照官方demo测试一下
config = random.choice(OCR_CONFIG) client = AipOcr(config['app_id'],config['api_key'],config['secret_key']) options = {} options["language_type"] = "ENG" options["detect_language"] = "true" with open(f"{IMG_PATH}/code.jpg", 'rb') as img: #调用百度OCR SDK，这里我用的高精度版，通过传入图像数据 #你也可以用这个方法basicGeneralUrl，直接传入图片url code_data = client.basicAccurate(img.read()) print(code_data) 打印输出:{'words_result': [{'words': ' HdAX'}], 'log_id': 1421303125069946686, 'words_result_num': 1} 这里有几个踩坑点，要注意下
image，图像数据，base64编码，base64编码后大小不超过4M，最短边至少15px，最长边最大4096px,支持jpg/png/bmp格式url，图片完整URL，URL长度不超过1024字节，URL对应的图片base64编码后大小不超过4M，最短边至少15px，最长边最大4096px,支持jpg/png/bmp格式识别回来的验证码有可能跟图片的验证码不一致有可能无法识别，接口直接返回空数据有可能返回来的验证码结果是带有空格的 rap2登录实战 首先我们去到登录页面，用F12看看验证码是怎么生成的，发现验证码是通过一个图片url随机生成的。那我们直接使用这个方法basicGeneralUrl，直接传入图片url试试，发现跟本调不通，出现报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0e21eddfa03e1b4ff49f5d6a5fa0e65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82b08c02c49b20f551e3d49f42d64459/" rel="bookmark">
			第62篇：批量去除EXCEL文件密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sub 清除密码()
Excel.Application.ScreenUpdating = False
arr = Sheet1.UsedRange.Value
For 行号 = 2 To UBound(arr)
文件 = "此处写文件路径 以\结尾" &amp; arr(行号, 1) &amp; ".xlsx"
Set w1 = Workbooks.Open(文件, Password:=arr(行号, 2))
w1.Password = ""
w1.Save
w1.Close
Next
Excel.Application.ScreenUpdating = True
End Sub
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5703d76e772f35b387af820fe19cef03/" rel="bookmark">
			第61篇：合并多个工作薄的所有工作表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sub 工作薄间工作表合并()
Dim FileOpen
Dim X As Integer
Application.ScreenUpdating = False
FileOpen = Application.GetOpenFilename(FileFilter:="Microsoft Excel文件(*.xlsx),*.xlsx", MultiSelect:=True, Title:="合并工作薄")
X = 1
While X &lt;= UBound(FileOpen)
Workbooks.Open Filename:=FileOpen(X)
Sheets().Move After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count)
X = X + 1
Wend
ExitHandler:
Application.ScreenUpdating = True
Exit Sub
errhadler:
MsgBox Err.Description
End Sub
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b86167a66f727a61ae10e3efe9f2ecf/" rel="bookmark">
			如何利用Matlab对指定条件下的excel单元格填充颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用Matlab对指定条件下的excel单元格填充颜色 1. 主要思路为matlab建立服务端并结合Excel的Worksheets.Item property对单元格颜色进行填充,主体代码如下： rgb = [255 0 0]; e = actxserver('Excel.Application');%这里是建立服务端（'Excel.Application'是指excel的服务端，和上面打开表格不重复不矛盾） ewb = e.Workbooks.Open("C:\Users\吴宇航\Desktop\新建文件夹\8月份日排产-成品.xls"); ewb.Worksheets.Item(1).Range(poistion).Interior.Color =rgb*256.^(0:2)';%红色 ewb.Save; ewb.Close(false); e.Quit; e.delete; 该代码是matlab建立服务端后对指定路径的excel文件按照指定位置将单元格颜色填充为红色，其中positon是代指单元格的位置例如：A1、B2，因此关键性问题是如何得到单元格位置 2.我们需要令满足条件的excel表格填充颜色，因此需要用到for循环，循环行数与列数对相应位置的数值值进行判断，在满足我们的条件时，获得excel的行数和列数，并将列数由数值转换为A、B、C…,将行数由数值转换为字符’1’、‘2’,并用strcat(列,行)进行拼接，得到’A1’、‘B2’…，即可得到position 3.利用上述思路对指定条件下的excel单元格填充颜色 （1）此时需要用到两个自定义函数，第一个函数如下： function str=letter2char(num) s=num+64; str=char(s);%因为char(65)=A end 上述自定义函数可以实现由1转化为A，第二个自定义函数如下： function s=lettertoxls(Integer0)%matlab中的函数定义 if (Integer0&lt;=26) %若只有单个字母 s=letter2char(Integer0); %转化成字母 elseif(Integer0&lt;=702 &amp;&amp; Integer0&gt;26)%不止单个字母，比如AA，BF等。702刚好到两位的最后一个列号：ZZ Integer1 = fix(Integer0/26);%取商 if mod(Integer0,26)==0 Integer1 = fix(Integer0/26)-1;%避免出现从AY直接到BZ的现象 end while(Integer0&gt;26) Integer0=Integer0-26; end a=letter2char(Integer1); b=letter2char(Integer0); s=strcat(a,b); end end 该函数考虑了列数可能出现两个字母同时出现的可能，例如：AA、AB… （2）主函数如下，导入数据后，根据自己的excel数据循环行数和列数（注意matlab中数据的行数和列数的位置可能与excel中数据的行数与列数的位置不对应），在满足条件时，输出该数据对应的位置，再利用matlab建立服务端，结合Excel的Worksheets.Item property对相应位置的单元格进行填充，实现效果如图所示 clear; [data,str]=xlsread("C:\Users\吴宇航\Desktop\新建文件夹\8月份日排产-成品.xls");%这里打开是为了在表格中筛选符合条件的数据 e = actxserver('Excel.Application');%这里是建立服务端（'Excel.Application'是指excel的服务端，和上面打开表格不重复不矛盾） ewb = e.Workbooks.Open("C:\Users\吴宇航\Desktop\新建文件夹\8月份日排产-成品.xls"); rgb = [255 0 0]; for i=1:66 %数据寻找范围 for j=1:25 %数据寻找范围(注意不能超过一开始读入的范围） if mod(i,2)==0&amp;&amp;(data(i,j)&gt;0) str2=int2str(i+1);%int to str行数当作字符 lie=lettertoxls(j+3);%列转换成ABC这样子 poistion=strcat(lie,str2);%字符串连接函数，[列，行]，如A1单元格，这里只能用strcat拼接，若果用[]拼接，形成的是str类型，不适用于下文Range中参数类型，而strcat拼接出来的是cell。 ewb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b86167a66f727a61ae10e3efe9f2ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/577ae6b83302b221ae9a2dc8dd041c78/" rel="bookmark">
			el-tree 搜索匹配结果高亮、关键字高亮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景 最近项目中用到了el-tree组件，根据产品的需求，需要做el-tree的关键词过滤功能，并且需要命中的关键字高亮显示，在这里记录一下实现的过程。
话不多说，先上效果图：
左侧是搜索命中结果高亮，右侧是命中的关键词高亮。
2、实现 看了上面的效果图，下面针对上面的两种情况分别进行实现。
2.1、命中的结果高亮 命中的结果高亮如上的效果图左侧部分，具体的实现代码如下：
1）结构代码
&lt;!-- 匹配结果高亮 --&gt; &lt;div class="content-item"&gt; &lt;el-input style="width:200px" v-model="filterText" placeholder="搜索" prefix-icon="el-icon-search" clearable&gt; &lt;/el-input&gt; &lt;el-tree style="width:200px" ref="tree" node-key="gid" :data="userDatas" :filter-node-method="filterNode" :default-expand-all="true"&gt; &lt;span class="custom-tree-node" slot-scope="{ node }"&gt; &lt;span :class="node.text"&gt;{{node.label}}&lt;/span&gt; &lt;/span&gt; &lt;/el-tree&gt; &lt;/div&gt; 主要就包括了一个 el-input 和 el-tree 组件
关键点：
第一、使用了 el-tree 组件自带的 filter-node-method 属性，描述如下：
对树节点进行筛选时执行的方法，返回 true 表示这个节点可以显示，返回 false 则表示这个节点会被隐藏Function(value, data, node) 官网地址：Element - The world's most popular Vue UI framework
第二、使用了 slot-scope 自定义树节点的内容，参数为 { node, data }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/577ae6b83302b221ae9a2dc8dd041c78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1345756c309a952a864bb472f0c19be1/" rel="bookmark">
			Win7 Win10系统下在右下角的usb设备中显示了SATA硬盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win7 Win10系统下在右下角的usb设备中显示了SATA硬盘，可以手动退出SATA硬盘，正常应该是只显示USB磁盘。
这种情况是新的主板芯片中支持了磁盘的热插拔功能，所以会将SATA硬盘也显示在usb设备中，解决办法是进入主板bios，找到以下类似的设置关闭热拔插功能即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68ebcbf4a98dc3e34b93a862bcafecc0/" rel="bookmark">
			解决Mybatis-Plus批量插入数据太慢，堪称神速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决Mybatis-Plus批量插入数据太慢，堪称神速 前言`rewriteBatchedStatements`参数普通saveBatch在数据库的连接加上rewriteBatchedStatements=true的属性 前言 用过Mybatis-Plus的小伙伴一定知道他有很多API提供给我们使用，真爽，再不用写那么多繁琐的SQL语句，saveBatch是Plus的批量插入函数，大家平时工作肯定都用过，下面我们就来一个案例进入今天的主题。
rewriteBatchedStatements参数 MySQL的JDBC连接的url中要加rewriteBatchedStatements参数，并保证5.1.13以上版本的驱动，才能实现高性能的批量插入。MySQL JDBC驱动在默认情况下会无视executeBatch()语句，把我们期望批量执行的一组sql语句拆散，一条一条地发给MySQL数据库，批量插入实际上是单条插入，直接造成较低的性能。只有把rewriteBatchedStatements参数置为true, 驱动才会帮你批量执行SQL，另外这个选项对INSERT/UPDATE/DELETE都有效
添加rewriteBatchedStatements=true这个参数后的执行速度比较
普通saveBatch 普通的saveBatch()：从底层源码来讲其实也是一个一个循环插入的
public boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize) { String sqlStatement = this.sqlStatement(SqlMethod.INSERT_ONE); int size = entityList.size(); this.executeBatch((sqlSession) -&gt; { int i = 1; for(Iterator var6 = entityList.iterator(); var6.hasNext(); ++i) { T entity = var6.next(); sqlSession.insert(sqlStatement, entity); if (i % batchSize == 0 || i == size) { sqlSession.flushStatements(); } } }); return true; } 在数据库的连接加上rewriteBatchedStatements=true的属性 jdbc:mysql://rm-bp1k3mk95rn1c17ammo.mysql.rds.aliyuncs.com:3306/wmmall?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;rewriteBatchedStatements=true 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b0902774acd2db1dbf699cd7843e54a/" rel="bookmark">
			解决Error L6218E Undefined symbol XXX....问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一个keil的错误编译提示以及其问题解决方法，当我们碰到"Error L6218E Undefined symbol XXX…"这个错误提示，其实出现这问题的原因就是我们调用了没有定义的函数，就比如你把一个函数定义注释了，然后却在程序调用了它，那编译时候就会提示你出现位定义的符号。
所以解决方法是可以看一下提示错误的那个函数或者变量是否未定义或声明。
当然也有人说，调用的函数的参数跟函数本身参数不一致也会出现这种错误提示，但是个人认为这种应该会提示调用参数个数不一致。不过大家也可以去找找看，看看参数不一致是否也会弹出L6218E这种错误提示。
本人水平有限，上述信息仅供参考，如有错误和不妥之处，请多多指教。
另外创作不易，请勿抄袭，如果有帮助到大家的话希望大家可以点个赞，谢谢~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4457045816be8f11067750e6002c8f4d/" rel="bookmark">
			朴素贝叶斯算法（初学者实例入门）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《老饼讲解机器学习》--一个优质的机器学习网站http://ml.bbbdata.com/teach#196
目录
一、算法介绍
二、贝叶斯概率公式与判别函数
(一) 贝叶斯原理
(二) 属于各类别的概率计算公式
(三) 判别函数
(四) 概率的实际估算
三.例子讲解
四、模型存储
五、概念补充
(一) 贝叶斯原理、贝叶斯分类器与朴素贝叶斯的区别
(二)先验概率、后验概率、信息证据
本文讲解朴素贝叶斯模型的原理，使用例子，以及线上使用。
一、算法介绍 朴素贝叶斯是基于贝叶斯后验概率建立的模型，它用于解决分类问题。
它的主要思想是，通过历史数据，对每个类别建立经验概率公式，然后当新样本进来时，用各个类别的概率经验公式分别进行预测，最终，属于哪个类别的概率最大，就认为是哪个类别。
注：为了简化，我们不一定用概率公式p(x)，也可以使用它的简化版g(x)替代它。
二、贝叶斯概率公式与判别函数 模型的关键是如何用历史数据构建类别的概率公式，贝叶斯原理恰好可以解决这个问题。
(一) 贝叶斯原理 贝叶斯原理为，在已知发生B条件下,发生A的概率为:
备注：贝叶斯原理可以理解为： ﻿ P(B)⋅P(A∣B)﻿ = P(B∣A)⋅P(A)﻿， 即： 发生B,且发生A = 发生A且发生B
(二) 属于各类别的概率计算公式 根据贝叶斯原理可以得到，在已知表现特征，属于类别 i 的概率则为：
如果各特征间是独立的，那特征的概率可以拆成累积形式，上式可以写成：
(三) 判别函数 因为每个分母一样，所以我们最终每个类别的决策器只取上式的分子即可，如下
此时，G代表的就不再是概率，而是判别值，称Gi为第i类别的判别函数。
(四) 概率的实际估算 ﻿上式各个P的计算用历史样本估算，如下
P(表现为特征Xk|已知属于类别 i) = 类别 i 中特征k为﻿ 的样本个数/ 类别 i 样本个数
P(属于类别 i ) = 类 i 在总本样中的占比
P(表现为特征) = 特征k等于的占比
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4457045816be8f11067750e6002c8f4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0788e990b411d452367040a64e772d8/" rel="bookmark">
			【C&#43;&#43;】之引用详解 什么是引用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引用的概念
二、 引用特性
三、 常引用
四、 引用的使用场景
4.1 做参数
4.2 做返回值(传引用返回)
五、传值、传引用效率比较
5.1 函数传值与传引用
5.2 值与引用作为函数返回值
六、 引用和指针的区别
引用和指针的不同点
一、引用的概念 引用不是新定义一个变量，而是给已存在的变量取一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。
类型 &amp; 引用变量名 (对象名) = 引用实体
多的不说，我们来举个例子
注意： 引用类型必须和引用实体是同种类型的！
二、 引用特性 引用在定义时必须初始化一个变量可以有多个引用引用一旦引用一个实体，再不能引用其他实体(不能更改) void TestRef() { int a = 10; // int&amp; ra; // 该条语句编译时会出错 int&amp; ra = a; int&amp; rra = a; printf("%p %p %p\n", &amp;a, &amp;ra, &amp;rra); } 三、 常引用 加了 const 该变量是不能修改的，即成了一种常量，可以理解为只读型，而没加 const 的可理解为可读可写型。
//权限的平移 --- 两者都是可读可写型 int a = 10; int &amp; b = a; 权限放大：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0788e990b411d452367040a64e772d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0e647786be6b95b9c54bb27a812648c/" rel="bookmark">
			SecureCRT键盘无法输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SecureCRT键盘无法输入，怎么办？？？ 将RTS/CTS选项剔除掉。。。即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ff7426b9f495b449398f47d53dec8d/" rel="bookmark">
			vue监控url地址栏的变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		watch:{
$route:{
immediate:true, //url不发生变化，也可以执行的
handler(newVal,oldVal){
//该函数会执行 }
}
}
只要是挂载在vue原型对象(prototype)的属性，都可以使用这种方法监视的;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4ab6819f5ec8abce3a23343c67f889f/" rel="bookmark">
			Typora 0.11.xx版本无法使用的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Typora 0.11.xx版本提示 This beta version of Typora is expired, please download and install a newer version 解决方法 原因
在某个日期之后 Typora 会检查日期然后提示如题信息。解决方法 网上已知的通过改日期2021及以前即可正常使用；但是由于部分限制(公司电脑不能手动更改日期)导致第一种方式不能实现，且较为麻烦，故可通过下面链接下载一个 app.asar 文件 替换 C:\Program Files\Typora\resources\app.asar 就可以正常使用typora了。
链接：Typora app.asar 下载 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550d28ec98aac70a30ce555ecdddb05f/" rel="bookmark">
			linux mysql 5.7 离线安装（tar.gz）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 服务器环境：centos7.3 x64
mysql版本：5.7.28
***需要卸载的话看这个：https://blog.csdn.net/shuai8624/article/details/103665983
GO 1. 官网下载压缩包 链接： https://dev.mysql.com/downloads/mysql/
选择linux通用64位，5.7.28
2. 查询并卸载系统自带的Mariadb rpm -qa | grep mariadb rpm -e --nodeps 文件名 3. 将压缩包放入服务器安装目录下（/usr/local），解压，重命名为mysql #解压命令 tar -xzvf mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz #重命名 mv mysql-5.7.28-linux-glibc2.12-x86_64 mysql 4. 检测mysql用户和mysql用户组是否存在，不存在则创建 #检测是否存在，如无则创建 cat /etc/group | grep mysql cat /etc/passwd | grep mysql *若存在请忽略创建
#创建mysql用户组 groupadd mysql #创建一个用户名为mysql的用户，并加入mysql用户组 useradd -g mysql mysql #修改mysql用户的登陆密码（不少于8位） passwd mysql 5. 修改mysql文件夹下所有文件的用户和用户组 chown -R mysql:mysql mysql/ 6. 创建mysql配置文件 my.cnf（位置/etc下面） cd /etc vi my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/550d28ec98aac70a30ce555ecdddb05f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53c6efce296201da6f3c799133d281a0/" rel="bookmark">
			《数据结构》邓俊辉 网课习题详细解析（第五章：二叉树）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 （a）树（b）树的表示（c）二叉树（e1）先序遍历（e2）中序遍历（e4）层次遍历（e5）重构 （a）树 1.下列那种数据结构可以高效地兼顾静态操作和动态操作（D）
A.array数组
B.vector向量
C.list列表
D.tree树
解析：数组可以被视为一种简单的向量。向量的静态操作效率高而动态操作效率低；列表的动态操作效率高而静态操作效率低。树能够兼顾静态操作和动态操作的高效性。
2.n个顶点的树有多少条边？（B）
A.n
B.n-1
C.n²
D.2的n次方
解析：树的性质之一就是边数=顶点数-1。
3.树是（C）
A.有向连通图
B.无环平面图
C.连通无环图
D.有向无环图
解析：树是一种特殊的图。树是一种连通无环图、极大无环图、极小连通图。
4.在一棵树中，顶点p是顶点v的父亲，则它们的高度关系是（A）
A.height v &lt;height p
B.height v =height p -1
C.height v =height p +1
D.height p &lt;height v
解析：由于p是v的父亲，因此p的高度一定比v要大，但是具体的大小关系不能确定，只有在顶点v所在的子树刚好对应顶点p最大高度的子树时，才能有B选项成立。
（b）树的表示 1.用父节点+孩子节点的方法存储n个结点的树，需要的空间是（B）
A.O(1)
B.O(n)
C.O(nlgn)
D.O(n²)
解析：父亲孩子表示法中，每个结点存储的内容包括：自身的秩、自身的数据、父节点的秩、孩子链表。因此总共需要的存储空间线性正比于结点的个数。
2.
以上图中的树在计算机中表示如下，则第三行中parent[]的内容应该是（B）
A.0,5,-1,7,0,5,4,7,0,7
B.-1,5,5,7,0,4,5,0,0,7
C.0,1,2,3,4,5,6,7,8,9
D.-1,7,5,2,5,4,1,-1,0,7
解析：parent[]中存放的是父节点的秩，因此只需要找到每一个结点的父节点记录其秩即可。根节点的父节点秩记录为-1。
（c）二叉树 1.高度为h的满二叉树有多少个节点（A）
A.2的(h+1)次方-1
B.2的(h+1)次方
C.2的h次方-1
D.2的h次方
解析：高度为h的满二叉树在每一层上分别有1、2、4…2的h次方个节点，通过等比数列求和公式可以得出答案。
2.一棵高度为h，节点数为n的真二叉树的特点是（D）
A.h=O(logn)
B.真的是二叉树，而不是其他种类的树
C.不存在只有一个父亲的节点
D.不存在只有一个孩子的节点
解析：对于退化为一条单链的二叉树，其高度h=O(n)。真二叉树的特点为不存在度数为1的节点。
3.在长子-兄弟表示法中，树中某节点的长子相当于二叉树中的（B）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53c6efce296201da6f3c799133d281a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a940942aacad3958a5409e08a2ac04/" rel="bookmark">
			在GitHub上学黑客 --- 黑客成长技术清单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 黑客的工具包 这个开源项目是黑客的多合一工具包，包含了各种黑客工具，比如逆向工程、老鼠工具、SQL注入工具等等。声明：该开源项目仅限学习使用，勿用与从事违法活动。
开源地址：https://github.com/Z4nzu/hackingtool
2 程序员如何优雅地做副业 这个开源项目是教程序员如何优雅地挣零花钱，本开源项目是一本电子书，从副业的重要性、到程序员可能得副业路径，以及知识付费、课程录制等实战案例为基础，打磨的一本程序员副业指南。
开源地址：https://github.com/easychen/lean-side-bussiness
3. Awesome Hacking 系列 “Awesome Hacking”涉及到黑客技能的各个方面，如果你想要了解安全入门的知识，进阶成为黑客大牛的话，相信“AwesomeHacking”一定可以给你带来很大帮助。
Android安全： A ndroid安全相关资源，包括各种工具、学术/研究/出版物/书籍等资源
https://github.com/ashishb/android-security-awesome
应用程序安全 (AppSec) ： 了解、学习应用程序安全性的资源列表，包含书籍，网站，博客文章等。
https://github.com/paragonie/awesome-appsec
bug赏金： 漏洞赏金计划列表和漏洞赏金猎人的备案等
https://github.com/djadmin/awesome-bug-bounty
Cheatsheets： 渗透测试/安全说明书
https://github.com/jshaw87/Cheatsheets
CTF： CTF框架，类库，资源和软件清单，这份清单旨在帮助初学者以及经验丰富的CTF玩家轻松找到与CTF相关的所有内容。
https://github.com/apsdehal/awesome-ctf
网络攻击环境： 黑客环境的集合列表，可以让你合法地，安全地培养提升你的网络技能
https://github.com/joe-shenouda/awesome-cyber-skills
devsecops： 一个权威的 devsecops 工具列表，这些基本的构建模块足以帮助你构建自己的DevSecOps程序。
https://github.com/devsecops/awesome-devsecops
exploit开发： 用于学习exploit开发的书籍，教程，工具和易受攻击的应用列表
https://github.com/FabioBaroni/awesome-exploit-development
Fuzzing： 各种fuzzing图书、课程、工具、教程等，用于学习漏洞开发的初始阶段，如根本原因分析。
https://github.com/secfigo/Awesome-Fuzzing
Hacking： 黑客教程、工具和资源的列表
https://github.com/Hack-with-Github/Awesome-Hacking
蜜罐： 一个很赞的蜜罐资源列表。重点放在开源项目上。该列表分为Web，服务和其他类别等。
https://github.com/paralax/awesome-honeypots
事件响应： 事件响应工具清单
https://github.com/meirwah/awesome-incident-response
工业控制系统安全： 与工业控制系统（ICS）安全相关的资源清单
https://github.com/hslatman/awesome-industrial-control-system-security
信息安全： 信息安全资源列表，包含精心设计的信息技术课程和培训资源。
https://github.com/onlurking/awesome-infosec
IoT安全： 包含了大量IoT破解案例，以便研究人员解决物联网产品中的安全漏洞问题
https://github.com/nebgnahz/awesome-iot-hacks
恶意软件分析： 涵盖许多恶意软件分析工具和资源等
https://github.com/rshipp/awesome-malware-analysis
开源情报(OSInt)： 各种开源情报来源
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17a940942aacad3958a5409e08a2ac04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1ec1a7a64cee2884fc19177842d36c/" rel="bookmark">
			MYSQL窗口函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、为何使用窗口函数二、什么是窗口函数三、窗口函数如何使用3.1 序号函数3.2 分布函数3.3 前后函数3.4 头尾函数3.5 其他函数3.6 聚类窗口函数 一、为何使用窗口函数 在日常工作中经常会遇到类似这样的需求：
怎么样得到各部门工资排名前N名的员工列表? 查找各部门每人工资占部门总工资的百分比? 对于这样的需求，使用传统的SQL实现起来比较困难，这类需求都有一个共同的特点，需要在单表中满足某些条件的记录集内部做一些函数操作。不使用窗口函数的话可能要进行多次的表连接操作，可读性差的同时还会影响性能。
窗口函数适用场景: 对分组统计结果中的每一条记录进行计算的场景下, 使用窗口函数更好, 注意, 是每一条；因为MySQL的普通聚合函数的结果(如 group by)是每一组只有一条记录。
二、什么是窗口函数 窗口函数也称为OLAP（Online Anallytical Processing）函数，意思是对数据库数据进行实时分析处理。窗口函数就是为了实现OLAP而添加的标准SQL功能。
窗口的概念非常重要，它可以理解为记录集合，窗口函数也就是在满足某种条件的记录集合上执行的特殊函数，对于每条记录都要在此窗口内执行函数，有的函数，随着记录不同，窗口大小都是固定的，这种属于静态窗口；有的函数则相反，不同的记录对应着不同的窗口，这种动态变化的窗口叫滑动窗口。
窗口函数和普通聚合函数也很容易混淆，二者区别如下：
聚合函数是将多条记录聚合为一条；而窗口函数是每条记录都会执行，查询结果并不会改变记录条数，有几条记录执行完还是几条。普通聚合函数也可以用于窗口函数中，赋予它窗口函数的功能。
原因就在于窗口函数的执行顺序（逻辑上的）是在FROM，JOIN，WHERE，GROUP BY，HAVING之后，在ORDER　BY，LIMIT，SELECT　DISTINCT之前。它执行时GROUP BY的聚合过程已经完成了，所以不会再产生数据聚合。 窗口函数的简单语法如下：
&lt;窗口函数&gt; OVER (partition by &lt;用于分组的列名&gt; order by &lt;用于排序的列名&gt;) 三、窗口函数如何使用 数据表：
drop table if exists examination_info,user_info,exam_record; CREATE TABLE examination_info ( id int PRIMARY KEY AUTO_INCREMENT COMMENT '自增ID', exam_id int UNIQUE NOT NULL COMMENT '试卷ID', tag varchar(32) COMMENT '类别标签', difficulty varchar(8) COMMENT '难度', duration int NOT NULL COMMENT '时长', release_time datetime COMMENT '发布时间' )CHARACTER SET utf8 COLLATE utf8_general_ci; CREATE TABLE user_info ( id int PRIMARY KEY AUTO_INCREMENT COMMENT '自增ID', uid int UNIQUE NOT NULL COMMENT '用户ID', `nick_name` varchar(64) COMMENT '昵称', achievement int COMMENT '成就值', level int COMMENT '用户等级', job varchar(32) COMMENT '职业方向', register_time datetime COMMENT '注册时间' )CHARACTER SET utf8 COLLATE utf8_general_ci; CREATE TABLE exam_record ( id int PRIMARY KEY AUTO_INCREMENT COMMENT '自增ID', uid int NOT NULL COMMENT '用户ID', exam_id int NOT NULL COMMENT '试卷ID', start_time datetime NOT NULL COMMENT '开始时间', submit_time datetime COMMENT '提交时间', score tinyint COMMENT '得分' )CHARACTER SET utf8 COLLATE utf8_general_ci; INSERT INTO user_info(uid,`nick_name`,achievement,`level`,job,register_time) VALUES (1001, '牛客1', 3200, 7, '算法', '2020-01-01 10:00:00'), (1002, '牛客2号', 2500, 6, '算法', '2020-01-01 10:00:00'), (1003, '牛客3号♂', 2200, 5, '算法', '2020-01-01 10:00:00'); INSERT INTO examination_info(exam_id,tag,difficulty,duration,release_time) VALUES (9001, 'SQL', 'hard', 60, '2020-01-01 10:00:00'), (9002, 'SQL', 'hard', 80, '2020-01-01 10:00:00'), (9003, '算法', 'hard', 80, '2020-01-01 10:00:00'), (9004, 'PYTHON', 'medium', 70, '2020-01-01 10:00:00'); INSERT INTO exam_record(uid,exam_id,start_time,submit_time,score) VALUES (1001, 9001, '2020-01-01 09:01:01', '2020-01-01 09:21:59', 90), (1002, 9001, '2020-01-20 10:01:01', null, null), (1002, 9001, '2020-02-01 12:11:01', null, null), (1003, 9001, '2020-03-01 19:01:01', null, null), (1001, 9001, '2020-03-01 12:01:01', null, null), (1002, 9001, '2020-03-01 12:01:01', '2020-03-01 12:41:01', 90), (1002, 9001, '2020-05-02 19:01:01', '2020-05-02 19:32:00', 90), (1001, 9002, '2020-01-02 19:01:01', '2020-01-02 19:59:01', 69), (1001, 9002, '2020-02-02 12:01:01', '2020-02-02 12:20:01', 99), (1002, 9002, '2020-02-02 12:01:01', null, null), (1002, 9002, '2020-02-02 12:01:01', '2020-02-02 12:43:01', 81), (1002, 9002, '2020-03-02 12:11:01', null, null), (1001, 9001, '2020-01-02 10:01:01', '2020-01-02 10:31:01', 89), (1001, 9002, '2020-01-01 12:11:01', null, null), (1002, 9001, '2020-01-01 18:01:01', '2020-01-01 18:59:02', 90), (1002, 9003, '2020-05-06 12:01:01', null, null), (1001, 9002, '2020-05-05 18:01:01', null, null); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf1ec1a7a64cee2884fc19177842d36c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0218f3852d172f777c3bc2c6ae0bd79/" rel="bookmark">
			查看模型训练时gpu利用率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小白 记录一下遇到的各种问题。windows11.
法1：win+R，输入cmd
输入：nvidia-smi，没有空格，否则会出现“nvidia-smi”不是内部或外部命令。
法2：直接在任务管理器--性能上查看，快捷键ctrl+shift+esc。好处是可以实时看到利用率变化
但是自己在训练时发现法1和法2的gpu利用率显示的不一样。找了很久。。发现任务管理器上的显示的是如下图：3d。改为cuda就好了。
如果没有cuda这个选项，需要改一下设置--显示--显示卡--更改默认图形设置--关闭硬件加速gpu计划。然后重启电脑，就有cuda选项了。
但是即使改成了Cuda，法1和法2的利用率还是有差别，听说法1是才是最准的。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d028616f705b9ce7462ae00c1375c326/" rel="bookmark">
			VUE3中的ref函数和reactive函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. ref函数 作用：定义一个响应式的数据语法：const xxx = ref(initValue) 创建一个包含响应式数据的引用对象（reference对象，简称 ref 对象）JS中操作数据：xxx.value模板中读取数据：不需要.value，直接：&lt;div&gt;{{xxx}}&lt;/div&gt; 备注： 接受的数据可以是：基本类型，也可以是对象类型基本数据类型：响应式依然是靠Object.defineProperty()的get与set完成的对象类型的数据：内部“求助”了VUE3.0中的一个新函数——reactive函数 2. reactive函数 作用：定义一个对象类型的响应式数据 （基本类型不要用它，要用ref函数）。语法：const 代理对象 = reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象）。reactive定义的响应式数据是“深层次的”。内部基于ES6的 proxy 实现，通过代理对象操作源对象内部数据进行操作。 3. reactive 对比 ref 从定义数据角度对比： ref用来定义：基本类型数据。reactive用来定义：对象（或数组）类型数据。备注：ref也可以用来定义对象（或数组）类型数据，它内部会自动通过reactive转为代理对象。 从原理角度对比： ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。reactive通过使用Proxy来实现响应式（数据劫持），并通过Reflect操作源对象内部的数据。 从使用角度对比： ref定义的数据：操作数据需要.value，读取数据时模版中直接读取不需要.value reactive定义的数据：操作数据与读取数据：均不需要.value 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3d6669a9ab541c389daaa342fe8cf26/" rel="bookmark">
			java算法题Day52
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4d3ca1046dea01fa69e59239c43f264/" rel="bookmark">
			Vue2 和 Vue3 的响应式原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue2.x的响应式 实现原理： 对象类型：通过Object.defineProperty()对属性的读取,修改进行拦截（数据劫持）数据类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。 Object.defineProperty(data,'count',{ get(){}, set(){} }) 存在问题： 新增属性，删除属性，界面不会更新。直接通过下标修改数组，界面不会自动更新。 vue3.0的响应式 实现原理： 通过Proxy（代理）：拦截对象中任意属性的变化，包括：属性值的读写，属性的添加。属性的删除等。通过Reflect（反射）：对被代理对象的属性进行操作。 new Proxy(data,{ //拦截读取属性值 get(target,prop){ return Reflect.get(target,prop) }, set(target,prop,value){ Reflect.set(target,prop,value) }, deleteProperty(target,prop){ return Reflect.deleteProperty(target,prop) } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14efc8f0fda7c6e2587c7507b392867e/" rel="bookmark">
			c#之文本框的回车事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中的文本框的表格事件有很多比如
执行先后顺序： keydown–&gt;keypress–&gt;keyup
但是这里我们用到的是KeyDown //文本框事件 private void textBox1_KeyDown(object sender, KeyEventArgs e) { //if条件检测按下的是不是Enter键 if (e.KeyCode == Keys.Enter) { MessageBox.Show("您按下了回车键"); } } 具体代码看上面一段代码在C#窗体程序中可以判断用户是否敲下了回车键,但是有些是用e.KeyChar 来判断的，我好像使用了没其效果，我这个里用的是e.KeyCode来判断的,我也不知道为什么所以就先记录下来吧,要是有大佬知道能告诉我下，就感激不尽了。
-------2022.7.17武汉记录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f796dd3b2d86e0ad1a6b1a3cde6ba57/" rel="bookmark">
			Lombok技术常用注解总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用来简化pojo类的开发，包括getter/setter/toString/equal/构造方法 等等
Lombok可以通过注解，来帮助开发人员消除Java尤其是pojo类的冗余代码
插件安装 idea版本在2020.3以上，不需要安装了，在以下要安装，在File-&gt;Setting-&gt;plugins中安装
Lombok依赖 Spring Boot项目的依赖为：
&lt;!--引入lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; Lombok注解@Setter 和@Getter 作用：为类中的属性提供setter和getter方法
位置：类上方或者属性上方，在属性上方则为属性生成setter和getter方法，在类上方表示给该类下的所有属性生成setter和getter方法
/** * 注意： * 1.static 修饰的属性不生成get和set * 2.final 修饰的属性只生成get方法 */ @Component //为该类下所有的属性添加setter方法 @Setter //为该类下所有的属性添加getter方法 @Getter public class User { //在id上面加入这个注解以后，id就有了set方法 @Setter private int id; //取消username 的set方法 @Setter(AccessLevel.NONE) private String username; //设置password 的 setter的私有权限 @Setter(AccessLevel.PRIVATE) private String password; } Lombok注解@ToString 作用：生成toSting方法，默认情况会按照顺序打印类名称以及每个字段
位置：类上方
@Component //为该类生成toString方法 //去除password和username，只打印id @ToString(exclude = {"password","username"}) public class User { private int id; private String username; private String password; } Lombok注解@EqualsAndHashCode 作用：生成equal方法和hashCode、canEqual方法。用于比较两个类对象是否相同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f796dd3b2d86e0ad1a6b1a3cde6ba57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe5248c3812878576b7dce300c300ef4/" rel="bookmark">
			立创EDA怎么批量处理元器件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.点击编辑—点击查找相似对象（也可以按快捷键Ctrl+Shift+F）。
2.之后弹出这个对话框，搜索你需要的条件。
种类： 选择你需要批量查找的元素类型。
范围： 在当前原理图页查找还是在全部原理图页查找。该选项仅在原理图存在。
查找条件： 任意：该属性不做为查找条件；相等：仅找出和该属性一致的；不等：找出和该属性不一致的
用电阻举个例子：
输入框支持Js的正则表达查询：/包含的文字/，如你需要找出所有编号为R开头的电阻R1，R2，R3：
你可以直接在编号输入框填入/R/，条件选择相等，然后进行查找。
3.点击查找后，所有符合的元素都会被选中，在右边属性面板会显示它们的属性，相同属性不同属性值的会用&lt;…&gt;显示，你可以直接修改参数，并会应用到全部选中的对象。
属性面板的批量属性修改暂不支持部分文本替换，修改将会全部修改。
查找相似对话框仅支持显示部分元件自定义属性。
教程参考嘉立创教程，感谢嘉立创支持，嘉立创免费打板，每个月可以免费打两次哟~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bed4a0ba2aa4ee4765d58ba07566284/" rel="bookmark">
			HashMap底层实现原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、快速入门1.HashMap的常用方法2.HashMap的几个重要知识点 二、JDK7与JDK8的HashMap区别三、HashMap的容量与扩容机制四、HashMap的结构五、HashMap存储原理与存储流程七、扩容后的新table数组，那老数组中的这个数据怎么迁移呢 一、快速入门 示例：有一定基础的小伙伴们可以选择性的跳过该步骤
HashMap是Java程序员使用频率最高的用于映射键值对(key和value)处理的数据类型。随着JDK版本的跟新，JDK1.8对HashMap底层的实现进行了优化，列入引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的数据结构实现和功能原理。
Java为数据结构中的映射定义了一个接口java.uti.Map，此接口主要有四个常用的实现类，分别是HashMap，LinkedHashMap，Hashtable，TreeMap，IdentityHashMap。本篇文章主要讲解HashMap以及底层实现原理。
1.HashMap的常用方法 // Hashmap存值：----------------------------------&gt; .put(“key”,“value”)； ----------&gt;无返回值。
//
// Hashmap取值：----------------------------------&gt; .get(“key”)；-------------------&gt; 返回Value的类型。
//
// Hashmap判断map是否为空：-----------------------&gt; .isEmpty()； -------------------&gt;返回boolean类型。
//
// Hashmap判断map中是否存在这个key：--------------&gt;.containsKey(“key”)；------------&gt;返回boolean类型。
//
// Hashmap判断map中是否含有value：----------------&gt;.containsValue(“value”)；-------&gt;返回boolean类型。
//
// Hashmap删除这个key值下的value：----------------&gt;.remove(“key”)；-----------------&gt;返回Value的类型。
//
// Hashmap显示所有的value值：---------------------&gt;.values()； --------------------&gt;返回Value的类型。
//
// Hashmap显示map里的值得数量：-------------------&gt;.size()； ----------------------&gt;返回int类型
//
// HashMap显示当前已存的key：---------------------&gt; .keySet()；-------------------&gt;返回Key的类型数组。
//
// Hashmap显示所有的key和value：-----------------&gt;.entrySet())；------------------&gt;返回Key=Value类型数组。
//
// Hashmap添加另一个同一类型的map：--------------&gt;.putAll(map)； -----------------&gt;(参数为另一个同一类型的map)无返回值。
//
// Hashmap删除这个key和value：------------------&gt;.remove(“key”, “value”)；-------&gt;(如果该key值下面对应的是该value值则删除)返回boolean类型。
//
// Hashmap替换这个key对应的value值(JDK8新增)：—&gt;.replace(“key”,“value”)；-------&gt;返回被替换掉的Value值的类型。
//
// 克隆Hashmap：-------------------------------&gt;.clone()； ---------------------&gt;返回object类型。
//
// 清空Hashmap：-------------------------------&gt;.clear()； ---------------------&gt;无返回值。
2.HashMap的几个重要知识点 HashMap是无序且不安全的数据结构。
HashMap 是以key–value对的形式存储的，key值是唯一的（可以为null），一个key只能对应着一个value，但是value是可以重复的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bed4a0ba2aa4ee4765d58ba07566284/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e80cd528912938b5b45d22311f302096/" rel="bookmark">
			零售连锁门店收银系统源码管理商品分类的功能逻辑分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、添加一级分类步骤 第一步：进入【商品】-【商品分类】-【分类管理】列表，点击【新增分类】按钮
第二步：在新增分类弹窗中，填写分类相关信息。并点击【保存】按钮。
二、添加子分类步骤 第一步：进入【分类管理】列表，在【操作列】点击【新增子分类】按钮
第二步：在新增子分类弹窗中填写相应信息后，点击【保存】按钮。
三、编辑商品分类步骤 第一步：进入【分类管理】列表，在【操作列】点击【编辑】按钮
第二步：在编辑商品分类弹窗中填写相应信息后，点击【保存】按钮。
四、删除商品分类步骤 第一步：进入【分类管理】列表，在【操作列】点击【删除】按钮
第二步：可以删除的分类会直接提示删除成功
五、管理分类的注意事项 5.1、分类信息填写的注意事项：
分类名称最多20个汉字；分类排序0～999，数字越大排序越靠前；分类名称不可重复。 5.2、所属行业的注意事项：
所属行业指的是门店所属的“门店行业”；新增分类时，调用了所属的门店行业，各下级门店将根据所属行业对应显示商品分类；留空默认调用公共行业，公共行业适应于所有直营及加盟门店（分类显示至所有门店）；已经发布成功的分类无法再次编辑所属行业。 5.3、网店显示的注意事项：
网店状态中，开启表示该分类可以在直营小程序网店中显示；隐藏表示该分类无法在直营小程序网店中显示；加盟小程序网店是否显示，由加盟店自行设置 5.4、商户端管理商品分类的注意事项
系统默认预设一条“预设分类”，无法删除、无法编辑，只能调用商户（总部）发布的商品分类将根据所属的 门店行业 ，同步至对应的直营门店及加盟门店；商户编辑或删除分类时请谨慎操作，以免影响门店的正常使用；系统目前最多支持3级商品分类。 5.5、门店端管理商品分类的注意事项
直营门店无任何管理商品分类的权限，只能查看/调用；加盟门店只能开启/隐藏商品分类在网店显示的权限；下级门店如需新增分类，请与商户管理员联系。 5.6、删除商品分类的注意事项
有下级子分类的分类无法删除；已经被任何商品占用的分类无法删除；商品分类只能由商户端操作删除，可以删除的分类会提示“删除成功”。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5411bb0807f71de959da4dfb83557ce4/" rel="bookmark">
			Spring AOP中CGLIB代理对象增强通知执行原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置博文：
Spring AOP中如何为Bean创建代理？
Spring AOP中是如何注册Advisor的？
Spring AOP如何为目标方法创建拦截器链？
Spring AOP拦截器调用的实现
Spring AOP中CGLIB代理对象增强通知执行原理
或者换句话说，当我们定义了切面、pointcut以及advice后，这些是如何对我们的目标对象生效的。本文这里以CglibAopProxy为例说明，至于jdk动态代理可以自行查看JdkDynamicAopProxy的invoke方法（大概流程与CGLIB代理一致）。
cglib代理为目标对象增强执行是通过CglibAopProxy的callbacks进行拦截处理的，入口在DynamicAdvisedInterceptor的intercept方法；
jdk动态代理则是通过JdkDynamicAopProxy#invoke方法进行拦截处理，流程与CGLIB类似，都是获取到拦截器链遍历调用。
继续结合前面博文分析，我们从代码角度解读其执行流程。假设我们有切面如下：
@Aspect @Component public class LogAspect { //注意这里我们没有限制方法修饰符 ，以 * 表示匹配所有 @Pointcut("execution(* com.recommend.controller.*.*(..))") public void logPointCut() { } @Before(value = "execution(* com.recommend.controller.*.*(..))") public void beforeMethod(JoinPoint point) { System.out.println(" before(Joinpoint point)"); } @After("logPointCut()") public void afterMethod(JoinPoint point) { System.out.println(" afterMethod(Joinpoint point)"); } @AfterReturning(pointcut = "logPointCut()",returning="result") public void AfterReturning(JoinPoint point,Object result) { System.out.println(" AfterReturning(Joinpoint point)"); } @AfterThrowing(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5411bb0807f71de959da4dfb83557ce4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3d79ff89a674fc60d1c2a47521f11b1/" rel="bookmark">
			aardio内嵌资源的代码写法-以内嵌DLL为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写程序经常需要调用一些dll文件。大体有把dll内嵌进exe文件和不内嵌直接从硬盘调用两种方式。如果不内嵌，写起来相对简单，就写dll的绝对路径或者以exe文件为基础的相对路径就可以了。重点分析一下内嵌方式，当然这种方式其实并不局限于dll，其他文件也是类似的。
（一）使用$包含操作符进行内嵌
使用包含操作符就是在dll路径字符串前引号前面加上一个$符号，就可以了。编译的时候，程序会将dll以二进制方式嵌入exe。执行的时候，执行到这里，程序会从exe中提取这个二进制数据到内存，然后调用它。也就是说，程序执行的时候，已经不需要原来的dll文件了。这就是内嵌的目的，打包。写法就是：raw.loadDll($"dll路径")。一般来说，你从硬盘拖一个dll文件进代码，就会生成这种格式。
注意，上面的dll路径可以是任何路径，绝对路径、相对路径都可以，工程里面、工程外面无所谓，但是最好不要放在资源目录。因为资源目录是下面要讲的另一种内嵌方式，两种方式都用就会内嵌两次，平白无故的增加软件体积。例子：
import win.ui; /*DSG{{*/ var winform = win.form(text="aardio form";right=360;bottom=247) winform.add() /*}}*/ var dll=raw.loadDll($"C:\Users\NIE\Desktop\basic.dll",,"cdecl") dll.msgboxW("aardio成功调用vfb编译的dll") winform.show(); win.loopMessage(); 这个dll是16k，这个程序编译完是1083k，如果放进资源目录，编译完是1099k，证明确实是重复嵌入了一次。
（二）放入res资源目录进行内嵌
放进资源目录的所有文件，默认都是内嵌的。所以不必再用$包含操作符，按理说直接写就行了，例如raw.loadDll("\res\basic.dll")。这样编译完成后，也是一样脱离了原来的dll。但是实际上不一定行，往往是开发环境可以，编译完成报错：
今天就有一位群友遇到了这样的问题。这时当然可以把res目录复制到exe目录解决这个问题，但这就不是内嵌了。
我分析是这样，大多函数都支持直接使用内嵌资源，但是并不是所有的函数都如此，这个raw.loadDll函数只支持dll路径、内存数据（参考智能提示），并不支持直接使用内嵌资源。所以我们需要把内嵌资源转换为内存数据。可用的函数不止一个，一般使用string.load就可以，因为string.load是支持读取内嵌资源的（参考智能提示）。最后，可行的写法应该是raw.loadDll(string.load("\res\basic.dll"))
import win.ui; /*DSG{{*/ var winform = win.form(text="aardio form";right=360;bottom=247) winform.add() /*}}*/ var dll=raw.loadDll(string.load("\res\basic.dll"),,"cdecl") dll.msgboxW("aardio成功调用vfb编译的dll") winform.show(); win.loopMessage(); 这样在开发环境和编译后都可以运行，编译完大小也是1083k。
（三）内嵌后释放到硬盘
有些dll并不支持内存加载，编译时内嵌了，执行时还要释放出来。释放方法很多，这里只说常用的两种方法：
1.fsys.res扩展库，适用于内嵌资源文件释放。
import win.ui; /*DSG{{*/ var winform = win.form(text="aardio form";right=360;bottom=247) winform.add() /*}}*/ import fsys.res if not _STUDIO_INVOKED fsys.res.saveRes() var dll=raw.loadDll("\res\basic.dll",,"cdecl") dll.msgboxW("aardio成功调用vfb编译的dll") winform.show(); win.loopMessage(); 这样的话，exe运行时会在同一目录下生成res目录，dll文件就在其中，实际是从硬盘调用，也就不必string.load了。
2. io.appdata函数，通常用于$包含操作符内嵌文件的释放。
import win.ui; /*DSG{{*/ var winform = win.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3d79ff89a674fc60d1c2a47521f11b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/209b10f4f21a0780bb5633f6a6b1046e/" rel="bookmark">
			关于windows自带的两种远程访问方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验环境：两台非家庭版的windows系统（我使用的win7和xp系统），在同一网段下
关于windows的两种远程访问方式：
1、将普通用户添加到远程桌面服务组（Remote Desktop Users组，该组账户专门用于为远程访问提供服务）
2、 telnet为用户提供命令行远程访问权限
使用Remote Desktop Users组的用户远程访问
在xp系统下我们点击开始-在我的电脑上单击右键-属性-远程-选中允许用户连接到此计算机- 选择远程用户
点击添加 -输入普通账户名-检查名称-确定--确定-应用-确定-完成
打开win7系统，点击开始菜单-远程桌面连接-输入需要连接的IP地址-连接
已经连接成功，需要我们输入刚才添加的普通用户账户名和密码登录进入 -此时在xp端也会提示有其他用户接入，是否同意接入，点击是，在win7端继续正常进入
使用win+R打开运行窗口-输入cmd打开命令行窗口，使用ipconfig命令获取到了被控端的IP地址，测试成功 ，远程桌面访问成功。
注意：具有管理员权限的用户无需添加到Remote Desktop Users组就可以访问，这些用户拥有最高的管理权限，因此无需授权，但如果用这些登录是极度危险的，一旦他们的密码泄露被不法分子利用造成的后果是非常严重的，因此还是使用普通用户通过加入Remote Desktop Users组提供专门的远程访问权限即可。
使用telnet访问远程访问
首先我们打开xp系统的telnet服务，单击开始菜单-控制面板-管理工具-服务-找到Telnet的服务-单击右键-属性
将启动类型改为手动-在服务状态栏点击启动-应用-确定-xp的telnet就已经完成配置
接下来我们配置win7的telnet服务
点击开始菜单-控制面板-程序-打开或关闭Windows功能 找到Telnet服务端和客户端，选中，点击确定等待安装
使用win+R键打开运行窗口-输入services.msc打开服务-找到Telnet
选中telnet-单击右键-属性-启动类型选手动- 服务状态选启动-应用-确定-win7的telnet配置成功
测试telnet服务是否畅通
在win7上使用win+R打开运行窗口-输入cmd打开命令行窗口，输入telnet 192.168.19.105(这里的IP是被访问端的IP)，回车-输入y-输入被访问端具有远程访问权限的用户名和密码（这里我们使用的是超级用户去访问，显然这样是不安全的，后面讲解将普通用户添加到telnetClient组，使普通用户可以通过telnet远程访问）-回车
我们已经远程访问成功并且使用ipconfig命令获取到了被控端的IP地址，测试成功 上面我们已经通过超级用户使用telnet远程访问，接下来讲使用普通用户，由于我在xp系统中没有找到Telnet Client组（希望懂得老师可以教教我xp里可不可以让普通用户获得远程访问权限，这方面不太懂），因此我打算在xp系统上使用telnet访问win7，也就是在win7上将普通用户添加到Telnet Client组，实现普通用户的telnet远程访问
打开win7，在win7上使用win+R打开运行窗口-输入lusrmgr.msc打开用户和组，在组中找到Telnet Client组点击打开
点击添加-输入授权远程访问的用户-确定-应用-确定-完成
使用xp系统telnet访问测试
我们已经远程访问成功并且使用ipconfig命令获取到了被控端的IP地址，测试成功 !
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/222/">«</a>
	<span class="pagination__item pagination__item--current">223/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/224/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>