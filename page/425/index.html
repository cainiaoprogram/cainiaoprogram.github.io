<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83f1aafcf2b002e877af48792d5d7216/" rel="bookmark">
			一个奇怪的问题——ImportError: No module named google.protobuf.internal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译好pycaffe在import时遇到这个问题：ImportError: No module named google.protobuf.internal
解决方法：
没有anaconda: pip install protobuf （编译caffe就需要这个protobuf）
有anaconda: conda install protobuf (最后装了libprotobuf和protobuf 3.5.2)
======================================================
使用系统自带的python(root下的python，路径为/usr/bin/python)能import这个2.6.1版本的protobuf
使用anaconda自带的python（anaconda2/bin/python）则无法import这个版本的protobuf，可能和protobuf-2.6.1-py2.7-nspkg.pth这个文件有关，内容如下：
import sys, types, os; has_mfs = sys.version_info &gt; (3, 5); p = os.path.join(sys._getframe(1).f_locals['sitedir'], *('google',)); importlib = has_mfs and __import__('importlib.util'); has_mfs and __import__('importlib.machinery'); m = has_mfs and sys.modules.setdefault('google', importlib.util.module_from_spec(importlib.machinery.PathFinder.find_spec('google', [os.path.dirname(p)]))); m = m or sys.modules.setdefault('google', types.ModuleType('google')); mp = (m or []) and m.__dict__.setdefault('__path__',[]); (p not in mp) and mp.append(p) 如果直接from google.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83f1aafcf2b002e877af48792d5d7216/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f646921b31dd08bfc1384c6d8f915bee/" rel="bookmark">
			Element-UI可编辑表格的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 可编辑单元格的实现
实现效果：点击可编辑
实现原理：在单元格中放置span 和 input ，绑定data中同一的数据，捕捉点击单元格事件和失去焦点事件，添加/删除 元素的相应class，控制span 和 input 框的显示。
实现代码：
Style：
.tb-edit .input-box { display: none } .tb-edit .current-cell .input-box { display: block; margin-left: -15px; } Html：
&lt;el-table-column label='&lt;@spring.message "flowemptransfer.description"/&gt;' class-name="column-bg-color-editable" width="100" show-overflow-tooltip&gt; &lt;template scope="scope"&gt; &lt;div class="input-box"&gt; &lt;el-input size="small" @blur="handleInputBlur" v-model="scope.row.description" &gt;&lt;/el-input&gt; &lt;/div&gt; &lt;span&gt;{{scope.row.description}}&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; JavaScript：
//单元格点击后，显示input，并让input 获取焦点 handleCellClick:function(row, column, cell, event){ emptransfer.addClass(cell,'current-cell'); if(emptransfer.getChildElement(cell,3) !== 0){ var _inputParentNode =emptransfer.getChildElement(cell,3); if(_inputParentNode.hasChildNodes()&amp;&amp; _inputParentNode.childNodes.length &gt; 2) { var _inputNode = _inputParentNode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f646921b31dd08bfc1384c6d8f915bee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec9696103b50645ec6f334953895d1f/" rel="bookmark">
			element中input的change事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element中input的change事件是移除焦点才触发：
&lt;el-input placeholder="同事姓名或账号" suffix-icon="el-icon-search" v-model="keyword" @change="handlerPageNo" style="width: 180px;"&gt;&lt;/el-input&gt; 想要变成输入就出发：
解决：
使用@input
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d763fc20ab50ebe271b92f2cb9d5e8d3/" rel="bookmark">
			常见几种数据库驱动和url书写格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle
驱动：oracle.jdbc.driver.OracleDriver
URL：jdbc:oracle:thin:@localhost:1521:dbname
mysql
驱动：com.mysql.jdbc.Driver
URL：jdbc:mysql://localhost:3306/dbname
SQL Server
驱动：com.microsoft.jdbc.sqlserver.SQLServerDriver
URL：jdbc:mirosoft:sqlserver://&lt;localhost&gt;&lt;:1433&gt;;DatabaseName=&lt;dbname&gt;
DB2
驱动：com.ibm.db2.jdbc.app.DB2Driver
URL：jdbc：db2://&lt;localhost&gt;&lt;:5000&gt;/dbname
注：上述所有的localhost需要替换成相应的主机名，端口都是默认端口，需要替换相应的端口号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d108776249e9892a175351779b1f07/" rel="bookmark">
			scss-@for 指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此指令用于循环输出，具有两种循环方式，下面分别做一下介绍。
（1）.@for $var from &lt;start&gt; through &lt;end&gt;:
此种方式的遍历索引区间是[start,end]，scss代码实例如下:
@for $i from 1 through 3 { .item-#{$i} { width: 2em * $i; } } 编译后的css代码如下:
.item-1 { width: 2em; } .item-2 { width: 4em; } .item-3 { width: 6em; } （2）.@for $var from &lt;start&gt; to &lt;end&gt;:
此种方式的遍历索引区间是[start,end-1]，scss代码实例如下:
@for $i from 1 to 3 { .item-#{$i} { width: 2em * $i; } } 编译后的css代码实例如下:
.item-1 { width: 2em; } .item-2 { width: 4em; } 转载于:https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61d108776249e9892a175351779b1f07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32fb6c036829cfc51a0186ce98d9dbfa/" rel="bookmark">
			Flutter 之 Scaffold
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scaffold是实现Material Design的布局结构。也就是说， MaterialApp 的 child 是 Scaffold Widget。
在Material设计中定义的单个界面上的各种布局元素，在 Scaffold 中都有支持，比如 左边栏（Drawers）、snack bars、以及 bottom sheets。
Scaffold 有下面几个主要属性：
appBar：显示在界面顶部的一个 AppBar，也就是 Android 中的 ActionBar 、Toolbar
body：当前界面所显示的主要内容 Widget
floatingActionButton：Material设计中所定义的 FAB，界面的主要功能按钮
persistentFooterButtons：固定在下方显示的按钮，比如对话框下方的确定、取消按钮
drawer：侧边栏控件
backgroundColor： 内容的背景颜色，默认使用的是 ThemeData.scaffoldBackgroundColor 的值
bottomNavigationBar： 显示在页面底部的导航栏resizeToAvoidBottomPadding：类似于 Android 中的 android:windowSoftInputMode=”adjustResize”，控制界面内容 body 是否重新布局来避免底部被覆盖了，比如当键盘显示的时候，重新布局避免被键盘盖住内容。默认值为 true。
显示 snackbar 或者 bottom sheet 的时候，需要使用当前的 BuildContext 参数调用 Scaffold.of 函数来获取 ScaffoldState 对象，然后使用 ScaffoldState.showSnackBar 和 ScaffoldState.showBottomSheet 函数来显示。
@override Widget build(BuildContext context) { return new RaisedButton( child: new Text('SHOW A SNACKBAR'), onPressed: () { Scaffold.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32fb6c036829cfc51a0186ce98d9dbfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/605a9b94bfe229c6b25dbdaf260ad3cb/" rel="bookmark">
			BUG记录 java.lang.NoSuchMethodError: No static method combineMeasuredStates(II)I in class Landroid/sup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常：
ERROR: java.lang.NoSuchMethodError: No static method combineMeasuredStates(II)I in class Landroid/support/v7/widget/ViewUtils; or its super classes (declaration of 'android.support.v7.widget.ViewUtils' appears in /data/app/com.example.marvin.test-1/split_lib_dependencies_apk.apk:classes58.dex)
出现原因：
（1）依赖的版本不同：
implementation 'com.android.support:appcompat-v7:27.0.1' implementation 'com.android.support:design:25.3.1' （2）第三方中引入一个包的不同版本导致，例如
自己的项目中：
implementation 'com.android.support:appcompat-v7:27.0.1' 同时导入了第三方，里面也有导入该包，造成了这个异常
知道问题就可以解决了，只要在相应的重复导包的第三方中exclude重复的包。
和这个问题相同就是导入的第三方里包含了你已经导入的包，例如重复导Glide（很常见），只要同样exclude掉重复的包，让各自有用的包在其固定范围内发挥作用。
问题解决：
（1）版本改为一样就好
implementation 'com.android.support:appcompat-v7:27.0.1' implementation 'com.android.support:design:27.0.1' （2）修改引入的第三方中的相关依赖
implementation ( 'com.github.LuckSiege.PictureSelector:picture_library:v2.1.9'){ exclude module: 'appcompat-v7' exclude group: 'com.android.support' } 总结：
对于导入第三方，常常出现很多问题，这个重复依赖是经常遇到的问题
有时候不会明显提示你重复导包了，需要自己通过查看项目依赖树来查看是否重复导包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b25c68a7e8a8db0d0263d369ad595426/" rel="bookmark">
			caffe学习：Faster-RCNN调试及训练自己的数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考官方的安装教程的同时，注意一些细节，由于我的服务器上之前跑openpose，因为Anaconda包含与Caffe不兼容的Protobuf版本，所以一直不敢装anaconda。但是跑Faster-RCNN的时候又发现自己安装的python环境，那些第三方库又老是出现不兼容的问题，无奈我还是得投奔anaconda的怀抱，经过了解anaconda还可以装虚拟环境，真的很强大。废话不多说了，开始动工~
Faster-RCNN官方教程：https://github.com/rbgirshick/py-faster-rcnn#requirements-software
运行环境：Ubuntu14.04，Caffe，cudnn，cuda8.0
由于我的环境都是现成的，所以直接上手运行demo。
一、运行demo 1、命令行下载Faster R-CNN # Make sure to clone with --recursive git clone --recursive https://github.com/rbgirshick/py-faster-rcnn.git [目录] 后面加一个目录，就可以克隆到你想放的目录下来；我就把文件下载到了py-faster-rcnn文件里。
2、拷贝并修改Makefile.config文件
cd $FRCN_ROOT/caffe-fast-rcnn cp Makefile.config.example Makefile.config 注意FRCN_ROOT是你下载的文件总目录。
下面修改Makefile.config文件
# In your Makefile.config, make sure to have this line uncommented WITH_PYTHON_LAYER := 1 # Unrelatedly, it's also recommended that you use CUDNN USE_CUDNN := 1 因为使用Anaconda带的库进行make.将 Makefile.config 里面的设置修改为：
ANACONDA_HOME := $(HOME)/anaconda2 PYTHON_INCLUDE := $(ANACONDA_HOME)/include \
$(ANACONDA_HOME)/include/python2.7 \
$(ANACONDA_HOME)/lib/python2.7/site-packages/numpy/core/include \
PYTHON_LIB := $(ANACONDA_HOME)/lib
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b25c68a7e8a8db0d0263d369ad595426/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c07f1ca1316f46079961601b200cebc0/" rel="bookmark">
			单点登录 和springSecurity整合 获取登录名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String name = SecurityContextHolder.getContext().getAuthentication().getName();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75397d0ebedf858d75027b2dfb9acf71/" rel="bookmark">
			Python爬虫时翻页等操作URL不会改变的解决办法--以爬取携程景点点评信息为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求：
需要爬取携程的五四广场景点主页的用户点评信息。
二、爬虫时可能遇到的问题：
评论信息虽然可以在该页的源代码中获取到：
但是存在许多问题，例如：
1、评论翻页、修改评论排序方式（智能排序、有用数排序、按时间排序）并不会改变当前页的URL。
2、使用Fiddler等的抓包工具，虽然能够找到该网页用来进行评论数据传输的文件AsynCommentView的URL，但是发现翻页以及修改评论排序方式同样不会改变URL。
3、得出结论，评论信息是“动态加载的”。
三、问题分析：
1、观察景点页面的源代码，注意到关键代码：
这行代码直接说明了，该网页的评论信息是通过POST服务的形式，向评论数据传输文件AsynCommentView的URL发送POST请求，然后获取返回的评论数据。
2、通过Chrome内核浏览器的F12工具，切换到network查看一下传输的内容，首先清空内容避免干扰，然后点击翻页或者切换排序方式，切换到Headers我们可以看到：
发送的请求信息无处遁形~
4、那么问题来了，请求的内容参数该如何设置呢？
（1）order以及pagenow：顾名思义，是排序方式（按时间：1 ，有用数：2，智能：3）以及当前页码。
（2）star、tourist：测试发现使用0.0即可。
（3）poiID、districtId、districtEName、resourceId、resourcetype：无法轻易判断，但是通过观察网页源代码：
发现源代码帮了大忙，他会把默认的参数储存，可以通过爬取这些参数来进行填充。
3、因此可以初步思考爬虫的解决思路：即使用自动模拟HTTP请求来解决，具体可参考我的另一篇博客：
Python数据爬虫学习笔记（5）自动模拟HTTP请求
三、编写代码：
import re import urllib.request import urllib.parse #模拟浏览器 headers=("User-Agent","Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.26 Safari/537.36 Core/1.63.6726.400 QQBrowser/10.2.2265.400") opener=urllib.request.build_opener() opener.addheaders=[headers] urllib.request.install_opener(opener) #设置URL为当前景点页面并获取内容 baseUrl="http://you.ctrip.com/sight/Qingdao5/5326.html#ctm_ref=www_hp_bs_lst" pagedata=urllib.request.urlopen(baseUrl).read().decode("utf-8","ignore") #爬取页面中的POST参数信息并进行处理 poiIDPat='var poiid = "(.*?)"' districtIdPat='var districtid = "(.*?)"' districtENamePat='var districtename = "(.*?)"' resourceIdPat='var resourceid = "(.*?)"' resourcetypePat='var resourcetype = "(.*?)"' poiID=int(re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75397d0ebedf858d75027b2dfb9acf71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4d5e83e2991fbcbbbf63286d26f7643/" rel="bookmark">
			@Deprecated注解功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里的java开发手册，其中有一个OOP规约（网上百度了一下，这个规约是阿里自己制定的），其中有一条：
外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加 @Deprecated 注解，并清晰地说明采用的新接口或新服务是什么。 这其中提到了 @Deprecated 注解，在之前的开发过程中没遇到过这个注解，于是查了下他的功能： 简单来讲就是，若某类或某方法加上该注解之后，表示此方法或类不再建议使用，调用时也会出现删除线，但并不代表不能用，只是说，不推荐使用，因为还有更好的方法可以调用。 或许有人会问 为什么会出现加这个注解呢，直接在写方法的时候定义一个新的不就好了吗？ 因为在一个项目中，工程比较大，代码比较多，而在后续开发过程中，可能之前的某个方法实现的并不是很合理，这个时候就要新加一个方法，而之前的方法又不能随便删除，因为可能在别的地方有调用它，所以加上这个注解，就方便以后开发人员的方法调用了。 作者：SalineJ
来源：CSDN
原文：https://blog.csdn.net/alinekang/article/details/79314815
版权声明：本文为博主原创文章，转载请附上博文链接！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eff3e92574aaff41533b1fa49262f2d0/" rel="bookmark">
			操作系统 管程机制--解决写者优先问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		管程机制--解决写者优先问题 读者写者问题经典的同步机制问题之一。
所谓写者优先的优先性体现在一批读者的写操作上。意思是说当有写者在执行写操作，后面有等待写的写者，则读者会一直等待。
也是说这一波写者会连续进行写操作，这波写操作结束之后唤醒读或者写都可以。优越性体现在一波上。
来看下实现代码：
管程机制：
moniter reader_writer{
int write, read; //管程的局部变量。
Condition r,w; //进行同步机制的条件变量
Entry start_read() {
if(write&gt;0) {
r.wait(); //判断是否有写者在写。
}
read++;
r.signal();
}
Entry end_read() {
read--;
if(read==0) w.signal(); //一波读者读完才能唤醒写者.
}
Entry start_write() {
write++; // 一波写者进行写操作，其它读者或写者被同步阻塞
if(write&gt;0||read&gt;0)
{
w.wait();
} //等待写者写完或者一波读者读完。 }
Entry end_write() {
write--;
if(write==0) {
w.signal();
r.signal() //此时唤醒读者写者都可以，因为一波写者已经写完了。
}
}
}
读者进程执行读操作调用start_read
读完之后调用end_read
写者进程执行写操作调用start_write
写者进程执行完写操作调用end_write
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e0c18881bdefbeb8b51de3609c3d57a/" rel="bookmark">
			csr_matrix矩阵压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		scipy库中的sparse.csr_matrix可对稀疏的np.array进行压缩处理，有两种方式：csr(Compressed Sparse Row marix) 和 csc(Compressed Sparse Column marix)。下面通过两个最常见的栗子说明一下。
scipy.sparse.csr_matrix　按行进行压缩
&gt;&gt;&gt; indptr = np.array([0, 2, 3, 6]) &gt;&gt;&gt; indices = np.array([0, 2, 2, 0, 1, 2]) &gt;&gt;&gt; data = np.array([1, 2, 3, 4, 5, 6]) &gt;&gt;&gt; csr_matrix((data, indices, indptr), shape=(3, 3)).toarray() array([[1, 0, 2], [0, 0, 3], [4, 5, 6]]) 解释说明：
indptr： 代表每行中有多少个不为0的值，其中第一项0是固定的，第2项与第一项的差值表示第0行有2-0个不为0的值，第3项与第2项的差3-2=1表示第1行有一个不为0的值，依次类推
indices： indptr指明了每行有多少个非0项，indices则指定每行究竟是那几列不为0，例子中第0行有2个非0，则对应indices中前两项，即0,2两列不为0，第1行有1个非0，则对应indices中的2列不为0，依次类推
data： 则代表这些不为0的值具体是什么值，例子中第0行的0,2两列不为0，即对应data中的1,2两个值，第1行的2列不为0，则对应data中的3这个值。
.toarray()将压缩后的数据又转成了array形式，其中压缩后的数据形式如下：
feature = csr_matrix((data, indices, indptr), shape=(3, 3)) print (feature) 输出为： (0, 0) 1 (0, 2) 2 (1, 2) 3 (2, 0) 4 (2, 1) 5 (2, 2) 6 第一行(0, 0) 1表示第0行第0列值为1，其它同理 scipy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e0c18881bdefbeb8b51de3609c3d57a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97d560ed8371ef8ce3726dc61a12abd9/" rel="bookmark">
			fastDFS多线程并发执行出现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		--------------------- 原作者：Java高级开发 来源：CSDN 原文：https://blog.csdn.net/hang1995/article/details/79242571 前一段时间，业务部门同事反馈在一次生产服务器升级之后，POS消费上传小票业务偶现异常，上传小票业务有重试机制，有些重试三次也不会成功，他们排查了一下没有找到原因，希望架构部帮忙解决。
公司使用的是FastDFS来做的图片服务器，生产使用了六台服务器外加一个存储，集群采用的是：2个tracker+4个storage，storage分为两个group，使用独立的nginx做文件代理访问。各软件版本信息如下：
操作系统：centos6.9 FastDFS ：5.05 libfastcommon：1.0.36 nginx ：1.7.9 fastdfs-nginx-module：1.16 为了尽可能的模拟生产，我在测试环境1:1搭建了一套和生产一样的FastDFS集群，当时也写了搭建过程：FastDFS 集群 安装 配置
从日志中找线索
业务部门同事反馈，在一次生产服务器升级之后，重新搭建了一套FastDFS集群，然后过了几天就开始出现上传小票偶尔失败的问题。根据这些信息的反馈，我怀疑是否是FastDFS搭建有问题？这个怀疑点差点把我带到沟里去。
我拉取了FastDFS的日志，tracker服务器日志如下：
[2017-09-19 09:13:52] ERROR - file: tracker_nio.c, line: 306, client ip: 192.168.0.1, pkg length: 15150 &gt; max pkg size: 8192 [2017-09-19 10:34:57] ERROR - file: tracker_nio.c, line: 306, client ip: 192.168.0.1, pkg length: 16843 &gt; max pkg size: 8192 [2017-09-19 10:34:57] ERROR - file: tracker_nio.c, line: 306, client ip: 192.168.0.1, pkg length: 16843 &gt; max pkg size: 8192 [2017-09-19 11:31:08] ERROR - file: tracker_nio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97d560ed8371ef8ce3726dc61a12abd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edbaf55125f66dfc627f646716134740/" rel="bookmark">
			免费代理网址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.66ip.cn/ 66免费代理网
http://www.proxy360.cn/Region/China proxy360代理网
http://www.goubanjia.com/free/gngn/index.shtml 转载于:https://www.cnblogs.com/liu-kun/p/9857104.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61113374b1cc2ad3e0e3e0b472a17051/" rel="bookmark">
			SOLR7实践(一)--安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装@SOLR7实践(一)
刚做完一个搜索引擎项目，记录一下备忘。
安装 系统部署在某运营商内网，操作系统是Linux Red Hat 6。
一、准备工作 确认所需CPU、内存、存储、操作系统、数据库和网络等各种资源(只列出相关命令不再截图了)。
CPU
参考命令 cat /proc/version内存
参考命令 top存储
参考命令 dh -lh操作系统
1)版本
参考命令 cat /proc/version
2)用户
参考命令 id -u solr数据库网络
参考命令 ssh -v -p 端口 IP地址 以上资源确认与申请的一致，下面可以开始安装了。
二、安装 按照客户对服务器的管理要求，不能使用root用户进行软件的安装配置，申请了solr用户和sudo权限。
1.JDK 1) 获取安装包 wget --no-check-certificate --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" http://download.oracle.com/otn-pub/java/jdk/8u162-b12/0da788060d494f5095bf8624735fa2f1/jdk-8u162-linux-x64.rpm 无网络的话需将安装包拷贝到服务器。
2) 安装JDK sudo rpm -ivh jdk-8u162-linux-x64.rpm 3) 确认JDK java -version 2.SOLR 1) 获取安装包 wget http://mirrors.hust.edu.cn/apache/lucene/solr/7.1.0/solr-7.1.0.tgz 无网络的话需将安装包拷贝到服务器。
2) 解压安装脚本 tar zxf solr-7.1.0.tgz solr-7.1.0/bin/install_solr_service.sh --strip-components=2 3) 安装SOLR sudo .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61113374b1cc2ad3e0e3e0b472a17051/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/644dd374cd02771b1e8551014eb6b27f/" rel="bookmark">
			springboot&#43;springsecurity&#43;mybatis&#43;JWT&#43;Redis 实现前后端离（实战篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在开头：这篇是实战篇，即默认各位看官具备相应的基础
目录
一、springboot
1.新建项目
2.application.yml的配置
3.写一个小demo
二、druid
三、springsecurity
1.引入相关依赖
2.写了几个工具类
3.实现springsecurity各个核心接口，处理用户各种状态
2.权限访问控制
3.jwt生成token的工具类
4.springsecurity核心处理
一、springboot 1.新建项目 我是用idea，jdk选择1.8以上 各个名字自行命名 添加部分依赖，后面再往pom.xml加入（这里忘记改了，springboot的版本我使用的是1.5.3release版本！） 简单的项目搭建好了，下一步 2.application.yml的配置 数据源 spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost/springboot?characterEncoding=utf-8&amp;useSSl=false driver-class-name: com.mysql.jdbc.Driver 数据池用了druid，pom.xml加入依赖 &lt;!-- druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.8&lt;/version&gt; &lt;/dependency&gt; 添加mabatis、druid，完整配置： spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost/springboot?characterEncoding=utf-8&amp;useSSl=false driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #监控统计拦截的filters filters: stat,wall,log4j #druid配置 #配置初始化大小/最小/最大 initialSize: 5 minIdle: 5 maxActive: 20 #获取连接等待超时时间 maxWait: 60000 #间隔多久进行一次检测，检测需要关闭的空闲连接 timeBetweenEvictionRunsMillis: 60000 #一个连接在池中最小生存的时间 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false #打开PSCache，并指定每个连接上PSCache的大小。oracle设为true，mysql设为false。分库分表较多推荐设置为false poolPreparedStatements: false maxPoolPreparedStatementPerConnectionSize: 20 # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid: stat: mergeSql: true slowSqlMillis: 5000 #mybatis是独立节点，需要单独配置 mybatis: mapper-locations: classpath*:mapper/*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/644dd374cd02771b1e8551014eb6b27f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c01b2f7bdcd5825080153b505810b1/" rel="bookmark">
			常见的标点符号的英文读法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收集整理常见的标点符号的英文读法,方便特殊符号问题的网上搜索.
中文名符号英文名备注句号. full stop 逗号, comma 冒号: colon 分号; semicolon 问号? question mark 叹号! exclamation mark exclamation point (美式英语)撇号' apostrophe 连字号- hyphen 破折号-- dash 省略号...dotsellipsis 斜杠/ slash 反斜杠\ backslash 单引号"single quotation marks 双引号""double quotation marks 双线号‖ parallel 连接和号&amp; ampersand = and代字号～ swung dash 分节号§ section; division 箭号；参见号→ arrow
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0f3ea97eb2d46fb86cd956cb4a959fd/" rel="bookmark">
			阳振坤：OceanBase如何跨越关系数据库的“死亡之谷”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OB君：2018年10月15日，北京交通大学计算机与信息技术学院第71期CIT名师大讲堂在第九教学楼中心报告厅举行。蚂蚁金服高级研究员、OceanBase团队负责人阳振坤在本次学术报告中发表了题为 《OceanBase：跨越关系数据库的死亡之谷》的主题演讲。阳振坤向同学介绍了OceanBase从创新到产品的飞跃式发展，分享了互联网时代下技术和产品如何跨越“死亡之谷”的经验和心得。 数据库：技术和市场的“死亡之谷” 数据库在每个人的生活里无处不在，不管是通讯、交通、金融行业，抑或是每天大家都在接触的互联网，所有这些业务的背后都是数据库在支撑。
蚂蚁金服OceanBase团队负责人阳振坤 数据库经历了近半个世纪的发展，在理论上很成熟，在技术应用上也已经非常成熟了。但是数据库偏偏有一个特别高的门槛，原因是数据库有三条特别苛刻的要求：
事务须并发处理：数据库要支持事务，所有人都希望用最小的处理资源，做到最大价值的事情。所以事务持续要做大量的并发处理。数据一条不能错：一个数据库如果数据错了，就永远没有机会了。对于使用者而言，如果你会错一条，你就有可能会错一千、一万条，这是没有公司愿意承担的风险。服务片刻不能停：通讯系统、列车系统，甚至飞机航行系统的背后都是数据库在支撑，这些系统一旦启动，一分一秒都是不能终止的。 上面提到的这三条要求，任何两个其实都好满足。但是大家仔细想一想，这三个要求如果要同时满足，就会变得极其困难。
同时，数据库又是一个巨大的市场，对国家、对整个社会都非常重要。这就导致很多国家、很多企业都想做也正在做这件事，但是结果大家都做到了同一个思路上。后来者都成了先行者的模仿者，那么这个模仿的代价就会变得很大。
今天作为一个后来者，你再去做这么一套数据库系统的时候，就真的很难说清楚你与先行者相比有多大的优势。这也就造成了强者恒强、寡头垄断的局面，后来者很难居上。
数据库同样也有开源这条路径，比如大家都了解的MySQL。开源是免费的，对于很多对成本敏感的公司而言开源数据库成为了替代商业数据库的另一种选择。
那么在面对数据库的“死亡之谷”这样的困境下，为什么我们还去花这么多钱，投入这么多设备，花这么多年时间和人力再去做一个数据库，究竟它的意义在哪儿？它又能够产生多大的经济价值？
既然有了开源的数据库，阿里巴巴和蚂蚁金服还要做这么一个商业数据库产品，其实这里面是有本质原因的。很多人知道阿里巴巴今天已经全面去IOE：去掉了Oracle数据库、IBM小型机、 EMC存储。那么很多人就在想，能不能在其他的行业，在铁路、交通，电信、政府这些行业推而广之，全部完成去O的进程呢？这个答案是否定的。
因为像阿里巴巴发展的这一套系统是基于MySQL的开源数据库，跟商业数据库在功能和性能上其实是有很大差距的。阿里巴巴当时在用它的时候，有很多事情数据库是做不了的，那么这些做不了的事情当时就放在应用软件里做。所以阿里巴巴在数据库和应用软件上都投入了很大的技术力量。这套系统拿到外部业务去用是不能彻底解决问题的。本质上这套系统是服务于阿里巴巴的专用系统，而不是一个通用的系统。
那么有人会问，在我的企业里，如果真的想去掉IOE，该怎么办？你同样要投入两拨人，一拨人要去做数据库，针对你的企业的需求来做相应的修改；还有一拨人要去做应用系统。但是问题是并不是所有的企业都像阿里巴巴有这么多优秀的技术人员，这套东西其实很难去直接推广应用。
所以，从一开始我们做OceanBase的目标就是——我们不想只做一个专用的系统，要做就一定要做一个通用的系统。我们希望今后OceanBase能够服务于各行各业，再也不需要企业投入几十几百甚至几千个人去改造、去重新做一套业务系统。
OceanBase的机遇与创新 当时做OceanBase数据库一个最根本性的原因就是需求的变化。因为这么一套基础系统，如果背后没有需求的变化，从0到1自己做出来基本是不可能的。
2010年春夏之际，我来到了阿里巴巴。去了之后发现当时有两个因素影响了阿里巴巴关系数据库的应用。
一个因素是并发，数据库它是按照并发量来卖钱的。说直接点，就是按照处理器来卖钱。之所以要买这么多处理器就是因为业务有这么大的需求。那么传统的业务比如商场，一个商场就那么几个收银台，它是一个相对稳定而且比较小的并发量，大多数情况就是几十几百的并发量。
阳振坤分享经验心得 随着互联网的高速发展，阿里巴巴天猫双11几乎完全改变了过去行业内相对稳定的并发量，突破了几百万人甚至是千万人的同时在线购买。这个并发量跟过去的传统业务场景相比是几个数量级的增长，按照这个数量级去买商业数据库，没有一家企业买得起。
还有一个因素，当时我们叫它建站，其实就是搭建一个数据库。过去建一个商场，建一个银行的分店，这个周期是非常长的，有足够的时间来规划IT业务系统。互联网业务是等不了的，就像当时OceanBase接的第一个业务给到我们的时间就是最多一个星期。现实是一个星期的时间根本连小型机的安装调试都完不成。
原来的模式已经完全无法支撑互联网快速发展的业务。所以这两个需求的变化，是催生我们自己来做数据库的很关键的因素。
OceanBase关键性的技术革新 当时我找了几个同事商量这个事情，我跟大家说，我们是天时地利人和都赶上，这件事情除非是被拍死掉，否则我们是肯定要把它做成的。这个过程真的非常艰辛，我们花了差不多五年的时间，才真正让OceanBase有了关键的应用。
过去做数据库的公司，不管是国内还是国外，大家都是为了做数据库而做数据库，那么最后结果就是所有做传统数据库的厂商，大家的方案都很像。
因为数据库有很成熟的理论和工程的方法，那么如果我们按照以往的原则做过去，结果肯定也是一样的。所以，其实我们走了另外一条路——做分布式。最早做这个东西可能都不叫数据库，它更像是一个分布式系统，但是支持了事务的特性。这条路后来被证明确实是具有特别大的价值和意义。
当时我们在做OceanBase的时候，首先确定了几件事情。第一件事就是我们要做分布式，因为我们的业务要建站，不做分布式靠大型机和小型机是不可能做得到的。
另外一件事是成本，什么东西最便宜，量最大最主流的东西最便宜，它就是PC服务器。小型机少则几十万，多则几百万，PC服务器顶多就是几千几万块的成本。
第三个要解决的就是可靠性问题。大家对数据库的期望是永不宕机，永远不出问题。可是PC服务器到处都有，性价比也非常好，但是不容忽视的是它的故障率高。普通PC服务器它远远达不到数据库所要求的年可靠性五个九的要求。对普通PC服务器而言，差的可能是两个或者三个数量级，所以我们得首先把这个问题解决掉。我们用的就是分布式的办法来解决。
我们运用的是分布式的一致性协议，直白一点就是一个多数派的选举和投票协议。同时，我们把修改的增量直接放在内存里，每次要查询的时候，把内存硬盘的数据做一个merge，那么每天在业务相对的低谷期，再把内存中的数据整理回硬盘去。
做到了这几件事情，这个系统就有了很好的性价比，我们的成本比传统的数据库至少低一个数量级，你只需要用普通的PC机，不需要用昂贵的硬件设施。同时，扩展能力会也变得很好。
OceanBase的第一个业务：淘宝收藏夹 理想看起来很美好，但是现实特别骨感。这个项目刚启动的时候，我们好不容易才找到了几个人，人手是严重不足的。另外一个更大的挑战是时间：在做OceanBase数据库之前，我去找我的老板，他说给你两年时间如果能把一个数据库做出来就可以。当时我心里想两年虽然对于做数据库来说时间确实太短，但是这两年对于那时候的我们而言已经足够支撑起最初的想法了。
技术最终还是需要通过业务落实下去，所以我找了一批业务方，花了很长时间跟对方沟通，最后终于有一个业务愿意用我们的数据库。当时他给我的时间期限是——两个星期。
当时我就傻了，两个星期要做个数据库，这可怎么办？后来跟业务的同学反复讨论，最后他们同意说，你们先做个demo出来。于是我们就花了两个月吭哧吭哧的做了一个demo出来。他们看了以后觉得比较满意，后来这个事情就一直坚持做下去了。
最后，我记得是到了第八个月的时候，系统上线了。这个业务就是现在大家都在用的——淘宝收藏夹，这是OceanBase的第一个业务。如果没有这个业务，我们现在也活不下来。
淘宝收藏夹业务
那么这个业务到底有什么特殊的地方？每个人都用过淘宝收藏夹，每次你打开收藏夹的时候，数据库在背后其实做了很多事情：我们以单个商品为例，它需要到一个叫商品库的地方，逐条纪录核对，看看商品有没有下架，有没有参与促销，有没有参加其他的返点活动等等。
假如你收藏了100多件商品，它就要进去一条条的取出来看。本质上来讲，这就意味着一百多次的随机IO。那么当很多人同时来看的时候，其实一个IO就被放大了几百倍，这时候有多少个硬盘都不够用。
当时他们已经用了几十台服务器了，按照业务的预估，第二年他们要买400台机器，第三年的数量都不敢想象。当时我们想了一个办法——我们做了一个宽表，确切的讲应该称为物化视图。
淘宝收藏夹的宽表 首先我们把每个用户收藏的信息聚集起来，这样可以减少IO，然后把收藏的商品放在这个列表里。但是我们怎么避免去访问一百多次IO呢？我们的办法就是找到一个时间点，当时是设定在每天晚上凌晨两点。在这之前，我们就把这些信息全部merge到硬盘，然后从两点开始，我们把新的修改都放在内存里面。
所以每到两点的时候，我们把两点之前所有的信息都合到这张表里，那么这张表里的信息在两点整的时候是准确的，这时候我们不需要去访问商品库。两点之后的修改，包括商品库的修改是在内存里进行的，这时候如果要看这些商品有哪些修改，商品只需访问内存中的更新即可。
所以其实我们就是通过这样一个手段，把每次收藏夹的展示，由原来的一百多次IO变成了一次。我们一下子就把淘宝收藏夹业务的整个IO降下来了。当时OceanBase确实是帮助业务实际解决了他们的问题，使得业务能够更好的快速的发展。业务是一定要发展的，所以只有我们真正能够解决他们的问题，我们这些做基础系统做底层的人，才能活下去。
淘宝收藏夹架构图 这是当时给淘宝收藏夹做的一个架构，中间是一个做修改的服务器，所有的修改都在这一台机器上进行。旁边的机器是基线数据，就是分片切片以后，放到周围这一圈进行。所以当时我们就用这个看上去很简陋的一个方案来真正解决了淘宝收藏夹的问题。
当时收藏夹用了这个方案之后，服务器的数量从原来预计的第二年要用几百台，最后其实只用了差不多二十几台服务器，就把整个问题解决掉了。
OceanBase 0.3-0.4版本：团队面临解散 从淘宝收藏夹项目之后，我们陆陆续续也做了不少项目，但是没有一个项目能像淘宝收藏夹这样对业务有明显的价值和贡献。
从那之后的整整两年，我们找不到对OceanBase数据库而言特别有价值的业务。那两年对于我们而言特别特别困难，甚至整个团队随时面临着解散。
2012年底，公司把我们从淘宝调到支付宝，当时预估到支付宝在数据库方面所面对的挑战更大，后来证明确实如此。即使是这样，当时仍然还处在一个非常困难的时期。到了支付宝一年多的时间，我们仍然很难找到新的业务，或者说价值比较大的业务来证明我们的价值。
OceanBase 0.5版本：成功抗住10%流量 2013年的夏天，支付宝希望全面去掉IOE——去掉IBM的小型机，Oracle的数据库和EMC的存储。当时面临了一个问题，就是去掉之后是可以用MySQL来代替Oracle，但是MySQL的主备镜像其实是做不到主备完全一致的。
这个时候我们意识到：OceanBase的机会来了。因为我们可以通过分布式的选举跟投票来做，哪怕硬件本身不可靠，我们也能保证数据的不丢失。传统数据库本质上是借助硬件的可靠性，也就是硬件需要达到五个九的可靠性来实现高可用的。就算出了故障，它的数据也能救得回来。但是这种手段需要非常高的成本，同时没有足够的扩展能力。
银行虽然有很高的可用性，但是它的高可用性是用很高的硬件成本换来的。我们建议一定要淘汰这些高可靠的硬件，因为他们的成本实在太高了。一旦真的使用了高性能，高性价比的PC服务器，那么你就不可能再花那么多钱去买高端的硬件。
所以我当时心里很明白，如果这件事情我们做不成，这个项目就只有死路一条。
那么，OceanBase到底如何做到主备完全一致的呢？理论上我们也没有办法说完全做到主库备库的一致。我们用了另外一个办法：主库还是主库，还是需要它快速的做事务，但同时主库还要把事务的日志同步给至少两个备库。两个备库中至少有一个收到了，那么加上它自己就超过了半数，或者我们叫多数派。当多数的节点收到了这个事务，并且把它持久化到硬盘了，我们就认为这个事务是成功的。
所以这时候任何一台机器坏掉，每笔事务在剩下两台机器里面至少一台存在。所以说即使主库突然坏掉，另外两台机器经过握手，它们再选举出一个新的主库，那么肯定可以继续工作下去，同时可以保证数据是没有损失的。
2014年的时候，我们在会议室里讨论支付宝交易库的上线，当时吵得面红耳赤，争论了很久别人就是不愿意上OB。他们原来的交易、支付系统全都在Oracle上，当时的Oracle无论是在稳定性、可靠性还是性能方面，肯定比OceanBase要好得多。所以没有人愿意用。
最后，在鲁肃的力挺下决定切给 OceanBase 1%的流量试试。因为那几年业务发展的太快，当时Oracle的共享存储已经扛不住这个流量，按照当时的业务流量去做压测的时候，几分钟就要坏一块盘。最后发现，把业务切掉10%，才能勉强扛得住。所以那一年的双11就把10%的流量切到了OceanBase。OceanBase也成功扛过去了那一年的双11。
OceanBase 1.0版本：唯一支持分布式事务的商业数据库 但是其实在0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0f3ea97eb2d46fb86cd956cb4a959fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7afae98ba815ea990c77491db448b29c/" rel="bookmark">
			Centos/Linux下如何查看网关地址/Gateway地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ifconfig -a //看netmask ,dns
netstat -rn //看网关
参考 https://blog.csdn.net/zljjava/article/details/48345653
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4411f9bcd81539e5b22e8bd3169e3d6e/" rel="bookmark">
			在python中用tkinter.filedialog以选择文件对话框的格式打开和保存图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tkinter.filedialog.asksaveasfilename() # 选择以什么文件名保存，返回文件名 tkinter.filedialog.askopenfilename() # 选择打开什么文件，返回文件名 有时候我们想要以选择文件对话框的格式打开一张图片或者保存图片，我在尝试之后把我的代码分享给大家作为参考：
打开一张图片并显示 root = tkinter.Tk() # 创建一个Tkinter.Tk()实例 root.withdraw() # 将Tkinter.Tk()实例隐藏 default_dir = r"文件路径" file_path = tkinter.filedialog.askopenfilename(title=u'选择文件', initialdir=(os.path.expanduser(default_dir))) image = Image.open(file_path) plt.imshow(image) plt.show() 只需要在弹出对话框后选择要打开的图片就可以了。如下图所示：
保存图片 fname = tkinter.filedialog.asksaveasfilename(title=u'保存文件', filetypes=[("PNG", ".png")]) picture.save(str(fname) + '.png', 'PNG') 只需要在弹出对话框后选择保存位置，输入图片名字即可。如下图所示：
【注】如果不加以下两行代码：
root = tkinter.Tk() # 创建一个Tkinter.Tk()实例 root.withdraw() # 将Tkinter.Tk()实例隐藏 程序运行后将会出现以下一个小框：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30acca272b8af9f9e133422e5c00dccb/" rel="bookmark">
			Linux回车总会出现：&#43;&#43; printf &#39;\033]0;%s@%s:%s\007&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在终端窗口输入任何命令或者运行任何脚本，发现每次按回车都会一条类似下面这样的输出都会出现：
++ printf ‘\033]0;%s@%s:%s\007’
后来发现是因为在终端窗口输入了set -x，或者是在终端窗口source 其他文件时，该文件中包含set -x，反正就是都是因为在终端窗口输入了set -x，所以再输入set +x即可取消回车后有++ printf '\033]0;%s@%s:%s\007’的输出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b0b7e4c7d7562c6c462527b4a8863f3/" rel="bookmark">
			ClassNotFoundException和NoClassDefFoundError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ClassNotFoundException和NoClassDefFoundError ClassNotFoundExceptionNoClassDefFoundError解决方案最后总结 最近工作中发现老是有同事遇到NoClassDefFoundError以及ClassNotFoundException这两种异常，很对人对此比较困惑，于是研究了一下并整理了此文档，希望对大家有所帮助。 ClassNotFoundException这个比较好理解，就是找不到类。其直接原因是：当应用调用类的forName方法、调用ClassLoader的findSystemClass方法、调用ClassLoader的loadClass方法时找不到指定的类。
NoClassDefFoundError这个比较容易让人疑惑些，其直接原因是：当Java虚拟机或者ClassLoader实例试图加载类时，类却找不到了，但是在编译期是没有问题的，只是在运行期找不到。
那么该如何理解它们？
ClassNotFoundException 对于ClassNotFoundException理解起来比较简单直接，就是在运行时调用诸如Class.forName等方法，将类的全限定名称作为参数，但是在运行时找不到这个名称的类。
比如，当我们没有依赖JDBC包的情况下试图加载JDBC驱动，就会抛出这个异常：
@Test(expected = ClassNotFoundException.class) public void givenNoDrivers_whenLoadDriverClass_thenClassNotFoundException() throws ClassNotFoundException { Class.forName("oracle.jdbc.driver.OracleDriver"); } 当然还有一些其它情况，最常见的是没有依赖相关jar包，其他如类名写错了，类名不合法，类没有放到classpath上等等。还有一点就是ClassNotFoundException是一个可检查异常，它直接继承自Exception类。
下面这段是JDK源码注释，大家可以参考一下：
public class ClassNotFoundException extends ReflectiveOperationException (extends Error)
Thrown when an application tries to load in a class through its string name using:
- The forName method in class Class.
- The findSystemClass method in class ClassLoader .
- The loadClass method in class ClassLoader.
but no definition for the class with the specified name could be found.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b0b7e4c7d7562c6c462527b4a8863f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d018929da3896009dd030d3d714bee8f/" rel="bookmark">
			docker 容器中不支持中文的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		某日在docker里搭建了一套MySQL服务，发现在MySQL命令行内无法输入中文 中文显示也以?代替，起初以为是MySQL字符集的问题 检查之后未解决问题，又退出到容器终端 发现同样不能输入中文，由此推断 是系统字符集出现问题，现将解决过程记录如下：
未解决前:
# 进入容器 查看字符集
[root@master2 ~]# docker exec -it b18f56aa1e15 /bin/bash
root@b18f56aa1e15:/# locale
LANG=
LANGUAGE=
LC_CTYPE="POSIX"
LC_NUMERIC="POSIX"
LC_TIME="POSIX"
LC_COLLATE="POSIX"
LC_MONETARY="POSIX"
LC_MESSAGES="POSIX"
LC_PAPER="POSIX"
LC_NAME="POSIX"
LC_ADDRESS="POSIX"
LC_TELEPHONE="POSIX"
LC_MEASUREMENT="POSIX"
LC_IDENTIFICATION="POSIX"
LC_ALL=
# 查看容器支持的字符集
root@b18f56aa1e15:/# locale -a
C
C.UTF-8
POSIX
不能输入中文原因：系统使用的是POSIX字符集，POSIX字符集是不支持中文的，而C.UTF-8是支持中文的 只要把系统中的环境 LANG 改为”C.UTF-8”格式即可解决问题
只要这样进入容器即可输入中文: docker exec -it b18f56aa1e15 env LANG=C.UTF-8 /bin/bash
[root@master2 ~]# docker exec -it b18f56aa1e15 env LANG=C.UTF-8 /bin/bash
root@b18f56aa1e15:/# 你好
root@b18f56aa1e15:/# mysql -uroot -p
Enter password: Welcome to the MySQL monitor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d018929da3896009dd030d3d714bee8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c93ee436b261bf96ced4f146a2263193/" rel="bookmark">
			If this view is optional add &#39;@Nullable&#39; (fields) or &#39;@Optional&#39; (methods) annotation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将@Nullable注释添加到字段中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f438e41b516239166f11fae3a9cb2997/" rel="bookmark">
			springmvc处理ajax请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springmvc与ajax的交互在实际开发中十分常见，以下是对springmvc与ajax交互时参数的传递与接收做的一些整理
jsp页面：
&lt;form id="login" style="width:600px; border:1px solid #000;border-left:none;border-right:none"&gt; &lt;p align="center"&gt;账号：&lt;input type="text" id="username" /&gt;&lt;/p&gt; &lt;p align="center"&gt;密码：&lt;input type="password" id="password" /&gt;&lt;/p&gt; &lt;p align="center"&gt;&lt;input type="submit" id="submit" value="登录" /&gt;&lt;/p&gt; &lt;/form&gt;在这里插入代码片 一、ajax请求如下：contentType：application/x-www-form-urlencoded
发送的数据格式为“A=xxx&amp;B=xxx”data数据不是json对象
$(function(){ $("#submit").click(function(){ $.ajax({ type: "POST", //contentType : 'application/x-www-form-urlencoded',//默认类型 url: '${pageContext.request.contextPath}/databind/json', dataType: "json", data: {username:$('#username').val(), password:$('#password').val()}, success: function(data){ alert('username : '+data.username+'\npassword : '+data.password); } }); }); }); 由于contentType : ‘application/x-www-form-urlencoded’，最终参数是以username=admin&amp;password=123456这个格式传至后台，当然你也可以利用占位符直接传字符串过去（后台使用@PathVariable注解逐个接收），但是，如果项目中字段还是特别多的，这样拼接会相当繁琐，然而我们知道还有个方法供我们使用，jQuery给我们提供的**$(“#login”).serialize()序列化表单**。
$(function(){ $("#submit").click(function(){ var params = $("#login").serialize();//序列化表单 alert(params); $.ajax({ type: "POST", url: '${pageContext.request.contextPath}/databind/json', dataType: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f438e41b516239166f11fae3a9cb2997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/467b252d5287d0b0b79c9f59cd7b9c94/" rel="bookmark">
			使用beyond compare4作为Git的比较工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Git来管理我们的项目非常的方便，然而Git默认的文档比较功能看起来不够直观，所以我们通过配置文件把比较功能强大的“beyond compare4”作为Git的比较工具，这样我们就可以通过命令行调用强大的“beyond compare4”啦！步骤如下（这里默认大家已经安装了Git和beyond compare4）：
1.配置“.gitconfig”文件 首先我们找到Git的配置文件“.gitconfig”，我的文件在路径“Administrator/.gitconfig”下。使用使用文本编辑工具打开后添加下图文本，其中的cmd一栏写的是你电脑上“beyond compare4”所在的路径。这样我们就配置成功啦！
2.命令调用
配置好后我们迫不及待的想要验证一下成果，我们切到Git仓库下，更改一下文件然后先使用Git默认的文本差异工具看看效果，下图，我们输入命令“git diff”后，git默认的比较工具显示出差异信息（很强大，但不够直观）：
我们再来看看调用“beyond compare4”进行文本差异比较的结果，我们首先输入命令“git difftool readme.txt”是比较工作区和暂存区中“readme.txt”的差异，然后他会询问你是否打开‘bc4’，输入y就好。（若是输入这一命令后没有任何反应，有可能是工作区和暂存区的内容是一致的，毕竟UNIX的哲学是没有消息就是最好的消息，所以你可以尝试修改一下文件，再尝试）
接着我们就可以看到下图所示的文件比较界面，这就很直观啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2c5c47f6e82c2f95a69e0c9bf65aea7/" rel="bookmark">
			决策树算法 MATLAB 简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		决策树算法 前言 最近在数据挖掘与机器学习的课程上刚刚学到了决策树算法，于是，想自己用 MATLAB 简单实现一下。虽然拿其中最简单算法的进行实现，但是，从构思–编写–初步完成，也花费了不少时间，毕竟只有动手编写，才能真正体会到算法的内涵。
文章目录 决策树算法前言1 算法流程2 程序设计3 MATLAB 中的调用4 Python 中的调用 1 算法流程 通过阅读机器学习的书籍首先了解决策树算法的基本思想：通过递归的方式构建一棵树，子树是通过选取某一属性，按照其属性值进行划分产生的。其算法伪代码如下：
2 程序设计 程序设计必须对算法的每个细节都要搞清楚，有时可能要实现一个健全完善的算法很困难，我们可以对算法进行简化，忽略复杂的情况，比如，在上面的构建决策树算法的步骤中，子树的划分可能有多个输出，连续属性和无序离散属性的划分的方法也有所不同，如果都要将这些考虑进去程序的设计难度会很大。作为初学者，可以对问题进行简化：
假设无序离散属性都只是二元属性，属性值用0或1表示类别只有两类，用0或1表示每个节点只有两个输出 在明确了细节之后，还需考虑另外一个问题：数据结构。在程序中用什么数据结构来描述所构建的“树”？这一步很关键，因为在对训练集之外的记录进行测试的时候要用到该数据结构。
由于自己实现决策树算法的目的只是加深对算法的理解，并不是实际开发，因此，只是将“树”的结构和参数打印出来。
function build_tree(x, y, L, level, parent_y, sig, p_value) % 自编的用于构建决策树的简单程序，适用于属性为二元属性，二分类情况。（也可对程序进行修改以适用连续属性）。 % 输入： % x：数值矩阵，样本属性记录（每一行为一个样本） % y：数值向量，样本对应的labels % 其它参数调用时可以忽略，在递归时起作用。 % 输出：打印决策树。 if nargin == 2 level = 0; parent_y = -1; L = 1:size(x, 2); sig = -1; p_value = []; % bin_f = zeros(size(x, 2), 1); % for k=1:size(x, 2) % if length(unique(x(:,k))) == 2 % bin_f(k) = 1; % end % end end class = [0, 1]; [r, label] = is_leaf(x, y, parent_y); % 判断是否是叶子节点 if r if sig ==-1 disp([repmat(' ', 1, level), 'leaf (', num2str(label), ')']); elseif sig ==0 disp([repmat(' ', 1, level), '&lt;', num2str(p_value),' leaf (', num2str(label), ')']); else disp([repmat(' ', 1, level), '&gt;', num2str(p_value),' leaf (', num2str(label), ')']); end else [ind, value, i_] = find_best_test(x, y, L); % 找出最佳的测试值 % % if ind ==1 % keyboard; % end [x1, y1, x2, y2] = split_(x, y, i_, value); % 实施划分 if sig ==-1 disp([repmat(' ', 1, level), 'node (', num2str(ind), ', ', num2str(value), ')']); elseif sig ==0 disp([repmat(' ', 1, level), '&lt;', num2str(p_value),' node (', num2str(ind), ', ', num2str(value), ')']); else disp([repmat(' ', 1, level), '&gt;', num2str(p_value),' node (', num2str(ind), ', ', num2str(value), ')']); end % if bin_f(i_) == 1 x1(:,i_) = []; x2(:,i_) = []; L(:,i_) = []; % bin_f(i_) = []; % end build_tree(x1, y1, L, level+1, y, 0, value); % 地柜调用 build_tree(x2, y2, L, level+1, y, 1, value); end function [ind, value, i_] = find_best_test(xx, yy, LL) % 子函数：找出最佳测试值（可以对连续属性适用） imp_min = inf; i_ = 1; ind = LL(i_); for i=1:size(xx,2); if length(unique(xx(:,i))) ==1 continue; end % [xx_sorted, ii] = sortrows(xx, i); % yy_sorted = yy(ii, :); vv = unique(xx(:,i)); imp_min_i = inf; best_point = mean([vv(1), vv(2)]); value = best_point; for j = 1:length(vv)-1 point = mean([vv(j), vv(j+1)]); [xx1, yy1, xx2, yy2] = split_(xx, yy, i, point); imp = calc_imp(yy1, yy2); if imp&lt;imp_min_i best_point = point; imp_min_i = imp; end end if imp_min_i &lt; imp_min value = best_point; imp_min = imp_min_i; i_ = i; ind = LL(i_); end end end function imp = calc_imp(y1, y2) % 子函数：计算熵 p11 = sum(y1==class(1))/length(y1); p12 = sum(y1==class(2))/length(y1); p21 = sum(y2==class(1))/length(y2); p22 = sum(y2==class(2))/length(y2); if p11==0 t11 = 0; else t11 = p11*log2(p11); end if p12==0 t12 = 0; else t12 = p12*log2(p12); end if p21==0 t21 = 0; else t21 = p21*log2(p21); end if p22==0 t22 = 0; else t22 = p22*log2(p22); end imp = -t11-t12-t21-t22; end function [x1, y1, x2, y2] = split_(x, y, i, point) % 子函数：实施划分 index = (x(:,i)&lt;point); x1 = x(index,:); y1 = y(index,:); x2 = x(~index,:); y2 = y(~index,:); end function [r, label] = is_leaf(xx, yy, parent_yy) % 子函数：判断是否是叶子节点 if isempty(xx) r = true; label = mode(parent_yy); elseif length(unique(yy)) == 1 r = true; label = unique(yy); else t = xx - repmat(xx(1,:),size(xx, 1), 1); if all(all(t ==0)) r = true; label = mode(yy); else r = false; label = []; end end end end 利用MATLAB提供的数据集进行测试，并与 MATLAB 自身提供的决策树分类的函数进行对比。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2c5c47f6e82c2f95a69e0c9bf65aea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acbdc6053c10d5b95f7c9bc751156e0c/" rel="bookmark">
			Android中startActivity中的permission检测与UID机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们经常在一个activity中去start另一个activity，或者与另一个acitivity的结果进行交互（startActivityForResult）。但有没有想过可能会出现的permission问题呢？如果你遇到了permission denial的Exception，那么你需要读读这篇文章啦。 我们在同一个application内部，可以随意的startActivity from Activity A to Activity B，而官方的文档中说startActivity可能会报NotFoundException，表示被start的Activity不存在。因此，我们很容易忽略另一个可能的Exception，Permission Denial。 当我们在不同的application中，如application A中的Activity去start一个application B中的Activity，也许你什么Exception都不会得到，也可能会直接Force Close掉。因为再Start Activity时，代码是有去检验permission的。 如下情况，可以成功startActivity而不会得到permission denial 1、同一个application下 2、Uid相同 3、permission匹配 4、目标Activity的属性Android:exported=”true” 5、目标Activity具有相应的IntentFilter，存在Action动作或其他过滤器并且没有设置exported=false 6、启动者的Pid是一个System Server的Pid 7、启动者的Uid是一个System Uid（Android规定android.system.uid=1000，具有该Uid的application，我们称之为获得Root权限） 如果上述调节，满足一条，一般即可（与其他几条不发生强制设置冲突），否则，将会得到Permission Denial的Exception而导致Force Close。 现在，我来解释一下Uid机制 众所周知，Pid是进程ID，Uid是用户ID，只是Android和计算机不一样，计算机每个用户都具有一个Uid，哪个用户start的程序，这个程序的Uid就是那个那个用户，而Android中每个程序都有一个Uid，默认情况下，Android会给每个程序分配一个普通级别互不相同的Uid，如果用互相调用，只能是Uid相同才行，这就使得共享数据具有了一定安全性，每个软件之间是不能随意获得数据的。而同一个application只有一个Uid，所以application下的Activity之间不存在访问权限的问题。 如果你需要做一个application，将某些服务service，provider或者activity等的数据，共享出来怎么办，三个办法。 1、完全暴露，这就是android:exported=”true”的作用，而一旦设置了intentFilter之后，exported就默认被设置为true了，除非再强制设为false。当然，对那些没有intentFilter的程序体，它的exported属性默认仍然是false，也就不能共享出去。 2、权限提示暴露，这就是为什么经常要设置usePermission的原因，如果人家设置了android:permission=”xxx.xxx.xx”那么，你就必须在你的application的Manufest中usepermission xxx.xxx.xx才能访问人家的东西。 3、私有暴露，假如说一个公司做了两个产品，只想这两个产品之间可互相调用，那么这个时候就必须使用shareUserID将两个软件的Uid强制设置为一样的。这种情况下必须使用具有该公司签名的签名文档才能，如果使用一个系统自带软件的ShareUID，例如Contact，那么无须第三方签名。 这种方式保护了第三方软件公司的利益于数据安全。 当然如果一个activity是又system process跑出来的，那么它就可以横行霸道，任意权限，只是你无法开发一个第三方application具有系统的Pid（系统Pid不固定），但是你完全可以开发一个具有系统Uid的程序，对系统中的所有程序任意访问，只需再Manufest中声明shareUserId为android.system.uid即可，生成的文件也必须经过高权限签名才行，一般不具备这种审核条件的application，google不会提供给你这样的签名文件。当然你是在编译自己的系统的话，想把它作成系统软件程序，只需在Android.mk中声明Certificate:platform则可以了，既采用系统签名。这个系统Uid的获得过程，我们把它叫做获得Root权限的过程。所以很多第三方系统管理软件就是有Root权限的软件，因为他需要对系统有任意访问的权限。那么它的Root签名则需要和编译的系统一致，例如官方的系统得用官方的签名文件，CM的系统就得用CM的签名文件。（这里就不多讲了） 讲到这里，大家应该明白Uid机制了吧。^_^ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/390868616753066ef84ee7afd8bb5f93/" rel="bookmark">
			TypeError: &#39;float&#39; object is not callable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在做一道Python练习题时遇到的问题，记录一下：
请输入三个整数a,b,c,判断能否以它们为三个边长构成三角形。若能，输出YES和面积，否则输出NO
刚开始写的代码如下：
a=int(input('请输入一个整数：')) b=int(input('请输入一个整数：')) c=int(input('请输入一个整数：')) if a&gt;0 and b&gt;0 and c&gt;0: #判断边长大于0 if a+b&gt;c and b+c&gt;a and a+c&gt;b: #两边之和要大于第三边 p=(a+b+c)/2 area=(p(p-a)(p-b)(p-c))**0.5 #海伦公式求面积 print('YES') print('area=%0.2f' % area) else: print('NO') 运行时输入a,b,c三个整数后一直报错 TypeError: 'float' object is not callable
TypeError Traceback (most recent call last) &lt;ipython-input-7-f185e7350a43&gt; in &lt;module&gt;() 5 if a+b&gt;c and b+c&gt;a and a+c&gt;b: #两边之和要大于第三边 6 p=(a+b+c)/2 ----&gt; 7 area=(p(p-a)(p-b)(p-c))**0.5 #海伦公式求面积 8 print('YES') 9 print('area=%0.2f'%area) TypeError: 'float' object is not callable 调试半天突然发现该行代码中缺少星号，将代码修改为area=(p*(p-a)*(p-b)*(p-c))**0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/390868616753066ef84ee7afd8bb5f93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6a902e81360be7cea01bb7a82bd7ac0/" rel="bookmark">
			无法连接虚拟磁盘服务解决办法（亲测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给虚拟机的win7安装了office
因为是iso文件，也不知道为什么无法读取，就用了cd/dvd连接光盘的方式安装了office
但是安装完之后本机的文件资源管理器多了一个cd/dvd，强迫症很不能忍
而且点开文件资源管理器上面的进度条很慢，磁盘加载不出来
一点cd/dvd就卡死，
搜索了一堆答案全是一群傻缺媒体各种瞎鸡儿复制粘贴
右键点击计算机 选属性——管理——服务找到virtual disk服务 双击将其开启 禁用的话 就用下拉列表选择手动 如果上面的还是不管用，一般可以肯定你是装了UltraISO软件，软件给卸载了就能打开了。你在装这个软件时应该给可选项都给勾选了，所以会默认打开虚拟磁盘，但是你系统又没有虚拟磁盘所以也就找不到。 一群缺货md真是来火，还肯定是装了ultraiso软件，呵呵你咋不上天，是不是劳资还得安装一个再卸载？？
而且进计算机管理-磁盘管理，加载虚拟磁盘服务很久很久也没啥相应。。。
不懈努力
找到了来自巨硬的官方解决方式（虽然巨硬回答有的时候很坑而且是自己填坑不过这次还是靠谱的）
您好，
建议您这样操作：
双击virual disk服务，点击“启动”，并在启动类型中选择“自动”，然后重新打开磁盘管理。
如果您安装有虚拟机软件，建议您尝试卸载后再次确认问题。
（没试过，我才懒得重装VMware，而且我的情况不允许我点virual disk服务）
同时您也可以进行干净启动步骤： 干净启动步骤：
1. 按Windows+R, 然后在输入框中输入msconfig，按回车，弹出系统配置对话框。
2. 选择常规，单击“有选择的启动”，然后单击清除“加载启动项”上面的勾。
3. 再点击“服务”，单击“隐藏所有Microsoft”服务，然后单击全部禁用。
4. 再点击“启动”，点击“打开任务管理器”，点击启动项，然后单击禁用。
5. 单击确定，重新启动系统。
如果要恢复到正常状态只要在系统配置对话框：“常规”选项卡上，点按或单击“正常启动”选项即可。 正解！！！
but关闭服务之后一直卡在重启不动
简直侮辱我的三星固态好吗？？！
等了差不多十分钟，强制关机，秒开，开启服务，重启，秒开
真香
（远离司马复制粘贴党保平安）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/225071d8df8fbc548fdb8f6a178baa91/" rel="bookmark">
			[Python]实现简易点名器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点名器 最近在学习Python, 做了一个简易的点名器, 使用Excel导入点名名单
使用到的库:
1.xlrd(用于读取Excel表)
2.random(用于获取随机数)
3.tkinter(用于绘制界面)
import random import tkinter as tk from tkinter import messagebox import xlrd window=tk.Tk() window.title('Call Name') window.geometry('300x400') excel_path = tk.Entry( window, width=50 ) excel_path.pack() x_values = [] def load_excel(): try: reader = xlrd.open_workbook(excel_path.get()) sheet = reader.sheet_by_index(0) global x_values x_values = sheet.col_values(0) except: tk.messagebox.showwarning(title='Warning', message='Read excel Error!') btn_read_name=tk.Button( window, text='load', width=15, height=2, command=load_excel ) btn_read_name.pack(pady=30) var=tk.StringVar() lab_show=tk.Label( window, textvariable=var, bg='black', fg='white', font=('Arial',12), width=15, height=2 ) lab_show.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/225071d8df8fbc548fdb8f6a178baa91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa106fa7e3ca2a8c25c6ddd1262beac7/" rel="bookmark">
			使用bat文件批量修改多个android终端的文件并重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、mod.bat源码
使用bat文件修改多个android终端的文件重启
::如果当前是老版本，a设置为0；如果是新版本，设置为1
@echo off
set /a n=0
setlocal enabledelayedexpansion
set a=0
:loop
adb connect 192.168.20.237
ping -n 1 -w 3000 1.1.1.2&gt;nul
if %a% equ 0 (
echo “a=”%a%
adb -s 192.168.20.237:5555 shell rm /etc/mr/zip
adb -s 192.168.20.237:5555 push a.zip /etc/mr
adb -s 192.168.20.237:5555 shell sync
set a=1
) else (
echo “a=”%a%
adb -s 192.168.20.237:5555 shell rm /etc/mr/zip
adb -s 192.168.20.237:5555 push b.zip /etc/mr
adb -s 192.168.20.237:5555 shell sync
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa106fa7e3ca2a8c25c6ddd1262beac7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42a8a0b52323f140c11244399647f8a/" rel="bookmark">
			Http中Content-Type等属性详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 一直以来对HTTP请求中各种属性一知半解,偶然在博客中找到一篇,特意摘录过来方便自己以后查看.
正文 敬请关注博客，后期不断更新优质博文，谢谢
这里讲解Content-Type的可用值，以及在spring MVC中如何使用它们来映射请求信息。
1. Content-Type
MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。
例如： Content-Type: text/html;charset:utf-8;
常见的媒体格式类型如下：
text/html ： HTML格式 text/plain ：纯文本格式 text/xml ： XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png：png图片格式 以application开头的媒体格式类型：
application/xhtml+xml ：XHTML格式 application/xml ： XML数据格式 application/atom+xml ：Atom XML聚合格式 application/json ： JSON数据格式 application/pdf ：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ： &lt;form encType=””&gt;中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的：
multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式 以上就是我们在日常的开发中，经常会用到的若干content-type的内容格式。
2. Spring MVC中关于关于Content-Type类型信息的使用
首先我们来看看RequestMapping中的Class定义：
@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Mapping public @interface RequestMapping { String[] value() default {}; RequestMethod[] method() default {}; String[] params() default {}; String[] headers() default {}; String[] consumes() default {}; String[] produces() default {}; } value: 指定请求的实际地址， 比如 /action/info之类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c42a8a0b52323f140c11244399647f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f56a35a6dc4960004b1577eb6a486c52/" rel="bookmark">
			python知识点：tkinter-filedialog-asksaveasfilename参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python知识点：tkinter-filedialog-asksaveasfilename参数
# For the following classes and modules: # # options (all have default values): # # - defaultextension: added to filename if not explicitly given # # - filetypes: sequence of (label, pattern) tuples. the same pattern # may occur with several patterns. use "*" as pattern to indicate # all files. # # - initialdir: initial directory. preserved by dialog instance. # # - initialfile: initial file (ignored by the open dialog).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f56a35a6dc4960004b1577eb6a486c52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4946e2be3fdf1b94c72b68940f946059/" rel="bookmark">
			js中try-catch的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在MatLab中看到了try-catch语句的应用，正好今天看到了js中的try-catch语句，就来简单的总结一下吧。
try-catch 语句：作用捕获异常语句
执行流程：先执行try中的语句，如果有错误，就会将错误抛出，并且被catch捕获并去执行，这时候就会执行catch里的语句，而且不论try中有没有抛出和错误，finally语句都会去执行其中自己的代码块
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; try{ console.log(a); }catch{ console.log(1); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 因为try中有错误，就会去执行catch中的代码块
执行结果：
try中代码的执行也是顺序的，直到遇到错误位置
在catch语句中遇到错误仍然是会报错的
无论是在try中有没有错误，finally中的代码块都会被执行，并且，如果catch和finally中都存在错误的话，只报错finally中的错误
最后再举一个例子吧
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; (function() { try{ var a = 1; console.log(a); //打印a throw Error(a); //抛出错误a }catch (a){ console.log("捕获到了错误a:"+a); console.log(b); //此时b未定义，没有finally的话就会报错 }finally{ console.log("finally执行"); console.log(c); //此时c未定义,会报错； } })(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afd6917bce7865b4de9981eaeac97d4d/" rel="bookmark">
			使用shell脚本对比两个文件内容差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时工作期间，我们有可能遇到对比两个文件内容的差异性，并将两个文件差异的内容输出，这个时候我们可以使用shell脚本来操作，使用shell脚本的sort排序后再比对，这种方法在数据量大的情况下，比循环比对速度快很多。
以下的比对的代码： 并集：cat file1.txt file2.txt | sort | uniq &gt; file.txt
交集： cat file1.txt file2.txt | sort | uniq -d &gt;file.txt
差集：求file1.txt相对于file2.txt的差集，可先求出两者的交集temp.txt，然后在
file1.txt中除去temp.txt即可。
cat file1.txt file2.txt | sort | uniq -d &gt;temp.txt
cat file1.txt temp.txt | sort | uniq -u &gt;file.txt
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe0b978dba57164054de0887cdfe7e1e/" rel="bookmark">
			postgresql 查询所有表名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SELECT tablename FROM pg_tables WHERE tablename NOT LIKE 'pg%'
AND tablename NOT LIKE 'sql_%' ORDER BY tablename;
或
select tablename from pg_tables where schemaname='public'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bd6601e2f88a516f1177ad011491a1f/" rel="bookmark">
			Python实用技法第17篇：将名称映射到序列的元素中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章： Python实用技法第16篇：从字典中提取子集 下一篇文章： Python实用技法第18篇：同时对数据做转换和换算 1、需求? 我们的代码是通过位置（即索引或下标）来访问列表会元组的，但有时候这会让代码变得有些难以阅读。我们希望可以通过名称来访问元素，以此减少结构中对位置的依赖性。 2、解决方案? 相比普通的元组，collections.namedtuple()(命名元组)只增加了极少的开销就提供了这些便利。实际上collections.namedtuple()是一个工厂方法，它返回的是Python中标准元组类型的子类。我们提供给它一个类型名称以及相应的字段，它就返回一个可实例化的类、为你已经定义好的字段传入值等。
from collections import namedtuple Subscriber=namedtuple('Subsciber',['addr','joined']) sub=Subscriber("1782980833@qq.com","2018-10-23") print(sub) print(sub.addr) print(sub.joined) print(len(sub)) addr,joined=sub print(addr) print(joined) #下面错误，以为你namedtuple是不可变的 #sub.joined="2019" 结果：
Subsciber(addr='1782980833@qq.com', joined='2018-10-23') 1782980833@qq.com 2018-10-23 2 1782980833@qq.com 2018-10-23 尽管namedtuple的实例看起来就像一个普通的类实例，但它的实例与普通的元组是可互换的，而且支持所有普通元组所支持的操作。
命名元组的主要作用在于将代码同它所控制的元素位置间解耦。所以，如果从数据库调用中得到了一个大型的元组列表，而且通过元素的位置来访问元素，那么假如在表单中新增了一列数据，那么代码就会崩溃，但如果首先将返回的元组转换为命名元组，就不会出现问题。
为了说明这个问题，下面有一些使用普通元组的代码：
def compute_cost(records): total=0.0 for rec in records: total+=rec[1]*rec[2] return total 通过位置来引用元素常常使得代码的表达力不够强，而且也很依赖于记录的具体结构。
下面是使用命名元组的版本：
from collections import namedtuple Stock=namedtuple('Stock',['name','shares','price']) def compute_cost(records): total=0.0 for rec in records: s=Stock(*rec) total+=s.shares*s.price return total 3、分析? namedtuple的一种可能用法是作为字典的替代，后者需要更多的空间来存储。因此，如果要构建设计字典的大型数据，使用namedtuple会更加高效，但是请注意，与字典不同的是，namedtuple是不可变的。
如果需要修改任何属性，可以通过使用namedtuple实例_replace()方法来实现。该方法会创建一个全新的命名元组，并对相应的值做替换。
from collections import namedtuple Subscriber=namedtuple('Subsciber',['addr','joined']) sub=Subscriber("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bd6601e2f88a516f1177ad011491a1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77a0d4aca067ea2338293b0b70e893b/" rel="bookmark">
			Linux学习笔记（共享内存 &#43;⽂件锁 &#43; 信号量 &#43;Shell脚本编程 &#43;云服务器⼊⻔）之云服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⼀，什么是云服务器？ 云服务器弹性计算服务（ECS）是云服务器提供商提供的⼀种基础云计算服务。 禾云服务器ECS就像使⽤⽔，电，煤⽓等资源呀样便捷，磐效。我们瘫需提前采购硬件设备， ⽽是根据业务需要，随时创建所需数量的云服务器实例，并在使⽤过程中，随着业务的扩展， 对云服务器进⾏扩容磁盘，增加带宽。如果不再需要云服务器，也可以⽅便的释放资源，节省 费⽤。 云服务器ECS实例是⼀月虚拟的计算环境，包含了CPU，内存，操作系统，磁盘，带宽等最基 既的服务器组件，是ECS提供给每个睿户的操作实体。⼀个实例就等同于⼀台虚拟机，您对所 创建的实例拥有管理员权限，可以随时登录进⾏使⽤和管理。您可以在实例上进⾏基本操作， 如挂载磁盘，创建快照，创建镜像，部署环境等。 正如⻢云所⾔，未来的云服务器就是社会的基础设施，就像我们打开⽔⻰头就可以⽤⽔⼀样， 我们也可以随时根据我们的需求使⽤我们的服务器。 ⼆，云服务器的选择 前⼏⽇，⼀篇“阿⾥云的这群疯⼦”迅速在⽹络上传播开来，这篇⽂章有⾎有⾁，有真实历史中的困 难，也有克服困难后的信⼼重建。是近年来⾮常出⾊的⼀篇关于阿⾥云发展的报道。阿⾥云是⽬前国 内最⼤的云服务器提供商，市场份额近50％，同时也是全球第三⼤云服务器提供商，仅次于亚⻢逊和 微软，那么我们就选择⽐较让我们国内的程序员感到⾃豪的阿⾥云吧！ 三，云服务器的购买 阿⾥云，腾讯云等国内⼤公司都提供了学⽣优惠的价格。 点击进⼊阿⾥云“云翼计划”学⽣优惠界⾯ 过程还⽐较简单啦，前三步是进⾏验证，第四部步进⼊如下所示的界⾯，终于要开始买我们的服务器 啦！ ----------------------- Page 14 -----------------------
在这⼀⻚我们有⼏个选择，我⽤标号标记出来了。 1. 我们选择云服务器ECS。“轻量应⽤服务器”预装了⼀些⼯具，⽐如搭建博客的WordPress，写 PHP的LAMP套件组合等等。我们想要⼀个全新的服务器，所以选择云服务器ECS就好，我们⾃ ⼰来安装。 2. 选择⽐较主流的CentOS啦~⽤Ubuntu的同学也不⽤担⼼，云服务器⼀般就只有命令⾏啦，是没 有图形界⾯的，选择CentOS没有什么过度。 3. 我们是东北，​看起来华北和华东离我们都⽐较近，随便选⼀个吧，选华北。 4. 先买⼀个⽉的吧。只要9.5哎！真的是很便宜的价格了。阿⾥云有学⽣认证可以买多次，腾讯云 则是有次数限制的，我爱阿⾥！ 5. 点击⽴即购买去付款就好啦~ 四、云上初体验 购买成功后我们进⼊控制台⻚⾯，如下图 我们主要关注的就是我⽤箭头标注出来的那个公⽹IP，接下来，我们就要远程登录到这个IP地址啦！ 「云服务器⼊⻔（⼆）」Windows⽤户上云 ----------------------- Page 15-----------------------
「云服务器⼊⻔（⼆）」Windows⽤户上云 背景 恭喜你已经成功购买了阿⾥云服务器！ 众所周知，Windows的命令⾏功能不多和Unix完全不⼀样，这也就决定了我们Windows⽤户不能直 接通过CMD来SSH远程连接到云服务器。在此向使⽤Windows的同学推荐Windows下的上云利 器“putty+winscp”的组合⽅案。 另外，​VSCode也有⼤量的辅助我们与云服务器交互的插件，感兴趣的同学也可以看⼀下「云服务器 ⼊⻔（三）Mac⽤户上云」，⾥⾯所提到的VSCode插件在Windows下也可以使⽤！ ⼀、putty ​基本介绍 PuTTY是⼀个Telnet、SSH、rlogin、纯TCP以及串⾏接⼝连接软件。较早的版本仅⽀持 Windows平台，在最近的版本中开始⽀持各类Unix平台，并打算移植⾄Mac OS X上。除了官⽅ 版本外，有许多第三⽅的团体或个⼈将PuTTY移植到其他平台上，像是以Symbian为基础的移 动电话。PuTTY为⼀开放源代码软件，主要由Simon Tatham维护，使⽤MIT licence授权。随着 Linux在服务器端应⽤的普及，Linux系统管理越来越依赖于远程。在各种远程登录⼯具中， Putty是出⾊的⼯具之⼀。Putty是⼀个免费的、Windows x86平台下的Telnet、SSH和rlogin客 户端，但是功能丝毫不逊⾊于商业的Telnet类⼯具。 —— 《百度百科》 下载安装 putty下载链接 根据电脑实际选择32/64位下载就ok啦~ 安装过程不赘述。 使⽤⽅法 ⻅「云服务器⼊⻔（四）」 ⼆、WinSCP WinSCP是⼀个Windows环境下使⽤SSH的开源图形化SFTP客户端。同时⽀持SCP协议。它的主 要功能就是在本地与远程计算机间安全的复制⽂件。winscp也可以链接其他系统,⽐如linux系 统。WinSCP可以执⾏所有基本的⽂件操作，例如下载和上传。同时允许为⽂件和⽬录重命名、 改变属性、建⽴符号链接和快捷⽅式。甚⾄还可以在线编辑⽂件内容。 ----------------------- Page 16-----------------------
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f77a0d4aca067ea2338293b0b70e893b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad74fc16e1cd815e2daa948b073b7cde/" rel="bookmark">
			Linux学习笔记（共享内存 &#43;⽂件锁 &#43; 信号量 &#43;Shell脚本编程 &#43;云服务器⼊⻔）之信号量 &#43;Shell脚本编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信号量 概念 为了保证共享内存不会同时被多⼈修改从⽽造成不同步，⼀般使⽤信号量。 示例 新建信号量 int semget（key_t key，int nsems，int semflg）; 修改信号量的值 ----------------------- Page 7 -----------------------
int semop（int sem_id，struct sembuf * sem_opa，size_t num_sem_ops）; 壳牌脚本编程 简介 外壳脚本，就是利⽤壳的命令解释的功能，对⼀个纯⽂本的⽂件进⾏解析，然后执⾏这些功能，也 可以说壳牌脚本就是⼀系列命令的集合.Shell可以直接使⽤在赢/ Unix / Linux操作系统上⾯，并且可以调⽤ ⼤量系统内部的功能来解释执⾏程序，如果熟练掌握外壳脚本，可以让我们操作计算机变得更加轻 松，也会节省很多时间。 应⽤场景 将囧些复杂的命令简单化（例如平时我们提交哉次Git代码可能需要很多步骤（git add。，git commit） -m“”，git push），但是我们可以睿Shell简化成⼀步） ⾃动打包，编译，发布等功能 完成快捷修改⽂件名，移动⽂件，清理磁盘中空⽂件夹等有技巧性的操作 总之⼀切有规律可循的任务都可以尝试⼀下shell脚本 编写 ＃！/ bin / sh的 ... 注：⾸⾏为＃！/ bin / sh，指定脚本的默认解释器路径。 运⾏⽅法 作为可执⾏的程序：将代码保存在.SH格式的⽂件内并直接调⽤执⾏ chmod + x ./test.sh#使脚本具有执ο权限 ./test.sh＃运蛾脚本Shell变量 作为解释器的参数：运搓解释器，参数为shell脚本的鹧件名 / bin / sh test.sh 壳牌变量 定义变量 定义变量时，变量名不加美元符号（$，PHP语⾔中变量需要） HELLO ='你好世界！'; 注：等号两端不能有空格，否则被当成多个操作。 ----------------------- Page 8 -----------------------
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad74fc16e1cd815e2daa948b073b7cde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9cd63cafdeedb5b5b3bb80ff32b8fdb/" rel="bookmark">
			C语言单链表的创建（使用函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言单链表的创建（使用函数） C语言单链表的入门学习
用函数实现上篇文章中建立链表的功能。
将该函数声明为指针函数，返回值为创建链表的链头指针。
node * createlist(void) 将遍历列表的过程也用一个函数来实现。
void display(node * head) { node * p; p = head; while(p != NULL) { printf("%d ",p-&gt;num); p = p-&gt;next; } printf("\n"); } 使用函数来实现单链表的创建。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef struct _node { int num; struct _node * next; }node; node * createlist(void); void display(node * head); int main(void) { node *head; head = createlist(); display(head); return 0; } node * createlist(void) { node * head = NULL, *p, *tail = NULL; int n; while(scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9cd63cafdeedb5b5b3bb80ff32b8fdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/997bb953462ac329b72c0e454d1c6848/" rel="bookmark">
			traceroute 命令示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用途 显示 IP 信息包至某个网络主机的路由。
语法 traceroute [ -m Max_ttl ] [ -n ] [ -p Port ] [ -q Nqueries ] [ -r ] [ -d ] [ -g gateway_addr ] [ -s SRC_Addr ] [ -t TypeOfService ] [ -f flow ] [ -v ] [ -w WaitTime ] Host [ PacketSize ]
描述 注意： traceroute 命令适用于网络测试、评估和管理。它应主要用于手动故障隔离。由于它对网络施加的负荷， traceroute 命令不应用于正常的操作中或自动脚本。 traceroute 命令试图跟踪 IP 信息包至某个因特网主机的路由，其具体方法是：先启动具有小的最大存活时间值（Max_ttl 变量）的 UDP 探测信息包，然后侦听从网关开始一路上的 ICMP TIME_EXCEEDED 响应。探测以一个一跳跃位的 Max_ttl 值开始，该值一次增加一个跳跃值，直至返回 ICMP PORT_UNREACHABLE 消息。ICMP PORT_UNREACHABLE 消息可以指出主机已经被定位，或命令已经达到允许跟踪的最大跳跃数目。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/997bb953462ac329b72c0e454d1c6848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f48b38bdb6d4b4f768cdd2bc604bbacd/" rel="bookmark">
			房间类游戏后台框架(一)—介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		闲来无事用GO语言写了个简易的房间类游戏后台框架，目前实现基本房间功能，并放了贪吃蛇游戏进去，可实现多人在线贪吃蛇。由于没有前端，导致项目难以继续下去。整个项目大概完成75%，基本目标也都实现，看以后是否有前端加入再继续编写。
（一）系统结构
设计的思路就是高可扩展，只要当前负载已达到上限，只需要整体扩容或者部分扩容即可，整个扩容过程用户没有感知。最终目标全自动化，将各个组件放在docker下运行，kubernetes控制游戏的扩容。
1、网关
网关负责接收来自客户端信息，对用户身份鉴权并解析其数据，从服务发现管理中心(ETCD)获取对应服务将其信息转发。其中不符合规则、黑名单等数据将被拦截，保证服务正常运行。对服务进行流量均衡，对客户端进行协议适配，转换为统一格式发送给服务。限流功能防止客户端在同一时间段访问数量多次。同时网关可以使客户端从一个服务器到另一个服务器的平滑过渡。客户端不用感知服务器变化，降低了编写难度。
2、消息队列
消息队列用来转发信息，使服务器之间能相互通信，只需要知道对应服务器编号即可向其发送信息，解耦并降低模块之间的编码难度。
3、大厅服务器
大厅负责处理玩家创建房间、加入房间、在线匹配、公告等功能。
4、游戏服务器
游戏服务器负责玩家的游戏过程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d51372b613903eb8c6a0fc75ffdb027/" rel="bookmark">
			&lt;configuration&gt;报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果出现以下的错误：
The content of element type "configuration" must match "(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)".
一般都是因为你&lt;configuration&gt;内的标签顺序不对，必须严格按照(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)这个顺序来写
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/016f5df6b5f0250f9b93fb83f062078e/" rel="bookmark">
			C语言基础编程题目（函数题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目地址：https://pintia.cn/problem-sets/14/problems
6-1 简单输出整数 （10 分） 本题要求实现一个函数，对给定的正整数N，打印从1到N的全部正整数。
函数接口定义： void PrintN ( int N ); 其中N是用户传入的参数。该函数必须将从1到N的全部正整数顺序打印出来，每个数字占1行。
裁判测试程序样例： #include &lt;stdio.h&gt; void PrintN ( int N ); int main () { int N; scanf("%d", &amp;N); PrintN( N ); return 0; } /* 你的代码将被嵌在这里 */ 输入样例： 3 输出样例： 1 2 3 //6-1 简单输出整数 /* 你的代码将被嵌在这里 */ void PrintN ( int N ) { int i=0; for(i=1;i&lt;N+1;i++) { printf("%d\n",i); } } 6-2 多项式求值 （15 分） 本题要求实现一个函数，计算阶数为n，系数为a[0] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/016f5df6b5f0250f9b93fb83f062078e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32e3e5cd6d29ffc85ab8fa9463ffc79b/" rel="bookmark">
			我就是演员的《北京爱情故事》，又是一出经典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来看到六位主演时，觉得这种对非主力选手的大杂烩太残忍了，从二进一变到三进一还可以理解，四进一就有些夸张了，要是六进一，真是欺人太甚。演员的地位直接影响他们的机会，哪怕在这种竞赛的舞台上，不就是输在起跑线上吗。（还好根据剧透，是六进二，不算离谱）。
看着看着，我觉得六位演员并没有受到不公平待遇，反而是一种幸运。真正的演员而非偶像明星，在意的是有没有好的作品流传下来，他们做到了。而且难得的是个人的表演都不脱节，最出色的几位就格外耀眼。好的剧本和表演是可遇不可求的，所以他们六个人演的这一出北京爱情故事，并不比其他两位或三位主演的剧目吃亏。即使从实际利益上说，在受人瞩目的平台上，给广大观众留下好印象，也是不虚此行。
以往也有好剧本，但这次的是距离现代都市青年心理和情感最近的，所以特别容易引起共鸣。檀健次的表演真挚动人，我不像那些导师那样，能用专业的眼光看出他没有接受过职业训练，但是我同意，这真的是一种天分。他似乎是个感情特别敏感细腻的人，后来被徐峥表扬时哭得泪流满面。
范和孙让我刮目相看，以前只看过范的喜剧角色，没想到演起正剧来这么出色，孙这表演也很细腻巧妙。开完前两段的时候我还想檀健次肯定得第一了，后面两段峰回路转，范和孙也不逊色于檀健次。六位都是好演员。
最后还要为编剧点个赞，把现实题材拍得这么深刻又温暖。范的那一句，在北京我们这些人不配有爱情，让这短短的表演一下子超越了无数爱情肥皂剧，人生的苦涩和无奈，在北京折叠层层展开。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7cf98aaa23824d1894ddb32eab315e3/" rel="bookmark">
			多元线性回归方程原理及其推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 多元线性方程原理及推导 概念 1.在统计学中，线性回归方程是利用最小二乘函数对一个或多个自变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量的情况称为简单回归，大于一个自变量的情况叫多元回归。
2.在线性回归中，数据使用线性预测函数来建模，并且未知的函数模型参数也是通过数据来估计。这种模型被叫做线性模型。最常用的线性回归建模是给定的X的条件下y的条件分布的分位数作为X的线性函数表示。像所有形式的回归分析一样，线性回归也是把焦点放在给定X的值的y的条件概率分布，而不是X和y的联合概率分布（多元分析领域）。
公式 一元线性回归方程：y=a+bx
a称为截距
b为回归直线的斜率
多元线性回归方程：y=b0+b1X1+b2X2+…+bnXn
b0为常数项
b1,b2,b3,…bn称为y对应于x1,x2,x3,…xn的偏回归系数
推导 使用极大函数解释最小二乘
似然函数
高斯的对数似然与最小二乘
参数的解析式
总结 自我认为多元线性方程的推导过程还是挺麻烦的，需要多看几遍。学习推导的过程中，我们要认识一些数学符号，一些方法，比如最小二乘，极大似然，梯度等等。 事实上，一种现象常常是与多个因素相联系的（比如：房子总价与房子面积，房间数，地段这些因素相关），由多个自变量的最优组合共同来预测或估计因变量，比只用一个自变量进行预测或估计更有效，更符合实际。因此多元线性回归比一元线性回归的实用意义更大。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ceba94872451d723d182b2037ade31/" rel="bookmark">
			题目8 	假定两个带头节点的单链表，保存单词，后缀相同时共享相同空间，找出共同后缀的起始位置。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假定两个带头节点的单链表，保存单词，后缀相同时共享相同空间，找出共同后缀的起始位置。 首先：这里给出创建的代码：至于createList函数，写在了头文件中，后面统一给出。 char word1[]={'l','o','a','d'}; char word2[]={'p','l','a','y'}; char last[]={'i','n','g'}; Node* node1 = createList(word1, 4, true);//带头结点 Node* node2 = createList(word2, 4, true);//带头结点 Node* nodelast = createList(last, 3, false);//不带带头结点 //连接 connect(node1, nodelast); connect(node2, nodelast); void connect(Node*&amp; A, Node*&amp; B){ if(A==NULL) return ; Node* p=A; while(p-&gt;next!=NULL){ p=p-&gt;next; } p-&gt;next=B; } 如loading 和 thing 相同的无疑是i 误区：错误的认为可以简单的理解为长度做减法，然后求倒数第一个，按照位置求解。 正确解法，求长度，从最大相同长度的位置开始比较，即从较短的单词的第一个元素，较长的单词的移动到和较短的对照的长度的位置处比较，比较指针地址。 Node* search_commonNode(Node *a, Node *b){ int c1 = getListLength(a, true);//自定义工具函数，在头文件中定义，计算长度 int c2 = getListLength(b, true); while(c1&gt;c2){ a=a-&gt;next; c1--; } while(c1&lt;c2){ b=b-&gt;next; c2--; } while(a-&gt;next!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8ceba94872451d723d182b2037ade31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db8620692cc26e9d70551bc2498247dd/" rel="bookmark">
			medusa--暴力破解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Medusa(美杜莎)和hydra(九头蛇)差不多
科普下: Medusa是支持AFP, CVS, FTP, HTTP, IMAP, MS-SQL, MySQL, NCP (NetWare), NNTP, PcAnywhere, POP3, PostgreSQL, rexec, rlogin, rsh, SMB, SMTP (AUTH/VRFY), SNMP, SSHv2, SVN, Telnet, VmAuthd, VNC的密码爆破工具
安装：
1. 安装gcc-c++
2. yum install apr-devel apr apr-util subversion-devel subversion freerdp-devel freerdp libssh2-devel libssh2
yum install openssl openssl-devel
yum install telnet
yum install telnet-server
3. 下载包 http://foofus.net/goons/jmk/medusa/medusa.html
4. 视频教学：https://www.fujieace.com/kali-linux/courses/medusa-2.html
https://v.youku.com/v_show/id_XMzE4MTI4NjM1Mg==.html
5. ./configure;make -j 4;make install
-o 多台机器
使用参考https://blog.csdn.net/u010984277/article/details/50792816?utm_source=blogxgwz0
https://blog.csdn.net/leiman1986/article/details/51016850?utm_source=blogxgwz4
-h [TEXT] 目标IP
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db8620692cc26e9d70551bc2498247dd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/424/">«</a>
	<span class="pagination__item pagination__item--current">425/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/426/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>