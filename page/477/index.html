<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef50a30f87b37b44053712041c0d500/" rel="bookmark">
			Android之AssetManager使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 获取AssetManager
AssetManager am = context.getAssets();
2. 列出assets目录下所有文件
String[] filePathList = am.list("");
3. 打开某个文件
InputStream is = am.open("test.txt");
4. 获取到InputStream后，就可以通过IO库进行文件操作了。或者通过BitmapFactory.decodeStream(is)得到Bitmap对象
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f902e779c1a2f78c16ed351c2284652/" rel="bookmark">
			删除重复字符 C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /* Description 给定一个字符串，将字符串中所有和前面重复多余的字符删除，其余字符保留，输出处理后的字符串。需要保证字符出现的先后顺序。 Prototype int GetResult(const char *input, char *output) Input Param input 输入的字符串 Output Param output 输出的字符串 Return Value 0 成功 -1 失败及异常 */ int GetResult(const char *input, char *output) { if(input==NULL||output==NULL){ return -1; } char exist[1024]={0}; int length=strlen(input); int out=0; for(int i=0;i&lt;length;i++){ if(!contains(exist,input[i])){ output[out]=input[i]; exist[out]=input[i]; out++; } } output[out]='\0'; return 0; } /* 验证input中是否含有c 有 返回1 无 返回0 */ int contains(const char *input,char c){ int length=strlen(input); if(!input) { return 0; } for(int i=0;i&lt;length;i++){ if(input[i]==c){ return 1; } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99d4dc799e9a7e84f9962c2cde5886ca/" rel="bookmark">
			第六章  Realm及相关对象——《跟我学Shiro》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录贴： 跟我学Shiro目录贴
6.1 Realm 【2.5 Realm】及【3.5 Authorizer】部分都已经详细介绍过Realm了，接下来再来看一下一般真实环境下的Realm如何实现。
1、定义实体及关系
即用户-角色之间是多对多关系，角色-权限之间是多对多关系；且用户和权限之间通过角色建立关系；在系统中验证时通过权限验证，角色只是权限集合，即所谓的显示角色；其实权限应该对应到资源（如菜单、URL、页面按钮、Java方法等）中，即应该将权限字符串存储到资源实体中，但是目前为了简单化，直接提取一个权限表，【综合示例】部分会使用完整的表结构。
用户实体包括：编号(id)、用户名(username)、密码(password)、盐(salt)、是否锁定(locked)；是否锁定用于封禁用户使用，其实最好使用Enum字段存储，可以实现更复杂的用户状态实现。
角色实体包括：、编号(id)、角色标识符（role）、描述（description）、是否可用（available）；其中角色标识符用于在程序中进行隐式角色判断的，描述用于以后再前台界面显示的、是否可用表示角色当前是否激活。
权限实体包括：编号（id）、权限标识符（permission）、描述（description）、是否可用（available）；含义和角色实体类似不再阐述。
另外还有两个关系实体：用户-角色实体（用户编号、角色编号，且组合为复合主键）；角色-权限实体（角色编号、权限编号，且组合为复合主键）。
sql及实体请参考源代码中的sql\shiro.sql 和 com.github.zhangkaitao.shiro.chapter6.entity对应的实体。
2、环境准备
为了方便数据库操作，使用了“org.springframework: spring-jdbc: 4.0.0.RELEASE”依赖，虽然是spring4版本的，但使用上和spring3无区别。其他依赖请参考源码的pom.xml。
3、定义Service及Dao
为了实现的简单性，只实现必须的功能，其他的可以自己实现即可。
PermissionService
public interface PermissionService { public Permission createPermission(Permission permission); public void deletePermission(Long permissionId); } 实现基本的创建/删除权限。
RoleService public interface RoleService { public Role createRole(Role role); public void deleteRole(Long roleId); //添加角色-权限之间关系 public void correlationPermissions(Long roleId, Long... permissionIds); //移除角色-权限之间关系 public void uncorrelationPermissions(Long roleId, Long... permissionIds);// } 相对于PermissionService多了关联/移除关联角色-权限功能。
UserService public interface UserService { public User createUser(User user); //创建账户 public void changePassword(Long userId, String newPassword);//修改密码 public void correlationRoles(Long userId, Long.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99d4dc799e9a7e84f9962c2cde5886ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d2982c46bd569a52d3c902e375a896b/" rel="bookmark">
			hg 使用 教程（非常值得一看）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：http://blog.csdn.net/zxkln/article/details/6118572
GDC注：只要你从头看到尾（而且该篇文章确实引人入胜，一步一步教你如何做），就会对HG的使用有一个非常全面的了解。唯一不足的是这篇教程中没有谈到branch在开发中的使用，感兴趣的可以自己在看完该篇文章的基础上，上网搜一搜HG branch的用法，这样就完全够开发使用了。
分布式版本控制工具 Mercurial 使用教程
本教程是介绍如何使用 Mercurial。我们不假定你有使用 源代码控制管理(SCM) 软件的背景。 本教程有法文 FrenchTutorial，西班牙文 SpanishTutorial，日文 JapaneseTutorial，和中文 ChineseTutorial 当研究完本教程后，你应该对以下几点有所领会： 你将要使用的 Mercurial 的概念和命令 如何用简单的方法在软件项目中使用 Mercurial 我们强烈建议你研读 Mercurial 手册 hg(1) 和hgrc(5)，它们也在源代码树 doc/hg.1.txt 和 doc/hgrc.5.txt 中 如何阅读本教程
格式约定很简单。命令名和参数名以 fixed font 显示。 你需要在 shell 或 命令行中输入的行用 fixed 字体显示，该行以 $ 字符开头。 你希望 Mercurial 或 shell 输出的行以 fixed 字体显示，但开头没有字符。 $ this is a line of user input
this is a line of program output
我 们在所有例子中使用 bash shell。在其它 Unix shell 和 Windows command.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d2982c46bd569a52d3c902e375a896b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1be110ae80644a74f847cbdc50dbba3/" rel="bookmark">
			js   动作与函数绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如将click动作与test()函数进行绑定
方法一
click(test);
方法二
bind("click","test")
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c9e6ee6f640a3124718acbece48fc92/" rel="bookmark">
			allegro导入和导出outline
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用allegro画的outline，另一个工程想继续用直接导出subdrawing就可以了
源工程里导出：
file-&gt;export-&gt;sub-drawing
然后在目标工程里导入：
file-&gt;import-&gt;sub-drawing
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70ca9231e6dd017e21545d94ec15a947/" rel="bookmark">
			【opencv】图像细化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们进行图像处理的时候，有可能需要对图像进行细化，提取出图像的骨架信息，进行更加有效的分析。
图像细化（Image Thinning），一般指二值图像的骨架化（Image Skeletonization） 的一种操作运算。
所谓的细化就是经过一层层的剥离，从原来的图中去掉一些点，但仍要保持原来的形状，直到得到图像的骨架。骨架，可以理解为图象的中轴。
好的细化算法一定要满足： 收敛性；保证细化后细线的连通性；保持原图的基本形状；减少笔画相交处的畸变；细化结果是原图像的中心线；细化的快速性和迭代次数少； 这里，我们对“Zhang并行快速细化算法”进行了实现（注意，该算法为并行算法，而我们在实现过程中并没有并行化处理，所以，效率并没有达到最好）。
参考资料
细化算法
论文 A fast parallel algorithm for thinning digital patterns#include &lt;opencv2/opencv.hpp&gt; #include &lt;opencv2/core/core.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; /** * @brief 对输入图像进行细化 * @param src为输入图像,用cvThreshold函数处理过的8位灰度图像格式，元素中只有0与1,1代表有元素，0代表为空白 * @param maxIterations限制迭代次数，如果不进行限制，默认为-1，代表不限制迭代次数，直到获得最终结果 * @return 为对src细化后的输出图像,格式与src格式相同，元素中只有0与1,1代表有元素，0代表为空白 */ cv::Mat thinImage(const cv::Mat &amp; src, const int maxIterations = -1) { assert(src.type() == CV_8UC1); cv::Mat dst; int width = src.cols; int height = src.rows; src.copyTo(dst); int count = 0; //记录迭代次数 while (true) { count++; if (maxIterations !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70ca9231e6dd017e21545d94ec15a947/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4600f49dcdd91cd4083e2b07e71aa1e8/" rel="bookmark">
			创建透明窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 hWnd：窗口句柄；nDegree：透明程度
void TranslateWnd(HWND hWnd, int nDegree) { ::SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);	// TopMost DWORD dwStyle = GetWindowLong(hWnd, GWL_EXSTYLE); ::SetWindowLong(hWnd, GWL_EXSTYLE, dwStyle^WS_EX_LAYERED); HINSTANCE hInst = LoadLibrary(_T("User32.DLL")); if (hInst) { typedef BOOL (WINAPI *MYFUNC)(HWND, COLORREF, BYTE, DWORD); MYFUNC pFun = NULL; // 取得SetLayeredWindowAttributes函数指针 pFun = (MYFUNC)GetProcAddress(hInst, "SetLayeredWindowAttributes"); if (pFun) // 128为透明值 { pFun(hWnd, 0, nDegree, LWA_ALPHA); } FreeLibrary(hInst); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/647512f643ddf07d077c0652f4d66929/" rel="bookmark">
			AD6交互式布线，智能布线快捷键的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Altium Designer 6系统为设计者提供了个功能强大、操作方便，而且布通率极高的自动
布线器，但在实际设计中，仍然会有不尽人意的地方，需要设计者去手工放置或调整PCB
上的布线，以便获得更为完善的设计效果。还有一些设计者出于个人喜好，习惯于对整个
PCB进行全部的手工布线，因此，提供了很方便的手工交互式布线，差分对交互式布线，
总线布线以及智能交互式布线，差分对交互式布线主要应用与高速电路的设计，我们将在以
后的文章里面进行讲述，这次我们先来看一下手工交互式布线和智能交互式布线。
一、手工交互式布线：
1．执行【Place】/【Interactive Routing】，或者单击布线工具栏的 图标，此时光标变
成“＋”形状，表明已进入导线放置状态。
2．在导线放置状态，将光标放在元器件的一个焊盘上，当出现八角形的亮环时 ，
表明已经捕捉的焊盘的中心，可以开始放置。
3．在导线放置状态，按下TAB键，这个时候就可以调整如：线宽，过孔大小，布线层，
手工布线的模式，布线角度，编辑线宽及过孔规则，常用线宽及过孔值编辑，以及线宽
及过孔大小选择方法。如下图：
4．在导线放置状态，按下TAB 键上面的` 键，或者F1，或者调出快捷面板的
SHORTKEY面板，即可看到关于手工布线的所有快捷键。
快捷键介绍：
F1：帮助，可以调出所有的快捷键说明，以及当前的帮助文件（pdf）
Backspace：移除上次放置的布线
Esc：结束布线
Shift+R：切换布线模式，有遇到障碍停止、推挤障碍、忽略障碍等三种模式可以选择
Shift+W：选择常用线宽
Shift+V：选择常用过孔大小
, ：减小圆弧角度布线时拐脚的圆弧半径
. ：增加圆弧角度布线时拐脚的圆弧半径
/：连接到内电层
Enter：放置当前走线
Num +：切换到下一层并自动放置过孔
Num –：切换到上一层并自动放置过孔
Num *：切换到下一个信号层并自动放置过孔
Space：切换起点模式，垂直、水平和45度
Shift+Space：切换走线角度，45度、直角、45度圆弧、90度圆弧，任意角度等
1：走线跟随鼠标
2：添加过孔，不换层
3：根据规则调整线宽，最大最小，以及默认
4：根据规则调整过孔大小，最大最小，以及默认
如下图： 二：智能交互式布线
在智能交互式布线环境中，系统为设计者提供了两种不同的连接完成模式，自动完成模
式以及非自动完成模式。
自动完成模式：在该模式下，布线过程中系统会尝试寻找能够完成整个连接的路径，并
以虚线轮廓的形式向设计者推荐，若设计者满意，只需按Ctrl键并单击鼠标左键，即可完
成整个连接的布线
非自动完成模式：在该模式下，布线过程中系统只尝试勋章从连接起点到当前光标位置
的路径
设计者在布线过程中可随意切换选用，极大的提高了设计的主动性和布线的灵活性。
1． 执行【Place】/【Smart Interactive Routing】，或者单击布线工具栏的 图标，此时
光标变成“＋”形状，表明已进入智能交互式状态。
2． 在导线放置状态，按下TAB键，这个时候就可以调整如：线宽，过孔大小，布线
层，走线模式，布线角度，编辑线宽及过孔规则，常用线宽及过孔值编辑，以及线宽及过孔
大小选择方法。
3． 在导线放置状态，按下TAB 键上面的` 键，或者F1，或者调出快捷面板的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/647512f643ddf07d077c0652f4d66929/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4602bde2d1a75510553a38356344c3e7/" rel="bookmark">
			;; connection timed out; trying next origin  ;; connection timed out; no servers could be reached
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置完bind，在其他主机进行域名解析的时候出现如下问题：
[root@Rac-one named]# nslookup rhel-cluster-scan.grid.example.com
;; connection timed out; trying next origin
;; connection timed out; no servers could be reached
问题解决：
修改bind服务器named.conf配置
修改之前：
options {
listen-on port 53 { 127.0.0.1; };
listen-on-v6 port 53 { ::1; };
directory "/var/named";
dump-file "/var/named/data/cache_dump.db";
statistics-file "/var/named/data/named_stats.txt";
memstatistics-file "/var/named/data/named_mem_stats.txt";
allow-query { localhost; };
recursion yes;
修改之后：
options {
listen-on port 53 { 192.168.4.102; };
listen-on-v6 port 53 { ::1; };
directory "/var/named";
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4602bde2d1a75510553a38356344c3e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40c02a28360b2c15b2ae12a7f59e076/" rel="bookmark">
			Android多线程方式处理图片下载及显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 想要创建运行流畅、响应迅速的应用程序，一个好的方式是在主UI线程中尽可能的少做写工作。一个有可能运行很长时间的任务有可能会阻塞整个应用程序，所以它应该在一个单独的线程中运行。经典的例子就是涉及到网络的操作，这些操作有可能会产生不可预测的延迟。用户可能会容忍一些延迟，特别是你能够提供一些提示来告诉他们后台正在运行任务，但是如果只是呆板的僵在那里，用户就不知道应用程序正在做什么。
在本文中，我们将采用这个模式创建一个简单的图片下载应用。我们将会在一个ListView中显示从网络上下载下来的缩略图。在实际运用中，创建一个异步的后台下载任务能够让你的应用程序保持流畅。
图片下载 从网络上下载图片相对来说比较简单，使用系统框架提供的HTTP相关的类就可以了。下面是一个简单的例子：
static Bitmap downloadBitmap(String url) { final AndroidHttpClient client = AndroidHttpClient.newInstance("Android"); final HttpGet getRequest = new HttpGet(url); try { HttpResponse response = client.execute(getRequest); final int statusCode = response.getStatusLine().getStatusCode(); if (statusCode != HttpStatus.SC_OK) { Log.w("ImageDownloader", "Error " + statusCode + " while retrieving bitmap from " + url); return null; } final HttpEntity entity = response.getEntity(); if (entity != null) { InputStream inputStream = null; try { inputStream = entity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f40c02a28360b2c15b2ae12a7f59e076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a2b3bb72d8ef0d75c65ab8519eb5547/" rel="bookmark">
			Java String byte数组 字符集转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转自：http://blog.csdn.net/aaronuu/article/details/7007386
1,byte[] str.getBytes(String charsetName) 将str按指定的字符集charsetName解码为字符数组.
返回用指定的字符集charsetName解码后的字符数组。
2,String(byte[] bytes, String charsetName) 构造一个新的String.将字符数组bytes按着指定的字符集charsetName指定的字符集进行编码。
3,　String str = "您好"；
String newStr = new String(str.getBytes("GB2312"),"ISO-8859-1");
这句话的意思是把str用GB2312编码方式取出，将取出的字符数组用ISO-8859-1再进行编码，来构造String类型对象newStr
相当于：
String str = "您好"；
byte[] tbyte = str.getBytes("GB2312");//str用GB2312编码方式取出
String newStr = new String(tbyte,"ISO-8859-1");//将tbyte转换为ISO-8859-1编码形式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da156b89eb2ce2d24573837efc427d17/" rel="bookmark">
			概要设计说明书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、编写背景
1.1作用
《概要设计说明书》是在《需求规格说明书》的基础上，通过我方与用户方反复沟通形成的。它充分反映《需求规格说明书》中的用户需求，如有改动必须征得用户的认可。它将作为项目验收时重要的的标准和依据。
从另一方面讲，它又是开发人员在下一阶段进行系统详细设计的纲领性文件，也是考核系统总体质量的重要技术文档。
1.2预期读者
软件开发人员，软件测试人员，机房管理员，学生。
2.1 系统名称及版本号
“机房收费系统V1.0”
2.2 任务提出者
廊坊师范学院
2.3任务承接者及实施者
信息技术提高班
2.4使用者
机房管理人员，学生
2.5与其它系统的关系
在用户现有的及预期的整个应用系统中，给本系统准确定位。用示意图及相应的文字予以说明。
3.文档结构：顺序结构：根据软件开发各个阶段编写不同阶段文档。
4.电子文档编写工具：MicrosoftWord 2010 for Windows 7
5.定义说明与符号规定
包括对专用术语及缩略语的解释、所用到的图（E-R图/功能层次图）中图符的表示与解释、屏幕界面中图标与按钮的表示与含义等。如在E-R图中，表示两个实体之间的关系时，我们定义了以下图符（部分举例）：
6.参考资料
《学生信息管理系统》
《SQL Server 2008》
《质量保证计划》
《需求规格说明书》
二、系统概述
1. 系统目标
开发意图：实现机房管理的信息化
应用目标：成本少，效益高，系统稳定
作用范围：机房管理
2. 设计原则
＊ 境遵照ISO9000的精神，按《联想集成系统有限公司软件开发规程文件》的要求办事。
＊ 质量管理应贯穿于整个设计之全过程。
＊ 对质量保证的承诺应落实到全体人员。
＊ 实际执行的过程中，必须符合项目自身的特点，体现个性差异，切实做到有的放矢。
＊ 分解原则
＊ 独立原则
＊ 一致原则
＊ 确定原则
3. 运行环境
硬件要求：符合windows xp系统以上配置的硬件配置。
软件平台：Windowsxp 系统操作平台以上。
SQL Server 2008
Vb6.0
网络体系结构：
局域网络：局域网中以一台计算机为服务器，为SQL Server 数据库服务器1台，位于局信息中心，用于支 撑征管业务信息处理、领导决策辅助支持、各征管业务科室的信息采集、查询及统计工作；其它机器为子机器， 连接服务器来读取数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da156b89eb2ce2d24573837efc427d17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a28e2ea8ebbec37d9a0e0590bf9cbab4/" rel="bookmark">
			jquery  ajax   success   beforeSend
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jQuery.ajax({ //Ajax函数
type: 'get', //定义http方法
data: 'version_id='+version_id ,
url: "/parent_package_versions/show_baseline_details", //请求的URL
beforeSend: function (){
jQuery('#ajax-indicator span').text('处理中，请稍等...');
Element.show('ajax-indicator');
},
success: function() {
Element.hide('ajax-indicator');
tb_show("&lt;%=l(:label_parent_package_version_details)%&gt;",'##TB_inline?height=500&amp;width=600&amp;inlineId=parent_package_version_details' , "thickbox");
}
});
jQuery ajax异步处理时，发送异步请求前，执行beforeSend，异步操作成功后，执行success
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dadca59d5b56f264764399ceea2ed8f5/" rel="bookmark">
			arc4random更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		u_int32_t arc4random(void);
void arc4random_addrandom(unsigned char * /*dat*/, int /*datlen*/);
void arc4random_buf(void * /*buf*/, size_t /*nbytes*/) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);
void arc4random_stir(void);
u_int32_t
arc4random_uniform(u_int32_t /*upper_bound*/) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);
以前获取0到x-1之间的整数的代码如下：
int value = arc4random() % x; 现在(__MAC_10_7, __IPHONE_4_3);以后
可以使用arc4random_uniform（x）；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2745756e9be9fc2f3fc4b64fcc605c3d/" rel="bookmark">
			jquery  获取元素的name名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 jQuery("#aa").attr(name); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a133e93bb40f6e25df86e0be912060b6/" rel="bookmark">
			source file does not belong to the project being debugged
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天中午突然碰到的问题：
奇怪！！！
而实际的错误是：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fad12faa7000c9bcf6b7d8770fd6286/" rel="bookmark">
			（redis）zmalloc.h/zmalloc.c理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权最终解释权归Leonjhan所有，要引述麻烦添加下作者博客leonjhan，thanks～
因为各处都有用到zmalloc这个函数进行内存的分配，所以这里讲下zmalloc的具体内部实现
作者是这样简介的：zmalloc-total amount of allocated memory version of malloc()
zmalloc：Redis内存分配策略，作者将不同平台下的内存分配malloc()进行了一个统一，和统计内存占有量，是对以前平台下内存分配函数的一个封装
/********************************** Part1：zmalloc.h *****************************************/
为了不让分段阅读吃力，我将整个代码的理解用注释标明出来...
#ifndef __ZMALLOC__H #define __ZMALLOC__H #define __xstr(s) __str(s) //此处使用#将宏(这里是#紧跟的那个s)“字符串化”；使用##能将左右两边的标签组合在一起，而且两个标签之间不存在空格 #define __str(s) #s //分别判断使用tcmalloc库/jemalloc库/苹果库哪个作为底层的malloc函数调用 #if defined(USED_TCMALLOC) #define ZMALLOC_LIB("tcmalloc-" __xstr(TC_VERSION_MAJOR) "." __xstr(TC_VERSION_MINOR)) #include &lt;google/tcmalloc.h&gt; #if (TC_VERSION_MAJOR == 1 &amp;&amp; TC_VERSION_MINOR &gt;=6) || (TC_VERSION_MAJOR &gt; 1) #define HAVE_MALLOC＿SIZE 1 //分别定义出内存占有量的计算方法 #define zmalloc_size(p) tc_malloc_size(p) #else #error "new version of tcmalloc required" #endif #elif defined(USE_JEMALLOC) #define ZMALLOC_LIB("jemalloc-" __xstr(JEMALLOC_VERSION_MAJOR) "." __xstr(JEMAOOLC_VERSION_MINOR) "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fad12faa7000c9bcf6b7d8770fd6286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cf531c6a8ae93c9d181250cc52ba229/" rel="bookmark">
			cc2530 串口实验--控制led灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/************************ * project : PC机向cc2530发送指令，控制led的亮灭 指令格式为“xy#”,其中x可以是B或Y， 代表着蓝灯或黄灯。y可以是0或1，0代表 关灯，1代表亮灯 * 时间 ：2014年1月10 * 作者 ：林少游 ************************/ #include &lt;ioCC2530.h&gt; #include &lt;string.h&gt; #define YLED P1_0 #define BLED P1_1 #define LIGHTOPEN 1 #define LIGHTCLOSE 0 #define uint unsigned int #define uchar unsigned char char ReceiveData[3]; //接收到的数据 int DataNumber=0; //接收到的数据的长度 char temp; //接收到的临时字符 void Delay(uint n); void Led_Init(); void Usart0_Init(); void Usart0_Send_String(char *Data,int len); void Usart0_Receive_String(); void Led_Contral(char *Data,int len); /************************ * @brief : LED初始化函数 ************************/ void Delay(uint n) { uint i; for(i=0;i&lt;n;i++); for(i=0;i&lt;n;i++); for(i=0;i&lt;n;i++); for(i=0;i&lt;n;i++); for(i=0;i&lt;n;i++); } /************************ * @brief : LED初始化函数 ************************/ void Led_Init() { P1DIR |= 0X03; //P1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cf531c6a8ae93c9d181250cc52ba229/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed75d4cb2183e20ee1b9abc3e5224452/" rel="bookmark">
			安装ASPCMS出现：提示：【】错误号：-2147467259 错误描述：未指定的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天把系统重装了下后，再安装了IIS，却发现电脑无法正常使用ASPCMS，而其它的程序却正常；在运行ASPCMS的时候出现以下报错现象： 提示：【】 错误号：-2147467259 错误描述：未指定的错误 Powered by AspCms2.0 经过一点时间的琢磨，终于找到了解决问题的办法；解决方法如下： A、打开系统目录下的windows/temp属性； B、切换到安全标签，在安全标签里面的所有用户组，你都赋予完全控制权限就OK了； 注：如果没有出现安全选项标签的话，请根据以下方法让安全标签展现； 1. 打开“我的电脑”→ 工具 菜单 → 文件夹选项 → 取消“使用简单文件夹共享”前面的打钩√ ； 2. 磁盘分区格式必须是NTFS格式。FAT32转NTFS格式的命令为：convert X: /fs:ntfs；直接在CMD里面执行命令就OK了；其中 "X"代表安装安装系统的盘符； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f154ee80a89132781be3338cd779e9/" rel="bookmark">
			Mysql按周分区的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一个项目中用到一个日志表，想根据按周来进行分区：
CREATE TABLE T_log( id INT(11) NOT NULL AUTO_INCREMENT, zoneid INT(11) NOT NULL, numcount INT(11) NOT NULL, ts TIMESTAMP NULL DEFAULT '0000-00-00 00:00:00' ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (id,ts) ) PARTITION BY RANGE (WEEK(ts)) ( PARTITION p1 VALUES LESS THAN (1), PARTITION p2 VALUES LESS THAN (2), PARTITION p3 VALUES LESS THAN (3), ... PARTITION p52 VALUES LESS THAN (52), PARTITION p53 VALUES LESS THAN MAXVALUE); 错误码: 1564
This partition function is not allowed 结果报错，week()函数不能作为分区函数。试了weekofyear()函数也不行。 换成yearweek()函数，可以，但又遇到了新问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0f154ee80a89132781be3338cd779e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1602724d62e042fb7739138312e6de5a/" rel="bookmark">
			Python 2 中文乱码解决方案：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文件编码是UTF-8，同时在文件头添加 # -*- coding: utf-8 -*-
2.文件中所有的字符串前都加u，如 u"中文"
3.在输入（抓取某些utf-8/gbk的网页）、输出（输出到网页、终端）的时候，要记住python内部是用Unicode存储的
4.所有输入要先decode，变成unicode，输出时要encode变成想要的编码（MacOS X/Linux下输出为utf-8，Windows下输出为gbk，但如果是在pycharm自己的控制台下的话，windows下输出为utf-8也可以正常显示）
5.还有其他很多种古老的解决方案，比如统一用gbk，比如中转编码不用unicode，而用utf-8，如此种种。。
更新一下，来源于 http://www.newsmth.net/nForum/article...
1.源码文件用coding: utf-8指定编码并把文件保存为utf-8格式
2.为了作为__main__模块执行时不出不必要的错误，统一使用\n换行
3.如果需要在源码内嵌入汉字等非ascii字符，建议使用u前缀作为unicode字符串，这样在print时可以可以不做编码转换，
4.否则如果控制台编码与源文件编码不一致就必须显式转换，通过locale.getdefaultlocale()可以获取系统语言和编码
5.涉及文件路径的最好转换为sys.getfilesystemencoding()编码
6.unicode字符串在写入文件时必须转换为某种字节编码
7.json默认支持utf-8编码
8.尽量用utf-8和unicode，除了前面说的文件路径和写入文件等少数情况
---------------------------------------------------------------------------------------------
其实如果想考虑今后迁移到 python 3 或者只是想使用 python 3 风格的默认 unicode, 可以使用
from __future__ import unicode_literals
之后不需要再在所有中文字符串前加 u 了, 相反, 所有原来的"字符串"现在默认均为unicode串了. 如果需要使用utf-8串可以选择在前面加 b :)
转载于:https://www.cnblogs.com/findeasy/p/4053098.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab7e7aaf18ae948c63c531d566e455ac/" rel="bookmark">
			VirtualBox安装Windows XP——图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VirtualBox安装Windows XP——图解 转自：http://blog.csdn.net/q1302182594/article/details/8720545
计算机/系统：acer4739z/ubuntu12.04-LTS
准备工作：1 在ubuntu12.04中安装好VirtualBox,我使用的VirtualBox版本是4.2.4，建议你下载最新的版本（下载地址https://www.virtualbox.org/wiki/Downloads）
2 下载一个Windows xp的安装镜像，我的是DEEPBBS_GHOST_XP_SP3_2012.08.iso,(可到http://www.xitongzhijia.net/下载)
在Ubuntu12.04-LTS中安装VirtualBox：略
在VirtualBox中安装Windows xp：
一)创建一个虚拟机
1 启动VirualBox,如下图所示：
2 点击“新建(N)”按钮，创建一个虚拟机。名称，类型，版本的设置如下所示：
3 点击下一步，给虚拟机分配内存。由于我的电脑有4G内存， 因此我给它分配了1G的内存。如下图所示：
4 点击下一步，给虚拟机分配硬盘。一般第一次创建虚拟机的时候都是选择“现在创建虚拟硬盘(C)”。
5 点击“创建”按钮，去创建一个虚拟硬盘。在在弹出来的窗体中，选择“VMDK”，然后点击“下一步”如下图所示：
注意：系统必须安装在VMDK上，如果安装其他类型的磁盘上，则会导致启动失败！
6 如下图，这时你可以选择虚拟硬盘是动态分配大小还是固定分配，这里我选择“动态分配”。选好后，点击下一步。
7 设置虚拟硬盘的名称和大小。这里我设置为“Windos”，大小我分配了20G。具体你可以根据自己的电脑配置来设置。如下图所示：
到此，一个虚拟机创建完毕，可以在这个虚拟机上安装系统了。
二)安装Windows XP系统
1 点击“设置(S)”按钮，并且选择“存储”选项，如下所示：
3 点击上图中用红色圆圈圈住的按钮，添加一个虚拟光驱。在弹出来的对话框中点击“留空(E)”如下图所示:
4 创建了一个空的虚拟光驱后，选中它，然后在“属性”栏中点击被红色圈住的按钮。如下图所示。
在弹出来的对话框中，点击“选择一个虚拟光盘...”,然后选择中你的下载的Windows xp的iso镜像。这时，添加虚拟光盘完毕。
5 这时，选择“系统”项，然后在启动循序里选择“光驱”，并且将其他选项去掉。如下图所示。
到此，基本设置已经完毕。点击“确定(O)”保存以上的配置。
6 点击“启动”按钮，开始安装Windows XP系统，如下图所示。其安装过程和在实体机上安装是一样的。
7 用WIN PE进入虚拟机,打开”我的电脑“，你会发现，刚才所创建的虚拟硬盘并不在这！哪里去了呢？
8 用Ghost来还原Window XP镜像
9 这时候再看，虚拟光驱出来啦！
10 这是时候，在改为硬盘启动，如下图所示：
11 可能出现的错误
分析：根据提示，可以知道这是虚拟硬盘出现了问题。由于我使用了ghost镜像还原的安装方式来安装，
没有格式化的过程，所以出现了这个错误。
后来，我换了另外一个系统镜像，使用正规的安装方式，结果这个问题迎刃而解了。
三)安装增强功能
1 选择“存储”选项，点击红色圆圈里的按钮，在弹出来的对话框中选择“增加虚拟光驱”。
2 选择“留空”，如下图：
3 点击“确认”保存了刚才的配置后，启动虚拟机。
4 选择：设备&gt;&gt;安装增强功能.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab7e7aaf18ae948c63c531d566e455ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d71804a1d549c1c8af5d296e51d00d1e/" rel="bookmark">
			Arm中main()和_main()的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当所有的系统初始化工作完成之后，就需要把程序流程转入主应用程序，即呼叫主应用程序。最简单的一种情况是：
IMPORT main
B main
直接从启动代码跳转到应用程序的主函数入口，当然主函数名字可以由用户随便定义。
在ARM ADS环境中，还另外提供了一套系统级的呼叫机制。
IMPORT __main
B __main
__main()是编译系统提供的一个函数，负责完成库函数的初始化和初始化应用程序执行环境，最后自动跳转到main()。所以说，前者是库函数，后者就是我们自己编写的main()主函数；
因此我们用的B __main其实是执行库函数,然后该库函数再调用我们的main() 函数,因此在单步调试时会看到先要跑一段程序(其实是库函数),然后再单步到我们自己的main函数(这个同时也说明如果有B __main 则就对应必须有main函数,否则编译出错),如果我们用 B main来进入我们的主函数的话,那在单步调试时就看到直接进入到我们自己的main函数了,中间不会看到其他程序; 那么用B __main和用B main 这两这进入我们的main函数方式有什么不同呢?
如果采用前者则会由编译器加入一段"段拷贝"程序,即我们说的从加载域到执行域转化程序;而采用后者就没有这个了，因此如果要进行 "段拷贝"只能自己动手编写程序来实现了,完成段拷贝后就可以进入我们的主函数了,当然这个主函数不一定是叫做main(),可以起个其他好听的名字,这个有别于使用B __main方式;不管采用哪种方式进入我们的程序,都要有一段"段拷贝"程序,跑完了段拷贝后才能可以进入我们主程序了!（顺便提一下:startup.s这个文件并没有所谓的"段拷贝"功能,再看也无益!）
对含有启动程序来说,"执行地址与加载地址相同"不容易实现：
如果执行地址与加载地址相同哪当然不需要做"段拷贝",但是个人理解编译器还会加入"段拷贝"程序(如果用B __main的话),只是因为条件不满足而不执行而已;但是对含有启动程序来说,"执行地址与加载地址相同"就不容易了.因为启动程序是要烧到非易失存储器里,用来在上电执行的,而这个程序必定会有RW段,如果RW放在非易失存储器,如FLASH,那就不好实现RW功能了,因此要给RW移动到能够实现RW功能的存储器,如SRAM等.因此,对含有启动程序来说,"执行地址与加载地址相同"就不容易实现;程序的入口点在C 库中的__main 处，在该点，库代码执行以下操作：
1. 将非零（只读和读写）运行区域从其载入地址复制到运行地址。
2. 清零ZI 区域。
3. 跳转到__rt_entry。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ca8bb64fcf27bd05942fd15cf4376dc/" rel="bookmark">
			mysql存储过程中 declare 和 set 定义变量的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql存储过程中，定义变量有两种方式：
1.使用set或select直接赋值，变量名以 @ 开头.
例如:set @var=1;
可以在一个会话的任何地方声明，作用域是整个会话，称为会话变量。
2.以 DECLARE 关键字声明的变量，只能在存储过程中使用，称为存储过程变量，例如：
DECLARE var1 INT DEFAULT 0; 主要用在存储过程中，或者是给存储传参数中。
两者的区别是：
在调用存储过程时，以DECLARE声明的变量都会被初始化为 NULL。而会话变量（即@开头的变量）则不会被再初始化，在一个会话内，只须初始化一次，之后在会话内都是对上一次计算的结果，就相当于在是这个会话内的全局变量。
在存储过程中，使用动态语句，预处理时，动态内容必须赋给一个会话变量。
例：
set @v_sql= sqltext;
PREPARE stmt FROM @v_sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/020251374f686325124c8b01a2c9d271/" rel="bookmark">
			细说tkprof的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		熟悉oracle的同学，对tkprof应该不会陌生。今天用到tkprof，有些语法变得模糊起来。查看文档，重新梳理有关tkprof的有关知识，加深记忆。
通过tkfprof可以非常方便的跟踪诊断sql语句的执行效率。结合explain plan的使用，更是如虎添翼。
sql trace为我们查看某天sql 语句的性能信息提供了可能，通常sqltrace可以生成下面的统计信息：
Parse, execute, and fetch counts 解析 执行和抓取的动作数量CPU and elapsed times 花费在cpu和整个操作上的时间Physical reads and logical reads 物理读和逻辑读Number of rows processed 处理的记录数量Misses on the library cache 库缓存的丢失率Username under which each parse occurred 执行用户Each commit and rollback 每次的提交和回滚操作 （tkprofl不会处理这些信息）Wait event data for each SQL statement, and a summary for each trace file 针对每条sql语句和所有的sql语句生成事件信息数据 除此之外，如果在sql trace期间，跟踪的语句游标已经关闭，sql trace还会提供如下的行源信息 Row operations showing the actual execution plan of each SQL statementNumber of rows, number of consistent reads, number of physical reads, number ofphysical writes, and time elapsed for each operation on a row 语法格式： [oracle@oadata trace]$ tkprof Usage: tkprof tracefile outputfile [explain= ] [table= ] [print= ] [insert= ] [sys= ] [sort= ] table=schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/020251374f686325124c8b01a2c9d271/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c13914bf7738d9e49eb62e141725c8/" rel="bookmark">
			3.启停redis服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.编译redis.conf参数文件 安装完成后，我们就得尝试启动redis服务了。 在$REDIS_HOME，编译如下文件 /home/ldh/redis/redis-2.8.3/redis.conf 修改端口 将PORT 6379改成你想要的被客户访问的端口，不改也可以，只要不冲突。 设置密码： redis.conf中requirepass前的注释去掉，后面加上密码，如 requirepass pass1234 如果服务已经启动，修改密码后需要重启服务才能使新密码生效。 2.启动服务 启动服务，假如不用Nohup的话，当前会话就不能再进行其他操作咯。 nohup redis-server /home/ldh/redis/redis-2.8.3/redis.conf &amp; 我们来看看nohup.out中，这个服务启动会反馈什么信息 [ldh@hauser redis-2.8.3]$ vi nohup.out [22624] 25 Dec 11:00:06.456 # Fatal error, can't open config file '/home/otredis/redis/2.6.16/conf/redis.conf' [22726] 25 Dec 11:06:01.442 # Fatal error, can't open config file '/home/otredis/redis/2.6.16/conf/redis.conf' [22737] 25 Dec 11:06:25.925 # Unable to set the max number of files limit to 10032 (Operation not permitted), setting the max clients configuration to 992.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8c13914bf7738d9e49eb62e141725c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd6c687247f953324c46e7a9b2e837a7/" rel="bookmark">
			《私人订制》--冯氏贺岁剧的隔年回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨晚和家人一起去看了《私人订制》，时光网上的低评分本来让我想选择《无人区》，后来因为时间的关系还是捧了冯小刚的场。范伟的当官梦十分精彩，活脱脱的冯氏风格的官场现形记，是这个时代的黑色喜剧，让人想起契诃夫和马克吐温这样的讽刺大师。范伟把一个卑微的司机所见所想的一把手演得淋漓尽致，短暂的角色扮演里，真实与虚幻编织出生活的荒诞。
导演的一腔俗血，情节相比就有些生硬。雅俗之辨在这样的喜剧电影里当然很难有深度的诠释，于是观众看到的就是编剧王朔对俗的不屑，对俗人求雅的嘲讽，愤怒之余只剩下人人皆俗，谁也别给我装高雅玩高雅的理直气壮，和隐隐的悲哀。
第三节马嫂的有钱人的梦更接近冯小刚贺岁片的小人物喜剧风格。精神上还延续了上一节对这个时代爆发土豪的嘲笑，但对于主人公这样一个底层劳动人民的典型，最后回归了中国人的家庭观世界观，在温情的歌声里，经历了一日如梦富人日子的马嫂形单影只地走回低矮阴暗的平房和狭窄的胡同，我的眼睛也湿润了。
本来以为这么短的小故事至少会有五个，没想到匆匆进入了最后一章。反思我们的物质文明和自私的人性，像伤痕累累的大自然母亲道歉。几乎要习以为常的遮天浓霾、布满巨大的塌陷坑的草原、污臭不堪垃圾拥塞的河流，在电影的大屏幕上，在人人掏钱进影院寻欢笑的时刻，震撼人心。几位主角的诚挚独白、道歉和提问也是大家共同的思考。“为什么一百万一千万一个亿你都愿意捐，一辆汽车却不愿意？”“因为我真的有一辆车。”这个老笑话最后从葛优嘴里说出来时，不再好笑，意味深长。
P.S.冯小刚导演这些年来的电影越来越带有人文反思，以前他拍《甲方乙方》、《没完没了》时是我喜欢的导演，现在他拍《一九四二》、《私人订制》，则是我尊敬的导演。第一节对官场的讽刺辛辣大胆，也算是和最近“老虎苍蝇一起打”的风向一致，虽然结尾时马秘书还要表明立场地解释一下和现实的差别。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edbcff472e55c3d3bac9047a73554142/" rel="bookmark">
			2013年12月15日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		socket = mFactory.createSocket(host, port); assertNotNull(socket); assertNotNull(socket.getOutputStream()); assertNotNull(socket.getInputStream()); // it throw exception when calling createSocket(String, int, InetAddress, int) // The socket level is invalid. } // a host and port that are expected to be available but have // a cert with a different CN, in this case CN=mtalk.google.com private static String TEST_CREATE_SOCKET_HOST = "mobile-gtalk.l.google.com"; private static int TEST_CREATE_SOCKET_PORT = 5228; public void test_createSocket_simple() throws Exception { try { socket = mFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edbcff472e55c3d3bac9047a73554142/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1430046070e345f25d00bb201c94d36/" rel="bookmark">
			vxWorks&amp;nbsp;BSP主要文件目录的组成及…
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.目录target/config/All: 这个目录下的文件是所有BSP文件共享的，不是特别需要不要更改里面的任何文件。 a.configAll.h: 缺省定义了所有VxWorks的设置。如果不用缺省的设置，可在BSP目录下的config.h文件中用#define或#undef方式来更改设置。 b.bootInit.c: 在romInit.s后完成Boot ROM的第二步初始化。程序从romInit.s中的romInit()跳到这个文件中的romStart()来执行必要的解压和ROM image的放置。 c.bootConfig.c: 完成Boot ROM image的初始化和控制. d.usrConfig.c: VxWorks image的初始化代码. 2.目录target/config/comps/src: 涉及系统核心的components，主要由target/config/All中usrConfig.c中函数调用。 3.目录target/config/bspname: 包含系统或硬件相关的BSP文件。 a.Makefile 一些命令行控制images的生成。 b.README BSP发布纪录,版本,总的文档。 c.config.h 包括所有涉及CPU主板的设置及定义(includes,definations)。 d.configNet.h 网络驱动的主要设置文件，主要对END驱动设置。 e.romInit.s 汇编语言文件，是VxWorks Boot ROM和ROM based image的入口。 f.sysALib.s 汇编语言文件，程序员可以把自己的汇编函数放在这个文件里。在上层调用VxWorks image的入口点_sysInit在这个文件里，是在RAM中执行的第一个函数。 g.sysLib.c 包含一些系统相关的函数例程，提供了一个board-level的接口，VxWorks和应用程序可以以system-indepent的方式生成。这个文件还能包含目录target/config/comps/src的驱动。 h.sysScsi.c 可选文件用于Scsi设备设置和初始化。 i.sysSerial.c 可选文件用于所有的串口设置和初始化。 j.bootrom.hex SIC文件包含VxWorks Boot ROM代码。 k.xWorks 运行在目标机上,完整的,连结后的VxWorks二进制文件。 l.VxWorks.sym 完全的，连结后带有符号表的VxWorks二进制文件。 m.VxWorks.st 完全的，连结后，standalone，带有符号表的VxWorks二进制文件。 注： BSP用"make"来编译连接生成(Created)，而不是用Tornado的工具。 BSP和应用程序都可以在"make"或"tornade"上开发(developed) BSP被设置包括以下驱动: 中断控制interrupt controller、计时器timer(sys/aux)、串口UART(serial)、显示屏LCD、键盘Keyboard(opt)、触摸屏touch-screen(opt)。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1faae6c21b1cafb4caffaecff479f88/" rel="bookmark">
			免费GIM企业即时通讯系统(服务器/客户端)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GIM企业即时通讯是笔者Garfield(QQ：3674571)采用.NetFramework4.0+SQL2008R2开发的一套企业内网/外网通用的即时通讯(IM)软件，分为服务器端和客户端，通讯使用UDP/TCP底层开发。界面高仿QQ2013，主要功能包括：即时消息、离线消息、消息字体设置、图片表情、抖动窗口、手写板、屏幕截屏、文件批量传输、消息管理、个性头像、个性昵称和服务器端组织机构、人员管理等功能。后续会逐渐添加群组聊天、语音聊天、视频聊天等功能。
当前版本为测试版，程序本身未添加任何限制。欢迎大家下载试用，请勿用于商业用途。
程序文件已经混淆，请要反编译代码的绕行。谢谢
百度云下载地址：
GIM使用说明书V1.2.pdf http://pan.baidu.com/s/1pJ0NaYJ
客户端下载地址 http://pan.baidu.com/s/1DzmpS
服务器端下载地址 http://pan.baidu.com/s/1o66phEy
CSDN下载地址：
GIM使用说明书V1.2.pdf http://download.csdn.net/detail/garfield21/6789193
客户端下载地址 http://download.csdn.net/detail/garfield21/6788737
服务器端下载地址 http://download.csdn.net/detail/garfield21/6789167 软件界面：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ea9bf25e1cc7ec7a71612c494e758b/" rel="bookmark">
			datagridview 拖拽 换行 复制 删除 排序实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		datagridview方面的问题，我碰到了好多好多，每次解决了，下次碰到又会忘记，又得重新找和试，所以现在记下来，以便以后进行参考。
首先，第一个问题，将datagridview的属性AllowUserToAddRows 设置为False时，添加datagridview的datasouce才不会出错，否则会出现异常：Row index provided is out of range.
首先这是个Why?
嘿嘿，不要被我上述给误导了，我刚新建了一个工程，只加了一个datagridview，设置了其datasouce，发现属性AllowUserToAddRows对datagridview的显示根本没有上述的影响，嘿嘿，所以上述的异常，是因为我程序做了其他功能时，才导致了，我妄下论断了。但是究竟是为什么，还是一点一点的挖吧。。。
最近一直在学跳舞，所以没时间弄，今天终于有了一天完整的时间，嘿嘿，开始学吧，要不，写这些有什么用。
昨天在抽空的时候，看了下virtual的使用方法，因为我想做一个窗口，让其他子窗口继承自它，不同的只是数据不一样，子窗口命名名称不一样，所以用到了virtual和override。
学习了别人的使用方法，我总结的是，在各个子类实现全一样的前提下，该方法直接在父类实现。而对于不同子类有差别的功能实现，则在父类使用virtual，然后再子类进行override，对于不同子类进行重写。
还有一个问题，就是List泛型，其实不是第一次使用泛型，但是上次看它用它的时候，还是感觉它好难好远。现在的理解是，泛型是数组的加深版本，将数据加到泛型和ArrayLis是一样的，但是取出时，泛型可以直接取出用，而ArrayLis要进行类型强制转换，才能取出使用，否则报错，错误原因为：Cannot implicitly convert type 'object' to '对象类型'. An explicit conversion exists (are you missing a cast?) 2014年1月3日
今天看了几个拖拽，文本文档.txt格式的不支持拖拽，word支持，但是移到本身的图标应该为禁止拖拽比较好，它还是可以拖拽的显示。当然，用Microsoft Visual Studio使用拖拽，是像想象的那样，没有什么不同，就像现在这种编辑界面，也是一样的，我现在觉得这可以做成拖拽的一种标志，就应该要做成这样，同学们可以试下。
行的拖拽，今天算是实现了，可以多行直接移动，可是令我十分纠结的一点是，我怎么选多行一起进行拖拽。看别人以前程序是，右键进行多行拖拽，直接拖到另一个DataGridView，我说这很简单，因为右键点击不影响当前单元格的选中行。如果是左键，在我连续选中了多行以后，再重新按下左键准备进行拖拽，行的选中从多行变成了只按下的这一行。因为左键本身是有选择这一功能的，而右键没有。现在已经是可以移动多行了，但是拖拽太不明了，因为左键的无法选中多行，我要想怎么给它加上或者怎么样？？？？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b4193339a9a2f11681181a2e87696e/" rel="bookmark">
			用位运算将a和b的值互换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 例如：ａ＝３，即11（2）；ｂ＝４，即100（2）。
想将ａ和ｂ的值互换，可以用以下赋值语句实现：
ａ＝a∧b;
ｂ＝b∧a;
ａ＝a∧b;
ａ＝011(2)
（∧）ｂ＝100(2)
ａ＝111(2)（a∧b的结果，a已变成７）
（∧）ｂ＝100(2)
ｂ＝011(2)（b∧a的结果，b已变成３）
（∧）ａ＝111(2)
ａ＝100（2）（a∧b的结果，a已变成４）
等效于以下两步：
① 执行前两个赋值语句：“ａ＝ａ∧ｂ；”和“ｂ＝ｂ∧ａ；”相当于b=b∧(a∧b)。
② 再执行第三个赋值语句： ａ＝ａ∧ｂ。由于a的值等于（ａ∧ｂ），b的值等于（ｂ∧ａ∧ｂ），
因此，相当于a=ａ∧ｂ∧ｂ∧ａ∧ｂ，即a的值等于ａ∧ａ∧ｂ∧ｂ∧ｂ，等于ｂ。
很神奇吧！
#include &lt;stdio.h&gt; void main() { int a=3; int b = 4; a=a^b; b=b^a; a=a^b; printf("a=%d b=%d",a,b); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b0276efc72bf0edf992d4b5b1d4d7f/" rel="bookmark">
			latch:cache buffers chains等待事件导致的latch争用的原理原因与检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		latch:cache buffers chains 原理 当一个数据块读入到sga中时，该块的块头(buffer header)会放置在一个hash bucket的链表(hash chain)中。该内存结构由一系列cache buffers chains子latch保护（又名hash latch或者cbc latch）。对Buffer cache中的块，要select或者update、insert,delete等，都得先获得cache buffers chains子latch，以保证对chain的排他访问。若在过程中发生争用，就会等待latch:cache buffers chains事件。 产生原因： 1. 低效率的SQL语句（主要体现在逻辑读过高） 在某些环境中，应用程序打开执行相同的低效率SQL语句的多个并发会话，这些SQL语句都设法得到相同的数据集，每次执行都带有高 BUFFER_GETS(逻辑读取)的SQL语句是主要的原因。相反，较小的逻辑读意味着较少的latch get操作，从而减少锁存器争用并改善性能。注意v$sql中BUFFER_GETS/EXECUTIONS大的语句。 2.Hot block 当多个会话重复访问一个或多个由同一个子cache buffers chains锁存器保护的块时，热块就会产生。当多个会话争用cache buffers chains子锁存器时，就会出现这个等待事件。 有时就算调优了SQL，但多个会话同时执行此SQL，那怕只是扫描特定少数块，也是也会出现HOT BLOCK的。 检查 看下当前active的会话中产生的比较高buffer get的SQL： select * from (select sql_text,hash_value,buffer_gets/executions from v$sql where executions&lt;&gt;0 and hash_value in (select sql_hash_value from gv$session where status='ACTIVE' )order by buffer_gets/executions desc ) where rownum&lt;16; 通过 v$latch查看 自实例启动以来cache buffers chains锁存器争用是否厉害： select round((misses/gets)*100)||'%',round(100*(immediate_misses/(immediate_gets+immediate_misses)))||' %' from v$latch where name='cache buffers chains'; 对于willing-to-wait,比较重要的是misses/gets，假如大于1%就应该发生争用了，大于10%，就有争用严重的情况了。对于no-wait模式，immediate_misses/(immediate_gets+immediate_misses)也一样。 通过查询子锁存器视图，看看是否有Hot Block，并且获取有Hot Block的子锁存器addr select * from (select addr,child#,gets,misses,sleeps from v$latch_children where name='cache buffers chains' order by sleeps desc ) where rownum&lt;=20; 如果存在倾斜明显，即某些子锁存器的GETS与SLEEPS比其他子锁存器高很多，则可以推测相应锁存器管辖的chain上有Hot Block。 另外一种判断Hot block方法，是从当前等待latch:cache buffers chains事件的会话出发。通过v$session_wait视图，获得P1RAW即子锁存器的地址。通过重复观察v$session_wait视图，发现某个子锁存器地址较多地出现，那么该子锁存器管辖的chain可能有热块。 select p1,p1raw from v$session_wait where event='latch: cache buffers chains'; 所以v$session的p1raw与x$bh的laddr，以及v$latch_children的addr是同样的东西，都是子锁存器的地址。 大概思路是，通过子锁存器的热度来找到所管辖的对象，以及对象的热度。 通过子锁存器地址，即v$latch_children的addr字段，来获取这些子锁存器所管理的对象的文件号块号与热度。 注意到x$bh字典表中的tch字段表示的就是block的touch count,一般来说这个值越高那么这个块就越热，我们称这样的块就叫做热点块。 select hladdr,obj,(select object_name from dba_objects where (data_object_id is null and object_id=x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58b0276efc72bf0edf992d4b5b1d4d7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f829e3dee339ae77646eee16beafdf2/" rel="bookmark">
			python opencv 图像尺寸变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 利用python opencv中的 cv.Resize(源，目标，变换方法)就可以实现变换为想要的尺寸了
源文件：就不用说了
目标：你可以对图像进行倍数的放大和缩小 也可以直接的输入尺寸大小
变换的方法：
CV_INTER_NN - 最近邻插值, CV_INTER_LINEAR - 双线性插值 (缺省使用) CV_INTER_AREA - 使用象素关系重采样。当图像缩小时候，该方法可以避免波纹出现。当图像放大时，类似于 CV_INTER_NN 方法.. CV_INTER_CUBIC - 立方插值. 如 我要将一个图片变为32*32大小的
image=cv2.imread('test.jpg')
res=cv2.resize(image,(32,32),interpolation=cv2.INTER_CUBIC)
cv2.imshow('iker',res)
cv2.imshow('image',image)
cv2.waitKey(0)
cv2.destoryAllWindows() 当然要正常的导入opencv 库 自己试过了哈 网上很多的已经过时了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f7cd98fa001c3c3409977923c64afbe/" rel="bookmark">
			利用Cookie保存相应信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//登陆显示上次登陆的时间 import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletException; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; //使用Cookie对上次登陆时间进行记录 public class CookiesTest extends HttpServlet { private static final long serialVersionUID = 1L; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType("text/html;charset=utf-8"); PrintWriter out = response.getWriter(); //从客户端获取web服务器相关的cookie信息 Cookie[] cookies = request.getCookies(); //定义用于存放时间值 String time=""; //有无此类型的Cookie的标识 Boolean flag=false; //客户端存在类型的Cookie,进行一步的判断 if(cookies!=null &amp;&amp; cookies.length&gt;0){ //循环cookie for(Cookie c:cookies){ //当需要的cookie拿到之后 if("lastTime".equals(c.getName())){ //就取出相应的内容 time=c.getValue(); flag=true; //断开 break; } } out.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f7cd98fa001c3c3409977923c64afbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/368f22008025fe4266ae4f8934794f24/" rel="bookmark">
			python解决ImportError: No module named google.protobuf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://blog.csdn.net/paynetiger/article/details/8197326
关于protocol buffer的优点，这里就不多贴废话了，如果涉及到数据传输和解析，使用pb会比自己去写解析代码更有效率，至少对于大部分而言是这样的。。
一、下载&amp;安装
要使用之前先到code.google.com上搜索protocol buffer，下载到本地，解压后依次执行：
./configure
make
make check
make install
最后一步涉及到权限，可能会需要sudo。
二、定义一个proto文件
下面依然是给出一个简单的例子，要使用proto首先需要自己定义一个proto文件，定义一个people.proto文件，内容如下：
message people
{
optional string name = 1;
optional int32 height = 2;
}
三、生成一个python可用的py文件
然后就是生成对应的py文件，命令如下：
protoc -I=./ --python_out=./ people.proto
其中-I是source的路径，--python_out表示对应python库的生成路径，然后是对应的proto文件。当然，pb还支持c++和java，修改--python_out即可。
完成后就有对应的people_pb2.py文件了。导入后即可使用，第一次安装后直接用应该会提示：ImportError: No module named google.protobuf，这是因为找不到对应的库路径导致，到你下载的pb路径下，找到python路径，执行sudo python setup.py install，执行完后可以通过执行sudo python setup.py test检查是否有安装成功，如果最后提示
----------------------------------------------------------------------
Ran 193 tests in 0.327s
OK
那么就是安装成功了，此时再导入对应的pb2.py文件即可使用。
--------------------------------------------------------------------------------------------------------------------------------------------------------
执行python setup.py install 时可能有：This script requires setuptools version 0.6c11 to run
可从：http://download.csdn.net/download/fhqsse220/5602687下载
gzip -d setuptools-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/368f22008025fe4266ae4f8934794f24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78e3c6f6395b7e47f7e410147dba6c6d/" rel="bookmark">
			centos安装bugfree
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BugFree基于PHP和MySQL开发，是免费且开发源代码的缺陷管理系统。服务器端在Linux和Windows平台上都可以运行；客户端无需安装任何软件，通过IE，FireFox等浏览器就可以自由使用。
BugFree 2 在BugFree 1.1的基础上，集成了Test Case和Test Result的管理功能。具体使用流程是：首先创建Test Case（测试用例），运行Test Case产生Test Result（测试结果），运行结果为Failed的Case，可以直接创建Bug。Test Case标题、步骤和Test Result运行环境等信息直接复制到新建的Bug中。
安装步骤：
一、安装mysql
# yum install mysql mysql-server
二、安装并启动apache
# yum install httpd
# /etc/init.d/httpd start(stop,restart)
然后用ie打开http://服务器地址。应该能看到熟悉的apache羽毛标志。
apache默认为80端口，如果已经被占用，可以在主配置文件中修改监听端口
查看服务器在运行的程序及端口：
#netstat -tunlp 修改监听端口：
#vi /etc/httpd/conf/httpd.conf
将第136行Listen 80修改为想要的端口
添加防火墙规则
# vi /etc/sysconfig/iptables
-AINPUT -p tcp –dport 80 –j ACCEPT
yum形式安装的apache的发布目录默认为：/var/www/html
三、安装php及mysql支持
#yum list|grep php
#yum install php php-mysql
修改apache配置使其支持php
#vi /etc/httpd/conf/httpd.conf
搜索AddType，在后面添加
AddType application/x-httpd-php .php AddType application/x-httpd-php-source .phps
1、重启apache，/etc/init.d/httpd restart
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78e3c6f6395b7e47f7e410147dba6c6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c0d3a7aa5e8290a344f50029f6d571f/" rel="bookmark">
			Android系统时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、获取系统时间
SimpleDateFormat timeFormat = new SimpleDateFormat("HH-mm-ss"); SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); strTime = timeFormat.format(new java.util.Date()); strDate = dateFormat.format(new java.util.Date()); 2、可以获取当前的年月时分,也可以分开写: SimpleDateFormat sDateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); String date = sDateFormat.format(new java.util.Date()); 3、指定时区的时间 df=DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL,Locale.CHINA); System.out.println(df.format(new Date())); 4、查看系统当时使用的时区 timeFormat.getTimeZone(); System.out.println("TimeZone:" + timeFormat.getTimeZone());说明：eclipse刚开始安装时，使用上面的方式获取系统时间错误，和本地显示时间不一致，这是因为使用的是系统默认时区，即：New_York ，不是中国标准时间。 5、设置系统时区：
AlarmManager mAlarmManager = (AlarmManager)getSystemService(Context.ALARM_SERVICE); mAlarmManager.setTimeZone("GMT+08:00"); //mAlarmManager.setTimeZone("Asia/Shanghai"); 设置时区需要在manifest.xml中增加如下权限： &lt;!-- 允许设置时区--&gt; &lt;uses-permission android:name="android.permission.SET_TIME_ZONE" /&gt; 6、Android系统时间是24小时制还是12小时制 ContentResolver cv = this.getContentResolver(); String strTimeFormat = android.provider.Settings.System.getString(cv,android.provider.Settings.System.TIME_12_24); if(strTimeFormat.equals("24")) { Log.i("activity","24"); } 7、利用calender获取系统时间 Calendar c = Calendar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c0d3a7aa5e8290a344f50029f6d571f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7807e8efb165a16283ec04679fe32a59/" rel="bookmark">
			解决：hibernate 生成MySQL表 无外键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决办法： hibernate.cfg.xml 配置文件 修改: &lt;!-- SQL dialect --&gt; 改为 &lt;propertyname="dialect"&gt;org.hibernate.dialect. MySQLInnoDBDialect&lt;/property&gt; 而不是 &lt;propertyname="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8178fb9bded613ef9467416e024a66e5/" rel="bookmark">
			CF卡技术详解——笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识太全面了，摘抄摘不完，还是粘过来加上注释和笔记吧。
重点以及断句用加粗，注释用红括号。
很早以前转的，图片不知道怎么都丢了
一.CF卡技术及规格
一.CF卡技术及规格
1.CF卡简史
随着数码产品的高速普及，近年来闪存卡也进入了高速发展时期，得到了越来越广泛的应用，相机、手机、掌上电脑、随身听上处处都可能用到闪存卡。闪存卡有很多种类，常见的有CF卡、SD卡、MMC卡、记忆棒、SM卡、xD卡等，其中CF卡已经有了相当长的历史，由于其建立标准的时间长、兼容性好、容量大、价格低等原因而得到了广泛的应用，是通用性 最强的存储卡之一。
CF卡的全称为“Compact Flash”卡，意为“标准闪存卡”（我表示怀疑，不是紧凑么？），简称“CF卡”，Compact Flash技术是由Compact Flash协会（CFA）提出的一种与PC机ATA接口标准兼容的技术，CFA由CF技术的主导者组成，不过CF和CF+技术并没有技术和权利金障碍，这也是其得到普及的重要原因之一。CF卡作为一种先进的移动数码存储产品， 当时其优势是很明显的，它具有高速度、大容量、体积小、重量轻、功耗低等优点，很容易就获得了一致的认可。CFA是1995年成立的，而CF卡的历史还要早一些，Sandisk公司1994年就制造出了最早的CF卡。
2.CF卡结构
十年过去了，CF卡的价格大为下降，容量和性能有了很大的提升，不过基本的结构并没有改变。
CF卡与其它存储卡相比，有几个特点。CF卡 使用flash作为存储媒介，无需供电也能保存资料，而且工作时耗电量也很低，它在3.3V或者5V的电压下工作，其耗电量只相当于传统存储设备如磁带、硬盘的3%或更低，适合用在移动设备上；如上图，CF卡由两个基本部分组成：控制芯片和闪存模组，闪存用于存储信息，控制芯片用来实现与主机的连接及控制数据在闪存模块中的传输。
我们结合实物来解说一下。这是某相机附带的16MB CF卡，打开后可以发现它是由前后两块金属外壳和里面的电路板组成。
CF卡的结构是比较简单的，控制芯片和若干片闪存分别安装在PCB的两面，然后再加上塑料、强化玻璃或金属质地的外壳。整个CF卡比较坚固，而且没有机械结构，因此除了省电之外，也具有更好的安全性和可靠性，CF卡可以承受比较强的冲击，自如从3米高处摔落都不会对它造成任何影响。在这块CF卡中，使用了一颗Sandisk控制芯片和一颗128Mb(16MB)的Sandisk闪存芯片 ，从芯片上的日期来看，这块卡是几年前的产品了。
这块CF卡仅有16MB容量，因此只在正面用了一颗闪存芯片。
3.CF卡工作原理
看到这里，对闪存产品有所了解的读者一定会说，这样看来，CF卡很像现在满地皆是的闪盘呢。的确，虽然形状不同，但CF卡和闪盘结构相似，有许多相同之处，不过 它们也有很大的区别，比如二者的管理和工作方式。
现在的CF卡和闪盘基本都使用NAND型flash，NAND Flash自身是没有存储控制器的，其结构可看作是由许多的小区块组成的，每块都能存储一定数量的信息，类似于硬盘的簇。NAND型flash的读写也是以块和页（到底是块还是页？）为单位来进行的，使用8bit的I/O端口存取数据。
NAND型flash容量大、成本低、可以达到比较高的速度，所以应用较为广泛，不过它也有些比较明显的缺点。NAND型flash的基本工作方式是按顺序读取，一个区块写入或读取结束再接着下一个，是“串行”方式而不是“并行”方式，操作上也是如此，比如区块上已有信息，就一定要先擦除，再写入，其它操作也是一样的。另一个问题就是NAND型flash需要一定的存储空间来存放目录等信息来管理所有的资料，进行任何操作都需要使用这一部分，大部分闪盘的控制芯片都使用固定区块，所以其使用次数远高于其它区块，不管闪存是号称10万次擦写寿命也好，100万次擦写寿命也好，如果使用很频繁，即使每次只用一点点存储空间，也可能因为目录区损坏及缺乏有效扫描除错手段（指什么）而造成数据丢失，需要格式化才能解决问题。
从NAND型闪存的以上特点，我们可以看出这一类存储器需要的是什么的，在拥有大容量、低成本的存储介质之后，还需要先进的控制器及程序来驱动及使用才能够使存储器具有比较好的性能及可靠性，否则不但性能低下，使用寿命也短。
CF卡比闪盘之类的存储器更加接近硬盘，CF卡内部控制器设计完全模拟硬盘，而且使用标准的ATA/IDE接口界面（这段知识不容易入脑，mark，以后查阅吧），可以很容易的通过IDE接口与电脑连接，而且早已实现无驱动设计，使用非常方便。CF卡最初一般是配备PCMCIA适配器在笔记本电脑的PCMCIA插槽上使用，现在还有了许多USB、IEEE1394读卡器等各种各样的CF适配器，使CF卡与电脑之间的信息传输变得更加方便。由于Windows 95以上的所有操作系统都内置PCMCIA接口的IDE硬盘控制器驱动程序，Windows ME以上的操作系统也加入了对USB、IEEE1394接口移动磁盘的支持，所以只要为CF卡加上一个简单的接口控制器（转接器），就可以直接在电脑上使用，移动版的Windows Mobile也早已加入对CF/CF+的支持，连转接器都免了。由于CF卡内置控制器和仿硬盘的设计，也简化了CF适配器的设计，只不过由于CF卡本身体积比SD等存储卡要大，针脚也多得多，所以相对来说往往还是CF适配器要大一些。
CF卡在自身设计上也作出了软硬件两方面的配合：一是硬件提供判断条件。CF卡在自身电路上提供了两个用来检测CF卡是否存在的管脚 （暂称CD1和CD2）。CD1和CD2的有效电平均为低电平，当主机检测到与其相连的CD1和CD2两个管脚同时为低电平时，可判断出CF卡与主机相连；当主机检测到与其相连的CD1和CD2有一个管脚不为低，则可判断出CF卡未与主机相连。 二是软件。首选定义全局变量（如：IsExist）用于记录CF卡是否与主机相连，当IsExist为0时表示CF卡未与主机相连；当IsExist为1时表示CF卡与主机相连。 然后，在每次操作CF卡时都先检测CF卡的CD1和CD2管脚，当检测到CD1和CD2管脚为低电平且IsExist为0时复位CF卡，重新检测CF卡的FAT表统计还剩余多少空间可以分配，检测完FAT表后置变量IsExist为1；当检测到CD1和CD2管脚为低电平且IsExist为1时，继续CF卡的正常操作 ；当检测到CD1和CD2为高时，停止CF卡操作，置变量IsExist为0。
通过软硬结合、内外配合，CF卡具备热插拔、即插即用、无须驱动的功能，也可以用来作为移动存储器使用。
前面我们说到NAND型flash使用8bit端口就可以完成页操作，CF卡的寄存器也都是8bit的，只有数据寄存器是16bit。 CF卡控制器中包含两组寄存器：命令寄存器和控制寄存器（怎么个控制寄存器法？和命令什么区别？是说把命令拆解成原操作了？），这两个寄存器组通过REG信号进行区分。CF卡工作在存储器方式时，按照ATA标准以寄存器方式传送数据、命令和地址，命令寄存器用来接受命令和传输数据 ，控制寄存器用来进行磁盘控制。当CF卡工作在I/O方式时，控制寄存器组主要用于控制CF卡的工作方式；命令寄存器组被分配在与ATA标准兼容的地址空间。当CF卡工作在I/O方式下，命令寄存器组的地址空间为IF0H～1F7H和3F6H～3F7H；当CF卡工作在寄存器方式下，命令寄存器组的地址空间为1F0H～1FFH。
CF卡的寄存器包括(细节部分，Mark)： 数据寄存器（R/W），用于对扇区的读写操作。主机通过该寄存器向CF卡卡控制器写入或从CF卡控制寄存器读出扇区缓冲区的数据； 错误寄存器（R）和特性寄存器（W），错误寄存器反映控制寄存器在诊断方式或操作方式下的错误原因。特性寄存器一般情况下不使用。 扇区数寄存器（R/W），用来记录读、写命令的扇区数目；扇区号寄存器（R/W），用来记录读、写和校验命令指定的起始扇区号； 柱面号寄存器（R/W），用来记录读、写、校验和寻址命令指定的柱面号； 驱动器/磁头寄存器（R/W），记录读、写、校验和寻道命令指定的驱动器号、磁头号和寻址方式（CHS模式或LBA模式）； 状态寄存器（R）和命令寄存器（W），状态寄存器反映CF卡驱动器执行命令后的状态，读该寄存器要清除中断请求信号，命令寄存器接收主机发送的CF卡工作的控制命令。
CF卡的扇区寻址有两种方式：物理寻址方式（CHS）和逻辑寻址方式（LBA）。物理寻址方式使用柱面、磁头和扇区号表示一个特定的扇区,起始扇区是0磁道、0磁头、1扇区，接下来是2扇区，一直到EOF扇区；接下来是同一柱面1头、1扇区等。逻辑寻址方式将整个CF卡同一寻址。逻辑块地址和物理地址的关系为：LBA地址=(柱面号×磁头数+磁头号)×扇区数+扇区数-1 在CF卡上写入一个文件的过程是这样的，在CF卡初始化后（CF卡上电复位和统计剩余空间等 工作已经完成），控制器中DSP开始向CF卡的一些寄存器填写必要的信息，如向扇区号寄存器填写读写数据的起始扇区号（LBA地址）和扇区数寄存器填写读写数据所占的扇区个数等 ，然后向CF卡的命令寄存器写入CF卡操作的命令，如写操作则向CF卡的命令寄存器写入30H，读操作向CF卡的命令寄存器写入20H等。删除或者再编程的过程相似。
看到这里大家可能发现了CF卡与硬盘越来越多的相似之处，不过有一点是完全不同的，那就是CF卡没有机械结构，所以一些操作是以虚拟方式进行。CF卡工作时一般采用逻辑寻址方式，它没有磁头和磁道的转换操作，因此在访问连续扇区时，操作速度比物理寻址方式快。 CF卡与可以完全像硬盘一样使用，不过由于和硬盘仍有许多不同之处，某些原本为硬盘设计的测试软件并不适合用来测试CF卡。
4.CF+/Compact Flash规格
Compact Flash协会制定了CF+/Compact Flash规格，最新版本为V2.0。CF卡遵循ATA标准制造，不过它的接口是50针而不是68针，分成两排，每排25个针脚。CF卡不是硬盘那样的针型接口而是50mil(1.27 mm)的孔型接口，因此不容易被损坏，这一设计和PC卡类似。
什么是CF+呢？CF+是Compact Flash的衍生技术规格，CF+的物理规格和CF完全相同，但CF+卡并不是CF卡那样的ATA闪存存储器，而主要是相同规格的I/O设备，如CF串口卡、CFmodem、CF蓝牙、CF USB卡、CF网卡、CF GPS卡、CF GPRS卡等，这一类设备在掌上电脑上用得最多，同样无须驱动，使用很方便，其兼容性也和CF卡一样好，加上PCMCIA适配器在笔记本电脑上一样可以使用。另一类CF+卡就是非闪存存储器，比如微型硬盘。
CF卡分为两类：Type I和Type II，二者的规格和特性基本相同。从上图大家可以看出，Type II型CF卡和Type I型CF卡相比，只是在外形上显得厚了一些，尽管只有这点区别，不过你要区分它们实在太容易了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8178fb9bded613ef9467416e024a66e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b422044bf732c0d4b624278a1caf12b7/" rel="bookmark">
			g_main_loop_new (NULL, FALSE) 原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gtk_main，g_main_loop_new原理分析
我们知道GUI应用程序都是事件驱动的。这些事件大部分都来自于用户，比如键盘事件、鼠标事件或笔点事件。还有一些事件来自于系统内部，比如定时事件、socket事件和其它文件事件等等。在没有任何事件的情况下，应用程序处于睡眠状态。 因为这种事件驱动机制，GUI应用程序都毫无例外的需要一个主循环(main loop)。主循环(main loop)控制应用程序什么时候进入睡眠状态，什么时候被唤醒。主循环实现得好，应用程序才能工作正常又省电。 在GTK+应用程序中，其主循环(main loop)非常简单，但是也非常的不明了： gtk_main (); 不少人用GTK+写了很长时间的程序，还是觉得这行代码很神秘，不知道里面到底干了什么。
本文试图分析一下gtk_main的工作原理： gtk_main主要是对glib的main loop的包装，基本上分为三步：
1. 调用初始化函数。 2. 进入glib main loop 3. 调用~初始化函数。 所以弄清楚glib main loop之后，gtk_main的实现也就尽收眼底了，本文重点分析glib的main loop的实现。main loop使用模式大致如下：
loop = g_main_loop_new (NULL, TRUE); g_main_loop_run (loop); g_main_loop_new创建一个main loop对象，一个main loop对象只能被一个线程使用，但一个线程可以有多个main loop对象。在GTK+应用中，一个线程使用多个main loop的主要用途是实现模态对话框，它在gtk_dialog_run函数里创建一个新的main loop，通过该main loop分发消息，直到对话框关闭为止。 g_main_loop_run则是进入主循环，它会一直阻塞在这里，直到让它退出为止。有事件时，它就处理事件，没事件时就睡眠。 g_main_loop_quit则是用于退出主循环，相当于Win32下的PostQuitMessage函数。 Glib main loop的最大特点就是支持多事件源，使用非常方便。来自用户的键盘和鼠标事件、来自系统的定时事件和socket事件等等，还支持一个称为idle的事件源，其主要用途是实现异步事件。
从最简单的例子开始：
//mainloop0.c #include&lt;glib.h&gt; GMainLoop* loop; int main(int argc, char* argv[]) { //g_thread_init是必需的，GMainLoop需要gthread库的支持。 if(g_thread_supported() == 0) g_thread_init(NULL); //创建一个循环体，先不管参数的意思。 g_print("g_main_loop_new/n"); loop = g_main_loop_new(NULL, FALSE); //让这个循环体跑起来 g_print("g_main_loop_run/n"); g_main_loop_run(loop); //循环运行完成后，计数器减一 //glib的很多结构类型和c++的智能指针相似，拥有一个计数器 //当计数器为0时，自动释放资源。 g_print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b422044bf732c0d4b624278a1caf12b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f80540087c63e44ad50ccd04e83ef03/" rel="bookmark">
			setupfactory  操作 注册表例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//判断注册表里是否有安装火狐的记录
result = Registry.DoesKeyExist(HKEY_LOCAL_MACHINE, "SOFTWARE\\Mozilla\\Firefox");
if(result==true)
then
result1 = Dialog.Message("注意", "你的电脑已经安装火狐是否重新安装？", MB_OKCANCEL, MB_ICONINFORMATION, MB_DEFBUTTON1);
if(result1==1)
then
Shell.Execute(SessionVar.Expand("%AppFolder%\\Firefox-full-latest.exe"), "open", "", "", SW_SHOWNORMAL);
end;
else result1 = Dialog.Message("注意", "你的电脑没有安装火狐请点击确认安装？", MB_OKCANCEL, MB_ICONINFORMATION, MB_DEFBUTTON1);
if(result1==1)
then
Shell.Execute(SessionVar.Expand("%AppFolder%\\Firefox-full-latest.exe"), "open", "", "", SW_SHOWNORMAL);
end;
end;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/514b25f6065a3a0767148c9b3f051759/" rel="bookmark">
			C&#43;&#43;时间标准库时间time和系统时间的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：http://www.cnblogs.com/yukaizhao/archive/2011/04/29/cpp_time_system_time.html
1. C++标准库中的时间需要引用time.h，可以取的本地时间或者格林威治时间，只能精确到秒
#include &lt;iostream&gt; /*包含time头文件*/ #include &lt;time.h&gt; using namespace std; int main() { //time_t是long类型，精确到秒，是当前时间和1970年1月1日零点时间的差 const time_t t = time (NULL); cout&lt;&lt; "current time is " &lt;&lt;t&lt;&lt;endl; /*本地时间：日期，时间 年月日，星期，时分秒*/ struct tm * current_time = localtime (&amp;t); printf ( "current year is %d;current month is %d;current date of month is %d\r\n" , 1900 + current_time-&gt;tm_year, 1 + current_time-&gt;tm_mon /*此month的范围为0-11*/ , current_time-&gt;tm_mday); printf ( "current day of year is %d;current day in week is %d\r\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/514b25f6065a3a0767148c9b3f051759/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5e5a0b5939e7fec073474de7f56ab47/" rel="bookmark">
			Shell脚本 字符串大小比较 字符串是否相等比较 字符串是否为空判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串比较的方法： 相等比较:
$str1 = $str2 //检查str1与str2是否相同
$str1 != $str2 //检查str1与str2是否不同
大小比较:
$str1 &lt; $str2 //检查str1是否小于str2
$str1 &gt; $str2 //检查str1是否大于str2
判断字符串是否为空:
-n str1 //检查str1的长度是否大于0
-z str1 //检查str1的长度是否为0
注意：：
上面的6个字符串比较。“所有的符号两侧都有空格”，必须小心使用不然将会出现语法错误。
同时字符串大小的比较，不能向上面的那么简单，因为shell不知道&gt;是大于还是输出重定向，
&lt;是小于还是输入重定向。 所以，&lt;和&gt;必须进行转义。
所以字符串大小的比较使用if [ $val1 \&gt; $val2 ]
//中括号两边必须加空格，符号两边必须加空格。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5da676da41b22100c105dc62ef30f058/" rel="bookmark">
			python中的sum函数.sum(axis=1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看起来挺简单的样子，但是在给sum函数中加入参数。sum（a，axis=0）或者是.sum(axis=1) 就有点不解了
在我实验以后发现 我们平时用的sum应该是默认的axis=0 就是普通的相加 （对不起，写的不好，看下面的）
而当加入axis=1以后就是将一个矩阵的每一行向量相加
例如：
import numpy as np
np.sum([[0,1,2],[2,1,3]],axis=1)的结果就是：array（[3,6]）
希望可以帮到你 呵呵
Sorry，以前学习阶段写东西比较随意，现在补充完善一下：
1. python 自己的sum（）
输入的参数首先是［］
&gt;&gt;&gt; sum([0,1,2]) 3 &gt;&gt;&gt; sum([0,1,2],3) 6 &gt;&gt;&gt; sum([0,1,2],[3,2,1]) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: can only concatenate list (not "int") to list 2.python的 numpy当中
现在对于数据的处理更多的还是numpy。没有axis参数表示全部相加，axis＝0表示按列相加，axis＝1表示按照行的方向相加
&gt;&gt;&gt; import numpy as np &gt;&gt;&gt; a=np.sum([[0,1,2],[2,1,3]]) &gt;&gt;&gt; a 9 &gt;&gt;&gt; a.shape () &gt;&gt;&gt; a=np.sum([[0,1,2],[2,1,3]],axis=0) &gt;&gt;&gt; a array([2, 2, 5]) &gt;&gt;&gt; a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5da676da41b22100c105dc62ef30f058/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daa53118fd42ce1f310f89aa70015727/" rel="bookmark">
			获取Spring容器中Bean实例的工具类(Java泛型方法实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Spring做IoC容器的时候，有的类不方便直接注入bean，需要手动获得一个类型的bean。
因此，实现一个获得bean实例的工具类，就很有必要。
以前，写了一个根据bean的名称和类型获取bean实例的2个工具方法，发现每次调用后，都需要强制转换成目标结果类型。
这样很不方便，突然想到可以使用Java泛型方法，实现1个新的工具方法，避免了类型转换。
import org.springframework.beans.BeansException; import org.springframework.beans.factory.BeanFactory; import org.springframework.beans.factory.BeanFactoryAware; import org.springframework.stereotype.Service; import org.springframework.web.context.ContextLoader; import org.springframework.web.context.WebApplicationContext; import cn.fansunion.webdemo.domain.User; /** * 获取Spring容器中Bean实例的工具类(Java泛型方法实现)。 * * @author leiwen@FansUnion.cn */ @Service public class SpringBeanUtils implements BeanFactoryAware { private static BeanFactory beanFactory; /** * 注入BeanFactory实例 */ @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException { SpringBeanUtils.beanFactory = beanFactory; } /** * 根据bean的名称获取相应类型的对象 * * @param beanName * bean的名称 * @return Object类型的对象 */ public static Object getBean(String beanName) { return beanFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daa53118fd42ce1f310f89aa70015727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e81912b187fb5bb145dc7cc904d44f6/" rel="bookmark">
			AH协议与ESP协议简析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.gxu.edu.cn/college/hxhgxy/sec/COURSE/ch12/2_1.htm
http://www.gxu.edu.cn/college/hxhgxy/sec/COURSE/ch12/2_2.htm
http://enterprise.huawei.com/ecommunity/bbs/10181731.html
AH AH可对整个数据包（IP 报头与数据包中的数据负载）提供身份验证、完整性与抗重播保护。但是它不提供保密性，即它不对数据进行加密。数据可以读取，但是禁止修改。AH 使用加密哈希算法签名数据包以求得完整性。
例如，使用计算机 A 的 Alice 将数据发送给使用计算机 B 的 Bob。IP 报头、AH 报头和数据的完整性都得到保护。这意味着 Bob 可以确定确实是 Alice 发送的数据并且数据未被修改。
完整性与身份验证是通过在 IP 报头与 IP 负载之间置入的 AH 报头提供的。 在 IP 报头中使用 IP 协议 ID 51 来标识 AH。AH 可以独立使用，也可以与ESP协议组合使用。
AH报头 AH 报头包含下列字段：
next hdr 下一个报头：使用 IP 协议 ID来标识 IP 负载,。从下图可知，表示被AH协议包含的那一个协议的类型。例如，TCP数据中，传输模式值 6 表示 TCP，隧道模式表示下一个报头为IP报头。
AH len 长度：表示 AH 报头的长度。
Reserved 保留字段
SPI 安全参数索引 ：与目标地址及安全协议（AH 或 ESP）组合使用，以确保通信的正确安全关联。接收方使用该值确定数据包是使用哪一安全关联标识的。
Sequence Number 序数 ：为该数据包提供抗重播保护。序数是 32 位、递增的数字（从 1 开始），它表示通过通信的安全关联所发送的数据包数。在快速模式安全关联的生存期内序列号不能重复。接收方将检查该字段，以确认使用该数字的安全关联数据包还没有被接收过。如果一个已经被接收，则数据包被拒绝。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e81912b187fb5bb145dc7cc904d44f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5267182413b5abf2a6f5e30ed9f5c6b/" rel="bookmark">
			Android短彩信源码解析-短信发送流程（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3、短信pdu的压缩与封装
相关文章:
-------------------------------------------------------------
1、短信发送上层逻辑
2、短信发送framework层逻辑
-------------------------------------------------------------
一直很逃避对这一部分做一个总结。因为这部分有些超出我能力范围之外，关于段彩信的3GPP协议，也看过一些，但总归觉得自己并非专业。对协议的学习仅仅停留在使用层面。刚开始了解这部分的时候，下过许多功夫，也走了不少弯路，为了截取pdu数据包，给10086/10010发了无数的短信（截取pdu数据log包需要发短信，给他们发短信测试不花钱，虽然通信费公司报销一部分，为公司省钱的娃），最后对pdu使用豁然开朗还是在看了网上一位大神写的帖子之后。（在文章之后会贴出来）
ps：强烈建议大家做几遍pdu的压缩与解析，对学习pdu的使用有很大帮助。大家可以参照文章最后贴出来的大神的解析过程，结合代码进行分析。
以下是从代码实现的角度来总结一下，为那些“挣扎”在pdu问题的娃抛个砖，引个路。如有错误，敬请批评指正，不胜感激。
ps：每条短信可容纳多少字符啊？
答：看代码。
SmsSingleReceipientSender.java
if ((MmsConfig.getEmailGateway() != null) &amp;&amp; (Mms.isEmailAddress(mDest) || MessageUtils.isAlias(mDest))) { String msgText; msgText = mDest + " " + mMessageText; mDest = MmsConfig.getEmailGateway(); messages = smsManager.divideMessage(msgText); } else { messages = smsManager.divideMessage(mMessageText); // remove spaces from destination number (e.g. "801 555 1212" -&gt; "8015551212") mDest = mDest.replaceAll(" ", ""); mDest = Conversation.verifySingleRecipient(mContext, mThreadId, mDest); } 最终调用：
SmsMessage.java
会执行：fragmentText（）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5267182413b5abf2a6f5e30ed9f5c6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2203ec8d4f9385f2328a7d57de80dea9/" rel="bookmark">
			[总结]FFMPEG视音频编解码零基础学习方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CSDN上的这一段日子，接触到了很多同行业的人，尤其是使用FFMPEG进行视音频编解码的人，有的已经是有多年经验的“大神”，有的是刚开始学习的初学者。在和大家探讨的过程中，我忽然发现了一个问题：在“大神”和初学者之间好像有一个不可逾越的鸿沟。“大神”们水平高超，探讨着深奥的问题；而初学者们还停留在入门阶段。究竟是什么原因造成的这种“两极分化”呢？最后，我发现了问题的关键：FFMPEG难度比较大，却没有一个循序渐进，由简单到复杂的教程。现在网上的有关FFMPEG的教程多半难度比较大，不太适合刚接触FFMPEG的人学习；而且很多的例子程序编译通不过，极大地打消了学习的积极性。我自己在刚开始学习FFMPEG的时候也遇到了很大的困难。为了帮助更多的人快速成为“大神”，我想总结一个学习FFMPEG的方法，方便大家循序渐进的学习FFMPEG。
PS：有不少人不清楚“FFmpeg”应该怎么读。它读作“ef ef em peg”
0. 背景知识
本章主要介绍一下FFMPEG都用在了哪里（在这里仅列几个我所知的，其实远比这个多）。说白了就是为了说明：FFMPEG是非常重要的。
使用FFMPEG作为内核视频播放器：
Mplayer，ffplay，射手播放器，暴风影音，KMPlayer，QQ影音...
使用FFMPEG作为内核的Directshow Filter：
ffdshow，lav filters...
使用FFMPEG作为内核的转码工具：
ffmpeg，格式工厂...
事实上，FFMPEG的视音频编解码功能确实太强大了，几乎囊括了现存所有的视音频编码标准，因此只要做视音频开发，几乎离不开它。
对于完全没有视音频技术背景的人来说，在学习FFmpeg之前最好先了解一下几种最基本的视音频数据的格式，可以参考下面的文章：
[总结]视音频编解码技术零基础学习方法
视音频数据处理入门：RGB、YUV像素数据处理
视音频数据处理入门：PCM音频采样数据处理
视音频数据处理入门：H.264视频码流解析
视音频数据处理入门：AAC音频码流解析
视音频数据处理入门：FLV封装格式解析
视音频数据处理入门：UDP-RTP协议解析
1. ffmpeg程序的使用（ffmpeg.exe，ffplay.exe，ffprobe.exe） 【视频资源】
本文中第1,2章是FFmpeg编程最基础的内容。这部分的内容我在给大二同学代课的时候录制成了视频，有时间的话可以看一下《基于 FFmpeg + SDL 的视频播放器的制作》课程的视频。
本章主要介绍一下ffmpeg工程包含的三个exe的使用方法。
ffmpeg的官方网站是：http://ffmpeg.org/
编译好的windows可用版本的下载地址（官网中可以连接到这个网站，和官方网站保持同步）： http://ffmpeg.zeranoe.com/builds/
该网站中的FFMPEG分为3个版本：Static，Shared，Dev。
前两个版本可以直接在命令行中使用，他们的区别在于：Static里面只有3个应用程序：ffmpeg.exe，ffplay.exe，ffprobe.exe，每个exe的体积都很大，相关的Dll已经被编译到exe里面去了。Shared里面除了3个应用程序：ffmpeg.exe，ffplay.exe，ffprobe.exe之外，还有一些Dll，比如说avcodec-54.dll之类的。Shared里面的exe体积很小，他们在运行的时候，到相应的Dll中调用功能。
Dev版本是用于开发的，里面包含了库文件xxx.lib以及头文件xxx.h，这个版本不包含exe文件。
打开系统命令行接面，切换到ffmpeg所在的目录，就可以使用这3个应用程序了。
1.1 ffmpeg.exe ffmpeg是用于转码的应用程序。
一个简单的转码命令可以这样写：
将input.avi转码成output.ts，并设置视频的码率为640kbps
ffmpeg -i input.avi -b:v 640k output.ts具体的使用方法可以参考： ffmpeg参数中文详细解释 详细的使用说明（英文）：http://ffmpeg.org/ffmpeg.html
1.2 ffplay.exe ffplay是用于播放的应用程序。
一个简单的播放命令可以这样写：
播放test.avi
ffplay test.avi具体的使用方法可以参考： ffplay的快捷键以及选项 详细的使用说明（英文）：http://ffmpeg.org/ffplay.html
1.3 ffprobe.exe ffprobe是用于查看文件格式的应用程序。
这个就不多介绍了。
详细的使用说明（英文）：http://ffmpeg.org/ffprobe.html
2. ffmpeg库的使用：视频播放器 本章开始介绍使用ffmpeg的库进行开发。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2203ec8d4f9385f2328a7d57de80dea9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/476/">«</a>
	<span class="pagination__item pagination__item--current">477/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/478/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>