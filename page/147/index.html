<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de79c8f5db9c67a32b8c81838041c7c5/" rel="bookmark">
			量子退火Python实战（1）：车辆路径问题（VRP : Vehicle Routing Problem）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、车辆路径问题（VRP）的QUBO建模1.目标变量2.目标函数定义3.约束条件定义 二、Python实现VRP的QUBO1.引入库2.设置参数和距离矩阵3.QUBO实现4.OpenJij求解QUBO目标变量5.输出求解结果路径 总结 前言 提示：本系列主要讲解如何用python实现常见组合优化问题中的QUBO公式：
量子退火作为解决组合优化问题的利器，车辆路径问题（VRP : Vehicle Routing Problem）是最经常被提起的现实应用。该问题的定义和特点如下：
车辆路径问题 (VRP) 是优化多辆送货车辆的送货顺序的组合优化问题，是旅行商问题 (TSP) 的推广。
这是一个可以应用于各种现实世界问题的问题，例如物流中的货物配送、工厂中的货物搬运，以及按需运输服务中的车辆分配计划。
VRP 是一个典型的组合优化问题，也是经典的NP-Hard问题，普通计算机很难在多项式时间内找到精确解。
量子退火有望利用量子隧穿效应实时解决 NP-Hard 组合优化问题。
一、车辆路径问题（VRP）的QUBO建模 本章节主要参考以下论文：
齋藤和広, 大山重樹, 梅木智光, 黒川茂莉, 小野智弘, "配送計画問題への量子アニーリング適用に関する初期評価" DEIM2020 D2-4(day1 p25) https://proceedings-of-deim.github.io/DEIM2020/papers/D2-4.pdf
作为一个基本的VRP，我们考虑了当多辆运送车辆访问所有目标基地时，搜索总旅行成本最小的路线的组合优化问题。
我们假设所有的送货车辆都从一个叫做 Depot 的基地出发，并且总是在最后返回到 Depot。移动成本使用基地之间的距离计算。距离矩阵的实现如下：
VRP的QUBO的定义：
我们把地点1作为Depot，然后假设有2辆车用来配送4个地点。2辆车的配送示意图如下： 其实大家可以可以把VRP问题理解为，有V辆车，V辆车各自负责不重叠的地点子集，所有车辆负责的地点子集的路径总和最小。
所以这里我们有三个参数需要设定：
V：车辆个数P：地点个数S：时间步（TSP建模中，我们不需要设置时间步，因为S=P+1） 小写字母代表变量：
1.目标变量 目标变量如下所示：
我们期待的QUBO矩阵如下图所示，
红色矩阵代表车辆1，从地点1==&gt;地点3==&gt;地点1；蓝色矩阵代表车辆2，从地点1==&gt;地点2==&gt;地点4==&gt;地点1。 下面写出目标函数和约束条件：
2.目标函数定义 目标函数
– 其实就是TSP的目标函数，又增加了一个车辆的维度 ∑ v = 1 V \sum_{v=1}^V ∑v=1V​。
3.约束条件定义 约束条件
– 条件a：第1个时间步的地点必须是Depot地点
– 条件b：第S个时间步的地点必须是Depot地点
– 条件c：除了Depot地点，剩余地点必须被访问过一次
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de79c8f5db9c67a32b8c81838041c7c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d208712eaab6ca73c350b605a3cce8c0/" rel="bookmark">
			NRZ、RZ信号的时频域区别及它们的谱效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、NRZ和RZ信号的时域比较二、NRZ和RZ信号的频域比较总结 一、NRZ和RZ信号的时域比较 NRZ信号的特征是信号脉冲之间无间隔，即信号脉冲宽度 τ \tau τ等于码元宽度 T B T_{B} TB​。NRZ信号可分为单极性NRZ和双极性NRZ信号。
RZ信号的特征是信号脉冲宽度 τ \tau τ等于码元宽度 T B T_{B} TB​，即一个信号在码元终止时刻前总要回归到零电平处。RZ信号也可分为单极性RZ和双极性RZ信号。
NRZ和占空比为50%的RZ信号时域波形如图1所示：
图1 占空比为50%的RZ和NRZ信号的时域波形 二、NRZ和RZ信号的频域比较 时域矩形脉冲，在频域中对应为Sa函数。
NRZ信号的频域功率谱为：
公式1： P s ( f ) = T B S a 2 ( π f T B ) P_{s}(f)=T_{B}Sa^{2}(\pi fT_{B}) Ps​(f)=TB​Sa2(πfTB​)
占空比为50%的RZ信号频域功率谱为：
公式2： P s ( f ) = T B 4 S a 2 ( π 2 f T B ) P_{s}(f)=\frac{T_{B}}{4}Sa^{2}(\frac{\pi}{2} fT_{B}) Ps​(f)=4TB​​Sa2(2π​fTB​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d208712eaab6ca73c350b605a3cce8c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a88676ca733359a5af8904be7d256f1a/" rel="bookmark">
			动态路由的原理与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.动态路由介绍
1.动态路由选择
指路由器使用路由选择协议来获悉网络并更新路由选择表。
2.路由协议分类
3.管理距离介绍
管理距离（AD）用于判断从邻接路由器收到的路由选择信息的可信度，它是 0-255的整数，0 表示可信度最大，255 意味着他不会有数据流使用相应的路由默认管路距离（Show ip protocols 查看动态路由的 AD 值）
4.度量值
度量是指路由协议来分配到达远程网络的路由开销的值。
IP 路由协议中使用的度量如下：
5.收敛
路由器收敛完成
当所有路由表包含相同网络信息
当路由器继续交换路由信息
当无信息时候收敛结束
网络在到达收敛钱无法完全正常工作
6.距离矢量-路由环路
什么是路由环路？路由环路是指数据包在一系列路由器之间不断传输却始终无法到达其预期目的网络的一种现象。
路由环路会造成的影响
环路内的路由器占用链路带宽来反复收发流量
路由器的 CPU 因不断循环数据包而不堪重负
影响到网络收敛
路由更新可能会失或无法得到及时处理
防环机制
定义最大度量以防止计数至无穷大
抑制计时器
水平分割
路由毒化或毒反转
触发更新
二.RIP 路由信息的更新
1.RIP 路由信息更新依托于时间周期的更新（更新周期为 30 秒）
当路由器 A 连接的网络拓扑发生改变后 A 路由器更新路由表，等到下一个发送周期通告更新后的路由表，路由器 B 收到此更新信息后更新自己的路由表
2.RIP 配置
配置命令
router rip
network 分类网络 (network10.0.0.0network 告诉路由协议 RIP 该通告哪些分类网络)
version 2
no auto-summary(关闭汇总)
查看命令 show ip route
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a88676ca733359a5af8904be7d256f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5db834acad22f0c14a5adb6194e8ba7f/" rel="bookmark">
			Vue.js报错问题解决：[Vue warn]: Error in v-on handler: “ReferenceError: XXX is not defined“.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
&lt;div id="box"&gt; &lt;button @click="counter"&gt;计算&lt;/button&gt; &lt;p&gt;按钮被单击{{count}}次&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue({ el: '#box', data: { count: 0 }, methods: { counter: function () { count++; } } }) &lt;/script&gt; 报错信息：
原因：count 忘加 this 了。。。
&lt;div id="box"&gt; &lt;button @click="counter"&gt;计算&lt;/button&gt; &lt;p&gt;按钮被单击{{count}}次&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue({ el: '#box', data: { count: 0 }, methods: { counter: function () { this.count++; } } }) &lt;/script&gt; 1、2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27bfa365c1d1fcebe3755323e52c13c8/" rel="bookmark">
			深入了解Linux内核: 全面指南（学习方法&#43;学习路线）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、内核组成 Linux内核由以下组成部分构成：
进程管理：负责管理进程的创建、销毁、调度和通信等。内存管理：负责管理系统中的物理内存和虚拟内存，包括内存映射和页面置换等。文件系统：提供了文件、目录和其他文件系统对象的抽象，包括文件操作、文件系统挂载和磁盘空间管理等。网络协议栈：负责处理网络通信，包括网络接口控制、IP协议和TCP/UDP协议等。设备驱动程序：负责与硬件设备进行交互，包括输入输出设备、网络接口、存储设备等。系统调用：为用户空间程序提供访问内核功能的接口。安全模块：提供安全机制，以保护系统资源和数据的完整性和机密性。中断处理：负责处理硬件中断和异常事件，以及调度处理器执行中断服务程序。 二、内核前景 Linux内核具有广泛的应用和发展前景。以下是几个方面：
云计算：Linux内核是云计算平台常用的操作系统，如AWS、Azure和Google Cloud等。物联网：由于其可裁剪性和跨处理器架构的特性，Linux内核被广泛用于物联网设备和嵌入式系统。大数据：Linux内核是大数据基础设施的重要组成部分，包括Hadoop、Spark和Kafka等。容器技术：Docker等容器技术的普及使得Linux内核得到更广泛的应用。AI和机器学习：Linux内核是人工智能和机器学习框架的主要操作系统之一，例如TensorFlow和PyTorch等。新兴技术：随着新兴技术的涌现，Linux内核将继续具有广泛的应用前景，如区块链、量子计算和边缘计算等。 总之，Linux内核的开源性质、安全性、高度可定制性和灵活性，以及社区支持和积极发展使其在各行各业具有广泛的应用前景。
三、如何学习内核及内核源码阅读 学习内核的目的，可以了解一下操作系统的基本知识和内核的作用。内核是操作系统的核心组件，负责管理计算机的资源，包括处理器、内存、输入输出设备等。学习内核可以帮助你深入理解操作系统的工作原理，提高系统优化能力和开发能力。
学习内核可以按照以下步骤进行：
学习操作系统原理：了解操作系统的基础概念和原理，包括进程管理、内存管理、文件系统、网络协议等。掌握C语言和汇编语言：学习C语言和汇编语言是理解内核代码的前提。需要掌握指针、内存分配、结构体等概念。阅读内核文档：内核源码包含大量文档，包括注释、文档、内核API文档等。需要先阅读这些文档来了解内核的结构和设计。阅读内核源码：从简单开始，逐步深入，对内核代码进行逐行分析和理解。可以根据感兴趣的模块或者问题来选择阅读。进行实践编程：尝试修改内核代码，并进行测试和调试，以加深对内核代码的理解。参与社区开发：参与Linux内核社区的讨论和开发，获取更多关于内核的知识和经验。 内核源码阅读可以按照以下步骤进行：
确定阅读目的：在开始阅读内核源码前，需要明确自己的学习目的和需求。是想深入了解某个特定模块的实现，还是想全面了解整个内核的结构和设计。安装内核源码：首先需要下载和安装内核源码。可以从官方网站下载最新版本的内核源码，也可以选择使用Linux发行版附带的内核源码。阅读文档：内核源码包含大量的注释、文档和API说明文档等。在开始阅读代码之前，需要阅读这些文档，以了解内核的结构和设计。选择阅读模块：可以根据自己的兴趣和需求选择具体的阅读模块。建议从简单的模块开始阅读，逐渐深入到复杂的部分。清晰思路：在阅读内核源码时，需要保持清晰的思路，按照内核的执行流程来理解代码。同时需要注意代码的调用关系和数据结构的定义和使用。实践编程：尝试修改和调试内核代码，以加深对内核的理解。但是需要注意，在修改内核代码之前需要了解内核的安全性和稳定性要求。 总之，学习内核需要不断地积累和实践，需要耐心和毅力。同时，需要不断地保持学习的热情和动力，才能在这个领域不断地深入和发展。
内核资料直通车：Linux内核源码技术学习路线+视频教程代码资料
学习直通车：Linux内核源码/内存调优/文件系统/进程管理/设备驱动/网络协议栈
四、内核学习路线 1、进程管理专题 1.1进程管理基础部分
1.2进程管理提高部分
1.3进程调度进阶部分
2、内存管理 2.1内存管理基础部分
2.2内存管理进阶部分
3、网络协议栈 3.1网络协议栈架构（一）
3.2网络协议栈架构（二）
4、设备驱动 4.1设备驱动基础架构
4.2Linux设备模型
4.3资源分配
4.4字符设备操作
4.5块设备操作
4.6NIC网络接口卡
5、文件系统及内核活动组件 5.1虚拟文件系统
5.2磁盘文件系统
5.3数据同步
5.4内核活动组件
5.5开源社区
五、适用人群 Linux内核适用人群包括：
操作系统开发者：Linux内核是一种操作系统内核，因此对于从事操作系统开发的人员来说，了解和掌握Linux内核非常重要。嵌入式系统开发者：Linux内核在嵌入式系统中得到广泛的应用。对于从事嵌入式系统开发的人员来说，熟悉和掌握Linux内核是必不可少的。网络开发者：Linux内核是网络协议栈的重要实现之一，因此对于从事网络开发的人员来说，学习Linux内核是提高网络技能的一个有效途径。驱动程序开发者：Linux内核驱动程序负责与硬件设备进行交互，因此对于从事驱动程序开发的人员来说，了解和掌握Linux内核驱动程序开发技术是必不可少的。系统管理员：Linux操作系统使用广泛，因此对于从事系统管理工作的人员来说，了解和掌握Linux内核是管理和维护Linux系统的基础。开源社区贡献者：Linux内核是开源社区的重要组成部分，参与Linux内核社区的讨论和开发可以为个人积累经验，同时也为开源社区做出贡献。 Linux内核是计算机领域的重要组成部分，对于从事相关工作的人员来说，了解和掌握Linux内核技术是非常有益的。
学习Linux内核可以从事以下岗位：
操作系统开发工程师：负责操作系统的开发和维护，包括调试内核代码、优化系统性能、支持新硬件等。嵌入式系统工程师：负责嵌入式系统的开发和维护，包括裁剪内核、移植驱动程序、支持新硬件等。驱动程序开发工程师：负责编写和维护设备驱动程序，与硬件进行交互，实现系统对硬件设备的控制和管理。网络开发工程师：负责网络协议栈的开发和维护，包括实现和优化TCP/IP协议、支持新类型的网络接口等。数据库开发工程师：负责数据库系统的开发和维护，包括实现存储引擎、查询优化、高可用性等功能。大数据开发工程师：负责大数据平台的开发和维护，包括Hadoop、Spark、Kafka等技术的应用和开发。安全工程师：负责系统安全方面的工作，包括漏洞修补、加密解密等方面的技术研究。 学习Linux内核技术可以从事计算机领域多个方向的工作，包括操作系统开发、嵌入式系统、驱动程序、网络协议栈、大数据、安全等多个领域。
学习内核可以帮助程序员更深入地了解操作系统的工作原理，从而更好地编写应用程序和调试问题。可以使程序员获得更丰富的开发经验和技能，例如熟悉系统级编程、驱动程序开发等。让程序员更好地理解代码质量的重要性，并掌握代码设计模式和最佳实践，更好地理解系统中的复杂问题，并提出更有效的解决方案。掌握内核开发技能可以提高程序员在职场上的竞争力，尤其是在操作系统、嵌入式系统等领域。
Linux内核学习地址：Linux内核源码/内存调优/文件系统/进程管理/设备驱动/网络协议栈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed845fb7ac768300f459118cf880151e/" rel="bookmark">
			数据归一化与标准化处理python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一： Zero-mean normalization（z-score标准化） （1） 将原始数据集归一化为均值为0、方差1的数据集
（2） 该种归一化方式要求原始数据的分布可以近似为高斯分布，否则归一化的效果会变得很糟糕。
应用场景：在分类、聚类算法中，需要使用距离来度量相似性的时候（比如K-means等聚类算法 中），或者使用PCA技术进行降维的时候，Z-score standardization表现更好。
1：调用preprocessing库的scale()函数
from sklearn import preprocessing import numpy as np X_train = np.array([[ 1., -1., 2.], [ 2., 0., 0.], [ 0., 1., -1.]]) X_scaled = preprocessing.scale(X_train) print(X_scaled) print(X_scaled.sum()) # 4.4408920985e-16 ~ 0 均值为0，方差为1 print(np.var(X_scaled)) # 1.0 [[ 0. -1.22474487 1.33630621] [ 1.22474487 0. -0.26726124] [-1.22474487 1.22474487 -1.06904497]] 4.440892098500626e-16 1.0 二：Min-max normalization（最大最小归一化） (1) 线性函数将原始数据线性化的方法转换到[0 1]的范围, 计算结果为归一化后的数据，X为原始数据
(2) 本归一化方法比较适用在数值比较集中的情况；
(3) 缺陷：如果max和min不稳定，很容易使得归一化结果不稳定，使得后续使用效果也不稳定。实际使用中可以用经验常量来替代max和min。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed845fb7ac768300f459118cf880151e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a28c7faa8d5d5e6d29883f27e7e5b65/" rel="bookmark">
			Python中的列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python中的列表是由一系列按特定顺序排列的元素组成的。它是Python中内置的可变序列。
形式上，列表的所有元素都放在[]中，两个相邻元素之间使用“,”隔开。在内容上，可以将整数，实数，字符串，列表，元组等任何类型的内容放入列表中。Python中的列表是非常灵活的。
一.列表的创建和删除 1.使用赋值运算符直接创建列表 如下代码：
listname=[element 1,element 2,element 3···element n] 其中listname表示列表的名称，其中的元素只要是Python中允许的数据类型即可。
注：在一个列表中，可以将不同数据类型的元素放入同一列表中，但通常情况下我们不这样做。这样可以提高程序的可读性。
2.创建空列表
emptylist=[] 3.创建数值列表
在Python中，数值列表很常见。可以使用list()函数直接将range()函数循环出来的结果转换为列表。
list()函数的基本语法如下：
list(data) 其中，data表示可以转换为列表的数据，其类型可以是range函数、字符串、元组或其他可迭代类型的数据。
例如，创建一个10~20（不包含20）的所有偶数的列表，可以使用以下代码：
list(range(10,20,2)) 运行上述代码，得出以下列表：
[10,12,14,16,18] 4.删除列表
对于已经创建的列表，可以使用del语句将其删除。语法如下：
del listname 二、访问列表元素
在Python中，输出列表的元素可以直接用print()函数。
print(name) 当然，也可以通过列表的索引输出指定元素。
三、遍历列表
1.直接使用for循环实现，只能输出元素的值：
for item in loistname: #输出item 其中，item用于保存获取到的元素值，要输出元素内容时，直接输出该变量即可。
2.使用for循环和ennumerate()函数来实现
此方法可以同时输出索引值和元素内的值。
for index,item in enumerate(listname): #输出index和item 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ddc726d450b226ddd426c76766fc9d4/" rel="bookmark">
			解决vue3&#43;vite跨域失败问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3+vite用proxy跨域出现的问题 一、改错前的代码 vite.config.js中的代码 import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' // https://vitejs.dev/config/ export default defineConfig({ plugins: [vue()], server: { proxy: { '/api': { target: "http://gmall-h5-api.atguigu.cn", //跨域地址 changeOrigin: true, //支持跨域 rewrite: (path) =&gt; path.replace(/^\/api/, '') //重写路径 } } } }) 发送请求的文件中的跨域请求代码 import axios from 'axios' axios.get('/api/product/getBaseCategoryList').then((res) =&gt; { console.log('success:' + res.data); }).catch((err) =&gt; { console.log('failed:' + err.data); }); 出现这些错误是因为 rewrite，写这行代码时要看接口有没有带上/api，如果接口本身就有/api则不需要重写路径，将重写路径的这行代码删掉就好了
二、改正后vite.config.js代码 import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' // https://vitejs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ddc726d450b226ddd426c76766fc9d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2392fbe693be6e396cec1eb58b8bf09e/" rel="bookmark">
			微信、QQOAuth 2.0前后端登录代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于不同的第三方平台的授权方式不同，包括授权的端点、授权的参数等等，因此，下面我们提供了分别用于QQ、微信、钉钉OAuth 2.0的前端和后端代码。
首先是QQ OAuth 2.0的前端代码，它使用QQ提供的connect.qq.com授权端点进行授权，并处理授权的回调：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;QQ OAuth 2.0&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;QQ OAuth 2.0&lt;/h1&gt; &lt;script src="https://open.mobile.qq.com/sdk/qqapi.js?_bid=152"&gt;&lt;/script&gt; &lt;script&gt; var appId = 'YOUR_APP_ID_HERE', redirectUri = encodeURIComponent('http://localhost:8080/oauth/callback/qq'), scope = 'get_user_info'; qq.login(function(res) { if (res.errMsg == 'login:ok') { var access_token = res.access_token, expires_in = res.expires_in, openid = res.openid; // Send OAuth login data to server-side var xhr = new XMLHttpRequest(); xhr.open('POST', 'http://localhost:8080/oauth2/callback', true); xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); xhr.onreadystatechange = function() { if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2392fbe693be6e396cec1eb58b8bf09e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc47bb0c9fd766dc0e1ddd445610e9f7/" rel="bookmark">
			什么是 BitB 网络钓鱼攻击？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 BitB 网络钓鱼攻击？ 前言什么是 BitB 网络钓鱼攻击？工作原理如何检测BitB骗局1、使用密码管理器2、拖动登录窗口3、最小化浏览器主窗口4. 安装无脚本 不要上钩 浏览器中的浏览器 （BitB） 攻击涉及弹出的单点登录 （SSO） 身份验证窗口的副本。可能很难发现，但您可以采取措施防止 BitB 诈骗。原文链接 前言 任何值得一提的互联网用户都可以发现经典的网络钓鱼计划——虚假 URL、可疑链接或不寻常的电子邮件请求都是可疑问题。但是最近出现了一种新的，更微妙的黑客技术，甚至专家也承认很难发现。输入 BitB 网络钓鱼诈骗。 什么是 BitB 网络钓鱼攻击？ 浏览器中的浏览器 （BitB） 攻击涉及弹出的单点登录 （SSO） 身份验证窗口的副本。当您尝试在新网站上创建帐户时，将打开虚假 SSO 窗口，提示您使用 Facebook、Gmail 或其他采用 OAuth 方法的网站登录。与传统的网络钓鱼攻击不同，BitB 窗口完美地复制了实际 URL 的外观——您不会在地址栏中看到 G00gle 或 Hotmial。那是因为它不是一个真正的窗口，而是一个使用HTML和CSS制作的插图。很聪明，不是吗？即使是经验丰富的 IT 专业人员也足以愚弄。输入用户名和密码后，黑客会窃取您的登录凭据以访问您的帐户。由于许多人对多个站点使用相同的凭据，因此黑客可以扫描您的所有帐户并查找信用卡号或其他敏感数据等内容。这就是为什么 90% 的成功数据泄露都是从网络钓鱼开始的。这几乎太容易了。 工作原理 首先，黑客创建了一个包含有趣内容的独特网站——这可能是一个工作列表网站或流媒体服务。然后，当您尝试在站点上创建帐户时，他们会创建一个虚假的 SSO 身份验证窗口。为了制作虚假弹出窗口，黑客使用模板复制Facebook，Apple和Google等网站的外观。从本质上讲，他们在网页上绘制了一个假窗口。网络钓鱼框架以及JavaScript和JQuery的一些帮助使这种黑帽技术成为公园里的散步。 如何检测BitB骗局 您不必成为最新网络钓鱼计划的受害者。虽然它很微妙，但有一些方法可以阻止 BitB 攻击的企图。 1、使用密码管理器 密码管理器将在真正的SSO身份验证窗口中自动填写您的登录凭据，但它不会被愚弄，认为BitB弹出窗口是合法窗口。用户名和密码框将保持为空。 2、拖动登录窗口 如果您无法将登录窗口拖离主浏览器窗口或地址栏，则表明您正在应对 BitB 网络钓鱼攻击。BitB 窗口将经过地址栏后面，而不是地址栏顶部。 3、最小化浏览器主窗口 最小化主窗口时登录窗口是否也会消失？如果是这样，这是另一个线索，它不是一个合法的SSO身份验证窗口，而是一个模拟。 4. 安装无脚本 由于此软件扩展禁用页面上的JavaScript元素，因此可以防止BitB窗口弹出。作为奖励，NoScript还禁用了Flash，媒体编解码器，Web字体和WebGL。所有可执行的 Web 内容都将保留在屏幕之外。 不要上钩 浏览器中的浏览器网络钓鱼是一种聪明的新方案，但与所有黑客尝试一样，有一些解决方法。发现BitB攻击的最简单方法是拖动弹出窗口。如果它留在页面上，那就是假的。
在您的所有帐户上启用双因素身份验证也是一个好主意。这样，即使黑客确实窃取了您的凭据，他们也无法登录。黑客越来越狡猾，但只要有一点常识和良好的网络安全实践，您就可以在他们自己的游戏中击败他们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c045a20e9c7929cd3c961376d0a37516/" rel="bookmark">
			Qt 自定义侧边菜单栏切换内容页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 自定义侧边菜单栏切换内容页面 一、环境二、效果三、实现方案1.方案一思路：源码： 2.方案二思路：源码： 做一个类似微信侧边栏切换不同页面的功能。支持初始状态 一、环境 系统： Windows 10 专业版Qt：Qt 5.14.1编译套件：MinGW-32 二、效果 菜单切换示例
代码免费随便用的。
三、实现方案 对于菜单点击后的互斥效果是通过样式表来设置的，通过样式表的不同状态来设置对应的显示效果，下面就给出具体的小小案例，下面给出了 homeBtn的样式和 editBtn 的样式，正常情况下是一张图片，在鼠标移入后、或者选中checked的时候是另外一张图片。
这里我使用的是svg格式图片，到时候也很方便扩展这个图片样式，svg是文本格式的描述图像的规范 QPushButton { border: 1px solid transparent; min-height:24px; max-height:24px; min-width:24px; max-width:24px; } /*HomeBtn*/ QPushButton#HomeBtn {	image: url(:/images/home.svg); } QPushButton#HomeBtn:checked, QPushButton#HomeBtn:hover {	image: url(:/images/home-filling.svg); } /*EditBtn*/ QPushButton#EditBtn {	image: url(:/images/edit.svg); } QPushButton#EditBtn:checked, QPushButton#EditBtn:hover {	image: url(:/images/edit-filling.svg); } 1.方案一 思路： 在菜单栏的父控件里去动态的去查找是哪一个按钮被触发点击状态，通过设置样式表的伪态来制作对应的响应效果，同时通过按钮和对应窗口的关系进行绑定即可 源码： 关键代码： //绑定 QList&lt;QPushButton *&gt; childButtons = ui-&gt;MenuWidget-&gt;findChildren&lt;QPushButton *&gt;(); foreach (auto item, childButtons) { //按钮必须设置可选，我这里直接代码设置的，ui里面也可以设置 item-&gt;setCheckable(true); connect(item, &amp;QPushButton::clicked, [=]() { QWidget * tempWidget = ui-&gt;stackedWidget-&gt;findChild&lt;QWidget *&gt;(QString(item-&gt;objectName().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c045a20e9c7929cd3c961376d0a37516/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101c670862682b31acd981674b3ff07b/" rel="bookmark">
			【k8s】 etcd cluster is not healthy 将一个master控制节点踢出后重新加入集群发现报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kubernets将一个master控制节点踢出后重新加入集群发现报错 failed to dial endpoint https://10.0.1.81:2379 with maintenance client: context deadline exceeded etcd cluster is not healthy 报错结果显示etcd集群运行不正常，其实在kubeadm join加入集群时打开 -v=5 选项，提高日志等级就可以发现，提示刚刚踢出的master节点etcd无法连接。原因是将master节点踢出后，etcd集群并未将其踢出etcd集群，需要我们手动进行移除。
下载etcdctl命令行工具
export RELEASE=$(curl -s https://api.github.com/repos/etcd-io/etcd/releases/latest|grep tag_name | cut -d '"' -f 4) wget https://github.com/etcd-io/etcd/releases/download/${RELEASE}/etcd-${RELEASE}-linux-amd64.tar.gz tar xvf etcd-${RELEASE}-linux-amd64.tar.gz cd etcd-${RELEASE}-linux-amd64 sudo mv etcd etcdctl etcdutl /usr/local/bin 随便登陆一台现有的master机器并查看现有的etcd集群列表，果然其中还有那台已经退出集群的服务器10.0.1.81:2379
etcdctl --endpoints 127.0.0.1:2379 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key member list 12637f5ec2bd02b8, started, blog-k8s-n0, https://10.0.1.81:2380, https://10.0.1.81:2379, false 17d58f8d29164d23, started, k8s-master1, https://10.0.1.32:2380, https://10.0.1.32:2379, false 19441808830db070, started, k8s-master2, https://10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/101c670862682b31acd981674b3ff07b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b75f5a4efdf376cf5447f8ad659d034c/" rel="bookmark">
			Android之区分U盘及SD卡等外置存储设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区分外置U盘及SD卡等存储设备 最近有个项目有内置SD卡同时又保留了USB及sd卡口，由于要计算外置存储设备的空间，尝试了几个方法均不理想最终使用如下方法 可以成功的区分外置设备是U盘还是SD卡。
主要通过如下方法区分U盘及SD卡
@SuppressLint("PrivateApi") private String getStoragePath(Context context, boolean isUsb){ String path=""; StorageManager mStorageManager = (StorageManager) context.getSystemService(Context.STORAGE_SERVICE); Class&lt;?&gt; volumeInfoClazz; Class&lt;?&gt; diskInfoClaszz; try { volumeInfoClazz = Class.forName("android.os.storage.VolumeInfo"); diskInfoClaszz = Class.forName("android.os.storage.DiskInfo"); Method StorageManager_getVolumes=Class.forName("android.os.storage.StorageManager").getMethod("getVolumes"); Method VolumeInfo_GetDisk = volumeInfoClazz.getMethod("getDisk"); Method VolumeInfo_GetPath = volumeInfoClazz.getMethod("getPath"); Method DiskInfo_IsUsb = diskInfoClaszz.getMethod("isUsb"); Method DiskInfo_IsSd = diskInfoClaszz.getMethod("isSd"); List&lt;Object&gt; List_VolumeInfo = (List&lt;Object&gt;) StorageManager_getVolumes.invoke(mStorageManager); assert List_VolumeInfo != null; for(int i=0; i&lt;List_VolumeInfo.size(); i++){ Object volumeInfo = List_VolumeInfo.get(i); Object diskInfo = VolumeInfo_GetDisk.invoke(volumeInfo); if(diskInfo==null)continue; boolean sd= (boolean) DiskInfo_IsSd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b75f5a4efdf376cf5447f8ad659d034c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0127daeaa5d85ebf4e20ce6a034cf40a/" rel="bookmark">
			rollup-plugin-copy 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 rollup-plugin-copy 是一个用于 Rollup.js 打包构建工具的插件，用于将指定的文件或目录从一个位置复制到另一个位置。
以下是 rollup-plugin-copy 的一些常用配置选项：
targets：将文件复制到的目标位置。可以是一个字符串或字符串数组，也可以是一个包含 src 和 dest 属性的对象数组。hook：生命周期钩子，例如 buildStart、buildEnd、generateBundle、writeBundle 等。flatten：是否将复制的文件都放置在目标目录的根目录下，而不是在整个目录结构中保留原始文件的路径结构。verbose：是否输出详细的日志信息。copyOnce：是否只复制尚未复制过的文件。 下面是一个简单的 rollup-plugin-copy 配置例子：
import copy from 'rollup-plugin-copy'; export default { // ... plugins: [ copy({ targets: [ { src: 'public/index.html', dest: 'dist' }, { src: 'public/assets/**/*', dest: 'dist/assets' } ], verbose: true }) ] } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/523c24c7432663e293db964f959763b5/" rel="bookmark">
			Win11的两个实用技巧系列之磁盘分区后再恢复的方法、调高进程的优先级方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win11磁盘分区后怎么恢复到分区前?Win11磁盘分区后在恢复的方法 很多人不知道win11磁盘分区怎么恢复回去?今日为你们带来的文章是win11磁盘分区的恢复方法，还有不清楚小伙伴和小编一起去学习一下吧
有不少小伙伴在使用电脑的时候经常会根据自身需求对其进行磁盘的分区，那么当分区之后出现不满意的情况时我们又应该如何恢复回去呢？其实我们只要进行反向操作就可以了，下面就和小编一起来看看具体的操作方法吧。
Win11磁盘分区后的恢复方法 一、合并了分区
1、在桌面上找到“此电脑”，右键它，点击“管理”。
2、接着在左边栏找到并打开“磁盘管理”。
3、打开后，我们找到被合并的分区，右键它。
4、在右键菜单里选择“压缩卷”。
5、然后选择被合并的分区空间量，再点击“压缩”。
6、压缩完成后，右键新增的可用空间，选择“新建简单卷”。
7、然后选择分区大小，并持续点击“下一页”。（其余设置保持默认）
8、最后点击“完成”就可以恢复之前的分区了。
二、新增了分区
1、如果是新增了不需要的分区，那么只要右键该分区。
2、接着点击“删除卷”，就能将它删除为可用空间了。
3、删除后，右键旁边的磁盘，点击“扩展卷”。
4、最后选择空间量并连续点击“下一页”就可以合并回分区了。
以上就是小编为你带来的关于“Win11磁盘分区后怎么恢复到分区前？Win11磁盘分区后的恢复方法”的全部内容了，希望可以解决你的问题。
Win11如何调高进程的优先级?Win11调高进程的优先级方法 很多的应用程序就需要设置一个优先级，那么使用Win11系统的电脑要如何去进行这个设置呢？本文就为大家带来了详细的设置方法，需要的朋友一起看看吧
相信很多使用过电脑的小伙伴都知道，系统资源是有限的，因此我们在打开很多的应用程序就需要设置一个优先级，那么使用Win11系统的电脑要如何去进行这个设置呢？其实操作起来还是很简单的，下面就和小编一起来看看方法吧。
Win11调高进程的优先级方法 第一步，咱们在Windows11这里找到程序树列表右击快捷方式。
第二步，咱们即可在这里找到设置优先级属性。
第三步，此时即可在这里看选择为高和高于正常这两个优先级了。
以上就是小编为你带来的关于“Win11如何调高进程的优先级？Win11调高进程的优先级方法”的全部内容了，希望可以解决你的问题。
Win10存储感知功能有什么用 Win10如何开启与关闭存储感知功能 存储感知功能实际上就是Win10系统中的一个特色功能，自带有AI的存储感知功能发挥其清理功能，TA可以在操作系统需要的时候清理不需要的文件，那么我们要如何开启存储感知功能
Win10存储感知功能有什么用？
存储感知功能是一个有关清理文件的功能，Win10存储感知功能能够让WIN10操作系统在需要时删除不需要的文件（比如临时文件与回收站中的文件）自动释放空间。
Win10如何开启存储感知功能？
1、首先开始&gt;设置 或者 我们按“Win+i”组合键打开设置界面，在设置窗口中点击“系统”选项，如下图所示。
2、再点击左侧栏中的“存储”，在右侧栏中能够看到“存储感知”选项，我们将其开启即可。
此外，我们还可以点击“更改释放空间的方式”或更改详细设置字样，来设置具体的删除方案，在这里也可以点击“立即释放空间”删除一些无用文件。
因为逻辑关系的原因存储感知功能并不是想象中的高级AI，所以在该功能升级之前其作用也不过是给用户尝尝鲜。
点击拿去
50G+学习视频教程
100+Python初阶、中阶、高阶电子书籍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/478485eaf560a003099faaeac5430116/" rel="bookmark">
			vue3 &#43; Typescript import “.vue“ 文件时报红问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为以前一直是用的js来写脚本，突然换成ts之后有很多问题，今天在做路由设置导入组件的时候一直报红，看了很多相关文档都没有找到问题，最后发现其实是因为ts导出方式和js不太一样。
在router/index.ts中设置路由:
import index from "@/layout/index.vue" 查询文档后发现ts中没有自动识别vue文件的依赖，需要在env.d.ts中添加module：
declare module '*.vue' { import { DefineComponent } from "vue"; // 有一些文档里import的是ComponentOptions,但是版本貌似比较低了 const component: DefineComponent&lt;{}, {}, any&gt;; export default component; } 在做完这一步之后依旧在报红，也运行不起来，各方查阅文档后依旧解决不了，干脆摆烂了！直接先写组件！
在写完index.vue之后，想回去在解决这个问题，结果发现不报红了，经过一番折腾之后发现组件中的ts脚本是不需要默认导出的，在script标签中加上setup字段即可，这样也解决了导入vue文件的问题。以我猜测估计是因为组件中没有有效导出所以才导致路由导入vue文件时会报红。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c83da304ee7904572ee0ac9447791c8/" rel="bookmark">
			Python保存文件时中文乱码/指定encoding仍然乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python保存JSON文件时中文乱码/指定encoding仍然乱码 import json def save(info): with open('info.json', 'w', encoding='utf-8') as f: json.dump(info, f, ensure_ascii=False, indent=1) 注意encoding='utf-8'和ensure_ascii=False即可。
encoding='utf-8'声明按照utf-8编码的方式来读取，ensure_ascii=False来确保 JSON 序列化时不将 Unicode 编码为 ASCII
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb09a4740812657ae74631f578d642d/" rel="bookmark">
			Android开发 登录注册设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Android Studio 简单的实现登录注册
目录
一、登录界面
activity_login.xml 布局代码：
login.java 代码： 二、注册界面 activity_register.xml布局代码：
register.java 代码：
三、修改密码（忘记密码 ？)
activity_update_password.xml布局代码：
UpdatePassword.java 代码：
四、SQLite 与 SharedPreferences 操作
QQHelper.java 创建SQLite数据库：
QQperate.java 对SQLite数据库进行增、改、查操作：
SaveQQ.java保存QQ账号与密码：
五、登录成功界面
六、 styles.xml 和AndroidManifest.xml
styles.xml 代码：
AndroidManifest.xml 代码：
一、登录界面 activity_login.xml 布局代码： &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;RelativeLayout android:background="@drawable/bgqq" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ImageView android:id="@+id/imgfile" android:layout_width="100dp" android:layout_height="100dp" android:layout_centerHorizontal="true" android:layout_marginTop="150dp" android:padding="2dp" android:background="#ffffff" app:srcCompat="@drawable/head" /&gt; &lt;TextView android:id="@+id/qq_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerHorizontal="true" android:layout_below="@+id/imgfile" android:layout_marginTop="5dp" android:textSize="24sp" android:text="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb09a4740812657ae74631f578d642d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/200908d1926d5d5496a3931f4578e47a/" rel="bookmark">
			头歌---数据挖掘算法原理与实践：数据预处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：标准化 为什么要进行标准化
对于大多数数据挖掘算法来说，数据集的标准化是基本要求。这是因为，如果特征不服从或者近似服从标准正态分布（即，零均值、单位标准差的正态分布）的话，算法的表现会大打折扣。实际上，我们经常忽略数据的分布形状，而仅仅做零均值、单位标准差的处理。在一个机器学习算法的目标函数里的很多元素所有特征都近似零均值，方差具有相同的阶。如果某个特征的方差的数量级大于其它的特征，那么，这个特征可能在目标函数中占主导地位，这使得模型不能从其它特征有效地学习。
代码实现如下：
# -*- coding: utf-8 -*- from sklearn.preprocessing import scale,MaxAbsScaler,MinMaxScaler #实现数据预处理方法 def Preprocessing(x,y): ''' x(ndarray):处理 数据 y(str):y等于'z_score'使用z_score方法 y等于'minmax'使用MinMaxScaler方法 y等于'maxabs'使用MaxAbsScaler方法 ''' #********* Begin *********# if y=='z_score': x = scale(x) return x elif y=='minmax': x = MinMaxScaler().fit_transform(x) return x elif y=='maxabs': x = MaxAbsScaler().fit_transform(x) return x #********* End *********# 第2关：非线性转换 为什么要非线性转换
在上一关中已经提到，对于大多数数据挖掘算法来说，如果特征不服从或者近似服从标准正态分布（即，零均值、单位标准差的正态分布）的话，算法的表现会大打折扣。非线性转换就是将我们的特征映射到均匀分布或者高斯分布(即正态分布)。
代码实现如下：
# -*- coding: utf-8 -*- from sklearn.preprocessing import QuantileTransformer #实现非线性转换方法 def non_linear_transformation(x,y): ''' x(ndarray):待处理数据 y(int):y等于0映射到均匀分布 y等于1映射到高斯分布 ''' #********* Begin *********# if y==0: x = QuantileTransformer(random_state=666).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/200908d1926d5d5496a3931f4578e47a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10a171edfc088ddc30d7beed77e8961c/" rel="bookmark">
			前端面试真题宝典（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Promise then 第二个参数和catch的区别是什么? 如果是 Promise 内部报错，reject 抛出错误后，由于就近原则，then 的第二个参数会先捕获到异常，catch 则无法获取异常。但如果是 then 的第一个参数抛出错误，then 的第二个参数会捕获不到，只有 catch 能捕获。都用catch就可以了
Promise finally 怎么实现的 调用finally传入的callback函数，callback不论返回什么，都转换为Promise对象，并且与当前调用对象的状态值是一样的。 finally(callback){ return this.then(value=&gt;{ return MyPromise.resolve(callback()).then(()=&gt;value) },reason=&gt;{ return MyPromise.resolve(callback()).then(()=&gt;{throw reason}) }) } webpack5 模块联邦 使用场景：试想一下，你有一个组件包通过 npm 发布后，你的10个业务项目引用这个组件包。当这个组件包更新了版本，你的10个项目想要使用最新功能就必须一一升级版本、编译打包、部署，这很繁琐。但是模块联邦让组件包利用CDN的方式共享给其他项目，这样一来，当你到组件包更新了，你的10个项目中的组件也自然更新了。
他和利用 npm 发包来实现的方案的区别在于，npm 发布的组件库从 1.0.1 升级到 1.0.2 的时候，必须要把业务线项目重新构建，打包，发布才能使用到最新的特性，而模块联邦可以实现实时动态更新而无需打包业务线项目。
模块联邦是webpack的内置模块，使用起来也是相当的简单，做好相关配置就可以了，首先要保障项目webpack是5.0及以上。然后在对应的项目的webpack.config.js进行配置，ModuleFederationPlugin有几个重要的参数：
1、name: 当前应用的名称，需要唯一性；
2、exposes: 需要导出的模块，用于提供给外部其他项目进行使用；
3、remotes: 需要依赖的远程模块，用于引入外部其他模块；
4、filename: 入口文件名称，用于对外提供模块时候的入口文件名；
5、shared: 配置共享的组件，一般是对第三方库做共享使用；
// webpack 配置 new ModuleFederationPlugin({ name: "main_app", filename: "remoteEntry.js", exposes: { "./search": "./src/search/search.vue" }, remotes: { lib_remote: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10a171edfc088ddc30d7beed77e8961c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12db42503528859e9ed145768da66d17/" rel="bookmark">
			网络安全等级保护2.0标准体系以及主要标准
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		等级保护2.0标准主要特点
首先，我们来看看网络安全等级保护2.0的主要标准，如下图：
说起网络安全等级保护2.0标准的特点，马力副研究员表示，主要体现在以下三个方面：
一是，对象范围扩大。新标准将云计算、移动互联、物联网、工业控制系统等列入标准范围，构成了“安全通用要求+新型应用安全扩展要求”的要求内容。
二是，分类结构统一。新标准“基本要求、设计要求和测评要求”分类框架统一，形成了“安全通信网络”、“安全区域边界”、“安全计算环境”和“安全管理中心”支持下的三重防护体系架构。 三是，强化可信计算。新标准强化了可信计算技术使用的要求，把可信验证列入各个级别并逐级提出各个环节的主要可信验证要求。
“标准从一级到四级全部提出了可信验证控件。但在标准的试用期间，对于可信验证的落地还存在诸多挑战。所以，我们希望与这次参会的所有硬件厂商、软件厂商、安全服务商共同努力，把可信验证、可信计算这方面的产品产业化，来更好地支撑新标准。” 马力副研究员说到。
等级保护2.0标准的十大变化
随后，他为大家解读了等级保护2.0标准的十大变化，具体如下：
1、名称的变化
从原来的《信息系统安全等级保护基本要求》改为《信息安全等级保护基本要求》，再改为《网安全等级保护基本要求》。
2、对象的变化
原来的对象是信息系统，现在等级保护的对象是网络和信息系统。安全等级保护的对象包括网络基础设施(广电网、电信网、专用通信网络等)、云计算平台/系统、大数据平台/系统、物联网、工业控制系统、采用移动互联技术的系统等。
3、安全要求的变化
由“安全要求”改为“安全通用要求和安全扩展要求”。
安全通用要求是不管等级保护对象形态如何必须满足的要求，针对云计算、移动互联、物联网和工业控制系统提出了特殊要求，成为安全扩展要求。
4、章节结构的变化
第三级安全要求的目录与之前版本明显不同，以前包含技术要求、管理要求。现在的目录包含：安全通用要求、云计算安全扩展要求、移动互联安全扩展要求、物联网安全扩展要求、工业控制系统安全扩展要求。
对此，马力副研究员指出：“别小看只是目录架构的变化，这导致整个新标准的使用不同。1.0标准规定技术要求和管理要求全部实现。现在需要根据场景选择性的使用通用要求+某一个扩展要求。”
5、分类结构的变化
在技术部分，由物理安全、网络安全、主机安全、应用安全、数据安全，变更为安全物理环境、安全通信网络、安全区域边界、安全计算环境、安全管理中心;在管理部分，结构上没有太大的变化，从安全管理制度、安全管理机构、人员安全管理、系统建设管理、系统运维管理，调整为安全管理制度、安全管理机构、安全管理人员、安全建设管理、安全运维管理。
6、增加了云计算安全扩展要求
云计算安全扩展要求章节针对云计算的特点提出特殊保护要求。对云计算环境主要增加的内容包括：基础设施的位置、虚拟化安全保护、镜像和快照保护、云服务商选择和云计算环境管理等方面。
7、增加了移动互联网安全扩展要求
移动互联安全扩展要求章节针对移动互联的特点提出特殊保护要求。对移动互联环境主要增加的内容包括：无线接入点的物理位置、移动终端管控、移动应用管控、移动应用软件采购和移动应用软件开发等方面。
8、增加了物联网安全扩展要求
物联网安全扩展要求章节针对物联网的特点提出特殊保护要求。对物联网环境主要增加的内容包括：感知节点的物理防护、感知节点设备安全、感知网关节点设备安全、感知节点的管理和数据融合处理等方面。
9、增加了工业控制系统安全扩展要求
工业控制系统安全扩展要求章节针对工业控制系统的特点提出特殊保护需求。对工业控制系统主要增加的内容包括：室外控制设备防护、工业控制系统网络架构安全、拨号使用控制、无线使用控制和控制设备安全等方面。
10、增加了应用场景的说明
增加附录C描述等级保护安全框架和关键技术，增加附录D描述云计算应用场景，附录E描述移动互联应用场景，附录F描述物联网应用场景，附录G描述工业控制系统应用场景，附录H描述大数据应用场景(安全扩展要求)。
网络安全学习资源分享: 零基础入门
对于从来没有接触过网络安全的同学，我们帮你准备了详细的学习成长路线图。可以说是最科学最系统的学习路线，大家跟着这个大的方向学习准没问题。
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享 (qq.com)
同时每个成长路线对应的板块都有配套的视频提供：
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享 (qq.com)
因篇幅有限，仅展示部分资料，需要点击上方链接即可获取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73bfb0479d914cf8dc468b3e60edeee0/" rel="bookmark">
			罗技设备 - 使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		罗技设备 - 使用技巧 前言罗技官网罗技软件/驱动程序使用技巧PrintScreen按键多通道USB多通道鼠标Options plus驱动程序显示已连接设备全局设置应用程序自定义备份设置更新固件添加设备删除设备/取消配对 Logi unifing和Logi bolt软件配对新设备取消配对 前言 罗技（Logitech）的产品涵盖了键盘、鼠标、耳机、音箱、摄像头、游戏设备等多种类别，被广泛应用于个人和商业领域。
常见的罗技设备有鼠标和键盘，罗技的无线鼠标采用先进的无线技术，具有高精度、舒适握持和长电池续航等特点，适用于各种办公和娱乐场景。罗技的键盘产品覆盖了有线、无线、机械、静音等多种类型，支持多媒体控制和自定义快捷键，为用户带来更高效的输入体验。
罗技的USB无线协议有2种，分别为优联（Unifying）标准和Bolt标准，这2种标准都支持6通道，可以同时连接6个设备，有效范围是10米左右。Bolt出现的比较晚，可以看作是优联的升级版，增强了稳定性和安全性，但只有部分设备型号才支持Bolt。
值得注意的是，优联是由罗技开发的专有 2.4 GHz 射频无线协议。罗技Bolt 无线产品无法与优联USB接收器配对，反之亦然。 优联无线产品无法与罗技Bolt USB接收器配对。
本文将介绍罗技的驱动软件以及罗技设备的一些使用技巧。
罗技官网 Logi官网：链接
Logi Support：链接
Logi Software Download Support：链接
Logi Options：链接1，链接2
Logi Options Plus：链接1，链接2
Logi Unifying Software：链接
Logi Bolt：链接
罗技软件/驱动程序 罗技软件，也可称为罗技驱动程序，可以在罗技官网进行下载，网址请见上文。
Logi options：罗技驱动程序，为罗技设备提供自定义设置
Logi options plus：Logi options的plus版，目前部分旧设备不支持
Logi unifing：罗技开发的连接标准，即优联标准，为优联USB配对优联设备
Logi bolt：国际化的连接标准，与罗技的优联标准类似，为Bolt USB和Bolt设备进行配对
推荐用户安装罗技驱动软件Logi options plus，因为Options正在被Options plus所替代，Options plus支持的设备也将越来越多。Options和Options plus中集成了Logi unifing和Logi bolt的功能，因此安装Options或Options plus则无需安装Logi unifing和Logi bolt。
注意：
Options或Options plus的服务需要开机自启，否则自定义设置不会生效。另外，每次电脑重启后，即便服务开机自启，初次连接部分设备后，仍需要等待一段时间，自定义设置才会生效，例如K380。
Options和Options plus只能为优联或Bolt USB添加设备，无法对USB的已配对设备进行删除，因此要管理优联设备需要安装Logi unifing，要管理Bolt设备需要安装Logi bolt。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73bfb0479d914cf8dc468b3e60edeee0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc560c1a8d37c7670daab031b635102/" rel="bookmark">
			scrapy添加cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在DEFAULT_REQUEST_HEADERS中添加 第一步打开settings.py
将COOKIES_ENABLED = False解除注释
然后解除DEFAULT_REQUEST_HEADERS注释
2.使用scrapy.Request中的cookies参数 首先将COOKIES_ENABLED = False改为true
然后将cookie反序列化
cookie= '_ntes_nuid=8d967fa3f8554d20bd113de35746ad9c; Device-Id=i70Gko1JVoIs7qs6F968; _ga=GA1.2.1134628517.1630412253; _ntes_nnid=8d967fa3f8554d20bd113de35746ad9c,1665043982001; __bid_n=1856cf764a513990824207; FEID=v10-8313c85f7de79a8e2f560cde271fa7b1606b16b3; __xaf_fpstarttimer__=1672570430810; Locale-Supported=zh-Hans; game=csgo; AQ_HD=1; YD_SC_SID=0183795762374AFC8D9C97C77F0869E9; AQ_REQ_FROM=webzj; NTES_YD_SESS=F6QEHmHCD9BObRN.Srsg5rqa.akndo0_1fYhGRWqnnIpkrW0kCD17o36f6h2aVRvEw6vAGPsy9cflHv1WUPteUjmYFJw6kwZbPO2e0J9FDnEHGx.nazr8Lv.OX2bE.Toe68zJoIBYEmEoAGRQR5PyAVdOygO36op.z4M_mX7B772mcNSXqtW6O_oO26gHhDDirSAPjxKNtQ7Miej55zhqhc0hbKCriMn_ivsxYf1UZApV; S_INFO=1681284174|0|0&amp;60##|19196482127; P_INFO=19196482127|1681284174|1|netease_buff|00&amp;99|sic&amp;1681282167&amp;netease_buff#sic&amp;510100#10#0#0|&amp;0|null|19196482127; remember_me=U1106914556|dVZ7ZfYFVatOpmSamrbKsDobKKjVsfKl; session=1-G0v5cQhu-08b_gOO6OAHPFQTBfxXJh5_Mzb6DuINue6h2033496996; csrf_token=IjA2NzQ1MGRjNTcyYjAzOTMxNTMxNWUzOWVkYTMzNGY5ZDZkNzQ0MDki.Fxft2Q.NstXpDi0ofj2at6k-3sOsCfLugY' cookies={ data.split('=')[0] : data.split('=')[1] for data in cookie.split(';')} print(cookies) yield scrapy.Request(url='https://buff.163.com/api/market/goods/price_history/buff?',callback=self.prices,cookies=cookies) 将cookies的值设置为反序列化后的cookie
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d72eadc57743cb4b472ef1c21727de4/" rel="bookmark">
			Git之github上传大文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github默认情况下不允许上传大文件，但是我想在github上备份重要文件，借助lfs实现上传大文件
1、下载并安装Git Large File Storage 2、git lfs 配置 在git仓库所在文件夹中输入如下代码进行安装配置
git lfs install 3、文件上传 git lfs track * #追踪要上传的大文件，*表示路径下的所有文件 git add .gitattributes #添加先上传的属性文件(要先上传属性文件，不然有可能失败) 装个git lfs，把你觉得大的文件加入到.gitattributes格式的标记文件中，然后正常操作就ok了 git commit -m "Git LFS commit" #添加属性文件上传的说明 git push #上传属性文件 git add * #添加要上传的大文件，*表示路径下的所有文件 git commit -m "上传大文件" #添加大文件上传的说明 git push #上传大文件 遇到的问题 1、
batch response: This repository is over its data quota. Account responsible for LFS bandwidth should purchase more data packs to restore access.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d72eadc57743cb4b472ef1c21727de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/416cd3ae3ddc2981b1716fd9bc497b69/" rel="bookmark">
			处理CSV（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		处理CSV（python） 简介1. CSV和Python简介2. 文章内容简介 一、用csv模块读取和写入CSV文件1. CSV模块2. 示例 二、用pandas库读取和写入CSV文件1. pandas2. 示例 三、处理CSV文件中的特殊情况1. 特殊情况及处理方法2. 示例 简介 1. CSV和Python简介 CSV是一种常见的数据格式，可以用来存储和交换表格数据。CSV文件由一系列的行组成，每行包含一些用逗号分隔的字段。CSV文件可以用文本编辑器或excel打开和编辑，也可以用编程语言进行处理和分析。
Python是一种流行的编程语言，它有许多内置的模块和第三方库，可以方便地读取和写入CSV文件。
2. 文章内容简介 本文将介绍如何用Python处理CSV文件，包括以下几个方面：
用csv模块读取和写入CSV文件用pandas库读取和写入CSV文件处理CSV文件中的特殊情况，如引号、换行符、编码等 一、用csv模块读取和写入CSV文件 1. CSV模块 csv模块是Python标准库中的一个模块，它提供了一些类和函数，可以帮助我们读取和写入CSV文件。csv模块常用的类有两个：
csv.reader：用来从一个文件对象或一个迭代器中读取CSV数据，返回一个迭代器，每次迭代返回一个列表，表示一行数据。csv.writer：用来将数据写入一个文件对象或一个迭代器中，接受一个可迭代对象作为参数，每个元素是一个列表，表示一行数据。 2. 示例 示例文件：data.csv如下图：
用csv模块读取和写入CSV文件：
# 导入csv模块 import csv # 以只读模式打开一个CSV文件 with open('data.csv', 'r') as f: # 创建一个csv.reader对象，指定分隔符为逗号 reader = csv.reader(f, delimiter=',') # 遍历reader对象，打印每一行数据 for row in reader: print(row) # 用写入模式创建一个新的CSV文件，newline=''可以避免空行 with open('new_data.csv', 'w', newline='') as f: # 创建一个csv.writer对象，指定分隔符为逗号 writer = csv.writer(f, delimiter=',') # 写入一些数据，每个元素是一个列表，表示一行数据 writer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/416cd3ae3ddc2981b1716fd9bc497b69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4b5beea93ef246e77c4db415b0d59c/" rel="bookmark">
			Git之文件名乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 现象 利用git status查看待提交的文件，其中文件名中有中文，但是显示的中文字符是乱码
乱码原因 在默认设置下，中文文件名在工作区状态输出，中文名不能正确显示，而是显示为八进制的字符编码。
解决方式 设置 git 的** core.quotepath **选项为false，quotepath表示引用路径，加上–global表示全局配置
git config --global core.quotepath false 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6370ab9342d809adee5265b48418df04/" rel="bookmark">
			postman进行post、get参数传递及中文乱码和各类型参数传递和json格式传参和日期型参数传递和响应数据传回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		postman是一种测试工具
用postman直接在其上输入参数名和参数值就行，不用区分post和get请求方法，当然java代码要改变一点，在响应注解的方法里面添加和postman中输入的参数名一样的形参
get请求：
代码：注意在响应注解的方法里面新添加了形参，其就对应着上面图片中的参数名
package com.itjh.servletmvc; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; @Controller //控制器 public class sermvc { //请求时的访问路径 @RequestMapping("/sav") //返回给浏览器的响应数据 @ResponseBody public String save(String name){ System.out.println("spring.......mvc.."+name); return "{'name':'zhangsan'}}"; } } 测试类：
package com.itjh.Config.test; import com.itjh.Config.SpringmvcConfig; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.support.AnnotationConfigWebApplicationContext; import org.springframework.web.servlet.support.AbstractDispatcherServletInitializer; public class SpringmvcTest extends AbstractDispatcherServletInitializer { //加载springmvc容器 @Override protected WebApplicationContext createServletApplicationContext() { AnnotationConfigWebApplicationContext context=new AnnotationConfigWebApplicationContext(); //注册一下springmvc容器 context.register(SpringmvcConfig.class); System.out.println("加载springmvc容器"); return context; } //从前端过来的请求，被拦截，即设置哪些请求归springmvc管 @Override protected String[] getServletMappings() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6370ab9342d809adee5265b48418df04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd9e1254b2d4698e698a6e19d5f9997f/" rel="bookmark">
			【JavaEE】死锁是什么？如何避免死锁（保姆级讲解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主简介：想进大厂的打工人博主主页：@xyk:所属专栏: JavaEE初阶 本篇文章将介绍什么是死锁，死锁的四大必要条件，如何去避免死锁~~~ 目录
一、死锁是什么？
二、关于死锁的情况
2.1 一个线程的情况
2.2 两个线程的情况
2.2.1 形如这样的代码：
2.2.2 吃饺子
2.3 N个线程的情况
2.4 加锁代码
三、如何避免死锁
3.1 死锁产生的四个必要条件
当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。其中最容易破坏的就是 "循环等待".
3.2 破坏循环等待：
四、相关面试题
4.1 谈谈 volatile关键字的用法?
4.2 Java多线程是如何实现数据共享的?
4.3 Java创建线程池的接口是什么？参数 LinkedBlockingQueue 的作用是什么？
4.4 Java线程共有几种状态？状态之间怎么切换的？
4.5 在多线程下，如果对一个数进行叠加，该怎么做？
4.6 Servlet是否是线程安全的？
4.7 Thread和Runnable的区别和联系?
4.8 多次start一个线程会怎么样
4.9 有synchronized两个方法，两个线程分别同时用这个方法，请问会发生什么？ 4.10 进程和线程的区别？
一、死锁是什么？
死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。
简单来说，死锁，就是没人能解锁了~~
举例：
我有个女神，我向女神表白了：女神I love you，她欣然同意，我就加锁成功了~~接下来，我换个微信小号，再偷偷加她一把，再在小号上也表白~~此时第二次尝试加锁，就不会成功了，我就只能阻塞等待~~
形如这样的代码：
就是加锁俩次的情况，第二次尝试加锁，需要等待第一个锁释放；第一个锁释放，需要等待第二个锁加锁成功；
逻辑上矛盾了！！！ ==&gt;这就是死锁~~
二、关于死锁的情况 2.1 一个线程的情况 一个线程，一把锁（上面的情况），可重入锁没事，不可重入锁死锁；
2.2 两个线程的情况 两个线程，两把锁，即使是可重入锁，也会死锁~~
2.2.1 形如这样的代码： t1和t2线程在互相抢占锁，t1拥有了locker1再去竞争locker2，t2拥有了locker2再去竞争locker1，这样就形成了死锁~~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd9e1254b2d4698e698a6e19d5f9997f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed0cb5277156bd70191271e260986b80/" rel="bookmark">
			阿里云服务器安装宝塔面板搭建网站全流程（一步步详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云服务器安装宝塔面板教程，云服务器吧以阿里云Linux系统云服务器安装宝塔Linux面板为例，先配置云服务器安全组开放宝塔所需端口8888、888、80、443、20和21端口，然后执行安装宝塔面板命令脚本，最后登录宝塔后台安装LNMP，包括Nginx、MySQL、Pure-Ftpd、PHP和phpMyAdmin：
目录
阿里云服务器安装宝塔面板教程
一：阿里云服务器开启宝塔所需端口号
二：远程连接到云服务器执行宝塔面板安装命令
三：宝塔面板安装Web环境
阿里云服务器安装宝塔面板教程 云服务器吧创建了一台阿里云服务器ECS计算型c7实例（ecs.c7.large）2核4G配置，5M公网带宽，操作系统为Alibaba Cloud Linux，如下图：
阿里云Linux服务器配置
阿里云服务器出于安全考虑，默认安全组只开放了22和3389端口，宝塔面板需要开启8888、888、80、443、20和21端口。先为云服务器开放宝塔所需端口，然后再执行安装宝塔Linux面板命令。可以在阿里云CLUB中心：aliyun.club 领取专属代金券。
一：阿里云服务器开启宝塔所需端口号 如果你使用的不是阿里云服务器，或者已经开放了相应的端口，那么可以忽略此步骤。
1、登录到阿里云服务器管理控制台
左侧栏选择“实例”，找到需要开放端口的云服务器ECS实例，如果没有，记得切换左上角地域
2、找到“更多”--“网路和安全组”--“安全组配置”，如下图：
阿里云服务器安全组配置
3、在安全组的“配置规则”中，按照下图开放21、20、443、80、888和8888端口
阿里云服务器开放宝塔面板端口
如上图所示，在“入方向”选择“手动添加”，云服务器吧以开启8888端口为例，端口范围目的：8888/8888，授权对象源：0.0.0.0/0。以此类推，把宝塔面板所需端口都开启。
二：远程连接到云服务器执行宝塔面板安装命令 远程连接到云服务器，可以使用阿里云服务器控制台自带的远程连接工具，也可以使用Xshell等SSH客户端。云服务器吧以阿里云服务器控制台自带的远程连接工具为例，如下图：
阿里云服务器远程连接
阿里云服务器支持多种远程连接方式，云服务器吧以Workbench远程连接为例，选择“Workbench远程连接”，点“立即登录”，如下图：
阿里云Workbench远程连接
云服务器Linux系统默认用户名为root，输入密码，点确定，即可登录。
登录云服务器
如果没有设置密码，或者忘记密码，可以通过重置实例密码的方式来设置新的密码。
然后执行宝塔Linux面板安装命令。云服务器吧使用的阿里云服务器安装的是Alibaba Cloud Linux镜像，Alibaba Cloud Linux是基于龙蜥社区(OpenAnolis) 龙蜥操作系统(Anolis OS)的阿里云发行版，完全兼容 RHEL/CentOS 生态和操作方式，所以使用宝塔面板CentOS的安装命令即可。
执行CentOS宝塔安装命令：
yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh
其他Linux系统安装宝塔面板命令，可以参考：宝塔面板Linux系统安装命令大全
执行宝塔安装命令后，会提示如下：
Do you want to install Bt-Panel to the /www directory now?(y/n): y
回复字母y，并回车即可继续安装。
这期间等待即可，宝塔程序会自动安装，安装时间与云服务器带宽和配置有关，一般3-5分钟即可安装完毕。
宝塔面板安装完毕后，会提示“Congratulations! Installed successfully!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed0cb5277156bd70191271e260986b80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87cf591d163b3c8cd5781d7cf2dac543/" rel="bookmark">
			GDB学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、基本用法 在gcc/g++参数里加上 -g ，生成的文件会包含调试程序，不加该参数则不包含调试程序，不利于gdb调试。
基本命令：
list或者l ：显示调试对象的代码文本内容。l 文件名:行数 可以显示该文件的第几行 b：设置断点。例如：b main ，在函数的main处设置断点。b+文件名:行数，在该文件的第几行设置断点。 i b ：查看断点信息，i 的全称是 info。 r：执行程序命令，会在断点出停下来。输入n或next命令，会继续执行，只执行一行，一行一行执行。 p 变量名：表示在调试过程中，显示变量的值，p表示print的意思。 c：表示继续执行，该命令会在下一个断点处停下来。 p locals：表示显示全部的当地变量值。 基本用法为：启动调试、设置断点、查看变量、继续执行。
2、启动调试 1、启动gdb并传递参数：
方式一：gdb --args 可执行文件名 参数1 参数2 ... 方式二：使用“ gdb 可执行文件名 “启动调试，在程序还没有 r 之前，使用命令：set args 参数1 参数2 ... 方式三：使用“ gdb 可执行文件名 “启动调试，在使用 r 命令的同时加上参数，即：r 参数1 参数2 ... 2、附加到进程：
当你想调试某个程序，然而该程序已经开始运行的时候，我们不用结束该程序，再使用gdb重新运行一次，而是直接在该进程中进行gdb调试。
首先使用命令： ps -aux | grep sec 来查看进程的pid号 方式一：gdb attach &lt;pid&gt; 也即，已经执行的函数程序的pid号，使用命令时不用加&lt;&gt;括号 方式二：gdb --pid &lt;pid&gt; 在使用上述命令进入条时候，会进入程序的等待响应处，你可以在原进程端口输入激励条件，也可以在gdb端口输入。 在推出gdb的时候，使用命令 detach 剥离程序，然后就可以使用 q 退出gdb。 3、单步执行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87cf591d163b3c8cd5781d7cf2dac543/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/566e440872701541c0cef44facdfe070/" rel="bookmark">
			Python字符串替换的3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python字符串替换笔记主要展示了如何在Python中替换字符串。Python中有以下几种替换字符串的方法，本文主要介绍前三种。
replace方法（常用）translate方法re.sub方法字符串切片（根据Python字符串切片方法替换字符） 1.replace方法 Python replace方法把字符串中的old（旧字符串） 替换成new(新字符串)，如果指定第三个参数max，则设置替换次数不超过 max 次。
str.replace(old, new[, max]) 示例1
在该示例中，出现的两个单词Hello都被替换为Hi。
#原字符 msg = "Hello world! Hello Python!" # 替换字符，字符串直接调用replace方法 msg2 = msg.replace('Hello', 'Hi') print(msg2) #输出 Hi world! Hi Python! 示例2
可以直接str.replace方法。它将我们进行替换的字符串作为第一个参数。结果和示例1一样。
msg = "Hello world! Hello Python!" msg2 = str.replace(msg, 'Hello', 'Hi') print(msg2) #输出 Hi world! Hi Python! 示例3
我们可以用换行符替换每个逗号，并设置替换次数
data = "1,2,3,4,5" # 替换次数为3次 data2 = data.replace(',', '\n', 3) print(data2) #输出 1 2 3 4,5 示例4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/566e440872701541c0cef44facdfe070/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fdb85ee92e914eef1de66f348b51fa9/" rel="bookmark">
			Mybatis配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，JavaEE中mybatis的db.properties配置文件代码
mysql.driver=com.mysql.cj.jdbc.Driver mysql.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&amp;serverTimezone=UTC mysql.username=root mysql.password=sql123 2，JavaEE中mybatis的log4j.properties配置文件代码
# Global logging configuration log4j.rootLogger=ERROR, stdout # MyBatis logging configuration... #com.first是路径名 log4j.logger.com.first=DEBUG # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 3，JavaEE中mybatis的mybatis-config.xml配置文件代码
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;properties resource="db.properties"/&gt; &lt;settings&gt; &lt;!-- 日志配置--&gt; &lt;setting name="logImpl" value="log4j"/&gt; &lt;!-- 二级缓存--&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;/settings&gt; &lt;!-- 取别名--&gt; &lt;typeAliases&gt; &lt;package name="com..pojo"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境信息--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fdb85ee92e914eef1de66f348b51fa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04ab33979f5fd8ea754f554a2bf0d3ec/" rel="bookmark">
			Java学习日记（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
三、面向对象编程（二）
1、隐藏和封装
1.1 理解封装
1.2 使用访问控制符
1.3 package、import和import static
1.4 Java的常用包
三、面向对象编程（二） 1、隐藏和封装 1.1 理解封装 封装是面向对象编程的三大特征之一，它指的是将对象的状态信息隐藏在对象内部，
不允许外部程序直接访问对象的内部信息，而是通过该类提供的方法来实现对内部信息的操作和访问。
封装是面向对象语言对客观世界的模拟，就如人的年龄，只有随着岁月的更改才会改变，而通常不能用其他方法改变人的年龄对一个类进行良好的封装，可以实现以下目的：
（1）隐藏类的实现细节；
（2）让访问者通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；
(3) 可进行数据检查，从而有利于保证对象信息的完整性；
（4）便于修改，提高代码的可维护性。
为了实现良好的封装，需要从两个方面考虑。
（1）将对象的成员变量和实现细节隐藏起来，
（2）不允许外部直接访问.把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。
1.2 使用访问控制符 Java提供了3个访问控制符：private、protected、public，分别代表了3个访问控制级别，提供了4个访问控制级别。Java的访问控制级别由小到大，如图3.1所示：
图3.1访问控制级别由小到大 图中的Default并没有对应的访问控制符，当不使用任何访问控制符修饰类或类成员时，系统自动默认使用该访问控制级别。
private（当前类访问权限）：如果类里的成员（包括成员变量、方法和构造器等）使用private来修饰，则这个成员只能在当前的类中访问；
default(包访问权限）：在相同包下可以访问；
protected（子类访问权限）：被protected修饰的成员，既可以被同一个包下的其他子类访问，又可以被在其他包下的子类访问。在通常情况下，如果使用protect来修饰一个方法，通常是希望其子类来重写这个方法；
public(公共访问权限)：被它修饰的成员可以被所有类访问。
掌握了访问控制符的用法之后，下面通过使用合理的访问控制符来实现一个Person类，这个Person类实现了良好的封装。
程序如下：
public class Person{ private String name; private int age; public void setName(String name) { //执行合理性校验，要求用户名必须在2~6位之间 if(name.length()&gt;6||name.length()&lt;2) { System.out.println("您设置的人名不符合要求“)； return； } else { this.name=name; } } public String getName() { return this.name; } public void setAge(int Age) { if(age&gt;100||age&lt;0) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04ab33979f5fd8ea754f554a2bf0d3ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bcd5d93c8d84c02c22255749bfa8f30/" rel="bookmark">
			本周最火AutoGPT！GitHub3.6万&#43;标星，解决复杂任务全程无需人类插手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		金磊 丰色 发自 凹非寺
量子位 | 公众号 QbitAI
本周AI圈”最红炸子鸡“诞生——AutoGPT。
不仅如此，这款软件系统的横空出世，一举将AI进程推向了新高度——
自主人工智能。
顾名思义，它所具备的能力主打的就是一个“自主”，完全不用人类插手的那种！
例如一位网友就要求AutoGPT开发一个网站，结果不到3分钟，AI自己就用React和Tailwind CSS“唰唰唰”地搞定了。
AI自己上网、自己使用第三方工具、自己思考、自己操作你的电脑。
这一套打法，算得上是把“行动→观察结果→思考→决定下一步行动”这条路子给打通并循环了起来。
就连前特斯拉AI总监Andrej Karpathy对此都评价道：
AutoGPT是提示工程的下一个前沿。
而且不只是AutoGPT，最近还陆陆续续地衍生出了各种自主人工智能工具，例如AgentGPT、BabyAGI等等。
然后网友们对面此景也坐不住了，惊叹于AI发展的日新月异：
这俩月，一睁眼就出新东西，太累了。
无需人类插手的AutoGPT们 那么这个当红的AutoGPT，和之前ChatGPT那波AI又有何区别？
微博博主“木遥”便下场亲测了一下。
△图源：微博博主“木遥”
他测试所用的题目是“给我解释LangChain怎么用”（LangChain是大型语言模型的一种应用框架）。
这个问题若是交给传统的GPT，由于LangChain这个概念太新，AI就会出现不知道怎么回答的情况。
若是交给“GPT+插件”这个组合来回答，那结果就会有点像Bing或者Bard。
但AutoGPT上手就不一样了，来欣赏一下它的执行过程：
首先试着直接去LangChain官网爬信息。
被官网拒绝了，可能因为有屏蔽。
发现失败了之后想了想，说要不Google一下？
Google出了很多结果。
读了半天这些结果，说「现在我们已经搜集了不少有用的信息了，接下来让我们安装它玩一下」
然后就开始动手在我的电脑上安装LangChain……
而博主“木遥”在这整个过程中所做的事情就是“坐在屏幕前看着这一切自动在我眼前发生”……
△图源：微博博主“木遥”
然后这位博主不禁发出了感慨：
我要是有它这个行动力，三个PhD都念完了。
有类似自主能力的AI，还有最近同样火爆的AgentGPT。
也是只需要给个任务，剩下的都交给它来完成：
用100美元的资金创建一个新的创业公司。
AgentGPT在接到这项任务之后，便开始了他的展示：
思考中……
添加任务：研究需要最少资金的低成本商业模式。
添加任务：确定潜在的目标市场及其需求。
添加任务：开发一个精简的MVP（最小可行产品），并在目标市场进行测试以验证需求。
思考中……
然后AgentGPT先是输出执行“研究需要最少资金的低成本商业模式”的结果：
根据我的研究，一些需要最少资金的低成本商业模式包括：
1、Dropshipping：通过Dropshipping，你可以在网上销售产品而无需持有库存。您只需通过第三方供应商完成订单，第三方供应商将产品直接运送给您的客户。你可以从50美元开始支付网站托管和域名注册费。
2、 社交媒体营销：如果你有社交媒体营销的天赋，你可以通过帮助企业接触他们的目标受众来创办自己的代理公司。你所需要的只是一台电脑，互联网连接，以及一些社交媒体营销的经验和技能，而你的起价只有50美元或更少。
3、活动策划：如果你对组织活动有热情，你可以开始自己的活动策划业务。你可以从策划一些小活动开始，比如生日派对、婚礼等等。你可以从100美元开始，创建一个简单的网站，名片，并通过社交媒体营销自己。
4、自由写作：如果你有写作天赋，你可以开始自己的自由写作事业。你可以通过在线平台，如Upwork、Fiver和其他求职网站找到客户。只需50美元，你就可以创建一个投资组合网站，并通过社交媒体营销自己。
这些只是一些低成本的商业模式，你只需要100美元的资金就可以考虑。选择一个符合你的技能和兴趣的商业模式是很重要的。
到这还没有完，AgentGPT会继续开始它的工作：
思考中……
添加任务：针对每种已确定的低成本商业模式，对潜在的产品或服务想法进行头脑风暴。
添加任务：评估每个想法的潜在盈利能力和可扩展性。
添加任务：选择最有希望的想法，并开发精益MVP，用于目标市场的测试。
而后便是继续地再思考、执行。
再如BabyAGI，也只需给个目标和任务迭代次数，AI“唰唰唰”地便自己搞了起来：
而且已经有博主开始把AutoGPT当做自己的生产力工具了——做视频！
不少网友在看到AI们的如此表现之后，表示整个人都通透了：
怎么玩？ 这么强的工具，真的不想亲自玩一下？
操作一点也不麻烦。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bcd5d93c8d84c02c22255749bfa8f30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5606b44cc4d70ff1f31643ee7a7cf6d2/" rel="bookmark">
			Oracle通过EFcore进行反向工程记录 以及数据操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在.NET开发当中进行WebAPI开发，由于表已建好，为了快速开发则选择进行DBFirst，则通过EFcore来进行反向工程注入。
1.导入EFCore访问Oracle数据库相关程序包（特别注意版本，稍微不一样就可能影响后续操作）如下：
2.右键项目-&gt;管理NuGet程序包（注意：浏览下搜索【程序包全名】、勾上预发行版、版本、右边点击安装）
3.导完三个程序包，接下来用NuGet程序包管理控制台（工具-&gt;NuGet包管理器-&gt;程序包管理控制台）：
Scaffold-DbContext "Data Source=(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=192.168.128.238)(PORT=1521))(CONNECT_DATA=(SERVICE_NAME=ORCL)));User Id=EFTEST;Password=EFTEST;" Oracle.EntityFrameworkCore -OutputDir Models 其中Data Source 属性与 Oracle文件夹下的 tnsnames.oRA 所对应的数据库一致
-Schemas 选项可用于包含架构中的每个表，而 -Tables 可用于包含特定表。
Scaffold-DbContext ... -Tables Artist, Album ！！！ -Force -f 强制覆盖
-Force -f 后缀 -Context 输出上下文类名称
-Context AntContext -outputdir 输出模型目录
-outputdir Models -Contextdir Data 上下文目录
-Contextdir Data -DataAnnotations
-DataAnnotations 生成数据注解 参考文章 如下：
微软官方EFcore反向工程文档：微软官方文档
大佬的 EFcore使用Oracle文档 ：EFcore使用文档
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/881534abfc96aac532ae01ff90b30aec/" rel="bookmark">
			深入理解Java的内存屏障
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java是一门高级语言，它为我们提供了许多便利的工具和接口，让我们能够更加高效地开发软件。然而，这些便利的工具背后隐藏着许多复杂的技术细节，其中一个重要的技术细节就是内存屏障。
内存屏障是一种硬件或者软件机制，它可以确保在多线程程序中，数据的修改能够正确地被其他线程感知到，从而保证程序的正确性和可靠性。在Java中，内存屏障是非常重要的，因为Java程序通常都是多线程程序，因此需要保证数据在不同线程之间的正确性。
在本文中，我们将深入探讨Java的内存屏障，包括其原理、实现方式以及常见的应用场景。
内存屏障的原理 内存屏障的本质是一种硬件或者软件机制，其主要作用是确保内存访问的有序性。在多核CPU架构下，不同的线程可能同时访问同一个内存地址，而这些内存地址的读写操作可能会被乱序执行，从而导致数据的不一致性。为了解决这个问题，内存屏障被引入了。
内存屏障可以分为多种类型，其中比较常见的包括：
Load Barrier（加载屏障）：保证在加载某个内存地址的数据之前，所有之前的内存操作都已经完成。Store Barrier（存储屏障）：保证在存储某个内存地址的数据之后，所有之后的内存操作都还没有开始。Full Barrier（全屏障）：同时包含加载屏障和存储屏障的效果，即保证在某个内存地址的数据被加载或存储之前，所有之前的内存操作都已经完成，而所有之后的内存操作还没有开始。 通过使用这些内存屏障，我们可以确保数据的读写操作按照我们所期望的顺序进行，从而避免了数据的不一致性。
内存屏障的实现方式 内存屏障可以通过硬件或者软件实现。在硬件层面，CPU通常会提供一些专门的指令来实现内存屏障。例如，x86架构的CPU提供了lfence、sfence和mfence等指令来实现加载屏障、存储屏障和全屏障。在软件层面，Java虚拟机也提供了一些内存屏障相关的接口，例如sun.misc.Unsafe类中的park、unpark、loadFence和storeFence方法，以及java.util.concurrent包中的LockSupport类等。
在Java中，使用volatile关键字声明的变量也具有内存屏障的效果。当一个线程写入volatile变量时，它会强制将修改后的值刷新到主内存中，而其他线程读取该变量时也会强制从主内存中重新加载最新的值，从而保证数据的一致性。同时，volatile变量的读写操作也会被编译器和CPU优化器限制，从而避免了因为编译器优化而导致的数据不一致性问题。
内存屏障的应用场景 内存屏障的应用场景非常广泛，其中最常见的应用场景包括：
保证volatile变量的可见性
如前所述，使用volatile关键字声明的变量可以保证多线程访问时的可见性。这是因为volatile变量具有内存屏障的效果，它会强制将修改后的值刷新到主内存中，而其他线程读取该变量时也会强制从主内存中重新加载最新的值。保证线程的安全性
内存屏障也可以用于保证线程的安全性。在多线程环境下，为了保证数据的一致性，我们通常需要对某些共享资源进行加锁。在使用锁的过程中，我们也需要使用内存屏障来确保锁的正确性。
例如，在使用synchronized关键字进行同步时，Java虚拟机会使用内置锁（也称为监视器锁）来保证线程的安全性。当一个线程获取锁时，它会执行一个内存屏障操作，从而确保所有之前的内存操作都已经完成，而其他线程在尝试获取锁时也会执行一个内存屏障操作，从而确保所有之前的内存操作都已经完成。优化代码的性能
除了上述应用场景外，内存屏障还可以用于优化代码的性能。例如，在Java中使用CAS（Compare And Swap）操作时，我们可以通过使用loadFence和storeFence方法来限制指令重排，从而提高CAS操作的性能。
具体来说，当我们使用CAS操作时，我们需要保证CAS操作之前的所有内存操作都已经完成，而CAS操作之后的所有内存操作都还没有开始。如果我们不使用内存屏障，那么编译器和CPU优化器可能会将CAS操作之前的内存操作和CAS操作之后的内存操作进行重排，从而导致CAS操作失败。通过使用内存屏障，我们可以限制这种重排行为，从而提高CAS操作的性能力。 样例代码 下面是一个使用volatile变量实现线程间通信的简单示例代码：
public class VolatileExample { private volatile boolean flag = false; public void setFlag(boolean flag) { this.flag = flag; } public void doSomething() { while (!flag) { // do something } // do something else } } 在上面的示例代码中，我们使用volatile关键字声明了一个布尔型变量flag，并在doSomething方法中使用了这个变量来实现线程间的通信。当flag为false时，doSomething方法会一直循环执行某些操作，直到flag变为true才会继续执行下面的代码。在另一个线程中，我们可以调用setFlag方法来设置flag的值，从而触发doSomething方法的执行。
需要注意的是，尽管volatile变量可以保证多线程访问时的可见性，但它并不能保证原子性。如果多个线程同时修改volatile变量的值，那么可能会发生竞态条件（Race Condition）的问题，从而导致数据的不一致性。为了避免这种问题，我们通常需要使用锁或者原子类来保证数据的原子性。
总结 本文主要介绍了Java中的内存屏障相关知识，包括内存屏障的概念、分类、工作原理、应用场景和样例代码等。通过本文的学习，读者可以更好地理解Java中内存模型的工作原理，进而编写出更加高效、可靠的多线程程序。同时，读者也可以进一步了解JDK中提供的各种并发工具，从而更好地利用Java中的多线程机制来提升代码的性能和稳定性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468d7a39a475df25843e4f306f05a3d1/" rel="bookmark">
			手把手教你在linux中部署stable-diffusion-webui
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stable-diffusion-webui是什么就不用多说了，以下是安装步骤，我以linux系统为例介绍，windows系统大同小异，安装期间没有用到梯子，安装目录/opt/stable-diffusion-webui/。
1.安装Anaconda
stable-diffusion-webui要求python版本在3.8-1.10，找对应的Anaconda版本就可以了，Anaconda下载地址：Anaconda | Anaconda Distribution
2.克隆git项目
从git上克隆
git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui 3.安装webui所需要的依赖包
cd到stable-diffusion-webui的目录执行下面两个命令，这一步一般比较顺利，如果下载慢可以换源，如在命令后面加上 -i http://pypi.douban.com/simple/
pip install -r requirements_versions.txt pip install -r requirements.txt 期间可能会报CLIP安装失败，Couldnt install clip。解决办法可以修改launch.py文件的CLIP_PACKAGE配置：
clip_package = os.environ.get('CLIP_PACKAGE', "git+https://gitee.com/ufhy/open_clip.git@bb6e834e9c70d9c27d0dc3ecedeebeaeb1ffad6b --prefer-binary") 4.安装webui插件
默认是没有任何插件的，可以跳过这步。下面是安装dreambooth插件的命令。
pip install -r extensions/sd_dreambooth_extension/requirements.txt 5.创建webui启动脚本
新建start.sh输入如下内容：
#!/bin/bash export COMMANDLINE_ARGS="--deepdanbooru --port 6006 --theme dark --share " python_cmd="python" LAUNCH_SCRIPT="launch.py" "${python_cmd}" "${LAUNCH_SCRIPT}" "$@" 上面的启动命令：
--deepdanbooru 启用了图生文的功能，主要用于训练前数据处理，这里没有太大用。
--port 6006 访问端口6006
--theme dark 黑色主题
--share 接了这个参数， 可以使用一个临时的公网地址进行程序访问，但是这个地址只能使用72小时，每次重启这个地址会变，公网地址如下图：
浏览器访问https://127.0.0.1:6006或者临时公网地址就能打开web页面了，开始生成你自己的图片吧。
stable-diffusion-webui的部署还是很简单的，后面还会有关于stable-diffusion-webui的更多内容，敬请期待。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03db138d53beafdad93fd9bec7f121aa/" rel="bookmark">
			js特效效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 轮播：
全swiper轮播（下面第一个）：
Swiper-强大的移动手机端幻灯片插件效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库
jQuery全屏圆形导航轮播图布局特效效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库
兼容IE8的高级jQuery轮播图插件_jQuery之家-自由分享jQuery、html5、css3的插件库
简单的jQuery响应式轮播图插件效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库
jquery简单轮播图代码效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库
带17种内置过渡动画的jquery轮播图插件效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库 支持markdown语法的网页幻灯片插件效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库
带缩略图和多种过渡动画效果的jquery轮播图特效效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库 带倒影效果的jquery轮播图插件效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库
myFocus-强大的js焦点图插件效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库
VM Carousel-jQuery响应式轮播图插件效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库 超炫游戏角色介绍jQuery幻灯片特效效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库基于slick插件的jQuery幻灯片特效效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库
基于SVG clipPath的预览图变形特效幻灯片效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库
Material Design风格内容幻灯片特效效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库 带视觉差效果的jQuery幻灯片特效效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库
(重点参考 下面这个：） 将Bootstrap网格转换为旋转木马特效的jQuery插件效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库 edslider-时尚的响应式jQuery焦点图插件效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库
支持移动端和桌面设备的轻量级jQuery幻灯片插件效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库 基于GSAP的响应式全屏背景图片jQuery幻灯片插件效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库
jQuery和css3圆形缩略图导航轮播图插件效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库 大图、缩略图轮播：
lightslider-支持移动触摸的轻量级jQuery幻灯片插件效果演示_jQuery之家-自由分享jQuery、html5、css3的插件库 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56b9731be9f643855cbe8243a4ba928e/" rel="bookmark">
			vba中工作簿事件，工作表事件，EnableEvents 属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各种事件过程代码的执行顺序：
先出发工作表，再工作簿，最后应用程序
应用程序事件注释NewWorkbook当新建一个工作簿时发生此事件SheetActivate当激活任何工作表时发生此事件SheetBeforeDoubleClick在双击任何工作表前发生此事件SheetBeforeRightClick右键单击任何工作表前发生此事件SheetCalculate在重新计算工作表时发生此事件SheetChange更改任何工作表的单元格时发生此事件SheetDeactivate当工作表失去焦点时发生此事件（离开工作表时）。 SheetFollowHyperlink在单击工作簿中的任何超链接时发生。 SheetPivotTableUpdate在更新数据透视表的工作表后发生。SheetSelectionChange所选内容在任何工作表上更改时发生。WindowActivate在激活任何工作簿窗口时发生。 WindowDeactivate工作簿的窗口变为非活动状态时，将产生本事件。WindowResize改变工作簿窗口大小时发生WorkbookActivate当激活任何工作簿时发生此事件WorkbookAddinInstall工作簿为加载宏安装时发生此事件WorkbookAddinUninstall当任一工作簿作为卸载宏时发生WorkbookAfterXmlEmport在保存或导出工作簿中的XML数据之后发生此事件WorkbookAfterXmlImport当刷新现有的XML数据链接或新的XML数据被导入任一打开的Excel工作簿之后时发生WorkbookBeforeClose关闭任何工作簿前发生此事件WorkbookBeforePrint在打印工作簿前发生此事件WorkbookBeforeSave在保存任何工作簿前发生引事件WorkbookBeforeXmlExport保存或导出XML数据前发生的事件WorkbookBeforeXmlImport当刷新现有的XML数据链接或新的XML数据被导入任一打开的Excel工作簿之前时发生WorkbookDeactivate当打开的工作簿转为非活动状态时发生此事件WorkbookNewSheet 在任何打开的工作簿中新建工作表时发生此事件WorkbookOpen当打开一个工作簿时发生此事件WorkbookPivotTableCloseCloseConnection在数据透视表的链接关闭之后发生此事件WorkbookPivotTableOpenCloseConnection在数据透视表的链接打开之后发生此事件WorkbookRowsetCompletd如果用户在OLAP数据透视表上深化记录集或调用行集操作，则会发生WorkbookRowsetComplete事件Workbooksync当作为“文档工作区”一部分的工作簿的本地副本与服务器上的副本进行同步时发生此事件工作簿事件注释Activate激活工作簿、工作表、图表工作表或嵌入式图表时发生此事件AddinInstall当工作簿作为加载宏安装时，发生此事件AddinUninstall当工作簿作为加载宏卸载时，发生此事件AfterXmlExport在Excel保存或导出指定工作簿中的XML数据之后发生此事件AfterXmlImport在刷新现有的XML数据链接或将新的XML数据导入到指定的Excel工作簿之后，发生此事件BeforeClose在关闭工作簿之前，先产生此事件。如果该工作簿已经更改过，则本事件在询问用户是否保存更改之前产生。BeforePrint在打印指定工作簿（或者其中的任何内容）之前，发生此事件BeforeSave保存工作簿之前发生此事件BeforeXmlExport在Excel保存或导出指定工作簿中的XML数据之后发生此事件BeforeXmlImport在刷新现有的XML数据链接或将新的XML数据导入到指定的Excel工作簿之后，发生此事件Deactivate图表、工作表或工作簿被停用时发生此事件NewSheet当在工作簿中新建工作表时发生此事件Open打开工作簿时，发生此事件PivotTableCloseConnection数据透视表关闭与其数据源的链接后发生此事件PivotTableOpenConnection数据透视表打开与其数据源的链接后发生此事件RowsetComplete如果用户在OLAP数据透视表上深化记录集或调用行集操作，则会引发此事件SheetActivate当激活任何工作表时发生 此事件SheetBeforeDoubleClick当双击任何工作表时发生此事件，此事件先于默认的双击操作发生SheetBeforeRightClick右键单击任一工作表时发生此事件，此事件先于默认的右键单击操作SheetCalculate在重新计算工作表时或在图表上绘制更改的数据之生发生此事件SheetChange当用户或外部链接更改了任何工作表中的单元格时发生此事件SheetDeactivate当任何工作表停用时发生此事件SheetFollowHyperlink单击Excel中的任何超链接时发生此事件SheetPivotTableUpdate在数据透视表的工作表更新之后发生此事件SheetSelectionChange任一工作表的选定区域发生更改时，将发生此事件Sync当作为“文档工作区”一部分的工作表的本地副本与服务器上的副本进行同步时，发生此事件WindowActivate工作簿窗口被停用时发生此事件WindowDeactivate任何工作簿窗口调整大小时发生此事件WindowResize任何工作簿窗口被停用时发生此事件工作表事件注释Activate激活工作簿，工作表，图表等发生的事件BeforeDoubleClick在工作表中双击前发生的事件BeforeRightClick右键单击工作表前发生的事件Calculate工作表重新计算之后发生的事件Change更改工作表中的单元格发生的事件Deactivate工作表，图表停用（焦点离开）时发生的事件FollowHyperlink单击工作表上的任意超链接时，发生此事件PivotTableUpdate工作簿中的数据透视表更新后发生此事件SelectionChange当工作表上选定区域发生改变时发生此事件 扩展：Application.EnableEvents 属性
'Application.EnableEvents = True/FALSE
'如果对指定对象启用事件，则该属性值为 True。Boolean 类型，可读写。
'作用：临时关闭，防止死循环
案例：
Private Sub Worksheet_Activate() '激活工作表触发的程序
a = InputBox("请输入密码")
If a = 123 Then
Cells.Font.Color = RGB(0, 0, 0)
Application.EnableEvents = False Else
Sheet3.Activate
End If
End Sub
Private Sub Workbook_Open()
Application.EnableEvents = True '让事件生效
Sheet2.Cells.Font.Color = RGB(255, 255, 255)
Sheet3.Activate
End Sub
object 是对象的意思
番外补充：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f8e81eb55229dea7b908cd8464cc3dc/" rel="bookmark">
			win2016-WordPress
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装phpstudy在官网下载wordpress，注意：在wordpress5.2版本后，需适配PHP5.6.20以后的版本，否则可能出现格式错误。下载wordpress后，将其解压，将upload目录复制到apache的WWW文件夹，路径为C:/phpstudy/WWW创建wordpress数据库：mysql -uroot -p输入密码后 建立数据库CREATE DATABASE wordpress 输入网址：http://localhost/wordpress，进行安装，数据库root，密码root；wordpress用户名admin，密码Antiy?1024 安装好后，进行登陆 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a0d13ee12195abd0651956d44c115b/" rel="bookmark">
			实验：基于ACL实现与禁止Telnet和Ping命令（HCIA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实验要求与拓扑搭建
二、实验过程
2.1配置IP地址，实现全网可达
2.1.1给PC1、PC2添加缺省，使路由器充当PC使用
2.1.2 实现全网可达的条件
2.2 开启AAA服务，创建账号密码，定义账号的作用
2.3 开启acl，实现与拒绝网络的telnet与ping命令
2.4 验证结果
一、实验要求与拓扑搭建 二、实验过程 2.1配置IP地址，实现全网可达 [r1-GigabitEthernet0/0/0]ip add 192.168.2.1 24
[r1-GigabitEthernet0/0/1]ip add 192.168.1.1 24
[r2-GigabitEthernet0/0/0]ip add 192.168.1.2 24
[pc1-GigabitEthernet0/0/0]ip add 192.168.2.2 24
[pc2-GigabitEthernet0/0/0]ip add 192.168.2.3 24
2.1.1给PC1、PC2添加缺省，使路由器充当PC使用 [pc1]ip route-static 0.0.0.0 0 192.168.2.1
[pc2]ip route-static 0.0.0.0 0 192.168.2.1
2.1.2 实现全网可达的条件 在R2上手动添加192.168.1.0到192.168.2.0的静态路由
2.2 开启AAA服务，创建账号密码，定义账号的作用 即在被telnet的设备上开启服务配置
[r1]user-interface vty 0 4（设置控制设备终端数为0-4人）
R2操作命令同R1 2.3 开启acl，实现与拒绝网络的telnet与ping命令 [r1]acl 3000
[r1-acl-adv-3000]rule deny icmp source 192.168.2.2 0.0.0.0 destination 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3a0d13ee12195abd0651956d44c115b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/902d3d6b415641e07444ca73a1d4fd81/" rel="bookmark">
			Linux(CentOS) yum源失效，无法下载解决方法。更换CentOS 5,6,7,8 yum源教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		截至2023年4月11日，目前CentOS系列除CentOS 7以外，其它版本的CentOS官方yum源都已经下线，因此会出现系统自带的yum源失效导致无法下载的问题。其它版本的CentOS只能更换yum源。
目录
查看yum源
更换CentOS 8 yum源
更换CentOS 7 yum源
更换CentOS 6 yum源 更换CentOS 5 yum源 查看yum源 //查看已经安装好的yum源仓库 yum repolist 更换CentOS 8 yum源 备份旧yum源 //备份系统旧配置文件 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 下载yum源(下面的yum源只要下载其中一个就行) //阿里云yum源 wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo //腾讯云yum源 wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.cloud.tencent.com/repo/centos8_base.repo //华为云yum源 wget -O /etc/yum.repos.d/CentOS-Base.repo https://repo.huaweicloud.com/repository/conf/CentOS-8-reg.repo 更新缓存 //清除原有yum缓存 yum clean all //刷新缓存 yum makecache 更换CentOS 7 yum源 备份旧yum源 //备份系统旧配置文件 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 下载yum源(下面的yum源只要下载其中一个就行) //阿里云yum源 wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo //腾讯云yum源 wget -O /etc/yum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/902d3d6b415641e07444ca73a1d4fd81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f917d45f1769548a464da8039ef4c2/" rel="bookmark">
			编写一个函数sum求s=x&#43;xx&#43;xxx&#43;xxxx&#43;......的值，其中x是一个数字，将求得的和返回，要求使用while循环进行累加求和。例如1&#43;11&#43;111&#43;111&#43;11111(此时共有5个数字)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写一个函数sum求s=x+xx+xxx+xxxx+......的值，其中x是一个数字，将求得的和返回，要求使用while循环进行累加求和。例如1+11+111+111+11111(此时共有5个数字相加)。
方式一： package day_2023_4_12; import java.util.Scanner; public class Test { public static void main(String[] args) { System.out.println(new Test().sum()); } long sum(){ long x,sum=0,i=1; System.out.println("请输入相加的项数："); Scanner scanner=new Scanner(System.in); int n=scanner.nextInt(); System.out.println("请输入数字x的值："); x=scanner.nextInt(); while(i&lt;=n){ sum+=x; x=x*10+1; i++; } return sum; } } 方式二： package day_2023_4_12; import org.junit.Test; import java.util.Scanner; public class Sum { public static void main(String[] args) { System.out.println(new Sum().sum()); } long sum(){ long x,y=0,s=0; Scanner scan=new Scanner(System.in); System.out.println("请输入相加的项数："); int n=scan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01f917d45f1769548a464da8039ef4c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48727b1a738e66c2f86a4c89e099fdfa/" rel="bookmark">
			Skywalking web页面空白问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述:今天微服务报错想用链路id追踪这个服务的流向，发现skywalking页面空白，查看后台进程发现skywalking-oap-server服务掉了，重启还是不行
tail -n500 skywalking-oap-server.log 查看这个服务的日志，发现是es分区满了导致的
于是去es服务器上查看，分区情况，发现已经到3000临界值
curl --insecure --anyauth -u elastic:Es@2022 -XGET 'http://10.121.65.106:19200/_cluster/health?pretty=true' { "cluster_name" : "es-cluster", "status" : "green", "timed_out" : false, "number_of_nodes" : 3, "number_of_data_nodes" : 3, "active_primary_shards" : 1545, "active_shards" : 3000, "relocating_shards" : 0, "initializing_shards" : 0, "unassigned_shards" : 0, "delayed_unassigned_shards" : 0, "number_of_pending_tasks" : 0, "number_of_in_flight_fetch" : 0, "task_max_waiting_in_queue_millis" : 0, "active_shards_percent_as_number" : 100.0 } 使用kibana的Dev Tools执行命令（临时 因为transient是临时生效重启es就会失效）
再次重启skywalking，此时skywalking-oap-server服务正常
清除缓存，此时skywalking页面正常，继续排查微服务的错.....
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcc06724923fbb211b6dc73e96458847/" rel="bookmark">
			软件测试面试题常见一百道【含答案】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问：你在测试中发现了一个bug，但是开发经理认为这不是一个bug，你应该怎样解决?
首先，将问题提交到缺陷管理库里面进行备案。
然后，要获取判断的依据和标准：
根据需求说明书、产品说明、设计文档等，确认实际结果是否与计划有不一致的地方，提供缺陷是否确认的直接依据;
如果没有文档依据，可以根据类似软件的一般特性来说明是否存在不一致的地方，来确认是否是缺陷;
根据用户的一般使用习惯，来确认是否是缺陷;
与设计人员、开发人员和客户代表等相关人员探讨，确认是否是缺陷;
合理的论述，向测试经理说明自己的判断的理由，注意客观、严谨，不参杂个人情绪。
等待测试经理做出最终决定，如果仍然存在争议，可以通过公司政策所提供的渠道，向上级反映，并有上级做出决定。
2、问：给你一个网站，你如何测试?
首先，查找需求说明、网站设计等相关文档，分析测试需求。
制定测试计划，确定测试范围和测试策略，一般包括以下几个部分：功能性测试;界面测试;性能测试;数据库测试;安全性测试;兼容性测试
设计测试用例：
功能性测试可以包括，但不限于以下几个方面：
链接测试。链接是否正确跳转，是否存在空页面和无效页面，是否有不正确的出错信息返回。
提交功能的测试。
多媒体元素是否可以正确加载和显示。
多语言支持是否能够正确显示选择的语言等。
界面测试可以包括但不限于一下几个方面：
页面是否风格统一，美观
页面布局是否合理，重点内容和热点内容是否突出
控件是否正常使用
对于必须但未安装的控件，是否提供自动下载并安装的功能
文字检查
性能测试一般从以下两个方面考虑：
压力测试;负载测试;强度测试
数据库测试要具体决定是否需要开展。数据库一般需要考虑连结性，对数据的存取操作，数据内容的验证等方面。
安全性测试：
基本的登录功能的检查
是否存在溢出错误，导致系统崩溃或者权限泄露
相关开发语言的常见安全性问题检查，例如SQL注入等
如果需要高级的安全性测试，确定获得专业安全公司的帮助，外包测试，或者获取支持
兼容性测试，根据需求说明的内容，确定支持的平台组合：
浏览器的兼容性;
操作系统的兼容性;
软件平台的兼容性;
数据库的兼容性
开展测试，并记录缺陷。合理的安排调整测试进度，提前获取测试所需的资源，建立管理体系(例如，需求变更、风险、配置、测试文档、缺陷报告、人力资源等内容)。
定期评审，对测试进行评估和总结，调整测试的内容。【推荐了解：软件测试课程】
3、在搜索引擎中输入汉字就可以解析到对应的域名，请问如何用LoadRunner进行测试。
建立测试计划，确定测试标准和测试范围
设计典型场景的测试用例，覆盖常用业务流程和不常用的业务流程等
根据测试用例，开发自动测试脚本和场景：
录制测试脚本：新建一个脚本(Web/HTML协议);点击录制按钮，在弹出的对话框的URL中输入”about:blank”;在打开的浏览器中进行正常操作流程后，结束录制;调试脚本并保存，可能要注意到字符集的关联。
设置测试场景：针对性能设置测试场景，主要判断在正常情况下，系统的平均事务响应时间是否达标;针对压力负载设置测试场景，主要判断在长时间处于满负荷或者超出系统承载能力的条件下，系统是否会崩溃;执行测试，获取测试结果，分析测试结果
4、问：一台客户端有三百个客户与三百个客户端有三百个客户对服务器施压，有什么区别?
300个用户在一个客户端上，会占用客户机更多的资源，而影响测试的结果。线程之间可能发生干扰，而产生一些异常。
300个用户在一个客户端上，需要更大的带宽。
IP地址的问题，可能需要使用IP Spoof来绕过服务器对于单一IP地址最大连接数的限制。
所有用户在一个客户端上，不必考虑分布式管理的问题;而用户分布在不同的客户端上，需要考虑使用控制器来整体调配不同客户机上的用户。同时，还需要给予相应的权限配置和防火墙设置。
5、试述软件的概念和特点?软件复用的含义?构件包括哪些?
软件是计算机系统中与硬件相互依存的另一部分，与计算机系统操作有关的计算机程序、规程、规则，以及可能有的文件、文档及数据。
软件复用(SoftWare Reuse)是将已有软件的各种有关知识用于建立新的软件，以缩减软件开发和维护的花费。软件复用是提高软件生产力和质量的一种重要技术。早期的软件复用主要是代码级复用，被复用的知识专指程序，后来扩大到包括领域知识、开发经验、设计决定、体系结构、需求、设计、代码和文档等一切有关方面。
可以被复用的软件成分一般称作可复用构件
6、软件生存周期及其模型是什么?
软件生存周期(Software life cycle)又称为软件生命期，生存期。是指从形成开发软件概念起，所开发的软件使用以后，知道失去使用价值消亡为止的整个过程。一般来说，整个生存周期包括计划(定义)、开发、运行(维护)三个时期，每个时期又划分为若干个阶段。每个阶段有明确的任务。
周期模型(典型的几种)：
瀑布模型
快速原型模型：快速原型模型允许在需求分析阶段对软件的需求进行初步而非完全的分析和定义，快速设计开发出软件系统的原型，该原型向用户展示待开发软件的全部或部分功能和性能;用户对该原型进行测试评定，给出具体改进意见以丰富细化软件需求;开发人员据此对软件进行修改完善，直至用户满意认可之后，进行软件的完整实现及测试、维护。
迭代模型：迭代包括产生产品发布(稳定、可执行的产品版本)的全部开发活动和要使用该发布必需的所有其他外围元素。在某种程度上，开发迭代是一次 完整地经过所有工作流程的过程：需求分析、设计、实施和测试工作流程。实质上，它类似小型的瀑布式项目。RUP认为，所有的阶段都可以细分为迭代。每一次 的迭代都会产生一个可以发布的产品，这个产品是最终产品的一个子集。
生命周期阶段：
软件计划与可行性分析
需求分析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcc06724923fbb211b6dc73e96458847/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/865978529196d63b4a85f3628dd1ad62/" rel="bookmark">
			网络ip地址划分-子网划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、IP地址划分
1、A类IP地址
2． B类IP地址
3． C类IP地址
4． D类地址用于多点广播（Multicast）
5． E类IP地址
小结
二、ip地址其他说明
1. A类
2. B类
3. C类
各网段保留地址
三、子网划分
第一种：
第二种：
一、IP地址划分 现在的IP网络使用32位地址，以点分十进制表示，如172.16.0.0。地址格式为：IP地址=网络地址＋主机地址。
最初设计互联网络时，为了便于寻址以及层次化构造网络，每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。IP地址根据网络ID的不同分为5种类型，A类地址、B类地址、C类地址、D类地址和E类地址。
IP地址分为A,B,C,D,E五类。
网络号：用于识别主机所在的网络；
主机号：用于识别该网络中的主机。
其中A类分配给政府机关使用，B类地址给大中型企业使用，C类地址给个人使用。这三种是主要的。
IP地址分为五类，A类保留给政府机构，B类分配给中等规模的公司，C类分配给任何需要的人，D类用于组播，E类用于实验，各类可容纳的地址数目不同。
其中A类、B类、和C类这三类地址用于TCP/IP节点，其它两类D类和E类被用于特殊用途。
A、B、C三类IP地址的特征：当将IP地址写成二进制形式时，A类地址的第一位总是O，B类地址的前两位总是10，C类地址的前三位总是110。
1、A类IP地址 一个A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”， 地址范围从1.0.0.0 到126.0.0.0。可用的A类网络有126个，每个网络能容纳1亿多个主机。
⑴ A类地址第1字节为网络地址，其它3个字节为主机地址。
⑵ A类地址范围：1.0.0.1—126.155.255.254
⑶ A类地址中的私有地址和保留地址：
① 10.X.X.X是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地 址）。
② 127.X.X.X是保留地址，用做循环测试用的。
2． B类IP地址 一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255。可用的B类网络有16382个，每个网络能容纳6万多个主机 。
⑴ B类地址第1字节和第2字节为网络地址，其它2个字节为主机地址。
⑵ B类地址范围：128.0.0.1—191.255.255.254。
⑶ B类地址的私有地址和保留地址
① 172.16.0.0—172.31.255.255是私有地址
② 169.254.X.X是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP。
3． C类IP地址 一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围从192.0.0.0到223.255.255.255。C类网络可达209万余个，每个网络能容纳254个主机。
⑴ C类地址第1字节、第2字节和第3个字节为网络地址，第4个个字节为主机地址。另外第1个字节的前三位固定为110。
⑵ C类地址范围：192.0.0.1—223.255.255.254。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/865978529196d63b4a85f3628dd1ad62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1488a02e95f944ec6dabf23a35b82ccc/" rel="bookmark">
			高频丙类谐振功率放大器【Multisim】【高频电子线路】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实验目的与要求
二、实验仪器
三、实验内容与测试结果
1、观察输入、输出波形
2、观察不同工作状态下的集电极电流波形
3、测试负载特性
4、测试集电极调制特性
四、实验结果分析
五、参考资料
一、实验目的与要求 1、通过实验加深理解高频谐振功率放大器电路结构和工作原理
2、通过实验加深理解高频谐振功率放大器工作状态的变化及其特点
3、掌握放大器负载特性和集电极调制特性的测试方法
4、进一步巩固用计算机仿真的实验方法
二、实验仪器 微机，仿真软件Multisim13.0
三、实验内容与测试结果 在Multisim13.0电路窗口中，创建如下图所示仿真电路。
注意器件选型！
交流电源：
晶体管：虚拟的晶体管
图1
1、观察输入、输出波形 对图1，单击仿真按钮，从示波器中观察到的输入输出波形如下：
2、观察不同工作状态下的集电极电流波形 分别选取R1为50%、60%、65%，选择软件Transient analysis（瞬态分析），参数设置如下：Start time:0.02s,End time:0.020005,I(Q1[IC])为输出变量，测试结果如下：
操作步骤：
1.
2.
输出选择I(Q1[IC])
等待波形加载出来 ~_~ 参考课本187、188页，集电极电流脉冲波形
R1 = 50%
R1 = 60%
R1 = 65%
3、测试负载特性 分别选取R1为30%、40%、50%、60%、70%，利用万用表测量输出电压幅度
快速调节滑动变阻器的方法：框选中滑动变阻器，将输入法改为英文状态，然后按A增加滑动变阻器的数值，或者用Shift+A减小滑动变阻器的数值
R1(Ω)
3K
4K
5K
6K
7K
输出电压（V）
7.1
7.465
7.912
8.165
8.27
4、测试集电极调制特性 取R1为65%，采用parameter sweep测量输出电压幅度V(5)随V1(VCC)的变化关系，V1:5V~30V，步长=5V
仿真设置：
1.
2.
3. V(5)是输出电压
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1488a02e95f944ec6dabf23a35b82ccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8676a0d56276e657414b9d32c308a4ac/" rel="bookmark">
			win2016-apache&#43;php&#43;mysql&#43;74CMS环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建apache
修改配置文件：将压缩包解压后，进入conf目录，打开httpd.conf，修改路径如图 测试配置文件：修改后进入bin目录下，输入httpd -t测试配置文件是否合法查看是否成功 安装apache服务：httpd -k install -n Apache2.4 开启apache服务：httpd -k start 关闭为httpd -k stop或者 双击运行解压目录/bin下的ApacheMonitor.exe，点击桌面右下角图标，然后点击start
访问页面：localhost，显示如图，apache安装成功 安装phpstudy，集成apache+php+mysql
下载phpstudy并安装访问页面127.0.0.1，出现php探针 访问10.249.128.180，出现php探针 解压74cms压缩包到phpStudy/WWW/74cms目录下并打开访问本地10.249.128.180/74cms，点击74CMS-&gt;upload 配置：数据库用户名root 密码root
74CMS管理员 admin 密码 admin
安装完成，登陆网址：10.249.128.180/74cms/upload
后台管理 admin/admin
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8546b1c1fbb21f551321bced6ed2b279/" rel="bookmark">
			yocto编译linux社区5.10版本的坎坷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为菜鲲的我，基于meta-intel的bsp进行修改，
精简后的linux-intel_5.10.bb内容如下：
require recipes-kernel/linux/linux-yocto.inc FILESEXTRAPATHS:prepend := "${THISDIR}/linux-intel:" KBRANCH = "master" LINUX_VERSION = "5.10" SRCREV_machine = "2c85ebc57b3e1817b6ce1a6b703928e113a90442" KERNEL_SOURCE_URI = "git:///workdir/smk/GIT_DIR/linux;name=machine;branch=${KBRANCH};protocol=file;" KERNEL_CONFIG_URI = "file://x86_64_defconfig" SRC_URI = " \ ${KERNEL_SOURCE_URI} \ ${KERNEL_CONFIG_URI} \ " PV = "${LINUX_VERSION}+git${SRCPV}" KCONF_BSP_AUDIT_LEVEL = "2" COMPATIBLE_MACHINE ?= "intel-corei7-64" LIC_FILES_CHKSUM = "file://COPYING;md5=6bc538ed5bd9a7fc9398086aedcd7e46" DEPENDS += "elfutils-native openssl-native util-linux-native" 同时需在local.conf指定MACHINE = “intel-corei7-64”
然后，在编译环境下执行bitbake virtual/kernel.
结果报错，
随后查看log.do_compile日志，搜索Error关键字，结果如下
从以上错误信息来看，我并没有发现明确的报错原因（可能我比较菜）。
由于5.10的内核编译没问题，编译命令如下
make ARCH=x86_64 defconfig make ARCH=x86_64 -j40 前面yocto的linux bb文件里的x86_64_defconfig就是上面生成.config，因此我怀疑是内核的问题而不是配置文件，我做了以下尝试验证了我的猜想。
1.替换intel-corei7-64的config，换成其自己（yocto）编译生成的.config，成功！
2.替换intel-corei7-64的config，换成linux社区的x86_64_defconfig，成功！
3.替换intel-corei7-64的kernel的源换成linux-yocto的，成功！
4.替换intel-corei7-64的kernel的源换成linux.org的，失败！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8546b1c1fbb21f551321bced6ed2b279/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc12b40e2d53a80de2287658f32f2a8/" rel="bookmark">
			离散时间傅里叶变换（DTFT）、离散傅里叶变换（DFT）和快速傅里叶变换（FFT）之间的联系和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、离散时间傅里叶变换（DTFT）二、离散傅里叶变换（DFT）三、DTFT和DFT区别的例子四、快速傅里叶变换（FFT）总结 一、离散时间傅里叶变换（DTFT） 在时间连续域中，信号一般用带有时间变量的函数表示，系统则用微分方程表示。在频域中，则使用傅里叶变换或拉普拉斯变换表示。
在时间离散域中，信号一般用序列表示，系统则用差分方程表示。在频域中，则使用序列的傅里叶变换或Z变换表示。
时间连续模拟信号的傅里叶变换会得到连续的频域信号。那么时间离散信号（序列）的傅里叶变换呢？
x ( n ) x(n) x(n)是一个长为M的序列，其离散时间傅里叶变换（DTFT）为：
公式(1)： X ( e j ω ) = D T F T [ x ( n ) ] = ∑ n = − ∞ ∞ x ( n ) e − j ω n X(e^{j\omega})=DTFT[x(n)]=\sum_{n=-\infty}^{\infty}x(n)e^{-j\omega n} X(ejω)=DTFT[x(n)]=∑n=−∞∞​x(n)e−jωn
离散时间傅里叶逆变换为：
公式(2)： x ( n ) = 1 2 π ∫ − π π X ( e j ω ) e j ω n d ω x(n)=\frac{1}{2\pi}\int_{-\pi}^{\pi}X(e^{j\omega})e^{j\omega n}d\omega x(n)=2π1​∫−ππ​X(ejω)ejωndω
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cc12b40e2d53a80de2287658f32f2a8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/146/">«</a>
	<span class="pagination__item pagination__item--current">147/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/148/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>