<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c899cc49264e64f90899336ead319985/" rel="bookmark">
			Spring Boot中进行分库编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Spring Boot中使用分库（Sharding）需要根据具体情况而定。分库是一种解决单数据库性能瓶颈和数据量大的解决方案，通过将数据分散到多个数据库中，可以提升数据库的读写性能和数据存储能力。但是，分库也会带来一些复杂性和额外的开销，如数据一致性、事务管理、数据路由等问题。
以下是一些考虑因素，可以帮助您决定是否在Spring Boot应用程序中使用分库：
数据量大小：如果您的应用程序需要处理大量数据，且单一数据库已经无法满足性能需求，那么分库可能是一个不错的选择。
业务拆分：如果您的业务逻辑可以按照不同的业务模块进行拆分，那么每个模块可以使用自己的数据库，这有助于提升系统的可维护性和扩展性。
读写分离：如果您的应用程序读操作远多于写操作，那么可以考虑使用读写分离的分库方案，将读操作分散到多个数据库中，以提升性能。
数据库特性：不同的数据库有不同的特性和限制，例如MySQL支持事务和行级锁定，而一些NoSQL数据库则更适合于大规模的读操作。因此，您需要选择适合您的应用程序需求的数据库。
开发和维护成本：分库可能会增加开发和维护的复杂性，因为您需要处理数据一致性、事务管理、数据路由等问题。因此，您需要评估分库对开发和维护成本的影响。
总之，是否在Spring Boot应用程序中使用分库需要根据具体情况而定。如果您需要处理大量数据或扩展系统性能，且分库方案能够满足您的需求，那么可以考虑使用分库。但是，您需要充分考虑分库带来的复杂性和额外的开销，并制定相应的解决方案。
在Spring Boot中进行分库编程具有以下优点：
水平扩展：通过分库可以将数据分散到多个数据库中，从而在处理大量数据时提供更好的性能和可扩展性。减轻压力：将数据分散到多个数据库可以平衡查询和写入的负载，使得每个数据库服务器只处理一部分数据，降低了单一服务器的压力。提高容错性：如果某个数据库服务器出现故障，其他数据库服务器仍然可以提供服务，从而提高了系统的容错性和可用性。 然而，分库编程也存在一些弊端：
复杂性增加：分库使得应用程序需要处理多个数据库，这增加了应用程序的复杂性，需要编写更多的代码来处理分库逻辑。数据一致性挑战：分库后，数据分布在不同的数据库中，需要确保数据的一致性和完整性。这需要设计适当的同步机制或事务管理策略。性能问题：分库后，跨数据库的查询和操作可能会变得复杂且性能下降，因为需要连接多个数据库服务器并处理数据聚合等问题。资源管理困难：分库后，每个数据库服务器都需要进行配置和管理，这增加了资源管理的复杂性。 因此，在进行分库编程时，需要根据实际需求和场景权衡利弊，并采取适当的技术和策略来克服弊端，实现高效、稳定、可靠的分库系统。
简单介绍一下
增加了一个工作流的数据库
# 工作流数据源 activity: enabled: true url: jdbc:mysql://localhost:3306/workflow?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8 username: root password: root 然后就可以用dataSource 指定对应的数据库
@Autowired @Qualifier("activityDataSource") private DataSource dataSource; 或者
@DataSource(value=DataSource.ACTIVITY) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29ef19f82b347ced2e9935fc795759c1/" rel="bookmark">
			【驱动序列】C#获取电脑硬件基本组合以及基础信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是全栈小5，欢迎阅读《小5讲堂之知识点实践序列》文章。
这是2024年第7篇文章，此篇文章是C#知识点实践序列文章，博主能力有限，理解水平有限，若有不对之处望指正！
要开发一款驱动小助手，要么首先就是需要了解和输出硬件基本信息，特别是驱动版本，这将是驱动程序是否需要更新重要判断依据。
目录 前言硬件信息输出信息CPU效果代码 显卡效果代码 查询工具 前言 用过驱动软件的小伙伴应该都可以，有一定流量后普通用户下载驱动的速度明显慢了，这个项目很久之前就想着开发一个，
所以就有《驱动序列》文章，此序列文章将会一步一步探索和实现驱动最新版本检查和下载更新等功能。
硬件信息 一台计算机主要由以下几个硬件组成
序号模块描述1中央处理器中央处理器（CPU）：负责执行计算机的指令和处理数据。CPU 是计算机的大脑，决定了计算机的运行速度和性能。2内存内存（RAM）：用于临时存储计算机正在运行的程序和数据。内存的大小直接影响计算机的多任务处理能力和运行效率。3存储设备存储设备（硬盘/固态硬盘）：用于永久存储操作系统、应用程序和用户数据。硬盘通常提供更大的存储容量，而固态硬盘具有更快的读写速度。4显卡显卡（图形处理器）：负责处理图形和图像的计算任务，并将结果显示在显示器上。显卡对于图形处理、游戏和视频编辑等方面至关重要。5主板主板（或称为系统板、基板）：是所有硬件组件的连接和交流枢纽。主板上有各种插槽和接口，用于插入和连接 CPU、内存、显卡、存储设备和其他扩展设备。6电源供应器电源供应器：为计算机提供电力，供各种硬件组件使用。 输出信息 通过窗体软件获取和输出电脑基本的硬件设备信息，包括名称、以及当前驱动版本。
后续文章会针对每个硬件进行细化分析输出详细信息。
CPU 以下是输出中央处理器的信息
效果 代码 // 创建 ManagementObjectSearcher 对象 ManagementObjectSearcher searcher = new ManagementObjectSearcher("select * from Win32_Processor"); // 执行查询并获取结果集 ManagementObjectCollection collection = searcher.Get(); // 遍历结果集并输出 CPU 信息 foreach (ManagementObject obj in collection) { textBox1.AppendText($"处理器: {obj["Name"]}\r\n"); textBox1.AppendText($"制造商: {obj["Manufacturer"]}\r\n"); textBox1.AppendText($"核心数量: {obj["NumberOfCores"]}\r\n"); textBox1.AppendText($"线程数量: {obj["NumberOfLogicalProcessors"]}\r\n"); textBox1.AppendText($"架构: {obj["Architecture"]}\r\n"); textBox1.AppendText($"处理器ID: {obj["Architecture"]}\r\n"); } 显卡 以下是输出显卡的信息
效果 代码 // 获取显卡信息 ManagementObjectSearcher searcher1 = new ManagementObjectSearcher("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29ef19f82b347ced2e9935fc795759c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2855440330e18a9f4997a4e8f1332ed9/" rel="bookmark">
			Oracle和MySQL有哪些区别？从基本特性、技术选型、字段类型、事务、语句等角度详细对比Oracle和MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航：
【Java笔记+踩坑汇总】Java基础+进阶+JavaWeb+SSM+SpringBoot+瑞吉外卖+SpringCloud+黑马旅游+谷粒商城+学成在线+MySQL高级篇+设计模式+面试题汇总+源码_vincewm的博客-CSDN博客
目录
一、基本区别
1.1 基本特性
1.2 Oracle和MySQL如何做技术选型？
1.3 RDBMS和ORDBMS的区别
1.4 默认端口号和用户名
1.5 基本操作
1.5.1 登录方式
1.5.2 修改用户名密码 1.5.3 Oracle解锁账号
1.5.4 Oracle内存优化
1.6 大小写是否敏感
1.6.1 Oracle：双引号下大小写敏感
1.6.2 MySQL：大小写不敏感
二、常用字段类型
2.1 Oracle常用字段类型
2.2 MySQL常用字段类型
三、时间日期
3.1 Oracle
3.2 MySQL
四、创建表空间/数据库
4.1 Oracle创建表空间
4.2 MySQL创建数据库
五、创建临时表
5.1 Oracle创建临时表
5.2 MySQL创建临时表
六、删除表空间/数据库
6.1 Oracle删除表空间
6.2 MySQL删除数据库
七、数据备份恢复
7.1 Oracle导入dmp文件
7.2 MySQL备份迁移
八、创建表和插入记录
8.1 Oracle创建表和插入记录
8.2 MySQL创建表和插入记录
九、事务提交方式
9.1 Oracle：完全支持事务，默认不自动提交
9.2 MySQL：仅innoDB支持事务，默认自动提交
十、分页
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2855440330e18a9f4997a4e8f1332ed9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bff48506c61ef51e8c453c3ffa0168e/" rel="bookmark">
			simulink if 模块用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		if else控制流 这个模块与 If Action Subsystem模块一起用，可完全替代c语言if else语句。
number of inputs-指定输入端口个数，用于if else中判断的变量。
然后将要判断的逻辑按格式填写，然后按填写顺序执行程序。
当u1&gt;0,u2&gt;0的时候，满足u1&gt;0条件，输出为1，下面条件则不进行判断。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f21adb4553f1baea4b8607bc6cb313ec/" rel="bookmark">
			Ef Core花里胡哨系列(11) ef8 无实体查询，你好!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ef Core花里胡哨系列(11) ef8 无实体查询，你好! EF7 引入了返回标量类型的原始 SQL 查询。 这在 EF8 中得到了增强，包括返回任何可映射 CLR 类型的原始 SQL 查询，而无需在 EF 模型中包括该类型。
使用非映射类型的查询是使用 SqlQuery 或 SqlQueryRaw 执行的。 前者使用字符串内插来参数化查询，这有助于确保所有非常量值都被参数化。
var result = _dbContext.Database.SqlQuery&lt;Blog&gt;($"select * from {typeof(Blog).Name}").ToList(); 非常振奋人心的是，SqlQuery的得到的结果是一个IQueryable，也就是说，可以无缝对接Linq!
所以你可以这样，在Sql中直接写上你的条件：
var cutoffDate = new DateOnly(2022, 1, 1); var summaries = await context.Database.SqlQuery&lt;PostSummary&gt;( @$"SELECT b.Name AS BlogName, p.Title AS PostTitle, p.PublishedOn FROM Posts AS p INNER JOIN Blogs AS b ON p.BlogId = b.Id WHERE p.PublishedOn &gt;= {cutoffDate}") .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f21adb4553f1baea4b8607bc6cb313ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5638a34f7fdb2379c0f397f4733870c7/" rel="bookmark">
			Qualcomm® AI Engine Direct 使用手册（18）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qualcomm® AI Engine Direct 使用手册（18） 6.4 分析6.4.1 qnn-量化-检查器（实验）6.4.2 qnn-accuracy-evaluator（实验） 6.4 分析 6.4.1 qnn-量化-检查器（实验） qnn-quantization-checker工具用于分析 qnn-converter 中单个模型文件或模型目录的每个后续层可用的所有可能量化选项的激活、权重和偏差。分析涉及将量化选项的权重、偏差和激活张量与未量化选项进行比较。该工具运行模型来生成浮点激活并分析浮点权重、偏差和激活以确定编码的质量。它最终输出所有量化选项的有问题的权重、偏差和激活张量。
X86-Linux/ WSL Usage: qnn-quantization-checker [--model MODEL_PATH] [--input_list INPUT_LIST_PATH] [--activation_width ACT_BW] [--bias_width BIAS_BW] [--output_dir OUTPUT_DIR_PATH] [--skip_building_model] [--skip_generator] [--skip_runner] [--generate_histogram] [--per_channel_histogram] [--output_csv] --config_file CONFIG_FILE_PATH X86-Windows/ Windows on Snapdragon Usage: python qnn-quantization-checker [--model MODEL_PATH] [--input_list INPUT_LIST_PATH] [--activation_width ACT_BW] [--bias_width BIAS_BW] [--output_dir OUTPUT_DIR_PATH] [--skip_building_model] [--skip_generator] [--skip_runner] [--generate_histogram] [--per_channel_histogram] [--output_csv] --config_file CONFIG_FILE_PATH 所需参数：
–config_file - 配置文件的路径，指定执行所需的所有可能选项。
例如，[RUN_IN_REPAIR_MODE、MODEL_PATH、INPUT_LIST_PATH、ACTIVATION_WIDTH、BIAS_WIDTH、WEIGHT_WIDTH、INPUT_LAYOUT、OUTPUT_DIR_PATH、CLANG_PATH、BASH_PATH、BIN_PATH、PY3_PATH、TENSORFLOW_HOME、TFLITE_HOME、ONNX_HOME、QUANTIZATION_OVERRIDES、 WEIGHT_COMPARISON_ALGORITHMS、BIAS_COMPARISON_ALGORITHMS、ACT_COMPARISON_ALGORITHMS、INPUT_DATA_ANALYSIS_ALGORITHMS、OUTPUT_CSV、GENERATE_HISTOGRAM、QUANTIZATION_VARIATIONS、QUANTIZATION_ALGORITHMS ]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5638a34f7fdb2379c0f397f4733870c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08556554a2cae62ffbc169aa82268f49/" rel="bookmark">
			vue前端表单常用的邮箱、电话、身份证、url、Ip等正则式多语言版校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		utils工具类中创建verify.js
常用表單校驗 //正则校验的正则表达式，这里注意正则表达式中的‘\’要使用‘\\’转义 const patterns = { "name": "^[a-zA-Z_][0-9a-zA-Z_]{0,}$", "phone": "^(13[0-9]|14[5|7]|15[0|1|2|3|4|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$", "tel": "^(0\\d{2,3}-\\d{7,8}(-\\d{1,6})?)$", "email": "^[\\w\\.-]+@[a-zA-Z\\d\\.-]+\\.[a-zA-Z]{2,}$", "pwd": "^(?![0-9]+$)(?![a-z]+$)(?![A-Z]+$)(?!([^(0-9a-zA-Z)]|[\\(\\)])+$)([^(0-9a-zA-Z)]|[\\(\\)]|[a-z]|[A-Z]|[0-9]){8,}$", "ip": "^(?=(\\b|\\D))(((\\d{1,2})|(1\\d{1,2})|(2[0-4]\\d)|(25[0-5]))\\.){3}((\\d{1,2})|(1\\d{1,2})|(2[0-4]\\d)|(25[0-5]))(?=(\\b|\\D))$", "IDCard": "(^\\d{15}$)|(^\\d{17}([0-9]|X)$)", "url": "^https?://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$" } //对应正则表达式的提示信息 const patternMsg_US = { "name": "请以字母、下划线开头并包括数字、字母、下划线组成", "phone": "手機號碼格式不正確", "tel": "電話號碼格式不正確", "email": "郵箱地址不正確", "pwd": "密码至少由8位包含字母、数字、特殊字符两种组合", "ip": "IP地址不正確", "IDCard": "身份證號碼不正確", "url": "鏈接格式不正確" } const patternMsg_CN = { "name": "请以字母、下划线开头并包括数字、字母、下划线组成", "phone": "手机号码格式不正确", "tel": "电话号码格式不正确", "email": "邮箱地址不正确", "pwd": "密码至少由8位包含字母、数字、特殊字符两种组合", "ip": "IP地址不正确", "IDCard": "身份证号码不正确", "url": "链接格式不正确" } const patternMsg_TW = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08556554a2cae62ffbc169aa82268f49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db34cc41a896bcaec32f4580daf71b94/" rel="bookmark">
			Python重温笔记番外篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 写在前面 今天这篇文章是python重温笔记的番外，整理一些面试中的问题以及遇到过的一些坑， 正好借着这个机会把前面的知识进行一个串联， 要不然这些知识很容易就会遗忘， 毕竟知识多而又不太容易常用到。 涉及到的知识包括列表推导式， 高阶函数的使用， 字典排序， 字符串， 日期， 文件遍历， 生成器， 正则， 线程等， 所以还是比较全面的， 以后如果再遇到python方面的练习题的话， 也可以再进行相应的补充。
2. python基础篇 2.1 一行代码生成奇数列表 一行代码生成[1, 2, 5, 7, 9, 11, 13, 15, 17, 19]， 这个考察的是列表推导式， 比较简单
[i for i in range(1, 20) if i % 2 !=0] # [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] 2.2 等差数列 产生一个首项为 10，公差为 12，末项不大于 100 的列表， 这个是列表生成式
# 写一个等差数列 list(range(10, 100, 12)) # [10, 22, 34, 46, 58, 70, 82, 94] 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db34cc41a896bcaec32f4580daf71b94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d392882919ad1548542a5bac8d68e17/" rel="bookmark">
			ReactNative Hooks写法抽离子view
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const itemTop = (itemName: any, itemIcon: any) =&gt; {
return &lt;View style={[$row, $flex1, { padding: 8, backgroundColor: '#f3f6ff', borderRadius: 10, }]}&gt;
&lt;IconFont size={65} name={itemIcon} /&gt;
&lt;View style={[$justifyAround, $flex1, { marginLeft: 20, }]}&gt;
&lt;Text style={[{ textAlign: 'right', color: theme.primary.color }, $fontSize16, $fontWeight]} &gt;99&lt;/Text&gt;
&lt;Text style={[{ textAlign: 'right', color: '#7a869a' }, $fontSize12]}&gt;{itemName}&lt;/Text&gt;
&lt;/View&gt;
&lt;/View&gt;
}
const IItemTop = (info: any) =&gt; {
return &lt;View style={[$row, $flex1, { padding: 8, backgroundColor: '#f3f6ff', borderRadius: 10, }]}&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d392882919ad1548542a5bac8d68e17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc7acaee62f0c5cc2b5f77a993ceeb23/" rel="bookmark">
			Qualcomm® AI Engine Direct 使用手册（17）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qualcomm® AI Engine Direct 使用手册（17） 6.3 执行 6.3 执行 qnn 网络运行
qnn-net-run工具用于使用从 QNN 转换器的输出编译的模型库，并在特定后端上运行它。
DESCRIPTION: ------------ Example application demonstrating how to load and execute a neural network using QNN APIs. REQUIRED ARGUMENTS: ------------------- --model &lt;FILE&gt; Path to the model containing a QNN network. To compose multiple graphs, use comma-separated list of model.so files. The syntax is &lt;qnn_model_name_1.so&gt;,&lt;qnn_model_name_2.so&gt;. --backend &lt;FILE&gt; Path to a QNN backend to execute the model. --input_list &lt;FILE&gt; Path to a file listing the inputs for the network.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc7acaee62f0c5cc2b5f77a993ceeb23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e02da886515150e2a3808aca66a588e0/" rel="bookmark">
			Qualcomm® AI Engine Direct 使用手册（16）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qualcomm® AI Engine Direct 使用手册（16） 6.2 模型准备 6.2 模型准备 量化支持
量化通过转换器接口支持并在转换时执行。启用量化和转换所需的唯一选项是 –input_list 选项，它为量化器提供给定模型所需的输入数据。上面列出的每个转换器都提供以下选项来启用和配置量化：
Quantizer Options: --quantization_overrides QUANTIZATION_OVERRIDES Use this option to specify a json file with parameters to use for quantization. These will override any quantization data carried from conversion (eg TF fake quantization) or calculated during the normal quantization process. Format defined as per AIMET specification. --input_list INPUT_LIST Path to a file specifying the input data. This file should be a plain text file, containing one or more absolute file paths per line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e02da886515150e2a3808aca66a588e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21a7b4379b2ff176ade6f4f1dcc0d2e9/" rel="bookmark">
			Nginx学习之Nginx高性能的实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx学习之Nginx高性能的实现原理
Nginx 采用的是多进程（单线程） &amp; 多路IO复用模型，使用了 I/O 多路复用技术的 Nginx，就成了”并发事件驱动“的服务器，同时使用sendfile等技术，最终实现了高性能。主要从以下几个方面讲述Nginx高性能机制： Nginx master-worker进程机制。
IO多路复用机制。
Accept锁及REUSEPORT机制。
sendfile零拷贝机制
1、Nginx进程机制
1.1、Nginx进程机制概述
许多web服务器和应用服务器使用简单的线程的（threaded）、或基于流程的（process-based）架构， NGINX则以一种复杂的事件驱动（event-driven）的架构脱颖而出，这种架构能支持现代硬件上成千上万的并发连接。
NGINX有一个主进程（master process）（执行特定权限的操作，如读取配置、绑定端口）和一系列工作进程（worker process）和辅助进程（helper process）。如下图所示：
如下所示：
复制代码
service nginx restart Restarting nginx ps -ef --forest | grep nginx root 32475 1 0 13:36 ? 00:00:00 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf
nginx 32476 32475 0 13:36 ? 00:00:00 _ nginx: worker process
nginx 32477 32475 0 13:36 ? 00:00:00 _ nginx: worker process
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21a7b4379b2ff176ade6f4f1dcc0d2e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34736036fc3e7e9f6c8ad8aa31a5333f/" rel="bookmark">
			【软件测试】2024年准备中/高级测试岗技术面试...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、Python编程入门到精通二、接口自动化项目实战三、Web自动化项目实战四、App自动化项目实战五、一线大厂简历六、测试开发DevOps体系七、常用自动化测试工具八、JMeter性能测试九、总结（尾部小惊喜） 前言 1、软件测试基础知识
这一点是一名软件测试员的必备技能，也是最最基础的~
如果你有一年以上的工作经验的话，对这一块一定有比较清晰的认识，当然，在实际的工作中不需要你对每一种测试方法去寻根求源，知道这些方法的含义与应用场景即可。
编写各种测试文档，对于初学者来说稍有难度。但终究还是谈不上什么技术含量，如果对业务和流程足够熟悉，文档用例自然就会写了。
2、测试辅助技能
我发现这两项技能在笔试和面试过程中必考，出现几率超高，但在实际的工作中，有些测试根本碰不到linux ，有些测试不需要去操作数据库。
当然，测试也不能太处于表面了，也需要熟悉熟悉相关测试的表，了解了解系统服务器。
好在这两项技能的要求都不高，linux 大多考几个常用命令，SQL一般考一下增、删、查、改。
3、测试技术
针对高级测试岗位需要一些有针对性的测试技术类问题。
1）例如，针对前端测试岗位，在技术提问上会有针对性地在前端提问，没有自己写过前端程序的人也很难把前端测试做好，html/css/js/Wartir/Selenium/Webdriver等方面的知识必不可少，开源的工具没用过，没有关系，你只要能把类似的思路说清楚也可以。
怎样精准定位web页面上的元素、如何得到这个对象而不是另外一个相同类型的元素、背后原理是怎样的，等等这种有针对性的问题很容易试探出候选人在前端测试方面的技术深度。
2）例如，一个测试工具开发的候选人必须知道框架、工具、平台的区别，框架如何提供接口给业务测试人员使用，哪些是框架要解决的问题哪些是业务测试自己要解决的问题，他们的问题域和解决方案都必须要了如指掌。
3）例如，针对自动化测试，什么情况下适合做自动化？你的自动化测试用例是怎么写的？什么样的用例适合转成自动化？
你是如何来实施的？有什么样的策略来开展自动化工作？你需要自动化在项目中达到一个什么样的预期和效果？只是学学工具，拿个例子练习练习。很难对这些问题有真实的理解。
4）例如，针对性能测试，测试流程是怎样的？你做性能测试的目的是什么？新系统验证？还是旧系统扩容？需要达到一个什么样的预期？在独立的环境可以开展么？压力在哪儿，脚本为什么要这样录制？
你的测试结果真的有知道意义么？或对系统性能做出了合理的评估，或为系统有调优做出指导，或为系统扩容做出了依据。如果前因后果弄不清何必去做呢？
5）类似地，在单元测试、api测试、安全测试、手机测试、后端服务测试、大数据测试等方面，都会有针对性的问题等着你。
相比较代码能力，面试官一般更看中测试技术本身的掌握能力，代码能力只能说明你有潜能，而测试技术是未来会在项目中真实用到的技术，会真正地帮助到测试本身的技术。
4、编程能力
如果是开发人员，那么编程能力是必定会考察的，而且是重点。据我所了解，现在的互联网企业，特别是一些大厂，对现场上机编程甚至白板编程，基本都是必须的。
大多机智的同学也会在简历的必备技能最下方面写上一条，熟悉Python、C语言或其它某种语言。
划重点！如果在编程能力上略懂一二，面试官也会给你加分。
懂编程和不懂编程的人看系统的深度不一样，一点不懂的只能看出来这是按钮，那是输入框。懂编程的就知道你的登录是个&lt;from&gt; ,输入框是个&lt;input&gt; ，你的登录提交是用的post 还是get呢？逻辑层就是获取到输入的用户名密码是查数据库做比较嘛。
在测试过程中不管功能实现也好，bug也好，都会看得更透彻，从而更容易挖掘出相关的bug。
5、工具使用
关于这点，开发工程师对工具的使用熟练程度，面试中问到的几率我不太了解。
但对于测试工程师，特别是性能和自动化岗位，使用什么自动化或者性能测试工具，技术框架如何设计，在面试中就被频频问到。
满大街的招聘要求上都写着“要求熟悉jmeter、LoadRunner、Selenium等自动化测试工具等。”虽然不是每个公司都用的到，但是既然这么多公司有要求，还是有必要学一下这些工具的。
LoadRunner、jmeter做测试必玩工具。没摸过jmeter都不好意思说自己是做测试的。性能测试是必须是要借助工具来实现了。不借助工具如何模拟成百上千的并发？
而且熟练地使用工具可以在日常工作中带来较大的效率提升，这也是不可忽视的作用。
6、其他技能
除了技术以外，沟通能力、团队合作能力、执行力、是否容易相处等性格问题也是面试官额外会考量的！
机会是留给有准备的人的！面试官更多的时候是在找闪光点，我只有一个岗位，在面试的十个人当中，有十个人都能把测试流程什么的说得顺溜（虽然我也只招一个懂测试会流程就行了），有八个人说自己懂LR等工具，只有两个人真正的有自动化或性能测试经验，只有一个人编程方面还不错。你说面试官会选谁呢？
千里马难寻的背后往往是因为伯乐太少。面试的过程就是选择的过程，不仅对于面试官，对于应聘者也是这样，可以通过面试了解岗位的情况，以便做出适合自己的决定。
坦诚，别装，即便你骗过了面试官，在日后的工作中你也骗不了你自己，这对谁都没有好处。公司找合适的人，个人选择适合自己的公司，才能达到双赢！
测试的发展前景：
1）这个行业的发展已经比较成熟，但是测试开发等高端人才缺口巨大；
2）入门的确容易，但不断提升技术才是重中之重，安于现状终将被淘汰；
3）就业机会多，因为公司产品迭代快，个人技术能力增长也快；
4）学习成本不是很大，相比来说，时间和资金都比开发要少很多。
下面是我整理的2023年最全的软件测试工程师学习知识架构体系图 一、Python编程入门到精通 二、接口自动化项目实战 三、Web自动化项目实战 四、App自动化项目实战 五、一线大厂简历 六、测试开发DevOps体系 七、常用自动化测试工具 八、JMeter性能测试 九、总结（尾部小惊喜） 只有敢于追求梦想，勇于拼搏奋斗，才能创造出自己想要的人生。不要放弃，坚持到底，你就是那个勇往直前，最终成功的人！
人生的路上，会有风雨雷电，但只要你心怀坚定的目标和不屈的意志，就能闪耀出无尽的勇气与智慧，最终登上成功的巅峰，创造令人瞩目的传奇！
每一次努力都是你离成功更近一步，不要停下脚步，不要放弃梦想。相信自己，战胜困难，你将成就无限可能，创造属于自己的辉煌人生！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35f89213463a25881b5d74f81a332798/" rel="bookmark">
			C&#43;&#43;11的新特性大总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++在线编译工具，可快速进行实验: https://www.bejson.com/runcode/cpp920/
1. 写在前面 这段时间， 差不多把C++的基础内容重新过了一遍，后面会利用零碎的时间，再把一些C++的重要新内容给过一下， 因为随着时代的发展， C++也与时俱进， 迭代更新， 这个过程中可绕不开C++11的标准，这个可以看做是C++的一次重大升级，其实这个我还是在实习期间接触的，在之前，我对C++的认识，依然是停留在老版本上，直到实习的时候，看到自动类型推导，智能指针，Lambda表达式等， 也不禁心里一惊，“好酷炫”，C++原来还可以这样玩， 才意识到之前的C++认知有点落伍了， 而落伍的核心原因，竟然不知道C++11的存在!!!
所以呢？ 想集中通过一篇文章，来特地整理C++11的新特性，内容依然是参考C语言中文网， 关于具体细节，依然是去这里看吧。 另外， 还有一点值得提一下，就是C++11的新特性， 有时候面试还会考到， 尤其是面试官看到简历上是熟悉C++的时候 😉
这篇文章依然会很长，因为我基于上面链接的知识， 摘出了重点，并对一些产生疑问的知识查缺补漏和做了一些实验，但为了方便后面查，我依然放一块，然后通过标题区分开， 所以，老规矩，各取所需即可 😉
主要内容:
C++11标准是个啥？C++11的自动类型推导(auto VS decltype， C++11返回值类型后置)C++11使用using定义别名C++11支持函数模板的默认模板参数C++11在函数模板和类模板中使用可变参数C++11 tuple元组C++11 列表初始化C++11 lambda匿名函数C++11 非受限联合体(union)C++11的for循环C++11的constexprC++11的右值引用C++11移动构造函数的功能和用法C++11引用限定符C++11完美转发及实现C++11的指针系列(nullptr, shared_ptr, unique_ptr, weak_ptr) Ok, let’s go!
2. C++11标准是个啥？ 这里得追溯到1983年， 在那时候， C++之父Bjarne Stroustrup把"带类的C"正式叫做"C++"， 这时候的C++， 在C语言的基础上加入面向对象的思想，除了具备C语言的所有功能，还具有类，继承，内联函数，虚函数，引用等等。
在1998年的时候， C++标准委员会发布了第一版C++标准，就是C++98标准(C++代码编写规范)， 然后C++就开始迭代更新， 直到2020年， C++发展历经3个标准：
2011年， 新的C++11标准诞生，用于取代C++98标准， 此标准还有别名，叫"C++ 0x"2014年，C++14标准发布，该标准对C++11标准做了更优的修改和更新2017年底， C++17标准正式颁布 上面3个标准， C++11是最颠覆性的， 在C++98的基础上修正了600多个C++语言存在的缺陷，增加了140多个新特性， 使得C++语言焕然一新，所以在C++98的基础上，孕育了一个全新的C++， 可以看成C++新的开始，这也是为啥C++11重要的原因。
3. C++11的自动类型推导(auto VS decltype) 3.1 C++的auto类型推导 在C++11的版本里面，定义变量或声明变量之前，必须指明类型，比如int, char等，但像一些灵活语言，比如python，在定义变量的时候，是不用指明具体类型的，而是编译器自动推导，这会非常方便。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35f89213463a25881b5d74f81a332798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cae7d9036ec90a9cf50a9543ce543fa/" rel="bookmark">
			计算机网络 综合(习题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【计算机网络习题】系列文章目录 计算机网络 第一章 绪论(习题) 计算机网络 第二章 计算机网络体系结构(习题) 计算机网络 第三章 应用层(习题) 计算机网络 第四章 运输层(习题) 计算机网络 第五章 网络层(习题)
计算机网络 第六章 数据链路层(习题) 计算机网络 第七章 物理层(习题) 计算机网络 第八章 局域网(习题) 计算机网络 综合(习题) 第 1 章 绪论 1-1 填空题 最早的计算机网络是（ ARPANET ）。电话网络采用（ 电路 ）交换技术，计算机网络采用（ 分组 ）交换技术。（ TCP/IP ）协议是 Internet 事实上的标准协议。分组交换技术的核心是（ 存储转发 ）。分组由（首部 ）和数据组成。根据所采用的传输技术的不同，计算机网络可以分为（ 广播式 ）网络和（ 点对点 ）网络。根据网络规模大小不同，计算机网络可以分为（局域网 ）、（ 城域网 ）和（广域网 ）。因特网标准常以（ RFC ）文档的形式发布。实现数据交换的三种技术分别是（ 电路交换）、（ 报文交换）和（ 分组交换 ）。 1-2 选择题 有关虚电路和数据报，正确的是（ B ）。
A．数据报方式中，每个分组一定走同样的路到达目的地
B．虚电路方式中，分组首部中存放虚电路号
C．数据报方式中，需要建立连接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cae7d9036ec90a9cf50a9543ce543fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852504322b2efa5d16af012de57adbce/" rel="bookmark">
			C&#43;&#43;重温笔记(十): C&#43;&#43;输入输出流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 写在前面 c++在线编译工具，可快速进行实验: https://www.bejson.com/runcode/cpp920/
这段时间打算重新把c++捡起来， 实习给我的一个体会就是算法工程师是去解决实际问题的，所以呢，不能被算法或者工程局限住，应时刻提高解决问题的能力，在这个过程中，我发现cpp很重要， 正好这段时间也在接触些c++开发相关的任务，所有想借这个机会把c++重新学习一遍。 在推荐领域， 目前我接触到的算法模型方面主要是基于Python， 而线上的服务全是c++(算法侧， 业务那边基本上用go)，我们所谓的模型，也一般是训练好部署上线然后提供接口而已。所以现在也终于知道，为啥只单纯熟悉Python不太行了， cpp，才是yyds。
和python一样， 这个系列是重温，依然不会整理太基础性的东西，更像是查缺补漏， 不过，c++对我来说， 已经5年没有用过了， 这个缺很大， 也差不多相当重学了， 所以接下来的时间， 重温一遍啦 😉
资料参考主要是C语言中文网和光城哥写的C++教程，然后再加自己的理解和编程实验作为辅助，加深印象，当然有些地方我也会通过其他资料进行扩充。 关于更多的细节，还是建议看这两个教程。
今天这篇文章整理C++关于输入和输出的操作，也就是我们所熟知的"流"操作， 我发现学习哪个语言，都需要学习它的I/O操作， 毕竟这是我们读数据和写数据的前提呀， C++也不例外，通常，我们在C++中使用cin输入流实现数据输入， cout输出流实现数据输出(输入和输出流本质上是已经定义好的类对象), 但是， 这只是流里面的冰山一小小角， 其实C++输入流和输出流不仅实现基本的输入输出操作， 通过类内部成员函数， 还可以满足特殊场景的输入输出需求， 这又是一个很长很长的故事…
主要内容:
C++输入流和输出流C++输出单个字符(put)和字符串(write)C++的tellp和seekp方法详解C++ cout的格式化输出C++输入输出重定向C++管理输出缓冲区C++读取单个字符(get)和读入字符串(getline)C++跳过指定字符(ignore)及查看输入流中的下一个字符(peek)C++ cin如何判断输入结束？C++处理输入输出错误小总 Ok, let’s go!
2. C++输入流和输出流 C语言有一套完成数据读写的解决方案:
scanf()、gets()等函数从键盘读取数据， printf()、puts()等向屏幕输出数据fscanf()、fgets()等函数读取文件中数据，fprintf()、fputs()向文件写入数据 这套I/O方案在C++也同样适用，不过C++还独立开发了一套全新I/O解决方案， 这套解决方案是我们所说的"流类"组成的类库。 整个流类以及它们的关系如下:
这些流类的功能也可以见名知意:
istream: 接收从键盘输入的数据ostream: 数据输出到屏幕ifstream: 读文件中的数据ofstream: 向文件写数据iostream: istream和ostream类功能合体，既可以从键盘输入，也可以输出到屏幕fstream: ifstream和ofstream类功能合体，既能读取文件数据，又能向文件写数据 之前学习的cin是istream对象， cout是ostream对象， 它们都声明在&lt;iostream&gt;中。除了cout, 头文件中还声明了2个对象，叫做cerr和clog， 它们用法和cout一样，只不过cerr常用来输出警告和错误信息， clog常用来输出程序执行中的日志信息。区别如下:
cout除了可以将数据输出到屏幕，还可以通过重定向，实现数据输出到指定文件； 而cerr和clog不支持重定向，只能将数据输出到屏幕cout和clog都有缓冲区， 它们输出数据时， 会先将数据放到缓冲区，等缓冲区满或手动换行时(换行符\n)，才会将数据全部显示到屏幕；cerr没有缓冲区，会直接将数据输出到屏幕。 其他的，这哥仨无不同。
std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/852504322b2efa5d16af012de57adbce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f8a5656a23b2f27e1ee9335875488f3/" rel="bookmark">
			java.lang.UnsupportedOperationException: null 怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 报错原因： Arrays.asList()返回的是不可修改列表集合，不能进行修改操作，如果进行add()操作就会报错； 2. 解决方案： （1）转换为可以修改的集合类型
通过ArrayList的构造器，将Arrays.asList(strArray)的返回值由java.util.Arrays.ArrayList转为java.util.ArrayList。 如：
// 创建数组
Integer[] arr = {1,2,3,4};
// 转换集合
List&lt;Integer&gt; list = Arrays.asList(arr);
// 转换为可以修改的集合类型
list = new ArrayList&lt;&gt;(list);
list.add(5);
System.out.println(list);
（2）不使用Arrays.asList(strArray)进行转换即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc459aef6ec965c3c6b515794beeee2e/" rel="bookmark">
			记一次使用mpvue开发微信小程序动画播放播放完成再播放下一个动画，实现动画队列的实战操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序wxss支持Css的keyframes动画，我们想通过事件监听，在动画开始、动画播放阶段、动画播放结束的时候进行下一步动作。如下图，有一个从右飘入，然后从左侧出去的动画，我们希望的是，前一个出去后，后一个再进入，即上一个播放完成后，再出来下一个
这个时候，解决问题的关键问题在于，监听上一个动画播放完成，这个时候，我们需要用到微信小程序的动画播放完成后的事件，
为此，我们将流程逻辑描述如下：
数据格式:
flbox:{itemlist:[],playing:false};//我们有一个这样的数据格式，其中itemlist用来存放要播放的队列，其中每一项item:{}可以为任意自己想要的，但里面必须要有一个st_start:true/false,用来控制，是否开始播放动画。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67db66194ea380cee9b7ff379494f6e7/" rel="bookmark">
			微服务之间互相调用出现的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：
微服务A调用微服务B的接口，微服务B的接口请求方式是get类型，传递的参数是JSON格式。 错误：
1、postman：springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize value of type `java.util.ArrayList&lt;com.cechds.diagnosis.domain.OnlineRegisterScheduleDetail&gt;` from Object value (token `JsonToken.START_OBJECT`);
2、微服务B：
心路历程：
1、我找了请求方式的问题，发现一点毛病没有，都是get请求，但是为啥微服务B中报错的原因尽然是请求方式不支持POST。
2、看了postman给我的报错原因，我也核实了请求参数是否传递有问题，最后发现也没毛病。
当我准备放弃时，向打开chat问一问它时，我就想既然你有报错时不支持POST请求，那我就把所有的请求方式改一下，都改成POST。最后启动项目，postman测试，发现通了。
然后，我冷静分析了一波……最后我明白了：出现问题的根本原因就是GET和POST请求方式的不同以及服务器和客户端对请求方式支持的程度不同导致的。
POST和GET的区别：
1、常规的设计原则是使用 GET 请求用于获取资源，而 POST 请求用于创建资源；
2、GET 请求通常用于查询，而查询参数通常会附加在 URL 上，而不是在请求体中传递 JSON 数据。因此，GET 请求通常不用于传递复杂的结构化数据，例如 JSON；
3、POST 请求通常用于在服务器上创建新资源，并且可以在请求体中传递复杂的结构化数据，例如 JSON。这种设计符合 RESTful 架构的原则，即使用不同的 HTTP 方法来表示不同的操作。
虽然 HTTP 规范并没有明确规定 GET 请求不能包含请求体，但是在实际应用中，许多服务器和客户端的实现对 GET 请求体的支持不够完善，可能导致一些不一致性和问题。在微服务之间进行 HTTP 调用时，通常建议遵循 RESTful 设计原则，并根据不同的操作选择适当的 HTTP 方法。如果需要传递数据，尤其是结构化数据，POST 请求通常被认为是更合适的选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e42ccb3bb8292cbcc9fa1a1c6f8dc56/" rel="bookmark">
			easycode 插件配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		easycode是一个idea生成文件的插件，以下是我的一个项目中配置信息，需要的可以拿走，保存成json文件导入即可
{ "author" : "XXX", "version" : "1.2.8", "userSecure" : "", "currTypeMapperGroupName" : "Default", "currTemplateGroupName" : "MybatisPlus", "currColumnConfigGroupName" : "Default", "currGlobalConfigGroupName" : "Default", "typeMapper" : { "Default" : { "name" : "Default", "elementList" : [ { "matchType" : "REGEX", "columnType" : "varchar(\\(\\d+\\))?", "javaType" : "java.lang.String" }, { "matchType" : "REGEX", "columnType" : "char(\\(\\d+\\))?", "javaType" : "java.lang.String" }, { "matchType" : "REGEX", "columnType" : "(tiny|medium|long)*text", "javaType" : "java.lang.String" }, { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e42ccb3bb8292cbcc9fa1a1c6f8dc56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/597d96900577c60e4a199e10aa2a9a8b/" rel="bookmark">
			【学生特惠|权威主办】2024年地理科学与遥感技术国际学术会议(ICGSRST 2024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【学生特惠|权威主办】2024年地理科学与遥感技术国际学术会议(ICGSRST 2024)
2024 International Conference Geographic Science and Remote Sensing Technology(ICGSRST 2024)
一、【会议简介】
我们非常荣幸地邀请您参加2024年地理科学与遥感技术国际学术会议（ICGSRST 2024）。本次会议旨在为地理科学和遥感技术领域的专家、学者和从业人员提供一个交流和探讨最新研究成果、技术和应用的平台。
二、【征稿主题】主题包括但不限于以下
地理地质信息化
自然地理
固体地球物理学
地理信息技术的应用
城市地理
空间物理学
地球探测与信息技术
乡村地理
地球化学
地质结构
大地测量学
地质灾害预测、评估、控制
海洋地理
地质学
地球探测与信息技术
水文地理
水文学
地理信息系统
建设地理
海洋科学
全球导航卫星系
测绘
技术与方法
遥感(RS)
光学遥感
微波遥感
大气环境遥感
行星遥感与测图
地理信息科学
遥感信息工程
空间数据库
地球监测与制图
空间技术与景观
图像处理技术
高光谱影像处理
遥感数据融合
遥感数据质量
遥感模式分析
三、【重要信息】
投稿邮箱：iac_info@163.com
投稿时请邮箱正文备注：论文投稿+苏老师推荐+投稿人姓名
最终截稿时间：请查看官网
接受/拒稿：投稿后2-3日内通知
四、【论文提交】
1. 文章需全英文，重复率低于30%。
2. 文章必须要有题目、作者、单位、邮箱、关键词、摘要、必要的图表、结论、参考文献等。
3. 投稿流程：投稿→审稿→录用→注册→开具增值税普票（专票）→电子版→纸质版→检索。
4. 请勿一稿多投，所有稿件将接受两三名专家进行评审
五、【联系我们】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/597d96900577c60e4a199e10aa2a9a8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc80db1e70d4b8e072784d5e334393d9/" rel="bookmark">
			LLM微调框架学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 Xtuner：“只需8G显存即可微调7B模型” 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/702930f21c39ebadff2b6366a4c7126e/" rel="bookmark">
			简述C语言中为什么要用指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言中，指针的使用是非常重要的，主要由于以下几个原因：
直接访问内存：指针允许程序直接访问和操作内存。这使得程序能够与硬件直接交互，提供了对底层数据结构的更精细控制，这在系统编程中尤其重要。
提高程序效率：使用指针可以减少数据复制的需要，从而提高程序的效率。例如，通过传递指向大型数据结构的指针（而不是整个结构的副本）给函数，可以减少内存使用和处理时间。
动态内存分配：在C语言中，使用指针可以动态地在运行时分配和释放内存。这对于创建灵活大小的数据结构（如链表、树等）和处理不确定大小的输入非常重要。
数组和字符串处理：指针在处理数组和字符串时非常有用。在C中，字符串实际上是字符数组，通常通过字符指针来操作。数组名本身在大多数上下文中退化为指向其第一个元素的指针，这使得使用指针遍历数组变得很自然。
实现复杂的数据结构：指针是实现链表、树、图等复杂数据结构的基础。这些结构在许多高级算法和系统中都有广泛应用。
函数指针：指针还可以用来指向函数。这允许动态地选择要调用的函数，使得程序更加灵活和模块化。
参考传递：虽然C语言中的函数参数是通过值传递的，但可以通过传递指针来实现引用传递。这样，函数能够修改其外部变量的值。
综上所述，指针是C语言中一个强大且灵活的工具，它为编程提供了广泛的可能性，特别是在性能优化、内存管理和低级编程方面。然而，指针的使用也需要小心，因为错误的指针操作可能导致内存泄露、无效内存访问和其他难以追踪的问题。
通俗举例 直接访问内存
想象你住在一个巨大的公寓楼里，每个房间都有一个独特的门牌号。在这个比喻中，每个房间代表内存中的一个存储位置，门牌号就像是内存地址。指针就像是一张包含门牌号的纸条；它告诉你怎么找到那个房间。没有指针，你就不知道要去哪个房间。提高程序效率
假设你是一个快递员，需要递送一个非常重的包裹。你可以选择两种方式：一是把整个包裹带到收件人那里，二是仅仅告诉收件人包裹所在的仓库和位置。在这个例子中，直接搬运整个包裹类似于在函数中传递整个数据副本，而提供位置信息类似于使用指针。显然，提供位置信息更加高效。动态内存分配
想象你正在组织一场聚会，但你不确定有多少人会来。使用指针和动态内存分配，就像是你有能力根据需要增加或减少聚会空间的大小。如果更多的人来了，你可以扩大空间；如果很少人来，你可以减小空间。这样你就不需要一开始就确定空间的大小。数组和字符串处理
将指针用于数组和字符串，就像是你有一张包含一系列地点的地图。地图上的每个点都是一个地点（在数组中是一个元素），而你可以通过沿着地图移动来访问不同的地点。实现复杂的数据结构
指针用于构建复杂的数据结构，如链表或树，就好比是在建立一系列的路线图，其中每个点都可以引导你到另一个点。例如，在链表中，每个元素都知道下一个元素的位置（地址），就像是一个接一个的导航点。函数指针
函数指针的使用就像是你有一个包含不同服务电话号码的通讯录。根据你需要的服务类型，你可以选择拨打不同的号码。在程序中，这意味着你可以根据需要选择调用不同的函数。引用传递
最后，使用指针进行引用传递就像是你给朋友一个装有文件的USB闪存驱动器。你的朋友可以直接在这个USB上编辑文件，而你回家后就可以看到这些更改。这就是指针允许函数修改外部变量的方式。 不用指针会怎样 效率降低：不使用指针意味着在函数调用时需要复制整个数据结构，而不是仅传递其地址。对于大型结构（如大型数组或复杂的数据结构），这会导致显著的性能下降，因为复制数据需要更多时间和内存。
功能限制：指针使得能够动态分配内存，这对于处理不确定大小的数据或构建某些类型的数据结构（如链表、树等）至关重要。不使用指针将无法有效实现这些功能。
无法直接修改函数外部的数据：在C语言中，默认情况下函数参数是通过值传递的，意味着函数内部对参数的修改不会影响到原始数据。没有指针，你就不能让函数直接修改其外部的变量或数据结构。
字符串和数组操作变得复杂：在C语言中，字符串本质上是通过字符指针处理的。没有指针，字符串和数组的操作会更加复杂和不直观。
内存管理受限：指针允许更精确和灵活的内存管理，比如分配、重分配和释放内存。不使用指针会使得这些操作变得困难或不可能。
高级编程模式受限：诸如函数指针之类的高级编程模式允许更灵活的代码结构，例如回调函数和动态函数调用。没有指针，这些模式将无法实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a919c04e56fa837228eaad13f249820/" rel="bookmark">
			Java的编码方式、单个char类型存储大部分中文字符、getBytes()、new String()的转换流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 编码种类
1.1 ASCII码
1.2 ISO8859-1编码
1.3 GBK编码
1.4 Unicode字符集
1.4.1 UTF-8编码
1.4.2 UTF-16编码
1.4.3 UTF-32编码
二 Java编码方式
2.1 内码、外码
2.2 单个char类型能存储大部分(BMP范围内)中文
2.3 String：字符个数和char数组长度的误区
2.4 getBytes()方法的转换流程
2.5 new String(字节数组，编码方式)方法的转换流程
2.6 System.out.println
一 编码种类 先了解下市面上的编码方式的相关知识点，为后面学习打好基础。
1.1 ASCII码 上个世纪60年代，美国制定了一套字符编码，对英文字符与二进制位之间的关系，做了统一规定，这被称为 ASCII码，一直沿用至今。
ASCII码 采用单字节编码，一共规定了128个字符的编码，其编码范围是 [0x00 , 0x7F]，这128个符号(包括了33个不能打印出来的控制字符或通信专用字符等)，只占用了一个字节的后面7位，最前面的1位统一规定为0。
0-31、127是控制字符或通信专用字符，如换行、回车、删除等。32-126是打印字符，可以通过键盘输入并且能够显示出来。 比如空格"SPACE"是32(二进制：0010 0000)，大写的字母A是65(二进制：0100 0001)。
ASCII 的编码表可以参考ASCII_百度百科
用128个符号编码便可以表示所有英文字符，但是用来表示其他语言，128个符号是不够的。比如在法语中，字母上方有注音符号，它就无法用 ASCII码 表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号，例如 ISO-8859-1编码，可以表示最多256个符号。 但是这里又出现了新的问题，不同的国家有不同的字母。因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语的编码中代表了é，在希伯来语的编码中却代表了字母Gimel (ג)，在俄语的编码中又会代表另一个符号。
但是不管怎样，所有这些编码方式中，[0 , 127]表示的符号是一样的，都是英文字符，不一样的只是[128 , 255]的这一段。
1.2 ISO8859-1编码 ISO-8859-1编码 采用单字节编码，向下兼容 ASCII 码，利用字节中闲置的最高位编入新的符号，其编码范围是 [0x00 , 0xFF]，[0x00 , 0x7F]的编码和 ASCII码 一致，[0x80 , 0x9F]是控制字符，[0xA0 , 0xFF]是文字符号，此字符集支持部分于欧洲使用的语言。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a919c04e56fa837228eaad13f249820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51475c794f1df4b62c801ea7f4a791c2/" rel="bookmark">
			苹果电脑菜单栏应用管理软件Bartender 4 mac软件特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bartender mac是一款可以帮助用户更好地管理和组织菜单栏图标的 macOS 软件。它允许用户隐藏和重新排列菜单栏图标，从而减少混乱和杂乱。
Bartender mac软件特点
菜单栏图标隐藏：Bartender 允许用户隐藏菜单栏图标，只在需要时显示。这样可以减少菜单栏的拥挤和视觉干扰，使界面更加整洁和专注。
可自定义的菜单栏排序：用户可以自定义菜单栏图标的顺序和位置。Bartender 提供了直观的拖放界面，让您轻松地重新排列图标，以适应个人喜好和工作流程。
快速访问隐藏图标：即使将图标隐藏，用户仍然可以轻松找到和访问它们。Bartender 提供了一个额外的菜单栏图标，通过点击它，用户可以访问所有隐藏的图标。
额外的菜单栏图标位置：Bartender 还提供了扩展的菜单栏图标位置，称为第二级菜单栏。用户可以将少使用的图标放在第二级菜单栏中，以进一步减少菜单栏的拥挤。
自动隐藏：用户可以设置菜单栏图标在一段时间没有使用时自动隐藏。这有助于节省菜单栏空间，并提供更多的可视区域。
总体而言，Bartender 是一款功能强大且易于使用的工具，可以帮助 macOS 用户更好地管理菜单栏图标。它提供了隐藏、重新排列和自定义菜单栏图标的选项，从而提高界面的整洁和用户体验。无论您是对菜单栏的视觉整洁性有要求，还是需要管理大量菜单栏图标，Bartender 都是一个有用的工具。
软件安装地址：Bartender 4 for Mac(菜单栏应用管理软件) v4.2.25中文版
Windows软件下载：StartAllBack(win11开始菜单增强工具)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc50bc6d1a50e8a60783630623c16e86/" rel="bookmark">
			Wargames与bash知识08
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Wargames与bash知识08 上篇文章知识简单的介绍一下“瑞士军刀”nc，下面就尝试做一些详细的讲解和演示：
1、使用nc打开并监测端口，执行端口接受到的Linux 命令。演示环境：windows wls2的linux子系统：ubuntu。左边终端执行 nc -l -p 8000 |bash -k -v；监听端口8000并且打开一个bash子进程；右边终端发送ls -l命令；左边终端顺利执行命令、显示结果。
2、传送文件：
3、聊天（ctrl+c退出）
4、扫描端口
gyj@guyanjun:~/nc$ nc -v -z 192.168.0.102 22 Connection to 192.168.0.102 22 port [tcp/ssh] succeeded! gyj@guyanjun:~/nc$ nc -v -z bandit.labs.overthewire.org 2220 Connection to bandit.labs.overthewire.org 2220 port [tcp/*] succeeded! Bandit Level 15 关卡提示：
可以通过使用SSL加密将当前级别的密码提交到localhost上的端口30001来检索下一级别的密码。
推荐命令：
ssh, telnet, nc, openssl, s_client, nmap
SSL SSL（安全套接层）连接是一种安全协议，用于在网络上传输数据时提供数据加密和身份验证功能。通过使用SSL连接，可以确保数据在传输过程中被加密，并且只有预期的接收者才能解密和读取数据。此外，SSL连接还可以验证服务器的身份，以确保与正确的服务器建立连接，而不是被中间人攻击者拦截。
在SSL连接中，客户端和服务器之间需要进行双向身份验证，以及协商加密算法和密钥交换等参数。一旦连接建立，客户端和服务器就可以使用加密算法对数据进行加密和解密，以确保数据的机密性和完整性。
SSL连接广泛应用于互联网上的各种应用程序，如Web浏览器、电子邮件、在线银行和其他需要高度安全性的数据传输场景。许多应用程序和协议都支持通过SSL连接来保护数据的传输，例如HTTP over SSL（HTTPS）、POP over SSL（POPS）和IMAP over SSL（IMAPS）等。
OpenSSL OpenSSL 是一个强大的安全套接层(SSL)和传输层安全(TLS)协议的开源实现，它支持多种加密算法，包括对称加密、非对称加密和哈希算法等。OpenSSL 提供了一系列的工具和库，用于创建和管理证书、生成密钥、测试SSL/TLS服务器和客户端等。
OpenSSL 的主要功能包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc50bc6d1a50e8a60783630623c16e86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e8bd12a87b7d0d5f1c1de1f35b66b23/" rel="bookmark">
			Flutter用GridView实现网格功能（1、item设置一个外边框，2、item背景点击变色，松开恢复原色）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GridView接收如下可选参数属性：
scrollDirection：滚动方法padding：内边距resolve：组件反向排序crossAxisSpacing：水平子Widget之间间距mainAxisSpacing：垂直子Widget之间间距crossAxisCount：一行的Widget数量childAspectRatio：子Widget宽高比例children：gridDelegate：控制布局主要用在GridView.builder里面 实现代码，我不说多
1、网格数据，我选择的是七个数据：图标和对应它的小标题
import 'package:flutter/material.dart'; List listData = [ { "title": "信息列表1", "author": 'Mohamed Chahin', // "imageUrl": 'https://www.itying.com/images/flutter/1.png', // "imageUrl": 'images/json.png', "imageUrl": Icons.account_tree_rounded, }, { "title": '信息列表2', "author": 'Mohamed Chahin', // "imageUrl": 'https://www.itying.com/images/flutter/1.png', // "imageUrl": 'images/statistics.png', "imageUrl": Icons.ad_units_rounded, }, { "title": '信息列表3', "author": 'Mohamed Chahin', // "imageUrl": 'https://www.itying.com/images/flutter/1.png', // "imageUrl": 'images/statistics.png', "imageUrl": Icons.adb, }, { "title": '信息列表4', "author": 'Mohamed Chahin', // "imageUrl": 'https://www.itying.com/images/flutter/1.png', // "imageUrl": 'images/statistics.png', "imageUrl": Icons.add_alert_sharp, }, { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e8bd12a87b7d0d5f1c1de1f35b66b23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16632498b7714cf4f15a836594814376/" rel="bookmark">
			IntelliJ IDEA 常用快捷键 Windows版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 IDEA快捷键默认支持两种，一种是从熟悉Eclipse开发工具转到IDEA过来的开发这，一种就是操作系统默认的，例如WIndwos就是Default copy，Eclipse就是Eclipse copy，Mac的话就是另外的一套了，这里总结一下WIndwos系统默认的IDEA快捷键，基本都是从网上借鉴过来的，方便高效率的开发和调试，方便我们快速的Coding。
一、coding过程实用快捷键 Ctrl+Alt+M： 将某段代码提取为私有方法 二、IntelliJIDEA_ReferenceCard官方提供快捷键文档 IntelliJIDEA_Reference：
https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf
Windows系统
Mac系统
三、Ctrl 快捷键介绍Ctrl + F在当前文件进行文本查找 （必备）Ctrl + R在当前文件进行文本替换 （必备）Ctrl + Z撤销 （必备）Ctrl + Y删除光标所在行 或 删除选中的行 （必备）Ctrl + X剪切光标所在行 或 剪切选择内容Ctrl + C复制光标所在行 或 复制选择内容Ctrl + D复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）Ctrl + W递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围Ctrl + E显示最近打开的文件记录列表（必备）Ctrl + N根据输入的 类名 查找类文件Ctrl + G在当前文件跳转到指定行处Ctrl + J插入自定义动态代码模板Ctrl + P方法参数提示显示Ctrl + Q光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容Ctrl + U前往当前光标所在的方法的父类的方法 / 接口定义Ctrl + B进入光标所在的方法/变量的接口或是定义出，等效于 Ctrl + 左键单击Ctrl + K版本控制提交项目，需要此项目有加入到版本控制才可用Ctrl + T版本控制更新项目，需要此项目有加入到版本控制才可用Ctrl + H显示当前类的层次结构（必备）Ctrl + O选择可重写的方法（必备）Ctrl + I选择可继承的方法，接口需要实现的方法（必备）Ctrl + +展开代码（必备）Ctrl + -折叠代码（必备）Ctrl + /注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）Ctrl + [移动光标到当前所在代码的花括号开始位置Ctrl + ]移动光标到当前所在代码的花括号结束位置Ctrl + F1在光标所在的错误代码出显示错误信息Ctrl + F3调转到所选中的词的下一个引用位置Ctrl + F4关闭当前编辑文件Ctrl + F8在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点Ctrl + F9执行 Make Project 操作Ctrl + F11选中文件 / 文件夹，使用助记符设定 / 取消书签Ctrl + F12弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选Ctrl + Tab编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口Ctrl + Enter智能分隔行Ctrl + End跳到文件尾Ctrl + Home跳到文件头Ctrl + Space基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备）Ctrl + Delete删除光标后面的单词或是中文句Ctrl + BackSpace删除光标前面的单词或是中文句Ctrl + 1,2,3…9定位到对应数值的书签位置Ctrl + 左键单击在打开的文件标题上，弹出该文件路径Ctrl + 光标定位按 Ctrl 不要松开，会显示光标所在的类信息摘要Ctrl + 左方向键光标跳转到当前单词 / 中文句的左侧开头位置Ctrl + 右方向键光标跳转到当前单词 / 中文句的右侧开头位置Ctrl + 前方向键等效于鼠标滚轮向前效果Ctrl + 后方向键等效于鼠标滚轮向后效果 四、Alt 快捷键介绍Alt + `显示版本控制常用操作菜单弹出层Alt + Q弹出一个提示，显示当前类的声明 / 上下文信息Alt + F1显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择Alt + F2对于前面页面，显示各类浏览器打开目标选择弹出层Alt + F3选中文本，逐个往下查找相同文本，并高亮显示Alt + F7查找光标所在的方法 / 变量 / 类被调用的地方Alt + F8在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果Alt + Home定位 / 显示到当前文件的 Navigation BarAlt + EnterIntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备）Alt + Insert代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等（必备）Alt + 左方向键按左方向切换当前已打开的文件视图（必备）Alt + 右方向键按右方向切换当前已打开的文件视图（必备）Alt + 前方向键当前光标跳转到当前文件的前一个方法名位置（必备）Alt + 后方向键当前光标跳转到当前文件的后一个方法名位置（必备）Alt + 1,2,3…9显示对应数值的选项卡，其中 1 是 Project 用得最多 五、Shift 快捷键介绍Shift + F1如果有外部文档可以连接外部文档Shift + F2跳转到上一个高亮错误 或 警告位置Shift + F3在查找模式下，查找匹配上一个Shift + F4对当前打开的文件，使用新Windows窗口打开，旧窗口保留Shift + F6对文件 / 文件夹 重命名Shift + F7在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法Shift + F8在 Debug 模式下，跳出，表现出来的效果跟 F9 一样Shift + F9等效于点击工具栏的 Debug 按钮Shift + F10等效于点击工具栏的 Run 按钮Shift + F11弹出书签显示层Shift + Tab取消缩进Shift + ESC隐藏当前 或 最后一个激活的工具窗口Shift + End选中光标到当前行尾位置Shift + Home选中光标到当前行头位置Shift + Enter开始新一行。光标所在行下空出一行，光标定位到新行位置Shift + 左键单击在打开的文件名上按此快捷键，可以关闭当前打开文件Shift + 滚轮前后滚动当前文件的横向滚动轴滚动 六、Ctrl + Alt 快捷键介绍Ctrl + Alt + L格式化代码，可以对当前文件和整个包目录使用 （必备）Ctrl + Alt + O优化导入的类，可以对当前文件和整个包目录使用 （必备）Ctrl + Alt + I光标所在行 或 选中部分进行自动代码缩进，有点类似格式化Ctrl + Alt + T对选中的代码弹出环绕选项弹出层Ctrl + Alt + J弹出模板选择窗口，讲选定的代码加入动态模板中Ctrl + Alt + H调用层次Ctrl + Alt + B在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口（必备）Ctrl + Alt + V快速引进变量Ctrl + Alt + Y同步、刷新Ctrl + Alt + S打开 IntelliJ IDEA 系统设置（必备）Ctrl + Alt + F7显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来Ctrl + Alt + F11切换全屏模式Ctrl + Alt + Enter光标所在行上空出一行，光标定位到新行Ctrl + Alt + Home弹出跟当前文件有关联的文件弹出层Ctrl + Alt + Space类名自动完成Ctrl + Alt + 左方向键退回到上一个操作的地方 （必备）**（注意与其他软件快捷键冲突）**Ctrl + Alt + 右方向键前进到上一个操作的地方 （必备）**（注意与其他软件快捷键冲突）**Ctrl + Alt + 前方向键在查找模式下，跳到上个查找的文件Ctrl + Alt + 后方向键在查找模式下，跳到下个查找的文件 七、Ctrl + Shift 快捷键介绍Ctrl + Shift + F根据输入内容查找整个项目 或 指定目录内文件 （必备）Ctrl + Shift + R根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备）Ctrl + Shift + J自动将下一行合并到当前行末尾 （必备）Ctrl + Shift + Z取消撤销 （必备）Ctrl + Shift + W递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）Ctrl + Shift + N通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）Ctrl + Shift + U对选中的代码进行大 / 小写轮流转换 （必备）Ctrl + Shift + T对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 （必备）Ctrl + Shift + C复制当前文件磁盘路径到剪贴板 （必备）Ctrl + Shift + V弹出缓存的最近拷贝的内容管理器弹出层Ctrl + Shift + E显示最近修改的文件列表的弹出层Ctrl + Shift + H显示方法层次结构Ctrl + Shift + B跳转到类型声明处 （必备）Ctrl + Shift + I快速查看光标所在的方法 或 类的定义Ctrl + Shift + A查找动作 / 设置Ctrl + Shift + /代码块注释 （必备）Ctrl + Shift + [选中从光标所在位置到它的顶部中括号位置 （必备）Ctrl + Shift + ]选中从光标所在位置到它的底部中括号位置 （必备）Ctrl + Shift + +展开所有代码 （必备）Ctrl + Shift + -折叠所有代码 （必备）Ctrl + Shift + F7高亮显示所有该选中文本，按Esc高亮消失 （必备）Ctrl + Shift + F8在 Debug 模式下，指定断点进入条件Ctrl + Shift + F9编译选中的文件 / 包 / ModuleCtrl + Shift + F12编辑器最大化 （必备）Ctrl + Shift + Space智能代码提示Ctrl + Shift + Enter自动结束代码，行末自动添加分号 （必备）Ctrl + Shift + Backspace退回到上次修改的地方 （必备）Ctrl + Shift + 1,2,3…9快速添加指定数值的书签 （必备）Ctrl + Shift + 左键单击把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备）Ctrl + Shift + 左方向键在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 （必备）Ctrl + Shift + 右方向键在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 （必备）Ctrl + Shift + 前方向键光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 （必备）Ctrl + Shift + 后方向键光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 （必备） 八、Alt + Shift 快捷键介绍Alt + Shift + N选择 / 添加 task （必备）Alt + Shift + F显示添加到收藏夹弹出层 / 添加到收藏夹Alt + Shift + C查看最近操作项目的变化情况列表Alt + Shift + I查看项目当前文件Alt + Shift + F7在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入Alt + Shift + F9弹出 Debug 的可选择菜单Alt + Shift + F10弹出 Run 的可选择菜单Alt + Shift + 左键双击选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 （必备）Alt + Shift + 前方向键移动光标所在行向上移动 （必备）Alt + Shift + 后方向键移动光标所在行向下移动 （必备） 九、Ctrl + Shift + Alt 快捷键介绍Ctrl + Shift + Alt + V无格式黏贴 （必备）Ctrl + Shift + Alt + N前往指定的变量 / 方法Ctrl + Shift + Alt + S打开当前项目设置 （必备）Ctrl + Shift + Alt + C复制参考信息 十、其他 快捷键介绍F2跳转到下一个高亮错误 或 警告位置 （必备）F3在查找模式下，定位到下一个匹配处F4编辑源 （必备）F7在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中F8在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内F9在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上F11添加书签 （必备）F12回到前一个工具窗口 （必备）Tab缩进 （必备）ESC从工具窗口进入代码文件窗口 （必备）连按两次Shift弹出 Search Everywhere 弹出层 十一、IDEA调试快捷键（必掌握） 快捷键介绍F8单步调试。一行行往下走，不进入函数内部F7单步调试。一行行往下走，进入函数内部Shift+F7选择要进入的函数Shift+F8跳出函数Alt+F9运行到断点Alt+F8执行表达式查看结果F9继续执行，进入下一个断点或执行完程序Ctr+F8设置/取消当前行断点Ctr+Shift+F8查看断点soutc快捷生成System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16632498b7714cf4f15a836594814376/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0881468d93cab38601131bef605fdc81/" rel="bookmark">
			LeetCode-数组-双指针-中等难度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 双指针1. 删除有序数组中的重复项（入门）1.1 题目描述1.2 解题思路1.3 代码实现 2. 删除有序数组中的重复项 II（简单）2.1 题目描述2.2 解题思路2.3 代码实现 3. 移动零（简单）3.1 题目描述3.2 代码实现 4. 两数之和（入门）4.1 题目描述4.2 解题思路4.3 代码实现 5. 盛水最多的容器（中等）5.1 题目描述5.2 解题思路5.3 代码实现 6. 三数之和（中等）6.1 题目描述6.2 解题思路6.3 代码实现 7. 最接近的三数之和（中等）7.1 题目描述7.2 解题思路7.3 代码实现 8. 接雨水（中等）8.1 题目描述8.2 解题思路8.3 代码实现 双指针 双指针一般是指利用两个变量，通过在线性的结构上进行遍历来解决某些特定的问题，按照遍历的方式一般多采用：同向遍历，相向遍历两种方式，例如冒泡排序、选择排序、插入排序都是用了两个变量同向遍历来实现，快排则是通过相向遍历来实现。
1. 删除有序数组中的重复项（入门） 1.1 题目描述 1.2 解题思路 快慢指针的简单应用
1.3 代码实现 public int removeDuplicates(int[] nums) { int n = nums.length; int p1 = 0; int p2 = 1; while (p2 &lt; n) { if (nums[p1] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0881468d93cab38601131bef605fdc81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/858a7482de63b2125c0166012685faec/" rel="bookmark">
			MATLAB对数据的处理（导入，异常处理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB对数据的处理 文章目录 MATLAB对数据的处理1、MATLAB导入数据导入的范围导入类型 2、MATLAB处理缺失值和异常值 1、MATLAB导入数据 最常用的就是导入excel表格数据，主页选项卡-导入数据-选择excel文件。
导入的范围 导入数据的范围默认是从第二行开始的，第一行—般是标题行。如果不想导入所有数据，可以按住ctrl键，选择想导入的内容，例如某行、某列。“变量名称行"也就是导入之后，matlab里表格最上方会显示变量，一般默认选择原文件第一行。但是只能识别英文，如果是汉字则变成"VerName"。 导入类型 “输出类型"决定了导入的数据以什么类型存储。一般选择表。如果选择"数值矩阵”，那么所有字符串都变成NaN，反之亦然。
选择的选项导入数据的方式列向量将所选数据的每一列导入为单个m×1向量。数值矩阵将所选数据导入为m×n数值数组。其余类型可以缺省，删除。字符串数组将所选数据导入为m×n字符串数组。其余类型可以缺省，删除。元胞数组将所选数据导入为可包含多种数据类型的元胞数组。表将所选数据导入为表。（什么类型都可以保存） 注意，导入后数据在工作区。关闭matlab后数据消失。如果想保存数据的话，记得保存工作区文件！
2、MATLAB处理缺失值和异常值 清理缺失数：
实时编辑器 --&gt;选择任务—&gt;清理缺失数据
但是这个功能是在2019b以及之后的版本才有。
首先，先写一组包含缺失值和异常值的例子
x = 1 : 100;%构造一个数组，元素为1，2，3，.......108 %randn(1,10日)意味着生成一个1行1ee列的矩阵 %矩阵元素的均值为e，方差o^2 = 1，且是正态分布的随机数 data = randn(1,100) ; data(20:20:80)= NaN;%设置第2e，40，6e，80个元素为缺失值 % data的值都是在e附近的，设置4个异常值 data(10) = -50; data(40) = 45; data(70) = -40; data(90) = 50; plot(x,data) 原本的数据：
在MATLAB中（在实时编辑器中才有这个功能，不然就将文件用实时编辑器的方式打开）：
这样，数据里面的NaN数据就被清理了，选择里面的线性插值和压条插值都可以或其他选项。（原先的位置就被线性插值计算出来的数据替换掉了）。
同样，在任务中可以选择清理离群数据来将异常的值（我们带上面的代码中是手动设置的）进行清理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7c4679c1e86915b05996a2daf91b78a/" rel="bookmark">
			rtsp超分推流流程(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下rtsp 推流的流程 播放一个RTSP的流需要如下的RTSP请求命令：
OPTIONS -&gt; DESCRIBE -&gt; SETUP -&gt; PLAY 然后就是接收RTP包、播放了
抓包分析出来，推流的RTSP请求命令如下：
OPTIONS -&gt; ANNOUNCE -&gt; SETUP -&gt; RECORD
可以使用ffmpeg命令来模拟一路视频和音频推流，
ffmpeg -re -stream_loop -1 -i abc.mkv -rtsp_transport tcp -c copy -f rtsp rtsp://127.0.0.1:8554/stream
udp 推流 OPTIONS rtsp://192.168.0.135:8554/stream RTSP/1.0
CSeq: 1
User-Agent: Lavf60.16.100
RTSP/1.0 200 OK
CSeq: 1
Public: DESCRIBE, ANNOUNCE, SETUP, PLAY, RECORD, PAUSE, GET_PARAMETER, TEARDOWN
Server: gortsplib
ANNOUNCE rtsp://192.168.0.135:8554/stream RTSP/1.0
Content-Type: application/sdp
CSeq: 2
User-Agent: Lavf60.16.100
Content-Length: 500
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7c4679c1e86915b05996a2daf91b78a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004695feb749d776f423e93a8069c4b6/" rel="bookmark">
			MATLAB基本绘图操作（二维和三维绘图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB基本绘图操作 文章目录 MATLAB基本绘图操作1、二维平面绘图1.1、线条（折线图）1.2、条形图1.3、极坐标图1.4、散点图 2、三维立体绘图2.1、三维曲面图2.2、三维曲线图（点图） 3、图片分区（子图） 1、二维平面绘图 1.1、线条（折线图） x=0:0.01:2*pi; %从09开始，每次递增0.01，一直到2*pi结束 y = sin(x) ; figure %建立一个幕布 plot(x, y) %绘制二维的平面图 %若(x,y ,'Linewidth',2)可变粗，后面的数字参数用来调整线条的粗细 %plot(x, y1，x，y2) %设置两个图在同一块幕布下 title('y = sin(x)') %标题 xlabe1('x') %x轴的标签 ylabe1('sin(x)') %y轴的标签 xlim([0 2*pi]) %将绘图的x轴限制设置为介于0和2*pi之间 grid on %添加网格 axis([0 20 -1.5 1.5]) %用来设置横纵坐标的范围，x：0~20 y：-1.5~1.5 执行结果： 设置颜色，线条风格等： x = 0:0.01:20; y1 = 200*exp (-0.05*x).*sin(x); y2 = 0.8*exp (-0.5*x).*sin(10*x); figure [AX, H1, H2] = plotyy(x, y1,x, y2, 'plot'); %plotyy是公用一个坐标系，并在y上面有不同的取值，两条线 set(get(AX(1),’Ylabel'), 'String', 'Slow Decay') set(get(AX(2),'Ylabel'), 'String','Fast Decay') xlabel('Time (\musec)') title(' Multiple Decay Rates') set (H1, 'LineStyle','--') %设置H1线的风格设置为虚线 set (H2, 'LineStyle',':') %冒号线，更多样式请参考下面的表 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/004695feb749d776f423e93a8069c4b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a1fcca74b4e300230edd73205558cd/" rel="bookmark">
			Apache 网页优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技能目标：
掌握 Apache 网页压缩掌握 Apache 网页缓存掌握Apache 隐藏版本信息掌握 Apache 网页防盗链 1.1网页压缩与缓存 在使用 Apache 作为 Web 服务器的过程中，只有对 Apache 服务器进行适当的优化配 置才能让 Apache 发挥出更好的性能。反过来说，如果 Apache 的配置非常糟糕， Apache 可能无法常为我们服务。因此，针对各种企业应用需求对 Apache 服务器的配置进行一定 的优化是必不可少的。
1.1.1 网页压缩 网站的访问速度是由多个因素所共同决定的，这些因素包括应用程序的响应速度、网络带宽、服务器性能、与客户端之间的网络传输速度等等。其中最重要的一个因素是 Apache本身的响应速度。因此当为网站性能所苦恼时，第一个需要着手进行处理的便是尽可能的提升 Apache 的执行速度，可以使用网页压缩提升应用程序的速度。更重要的是，它完全不需要任何的成本，只不过是会让服务器 CPU 占用率稍微提升一两个百分点或者更少。
1.gzip介绍 gzip 是一种流行的文件压缩算法，目前应用非常广泛，尤其是在 Linux 平台。当使用gzip 压缩一个纯文本文件时，效果是非常明显的，大约可以减少 70 ％以上的文件大小。利用 Apache 中的 gzip 模块，可以使用 gzip 压缩算法来对 Apache 服务器发布的网页内容进行压缩后再传输到客户端浏览器。经过压缩后，实际上降低了网络传输的字节数，最明显的好处就是可以加快网页加载的速度。
网页加载速度加快的好处不言而喻。除了节省流量，改善用户的浏览体验外，另一个潜 在的好处是 gzip 与搜索引擎的抓取工具有着更好的关系。
2.HTTP压缩的过程 Web 服务器接收到浏览器的 HTTP 请求后，检查浏览器是否支持 HTTP 压缩（Accept-Encoding 信息）。如果浏览器支持 HTTP 压缩， Web 服务器检查请求文件的后缀名。如果请求文件是 HTML 、 CSS 等静态文件， Web 服务器到压缩缓冲目录中检查是否已经存在请求文件的最新压缩文件。如果请求文件的压缩文件不存在，Web 服务器向浏览器返回未压缩的请求文件，并在压缩缓冲目录中存放请求文件的压缩文件。如果请求文件的最新压缩文件已经存在，则直接返回请求文件的压缩文件。如果请求文件是动态文件，Web服务器动态压缩内容并返回浏览器，压缩内容不存放到压缩缓存目录中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93a1fcca74b4e300230edd73205558cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d64f470fd6d637897fac57f4a5bea39/" rel="bookmark">
			C语言中一些基本数据类型的典型大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		char：通常是1字节。表示一个字符。int：通常在现代系统中是4字节（但这取决于编译器和架构，有时可能是2字节）。float：通常是4字节。double：通常是8字节。short 和 short int：通常是2字节。long：在32位系统上通常是4字节，在64位系统上可能是8字节。long long：通常是8字节。unsigned 类型（如 unsigned int）：大小通常与对应的有符号类型相同。 对于指针类型，大小取决于系统的地址空间：
指针（例如 int* 或 char*）：在32位系统上通常是4字节，在64位系统上通常是8字节。 #include &lt;stdio.h&gt; int main() { printf("Size of char: %zu bytes\n", sizeof(char)); printf("Size of int: %zu bytes\n", sizeof(int)); printf("Size of float: %zu bytes\n", sizeof(float)); printf("Size of double: %zu bytes\n", sizeof(double)); printf("Size of short: %zu bytes\n", sizeof(short)); printf("Size of long: %zu bytes\n", sizeof(long)); printf("Size of long long: %zu bytes\n", sizeof(long long)); printf("Size of int pointer: %zu bytes\n", sizeof(int*)); // getchar(); return 0; } Size of char: 1 bytes Size of int: 4 bytes Size of float: 4 bytes Size of double: 8 bytes Size of short: 2 bytes Size of long: 4 bytes Size of long long: 8 bytes Size of int pointer: 4 bytes 注：在这个例子中，%zu是用于size_t类型的格式说明符，它是sizeof运算符返回的类型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ebe0bf66cf3213805878391f1c2c64d/" rel="bookmark">
			CF1909_C. Heavy Intervals题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CF1909_C. Heavy Intervals题解 题目传送门（Problem - C - CodeforcesCodeforces. Programming competitions and contests, programming communityhttps://codeforces.com/contest/1909/problem/C）。
题目翻译如下：（图片来源：洛谷）
这题已经出的很直了……可能也有暴力做法，大家可以尝逝，我直接将数论方法。
先给亿点前置芝士（排序不等式）：
通俗来讲，就是对于两个有序序列，顺序之积之和大于等于乱序之积之和大于逆序之积之和。
我都知道你们在想什么，下面来到了大家喜闻乐见的Ctrl+C/V环节，AC Code走起！
#include&lt;bits/stdc++.h&gt;
#define N 110000
using namespace std;
multiset&lt;int&gt;tl={};
int a[N]={},c[N]={},l[N]={},r[N]={},n=0,t=0;
int main(){
scanf("%d",&amp;t);
while(t--){
scanf("%d",&amp;n);
tl.clear();
for(int i=1;i&lt;=n;i++){
scanf("%d",&amp;l[i]);
tl.insert(l[i]);
}
for(int i=1;i&lt;=n;i++){
scanf("%d",&amp;r[i]);
}
for(int i=1;i&lt;=n;i++){
scanf("%d",&amp;c[i]);
}
sort(r+1,r+1+n);
for(int i=1;i&lt;=n;i++){
auto id=tl.lower_bound(r[i]);
id--;
a[i]=r[i]-(*id);
tl.erase(id);
}
sort(a+1,a+1+n);
sort(c+1,c+1+n);
long long ans=0;
for(int i=1;i&lt;=n;i++){
ans+=a[i]*1LL*c[n-i+1];
}
printf("%lld\n",ans);
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ebe0bf66cf3213805878391f1c2c64d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d91d2ec0535de09495af33f4ffbe44c/" rel="bookmark">
			char、char*和char**
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言中，char**表示一个指向字符指针的指针。这通常用于表示一个字符串数组，其中每个字符串本身也是一个字符指针。
char：基本的数据类型，用于存储单个字符。 #include &lt;stdio.h&gt; int main() { char ch = 'A'; // 定义一个字符变量并初始化为 'A' printf("The character is %c\n", ch); // 打印字符 return 0; } char*：字符指针，通常用于指向一个字符串（即字符数组）。在C语言中，字符串是以空字符（\0）结尾的字符数组。 #include &lt;stdio.h&gt; int main() { char* str = "Hello, World!"; // 定义一个指向字符串的指针 printf("The string is %s\n", str); // 打印字符串 return 0; } char**：指向字符指针的指针。这可以被视为指针的数组，其中每个指针指向一个char数组（或字符串）。因此，它通常用来表示一个字符串数组 #include &lt;stdio.h&gt; void printStrings(char** strings, int num) { for (int i = 0; i &lt; num; ++i) { printf("%s\n", strings[i]); // 打印每个字符串 } } int main() { char* arr[] = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d91d2ec0535de09495af33f4ffbe44c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9afeda9f9050832b661006b37bdefb22/" rel="bookmark">
			【React系列】React中的CSS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来自#React系列教程：https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg5MDAzNzkwNA==&amp;action=getalbum&amp;album_id=1566025152667107329)
一. React中的css方案 1.1. react 中的 css 事实上，css 一直是 React 的痛点，也是被很多开发者吐槽、诟病的一个点。
在组件化中选择合适的CSS解决方案应该符合以下条件：
可以编写局部css：css具备自己的具备作用域，不会随意污染其他组件内的原生；可以编写动态的css：可以获取当前组件的一些状态，根据状态的变化生成不同的css样式；支持所有的css特性：伪类、动画、媒体查询等；编写起来简洁方便、最好符合一贯的css风格特点；等等… 在这一点上，Vue做的要远远好于React：
Vue通过在.vue文件中编写 &lt;style&gt;&lt;style&gt; 标签来编写自己的样式；通过是否添加 scoped 属性来决定编写的样式是全局有效还是局部有效；通过 lang 属性来设置你喜欢的 less、sass等预处理器；通过内联样式风格的方式来根据最新状态设置和改变css；等等… Vue在CSS上虽然不能称之为完美，但是已经足够简洁、自然、方便了，至少统一的样式风格不会出现多个开发人员、多个项目采用不一样的样式风格。
相比而言，React官方并没有给出在React中统一的样式风格：
由此，从普通的 css，到 css modules，再到 css in js，有几十种不同的解决方案，上百个不同的库；大家一致在寻找最好的或者说最适合自己的CSS方案，但是到目前为止也没有统一的方案； 在这篇文章中，我会介绍挑选四种解决方案来介绍：
方案一：内联样式的写法；方案二：普通的css写法；方案三：css modules；方案四：css in js（styled-components）； 1.2. 普通的解决方案 1.2.1. 内联样式 内联样式是官方推荐的一种css样式的写法：
style 接受一个采用小驼峰命名属性的 JavaScript 对象，而不是 CSS 字符串；并且可以引用state中的状态来设置相关的样式； export default class App extends PureComponent { constructor(props) { super(props); this.state = { titleColor: "red" } } render() { return ( &lt;div&gt; &lt;h2 style={{color: this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9afeda9f9050832b661006b37bdefb22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e71d0aeff978bd8c285bafb1cb66d158/" rel="bookmark">
			图像识别的技术前沿：人工智能与机器学习的融合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像识别的技术前沿在于人工智能（AI）与机器学习（ML）的融合。这种融合使得图像识别系统能够从大量数据中自动学习并识别出各种模式，从而在复杂和动态的环境中实现更高的准确性和鲁棒性。
机器学习在图像识别中发挥着越来越重要的作用。传统的图像识别方法通常依赖于手工制作的特征提取和特征匹配，而机器学习则通过训练神经网络自动学习图像中的特征，并做出准确的分类或识别。深度学习，特别是卷积神经网络（CNN），已经在图像识别领域取得了突破性的成果。通过训练大量的图像数据，深度学习模型能够自动提取出对识别任务最有用的特征，并且可以在不同的尺度和角度下进行识别，提高了识别的准确性和鲁棒性。
人工智能和机器学习的融合还表现在自适应学习和自学习能力上。自适应学习是指系统能够根据不同的任务和环境自动调整其参数和行为，以实现最佳的性能。自学习能力则是指系统能够在没有人为干预的情况下，通过自我学习和经验积累来提高其性能。这种自适应和自学习能力使得图像识别系统能够更好地应对各种复杂和动态的场景，提高其实用性和可靠性。
此外，随着云计算、大数据和边缘计算技术的发展，图像识别的技术前沿也在不断扩展。云计算为海量数据的存储和处理提供了强大的支持，使得训练更大规模的深度学习模型成为可能。大数据则为模型的训练提供了足够多的样本数据，使得模型能够更好地学习和泛化。边缘计算则将计算和数据处理的能力从中心服务器扩展到了设备边缘，使得实时图像识别成为可能，满足了低延迟和高可靠性的要求。
总的来说，人工智能与机器学习的融合以及云计算、大数据和边缘计算技术的发展，正在推动图像识别技术的不断进步。未来，随着技术的不断创新和完善，图像识别的准确性和可靠性将进一步提高，应用场景也将更加广泛和深入。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d166711987054ef61867ebf3f5c8e9e/" rel="bookmark">
			【开题报告】基于微信小程序的母婴商品仓库管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.选题背景 随着社会经济的发展和家庭生活水平的提高，母婴商品市场逐渐兴起。然而，传统的母婴商品仓库管理方式存在着许多问题，如信息不透明、操作繁琐等。为了提高仓库管理的效率和准确性，基于微信小程序的母婴商品仓库管理系统应运而生。
传统的母婴商品仓库管理通常采用人工或Excel等手动方式进行，存在着许多弊端。例如，人工操作容易出错，数据不够实时、准确；Excel等电子表格虽然可以提高管理效率，但功能有限，无法满足企业的各类需求。此外，母婴商品具有一定的时效性，需要及时管理和处理，否则容易造成商品积压或缺货等情况，影响企业的经营效益。
因此，设计和实现基于微信小程序的母婴商品仓库管理系统，可以有效解决传统仓库管理方式存在的问题，提高管理效率和准确性，满足企业的各类需求，提升竞争力。同时，微信小程序作为一种便捷、实时的移动应用程序，也能够为用户提供更好的使用体验。
2.选题意义 基于微信小程序的母婴商品仓库管理系统的设计与实现具有以下几点研究意义：
（1）提高仓库管理效率：传统的母婴商品仓库管理方式往往需要人工操作或使用电子表格进行记录，操作繁琐且容易出错。而基于微信小程序的仓库管理系统可以通过自动化和信息化的方式，提高仓库管理的效率，减少人为操作的错误。
（2）实现信息的实时性和准确性：微信小程序具有实时通信和数据更新的特点，可以实时反馈仓库中的商品信息、库存情况等重要数据，帮助企业及时掌握最新的仓库状态，做出及时的决策。
（3）提升用户体验和便捷性：基于微信小程序的仓库管理系统可以随时随地通过手机进行访问和操作，用户无需安装额外的应用程序，提供了更便捷的使用体验。同时，系统的界面可以根据用户习惯和需求进行定制，提高用户的满意度。
（4）数据分析和决策支持：基于微信小程序的仓库管理系统可以提供实时的数据分析功能，帮助企业了解库存情况、销售趋势等关键信息，为企业管理者提供决策支持，优化仓库运营和供应链管理。
（5）推动企业数字化转型：随着信息技术的不断发展，企业数字化转型已成为发展的趋势。基于微信小程序的仓库管理系统可以作为企业数字化转型的重要组成部分，帮助企业实现信息化、智能化管理，提升企业竞争力。
（6）为母婴商品行业提供创新解决方案：母婴商品行业具有一定的特殊性，对商品的时效性和品质要求较高。基于微信小程序的仓库管理系统可以为母婴商品行业提供定制化的解决方案，满足行业的特殊需求，促进行业的发展和进步。
综上所述，基于微信小程序的母婴商品仓库管理系统的设计与实现具有重要的研究意义和实际应用价值，可以提高仓库管理的效率和准确性，推动企业数字化转型，为母婴商品行业提供创新解决方案。
3.研究现状 目前，基于微信小程序的母婴商品仓库管理系统的研究和实践已经取得了一些进展。以下是相关领域的研究现状：
（1）系统设计与功能：研究者们对基于微信小程序的仓库管理系统进行了系统设计和功能规划。他们提出了合理的架构设计、数据库设计和系统功能模块划分，以满足母婴商品仓库管理的需求。
（2）数据管理与处理：研究者们致力于解决仓库管理中的数据管理与处理问题。他们采用了多种技术手段，如数据库管理系统、数据挖掘和大数据分析等，以实现对商品信息、库存数据等重要数据的管理和分析。
（3）用户体验和界面设计：研究者们注重用户体验和界面设计，提出了一些可行的解决方案。他们通过优化界面设计、增加用户交互功能等方式，提高了用户的满意度和使用便捷性。
（4）移动端技术应用：研究者们将移动端技术应用于基于微信小程序的仓库管理系统中。他们利用微信小程序的实时通信和数据更新能力，实现了仓库信息的实时反馈和操作，提高了管理效率和准确性。
（5）数据安全与隐私保护：研究者们重视数据安全和隐私保护问题，并提出了一些相应的解决方案。他们采用了数据加密、权限控制和用户认证等措施，保障了系统中重要数据的安全性和合规性。
4.研究内容和方法 基于微信小程序的母婴商品仓库管理系统的设计与实现涉及多个方面的研究内容和方法。以下是一些研究内容和常用方法的介绍：
（1）系统需求分析：首先需要对母婴商品仓库管理的需求进行深入分析。通过与用户、企业管理者等相关方进行沟通和访谈，了解他们的具体需求和问题，明确系统的功能需求和性能要求。
（2）系统架构设计：根据需求分析的结果，进行系统架构的设计。可以采用分层结构、模块化设计等方式，将系统划分为不同的模块，明确各个模块之间的关系和功能。
（3）数据库设计与管理：设计和管理数据库是系统设计的重要一环。根据需求，设计合适的数据模型和表结构，建立适当的数据库，存储和管理商品信息、库存数据等重要数据。常用的数据库管理系统包括MySQL。
（4）用户界面设计：针对微信小程序的特点，进行用户界面的设计。考虑用户的使用习惯和操作习惯，设计简洁、易用的界面，提供直观的操作方式和良好的用户体验。
（5）数据处理与分析：对仓库中的商品信息、库存数据等进行处理和分析。可以使用数据挖掘、大数据分析等技术，提取有用的信息，为企业管理者提供决策支持。
（6）系统实现与测试：根据设计的架构和功能，进行系统的实现和测试。使用微信小程序开发工具和相应的编程语言（如JavaScript），开发系统的前端和后端功能，并进行功能测试和性能测试。
（7）安全性与隐私保护：确保系统的安全性和用户隐私的保护。采用数据加密、权限控制、用户认证等方式，加强系统的安全性，保护用户的隐私。
5.可行性分析 基于微信小程序的母婴商品仓库管理系统的设计与实现，在技术上是可行的，具有一定的优势和潜力。以下是可行性分析的具体内容：
（1）技术可行性：微信小程序开发工具已经相对成熟，并且提供了完善的API接口，可以方便地实现网页展示、数据处理和跨平台通信等功能。同时，微信小程序还具有轻量级、快速响应等特点，适合于母婴商品仓库管理系统这种需要频繁操作的场景。
（2）商业可行性：随着社会经济的发展和人们生活水平的提高，母婴市场的需求不断增加。建立一个基于微信小程序的母婴商品仓库管理系统，可以提升企业的管理效率和服务质量，满足不同用户和商家的需求，有望在市场上获得竞争优势。
（3）用户可行性：微信小程序具有广泛的用户基础和易用性，用户可以通过微信直接打开小程序，无需下载和安装，便于使用和分享。对于母婴商品仓库管理系统的用户，也可以通过微信小程序轻松实现商品查询、下单、配送等操作，提高用户体验和满意度。
（4）数据安全可行性：微信小程序提供了完善的数据加密、权限控制等机制，可以保证敏感数据的安全性和隐私保护。同时，企业也可以通过合理的数据备份、恢复和监管机制，进一步加强数据的安全性和稳定性。
总的来说，基于微信小程序的母婴商品仓库管理系统的设计与实现具有较高的可行性和前景，在技术、商业、用户和数据安全等方面都具备一定的优势和潜力。
6.功能模块 基于微信小程序的母婴商品仓库管理系统可以包括以下功能模块：
（1）用户登录与权限管理：实现用户注册、登录和权限管理，确保只有授权用户可以访问系统，并对用户进行身份验证和权限控制。
（2）商品管理：包括商品信息的录入、编辑和删除，可以添加商品的名称、描述、价格、规格等详细信息，并能够上传商品图片。
（3）库存管理：记录商品的库存数量，实时更新库存信息，包括入库、出库、调拨等操作，以及库存预警功能，提醒管理员及时补货。
（4）仓库管理：管理仓库的基本信息，包括仓库名称、位置、容量等，可以对仓库进行增删改查，方便管理和分配。
（5）数据统计与报表：统计和分析商品销售情况、库存变动情况等数据，生成报表和图表，为企业管理者提供决策支持。
（6）数据备份与恢复：定期进行数据备份，以防止数据丢失和错误，同时能够及时恢复数据，保证系统的可用性和稳定性。
7.技术路线 基于微信小程序的母婴商品仓库管理系统的设计与实现的技术路线如下：
前端开发：
使用微信小程序开发工具进行前端界面的设计和开发。使用WXML（微信小程序的模板语言）和WXSS（微信小程序的样式语言）编写页面布局和样式。使用JavaScript进行前端逻辑开发，通过调用微信小程序提供的API接口实现页面跳转、数据交互等功能。 后端开发：
选择合适的后端开发语言java和框架SpringBoot。设计和实现后端服务器，处理前端发送的请求并返回相应的数据。使用数据库（MySQLB等）存储和管理商品信息、用户信息、订单信息等数据。 数据交互：
前后端通过RESTful API进行数据交互，使用HTTP协议传输数据。后端提供接口，处理前端发送的请求并返回相应的数据，如商品查询、下单、库存管理等操作。前端通过调用后端接口获取数据，并将数据展示在小程序界面上。 数据库设计：
根据系统需求，设计合理的数据库结构，包括商品表、用户表、订单表等。使用数据库管理系统进行数据库的创建、表的设计和数据的存储管理。 用户认证与权限管理：
使用登录接口实现用户的注册和登录功能。在后端进行用户身份验证，确保只有授权用户可以访问系统。设计合适的权限管理机制，对不同用户进行不同级别的权限控制。 测试：
进行系统功能测试，包括单元测试、集成测试和系统测试，确保系统的稳定性和可靠性。 8.预期成果和创新点 本研究的预期成果是基于微信小程序的母婴商品仓库管理系统的设计与实现。该系统将提供便捷的操作界面和全面的功能模块，帮助企业实现母婴商品仓库管理的自动化和信息化。
本研究的创新点主要有：
（1）引入微信小程序平台：通过微信小程序的便捷性和实时性，使母婴商品仓库管理更加高效和准确。
（2）全面的功能模块：系统将提供商品入库、出库、库存管理、订单管理和数据分析等全面的功能模块，满足企业的各类需求。
（3）实时数据分析：系统将提供实时的数据分析功能，帮助企业实时了解库存情况、销售情况等关键信息，从而作出及时决策。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d18b9c7b3a5d7115436a18123c34bd64/" rel="bookmark">
			C&#43;&#43;实现分水岭算法（Watershed Algorithm）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要为大家详细介绍了C++实现分水岭算法Watershed Algorithm，具有一定的参考价值，感兴趣的小伙伴们可 以参考一下 分水岭分割方法（Watershed Segmentation），是一种基于拓扑理论的数学形态学的分割方法，其基本思想是把图像看作是 测地学上的拓扑地貌，图像中每一点像素的灰度值表示该点的海拔高度，每一个局部极小值及其影响区域称为集水盆，而集水 盆的边界则形成分水岭。分水岭的概念和形成可以通过模拟浸入过程来说明。在每一个局部极小值表面，刺穿一个小孔，然后 把整个模型慢慢浸入水中，随着浸入的加深，每一个局部极小值的影响域慢慢向外扩展，在两个集水盆汇合处构筑大坝，即形 成分水岭。 分水岭的计算过程是一个迭代标注过程。分水岭比较经典的计算方法是L. Vincent提出的。在该算法中，分水岭计算分两 个步骤，一个是排序过程，一个是淹没过程。首先对每个像素的灰度级进行从低到高排序，然后在从低到高实现淹没过程中， 对每一个局部极小值在h阶高度的影响域采用先进先出（FIFO）结构进行判断及标注。 分水岭变换得到的是输入图像的集水盆图像，集水盆之间的边界点，即为分水岭。显然，分水岭表示的是输入图像极大值 点。因此，为得到图像的边缘信息，通常把梯度图像作为输入图像，即： grad(f(x,y))=((f(x-1,y)-f(x+1,y))^2 + (f(x,y-1)-f(x,y+1))^2)^0.5 式中，f(x,y)表示原始图像，grad(.)表示梯度运算。 分水岭算法对微弱边缘具有良好的响应，图像中的噪声、物体表面细微的灰度变化，都会产生过度分割的现象。但同时应 当看出，分水岭算法对微弱边缘具有良好的响应，是得到封闭连续边缘的保证的。另外，分水岭算法所得到的封闭的集水盆， 为分析图像的区域特征提供了可能。 为消除分水岭算法产生的过度分割，通常可以采用两种处理方法，一是利用先验知识去除无关边缘信息。二是修改梯度函 数使得集水盆只响应想要探测的目标。 为降低分水岭算法产生的过度分割，通常要对梯度函数进行修改，一个简单的方法是对梯度图像进行阈值处理，以消除灰 度的微小变化产生的过度分割。即： g(x,y)=max(grad(f(x,y)),gθ) 式中，gθ表示阈值。 程序可采用方法：用阈值限制梯度图像以达到消除灰度值的微小变化产生的过度分割，获得适量的区域，再对这些区域的 边缘点的灰度级进行从低到高排序，然后在从低到高实现淹没的过程，梯度图像用Sobel算子计算获得。对梯度图像进行阈值 处理时，选取合适的阈值对最终分割的图像有很大影响，因此阈值的选取是图像分割效果好坏的一个关键。缺点：实际图像中 可能含有微弱的边缘，灰度变化的数值差别不是特别明显，选取阈值过大可能会消去这些微弱边缘。 下面用C++实现分水岭算法：
#define _USE_MATH_DEFINES
#include #include #include #include #include #include #include #include #include #include #include using namespace std; typedef void GVVoid; typedef bool GVBoolean; typedef char GVChar; typedef unsigned char GVByte; typedef short GVInt16; typedef unsigned short GVUInt16; typedef int GVInt32; typedef unsigned int GVUInt32; typedef long long GVInt64; typedef unsigned long long GVUInt64; typedef float GVFloat32; typedef double GVFloat64; const GVBoolean GV_TRUE = true; const GVBoolean GV_FALSE = false; const GVByte GV_BYTE_MAX = UCHAR_MAX; const GVInt32 GV_INT32_MAX = INT_MAX; const GVInt32 GV_INT32_MIX = INT_MIN; const GVInt64 GV_INT64_MAX = LLONG_MAX; const GVInt64 GV_INT64_MIN = LLONG_MIN; const GVFloat32 GV_FLOAT32_MAX = FLT_MAX; const GVFloat32 GV_FLOAT32_MIN = FLT_MIN; const GVFloat64 GV_FLOAT64_MAX = DBL_MAX; const GVFloat64 GV_FLOAT64_MIN = DBL_MIN; class GVPoint; class GVPoint { public: GVInt32 x; GVInt32 y; public: GVPoint() : x(0), y(0) { } GVPoint(const GVPoint &amp;obj) : x(obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d18b9c7b3a5d7115436a18123c34bd64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42077fe30f48f83013e468b356b40feb/" rel="bookmark">
			DDIA 第四章：数据编码与演化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是《数据密集型应用系统设计》（DDIA）的读书笔记，一共十二章，我已经全部阅读并且整理完毕。
采用一问一答的形式，并且用列表形式整理了原文。 笔记的内容大概是原文的 1/5 ~
1/3，所以你如果没有很多时间看书的话，看我的笔记也就够了！
应用程序总是增增改改。
修改程序大多数情况下也在修改存储的数据。
关系数据库通常假定数据库中的所有数据都遵循一个模式：尽管可以更改该模式（通过模式迁移，即ALTER语句），但是在任何时间点都有且仅有一个正确的模式。读时模式（schema-on-read）（或 无模式（schemaless））数据库不会强制一个模式，因此数据库可以包含在不同时间写入的新老数据格式的混合。 当数据格式发生改变时，需要代码更改：
服务端应用程序，会灰度发布；客户端应用程序，看用户心情。 新旧版本的代码和数据，可能同时共处。
系统需要双向兼容：
向后兼容：新代码可以读旧数据。容易。向前兼容：旧代码可以读新数据。难。 编码数据的格式 程序通常（至少）使用两种形式的数据：
在内存中，数据保存在对象，结构体，列表，数组，哈希表，树等中。 这些数据结构针对CPU的高效访问和操作进行了优化（通常使用指针）。如果要将数据写入文件，或通过网络发送，则必须将其 编码（encode） 为某种自包含的字节序列（例如，JSON文档）。 由于每个进程都有自己独立的地址空间，一个进程中的指针对任何其他进程都没有意义，所以这个字节序列表示会与通常在内存中使用的数据结构完全不同。 所以，需要在两种表示之间进行某种类型的翻译。
从内存中表示到字节序列的转换称为 编码（Encoding） （也称为序列化（serialization） 或编组（marshalling））；反过来称为**解码（Decoding）**ii（解析（Parsing），反序列化（deserialization），反编组( unmarshalling））译i。 语言特定的格式 许多编程语言都内建了将内存对象编码为字节序列的支持。例如，Java有java.io.Serializable ，Ruby有Marshal，Python有pickle .
这些库很方便，但是有深层次问题：
与特定的编程语言绑定。为了恢复相同对象类型的数据，解码过程需要实例化任意类的能力，这是安全问题的来源。数据版本控制不方便。效率也不高。 只适合临时使用。
JSON，XML和二进制变体 跨语言的编码：JSON，XML和CSV，属于文本格式，因此具有人类可读性。
除了语法问题外，还有问题：
数值编码有歧义：XML 和 CSV 不能区分数字和字符串。JSON 不能区分整数和浮点数。处理大数值困难。JSON 和 XML 对 unicode（人类可读的文本）有很好的支持，但是不支持二进制。通过 base64 绕过这个限制。XML 和 JSON 都有可选的模式支持。CSV 没有模式，行列的含义完全由应用程序指定。格式模糊。 虽然问题多，但是大家对这些达成了意见一致。
二进制编码 当数据很多的时候，数据格式的选择会有很大影响。
JSON比XML简洁，但与二进制格式相比还是太占空间。现在有很多二进制格式的 JSON（MessagePack，BSON，BJSON，UBJSON，BISON和Smile等）。
JSON 字符串是：
{ "userName": "Martin", "favoriteNumber": 1337, "interests": ["daydreaming", "hacking"] } MessagePack 编码的 Json 举例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42077fe30f48f83013e468b356b40feb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13480814bf5a52a43a7eaa7a7fd576c/" rel="bookmark">
			中国AIGC广告营销产业全景报告：五大变革四大影响，生成式AI让只为「一个人」打造广告成为可能...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		量子位智库 发自 凹非寺
量子位 | 公众号 QbitAI 在互联网流量红利消退的当下，广告营销产业进入存量竞争。
TikTok开始用生成式AI来提供广告脚本，Snapchat开始用聊天机器人来推个性化广告，百度营销重构了一系列全新的AI Native产品赋能企业营销全流程。
大模型和生成式AI技术的出现为品牌营销的破局提供了重要契机，国内外广告营销行业与大模型和生成式AI技术的结合呈现前所未有的火热态势。
广告营销产业链上的玩家正处于历史性的转折点。
生成式AI为不同广告营销主体提供了何种新解法？
广告营销行业的工作流程、内容生产场景、投放效果如何变化？行业将产生怎样的周期影响？
生成式AI浪潮下广告营销行业的核心生产要素发生了哪些变化？传统营销企业应该如何应对？创业公司又有哪些机遇？
带着这些问题，量子位智库《中国AIGC广告营销产业全景报告》由此而来，并尝试解答。
报告中，量子位智库将从我国广告营销行业现状、生成式AI带来的五大变革、四大影响、市场规模及竞争现状等多角度、多方向地全面立体描绘中国AIGC广告营销产业全景。
核心观点包括：
广告营销或成为生成式AI最快落地领域，开始回归「人与人」的交流，实现「全局最优」分配方式
生成式AI从供给端到需求端依次冲击产业链玩家，营销服务商价值凸显
从PGC到UGC到AIGC，生成式AI打造内容生产增量市场，创意工具平民化趋势显著
从无差别影响到个性化定制，生成式AI让只为「一个人」打造广告成为可能
作为新增长引擎，生成式AI在广告营销行业中业务营收预计2030年触及千亿级市场规模
行业与人才资源、模型效果、服务场景与数据反馈成为广告营销行业新的核心生产要素
未来每个品牌都将有自己专属的营销大模型，大模型定制与微调技术不可或缺
……
大模型时代下的广告营销 广告营销是指企业通过广告对产品展开宣传推广，促成消费者的直接购买，增加产品的销售量，提高企业的知名度、美誉度和影响力的系列活动，是企业营销组合中的一个重要组成部分。
广告营销的传统范式是以流量推动品牌增长，以SEM搜索投放模式和算法推荐为主。
如今互联网流量红利见顶，客户更加希望获得「所问即所答」的回复，用户需求表达关注度提高。
广告营销产业亟需新范式推动其增长。
生成式AI成为破局关键 广告营销之前的偏重都在投放、媒介和运营上，现在媒介由于以媒体广告为主（近70%），生命周期变短，对内容生产要求变高，内容质量将直接决定广告营销的价值创造。
生成式AI技术可用于解决营销各环节痛点，其或将成为最快与生成式AI结合并产生实际落地效果的领域。
在生成式AI冲击下，广告营销行业将回归营销本质，从「人与机器」单向交互，回归到「人与人」的交流；流程扁平化，一步到位进行内容生产与投放，减少信息损失；从传统的广告推荐模型，变成以数据驱动的大模型为核心，实现全局最优的广告分配。
生成式AI广告营销领域应用 国内外广告营销行业与大模型和生成式AI技术的结合呈现前所未有的火热态势。
广告主/品牌商、广告营销服务商、投放平台、第三方公司纷纷入局。
AIGC广告营销五大变革 大模型与生成式AI技术对广告营销行业带来的变革，我们从产业链、工作流程、典型生产场景、投放效果、业态与格局这五个方面总结如下：
变革一：产业链变革 广告营销行业产业链按参与主体可分为广告主、广告媒介和消费者，其中广告主是互联网广告行业发展的源动力，广告媒介是市场的核心驱动，消费者是广告营销的受众。
其中产业链上游玩家将最先受到冲击，因为有内容生产降本增效的需求，需要利用生成式AI的能力进行转变。
部分品牌慢慢在去中介化，内化自己能力，需要有新工具运用到新场景中。
营销服务商从纯工具和中介化的链接工作，慢慢转变为在中间环节给广告主提供更强的增值性。
紧接着中游的投放平台会受到冲击，如果上游会采用生成式AI能力，平台自身能力可以外化成和上游一起合作打破自闭环的能力。
未来在大模型加持的虚拟数字人等新的交互方式、场景或渠道成熟后，消费者再会受到较大影响。
变革二：工作流程变革 广告营销领域的工作流程与环节涉及策略制定与用户画像洞察、广告内容的制作、投放渠道的管理与效果分析等工作，需要消耗大量的时间，其中有较多的工作都可以通过 AI 代替人工的方式实现效率的提升。
其中策略洞察与内容生产将最先被覆盖，是0-2年内生成式AI能提供较高辅助程度的场景。
但由于目前在流量匹配算法中加入大模型的提升效果并不明显，投放管理环节在短期内生成式AI还不能提供较高辅助。
变革三：生产场景变革 内容生产是广告营销全流程中生成式AI表现最突出的场景。量子位智库预测未来5年会有70%的营销内容可由AI自动生成并迭代。
这是由于生成式AI降低了内容创作的门槛，使内容批量化生成成为可能。未来创意生产工具将越来越平民化，内容生产也不再是一个存量市场，而是一个增量市场。
而广告营销行业中的内容生产部分中营销素材生产主要包括三种形式：文案生成、图片生成、视频生成。
其中文案生成受制于营销行业的创新性和实时性，技术虽较为成熟，国内目前真正投入使用较少，商业化程度较低。
图片生成国内目前技术相对成熟，由于生成的图片仍不够精细化商业化程度一般。
视频生成国内目前技术和商业化均不够成熟，复杂度较高，公司更多的是用AI做特效或图片拼接以及生成虚拟数字人视频，预计可能在年中达到图片生成的效果，实现商业化。
变革四：投放效果变革 广告营销经历了从2006年以前的无差别影响「所有人」，到2006-2012年间的影响「一类人」，再到2012年后的精准影响「一个人」。
2012年移动互联网的广告算法让精准推荐变成可能，2022年大模型技术出现，生成式AI让只为「一个人」打造广告内容成为可能。
变革五：业态与格局变革 生成式AI能有效实现广告营销行业生产力的提升，主要体现在——
创新广告形式，带来全新交互体验，形成强流量、高互动，提升广告投放ROI。
提高营销内容生产效率，推进自动化个性化营销，实现精准链接和高效触达。
推动营销服务商商业模式革新，优化企业工作流。
AIGC广告营销四大影响 量子位智库从市场规模、行业核心生产要素、企业工作流、行业发展阶段与周期四个方面，来看大模型与生成式AI对广告营销行业未来带来的影响：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b13480814bf5a52a43a7eaa7a7fd576c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5736a286584a1e0ad739e00831ebc96e/" rel="bookmark">
			分布式（9）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
41.常见的JOB实现方案？
42.Cookie和Session有什么区别？
43.谈谈会话技术的发展？
44.分布式会话有哪些解决方案？
45.什么是Session Stick？
41.常见的JOB实现方案？ 基于上面Java任务演化出分布式Job方案：
quartz
JDBCJobStore 支持集群所有触发和Job都存储在数据库中无论服务器停止和重启都可以恢复任务同时支持事务处理
elastic job
elastic job是由当当网基于quartz二次开发之后的分布式调度解决方案，由两个相对独立的子项目Elastic Job Lite和Elastic JOB Cloud 组成。
Elastic Job Lite 定位为轻量级无中心化解决方案，使用jar包的形式提供分布式任务的协调服务。
Elastic Job Cloud使用Mesos+Docker（TBD)的解决方案，额外提供资源治理，应用分发以及进程隔离等服务
两点：
1.基于quartz定时任务框架为基础的，因此具备quartz的大部分功能
2.使用zookeeper做协调，调度中心，更加轻量级
3.支持任务的分片
4.支持弹性扩容，可以水平扩展，当任务再次运行时，会检查当前的服务器数量，重新分片，分片结束之后才会继续执行任务。
5.失效转移，容错处理，当一台调度服务器宕机或者跟zookeeper断开连接后，会立即停止作业，然后再去寻找其他空闲的调度服务器，来运行剩余的任务。
6.提供运维界面，可以管理作业和注册中心。
xxl job
一个轻量级分布式任务调度框架，主要分为调度中心和执行器两部分，调度中心在启动初始化的时候，会默认生成执行器的RPC代理
对象（http协议调用），执行器项目启动之后，调度中心在触发定时器之后通过jobHandle来调用执行器项目里面的代码，核心功能和elastic job差不多
42.Cookie和Session有什么区别？ Cookie和Session的方案虽然分别属于客户端和服务端，但是服务端的session的实现对客户端的cookie有依赖关系的，服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个Id值放到http请求的头部发送给服务器，而这个id值在客户端会保存下来，保存的容器就是cookie,因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用。
43.谈谈会话技术的发展？ 单机 Session+Cookie
多机器
在负载均衡侧 Session粘滞
Session数据同步
多机器，集群，session集中管理，比如redis;目前方案上用的最多的是SpringSession，早前也有用tomcata集成方式的。
无状态token,比如JWT
44.分布式会话有哪些解决方案？ Session Stick
Session Replication Session数据集中存储
Cookie Based
JWT
45.什么是Session Stick？ 方案即将客户端的每次请求都转发至同一台服务器，这就需要负载均衡器能够根据每次请求的会话标识（Session ID）进行请求转发，如下图所示。
这种方案实现比较简单，对于Web服务器来说和单机的情况一样。但是可能会带来如下问题：
如果有一台服务器宕机或者重启，那么这台机器上的会话数据会全部丢失。
会话标识是应用层信息，那么负载均衡要将同一个会话的请求都保存同一个Web服务器上的话没救需要进行应用层（第7层）的解析，这个开销比第4层大。
负载均衡器将编程一个有状态的节点，要将会话保存到具体的web服务器的映射。和无状态节点相比，内存消耗更大，容灾方面也会更麻烦。
PS：为什么这种方案到目前还有很多项目使用呢？因为不需要在项目代码侧改动，而是只需要在负载均衡侧改动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b37677833d0035ffdc13bd0a7e25b86/" rel="bookmark">
			使用EasyExcel导出数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引入EasyExcel依赖
二、代码框架实现
1-1、无需复杂处理，直接使用工具类
1-2、创建一批假数据
1-3、使用流的方式导出数据
1-4、使用生成文件的方式导出数据
1-5、验证结果
2-1、自定义表头格式，并对数据做处理
2-2、验证结果
三、问题暴露及修复思路
1、问题原由
The maximum number of cell styles was exceeded. You can define up to 64000 styles
2、将底层实现或是枚举方法Copy重写
3、重新定义实现类
四、百万级别数据导出 处理思路
一、引入EasyExcel依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; 二、代码框架实现 1-1、无需复杂处理，直接使用工具类 定义具体对象，并添加@ExcelProperty，来指定列信息
@Data @Builder @NoArgsConstructor @AllArgsConstructor @ExcelIgnoreUnannotated public static class DemoDataRespVO { @ExcelProperty(value = "数据1", index = 0) private String data1; @ExcelProperty(value = "数据2",index = 1) private String data2; @ExcelProperty("数据3") private String data3; @ExcelProperty("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b37677833d0035ffdc13bd0a7e25b86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24cf819553cf8f1d40a30e48866a5c2c/" rel="bookmark">
			斜杠/、反斜杠\与转义字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串中的路径，如果代表的是 Linux 或 Unix 文件路径，则使用斜杠 / ；如果代表的是 Windows 文件路径，则使用斜杆 / 和反斜杠 \ 是一样的（但 Windows 系统默认为反斜杠 \ ）；如果代表的是网络文件路径，则必须使用斜杆 / ，因为 web 遵循 unix 命名。
在程序中， \ 用来转义，即具备转义能力的字符就被定义为“ \ ”本身。如果要表示单纯的“ \ ”符号，需要经过转义，即“ \\ ”，表示单纯的“ \ ”字符。
"."：代表当前目录
".."：代表上一级目录
"/"：代表根目录（ Linux 或 Unix 系统下）
1、2、3、4、5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/193b6262ad2f08ed85fc109c4e3773f3/" rel="bookmark">
			Ef Core花里胡哨系列(10) 动态起来的 DbContext
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ef Core花里胡哨系列(10) 动态起来的 DbContext 我们知道，DbContext有两种托管方式，一种是AddDbContext和AddDbContextFactory，但是呢他们各有优劣，例如工厂模式下性能更好呀等等。那么，我们能否自己托管DbContext呢？
Github Demo：动态起来的 DbContext
场景：
结合我们之前的文章 [Ef Core花里胡哨系列(5) 动态修改追踪的实体、动态查询] 假设一个应用内有很多的子应用，且都需要更新追踪的动态实体，那么很多表在重置OnModelCreating的时候将会非常的慢。主要体现在modelBuilder.Model.AddEntityType(type)，每个实体都需要花费一小段时间，几百个实体就会按分钟计算了，而且还会数据库操作产生一定的影响。
我们先实现一个基础的DbContext用来添加一些通用的实体以及处理动态实体的逻辑，每次需要重置DbContext的时候，都会获取最新的动态实体进行更新：
public class DbContextBase : DbContext { public DbSet&lt;User&gt; Users { get; set; } = null!; public DbSet&lt;Department&gt; Departments { get; set; } = null!; protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder.UseSqlite("Data Source=sample.db"); optionsBuilder.ReplaceService&lt;IModelCacheKeyFactory, MyModelCacheFactory&gt;(); base.OnConfiguring(optionsBuilder); } protected override void OnModelCreating(ModelBuilder modelBuilder) { var name = GetType().Name.Split("_"); if (name.Length &gt; 1) { foreach (var item in FormTypeBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/193b6262ad2f08ed85fc109c4e3773f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91a1ffc047e5fd8188123e6adaa1fc3c/" rel="bookmark">
			[足式机器人]Part2 Dr. CAN学习笔记-动态系统建模与分析 Ch02-3流体系统建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅供学习使用
本文参考：
B站：DR_CAN
Dr. CAN学习笔记-动态系统建模与分析 Ch02-1+2课程介绍+电路系统建模、基尔霍夫定律 流量 flow rate q q q m 3 / s m^3/s m3/s
体积 volume V V V m 3 m^3 m3
高度 heigh h h h m m m
压强 pressure p p p N / m ( p a s c a l ) N/m\left( pascal \right) N/m(pascal)
静压 Hydrostatic Pressure p H y d r o = F H y d r o A = m g A = ρ g h p_{\mathrm{Hydro}}=\frac{F_{\mathrm{Hydro}}}{A}=\frac{mg}{A}=\rho gh pHydro​=AFHydro​​=Amg​=ρgh
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91a1ffc047e5fd8188123e6adaa1fc3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac595f641b7348381602c110531be95/" rel="bookmark">
			基于深度学习的停车位关键点检测系统（代码&#43;原理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要： DMPR-PS是一种基于深度学习的停车位检测系统，旨在实时监测和识别停车场中的停车位。该系统利用图像处理和分析技术，通过摄像头获取停车场的实时图像，并自动检测停车位的位置和状态。本文详细介绍了DMPR-PS系统的算法原理、创新点和实验结果，并对其性能进行了评估。
算法创新： DMPR-PS系统的算法创新主要体现在以下几个方面：
深度学习模型：DMPR-PS系统采用了深度学习模型来进行停车位的检测。通过大规模数据集的训练，该模型可以自动学习停车位的特征，并准确地进行检测和分类。
多尺度检测：为了应对不同大小的停车位，DMPR-PS系统使用了多尺度检测策略。通过在不同尺度下进行检测，可以提高系统对各种大小停车位的检测准确率。
实时性能：DMPR-PS系统具有较高的实时性能。它能够快速处理实时视频流，并在短时间内完成停车位的检测和识别，满足实时监测的需求。
实验结果与结论： 通过对多个停车场场景的实验测试，DMPR-PS系统展现了良好的性能。实验结果表明，该系统在检测准确率和实时性能方面都具有较高的水平。
、
代码运行 要求： python版本3.6 pytorch版本1.4+ 其他要求： pip install -r requirements.txt gcn-parking-slot 预训练模型 可以通过以下链接下载两个预训练模型。
链接	代码	描述 Model0	bc0a	使用ps2.0子集进行训练，如[1]所述。 Model1	pgig	使用完整的ps2.0数据集进行训练。 准备数据 可以在此处找到原始的ps2.0数据和标签。提取并组织如下：
├── datasets │ └── parking_slot │ ├── annotations │ ├── ps_json_label │ ├── testing │ └── training 训练和测试 将当前目录导出到PYTHONPATH：
export PYTHONPATH=`pwd` 演示 python3 tools/demo.py -c config/ps_gat.yaml -m cache/ps_gat/100/models/checkpoint_epoch_200.pth 训练 python3 tools/train.py -c config/ps_gat.yaml 测试 python3 tools/test.py -c config/ps_gat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fac595f641b7348381602c110531be95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a144bcdb454aea66bdd1031dded72c69/" rel="bookmark">
			[转]Jetson nano部署YOLOv8-CSDN博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、YOLOv8模型训练 1. 项目的克隆和必要的环境依赖 1.1 项目的克隆1.2 项目代码结构整体介绍1.3 环境安装2. 数据集和预训练权重的准备 2.1 数据集2.2 预训练权重准备3. 训练模型 3.1 修改数据配置文件3.2 修改模型配置文件3.3 训练模型3.4 推理测试二、YOLOv8模型部署 1. 源码下载2. 环境配置 2.1 trtexec环境变量设置3. ONNX导出 3.1 静态batch导出 3.1.1 Transpose节点的添加3.1.2 Resize节点解析的问题3.2 动态batch导出 3.2.1 exporter.py修改3.2.2 Transpose节点添加3.2.3 Resize节点解析的问题4. 运行 4.1 engine生成4.2 源码修改4.3 编译运行4.4 拓展-摄像头检测4.5 拓展-trtexec参数结语下载链接参考 前言 开始YOLOv8的模型部署，目的是为大家推荐一个全新的tensorrt仓库https://github.com/shouxieai/infer，大家可以查看我之前的Jetson嵌入式系列模型部署教程，很多细节这里就不再赘述了。考虑到nano的算力，这里采用yolov8n.pt模型，本文主要分享yolov8模型训练和jetson nano部署yolov8两方面的内容。若有问题欢迎各位看官批评指正!!!😄
一、YOLOv8模型训练 先来欣赏下YOLOv8的网络结构😅
yolov8的代码风格和yolov5相差较大，训练流程也稍有差异。博主主要参考魔鬼面具的YOLOv8最强操作.
1. 项目的克隆和必要的环境依赖 1.1 项目的克隆 yolov8的代码是开源的可直接从github官网上下载，源码下载地址是https://github.com/ultralytics/ultralytics，由于yolov8刚发布不久一个固定版本都没有，故只能采用主分支进行模型的训练和部署工作(PS:由于代码更新频繁，可能大家会遇到不同的bug)。Linux下代码克隆指令如下
git clone https://github.com/ultralytics/ultralytics.git 也可手动点击下载，点击右上角的Code按键，将代码下载下来。至此整个项目就已经准备好了。也可以点击here[pwd:yolo]下载博主准备好的代码(注意代码下载于2023/3/14日，若有改动请参考最新)
1.2 项目代码结构整体介绍 将下载后的yolov8的代码解压，其代码目录如下图
只需要关注ultralytics这个文件夹的内容即可，下面对这个文件夹的整体目录做一个介绍
|-assets：存放测试图片|-datasets：存放一些超参数的配置文件以及配置训练集和验证集路径的coco.yaml文件，如果需要修改自己的数据集，那么需要修改其中的yaml文件|-hub：pytorch扩展模型|-models：存放不同模型的yaml文件，包括v3、v5和v8|-nn：存放yolov8整体网络模型搭建的py文件|-tracker：存放yolov8目标跟踪的py文件|-yolo：存放yolov8模型预测、训练、导出的py文件 cfg：存放yolov8的配置文件，包括训练时的参数指定如epoch、batch等以及超参数设置，所有的相关配置都可通过这个文件设置(重点关注cfg/default.yaml文件)data：存放数据加载的py文件engine：存放模型导出的py文件utils：存放工具类函数，包括loss、metrics、plots函数等v8：存放yolov8分类、检测、分割等不同任务的预测、训练以及验证的py文件(重点关注) 1.3 环境安装 关于深度学习的环境安装可参考炮哥的利用Anaconda安装pytorch和paddle深度学习环境+pycharm安装—免额外安装CUDA和cudnn(适合小白的保姆级教学)，这里不再赘述。如果之前配置过yolov5的环境，yolov8可直接使用。
2. 数据集和预训练权重的准备 2.1 数据集 这里采用的数据集是口罩识别，来源于B站UP主HamlinZheng的口罩识别数据集，这里给出下载链接Baidu Drive[password:yolo]，博主将原数据集整合了下，方便后续的训练，解压后整个数据集目录结构如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a144bcdb454aea66bdd1031dded72c69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c79f8222d7d284cf22d8bfa418aaded9/" rel="bookmark">
			RA4803SA (高稳定实时时钟模块)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 汽车用RA4803SA，高稳定串行接口实时时钟模块内置频率可调32.768kHz晶体单元和DTCXO。1/100秒分辨率时间寄存器接口类型4线串行接口界面电压范围1.6V ~ 5.5V温度补偿电压范围2.2V至5.5V时钟电源电压范围1.6V ~ 5.5V可选时钟输出(32.768kHz, 1024Hz, 1Hz)各种功能包括完整的日历，闹钟，定时器，EVIN输入。用途:汽车音响，汽车导航系统，时钟AEC-Q200兼容 概述 高稳定性 UA±3.4 × 10-6 / -40℃~ +85℃(相当于月差±9秒)±5.0 × 10-6 / -40℃至+85℃(相当于月差±13秒)UC±5.0 × 10-6 / -30℃至+70℃(相当于月差±13秒)Aa(+5±5.0)× 10-6 / +25°c高分辨率:1/100秒时间寄存器与捕获缓冲区32.768kHz频率输出功能 FOUT引脚输出(C-MOS输出)，CL=30pF输出可选:32.768kHz, 1024Hz, 1Hz各种各样的中断 定时器功能可在1/ 4096秒到4095分钟之间设置。闹钟功能可以设置为星期几、天、小时或分钟。艾文输入。时间同步功能，1PPS信号输入寄存器兼容性:上层兼容RX-4801。 *可通过32.768kHz-DTCXO端子连接使用。
电路框图 规格（特征） 引脚连接 / 外部尺寸规格 引脚功能定义 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/36/">«</a>
	<span class="pagination__item pagination__item--current">37/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/38/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>