<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a152be41a2f1e6230bfd0ae0d90ec3bf/" rel="bookmark">
			pycharm 2020.1 连接远程虚拟机centos服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本信息：pycharm 2020.1 Centos7
简单配置过程如下:
选择Sftp 添加sftp连接信息
填写本地项目路径 远程服务器路径mapping 本地pycharm运行 py文件即可以同步至远程虚拟机服务器上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f501e13ba70fcc37e4dafa93ca384ee/" rel="bookmark">
			org/apache/hbase/thirdparty/com/google/common/cache/CacheLoader
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日萌社 人工智能AI：Keras PyTorch MXNet TensorFlow PaddlePaddle 深度学习实战（不定时更新）
报错：
Caused by: java.lang.NoClassDefFoundError: org/apache/hbase/thirdparty/com/google/common/cache/CacheLoader
Caused by: java.lang.ClassNotFoundException: org.apache.hbase.thirdparty.com.google.common.cache.CacheLoader
解决：
https://mvnrepository.com/artifact/org.apache.hbase.thirdparty/hbase-shaded-miscellaneous
下载：hbase-shaded-miscellaneous-2.2.1.jar
报错：
Caused by: java.lang.NoClassDefFoundError: org/apache/hadoop/hbase/shaded/protobuf/generated/MasterProtos$MasterService$BlockingInterface
Caused by: java.lang.ClassNotFoundException: org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos$MasterService$BlockingInterface
解决：
https://mvnrepository.com/artifact/org.apache.hbase/hbase-protocol-shaded
下载：hbase-protocol-shaded-2.2.5.jar
报错：
Caused by: java.lang.NoClassDefFoundError: org/apache/hbase/thirdparty/com/google/protobuf/RpcController
Caused by: java.lang.ClassNotFoundException: org.apache.hbase.thirdparty.com.google.protobuf.RpcController
解决：
https://mvnrepository.com/artifact/org.apache.hbase.thirdparty/hbase-shaded-protobuf/2.2.1
下载：hbase-shaded-protobuf-2.2.1.jar
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a736636021517d60c5bac3110d081b2/" rel="bookmark">
			python用法查询笔记（一）——基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python用法查询笔记（一）——基础知识 目录 python用法查询笔记（一）——基础知识 print()函数引号的区别注释转义字符算数运算符格式化字符串条件判断 if列表字典for循环while循环函数 print()函数 #打印 #计算机无需理解，原样复述引号中的内容 print(‘You are pretty!’) #》》You are pretty! #让计算机读懂括号里的内容，打印最终的结果 print(1+2) #》》3 引号的区别 单引号 复述引号内容，语句中有单引号需用转义字符 ‘\’
print('let\'t go') #》》let't go 双引号 复述引号内容
print("let't go") #复述引号内容 #》》let't go print("hello,\ world") #连行符（\）多用于一行写不下的情况 '''hello,world''' 三对双引号 可实现多行输出，隐含了\n换行
print("""hello world""")#可实现多行输出，隐含了\n换行 ''' 输出： hello World ''' 注释 单行注释以 # 开头,快捷键 Ctrl+/
多行注释用三个单引号’’'或三个双引号"""
# 这是一个注释 print("Hello, World!") #多行注释用三个单引号''' #!/usr/bin/python3 ''' 这是多行注释，用三个单引号 这是多行注释，用三个单引号 这是多行注释，用三个单引号 ''' print("Hello, World!") #多行注释用三个双引号""" #!/usr/bin/python3 """ 这是多行注释，用三个双引号 这是多行注释，用三个双引号 这是多行注释，用三个双引号 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a736636021517d60c5bac3110d081b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5c9b7bb10dba128b789904b181e00a7/" rel="bookmark">
			LTE的寻呼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		寻呼（Paging）是网络发送给UE的。UE在 RRC-IDLE 状态时，如果需要给UE发送下行数据，网络需要先给UE发送寻呼，UE收到寻呼后，可能会发起RRC连接以便接收呼叫。
为了接收寻呼，同时保持低功耗，UE支持DRX，只在预先定义好的时间段醒来接收 Paging 消息，其它时间段都处于休眠状态，以达到低功耗的目的。
网络会在特定系统帧（称为 Paging Frame（PF））的特定子帧（称为 Paging Occasion（PO））上发送 Paging 消息。UE只要在一个DRX周期内接收1个PO就可以了。寻呼周期和DRX周期是同一概念。DRX周期是由网络下发的2 个参数决定的：（1）小区特定的默认 DRX cycle；（2）UE 特定的 DRX cycle，这个是可选参数。UE选择两种的最小值作为DRX周期。DRX周期的值可能有 rf32, rf64, rf128, rf256 ...，即 32个系统帧，64个系统帧，128个系统帧，256个系统帧。DRX周期的长短影响UE的被动接通时延和待机功耗。
网络不是在每个DRX周期都会下发 Paging 消息；同一个 PO 可以用于多个UE的寻呼，用 Paging 消息中的 pagingRecordList 字段来区分具体寻呼哪个UE。UE在每个DRX周期的PO时点上开启接收，如果没有 Paging 消息，或者不是寻呼自身，则不做额外操作，继续休眠；只有确定是寻呼自身的，才将相应的消息送往上层去处理。
Paging 消息的作用除了向处于 RRC_IDLE 态的 UE 发送呼叫请求；还有 （1）通知处于 RRC_IDLE 和 RRC_CONNECTED 态的 UE，系统信息发生了变化；（2）通知 UE 开始接收 ETWS primary 通知和/或 ETWS secondary 通知；（3）通知 UE 开始接收 CMAS 通知。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0332fb5a8b32e4dff4252b1ce66948b5/" rel="bookmark">
			U-Net模型介绍和Kaggle的Top1解决方案源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容列表
介绍先决条件什么是U-NETU-NET结构KAGGLE数据科学SCIENCE BOWL 2018 挑战赛 介绍 计算机视觉是人工智能的一个领域，训练计算机解释和理解视觉世界。利用来自相机、视频和深度学习模型的数字图像，机器可以准确地识别和分类物体，然后对它们看到的东西做出反应。
在过去几年里，深度学习使得计算机视觉领域迅速发展。在这篇文章中，我想讨论计算机视觉中一个叫做分割的特殊任务。尽管研究人员已经提出了许多方法来解决这个问题，但我将讨论一种特殊的架构，即UNET，它使用一个完全卷积的网络模型来完成这项任务。
我们将利用UNET构建Kaggle SCIENCE BOWL 2018 挑战赛的第一解决方案。
先决条件 这篇文章是假设读者已经熟悉机器学习和卷积网络的基本概念。同时，他/她也有一些使用Python和Keras库的ConvNets的工作知识。
什么是市场细分? 分割的目的是将图像的不同部分分割成可感知的相干部分。细分有两种类型:
语义分割(基于标记类的像素级预测)实例分割(目标检测和目标识别) 在这篇文章中，我们将主要关注语义分割。
U-NET是什么? U-Net创建于2015年，是一款专为生物医学图像分割而开发的CNN。目前，U-Net已经成为一种非常流行的用于语义分割的端到端编解码器网络。它有一个独特的上下结构，有一个收缩路径和一个扩展路径。
U-NET 结构 U-Net下采样路径由4个block组成，其层数如下:
3x3 CONV (ReLU +批次标准化和Dropout使用)
3x3 CONV (ReLU +批次标准化和Dropout使用)
2x2 最大池化
当我们沿着这些块往下走时，特征图会翻倍，从64开始，然后是128、256和512。
瓶颈层由2个CONV层、BN和Dropout组成
与下采样相似上采样路径由4个块组成，层数如下:
反卷积层
从特征图中拼接出相应的收缩路径
3x3 CONV (ReLU +BN和Dropout)
3x3 CONV (ReLU +BN和Dropout)
KAGGLE DATA SCIENCE BOWL 2018 CHALLENGE 这项挑战的主要任务是在图像中检测原子核。通过自动化核检测，你可以帮助更快的解锁治疗。识别细胞核是大多数分析的起点，因为人体30万亿个细胞中的大多数都包含一个充满DNA的细胞核，而DNA是给每个细胞编程的遗传密码。识别细胞核使研究人员能够识别样本中的每个细胞，并通过测量细胞对各种治疗的反应，研究人员可以了解潜在的生物学过程。
样本图像，目标和方法
我们将使用U-Net这个专门为分割任务而设计的CNN自动生成图像遮罩
导入所有必要的包和模块
import os import sys import random import warnings import numpy as np import pandas as pd import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0332fb5a8b32e4dff4252b1ce66948b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b6450ca74b1fc8d3a5a0eeb8d4099ae/" rel="bookmark">
			COMSOL提取全域的场强值并导出到文件 或者 提取某一点的属性值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、COMSOL提取全域的场强值并导出到文件 （1） 显示场强分布云图 电势–右键–体；右侧表达式部分可以自己输入，也可以点击双向红绿箭头选择
* ec.Ex —E的三个坐标值
* ec.Ey
* ec.Ez
* ec.normE —E的模值
（2） 提取场强值 导出–右键–数据右侧表达式既可以直接输入也可以点击选择底部可以选择输出文件类型，和输出路径
二、COMSOL提取某一点的属性值 利用函数： mphinterpr(model,T,coord,[x;y;z]) 下图转载自该博客 PS:
对于每一个模型中其相关参数的表达式，可以通过查看其方程视图获得。如电流场问题示意如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6abb8cb3cb0ddbba9b64e0dc1289366f/" rel="bookmark">
			关于bootstrap--表格（table的各种样式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、table-striped：斑马线表格
2、table-bordered：带边框的表格
3、table-hover：鼠标悬停高亮的表格
4、table-condensed：紧凑型表格(单元格的内距由8px调至5px。)
5、table-responsive：响应式表格(当你的浏览器可视区域小于768px时，表格底部会出现水平滚动条。当你的浏览器可视区域大于768px时，表格底部水平滚动条就会消失)
6、“.table”主要有三个作用：
☑ 给表格设置了margin-bottom:20px以及设置单元内距
☑ 在thead底部设置了一个2px的浅灰实线
☑ 每个单元格顶部设置了一个1px的浅灰实线
&lt;table class="table"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 转载于：https://www.cnblogs.com/HUIWANG/p/11017108.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec5a228da535c9717b60254283be0e23/" rel="bookmark">
			C语言重要知识点总结【7】：C语言中的常量、变量、标识符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、常量1. 整型常量2. 实型常量（浮点型常量）3. 字符常量3.1 普通字符3.2 转义字符(表格)3.3 常见字符与ASCII代码表 4. 字符串常量4.1 字符串所占内存字节数 5. 符号常量 二、变量1. 常变量 三、标识符 大一下学期学习了C语言、暑假在家没事又把C语言复习了一遍。因此，趁热打铁，把所学内容写成笔记，以便以后复习，也希望能够帮助大家学好C语言。
以下内容如有错误，请大家在评论区指正，谢谢支持，共同进步。 go、go、go ！！！
一、常量 在C语言中，数据有常量和变量之分：
若在程序执行过程中，其数值不能发生改变的量称为常量
若在程序执行过程中，其数值可以改变的量称为变量
常量：分为 直接常量 和 符号常量 。直接常量：分为整型常量、实型常量、字符常量和字符串常量。（通常将整型常量和实型常量合称为数值常量）
首先大概看一下关于常量的内容：
整型常量：就是常整数，包括正整数、负整数和0。有十进制、八进制、十六进制三种表示形式。需要注意的是，八进制常整数在书写时以数字0作前缀；十六进制以0x作前缀。实型常量 ：又称浮点型常量，采用十进制小数形式 和 指数形式表示。字符型常量 ：用单引号括起来的单个字符，分为普通字符（‘a’，‘Z’，‘6’，’#’，’?’ ）和转义字符（’\n’是换行符、’\t’是水平制表符，横向跳格，8个空格）字符串常量 ：用双引号括起来的字符串符号常量：用标示符代表一个常量，使用之前必须定义，具有一改全改的优点。例如： #define PI 3.14 1. 整型常量 整型常量：包括正整数、负整数 和 0
十进制整数：书写形式通常是整数的写法。例如：0、16、88、666、-99 等。八进制整数：书写形式通常在八进制整数的前面加一个数字0（0作前缀）。例如：00、0111、015、021等，它们分别表示十进制整数：0、73、13、17。十六进制整数：书写形式通常是在十六进制整数的前面加0x（0x作前缀）。其中每个数字可以是 0 ~ 9、a ~ f 或 A~F 中的数字或英文字母。 例如：0x0（十进制0）、0x111（十进制273） 、0x15（十进制21）、0x21（十进制33 ）、0x5a（十进制90 ）、0Xa5（十进制165 ）…… 2. 实型常量（浮点型常量） 实型常量：又称浮点型常量，有 十进制小数形式 和 指数形式 2种表示形式。
① 十进制小数形式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec5a228da535c9717b60254283be0e23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ffc7106a7d945ebf5f2b422c17d4276/" rel="bookmark">
			Vue3第一次使用：ref与reactive的区别和注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天使用Vue3写了一个todo的例子
Vue3对我最大的感觉：
1、template标签下面可以有多个节点了，终于不用先写一个DIV了
2、setup函数可以代替之前的data，methods，computed，watch，Mounted等对象，但是props声明还是在外面。
不过我总是忘记在return里面写声明好的变量或者方法，导致报错没有这个变量或者函数。这一点还需要适应。希望以后能有方便的插件出现。
const todoList = reactive([]) const todoItem = ref('') 3、ref与reactive方法的区别是什么？一个是把值类型添加一层包装，使其变成响应式的引用类型的值。另一个则是引用类型的值变成响应式的值。所以两者的区别只是在于是否需要添加一层引用包装？其目的都是对数据添加响应式效果。
使用ref包装之后，需要使用.value才行进行取值和赋值操作。这就导致一个结果，就是在对象起属性名时，尽可能避开有value的属性名。因为会引起混淆，让人不知道是ref方法加上去的属性，还是原来对象就是这样的结构！
4、响应式对象里面如果有ref包装的值类型。则Vue会实现自动拆箱，即获取值的方式是object.property，而不是object.property.value，注意：只有响应式对象会是这样，响应式数组或者Map都不能这样。这一点在文档里面专门提到了。需要多注意。
上文说ref自动拆箱只发生在响应式对象内部。而在数组和原生集合如：Map里面访问ref是没有这种行为的。
5、watch监听没有响应式的变量时，需要方法包装，响应式变量可以直接监听。与Vue2的写法不同，要更需要小心和注意了。文档里面有说明
如果值类型监听，浏览器也会给你直接说明错误原因，很详细。
上面说：非法的监听源：&lt;值&gt;，源只能是一个getter函数，或者ref包装过的值，或者一个响应式对象，还有数组以上这些类型。
6、想自己下载Vue3来玩一玩的小伙伴，可以使用 npm init vite-app hello-vue3 命令下载一个Vue3的例子。然后用npm run dev启动就可以开始了。官方文档目前还是beta版本，但是已经基本不会大改了。文档地址
下面是源码：
真正的js代码其实还不到20行，比Vue2来说，真得是很大的进步了。节省了很多样板代码，逻辑也更加紧凑了。
&lt;template&gt; &lt;h1&gt;{{ msg }}&lt;/h1&gt; &lt;p&gt;left {{ leftNum }} thing(s) have to do&lt;/p&gt; &lt;input v-model="todoItem" placeholder="write some thing todo" @keyup="e =&gt; { if(e.keyCode == 13) add() }"&gt; &lt;button @click="add"&gt;add&lt;/button&gt; &lt;div v-for="(item, index) in todoList" :key="index"&gt; &lt;input type="checkbox" @input="finish(index)"&gt; &lt;input v-if="item.editable" v-model="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ffc7106a7d945ebf5f2b422c17d4276/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/548efa52069d76291166a07b1fd4c2a4/" rel="bookmark">
			初始堆-Xms与最大堆-Xmx设置为相等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般情况下，在生产环境中，初始堆大小-Xms与最大堆大小-Xmx被设置为相等。假设如果在生产环境中，初始堆大小-Xms与最大堆大小-Xmx是不等的，那么JVM就会根据堆内存的使用情况，动态的向操作系统申请内存，扩大或者是缩小，以-Xmx和-Xms的值为上下界，这里的每一次调整都会产生一定的系统开销，虽然做到了动态申请堆大小的能力，不过生产环境中，很少说一台机器跑好多个JAVA程序，一般情况下都是一对一，那么动态申请调整堆大小就没有意义了，因为不管内存申请的多还是少，都只是这个JAVA程序在用，不需要给其他的程序腾出空间，相反的，如果把初始堆大小-Xms与最大堆大小-Xmx设置成不相等，那么反而画蛇添足，因为如果初始堆大小-Xms与最大堆大小-Xmx不相等，那么就会需要申请空间时，而每次申请空间，就会产生相应的系统开销，同时如果一开始堆大小是-Xms，会增加程序运行时进行垃圾回收的次数，降低程序的性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fd1d85591fdcd8ce815b0b7c9303ea7/" rel="bookmark">
			2020人体姿态估计综述（Part4：3D Human Pose Estimation from Image）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		承接之前的博文：
A 2020 Human Pose Estimation Review （Part1：2D Single Person）
A 2020 Human Pose Estimation Review （Part2：2D Top-Down Multi-Person Pose Estimation）
A 2020 Human Pose Estimation Review （Part3：2D Bottom-Up Multi-Person Pose Estimation）
目录
1 Human Pose Estimation
2 2D Single-Person Pose Estimation
3 2D Top-Down Multi-Person Pose Estimation
4 2D Bottom-Up Multi-Person Pose Estimation
5 3D Human Pose Estimation from Image
5.1 3D Human Pose Estimation
5.2 3D Human Pose Estimation from Monocular Images with Deep Convolutional Neural, ACCV2014
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fd1d85591fdcd8ce815b0b7c9303ea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bb96c566794c0c7966eefaab47fe7d7/" rel="bookmark">
			关于映射的一些理解与常见命题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 写在前面一些定义映射的有关定义单射满射双射逆映射 一点理解一些命题与定理命题1：有限集合间建立双射，两集合元素个数相等证明 命题2：有限集的单射与满射可由元素数相等互相推出证 明 定理1：映射是可逆的当且仅当其为双射证 明 题外话 写在前面 映射在高中作为一个不需要深入理解的内容，那时候只知道映射是函数的推广。但在大学的数学学习中，映射的概念贯穿了分析、代数等多个学科，下面详细介绍一下映射以及一些关于映射的一些定理。部分内容参考丘维声教授所著《数学的思维方式与创新》一书的引言部分。
一些定义 映射的有关定义 设 A A A和 B B B是两个集合，如果集合 A A A到集合 B B B存在一个对应法则 f f f，使得 A A A中每一元素 a a a，都有 B B B中唯一确定的一个元素 b b b与之对应，那么称 f f f是集合 A A A到集合 B B B的一个映射，记作
f : A → B , a ↦ b , f ( a ) = b , a ∈ A , \begin{aligned} f:A&amp;\to B,\\ a&amp;\mapsto b,\\ f(a)&amp;=b,\quad a\in A, \end{aligned} f:Aaf(a)​→B,↦b,=b,a∈A,​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bb96c566794c0c7966eefaab47fe7d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e7176ec82f617410a902538ea823466/" rel="bookmark">
			五、Spring AOP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. AOP入口类的添加
2. 匹配Advisor生成代理
2.1 基本概念
2.1.1 Pointcut
2.1.2 Advice
2.1.3 Advisor
2.2 生成代理
2.2.1 找到bean匹配的Advisor
2.2.2如果bean有匹配到Advisor,则为其生成代理对象
3. 被代理方法的执行
3.1 获取被代理方法匹配的增强统一包装成MethodInterceptor
3.2方法调用
3.2.1 Before 增强的调用
3.2.2 After增强的调用
3.2.3 Around增强的调用
3.2.4 AfterReturning增强的调用
3.2.5 AfterThrowing增强的调用
4. 事务切面
4.1开启事务支持
4.1.1 添加AOP入口bean
4.1.2 添加事务advisor
4.2 事务pointCut
4.3事务增强advice
4.3.1 底层JDBC事务
4.3.2 常用事务传播属性
4.3.3 事务代码分析
5. 异步切面
5.1开启异步支持
5.2 异步advisor
5.2.1 异步pointCut
5.2.2 异步advice
5.2.3 bean添加异步advisor
(本篇中用到的演示项目地址：https://gitee.com/yejuan/spring-learning-no-xml 对应tag: spring-c5)
1. AOP入口类的添加 上一篇我们分析到AbstractAutoProxyCreator#postProcessAfterInitialization这个方法中如果bean有匹配到advisor将会生成bean的代理实例。AbstractAutoProxyCreator是一个抽象类，要相关方法得以执行就必须要将其子类并且是实现了BeanPostProcessor接口的子类注册到BeanFactory的List&lt;BeanPostProcessor&gt; beanPostProcessors容器中。
@EnableAspectJAutoProxy通过@Import将AspectJAutoProxyRegistrar加入到spring 容器中，AspectJAutoProxyRegistrar实现了ImportBeanDefinitionRegistrar接口，在registerBeanDefinitions方法中就会将AOP的入口类AnnotationAwareAspectJAutoProxyCreator加入spring容器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e7176ec82f617410a902538ea823466/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c04f22165efbb3b2db868094b27a2468/" rel="bookmark">
			整理了iava新日期LocalDateTime系列类型在springweb中类型转换的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接使用LocalDateTime是接收不到前端发来的日期参数, 可以使用注解@DateTimeFormat
使用jackson也无法转换LocalDateTime, 需要使用@JsonFormat.
除了使用注解, 还有一种配置的方式, 配置过后不需要添加注解直接就能接收到和转换:
jackson转换:
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule; import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer; import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer; import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer; import org.springframework.format.Formatter; import pers.rxiao.accountcommon.constant.LocalDateTimeConstant; import java.time.LocalDate; import java.time.LocalDateTime; import java.time.LocalTime; import java.time.format.DateTimeFormatter; import java.util.Locale; public class LocalDateTimeConfig { /** * localDateTime的序列化和反序列化配置 * * @return 设定好的序列化和反序列化格式 */ public static JavaTimeModule serializerAndDeserializer() { JavaTimeModule javaTimeModule = new JavaTimeModule(); // 序列化 javaTimeModule.addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern("HH:mm:ss"))); javaTimeModule.addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern("yyyy-MM-dd"))); javaTimeModule.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c04f22165efbb3b2db868094b27a2468/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6894e9dcd9af7f4417a04627238155d/" rel="bookmark">
			3D数学-正交投影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 3D数学-正交投影概述正交投影的推导投影矩阵的另一种形式 3D数学-正交投影 好记性不如烂笔头啊，还是记录一下!
概述 正交投影也被称为平行投影，不会出现透视投影的近大远小的扭曲现象，
正交投影的推导 构建正交投影矩阵相对来说会简单一些，由于不存在透视扭曲。
&lt; x e , y e , z e &gt; &lt;x_{e}, y_{e}, z_{e}&gt; &lt;xe​,ye​,ze​&gt;是相机空间中的一个坐标点
&lt; x n , y n , z n &gt; &lt;x_{n}, y_{n}, z_{n}&gt; &lt;xn​,yn​,zn​&gt;表示经过透视投影后在规范化设备坐标系（Normalized Device Coordinates）中的坐标
l l l表示近裁剪平面（near clip plane）的左边，即 x = l x=l x=l
r r r表示近裁剪平面（near clip plane）的右边，即 x = r x=r x=r
t t t表示近裁剪平面（near clip plane）的上边，即 y = t y=t y=t
b b b表示近裁剪平面（near clip plane）的下边，即 y = b y=b y=b
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6894e9dcd9af7f4417a04627238155d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c90376eaf71f2d6fd6abbafcf64186ab/" rel="bookmark">
			sv 中循环的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sv 中循环的实现 sv 中循环和C C++ 中的类似，常用的for while…do
C 中的for int i; for （i=0;i&lt;10;i++） { ..... } 可以使用continue 跳过本次循环中的剩余部分，直接进入下次循环。
int i; for （i=0;i&lt;10;i++） { .... if（i==1） continue; ..... } 可以使用break 跳出循环，放弃剩余的循环执行。
int i; for （i=0;i&lt;10;i++） { .... if（i==1） break; ..... } 可以使用return 跳出函数，放弃剩余的循环执行。
int i; for （i=0;i&lt;10;i++） { .... if（i==1） break; ..... } SV 中的for 循环 int i; for （i=0;i&lt;10;i++） begin ..... end 可以使用continue 跳过本次循环中的剩余部分，直接进入下次循环。
int i; for （i=0;i&lt;10;i++） begin .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c90376eaf71f2d6fd6abbafcf64186ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da190ac55c0e15b67c07a1276e307dc1/" rel="bookmark">
			ubuntu 16.04 /dev/sda1 满了如何清理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用如下命令侦察 df -hl
也可以直接输入以下命令，进入占用比较大的目录看看情况：
sudo du --max-depth=1 --human-readable * | sort --human-numeric-sort * 处 换成相应的目录，一般从 / 开始
2. 找到相应的文件就开始清理了：
文件：sudo rm -f 文件夹： sudo rm -f 3. sudo reboot 走起
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6722a26e0511eb249441edafa33e4fc4/" rel="bookmark">
			JQ实现Table的tr上移下移功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日份需求：实现表格行的上移下移，并更新排序值，效果如下：
话不多说直接上代码，JQ实现挺简单的
HTML代码
&lt;div&gt; &lt;span&gt; &lt;button class="layui-btn" id="doUp"&gt;上移&lt;/button&gt;&lt;button class="layui-btn" id="doDown"&gt;下移&lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;table class="layui-table" style="width: 800px; margin-top: 3px;"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th style="width: 100px; padding: 0px 0px; height: 32px;"&gt;姓名&lt;/th&gt; &lt;th style="width: 100px; padding: 0px 0px; height: 32px;"&gt;联系电话&lt;/th&gt; &lt;th style="width: 20px; padding: 0px 0px; height: 32px;"&gt;排序值&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id="demo"&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;139000000&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;137000000&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;139000000&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;赵六&lt;/td&gt; &lt;td&gt;139000000&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;孙七&lt;/td&gt; &lt;td&gt;139000000&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;周八&lt;/td&gt; &lt;td&gt;139000000&lt;/td&gt; &lt;td&gt;6&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; JQ代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6722a26e0511eb249441edafa33e4fc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ee8acf0ea88392665e7cba088815de2/" rel="bookmark">
			(转载)swift4 sqlite3 数据绑定（sqlite3_bind_text）的坑（逼）！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		swift4 sqlite3 数据绑定（sqlite3_bind_text）的坑（逼）！ 利特星
0.1922018.08.07 20:13:59字数 183阅读 2,045
Xcode9.2
Swift version 4.0.3
sqlite3
sqlite3_bind_text
今天搞数据库，用sqlite3_bind_text插入数据的时候总是错乱
（插入的value顺序、位置不对！且插入的数据部分乱码了！）。
错误代码： let sql = "insert into UserInfo(ACCOUNT,PASSWORD,TOKEN,GETTOKENDATE) values(?,?,?,?)" //... let cstr = text.cString(using: .utf8) sqlite3_bind_text(stmt, Int32(bindIndex), cstr, -1, nil) 但是直接插入，不用绑定就OK let sql = "insert into UserInfo(ACCOUNT,PASSWORD,TOKEN,GETTOKENDATE) values('\(value0)','\(value1)','\(value2)','\(value3)')" 认真检验了几个小时，网上各种查，还是错乱！一直想着是不是这句
let cstr = text.cString(using: .utf8)
导致的类型转换出问题，但swift没别的方法了啊！还很傻的试了.ascii,.unicode，更错。最后没办法了，绝望中，完全不抱希望了，再试试转OC类型
let nsStr = text as! NSString let cstr = nsStr.utf8String sqlite3_bind_text(stmt, Int32(bindIndex), cstr, -1, nil) 结果，T-M-D可以了！！！！
原文链接: https://www.jianshu.com/p/23e31aeb45e5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e75bd503d16f25238fd23a9a1ef34d01/" rel="bookmark">
			kbengine属性同步分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实体的属性是定义在def文件中
属性会有几个不同的flag来表示属性是如何更新的
entitydef/common.h
ALL_CLIENT 属性能被周围的客户端获得，包括自身。相当于同时设置了OWN_CLIENT和OTHER_CLIENT标志。ALL_CLIENTS 同ALL_CLIENTBASE 只能在Base上使用BASE_AND_CLIENT 属性在base和客户端都可见，相当于同时设置了OWN_CLIENT和BASE标志。CELL_PRIVATE entity的内部属性。 只在cell的entity内部可见，相当于私有属性。CELL_PUBLIC 可以被服务端的其它entity访问。在kbe中，现在暂时和CELL_PUBLIC是一样的。CELL_PUBLIC_AND_OWN 在cell上的其它entity可见，对客户端来说，仅自身客户端可见 在entity类中会有宏定义 ENTITY_HEADER
这里将其展开，主要是看其中的onScriptSetAttribute()函数。如果脚本层修改了属性值，会回调onScriptSetAttribute()。（object.__setattr__）
在815行，会调用onDefDataChanged()
679 到 682行 将属性值放到memorystream中去，然后发送
会根据propertyDescription里的flag（看三个if中的判断条件），即def文件中作用域的描述，形成发包，广播到关心这个数据的app里面。
其中同步客户端时会通过socket发送这个数据包到baseapp， baseapp中转到客户端， 客户端根据def描述解析并最终更新到对应实体数据中。
我们看其中广播给其他客户端的
在751行的宏定义展开之后
下面是forwardMessageToClientFromCellapp()的发送片段，会将信息发送给客户端
同时注意到baseapp的entity中也有onDefDataChanged()函数
128行的判断会将不具有ED_FLAG_BASE_AND_CLIENT 的属性数据类型才会发送到客户端。这些属性数据的定义如下
baseapp的属性改变只会发给自己的客户端，而不会广播
cellapp有广播的可能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c5580159b3ac01ace51fecc99a7c049/" rel="bookmark">
			bios uefi 区别_UEFI vs BIOS：有何区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bios uefi 区别
So you might have heard the acronyms BIOS and UEFI thrown around, especially when trying to switch Operating Systems or messing around with overclocking. 因此，您可能听说过BIOS和UEFI的首字母缩写词，尤其是在尝试切换操作系统或搞乱超频时。 And you might know what these acronyms stand for (Unified Extensible Firmware Interface and Basic Input/Output System, respectively). But have you ever wondered how they're used in a computer system? 您可能知道这些首字母缩写的含义(分别是统一可扩展固件接口和基本输入/输出系统)。 但是您是否想知道它们如何在计算机系统中使用？ Let's demystify these terms and their meanings now.
让我们现在揭开这些术语及其含义的神秘面纱。 开机程序 (Boot Procedure) First things first – I know we're deviating from the topic, but I promise this will help you with some concepts later on.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c5580159b3ac01ace51fecc99a7c049/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc36f561710241d543e758f0806bfd86/" rel="bookmark">
			kbengine移动同步分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在kbengine.cs中，可以看到存在这样一个函数
在1394行 可以看到会调用baseapp::onUpdateDataFromClient()
4618行调用了cellapp:: onUpdateDataFromClient()
从baseapp:: onUpdateDataFromClient()到cellapp:: onUpdateDataFromClient()
1502行实际上调用了Entity:: onUpdateDataFromClient()
下面还有一长段检查就没截图了。走到这发现好像就是更新了位置，AOI没有处理啊。实际上这里隐蔽在于要到position函数里
2017行进到EntityCoordinateNode:: update()
355行到CoordinateNode::update()
会在52行到coordinateSystem::update()
这里注意的是moveNodeX这个函数，后面的y,z都是相似的。主要看的是moveNodeX的后半段，以下是moveNodeX的后半段
看到这有onNodePassX()，查找到coordinate_node.h
然后你会发现coordinate_node.h关于onNodePassX()啥都没有，好在它们是虚函数。所以就要看coordinate_node的继承类。
这就是它们几个关联类之间的关系
在coordinateNode的继承类中找啊找，发现在RangeTriggerNode类有重写onNodePassX()，进去查看
原来最后的实现用的是RangeTrigger:: onNodePassX，
这里先不管判断逻辑，反正最后要不什么都没发生，直接return，要么执行onEnter或者onLeave
发现在RangeTrigger里onEnter和onLeave是纯虚函数，又要查看其子类
先看viewTrigger的onEnter
这里会发现最后会调用witness的onEnterView()
witness的onEnterView()就是处理AOI的
AOI在服务端处理处理好了，那么客户端是怎么知道呢？
找了半天，也没找到
后来又结合前面login过程想，突然惊醒，就是计时器啊，handleTimeout。
理清这个关系，就是cellapp::handleTimeout -&gt; EntityApp&lt;Entity&gt;::handleTimeout -&gt; cellapp::handleGameTick
主要看cellapp::handleGameTick，其中
1、UpdateLoad() 是更新cellapp上的负载情况
2、SpaceMemorys::update()是用来更新space的memory情况
那么updatables_.update()是干什么呢？首先就要明白updatables_是什么，updatables是updatable的集合，updatables_.update()就是对集合中的每一个updatable进行update操作
那么updatable的update是干啥呢
它是一个纯虚函数，那么具体实现肯定要找到它的子类了。
走到这，就要猜一猜了。现在和AOI有关系就那么几个类，前面是走到witness的onEnterView断了，就看看witness类。
果不其然
Witness继承了updatable。再看看其对update()的实现
（截取了一部分）
看其中的for循环中的if，else if
witness是用来监视拥有者玩家内的视野范围的玩家（AOI），负责同步视野范围其他玩家的客户端数据及位置信息。有三种状态1、（将要进入视野范围内）：其他玩家进入拥有者玩家的视野范围，那么将其他玩家在拥有者玩家的Witness里的引用的状态更改成普通状态，并同步其他玩家的客户端信息与位置信息给拥有者玩家，通知拥有者玩家有其他玩家进入视野范围
2、（将要离开视野范围内）：其他玩家离开拥有者玩家的视野范围，那么通知拥有者玩家有其他玩家要离开，并删除其他玩家在拥有者玩家的Witness里的引用
3、（普通状态，还在视野范围内），同步还在视野范围的其他玩家的信息给拥有者玩家
在update中会不断的将这些信息传递给客户端
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/761c6169b604b33fefa63ca36f926f70/" rel="bookmark">
			gitlab配置https方式访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. mkdir /etc/gitlab/ssl #创建ssl证书目录
2.上传证书
3.配置gitlab
#vim /etc/gitlab/gitlab.rb external_url 'https://cloud.cn' nginx['enable'] = true nginx['redirect_http_to_https'] = true #http重定向到https nginx['redirect_http_to_https_port'] = 80 nginx['redirect_http_to_https'] = true #http重定向到https，使用http的访问会自动重定向到https； nginx['redirect_http_to_https_port'] = 80 4修改nginx配置
vim /var/opt/gitlab/nginx/conf/gitlab-http.conf #修改 ssl_certificate /etc/gitlab/ssl/ ssl_certificate_key /etc/gitlab/ssl/ vim /var/opt/gitlab/nginx/conf/gitlab-registry.conf #修改 ssl_certificate /etc/gitlab/ssl/ ssl_certificate_key /etc/gitlab/ssl/ 重启gitlab！！！
gitlab-ctl restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27f606be98978e06171b507febb04489/" rel="bookmark">
			一个人做饭简单食谱_通过这5条简单食谱学习SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个人做饭简单食谱
SQL (Structured Query Language) is a powerful and expressive language for dealing with data from relational databases. But it can seem daunting to the uninitiated.
SQL(结构化查询语言)是一种功能强大的表达性语言，用于处理关系数据库中的数据。 但是对于初学者来说，这似乎令人生畏。 The "recipes" I'm going to share with you today are some basic examples from a simple database. But the patterns you'll learn here can help you write precise queries. These will have you feeling like the data equivalent of a MasterChef in no time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27f606be98978e06171b507febb04489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c28e6f7a330f61237be9d7cbb40792e1/" rel="bookmark">
			mac启动pg数据库失败 “Is another postmaster (PID 370) running in data directory“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决办法: 进入目录 /usr/local/var/postgres删除文件: postmaster.pid启动pg命令: pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start 图片参考: 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1098d54dbe1fb4fc4e79b63d2a648902/" rel="bookmark">
			AFX_MANAGE_STATE(AfxGetStaticModuleState()) 与AfxGetResourceHandle()不能混用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新框架调用时一直关闭时报错，一个用的AFX_MANAGE_STATE(AfxGetStaticModuleState());来加载资源，一个就用的下面的来加载导致报错，换成一样的而就行了。使用AFX_MANAGE_STATE(AfxGetStaticModuleState())来加载资源是有些类用这个来加载才行。
HINSTANCE save_hInstance = AfxGetResourceHandle();
AfxSetResourceHandle(theApp.m_hInstance);
。。。。。
AfxSetResourceHandle(save_hInstance);
extern "C" _declspec(dllexport) BOOL XXXX(CMainFrame *pWnd)
{
AFX_MANAGE_STATE(AfxGetStaticModuleState());
BaseDlg *pDlg = (BaseDlg *)CDialogSize::GetInstance(MAKECLASS(BaseDlg));
if(pDlg == NULL)
{
pDlg = new BaseDlg(pWnd);
pDlg-&gt;Create(BaseDlg::IDD,NULL);
pDlg-&gt;ShowWindow(SW_SHOW);
}
return TRUE;
}
extern "C" _declspec(dllexport) void close(void)
{
AFX_MANAGE_STATE(AfxGetStaticModuleState());
CDialogEx *pDlg = BaseDlg::GetInstance();
if(pDlg != NULL)
pDlg-&gt;DestroyWindow();
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2c8cdae44e94fb2781fcacc13023dd8/" rel="bookmark">
			Ubuntu16.04系统联网（连接WiFi）设置（亲测有效！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu16.04系统联网设置 前言联网设置网络连接测试联网是否成功如果网络还未连接，请继续以下操作： 前言 安装完Ubuntu系统之后，当然是要愉快的联网玩耍啦！如果你的主机连的是 WiFi ，但是虚拟机连不到网怎么办？这里分享一个亲测有效的方法。
联网设置 网络连接 点击 “ 编辑 ” - - &gt; “ 虚拟网络编辑器 ”。如下所示：
之后出现如下界面，点击 “ 更改设置 ”。如下所示：
之后出现如下界面，点击 “ VMnet0 ” - - &gt; “ 桥接模式 ”，把 “ 桥接至 - - &gt; 自动 ” 改为外部计算机（即主机）的无线网卡，然后点击 “ 确定 ” 。如下所示：
注意：不清楚自己的无线网卡是哪个的，可在 “ 控制面板 - -&gt; 网络和Internet - -&gt; 网络连接 ” 里查看自己的网卡。如下所示：
然后点击 “ 虚拟机 ” - - &gt; “ 设置 ”，如下所示：
之后出现如下界面，点击 “ 网络适配器 ” 选择 “ 桥接模式 ” 并且不勾选 “ 复制物理网络连接状态 ”，点击确定。如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2c8cdae44e94fb2781fcacc13023dd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4589f7138e7bce002ea706498f75cc1/" rel="bookmark">
			leetcode_529_扫雷游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫雷游戏 描述 让我们一起来玩扫雷游戏！
给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，‘E’ 代表一个未挖出的空方块，‘B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（‘1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，‘X’ 则表示一个已挖出的地雷。
现在给出在所有未挖出的方块中（‘M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：
如果一个地雷（‘M’）被挖出，游戏就结束了- 把它改为 ‘X’。如果一个没有相邻地雷的空方块（‘E’）被挖出，修改它为（‘B’），并且所有和其相邻的未挖出方块都应该被递归地揭露。如果一个至少与一个地雷相邻的空方块（‘E’）被挖出，修改它为数字（‘1’到’8’），表示相邻地雷的数量。如果在此次点击中，若无更多方块可被揭露，则返回面板。 示例 1：
输入: [['E', 'E', 'E', 'E', 'E'], ['E', 'E', 'M', 'E', 'E'], ['E', 'E', 'E', 'E', 'E'], ['E', 'E', 'E', 'E', 'E']] Click : [3,0] 输出: [['B', '1', 'E', '1', 'B'], ['B', '1', 'M', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B']] 解释: 示例 2：
输入: [['B', '1', 'E', '1', 'B'], ['B', '1', 'M', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B']] Click : [1,2] 输出: [['B', '1', 'E', '1', 'B'], ['B', '1', 'X', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B']] 解释: 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4589f7138e7bce002ea706498f75cc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7d576a611838cb920dfb9cdfb5a02fc/" rel="bookmark">
			Java ActiveMQ：（八）在案例中处理对象消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在案例中处理对象消息 1.定义消息对象2.创建生产者3.定义消息消费者4.测试4.1 Producer4.2 Consumer 1.定义消息对象 创建两个Maven项目一个是Producer，一个是Consumer，而后在每个项目中定义Users记得在POM文件中导入ActiveMQ的坐标 import java.io.Serializable; public class Users implements Serializable { private int userid; private String username; private int userage; public int getUserid() { return userid; } public void setUserid(int userid) { this.userid = userid; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public int getUserage() { return userage; } public void setUserage(int userage) { this.userage = userage; } @Override public String toString() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7d576a611838cb920dfb9cdfb5a02fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64503594896be6b6a5dc25132342ab3d/" rel="bookmark">
			模型压缩和加速方法总结和文献综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文集中了一些针对模型压缩和技巧，用于加快计算速度的论文。 如下所示，模型压缩具有不同的技术，在这里我将主要列出深度学习网络部分。
1. Review papers，综述文章 以下是推荐用于模型压缩和加速的几篇论文。
Cheng Yu et al., A survey of model compression and acceleration for deep neural networks, 2017.
Cheng Jian et al., Recent advances in efficient computation of deep convolutional neural networks, 2018.
Deng Yunbin, Deep learning on mobile devices: a review, 2019.
Choudhary, Tejalal et al., A comprehensive survey on model compression and acceleration, 2020.
2. Model compression and speedup approaches，模型压缩和加速方法 上面的综述论文有一些重叠的领域，因此在本节中，我将调查分为以下几类。 除了下面的方法，Chen等还试图通过硬件加速器来加快速度。 这些方法大多数都是独立设计的，并且相互补充。 例如，转移的层和参数修剪与量化可以一起部署。 另一个例子是，模型量化和二值化可以与低秩近似一起使用，以实现进一步的压缩/加速。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64503594896be6b6a5dc25132342ab3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97891136280c2c5a1ece638b55087074/" rel="bookmark">
			数据增强：图片加雾效果实现Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像处理中多数算法为去雾算法，所以写了个加雾的算法，加雾效果如下：
直接请上代码：
import cv2, math import numpy as np def demo(): img_path = 'test.png' img = cv2.imread(img_path) img_f = img / 255.0 (row, col, chs) = img.shape A = 0.5 # 亮度 beta = 0.08 # 雾的浓度 size = math.sqrt(max(row, col)) # 雾化尺寸 center = (row // 2, col // 2) # 雾化中心 for j in range(row): for l in range(col): d = -0.04 * math.sqrt((j-center[0])**2 + (l-center[1])**2) + size td = math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97891136280c2c5a1ece638b55087074/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4595b135f2554cb7ac4b9fb47d1b5836/" rel="bookmark">
			数据增强：模拟雨天算法Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在opencv中，可以利用随机噪声、滤波器等方法为图像叠加仿真的雨滴的运动轨迹，使通常情况下拍摄的图像有了烟雨蒙蒙的效果。
1.生成随机噪声
首先，我们需要生成不同密度的随机噪声来模拟不同大小的余量，于是利用了下面的函数来生成。主要的使用了均匀随机数和阈值来控制噪声的水平。由于生成噪声是浮点数，所以在value上乘了尺度缩小因子。
import cv2 import numpy as np def get_noise(img, value=10): ''' #生成噪声图像 &gt;&gt;&gt; 输入： img图像 value= 大小控制雨滴的多少 &gt;&gt;&gt; 返回图像大小的模糊噪声图像 ''' noise = np.random.uniform(0, 256, img.shape[0:2]) # 控制噪声水平，取浮点数，只保留最大的一部分作为噪声 v = value * 0.01 noise[np.where(noise &lt; (256 - v))] = 0 # 噪声做初次模糊 k = np.array([[0, 0.1, 0], [0.1, 8, 0.1], [0, 0.1, 0]]) noise = cv2.filter2D(noise, -1, k) # 可以输出噪声看看 '''cv2.imshow('img',noise) cv2.waitKey() cv2.destroyWindow('img')''' return noise 原始噪声如如左图，加上了k之后的初次高斯噪声图如右图(可点击放大查看)：
2.生成雨滴模糊噪声
随后，需要对噪声拉长、旋转方向，模拟不同大小和方向的雨水。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4595b135f2554cb7ac4b9fb47d1b5836/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833435ddb11104515823b34b4cd72f9b/" rel="bookmark">
			是什么让Lisp宏如此特别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文翻译自：What makes Lisp macros so special?
Reading Paul Graham's essays on programming languages one would think that Lisp macros are the only way to go. 阅读Paul Graham关于编程语言的论文 ，人们会认为Lisp宏是唯一可行的方法。 As a busy developer, working on other platforms, I have not had the privilege of using Lisp macros. 作为一个忙于开发人员，在其他平台上工作，我没有使用Lisp宏的特权。 As someone who wants to understand the buzz, please explain what makes this feature so powerful. 作为想要了解嗡嗡声的人，请解释是什么让这个功能如此强大。 Please also relate this to something I would understand from the worlds of Python, Java, C# or C development.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833435ddb11104515823b34b4cd72f9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/725ffe79c56e3cde55d8c1c6b288bbee/" rel="bookmark">
			如何以编程方式退出android应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文翻译自：How to quit android application programmatically
I Found some codes for quit an Android application programatically. 我找到了一些以编程方式退出Android应用程序的代码。 By calling any one of the following code in onDestroy() will it quit application entirely? 通过在onDestroy（）中调用以下任何一个代码，它会完全退出应用程序吗？ System.runFinalizersOnExit(true) (OR) （要么） android.os.Process.killProcess(android.os.Process.myPid()); I dont want to run my application in background after clicking quit button. 我不想在单击退出按钮后在后台运行我的应用程序。 Pls suggest me can i use any one of these code to quit my app? 请问我可以使用这些代码中的任何一个来退出我的应用程序吗？ If so which code can i use?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/725ffe79c56e3cde55d8c1c6b288bbee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b68a080cb05aebbe58bb2a53e7ab4da9/" rel="bookmark">
			微信小程序二级联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;view class="l-header _div"&gt;
&lt;view class="l-nav _ul"&gt;
&lt;view class="_li {{issortActive?'active':''}}" bindtap="sort"&gt;
{{changeSortName}}
&lt;/view&gt;
&lt;view class="_li {{islevelActive?'active':''}}" bindtap="level"&gt;
{{changeLevelName}}
&lt;/view&gt;
&lt;/view&gt;
&lt;view class="l-screen _div"&gt;
&lt;view class="l-step l-filtration _ul" style="height:auto;overflow:auto;" hidden="{{!issortActive}}"&gt;
&lt;view class="_li {{index==current?'active':''}}" wx:for="{{sortContent}}"&gt; {{item.typeName}} &lt;/view&gt;
&lt;/view&gt;
&lt;view class="l-area l-filtration _ul" hidden="{{!islevelActive}}"&gt;
&lt;view class="_li {{index==currentLevel?'active':''}}" wx:for="{{levelContent}}" v-on:click="changeLeveItem(index)"&gt;{{item.name}}&lt;/view&gt;
&lt;/view&gt;
&lt;/view&gt;
&lt;/view&gt;
&lt;view class="i-shade _div" hidden="{{mask}}" bindtap="closeall"&gt;&lt;/view&gt;
const app = getApp()
Page({
data: {
issortActive:false,
islevelActive:false,
sortShow:false,
levelShow:false,
mask:true,
changeSortName:"类别",
changeLevelName:"级别",
sortContent: [
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b68a080cb05aebbe58bb2a53e7ab4da9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dcfb3485ba9fcaf908dc3bb668d3f6a/" rel="bookmark">
			SPSS数据分析-交叉表分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交叉表(交叉列联表) 分析法是一种以表格的形式同时描述两个或多个变量的联合分布及其结果的统计分析方法，此表格反映了这些只有有限分类或取值的离散变量的联合分布。
当交叉表只涉及两个定类变量时，交叉表又叫做相依表。
交叉列联表分析易于理解，便于解释，操作简单却可以解释比较复杂的现象，因而在市场调查中应用非常广泛。
频数分布一次描述一个变量，交叉表可同时描述两个或更多变量。
交叉表法的起点是单变量数据，然后依研究目的将这些数据分成两个或多个细目。
交叉表是一种行列交叉的分类汇总表格，行和列上至少各有一个分类变量，在行和列的交叉处可以对数据进行多种汇总计算，例如：求和、求平均值、计数等。
步骤：
单击分析，选择描述统计，然后选中描述交叉表模块，弹出交叉表的选项窗口
在【交叉表】中，将Q13婚姻状况 移至【行】框中，将Q2性别 移至【列】框中。
【单元格】按钮，弹出【交叉表：单元格显示】对话框。
SPSS默认选中【实测】（即实际值），我们还可以勾选【百分比】下的【列】复选框，以显示百分比，行百分比和总计百分比可根据分析的需要进行选择。其他选择与描述性分析的关系不大，故在此不做选择。
单击【继续】，返回【交叉表】对话框，单击下方【确定】，输出结果如下图：
个案处理摘要：
对个案进行汇总，显示有效个案数和数量与百分比。
从交叉表中我们可以看到，在四种婚姻状况中，“未婚单身”占比45.2%，所占比重最大；其次是“已婚已育”，占比27.5%，在此基础上增加性别角度，进一步查看数据的分布，在四种婚姻状况男、女的比例较为平衡。 数据参照来源：《谁说菜鸟不会数据分析之SPSS篇》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3a32a91ee49a9ba8970064f3efd6198/" rel="bookmark">
			docker中启动mysql容器并用Navicat 进行连接docker 中mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动docker mysql容器 1.确认将MySQL镜像拉倒docker中，检查命令
docker images 或者 docker image ls 2.启动mysql容器
docker run -d --name 容器名(自定义) -v 宿主机路径:mysql镜像中mysql的路径 -e MYSQL_ROOT_PASSWORD=123456 -p 33016:3306 mysql:5.9 例子： docker run -d --name dockermysql -v /dvol/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -p 33016:3306 mysql:5.9 解释： -v /dvol/mysql:/var/lib/mysql 数据同步到宿主机 -p 33016:3306 把容器内的33006端口映射到宿主机3306端口 -e MYSQL_ROOT_PASSWORD=123456 MySQL 的用户名（root）密码123456 本地(docker内)连接mysql 1.查看mysql容器ID
docker ps -a 2.进入mysql容器
docker exec -it 容器ID /bin/bash 例子： docker exec -it ba7a93aae2a8 /bin/bash 解释： -i :即使没有附加也保持STDIN 打开 -t :分配一个伪终端 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3a32a91ee49a9ba8970064f3efd6198/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbdda120dad8fb6610cebfb8f062cce0/" rel="bookmark">
			定积分的性质——积分中值定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 积分中值定理 积分第一中值定理几何意义推广的积分第一中值定理 积分第二中值定理推论 积分第一中值定理 几何意义 推广的积分第一中值定理 积分第二中值定理 推论 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/081bc82c2d705bb41858fe00135a051c/" rel="bookmark">
			利用MATLAB计算级数之和与泰勒级数的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘要1 级数求和1.1 MATLAB级数求和函数1.2 级数求和应用实例1.3 特例 2 泰勒级数2.1 泰勒级数函数的调用2.2 泰勒级数的应用 结语 摘要 本文是《科学计算与MATLAB语言》专题七第3小节的学习笔记，如果大家有时间的话，可以去听听课，没有的话，可以看看我的笔记，还是很不错的。本节主要讲了如何利用MATLAB求级数之和以及泰勒级数如何计算，文中每个代码我都跑过一遍，可以直接复制到MATLAB中运行。
1 级数求和 1.1 MATLAB级数求和函数 求无穷级数的和需要符号表达式求和函数symsum（），其调用格式为：
symsum（s，v，n，m）
其中，s表示一个级数的通项，是一个符号表达式。v是求和变量，v省略时使用系统的默认变量。n和m是求和变量v的初值和末值。
银行利率的计算问题
例1 求下列级数之和。
(1) S 1 = 1 + 4 + 9 + 16 + … + 10000 S_1=1+4+9+16+…+10000 S1​=1+4+9+16+…+10000
(2) S 2 = 1 − 1 2 + 1 3 − 1 4 + . . . + ( − 1 ) n + 1 1 n . .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/081bc82c2d705bb41858fe00135a051c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5265393385b46880ce96055aa5aa6ab0/" rel="bookmark">
			车 题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		车 题解 车
题目 在 n n n* n n n( n n n≤20)的方格棋盘上放置 n n n个车(可以攻击所在行、列)，有些格子不能放,求使它们不能互相攻击的方案总数。
输入 第一行为棋盘的大小 n n n
第二行为障碍的数量 m m m
第三行到第 m m m+3为 m m m个障碍
输出 总数
样例 input
4
2
1 1
2 2
output
14
解题思路 状压DP
用二进制表示某种状态
在本题
0表示可放，1表示不可放
移位存储所有不可以放的位置
枚举所有状态
再枚举这个状态1在的位置
判断是否能放
能放就更新答案
代码 #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; long long n,m,x,y,f[2000100],p[30]; int main() { scanf("%lld%lld",&amp;n,&amp;m); for (int i=1;i&lt;=m;i++) { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5265393385b46880ce96055aa5aa6ab0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/351bb9173043710c41f3d5ab1bff29a9/" rel="bookmark">
			简单题--剑指 Offer 09. 用两个栈实现队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		力扣刷题
用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
示例 1：
输入：
[“CQueue”,“appendTail”,“deleteHead”,“deleteHead”]
[[],[3],[],[]]
输出：[null,null,3,-1]
示例 2：
输入：
[“CQueue”,“deleteHead”,“appendTail”,“appendTail”,“deleteHead”,“deleteHead”]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
提示：
1 &lt;= values &lt;= 10000
最多会对 appendTail、deleteHead 进行 10000 次调用
解题思路：
var CQueue = function () { // 1、设置两个栈 堆是 stack this.warehouse1 = []; this.warehouse2 = []; }; // 2、写一个函数实现 队列尾插入整数 // 为啥写出了prototype? 指的是从原型链出发 // 将value 压入 第一个栈 warehouse1中 CQueue.prototype.appendTail = function (value) { this.warehouse1.push(value); }; CQueue.prototype.deleteHead = function () { // 实现warehouse2 出栈操作 if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/351bb9173043710c41f3d5ab1bff29a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/425617b6919aa1021e537f7657e9ac79/" rel="bookmark">
			CentOS7 一个网卡配置多个IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS7 一个网卡配置多个IP地址 1、给网卡p8p1新创建配置文件（复制原来的p8p1，修改IP地址即可）
ifcfg-p8p1:0
vim /etc/sysconfig/network-scripts/ifcfg-p8p1:0
DEVICE="ifcfg-p8p1:0"
BOOTPROTO="static"
IPADDR=10.0.2.9
NETMASK=255.255.255.0
GATEWAY=10.0.2.1
ONBOOT="yes"
2、启动网卡
ifup p8p1:0
转发：https://www.cnblogs.com/dwj192/p/12021239.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555d81291fa391f8bf87990a2116dd6c/" rel="bookmark">
			QQ登录测试用例【练习】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94da31e3848e835a1ee3b7de908d64cd/" rel="bookmark">
			等价类划分和边界值法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 测试用例 指为特定的目的而设计的一组测试输入、执行条件和预期的结果，以便测试是否满足某个特定需求。通过大量的测试用例来检验软件的运行效果，它是指导测试工作进行的依据。（测什么，怎么测）
等价类划分法 一种黑盒测试方法，不考虑程序的内部结构，只考虑程序的输入规格即可。将不能穷举的测试过程进行合理分类，从而保证设计出来的测试用例具有完整性和代表性
有效等价类：符合《需求规格说明书》，输入合理的数据集合
无效等价类：不符合《需求规格说明书》，输入不合理的数据集合
等价类思考步骤：
1、先确定有效和无效等价类
2、有效等价类就是题目条件（两端的极值（边界值）要判断、中间随意一个值也要判断）
3、无效等价类先划分与条件相反的情况，再找到特殊情况（中文、英文、符号、空格、空）
测试某一个内容是否正确，要把其他的内容输入正确的值；根据需求判断预期结果
等价类细节：1、考虑输入长度 2、考虑输入细节 3、组成原则 4、是否为空 5、是否区分大小写 6、是否重复 7、是否去除空格
边界值 上点：边界上的点，闭内开外（闭指域的边界是封闭的，即闭区间；开指域的边界是开放的，即开区间）。
离点：离上点最近的点称为离点。开内闭外。
内点：域范围内的任意一点。
（解释：对开区间，范围不包括边界，上点是在范围之外的，所以需要再测一个在范围之内，又离上点最近的点，这个值就是范围内离上点最近的点。）
边界值和等价类划分法的关系 等价类划分法：将测试过程中的输入、输出、操作等相似内容分组，从每组中挑选具有代表性的内容作为测试用例，划分为有效等价类和无效等价类；
边界值分析法：确认输入、输出的边界，然后取刚好等于、大于、小于边界的参数作为测试用例测试；
边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。
实践中，由于大量的错误发生在输入、输出值的边界上，所以，对于各种边界值进行测试用例的设计，可以查出更多的错误。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d869e3b68b9f2172585006e7a1d1c57c/" rel="bookmark">
			天天刷leetcode——动态规划（子串们的故事）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		647. 回文子串 解题思路 1. 暴力求解 def countSubstrings(self, s: str) -&gt; int: res = 0 def cal(s): if s[::-1] == s: return 1 else: return 0 for i in range(len(s)): for j in range(i,len(s)): target = s[i:j+1] res += cal(target) return res 时间复杂度 O （ n 3 ） O（n^3） O（n3）真高呀
2. 动态规划 d p [ i ] [ j ] dp[i][j] dp[i][j] 表示字符串 s [ i , j ] s[i,j] s[i,j]是否是回文子串。 j &lt; = i j&lt;=i j&lt;=i，求回文子串数量也就是，也就是求对角线上面1的数量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d869e3b68b9f2172585006e7a1d1c57c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acffd853ba223a567f9b8a2da1037460/" rel="bookmark">
			IntelliJ IDEA 2020.2发布，诸多亮点助提效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		向工具人致敬。本文已被 https://www.yourbatman.cn 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的专栏供以免费学习。关注公众号【BAT的乌托邦】逐个击破，深入掌握，拒绝浅尝辄止。
目录 前言正文what’s new（新特性）1、支持Java 152、相关问题内嵌提示3、运行时异常原因分析4、更好Stream API自动补全5、Live Templates新增Java分组6、新增Problems窗口7、操作意图预览8、改进的拼写检查9、完整的GitHub pull requests支持10、改进的Git操作对话框11、支持Jakarta EE 912、创建企业项目向导12、HPROF内存查看器12、使用预先构建好的indexes13、正在索引中也可编码14、支持Maven Wrapper15、其它 升级建议总结推荐你看： 关注A哥 前言 各位小伙伴大家好，我是A哥。IDEA上个较大版本的发布，要追溯到4月份了：
时隔近4个月，北京时间2020-07-28深夜，IntelliJ IDEA再迎更新，这是2020年的第二个里程碑版本。
之前提到过，2020年是Jetbrain公司的20周年（小伙子长成大男孩了），有理由相信官方会立些Flag。所以自从官方在2020-01-20发布了其2020年的Roadmap后，我个人是有保持持续关注的，毕竟一方面是公司20周年，另一方面是21世纪的“新10年”，这么好的契机很适合搞事情。
上个版本（2020.1）发布后，带来了众多实用新特性，比如：中文支持、禅模式、Javadoc渲染等等，某些新功能可以显著提高效率，因此反响是一片叫好。无独有偶，作为2020年的第二个里程碑版本，它能给我们带来什么样的期许呢？
正文 按照惯例，来一张最新版IDEA启动图尝尝鲜：
我把2020.1版本启动图也扔在这供你对比，哪个更好看？
what’s new（新特性） IntelliJ IDEA 2020.2做的改进重点体现在完全控制GitHub请求，包括在IDE中审查、合并 GitHub PR等。同时还提供了对Java15、Jakarta EE 9的支持，还包括Quarkus、microaut等等。
1、支持Java 15 尽管Java 15将在9月发布，IntelliJ IDEA 2020.2已经提前为此做好了准备，反应不可为不灵活，给个大大的赞👍。
说明：Java 15新特性啥的本文不提，毕竟这不是本文关注点所在
题外话：从JDK9之后，Oracle采用了新的发布周期：每6个月发布一个版本，每3年发布一个LTS版本。JDK15是继JDK9之后发布的第七个版本， 该版本依旧为非LTS版本，最新的LTS版本为JDK11（JDK17还未发布）。
2、相关问题内嵌提示 这个功能非常好用，特别对有些不使用RENAME功能的小伙伴来说是福音。
如果您通过更改具有外部使用的类、方法或字段的签名而引入了编译错误，IDE将用镶嵌提示通知您。单击相关嵌入提示，IDE将自动帮你打开Find工具窗口，列出了在外部文件中发生的所有相关问题。
看完这段话是不是还有点蒙，来吧，A哥给你准备了示例：
Person.java文件：
public class Person { public String eat(String food) { return "SUCCESS"; } } Demo.java文件：
public class Demo { public static void main(String[] args) { new Person().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acffd853ba223a567f9b8a2da1037460/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85230e5059ae12a35497e0a17f1bb544/" rel="bookmark">
			boundRect.tl和boundRect.br什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		boundRect.tl和boundRect.br什么意思？ 在opencv中boundingRect的用法:
1、boundingRect函数
函数作用：
计算轮廓的垂直边界最小矩形，矩形是与图像上下边界平行
2、boundingRect函数调用形式
C++: Rect boundingRect(InputArray points)
points 读入的参数必须是vector或者Mat点集
但是
rectangle(drawing, boundRect[i].tl(), boundRect[i].br(), color, 2, 8, 0); boundRect[i].tl()， boundRect[i].br()指矩形的左上点和右下点,从而调用rectangle()函数绘制矩形。
tl——&gt; top、left
br——&gt;right、bottom
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36873f51d5df4ec07ba1a6119ca1ca80/" rel="bookmark">
			【SSL1382】车
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description 在n*n(n≤20)的方格棋盘上放置n个车(可以攻击所在行、列)，有些格子不能放,求使它们不能互相攻击的方案总数。
Input 第一行为棋盘的大小n
第二行为障碍的数量m
第三行到第m+3为m个障碍
Output 总数
Sample Input 4 2 1 1 2 2 Sample Output 14 思路：
我们可以设 f [ i ] [ j ] f[i][j] f[i][j]为当前第 i , j i,j i,j这个位置放的答案，虽然这样可行，但我们想到可以优化，那就是状压DP
状压DP就是把维数降一，把其中一维用二进制表示，转换成十进制存到数组里
那我们思考这道题怎么状压
我们用 a a a数组表示这一行障碍的状态，则它的转移就是
a [ x ] + = p o w [ y − 1 ] a[x]+=pow_[y-1] a[x]+=pow[​y−1]
其中 p o w pow pow代表二的几次方（注意：我们这里是从右到左看）
接下来我们考虑怎样转移：
首先我们要枚举它所有的状态个数，即 p o w [ n ] − 1 pow[n]-1 pow[n]−1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36873f51d5df4ec07ba1a6119ca1ca80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/120adf85f93c5cbf8ef4d9acbdc445aa/" rel="bookmark">
			轻量化网络：MobileNet-V2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MobileNet-V2 基本情况
创新点：
正文：
MobileNet-V2网络结构
MobileNet-V2 基本情况 《Inverted Residuals and Linear Bottlenecks: Mobile Networks for Classification, Detection and Segmentation》于2018年1月公开在arXiv(美[ˈɑ:rkaɪv]) ：https://arxiv.org/abs/1801.04381MobileNetV2是对MobileNetV1的改进，同样是一个轻量化卷积神经网络。 创新点： 1. Inverted residuals，通常的residuals block是先经过一个1*1的Conv layer，把feature map的通道数“压”下来，再经过3*3 Conv layer，最后经过一个1*1 的Conv layer，将feature map 通道数再“扩张”回去。即先“压缩”，最后“扩张”回去。
而 inverted residuals就是 先“扩张”，最后“压缩”。为什么这么做呢？请往下看。
2.Linear bottlenecks，为了避免Relu对特征的破坏，在residual block的Eltwise sum之前的那个 1*1 Conv 不再采用Relu，为什么？请往下看。
创新点全写在论文标题上了！
由于才疏学浅，对本论文理论部分不太明白，所以选取文中重要结论来说明MobileNet-V2。
先看看MobileNetV2 和 V1之间有啥不同
（原图链接）
主要是两点：
Depth-wise convolution之前多了一个1*1的“扩张”层，目的是为了提升通道数，获得更多特征；最后不采用Relu，而是Linear，目的是防止Relu破坏特征。 再看看MobileNetV2的block 与ResNet 的block：
（原图链接）
主要不同之处就在于，ResNet是：压缩”→“卷积提特征”→“扩张”，MobileNetV2则是Inverted residuals,即：“扩张”→“卷积提特征”→ “压缩”
正文： MobileNet-V1 最大的特点就是采用depth-wise separable convolution来减少运算量以及参数量，而在网络结构上，没有采用shortcut的方式。
Resnet及Densenet等一系列采用shortcut的网络的成功，表明了shortcut是个非常好的东西，于是MobileNet-V2就将这个好东西拿来用。
拿来主义，最重要的就是要结合自身的特点，MobileNet的特点就是depth-wise separable convolution，但是直接把depth-wise separable convolution应用到 residual block中，会碰到如下问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/120adf85f93c5cbf8ef4d9acbdc445aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd456d58589ef1fab74f0228128fc1b/" rel="bookmark">
			线程池ThreadPoolExecutor--Executors.newFixedThreadPool()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程池ThreadPoolExecutor
我们可以使用Executor工厂类Executors快速的获取一个ThreadPoolExecutor
ExecutorService executorService = Executors.newFixedThreadPool(10); 但是如果我们安装了Alibaba Java Coding Guidelines插件会提示我们
线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这
样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
说明：Executors 返回的线程池对象的弊端如下：
1） FixedThreadPool 和 SingleThreadPool：
允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。
2） CachedThreadPool：
允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。
那么为什么不允许使用Executors去创建呢？首先看newFixedThreadPool方法的实现
public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); } 可以看出创建了一个ThreadPoolExecutor类，核心线程池数量和最大线程池数量都是我们初始化的值，但是要注意阻塞队列使用的是new LinkedBlockingQueue() 是一个链表阻塞队列，再去看看链表阻塞队列的构造方法
public LinkedBlockingQueue() { this(Integer.MAX_VALUE); } public LinkedBlockingQueue(int capacity) { if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity; last = head = new Node&lt;E&gt;(null); } 链表的长度达到了默认的Integer的最大值。而再看看ThreadPoolExecutor的execute方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dd456d58589ef1fab74f0228128fc1b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/355/">«</a>
	<span class="pagination__item pagination__item--current">356/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/357/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>