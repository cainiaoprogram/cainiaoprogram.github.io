<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fc7273c0db8104d256d68b7691b4246/" rel="bookmark">
			Mac M1 安装gitlab——访问本地端口失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker已经有明显的提醒了，如下图：
所以在安装gitlab 时，不能直接去拉gitlab，需要拉取arm64的 推荐一个我在用的
yrzr/gitlab-ce-arm64v8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4bad8c701a36e41ba9670f3f12233e7/" rel="bookmark">
			Entity Framework Core反向工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.EF Core 把C#代码转换为SQL语句的框架
2.EF Core &amp; EF EF有DB First、Model First、Code First。EF Core不支持模型优先，推荐使用代码优先，遗留系统可以使用Scaffold-DbContext来生成代码实现类似DBFirst的效果，但是推荐用Code First 。
3.反向工程（DB First） 1、根据数据库表来反向生成实体类
2、Scaffold-DbContext ‘Server=.;Database=demo1;Trusted_Connection=True;MultipleActiveResultSets=true’ Microsoft.EntityFrameworkCore.SqlServer
注意：
1、生成的实体类可能不能满足项目的要求，可能需要手工修改或者增加配置。
2、再次运行反向工程工具，对文件所做的任何更改都将丢失。
3、不建议把反向工具当成了日常开发工具使用，不建议DBFirst。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62f68113e6596ca64aaa69b8d49a57e9/" rel="bookmark">
			【C语言】哥德巴赫猜想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//哥德巴赫猜想：任意一个大于6的偶数都是两个素数之和
//思路：先写一个判断素数的函数，在主函数中调用，遍历比i小的数，如果这两个数是素数则成立
//素数函数的思路：除了1和他本身没有其他的公因数，二次循环。
int prime(int i)
{
int w,a,b,num;
for (a=1;a&lt;=i;a++) {
for (b = 0;b &lt;=a;b++)
{
if (a * b == i)
{
if (a != i) { num = 1; };
if (a == i) { num = 2; };
switch (num)
{
case 1:return 1;
case 2:return 2;
}
}; }
} }
int main()
{
int t,p,q,a1,a2;
printf("please input a even i(&gt;=6)");
scanf_s("%d" , &amp;t);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62f68113e6596ca64aaa69b8d49a57e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be8cf9beec1c9c5047ef00d3538d5648/" rel="bookmark">
			element this.$confirm按钮样式修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改按钮颜色或者位置间距
this.$confirm('此操作将永久删除该文件, 是否继续?', '提示', { confirmButtonText: '确定', cancelButtonText: '取消', customClass:'del-model', type: 'warning' }).then(() =&gt; { this.$message({ type: 'success', message: '删除成功!' }); }).catch(() =&gt; { this.$message({ type: 'info', message: '已取消删除' }); }); //注意这里不能将样式放到scoped中 &lt;style lang='stylus'&gt; .del-model { .el-message-box__btns { .el-button:nth-child(1) { float:right; } .el-button:nth-child(2) { margin-right:10px; background-color:#2d8cf0; border-color:#2d8cf0; } } } 下面是修改确认按钮的宽度
this.$confirm('确认上架后，该广告将出现在「正在投放」列表中', '是否确认上架', { confirmButtonText: '确定', center: true, showCancelButton: false, customClass: 'confirm' }).then(() =&gt; { this.$message({ type: 'success', message: '删除成功!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be8cf9beec1c9c5047ef00d3538d5648/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d6a88fb672886fdae3191ddcc9f5aea/" rel="bookmark">
			Visio Viewer for Mac(Visio文件编辑查看工具)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visio Viewer是一款能够快速的打开Visio文件，包括 vsd 和 vsds 格式的文件编辑查看工具，Visio Viewer mac支持放大和缩小浏览，并可以将Visio绘图文件转换为PDF文件或将其打印出来。
功能
在Mac OS X上查看Visio绘图和图表
在Mac OS X上轻松查看MS Visio文件
在Mac上快速方便地打开并阅读Visio文件（.vsd，.vsdx）。
支持通过放大，缩小，旋转，文本选择和复制，打印，文本搜索等功能查看Visio文件。
以单页，单页连续，两页，两页连续四种模式浏览多页Visio文档。
支持多标签查看，轻松读取和切换多个Visio文件。
将Visio转换为PDF，一键单击文本
支持将查看的Visio文件转换为PDF格式，并将文本格式轻松转换。
将Visio转换为PDF，保留原始元素，包括线条，颜色和填充等。
将Visio转换为更常见的文件格式PDF，以进一步处理和共享。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a87b64ae373efebb5ed604ecc3894724/" rel="bookmark">
			通过itextpdf向PDF文件最后一页添加图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品需求: 在pdf 最后一页嵌上签名,因为每个pdf 内容不一样,故不能用pdf 模板的方式,所以采用将签名嵌在最后一页.
最终方案,首先上最终代码:
public static void main(String[] args) throws Exception { ​​​​​​​ PdfReader reader = null; PdfStamper stamper = null; FileInputStream fis = null; try { fis = new FileInputStream(new File("C:\\Users\\EDZ\\Desktop\\peletter.pdf")); } catch (FileNotFoundException e) { log.error("pdf文件路径不正确",e); } String path = "C:\\Users\\EDZ\\Desktop\\peletter888.pdf"; try { reader = new PdfReader(fis); stamper = new PdfStamper(reader, new FileOutputStream(path)); //新增空白页 stamper.insertPage(reader.getNumberOfPages() + 1, reader.getPageSizeWithRotation(1)); //捕获新增的空白页 PdfContentByte under = stamper.getOverContent(reader.getNumberOfPages()); Image image = Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a87b64ae373efebb5ed604ecc3894724/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de7b9ddf47709652ff8067d9b68919b2/" rel="bookmark">
			vue项目启动报错：npm ERR! job-schedule@0.1.0 serve: `vue-cli-service serve`以及No matching version found forX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近将前端项目转移到其他电脑上（linux系统）去部署的时候，运行 npm install ,然后再运行npm run serve 之后出现如下图所示的两种报错情况。关键是，删除了node_modules模块和package-lock.json文件重新npm install还是出错（可是把我该困扰住了）；把vue cli和node都卸载重新安装，还是不行。
主要会出现这两个主要的错误提示信息：
npm ERR! job-schedule@0.1.0 serve: ‘ vue-cli-service serve’ 和
No matching version found forX
这个是用npm install 命令出现的：
这个是使用 npm run serve 命令出现的：
第一张图片提示信息No matching version found for xxxxxxxx+版本信息，是package.json文件中的配置信息出了些什么问题，我原本window系统下做的时候，package.json文件里面的内容如下：
"@babel/core": "^7.12.16", "@babel/eslint-parser": "^7.12.16", "@vue/cli-plugin-babel": "~5.0.0", "@vue/cli-plugin-router": "~5.0.0", "@vue/cli-service": "~5.0.0", "eslint-plugin-node": "^11.1.0", "eslint-plugin-promise": "^5.1.0", "vue-template-compiler": "^2.6.11", "eslint-plugin-html": "^6.0.3", "@vue/cli-plugin-eslint": "^3.3.0", "@vue/eslint-config-standard": "^4.0.0" 后来把项目放到linux系统的电脑上时，我在package.json文件中又添加了一些内容如下：
"eslint-plugin-html": "^6.0.3", "@vue/cli-plugin-eslint": "^3.3.0", "@vue/eslint-config-standard": "^4.0.0", "eslint": "5.0.0", "eslint-friendly-formatter": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de7b9ddf47709652ff8067d9b68919b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f3528dbd1c7f8e311632256b594789/" rel="bookmark">
			什么是移动设备管理（MDM），MDM的优势？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是MDM？
移动设备管理（MDM）指的是在工作场所注册、配置和保护便携式设备的做法。尽管一些供应商仅用该术语描述管理智能手机，但值得强调的是，MDM 还包括管理平板电脑和笔记本电脑。
IT 管理员使用 MDM 软件自定义移动设备设置、强制执行用户策略并增强网络安全。因此，MDM 既是一种软件解决方案，也是一种 IT 管理实践。
不同类型的 MDM 平台支持不同类型的设备、功能和操作系统。但所有 MDM 平台都分为两个不同的类别：本地部署的MDM和基于云的 MDM。
二、MDM 的常见任务
1、安装应用程序
2、设置网络偏好
3、激活用户帐户
4、确定权限
5、停用设备
三、移动设备管理的优势
实施移动设备管理的最主要原因就是减少安全漏洞。但是，实施有效的MDM项目还为企业提供了额外的好处。以下是 MDM 实施中以安全为中心的额外优势：
1、降低成本：不太可能出现高成本的违规行为
2、安全保障：支持对用户、设备和应用程序进行远程监控，以远程扫描威胁 3、安心使用：数据备份，以防止关键数据丢失
4、改进管理：提供临时存储设备的自动删除功能，释放空间并减少堵塞
5、受控更新：管理员决定何时在设备上安装更新
6、加密通信：支持员工之间专有信息的安全通信
7、提高效率：改善新员工的入职体验
8、增强便利性：保护自带设备（BYOD）策略
有了这些优势，分析师预计对 MDM 解决方案的需求会增长也就不足为奇了。专家预测，到2028年，全球315亿元的 MDM 市场将增长24%。
四、移动设备管理软件如何运行？
移动设备管理软件的初始设置因平台而异。但是，大多数 MDM 的工作从在软件或服务器中注册设备开始。
根据特定的 MDM 解决方案，可以通过向特定厂商的程序（如苹果、Google、三星和微软）注册设备或通过令牌、二维码、NFC芯片或电子邮件/短信手动添加设备来进行注册。
一旦设备被注册后，管理员只需登录到其 MDM 门户就能看到这些设备。然后，IT 管理员使用其管理控制台将配置和应用程序推送到已注册的设备上。
从技术上讲，MDM 服务器（软件）会发出一组命令，这些命令通过操作系统中内置的应用程序编程接口（API接口）应用于设备。
五、移动设备管理的成本
根据2021年的一项调查，47%的中小型企业（SME）计划增加在移动技术上的支出，而58%的企业计划在远程管理上增加投入。
如今，在通货膨胀、供应链问题和竞争性的预算要求面前，IT经理面临着减少部门支出的巨大责任。IT 管理人员必须优化运营，同时保持预算精简。
幸运的是，基于用户数量的定价模式现在适合任何规模的企业预算。管理员还可以在采购之前用免费试用版本测试 MDM 系统。
以身份目录即服务（DaaS）技术为代表的云目录平台对于希望将身份和访问管理（IAM）与 MDM 整合在一起的企业是个理想选择，且投入的费用更少。
云目录平台将 macOS 和 Windows MDM 功能作为其常规设备管理的原生功能。管理员还可以享受组策略功能、临时命令执行以及单点登录（SSO）机制，这些功能在其他方案中是享受不到的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8e60e913eedd9579991056504039b86/" rel="bookmark">
			vue3实现二维码的创建生成dataURL和直接显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3生成二维码的方式有很多种，因为项目要求，本次实现二维码主要是通过转化成dataURL的base64位数据进行解析展示。查阅了多种资料，根据要求的不同，如果想要二维码直接展示也会有相应的标签。
//判断图片 if (block.type === 'image') { const image = new Image() image.src = block.src image.onload = () =&gt; { block.image = image } }else if (block.type === 'qrcode'){//判断二维码，转二维码dataURL QRCode.toDataURL(block.text, {width: block.width, height: block.height}).then(src=&gt; { const image = new Image() image.src = src image.onload = () =&gt; { block.image = image } }) 在npm中查询到一种简单的方法直接实现二维码的转码，不管是图片还是二维码都可以轻松实现转成base64位格式的文件。
显示的方式和block的格式如下：
//显示方式 &lt;v-image v-else-if="item.type === 'qrcode'" :config="item" @dragmove="onMove($event, item)" @mousedown="handleStageMouseDown($event, item)" @transform="handleTransformEnd" @transformend="handleTransformEnd"&gt;&lt;/v-image&gt; //块状数据封装 const newQrcode = (index = 0) =&gt; ({ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8e60e913eedd9579991056504039b86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/249b45ef60de86ace1ee341e21419193/" rel="bookmark">
			Android地理围栏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、请求地理围栏，并向围栏管理端添加 private void addFenceInAndStay() { mClientInAndStayAction = new GeoFenceClient(mContext); mClientInAndStayAction.createPendingIntent(GEOFENCE_BROADCAST_ACTION); mClientInAndStayAction.setGeoFenceListener(this); mClientInAndStayAction.setActivateAction(GeoFenceClient.GEOFENCE_IN | GeoFenceClient.GEOFENCE_STAYED); mClientInAndStayAction.addGeoFence("合肥", "快餐厅", "六安", 2, String.valueOf(mCustomID)); mCustomID++; mClientInAndStayAction.addGeoFence("kfc", "快餐厅", new DPoint(39.982375,116.305292), 5000, 2, String.valueOf(mCustomID)); mCustomID++; mClientInAndStayAction.addGeoFence("安庆", String.valueOf(mCustomID)); mCustomID++; } 2、绘制地理围栏 1）：绘制多边形 。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yPMhBleT-1663808467442)(https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/605a2cfe746f44bb80e353762919064e~tplv-k3u1fbpfcp-watermark.image?)]
private void drawPolygon(GeoFence fence) { final List&lt;List&lt;DPoint&gt;&gt; pointList = fence.getPointList(); if (null == pointList || pointList.isEmpty()) { return; } List&lt;Polygon&gt; polygonList = new ArrayList&lt;Polygon&gt;(); for (List&lt;DPoint&gt; subList : pointList) { if (subList == null) { continue; } List&lt;LatLng&gt; lst = new ArrayList&lt;LatLng&gt;(); PolygonOptions polygonOption = new PolygonOptions(); for (DPoint point : subList) { lst.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/249b45ef60de86ace1ee341e21419193/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9454dae08e5b7c556559d3e5239a10d9/" rel="bookmark">
			Linux基础环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux基础环境搭建 这篇文章主要介绍Linux、java、mysql、Tomcat基础环境的搭建。帮助我们迅速完成基础服务环境的部署。
VM的安装 CentOS 7的安装 固定IP配置 [root@localhost ~]# vi /etc/sysconfig/network-scripts/ifcfg-ens33 #各个配置名称说明 DEVICE=ens33 #网卡接口名称 TYPE=Ethernet #网卡类型 HWADDR=00:0C:29:F2:D2:43 #网卡设备的MAC地址 UUID=25082ea8-6e04-4cf4-8442-0fb02fae6fa4 #设备UUID编号，如果你想要更改就更该，后果自负哟 ONBOOT=yes #系统启动时是否自动加载 NM_CONTROLLED=yes #network manager的选项，实时生效，不需要重启 BOOTPROTO=static #IP的配置方法【none|static|bootp|dhcp】(引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议) NETMASK=255.255.255.0 #子网掩码 IPADDR=192.168.100.250 #设置的IP地址 PREFIX=24 #子网掩码的位数，代表的子网掩码为255.255.255.0。 GATEWAY=192.168.100.2 #网卡的默认网关地址 DNS1=114.114.114.114 #DNS服务器地址1 DNS2=180.76.76.76 #DNS服务器地址2 DNS3=223.5.5.5 #DNS服务器地址2 DEFROUTE=yes #是否将该路由设置为默认路由 IPV4_FAILURE_FATAL=yes IPV6INIT=no #禁止IPV6 NAME="System eth0" #显示的网络连接的名称 USERCTL=no #是否允许非root用户控制该设备，设置为no，则只能使用root用户修改 #重启网卡服务 [root@localhost ~]# systemctl restart network 防火墙设置 查看防火墙状态，发现当前是dead状态，即防火墙未开启 systemctl status firewalld 关闭防火墙 systemctl stop firewalld 永久关闭防火墙 systemctl disable firewalld.service 重启防火墙（设置了新的端口记得先关闭，再重启） service firewalld restart 查看防火墙是否已开放3306端口 firewall-cmd --query-port=3306/tcp 设置3306 8080端口为永久开放 firewall-cmd --add-port=3306/tcp --permanent firewall-cmd --add-port=8080/tcp --permanent 服务器操作辅助工具推荐 xshell （服务器远程连接工具）、xftp(本地与服务器文件传输工具 窗口端)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9454dae08e5b7c556559d3e5239a10d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f5d860819a282301f1c34542f6d73a/" rel="bookmark">
			Python程序设计第三版董付国 百度网盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Python程序设计（第3版）》pdf下载在线阅读，求百度网盘云资源 《Python程序设计（第3版）》（[美] John Zelle）电子书网盘下载免费在线阅读链接： 提取码：rf93书名：Python程序设计（第3版）作者：[美] John Zelle译者：王海鹏豆瓣评分：7.3出版社：人民邮电出版社出版年份：2018-1-12页数：344内容简介：本书是面向大学计算机科学专业第一门程的教材。
本书以Python语言为工具，采用相当传统的方法，强调解决问题、设计和编程是计算机科学的核心技能。全书共13章，包含两个附录。
第1章到第5章介绍计算机与程序、编写简单程序、数字计算、对象和图形、字符串处理等基础知识。第6章到第8章介绍函数、判断结构、循环结构和布尔值等话题。
第9章到第13章着重介绍一些较为高级的程序设计方法，包括模拟与设计、类、数据集合、面向对象设计、算法设计与递归等。附录部分给出了Python快速参考和术语表。
每一章的末尾配有丰富的练习，包括复习问题、讨论和编程联系等多种形式，帮助读者巩固该章的知识和技能。
谷歌人工智能写作项目：小发猫
《Python程序设计（第3版）》pdf下载在线阅读全文，求百度网盘云资源 《Python程序设计（第3版）》（[美] John Zelle）电子书网盘下载免费在线阅读链接: 提取码: 74k4书名：Python程序设计（第3版）作者：[美] John Zelle译者：王海鹏豆瓣评分：7.3出版社：人民邮电出版社出版年份：2018-1-12页数：344内容简介：本书是面向大学计算机科学专业第一门程的教材python编程一级考试难吗。
本书以Python语言为工具，采用相当传统的方法，强调解决问题、设计和编程是计算机科学的核心技能。全书共13章，包含两个附录。
第1章到第5章介绍计算机与程序、编写简单程序、数字计算、对象和图形、字符串处理等基础知识。第6章到第8章介绍函数、判断结构、循环结构和布尔值等话题。
第9章到第13章着重介绍一些较为高级的程序设计方法，包括模拟与设计、类、数据集合、面向对象设计、算法设计与递归等。附录部分给出了Python快速参考和术语表。
每一章的末尾配有丰富的练习，包括复习问题、讨论和编程联系等多种形式，帮助读者巩固该章的知识和技能。
本书特色鲜明、示例生动有趣、内容易读易学，是美国颇受欢迎的教程，适合Python入门程序员阅读，也适合高校计算机专业的教师和学生参考。
谁有Python语言程序设计pdf分享一下 《北京理工大学-Python语言程序设计》百度网盘免费资源下载链接: ?pwd=b1gh 提取码: b1gh 北京理工大学-Python语言程序设计|Python程序设计pdf文档||9.3Python的Office编程Word编程.mp4|9.3Python的Office编程Powerpoint编程.mp4|9.3Python的Office编程Office编程.mp4|9.3Python的Office编程Excel编程.mp4|9.2Python的OS平台编程OS平台编程.mp4|9.1Python的库编程和库安装Python库纵览.mp4|9.1Python的库编程和库安装9.2Python库的通用安装方法.mp4|8.6 Turtle Art - Turtle Art66893.mp4|8.5 Turtle实例 - Turtle实例66893.mp4|8.4 图形用户接口实例 - 图形用户接口实例66893.mp4|8.3 Turtle库的介绍 - Turtle库的介绍66893.mp4|8.2 图形库的应用方法 - 图形库的应用66893.mp4。
谁有Python语言程序设计pdf分享一下 《北京理工大学-Python语言程序设计》百度网盘免费资源下载链接: ?pwd=b1gh 提取码: b1gh 北京理工大学-Python语言程序设计|Python程序设计pdf文档||9.3Python的Office编程Word编程.mp4|9.3Python的Office编程Powerpoint编程.mp4|9.3Python的Office编程Office编程.mp4|9.3Python的Office编程Excel编程.mp4|9.2Python的OS平台编程OS平台编程.mp4|9.1Python的库编程和库安装Python库纵览.mp4|9.1Python的库编程和库安装9.2Python库的通用安装方法.mp4|8.6 Turtle Art - Turtle Art66893.mp4|8.5 Turtle实例 - Turtle实例66893.mp4|8.4 图形用户接口实例 - 图形用户接口实例66893.mp4|8.3 Turtle库的介绍 - Turtle库的介绍66893.mp4|8.2 图形库的应用方法 - 图形库的应用66893.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01f5d860819a282301f1c34542f6d73a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80d04afb2d31be4755256a804d87ac7e/" rel="bookmark">
			LeetCode——两数之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
解法1:
var twoSum = function(nums, target) { for(let i=0;i&lt;nums.length;i++){ for(let j=i+1;j&lt;nums.length;j++){ if(nums[i]+nums[j] == target){ return [i,j] } } } return [] }; 解法2:
var twoSum = function(nums, target) { const map = new Map(); for(let i = 0, len = nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80d04afb2d31be4755256a804d87ac7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e003081174a24b1399e2d0f6fd5172/" rel="bookmark">
			密码学系列 - BLS签名算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BLS签名算法概述：
BLS签名算法具有如下三个特点：
1、签名简单：签名算法和ECDSA等算法相比较为简单
2、签名可聚合：可将多个签名聚合成一个签名，进行统一验证
3、签名唯一：对于同一个消息，每次签名得到的结果相同
BLS签名算法的Golang代码实现：
1、引用 gnark-crypto实现的bls12-381曲线，先定义BLS签名的公私钥
2、签名和验签算法如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6018e0596fc5afffa64c2929b2a7d2b4/" rel="bookmark">
			第二章 学生指导(04 小学德育 05 小学美育 06 小学生安全与心理健康教育 07 学校与家庭、社会的协调)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第二章 学生指导 01 小学生身心发展的规律
02 学生心理发展与教育
03 小学生的学习
04 小学德育
05 小学美育
06 小学生安全与心理健康教育
07 学校与家庭、社会的协调
04 小学的德育 一、德育的含义 广义、狭义
二、德育的内容 政治、思想、道德、民主法制
三、皮亚杰道德发展阶段论
四、科尔伯格的道德发展阶段论 五、小学生思想品德发展的特点
六、德育过程的基本规律
七、德育的原则
八、德育的途径与方法
九、小学生的品德指导
三、皮亚杰道德发展阶段论 单选、简答 A.方法：对偶故事法
B.儿童道德发展阶段
（例）简述皮亚杰的道德发展理论？
四、科尔伯格的道德发展阶段论 单选 A.方法：道德两难故事法
B.三水平六阶段
五、小学生思想品德发展的特点 单选 六、德育过程的基本规律 单选 七、德育的原则 单选 八、小学德育的途径与方法 单选 （二）德育方法 九、小学生的品德指导 （一）品德形成的一般过程 （二）小学生品德不良的形成原因 简答、材料 （例）简述小学生品德不良的原因。
总结（小学德育） 05 小学美育 三、美育的任务 简答 06 小学生安全与心理健康教育 一、小学生的营养饮食卫生
二、小学生常见疾病及意外事故
三、小学生的心理健康
四、小学生的心理辅导
一、小学生的营养饮食卫生 （一）小学生所需的营养 单选 二、小学生常见疾病及意外事故 单选 （三）意外事故的预防与处理 （四）常见外伤处理 三、小学生的心理健康 单选 （一）心理健康的含义 一是无心理疾病；二是有积极发展的心理状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6018e0596fc5afffa64c2929b2a7d2b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/385604ddf3638f6be49abd901c57ecc6/" rel="bookmark">
			K8S概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K8S概述 文章目录 K8S概述1.K8S是什么2.为什么用K8S3.K8S的特性4.K8S集群架构与组件4.1Master组件4.2Node组件4.3K8S架构 5.K8S核心概念5.1Pod5.2Pod控制器5.3Label5.4Label选择器（Label selector）5.5Service5.6Ingress5.7Name5.8Namespace 6.常见的K8S按照部署方式 1.K8S是什么 K8S 的全称为Kubernetes
作用：
用于自动部署、扩展和管理“容器化(containerized）应用程序”的开源系统。
可以理解成K8S是负责自动化运维管理多个容器化程序（比如 Docker）的集群，是一个生态极其丰富的容器编排框架工具。
由来：
K8S由google的Borg系统（博格系统，google内部使用的大规模容器编排工具）作为原型，后经GO语言延用Borg的思路重写并捐献给CNCF基金会开源。
含义：
词根源于希腊语的舵手、飞行员
2.为什么用K8S 试想下传统的后端部署办法：把程序包（包括可执行二进制文件、配置文件等）放到服务器上，接着运行启动脚本把程序跑起来，同时启动守护脚本定期检查程序运行状态、必要的话重新拉起程序。
设想一下，如果服务的请求量上来，已部署的服务响应不过来怎么办。传统的做法往往是，如果请求量、内存、CPU超过阈值做了告警，运维人员马上再加几台服务器，部署好服务之后，接入负载均衡来分担已有服务的压力。
这样问题就出现了：从监控告警到部署服务，中间需要人力介入。那么，有没有办法自动完成服务的部署、更新、卸载和扩容、缩容呢？
而这就是K8S要做的事情：自动化运维管理容器化(Docker) 程序。
K8S的目标是让部署容器化应用简单高效。
K8S解决了裸跑Docker的若干痛点：
单机使用，无法有效集群随着容器数量的上升，管理成本攀升没有有效的容灾、自愈机制没有预设编排模板，无法实现快速、大规模容器调度没有统一的配置管理中心工具没有容器生命周期的管理工具没有图形化运维管理工具 K8S是Google开源的容器集群管理系统，在Docker等容器技术的基础上，为容器化的应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性。其主要功能如下：
使用Docker等容器技术对应用程序包装(package)、实例化（instantiate)、运行（run)以集群的方式运行、管理跨机器的容器。解决Docker 跨机器容器之间的通讯问题。K8S的自我修复机制使得容器集群总是运行在用户期望的状态。 3.K8S的特性 弹性伸缩
使用命令、UI或者基于CPU使用情况自动快速扩容和缩容程序实例，保证应用业务高峰并发时的高可用性；业务低峰时回收资源，以最小成本运行服务
自我修复
在节点故障时重新启动失败的容器，替换和重新部署，保证预期的副本数量（3台容器运行）；杀死健康检查失败的容器，并且在未准备好之前不会处理客户端的请求，确保线上服务不中断
服务发现和负载均衡
K8S为多个容器提供一个统一的访问入口（内部IP地址和一个DNS名称），并且负载均衡关联的所有容器，使得用户无需考虑容器IP问题
自动发布（默认滚动发布模式）和回滚
K8S采用滚动更新策略更新应用，一次更新一个Pod，而不是同时删除所有的Pod，如果更新过程中出现问题，将回滚更改，确保升级业务不受影响
集中化配置管理和密钥管理
管理机密数据和应用程序配置，而不需要把敏感数据暴露在镜像里，提高敏感数据安全性。并可以将一些常用的配置存储在K8S中，方便应用程序使用
存储编排，支持外挂存储并对外挂存储资源进行编排
挂载外部存储系统，无论是来自本地存储，公有云（如AWS），还是网络存储（如NFS、Glisterfs、Ceph）都作为集群资源的一部分使用，极大提高存储使用灵活性
任务批处理运行
提供一次性任务，定时任务；满足批量数据处理和分析的场景
4.K8S集群架构与组件 K8S是属于主从设备模型（Master-Slave 架构），即有Master 节点负责集群的调度、管理和运维，slave 节点是集群中的运算工作负载节点。
在K8S中，主节点一般被称为Master节点，而从节点则被称为Worker Node节点，每个Node都会被Master分配一些工作负载。
Master组件可以在群集中的任何计算机上运行，但建议Master节点占据一个独立的服务器。因为Master 是整个集群的大脑，如果Master所在节点宕机或不可用，那么所有的控制命令都将失效。除了Master,在K8S集群中的其他机器被称为Worker Node节点，当某个Node宕机时，其上的工作负载会被Master自动转移到其他节点上去。
4.1Master组件 Kube-apiserver
用于暴露Kubernetes API，任何资源请求或调用操作都是通过kube-apiserver 提供的接口进行。以HTTP Restful API提供接口服务，所有对象资源的增删改查和监听操作都交给API Server 处理后再提交给Etcd 存储（相当于分布式数据库，以键值对方式存储）。
可以理解成API Server 是K8S的请求入口服务。API server 负责接收K8S所有请求（来自UI界面或者CLI 命令行工具），然后根据用户的具体请求，去通知其他组件干活。可以说API server 是K8S集群架构的大脑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/385604ddf3638f6be49abd901c57ecc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d653d1a944d7c364a67b64c4e4278f/" rel="bookmark">
			Android地图集成以及基础功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、注册步骤 第一步：第一步，注册高德开发者；
第二步，去控制台创建应用；
第三步，获取Key。
2、地图集成 第一步：在Project的build.gradle文件中配置repositories，添加maven。
allprojects { repositories { jcenter() // 或者 mavenCentral() } } 第二步，在主工程的build.gradle文件配置dependencies。
dependencies { implementation fileTree(dir: 'libs', include: ['*.jar']) //3D地图so及jar implementation 'com.amap.api:3dmap:latest.integration' //定位功能 implementation 'com.amap.api:location:latest.integration' //搜索功能 implementation 'com.amap.api:search:latest.integration' } 注意： 1）、navi导航SDK 5.0.0以后版本包含了3D地图SDK，所以请不要同时引入 map3d 和 navi SDK。
2）、定位库与导航库一起集成，还是有冲突的，要排除这种冲突。
/* 移除冲突依赖*/ configurations { all*.exclude group:'com.amap.api', module: 'location' } 3、地图基础功能介绍（https://github.com/AlbertShen0211/3DAMap） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c027bf83fdffcbb8bf54631b469616db/" rel="bookmark">
			Pytorch-3D-Image-Classification
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实践经历，类似于肿瘤的图像都是3D图像类型的，而3D Image Classification 一般多用于医学领域，之前从未接触过类似的，所以此次实践过程值得记录一下
刚开始接触3D分类的时候，由于没有任何经验所以碰到了很多问题，记录方便自己查看并希望能够帮到和我一样什么都不知道的小白，我会从我将数据的处理到训练完成后的整个过程进行记录，如有错误的地方请多多包含
3D的图像识别于2D的识别存在一些细微的差别，当基本方法思想都一样，主要是对于数据的处理部分需要注意
图像预处理 其实这一部分的话，对于大多数任务来说是不需要的，但是由于我数据的特殊性（区域太小），需要将被识别的部分框出来，这样才能进行识别
我的数据是医学影像常见领域的MRI格式的图像，这批图像有原始数据，以及对于病灶的ROI部分，ROI部分是只有病灶的数据，其位置信息完全对应原始数据的病灶部分，因此需要根据ROI数据将原始数据中的肿瘤部分框出，对于预处理这一部分，因为作者也是通过网上各种查找资料才处理好，前后一共花了大概两周的时间才处理好，所以这里我只介绍用的方法，我是用的是SimpleITK这个库，它是专门对医学影像图像处理的库，请自行参考
我有用到的几个函数：
将MRI图像转换为矩阵sitk.GetArrayFromImage()
读取图像sitk.ReadImage(img)
写图像 sitk.WriteImage()
将矩阵转换为图像 sitk.GetImgageFromArray()
重采样 sitk.Resmaple()
由于时间太过久远我只给出了我仍然还记得的函数，需要用到什么请自行Google（使用VPN）
DataSet部分 Dataset部分由于我们的图像是3D的，因此需要对3D图像，这里我推荐一个库：Torchio正对于MRI影响有很多处理，还有图像增强等各种函数，但是我的数据已经做过增强因此不再使用
import SimpleITK as sitk from torch.utils.data import Dataset import torch import numpy as np import os import torchio as tio class Classification_Dataset(Dataset): def __init__(self, mode='train', period=''): self.root_path = 'your path of the data' self.high_list = [] self.low_list = [] with open('./label.txt', 'r') as f: for line in f.readlines(): all_label = line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c027bf83fdffcbb8bf54631b469616db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24a051999f51155df42344ec62550b96/" rel="bookmark">
			连续数组（Java算法每日一题）前缀和&#43;Hashmap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问：
给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。
原题链接：https://leetcode.cn/problems/contiguous-array/
例：
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
答：
class Solution { public int findMaxLength(int[] nums) { int len = nums.length; int[] s = new int[len+1]; for(int i = 1;i &lt;= len;i++) { s[i] = s[i-1] + (nums[i-1] == 1 ? 1:-1); } int a = 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for(int i = 2;i &lt;= len;i++) { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24a051999f51155df42344ec62550b96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8329a2ab72bb2882fe79e4cb1d08f93/" rel="bookmark">
			字符串处理函数：sscanf 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
一直对于一些日期字符串中数字的提取比较头疼，现看到 sscanf 对于字符串中的内容提取较方便，学习记录如下。方便以后查询。
sscanf()：将 C 语言字符串中数据按 指定的格式 将数据存储在对应的参数中。
1、函数格式 // sscanf() 会从 buffer 里读进数据，依照 format 的格式将数据写入到 argument 里，注意这里的 argument 需要使用地址符号 // 转换格式参考 scanf() 即可 int sscanf(const char *buffer, const char *format, [argument ]... ); 2、返回值 成功则返回参数数目，失败则返回-1，错误原因存于errno中。
说明：
3、支持集合操作 %[a-z] 表示匹配 a 到 z 中任意字符，贪婪性(尽可能多的匹配)；%[aB] 匹配 a、B 中一员，贪婪性；%[^a] 匹配非 a 的任意字符，并且停止读入，贪婪性； 4、测试代码 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { // sscanf() 会从 buffer 里读进数据，依照 format 的格式将数据写入到 argument 里，注意这里的 argument 需要使用地址符号 // format 格式参考 scanf() 的输入格式即可 // 1、取需要的字符串 int year,month,day; sscanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8329a2ab72bb2882fe79e4cb1d08f93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7e0839747def63cbb035408d44ada7d/" rel="bookmark">
			【语义分割中数据增强笔记】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语义分割中数据增强笔记 transform中的注意事项： 对于train / val / test 中image 和label 的操作
注意image和label变换的相同随机性train和val和test的过程差异性 使用PIL处理图片： 基础知识
图像的模式定义了图像的类型和像素的位宽。当前支持如下模式：
1：1位像素，表示黑和白，但是存储的时候每个像素存储为8bit。
L：8位像素，表示黑和白。
P：8位像素，使用调色板映射到其他模式。
RGB：3x8位像素，为真彩色。
RGBA：4x8位像素，有透明通道的真彩色。
CMYK：4x8位像素，颜色分离。
YCbCr：3x8位像素，彩色视频格式。
PIL.Image与numpy.array之间的相互转换
Image ====&gt; numpy
img = numpy.array(im) numpy ====&gt; Image
img = Image.fromarray(img.astype('uint8')),convert('RGB') 图片的同步变换问题
img = cv2.imread('../data/A/111.tif') img_B = cv2.imread('../data/B/111.tif') label = cv2.imread('../data/label/111.png',0) transform_all = transforms.Compose([ transforms.ToPILImage(), transforms.ColorJitter(0.4,0.42,0.52), transforms.RandomRotation(180), # transforms.PILToTensor(), ]) img = transform_all(img) img_B = transform_all(img_B) img.show() img_B.show() 处理的图片显示：
解决方法
这里拿旋转举例
class RandomRotate(object): def __init__(self, degree=15): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7e0839747def63cbb035408d44ada7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8cca5070cabc741f22d8093fac20ca1/" rel="bookmark">
			【模型调参总结之解决模型过拟合方法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 模型调参总结之解决模型过拟合方法 前言 在深度学习中对于过少的数据集，模型往往会产生过拟合现象。本文将对过拟合问题进行归纳和总结，并针对性的提出一点自己的见解。 原因 由于数据集中图片数量较少，但模型训练次数扩大时，会导致模型对于训练集中图片分布情况过度依赖，从而降低了模型对于其他分布数据的预测能力，降低了模型的泛化性能。 主要表现 模型对于验证集中loss 上升 并且训练集中loss下降模型对于验证集中图片准确度下降 解决方法 加大权重衰减指数（weight decay） 权重衰减原理（为什么可以对权重进行衰减）：
我们对加入L2正则化后的代价函数进行推导，先求导：
可以发现L2正则化项对b的更新没有影响，但是对于w的更新有影响：
在不使用L2正则化时，求导结果中w前系数为1，现在w前面系数为1-ηλ/n，因为η、λ、n都是正的，所以1-ηλ/n小于1，它的效果是减小w，这也就是**权重衰减（weight decay）**的由来。当然考虑到后面的导数项，w最终的值可能增大也可能减小。
权重衰减作用：
L2正则化项有让w变小的效果，但是为什么w变小可以防止过拟合呢？ 原理：
（1）从模型的复杂度上解释：更小的权值w，从某种意义上说，表示网络的复杂度更低，对数据的拟合更好（这个法则也叫做奥卡姆剃刀），而在实际应用中，也验证了这一点，L2正则化的效果往往好于未经正则化的效果。
（2）从数学方面的解释：过拟合的时候，拟合函数的系数往往非常大，为什么？如下图所示，过拟合，就是拟合函数需要顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。而正则化是通过约束参数的范数使其不要太大，所以可以在一定程度上减少过拟合情况。
加入Dropout 在训练时，我们随机地“删除”一半的隐层单元，视它们为不存在
进行适量的数据增强
可以从loss本身进行分析，如果是CE loss上升 说明模型预测置信度和标签的匹配程度在变小（但也仅仅反应了预测置信度），同时要结合评价指标，如果CE loss 只有轻微上升，但评价指标（F1）并没有下降，结果应该并无大碍。
参考链接 https://blog.csdn.net/program_developer/article/details/80867468 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e388d7fadaee497b80f34caedca38832/" rel="bookmark">
			使用shell生成指定范围日期序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用shell生成指定范围日期序列 1. 问题描述2. 实现方式3. 注意事项 1. 问题描述 在shell 脚本中,需要产生一个指定范围的日期序列, 输入的数值为开始时间和结束时间,输出范围中的所有日期
如: 输入 20220528 20220606 输出为: 20220528 20220529 20220530 20220531 20220601 20220602 20220603 20220604 20220605 20220606 2. 实现方式 #!/bin/bash startDate=$1 endDate=$2 while [[ $startDate -le $endDate ]] do echo $startDate # 更新日期 startDate=`date -d "+1 day $startDate" +%Y%m%d` done 3. 注意事项 如果想指定自己使用的日期显示格式,只需要修改脚本的 %Y%m%d即可;
%Y%m%d 纯数字 如 20220606%Y-%m-%d 横线分隔 如 2022-06-06 欢迎大家留言一起讨论学习!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59448e533e78dc232eb3f192c7c7332e/" rel="bookmark">
			关于uniapp使用srcoll-view视图是横向及纵向滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在用HBuilder X写uniapp项目时遇到了需要使用滚动视图的地方，为了简单省事自然就选择了srcoll-view这个标签。在写完后实验了一下，微信小程序时没有问题，但是h5页面却出问题了。
问题大致分为两类：横向、纵向
共有的问题有：给scroll-view加上class类名并设置弹性布局后发现不起作用，经过排查和浏览器查看视图结构发现，h5页面中的scroll-view标签内自动嵌套了三层uni-view结构，如下图：
因此直接给scroll-view的类名中设置弹性布局是不行的，需要写成下面的这样：
/* h5的scroll-view滚动容器内元素样式 */ /deep/.uni-scroll-view-content{ display: flex; flex-direction: column; } 在设置滚动时，需参考下图
横向时需设置滚动视图容器的宽度，并设置white-space: nowrap;其目的是在内部元素的总宽度超过容器时禁止换行，使其在一行上显示。
纵向时则需要设置滚动视图容器的高度，不需要禁止换行。但值得注意的是在设置聚堆定位的时候（absolute和fixed）可能会造成出现滚动条但是无法滚动的，但去除绝对定位后又可以的情况。
我上网查询时发现横向滚动的文章比较多，但纵向的寥寥无几，且对纵向滚动的解决办法都是设置高度，但这明显不行。后来经过试验发现问题所在。
由于绝对定位后视图组件会脱离当前的文本流，在没有指定具体层级的情况下，导致滚动元素也没固定（个人猜想）。于是我在设定scroll-view的层级后即可保证在绝对定位的情况下还可以滚动。
以上是我在写代码的过程中遇到的问题及解决办法，如果有不同的看法的欢迎交流，大家一起进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4235d4acba0fa7eb8f8e334153d06ecf/" rel="bookmark">
			Redis占用内存过高怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
案例现象
定位问题
内存回收策略
键过期机制
slave的过期策略
解决问题
前言
我们知道，Redis是一个key-value数据库，它的数据是运行在内存中的
其读写效率比将数据存储到磁盘上的数据库要快很多
虽然性能强大，但是如果我们不了解Redis的内存回收策略，就有可能导致Redis消耗内存过高甚至导致内存溢出，严重影响系统性能
案例现象
发现生产环境上的一台服务器出现内存使用率达到阈值的告警
登上服务器使用 top 命令先看下
系统资源整体使用的情况
top
通过 top 的输出发现：
系统平均负载没有异常
系统cpu使用率没有异常
系统已使用的物理内存（used）数值特别高，达到了总物理内存的80%以上
而且buffer/cache的数值也不小，这说明有应用产生了大量的读写缓存
光看系统资源整体使用情况不能精确的定位到问题
我们继续观察 top 输出，这次我们将重点放到了各个进程的资源使用情况
发现：
redis进程占用了最多的内存，达到了20G
redis进程的使用率也达到了90%以上
由 top 的输出我们不难发现，这台服务器上的 redis实例消耗了大量的内存，而且cpu使用率很高，应该是有应用往 redis 上进行大量的读写操作
定位问题
这台服务器上的 Redis 是运行在 docker 上的，我们进入到 redis 容器里面
docker exec -it redis /bin/bash 我们还可以使用如下命令来查看 redis 容器的一些详细信息
docker inspect redis
然后找到 Redis 的配置文件路径，检查一下是不是配置出了问题
与对部署相同服务的服务器redis配置文件对比了一下，发现配置并没有什么问题
不是配置问题，那到底是什么原因导致Redis占用了这么多内存？这些使用的内存Redis不会回收的吗？
在回答这些问题时，我们先来了解一下Redis的内存回收策略以及键过期机制
内存回收策略
Redis是基于内存的数据库，常被用作缓存，以此来提高系统的响应速率与性能
Redis内存消耗 Redis进程的内存消耗主要包括：自身内存 + 对象内存 + 缓冲内存 + 内存碎片
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4235d4acba0fa7eb8f8e334153d06ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fcb67c4eefec091913c430785b9ff3a/" rel="bookmark">
			ConcurrentHashMap 中竟有好几个BUG？JDK8 源码深度解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 哈希值是负数的几种特殊情况sizeCtlputputValspread(int h) 求哈希值initTable() 初始化数组treeifyBin() 扩容或链表转红黑树tryPresize(int size)resizeStamp(int n) 计算扩容标识戳transfer(tab, null) 第一个进来执行扩容的线程lastRun 机制图示 helpTransfer 协助扩容 源码中的 BUG 及修复版本BUG 一：sizeCtl 临时变量 sc 判断条件sc == rs + 1sc == rs + MAX_RESIZERSbug fix in jdk12 BUG 二：tryPresize(int size) 中 sc &lt; 0 的判断bug fix in jdk9 BUG 三：computeIfAbsent 导致死循环computeIfAbsent In JDK 8bug fix in jdk9 #八股文 #JUC 哈希值是负数的几种特殊情况 // 数组中的数据的哈希值是负数的特殊含义 static final int MOVED = -1; // 数组正在扩容，并且当前位置的数据已经迁移到了新数组 static final int TREEBIN = -2; // 当前索引位置上是红黑树 static final int RESERVED = -3; // 当前索引位置已经被占了，但是值还没设置 sizeCtl // sizeCtl &gt; 0：若当前数组没有初始化，代表初始化的长度；若数组已初始化，代表下次扩容的阈值 // sizeCtl = 0：数组数还没初始化 // sizeCtl = -1：数组正在初始化 // sizeCtl &lt; -1：数组正在扩容 // 数组初始化和扩容的标识信息。 private transient volatile int sizeCtl; put // 若 key 已存在，则使用 value 覆盖 oldValue，并返回 oldValue public V put(K key, V value) { return putVal(key, value, false); } // 若 key 已存在，什么都不做，并返回 oldValue // absent：缺席、不到场 public V putIfAbsent(K key, V value) { return putVal(key, value, true); } putVal put 时没有哈希冲突用 CAS，有哈希冲突用 synchronized。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fcb67c4eefec091913c430785b9ff3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9baa7e786078cb0fb00f16698b624c99/" rel="bookmark">
			JAVA设计模式--单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是设计模式？ 软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。
2.设计模式的种类23种 1.创建型模式
用于描述“怎样创建对象”，它的主要特点是“==将对象的创建与使用分离==”。GoF（四人组）书中提供了==单例、原型、工厂方法、抽象工厂、建造者==等 5 种创建型模式。
2.结构型模式
用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了==代理、适配器、桥接、装饰、外观、享元、组合==等 7 种结构型模式。
3.行为型模式
用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了==模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器==等 11 种行为型模式。
3.单例模式 1.单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
2.单例模式的创建方式
第一种：饿汉式---&gt;不管是否使用该对象，该类会直接创建
第二种：懒汉式---&gt;当使用到该对象再创建
3.1饿汉式-方式1（静态变量方式） //饿汉式 创建一个单例类 public class Singleton { //构造方法私有化 private Singleton(){} //创建一个本类的对象---static:随着类的加载而加载到内存而且只会加载一次 private static Singleton singleton = new Singleton(); //静态方法，返回本类创建的类对象 public static Singleton getInstance(){ return singleton; } } 该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。 3.2 懒汉式-方式3（双重检查锁） //懒汉式双重校验 public class Singleton03 { private Singleton03(){} private static Singleton03 instance ; public static Singleton03 getInstance(){ //第一次判断，如果instance不为null,不进入抢锁阶段，直接返回实例 if (instance==null){ synchronized (Singleton03.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9baa7e786078cb0fb00f16698b624c99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f8e53ef65312313f8f0e0b86ee27a8e/" rel="bookmark">
			python 连接 neo4j
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入并连接： from py2neo import * graph = Graph("http://127.0.0.1:7474",auth=("账号","密码")) 新建节点与关系： # 头实体 head = Node("head_label", name='head_name') # 尾实体 tail = Node("tail_label", name='tail_name') # 关系 relation = Relationship(head, "relation_name", tail) # 创建关系（连带创建节点） graph.create(relation) 创建时合并相同节点： node_list = list(matcher.match("node_label",name='node_name')) if len(node_list) &gt; 0: node = node_list[0] else: node = Node("node_label",name='node_name') graph.create(node) 查询节点与关系： data_list = list(graph.match(r_type="relation_name") # 返回关系三元组 matcher = NodeMatcher(graph) # 用于查询节点 node_list = list(matcher.match("node_label",name='node_name')) # 返回节点 r_matcher = RelationshipMatcher(g) # 用于查询关系 relation_list = list(r_matcher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f8e53ef65312313f8f0e0b86ee27a8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ee0c7fb8bf01c175f8560de1123cfa/" rel="bookmark">
			sdc中跨时钟域(CDC)路径的约束方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看S家某IP关于CDC处理的SDC约束中，看到了一些有用的知识点和SDC约束，这里做一下总结。
1.通常的认识中，我们期望综合工具不要去检查和优化异步时钟之间的时序路径，所以只在sdc中将其设置为async，例如，当clk_a和clk_b为异步时钟时，可以把进行如下设置：
set_clock_groups -asynchronous -group clk_a -group clk_b
但在实际的项目中，还需要对异步时钟路径加一些特殊约束。其中set_max_delay和set_min_delay是比较常用的做法，set_max_delay会用于目的寄存器(destination flop)的setup check，set_min_delay会用于目的寄存器(destination flop)的hold check。set_max/min_delay需要加上-ignore_clock_latency开关，保证在计算异步时钟路径的delay时，不考虑clock tree latency（只会在CTS之后存在）
2.为了使set_max/min_delay生效，需要注意以下两点：
1）设置set_max/min_delay的路径，不能加set_false_path，因为此设置的优先级更高
2）异步时钟之间不能像前面给的例子中，只设置async，而应该加入-allow_paths，完整命令如下：
set_clock_groups -asynchronous -allow_paths -group clk_a -group clk_b
以下是Synopsys Synthesis Commands中关于该选项的解释
-allow_paths
Enable the timing analysis between specified clock groups. If this option is not specified, the timing analysis among the defined clock groups are disabled. This option can be used with asynchronous clock groups only.
3.当异步时钟域之间传递格雷码数据，且目的时钟域用两级同步器（寄存器）采样数据时，应该set_max_delay为一个源时钟周期，set_min_delay为0。这样有两个好处：1.防止数据路径太长而导致较长的同步所需时间，引起电路性能下降 2.限制格雷码的多个bit之间的skew，防止多个bit在目的时钟域的寄存器输入端同时变化，使得传递的数据不再是格雷码
4.当异步时钟域之间传递Qualifier-based Data Bus Signal时，应该set_max_delay为(同步级数-0.5)*目的时钟周期，set_min_delay为0。这样可以保证目的时钟域只会采样到稳定的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13ee0c7fb8bf01c175f8560de1123cfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c36b29677f123a77e39845d84abf487a/" rel="bookmark">
			考研[*数据结构*]学习笔记汇总（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录：
一：预备阶段
二：基础阶段笔记
三：冲刺阶段笔记
四：各章节思维导图
五：题库
来源：王道计算机考研 数据结构 一：预备阶段 之前的数据结构笔记
数据结构——学习笔记——入门必看【建议收藏】
数据结构——课堂笔记【上课重点知识截图】
数据结构——考前查漏补缺
数据结构与算法基础——重要知识点截图【青岛大学-王卓版】
二：基础阶段笔记 数据结构理论附加笔记
考研数据结构笔记——第一章 绪论
考研数据结构笔记——第二章 线性表
考研数据结构笔记——第三章 栈和队列
考研数据结构笔记——第四章 串
考研数据结构笔记——第五章 树和二叉树
考研数据结构笔记——第六章 图
考研数据结构笔记——第七章 查找
考研数据结构笔记——第八章 排序
三：冲刺阶段笔记 考研数据结构冲刺笔记
四：各章节思维导图 考研数据结构各章节思维导图
五：题库 数据结构——【十五套卷子】考前题型归纳整理
之前找的题库
考研数据结构历年真题(选择题)整理 考研数据结构历年真题(算法设计题)整理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b28cebb43f522760655a7fac8a405d8d/" rel="bookmark">
			shell双重循环之小实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写一个逛网上商城选购商品脚本，每家商店有五种商品选购（衣服500元，裤子400元，鞋子350元，帽子150元，袜子50元），每次选购完或不买都会提示用户是否继续逛下一家商店，如果不再继续逛的话进行购物车结算总
#!/bin/bash
PRICE=$( expr $RANDOM % 1000)
TIMES=0
echo "商品实际价格为0-999之间，猜猜看是多少？"
while true
do
read -p "请输入你猜测的价格数目：" INT
let TIMES++
if [ $INT -eq $PRICE ]
then
echo "恭喜你答对了，实际价格为 $PRICE"
echo "你总共猜测了 $TIMES 次"
exit 0
elif [ $INT -gt $PRICE ]
then
echo "太高了！"
else
echo " 太低了！"
fi
done
将一个点分十进制格式的IP地址转换成点分二进制格式。
#!/bin/bash
read -p "请输入ip" a
e=. #定义变量值为.作为分隔符
a1=`echo $a | awk -F. '{print $1}'`
a2=`echo $a | awk -F.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b28cebb43f522760655a7fac8a405d8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6f1181b159989a9dd7357e78244d400/" rel="bookmark">
			【深度学习】 基于Keras的Attention机制代码实现及剖析——Dense&#43;Attention
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 大部分代码来源于网上，但网上的代码一下子可能难以入门或因版本原因报错，此处整理后进行详细分析。
参考的代码来源1：Attention mechanism Implementation for Keras.网上大部分代码都源于此，直接使用时注意Keras版本，若版本不对应，在merge处会报错，解决办法为：导入Multiply层并将attention_dense.py第17行的：
attention_mul = merge([inputs, attention_probs], output_shape=32, name=‘attention_mul’, mode=‘mul’)，改为：attention_mul = Multiply()([inputs, attention_probs])即可。
参考的代码来源2：[深度应用]·Keras极简实现Attention结构。这相当于来源1的简化版本，其将注意力层还做了封装，可直接使用。但此方法运用了两个注意力层，使我有些不太理解，这个问题在后面会进行讨论。
本文主体将在来源1的基础上进行分析探讨。Attention机制大致过程就是分配权重，所有用到权重的地方都可以考虑使用它，另外它是一种思路，不局限于深度学习的实现方法，此处仅代码上分析，且为深度学习的实现版本。更多理论请看解读大牛文章深度学习中的注意力机制(2017版)，还可以看解读这篇文章的大牛文章：[深度概念]·Attention机制实践解读。此处仅介绍Dense+Attention，进阶篇LSTM+Attention请看【深度学习】 基于Keras的Attention机制代码实现及剖析——LSTM+Attention。 如果你对本系列感兴趣，可接以下传送门：
目录 说明实验目的数据集构造模型搭建模型训练及验证拓展多分类问题时，Attention效果如何？拓展总结 实验目的 在简单的分类模型(如最简的全连接网络)基础上实现Attention机制的运用。检验Attention是否真的捕捉到了关键特征，即被Attention分配的关键特征的权重是否更高。在已有的模型基础上适当做些变化，如调参或新加层，看看Attention的稳定性如何。 数据集构造 因为是在分类问题上进行应用，所以需要构造特征(X)和标签(Y)，此处数据随机产生，但为了进行Attention机制的有效性验证，我们将特征X的某一列置成和标签完全相同，如果Attention有效，那么模型学出来，自然这一列的权重就要最高。
默认设置：attention_column=1，即将 第“1”列(从0开始数) 与标签置成相同。
同时为了简化问题，将分类设置为二分类问题，即randint的参数high设置为2。(注意randint是左闭右开，所以当high=2时，y要么为0，要么为1)
def get_data(n, input_dim, attention_column=1): """ Data generation. x is purely random except that it's first value equals the target y. In practice, the network should learn that the target = x[attention_column]. Therefore, most of its attention should be focused on the value addressed by attention_column.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6f1181b159989a9dd7357e78244d400/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d09d67b80111d3a8c546747ff0ef130/" rel="bookmark">
			【深度学习】 基于Keras的Attention机制代码实现及剖析——LSTM&#43;Attention
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 这是接前面【深度学习】基于Keras的Attention机制代码实现及剖析——Dense+Attention的后续。
参考的代码来源1：Attention mechanism Implementation for Keras.网上大部分代码都源于此，直接使用时注意Keras版本，若版本不对应，在merge处会报错，解决办法为：导入Multiply层并将merge改为Multiply()。
参考的代码来源2：Attention Model（注意力模型）思想初探，这篇也是运行了一下来源1，做对照。在实验之前需要一些预备知识，如RNN、LSTM的基本结构，和Attention的大致原理，快速获得这方面知识可看RNN&amp;Attention机制&amp;LSTM 入门了解。 如果你对本系列感兴趣，可接以下传送门：
【深度学习】 基于Keras的Attention机制代码实现及剖析——Dense+Attention
【深度学习】 基于Keras的Attention机制代码实现及剖析——LSTM+Attention
【深度学习】 Attention机制的几种实现方法总结(基于Keras框架)
目录 说明实验目的实验设计数据集生成模型搭建Attention层封装LSTM之前使用AttentionLSTM之后使用Attention 结果展示注意权重共享+LSTM之前使用注意力注意权重共享+LSTM之后使用注意力注意权重不共享+LSTM之前使用注意力注意权重不共享+LSTM之后使用注意力结果总结完整代码(1个文件) 实验目的 现实生活中有很多序列问题，对一个序列而言，其每个元素的“重要性”显然是不同的，即权重不同，这样一来就有使用Attention机制的空间，本次实验将在LSTM基础上实现Attention机制的运用。检验Attention是否真的捕捉到了关键特征，即被Attention分配的关键特征的权重是否更高。 实验设计 问题设计：同Dense+Attention一样，我们也设计成二分类问题，给定特征和标签进行训练。Attention聚焦测试：将特征的某一列与标签值设置成相同，这样就人为的造了一列关键特征，可视化Attention给每个特征分配的权重，观察关键特征的权重是否更高。Attention位置测试：在模型不同地方加上Attention会有不同的含义，那么是否每个地方Attention都能捕捉到关键信息呢？我们将变换Attention层的位置，分别放在整个分类模型的输入层(LSTM之前)和输出层(LSTM之后)进行比较。 数据集生成 数据集要为LSTM的输入做准备，而LSTM里面一个重要的参数就是time_steps，指的就是序列长度，而input_dim则指得是序列每一个单元的维度。
def get_data_recurrent(n, time_steps, input_dim, attention_column=10): """ Data generation. x is purely random except that it's first value equals the target y. In practice, the network should learn that the target = x[attention_column]. Therefore, most of its attention should be focused on the value addressed by attention_column.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d09d67b80111d3a8c546747ff0ef130/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21db3c4812243a5d6af8f3eb5de90a59/" rel="bookmark">
			NAS折腾：zeroTier简明教程（组成p2p的虚拟局域网）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		肯德基的店员过来了，要我帮忙点个五星，送一杯中可。挺开心的。谢谢。20220920 by SheZQ 0.一些吐槽 0. 缘起 因为想用unas上的aria2实现远程下载，但由于unas自带的uanywhere，只开放了80\443端口，并没有aria2用到的6800和6888端口。
当你远程访问NAS的时候，Aira2的WEBUI就会连接不上，你也没有服务器的设置权限去打开端口，也不能在服务器上设置反代。所以只能自己整内网穿透。
1.技术简明 网上把zeroTier（一下简称“z”）说的乱七八糟的，其实z的目的就是组个局域网，同样能实现虚拟局域网（vlan）技术的操作，也能实现z同样的效果，所以只是利用了z去做了一个中介的路由。
简单的理解就是如下图所示：
ZeroTier=wifi路由器 接入wifi的手机 接入wifi的设备1 接入wifi的设备2 ...... 1.zeroTier教程 1.注册与登录 首先先去注册zeroTier
zeroTier：官网 | 登录页面 | 手册
注册完成后登录账号
3.当然你有微软、谷歌、github账号的话，建议你直接点登录。
官网有时候会登录不上，所以建议直接到登录界面。
2.在你需要的设备上安装zeroTier zeroTier:下载 |
选择你的系统版本下载Tier即可，以下我举例windows和Unas的加入
本教程也是参照如图所示的Step1-3编制。 3. 创建虚拟的路由器 点击"Create A Network"新建一个路由器
依次为：
Network ID :“网络ID”----这个是zeroTier的一种标识，其他组网的设备依靠这个Id，与zeroTier建立的虚拟局域网链接。NAME：“名称”----你可以随意取名DESCRIPTION： “介绍、说明、描述”----你可以自己写一段你想要的备注上去。SUBNET：“子网”----有zeroTier分配给你的设备ip的地址池NODES：“节点”----你的链接过的设备数量，一般一个设备一个节点。CREATED：“创建时间”—你创建的这个虚拟局域网的时间。 4.进入设置 我们直接进入“Members”（成员选项卡），按照目前zeroTier的页面排布，setting会在前面，但默认的设置已经可以直接使用了。如果你没啥高阶需求的话。
Members才是小白需要设置的，其他的Setting、Rules都不用管。按下“箭头”按钮可以展开或折叠选项卡。
如图所示是没有加入任何设备的状态。 5.设备加入 windows安装好zeroTier后，启动zeroTier，在任务栏“右键”zerotier的图标出现菜单，点击“Join New NetWork”
填入NetWork ID，点击Join
接下来回到zeroTier的虚拟局域网的网页，他会用英文告诉你：“老伙计，有一台设备加入了这个网络。”
我们需要在Auth那一列勾选，已确定是否允许该设备加入本网络。这里我勾选确认。
勾选确认前
勾选确认后
其他设备操作类似。多个设备就这样组成一个局域网。
6.组网成功 组网成功后你是能直接通过ip访问该设备的共享文件的，或者访问nas设备。这里我举例访问我的nas设备。
首先了解我们需要认识的参数
Address 你使用的zeroTier客户端生成的参数。
Managed IPs，这些代表你们设备在局域网里各自的局域网ip地址。
Last Seen 最后一次看到这台设备在线的时间。
Version 客户端使用的ZeroTier的版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21db3c4812243a5d6af8f3eb5de90a59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19dd6eccfc520d1a18dd5e70315860a5/" rel="bookmark">
			第二章 学生指导(01 小学生身心发展的规律 02 学生心理发展与教育 03 小学生的学习)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第二章 学生指导 01 小学生身心发展的规律
02 学生心理发展与教育
03 小学生的学习
04 小学德育
05 小学美育
06 小学生安全与心理健康教育
07 学校与家庭、社会的协调
01 小学生身心发展的规律 一、个体身心发展的概念
二、个体身心发展的动因
三、影响人身心发展的因素
四、个体身心发展的一般规律与教学启示
一、个体身心发展的概念 了解 个体的身心发展是指个体随年龄增长而发生的身心有规律的、连续变化的过程，包括生理和心理两方面的发展。
二、个体身心发展的动因 单选 个体身心发展的动因：书上讲到了三个理论。单选题备考，做到理论和人物的一一对应即可。
1.内发论：人之所以会发展是内在的因素推动你发展。例如内在的需要、遗传素质、成熟机制等，只要是自身内部的因素都可以推动你发展。
（1）代表人物：大家只需要记住他们都属于内发论的代表即可。
①孟子：
A.他提出“得天下英才而教育之”，最早提出了“教育”一词，最早见于《孟子·尽心上》。
B.孟子认为人生下来就是善良的，他提出性本善的理论。生下来就是善良的，这是遗传决定的，所以他是内发论的代表。
②弗洛伊德：他提出了本我、自我、超我。由此他提出人的发展由性本能推动发展。人对性有渴望，性欲推动发展，性欲是内在的需要。
③威尔逊：提出基因复制理论。要想生出漂亮的孩子，那你就要找一个漂亮或帅气的对象。
④格赛尔：他做了双生子爬梯实验。这一实验有 A 和 B 双胞胎两个孩子，A出生后不多久就对他进行爬楼梯训练，让他学习爬楼梯，但是不对 B 进行爬楼梯训练，六个星期之后对 B 进行爬梯训练，发现 B 用了一小会的时间就快速的赶上了 A，甚至超过了 A，B 学习的晚但是学的还比较快，是因为到 6 周之后孩子的腿部肌肉成熟了，当成熟了之后再教他这些东西他学的更快，所以他强调成熟机制决定了人的发展。
⑤霍尔：他提出“一两的遗传胜过一吨的教育”。他认为遗传非常的重要。
⑥高尔登：他提出优生学的观点，优生优育。现在生孩子的时候要做各项检查，在备孕的时候也要补充各种叶酸、维生素等东西，是从优生优育的方面考虑，希望生一个健康的孩子，这样遗传素质比较好。
（2）口诀：“孟子（孟子）复（弗洛伊德）活（霍尔）训（威尔逊）高（高尔登）歌（格赛尔）”，孟子突然活过来了，鲁迅替他高声唱歌。
2.外铄论：认为外在的力量决定人的发展，例如外在的教育，外在的环境。
（1）代表人物：
①荀子：他认为人生下来就是恶的，性本恶，要通过后天的教育化性起伪，靠后天外在的教育让他变好，从善。
②洛克：口诀是“绅士的洛克在白板上画漫画”，他提出了白板说，他认为人生下来就是一张白纸，靠后天的教育着色。
③华生：他说“给我一沓健康的婴儿，不管你祖先状况如何，我都能把他们培养成从小偷到领袖各种各样的人物。”不管祖先如何，也就是不管遗传素质如何，都能给你培养成各种各样的人物，说明后天的教育很重要，强调外在的力量。
（2）口诀：“外婆（外铄论）寻（荀子）找落（洛克）花生（华生）”。
3.多因素相互作用论：人的发展既有内在的因素，也有外在的因素，代表人物皮亚杰。这一内容不考，大家理解即可。
三、影响人身心发展的因素 单选、简答 起主导作用的原因 【2011下简答】
（1）学校教育是有目的、有计划、有组织地培养人的活动。
（2）学校教育是通过专门训练的教师来进行的，相对而言效果较好。
（3）学校教育能有效地控制影响学生发展的各种因素。
（4）学校教育对人的影响比较全面、系统和深刻。 起主导作用的表现 简答
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19dd6eccfc520d1a18dd5e70315860a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75cc6e4fe707f71e5c969c0f43800d4f/" rel="bookmark">
			SQL 时间范围和时间粒度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 使用 SQL 进行业务数据计算时，经常会遇到两个概念：时间范围 和 时间粒度 。以 最近一天的每小时的用户访问人数 为例：
最近一天 是时间范围每小时 是时间粒度 常见的时间范围：最近五分钟、最近一小时、最近一天、最近一周、最近一月、最近一年、截止到今天、截止到本周、截止到本月、截止到今年。
常见的时间粒度：五分钟、小时、天、周、月、年。
大多数情况下，我们需要根据计算时间和时间范围，计算出业务数据的开始时间和结束时间，用于过滤业务数据；然后再根据业务数据的业务时间和时间粒度，计算出业务时间点，用于分组统计业务数据。
假设用户访问表（user_visit）记录如下：
iduidtimestamp1u12022-09-19 15:10:582u22022-09-19 16:24:193u12022-09-20 01:04:034u22022-09-20 02:12:365u12022-09-20 02:35:036u12022-09-20 03:10:27 使用 最近一天 过滤数据，开始时间：2022-09-20 00:00:00，结束时间：2022-09-21 00:00:00，SQL 伪代码：
SELECT * FROM user_visit WHERE timestamp &gt;= "2022-09-20 00:00:00" AND timestamp &lt; "2022-09-21 00:00:00" 过滤结果：
iduidtimestamp3u12022-09-20 01:04:034u22022-09-20 02:12:365u12022-09-20 02:35:036u12022-09-20 03:10:27 过滤后的业务数据，使用 小时 将业务时间转换成业务时间点，转换结果：
iduidtimestamp3u12022-09-20 01:00:004u22022-09-20 02:00:005u12022-09-20 02:00:006u12022-09-20 03:00:00 按小时分组统计用户访问人数，SQL 伪代码：
SELECT timestamp, COUNT(DISTINCT(uid)) AS uids FROM user_visit GROUP BY timestamp 统计结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75cc6e4fe707f71e5c969c0f43800d4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/395fe2aa50dcd370b33adcc335e57fd0/" rel="bookmark">
			5000预算组装台式机配置清单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.Intel10代酷睿i5-10400F+GTX1660Ti独显主机 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f15efb71b127907f188b6d22241b4bda/" rel="bookmark">
			接口用postman可以调的通，但页面请求失败404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为postman是可以调的通的
但请求404，明显是接口没调通，检查代理配置，请求路径。
我的错误就是请求的域名中带有‘/api’
配置代理时候没有注意到pathRewrite中，将api重写替换为空了；
请求404，多半是服务器没启动，或者请求路径错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f981335a877fa9a0833685d0a9a52e68/" rel="bookmark">
			数据库并发问题及四种隔离级别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据库并发问题
二、四种隔离级别
一、数据库并发问题 ● 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制,就会导致各种并发问题
脏读: 对于两个事务T1,T2,T1读取了已经被T2更新但还没有被提交的字段。之后, 若 T2 回滚,
T1读取的内容就是临时且无效的
不可重复读: 对于两个事务T1,T2,T1读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字 段, 值就不同了
幻读: 对于两个事务T1,T2,T1从一个表中读取了一个字段, 然后T2在该表中插入了一些新的
行。之后,如果T1再次读取同一个表,就会多出几行
● 数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题
● 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度,隔离级别越高,数据一致性就越好,但并发性越弱
二、四种隔离级别 隔离级别说明READ UNCOMMITED（读未提交）允许事务读取其他事务未提交的变更，会出现脏读、不可重复读、幻读的问题READ COMMITTED（读已提交）只允许事务读取已经被其他事务提交的变更，可以避免脏读，但存在不可重复读、幻读的问题READ COMMITTED（读已提交）确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新，避免了脏读和不可重复读，但存在幻读问题SERIALIZABLE（串行化）确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新、删除的操作，解决所有的并发问题，但是性能低下 ● Oracle支持的2种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED
● Mysql 支持4种事务隔离级别。Mysql默认的事务隔离级别为: REPEATABLE READ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50577e00d2a3f614ec34316f99d012a7/" rel="bookmark">
			debian9系统出现双IP解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用修改/etc/network/interfaces文件的方式设置静态IP会出现双IP情况
原因 ：在/etc/network/interfaces.d/目录下，eth0设置了一个IP，所以静态IP设置只需要在该文件下修改即可，不用再修改/etc/network/interfaces文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee35a04ffc2d914505beef5bf486f2a/" rel="bookmark">
			Flask03_路由传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# encoding=utf-8
"""
1、@app.route("/路由匹配/")：代表资源在服务器上的位置
（1）路由：Flask根据http请求的url在路由表中和定义好的进行匹配，找到对应的函数处理这个请求，此过程保存一个url到函数的映射关系称之为路由router
（2）Flask通过装饰器@app.route("路由后半部分")来定义，route内部代码会将其余前面的url拼接成一条完整的路由
（3）通过装饰器装饰在视图函数上，是指向视图函数的标志,用户可以通过url来访问,服务器通过url路由引导获取到：@app.route("/地址(一节)/")
（4）路由编写规则
A、开头必须"/"：强制规则，开头没有"/"是不合法的
B、结尾添加"/"：标准的url，类似文件夹，访问无"/"的url时，Flask会重定向，自动在结尾添加
C、结尾没有"/"：类似文件，访问添加了"/"的url时，会报404错误，可以保持url唯一，帮助搜索引擎避免重复索引同一页面
D、路由是可以重复的
（5）根目录：网站服务启动的目录就是根目录
（6）对于视图函数，代表视图函数的路由；对于静态资源，代表放在服务器当前web服务的根目录的位置
2、视图函数
（1）视图是处理请求，返回响应的代码块，函数名字不能重名
（2）函数的名字与路由的名字可以不一致(一般为了简明，保持一致)
3、路由讲解
（1）route装饰器：装饰视图函数，更加方便、优雅地写应用的URL
def route(rule, **options):
def decorator(f):
add_url_rule(rule, f.__name__, **options)
view_functions[f.__name__] = f
return f
return decorator
A、首先会调用add_url_rule 法，将装饰器中的URL规则添加进Map实例中，视图函数的名字会作为endpoint进行传递
B、在应用的view_functions中增加endpoint和视图函数的对应关系，可以在请求成功时方便地调用对应的视图函数
（2）add_url_rule
def add_url_rule(rule, endpoint, **options):
options['endpoint'] = endpoint
options.setdefault('methods', ('GET',))
url_map.add(Rule(rule, **options))
A、用来添加url与视图函数的映射，默认会使用view_func的名字作为endpoint，可以将URL和视图函数关联起来
B、使用url_for时，要看映射时的endpoint参数，只要传递一条规则rule和一个endpoint即可
C、可以传递一些关键字参数：路由rule、访问点endpoint、视图函数func
D、调用方法后，会调用Map实例的add方法，会将URL规则添加进Map实例中
&gt;&gt; app.add_url_rule(rule=路由,view_func=视图函数,endpoint=访问点)
（3）访问点endpoint：做反向解析
A、视图函数中关于url_map视图的映射应该是：[url-&gt;methods-&gt;endpoint]
B、methods=["POST","GET"])：methods用来限制请求方式
C、利用url_map找到所请求URL对应的endpoint访问点(通过url地址映射到端点endpoint)，利用view_functions表(默认空字典，存储endpoint：view_func键值对)查找到访问点对应的视图函数，最终匹配到函数，执行响应的功能函数
D、一个实例对象app的本质过程是通过url先找到endpoint的值(url_map映射)，然后endpoint在字典view_functions中找到视图函数view_func，同一实例对象app中试图函数名可以相同，但endpoint不能相同
E、url_map：维护URL规则和endpoint的映射
F、view_functions={键：值}：维护endpoint和视图函数的映射
G、默认访问点：使用route装饰器注册路由时，默认使用被装饰函数的 函数名作为访问点
H、自定义访问点：在使用route装饰器或调用add_url_rule()方法注册路由时，使用endpoint关键字参数可以改变默认行为
I、app.add_url_rule("/index2/&lt;int:yy&gt;",view_func=index2)：Flask中只有有名分组，yy用于接收参数
app.add_url_rule("/", view_func=index,endpoint="index12333444",methods=["POST","GET"])
def index1():
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ee35a04ffc2d914505beef5bf486f2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5374f2637abe6199814089c68703b4b/" rel="bookmark">
			在 Windows 10 中如何查看系统的激活状态？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看激活方法 方法一方法二方法三 升级到 Windows 10 或重新安装 Windows 10 后，可能需要检查 Windows 10 安装是否已激活，那么可以通过以下方法来实现：
方法一 开始按钮-&gt;设置（快捷键 Windows + I）
点击“更新和安全”，选择左边的激活，在右边就可以看到激活的信息
如果 Windows 10 许可证链接到 Microsoft 帐户，那么你将看到“Windows 通过链接到你的 Microsoft 帐户的数字许可证激活”消息；如果你使用的是本地帐户，你将看到“Windows使用数字许可证激活”消息；如果是通过 KMS 来激活的，那么你将看到上图中的激活信息。
方法二 打开资源管理器（Windows + E），右键单击“此电脑”，然后选择“属性”
把右边的窗口滚动到“更改产品密钥或升级 Windows”，然后查看激活信息
方法三 运行命令提示符
输入命令 slmgr /xpr，参数 xpr 是参看当前许可证状态的截止日期
要查看 slmgr 的更多用法，请在命令提示符中输入“slmgr /?”获取更多信息。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13e987ae0bd808d8b9154f86e285d668/" rel="bookmark">
			C#基础入门教程-方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
C#方法
C# 中定义方法
实例练习
C# 中调用方法
实例练习
实例练习
递归方法调用
实例练习
参数传递
按值传递参数
实例练习
按引用传递参数
实例练习
按输出传递参数
实例练习
实例练习
C#方法 一个方法是把一些相关的语句组织在一起，用来执行一个任务的语句块。每一个 C# 程序至少有一个带有 Main 方法的类。
要使用一个方法，您需要：
定义方法调用方法 C# 中定义方法 当定义一个方法时，从根本上说是在声明它的结构的元素。在 C# 中，定义方法的语法如下：
&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)
{
Method Body
}
下面是方法的各个元素：
Access Specifier：访问修饰符，这个决定了变量或方法对于另一个类的可见性。Return type：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 void。Method name：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。Parameter list：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。Method body：方法主体，包含了完成任务所需的指令集。 下面的代码片段显示一个函数 FindMax，它接受两个整数值，并返回两个中的较大值。它有 public 访问修饰符，所以它可以使用类的实例从类的外部进行访问。
实例练习 class NumberManipulator { public int FindMax(int num1, int num2) { /* 局部变量声明 */ int result; if (num1 &gt; num2) result = num1; else result = num2; return result; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13e987ae0bd808d8b9154f86e285d668/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3e134cf6ede04c0870b8f66e9085cb1/" rel="bookmark">
			Gstreamer基础讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gstreamer讲解 文章目录 Gstreamer讲解基础背景小结 元件（Element）衬垫(Pads)Gstreamer的面向对象Gstreamer的多线程 实用工具Gstreamer常用插件介绍gstreamer工程记录关于YUV的补充知识 基础 背景 ​ 从历史的角度来看，Linux在多媒体方面已经远远落后于其他的操作系统。Microsoft’s Windows 和Apple’s MacOS它们对多媒体设备、多媒体创作、播放和实时处理等方面已经有了很好的支持。另一方面，Linux对多媒体应用的综合贡献比较少，这也使得Linux很难在专业级别的软件上与MS Windows和MacOS去竞争。GStreamer正是为解决Linux多媒体方面当前问题而设计的。
​ GStreamer 是一个非常强大而且通用的流媒体应用程序框架。GStreamer并不受限于音频和视频处理, 它能够处理任意类型的数据流。主要的优点在于: 它的可插入组件能够很方便的接入到任意的流水线（pipeline）当中。这个优点使得利用GStreamer编写一个万能的可编辑音视频应用程序成为可能。
​ GStreamer框架是基于插件的。所有的插件都能够被链接到任意的已经定义了的数据流水线中。
官方网站：https://gstreamer.freedesktop.org/
小结 Gstreamer的优点
1.结构清晰且威力强大
GStreamer提供一套清晰的接口，无论是构建媒体管道的应用程序员还是插件程序员，均可以方便的使用这些API。
2.面向对象的编程思想
GStreamer是依附于GLib 2.0对象模型的，采用了信号与对象属性的机制。
3.灵活的可扩展性能
所有的GStreamer对象都可以采用GObject继承的方法进行扩展
所有的插件都可以被动态装载，可以独立的扩展或升级。
4.核心库与插件(core/plugins)分离
所有的媒体处理功能都是由插件从外部提供给内核的，并告诉内核如何去处理特定的媒体类型。
元件（Element） ​ 元件(Element)是GStreamer中最重要的概念。
​ 可以通过创建一系列的元件，并把它们连接起来,从而让数据流在这个被连接的各个元件之间传输。
​ 可以将若干个元件连接在一起,从而创建一个流水线(pipeline)来完成一个特殊的任务,例如,媒体播放或者录音。
​ 对程序员来说， GStreamer中最重要的一个概念就是GstElement对象。元件是构建一个媒体流水线的基本块。每一个元件都对应一个GstElement。任何一个解码器编码器、分离器、视频/音频输出部件实际上都是一个GstElement对象。
​ 下图为一个流水线的实例，实现 文件-&gt;音视频解码-&gt;分别播放 的功能
源元件（source element）
​ 源元件为管道产生数据，比如从磁盘或者声卡读取数据。下图是形象化的源元件，我们总是将**源衬垫(source pad)**画在元件的右端。
​ 源元件不接收数据，仅产生数据。你可从上图中明白这一点，因为上图仅有一个源衬垫（右端 ）。
过滤/类过滤元件（filter/filter-like element）
​ 过滤器(Filters)以及类过滤元件(Filter-like elements)都同时拥有输入和输出衬垫。他们对从输入衬垫得到的数据进行操作，然后将数据提供给输出衬垫。音量元件(filter) 、视频转换器(convertor) 、Ogg分流器或者Vorbis解码器都是这种类型的元件。
​ 类过滤元件可以拥有任意个的源衬垫或者接收衬垫。像解码器只有一个源衬垫及一个接收衬垫。而视频分流器可能有一个接收衬垫以及多个源衬垫，每个接收衬垫对应一种元数据流。
接收元件（sink element）
​ 接收元件是媒体管道的末端，它接收数据但不产生任何数据。写磁盘、利用声卡播放声音以及视频输出等都是由接收元件实现的。下图显示了接收元件。
将元件链接(link)起来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3e134cf6ede04c0870b8f66e9085cb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9e4611583a2a9902a519dc3e088bf8d/" rel="bookmark">
			Docker常用命令总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.docker run 创建容器并暴露端口 docker run -p 10001:80 -d nginx:latest 2.停止全部运行的容器，删除全部容器，删除全部镜像 docker ps -a | awk '{if(NR&gt;=2){print $1}}' | xargs docker stop docker ps -a | awk '{if(NR&gt;=2){print $1}}' | xargs docker rm docker images -a | awk '{if(NR&gt;=2){print $1}}' | xargs docker rmi 3.根据Dockerfile生成镜像 docker build -t centos7-nginx:v1 . 根据当前目录下的Dockerfile文件生成镜像，repository为 centos7-nginx,tag为v1
4.nginx首页位置 容器名为nginx-server
echo "nginx is working" &gt; /opt/nginx-server/index.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d7b6eceae1a0872240e5ffcf7215ed9/" rel="bookmark">
			如何在linux系统上安装wine来运行.exe文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主的系统是Ubuntu linux 首先打开终端，可用快捷键 Ctrl + Alt + T。
下图是官网
如果您使用的是 64 位系统，请开启 32 bit 架构支持（如果您之前没有开启的话）：
sudo dpkg --add-architecture i386 在过程中遇到问题可使用 su root 切换成root用户来运行。
下载添加仓库密钥：
sudo wget -nc -O /usr/share/keyrings/winehq-archive.key https://dl.winehq.org/wine-builds/winehq.key 这时我们更新一下安装包：
sudo apt update 然后安装 以下任意一个安装包：
稳定分支 sudo apt install --install-recommends winehq-stable 开发分支 sudo apt install --install-recommends winehq-devel Staging 分支 sudo apt install --install-recommends winehq-staging 在系统中有Ubuntu软件商店，打开商店在商店中搜索Q4Wine
点击启动后进入应用
点击文件—&gt; 运行—&gt;选择需要运行的程序即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3431bce59d419b25b2f6bddd1f4a24b/" rel="bookmark">
			Dockerfile实现容器镜像的自定义及生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Dockerfile介绍 Dockerfile是一种能够被Docker程序解释的剧本。Dockerfile由一条一条指令组成，并且有自己的书写格式和支持的命令。当我们需要在容器镜像中指定自己额外的需求时，只需要在Dockerfile上添加和修改指令，然后通过docker build生成我们自定义的容器镜像（image）
二.Dockerfile指令 1.构建类指令 用于构建image，其指定的操作不会在运行image的容器上运行
FROM MAINTAINER RUN ENV ADD COPY 2. 设置类指令 用于设置image的属性，其指定的指令将在运行的image的容器中执行
CMD ENTRYPOINT USER VOLUME WORKDIR ONBUILD EXPOSE 指令说明
1.FROM FROM &lt;image&gt;:&lt;tag&gt; 如FROM centos:latest 2.RUN RUN指令用于构建镜像中执行命令，有以下两种格式
shell格式
RUN &lt;命令&gt; 如 RUN echo 'kunkun' &gt; /var/www/html/index.html exec格式
RUN ["可执行文件","参数1","参数2"] 如 RUN ["/bin/bash","-C","echo kubkub &gt; /var/www/html/index.html"] 注意：如果有多条RUN指令，应该用&amp;&amp;连接，方便查看
3.CMD CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时索要执行的命令
格式有三种
CMD ["executable","param1","param2"] CMD ["param1","param2"] CMD command param1 param2 一个在物理机中执行，一个在容器中执行
每个Dockerfile只能有一条CMD指令，如果有多条CMD指令，只有最后一条会被执行；
如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令
什么是启动容器时指定运行的命令
docker run -d -p 80:80 镜像名 运行的命令 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3431bce59d419b25b2f6bddd1f4a24b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/781823924ad0bcc71e9b901136ebcec6/" rel="bookmark">
			程序员 40 岁之后的出路在哪里？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天看了一篇文章《面试了一个 46 岁的程序员，思绪万千》，看完也感慨良多。 一个 46 岁的程序员，不得不写代码养家糊口，在技术和语言能力上与他的年龄完全不符。 最后面试没有通过。 笔者一再强调，面试没有通过，不是年龄问题。 作者有很多想法，因为他引起了自己内心的危机感。
程序员 35 岁以后真的没有出路了吗？ 我认为技术人员的未来有很大的想象空间。 至少有三个方向可供选择：
继续走技术研发方向，成为该领域的佼佼者。 走项目经理、技术总监等技术管理路线，培养第二技能，结合自己的技术能力
1、 继续走技术研发方向，成为该领域的顶尖人才 第一个方向是继续走研发方向。 走这条路，首先要端正心态。 这条路注定会越来越艰难，但艰辛是值得的。 你可以这样理解：这条路越难走，走到尽头的人就越少，你面临的竞争就越少。 你的门槛越来越高。
越底层越抽象。 要想在技术方向上打到最底层，就必须有非常扎实的基本功。 现在有很多面向业务的语言（如 PHP、Java、Vue 等），如果你是做 PHP 开发的，那你就得去 PHP 源码层面研究一下 PHP 底层是怎么做的语言实现。 如果你做 Java 开发，你必须了解 JVM 的原理和实现。
PHP 程序员常说：PHP 是世界上最好的语言！ 但是你有没有想过，如果有一天 PHP 被淘汰了怎么办？ 如果你已经达到了一定的技术水平，你完全不用担心这个。 因为我从未听说过有一天 C 语言会过时。 面向业务的语言总有一天会过时，但构建复杂网络世界的底层语言永远不会过时。
所以，如果你选择这条路，早期可能会是痛苦和孤独的。 但是一旦你跨过了临界点，你的人生就会一帆风顺！
2、 走管理路线 很多程序员最终选择了走管理路线，这和技术开发的思路完全不同。 技术人员要管理，如果不能转变思想，就很难取得成功。
走管理路线，首先要转变心态。 从利己的心态到利他的心态，遇到问题要承担责任，要与下属分享荣耀。 做事的方式也应该改变。 你可以提前充电，但你不能自己做所有事情。 在您成为经理之前，您是一名冲锋陷阵的将军。 当你成为经理后，你是后方战略的指挥官。 您对整体情况和结果负责。 另外，你要做到奖惩分明，有理有据。
接下来要做的是分解任务和目标。 你需要对需求有足够的了解，同时对每个下属有足够的了解。 你需要能够合理的拆解任务，分配给每个人，让每个人都清楚我们的目标是什么。 常见的问题是目标不明确、目标不合理、目标过高。 一个好的管理者必须为团队设定明确的目标（可以参考 SMART 原则）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/781823924ad0bcc71e9b901136ebcec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8790a4ac27c41de769f052f24b2395b6/" rel="bookmark">
			pm2基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.pm2的基本介绍 pm2是node的进程管理器，利用它可以简化node任务的管理,且内置了许多功能,常用于后台脚本管理。
pm2特性 自带热部署 - - - 当源文件更新 线上项目也会自动重启后台运行 - - - 不会占用实时窗口 会在后台运行服务信息查看 - - - 查看运行中程序的各项信息日志系统 - - - 可以随时查看程序的运行日志内置负载均衡 - - - 在cluster模式会自动使用轮询的方式达到负载均衡的效果多平台支持 - - - 在linux windows macOS 上都可以稳定的运行最大内存重启 - - - 可以设置最大内存限制超过限制则会自动重启；
还有很多的特性 咱就不一一举例了感兴趣的朋友可以去官网查看学习 小的这就献上官网地址 官网地址 2.pm2的安装 // 这里我使用npm进行pm2的全局安装 $ npm install -g pm2 // 安装完成后可以使用 -v 参数 查看pm2的版本 检测是否安装成功 $ pm2 -v 3.pm2的基本使用 // 第一条要介绍的是pm2的启动命令 $ pm2 start [项目入口文件名] 这里我使用一个 node.js内置的http模块搭建的一个简单服务器程序来演示
// serve.js var http = require("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8790a4ac27c41de769f052f24b2395b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4451a255233da60fccfd30cedbd20efa/" rel="bookmark">
			计算机网络:TCP三次握手可能出现的问题及攻击手段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、握手阶段消息丢失第一次握手消息丢失（SYN)第二次握手消息丢失（SYN+ACK）第三次握手消息丢失（ACK） 二、握手阶段队列已满三、SYN洪泛攻击1.洪泛攻击是什么2.解决措施 前言 对于TCP三次握手和四次挥手大多数读者想必已经烂熟于心，但是对于TCP三次握手和四次挥手之间可能出现的问题，很多时候我们并没有给予细致的关注，笔者依然如此，因而想借周末的晚上，对相关问题进行一番整理
先放一张TCP三次握手的图
再放一张TCP四次挥手的图
一、握手阶段消息丢失 现象：TCP在握手/挥手阶段发出的消息在数据传播的过程中丢失
解决原则：ACK不会重传，SYN和FIN报文段有最大重传次数。无论是SYN还是FIN，达到最大重传次数后对端若仍无响应则直接进入CLOSED状态。
第一次握手消息丢失（SYN) 正常：当客户端想要与服务器建立TCP连接时，首先要发送第一个SYN报文段，然后将本端的TCP状态置为 SYN_SENT。
异常：客户端没有收到服务端的ACK确认回应，接下来便会进入超时重传阶段
超时时间判断： 不同版本的操作系统可能超时时间不同，一般为 1秒 或 3秒，由内核配置，修改需要重新编译内核。
重传次数： 由内核参数 tcp_syn_retries 配置，默认值为5，可手动修改。
重传周期： 按指数退避计算重传周期，第一次超时重传是 1秒，第二次超时重传是 2秒，第三次超时重传是 4秒，第四次超时重传是 8秒，第五次超时重传是 16秒，以类类推，直到达到最大重传次数后，客户端不再重传SYN报文段，断开TCP连接。 此时 connect会返回 -1，并设置 errno 为 ETIMEOUT。
如果达到默认最大重传次数后断开TCP连接，总耗时为：
1+2+4+8+16+32 = 63秒，大约 1分钟。
关于TCP内核参数的修改：
所有TCP/IP参数（注意是TCP/IP协议族的所有参数，不止TCP参数）都位于 /proc/sys/net目录下，注意此目录下的内容修改都是临时的，任何修改在系统重启后都会丢失。
例如对 tcp_syn_retries 参数的修改：
echo 5 &gt; /proc/sys/net/ipv4/syn_timeout_retries 第二次握手消息丢失（SYN+ACK） 正常：服务端在收到客户端的第一次握手SYN报文段后，将TCP状态置为 SYN_RECV状态，并发送SYN+ACK报文段给客户端。
异常：如果第二次握手的报文段丢失，服务端会发起重传；客户端由于收不到SYN+ACK，无法判断是第一次握手的SYN报文段丢失，还是第二次握手的SYN+ACK报文段丢失，所以客户端也会发起重传。
这一情况可能会导致客户端和服务端一起发生重传，重传过程如第一部分所述，服务端的 SYN+ACK重传次数由参数 tcp_synack_retries 配置。
第三次握手消息丢失（ACK） 正常：客户端在收到服务端的第二次握手SYN+ACK报文段后，将TCP状态置为 ESTABLISH 状态，并发送ACK报文段给服务端。
异常：如果第三次握手的ACK报文段丢失，则服务会重传SYN+ACK报文段，直到收到ACK响应或者达到最大重传次数。
第三次握手的ACK报文段没有重传，当ACK丢失，只能依靠服务端重传SYN+ACK报文段。
如果握手阶段ACK持续丢失，那么对于服务端来说会发生以下情况：
超过服务端最大回传次数，放弃此次连接，服务端状态充值 对于客户端来说，会发生以下两种情况
未发送数据，等到一定时间后，客户端会检查连接状态，发现检查失败，那状态重置，将连接从半连接状态中移除发送数据，得不到服务端的回应，然后发现连接失败，那状态重置 二、握手阶段队列已满 我们知道，对于客户端和服务端之间的连接，其实存在半连接队列和全连接队列：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4451a255233da60fccfd30cedbd20efa/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/205/">«</a>
	<span class="pagination__item pagination__item--current">206/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/207/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>