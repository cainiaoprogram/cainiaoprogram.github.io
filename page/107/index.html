<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51d3860a9c7867afd4e6b1655c5c7aa8/" rel="bookmark">
			Focal and Global Knowledge Distillation for Detectors（CVPR 2022）原理与代码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		paper：Focal and Global Knowledge Distillation for Detectors
official implementation：https://github.com/yzd-v/FGD
存在的问题 如图1所示，前景区域教师和学生注意力之间的差异非常大，背景区域则相对较小。此外通道注意力的差异也非常明显。
作者还设计了实验解耦了蒸馏过程中的前景和背景，结果如表1所示，令人惊讶的是，前景背景一起进行蒸馏的效果是最差的，比单独蒸馏前景或背景还差。
上述结果表明，特征图中的不均匀差异会对蒸馏产生负面效果。这种不均匀差异不仅存在于前背景之间，也存在于不同像素位置和通道之间。
本文的创新点 针对前背景、空间位置、通道之间的差异，本文提出了focal distillation，在分离前背景的同时，还计算了教师特征不同空间位置和通道的注意力，使得学生专注于学习教师的关键像素和通道。
但是只关注关键信息还不够，在检测任务中全局语义信息也很重要。为了弥补focal蒸馏中缺失的全局信息，作者还提出了global distillation，其中利用GcBlock来提取不同像素之间的关系，然后传递给学生。
方法介绍 Focal Distillation 首先用一个binary mask \(M\) 来分离前背景
其中 \(r\) 是ground truth box，\(i,j\) 表示像素位置的坐标。
为了消除不同大小的gt box的尺度的影响和不同图片中前背景比例的差异，作者又设置了一个scale mask \(S\)
其中 \(H_{r},W_{r}\) 表示gt box \(r\) 的高和宽，如果一个像素属于不同的target，选择最小的box来计算 \(S\)。
接着作者借鉴SENet和CBAM的方法提取通道注意力和空间注意力
\(G^{S},G^{C}\) 分别表示空间和通道attention map，然后attention mask按下式计算
其中 \(T\) 是温度系数。
利用binary mask \(M\)、scale mask \(S\)、attention mask \(A^{S},A^{C}\)，特征损失 \(L_{fea}\) 如下
其中 \(A^{S},A^{C}\) 表示教师的空间和通道attention mask，\(F^{T},F^{S}\) 分别表示教师和学生的feature map，\(\alpha, \beta\) 是balance超参。
此外作者还提出了注意力损失 \(L_{at}\) 让学生模仿教师的attention mask
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51d3860a9c7867afd4e6b1655c5c7aa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dba616247ec115a1d709a04e9f741c0/" rel="bookmark">
			【嵌入式环境下linux内核及驱动学习笔记-（18）LCD驱动框架1-LCD控制原理】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、LCD显示系统介绍1.1 LCD显示基本原理1.1.1 颜色的显示原理：1.1.2 图像的构成 1.2 LCD接口介绍1.2.1 驱动接口 - MCU接口1.2.2 驱动接口 - RGB接口1.2.3 驱动接口 - LVDS接口1.2.4 驱动接口 - MIPI接口1.2.5 RGB / MIPI / LVDS三种接口方式的区别： 2、RGB控制原理2.1 LCD显示系统结构2.2 基本显示过程2.3 LCD时钟控制2.3.1 像素时钟2.3.2 水平同步时钟 HSYNC2.3.3 显示一帧 - 垂直同步时钟VSYNC 2.4 控制时序2.5 LCD时序与显示的映射关系2.6 linux对LCD时序的抽象2.6.1 struct fb_videomode 显示参数结构体2.6.2 判断 HSYNC,VSYNC,VCLK, VDEN信号是否需要反转 3、实验环境介绍4、 exynos4412的LCD控制器相关知识点介绍4.1 显示控制器介绍4.2 时钟4.3 RGB接口4.3.1 RGB接口控制器4.3.2 RGB接口规范4.3.3 信号4.3.4 LCD RGB接口时序 4.4 寄存器4.4.1 寄存器概况4.4.2 寄存器使用详述4.4.2.2 时钟寄存器CLK_SRC_LCD0 （P505）CLK_SRC_MASK_LCDCLK_DIV_LCD （P530）CLK_GATE_IP_LCD (P556) 4.4.2.3 系统寄存器LCDBLK_CFG (P884)LCDBLK_CFG2 （P886） 4.4.2.4 LCD控制寄存器VIDCON0 （P1838）VIDCON1 (P1839)VIDTCON0 (P1842)VIDTCON1VIDTCON2 (P1843)VIDTCON3 (P1843)WINCON0 (P1844)SHADOWCON (P1859)WINCHMAP2VIDOSD0A VIDOSD0B VIDOSD0C（P1863） 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dba616247ec115a1d709a04e9f741c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed703be9f9cf16a06414ce5cc7a192b4/" rel="bookmark">
			微服务间消息传递
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微服务间消息传递 微服务是一种软件开发架构，它将一个大型应用程序拆分为一系列小型、独立的服务。每个服务都可以独立开发、部署和扩展，并通过轻量级的通信机制进行交互。
应用开发
common模块中包含服务提供者和服务消费者共享的内容provider模块是服务的提供者，用于通过SpringMVC的控制器提供访问接口
服务提供者 @RestController @RequestMapping("/users") public class HelloController { @GetMapping("/hello") public String sayHello(@RequestParam String username) { if (username == null || username.trim().length() &lt; 1) username = "MicroService"; return "Provider: hello " + username + "!"; } } 服务消费者
服务消费者通过http协议访问服务提供者，可以使用JDK的URL或者使用HttpClient之类的工具，但是直接使用工具比较繁琐，所以使用SpringBoot提供的RestTemplate进行访问
在主类或者当前应用的配置类上声明RestTemplate
@SpringBootApplication public class ConsumerApplication { public static void main(String[] args) { SpringApplication.run(ConsumerApplication.class, args); } @Bean public RestTemplate restTemplate() { return new RestTemplate(); } } 核心配置，主要修改一下访问端口号，因为应用的默认端口都是8080，会有端口号冲突的问题
server.port=7081 定义控制器实现访问服务提供者 @RestController @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed703be9f9cf16a06414ce5cc7a192b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/718846ec81706d07e6cee59ed7634249/" rel="bookmark">
			Vue数据监视 内置指令 自定义指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue监视数据的原理： vue会监视data中所有层次的数据检测对象中的数据： 通过setter实现监视，且要在new Vue时就传入要监测的数据（1）对象中后追加的属性：Vue默认不做响应式处理（2）如需给后添加的属性做响应式，可以采用如下API Vue.set(target,propertyName/index,value) //或者 vm.$set(target,propertyName/index,value) 监测数组中的数据： 通过包裹数组更新元素的方法实现，本质上做了以下两件事情：（1）调用原生对应的方法对数组进行更新（2）重新解析模板，进而更新页面 在Vue修改数组中的某个元素，一定要使用如下方法 （1）使用这些API：push(),pop(),shift(),unshift(),splice(),sort()（2）Vue.set()或vm. s e t ( ) 【注意】： V u e . s e t ( ) 和 v m . set() 【注意】：Vue.set()和vm. set()【注意】：Vue.set()和vm.set()不能给vm或vm根数据对象添加属性 内置指令 v-bind：单向绑定解析表达式，可简写位 :xxxv-model：双向数据绑定v-for：遍历数组/对象/字符串v-on：绑定事件监听，可简写为@v-if：条件渲染（动态控制节点是否存在）v-else：条件渲染（动态控制节点是否存在）v-show：条件渲染（动态控制节点是否展示）v-text： 向其所在的节点中渲染文本内容 与插值语法的区别：v-text会替换掉节点中的内容，插值语法不会 v-html： 作用：向指定节点中渲染包含html结构的内容 与插值语法的区别： （1）v-html会替换掉节点中所有的内容，插值语法不会 （2）v-html可以识别html结构 【注意】：v-html有安全性问题 （1）在网站上动态渲染任意HTML是非常危险的，容易导致xss攻击 （2）一定要在可信的内容上使用v-html，永远不要在用户提交的内容上 v-cloak（没有值） 本质是一个特殊的属性，Vue实例创建完毕并接管容器后，会删除掉v-cloak属性 使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题 v-once（没有值）：所在节点在初次动态渲染之后，就是为静态内容了，以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能v-pre：让vue跳过所在节点的编译过程，可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译 自定义指令 new Vue({ //有两种自定义形式：函数式和对象式 //这样定义的指令为局部指令 directives:{ //big是自定义指令，使用时通过v-big使用 //调用时机：指令与元素成功绑定时，指令所在的模板被重新解析时 big(element，bingding){ console.log(this)//这里面的this是window element.innerText = bingding.value * 10 } //自定义fbind函数 fbind:{ //指令与元素成功绑定时调用 bind(){ } //指令所在元素被插入页面时调用 inserted(){ } //指令所在模板被重新解析时调用 update(){ } } } }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/718846ec81706d07e6cee59ed7634249/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1458376434eb460fcb6ec99bed7a875d/" rel="bookmark">
			Java 并发容器和框架Fork/Join详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
一 使用场景
1 大规模数据处理
2 复杂计算
3 并行搜索
4 并行排序
二 Fork/Join框架介绍
三 Fork/Join框架模块
四 Fork/Join框架核心思想
1分治思想(Divide-and-Conquer)
2 work-stealing(工作窃取)算法
五 Fork/Join框架执行流程
1 实现原理：
2 fork/join 整体任务调度流程
3 work-stealing 原理
六 Fork/Join框架源码解析
1 使用
2 具体原理实现
七 Fork/Join框架的陷阱和注意事项
八 Fork/Join在JDK8中的使用以及异常处理问题
九 Fork/Join实践问题
参考文献
一 使用场景 1 大规模数据处理 一个大型文件进行处理时候，可以用forkjoin将文件拆分成多个小块，然后并行处理这些小块，最终将结果合并起来。
2 复杂计算 大规模的图像处理时候，可以讲图像拆分成多个小块，然后并行处理，最后合并。
3 并行搜索 当需要在一个大型数据集中搜索某个元素时候，讲数据集拆分成多个小块，然后并行搜索这些小块，最后讲结果合并
4 并行排序 二 Fork/Join框架介绍 Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。
这种机制策略在分布式数据库中非常常见，数据分布在不同的数据库的副本中，在执行查询时，每个服务都要跑查询任务，最后在一个服务上做数据合并，或者提供一个中间引擎层，用来汇总数据：
三 Fork/Join框架模块 Fork/Join框架模块主要包含三个模块
1 任务对象ForkJoinTask (包括RecursiveTask，RecursiveAction ，CountedCompleter)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1458376434eb460fcb6ec99bed7a875d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17f662bba06143bd224c7fd323cf40a5/" rel="bookmark">
			10*1000【1】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7.20号
讲了蚂蚁的运行方式和关键技术：
数字技术实现了对金融的改革，让它更包容。当然也实现了消费方式的改变，是得以用户为中心。同时虚拟技术让个人也有了一个自己的小公司，在互联网上面的信息与信用都会被记录下来，作为与第三方交流的信任依据（借贷等等）。由此衍生了许多的信息安全问题，我们通过多方授权来修改网络上的信息(有一个专门的术语，忘了)，当然本源信息不可以改来保证安全。
课程主要打算讲阿里巴巴集团的三个方面（key）：支付，借贷，健康管理金钱（理财）等方面的事情。
讲了淘宝的运行机制：支付宝作为第三方的托管平台，买家先把付款的钱给支付宝托管然后卖家发货，如果买家觉得东西不错，确认收货，那么支付宝把钱打到卖家手里。
二维码：改变业务办理模式，（交水电非不用排长队了），线上不在使用POS机支付了（机器成本高，使用不方便，滑卡支付）。二维码人手一个使支付变得可以访问。
借贷方面：310规则
财富管理：阿里巴巴的余额宝：利用云计算和人工智能进行风险评估合理的让用户进行投资和理财。让用户用自己的闲钱选择喜欢的市场基金进行买股。【理财】。
-----------7.24----------
普惠金融是什么？它有什么麻烦？（尤其是在私营部门里面）普惠金融如何变得包容。
【是什么：1.对于供应者来讲（supply）：他们需要为普惠金融提供一个负责任而稳定的方式。{难}
2.对于消费者来说，他们需要一个有用的和可支付（afordable）的商品
【重要性：通过共有和私营部门的共合努力，普惠金融完全可以发展起来。甚至让低收入国家超过高收入国家。
注意一个点：相比于那些富有的人，脆弱群体属于普惠金融的照顾对象，如：妇女（女性），低教育人群，失业者等。
【按照地区划分的效果：
世界上最大的未普及的人口最多的地区：南非和东亚太平洋。但是值得高兴一下的是，亚洲与低收入和新兴市场相比，几乎差不多。
Mongolia：亚洲普惠率最大的国家。
亚洲应该抓住这次机会，为自己与世界做出贡献，
在东亚和太平洋的男女性的收入以及其他经济水平几乎一样，但是在南亚，的女性略微低于男性。
看一下划分标准： 目前的形势：
了解普惠金融的目标人群和它们的需求。
亚洲与其他低收入国家相比，优势是自己的信贷上面的信誉较高。
------------中国 推进普惠金融的案例--------------
不动资产:
------------中国的经验教训------------
要让人们懂得还贷款的意识，这也是对他们的保护。
---------案例研究1.：F-Road[上海的一家金融公司]---------
关于私营部门的能做的事，让农村的人上了网上银行的流程，为个体企业（微小型企业）建立了一种app，让个人也能够因为有信任机构而借到银行的钱。
----------------2.百度-------------
运行方式：
利基市场：就是那些高度专门化的需求市场。
百度的启发：
------------------7.28-关于非洲的数字金融--------------
-----------------非洲数字金融服务的发展趋势-
关键一：金融的包容性：移动货币已经代替了大部分的【FSP】金融提供服务商 关键二：创新，改革：通过使用应用程序和金融科技市场，增加支付服务的创新。
关键三：新平台：通过像Glovo&amp;Jumia这样为小企业服务的平台，数字和企业之间的融合现在包括金融服务作为其服务的一部分。
关键四：管理：整个非洲大陆的监管环境存在重大差异。撒哈拉以南非洲的监管比北非更加开放。然而北非的需求正在开放。
关于女性在银行账户上面的困难，金融普惠需要为女性账户在使用便利性上面下功夫
------------非洲如何促进普惠金融:概览
让普惠金融成为可能撒哈拉以南非洲：
非洲政府努力促进金融包容性：政府部门
--------------非洲如何促进金融包容性：私营部门
1.数字银行的普及以及价值链扩张所产生的数字化。
2.新冠(COVID-19)，使某些数字机构推动数字化支付。
3.产品围绕付款度的改进，越来越支持数字化支付。
普惠金融需要人和数字化相结合。人们不能在孤立的盒子里面运作，所以开放变得越来越重要，开放平台和开放金融的互操作性变得非常重要。
加密货币和数字银行看的风险：
了解不足；税收的引入，要从金融包容的角度征税；外汇的结算，【跨境交易的风险】；网络（店铺）的流动性；
-----------------个私营部门研究
kuda： Equity Bank【股权银行】：传统银行转型的趋势
Carma：试图协助或破坏银行结构以便获得大量数据信息
---------------金融服务的9大新兴趋势
开放银行作为大家支付手段的一种趋势，大的数据能为金融服务搭建结构并了解客户信息，客户体验就是你想的那样，伙伴关系对于整个产品的核心。起一个奠定的基础，人工智能是把1234点都给结合起来，呈现给客户使用。
总结：
1.关键
2.风险：
身份证，潜在税收，加密的数字货币
----------------数字经济与包容性趋势--------------
------------数字金融与包容性
重点：
中国在里面的主要改革：
中国央行数字货币将如何运作? 它对金融行业有什么启示?
DCPE:数字货币的电子支付，允许小额线上支付；个人用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17f662bba06143bd224c7fd323cf40a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45b115686325492daf3382c18576d4de/" rel="bookmark">
			在Linux中安装MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux中安装MySQL 检测当前系统中是否安装MySQL数据库
命令作用rpm -qa查询当前系统中安装的所有软件rpm -qa|grep mysql查询当前系统中安装的名称带mysql的软件rpm -qa | grep mariadb查询当前系统中安装的名称带mariadb的软件 RPM ( Red-Hat Package Manager )RPM软件包管理器，是红帽Linux(CentOS相当于此类系统的免费版)用于管理和安装软件的工具。
注意事项:
​ 如果当前系统中已经安装有MySQL数据库，安装将失败。CentOS7自带mariadb，与MySQL数据库冲突，如下，需要删除mariadb。
卸载已经安装的冲突软件
命令：rpm -e --nodeps 软件名称
将rpm的MySQL安装包上传到Linux并解压到 mkdir /usr/local/muysql
解压命令：tar -zxvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz -C/usr/local/mysql 按照顺序安装rpm软件包（以下的文件都具有依赖关系，所以必须按照顺序安装）：
rpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-devel-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpm yum install net-tools rpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm 安装顺序：common --&gt; libs–&gt; devel --&gt; libs-compat–&gt; client–&gt; net-tools --&gt; server
说明1:安装过程中提示缺少net-tools依赖，使用yum安装
说明2:可以通过指令升级现有软件及系统内核：yum update
启动mysql
命令作用systemctl status mysqld查看mysql服务状态systemctl start mysqld启动mysql服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45b115686325492daf3382c18576d4de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c1dfd411879d9178c4d6b407bcb3fbf/" rel="bookmark">
			二层vlan隔离下跨vlan互访配置和原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现二层不同vlan互通 通过配置同网段不同vlan实现PC1仅与PC2互通。 网络拓扑
Tag字段
TPID（0x8100）
PRI
CFI
VID
方案一：用混和接口进行配置
Hybrid具有在同一个网段实现不同vlan通信可以使用混合接口的配置那些接口剥离标记tag，那些接口不剥离tag。具有access和trunk口的功能。
配置
[SW1-GigabitEthernet0/0/1]port hybrid pvid vlan 10
[SW1-GigabitEthernet0/0/1]port hybrid tagged vlan 10
[SW1-GigabitEthernet0/0/1]undo port hybrid untagged vlan 20
[SW1-GigabitEthernet0/0/2]port hybrid untagged vlan 10 20
[SW3-GigabitEthernet0/0/2]port hybrid pvid vlan 20
[SW3-GigabitEthernet0/0/2]port hybrid tagged vlan 20
[SW3-GigabitEthernet0/0/2]undo port hybrid untagged vlan 10
[SW1-GigabitEthernet0/0/1]port hybrid untagged vlan 10 20
实现同网段不同vlan互访。
验证过程： 无标签数据帧进入SW时，被打上端口对应的vlan id ，在交换机中带标签传输，在离开时untagged。应为混合接口控制了tag标签的剥离与添加。
方案二：用Access口配置，添加和玻璃tag
实现原理：终端发送的数据帧untagged进入交换机的Access接口后，会被加上一个标记tag，这个标记用于表示当前端口号的PVID的所属的VLAN号，默认情况下交换机所有端口都属于VLAN 1，被加上这个标记的数据只会向被允许这个VLAN号通过的端口去转发，如果它的VLAN ID与端口的PVID不同时，数据帧会被丢弃，而当这个数据帧到达它的目标端口号后，这个标记就会被剥离，避免将打了标记的数据包传给终端。
将两交换机之间端口用Access类型。
Access口上的数据帧通常不会打上802.1Q的VLAN标签，只有在进入或离开交换机时，数据帧的VLAN标签才会被添加或移除。
配置方法：将交换机sw1，sw2 g0/0/1,g0/0/2 接口类型设为access，并划分到对应的vlan中,创建vlan10 20
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c1dfd411879d9178c4d6b407bcb3fbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/521ec5d5b1b4bb0308a04a68d63e4638/" rel="bookmark">
			OpenCV安装 error LNK2019: 无法解析的外部符号 “public: static struct cv::Ptr＜class cv::xfeatures2d::SURF＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的是缺少添加扩展的lib，在项目属性里面添加即可
opencv_xfeatures2d320d.lib
opencv_features2d320d.lib
这个应该是opencv扩展模块opencv_contrib工程编译出来的，CMAKE的时候要导入这个工程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbb51d2b3772d5fa6f2af01e7dd36c8b/" rel="bookmark">
			Verdi的使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在使用Verdi，于是结合自己使用，以及网络上他人总结过的使用技巧进行了一个汇总
1.加载设计和波形 加载Verdi须在makefile脚本中添加：
其中，verdi 表示启动 Verdi 工具的命令；-nologo 表示启动 Verdi 时不加载欢迎界面;-ssf $(TEST_NAME).fsdb 表示指定 Verdi 可识别的波形文件$(TEST_NAME).fsdb，可自动加载波形；&amp; 表示 Verdi 启动时新打开一个进程，不占用当前的 shell 环境进程。 2.重新加载设计和波形 在新一次仿真完成之后可选中波形或设计文件L（shift+l）重新加载波形或设计文件，也可点击file-&gt;reload design。
3.nWave使用 3.1 查寻模块实例化的位置 在nTrace界面 选中要查看的波形用鼠标左键拖拽到nwave界面选中要查看的波形使用ctrl+w快捷键 在nWave界面 若是没有自动添加波形可以，在nWave界面使用快捷键g加载信号，在弹出的窗口中选择需要添加的信号，点击apply手动添加信号。
3.2 观察波形 放大波形可使用快捷键shift+z，也可以左键托选放大范围，还可以直接点击nWave界面的zoom in缩小波形的快捷键为z，也可以点击nWave界面的zoom out：查看全局波形，快捷键为f，或直接点击nWave界面的100%符号移动信号，左键选取要移动的信号，中键选取要移到的位置（黄线），使用快捷键m即可将所选信号移动到黄线位置；也可以使用鼠标左键直接拖拽。复制信号，左键点击要复制的信号，点击右键选择copy；或使用快捷键ctrl+p粘贴信号，点击右键选择粘贴。删除信号，左键选中要删除的信号，点击快捷键del，或通过右键进行选择。显示结构，可以使用快捷键h看信号属于那个模块重命名： 3.3 标记时间差 鼠标左键可以定位一条黄色的时间线，鼠标中键可以定义一条白的时间线，点击nWave界面的Δ可以获得这两条时间线内的放大波形，Δ后可获取时间差
若想标记其他时间点来对波形进行定位，也可以使用快捷键shift+m功能进行标记，该过程可以选取标记线的位置，颜色等等。如下图所示，在5000ns处创建了一条蓝色的标记线。
3.4 进制之间的转换 3.5 符号数之间的转换 3.6 通过逻辑操作创建新信号 3.7 总线操作 操作
简述
生成
将所选的多个信号合成总线
抽取
选择多bit信号中的部分生成总线
编辑
处理当前数据总线信息
取反
可应用于大小端的场景
3.8 查找信号的某个值、某个值跳转到某个值 3.9 波形对比 3.10 nWave中的快捷键总结(shift+小写字母=大写字母) 快捷键
概述
a
Set Active,当一个波形窗口打开多个波形文件时，可以选择当前需要显示的波形文件
c
Color/Pattern,设置信号与波形颜色，线的类型及粗细
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbb51d2b3772d5fa6f2af01e7dd36c8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09f2416019d98bdec10d55f3f87b3f1d/" rel="bookmark">
			Linux centos7 sed命令的高级应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上看到这样一条命令，运用sed命令交换文件中任意两行数据，其代码应用知识众多，思路巧妙，符合项目学习训练的特点，很有启发性，特分析研究讨论。
一、案例 1.素材 先准备一个素材，文件passwd.demo中有6行数据
2.代码 交换^bin和^lp两行数据（^bin匹配行在前，这一点很重要）
分行编写代码，方便理解：
sed -r '/^bin/{
:a
N
s/(^bin[^\n]*)\n(([^\n]*\n)*)(^lp[^\n]*)$/\4\n\2\1/
t
ba
}' passwd.demo
为了提高可读性，每个sed命令都放在单独的行上。但是，可以选择将所有命令放在一行中，如下所示:
sed -r '/^bin/{:a;N;s/(^bin[^\n]*)\n(([^\n]*\n)*)(^lp[^\n]*)$/\4\n\2\1/;t;ba;}' passwd.demo
在把分行编写的代码转为一行时，仅需把换行改为分号";"即可。
3.效果 对照前面素材，已知达到目的，交换了两行数据。
二、知识点 行与行之间交换数据是常用训练项目。
两行交换实现起来并不难。学过编程的人都学过或遇到过变量交换:先把变量1交换给临时变量tmp，再把变量2交换给变量1，最后把临时变量交换给变量2。交换的实质：有一个舞台或中间环节！
sed两行交换正好有保持空间可用:sed读取行内容，在"模式空间"处理一下，然后保存在"保持空间"中，多次有效处理，最终达到交换的目的。
下面简单梳理一下本案例应用的知识。
1.循环 循环，其实就是一种重复，在满足指定的条件下，重复的做某些事情。可以说，循环通常都表现为条件转换的形式。
与其他编程语言一样，sed也提供了循环和分支语句来控制执行流程。虽没有专门的循环命令，但提供了跳转的命令，因而我们仍然可以实现循环，达到循环目的。
sed的循环方式类似于goto语句。sed可以跳到标签所标记的行，然后继续执行其余命令。在sed中，可以如下定义label：
:label
:start
:end
:up
在上面的示例中，冒号(:)之后的名称表示标语法称，一般称为标签名。
要跳转到标签，可以使用t/b命令，后跟标签名。如果省略标签名，则sed跳至文件的末尾。
2.条件判断 判断语句要求程序员指定一个或多个要测试的条件，以及条件为真时执行的语句（必需的）和条件为假时执行的语句（可选的）。
sed的条件判断没有if语句，没有switch语句，而是一个简单的b命令。
字符b是break的缩写。b/t都是sed中的分支（跳转）命令。
b的格式是'b label'，也可以去掉中间的空格，写作'blabel'。其作用是从:label处继续执行脚本。label必须在脚本中定义，且对标签的长度有限制，具体的限制可以参考sed faq。如果b后没有带标签，则默认转到脚本结束处。
当然了，我们也可以对条件取反，也就是条件测试不通过时才跳转，这时候就要用到逻辑非运算符"! "，具体的语法格式如下:
:label
some_code_here
/&lt;pattern/!t label
3.t b参数 定义了标签之后，如果要跳转到某个标签名，可以使用t命令。
t命令的语法格式为
t [label_name]
其中[label_name]为要跳转到的标签名。这是一个可选项，如果忽略，那么sed会跳转到sed命令文件的末尾，也就是结束所有sed命令。
条件为假时跳转到指定标签处，这时候就需要使用逻辑非运算符"! "，语法格式如下:
/pattern/!t label
t命令与b相似。不同点在于t是以前s命令的成功与否来决定是否跳转，如成功则跳转。如果在一个s命令后使用了多个条件跳转则第二个及其后的t都会失败。gnu sed还提供了与t相反的T命令。
4.N多行处理 N是把下一行加入到当前的模式空间里，使之进行后续处理，最后sed会默认打印模式空间里的内容。也就是说，sed及N是可以处理多行数据的。
sed是按行处理文本数据的，每次处理一行数据后，都会在行尾自动添加trailing newline,其实就是行的分隔符即换行符。连续两行执行一次sed命令，就可以把前一行的\n替换完成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09f2416019d98bdec10d55f3f87b3f1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bdf479ad77e807ef9f4273746a7fa85/" rel="bookmark">
			贝尔曼期望方程(Bellman Expectation Equation)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		马尔可夫决策过程之贝尔曼期望方程 价值函数与贝尔曼期望方程回顾策略的重要性策略的具体表现形式如何判断一个策略 π \pi π的优劣性 价值函数(Value Function)状态价值函数(state-value function)状态-动作价值函数(action-value function) 贝尔曼期望方程(Behrman Expectation Equation) V π ( s ) V_\pi(s) Vπ​(s)和 q π ( s , a ) q_\pi(s,a) qπ​(s,a)之间的关系贝尔曼期望方程 上一节介绍了马尔可夫奖励过程中(Markov Reward Process,MRP) 出现的概念，本节引入贝尔曼期望方程，讲述马尔可夫决策过程(Markov Decision Process, MDP)的逻辑具体是如何实现的。
价值函数与贝尔曼期望方程 回顾 在介绍马尔可夫奖励过程(MRP)内容中，讲述了马尔可夫决策过程(MDP)的逻辑场景及相关概念，在这里做一个简单回顾：
在某时刻 t t t的状态 S t S_t St​的情况下，在该时刻选择 A t A_t At​并执行，系统必然将当前状态 S t → S_t \to St​→下一个时刻状态 S t + 1 S_{t+1} St+1​,状态转移的同时返回奖励结果 R t + 1 R_{t+1} Rt+1​。 在本节中，重新对各概念和条件进行设定；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bdf479ad77e807ef9f4273746a7fa85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec43236748a99626bd6a6d4ae12da7ef/" rel="bookmark">
			【Spring Boot】拦截器与统一功能处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主简介：想进大厂的打工人博主主页：@xyk:所属专栏: JavaEE进阶 上一篇文章我们讲解了Spring AOP是一个基于面向切面编程的框架，用于将某方面具体问题集中处理，通过代理对象来进行传递，但使用原生Spring AOP实现统一的拦截是非常繁琐的。而在本节，我们将使用一种简单的方式进行统一功能处理，具体如下：
统一用户登录权限验证统一数据格式返回统一异常处理 目录
文章目录
0、我们先来回顾⼀下最初⽤户登录验证的实现方法：
一、统一用户登录权限验证
1.1 使用原生Spring AOP 实现统一拦截
1.2 使用Spring 拦截器实现统一用户登录验证
1.3 拦截器实现原理
1.4 实现原理源码分析
二、统一异常处理
三、统一数据返回格式
3.1 为什么要统一数据返回格式？
3.2 统一数据返回格式的实现
结语
0、我们先来回顾⼀下最初用户登录验证的实现方法： @RestController @RequestMapping("/user") public class UserController { /** * 某⽅法 1 */ @RequestMapping("/m1") public Object method(HttpServletRequest request) { // 有 session 就获取，没有不会创建 HttpSession session = request.getSession(false); if (session != null &amp;&amp; session.getAttribute("userinfo") != null) { // 说明已经登录，业务处理 return true; } else { // 未登录 return false; } } /** * 某⽅法 2 */ @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec43236748a99626bd6a6d4ae12da7ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eeb2eef66dc39d9a9dea8569f8d5842/" rel="bookmark">
			【三】Vue之后端交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【一】与后端交互 - ajax 【1】版本1 - 出现了跨域问题 (1)前端：index.html &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue与后端交互 - 出现了跨域问题&lt;/title&gt; &lt;script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="box"&gt; &lt;button @click="handleClick"&gt;加载数据&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; let vm = new Vue({ el: '#box', data: {}, methods: { handleClick() { $.ajax({ url: 'http://127.0.0.1:5000/', // 发送请求的url，本地的5000端口，是flask的默认端口 method: 'get', success: (data) =&gt; { console.log(data) } }) } } }) &lt;/script&gt; &lt;/html&gt; (2)后端：main.py from flask import Flask # 这里用轻量级的Flask框架来测试 app = Flask(__name__) @app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eeb2eef66dc39d9a9dea8569f8d5842/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6154aabe951ac1970a1296a898dc38e3/" rel="bookmark">
			mysql数据库的运算符优先级，常用的函数以及对mysql事务和索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.mysql的内部运算符很丰富，主要有四大类，分别是:算术运算符、比较运算符、逻辑运算符、位运算符 算术运算符：用于各类数值运算 加（+）
减（-）
乘（*）
除（/）
求余（或者称模运算）（%）
比较运算符：用于比较运算 大于（&gt;）
小于（&lt;）
等于（=）
大于等于（&gt;=）
小于等于（&lt;=）
不等于（!=）
IN、BETWEEN AND、IS NULL、GREATEST、LEAST、LIKE、REGEXP等
逻辑运算符：求值所得结果为1（TRUE）、0（FALSE）、这类运算符有 逻辑非（NOT或者!）
逻辑与（AND或者&amp;&amp;）
逻辑或（OR或者||）
逻辑异或（XOR
位运算符：参与运算的操作数按二进制位进行运算 位与（&amp;）
位或（|）
位非（~）
位异或（^）
左移（&lt;&lt;）
右移（&gt;&gt;）
2.常用的函数 COUNT()：用于计算查询结果的行数。
SUM()：用于计算某列的总和。
AVG()：用于计算某列的平均值。
MAX()：用于获取某列的最大值。
MIN()：用于获取某列的最小值。
UPPER()：将字符串转换为大写。
LOWER()：将字符串转换为小写。
CONCAT()：用于连接两个或多个字符串。
3.mysql的事物 事务是一组数据库操作，它们作为一个逻辑单元一起执行。在 MySQL 中，可以使用以下语句来管理事务：
START TRANSACTION：开始一个事务。
COMMIT：提交事务，将已执行的操作永久保存到数据库。
ROLLBACK：回滚事务，撤销已执行的操作，将数据恢复到事务开始之前的状态。
通过使用事务，可以确保一组操作要么全部成功提交（原子性），要么全部失败回滚（一致性）。事务还可以提供隔离性和持久性，以保证并发操作的正确性。
4.索引 索引的理解： 索引是一种数据结构，用于加快数据库表中数据的检索速度。在 MySQL 中，常见的索引类型包括 B-tree 索引、哈希索引和全文索引。
索引的作用是通过创建索引列的值和对应行的物理位置之间的映射关系，来提高数据的检索效率。当执行查询时，MySQL 可以利用索引快速定位到满足条件的数据行，而不用逐行扫描整个表。
创建索引可以加快查询的速度，但同时也会增加插入、更新和删除操作的成本。因此，在创建索引时需要权衡查询效率和数据修改的频率。
一些注意事项：
对于经常被使用作为查询条件的列，可以考虑创建索引来优化查询性能。
避免过多创建索引，因为索引会占用额外的存储空间，并影响插入、更新和删除操作的性能。
当表中的数据量较小时，索引的影响可能不明显，甚至会降低查询性能。在这种情况下，需要权衡是否创建索引。
定期维护和优化索引是保持数据库性能的重要步骤，可以使用 ANALYZE TABLE 和 OPTIMIZE TABLE 来进行索引优化和碎片整理。
总之，根据具体的业务需求和查询模式，合理地使用事务和索引可以提高数据库的性能和数据一致性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c336144fddd3bda809b67a98ff8ef65/" rel="bookmark">
			C&#43;&#43; 自定义标签和使用标签分发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;type_traits&gt; using namespace std; struct boy_tag { }; struct girl_tag{ }; struct boy { void eat() const { cout &lt;&lt; "eat two bowls"; } }; struct girl { void eat() const { cout &lt;&lt; "eat one bowl"&lt;&lt;endl; } }; template &lt;typename T&gt; void eat(T student, girl_tag) { cout &lt;&lt; "---" &lt;&lt; "girl" &lt;&lt; "---" &lt;&lt; endl; student.eat(); } template &lt;typename T&gt; void eat(T student, boy_tag) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c336144fddd3bda809b67a98ff8ef65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f922a467b7900774e9d30846d9a1a21/" rel="bookmark">
			【VMware】XP安装VMware Tools
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware虚拟机是一款很好用的软件，我们经常在上面安装体验其他的系统。但是，很多人发现在虚拟机上安装XP系统之后，发现不能像其他系统那样实现主机与虚拟机之间文件夹共享功能，实用性大打折扣。解决该问题的方法是：给XP系统安装VMware Tools软件。
环境 VMware版本：VMware Workstation 14.1.2 build-8497320
系统：Windows XP sp3
步骤 1、在VMware软件中启动Windows XP系统。
2、在VMware软件中点击菜单 虚拟机\安装VMware Tools。
3、 软件会弹出提示信息。
4、 在Windows XP系统中找到虚拟光驱，点击setup。安装时，一路选择默认设置。
5、安装完毕，Windows XP重启系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2712578abc1b90772b29fa09d85543d/" rel="bookmark">
			JavaEE——作业管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Springboot的简易学生作业管理系统 目录
一、大概介绍下项目结构:
二、项目结构图
三、页面实现
3.1身份为学生的页面实现效果（权限=1）
3.1.1登录
3.1.2注册
3.1.3登录成功
3.1.4查看学生名单
3.1.5学生管理作业（可提交、更新、删除作业）
3.1.6学生更新作业
3.1.7学生提交作业
3.2身份为教师的页面实现效果（权限=0）
3.2.1登录
3.2.2注册
3.2.3登录成功
3.2.4教师管理学生名单（可添加学生、更改学生信息、删除学生信息）
3.2.5教师更改学生信息
3.2.6教师添加学生
3.2.7教师管理作业
3.2.8教师更改作业信息
3.2.9教师布置新作业
3.2.10教师检查已提交的作业
四、代码解析
使用学生操作进行解析（教师和用户操作与学生操作大同小异）
实体类——model：Student
4.1表结构
4.2实体类
4.3mapper类
4.4mapper.xml
4.5service类
4.6controller类
4.7登录成功代码
4.8学生查看学生名单
4.9学生管理作业
4.10学生更改作业
4.11学生提交作业
五、Git地址
一、大概介绍下项目结构: 持久层框架使用的是：Mybatis(配置 .xml文件版)使用了RESTful：通过GET,POST请求实现各种功能模板引擎使用的是：Thymeleaf数据库使用的是：Mysql数据访问使用的是：Spring Data JPA 二、项目结构图 三、页面实现 3.1身份为学生的页面实现效果（权限=1） 3.1.1登录 3.1.2注册 3.1.3登录成功 3.1.4查看学生名单 3.1.5学生管理作业（可提交、更新、删除作业） 3.1.6学生更新作业 3.1.7学生提交作业 3.2身份为教师的页面实现效果（权限=0） 3.2.1登录 3.2.2注册 3.2.3登录成功 3.2.4教师管理学生名单（可添加学生、更改学生信息、删除学生信息） 3.2.5教师更改学生信息 3.2.6教师添加学生 3.2.7教师管理作业 3.2.8教师更改作业信息 3.2.9教师布置新作业 3.2.10教师检查已提交的作业 四、代码解析 使用学生操作进行解析（教师和用户操作与学生操作大同小异） 实体类——model：Student 4.1表结构 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2712578abc1b90772b29fa09d85543d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/701e36609d5a379d509c8f1b412d3822/" rel="bookmark">
			套接字的创建时机、新创建连接套接字的端口、套接字描述符的解惑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		套接字 套接字 socket是操作系统内核的一个数据结构，它是网络中节点进行相互通信的门户。网络编程实际上也可以称作套接字编程。
套接字有3种类型：
流式套接字，即TCP套接字，用SOCK_STREAM表示数据报套接字，即UDP套接字（或称无连接套接字），用SOCK_DGRAM表示原始套接字，用SOCK_RAM表示 套接字地址结构由网络地址和端口号组成。
传输方式 （1）TCP
TCP是一个面向连接的传输层协议，在数据发送之前（即进程通信之前)，必须先建立连接。通信完毕后，必须关闭连接。基于TCP传输协议的服务器与客户机间的通信工作流程如下图：
大致流程如下：
服务器先用socket()函数来建立一个套接字，用这个套接字完成通信的监听及数据的收发。服务器用bind()函数来绑定一个端口号和IP地址，使套接字与指定的端口号和IP地址相关联。服务器调用listen()函数，使服务器的这个端口和IP处于监听状态，等待网络中某一客户机的连接请求。客户机用socket()函数建立一个套接字，设定远程IP和端口。客户机调用connect()函数连接远程计算机指定的端口。服务器调用accept()函数来接受远程计算机的连接请求，建立起与客户机之间的通信连接。建立连接以后，客户机用write()函数（或close()函数）向socket中写入数据，也可以用read()函数（或recv()函数）读取服务器发来的数据。服务器用read()函数（或recv()函数）读取客户机发来的数据，也可以用write()函数（或send()函数）来发送数据。完成通信以后，使用close()函数关闭socket连接。 （2）UDP
不同于TCP协议，UDP是一个无连接的、不可靠服务的传输层协议，它不对数据进行确认、出错重传和排序等可靠性处理，但它却是具有代码小、实现简单那、速度快和系统开销小等优点。对于某些应用，使用UDP将带来更高的效率，如域名服务系统DNS、网络文件系统NFS等。
基于UDP传输协议的服务器与客户机间的通信工作流程如下图：
对比TCP套接字通信流程，区别在于：
使用TCP套接字必须先建立连接（如客户机进程的connect()，服务器进程的listen()和accept()） 而UDP套接字不需要先建立连接，它在调用socket()生成一个套接字后，在服务器端调用bind()绑定一个端口，然后服务器进程挂起于recvfrom()调用，等待并接收网络中某一客户机的数据请求。而客户端调用sendto()发送数据请求，同样也挂起于recvfrom()调用，等待并接收服务器的应答信号。
当数据传输完毕后，UDP套接字中的客户端调用close()释放通信链路，但不再发送“断开连接通知”信息来通知服务器端释放通信链路。 创建时机 每一个来自客户端的TCP请求在服务器端都会对应一个 socket。事实上，这个新 socket 的创建实机既不是在 listen 的时候，也不是在 accept 的时候，而是在三次握手成功之后创建的，然后放在对应的全连接队列中。
服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，如果服务器超时还未收到 ACK 会进行 SYN+ACK 的重传，重传的次数由 tcp_synack_retries 值确定，在 CentOS 上这个值等于 5。服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 全连接 队列，等待进程调用 accept 函数时把连接取出来。
accept会阻塞直到3次握手成功为止，也就是说accept发生在三次握手之后(没有accept 3次握手照样成功)。
服务器在 listen 状态的时候可以接收来自客户端的握手请求。当客户端发出的第三次 ack 到达时，服务器创建了新的 sock 对象（socket 的核心），然后加入到了全连接队列中。然后accept的时候，仅仅只是从全连接队列里把 sock 取出来而已。
套接字描述符 套接字描述符是一个整数类型的值，就如程序通过文件描述符访问文件一样，套接字描述符是访问套接字的一种路径。每个进程的进程空间里都有一个套接字描述符表(每个进程维护一个单独的套接字描述符表。因此，应用程序可以拥有相同的套接字描述符)，该表中存放着套接字描述符和套接字数据结构的对应关系。该表中有一个字段存放新创建的套接字的描述符，另一个字段存放套接字数据结构的地址，因此根据套接字描述符就可以找到其对应的套接字数据结构。每个进程在自己的进程空间里都有一个套接字描述符表但是套接字数据结构都是在操作系统的内核缓冲里。
从某种意义上说，套接字也是文件，所以许多对文件描述符使用的函数，对套接字描述符同样适用。每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。
在redis中，当下次这个client端往Redis服务器发送数据的时候，数据就会被内核拷贝到这个socket的输入缓冲区，然后aeEvent模块监听到这个事件就会调用readQueryFromClient函数。
write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再写入协议栈，即由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。read()/recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。 套接字端口 有一个问题：比如我的程序开了一个监听端口，与客户端建立连接之后，生成了一个新套接字。这时我执行了只关闭监听端口的语句，结果却发现监听端口和已建立的连接仍然存在。我都已经关闭了监听套接字，为什么客户端还可以继续往监听端口发信息？这到底是因为什么呢？新套接字和监听套接字有什么关系呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/701e36609d5a379d509c8f1b412d3822/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d348f92b3fa7e3987af9d2a686a5d9b/" rel="bookmark">
			【独立后台】快递小程序便宜寄快递系统小程序 对接易达
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快递代发项目简介：
顾名思义就是帮发快递。原本产业链是客户-快递之间的联系，现在变成了客户-我们-快递，简单来说就是我们把客户聚集到一起团购到了更优惠的价格。很简单就是赚一个差价，
单子多就能和各个快递合作的平台，能拿到优惠价格。
比如线下发快递首重10元，我们在线上平台能拿到首重5元的价格，这中间的差价就是利润空间。有很多种方法可以去引流，不担心客户来源。如果想具体了解可以联系客服。
是个不错的程序项目。 这一款自己对接自己的云洋易达接口，再也不怕割韭菜啦！完全是一套自己快递系统。
另外会员、分销等功能都有的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5ffe3c7ea8c2c6cda945fdc66d1a26a/" rel="bookmark">
			什么是Linux，如何在Windows操作系统下搭建Linux环境，远程连接Linux系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是LinuxLinux的诞生及发展为什么要学习LinuxLinux内核Linux发行版什么是虚拟机如何在VMware虚拟机中搭建Linux系统环境远程连接 Linux 系统Linux 帮助网站 什么是Linux Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。Linux操作系统诞生于1991年10月5日（这是第一次正式向外公布时间）。严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU工程各种工具和数据库的操作系统。
Linux的诞生及发展 Linux的诞生可以追溯到1991年，当时Linus Torvalds（林纳斯 托瓦兹）还是芬兰赫尔辛基大学的学生，为了能在自己的PC机上使用与学校一样的操作系统，他开始编写类似UNIX内核的工作。Linus使用的是MINIX，但他希望自己的操作系统能够超过MINIX的标准。到了1991年的10月5日，Linus在comp.os.minix新闻组上发布消息，正式向外宣布Linux内核系统的诞生。这段消息可以称为Linux的诞生宣言，并且一直广为流传。
在后来的几年中，Linux系统得到了不断的发展和完善。商业化和非商业的Linux发行版本开始出现，吸引了越来越多的用户和开发者。到了2010年，在Linux Kernel平台上工作的开发者已经达到1000位。
Linux的发展得到了许多公司和个人的支持，其中最为重要的就是GNU计划。GNU计划旨在开发一套完全自由的操作系统，弥补Linux的不足。Linux和GNU相结合，形成了一个完整的自由软件操作系统——GNU/Linux。
总的来说，Linux的诞生和发展是开源运动和自由软件运动的重要推动力量，为全球的计算机发展和软件开发做出了巨大的贡献。
为什么要学习Linux 开源性：Linux是一个开源操作系统，这意味着它的源代码对公众开放，任何人都可以查看、修改和分发它。这使得Linux具有透明性、灵活性和安全性，吸引了大量的开发者和社区参与，促进了技术的创新和改进。
广泛应用：Linux被广泛应用于各种领域，包括服务器、嵌入式系统、移动设备和云计算等。学习Linux可以让您掌握一种通用的操作系统，为您走向不同领域的IT职业提供更多机会和选择。
跨平台性：Linux能够运行在多种硬件平台上，从个人计算机到服务器集群，从手机到嵌入式设备。通过学习Linux，您可以获得与不同平台兼容的技能和知识，提高您的灵活性和适应性。
强大的命令行工具：Linux提供了强大而灵活的命令行工具，可以进行高效的系统管理、配置和脚本编程。熟练掌握命令行工具可以提高您的工作效率和自动化能力，并为您提供更大的控制力。
安全性：相比其他操作系统，Linux由于其开放源代码和庞大的社区支持，通常被认为更安全。通过学习Linux，您可以了解和实施安全最佳实践，提升您在保护系统和数据方面的技能。
职业机会：Linux在IT行业中的广泛应用和普及程度，为Linux技术人员提供了丰富的职业机会。从Linux系统管理员到网络工程师、云计算专家以及安全专家，有许多与Linux相关的职位和角色需要熟悉Linux技能。
社区支持：Linux拥有庞大而活跃的社区，提供了丰富的资源、论坛和博客，可以为学习者提供帮助和支持。通过加入Linux社区，您可以与其他开发者和专业人士交流、学习和分享经验。
Linux是服务器领域最厉害的操作系统，没有之一。
Linux内核 Linux内核是Linux操作系统的心脏，负责管理系统资源、处理系统请求、控制硬件设备等。它是基于Unix设计思想的操作系统，具有高效、稳定、安全和灵活等特点。
Linux内核主要由以下几个部分组成：
进程管理：负责进程的创建、终止、调度以及进程间的通信等。内存管理：负责内存的分配、释放、保护和共享等。文件系统：负责文件和目录的创建、读取、写入和删除等操作。设备驱动：负责与硬件设备的通信和控制。网络管理：负责网络协议的实现、网络连接的管理和网络安全等。系统调用：提供一组系统调用接口，用于应用程序与内核交互。 Linux内核是免费开源的，任何人都可以下载查看并修改源码。
大家可以通过 https://www.kernel.org/ 去下载Linux内核。
Linux发行版 Linux发行版（Linux distribution）是指将Linux操作系统和各种应用软件集成到一个预先打包好的系统中，以便一般用户可以方便、快捷地安装和使用。Linux发行版通常包含了桌面环境、办公套件、媒体播放器、数据库等应用软件，以及一个软件包管理系统，用于方便地安装、卸载和管理软件。
Linux发行版有很多种，如Ubuntu、Fedora、Debian、Arch Linux、CentOS等。这些发行版各有特点和优点，可以根据用户的需求进行选择。其中，Ubuntu和Fedora是比较流行的Linux发行版，而Arch Linux则以滚动更新和简洁的理念受到用户的青睐。
Linux发行版的发展一直非常活跃，不断推出新的版本和改进，以满足用户的需求和提高系统的性能和安全性。
什么是虚拟机 我们要想在非Linux系统下使用Linux，最好的方法就是使用虚拟机搭建一个Linux系统环境。
虚拟机（Virtual Machine）是指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。它可以在实体计算机中模拟出多个虚拟计算机，每个虚拟计算机都可以独立运行，并可以安装各种软件与应用等。
虚拟机在现实中的作用还是相当大的，比如在没有光驱的情况下，如果要安装系统就可以使用虚拟机来安装系统。另外，虚拟机技术在游戏爱好者朋友眼中也相当实用，比如一般一台电脑很多游戏不支持同时多开，但我们可以在电脑中多创建几个虚拟机，那么在虚拟机系统中即可单独再运行程序了，这样即可实现一台电脑同时多开同一游戏了。
目前流行的虚拟机软件有VMware（VMWare ACE）、Virtual Box和Virtual PC等。
接下来我将为大家分享如何使用VMware虚拟机来搭建Linux系统环境。
如何在VMware虚拟机中搭建Linux系统环境 一：下载VMware虚拟机
https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html
二：检查网络适配器
安装完成VMware之后，我们需要检查对应的网络适配器是否完成配置。WIN + R 输入 ncpa.cpl，查看是否有VMnet1 和 VMnet8。如果没有，需要重新安装 VMware 虚拟机。
三：下载 CentOs 操作系统
CentOs 是国内使用较多的操作系统，Ubantu 使用人数也较多，大家也可以试试这个操作系统。
CentOs官网
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5ffe3c7ea8c2c6cda945fdc66d1a26a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1e19a1124269e3551976825fc38529c/" rel="bookmark">
			LOL-v2数据集和VE-LOL数据集的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LOL-v2数据集和VE-LOL数据集的区别 LOL-v2 LOL-v2数据集[64]包括两个不同的子集，即LOL-v2-real和LOL-v2-synthetic。LOL-v2-real子集是通过改变ISO和曝光时间在真实场景中捕获的，包括689对用于训练和测试的图像。在LOL-v2-synthetic子集中，通过分析低光照图像的照明分布，从RAW图像合成低光照图像。该子集包含1,000对低光照/正常图像，选择了900对用于训练和100对用于测试。
VE-LOL VE-LOL [32]是一个用于低光照图像增强的大规模数据集，提供了2,500对低光照/正常光照的图像，场景更加多样化。与LOL不同，VE-LOL还在RAW图像级别考虑了噪声建模，并且使用了四种不同的相机捕获了噪声：索尼A7R、奥林巴斯E-M10、索尼RX100 IV和华为Nexus 6P。
为了公平比较，我们对这些方法使用已发布的代码，无需任何修改。由于 Zero-DCE(Guo et al., 2020) 和 EnlightenGAN(Jiang et al., 2021) 使用未配对的数据进行训练，我们使用他们发布的预训练模型进行比较。LOL 数据集 (Wei et al., 2018) 通过改变相机的曝光时间和 ISO 来捕获 500 对真实的低/正常光图像，其中包括 485 个训练图像和 15 个测试图像。VE-LOL(Liu et al., 2021) 包含两个子集：配对 VE-LOL-L 用于训练和评估LLIE 方法，并使用非配对 VE-LOLH 来评估LLIE 方法对人脸检测的影响。在这里，我们使用 VELOL-L。VE-LOL-L 中有 500 个真实场景图像，其中 400 个用于训练，100 个用于测试。
参考文献
Under review as a conference paper at ICLR 2023 RETINEXUTV: ROBUST RETINEX MODEL WITH UNFOLDING TOTAL VARIATION
LLDiffusion: Learning Degradation Representations in Diffusion Models for Low-Light Image Enhancement
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6114f40d2aadd1c500cae1833bc2290e/" rel="bookmark">
			Vue 项目 实现阻止浏览器记住密码功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 通常浏览器会主动识别密码表单，在你登录成功之后提示保存密码 ， 密码保存到浏览器的 密码管理器中 ( 如下是谷歌浏览器 )
这种行为是浏览器的行为 ，这种操作也是为了方便用户的使用
现在的一个需求是要阻止这个保存密码的弹窗提示 实现方法 查找资料发现的一些方法：
使用 autocomplete="off"（现代浏览器许多都不支持）使用 autocomplete="new-password"在真正的账号密码框之前增加相同 name 的 input 框使用 readonly 属性，在聚焦时移除该属性初始化 input 框的 type 属性为 text，聚焦时修改为 password使用 type="text"，手动替换文本框内容为星号 “*” 或者 小圆点 “●” 可以看到实现这个需求有许许多多的方法，但是实际上确有各种各样的问题，下面是我自己测试的几个方法
方法一 密码框添加 autocomplete="new-password" 属性
根 index.html 文件添加 meta 元数据 (该步骤可以省略)
密码输入框 &lt;el-input prefix-icon="el-icon-lock" type="password" name="xxxx" placeholder="密码" v-model="password" autocomplete="new-password" &gt; &lt;/el-input&gt; index.html 文件 (该步骤可以省略) &lt;!DOCTYPE html&gt; &lt;html lang=""&gt; &lt;head&gt; ..... &lt;meta name="autocomplete" content="off"&gt; ....... &lt;/head&gt; ...... &lt;body&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6114f40d2aadd1c500cae1833bc2290e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33fc34a568b41facabceb4748c34317a/" rel="bookmark">
			【Spring】Spring AOP 初识及实现原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主简介：想进大厂的打工人博主主页：@xyk:所属专栏: JavaEE进阶 目录
文章目录
一、初识AOP
1.1 什么是AOP？
1.2 AOP的组成
1.2.1 切面（Aspect）
1.2.2 切点（Pointcut）
1.2.3 连接点（Join Point）
1.2.4 通知（Advice）
1.3 AOP的使用场景
二、Srping AOP 实现
2.1 添加Spring AOP 依赖
2.2 定义切面和切点
2.3 定义通知
三、Spring AOP 实现原理
3.1 什么是动态代理？
3.2 JDK 动态代理实现
3.3 CGLIB 动态代理实现
3.4 JDK 和 CGLIB 实现的区别
一、初识AOP 1.1 什么是AOP？ AOP（Aspect Oriented Programming）：面向切面编程，它是⼀种思想，它是对某⼀类事情的
集中处理。在我们想要对某一件事情进行集中处理，就可以使用到AOP，它提供一种将程序中的横切关注点模块化的方式。在 AOP 中，我们将这些横切关注点称为“切面”，它们独立于业务逻辑模块，但是可以在程序运行的不同阶段被织入到业务逻辑中。
简单来说，AOP 就是对某一件事进行集中处理的思想方式~
1.2 AOP的组成 1.2.1 切面（Aspect） 切⾯（Aspect）由切点（Pointcut）和通知（Advice）组成，它既包含了横切逻辑的定义，也包
括了连接点的定义。相当于处理某方面具体问题的一个类，包含多个方法，而这些方法就是切点和通知。
1.2.2 切点（Pointcut） Pointcut 的作⽤就是提供⼀组规则来匹配连接点（Join Point），给满足规则的连接点添加通知（Advice），可以理解为用来进行主动拦截的规则（配置）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33fc34a568b41facabceb4748c34317a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f515bc1d9928f21c205d14d5c67abdff/" rel="bookmark">
			BI技巧丨利用OFFSET计算同环比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微软最近更新了很多开窗函数，其内部参数对比以往的DAX函数来说，多了很多，这就导致学习的时间成本直线上升。
而且对于新增函数的应用场景，很多小伙伴也是一知半解的，本期我们就来聊一聊关于最近新增的开窗函数——OFFSET函数。
OFFSET函数基础语法
OFFSET ( &lt;delta&gt;[, &lt;relation&gt;][, &lt;orderBy&gt;][, &lt;blanks&gt;][, &lt;partitionBy&gt;][, &lt;matchBy&gt;] ) 参数介绍：
delta：偏移量，正负数均可，可以是固定值，也可以是DAX表达式。
relation：表表达式，后续参数orderby，partitionby，matchby的内部参数，都需要来自它或相关表。
orderby：可选项，排序依据。
blanks：可选项，保留参数，可以忽略。
partitionby：可选项，分区定义，参照SQL的开窗分区即可。
matchby：可选项，定义匹配数据和标识当前行的列的语句。
PS：看到这里是不是有点晕？别慌，记住前2个参数即可，足以满足大部分应用场景。
接下来我们搭配应用场景来看一下如何使用OFFSET函数。
先来看看本期的案例数据：
案例数据就一张Sales的销售事实表，表结构也相对简单，将其导入到PowerBI中。
添加如下日期表，并建立模型关系。
Date = GENERATE ( CALENDAR ( MIN ( 'Sales'[DATE] ), MAX ( 'Sales'[DATE] ) ), VAR DA = [Date] VAR YEAR = YEAR ( DA ) VAR QUARTER = "Q" &amp; FORMAT ( DA, "Q" ) VAR MONTE = FORMAT ( DA, "MM" ) VAR DAY = DAY ( DA ) RETURN ROW ( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f515bc1d9928f21c205d14d5c67abdff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da76b2f2823a2499b538f26cb37f6127/" rel="bookmark">
			Linux centos7 sed命令学深一点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sed命令是流编辑器，对文件中的行一一处理，得到需要的结果。可增删改查文件，把处理后的数据重定向到新文件，或修改原文件。
在sed命令中引入变量、行处理、模式空间与保持空间是本文的重点。其中为了讨论方便，还引入了sed命令中的写文件与读文件。
一、sed中引入变量 我们先定义一些变量，在sed中使用。
sed命令中引入变量，共有三种方法。
1.命令使用单引号 sed命令使用单引号的情况下，可以使用'"$var"'引用（单引号，然后双引号，变量）：
sed '3s/test/'"$i"'/' /home/zhang3/a1.txt
2.命令使用双引号 sed命令中使用双引号的情况下，直接使用变量。
sed "4s/demo/$i/" /home/zhang3/a1.txt
3.添加eval命令 使用单引号，变量直接引用，但是需要通过eval执行这个sed命令。eval会对后面Shell命令进行两遍扫描，如果第一遍扫描后，Shell命令是个普通命令，则执行此命令；如果Shell命令是含有变量的间接引用，则保证间接引用的语义。
命令行可以测试：
name=lisi
eval sed -i 's/games/${name}/g' passwd
二、sed中读写文件 1.w文件 sed支持写文件命令。命令为单字母w，是write的缩写。
sed w命令用于将模式缓冲区的内容存储在另一文件中。
w语法
[address1[,address2]]w file
file是目标文件路径，也就是内容要备份/拷贝到的目标文件地址。
address1和 address2分别是 起始地址和结束地址，可以是行号或模式字符串。
address1和address2都是可选参数，可不填，这时候就是全文件拷本/备份了。
如果存在一个参数，那么就是备份单行。也就是只备份address1指定的那行。
如果file参数指定的文件不存在，sed会新建文件。
如果file参数指定的文件已经存在，sed会删除原内容。
案例
sed '3w line3' passwd
把文件passwd的第3行内容写入新文件line3中
sed '2,5 w demo.txt' passwd
把文件passwd的第2-5行内容写入demo文件中
sed '4,$w file.txt' passwd
把文件passwd的第4至最后一行内容写入file文件中
注意：
此处，$代表最后一行
w与文件名之间要有空格
起始地址和结束地址与w之间有没有空格都可以。
2.r文件 r 是读文件命令
r 是read 的缩写，后者翻译为中文是读取的意思。
r 命令的使用语法格式如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da76b2f2823a2499b538f26cb37f6127/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50b869d2d9269170c32235613e7b9a85/" rel="bookmark">
			【C&#43;&#43;】——内存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 回忆C语言内存管理C++内存管理方式new deleteoperator new与operator delete函数new和delete的实现原理定位new表达式(placement-new)malloc/free和new/delete的区别 回忆C语言内存管理 void Test() { int* p1 = (int*)malloc(sizeof(int)); free(p1); int* p2 = (int*)calloc(4, sizeof(int));//不用free int* p3 = (int*)realloc(p2, sizeof(int) * 10); free(p3); } C++内存管理方式new delete 通过new和delete操作符进行动态内存管理
C++自动计算大小，不需要进行强制类型转换
int main() { //动态申请一个int型的空间 int* p1 = (int*)malloc(sizeof(int));//C int* p2 = new int;//C++ //动态申请10个int型空间 int* p3 = (int*)malloc(sizeof(int) * 10);//C int* p4 = new int[10];//C++ free(p1); free(p3); delete p2; delete[] p4; return 0; } C++额外支持开空间和初始化
int main() { int* p1 = new int(10); int* p2 = new int[10] {1, 2, 3}; int* p3 = new int[10] {}; return 0; } malloc没有办法很好的支持动态申请的自定义对象初始化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50b869d2d9269170c32235613e7b9a85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b40925e55277a8bb44976c98e5c860a9/" rel="bookmark">
			Java Runnable，Callable和FutureTask详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
1 序言
2 基本概念
2.1 Runnable 和 Callable的区别
2.2 Future 和 FutureTask
2.3 ExecutorService中Future的应用
2.4 Future submit(Runnable task)
2.5 Future submit(Callable task)
2.6 ExecutorService中execute()在ThreadPoolExecutor中实现如下：
3 Future，RunnableFuture，FutureTask 关系
4 总结
参考文献
1 序言 本文针对多线程中使用的几种任务：Runnable、Callable、RunnableFuture，FutureTask等进行详细介绍
2 基本概念 2.1 Runnable 和 Callable的区别 Runnable和Callable都是定义了接口，可以用在线程池中异步执行，区别是：
Runnable可以直接被Thread执行，但是没有返回值Callable执行之后有返回值，但是只能提交给线程池执行。 2.2 Future 和 FutureTask Future是一个接口，主要是线程池中任务执行之后用于返回结果的获取，定义了
boolean cancel(boolean mayInterruptIfRunning); 取消任务boolean isCancelled(); 任务是否取消boolean isDone(); 任务是否执行完毕V get(); 获取任务执行的结果，注意这个方法阻塞线程V get(long timeout, TimeUnit unit)； 同上，只是增加了一个超时时间 Future有一个直接继承接口RunnableFuture，RunnableFuture有一个实现的子类FutureTask，RunnableFuture这个接口同时还继承了Runnable接口，这意味着FutureTask可以作为Future或者Runnable使用。
再来看一下FutureTask的实现，最终内部保存了一个Callable对象，也就是提交的任务
先看构造函数
一共2个构造函数，一个是接受Callable，一个是接受Runnable和默认返回值。
详细看一下第二个构造参数，注释很清楚的说明，当你需要runnable可取消同时不关心返回值时，可以这样构建
上面两个函数将一个Runnable适配成了一个Callable，是Executors中提供的静态方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b40925e55277a8bb44976c98e5c860a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3901e1b804b811713b4d510f2db5f446/" rel="bookmark">
			Jupyter Notebook 7.0 更新远程访问配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决：ModuleNotFoundError: No module named 'notebook.auth' 类似问题 背景介绍旧配置新配置解决方法 背景介绍 jupyter-server 最近发布了新的版本升级，随之，配置文件中的部分设置也有所改变。
旧配置 c.NotebookApp.ip = '*' 或'0.0.0.0' 所有绑定服务器所有网络接口。 c.NotebookApp.password = '' c.NotebookApp.open_browser = False c.NotebookApp.port = 8888 c.NotebookApp.allow_remote_access = True 新配置 c.ServerApp.ip = '0.0.0.0' c.ServerApp.password = '' c.ServerApp.open_browser = False c.ServerApp.port = 8888 c.ServerApp.allow_remote_access = True 简单看下来，就是 NotebookApp 被替换为了 ServerApp 。
但是生成密码的时候就出现了问题，
旧方法：
from notebook.auth import passwd passwd() Enter password: Verify password: Out[2]: 'sha1:...' 现在提示：
&gt;&gt;&gt; from notebook.auth import passwd Traceback (most recent call last): File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3901e1b804b811713b4d510f2db5f446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e86cb437a5d52764fd251994dceb181/" rel="bookmark">
			vue-baidu-map-3x 使用记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Vue3 + TypeScript 项目中，为了采用 标签组件 的方式，使用百度地图组件，冲浪发现了一个开源库 ovo，很方便！喜欢的朋友记得帮 原作者 点下 star ~
vue-baidu-map-3xbaidu-map的vue3/vue2版本（支持v2.0、v3.0和webGl api）我全都有。同时也是vue2-baidu-map的文档https://map.heifahaizei.com/doc/index.html
目录
快速上手
全局注册
局部注册
注意事项
错误示例
正确示例
输入框搜索点位，并定位至该点位
实现效果
引入地图组件
为什么不采用 BmAutoComplete？
使用 BmControl 实现自定义控件
定义响应式变量
关于初始化变量的踩坑
添加地图初始化方法 ready
监听外部组件传入地址的监变化
ready 方法逻辑 获取地址搜索结果列表
使用百度地图 API 检索跨域
获取搜索结果列表方法 执行定位
使用 nextTick 修改数据
点位弹窗信息
展示搜索点位的周边点位弹窗
实现效果
引入地图组件
辐射圆、海量点组件
控制弹框在地图范围内显示
接收弹框组件的周边点位数据，并显示
【一个我很迷惑的报错】多个页面引用地图组件时，路由报错
快速上手 全局注册 一次性引入 百度地图组件库 的所有组件
import { createApp } from 'vue' import App from './App.vue' import BaiduMap from 'vue-baidu-map-3x' const app = createApp(App); app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e86cb437a5d52764fd251994dceb181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c0ea466ac38597d2eb40cea1ec858c/" rel="bookmark">
			使用docker 生成镜像，并启动容器。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备好相应得jar包，并vim好dockerfile文件。 #定义基础镜像 FROM java:8 # 维护者信息 MAINTAINER xxxxxxxxx@qq.com #声明发布端口（没有发布） EXPOSE 9181 # 将jar包添加到容器 ADD springboot.jar app.jar # 定义容器启动执行的命令（CMD会被docker run 之后的命令替换掉） CMD java -jar app.jar 指令详情：
指令解析FROM指定基础镜像，必须为第一个命令MAINTAINER维护者邮箱等信息RUN构建镜像docker build时执行的命令ADD将本地文件添加到容器中,tar 类型文件会自动解压COPY功能类似ADD，但是是不会自动解压文件，也不能访问网络资源CMD在docker run时会执行的命令，如果存在多个则仅最后一个生效，例如一个镜像的dockerfile的结尾是“ CMD ["/bin/bash"] ”，那么进入容器可以使用docker exec -it imageName或docker exec -it imageName /bin/bash，后者是在“ CMD ["/bin/bash"] ”的指令下面多加了一个“ CMD ["/bin/bash"] ”，根据CMD的特性，存在多个时，只让最后一个CMD生效，因此不影响ENTRYPOINT可执行化LABEL用于为镜像添加元数据ENV设置环境变量EXPOSE指定于外界交互的端口VOLUME用于指定持久化目录WORKDIR工作目录ARG用于指定传递给构建运行时的变量ONBUILD用于设置镜像触发器 二、build 当前dockerfile文件 docker build -f dockerfile文件路径 -t 镜像名称:版本号 . 例：docker build -f dockerfile -t myfirstapp:1.0 . 三、查看镜像是否打成功 #查看镜像是否已存在。 docker images #查看镜像声明的端口 docker inspect -f {{"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87c0ea466ac38597d2eb40cea1ec858c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a7458930918e36adaf2a86ec21bc1b3/" rel="bookmark">
			Java基础知识点---面向对象 ---类---private（实例四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
面向对象 --类---private（实例四）
面向对象 --类---private（实例四） package oop.Demo04; //类 private public class Student { ​ //名字 private String name; //学号 private int id; //性别 private char sex; //学习（） //睡觉（） ​ //提供一些可以操作这个属性的方法 //提供一些public 的get 、set方法 ​ ​ //get 获得这个数据 public String getName(){ return this.name; } ​ ​ //set 给这个数据设置值 public void setName(String name){ this.name = name; ​ } } package oop.Demo04; /* 封装 1.提高程序的安全性，保护数据 2. 隐藏代码的实现细节 3. 统一接口 4.系统的维护增加 */ public class Application { public static void main(String[] args) { Student s1 = new Student(); ​ s1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a7458930918e36adaf2a86ec21bc1b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08fa4d39a57bc70e24320473c3117d4/" rel="bookmark">
			Java基础知识点---面向对象（实例三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
面向对象（实例三）
面向对象（实例三） package oop.Demo03; ​ public class Pet { public String name; public int age; ​ //无参构造 public void shout(){ System.out.println("叫了一声"); } } package oop.Demo03; ​ public class Application { ​ public static void main(String[] args) { ​ Pet dog = new Pet(); dog.name = "旺财"; dog.age = 3; dog.shout(); System.out.println(dog.name); System.out.println(dog.age); ​ ​ } } /* 运行结果 叫了一声 旺财 3 */ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98c9f779f87f300995ef34fbf58a3064/" rel="bookmark">
			微服务-nacos配置管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nacos配置管理 统一配置管理：一次配置更改并支持热更新。将核心配置存储到配置管理服务，当微服务启动时会自动读取配置管理服务中的配置信息并结合本地配置启动。当配置改动时，配置管理服务会自动通知微服务，微服务读取新配置并自动热更新，无需重新启动。
配置中心的思路是：
1、首先把项目中各种配置全部都放到一个集中的地方进行统一管理，并提供一套标准的接口。2、当各个服务需要获取配置的时候，就来配置中心的接口拉取自己的配置。
3、当配置中心中的各种参数有更新的时候，也能通知到各个服务实时的过来同步最新的信息，使之动态更新。
Hello配置管理
使用nacos作为配置中心，其实就是将nacos当做一个服务端，将各个微服务看成是客户端，将各个微服务的配置文件统一存放在nacos上，然后各个微服务从nacos上拉取配置即可。
对应的依赖为spring-cloud-starter-alibaba-nacos-config注意：启用配置中心后，需要配置文件写到bootstrap配置文件中。只能是bootstrap.yml或bootstrap.properties优先级等级为bootstrap.properties -&gt; bootstrap.yml -&gt; application.properties -&gt; application.yml
需要注意：SpringCloud默认将bootstrap移除了，需要手动添加bootstrap依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt; &lt;version&gt;3.1.5&lt;/version&gt;&lt;/dependency 消费者配置
spring.cloud.nacos.config.server-addr=localhost:8848 服务配置中心的配置spring.cloud.nacos.config.file-extension=yaml 配置使用的后缀名spring.cloud.nacos.config.prefix=nacos-consumer 配置DataId名称，默认就是服务名称spring.cloud.nacos.config.group=DEFAULT_GROUP 默认分组名称spring.profiles.active=dev 读取指定配置文件，配置参数dev开发环境、prod生产环境、test测试环境
配置设置的概念：
命名空间Namespace：不同的项目可以分为不同的命名空间。配置分组Group：根据项目的不同环境可以一个分组。配置集Data ID：服务不同环境的不同配置，就是一个配置集
使用nacos配置管理
DataID就是配置文件名称，不能冲突，采用【微服务名称-profile.yaml或properties】，如user-service-dev.yaml。默认DataId为spring.cloud.nacos.config.prefix，后面可以添加spring.profiles.active值，对应的文件后缀为spring.cloud.nacos.config.file-extension 分组采用默认即可。配置内容应该只有可能有热更新需求的配置信息，不是将所application.yml中内容全部拷贝。例如数据库地址一般不会频繁更新的，所以添加到配置管理中就不合适。这里适合一些开关类型或者模板类型的配置，pattern.dateformat=yyyy-MM-dd
微服务配置拉取 项目启动先读取nacos中的配置文件，然后读取本地配置文件application.yaml，合并后再创建spring容器，加载受管bean。项目中提供bootstrap.yml优先application.yml，这里配置nacos地址，从而实现nacos中配置信息的读取在控制器中读取配置信息进行验证
@Value("${pattern.dateformat}") private String dateFormat; @GetMapping("now")public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateFormat));} 配置热更新 可以在nacos控制台上手动编辑更新配置信息。事实上nacos中的配置文件变更后，微服务无需重启就可以感知。需要通过2种配置方式实现
方式1：在@Value注入的变量所在类上添加注解@RefreshScope
@Slf4j @RestController @RequestMapping("/user")@RefreshScopepublic class UserController { @Value("pattern.dateformat") private String dateFormat;} 在微服务日志中可以看到服务更新的自动通知
方式2：使用@ConfigurationProperties注解
@Component @Data@ConfigurationProperties(prefix="pattern")public class PatternProperties { private String dataformat;} 修改控制器类通过PatternProperties组件获取配置信息
@Autowiredprivate PatternProperties properties;@GetMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98c9f779f87f300995ef34fbf58a3064/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fb95745b58ff6b067e83d4ffc888f8f/" rel="bookmark">
			【Linux】Linux下git的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是git二、git发展史三、Gitee仓库的创建1.新建仓库2.复制仓库链接3.在命令行克隆仓库3.1仓库里的.gitignore是什么3.2仓库里的git是什么 三、git的基本使用1.将克隆仓库的新增文件添加到暂存区(本地仓库)2.将暂存区的文件添加到.git仓库中3.将.git仓库中的变化文件上传到远程仓库 四、其他git指令1.Linux上git安装2.查看仓库日志信息3.查看暂存区，仓库文件的变更状态4.对仓库文件重命名/删除5.从远端仓库拉取最新版文件 一、什么是git Git是一种分布式版本控制系统，用于跟踪代码的更改，以便多个人可以在同一代码库上协作开发。Git具有分布式的特性，允许多个开发者在本地开发并提交代码，而不需要连接到远程服务器。Git还提供了一些管理代码库的功能，例如分支、合并和回滚。它是开源的，由Linus Torvalds于2005年创建。Git已成为许多开源项目和商业软件开发的主要工具
我们以一个例子来对git进行更好的理解：
我们在大学时需要交很多实验报告，假如有一个人叫张三，他拿着他的实验报告去交给老师，他们老师十分的严格，一看张三做得很不好，就被打退回来重做，张三就在原来的基础上进行修改，然后又去交给老师，老师还是不满意，张三又继续修改，多次之后，老师说：张三啊，你这越改越差，你就把你第一次的实验报告交给我就可以了。张三这时蒙了，他上哪去找他第一份的实验报告。他的室友叫了张三的情况，所以被老师打退回来之后就留了一个心眼，他就把第一份的报告保存了一份，然后再进行修改，这样无论老师要哪一份，他手中都有，所以这个室友就说，你们有什么保存需要版本管理的就发给我，我帮你们保存，需要的时候找我拿即可，然后不断进行推广，用代码进行实现，自己一份，需要的人一份，这就是版本控制器，然后自建网站，此时已经不需要客户端，直接在浏览器上就可以操作，比如gitee和github
二、git发展史 雷纳斯-托瓦兹在将Linux源码开源之后，世界各地的顶级程序员或者黑客等等就向他提供他们编写的代码，所以雷纳斯-托瓦兹就一个人将他们的代码不断的扩充，合并代码，但是这样就十分的费力，然后他准备一家收费的版本控制器公司进行购买，但是顶级程序员觉得一款免费的软件使用的是一款付费的软件，这样就违背了开源的初衷，但是这家公司最后也乐意免费给他们使用，但是后面有一些好奇的程序员就打算破解这个版本控制器的源码，却被这家公司发现了，这家公司的老板就十分生气，就不允许他们使用了，这时雷纳斯-托瓦兹就十分的恼火，最终他经过2-3周的时间自己开发了一个版本控制器-git，并且也进行了开源。后来Git的开发者们一直在不断地改进它，使其更加稳定、高效和易用。
Git的发展史可以说是一个不断完善和发展的过程，它的成功得益于它的开源性、高效性和可扩展性。
三、Gitee仓库的创建 gitee链接：gitee
我们可以先点击上面链接注册，然后就可以进行下面的操作
1.新建仓库 2.复制仓库链接 3.在命令行克隆仓库 git clone https://gitee.com/call-me-xiao-hou/linux.git 注意这里我们需要输入我们注册gitee的账号和密码，至此我们的仓库就建立好了：
3.1仓库里的.gitignore是什么 我们进入仓库之后有如下的文件：
我们进入.gitignore文件之后发现有如下的内容：
我们发现里面保存的是文件的后缀，并且在这个文件内部的后缀，对应的文件，不会被上传到gitee上
3.2仓库里的git是什么 这个.git就是我们所说的仓库，本质就是一个目录，里面保存的是本地仓库的内容，push到远端仓库的本质就是将.git仓库里的内容同步到gitee上面(gitee也有类似.git的文件，我们看不到罢了)
三、git的基本使用 我以提交我下面的进度条的实现的代码为例：
1.将克隆仓库的新增文件添加到暂存区(本地仓库) git add . git add命令可以指定要添加的文件，只需在命令后面加上文件路径或文件名即可。例如，要添加名为"example.txt"的文件，可以使用以下命令：
git add example.txt 也可以指定一个目录来添加该目录下的所有文件，例如：
git add myfolder/ 这将添加 “myfolder” 目录中的所有文件
2.将暂存区的文件添加到.git仓库中 git commit -m '提交日志描述' 我们后面必须加上提交日志的信息，没有的话就会报错，这个信息不能够乱写，
3.将.git仓库中的变化文件上传到远程仓库 git push 这个时候我们需要输入gitee的名称和密码
然后我们在gitee上面进行刷新之后，我们的文件就传递上去了：
四、其他git指令 1.Linux上git安装 sudo yum -y install git 我们首次使用git会提示你完善邮箱和用户名：
我们按照指令提示一次完善即可。
注意：我们这里完善邮箱和姓名的目的是为了在公司的时候，我们提交的代码就一直存在，如果我们的代码出问题了，那么别人可以通过邮箱联系我们
2.查看仓库日志信息 git log 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fb95745b58ff6b067e83d4ffc888f8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b6f2fde99205316d8c08cac386ff321/" rel="bookmark">
			jdk1.8的安装和环境变量的配置最新版（超详细，保姆级教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、JDK的下载和安装
1.JDK的下载
（1）方式一：通过下面的链接地址直接下载jdk1.8版本
（2）方式二：通过Oracle官网进行下载
2.jdk的安装
二、环境变量的配置
1.通过jdk路径配置环境变量
2.通过JAVA_HOME配置环境变量
一、JDK的下载和安装 1.JDK的下载 jdk1.8又称jdk8.0，是目前相对比较稳定也是日常开发中用得最多的版本，但为什么不建议下载最新的jdk版本呢，那是因为最新版的jdk不稳定，在Java的学习中可能会出现各种各样的问题。jdk1.8完全能够满足大家学习和在工作中的使用。
我这边提供给大家两种安装jdk的渠道
（1）方式一：通过下面的链接地址直接下载jdk1.8版本 由于Sun公司已经被Oracle收购，所以想要下载jdk，就必须要去到Oracle的网址进行下载。如果没有账号的话是不能下载的，这样的话还要自己去注册一个账号，相对比较麻烦。下面我直接把安装jdk的可执行文件压缩放到下面地址，大家可以自取。
下载地址：https://download.csdn.net/download/m0_51520179/87926743
（2）方式二：通过Oracle官网进行下载 第二种方式相对麻烦一点，我们需要自己到甲骨文的官网去下载。
官网地址：Java Downloads | Oracle
这是下载jdk的一个界面.
但是最上面可能没有我们想要的jdk1.8的版本，我们把网页向下滑动。如下图，我们点击Windows然后下载第二个x64位的版本。如果没有Oracle的账号可能需要大家自己注册一个，登录了才能下载。这个我就不描述了，肯定难不了大家。
2.jdk的安装 下面我来带大家安装一下jdk,jdk的安装其实是非常简单的。大体就是下一步下一步，如果大家都会的话可以直接往下看环境变量的配置。
（1）我们把下载好的文件压缩后可以得到如下图所示的可执行文件，我们双击它，就能进行安装。
（2）下图是jdk的安装界面，我们点击下一步
（3）在这一步的时候，我们可能要修改一下jdk存放的位置,点击“更改"（这里也可以不更改，直接用默认路径，但一定要确保能找到jdk的存放路径。）在这一步大家一定要注意，不论是使用自己定义的路径还是默认路径都一定要确保自己能够找到jdk的安装路径。因为在配置环境变量的时候会用到。
下面是更改完的路径，我们继续点击下一步。
（4)这时程序会自动安装内容，如下图所示。
（5）第四步安装完成之后会自动跳出下面这个界面。其实这次安装的是单独的JRE。大家也可以自定义一个路径进行安装，修改完路径后我们继续点击下一步。
（6）这时程序会进入安装阶段，我们等待一会。完成后点击关闭，说明程序安装成功。
（7）安装完成后，我们可以查看一下安装是否成功。步骤如下
1.同时摁住windows+R键，输入cmd,进入命令行。如下图所示。
2.在命令行输入 java -version查看版本号(注意：输入java后要有一个空格)，如下图所示。这样就说明jdk安装成功了。
二、环境变量的配置 在上一小节，主要描述了如何安装jdk。但光安装一个jdk肯定是不够的，我们还需要自己配置一下环境变量，才能成功将程序运行。下面我给大家提供两种环境变量的配置方法
1.通过jdk路径配置环境变量 （1）右击”此电脑“，打开属性。如下图所示
（2）找到高级系统设置，并点击进去。（不同windows版本的高级系统设置的位置可能不一样，但一般会在显眼的位置，我的是windows 10的版本）
（3）点击高级系统设置之后，我们可以看到如下图的界面，点击环境变量。
（4）进入到环境变量以后，我们需要到path路径进行编辑。步骤如下
1.找到用户变量的path,然后点击编辑。
点击编辑后会有下面这个界面。
2.找到自己的jdk安装路径，并进入到bin目录下，复制路径。（注意，一定要进入jdk的bin目录下再复制路径）
然后在第四步打开的编辑环境变量里先点击”新建“，然后粘贴上刚刚复制的jdk路径，再点击确定。如下图所示。
（5）把先前打开的环境变量都点击确定（一定要点确定哈！！！）
这样，我们jdk就算配置成功了。
2.通过JAVA_HOME配置环境变量 通过JAVA_HOME配置环境变量相较于第一种方式更加便于我们对jdk的管理。如何找到环境变量和修改path路径，在第一种方式里已经讲得很清楚了。这里就不作过多阐述了。下面我们来看一下怎么通过JAVA_HOME来配置环境变量。
（1）新建一个用户变量，变量名为JAVA_HOME 变量的值为JDK的目录路径,如下图所示
（2）新建JAVA_HOME用户变量后，我们需要通过path路径来引入JAVA_HOME变量，
1.编辑path路径
2.引入JAVA_HOME变量（通过%JAVA_HOME%引入），并添加\bin来引入JDK目录下的bin目录，如下图所示。
到此，jdk环境变量配置成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf4d8f2a18126abb90b870f0f43120c7/" rel="bookmark">
			k8s存储卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、为什么要存储卷？二、emptyDir存储卷三、hostPath存储卷四、 nfs共享存储卷五、PVC 和 PV5.1 PV和PVC之间的相互作用遵循的生命周期5.2 PV 的状态5.3 一个PV从创建到销毁的具体流程 六、静态创建pv和pvc资源由pod运用过程6.1 在NFS主机上创建共享目录，并且进行exportfs发布6.2 在master主机编写pv资源创建yaml6.3 创建pvc资源，并且设置匹配绑定相应的pv6.4 挂载共享卷，并且进行共享目录写入测试6.5 K8S支持的存储卷的访问模式 七、StorageClass + nfs-client-provisioner搭建动态创建pv7.1 在NFS服务器配置nfs服务7.2 创建 Service Account，用来管理 NFS Provisioner 在 k8s 集群中运行的权限和动态规则7.3 创建 StorageClass，负责建立 PVC 并调用 NFS provisioner 进行预定的工作，并让 PV 与 PVC 建立关联7.4 挂载共享卷，并且进行共享目录写入测试 八、 总结 一、为什么要存储卷？ 容器磁盘上的文件的生命周期是短暂的，这就使得在容器中运行重要应用时会出现一些问题。首先，当容器崩溃时，kubelet 会重启它，但是容器中的文件将丢失——容器以干净的状态（镜像最初的状态）重新启动。其次，在Pod中同时运行多个容器时，这些容器之间通常需要共享文件。Kubernetes 中的Volume抽象就很好的解决了这些问题。Pod中的容器通过Pause容器共享Volume。
二、emptyDir存储卷 当Pod被分配给节点时，首先创建emptyDir卷，并且只要该Pod在该节点上运行，该卷就会存在。正如卷的名字所述，它最初是空的。Pod 中的容器可以读取和写入emptyDir卷中的相同文件，尽管该卷可以挂载到每个容器中的相同或不同路径上。当出于任何原因从节点中删除 Pod 时，emptyDir中的数据将被永久删除。
emptyDir可实现Pod中的容器之间共享目录数据，但是emptyDir卷不能持久化数据，会随着Pod生命周期结束而一起删除。
//创建一个模板文件 mkdir /opt/volumes cd /opt/volumes kubectl run myapp-demo --image=soscscs/myapp:v1 --port=80 --dry-run=client -o yaml &gt; myapp-demo.yaml vim myapp-demo.yaml apiVersion: v1 kind: Pod metadata: labels: run: myapp-demo name: myapp-demo spec: containers: - image: soscscs/myapp:v1 name: myapp-demo ports: - containerPort: 80 cp myapp-demo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf4d8f2a18126abb90b870f0f43120c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0ddcf980e0a49e81232f742c03283da/" rel="bookmark">
			为什么说Yii2.0比Laravel更快？底层原理是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Yii2.0比Laravel更快的原因主要有以下几点：
Yii2.0采用了更轻量级的框架结构和更高效的代码生成器，使得它的启动和运行速度更快。
Yii2.0使用的是更快的模板引擎和更高效的缓存机制，能够更快地渲染视图和提高应用程序的响应速度。
Yii2.0具有更好的自动加载机制，它采用了Composer自动加载器，能够更快地加载类文件。
Yii2.0使用了更好的数据库连接池和查询构建器，能够更快地访问和操作数据库。
总的来说，Yii2.0相对于Laravel具有更快的执行速度，这得益于其更高效的底层实现机制和优化措施。当然，具体的执行效率还取决于开发人员的实际实现方式和代码质量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee3f7e6dc82d34e04d970c3129a26ba/" rel="bookmark">
			NTC温度计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见电路 图1 温度检测电路
R_ntc为热敏电阻
3.3V 采用ADC的参考电压
分压电阻为10K
由电流相等得到
VRntc/Rntc = 3.3V/(R1+Rntc)
得到
3.3V/VRntc =(R1+Rntc)/Rntc
由AD采用就知道
采用12bit的ADC采样计算
4096/Vadc =(R1+Rntc)/Rntc
热敏电阻的温度与阻值关系 Rntc=R25*exp(B*(1/T1-1/T2))
Rntc是热敏电阻的温变阻值
R25 为温度为25°的电阻值 如图2
B是需要查电阻的规格书 如图2
T1为开尔文对应的摄氏温度275.15+电阻当前的温度
T2为开尔文温度273.15+25
图2 热敏电阻规格书截图
这样计算理论电阻我们可以采用execl得到
图3 计算电阻的公式
图4 计算ADC的公式
图5 采样ADC值计算温度公式
根据这些公式我们就能在程序中直接实现代码的编写
uint32_t lu32_Res = 0; int16_t l16_Tm = 0; float K = 273.15; float T1 =298.15; uint16_t B = 3380; uint16_t R1 = 10000; //分压电阻值 uint8_t i; lu32_Res = (uint32_t)((lu16_adc_value*10000)/(4096-lu16_adc_value)); l16_Tm =(int16_t)(1/(1/T1+log(lu32_Res/R1)/B)-K); 上述代码可以直接计算去NTC电阻的温度 注意规格书上的B值以及R25值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f251f99990b7fff6412745d2e0f85623/" rel="bookmark">
			Si5395/94/92时钟芯片配置步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Si5395/94/92芯片配置步骤 第一次写博客(学习笔记)，记录一次Si5394时钟芯片的配置，写这个教程的原因也是因为自己在网上搜资料的时候，用的人少之又少，让后面用到的人少走些弯路吧。 前3点为芯片的主要介绍，配置直接看第4点 1.时钟介绍
摘点datasheet的介绍吧，总之高端就完事儿了，可以实现超低相位抖动输出任何频率时钟。
12-Channel, Any-Frequency, Any-Output Jitter Attenuator/Clock Multiplier with Ultra-Low Jitter
The Si5395/94/92 Jitter attenuators combine fourth-generation DSPLL™ and MultiSynth™ technologies to deliver ultra-low jitter (69 fs) for high performance applications like 56G SerDes. They are used in applications that demand the highest level of integration and jitter performance. All PLL components are integrated on-chip,
eliminating the risk of noise coupling associated with discrete solutions.
2.时钟工作模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f251f99990b7fff6412745d2e0f85623/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c5e1242156fbca64ed48be0db87500e/" rel="bookmark">
			3.Cesium JS中的camera
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 setView setView方法用于设置相机的位置和朝向，但不会进行平滑过渡。相机会立即跳转到指定的位置。例如：
// Cesium相机系统 const position = Cesium.Cartesian3.fromDegrees(116.39,39.91,400) //setView 适用于快速切换视角 viewer.camera.setView({ destination: position, //相机目的地 orientation:{ //相机视口方向 heading: Cesium.Math.toRadians(0), // y 轴方向，0 正北 pitch: Cesium.Math.toRadians(-90), // x 轴方向， 俯仰角度 roll: 0 } }) flyto flyTo方法用于使相机飞行到指定位置和方向。你可以通过提供目标位置和视角，让相机平滑地飞行到指定的位置。例如：
viewer.camera.flyTo({ destination: position, orientation:{ //相机视口方向 heading: Cesium.Math.toRadians(0), // y 轴方向，0 正北 pitch: Cesium.Math.toRadians(-90), // x 轴方向， 俯仰角度 roll: 0 }, duration: 5 }) lookAt lookAt方法用于将相机的视线指向地球上的某个点。你可以指定目标点的经纬度和高度，相机会调整视角以看向该点。
var target = Cesium.Cartesian3.fromDegrees(longitude, latitude, height); viewer.camera.lookAt(target); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d22c1c08f429df055b44df281a23e64b/" rel="bookmark">
			2.cesium中的重要组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Viewer： Viewer是Cesium的主要入口点，它是地球可视化应用程序的容器。通过Viewer，你可以创建一个包含3D场景的交互式地球视图。Viewer负责创建和管理Scene、Camera、Canvas等组件，并提供了许多配置选项和交互方法，使你可以自定义和控制地球场景的行为。
Scene： Scene代表了3D场景，是Viewer中真正用于渲染和显示地球的部分。Scene包含了一个场景图，其中包括了所有的Entity和DataSourceCollection。它负责处理地球的渲染、光照、相机控制、事件处理等功能。
Entity： Entity表示地球上的实体，可以是点、线、面、模型等。通过Entity，你可以设置地理位置、样式、属性等信息，用于在地球上展示各种对象和特征。Entity通常通过DataSource添加到Scene中，从而在地球上可见。
DataSource 和 DataSourceCollection： DataSource是一种数据源，它包含了一组Entity，可以将这些实体添加到Scene中显示。DataSourceCollection是一个用于管理DataSource的集合。通过使用DataSourceCollection，你可以将不同类型的数据源组织在一起，比如地图图层、模型数据等。
Camera： Camera用于控制地球视图的相机，你可以通过Camera的方法和属性来调整视角、缩放、旋转等相机的行为。
Primitives： Primitives是Cesium的图元集合，用于绘制各种几何图形，如点、线、面等。你可以使用Primitives创建自定义的图形并添加到Scene中。
ImageryLayers： ImageryLayers是用于管理地图图层的集合。你可以通过ImageryLayers添加各种地图服务、卫星影像等底图图层。
TerrainProvider： TerrainProvider用于提供地形数据，以支持地球的高程模型。Cesium支持多种地形数据提供者，用于显示真实的地球表面。
Widgets： Cesium提供了一些内置的UI小部件，用于实现常见的交互功能，如时间轴、导航控制、全屏等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03b0d8b80e30dbe5785758a037f872b1/" rel="bookmark">
			docker端口映射详解（随机端口、指定IP端口、随意ip指定端口、指定ip随机端口）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
docker端口映射详解
一、端口映射概述：
二、案例实验：
1、-P选项，随机端口
2、使用-p可以指定要映射到的本地端口。
Local_Port:Container_Port，任意地址的指定端口
Local_IP:Local_Port:Container_Port 映射到指定地址的指定端口
Local_IP::Container_Port 映射到指定地址，但是宿主机端口是随机分配的
3、指定传输协议：TCP
docker端口映射详解 一、端口映射概述： 在Docker中容器默认是无法与外部通信的，需要在启动命令中加入对应的参数才允许容器与外界通信。
当Docker中运行一个Web服务时，需要把容器内的Web服务应用程序端口映射到本地宿主机的端口。这样，用户访问宿主机指定的端口的话，就相当于访问容器内部的Web服务端口。
二、案例实验： 1、-P选项，随机端口 使用-P选项时Docker会随机映射一个端口至容器内部的开放端口
[root@docker ~]# docker run -d -P --name nginx-test1 nginx
使用docker port可以查看端口映射情况
[root@docker ~]# docker port nginx-test1
访问测试:192.168.100.131:32768
[root@docker ~]# docker logs nginx-test1
查看映射的随机端口范围
[root@docker ~]#
cat /proc/sys/net/ipv4/ip_local_port_range
2、使用-p可以指定要映射到的本地端口。 Local_Port:Container_Port，任意地址的指定端口 端口映射参数中指定了宿主机的8000映射到容器内部的80端口，可以多次使用-p选项
[root@docker ~]# docker run -d -p 8000:80 --name nginx-test2 nginx
访问测试:192.168.100.131:8000
这种方式会映射到所有接口地址，所有访客都可以通过宿主机所有IP的端口来访问容器。
如下：查看宿主机当前的ip地址
访问测试:192.168.59.153:8000
Local_IP:Local_Port:Container_Port 映射到指定地址的指定端口 [root@docker ~]# docker run -d -p
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03b0d8b80e30dbe5785758a037f872b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c699e5470616cf6b7ad5e652ee84d60b/" rel="bookmark">
			vue中滚到页面最底部scrollTop不生效，解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要注意几点
&lt;template&gt; &lt;div ref="main" style="height:500px;overflow:auto;"&gt; &lt;div class="scrolldivmain" @click="scrollToBottom" style="height:3000px;width:80vw;background-color: aqua;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Thild6-to', mounted(){ let that=this this.$nextTick(()=&gt;{ let main=that.$refs.main main.scrollTop = main.scrollHeight }) }, } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 1.滚动的div必须是父级，2.父级需要设置overflow：auto和高度，3.子级高度比父级高度高
methods:{ scrollToBottom(){ let that=this this.$nextTick(()=&gt;{ let main=that.$refs.main main.scrollTop = main.scrollHeight }) } } 点击子页面后直接滚动到父级最底端
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cac1a28834d2c55e8362e73ff6f503a/" rel="bookmark">
			pycharm远程连服务器问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.配到部署好远程后，启动一直卡在初始化，无法启动。 解决：
（1） Connect to the remote device using ssh ssh &lt;user_name&gt;@&lt;device_ip&gt;
（2） Run the below commands (In my case, “.pycharm_helpers” folder was created in remote Linux device under “/home/root/” path)
cd /home/root/ cd ./.pycharm_helpers/ （用find找到： find / -name *pycharm_helpers*） rm -rf check_all_test_suite.py tar -xvzf helpers.tar.gz （3） Restart PyCharm and wait a little bit for the progress bar at bottom right to complete.
2. 报错信息：/usr/bin/python: error while loading shared libraries: libpython3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cac1a28834d2c55e8362e73ff6f503a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80b7caed25cd6ac1e28daaf2994ea479/" rel="bookmark">
			51单片机学习-AT24C02数据存储&amp;秒表（定时器扫描按键数码管）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先编写I2C模块，根据下面的原理图进行位声明：
sbit I2C_SCL = P2^1; sbit I2C_SDA = P2^0; 再根据下面的时序结构图编写函数：
/** * @brief I2C开始 * @param 无 * @retval 无 */ void I2C_Start(void) { I2C_SDA = 1; I2C_SCL = 1; I2C_SDA = 0; I2C_SCL = 0; } /** * @brief I2C停止 * @param 无 * @retval 无 */ void I2C_Stop(void) { I2C_SDA = 0; I2C_SCL = 1; I2C_SDA = 1; } /** * @brief I2C发送一个字节 * @param 要发送的字节 * @retval 无 */ void I2C_SendByte(unsigned char Byte) { unsigned char i; for(i = 0; i &lt; 8; i ++) { I2C_SDA = Byte &amp; (0x80 &gt;&gt; i); //由高位到低位依次取出写入 I2C_SCL = 1; I2C_SCL = 0; } } /** * @brief I2C接受一个字节 * @param 无 * @retval 接收到的字节 */ unsigned char I2C_ReceiveByte(void) { unsigned char i, Byte = 0x00; I2C_SDA = 1; for(i = 0; i &lt; 8; i ++) { I2C_SCL = 1; if(I2C_SDA) {Byte |= (0x80 &gt;&gt; i);} //由高位到低位把读到的 取出 I2C_SCL = 0; } return Byte; } /** * @brief I2C发送应答 * @param 应答位，0为应答，1为非应答 * @retval 无 */ void I2C_SendAck(unsigned char AckBit) { I2C_SDA = AckBit; I2C_SCL = 1; I2C_SCL = 0; } /** * @brief I2C接收应答 * @param 无 * @retval 接收到的应答位，0为应答，1为非应答 */ unsigned char I2C_ReceiveAck(void) { unsigned char AckBit; I2C_SDA = 1; I2C_SCL = 1; AckBit = I2C_SDA; I2C_SCL = 0; return AckBit; } 接下来利用写好的I2C模块，创建AT24C02模块来凑成数据帧：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80b7caed25cd6ac1e28daaf2994ea479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89de5ad13e6d0ed9ef4cee85d579cc22/" rel="bookmark">
			20230804做了一个梦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先梦是毫无逻辑的。
今天梦到我大学暑假期间，还要去以一个为期15天的培训活动，在海边一个别墅，我极其不理解，为何还要参加，不参加和大学毕业有何关系。最后呗严重警告，入住后发现吃人事件，怀疑对象为同一宿舍的针女，我时常和隔壁栋的一个人联系，具体梦里细节已经模糊，结果到最后一天，发现隔壁那个人才是吃人怪物，最后我要死的一瞬间回到了开头第一天，就像雨宫莲回到第一天一样。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38acfb1215ee14f14fa7795993af9e97/" rel="bookmark">
			STM32的入门——CM3芯片STM32F103VET6的使用和相关外设
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据《STM32库开发实战指南——基于野火指南者开发板》整理，
https://gitee.com/Embedfire-stm32f103-zhinanzhe/ebf_stm32f103_zhinanzhe_
std_tutorial
在整理的过程中，还参考了其他的一些STM32资料
使用了“幕布”这款软件，添加了一些思维导图
整理框架目的：
1.梳理知识脉络
2.复习知识
CM3芯片STM32F103VET6的使用和相关外设——目录 命名STM32F10xx 系统框图总线被动单元的地址划分 CMSIS标准ST标准库（STD库）ST标准库（STD库）中的启动文件ST标准库（STD库）中的stm32f10x.hST标准库（STD库）中的启动文件startup_stm32f10x_hd.sST标准库（STD库）中的core_cm3.h MDK编译过程域及堆栈空间编译工具链MDK工程的文件类型 按键按键消抖-&gt;软件消抖按键消抖-&gt;硬件消抖 位带时钟系统时钟树RCC 中断系统中断向量表中断向量表偏移NVIC(内嵌向量中断控制器)SysTick(系统定时器) 中断服务函数中断优先级中断服务函数EXTI(外部中断/事件控制器)EXTI(外部中断/事件控制器)功能框图 GPIO电流、电压（电气属性）相关术语GPIO结构框图GPIO输出模式GPIO输入模式 通讯通讯分类、常用概念RS-232物理层协议层 I2C物理层协议层STM32的I2C外设 SPI物理层协议层STM32的SPI外设 CAN物理层 协议层RS485物理层协议层 USART（通用同步异步收发器）、UARTUSART结构框图 DMA(直接存储器存取)从哪里来到哪里去要传多少，单位是什么什么时候传输完成：DMA请求、通道、仲裁器 存储器RAMDRAMSDRAMDDR SDRAM (Double Data Rate SDRAM) SRAM扩展外部SRAMROMMASK(掩膜) ROMOTPROM(One Time Programable ROM)EPROM(Erasable Programmable ROM)EEPROM(Electrically Erasable Programmable ROM)EEPROM——AT24C02原理图和手册分析**FALSH(闪存)外部Nor FALSH（SPI Flash）——W25Q64手册分析内部FLASH SD卡 SDIOSTM32的SDIO主机 文件系统FatFs STM32的启动方式：在SRAM中调试代码 FSMC显示器电阻触摸液晶屏RGB接口(RGB Interface)一种分辨率为320*240的3.2寸电阻触摸液晶屏 编码、字模编码字模 ADCADC采集数据转换时间采样后 DACTIM—基本定时器TIM—高级定时器输入捕获PWM输入模式 断路功能、死区时间输出比较 IWDG独立看门狗窗口看门狗WWDGRTCUNIX 时间戳 STM32的电源管理电源管理器、可编程电压检测器STM32的电源系统STM32的功耗模式 总结 命名 STM32F10xx 系统框图 总线 被动单元的地址划分 CMSIS标准 ST标准库（STD库） ST标准库（STD库）中的启动文件 上图是汇编指令及对应作用
启动文件由汇编编写，是系统上电复位后第一个执行的程序。主要做了以下工作：
初始化堆栈指针SP=_initial_sp
初始化PC 指针=Reset_Handler
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38acfb1215ee14f14fa7795993af9e97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5d74baa42c959aeb9038a0f9274b10c/" rel="bookmark">
			ChatGPT 助力开发人员改进代码的5个方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来，在软件开发中使用人工智能和机器学习变得越来越普遍。因此，开发人员开始转向像 OpenAI 的 ChatGPT 这样的工具来简化他们的工作，提高他们的工作效率。ChatGPT是一个由 OpenAI训练的大型语言模型，本文将向您展示如何使用 ChatGPT 帮助开发人员完成从编码到文档和测试等各种任务。
简单了解 ChatGPT ChatGPT 是 OpenAI 开发的一种重要语言模型，已被证明是现代软件开发中的宝贵工具。这是一个人工智能 (AI) 系统，使用自然语言处理 (NLP) 和机器学习 (ML) 算法来理解人类语言并生成响应。
ChatGPT 已经在各种来源的海量文本数据上进行了训练，使其能够生成高质量的文本，通常与人类书写的内容难以区分。这种能力使 ChatGPT 在多个领域成为开发人员的宝贵工具，包括代码片段文本生成、自动错误修复、技术支持聊天机器人和文档生成。
开发人员如何使用 ChatGPT 作为一个功能强大的语言模型，开发人员已经使用 ChatGPT 构建了各行各业的创新应用。这些应用的范围从聊天机器人和语言翻译工具到内容创建和客户支持解决方案。
在本节中，我们将重点介绍开发者使用 ChatGPT 的五个例子，并探讨他们利用该模型的功能解决复杂问题和改善用户体验的独特方式。这些例子展示了 ChatGPT 作为构建智能应用的工具的多功能性和潜力，它可以颠覆我们与技术的交互方式。
代码片段的文本生成 生成代码片段对于开发人员来说是一项关键任务，ChatGPT 可以帮助开发者们更高效地完成这项工作。通过输入所需的功能，ChatGPT 可以生成能够轻松集成到开发人员项目中的代码片段。
ChatGPT 通过自动化基于自然语言描述生成代码片段的过程，显著提高软件开发的效率、生产力和质量。
在上图中，ChatGPT 被提示构建一个待办事项应用程序，并且它使用确切的 Javascript 框架（React）来完成此操作。这种级别的智能工具有多种优势，具体为：
节省时间：ChatGPT 可以自动生成代码片段，节省开发人员的时间和精力。
提高代码质量：可以帮助减少代码生成中的错误，提高整体代码质量。
学习速度更快：ChatGPT 为开发人员提供他们可能没有想到的代码片段建议，使他们能够探索问题的不同解决方案，更快地学习。
降低认知负荷：通过自动生成代码片段，ChatGPT 可以减轻开发人员的认知负担，让他们能够专注于更重要的任务。
代码标准化：ChatGPT 可以帮助实现代码片段的标准化，确保代码在整个项目或企业中的一致性。
编程语言转换 ChatGPT 是一个基于人工智能的语言模型，可以理解和解释多种编程语言。这也意味着它不局限于特定的编程语言，可以从一种语言无缝过渡到另一种语言。
例如，让我们思考一个使用 JavaScript 构建的简单 Todo 应用程序的场景。在这种情况下，如果您想切换到 React（一种用于构建用户界面的流行 JavaScript 库），通常需要使用 React语法重写整个应用程序。然而，ChatGPT 可以简化这一过程，您可以轻松地过渡到 React，而无需编写任何代码。
这是因为 ChatGPT 经过了大量编程语言语法库的训练，能够理解应用程序的底层逻辑。因此，它可以将现有的 JavaScript 代码翻译成 React 语法，从而促进平稳过渡。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5d74baa42c959aeb9038a0f9274b10c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03ea69d694d938b0cb38d349e39b1930/" rel="bookmark">
			org.aspectj.apache.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 18
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能原因： aspectjweaver.jar 包版本太低了，可升级到1.8.9
本人出现的问题：
项目在本地window启动没问题，本地虚拟机centos7上也没问题，到线上centos7部署就报错误.
后面发现 com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar 与 aspectjweaver-1.8.9.jar 包重复了，去掉第一个包即可。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/106/">«</a>
	<span class="pagination__item pagination__item--current">107/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/108/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>