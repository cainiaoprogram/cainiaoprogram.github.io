<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f58a7ce0f2be33a7aa252ad85740eac/" rel="bookmark">
			干货 | Python思维导图.pdf资料，免费领取！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 python语言是一个面向对象的编程语言，学习的难度比较小。Python学习比较的简单，发展非常的好，比较的好找工作 ，而且相对发展也要比其他的编程语言少很多。
如果想要学习Python，Python学习的思维导图是必不可少，可以帮助你更快的了解Python这门语言和理清思路，文末可以免费领取
一、为什么需要思维导图 1、了解学科体系： 思维导图是一种结构化的图形工具，可以帮助我们整理和组织复杂的思维内容。通过将主题、子主题和关键点以图形化的方式表示，我们可以更清晰地把握思维的结构和逻辑关系。
2、建立学科逻辑： 通过思维导图，我们可以更自由地展开思维，进行联想和推理。思维导图能够激发我们的创造性思维，帮助我们产生新的想法、解决问题和发现关联性。
3、强化记忆和理解： 思维导图在视觉上提供了一个整体的概览，通过将信息以图形和图像的形式展示，帮助我们更好地记忆和理解。与纯文字相比，思维导图可以激活我们的大脑视觉和空间认知，提高信息的吸收和记忆效果。
二、思维导图的作用 1、结构清晰： 思维导图以树状结构或网络结构呈现信息，使复杂的思维内容更加清晰可见。通过将主题、子主题和关联点以图形化方式展示，帮助我们整理和组织思维。
2、激发创造力： 思维导图可以帮助我们发现不同元素之间的关联和相互作用，激发创新和创造力。通过将不同领域的概念和想法进行连接，我们可以产生新的创意和解决问题的方法。
3、提高效率： 思维导图可以帮助我们更有条理地进行工作和决策，提高效率。通过将复杂的任务或计划拆解成具体的步骤和关联，我们可以更好地管理时间和资源。
-END-
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
一、Python学习路线 二、Python基础学习 1. 开发工具 给大家准备考Python开发过程中需要用到的必备工具，包括最新版PyCharm安装永久激活工具。
2. 学习笔记 3. 学习视频 三、Python小白必备手册 四、Python实战案例 五、Python爬虫秘笈 六、数据分析全套资源 七、Python面试集锦 1. 简历模板 资料领取 上述这份完整版的Python全套学习资料已经上传CSDN官方，朋友们如果需要可以微信扫描下方CSDN官方认证二维码输入“领取资料” 即可领取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f48930205d9feb2be15e733ec61abb8/" rel="bookmark">
			How can I be sure that I am pulling a trusted image from docker?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Error response from daemon: manifest for jenkins:latest not found: manifest unknown: manifest unknown 2、Error response from daemon: pull access denied for nacos, repository does not exist or may require ‘docker login’: denied: requested access to the resource is denied 由于名字没有匹配到，需要拉取正确的镜像名称
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c341c4b0193714bf4b4702d734039d96/" rel="bookmark">
			C&#43;&#43;内容补充--面向对象篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类和对象 类中静态成员不占用类的大小 也就不占用类的对象的大小 只有一个类壳子的时候 类和对象的大小都是1
当类中只有一个int数据的时候
类和对象的大小都是4
当类中有int数据以及一个静态变量的时候
类和对象的大小还是4
变量存储类以及对象的存储类 所有的局部变量默认存储类是auto类
对象的存储类跟变量一致 因为对象也是一个变量 是自定义类的变量
存储类为外部和静态的数组其元素具有默认值。
文件操作 键盘输入 数据流 中心思想：键盘输入的东西 可以可以看做一个文件 称为“键盘输入文件”
首先我们要明确 从键盘上输入数据是带缓冲区的，只有输入完数据，并且在数据输入完之后按回车，就会形成输入流，也就是完成了文件到输入流的转化，就可以向程序中输入数据了（注意 如果数据没有输入完 也就是还有变量没对应数据 那么这时的回车是被当做空格符的）
键盘设备的输入流对象系统规定为cin，所以cin是一个系统默认键盘输入流对象，而ifstream ifs 是一个文件输入流对象，与cin的区别是cin是键盘文件的输入流对象 ，ifs是某个内存文件的输入流对象
cin&gt;&gt; 首先将输入输入到缓冲区 形成键盘文件 敲下回车之后 形成输入流 那么cin&gt;&gt;就可以从输入流中获取数据赋值给后面的变量
如果提取失败 那么cin的值就是0
cin&gt;&gt;x 表达式的值也是0 所以可以将其作为条件判断接下来是否还有键盘输入（常用于算法程序 判断还会不会给程序塞数据，因为算法程序的测试用例，就可以看成一个已经形成好的键盘文件，并且形成了输入流，拿着这个输入流塞给程序）
get() 因为cin是默认键盘输入对象 所以要用cin调用get函数 返回所获取的字符 文件结束时返回EOF
输入数据 按下回车键之后 形成输入流 之后交给get函数处理 get函数将字符一个一个读入程序，当读完时，意味着文件结束（这里的文件是键盘输入文件），那么get就会读到EOF（也就是-1）所以可以使用该条件来判断读入是否结束
geiline() 返回值是void 参数是存放的字符数组的数组名或地址，最大读取字符个数限制n 一般为字符数组的大小 ，因为每次都是往那个字符数组中存放
上图中 每次回车都是一个输入流 那么他的程序结束是用ctrl+z来表示接下来没有输入了，使得程序结束
（ps：对于算法题来说 不用ctrl+z 因为是系统强制输入数据 算法测试用例已经是一个键盘文件的输入流 所以直接将该输入流通过getline解析，之后判断目标字符数组str中的字符个数是否为0 就能告诉程序测试用例输入了几行）
getline()用法
getline是C++标准库函数；它有两种形式，一种是头文件&lt; istream &gt;中输入流成员函数；一种在头文件&lt; string &gt;中普通函数；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c341c4b0193714bf4b4702d734039d96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/798f8a92644ae1fe83d29868d8f8f7c5/" rel="bookmark">
			C&#43;&#43;补充内容--EasyX-UI界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		esay x 其他 地图打印(利用二维数组) 双缓冲 当我们绘制一张图 然后另一张图盖住前一张图的某个部分的时候 由于while的存在 会导致 两张图不停的闪烁 所以加入双缓冲可以解决这个问题
开启双缓冲 之后等待Flush或者End 才会进行图片的绘制 不然不会进行图片的绘制,这样就可以保证每次while的执行 都是以一整套为单位进行的 执行到双缓冲状态结束或者flush 才将之前的内容同时绘制 也就是蓝色和白色同时绘制(这样虽然每次都在循环绘制 但是每一次绘制的效果一样 就不会出现闪烁) 而不是蓝色先绘制 之后白色再绘制
有以下两种方式
注意::
如果开启双缓冲状态之后 中途进行了函数的跳转 那么函数里要将双缓冲状态结束 不然一直没有结束双缓冲状态的话 函数里的绘图也不会进行绘制 而是等待双缓冲状态的结束
颜色和格式的设置 设置颜色和格式都是设置了一种状态 在这之后的填充都会采用这种状态 所以设置状态要在真正填充之前 所以每次填充之前最好都设置一次状态
键盘的输入 _kbhit() 以及_getch()都是控制台函数 会导致操作与界面割裂开 所以建议使用Get这个函数 该函数直接传入一个大写w即可包含小写w,因为他的参数是虚拟键
补充:VC虚拟值表 可放入GetAsyncKeyState的参数
https://blog.csdn.net/qq_42372031/article/details/105178789
界面的设计 按钮和鼠标 按钮 设置文本所占矩形的位置坐标 对于横轴 先将文本矩形的左边像素坐标移动到按钮的中间 之后 减去文本矩形像素的一半 就可以实现左边一半右边一半 就可以对齐了
纵轴同理
鼠标 先对鼠标的状态进行设置,采用枚举类型
同时定义全局变量 Message msg; 或者 ExMessage msg;
定义鼠标状态函数 获取在某一时刻 各个按钮内的鼠标状态
之后 获取到鼠标的位置 是否在按钮中间 并对鼠标是否点击进行判断 并返回枚举变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/798f8a92644ae1fe83d29868d8f8f7c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da458cf7e5f88d3a5ef79a9bb23fddeb/" rel="bookmark">
			Java、Javascript、Javaweb三者的区别及说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言首先说一下java 与 javaweb之间的关系再者，说一下Java与Javascript之间的关系一、什么是Javascript二、什么是Java三、Javascript名字的由来四、Java与Javascript的区别 总结 关于Python技术储备一、Python学习路线二、Python基础学习1. 开发工具2. 学习笔记3. 学习视频 三、Python小白必备手册四、Python实战案例五、Python爬虫秘笈六、数据分析全套资源七、Python面试集锦2. 简历模板 资料领取 前言 首先说一下java 与 javaweb之间的关系 我们平常说的Java一般指Java SE，也就是Java Standard Edition，Java的标准版，一般用来开发桌面应用程序，但是在开发桌面应用程序上相对VB，Delphi，VC++并没有什么优势。
JavaWeb则到了Java EE领域了，也就是Java Enterprise Edition，Java的企业版，看那个web就应该想到是与Internet有关的，其实开发JavaWeb应用程序，初级的一般是用JSP（Java Server Pages）+servlet+Javabean来开发的，对大型的网站一般是使用框架来开发的，例如struts，hibernate，spring，例如校内，你在登陆的时候会在地址栏看见Login.do，登陆以后会看见Home.do这样的请求，典型的struts框架结构。
Java还有一个版本是JavaME,Java Micro Edition,Java的微型版，诺基亚手机上运行的Java程序就是指用这个版本开发的程序。
再者，说一下Java与Javascript之间的关系 一、什么是Javascript 它是运行在浏览器中的一种脚本语言，在web页面中，Javascript可谓是无所不能：
可以操作HTML，提供了一种运行时改变HTML的工具;
可以附加并执行事件，符合面向事件编程的思想;
数据验证功能，在提交表单时对表单数据进行合法性验证;
对客户浏览器的操作，前进、后退、刷新、跳转、打开新窗口、打印等;
可以创建并使用Cookies.
二、什么是Java Java是Sun公司推出的一种编程语言。它是一种通过解释方式来执行的语言，语法规则和C++类似。同时，Java也是一种跨平台的程序设计语言。
用Java语言编写的程序叫做“Applet”(小应用程序)，用编译器将它编译成类文件后，将它存在WWW页面中，并在HTML档上作好相应标记，用户端只要装上Java的客户软件就可以在网上直接运行“Applet”。
Java非常适合于企业网络和Internet环境，现在已成为Internet中最受欢迎、最有影响的编程语言之一。
Java有许多值得称道的优点，如简单、面向对象、分布式、解释性、可靠、安全、结构中立性、可移植性、高性能、多线程、动态性等。
Java摒弃了C++中各种弊大于利的功能和许多很少用到的功能。
Jave可以运行于任何微处理器，用Java开发的程序可以在网络上传输，并运行于任何客户机上。
三、Javascript名字的由来 JavaScript最早是被称为Mocha（魔卡）的，这是这个项目的代码名。
这个名字一直用到Netscape2.0 beta 2发布之前（95.11.04）——包括在beta 1中弹出的错误框上，还可以看到Mocha的名字。不过，早在此前的9月18号，netscape就已经发布消息将在LiveWire中启用一种服务器端脚本（未提及名称）。又因为我们前面提到的“前后端通用脚本”的设计，该语言在beta 2发布时就使用了内部名称LiveScript。
但同样混乱的事情是，事实上这时Netscape已经决定将该语言命名为“JavaScript”。
因此在beta 2的发布备忘中该语言称为JavaScript，而界面上却从Mocha改为了LiveScript。
这一局面一直持续到12月4日，netscape与sun共同发布声明，正式启用了JavaScript这个名字。随后beta 4发布(95.12.20)，界面和文档上就统一了。
所以事实上“LiveScript”这个名字可以考证的生命周期，也就只有一个月的时间（在95.11.04- 12.04）。但Mocha毕竟只是项目代码名，而非产品名，所以后来人们追溯JavaScript的历史，大多只提到LiveScript为止。
四、Java与Javascript的区别 1、javascript与Java是由不同的公司开发的不同产品。javascript是Netscape公司的产品，其目的是为了扩展Netscape Navigator功能,而开发的一种可以嵌入Web页面中的基于对象和事件驱动的解释性语言；而Java是SUN Microsystems公司推出的新一代面向对象的程序设计语言，特别适合于Internet应用程序开发。实际上，javascript最初的名字并不是javascript，而是LiveScript，名字中的“Java”是经过SUN Microsystems公司授权的。
2、javascript是_基于_对象的，它是一种脚本语言，是一种基于对象和事件驱动的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。而Java是_面向_对象的，即Java是一种真正的面向对象的语言，即使是开发简单的程序也必须设计对象。
3、javascript与Java嵌入方式不一样。在HTML文档中，两种编程语言的标识不同，javascript使用来标识，而Java使用Applet来标识。
4、javascript与Java在浏览器中所执行的方式不一样。javascript是一种解释性编程语言，其源代码在发往客户端执行之前不需经过编译，而是将文本格式的字符代码发送给客户，即javascript语句本身随Web页面一起下载下来，由浏览器解释执行。而Java的源代码在传递到客户端执行之前，必须经过编译，因而客户端上必须具有相应平台上的仿真器或解释器，它可以通过编译器或解释器实现独立于某个特定的平台编译代码。
5、javascript与Java代码格式不一样。javascript的代码是一种谋咀址格式，可以直接嵌入HTML文档中，并且可动态装载，编写HTML文档就像编辑文本文件一样方便，其独立文件的格式为X.js。java是一种与HTML无关的格式，必须通过像HTML中引用外媒体那么进行装载，其代码以字节代码的形式保存在独立的文档中，其独立文件的格式为X.class。
6、javascript与Java所采取的变量是不一样的。javascript中的变量声明采用弱类型，即变量在使用前不需作声明，而是解释器在运行时检查其数据类型。Java采用强类型变量检查，即所有变量在编译之前必须作声明。
7、javascript采用动态联编，即javascript的对象引用在运行时进行检查。Java采用静态联编，即Java的对象引用必须在编译时的进行，以使编译器能够实现强类型检查。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da458cf7e5f88d3a5ef79a9bb23fddeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f507c4c8f4664f3c2d37b286ebad4b/" rel="bookmark">
			如何使用python实现自动化办公？全网最全干货来了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1、普通文件自动化管理1.1 文件的复制1.2 文件内容的复制1.3 文件的裁剪1.4 文件的删除1.5 文件的压缩与解压缩1.6 文件的查找1.7 查找含有指定内容的文件1.8 清理重复的文件1.9 批量修改目录中的文件名称 2、文件夹的自动化管理2.1 文件夹的复制2.2 文件的删除2.3 文件夹的裁剪 3、Word自动化 – 高效做文档3.1 读取Word文档3.2 小练习：简历筛选3.3 生成word 文档3.3 .1 标题3.3 .2 段落3.3 .3 图片3.3 .4 表格3.3 .5 分页 3.4设置 word 文档样式3.4.1 全局样式3.4.2 文本样式3.4.3 图片样式3.4.4 表格样式 3.5 WORD 转 PDF3.5.1 网址 转 PDF3.5.2 HTML字符串 转PDF3.5.1 WORD 转 PDF 4、Excel 自动化4.1 获取Excel 对象4.1.1 获取工作簿4.1.2 读取工作簿内容 4.2 写入Excel 数据4.2.1 常用函数4.2.2 代码书写 4.3 Excel 写入图表4.3.1 常用函数4.3.2 图表样式4.3.3 代码书写 5、 PPT 自动化5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2f507c4c8f4664f3c2d37b286ebad4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5edebda1ef43e1544e82d73477b83c5c/" rel="bookmark">
			更便捷的访问共享盘方式 pyfilesystem
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class SMB: info_dict = { "host": '1.66.12.1', "username": "H7", 'passwd': password, 'port': 445, 'direct_tcp': True, } class MySMB: def __init__(self, smb_dict): self.smb_dict = smb_dict def __enter__(self): self.smb_fs = fs.smbfs.SMBFS(**self.smb_dict) return self def __exit__(self, exc_type, exc_val, exc_tb): self.smb_fs.close() return True def do_something(self): print(self.smb_fs.listdir(r"/xt")[:19]) def download(self, smb_path, local_dir): os.makedirs(local_dir, exist_ok=True) filename = os.path.basename(smb_path) local_path = os.path.join(local_dir, filename) with open(local_path, 'wb') as f: self.smb_fs.download(smb_path, f) print('download remote file success', smb_path) return local_path def upload(self, local_path, smb_path): print('smb_path', smb_path,os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5edebda1ef43e1544e82d73477b83c5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6000f3eb95aafd199300ea6500656e09/" rel="bookmark">
			GoLang vs Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python和Go是两种非常不同的编程语言，它们在设计哲学、用途和特性方面有各自的优势和局限性。以下是它们的一些主要区别：
设计哲学: Python: 设计简洁明了，强调代码的可读性和简洁性。Python遵循"只有一种方式来做一件事"的原则。Go (又名Golang): 由Google开发，旨在提高程序的效率、可读性和简洁性。Go是为了解决多核心处理器、网络系统和大型代码库中的问题而设计的。 性能: Python: 通常执行速度较慢，因为它是一种解释型语言。Python的动态类型使其灵活但牺牲了一些性能。Go: 编译型语言，运行速度通常比Python快。Go的静态类型和编译时优化使其在性能上更有优势。 类型系统: Python: 动态类型语言。这意味着变量在运行时才知道其类型。Go: 静态类型语言。在编译时就必须确定所有变量的类型。 并发处理: Python: 通过线程和协程支持并发，但由于全局解释器锁（GIL）的存在，真正的并行执行在多线程中受到限制。Go: 提供了更原生的并发支持，通过goroutines（轻量级线程）和通道（Channels）来实现。Go的并发模型是其核心特性之一。 用途: Python: 广泛应用于数据科学、机器学习、Web开发、自动化脚本、科学计算等领域。Go: 常用于系统编程、云计算（特别是容器化技术如Docker）、微服务架构、网络服务器等。 社区和生态系统: Python: 拥有庞大的社区和丰富的第三方库，尤其是在数据科学和机器学习领域。Go: 社区相对较小，但在云计算和网络服务方面有着强大的库和工具。 学习曲线: Python: 通常认为是初学者友好的，入门较容易。Go: 语法简洁，但对于没有编程经验的人来说，学习曲线可能略高于Python。 总的来说，Python因其易用性和广泛的应用场景而受欢迎，而Go则因其高效的性能和并发处理能力而在系统编程和网络服务领域中占有一席之地。选择哪种语言取决于具体的项目需求和个人偏好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fbdf216783961a72060a84a5744ce39/" rel="bookmark">
			职场生存及升职法则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 获得更多同事支持（拉拢） 1. 获得更多同事支持（拉拢） 一般有三种方法可以打造
制造共同的敌人
懂权术的人，都懂得利用外部矛盾来增加团队的凝聚力，羊群内耗的最优解决办法，就是狼来了，大家都逃命，也就顾不上内耗了。这个不仅仅适用于职场，日常生活中也是如此。
如果没有敌人，就制造一个假想敌出来。
如果没有外在的胁迫手段，就只能给好处。
给好处
常用方法就是，把别人给员工的好处，说成自己给员工的好处，靠自己才为大家赢得了好处，是自己的功劳。
举个例子，领导表扬了要拉拢的对象，你提前通风报信，把这个表扬说成是自己推荐的结果。或者，先给他制造难题，然后再拉他出坑，让他感恩戴德。
袁世凯选拔人才就是如此。
养感情
建立情感连接。平平淡淡，没有好处也没有敌人，这时候就需要高举感情大旗，毕竟大部分人都不懂权术，不是赤裸裸的利益动物，大家还是讲温情的。那么我们只需要等待一个合适的机会，每个人都有脆弱的时候，关键时候借花献佛。或者雪中送炭，再或者自虐表态。
比如历史上，刘备常用这招儿。比如三顾茅庐感动诸葛亮，摔孩子来赢取赵云的忠心。这些都是通过自虐来完成情感连接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878675aff9a4153704b061d1d53da741/" rel="bookmark">
			C语言整型详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 整数类型简介 1.1 类型说明 C语言定义了几种整数类型：短整型（short）、整型（int）、长整型（long）、更长的整型（long long）。这些类型可以被 signed 和 unsigned 修饰。
signed 修饰：带符号位，有正负号，可以表示负值。（默认情况）unsigned 修饰：不带符号位，没有正负号，只能表示零和正整数。 计算机中的最小存储单位是 bit（位），1字节（byte）= 8位（bit）。
类型修饰符占用空间取值范围short [int]signed2字节(=16位)-32768 ~ 32767 (- 2 15 2^{15} 215 ~ 2 15 2^{15} 215-1)short [int]unsigned2字节(=16位)0 ~ 65535 (0 ~ 2 16 2^{16} 216-1)intsigned通常4字节-2147483648 ~ 2147483647 (- 2 31 2^{31} 231 ~ 2 31 2^{31} 231-1)intunsigned通常4字节0 ~ 4294967295 (0 ~ 2 32 2^{32} 232-1)long [int]signed4字节或8字节4字节时：-2147483648 ~ 2147483647 (- 2 31 2^{31} 231 ~ 2 31 2^{31} 231-1)long [int]unsigned4字节或8字节4字节时：-0 ~ 4294967295 (0 ~ 2 32 2^{32} 232-1)long longsigned8字节(=64位)-9223372036854775808~ 9223372036854775807(- 2 63 2^{63} 263 ~ 2 63 2^{63} 263-1)long longunsigned8字节(=64位)0 ~ 18446744073709551615(0 ~ 2 64 2^{64} 264-1) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/878675aff9a4153704b061d1d53da741/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f3bf420aacb4c4dcb735b7ef7fa558c/" rel="bookmark">
			【Docker基础三】Docker安装Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载镜像 根据自己需要下载指定版本镜像，所有版本看这：Index of /releases/ (redis.io) 或 https://hub.docker.com/_/redis
# 下载指定版本redis镜像 docker pull redis:7.2.0 # 查看镜像是否下载成功 docker images 创建挂载目录 # 宿主机上创建挂载目录 mkdir -p /usr/local/software/docker/redis/conf mkdir -p /usr/local/software/docker/redis/data # 进入conf文件夹下创建redis.conf文件 # 文件内容看下方 cd /usr/local/software/docker/redis/conf vi redis.conf 注：redis.conf文件github地址：redis/redis.conf at 7.2 · redis/redis · GitHub
创建并启动容器 docker run -itd --name redis7 -p 6379:6379 -v /usr/local/software/docker/redis/conf/redis.conf:/etc/redis/redis.conf -v /usr/local/software/docker/redis/data:/data redis:7.2.0 redis-server /etc/redis/redis.conf --appendonly yes --requirepass gusy1234 --bind 0.0.0.0 -::1 命令解释：
-p 6379:6379
端口映射，语法：-p 宿主机端口:容器端口
-v /usr/local/software/docker/redis/conf/redis.conf:/etc/redis/redis.conf
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f3bf420aacb4c4dcb735b7ef7fa558c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13a22e04f37a8ddfb8ceb856f02a4ded/" rel="bookmark">
			vite 如何打包 dist 文件到 zip 使用插件 vite-plugin-zip-pack，vue3 ts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vite 如何打包 dist 文件到 zip 使用插件 vite-plugin-zip-pack，vue3 ts 开发过程中一个经常做的事就是将 ./dist 文件夹打包成 zip 分发。
每次手动打包还是很费劲的， vite 同样也有能把 ./dist 文件夹打包成 .zip 的插件，当然这个打包的文件夹不一定非得是 ./dist，可以是任何位置，只要指定好就可以了。
说一下如何实现它。
一、安装 vite 插件 vite-plugin-zip-pack npm 或 yarn 自行取用
npm i -D vite-plugin-zip-pack # 或 yarn add -D vite-plugin-zip-pack 二、配置插件 vite-plugin-zip-pack 打开项目中的 vite.config.ts 文件
头部导入 vite-plugin-zip-pack
import zipPack from "vite-plugin-zip-pack" 它是插件，所以需要放到 vite.config.ts 文件的 plugins 里面
zipPack({ inDir: 'dist', // 输入的文件夹，就是要打包的文件夹 outDir: 'archive', // 打包好的 zip 文件放到哪个文件夹下 outFileName: `diary-${timeStringNow}.zip`, // 打包好的文件名，自行定义，这里我定义了一个 timeStringNow 变量，放置了此时此刻的时间 2024-01-06 这样的 pathPrefix: '' }) 它在编辑器中是长这样的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13a22e04f37a8ddfb8ceb856f02a4ded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dde1223c9dc2e6a42d9519628cd4a9f3/" rel="bookmark">
			【Docker基础一】Docker安装Elasticsearch,Kibana,IK分词器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装elasticsearch 下载镜像 查看版本：Elasticsearch Guide [8.11] | Elastic
# 下载镜像 docker pull elasticsearch:7.17.16 # 查看镜像是否下载成功 docker images 创建网络 因为需要部署kibana容器，要让es和kibana容器互联
# 创建一个网络： es-net docker network create es-net # 查看本机的网络 docker network ls # 删除一个网络 docker network rm es-net 创建容器挂载目录 # 创建挂载目录 mkdir -p /var/lib/docker/volumes/es-data/_data mkdir -p /var/lib/docker/volumes/es-plugins mkdir -p /var/lib/docker/volumes/es-config mkdir -p /var/lib/docker/volumes/kibana-config # 进入es-config目录 cd /var/lib/docker/volumes/es-config # 创建文件 vi elasticsearch.yml # 键入‘’中内容： ‘ cluster.name: "docker-cluster" network.host: 0.0.0.0 ’ # 进入kibana-config目录 cd /var/lib/docker/volumes/kibana-config # 创建文件 vi kibana.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dde1223c9dc2e6a42d9519628cd4a9f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d7a35a57de3a5c9c8b960d89554645c/" rel="bookmark">
			Ajax常见请求方法（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、GET请求 //1.创建对象 const xhr = new XMLHttpRequest(); //2.初始化 设置请求方法和 url xhr.open('GET','http:/127.0.0.1:8000/server') //3.发送 xhr.send() //4.事件绑定 处理服务端返回的结果 //-readystate 是 xhr对象中的属性，表示状态 0 1 2 3 xhr.onreadystatechange = function(){ if(xhr.readyState === 4 ){ //响应码 200 404 403 401 500 if(xhr.status &gt;=200 &amp;&amp; xhr.status &lt; 300){ result.innerHTML = xhr.response }}} 二、POST请求 //1.创建对象 const xhr = new XMLHttpRequest(); //2.初始化 设置请求方法和 url xhr.open('POST','http:/127.0.0.1:8000/server') //设置请求头 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded') xhr.setRequestHeader('name','hhhh')//自定义请求头 //3.发送 xhr.send('a=100&amp;b=200&amp;c=300') //4.事件绑定 处理服务端返回的结果 //-readystate 是 xhr对象中的属性，表示状态 0 1 2 3 xhr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d7a35a57de3a5c9c8b960d89554645c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2996ee5a5aeca5e665658441f228133d/" rel="bookmark">
			【Docker基础二】Docker安装Mysql8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载镜像 安装mysql（版本：8.0.35）
# 拉取镜像 docker pull mysql:8.0.35 # 查看镜像是否已经下载 docker images 创建挂载目录 # 宿主机上创建挂载目录 (可以不创建，docker run -v配置了挂载目录，docker会自动创建宿主机和容器目录) mkdir -p /usr/local/software/docker/mysql/log mkdir -p /usr/local/software/docker/mysql/data mkdir -p /usr/local/software/docker/mysql/conf 补充：容器中‘my.cnf’配置文件在‘/etc/my.cnf’下，默认的data文件在‘/var/lib/mysql’下。
创建并启动容器 docker run -itd --name mysql8 -p 3306:3306 -v /usr/local/software/docker/mysql/conf:/etc/mysql/conf.d -v /usr/local/software/docker/mysql/data:/var/lib/mysql -v /usr/local/software/docker/mysql/log:/var/log/mysql --restart unless-stopped -e MYSQL_ROOT_PASSWORD=gusy1234 mysql:8.0.35 命令解释：
–name mysql8
启动容器的名字
-p 3306:3306
将容器的 3306 (后面那个) 端口映射到主机的 3306 (前面那个) 端口
–restart unless-stopped
容器重启策略
-v /usr/local/software/docker/mysql/conf:/etc/mysql/conf.d
将配置文件夹挂载到主机，语法：-v 宿主机目录:容器目录
-v /usr/local/software/docker/mysql/data:/var/lib/mysql
将mysql储存文件夹挂载到主机
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2996ee5a5aeca5e665658441f228133d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd4d19b05758efcc2d0b050dd7923bb/" rel="bookmark">
			mysql-数据库DDL操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前已经学习了安装mysql服务端还有进行了一些关于数据库安全的设置，现在开始学习创建数据库和数据表以及进行修改。
MySQL的DDL（Data Definition Language）语句用于定义或更改数据库结构，包括创建、修改或删除表、视图、索引等数据库对象。sql语句以关键字和数据库或者数据表格式执行，常见的关键字：SHOW、USE、DROP、DELETE、SELECT等等，以;(分号)结尾，否则可能会报错。
数据库管理系统--&gt;数据库--&gt;数据表--&gt;数据字段--&gt;数据记录。
一、创建数据库 # 登陆数据库
mysql -uroot -p
# 查看所有数据库
SHOW DATABASES;
mysql # 系统数据库（慎动）
sys # 系统数据库
# use关键字+数据库名 ,切换数据库
USE mysql;
# 创建数据库 database + 数据库名称 ,编码utf8
CREATE DATABASE database_name
CHARACTER SET utf8mb4
COLLATE utf8mb4_general_ci;
# 只有在数据库不存在时才进行创建
CREATE database if not exists 数据库名称;
# 删除数据库,一定要小心再小心。
DROP database 数据库名；
# 修改数据库编码类型为utf8
ALTER database 数据库名 character set utf8;
二、常见的数据类型 创建数据表，在数据表中定义字段的类型与长度。
数据类型定义示例int整型int(10)double浮点型double(5,2)表示最多5位，2位小数，最大999.99decimal浮点型用在关于金额的方面，不会出现精度缺失char固定长度字符串char(255),最大char(255),char(100),不足会补足100varchar可变长字符串varchar(65535),用一个字节来记录text字符串超大类型，mysql独有date日期类型格式为：yyyy-MM-ddtime时间类型格式为：hhmmsstimestamp时间戳类型格式为：日期+时间 三、数据表操作 3.1 创建数据表表 CREATE TABLE (IF NOT EXISTS) 表名（
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fd4d19b05758efcc2d0b050dd7923bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/941febe868d0877835daea8be11d5946/" rel="bookmark">
			【MATLAB源码-第104期】基于matlab的MPSK和MQAM调制解调方式仿真，输出误码率曲线。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作环境： MATLAB 2022a 1、算法描述 MPSK（多相位键控）
MPSK是一种基于载波相位变化的数字调制技术。它的核心原理是通过改变载波的相位来表示不同的数字信息。这种技术可以分为几个不同的级别，其中最常见的包括：
1. BPSK（Binary Phase Shift Keying，二进制相位键控）：
只有两个相位（通常是0度和180度），代表两种二进制状态（0和1）。
由于其结构简单，BPSK在信号质量较差的环境中表现良好。
2. QPSK（Quadrature Phase Shift Keying，四相位键控）：
有四个不同的相位（例如0度、90度、180度和270度）。
每个相位表示两位二进制数据（00、01、10、11）。
QPSK相较于BPSK能传输更多数据，但也更容易受到噪声的影响。
3. 8PSK（8-Phase Shift Keying，八相位键控）：
包含八个不同的相位，每个相位代表三位二进制数据。
能够提供更高的数据传输率，但对信号质量的要求更高。
MQAM（多级正交幅度调制）
MQAM则是一种同时利用幅度和相位变化的调制技术。它结合了幅度调制（AM）和相位调制（PM）的特点，能在有限的带宽内传输更多的数据。主要特点包括：
1. 符号的表示：
在MQAM中，每个符号是通过一对值来表示的：一个值决定了幅度，另一个值决定了相位。
这些值通常在二维空间中表示，其中一个轴代表幅度，另一个轴代表相位。
2. 常见的MQAM形式：
16-QAM、64-QAM和256-QAM是最常见的形式。
例如，在16-QAM中，有16个不同的符号，每个符号由一个独特的幅度和相位组合表示。
3. 效率与复杂性：
MQAM能够在相同的频带宽度内传输更多数据，但这也使得它对信号质量的要求更高。
高阶的MQAM（如256-QAM）在理想条件下可以实现极高的数据传输率，但也更易受到干扰和信号衰减的影响。
MPSK：专注于通过改变相位来传输数据。随着相位数量的增加，能够传输的数据量也增加，但同时对信号质量的要求也提高。
MQAM：通过同时改变幅度和相位来传输数据，能在有限的带宽内提供更高的数据传输率，但对信号的质量和稳定性要求更高。
2、仿真结果演示 3、关键代码展示 略
4、MATLAB 源码获取 V 点击下方名片
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48aeb199e99c9e52c906f3147cacb99b/" rel="bookmark">
			基于FFmpeg的短视频编辑工具Cut
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近在学习FFmpeg和音视频的相关知识，为了加强对FFmpeg的认识和了解，于是撸了一个短视频编辑软件Cut。
效果图先行：
技术点 启动页优化 但启动app的时候会有一个短暂的黑屏或者白屏。为什么呢？ 是因为在App启动时，系统会执行3个Task：
1、 加载并启动app
2、在app启动后，立即展示空白的window
3、创建app进程
一旦app进程完成了第一次绘制，系统进程就会用main activity替换已经展示的background window。之后用户才可以使用app。
这个空白的window就是导致白屏或者黑屏的罪魁祸首。怎么解决呢？ 1.定义透明的主题,parent中的AppTheme为APP的主题
&lt;style name="Theme.AppStartLoadTranslucent" parent="AppTheme"&gt; &lt;item name="android:windowIsTranslucent"&gt;true&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; &lt;/style&gt; &lt;!-- 启动界面 --&gt; &lt;activity android:name=".ui.LaunchActivity" android:launchMode="singleTask" android:theme="@style/Theme.AppStartLoadTranslucent"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 启动页优化原理
增量更新和全量更新
在App用了增量更新。
增量更新：增量更新是指在进行更新操作时，只更新需要改变的地方，不需要更新或者已经更新过的地方则不会重复更新，增量更新与全量更新相对。
使用的是bsdiff、 在bspatch中还会用到bzip2.
增量更新的流程：下载差分包，手机上的apk和差很包合并形成新的apk，然后再次安装。
DownloadUtil.get().download(appPath, savePath, saveName,new DownloadUtil.OnDownloadListener() { @Override public void onDownloadSuccess(File file) { if(file != null){ mProgressDialog.dismiss(); LogUtil.e("tag", "---path = " + file.getAbsolutePath()); if(update_type == 1){ //获取当前应用的apk文件/data/app/app String oldFile = Utils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48aeb199e99c9e52c906f3147cacb99b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11358661a6425af5a473acc31d4fcbdc/" rel="bookmark">
			YOLOV8目标识别与语义分割——使用OpenCV C&#43;&#43; 推理模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 深度学习在实际应用中包括训练和推理两个重要阶段，通常依赖于流行的深度学习框架，如Caffe、TensorFlow、PyTorch等。然而，这些框架的安装和配置往往复杂，在实际部署中可能面临一些挑战。
自从OpenCV 3.3版本起，引入了DNN模块，为用户提供了一种更加简便的方式进行深度学习推理。使用OpenCV的DNN接口，用户可以无需安装额外的依赖，直接在正常安装OpenCV的基础上，使用经过训练的深度学习模型进行推理计算，从而简化了深度学习模型的部署过程。这为开发者提供了更方便、更轻量级的选择，使得在实际应用中更容易集成深度学习技术。
推理环境 当前使用的环境是OpenCV4.7 带dnn模块，YoloV8的推理目前只支持opencv4.7.0及其以上的版本，而目前opencv4.7.0的版本有问题，如果推理CPU不支持AVX2指令集，则需要在net.forward() 前面加上net.enableWinograd(false);来关闭Winograd加速，关于这个问题可以参考这个issue .
模型转换 安装环境：
conda create -n yolov8 python=3.8 activate ylolv8 pip install ultralytics 模型转换：
使用以下命令将YOLO模型从PyTorch导出为ONNX格式，并设置opset为12：
yolo export model=yolov8s.pt format=onnx dynamic=False opset=12 此命令的含义解释如下：
yolo export: 使用YOLO导出功能model=yolov8s.pt: 指定PyTorch模型的路径format=onnx: 导出为ONNX格式dynamic=False: 关闭动态输入opset=12: 设置ONNX模型的opset版本为12 推理代码 1.目标识别 #include "YoloV8Detect.h" YoloV8Detect::YoloV8Detect() { } bool YoloV8Detect::detect(cv::Mat&amp; cv_src,std::vector&lt;OutputSeg&gt;&amp; output) { cv::Mat blob; output.clear(); int col = cv_src.cols; int row = cv_src.rows; cv::Mat net_input_img; cv::Vec4d params; LetterBox(cv_src, net_input_img, params, cv::Size(_net_width, _net_height)); cv::dnn::blobFromImage(net_input_img, blob, 1 / 255.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11358661a6425af5a473acc31d4fcbdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b62653f6c6fdae4976e68f3b02838f56/" rel="bookmark">
			外包干了4个月，技术退步明显了...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说一下自己的情况，大专生，18年通过校招进入武汉某软件公司，干了接近4年的功能测试，今年年初，感觉自己不能够在这样下去了，长时间呆在一个舒适的环境会让一个人堕落！
而我已经在一个企业干了四年的功能测试，已经让我变得不思进取，谈了2年的女朋友也因为我的心态和工资和我分手了。
于是，我决定要改变现状，冲击下 大厂。
刚开始准备时，自己都蒙了，四年的功能测试让我的技术没有一丝的进步，提升的只有我的年龄…
没办法，我找到了我在腾讯的老哥，作为他的小老表，在他了解了我的情况后(几乎就是软件测试基础开始)，直接甩给我一个网盘，说到：“去吧，这里有你需要的所有东西，不要来找我了，我都嫌丢人!”。
盘里头是一整套软件测试面试必备文档PDF，看完之后直接给我老哥给跪了…这下面试稳了。
内容涵盖：包括测试理论、Linux基础、MySQL基础、Web测试、接口测试、App测试、管理工具、Python基础、Selenium相关、性能测试、LordRunner相关等… 质量非常高，需要的可自行领取！！
全网首发-涵盖16个技术栈 第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）
第二部分，Linux（ Linux基础+Linux练习题）
第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）
第四部分，Web测试
第五部分，API测试
第六部分，App测试
第七部分，管理工具
第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）
第九部分，Selenium相关
第十部分，性能测试
第十一部分，LordRunner相关
第十二部分，计算机网络
第十三部分，组成原理
第十四部分，数据结构与算法
第十五部分，逻辑题
第十六部分，人力资源
软件测试基础 软件测试的步骤是什么?如何录制测试脚本?应该考虑进行如何测试的测试方法怎样估计测试工作量?测试设计的问题当测试过程发生错误时，有哪几种解决办法?测试执行的问题测试评估的目标如何提高测试?C/S模式的优点和缺点B/S模式的优点和缺点 Linux grep和find的区别? grep 都有哪些用法?查看IP地址?创建和删除一个多级目录?在当前用户家目录中查找haha.txt文件?如何查询出tomcat的进程并杀掉这个进程，写出linux命令?动态查看日志文件?查看系統硬盘空间的命令?查看当前机器listen 的所有端口?… Python 统计python源代码文件中代码行数，去除注释，空行，进行输出?python调用cmd并返回结果?冒泡排序1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数判断 101-200 之间有多少个素数，并输出所有的素数一个输入三角形的函数，输入后输出是否能组成三角形，三角形类型，请用等价类- 划分法设计测试用例 MySQL 你用的Mysql是哪个引擎，各引擎之间有什么区别?如何对查询命令进行优化?数据库的优化?Sql注入是如何产“生的，如何防止?NoSQL和关系数据库的区别?MySQL与MongoDB本质之间最基本的差别是什么Mysql数据库中怎么实现分页?Mysql数据库的操作?优化数据库?提高数据库的性能?什么是数据的完整性? …
Web Web测试和app测试区别？WEB测试环境搭建和测试方法WEB测试教程WEB测试要点及基本方法Web测试页面总结… 接口测试 什么是接口如果模块请求http改为了https,测试方案应该如何制定，修改?常用HTTP 协议调试代理I具有什么?详细说明抓取HTTPS协议的设置过程?描述TCP/IP协议的层次结构，以及每一-层中重要协议jmeter,一个接口的响应结果如下:接口产生的垃圾数据如何清理依赖第三方的接口如何处理测试的数据你放在哪?什么是数据驱动，如何参数化? …
性能测试 你认为性能测试的目的是什么?做好性能测试的工作的关键是什么?服务端性能分析都从哪些角度来进行?如何理解压力测试，负裁测试以及性能测试?如何判断是否有内存泄漏及关注的指标?描述软件产“生内存泄露的原因以及检查方式。(可以结合- 种开发语言进行描述)简述什么是值传递，什么是地址传递，两者区别是什么?什么是系统瓶颈?…、 elenium 如何开展自动化测试框架的构建?如何设计自动化测试用例:webdriver如何开启和退出一个浏览器?什么是自动化测试框架?Selenium是什么，流行的版本有哪些?你如何从命令行启动Selenium RC?在我的机器端口4444不是免费的。我怎样才能使用另一个端口?什么是Selenium Server,它与Selenium Hub有什么不同?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b62653f6c6fdae4976e68f3b02838f56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bafcfc2c2f759ef38116375e87d18c7f/" rel="bookmark">
			Adding Conditional Control to Text-to-Image Diffusion Models——【论文笔记】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文发表于ICCV2023 论文地址：ICCV 2023 Open Access Repository (thecvf.com)
官方实现代码：lllyasviel/ControlNet: Let us control diffusion models! (github.com) Abstract 论文提出了一种神经网络架构ControlNet,可以将空间条件控制添加到大型的预训练文本到图像扩散模型中。ControlNet将预训练好的大型扩散模型锁定，通过克隆的方式重新使用其深度和强大的编码层，以学习需要加入的各种条件控制，并通过一个特殊的卷积层“零卷积”连接。
通过各种实验证明，通过ControlNet来实现各种如边缘、深度、分割、人体姿势等条件控制的扩散模型是十分有效的，且无论对于大型还是小型数据集而言，训练都是鲁棒的，大量结果表明ControlNet可以促进更广泛的应用程序来控制图像扩散模型。
一、Introduction 目前文本生成图像的扩散模型可以给我们带来高质量的图像生成。然而，文本生成图像模型在对图像的空间组成提供的控制方面是有限的；仅仅通过文本提示精确的表达复杂的布局、姿势、形状和形式比较困难。因此生成一个与我们心理意向准确匹配的图像通常需要无数次的试验。于是我们试图通过提供额外的图像来直接指定想要的图像组合，从而实现更细粒度的空间控制，比如边缘图、人体姿势骨架、分割图、深度、法线等，这些通常被视为图像生成过程中的条件。
以端到端的方式学习大型文本到图像扩散模型的条件控制是具有挑战性的。特定条件的训练数据量可能显著小于可用于一般文本到图像训练的数据。直接微调或继续训练具有有限数据的大型预训练模型可能会导致过度拟合和灾难性遗忘。
本文介绍了ControlNet，这是一种端到端的神经网络架构，可以学习大型预训练文本到图像扩散模型的条件控制（在我们的实现中是稳定扩散）。
二、Related Work 1.微调神经网络 微调神经网络的一种方法是直接用额外的训练数据继续训练它。但这种方法可能导致过拟合、模式崩溃和灾难性遗忘。广泛的研究集中在开发微调策略，以避免这些问题。
这里主要简单介绍了HyperNetwork、Adapter、Addtiive Learning、Low-Rank Adaptation (LoRA)以及Zero-Initialized Layers。
2.图像扩散 这部分首先介绍了当前几个比较有名的图像扩散模型，包括潜在扩散模型LDM，也就是StableDiffusion的基础；以及GLIDE、Imagen、DALL-E2和Midjourney。
然后，介绍了目前比较流行的控制图像扩散模型的方法，主要包括MakeAScene、SpaText、Textual Inversion和DreamBooth等，最后还简单聊了一下图像到图像的转换条件。
三、Method 1.ControlNet ControlNet会将附加的条件注入到神经网络的块中。
这个所谓的“网络块”用于指代通常放在一起以形成神经网络的单个单元的一组神经层，例如，resnet块、conv-bn-relu块、多头注意力块、Transformer块等。
论文中，以2D特征图为例，即x ∈ Rh×w×c，{h，w，c}分别为地图中通道的高度、宽度和数量。
为了将ControlNet添加到这样一个预先训练的神经块中，首先要锁定（冻结）原始块的参数Θ，同时将该块克隆到具有参数Θc的可训练副本中（图b）。可训练副本将外部条件向量c作为输入。当这种结构应用于稳定扩散等大型模型时，锁定的参数保留了用数十亿张图像训练的生产就绪模型，而可训练副本则重用这种大规模预训练模型，以建立一个深度，鲁棒性和强大的骨干来处理不同的输入条件。
然后，使用零卷积层将训练完的副本块与原始模型连接起来，并将学习到的额外条件信息映射到参数固定的预训练大模型中。如图（b）所示，将副本块与原始模型之间添加两个零卷积层，再与原始模型相连接，这两个零卷积层的权重会在训练过程中逐渐增加。通过这种连接方式，副本块的输出可以与原始模型的输出相加，从而将额外的条件信息引入到预训练大模型中。这样做的好处是，在训练初期，不会往大模型的深层特征中加入任何有害的噪声，同时也保护了预训练大模型的质量和能力。
2.ControlNet for Text-to-Image Diffusion Stable Diffusion是一个在数十亿张图像上训练的大型文本-图像扩散模型，本质上是个U-Net，包括一个编码器、一个中间块和一个跳连解码器。编码器和解码器都有12个块，完整的模型包含25个块。在这些块中，有8个块是下采样或上采样的卷积层，17个块是主要块，每个块包含四个ResNet层和两个ViT。每个ViT包含几个交叉注意力。文本使用CLIP进行编码，扩散时间步使用位置编码进行编码。
如上图是将ControlNet添加到StableDiffusion中的结构图，如此连接ControlNet的方式在计算上是高效的-由于锁定的复制参数被冻结，因此在最初锁定的编码器中不需要梯度计算来进行微调。这种方法可以加快训练速度并节省GPU内存。在单个NVIDIA A100 PCIE 40 GB上进行的测试表明，与不使用ControlNet优化Stable Diffusion相比，使用ControlNet优化Stable Diffusion只需要增加约23%的GPU内存和34%的训练迭代时间。
3.Training 给定输入图像z0，图像扩散算法逐渐地将噪声添加到图像并产生噪声图像zt，其中t表示添加噪声的次数。给定包括时间步长t、文本提示ct以及特定于任务的条件cf的一组条件。
L是整个扩散模型的总体学习目标。输入的四个参数Zt,t,Ct,Cf分别是：
- Zt：潜在噪声向量
- t：时间步骤t
- Ct：文本提示Prompt
- Cf：额外添加的条件
在训练过程中，会随机将50%的文本提示ct替换为空字符串。这种方法增加了ControlNet直接识别输入条件图像中的语义的能力（例如，边缘、姿势、深度等）作为提示的替代。在训练过程中，由于零卷积不会给网络增加噪声，因此模型应该始终能够预测高质量的图像。
4.Inference 通过额外的方式进一步去控制ControlNet的外条件去影响去噪扩散过程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bafcfc2c2f759ef38116375e87d18c7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5530835f26bb8bd3174bc7673d54857a/" rel="bookmark">
			麒麟镜像下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试用版下载链接
产品试用申请·国产操作系统、银河麒麟、中标麒麟、开放麒麟、星光麒麟——麒麟软件官方网站
下载自己对应的操作系统
我下载的是
共享文件下载 - Kylin Distro
然后用迅雷下载就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5f79e8166e8163db865063b3f6dc59d/" rel="bookmark">
			0-自然语言处理基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 transformers1.1 什么是transformers1.2 优缺点和使用场景是什么？优点缺点使用场景 1 transformers 1.1 什么是transformers transformers 是由 Hugging Face 团队开发的一个非常流行的开源库，它为自然语言处理（NLP）提供了大量预训练的模型，如 BERT、GPT、T5、RoBERTa 等。这个库使得使用这些先进的模型变得更加容易，无论是用于语言理解还是生成任务。
以下是 transformers 库的一些关键特点和用途：
预训练模型：transformers 提供了大量预训练的模型，这些模型已经在大型文本数据集上训练过，可以进行各种语言任务，如文本分类、问答、文本生成、翻译等。
简化 API：库提供了简单的 API 来下载、加载和使用这些模型。这包括对模型的 tokenization（分词）和 inference（推理）操作的支持。
多种框架支持：尽管最初是基于 PyTorch 设计的，transformers 现在也支持 TensorFlow，使得它在不同的深度学习框架中都可用。
多种任务适用性：从文本分类、句子配对、问答系统到文本生成，transformers 支持多种 NLP 任务，并提供相应的模型和工具。
社区和文档：由于其广泛的使用和社区支持，transformers 拥有很好的文档和社区，为初学者和专业人士提供帮助和资源。
灵活性和扩展性：transformers 不仅提供预训练模型，还允许用户对这些模型进行微调，以适应特定的数据集和任务。
总的来说，transformers 是 NLP 领域的一个重要工具，它简化了使用最先进模型的过程，使研究者和开发者能够更容易地在他们的项目中实现复杂的语言处理功能。
1.2 优缺点和使用场景是什么？ transformers 库是一个功能强大的工具，广泛用于自然语言处理（NLP）领域。它的优缺点以及使用场景如下：
优点 丰富的模型库：提供广泛的预训练模型，包括BERT、GPT、RoBERTa、T5等，适用于各种NLP任务。
简洁的API：用户友好的接口使得加载、微调、部署模型变得简单直接。
多框架支持：兼容PyTorch和TensorFlow，提供灵活性。
高效的性能：优化过的实现确保了高效的内存和时间性能，特别是在大型模型和数据集上。
社区支持：由于其广泛的使用，拥有一个活跃的社区和详细的文档，为用户提供了丰富的资源和支持。
持续更新：定期更新以包括最新的研究和模型。
缺点 资源需求：预训练的模型通常非常大，需要大量的内存和计算资源。
复杂性：对于初学者来说，理解和使用这些先进的模型可能具有一定的挑战性。
过度依赖预训练模型：可能导致用户忽视数据的质量和特定任务的调整。
不适合特定任务：虽然预训练模型在许多通用任务上表现出色，但可能不适用于高度特定化或罕见的应用场景。
使用场景 文本分类：情感分析、垃圾邮件检测等。
问答系统：构建能够理解自然语言问题并提供答案的系统。
文本生成：自动写作、摘要、翻译等。
命名实体识别（NER）：从文本中识别出特定的实体（如人名、地点、组织）。
情感分析：分析文本中的情绪倾向。
语言理解：改进搜索引擎、聊天机器人等的语言理解能力。
总体来说，transformers 是为那些希望在他们的项目中利用最新NLP技术的研究人员、数据科学家和开发者设计的。尽管它的使用需要一定的计算资源和技术知识，但它为处理复杂的语言任务提供了强大的工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be94abe4d6fcf499d0ab6559b693620f/" rel="bookmark">
			Ubuntu配置Yolov8环境并训练自己的数据集 &#43; ROS实时运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、环境配置与功能测试1.1 安装1.2 目标检测1.3 实例分割1.4 分类1.5 姿态检测 二、训练数据标注三、数据集训练方法3.1 命令训练3.2 代码训练 四、Yolov8在ROS中实时运行4.1 yolov8_ros4.2 ultralytics_ros 前言：需要先安装CUDA和Anaconda，它们的安装参考我这篇文章：Ubuntu配置深度学习环境（TensorFlow和PyTorch）
一、环境配置与功能测试 1.1 安装 新建一个虚拟环境下安装：
# 新建虚拟环境 conda create -n yolov8 python=3.8 # 激活虚拟环境 conda activate yolov8 pip install ultralytics # 使用清华大学的镜像源安装 pip install ultralytics -i https://pypi.tuna.tsinghua.edu.cn/simple/ 源码安装：
# 激活虚拟环境 conda activate yolov8 # 需要单独安装torch conda install pytorch==2.0.0 torchvision==0.15.0 torchaudio==2.0.0 pytorch-cuda=11.7 -c pytorch -c nvidia git clone https://github.com/ultralytics/ultralytics.git cd ultralytics # 安装依赖 pip install -r requirements.txt # 使用清华大学的镜像源安装 pip install -r requirements.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be94abe4d6fcf499d0ab6559b693620f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c08f8f4bc20488bd23e622956d3c152/" rel="bookmark">
			Android 某个应用缺少特殊权限导致系统一直重启解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 某个应用缺少特殊权限导致系统一直重启解决 文章目录 Android 某个应用缺少特殊权限导致系统一直重启解决一、前言二、错误日志三、分析解决四、其他1、对 privapp-permissions 称呼的误解2、系统特殊权限有哪些2、系统其他权限介绍（1）普通权限（normal）（2）运行时权限（dangerous）（3）签名权限（signature）（4）特殊权限（privileged） 3、系统framework权限文件 AndroidManifest.xml4、其他查看源码地址： 一、前言 系统一些应用会使用到特殊权限，这时候要在系统配置一下否则系统会一直重启。
出现该问题的时候，系统一直显示开机Log界面，无法正常进入Android系统界面。
下面一起分析总结一下吧。
本文不仅正文有学习价值，后续的延伸介绍内容也是有学习价值的。
二、错误日志 系统会有如下 AndroidRuntime 日志：
01-02 21:16:05.037 1766 1766 D AndroidRuntime: Shutting down VM 01-02 21:16:05.038 1766 1766 E AndroidRuntime: *** FATAL EXCEPTION IN SYSTEM PROCESS: main 01-02 21:16:05.038 1766 1766 E AndroidRuntime: java.lang.IllegalStateException: Signature|privileged permissions not in privapp-permissions allowlist: {com.android.documentsui (/system/priv-app/DocumentsUI): android.permission.MODIFY_QUIET_MODE, com.android.documentsui (/system/priv-app/DocumentsUI): android.permission.INTERACT_ACROSS_USERS, com.android.documentsui (/system/priv-app/DocumentsUI): android.permission.START_FOREGROUND_SERVICES_FROM_BACKGROUND, com.android.documentsui (/system/priv-app/DocumentsUI): android.permission.CHANGE_OVERLAY_PACKAGES, com.android.documentsui (/system/priv-app/DocumentsUI): android.permission.READ_COMPAT_CHANGE_CONFIG, com.android.documentsui (/system/priv-app/DocumentsUI): android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c08f8f4bc20488bd23e622956d3c152/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/726478c0c641dfba53b23ef791c73e2b/" rel="bookmark">
			Shape-IoU: More Accurate Metric considering Bounding Box Shape and Scale
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pdf链接：https://pan.baidu.com/s/1T534oaZWQY65SRh0QZ3bug 提取码：yyds
作为检测定位分支的重要组成部分，边界框回归损失在目标检测任务中起着重要作用。现有的边界框回归方法通常考虑GT框和预测框之间的几何关系，通过相对位置和框形来计算损失，而忽略边界框的固有属性（如边界框的形状和尺寸）对边界框回归的影响。为了弥补现有研究的不足，本文提出了一种关注边界框自身形状和尺寸的边界框回归方法。首先，分析了边界框的回归特性，并发现边界框自身的形状和尺寸因素将对回归结果产生影响。基于上述结论提出了Shape IoU方法，该方法通过关注边界框自身的形状和尺寸来计算损失，从而使边界框回归更准确。最后，通过大量的比较实验验证了Shape-IoU方法，实验结果表明，Shape-IoU可以有效提高检测性能，并超越现有方法，在不同的检测任务中实现最先进的性能。代码：GitHub - malagoutou/Shape-IoU 论文：https://arxiv.org/pdf/2312.17663.pdf
关键词-目标检测，损失函数，边界框回归
图1: 左图、右图的回归样本只在边界框形状上有所不同，两个回归样本分别对应GT盒长边方向和短边方向的偏差是相同的，从图中可以看出GT盒形状因素导致的回归效果的差异。右图的回归效果优于左图。
1.介绍 目标检测是计算机视觉的基本任务之一，其目标是在图像中定位和识别物体。根据是否生成Anchor点，可以将方法分为基于Anchor点的方法和基于Anchor点的方法。基于Anchor点的方法包括FasterR-CNN,YOLO系列,SSD和RetinaNet。基于Anchor点的方法包括CornerNet, CenterNet和FCOS。在这些检测器中，边界框回归损失函数作为局部化分支的重要组件起着不可替代的作用。 在目标检测领域，最常用的方法包括IoU, GIoU, CIoU, SIoU等。IoU作为目标检测领域最广泛使用的损失函数，其优点在于更准确地描述了预测框和GT框之间的匹配程度。其缺点主要在于当两个框的交点为0时，无法准确描述预测框和GT框之间的位置关系。GIoU通过引入最小检测框来解决这个问题，从而提供了一个具体的改进。CIoU进一步提高了检测精度，通过在考虑预测框和GT框的中心点之间的归一化距离最小化的基础上，增加了一个形状损失项。在SIoU的工作中，提出将连接预测框中心点和GT框中心点的线的角大小作为新的损失项来考虑，以更准确地通过角的变化来判断预测框和GT框之间的匹配程度。总之，边界框回归的主要方法是通过在IoU的基础上添加新的几何约束来使回归更准确。上述方法考虑了GT框和Anchor框的距离、形状和角度对边界框回归的影响，但忽略了边界框自身的形状和尺寸也会对边界框回归产生影响的事实。为了进一步提高回归的准确性，作者分析了边界框自身形状和角度的影响，并提出了一个新的边界回归损失：Shape-IoU。
本文的主要贡献如下：
分析结果表明，在边界框回归过程中，边界框回归样本自身的形状和尺寸因素将对回归结果产生影响。基于现有的边界框回归损失函数，考虑到边界框回归样本自身的形状和尺寸对边界框回归的影响，提出了Shape-IoU损失函数，并在微型目标检测任务中提出了Shape-dot-distance和Shape-nwd损失。在各种检测任务上使用最先进的单阶段检测器进行了系列的比较实验，实验结果表明，本文提出的方法的检测效果优于现有方法，达到了最先进的水平。 2.相关工作 2.1 目标检测中基于IOU的度量 近年来，随着检测器的不断发展，边界框回归损失也得到了快速的发展。最初，IoU被提出用于评估边界框回归的状态，而基于IoU的DIoU, CIoU, EIoU, SIoU等方法则通过在IoU的基础上添加不同的约束来实现更好的检测。
1) IoU Metric: IoU是最流行的目标检测评估指标，定义如下：
其中，B和BGT分别表示预测框和GT框。
2) GIoU Metric: 由于在边界框回归中，GT框和 Anchor 框之间没有重叠，导致IoU损失出现梯度消失的问题，因此提出了GIoU（广义IoU）来解决这个问题。其定义如下：
其中，C表示GT框和 Anchor 框之间的最小检测框。
3) DIoU Metric:由于在边界框回归中，GT框和 Anchor 框之间没有重叠，导致IoU损失出现梯度消失的问题，因此提出了GIoU（广义IoU）来解决这个问题。其定义如下：
与GIoU相比，DIoU考虑了边界框之间的距离约束，并在IoU的基础上添加了中心点归一化距离损失项，从而使得回归结果更准确。其定义如下：
在这里，和分别表示 Anchor 框的中心点和GT框的中心点，表示欧几里得距离，其中表示和之间的最小检测框的斜边长度。
CIoU进一步考虑了GT和Anchor框之间的形状相似性，通过在DIoU的基础上添加一个新的形状损失项来减少Anchor框和GT框之间的宽高比差异。其定义如下：
在这里，和分别表示GT框的宽度和高度，和分别表示Anchor框的宽度和高度。
4) EIoU Metric:EIoU根据CIoU重新定义了形状损失，并进一步通过直接减小GT框和Anchor框之间的宽高比来提高检测精度。其定义如下：
在这里，wc和hc分别表示最小检测框覆盖GT框和Anchor框的宽度和高度。
5) SIoU Metric:在前人研究的基础上，SIoU进一步考虑了边界框之间的角度对边界框回归的影响，旨在通过减小Anchor框和GT框之间的角度（水平或垂直方向）来加速收敛过程。其定义如下：
2.2 微小目标检测中的度量 基于IoU的度量适用于一般的目标检测任务，对于小目标检测，为了克服自身对IoU值的敏感性，提出了Dot Distance[13]和Normalized Wasserstein Distance (NWD)[14]。
1) Dot Distance:
其中D为GT盒中心点与锚框中心点之间的欧氏距离，S为目标在数据集中的平均大小。M表示图像数量，Ni表示第i张图像中标记的边界框数量，wij和hij分别表示第i张图像种中第j条边界的宽度和高度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/726478c0c641dfba53b23ef791c73e2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd1f9c0eb13c0254cfa0493b152e47ad/" rel="bookmark">
			input 关闭输入的自动提示 autocomplate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		input 关闭输入的自动提示 autocomplate 一、问题 有些时候需要将 Input 的自动提示去掉，因为不去掉的话会很烦人，比如我有一个输入温度的输入框：每次点的时候都会出来这个提示框，很烦
二、解决方法 这个是可以解决的，本身 input 元素就有一个属性是 autocomplete 只需要设置一下就可以了。
如果你想它不再提示任何内容，就这样写：
&lt;input autocomplete="off" /&gt; 其实它这个属性值除了 “off” 之外，还有其它的一些可选的内容，可以看 MDN 中的说明：
https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#values
三、结果 这样再点击的时候就不会出现烦人的输入提示框了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c44ebdcba24724f236e77e501430d4/" rel="bookmark">
			2024华为OD机试真题目录 B&#43;C&#43;D卷，使用C语言进行解答（470道）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🚀前言🚀其他华为OD机试题清单一、什么是华为OD，什么是华为OD机试？二、华为OD面试流程？三、华为OD机试通过率高吗？四、华为OD薪资待遇？🚀五、怎么刷题？通过华为OD机试？华为OD原题刷题列表🔰部分文章试读演示🔰 部分思路参考展示🔰本专栏题库列表：华为OD机试真题(C语言) B+C+D卷 📝最后作者：KJ.JK 🚀前言 本文是2024华为OD机试真题(C语言)专栏的目录贴（持续更新中…）
专栏介绍：定期更新华为OD各个时间阶段的机试真题，每日定时更新，本专栏将使用C语言进行更新解答，包含真题，思路分析，代码参考，欢迎大家订阅学习
🚀其他华为OD机试题清单 🔥2024华为OD机试真题(C C++ Java Py JS) B+C+D卷🔥
🔥2024华为OD机试真题(C语言) B+C+D卷🔥
🔥2024华为OD机试真题(Python语言) B+C+D卷🔥
🔥2024华为OD机试真题(Java 语言) B+C+D卷🔥
🔥2024华为OD机试真题(C++语言)B+C+D卷🔥
🔥2024华为OD机试真题(JS 语言) B+C+D卷🔥
🔥2024华为OD机试真题(Golang语言) B+C+D卷🔥
🔥2024华为OD机试真题(C++ Java Python) 🔥
一、什么是华为OD，什么是华为OD机试？ 华为OD是Outsourcing Dispacth模式，是华为和外企德科联合招聘的简称。目前华为大多数是OD招聘。OD模式也是华为提出的一种新的用工形式，每年都会从OD项目挑优秀员工转为正编。所有OD和正式员工一样对待，没有差别，部门平时开会、评审等活动都是一起参加的，是同薪同酬，都是由华为的HR直接定的薪资，看的是我们技术能力。华为是大企业，能到华为上班也是有能力的，每个部门都有好多职位，是金子，在哪都会发光。薪资对华为OD也是有绝对的优势，在互联网一线的大厂中，华为的工作环境和薪资都是很好的，OD其实简单说就是外包，现在有很多公司都在给华为供给外包服务，比如中软，因为华为有很多业务部门，去年一个很熟的猎头给我推荐了几个技术岗位的华为OD都通过了
而华为OD机试是指华为公司的在线笔试，是华为公司用于筛选招聘岗位候选人的一种考核方式，
华为OD机试通常由多个题目组成，包括算法设计、编程、调试等多个环节，考察候选人的基础知识、实际能力和算法编写能力等多个方面，是华为招聘流程中非常重要的一环
二、华为OD面试流程？ 华为OD面试流程一般包括以下几个步骤：
1、笔试：考察候选人的基础知识、算法设计和编程能力等多个方面，题目通常包括算法题、编程题、数据结构题等
2、性格测试(综合测试)：这部分是用来评估候选人的性格特质，以便更好地了解其适应能力、沟通能力和团队合作能力等
3、技术一面：该面试官通常是该项目组的技术负责人，主要考察候选人对技术的理解和实际应用能力。面试内容通常包括代码题和项目问题解决，围绕计算机/编程基础+项目经验+代码能力进行考察，如应届生无项目经验，重点复习八股文+刷算法题
4、HR面：围绕求职动机、稳定性、薪酬期望、Gap经历、延毕等异常情况进行考察
5、终面：终面是在参加完所有面试后进行的最后一轮面试，，主要考察候选人的综合素质和领导潜力；其中，笔试和性格测试是比较常见的部分，而技术一面和群面则比较特殊，通常会根据不同的岗位和项目有所不同，最终的面试结果也会根据个人的表现和竞争情况而定，不会限制通过人数
全流程线上进行，一般机考通过后2-3周内出offer，特殊情况时间过长的话需要积极联系接口人HR
三、华为OD机试通过率高吗？ 据华为官方公布的数据，华为OD机试的通过率约为75%。具体来说，华为OD机试一共有五个级别，从D1到D5，对应13到17级，每个级别的题目数量和难度都有所不同。在过去的招聘中，据说只有25%左右的候选人能够通过第一轮机试。第二轮性格测试也是招聘流程中的重要环节，会刷掉一部分人。不过，华为表示，最终的通过率取决于候选人的实际表现和竞争情况，不会限制通过人数
此外，华为还将机试分为上机考试和在线作业两部分，上机考试主要考察算法设计和编程能力，在线作业主要考察算法思维和解决问题的能力。华为表示，在线作业部分是考察候选人的综合能力，包括解决问题的能力、沟通能力和团队合作能力等。
综合来看，华为OD机试的通过率虽然不是100%，但是也是在高水平范围内的。对于候选人来说，需要全面提升自己的能力，才能更好地通过机试
四、华为OD薪资待遇？ 薪资结构：
1、基本工资+绩效工资+年终奖（2-4个月，一般绩效A-4个月，B-2个月）；
2、D1-D5分别对应华为13-17级，参考范围10-40K；
3、试用期内（6个月）工资不打折，按B绩效发绩效工资，转正时重新评绩效，一般分A、B、C三档（主要A或B，C概率较小），和正式员工分开评，半年评一次；
4、五险一金基数按基本工资，公积金比例5%-12%，具体看base地。
5、福利补贴：带薪年假、入职&amp;年度免费体检、免费夜宵、班车/加班打车免费、下午茶、节假日礼品等
13级薪资：9k-13k
14级薪资：13k-17k
15级薪资：17k-21k
16级薪资：21k-25k
17级薪资：25k-29k
🚀五、怎么刷题？通过华为OD机试？华为OD原题刷题列表 🔥2024华为OD机试真题(C C++ Java Py JS) B+C+D卷🔥
🔥2024华为OD机试真题(C语言) B+C+D卷🔥
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49c44ebdcba24724f236e77e501430d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a72cc79e3e90623d59421120a88ce49e/" rel="bookmark">
			吉他打谱软件Guitar Pro8苹果Mac电脑简体中文特别版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Guitar Pro 8 Mac是一款吉他编曲学习软件，用于吉他、贝和其他弦乐器的制谱和演奏，这是一个多轨编辑器，具有集成的 MIDI 编辑器、合唱绘图仪、吉他、节拍器和其他音乐家工具。它使您能够编辑吉他、贝司和尤克里里、乐谱、指法谱，并创建鼓或钢琴备份轨迹。它为想要开发、编写或弹奏吉他的经验丰富的音乐家提供详细资源。
此外，时间、循环、和弦和音阶字典、调音器、单独的音量调音、虚拟键盘和吉他指板都可以用它来控制。Guitar Pro 激活码免费下载还配备了 Realistic Sound (RSE)，带有一个音板，用于对每个音轨上的声音进行完整配置和 60 种建模效果(放大器、效果器、主吉他、电吉他、原声吉他)、电吉他和原声吉他、贝司、键盘和黄铜。
Guitar Pro 8 win-安装包下载如下：
https://wm.makeding.com/iclk/?zoneid=50683
Guitar Pro 8 mac-安装包下载如下：
https://wm.makeding.com/iclk/?zoneid=50684
以下是 Guitar Pro 8的一些特点和介绍：
制谱功能：Guitar Pro 允许用户创建、编辑和播放各乐谱。它支持多种器，包括他、贝斯、键盘、鼓声乐等。
音符输入：用户可以使用键盘、鼠标或MIDI设备输入音符，并在乐谱中进行编辑。它提供丰富的音符符号和技选项，以满不同类型的音乐需求。
播放功能：Guitar Pro 可以通过内置的音源引擎播放乐谱，以便用户到实际演奏效果。用户可以调整播放速度、循环播放特定部分，并使用变调功能来适应不同的演要求。
教学工具：该件还提供了一些教学工具，如音轨分离、减速播放和环练习，以帮助用户学习和掌握乐曲。
共享和导出：用户可以将自己的乐谱导为各种格式，如音频文件、图像文件或PDF文档。们还可以在 Guitar Pro 社区中分享自己的作，并与其他音乐爱好者交流和合作。
功能介绍 点击和编辑
一个主要的新功能，为评分编辑。你现在需要做的就是点击下面的元素来编辑它们:标题，谱号，键签名，节奏，小节，调音，和弦，三连音
更快的检索用户的专业吉他文件
浏览器列出了所有吉他专业的文件在用户的硬盘上或在一个特定的文件夹。搜索框，连同视觉和音频预览，允许用户快速找到自己正在寻找的文件。
访问mySongBook乐谱库
该浏览器还提供了对整个mySongBook集合(订阅时)或网站上购买的文件的即时访问。每天访问一个免费的“每日标签”。
改善track-tuning窗口
最新版本已经完全重新设计了调优窗口，使其更加直观和易于使用。现在定制用户的吉他专业7.5音轨的调弦一串一串在一个点击。
自定义MIDI导入
MIDI导入窗口现在为用户提供了许多设置，以获得更高质量的吉他专业文件:曲目合并，导入到现有的文件，量化，选择符号和声音，预览…
点击转换用户所有的旧文件
批处理转换器允许用户将所有吉他Pro 1到6个文件(.gtp、.gp3、.gp4、.gp5、.gpx)转换为吉他Pro 7 (.gp)格式。只需选择包含要转换的文件的文件夹(以及子文件夹，如果有的话)。原始文件不会被删除。
Guitar Pro 8新增功能 Guitar pro 新功能
这个新版本的Guitar pro考虑了我们用户的许多建议，包括更完整和专业的乐谱图形渲染，改进的MIDI和MusicXML导入/导出，音频输出格式的添加以及鼓曲目编辑的返回使用tablature数字。该软件的用户友好性经过全面重新设计和现代化，以支持创造力，使音频微调变得更加容易。该程序现在更平滑，更快速，并与高分辨率屏幕兼容。最后，由于其新的音频输入功能，使用Guitar pro播放歌曲从未如此简单和愉快。我们开发了迄今为止最好的Guitar pro版本。改进的人体工程学，新功能和更好的音频渲染！
1、点击并编辑！
分数编辑的一个主要新功能。你现在需要做的只是点击乐谱的以下元素来编辑它们：标题，谱号，键签名，节奏，部分，调音，和弦，三重奏感觉，fermata ......
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a72cc79e3e90623d59421120a88ce49e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a10dd817c60af6e92f5e2fe6a150b202/" rel="bookmark">
			【性能测试入门】详解客户端性能测试和服务器端性能测试！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：客户端性能测试和服务器端性能测试 客户端性能测试和服务器端性能测试是两个不同但相关的概念:
客户端性能测试:
- 测试应用程序客户端(如Web浏览器、移动应用等)的性能,例如加载时间,响应时间等。
- 测试在不同系统配置(CPU、内存、网络等)下客户端的运行性能。
- 测试客户端在高并发负载下的性能,例如同时打开大量浏览器请求首页。
- 测试移动应用在不同移动设备和网络环境下的响应速度。
服务器端性能测试: - 测试应用程序服务器端的响应时间,吞吐量,连接数等指标。
- 测试服务器软硬件配置对性能的影响,例如CPU核数、内存大小。
- 测试服务器在高并发情况下的应对能力,例如模拟1万并发用户请求。
- 测试分布式系统各个组件之间的性能瓶颈。
- 测试新功能是否会影响现有请求的响应速度。
二：二者的区别 - 客户端测试关注用户体验,服务器测试关注系统承载能力。
- 客户端多与实际业务场景挂钩,服务器侧结果更倾向原理层面。
- 两边结果关系重要,需要协同进行。例如负载引起的客户端慢问题。
所以总的来说,客户端服务器端测试都很重要,二者结果互相影响,需要结合应用场景进行。
三：如何进行客户端和服务器端性能测试: 客户端性能测试:
- 使用浏览器开发者工具,检查页面加载时间、重绘时间等。
- 使用测试工具模拟不同网络环境(3G/4G/WIFI),测试首页和关键流程响应时间。
- 设置高并发测试,同时打开几百个页面测试加载性能。
- 对移动APP进行压力测试,模拟大量用户同时访问APP主流程。
- 检查页面资源大小,减少图片、JS、CSS文件等,优化初次加载。
服务器端性能测试:
- 使用压力测试工具(如JMeter),设置1万等并发用户同时访问首页。
- 检查平均响应时间、通过率等指标,找出性能瓶颈所在。
- 分析数据库查询性能,检查SQL语句是否高效。
- 测试服务器CPU、内存、磁盘和网络利用情况。
- A/B测试不同硬件规格(CPU核数、内存大小)对效率的影响。
- 模拟实际高峰期访问观察系统是否有垮掉的风险。
- 使用profiler分析代码性能问题,改进算法和数据结构。
周期性进行上述测试可以找到痛点, 根据目标 进行优化。定期重复测试检查优化效果。
下面是配套资料，对于做【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴我走过了最艰难的路程，希望也能帮助到你！
最后： 可以在公众号：程序员小濠 ！ 免费领取一份216页软件测试工程师面试宝典文档资料。以及相对应的视频学习教程免费分享！，其中包括了有基础知识、Linux必备、Shell、互联网程序原理、Mysql数据库、抓包工具专题、接口测试工具、测试进阶-Python编程、Web自动化测试、APP自动化测试、接口自动化测试、测试高级持续集成、测试架构开发测试框架、性能测试、安全测试等。
如果我的博客对你有帮助、如果你喜欢我的博客内容，请 “点赞” “评论” “收藏” 一键三连哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b3e7359819308e2d3cee439dd21e4b3/" rel="bookmark">
			记uniapp总动态:style无法用带参数的computed属性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： v-for里面的组件呢，我要根据不同的item配置不同的style,于是有了这样的写法
&lt;template&gt; &lt;view class="weeks-item" v-for="(day,dayIndex) in item" :key="dayIndex"&gt; &lt;view :style="bgStyle(day)" &gt; {{ day. extraInfo.info}} &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default{ computed:{ bgStyle:function(){ return (day)=&gt;{ if(day.extraInfo){ return `background-color:${day.extraInfo.data.bgColor}` }else{ return '' } } }} } &lt;/script&gt; 然后一运行 ，就给报错
👉🏻 ☞ 解决办法： &lt;template&gt; &lt;view class="uni-calendar__weeks-item" v-for="(day,dayIndex) in styledItems(item)" :key="dayIndex"&gt; &lt;view class="daylayer-custom"&gt; &lt;view :style="day.dynamicStyle" &gt; {{ day. extraInfo.info}} &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default{ computed:{ styledItems:function(){ return (item)=&gt;{ return item.map(day =&gt; ({ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b3e7359819308e2d3cee439dd21e4b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d20c8a3a86f71e60c9a5f63e6864841/" rel="bookmark">
			二刷Laravel 教程（用户模型）总结Ⅲ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据库迁移 当我们运行迁移时，up 方法会被调用；（创建表）
当我们回滚迁移时，down 方法会被调用。（删除表）
public function up()
{
//create 方法会接收两个参数：一个是数据表的名称，另一个则是接收 $table（Blueprint 实例）的闭包。
Schema::create('users', function (Blueprint $table) {
$table-&gt;id();
$table-&gt;string('name');
$table-&gt;string('email')-&gt;unique();
$table-&gt;timestamp('email_verified_at')-&gt;nullable();
$table-&gt;string('password');
$table-&gt;rememberToken();
$table-&gt;timestamps();
});
}
public function down()
{
Schema::dropIfExists('users');
}
补： 清理缓存重启服务
在命令行中进入程序根目录，执行下列语句。
php artisan cache:clear
php artisan config:clear
php artisan migrate
二、查看数据库表 三、模型文件 1）用户模型中定义的三个属性 $casts（指定数据库字段使用的数据类型）
$fillable（过滤用户提交的字段，只有包含在该属性中的字段才能够被正常更新。避免『批量赋值』的错误）
$hidden（用户密码或其它敏感信息在用户实例通过数组或 JSON 显示时进行隐藏） 2）创建文章模型（Article）为例 &gt;&gt;&gt;只创建模型（模型类名称使用 单数 形式来命名） php artisan make:model Article
//删除模型
rm app/Models/Article.php
&gt;&gt;&gt;创建模型的同时创建数据迁移 php artisan make:model Article -m
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d20c8a3a86f71e60c9a5f63e6864841/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/009f60ada82cba14512e21bca0d61a40/" rel="bookmark">
			解决列表和元组多索引bug问题(TypeError: list indices must be integers or slices, not tuple)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在对列表和元组进行索引的时候，发现使用多维索引会出现以下bug: TypeError: list indices must be integers or slices, not tuple
TypeError: tuple indices must be integers or slices, not tuple
list: list1 = [[1,2,3], [4,5,6]] m1 = list1[1,0] tuple: tuple1 = ((1,2,3), (4,5,6)) m2 = tuple1[0, 1] 问题原因:这是因为我们经常使用numpy库和torch库，里面的tensor类型和np类型是支持多索引的，而list和tuple不支持。因为list和tuple支持不同类型的数据同存，而numpy是不支持的，所以numpy可以进行多索引。例子如下: 我们使用list来查看里面数据的类型:
list1 = [[1,2,3], ["test",5,6]] print (type(list1[1][0])) print (type(list1[0][0])) 可以看到list可以存储多种不同数据类型的数据。
我们使用numpy来进行测试:
import numpy as np np1 = np.array( [[1,2,3], ["test",5,6]]) print (type(np1[1][0])) print (type(np1[0][0])) 可以看到输出结果如下:
我们可以看到，numpy在创建数组时，会自动的把数据类型统一，方便进行批量处理，即可以使用多索引。tensor也是同理
结论: 1.列表(List)和元组(Tuple)是内置的数据结构，可以包含不同类型的元素，并且长度可以动态改变，主要目的是提供灵活性和易用性。所以不支持多个索引
2.numpy是为了高校的数值计算而设计的，是一个固定大小和同质的多维数组。所以支持多个索引，方便数值计算
4.如果想要使用多个索引，可以把list转换为numpy来进行处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/009f60ada82cba14512e21bca0d61a40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/943ceedef2a99c745c5042430867d2f7/" rel="bookmark">
			react：ffcreator中FFCreatorCenter视频队例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目要求，一键生成房子的推荐视频，选几张图，加上联系人的方式就是一个简单的视频，因为有web端、小程序端，为了多端口用，决定放在服务器端生成。
目前用的是react中的nextjs来开发项目。
nextjs中怎样用ffcreator上一章有讲到过，这里不再详细说了，考虑多端口用，并发和处理视频合成等一系列对服务器压力过大的情况，这时候队列就有必要了。
一通了解后FFCreatorCenter能实现队列。官方有koa实现队列的例子。看过后怎样在nextjs中实现？
找准思路：
1.制作预设视频动画模板，意思是合成视频的模板提前预设好的，比如静态内容都提前准备好
2.用户选择想要的视频模板，然后根据视频模板添加动态内容，排队生成视频
3.查询视频生成情况
按照上述流程，我们开干：
1。制作预设视频模板，做一个模板比如相册视频，放到模板详情接口中调用AddTPL(id)
import { FFAlbum, FFScene, FFImage, FFCreator, FFRect, FFText, FFCreatorCenter } from 'ffcreator' const path = require('path'); import colors from 'colors' export default function AddTPL({ id }) { FFCreatorCenter.createTemplate(id, async ({ }) =&gt; { //用官方图片例子 const ROOT_PATH = process.cwd(); const bg1 = path.join(ROOT_PATH, '/assets/imgs/bg/05.jpg'); console.log(bg1) const bg2 = path.join(ROOT_PATH, '/assets/imgs/bg/04.jpeg'); const logo2 = path.join(ROOT_PATH, '/assets/imgs/logo/logo2.png'); const cloud = path.join(ROOT_PATH, '/assets/imgs/cloud.png'); const mars = path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/943ceedef2a99c745c5042430867d2f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d329cc2861d2a12b858751a8e864d08e/" rel="bookmark">
			【大数据】Zookeeper 集群及其选举机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zookeeper 集群及其选举机制 1.安装 Zookeeper 集群2.如何选取 Leader 1.安装 Zookeeper 集群 我们之前说了，Zookeeper 集群是由一个领导者（Leader）和多个追随者（Follower）组成，但这个领导者是怎么选出来的呢？我们貌似没有在配置文件中看到有关领导者和追随者的参数啊？
在此之前先来看看 Zookeeper 内部的一些机制：
半数机制：只要有半数以上的节点存活，则集群可用，所以 Zookeeper 集群的节点数量适合为奇数。虽然在配置文件中没有指定领导者和追随者，但 Zookeeper 在工作时，有一个节点为 Leader，其它则为 Follower，而 Leader 是通过内部的选举机制临时产生的。 那么领导者到底是怎么选出来的呢？很简单，每台服务器都有一个 id（这里的 id 后面说），当启动的服务器超过半数的时候，就会选择 id 最大的 Server 成为领导者。比如有五台服务器，半数就是 2.5 2.5 2.5，因此当启动三台的时候就可以选出领导者。至于剩余的两台，启动之后只能成为追随者，因为领导者已经选出来了。关于这里的细节，一会儿再详细聊。
那么怎么指定服务器的 id 呢？还记得配置文件中的 dataDir 参数吗，在该参数指定的目录下创建一个 myid 文件（文件必须叫这个名字），然后在里面写上服务器的 id 即可。
[root@satori zkData]# echo 2 &gt; myid 这里给 id 设置为 2，因为一会要搭建由三个节点组成的集群，而我希望当前节点成为 Leader，所以它的 id 应该为 2，其它的两个节点的 id 显然分别为 1 和 3。这样按着 id 从小到大的顺序启动时，该节点就会成为 Leader。
下面来我们来搭建 zookeeper 集群，总共三个节点：
IP：82.157.146.194，主机名：satoriIP：121.37.165.252，主机名：koishiIP：123.60.7.226，主机名：marisa satori 节点就是当前一直在用的节点，剩余的两个节点的 Zookeeper 也已经安装完毕。那么问题来了，我们要如何将这三个节点组成一个集群呢？显然还需要修改配置文件，先在 satori 节点进行修改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d329cc2861d2a12b858751a8e864d08e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ebc9e69195d5d16254d631a2841e8ed/" rel="bookmark">
			【大数据】分布式协调系统 Zookeeper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式协调系统 Zookeeper 1.Zookeeper 的特点2.Zookeeper 的数据结构3.Zookeeper 的应用场景3.1 统一命名服务3.2 统一配置管理3.3 统一集群管理3.4 服务器动态上下线3.5 软负载均衡 Zookeeper 是 Apache 开源的一个顶级项目，目的是为分布式应用提供协调服务，当然 Zookeeper 本身也是分布式的。
而从设计模式的角度来理解：Zookeeper 是一个基于观察者模式设计的 分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接收观察者的注册。一旦数据的状态发生变化，Zookeeper 就会通知那些已经注册的观察者，以便它们能够及时做出反应。
所以 Zookeeper 可以看作是一个 文件系统 + 通知机制。文件系统指的是 Zookeeper 可以存储数据，尽管数据量比较少，但还是像文件一样可以存储的；而通知机制指的是当数据有变化，会立即通知观察者。
1.Zookeeper 的特点 那么 Zookeeper 都有哪些特点呢？
1️⃣ Zookeeper 本身也是分布式的，可以组成集群。Zookeeper 集群由一个领导者节点（Leader）和多个追随者节点（Follower）组成，Leader 负责接收写请求，Follower 负责和 Leader 之间进行数据同步并接收读请求。2️⃣ 集群中只要有半数以上的节点存活，Zookeeper 集群就能正常服务，所以集群内部的节点数量最好是奇数个。3️⃣ Zookeeper 是 CP 模型，在一致性（Consistency）和可用性（Availability）之间选择了一致性，因此集群里面的数据是全局一致的，每个 Server 都保存了一份相同的数据副本。客户端无论连接到哪一个 Server，数据都是一致的。这也意味着 Leader 只有将新数据同步给所有的 Follower 之后，整个 Zookeeper 集群才能对外提供服务，否则客户端就有可能读到旧数据。因为根据 CAP 理论，在保证 P（Partition tolerance）的前提下，C 和 A 是不可兼顾的，至于选择哪一个则看是否对数据有强一致性的要求。而 Zookeeper 存储的数据一般都不大，所以选择了一致性。4️⃣ 写请求顺序进行，来自同一个 Client 的写请求按其发送顺序依次执行。5️⃣ 实时性，Client 可以很快地读到最新数据。虽然 Leader 和 Follower 之间的数据同步需要一定时间，但 Zookeeper 保存的数据量很小，因此同步速度非常快。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ebc9e69195d5d16254d631a2841e8ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e27f62b984d6f42ccb1d6533af424a04/" rel="bookmark">
			从C向C&#43;&#43;3——类和对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.前言 ​ 类和对象是 C++的重要特性，它们使得 C++ 成为面向对象的编程语言，可以用来开发中大型项目，本节重点讲解类和对象的语法。
​ 类是创建对象的模板，一个类可以创建多个对象，每个对象都是类类型的一个变量；创建对象的过程也叫类的实例化。每个对象都是类的一个具体实例，拥有类的成员变量和成员函数。
有些教程将类的成员变量称为类的属性（Property），将类的成员函数称为类的方法（Method）。在面向对象的编程语言中，经常把函数（Function）称为方法（Method）。
​ 与结构体一样，类只是一种复杂数据类型的声明，不占用内存空间。而对象是类这种数据类型的一个变量，或者说是通过类这种数据类型创建出来的一份实实在在的数据，所以占用内存空间。
二.定义 1.最简单的类 ​ 类是用户自定义的类型，如果程序中要用到类，必须提前说明，或者使用已存在的类（别人写好的类、标准库中的类等），C++语法本身并不提供现成的类的名称、结构和内容。
​ 在此之前我们或多或少的接触过这些方面的知识，直接看一个例子：
class Student{ public: //成员变量 char *name; int age; float score; //成员函数 void say(){ cout&lt;&lt;name&lt;&lt;"的年龄是"&lt;&lt;age&lt;&lt;"，成绩是"&lt;&lt;score&lt;&lt;endl; } }; ​ class是 C++ 中新增的关键字，专门用来定义类。Student是类的名称；类名的首字母一般大写，以和其他的标识符区分开。{ }内部是类所包含的成员变量和成员函数，它们统称为类的成员（Member）；由{ }包围起来的部分有时也称为类体，和函数体的概念类似。public也是 C++ 的新增关键字，它只能用在类的定义中，表示类的成员变量或成员函数具有“公开”的访问权限，这个到后面类的继承中在细说。
注意在类定义的最后有一个分号;，它是类定义的一部分，表示类定义结束了，不能省略。
​ 整体上讲，上面的代码创建了一个 Student 类，它包含了 3 个成员变量和 1 个成员函数。
​ 类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。
2.创建对象 有了 Student 类后，就可以通过它来创建对象了，例如：
Student xqs; //创建对象 Student是类名，xqs是对象名。
在创建对象时，class 关键字可要可不要，但是出于习惯我们通常会省略掉 class 关键字：
class Student xqs; //正确 Student xqs; //同样正确 除了创建单个对象，还可以创建对象数组：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e27f62b984d6f42ccb1d6533af424a04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad482c07b64575d7317bde707a015263/" rel="bookmark">
			学习Redis缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 学习Redis缓存 NoSQL和SQL的区别缓存缓存作用缓存成本添加Redis缓存 Redis特征Redis中数据结构Redis通用命令String类型Key的层级格式Hash类型Redis的Java客户端 NoSQL和SQL的区别 缓存 缓存就是数据交换的缓冲区，是存储数据的临时地方，一般读写性比较高。
缓存作用 降低后端负载
提高读写效率，降低响应时间
缓存成本 数据一致性成本
代码维护成本
运维成本
添加Redis缓存 Redis 是一个基于内存的键值型NoSQL数据库。
特征 Redis中数据结构 Redis通用命令 String类型 Key的层级格式 Hash类型 Redis的Java客户端 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/027435f4c90849bc17b31db88346911f/" rel="bookmark">
			c/c&#43;&#43;基础 自增自减运算符 大白讲解i&#43;&#43;/i--/&#43;&#43;i/--i
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后置运算符：i++表示在使用x之后，再使x的值加1，即i=i+1;
前置运算符：++i表示在使用x之前，先使x的值加1，即i=i+1.
前缀运算和后缀运算的区别：前缀运算是“先变后用”，而后缀运算是“先用后变”
i++和++i 这样看结果是一样的，还是没有区别，原因在于，x两次都是对自身使用了x，但实际当有其他变量、一个表达式内有其他运算时，情况就可能不太一样了。（以下详说）
一般实际使用时，在如此的单个i变量的for循环里使用两种自加都没有区别：
以上的举例都是i++和++i使用的结果相同的例子，可以看出：i都是自己使用自己，所以看不出二者有什么差别。
后置运算符：i++表示在使用x之后，再使x的值加1，即i=i+1;
前置运算符：++i表示在使用x之前，先使x的值加1，即i=i+1.
也就是说，他们一个是先用再+1，一个是先+1再用
这就像一盘菜的两个原料一样。“花生油炒西红柿”
如果不炒，只是将花生油和西红柿掺起来，那么，无论是先把西红柿放在碗里再放花生油还是先把花生油放到锅里再放西红柿，结果都是一样的：生西红柿泡在了生花生油里。
但是，如果再使用一个锅来炒它们。那么，先放西红柿还是先放花生油就会产生不一样的菜的味道。
在代码中，这个“锅”是什么呢？是a。
a=i++是先将i=1的值赋值给a，然后i=i+1，最后a的结果是1
a=++i是先i=i+1,此时，i=2,然后把i的值赋值给a，最后a是2
i--和--i i--和--i与i++和++i是类似的情况，可参照前文进行理解
贪吃法则 ++与- -是连体操作符： 如果分开写，则成两个独立的+或-了，所以中间不能有空格。如果有多于两个的+或-连写，则编译器按”贪吃法则“理解。所谓贪吃，是指只要能理解能成为操作符，就尽量多读入字符。
在C和C++语言中，++ 和 -- 操作符被称为自增和自减操作符。这些操作符在语法上是不可以分割的，也就是说，它们是"连体"的，中间不能有空格。
例如，如果你尝试写下这样的代码：
int x = 5; int y = ++ 5; // 错误！不能这样写 编译器会报错，因为 ++ 和数字 5 被视为两个独立的符号，而不是一个合法的自增操作。
另外，您提到的"贪吃法则"也确实适用于C/C++语言。这是一种编译器在解析表达式时采取的策略，如果多个相同的运算符连在一起（比如两个或更多的 + 或 -），编译器会尝试尽可能多地将其解析为一个操作符。例如：
int z = + + - - 7; // 实际上是 (int) (+ (+ (-7)))，结果为-7 在这个例子中，尽管有三个 + 和两个 -，但编译器将它们解析为两个 + 和两个 -，而不是四个独立的符号。这是因为 + + - - 在语法上是合法的，表示先对一个负数进行两次自增操作（使其变为正数），然后再进行两次自减操作（使其变为负数）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/027435f4c90849bc17b31db88346911f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f78ecf00f1ec9b211118f5aec7aa1e5/" rel="bookmark">
			【Java EE初阶九】多线程进阶一（锁策略）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 锁的策略：加锁过程中，即处理冲突的过程中，需要涉及到的一些不同的处理方式（此处锁策略并不是java独有的），本篇内容主要是讲解一下关于锁的相关知识点；
1. 关于锁的分组 1.1 第一组：乐观锁和悲观锁 ------&gt;这是两种不同的锁的实现方式
乐观锁：在加锁之前，预估当前出现锁冲突的概率不大，因此在进行加锁的时候不会做太多的工作。加锁过程中做的事情比较少，加锁的速度可能更快，但是更容易引入一些其他的问题（即可能会消耗更多的cpu资源）
悲观锁：在加锁之前，预估当前出现锁冲突的概率比较大，因此在进行加锁的时候会做更多的工作，因为做的事情更多，所以加锁的速度回更慢，但是整个过程中不容易出现其他的问题。
1.2 第二组：轻量级锁和重量级锁 轻量级锁，加锁的开销更小，加锁的速度更快---&gt;轻量级锁，一般都是乐观锁
重量级锁，加锁的开销更大，加锁的速度更慢---&gt;轻量级锁，一般都是悲观锁
轻量重量是加锁之后对结果的评价，悲观乐观，是加锁之前，对未来的事情进行的预估,根据整体来说，这两种角度，描述的都是同一个事情；
1.3 第三组：自旋锁和挂起等待锁 自旋锁：是轻量级锁的一种典型实现；加锁的时候，如果加锁失败，不会就此阻塞放弃cpu，而是相当于添加一个while循环，不停的进行锁竞争，这次锁竞争失败了就再次进入循环竞争锁，直到加锁成功，才退出循环。
这种反复快速的执行，就称为 “自旋”，故此自旋锁也是乐观锁，使用自旋锁的前提是预期锁冲突概率不大，只要其他线程释放了锁，它就能第一时间加锁成功；但如果有很多线程要加锁，就必要使用自旋锁了，因为会浪费cpu资源。
等待挂起锁：是重量级锁的一种典型体现，也是悲观锁；加锁的时候，如果加锁失败，就会等待一段时间，这段时间它不会去进行加锁操作和别的线程锁竞争，故此就能把一些cpu资源让出来，被让出来的这些cpu资源可以干一些其他事情，等一段时间过后，会再次尝试加锁，如果失败还是重复以上工作，直到最后成功拿到锁；
当等待挂起的时候，会有内核调度器介入，所以就需要完成的操作就多了，从而要获取锁的时间花费也更多一些。
Q：java中的synchronized算以上锁的哪种情况？
A：synchronized具有自适应能力，且synchronized在某些情况下是乐观锁，轻量级锁，自旋锁；但是在某些情况下时悲观锁，重量级锁，等待挂起锁，当然系统内部会自动的评估当前锁冲突的激烈程度；
如果当前锁冲突的激烈程度不大，就处于乐观锁\轻量级锁\自旋锁；
如果当前锁冲突的激烈程度很大，就处悲观锁锁\重量级锁\等待挂起锁；
1.4 第四组： 普通互斥锁和读写锁 普通互斥锁：类似synchronized这种，操作涉及到加锁、解锁
读写锁：这里加锁的情况分为两种：加读锁，加写锁
读锁和读锁之间，不会出现锁冲突（不会阻塞）；写锁和写锁之间，会涉出现锁冲突（会阻塞）；读锁和写锁之间，会出现锁冲突（会阻塞）；当一个线程加读锁时，另一个线程只能读，不能写；当一个线程加写锁时，另一个线程不能写，也不能读
Q:为啥要引入读写锁？
A: 如果两个线程读，本身就是线程安全的，不需要进行互斥；
如果使用synchronized这种方式加锁，两个线程读与会产生互斥（阻塞），对于性能有一定的损耗，完全给读操作不加锁，就怕连个线程一个是读线程，一个是写线程，这样更加会涉及锁冲突；如上所述，读写锁能很好地解决上述的问题
java标准库中，也提供了专门的类，来实现读写锁（读写锁本质上还是系统提供的读写锁，系统提供api，jvm中将api进行封装给我们使用），注意synchornized不是读写锁；
1.5 第五组：公平锁和非公平锁 此处的公平即遵循先来后到的规则才是公平；
公平锁：如果线程和线程之间，锁竞争的时间大小不一样，按照锁竞争时间久的线程先拿到锁，有先后顺序（先来后到的意思）
非公平锁：线程和线程之间没有拿锁顺序，随机调度，各凭各的本事拿锁。
这里使用公平锁，就能很好的解决线程饿死的这一问题。而要想实现公平锁，就需要引入额外的数据结构（引入队列，记录每个线程的先后顺序），才能实现公平锁。
1.6 第六组：可重入锁和不可重入锁 可重入锁：如synchronized，加锁一段代码，锁里面可以再进行一次加锁，锁里面可以嵌套多个锁，里面是用计数器这种方式对加锁的数量进行计数，并判断是否解锁，是可重入锁。
不可重入锁：系统自带的锁，不能连续加锁两次。
1.7 synchronized和Linux基于特定锁的简单比较 下面来说明一下synchronized和系统自带的锁的具体锁；
synchronized：乐观锁 / 悲观锁自适应
轻量级锁 / 重量级锁自适应
自旋锁 / 挂起等待所自适应
不是读写锁
非公平锁
可重入锁
linux提供的mutex（系统自带的锁）： 悲观锁
重量级锁
挂起等待所
不是读写锁
非公平锁
不可重入锁
2. 细说synchronized的自适应 Synchronized的加锁过程，自适应如下所述：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f78ecf00f1ec9b211118f5aec7aa1e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77cb3d3434c2ed479193c81ee8fc1310/" rel="bookmark">
			2024年阿里云优惠活动清单_优惠代金券领取大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云服务器优惠活动大全包括：云服务器新人特惠、云小站、阿里云免费中心、学生主机优惠、云服务器精选特惠、阿里云领券中心等，活动上阿里云服务器ECS经济型e实例2核2G、3M固定带宽99元一年、轻量应用服务器2核2G3M带宽轻量服务器一年61元，2核4G4M带宽轻量服务器一年165元12个月；ECS云服务器e系列2核2G配置99元一年、2核4G服务器30元3个月、2核4G配置365元一年、2核8G配置522元一年；阿里云u1服务器2核4G、2核8G、4核8G、8核16G、4核16G、8核64等配置新人3折优惠，阿里云服务器网aliyunfuwuqi.com分享2024年阿里云服务器优惠活动汇总大全：
2024阿里云服务器优惠活动中心
更新时间：2024年1月2日，阿里云轻量应用服务器2核2G3M带宽又降价了，之前是87元一年，现在是61元一年。另外，目前阿里云99元服务器爆款特惠，云服务器ECS经济型e实例、2核2G配置、3M固定带宽和40G ESSD Entry系统盘，新老用户均可购买，老用户也能买，并且续费不涨价，续费不涨价，原价99元即可续费一年，最长可以续费到2027年。
阿里云活动 https://t.aliyun.com/U/bLynLC
阿里云服务器优惠活动大全 以上是阿里云百科分享的阿里云服务器优惠活动大全，涉及云服务器包括ECS云服务器、轻量应用服务器、GPU服务器、FPGA服务器、弹性裸金属服务器、云虚拟主机、专有宿主机等，时间点不同当前活动也不同，例如：阿里云开年采购季、阿里云618优惠活动、年中大促、阿里云双十一、阿里云双12及阿里云年终大促等：
99元服务器活动：aliyunfuwuqi.com/go/99云小站：https://t.aliyun.com/U/bLynLC阿里云CLUB领券中心：aliyun.club免费试用：aliyunfuwuqi.com/go/free学生服务器：aliyunfuwuqi.com/go/student云服务器精选特惠：aliyunfuwuqi.com/go/activity_selection爆款特惠：aliyunfuwuqi.com/go/bestoffer活动大全：aliyunfuwuqi.com/go/activity 以上是阿里云服务器网aliyunfuwuqi.com分享的阿里云服务器优惠活动大全，包括不同云服务器的优惠活动汇总。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6af40579c438d69249e3f66ea25b6ab/" rel="bookmark">
			Jenkins修改全局maven配置后不生效解决办法、以及任务读取不同的settings.xml文件配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、修改Global Tool Configuration的maven配置不生效 说明：搭建好jenkins后，修改了全局的settings.xml，导致读取settings一直是之前配置的。
解决办法一 Jenkins在创建工作任务时，会读取当前配置文件内容，固定在这个任务上。
任务创建之后，修改全局配置文件，是无法影响到之前的工作任务。
所以需要重新创建任务即可解决。
解决办法二(推荐) 点开 Advanced,然后设置Settings file,然后选择项目需要依赖的settings.xml文件即可
二、针对不同项目使用不同的settings.xml文件配置 说明：在jenkins中，有可能不同的视图下的任务使用的settings.xml都不一样，此处配置了全局的settings.xml就没法实现，此处jenkins给大家提供了配置，具体步骤如下
1、创建项目
2、在项目的build中，使用解决办法二
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e553bec1bc2fe77ffb86f88afe27f88/" rel="bookmark">
			大翻车！斯坦福超火机器人自曝内幕，研究者救场还受伤了，网友：放心了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		金磊 丰色 发自 凹非寺
量子位 | 公众号 QbitAI 爆火的斯坦福全能家务机器人Mobile ALOHA，大！翻！！车！！！
你以为它擦个红酒轻而易举，但实际上却是这样的：
全给你弄撒喽，顺带碎个杯子……
你以为它能化身大厨娴熟烹炒，结果给你上演一个炒锅底：
Mobile ALOHA的翻车大合集还不止这些。
例如刚才炒完虾的锅，哎呦喂，一不小心没拿住：
即使小哥一个箭步冲上去也没阻止“悲剧”的发生（好像还烫到手了）。
这画面，真是像极了庄嫂摔碗……
昨天还在“神坛”上的Mobile ALOHA，一夜之间便被曝出了这么多“笨手笨脚”的样子，也是引来不少网友的围观。
然而，这次即使面对翻车铁证，网友们的画风却是一反常态：
它并不完美，不过很可爱。
总会有犯错的余地。
最重要的是：
放心了。（手动狗头）
这到底是怎么回事？
斯坦福团队自曝“丑闻” 原来，这段机器人大翻车的视频，就是由斯坦福Mobile ALOHA的作者Tony Z. Zhao发布的。
并且他还直言不讳地说道：
机器人还没有做好准备接管这个世界。
而这段翻车视频，正是机器人完全在自主模式下所犯的。
用作者的话来形容，就是“最愚蠢的错误”。
毕竟除了刚才我们展示的几个例子之外，Mobile ALOHA甚至连锅都放不进橱柜里：
炒完的虾粘锅倒不出来不说，连碗的位置也找不到：
拿支笔也没法找对位置下手：
面对失败合集，作者却是打趣道：
这是我目前为止最喜欢的视频了，（不过）当机器人在你面前犯错的时候，你就不会觉得那么有趣了。
确实，毕竟手都被烫了……
不过作者今天自曝这段视频其实应该还有另外一个原因。
因为前两天Mobile ALOHA神级现场的视频确实引来了不小的关注度，不过很多人误以为这是它在自主模式下完成的。
但其实，Mobile ALOHA采用的是混合模式，并非完全自主，作者也呼吁网友们在吃瓜的同时认真看下论文和代码。
值得一提的是，作者还引用了2015年波士顿动力Atlas人形机器人“翻车合集”并向它致敬。
或许这也正如英伟达科学家Jim Fan说的那样：
一步一个脚印。
学习50次，成功率能到90% 就在这两天，Mobile ALOHA团队连续放出三个爆火视频，展示了该机器人敏捷灵巧的家务能力，看呆网友。
包括做满汉全席（磕鸡蛋、给鸡肉翻面这种细活都信手拈来）：
套枕套铺床单：
浇花、拖地板、开瓶盖，甚至逗猫猫：
那叫一个人模人样，上得厅堂下得厨房。
不过，大部分都是真人操控的，比如上面这些。
更直观的可以看下面这个抽纸擦玻璃的动图，背后直接站了个人类1:1示范：
不过，对于一些相对简单的任务，例如这个单炒虾仁：
还有刷锅、将餐椅归位、呼叫并乘坐电梯、擦桌子等等，只需真人少量示教，它就可以学会，然后脱离人类进行自主操作。
具体而言，作者介绍，上面这些简单动作目前只需要学习50次就可以做到90%的成功率——
经测试，Mobile ALOHA可以连续9次擦干倒洒了的酒、连续呼叫5次电梯都不会出错，能够保持一定的稳定性。
除此之外，它还能抗干扰，在完成归置锅具到柜子之中时，实验人员不停向它面前投掷杂物，都完全没有影响它发挥：
在训练期间根本看不见的椅子？它也能准确识别并完成归位任务。
那么，作者是如何仅通过50个演示就让Mobile ALOHA实现自主任务的呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e553bec1bc2fe77ffb86f88afe27f88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8be9abf09074b5af97c8ab0c1a042c47/" rel="bookmark">
			单片机项目分享 stm32实现车牌识别系统 -物联网 嵌入式 单片机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 简介2 主要器件3 实现效果4 设计原理4.1 **软件总体过程：**4.2 具体解释 5 部分核心代码6 最后 0 前言 🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的毕设题目缺少创新和亮点，往往达不到毕业答辩的要求，这两年不断有学弟学妹告诉学长自己做的项目系统达不到老师的要求。
为了大家能够顺利以及最少的精力通过毕设，学长分享优质毕业设计项目，今天要分享的是
🚩 基于stm32的实现车牌识别系统
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：4分工作量：4分创新点：3分 1 简介 本系统利用STM32单片机驱动摄像头采集图像，通过模式识别，匹配车牌的识别结果，并在屏幕上显示。
2 主要器件 STM32F103RCT6 主控芯片TFT液晶屏OV7670摄像头蜂鸣器LED电路 3 实现效果 识别效果
摄像头模块
4 设计原理 4.1 软件总体过程： （1）OV7670带FIFO摄像头图像采集，采用GPIO模拟摄像头时序，通过读取FIFO输出值将图像直接显示在LCD屏上
（2）LCD屏相当于一个图像缓存，同时也做显示，通过读取LCD屏上的像素值进行图像处理；
（3）车牌定位处理，车牌定位常用二值化分割，腐蚀膨胀处理，连通域计算等操作，显然这些算法在stm32f1上实现是很困难的，且处理速度太慢，因此，采用RGB转HSV颜色空间变换和阈值选择进行车牌定位，然后将车牌定位区域进行二值化处理，不是蓝色车牌的部分就是字符区域；
（4）车牌字符分割处理，字符分割先采用行统计加列统计的方式，确定每行和每列的有效像素和，进一步确定字符区域；然后进行横向统计分割，通过每一列的像素和阈值判断字符的分界线和个数；
（5）车牌归一化处理，归一化处理先将每个字符提取出来，然后按照像素值进行横向和纵向压缩，最终处理成模板一样大小的字符；并在液晶屏上保存字符的数据；
（6）模板匹配，将归一化之后的字符，与模板中的字符通过像素值一一比较，确定相似度最高的字符就是目标值；
4.2 具体解释 图像采集
通过OV7670摄像头进行图像采集，采集的图像大小为320*240像素，像素格式为RGB565。每个像素由两字节组成，第一字节的高五位是Red，第一字节的低三位和第二字节的高三位组成Green，第二字节的低五位是Blue。
二值化
二值化就是让图像的像素点矩阵中的每个像素点的灰度值为0（黑色）或者255（白色），让整个图片呈现出只有黑色和白色的效果。二值化后的图像中灰度值范围是0或者255。这时需要设定一个阈值来对像素点进行设置。
常用二值化方法：
取中值：设置阈值为127，灰度值小于127的为0，大于127的为255。这样设置计算量小，计算快。缺点也严重：在不同的图像中，颜色分布差别大，处理效果也不会很好。程序开始之前设置R,G，B的阈值，通过阈值判断将像素设置为全黑（0x0000）或者全白（0xFFFF）.同时根据色彩的变化记录每一行的颜色跳变点，由此识别出车牌区域。取平均值：像素点平均值 = （像素点1灰度值 + 像素点2灰度值 + …… + 像素点n灰度值） / n双峰法：此方法适用于具有明显双峰直方图的图像，不适合直方图中双峰差别很大或双峰间的谷比较宽广而平坦的图像。该方法认为图像由前景和背景组成，在灰度直方图上，前景和背景会形成高峰，在双峰之间的最低谷处就是阈值。 识别车牌区域
根据上一步的二值化，由于车牌区域跳变点多，由此可以得出车牌区域。分别记录车牌区域的上下高度。然后通过RGB-HSV颜色转换，识别出车牌区域的左右边界。
字符分割
我国常见车牌以及排列顺序大部分都是按照如下设计的：汉字、英文字母、点、英文字母、阿拉伯数字、阿拉伯数字、阿拉伯数字、阿拉伯数字。基于这个规律，以及图像采集高度一致，设计了如下的分割方法：
在内存中开辟七个长为车牌长的七分之一和宽为车牌宽的区域从车牌图像长边的巾问向下开始扫描车牌图像，并把扫描到的所有的点灰度值复制到0区域的第四个区域对应位置上。然后再从上向下扫描刚扫描过这一努的左边或右边，直到所扫描的这一峰上的所有点的灰度都是0时为止,并把这一竖认为是字符的分离处。切割第五到第七个字符。方法就是，切割完了第四个字符之后，再依次扫描剩下的空间，直到所扫描的这一竖上的所有点的灰度值不全为0时，认为是字符的开始并依次扫描直到所扫描的这一竖上的所有点的灰度值全为0时认为是字符的结束。切割第三到第四个字符。这两个字符的切割方式与第五到第七个字符一样。切割第一到第二个字符。当第三个字符切割完之后，我们将遇到一个点，我们也把它看作一个字符，只不过这个点扫描之后就不要了。扫描完这个点之后，我们来切割第二个字符，它的切割方式与前面一样。切割完了第二个字符之后，再向左扫描，直到所扫描的这一竖上的所有点的灰度值不全为0时，认为是字符的开始，并依次扫描直到所扫描所有剩下的，并填到相应的位置，直到剩下的空间填满。经过粗分割后，可以得到一些单个字符区域和多余的空间。下一步我们将把这些多余的空间去掉。这将更有利于下一步字符的识别。去除图像上多余空间：车牌上的字符经过了粗切割所得到的是一些单的字符，但在分配空间时是按照车牌的宽和长的七分之一来分配的；所以这个空间可能大于字符应该占的空问。所以，要将多余空间去除。对于第一个字符从第一行开始向下扫描，把那些一行中所有的点的灰度值全为0的点去掉，直到扫描到有一行不全为0时为止。然后再从第一列开始向右扫描把那些一列中所有的点的灰度值全为0的点去掉，直到扫描到有一列不全为0时为止。接下来从最后一行开始向上扫描，把那些一行中所有的点的灰度值全为0的点去掉，直到扫描到有一行不全为0时为止。最后从最后一列开始向左扫描把那些一列中所有的点的灰度值全为0的点去掉，直到扫描到有一列不全为0时为止。重复上面的步骤完成剩下字符的切割。根据二值化的结果，以及记录的跳变点位置，对字符进行分割，同时记录字符的左右边界。 字符匹配
对分割出来的字符进行归一化处理，这里用到图片的扩大算法，扩大之后逐一的去进行字符匹配。字符模板事前通过字模软件转换成二进制数据保存在数组中。最后根据匹配结果相似度最大的做为输出结果。
归一化图像就是要把原来各不相同的字符统一到同一尺寸。因为扫描进来的图像中字符大小存在较大的差异，而相对来说，统一尺寸的字符识别的标准性更强，准确率自然也更高。具体算法如下：先得到原来字符的高度和宽度，与系统已存字模的数据作比较，得出要变换的系数，然后根据得到的系数按照插值的方法映射到原图像中。
5 部分核心代码 #define COLOR_RGB565_TO_R8(pixel) \ ({ \ __typeof__ (pixel) __pixel = (pixel); \ __pixel = (__pixel &gt;&gt; 8) &amp; 0xF8; \ __pixel | (__pixel &gt;&gt; 5); \ }) #define COLOR_RGB565_TO_G8(pixel) \ ({ \ __typeof__ (pixel) __pixel = (pixel); \ __pixel = (__pixel &gt;&gt; 3) &amp; 0xFC; \ __pixel | (__pixel &gt;&gt; 6); \ }) #define COLOR_RGB565_TO_B8(pixel) \ ({ \ __typeof__ (pixel) __pixel = (pixel); \ __pixel = (__pixel &lt;&lt; 3) &amp; 0xF8; \ __pixel | (__pixel &gt;&gt; 5); \ })	int8_t imlib_rgb565_to_l(uint16_t pixel) { float r_lin = xyz_table[COLOR_RGB565_TO_R8(pixel)]; float g_lin = xyz_table[COLOR_RGB565_TO_G8(pixel)]; float b_lin = xyz_table[COLOR_RGB565_TO_B8(pixel)]; float y = ((r_lin * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8be9abf09074b5af97c8ab0c1a042c47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c36fc5a9ced0bde843dbd1a8687feca9/" rel="bookmark">
			利用注解和反射处理方法级别的逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 定义自定义注解 首先，我们定义一个自定义注解 MyAnnotation，用于标记需要特殊处理的方法。该注解具有一个 value 属性，表示方法的标识。
import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { String value(); } 2. 编写注解处理器 接下来，我们编写一个注解处理器 AnnotationProcessor，负责处理包含 MyAnnotation 注解的方法。该处理器通过反射查找带有注解的方法，并执行与注解值相关的逻辑。
import com.lfsun.annotation.annotations.MyAnnotation; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class AnnotationProcessor { public static void processAnnotations(Object obj, String methodName) { Class&lt;?&gt; clazz = obj.getClass(); for (Method method : clazz.getDeclaredMethods()) { if (method.isAnnotationPresent(MyAnnotation.class)) { MyAnnotation annotation = method.getAnnotation(MyAnnotation.class); String value = annotation.value(); // 根据注解值调用不同的业务方法 if (methodName.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c36fc5a9ced0bde843dbd1a8687feca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54a3204f287212574223776cc2e3ff0a/" rel="bookmark">
			Wargames与bash知识10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Wargames与bash知识10 Bandit Level 17 关卡提示： 主目录中有两个文件：passwords.old和passwords.new。下一级的密码在passwords.new中，是在password.old和password.new之间唯一被更改的行
注意：如果你已经解决了这个级别，请参阅“再见！”当尝试登录bandit18时，这与下一个级别bandit19有关。
推荐命令： cat, grep, ls, diff
转载自：读懂diff - 阮一峰的网络日志 (ruanyifeng.com)
读懂diff 作者： 阮一峰
diff是Unix系统的一个很重要的工具程序。
它用来比较两个文本文件的差异，是代码版本管理的基石之一。你在命令行下，输入：
$ diff &lt;变动前的文件&gt; &lt;变动后的文件&gt;
diff就会告诉你，这两个文件有何差异。它的显示结果不太好懂，下面我就来说明，如何读懂diff。
一、diff的三种格式
由于历史原因，diff有三种格式：
* 正常格式（normal diff）
* 上下文格式（context diff）
* 合并格式（unified diff）
我们依次来看。
二、示例文件
为了便于讲解，先新建两个示例文件。
第一个文件叫做f1，内容是每行一个a，一共7行。
a
a
a
a
a
a
a
第二个文件叫做f2，修改f1而成，第4行变成b，其他不变。
a
a
a
b
a
a
a
三、正常格式的diff
现在对f1和f2进行比较：
$ diff f1 f2
这时，diff就会显示正常格式的结果：
4c4
&lt; a
—
&gt; b
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54a3204f287212574223776cc2e3ff0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23d61303e805d869680274958698d406/" rel="bookmark">
			深入理解JVM虚拟机--3.3垃圾收集算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解JVM虚拟机--3.3垃圾收集算法
1 标记-清除算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。
它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
2 复制算法，将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。这种算法的代价是将内存缩小为了原来的一半。现在的商业虚拟机都采用这种收集算法来回收新生代。
所以并不需要按照1∶1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[插图]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。
HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。
3 标记-整理算法，复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。
根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
4 分代收集算法，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e56296c7e1a97ef94156962a798f26d8/" rel="bookmark">
			直接解决Incorrect string value: ‘\xB9\xDC\xC0\xED\xD4\xB1‘ for column ‘user_permission‘ at row 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个方法鉴于你有Navicat
1、连接上你的数据库，绿色表示连接上
2、将鼠标移至你想要修改的表上，右键后选择设计表
3、点击字符集，选择utf-8（最好所有字段的字符集改成通一的utf8）
4、选择保存
然后就可以进行插入了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84937805a8605c5978a9bce54ae43b1e/" rel="bookmark">
			[Redis] Redisson实现分布式锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现分布式锁的方式有多种，例如基于数据库、Redis、ZooKeeper 等中间件来实现，它们通常依赖于这些中间件提供的事务特性，或者命令语义来达到分布式环境下的锁效果。例如，Redis 通过 SETNX 命令配合过期时间可实现一个简单的分布式锁方案。
文章目录 1.SETNX 存在的问题2.Redisson 特性说明3.Redisson 使用分布式锁 1.SETNX 存在的问题 虽然可以使用 SETNX 命令方便的实现分布式锁，但是 SETNX 存在以下问题：
死锁问题：SETNX 如未设置过期时间，锁忘记删了或加锁线程宕机都会导致死锁，也就是分布式锁一直被占用的情况。锁误删问题：SETNX 设置了超时时间，但因为执行时间太长，所以在超时时间之内锁已经被自动释放了，但线程不知道，因此在线程执行结束之后，会把其他线程的锁误删的问题。不可重入问题：也就是说同一线程在已经获取了某个锁的情况下，如果再次请求获取该锁，则请求会失败（因为只有在第一次能加锁成功）。也就是说，一个线程不能对自己已持有的锁进行重复锁定。无法自动续期：线程在持有锁期间，任务未能执行完成，锁可能会因为超时而自动释放。SETNX 无法自动根据任务的执行情况，设置新的超时实现，以延长锁的时间。 Redisson 是一个开源的用于操作 Redis 的 Java 框架。与 Jedis 和 Lettuce 等轻量级的 Redis 框架不同，它提供了更高级且功能丰富的 Redis 客户端。它提供了许多简化 Redis 操作的高级 API，并支持分布式对象、分布式锁、分布式集合等特性。
2.Redisson 特性说明 Redisson 可以设置分布式锁的过期时间，从而避免锁一直被占用而导致的死锁问题。Redisson 在为每个锁关联一个线程 ID 和重入次数（递增计数器）作为分布锁 value 的一部分存储在 Redis 中，这样就避免了锁误删和不可重入的问题。Redisson 还提供了自动续期的功能，通过定时任务（看门狗）定期延长锁的有效期，确保在业务未完成前，锁不会被其他线程获取。 3.Redisson 使用分布式锁 maven:
&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.25.2&lt;/version&gt; &lt;!-- 请根据实际情况使用最新版本 --&gt; &lt;/dependency&gt; Condig:
import org.redisson.Redisson; import org.redisson.api.RedissonClient; import org.redisson.config.Config; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84937805a8605c5978a9bce54ae43b1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7477beeb5c73cafc4c8ae202bfdc576/" rel="bookmark">
			【Python】Excel不同sheet另存为不同CSV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我有一个excel，内有不同sheet，现在批量生成不通csv文件，并以sheet名命名，或根据sheet名调整命名。
# 读取新的Excel文件 df = pd.read_excel(r'D:\itm\data.xlsx', sheet_name=None) # 遍历每个sheet，将其另存为不同的CSV文件 for sheet_name, data in df.items(): # 去掉sheet名中的前11位 new_sheet_name = sheet_name[11:] data.to_csv(fr'D:\itm\data_csv\{new_sheet_name}.csv', index=False, encoding='gbk', errors='replace') encoding='gbk’应该是避免excel有中文时出现乱码
errors='replace’貌似是防止首行错位
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/27/">«</a>
	<span class="pagination__item pagination__item--current">28/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/29/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>