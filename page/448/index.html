<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f09ec5a463606fc3ba3e40226cd0997/" rel="bookmark">
			姿态估计 - Human Pose Estimation Papers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 人体姿态估计 - Human Pose Estimation Papers 语义分割类的论文与代码汇总
逐渐迁移到搭建的博客上 - AIUAI - www.aiuai.cn
新地址: 姿态估计 - Human Pose Estimation Papers
Single Person Multi-Scale Structure-Aware Network for Human Pose Estimation - 2018 [Paper]Integral Human Pose Regression [Paper]Human Pose Regression by Combining Indirect Part Detection and Contextual Information - 2017 [Paper] [Code]Self adversarial training for human pose estimation - 2017 [Paper]Adversarial posenet: A structure-aware convolutional network for human pose estimation - 2017 [Paper]Learning Feature Pyramids for Human Pose Estimation - 2017 [Paper] [Code-Torch]Knowledge-Guided Deep Fractal Neural Networks for Human Pose Estimation - 2017 [Paper]Compositional human pose regression - 2017 [Paper]LCR-Net: Localization-Classification-Regression for Human Pose - 2017 [Paper] [Project]Multi-context attention for human pose estimation - 2017 [Paper] [Code-Torch7]Structured feature learning for pose estimation - 2016 [Paper] [Code-Caffe] [Project]Convolutional pose machines - 2016 [Paper] [Code-Caffe]Recurrent human pose estimation - 2016 [Paper]Human pose estimation via Convolutional Part Heatmap Regression - 2016 [Paper] [Code-Torch] [Project]Stacked Hourglass Networks for Human Pose Estimation - 2016 [Paper] [Code-Torch-train] [Code-Torch-demo] [Project]Chained Predictions Using Convolutional Neural Networks - 2016 [Paper]Human Pose Estimation Using Deep Consensus Voting - 2016 [Paper] [Code-Caffe] [Project]End-to-end learning of deformable mixture of parts and deep convolutional neural networks for human pose estimation - 2016 [Paper] [Code]Human Pose Estimation with Iterative Error Feedback - 2015 [Paper] [Code-Caffe] [Project]Combining local appearance and holistic view: Dual-source deep neural networks for human pose estimation - 2015 [Paper] [Code-Caffe] [Project]Flowing convnets for human pose estimation in videos - 2015 [Paper] [Code-Caffe] [Project]Learning Human Pose Estimation Features with Convolutional Networks - 2014 [Paper]Efficient Object Localization Using Convolutional Networks - 2014 [Paper]Multi-source deep learning for human pose estimation - 2014 [Paper]Heterogeneous Multi-task Learning for Human Pose Estimation with Deep CNN - 2014 [Paper]Human Pose Estimation and Activity Classification Using Convolutional Neural Networks - 2014 [Paper]Joint training of a convolutional network and a graphical model for human pose estimation - 2014 [Paper]Articulated pose estimation by a graphical model with image dependent pairwise relations - 2014 [Paper]Pose Machines- Articulated Pose Estimation via Inference Machines - 2014 [Paper] [Project]DeepPose: Human Pose Estimation via Deep Neural Networks - 2013 [Paper] Multi-Person Learning to Refine Human Pose Estimation - 2018 [Paper]Simple Baselines for Human Pose Estimation and Tracking - 2018-MSRA [Paper]Data Distillation: Towards Omni-Supervised Learning - 2017 - FAIR [Paper]Cascaded Pyramid Network for Multi-Person Pose Estimation - 2017 - Face++ [Paper] [Code-Tensorflow]Associative Embedding: End-to-End Learning for Joint Detection and Grouping [Paper] [Code-Tensorflow] [Code-PyTorch]ArtTrack: Articulated Multi-person Tracking in the Wild - 2017 [Paper] [Code-TensorFlow]An efficient convolutional network for human pose estimation - 2017 [Paper] [Code-Caffe] [Project] [PoseTrack Challenge]PoseTrack: Joint Multi-Person Pose Estimation and Tracking - 2017 [Paper] [Code-Caffe]Towards Accurate Multi-person Pose Estimation in the Wild - 2017 [Paper]Realtime Multi-Person 2D Pose Estimation using Part Affinity Fields - 2016 [Paper] [Code-Caffe] [Openpose] [Code-PyTorch] [Code-Chainer]RMPE: Regional Multi-person Pose Estimation - 2016 [Paper] [Code-Caffe]DeeperCut: A Deeper, Stronger, and Faster Multi-Person Pose Estimation Model - 2016 [Paper] [Code-Caffe] [Code-TensorFlow]DeepCut: Joint Subset Partition and Labeling for Multi Person Pose Estimation - 2015 [Paper] [Code-Caffe]Multi-Person Pose Estimation with Local Joint-to-Person Associations - 2016 [Paper] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/056bccf4558da78d5744658101f1ffcc/" rel="bookmark">
			mysql查询重复数据的语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select lender_id,sign_day from caiyun_v02_other.shop_user_sign_log group by lender_id,sign_day having count(*) &gt; 1 ;//重复2个字段的数据
select lender_id,sign_day from caiyun_v02_other.shop_user_sign_log group by lender_id,sign_day having count(*) &gt; 1 and lender_id=391446 limit 10; //查询具体一个人重复的次数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/423e0950282f8dab43c9f904cee35d50/" rel="bookmark">
			使用 Electron 从剪贴板复制和粘贴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 Electron 从剪贴板复制和粘贴 此系列文章的应用示例已发布于 GitHub: electron-api-demos-Zh_CN. 可以 Clone 或下载后运行查看. 欢迎 Star .
clipboard 模块提供了执行复制和粘贴操作的方法.
此模块还具有将文本作为标记（HTML）复制到剪贴板的方法.
在浏览器中查看 完整 API 文档.
复制 支持: Win, macOS, Linux | 进程: Both
在这个示例中, 我们将一个短语复制到剪贴板. 单击 "复制" 按钮后, 使用粘贴（CMD + V 或 CTRL + V）将短语粘贴到文本区域.
渲染器进程
const clipboard = require('electron').clipboard const copyBtn = document.getElementById('copy-to') const copyInput = document.getElementById('copy-to-input') copyBtn.addEventListener('click', function () { if (copyInput.value !== '') copyInput.value = '' copyInput.placeholder = '已复制! 请在这里执行粘贴.' clipboard.writeText('Electron 示例!') }) 粘贴 支持: Win, macOS, Linux | 进程: Both
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/423e0950282f8dab43c9f904cee35d50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/232798dfd9f2d6866023a701ca3b446b/" rel="bookmark">
			python opencv入门 SIFT算法（33）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容来自OpenCV-Python Tutorials 自己翻译整理
目标： 学习SIFT算法的概念 学习在图像中查找SIFT关键的和描述符
原理： （原理部分自己找了不少文章，内容中有不少自己理解和整理的东西，为了方便快速理解内容和能够快速理解原理，本文尽量不使用数学公式，仅仅使用文字来描述。本文中有很多引用别人文章的内容，仅供个人记录使用，若有错误，请指正出来，万分感谢）
参考文章：
参考文章1 参考文章2 参考文献3 参考文章4 参考文章5
之前的harris算法和Shi-Tomasi 算法，由于算法原理所致，具有旋转不变性，在目标图片发生旋转时依然能够获得相同的角点。但是如果对图像进行缩放以后，再使用之前的算法就会检测不出来，原理用一张图表示（图1）：
（harris算法和shi-tomasi算法都是基于窗口中像素分布和变化的原理，在图像放大且窗口大小不发生变化的时，窗口中的像素信息则会有很大的不同，造成无法检测的结果）
SIFT特性：
独特性，也就是特征点可分辨性高，类似指纹，适合在海量数据中匹配。多量性，提供的特征多。高速性，就是速度快。可扩展，能与其他特征向量联合使用。 SIFT特点：
旋转、缩放、平移不变性解决图像仿射变换，投影变换的关键的匹配光照影响小目标遮挡影响小噪声景物影响小 SIFT算法步骤：
尺度空间极值检测关键点定位关键点方向参数关键点描述符关键点匹配 尺度空间极值检测： 尺度空间的个人理解： 你找一张分辨率1024×1024图片，在电脑上观看，十分清晰，但是图片太大。现在把这图片反正photoshop上，将分辨率改成512×512,图片看着依然很清晰，但是不可能像1024×1024的画面那么精细，只不过是因为人眼构造的原因，512×512图片依然能让你分辨出这是个什么东西。
粗俗点说，尺度空间，就相当于一个图片需要获得多少分辨率的量级。如果把一个图片从原始分辨率到，不停的对其分辨率进行减少，然后将这些图片摞在一起，可以看成一个四棱锥的样式，这个东西就叫做图像金字塔（如下图，图2）。 再回到尺度空间，在摄像头中，计算机无法分辨一个景物的尺度信息。而人眼不同，除了人大脑里已经对物体有了基本的概念（例如正常人在十几米外看到苹果，和在近距离看到苹果，都能认出是苹果）以外，人眼在距离物体近时，能够获得物体足够多的特性，在距离物体远时，能够或略细节，例如，近距离看一个人脸能看到毛孔，距离远了看不到毛孔等等。
在图片信息当中，分辨率都是固定的，要想得到类似人眼的效果，就要把图片弄成不同的分辨率，制作成图像金字塔来模拟人眼的功能，从而在其他图片中进行特征识别时，能够像人眼睛一样，即使要识别的物体尺寸变大或者变小，也能够识别出来！
从图1可以看出，如果如果图像变大，窗口大小还是以前的大小，则无法正确检测出角点。那么很自然的就能想到，如果图片变大，咱们把窗口也放大不就行了？ 这就需要上面提到的尺度空间发挥作用。
在SIFT当中，利用了一个叫做高斯核的方程来构建尺度空间，原因是高斯核函数是唯一多尺度空间的核。听起来比较晦涩，个人理解为：
高斯核函数在之前的高斯滤波当中使用过，其原理就是利用高斯分布的特性，在以某一个点为中心要进行以某一个窗口大小进行模糊的操作。那么，根据滤波的原理，距离中心像素点位置的距离越远的像素点，需要“模糊化效果”的值就应该越少。那么这个距离值的分配方法，就是利用满足高斯核函数的分配方法，由中心，到四周，符合高斯核函数的“钟型”曲线（从二维上看）。
那么尺度空间中的高斯核也可以这么理解，高斯核函数的参数有三个 G(x,y,σ) ，在滤波当中，第三个参数σ在运算中是固定的一个值。而在尺度空间的构造当中，所谓的“尺度”，就是这个σ值变化，而x和y表示像素坐标。σ的值越小，图像被平滑（被模糊）的越少，尺度也越小。所以，大尺度图片可以对应成一个图像离远处观看，是个大致轮廓，小尺度图片可以对应成离近处观看，有更多细节。
构建尺度空间的目的是为了检测出在不同的尺度下都存在的特征点，如此可以获得缩放不变性
其中利用图像 I(x,y) 与 G(x,y,σ) 进行卷积运算，得到尺度空间 L(x,y,σ) ，可以理解，所谓的“尺度空间”在这里就是这个函数 L(x,y,σ) 如果求取特征点，可以使用一个叫做拉普拉斯算子进行运算
但是，由于拉普拉斯算子的效率太低，再SIFT算法当中使用差分来代替。
高斯金字塔：
在建立尺度空间后，需要找到关键点，此时需要实现高斯金字塔的构造来实现关键点的求取。在高斯金字塔当中，“塔”的每一层都是图像，“塔”的高度就是上面提到的尺度σ。“塔”的每一层对应一个σ值，同时将高斯金字塔中的图像分成组，每组当中图像的尺寸相同，但是尺度σ不同。具体尺度之间的计算关系，先忽略，如下图所示： 高斯差分金字塔DOG：
每一组相邻当中相邻两层的图像做差，得到的图像再“叠”成一个金字塔就是高斯差分金字塔DOG。
DOG局部特征点检测：
有了差分金字塔，现在便可以计算关键点（特征点）。由于金字塔的模型不是二维模型，而是一个三维模型，这里计算极值的方法也不再是二维求取极值的方法。
计算一个某一个点是否是局部最大值，在离散的三维空间当中，以该点为中心，检测它周围的点。类似魔方的中心位置一样，如下图中的“叉”就是待计算是否是局部极值点。
这里说明，局部极值点都是在同一个组当中进行的，所以肯定有这样的问题，某一组当中的第一个图和最后一个图层没有前一张图和下一张图，那该怎么计算？ 解决办法是，在用高斯模糊，在高斯金字塔多“模糊”出三张来凑数，所以在DOG中多出两张。
关键点定位： 上面找到的关键点要进行处理，去除一些不好的特征点，保存下来的特征点能够满足稳定性等条件。 主要是去掉DOG局部曲率非常不对称的像素。
因为低对比度的特征点和边界点对光照和噪声变化非常敏感，所以要去掉。利用阈值的方法来限制，在opencv中为contrastThreshold。
去除低对比度的特征点：
使用泰勒公式对DOG函数空间进行拟合，去掉小于修正阈值的关键点。
去除不稳定的边界点：
利用Hessian矩阵（就是求导数的矩阵），利用边缘梯度的方向上主曲率值比较大，而沿着边缘方向则主曲率值较小的原理，将主曲率限制为某个值。满足该值条件的点留下，反之去除。
关键点设定方向参数： 每个关键点设置方向以后可以获得旋转不变性。 获取关键点所在尺度空间的邻域，然后计算该区域的梯度和方向，根据计算得到的结果创建方向直方图，直方图的峰值为主方向的参数，其他高于主方向百分之80的方向被判定为辅助方向，这样设定对稳定性有很大帮助。如图
关键点描述符： 经过上面的步骤计算，每个关键点有三个信息，位置、尺度、方向。所以具备平移、缩放、和旋转不变性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/232798dfd9f2d6866023a701ca3b446b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50723ae556c684e9788846fa35bacb07/" rel="bookmark">
			Spring Boot学习之旅：（六）springboot 整合 redis 以及 redis 通用工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这编文章主要介绍了springboot整合redis，以及redis配置和一些redis操作数据的工具类。 首先倒入redis依赖
一.依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 二.配置文件 创建一个redis.properties配置redis redis.host=localhost redis.port=6379 redis.password= redis.database=1 redis.maxActive=8 redis.maxWait=-1 redis.maxIdle=8 redis.minIdle=1 redis.timeOut=0 创建一个与redis.properties的配置类方便直接使用配置的参数。
@Configuration @PropertySource(value = "classpath:redis.properties") @ConfigurationProperties(prefix = "redis") public class RedisConfigProperties { // 主机地址 public String host; //端口 public int port; //密码没有不填写 public String password; // Redis数据库索引（默认为0） public int database; //最大活跃连接 public int maxActive; //连接池最大阻塞等待时间（使用负值表示没有限制） public int maxWait; //连接池中的最大空闲连接 public int maxIdle; //连接池中的最小空闲连接 public int minIdle; //连接超时时间（毫秒） public int timeOut; public String getHost() { return host; } public void setHost(String host) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50723ae556c684e9788846fa35bacb07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdda2c9004cefb731e02c1aad9b85c54/" rel="bookmark">
			try catch 执行原理及顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		try{ //正常执行的代码 }catch (Exception e){ //出错后执行的代码 }finally{ //无论正常执行还是出错,之后都会执行的代码 } //跟上面try catch无关的代码 正常执行的代码如果出现异常,就不会执行出现异常语句后面的所有正常代码。 异常可能会被捕获掉,比如上面catch声明的是捕获Exception,那么所有Exception包括子类都会被捕获,但如Error或者是Throwable但又不是Exception(Exception继承Throwable)就不会被捕获。 如果异常被捕获,就会执行catch里面的代码.如果异常没有被捕获,就会往外抛出,相当于这整个方法出现了异常。 finally中的代码只要执行进了try catch永远都会被执行.执行完finally中的代码,如果异常被捕获就会执行外面跟这个try catch无关的代码.否则就会继续往外抛出异常。 return无论在哪里,只要执行到就会返回,但唯一一点不同的是如果return在try或者catch中,即使返回了,最终finally中的代码都会被执行.这种情况最常用的是打开了某些资源后必须关闭,比如打开了一个OutputStream,那就应该在finally中关闭,这样无论有没有出现异常,都会被关闭。
之前有看到资料说，try/catch要写在循环外面，，防止出现性能的损失。不过今天看了try/catch的执行原理，结论是在没有抛出异常的情况下，性能完全没区别。
讨论帖地址：http://stackoverflow.com/questions/141560/should-try-catch-go-inside-or-outside-a-loop
异常处理帖地址：http://www.javaworld.com/javaworld/jw-01-1997/jw-01-hood.html?page=1
1、类会跟随一张 异常表（exception table），每一个try catch都会在这个表里添加行记录，每一个记录都有4个信息（try catch的开始地址，结束地址，异常的处理起始位，异常类名称）。
2、当代码在运行时抛出了异常时，首先拿着抛出位置到异常表中查找是否可以被catch（例如看位置是不是处于任何一栏中的开始和结束位置之间），如果可以则跑到异常处理的起始位置开始处理，如果没有找到则原地return，并且copy异常的引用给父调用方，接着看父调用的异常表。。。以此类推。
所以最终的结论是，要根据需求，选择合适的try/catch进行处理，满足功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5129680721dc6b6d7f475b7edb89ea42/" rel="bookmark">
			深入探讨Java字符串的拼接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：国庆最近跟着小男友在图书馆学习，偶然被他带着看开了Java源码，因而有兴趣想看看String这个是怎么回事。 String中的equals public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } 这是String复写的equals的源码，在Object中equals方法返回的是两者地址值，即：
public boolean equals(Object obj) { return (this == obj); } 也就是说，如果这两个地址相同则返回true，不进行内容的比较。例如，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5129680721dc6b6d7f475b7edb89ea42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8238df355dc84637dfa9d2c9d8cd00f/" rel="bookmark">
			curl命令测试网络请求中DNS解析、响应时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经查遇到需要测量网络请求时间的问题，包括DNS解析、连接、传输等时间。Linux下的curl命令可以很好的测量网络请求。
如下
curl -o /dev/null -s -w %{time_connect}:%{time_starttransfer}:%{time_total} http://www.baidu.com 0.034:0.066:0.067 -o表示输出结果到/dev/null，-s表示去除状态信息，-w表示列出后面的参数的结果。
curl命令支持的参数，有如下
time_connect 建立到服务器的 TCP 连接所用的时间 time_starttransfer 在发出请求之后,Web 服务器返回数据的第一个字节所用的时间 time_total 完成请求所用的时间 time_namelookup DNS解析时间,从请求开始到DNS解析完毕所用时间(记得关掉 Linux 的 nscd 的服务测试) speed_download 下载速度，单位-字节每秒。 通过该命令，可以计算网络请求中DNS解析、连接、传输及总的时间，进行初步的故障排查。
参考 curl 来测试网站-dns解析时间,响应时间,传输时间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec059ec1a6f67f73acfb33765a82cae6/" rel="bookmark">
			HTML canvas 制作星星背景加流星特效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		突然想做一个流星动画效果结果做完好jb丑啊 感觉缺了什么算了反正我也想不起来 页面是用的CANVAS纯JavaScript做的
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;style&gt; html, body { height: 100%; width: 100%; margin: 0px; padding: 0px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="画板id"&gt;&lt;/canvas&gt; &lt;script&gt; var 参数 = { 画板载入: function (can) { var canvas = document.getElementById(can); canvas.width = document.body.offsetWidth; canvas.height = document.body.offsetHeight; canvas.style.backgroundColor = "rgb(255, 255, 255)"; return canvas; }, 二D配置: function (canvas) { var cvs = canvas.getContext('2d'); return cvs; }, 星星配置: function () { var 星图 = 绘图.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec059ec1a6f67f73acfb33765a82cae6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8852af49b7c8ed827c065610c95f2ba3/" rel="bookmark">
			Apache JMeter常用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JMeter函数是一种特殊值，可用于除测试计划外的任何组件。函数调用的格式如下所示：
${__functionName(var1,var2,var3)}
其中，__functionName为函数名，括号内是函数的参数，无参数时可以不用括号，如${__UUID}
Tips:
如果参数包含逗号，那么一定要使用“\”来转义，否则JMeter会把它当作一个参数分隔符
实际使用时，可通过函数助手对话框选择函数，设置参数后，点击生成按钮生成函数字符串。
下文讲述几个常用的JMeter函数。
__Random函数 返回指定最大值和最小值之间的一个随机数。
示例：
${__Random(1,10,)} 返回1到10之间的随机数
${__Random(0,10，MYVAR)} 返回0到10之间的随机数，并将其存储在MYVAR中。 ${MYVAR}将包含随机数
__RandomString函数 返回指定长度的随机字符串。
示例：
${__RandomString(5)} 返回一个5个字符的随机字符串
${__RandomString(10,abcdefg)} 返回从abcdefg集合中选取的10个字符的随机字符串，如cdbgdbeebd或adbfeggfad，...
__UUID函数 返回一个伪随机类型4通用唯一标识符（UUID）。
示例：
${__UUID}
${UUID()}
__time函数 返回当前时间。
示例：
${__time(,)} 当前时间(毫秒级时间戳)
${__time(/1000,)} 当前时间(秒级时间戳)
${__time(yyyy-MM-dd,)} 当前时间(指定格式的日期)
__counter函数 线程每次调用时会生成一个新的数字，从1开始，每次增加+1。
实例：
${__counter(TRUE,)} 每个用户(线程)有自己的计数器
${__counter(TRUE,)} 使用全局计数器
__StringFromFile函数 用于从文本文件读取字符串，支持读取多个文件。
示例：
${_StringFromFile(demo.txt,,,)} 读取demo.txt
${_StringFromFile(PIN#'.'DAT,,1,2)} 读取demo1.txt, demo2.txt
${_StringFromFile(PIN.DAT,,,2)} 读取demo.txt两次
__CSVRead函数 从csv文件读取字符
列号文件中的列号。 0 =第一列，1 =下一列 ，以此类推 ... next - 转到文件下一行
示例：
（假设如下4条按顺序调用）
${__CSVRead(random.txt,0)} 读取COL1a
${__CSVRead(random.txt,1)}${__CSVRead(random.txt,next)} 读取COL2a
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8852af49b7c8ed827c065610c95f2ba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca4228f6174f495afa5897702da2c389/" rel="bookmark">
			数据降维与可视化——t-SNE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：
manifold：可以称之为流形数据。像绳结一样的数据，虽然在高维空间中可分，但是在人眼所看到的低维空间中，绳结中的绳子是互相重叠的不可分的。参考sklearn官方文档对数据降维比较熟悉的朋友可以看这篇博客 t-SNE实践——sklearn教程 数据降维与可视化——t-SNE t-SNE是目前来说效果最好的数据降维与可视化方法，但是它的缺点也很明显，比如：占内存大，运行时间长。但是，当我们想要对高维数据进行分类，又不清楚这个数据集有没有很好的可分性（即同类之间间隔小，异类之间间隔大），可以通过t-SNE投影到2维或者3维的空间中观察一下。如果在低维空间中具有可分性，则数据是可分的；如果在高维空间中不具有可分性，可能是数据不可分，也可能仅仅是因为不能投影到低维空间。 下面会简单介绍t-SNE的原理，参数和实例。
t-distributed Stochastic Neighbor Embedding(t-SNE) t-SNE（TSNE）将数据点之间的相似度转换为概率。原始空间中的相似度由高斯联合概率表示，嵌入空间的相似度由“学生t分布”表示。
虽然Isomap，LLE和variants等数据降维和可视化方法，更适合展开单个连续的低维的manifold。但如果要准确的可视化样本间的相似度关系，如对于下图所示的S曲线（不同颜色的图像表示不同类别的数据），t-SNE表现更好。因为t-SNE主要是关注数据的局部结构。 通过原始空间和嵌入空间的联合概率的Kullback-Leibler（KL）散度来评估可视化效果的好坏，也就是说用有关KL散度的函数作为loss函数，然后通过梯度下降最小化loss函数，最终获得收敛结果。注意，该loss不是凸函数，即具有不同初始值的多次运行将收敛于KL散度函数的局部最小值中，以致获得不同的结果。因此，尝试不同的随机数种子(Python中可以通过设置seed来获得不同的随机分布)有时候是有用的，并选择具有最低KL散度值的结果。 使用t-SNE的缺点大概是：
t-SNE的计算复杂度很高，在数百万个样本数据集中可能需要几个小时，而PCA可以在几秒钟或几分钟内完成Barnes-Hut t-SNE方法（下面讲）限于二维或三维嵌入。算法是随机的，具有不同种子的多次实验可以产生不同的结果。虽然选择loss最小的结果就行，但可能需要多次实验以选择超参数。全局结构未明确保留。这个问题可以通过PCA初始化点（使用init ='pca'）来缓解。 优化 t-SNE t-SNE的主要目的是高维数据的可视化。因此，当数据嵌入二维或三维时，效果最好。有时候优化KL散度可能有点棘手。有五个参数可以控制t-SNE的优化，即会影响最后的可视化质量：
perplexity困惑度early exaggeration factor前期放大系数learning rate学习率maximum number of iterations最大迭代次数angle角度 Barnes-Hut t-SNE Barnes-Hut t-SNE主要是对传统t-SNE在速度上做了优化，是现在最流行的t-SNE方法，同时它与传统t-SNE还有一些不同：
Barnes-Hut仅在目标维度为3或更小时才起作用。以2D可视化为主。Barnes-Hut仅适用于密集的输入数据。稀疏数据矩阵只能用特定的方法嵌入，或者可以通过投影近似，例如使用sklearn.decomposition.TruncatedSVDBarnes-Hut是一个近似值。使用angle参数对近似进行控制，因此当参数method="exact"时，TSNE()使用传统方法，此时angle参数不能使用。Barnes-Hut可以处理更多的数据。 Barnes-Hut可用于嵌入数十万个数据点。 为了可视化的目的（这是t-SNE的主要用处），强烈建议使用Barnes-Hut方法。method="exact"时，传统的t-SNE方法尽管可以达到该算法的理论极限，效果更好，但受制于计算约束，只能对小数据集的可视化。
对于MNIST来说，t-SNE可视化后可以自然的将字符按标签分开，见本文最后的例程；而PCA降维可视化后的手写字符，不同类别之间会重叠在一起，这也证明了t-SNE的非线性特性的强大之处。值得注意的是：未能在2D中用t-SNE显现良好分离的均匀标记的组不一定意味着数据不能被监督模型正确分类，还可能是因为2维不足以准确地表示数据的内部结构。
注意事项 数据集在所有特征维度上的尺度应该相同 参数说明 parametersdescriptionn_componentsint, 默认为2，嵌入空间的维度（嵌入空间的意思就是结果空间）perplexityfloat, 默认为30，数据集越大，需要参数值越大，建议值位5-50early_exaggerationfloat, 默认为12.0，控制原始空间中的自然集群在嵌入式空间中的紧密程度以及它们之间的空间。 对于较大的值，嵌入式空间中自然群集之间的空间将更大。 再次，这个参数的选择不是很关键。 如果在初始优化期间成本函数增加，则可能是该参数值过高。learning_ratefloat, default:200.0, 学习率，建议取值为10.0-1000.0n_iterint, default:1000, 最大迭代次数n_iter_without_progressint, default:300, 另一种形式的最大迭代次数，必须是50的倍数min_grad_normfloat, default:1e-7, 如果梯度低于该值，则停止算法metricstring or callable, 精确度的计量方式initstring or numpy array, default:”random”, 可以是’random’, ‘pca’或者一个numpy数组(shape=(n_samples, n_components)。verboseint, default:0, 训练过程是否可视random_stateint, RandomState instance or None, default:None，控制随机数的生成methodstring, default:’barnes_hut’, 对于大数据集用默认值，对于小数据集用’exact’anglefloat, default:0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca4228f6174f495afa5897702da2c389/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1276612690f04048b2de61eae6f8594a/" rel="bookmark">
			Linux防火墙开放端口号 及 常用端口号详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、防火墙开放端口号 开放端口号命令:
/sbin/iptables -I INPUT -p tcp --dport 11211 -j ACCEPT
保存防火墙修改命令(必须)：
/etc/rc.d/init.d/iptables save
[说明]此处端口号为11211，可对应修改 二、各种常见的端口号及其作用 TCP 21端口：FTP 文件传输服务
TCP 23端口：TELNET 终端仿真服务
TCP 25端口：SMTP 简单邮件传输服务
UDP 53端口：DNS 域名解析服务
TCP 80端口：HTTP 超文本传输服务
TCP 110端口：POP3 “邮局协议版本3”使用的端口
TCP 443端口：HTTPS 加密的超文本传输服务
6379端口: Redis
11211端口: Memcached
3306端口: MySql 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a105252e0b168578509ba8d79ed72b8/" rel="bookmark">
			angular中$emit与$broadcast详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		angularjs 中 broadcast与 emit $on的处理思想 对于Angular的controll之间的通信方式，我们可以常见有有几种方式，如可以通过 rootScope，还有通过 scope的作用域，当然还有一种个人觉得很好的通信方式就是 broadcast, emit,$on来监听；
broadcast方式与 emit方式的区别 broadcast方式一种广播模式，就是父级发送一个消息时间，子级controller里面监听这个消息事件的函数就会执行； emit与$broadcast方式相反，是子级controller发布一个消息事件，父级controller监听的函数执行； 两种方式平级的controller都不能收到消息事件，注意同一个controller里面都是可以捕获到消息事件的; 父子级controller
&lt;div ng-controller="ParentCtrl"&gt; //父级 &lt;div ng-controller="SelfCtrl"&gt; //自己 &lt;a ng-click="click()"&gt;click me&lt;/a&gt; &lt;div ng-controller="ChildCtrl"&gt;&lt;/div&gt; //子级 &lt;/div&gt; &lt;div ng-controller="BroCtrl"&gt;&lt;/div&gt; //平级 &lt;/div&gt; 1234567 javascript如下：
phonecatControllers.controller('SelfCtrl', function($scope) { $scope.click = function () { $scope.$broadcast('to-child', 'child'); $scope.$emit('to-parent', 'parent'); } }); phonecatControllers.controller('ParentCtrl', function($scope) { $scope.$on('to-parent', function(d,data) { console.log(data); //父级能得到值 }); $scope.$on('to-child', function(d,data) { console.log(data); //子级得不到值 }); }); phonecatControllers.controller('ChildCtrl', function($scope){ $scope.$on('to-child', function(d,data) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a105252e0b168578509ba8d79ed72b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc1a4a2d25d24d926b70fa87cb10bc4e/" rel="bookmark">
			springboot vue 登陆发送请求（跨域问题）02
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前后端分离之间进行通讯首先要进行跨域请求,以前的做法就是写个过滤器来操作，还有就是nginx代理了。 现在用vue和springboot都有新的方式 第一种 vue2 本身也支持跨域，开发过程中支持这个，方便 第二种 springboot 简单一个类就可以支持 第三种 生产环境用nginx就不用说了，必须的。像什么复杂的代理请求和负载等等都可以 先弄第一种 引入resource 在App.vue 加入请求方法 methods: { getData () {
var that = this.$http.get('api/sysuser/list') .then(function (response) { console.log(response.data) console.log(this) that.serverData = response.data }) .catch(function (error) { console.log(error) }) } } 2.第二种 springboot 配置也可以 去掉之前vue代理请求就提示跨域问题了，我们先删除代理运行看看 访问地址修改成 再次访问就有跨域问题 接下来在项目种加入CorsConfig类，如图 @Configuration public class CorsConfig extends WebMvcConfigurerAdapter{ @Override public void addCorsMappings(CorsRegistry registry) { System.out.println("----------------------"); registry.addMapping("/**") .allowedOrigins("*") .allowCredentials(true) .allowedMethods("GET", "POST", "DELETE", "PUT") .maxAge(3600); } } 重启项目刷新页面，跨域问题就解决了 第三种nginx跨域解决问题后面部署服务器的时候再一起学习
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3549b8a5644f959cbb4128e3395e7315/" rel="bookmark">
			JS中的PadLeft、PadRight，位数不足，自动补位，String扩展方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类似C#中的 PadLeft、PadRight方法 //方法一 function FillZero(p) { return new Array(3 - (p + '').length + 1).join('0') + p; } FillZero(6); //输出006 //方法一扩展（C#中PadLeft、PadRight） String.prototype.PadLeft = function (len, charStr) { var s = this + ''; return new Array(len - s.length + 1).join(charStr, '') + s; } String.prototype.PadRight = function (len, charStr) { var s = this + ''; return s + new Array(len - s.length + 1).join(charStr, ''); } var p = 6; p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3549b8a5644f959cbb4128e3395e7315/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c041eee6ec42f1e26c0b91febee7ec/" rel="bookmark">
			Win10 如何以管理员身份设置开机自启程序(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一个项目在win10上部署时遇到问题，即如何设置以管理员身份开机自启。现把解决方法整理如下：
首先，为了进行验证，我编了一个简单的程序test.exe(在C盘系统文件中创建一个文件)：
#include &lt;iostream&gt; #include &lt;fstream&gt; using namespace std; int main() { ofstream temp("C:/Program Files (x86)/Internet Explorer/test/test.txt"); if (!temp) cout &lt;&lt; "creat failed" &lt;&lt; endl; else { cout &lt;&lt; "creat successfully" &lt;&lt; endl; temp.close(); } system("pause"); return 0; } (1) 在Cortana中输入并打开任务计划程序
(2) 操作 -&gt; 创建基本任务
任务名称随便写：
触发器暂时选择 “计算机启动时”
操作选择 “启动程序”
启动程序选择你需要开机自启的东西
完成时，注意选择打开属性对话框
(3) 设置任务属性
通过 “更改用户或组”修改对象为 “Administrators”; 同时选中 使用最高权限运行。 调整触发条件为所有用户登录时：
(4) 大功告成，开机重启
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6460f341cca4272e1417335140a8a5d/" rel="bookmark">
			三极管相关知识点释疑（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近找工作找的郁闷，感觉走了一条不归路。。。 主要介绍下三极管相关的知识点，还有一些相关的总结。
1.二极管 介绍三极管之前肯定要先了解下二极管。
1.1 基本结构 PN 结加上管壳和引线，就成为半导体二极管。 电路符号： 实物图： 伏安特性： 1.2主要参数 直流的情况，主要利用它的单向导电性，主要应用于整流、限幅、保护等等。 1.最大整流电流 IF 二极管长期使用时，允许流过二极管的最大正向平均电流。 2.反向击穿电压 VBR 二极管反向击穿时的电压值。击穿时反向电流剧增，二极管的单向导电性被破坏，甚至过热而烧坏。 3.反向电流 IR 指二极管加反向峰值工作电压时的反向电流。反向电流大，说明管子的单向导电性差，因此反向电流越小越好。反向电流受温度的影响，温度越高反向电流越大。硅管的反向电流较小，锗管的反向电流要比硅管大几十到几百倍。 交流的情况 1.微变电阻 rD rD 是二极管特性曲线上工作点Q 附近电压的变化与电流的变化之比： 1.3二极管的极间电容 势垒电容：势垒区是积累空间电荷的区域，当电压变化时，就会引起积累在势垒区的空间电荷的变化，这样所表现出的电容是势垒电容。 扩散电容：为了形成正向电流（扩散电流），注入P 区的少子（电子）在P 区有浓度差，越靠近PN结浓度越大，即在P 区有电子的积累。同理，在N区有空穴的积累。正向电流大，积累的电荷多。这样所产生的电容就是扩散电容CD。 PN结高频小信号时的等效电路 晶体二极管模型 1.4二极管分类 按结构材料分: (1)锗二极管 (2)硅二极管
按制作工艺分： (1)点接触型二极管：pn结面积小，结电容小，用于检波和变频等高频电路。 (2)面接触型二极管：结面积大，用于工频大电流整流电路。 (3)平面型二极管：往往用于集成电路制造工艺中。pn结面积可大可小，用于高频整流和开关电路中。
按功能用途分： (1)硅整流二极管：硅整流二极管除主要应用于电源电路做整流元件外，还可用作限幅、保护、钳位等。(常用整流二极管主要是1n、2cz系列) (2)检波二极管：检波二极管的结点容小、工作频率高、正向压降小，但允许流过的最大正向电流小、内阻大。多用于小信号、高频率的电路，用作检波、鉴频、限幅。(常用检波二极管主要是2ap系列) (3)稳压二极管：利用稳压二极管的反向击穿特性，用作稳压基准电压、保护、限幅、电平转换等。其中2dw230~2dw232稳压管内部具有温度补偿，电压温度系数低，可用于精密稳压电路。(常用稳压二极管主要是1n、2cw、2dw系列) (4)光敏二极管：利用光敏二极管在光的照射下，反向电流与光照成正比的特性，应用于光电转换及光控、测光等自动控制电路中。（常用硅光敏二极管主要是2cu、2du系列） (5)变容二极管：变容二极管的结电容可以随外加偏压的不同而变化，主要应用于lc调谐、自动频率控制稳频等场合。（常用变容二极管主要是2cc、1n系列） (6)发光二极管：发光二极管能把电能直接快速地转换成光能，在电子仪器、仪表中用作显示器件、状态信息指示、光电开关和光辐射源等。（常用发光二极管主要是2ef系列） (7)肖特基二极管：肖特基二极管具有反向恢复时间很短、正向压降较低的特性，可用于高频整流、检波、高速脉冲箱位等。（常用肖特基二极管主要是1n、mbr系列） (8)快速恢复二极管：快速恢复二极管的正向压降与普通硅整流二极管相似，但反向恢复时间小，耐压比肖特基二极管高得多，用作中频整流元件。（常用快速恢复二极管主要是1n、mr系列） (9)开关二极管：开关二极管的反向恢复时间很小，主要用于开关、脉冲、超高频电路和逻辑控制电路中。（常用开关二极管主要是2ak、2ck、1n系列） (10)硅整流桥：单相硅整流桥用以代替四个整流二极管、在小功率电源整流中应用广泛。（常用硅整流桥主要是3n、ql系列） (11)高压硅堆：高压硅堆是由多个硅二极管串联后封装的，在电子设备中用作高压整流。(常用高压硅堆主要是2cl系列) (12)双向触发二极管：双向触发二极管是两端交流器件，有两个对称的正反转折电压vbo，可用作双向交流开关，可向双向晶闸管提供控制极触发电流。（常用双向触发二极管主要是2cts、pda系列） (13)双基极二极管：双基极二极管又称单结晶体管，它具有稳定的触发电压和触发电流，可控制基极间的电压以取得较大的脉冲电流，适用作驰张振荡器，定时电路及晶闸管的触发电路。（常用双基极二极管主要是bt31~37系列） (14)温敏二极管：温敏二极管作为热敏元件对温度变化敏感，可用于自动增益控制、音量控制、过热和过载保护等电路中，在工业自动控制、高空和海洋探测、医学卫生等方面得到了广泛的应用。（常用温敏二极管主要是hw、2cwm、jcwm系列） (15)磁敏二极管：磁敏二极管是一种新型的磁电转换器件。这种元件比霍尔元件的探测灵敏度高，且具有体积小、响应快、无触点、输出功率大及线性特性好的优点。该器件在磁力探测、无触点开关、位移测量、转速测量及其他各种自动化设备上得到了广泛的应用。(常用磁敏二极管主要是2acm、2dcm系列) (16)阻尼二极管：阻尼二极管具有较高的反向工作电压和峰值电流，正向压降小，高频高压整流二极管，用在电视机行扫描电路作阻尼和升压整流用。（常用阻尼二极管主要是2cn、rh、tvr系列） (17)瞬态二极管(tvs)：瞬态二极管是一种二极管形式的高效能保护器件。具有响应时间快、瞬态功率大、漏电流低、击穿电压偏差、箝位电压较易控制、无损坏极限、体积小等优点。广泛应用于计算机系统、通讯设备、交/直流电源、汽车、电子镇流器、家用电器、仪器仪表（电度表）、rs232/422/423/485、i/o、lan、isdn、adsl、usb、mp3、pdas、gps、cdma、gsm、数字照相机的保护、共模/差模保护、rf耦合/ic驱动接收保护、电机电磁波干扰抑制、声频/视频输入、传感器/变速器、工控回路、继电器、接触器噪音的抑制等各个领域。 (18)激光二极管：激光二极管具有效率高、体积小、寿命长的优点，但其输出功率小（一般小于2mw），线性差、单色性不太好，使其在有线电视系统中的应用受到很大限制，不能传输多频道，高性能模拟信号。激光二极管在计算机上的光盘驱动器，激光打印机中的打印头等小功率光电设备中得到了广泛的应用。 (19)红外发射二极管：红外发射二极管具有高发射功率、绝缘性好、抗湿、耐磨、高可靠性，应用于各种仪器的遥控发射光源、点钞机、复印机、扩印机、监控器红外发射光源。ir3401 (20)微波二极管：微波二极管的基片材料由锗、硅发展到砷化镓，使微波二极管工作频率不断提高，目前最高频率已达300吉赫。微波二极管具有体积小和可靠性高等优点，用于微波振荡、放大、变频、开关、移相和调制等方面。 （21）其他功能二极管：恒流二极管、压敏二极管、补偿二极管、精密二极管限幅二极管、钳位二极管、 续流二极管、 垫位二极管、保护二极管、译码二极管、 pin二极管、雪崩二极管、 高反向电阻点接触型二极管、高传导点接触型二极管等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6460f341cca4272e1417335140a8a5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5de427a4c68f7c57f8c1be5da55e700/" rel="bookmark">
			[Intensive Reading]目标检测(object detection)系列（一）  R-CNN：CNN目标检测的开山之作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标检测系列：
目标检测(object detection)系列（一） R-CNN：CNN目标检测的开山之作
目标检测(object detection)系列（二） SPP-Net：让卷积计算可以共享
目标检测(object detection)系列（三） Fast R-CNN：end-to-end的愉快训练
目标检测(object detection)系列（四） Faster R-CNN：有RPN的Fast R-CNN
目标检测(object detection)系列（五） YOLO：目标检测的另一种打开方式
目标检测(object detection)系列（六） SSD：兼顾效率和准确性
目标检测(object detection)系列（七） R-FCN：位置敏感的Faster R-CNN
目标检测(object detection)系列（八） YOLOv2：更好，更快，更强
目标检测(object detection)系列（九） YOLOv3：取百家所长成一家之言
目标检测(object detection)系列（十） FPN：用特征金字塔引入多尺度
目标检测(object detection)系列（十一） RetinaNet：one-stage检测器巅峰之作
目标检测(object detection)系列（十二） CornerNet：anchor free的开端
目标检测(object detection)系列（十三） CenterNet：no Anchor，no NMS
目标检测(object detection)系列（十四）FCOS：用图像分割处理目标检测
目标检测扩展系列：
目标检测(object detection)扩展系列（一） Selective Search：选择性搜索算法
目标检测(object detection)扩展系列（二） OHEM：在线难例挖掘
目标检测(object detection)扩展系列（三） Faster R-CNN，YOLO，SSD，YOLOv2，YOLOv3在损失函数上的区别
简介 ：CNN目标检测的开山之作 R-CNN提出于2014年，应当算是卷积神经网络在目标检测任务中的开山之作了，当然同年间还有一个overfeat算法，在这里暂不讨论。R-CNN的论文是《Rich feature hierarchies for accurate oject detection and semantic segmentation》，在之后的几年中，目标检测任务的CNN模型也越来越多，实时性与准确率也越来越好，但是最为经典的模型还是很值得学习的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5de427a4c68f7c57f8c1be5da55e700/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24063cb108af69124802e4d7e2c9424b/" rel="bookmark">
			实习生与公司签订三方协议的流程与操作细节指南&#43;配图 - CQNU &amp; Deloitte
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景描述：在德勤实习近5个月后，早在前2周就听公司的SM说起近期要签订三方协议，由于不知道具体流程，在询问学长、辅导员以及HR后，才知道如何去操作。
前提假设：本文将以重庆师范大学实习生与德勤公司的实习关系进行story line的描述。
1、在实习期间，如果实习生通过了公司实习期的考察，HR会通知你准备签订三方协议。一般考核期为3个月，刚开始你会收到HR的电话通知，说公司有意向与你签订三方协议了，之后会以邮件的形式，告诉你公司的基本信息，以便你在学校那边申请三方协议模板时填写。
如：单位全称、单位地址、组织机构代码、联系人、单位行业类型、工作职位类型、单位性质、邮编等。
2、前往学校教务系统填写三方协议（学校官方名称为：协议书）签署的申请表，特别注意填表时，去向类型要填签学校就业协议形式就业，切勿选填签用人单位协议形式。当正确填写了申请表提交以后，才可以下载三方协议。
截图如下：
3、你可自行打印三方协议，然后将其交给与你对接的HR加盖公司的章，之后你需要把公司盖章后的协议书交给学校（一些填写三方协议的注意事项请自行百度）。
4、学校收到三方协议后也会加盖学院的章，然后再加盖校招办的章才算完成。在三方都签章后，三方各执一份。
Q&amp;A：
Q1、重师老校区可以办理该业务么？
A：目前无法在沙坪坝老校区办理三方协议，你需要前往大学城校区自行办理，请自行安排好时间。
Q2、学校签章流程大概得花多长时间？
A：你至少要留出半天的时间跑签章，最多1天。
Q3、档案该转往哪？
A：这么个性的问题还是得问问你自己。我目前在问完已毕业5年的表姐后，决定把档案留在公司，方便。
Q4、填写三方申请时，工作岗位栏的录用接受证明附件该如何填？
A：我当时是上传的是HR给我的告知签订三方通知邮件的保存文件
Q5、重师校招办在哪？
A：在一站式就业服务平台，校友会堂处。
Q6、如果去向类型填错了怎么办？
A：你需要申请撤销，之后联系辅导员通过撤销审核-&gt;分管院校领导过审（目前是杨书记）-&gt;招就办过审（目前是殷老师）。最后，重新填写选择正确的去向类型即可！！！
Q7、其他问题？
A：请留言！！！
补充：关于违约
若三方协议未明确提出违约金是否需要缴纳，不需要缴纳违约金。违约金只能按约定办，公司惯例不能成为职工支付违约金的依据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d9ad1b3abaa1364f3c3881deb22ce0d/" rel="bookmark">
			关于QQ登录出现&#34;非官方应用 错误码100044&#34;的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		### 解决方法： 1、检查代码里配置的appid是否正确(和腾讯开放平台的保持一致)。 2、修改签名。(第一次上传的应用与之后上传的签名不一致) 签名修改操作步骤：对应移动应用的开发者可以进入QQ互联平台connect.qq.com/index.html 移动应用里修改签名。若QQ互联里已有对应的移动应用，可直接改签名；若无对应移动应用，需在应用管理 =&gt; 移动应用 =&gt; 关联腾讯开放平台，根据提示关联创建出现问题的移动应用，修改/添加相应的签名或者包名。
注：1、获取对应报错包名所用的签名信息进行修改或者添加。
2、包名、签名需小写，去掉冒号
ps : 友盟给的解决办法 太不靠谱了 有点敷衍.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a15ee93514016d0e3d6ca057e73e5ac2/" rel="bookmark">
			kafka0.8消费者实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序 这里简单展示一下如何使用kafka0.8的client去消费一个topic。
maven &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka_2.10&lt;/artifactId&gt; &lt;version&gt;0.8.2.2&lt;/version&gt; &lt;/dependency&gt; 初始化客户端 Properties props = new Properties(); props.put("zookeeper.connect", zk); // props.put("auto.offset.reset","smallest"); props.put("group.id",group); props.put("zookeeper.session.timeout.ms", "10000"); props.put("zookeeper.sync.time.ms", "2000"); props.put("auto.commit.interval.ms", "10000"); props.put("consumer.timeout.ms","10000"); //设置ConsumerIterator的hasNext的超时时间,不设置则永远阻塞直到有新消息来 props.put(org.apache.kafka.clients.consumer.ConsumerConfig.PARTITION_ASSIGNMENT_STRATEGY, "range"); ConsumerConfig consumerConfig = new kafka.consumer.ConsumerConfig(props); ConsumerConnector consumerConnector = kafka.consumer.Consumer.createJavaConsumerConnector(consumerConfig); Map&lt;String, Integer&gt; topicCountMap = new HashMap&lt;String, Integer&gt;(); topicCountMap.put(topic, consumerCount); Map&lt;String, List&lt;KafkaStream&lt;byte[], byte[]&gt;&gt;&gt; consumerMap = consumerConnector .createMessageStreams(topicCountMap); 并发消费 consumerMap.get(topic).stream().forEach(stream -&gt; { pool.submit(new Runnable() { @Override public void run() { ConsumerIterator&lt;byte[], byte[]&gt; it = stream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a15ee93514016d0e3d6ca057e73e5ac2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03e1ff384872c481e7380b2d5f40b8a4/" rel="bookmark">
			[教你警告消除]Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在利用IAR进行编译的时候，经常会出现 Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined in this statement C:\Users\Administrator\Desktop\IAP_BootLoader\UART\UART.c 38 这种报警。
其实这种报警很简单消除。
他的意思是你报警的这条语句中有两个或两个以上被 volatile 定义过的变量。编译器会认为有问题。
如下：
/*看门狗复位计算*/ void wdt_feed(void) { if( (LPC_WWDT-&gt;TV) &lt;= (LPC_WWDT-&gt;WINDOW)) { // Do a feed sequence to enable the WWDT. LPC_WWDT-&gt;FEED = 0xAA; LPC_WWDT-&gt;FEED = 0x55; } } 这里的TV 和 WINDOW 都是被 volatile 定义的变量。
因此想要消除，只需要将其中一个变量值赋给一个临时变量即可。如下：
/*看门狗复位计算*/ void wdt_feed(void) { static uint32_t ret ret = LPC_WWDT-&gt;TV; if( ret &lt;= (LPC_WWDT-&gt;WINDOW)) { // Do a feed sequence to enable the WWDT.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03e1ff384872c481e7380b2d5f40b8a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e736bfb7eafc601cc69b404facaf5c/" rel="bookmark">
			引入jquery等(静态资源)报404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路径 绝对 对
原理：如果请求包含静态资源拦截器的路径那么这些静态资源就会放行，不被拦截，否则将会被拦截，导致出现404
解决：配置srping-mvc的静态拦截器 在srping-mvc.xml里面配置 静态资源路径 在srping-mvc.xml加上
&lt;mvc:default-servlet-handler /&gt; 报404页面
srping-mvc.xml页面
jsp页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3434aa6c983292cb001fdf8e1443f1b4/" rel="bookmark">
			Python中numpy数组的合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python中numpy数组的合并有很多方法，如
np.append()np.concatenate()np.stack()np.hstack()np.vstack()np.dstack() 其中最泛用的是第一个和第二个。第一个可读性好，比较灵活，但是占内存大。第二个则没有内存占用大的问题。
方法一——append parametersintroductionarr待合并的数组的复制（特别主页是复制，所以要多耗费很多内存）values用来合并到上述数组复制的值。如果指定了下面的参数axis的话，则这些值必须和arr的shape一致(shape[axis]之外都相等)，否则的话，则没有要求。axis要合并的轴 例程： 方法二——concatenate parametersintroduction*arrays这些数组除了在待合并的axis（默认为axis=0）上之外，必须具有相同的shapeaxis待合并的轴，默认为0 例程： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33420ada2ca114f0f925d0288d8fae4e/" rel="bookmark">
			softmax的loss和gradient推导过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		softmax的loss和gradient推导过程 相信搞deeplearning的各位大牛都很熟悉softmax了，用来对得分矩阵做归一化得到概率的一种分类手段，我这两天在做cs231n的作业，新手上路，只作为自己的学习足迹记录，还望各位大佬多多包涵。
简单介绍Softmax的loss计算Softmax的grad计算naive loopvectorization 简单介绍 这个公式是大家非常熟悉的，其实就是对于神经网络最后一层的结果进行指数概率的归一化，其中Li求得的是对于每个样本而言，它在所有类别中，被分类位正确的概率，syi代表样本被正确分类的评分，sj代表样本被分类为j的评分。 其实对于loss的求解很简单，主要的难度就在于对于梯度的求解。
loss的计算 根据上面的定义其实很容易计算loss,把所有样本i的Li加起来就是最终的结果，需要注意的是L的维度，和分数矩阵相同，最后再计算的时候用numpy.sum函数求矩阵的所有元素之和即可。另外需要考虑的就是归一化和正则化，归一化除以训练样本数就行。做作业的时候说的是用L2正则化，也就是把regularization_rate*W*W加在loss后面即可。
梯度grad的计算 以上这个式子的第一步其实是我们熟悉的链式求导法则，第二步是矩阵的求导法则，s是x与w的点乘结果，如果对某一个求导，结果就是另一个的转置。清楚了以上这个式子就可以进行正常的推导了。
单纯求导的结果会是这样，我们可以看出和s有关的有两个参数sj和syi，分别对应着正确分类的分数和其他所有分类的分数。
终于到了激动人心的推导过程。上面说了要分为正确的Syi和错误的Sj两种情况来计算，也就是j=yi和j≠yi两种。首先看j≠yi。这个时候我们是对sj来求导，那syi就是一个常数，分子后面的被减数的求和项只剩下sj的指数，这样求到之后得出的是probability(j)。
接下来用同样的思想，对syi来求导数，sj就是未知数。可以看出结果是probability(i)-1。
代码块 关于以上的求解，算法分为两种，一种是对于矩阵每个元素的细致计算，通过循环来实现，也叫做naive算法，这种算法直接按照公式去做，还是很简单的直接上代码：
def softmax_loss_naive(W, X, y, reg): """ Softmax loss function, naive implementation (with loops) Inputs have dimension D, there are C classes, and we operate on minibatches of N examples. Inputs: - W: A numpy array of shape (D, C) containing weights. - X: A numpy array of shape (N, D) containing a minibatch of data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33420ada2ca114f0f925d0288d8fae4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f412752411a839081e9897dea3cb9cb/" rel="bookmark">
			Could not resolve all dependencies for configuration &#39;:app:retrolambdaConfi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Error:Execution failed for task ‘:app:compileRetrolambdaDebug’.
Could not resolve all dependencies for configuration ‘:app:retrolambdaConfig’. Could not resolve net.orfjackal.retrolambda:retrolambda:2.1.0. Required by: project :app Could not resolve net.orfjackal.retrolambda:retrolambda:2.1.0. Could not load module metadata from C:\Users\Garnet.gradle\caches\modules-2\metadata-2.23\descriptors\net.orfjackal.retrolambda\retrolambda\2.1.0\22da77b0d76ea8df17298218f3ec1f87\descriptor.bin 根目录下的build.gradle如下： // Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript { repositories { jcenter() } dependencies { classpath ‘com.android.tools.build:gradle:2.2.2’ classpath ‘me.tatarka:gradle-retrolambda:3.2.5’ // NOTE: Do not place your application dependencies here; they belong // in the individual module build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f412752411a839081e9897dea3cb9cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cedb9ced5d07ca78fbb200bcc6cb9ea/" rel="bookmark">
			搞懂朴素贝叶斯分类算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载- 搞懂朴素贝叶斯分类算法
带你搞懂朴素贝叶斯分类算 贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。而朴素朴素贝叶斯分类是贝叶斯分类中最简单，也是常见的一种分类方法。这篇文章我尽可能用直白的话语总结一下我们学习会上讲到的朴素贝叶斯分类算法，希望有利于他人理解。
1 分类问题综述
对于分类问题，其实谁都不会陌生，日常生活中我们每天都进行着分类过程。例如，当你看到一个人，你的脑子下意识判断他是学生还是社会上的人；你可能经常会走在路上对身旁的朋友说“这个人一看就很有钱”之类的话，其实这就是一种分类操作。
既然是贝叶斯分类算法，那么分类的数学描述又是什么呢？
从数学角度来说，分类问题可做如下定义：已知集合和，确定映射规则y = f(x)，使得任意有且仅有一个,使得成立。
其中C叫做类别集合，其中每一个元素是一个类别，而I叫做项集合（特征集合），其中每一个元素是一个待分类项，f叫做分类器。分类算法的任务就是构造分类器f。
分类算法的内容是要求给定特征，让我们得出类别，这也是所有分类问题的关键。那么如何由指定特征，得到我们最终的类别，也是我们下面要讲的，每一个不同的分类算法，对应着不同的核心思想。
本篇文章，我会用一个具体实例，对朴素贝叶斯算法几乎所有的重要知识点进行讲解。
2 朴素贝叶斯分类
那么既然是朴素贝叶斯分类算法，它的核心算法又是什么呢？ 是下面这个贝叶斯公式：
换个表达形式就会明朗很多，如下：
我们最终求的p(类别|特征)即可！就相当于完成了我们的任务。
3 例题分析
下面我先给出例子问题。
给定数据如下：
现在给我们的问题是，如果一对男女朋友，男生想女生求婚，男生的四个特点分别是不帅，性格不好，身高矮，不上进，请你判断一下女生是嫁还是不嫁？
这是一个典型的分类问题，转为数学问题就是比较p(嫁|(不帅、性格不好、身高矮、不上进))与p(不嫁|(不帅、性格不好、身高矮、不上进))的概率，谁的概率大，我就能给出嫁或者不嫁的答案！ 这里我们联系到朴素贝叶斯公式：
我们需要求p(嫁|(不帅、性格不好、身高矮、不上进),这是我们不知道的，但是通过朴素贝叶斯公式可以转化为好求的三个量.
p(不帅、性格不好、身高矮、不上进|嫁)、p（不帅、性格不好、身高矮、不上进)、p(嫁)（至于为什么能求，后面会讲，那么就太好了，将待求的量转化为其它可求的值，这就相当于解决了我们的问题！）
4 朴素贝叶斯算法的朴素一词解释
那么这三个量是如何求得？
是根据已知训练数据统计得来，下面详细给出该例子的求解过程。 回忆一下我们要求的公式如下：
那么我只要求得p(不帅、性格不好、身高矮、不上进|嫁)、p（不帅、性格不好、身高矮、不上进)、p(嫁)即可，好的，下面我分别求出这几个概率，最后一比，就得到最终结果。
p(不帅、性格不好、身高矮、不上进|嫁) = p(不帅|嫁)*p(性格不好|嫁)*p(身高矮|嫁)*p(不上进|嫁)，那么我就要分别统计后面几个概率，也就得到了左边的概率！
等等，为什么这个成立呢？学过概率论的同学可能有感觉了，这个等式成立的条件需要特征之间相互独立吧！
对的！这也就是为什么朴素贝叶斯分类有朴素一词的来源，朴素贝叶斯算法是假设各个特征之间相互独立，那么这个等式就成立了！
但是为什么需要假设特征之间相互独立呢？
1、我们这么想，假如没有这个假设，那么我们对右边这些概率的估计其实是不可做的，这么说，我们这个例子有4个特征，其中帅包括{帅，不帅}，性格包括{不好，好，爆好}，身高包括{高，矮，中}，上进包括{不上进，上进}，那么四个特征的联合概率分布总共是4维空间，总个数为2*3*3*2=36个。
36个，计算机扫描统计还可以，但是现实生活中，往往有非常多的特征，每一个特征的取值也是非常之多，那么通过统计来估计后面概率的值，变得几乎不可做，这也是为什么需要假设特征之间独立的原因。
2、假如我们没有假设特征之间相互独立，那么我们统计的时候，就需要在整个特征空间中去找，比如统计p(不帅、性格不好、身高矮、不上进|嫁),
我们就需要在嫁的条件下，去找四种特征全满足分别是不帅，性格不好，身高矮，不上进的人的个数，这样的话，由于数据的稀疏性，很容易统计到0的情况。 这样是不合适的。
根据上面俩个原因，朴素贝叶斯法对条件概率分布做了条件独立性的假设，由于这是一个较强的假设，朴素贝叶斯也由此得名！这一假设使得朴素贝叶斯法变得简单，但有时会牺牲一定的分类准确率。
好的，上面我解释了为什么可以拆成分开连乘形式。那么下面我们就开始求解！
我们将上面公式整理一下如下：
下面我将一个一个的进行统计计算（在数据量很大的时候，根据中心极限定理，频率是等于概率的，这里只是一个例子，所以我就进行统计即可）。
p(嫁)=？ 首先我们整理训练数据中，嫁的样本数如下：
则 p(嫁) = 6/12（总样本数） = 1/2
p(不帅|嫁)=？统计满足样本数如下：
则p(不帅|嫁) = 3/6 = 1/2 在嫁的条件下，看不帅有多少
p(性格不好|嫁)= ？统计满足样本数如下：
则p(性格不好|嫁)= 1/6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cedb9ced5d07ca78fbb200bcc6cb9ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd4b078dda3abe408a6ae89001536ad/" rel="bookmark">
			谷歌GDELT数据下载代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对代码进行了修改，从python2调整为python3，并对代码进行了优化。20210515
在上一篇博客谷歌GDELT数据说明中，我对GDELT数据进行了说明，在这篇文档中直接上代码，有需要的可以直接使用并下载数据，有问题欢迎留言。
GDELT提供了好几种数据，包括gkg、event、mentions等数据，我在代码中下载的是event数据，可以自己修改原始链接，代码应该可以通用，原理是一样的。
###需要注意，数据量较大，截止到2017.7.18全部下载下来需要150多GB，所以下载的时候最好下载到硬盘中，免得电脑内存不足。
# -*-coding:utf-8-*- import requests from bs4 import BeautifulSoup from datetime import datetime import zipfile import sys import multiprocessing import random import os path = os.path.split(os.path.abspath(__file__))[0] + os.sep # 获取当前文件所在目录 data_folder = path + 'data' + os.sep def get_url_list(url): '''获取页面下的所有url，保存到url_list.txt中，并返回url_list''' html = requests.get(url).text soup = BeautifulSoup(html, 'lxml') url_list = [] for li in soup.body.ul.find_all('li'): href = 'http://data.gdeltproject.org/events/' + li.a['href'] url_list.append(href) print(len(url_list)) with open(path + 'url_list.txt', 'w') as f: for url in url_list[3:-1]: # 前三个url和最后一个不是我们需要的数据，故跳过 f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fd4b078dda3abe408a6ae89001536ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c8a3ab2529b7c57bf503b049fa59f8/" rel="bookmark">
			JAVA的向上转型 和 向下转型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		向上转型 是面向对象继承的一种形式，是指子类对象转换为父类对象。
看下面的example
class Instrument { public void play() { System.out.println("Instrument play"); } static void tune(Instrument i) { // … i.play(); } } public class Test1 extends Instrument { public static void main(String [] args) { Test1 w = new Test1(); Instrument.tune(w); } } // out put Instrument play 导出类转型为基类，在继承图上是向上移动的，因此一般称为向上转型。 在向上转型的过程中，子类唯一可能发生的事情是丢失方法，子类的新有的方法都会丢掉。 向下转型： 父类引用的对象转换为子类类型称为向下转型。
看下面的代码
class Animal { public void eat() { System.out.println("Animal eat"); } } class Dog extends Animal{ @Override public void eat() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30c8a3ab2529b7c57bf503b049fa59f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dbf7a09e63a3f294dab0a408e6b7877/" rel="bookmark">
			Excel（XLS，XLSX）和CSV相互转换 - C#简单实现方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Excel（XLS，XLSX）和CSV相互转换 - C#简单实现方案
一、概述
XLS和XLSX是Excel电子表格的格式，可以包含包含文本、数值、公式和格式。而CSV则是一种通用的文件格式，它可以非常容易地被导入到各种表格和数据库中。日常工作中，我们经常需要对这几种文件格式进行相互转换，这篇文章将介绍如何使用C#和Excel组件Spire.XLS来快速实现这一功能。
二、组件下载
Spire.XLS可以通过以下几种方式下载/安装：
1. Spire产品系列官方网站: http://www.e-iceblue.cn/Introduce/Spire-XLS-NET.html
2. 在Visual Studio中的NuGet Package Manager-&gt;Manage NuGet Packages for Solution中搜索Spire.XLS并安装
三、Excel（XLS，XLSX）和CSV相互转换
XLS转XLSX
XLSX格式可选Excel 2007，2010和2013。
//载入xls文档 Workbook workbook = new Workbook(); workbook.LoadFromFile("Input.xls"); //保存为xlsx格式 workbook.SaveToFile("XlsToXlsx.xlsx",ExcelVersion.Version2013); XLS转CSV
//载入xls文档 Workbook workbook = new Workbook(); workbook.LoadFromFile(@"Input.xls"); //获取第一张工作表 Worksheet sheet = workbook.Worksheets[0]; //保存为csv格式 sheet.SaveToFile("XlsToCsv.csv",",", Encoding.UTF8); XLSX转XLS
//载入xlsx文档 Workbook workbook = new Workbook(); workbook.LoadFromFile("Input.xlsx"); //保存为xls格式 workbook.SaveToFile("XlsxToXls.xls",ExcelVersion.Version97to2003); XLSX转CSV
//载入xlsx文档 Workbook workbook = new Workbook(); workbook.LoadFromFile("Input.xlsx"); //获取第一张工作表 Worksheet sheet = workbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dbf7a09e63a3f294dab0a408e6b7877/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c13e6c216bebe73af39f2b77ab324a9e/" rel="bookmark">
			【C&#43;&#43;】成员函数重载二元和一元运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重载双目运算符时，运算符函数中应该具有两个参数，若运算符函数作为类的成员函数(当运算符重载函数作为类的成员函数时，要求操作数左边必须是一个对象，而函数的参数可以是同类的对象也可以是普通的变量)，则只需要一个参数。 双目运算符 双目运算符就是具有两个操作数的运算符。如 +、-、==等。
对双目运算符而言，成员函数重载运算符的函数参数表中只有一个参数，而用友元函数重载运算符函数参数表中含有两个参数。 成员函数重载 == 、&gt;运算符: bool operator==(CTime&amp; time); bool operator&gt;(CTime&amp; time); //判断对象的每个成员变量是否相等 bool CTime::operator==(CTime&amp; time) { if (m_nHour == time.m_nHour&amp;&amp;m_nMinute == time.m_nMinute&amp;&amp;m_nSecond == time.m_nSecond) { return true; } return false; } bool CTime::operator&gt;(CTime&amp; time) { if (m_nHour &gt; time.m_nHour) //先判断两个对象的小时数的大小 { return true; } else if (m_nHour &lt; time.m_nHour) { return false; } else //这是两个对象小时数相等的情况，接下来就判断分钟数 { if (m_nMinute&gt; time.m_nMinute) //再判断两个对象的分钟数的大小 { return true; } else if (m_nMinute &lt; time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c13e6c216bebe73af39f2b77ab324a9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ad0aaaf3a9c80227c1d15bad2e81eb/" rel="bookmark">
			项目管理的“三边六拍”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目管理的“三边六拍” 作者: Fireball 来源: 博客园 发布时间: 2012-07-27 15:54 URL：http://kb.cnblogs.com/page/119555/ 文/张传波
“三边”是指：边计划、边实施、边修改，“六拍”是指：拍脑袋、拍肩膀、拍胸口、拍桌子、拍屁股、拍大腿！“三边六拍”很形象，引人深思！
“三边六拍”并非本人原创，最开始我是从我的领导那听到的，我觉得很有意思，很形象，很贴合实际。下面介绍一下什么是项目管理“六拍”，以及我的一些感受；然后介绍“三边”和我的体会。
第一拍：拍脑袋
客户领导与软件公司领导在一起，“拍脑袋”确定了一个项目，于是项目马上就要开始了，你的麻烦马上就要来了。
“拍脑袋”主要说明的问题是没有想清楚为什么要做这个项目，不怎么考虑可行性和最终效果，就冲动地让项目上马了。
我的感受：
作为项目经理的你，往往无法干预这个“拍脑袋”的过程，你想你的领导下次拍脑袋能拍好一点，恐怕也不太可能。你能做到的事情就是，搞清楚项目的背景、搞清楚你的领导和客户的领导做这个项目的动机是什么？
项目要成功，你必须同时满足你的领导和客户的想法。当然双方领导的想法可能都不确定，这可能会让你很被动，但也给你带来机会来“控制”这些事情，前期虽然是“拍脑袋”安排这个项目，但你可以在后期充分与双方领导沟通，逐步将领导脑袋中不明确的东西明确（当然难度超高），让项目有成功的机会。
第二拍：拍肩膀
领导安排项目工作给你时，往往是语重心长地说类似这样的话：这个项目对公司如何如何重要，你是公司中非常重要的人物，这个项目没有你不能成功......拍你的肩膀，就是和你套亲切和信任，有时候还会请你甚至是项目组吃饭，表示对大家的感谢和信任。
我的感想：
咱们做软件开发的，其实是不傻的，这些门面功夫其实让我觉得很恶心，而你遇到这样的情况时，你又必须虚伪地做下面的第三拍的事情，更加恶心！但如果我是领导，我会如何安排项目工作下去呢？会不会也是这样做这些恶心的门面功夫？
第三拍：拍胸口
有些朋友，可能真的是以为领导很重视你，义无反顾的“拍胸口”保证没有问题！
有些朋友就比较聪明，他知道这个项目你是不可能推脱的（除非你想走人），但他又知道任务艰巨，他会在拍胸口的同时，要求增加人手和延长工期，往往会得到老板的一些妥协。
而我是属于比较蠢的一种，我会直接跟领导说这个项目的一些重大问题，有些项目我了解到项目“拍脑袋”过程后，我甚至会说这个项目不可能成功。我这样做往往惹领导不高兴，觉得我不听话，认为我对这个项目没有信心等等。
我的感想：
做人真难，我不是随便承诺的人，我能列出项目的具体问题，说明已经认真思考了，有问题自然有努力的方向，没有问题其实问题更大，不知道领导是怎样想的？拍胸口真的是很痛苦的事情啊！
第四拍：拍桌子
项目进展不理想，领导拍桌子骂人！
领导拍桌子骂人，可能是真的很火，忍不住拍了，也可能是要给你一种威慑感，让你更有压力的干活。
也有的领导很厉害，会忍住怒火，他知道目前只能靠你，等项目完了后才“收拾”你！
我的感想：
用工厂模式来管理软件项目，其实是很傻的做法。软件项目是充满创造力的事情，无聊的高压，往往让项目组不思考如何更简单，更少工作量，而疲于奔命，不断返工。而老板见到你拼命加班，虽然工作成功不尽理想，但至少老板心里会舒坦一些。这是多么无聊的怪现象啊！
如果遇到厉害的领导，暂时忍住怒火，继续对你“以礼相待”。有人会趁机“要挟”一把，这时候要求加薪，90%是没有问题的，但你等着项目后被开掉吧，而且可能会被开得很惨。
第五拍：拍屁股
现在不是奴隶社会，我又不是终身卖给你的，老子不打东家可以打西家，你可以发飙，老子何尝不可以！老子走人，你自己管你这个破项目吧！
我的感想：
不管东家还是西家，其实家家都是一个鬼样，你只是从一个火坑跳到另外一个火坑而已。不要轻易拍屁股，要思考自己是否值得留下来！凡事没有完美，出来打工更加不可能事事顺意，从你的职业规划思考，你值不值得继续为这个项目奋斗？当然要记住，做人要有基本的职业道德，他不仁，我不会不义！
第六拍：拍大腿
领导将项目经理气走了，项目无人打理，于是拍大腿后悔。
我的感想：
早知如此，何必当初呢？但很多领导还是不断地重复着“六拍”，领导还真的是不好当啊！
“三边”是指：边计划、边实施、边修改。
很多项目往往没有通盘规划就仓促上马，紧张的项目工期，太多的不清楚因素，项目组在高压力下，往往是见一步走一步，一边做一边修改。最终项目效果也不会很好，不但项目组痛苦，客户的利益也会受到伤害，最后结果就是“双输”了！
实际上很多项目可能逃不过“三边”命运，因为项目上马时，需求是不确定的，技术往往也是不确定的，但工期是限死的，项目的预算也很可能是限死的，在“两大限死、两不确定”的框架下，“三边”难以避免。我做过的项目，几乎都不可能从一开始就能得到全面准确的需求，都不可能在项目初期就可以制定长期而周全的计划，小版本迭代是我惯常的做法。其实敏捷就有具备“三边”的特点，不过不是“见一步走一步”，而是有一个长远的战略性规划，通过一个个小版本逐步接近我们的目标，保持灵巧的同时也能预测变化。
所以我对“三边”的感想是：“三边”不代表低水平，关键你是敏捷地“三边”还是被动地“三边”？
另，百度文库：
项目管理三边六拍 https://wenku.baidu.com/view/63c4b49503d8ce2f006623e0.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52000803616fcf40c48894ab99d203a8/" rel="bookmark">
			Java Language and Virtual Machine Specifications
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java Language and Virtual Machine Specifications url: http://docs.oracle.com/javase/specs/ 20170921
Java Language and Virtual Machine Specifications Java SE 8 The Java Language Specification, Java SE 8 Edition HTML | PDF
The Java Virtual Machine Specification, Java SE 8 Edition HTML | PDF
Java SE 7 The Java Language Specification, Java SE 7 Edition HTML | PDF
The Java Virtual Machine Specification, Java SE 7 Edition HTML | PDF | Update (March 2015)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52000803616fcf40c48894ab99d203a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fcff48281c92734d58c3ab36557072c/" rel="bookmark">
			C语言实现学生成绩管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言实现学生成绩管理系统V1.0 某班有最多不超过30人（具体人数由键盘输入），参加某门课程的考试，实现如下学生成绩管理：
录入每个学生的学号和考试成绩计算课程的总分和平均分按成绩由高到低排出名次表按学号由小到大排出成绩表按学号查询学生排名及其考试成绩按优秀（90-100），良好（80-89），中等（70-79），及格（60-69），不及格（0-59）5个类别，统计每个类别的人数以及所占的百分比 接下来直上代码
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define N 30 void Readscore(int id[],int score[],int n); int Average(int score[],int n); void Scoresort(int id[],int score[],int n); void Idsort(int id[],int score[],int n); int Selectsort(int id[],int score[],int n,int x); void Scoreclass(int score[],int n); void Showinfo(int id[],int score[],int n); int main() { int num,score[N],aver,n,sum,id[N],i,m,x,k,great=0,better=0,middle=0,low=0,lower=0; while(1){ //首页选择 printf("----------------\n"); printf("1.Input record\n"); printf("2.Caculate total and average score of course\n"); printf("3.Sort in descending order by score\n"); printf("4.Sort in ascending order by number\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fcff48281c92734d58c3ab36557072c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2230575e24b3cf6736aa522c5179ff3d/" rel="bookmark">
			示波器调试RS485通信波形图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于笔者在调试STM32移植的MODBUS协议的时候遇到了一些问题，需要借助示波器来看波形，而关于485通信波形相关的资料网上不多，所以把自己调试过程中的波形记录下来。 硬件：STM32单片机，1个主机和10个从机，移植MODBUS协议，采用轮询机制，主机挨个询问从机，从机采集一些信息回复给主机。 原理图：使用带隔离的芯片ADM2483，PA1，PA2，PA3指的是单片机的引脚，分别是使能，TXD和RXD。 代码：基本上是http://www.openedv.com/forum.php?mod=viewthread&amp;tid=98367&amp;highlight=modbus 根据自己的业务稍微做了简化和修改。 以下是主机询问以及从机回答的波形，两组。测试的是AB两线的电压差 以下是一组主机询问与从机回答的波形，中间间隔7ms左右。注意，MODBUS规定两组数据之间必须有3.5字符的间隔，我的单个字符时长大约1ms，所以这个间隔不得小于3.5ms。 以下是一个命令的波形，可以看出一个命令用时约为8ms多一点，而一个命令是8个字符，通常情况下1个字符包括1位起始位、8位数据位（一般情况）、1位校验位（或者没有，本例子没有校验位）、1位停止位（一般情况下）。也就是一个字符是10位，由此可以推算出波特率：10bit / 1.05ms X 1000 ≈ 9600 bit/s 以下两图是把波形进一步“放大”，尝试从波形里读出数据。约4格表示一个字符。 此图是上图前四格的第一个字符，也就是10位，起始位总是低电平，而结束位是高电平，8个数据位，低位在前。可以看出，第一格式起始位的低电平，接下来是连续3个高电平和5个低电平，最后一格是结束位的高电平。中间的数据位是1110 0000，由于低位在前，所以实际是0000 0111，也就是0x07 下图的黄色线是A线对地电压，蓝线是B线对地电压。为了方便观察，第一个图把两个波形完全分开了，第二个图的“地”在同一水平线上。而A减去B，也就是黄色减去蓝色，就可以得到465总线上的电压情况。可以看出，单个A或是B的波形都不是很理想，定时A-B的波形还不错。大概这就是485通信稳定的一个原因了吧。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b92ae2c2ef747e07cb12faca40edf7cc/" rel="bookmark">
			AD转移一个封装库文件到另一个封装库中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AD这款PCB EDA软件有一个很大的优点就是它的库比较多，也很容易找，现在AD官方已经给我们做好了很多库了，很多时候其实我们并不需要自己去建立元件库了，自己建库，要去元件的官网下它的手册，然后对着它的尺寸图画原理图符号和PCB符号，在那算老半天引脚的相对位置，然后画來画去的，麻烦不说，一不小心出错了，那真是欲哭无泪啊。所以，能用官方的库就用它的库吧，省事省力，还放心。要下AD10及之前版本的官方库，可以到这个网址http://techdocs.altium.com/display/ADOH/Download+Libraries去下，要下ad10之后的元件集成库，可以到这个网站https://designcontent.live.altium.com/#UnifiedComponents去下，我个人觉得最好到后面那个网址去下，因为它的集成库的数目是前面那个的超集。不过有很多老的电路图，可能还是用的以前的集成库，为了保持一致，有时也可以用前面那个。
好，现在转入正题。要将别人做好的库里面的元件转移到自己的库，需要先打开别人的库。
在右侧的面板中点击Libraries选项卡，然后在1中选择所要复制的元件所在的库，在2中可以搜索该元件。
然后在左侧面板的下方，点击SCH Library，在1的位置可以输入元件名称，快速查找元件所在的位置，然后在2中选择所要拷贝的元件，右键，copy。然后切换回自己的元件库，同样在2的位置，右键，Paste，就可以把元件复制到自己的库中了。对PCB footprint库的操作，步骤同这也是一样的，这里就不再赘述了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8446ce84575f461887b87ab5b5fccb6/" rel="bookmark">
			OpenCV实现SfM（一）：双目三维重建(包含SIFT特征点提取)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三维重建介绍 三维重建是指根据基于一个视图或者多个视图所获得的物体或者场景的图像重建三维模型的过程。由于单视图的信息很单一,因此三维重建需要更复杂的算法和过程。相比之下，多视图的三维重建(模仿人类观察世界的方式)就比较容易实现,其方法是先对摄像机进行标定,即计算出摄像机的图像坐标系与世界坐标系的关系.然后利用多个二维图像中的信息重建出三维信息
1.根据摄像机（图片）数目划分：
对于基于图像的三维重建，主要有单目视觉法、双目视觉法、多目视觉法。
基于图像的三维重建是从若干幅图片计算提取出场景和物体的三维深度信息，根据获取的三维深度信息，重构出具备很强真实感的物体或者场景的三维模型的方法。
2.单幅图像的三维重建
目前，基于单幅图像三维重建最广泛和最实用的方法利用几何投影的原理进行重建。每一幅图像中含有的大量平行线、平行面、垂直线、垂直面、消失点、消失线等多种几何属性的约束，利用图像的这些几何约束进行摄像机标定或平面标定。进而估算出摄像机的内部各种参数、摄像机的焦距； 然后通过测量目标的几何形状或计算目标高度来估算出必需的深度信息; 最后利用几何投影知识等对图像进行数字化的表述，构建数字化的三维模型，将得到的模型绘制出来，这就是整个的基于单幅图像的三维重建过程。
3.立体视觉的三维重建
立体视觉的基本原理是从两个或者多个视点观察同一景物，已获得在多个不同的视角下对景物的多张感知图像，运用三角测量的基本原理计算图像像素间位置偏差，获得景物的三维深度信息，这一个过程与人类观察外面的世界的过程是一样的。要建立完整的一个双目立体视觉系统通常大致需要经过6个步骤，分别是获得图像、标定摄像机、提取特征、立体匹配、模型重建等
4.深度图像三维重建
一般的通过激光扫描仪进行一次扫描得到的是一组二维有序的点阵，其中每一点包含了相应的场景上被扫描点的距离信息，这个点阵被称为深度图像。为了获得完整的场景，往往需要从几个不同的位置对目标场景进行扫描而得到的不同的深度图像则需要匹配到一个坐标系下。通过深度图像获得场景的数据，对点云数据进行基于平面的分割，提取平面特征实现三维场景的重
本文主要学习基于双目的立体视觉三维重建。
SfM介绍 SfM的全称为Structure from Motion，即通过相机的移动来确定目标的空间和几何关系，是三维重建的一种常见方法。它与Kinect这种3D摄像头最大的不同在于，它只需要普通的RGB摄像头即可，因此成本更低廉，且受环境约束较小，在室内和室外均能使用。但是，SfM背后需要复杂的理论和算法做支持，在精度和速度上都还有待提高，所以目前成熟的商业应用并不多。 本系列介绍SfM中的基本原理与算法，借助OpenCV实现一个简易的SfM系统。
极线约束与本征矩阵 在三维重建前，我们先研究一下同一点在两个相机中的像的关系。假设在世界坐标系中有一点 p ，坐标为 X ，它在1相机中的像为 x1 ，在2相机中的像为 x2 （注意 x1 和 x2 为齐次坐标，最后一个元素是1），如下图。 设 X 到两个相机像面的垂直距离分别为 s1 和 s2 ，且这两个相机具有相同的内参矩阵 K ，与世界坐标系之间的变换关系分别为 [R1 T1] 和 [R2 T2] ，那么我们可以得到下面两个等式 s1x1=K(R1X+T1)s2x2=K(R2X+T2) 由于K是可逆矩阵，两式坐乘K的逆，有 s1K−1x1=R1X+T1s2K−1x2=R2X+T2 设 K−1x1=x′1 ， K−1x2=x′2 ，则有 s1x′1=R1X+T1s2x′2=R2X+T2 我们一般称 x′1 和 x′2 为归一化后的像坐标，它们和图像的大小没有关系，且原点位于图像中心。 由于世界坐标系可以任意选择，我们将世界坐标系选为第一个相机的相机坐标系，这时 R1=I, T1=0 。上式则变为 s1x′1=Xs2x′2=R2X+T2 将第一式带入第二式，有 s2x′2=s1R2x′1+T2 x′2 和 T2 都是三维向量，它们做外积（叉积）之后得到另外一个三维向量 T2ˆx′2 （其中 T2ˆ 为外积的矩阵形式， T2ˆx′2 代表 T2×x′2 ），且该向量垂直于 x′2 和 T2 ，再用该向量对等式两边做内积，有 0=s1(T2ˆx′2)TR2x′1 即 x′2T2ˆR2x′1=0 令 E=T2ˆR2 有 x′2Ex′1=0 可以看出，上式是同一点在两个相机中的像所满足的关系，它和点的空间坐标、点到相机的距离均没有关系，我们称之为极线约束，而矩阵 E 则称为关于这两个相机的本征矩阵。如果我们知道两幅图像中的多个对应点（至少5对），则可以通过上式解出矩阵 E ，又由于 E 是由 T2 和 R2 构成的，可以从E中分解出 T2 和 R2 。 如何从 E 中分解出两个相机的相对变换关系（即 T2 和 R2 ），背后的数学原理比较复杂，好在OpenCV为我们提供了这样的方法，在此就不谈原理了。 特征点提取与匹配 从上面的分析可知，要求取两个相机的相对关系，需要两幅图像中的对应点，这就变成的特征点的提取和匹配问题。对于图像差别较大的情况，推荐使用SIFT特征，因为SIFT对旋转、尺度、透视都有较好的鲁棒性。如果差别不大，可以考虑其他更快速的特征，比如SURF、ORB等。 本文中使用SIFT特征，由于OpenCV3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8446ce84575f461887b87ab5b5fccb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553fa688ce3052fe4610587ff46061ea/" rel="bookmark">
			django限制用户重复登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总体思路：
找出所有有效的session，然后从session中反解出所对应的用户信息，判断当前待登陆的用户是否已存在有效的session，如果有，则代表已登陆过，否则未登录。
代码实现：
from django.contrib.sessions.models import Session from djang.utils import timezone valid_session_obj_list = Session.objects.filter(expire_date__gt=timezone.now()) logged_user_id_list = [] for session_obj in valid_session_obj_list: user_id = session.get_decoded().get("_auth_user_id") logged_user_id_list.append(user_id) #logged_user_id_list为所有已登陆的用户的id，根据id再分别获取对应的用户信息即可。复制代码 注意：
django登陆过程简化如下，验证username/password，通过之后，在django_session表中生成一条记录，正常情况下，用户点击登出的时候，django会删除刚才所生成的记录；特殊情况，用户直接关闭浏览器，此时需要将session设置成过期，需要在settings文件里设置SESSION_EXPIRE_AT_BROWSER_CLOSE = True，以此来保证关闭浏览器时退出登录，该情况下，django并不会删除所生成的记录，日积月累，django_session表中的数据越来越多，需要定期的执行python manage.py clearsessions来清除过期的session。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7ce8b97042dd6479ce5aaa67bb63d2b/" rel="bookmark">
			存储器容量、位宽及其地址线根数三者之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载于：http://blog.sina.com.cn/s/blog_498dc96f0100gc2r.html
1、存储器
Ⅰ Flash ROM: SST39VF1601
数据位宽为16位（16根数据线）；20根地址线；2M(1M*16bit)。
Ⅱ SDRAM: HY57V641620HG
数据位宽为16位（16根数据线）；12根地址线（行地址选择线有12根，列地址选择线有8根（12根的低8根）），2根bank选择线，总共有22根有效地址线；8M(4bank*1M*16bit)。
2、CPU编址：以字节（8bit）为单位
存储器编址：以其位宽为单位，也就是说每个存储器地址下的数据位数为位宽。如
8K*12bit的存储器中的12就是存储器的位宽，指每个存储器地址下数据的位数。
这个12与地址线的多少无关，8K就是指有8K个不同的地址8K=8*1024=2^? 2的多少次方等于8*1024就有多少根地址线，8=2^3, 1024=2^10, 那么8K=2^13 ，存储器地址线就为13根。
3、存储容量计量单位的换算
1M(MB,mbyte)=2^10K(KB,kbyte)=2^20B(byte);
1Mb(Mbit)=2^10Kb(kbit)=2^20b(bit)；
1字（Word）=2半字（half word）=4字节(B,byte)=4×8位(b,bit)。
4、关系的确立及举例
以上面的SST39VF1601为例，
存储容量2M=16Mbit=16*2^20bit,
地址线寻址范围：2^20*16bit(地址线根数20，位宽16)。
以上面的HY57V641620HG为例，
存储容量8M=8*8Mbit=64*2^20bit,
地址线寻址范围：2^22*16bit=64*2^20bit(地址线根数22，位宽16)。
总结：
存储器位宽表示每个地址下有多少位数据，与它的数据线根数相等；
存储器的地址线根数(N)决定了它的地址编号范围（2^N）；
存储器的位宽与它的地址线根数是没有联系的；
而存储器容量是位宽与2^N的乘积，此处单位为bit。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45a83b60853ddee691ea9b1821d345a0/" rel="bookmark">
			iis7 https站点服务 发生413错误 未显示页面,因为请求实体过大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：在开发微信小程序中，由于小程序的请求数据接口必须为https，所以在服务器的IIS7上配置了https站点并在阿里云上申请了免费证书安装到服务器上。
问题：在做图片上传时，出现了问题，当上传较大文件时，返回提示为
分析原因：在网上查阅知道了，这是因为https站点限制了上传文件的大小，所以上传的文件出现超时未上传到服务器上。
解决方法：修改IIS上的UploadReadAheadSize值
1.打开IIS管理器，在需要配置的网站主页打开“配置管理器”
2.在最上边的“节”下拉框中选择“system.webServer/serverRuntime”
3.可以看到“UploadReadAheadSize”默认值为49152，修改成你所需要的限制大小，这我修改了为10M
再进行上传就没有问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320c022d382378eacd6f7955af6202cd/" rel="bookmark">
			SENet（Squeeze-and-Excitation Networks）算法笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文：Squeeze-and-Excitation Networks
论文链接：https://arxiv.org/abs/1709.01507
代码地址：https://github.com/hujie-frank/SENet
PyTorch代码地址：https://github.com/miraclewkf/SENet-PyTorch
Sequeeze-and-Excitation(SE) block并不是一个完整的网络结构，而是一个子结构，可以嵌到其他分类或检测模型中，作者采用SENet block和ResNeXt结合在ILSVRC 2017的分类项目中拿到第一，在ImageNet数据集上将top-5 error降低到2.251%，原先的最好成绩是2.991%。
作者在文中将SENet block插入到现有的多种分类网络中，都取得了不错的效果。SENet的核心思想在于通过网络根据loss去学习特征权重，使得有效的feature map权重大，无效或效果小的feature map权重小的方式训练模型达到更好的结果。当然，SE block嵌在原有的一些分类网络中不可避免地增加了一些参数和计算量，但是在效果面前还是可以接受的。
也许通过给某一层特征配备权重的想法很多人都有，那为什么只有SENet成功了？个人认为主要原因在于权重具体怎么训练得到。就像有些是直接根据feature map的数值分布来判断；有些可能也利用了loss来指导权重的训练，不过全局信息该怎么获取和利用也是因人而异。
Figure1表示一个SE block。主要包含Squeeze和Excitation两部分，接下来结合公式来讲解Figure1。
首先Ftr这一步是转换操作（严格讲并不属于SENet，而是属于原网络，可以看后面SENet和Inception及ResNet网络的结合），在文中就是一个标准的卷积操作而已，输入输出的定义如下表示。
那么这个Ftr的公式就是下面的公式1（卷积操作，vc表示第c个卷积核，xs表示第s个输入）。
Ftr得到的U就是Figure1中的左边第二个三维矩阵，也叫tensor，或者叫C个大小为H*W的feature map。而uc表示U中第c个二维矩阵，下标c表示channel。
接下来就是Squeeze操作，公式非常简单，就是一个global average pooling：
因此公式2就将HWC的输入转换成11C的输出，对应Figure1中的Fsq操作。为什么会有这一步呢？这一步的结果相当于表明该层C个feature map的数值分布情况，或者叫全局信息。
再接下来就是Excitation操作，如公式3。直接看最后一个等号，前面squeeze得到的结果是z，这里先用W1乘以z，就是一个全连接层操作，W1的维度是C/r * C，这个r是一个缩放参数，在文中取的是16，这个参数的目的是为了减少channel个数从而降低计算量。又因为z的维度是11C，所以W1z的结果就是11C/r；然后再经过一个ReLU层，输出的维度不变；然后再和W2相乘，和W2相乘也是一个全连接层的过程，W2的维度是C*C/r，因此输出的维度就是11C；最后再经过sigmoid函数，得到s。
也就是说最后得到的这个s的维度是11C，C表示channel数目。这个s其实是本文的核心，它是用来刻画tensor U中C个feature map的权重。而且这个权重是通过前面这些全连接层和非线性层学习得到的，因此可以end-to-end训练。这两个全连接层的作用就是融合各通道的feature map信息，因为前面的squeeze都是在某个channel的feature map里面操作。
在得到s之后，就可以对原来的tensor U操作了，就是下面的公式4。也很简单，就是channel-wise multiplication，什么意思呢？uc是一个二维矩阵，sc是一个数，也就是权重，因此相当于把uc矩阵中的每个值都乘以sc。对应Figure1中的Fscale。
了解完上面的公式，就可以看看在实际网络中怎么添加SE block。Figure2是在Inception中加入SE block的情况，这里的Inception部分就对应Figure1中的Ftr操作。
Figure3是在ResNet中添加SE block的情况。
看完结构，再来看添加了SE block后，模型的参数到底增加了多少。其实从前面的介绍可以看出增加的参数主要来自两个全连接层，两个全连接层的维度都是C/r * C，那么这两个全连接层的参数量就是2*C^2/r。以ResNet为例，假设ResNet一共包含S个stage，每个Stage包含N个重复的residual block，那么整个添加了SE block的ResNet增加的参数量就是下面的公式：
除了公式介绍，文中还举了更详细的例子来说明参数增加大概是多少百分比：In total, SE-ResNet-50 introduces 2.5 million additional parameters beyond the 25 million parameters required by ResNet-50, corresponding to a 10% increase in the total number of parameters。而且从公式5可以看出，增加的参数和C关系很大，而网络越到高层，其feature map的channel个数越多，也就是C越大，因此大部分增加的参数都是在高层。同时作者通过实验发现即便去掉最后一个stage的SE block，对模型的影响也非常小（&lt;0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/320c022d382378eacd6f7955af6202cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4348f4ad3430905b2362d9024f9dc310/" rel="bookmark">
			L-Lipschitz条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.baike.com/wiki/lipschitz%E6%9D%A1%E4%BB%B6
若存在常数K,使得对定义域D的任意两个不同的实数x1、x2均有：∥f(x1)-f(x2)∥&lt;=K∥x1-x2∥成立，则称f(x)在D上满足利普希茨条件。若f(x)在 区间I上满足利普希茨条件，必定有f(x)在区间I上一致连续.上述的L*和K是某个大于零的数。对各自的定义域，这个数一定要存在。
设函数Φ(x)在有限 区间[a,b]上满足如下条件：
(1) 当x∈[a,b]时，Φ(x)∈[a,b]，即a≤Φ(x)≤b.
(2) 对任意的x1，x2∈[a,b]， 恒成立：|Φ(x1)-Φ(x2)|≤L|x1-x2|.
即Φ(x)在[a,b]上满足Lipschitz条件，L称为Lipschitz常数。利普希茨连续条件（Lipschitz continuity）是以德国数学家鲁道夫·利普希茨命名，是一个比一致连续更强的光滑性条件。直观上，利普希茨连续函数限制了函数改变的速度，符合利普希茨条件的函数的斜率，必小于一个称为利普希茨常数的实数（该常数依函数而定）。
在微分方程理论中，利普希茨条件是初值条件下解的存在唯一性定理中的一个核心条件。 利普希茨条件的一个特殊形式压缩映射，被应用在巴拿赫不动点定理中。
一条曲线上任意两点连线的斜率的绝对值都有小于某一个数。 表达式为存在 数L使得
|F(X)-F(Y)| &lt;= L*|X-Y|, for all X, Y.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be9f2f769790842885ce4eedef70215d/" rel="bookmark">
			adb命令实现自动化执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		adb命令按顺序写入txt文本文件，改后缀为bat，点击后自动按顺序运行adb指令
例如如下删除命令：
adb root
adb remount
adb shell rm -rf /data/app/com.eebbk.translation
adb shell rm /data/app/com.eebbk.translation-build-id.txt
adb uninstall /data/app/com.eebbk.translation
编辑好之后保存，再将txt文件后缀改为bat后缀，保存，点击即可自动按顺序执行！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdc06fd32899536cb3004abb54500fd3/" rel="bookmark">
			关于用MyEclipse6.6,jdk1.8，class不编译的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于项目问题，由原先的jdk1.6改为jdk1.8，将jdk1.8文件夹拷入到电脑中，修改环境变量。在MyEclipse6.6下将原先的class类删除之后引入jdk1.8，无法编译。在problems标签出现两个错误一是the project was not build since its build path is incomplete..... 二是 the type java.lang.CahrSequence cannot be resolved.it is .....同时在项目的类中一直需要build path。 经过网上搜索和分析，猜到可能是由于MyEclipse6.6不支持jdk1.8，从而导致无法编译。下载MyEclipse2016版本，重新导入项目，编译成功。但程序当中的FTPClient类在jdk1.8中重写了，原先方法无法使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7e54707f86c12fd6aee4f990b58f447/" rel="bookmark">
			HttpClient获取Cookie的一次踩坑实录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文原地址：http://www.fullstackyang.com/...，转发请注明本博客地址或segmentfault地址，谢谢！
在使用HttpClient进行抓取一些网页的时候，经常会保留从服务器端发回的Cookie信息，以便发起其他需要这些Cookie的请求。大多数情况下，我们使用内置的cookie策略，便能够方便直接地获取这些cookie。
下面的一小段代码，就是访问http://www.baidu.com，并获取对应的cookie：
@Test public void getCookie(){ CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet get=new HttpGet("http://www.baidu.com"); HttpClientContext context = HttpClientContext.create(); try { CloseableHttpResponse response = httpClient.execute(get, context); try{ System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;headers:"); Arrays.stream(response.getAllHeaders()).forEach(System.out::println); System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;cookies:"); context.getCookieStore().getCookies().forEach(System.out::println); } finally { response.close(); } } catch (IOException e) { e.printStackTrace(); }finally { try { httpClient.close(); } catch (IOException e) { e.printStackTrace(); } } } 打印结果
&gt;&gt;&gt;&gt;&gt;&gt;headers: Server: bfe/1.0.8.18 Date: Tue, 12 Sep 2017 06:19:06 GMT Content-Type: text/html Last-Modified: Mon, 23 Jan 2017 13:28:24 GMT Transfer-Encoding: chunked Connection: Keep-Alive Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform Pragma: no-cache Set-Cookie: BDORZ=27315; max-age=86400; domain=.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7e54707f86c12fd6aee4f990b58f447/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/056e6218e659f9d8543f6e30c63a5752/" rel="bookmark">
			微信小程序服务器请求和上传数据，上传图片并展示，提交表单完整实例代码附效果图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序开发交流qq群 173683895 、 526474645 ；
承接微信小程序开发。扫码加微信。 为了方便大家，下面列出微信请求服务器常用的几种方式，并附上代码和注释。
一： GET请求（最常用的） wx.request({ url: 'https://URL', //这里''里面填写你的服务器API接口的路径 data: {}, //这里是可以填写服务器需要的参数 method: 'GET', // 声明GET请求 // header: {}, // 设置请求的 header，GET请求可以不填 success: function(res){ console.log("返回成功的数据:" + res.data ) //返回的会是对象，可以用JSON转字符串打印出来方便查看数据 console.log("返回成功的数据:"+ JSON.stringify(res.data)) //这样就可以愉快的看到后台的数据啦 }, fail: function(fail) { // 这里是失败的回调，取值方法同上,把res改一下就行了 }, complete: function(arr) { // 这里是请求以后返回的所以信息，请求方法同上，把res改一下就行了 } }) 二：POST请求（我主要用于上传数据的时候用） 基本和GET比较类似，需要注意的两个地方请看注释。 var that = this //创建一个名为that的变量来保存this当前的值 wx.request({ url: '', method: 'post', data: { openid: 'openid' //这里是发送给服务器的参数（参数名：参数值） }, header: { 'content-type': 'application/x-www-form-urlencoded' //这里注意POST请求content-type是小写，大写会报错 }, success: function (res) { that.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/056e6218e659f9d8543f6e30c63a5752/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be2314e7d2765f1510707f6636d2d9e1/" rel="bookmark">
			MySQL之索引：索引字段的选取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常在建数据表的时候，通常会在WHERE，GROUP BY，ORDER BY等常用的字段上建立索引，当有多个字段时候，有一项原则就是该字段的去重后的值个数越多，索引建立的必要性越强。
这里建立一张数据表，有staff_id和leader_id两个字段，通过EXPLAIN分析可以验证哪个字段更适合做索引。
CREATE TABLE `test_index_distinct_value` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `staff_id` int(11) DEFAULT NULL, `leader_id` int(11) DEFAULT NULL, `remark` varchar(255) DEFAULT NULL, PRIMARY KEY (`Id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 插入若干条数据：
通过一条SQL先对比下staff_id和leader_id去重后的值个数与总行数的占比：
SELECT COUNT(DISTINCT(staff_id))/COUNT(*) AS staff_rate, COUNT(DISTINCT(leader_id))/COUNT(*) AS leader_rate FROM test_index_distinct_value 查找结果：
可以看到去重后的数值staff_id要高于leader_id的个数。
下面先在staff_id字段上建立索引，用EXPLAIN分析一条普通的查询SQL语句：
EXPLAIN SELECT * FROM test_index_distinct_value WHERE leader_id=2 AND staff_id=22 拆除staff_id字段上的索引，在leader_id字段上建立，继续用EXPLAIN分析分析上条查询SQL语句：
可以看出同样使用了索引查找执行同样的SQL语句，在leader_id字段上建立的索引需要扫描3行数据，而在staff_id字段建立索引时，仅需扫描1行数据，验证可去重后数值越多索引效率越高。
当然这个原则仅仅是作为一项参考，具体的还需要跟对应业务相结合。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2839d0dd3fad0ceb1287ce02c4513a6a/" rel="bookmark">
			2017年9月 bug总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.延迟加载的流程
最近在公司看见这么一段代码（做的是扫描蓝牙，并且链接的，但是业务有点复杂，我就不贴业务逻辑的代码了，只看这个延迟加载。）
private void scanLeDevice(final boolean enable) { mHandler.postDelayed(new Runnable() { @Override public void run() { Log.i("robin", "scanLeDevice--&gt;run: "); } }, 5000); try { Log.i("robin", "scanLeDevice:--&gt;try: "); mTimer = new Timer(); mTimer.schedule(new TimerTask() { @Override public void run() { Log.i("robin", "scanLeDevice:--&gt;try:--&gt;schedule:--&gt;run "); Handler h = new Handler(Looper.getMainLooper()); if (!mProgressed) { h.post(new Runnable() { public void run() { Log.i("robin", "scanLeDevice:--&gt;try:--&gt;schedule:--&gt;run --&gt;post"); if(tryTimes != 5){ tryTimes++; scanLeDevice(true); } else { tryTimes = 1; } } }); } } }, 5000); } catch(Exception e){ e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2839d0dd3fad0ceb1287ce02c4513a6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53bc25594ec8512126fff07547e51b01/" rel="bookmark">
			处理Python2.7读写文件中的中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python2.7对于中文编码的问题处理的并不好，这几天在爬数据的时候经常会遇到中文的编码问题。但是本人对编码原理不了解，也没时间深究其中的原理。在此仅从应用的角度做一下总结，
1.设置默认编码 在Python代码中的任何地方出现中文，编译时都会报错，这时可以在代码的首行添加相应说明,明确utf-8编码格式，可以解决一般情况下的中文报错。当然，编程中遇到具体问题还需具体分析啦。
#encoding:utf-8 或者 # -*- coding: utf-8 -*- import sys reload(sys) sys.setdefaultencoding(’utf8’) # 设置默认编码格式为'utf-8' 2.文件读写 文件读写中遇到中文，通常不会报错，但是最后运行结果显示乱码，给后续处理带来不便。
2.1 读文件 读文件时，如果文件路径、文件名中有中文，需要使用unicode函数将其编码为’utf-8’格式，然后再进行正常的文件读取。以我常用的pandas的read_csv函数为例，使用如下代码可以成功地读取名为“POI总表”的csv文件，保存在DataFrame数据类型的poi_list。
import pandas as pd inpath = 'C:\\POI总表.csv' **path = unicode(inpath, 'utf-8')** poi_list = pd.read_csv(path) 2.2 写文件 文件名有中文，文件名乱码 当想要将程序运行结果保存到文本文件时，文本文件的命名中如果有中文，不做处理文件名会出现乱码。利用unicode函数进行编码可解。unicode(‘中文.csv’,’utf-8’)
文件内容有中文，excel打开内容乱码 如果将包含中文的结果输出到csv文件，一般默认使用Excel打开文件时，文件内容会出现乱码，而使用文本编辑器打开不会乱码。这是因为Excel默认的编码方式为‘GBK‘，而文本编辑器默认的格式为‘utf-8’。使用codecs包在创建文件后添加语句f.write(codecs.BOM_UTF8)可解
name='语文' f = open(name+'.csv','w') f.write('123,语文') f.close() #修改编码 import codecs f = open(**unicode(name+'.csv','utf-8')**,'w') # 文件名不乱码 **f.write(codecs.BOM_UTF8) # excel打开内容不乱码的核心语句** f.write('123,语文') f.close() 输出结果：
#文件名：璇枃.csv #Excel打开 123 璇枃 #文本编辑器打开 123,语文 #改编码后 #文件名：语文.csv #Excel打开 123 语文 #文本编辑器打开 123,语文 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69d4988cd20a5f937e6dff0b85adf8fb/" rel="bookmark">
			移动web应用调试汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动web应用手机调试汇总 手机远程调试是必不可少的一个调试技能，主要用于调试真实环境、与手机原生有交互的功能、在线调试不能回显的问题；本 文主要分享手机远程调试、微信公众号调试、钉钉web应用调试、fiddler代理调试等各种调试技巧。希望对您有用。
调试要求 开发环境安卓桌面版Chrome32+安卓系统须为Android 4.4+一条USB数据线，连接电脑与移动设备，安装相应机型的USB驱动 手机远程调试操作步骤： 第一步：开启手机开发者模式 手机第一次进行调试时，一般需要开启成开发者模式；进入手机【设置】页面，找一下有没有【开发者选项】的按钮，如果没有则需要开启，步骤如下： 第二步：用USB数据线连接设备 驱动装好连接成功后，你可能会在设备上看到一个弹框请求允许使用这台计算机通过usb调试 勾选后点击“确定”。
第三步：连接Chrome浏览器调试 打开Chrome浏览器，在地址栏中输入chrome://inspect；如果USB连接成功，这时候我们可以看到移动设备的型号和设备上运行的页面和 允许调试的WebView列表 第四步：点击Webview列表中的inspect按钮进入到需要调试的页面中 如果首次进入显示的是空白页面，则需要使用翻墙软件进行翻墙后，再次点击 inspect进入页面进行调试，调试方式和技巧和在线调试是一样的。
微信公众号调试步骤 微信端的调试也和手机调试是一样的，需要用USB将chrome和手机连接，只是需要将微信端进行一些设置。
具体步骤如下： 第一步：打开微信，找到“微信公众平台”或者随便找一个公众号进入 在 输入http://debugx5.qq.com网址后点击发送，在对话框中点击这个 网址进入页面。
第二步：在打开的网页中选择 【信息】-&gt;【TBS settings】，勾选 【是否打开 TBS 内核 Inspector 调试功能】 第三步：提示重启微信，点击重启，就可以进行Chrome调试了
钉钉端调试步骤 钉钉端调试，需要下载钉钉调试版以及设置一下，点击钉钉调试版 下载安装，或直接进入钉钉开放平台 进行下载和设置
设置步骤如下： 进入“我的”(个人资料页)选择“设置”选择“通用”选择“开发者选项”打开“微应用调试” fiddler调试 fiddler调试主要用于调试客户的生产环境（如生产环境的微信公众号、钉钉web应用），以及ios端调试；原理是fiddler生 产环境中的真实请求替换成本地的文件、数据进行期望值的修改。
调试步骤如下： 第一步：电脑开启fiddler软件，并设置监听端口号 如果对fiddler的用法不是很了解，可以度娘一下；
第二步：设置手机WLAN代理
Android手机设置：长按连接的弹出以下操作 IOS设备设置： 第三步：设置fiddler的AutoResponder
如果对fiddler的高级设置不是很清楚的，可以参考fiddler高级用法
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/447/">«</a>
	<span class="pagination__item pagination__item--current">448/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/449/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>