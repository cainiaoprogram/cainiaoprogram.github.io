<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39ba585859cc8998dc9ef0ec5be34ebf/" rel="bookmark">
			lotus Proving
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用时43m 2020-01-09T15:03:13.514+0800	INFO	storageminer	storage/sectors.go:162	Sector 9 updated state to Packing 2020-01-09T15:03:13.520+0800	INFO	storageminer	storage/sectors.go:162	Sector 9 updated state to Unsealed 2020-01-09T15:14:50.905+0800	INFO	storageminer	storage/sectors.go:162	Sector 9 updated state to PreCommitting 2020-01-09T15:14:51.925+0800	INFO	storageminer	storage/sectors.go:162	Sector 9 updated state to PreCommitted 2020-01-09T15:26:25.597+0800	INFO	storageminer	storage/sectors.go:162	Sector 9 updated state to Committing 2020-01-09T15:45:33.117+0800	INFO	storageminer	storage/sectors.go:162	Sector 9 updated state to CommitWait 2020-01-09T15:46:41.776+0800	INFO	storageminer	storage/sectors.go:162	Sector 9 updated state to Proving 2020-01-09T15:46:41.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39ba585859cc8998dc9ef0ec5be34ebf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85967e7e6edfa1de04608993f8c6cdae/" rel="bookmark">
			python中的时间处理模块(二)：datetime模块之timedelta类详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、datetime模块 datatime模块是在time模块的基础之上做了封装，提供了更多更好用的类供我们使用，常用的有date、time、datetime、timedelta、tzinfo。但是为了更灵活的处理时间，最好是将time模块和datetime模块中的精髓学习到。
① date类：主要用于处理年、月、日；② time类：主要用于处理时、分、秒；③ datetime类：date类和time类的综合使用，可以处理年、月、日、时、分、秒；④ timedelta类：主要用于做时间加减的；⑤ tzinfo类：时区类；注意：tzinfo类用的不多，也就不专门讲述了，如果有需要，可以自行学习。 2、timedelta类
使用timedelta可以很方便的在日期上做天days，小时hour，分钟minute，秒second，毫秒millisecond，微妙的时间计算microsecond。如果要进行年、月的加减，则需要另外的办法。
但是这个类的使用，一定要结合date类的对象 或 datetime类的对象使用。也就是说，一定是基于这两个类的对象，进行时间的加、减。
注意：timedelta不能单独和time类的对象结合使用，这个下面会做演示。
1）案例说明：分别创建date类、datetime类的对象，然后进行时间的加减； ① 分别创建date类、datetime这两个类的对象；
from datetime import * d = date(2012,12,12) display(d) dt = datetime(2012,12,12,23,59,59) display(dt) 结果如下：
② 利用date类的对象，配合timedelta，进行时间的加减；
date类主要是用于处理年、月、日的，因此对该对象进行时间的加、减，主要是做“日(天数)”的加减。
from datetime import * d = date(2012,12,12) display(d) # 昨天 d1 = d + timedelta(days=-1) display(d1) # 明天 d2 = d + timedelta(days=1) display(d2) 结果如下：
③ 利用datetime类的对象，配合timedelta，进行时间的加减；
datetime类主要是用于处理年、月、日、时、分、秒、毫秒、微妙的，因此对该对象进行时间的加、减，主要做“日(天数)”、“时”、“分”、“秒”、“毫秒”、“微秒”、的加减。
from datetime import * dt = datetime(2012,12,12,23,59,59) display(dt) # 昨天 dt1 = dt + timedelta(days=-1) display(dt1) # 明天 dt2 = dt + timedelta(days=1) display(dt2) # 上一个小时 dt3 = dt + timedelta(hours=-1) display(dt3) # 下一个小时 dt4 = dt + timedelta(hours=1) display(dt4) # 上一秒 dt5 = dt + timedelta(seconds=-1) display(dt5) # 下一秒 dt6 = dt + timedelta(seconds=1) display(dt6) 结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85967e7e6edfa1de04608993f8c6cdae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77ce35e7737b1e5e8ce9c55291d1bbb6/" rel="bookmark">
			centos7-yum无法下载问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos7安装完之后想安装宝塔，发现无法获取资源。
查找资料后发现，是yum未注册问题，网络上提供了很多解决思路，在这里记录一下。
首先，先查找yum已安装的软件包
rpm -qa | grep yum
卸载以下软件包：
[root@wissunpp /]# rpm -e yum-3.4.3-158.el7.noarch --nodeps
[root@wissunpp /]# rpm -e yum-metadata-parser-1.1.4-10.el7.x86_64 --nodeps
[root@wissunpp /]# rpm -e yum-rhn-plugin-2.0.1-10.el7.noarch --nodeps
找到对应的软件包：http://mirrors.163.com/centos/7/os/x86_64/Packages/
[root@wissunpp /]# wget http://mirrors.163.com/centos/7/os/x86_64/Packages/python-kitchen-1.1.1-5.el7.noarch.rpm
wget http://mirrors.163.com/centos/7/os/x86_64/Packages/python-chardet-2.2.1-3.el7.noarch.rpm
wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-3.4.3-163.el7.centos.noarch.rpm
wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-metadata-parser-1.1.4-10.el7.x86_64.rpm
wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-utils-1.1.31-52.el7.noarch.rpm
wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-updateonboot-1.1.31-52.el7.noarch.rpm
wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.31-52.el7.noarch.rpm
安装软件包：
rpm -ivh python-*
rpm -ivh yum-*
新建repo配置文件
cd etc/yum.repos.d/
wget http://mirrors.aliyun.com/repo/Centos-7.repo
修改文件中的$rerverse 改为7
yum clean all yum memcache
过程中问题：
没有那个文件或者目录 -bash: /usr/bin/yum: 没有那个文件或目录
应该是yum没有安装成功，于是乎，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77ce35e7737b1e5e8ce9c55291d1bbb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57a7f4719db0d9a471125bec7e0f5b60/" rel="bookmark">
			JDK1.5的@Retention注解的使用和分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注解@Retention可以用来修饰注解，是注解的注解，称为元注解。Retention注解是RetentionPolicy类型的，是一个标准的枚举类型.这个枚举决定了Retention注解应该如何去保持，也可理解为Rentention 搭配 RententionPolicy使用。RetentionPolicy有3个值：CLASS RUNTIME SOURCE。
按生命周期来划分可分为3类：
1、RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；
2、RetentionPolicy.CLASS：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；
3、RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；
这3个生命周期分别对应于：Java源文件(.java文件) ---&gt; .class文件 ---&gt; 内存中的字节码。
那怎么来选择合适的注解生命周期呢？
首先要明确生命周期长度 SOURCE &lt; CLASS &lt; RUNTIME ，所以前者能作用的地方后者一定也能作用。
一般如果需要在运行时去动态获取注解信息，那只能用 RUNTIME 注解，比如@Deprecated使用RUNTIME注解
如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS注解；
如果只是做一些检查性的操作，比如 @Override 和 @SuppressWarnings，使用SOURCE 注解。
注解@Override用在方法上，是我们继承一个类并且要重写它的方法时候使用，当我们方法的名字出错时，编译器就会报错
注解@Deprecated，用来表示某个类或属性或方法已经过时，不想别人再用时，在属性和方法上用@Deprecated修饰
注解@SuppressWarnings用来压制程序中出来的警告，比如在没有用泛型或是方法已经过时的时候
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/314093ae6579bc35bfb5b3ca2b3d1c3c/" rel="bookmark">
			OBS 透明图 透明区域边框偏黑问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OBS 添加透明图时，比如添加圆角矩形区域透明的图时，透明区域边框会呈现偏黑色线条。
如下所示：
经排查，找到了原因：
图片区域透明使用的原理是将图片某矩形区域统一置黑色，再指定黑色为透明色，绘制到目的图片中，这样在目的图片中，矩形部分就成为了透明区域，此透明区域的实际像素值很可能为（0,0,0,0）。
OBS渲染使用的OPENGL （d3d）图形处理， 其中某些算法是根据图片的像素值 做一些算法处理，这样，当透明区域像素值和边框像素值反差较大时，会影响边框像素的颜色值，造成边框像素颜色可能会成为偏黑色。
解决方案： 自定义图片区域透明算法，修改指定区域内每个像素点的像素值，使其 RGB三色保持不变，只修改透明度，尽量减少透明区域和周边区域的像素反差，降低因反差造成的透明区域外偏黑色边框问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ec4794e126f71034230bbe07ded025f/" rel="bookmark">
			基于对话框的单实例应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍
有许许多多的文章介绍单示例应用程序的实现，这里演示一种非常简单的基于MFC对话框的应用程序，本技术可以运用到ATL/WTL和普通的win32应用程序。
实现
创建一个基于对话框的MFC工程。
打开资源文件(.rc)，找到主窗口的模板，并添加一句话。把这个窗口类注册为SINGLE_INSTANCE_APP。
IDD_SINGLEINSTANCE_DIALOG DIALOGEX 0, 0, 320, 200
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
EXSTYLE WS_EX_APPWINDOW
CLASS "SINGLE_INSTANCE_APP"
CAPTION “Single Instance Application”
FONT 8, “MS Shell Dlg”, 0, 0, 0x1
BEGIN
DEFPUSHBUTTON “OK”,IDOK,263,7,50,16
PUSHBUTTON “Cancel”,IDCANCEL,263,25,50,16
CTEXT “TODO: Place dialog controls here.”,IDC_STATIC,10,96,300,8
END
然后在InitInstance()函数起始位置加入如下代码：
//register window class name
WNDCLASS wc = {0};
wc.style = CS_BYTEALIGNWINDOW|CS_SAVEBITS|CS_DBLCLKS;
wc.lpfnWndProc = DefDlgProc;
wc.cbWndExtra = DLGWINDOWEXTRA;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ec4794e126f71034230bbe07ded025f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0398565dc2b31d3d6e337e2decdf183f/" rel="bookmark">
			lotus-storage-miner pledge-sector 远程矿工 数据流向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lotus 存储数据流向 1，数据流向 1，数据流向 时区需要保持一致 20:34
lotus-storage-miner pledge-sector 20:34
Local 0&gt;1&gt;0(2m) 22m Local 0&gt;1&gt;0(2m) Remote 0&gt;1 20:55 Sector 1110 updated state to Packing
20:55 Sector 1110 updated state to Unsealed
20:55 SERVEGETREMOTE /remote/staging/
20:55 Fetch staging 1.00 GiB 9s
20:55 Data fetched, starting computation
21:17 Push sealed 1.00 GiB 9s
21:17 Push cache 10.25 GiB 1m44s
21:17 SERVEGETREMOTE /remote/sealed/
21:17 received sealed sector
21:17 SERVEGETREMOTE /remote/cache/
21:19 received cache sector
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0398565dc2b31d3d6e337e2decdf183f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f5dc77eb4bf2be2a59378da8d0f18ce/" rel="bookmark">
			Unity | AssetBundle资源包的加密与解密（恺撒加密）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建预制体：用Sphere与Cube临时创建了一个物体，就叫Sphere吧；
二、将这个预制体Sphere打包成assetbundle包，具体介绍可点击这里进行参考（是我之前写的文章）；
选中Sphere预制体，设置AssetBundle名称为myab；点击Unity菜单栏AssetBundle/AssetBundle_Window按钮。附上本次打AB包的相关代码（此代码需要放在Editor文件夹下）： [MenuItem("AssetBundle/AssetBundle_Window")] public static void BuildAssetToWindow() { string outPath = Application.dataPath + "/../BuildAssetBundle/Window/"; CreateDir(outPath); BuildPipeline.BuildAssetBundles(outPath,BuildAssetBundleOptions.ForceRebuildAssetBundle, BuildTarget.StandaloneWindows); AssetDatabase.Refresh(); } public static void CreateDir(string path) { DirectoryInfo info = new DirectoryInfo(path); if (!info.Exists) { info.Create(); } } 3. 打包好的 AB包如下图所示：
三、对myab资源进行加密（此处用的是恺撒加密），加密后的AB包为myab_Encryption.assetbundle（后缀名可写可不写）：
private IEnumerator EncryptionAB() { WWW www = new WWW("file:///D:\\fcj\\unity2018\\VuforiaStudy\\BuildAssetBundle\\Window\\myab"); yield return www; if (www.isDone) { if (www.error == null) { byte[] bytes = www.bytes; for (int i = 0; i &lt; bytes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f5dc77eb4bf2be2a59378da8d0f18ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69312a5d8910afbb9e0c0404914e4b7d/" rel="bookmark">
			No signing certificate &#34;iOS Distribution&#34; found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		证书的私有key不对？
1证书的请求文件CertificateSigningRequest可能不是自己电脑上的
用自己的CerRequest制作完后，记得下载双击
2删除本地~/资源库/MobileDevice/Provisioning Profiles
里的原有描述文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8587cf651642cd7e976a7953cf5d2f9c/" rel="bookmark">
			利用Python进行数据归一化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用Python进行数据归一化 归一化化定义：
归一化就是要把需要处理的数据经过处理后（通过某种算法）限制在你需要的一定范围内。
归一化方法有两种形式：
一种是把数变为（0，1）之间的小数一种是把有量纲表达式变为无量纲表达式 一、归一到[0，1] class sklearn.preprocessing.MinMaxScaler(feature_range=(0, 1),
copy=True)
计算原理（参考sklearn官方文档）：
X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0)) X_scaled = X_std * (max - min) + min 这里 min, max = feature_range。也就是你要归一化的范围，默认是（0,1），即min=0,max=1;
这里axis=0，表示MinMaxScaler方法默认是对每一列做这样的归一化操作，这也比较符合实际应用。
示例代码：
from sklearn import preprocessing import numpy as np x = np.array([[3., -1., 2., 613.], [2., 0., 0., 232], [0., 1., -1., 113], [1., 2., -3., 489]]) min_max_scaler = preprocessing.MinMaxScaler() x_minmax = min_max_scaler.fit_transform(x) print(x_minmax) 运行结果： [[1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8587cf651642cd7e976a7953cf5d2f9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3f8806fcf3db4e00c146463d725247c/" rel="bookmark">
			Ubuntu安装软件时报错（报错：dpkg: 处理软件包  xxx  (--configure)时出错：  依赖关系问题 - 仍未被配置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu安装软件时报错 报错：dpkg: 处理软件包 ······ (–configure)时出错： 依赖关系问题 - 仍未被配置。 报错信息：
done! update-alternatives: 使用 /var/lib/mecab/dic/ipadic-utf8 来在自动模式中提供 /var/lib/mecab/dic/debian (mecab-dictionary) dpkg: 依赖关系问题使得 hplip 的配置工作不能继续： hplip 依赖于 cups；然而： 软件包 cups 尚未配置。 dpkg: 处理软件包 hplip (--configure)时出错： 依赖关系问题 - 仍未被配置 dpkg: 依赖关系问题使得 printer-driver-hpcups 的配置工作不能继续： printer-driver-hpcups 依赖于 cups；然而： 软件包 cups 尚未配置。 dpkg: 处理软件包 printer-driver-hpcups (--configure)时出错： 依赖关系问题 - 仍未被配置 正在设置 mysql-server (8.0.18-0ubuntu4) ... 由于已经达到 MaxReports 限制，没有写入 apport 报告。 由于已经达到 MaxReports 限制，没有写入 apport 报告。 正在处理用于 libc-bin (2.30-0ubuntu3) 的触发器 ... 正在处理用于 ureadahead (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3f8806fcf3db4e00c146463d725247c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e352fb6d9d7d468607237226f49b02/" rel="bookmark">
			APK反编译后插入调试代码动态运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 引入 当我们拿到一个APK，没有源代码，该怎么样去研究APK的核心逻辑呢？
限于运行环境的复杂，我们会首先使用静态分析的方式，大概可以想出这样一些静态分析APK的方法：
用apktool直接将APK转换为smali程序，再阅读smali代码（比较痛苦）
用dextojar将APK中的DEX转换为jar，再用JD-JUI来查看其java代码
用JEB，直接查看java或smali（JEB是收费软件，比较贵）
当我们做这样的静态分析，定位到某些关键逻辑，就要用动态调试的手段来观测某些变量的值了。
这时候，我们就会在APK中，关键逻辑的地方，插入LOG，然后运行观测，这个过程就是本文要讲述的内容。
本文的实验环境如下：
windows 10apktool_2.4.0.jarjava version “1.8.0_201” 2. 要分析的APK 我们自己写了一个很简单的APK（文件名为hello-apk.apk），后面称之为hello-apk，专门用于反编译分析。分析其他复杂APK的过程也和本文讲述的过程是一样的，只是用这个简单hello-apk，更能清晰、简洁、易懂的说明这个过程。
hello-apk的界面很简单，就是一个button，加上一个textview。当我们单击button，就会在textview上显示"Hello world! click by button!!"。其核心逻辑见下面代码
public class MainActivity extends AppCompatActivity { private int count=0; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void btn1ClickEvent(View target){ count++; TextView txt=(TextView)findViewById(R.id.mytextview);//find output label by id txt.setText("Hello world! click by button!!"); } } 这里的关键逻辑，就是函数btn1ClickEvent()中的内容，它负责处理button的click事件。
接下来我们讲解如何查看count值的过程。
3. 安装配置apktool的步骤 具体步骤参考： https://ibotpeaches.github.io/Apktool/install/
将如下链接中显示的脚本内容保存为apktool.bat
https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/windows/apktool.bat 到如下链接下载最新版本的apktool https://bitbucket.org/iBotPeaches/apktool/downloads/ 将下载的apktool重命名为apktool.jar，并与apktool.bat放在同一个文件夹，添加环境变量 本文将hello-apk与apktool.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14e352fb6d9d7d468607237226f49b02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b0319635189c2b3a88a2449660457b9/" rel="bookmark">
			线性回归损失函数求偏导（推到过程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性回归使用线性模型去拟合数据集，进行预测。线性回归的预测函数的一般形式为：
用（xi，yi）表示为第i个样本，xi，yi​分别为其特征和真实类别。
线性回归模型中，参数w的最优值为：参考
线性回归损失函数求偏导
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96f856ee302853902046ab0f18995138/" rel="bookmark">
			用Keras写出像PyTorch一样的DataLoader方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Keras
Author：Iouwill
Machine Learning Lab
数据导入、网络构建和模型训练永远是深度学习代码的主要模块。笔者此前曾写过PyTorch数据导入的pipeline标准结构总结PyTorch数据Pipeline标准化代码模板，本文参考PyTorch的DataLoader，给Keras也总结一套自定义的DataLoader框架。
Keras常规用法
按照正常人使用Keras的方法，大概就像如下代码一样：
import numpy as np from keras.models import Sequential # 导入全部数据 X, y = np.load('some_training_set_with_labels.npy') # Design model model = Sequential() [...] # 网络结构 model.compile() # 模型训练 model.fit(x=X, y=y) 虽然一次性导入训练数据一定程度上能够提高训练速度，但随着数据量增多，这种将数据一次性读入内存的方法很容易造成显存溢出的问题。所以，在开启一个深度学习项目时，一个较为明智的做法就是分批次读取训练数据。
数据存放方式
常规情况下，我们的训练数据要么是按照分类和阶段有组织的存放在硬盘目录下(多见于比赛和标准数据集)，要么以csv格式将数据路径和对应标签给出(多见于深度学习项目情形)。
数据按照类别和使用阶段存放(kaggle猫狗分类数据集)
数据按照csv文件形式给出（花朵分类数据集）
ImageDataGenerator
Keras早就考虑到了按批次导入数据的需求，所以ImageDataGenerator模块提供了按批次导入的数据生成器方法，包括数据增强和分批训练等方法。如下所示，分别对训练集和验证集调用ImageDataGenerator函数，然后从目录下按批次导入。
from tensorflow.keras.preprocessing.image import ImageDataGenerator # 数据增强 train_datagen = ImageDataGenerator( rescale=1./255, shear_range=0.2, zoom_range=0.2, horizontal_flip=True) test_datagen = ImageDataGenerator(rescale=1./255) # 从目录下按批次读取 train_generator = train_datagen.flow_from_directory( 'data/train', target_size=(150, 150), batch_size=32, class_mode='binary') validation_generator = test_datagen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96f856ee302853902046ab0f18995138/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e7bcc012b985fcdc077277a634a4cf0/" rel="bookmark">
			基于Vue和Vant-ui开发的移动端周历日期选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该周历日期选择器是在 基于Vue的小日历（支持按周切换）的基础上改造而来，对其代码进行优化，并引入了Vant-ui新增了年份和月份的选择、一键返回今日的快捷键功能，以及支持4种常用日期格式的选择。总体来说，该日期选择器适用于中小型移动端web项目，非常好用，现在我把它封装成了一个组件，有需求的同学就拿去用吧，别忘了点赞哦！
动图演示：
详细介绍和源码，请戳此链接：https://github.com/KBeginner/vue-week-datepicker
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d93ec9ff7b0a7d254388822dc90bd904/" rel="bookmark">
			MoveIt教程[10]：Motion Planning Pipeline
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MoveIt中，motion planners被设置为规划路径。然而，在很多情况下，可能希望对运动规划请求进行预处理，或者对规划的路径进行后处理[例如，对时间参数化]。在这种情况下，使用规划管道，其中链的motion planner与预处理和后处理阶段。预处理和后处理阶段称为计划请求适配器，可以通过ROS参数服务器的名称进行配置。在本教程中，将运行C++代码来实例化和调用这样的规划管道。
一.Running the Code
Roslaunch launch文件运行代码直接从moveit_tutorials：
roslaunch moveit_tutorials motion_planning_pipeline_tutorial.launch 注意：本教程使用RvizVisualToolsGui面板逐步演示。要将此面板添加到RViz，请遵循可视化教程中的说明。
过一会儿，RViz窗口应该会出现，并且看起来与页面顶部的窗口相似。要完成每个演示步骤，要么按下屏幕底部RvizVisualToolsGui面板中的Next按钮，要么在屏幕顶部的Tools面板中选择Key Tool，然后在RViz聚焦时按键盘上的N。
二.Expected Output
在RViz中，应该能够看到三种最终被重放的轨迹：
[1]robot将它的右臂移动到它前面的姿势目标
[2]robot将右臂移动到关节目标的一侧
[3]robot将它的右臂移动回它前面的初始姿势目标
三.The Entire Code
全部代码参考文献[2]。
1.Start
设置开始使用规划管道非常简单。在加载规划器之前，需要两个对象，一个RobotModel和一个PlanningScene。
将从实例化一个RobotModelLoader对象开始，该对象将在ROS参数服务器上查找robot描述并构造一个供使用的RobotModel。
robot_model_loader::RobotModelLoader robot_model_loader("robot_description"); robot_model::RobotModelPtr robot_model = robot_model_loader.getModel(); 利用RobotModel，可以构建一个保持世界状态[包括机器人]的PlanningScene。
planning_scene::PlanningScenePtr planning_scene(new planning_scene::PlanningScene(robot_model)); 现在可以设置PlanningPipeline对象，它将使用ROS参数服务器来确定要使用的请求适配器集和planning插件。
planning_pipeline::PlanningPipelinePtr planning_pipeline( new planning_pipeline::PlanningPipeline(robot_model, node_handle, "planning_plugin", "request_adapters")); 2.Visualization
MoveItVisualTools包提供了许多在RViz中可视化对象、机器人和轨迹的功能，还提供了调试工具，比如脚本的分步内省。
namespace rvt = rviz_visual_tools; moveit_visual_tools::MoveItVisualTools visual_tools("panda_link0"); visual_tools.deleteAllMarkers(); /* Remote control is an introspection tool that allows users to step through a high level script via buttons and keyboard shortcuts in RViz */ visual_tools.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d93ec9ff7b0a7d254388822dc90bd904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2546de94f2edcb0cc1b248fbd0bd8b9c/" rel="bookmark">
			超简单的内网穿透ngrok
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是内网穿透？ 首先，我们生活中的网络从应用上可以分为内网和外网；
内网就是你自己的网络环境，就你自己能访问，比如你本地测试进行的localhost；
外网就不言而喻了，你看网页，视频等这些网址都是外网。
那么什么又是内网穿透呢？简单的说就是通过访问一个外网地址，然后穿透到你的内网地址。
内网穿透有什么用？ 【情景1】
假设你写了一个代码功能，本地测试已经OK，此时，你要想让千里之外的朋友帮你测试，会怎么做呢？
A方案：如果你的朋友懂代码，你可以把代码打包发给他，让他在本地测试；
B方案：如果你的朋友不懂代码，你只能搭建一套服务器，然后放到服务器上面，让他通过外网访问进行测试；
不论是A方案还是B方案，整个过程复杂繁琐。特别是B方案，如果不会服务器部署那套，那直接白搭。
此时，ngrok 就可以派上用场了，只需要打开输入一个命令，就可以让你千里之外的朋友测试了，整个操作耗时5秒不到。
【情景2】
我们有时在对接各种授权的时候，比如微信授权，微信那边会要一个带有https的备案域名进行回调，如果你都还未申请这些东西，或者还正在申请（域名备案往往需要半个月左右），那么现在的你只能干等，以至于代码都不能写或测试。
此时，ngrok 同样可以大显身手，你可以在这个过程中，用 ngrok 给你的域名，配置到微信回调地址上，这样就不影响正常开发了。
下载 ngrok，然后双击打开。 https://pan.baidu.com/s/1vtBLsdrrW3T5DwhUzpnrSA
然后输入命令：ngrok http 8080 （8080为你的程序访问端口）
最后图中那个网址就是你要分享给别人的网址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2c83710a12584b752d85e9a63f813e3/" rel="bookmark">
			MoveIt教程[6]：Robot Model and Robot State
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本节中，将了解在MoveIt中使用kinematics的C++ API。
一.The RobotModel and RobotState Classes
RobotModel和RobotState类是允许访问rebot kinematics的核心类。
RobotModel类包含所有links和joints之间的关系，包括从URDF加载的joint限制属性。RobotModel还将robot的links和joints分成SRDF中定义的planning groups。在这里可以找到关于URDF和SRDF的单独教程：URDF和SRDF教程
RobotState包含关于robot的实时快照信息，存储joint位置和可选的速度和加速度向量，可用于获得关于robot的运动学信息，这些信息取决于robot的当前状态，比如末端执行器的雅可比矩阵。
RobotState还包含辅助功能，用于基于末端执行器位置[笛卡尔位姿]设置手臂位置和计算笛卡尔轨迹。
在本例中，将遍历使用Panda使用这些类的过程。
二.Running the Code
本教程中的所有代码都可以从moveit_tutorials包[MoveIt的一部分]编译并运行设置。
Roslaunch启动文件运行代码直接从moveit_tutorials：
roslaunch moveit_tutorials robot_model_and_robot_state_tutorial.launch 三.Expected Output
预期的输出形式如下。这些数字将不匹配，因为使用随机joint值：
ros.moveit_tutorials: Model frame: /panda_link0 ros.moveit_tutorials: Joint panda_joint1: 0.000000 ros.moveit_tutorials: Joint panda_joint2: 0.000000 ros.moveit_tutorials: Joint panda_joint3: 0.000000 ros.moveit_tutorials: Joint panda_joint4: 0.000000 ros.moveit_tutorials: Joint panda_joint5: 0.000000 ros.moveit_tutorials: Joint panda_joint6: 0.000000 ros.moveit_tutorials: Joint panda_joint7: 0.000000 ros.moveit_tutorials: Current state is not valid ros.moveit_tutorials: Current state is valid ros.moveit_tutorials: Translation: -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2c83710a12584b752d85e9a63f813e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f16c7bb4cb14c1bfaa28a0aef99113/" rel="bookmark">
			plt.scatter legend
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽，就这个scatter的legend老子费劲了很久，几个小时才查到。
事无巨细。。。。也是辛苦
参考链接，这个解决方法完美。
在t-SNE画图中老子费了好大劲，按照官方给出的实例只能在簇上标记标签，而不知道它的legend，我想画出来这个legend，这就是我自己的问题。做学问不就是如此吗？？
如图下：
突然发现画出来这个legend除了能装逼而实际并无用处，woc
标签在y中已然固定。
另外有相关问题可以加入QQ群讨论，不设微信群
QQ群：868373192 语音图像深度学习群
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46985690a6cacf2e4c7790b8674a6d77/" rel="bookmark">
			2020 嵌入式系统原理与应用技术（第2版） 期末复习 【整理】 习题1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 随堂习题1 随堂习题1 1、与个人计算机（PC）相比，嵌入式系统具有许多不同的特点。下面不属于嵌入式系统特点的是（D）。
A) 嵌入式系统与具体应用紧密结合，具有很强的专用性
B) 嵌入式系统通常包含在非计算机设备（系统）中，具有隐蔽性
C) 嵌入式系统的软硬件资源往往受到严格的限制
D) 嵌入式系统性能较低，价格也比较便宜
【解析】：与人们日常使用的个人计算机相比，嵌入式系统具有许多不同的特点。1）专用型，嵌入式系统与具体应用紧密结合，具有很强的专用型；2）隐蔽性，嵌入式系统通常总是非计算机设备（系统）中的一个部分，它们隐藏在其内部，不为人知；3）资源受限，嵌入式系统通常要求小型化、轻量化、低功耗及低成本，因此其软硬件资源受到严格的限制；4）高可靠性；5）实时性；6）软件固化。综上所述，D选项不属于嵌入式系统的特点。
2.嵌入式系统中的CPU具有一些与通用计算机所使用的CPU不同的特点，下面不是其特点的是（C）。
A) 支持实时处理
B) 低功耗
C) 高主频
D) 集成了测试电路
【解析】：嵌入式系统中的CPU一般具有4个特点：1）支持实时处理；2）低功耗；3）结构可扩展；4）集成了测试电路。因此，该题选C。
3、嵌入式系统使用的片上系统英文缩写名为SoC，下面关于SoC叙述中错误的是（D）。
A) SoC也称为系统级芯片，它是电子设计自动化水平的提高和集成电路制造技术飞速发展的产物
B) SoC芯片中既包含数字电路，也可以包含模拟电路，甚至还能包含数字/模拟混合电路和射频电路
C) SoC将嵌入式系统的几乎全部功能都集成在一块芯片中，单个芯片就能实现数据的采集、转换、存储、处理和I/O等多种功能
D) SoC的设计制造难度很大，目前还没有得到广泛使用
【解析】：随着电子设计自动化水平的提高和VLSI制造技术的飞速发展，半导体加工已经从微米、亚微米进入到深亚微米的时代，单个芯片上可以集成几亿个甚至几十亿个晶体管，因而能够把计算机或其他一些电子系统的全部电路都集成在单个芯片上，这种芯片就是所谓的片上系统。SoC芯片中既包含数字电路，也可以包含模拟电路，甚至还能包含数字/模拟混合电路和射频电路。由于SoC将嵌入式系统的几乎全部功能都集成在一块芯片中，单个芯片就能实现数据的采集、转换、存储、处理和I/O等多种功能。目前，大多数32位的嵌入式处理芯片均为SoC，SoC逐渐成为集成电路设计的主流发展趋势。综上可知，D选项不正确。
4．下面说法正确是（B ）
A. 嵌入式系统不是一个计算机系统。
B. MP3播放器是软实时的。
C. 嵌入式系统的资源受限就是嵌入式系统的体积太小。
D. 嵌入式系统的开发调试通常比通用计算机轻松容易。
嵌入式系统通常 要求小型化、轻量化、低功耗及低成本，因此其软硬件资源受到严格的限制；
5．通常所说的 32 位微处理器是指( C )
A．地址总线的宽度为 32 位 B．处理的数据长度只能为 32 位 C．CPU 字长为 32 位 D．通用寄存器数目为 32 个
6．将高速缓存分为指令缓存（I Cache）和数据缓存（D Cache）的体系结构是（B）
A．冯•诺依曼结构 B．哈佛结构
C．RISC D．CISC
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46985690a6cacf2e4c7790b8674a6d77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/068b4dc53503c1f245407165be6f7b29/" rel="bookmark">
			python numpy矩阵中令小于0的元素改为0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&gt;&gt;&gt; import numpy as np &gt;&gt;&gt; a = np.random.randint( -5, 5, ( 5, 5)) &gt;&gt;&gt; a array([[ -4, -4, -5, 2, 1], [ -1, -2, -1, 3, 3], [ -1, -2, 3, -5, 3], [ 0, -3, -5, 1, -4], [ 0, 3, 1, 3, -4]]) # 方式一 &gt;&gt;&gt; np.maximum(a, 0) array([[ 0, 0, 0, 2, 1], [ 0, 0, 0, 3, 3], [ 0, 0, 3, 0, 3], [ 0, 0, 0, 1, 0], [ 0, 3, 1, 3, 0]]) # 方式二 &gt;&gt;&gt; (a + abs(a)) / 2 array([[ 0, 0, 0, 2, 1], [ 0, 0, 0, 3, 3], [ 0, 0, 3, 0, 3], [ 0, 0, 0, 1, 0], [ 0, 3, 1, 3, 0]]) # 方式三 &gt;&gt;&gt; b = a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/068b4dc53503c1f245407165be6f7b29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09a1da55781e184a34bbd82a4eec2aa9/" rel="bookmark">
			如何快速的将OpenCV集成到自己的Android项目中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先下载官方的OpenCV-Android-SDK，我已经下载下来了，给出链接同志们自己下载OpenCV-android-sdk.zip
二、把官方SDK中的程序文件导入到自己的项目中，具体步骤如下：
导入官方SDK中的sdk/java文件夹，点击OK就行
将导入的名字改为OpenCV
点击Finish导入成功
三、导入库
在自己工程src/main下新建jinLibs，然后将下载的官方SDK中的OpenCV-android-sdk\sdk\native\libs下的文件拷贝进去
如下图所示
四、修改配置文件
1.打开Gradle Scripts，找到build.gradle（Module.OpenCV），将自己工程的build.gradle（Module.app）中的的内容拷贝到build.gradle（Module.OpenCV）中，然后修改build.gradle（Module.OpenCV）中的apply plugin: ‘com.android.application’ 改为apply plugin: ‘com.android.library’ 然后，把applicationId "com.example.mplog"这一句去掉
2.打开build.gradle（Module.app）在dependencies中加入这句话implementation project(":openCV")
在android中加入sourceSets { main { jniLibs.srcDirs = ['src/main/jniLibs'] } }
这句话，如下图所示
五、新建工程测试
下面是我的工程文件
MainActivity.java
package com.xp.opencvtest; import androidx.appcompat.app.AppCompatActivity; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.ImageView; import android.widget.Toast; import org.opencv.android.BaseLoaderCallback; import org.opencv.android.LoaderCallbackInterface; import org.opencv.android.OpenCVLoader; import org.opencv.android.Utils; import org.opencv.core.CvType; import org.opencv.core.Mat; import org.opencv.imgproc.Imgproc; public class MainActivity extends AppCompatActivity implements View.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09a1da55781e184a34bbd82a4eec2aa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5beb1873298e096e2f07f769f8521ab/" rel="bookmark">
			Android资源管理框架-------之AssetManager2总述（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android对于资源管理这个模块的折腾从Android-Lollipop开始就从未停止过：Android-Lollipop引入了Runtime Resources Overlay，但是bug比较多，多得根本不能用；Android-Marshmallow算是修正了这些bug，Runtime Resources Overlay终于可以生效了。然而，从Android-Nougat开始，到Android-Oreo，再到Android-Pie，这三个版本又对整个Android资源管理模块进行了彻彻底底的重构。比如，在Android N中引入了aapt2，将Android资源的编译分成了两个过程：编译和链接，并将之前的架构彻底推翻重建，另外，ResourcesManager类和Resources也大变样，功能增强不少；Android O中引入了AssetManager2，将AssetManager中ResTable相关的概念彻底废除，引入了更加直观的ApkAssets、LoadedArsc、LoadedPackage等概念，并且增加了OverlayManagerService等系统服务。但是在这个版本中，AssetManager2只是增加了相关代码，并未真正启用，真正使用的还是原来的AssetManager；在Android P中，java层引入了ApkAssets相关的接口，AssetManager2真正替换掉了原来的AssetManager；到了android-10，又引入了overlay相关的策略来增加安全控制。至此，Android资源管理模块算是完成了重构。其中AAPT2算是对AAPT的推倒重建，两者之间没有依赖关系，所以我们后面可以不用学习AAPT了，毕竟它只是一个过了时的编译工具（说实话，我还是挺喜欢aapt那种代码风格的，对aapt2的风格却不怎么喜欢）；但AssetManager2和AssetManager相比，并非一个单独的模块，它本身就是继承自AssetManager的（可能是为了兼容吧），它的代码仍然和AssetManager的放在一起，它仍然使用了原来AssetManager中的不少数据结构，所以，前面我们介绍了那么多AssetManager相关的东西，还是非常有必要的。AssetManager2的代码，我们基于目前最新的Android 10来分析。
相同点 有了前面AssetManager的基础，AssetManager2理解起来就会容易得多。其实在资源的获取方面，AssetManaager2的思路和流程与AssetManager相比，基本是一致的：根据资源id，分别得到PackageId、typeIndex、entryIndex；根据PackageId找到对应PackageGroup的索引，进而得到对应的PackageGroup；从对应的PackageGroup中根据typeIndex拿到该PackageGroup中所有包该类型的资源；遍历这些资源，根据entryIndex，从中选取最符合设备当前配置的entry；如果有资源共享库，还需要查一下DynamicReferenceTable，将动态引用转化为静态引用；如果有必要，还要把得到的静态引用解析一下，大概就是这么个流程。
不同点 然后，我们重点说说AssetManager2的不同吧。首先就是代码风格了，这个我适应了很久。按道理说，同一个模块的代码，整体风格应该保持一致吧。但看看AssetManager2，再看看AssetManager，我还以为我看错了，感觉就像一个人上半身西装领带，下半身拖鞋裤衩一样，违和感太强了，哈哈。
我们知道AssetManager在native层，有大量的代码放在ResourceTypes.cpp(以及ResourceTypes.h)中，AssetManager2则对这部分代码做了整理，从中抽取出了部分代码单独存放，这样结构显得清晰了一些。总体来讲，AssetManager的一些关键类比较庞大，而AssetManager2中则对它们做了拆分。
当然，最重要的在于，AssetManager2的整体架构和AssetManager完全不一样，资源的组织方式也完全不同。在AssetManager中，资源的核心处理逻辑都是放在ResTable这个类中的；而在AssetManager2中，则完全废弃了这个类，而是把资源处理的核心逻辑直接放到了AssetManager2这个类中。同时引入了ApkAssets、LoadedArsc、LoadedPackage等类，来分担原来ResTable的功能。特别是ApkAssets概念的引入，它会直接影响到应用层的API。比如，Android P以及以后的版本中AssetManager类增加了Builder类，应用层也新增了ApkAssets类，用来创建AssetManager对象。也就是说，ApkAssets的概念是从应用到底层贯穿整个资源管理模块的。
新增主要文件 frameworks/base/libs/androidfw/include/androidfw/AssetManager2.h
frameworks/base/libs/androidfw/AssetManager2.cpp
AssetManager2类是AssetManager的子类，可以认为相当于之前的AssetManager + ResTable，由于没有了ResTable类，所以AssetManager2做了部分ResTable的工作。
frameworks/base/core/java/android/content/res/ApkAssets.java
frameworks/base/libs/androidfw/include/androidfw/ApkAssets.h
frameworks/base/libs/androidfw/ApkAssets.cpp
一个ApkAssets对应于一个APK包，ApkAssets关注的重点在于这个包里的resources.arsc以及这个APK包对应的idmap文件（如果有的话）。另外，ApkAssets也是AssetManager2中非常重要的概念，之前版本的资源管理模块中没有数据结构与之对应。
frameworks/base/libs/androidfw/include/androidfw/LoadedArsc.h
frameworks/base/libs/androidfw/LoadedArsc.cpp
这两个文件中定义了两个非常重要的类LoadedArsc和LoadedPackage。一个LoadedArsc对应于一个APK中的resources.arsc文件。我们知道一个resources.arsc中只有两种数据结构，一个是Global String Pool，一个是Package，LoadedArsc的内容也是如此。一个LoadedPackage则对应于一个LoadedArsc中的（或者说resources.arsc中的）Package，我们可以简单认为它相当于之前版本的资源管理模块中的ResTable::Package。
frameworks/base/libs/androidfw/include/androidfw/Idmap.h
frameworks/base/libs/androidfw/Idmap.cpp
从之前的ResTable中分拆出来的idmap文件解析相关的逻辑被放到了这两个文件中。
frameworks/base/libs/androidfw/include/androidfw/AttributeFinder.h
frameworks/base/libs/androidfw/include/androidfw/AttributeResolution.h
frameworks/base/libs/androidfw/AttributeResolution.cpp
Theme和style相关，从之前的Theme相关模块中分离出来的，主要用于属性的查找和解析。
关键数据结构 // framework/base/libs/androidfw/include/androidfw/AssetManager2.h class AssetManager2 { //...... 省略非关键代码 //用来存储该AssetManager2已经加载的所有APK包 std::vector&lt;const ApkAssets*&gt; apk_assets_; /** * 用来将apk_assets_分组，概念和之前的ResTable::PackageGroup一样 * 主要还是用来处理Runtime Resources Overlay的 * 但它内部的结构已经完全和ResTable::PackageGroup不一样了 */ std::vector&lt;PackageGroup&gt; package_groups_; /** * 叫package_ids_很容易让人费解，感觉还是叫package_map比较合适 * 因为它和ResTable::mPackageMap的作用一模一样 * 它的key表示APK包也就是ApkAssets的id，比如应用是0x7f，系统是0x01等 * 它的value表示PK包也就是ApkAssets所在的PackageGroup在package_groups_中的索引 */ std::array&lt;uint8_t, std::numeric_limits&lt;uint8_t&gt;::max() + 1&gt; package_ids_; //表示设备当前的配置信息，相当于ResTable::mParams ResTable_config configuration_; /** * 相当于ResTable::PackageGroup::bags，用来缓存资源的Bag * 它的key表示一个资源的id，比如一个style，一个array * 它的value 表示已经从resources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5beb1873298e096e2f07f769f8521ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c69ed5d3aa93fdc56d285c4a8526b27f/" rel="bookmark">
			依赖倒置原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 定义 依赖倒置原则（Dependence Inversion Principle，DIP）是Object Mentor公司总裁罗伯特·马丁（Robert C.Martin）于1996年在C++ Report上发表的文章。
依赖倒置原则的原始定义：高层模块不应该依赖底层模块，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules should not depend upon low level modules.Both should depend upon abstractions.Details should not depend upon details.Details should depend upon abstractions）。
2. 核心思想 依赖倒置原则的核心思想是：要面向接口编程，不要面向实现编程。
3. 重要性 依赖倒置原则是实现开闭原则的重要途径之一，它降低了功能使用模块与功能提供模块之间的耦合度。
在软件设计中，细节具有多变性，抽象则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。
4. 作用 依赖倒置的主要作用如下：
1. 降低类间的耦合度
2. 提高系统的稳定性
3. 降低并行开发的风险
4. 提高代码可读性和可维护性
5. 实现方法 依赖倒置原则的目的是通过面向接口编程来降低类间的耦合度，所以我们在实际编程中要遵循以下4点：
每个类尽量提供接口或抽象类，或者两者都具备。变量的声明类型尽量是接口或者抽象类。任何类都不应该从具体类派生。使用继承时尽量遵循里氏替换原则。 6. 如何理解 下面以“顾客购物程序”为例来说明依赖倒置原则的应用。
【例1】依赖倒置原则在“顾客购物程序”中的应用。
分析：本程序反映了“顾客类”与“商店类”的关系。商店类中有sell()方法，顾客类通过该方法购物，以下代码定义了顾客类通过韶关网店 ShaoguanShop 购物：
class Customer
{
public void shopping(ShaoguanShop shop)
{
//购物
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c69ed5d3aa93fdc56d285c4a8526b27f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7fe17a1fafe7986a259236644f22f85/" rel="bookmark">
			Android AndPermission获取权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具类PermissionUtils
网上找来的
package com.baidu.map.demo; import android.content.Context; import android.os.Build; import com.yanzhenjie.permission.AndPermission; /** * Android权限申请工具类 */ public class PermissionUtils { /** * 注释：权限申请回调 */ public interface PermissionListener { void onSuccess(Context context); void onFailed(Context context); } /** * 注释：应用相关组权限 */ public static void applicationPermissions(Context context, PermissionListener listener, String[]... permissions) { if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.M) { if (!AndPermission.hasPermissions(context, permissions)) { AndPermission.with(context) .runtime() .permission(permissions) .rationale((mContext, data, executor) -&gt; { //选择显示提示弹窗 executor.execute(); }) .onGranted((permission) -&gt; { listener.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7fe17a1fafe7986a259236644f22f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95261a3d9fb77350018939e462a23e02/" rel="bookmark">
			基于SSM框架的web入门项目(五)学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配合哔哩哔哩视频学习【SSM 框架】SpringMVC+Spring+Mybatis SSM 整合+实战+源码13集
5.MyBatis整合Spring-整合JDBC事务 5.1.修改applicationContext.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 读取jdbc.properties --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 创建DataSource --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="url" value="${jdbc.url}"/&gt; &lt;property name="driverClassName" value="${jdbc.driverClass}"/&gt; &lt;property name="username" value="${jdbc.user}"/&gt; &lt;property name="password" value="${jdbc.password}"/&gt; &lt;property name="maxActive" value="10"/&gt; &lt;property name="maxIdle" value="5"/&gt; &lt;/bean&gt;	&lt;!-- 创建SqlSessionFactory对象 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 关联连接池 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- 加载sql映射文件 --&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95261a3d9fb77350018939e462a23e02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b3ef9a896f5026ef6f98e3d34e1fdfb/" rel="bookmark">
			Auto.js 实现钉钉实时抢红包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		又到一年年会的环节了，每次都嫌自己手速慢？那就开挂本吧！
仅供学习使用，请勿传播：
测试下载地址：https://pan.baidu.com/s/1jradOvFF9-z53ycNaUd8MQ 密码:r8rh
使用方法APP里面有说明：
下面上最关键的核心代码：一下基于Auto.js pro 8实现！
toast("开启监听") function tractHongBao() { while (true) { // sleep(50); let chatView = id("list_view").findOnce(); if (chatView != null) { for (let i = chatView.children().length - 1; i &gt; 0; i--) { let child = chatView.children()[i]; if (child != null) { let targetP = child.findOne(id("chatting_content_view_stub")); if (targetP != null &amp;&amp; targetP.desc().startsWith("[红包]")) { //需要再判断 是否领取过 let childs = targetP.children(); if (childs.length &gt; 0) { let readBaba = childs[0]; let papaInside = readBaba.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b3ef9a896f5026ef6f98e3d34e1fdfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c2c165e9aed4988decba323ece1026e/" rel="bookmark">
			! [rejected] master -&gt; master (fetch first)问题的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在做git push时出现了如下错误
分析原因，基本上可以确定是因为github上的远程库与本地库版本不一致（我对github上的文件做了编辑操作，且未更新到本地，当然也可能还有其他原因…），通过一番研究，找到了两种解决方案：
温柔型方案：
通过git pull 先将本地库更新到与远程库一致的版本，但要注意本地库后来做的修改可能被覆盖，最好使用git fetch(不会自动合并)，查看更新情况再有选择合并，或者先将本地库修改过的文件备份，git pull后再重新修改；
再运行git push即可成功。
暴力型方案：
git提供了一种强制上传的方式：git push -f ，它会忽略版本不一致等问题，强制将本地库上传的远程库，但是一定要谨慎使用，因为-f会用本地库覆盖掉远程库，如果远程库上有重要更新，或者有其他同伴做的修改，也都会被覆盖，所以一定要在确定无严重后果的前提下使用此操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495664b17f421fd90f2abf3db1e99093/" rel="bookmark">
			python 网络编程 struct解包时报错 struct.error: unpack requires a buffer of 4 bytes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息 D:\Donta_tensorflow-yolov3\python\python.exe D:/10_gitee/network_programming/避障程序信号及图像接收端/201003_避障程序信号及图像接收端_测试udp传输上限.py b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00\xff\xdb\x00C\x00\x02\x01\x01\x01\x01\x01\x02\x01\x01\x01\x02\x02\x02\x02\x02\x04\x03\x02\x02\x02\x02\x05\x04\x04\x03\x04\x06\x05\x06\x06\x06\x05\x06\x06\x06\ ... 65507 Traceback (most recent call last): File "D:/10_gitee/network_programming/避障程序信号及图像接收端/201003_避障程序信号及图像接收端_测试udp传输上限.py", line 87, in &lt;module&gt; receive() File "D:/10_gitee/network_programming/避障程序信号及图像接收端/201003_避障程序信号及图像接收端_测试udp传输上限.py", line 40, in receive data_size = struct.unpack('i', buffer)[0] struct.error: unpack requires a buffer of 4 bytes Process finished with exit code 1 这是因为传给unpack()函数的buffer参数本应为4个字节的，结果传了60000多个字节，所以就会报此错误
解决办法 给传入参数加一个 recvfrom()函数的bufsize参数加一个判断就行了，如果长度不是4，就continue跳过
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/916c21596852b46ff0f3804c8479a76b/" rel="bookmark">
			idea中properties文件如何显示中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4688e94f444b25a28697a76594937a06/" rel="bookmark">
			JDK11 HttpClient
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 11的HttpClient 小示例:
import java.net.URI; import java.net.http.*; import java.net.http.HttpClient.Redirect; import java.net.http.HttpClient.Version; import java.time.Duration; /* @author dhing */ public class Test1{ public static void main(String[] args) throws Exception { var client = HttpClient.newBuilder() .version(Version.HTTP_1_1) .followRedirects(Redirect.NORMAL) .connectTimeout(Duration.ofSeconds(20)) .build(); HttpRequest request = HttpRequest.newBuilder() .uri(URI.create("https://www.baidu.com")) .build(); HttpResponse response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response); System.out.println(response.body()); } } 参考文档： https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpClient.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26f93e5fdb146bc9e438a098712d9e16/" rel="bookmark">
			ES(elasticsearch)安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装过程基本来自互联网, 有一个小问题需要解决.
centos中
ulimit -n (默认是1024), ES需要65536, 所以我们需要修改.
修改的方法, 网上有很多, 大多都不可用.
本人试坑后, 以下可用.
vim /etc/security/limits.conf
添加配置如下：
es(网上大多是*, 导致不生效) soft nofile 65536
es hard nofile 131072
es soft nproc 4096
es hard nproc 4096
作者：有梦想永远年轻
链接：https://www.jianshu.com/p/15d31cf30154
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
一、ES安装需求
硬件环境: Centos7 软件环境: JDK8
二、ES安装(来自网上, 可用)
1.下载elasticsearch
官网可以直接下载，可以选择最新版本，也可以下载历史版本（箭头所示为历史版本），本案例中选择的是6.2.4版本
2.安装elasticsearch
2.1.上传压缩包并解压
tar zxvf elasticsearch-6.2.4.tar.gz
目录重命名：mv elasticsearch-6.2.4 elasticsearch
2.2.创建ES用户
默认ES 6.X 是不允许root用户运行的，否则ES运行的时候会报错，所以我们需要创建新的用户
命令：useradd es
命令：passwd es（设置密码）
修改权限 ： chown -R es:es elasticsearch-6.2.4
切换用户：su es
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26f93e5fdb146bc9e438a098712d9e16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bde1cd6907205f91e5ab5d3fc82a891/" rel="bookmark">
			概率统计——三扇门游戏与贝叶斯定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文首发于公众号：TechFlow
在概率论的课本上有一个经典的问题，一直困扰我很久。有很多次我以为我想明白了，过了一段时间却又会糊涂。这个问题学过概率论的同学想必都知道，就是著名的三扇门问题。
说是之前在美国有一个著名的综艺节目，这个节目里有三扇关闭着的门。其中有两扇的后面是山羊，有一扇则放着一辆豪车。主持人会让嘉宾做出选择，嘉宾做出选择之后，主持人会打开其中错误的一扇门，询问嘉宾：伙计，你有一次更改选择的机会，你要使用吗？
节目的效果如何我们不谈，但是背后的数学问题却很有意思。我们更改或者不更改选择，究竟分别有多大的赢面呢？
我们从直觉来分析，我们更不更换答案应该不会影响。毕竟三扇门里有一个正确答案，主持人排除的是错误答案，也就是说正确答案就在剩下的两个门里。不管我们换不换选择，门后是大奖的概率都应该是二分之一才对。但是书上的答案是如果不更换的话，获奖的概率是三分之一，而更换的话，获奖的概率高达三分之二。
这个答案显然和我们的直觉违背，所以，我们去探究一下其中隐藏的深层次的数学原理就很有必要了。实际上，这也是概率论当中理解条件概率和贝叶斯公式非常重要的一个例题。
条件概率 条件概率大家都不陌生，我们在很早的时候就在数学课上学过。
简单来复习一下，假设在样本空间当中存在A、B两个事件。如果A、B两个事件之间没有任何关联，那么就认为它们是独立事件。比如说，如果把我今天早上喝了牛奶当做事件A，我这篇文章转发量超过10当做事件B。显然这两个事件没有任何关联，我喝不喝牛奶完全不会影响文章的转发量。那么就叫做这两个事件是独立事件：
P ( A B ) = P ( A ) P ( B ) P(AB)=P(A)P(B) P(AB)=P(A)P(B)
当然也会存在两个事件彼此有关联的情况，比如我早上喝牛奶和我上班有没有迟到很有可能就是关联事件。因为早上喝牛奶要花时间，很有可能会影响是否迟到。在这个时候P(AB)和两个事件都有关联，就不只是简单的乘积了。
如上图所示，当AB两个事件不是独立事件的时候。P(AB)指的就是AB两个事件的交集，可以认为成在B事件发生的前提下A事件发生，或者是A事件发生的前提下，发生B事件。
概率论上将某件事发生的前提下另一件事发生的概率称为条件概率，写作P(B|A)。
我们把前文的结论写成公式：
P ( A B ) = P ( A ) P ( B ∣ A ) = P ( B ) P ( A ∣ B ) P ( B ∣ A ) = P ( A B ) P ( A ) = P ( B ) P ( A ∣ B ) P ( A ) P(AB)=P(A)P(B|A)=P(B)P(A|B)\\ P(B|A)=\frac{P(AB)}{P(A)}=\frac{P(B)P(A|B)}{P(A)} P(AB)=P(A)P(B∣A)=P(B)P(A∣B)P(B∣A)=P(A)P(AB)​=P(A)P(B)P(A∣B)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bde1cd6907205f91e5ab5d3fc82a891/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecbf8265df458346043a1161d38c368c/" rel="bookmark">
			Android开发学习之路--XPosed插件开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Xposed插件Hello World 新建工程：MyXposed引入xposed: provided 'de.robv.android.xposed:api:82' provided 'de.robv.android.xposed:api:82:sources' 官方链接
修改AndroidManifest
在AndroidManifest中修改如下： &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;!-- 应用为模块 --&gt; &lt;meta-data android:name="xposedmodule" android:value="true" /&gt; &lt;!-- 版本信息 --&gt; &lt;meta-data android:name="xposedminversion" android:value="82" /&gt; &lt;!-- 模块描述 --&gt; &lt;meta-data android:name="xposeddescription" android:value="Xposed Test" /&gt; &lt;/application&gt; 新建xpose_init 新建assets文件夹，并在该文件夹中新建xposed_init文件，在文件中添加启动的main：
com.jared.myxposed.Main 新建Main 在对应的包名下新建Main类，添加代码如下：
class Main : IXposedHookLoadPackage { override fun handleLoadPackage(lpparam: XC_LoadPackage.LoadPackageParam?) { XposedBridge.log("Main: " + lpparam?.packageName) XposedBridge.log("Hook已经成功了") } } 这里打印了包名。
编译安装 因为android studio运行需要MainActivity，所以在工程下命令行运行
./gradlew app:assembleDebug virtualxposed下安装MyXposed,安装完成如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecbf8265df458346043a1161d38c368c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2afaf5c8d19e4f50e3a8fdeefad7cf09/" rel="bookmark">
			代码提交Git时CRLF与LF转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows下文件换行符为’\r\n’，为CRLF格式
Linux下文件换行符为’\n’，为LF格式
IDEA、PyCharm下操作文件，换行符为CRLF（可通过设置进行修改）
1、提交git时可进行config配置，使得CRLF与LF格式进行自动转换
git config –global core.autocrlf true #提交时转换为LF，检出时转换为CRLF
因此，可以在IDEA、PyCharm下执行上述配置命令
2、然后，在Linux环境下，执行git config --global core.autocrlf false
这样，当在Linux进行pull时，不会进行转换，直接为LF格式；
push代码时也无需进行转换，因为Linux下生成的文件换行符本身就是’\n’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9213d1632f299edd10705bd5fc00d72/" rel="bookmark">
			Sort和PageRequest方法过时问题的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 过时方法：
Sort sort = new Sort(Sort.Direction.DESC,"updateTime"); Pageable pageable = new PageRequest(0, size, sort); 在不运行的时候就会报错：
解决方法：
Sort sort = Sort.by(Sort.Direction.DESC, "blogs.size"); Pageable pageable= PageRequest.of(0, size, sort); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c64da532496a4942e79536f2baeb63e4/" rel="bookmark">
			接口_新浪财经期货行情新查询接口API[博]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		旧接口地址:http://hq.sinajs.cn/list=TICKER
字段含义:
1 这个字符串由许多数据拼接在一起，不同含义的数据用逗号隔开了，按照程序员的思路，顺序号从0开始。 2 0：豆粕连续，名字 3 1：145958，不明数字（难道是数据提供商代码？） 4 2：3170，开盘价 5 3：3190，最高价 6 4：3145，最低价 7 5：3178，昨日收盘价 （2013年6月27日） 8 6：3153，买价，即“买一”报价 9 7：3154，卖价，即“卖一”报价 10 8：3154，最新价，即收盘价 11 9：3162，结算价 12 10：3169，昨结算 13 11：1325，买 量 14 12：223，卖 量 15 13：1371608，持仓量 16 14：1611074，成交量 17 15：连，大连商品交易所简称 18 16：豆粕，品种名简称 19 17：2013-06-28，日期 参考帖子:新浪期货接口:https://blog.csdn.net/qq_37193537/article/details/89359425
但旧接口已经不再维护了,部分品种旧接口无法查询到数据(结果空,比如NR,20号胶)
新接口地址:https://hq.sinajs.cn/list=nf_NR2003(相比旧接口,品种代码前多了nf_前缀)
响应数据含义:
1 var hq_str_nf_NR2003= 2 0,20号胶2003 3 1,112959 4 2,10780.000,开盘价 5 3,10930.000,最高 6 4,10710.000,最低价 7 5,0.000,结算价 8 6,10700.000,买价 9 7,10715.000,卖价 10 8,10710.000,最新价 11 9,0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c64da532496a4942e79536f2baeb63e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a924e4ff238e8f4f5cb0bc6158920599/" rel="bookmark">
			Git：如何在项目提交历史中查找已删除的文件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		曾几何时，我的项目中现在有一个文件，我现在希望能够得到。 问题是：我不知道何时删除它以及它在哪条路径上。 如何找到该文件的提交？ #1楼 无法编辑接受的回复，因此在此处将其添加为答案， 要恢复git中的文件，请使用以下命令（注意SHA后面的'^'符号） git checkout &lt;SHA&gt;^ -- /path/to/file #2楼 获取已删除文件的列表，并复制已删除文件的完整路径 git log --diff-filter=D --summary | grep delete 执行下一个命令以查找该提交的提交ID，并复制提交ID git log --all -- FILEPATH 显示已删除文件的差异 git show COMMIT_ID -- FILE_PATH 请记住，您可以使用&gt; like将输出写入文件 git show COMMIT_ID -- FILE_PATH &gt; deleted.diff #3楼 下面是一个简单的命令，开发人员或git用户可以从存储库根目录传递已删除的文件名并获取历史记录： git log --diff-filter=D --summary | grep filename | awk '{print $4; exit}' | xargs git log --all -- 如果有人可以改善命令，请执行。 #4楼 @琥珀给出了正确的答案！ 仅此一项，如果您不知道文件的确切路径，则可以使用通配符！ 这对我有用。 git log --all -- **/thefile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a924e4ff238e8f4f5cb0bc6158920599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adb4ef42f2d17a2a5aad6f585d0c0697/" rel="bookmark">
			机器学习基础——一文讲懂中文分词算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前文当中，我们介绍了搜索引擎的大致原理。有错过或者不熟悉的同学，可以点击下方的链接回顾一下前文的内容。
ML基础——搜索引擎基本原理
在介绍爬虫部分的时候，我们知道，爬虫在爬取到网页的内容之后，会先进行一些处理。首先要做的就是过滤掉HTML当中的各种标签信息，只保留最原生的网页内容。之后，程序会对这些文本内容提取关键词。
今天我们就来讲讲关键词提取当中最重要的一个部分——中文分词。
在世界上众多的语言当中，中文算是比较特殊的一种。许多语言自带分词信息，比如英文，机器学习写作machine learning。machine和learning之间自带一个空格作为分隔。但是中文不是这样，汉字之间没有任何分隔符。意味着程序没有办法直接对文本进行分割。
那么我们怎么知道“机器学习”这四个字应该分割成机器和学习而不是机和器学习或者是机器学和习呢？
这就需要中文分词算法。
目前常用的分词算法主要分为两大类，一种是基于词表的规则分词算法。另一种则是在机器学习以及深度学习兴起之后流行起来的统计分词算法。我们先从比较容易理解的规则分词算法开始讲起。
规则分词算法的核心是词表，我们维护一个尽可能大的词表， 当中尽可能多的包含各种中文的词语。在切分语句的时候，我们将句子当中的每个短语都去词表当中检索。如果能够检索到，说明这的确是一个词语，则进行切分，否则则不切分。
这个很好理解对吧，我们继续往下。
但是我们切分语句的时候，其实有两种顺序，既可以正向切分，也可以反向切分。根据切分方向的不同，产生了两种比较类似的算法。
正向最大匹配算法 正向最大匹配算法的思路非常简单，我们每次尽量找尽可能长的词语。假设中文的词库当中最长的词语长度是n个字，那么我们每次从文本的前n个字开始查找词表， 如果找到了，那么显然这n个字就是一个单独的单词。如果没找到，那么缩减一位，查找前n-1个字，如此循环往复，直到在词表当中找到单词为止。
这时候， 我们从匹配结束的位置继续往下，一直到整个句子分词完毕。整个过程非常简单，理论上来说我们人类阅读句子的时候，就是按照这个顺序。但是这个算法并不是完美的，当中隐藏着问题。
举个最经典的例子，假设当前的句子是“南京市长江大桥”。假设我们词库当中单词的最长长度是5，那么我们第一次切分的结果是“南京市长江”，词表当中并没有这个词，于是会切分“南京市长”，词表当中的确有这个词，那么整个句子就会切分成“南京市长”和“江大桥”这两个部分。如果“江大桥”不被当做人名，那么会继续切分成“江”和“大桥”。
这显然是不对的，会发生这个问题的原因也很简单，因为中文当中存在歧义。尤其是掺杂人名的时候，因为人名数不胜数，不可能都包容在词表当中。如果真的包容了，也会很有问题。
逆向最大匹配算法 为了解决正向匹配算法当中的问题，人们又想出了逆向最大匹配算法。思路和正向匹配几乎一模一样，仅仅将切分的顺序从前面开始改成了从后面开始而已。
每次我们获取句子当中最后n个字，进行词表匹配。如果没有匹配中，那么去掉这n个字当中的第一个字，将后面的n-1个字继续匹配。直到能匹配上为止。
在实际应用当中，正相匹配的错误率约为1/169，而逆向匹配的错误率为1/245，显然逆向匹配要更好一些。这也是有原因的，因为汉语当中偏正短语较多，词语的重心往往落在后面，比如之前的”南京市长江大桥“如果按照逆向匹配，就很容易识别出”南京市“和”长江大桥“了。
当然和正向匹配一样，逆向匹配也不是完美的，同样存在许多反例。
双向最大匹配 双向最大匹配的原理也很简单，就是将正向和负向结合起来。互相各取所长，因为这两种算法的切分思路刚好相反，从逻辑上来看是存在互补的可能的。
实际上也的确如此，根据研究显示，约有90%的中文句子，正向和逆向的切分结果是完全匹配并且正确的。大约有9%的句子是两个算法结果不一致，并且是有一种是正确的。只有1%不到的句子，两个算法的结果都错误的。
算法的思路也很简单，就是将正向匹配和逆向匹配的结果进行对比。如果一致，那么直接就认为是正确答案，如果不一致，则选择其中切分出来单词数量较少的。
比如前文当中”南京市长江大桥“两种切分结果分别是”南京“，“市长”，“江”，“大桥”和“南京市”，“长江大桥”，那么算法会选择后者。
统计分词算法 基于统计的分词算法也不难理解，我们用统计学中出现的概率来代表分词方案的正确性。
假设句子是T，一种分词方案是
那么
显然，我们要计算出当中所有的条件概率是不可能的，因为参数空间太大，数据过于稀疏。
不过好在我们可以进行化简，理论上来说当前句子某个位置会出现什么单词，可能和其他所有单词都有关系。但是我们可以简化这个关系，我们可以简单认为每个单词之和之前出现的两个词语有关。
也就是说，
这样样本空间大大减少，我们枚举可能存在的分词情况，通过统计的方法找到其中出现概率最大的值即可。
深度学习分词算法 在深度学习普及了之后， 市面上出现了许多种基于深度学习的中文分词算法。本文选择其中最简单的一种作为介绍。
目前常用的模型是BiLSTM，即双向的LSTM模型。LSTM模型的好处是可以学到时间序列的信息，在文本当中，能够学习到上下文直接词语的内在联系。BiLSTM是双向LSTM模型，既考虑了句子的正序，也考虑了句子的逆序，有些类似于前文当中说的双向最大匹配算法。
模型的输入是一个句子当中所有汉字向量化的集合，有点类似于Word2vec的做法(这里看不懂的同学可以跳过，后面会有专门介绍Word2vec的文章)，以及每个字的类别。每个字的类别一共有四种，分别是s(single)，即单字成词，b(begin)，某个词语的开始，m(middle)，某个词语的中间部分和e(end)，即每个词语的结尾。
预测的时候，模型一样读入每个字对应的embedding，模型的预测结果是每个字属于每个类别的概率。最后，根据模型的预测结果，对整个文本完成分词。
和之前几种算法相比，这种算法的准确率更高，但是它也有自己的问题。最大的问题是非常依赖人工标注的结果，想要模型有好的结果，需要的训练样本量非常大，因此带来的人力成本很高。
中文分词是非常小的一个点，但是却至关重要，凡事和文本有关的领域都离不开它。好在绝大多数情况下，我们并不需要自己手动实现分词算法，因为如今市面上已经有了许多免费开源的分词引擎，像是著名的庖丁、jieba等等。不过尽管如此，深入了解其中的算法原理，依然很有必要。
如果觉得文章有所帮助，请给个关注。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05b1de2419208dbd4d0d9cedae249f48/" rel="bookmark">
			TypeScript之数组知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 TypeScript中数组的类型 使用 类型+方括号 进行声明 let arr1:number[] = [1,2,3,4,5,6]; arr1.map(i=&gt;{ console.log(i); //123456 }) 注意，数组的每一项应为声明时确定的，不能改。
能改变数组本身的数组方法，其参数也要被类型所限制。 let arr1:number[] = [1,2,3,4,5,6]; arr1.push(4); //添数据必须得是数值 arr1.unshift(1); 用接口来描述数组 interface Arr{ [index:number]:string //[下标：下标类型]：值类型 } let arr:Arr[] = ["1","str","hello"]; console.log(arr); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53875073352c7a46e94b47898d642622/" rel="bookmark">
			如何把自己的代码开源，将类库部署到JitPack上；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用AndroidStudio把代码开源到Github： 输入自己的Github账号和密码，一路下一步就上传了；
二、配置Github开源许可证： 例：
1、创建新文件： 2、输入文件名称：LICENSE，点击右边的 Choose a license template 3、点击Choose a license template后跳转到协议配置界面（选择 Apache License 2.0 ,然后点击右边的Review and submit）： 4、提交该文件（我这边选择的不创建新分支）： 5、回到该项目的首页，就会发现开源证书已经存在； 三、发布依赖版本： 1、点击 release 跳转版本发布界面： 2、点击 Create a new release 创建新版本； 3、输入版本号，发布版本； 4、OK、版本创建完成； 4、打包生成依赖； JitPack地址 ： https://jitpack.io/
1、复制项目仓库地址： 2、将仓库地址放在网址框，生产依赖： 3、完成！！！ Tag就是你的 release 版本号，我的是 1.0.0
使用的时候把Tag换掉就OK了；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bed0b2b335c3ff1ecc3c4125df0e5a86/" rel="bookmark">
			Flowable 快速入门教程：任务驳回与回退
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Flowable 快速入门教程：任务驳回与回退 前言BUG 修复记录支持场景功能描述驳回退回 脏数据什么是脏数据串行样例并行样例会签样例脏数据清洗效果图 完整代码效果图 前言 本文的代码中没有对流程做任何特殊处理，用的都是流程本身的数据，因此可以通用，直接复制粘贴即可
方法不支持多对多跳转
回退不能够直接回退到子流程上，我这里按照只能回退到用户任务节点处理的
驳回可以直接驳回到子流程开始
可根据自己需要对代码进行调整
BUG 修复记录 2021.03.03：修复花的时间有点久，主要时间有限，而且太复杂了（改动比较大，改了很多地方，因此建议代码全替换）
修复：网关节点驳回时，网关的活动节点数据也需驳回问题（坑爹）
修复：基于上一点的修复，历史节点获取从原来的历史任务数据改为了历史活动数据获取，因此改动比较大
修复：已经经过的路线改为浅拷贝数据，毕竟每个路线的数据都应该是单独的 支持场景 并行网关，高级网关，包容网关，会签，子流程
功能描述 驳回 参数：当前任务ID，驳回原因
直接根据历史数据，获取上个用户任务节点，进行跳转
退回 参数：当前任务ID，驳回的节点Key
回退只能回退到串行路线上
脏数据 什么是脏数据 如图，假如我从节点6回退到节点2，这时红框中的数据对于我们来说是一个历史记录，但是对于流程来说，这些数据是无意义的废弃数据
串行样例 并行样例 会签样例 脏数据清洗效果图 流程图
对应数据
清洗效果截图，由于没有循环，可以看到除了会签对应 3 条实例数据，其他节点清洗后都只有一个
sid-4FE193FF-E1E2-4F87-8424-2F00BCA9AFC5 是网关，没给它命名
完整代码 TackbackApiController.java
为了方便查看，代码我单独上传 gitee 了，包含驳回，回退，任务流程图查看，可驳回节点列表接口
效果图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc3f0b0f6ba2ff90fdaef9612f8aa613/" rel="bookmark">
			文字超过两行省略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天遇见一个问题就是要对文字超过两行进行省略，并进行弹窗
换行代码
overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; 对应换行弹窗代码
css .content{ float: left; margin: 50px 50%; transform: translateX(-50%); width: 60%; height: auto; background: #666; border-radius: 10px; } .content span{ display: inline-block; width: 8%; margin: 20px 17px; position: relative; height: 43px; } .topContent { position: absolute; top: -80%; left: 50%; background: #fff; color: #000; z-index: 900; border-radius: 5px; } html &lt;div class="content"&gt; &lt;span&gt; &lt;p&gt;大数据大数4124124124据&lt;/p&gt; &lt;/span&gt; &lt;/div&gt; js //弹窗方法 let content = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc3f0b0f6ba2ff90fdaef9612f8aa613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e056995cf2e4376d854521986066b81/" rel="bookmark">
			Centos7 合理分配 swap空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：查看服务器内存情况命令： #free
可以看到，我的服务器还没有配置Swap虚拟内存！
第二步：检查硬盘驱动器分区上的可用空间 在我们创建swap文件之前，我们将检查当前的磁盘使用情况，以确保我们有足够的空间。通过输入：
#df -h Filesystem 列中的/dev/vda1 是我们的磁盘。在这个例子中我们有足够的空间（仅有9.1G被使用）。 对swap空间的适当大小实际上取决于您的个人偏好和您的应用程序要求。通常，等于或双倍于系统内存的量是一个很好的选择。如果您只是将其用作RAM后备，那么你的swap分区尽可能不要超过4G。 一般来说可以按照如下规则设置swap大小：
4G以内的物理内存，SWAP 设置为内存的2倍。 4-8G的物理内存，SWAP 等于内存大小。 8-64G 的物理内存，SWAP 设置为8G。 64-256G物理内存，SWAP 设置为16G。 第三步：创建Swap分区文件 我们可以在文件系统上创建一个swap分区。我们将在根/目录中分配我们想要调用的swap大小的文件swapfile。
创建交换文件的最佳方法是使用fallocate。此命令将创建指定大小的文件。
由于我的服务器物理内存数2G，因此我们将在本教程中创建4G文件：
sudo fallocate -l 4G /swapfile
我们可以通过输入以下内容来验证其是否保留了正确的空间量：
#ls -lh /swapfile
第四步：启用Swap分区 我们需要将swap文件转换为swap分区。首先，我们需要锁定文件的权限，以便只有具有root权限的用户才能读取内容。
通过输入以下内容使该文件只能由root访问：
sudo chmod 600 /swapfile 我们现在可以通过输入以下内容将文件标记为swap空间
sudo mkswap /swapfile 标记文件后，我们可以启用swap文件：
sudo swapon /swapfile 输入以下内容验证交换是否可用：
sudo swapon --show 我们可以用free命令再次检查：
free -h 我们的swap已成功设置，我们的操作系统将在必要时使用它。
第五步：永久化swap文件 我们已启用当前会话中的swap文件。但是，如果我们重新启动的话，服务器将不会自动保留swap设置。我们可以通过将交换文件添加到我们的/etc/fstab来进行更改。
为了避免出现任何问题，先备份/etc/fstab文件：
#sudo cp /etc/fstab /etc/fstab.bak 输入以下内容，将swap文件信息添加到/etc/fstab文件末尾：
#echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab 第六步：调整您的Swap设置 您可以配置一些选项，这些选项会在处理swap时对系统的性能产生影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e056995cf2e4376d854521986066b81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac34403a533e5b612222617ccbfb710a/" rel="bookmark">
			Kali之airodump-ng
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具说明：
用于捕获原始802.11帧的数据包，以便与aircrack-ng一起使用。如果你有一个连接到电脑的GPS接收器，airodump-ng可以记录下找到的接入点的坐标。此外，airodump-ng会写出一个文本文件，其中包含所看到的所有访问点和客户机的详细信息。
操作：
airodump-ng [选项] &lt;接口名字&gt; 选项意译：
-H，–help打印帮助信息界面-i，–ivs它只保存IVs(只对破解有用).如果指定了此选项，则必须提供转储前缀(–write选项)-g,–gpsd指示airodump-ng应该尝试使用GPSd获取坐标。-w &lt;prefix&gt;,–write &lt;prefix&gt;要使用的转储文件前缀。如果没有提供这个选项，它将只在屏幕上显示数据。在该文件旁边将创建与捕获文件相同文件名的CSV文件-e,–beacons它将记录所有的信标到cap文件。默认情况下，它只记录每个网络的一个信标-u &lt;secs&gt;,–update &lt;secs&gt;延迟&lt;秒&gt;显示更新之间的延迟(默认为1秒)。适用于CPU速度慢的情况。–showack打印ACK / CTS / RTS统计数据。有助于调试和一般的注入优化。它表明如果你注入，注入太快，到达AP，帧是有效的加密帧。允许探测“隐藏”的站，因为它们太远，无法捕获高比特率帧，因为ACK帧以每秒1Mbps的速度发送。-h隐藏的站点.–berlin &lt;secs&gt;当不再接收到任何数据包时，从屏幕上删除AP/client之前的时间(默认为120秒)。-c &lt;channel&gt;[,&lt;channel&gt;[,…]],–channel &lt;channel&gt;[,&lt;\channel&gt;[,…]]指出要监听的频道。默认情况下，airodump-ng在所有2.4GHz通道上跳转。-b &lt;abg&gt;,–band &lt;abg&gt;指出airodump-ng应该跳的波段。它可以是“a”、“b”和“g”字母的组合(“b”和“g”使用2.4GHz，“a”使用5GHz)。与——通道选项不兼容。-s &lt;method&gt;,–cswitch &lt;method&gt;定义airodump-ng在使用多个网卡时设置通道的方式。有效值:0 (FIFO，默认值)、1(轮询)或2(最后一跳)。-2,–ht20将通道设置为HT20 (802.11n)。-3,–ht40+设置通道为HT40+ (802.11n)。它要求20MHz以上的频率是可用的(4通道以上)，因此一些通道在HT40+中是不可用的。HT40+在美国只有7个频道可用(欧洲大部分地区有9个)。-5,–ht40-将通道设置为HT40-(802.11n)。它要求20MHz以下的频率是可用的(4个通道是低的)，因此一些通道在HT40-中是不可用的。在2.4GHz中，HT40通道从5通道开始。-r &lt;file&gt;从文件中读取数据包。-x &lt;msecs&gt;主动扫描模拟(发送探测请求并解析探测响应)。-M,–manufacturer显示一个制造商列，其中包含从IEEE OUI列表获得的信息。-U,–update显示从其信标时间戳获得的APs正常运行时间。-W,–wps显示WPS列，其中包含WPS版本、配置方法、从APs信标或探针响应(如果有的话)获得的AP设置锁定。–output-format &lt;formats&gt;定义要使用的格式(用逗号分隔)。可能的值是:pcap, ivs, csv, gps, kismet, netxml。默认值为:pcap、csv、kismet、kismt -newcore。“pcap”是用于以pcap格式记录捕获的，“ivs”是用于ivs格式的(它是—ivs的快捷方式)。“csv”将创建一个airodump-ng csv文件，“kismet”将创建一个kismet csv文件，“kismet-newcore”将创建一个kismet netxml文件。“gps”是gps的简写。除ivs和pcap外，这些值可以合并。-I &lt;seconds&gt;,–write-interval &lt;seconds&gt;输出文件的写入间隔为CSV, Kismet CSV和Kismet NetXML，以秒为单位(最少1秒)。默认:5秒。注意，间隔太小可能会减慢airodump-ng。-K &lt;enable&gt;,–background &lt;enable&gt;覆盖自动后台检测。使用“0”强制前台设置，使用“1”强制后台设置。它不会使airodump-ng作为守护进程运行，它将跳过后台自动检测和强制启用/禁用交互模式和显示更新。–ignore-negative-one删除“固定通道&lt;接口&gt;:-1”的消息Filter options:过滤选项：-t &lt;OPN|WEP|WPA|WPA1|WPA2&gt;,–encrypt &lt;OPN|WEP|WPA|WPA1|WPA2&gt;它将只显示与给定加密匹配的网络。可以多次指定:’-t OPN -t WPA2’-d &lt;bssid&gt;,–bssid &lt;bssid&gt;它将只显示与给定bssid匹配的网络。-m &lt;mask&gt;,–netmask &lt;mask&gt;它将只显示网络，匹配给定的bssid ^网掩码组合。需要–bssid(或-d)需要指定。-a它只显示关联的客户端。-N,–essid通过ESSID过滤APs。可以多次使用以匹配一组ESSID。-R,–essid-regex使用正则表达式通过ESSID过滤APs。 案例：
前提环境：
Vmware pro15
Kali Linux 2019.4
网卡Rlink 802.11n
网卡监听已开启
操作：
“airodump-ng -i wlan0mon”将只显示ivs信息，扫描文件将不进行保存 “airodump-ng -i -w test wlan0mon”加上-w选项将会把扫描信息存储在根目录下，文件名以“ivs”后缀，以设定的test为前缀。 也可以存储在其它位置，存储文件夹必须存在，否则会报错。如下图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac34403a533e5b612222617ccbfb710a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/715e799e9cb35c403def998999b348eb/" rel="bookmark">
			读源码学MYSQL系列（一）decimal类型用法及存储实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题来源 最近在项目中用到了许多浮点数，精度要求较高，小数点后有4位甚至8位的，思考了一下，类似需求在工程计算、数值计算、股票金融、数字货币等场景都会出现。
计算机提供了float/double两种浮点类型的数据来进行科学计算，但计算机中的浮点数据表示是有误差的，它们并不能准确的表示十进制的小数，在进行高精度计算时会产生误差，再经过复杂的传播，误差就变得很不可控了。
为了保证结果的准确性，必须使用高精度计算。高精度计算的基本原理是模拟人工计算过程，保留计算过程中的所有数位，从而达到结果的精确性。各类语言及数据库都提供了对基本浮点类型的支持，扩展库都会提供相应的高精度数据的支持，在MYSQL中，decimal就是高精度浮点数据类型。后文主要介绍decimal的使用和实现原理。
MYSQL中浮点数据介绍 float/double MYSQL当中的float/double和我们常见的编程语言当中的float/double是一样的，分别表示32位单精度和64位双精度浮点数，在存储上分别需要4字节和8字节。从浮点的特性考虑，float和double都只能近似表示，无法精确。如下图所示，a列为float(10, 4)，b列为double，参考第2行，同一个数131072.32保存在a和b的结果是不同的。在超出了浮点数的表示精度后，会有一定的截断，从而引起计算结果的误差。
numeric/decimal 基本用法 decimal(M,D)表示高精度的小数，其中M表示整数加小数的数位，D表示小数部分位数，并且有如下约束：
字段约束M总精度，整数加小数部分，1 &lt;= M &lt;= 65, 默认M = 10D小数部分精度，0 &lt;= D &lt;= 30且D &lt;= M, 默认D = 0 SQL标准中，numeric(M,D)表示准确为M位的小数，而decimal(M,D)表示精度至少为M，可以比M位多。但在MYSQL中，两者是一样的，都只能表示精度为M位。
存储实现 MYSQL对decimal的存储进行了优化。为了节省空间，MYSQL采用4字节来存储9位数位。我们知道，9位数字最大为999999999，但4字节整数最大可以表示21亿多，可以达到10位，所以4字节是充足的。整数部分和小数部分是分开存储的，每9位存储为4字节，多余部分采用额外的字节存储。对应的额外字节如下：
数位字节001-213-425-637-94 举个例子，decimal(18,9)的整数部分和小数部分各有9位，所以两边各需要4字节来存储。decimal(20,6)有14位整数，6位小数，整数部分先用4字节表示9位，余下5位仍然需要3字节，所以整数部分共7个字节，小数部分则需要3字节。
浮点位或者前缀0不会被保存。那么MYSQL是怎么保存负数的呢？负数的存储是将正数的每个字节取反。参考下面的示例：
我们将1234567890.1234存储到MYSQL中，设定M=14，D=4.
首先，将整数和小数进行分组：
1 234567890 1234 整数部分低9位可以存储为4个字节，即
...... 0D-FB-38-D2 ...... 剩下的一位可以存储成1个字节，
01 0D-FB-38-D2 ...... 小数部分，可以用2字节存储，得如下
01 0D-FB-38-D2 04-D2 对最高位求反，得到
81 0D-FB-38-D2 04-D2 于是，我们得到了这个14位精度数据在MYSQL中的二进制存储
81 0D FB 38 D2 04 D2 对上述各个字节求反，可以得到-1234567890.1234的存储表示
7E F2 04 C7 2D FB 2D 由此可见，MYSQL中的decimal是可以实现对小数部分的高精度的，而且在性能上比起一般采用varchar存储的做法要好，毕竟MYSQL内部采取的是整数分组计算的策略。这也启发我们，如果要自己实现高精度计算，应该采取类似的思路。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/715e799e9cb35c403def998999b348eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a028530ab7336f8dca3ab31519c99b/" rel="bookmark">
			网站页面底部的著作权（版权）声明应该怎么写？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网站建设中的知识产权问题主要存在于主页、链接、网页信息、技术措施和权利管理信息中。
随着互联网的发展，大大小小的网站冒出来很多，那么网站的底部信息到底应该写什么？
和目前我国通行的大部分互联网惯例一样，网站声明著作权的做法起源于美国。相应的，参考标准和格式也是应用的美国版权局的说明，关于书籍，电影，唱片，网页，软件等的著作权声明，必须包含这三部分：
1：英文单词“Copyright”（直译为版权）
2:作品初次公开发表的年份
3:作品的著作权拥有者名称——拥有者除作者、多作者外，也可以是拥有著作权的公司、企业；名称可以是可识别的拥有者全称外，也可以是名称缩写、可以是拥有者的其他为公众知晓的名称。
简单来说说，标准格式应该是：
Copyright+[dates]+[author/owner]
*Copyright+[日期]+[作者/拥有者]
有些网站的著作权声明中还会在著作权拥有者之后加一个后缀“AllRightsReserved.”（通常直译为“版权所有”），使整个格式变为如“Copyright2016XXX.AllRightsReserved.”
而中文书写著作权声明时，也可以加上“版权所有”四个字，但要注意它的位置也是在后边，切记不要直接将“版权所有”代替“Copyright”使用，写作“版权所有1996-2012XXX.AllRightsReserved.”。
在某些国家法规中这一个后缀曾经是必须的，但是目前在大多数国家，都不是法律规定必须标注的字样。
有些网站的著作权声明中，在“初次公开发表的年份”后会同时注明另外一个年份日期，如：Copyright1996-2012XXX.AllRightsReserved.
这是因为该网站的有效时间长于1年，所以会有第2个年份出现。如果这个网站一直到今年都是有效的，第二个年份应该填为今年年份。同时，第二个年份也不是必须标注的内容。
正确的格式应该是：Copyright [dates] [author/owner] All rights Reserved. 如：菜鸟教程的底部版权就是这种合适。
1、那个 [dates] 是指起至日期还是其他的什么意思？
一般的，只要显示最新的年份即可，也可以显示从某个起始日期开始，到现在为止。如果你加了这行字，请注意每年及时更新。
2、日期后加网站名字？其他行吗？
日期后面，只能跟网站，或者版权拥有者的名字，如果是个人网站，你可以用域名，也可以用你自己的名称。
拼音的写法是你的名字的首字母，后面跟你的姓的全拼，首字母大写。很多人也用网名的，重要的是格式的次序，不加这个标注，你的版权也是同样被认可和保护的。
转载于:https://www.cnblogs.com/zhangqie/p/6972214.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51df78a03be95dc95dcfb7094296560d/" rel="bookmark">
			JSONObject.parseObject和JSONObject.fromObject
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/qq635785620/article/details/10436789
https://blog.csdn.net/qq_40206864/article/details/82997458
说明 com.alibaba.fastjson.JSONObject是经常会用到的JSON工具包，同样它的转换方法也会经常被我们使用，包括对象转成JSON串，JSON串转成java对象等，如果过一段时间不用的话很容易就会忘记，所以将使用方法总结如下，以便以后忘记了方便查
询。
//Java对象转换成String类型的JSON字符串 JSONObject.toJSONString(Java对象) //String类型的JSON字符串转换成Java对象 JSONObject.toJavaObject(JSON字符串,Java对象.class) //Json字符串转换成JSONObject对象 JSONObject.parseObject(JSON字符串) //JSON字符串转换成Java对象 JSONObject.parseObject(JSON字符串,Java对象.class) JSON JSON 即 JavaScript Object Natation，它是一种轻量级的数据交换格式，非常适合于服务器与 JavaScript 的交互。
创建json对象 用put(key,value)拼接json：
JSONObject object = new JSONObject(); jsonObjectRow.put("YWH", projId); jsonObjectRow.put("YWX", "2010"); jsonObjectRow.put("JGXYH", jsonObject.getString("ZJYH")); 创建json数组 用add添加json对象（json对象转json数组)：
JSONArray jsonArrayRow = new JSONArray(); jsonArrayRow.add(object); JSON.parseObject（String text）与JSONObject.parseObject（String text） JSONObject是JSON的子类。JSON是一个抽象类，JSON中有一个静态方法parseObject（String text），将text解析为一个JSONObject对象并返回；JSONObject是一个继承自JSON的类，当调用JSONObject.parseObject（result）时，会直接调用父类的parseObject（String text）。所以两者没什么区别，一个是用父类去调用父类自己的静态的parseObject（String text），一个是用子类去调用父类的静态parseObject（String text），两者调的是同一个方法。
parseObject(String str) 的作用： json.parseObbject(String str)是将str转换成相应的jsonObject对象，其中str是“键值对”形式的json字符串，转化为jsonObject对象之后就可以使用其内置的方法，进行处理
JSON.parseArray() 这个方法的作用就是将json格式的数据转换成数组格式。
假设有Person这个类，有json类型数据jsonStr = [{"name":"张三","age":"1"},{"name":"李四","age":"4"}]，那么List lists = json.parseArray(jsonStr, Person.class);lists就可以接收jsonStr了
JSON与JAVA数据的转换（） 来自net.sf.json.*下的类（jar包是json-lib-x.x.jar）
JSONObject jo = JSONObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51df78a03be95dc95dcfb7094296560d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b38af47e3528f29534a956647232d47/" rel="bookmark">
			【压缩原理】 deflate 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 概述
2 LZ77算法原理
2.1 压缩
2.2 解压缩
3 Huffman编码
3.1 构造霍夫曼树
4 参考
1 概述 DEFLATE是同时使用了LZ77算法与哈夫曼编码（Huffman Coding）的一个无损数据压缩算法。DEFLATE压缩与解代码可以在自由、通用的压缩库zlib上找到。常见的压缩算法如下：
zlib(RFC1950):一种格式，是对deflate进行了简单的封装，zlib = zlib头 + deflate编码的实际内容 + zlib尾gzip(RFC1952):一种格式，也是对deflate进行的封装，gzip = gzip头 + deflate编码的实际内容 + gzip尾 2 LZ77算法原理 LZ77算法是采用字典做数据压缩的算法，由以色列的两位大神Jacob Ziv与Abraham Lempel在1977年发表的论文《A Universal Algorithm for Sequential Data Compression》中提出。
基于统计的数据压缩编码，比如Huffman编码，需要得到先验知识——信源的字符频率，然后进行压缩。但是在大多数情况下，这种先验知识是很难预先获得。因此，设计一种更为通用的数据压缩编码显得尤为重要。LZ77数据压缩算法应运而生，其核心思想：利用数据的重复结构信息来进行数据压缩。
在具体实现中，用滑动窗口（Sliding Window）字典存储历史字符，Lookahead Buffer存储待压缩的字符，Cursor作为两者之间的 分隔，如图所示：
并且字典与Lookahead Buffer的长度是固定的。 2.1 压缩 用(p,l,c)表示Lookahead Buffer中字符串的最长匹配结果，其中
p表示最长匹配时，字典中字符开始时的位置（相对于Cursor位置），l为最长匹配字符串的长度，c指Lookahead Buffer最长匹配结束时的下一字符 压缩的过程，就是重复输出(p,l,c)，并将Cursor移动至l+1，伪代码如下：
Repeat: Output (p,l,c), Cursor --&gt; l+1 Until to the end of string 压缩示例如图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b38af47e3528f29534a956647232d47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/305be5d90db9e3b36d91d85dbe44e91b/" rel="bookmark">
			如何快速的将离线语音识别PocketSphinx集成到自己的项目中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先下载官方的DEMO
我给出我的链接让大家下载：PocketSphinx官方DEMO
二、自己新建一个AndroidStdio项目
三、导入官方项目的依赖aars具体步骤如下
然后点击next
然后打开自己工程的setting.grade
加入这句话include ‘:app’, ‘:models’, ‘:wear’, ‘:aars’, ‘:pocketsphinx-android-5prealpha-release’如下图所示：
然后点击右上角的Sync Now
然后你的项目中就会出现aars和models文件夹和库文件
然后将官方Demo中的aars文件夹和models文件夹中的内容分别拷贝到自己工程中的aars文件夹和models文件夹
四、将官方Demo中的assets文件夹中的内容拷贝到自己工程中的assets文件夹中，如果没有新建一个
五、将Demo中的MainActivity和layout中的内容复制到自己的工程中
六、在自己工程中的Build.gradle文件中 添加implementation project(’:aars’)
七、自己工程添加权限&lt;uses-permission android:name="android.permission.RECORD_AUDIO"/&gt;
八、把自己的工程运行到自己的手机上就OK了
九、如果有问题联系我：QQ：1124315978，如果没问题就点个赞吧
下面是我的工程大家自己下载：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/383/">«</a>
	<span class="pagination__item pagination__item--current">384/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/385/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>