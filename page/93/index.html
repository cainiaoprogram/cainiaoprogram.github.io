<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6816b6248621b960d9a8605aadcd08d9/" rel="bookmark">
			并发场景下的事务会导致哪些数据问题?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		脏读 (Dirty Read)、不可重复读 (Non-repeatable Read) 和幻读 (Phantom Read)
1. 脏读：事务A读取了事务B尚未提交的数据，但是事务B因为错误进行回滚操作，而事务A还是获取到这个尚未提交的数据。所以说，脏读就是一个事务中访问到了另外一个事务未提交的数据，也就是读取到的数据可能是临时的或者无效的。
2. 不可重复读：在一个事务内，根据同一个条件对数据进行多次查询，但是结果却不一致。原因是其他事务对该数据进行了修改。所以，不可重复读通常与更新操作有关，因为在读取数据期间，其他的事务的更新操作，可能会导致读取到不同的数据。
3. 幻读：两个完全相同的查询条件执行时，第二次查询所返回的结果集和第一次查询所返回的结果集不相同。原因是其他的事务执行了插入、删除操作，导致两次的事务结果集不一致。所以说，幻读通常与插入、删除操作有关。
为了避免这些问题，数据库系统通常会使用锁机制、多版本并发控制 (MVCC) 或快照隔离 (Snapshot Isolation) 等技术来确保事务的隔离性和一致性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ea037d17c6e9d5aab0805f23fcd1bd/" rel="bookmark">
			最新版Intellij IDEA创建web项目&#43;配tomcat（手把手教学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新版Intellij IDEA创建web项目+配tomcat（手把手教学） 文章目录 最新版Intellij IDEA创建web项目+配tomcat（手把手教学）一、创建web项目二、tomcat的配置与测试 一、创建web项目 1、将鼠标逐步放置在下图标中，并点击project…
File（将鼠标放置在File上）–&gt;New（放置）–&gt;project(单击)
2、创建普通java项目
3、点击next进行下一步
4、构建项目名称及存放地点
5、右击创建好的项目，然后选择add framework
6、加装成为web项目
项目创建完成模样
二、tomcat的配置与测试 11、配置tomcat
测试是否成功
测试成功，出现如下界面（自动跳转到浏览器出现）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1bfe80351524212ad65766354c56fbc/" rel="bookmark">
			html-webpack-plugin和ScriptExtHtmlWebpackPlugin这两个插件有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两个插件的主要区别在于它们的作用和用法。
html-webpack-plugin是一个用于生成HTML文件的插件，它可以将打包后的文件自动注入到HTML模板中，并生成一个新的HTML文件。它可以通过配置生成多个HTML文件，并且可以配置生成的文件的模板和输出路径等。
ScriptExtHtmlWebpackPlugin是一个用于打包后自动添加引用外部JS文件的插件。它允许您将JS文件分为不同的块（chunk）并在HTML文件中按需引入，以加快页面的加载速度。它允许您指定哪些JS文件是内联的，哪些是外部引用的。
因此，两个插件的作用不同，但可以一起使用以提高打包效率和性能。html-webpack-plugin用于生成HTML文件，而ScriptExtHtmlWebpackPlugin则用于管理JS文件的加载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/046e36075617fe15aec85bcf1943ad20/" rel="bookmark">
			GODIVA论文阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文链接：GODIVA: Generating Open-DomaIn Videos from nAtural Descriptions
文章目录 摘要引言相关工作Video-to-video generationText-to-image generationText-to-video generation GODIVA方法逐帧视频自动编码器GODIVA视频生成器 实验数据集评价指标自动评估指标人工评估指标 实施细节定性结果定量结果 结论 摘要 从文本生成视频任务是极具挑战性的任务，由于其训练的高计算需求和答案无限性难以评估。当前的工作通常在简单或小型数据集上进行实现，泛化能力非常有限。本工作提出了GODIVA，一种开放域文本到视频的预训练模型，可以使用三维稀疏注意机制以自回归的方式从文本中生成视频。在 Howto100M 上预训练模型，这是一个包含超过 13600 万个文本-视频对的大规模文本-视频数据集。实验表明，GODIVA 不仅可以在下游视频生成任务上进行微调，而且在zero-shot的文本上也具有良好的零样本能力。本文还提出了一种名为相对匹配 (Relative Matching/RM) 的新指标来自动评估视频生成质量。列出并讨论了一些挑战作为未来的工作。
引言 “创造力是人类智力的一个基本特征，也是人工智能的挑战”。图像和文本生成的最新进展显示了机器的巨大创造力，包括GANs、VAE、RNN和自注意力。然而，AI 代理创建视频仍然是一个挑战，尤其是对于现实世界的多样性。生成视频要求机器不仅创建大量像素，而且还确保它们之间的语义一致性。
从文本生成视频的挑战，即文本到视频生成 (T2V) 任务。给定一个自然描述，T2V 要求机器理解它并创建语义一致的视频。尽管不是太多，但仍有一些工作使用 GAN 来研究这个主题。Video Generation From Text和To Create What You Tell: Generating Videos from Captions使用带有3D卷积的GAN来生成固定长度的低分辨率视频。Conditional GAN with Discriminative Filter Generation for Text-to-Video Synthesis使用条件过滤器来生成不同长度的视频。IRC-GAN: Introspective Recurrent Convolutional GAN for Text-to-video Generation将 LSTM 单元与 2D 卷积网络相结合，对帧质量和时间一致性进行建模。然而，这些工作在简单或小型数据集上进行了实验，泛化能力有限。
除了基于 GAN 的方法外，VQ-VAE 是另一个有前途的研究方向，并且在生成图像和视频方面取得了很大进展，尤其是用于文本到图像生成的 DALL-E。它成功地从文本中生成高质量的图像。本文转向更具挑战性的文本到视频生成任务，其中必须考虑视觉信息的时空连贯性。最近的一些工作Latent Video Transformer、Predicting Video with VQVAE、VideoGen: Generative Modeling of Videos using VQ-VAE and Transformers
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/046e36075617fe15aec85bcf1943ad20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311860f29852a7caec843ff4a3d54c62/" rel="bookmark">
			demo0917
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		demo0917
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d8e9dd6f778ab56e497f3b02906796/" rel="bookmark">
			【VPN-GRE|IPSEC学习】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VPN学习--GRE|IPSEC 1、GRE-VPN2、 IPSEC-VPN2.1实验1 1、GRE-VPN 一、R1-R2-R3建立OSPF
GRE步骤：
1.建立tunnel隧道
2.添加ip地址
3.配置隧道协议
4.隧道的源地址（公网）
4.隧道的目的地址（公网）
5.配置路由协议让路由从tunnel口出去。
二、Tunnel接双up条件？
1、tunnel口要ip地址
2、Tunnel口配置目的地可达0
R2:
interface Tunnel0/0/1
ip address 192.168.3.2 255.255.255.0
tunnel-protocol gre
source 192.168.12.2
destination 192.168.13.3
ip route-static 192.168.2.0 24 tunnel 0/0/1
R3:
interface Tunnel0/0/1
ip address 192.168.3.2 255.255.255.0
tunnel-protocol gre
source 192.168.13.3
destination 192.168.12.2
Ip route-static 192.168.1.0 24 tunnel 0/0/1
2、 IPSEC-VPN （1）加密算法：
对称加密：加密方和解密方采用同一个秘钥。
非对称加密：加密方通过对端的公钥加密数据；解密坊通过自己的私钥解密数据。
（2）解密算法：
MD5:哈希输入任意长度的消息，产生一个128比特的消息摘要。
SHA
（3）模式
Transport Mode:传输模式，封装时候不会产生新的IP头部
Tunnel Mode：隧道模式，封装的时候产生新的IP头部
（4）SA安全联盟
安全参数索引号SPI：SPI唯一确定SA，一个32bit
手动指定配置、IKE协商产生SA，SPI随机生成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96d8e9dd6f778ab56e497f3b02906796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa66a1064cf6fd62676b2751d31fbc33/" rel="bookmark">
			obs-studio程序运行中的一些配置信息存储路径和字段解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置文件路径 C:\Users\Administrator\AppData\Roaming\obs-studio 1. basic\profiles\未命名\basic：设置中某些配置项的保存
（1） 高级--网络-- 绑定IP，一般都设置为默认，对应参数中的值为
[Output]
BindIP=default ，可以界面上修改，也可以配置文件修改
如果设置为其他选项，有可能出现推流不成功的问题
（2） 2. basic\profiles\未命名\service： 自定义流媒体服务器
可以通过如下界面进行设置，也可以直接修改配置文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee4396d74bd102c81711942fac022aa7/" rel="bookmark">
			Rust Rc（引用计数）方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rust中的Rc（Reference Counting）是一种用于共享所有权的智能指针类型。它允许多个引用同时指向同一个值，通过计数器来跟踪当前有多少个引用指向该值，从而在引用计数为零时自动释放该值。本文将详细介绍Rc的用法和相关方法。
Rc的使用非常简单，只需导入std::rc::Rc模块即可。下面是一个使用Rc的示例代码：
use std::rc::Rc; struct Foo { data: i32, } fn main() { let foo = Rc::new(Foo { data: 42 }); let foo1 = Rc::clone(&amp;foo); let foo2 = Rc::clone(&amp;foo); println!("Count: {}", Rc::strong_count(&amp;foo)); // 使用foo, foo1, foo2的值 // 当foo1和foo2离开作用域时，引用计数将减少 // 当引用计数为零时，释放foo所指向的内存 } 在上述示例中，我们首先创建了一个Foo结构体，并使用Rc将其包装起来。接下来，我们通过Rc::clone方法创建了两个新的Rc实例，它们指向同一个Foo实例。这里需要注意的是，Rc::clone方法并不会进行深拷贝，而只是增加引用计数。最后，我们通过Rc::strong_count方法获取当前引用计数，并打印输出。
Rc提供了一些常用的方法，下面是一些常用的Rc方法及其说明：
Rc::new(value: T) -&gt; Rc&lt;T&gt;：创建一个新的Rc实例，将值value包装起来。返回一个指向value的Rc指针。Rc::downgrade(&amp;self) -&gt; Weak&lt;T&gt;：创建一个弱引用Weak实例，指向与当前Rc实例相同的值。弱引用不会增加引用计数。Rc::strong_count(&amp;self) -&gt; usize：返回当前Rc实例的引用计数。Rc::weak_count(&amp;self) -&gt; usize：返回当前Rc实例的弱引用计数。Rc::clone(&amp;self) -&gt; Rc&lt;T&gt;：增加引用计数，返回一个指向相同值的新Rc指针。 除了上述方法之外，Rc还实现了Deref和Drop trait，使得可以像操作普通引用一样操作Rc指针。
use std::rc::Rc; struct Foo { data: i32, } impl Foo { fn print_data(&amp;self) { println!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee4396d74bd102c81711942fac022aa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0b8e2f027ca551b33b7d7c92a2d132e/" rel="bookmark">
			Windows net 3.5安装失败 错误状态：0x800f0818
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各系统 net.3.5
链接: https://pan.baidu.com/s/13XD73GIx_OLVKBvgb2_FnA
提取码: cmhi
错误状态：0x800f0818
第一步，挂载或插入安装光盘。在sources\sxs文件夹中会有一个“microsoft-windows-netfx3-ondemand-package.cab”文件。
Win+X，以管理员权限启动命令提示符。假设安装盘盘符为X。
首先运行：
dism.exe /online /add-package /packagepath:X:\sources\sxs\microsoft-windows-netfx3-ondemand-package.cab
一段时间过后，DISM会返回错误码。
然后运行：
dism.exe /online /enable-feature /featurename:NetFX3 /Source:X:\sources\sxs\microsoft-windows-netfx3-ondemand-package.cab
如果DISM返回“操作成功完成”，恭喜你，.NET 3.5 已经成功安装。
将其中的 X　替换为你的 Win10 光盘镜像盘符。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdfa7e5cd22185b521ffb74b1d8bf9c0/" rel="bookmark">
			pytorch从预训练权重加载完全相同的层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 saved = torch.load(cfg.Transfer, map_location=device) # model.load_state_dict(saved['state_dict']) old_state_dict = saved['state_dict'] # 新建一个空的字典，用于存储新模型加载的权重 new_state_dict = {} # 将旧模型中相同层的权重复制到新模型中 all_layer=len(model.state_dict()) num=0 for key in model.state_dict(): if key in old_state_dict and old_state_dict[key].shape==model.state_dict()[key].shape: new_state_dict[key] = old_state_dict[key] num+=1 else: new_state_dict[key] = model.state_dict()[key] # 使用load_state_dict()加载新模型的部分权重 model.load_state_dict(new_state_dict) print("从预训练模型中加载了{}/{}层".format(num,all_layer)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75bff082d218cfba6d6ff0631030bfa1/" rel="bookmark">
			升级win11后怎么退回win10？保持原有win10系统不变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有用户将电脑系统升级到了windows11系统版本以后。觉得win11系统非常不好用，后悔升级。那么升级到win11还能退回win10吗？今天小编就针对用户不同的升级情况，给大家准备了相应的方法。升级到win11以后，想要退回原版本系统的用户们赶紧来看一下吧。
不超过10天win11退回win10系统方法 1. 选择“Windows Update”，然后点击“恢复”；
2. 在“恢复选项”中选择“以前版本的Windows”，点击“返回”；
3.选择原因，然后点击“下一步”；
4. 在“检查更新”的通知，选择“不，谢谢”；
5. 阅读需要了解的内容，然后点击“下一页”；
6. 阅读锁定提示，点击“下一页”；
7. 选择“回退到早期版本”；
8.之后等待系统退回即可。如果该方法无效或者已经超过了10天，请尝试下面的方法。
超过10天win11退回win10系统方法 1.在windows11系统中下载一个系统重装工具。小伙伴们可以点击超链接进行下载：胖爪windows10装机助手。进入页面点击。然后点击“软件下载”，就可以完成程序的安装了。需要注意关闭安全卫士类软件，不然会引起误报；
2.下载后完成安装程序，点击程序中的“立即重装”;
3.这时候软件会自动检测系统的硬件，小伙伴们直接点击“下一步”;
4.这时候选定需要安装的程序，想要升级的朋友们，记得在windows7或者windows10系统中找到后缀为64位的系统，之后点击下一步；
5.到了该步骤，小伙伴们可以选择一些常用的软件，方便系统安装后直接使用，继续点击“下一步”;
6.之后直接点击开始安装；
7.这时候软件就会开始自动下载装机需要的系统文件，我们只需要耐心等待就可以了。等到下载结束以后，系统会提示自动重启。
8.电脑自动重启以后不要进行任何操作，系统会自动进入pe解压系统文件，并且进行安装。整个步骤都不需要进行任何操作，只需要等待。等到安装完成后，系统就升级为64位系统了。
以上就是升级完win11后悔了怎么退回的详细介绍说明了，希望对各位用户们有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42434be1e7f27013628e1bbfb90bdd48/" rel="bookmark">
			人类存储的历史演变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		存储的历史演变与人类社会的发展密切相关，从最早的物理介质到现代数字化存储技术，不断满足着不同时期的信息保存和交流需求。以下是存储的历史演变从人类社会角度的阐述，包括代表产品、产生原因、问题解决和技术基础：
阶段一：原始存储（古代 - 中世纪） 代表产品： 壁画、雕刻、口头传承等。
为什么会产生： 人类早期社会需要一种方式来保存重要信息，以便后代能够获取、传承和学习。
解决了什么问题： 原始存储方式解决了信息传承问题，让社会中的知识、历史和文化能够被保留并传播。
技术基础： 技术基础主要是物理介质，如石头、壁画、纸张和口头传承。信息通过物质的改变（刻画、书写、言语）来保存。
阶段二：印刷术的革命（15世纪 - 18世纪） 代表产品： 印刷书籍、报纸等。
为什么会产生： 随着印刷术的出现，大规模生产书籍和文献的需求增加。手写复制的速度和成本已无法满足。
解决了什么问题： 印刷术解决了信息复制和传播的问题，大幅提高了文献的可获取性，促进了知识的传播。
技术基础： 印刷术基于活字印刷技术，通过排列和印刷活字来生产书籍和文献。
阶段三：电子存储的兴起（19世纪 - 20世纪） 代表产品： 磁带、磁盘、磁芯存储器等。
为什么会产生： 随着工业化和信息技术的发展，需要更高效、更便捷的信息存储方式。
解决了什么问题： 电子存储技术解决了信息保存、处理和传输的问题，提高了数据的存储密度和访问速度。
技术基础： 电子存储基于电磁学和半导体物理，利用电流和电磁性质来存储和读取数据。
阶段四：数字化存储的时代（20世纪末 - 至今） 代表产品： 固态硬盘（SSD）、云存储、光盘、USB闪存驱动器等。
为什么会产生： 随着数字化信息的急剧增加，传统的物理存储方式无法满足快速存储和共享的需求。
解决了什么问题： 数字化存储解决了存储容量、访问速度和可移动性的问题，实现了快速、灵活的数据存储和传输。
技术基础： 数字化存储依赖于数字编码和半导体技术，通过将数据转化为数字形式并存储在半导体器件中来实现。
阶段五：未来展望与新兴存储技术 代表产品： 存储级内存、量子存储、光子存储等。
为什么会产生： 随着大数据、人工智能等技术的发展，对更高容量、更快速度、更安全的存储需求不断增加。
解决了什么问题： 新兴存储技术有望解决传统存储技术在容量、速度、能效和安全性等方面的局限。
技术基础： 新兴存储技术基于先进的物理、材料和量子力学原理，例如利用量子位和光子的性质进行信息存储和处理。
通过不同历史阶段的存储技术，人类不断探索、创新和适应信息保存、共享和利用的需求，从而推动了社会的进步和发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d974df6bfa63fc9dcfa51345d525bc1/" rel="bookmark">
			人类计算的历史演变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人类计算的历史演变 (qq.com)https://mp.weixin.qq.com/s?__biz=MzAwODg2NTA2Mw==&amp;mid=2247483660&amp;idx=1&amp;sn=65266a2b588e5bdfeeca40d7ecb9e521&amp;chksm=9b691544ac1e9c529e64c4be820d02d45864c4e5b49f2d15cf6e4ba5ea07e9687dce78fe13d9&amp;token=1923526556&amp;lang=zh_CN#rd
计算的历史演变贯穿了人类社会的发展，从最早的手工计算到今天的高性能计算机和量子计算机，不断地满足着各个时期的计算需求。以下是计算的历史演变从人类社会角度的阐述，包括代表产品、产生原因、问题解决和技术基础：
阶段一：手工计算和天文观测（古代 - 中世纪） 代表产品： 算盘、天文仪器等。
为什么会产生： 人类早期社会需要计算时间、位置和财务等，同时天文学家需要进行星体观测和预测。
解决了什么问题： 手工计算和天文观测解决了时间、空间和金融等方面的计算需求，帮助人们更好地组织生活和理解宇宙。
技术基础： 手工计算基于数学和机械技术，天文观测基于观察和记录天体的位置和运动。
阶段二：机械计算设备的出现（17世纪 - 19世纪） 代表产品： 布莱克利计算机、差分机、分析机等。
为什么会产生： 随着科学研究和工程计算的复杂性增加，需要更高效的计算方式。
解决了什么问题： 机械计算设备解决了复杂计算和数据处理问题，大幅提高了计算的速度和准确性。
技术基础： 机械计算设备基于齿轮、滑轨等机械原理，通过机械运动来执行计算操作。
阶段三：电子计算的兴起（20世纪初 - 中期） 代表产品： 首台通用计算机ENIAC、UNIVAC、EDVAC等。
为什么会产生： 科学、军事和工业等领域对大规模计算需求增加，机械计算设备已不再满足。
解决了什么问题： 电子计算机解决了更加复杂和大规模的计算问题，从科学研究到数据处理都受益于此。
技术基础： 电子计算机基于电子电路、逻辑门等，通过二进制编码来执行计算和数据处理操作。
阶段四：个人计算和微处理器时代（20世纪后期 - 至今） 代表产品： 个人计算机、微处理器、移动设备等。
为什么会产生： 信息技术普及，个人和企业对计算能力的需求不断增加。
解决了什么问题： 个人计算和微处理器技术使计算变得普遍可用，解决了从数据处理到娱乐的广泛需求。
技术基础： 微处理器技术基于集成电路技术，包括逻辑电路、存储器单元和控制单元。
阶段五：未来展望与新兴计算技术 代表产品： 量子计算机、脑机接口等。
为什么会产生： 随着科技的不断发展，对更高性能、更节能、更灵活计算方式的需求增加。
解决了什么问题： 新兴计算技术有望解决大规模复杂计算和模拟需求，改变传统计算的边界。
技术基础： 新兴计算技术基于先进的量子力学原理、生物学原理等，如量子比特和神经元模拟。
通过不同历史阶段的计算技术，人类在解决日益复杂和多样化的问题时不断迈向更高效、更强大的计算能力。这些技术的发展对科学、工程、商业和社会的发展产生了深远影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b8b0a91f6eb820bcf0ea4bff9efb5e7/" rel="bookmark">
			Mysql001：Mysql概述以及安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本课程将从头学习Mysql，以我的工作经验来说，sql语句真的太重要的，现在互联网所有的一切都是建立在数据上，因为互联网的兴起，现在的数据日月增多，每年都以翻倍的形式增长，对于数据的管理日发重要，sql语法便是最重要的一个部分。
本章节将讲解一下内容：
基础篇：
》Mysql概述
》SQL
》函数
》约束
》多表查询
》事务
进阶篇：
》存储引擎
》索引
》SQL优化
》视图、存储过程、触发器
》锁
》InnoDB核心
》Mysql管理
运维篇：
》日志
》主从复制
》分库分表
》读写分离
数据库相关概念：
数据库：数据存储的仓库，简称DataBase(DB)。一个数据从界面存放到硬盘中，是交由电脑去实现的，而人想让电脑按照自己的意愿去操作数据， 用的就是sql语句，数据+sql+硬盘便可视为数据库。
关系型数据库、非关系型数据库：
在数据库中， 有关系型数据库于非关系型数据，
关系型数据库使用表格来组织数据，使用结构化查询语言（SQL）进行查询。它们适合处理高度结构化的数据和复杂的关系，对数据一致性和事务处理有严格要求，例如金融系统和企业资源管理。
讲人话：是以类似于excel表格形式来存储数据，适合存储非常复杂的数据，经常出现在金融类型行业
非关系型数据库是一种没有固定模式的数据库，以键值对、文档、列族或图形等方式存储数据，通常不使用SQL作为查询语言。它们适合处理大规模数据和高并发访问，强调可扩展性和性能，例如社交媒体数据和实时分析。
讲人话：是以类似于键值对来存储数据，适用于数据库量非常大的场景，性能比较出众，经常出现在社交媒体行业
关系型数据库细分种类：
MySQL：一种流行的开源关系型数据库，具有良好的性能和易用性。PostgreSQL：一种功能强大的开源关系型数据库，支持复杂的数据类型和高级特性。Oracle Database：一种商业级的关系型数据库，广泛应用于企业级应用，具有强大的可扩展性和安全性。Microsoft SQL Server：由微软提供的关系型数据库管理系统，适用于窗​​户平台和与其他微软产品集成。SQLite：一种嵌入式关系型数据库，非常轻量级，适用于移动应用和小型项目。IBM DB2：一种可扩展的关系型数据库，适用于企业级应用和大型数据处理。MariaDB：由MySQL的创始人创建的开源关系型数据库，与MySQL兼容，并提供一些额外的功能和性能改进。Sybase：一种用于企业级应用的关系型数据库，具有高性能和可扩展性。Teradata：专注于大规模数据仓库和分析的关系型数据库系统。Informix：一种高性能的关系型数据库，适用于企业级应用和实时数据处理。 非关系型数据细分种类：
键值存储数据库（Key-value store）：以键值对的形式存储数据，适用于简单的数据模型和高速读写操作。例如Redis、Memcached和DynamoDB等。
文档数据库（Document store）：以类似于JSON或XML的文档格式存储数据，适用于半结构化数据和灵活的查询需求。例如MongoDB、CouchDB和Elasticsearch等。
列族数据库（Column store）：将数据按列簇进行存储，适用于具有大量列和变化的数据模式。例如HBase和Cassandra等。
图形数据库（Graph database）：专注于存储和查询图形结构的数据，适用于复杂的关系和图形分析。例如Neo4j和ArangoDB等。
对象数据库（Object database）：以对象的形式存储数据，适用于对象导向编程和复杂数据模型。虽然非关系型数据库中对象数据库的使用较少，但一些产品仍在使用，例如db4o和Versant等。
哇，这么多，你学得完么，就算你学得完你记得完么？反之我记不完也学不完，所以就学mysql语法可以了，sql语法适用大分部种类数据库，就学一个可以了， 除非你想拿诺贝尔奖。
现如今打分企业用的都是Mysql和Oracle，你问我有什么区别？那我只能肤浅一点回答你了，mysql是免费的，适用中小型企业；Oracle是收费的，适用大型企业。后来mysql被oracle收购了，然后捣鼓了一下，就推出了收费版的mysql。当然免费版的mysql还是存在的，不然我可没钱买一个mysql来讲解。 Mysql数据库的安装：
目前Mysql提供了社区版和商业版， 也就是免费版和收费版。以下将用免费版进行说明。
mysql官方下载地址：MySQL :: MySQL Downloads
在安装之前， 需要卸载本地mysql，如果没有安装过则跳过。
cmd输入：mysql -V ，如果出现以下则说明安装过mysql，需要卸载。
卸载教程： https://mp.csdn.net/mp_blog/creation/editor/132521560
接下来接着说安装，双击安装文件：
等待安装
选择默认的开发模式，下一步
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b8b0a91f6eb820bcf0ea4bff9efb5e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872822980608b204770fd63f0de48e09/" rel="bookmark">
			Idea找不到Add Frameworks Support
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下图，可以通过Settings菜单进行添加，选择add action，如下：
搜索add framework support，点击ok，如下：
最后点击apply-&gt;ok
正常这个时候，右键项目就能看到add framework support选项了，但是如果还是没有，就通过help的搜索功能或者双击shift，会出现以下搜索框：
此时搜索到add framework support，直接单击使用即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/186fcaaf040123ce49384b28c455c1d8/" rel="bookmark">
			硬件预取之空间预取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《data prefetching techniques in computer system》翻译之空间预取器
2 Spatial prefetching 数据预取器需要在应用程序运行时预测处理器未来的内存访问。为此，它们通常依赖于数据访问之间的循环模式或相关性。在处理器上运行时，应用程序的数据访问中出现的模式或特定相关性越多，数据预取器就越能更好地预测未来的内存引用。
空间数据预取器通过依赖空间地址相关性来预测未来的内存访问。空间地址相关性是指多个内存区域间数据访问模式的相似性。访问模式演示了空间相关性，因为应用程序使用具有规则的并且固定布局，并且遍历数据结构时会重新进行访问[1]。
例如，应用程序可以使用结构体数组，而该结构体有多个元素。访问不同数据结构的模式很可能是相似的(有时是相同的)。图1显示了几个内存区域的访问模式。在这个图中可以看到访问模式的相似性。这种访问模式与内存区域(在本例中，与结构体相关的内存区域)的相似性被称为空间相关性。
有几种空间数据预取器[1-10]。这些预取器将内存地址空间划分为固定大小的部分，称为空间区域，并学习这些部分的内存访问模式。当应用程序触及相同或类似的空间区域时，学习访问模式用于预取未来的内存引用。在本章中，我们将讨论空间预取器学习空间区域访问模式的机制，以及它们如何将所学应用于未来类似空间区域的预取。
空间数据预取器的优点之一是它们施加的面积开销很小，因为它们存储偏移量(offset即，块地址从空间区域开始的距离)或增量(delta即，落入空间区域的两个连续访问的距离)作为它们的元数据信息，而不是完整的地址。空间数据预取器的另一个同样显著的优点是它们能够消除强制缓存丢失[11]。
强制缺失是指地址第一次被缓存看到的缓存缺失。这些失误也被称为冷启动失误或首次引用失误。当缓存第一次看到这些地址时，这样的数据访问通常会在缓存中丢失。因此，在重要的应用程序类别中，强制缓存缺失是导致性能下降的主要原因，例如，scan-dominated的工作负载，其中scan大量数据产生大量不可见的内存访问，无法被缓存捕获[1]。通过将在过去的空间区域中观察到的模式利用到新的未观察到的空间区域，空间预取器可以减轻强制缓存丢失，从而显着提高系统性能。
空间数据预取的关键限制是它无法预测指针跟踪导致的缓存丢失[12-16]。例如，对于链表，每个元素都是动态地分配到内存中的某个位置，并且元素之间不一定是相邻的。相反，它们使用指针连接在一起。通常，由于动态对象可能被分配到内存中的任何地方，因此不一定彼此相邻，因此指针跟踪访问通常不会显示空间相关性。相反，它们会产生大量依赖的缓存缺失，由于缺乏空间地址相关性，空间预取器几乎做不了这些缓存缺失。
我们介绍了两种最先进的空间预取技术:(1)spatial memory streaming (SMS 2006’ISCA)[2]，(2)VLDP[4]。
2.1 spatial memory streaming(SMS 2006’ISCA) SMS是一种最先进的空间预取器，它是在服务器和科学应用的背景下提出和评估的。每当第一次请求某个空间区域时，只要应用程序正在积极使用该空间区域，SMS就开始观察并记录对该空间区域的访问。每当空间区域不再被使用时(即空间区域的相应块开始从缓存中被清除)，SMS将观察到的访问信息存储在其元数据表中，称为模式历史表(PHT)。
PHT中的信息以_&lt;event, pattern&gt;_的形式存储。event(pc+addr/pc+offset/addr/offsetd等)是一条与观察到的访问模式相关联的信息。也就是说，如果将来事件再次发生时使用相应的存储访问模式。SMS根据经验选择PC +触发访问的偏移量 (即，第一次访问空间区域的指令的PC加上第一个请求的缓存块与空间区域开始的距离)作为访问模式相关的事件。这样，每当PC + Offset重新出现时，相关的访问模式历史记录将用于发出预取请求。模式是发生在每个空间区域的访问历史。SMS将访问模式编码为位向量。通过这种方式，对于空间区域中的每个缓存块，存储一个位，表示该块是否有在最近一次使用空间区域使用有则标记为(’ 1 ‘)若无则标记为 (’ 0 ')。
因此，无论何时使用一个模式，预取请求只针对存储模式中对应位为“1”的块发出。图2为SMS的硬件实现。
2.1.1 example 让我们假设SMS跟踪大小为256字节的空间区域，缓存直接映射为512字节，而块大小为**64字节。**在本例中，缓存包含8个块，每个区域长4个块。
序号Region1序号Region204167/5805134626320071490 在本例中，我们考虑以下内存访问顺序:67、200、580、1346、1490、1310开始时，缓存和预取器状态都是空的。地址67不在缓存中，映射到它的第二个块(上表的序号1)。此外，这是第一次进入一个新的空间区域。因此，它触发了SMS。SMS记录访问的PC(比如PC=0x001F54)和偏移量64，因为这个地址是空间区域的第二个块。第二个内存访问是地址200。这个地址也不在缓存中，并映射到它的第四个块(上表的序号3)。此外，地址200与地址67来自相同的空间区域，因此，偏移量192将被记录。
下一个内存访问是地址580。这个地址也不在缓存中，并映射到它的第二个块。因此，地址67将被替换为缓存中的这个地址。当一个活动空间区域的一个块在缓存中被替换时，表明该空间区域不再是活动的。因此，将记录{PC + Offset, Bit Pattern}(在本例中为{0x001F54+64，{0,1,0,1}})。地址580也开始一个新的空间区域。为简洁起见，我们不提及该空间区域的SMS记录。
下一个内存访问地址是1346。此地址不在缓存中，并映射到缓存的第六个块。这种访问也是一个新的空间区域的开始。为简洁起见，我们不提SMS是如何跟踪这个空间区域中的访问的。SMS还检查此访问是否匹配任何记录的**PC +偏移量。假设此内存访问来自与先前内存访问相同的加载指令。因此，pc是相同的。由于空间区域中的偏移量为64，因此偏移量也匹配。因此，SMS在新的空间区域中预取模式{0,1,0,1}(即只有块地址1472作为块地址1346的后续访问)。
下一个地址是1490。和前面一样，块地址1472是预取的，地址1490已经在缓存中，因此是命中。最后一个地址是1310，它来自与前一次内存访问相同的空间区域。
但是，这个地址不在缓存中，因为SMS先前用于预取的模式没有这个块，因此SMS没有预取这个缓存块，因此要将其加到PC+offset的访问模式中即为{1、1、1、0}。
2.2 VLDP(2015’Micro) VLDP是一种最新的最先进的空间数据预取器，它依赖于内存空间区域之间delta模式的相似性。VLDP记录落入空间区域的连续访问之间的距离，并使用它们来预测未来的缺失。VLDP的关键创新是部署多个预测表来预测增量模式。 VLDP使用几个历史表，其中每个表根据输入历史的特定长度保存元数据。
VLDP的元数据组织如图3所示。三个主要组件是Delta历史缓冲区(DHB)、Delta预测表(DPT)和偏移预测表(OPT)。DHB是一个记录当前活动空间区域的增量历史的小表。DHB中的每个条目都与一个活动的空间区域相关联，并包含像最后引用块这样的详细信息。
这些详细信息用于索引OPT和DPT，以便发出预取请求。DPT是一组键值对，它将增量序列与下一个预期增量关联起来。VLDP受益于多个DPT，其中每个DPT以不同的输入长度记录历史。DPT-i将利用i个历史delta来预取下一个期望的序列。例如，如果一个空间区域的最后三个增量是d3, d2和d1 (d1是最近的增量)，DPT-2存储&lt;d3,d2&gt; --d1,DPT1记录–d3。在查找dpt时，如果提供其中几个delta用于预测，则使用具有最长delta序列的表的预测，因为基于更长的输入进行的预测预计会更准确[1]。
通过这种方式，VLDP消除了由于短输入而产生的错误预测，从而提高了预取器的准确性和缺失覆盖率。
OPT是VLDP的另一个元数据表，它使用对空间区域的第一次访问的偏移量(而不是增量)进行索引。仅仅依靠增量进行预取要求预取器在发出预取请求之前至少观察到对空间区域的前两次访问;然而，有许多稀疏的空间区域，其中一些(例如两个)块被应用程序使用。因此，当应用程序在大量稀疏空间区域上操作时，在开始预取之前等待两次访问可能会使预取器失去发出足够的预取请求的机会。使用OPT可以使VLDP在第一次访问空间区域后立即开始预取。OPT将空间区域的第一次访问的偏移量与下一个期望的增量相关联。在第一次访问空间区域之后，使用访问的偏移量查找OPT，并使用表的输出发出预取请求。对于对空间区域的其余访问(即第二次访问)，VLDP只使用dpt。
尽管VLDP依赖于具有单个下一个预取增量的预测表，但它仍然能够提供大于1的预取前瞻性，使用提出了多级预取机制。在多度模式下，在预测空间区域中的下一个delta后，VLDP将该预测作为dpt的输入，以进行更多的预测**(递归)**。
2.2.1 举例 与SMS的示例类似，让我们假设VLDP跟踪大小为256字节的空间区域，缓存直接映射为512字节大小，块大小为64字节。在本例中，缓存包含8个块，每个区域长4个块。
我们考虑与SMS相同的地址序列:67、200、580、1346、1490、1310开始时，缓存和预取器状态都是空的。地址67不在缓存中，映射到它的第二个块。此外，由于这是空间区域的第一个地址，因此在增量历史缓冲区(DHB)中没有与之相关的条目。因此，以下条目将被添加到DHB(请注意，偏移量和增量是以缓存块而不是字节为单位的)(表1)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/186fcaaf040123ce49384b28c455c1d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c93c6d33d0d56abadddf275ff0188a0/" rel="bookmark">
			二值图细化算法 查表法&#43;ZS算法 (附有完整代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、细化简介 图像的细化主要是针对二值图而言。所谓细化，也就是从原来的图中去掉一些点，但仍要保持原来的形状，实际上是保持原图的骨架，将其细化为一个像素宽的线条的处理过程。
图像细化的算法有很多种，具体可以分为迭代法和非迭代法，迭代法根据其运算时是否并行处理像素，又分为串行算法和并行算法。在并行算法中，像素点的删除与图像中像素值的顺序无关，而仅仅取决于上一次迭代的结果，串行算法中，是否删除像素不仅与上一次迭代的结果有关，而且与当前像素值的分布也有关系。目前，比较典型的算法又 ZS 图像细化算法，LW 细化算法和EPTA 算法。ZS 算法是一种基于8邻域的并行细化算法，该算法是目前应用最为广泛的算法，其突出的优点是算法效率高，算法的迭代次数少，而且对于直线等要素经过细化处理后能够保持和原图像一致的形状。LW算法改进了ZS算法会丢失局部信息的问题，但产生了多余分叉的问题。EPTA 是对 ZS 算法和 LW 算法的增强，改善了 ZS 和 LW 算法存在的一些问题，但存在对于部分图像细化不完全的问题。
ZS 算法、LW算法和EPTA算法都是基于目标像素的8邻域，8领域表示如图1所示，目标像素的值为1，背景像素的值为0，在目标像素的8邻域内，根据像素值分布的不同，可以分为端点、孤立点和内部点。
判断一个点是否能去掉是以其8个相邻点（八连通）的情况来作为判据的，八邻域图如图1所示。
图1 目标像素的8邻域范围
具体判据为：
（1）内部点不能删除；
（2）孤立点不能删除；
（3）直线端点不能删除；
图2 特殊点示意图
下面主要介绍两种细化算法：
2、ZS 细化算法 ZS 算法是一种基于8邻域的并行细化算法，通过对目标像素8邻域进行分步的算术逻辑运算，来确定该目标像素是否删除，细化过程如下：
第一次迭代的过程中，如果P1的值满足以下四个条件，则删除P1的值，将P1的值置为0：
对于二值图像中的每一个像素点来说，它可能为孤立点、道路的内部点或者端点。将像素点P1的8邻域值P2-P9相加，若其和大于等于2，说明P1点不是端点或者孤立的点，若其和小于等于6，则保证P1不是内部点。如果像素点P1的8邻域值的和满足上述条件(1)，P1一定为边界点。S(P1)表示目标像素P1的8邻域中，顺时针变化一周像素由0变1的次数。在目标点8邻域P2-P9的范围内，像素值由0变1的次数只能为1次。在图3中，P2与P3以及P6和P7出现了0和1直接相连，此时若删除P1则P3与P8不再相连，细化后道路的连通性受到影响。条件(2)保证了图像细化后的连通性。
图3 模式示意图
第二次迭代中，像素点如果满足第一次迭代中的条件(1)和(2)及以下条件，则移除该像素点：
重复以上迭代过程，直到处理完所有像素点，此时，细化完成。
3、查表法 由于输入的图像是一张二值图，经过简单的数据处理将其归一化为像素值只有0和1的图像，然后对其进行卷积操作。
举一个特征点及其八邻域说明具体操作：
目标点八邻域 卷积核
将目标点的八邻域和和卷积核进行点乘，然后将所有值相加即可得表的索引 M；
然后实用上述计算的表的索引值M去找表中对应的值，表中对应得值为0/1，就把目标点的像素值修改为0/1（0为可删除，1为不可删除）；
使用上述方法，从上到下，从左到右进行扫描，然后对目标点进行查表、修改目标像素值，最后得到细化结果。表即为得一维向量，其中N受卷积核所有元素之和的影响。
4、实验分析 （1）查表法代码 说明:非常抱歉,下面贴的代码是我从细化到矢量化完整的工程(完整工程见下面链接)里面剪切出来的,之前没有调试就放上去了;今天试了下,发现里面有一些小问题,所以对其进行了修改,下面是修改后的代码;读者可以把代码复制过去后,只需要自己配一下 opencv 即可运行!!!
#include&lt;iostream&gt; #include &lt;opencv2\opencv.hpp&gt; using namespace std; using namespace cv; //查表法// Mat lookUpTable(Mat&amp; mat, int lut[]) { Mat mat_in; mat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c93c6d33d0d56abadddf275ff0188a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be146a727372647f143aa9b9d983d7cb/" rel="bookmark">
			linux下vsode超级用户运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决此问题的另一种方法是为当前用户创建一个本地桌面图标文件，而非编辑系统级别的桌面图标。这将覆盖系统级别的设置。请按照以下步骤操作：
在终端中输入以下命令，创建一个特定于当前用户的桌面图标文件：
cp /usr/share/applications/code.desktop ~/.local/share/applications/
使用文本编辑器编辑新创建的桌面图标文件：
nano ~/.local/share/applications/code.desktop
将 “Exec=” 行替换为以下内容：
Exec=sh -c “sudo code --no-sandbox --user-data-dir=YOUR_USER_DATA_DIR %U”
请记得将 YOUR_USER_DATA_DIR 替换为实际的用户数据目录路径。
按 Ctrl + O 保存文件，然后按 Ctrl + X 退出 nano 编辑器。
现在，当您单击Visual Studio Code图标时，它应以超级用户身份运行。请注意，以超级用户身份运行Visual Studio Code可能存在安全风险，所以除非您正在编辑受保护的文件，否则请使用普通用户权限运行Visual Studio Code。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/261e029b427f9a249c4d821c02e1c60a/" rel="bookmark">
			vue-h5移动Web的Flex布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Flex布局 Flexible布局，也就是弹性布局。
Flexible的优点是，不需要对元素设置固定的宽度和高度，元素的位置和大小也会跟着父元素或者浏览器的状态来自动适配。
同时还添加了水平居中和垂直居中的解决方案。
在页面中指定一个元素作为Flex布局，那么这个元素就是作为容器冤元素。设置如下：
.box{ display:flex; } 行内元素也是可以使用flex布局的。
注意：父元素设置为flex后，子元素的float、clear和vertical-align的设置就会失效。
Flex的兼容性写法 尽管有很多的浏览器已经实现了无前缀的版本，但是在系统比较旧版本的移动端设备上，只能带上前缀。
那么，我们在写代码的时候，就要考虑样式的兼容性了：
.box{ display:-webkit-flex; // 新版本语法加前缀 display:flex; // 新版本语法 display:-webkit-box; // 旧版本语法 } .children{ -webkit-flex:1; // 新版本语法加前缀 flex:1; // 新语法 -webkit-box-flex:1; // 旧版本语法 } Flex容器属性 弹性容器有两个方向：水平方向和垂直方向，弹性容器的子元素默认沿着水平方向排列。Flex容器有这些属性：
1、flex-direction 该属性决定主轴的方向；属性值如下：
row：表示设置主轴为水平方向，从左到右，该值为默认值row-reverse：表示设置主轴为水平方向，从右到左column：表示设置主轴为垂直方向，从上到下column：表示设置主轴为垂直方向，从上到下 2、flex-wrap 该属性决定如果一条轴线排列时内容超出，那么该如何换行；属性值如下：
nowrap：表示单行显示，不换行，该值为默认值wrap：表示内容超出容器宽度时换行显示，第一行在上方wrap-reverse：表示内容超出容器宽度时换行显示，但是从下往上开始，也就是第一行在最下方，最后一行在最上方 3、flex-flow 该属性是flex-direction和flex-wrap的缩写，即一个属性可以实现设置两个属性的功能。
4、justify-content 该属性决定了主轴方向上子元素的对齐和分布方式；属性值如下：
flex-start：表示主轴方向左对齐，该值为默认值flex-end：表示主轴方向右对齐center：表示主轴方向居中对齐space-between：表示主轴方向两端对齐，子元素之间的间隔都相等，多余的空白间距只在子元素中间区域分配space-around：表示主轴方向距容器两侧的间隔相等 5、align-items 该属性决定了交叉轴方向上子元素的对齐和分布方式；属性值如下：
flex-start：表示子元素在容器交叉轴方向顶部对齐flex-end：表示子元素在容器交叉轴方向底部对齐center：表示子元素在容器交叉轴方向居中对齐baseline：表示所有子元素都相对第一行文字的基线（字母x的下边缘）对齐。stretch：表示子元素拉伸，如果主轴是水平方向，且该子元素未设置高度或者把高度设置为auto，那么子元素将会占满整个容器的高度；如果主轴是垂直方向，且该子元素未设置宽度或者把宽度设置为auto，那么子元素将会占满整个容器的宽度；如果设置了高度和宽度，那么按照设置值显示子元素。该值为默认值。 6、align-content 该属性决定了多根轴线的对齐方式。如果容器只有一根轴线，那么该属性不起作用；属性值为：
flex-start：表示子元素在容器交叉轴方向顶部对齐flex-end：表示子元素在容器交叉轴方向底部对齐center：表示子元素在容器交叉轴方向整体居中对齐space-between：表示子元素在容器交叉轴方向两端对齐，剩下每一行子元素等分剩余的空间space-around：表示子元素在容器交叉轴方向上两侧的间距都相等，且位于起点和终点的元素与容器边框的间距为两侧间距的1/2stretch：表示每一行子元素都拉伸，是align-content的默认值。 Flex容器元素的子元素，有以下几个属性：
order：该属性决定子元素的排列顺序flex-grow：该属性决定子元素的放大比例flex-shrink：该属性决定子元素的缩小比例flex-basis：该属性决定在分配多余空间之前，子元素占据的主轴空间的大小flex：该属性是复合属性，由flex-grow、flex-shrink和flex-basis组成align-self：该属性决定了子元素与其他子元素不一样的排列和对齐方式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/798aa472c97c982fa2defa18031ec39f/" rel="bookmark">
			端到端测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是端到端测试？ 端到端测试是一种用于在类似生产产品的环境和数据下验证应用程序流的功能和性能的方法。
这不仅包括单个软件模块，还包括应用程序所依赖的内部和外部 API、网络和数据库基础设施 - 因此，名称为“端到端”。
目标是模拟真实世界的用户场景，以确保应用程序在整体上按预期运行，而不仅仅是单个组件（由其他类型的功能测试涵盖）或与第三方或真实最终用户场景隔离的系统（系统测试涵盖了这一点）。
端到端测试的好处 由于复杂的现代应用程序建立在内部和外部子系统之上，现代软件产品需要进行整体验证，而不仅仅是部分验证；虽然子系统可能单独通过测试，但它们作为完整应用程序交互的方式可能会出现故障和错误。
进行端到端测试有助于确保您的软件逐层做好生产准备。
以下是它对您成功至关重要的几个原因：
端到端测试确认您的应用程序的运行状况 端到端测试可以在多个系统上从前到后、从整体上验证您的软件功能。同时，它提供了跨不同最终用户环境的应用程序性能的视角，并确保最终用户体验按预期工作。
端到端测试扩大了测试覆盖范围 通过考虑服务和子系统之间的交互，端到端测试还扩大了测试覆盖范围，超出了通常在更孤立的测试实践中考虑的范围，以进一步确保质量并降低风险。
E2E 测试发现更多错误并提高应用程序生产力 在现代敏捷或 DevOps 开发环境中执行的端到端测试通常在每次迭代或每隔几次迭代进行一次，这意味着可以更快地捕获和纠正错误。这减少了错误被深埋在产品中的机会，使它们变得难以发现和修复。
端到端测试减少工作量和成本 通过每次迭代的全面测试以及已发布产品中错误和故障的减少，端到端测试减少了重复测试或重做工作的需要，最终降低了与测试相关的成本和时间。
端到端测试如何工作 由于端到端测试涵盖整个应用程序，因此正确规划和迭代部署新的端到端测试程序非常重要。
如果子系统出现故障，未能进行端到端测试可能会导致应用程序崩溃。
例如，假设您购买了 Evernote 这样的软件产品。从您作为最终用户的角度来看，该过程可能如下所示：
访问 Evernote 网站。导航至“比较计划”页面，了解成本、功能和规格。选择高级计划并点击“免费试用”。继续创建用户名和密码，然后单击“继续”。输入您的账单信息，然后单击“开始免费试用”。登陆 Evernote 的网络应用程序主页。从主页导航到“比较计划”页面。单击高级计划上的“免费试用”按钮。填写并提交用户名和密码字段以创建帐户。输入并提交账单信息。 然后，您可能还会收到一封确认您注册的电子邮件，然后是一封包含有关如何使用 Evernote 的资源的后续电子邮件。
从开始到结束，您希望此过程能够从网站加载到能够导航注册过程并接收电子邮件无缝流动。
作为最终用户，您不会考虑每个步骤所依赖的后端系统，但对于 Evernote 的质量保证和控制团队来说，仅此用户流程中的步骤数量就可能使测试其平台变得复杂且耗时-消耗。包括核心应用程序之外的其他服务，例如支付处理器和电子邮件系统，测试完整的工作流程可能是一场噩梦。
验证保持网站正常运行和响应所需的网络基础设施是否正常工作、用户界面的外观和功能是否符合预期、您共享的私人财务信息在传输过程中和静态时都经过加密、电子邮件是否正确触发和发送……
移动部件的数量可能相当巨大，并带来了一系列故障点和可能性。
端到端测试不仅确保像这样的复杂工作流程从用户的角度跨各种界面运行，而且还确保 Evernote 的应用程序、网络设备以及（可能是第三方）电子邮件和应用程序之间的信息流。信用卡处理平台也按预期工作。
端到端测试流程 由于其范围广泛，端到端测试可以由许多复杂且独特的部分组成，但基本过程如下：
需求规划：分析您现有的系统和子系统，并定义最低和建议的软件和硬件需求。E2E系统设计：概述端到端测试系统的组件、工具、工作流程、方法和指标，以及所有相关团队成员的个人角色和职责。测试组件设计：为每个子系统设计单独的测试用例。测试基础设施开发：编写测试用例并设置测试环境所需的硬件和软件基础设施。测试执行和测量：测试您的系统，记录所有输入和输出数据，并根据您的目标指标进行分析，以识别缺陷和故障。 端到端测试方法 端到端测试主要通过两种方式进行：水平测试和垂直测试。
横向端到端测试 横向端到端测试主要从用户的角度进行操作，从头到尾逐步执行应用程序业务逻辑的每个阶段，以确保每个相互关联的流程正确执行。
在我们的 Evernote 示例中，他们的应用程序不仅需要从 UI 角度工作，还需要与其支付处理器和电子邮件系统以及网络和数据库基础设施正确集成。
由于水平测试发生在发布周期结束时（当系统和子系统的更改完成时），因此测试团队在执行之前完全设置测试环境至关重要。
垂直端到端测试 垂直端到端测试涉及从上到下测试应用程序架构的每一层，这意味着每个子系统都是独立测试的，然后通过网络基础设施、API 集成和 UI 层继续测试。
因此，在我们的 Evernote 示例中，他们的核心系统将通过单元测试进行精细测试，然后是支付处理系统，然后是电子邮件系统，然后再继续测试网络、API 集成，最后是 UI。
由于其关注点细化，垂直测试通常使用行为驱动开发、测试驱动开发或持续测试等策略更多地集成到开发周期中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/798aa472c97c982fa2defa18031ec39f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7949da196ff794166301d518f6c32db/" rel="bookmark">
			多客户数据库数据更新如何实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景描述 对于一个系统往往不止一个客户使用（注意：不是用户，是客户，例如A大学是一个客户、B大学是另一个客户），那么这时，对于系统中的数据结构（例如表设计、字段设计等等）往往是需要更改、完善的，那为了不一一去各个数据库执行相关sql，只想配置一次，从而做到各个数据库都可以更新到相关的数据结构，如何进行除了？
解决思路 首先，客户需要用到数据，一定是进入到系统的，而进入到系统，就一定会经过登入这一操作。
因此，可以通过设置代码全局静态版本号，与数据库存入的版本号进行比对，如果不一致，则进行数据更新，如果一致，则直接进行登入。（这样处理的一个好处就是，每一次的系统数据结构的更迭，只需要一个用户登入一次系统，触发一次数据更新即可）
解决方法 一般来说，对于检查数据结构的更改有：检查表是否存在、检查表字段是否存在、检查表字段是否升级（字段类型变化、长度变化、默认值变化、检查数据是否需要初始化）
此时需要注意：
1. 对于检查是否需要更新的数据结构需要配置在代码中； 1. 对于检测是否更新可以做一个标识，标识当前是否满足了数据结构，不满足则进行更新（例如：对于检测表结构，这个标识可以取最近最新添加的表进行配置，检测数据库中是否存在该表，如果不存在，则进入表升级配置里面进行表升级）； 1. 在配置相关的sql时，可以统一进行一个底层方法的执行，这样就可以避免一个数据结构的更改创建一次连接执行一次sql了。 实现方式如下：
图3-1
代码实现举例：
//代码3.1检测版本-&gt;检测结构-&gt;得到返回的对象-&gt;进行sql执行而升级 //检测版本号从而判断是否需要升级 String updateVersion = iSelectSQLService.acquireUpdateVersion(dbName);//获取数据库存储的版本号 iUpdateLog.saveStep(maxLastUpdateIndex, dbName, "检查账套升级版本号和上次升级成功版本号是否一致？");//保存进度、日志 if (StringUtils.isNotEmpty(updateVersion) &amp;&amp; updateVersion.equals(UpdateVersion.JavaUpdateVersion)) { sMsg = "账套数据库[" + request.getAccDBName() + "]升级版本号与上次一致, 无需升级"; iUpdateLog.saveStep(maxLastUpdateIndex, dbName, sMsg);//保存进度、日志 result.put("result", true); return success(sMsg, result); } sMsg = "升级版本号不一致，需要升级"; iUpdateLog.saveStep(maxLastUpdateIndex, dbName, sMsg);//保存进度、日志 ​ //检测数据库是否需要升级 iUpdateLog.saveStep(maxLastUpdateIndex, dbName, "检测数据库是否需要升级？");//保存进度、日志 Boolean aBoolean = iAutoUpdateDB_acc.checkIsNeedUpdate_Acc(iUpdateLog, maxLastUpdateIndex, dbName);//检测表结构是否需要升级 统一进行相关检测 如下 3.2 if (aBoolean) {//进行表升级 sMsg = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7949da196ff794166301d518f6c32db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f54ee78373d782e1bc969017dc2c9bf3/" rel="bookmark">
			系统开发完整流程--------整体介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一名软件开发工程师,我们需要了解在软件开发过程中的开发流程， 以及软件开发过程中涉及到的岗位角色，角色的分工、职责， 并了解软件开发中涉及到的三种软件环境。那么这一小节，我们将从 软件开发流程、角色分工、软件环境 三个方面，来整体上介绍一下软件开发.
1.1 软件开发流程 1). 第1阶段: 需求分析
完成产品原型、需求规格说明书的编写。 产品原型，一般是通过网页(html)的形式展示当前的页面展示什么样的数据, 页面的布局是什么样子的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。 需求规格说明书， 一般来说就是使用 Word 文档来描述当前项目有哪些功能，每一项功能的需求及业务流程是什么样的，都会在文档中描述。
2). 第2阶段: 设计
设计的内容包含 产品设计、UI界面设计、概要设计、详细设计、数据库设计。
在设计阶段，会出具相关的UI界面、及相关的设计文档。比如数据库设计，需要设计当前项目中涉及到哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字段，字段类型都会在文档中描述清楚。
3). 第3阶段: 编码
编写项目代码、并完成单元测试。
作为软件开发工程师，我们主要的工作就是在该阶段， 对分配给我们的模块功能，进行编码实现。编码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。
4). 第4阶段: 测试
在该阶段中主要由测试人员, 对部署在测试环境的项目进行功能测试, 并出具测试报告。
5). 第5阶段: 上线运维
在项目上线之前， 会由运维人员准备服务器上的软件环境安装、配置， 配置完毕后， 再将我们开发好的项目，部署在服务器上运行。
我们作为软件开发工程师， 我们主要的任务是在编码阶段， 但是在一些小的项目组当中， 也会涉及到数据库的设计、测试等方面的工作。
1.2 角色分工 学习了软件开发的流程之后， 我们还有必要了解一下在整个软件开发过程中涉及到的岗位角色，以及各个角色的职责分工。
岗位/角色职责/分工项目经理对整个项目负责，任务分配、把控进度产品经理进行需求调研，输出需求调研文档、产品原型等UI设计师根据产品原型输出界面效果图架构师项目整体架构设计、技术选型等开发工程师功能代码实现测试工程师编写测试用例，输出测试报告运维工程师软件环境搭建、项目上线 上述我们讲解的角色分工, 是在一个项目组中比较标准的角色分工, 但是在实际的项目中, 有一些项目组由于人员配置紧张, 可能并没有专门的架构师或测试人员, 这个时候可能需要有项目经理或者程序员兼任。
1.3 软件环境 在我们日常的软件开发中，会涉及到软件开发中的三套环境， 那么这三套环境分别是: 开发环境、测试环境、生产环境。 接下来，我们分别介绍一下这三套环境的作用和特点。
1). 开发环境(development)
我们作为软件开发人员，在开发阶段使用的环境，就是开发环境，一般外部用户无法访问。
比如，我们在开发中使用的MySQL数据库和其他的一些常用软件，我们可以安装在本地， 也可以安装在一台专门的服务器中， 这些应用软件仅仅在软件开发过程中使用， 项目测试、上线时，我们不会使用这套环境了，这个环境就是开发环境。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f54ee78373d782e1bc969017dc2c9bf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03a11fa5bfc40ebe09c2121550a26ba5/" rel="bookmark">
			【笔记】docker容器中，gitlab备份与恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		备份 //进入docker容器 docker exec -it 容器id bash //执行备份命令 gitlab-rake gitlab:backup:create 备份完成文件保存在 容器的/var/opt/gitlab/backups/目录下。
gitlab-secrets.json和gitlab.rb文件需要手动进行备份
备份完成后将备份文件copy到宿主机中进行保存
docker cp 容器名称:/var/lib/gitlab/backup/备份文件名称.tar /宿主机目录 恢复 使用docker cp 将备份文件copy到需要恢复备份的gitlab容器中
进入容器执行gitlab恢复备份命令
//停止puma服务 gitlab-ctl stop puma //执行恢复备份 gitlab-rake gitlab:backup:restore BACKUP=备份文件的时间戳前缀 备份恢复完成，gitlab-secrets.json和gitlab.rb文件需要手动进行恢复
//恢复完成后重启gitlab gitlab-ctl restart 启动完成后自动登录web验证
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9da74066af7120e0410378e47565527/" rel="bookmark">
			【记录】gitlab bundle 占用cpu过多
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改配置文件gitlab.rb，puma['worker_processes'] = 4
参考文章：gitlab部署后内存占用过多_gitlab bundle_xiaoniuxqq的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08e49f9b6e6fd2166cd78af9c4237010/" rel="bookmark">
			C&#43;&#43;中函数原型和函数定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中函数原型和函数定义 C++函数原型指的是函数声明的语法形式，它告诉编译器函数的名称、返回类型和参数列表。函数原型的语法形式如下：
return_type function_name(parameter_list); 其中，return_type 是函数返回值的数据类型，function_name 是函数的名称，而 parameter_list 是函数参数的列表，包括参数的数据类型和名称。例如，下面是一个简单的 C++ 函数原型的例子：
int sum(int a, int b); 函数原型指出了函数的名称（Area）、函数接受的参数列表（一个名为 radius 的 double 参数）以及返回值的类型（double）。
如果没有函数原型，编译器在 main() 中遇到 Area 和 Circumference 时，将不知道这两个是什么。函数原型告诉编译器， Area 和 Circumference 是函数，它们接受一个类型为 double 的参数，并返回一个类型为 double 的值。这样，编译器将意识到这些语句是合法的，而链接器负责将函数调用与实现关联起来，并确保程序执行时将触发它们。
函数原型的作用是让编译器知道函数的存在和形式，这样在程序中调用函数时，编译器就可以进行参数类型检查和类型转换，以及对函数返回值的处理。函数原型还可以帮助程序员在程序中使用多个源文件时避免函数名称冲突的问题。
注意：
函数可接受用逗号分隔的多个参数，但只能有一种返回类型。 编写不需要返回任何值的函数时，可将其返回类型指定为 void。 函数的实现被称为函数定义。下面来分析函数 Area() 的定义：
double Area(double radius) { return Pi * radius * radius; } 函数定义总是由一个语句块组成。除非返回类型被声明为 void，否则函数必须包含一条 return 语句。就这里而言，函数 Area() 需要返回一个值，因为其返回类型为 double。语句块是包含在左大括号和右大括号（ {}）内的语句，在函数被调用时执行。 Area() 使用输入参数 radius 来计算圆的面积，该参数包含调用者以实参方式传递的半径。
如果函数声明中包含形参（parameter），调用函数时必须提供实参（argument），它们是函数的形参列表要求的值。下面来分析程序中对函数 Area() 的调用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08e49f9b6e6fd2166cd78af9c4237010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c559bfffc09b79f6d558aaf34317e509/" rel="bookmark">
			idea显示git分支信息(GitToolBox插件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图 说明 本身idea在右下角会有git分支信息，但是显示的当前打开文件的分支信息，并且不够显眼
解决 1、安装插件(GitToolBox插件) 2、修改idea.properties project.tree.structure.show.url=false ide.tree.horizontal.default.autoscrolling=false 将上分配置写入到idea.properties文件中
注: idea项目默认显示的是路径，把这个路线显示去掉，以及去掉自动滚动
3、配置(GitToolBox插件) 由于开发使用git命令拉取提交代码，故将auto fetch自动拉取去掉了，具体配置根据个人情况选择。
4、重启 不论是安装插件还是修改idea.properties，记得重启idea
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68914642ac02a787012d015a8129c72c/" rel="bookmark">
			青龙面板集合仓库（不断更新）青龙面板，京东定时任务库，脚本库大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
'【注意】不可同时拉多个集合库，同时拉多个集合库容易黑ip，保留一个即可。
拉了好几个大库的记得运行一下去重脚本。
下面最新更新
2.拉库合集
没有先后顺序 好不好用自测
faker2 (助力池版) 拉库代理 https://git.metauniverse-cn.com/
ql repo https://git.metauniverse-cn.com/https://github.com/shufflewzc/faker2.git “jd_|jx_|gua_|jddj_|jdCookie” “activity|backUp” “jd[]|USER|function|utils|sendNotify|ZooFaker_Necklace.js|JDJRValidator|sign_graphics_validate|ql|JDSignValidator|magic|depend|h5sts” “main”
faker3 (纯内部助力版本) 拉库代理 https://git.metauniverse-cn.com/
ql repo https://git.metauniverse-cn.com/https://github.com/shufflewzc/faker3.git “jd_|jx_|gua_|jddj_|jdCookie” “activity|backUp” “jd[]|USER|function|utils|sendNotify|ZooFaker_Necklace.js|JDJRValidator|sign_graphics_validate|ql|JDSignValidator|magic|depend|h5sts” “main”
kr 拉库代理 http://hub.fgit.ml/
ql repo https://github.com/KingRan/KR.git “jd_|jx_|jdCookie” “activity|backUp” “jd[_]|USER|utils|function|sign|sendNotify|ql|JDJR”
船长
ql repo https://github.com/HarbourJ/HarbourToulu.git “jd_” “activity|backUp|jd_sign” “jd[]|USER|utils|ZooFaker_Necklace|JDJRValidator|sign_graphics_validate|jddj_cookie|function|ql|magic|JDJR|JD|sendNotify” “main”
6dy 拉库代理 ghproxy.com 拉不动改备用代理 js.dayplus.xyz
ql repo https://ghproxy.com/https://github.com/6dylan6/jdpro.git “jd_|jx_|jddj_” “backUp” “jd[_]|USER|JD|function|sendNotify”
保护环境 (助力池版)
ql repo https://github.com/feverrun/my_scripts.git “jd_|jx_|jddj_|getCookie|getJDCookie” “backUp” “(jd|JD|JS)[_]|USER|sendNotify|utils”
保护环境 (纯内部助力版本)
ql repo https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68914642ac02a787012d015a8129c72c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62f1e34ff4a2af835e3ffd41b204d425/" rel="bookmark">
			linux 内核配置usb支持sd卡识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先配置SCSI如下图 再配置usb驱动支持storage 就是这么简单
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/234ef0d72824e4c58c865bd6fb311be9/" rel="bookmark">
			基于深度学习的加密恶意流量检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加密恶意流量检测 研究目标定位数据收集数据处理基于特征分类算法的数据预处理基于源数据分类算法的数据预处理 特征提取模型选择基于数据特征的深度学习检测算法基于特征自学习的深度学习检测算法 训练和评估精确性指标实时性指标 应用检验改进 摘录自：Mingfang ZHAI,Xingming ZHANG,Bo ZHAO. Survey of encrypted malicious traffic detection based on deep learning[J]. Chinese Journal of Network and Information Security, 2020, 6(3): 66-77.
网络信息安全学报：Survey of encrypted malicious traffic detection based on deep learning
本文归纳总结“六步法”的加密恶意流量检测一般框架模型，为问题研究提供帮助。
“六步法”框架是针对加密恶意流量检测问题的，但对于普通的流量识别问题仍然适用（普适性）。
加密恶意流量检测的本质是学习数据特征，将流量数据进行正确分类。
如下是“六步法”的模型构造
研究目标定位 流量通常由5元组决定：源IP、目标IP、源端口、目标端口和协议。
可按以下方面对流量进行分类：
1）协议，如SSH、SSL/TLS
2）应用，如微信、滴滴出行、百度地图
3）服务，如聊天。购物
4）网站，如谷歌、百度
5）用户行为，如浏览、下载、上传
具体就加密流量而言，通常分为加密与未加密识别、加密协议识别、加密服务识别和恶意流量检测。
加密与未加密识别主要将流量区分为加密流量和非加密流量。加密协议识别是根据协议的不同对加密流量进行归类。加密服务识别是将流量按特征、服务类别或者应用程序进行分类。异常流量检测的目的在于检测出隐藏在加密流量之中的DDoS、APT、Botnet等恶意流量，是保障网络安全的重要手段。 与加密协议识别和加密服务识别相比，异常流量检测的难点有：
①攻击者常常利用协议规则将攻击流量伪装成正常流量，增加检测的难度。
②数据集严重不平衡，攻击流量远远小于正常流量，可能会产生训练不充分的问题，从而影响检测精度。
③检测错误代价大，因此对检测精度要求更高。
下图是加密流量识别分类结构
数据收集 直接收集法：常用的数据采集软件有Wireshark、Sniffer、Fiddler等。
脚本收集法：拟合大多现有的攻击模式。
混合方法：直接收集法+脚本收集法。
数据处理 数据预处理是指将未加工数据转换为适合分析的形式，包括多数据源的数据融合、数据清洗、维规约等。
基于特征分类算法的数据预处理 该方法需要将原始数据处理为打上各种特征标签的数据，如统计标签、时间序列等，而后送入算法模型检测恶意流量与正常流量。
数据清洗：数据清洗是指对数据进行重新审查和校验的过程，目的在于删除重复信息、纠正存在的错误。对数据中存在的无效值或错误值常采用删除的方法，包括整列删除、变量删除和成对删除等方法。对缺失值处理有均值插补、同类均值插补及高维映射等方法。
数据集成：数据集成是将多个数据源收集的数据整合在一起，主要的困难在于多个数据源异构的问题，即几个数据源并不完全一致，收集的数据格式、长度等不同，相互之间存在冗余和不兼容等问题。
数据变换：数据变换即对数据进行规范化处理，以便于后续的信息挖掘，主要包括数值化、中心化和规范化等内容。数值化就是将非数据信息转化为数据，如网络协议信息，可用简单数值表示。中心化是指将数据减去均值或者某个指定数值的操作。规范化目的在于把数据整合到[0,1]内以方便实验，常用最大值规范化方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/234ef0d72824e4c58c865bd6fb311be9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7a3e5145e280cc942261a1d2ba17d65/" rel="bookmark">
			如何将 OBJ 模型转换和压缩为 GLTF 以与 AWS IoT TwinMaker 配合使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐：使用NSDT场景编辑器快速搭建3D应用场景
概述 在这篇博文中，引用了几种文件扩展名和模型格式。在开始之前，最好了解以下内容：
OBJ – 对象文件，一种标准的 3D 图像格式，可以通过各种 3D 图像编辑程序导出和打开。MTL – 材料库文件，包含一个或多个材料定义，每个定义都包括 OBJ 模型中对象的各个材料的颜色、纹理和反射图glTF – 图形语言传输格式，三维场景和模型的标准文件格式。glTF 模型使用两种可能的文件扩展名之一：.gltf 或 .glbDraco Compression – 用于网格压缩的glTF扩展。此cesium库将压缩和解压缩 3D 网格，以显着减小 3D 内容的大小。它可以压缩顶点位置、法线、颜色、纹理坐标和任何其他通用顶点属性，从而提高通过 Web 传输 3D 内容的效率和速度。点云扫描 – 3D 空间内单个点（x、y、z 坐标）的大量集合，使用 3D 激光扫描仪捕获并以 ASCII （.xyz） 或二进制格式存储。 AWS IoT TwinMaker 支持 glTF 格式的 3D 资产，这是一种 3D 文件格式，以 JSON 格式或二进制格式存储 3D 模型信息，可在应用程序中高效传输和加载 3D 模型。glTF 模型最大限度地减少了 3D 资产的大小以及解压缩和使用它们所需的运行时处理。来自传统 CAD 应用程序的 3D 模型以及点云扫描可以使用 AWS 合作伙伴解决方案（例如 Pixyz 的解决方案）转换为 glTF。在这篇博客中，您将探索另一种无服务器方法，使用 Cesium 的开源库（包括 obj2gltf 和 gltf-pipeline）将 Matterpak 捆绑包转换为glTF 模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7a3e5145e280cc942261a1d2ba17d65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7672cd3a1e7157ff756997c98d299c17/" rel="bookmark">
			JavaScript之innerHTML和outerHTML，innerText和outerText
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		document对象中有innerHTML、innerText这两个属性，都是获取document对象文本内容，但使用起来还是有区别的；
区别 1） innerHTML设置或获取标签所包含的HTML+文本信息(从标签起始位置到终止位置全部内容，包括HTML标签，但不包括自身)
2） outerHTML设置或获取标签自身及其所包含的HTML+文本信息（包括自身）
3） innerText设置或获取标签所包含的文本信息（从标签起始位置到终止位置的内容，去除HTML标签，但不包括自身）
4） outerText设置或获取标签自身及其所包含的文本信息（包括自身）
innerText和outerText在获取的时候是相同效果，但在设置时，innerText仅设置标签所包含的文本，而outerText设置包含包括标签自身在内的文本。
例子1：outerHTML和innerHTML的区别 document.body.outerHTML:
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;aa&lt;/div&gt; &lt;script type="text/javascript"&gt; alert(document.body.outerHTML); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 结果：
document.body.innerHTML:
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;aa&lt;/div&gt; &lt;script type="text/javascript"&gt; alert(document.body.innerHTML); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 结果：
通过不同的结果可以得出：outerHTML属性比innerHTML属性多包含了&lt;body&gt;标签
还有需要注意的是：
innerHTML是所有浏览器都支持的属性。outerHTML属性不是DHTML标准，IE外的其它浏览器不支持。
在非IE浏览器下必须使用扩展方法才能获取，扩展方法如下：
if(typeof(HTMLElement)!="undefined" &amp;&amp; !window.opera) { var pro = window.HTMLElement.prototype; pro.__defineGetter__("outerHTML", function(){ var str = "&lt;" + this.tagName; var a = this.attributes; for(var i = 0, len = a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7672cd3a1e7157ff756997c98d299c17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c72fca7b0ea9bcf601fab3834e1497ae/" rel="bookmark">
			【密码学】密码学中的常见概念简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、对称密码（共享钥匙密码）---用相同的密钥进行加密和解密 1.何为编码？ 将现实世界的东西映射为比特序列的操作称为编码（encoding）。例如midnight这个词，我们就可以对其中每个字逐一进行编码，这种编码规则叫做ASCII。
2.XOR 0 XOR 0 = 0
0 XOR 1 = 1
1 XOR 0 = 1
1 XOR 1 = 0
也就是说相同则为0，不同则为1。
将结果与其中一项重新新异或（XOR），可以还原另外一项。
用于与明文异或的随机比特序列就是密钥，与明文异或得到的结果就是密文，将密钥重新与密文异或可以得到明文。
3.一次性密码本 号称永远不会被破译的加密方式，事实上的确是这样。然而没卵用，就是将保护明文变成了保护与明文相同长度的密钥，没有根本性解决问题。
4.DES（Data Encryption Standard） DES已经能够被暴力破解。所以不推荐使用哦。
DES是以64比特的明文为一个单位进行加密的，这个64比特的单位称为分组。
它的密钥长度是56比特，尽管从规格上说，DES密钥长度是64比特，但由于每隔7比特就会设置一个用于错误检查的比特，实质上是56比特。
DES的结构（Feistel网络）
Feistel网络中，加密的各个步骤称为轮（round），整个加密过程就是若干次轮的循环。
DES是一种16轮循环的Feistel网络。
DES一轮的具体计算步骤如下：
将输入的数据等分为左右两部分。将输入的右侧直接发送到输出的右侧。将输入的右侧发送到轮函数。轮函数根据右侧数据和子密钥，计算出一串看上去随机的比特序列。将上一步得到的比特序列与左侧数据进行XOR运算，并将结果作为加密后的左侧。 通过上面的步骤来看，“右侧”根本就没有加密，因此需要每两轮处理只见将左侧和右侧数据对调。
用相同的子密钥重新运行一轮即可还原。
加密和解密使用完全相同的结构来实现。
5.三重DES 三重DES是为了增加DES的强度，将DES重复三次所得到的一种密码算法，也称为TDEA，通常缩写为3DES。
三重DES并不是进行三次DES加密（加密-加密-加密），而是（加密-解密-加密）。这是IBM公司设计出来的，目的是为了让三重DES能够兼容普通的DES（三次密钥相同即为普通的DES，但是浪费运算。）
三重DES的解密与加密完全相反，为（解密-加密-解密）。
6.AES 1997年，NIST开始公开募集AES。
AES的选拔，不仅考虑一种算法是否存在弱点，算法的强度，实现的容易性等也在考虑范围内。不仅加密本身的速度要快，密钥准备的速度也很重要。此外，还需要能够在各种平台上有效工作。
2000年，Rijindeal力压群雄，被NIST选定为AES标准。
在AES规格中，分组长度固定为128比特，密钥长度有128、192和256比特三种。
与DES一样，Rijindeal算法也是由多个轮构成，其中每一轮分为SubBytes、ShiftRows、MixColumns和AddRoundKey共四个步骤。
AES没有使用Feistel网络作为基本结构，而是使用了SPN结构。
AES一轮的步骤如下：
SubBytes 逐字节（1字节为8比特）替换，（在字节中对比特进行替换）4*4=16字节。ShiftRows处理，这一步是将以4字节为单位的row按照一定的规则向左平移，且每一行平移的字节数是不同的。MixColumns处理，这一步是对一个4字节的值进行比特运算，将其变为另外一个4字节的值。最后需要将MixColumns的输出与轮密码进行XOR，即AddRoundKey处理。 AES需要重复进行10~14轮计算。
AES的解密就是将上述步骤反过来。
二、分组密码的模式 ---分组密码是如何迭代的 DES和AES都属于分组密码，他们只能加密固定长度的明文。如果需要加密任意长度的明文，就需要对分组密码进行迭代，而分组密码迭代的方法就成为分组密码的“模式”。
分组密码有多种模式，如果模式选择不恰当，就无法充分保证机密性。
1.分组密码和流密码 分组密码是每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”就称为分组。此外，一个分组的比特数就称为分组长度。
如DES和三重DES的分组长度都是64比特，AES将128比特明文转化为128比特密文。
DES将64比特明文转换为64比特密文，AES将128比特明文转化为128比特密文。
流密码是对数据进行连续处理的一类密码算法。流密码一般以1比特、8比特或32比特等为单位进行加密和解密。
分组密码处理完一个分组就结束了，因此不需要通过内部状态记录它加密的进度；相对的，流密码是对一串数据流进行连续处理，因此需要保持内部状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c72fca7b0ea9bcf601fab3834e1497ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71fdfb935e49c5f7c4de0f6712f37fc3/" rel="bookmark">
			Jsoup | Document | HTML解析器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jsoup 一、获取 `&lt;p&gt;`标签下的所有图片 一、获取 &lt;p&gt;标签下的所有图片 &lt;p&gt; &lt;img style="max-width: 100%;" src="http://image.svipjf.cn/1678271098160-480_01.jpg"/&gt;&lt;img src="http://image.svipjf.cn/1678271097994-480_02.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271098267-480_03.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271098250-480_04.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271098309-480_05.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271098307-480_06.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271098336-480_07.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271098490-480_08.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271098564-480_09.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271098624-480_10.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271098721-480_11.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271098698-480_12.jpg"/&gt; &lt;/p&gt; &lt;p&gt; &lt;img style="max-width: 100%;" src="http://image.svipjf.cn/1678271215342-爱马仕橙.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271215539-烟波蓝.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271215306-薄荷绿.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271215248-橙灰.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271215353-拉菲红.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271215338-湘妃玉.jpg"/&gt; &lt;img src="http://image.svipjf.cn/1678271215342-蓝灰.jpg"/&gt; &lt;/p&gt; Java代码
List&lt;String&gt; descImgList = new ArrayList&lt;&gt;(); if (StringUtils.isNotBlank(description)) { Document document = Jsoup.parse(description); Elements elements = document.select("img"); for (Element element : elements) { String src = element.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71fdfb935e49c5f7c4de0f6712f37fc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203ce79120788abef9d9915bfc0d737f/" rel="bookmark">
			CSDN中，如何创建目录或标题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建目录或标题 1.复制，自动生成目录2.复制，自动生成标题3.CSDN标准写法如下图 1.复制，自动生成目录 @[TOC] 或
@[TOC](这里写目录标题) # 一级目录 ## 二级目录 ### 三级目录 2.复制，自动生成标题 # 一级目录 ## 二级目录 ### 三级目录 3.CSDN标准写法如下图 —————————————————————
以上就是今日博客的全部内容了
创作不易,若对您有帮助,可否点赞、关注一二呢, 感谢支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/928a43e77e28e99ddb33266b547c3df3/" rel="bookmark">
			JavaWeb项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
效果展示
1. 创建 maven 项目
2. 设计数据库
3. 封装数据库的操作代码
3.1 创建 DBUtil 类
3.2 创建类 Blog (代表一篇博客)
3.3 创建类 User (代表一个用户)
3.4 创建类 BlogDao (对博客表进行操作)
3.5 创建类 UserDao (对用户表进行操作)
4. 导入之前写好的前端代码
5. 实现博客主页界面
5.1 约定好前后端交互接口
5.2 实现 IndexServlet
5.3 实现前端代码
6. 实现博客详情界面
6.1 约定好前后端交互接口
6.2 实现 DetailsServlet
6.3 实现前端代码
7. 实现博客登录界面
7.1 约定好前后端交互接口
7.2 实现 LoginServlet
7.3 实现前端代码
8. 实现登录判定的功能
8.1 创建一个 Common类 来判定当前登录状态
8.2 在Sevlet代码中加入判定
8.3 更改前端代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/928a43e77e28e99ddb33266b547c3df3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/256f8576203d775648786c41e29328f6/" rel="bookmark">
			Android入门教程 | ImageView 图片显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了让App界面更美观生动，我们可以放上图片。 显示图片是“刚需”。不论是书籍，报纸，网站，都有显示图片的需求。毕竟“无图无真相”。 在 Android 应用开发中，我们通常使用 ImageView 来显示图片。
ImageView的主要属性 ImageView的使用 ImageView经常用来显示图片。例如直接显示drawable里的图片资源。 ImageView显示的是Drawable对象。
src 与 backGround 的区别 在 layout xml 中，我们先来看一下 src 与 backGround 的区别。
backGround 是 View（ImageView是View的子类）的背景，会把图片拉大铺满整个View。src 是 ImageView 的属性，接受要展示的图片资源。 为方便后续表述，先给ImageView指定一个style，统一大小。再设置一个默认背景颜色。
&lt;style name="IvDemo1"&gt; &lt;item name="android:layout_width"&gt;100dp&lt;/item&gt; &lt;item name="android:layout_height"&gt;80dp&lt;/item&gt; &lt;item name="android:background"&gt;#929292&lt;/item&gt; &lt;item name="android:layout_marginTop"&gt;4dp&lt;/item&gt; &lt;/style&gt; 在 drawable目录中增加一张图片。图片的宽长比和 style 设置的不一样。方便我们查看图片效果。
在示例 xml 中，展示 src 与 backGround 的区别。
&lt;ImageView style="@style/IvDemo1" android:background="@drawable/pic_2_robots" /&gt; &lt;ImageView style="@style/IvDemo1" android:layout_marginStart="20dp" android:src="@drawable/pic_2_robots" /&gt; 效果：
左边是设置为了background，可以看到图片被拉伸铺满了整个ImageView。 而且图片有一点变形。那是因为图片的宽长比和 ImageView 的宽长比不一致。
右边设置了src，可以看到图片并没有铺满。右边图片的显示方式，就是我们接下来要介绍的 scaleType。
scaleType，图片显示方式 设置了src后，再设置scaleType，能确定图片的显示效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/256f8576203d775648786c41e29328f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f9c7ff70e2a7254a82cd14d459844a8/" rel="bookmark">
			在Vue项目中将Element-Plus语言切换为中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Element-Plus语言默认是英文，但更多人比较习惯使用中文页面，因此本文将会详解如何在Vue项目中将Element-Plus语言切换成中文。
在App.vue中加入以下代码即可 官方文档链接
&lt;template&gt; &lt;el-config-provider :locale="locale"&gt; &lt;RouterView /&gt; &lt;/el-config-provider&gt; &lt;/template&gt; &lt;script&gt; import { defineComponent } from 'vue' import { ElConfigProvider } from 'element-plus' import zhCn from 'element-plus/dist/locale/zh-cn.mjs' export default defineComponent({ components: { ElConfigProvider, }, setup() { return { locale: zhCn, } }, }) &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d48c1e3feb1cc79ad78dffa60bfac6/" rel="bookmark">
			Python工程师Java之路（p）Maven聚合和继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 依赖管理依赖传递可选依赖和排除依赖 继承与聚合 依赖管理 指当前项目运行所需的jar，一个项目可以设置多个依赖
&lt;!-- 设置当前项目所依赖的所有jar --&gt; &lt;dependencies&gt; &lt;!-- 设置具体的依赖 --&gt; &lt;dependency&gt; &lt;!-- 依赖所属群组id --&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;!-- 依赖所属项目id --&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;!-- 依赖版本号 --&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 依赖传递 直接依赖：在当前项目中通过依赖配置建立的依赖关系间接依赖：被资源的资源如果依赖其他资源，当前项目间接依赖其他资源特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的 可选依赖和排除依赖 可选依赖和排除依赖的区别
可选依赖（optional）：对外隐藏当前所依赖的资源
A依赖B，B依赖C，C不想被A依赖进来 &lt;dependency&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;maven_03_pojo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递性--&gt; &lt;optional&gt;false&lt;/optional&gt; &lt;/dependency&gt; 排除依赖（exclusions）：主动断开依赖的资源，被排除的资源无需指定版本
A依赖B，B依赖C，A不想将C依赖进来 &lt;dependency&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;maven_04_dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 继承与聚合 聚合：
将多个模块组织成一个整体，同时进行项目构建的过程
聚合工程：
通常是一个不具有业务功能的空工程（有且仅有一个pom文件）
作用：使用聚合工程可以将多个工程编组，通过对聚合工程进行构建，实现对所包含的模块进行同步构建。
当工程中某个模块发生更新（变更）时，必须保障工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题。
继承描述的是两个工程间的关系，子工程可以继承父工程中的配置信息，常见于依赖关系的继承
作用：
1、简化配置
2、减少版本冲突
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40d48c1e3feb1cc79ad78dffa60bfac6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e022270e3bf5782136c259d25c0270/" rel="bookmark">
			Java反射机制简单入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 标题 反射能干嘛获取Class对象的三种方式下面开始重点，需要掌握获取类的构造器并进行操作获取成员变量获取成员方法 这块建议先听第一个视频入门，第二个视频深入了解
视频学习地址1
视频学习地址1
正射:知道某个类，类的地址，通过new关键字创建出对象，然后使用对象，编程时就知道了，直接在代码中new。
反射: Java反射机制是在运行状态中，对于任意一个类，都能够直到这个类的所有属性和法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。
反射能干嘛 获取Class对象的三种方式 下面开始重点，需要掌握 获取类的构造器并进行操作 建议使用getDeclaredConstructors，注意获取不到构造器时，可能会报错的呦
上面我们拿到了构造器，下面怎么操作这个构造器呢，能干什么
获取成员变量 获取成员方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55ce5ac2b84240d6d623738b03fad5b0/" rel="bookmark">
			基于Python的UG二次开发入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基于Python的UG二次开发入门1 二次开发环境搭建1.1 安装UG1.2 安装Pycharm1.3 环境配置1.4 测试 2 NX Open介绍2.1 基础架构2.1.1 Sessions and Parts2.1.2 Objects and Tags2.1.3 Factory Objects（工厂对象）2.1.4 Builder Objects（生成器对象）2.1.5 导出NX Open脚本 2.2 位置, 向量和点2.2.1 Point3d2.2.2 Vector3d2.2.3 Points 2.3 更多内容 3 参考资料 基于Python的UG二次开发入门 1 二次开发环境搭建 环境配置：
NX12.0Python3.6.1Pycharm2023 1.1 安装UG 去微信公众号搜“软件安装管家”，在软件目录中找到UG12.0安装教程，一步步跟着安装就行，这里不多赘述。
1.2 安装Pycharm 下载地址：PyCharm: the Python IDE for Professional Developers by JetBrains。
网上关于Pycharm的安装教程也比较丰富，这里同样省略。
1.3 环境配置 获取NX对应的python版本。
访问NX安装路径下的NXBIN目录，找到python的动态库文件，右键属性-&gt;详细信息，获取对应的python版本，我的电脑中版本为python3.6.1。
运行Anaconda Prompt，新建python虚拟环境。
conda create -n NXOpen_env python=3.6.1 失败了，找不到python3.6.1的包。
换一种方法，去python官网下载python3.6.1并安装。
下载地址：Python Release Python 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55ce5ac2b84240d6d623738b03fad5b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f21bb84fd606d6a5874d3645c48ae533/" rel="bookmark">
			ubuntu命令连接wifi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sudo service network-manager restart sudo nmcli dev wifi sudo nmcli dev wifi connect "Pang" password "996996996" ubuntu@ubuntu-desktop:~/rk/x3566_android11$ sudo service network-manager restart [sudo] ubuntu 的密码： ubuntu@ubuntu-desktop:~/rk/x3566_android11$ sudo nmcli dev wifi IN-USE BSSID SSID MODE CHAN RATE SIGNAL BARS SECURITY FA:8C:21:AA:21:DE -- Infra 6 540 Mbit/s 77 *** WPA1 WPA2 F8:8C:21:8A:21:DE 33dewifi/2.4g Infra 6 540 Mbit/s 75 *** WPA1 WPA2 F4:6A:92:5E:C0:0A B1111 Infra 13 270 Mbit/s 72 *** WPA1 WPA2 16:F6:D8:67:26:45 pang Infra 13 195 Mbit/s 72 *** WPA2 2C:55:7C:78:77:10 ChinaNet-UKy9 Infra 6 130 Mbit/s 44 ** WPA1 WPA2 D8:A8:C8:E5:B7:28 ChinaNet-w5cu Infra 3 130 Mbit/s 40 ** WPA1 WPA2 F4:B7:8D:53:50:B0 topway1101 Infra 6 130 Mbit/s 40 ** WPA1 WPA2 48:A7:3C:56:F5:21 ChinaNet-1112 Infra 6 130 Mbit/s 37 ** WPA1 WPA2 90:16:BA:73:3B:58 topway1105 Infra 9 130 Mbit/s 35 ** WPA1 WPA2 F4:6A:92:5E:C0:0B B1111_5G Infra 157 270 Mbit/s 35 ** WPA1 WPA2 02:BE:8B:DE:7E:BD -- Infra 1 0 Mbit/s 32 ** WPA2 F8:8C:21:8A:21:E0 33dewifi/5g Infra 48 540 Mbit/s 24 * WPA1 WPA2 ubuntu@ubuntu-desktop:~/rk/x3566_android11$ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbdcf36cbf7244b2d32889bb75407c1d/" rel="bookmark">
			深度学习环境VMware&#43;ubuntu可以实现GPU吗？Windows安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware+Ubuntu别尝试GPU的环境了 基于VMware+ubuntu22.04：如果朋友你还在尝试，我建议放弃，很多文章都在谈及Linux系统的安装深度学习的环境，大都是双系统，或者是租用的服务器。本人一开始坚决认为Win11作为主系统的电脑基于VMware+ubuntu22.04可以实现GPU环境搭建。最关键的问题是我发现它的显卡是虚拟出来的，准确说VMware基于主机的显卡虚拟映射出了一个供uhuntu系统使用的显卡，这个显卡没有合适的驱动去实现基于GPU的深度学习环境搭建。（基于CPU应该可以但我没试）虽然用很多人提到显卡直连什么的大家算了，我整了好久试了好多方法也没实现，虚拟显卡的更改。
如果没有双系统和租用服务器的打算，建议直接搜索Windows下的pytorch环境搭建，十分顺利。
顺便说一下Windows下安装可能出现的问题和注意事项 建议参考https://blog.csdn.net/qq_43874102/article/details/123164105安装
安装Anaconda不想或者配置不明白环境变量就装在C盘。
如果装在其他盘要看清别人的环境变量如何配置的，如果配置不好，在模块导入的时候会报错。大致意思说你VC_redist_x64.exe驱动有问题，不管你重写装载多少遍都是有问题的。我的解决方法就是把anaconda卸载重新安装到C盘，关于anaconda的卸载大家搜索参考别人卸载比较干净的方法。然后按照之前一样安装到C盘就OK了。
如果说在安装pytorch过程中不管利用pip还是conda都不能成功安装，pip应该是说包不存在，conda建议增加网址。其实如果anaconda默认安装到c盘应该不会出现类似的问题。
建议利用pip安装时可以利用如下指令查看错误原因
pip debug --verbose 然后保证你安装的文件后面和上面指令输出的要对应。
建议利用清华镜像下载
CUxxx表示的是CPU驱动，xxx是CUDA的版本号，例如CUDA11.8需要选择cu118，cp39后面是要求的python3.9版本， 建议在安装CUDA的时候选择11.8这个版本目前版本的对应比较全（但是保证一定是小于nvidia-smi输出的版本型号）例如我选择的版本搭配Anaconda3-2023.07-2-Windows-x86_64.exe +cuda_11.8.0_522.06_windows.exe+torch-2.0.0 + cu118-cp39-cp39-win_amd64.whl+torchaudio-2.0.1+cu118-cp39-cp39-win_amd64.whl+torchvision-0.15.0+cu118-cp39-cp39-win_amd64.whl
安装好Anaconda3-2023.07-2-Windows-x86_64.exe +cuda_11.8.0_522.06_windows.exe+torch-2.0.0 这两个之后创建虚拟环境conda conda create -n pytorch39 python=3.9（因为以后我要用和python3.9相匹配的pytorch）conda activate pytorch39进入已经创建的虚拟环境。
然后下载 cu118-cp39-cp39-win_amd64.whl+torchaudio-2.0.1+cu118-cp39-cp39-win_amd64.whl+torchvision-0.15.0+cu118-cp39-cp39-win_amd64.whl在清华镜像网址下载保存到某个文件夹。利用cd 路径到达该文件所在目录pip install 文件名依次安装。
&gt;&gt;&gt; import torch &gt;&gt;&gt; print(torch.__version__) &gt;&gt;&gt; print(torch.cuda.is_available()) 到此结束环境搭建
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27b5bbe66088a69213bd971b801d1baf/" rel="bookmark">
			Python生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、生成器二、生成器练习三、生成器yield的其他用法四、生成器表达式五、yield和return的对比 一、生成器 ''' 生成器对象： 1.本质： 还是内置有__iter__和__next__的迭代器对象 2.区别： 迭代器对象是解释器自动提供的 数据类型/文件对象&gt;&gt;&gt;:迭代器对象 生成器对象是程序员(自己)编写出来的 代码、关键字&gt;&gt;&gt;:迭代器对象(生成器) 3.创建生成器的基本语法 函数体代码中填写yield关键字 4.学习生成器对象的目的 主要是为了优化代码 也是一种不依赖于索引取值的另一方式 可以节省数据类型的内存占用空间(主要) ''' '''生成器基本语法''' def my_iter(): """在函数体代码中填写yield关键字""" print('这是第一行代码') yield 1 # 如果yield后面有数据值 那相当于return一样返回出去 print('这是第二行代码') yield 2,3,4 # 如果有多个数据值，用逗号隔开，会组成元组的形式返回出去 ''' 1.函数体代码中如果有yield关键字 那么函数名加括号并不会执行函数体代码 会生成一个生成器对象(迭代器对象) ''' res = my_iter() #第一次加括号调用不会执行函数体代码 '''使用加括号之后的结果调用__next__才会执行函数体代码''' res.__next__() #直接由函数变成了迭代器对象(生成器) res.__next__() '''每次执行完__next__代码都会停在yield位置， 下次基于该位置继续往下找第二个yield''' res.__next__() # 和迭代器对象一样，当后面没有值继续__next__后会报错：StopIteration 二、生成器练习 '''生成器练习''' '''用生成器来模拟range的三种功能''' for i in range(0,10,2): pass '''先实现两个参数的range的编写''' def my_range(start,end): # 创建一个函数给予两个形参，模拟range的开始和结束 while start &lt; end: # 因为开始值不能大于结束值，不然会无限下去 yield start # 条件成立后进入返回开始值 start += 1 # 每次返回完毕后加1 for i in my_range(0,10): print(i,end=' ') '''在实现一个参数的range的编写''' def my_range(start,end=None):#一个参数的先设置一个形参，可以在写一个默认参数 '''end可以不传值，可以直接弄成默认参数，end=None''' '''代码层面做判断，将形参数据做替换处理''' if not end: # 如果没有给结束传值 end = start # 那么就让结束值等于开始值 start = 0 # 再让开始值从默认0开始 while start &lt; end: # 开始值不能大于结束值 yield start start += 1 for i in range(10): print(i, end=' ') '''最后实现三个参数的range编写''' def my_range(start,end=None, step=1): # 创建一个形参两个关键字参数 if step &lt; 1: # 如果间隔小于1的话，相当于只有两个参数 所以给它默认等于1 step = 1 if not end: # 如果没有传值给end，那就是只有一个参数 start = end # 那么就让end等于start start = 0 # 让start从0开始 while start &lt; end: # 开始值不能大于结束值 yield start # 返回开始值 start += step # for i in my_range(0,20,2): print(i,end=' ') 三、生成器yield的其他用法 def eat(name,food=None): # 创建一个函数，一个形参，第二个参数给它默认参数 print('%s正在吃.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27b5bbe66088a69213bd971b801d1baf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3596d4329b89ebeaf74720e0528d58fe/" rel="bookmark">
			小白学熵权法原理及案例教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：吴裕雄
链接：
吴裕雄 python 熵权法确定特征权重
来源：博客园
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
写在前面：
熵权法也属于一种综合评价方法，没有主观性，可与前面几篇文章提到的方法联合使用。
目录
一、熵权法概述 1.1 信息论基础
信息量：信息量是度量弄清楚一个未知事物需要查询的信息的多少，单位是比特。随机变量取某个值时，其概率倒数的对数就是信息量。通俗的说就是，事物所含信息量与其发生的概率负相关。一件事物出现的概率决定了它的不确定性大小，也就决定了所含信息量的大小。出现的概率越大，不确定性越小，所含信息量也就越小。
信息熵：信息熵也就是信息量的期望。可以把信息熵理解成不确定性的大小，不确定性越大，信息熵也就越大。
X表示的是一个信源。
信息量是对信源发出的某一个信号所含信息的度量，信息熵是对一个信源所含信息的度量，也就是信息量的期望。
1.2 熵权法介绍
熵最先由香农引入信息论，目前已经在工程技术、社会经济等领域得到了非常广泛的应用。
熵权法的基本思路是根据指标变异性的大小来确定客观权重。
一般来说，若某个指标的信息熵越小，表明指标值得变异程度越大，提供的信息量越多，在综合评价中所能起到的作用也越大，其权重也就越大。相反，某个指标的信息熵越大，表明指标值得变异程度越小，提供的信息量也越少，在综合评价中所起到的作用也越小，其权重也就越小。
个人理解：注意上面这段话，说的是提供的信息量，也就是已知的信息。提供的信息量越大，包含的信息也就越小。按照前面信息量的阐述，一个指标变异性越大则发生的概率越大，不确定也就越小，信息量也就越小，解决这个未知事物所需要的信息量也就越小，也就是说它本身提供了较多的信息量。
二、熵权法赋权步骤 2.1 数据标准化
首先将各个指标进行去量纲化处理。
假设给定了m个指标：
，其中
。假设对各指标数据标准化后的值为
,那么
或
2.2 求各指标在各方案下的比值
也就是第j项指标在第i个方案中占该指标的比重，其实也就是为了计算该指标的变异大小。
2.3 求各指标的信息熵。
根据信息论中信息熵的定义，一组数据的信息熵为：
其中Ej≥0。若pij=0，定义Ej=0。
2.4 确定各指标的权重
根据信息熵的计算公式，计算出各个指标的信息熵为E1,E2,…,Em。
2.4.1 通过信息熵计算各指标的权重： 这里k指的是指标个数，即k=m。
2.4.2 也可以通过计算信息冗余度来计算权重：
然后计算指标权值：
2.5 最后计算每个方案的综合评分
感谢评论区的提醒，下方公式中有误，wj*pij改为wj*xij。
三、熵权法应用实例 3.1 背景介绍
某医院为了提高自身的护理水平，对拥有的11个科室进行了考核，考核标准包括9项整体护理，并对护理水平较好的科室进行奖励。下表是对各个科室指标考核后的评分结果。
但是由于各项护理的难易程度不同，因此需要对9项护理进行赋权，以便能够更加合理的对各个科室的护理水平进行评价。
3.2 数据预处理
根据原始评分表，对数据进行标准化后可以得到下列数据标准化表
所用公式：
11个科室9项整体护理评价指标得分表标准化表：
3.3 计算第j个指标在第i个方案中所占比重
3.4 求各指标的信息熵
3.5 计算各指标的权重
根据指标权重的计算公式：
这里k指的是指标个数，即k=m。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3596d4329b89ebeaf74720e0528d58fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cce80f314154a5c0e01b9cd8cdd93722/" rel="bookmark">
			go-zero 生成中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.API编写
2.生成API
生成后的目录如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/030a1a557ec93ccd633d04850d42691a/" rel="bookmark">
			Go 操作kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载和安装 go get github.com/IBM/sarama
2.连接 func main() { config := sarama.NewConfig() config.Producer.RequiredAcks = sarama.WaitForAll //发送完数据需要leader和follow都确认 config.Producer.Partitioner = sarama.NewRandomPartitioner config.Producer.Return.Successes = true // 成功交付的消息将在success channel返回 config.Producer.Retry.Max = 0 //重新发送的次数 config.Producer.Timeout = time.Microsecond * 10 //等待 WaitForAck的时间 config.Producer.Idempotent = true //开启幂等性 //config.Producer.Transaction = //构造一个消息 //连接kafka client, err := sarama.NewSyncProducer([]string{"192.168.0.4:9092"}, config) if err != nil { fmt.Println("producer closed,err:", err) return } defer client.Close() //发送消息 for i := 0; i &lt; 5; i++ { msg := &amp;sarama.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/030a1a557ec93ccd633d04850d42691a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e7f13ea18b7921a8848b8e19e9de55b/" rel="bookmark">
			TP4056的datasheet简要解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是TP4056 datasheet的主要参数和对应的解读：
1、输入电压范围：4.5V至5.5V
这是指TP4056芯片可以工作的最小和最大输入电压范围。在工作过程中，输入电压需要保持稳定，否则会影响充电效率和稳定性。
2、最大充电电流：1000mA
这是指TP4056最大的充电电流，即充电模式下电流的最大值。如果超过这个值，会导致芯片过热或损坏。根据电池的规格和实际情况，可以调整充电电流大小。
3、过充保护电压：4.2V
这是指TP4056芯片提供的过充保护电压值，当锂电池电压超过这个值时，芯片会自动停止充电。这是防止电池过充而导致的安全问题。
4、欠压锁定电压：2.4V
这是指TP4056芯片提供的欠压保护电压值，当锂电池电压低于这个值时，芯片会停止输出，保护电池免受过度放电的伤害。
5、充电指示：红色LED
这是指TP4056芯片的充电指示灯的颜色，一般是红色。充电开始时，指示灯亮起表示正在充电；当充电完成时，指示灯熄灭。
6、充电效率：约85%
这是指TP4056芯片的充电效率，即输入电压与电池实际充电电流之间的比率。充电效率越高，芯片发热越少，充电速度也越快。
7、工作温度范围：-20℃至85℃
这是指TP4056芯片工作的温度范围，超出此范围会影响芯片的性能和寿命。在实际应用过程中，需要根据环境温度和散热条件来选择芯片的工作电流和外部元件。
总之，对TP4056芯片的参数进行充分理解和应用，可以帮助设计出稳定、高效、安全的锂电池充电管理电路。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6251229108831f722af8e4c6e125899/" rel="bookmark">
			WPF学习：资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是资源 资源既是一种数据存储，通常程序将需要重复使用到的数据作为资源。WPF的资源系统既有传统桌面开发常用的二进制资源也有自己特色的对象级资源。
1、WPF对象级资源： 在WPF中的每个元素下都有一个Resource属性，Resource属性是Object类型的，所以可基本将任何类型赋值给Resource属性。并且每个资源由键值对组成，需要提供一个key。
2、二进制资源： 字符串资源可以在项目添加资源使用，他也是通过键值对进行存储字符串的，如下图所示：
首先要修改上图中的访问修饰符为public使其可被其他程序集调用，该资源主要用于程序国际化。
另外如图片，音乐等作为资源则可以直接创建一个文件夹通过添加现有项将其引入（实际上会将图片音乐拷贝到文件夹下）。另外需要设置该图片或者音乐为资源（右键属性中设置），则已将该文件设置为WPF二进制资源，在编译时自动编译为程序数据。
二、资源类型 1、动态资源： 当资源对象更新后，使用资源的对象也会更新。
2、静态资源： 资源只进行一次加载，后续不再改变。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/046f97fd96aaa382c6f6af6fff900d11/" rel="bookmark">
			深度学习如何入门？要学哪些东西？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 深度学习是一个强大的领域，可以帮助解决各种复杂的问题，但它也可以看起来非常复杂和令人畏惧。对于初学者来说，入门深度学习可能需要一些时间和耐心，但以下是一些步骤和建议，可以帮助你入门深度学习：
深度学习如何入门？
首先，建议建立一个坚实的数学和编程基础。深度学习涉及到许多数学概念，如线性代数、微积分和概率统计。如果你对这些概念不熟悉，可以通过在线课程、教科书和教程来学习。同时，熟练掌握编程语言，特别是Python，对于实施深度学习模型非常重要。
接下来，你可以开始学习深度学习的基本概念和原理。这包括了解人工神经网络（Artificial Neural Networks，ANN）的基本结构和工作原理，以及深度学习的历史和发展。你可以通过在线课程、教材和教学视频来了解这些内容。
一旦你掌握了基本概念，可以开始学习深度学习框架。TensorFlow、PyTorch和Keras是流行的深度学习框架，它们提供了一系列工具和资源，使你能够更容易地构建和训练神经网络模型。你可以找一些适合初学者的教程，从简单的示例开始，逐渐加深你的理解。
实际项目是学习深度学习的关键。尝试解决一些简单的问题，例如图像分类或文本分类，然后逐渐挑战更复杂的任务。这可以通过参加Kaggle竞赛、自己构建项目或参与开源项目来实现。实践中的问题和挑战将有助于巩固你的知识和技能。
此外，深度学习社区是一个非常有用的资源。加入在线社区、参加论坛、博客和社交媒体，与其他学习者和专家互动，分享经验和解决问题。社区的支持和分享可以帮助你更容易地入门深度学习。
最重要的是，要保持坚持不懈的态度。深度学习是一个需要持续学习和实践的领域。不要气馁，不要怕犯错，因为从错误中学到的东西同样重要。随着时间的推移，你将逐渐积累经验和自信，成为深度学习领域的专家。
深度学习是一个充满挑战但也充满机遇的领域。通过坚实的数学和编程基础、深度学习基本概念的学习、实际项目的实践以及积极参与社区，你可以逐渐入门深度学习，为未来的学习和应用奠定坚实的基础。
免费分享一些我整理的人工智能学习资料给大家，整理了很久，非常全面。包括一些人工智能基础入门视频+AI常用框架实战视频、计算机视觉、机器学习、图像识别、NLP、OpenCV、YOLO、pytorch、深度学习与神经网络等视频、课件源码、国内外知名精华资源、AI热门论文等。
下面是部分截图，点击文末名片关注我的公众号【AI技术星球】发送暗号 321 领取（一定要发 321） 学好人工智能，要多看书，多动手，多实践，要想提高自己的水平，一定要学会沉下心来慢慢的系统学习，最终才能有所收获。
点击下方名片，扫码关注公众号【AI技术星球】发送暗号 321 免费领取文中资料。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a811e7b1031de011f7882dc91edf0f46/" rel="bookmark">
			学深度学习可以做什么？可以从事什么工作？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 学习深度学习可以让您涉足人工智能领域的前沿，为各种领域带来巨大的创新和改进机会。深度学习的核心思想是通过多层神经网络模拟人类大脑的工作方式，从而实现对复杂数据的高级处理和理解。这为以下方面的应用提供了广泛的可能性：
学深度学习可以做什么？
首先，深度学习在计算机视觉领域中表现出色，能够实现图像识别、物体检测、人脸识别等任务。这可以应用于自动驾驶、医学图像分析、安防监控等领域，提高了生活质量和安全性。
其次，深度学习在自然语言处理中也有显著的影响，包括机器翻译、情感分析、文本生成等。这推动了跨语言交流、内容生成和智能助手等领域的发展。
此外，深度学习对于语音识别、自动化控制、金融预测和医学诊断等任务也具有广泛应用，有助于提高效率、准确性和创新能力。
深度学习为各个领域的问题提供了强大的工具，有望推动科学研究、技术创新和社会进步。学习深度学习可以使你参与这一领域的发展，应用其技能来解决实际问题并推动未来的发展。
免费分享一些我整理的人工智能学习资料给大家，整理了很久，非常全面。包括一些人工智能基础入门视频+AI常用框架实战视频、计算机视觉、机器学习、图像识别、NLP、OpenCV、YOLO、pytorch、深度学习与神经网络等视频、课件源码、国内外知名精华资源、AI热门论文等。
下面是部分截图，点击文末名片关注我的公众号【AI技术星球】发送暗号 321 领取（一定要发 321） 学好人工智能，要多看书，多动手，多实践，要想提高自己的水平，一定要学会沉下心来慢慢的系统学习，最终才能有所收获。
点击下方名片，扫码关注公众号【AI技术星球】发送暗号 321 免费领取文中资料。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/92/">«</a>
	<span class="pagination__item pagination__item--current">93/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/94/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>