<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bce32f6c6d9ce65abf65a299463f5c1e/" rel="bookmark">
			删除新建短信时候输入框中的重复收件人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.参考文章：http://www.cnblogs.com/vendor/p/6924964.html
2.我的修改 packages\apps\Mms\src\com\android\mms\ui\ComposeMessageActivity.java 8.0的代码和参考文章中有点不同，只需要在switch的default下添加就行，相当于2个以上的收件人时
private void updateTitle(ContactList list){ default: { //add Contact lastContact = list.get(list.size() - 1); String number = lastContact.getNumber(); for(int i = 0; i &lt; list.size() - 1; i++) { if(number.equals(list.get(i).getNumber())&amp;&amp; list.size()&lt;6){ //Repeat the contact list.remove(list.size() - 1); mRecipientsEditor.clearEditor();//这个方法一定要调用，参考的文章中没有 mRecipientsEditor.populate(list); //String title2 = getResourcesString(R.string.has_invalid_recipient, name); //Toast.makeText(ComposeMessageActivity.this, title2, Toast.LENGTH_SHORT).show(); return; } } //add } mRecipientsEditor.clearEditor();这个方法在RecipientsEditor.java方法中不存在，需要我们加上
public void clearEditor() { setText(null); } 这个方法一定要在 mRecipientsEditor.populate(list);前调用，否则会出现编辑框中不停增加收件人；因为populate只是在输入框中添加收件人相当于append，这样会造成输入框中不停的有重复的联系人，然后又不停的执行populate，造成死循环
3.重要的方法mRecipientsEditor.populate(list); 这个方法是往里面填充收件人的，简记一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c019f34f1bc5368112e7ee52bfc3acc5/" rel="bookmark">
			35岁，真的是程序员跨不过的坎吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天，我在一篇招聘的文章里，写了某个技术岗位的要求：
Web前端/H5高级工程师 1 名，年薪 18 ~ 24 万
要求：
35岁以下
计算机及其相关专业本科
5年以上前端开发经验
有跨屏开发能力
精通H5流媒体框架
熟悉各种浏览器内核
工作细致认真，责任心强
多位小伙伴留言，质疑招聘信息里的年龄要求，想知道对技术人来讲，年龄到底有多重要。
因此，我今天特意写一篇文章，聊聊我对程序员年龄的看法，从 5 方面展开：
为什么很多公司不欢迎大龄程序员
为什么程序员自己也介意年龄
年龄会给程序员带来的劣势和优势
开发者能在哪些方面打造优势
如何面对年龄这个现实问题
▼
1. 为什么公司不欢迎大龄程序员 大龄程序员不受欢迎，这是很多开发者的感受，因为实在是有太多公司在招募人员时会设置年龄门槛了。
比如 X 为，存在社招年龄必须小于 37 岁这个门槛，还传出过清退 34 岁员工的消息……
那么，公司为什么不欢迎大龄程序员呢？
其实，这个问题并不存在！
2015 年底，我接近 36 岁，创业失败后找工作，没花几天就找到了不错的机会。
这说明，公司不是不欢迎大龄程序员，而是不欢迎能力和年龄不匹配的大龄程序员！如果你能力对得起年龄，在某方面有深入积累，年龄根本不是问题。
我们再来站在公司角度，看看它们为什么担心程序员的年龄：
年龄大了，家庭课业繁重，需要平衡工作和家庭
年龄大了，可能会丧失积极主动学习的欲望
大龄开发者经济成本高
大龄开发者管理成本高
公司所做产品不需要多深的技术和业务积累，没必要用大龄开发者
▼
2. 为什么程序员自己也介意年龄 程序员本身介意年龄，是因为：
很多公司招人时要求年龄在多少多少岁以下，让人焦虑
年龄大了，真的会丧失学习与提升的欲望，让人焦虑
年龄大了，真的会有心无力，让人失望
年龄大了，真的会不敢接受从零开始的挑战，让人沮丧
你有这些感受吗？
反正我是有的。
还有其它的担忧吗？
欢迎在本文后留言讨论。
▼
3. 大龄程序员的优势vs劣势 关于劣势，其实我们说了很多，这里汇总一下：
生活状况多，上有老，下有小，中有伴侣，横有各种社会关系，需要在时间和精力上平衡工作与生活
学习欲望降低
进取欲望降低
能力提升变慢
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c019f34f1bc5368112e7ee52bfc3acc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a46f6d10d9312efa8f8e0b18a02fb52b/" rel="bookmark">
			解决 谷歌 浏览器 黄色 背景 的 css 样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决 谷歌 浏览器 黄色 背景 的 css 样式
input:-webkit-autofill , textarea:-webkit-autofill, select:-webkit-autofill { -webkit-text-fill-color: #ededed !important; -webkit-box-shadow: 0 0 0px 1000px transparent inset !important; background-color:transparent; background-image: none; transition: background-color 50000s ease-in-out 0s; } input { background-color:transparent; }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22d28d33d8ed8fcebf08aeff879772b2/" rel="bookmark">
			&amp;times变成x
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天晚上遇到一个很尴尬的bug。
当使用IE浏览器，跳转链接使用&amp;传参的时候第二个参数是times，也就是&amp;times(你有可能看到的是x，实际是&amp;times)，结果&amp;times(你有可能看到的是x，实际是&amp;times)变成了一个x，于是就变成了***.html?a=1x=的样子。
特此记录以备后用。
转载于:https://www.cnblogs.com/Lenbrother/p/8425481.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fcafb182ed18ef64668d80080189da5/" rel="bookmark">
			异常 Exception
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、异常定义： 导致程序的正常流程被中断的事件，叫做异常
FileNotFoundException 文件不存在异常
OutOfIndexException 数组下标越界异常
OutOfMemoryError 内存不足 ClassCastException 类型转换异常 ArithmaticException 除数为零 NullPointerException 空指针异常
二、异常处理常见手段： try catch finally throws
1. try catch
package exception; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; public class TestException { public static void main(String[] args) { File f= new File("d:/LOL.exe"); try{ System.out.println("试图打开 d:/LOL.exe"); new FileInputStream(f); System.out.println("成功打开"); } catch(FileNotFoundException e){ System.out.println("d:/LOL.exe不存在"); e.printStackTrace(); } } } 2.使用异常的父类进行catch FileNotFoundException是Exception的子类，使用Exception也可以catch住FileNotFoundException
package exception; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; public class TestException { public static void main(String[] args) { File f= new File("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fcafb182ed18ef64668d80080189da5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e900ea599315f49d7a8b88586d62fd82/" rel="bookmark">
			基于Memcached分布式系统DRDoS拒绝服务攻击技术研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础概念 友情提醒：以下仅做技术研究，如有恶意利用，发起攻击，将自负法律后果
本次反射式拒绝服务攻击技术基于全球互联网分布式的Memcached服务器，需要储备一定得安全攻防知识，网络协议知识和python代码编程技术。希望在学习本篇文章知识前自行学习相关的基础知识，文章后面同时附有参考链接。 关于Memcached系统 Memcached是一个自由开源的，高性能，分布式内存对象缓存系统。Memcached是以LiveJournal旗下Danga Interactive公司的Brad Fitzpatric为首开发的一款软件。现在已成为mixi、hatena、Facebook、Vox、LiveJournal等众多服务中提高Web应用扩展性的重要因素。Memcached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API调用或者是页面渲染的结果。Memcached简洁而强大。它的简洁设计便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题。它的API兼容大部分流行的开发语言。本质上，它是一个简洁的key-value存储系统。一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。
关于分布式DDoS原理 分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。通常，攻击者使用一个偷窃帐号将DDoS主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户/服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行。
关于反射式DRDoS原理 DRDoS是英文“Distributed Reflection Denial of Service ”的缩写，中文意思是“分布式反射拒绝服务”。与DoS、DDoS不同，该方式靠的是发送大量带有被害者IP地址的数据包给攻击主机，然后攻击主机对IP地址源做出大量回应，形成拒绝服务攻击。
攻击流程
DDoS攻击流程 要完成这个攻击流程，得至少需要三个步骤。
1 攻击者手里必须控制大量肉鸡机器，并且分布式在互联互通分布在互联上。
2 攻击者随时可以通过代理或者控制程序同时向所有肉鸡发送大量攻击指令。
3 所有肉鸡在接受指令后，同时大量并发，同时向受害者网络或者主机发起攻击行为。
DRDoS攻击流程 DRDoS要完成一次反射放大攻击：
1 攻击者，必须提前需要把攻击数据存放在所有的在线肉鸡或者反射服务器之上。
2 攻击者，必须伪造IP源头。发送海量伪造IP来源的请求。当然这里的IP就是受害者的IP地址。
3 反射服务器，必须可以反射数据，运行良好稳定。最好是请求数据少，返回数据成万倍增加。
如此不断循环，就可以大规模攻击其带宽网络，增加占用率和耗损目标机的硬件资源。
利用Memcached实现的DRDos攻击反射流程
存活机器
首先我们要找到大量反射服务器，利用搜索引擎去发掘全球可利用在线服务器。这里我暂时用zoomeye进行搜集，你也可以用别的搜索引擎，比如shodan等。默认开启端口号是11211,利用知道创宇得钟馗之眼空间引擎搜索到全球538317台机器开启11211端口，运行着Memcached缓存服务系统。但是利用条件还有一个，就是我们还得进一步帅选确认是否开启默认可以登录的机器，这样就可以被我们所利用了。有些已经设置了安全认证，那么就无法使用了。(不做公布）
通信协议 从协议看，memcache同时监听tcp和udp。也就是说它本身支持两种协议同时可以发起交互和通信。这个就很关键了。大家可以看看tcp和udp协议区别。由于TCP是字节流，没有包的边界，无所谓大小，一次发送接受的数据取决于实现以及你的发送接收缓存大小。
TCP没有限定，TCP包头中就没有“包长度”字段，而完全依靠IP层去处理分帧。
但是UDP协议就不一样了，他不基于连接，直接发送数据报到目标机器。
注意这个Length字段，只占有两个字节。所以说UDP协议发送数据就有了限制，单次最大发送2^16=65535=64KB。
如果想要发送更大数据包，那么只能使用TCP协议或者UDP多次发送来实现，这里我已经测试过，两种协议均可以实现。
小结：
1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交 付，即不保证可靠交付。
3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的。UDP没有拥塞控制，因此网络出 现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。
4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。
5、TCP首部开销20字节;UDP的首部开销小，只有8个字节。
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。
好了，明白了这个，我们就看看怎么利用基于TCP和UDP协议通信的Memcached缓存系统。由于Memcached系统支持最大键值单数据对1M存储。所以我们最大只能存储1M，当然你可以作多个字段，这样也会放大。那首先按照流程图我们向远程服务器提前存储有效载荷，这里就是数据了。利用TCP协议可以一次性发1M，但是我们要是利用UDP就得循环发送多次才能完成1M数据传输。由于UDP具有不稳定性，数据包不保证可靠交付。这里我建议使用TCP进行发送。
数据格式 Memcached简洁而强大。它的简洁设计便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题。它的API兼容大部分流行的开发语言。本质上，它是一个简洁的key-value存储系统。
一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。
支持有如下所有命令和操作。
Memcached 存储命令 Memcached set 命令 Memcached add 命令 Memcached replace 命令 Memcached append 命令 Memcached prepend 命令 Memcached CAS 命令 Memcached 查找命令 Memcached get 命令 Memcached gets 命令 Memcached delete 命令 Memcached incr/decr 命令 Memcached 统计命令 Memcached stats 命令 Memcached stats items 命令 Memcached stats slabs 命令 Memcached stats sizes 命令 Memcached flush_all 命令 这里我们重点介绍三种命令，因为我们的攻击流程中将会涉及了这三种方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e900ea599315f49d7a8b88586d62fd82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/803432dca2fe6c78a658ad33ba98ddbb/" rel="bookmark">
			[Java]去掉数组中重复的元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提供两种思路解决去掉重复的数字:
1)添加一个数组,但是长度无法确定,记录没有重复的值
2)添加一个数组,用于记录原数组中存在的主,再添加一个数组,可以确定数组的长度,用于存放原数组的值.
public class TextDelRepeat { /** * 去掉数组中重复的数字 * @param src * @return */ public static int[] changeMethodOne(int src[]) { int length = src.length; int[] taget = new int[length]; int index = 0; taget[0] = src[0]; for(int i = 1; i &lt; length; i++) { if(taget[index] != src[i]) { index ++; taget[index] = src[i]; } } return taget; } /** * 去掉数组中重复的数字 * @param src * @return */ public static int[] changeMethodTwo(int src[]) { int length = src.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/803432dca2fe6c78a658ad33ba98ddbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8902a83931d949c2668bd843d418c0f0/" rel="bookmark">
			linux系统中打rz命令后出现waiting to receive.**B0100000023be50
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到教程。
linux系统中打rz命令后出现 waiting to receive.**B0100000023be50 而没有出现选择文件弹出框是什么问题：
我本来用的是 git-bash 不行，后来用 Xshell 就可以了。
rz 与 sz 需要端支持。终端就是连接远程服务器的客户端，例如 XShell、SecureCRT 等，linux默认终端是不支持的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3495709189befdf159fa6fe1e164d0a7/" rel="bookmark">
			Nginx 显示中文乱码解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文乱码，心里瞬间一万条草泥马奔腾。在网上查了一下资料，发现需要修改nginx的server的配置内容，增加一行：charset utf-8;
详情如下：
upstream you.domainName.com {
server 127.0.0.1:8081;
}
server {
listen 80;
server_name you.domainName.com;
charset utf-8;
location /examples {
return 403;
}
然后，重启Nginx服务。最后，在浏览器上Ctrl+F5，刷新，一切正常！如下图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dbbeb8fd0f7e06baba4a39ed6768c97/" rel="bookmark">
			通信基站和通信技术机房
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SELECT nowtime.EC_CITY_NAME as EC_CITY_NAME, nowtime.EC_ITEM_TIME as EC_ITEM_TIME, nowtime.EC_ARENA_NAME as EC_ARENA_NAME, nowtime.TOTAL_USAGE as NOW_TOTAL_USAGE, lastmonth.TOTAL_USAGE as YEAR_TOTAL_USAGE, CASE WHEN nowtime.TOTAL_USAGE is null THEN 0 WHEN nowtime.TOTAL_USAGE = 0 THEN 0 ELSE CASE WHEN lastmonth.TOTAL_USAGE is null THEN 0 WHEN lastmonth.TOTAL_USAGE = 0 THEN 0 ELSE round(nowtime.TOTAL_USAGE/lastmonth.TOTAL_USAGE,4) END END as TOTALUSAGECOMPARELASTMONTH, nowtime.AIRCON_USAGE as NOW_AIRCON_USAGE, lastmonth.AIRCON_USAGE as YEAR_AIRCON_USAGE, CASE WHEN nowtime.AIRCON_USAGE is null THEN 0 WHEN nowtime.AIRCON_USAGE = 0 THEN 0 ELSE CASE WHEN lastmonth.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dbbeb8fd0f7e06baba4a39ed6768c97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3af98b0862b4c8292f47985b10b9e671/" rel="bookmark">
			ES6 find 和 filter 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到个功能是要分类就想说在前端过滤，不要从查数据库的时候过滤了。然后就想说除了filter还有啥好用的
发现有个find，测试一番之后发现
const list = [{'name':'1',index:1},{'name':'2'},{'name':'1'}]
let list2 = list.find(i=&gt;i.name==='1') let list3 = list.filter(i=&gt;i.name==='1')
console.log(list); [ { name: '1', index: 1 }, { name: '2' }, { name: '1' } ]
console.log(list2); { name: '1', index: 1 }
console.log(list3);[ { name: '1', index: 1 }, { name: '1' } ]
find 和 filter 都是不改变原数组的方法
但是find只查出第一个符合条件的结果像例子里是直接返回了一个对象而不是数组！
，而filter返回全部结果仍然是数组。
注：以后遇到问题，不忙的时候立马就记下来，方便以后查找，不论简单还是难。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e026953cbb54c9944b28d21e8ae070/" rel="bookmark">
			zabbix agent改造方案之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55661dcb5ef8cd0339d1e71f78f19537/" rel="bookmark">
			【AD小知识】各个布线层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本内容了解
一共是13层。…
top layer - 顶层 bottom layer - 底层 mechanical,机械层 keepout layer禁止布线层 top overlay顶层丝印层 bottom overlay底层丝印层 top paste顶层**助焊层** bottom paste底层**助焊层** top solder顶层**阻焊层** bottom solder底层**阻焊层** drill guide 过孔引导层 drill drawing 过孔钻孔层 multilayer 多层 ①顶层和底层:top-layer 和 bottom layer
这个不用多说了，就是我们画板子的正反面呗。。。
②机械层和禁止布线层(mechanical 和 keep-out layer)
这两个关乎板子的外形，也可参考这篇博客。。
机械层是定义整个PCB板的外观的，其实我们在说机械层的时候就是指整个PCB板的外形结构。
禁止布线层是定义我们在布电气特性的铜时的边界，也就是说我们先定义了禁止布线层后，我们在以后的布过程中，所布的具有电气特性的线是不可能超出禁止布线层的边界。
注意： 可能从上面你会越看越晕，那么板子外形到底该看哪个层？
实际上现在，大多数的生产厂家默认都是 keep-out layer 层，所以只需要画这层就行了。
③ 顶层和底层丝印 top overlay和bottom overlay
topoverlay和bottomoverlay是定义顶层和底的丝印字符，就是一般我们在PCB板上看到的元件编号和一些字符。
④顶层底层助焊层 top paste和bottom paste
助焊层：paste mask，是机器贴片时要用的，是对应所有贴片元件的焊盘的，大小与 top layer/bottom layer层一样，是用来开钢网漏锡用的。
⑤ 顶层底层阻焊层 top solder和bottomsolder
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55661dcb5ef8cd0339d1e71f78f19537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93e45081c632772ddc5befadf1de0937/" rel="bookmark">
			Linux 中 /var/spool/postfix/maildrop 占用空间很大问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 一台运维主机上面没有跑什么特殊服务，所以没有添加监控告警。今突然执行命令执行不了发现是因为磁盘慢了导致。排错发现是因为目录/var/spool/postfix/mailfdrop 过大导致。
通过了解发现因为：
由于 Linux 在执行 cron 时，会将 cron 执行脚本中的 output 和 warning 信息，都会以邮件 的形式发送 cron 所有者， 而由于客户环境中的 sendmail 和 postfix 没有正常运行，导致邮件 发送不成功，全部小文件堆积在了 maildrop 目录下面，而且没有自动清理转换的机制，所以长达一 年的时间，此目录已堆积了大量的文件。查看 man cron 的信息，可以知道会发送给 cron owner. 解决之道 临时解决当然是清空该文件夹即可
cd /var/spool/postfix/maildrop rm -rf * 但是临时删除了，以后也还会出现。所以我们需要从源头杜绝这个问题再次出现。 通过上面的介绍我们知道是因为crontab执行定时任务的时候把脚本的一些输出发送给脚本执行者。如果是我们不关心的备注型等输出我们完全可以让其输出到 /dev/null 这样就不会因为发送失败到导致在/var/spool/postfix/maildrop下面产出什么文件。
建议： */10 * * * * /tmp/test.sh &gt;/dev/null 2&gt;&amp;1 修改之后观察该目录发现没有新的文件产生。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4637c0158830b2dd6b4011ae3ae74cf/" rel="bookmark">
			数据钻取与大屏可视化-东软SaCa DataViz
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：项目中一直准备做这块，后面检索到：阿里dataV，海致BDP，东软DataViz，超图DataInsight。
SaCa DataViz V5.0 震撼预览
主要功能：关联数据源、数据钻取与分析、图册与可视化
官网网站：http://www.sacadataviz.com
产品论坛：https://forum.platform.neusoft.com/c/saca-chan-pin/dataviz
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f809f11a07d9f98b29f08d16d9413e8e/" rel="bookmark">
			tomcat修改JDK版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 windows系统里，tomcat默认是使用系统变量JAVA_HOME的jdk版本，如果需要更换，可以在配置文件手动指定。
在bin\catalina.bat和bin\setclasspath.bat文件，记事本打开编辑，开头的空白处加上：
set JAVA_HOME=D:\jdk\jdk1.8.0_31 set JRE_HOME=D:\jdk\jdk1.8.0_31\jre 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84da9598081abb2a98f4cd27e92a7e07/" rel="bookmark">
			metabase二次开发需要修改的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		metabase/frontend/src/metabase/admin/databases/components/CreatedDatabaseModal.jsx metabase/frontend/src/metabase/admin/databases/components/DatabaseEditForms.jsx metabase/frontend/src/metabase/admin/databases/components/DatabaseSchedulingForm.jsx metabase/frontend/src/metabase/admin/databases/components/DeleteDatabaseModal.jsx metabase/frontend/src/metabase/admin/databases/containers/DatabaseEditApp.jsx metabase/frontend/src/metabase/admin/databases/containers/DatabaseListApp.jsx metabase/frontend/src/metabase/admin/databases/database.js metabase/frontend/src/metabase/admin/datamodel/components/ObjectActionSelect.jsx metabase/frontend/src/metabase/admin/datamodel/components/ObjectRetireModal.jsx metabase/frontend/src/metabase/admin/datamodel/components/database/ColumnItem.jsx metabase/frontend/src/metabase/admin/datamodel/components/database/ColumnsList.jsx metabase/frontend/src/metabase/admin/datamodel/components/database/MetadataHeader.jsx metabase/frontend/src/metabase/admin/datamodel/components/database/MetadataSchema.jsx metabase/frontend/src/metabase/admin/datamodel/components/database/MetadataSchemaList.jsx metabase/frontend/src/metabase/admin/datamodel/components/database/MetadataTable.jsx metabase/frontend/src/metabase/admin/datamodel/components/database/MetadataTableList.jsx metabase/frontend/src/metabase/admin/datamodel/components/database/MetricsList.jsx metabase/frontend/src/metabase/admin/datamodel/components/database/SegmentsList.jsx metabase/frontend/src/metabase/admin/datamodel/components/revisions/Revision.jsx metabase/frontend/src/metabase/admin/datamodel/components/revisions/RevisionHistory.jsx metabase/frontend/src/metabase/admin/datamodel/containers/FieldApp.jsx metabase/frontend/src/metabase/admin/datamodel/containers/MetadataEditorApp.jsx metabase/frontend/src/metabase/admin/datamodel/containers/MetricForm.jsx metabase/frontend/src/metabase/admin/datamodel/containers/SegmentForm.jsx metabase/frontend/src/metabase/admin/datamodel/containers/TableSettingsApp.jsx metabase/frontend/src/metabase/admin/people/components/AddRow.jsx metabase/frontend/src/metabase/admin/people/components/EditUserForm.jsx metabase/frontend/src/metabase/admin/people/components/GroupDetail.jsx metabase/frontend/src/metabase/admin/people/components/GroupSummary.jsx metabase/frontend/src/metabase/admin/people/components/GroupsListing.jsx metabase/frontend/src/metabase/admin/people/components/UserActionsSelect.jsx metabase/frontend/src/metabase/admin/people/containers/AdminPeopleApp.jsx metabase/frontend/src/metabase/admin/people/containers/PeopleListingApp.jsx metabase/frontend/src/metabase/admin/permissions/components/PermissionsConfirm.jsx metabase/frontend/src/metabase/admin/permissions/components/PermissionsEditor.jsx metabase/frontend/src/metabase/admin/permissions/containers/PermissionsApp.jsx metabase/frontend/src/metabase/admin/permissions/selectors.js metabase/frontend/src/metabase/admin/settings/components/SettingsAuthenticationOptions.jsx metabase/frontend/src/metabase/admin/settings/components/SettingsEmailForm.jsx metabase/frontend/src/metabase/admin/settings/components/SettingsLdapForm.jsx metabase/frontend/src/metabase/admin/settings/components/SettingsSetting.jsx metabase/frontend/src/metabase/admin/settings/components/SettingsSetupList.jsx metabase/frontend/src/metabase/admin/settings/components/SettingsSingleSignOnForm.jsx metabase/frontend/src/metabase/admin/settings/components/SettingsSlackForm.jsx metabase/frontend/src/metabase/admin/settings/components/SettingsUpdatesForm.jsx metabase/frontend/src/metabase/admin/settings/components/widgets/CustomGeoJSONWidget.jsx metabase/frontend/src/metabase/admin/settings/components/widgets/EmbeddingLegalese.jsx metabase/frontend/src/metabase/admin/settings/components/widgets/LdapGroupMappingsWidget.jsx metabase/frontend/src/metabase/admin/settings/components/widgets/PublicLinksListing.jsx metabase/frontend/src/metabase/admin/settings/components/widgets/SecretKeyWidget.jsx metabase/frontend/src/metabase/admin/settings/containers/SettingsEditorApp.jsx metabase/frontend/src/metabase/admin/settings/selectors.js metabase/frontend/src/metabase/auth/components/BackToLogin.jsx metabase/frontend/src/metabase/auth/components/GoogleNoAccount.jsx metabase/frontend/src/metabase/auth/containers/ForgotPasswordApp.jsx metabase/frontend/src/metabase/auth/containers/LoginApp.jsx metabase/frontend/src/metabase/auth/containers/PasswordResetApp.jsx metabase/frontend/src/metabase/components/ActionButton.jsx metabase/frontend/src/metabase/components/AddButton.jsx metabase/frontend/src/metabase/components/AdminPaneLayout.jsx metabase/frontend/src/metabase/components/Archived.jsx metabase/frontend/src/metabase/components/ButtonWithStatus.jsx metabase/frontend/src/metabase/components/Calendar.jsx metabase/frontend/src/metabase/components/CheckBox.jsx metabase/frontend/src/metabase/components/ConfirmContent.jsx metabase/frontend/src/metabase/components/CreateDashboardModal.jsx metabase/frontend/src/metabase/components/DatabaseDetailsForm.jsx metabase/frontend/src/metabase/components/DeleteModalWithConfirm.jsx metabase/frontend/src/metabase/components/DeleteQuestionModal.jsx metabase/frontend/src/metabase/components/HeaderModal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84da9598081abb2a98f4cd27e92a7e07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2aa00cfda7457727e76ca46d3e7d70/" rel="bookmark">
			Android 6.0 运行时权限管理最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from: http://blog.csdn.net/yanzhenjie1003/article/details/52503533
这是一篇迟来的博客，Android M已经发布一年多了（6.0的变化），在Android M中权限系统被重新设计，发生了颠覆性的变化，很多人把握不好这个变化，一是对这个权限策略和套路还没有摸透，二是没有一个很好的实践来支撑，在我的技术开发群里很多人问我关于权限的问题，往往我都没有直接回答，因为这个问题不是一两句说的清楚的，这几点是今天我写这篇博客的原因。这里有一切关于Android运行时权限你需要知道的，包括如何在代码中实现，如果你以前不知道这些东西，现在来看也为时不晚，我将在详解之后给你一个最佳的实践方案。
由于项目一直在更新，更多新内容请直接看AndPermission开源主页： https://github.com/yanzhenjie/AndPermission
AndPermission能解决大部分国产机遇到的权限问题，请参考：国产手机权限适配方案
AndPermission特性 链式调用，一句话申请权限，为你省去复杂的逻辑判断。支持注解回调结果、支持Listener回调结果。拒绝一次某权限后，再次申请该权限时可使用Rationale向用户说明申请该权限的目的，在用户同意后再继续申请，避免用户勾选不再提示而导致不能再次申请该权限。就算用户拒绝权限并勾选不再提示，可使用SettingDialog提示用户去设置中授权。RationaleDialog和SettingDialog允许开发者自定义。AndPermission自带默认对话框除可自定义外，也支持国际化。支持在任何地方申请权限，不仅限于Activity和Fragment等。 如果你的英文够好，推荐你阅读官网的文章：
System PermissionsRequesting Permissions at Run TimePermissions Best Practices 关于运行时权限 在旧的权限管理系统中，权限仅仅在App安装时询问用户一次，用户同意了这些权限App才能被安装（某些深度定制系统另说），App一旦安装后就可以偷偷的做一些不为人知的事情了。
在Android6.0开始，App可以直接安装，App在运行时一个一个询问用户授予权限，系统会弹出一个对话框让用户选择是否授权某个权限给App（这个Dialog不能由开发者定制），当App需要用户授予不恰当的权限的时候，用户可以拒绝，用户也可以在设置页面对每个App的权限进行管理。
特别注意：这个对话框不是开发者调用某个权限的功能时由系统自动弹出，而是需要开发者手动调用，如果你直接调用而没有去申请权限的话，将会导致App崩溃。
也许你已经开始慌了，这对于用户来说是好事，但是对于开发者来说我们不能直接调用方法了，我们不得不在每一个需要权限的地方检查并请求用户授权，所以就引出了以下两个问题。
哪些权限需要动态申请 新的权限策略讲权限分为两类，第一类是不涉及用户隐私的，只需要在Manifest中声明即可，比如网络、蓝牙、NFC等；第二类是涉及到用户隐私信息的，需要用户授权后才可使用，比如SD卡读写、联系人、短信读写等。
不需要运行时申请的权限 此类权限都是正常保护的权限，只需要在AndroidManifest.xml中简单声明这些权限即可，安装即授权，不需要每次使用时都检查权限，而且用户不能取消以上授权，除非用户卸载App。
ACCESS_LOCATION_EXTRA_COMMANDSACCESS_NETWORK_STATEACCESS_NOTIFICATION_POLICYACCESS_WIFI_STATEBLUETOOTHBLUETOOTH_ADMINBROADCAST_STICKYCHANGE_NETWORK_STATECHANGE_WIFI_MULTICAST_STATECHANGE_WIFI_STATEDISABLE_KEYGUARDEXPAND_STATUS_BARGET_PACKAGE_SIZEINSTALL_SHORTCUTINTERNETKILL_BACKGROUND_PROCESSESMODIFY_AUDIO_SETTINGSNFCREAD_SYNC_SETTINGSREAD_SYNC_STATSRECEIVE_BOOT_COMPLETEDREORDER_TASKSREQUEST_IGNORE_BATTERY_OPTIMIZATIONSREQUEST_INSTALL_PACKAGESSET_ALARMSET_TIME_ZONESET_WALLPAPERSET_WALLPAPER_HINTSTRANSMIT_IRUNINSTALL_SHORTCUTUSE_FINGERPRINTVIBRATEWAKE_LOCKWRITE_SYNC_SETTINGS 需要运行时申请的权限 所有危险的Android系统权限属于权限组，如果APP运行在Android 6.0 (API level 23)或者更高级别的设备中，而且targetSdkVersion&gt;=23时，系统将会自动采用动态权限管理策略，如果你在涉及到特殊权限操作时没有申请权限权限而直接调用了相关代码，你的App可能就崩溃了，综上所述你需要注意：
此类权限也必须在Manifest中申明，否则申请时不提示用户，直接回调开发者权限被拒绝。同一个权限组的任何一个权限被授权了，这个权限组的其他权限也自动被授权。例如一旦WRITE_CONTACTS被授权了，App也有READ_CONTACTS和GET_ACCOUNTS了。申请某一个权限的时候系统弹出的Dialog是对整个权限组的说明，而不是单个权限。例如我申请READ_EXTERNAL_STORAGE，系统会提示"允许xxx访问设备上的照片、媒体内容和文件吗？"。 如果App运行在Android 5.1 (API level 22)或者更低级别的设备中，或者targetSdkVersion&lt;=22时（此时设备可以是Android 6.0 (API level 23)或者更高），在所有系统中仍将采用旧的权限管理策略，系统会要求用户在安装的时候授予权限。其次，系统就告诉用户App需要什么权限组，而不是个别的某个权限。
CALENDAR（日历） READ_CALENDARWRITE_CALENDAR CAMERA（相机） CAMERA CONTACTS（联系人） READ_CONTACTSWRITE_CONTACTSGET_ACCOUNTS LOCATION（位置） ACCESS_FINE_LOCATIONACCESS_COARSE_LOCATION MICROPHONE（麦克风） RECORD_AUDIO PHONE（手机） READ_PHONE_STATECALL_PHONEREAD_CALL_LOGWRITE_CALL_LOGADD_VOICEMAILUSE_SIPPROCESS_OUTGOING_CALLS SENSORS（传感器） BODY_SENSORS SMS（短信） SEND_SMSRECEIVE_SMSREAD_SMSRECEIVE_WAP_PUSHRECEIVE_MMS STORAGE（存储卡） READ_EXTERNAL_STORAGEWRITE_EXTERNAL_STORAGE 使用adb命令可以查看这些需要授权的权限组：
adb shell pm list permissions -d -g 1 使用adb命令同样可以授权/撤销某个权限：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f2aa00cfda7457727e76ca46d3e7d70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b3cc28c0d25520b370143b0d85c021e/" rel="bookmark">
			Keil的几个插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从C#开发再转回到Keil单片机开发显然是不适应的, 首先就是开发环境相对VS来说太弱智, 注释没有办法自己添加时间等等让我很无语, 自己写了几个插件, 看图, 在Tools菜单下, 选择Customize Tools Menu即可进行编辑添加.
下面将几个设置都截图备份一下
鉴于Keil的弱智性, 用这些插件会造成一个问题, 那就是调用插件后你就没法进行撤销操作了, 因为是外部程序修改文件造成了文件重载, 还有再调用这些插件时最好要提前保存下文件, 否则Keil可能不会刷新重载, 这就给你的感觉是插件失效, 但你重新打开这个文件会发现文件已经修改了的, 话不多说, 看下插件文件吧:
File.c是C文件的文件注释模板,你可以根据自己的习惯创建, File.h对那个的是头文件注释模板, 下面说下文件注释里面的关键字:
{FileName}遇到该关键字会被替换为文件名, 大小写敏感, 必须添加大括号;
{Date}当前日期, 2018-01-30这样的格式;
{Year}当前年, 如2018这样的
{ifndef}这个用在头文件中, 这个关键字程序会根据头文件的文件名生成如下格式代码:
#ifndef __XX_XX_H_
#define __XX_XX_H_
#endif
function.c对应的是函数模板, 如果你将光标放在函数的上面空行处, 函数注释插件会自动搜索函数名及参数列表, 里面关键字:
{FunctionName} 光标下面函数的函数名;
{Parameters} 参数列表, 没有填入None;
{Date} 当前日期;
就这些吧, 时间插件会根据传入参数在光标处输出日期或者时间字符串;
最后献上插件下载地址:http://download.csdn.net/download/xinxinsky/10231382 PS:有网友说我没把文件给打包进去，我把我的模板发一下吧：
File.c
/********************************Copyright (c)**********************************\ ** ** (c) Copyright {Year}, Main, China, QD. ** All Rights Reserved ** ** By(青岛世新科技有限公司) ** http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b3cc28c0d25520b370143b0d85c021e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/785a19866d64efce872b138c22b31d53/" rel="bookmark">
			CP-ABE Toolkit使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CP-ABE Toolkit使用方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/312586229ae66665fc9c02a4ae4a2503/" rel="bookmark">
			Java中连接字符串时使用&#43;号与使用StringBuilder的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串是Java程序中最常用的一种数据结构之一。在Java中的String类已经重载的”+”。也就是说，字符串可以直接使用”+”进行连接，如下面代码所示：
String s = "abc" + "ddd"; 但这样做真的好吗？当然，这个问题不能简单地回答yes orno。要根据具体情况来定。 在Java中提供了一个StringBuilder类（这个类只在J2SE5及以上版本提供，以前的版本使用StringBuffer类），这个类也可以起到”+”的作用。那么我们应该用哪个呢？ 下面让我们先看看如下的代码：
package string; public class TestSimplePlus { public static void main(String[] args) { String s = "abc"; String ss = "ok" + s + "xyz" + 5; System.out.println(ss); } } 上面的代码将会输出正确的结果。从表面上看，对字符串和整型使用”+”号并没有什么区别，但事实真的如此吗？下面让我们来看看这段代码的本质。 我们首先使用反编译工具（如jdk带的javap、或jad）将TestSimplePlus反编译成Java Byte Code，其中的奥秘就一目了然了。在本文将使用jad来反编译，命令如下：
jad -o -a -s d.java TestSimplePlus.class 反编译后的代码如下：
package string; import java.io.PrintStream; public class TestSimplePlus { public TestSimplePlus() { // 0 0:aload_0 // 1 1:invokespecial #8 &lt;Method void Object()&gt; // 2 4:return } public static void main(String args[]) { String s = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/312586229ae66665fc9c02a4ae4a2503/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a3bc2bcf23ef45f2d5370a15acd25b9/" rel="bookmark">
			过滤器Filter的写法及注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在登陆模块的开发过程中，肯定要写过滤器这一功能，保证安全，其原理就是：当session中的用户丢失了就拦截相关操作，只有当session中的用户存在的时候，才可以顺利请求服务器进行相关操作。
过滤器的写法分为两步：
第一步：创建过滤器这个类，声明过滤条件，该类必须实现Filter，implement Filter（导包的时候不要导错了，是servlet中的），代码写法如下：
第二步：在web.xml中配置过滤器，统一写法
&lt;filter&gt;
&lt;display-name&gt;LoginFilter&lt;/display-name&gt;
&lt;filter-name&gt;LoginFilter&lt;filter-name&gt;
&lt;filter-class&gt;com.baidu.goods.user.web.filter.LoginFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
&lt;filter-name&gt;LoginFilter&lt;/filter-name&gt;
&lt;url-pattern&gt;/jsps/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
实例如下：
这样，当session中的用户丢失的时候就会过滤掉url-pattern中的所有请求，要求用户必须登录。
除了在web.xml中配置过滤器，还可以用注解的方式，如下图：
urlPatterns中填写需要过滤的路径，servletNames中填写需要过滤的servlet，过滤的路径中可以不填写servlet的路径，在servletNames中填写servlet就可以了，但是，这里隐含着一个很大的问题，servletNames中声明过滤的servlet必须在web.xml中配置过，否则无效，也就是servletNames中的servlet对注解方式的servlet无效。所以综上所述：为保证安全，当开发人员使用注解的方式配置过滤器时，urlPatterns中最好是写完整所有要过滤的路径，包含jsp页面，servlet控制层，而所有的servlet都应该优先采用配置web.xml的方式，而不是注解的方式，注解只对运行时的请求有效，filter会优先寻找web.xml中的servlet。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f96b31a00c9797de5d5c95c41dea49/" rel="bookmark">
			单独获取字典中的键和值、并进行字典排序——Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先遍历字典所有的键-值对可以使用items() dict_name={k:v for k,v in zip(range(1,len(names)+1),names) } print(dict_name) for i,j in dict_name.items(): print(str(i) + ':' + j) 2、只遍历键时可以使用keys()，还可以使用sorted()进行排序 names = ['bob', 'tom', 'alice', 'jerry', 'wendy', 'smith','we','jerry'] dict_name={k:v for k,v in zip(range(1,len(names)+1),names) } for i in dict_name.keys(): print(i) #对 key 按照排序之后的结果输出 for j in sorted(dict_name.keys(),reverse=True): print(j) 3、只遍历值时，可以使用values()，还可以使用set(）去除值中重复的值 names = ['bob', 'tom', 'alice', 'jerry', 'wendy', 'smith','we','jerry'] dict_name={k:v for k,v in zip(range(1,len(names)+1),names) } for i in dict_name.values(): print(i) #对value 进行输出，去除重复的值 for j in set(dict_name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32f96b31a00c9797de5d5c95c41dea49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ec9eab1f9e591c8ad2f3fbcac2342f0/" rel="bookmark">
			python opencv-批量调整图片的曝光率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#--coding:utf-8-- import cv2 import numpy as np import os def gamma_trans(img,gamma):#gamma函数处理 gamma_table=[np.power(x/255.0,gamma)*255.0 for x in range(256)]#建立映射表 gamma_table=np.round(np.array(gamma_table)).astype(np.uint8)#颜色值为整数 return cv2.LUT(img,gamma_table)#图片颜色查表。另外可以根据光强（颜色）均匀化原则设计自适应算法。 def nothing(x): pass cv2.namedWindow("demo",0)#将显示窗口的大小适应于显示器的分辨率 cv2.createTrackbar('Value of Gamma','demo',100,1000,nothing)#使用滑动条动态调节参数gamma data_base_dir="C:\\Users\\HUANG\\Desktop\\pict"#输入文件夹的路径 outfile_dir="C:\\Users\\HUANG\\Desktop\\pictout"#输出文件夹的路径 processed_number=0#统计处理图片的数量 print "press enter to make sure your operation and process the next picture" for file in os.listdir(data_base_dir):#遍历目标文件夹图片 read_img_name=data_base_dir+'//'+file.strip()#取图片完整路径 image=cv2.imread(read_img_name)#读入图片 while(1): value_of_gamma=cv2.getTrackbarPos('Value of Gamma','demo')#gamma取值 value_of_gamma=value_of_gamma*0.01#压缩gamma范围，以进行精细调整 image_gamma_correct=gamma_trans(image,value_of_gamma)#2.5为gamma函数的指数值，大于1曝光度下降，大于0小于1曝光度增强 cv2.imshow("demo",image_gamma_correct) k=cv2.waitKey(1) if k==13:#按回车键确认处理、保存图片到输出文件夹和读取下一张图片 processed_number+=1 out_img_name=outfile_dir+'//'+file.strip() cv2.imwrite(out_img_name,image_gamma_correct) print "The number of photos which were processed is "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ec9eab1f9e591c8ad2f3fbcac2342f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22635042b6ed6519200b057b3947f2b0/" rel="bookmark">
			特征工程之特征选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前一篇文章中我介绍了一些数据预处理的方法，原始数据在经过预处理之后可以被算法处理了，但是实际中可能有一些特征是没有必要的，比如在中国采集的一些数据，那么国籍就都是中国，其实也就没有意义了，反映在统计量上就是方差过小，也就是样本在这个特征上变化很小。还有一种情况是特征和最后的结果相关性很小，也就是这个特征不起作用，衡量这种相关性我们可以用卡方检验，F-检验以及互信息等。其实很多sklearn的算法本身带有coef_和feature_importance_属性，而这个属性就可以被利用来筛选特征。前面说过的方法其实都是在已有特征的基础上排除特征的方法，但是在实际中我们很多时候需要自己构造特征，构造出好的特征可以大大提升模型的性能，对于这方面我就不是很了解了，毕竟我也是个新手，没有太多经验。
根据方差移除特征 sklearn中VarianceThreshold可以起到这个作用
from sklearn.feature_selection import VarianceThreshold sel = VarianceThreshold(0.2) sel.fit_transform(data) 上述代码起到移除方差小于0.2的特征的作用（只起到示意作用）。
单一变量特征选择 单一变量选择就是通过某种得分来度量相关性，进而选择特征，sklearn中有两个比较常用 . SelectKBest ：选择前k个最好的特征，也就是得分最高的K个 . SelectPercentile :选择前百分之几的特征，这个百分比由用户指定
所以从上面就可以看出必须要有一个方法来衡量这种相关性，来传给上面的两个方法，才能够做出选择。衡量方法也就是上面提到的，卡方检验，F-检验以及互信息。这几种方法在sklearn中是有专门的实现的，再进行单一变量特征选择的时候将他们作为参数传递进去。下面以卡方检验为例
&gt;&gt;&gt; from sklearn.datasets import load_iris &gt;&gt;&gt; from sklearn.feature_selection import SelectKBest &gt;&gt;&gt; from sklearn.feature_selection import chi2 &gt;&gt;&gt; iris = load_iris() &gt;&gt;&gt; X, y = iris.data, iris.target &gt;&gt;&gt; X.shape (150, 4) &gt;&gt;&gt; X_new = SelectKBest(chi2, k=2).fit_transform(X, y) &gt;&gt;&gt; X_new.shape (150, 2) 作为参数的打分的函数对于回归和分类是不同的： -回归：f_regression, mutual_info_regression -分类：chi2, f_classif, mutual_info_classif
值得注意的是互信息（mutual_info_regression， mutual_info_classif）可以得到特征和最后的结果之间的非线性的相关性，而卡方检验和F-检验应该只能够判断线性性。互信息的公式是 I(X;Y)=∑x∈X∑y∈Yp(x,y)p(x,y)p(x)p(y) I ( X ; Y ) = ∑ x ∈ X ∑ y ∈ Y p ( x , y ) p ( x , y ) p ( x ) p ( y ) 递归特征消除 递归特征消除（RFE）很好理解，给定一个模型，要求这个模型要能够给出coef_或者feature_importance_，然后我们就能够根据训练的这些相关性特征删除得分最差的特征，然后再一次训练，重复这个过程，直到最后满足我们预设的特征个数。还可以用RFECV通过交叉验证找出最佳的特征个数。下面是一个示例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22635042b6ed6519200b057b3947f2b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320eeb0ba88a72bc6dcd473050a6b937/" rel="bookmark">
			【LeetCode】696. Count Binary Substrings 解题报告（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者： 负雪明烛
id： fuxuemingzhu
个人博客： http://fuxuemingzhu.cn/
目录 题目描述题目大意解题方法方法一：暴力解法（TLE）方法二：连续子串计算 日期 题目地址：https://leetcode.com/problems/baseball-game/description/
题目描述 Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0’s and 1’s, and all the 0’s and all the 1’s in these substrings are grouped consecutively.
Substrings that occur multiple times are counted the number of times they occur.
Example 1: Input: "00110011" Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/320eeb0ba88a72bc6dcd473050a6b937/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7e32dad886ecc6ce154871720d0448e/" rel="bookmark">
			OSM(OpenStreetMap) poi、路网 数据导入 PostgreSQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标签 PostgreSQL , OSM , osm2pgsql , osm2pgrouting , osmosis
背景 从OpenStreetMap下载地图数据，使用osm2pgsql可以将数据导入PostgreSQL数据库，结合PostGIS插件，实现POI的业务。
如果要提取POI（兴趣点）数据，可以使用osmosis工具，处理OSM导出的文件。
https://github.com/openstreetmap/osmosis
如果需要用于路径规划，可以使用osm2pgrouting工具，将OSM文件导入到PostgreSQL数据库，结合pgrouting插件实现路径规划。
安装方法参考：
《PostgreSQL 10 + PostGIS + Sharding(pg_pathman) + MySQL(fdw外部表) on ECS 部署指南(适合新用户)》
参考 https://github.com/openstreetmap/osmosis
http://www.openstreetmap.org/
http://pgrouting.org/
http://postgis.net/
https://wiki.openstreetmap.org/wiki/Osmosis/Installation
http://wiki.openstreetmap.org/wiki/Osmosis/Detailed_Usage
https://help.openstreetmap.org/questions/4065/getting-specific-poi-data-and-keeping-them-up-to-date
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b132a716f7c87f9d60bf627e1e711ca2/" rel="bookmark">
			func() interface{} 强制类型转换（结构）（接口）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; package main import ( "sync" "fmt" ) type handler struct { p sync.Pool } type context struct{ A string B string } func (c *context) set(a,b string){ c.A=a c.B=b } func main(){ h:=handler{} //返回 interface{} ，interface 任意的数据，只要类型正确就可以强制转换 interface.(type) h.p.New= func() interface{} { return &amp;context{} } s:=h.p.Get().(*context)//get获取数据，.(*context)类型强制转换 s.set("A","B") fmt.Println(s.A,s.B) } 转载于:https://my.oschina.net/u/3529405/blog/1613943
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c952e5e2149c7fcfd7d362d01cdf657/" rel="bookmark">
			函数返回值和返回引用的 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数返回值时会产生一个临时变量作为函数返回值的副本，而返回引用时不会产生值的副本，既然是引用，那引用谁呢？这个问题必须清楚，否则将无法理解返回引用到底是个什么概念。以下是几种引用情况：
1，引用函数的参数，当然该参数(s1、s2)也是一个引用
const string &amp;shorter String(const string &amp;s1,const string &amp;s2)
{
return s1.size()&lt;s2.size()?s1:s2;
}
以上函数的返回值是引用类型。无论返回s1或是s2,调用函数和返回结果时，都没有复制这些string对象。简单的说，返回的引用是函数的参数s1或s2，同样s1和s2也是引用，而不是在函数体内产生的。函数体内局部对象是不能被因哟个的，因为函数调用完局部对象会被释放。
解释2：通常的返回机制将返回值复制到临时存储区域中, 随后调用程序将访问该区域. 返回引用则程序则调用程序将直接访问返回值.
通常引用将指向传递给函数的引用, 因此调用函数实际上是直接访问自己的一个变量.
比如
const int&amp; fun (int&amp; a, const int&amp; b)
{
a = a + b;
return a;
}
int x = 1, y = 2, z;
z = fun(x, y);
//等价于 fun(x, y); z = x;
2，千万不要返回局部对象的引用
const string &amp;mainip(const string &amp;s)
{
string ret=s;
return ret;
}
当函数执行完毕，程序将释放分配给局部对象的存储空间。此时，对局部对象的引用就会指向不确定的内存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c952e5e2149c7fcfd7d362d01cdf657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c71ffce84129e759be6a1b61fe48935/" rel="bookmark">
			MCU定时器分频的N种用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mcu定时器操作方式很多先列举两个，后边补充。
一：比较灵活开启时间比较自由
1 /*TIMER LIST intferce*/ 2 typedef struct timer_event 3 { 4 uint32_t de_counter; 5 void ( *callback )( void ); 6 struct timer_event *next; 7 }timer_event_t; 8 9 void TimerInit( timer_event_t *obj,void( *callback)(void)); 10 void TimerStart( timer_event_t *obj,uint32_t timer_val); 11 void TimerStop( timer_event_t *obj); 12 void App1MsTimerTickCallBack(void); static timer_event_t timer_list_head = {0,NULL,NULL}; //表头 /* 定时器list */ void App1MsTimerTickCallBack(void) { timer_event_t* cur = &amp;timer_list_head; while(cur-&gt;next != NULL) { cur = cur-&gt;next; if(cur-&gt;de_counter &gt; 0) { cur-&gt;de_counter -= 1; if(cur-&gt;de_counter == 0) { cur-&gt;callback(); } } } } void TimerInit( timer_event_t *obj,void( *callback)(void)) { timer_event_t* cur = &amp;timer_list_head; while(cur-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c71ffce84129e759be6a1b61fe48935/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00ff7973bbb5e37d772a8defffc8bf9e/" rel="bookmark">
			特征工程探索之数据预处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在前面的几篇文章里面介绍了一些机器学习的算法，当然不是非常全面，只是大致介绍，但我觉得对我来说已经对算法有了一定的理解。但是当我想完成一个真正的数据处理任务的时候，发现还是不够，从原始数据到开始用算法训练之间还有一部分空白，这个空白就是——特征工程。
我在一些文章里面都看到这种说法数据和特征决定了最后结果的上限，而算法只是用来逼近这个上限的工具。对此我深以为然，数据和选择的特征如果不好，算法再怎么巧夺天工也不可能从一堆垃圾里面找出金子。在使用sklearn做单机特征工程这篇博文里面，博主把从原始数据开始的清洗，预处理，特征选择，特征监控等都算作特征工程的一部分，所以，按照类似的分类方法我这篇文章先从数据预处理开始。
数据清洗 数据清洗可以说是非常重要的一步了，因为我们获得的原始数据很有可能有各种缺失值，并且有很多定性的特征（比如住址，性别等），这些算法都是无法处理的。 这里说明下，pandas 和sklearn都是可以用于数据预处理的。
缺失值处理 缺失值，在数据里面一般用”NaN”代替，是一定要处理的。
如果用pandas，可以直接把这条记录删除
import pandas as pd data = pd.read_csv("file_path") data.dropna() 利用dropna()函数可以滤除DataFrame中所有包含NaN的记录。如果采用
data.dropna(how = "all") 则删除全部为缺失值的行。 但是有时候含有NaN的记录太多，全都删除的话可能就没剩几条了，这样的话就浪费了太多的信息，这时候我们可以用能力更强的fillna()函数，来对缺失值进行进一步的处理。 比如
fillna(0) 将所有缺失值填充为0，
fillna(data.mean()) 将缺失值填充为每一行的平均值，这个方法挺重要的
fillna(method = 'ffill') 这个是对每个缺失值按照他前面的值填充，同理还有’bfill’是按照后面的值填充。 还有一些其他的细节感兴趣的可以自己探索
如果用sklearn ,可以利用preprocessing库里面的Imputer Imputer 的API为 class sklearn.preprocessing.Imputer(missing_values=’NaN’, strategy=’mean’, axis=0, ver- bose=0, copy=True) 其中missing_values就是缺失值的符号，默认是NaN，在处理的时候所有的missing_values代表的缺失值都会被处理 strategy表示使用什么方法处理，有三种方式mean，代表用沿着axis所指示的轴的平均值来代替。median代表用沿着axis所指示的轴的中位数来代替。most_frequent代表用沿着axis所指示的轴的最普遍的值来代替。默认是mean 使用的时候用法
Imputer().fit_transform(data) 定性特征编码 实际中的数据可能是定性的，比如高，中，低，这是一种特殊的情况，因为各个值之间有可比较的关系，那么我们就可以把他们编码成2，1，0。但是有些情况一些定性的值之间没有这种关系，比如城市，可以是北京，上海，广州，如果我们把他们编码成2，1，0就引入了原本不存在的序列信息，所以正确的方式是使用向量来表示比如[1,0,0],[0,1,0],[0,0,1]分别代表三个城市，向量的每个维度就代表是否为这个城市。这叫做哑编码，在sklearn.preprocessing中有一个OneHotEncoder可以做到。
但是，OneHotEncoder的输入需要是一个整数的矩阵，自己转换比较麻烦，这里还有种方法就是利用feature_extraction中的DictVectorizer()将键值对形式的数据转换成向量，对于定性的数据自动采用哑编码。大致用法是
vec = DictVectorizer(sparse = False) X_train = vec.fit_transform(X_train.to_dict(orient ='record' )) 其中X_train是DataFrame，to_dict()函数可以将其变成一种字典，参数orient默认是dict，但是他产生的结果是 df.to_dict() {‘col1’: {‘a’: 1, ‘b’: 2}, ‘col2’: {‘a’: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00ff7973bbb5e37d772a8defffc8bf9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe67920753765ba2882842d85f367c0/" rel="bookmark">
			mac桌面文件夹突然消失解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开终端 输入
defaults write com.apple.finder CreateDesktop -bool TRUE;killall Finder 当然把true 改为false 文件会全部消失
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72acc5133024ec7e4a06b096c280f105/" rel="bookmark">
			redis主从搭建（超简单）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis是非关系型数据库，原理一搜一大把，这里就不再赘述了，只介绍简单的搭建方法
达到目的：用sentinel嗅探主服务器状态，如果down了，十秒钟内完成切换，将slave升为master，当master再次启动时，变成slave状态
主服务器：192.168.1.11
从服务器：192.168.1.12
主服务器操作：
1、关闭防火墙和Selinux
2、yum -y install gcc //编译时需要用到gcc
3、wget http://download.redis.io/releases/redis-3.2.8.tar.gz //下载安装包
4、tar zxf redis-3.2.8.tar.gz -C /usr/src/ //解压文件
5、cd /usr/src/redis-3.2.8/ &amp;&amp; make &amp;&amp; make install //编译安装
6、mkdir -p /usr/local/redis/etc //创建配置文件及日志所存放的目录
mkdir /usr/local/redis/log
7、cp /usr/src/redis-3.2.8/redis.conf /usr/local/redis/etc/ //复制redis和sentinel的配置文件到
cp /usr/src/redis-3.2.8/sentinel.conf /usr/local/redis/etc/sentinel.bak --/usr/local/redis/etc下便于管理
8、vi/usr/local/redis/etc/redis.conf
修改：bind 0.0.0.0 //允许所有网段的IP与master连接
daemonize yes //在后台启动
9、grep -Ev ^# /usr/local/redis/etc/sentinel.bak | grep -v ^$ &gt; sentinel.conf //将注释和空白行删除
10、vi /usr/local/redis/etc/sentinel.conf
daemonize yes //添加，使其可以在后台运行
logfile "/usr/local/redis/log/sentinel.log" //添加sentinel.log的位置
sentinel monitor mymaster 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72acc5133024ec7e4a06b096c280f105/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46f99eb8e0a2dc1eca74f9fb3e45dc93/" rel="bookmark">
			Vue.js实现图片的随意拖动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 主要代码如下：
&lt;template&gt; &lt;div id="test_3"&gt; &lt;img src="../assets/img/photo.jpg" @mousedown="start" @mouseup="stop" @mousemove="move" :style="style"&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default{ data:function(){ return{ canDrag: false, x0:0, y0:0, x1:0, y1:0, style:null } }, methods:{ start:function(e){ //鼠标左键点击 if(e.button==0){ this.canDrag=true; //记录鼠标指针位置 this.x0=e.clientX; this.y0=e.clientY; } }, stop:function(e){ this.canDrag=false; }, move:function(){ if(this.canDrag==true){ this.x1=e.clientX; this.y1=e.clientX; let x=this.x1-this.x0; let y=this.y1-this.y0; let img=document.querySelector("#test_3 img"); this.style=`left:${img.offsetLeft+x}px;top:${img.offsetTop+y}px`; this.x0=this.x1; this.y0=this.y1; } } } } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a1473bd65accca7d9edc46656e25f1e/" rel="bookmark">
			数据库三范式 无重复列 完全依赖主键 属性不依赖非主属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：http://www.cnblogs.com/xrq730/p/5100442.html
细说数据库三范式
2.1 第一范式（1NF）无重复的列，保证每列的原子性，即每一列的各个属性值之间不能有相同部分，比如地址可以进一步拆分为 国家 省份 城市三列，可以理解为列不可拆分
第一范式（1NF）中数据库表的每一列都是不可分割的基本数据项
同一列中不能有多个值
即实体中的某个属性不能有多个值或者不能有重复的属性。
简而言之，第一范式就是无重复的列。
在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。
2.2 第二范式（2NF）属性完全依赖于主键[消除部分子函数依赖]，不满足时垂直拆分为一张新表。保证一张表只描述一件事情，即一个关系
满足第二范式（2NF）必须先满足第一范式（1NF）。
第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。
为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。 第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是属性完全依赖于主键。
2.3 第三范式（3NF）属性不依赖于其它非主属性[消除传递依赖]
满足第三范式（3NF）必须先满足第二范式（2NF）。
简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息，避免冗余保存其它表中的数据。
例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。
数据库三范式是设计数据库时需要考虑的基本原则，对数据库进行垂直拆分也要满足三范式。
转载于:https://www.cnblogs.com/heapStark/p/8336996.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ef2ce0be4f8d1c74d5b60df69c813aa/" rel="bookmark">
			模型压缩：Deep Compression
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步weight pruning第二步trained quantization and weight sharing第三步 Huffman coding 实验分析之压缩几十倍从何而来 实验分析之极致量化 《Deep Compression Compressing Deep Neural Networks with Pruning, Trained Quantization and Huffman coding》是ICLR-2016的 best paper，斯坦福的由HanSong等人共同发表。 arXiv(发音： 美[ˈɑ:rkaɪv]) ：https://arxiv.org/abs/1510.00149
前言： 从文章标题就知道，这是一篇关于模型压缩的论文，整体步骤分为三部：pruning ,quantization, coding。也就是，剪枝、量化、编码。熟悉通信理论的同学，对量化、编码再熟悉不过了，因此，针对于网络模型的操作仅仅体现在pruning上，而之后的量化和编码，可以归为信息存储技术。
模型压缩最终的目的不外就两个： 1. 存储问题 ，在不怎么损失网络性能的前提下，尽可能的占用更少的内存，以至于可以部署在移动端； 2. 速度问题 ，在不怎么损失网络性能的前提下，尽可能的提高inference时的速度，以达到实时处理。
然而，本文提出的方法，仅仅针对问题1.存储问题 ！对于inference的速度，并没得到什么提升，原文1.introduction中有一句话单独设为一段： “Our goal is to reduce the storage and energy required to run inference on such large networks so they can be deployed on mobile devices.”
正文： 讲解deep compression的步骤，以及实验结果以及结论。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ef2ce0be4f8d1c74d5b60df69c813aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efeb0e39e74efd5528f403b165a487d6/" rel="bookmark">
			int *(p)[ ] 与 int *p[ ]的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 int *(p)[ ]与int *p[ ]的比较 前者表示 p是由俩个指向int值的指针构成的函数，这种声明会创建俩个指向单个int值的指针；后者表示 p首先和*相结合，从而创建一个指向包含俩个int值的数组指针。 例： int *(p[4])是指针数组，数组内存放的是四个指针 int (*p)[4]是数组指针，数组内存放的整形，而p指向该数组 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/777077f68fb7e0c05f8fe661c510119b/" rel="bookmark">
			图像处理——矩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自：https://www.cnblogs.com/ronny/p/3985810.html
本文转自：http://blog.csdn.net/gdfsg/article/details/51015066
1. 矩的概念 2. Hu矩 3. 利用OPENCV计算Hu矩 opencv里对Hu矩的计算有直接的API，它分为了两个函数：moments()函数用于计算中心矩，HuMoments函数用于由中心矩计算Hu矩。
Moments moments(InputArray array, bool binaryImage=false )
参数说明 输入参数：array是一幅单通道，8-bits的图像，或一个二维浮点数组(Point of Point2f)。binaryImage用来指示输出图像是否为一幅二值图像，如果是二值图像，则图像中所有非0像素看作为1进行计算。输出参数：moments是一个类： class Moments { public: Moments(); Moments(double m00, double m10, double m01, double m20, double m11, double m02, double m30, double m21, double m12, double m03 ); Moments( const CvMoments&amp; moments ); operator CvMoments() const; } 里面保存了图像的2阶与3阶中心矩的值。
void HuMoments(const Moments&amp; moments, double* hu) 参数说明： 输入参数：moments即为上面一个函数计算得到的moments类型。输出参数：hu是一个含有7个数的数组。 int main(int argc, char** argv) { Mat image = imread(argv[1]); cvtColor(image, image, CV_BGR2GRAY); Moments mts = moments(image); double hu[7]; HuMoments(mts, hu); for (int i=0; i&lt;7; i++) { cout &lt;&lt; log(abs(hu[i])) &lt;&lt;endl; } return 0; } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/777077f68fb7e0c05f8fe661c510119b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95d4ee919b6fefc8072ca538f25d2f25/" rel="bookmark">
			margin 0 auto 和text-align区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 text-align：center 是当前元素中内容的排版方式；margin 是设置对象四边的外延边距，被称为外补丁或外边距；区别：设置文本或img标签等一些内联对象； margin:0 auto设置块元素的居中
1.text-align: 属性规定元素中的文本的水平对齐方式; 该属性通过指定行框与哪个点对齐，从而设置块级元素内文本的水平对齐方式;
一般情况下设置文本对齐方式的时使用此属性。支持值 justify。
Example: div { text-align: left; } //文本居左对齐
注释：所有浏览器都支持 text-align 属性；任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 "inherit"。
2.margin 是设置对象四边的外延边距，被称为外补丁或外边距。
Example: div { margin: 20px 10px 30px 40px; } // 表示对象外边距，顶20px、右10px、下30px、左40px
区别如下:
1.text-align:center 设置文本或img标签等一些内联对象（或与之类似的元素）的居中。
2.margin:0 auto 设置块元素（或与之类似的元素）的居中。
这两个属性IE与FF的理解也有所不同。我们设置一个段落P，在段落内存在一个图片img标签。　
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67221043cc5b2f0c0e5a2fb80c744ed4/" rel="bookmark">
			MySQL数据类型之TEXT与BLOB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般在保存少量字符串的时候，我们会选择CHAR或者VARCHAR,而在保存较大文本时，通常会选择使用TEXT或者BLOB。二者之间的主要差别是BLOB能用来保存二进制数据，比如照片；而TEXT只能保存字符数据，比如一遍文章或日记。TEXT和BLOB中又分别包括TEXT,MEDIUMTEXT,LONGTEXT和BLOB,MEDIUMBLOB,LONGBLOB三种不同的类型，他们之间的主要区别是存储文本长度不用和存储字节不用，用户应该根据实际情况选择能够满足需求的最小存储类型。
BLOB和TEXT值会引起一些性能问题，特别是执行了大量的删除操作时。 删除操作会在数据库表中留下很大的“空洞”，以后要填入这些“空洞”的记录在插入的性能上会有影响。为了提高性能，建议定期使用OPTIMEIZE TABLE功能对这类表进行碎片整理，避免因为“空洞”导致性能问题。 创建测试表t,字段id和context的类型分别为varchar(100)和text： 然后往t中插入大量记录，这里使用repeat函数插入大量字符串 repeat()函数解释（返回字符串str重复count次后的字符串。如果count小于1，则返回一个空字符串。如果str或count为NULL，返回NULL。）
查看表t的物理文件大小 从表t中删除id为“1”的数据，这些数据占总数据量的1/3； 发现表t的数据文件仍然为155MB,并没有因为数据删除而减少，接下来对表进行OPTIMIZE（优化）操作： 查看表t的物理文件的大小 可以发现，表的数据文件大大缩小，“空洞”空间已经被回收。
可以使用合成的（Synthetic）索引来提高大文本字段（BLOB或TEXT）的查询性能。 简单来说，合成索引就是根据大文本字段的内容建立一个散列值，并把这个值存储在单独的数据列中，接下来就可以通过检索散列值找到数据行了。但是，要注意这种技术只能用于精确匹配的查询（散列值对于类似“&lt;”或“&gt;=”等范围搜索操作符是没有用处的）。可以使用MD5（）函数生成散列值，也可以使用SHA1()或CRC32()，或者使用自己的应用程序逻辑来计算散列值。也可以使用SHA1()或CRC32()，或者使用自己的应用程序逻辑来计算散列值。数值型散列值可以很高效率地存储。如果散列算法生成的字符串带有尾部空格，就不要把他们存储在CHAR或VARCHAR列中，他们会收到尾部去除的影响。合成的散列索引对于那些BLOB或TEXT数据列特别有用。用散列标识符值查找的速度比搜索BLOB列的本身速度快很多。 创建一张表，来介绍合成索引的使用方法。 插入数据 如果要查询context值为“beijingbeijing”的记录，则可以通过相应的散列值来查询 这种做法只能用于精确匹配，在一定程序上减少了I/O，从而提高了查询效率。
在不必要的时候避免检索大型的BLOB或TEXT值。 把BLOB或TEXT列分离到单独的表中。 转载于:https://www.cnblogs.com/aotemanzhifu/p/9192389.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dbdddf552c08b2ff792fa9a33bb9a51/" rel="bookmark">
			Max Sum (O(n)时间复杂度)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Max Sum Problem Description Given a sequence a[1],a[2],a[3]......a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14. Input The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1&lt;=N&lt;=100000), then N integers followed(all the integers are between -1000 and 1000).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dbdddf552c08b2ff792fa9a33bb9a51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da139c923ebe92b0c49fc48db7d9a140/" rel="bookmark">
			jupyter notebook远程访问不了的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jupyter notebook非常方便，想在服务器上面搭建一个，但是访问不了。
（一）首先是安装jupyter notebook，
pip install jupyter 如果pip安装报错，缺少sqlite的库，那么请安装 sudo apt-get install libsqlite3-dev 然后需要 “重新编译python”，再通过pip安装（python3.x则不需要安装pysqlite） pip install pysqlite （二）启动jupyter jupyter notebook 其实这时候，local如果有browser的话，就可以输入访问了，但是没有，所以需要远程访问： http://ip:8888，发现访问不了 （三）配置远程访问jupyter
1）首先输入ipython生成秘钥
$ ipython from notebook.auth import passwd passwd()设定一个密码，会生成一个sha1的秘钥，如下图： 2）生成jupyter的config文件
$ jupyter notebook --generate-config这时候会生成配置文件，在 ~/.jupyter/jupyter_notebook_config.py 3）修改配置文件：~/.jupyter/jupyter_notebook_config.py
$vim ~/.jupyter/jupyter_notebook_config.py 加入如下内容，其中sha1那一串秘钥是上面生成的那一串
c.NotebookApp.ip='*' c.NotebookApp.password = u'sha1:f9030dd55bce:75fd7bbaba41be6ff5ac2e811b62354ab55b1f63' c.NotebookApp.open_browser = False c.NotebookApp.port =8888如图： 保存退出。
4）启动jupyter
$jupyter notebook 在远程电脑上，打开浏览器，输入：
http://your-server-ip:8888 需要输入密码，就是上面设置的那个密码，输入即可
5）OK了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af0784180cdcee8feafbd39015eab684/" rel="bookmark">
			Dataset - Visual Genome 数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visual Genome dataset Visual Genome 主页
Visual Genome Data
Visual Genome Readme
Visual Genome 数据集总览：
108077 张图片
5.4 Million Region Descriptions
1.7 Million Visual Question Answers
3.8 Million Object Instances
2.8 Million Attributes
2.3 Million Relationships
Everything Mapped to Wordnet Synsets
​
标注数据：
objects，attributes，图片内的 relationships
共 108K 张图片，每张图片平均有， 35 个 objects，26 个 attributes，21对 objects 见的成对 relationships.
1. Visual Genome 数据标注 数据集主要包括七个主要部分：
region descriptionsobjectsattributesrelationshipsregion graphsscene graphsquestion answer pairs 1.1. Region Descriptions 数据集标注了图片的 regions descriptions，每个 region 有一个 bounding box.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af0784180cdcee8feafbd39015eab684/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8a5be59f3cc160e12e80cc06b7a6520/" rel="bookmark">
			Nginx中获取自定义的header参数？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何在Nginx环境下获取自定义的header参数 ？ 项目之前部署在apache和IIS下运行，一直都好好的，且把用户ID和TOKEN在客户端以header参数的形式传过来的。后来改换环境，在NGINX下无法获取自定义的参数了，百度了解决方法，直接贴代码：
首先 fastcgi.conf中定义所用到的参数，如下： 其次在nginx.conf中定义？ 在程序通过getallheaders()方法获取。如果getallheaders()方法未定义，可以做个方法兼容，如下： if (!function_exists('getallheaders')) { function getallheaders() { $headers = []; foreach ($_SERVER as $name =&gt; $value) { if (substr($name, 0, 5) == 'HTTP_') { $headers[str_replace(' ', '-', ucwords(strtolower(str_replace('_', ' ', substr($name, 5)))))] = $value; } } return $headers; } } 获取的示例如下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/104aff8b314680b449d299612c9f854d/" rel="bookmark">
			opencv_contrib_python-3.4.0.12-cp36-cp36m（32位 64位）百度云资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官方下载地址下载太慢，贴一个百度云的地址：https://pan.baidu.com/s/1gguVL55（32位） https://pan.baidu.com/s/1bqP8c0Z（64位） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc4105b53fbe21753b4fe0290d24626/" rel="bookmark">
			vue项目兼容IE11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、npm安装babel-polyfill
npm install babel-polyfill --save-dev
2、在入口文件main.js中引入
import 'babel-polyfill' 3、如果也是用了官方脚手架vue-cli，还需要在webpack.config.js配置文件中做修改，即可。
entry: { app: ["babel-polyfill", "./src/main.js"] }, 改后别忘记重启项目，清除下浏览器缓存，此方法兼容IE11亲测有效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ac1ee8acf23ee83cc0124c9693598f8/" rel="bookmark">
			supervisor报错：ImportError: No module named supervisor.supervisord 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 centos环境下安装supervisor： 安装后启动supervisor时候报错：service supervisord start Starting supervisord: Traceback (most recent call last): File "/usr/bin/supervisord", line 2, in &lt;module&gt; from supervisor.supervisord import main ImportError: No module named supervisor.supervisord [FAILED] 问题原因：yum install supervisor 会默认使用python2.6环境 解决办法： 创建python 2.6环境 conda create --name py26 python=2.6 切换到2.6环境（我们用的是conda）： source activate py26 找到了这篇文章，然而里面说是改成python26，事实上应该是python2.6而不是python26 https://dev.classmethod.jp/cloud/aws/install_supervisor_to_amazonlinux_using_yum/ 默认的是#!/usr/bin/python 改成下面： vim /usr/bin/supervisord #!/usr/bin/python2.6 from supervisor.supervisord import main # __doc__ required to make supervisord -h work from supervisor.supervisord import __doc__ main() 启动服务，成功 sudo service supervisord start 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4a4422546cb88a91d34dc5348926113/" rel="bookmark">
			Android实现第三方登录并获取到头像、名字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先导入架包
下面还需要一个ImageLoader的依赖，用来加载图片
compile 'com.nostra13.universalimageloader:universal-image-loader:1.9.5'
首先是清单文件里的代码
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.shiran.qqlogindemo"&gt; &lt;!-- QQ登录授权所需权限 --&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- 注册SDKActivity --&gt; &lt;activity android:name="com.tencent.tauth.AuthActivity" android:launchMode="singleTask" android:noHistory="true" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt; &lt;data android:scheme="tencent1105602574" /&gt; &lt;!-- 开放平台获取的APPID --&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name="com.tencent.connect.common.AssistActivity" android:theme="@android:style/Theme.Translucent.NoTitleBar" android:screenOrientation="portrait"/&gt; &lt;/application&gt; &lt;/manifest&gt; 下面就是布局代码 &lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4a4422546cb88a91d34dc5348926113/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0091789fb71a40713e5f3422d56af826/" rel="bookmark">
			Python学习之路--Flask&#43;MongoDB搭建Restful Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发客户端的时候总是需要网络请求的，之前用过java的，node的，感觉都不是非常的方便。再加上机器学习越来越火，索性就用python来开发下web。
1 准备 1.1 Flask python的主流web框架有django和flask，这里使用了flask。flask是python编写的轻量级 Web 应用框架。
1.2 MongoDB MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 数据库的命令行简单操作:
mongo &gt; show dbs admin 0.078GB config 0.078GB local 0.078GB todoApp 0.078GB &gt; use todoApp switched to db todoApp &gt; show collections accounts device device1 system.indexes user &gt; db.user.find() { "_id" : ObjectId("5a4874bd377863486d2bbd62"), "name" : "test1", "password" : "123456" } { "_id" : ObjectId("5a487b143778634acfa46901"), "name" : "test2", "password" : "123456", "device" : ObjectId("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0091789fb71a40713e5f3422d56af826/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77fed5b18003975053d92293e8b6ff4/" rel="bookmark">
			socket 读、写字节流数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		socket是网络通信套接字。主要体现在读与写方面。 （ 阻塞读）
C版本：
int ReadFile(int nFile, void * pData, int * pSize) { int nLeft, nRead; char *pcData = pData; ASSERT(pData != NULL &amp;&amp; pSize != NULL); nLeft = *pSize; while (nLeft &gt; 0) { if ((nRead = read(nFile, pcData, nLeft)) &lt; 0) { if (errno != EINTR) ASSERT(0); nRead = 0; } else if (nRead == 0) break; nLeft -= nRead; pcData += nRead; } *pSize = *pSize - nLeft; return 0; } int WriteFile(int nFile, void* pData, int nSize) { int nLeft = nSize, nWrite; const char *pcData = pData; ASSERT(pData !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f77fed5b18003975053d92293e8b6ff4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/442/">«</a>
	<span class="pagination__item pagination__item--current">443/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/444/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>