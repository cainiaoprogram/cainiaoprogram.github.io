<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f7816c9de2a0f18f06cb424191f3255/" rel="bookmark">
			网络安全（黑客）——自学2024
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是网络安全 网络安全是一种综合性的概念，涵盖了保护计算机系统、网络基础设施和数据免受未经授权的访问、攻击、损害或盗窃的一系列措施和技术。经常听到的 “红队”、“渗透测试” 等就是研究攻击技术，而“蓝队”、“安全运营”、“安全运维”则研究防御技术。作为一个合格的网络安全工程师，应该做到攻守兼备，毕竟知己知彼，才能百战百胜。 二、网络安全怎么入门 安全并非孤立存在，而是建立在其计算机基础之上的应用技术。脱离这个基础，就容易陷入纸上谈兵的境地，出现“知其然，不知其所以然”的情况，这在安全职业道路上难以取得长远成就。
如果你之前是从事网工的，可以选择网络安全方向入门；
如果你之前是从事程序开发的，推荐选择Web安全/渗透测试方向入门。
然而，随着学习深入或者工作经验的积累，不同方向的技术耦合逐渐增加，要求在各个方向都能有一定的了解。
网安技能表
《----------学习资源免费领取，一个评论即可----------》
1、网安学习线路图2、老师教学笔记50份PDF3、渗透测试技巧及电子书86份4、攻防演练记录及笔记35份5、网安工具包，32G6、网安自学必看书籍352份PDF，28G7、120个漏洞实战演练案例8、网安面试题、CTF竞赛题等130份9、专业老师搭建实战靶场30个10、实训社群资源13000人 →→→→→→→→→&amp;关注告诉我，点赞收藏评论区留言 “已关注 求 ” ！&amp;
三、网络安全的知识多而杂，怎么合理安排学习？ 1、基础阶段
中华人民共和国网络安全法 （包含19个知识点）Linux操作系统 （包含15个知识点）计算机网络 （包含15个知识点）SHELL （包含13个知识点）HTML/CSS （包含45个知识点）JavaScript （包含42个知识点）PHP入门（包含13个知识点）MySQL数据库 （包含32个知识点）Python （包含19个知识点） 入门的首要步骤是有系统地学习计算机基础知识，即深入研究以下几个基础知识领域：操作系统、协议/网络、数据库、开发语言以及常见漏洞原理。一旦掌握了前述基础知识，就应着手进行实际操作。 2、渗透阶段
SQL注入的渗透与防御（包含38个知识点）XSS相关渗透与防御（包含15个知识点）上传验证渗透与防御（包含14个知识点）文件包含渗透与防御（包含13个知识点）CSRF渗透与防御（包含8个知识点）SSRF渗透与防御（包含6个知识点）XXE渗透与防御（包含7个知识点）远程代码执行渗透与防御（包含8个知识点） 熟悉常见漏洞的原理、使用方法和防御等方面的知识是必要的。在进行Web渗透的阶段，了解一些关键工具也是重要的。需要掌握的主要工具和平台包括：Burp、AWVS、Appscan、Nessus、Sqlmap、Nmap、Shodan、Fofa、以及代理工具SSRS、Hydra、Medusa、Airspoof等。对这些工具的实践可以通过上述提到的开源靶场进行，足以满足需求。 3、安全管理（提升）
渗透报告编写（包含22个知识点）等级保护2.0（包含51个知识点）应急响应（包含6个知识点）代码审计（包含9个知识点）风险评估（包含12个知识点）安全巡检（包含14个知识点）数据安全（包含26个知识点） 主要内容包括渗透测试报告的编写、网络安全等级的定级、应急响应、代码审计、风险评估、安全巡检、数据安全、法律法规汇编等方面。这个阶段主要面向那些已经从事网络安全相关工作，希望提升至管理层职位的人员。如果你的职业方向是网络安全工程师，那么这个阶段的学习可能是可选的。 4、提升阶段（提升）
密码学（包含35个知识点）JavaSE入门（包含95个知识点）C语言（包含145个知识点）C++语言（包含186个知识点）Windows逆向（包含48个知识点）CTF夺旗赛（包含38个知识点）Android逆向（包含42个知识点） 涵盖的内容主要有密码学、JavaSE、C语言、C++、Windows逆向、CTF夺旗赛、Android逆向等。这个阶段的学习主要面向那些已经从事网络安全相关工作，希望提升至进阶安全架构领域的人员。 四、网络安全学习路线 若你真心希望通过自学方式初探Web安全领域，我建议你查阅以下学习路线图。该路线图详细指导每个知识点的学习时长和学习方法，全程自学时间约为半年左右，亲测有效（文末有惊喜）。
1. 网络安全概念学习（2周）
掌握基本概念，包括SQL注入、文件上传、XSS、CSRF、一句话木马等。使用关键字（SQL注入、文件上传、XSS、CSRF、一句话木马等）进行Google/SecWiki搜索。阅读《精通脚本黑客》。尽管内容古老并可能存在错误，但仍适合入门。查阅渗透笔记/视频，了解整个渗透实战过程。使用搜索词（渗透笔记、渗透过程、入侵过程等）。 2. 渗透工具熟悉（3周）
熟悉AWVS、sqlmap、Burp、Nessus、Chopper、Nmap、Appscan等相关工具的使用。了解这些工具的用途和使用场景，首先通过软件名字在Google/SecWiki上搜索。下载这些工具的无后门版本进行安装。学习并实践使用，搜索SecWiki上的具体教材，如Burp的教程、sqlmap。熟练掌握这些常用工具后，可以考虑安装音速启动，构建渗透工具箱。 3. 渗透实战操作（5周）
掌握渗透的整个阶段，能够独立渗透小型站点。在网上找渗透视频，思考其中的思路和原理，使用关键字（渗透、SQL注入视频、文件上传入侵、数据库备份、dedecms漏洞利用等等）。自己找站点或搭建测试环境进行测试，注意隐藏个人身份。思考渗透主要分为几个阶段，每个阶段需要做哪些工作，例如PTES渗透测试执行标准。研究SQL注入的种类、注入原理、手动注入技巧。研究文件上传的原理，包括如何进行截断、双重后缀欺骗（IIS、PHP）、解析漏洞利用（IIS、Nginx、Apache）等，参考上传攻击框架。研究XSS形成的原理和种类，具体学习方法可以在Google/SecWiki搜索，也可以参考XSS。研究Windows/Linux提权的方法和具体使用，参考提权。可以参考开源渗透测试脆弱系统。 4. 关注安全领域动态（1周）
关注安全领域的最新漏洞、安全事件和技术文章。通过SecWiki浏览每日的安全技术文章和事件。在Weibo/Twitter关注安全领域的从业人员，尤其是大牛或者同行，每天抽时间浏览。使用feedly/鲜果订阅国内外安全技术博客，不仅限于国内，多积累关键信息。SecWiki的聚合栏目也是一个不错的选择。养成习惯，每天主动提交安全技术文章链接到SecWiki，进行分享和积累。多关注最新漏洞信息，推荐一些平台：exploit-db、CVE中文库、乌云等，实践公开漏洞利用。 5. 熟悉Windows/Kali Linux（3周）
学习Windows/Kali Linux的基本命令和常用工具。熟悉Windows下的常用cmd命令，例如ipconfig、nslookup、tracert、net、tasklist、taskkill等。熟悉Linux下的基本命令，如ifconfig、ls、cp、mv、vi、wget、service、sudo等。掌握Kali Linux系统下的常用工具，可以参考SecWiki、《Web Penetration Testing with Kali Linux》、《Hacking with Kali》等。熟悉metasploit工具的使用，可以参考SecWiki、《Metasploit渗透测试指南》。 6. 服务器安全配置（3周）
学习服务器环境配置，能够通过思考发现配置中存在的安全问题。针对Windows 2003/2008环境下的IIS配置，特别注意配置安全和运行权限，参考SecWiki-配置。针对Linux环境下的LAMP安全配置，主要考虑运行权限、跨目录、文件夹权限等，参考SecWiki-配置。进行远程系统加固，限制用户名和口令登录，通过iptables限制端口。配置软件WAF以加强系统安全，在服务器配置mod_security等系统，参见SecWiki-ModSecurity。使用Nessus软件对配置环境进行安全检测，发现未知安全威胁。 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f7816c9de2a0f18f06cb424191f3255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b99120f29b0caf81defe93ff08f63f/" rel="bookmark">
			Vue 进阶面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述MVVM 什么是MVVM？
视图模型双向绑定，是Model-View-ViewModel的缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。以前是操作DOM结构更新视图，现在是数据驱动视图。
MVVM的优点：
1.低耦合。视图（View）可以独立于Model变化和修改，一个Model可以绑定到不同的View上，当View变化的时候Model可以不变化，当Model变化的时候View也可以不变；
2.可重用性。你可以把一些视图逻辑放在一个Model里面，让很多View重用这段视图逻辑。
3.独立开发。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计。
4.可测试。
Vue底层实现原理 vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调
Vue是一个典型的MVVM框架，模型（Model）只是普通的javascript对象，修改它则试图（View）会自动更新。这种设计让状态管理变得非常简单而直观
Observer（数据监听器） : Observer的核心是通过Object.defineProprtty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher
Watcher（订阅者） : Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：
在自身实例化时往属性订阅器(dep)里面添加自己自身必须有一个update()方法待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调 Compile（指令解析器） : Compile主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新试图
谈谈对vue生命周期的理解？ 每个Vue实例在创建时都会经过一系列的初始化过程，vue的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件
create阶段：vue实例被创建
beforeCreate: 最初调用触发，创建前，此时data和methods中的数据都还没有初始化，data和events都不能用
created： 创建完毕，data中有值，未挂载，data和events已经初始化好，data已经具有响应式；在这里可以发送请求mount阶段： vue实例被挂载到真实DOM节点
beforeMount：在模版编译之后，渲染之前触发，可以发起服务端请求，去数据，ssr中不可用，基本用不上这个hook
mounted: 在渲染之后触发，此时可以操作DOM，并能访问组件中的DOM以及$ref,SSR中不可用update阶段：当vue实例里面的data数据变化时，触发组件的重新渲染
beforeUpdate :更新前，在数据变化后，模版改变前触发，切勿使用它监听数据变化
updated：更新后，在数据改变后，模版改变后触发，常用于重渲染案后的打点，性能检测或触发vue组件中非vue组件的更新destroy阶段：vue实例被销毁
beforeDestroy：实例被销毁前，组件卸载前触发，此时可以手动销毁一些方法，可以在此时清理事件、计时器或者取消订阅操作
destroyed:卸载完毕后触发，销毁后，可以做最后的打点或事件触发操作 组件生命周期 生命周期（父子组件） 父组件beforeCreate --&gt; 父组件created --&gt; 父组件beforeMount --&gt; 子组件beforeCreate --&gt; 子组件created --&gt; 子组件beforeMount --&gt; 子组件 mounted --&gt; 父组件mounted --&gt;父组件beforeUpdate --&gt;子组件beforeDestroy–&gt; 子组件destroyed --&gt; 父组件updated
加载渲染过程 父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted
挂载阶段 父created-&gt;子created-&gt;子mounted-&gt;父mounted
父组件更新阶段 父beforeUpdate-&gt;父updated
子组件更新阶段 父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated
销毁阶段 父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8b99120f29b0caf81defe93ff08f63f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0a0a11f005eadcd3b61c19247aa3c7a/" rel="bookmark">
			C语言中的输入输出详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在计算机编程中，输入和输出是程序与外部世界交互的两个基本方式：
输出：将计算机处理后的数据传输至外部输出设备，如显示器或打印机。输入：从外部输入设备（如键盘、鼠标或扫描仪）接收数据并输入到计算机内部进行处理。 C语言本身并未提供内建的输入输出语句，而是通过调用标准库中的输入输出函数来完成这些操作。下面我们将详细介绍C语言中常用的输入输出函数。
输入函数 scanf()：这是一个格式化输入函数，可以接收任意类型的数据。getchar()：字符输入函数，只能接收单个字符。gets()：字符串输入函数，用于接收一整行的字符串输入。 输出函数 printf()：格式化输出函数，可以根据指定的格式输出任意类型的数据。putchar()：字符显示函数，只能输出单个字符。puts()：字符串输出函数，用于输出一个完整的字符串，并自动添加换行符。 1. scanf()的使用 scanf("格式控制字符串", 参数地址列表); 格式控制字符串用于约定输入数据的类型和格式，参数的个数必须与变量地址的个数一致。参数地址列表是一个以逗号分隔的输入数据变量地址序列，每个地址前需加上取址运算符&amp;。 例如：
scanf("%d%d%d",&amp;a,&amp;b,&amp;c); 在此例中，%d表示读取整型数值，连续的%d意味着按照顺序读取三个整数，并分别存入变量a、b、c的内存地址中。
以下是几个使用scanf的示例：
示例1：计算圆的面积
#include &lt;stdio.h&gt; int main() { float radius, area; printf("请输入半径值： "); scanf("%f", &amp;radius); // 输入半径 area = 3.14 * radius * radius; printf("area=%f\n", area); // 输出圆的面积 return 0; } 示例2：求整数绝对值
#include &lt;stdio.h&gt; int main() { int num; printf("输入一个整数:"); scanf("%d", &amp;num); int absNum = num; if(absNum &lt; 0) absNum = -absNum; printf("\n 整数:%d---&gt;绝对值为:%d\n", num, absNum); return 0; } 示例3：计算两个数的乘积
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0a0a11f005eadcd3b61c19247aa3c7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d5af691d1ea465550d115a5fa5d1e5/" rel="bookmark">
			VB6获取多个汉字拼音的首字母，vba字符串转拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VB6获取多个汉字拼音的首字母，vba字符串转拼音
Function GetPY(ByVal StringABC As String) As String 'vb 获取多个汉字拼音的首字母 Dim Tmp As String, i As Long For i = 1 To Len(StringABC) Select Case Asc(Mid(StringABC, i, 1)) Case -20319 To -20284: GetPY = GetPY &amp; "A" Case -20283 To -19776: GetPY = GetPY &amp; "B" Case -19775 To -19219: GetPY = GetPY &amp; "C" Case -19218 To -18711: GetPY = GetPY &amp; "D" Case -18710 To -18527: GetPY = GetPY &amp; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1d5af691d1ea465550d115a5fa5d1e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/370174a60c9a05829f7430ebe7fbe1d4/" rel="bookmark">
			第三十三学习周报：文献阅读&#43;LSTM变体&#43;RNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
Abstract
文献阅读：卷积LSTM网络：降水临近预报的机器学习方法
现有问题
提出方法
相关知识
LSTM
FC-LSTM
Conv-LSTM
编码预测结构
研究实验
1. 数据集
2. 评估指标
3. 实验设计
4. 实验结果
研究贡献
Recurrent Neural Network（循环神经网络）
1. RNN的结构
2. RNN的分类
3. RNN的原理
4. RNN can be deep
5. Bidirectional RNN（ 双向RNN）
6. RNN的训练
基于Pytorch实现ConvLSTM
摘要 本周阅读的文献中首次提出ConvLSTM，ConvLSTM同时拥有LSTM的时间序列处理能力和CNN的空间特征处理能力，同时它也是FC-LSTM的扩展，解决了FC-LSTM对于空间数据包含太多的冗余的问题。通过叠加多个ConvLSTM层并形成一个编码-预测结构，可用于处理如降雨天气预报等时空序列问题。RNN是一种有记忆力的神经元，它能挖掘数据中的时序信息以及语义信息。通过手动演算RNN的运作过程，认识到它与CNN等结构不同，它同时考虑前一时刻的输入，对前面的内容具有“记忆”功能，因此网络的输入顺序将会影响输出。RNN进行训练时会存在梯度无效和梯度爆炸等问题，而通过LSTM可以很好解决RNN训练时的梯度无效问题。
Abstract The literature read this week first proposed ConvLSTM, which possesses both the time series processing capability of LSTM and the spatial feature processing capability of CNN.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/370174a60c9a05829f7430ebe7fbe1d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6491b58f821fb2a277a4e8eeb58b20e4/" rel="bookmark">
			Centos 7 安装Nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装编译环境 yum install -y gcc-c++ pcre pcrre-devel zlib zlib-devel openssl openssl-devel 下载或上传Nginx ​ 官网下载链接:nginx: download
​ 命令下载：
wget http://nginx.org/download/nginx-1.24.0.tar.gz 解压并编译文件 # tar -zxvf nginx-1.24.0.tar.gz # cd nginx-1.24.0 # ./configure # make &amp; make install 命令正常执行后 会在/usr/local/目录下生成nginx目录
/usr/local/nginx/conf 目录下为Nginx配置文件nginx.conf
/usr/local/nginx/sbin 目录下为Nginx执行程序
启动Nginx cd /usr/local/nginx/sbin nginx -s reload 注:修改nginx-conf 配置文件后 需要执行nginx -s reload 完成配置重载
其他问题 出现启动问题
[root@71bbc89bd68f sbin]# ./nginx -s reload
nginx: [alert] kill(3042, 1) failed (3: No such process)
或者
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6491b58f821fb2a277a4e8eeb58b20e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1cf52b343a043fc2a84c5c7d6f3c351/" rel="bookmark">
			C语言编译器（C语言编程软件）完全攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 介绍常用C语言编译器的安装、配置和使用。
常用的C语言编译器（编程软件）介绍，同时附带下载地址、详细的安装教程和使用教程。我们还对比了不同C语言编译器（C语言编程软件）的优缺点，让初学者知道该如何选择。
覆盖全平台，包括 Windows、Linux 和 Mac OS，不管你使用什么电脑，都能编写C语言代码。
提示：Windows 下的C语言编译器众多，多如牛毛，有的功能强大，但是安装和使用都比较复杂，有的小巧灵活，但是功能较弱；这里我们收集了八款常用的编译器，供大家下载。如果您是一名初学者，不知道该选择哪款编译器，那么请转到《Windows下的编译器有哪些？如何选择？》，我们已经给出了详细的说明。
Windows下的C语言编译器VS2022下载和安装教程（图解版） VS2022下载和安装教程（图解版）VS2022使用教程（使用VS2022编写C语言程序）VS2019下载地址和安装教程（图解） VS2019下载地址和安装教程（图解）VS2019使用教程（使用VS2019编写C语言程序） VS2017下载地址和安装教程（图解）
VS2017下载地址和安装教程（图解）VS2017使用教程（使用VS2017编写C语言程序）VS2015下载地址和安装教程（图解） VS2015下载地址和安装教程（图解）VS2015使用教程（使用VS2015编写C语言程序）VS2010下载地址和安装教程（图解） VS2010下载地址和安装教程（图解）VS2010使用教程（使用VS2010编写C语言程序）CLion下载、安装和汉化教程 CLion下载、安装和汉化教程使用CLion编写C语言程序Dev C++下载地址和安装教程（图解） Dev C++下载地址和安装教程（图解）Dev C++使用教程（使用Dev C++编写C语言程序）VC6.0（VC++6.0）下载地址和安装教程（图解） VC6.0（VC++6.0）下载地址和安装教程（图解）VC6.0（VC++6.0）使用教程（使用VC6.0编写C语言程序）Code::Blocks下载地址和安装教程（图解） Code::Blocks下载地址和安装教程（图解）Code::Blocks汉化教程（附带汉化包）Code::Blocks使用教程（使用Code::Blocks编写C语言程序）Turbo C 2.0下载地址和安装教程（图解） Turbo C 2.0下载地址和安装教程（图解）Turbo C 2.0使用教程（使用Turbo C 2.0编写C语言程序）C-Free 5.0下载地址和激活教程（图解） C-Free使用教程（使用C-Free编写C语言程序）C-Free 5.0下载地址和激活教程（图解）Linux平台下的编译器Linux GCC简明教程（使用GCC编写C语言程序）Mac OS平台下的编译器Xcode简明教程（使用Xcode编写C语言程序）【附录】VS常见问题VS安全函数问题（C语言安全函数）是怎么回事？如何解决？VS“无法查找或打开PDB文件”是怎么回事？如何解决 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c3f6f09bafbe81d189a333ce439ca7/" rel="bookmark">
			2024年阿里云、腾讯云、华为云、LightNode、硅云服务器如何选？怎么买最划算？[最新价格表]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多小伙伴都有一颗上云的心，包括我自己
有事没事的折腾一下自己的小破站，也挺有意思的！
那么，云服务器哪家好？优惠力度哪家大？活动入口哪里进？云服务器如何配置？如何选型？
相信这些问题不仅仅困扰着我，电脑对端的你也是吧。
本人最近宵衣旰食，不眠不休，终于整理了一份超全的云服务器大全，不说全网第一吧，也算是业界良心了！
其实我们在选择服务器上云的时候，往往不知道该如何选择机器型号，或者不知道各种产品之间到底有啥区别，那么请保存收藏本文哦！！官网最优活动入口一网打尽！
很多时候，同一款服务器，进错了官网活动，价格也是有差别！！文末分享爆款服务器性能测评报告！！
看过本篇文章，保证~
不管你是计算机软件专业的学生、云服务器的票友、亦或者是个人软件开发者还是中小企业，都能在本文中找到最具性价比的云服务器！！
保持良好的阅读习惯，建议点赞后收藏本文，不迷路哦
一、最新云服务器配置价格表 今年整体形势，大家应该都清楚，各行各业都不好过
尤其是互联网行业，前段时间哲库js，阿里cy，无一不震荡着我们互联网人的神经。
在这种大环境下，各行各业都内卷严重，甚至是各个大厂，也不能独善其身。
云厂商也不例外，云厂商之间内卷相当激烈，那些烧不起钱的厂商都卷出局了，现在剩下的，可以说是剩者为王了！
所以说也就经历了一波云服务器涨价，这也是没有办法的事情
但是，国内大厂云服务器价格经历一波上调后，好在遇到大促活动！！价格终于降了！！要上云赶紧入手！！
这里推荐大家参与双十一年度采购季 活动，官网活动入口：
https://curl.qcloud.com/IRNfLQJL
https://cloud.tencent.com/act/cps/redirect?redirect=2446&amp;cps_key=207e03af0468b3c5728cb64603468214&amp;from=console
我这里也精细汇总了各大厂商不同类型云服务器价格表，大家可以保存一下哈
一定要注意啊，不要因为购买链接不对，而多花冤枉钱！
如果你购买的价格比表中高，那很可能是链接不正确，记得从文中给出的卡片进入官网购买！同一种机型，参加的活动不对，价格也会差别很大哦！切记切记！
还有一个要嘱咐大家的就是，目前各个云厂商的新人活动都是非常给力的，所以大家千万不要自行贪图某些小便宜就随便够了服务器，这样你就属于老用户了。
我们一定要在第一次就选择合适的云服务器，这样你后期的总体成本才会越低。
为什么我推荐第一次购买服务器的时候就一次性到位呢，因为如果你先买了低配置的，然后后面要升级配置，那么这个时候价格就要高很多了！
而且我们选择云服务器的时候，各种配置有较多注意事项，我这里也进行了全方位的整理说明，尽可能的让你避坑！还不赶紧收藏、点赞吗？！
二、活动详情 接下来我就来介绍各个厂商的详细活动情况，不要错过啊！
1. 腾讯云 之所以把腾讯云放在第一位，就是因为当前腾讯云是国内性价比最高的云服务器了！
1）轻量应用服务器推荐 **轻量应用服务器：**配置适中，价格低，性价比高，是个人开发者和中小企业首选服务器。
我个人的小破站就是这个类型的服务器，真心好用，性价比超高！
a）轻量-超低价 腾讯云轻量应用服务器 2核2G 3M带宽 40G SSD盘 月流量200G 一年88元。
推荐理由：
对于个人开发者或者初级入门的朋友来说，这个服务器绝对是值得的，如果你是基于 Linux 的网站，那么这个配置完全够用。
推荐指数：4颗星
https://cloud.tencent.com/act/cps/redirect?redirect=5049&amp;cps_key=207e03af0468b3c5728cb64603468214&amp;from=console
b）轻量-最爆款 腾讯云轻量应用服务器 2核4G 5M带宽 60G SSD盘 月流量500G 一年168元。
推荐理由：
当然如果你对于你的网站应用有一些期盼的话，那么适当提高一个配置也是可以的。月流量500G，2C4G 完全够用。
推荐指数：4.5颗星
https://cloud.tencent.com/act/pro/618season?from=20616&amp;cps_key=207e03af0468b3c5728cb64603468214
c）轻量-爆款 腾讯云轻量应用服务器 **4核8G 12M带宽 180G SSD盘 月流量2000G 1年仅518元。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48c3f6f09bafbe81d189a333ce439ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ead6371f23d4a7ee4c19c5bd702a5a79/" rel="bookmark">
			python中parsel模块的css解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、爬虫页面分类 1.想要爬取的内容全部在标签中，可以使用xpath去进行解析如下图 2.想要爬取的内容呈现json的数据特征，用.json()转换为字典格式 3.页面不规则，标签中包含大括号，如下面想要获取键值内容怎么做，先用re正则获取大括号内容，再转换为json格式 4.想要爬取的页面数据很零散，建议使用css选择器，如下图，想要猫咪的年龄，品种，是否接种疫苗，是否支持视频看猫等信息 二、css解析步骤： import parsel html_data = requests.get(url,headers).text selector = parsel.Selector(html_data) content = selector.css('css格式') 实例化一个selector对象 css格式总结：
.代表class #代表id ::text 表示输出文本（即尖括号里面的内容） nth-child(page)表示匹配第page项 例子：
div 返回的是全部div标签
div.content 返回的是class = 'content'的整个div标签
div.content #su 返回的是class = 'content'的整个div标签下id = 'su'的标签
div.content li 返回的是class = 'content'的整个div标签下的li标签
div.content li:nth-child(1)返回的是class = 'content'的整个div标签下的li标签中的第一个li标签
div.content li:nth-child(1)::text返回的是class = 'content'的整个div标签下的li标签中的第一个li标签中的文本数据
div.content li:nth-child(1)::attr(href)返回的是class = 'content'的整个div标签下的li标签中的第一个li标签,其中的href所对应的属性值
selector.css('css样式').get() 获得一个匹配的
selector.css('css样式').getall()获得多个匹配的
可以在开发者工具中尝试：
定位要爬取的数据，在elements中ctrl+f出现
如想爬取在售只数应该怎么写：
import parsel import requests url = 'http://maomijiaoyi.com/index.php?/chanpinxiangqing_1038711.html' headers = {'User-Agent': 'Mozilla/5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ead6371f23d4a7ee4c19c5bd702a5a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64783d9911e4dc30c89e10c686f434a3/" rel="bookmark">
			基于web3&#43;solidity的众筹项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本配置：`node`、`npm`、`yarn`，安装`ganache`，`chrome`，`chrome`安装插件`MetaMask`，
主要功能：目的是实现一个简单的众筹平台，允许用户发起筹款项目、捐款、提出使用资金请求以及证明人证明。
部分合约：
1.首先打开ganache软件，进行如下配置，
2.然后通过私钥在metamask内添加两个账户。
3.输入：`truffle compile`
4. 输入：`truffle migrate`
5.合约地址粘贴到contract.js对应的位置
6. 将`./build/contracts/CrowdFunding.json`复制到`./crowdfunding/src/api/`目录下
7.输入yarn serve
8.项目总体目录
项目启动成功，下面一起看看具体的前端页面吧
证实操作：
需要项目源码或相关服务私聊
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fda613a7f47fbf62ef178fc8fa128c39/" rel="bookmark">
			如何让自己的写的程序在阿里云一直运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		购买了阿里云服务器后，每次要用自己写在阿里云的服务器程序都要连接到云端
然后./运行该程序，而且每次一断开终端，该服务器就会自动停止，这样使用相当麻烦。那怎样才能让我们的服务器一直在云端后台运行，即便退出终端，也保持这个服务器进程运行呢？
这里我们可以使用screen工具：
1、下载screen： CentOS 系列系统： yum install screen Ubuntu 系列系统： sudo apt-get install screen 2、运行screen，创建一个screen screen -S [name] [name] 是一个标记，可以自己随便填，这个标记是给自己看的，用来分辨该窗口的用途，避免窗口多了自己混淆 进入screen后我们把想要的程序运行起来然后退出再screen，该程序就会一直在后台正常运行
3、查看screen在后台运行的进程 screen -ls 4、进入查看后台运行的screen进程 screen -r -d [PID号]
5、杀死不需要的进程 kill -9 【PID号】
6、清理screen已经死亡的进程信息 screen -wipe （检查目前所有的screen作业，并删除已经无法使用的screen作业） 进程被人为终止后，可以看到在screen 里会显示dead，如果想清理掉这些已经死亡的进程信息可使用这个命令。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8c05fffb1edf7277a9e74e6f74cad64/" rel="bookmark">
			mysql之视图&amp;执行计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.视图
1.1视图简介
1.2 创建视图
1.3视图的修改
1.4视图的删除
1.5查看视图
二.连接查询案例
三.思维导图 一.视图 1.1视图简介 虚拟表，和普通表一样使用
MySQL中的视图（View）是一个虚拟表，其内容由查询定义。与实际表不同，视图不会在数据库中存储数据，它只是基于一个或多个表的查询结果的表示。视图可以被视为一个预定义的查询，它允许用户以一种特定的方式查看数据库中的数据。
视图的主要优点包括：
简化复杂查询：如果有一个复杂的查询，你可以将其定义为视图，然后简单地引用该视图以执行相同的查询。数据安全性：通过视图，你可以限制用户对基础表的特定列或行的访问。例如，你可以创建一个只显示员工姓名的视图，而不显示他们的地址或薪资信息。逻辑层：视图可以在逻辑层面上提供数据的表示，而不必关心底层的数据结构。 1.2 创建视图 create view 视图名 as 查询语句；
1.3视图的修改 alter view 视图名 as 查询语句;
1.4视图的删除 drop view 视图名，视图名。。。
1.5查看视图 DESC 视图名；-----查看视图相关字段
SHOW CREATE VIEW 视图名;
二.连接查询案例 01）查询" 01 "课程比" 02 "课程成绩高的学生的信息及课程分数
02）查询同时存在" 01 "课程和" 02 "课程的情况
03）查询存在" 01 "课程但可能不存在" 02 "课程的情况(不存在时显示为 null )
04）查询不存在" 01 "课程但存在" 02 "课程的情况
05）查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩
06）查询在t_mysql_score表存在成绩的学生信息
07）查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null ) 三.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8c05fffb1edf7277a9e74e6f74cad64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaf5c53d4c9422fefa9d5de0c2d0e81f/" rel="bookmark">
			关于谷歌Gemini大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年12月7日，谷歌AI宣布发布新一代基于Transformer架构的大模型Gemini。
Gemini的名字来源于双子座，象征着模型的双重性质：
一方面，它是一个强大的训练模型，可以在各种下游任务上进行微调，如文本摘要、机器翻译、问答、对话等；另一方面，它也是一个创造性的模型，可以根据用户的输入生成有趣和有用的内容，如诗歌、故事、代码、博客等。
Gemini 版本： 谷歌当天发布的Gemini 1.0共分为Ultra, Pro和Nano三个版本：
Gemini Ultra：能力最强，复杂度最高，能够处理最为高度复杂的任务，
Gemini Pro：能力稍弱，可以用来处理多任务，
Gemini Nano：更注重于移动端的处理能力。
Gemini的功能：
Gemini在多模态方面取得了突破性的进展，包括生成文本、图像、视频、音频、翻译语言、编写不同类型的创意内容、以及回答问题等各个方面全面超越了GPT-4的能力。
Gemini Ultra 模型的性能在大型语言模型 (LLM) 研发中使用的 32 个广泛使用的学术基准中的 30 个上超过了当前最先进的结果。
Gemini Ultra 的得分高达 90.0%，是第一个在MMLU（大规模多任务语言理解）上超越人类专家的模型，该模型结合了数学、物理、历史、法律、医学和伦理学等 57 个科目来测试知识和解决问题的能力。Gemini 在文本和编码等一系列基准测试中超越了最先进的性能。
Gemini Ultra 还在新的MMMU基准测试中取得了 59.4% 的最先进分数，该基准测试由跨越不同领域、需要深思熟虑的推理的多模态任务组成。
根据测试Gemini Ultra 的性能优于以前最先进的模型，无需从图像中提取文本以进行进一步处理的对象字符识别 (OCR) 系统的帮助。这些基准凸显了Gemini 双子座天生的多模态性，说明了Gemini双子座拥有更复杂的推理能力。
Gemini训练方法：
Gemini 是在谷歌的大规模多语言语料库上训练的，该语料库包含了来自互联网的文本、图像、音频、视频等不同类型的数据，覆盖了超过100种语言。
Gemini 采用了多种新颖的技术来提高模型的性能和效率，包括自适应稀疏注意力（Adaptive Sparse Attention）、多模态融合（Multimodal Fusion）和元学习（Meta-Learning）。这些技术可以让模型根据输入的复杂度和长度动态地调整注意力矩阵的稀疏度，从而减少计算和内存开销，同时保持高质量的输出；可以将文本、图像、音频、视频等不同类型的数据融合在一起，作为模型的输入，从而提高模型的泛化能力和多样性；可以让模型在训练过程中自动地调整其学习率、优化器、损失函数等超参数，从而适应不同的任务和数据分布。
如何集成gemini：https://zhuanlan.zhihu.com/p/673079995
如何创建 Google API 密钥。如何使用 Google Generative AI SDK 调用 Gemini API。如何使用 LangChain 框架集成 Gemini API。 LangChain是什么？
https://zhuanlan.zhihu.com/p/644500258
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b645d50afb5d464da951f68386089f/" rel="bookmark">
			8 单链表---带表头节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上节课所学的顺序表的缺点 顺序表的最大问题：插入和删除时需要移动大量元素
链式存储的定义 链式存储的逻辑结构 链表中的基本概念： 注意：表头节点并不属于数据元素
单链表图示： 把3个需要的结构体定义出来： typdef struct _tag_LinkList{ LinkListNode header; //指针域 int length; //单链表的长度 }TLinkList 获取第pos个元素 插入元素到pos位置 注意：新的链表形成之前，旧的链表不能断
删除元素： 一定要注意：index是从0开始还是从1开始【程序员永恒问题】
代码实现—单链表—带表头节点—头插法 linklist.c
#include "LinkList.h" typedef struct _tag_LinkList { LinkListNode* header;//头指针 int length;//单链表的长度 }TLinkList; //类型：即代表头结点，又代表整个单链表 LinkList* LinkList_Create() { TLinkList* ret = (TLinkList*)malloc(sizeof(TLinkList)); if (ret) { ret-&gt;length = 0; ret-&gt;header = NULL; } } void LinkList_Destory(LinkList* list) { free(list); } void LinkList_Clear(LinkList* list) { ((TLinkList*)list)-&gt;length = 0; } int LinkList_Length(LinkList* list) { return ((TLinkList*)list)-&gt;length; } int LinkList_Insert(LinkList* list, LinkListNode* node, int pos) { TLinkList* tll = (TLinkList*)list; int i = 0; int ret = -1; ret = (tll !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3b645d50afb5d464da951f68386089f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ba177e781fc0476c5fbc3c0d7f71c33/" rel="bookmark">
			ERROR 1698 (28000): Access denied for user ‘root‘@‘localhost‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单解决方法 注意密码要求
8位以上，需要包含大写、小写、数字、特殊字符。
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'PassWord...000'; 另一种方法 参考外文文献
ERROR 1698 (28000): Access denied for user ‘root’@‘localhost’
国内翻译
解决 MySQL 的 ERROR 1698 (28000): Access denied for user ‘root’@‘localhost’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92b5c816927acae6a7c3e7e03378864e/" rel="bookmark">
			idea中使用Lombok 失效，@Slf4j 找不到符号的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、前言二、问题排查和解决方案三、 其他解决方案3.1 另一种解决方案3.2 参考文章 一、前言 今天在一个多module工程中，新增了一个 springboot（版本 2.2.4.RELEASE） module，像往常一样，我引入了lombok依赖， 在类中也能正常引入@Slf4j注解，但是 编译时，总是报：找不到符号，符号：变量 log。可是我试了同一个中另一个 springboot（版本2.7.10）module 明明是可以正常编译的，至少可以说明IDEA的配置，相关插件都是没问题的，于是就觉得和springboot版本有关系。
二、问题排查和解决方案 我引入 lombok的依赖坐标写法如下，这里并没有指定 verion，因为springboot 父工程里定义好了 不同版本springboot使用不同版本lombok ，以保证互相兼容。
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 查看 spring-boot-dependencies-2.2.4.RELEASE.pom 文件可见 这里定义了 1.18.10 版本。
查看 spring-boot-dependencies-2.7.10.pom 文件可见 这里定义了 1.18.26 版本。
通过对比得知是版本的问题，我把lombok的版本提高到1.18.26 这个问题就迎刃而解。
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.26&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 三、 其他解决方案 同时在我解决问题的时候还发现 github 和stackoverflow 已经有人提出这个问题了并给出了解决方案：
地址：
GitHub：https://github.com/projectlombok/lombok/issues/2592
stackoverflow ：https://stackoverflow.com/questions/66170975/jps-incremental-annotation-processing-is-disabled-compilation-results-on-partia
3.1 另一种解决方案 在以下位置加入该配置-Djps.track.ap.dependencies=false
-Djps.track.ap.dependencies=false 3.2 参考文章 @Slf4j 变量log找不到符号，附上网上一般处理流程Idea21.1.3版本Lombok失效解决方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7157969d0846246d0112ac9f4054357/" rel="bookmark">
			A2DP Source如何从android系统拿到音频数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 13
简单来说就是两条本地socket通道，分别使用文件：
#define A2DP_CTRL_PATH "/data/misc/bluedroid/.a2dp_ctrl"
#define A2DP_DATA_PATH "/data/misc/bluedroid/.a2dp_data"
A2DP_CTRL_PATH是控制通道，A2DP_DATA_PATH是数据通道。
packages\modules\Bluetooth\system\audio_a2dp_hw\include\audio_a2dp_hw.h
1、首先需要关注一个文件 btif_a2dp_control.cc
// packages\modules\Bluetooth\system\btif\src\btif_a2dp_control.cc void btif_a2dp_control_init(void) { a2dp_uipc = UIPC_Init(); UIPC_Open(*a2dp_uipc, UIPC_CH_ID_AV_CTRL, btif_a2dp_ctrl_cb, A2DP_CTRL_PATH); } 里面的函数UIPC_Init
// packages\modules\Bluetooth\system\udrv\ulinux\uipc.cc std::unique_ptr&lt;tUIPC_STATE&gt; UIPC_Init() { std::unique_ptr&lt;tUIPC_STATE&gt; uipc = std::make_unique&lt;tUIPC_STATE&gt;(); LOG_DEBUG("UIPC_Init"); std::lock_guard&lt;std::recursive_mutex&gt; lock(uipc-&gt;mutex); uipc_main_init(*uipc); uipc_start_main_server_thread(*uipc); return uipc; } 初始化一些uipc的变量，然后启动主线程uipc_read_task
int uipc_start_main_server_thread(tUIPC_STATE&amp; uipc) { uipc.running = 1; if (pthread_create(&amp;uipc.tid, (const pthread_attr_t*)NULL, uipc_read_task, &amp;uipc) != 0) { LOG_ERROR("uipc_thread_create pthread_create failed:%d", errno); return -1; } return 0; } 这里面的实现不太需要关注。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7157969d0846246d0112ac9f4054357/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/374cd765f9bf4050674a92e76c537ce6/" rel="bookmark">
			【网络技术】【Kali Linux】Wireshark嗅探（八）动态主机配置协议（DHCP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的 本次实验使用 Wireshark （“网鲨”）流量分析工具进行网络流量嗅探，旨在初步了解动态主机配置协议（DHCP协议）的工作原理。
二、DHCP协议概述 动态主机配置协议（ D ynamic H ost C onfiguration P rotocol, DHCP）的作用是协助计算机在加入新的网络时获取新的IP地址。
三、实验网络环境设置 本次实验使用 Kali Linux 虚拟机完成，主机操作系统为 Windows 11，虚拟化平台选择 Oracle VM VirtualBox，网络模式（先后）选择 网络地址转换（NAT）和桥接网卡，如下图所示：
虚拟机设置：
网络模式1：
网络模式2：
四、DHCP协议报文捕获及分析 1、必要设置
在开始本次实验之前，需要将Kali Linux虚拟机获得IPv4地址的方式设定为“DHCP”。具体做法如下：
All Applications（所有应用）—— Advanced Network Configuration（高级网络配置项）—— Wired connection 1（当前网络连接）—— IPv4 Settings（IPv4设置）
将Method（方法）一栏设置为Automatic(DHCP)
2、实验组网
为了理解DHCP协议的工作原理，先后使用两种不同的组网模式，如下2图所说明：
在 网络地址转换（NAT） 模式下，虚拟机IP地址为10.0.2.15：
组网简图：
在 桥接网卡 模式下，虚拟机IP地址为192.168.1.23：
组网简图：
3、DHCP协议报文捕获及分析
（1） 在网络地址转换模式下，在 Kali Linux 虚拟机上启动 Wireshark，开始抓包，“过滤条件（Filter）”一栏中填写 dhcp 。
（2） 在“设备”——“网络”中将网络模式更改为“桥接网卡”，点击OK，此时抓取到更换网络（获取新IP地址）过程中的DHCP协议报文（共6条）：
（3） 请求报文协议字段内容：
（4） Offer报文协议字段内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/374cd765f9bf4050674a92e76c537ce6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6deecb9a72f0d32e8754ed01888e55c3/" rel="bookmark">
			uniappVue3版本中组件生命周期和页面生命周期的详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是生命周期？ 生命周期有多重叫法，有叫生命周期函数的，也有叫生命周期钩子的，还有钩子函数的，其实都是代表，在 Vue 实例创建、更新和销毁的不同阶段触发的一组钩子函数，这些生命周期函数允许开发者在不同阶段对 Vue 实例进行操作，以便执行特定的逻辑或清理工作。
生命周期主要包含以下四个阶段：创建、挂载、更新、销毁。
好比一款手机，创建（拿到全新一款手机）、挂载（安装各种软件）、更新（系统或者软件升级）、销毁（丢弃手机）
二、Vue3中的生命周期函数 官方生命周期函数地址
setup()是在beforeCreate和created之前运行的，所以可以用setup代替这两个钩子函数。onBeforeMount() : 已经完成了模板的编译，但是组件还未挂载到DOM上的函数。onMounted() : 组件挂载到DOM完成后执行的函数。onBeforeUpdate(): 组件更新之前执行的函数。onUpdated(): 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该函数。onBeforeUnmount(): 在组件实例被卸载之前调用。onUnmounted(): 组件卸载完成后执行的函数onActivated(): 若组件实例是 缓存树的一部分，当组件被插入到 DOM 中时调用。onDeactivated(): 若组件实例是 缓存树的一部分，当组件从 DOM 中被移除时调用。onErrorCaptured(): 在捕获了后代组件传递的错误时调用。 注意：在uniapp组件中，onBeforeUpdate、onUpdated、onActivated、onDeactivated，H5支持，小程序无法使用。
三、Vue2与Vue3的对比 四、uniapp中的页面生命周期函数 uniapp页面生命周期函数与 Vue.js 的生命周期函数有所不同，因为 uni-app 是基于 Vue.js 的跨平台应用框架，因此它具有自己特定的生命周期函数。
可以在这些生命周期函数中编写相应的逻辑代码，以便在不同阶段对页面进行初始化、展示、隐藏和卸载时执行特定的操作。
在开发uniapp Vue3版本的时候，不能像vue2的选项式API一样，可以直接使用onLoad、onShow等，在组合式API中需要先从“@dcloudio/uni-app”模块中导入才可以。
&lt;script setup&gt; import {onLoad,onReady} from "@dcloudio/uni-app" &lt;/script&gt; onLoad：页面加载时触发，可以在此生命周期函数中进行页面初始化操作。onShow：页面显示时触发，可以在此生命周期函数中进行页面展示相关的操作。onReady：页面初次渲染完成时触发，可以在此生命周期函数中进行页面渲染完成后的操作。onHide：页面隐藏时触发，可以在此生命周期函数中进行页面隐藏相关的操作。onUnload：页面卸载时触发，可以在此生命周期函数中进行页面卸载相关的操作。 其他常用的生命周期，可以看官方发文档，页面生命周期函数
五、uniapp中组件生命周期函数和页面生命周期函数的执行顺序 不包含组件的页面 onLoad &gt; onShow &gt; onReady
包含组件的页面 onLoad &gt; onShow &gt; onBeforeMount &gt; onReady &gt; onMounted
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f99ed5ca45f5c328b217f8e964bc3dc5/" rel="bookmark">
			transforms图像增强（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、图像变换 1、transforms.Pad transforms.Pad是一个用于对图像边缘进行填充的数据转换操作。
参数：
padding：设置填充大小。可以是单个整数，表示在上下左右四个方向上均填充相同数量的像素；也可以是一个包含两个整数的元组 (a, b)，表示在上下方向上填充 b 个像素，在左右方向上填充 a 个像素；还可以是一个包含四个整数的元组 (a, b, c, d)，分别表示在左、上、右、下四个方向上填充 a, b, c, d 个像素。padding_mode：填充模式，有四种模式可选： 'constant'：使用常数填充，填充值由 fill 参数指定。'edge'：使用图像边缘像素进行填充。'reflect'：使用图像边缘像素的镜像进行填充。'symmetric'：使用图像边缘像素的对称像素进行填充。 fill：当 padding_mode 为 'constant' 时，设置填充的像素值。可以是一个包含三个整数的元组 (R, G, B) 表示彩色图像的填充值，或者是一个整数表示灰度图像的填充值。
使用transforms.Pad可以在图像的边缘进行填充，以增加图像的尺寸或保持图像的大小不变。 示例：
import torchvision.transforms as transforms transform = transforms.Compose([ transforms.Pad(padding=2, fill=(255, 0, 0), padding_mode='constant') ]) # 对图像进行填充 padded_image = transform(image) 在上面的示例中，transforms.Pad(padding=2, fill=(255, 0, 0), padding_mode='constant')将图像的边缘填充了2个像素，填充的像素值为红色 (255, 0, 0)。填充模式为 'constant'，表示使用常数填充。
注意：填充操作通常在图像预处理阶段使用，以确保所有图像具有相同的尺寸或符合模型的输入要求。填充后的图像尺寸会增加，因此在应用填充之前需要考虑好图像的尺寸和比例关系。
2、transforms.ColorJitter transforms.ColorJitter是一个用于调整图像亮度、对比度、饱和度和色相的数据转换操作。
参数：
brightness：亮度调整因子。可以是单个浮点数 a，表示在范围 [max(0, 1-a), 1+a] 中随机选择亮度调整因子；也可以是一个包含两个浮点数的元组 (a, b)，表示在范围 [a, b] 中选择亮度调整因子。contrast：对比度参数，与亮度调整因子的使用方式相同。saturation：饱和度参数，与亮度调整因子的使用方式相同。hue：色相参数。可以是单个浮点数 a，表示在范围 [-a, a] 中选择色相调整参数，注意 0 &lt;= a &lt;= 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f99ed5ca45f5c328b217f8e964bc3dc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b142feacdeab9164f6dd7ab8bec04ee1/" rel="bookmark">
			EF Core实体的五种不同的状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Entity Framework Core Entity Framework Core是一个基于.NET Core的ORM框架，用于将对象表示转换为数据库中的数据。它提供了一组API，使得开发人员可以使用面向对象的方式来对关系数据库进行操作。
实体对象五种不同的状态： Detached（未跟踪）：实体对象没有被上下文追踪，也没有和数据库进行关联。这通常发生在新创建的对象或者已经从上下文中删除的对象上。Unchanged（未修改）：实体对象已经被上下文追踪，并且与数据库中的数据一致。这意味着该实体对象的属性没有被修改过。Added（新增）：实体对象是通过上下文的Add方法添加到上下文中的，但尚未保存到数据库。此时，对象被标记为新增状态。Modified（已修改）：实体对象的一个或多个属性已被修改。这通常发生在修改了实体对象的属性后，但尚未调用上下文的SaveChanges方法进行保存操作。Deleted（已删除）：实体对象是通过上下文的Remove方法从上下文中移除的，但尚未从数据库中删除。此时，对象被标记为删除状态。
这些实体状态反映了实体对象在上下文中的状态以及其与数据库之间的关系。根据实体对象的状态，Entity Framework Core会执行相应的操作来保持对象与数据库的一致性，例如插入、更新或删除操作。 Detached（未跟踪）： 场景：当你需要创建一个新的实体对象，并且不打算将其与数据库关联时，可以使用未跟踪状态。
var newEntity = new Entity { Name = "New Entity" };// 此时newEntity处于Detached状态 Unchanged（未修改）： 场景：当你查询数据库并获取一个实体对象时，该对象的属性与数据库中的数据一致，且不需要进行任何修改时，可以使用未修改状态。
var entity = dbContext.Entities.FirstOrDefault(e =&gt; e.Id == entityId);// 此时entity处于Unchanged状态 Added（新增）： 场景：当你想要将一个新创建的实体对象保存到数据库时，可以使用新增状态。
var newEntity = new Entity { Name = "New Entity" }; dbContext.Entities.Add(newEntity);// 现在newEntity处于Added状态 Modified（已修改）： 场景：当你需要修改实体对象的属性，并将这些更改保存到数据库时，可以使用已修改状态。
var entity = dbContext.Entities.FirstOrDefault(e =&gt; e.Id == entityId); entity.Name = "Updated Name";// 此时entity处于Modified状态 Deleted（已删除）： 场景：当你想要从数据库中删除一个实体对象时，可以使用已删除状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b142feacdeab9164f6dd7ab8bec04ee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50d57f428bf208e1bbeb1330d482c9df/" rel="bookmark">
			代码随想录：贪心算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		455. 分发饼干 解题步骤
排序：给两个数组排序举例判断：看第一个情况不满足，要换孩子还是换物品？
a. 换孩子→遍历孩子
b. 换物品→遍历物品 实战：
选择从小到大排序第一个不满足，我要换物品。因为换了孩子还是不满足。确定了遍历顺序：换物品→遍历物品 go实现
/** * @date: 2024 Jan 06 * @time: 10:50 * @author: Chris * @title: 455. Assign Cookies * @link: https://leetcode.cn/problems/assign-cookies/description/ **/ package day31 import ( "sort" ) // 优先满足胃口小的孩子， // 如果不可以换下一个物品；如果换孩子的的话也不能满足 func findContentChildren(g []int, s []int) int { // sort by ascending sort.Ints(g) sort.Ints(s) child := 0 // 遍历物品，如果不行换下个物品 for sIndex := 0; child &lt; len(g) &amp;&amp; sIndex &lt; len(s); sIndex++ { // 物品sIndex在不断递增 // child只有满足的当前孩子时候才递增，才会尝试分配给下一个孩子 if s[sIndex] &gt;= g[child] { child++ } } return child } // 优先满足胃口大的孩子， // 如果不行，换下个孩子； 如果换下一个物品的话也不能满足。 func findContentChildren2(g []int, s []int) int { // sort sort.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50d57f428bf208e1bbeb1330d482c9df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70bb80a6aa599951a4aa2ac959683152/" rel="bookmark">
			【PHP】where和whereOr一起复杂查询示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在ThinkPHP 5 中，where 和 whereOr 方法可以一起使用以实现复杂的查询条件。以下是一个示例：
// 接收的参数 $param = $this-&gt;request-&gt;param(); // 实例化 $query = new UserModel(); // 关联表 $query-&gt;with(['collect' =&gt; function($collect_query) use ($user_id) { $collect_query-&gt;field('id,user_id'); $collect_query-&gt;where('user_id', user_id); }]); // 查询条件 $query-&gt;where(['status' =&gt; 1]) // 可筛选逗号分割的 $query-&gt;where("FIND_IN_SET({$user_id},parent_ids)") // 价格区间最小值 if(isset($param['min_money']) &amp;&amp; is_numeric($param['min_money'])){ $query-&gt;where(function ($query) use ($param) { $query-&gt;where('price_min', '&gt;=', $param['min_money'])-&gt;orWhere('price_max', '&gt;=', $param['min_money']); }); } // 价格区间最大值 if(isset($param['max_money']) &amp;&amp; is_numeric($param['max_money'])){ $query-&gt;where(function ($query) use ($param) { $query-&gt;where('price_min', '&lt;', $param['max_money'])-&gt;orWhere('price_max', '&lt;', $param['max_money']); }); } // 查询结果 $list = $query-&gt;field(TaskModel::HALLLIST) -&gt;order($sort) -&gt;select(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1233ff346ea46a1eda90eed25d01c52/" rel="bookmark">
			程序与进程的基本认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d480eeba23db4ec50c48f36ca6971bd2/" rel="bookmark">
			Elasticsearch的性能优化思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件优化：
内存：确保足够的内存用于Elasticsearch，特别是JVM堆内存。一般建议将堆内存设置为物理内存的一半，但不超过32GB。CPU：提供足够的CPU资源，特别是对于复杂查询和大量写操作。磁盘：使用SSD硬盘以提高I/O性能。磁盘速度直接影响到索引和搜索的性能。 索引策略优化：
映射优化：根据数据特点优化字段映射，如适当使用不同的字段类型和索引策略。合理分片：合理设置索引分片数。过多的分片会增加管理和维护开销，而分片数过少可能无法充分利用集群资源。使用别名：使用索引别名可以在不中断服务的情况下重新索引数据。 查询性能优化：
避免深度分页：深度分页会消耗大量资源，应通过其他方式如滚动查询来替代。优化查询语句：避免使用高成本操作，如通配符和正则表达式。利用缓存：理解并合理利用Elasticsearch的查询缓存和字段数据缓存。 集群和节点配置：
负载均衡：确保集群中节点间的负载均衡。监控和日志记录：使用监控工具来跟踪集群的健康和性能。节点类型优化：合理配置主节点、数据节点和协调节点，根据集群的规模和用途调整。 批量处理与索引维护：
批量操作：尽量使用批量API进行数据的插入、更新和删除。定期维护：定期对索引执行优化操作，如清理过期数据。 使用最新版本：
Elasticsearch不断更新和优化，使用最新版本可以获得性能改进和新特性。 每个Elasticsearch集群的具体情况不同，因此在进行性能优化时应考虑特定的使用场景和需求。同时，持续监控和评估优化效果也是非常重要的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ec2b03a629531fbc163afd39a5e29e/" rel="bookmark">
			C语言常量详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言中，常量是指在程序运行时其值无法被修改的量。C语言中的常量可以分为以下几种类型：
1. 字面常量 字面常量包括整型常量、实型常量和字符型常量。在代码中直接写明的数值或字符即为字面常量。
#include &lt;stdio.h&gt; int main(){ // 字面常量 3.14; // 实型常量 1000; // 整型常量 'a'; // 字符型常量 } 2. 多种方式定义常量 2.1 使用#define 使用#define来定义常量，也称为宏定义，将一个标识符表示为一个常量值，在代码中使用时将其替换为常量值。
#include &lt;stdio.h&gt; #define ZERO 0 // #define的标识符常量 int main() { printf("zero = %d\n", ZERO); return 0; } 2.2 使用const限定符 const关键字在C99中引入，可以定义常量，对应的是一种更安全、更可控的定义方式。
#include &lt;stdio.h&gt; int main(){ // const 修饰的常变量 const float PI = 3.14f; // PI = 5.14; // 不能直接修改！ return 0; } 2.3 定义枚举常量 使用enum定义枚举类，其中括号中的内容是枚举常量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75ec2b03a629531fbc163afd39a5e29e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b3e788e38e93848e7342c6acd217a8e/" rel="bookmark">
			自动驾驶预测-决策-规划-控制学习（4）：预测分析文献阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、摘要分析1.Transformer模型是什么？什么是自注意力机制？ 2.数据集是什么？3.预测车辆行驶轨迹和车辆换道意图4. LSTM 网络 二、神经网络概述1.人工智能是什么？2.机器学习是什么？3.深度学习是什么？4.神经网络是什么？一个最简单的神经网络模型神经网络可以理解为一个分类器，通过训练后，能够记住我们人为需要的一类数据特征，那么对以后输入的任何数据都会按照这个记忆来分类，这种记忆力与神经网络每一层的神经元个数以及深度有关。数学思维下，深度学习的神经网络好比一个可以自主调节系数的公式。 5.RNN和CNN是什么？各自有什么优缺点？RNN：时序序列数据的处理CNN:网格化图像数据处理RNN和CNN各自有以下优缺点： 二、绪论分析三、简要解释基于transformer的车辆未来时刻轨迹预测四、简要分析基于transformer的车辆换道意图预测 前言 题目：《基于 Transformer 的车辆轨迹预测及变道意图识别方法研究》-吉林大学都业铭
一、摘要分析 本文改进了 Transformer 模型， 在 Argoverse 数据集、NGSIM 数据集上分别设 计了新的模型结构， 可以分别完成预测车辆行驶轨迹和车辆换道意图识别任务。在 车辆行驶轨迹预测任务中，本文在 Argoverse 数据集上使用最小平均位移误差 （minADE）、最小终点位移误差（minFDE）、错过率（MR）等指标与多种轨迹预 测方法进行了比较与评估， 结果显示本文基于 Transformer 改进的模型在轨迹预测 任务上具有更高的准确性。除此之外，本文还在 Transformer 模型基础上进行改进， 使其能够完成车辆换道意图识别任务。同时本文与不同隐藏层数的 LSTM 网络进 行了对比实验， 结果表明在准确率与召回率指标上， 本文基于 Transformer 的车辆换道意图识别模型更加优秀。
1.Transformer模型是什么？ Transformer模型是一种基于自注意力机制的神经网络模型，最初由Google在2017年提出，用于自然语言处理任务，如机器翻译、文本生成等。与传统的循环神经网络（RNN）和卷积神经网络（CNN）不同，Transformer模型不需要按照时间顺序或空间位置顺序处理输入数据，而是通过自注意力机制来计算输入数据中不同位置之间的依赖关系，从而实现对输入数据的全局理解和处理。
Transformer模型由编码器和解码器两部分组成，其中编码器用于将输入序列转换为一系列特征表示，解码器则用于根据编码器的输出和上下文信息生成目标序列。Transformer模型的主要优点是能够处理长序列数据，同时具有较好的并行计算能力，因此在自然语言处理、图像处理等领域得到了广泛应用。
什么是自注意力机制？ 当谈到Transformer时，我们通常会提到它在自然语言处理中的应用，比如机器翻译。让我们以机器翻译为例来解释Transformer的原理。
假设我们要将一句英文句子翻译成法文。在传统的神经网络中，我们会使用循环神经网络（RNN）或卷积神经网络（CNN）来处理输入序列。但是，这些模型在处理长句子时可能会遇到一些问题，比如长期依赖关系的捕捉和并行计算的困难。
Transformer通过引入自注意力机制来解决这些问题。它的核心思想是将输入序列中的每个单词都看作是一个向量，并通过计算这些向量之间的相似度来确定它们之间的关系。
首先，Transformer将输入的英文句子中的每个单词转换为向量表示，这些向量称为"词嵌入"。然后，它引入了一个叫做"注意力机制"的概念。注意力机制允许模型在生成输出的过程中，根据输入序列中的不同单词的重要性来分配不同的权重。
在编码器部分，Transformer使用多层的自注意力机制来对输入序列进行编码。每一层都会计算每个单词与其他单词之间的相似度，并根据相似度分配权重。这样，模型可以同时考虑到整个输入序列的信息，而不仅仅是局部上下文。
在解码器部分，Transformer使用类似的自注意力机制来生成目标序列。它会根据已经生成的部分目标序列来预测下一个单词，并不断迭代生成整个目标序列。
通过使用自注意力机制，Transformer能够更好地捕捉长期依赖关系，并且可以并行计算，提高了模型的训练和推理效率。这使得Transformer在机器翻译等自然语言处理任务中取得了很大的成功。
总结起来，Transformer通过引入自注意力机制，将输入序列中的每个单词都看作是一个向量，并根据它们之间的相似度来确定它们之间的关系。这种机制使得Transformer能够更好地处理长句子和捕捉长期依赖关系，提高了模型的性能和效率。
想象一下你在学习一门新语言，比如学习法语。你需要将一句英文句子翻译成法语。传统的方法是逐个单词地翻译，但这可能会导致一些问题，比如长句子的处理困难和长期依赖关系的捕捉问题。
Transformer是一种新的方法，它使用了一种叫做"自注意力"的机制来解决这些问题。自注意力机制可以帮助模型在处理输入时，更好地关注不同单词之间的关。
在这个例子中，我们可以将输入的英文句子中的每个单词看作是一个人，而Transformer就像是一个聪明的观察者。这个观察者会同时观察所有的人，并注意到每个人与其他人之间的相似度。
然后，观察者会根据相似度来决定每个人的重要性。比如，如果一个人在句子中出现多次并且对整个句子的理解很重要，那么他的重要性就会更高。
在编码器部分，观察者会通过多次观察和计算相似度来对整个句子进行编码。每次观察都会给每个人分配不同的权重，以便更好地捕捉句子中的关系。
在解码器部分，观察者会使用类似的方法来生成目标语言的句子。他会根据已经生成的部分句子来预测下一个单词，并不断重复这个过程，直到生成整个目标句子。
通过使用自注意力机制，Transformer可以更好地处理长句子和捕捉长期依赖关系。这种方法使得模型在机器翻译等任务中表现出色。
2.数据集是什么？ 数据集是指在进行机器学习或深度学习任务时所使用的数据的集合。它是从现实世界中收集、整理和标注的一组样本数据，用于训练、验证和测试机器学习模型的性能。
数据集通常包含输入数据和对应的标签或目标值。输入数据可以是图像、文本、音频等不同形式的数据，而标签或目标值则是对输入数据的描述、分类或预测结果。在训练过程中，机器学习模型通过对数据集进行学习和优化，从而能够对新的未见过的数据进行准确的预测或分类。
数据集的质量和多样性对于机器学习模型的性能至关重要。一个好的数据集应该具有代表性、多样性和充分的样本数量，以确保模型能够泛化到不同的情况和场景中。同时，数据集的标注质量也需要高，以保证模型能够学习到正确的模式和规律。
在论文中，作者使用了Argoverse数据集和NGSIM数据集作为训练和评估模型的基准数据集，用于车辆行驶轨迹预测和车辆换道意图识别任务。这些数据集是从真实的交通场景中收集而来，并经过标注和处理，以供研究人员进行相关任务的研究和性能评估。
3.预测车辆行驶轨迹和车辆换道意图 预测车辆行驶轨迹和车辆换道意图是自动驾驶系统中的两个重要任务。在自动驾驶系统中，车辆需要能够准确地预测其他车辆的行驶轨迹和换道意图，以便做出相应的决策和规划行驶路线。
预测车辆行驶轨迹是指根据车辆当前的位置、速度和方向等信息，预测其未来一段时间内的行驶轨迹这个任务的难点在于需要考虑到其他车辆、行人、路标等因素对车辆行驶轨迹的影响，同时需要考虑到车辆自身的动力学特性和环境因素，如路况、天气等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b3e788e38e93848e7342c6acd217a8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/194c11821aef66de62c3f398292bcd30/" rel="bookmark">
			18.Linux Shell中的mktemp命令使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 `Linux Shell`创建临时文件在工作目录创建临时文件在`/tmp` 目录创建临时文件3)创建临时目录 欢迎访问个人网络日志🌹🌹知行空间🌹🌹
Linux Shell创建临时文件 Linux的/tmp目录用来存放不需要永久保留的文件。大多数Linux发行版配置了系统在启动时自动清空/tmp目录的功能。系统上的任何用户账户都有权限读写/tmp目录中的文件。这为用户提供了一种创建临时文件的简单方法。
mktemp 命令可以用来创建临时文件，并保证创建文件名的唯一性。它会将文件的读和写权限分配给文件的属主，并将文件创建者设置成文件的属主。
在工作目录创建临时文件 默认情况下， mktemp 会在工作目录中创建一个文件。mktemp创建文件需要用户提供一个文件名模板，这个文件名模板可以包含任意文本文件名，只需要在文件名末尾加上6个大写的X就行了，系统会自动替换6个XXXXXX，生成唯一的标识名。
$ mktemp test_XXXXXX # test_dtDrji $ mktemp test_XXXXXX # test_5AHGek $ mktemp test_XXXXXX # test_qRaG25 从上面的例子可以看到mktemp 命令的输出正是它所创建的文件的名字，在脚本中使用 mktemp 命令时，可能要将文件名保存到变量中，这样就能在后面的脚本中引用了。
#!/bin/bash tempfile=$(mktemp test_XXXXXX) exec 3&gt;$tempfile echo "This script writes to temp file $tempfile" echo "line1" &gt;&amp;3 echo "line2" &gt;&amp;3 echo "line3" &gt;&amp;3 exec 3&gt;&amp;- echo "Done creating temp file. The contents are:" cat $tempfile rm -f $tempfile 2&gt; /dev/null 这样，就会用 mktemp 命令来创建临时文件并将文件名赋给 $tempfile 变量。rm -f $tempfile 2&gt; /dev/null是吃掉rm命令的报错信息，不将其打印到显示器上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/194c11821aef66de62c3f398292bcd30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852c09a29e85bedf0503f3ac014a1612/" rel="bookmark">
			JavaScript-变量&amp;数据类型-笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.变量的使用
① 先声明 再赋值
声明：var 变量名 在声明时不知道数据类型
赋值：变量名 = 值 在赋值时 知道数据类型
② 初始化： 在声明变量时 就进行赋值
var 变量名 = 值
2.变量名在使用时 不能加引号
3.声明变量的特殊情况
① 只声明 不赋值：undefined
② 不声明 不赋值：报错
③ 不声明 只赋值：可以 正常使用
4.变量名的命名规范
① 组成: 字母、数字、下划线、美元符号
② 数字不能开头
③ 不能使用关键字和保留字
④ 见名识义 (语义化) uname agesex hobby
⑤ 严格区分大小写
⑥ 驼峰命名法: 除了第一个单词，其他单词的首字母大写 boyName girlName
5.字符串的长度 字符的数量就是字符串的长度，通过字符串length属性获取。【字符串.length】
var str = "你好世界"；
console.log(str.length); // 显示 4
6.字符串的拼接
多个字符串之间可以使用+进行拼接，并生成新的字符串。
console.log( "hello" + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/852c09a29e85bedf0503f3ac014a1612/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eafb7da9c13a1c03f43acd2239ec7cd/" rel="bookmark">
			【数据分享】2023年我国土壤数据集HWSD2.0（免费获取/7个土壤深度/40多种土壤指标）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		土壤数据，包括土壤类型、土壤酸碱度、土壤沙含量等指标，对于农业、林业、园艺、环境保护等领域都非常重要。
本次我们为大家带来的是2023年1月份发布的我国土壤数据库，包括国界范围的数据和分省份的数据。该数据的核心信息如下：
①该数据是基于联合国粮农组织（FAO）和维也纳国际应用系统研究所（IIASA）所构建的世界土壤数据库HWSD2.0经过处理得到的。
②该数据包括7个土壤深度层的数据，分别为0-20cm、20-40 cm、40-60 cm、60-80 cm、80-100 cm、100-150 cm和150-200 cm，每个土壤深度层一个tif文件。
③每个土壤层都包含至少1种土壤，至多12种土壤。
④每种土壤包括40多种指标，比如酸碱度、导电率、含沙量、含水量、粉沙粒含量、有机碳含量等。
⑤数据的其它信息包括：数据格式为栅格格式（tif）,数据分辨率约为1公里，数据坐标为wgs1984，数据范围为中国范围。
大家在公众号回复关键词101可免费获取全国任意一个省份的土壤数据集，包括上述所有指标，无需转发文章，直接获取！ 如果想要全国范围的数据，请在公众号回复关键词 102 按照转发要求获取全国范围的数据。以下为数据的详细介绍：
01 数据详情
1.该数据包括七个土壤深度层的数据，深度范围依次为0-20cm、20-40 cm、40-60 cm、60-80 cm、80-100 cm、100-150 cm和150-200 cm，每个土壤深度层为一个tif文件，如下图：
2.对于每个土壤深度层，都包含至少1种土壤，至多12种土壤，每种土壤都有相应指标（超过40种指标）。我们以0-20cm土壤深度层为例来具体看一下！如下图：
其中：F1_xxxxxx代表第一种土壤的相关属性，F2_xxxxxx代表第二种土壤的相关属性，以此类推。注：从F1-F12是土壤占比从大到小的排序，也就是F1_xxxxxx代表该土壤层中占比最大土壤的相关属性。需要说明的是国界范围的土壤数据直接以数字开头，没有字母F。
3.对于每一种土壤又包括了40余种具体指标，具体指标如下（*_代表第*种土壤的相关属性）：
OID：内部唯一索引数据库标识符，映射单元的自然序列
Value：全局映射单元标识符，提供GIS层与属性数据库之间的链接
Count：土壤指标完全一样表现连续性的区域大小
F*_SEQUENCE：土壤种类在土壤测绘单元组成中的顺序（按照占比大至小来排序）
F*_SHARE：该种土壤在土壤测绘单元组成中的份额/占比
F*_LAYER：Depth Layer土壤层 (从D1到D7)
F*_TOPDEP：Depth of top of layer该土壤层的顶部深度（cm）
F*_BOTDEP：Depth of bottom of layer该土壤层的底部深度（cm）
F*_COVERAGE：土壤数据的来源
F*_NSC_MU_SOURCE1：国家土壤分类
F*_NSC_MU_SOURCE2：国家土壤分类
F*_WRB_PHASES：土壤分类(FAO WRB2022标准)
F*_WRB4：土壤分类(FAO WRB2022标准 四字代码)
F*_WRB2：土壤分类(FAO WRB2022标准 两字代码)
F*_FAO90：土壤分类(FAO 1990标准)
F*_ROOT_DEPTH：可根土壤深度
F*_PHASE1：土壤相位
F*_PHASE2：土壤相位
F*_ROOTS根（障碍物的根）：提供STU中根的障碍物的深度等级
F*_IL（防渗层）：指示STU的土壤剖面中存在防渗层
F*_SWR（土壤水分状况）：指示STU的土壤剖面中占主导地位的年度平均土壤水分状况类别
F*_DRAINAGE：土壤排水类别
F*_AWC ：以毫米/米为单位的土壤单位的可用储水量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eafb7da9c13a1c03f43acd2239ec7cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b3b4001e90e75ec39085a36744027d/" rel="bookmark">
			一篇文章学透所有Python知识（建议收藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本文中，我们将深入探讨Python编程的八大核心知识点，并提供多个实例代码，帮助读者更好地理解和运用这些知识点。
第一部分：基础语法
1. 变量的定义与使用
name = "John" age = 25 2. 数据类型操作
num1 = 10 num2 = 5 result = num1 + num2 print(result) 3. 条件语句
score = 85 if score &gt;= 90: print("优秀") elif score &gt;= 80: print("良好") else: print("及格") 4. 循环结构
for i in range(1, 6): print(i) 第二部分：函数和模块
1. 函数的定义与调用
def add(a, b): return a + b result = add(3, 4) print(result) 2. 参数传递
def greet(name): print("Hello, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78b3b4001e90e75ec39085a36744027d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d714b3de92215c5fe099158c4d896ca9/" rel="bookmark">
			51单片机串行口相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		51单片机串行口相关知识 串行通信概念 计算机与外部通信方式就两种：
并行通信串行通信 两种通信方式的特点以及适用场景：
名称特点适用场景并行通信速度快，效率高，成本高适合短距离高速通信，如计算机内部各硬件之间通信串行通信速度慢，效率低，成本低适合远距离低速通信，如线缆，网线 串行通信的三种模式 有三种：
单工：数据只能从A到B半双工：数据可以AB相互传递，但是不能同时进行全双工：数据可以AB相互传递，而且可以同时进行 波特率 用来衡量串行通信的速度，具体含义是每秒传送的二进制数码的位数。
单位： bps （位/秒）
国际规定的标准波特率系列：
110bps300bps600bps1200bps1800bps2400bps4800bps9600bps19200bps 接收端和发送端的波特率分别设置时，必须保证两者相同
串行通信的两种方式 有两种：
异步通信同步通信 异步通信 将字节为单位组成数据帧的格式进行传输，称作异步通信。
一帧数据的组成包括：
起始位：1位，一定为低电平数据位：5~8位，从低到高依次传送可编程校验位：1位，可以作为校验位，具体内容根据校验方式而定停止位：1位，数据帧末尾，始终为高电平 传输线未开始通信时一直处在高电平状态，当接收端检测到传输线上出现低电平时就意味着发送端已经开始发送了，之后接收到终止位就知道数据发送完成。
同步通信 在同步通信种，数据是以块为单位发送的。
下面是同步通信的理解图，注意，51单片机种的传输方式与其略有差别：
以下是51单片机中的同步通信示意图：
可以看出区别：51单片机中的同步通信在数据传输的过程中不需要同步信号。
同步通信的要求较为严格，需要注意的细节如下：
发送端和接收端的设备需要同步（一般由硬件实现）没有开始信号和终止信号适合传输数据量大，效率要求高的场合 51单片机的串行口控制器 串行口内部结构 51单片机的内部有一个全双工的串行通信接口。
这个图可以从最右边看起：
有两个接口：TXD和RXD，一个用于发送，一个用于接收
接着是一个寄存器： SCON串行控制寄存器，这个寄存器通过其中的位的值去控制发送控制器和接收控制器。
然后是发送控制器：观察图片可以发现这个发送控制器的作用受到定时器T1和SCON的控制，其作用是将发送SBUF中的并行数据转换为串行数据然后发送出去的，在这个过程中，还会自动添加起始位，校验位，停止位，发送结束后将SCON中的中断标志位TI标记为1，表示发送完毕
然后是接收控制器：与发送控制器相反，是将接收到的串行数据转换为并行数据然后发送到接收SBUF中，在这个过程中会自动取消起始位，校验位，停止位，接收结束后将SCON中的中断标志位RI标记为1，表示接收完毕
最后是定时计数器T1：定时计数器T1的作用产生用以收发过程中节拍控制的通信时钟（方波脉冲），实际上就是作为一把尺，假如有三个1到来的话，那么T1一定会发出三个方波，这样一来就可以判断了。
可以看出发送端只有一个寄存器SBUF，但是接收端有两个寄存器，这样做的好处是：当接收数据时，接收数据进入SBUF后，接收端还可以通过接收移位寄存器接收下一帧数据。这种双缓冲的结构可以避免在第二帧数据到来时，未将第一帧数据读走而引起的两帧数据重叠覆盖的错误。
SCON串行口控制寄存器 需要知道的有以下内容：
TI、RI：串行口中断请求信号，当接收完毕或者发送完毕时，对应位置就会置1，需要软件置0SM0 和 SM1：串行工作方式定义位，具体内容在后文。RB8 和 TB8：用于接收数据的第9位和发送数据的第9位，用于多机通信和奇偶校验SM2 ：多级通信控制位REN ：允许接收控制位，用于允许或禁止串行口接收数据 串行口工作方式 SM0SM1方式功能说明0008位同步移位寄存器方式01110位数据异步通讯方式10211位数据异步通信方式11311位数据异步通讯方式 上述4种工作方式种，只有后三种才属于严格意义上的异步通信，方式0属于同步移位寄存器方式，主要用于串并转换。
PCON电源控制寄存器 根据芯片手册，PCON内容如下：
我们只需要关注SMOD位即可：当SMOD = 1时（软件置位），使得串行通信方式1、2、3的波特率加倍。当SMOD = 0，各工作方式的波特率正常。复位时SMOD = 0。
SMOD0是帧错误检测有效控制位，详细内容不做介绍（因为用不上）。
通信时钟波特率的计算方式：
通信时钟波特率 = f O S C 12 ∗ ( 2 n − a ) ⋅ 2 S M O D 32 通信时钟波特率 = \frac {f_{OSC}} {12 * (2^{n} - a)} \cdot \frac {2^{SMOD}} {32} 通信时钟波特率=12∗(2n−a)fOSC​​⋅322SMOD​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d714b3de92215c5fe099158c4d896ca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6318eb165bceddcae4c275d5caf2992/" rel="bookmark">
			2024 Midjourney 基础教程（⼆）：了解 Midjourney Bot 和AI绘画使用技巧进阶教学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上⼀篇⽂章中，我们学到了如何注册 Midjourney ，开通付费订阅，并画出了可能是⾃⼰的第⼀张 AI绘画。怎么样？这种将想象的画⾯，变为现实世界图⽚的感觉。
是否有种造物者的错觉，同时有种开盲盒的惊喜感？那这篇⽂章，带⼤家更进⼀步深⼊了解 Midjourney 的 Discord 服务器。教⼤家如何将 Midjourney Bot 邀请到⾃⼰的 Discord 服务器；并介绍⼀些常⻅常⽤的 Midjourney Bot 指令。
教程专区：AI绘画，AI视频，AI写作等软件类型AI教程，
更多作品：长期更新国内外，中英文AI人工智能作品
⼀、Midjourney 服务器介绍
1. Discord 软件介绍
上⼀篇⽂章也提到过了，Midjourney AI 绘画服务基于 Discord 软件的，它的绘画功能，都是通过Midjourney Bot 机器⼈来实现。如果要深⼊了解 Midjourney 的 Discord 服务器，必须先对 Discord 有⼀定的认识。Discord 是⼀个聊天社交程序，初衷是为了游戏社区、游戏交流来设计的，产品形式上看，像是国内的 YY 语⾳，不知道⼤家有没有⽤过。以前玩魔兽世界打团的时候经常⽤到。⼤家对微信更熟悉，我们还是拿微信来类⽐。
Discord 的服务器，有点像企业微信，要⽤⼀定的资质来注册，不同企业注册的企业微信，数据是不互通的。如果没有加⼊这个企业微信，是看不到企业微信内的成员、群聊和内容。Discord 的频道，就像企微的群聊，加⼊企微，并加⼊群聊后，可以在聊天区⾃由聊天。这⾥ Discord有个特别的功能，企业微信业有，但在微信上是⾮法的（官⽅没有提供接⼝），那就是⸺聊天机器⼈。
机器⼈可以结合平台提供的⼀些服务器、频道、成员、聊天内容的管理接⼝，通过和⽤⼾聊天，来实现产品的功能。Midjourney Bot 就是这样的⼀种实现。因为我们有⼤部分的球友，⾮技术出⾝，关于机器⼈的实现，就不聊更具体的细节了，⼤家感兴趣可以⾃⼰去搜集相关资料来了解。Discord 频道，还有个值的注意的设计，它的频道分为⽂字频道、语⾳频道。除过普通频道之外，服务器中，还可以发布公告、创建活动。
2. Midjourney 服务器
了解了以上关于 Discord 的概念，我们可以来研究下 Midjourney 服务器的构成了。
打开 Discord ，进⼊ Midjourney ⾸⻚。
可以看到，整个服务器主⻚，分为了3个区域：
频道列表。房⼦图标开头是主⻚；⽇历图标的是活动；喇叭图标的是公告；#图标是频道；箭头图标是频道分类。
内容展⽰&amp;聊天区。服务器信息展⽰、频道活动、和活动预约。进⼊到频道中，这个区域还⽤来展⽰频道的⽤⼾列表。
1. Midjourney 频道
新⼈进⼊到 Midjourney 服务器之后，需要掌握的信息，或者更准确的说应该是频道。主要有 newbies、general；show-case 分类；recent-changes、rules、support。newbies 、general 开头的频道，都是专⻔⽤来 AI 绘画的。在这些频道中，可以看到其他⼈ AI 绘画的过程，包括他们的提⽰词以及对应⽣成的画作。也可以在聊天区域，输⼊指令，和 Midjourney Bot 来交互、绘画。newbies 、general 两者的区别，前者是新⼈频道新⼿村，后者是专业绘画频道。⾄于两频道中绘画的质量，在我看来，区别不⼤，不⽤特别在意。show-case 是⼏个频道集合的名称，show-case 下⾯的⼏个频道，可以看到不同分类的优质画作分享。⽐如说 blend-showcase 频道，就展⽰了很多的使⽤ blend 指令⽣成的图⽚，这个指令可以将不同的图⽚混合在⼀起。 recent-changes、rules、support，这些是属于⽇常需要偶尔关注的频道，按顺序依次是更新⽇志、使⽤规则、客⼾服务等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6318eb165bceddcae4c275d5caf2992/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d20e245693f8a792578d114934e0406/" rel="bookmark">
			抖音字幕视频怎么做能滚动 抖音个性字幕怎么做 抖音短视频用什么软件剪辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不管是抖音短视频，还是其他影视网站的影视剧，字幕基本都是必不可少的，字幕本身就能加强观众对视频的理解，而且像一些滚动字幕，会更加吸引观众的注意力，那抖音字幕视频怎么做能滚动？抖音个性字幕怎么做？本文将详细说明。
一、抖音字幕视频怎么做能滚动
以会声会影这款视频剪辑软件为例，抖音字幕视频滚动教程如下：
1、打开会声会影，点击“编辑——导入媒体文件”，选中视频素材，点击“打开”等待素材导入。
2、将视频素材拖拽到视频轨上，如果视频素材有多余部分，可以将滑轨移至多余素材处，按下“s”键进行切割，并鼠标右键删除。
将抖音视频多余素材删除后，点击“字幕编辑器”打开字幕编辑窗口。
将左方的滑轨移至要添加字幕的地方，点击“+”按钮，并双击“添加新字幕”，将字幕内容输入进去，点击“确定”即可。
3、双击标题轨上的文字，点击“运动——应用——飞行”，选择最后一个效果，再将“起始单位”和“终止单位”改为“行”，“暂停”时间选择“中等”即可。
4、最后点击“共享——mpeg4——开始”，等待视频渲染输出，就能得到如下效果图。
5、要是大家不需要视频画面，只需要纯字幕滚动，可以点击“禁用视频轨”，这样视频就只会显示字幕了。
接着再双击标题轨上的素材，调整字幕大小、位置、运动轨迹即可。
会声会影正版软件安装包：会声会影2023旗舰版（免费试用）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0fdf39863553007e4a8ebe0154d4e60/" rel="bookmark">
			shell 计算两个数据百分比，bc高级运算，bc计算系统磁盘剩余内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 安装运算工具 bc使用方法高级数学库 (直接把公式 给他即可)计算百分比计算内存已经使用的百分比计算圆周率 安装运算工具 bc yum -y install bc 使用方法 echo $((10/3)) | bc 高级数学库 (直接把公式 给他即可) echo $((2+4)) | bc -l 计算百分比 这里是 bc 的用法 也是计算了一个 66 /100 的百分比
## scale=2 小数点后两位数 a=$( echo "scale=2; (66 / 100) * 100" | bc -l );echo $a\% a=$(bc -l &lt;&lt;&lt; "scale=2; (66 / 100) * 100");echo $a\% # 把计算公式交给bc 去执行 计算内存已经使用的百分比 # 获取已使 used_disk=$(df -T | grep "/dev/mapper/centos-root" | awk '{print $3}') # 获取未使 all_disk=$(df -T | grep "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0fdf39863553007e4a8ebe0154d4e60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/150a6f9ae288837d02d144181e797b3c/" rel="bookmark">
			ABC208(A-C)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 A #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int a,m; cin&gt;&gt;a&gt;&gt;m; if(m&lt;=a*6&amp;&amp;m&gt;=a)cout&lt;&lt;"Yes"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; return 0; } B #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; ll f(ll j){ ll ans=1; for(int i=1;i&lt;=j;i++){ ans*=i; } return ans; } int main() { ll p; cin&gt;&gt;p; ll ans=0; ll i=10; while(p!=0){ if(f(i)&gt;p)i--; else if(f(i)&lt;=p){ p-=f(i); ans++; } } cout&lt;&lt;ans&lt;&lt;endl; } C #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { ll n,k; cin&gt;&gt;n&gt;&gt;k; ll k2=k%n; ll num0=k/n; ll num[n]; ll ans[n]; for(ll i=0;i&lt;n;i++){ cin&gt;&gt;num[i]; ans[i]=num[i]; } sort(num,num+n); int add=0; ll key=num[k2-1]; if(k2&gt;0)add++; for(ll i=0;i&lt;n;i++){ if(ans[i]&lt;=key)cout&lt;&lt;num0+add&lt;&lt;endl; else cout&lt;&lt;num0&lt;&lt;endl; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb1a2eabfd0207bcfa8503b78903e67/" rel="bookmark">
			案例098:基于微信小程序的电子购物系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
管理员功能实现
订单评价管理
商品信息管理
已完成订单
用户管理
用户功能实现
商品信息
购物车
下单支付
我的订单
在线客服
我的收藏管理
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 由于APP软件在开发以及运营上面所需成本较高，而用户手机需要安装各种APP软件，因此占用用户过多的手机存储空间，导致用户手机运行缓慢，体验度比较差，进而导致用户会卸载非必要的APP，倒逼管理者必须改变运营策略。随着微信小程序的出现，解决了用户非独立APP不可访问内容的痛点，所以很多APP软件都转向微信小程序。本次课题就运用了微信小程序技术开发一个基于微信小程序的电子购物系统。
基于微信小程序的电子购物系统是在MySQL中建立数据表保存信息，运用微信开发者工具开发。并按照软件设计开发流程进行设计实现。系统具备友好性且功能完善。管理员管理不同状态的订单，管理商品和用户，审核订单评价。用户收藏商品，订购商品，管理个人订单，联系客服，在线充值。
总之，基于微信小程序的电子购物系统可以更加方便用户在线查看商品，购买所需商品，管理个人购买订单。
系统展示 管理员功能实现 订单评价管理 管理员权限中的订单评价管理，其运行效果见下图。管理员需要审核订单评价，提交订单编号获取相应的订单评价。
商品信息管理 管理员权限中的商品信息管理，其运行效果见下图。管理员发布商品，修改商品价格，图片以及规格等信息，删除数据异常的商品。
已完成订单 管理员权限中的已完成订单，其运行效果见下图。管理员查看已完成订单，查询已完成订单。
用户管理 管理员权限中的用户管理，其运行效果见下图。管理员可以在本页面修改，删除用户资料。
用户功能实现 商品信息 用户权限中的商品信息，其运行效果见下图。用户在本页面可以收藏商品，可以订购商品，或把本页面的商品加入购物车。
购物车 用户权限中的购物车，其运行效果见下图。购物车保存了用户需要购买的商品，用户通过本功能可以对多种商品一起下单。
下单支付 用户权限中的下单支付，其运行效果见下图。用户在当前页面确认收货地址，确认购买的商品信息，最后进行支付。
我的订单 用户权限中的我的订单，其运行效果见下图。用户管理不同状态的订单，可以取消已支付的订单。
在线客服 用户权限中的在线客服，其运行效果见下图。用户有疑问可以咨询客服。
我的收藏管理 用户权限中的我的收藏管理，其运行效果见下图。用户查询收藏的商品，删除已经收藏的商品。
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcb1a2eabfd0207bcfa8503b78903e67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4297c2d6df67b55f6f9630c8315aaf1/" rel="bookmark">
			三英战吕布web3游戏项目启动全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目是一个学习相关的很好的例子并且开源，原本的项目是连接goerli网络，但我把它修改为可连接ganache网络的项目了，更方便启动。
智能合约部分
进入文件 `hardhat.config.js` ，增加一个钱包私钥
2.执行npm install
3.测试合约 npx hardhat test
4.部署到 ganache 测试网络
npx hardhat run scripts/deploy.js --network ganache
前端运行，进入到前端目录 cd game
1.安装依赖 yarn install
2.编辑文件 `.env`，把部署的合约地址填入。
3.修改index.js当中的相关文件
3.启动前端 yarn serve
需要源码私信我
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaedfe65e78cdf6f1b44586811f553d5/" rel="bookmark">
			I.MX6ULL开发笔记（二）——硬件外设操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 点亮第一个RGB灯 在文章http://t.csdnimg.cn/EGWt9中有介绍Linux下文件目录，那么在Linux系统下，RGB灯也是一个设备，所以我们需要到/sys目录下去操作这个设备。
之后，我们进入到class目录，这里挂载着开发板上的外设：
在这里就能看到熟悉的硬件接口了，那么我们进入到leds的目录下：
可以看到里面有红绿蓝三个文件，这也就是操作对应gpio的接口，那么我们可以进去看对应的文件夹：
那么我们可以这么去控制蓝灯的亮度，0~255代表灯光的亮度：
sudo echo 255 &gt; /sys/class/leds/blue/brightness 之后就可以看到版上灯光亮起：
若想关闭可以设置如下：sudo echo 0 &gt; /sys/class/leds/blue/brightness
其他颜色灯光打开也如上所示。
0x02 使用shell操控硬件 在这之前，我们需要安装一个脚本文件，使用命令sudo apt update进行软件源的刷新。并且下载vim编辑器，sudo apt-get install vim。对于更新太慢的，可以使用命令：
sudo vi /etc/apt/sources.list 屏蔽后面这两句即可。这里用的是国外的软件源。之后安装我们的脚本文件preipheral：
sudo apt install peripheral 这是野火自己构建的deb包。
之后就可以看到了我们所安装的脚本文件了：
那么执行这些脚本文件，就可以操作对应的硬件外设了，但是在这之前，我们需要在fire-config下将这些外设进行使能。
在这个目录下的：
如果之前没有禁止过任何模块，这些模块都是默认开启的，可以不用管他，后面标记着enable。
之后我们尝试执行一下led的脚本：sudo ./led.sh
这是一个闪灯程序。接下来测试按键功能，使用evtest的软件包，之后执行input.sh的脚本，在这能识别到这三个按钮：
注意不能长按，这个是强制开关机的。接下来玩玩蜂鸣器：
这里就放不了声音了，可以自己动手体验。其他脚本也是一样的执行方式，使用adc可以拧一下变阻器来观察，使用mpu的话可以动动开发板观察情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3201375f595021dc0a903daf8e5ea701/" rel="bookmark">
			I.MX6ULL开发笔记（三）——挂载NFS网络文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 网络文件系统 当我们在编译一个文件时，正常是在一个pc上编译好一个文件，之后丢到开发板上去运行。如果有了NFS网络文件系统，那么我们就可以在PC以及开发板上共享文件了。
网络文件系统，常被称为NFS（Network File System），它是一种非常便捷的在服务器与客户端通过网络共享文件的方式，具体见下图。
开启了NFS服务后，客户端访问服务器共享的文件时如同访问本 地存储器（磁盘/SD卡/NAND FLASH等）上的文件一样，对于上层应用来说没有 任何差别，在嵌入式开发时，我们常常利用这个特性在主机上共享文件，主要应用场景如下：
在NFS服务器上编译应用软件，客户端（开发板）通过NFS访问并运行应用程序进行测试。把NFS作为根文件系统来启动 配置Linux 系统之间的文档共享（Linux 和Windows 间的文档共享需采用SAMBA 服务）；NFS 只是一种文档系统，本身没有传输功能，是基于RPC 协议实现的，才能达到两个Linux 系统之间的文档目录共享；NFS 为C/S（客户机/服务器） 架构； 安装NFS服务器： sudo apt update sudo apt install nfs-kernel-server -y 配置NFS服务器 打开配置文件 sudo vim /etc/exports 创建用于共享的文件夹 sudo mkdir -p /home/zhengxiting/workdir 添加配置信息 /home/zhengxiting/workdir *(rw,sync,no_root_squash) -/home/zhengxiting/workdir 指定分享文件名 - * 所有网段都可写 - rw 读写权限 - sync 资料同步写入到内存与硬盘中 - no_root_squash 用户具有挂载目录的全部操作权限 更新exports配置 sudo exportfs -arv 查看NFS共享情况 showmount -e 对于WSL系统，他是没有办法直接实现NFS的，他并不是一个完整的Linux系统。若要在WSL中实现这个服务，需要这么构建环境，会出现这样的报错：
root@Cx330:/home/zhengxiting# showmount -e
clnt_create: RPC: Timed out
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3201375f595021dc0a903daf8e5ea701/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36fdc1d998c549d99f8508ae2c1a42c3/" rel="bookmark">
			案例096:基于微信小程序的社区团购系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
管理员服务端功能模块
商家服务端功能模块
会员客户端功能模块
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 社会的发展和科学技术的进步，互联网技术越来越受欢迎。手机也逐渐受到广大人民群众的喜爱，也逐渐进入了每个会员的使用。手机具有便利性，速度快，效率高，成本低等优点。 因此，构建符合自己要求的操作系统是非常有意义的。
本文从管理员、商家、会员的功能要求出发，社区团购系统中的功能模块主要是实现管理员服务端；首页、个人中心、会员管理、商家管理、商品信息管理、商品分类管理、购买订单管理、退货退款管理、商品评价管理、系统管理，商家服务端：首页、个人中心、商品信息管理、购买订单管理、退货退款管理、商品评价管理；会员客户端：首页、商品信息、我的（会员信息、商品信息、购买订单、退货退款、商品评价、用户充值、购物车、我的订单）。
本人经过认真细致的研究，精心准备和规划，最后测试成功，系统可以正常使用。分析功能调整与社区团购系统实现的实际需求相结合，讨论了微信开发者技术与后台结合java语言和mysql数据库开发社区团购系统的使用。
系统展示 管理员服务端功能模块 管理员通过点击后台管理，进入页面可以输入用户名、密码、角色进行登录相对应操作
管理员通过点击后台管理，进入页面可以查看首页、个人中心、会员管理、商家管理、商品信息管理、商品分类管理、购买订单管理、退货退款管理、商品评价管理、系统管理等功能模块，进行相对应操作
会员管理：管理员通过会员管理可以查看会员账号、会员姓名、手机、邮箱、身份证、头像、积分等并进行详情、删除、修改操作
商家管理：管理员通过列表可以查看商家账号、密码、姓名、手机、邮箱、身份证、商铺名称、商铺图片、商铺地址、经营范围、积分等信息，管理员审核商家后才能登陆，并进行详情、删除、修改操作
商品信息管理：管理员通过商品信息管理可以查看商家账号、商铺名称、商商品原价、商品现价、团购最低人数、商品折扣、团购开始时间、团购结束时间、可提货点、积分、价格、积分等信息并进行详情、删除、修改操作
退货退款管理：管理员通过退货退款管理列表可以并进行审核、回复查看详情、删除操作
系统管理；该页面为轮播图管理界面。管理员可以在此页面进行首页轮播图的管理，通过新建操作可在轮播图中加入新的图片，还可以对以上传的图片进行修改操作，以及图片的删除操作
商家服务端功能模块 商家注册、登录，商家在注册页面填写商家姓名、密码、姓名、手机、邮箱、身份证、商铺名称、商铺图片、商铺地址、经营范围进行注册，登陆填写商家账号、密码，商家需要登陆必须经过管理员审核
首页，商家登录到首页可以查看首页、个人中心、商品信息管理、购买订单管理、退货退款管理、商品评价管理等内容 商品信息，商家在商品信息页面可以查看商家账号、商铺名称、商商品原价、商品现价、团购最低人数、商品折扣、团购开始时间、团购结束时间、可提货点、积分、价格等信息，可进行添加、修改、删除操作
购买订单管理，商家在购买订单管理页面可以查看订单编号、商品名称、商品图片、商品现价、购买时间、团购人数、会员账号、会员姓名、手机、地址，可进行查看会员支付状况，进行详情查看操作
商品评价管理，商家在商品评价可以进行信息回复操作
会员客户端功能模块 会员注册、登录，用户在注册页面填写会员账号、密码、会员姓名、手机、邮箱、身份证、、进行注册，信息无误进行登陆
首页，会员登录到首页可以查看首页、商品信息、我的等内容 商品信息，会员在商品信息页面可以查看、加入购物车、立即订购、积分兑换等操作 我的，会员在我的页面可以查看会员信息、商品信息、购买订单、退货退款、商品评价、用户充值、购物车、我的订单等信息 会员信息，会员在个人信息可以查看会员账号、会员姓名、手机、邮箱、身份证、头像、积分等信息，可进行添加、修改、删除操作 代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36fdc1d998c549d99f8508ae2c1a42c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efd3bc7d8badf2c2f3b5a409108f40ae/" rel="bookmark">
			解决“SQLServer 添加数据库,报Error 5118“错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当将把一个SQLServer的数据库文件*.MDF和日志文件*.LDF，从电脑A拷贝到电脑B，然后在电脑B上，使用Microsoft SQL Server Management Studio添加该*.MDF文件，有时报"Error 5118"错误，如图(1)所示：
图(1) 添加SQLServer数据库时，报"Error 5118"错误 出现这种问题的原因：当前文件采用压缩格式保存，需要取消这种压缩格式；
解决方法：右击该数据*.MDF文件 --》属性 --》高级 --》去掉"压缩"–》应用 --》OK
同理，右击该日志*.LDF文件–》属性 --》高级 --》去掉"压缩"–》应用 --》OK；
如图(2)、图(3)、图(4)、图(5)所示：
图(2) 右击Hello_Data.MDF --》属性 图(3) 在【高级】里，取消"压缩"前面的对钩√ 图(4) 同理，右击*.LDF文件，也取消"压缩"选项 图(5) 点击【继续】即可，修改成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf3538a45d2339eb999293386fcdc91c/" rel="bookmark">
			Vue组件封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组件封装 一个封装好的组件可以在项目的任意地方使用，甚至我们可以直接从npm仓库下载别人封装好的组件来进行使用，比如iview、element-ui这一类的组件库。但是每个公司的需求是不一样的，我们可以封装自己的组件库并发布到npm上去，这样可以不用碰到相似的项目就复制一大串代码了，简洁明了，要用的时候可以直接从npm安装使用。废话不多说，下面开始介绍步骤。
（1） 新建package文件夹 因为我们可能会封装多个组件，所以在src下面新建一个package文件夹用来存放所有需要上传的组件。
（2）在pwd/index.vue中编写好代码 &lt;template&gt; &lt;div&gt; &lt;el-form ref="Form" :label-width="labelWidth" label-position="right" :model="form" :rules="comValidateFlag ? modifyRules : loginRules" :size="comSize" :disabled="comPasswordDisabled" &gt; &lt;el-form-item :label="comLabel" prop="password"&gt; &lt;el-input v-model="form.password" :show-password="showPasswordFlag" :placeholder="placeholderText" maxlength="16" autocomplete="new-password"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'MyPwd', prop: { comPasswordDisabled: { type: Boolean, default: false }, showPasswordFlag: { type: Boolean, default: false }, placeholderText: { type: Boolean, default: false }, labelWidth: { type: String, default: '120px' } }, computed: { comValidateFlag: { get() { } } }, data() { const validatePwd = (rule, value, callback)=&gt;{ } return { password: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf3538a45d2339eb999293386fcdc91c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2f1ab139d877582554fa5339277ca13/" rel="bookmark">
			PyTorch|构建自己的卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何搭建网络，这在深度学习中非常重要。简单来讲，我们是要实现一个类，这个类中有属性和方法，能够进行计算。
一般来讲，使用PyTorch创建神经网络需要三步：
继承基类：nn.Module
定义层属性
实现前向传播方法
如果你对于python面向对象编程非常熟练，那么这里也就非常简单，就是定义一些属性，实现一些方法。
开始建立一个网络，就像这样：
import torchimport torch.nn as nnimport torch.nn.functional as Fclass Network(nn.Module): def __init__(self): super(Network, self).__init__() self.conv1 = nn.Conv2d(in_channels=1, out_channels=6, kernel_size=5) self.conv2 = nn.Conv2d(in_channels=6, out_channels=12, kernel_size=5) self.fc1 = nn.Linear(in_features=12*4*4, out_features=120) self.fc2 = nn.Linear(in_features=120,out_features=60) self.out = nn.Linear(in_features=60, out_features=10) def forward(self,t): # (1) input layer t = t # (2) hidden conv layer1 t = self.conv1(t) t = F.relu(t) t = F.max_pool2d(t, kernel_size=2, stride=2) # (3) hidden conv layer2 t = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2f1ab139d877582554fa5339277ca13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd548ad6414142b47c7b13c8f59a2239/" rel="bookmark">
			【数据分享】2023年我国省市县三级的商务住宅数量（4类设施/Excel/Shp格式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产业园区、住宅区、楼宇等商务住宅的数量是一个城市基础设施完善程度的重要体现，一个城市商务住宅的种类越丰富，数量越多，通常能表示这个城市的城市化水平越高！
本次我们为大家带来的是我国各省份、各地级市、各区县三个层级的商务住宅数量数据！包括4类常见商务住宅的数量，具体为：产业园区、住宅区、商务住宅相关、楼宇。
该数据是基于2023年6月份全国范围的高德地图POI数据，通过统计各省份（地级市和区县同理）的上述4类设施的数量得到的。数据包括Excel和shp两种格式；数据坐标为WGS1984坐标。
大家可以在公众号回复关键词 099 按照转发要求获取该数据，以下为数据的详细介绍：
01 数据预览
该数据包括省份、地级市、区县三个行政层级的数据，每个层级包括Excel和Shp两种格式！下面我们依次来预览一下：
1.各省份商务住宅数量
我们先来看一下Shp格式的数据，34个省份的4类商务住宅数量汇总在一个Shp文件中，数据字段主要包括省份名称（province）、省代码（province_c）、省份类型（province_t）、各类商务住宅数量、数据说明。
各省商务住宅数量属性表 我们以各省楼宇数量为例来预览一下：
各省楼宇数量（Shp格式） 我们再来看一下Excel格式的数据，数据字段的具体属性与Shp格式相同，34个省份的商务住宅数量同样汇总为一个Excel文件。
各省商务住宅数量（Excel格式） 2.各地级市商务住宅数量
我们先来看一下Shp格式的数据，371个城市的4类商务住宅数量汇总在一个Shp文件中，数据字段主要包括省份名称（province）、省代码（province_c）、省份类型（province_t）、城市名称（city）、城市代码（city_code)、城市类型（city_type)、各类商务住宅数量、数据说明。
我们以各市住宅区数量为例来预览一下：
各市住宅区数量（Shp格式） 我们再来看一下Excel格式的数据，数据字段的具体属性与Shp格式相同，371个城市的商务住宅数量同样汇总为一个Excel文件。
各市商务住宅数量（Excel格式） 3.各区县商务住宅数量
我们先来看一下Shp格式的数据，2877个区县的4类商务住宅数量汇总在一个Shp文件中，数据字段主要包括省份名称（province）、省代码（province_c）、省份类型（province_t）、城市名称（city）、城市代码（city_code)、城市类型（city_type)、区县名称（country）、区县代码（country_co）、区县类型（country_ty）、各类商务住宅数量、数据说明。
各区县商务住宅数量属性表 我们以各区县保险公司数量为例来预览一下：
各区县保险公司数量（Shp格式） 我们再来看一下Excel格式的数据，数据字段的具体属性与Shp格式相同，2877个区县的商务住宅数量同样汇总为一个Excel文件。
各区县商务住宅数量（Excel格式） 02 数据详情
统计时间：
2023年6月
统计口径：
各省/各市/各区县
数据格式：
Shp和Excel
地理坐标系：
GCS_WGS_1984
数据说明：
采用不同方式获取的POI数量可能会有不同，因此本数据只可用于练习，不得商用！
文末下方是我们的公众号”立方数据学社”的名片，我们将定期介绍各类城市数据以及数据的可视化和分析技术，有关2023年我国省市县三级的商务住宅数量，欢迎大家多多关注我们进行了解！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e2f3309f2f948d954d2e4f94fbe493/" rel="bookmark">
			大创项目推荐 深度学习图像分类算法研究与实现 - 卷积神经网络图像分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 常用的分类网络介绍1.1 CNN1.2 VGG1.3 GoogleNet 2 图像分类部分代码实现2.1 环境依赖2.2 需要导入的包2.3 参数设置(路径，图像尺寸，数据集分割比例)2.4 从preprocessedFolder读取图片并返回numpy格式(便于在神经网络中训练)2.5 数据预处理2.6 训练分类模型2.7 模型训练效果2.8 模型性能评估 3 1000种图像分类4 最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 深度学习图像分类算法研究与实现 - 卷积神经网络图像分类
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：4分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 常用的分类网络介绍 1.1 CNN 传统CNN包含卷积层、全连接层等组件，并采用softmax多类别分类器和多类交叉熵损失函数。如下图：
卷积层(convolution layer): 执行卷积操作提取底层到高层的特征，发掘出图片局部关联性质和空间不变性质。
池化层(pooling layer): 执行降采样操作。通过取卷积输出特征图中局部区块的最大值(max-pooling)或者均值(avg-pooling)。降采样也是图像处理中常见的一种操作，可以过滤掉一些不重要的高频信息。
全连接层(fully-connected layer，或者fc layer): 输入层到隐藏层的神经元是全部连接的。
非线性变化: 卷积层、全连接层后面一般都会接非线性变化层，例如Sigmoid、Tanh、ReLu等来增强网络的表达能力，在CNN里最常使用的为ReLu激活函数。
Dropout : 在模型训练阶段随机让一些隐层节点权重不工作，提高网络的泛化能力，一定程度上防止过拟合
在CNN的训练过程总，由于每一层的参数都是不断更新的，会导致下一次输入分布发生变化，这样就需要在训练过程中花费时间去设计参数。在后续提出的BN算法中，由于每一层都做了归一化处理，使得每一层的分布相对稳定，而且实验证明该算法加速了模型的收敛过程，所以被广泛应用到较深的模型
1.2 VGG VGG 模型是由牛津大学提出的（19层网络），该模型的特点是加宽加深了网络结构，核心是五组卷积操作，每两组之间做Max-
Pooling空间降维。同一组内采用多次连续的3X3卷积，卷积核的数目由较浅组的64增多到最深组的512，同一组内的卷积核数目是一样的。卷积之后接两层全连接层，之后是分类层。该模型由于每组内卷积层的不同主要分为
11、13、16、19 这几种模型
增加网络深度和宽度，也就意味着巨量的参数,而巨量参数容易产生过拟合，也会大大增加计算量。
1.3 GoogleNet GoogleNet模型由多组Inception模块组成，模型设计借鉴了NIN的一些思想.
NIN模型特点：
1. 引入了多层感知卷积网络(Multi-Layer Perceptron Convolution, MLPconv)代替一层线性卷积网络。MLPconv是一个微小的多层卷积网络，即在线性卷积后面增加若干层1x1的卷积，这样可以提取出高度非线性特征。 2)设计最后一层卷积层包含类别维度大小的特征图，然后采用全局均值池化(Avg-Pooling)替代全连接层，得到类别维度大小的向量，再进行分类。这种替代全连接层的方式有利于减少参数。 Inception 结构的主要思路是怎样用密集成分来近似最优的局部稀疏结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2e2f3309f2f948d954d2e4f94fbe493/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d8065920525254785fa6586a14e059/" rel="bookmark">
			Vagrant安装虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vagrant安装虚拟机 优点：操作简单方便
vagrant仓库提供已配置完成镜像系统，只需简单命令可迅速初始化运行虚拟机
一、安装virtualBox 官方网站：Oracle VM VirtualBox
如果虚拟机安装失败，可能计算机未开启CPU虚拟化
二、安装Vagrant Vagrant官方镜像仓库：Discover Vagrant Boxes - Vagrant Cloud (vagrantup.com)
Vagrant软件下载：Install | Vagrant | HashiCorp Developer
AMD64即对应x86平台
三、运行虚拟机 启动virtualBox
打开windows cmd窗口，运行如下命令，初始化centos7系统，系统名称可通过第二步中官方镜像仓库查看
Vagrant init centos/7 运行如下命令启动虚拟机，系统root用户密码是vagrant
vagrant up 启动成功后，virtualBox界面会出现对应虚拟机
四、vagrant其他常用命令 自动使用vagrant用户连接虚拟机
vagrant ssh 上传文件
vagrant upload source [destination] [name|id] 重启
vagrant reload Vagrant命令行：vagrant init - Command-Line Interface | Vagrant | HashiCorp Developer
五、配置虚拟机固定ip 默认虚拟机的ip地址不是固定ip，开发不方便
修改Vagrantfile
config.vm.network "private_network",ip:"192.168.56.10" 这里的ip需要在物理机下使用ipconfig命令找到
ipconfig /all 重新加载vagrantfile文件
vagrant reload # 重启 vagrant ssh # 登录 登录后查看ip地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13d8065920525254785fa6586a14e059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba73ee6cb51c4a44abc4c67487baa36b/" rel="bookmark">
			解决SQLServer访问*.mdf文件“报Unable open file Error5120“问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天，在使用Microsoft SQL Server Management Studio附加Hello_Data.MDF数据库时，弹出“Unable to open the physical file *.MDF system error 5 Error:5120”错误，如图(1)所示：
图(1) 添加Hello_Data.MDF数据库，报"Unable open file 5120"错误 出现该问题的原因：当前用户对Hello_Data.MDF、Hello_Data.LDF没有读写权限。
解决方法：右击Hello_Data.MDF文件 --》属性 --》安全 --》选中Users–》编辑 --》再次选中Users --》勾选 √ “完全控制” --》点击【应用】按钮 --》再点击【确定】；
选中Authenticated Users–》编辑 --》再次选中Authenticated Users --》勾选 √ “完全控制” --》点击【应用】按钮 --》再点击【确定】；如图(2)、图(3)、图(4)所示：
图(2) 右击Hello_Data.MDF --》属性 图(3) 在【安全】页，赋予Users以"完全控制"权限 图(4) 选中Authenticacted Users，勾选"完全控制" --》应用 同理，右击Hello_Data.LDF文件–》属性 --》安全 --》选中Users–》编辑 --》再次选中Users --》勾选 √ “完全控制” --》点击【应用】按钮 --》再点击【确定】；
选中Authenticated Users–》编辑 --》再次选中Authenticated Users --》勾选 √ “完全控制” --》点击【应用】按钮 --》再点击【确定】；如图(5)所示：
图(5) 右击*.LDF，在【安全】页，也开放对Users和AuthenticatedUser的读取权限 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fd8aa8238a0732aa8f9f11eb5ee8c1c/" rel="bookmark">
			微信小程序——调节手机屏幕亮度案例分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：2022年博客新星 第八。热爱国学的Java后端开发者，修心和技术同步精进。
🍎个人主页：Java Fans的博客
🍊个人信条：不迁怒，不贰过。小知识，大智慧。
💞当前专栏：前端案例分享专栏
✨特色专栏：国学周更-心性养成之路
🥭本文内容：微信小程序——调节手机屏幕亮度案例分享
文章目录 1、知识小结2、案例分享 1、知识小结 使用 wx.setScreenBrightness(Object object) 方法设置手机屏幕亮度；
使用 wx.getScreenBrightness(Object object) 方法获取手机屏幕亮度；
2、案例分享 首先，在小程序的json配置文件中添加以下权限：
{ "permission": { "scope.userBrightness": { "desc": "用于调节屏幕亮度" } } } 接下来，在wxml文件中添加一个滑动条和一个按钮，并绑定相应的事件：
&lt;view class="container"&gt; &lt;slider class="slider" bindchange="changeBrightness" min="0" max="100" step="1" value="{{brightness}}" show-value="{{true}}"&gt;&lt;/slider&gt; &lt;button class="button" bindtap="setBrightness"&gt;设置亮度&lt;/button&gt; &lt;/view&gt; 然后，在对应的js文件中编写以下代码：
Page({ data: { brightness: 50, // 初始亮度为50 isSupported: false // 是否支持调节亮度 }, onLoad: function () { // 检查是否支持调节亮度 wx.getSystemInfo({ success: (res) =&gt; { if (res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fd8aa8238a0732aa8f9f11eb5ee8c1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d4ca4ddd99cb1841813afe3bc6b8e5a/" rel="bookmark">
			第28关 k8s监控实战之Prometheus(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		------&gt; 课程视频同步分享在今日头条和B站
大家好，我是博哥爱运维。这节课我们继续prometheus相关的内容。
访问prometheus后台，点击上方菜单栏Status — Targets ，我们发现kube-controller-manager和kube-scheduler未发现
接下来我们解决下这一个碰到的问题吧
# 这里我们发现这两服务监听的IP是0.0.0.0 正常 # ss -tlnp|egrep 'controller|schedule' LISTEN 0 32768 *:10257 *:* users:(("kube-controller",pid=3528,fd=3)) LISTEN 0 32768 *:10259 *:* users:(("kube-scheduler",pid=837,fd=3)) 然后因为K8s的这两上核心组件我们是以二进制形式部署的，为了能让K8s上的prometheus能发现，我们需要来创建相应的service和endpoints来将其关联起来
注意：我们需要将endpoints里面的NODE IP换成我们实际情况的
apiVersion: v1 kind: Service metadata: namespace: kube-system name: kube-controller-manager labels: app.kubernetes.io/name: kube-controller-manager spec: type: ClusterIP clusterIP: None ports: - name: https-metrics port: 10257 targetPort: 10257 protocol: TCP --- apiVersion: v1 kind: Endpoints metadata: labels: app.kubernetes.io/name: kube-controller-manager name: kube-controller-manager namespace: kube-system subsets: - addresses: - ip: 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d4ca4ddd99cb1841813afe3bc6b8e5a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/26/">«</a>
	<span class="pagination__item pagination__item--current">27/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/28/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>