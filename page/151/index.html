<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98550787640245c65ca2f746972e7995/" rel="bookmark">
			【Oracle查询锁表及解锁】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Oracle查询锁表及解锁 1.查询锁表信息
--查询锁表信息 select b.owner, b.object_name, a.session_id, a.locked_mode from v$locked_object a, dba_objects b where b.object_id = a.object_id 2.查看session信息
--查询session信息 select b.username, b.sid, b.serial#, logon_time from v$locked_object a, v$session b where a.session_id = b.sid order by b.logon_time 3.kill对应进程解锁
-- sid,serial#即为上步查询的session信息 alter system kill session 'sid,serial#' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37f667b466a12389f386db883de9ebbe/" rel="bookmark">
			分享在阿里做Java研发5年的朋友的从业心得，送给还在迷茫中的你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		貌似这一点适应的行业最广，但是我可以很肯定的说：当你从事Java一年后，重新找工作时，才会真实的感受到这句话。
工作第一年，往往是什么都充满新鲜感，什么都学习，冲劲十足的一年；WEB行业知识更新特别快，今天一个框架的新版本，明天又是另一个新框架，有时往往根据项目的需要来不断学习新东西；所有，很多时候感觉，自己用过的东西真多呀！但是真正深入研究的东西却不多。面试，是跳槽后第一个需要面对的问题；而且不同公司面试的着重点不同；但是却有一个共同点：Java基础是必考的。
工作第一年，可能问你String对象创建的理解，常用的框架是什么等等； 工作第三年，就问你Java内存分配机制是什么，类是如何加载的等等； 工作第五年，就问你常用的设计模式是什么，你在工作中充当什么角色，怎么独立完成一个模块等等； 可以看出——这是一个典型的程序员的成长过程： 使用Java—-&gt;深入理解Java积累经验——&gt;独立设计分析能力——&gt;独当一面的多面手！ 因此，必须学习： 数据库
最常用的是Oracle了(当然银行项目等需要DB2等)，熟练掌握使用存储过程，触发器等；
UML
项目中经常要写文档，项目经理的基本功，程序员走向设计的基本功；
linux系统
需要掌握常用的linux命令——部署在windows操作系统上的项目很少吧。
其他就不多说了，大家可以补充。
学习上，兴趣是最大的老师；项目驱动也是不错的选择，总之，不学习不行。
第一. 积累行业背景； 行业背景非常重要；工作3年后必须确定自己的行业背景，比如一直从事电信行业，一直从事银行项目，一直从事ERP行业等等。
一个程序员不可能是一直写代码的，就是写代码也要知道业务逻辑，满足什么需求；俗话说隔行如隔山，每个行业的业务都不一样，甚至差别很大，比如你一直从事流媒体的研究，让你跳槽到一家银行项目，完了，一切从头学吧，以前的行业经验都用不上了；而且，一个公司公司招人，就是希望找到那些很容易上手，不需要培训业务很久的程序员；频繁跳槽的朋友，一定要注意这点；
一直在一个行业呆久了，就可以成为这个行业的专家；我们可以经常看到，一个项目组的某个leader，代码写的一般，但是却可以跟客户流畅的沟通，控制着新需求的提出，bug的修正等等；而客户也很愿意跟他打交道，因为那些老的项目只有他能维护，他甚至熟悉系统的每一张表结构——-可想在这个行业呆的时间有多久啦。
第二. 合理的职业规划 什么是职业规划—就是你短期或者长期的一个职业计划！大道理不讲，咱简单点。先问你几个问题：
a.你工作几年了，你愿意一直和新入行的新手一样就是个简单的程序员吗？
b. 你愿意一直写代码，而不关心其他吗？
c. 一个项目的前期需求，设计，后期部署维护，领导找到你，你说咱搞不定，行吗？
程序员不是敲代码的机器。第一年太多东西不懂，你可以一切听从老大的安排，敲敲代码，看看数据库，测试自己和别人的代码；但是第二年，你还是这样吗？不可能的，一年的经验你完全可以入行了，是时候该学习怎么进行需求分析，怎么设计数据库，怎么写各类文档，怎么写更好的代码？这是高级程序员的要求！
什么是高级程序员？
具有分析设计能力，能进行技术攻关，而且具有某行业深厚背景的程序员！
所有，一个项目立项后，你要积极的参与到前期设计中，跟老同志们一道思考分析问题，学习经验！OK，你这就成长啦！
千万不要认为程序员就是写代码的哦！！！
而且，通过一个项目的开发，你要能粗略的统计出一个功能的开发时间；比如一个模块有20个小功能点，你开发了80个小时，每个小功能点平均2小时——这时在前期就能评估工作量啦。当然每个人的效率和工作质量是不同的，因人而异，但是大概的工作量应该是可以统计出来的，用于统计一个项目的工作周期；
具备上面的能力，你起码已经是一个项目组的骨干啦！此时，就可以带领小弟做开发而不是平凡的一个被带领者啦。
很多公司的项目骨干和项目经理都不是通过招聘的来的，都是培养出来的——-工作2年，思考能力不错，善于动手，很上道！OK，此时项目经理和公司中层可能就注意到你了，就会给你多分配任务慢慢的锻炼你，这时候千万不要闹别扭哦（曾遇上这样一个同事，技术很好，人也不错，领导突然给他分配很多任务，他开始是默默承受，后来闹意见啦！领导找他谈话后，他算明白啦！顶过一段时间就基本适应，可以快速的做完；后来他成了我们那批人中新的项目leader啦），跟带你的人好好学习，多劳动，很快就出头啦！
如果你工作了多年，属于老鸟了，也要善于带人，能提携小弟！因为只有小弟成长了，你身上的担子才会轻，项目才会顺畅的进行！
而且高级程序员（本科为例）工作四年左右工资就达到一个瓶颈了（一线城市是9K—1.2W），这时候必须“转型”—–高级程序员只是你能力的一部分，系统分析师，架构师，技术主管才是你应该告诉别人的职务，薪资才能再次提升。
第三. 关于跳槽 跳槽要学习的技术就多了
跳槽时时刻刻都在发生，但是我建议大家跳槽之前，先想清楚为什么要跳槽。切不可跟风，看到同事一个个都走了，自己也盲目的开始面试起来（期间也没有准备充分），到底是因为技术原因（影响自己的发展，偏移自己规划的轨迹），还是钱给少了，不受重视。
准备不充分的面试，完全是浪费时间，更是对自己的不负责（如果title很高，当我没说）。
今天给大家分享下在这次跳槽中整理的Java面试大纲，其中大部分都是面试过程中的面试题，可以对照这查漏补缺，当然了，这里所列的肯定不可能覆盖全部方式。
项目介绍
大部分情况，这是一场面试的开门题，面试官问这个问题，主要是考察你的概述能力和全局视野。有的人经常抱怨自己每天在堆业务，但没有成长。事实上，很多情况下确实在堆业务，但并不是没有成长的。并非做中间件或者技术架构才是成长，例如我们的需求分析能力，沟通协作能力，产品思维能力，抽象建模能力等都是一个非常重要的硬实力。
好的，现在进入正文。
明确项目是做什么的明确项目的价值。（为什么做这个项目，它解决了用户什么痛点，它带来什么价值？）明确项目的功能。（这个项目涉及哪些功能？）明确项目的技术。（这个项目用到哪些技术？）明确个人在项目中的位置和作用。（你在这个项目的承担角色？）明确项目的整体架构。明确项目的优缺点,如果重新设计你会如何设计。明确项目的亮点。（这个项目有什么亮点？）明确技术成长。（你通过这个项目有哪些技术成长？） Java基础
List 和 Set 的区别HashSet 是如何保证不重复的HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?HashMap 的扩容过程HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？final finally finalize强引用 、软引用、 弱引用、虚引用Java反射Arrays.sort 实现原理和 Collection 实现原理LinkedHashMap的应用cloneable接口实现原理异常分类以及处理机制wait和sleep的区别数组在内存中如何分配 Java 并发
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37f667b466a12389f386db883de9ebbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/806831c7e4e1a7da6ff2e3576adc152e/" rel="bookmark">
			InternImage实战：使用InternImage实现图像分类任务（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘要“书生2.5”的应用1. 图像模态任务性能2. 图文跨模态任务性能 核心技术 安装包安装timm安装 grad-cam安装DCNV3 数据增强Cutout和MixupEMA项目结构计算mean和std生成数据集 摘要 论文翻译：https://wanghao.blog.csdn.net/article/details/129379410
官方源码： https://github.com/OpenGVLab/InternImage
他来了！他来了！他带着氩弧焊的光芒过来了！作为CV的大模型，InternImage的光芒太强了。
2023年3月14日: 🚀 “书生2.5”发布！2023年2月28日: 🚀 InternImage 被CVPR 2023接收!2022年11月18日: 🚀 基于 InternImage-XL 主干网络，BEVFormer v2 在nuScenes的纯视觉3D检测任务上取得了最佳性能 63.4 NDS ！2022年11月10日: 🚀 InternImage-H 在COCO目标检测任务上以 65.4 mAP 斩获冠军，是唯一突破 65.0 mAP 的超强物体检测模型！2022年11月10日: 🚀 InternImage-H 在ADE20K语义分割数据集上取得 62.9 mIoU 的SOTA性能！ “书生2.5”的应用 1. 图像模态任务性能 在图像分类标杆数据集ImageNet上，“书生2.5”仅基于公开数据便达到了 90.1% 的Top-1准确率。这是除谷歌与微软两个未公开模型及额外数据集外，唯一准确率超过90.0%的模型，同时也是世界上开源模型中ImageNet准确度最高，规模最大的模型；在物体检测标杆数据集COCO上，“书生2.5” 取得了 65.5 的 mAP，是世界上唯一超过65 mAP的模型；在另外16个重要的视觉基础数据集（覆盖分类、检测和分割任务）上取得世界最好性能。 分类任务
图像分类 场景分类 长尾分类ImageNetPlaces365Places 205iNaturalist 201890.161.271.792.3 检测任务
常规物体检测长尾物体检测 自动驾驶物体检测密集物体检测COCOVOC 2007VOC 2012OpenImageLVIS minivalLVIS valBDD100KnuScenesCrowdHuman65.594.097.274.165.863.238.864.897.2 分割任务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/806831c7e4e1a7da6ff2e3576adc152e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0428ba2de08ffdafb48e755b5465d69/" rel="bookmark">
			笔记软件怎么导入PDF文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常工作和学习中，我们需要接触到很多人的文件，比如PDF文件等。在管理这些文件的时候，如果能将其储存在一个笔记软件中，会更加方便随时查看和提取重要信息。
那么笔记软件怎么导入PDF文件呢？
首先，要确保你所使用的笔记软件支持上传PDF文件，只要这个前提成立，我们就可以按照一定的步骤一步步上传了。敬业签支持导入PDF文件的笔记软件，今天就以Windows端的它为例，演示一下如何操作：
1、打开并登录，点开已有的或创建一个新的便签分类，在该分类下，点击新增；
2、然后点击传文件按钮或把PDF文件拖到窗口上方（大窗口）；
3、PDF文件就会显示在窗口下方，你可以继续上传或编辑相关文字；
4、编辑完成后点击保存，软件主页面就会显示该条内容，想要查看文件只需点击文件图标，右键单击文件图标还能执行相应操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba80fce5946e46ff52d96761e55b873b/" rel="bookmark">
			金三银四，我猜你需要这三套网络安全工程师面试题（附答案解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年已经开始了，先来灵魂三连问，年初定的目标是多少？薪资能涨吗？女朋友能找到吗？
好了，不扎大家的心了，接下来进入正文。
由于我之前写了不少网络安全技术相关的文章和回答，不少读者朋友知道我是从事网络安全相关的工作，于是经常有人私信问我：
我刚入门网络安全，该怎么学？
想找网络安全工作，应该要怎么进行技术面试准备？
工作不到 2 年，想跳槽看下机会，有没有相关的面试题呢？
为了更好地帮助大家高薪就业，今天就给大家分享三份网络安全工程师面试题，一共有260道面试真题，希望它们能够帮助大家在面试中，少走一些弯路、更快拿到offer！
需要面试题的话可以点击：CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
91道网络安全面试题 什么是SQL注入攻击什么是XSS攻击什么是CSRF攻击什么是文件上传漏洞DDos 攻击重要协议分布图arp协议的工作原理什么是RARP?工作原理dns是什么?dns的工作原理rip协议是什么? rip的工作原理RIP的缺点OSPF协议? OSPF的工作原理TCP与UDP区别总结?什么是三次握手四次挥手?tcp为什么要三次握手?GET和 POST的区别Cookies和session区别session 的工作原理?1一次完整的HTTP请求过程HTTPS和HTTP的区别OSI 的七层模型都有哪些?http长连接和短连接的区别TCP如何保证可靠传输?常见的状态码有哪些?什么是SSL? https是如何保证数据传输的安全（SSL是怎么工作保证安全的）如何保证公钥不被篡改?php爆绝对路径方法?你常用的渗透工具有哪些，最常用的是哪个?xss盲打到内网服务器的利用鱼叉式攻击和水坑攻击什么是虚拟机逃逸?中间人攻击?TCP三次握手过程?七层模型?对于云安全的理解了解过websocket吗?DDOS是什么?有哪些?CC攻击是什么?区别是什么?land攻击是什么?你会如何进行信息收集?什么是CRLF注入攻击?防止XSS，前端后端两个角度?如何防护一个端口的安全?webshell检测思路?GPC是什么?开启了怎么绕过web常用的加密算法有什么XSS除了获取cookies还能做什么?运营商（或其他）网络劫持DNS欺骗是什么网络安全事件应急响应企业内部安全业务上线前，怎么测试，从哪些角度测试应用有漏洞，但是无法修复和停用，你怎么办CSRF怎么防护?文件上传绕过方法?验证码相关利用点cookie你会测试什么内容说出几个业务逻辑漏洞类型?简述文件包含漏洞业务逻辑漏洞，用户任意密码重置有什么例子，因为什么因素导致的?渗透测试过程中发现一个只能上传zip文件的功能，有什么可能的思路?为什么aspx木马权限比asp大?只有一个登录页面有哪些思路?请求头中哪些是有危害的?谈谈水平/垂直/未授权越权访问的区别?xss有什么?执行存储型的xss的危害和原理主机疑似遭到入侵，要看哪里的日志python常用的标准库oauth认证过程中可能会出现什么问题，导致什么样的漏洞?做了cdn的网站如何获取真实IP如何实现跨域?jsonp跨域与CORS跨域的区别?算法?了解过什么排序?SSRF漏洞利用?常见后门方式?open basedir访问目录限制绕过方法?PHP代码审计中容易出问题的点?红蓝对抗中蓝队反杀红队场景和姿势?linux计划任务，黑客隐藏自己的计划任务会怎么做?Redis未授权常见getshell的几种方式?JWT的攻击手法? （头部、负载、签名）JAVA中间件的漏洞，举几个例子?DNS外带可以用在哪些漏洞?中间件漏洞总结?谈一谈Windows系统与Linux系统提权的思路?python有哪些框架，其中出现过哪些漏洞小程序的渗透和普通渗透的差异app本身的漏洞测试四大组件IDS/IPS防护原理及绕过思路json的csrf的利用json格式的数据包可以测哪些漏洞内网服务器，如何进行信息收集?如果拿下了内网边界层的某一个机器，如何对内网其他进行探测? 83道天融信网络安全面试题及答案 防范常见的 Web 攻击重要协议分布层arp 协议的工作原理rip 协议是什么？rip 的工作原理什么是 RARP？工作原理OSPF 协议？OSPF 的工作原理TCP 与 UDP 区别总结什么是三次握手四次挥手？tcp 为什么要三次握手？一次完整的 HTTP 请求过程Cookies 和 session 区别GET 和 POST 的区别HTTPS 和 HTTP 的区别session 的工作原理？http 长连接和短连接的区别OSI 的七层模型都有哪些？session 的工作原理？什么是 TCP 粘包/拆包？发生原因？解决方案TCP 如何保证可靠传输？URI 和 URL 的区别什么是 SSL ？https 是如何保证数据传输的安全（SSL 是怎么工作保证安全的）TCP 对应的应用层协议，UDP 对应的应用层协议常见的状态码有哪些？拿到一个待检测的站，你觉得应该先做什么mysql的网站注入，5.0以上和5.0以下有什么区别在渗透过程中，收集目标站注册人邮箱对我们有什么价值判断出网站的CMS对渗透有什么意义目前已知哪些版本的容器有解析漏洞，具体举例发现 demo.jsp?uid=110 注入点，你有哪几种思路获取 webshell，哪种是优选sql注入分为哪几种？这几种在注入的时候有什么分别XSS分为几种？简单描述cookie和session你常用的渗透工具有哪些，最常用的是哪个windows 权限控制，种后门有哪几种方式php文件包含有哪些函数php命令执行有哪些函数phpmyadmin 如何渗透sqlmap查询当前数据库参数是啥如何判断web服务器是linux还是windowsCSRF、XSS 、XXE、Ssrf 分别是什么？以及修复方式常见的不同web服务器解析漏洞？ IIS apache nginx 等怎么利用http返回头里面有哪些项？能说出来几个 分别什么作用redis 未授权在渗透中如何利用渗透测试执行流程简单介绍一下nmap工具及使用nmap在扫描过程中如何规避安全设备简单介绍一下metasploit工具metasploit中有哪些模块cs有接触过吗？介绍一下cs的功能吧什么是Xray？有什么功能？如何使用介绍一下burpsuite工具及其常用模块有哪些Webshell管理工具有哪些？有什么不同之处什么是OWASP TOP 10？OWASP top10都有哪些漏洞数据库类型？常见的端口？什么是SQL注入什么是堆叠注入？mysql提权方式有哪些mysql提权之后可以执行命令吗如何突破注入时字符被转义？SQL注入如何防御什么是XSS？XSS类型有哪些？XSS漏洞有哪些危害什么是dos、ddos攻击？如何防御抓包工具用过哪些？如何使用文件权限修改用什么命令？格式是怎么样的复制文件用哪个命令，如果需要连同文件夹一块复制呢移动文件用哪个命令？改名用哪个命令终止进程用什么命令?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba80fce5946e46ff52d96761e55b873b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df8b498649c9498a1a052eb75e1bb156/" rel="bookmark">
			socket使用(recv踩坑)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要写一个client用户端和一个server服务器端，实现客户端向服务器端发送图片文件，服务器端进行处理，并返回处理结果
client.py
import socket from tqdm import tqdm import os import time if __name__ == "__main__": # 传输数据分隔符，减少连接次数 SEPARATOR = "&lt;SEPARATOR&gt;" # 服务器信息 host = '127.0.0.1' port = 5001 # 客户端信息 c_host = '127.0.0.1' c_port = 5002 # 文件传输的缓存区 BUFFERSIZE = 4096 # 传输文件名，文件路径 path = r"I:\map\twoMethod\figure" filename = "0061_Martigues_As_Surveyed_2022-Model.png" # 文件大小 filesize = os.path.getsize(os.path.join(path,filename)) # 接受回复文件存储位置 replyPath = "temp/" # 创建socket连接 s = socket.socket() s.bind((c_host,c_port)) # 连接服务器 print(f"服务器连接中{host}:{port}...") s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df8b498649c9498a1a052eb75e1bb156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ffe47828cbdaed0c0ded0e91662a446/" rel="bookmark">
			WSL安装ubuntu到指定目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依赖 系统已启动适用于 Linux 的 Windows 子系统可选功能系统已启用虚拟机平台可选功能支持WSL2的windows系统 注：上述1和2如果有疑问请阅读《参考》章节链接1的步骤1~步骤5。
安装步骤 官网下载非Microsoft Store 发行版包，如此处选择下载Ubuntu 18.04版本，比如下的文件为：Ubuntu_1804.2019.522.0_x64.appx将上一步下载的文件的扩展名(即.appx)重命名为.zip，即Ubuntu_1804.2019.522.0_x64.zip将上一步的zip文件包提取到想要安装的如 F:\wsl\Ubuntu_1804目录下点击解压后的ubuntu1804.exe，即安装到当前目录。 其他版本类似。 参考 1: windows 10/11 wsl 安装 ubuntu
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d169ab24c7ce0ed80c92b7001281ca5/" rel="bookmark">
			反爬虫常见策略总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有爬虫就有反爬虫，这都是相辅相成的，对于长时期从事在爬虫行业的技术员来说，时刻要了解对应网站的反爬机制，才能稳定获取数据。下面就是我这几年接触过的反爬的一些案例，供大家参考下。
反爬虫
反爬虫，即应对爬虫进行反制的统称，主要区分“正常用户”与“机器人”的一种策略统称。
认识反爬虫
正所谓知其然，知其所以然。对于反爬虫的措施有所了解与认知，一方面便于快捷定位防护点实现分析或绕过，另一方面组成爬虫攻防体系。万变自不离其宗，应对反爬虫措施游刃有余。一般常在如下几大部分设伏。
“以下便不考虑第三方测试工具的校验”
请求前校验
抓包拦截
做过爬虫的小伙伴，一定知道在分析加密、执行爬虫项目之前。首先第一步一定是先抓包，定位到对应数据包，然后继续才进行分析或规律。那么在此无疑是最为有效的反抓，捕获不到流量包URL未知，除了使用自动化测试工具、RPC等通常可能都毫无办法。
抓包拦截又可细分为控制台检测、端口转移、证书校验，私有协议总而言之就是让你抓不到包，其方法无所不用其极。
控制台检测抓包绕过策略：
替代法: 采用中间人抓包（Charles、mitmproxy、firdler等）
分析绕过法：定位到检测处，分析绕过
端口转移绕过策略：
强制端口
流量转发
证书锁定与公钥锁定
为了防止中间人攻击，采用SSL-Pinning的技术来反抓包。中间人抓包要点是伪造了一个假的证书实现拦截与转发，从而在中间获取的过路数据包实现抓包。反抓思路就是，客户端也预置一份服务端的证书，比较一下就知道真假了。SSL-pinning有两种方式证书锁定（Certificate Pinning）与公钥锁定（Public Key Pinning）
证书锁定
“证书锁定是SSL/TLS加密的额外保证手段。它会将服务器的证书公钥预先保存在客户端。在建立安全连接的过程中，客户端会将预置的公钥和接受的证书做比较。如果一致，就建立连接，否则就拒绝连接。在客户端设置证书只允许设置指定域名的证书，而不接受操作系统或浏览器内置的CA根证书对应的任何证书。”
公钥锁定
“HTTP公钥锁定是HTTPS网站防止攻击者CA机构错误签发的证书进行中间人攻击的一种安全机制，用于预防CA遭受入侵或其他会造成CA签发未授权证书的情况。采用公钥锁定时，网站会提供已授权公钥的哈希列表，指示客户端在后续通讯中只接受列表上的公钥。提取证书中的公钥并内置到客户端中，通过与服务器对比公钥值来验证连接的正确性。”
绕过：Hook到证书校验，无论如何返回正确的即可
私有协议通讯
一线大厂自定义通讯协议，自然考虑到了抓包。那么自然而然也设置了反抓包
绕过：Hook、沙箱
运行环境检测
CDN网络分发加验证:经典产品5秒盾
“其核心为 请求 -&gt; cdn -&gt; 返回关键参数 -&gt; 通过 -&gt; 数据(可能为假)”
请求校验
“当抓到包之后，便是模拟用户请求了。那么这里的常见的反抓措施有哪些呢”
请求校验，即在发送请求时即对网络请求时进行校验，实现区分。通过则返回数据，未通过不返回或返回假数据常有如下几种方式
协议校验
常见通用的协议有HTTP1.0、 HTTP1.1、HTTP2.0 ，若强行只允许HTTP2.0协议来完成请求与响应。那么平常使用其他
TSL指纹
每个请求库其实是有自己的库指纹，若只允许某段或某规则指纹通过，那么自然而言实现了反抓的效果。
header校验
header校验又可分为两种。其一是字段校验，其二是header字段顺序校验
header各字段校验，如ua、sign、cookie、token、safe等
“绕过方案或思想：通过JS解密或逆向获取关键参数缺啥补啥，完成模拟即可”
header字段顺序：当我们打开一个网页其实是一个新的会话那么在未断开或重新连接的时候那么这个顺序就是固定的。而字典格式中位置其实是随机分配的，自定义客户端刷新，对header取指纹或字段顺序检测即可实现鉴别
“绕过方案或思想：保持会话一致”
参数校验
通常字段不仅在header中校验还经常在请求参数中，如sgin、token、safe等。
“参数不可无缘无故来，主要来源JS 生成、服务器下发(不限于文件、JS、wasm等)。又可进行多次中间操作”
前后端分离技术Ajax
“严格来说并不算反扒而是前后端分离技术,但常常结合反抓共同出现”
Ajax（异步JavaScript和XML）也叫不刷新页面请求。
RPC防护
采用RPC及加密或编码方式实现前后端分离、微服务架构等。
“rpc结合反抓基本步骤，客户端请求(中间极有可能涉猎加密)RPC服务端，RPC客户端(原服务端)再次(中间极有可能涉猎加密)请求(一次或多次)。实现“分端”请求，多端加密。”
“逆写rpc进行调用，模拟“第一次”客户端请求rpc无差别，绕过”
请求校验小结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d169ab24c7ce0ed80c92b7001281ca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70b50183827780d9632ab5ce5be58092/" rel="bookmark">
			aop编程切点的的过滤execution的语法、cron表达式的语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		execution 切点除了execution表达式之外，还可以过滤自定义注解，使用面向切面编程实现的自定义注解的功能
execution(&lt;修饰符模式&gt;?&lt;返回类型模式&gt;&lt;方法名模式&gt;(&lt;参数模式&gt;)&lt;异常模式&gt;?)返回类型模式、方法名模式和参数模式外，其它项都是可选的 符号作用*0个或多个任意字符…用在方法参数中， 表示任意多个参数； 用在包名后，表示当前包及其子包路径+用在类名后，表示当前类及其子类；用在接口后，表示当前接口及其实现类 cron表达式 语法: 秒 分钟 小时 日期 月份 星期 年(可选) 字段允许值允许的特殊字符秒0-59, - * /分0-59, - * /小时0-23, - * /日期1-31, - * ? / L W C月份1-12, - * /星期1-7, - * ? / L C #年（可为空）留空, 1970-2099, - * / 秒 允许值范围: 0~59 ,不允许为空值，若值不合法，调度器将抛出SchedulerException异常
“*” 代表每隔1秒钟触发
“,” 代表在指定的秒数触发，比如"0,15,45"代表0秒、15秒和45秒时触发任务
“-” 代表在指定的范围内触发，比如"25-45"代表从25秒开始触发到45秒结束触发，每隔1秒触发1次
“/” 代表触发步进(step)，"/“前面的值代表初始值(”“等同"0”)，后面的值代表偏移量，比如"0/20"或者"/20"代表从0秒钟开始，每隔20秒钟触发1次，即0秒触发1次，20秒触发1次，40秒触发1次；"5/20"代表5秒触发1次，25秒触发1次，45秒触发1次；"10-45/20"代表在[10,45]内步进20秒命中的时间点触发，即10秒触发1次，30秒触发1次
分钟 允许值范围: 0~59 ,不允许为空值，若值不合法，调度器将抛出SchedulerException异常
“*” 代表每隔1分钟触发
“,” 代表在指定的分钟触发，比如"10,20,40"代表10分钟、20分钟和40分钟时触发任务
“-” 代表在指定的范围内触发，比如"5-30"代表从5分钟开始触发到30分钟结束触 发，每隔1分钟触发
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70b50183827780d9632ab5ce5be58092/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66608787e0c3a90adebc27d67596f548/" rel="bookmark">
			Nuxt3实战系列之网络请求篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nuxt3提供了4种方式使得我们可以异步获取数据
useAsyncDatauseLazyAsyncData （useAsyncData+lazy:true）useFetchuseLazyFetch （useFetch+lazy:true） 4种方式中，其实核心的就是useAsyncData和useFetch。这两个方法不同于Nuxt2中的asyncData和fetch。接下来我们先来好好分析下这两个方法。
useAsyncData 我们知道，在Nuxt2中，asyncData方法类似于一个生命周期函数，它在服务端或路由更新之前被调用。方法的参数是当前页面的上下文对象，我们一般是利用 asyncData方法来获取数据并返回给当前组件，以避免请求放在客户端执行时带来的数据延迟出现问题。
export default {data() {return { project: 'default' }},asyncData(context) {return { project: 'nuxt' }} } 在Nuxt3中，useAsyncData可以看做是异步获取数据场景的一个封装，而且变成了一个主动调用函数，原则上可以在任何时机调用。
// 用法 const {data: Ref&lt;DataT&gt;,// 返回的数据结果pending: Ref&lt;boolean&gt;,// 是否在请求状态中refresh: (force?: boolean) =&gt; Promise&lt;void&gt;,// 强制刷新数据error?: any // 请求失败返回的错误信息 } = useAsyncData(key: string, // 唯一键，确保相同的请求数据的获取和去重fn: () =&gt; Object,// 一个返回数值的异步函数options?: { lazy: boolean, server: boolean }// options.lazy,是否在加载路由后才请求该异步方法，默认为false// options.server,是否在服务端请求数据，默认为true// options.default，异步请求前设置数据data默认值的工厂函数（对lazy:true选项特别有用）// options.transform，更改fn返回结果的函数// options.pick，只从数组中指定的key进行缓存 ) 从api的设计中可以看出，useAsyncData没有限制我们发起网络请求的方式，同时它还暴露了请求状态，增加了刷新控制，以及对重复获取数据的去重控制等。使用示例如下：
&lt;script setup&gt; const { data } = await useAsyncData('count', () =&gt; $fetch('/api/count')) &lt;/script&gt; &lt;template&gt;Page visits: {{ data }} &lt;/template&gt; useFetch 在Nuxt2中，fetch 方法用于在渲染页面前填充应用的状态树（store）数据， 与 asyncData 方法类似，不同的是它不会设置组件的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66608787e0c3a90adebc27d67596f548/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ba498ba81564b1dd00f92cc9b9e410/" rel="bookmark">
			cadence PCB的sub-drawing使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要功能为，把走线过孔等，从一个PCB复制到另外一个PCB中；
学习笔记，仅供大家参考！
两个注意事项 此指令必须拷贝元件位置摆放位置要一样File-&gt;export-&gt;sub drawing 再选择所以复制的类型项目
PCB上右键 tenp group 框选复制内容；
框选所需要的复制对像，然后右键comple
再输入参考坐标，例输入x 0 0,以原点为坐标，再 回车，保存文件
3, 再导入新PCB中（File-&gt;import-&gt;sub-drawing）,选择要文件，再ok
再输入坐标
4,, 导入完成效果（两个板子规则不一样，有DRC报错，后面要根据情况再调整规则）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbfc72789f5b06ba9d36cf8242cdea2f/" rel="bookmark">
			Git如何查看分支列表？具体步骤是怎样的？底层原理是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要查看 Git 中的分支列表，可以使用 git branch 命令。该命令会列出当前仓库中所有的本地分支，并在当前分支前面加上一个星号（*）以标识当前所在的分支。
具体步骤如下：
打开终端或命令行窗口，进入 Git 仓库所在的目录。
运行 git branch 命令，该命令会列出所有本地分支。
可以添加 -r 选项来查看远程分支，或者使用 -a 选项来查看所有分支（包括本地分支和远程分支）。
底层原理是，Git 使用对象数据库来存储提交和分支等信息。每个分支实际上是一个指向某个提交对象的指针。在 Git 中，分支的列表信息存储在 .git/refs/heads 目录下，每个分支都是一个文件，文件名为分支名称，文件内容为指向该分支最新提交的 SHA-1 值。当运行 git branch 命令时，Git 会读取该目录下的文件列表并显示为分支列表。通过读取这些文件的内容，Git 可以确定每个分支指向的提交对象和分支名称。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24ffda151c61d46c54f2189c4fbf7919/" rel="bookmark">
			sklearn库 bp神经网络[从原理到代码一篇搞定]（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是bp神经网络 BP神经网络，即反向传播神经网络（Backpropagation Neural Network），是一种广泛应用于分类、回归和聚类等任务的人工神经网络。
bp神经网络的结构 BP神经网络的基本结构包含三层：输入层、隐含层和输出层。其中，输入层接受输入数据，隐含层和输出层由若干个神经元组成。每个神经元与前一层的每个神经元相连，并带有权重。当输入数据通过神经网络时，每个神经元将加权输入相加，并通过一个激活函数进行非线性变换，然后将输出传递到下一层神经元。这样逐层传递后，最后输出层将产生一个输出结果。
BP神经网络的训练过程是基于误差反向传播算法(Backpropagation)，即通过反向传播误差来更新每个神经元的权重值，以减小网络输出与真实输出之间的误差。误差计算的目标函数通常是平方误差或交叉熵误差。
激活函数 在神经网络中，激活函数（Activation Function）是一种将输入信号转换为输出信号的非线性函数。它在神经元中起到非线性映射的作用，可以增强神经网络的表示能力和学习能力。
以下是常用的激活函数及其表达式：
sigmoid函数
f ( x ) = 1 1 + e − x f(x) = \frac{1}{1+e^{-x}} f(x)=1+e−x1​
sigmoid函数的输出值在0到1之间，具有平滑的S形曲线。它在二元分类和神经网络中的某些层次中经常使用，但由于其存在梯度消失的问题，逐渐被ReLU等激活函数所取代。
tanh函数
f ( x ) = e x − e − x e x + e − x f(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}} f(x)=ex+e−xex−e−x​
tanh函数也是一种S形曲线函数，其输出值在**-1到1**之间。它相比sigmoid函数具有更大的梯度，但在面对大量输入时，tanh函数仍然存在梯度消失的问题。
ReLU函数
ReLU函数在输入为正数时直接输出该值，否则输出0。相较于sigmoid和tanh函数，ReLU函数的计算速度更快，且不存在梯度消失问题。因此，它被广泛应用于深度神经网络中。
损失函数 损失函数是用来衡量模型预测结果与实际结果之间的差异的函数。在神经网络中，损失函数通常用于评估模型的性能，从而优化模型参数以提高预测准确度。
不同的任务可能需要使用不同的损失函数。下面是一些常见的损失函数：
均方误差（Mean Squared Error，MSE）：适用于回归问题，表示预测值与真实值之间的平方差的平均值。表达式为：
其中 n n n 表示样本数量， y i y_i yi​ 表示真实值， y i ^ \hat{y_i} yi​^​ 表示模型的预测值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24ffda151c61d46c54f2189c4fbf7919/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40292f5f3ccaaa26e99cba69945ab273/" rel="bookmark">
			python字典的增删改查（基础）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 a = dict(num=1, name='libing', age='17') a1 = dict(num=2, name='libing', age='18',gread='2') # del a['name'] # 删除指定键值对 # a['age'] = "18" # 修改指定键的值，或者添加不存在的键值对 # a.clear() # 清空指定字典 # a.pop('num', 'ok') # 删除指定键，返回ok值（可省略） # a.popitem() # 获得最后一个键值对，并删除 # b = a.pop('num') # 删除指定键，并将删除的结果返回给b # print(b) # a.update(a1) # 更新字典 b = a.items() # 遍历字典时，需要先将字典变为列表 [列（元组），（元组）表] print(b) for x,y in b: print(x,y) c = a.keys() d = a.values() print(d) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0899464b11918e2dc2b959bb11da4f6/" rel="bookmark">
			js大数字转换，将大额数字转换为万、千万、亿等,并保留2位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 function bigNumberTransform (value) { let param = {}; let k = 10000, sizes = ['', '万', '亿', '万亿'], i; if(value &lt; k){ param.value =value.toFixed(2) param.unit='' }else{ i = Math.floor(Math.log(value) / Math.log(k)); param.value = ((value / Math.pow(k, i))).toFixed(2); param.unit = sizes[i]; } return param; } 调用
// 带上单位 console.log(bigNumberTransform (12345.564).value + bigNumberTransform (12345.564).unit ) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1103a0d6abfc2c3e33d23dcf4a345c15/" rel="bookmark">
			js矩阵转置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：将如下矩阵进行转置，也是我面试笔试碰到过的一道题目
这是我个人的思路（有好的思路请评论指教哈）：
转置之后的矩阵如下：
直接贴代码吧：
//题目：将如下矩阵进行转置，也是我面试笔试碰到过的一道题目 let arr = [ ['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'], ['j', 'k', 'l'], ]; //转置之后 //res= [ // [ 'a', 'd', 'g', 'j' ], // [ 'b', 'e', 'h', 'k' ], // [ 'c', 'f', 'i', 'l' ] // ] // 1.首先发现res[0]的长度是arr.length // 2.res.length=arr[0].length // 3.res[0][0]=arr[0][0] res[0][1]=arr[1][0] let res = []; for (let i = 0; i &lt; arr[0].length; i++) { //由于res里面没有数据数组，所以先创建（1） res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1103a0d6abfc2c3e33d23dcf4a345c15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d86e56b8fb9e5516e9d07eaf52df86ab/" rel="bookmark">
			【neo4j-python】安装与简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言环境第一步：JDK安装第二步：neo4j安装第三步：测试neo4j是否安装成功第四步：Python进行连接neo4j 前言 最近新入坑梦幻模拟战手游，对于英雄的羁绊一直不是很清楚，也不知道怎么方便查找英雄的羁绊（后来发现哔哩哔哩有专门的wiki进行介绍）。想到之前使用过一个叫做全历史的软件，是不是可以自己画一个类似的那种人物羁绊关系图，后来网上搜索了一下有个知识图谱的东西，似乎就很相似。但是网上的资料似乎都或多或少有点问题，花了我一天半的时间我才学会如何使用neo4j，因此在这儿重新梳理一下如何从完全不了解的情况下，开始使用neo4j搭建一个简单的知识图谱。写的不好，欢迎指责！
环境 win11python = 3.8.1IDE：VS code 第一步：JDK安装 官网下载 ：
https://www.oracle.com/java/technologies/javase-downloads.html
选择JDK版本
博主最开始下载的是java-20的版本，但是后来启动neo4j网页的时候，cmd终端总会发出警告（与neo4j版本不匹配），说是让我更换jdk的版本，因此这里使用的是JDK-17。
下载安装
这玩意儿下载比较慢，博主试了好几次，反复点击链接新建下载，每次下载的速度都不一样，慢的半小时，快的两分钟。
保存安装路径
这里可以直接使用这个路径，安装在C盘也只有200+MB，也不会被误删，记得先复制下来这个路径，待会儿有用
设置系统变量
可以直接在搜索框搜索环境变量
点进系统属性-高级-环境变量
选择新建一个系统变量，变量名为JAVA_HOME，变量值为C:\Program Files\Java\jdk-17（就是刚刚那个JDK的安装路径）
如下所示：
设置环境变量
双击系统变量里面的path，创建环境变量路径：%JAVA_HOME%\bin，设置完连点三个确定就可以了。
检测JDK是否安装成功
使用win+R，打开cmd，输入java -version，若没有报错则JDK安装成功
第二步：neo4j安装 官网下载
https://neo4j.com/download-center/#community版本选择
我是直接选择的最新个人社区版
下载解压
将压缩包解压在一个你不会误删除的地方，比如我放在了D:\neo4j-community-5.6.0
设置系统变量与环境变量
跟刚刚的JDK类似，搜索环境变量打开菜单栏，添加系统变量和环境变量，设置完就连点三个确定就可以了。
第三步：测试neo4j是否安装成功 进入到neo4j文件夹下的bin目录：D:\neo4j-community-5.6.0\bin，这儿有neo4j的启动文件neo4j.bat
使用鼠标右键点击空白处，选择在终端中打开，或者通过win+R，打开cmd，通过cd指令，进入到这个路径。然后输入
./neo4j.bat console 通过框选处给出的网址可以进入到网页端的neo4j，这个窗口在使用时不可关闭
设置用户名与密码
初次打开网页使用用户名neo4j和密码neo4j即可登陆成功，然后他紧接着会要求你修改密码，这个密码很关键，后面使用python进行连接的时候需要用到，记得保存。
试用一下
打开后是这样的内容，下面两个小框可以直接叉掉，不用管
在第一行输入
match(n) detach delete n 大小写都可以，可以先删除之前残留的知识图谱，（建议每次打开都删除一下）
然后再在第一行输入指令
CREATE (n:Person {name:'老师'}) RETURN n; CREATE (n:Person {name:'学生A'}) RETURN n; CREATE (n:Person {name:'学生B'}) RETURN n; 创建三个节点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d86e56b8fb9e5516e9d07eaf52df86ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ef174ca7f73067f9069286753c0b679/" rel="bookmark">
			物理引擎系统-ode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物理引擎系统-ode 目录
物理引擎系统-ode 一、物理引擎系统-ode——dBodySetAngularVel 二、物理引擎系统-ode——dBodySetMass 三、物理引擎系统-ode——dBodyGetMass 四、物理引擎系统-ode——dBodyAddForce 五、物理引擎系统-ode——dBodyAddTorque 六、物理引擎系统-ode——dBodyAddRelForce 一、物理引擎系统-ode——dBodySetAngularVel void dBodySetAngularVel (dBodyID b, dReal x, dReal y, dReal z)
{
dAASSERT (b);
b-&gt;avel[0] = x;
b-&gt;avel[1] = y;
b-&gt;avel[2] = z;
}
const dReal * dBodyGetPosition (dBodyID b)
{
dAASSERT (b);
return b-&gt;pos;
}
const dReal * dBodyGetRotation (dBodyID b)
{
dAASSERT (b);
return b-&gt;R;
}
const dReal * dBodyGetQuaternion (dBodyID b)
{
dAASSERT (b);
return b-&gt;q;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ef174ca7f73067f9069286753c0b679/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ed90c82faf7df85a0e8833a2f7dc3c/" rel="bookmark">
			Python seqeval包安装报错： error: subprocess-exited-with-error 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 报错信息如下解决方法： pip install seqeval 报错：error: subprocess-exited-with-error 报错信息如下 Collecting seqeval Using cached http:///pypi.tuna.tsinghua.edu.cn/simple/repository/pypi/packages/seqeval/1.2.2/seqeval-1.2.2.tar.gz (43 kB) Preparing metadata (setup.py) ... error error: subprocess-exited-with-error × python setup.py egg_info did not run successfully. │ exit code: 1 ╰─&gt; [41 lines of output] /usr/local/lib/python3.9/site-packages/setuptools/__init__.py:85: _DeprecatedInstaller: setuptools.installer and fetch_build_eggs are deprecated. Requirements should be satisfied by a PEP 517 installer. If you are using pip, you can try `pip install --use-pep517`. dist.fetch_build_eggs(dist.setup_requires) WARNING: The repository located at 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2ed90c82faf7df85a0e8833a2f7dc3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62ad22c3a8277441c78a628c15a526b1/" rel="bookmark">
			ShuffleNet V2 迁移学习对花数据集训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. shufflenet v2 介绍
2. 四条轻量化网络的基本准则
2.1 输入输出通道个数相同的时候，内存访问量MAC最小
2.2 分组卷积的分组数过大会增加MAC
2.3 碎片化操作会并行加速并不友好
2.4 element-wise 操作带来的内存和耗时不可以忽略
2.5 轻量化网络特点总结
3. shufflenet v2 网络
4. train 过程
5. utils 函数
6. 预测
7. 用命令行进行训练
shufflenetv1、v2的下载：shufflenet V1和V2 基于花数据集的分类
1. shufflenet v2 介绍 shufflenet v2 论文中提出衡量轻量级网络的性能不能仅仅依靠FLOPs计算量，还应该多方面的考虑，例如MAC(memory access cost)，还应该比较在不同的硬件设备下的性能等等
因此，基于多方面的考虑。shufflenet v2 通过大量的实验和测试总结了轻量化网络的四个准则，然后根据这四条准则搭建了shufflenet v2网络
输入输出通道个数相同的时候，内存访问量MAC最小分组卷积的分组数过大会增加MAC碎片化操作会并行加速并不友好element-wise 操作带来的内存和耗时不可以忽略 2. 四条轻量化网络的基本准则 2.1 输入输出通道个数相同的时候，内存访问量MAC最小 计算FLOPs和MAC可以参考这个：聊聊神经网络结构以及计算量和内存使用
如下，这里的卷积都是1*1卷积，因为1*1卷积占了大部分运算，并且BN层的存在，这里没有了bias。并且这里是same卷积，因此输出的size = 输入的size
所以这里的FLOPs = hwc1*1*1*c2 =hwc1c2= B(这里用B表示)，
同样，MAC = hw*c1(输入特征图) + 1*1*c1*c2(1*1权重)+hw*c2(输出特征图) = hw(c1+c2)+c1c2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62ad22c3a8277441c78a628c15a526b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82078cca44a606b6c9e5843f8e52742c/" rel="bookmark">
			VUE-全家桶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一节、vue全家桶概念 基础功能 + 2个额外功能(vuex、router)vuex:仓库，用来存储数据，比如userInforouter:路由：组件跳转（类似于动态组件） 第二节、新建vue全家桶项目 1 vue create v2_family 2 Manually select features --自己选择引入哪些插件 3 ? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection, and &lt;enter&gt; to proceed) (*) Babel ( ) TypeScript ( ) Progressive Web App (PWA) Support (*) Router (*) Vuex &gt;(*) CSS Pre-processors --scss ( ) Linter / Formatter ( ) Unit Testing ( ) E2E Testing 4 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82078cca44a606b6c9e5843f8e52742c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a59ce82bfc715cd2e190a1a3b34d796/" rel="bookmark">
			有关VMWare tools安装后仍然无法全屏的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人找了很多很多教程，基本上都没用，我用的ubuntu好像是22.的版本
我觉得一定要注意上图的中的第二句话，我的显示器好像有点大，我仅仅把虚拟机拖到了我的笔记本上，就可以全屏了，然后再拖回显示器也就可以全屏了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b74e77a33c945f982ebed9d27e65a124/" rel="bookmark">
			如何复制java工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有两种式，第一是在在IDEA中复制 它会弹出让你修改名字
我把001改为002
点击ok
方式二：在电脑中复制
复制001到当前文件，改名为002.上图是已经复制并改名为002了，点进去002
修改pom.xml中的
进入idea
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6deef2a30f8f9dc4664930561b609201/" rel="bookmark">
			OpenGL学习—EBO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.概念 EBO(Element Buffer Object，也叫IBO:Index Buffer Object)索引缓冲区对象
如在绘制多边形时，顶点数组中出现大量重复点，可以使用索引数组从而减少重复性点
EBO用来存储索引数据
二.使用 创建所索引数组
float vertices[]={ -0.5f,-0.5f,0.0f, 0.5f,-0.5f,0.0f, 0.0f,0.5f,0.0f}; unsigned int indices[]={0,1,3 1,2,3}; 创建EBO(同VBO)
注：EBO从索引数组中拿取数据
unsigned int EBO; //创建 glGenBuffers(1,EBO); //绑定 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,EBO); //传入数据 glBufferData(GL_ELEMENT_ARRAY_BUFFER,sizeof(indices),indices,GL_STATIC_DRAW); 创建好EBO后，VAO也会记录EBO中的情况
绘制的时候使用
glDrawElements();
glDrawElements(GL_TRIANGLES,6,GL_UNSIGNED_INT,0); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da4524a7d2632723dd35fa4507263907/" rel="bookmark">
			Ubuntu18.04及以上 安装3070ti显卡驱动 超简易方法！黑屏无法进入桌面解决方法以及联想拯救者电脑特殊设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接下来的工作要用ZED相机进行稠密地图构建的学习，故正好在新电脑上配置相关环境。
没想到第一步显卡驱动就让我捣鼓了两天，期间经历了无数次电脑黑屏无法进入桌面，大大小小坑都踩了一遍。
但在朋友zigzag的提醒下，发现ubuntu18.04及以上的显卡驱动安装其实是有超简易方法的。只要先禁用nouveau然后在软件与更新（software updater）里的additional driver 选择和自己适配的驱动器即可！
步骤如下：
1.禁用nouveau
先创建一个文件（默认没有这个文件 如果有就不用创建了 gedit命令可以直接创建并进入编辑）
sudo gedit /etc/modprobe.d/blacklist.conf
然后在文件中加入以下两行
blacklist nouveau options nouveau modeset=0 然后执行
update-initramfs -u 重启使命令生效（可用鼠标重启也可用reboot命令行），重启后
lsmod | grep nouveau 若没有输出就表示nouveau禁用成功！才可以进行下面步骤，不然就会一直面临黑屏一直删除重来！
2、驱动安装
网上大大小小的安装教程无数，但如果操作正确其实目前18.04及以上的ubuntu系统都可以直接在software updater里面 一键安装驱动的！可以省去官网下载等等步骤，相当于电脑直接自己安装，步骤如下：
进入应用列表找到software updater（软件与更新）：
然后点击 setting(设置)：
接着选择Additional driver项
可能一开始显示正在搜索然后没有驱动可以选，耐心等一下即可，加载好了会出现以下图像：选择一个和自己显卡相配对的驱动即可（其实没大区别 我3070ti 官方推荐525 但我为了适应相机 安装的510，最终也可以用！）
选择好驱动之后，点击右下角的Apply Changes，会有一个小进度条表示正在安装，这时候耐心等待一下。等安装完成后应该是如上图的样子，重启即可。
按道理重启之后应该成功可以直接运行了。
******Y9000p特殊设置（独立显卡设置） 但我本人的这台新电脑是联想拯救者y9000p, 其实在上面这个简单步骤之前尝试了无数中方法，什么ppa安装啊，官网下载run文件安装啊，都以失败告终(各种问题杂糅，人都不知道究竟哪里出了问题)。后面用这个简单步骤安装完之后，重启还是黑屏我都崩溃的想淘宝一百解君愁了，最后突然想到之前看过的一篇文章，说y9000p安装好显卡驱动之后要进bios设置把集成显卡改成独立显卡模式（如果安装了ubuntu 就在grub界面直接选择最下面那个system setting 应该就是进入bios了 或者在开机出现logo时按f2 或者f12 或者del键进入bios）
踩坑过程以及解决方法： 正常情况下，如果是nouveau没禁用或者安装过程中点错了东西，导致重启之后黑屏的，在重启之后选择高级选项进入recovery mode模式选择root进行命令行操作（或者这样进入命令行模式），删除已经安装的包即可，输入以下命令之后再重启即可
sudo apt-get remove --purge nvidia* 在我第一次操作时，哪怕把nvidia*全remove了reboot都不行，网上所有教程的方法我都尝试过了T T，后面发现应该是过程中越改越乱，把desktop不小心删了啊啊啊
最后结合了两个教程如何从grub界面进入tty1命令行界面以及在命令行界面重新安装ubuntu-desktop终于重新进入了熟悉的桌面。
大致流程就是这样，明明是个很简单的过程却耗费了我很多天时间就是因为对各种原理和操作不够熟练，道阻且长owo
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd3c1006e6ec0c2d083b1ed4ecd6f6d/" rel="bookmark">
			基于CloudSim Plus的计算卸载仿真设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于CloudSim Plus的计算卸载仿真设计 1. 前提介绍 仿真框架的实现，主要依托于仿真实体、以及仿真事件，简单介绍如下
1.1 仿真实体 继承CloudSimEntity类(推荐)或者实现SimEntity接口(不建议)
public class ExampleEntity extends CloudSimEntity { public ExampleEntity(Simulation simulation) { super(simulation); } @Override protected void startInternal() { // 实体开始启动 } @Override public void processEvent(SimEvent evt) { // 接收仿真事件 } } 该实体将交由CloudSim进行管理
各个实体之间因此也可以通信(通过仿真事件)
1.2 仿真事件 发送仿真事件
可以使用schedule()和scheduleNow()来发送仿真事件
schedule(final SimEntity dest, final double delay, final CloudSimTag tag, final Object data) scheduleNow(final SimEntity dest, final CloudSimTag tag, final Object data) 例如：实体启动时给自身发送事件
@Override protected void startInternal() { schedule(this, 1, CloudSimTag.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd3c1006e6ec0c2d083b1ed4ecd6f6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85917f2c918ec3f4ba37cfe58b862763/" rel="bookmark">
			SptingBoot过滤器Filter的使用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SptingBoot过滤器Filter的使用方式 参考博客：SptingBoot过滤器Filter的使用方式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec341da27168498180954deb4c6096b0/" rel="bookmark">
			第五届字节跳动前端青训营入营笔试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五届字节跳动青训营 文章目录 第五届字节跳动青训营青训营 - 前端练习题每日一练编程题前端编程题[342. 4的幂](https://leetcode.cn/problems/power-of-four/)[125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/)[5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/) 后端编程题题目1题目2题目3 青训营 - 前端进阶班笔试（A卷）单选题不定选择编程题第一题第二题 简答题 青训营 - 前端练习题 每日一练 DAY 1
选择题 1： 下列哪些是 HTML5 的新特性？ A. 语义标签 B. Canvas 绘图 C. &lt;audio&gt;元素 D. 增强型表单 【答案】ABCD
选择题 2： 下面可以继承的属性有哪些？ A. font-size B. background C. color D. cursor 【答案】ACD
【解析】
css不可以继承的属性：display、margin、padding、border、background、width、min-width、max-width、height、min-height、max-height、overflow、position、top、bottom、left、right、z-index、float、clear、table-layout、vertical-align、page-bread-before、page-bread-after、unicode-bidi
所有元素都可以继承：visibility、cursor
子元素可以继承：letter-spacing（字符间距）、word-spacing（单词间距）、white-space（如何处理元素内的空白）、line-height（设置行高，内联元素不可以继承，设置为行内块元素可以继承）、color、font、font-size、font-family、font-style、font-weight、font-variant（大写字母）、text-decoration（文本下划线、中划线）、text-transform（首字母大写、转大写）、direction（rtl-文本方向从右向左）、text-indent（首行缩进）、text-align（文本对齐）
列表元素（li）可继承：list-style、list-style-type、list-style-position、list-style-image
表格元素可继承：border-collapse
DAY 2
选择题 1： 对于一条100M的宽带，理论下载速度上限是多少？ A. 12.5MB/s B. 100MB/s C. 10MB/s D. 10Mb/s 【答案】A
【解析】1Byte = 8bit，因此理论下载速度上限是：100Mb/s ÷ 8 = 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec341da27168498180954deb4c6096b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acf364056a8c135000d41c8266257f5e/" rel="bookmark">
			加密算法分类介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加密算法分类：
1、对称加密算法: 加密和解密用同一个密钥，如AES 算法
2、非对称加密算法: 加密和解密用不同的密钥, 如RSA 算法
3、散列（hash）算法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5da6095e62a33c10cff839c9c1aaebee/" rel="bookmark">
			数据加密模型（学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据加密模型包括以下几个部分：
1、明文 P：准备加密的文本, 称为明文
2、密文 Y：加密后的文本, 称为密文
3、加解密算法 E(D)：实现从明文到密文或从密文到明文的一种转换方法
4、密钥 K：加密和解密算法中的关键参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76dd8978098915488695e64f2f76de8b/" rel="bookmark">
			Git - 如何将git修改的文件导出和导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.应用场景
主要用于将git修改的文件导出和导入， 帮助提高工作效率。 2.学习/操作
1.文档阅读 来自chatGPT的对话
2.整理输出 2.1 如何将git修改的文件导出来 如果您只是想将 Git 仓库中的文件导出到本地磁盘中，而不需要保留 Git 的历史记录和元数据，可以使用 git archive 命令来实现。
git archive 命令可以将 Git 仓库中的指定文件或文件夹打包成一个压缩文件，并将其导出到指定的目录中。具体步骤如下：
打开命令行终端，并进入 Git 仓库所在的目录。
运行以下命令来将 Git 仓库中的指定文件或文件夹打包成一个压缩文件：
git archive --format=zip --output=/path/to/output/file.zip HEAD:path/to/folder 其中，--format=zip 表示输出文件的格式为 ZIP 压缩文件，--output=/path/to/output/file.zip 表示将输出文件保存到指定的目录中，HEAD:path/to/folder 表示要导出的文件或文件夹路径。如果要导出整个仓库中的所有文件，可以将 HEAD:path/to/folder 替换为 HEAD。
运行以上命令后，Git 会将指定的文件或文件夹打包成一个压缩文件，并将其保存到指定的目录中。
如果您需要保留 Git 的历史记录和元数据，可以考虑使用 Git 的 git clone 命令将整个仓库克隆到本地，并使用其他工具来管理和导出修改的文件。
2.2 将git未提交的文件导出来 如果您想将 Git 中已经修改但未提交的文件导出到本地磁盘中，可以使用 git diff 命令和一些 shell 命令来实现。
具体步骤如下：
打开命令行终端，并进入 Git 仓库所在的目录。
运行以下命令来查看未提交的修改内容：
git diff &gt; changes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76dd8978098915488695e64f2f76de8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11879a37b2a58215b9a83a7f04b87c62/" rel="bookmark">
			大数据技术之Kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1章 Kafka概述 1.1 定义 Kafka传统定义: Kafka是一个分布式的基于发布/订阅模式的消息队列 (MessageQueue)，主要应用于大数据实时处理领域。
发布/订阅 :消息的发布者不会将消息直接发送给特定的订阅者，而是将发布的消息分为不同的类别，订阅者只接收感兴趣的消息。
Kafka最新定义 : Kaka是一个开源的分布式事件流平台 (Event StreamingPlatformm)，被数千家公司用于高性能数据管道、流分析、数据集成和关键任务应用。
1.2 消息队列 目前企业中比较常见的消息队列产品主要有Kafka、ActiveMQ、RabbitMQ、RocketMQ等。
在大数据场景主要采用Kafka作为消息队列在JavaEE开发中主要采用ActiveMQ、RabbitMQ、RocketMQ 1.2.1 传统消息队列的应用场景 传统的消费队列的主要应用场景有：缓存/削峰（缓冲）、解耦（少依赖）、异步通信（不必要及时处理）。
缓存/削峰（缓冲）：有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。解耦:允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。异步通信：允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。 1.2.2 消息队列的两种模式 消息队列主要分为两种模式：点对点模式（一个生产者对口一个消费者）和发布/订阅模式（一对多）。
1.3 Kafka基础架构 1）Producer ：消息生产者，就是向kafka broker发消息的客户端；
2）Consumer ：消息消费者，向kafka broker获取消息的客户端；
3）Consumer Group （CG）：消费者组，由多个consumer组成。消费者组内每个消费者负责消费不同分区的数据，一个broker可以有多个不同的topic，一个topic下的一个分区只能被一个消费者组内的一个消费者所消费；消费者组之间互不影响。消费者组是逻辑上的一个订阅者。
4）Broker ：一台kafka服务器就是一个broker。一个broker可以容纳多个不同topic。
5）Topic ：可以理解为一个队列，生产者和消费者面向的都是一个topic；
6）Partition：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列；
7）Replica：副本，为保证集群中的某个节点发生故障时，该节点上的partition数据不丢失，且kafka仍然能够继续工作，kafka提供了副本机制，一个topic的每个分区都有若干个副本，一个leader和若干个follower。
8）leader：每个分区副本中的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是leader。
9）follower：每个分区副本中的“从”，实时与leader副本保持同步，在leader发生故障时，成为新的leader。
第2章 Kafka快速入门 2.1 安装部署 后续更新
2.2 Kafka命令行操作 2.2.1 主题命令行操作 查看操作主题命令需要的参数
[atguigu@hadoop102 kafka]$ bin/kafka-topics.sh
重要的参数如下
| 参数 | 描述|
|–|–|
| --bootstrap-server | 连接kafka Broker主机名称和端口号 |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11879a37b2a58215b9a83a7f04b87c62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad570c66872e4780b5a5617ab13891e/" rel="bookmark">
			jsonp解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从学习前端开始，对于跨域就一直听到jsonp这个名词，对于这个技术我其实一直很好奇，因为前端这边的实现代码实在是过于抽象了.......下面我放一下前端部分的代码：
function jsonp(fnName) { let script = document.createElement("script") script.src = "http://127.0.0.2:8080/index/?call="+fnName; document.body.insertBefore(script, document.body.firstChild) } function handleResponse(response) { console.log('请求数据', response) } jsonp('handleResponse') http://127.0.0.2:8080/index/是我本地我自己开的服务，我用node写的接口，当然一个合格的jsonp方法应该有更好的处理方式，但是在这里我们不去讨论那些东西，我们只是单独讨论原理。
好的让我们回归正题，细看这段代码发现它只是生成了一个script标签，然后将其添加到了当前的html文档里而已，即使是向后端发送了一个请求，但是也只是传递过去了一个方法名称，一个方法名称有什么意义？直到我后来学了node之后亲自写了一遍前后端的完整逻辑才明白这个技术的天才之处，下面是服务器部分的代码:
var http = require("http"); //发起服务 const url = require('url'); var querystring = require("querystring"); http.createServer((req,res)=&gt;{ if(req.url == '/favicon.ico'){ return } let queryObj = null; if(req.url == '/index/?call=handleResponse'){ let urlObj = url.parse(req.url); queryObj = querystring.parse(urlObj.query); } res.statusCode = 200; let data = {id:'11111111111',data:[{a:1}]}; res.end(queryObj.call+'('+JSON.stringify(data)+')');//传递给前端数据 }).listen(8080,"127.0.0.2",()=&gt;{ console.log("Successfully"); console.log("http://127.0.0.2:8080/"); }) 这里我用node拉起了一个本地服务，res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ad570c66872e4780b5a5617ab13891e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fd0180db33b61d49b1039bb65d80e66/" rel="bookmark">
			rocon app
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		规格： Rapp指代rocon_app或者叫robot_app,用在机器人的控制中Robotics in Concert，这是通过 Rapp Manager 安装和执行的元数据。它旨在允许更高级别的控制器采用提供所需公共接口的系统，而不管其平台如何。Rapps 根据平台相关参数（例如启动）和 Rapp 继承的存在分为实现/虚拟和祖先/子级。
rapp类型 虚拟祖先：是rapp;包含公共接口，没有与平台相关的信息;不可执行;示例：rocon_apps/teleop
实现子：不完整的rapp;包含与平台相关的数据，但没有公共 API。它从父母那里继承参数，成为一个完整的 Rapp;示例：turtle_concert/teleop
实现祖先：是完整的rapp;包含要执行的完整信息;例 ： turtle_concert/turtle_stroll
虚拟子：无效的rapp;有关详细信息，请参阅设计决策。
rapp参数 下表描述了每种 rapp 类型和要求的特征
R = 必需
O = 可选
N = 不允许
i = 从父级继承（如果不存在）
功能依赖关系 ROS中功能的概念是机器人拥有的大多数“能力”存在更高级别的接口。格式遵循功能接口规范。
- name: &lt;capability interface name&gt; interface: topics: requires: &lt;interface topic&gt;: &lt;rapp topic&gt; provides: &lt;interface topic&gt;: &lt;rapp topic&gt; services: requires: &lt;interface service&gt;: &lt;rapp service&gt; provides: &lt;interface service&gt;: &lt;rapp service&gt; actions: requires: &lt;interface action&gt;: &lt;rapp action&gt; provides: &lt;interface action&gt;: &lt;rapp action&gt; 设计决策 虚拟/实现rapp 如果存在以下两个，则它是 rapp 实现。否则，它是一个虚拟的rapp。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fd0180db33b61d49b1039bb65d80e66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca33faa327cd69e2dd6f77370a8b3e16/" rel="bookmark">
			requests 标红 InsecureRequestWarning: Unverified HTTPS request is being made to host
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 InsecureRequestWarning: Unverified HTTPS request is being made to host ‘127.0.0.1’. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html#ssl-warnings
InsecureRequestWarning,
添加这一行解决问题
requests.packages.urllib3.disable_warnings() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/521d017ef852b1db9f015bce1f3a1558/" rel="bookmark">
			python实现z-score标准化和0-1标准化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
标准化处理
0-1标准化:
z-score标准化：
1、用自带的函数来操作
实现z-score标准化
实现0-1标准化
2、自定义函数实现
实现z-score标准化
实现0-1标准化
标准化处理 0-1标准化: 对输出结果范围有要求，数据较为稳定的，不存在极端的最大最小值
z-score标准化： 数据存在异常值和较多的噪音，可以间接通过中心化避免异常值和极端值的影响
1、用自带的函数来操作 实现z-score标准化 from sklearn.preprocessing import StandardScaler #实现z-score标准化 X_test=df_sum.iloc[:,-3:] #实例化对象 b_test=StandardScaler() #训练数据，赋值给b_test X_result=b_test.fit_transform(X_test) print(X_result) #查看训练数据 实现0-1标准化 from sklearn.preprocessing import MinMaxScaler X_test=df_sum.iloc[:,-3:] #实例化对象 b_test=MinMaxScaler() #训练数据，赋值给b_test X_result=b_test.fit_transform(X_test) print(X_result) #查看训练数据 2、自定义函数实现 实现z-score标准化 #定义标准化函数 import numpy as np def z_score_normalize(data): mean = np.mean(data, axis=0) std_dev = np.std(data, axis=0) normalized_data = (data - mean) / std_dev return normalized_data #调用 X=df_sum.iloc[:,-3:] b=z_score_normalize(X) print(b) 实现0-1标准化 #定义0-1标准化的代码 import numpy as np def normalize(X): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/521d017ef852b1db9f015bce1f3a1558/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0981cf8c537622727dc2a7159bb0495/" rel="bookmark">
			C# 调用海康相机SDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、查找相机设备 /// &lt;summary&gt; /// 枚举相机 /// &lt;/summary&gt; public List&lt;string&gt; DeviceListAcq() { var list = new List&lt;string&gt;(); // ch:创建设备列表 | en:Create Device List System.GC.Collect(); //cbDeviceList.Items.Clear(); list.Clear(); m_stDeviceList.nDeviceNum = 0; //MV_CC_EnumDevices_NET 查找设备 枚举了GigE相机的设备信息 CGigECameraInfo 、 //U3V相机的设备信息 CUSBCameraInfo 、Camera Link相机的设备信息 CCamLCameraInfo 。 //查找成功 返回0 没有查找成功--非0 显示ShowErrorMsg int nRet = MyCamera.MV_CC_EnumDevices_NET(MyCamera.MV_GIGE_DEVICE | MyCamera.MV_USB_DEVICE, ref m_stDeviceList); if (0 != nRet) { throw new ArgumentException("Enum Devices Fail"); //MessageBox.Show("Enum Devices Fail"); } // ch:在窗体列表中显示设备名 | en:Display device name in the form list for (int i = 0; i &lt; m_stDeviceList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0981cf8c537622727dc2a7159bb0495/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9adaf17388fea402c1f4718473ef56e0/" rel="bookmark">
			错误解决：Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
目的需求：
源代码：
报错信息：
错误解决：
总结：
前言： 这里出错的原因与大多数人并不相同，这里仅为个人记录。
作为一个菜只因，总是能深刻体会到一个bug改一天或者几天的痛苦......在做spring项目时，需要利用session保存用户信息，启动项目登录后总是抛出空指针异常，从昨天晚上7点一直搞到今天中午才最终解决。出错的原因也是非常搞笑。。。
目的需求： 在控制台打印出获取到的session信息
源代码： 父控制层：
子控制层继承父控制层，并在方法中打印信息：
报错信息： 启动输入信息后报错：
Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.NullPointerException] with root cause.
并报空指针异常：
java.lang.NullPointerException: null
以下还有一堆另人头疼的报错信息，这里不再赘述。
......
错误解决： 经过上网查询，陆续排除注解，名称映射等问题。最终将问题的关键锁定在seesion对象未获取到对象信息上，此时页面中的data显示为null：
后来打开业务层的实现类才发现：
我去，怎么 “return null” 呢，忙活了半天，对象创建了，值也绑定了，正常返回user对象，返回null干什么。
哎，之前测试的时候忘记改回来了 ......醉了醉了，这里提醒大家在构建项目的时候一定仔细严谨，不然就会出现这种令人无语的问题。
此时，重新启动项目：
控制台信息：
总结： 找错总是一件痛苦的事，但一定要坚持，就像学习一样，不断努力，不断在错误中改正——钢铁就是这样炼成的。
看到一句话说的很好：杀死你的不是AI，而是创造AI的人。
愿继续努力，与诸君共勉！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0230071015b09362db34338df5a1beb9/" rel="bookmark">
			注意力机制综述（自用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Attention Mechanisms in Computer Vision:A Survey Attention Mechanisms in Computer Vision:A Survey论文
文章将近几年的注意力机制分为：通道注意力、空间注意力、时间注意力和branch注意力，以及两个组合注意力机制：空间通道注意力机制和时间空间注意力机制。
Channel attention 通道注意力机制讲解
SENet (squeeze and excitation)：主要分为两部分：squeeze和excitation模块。前者使用全局平均池化用来压缩通道，将h×w×c特征图压缩为1×1×c，再经过非线性激活和全连接变为对应于每个通道的一个乘数，最后与输入特征图相乘。
GSoP-Net (Global second-order pooling)：
下图就是GSoP模块的结构，它类似于SE模块，采用了squeeze-excitation两个步骤。squeeze操作是为了沿着输入张量的通道维度建模二阶统计信息。首先，输入的 h ′ × w ′ × c ′ 的张量（其实就是特征图）首先通过1x1卷积降维到 h ′ × w ′ × c ，然后通道之间两两之间计算相关性，得到 c × c的协方差矩阵，这个协方差矩阵意义鲜明，第 i 行元素表明第 i 个通道和其他通道的统计层面的依赖。由于二次运算涉及到改变数据的顺序，因此对协方差矩阵执行逐行归一化，保留固有的结构信息。SENet使用GAP只获得了每个通道的均值，限制了统计建模能力。
然后，excitation模块，对上面的协方差特征图进行非线性逐行卷积得到 4c的结构信息，再用卷积调整到输入的通道数 c ′ 维度，和输入进行逐通道相乘，完成通道注意力。
GSoP-Net在压缩方式上做出了改变，将SE-Net中的一维压缩形式改为Cov的二维压缩
SRM (sytel-based recalibration module)：
squeeze模块：使用style pooling(SP)，它结合了全局平均池化和全局标准差池化。如下图所示。（输出为C × d ：当只用全局平均池化就是C × 1 ；当用了全局平均池化和全局标准差池化就是C × 2 ；当用了全局平均池化和全局标准差池化和全局最大池化就是C × 3。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0230071015b09362db34338df5a1beb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeacce7f85104ebe79f4680cb96a005b/" rel="bookmark">
			C 递归 详解（通俗易懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、定义
1.概述
2.条件
3.比较
二、 如何理解递归？
1.函数调用其他函数示例 : 2.函数调用函数自身示例 : 3.函数调用自身的底层操作 : ①在主调函数调用被调函数之前——
②在被调函数返回主调函数之前——
③在出现多个函数相互调用的情况时——
三、递归的具体实例
1.求1~100的和 : 思路 : 代码 : 优化 : 2. 汉诺塔问题 : 背景 : 思路 : 代码 : 3.斐波那契数 : 介绍 : 思路 : 代码 : 一、定义 1.概述 递归（Recursion），又称递回，是指一个函数直接或间接地实现自调用。在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。绝大多数编程语言支持函数的自调用，在这些语言中函数可以通过调用自身来进行递归。计算理论可以证明递归的作用可以完全取代循环。
计算机科学家尼克劳斯·维尔特如此描述递归：
“ 递归的强大之处在于它允许用户用有限的语句描述无限的对象。因此，在计算机科学中，递归可以被用来描述无限步的运算，尽管描述运算的程序是有限的。”
——尼克劳斯·维尔特
2.条件 ①递归必须设置一个明确的终止条件，当满足该条件时，递归停止；不满足该条件时，继续递归。PS : 如果一个递归没有设置终止条件，那么它会无限制地递归下去，形成死递归（类似于死循环），称为“死龟了”。
②一个使用了递归的函数，其处理的数据规模一定是在递减的。即，一个有效的递归，它的递归总次数是一定的，执行的次数越多，剩余的规模就越小。
3.比较 这里的“比较”，指的是递归和循环的比较。
理论上讲，可以用循环解决的问题都可以转化为用递归解决；但是用递归解决的的问题有时候并不能用循环解决。
递归结构简洁，更易理解，但是递归所需存储空间大，运行速度慢；
循环结构复杂，不易理解，但是循环所需存储空间小，运行速度快。
二、 如何理解递归？ 1.函数调用其他函数示例 : 递归本质上利用的栈的原理，满足“先进后出”的特点。要想理解递归，必须先理解函数中是如何调用其他函数的，我们先来看下面一段代码 : # include &lt;stdio.h&gt; void f1(); void f2(); void f3(); int main(void) { f1(); return 0; } void f1() { f2(); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeacce7f85104ebe79f4680cb96a005b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/347584378e3951cdf02d2d8d54fc6256/" rel="bookmark">
			虚拟机连接USB设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在window运行框内打开VMUSB服务
然后选择可移动设备，选择需要连接的设备。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46042c79f1173ad73752f740bc8488e0/" rel="bookmark">
			mac安装套件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近需要配置一个新到手的mac，在原来的一些常用工具基础上，也发现了极其好用的几个工具，手记下来~ 持续更新
Homebrew安装 Homebrew是 mac的包管理器，仅需执行相应的命令,就能下载安装需要的软件包，可以省掉自己去下载、解压、拖拽(安装)等繁琐的步骤。 比如安装服务器 nginx，打开终端执行以下命令即可安装:
brew install nginx Homebrew 官方文档 https://brew.sh/
Mac安装Homebrew的正确姿势
终端软件iterm2 Mac 最强大的终端工具之 iTerm2 详解
其中安装 oh-my-zsh 之后，主题更加美妙。oh-my-zsh 是对主题的进一步扩展，Github 地址
其中主题可见：theme
文本编辑器BBEdit 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/449fcd74c67b0adefb78715db2e2ba5a/" rel="bookmark">
			数据库备份与删除（MySQL）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用管理员模式启动cmd
#【例 1】使用mysqldump备份MySQL服务器上的stusys和stuexpm数据库到本“学号姓名”文件夹下的My_data目录下。
#【例 2】删除stuexpm数据库中各个表后，用例13.3备份文件stuexpm.sql将其恢复。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6127a8a647353f07a9a8c743a836a1a9/" rel="bookmark">
			vs2017 运行时不能调动exe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		严重性 代码 说明 项目 文件 行 禁止显示状态
错误 LNK1104 无法打开文件“R:\vs2017_program\ipsr-master\ipsr-master\\Debug\ipsr.exe” ipsr R:\vs2017_program\ipsr-master\ipsr-master\LINK 1 在开始菜单中的搜索框内输入“资源监视器”，回车，打开“资源监视器”。
在“资源监视器”界面中，点击第二个选项卡“CPU”。找到相关exe文件，右键结束进程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/964e9c807950cceb4d6131f03ba3a95b/" rel="bookmark">
			诡异-为什么使用AOP环绕通知执行Around执行2次
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因是：引用了@RefreshScope注解导致AOP环绕通知执行Around执行2次
1. 问题代码
@RefreshScope @Aspect @Component public class ControllerAspect { private final Logger logger = LogManager.getLogger(this.getClass()); @Value("${warnTime:500}") private Long warnTime; /** * 切面定义，拦截所有Controller的所有方法 */ @Pointcut("execution(* com.zhi..*Controller.*(..))") private void controller() { } @Around("controller()") public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable { logger.info("环绕通知开始"); try { return joinPoint.proceed(); } finally { logger.info("环绕通知结束"); } } } 说明：@RefreshScope配合@Value注解用于动态获取注册中心中的配置
2、日志输出结果，被拦截的方法只执行了一次，但环绕通知中的方法却执行了2次：
3、去掉RefreshScope注解后的日志输出：
说明：如果没有使用配置中心，单使用RefreshScope注解也不会出现日志输出2次的问题。
4、问题猜测
应该使用RefreshScope注解后ControllerAspect被再次代理，结合@Component总共被代理了2次。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81844cd87112eb102837e6b8b863ca55/" rel="bookmark">
			matlab of control engineers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各大符号在matlab中的表示：
t=0:0.01*pi:2*pi
alpha=3
y=sin(alpha*t)
plot(t,y)
grid
title('plot of sin(\alphat)')
xlabel('t')
ylabel('sin(\alphat)')
u1=[0:0.5:2]'
u2=[1.5:-0.5:-2]'
u3=[-1.5:0.5:0]'
w=[u1;u2;u3]
t=0:0.5:8.0
plot(t,w)
grid
绘制两个矩形：
x1=[-10 10 10 -10 -10]
y1=[-5 -5 5 5 -5]
x2=[-5 5 5 -5 -5]
y2=[-2 -2 2 2 -2]
plot(x1,y1,x2,y2)
v=[-20 20 -20 20]
axis(v)
axis('square')
grid
xlabel('x')
ylabel('y')
xp=[0 5*sin(pi/6)]
yp=[0 5*cos(pi/6)]
plot(xp,yp)
v=[-6 6 -4 8]
axis(v)
hold a=0:0.01:2*pi
x=5*sin(pi/6)+0.5*cos(a)
y=5*cos(pi/6)+0.5*sin(a)
plot(x,y)
xb=[-3 3 3 -3 -3]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81844cd87112eb102837e6b8b863ca55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc68cd39f31e4ba68720f8e717170b39/" rel="bookmark">
			系统降阶-
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的模型降阶方法有集结法、摄动法、时间矩匹配法、Pade逼近法、连分式法、Routh逼近法、Pade-Routh逼近法
时间矩匹配法：
该方法基于匹配脉冲响应的时间矩原始模型与那些相同脉冲响应的降解模型相匹配
缺点：匹配后的低阶系统模型的稳定性可能会使原来稳定的系统变为不稳定的系统
clear all
clc
num1=[1 13 40]
den1=[1 13 32 20]
num2=[0.48 2]
den2=[0.5171 1.5144 1]
step(num1,den1)
hold
step(num2,den2,'--')
连分式法：
劳斯表：
clear all clc num1=[10 171 360] den1=[1 71 702 720] num2=[6 15] den2=[1 27 30] step(num1,den1) hold step(num2,den2,'--') 如果自己用高阶系统的主导极点去降阶：
将传递函数展开成部分分式，保留最靠近虚轴的所谓‘主导’极点，而舍去那些远离虚轴的极点。主要通过特征方程求根来确定极点，但近似的性能不是特别好。
z1=-2.46,z2=-14.6
p1=-59.4,p2=-1.15,p3=-10.4
所以可以把p1省掉：
s=tf('s')
G1=(0.0167*(s+2.46)*(s+14.6))/((s+1.15)*(s+10.4));
step(G1)
采用这种方法一点也不准？？？？？？？ clear all
clc
syms s
num1=[1]
den1=[1 1 1]
G=tf(num1,den1)
step(num1,den1)
G =
1
-----------
s^2 + s + 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc68cd39f31e4ba68720f8e717170b39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0a2e74f524a6371d11247d7e7eafb4b/" rel="bookmark">
			快手查权重&#43;抖音查权重&#43;QQ查估值三合一软件工具【查询脚本&#43;详细教程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 功能：
抖音权重查询功能
快手权重查询功能
QQ估值查询直播工具
小游戏直播合集
设备要求：
安卓设备
不管你直播快手查询还是抖音还是qq估值 还是小游戏 一个app全部搞定
-------------------
文章分享者：Linxiaoyu2022
文章的来源：沉睡者IT的CSDN
获取#网络创业项目#可咨询分享者
转载必须标明分享者信息与文章来源 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e955df22d53607f9cf049600fcb45a9a/" rel="bookmark">
			主机系统扫描程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主机系统扫描程序设计 1、相关原理、技术分析1.1获得主机的网络信息1.2系统信息1.3端口信息 2、设计思路、算法描述3、详细实现（代码必须注释）4、程序测试、结果分析5、总结 1、相关原理、技术分析 1.1获得主机的网络信息 获取主机的网络信息非常简单，我们就拿获取主机的IP地址，获取主机的网卡来说
获取目标主机的IP地址 最简单的办法就是ping目标主机，就会得到IP地址，当然扫描主机也要得到IP地址，在python中用一个函数也可以搞定
获取目标主机的网卡 获取目标主机的网卡有点东西，需要使用interfaces 和 wr这两个模块，需要找到对应的注册表，再得到网卡信息
1.2系统信息 获取系统信息最好的办法就是ping目标主机，根据TTL值来判断目标系统信息，如果TTL值再53左右就是Linux系统，如果TTL值再128左右就是Windows系统，如下可以看到百度是Linux系统
1.3端口信息 端口信息我使用套接字编程实现的，我先建立一个套接字，然后与目标主机的对应端口连接，连接不成功会返回socket.error错误，根据这一点，我就可以判断目标主机开放的端口，进而推算出目标主机的服务
不同端口对应的服务：
FTP (21/TCP)SSH (22/TCP)Telent (23/TCP)SMTP (25/TCP)DNS (53/UDP &amp; 53/TCP)DHCP 67/68Kerberos (88/TCP)POP3 (110/TCP &amp; 995/TCP)RPC (135/TCP)NetBIOS (137/UDP &amp; 138/UDP)NetBIOS / Samba (139/TCP)IMAP (143/TCP &amp; 993/TCP)SNMP (161/TCP &amp; 161/UDP)LDAP (389/TCP)HTTPS (443/TCP)Linux Rexec (512/TCP &amp; 513/TCP &amp; 514/TCP)Rsync (873/TCP)RPC (1025/TCP)Java RMI (1090/TCP &amp; 1099/TCP)MSSQL (1433/TCP)Oracle (1521/TCP)NFS (2049/TCP)ZooKeeper (2171/TCP &amp; 2375/TCP)Docker Remote API (2375/TCP)MySQL (3306/TCP)RDP / Terminal Services (3389/TCP)Postgres (5432/TCP)VNC (5900/TCP)CouchDB (5984/TCP)WinRM (5985/TCP)Redis (6379/TCP)Kubernetes API Server (6443/TCP &amp;&amp; 10250/TCP)JDWP (8000/TCP)ActiveMQ (8061/TCP)Jenkin (8080/TCP)Elasticsearch (9200/TCP)Memcached (11211/TCP &amp; 11211/UDP)RabbitMQ (15672/TCP &amp; 15692/TCP &amp; 25672/TCP)MongoDB (27017/TCP)Hadoop (50070/TCP &amp; 50075/TCP) 2、设计思路、算法描述 该算法分为三步，获得主机的网络信息，获取网络信息，获取端口信息，首先获取计算机信息，platform中，有对应的函数，然后获取端口信息，直接建立套接字，再进行连接，连接不成功会返回socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e955df22d53607f9cf049600fcb45a9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b73e99d03df7d0743146942d79a289fc/" rel="bookmark">
			maven环境搭建和项目创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、创建项目 新创建一个文件夹存放代码
IDEA选择如下，打开exam文件夹 检查项目结构是否有问题
选定自己的jdk，确认有out文件夹
配置maven，如下：
修改为自己的maven和私人仓库。完成后apply
开始创建项目
进入后如下，使用脚手架快速搭建springboot项目的结构(考验网速)义，输入https://start.aliyun.com/ 使用阿里巴巴公司提供的脚手架网速不行选择Custom自定
jdk先不管，一定要选择为maven项目。
这里是选着依赖，先选择一个web，后续回去修改 确定项目名字，点击完成。
如下将创建好的项目识别为 maven项目 然后去到pom文件修改依赖如下。
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.12&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.wuzeyu&lt;/groupId&gt; &lt;artifactId&gt;springboot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot&lt;/name&gt; &lt;description&gt;springboot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b73e99d03df7d0743146942d79a289fc/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/150/">«</a>
	<span class="pagination__item pagination__item--current">151/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/152/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>