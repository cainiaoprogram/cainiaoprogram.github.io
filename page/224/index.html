<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/074737f76395939a887f8655b6e882ce/" rel="bookmark">
			JDK1.8安装以及环境变量配置(win10)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、官网下载JDK jdk下载地址：https://www.oracle.com/java/technologies/downloads/
往下滑可以看到jdk1.8的下载地址，现在官网下载需要登录，如果不想登录可以点击下面的百度云链接，有jdk1.8的安装包。
百度云下载链接 ：https://pan.baidu.com/s/1Ce0qDHxWZ3AMPu3R9B2Ajw?pwd=srau
二、jdk安装 1、双击下载好的安装包，点击下一步
2、点击更改可以选择自定位置，然后点击下一步
3、开始安装jre，点击更改选择自定位置，点击下一步
4、安装完成
三、配置环境变量 1、在桌面此电脑上右键，点击属性
2、然后点击高级系统设置
3、点击环境变量
4、点击新建，创建系统变量，变量名是JAVA_HOME，变量值选择jdk安装路径
5、找到PATH，双击打开或者点击编辑
6、点击右上角新建，输入%JAVA_HOME%\bin，点击确定
7、最后别忘了点击确定
四、验证 1、输入win+R，然后输入cmd点击确定打开命令行
命令行窗口
2、输入java -version，中间有空格，然后回车，出现版本信息则安装成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1af3728e162667011260942358935abf/" rel="bookmark">
			【论文读后感】：A simple yet effective baseline for 3d human pose estimation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接，感谢原作者
先验知识摘要引言2.相关工作3.解决方法 3.1 我们的目标——没有蛀牙！（误！是网络的设计）3.2 数据预处理 4.实验评估 4.1 定量结果 先验知识 阅读本论文，要先稍微了解一下3d人体姿态估计的一些常用方法。其中本文所涉及到的，如下：
1.一般3d姿态估计的问题描述为：以一张RGB图像作为输入，要求程序输出图像中人体主要关节点的三维坐标，比如头部、两肩、腰部，腿部等等重要关节点。
2.有些算法使用端对端的思想，直接给网络输入一张RGB图，要求网络输出重要关节点的三维坐标。当然训练的数据也是输入RGB，输出三维坐标。
3.有些算法使用两步走的思想，第一步，从RGB图像中获取到二维的重要关节点坐标。第二步，训练一个网络，该网络输入是一系列二维关节点坐标，输出是一系列三维关节点坐标。【本文就是使用这种方式，本文主要描述第二步】
4.精确的，真实的数据叫做groundtruth数据，而观测数据，生成数据等等都是不能完全信的数据，比如，现实生活中用传感器测出来的三维关节点坐标，这是groundtruth数据，而用算法估计出来的数据，就是生成数据或预测数据。对于机器学习或深度学习的其他方向，这些名词也是通用的。
好的，先验知识就这么多，现在开始本文的翻译
摘要 3d人体姿态估计领域由于深度神经网络的使用，在端对端系统预测中已经取得不错的成果。但是我们还不确定那些错误的预测是因为以下哪种原因：
1.从2d姿态（视觉）理解中出的错【就是从图像中预测图像中的2d关节点这一步骤】。
2.从2d关节点到3d关节点的映射。
所以本文就是要找到错误的根源，并解决它。我们建立了一个模型，输入2d关节点信息，输出3d关节点对应的信息。发现对于这个过程，错误率很低。然后把我们的这个模型放在最新的2d检测模型上训练。最终得出结论：大多数的3d姿态估计的错误来自于视觉分析这一步【也就是上述的第1点】。
引言 现在很多3d姿态估计的方法使用从2d图像直接向3d姿态转换的端对端方式。也有使用2d语义信息向3d姿态转换的方式。本文对第一种方式进行解耦合：
1.先利用2d图像输入来估计2d姿态。
2.利用2d姿态信息映射3d姿态。
本文实验结果显示：用2d的groundtruth关节点来生成3d的关节点错误率非常低——比目前最好的结果好了30%。而我们用从2d图像生成的用关键点检测生成的2d关节点来生成3d关节点，这样的错误率只比目前最好的结果稍微好一点。
所以本文结果显示，我们以后的精力应当放在提高2d图像向2d姿态的转化这一步骤。
此外，本文发布了一个高性能、轻量级的baseline，代码见：https://github.com/una-dinosauria/3d-pose-baseline
2.相关工作 从图像中获取深度 从纯粹的二维输入中感知深度是一个经典的问题，至少从文艺复兴时期开始就吸引了科学家和艺术家的注意，当时布鲁内莱斯基在他的佛罗伦萨建筑绘画中使用了透视的数学概念来传达空间感。
自上而下的3d推理 最早的深度估计算法之一采用了一种不同的方法:利用场景中物体的已知三维结构。当感知人体运动时，抽象成一组稀疏的点投影。
从2d到3d关节点 从2d投影推理3d关节点的方法可以追溯到 Lee 和 Chen。
基于2d到3d关节点的深度网络
3.解决方法 我们的目标是给定一个二维输入x∈R 2n，输出一个三维空间的关节点坐标估计。也就是说，我们的输入是一系列二维的点x∈R 3n 。也就是说，我们希望训练出一个函数 f ∗ : R 2 n → R 3 n 个姿态中有最小的预测错误率： 在实际操作中， xi可以是二维的groundtruth关节点坐标，也可以是根据图像估计出来的二维关节点坐标。而我们的目标就是找到一个简单的、可扩展的、高效的架构来设计一个神经网络去完成f*的任务。
3.1 我们的目标——没有蛀牙！（误！是网络的设计） 上图就是我们的网络的主要架构。我们的方法就是基于一个简单的、深度的、多层的神经网络以及批处理标准化、丢弃、RELUs以及残差连接。瞎子也能看出来，上图还有两个额外的线性层：第一个直接应用于输入，将输入增维至1024维。还有一个在产生预测之前应用，产生大小为3n的输出。在我们的实验中，我们一般有2个这样的残差块，所以一共有6个线性层，而我们的这个模型大概有4-5百万个参数需要训练。
2d/3d坐标 其他算法有使用二维原图像作为输入的，有些是以二维概率分布作为输入的，有些是以三维概率作为输出的，还有照相机参数估计作为输出的，与那些妖艳贱货不同，我们算法使用2d/3d姿态的坐标分别作为输入与输出。虽然二维所携带的信息较少，但它们的低维性非常吸引人。比如你可以吧Human 3.6M整个数据集都储存在GPU中以供训练，这样会大大地减少训练时长，而且，这样也让我们很自然地训练超参数。
线性-RELU层 大多数算法处理3d姿态估计的问题一般都是基于卷积神经网络的，因为卷积神经网络具有平移不变性。但是，因为我们以2d关节点坐标作为输入，所以我们不需要这个特性，我们可以采用更加节省成本的线性层，而RELUs则是一个标准的非线性层的选择。
残差连接 我们发现残差连接是最近提出的一种促进深度卷积神经网络训练的技术，还可以提高泛化性能、降低训练时间。在本文中，残差连接帮我们降低了10%的错误率。
批处理正则化和丢弃(dropout) 虽然有了上述的三个组件可以使这个网络在2d的groundtruth数据中表现良好，但是如果输入变成2d的估计坐标，或者在2d groundtruth数据中训练，而在有噪音的2d 观测数据中测试，那效果就不尽人意了。而批处理正则化和dropout使我们的网络在这两种情况中的性能得以提升，当然，代价就是训练时长稍稍增加。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1af3728e162667011260942358935abf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ef30397a244c3f67ac45f0a972b176a/" rel="bookmark">
			华为od js 日志排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题：日志排序 | 时间限制：1秒 | 内存限制：262144K | 语言不限
运维工程师采集到某产品现网运行一天产生的日志N条，现需根据日志时间按时间先后顺序对日志进行排序。
日志时间格式为：
H:M:S.N
H表示小时(0-23)，M表示分钟(0-59)，S表示秒(0-59)，N表示毫秒(0-999)
时间可能并没有补齐，也就是说: 01:01:01.001，也可能表示为1:1:1.1
输入描述:
第一行输入一个整数N，表示日志条数，1&lt;=N&lt;=100000
接下来N行输入N个时间
输出描述:
按时间升序排序之后的时间
如果有两个时间表示的时间相同，则保持输入顺序
示例1
输入：
2
01:41:8.9
1:1:09.211
输出：
1:1:09.211
01:41:8.9
示例2
输入：
3
23:41:08.023
1:1:09.211
08:01:22.0
输出：
1:1:09.211
08:01:22.0
23:41:08.023
示例3
输入：
2
22:41:08.023
22:41:08.23
输出：
22:41:08.023
22:41:08.23
说明：
两个时间表示的时间相同，保持输入顺序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7957633ee8903346bc190c8160e89d35/" rel="bookmark">
			ModuleNotFoundError: No module named ‘cv2‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ModuleNotFoundError: No module named 'cv2' 问题描述问题分析解决方案 问题描述 运行.py文件时遇到：ModuleNotFoundError: No module named ‘cv2’，如图：
本以为使用命令pip install cv2能够解决，但是又遇到没有找到cv2这个包的问题，如下图：
问题分析 环境中缺少cv2的包所以会出现No module named 'cv2’的问题。然后cv2的包名并不叫cv2，所以使用pip install cv2不能安装。 解决方案 cv2的包名叫opencv-python，所以cmd中使用以下命令即可解决：
pip install opencv-python 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7089ba383310d374d04929e7470b55d/" rel="bookmark">
			TICK回测二：数据如何存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交流Q群1064240775
一、概述
前一节讲了如何用极星每日批量获取TICK数据，并存到CSV文件，存储格式是：
【合约编号，时间戳，最新价】
比如：ZCE|F|AP|112,20211102145321750,8035.0
交易日11月2日，跑了ZCE全部198个合约，得到了676569条记录，CSV文件25M
交易日11月3日，跑了ZCE全部198个合约，得到了755613条记录，CSV文件28M
如果以此类推，一年约需要6600M的空间，3家交易所就是19.8G/年。想想其实也还好，但是不压缩压缩就不高端了是吧，而且上期的品种比较活跃，可能一个顶两也说不定，所以我们要考虑数据的压缩和存储。
二、数据压缩
1、合约编号没必要没必要每一行都写，可以每一个合约整一个目录，这样至少省了1/3的空间了
2、日期也没必要每一行都写，年月日也是可以用目录的形式，存行情的文件只需要写时分秒+最新价即可
那么下图中的存储方式应该就是兼具实用和压缩的最佳解了，测试了一下最终数据大小是12.8M，有效压缩了不少。
3、进一步压缩（经典办法）
可以看到，除了数值外，时间是会一直重复出现的数，而且占了9位。最经典的压缩方法就是将两两数字映射成一个ASCII字符，比如
0 - 9 = 0 - 9
a - z = 10 - 35
A - Z = 36 - 61
时间显示中，最多24小时、60分钟、60秒，所以14时05分52秒可以映射成e5Q这样的字符，妥妥的缩小了1倍空间。
接着我们看毫秒位只显示了000、250、500、7500四种情况，所以也可以简单映射下000=A、250=B、500=C、750=D。
于是14时05分52秒750毫秒就映射成了e5QD，字符串的宽度由9位变成了4位超过50%的压缩比，实测了一下最终大小是8.68M。
4、继续压缩（差值法）
我们可以注意到，行情的数值经常是重复且连续的，像下图这样，就是重复的4个数值。同时772.0完全可以理解为772.2-0.2，那么我们能不能用前后差值的办法来进一步压缩数据呢。
比如像下图这样，对于数值越大的效果越明显。
实测结果是6.95M，效果不错。
5、用差值法来压缩时间
前面用差值法来压缩数字效果很好，如果时间也用差值法是否可行呢？我们试试看。
可能需要做一些调整，首先不能用年月日时分秒这样的时间格式，得用时间戳，不然不好做减法对吧。其次毫秒位要单独拉出来继续按ABCD映射，因为本来就只占一位，没必要搞什么减法了。但前面时间戳的差值位数不好说，所以可以将毫秒位映射的字母放在最前面。大概是下面这个意思：
2021-11-06 14:55:27.250 -&gt; B1636181727
2021-11-06 14:55:28.500 -&gt; C1
2021-11-06 14:55:29.000 -&gt; A1
实测结果是5.64M，效果并不明显，而且往回转的时候比较麻烦，所以时间还是用ASCII码来压缩。
三、总结
最终我采用了时间用ASCII码映射的办法，数值部分用差值法，总体压缩率在25%左右，还算是有一点用处。
还有没有进一步压缩的空间呢？有的，但是没有必要的，一家交所全部合约，一天的数据不到7M，够了，就算再压缩一倍到3.5M，没有意义了，不是数量级的差异。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6722215cb37a80316a7b09853e152f1b/" rel="bookmark">
			浅析一致性哈希算法的原理及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.分布式缓存问题 以上是单节点环境下，但随着流量的增大，可能就演变为了如下情形：
❓这个负载均衡算法该如何设计最为合理呢？
首先能想到的最简单的方法可能就是随机或者轮询，这样会产生两个问题：一是数据冗余；二是数据可能已经被缓存，但请求却命中了不存在该数据的节点上。
如何解决这个问题？只需要保证相同的key被发送给相同节点上即可。再一想这不就是hash算法嘛【index = hash(key) % n】（n为节点的数量）
public class SimpleHash { public int loadBalance(String key) { return hash(key) % 3; } private int hash(String key) { int hash = Math.abs(key.hashCode()); ..... ..... return hash; } } 这种算法它的容错性和扩展性不是很好；一旦某个节点宕机或者加入新的节点时，导致n发生了变化，需要重新hash计算，这样可能导致大量缓存不命中，一瞬间给磁盘数据库造成了很大的压力。
容错性是指当某个节点宕机时，整个系统是否可以继续高效运行；扩展性是指加入新节点时，整个系统是否可以高效运行。
所以这种简单的哈希算法并不适用于实际场景，而本文所讲的一致性哈希算法解决了大量哈希重定位的问题。
2.一致性哈希算法 一致性哈希引入了一个虚拟的圆环，这个圆环有2^32个节点组成(0~ 2^32）；
📚它的原理如下：
(1)对每个缓存服务器的IP作为key进行哈希计算，得到的结果一定分布在环上。
(2)对每个数据作为key进行哈希计算，得到的结果也一定分布在环上
按照顺时针，第一台遇到的节点就是该数据定位到的服务器。
❓当节点宕机或者添加新的节点时，它会出现什么样的结果呢？
public class ConsistentHash { private static final String[] NODES = {"123.23.34.1", "123.52.2.1", "43.122.54.1"}; //模拟环形哈希表 private static final SortedMap&lt;Integer, String&gt; CIRCLE_Map = new TreeMap&lt;&gt;(); static { for (String node : NODES) { int index = hash(node); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6722215cb37a80316a7b09853e152f1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b9bbc8a1bbc4788019bea7581b914dc/" rel="bookmark">
			高通常见nv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Qualcomm】在EFS的NV项中打开voice通话自动接听 1. set NV 5280 to 0
2. set NV 74 to 1
3. 重做EFS烧写验证即可。
【Qualcomm】在EFS的NV项中关闭VoLTE高清语音服务 VoLTE功能开关：
NV67218 = 1 enable（IMS）
NV67218 = 0 disable（IMS）
重新制作EFS即可。
【EFS】NV65633-LTE搜网能力的NV值、格式、配置 1、QPST从设备重backup出静态.qcn
2、QRCT将.qcn转换生成.xml配置文件
3、从.xml文件中检查/nv/item_files/modem/mmode/lte_bandpref的配置值和格式
标准格式：
213,0,8,0,160,1,0,0
6828 == 6829 == 1786958649567
十进制： 1786958649567
十六进制： 1A00F0918DF
补全高位5个0
00 00 01 A0 0F 09 18 DF
0 1 2 3 4 5 6 7
倒置，并用逗号隔开：
223,24,9,15,160,1,0,0
------------------------------------------------------------------------------------
NV 65633 /nv/item_files/modem/mmode/lte_bandpref
HH41CM band [ 1 3 5 7 8 20 26 28 38 40 41 ]id card
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b9bbc8a1bbc4788019bea7581b914dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0942d49decac5553187eddc4ca0a123/" rel="bookmark">
			3.0、Java多线程——实现多线程同步下载图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.0、Java多线程——Java多线程实现图片同时下载 第一步：在pom.xml文件中导入相关依赖，如下：
&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt; &lt;/dependency&gt; 第二步：创建 TestThread.java 文件，代码如下：
package com.hkl.demo01; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; //练习Thread , 实现多相处同步下爱图片 public class TestThread2 extends Thread { private String url; //网络图片地址 private String name; //保存的文件名 public TestThread2(String url,String name) { this.url = url; this.name = name; } @Override public void run() { WebDownLoader webDownLoader = new WebDownLoader(); webDownLoader.downLoader(url,name); System.out.println("下载的文件名为：" + name); } public static void main(String[] args) { TestThread2 t1 = new TestThread2("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0942d49decac5553187eddc4ca0a123/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495fb6664558b1c03fda7dc9566db3e7/" rel="bookmark">
			性能测试学习之jmeter单场景使用示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 做性能测试主要用于检测系统性能是否符合需求标准
以上为性能测试流程
需求分析，分析系统性能指标准备环境、工具和场景准备脚本，基于不同的性能场景完成测试准备执行脚本，获取数据判定指标是否满足要求如果达标，还会继续进行下一步性能测试，了解系统阈值，测试系统是否具备抗风险能力不达标则进入性能诊断
比如：CPU占用过高，响应时间下降，吞吐量下降，硬件资源占用上升
首先检查那个进程占用过高内存，查看该进程下哪个线程造成的，从线程定位到代码给开发人员提出优化建议 提示：以下是本篇文章正文内容，下面案例可供参考
示例1：首页支持5个用户并发，时间在3s内，容错率不超过2% 1、新建线程组 1、线程组相当于用户组，多少个线程相当于多少个用户，所有取样器都在线程组下，所有任务都基于线程组；
2、ramp-up period就是启动设置的线程所需要的时间。如果选择了10个线程，并且ramp-up period是5秒，那么JMeter将使用5秒使10个线程启动并运行。1s就要启动两个线程。（这个启动线程所需时间是自己设置的，具体根据项目的服务器性能来设置，如果设置的时间过短，服务器性能不足，也会影响后面的执行的结果）
3、循环就是规定时间循环执行的次数。 比如线程数10，时间是5秒，循环2次，也就是说，一秒会执行两个线程2次循环，一秒并发4次请求；
按照题目要求支持5个用户并发，即设置5个用户
2、设置HTTP请求 设置协议、IP、端口、路径
以百度为例
3、设置监听器 有用户数，先设置活跃线程数的监听器（active threads）响应时间——response over time错误率——聚合报告
4、启动 5、查看结果 1.首先查看活跃线程数
从快接近第5 s开始，红线接近平缓，所有用户都正在运行，所以查看响应时间的报告时，也应该从第5s开始看,20结束
2.查看响应时间
从第5秒开始查看响应时间，最高不超过800毫秒
3.查看错误率
打开聚合报告
异常率为0，并且百分之99的时间里，平均响应时间是133毫秒，符合本次性能测试要求
示例2：访问首页响应时间不超过3s，最多能支持多少用户并发？ 两种方案：
（1）根据服务器性能，估算一个最大用户数，根据测试结果，将原用户数加（或减）原用户数的一半（100用户，性能未达到瓶颈，人数则为100+100/2=150），知道获取到最大用户数
（2）每隔10s增加一个用户
此处使用第二种方式进行测试
1、 新建线程组 逐步加压的线程组使用ultimate thread group（比起普通的线程组更加准确，因为普通线程组加用户时候是取平均值，只要在10s完成即可）
2、添加http请求 与示例1一致，可直接复制
3、监听器与结果 访问首页响应时间不超过3s，最多能支持多少用户并发
有用户数，先设置活跃线程数的监听器（active threads）响应时间与用户数的关系（response times vs threads）错误——聚合报告、查看结果数
根据以上结果可修改用户数为初始线程数为700，每秒增加5个线程数
直至得到最后3s内最多支持多少用户并发 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4363d39fc42cd6e11bcce96823f9412/" rel="bookmark">
			云GPU运行yolov5模型训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.为啥需要云训练呢？
一般来说，模型训练的时间长达十几个小时，而且对于运行设备的要求极高，一般的学生（比如说我）想拿自己的笔记本电脑跑训练的话，首先就可能因为GPU的设置问题跑不起来，就算跑起来了，速度也很慢，而且对于电脑的伤害是很大的。
2.恒源云GPU 恒源云_GPUSHARE-恒源智享云
在控制台-我的实例 中，点击创建实例
接下来选择想租什么配置的设备，操作系统建议会linux的就linux，实在不会才windows（后面的操作步骤是linux的命令），计费模式建议按量付费，也就是按小时付费
然后如图选择预装的python环境（尽量和yolo的版本匹配）最后点击创建实例。
然后先别着急开机，开机就计费了。如果系统默认开机，赶紧关机。
如图打开帮助文档（文档中心），找到 数据上传里面的OSS命令上传，后面就是照做，把自己的项目文件夹打包传上去。
这里软件下载是按照自己电脑的系统，注意不要搞混 如果实在不会使用oss，也可以参考文档里的其他方式（xftp等），上传速度可能会很慢 以下是oss的操作过程
下载完之后运行，然后login（登录用的是你注册网站的账号）
然后使用linux的文件命令将本地的项目压缩包上传到文件系统中
cp （你的压缩包路径） oss:// 这样就算成功
接下来无卡启动（为了省钱，该模式下内存只有1G，费用是0.1元/小时）
启动完之后使用JupyterLab进行操作 （从这里开始是linux系统下操作，如果前面实例创建选择了windows系统，请类比操作或参考帮助文档）
打开一个命令行，先进入hy-tmp目录
登录oss客户端
oss login 从oss文件系统中下载项目压缩包
oss cp oss://dataset/yolov5.rar ./ 这样就上传好了
解压rar包
7z x yolov5.rar 然后就可以在这个终端上正常运行项目啦
一般来说库的都是预装好的，也可以检查一下 可以在训练代码的最后一行加上 import os os.system('shutdown') 这样训练完就自动关机了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ccb3f452cbd06b0a5ff2857a2b238b/" rel="bookmark">
			git发起合并请求时提示存在冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此时我本地有一个主分支 develop ；然后我根据 develop 主分支创建了一个 work/BCS-298 分支； 1. 我在本地 work/BCS-298 分支中修改了代码，准备 push 推送到远程 work/BCS-298 仓库； 2. 我在 push 本地 work/BCS-298 分支代码之前，先更新了本地 develop 主分支代码； git stash // 保存本地分支修改 git checkout develop // 切换到主分支 git pull // 拉取主分支最新代码到本地仓库 git checkout work/BCS-298 // 切换到 work/BCS-298 分支 git merge develop // 将本地分支 develop 合并到当前 work/BCS-298 分支中 此时我这里是没有冲突（有的人可能会有冲突，按照下面 第8步 操作即可）
3. 我将本地分支 work/BCS-298 的代码 push 到我自己的远程 work/BCS-298 分支上 git add . git commit ... git push 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07ccb3f452cbd06b0a5ff2857a2b238b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cd0ae1bad67ddf912ddcab2afcb1a2a/" rel="bookmark">
			OpenCV DFT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二维图像的DFT 离散傅里叶变换，图像的频域表示的是什么含义呢？又有什么用途呢？图像的频率是表征图像中灰度变化剧烈程度的指标，是灰度在平面空间上的梯度。图像的边缘部分是突变部分，变化较快，因此反应在频域上是高频分量；图像的噪声大部分情况下是高频部分；图像大部分平缓的灰度变化部分则为低频分量。也就是说，傅立叶变换提供另外一个角度来观察图像，可以将图像从灰度分布转化到频率分布上来观察图像的特征。
频域在图像处理中，就我所知的用途主要在两方面：图像压缩和图像去噪。关于这两点将在下面给出图片DFT的变换结果后说明。
有关DFT的更多性质请参考胡广书教授的《数字信号处理》教材。
提到图像频域变换的用途：压缩和去噪。压缩的原理就是在频域中，大部分频域的值为0（或接近0，可以进行有损压缩，如jpeg图像），只要压缩频域中的少数非0值即可达到图片压缩的目的。去噪则是通过频域的滤波实现，因为噪声大部分情况下体现为高频信号，使用低通滤波器即可滤除高频噪声（当然，也会带来损失，那就是边缘会变得模糊（之前说过，边缘也是高频信号））。
计算幅值：magnitude()函数
void cv::magnitude(InputArray x,InputArray y,OutputArray magnitude) 参数说明：
x : 实部，矢量的浮点类型
y : 虚部，矢量的浮点类型
magnitude ： 目标图像
将实部和虚部转换为幅值 Transform the real and complex values to magnitude 一个复数有实部（Real - Re）和虚部 (imaginary - Im) 。DFT的结果是复数。幅值用下面公式计算：
截取并重新组合图像 Crop and rearrange 将幅度图像转换为偶数。并且重新组合图像象限，让原点（0,0）位于图像中心。
// 重新排列变换结果，让原点处于图像中心。rearrange the quadrants of Fourier image so that the origin is at the image center // 变换结果图像中四个角到中心是低频到高频，为了符合坐标系，将其分为四份重新排列，让四个角处于中心位置 int cx = magI.cols / 2; int cy = magI.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cd0ae1bad67ddf912ddcab2afcb1a2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd435543e6afdef95d193c329aa2b62f/" rel="bookmark">
			大龄程序员都去哪了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大龄程序员都去哪了？
大龄程序员依然在各个大中小公司正常工作。
外资、国企不说了，30-40岁的员工很多很多，不仅仅是程序员，产品啊，测试，运维。
不仅仅喝计算机有关系的，行政，hr，财务也是30-40岁得人数据主力。
随便举一些例子吧（我不知道的不举，只说计算机相关的）。
外资比如花旗银行，比如美国运通，ebay
国企比如邮政，兴业，广发，中金公司，中信
不但算外资也算国资的..比如kfc，比如迪士尼，比如大众，
规律就是越历史悠久的公司越不care大龄员工或者依赖大龄员工。
特别是比较核心得岗位不会让小屁孩来干。
第二个各个bat等大厂统计一下p8，p9所有员工30以上的有多少（成立年限越长，30以上越多）
也是一样核心岗位都需要10年以上经验的人。
第三各种小中公司以及部分创业公司更是高度依赖大龄程序员。
大家看下：23岁毕业，33岁才能到10年。算是熟悉了行业规则了。这样就失业了？？？
你说你怎么看不到大龄程序员。因为你找的公司只需要小朋友，而我在等公司不要小朋友。
你面试的公司面试要求lecode多牛逼
我面试得公司要求最低工作年限5年，最好8年以上。
我已经很久没有做leecode以及算法数据结了，
我面试就是和cto，ceo（小公司）中大公司（技术总监）直接聊架构+技术方案，以及落地思路。
我偶然去面试过那些年轻化的公司，上来就是手写算法数据结构，然后说你连实习生都不如。就没有然后呢，我都没开始讲我如何处理几万并发，以及亿级数据快速响应呢，就让我走了。
好，我按照小年轻做出他们擅长的，算法题，开始问我技术问题。请问你怎么处理高并发，我如实回答 nginx挂10台，每台3k并发。低成本亲亲松松处理3w并发。
不是他想听到的微服务限流降级熔断。于是技术栈比较落后.拜拜。
下一次我面试，我回答我司这边用的springcloud aliabba，限流怎么做，熔断怎么做，降级怎么做，
链路追踪怎么做，微服务循环依赖怎么解决，分布式事务怎么解决，分布式id，分布式各种怎么解决…
好，挺不多的。但是你不适合我们公司。
于是我还是去了喜欢大龄（大个鸡儿30-40岁就大龄）得公司，月薪4w，年终2-3个月，早上10点上，5点下班，没有业绩没有kpi。
这辈子估计都不会取字节跳动这种了吧。虽然我无数次幻想过。
成年人以家庭优先，能赚钱能眷顾家庭ok了，反正我早就买了三套房，全家人保险买好了，上海户口搞定。
想去腾讯和字节，就想想吧。
大龄程序员好好的，和大龄产品经理大龄测试大龄运维一起工作呢。
90年出生的我还是宝宝呢，居然说我大龄。
哦，我娃都4岁了，我确实老了。那又怎么样，我喜欢玩技术我喜欢编程又有人愿意要我给我的钱让我满意，差不多得了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9764b11f7a02458a0d86a5f340dd8465/" rel="bookmark">
			【Linux】ansible批量管理服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 前言一、概述1.1 ansible简介1.2 ansible安装 二、剧本2.1 剧本组件2.2 角色详解2.3 剧本语法2.3.1 基本语法2.3.2 常用字段2.3.4 常用模块 三、思维导图 前言 本博客内容仅为记录博主思路，仅供参考，一切以自己实践结果为准。
一、概述 1.1 ansible简介 服务没有客户端存在，通过模块对节点服务器进行控制模块具有幂等性，重复的操作不会报错能够批量配置、部署、管理上千台主机 1.2 ansible安装 仅需在控制主机安装ansible服务即可（本质是通过ssh进行连接控制） #安装epel源 yum install -y epel-release #安装ansible服务 yum install -y ansible #编辑主机清单配置 vim /etc/ansible/hosts #生成非对称秘钥 ssh-keygen -t rsa #传输给节点主机，实现免密登陆 ssh-copy-id root@IP 二、剧本 2.1 剧本组件 组件释义tasks任务variables变量templates模块（核心）handlers处理器roles角色 2.2 角色详解 在配置文件：/etc/ansible/hosts总定义角色组 #自定义组 [mysql] #选择所有组 all #组合组（多个组在一起） [组集合名:child] #设置组变量 [组名：vars] 2.3 剧本语法 2.3.1 基本语法 大小写敏感、大小写不同则含义不同缩进敏感、用缩进表示层级关系缩进不允许用tab键、只能识别空格文本中空格的数量不重要，只要左侧对齐，则层级相同 2.3.2 常用字段 remote-user：用什么身份登录tasks：子条目编写角色将要执行的任务become:yes：表示切换用户执行become_user:用户：切换为对应用户进行执行– name：定义下方操作的名称（方便维护） 2.3.4 常用模块 模块释义command：命令模块执行后方的Linux命令cron：周期任务模块定义周期性执行任务（相当于crontab -e）user：用户模块创建/删除用户group：组模块创建/删除组copy：复制模块将本机文件复制到其他机器file：文件模块对文件进行增删操作ping：ping模块检测机器是否正常通信service：服务模块配置其他机器是否开机自启等yum：yum模块控制机器通过yum安装服务shell：脚本模块控制机器使用shell脚本（非幂等性操作） 三、思维导图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/221c678db9dfca3345930d7b065c3472/" rel="bookmark">
			可重构计算处理器设计实例REMUS——REMUS总体硬件架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前半年看了一些关于CGRA的论文，但是对从硬件架构到编译的整体还有没有很系统的认识。
跟我导借了本书，拓展知识面一下，顺便做个笔记（不定时更新）
1.1 REMUS的硬件架构
REMUS 多标准视频解码可重构计算处理器
主要用于多媒体领域内的视频解码应用。除此之外还拓展实现了通信基带处理领域内的全球定位系统算法（GPS算法），计算机视觉领域内的Adaboost算法（这个算法 西瓜书上有介绍哎）、SIFT算法和SURF算法，以及密码学领域内的多种加密算法（这个领域俺就一窍不通了）
多层系统主线：连接外设控制器、DMA控制器（这个DMA貌似是用于划分bank的？）、片上存储器、片外存储控制器
配置总线：主控制器通过配置总线，对可重构处理单元（reconfigurabale processing unit PRU 整个系统中的核心模块）进行控制，RPU通过设置片外存储控制器对其进行读写访问
可以看到，REMUS分为两大块：可重构数据通路和可重构控制器。
在这里是不是应该解释一下何为 配置，何为 可重构。是这样的，可重构处理器。
补充小知识：
可重构处理器长这样，里面每个PE算作一个计算单元嘛，可以通过配置，来重构这些PE的功能。这样可以达到一次配置多次执行（也就是刚刚开始配置好了，然后让数据在片上进行流水线运动，因为一般是处理循环这种密集型计算嘛）。
其中编译在里面起到的作用就很关键，因为循环中的kernel千变万化撒，怎么样让kernel中这些算子，满足这些资源约束、依赖约束一一映射到PE阵列中呢？
其中有两种映射方法：空间映射和时域映射（在这里就不展开讲了，后续应该会补充）
回到正题
首先，其中的可重构数据通路包括系统级的可重构数据通路和RPU内的可重构数据通路。
系统级的可重构数据通路包括：片外存储器、DMA控制器、片上存储器、片外存储控制器。
其运行流程为：DMA控制器被系统中的主控制器设置后，通过片外存储控制器访问片外存储器，将数据从片外存储器读出并且写入到片上存储器（或者将数据从片上存储器写入片外存储器）
RPU内的可重构数据通路包括：运算单元阵列、输入数据存储器、输出数据存储器、中间数据存储器、内部DMAC控制器。
其运行流程如下：
1.内部DMAC控制器通过设置片外存储控制器将原始数据从片外存储器读出并且写入RPU内部的输入数据存储器
2.PEA（也就是PE阵列）从输入数据存储器中读取数据并对数据进行运算
3.运算结果存于输出数据存储器，并将中间运算结果存于中间数据存储器
4.待多次运算全部完成后，内部DMAC控制器将结果数据从输出数据存储器中读出，并通过片外存储控制器写出至片外
其次，REMUS可重构控制器也分为系统级可重构控制器和RPU内的可重构控制器。
系统级可重构控制器由主控制器和配置总线组成，主控制器采用ARM7来实现，包含系统控制、RPU控制。其中，系统级控制任务通过多层系统总线对系统中的外设控制器、DMA控制器和片外存储控制器进行控制，已完成对系统级的控制。
RPU内的可重构控制器包括配置信息解析器、配置流程控制器和配置存储器。PRU中的控制任务包括通过配置总线向RPU写入配置信息，以完成对RPU运行的控制。
其运行流程如下：
1.配置信息解析器对主控制器写入的配置信息进行解析。
2.配置流程控制器中根据解析出的配置信息对配置存储器的读访问进行控制，已完成对配置流程的控制。
3.从配置存储器中读出的配置信息被写入到RPU内的可重构数据通路，已完成对数据通路的功能配置。
4.数据通路在完成运算之后，将完成信号反馈回配置流程控制器，以触发下一次对配置存储器的读访问。
在REMUS中，FSM（有限状态机？）被分为带有分支部分和顺序执行部分。带有分支的部分被分配到主控制器上，通过软件的方式来实现。顺序执行部分有RPU内的配置流程控制器来实现。这种复合的处理方式可以用专用的配置流程控制器来对FSM中顺序执行部分进行加速。
REMUS分为两个版本，分别是REMUS高性能版本和REMUS低功耗版本。二者区别在于包含的RPU个数。前者有两个RPU，后者一个RPU。每个RPU中包含有一个规模为1616的运算单元阵列。
REMUS高性能版本主要应用于高清分辨率（19201080）的视频码流的实时解码，REMUS低功耗版本主要应用于低分辨率（720*480）的视频码流的实时解码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1e0f61fac2bf81200e8dfe57075d43f/" rel="bookmark">
			网络运维系列：Ubnt ER-X初始化和开启硬件NAT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 路由器初始化 电脑通过网线连接Ubnt ERX路由器第一个WAN口（默认只有第一个网口可用），通过浏览器访问控制台，初始化配置，将第一个口设置为WAN口，第二个口设置为LAN口
2. 固件版本升级 下载最新版本即可，初始固件版本相对较低建议升级以提升整体路由器的稳定性，官网固件下载地址
3. 开启硬件NAT 开启NAT需要使用SSH登陆，帐户为在初始化设置的管理员账户，相比较于通过CPU来进行NAT转发，开启硬件NAT将大幅降低CPU的利用率，从而可以利用CPU做一些其它的事情。
show ubnt offload configure set system offload hwnat enable commit save sudo reboot 4. 光猫更改桥接模式 为什么将光猫更改桥接模式，电信运营商的光猫核心的一个作用是将光信号转化为模拟信号，除此之外一般家用的过程中还充当了路由器来进行运营商的拨号。 在充当路由器的角色中由于需要进行局域网地址更改为网关地址的工作即NAT，光猫的硬件会严重制约网络的出口带宽，而将光猫更改为桥接模式只单纯处理包转发，通过自己性能更强的路由器来进行拨号和NAT转发。
5. LAN口设备变更为无线中继 全部的网络全部通过弱电箱的Ubnt ER-X来进行拨号和实现路由功能。 通过LAN口接入的网络路由器全部更改为AP模式，通过无线中继或是有线中继功能全部连接到LAN口，避免二次NAT对性能的损耗。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c94c98460fdc13f23e609ce775842b4/" rel="bookmark">
			【高等数学】高数整理：常见等价无穷小、导数和微分、微分方程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常见等价无穷小 当 x → 0 x\rightarrow0 x→0 时， sin ⁡ x ∼ x \sin x \sim x sinx∼x
tan ⁡ x ∼ x \tan x\sim x tanx∼x
arcsin ⁡ x ∼ x \arcsin x \sim x arcsinx∼x
arctan ⁡ x ∼ x \arctan x \sim x arctanx∼x
e x − 1 ∼ x e^x-1 \sim x ex−1∼x, a x − 1 ∼ x ln ⁡ a a^x-1 \sim x \ln a ax−1∼xlna
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c94c98460fdc13f23e609ce775842b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/875054ccc67f8069cf35e55950f761fa/" rel="bookmark">
			什么是闭包，闭包的优缺点，闭包的使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 闭包是指有权访问另外一个函数作用域中的变量的函数
闭包的优点 可以重复使用变量，并且不会造成变量污染
全局变量可以重复使用，但是容易造成变量污染。局部变量仅在局部作用域内有效，不可以重复使用，不会造成变量污染。闭包结合了全局变量和局部变量的优点。 可以用来定义私有属性和私有方法。
闭包的缺点 比普通函数更占用内存，会导致网页性能变差，在IE下容易造成内存泄露。
什么是内存泄漏 首先，需要了解浏览器自身的内存回收机制。
每个浏览器会有自己的一套回收机制，当分配出去的内存不使用的时候便会回收；内存泄露的根本原因就是你的代码中分配了一些‘顽固的’内存，浏览器无法进行回收，如果这些’顽固的’内存还在一直不停地分配就会导致后面所用内存不足，造成泄露。
闭包造成内存泄漏
因为闭包就是能够访问外部函数变量的一个函数，而函数是必须保存在内存中的对象，所以位于函数执行上下文中的所有变量也需要保存在内存中，这样就不会被回收，如果一旦循环引用或创建闭包，就会占据大量内存，可能会引起内存泄漏
内存泄漏的解决方案 造成内存泄露的原因：
意外的全局变量(在函数内部没有使用var进行声明的变量)console.log闭包对象的循环引用未清除的计时器DOM泄露(获取到DOM节点之后，将DOM节点删除，但是没有手动释放变量，拿对应的DOM节点在变量中还可以访问到，就会造成泄露) 如何避免闭包引起的内存泄漏：
在退出函数之前，将不使用的局部变量全部删除，可以使变量赋值为null //这段代码会导致内存泄露 window.onload = function(){ var el = document.getElementById("id"); el.onclick = function(){ alert(el.id); } } //解决方法为 window.onload = function(){ var el = document.getElementById("id"); var id = el.id; //解除循环引用 el.onclick = function(){ alert(id); } el = null; // 将闭包引用的外部函数中活动对象清除 } 避免变量的循环赋值和引用(代码如上)由于jQuery考虑到了内存泄漏的潜在危害，所以它会手动释放自己指定的所有事件处理程序。只要坚持使用jQuery的事件绑定方法，就可以一定程度上避免这种特定的常见原因导致的内存泄漏。 //这段代码会导致内存泄露 $(document).ready(function() { var button = document.getElementById('button-1'); button.onclick = function() { console.log('hello'); return false; }; }); //当指定单击事件处理程序时，就创建了一个在其封闭的环境中包含button变量的闭包。而且，现在的button也包含一个指向闭包（onclick属性自身）的引用。这样，就导致了在IE中即使离开当前页面也不会释放这个循环。 //用jQuery化解引用循环 $(document).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/875054ccc67f8069cf35e55950f761fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75a7ad1819a4257f7ae0df70b79a60a0/" rel="bookmark">
			网络运维系列：网络出口IP地址查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景 在日常研发的工作过程中很少会需要了解自己的网络出口的IP地址是多少，网络出口IP地址和机器IP地址不是同一个概念，那具体什么情况下会需要知道自己的网络出口IP地址呢？ 一般在与外部机构进行安全访问的情况下，机构会将我们的IP地址或是IP段添加到防火墙的白名单中，进而提升整体的安全性。
2. 如何查询出口IP地址 在终端下执行curl https://www.cip.cc即可查询到我们的出口IP地址，多次查询可能会有所变化，短时间一般是同一个出口IP地址，主要是由于IPV4的地址的稀缺性，个人的家庭宽带一般情况下都不是固定的IP地址，会随着时间的变化而变化。
3. 云服务器的出口IP地址 云服务器的出口IP地址是否也是一样的查询呢？ 同样的命令是可以查询，但是云服务器会共用多个出口IP地址，多次请求可能是不一样的出口IP地址，针对云服务器一般推荐与云服务器提供商进行确认，一般情况下每个机房单元出口IP地址都在固定IP段内，比如：115.197.10.1/255.255.255.0，在与外部机构交互的话我们需要提供IP+掩码的形式给到外部机构，添加到白名单中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a9600f112459fd9b1a4ac2092e6b61c/" rel="bookmark">
			二叉树，遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分先根，中根，后根遍历。
已知7个节点的二叉树的先根遍历是1 2 4 5 6 3 7（数字为节点的编号，以下同），中根遍历是4 2 6 5 1 7 3，则该二叉树的后根遍历是（）。
已知条件可以知道，
最高的节点应该是1。左节点的数据是：4 2 6 5，右节点：7 3又由先根遍历，二层节点：2 3最后考虑三层的左右节点：
2的左节点4，右节点5，5的右节点6
3的左节点7。
所以后根遍历为：4 6 5 2 7 3 1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b95e22111a00a261910a3173f5fbd2ac/" rel="bookmark">
			输出和输入的一模一样（最复杂的复制）（可能会有错，请大家多多指教）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;
int main()
{
char a[100];
char ch;
int i=0;
while((ch=getchar ( ))!='\n')
{
a[i]=ch;
i++;
}
a[i]='\0';
cout&lt;&lt;a;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d3e06b73d31d21afc52bf3f018b1407/" rel="bookmark">
			【C#】VS中写C#无法使用complex等问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 最近在写C#工控上位机软件，为项目测试做铺垫，要使用到 FFT 来对数据进行处理，遇到使用复数的时候不能使用Complex来直接写。这个问题简单到爆，很快就解决了，但是对于新手来说肯定是找不到的（笑），所以干脆写出来方便新手在网上搜索。
原因 由于没有System.Numerics导致
而你在项目中直接写
using System.Numerics; ，这时候你本身项目中就没有这个程序集，所以直接用肯定也不行。
解决方法 这时候需要手动添加一下这个框架 在解决方案管理器中对项目点击右键 选择添加-&gt;引用 在搜索栏中搜索System.Numerics框架 添加即可 最后使用的时候记得
using System.Numerics; 结束 成功解决，各位新人在之后找不到其他程序的时候也记得这样添加一下哦！：D
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afbaa9f1aff6b12766685005808aee4e/" rel="bookmark">
			简单高效解决逆向工程，字段没有注释，注释是英文，问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我要中文注释！！！问题思路，简单的配置了suppressAllComments = false之后，一些小伙伴十分懵逼，出来一堆英文注释，根本不是自己需要的。然后各种拼命往上找办法，找资源，一顿乱搞，没搞定。要么是操作繁琐，要么是配置困难。
本人对那些胡乱发帖子却搞不定问题的行为深恶痛绝。
下面是解决办法。
先把我的资源里面（我传到csdn的文件）
MyCommentGenerator.java下载后放在本地
然后在
generatorConfig.xml的下边代码区域
&lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="false"/&gt; &lt;/commentGenerator&gt; 替换成 &lt;commentGenerator type="org.spring.springboot.dao.MyCommentGenerator"&gt; &lt;/commentGenerator&gt; 问题直接搞定，自愿打赏谢谢。
上述文章参照了改文章，但是做了些许改动方便了大家的使用配置：mybatis-generator自定义注释生成_一头磕在键盘上的博客-CSDN博客
MyCommentGenerator.java文件下载链接，文件路径，下载文件，都在这里：mybatis-generator自定义注释生成_一头磕在键盘上的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05ff9b3f645a40712a201da0a5cf5acb/" rel="bookmark">
			短视频矩阵运营系统，多账号管理，视频一键分发的开发逻辑分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 目录
文章目录
前言
一、矩阵号系统是什么？
二、使用步骤
1.创建推广项目
2.多账号授权
3.企业号智能客服系统
总结
前言
短视频多账号矩阵系统，通过多账号一键授权管理的方式，为运营人员打造功能强大及全面的“矩阵式“管理平台。使用矩阵系统也能保证账号的稳定性，降低账号的风险性，因而矩阵号目前也逐渐成为各商家账号经营的标配。
一、矩阵号系统是什么？ 账号矩阵是通过不同平台不同账号之间建立联系，通过将同一品牌下不同平台不同账号的粉丝流量进行账号互通，根据平台不同的规则及内容，来输出企业及品牌信息，通过矩阵的形式提升粉丝数量及账号商业价值。矩阵号的运营模式可以是多平台、多账号，也可以是单平台，多账号。
目前常用做短视频矩阵的平台有抖音、快手、百家号、西瓜、头条等几大热流平台，通过调查分析，目前抖音坐拥亿级流量，成为商家流量必争之地。所以我们下面分析也主要以抖音短视频平台为例。
二、使用步骤 1.创建推广项目 注意：
(1) 创建需要推广的产品信息，且选择素材组合模式
（2）场景组合数：可自定义素材场景数量 （3）可自定义设置素材生成的视频长度及数量，按需生成
代码如下（示例）：
import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns import warnings warnings.filterwarnings('ignore') import ssl ssl._create_default_https_context = ssl._create_unverified_context 2.多账号授权 多账号授权支持多平台，如：抖音、快手、百家号、B站。西瓜。头条等几个主流短视频平台，支持账号分组，账号数据统计，及粉丝分布及画像信息查看。
代码如下（示例）：
// Import classes: //import com.douyin.open.ApiException; //import com.douyin.open.api.OauthCodeApi; OauthCodeApi apiInstance = new OauthCodeApi(); String clientKey = "clientKey_example"; // String | 应用唯一标识 String responseType = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05ff9b3f645a40712a201da0a5cf5acb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6beb59a8b3755ee44b4be53981e7c6db/" rel="bookmark">
			小红书商品详情API接口（item_get-获得小红书商品详情接口）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小红书商品详情API接口（item_get-获得小红书商品详情接口）代码对接如下：
1.公共参数
名称类型必须描述keyString是调用key（必须以GET方式拼接在URL中，点击获取请求key和secret）secretString是调用密钥api_nameString是API接口名称（包括在请求地址中）[item_search,item_get,item_search_shop等]cacheString否[yes,no]默认yes，将调用缓存的数据，速度比较快result_typeString否[json,jsonu,xml,serialize,var_export]返回数据格式，默认为json，jsonu输出的内容中文可以直接阅读langString否[cn,en,ru]翻译语言，默认cn简体中文versionString否API版本 2.请求参数
请求参数：num_iid=5eb1097ba091410953951d17
参数说明：num_iid:小红书商品ID 3.响应参数
获取单个笔记详细数据：
note_id为笔记id，如 5b275e5c9374260197ec884a short_url为笔记短链接，如 https://xhslink.com/jJI6sg 此参数与note_id之间只需要传一个 返回如下： { "ok": true, "result": { ... # 返回值与小红书接口一样，字段比较多，按字面意思理解即可 } } 当作品不存在时，则返回如下： { "cost": true, "error": "作品不存在", "ok": false } 获取笔记的评论列表
每页返回20条。 如果要翻页，需要传入cursor参数（会在前一次请求结果里返回），第一次请求不需要传此参数。 返回如下： { "ok": true, "result": { 'cursor': '5e16e6200000000001009400', 'data':{...} # 评论数据 } } 获取单条评论下的回复列表
每页返回20条。 如果要翻页，需要传入cursor参数（会在前一次请求结果里返回），第一次请求不需要传此参数。 返回如下： { "ok": true, "result": { 'cursor': '5e16e6200000000001009400', 'data': [] # 评论回复列表 } } 获取单个笔记关联的商品列表（当笔记存在关联商品时才需要调用此接口）
如果要翻页，需要传入page参数，从1开始，每页最多10条。 返回如下： { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6beb59a8b3755ee44b4be53981e7c6db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24af3bb2ff1bf8905dbb91a524798cd/" rel="bookmark">
			.NET6.0 EF Core 之 DB First生成实体类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 EF Core可以使用DB First模式生成实体类具体步骤如下：
1.添加EF Core支持程序包 因为.NET Core中默认不包含EF Core的工具和程序包，需要通过NuGet管理器安装对应的工具和程序包，这里使用SQL Server数据库。
Microsoft.EntityFrameworkCore.SqlServer：SQL Server数据库EF提供程序
Microsoft.EntityFrameworkCore.Design：设计时使用到的EF共享库
Microsoft.EntityFrameworkCore.Tools：EF的NuGet包管理器命令工具
也可以调出【程序包管理控制台】(位置:工具-&gt;NuGet 包管理器-&gt;程序包管理控制台),选择【默认项目】,输入以下命令安装依赖
Install-package Microsoft.EntityFrameworkCore.Tools
Install-package Microsoft.EntityFrameworkCore.Design
Install-package Microsoft.EntityFrameworkCore.SqlServer
2.通过数据库生成Model 调出【程序包管理控制台】，选择项目，输入以下命令将数据库中所有表生成Model
Scaffold-DbContext 'Data Source=.;Initial Catalog=DB;integrated security=True;' Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -Context DBContext
DB：数据库名称
DBContext：数据上下文名称
后续如数据库新增或删减表，在命令后加-Force Scaffold-DbContext 'Data Source=.;Initial Catalog=DB;integrated security=True;' Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -Context DBContext -Force
3.连接字符串写入配置文件 在appsettings.json文件中配置连接字符串
"ConnectionStrings": { "DBEquipment": "Data Source=.;Initial Catalog=DB;integrated security=True;" } 4.在Program类中添加数据上下文对象依赖注入服务，并从appsettings.json文件中读取连接字符串配置 using Microsoft.EntityFrameworkCore; builder.Services.AddDbContext&lt;DBContext&gt;(options =&gt; options.UseSqlServer(builder.Configuration.GetConnectionString("DBEquipment"))); 5.在Controllers文件夹中创建一个控制器，在该类的构造方法中获取依赖注入的数据上下文对象 private readonly ShopContext _context; public EquipmentsController(ShopContext context) { _context = context; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62bf8797a2403140d4044a301bc0116c/" rel="bookmark">
			Centos7下搭建MySQL高可用架构(互为主从)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、环境介绍
192.168.31.14 A机器 192.168.31.82 B机器 192.168.31.200 vip（A主B从） 2、安装mysql
2.1、创建配置文件：vi mysql.cnf
[mysqld] port = 3306 basedir=/home/data/server/mysql datadir=/home/data/server/mysql/data max_connections=1000 character-set-server=utf8 default-storage-engine=INNODB lower_case_table_names=1 max_allowed_packet=20M sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION' # Disabling symbolic-links is recommended to prevent assorted security risks symbolic-links=0 skip-grant-tables=1 # Settings user and group are ignored when systemd is used. # If you need to run mysqld under a different user or group, # customize your systemd unit file for mariadb according to the # instructions in http://fedoraproject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62bf8797a2403140d4044a301bc0116c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/488557e1a545a1c429a531a073add28a/" rel="bookmark">
			lotus 扇区生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 lotus
lotus 扇区生命周期 系列文章目录前言一、扇区生命周期V1V1_1 二、扇区续期1. V1_12.命令3. 查看续期是否成功 参考 前言 扇区生命周期
一、扇区生命周期 扇区生命周期 180–540天默认⾃动设置 540天 V1 V1扇区最大寿命 540天 V1_1 V1_1扇区最大寿命 5年 二、扇区续期 1. V1_1 如果V1_1扇区还有30天到期，可以续期150–510天，不是直接续期180–540续期命令lotus-miner sectors renew 2.命令 续期扇区1 # cat sectors.list 1 lotus-miner sectors renew --sector-file=sectors.list --extension=1555200 不会续期，只是查看 # lotus-miner sectors renew --sector-file=sectors.list --extension=1555200 Renewing 1 sectors: { "Extensions": [ { "Deadline": 1, "Partition": 0, "Sectors": "1", "NewExpiration": 3534635 } ] } 1 sectors renewed 上链续期需要加参数--really-do-it lotus-miner sectors renew --really-do-it --sector-file sectors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/488557e1a545a1c429a531a073add28a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17f99d6f1380b281673c98aa2d916362/" rel="bookmark">
			计算机网络（一）——网络基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、计算机网络背景二、网络协议分层2.1 协议分层2.2 OSI七层2.3 TCP/IP四层 三、网络传输基本流程3.1 网络传输流程图3.2 数据包的封装和分用 四、网络中的地址管理4.1 IP地址4.2 几组概念4.3 Mac地址 一、计算机网络背景 网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。
计算机网络主要包括三部分：
计算机 （可以包括客户端、服务器）网络设备 （路由器、交换机、防火墙等）传输介质（可以分为有线和无线的） 按照地域范围可以对网络进行如下分类:
局域网 ：小范围内的私有网络，一个家庭内的网络、一个公司内的网络、一个校园内的网络都属于局域网。广域网：把不同地域的局域网互相连接起来的网络。运营商搭建连接远距离区域的广域网。互联网：由世界各地的局域网和广域网连接起来的网络。互联网是一个开放、互联的网络，不属于任何个人和任何机构。 主机之间的通信方式
客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。对等（P2P）：不区分客户和服务器。 二、网络协议分层 “协议” 是一种约定.
计算机之间的传输媒介是光信号和电信号. 通过 “频率” 和 “强弱” 来表示 0 和 1 这样的信息. 要想传递各种不同的信息, 就需要约定好双方的数据格式.
网络协议, 就是人为约定一个共同的标准，让这些不同厂商之间生产的计算机能够相互顺畅的通信。
2.1 协议分层 为什么要分层？ 主要是为了解耦，使得某一层的改变对整体不影响。这是对网络传输的封装，也是一种面向对象的思想。
2.2 OSI七层 OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型，是一个逻辑上的定义和规范;
把网络从逻辑上分为了7层. 每一层都有相关、相对应的物理设备，比如路由器，交换机;
OSI 七层模型是一种框架性的设计方法，其最主要的功能使就是帮助不同类型的主机实现数据传输;
它的最大优点是将服务、接口和协议这三个概念明确地区分开来，概念清楚，理论也比较完整. 通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯;
但是, 它既复杂又不实用;更多的是TCP/IP四层模型.
2.3 TCP/IP四层 在TCP/IP协议中，它们被简化为了四个层次。
和 OSI 七层网络协议的主要区别如下
应用层、表示层、会话层三个层次提供的服务相差不是很大，所以在 TCP/IP 协议中，它们被合并为应用层一个层次。由于数据链路层和物理层的内容很相似，所以在 TCP/IP 协议中它们被归并在网络接口层一个层次里。 先介绍五层协议
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17f99d6f1380b281673c98aa2d916362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e1ca4d86a85408682588d9aea363d3c/" rel="bookmark">
			Python的选择语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常生活中，我们总要做出许多选择，在程序的世界中也是一样；在python中的选择语句主要有三种形式if、if…else、if…elif…else。
1.if语句 if语句的基本语法：
if 表达式: 语句块 表达式可以是一个单纯的布尔值或变量，也可以是比较表达式或逻辑表达式（例如：a &lt; b）,如果表达式为真，则执行“语句块”，如果表达式的值未假，就跳过“语句块”，继续执行后面的语句。
a = 3 b = 4 if a &lt; b: print("a小于b") #===========结果输出为========== #a小于b 2.if…else语句 if…else语句的基本语法：
if 表达式: 语句块1 else: 语句块2 使用if…else语句时，表达式可以是一个单纯的布尔值或变量，也可以是比较表达式或逻辑表达式，如果满足条件，则执行if后面的语句块，否则，执行else后面的语句块。在使用else语句时，else一定不可以单独使用，它必须和保留字if一起使用。
a = 5 b = 4 if a &lt; b: print("a小于b") else: print("a大于b") #===========结果输出为========== #a大于b 3.if…elif…else语句 if…elif…else语句的基本语法：
if 表达式1: 语句块1 elif 表达式2: 语句块2 …… else: 语句块n 使用if…elif…else语句时，表达式可以是一个单纯的布尔值或变量，也可以是比较表达式或逻辑表达式，如果表达式为真，执行语句；如果表达式为假，则跳过该语句，进行下一个elif的判断，只有在所有表达式都为假的情况下，才会执行else中的语句。
a = 101 if a &lt; 0: print("a小于0") elif a &lt; 10: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e1ca4d86a85408682588d9aea363d3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfdc75cd551f3f1c77d2c3b0748a52f4/" rel="bookmark">
			数学建模中各种评价类模型的优点和缺点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数学建模中，评价类模型是一类比较基础的数学模型之一，往往是对应生活中的一些实际问题。最常见的数学模型包括：层次分析法、模糊综合评价、熵值法、TOPSIS法、数据包络分析、秩和比法、灰色关联法。下面对于上述几种模型的优缺点进行系统地分析。
目录
1.层次分析法
2.模糊综合评价
3.熵值法
4.TOPSIS法
5.数据包络分析
6.秩和比法
7.灰色关联法 1.层次分析法 层次分析法的优点如下所示：
层次分析法是一种系统性的分析方法。层次分析法把研究对象作为一个系统，按照分解、比较判断、综合的思维方式进行决策，成为继机理分析、统计分析之后发展起来的系统分析的重要工具。
层次分析法是一种简洁实用的决策方法。这种方法既不单纯追求高深数学，还不片面地注重行为、逻辑、推理，而是把定性方法与定量方法有机地结合起来。
层次分析法所需定量数据信息比较少。层次分析法主要是从评价者对评价问题的本质、要素的理解出发，比一般的定量方法更讲究定性的分析和判断。
层次分析法的缺点如下所示：
层次分析法指标过多时数据统计量大，且权重难以确定。
层次分析法的特征值和特征向量的精确求法比较复杂。在求判断矩阵的特征值和特征向量时，所用的方法和我们多元统计所用的方法是一样的。
层次分析法的定量数据较少，定性成分多，不易令人信服。
层次分析法只能从原有方案中进行选取，而不能为决策者提供解决问题的新方案。
2.模糊综合评价 模糊综合评价的优点如下所示：
模糊评价通过精确的数字手段处理模糊的评价对象，能对蕴藏信息呈现模糊性的资料作出比较科学、合理、贴近实际的量化评价。
模糊评价法的评价结果是一个矢量，而不是一个点值，包含的信息比较丰富，既可以比较准确的刻画被评价对象，又可以进一步加工，得到参考信息。
模糊综合评价的缺点如下所示：
模糊综合评价的计算复杂，对指标权重矢量的确定主观性较强。
当指标集U较大时，在权矢量和为1的条件约束下，相对隶属度权系数往往会偏小，权矢量与模糊矩阵R不匹配，结果会出现超模糊现象，分辨率很差，无法区分谁的隶属度更高，严重情况甚至会造成评判失败，此时可以使用分层模糊评估法加以改进。
3.熵值法 熵值法的优点如下所示：
熵值法是根据各项指标指标值的变异程度来确定指标权数的，这是一种客观赋权法，避免了人为因素带来的偏差。
熵值法的缺点如下所示：
熵值法不能减少评价指标的维数。
熵值法忽略了指标本身重要程度，有时确定的指标权数会与预期的结果相差甚远。
4.TOPSIS法 TOPSIS法的优点如下所示：
TOPSIS法避免了数据的主观性，不需要目标函数，不用通过检验，而且能够很好的刻画多个影响指标的综合影响力度。 TOPSIS法对于数据分布及样本量、指标多少无严格限制，既适于小样本资料，也适于多评价单元、多指标的大系统,较为灵活、方便。
TOPSIS法的缺点如下所示：
TOPSIS法必须有两个以上的研究对象才可以进行使用。 TOPSIS法需要的每个指标的数据，对应的量化指标选取会有一定难度。
TOPSIS法不确定指标的选取个数为多少才适宜去很好刻画指标的影响力度。
5.数据包络分析 数据包络分析的优点如下所示：
数据包络分析又称作为DEA，可用于处理具有多个输入和输出的问题。 数据包络分析对于效率的评估结果是一个综合指标，并且可用于在经济学中应用总生产要素的概念。
数据包络分析可以处理间隔数据以及序号数据。
数据包络分析中的加权值是数学的乘积计算，因此摆脱了人类的主观性。
数据包络分析不会受到不同规模的影响。
数据包络分析的缺点如下所示：
数据包络分析不应该有太多变量。 数据包络分析的输入变量和输出变量之间的关系程度没有考虑。
数据包络分析它产生了有效的边界，这可能相当大。
如果样本量太小的话结果不太可靠。
6.秩和比法 秩和比法的优点如下所示：
秩和比法又称为RSR法，该方法使用了数据的相对大小关系，而不真正运用数值本身，所以此方法综合性强，可以显示微小变动，对离群值不敏感。 秩和比法能够找出评价指标是否有独立性。
秩和比法能够对各个评价对象进行排序分档，找出优劣，是做比较，找关系的有效手段。
秩和比法的缺点如下所示：
秩和比法 通过秩替代原始指标值，会损失部分信息，不容易对各个指标进行恰当的编秩。 7.灰色关联法 灰色关联法的优点如下所示：
灰色关联法对于数据要求比较低，工作量比较少。灰色关联法的思路明晰，可以在很大程度上减少由于信息不对称带来的损失。 灰色关联法的缺点如下所示：
灰色关联发要求需要对各项指标的最优值进行现行确定，主观性过强。灰色关联法的部分指标最优值难以确定。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/783bb86346a6427b6afd59ea200cd629/" rel="bookmark">
			GO语言-数据操作-GORM 中使用事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GORM 中使用事务 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全执行，要么全不执行。 事务的处理也很简单，用db.Begin() 声明开启事务，结束的时候调用 tx.Commit()，异常的时候调用tx.Rollback()
禁用默认事务 为了确保数据一致性，GORM 会在事务里执行写入操作(创建、更新、删除等)。如果没有这方面的要求，我们就可以在初始化时禁用它，这将提高大约 30%+ 性能提升。
go dsn := "root:password@tcp(127.0.0.1:3306)/gin?charset=utf8mb4&amp;parseTime=True&amp;loc=Local" DB, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config{ SkipDefaultTransaction: true, //打开禁用默认事务 }) DB.Debug() GORM 默认会将单个的 create, update, delete 操作封装在事务内进行处理，以确保数据的完整性。 如果你想把多个 create, update, delete 操作作为一个原子操作，Transaction 就是用来完成这个的。
事务执行流程 要在事务中执行一系列操作，我们可以参照下面的流程来执行。
go db.Transaction(func(tx *gorm.DB) error { // 在事务中执行一些 db 操作(从这里开始，应该使用 'tx' 而不是'db') if err := tx.Create(&amp;Animal{Name: "cxk"}).Error; err != nil { // 返回任何错误都会回滚事务 return err } if err := tx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/783bb86346a6427b6afd59ea200cd629/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f91739fd3267497fc0b521dd4c7e6395/" rel="bookmark">
			rsync 远程同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rsync 远程同步 前言一、Rsync简介(1)rsync介绍(2)rsync同步方式 二、rsync同步源(1)配置rsync源①基本思路②配置文件rsync.conf③独立的账号密码④启用rsync服务 三、常用Rsync命令四、rsync与cp、scp对比五、配置源的两种表达方式六、配置服务端与客户端的实验(1)配置环境(2)配置client端(3)配置server端(4)rsync+inotify实时同步①inotify简介②配置Rsync+Inotify 实时同步③Master 关闭只读模式并为共享目录赋权④优化 Slave 内核参数⑤编译安装inotify-tools⑥编写触发同步脚本 七、rsync的应用场景八、总结 前言 rsync（Remote Sync，远程同步） 是一个开源的快速备份工具，可以在不同主机之间镜像同步整个目录树，支持增量备份，并保持链接和权限，且采用优化的同步算法，传输前执行压缩，因此非常适用于异地备份、镜像服务器等应用。
一、Rsync简介 (1)rsync介绍 rsync是一款开源的、快速的、多功能的、可实现全量及增量的本地或远程数据同步备份的优秀工具。并且可以不进行改变原有数据的属性信息，实现数据的备份迁移特性。
在远程同步任务中，负责发起rsync同步操作的客户机称为发起端，而负责响应来自客户机的rsync同步操作的服务器称为同步源。在同步过程中，同步源负责提供文件的原始位置，发起端应对该位置具有读取权限。
Rsync 是 Linux 系统下的数据镜像备份工具，使用快速增量备份工具 Remote Sync 可以远程同步， 可以在不同主机之间进行同步，可实现全量备份与增量备份，保持链接和权限，且采用优化的同步算法， 传输前执行压缩，因此非常适合用于架构集中式备份或异地备份等应用。同时Rsync支持本地复制，或者与其他 SSH、rsync 主机同步，rsync监听端口:873、rsync运行模式:C/S
官方网站：https://rsync.samba.org/
(2)rsync同步方式 完整备份：每次备份都是从备份源将所有的文件或目录备份到目的地。
差量备份：备份上次完全备份以后有变化的数据（他针对的上次的完全备份，他备份过程中不清除存档属性）。
增量备份：备份上次备份以后有变化的数据（他才不管是那种类型的备份，有变化的数据就备份，他会清除存档属性）
二、rsync同步源 rsync同步源指备份操作的远程服务器，也称为备份源 (1)配置rsync源 ①基本思路 建立rsyncd.conf配置文件、独立的账号文件启用rsync的 --daemon模式 ②配置文件rsync.conf 认证配置auth users、secrets file，不加则为匿名
③独立的账号密码 用户名:密码每行一个用户记录独立的账号数据，不依赖系统账号 ④启用rsync服务 通过 --daemon独自提供服务，rsync --daemon执行kill $(cat /var/run/rsyncd.pid)关闭服务 三、常用Rsync命令 命令使用语法 rsync 【选项】原始位置 目标位置 常用选项 -r递归模式，包含目录及子目录中的所有文件。-l对于符号链接文件仍然复制为符号链接文件。-v显示同步过程的详细（verbose）信息。-z在传输文件时进行压缩（compress）。-a归档模式，保留文件的权限、属性等信息，等同于组合选项“-rlptgoD”。-p保留文件的权限标记。-t保留文件的时间标记。-g保留文件的属组标记（仅超级用户使用）。-o保留文件的属主标记（仅超级用户使用）。-H保留硬连接文件。-A保留 ACL 属性信息。-D保留设备文件及其他特殊文件。–delete删除目标位置有而原始位置没有的文件。–checksum根据校验和（而不是文件大小、修改时间）来决定是否跳过文件。 –delete的作用简单来说，就是删除差异文件，保留一致性
四、rsync与cp、scp对比 cp命令是一种典型的将文件完整的拷贝到一个位置。而rsync是，第一次拷贝，在目标位置没有的时候，rsync是全量拷贝过去，但是第二次拷贝的时候，只会对差异项进行同步拷贝。所有如果对同一个文件进行二次备份的话，rsync速度会相较于cp而言更快。cp只支持本地，而rsync支持远程scp是基于cp原理，也是属于完整性拷贝文件。假设rsync和scp拷贝的文件都是第一，目标地址都没有要同步的文件，此时，这两者的差异在于，第一个，这个要传输的文件大不大，第二个要看在传输的过程中，用的带宽大不大。如果文件不大的情况下，scp是把数据从磁盘中的块存储提取出来，封装一下，网络传过去，此时scp更快，如果是更大的文件，比如说40G，带宽只支持100M的带宽，scp想要传输，需要拆分数据，一段一段传输。而rsync会根据一个逻辑意义上的空间，把数据划分出来，把数据先压缩再传输，所以这种方式而言，带宽校，文件大，这个时候先压缩再传输会比较快。此时适合用rsync远程同步。 五、配置源的两种表达方式 格式一：
用户名@主机地址::共享模块名 例： rsync -avz backuper@192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f91739fd3267497fc0b521dd4c7e6395/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50b4d19b5e831f6df871d34c6b9b1e57/" rel="bookmark">
			探究Vue表单输入绑定v-model
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 探究Vue表单输入绑定v-model表单输入绑定1. 基础语法 值绑定 v-model1.1. 文本1.2. 单选按钮1.3. 复选框1.4. 选择框1.5.多行文本1.6. 提交按钮 2. v-model 修饰符2.1. .layz 在 change 事件_之后_进行同步 ,也可以理解为：失去焦点再收集数据；2.2. .number 将用户的输入值转为数值类型2.3. .trim 自动过滤用户输入的首尾空白字符 3. 细节3.1、点文字账号，密码，光标定位到相应input框中3.2、button 按钮 4. 总结5. 案例 探究Vue表单输入绑定v-model Vue 官网： https://cn.vuejs.org/v2/guide/forms.html
尚硅谷Vue2.0+Vue3.0全套教程丨vuejs从入门到精通 https://www.bilibili.com/
表单输入绑定 1. 基础语法 值绑定 v-model 说到表单，肯定会想到的就是form。form表单是一个包含表单元素的区域，允许用户在表单中
(比如:文本域、下拉列表、单选框、复选框等等)输入信息的元素。
form常用属性
name：规定表单的名称。
action：规定当提交表单时，向何处发送表单数据。默认为当前页面
method：规定如何发送表单数据（即提交方式，常用get或post），默认get
1.1. 文本 &lt;label for="account"&gt;账号：&lt;/label&gt; &lt;input type="text" v-model="account" id="account"&gt; &lt;br/&gt;&lt;br/&gt; &lt;label for="password"&gt;密码：&lt;/label&gt; &lt;input type="password" v-model="password" id="password"&gt;&lt;br/&gt;&lt;br/&gt; 1.2. 单选按钮 &lt;label&gt;性别：&lt;/label&gt; 男：&lt;input type="radio" v-model="sex" value="male"&gt; 女：&lt;input type="radio" v-model="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50b4d19b5e831f6df871d34c6b9b1e57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/844351c302d425226d8604bacae8be1d/" rel="bookmark">
			数据库(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 外连接mysql 约束primary key 主键not null(非空)和unique(唯一)foreign key(外键)check 自增长mysql 索引索引使用小结 事务隔离事务的acid特性 存储引擎三种存储引擎 视图管理用户管理权限管理细节 本章作业 外连接 左外连接（如果左侧的表完全显示我们就说是左外连接）右外连接（如果右侧的表完全显示我们就说是右外连接） CREATE TABLE stu( id INT, `name` VARCHAR(32)); DELETE FROM stu; INSERT INTO stu VALUES(1,'jack'),(2,'tom'),(3,'kity'),(4,'nono'); SELECT * FROM stu; CREATE TABLE exam( id INT, grade INT); INSERT INTO exam VALUES(1,56),(2,76),(11,8); DELETE FROM exam; SELECT * FROM exam; -- 左连接，显示所有人的成绩，如果没有成绩，也要显示该人的姓名和id号,成绩显示为空 SELECT `name`,stu.id,grade FROM stu LEFT JOIN exam ON stu.id = exam.id; -- 右连接，显示所有成绩，如果没有名字匹配，显示空 SELECT `name`,exam.id,grade FROM stu RIGHT JOIN exam ON stu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/844351c302d425226d8604bacae8be1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f574a3c7e16a6840a95e38b6305c7040/" rel="bookmark">
			QGraphicsView图形视图框架使用(四)自定义Item
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 图元创建事件处理状态处理尺寸修改样例代码 QGraphics View允许我们通过子类化QGraphicsItem实现自定的图元。这里就介绍一下自定义图元的实现方式和一些需要注意的问题。这里以一个正弦波曲线图元为例进行说明。 图元创建 首先在工程中添加一个基于QGraphicsItem的C++类，然后在头文件的QGraphicsItem类名称上按Alt+Enter快捷键，在弹出的窗口中选择需要重载的函数，该快捷键只在QtCreator中生效，如果你使用的是Visual Studio + QT，是不可以的。对应的界面如下所示:
当然，我们也可以手动添加对应的重载函数。实现自定义Item有两个接口是必须实现的分别如下:
//返回图元的边界 QRectF boundingRect() const; //添加图元的自定义绘制 void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget); 这里我们定义的图元显示的是振幅为5的正弦波曲线，对应的函数是y=5sin(x)。对应的边界矩形如下所示:
QRectF SineItem::boundingRect() const { //左上角的坐标是(0,-5)矩形 //宽度m_maxX可以通过外部设置,默认是30 //高度就是正弦曲线的振幅的两倍10 return QRectF(0, -5, m_maxX, 10); } 矩形对应的X的范围是(0，30),Y的范围是(-5,5)。
正弦曲线的绘制方法如下:
void SineItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) { Q_UNUSED(option) Q_UNUSED(widget) QPen pen; //缩放的时候保持固定线宽 pen.setCosmetic(true); //采样间隔 qreal dx = 0.5; painter-&gt;setPen(pen); painter-&gt;drawLine(-50, 0, 50, 0); painter-&gt;drawLine(0, -50, 0, 50); const int steps = qRound(m_maxX / dx); QPointF previousPoint(0, sin(0)); for(int i = 1; i &lt; steps; ++i) { const float x = dx * i; QPointF point(x, 5*sin(x)); painter-&gt;drawLine(previousPoint, point); previousPoint = point; } } 这里的采样间隔也就是绘制的步长是是固定的0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f574a3c7e16a6840a95e38b6305c7040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b61f2add3f0cd5171283e730887eb3/" rel="bookmark">
			MySQL中truncate和delete的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		truncate用法： truncate的作用是清空表或者说是截断表，它只能作用在表上
truncate的语法：
truncate table tbl_name; 或者 truncate tbl_name; ​​​​​​​ 需要注意的是：在执行truncate语句的时候是需要拥有表的drop权限；为了实现高性能，他绕过了删除数据的DML方法，所以truncate不能回滚（指的是程序或数据处理错误，将程序或数据恢复到上一次正确状态的行为）。同时，truncate不能对有外键约束引用的表使用；
delete用法： delete语句用于删除数据表中现有的记录，同时delete命令通常和where子句一起使用的，用来删除满足条件的记录，如果没有用到where语句，那么整个表中的数据都会被删除。
delete的语法：
delete from table_name where[condition] where语句中，可以使用and、or、between..and等条件语法。
下面的例子是删除user表中名字是tom的信息。
truncate和delete的区别： 1.truncate命令在各个表中无论是大是小处理的都非常的快，但是不能回滚，也就意味着当有ROOLBACK命令的时候，delete将被撤回，但是truncate不能被撤回。
2.truncate只能删除表中的所有信息，不可以匹配性删除，但是delete可以使用where语句进行条件匹配来选择性的删除内容。
3.当表被truncate后，这个表和索引所占用的空间会恢复到初始的大小，但是delete后不会减少表或索引所占用的空间。
4.truncate不能删除带有外键的表，如果要删除的话需要先取消外键，然后再truncate删除‘为delete语句在结合where语句时候执行删除过程都是从表中删除一行，并且同时将该行的操作作为事物记录到日志中保存，一边进行回滚操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eafb997ed278d98114ef118e8858e45/" rel="bookmark">
			echarts 柱状图 bar、饼状图 pie 设置不同颜色，如何实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		echarts 柱状图 bar、饼状图 pie 设置不同颜色，如何实现 echarts 配置柱状图、饼状图，不同数据颜色不一，如何实现
实现方法一 直接修改 series &gt; colorBy 属性，改为 data
它会遍历 option.color 中的颜色数组，循环使用，这种情况适合只是简单的区分颜色的场景。
color: [ '#4CD964', '#5AC8FA', '#007AFF', '#5856D6', '#FF2D70', '#FF3B30', '#FF9500', '#FFCC00', '#8E8E93', ], series: [ { name: '报警数量', type: 'bar', data: [], colorBy: 'data' // 默认是 series }, ] 实现方法二 主要是 series 中的 itemStyle 属性，这种适合需要指定类别的颜色的场景。
官方说明： https://echarts.apache.org/zh/option.html#series-pie.itemStyle
你需要先准备一个颜色数组
// 这个颜色数组中有 8 个颜色 const COLORS = [ '#FFA41C', '#2F3037', '#9FE080', '#5C7BD9', '#7ED3F4', '#EE6666', '#c7c7c7', '#FFDC60' ] 这里需要说明一下 item 的内容，它的完整内容是这样的，但我们只需要其中几个就可以了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eafb997ed278d98114ef118e8858e45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/804bbc08397815399301544efc015ae2/" rel="bookmark">
			RustDesk 客户端安装及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、客户端安装 傻瓜式一步步往下点就是
注意关掉杀毒软件，可能会有拦截
二、客户端配置 ID服务器：自建的ID服务器的IP地址，若服务器发布到了公网就写公网IP，若服务器只在内网使用，就写内网IP中继服务器：可以不填，软件会自动推导API服务器：同上Key：xxxxxxxx 三、Key的作用和获取 Key是RustDesk加密通讯的公钥，RustDesk服务搭建成功后会在服务程序所在文件夹生成一个id_ed25519.pub文件，用文本编辑器打开就可以得到了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b688bc0a84e71d505f81bcce65ee6ecb/" rel="bookmark">
			Win11安全中心删除的文件如何恢复？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win11安全中心删除的文件如何恢复？有不少朋友在网上下载东西后马上就被安全中心自动删除了，这种情况其实Windows Defender只是将文件隔离了起来，用户还是可以找回来并添加信任的，今天给朋友们讲讲在哪里可以恢复被自动删除的文件。
这些重装系统的方法可以看看
1、在开始菜单中搜索并打开“windows安全中心”。
2、点击并进入“病毒和威胁防护”。
3、点击“保护历史记录”按钮。
4、在这里就可以找到已隔离的威胁，点击右边的操作进行还原即可。
Win11安全中心删除的文件如何恢复？有不少朋友在网上下载东西后马上就被安全中心自动删除了，这种情况其实Windows Defender只是将文件隔离了起来，用户还是可以找回来并添加信任的，今天给朋友们讲讲在哪里可以恢复被自动删除的文件。
这些重装系统的方法可以看看
1、在开始菜单中搜索并打开“windows安全中心”。
2、点击并进入“病毒和威胁防护”。
3、点击“保护历史记录”按钮。
4、在这里就可以找到已隔离的威胁，点击右边的操作进行还原即可。
Win11安全中心删除的文件如何恢复？有不少朋友在网上下载东西后马上就被安全中心自动删除了，这种情况其实Windows Defender只是将文件隔离了起来，用户还是可以找回来并添加信任的，今天给朋友们讲讲在哪里可以恢复被自动删除的文件。
这些重装系统的方法可以看看
1、在开始菜单中搜索并打开“windows安全中心”。
2、点击并进入“病毒和威胁防护”。
3、点击“保护历史记录”按钮。
4、在这里就可以找到已隔离的威胁，点击右边的操作进行还原即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25face0e811bc2506c4d07e56e7dc6e1/" rel="bookmark">
			Shell脚本编写格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、IF 判断语句
#! /bin/bash #[] 该符号是test简化书写，test可以用来判断文件目录，数值大小 if [ $usr=root ] ;then echo "running successul " else echo "running fault" fi ~ --------------------------------------------------------- if-then-else 语句可以在条件不成立时也运行相应的命令 if [测试条件成立] ;then echo 执行相应命令 elif [ 测试条件成立 ] ;then echo 执行相应命令 else echo 测试条件不成立，执行相应命令 fi 结束 -------------------------------------------------------------- #！ /bin/bash # root user1 other if [ $usr=root ] ;then echo "The usr is root" elif [ $usr=usr1 ] ;then echo "The usr is usr1" else echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25face0e811bc2506c4d07e56e7dc6e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446408e93a0aba8539125caf141d3c8a/" rel="bookmark">
			UBI文件系统的制作与挂载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、UBI文件系统的概述
UBIFS是由诺基亚工程师在塞格德大学的帮助下开发的一种新的闪存文件系统。在某种程度上，UBIFS可以被认为是JFFS2文件系统的下一代。
UBI 意思是"Unsorted Block Images未排序的块镜像"。UBIFS是一个flash文件系统。UBIFS与Linux中的传统文件系统如Ext2，XFS，JFS等完全不同。UBIFS 表示一类单独的文件系统，它们与 MTD 设备（而不是块设备）一起使用。此类的另一个 Linux 文件系统是 JFFS2。
JFFS2 文件系统与UBIFS文件系统的区别在于：JFFS2在 MTD 设备之上工作，但 UBIFS 在 UBI 卷之上工作，不能在 MTD 设备上运行
二、UBIFS涉及三个子系统
解释
MTD子系统
MTD子系统用于屏蔽不同flash的操作差异，向上提供统一的操作接口，对应kernel的代码位于drivers/mtd。MTD在flash驱动之上，向上呈现统一的操作接口
UBI子系统
UBI子系统基于MTD子系统之上，在MTD上实现nand特性的管理逻辑，向上屏蔽nand的特性；对应drivers/mtd/ubi
UBIFS文件系统
基于UBI子系统的文件系统，实现文件系统的所有基本功能。例如文件的实现，日志的实现等；对应kernel的代码位于fs/ubifs
三、UBIFS的功能列表
1、可扩展项。UBIFS相对于闪存大小具有良好的可扩展性。挂载时间，内存消耗和I / O速度不取决于闪存大小。UBIFS应该可以在数百GiB的flash上正常工作。UBI / UBIFS堆栈的扩展性比JFFS2好得多
2、快速安装。UBIFS几毫秒就能安装，安装不取决于闪存大小，但UBI初始化时间与闪存大小相关
3、写回支持。JFFS2是直写，UBIFS提高了许多工作负载中文件系统的吞吐量
4、容忍不干净的重启。UBIFS是一个日志文件系统，它容忍突然崩溃和不干净的重新启动。在遇到不干净的重启时，挂载时间稍慢，因为需要重放日志，但 UBIFS 不需要扫描整个介质，因此挂载 UBIFS 无论如何都需要几分之一秒的时间
5、快速I/O。在同步I/O中与JFFS2竞争是极其困难的，因为JFFS2不在闪存上维护索引数据结构，因此它没有维护开销，而UBIFS需要。但是UBIFS仍然很快，因为UBIFS提交日志的方式——不会将数据从一个地方物理移动到另一个地方，而是将相应的信息添加到文件系统索引中，并为新日志选择不同的擦除块，还有其他技巧，如多头日记，这些特性使得UBIFS I/O速度表现良好
6、动态压缩。数据以压缩形式存储在闪存介质上，这与JFFS2非常相似。UBIFS还允许在每个inode的基础上打开/关闭压缩，这非常灵活。
7、可恢复性。如果索引信息损坏，UBIFS 可能会被完全恢复。UBIFS中的每条信息都有一个描述该信息段的标头，并且可以通过扫描闪存介质完全重建文件系统索引，这与JFFS2非常相似。
8、完整性。UBIFS（以及UBI）会校验写入闪存的所有内容以保证数据完整性，UBIFS不会让数据或元数据损坏被忽视（同JFFS2）。默认情况下，UBIFS在从flash读取时仅检查元数据CRC，而不检查数据CRC，但是也可以使用其中一个 UBIFS 挂载选项强制 CRC 检查数据
四、UBI文件系统的制作
制作UBI文件系统时常用的命令有： 工具
作用
ubinfo
提供ubi设备和卷的信息
ubiattach
链接MTD设备到UBI并且创建相应的UBI设备
ubidetach
ubiattach相反的操作，将MTD设备从UBI设备上去链接
ubimkvol
从UBI设备上创建UBI卷
ubirmvol
从UBI设备上删除UBI卷
ubiblock
管理UBI卷上的block
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/446408e93a0aba8539125caf141d3c8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f51563308d2d4394147c64566cdb29e0/" rel="bookmark">
			Spring Boot - ApplicationContextAware
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当一个类实现了这个接口（ApplicationContextAware）之后，这个类就可以方便获得ApplicationContext中的所有bean。换句话说，就是这个类可以直接获取spring配置文件中，所有有引用到的bean对象。applicationContext可以拿到所有创建的Bean对象，从而做一些操作。比如已知某个Bean名称查询Class，通过上下文拿到所有加了某注解的类 import com.evget.exception.BaseException; import org.springframework.beans.BeansException; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.stereotype.Component; @Component public class ContextUtil implements ApplicationContextAware { // 定义一个上下文context; // 通过context.getBean(name); 获取对象 private static ApplicationContext context; @Override public void setApplicationContext(ApplicationContext context) throws BeansException { this.context = context; } public static &lt;T&gt; T get(Class&lt;T&gt; c) { try { return context.getBean(c); } catch (Exception e1) { try { return c.newInstance(); } catch (Exception e2) { throw new BaseException(e2.toString()); } } } public static Object service(String name) { return context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f51563308d2d4394147c64566cdb29e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d2fa98751736c48de484e471a8976e/" rel="bookmark">
			bluez-alsa流程说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//整个的写流程如下，请在对应的调整点/数据记录监控点进行记录调试，确认问题。 //eq_drc层：(调整点1，是否可以增大buffsize) #define READ_FRAME_DEFAULT 1920 #define PERIOD_SIZE_DEFAULT (READ_FRAME_DEFAULT) #define PERIOD_COUNTS_DEFAULT (8*2) #define BUFFER_SIZE_DEFAULT (PERIOD_SIZE_DEFAULT * PERIOD_COUNTS_DEFAULT) /* Keeping a large buffer_size ASAP */ #define MUTE_TIME_DEFAULT (3) /* seconds */ //从虚拟声卡读 (数据记录监控点1：主要是确认aplay送下来的数据是否完整) err = snd_pcm_readi(capture_handle, buffer, g_read_frame); //寻找播放设备 alsa_fake_device_write_open() if (device_flag == DEVICE_FLAG_BLUETOOTH) { sprintf(bluealsa_device, "%s%s", "bluealsa:HCI=hci0,PROFILE=a2dp,DEV=", g_bt_mac_addr); eq_debug("[EQ_WRITE_OPEN] Open PCM: %s\n", bluealsa_device); //打开bluez的蓝牙设备 write_err = snd_pcm_open(write_handle, bluealsa_device, SND_PCM_STREAM_PLAYBACK, 0); } //设置各类参数, 对应上面的define的各种参数 snd_pcm_hw_params_set_access() snd_pcm_hw_params_set_format() snd_pcm_hw_params_set_channels() snd_pcm_hw_params_set_buffer_size_near() snd_pcm_hw_params_set_period_size_near() //对应的输出如下： //eq_drc_process: [EQ_WRITE_OPEN] interleaved mode //eq_drc_process: [EQ_WRITE_OPEN] snd_pcm_hw_params_alloca //eq_drc_process: [EQ_WRITE_OPEN] interleaved mode //eq_drc_process: [EQ_WRITE_OPEN] format successed //eq_drc_process: [EQ_WRITE_OPEN] channels = 2 //eq_drc_process: [EQ_WRITE_OPEN] setting sampling rate (48000) //eq_drc_process: [EQ_WRITE_OPEN] write_bufferSize = 15360 //eq_drc_process: [EQ_WRITE_OPEN] write_periodSize = 1920 //写音频数据到write_handle(数据记录监控点2，对比是否跟监控1一致，及写是否会出错) err = snd_pcm_writei(write_handle, buffer, g_read_frame); //bluez-alsa层： //bluez-alsa\src\asound\bluealsa-pcm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41d2fa98751736c48de484e471a8976e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d4a53396b25d35a36dc8b9b31abea29/" rel="bookmark">
			CSDN文章如何设置目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前看别人的博客，觉得有目录是真的方便！看了很多博客觉得制作也很简单，奈何当时就是做不出来。嗨害！今天悟了hhh。
一、使用MD编辑器。
一般写文章打开应该是富文本编辑器，像这样。我们需要转换成MD编辑器（markdown编辑器）。
转换MD编辑器的地方在这里！
二、事情突然变得简单起来。
格式：
@[TOC](这里写目录标题)
# 一级目录
## 二级目录
### 三级目录
注意！！！
1、@[TOC]后面要有（），在（）中写目录的标题
2、 # 后要有空格
举个栗子：
以学校的职务为例。左边是编辑部分，右边是预览部分。
一些简单的markdown编辑器操作在第一次使用markdown编辑器时会有介绍。
整理出来如下：
点我点我
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfaf9f031245f5531e08480f2433197c/" rel="bookmark">
			Latex公式与Word公式相互转换（使用MathType）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Latex公式转Word公式 在MathType中敲好的公式，将 预置-&gt;剪切和复制 中选项改为MathML
复制公式后，打开Word并粘贴到相应位置，出现如下弹窗
选择创建OMML公式并点击确定即可
word公式转Latex公式 打开Word中MathType插件，选择转换公式
点击转换按钮即可完成转换
其他（MathType OLE对象转Latex公式代码） 利用转换公式功能，容易将MathType公式转换为Latex代码
若想转换回MathType公式，选中MathType代码并点击“切换Tex”按钮即可
参考资料
[1] Latex公式编辑器
[2] word自带公式转换为mathtype格式
[3] 2种办法把mathtype公式转换成word公式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f38a347aae9f30c8b7c9ad566e86eb1e/" rel="bookmark">
			RabbitTemplate的两段回调确认机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ConfirmCallback是用来得知是否进入到交换机
ReturnCallback是获取未进入队列的回调信息，如果成功进入队列，不会进入这个回调方法。
注意要触发ReturnCallback，必须设置rabbitTemplate.setMandatory(true);
@Bean public RabbitTemplate rabbitTemplate(CachingConnectionFactory factory) { // 开启消息进入Broker确认 factory.setPublisherConfirmType(CachingConnectionFactory.ConfirmType.CORRELATED); // 开启消息未进入队列确认 factory.setPublisherReturns(true); RabbitTemplate rabbitTemplate = new RabbitTemplate(factory); // 进入Broker时触发回调 rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() { @Override public void confirm(CorrelationData correlationData, boolean b, String s) { log.info("消息进入到broker，是否到交换机:correlationData({}),ack({}),cause({})", correlationData, b, s); } }); // Mandatory：为true时,消息通过交换器无法匹配到队列会返回给生产者 并触发MessageReturn，为false时,匹配不到会直接被丢弃 rabbitTemplate.setMandatory(true); // 消息未进入队列时触发回调 rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() { @Override public void returnedMessage(Message message, int i, String s, String s1, String s2) { log.info("消息未进入队列:exchange({}),route({}),replyCode({}),replyText({}),message:{}",s1, s2, i, s, message); } }); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9801355f14c4f39afe04c08c36f67248/" rel="bookmark">
			三步解决Word无法使用Ctrl V进行复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题原因：多数情况下，该问题的出现是由于Word中安装了插件math type
依次点击“文件”-“选项”；
点击“加载项”，选中math type commands，在最下方的“管理”处选择“模板”，然后点击“转到”。
取消标记处的勾选，然后点击“确定”，之后Word中的Ctrl+v即可使用。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/539707f3fc06b738c5771096d9d2d4f3/" rel="bookmark">
			Oracle 通过TCP/IP 与外部服务通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍了oracle通过UTL_TCP与外部程序进行通信的示例
外部服务端使用python3编写
import socket #网络编程需要用到socket模块 server = socket.socket() #创建一个用于监听连接的Socket对像（服务器端） server.bind(('127.0.0.1', 8888)) #设置服务端的ip和端口号 server.listen() #开始监听 while True: print('ready') conn, addr = server.accept() #接受服务器端发出的消息和地址信息 while True: c_info= conn.recv(1024) #将接受的消息存入到c_info变量中 if not c_info: break else: print(c_info) if c_info==b'nice to meet you!': print('send msg') conn, addr = server.accept() conn.send(b'nice to meet you too!') #向客户端发出消息 break conn.close() #关闭连接 server.close() #关闭服务端 数据库端程序
DECLARE v_conn UTL_TCP.connection; v_ret PLS_INTEGER:=0; v_out VARCHAR2(100):=''; BEGIN --创建连接 v_conn:=UTL_TCP.open_connection(remote_host =&gt; '127.0.0.1', remote_port =&gt; '8888', in_buffer_size =&gt; 32767, out_buffer_size =&gt; 32767, CHARSET =&gt; null, newline =&gt; UTL_TCP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/539707f3fc06b738c5771096d9d2d4f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a63a6666ffc40b0a6e37dfaa14fcf6f3/" rel="bookmark">
			无法获取下列许可SOLIDWORKS Standard，无法找到使用许可文件。(-1,359,2)。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体的问题如下：
原因分析：可能是误操作，修改了或删除了与使用许可相关的文件。（我之前装UG时，可能不小心修改了某些东西，就出现了这种情况）
声明：以下方法只是针对我自身而言，相对有效的一种解决方案，不一定全部适用。如果有更多更好的方法，可以积极反馈。
本人的修复步骤：
1、找到原来的Solidworks安装包解压，打开解压后的文件夹。
2、找到并选择setup.exe文件，右键以管理员身份运行。（建议安装修复过程中，断开网络，关闭杀毒软件）
3、打开程序后，选择修复单机安装，点击下一步。
4、点击右下角的修复。
5、等待修复完成。（大概20分钟）
6、显示以下界面，表示修复完成。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/223/">«</a>
	<span class="pagination__item pagination__item--current">224/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/225/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>