<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58ce21dcc986ac5e3d9ae0fdd2afc863/" rel="bookmark">
			网络安全（黑客）—2024自学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.网络安全是什么 网络安全可以基于攻击和防御视角来分类，我们经常听到的 “红队”、“渗透测试” 等就是研究攻击技术，而“蓝队”、“安全运营”、“安全运维”则研究防御技术。
2.网络安全市场 一、是市场需求量高；
二、则是发展相对成熟入门比较容易。
安全不是独立存在的，而是建立在其他技术基础之上的上层应用技术。脱离了这个基础，就很容易变成纸上谈兵，变成“知其然，不知其所以然”，在安全的职业道路上也很难走远。
如果你是原本从事网工运维，那么可以选择网络安全方向入门；
如果你原本从事程序开发，推荐选择Web安全/渗透测试方向入门。
当然学到一定程度、或者有了一定工作经验，不同方向的技术耦合会越来越高，各个方向都需要会一点。
3.所需要的技术水平 需要掌握的知识点偏多（举例）：
4.国家政策环境 对于国家与企业的地位愈发重要，没有网络安全就没有国家安全
更有为国效力的正义黑客—红客联盟
可见其重视程度。
5.自学网络安全学习的误区和陷阱 1.不要试图先成为一名程序员（以编程为基础的学习）再开始学习 行为：从编程开始掌握，前端后端、通信协议、什么都学。
缺点：花费时间太长、实际向安全过渡后可用到的关键知识并不多。
很多安全函数知识甚至名词都不了解 unserialize outfile
2.不要把深度学习作为入门第一课 很多人都是冲着要把网络安全学好学扎实来的，于是就很容易用力过猛，陷入一个误区：就是把所有的内容都要进行深度学习，但是把深度学习作为网络安全第一课不是个好主意。原因如下：
【1】深度学习的黑箱性更加明显，很容易学的囫囵吞枣
【2】深度学习对自身要求高，不适合自学，很容易走进死胡同
3.以黑客技能、兴趣为方向的自学误区： 行为：疯狂搜索安全教程、加入各种圈子，资源就下，视频就看，只要是黑客相关的。
缺点： 就算在考虑资源质量后的情况下，能学习到的知识点也非常分散，重复性极强。
代码看不懂、讲解听不明白，一知半解的情况时而发生。
在花费大量时间明白后，才发现这个视频讲的内容其实和自己看的其他知识点是一样的。
4.不要收集过多的资料 网上有很多关于网络安全的学习资料，动辄就有几个G的材料可以下载或者观看。而很多朋友都有“收集癖”，一下子购买十几本书，或者收藏几十个视频
网上的学习资料很多重复性都极高而且大多数的内容都还是几年前没有更新。在入门期间建议“小而精”的选择材料，下面我会推荐一些自认为对小白还不错的学习资源，耐心往下看
6.网络安全学习路线 网络安全（黑客技术）学习路线图
需要高清pdf可以关注后留言
第一阶段：安全基础 网络安全行业与法规
Linux操作系统
计算机网络
HTML PHP Mysql Python基础到实战掌握
第二阶段：信息收集 IP信息收集
域名信息收集
服务器信息收集
Web网站信息收集
Google hacking
Fofa网络安全测绘
第三阶段：Web安全 SQL注入漏洞
XSS
CSRF漏洞
文件上传漏洞
文件包含漏洞
SSRF漏洞
XXE漏洞
远程代码执行漏洞
密码暴力破解与防御
中间件解析漏洞
反序列化漏洞
第四阶段：渗透工具 MSF
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58ce21dcc986ac5e3d9ae0fdd2afc863/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c03a949d0e9328cd322566985aa772ff/" rel="bookmark">
			代码精简10倍，责任链模式yyds
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全新前后端微商城项目，手把手教学！ 全新前后端微商城项目，手把手教学！ 全新前后端微商城项目，手把手教学！ 文章来源：https://blog.csdn.net/q1472750149/article/details/121886327 目录
什么是责任链
使用场景
结语
前言
最近，我让团队内一位成员写了一个导入功能。他使用了责任链模式，代码堆的非常多，bug 也多，没有达到我预期的效果。
实际上，针对导入功能，我认为模版方法更合适！为此，隔壁团队也拿出我们的案例，进行了集体 code review。
学好设计模式，且不要为了练习，强行使用！让原本 100 行就能实现的功能，写了 3000 行！对错暂且不论，我们先一起看看责任链设计模式吧！
什么是责任链
责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。
使用场景
责任链的使用场景还是比较多的：
多条件流程判断：权限控制
ERP 系统流程审批：总经理、人事经理、项目经理
Java 过滤器的底层实现 Filter
如果不使用该设计模式，那么当需求有所改变时，就会使得代码臃肿或者难以维护，例如下面的例子。
反例 假设现在有一个闯关游戏，进入下一关的条件是上一关的分数要高于 xx：
游戏一共 3 个关卡
进入第二关需要第一关的游戏得分大于等于 80
进入第三关需要第二关的游戏得分大于等于 90
那么代码可以这样写：
//第一关 public class FirstPassHandler { public int handler(){ System.out.println("第一关--&gt;FirstPassHandler"); return 80; } } //第二关 public class SecondPassHandler { public int handler(){ System.out.println("第二关--&gt;SecondPassHandler"); return 90; } } //第三关 public class ThirdPassHandler { public int handler(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c03a949d0e9328cd322566985aa772ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd5c05098ebb716862dd34d7c786dea6/" rel="bookmark">
			如何在Ubuntu中查看内存使用情况？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Ubuntu中查看内存使用情况，您可以使用几种不同的方法。以下是一些常用的方法：
1. 使用系统监视器
系统监视器是Ubuntu中内置的一个工具，可以方便地查看系统的资源使用情况，包括内存。要打开系统监视器，请按下Ctrl+Alt+F1（F1-F6键）进入终端，然后输入以下命令：
sudo apt-get install gnome-system-monitor 安装完成后，您可以使用以下命令启动系统监视器：
gnome-system-monitor 系统监视器将显示一个窗口，其中包含各种系统资源的图表和数字，包括内存使用情况。
2. 使用top命令
top命令是一个常用的Linux命令行工具，可以实时查看系统的资源使用情况。要使用top命令查看内存使用情况，请在终端中输入以下命令：
top top命令将显示一个动态的屏幕，其中包含各种系统进程和资源使用情况的实时信息。您可以通过按键盘上的不同键来更改top命令的显示内容，其中包括按“M”键以按内存使用情况排序进程。
3. 使用free命令
free命令可以用来查看系统的内存使用情况。要使用free命令，请在终端中输入以下命令：
free -h 这将显示系统的总内存、已用内存、空闲内存和缓存内存的使用情况。如果您希望以易读的格式显示这些数字，请使用“-h”选项。
这些方法中的每一种都有其优点和适用场景。系统监视器适合于图形用户界面下的查看，top命令适合于实时监控系统资源，而free命令则适合于快速查看系统的内存使用情况。根据您的需求选择最适合您的方法。
​
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada43fab925f6ec1e4bc0638252e11fa/" rel="bookmark">
			小程序跳转安卓会跳转两次 iOS不会的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因：元素点击事件在子元素上有绑定，父元素上也有绑定会形成冒泡时间；
原生小程序： bind:tap：会冒泡；
&lt;view bind:tap="gotoDetail"&gt; &lt;image :src="{{ item2.img }}" mode="aspectFill"&gt;&lt;/image&gt; &lt;/view&gt; catch:tap：阻止冒泡；
&lt;view catch:tap="gotoDetail"&gt; &lt;image :src="{{ item2.img }}" mode="aspectFill"&gt;&lt;/image&gt; &lt;/view&gt; uniapp： @click：会冒泡；
&lt;view @click="gotoDetail(item.id, item2.action_id)"&gt; &lt;image :src="item2.img" mode="aspectFill"&gt;&lt;/image&gt; &lt;/view&gt; @click.stop：阻止冒泡；
&lt;view @click.stop="gotoDetail(item.id, item2.action_id)"&gt; &lt;image :src="item2.img" mode="aspectFill"&gt;&lt;/image&gt; &lt;/view&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/067109fd9f18b64d7d2f9868af69750e/" rel="bookmark">
			LeetCode刷题---链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、反转链表1.分析2.翻转指针3.头插法 二、链表的中间结点1.分析1.求长度，找中点2.快慢指针 三、合并两个有序链表1.分析2.尾插法3.带哨兵位的头节点 四、环形链表1.分析2.快慢指针 一、反转链表 1.分析 给定单链表头结点，反转链表之后返回新的头结点。
思路一：翻转指针
原本1号指针指向下一个节点2的，但是将1号指针翻转之后指向空，一直翻转直到5指向空翻转为5指向4.
所以我们就需要3个变量，一个节点存放指向其他节点的信息，另一个节点是被指向的节点，还需要一个节点来存放下一个节点的信息
思路2：头插法
将已知链表存放在一个新的链表中，将已知链表的每一个节点头插进新的链表中，需要三个变量：一个变量存放新的链表的节点信息，一个变量存放下一个节点的信息，一个变量来存放当前位置的信息
2.翻转指针 struct ListNode* reverseList(struct ListNode* head) { if (head == NULL) { return NULL; } struct ListNode* n1 = NULL;//被指向的节点 struct ListNode* n2 = head;//已知节点 struct ListNode* n3 = n2-&gt;next;//存下一个节点的位置 while (n2 != NULL) { n2-&gt;next = n1; n1 = n2; n2 = n3; if (n3) { n3 = n3-&gt;next; } } return n1; } 3.头插法 struct ListNode* reverseList(struct ListNode* head) { struct ListNode* cur = head; struct ListNode* newhead = NULL; while (cur) { struct ListNode* next = cur-&gt;next; cur-&gt;next = newhead; newhead = cur; cur = next; } return newhead; } 二、链表的中间结点 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/067109fd9f18b64d7d2f9868af69750e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/350b1c18a96a16a05886cc5d16a7e031/" rel="bookmark">
			iOS 位移枚举NS_OPTIONS（如何实现多个枚举值的同时传入判断）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、场景 当我们使用枚举这个东西时，有时需要多个枚举值任一一个满足时就ture，但是常用的枚举NS_ENUM定义好的枚举只能挨个判断，写一坨就既不美观也不好阅读，如下：
typedef NS_ENUM (NSInteger, RPTestType){ RPTestTypeUnknown = 0, // unknow RPTestTypeValue0, // 值0 RPTestTypeValue1, // 值1 RPTestTypeValue2, // 值2 RPTestTypeValue3, // 值3 RPTestTypeValue4, // 值4 RPTestTypeValue5, // 值5 }; RPTestType testTeype = RPTestTypeUnknown； if (testTeype == RPTestTypeValue0 || testTeype == RPTestTypeValue1 || testTeype == RPTestTypeValue2 || testTeype == RPTestTypeValue3 || testTeype == RPTestTypeValue4 || testTeype == RPTestTypeValue5) { NSLog(@"ture"); } 二、利用NS_OPTIONS优化 1、先了解一个关于位运算符的知识点：位运算符浅析 这里用到（左移 &lt;&lt; ）和 （按位与 &amp; ）和（按位或 | ）这仨，先明确是怎么个事；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/350b1c18a96a16a05886cc5d16a7e031/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0035c5a3f0f1fd3fec65f5da21eb8d6/" rel="bookmark">
			Go语言开发IDE介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go语言开发的集成开发环境（IDE）主要包括以下几种：
Goland - 由 JetBrains 公司专门为 Go 语言开发而设计的专业 IDE，提供智能代码补全、深入代码分析、高级调试工具、强大的导航与搜索功能以及与版本控制系统（VCS）的紧密集成。支持 Windows、macOS 和 Linux 平台。
Visual Studio Code (VSCode) - 跨平台开源代码编辑器，可通过安装 Go 扩展（如 Microsoft 的 Go 插件）来支持 Go 开发，提供丰富的代码编辑、调试、格式化及自动完成功能。
LiteIDE - 针对 Go 语言的一个轻量级集成开发环境，虽然不如 Goland 或 VSCode 功能齐全，但对资源占用较少，适合一些简单场景或低配置环境下的开发。
Sublime Text / Atom - 这两款都是流行的文本编辑器，可以通过安装对应的插件支持 Go 语言开发，提供基础的代码高亮、语法检查和自动完成等功能。
Eclipse - 使用 GoClipse 插件可以在 Eclipse IDE 中支持 Go 开发。
Vim / Emacs - 传统的命令行文本编辑器，配合相关的插件可以作为高效的 Go 语言开发环境，尤其受到许多喜欢简约高效界面和高度定制化的开发者喜爱。
根据个人需求和爱好，可以选择上述任一工具进行 Go 语言的开发工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f3359fba590a617ff346352183cae96/" rel="bookmark">
			Node安装极速版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Node安装 首先下载node在当前解压好的文件夹目录中输入cmd打开控制台搜索命令提示符配置npm淘宝镜像源安装cnpm打开vscode终端-也要以管理员身份打开 否则权限不够 首先下载node node-v14.17.0 -x64下载
提取码：qrjv
如果想用其他版本可以去node官网下载
下载好后记得解压，安装则是傻瓜式安装，一直点下一个，也不用勾选什么，安装地址可以自行修改
在当前解压好的文件夹目录中输入cmd打开控制台 输入以下命令，进行一个node版本的查询
node -v npm -v 下载的版本能显现则下载成功
搜索命令提示符 右击命令提示符以管理员身份运行打开
配置npm淘宝镜像源 npm config set registry https://registry.npm.taobao.org 安装cnpm 安装之前可以看一下你项目当前cnpm的版本号，然后进行下载，可以自行更改@后面的版本号
npm install -g cnpm@7.1.1 --registry=https://registry.npm.taobao.org 打开vscode终端-也要以管理员身份打开 否则权限不够 按顺序输入以下两行命令先下载再run，能成功运行则安装成功，可进入使用，这时候再运行vue项目，则能在网页中展现
nmp install nmp run dev 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a31ec055a6074c3a2f95e55a8915096/" rel="bookmark">
			优雅而强力地卸载docker-desktop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker Desktop可正常使用 打开 Docker Desktop，然后点击troubleshoot：
再点击 uninstall。
Docker Desktop不可用 javaedge@JavaEdgedeMac-mini .kube % sudo /Applications/Docker.app/Contents/MacOS/Docker --uninstall Password: 打不开 Docker Desktop 且情况二无法解决 sudo rm -Rf /Applications/Docker.app sudo rm -f /usr/local/bin/docker sudo rm -f /usr/local/bin/docker-machine sudo rm -f /usr/local/bin/com.docker.cli sudo rm -f /usr/local/bin/docker-compose sudo rm -f /usr/local/bin/docker-compose-v1 sudo rm -f /usr/local/bin/docker-credential-desktop sudo rm -f /usr/local/bin/docker-credential-ecr-login sudo rm -f /usr/local/bin/docker-credential-osxkeychain sudo rm -f /usr/local/bin/hub-tool sudo rm -f /usr/local/bin/hyperkit sudo rm -f /usr/local/bin/kubectl.docker sudo rm -f /usr/local/bin/vpnkit sudo rm -Rf ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a31ec055a6074c3a2f95e55a8915096/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8870f239d3b104e442a265d42e418223/" rel="bookmark">
			[C#]使用winform部署PP-MattingV2人像分割onnx模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【官方框架地址】
https://github.com/PaddlePaddle/PaddleSeg
【算法介绍】
PP-MattingV2是一种先进的图像和视频抠图算法，由百度公司基于PaddlePaddle深度学习框架开发。它旨在提供更精准和高效的图像分割功能，特别是在处理图像中的细微部分，如头发或者毛发等半透明边缘细节时，PP-MattingV2展现出卓越的性能。
### 核心技术
PP-MattingV2采用了深度神经网络作为其核心技术，通过训练大量的图像数据，学习如何从复杂背景中分离前景对象。算法通常包含两个关键的步骤：首先是前景估计，即确定图像中哪些区域属于前景；其次是边缘精细化，即处理前景与背景之间的交界区域，保证抠图的自然和无缝。
### 特点
#### 超高精度
PP-MattingV2在处理细节丰富的图像区域时，如头发、羽毛或织物纹理等，能够保持极高的精确度，使得抠图结果自然和逼真。
#### 适应性强
算法能够适应各种复杂的背景和光照条件，对于多样性的图像内容具有很好的泛化能力。
#### 高效率
由于PaddlePaddle框架的高性能计算能力，PP-MattingV2能够快速处理大规模的图像和视频数据，满足实时处理的需求。
#### 易于集成
作为PaddlePaddle生态系统的一部分，PP-MattingV2可以轻松集成到已有的图像处理和视频编辑工作流中，提供端到端的解决方案。
#### 支持多平台
PP-MattingV2支持在多种平台上运行，包括服务器、云端和移动设备，这使得它可以广泛应用于不同的使用场景和业务需求。
### 应用场景
PP-MattingV2的高精确度和灵活性使其适用于多种应用场景，包括但不限于：
- **影视后期制作**：在电影或视频制作中，需要将演员或物体从一些场景中抠出，以便将它们置于新的背景之中。
- **虚拟现实**：在虚拟现实内容的创作中，需要准确分离真实世界的元素与虚拟环境的结合。
- **广告设计**：在广告和图像设计行业，经常需要将产品或模特从一个背景中抠出，以制作更具吸引力的视觉材料。
- **个性化内容制作**：在社交媒体上制作个性化的头像、表情包或其他创意内容时，抠图功能非常实用。
总的来说，PP-MattingV2是PaddlePaddle生态中的一个重要工具，它将深度学习的强大能力带给了图像和视频抠图任务，大幅提高了抠图的质量和效率，适合在多种行业中部署和应用。
【效果展示】
【实现部分代码】
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Diagnostics; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; using OpenCvSharp; namespace FIRC { public partial class Form1 : Form { Mat src = new Mat(); PPMattingManager detector = new PPMattingManager(); public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { OpenFileDialog openFileDialog = new OpenFileDialog(); openFileDialog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8870f239d3b104e442a265d42e418223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d0600a33c34f9ff308332ffacc65f49/" rel="bookmark">
			某汽车塑料制品有限公司：采用监控易管理平台提升IT运营效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景介绍
某汽车塑料制品有限公司是一家专注于汽车塑料制品研发、生产和销售的公司。随着业务的快速发展，公司面临着越来越多的IT设备和管理问题。为了提高IT运营效率，降低IT风险，公司决定引入一套高效、可靠的IT监控管理平台。
二、解决方案
经过严格的筛选和评估，某汽车塑料制品有限公司最终选择了监控易管理平台7.0基础模块，并购买了近百个监控点，包括IT基础监控和动环监控。这一解决方案能够实现对公司IT基础设施的全面监控和管理，包括服务器、网络设备、存储设备、数据库等。
三、实施过程与成果
在实施过程中，监控易团队提供了全方位的技术支持，确保平台的顺利部署和运行。实施完成后，某汽车塑料制品有限公司的IT运营效率得到了显著提升。以下是实施后的具体成果：
提高IT响应速度：通过监控易管理平台，公司可以实时了解IT设备的运行状态，及时发现和解决问题。这大大提高了IT响应速度，减少了故障恢复时间。降低IT风险：监控易管理平台能够实时监控IT设备的性能和状态，及时发现潜在的问题和风险。这有助于公司提前采取措施，降低IT风险。提高IT资源利用率：通过监控易管理平台，公司可以更加合理地分配和使用IT资源。这有助于提高资源利用率，降低成本。远程维保服务：为了确保平台的顺利运行，公司还购买了一年的远程维保服务。这项服务包括了技术支持、系统升级、故障排除等一系列专业服务。这使得公司能够及时解决遇到的问题，确保系统的稳定运行。提升员工效率：通过监控易管理平台，员工可以更加便捷地进行工作，减少不必要的重复性操作。这有助于提高员工的工作效率，减少人力成本。促进业务发展：通过引入监控易管理平台，某汽车塑料制品有限公司成功地提高了IT运营效率，降低了IT风险。这为公司的业务发展提供了有力的支持，有助于实现长期稳定的发展目标。 四、结论
通过引入监控易管理平台和购买远程维保服务，某汽车塑料制品有限公司成功地提高了IT运营效率，降低了IT风险。这一解决方案有助于公司实现长期稳定的发展目标，并为其他企业提供了可借鉴的成功案例。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a750518bf63af46660e4ac7080d82f33/" rel="bookmark">
			行为型设计模式——模板方法模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习难度：⭐ ，比较常用
模板方法模式 在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。例如拿泡茶这件事来说，可以分为4个步骤，第一步洗茶具，第二步烧开水，第三步放入茶叶并根据不同的茶叶泡不同的时间，第四步品茶。以上的一二四步都是一样的，只有第三步不一样，因此可以将一二四步具体实现好，即模板方法。第三步则是用户自己需要实现的方法，即抽象方法。模板方法的定义： 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
模板方法（Template Method）模式包含以下主要角色：
抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。
模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。
基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：
抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。
具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。
钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。
一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。
具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。
案例 【例】炒菜
炒菜的某些步骤是固定的，分为开启灶台、倒油、炒菜、倒调料品、起锅共五个步骤。假设炒菜和倒调料品两个步骤不一样，其他都一样，现通过模板方法模式来用代码模拟。类图如下：
代码 编写抽象模板类，其中开炉灶、倒油、起锅都是固定的方法，而炒菜和放调味品则是根据不同的菜品而不同的，而cook()方法则是一个将上述步骤组合调用的一个方法，使用final修饰不可被重写，如下：
// 烹饪抽象类 public abstract class AbstractCook { // 做菜很多步骤都一样的，只是关键步骤不一样， // 因此，相同步骤作为模板实现好，不同的自己实现 private String food; public AbstractCook(String food){ this.food = food; } public void openStove(){ //1. 开启灶台是相同步骤 System.out.println("打开灶台，将锅烧热"); } public void pourOil(){ //2. 倒油是相同步骤 System.out.println("油倒入锅中，并烧热"); } //3. 翻炒时间和手法不一样 public abstract void fry(); //4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a750518bf63af46660e4ac7080d82f33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b39327255df3088fdbd605ffc376065/" rel="bookmark">
			​机房动环监控和IT软硬件一体化运维解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机房动力环境监测是数字化转型背景下的一项重要需求。随着信息化建设的不断深入，机房设备的运行状态、环境参数等因素对整个系统的稳定性和可靠性影响越来越大。因此，实时掌控机房设备运行状态、一体化集中运维管理、提升故障报修管理、全面掌握机房资产以及有效考核运维工作情况等方面的需求日益凸显。通过机房动力环境监测系统的建设，可以实现对机房环境参数、设备运行状态等的实时监测和报警，提高运维效率和系统稳定性，为数字化转型提供有力保障。
性能特点：
一体化集中监控
大规模监控能力强
支持对机房动力、环境及IT基础设施、物联网各类设备统一监控；针对运维海量数据高频次写入场景专门设计；单机监控能力为同类产品3-4倍；一个平台进行统一管理，提升管理效率。分布式集群架构，支持监控规模无限扩展。
快速定位故障并告警
分布式多节点统一管理
可视化快速定位设备故障；多种方式实时准确发送告警通知；支持组合策略过滤非关键告警。
支持多数据中心、多区域、多层级、跨网闸等；多种管理场景，支持分人员权限、多租户管理方式。
高性能与高可用
自主研发可控
支持分布式大数据高并发存储；核心数据库、中间件、WebServer等均为自研；支持负载均衡、双机热备；支持各类国产化环境部署；系统底层分布式组件，占用网络资源少。
可监控各类国产化设备。
3D机房管理
机房动环监控和IT软硬件一体化运维解决方案，推荐监控易。这款产品将IT基础设施监控和机房动环监控一体化管理，一个平台实现多种产品功能，部署快捷、操作简便，性能稳定。监控易以用户机房建筑为原型实现3D构图，将网络设备和动环设备按照实际位置进行配置，实时显示各项关键参数，包括机柜、设备、配电柜、温感、湿感、烟感、空调、UPS、蓄电池及其他设备，模拟整个机房里各个设备及机柜，实现所见即所得的透明化管理。
动力监控：UPS、蓄电池、配电柜、发电机、精密空调等环境监控
安防监控：机柜微环境、漏水检测、温度、新风机等安防监控
消防监控：门禁、音视频系统、防盗设备、消防设备设备管理
资产管理：设备资产，包括设备型号、编号、空间分布位置等
温湿度监测
通过采集温湿度传感器的实时数据来监测机房环境的温度和湿度。可通过图形化界面显示机房各个区域的温度和湿度值。
可生成历史数据变化曲线，以便运维人员掌握变化趋势。
温度、湿度值达到设定的阀值时，系统自动进行告警。
烟雾/消防监测
实时监测烟雾探测器的输出状态变化。
监测消防主机的输出状态变化量。当监测到机房内部烟雾浓度超标时，烟雾探测器的干接点输出接口将报警信号发送至监控平台，监控平台自动进行告警。
漏水监测
实时监测机房内有水源区域的漏水情况，并显示具体的漏水位置。通过在空调出水管及出水管等有水源区域敷设区域式泄漏检测感应绳，将监测到的液体泄漏情况信号发送至监测平台。
监控平台根据告警配置提供多种告警方式，及时通知维护人员现场漏水的故障情况。
低压配电监测
监测低压配电柜的配电参数及状态；监测配电开关的通断状态。
通过在配电柜进线处加装智能电量仪，采集配电柜进线的各项配电参数。
通过对电量仪实现对各项供电参数进行监测；通过智能采集模块采集配电开关的状态信号。
UPS监测
实时监测UPS的工作状态、电压、电流、频率、功率、后备时间等。可查看UPS实时运行状态、参数数据和报警事件；可查询任意时间段内的历史变化曲线和历史数据。
支持RS232/RS485/SNMP智能监控通讯接口以及RJ45 TCP/IP网络通信协议。
蓄电池监测
监测蓄电池组总电压、单体电压、单体温度、单体内阻、充放电电流等。
电池加装蓄电池采集模块、配置通信管理模块，可监测电池的电压、内阻与负极温度等。
实现集中实时监控及故障预警通知，及时发现电池老化、过载、发热等异常现象。
精密空调监测
监测精密空调运行参数及状态：开、关状态、送风温度/湿度、回风温度/湿度参数等。
记录详细报警状态和历史记录等信息支持导出历史记录数据，便于事故分析和处理。
支持RS232/RS485/SNMP智能监控通讯接口及RJ45 TCP/IP网络通信协议。
新风机监测
监测新风机的开关状态、运行状态、控制运行模式；监测送风温度、送风相对湿度、室内温度、CO2浓度等。
通过监测控制辅助继电器、单路开关传感器、微压差开关，实现对新风机的监测。
提供详细的故障通知信息。
门禁监测
实时监测门禁系统的状态、开关门状态、门的出入记录信息。
对人员准入级别、准入时间段设定等信息的记录、存储和显示。
可获取非系统授权人员强行进入的报警并通知管理人员及时处理。
视频监测
实时监视重点区域各路摄像头的视频图像；实现与门禁监测、消防监测等的联动功能。
通过摄像头（视频服务器或硬盘录像机）的通讯协议，采用TCP/IP网络无缝视频调用。
点击3D视图，自动调取现场视频图像。
综上所述，机房动力环境监测系统的建设对于数字化转型至关重要，它可以提高运维效率和系统稳定性，为企业的信息化建设提供有力保障。因此，加强机房动力环境监测系统的建设和管理，是数字化转型背景下的一项重要任务。
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7895ace99f1c7a89929571048a81eccc/" rel="bookmark">
			【小白专用】C# 连接 MySQL 数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# – Mysql 数据库连接 1. 配置环境 #前提：电脑已安装Mysql服务；
Visual Studio 安装Mysql依赖库：
工具 -&gt; NuGet 包管理器 -&gt; 管理解决方案的 NuGet程序包 —&gt; 搜索， 安装Mysql.Data (Oracle); (安装成功后，在项目引用里面可以看到 Mysql.Data)
接着安装 System.Data.SqlClient
这样就安装完成了，接下来就是代码了
using MySql.Data.MySqlClient; using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace MySqlWinForm { public partial class MySqlForm : Form { public MySqlForm() { InitializeComponent(); } private void btnMySqlConnect_Click(object sender, EventArgs e) { string connectUrl = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7895ace99f1c7a89929571048a81eccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb63135c34938fe8f4b67b1fbb30e48a/" rel="bookmark">
			计算机网络教程题（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、一个网络的物理线路上抓到 011001 位串的波形如下
请问该线路采用了 (B)编码方式。
A.二进制编码
B.曼彻斯特编码
c.差分曼彻斯特编码
D.归零编码
曼彻斯特编码:每一周期分为两个相等的间隔，二进制”1“位在发送时，在第一个间隔中为高电压，在第二个间隔中为低电压。二进制”0“正好相反。
二进制编码：二进制编码是最简单的编码方式，每一位都是高电平或低电平。
曼彻斯特编码：曼彻斯特编码是一种双相线码，每一位的中心点都有电平跳变。
差分曼彻斯特编码：差分曼彻斯特编码与曼彻斯特编码类似，但只有数据位有中心电平跳变，而起始位和结束位没有。
归零编码：在这种编码方式中，信号在每一位的持续时间内都保持在一个恒定的状态（高或低），直到下一位开始。
2、如果对数据的实时性要求比较高，但对数据的准确性要求相对较低;如视频通话，一般可在传输层采用 (A)协议。
A.UDP B.TCP C.FTP D.IP
TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为对数据准确性要求高，速度可以相对较慢的，可以选用TCP对于实时性要求较高但对数据准确性要求相对较低的应用，如视频通话，传输层采用UDP协议更为合适。这是因为UDP（User Datagram Protocol，用户数据报协议）相较于TCP（Transmission Control Protocol，传输控制协议）具有以下特点： 无连接：UDP是无连接的协议，不需在传输数据前进行三次握手建立连接。 不可靠：UDP不保证数据传输的可靠性，也就是说数据可能会丢失、重复或乱序。 面向报文：UDP将应用程序发送的数据直接发送到网络层，不进行拆分或合并。 简单：UDP的协议头只有8个字节，比TCP的20字节头要短。 速度：由于UDP协议相对简单，它在处理速度上可能比TCP更快。综上，对于实时性要求较高的应用，如视频通话，选择UDP协议是更为合适的。因此，答案为A.UDP。 3、FTP 客户和服务器之间一般需要建立的连接个数是（B）
A.1 B.2 C.3 D.4
FTP 客户和服务器之间一般建立两个的连接，一个是控制连接，一个是数据连接。
FTP（File Transfer Protocol，文件传输协议）在客户和服务器之间进行通信时，通常需要建立两个连接。
控制连接：用于传输FTP命令和服务器响应。数据连接：用于实际的数据传输，如从服务器读取或写入文件。 因此，FTP客户和服务器之间一般需要建立的连接个数是B.2。
4、http状态码 (A)代表着OK，没有任何问题。
A、200 B、300 C、404 D、503
200（ OK）：请求已成功，请求所希望的响应头或数据体将随此响应返回
300（ Bad Request）：请求格式错误
1) 语义有误，当前请求无法被服务器理解。除非进行 修改，否则客户端不应该重 复提交这个请求
2) 请求参数有误
404（ Not Found）：请求失败，请求所希望得到的资源未被在服务器上发现
500（ Internal Server Error）：服务器遇到了一个未曾预料的状况，导致了它无法完成对 请 求的处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb63135c34938fe8f4b67b1fbb30e48a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27294b2471f35d4aebdf4c1f407672be/" rel="bookmark">
			Django的数据库模型的CharField字段的max_length参数与中文字符数的关系探索(参数max_length的单位是字符个数还是字节数？)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01-清理干净之前的数据库迁移信息 02-根据setting.py中的信息删除掉之前建立的数据库 03-删除之后重新创建数据库 04-models.py中创建数据库模型 from django.db import models class User(models.Model): username = models.CharField(max_length=4) email = models.EmailField(unique=True) # 其他字段... def __str__(self): return self.username 在上面的数据库模型代码中我对字段username限制为4个长度，我们进行如下测试
①4个中文汉字能不能正常写入；
②5个中文汉字能不能正常写入；
③4个英文字符能不能正常写入；
④5个英文字符能不能正常写入；
05-数据库迁移命令生成 相关命令如下：
CD E:\Python_project\P_001\myshop-test\myshop\ E: manage.py makemigrations 06-执行数据库迁移命令 manage.py migrate 07-写入数据到数据库进行测试 07-1-测试中文汉字 import os import django # 设置Dango运行时需要的环境变量DJANGO_SETTINGS_MODULE os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myshop.settings') # 加载Django的设置 django.setup() # 导入模型，注意必须在加载完Django的设置后下面的这句导入模型语句才能被正确执行 from app1.models import User # # 清空User数据表 # User.objects.all().delete() # # print('Successfully written data to the database.') # 创建一个用户 user = User(username='欧阳娃娃', email='john@example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27294b2471f35d4aebdf4c1f407672be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/784c0b7b76c822d22af531bf15222452/" rel="bookmark">
			LeetCode-搜索插入位置（35）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述： 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
请必须使用时间复杂度为 O(log n) 的算法。
思路： 给定数组查找指定元素值的索引，如果元素值不存在于数组，就返回被顺序插入位置，并且时间复杂度要求O(log n)，那么很自然就能想到使用二分查找，当二分查找找不到元素值时后面再去考虑顺序插入的情况。如果原数组不包括给定的元素值那么就要寻找插入位置，在我看来插入位置分三种情况，第一种指定元素小于等于数组中第一个数，第二种指定元素值大于等于数组最后一个数，第三种就是大于等于前一个数，小于等于后一个数。具体看代码。
代码：
class Solution { public int searchInsert(int[] nums, int target) { int left=0; int right=nums.length-1; while(left&lt;=right) { int mid=(right+left)/2; if(nums[mid]&lt;target) { left=mid+1; } else if(nums[mid]&gt;target) { right=mid-1; } else { return mid; } } for(int i=0;i&lt;nums.length-1;i++) { if(nums[i]&lt;=target&amp;&amp;nums[i+1]&gt;=target) { return i+1; } } if(nums[nums.length-1]&lt;=target) { return nums.length; } return 0; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833dac73c407c27e1ec87c709a6fe738/" rel="bookmark">
			论文系列之-Mixtral of Experts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Q: 这篇论文试图解决什么问题？ A: 这篇论文介绍了Mixtral 8x7B，这是一个稀疏混合专家（Sparse Mixture of Experts，SMoE）语言模型。它试图解决的主要问题包括： 1. 提高模型性能：通过使用稀疏混合专家结构，Mixtral在多个基准测试中超越或匹配了现有的大型模型（如Llama 2 70B和GPT-3.5），尤其是在数学、代码生成和多语言理解任务上。 2. 控制计算成本：尽管模型拥有47B参数，但在推理过程中每个token仅使用13B活跃参数。这种设计允许在小批量大小下实现更快的推理速度，并在大批量大小下实现更高的吞吐量。 3. 减少偏见和提高情感平衡：通过指令微调（Instruct）模型，Mixtral在人类评估基准测试中展示了减少的偏见和更平衡的情感配置文件。 4. 开放访问和应用潜力：Mixtral模型在Apache 2.0许可下发布，允许学术和商业用途的广泛访问，促进了新技巧和应用的开发。 5. 专家选择的分析：论文还对路由网络选择专家的行为进行了分析，以了解在训练过程中是否存在某些专家专门化于特定领域。 总的来说，Mixtral模型旨在通过稀疏混合专家结构提高语言模型的性能，同时控制计算成本，并在多个领域内减少偏见，提高情感平衡，以及促进模型的开放访问和应用。
Q: 有哪些相关研究？ A: Mixtral模型的研究与以下几个领域的相关工作紧密相关： 1. 稀疏混合专家（Sparse Mixture of Experts）：这项研究借鉴了稀疏混合专家的概念，这是一种在深度学习中用于提高模型效率的技术。通过在每个层中选择一组专家（即参数组），模型可以在保持大量参数的同时，仅在每个时间步使用一部分参数。这允许模型在推理时减少计算成本。 2. Transformer架构：Mixtral基于Transformer架构，这是一种在自然语言处理（NLP）任务中表现出色的模型。Transformer通过自注意力机制捕捉输入序列中的长距离依赖关系。 3. 多语言预训练：Mixtral使用了多语言数据进行预训练，这与近年来在多语言理解和生成任务中取得成功的模型（如mBERT和XLM-R）的研究相呼应。 4. 指令微调（Instruction Tuning）：Mixtral-8x7B - Instruct模型通过在指令数据集上进行监督微调和直接偏好优化（DPO）来提高其遵循指令的能力。这与指令微调技术的研究相关，该技术旨在提高模型遵循用户指令的能力。 5. 偏见和情感分析：论文中对模型在偏见和情感分析方面的评估与近年来在语言模型偏见和公平性研究中的趋势相一致。 6. 模型路由和专家选择：对模型中专家选择的分析与研究如何优化模型的路由策略和专家分配以提高性能和效率的工作相关。 7. 模型评估和基准测试：Mixtral模型在多个任务和基准测试上进行了评估，这与评估大型语言模型性能的研究相联系。 这些相关工作为Mixtral模型的设计和评估提供了理论基础和实践指导。
Q: 论文如何解决这个问题？ A: 论文通过以下方法解决了提高模型性能、控制计算成本和减少偏见等方面的问题： 1. 稀疏混合专家（Sparse Mixture of Experts）：通过在每个层中使用8个专家（即8个前馈块），并在每个时间步选择两个专家来处理当前状态，Mixtral实现了在推理时仅使用部分参数。这种结构允许模型在保持大量参数的同时，控制实际使用的计算资源。 2. 多语言预训练：使用32k tokens的上下文大小进行多语言数据预训练，使得Mixtral在多语言理解任务上表现优秀，尤其是在数学、代码生成等需要专业知识的领域。 3. 指令微调（Instruction Tuning）：为了提高模型遵循指令的能力，Mixtral-8x7B - Instruct模型在指令数据集上进行了监督微调，并应用了直接偏好优化（DPO）。这使得模型在人类评估基准测试中的表现超过了其他模型。 4. 偏见和情感分析：通过在偏见基准测试（如BBQ和BOLD）上评估模型，论文展示了Mixtral相对于其他模型在减少偏见和提高情感平衡方面的优势。 5. 专家选择分析：论文对路由网络选择专家的行为进行了分析，以了解在训练过程中是否存在某些专家专门化于特定领域。这有助于理解模型的内部工作机制，并可能为未来的模型优化提供指导。 6. 模型架构和训练：Mixtral基于Transformer架构，并采用了特殊的稀疏混合专家层。这种架构允许在保持模型性能的同时，通过专家选择来控制计算成本。 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833dac73c407c27e1ec87c709a6fe738/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bbf2a5cee1acc43e85aa428f3457bab/" rel="bookmark">
			go 语言常见问题（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		11. recover的执行时机 无，recover 必须在 defer 函数中运行。recover 捕获的是祖父级调用时的异常，直接调用时无效。
func main() { recover() panic(1) } 直接 defer 调用也是无效。
func main() { defer recover() panic(1) } defer 调用时多层嵌套依然无效。
func main() { defer func() { func() { recover() }() }() panic(1) } 必须在 defer 函数中直接调用才有效。
func main() { defer func() { recover() }() panic(1) } 12. 闭包错误引用同一个变量问题怎么处理 在每轮迭代中生成一个局部变量 i 。如果没有 i := i 这行，将会打印同一个变量。
func main() { for i := 0; i &lt; 5; i++ { i := i defer func() { println(i) }() } } 或者是通过函数参数传入 i 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bbf2a5cee1acc43e85aa428f3457bab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2306264b4cbf60c56161075883cf6fc7/" rel="bookmark">
			用matlab解决简单的数学问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 微分和积分 微分和积分是数学计算中常用的手段。微积分最重要的思想就是”微元“与”逐次逼近“，一个整体的事物往往不好研究，但是通过微元分割成一下块一小块的，当做常量处理，最终加起来就能实现运行效果。在matlab中实现函数微分使用diff函数，实现函数积分使用int函数，其函数具体参数如下：
Y= diff(X，n，dim)是沿dim指定的维计算的第n个差分。dim输入是一个正整数标量。 Y=integral(fun，xmin，xmax)使用全局自适应积分和默认误差容限在xmin至xmax间以数值形式为函数fun求积分。 具体代码如下： % 微分 syms x y=3*x^3-6*x^2+5*x+2; % 定义函数 diff(y,x,1) % 一阶微分 diff(y,x,2) % 二阶微分 diff(y,x,3) % 三阶微分 %% % 积分 syms x y=3*x^3-6*x^2+5*x+2; % 定义函数 int(y) % 求不定积分 int(y,3,4) % 求定积分 int(y,'a','b') % a、b为上下限的定积分 运行结果如下图：
diff可以实现函数的各阶微分，同时如果输入为一组向量，则可以计算向量差分结果；integral函数在matlab中可以直接使用int代替，既可以求定积分、不定积分也可以计算无穷积分。
2 数值统计 对于一组数据，如果我们想分析它的统计特性，发现它的分布规律，我们会使用均值和方差描述一组数据在概率空间中的分布情况。在matlab中实现均值使用mean，实现方差使用var，标准差使用std，其函数具体参数如下：
M=mean(A)返回 A 沿大小大于 1 的第一个数组维度的元素的均值。V=var(A)返回A沿大小大于1的第一个数组维度计算的元素的方差。默认情况下，方差按N-1实现归一化，其中N是观测值数量。S = std(A)返回 A 沿大小大于 1 的第一个数组维度计算的元素的标准差。默认情况下，标准差按 N-1 实现归一化，其中 N 是观测值数量。 具体代码如下：
%% % 数值统计 A=[1 2 3 4 5 6] % 输入序列 mean_A=mean(A) % 求均值 var_A=var(A) % 求方差 std_A=std(A) % 求标准差 运行结果如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2306264b4cbf60c56161075883cf6fc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63a80984bd2284056a2c300abf6da699/" rel="bookmark">
			Vue学习笔记：setup语法糖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue的"setup"语法糖是在Vue 3.x版本中引入的新特性，用于替代之前版本中的"beforeCreate"和"created"生命周期钩子函数，并且用于在组件实例化过程中进行状态和逻辑的设置。
"setup"函数接收两个参数：props和context。props是组件的属性，context包含了当前组件实例的一些上下文信息。在"setup"函数内部，可以通过返回一个对象来设置组件的状态和处理逻辑，这些返回的值将会在组件实例上可用。
使用"setup"语法糖的好处在于它更加灵活，能够更好地与Composition API配合使用，让组件逻辑更加清晰和易于维护。同时，由于"setup"函数是在组件实例化之前执行的，因此它也可以用于处理一些初始化工作。
以下是一个简单的例子来展示"setup"语法糖的使用：
// Vue组件 const MyComponent = { props: { message: { type: String, required: true, }, }, setup(props, context) { // 在setup函数内部处理逻辑和状态 const count = Vue.ref(0); // 在组件内部可以使用props和context console.log('props:', props.message); // 返回一个包含状态和逻辑的对象 return { count, increment() { count.value++; }, }; }, template: ` &lt;div&gt; &lt;p&gt;{{ props.message }}&lt;/p&gt; &lt;p&gt;Count: {{ count }}&lt;/p&gt; &lt;button @click="increment"&gt;Increment&lt;/button&gt; &lt;/div&gt; `, }; 总结："setup"语法糖是Vue 3.x版本中引入的新特性，用于替代"beforeCreate"和"created"生命周期钩子函数，并在组件实例化过程中设置状态和逻辑。通过返回一个对象，"setup"函数能够让组件逻辑更清晰和易于维护。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54a27857c1c154cf0f5c2b9f1d989f1a/" rel="bookmark">
			【small syposis: 脾气好的人是怎么做到的？读《非暴力沟通》】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		syposis for book of non-violence communication Nil) website addressI) text excerptionII) 描述事实II) 表达感受&amp;需要IV) 提出请求 Nil) website address url resource
I) text excerption 为什么生气？有人出言不逊？有人拿你东西？侵犯个人权利？孩子比听话？朋友欺骗？，，，这些理由归结为一个：我们的需求没有被满足（physiology生理需求--&gt;safe安全需求--&gt;social activity社交需求--&gt;尊重需求--&gt;self value realized） Needs not to be fullfilled, then we need to put foward/propose/bring out/advance the needs, then /negotiate/discuss/ with the better half Anger will blind us, and a protection mechanism, which gets adrenaline higher with faster heartbeats, and transmits more blood into the limbs. Man will prepare to fight, defend or flee/withdraw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54a27857c1c154cf0f5c2b9f1d989f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a783da232493505a1a2f612bc79cc823/" rel="bookmark">
			GEE计算Landsat8的NDVI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 前言源代码结果 前言 NDVI=（近红-红）/（近红+红）
normalizedDifference方法是（A-B）/（A+B）的计算方法
计算NDVI一般用来配合其他反演参数，构造指数或者数据升降尺度。
源代码 var roi = ee.FeatureCollection('projects/a-flyllf0313/assets/dachang'); Map.centerObject(roi, 7); var dataset = ee.ImageCollection("LANDSAT/LC08/C02/T1_L2") .filterDate('2023-05-05', '2023-05-10') .median() .clip(roi); var ndvi = dataset.normalizedDifference(["SR_B5", "SR_B4"]); var visParam = { min: -0.2, max: 0.8, palette: 'FFFFFF, CE7E45, DF923D, F1B555, FCD163, 99B718, 74A901, 66A000, 529400,' + '3E8601, 207401, 056201, 004C00, 023B01, 012E01, 011D01, 011301' }; Map.addLayer(ndvi, visParam, "ndvi"); 使用该代码获取5.5-5.10期间Landsat 8的影像的B4、B5波段，并裁剪出研究区，进行NDVI计算
结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76ce71167480c89503b31860b81a54e/" rel="bookmark">
			关于 SSL/CA 证书及其相关证书文件（pem、crt、cer、key、csr）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.pre 首先要明确一下几个概念，加密，数字签名，和数字证书。加密分为对称加密和非对称加密。其中对称加密，双方使用同一个密钥进行加解密。存在的问题是在第一次与陌生人进行通信时，如何安全的传递密钥。而非对称密钥，双方使用不同的密钥进行加解密。通信时，使用公钥进行加密，而使用私钥进行解密。因为私钥是不传输的，所以就解决了密钥传输的安全问题。同时，公钥私钥可以进行身份认证，实现数字签名。具体如下
对消息内容进行哈希计算，得到hashcode，利用私钥对hashcode进行加密可以标识身份，因为私钥唯一，公钥与私钥是一对，公钥能解密成功，证明消息的发送方一定是私钥的持有者可以校验消息的一致性，消息和数字签名一同发送给接收方，如果消息被篡改，hashcode和数字签名中保存的hashcode不一样，数字签名中的hashcode无法修改，否则解密不会成功 通过数字签名，能够让公钥的持有方确认数据的完整性和可靠性（确实从私钥持有方发送的）但在与陌生人第一次建立通信时，如何确认收到的公钥是对方发送的，而不是通信被截获之后伪造的。（比如：我想访问B网站，但是请求被截获，C网站伪造了一个公钥发给了我，然后我就用这个公钥加密我的隐私数据，发送给C网站，C网站就用它的私钥进行了解密获取个人信息）。此时我们就需要数字证书，来确认公钥的身份验证。因为数字证书的是由权威机构颁布的，这个证书中所包含的公钥是被认证过的公钥，我们只需要验证证书的真伪，而公钥的真伪则交给了CA担保。证书的真伪是通过CA证书的数字签名来确保的，用事先已经存储在客户端的CA公钥，进行CA的数字签名确认。
2.数字证书 CA（certification authority）颁发数字证书的权威机构，来创建CA证书，包含了以下信息：
1.证书所有者信息：
主题（Subject）：证书所有者的身份信息，可能包括个人、组织、设备或服务的名称，以及其他区分信息，如组织单位、地理位置等。
2.证书颁发机构信息：
颁发者（Issuer）：签发和认证证书的证书颁发机构（CA）的名称。
3.公钥：
公钥（Public Key）：与证书所有者的私钥相对应的公钥，用于数字签名的验证和信息的加密。
4.证书有效期：
有效期（Validity Period）：证书的有效开始日期和结束日期，标志了证书的有效使用时间范围。
5.证书序列号：
序列号（Serial Number）：CA分配给证书的唯一编号，用于唯一标识证书。
6.签名算法：
签名算法（Signature Algorithm）：用于CA签名证书的算法，例如SHA-256和RSA组合。
7.CA的数字签名：
CA的数字签名（CA's Digital Signature）：CA使用其私钥对证书信息进行签名的结果，用于证明证书的真实性。
8.证书扩展（可选）：
密钥使用（Key Usage）：说明了证书中的公钥应如何使用，例如用于数据加密、数字签名、证书签名等。
扩展密钥使用（Extended Key Usage, EKU）：更具体地描述了公钥的预期用途，例如用于服务器认证、客户端认证、代码签名等。
主题备用名称（Subject Alternative Name, SAN）：允许为证书主题指定多个名称，如多个域名或IP地址。
CRL分布点（CRL Distribution Points）：提供了检查证书撤销状态的在线资源位置，如证书撤销列表（CRL）或在线证书状态协议（OCSP）服务器的UR
client向server发送请求；
server向client下发CA证书；
client比较证书中所有者的信息与正在访问的服务提供者的信息是否一致，确认公钥的身份一致性；
client校验证书是否为合法机构颁发，确认公钥的真实性；
client生成一个随机值（对称密钥），然后用证书中的公钥对该对称密钥加密；
server利用非对称私钥解密client发送的信息，从中得到对称密钥；
之后server和client就可以通过对称密钥进行信息交互。
证书格式
从分类标准上分，SSL 证书格式主要有：
公钥证书格式标准 X.509 中定义的 PEM 和 DER
公钥加密标准 PKCS 中定义的 PKCS#7 和 PKCS#12
Java环境专用的 JKS
从文件格式上分，SSL 证书格式主要有：
一种是 Base64 (ASCII) 编码的文本格式。这种证书文件是可以通过文本编辑器打开，甚至进行编辑，常见有 PEM 证书格式，扩展名包括 PEM、CRT 和 KEY。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c76ce71167480c89503b31860b81a54e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdc6992ceb799c6733f6eb99ab1fa7b5/" rel="bookmark">
			深度学习 Day26——J5DenseNet&#43;SE-Net实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍨 本文为🔗365天深度学习训练营 中的学习记录博客🍖 原作者：K同学啊 | 接辅导、项目定制🚀 文章来源：K同学的学习圈子 文章目录 前言1 我的环境2 pytorch实现DenseNet算法2.1 前期准备2.1.1 引入库2.1.2 设置GPU（如果设备上支持GPU就使用GPU,否则使用CPU）2.1.3 导入数据2.1.4 可视化数据2.1.4 图像数据变换2.1.4 划分数据集2.1.4 加载数据2.1.4 查看数据 2.2 搭建DenseNet_SE模型2.3 训练模型2.3.1 设置超参数2.3.2 编写训练函数2.3.3 编写测试函数2.3.4 正式训练 2.4 结果可视化2.4 指定图片进行预测2.6 模型评估 3 tensorflow实现DenseNet算法3.1.引入库3.2.设置GPU（如果使用的是CPU可以忽略这步）3.3.导入数据3.4.查看数据3.5.加载数据3.6.再次检查数据3.7.配置数据集3.8.可视化数据3.9.构建DenseNet网络3.10.编译模型3.11.训练模型3.12.模型评估3.13.图像预测 4 知识点详解4.1 SE-Net算法详解 4 总结 前言 关键字： pytorch实现DenseNet_SE算法，tensorflow实现DenseNet_SE算法，SE_Net算法详解
1 我的环境 电脑系统：Windows 11语言环境：python 3.8.6编译器：pycharm2020.2.3深度学习环境：
torch == 1.9.1+cu111
torchvision == 0.10.1+cu111
TensorFlow 2.10.1显卡：NVIDIA GeForce RTX 4070 2 pytorch实现DenseNet算法 2.1 前期准备 2.1.1 引入库 import torch import torch.nn as nn import time import copy from torchvision import transforms, datasets from pathlib import Path from PIL import Image import torchsummary as summary import torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdc6992ceb799c6733f6eb99ab1fa7b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07615574163c8fbfa2e7d09a29a469aa/" rel="bookmark">
			掌握设计模式：深入了解命令模式的优雅调度与行为解耦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令模式是一种行为设计模式，其目的是将请求发送者和接收者解耦，从而允许发送者发送请求，而无需知道请求的具体处理方式。在命令模式中，请求被封装为一个对象，这个对象包含了执行请求所需的所有信息，包括调用方法、参数等。这样，请求的发送者只需知道如何发送命令对象，而不需要关心命令的具体执行。
关键角色和概念： 命令接口（Command）： 声明了执行命令的方法 execute()，以及可能的撤销方法 undo() 和重做方法 redo()。这个接口可以有多个具体实现类，每个类代表不同的命令。
具体命令（ConcreteCommand）： 实现了命令接口，负责执行具体的操作。它通常包含一个接收者对象，通过调用接收者的方法来完成实际的工作。
调用者（Invoker）： 请求的发送者，负责将命令发送给接收者。它并不知道命令的具体执行细节，只是负责发送请求。
接收者（Receiver）： 实际执行命令操作的对象。命令对象通常会包含一个接收者，通过调用接收者的方法来完成命令的执行。
客户端（Client）： 创建命令对象、接收者对象以及调用者对象的地方。客户端将命令对象与调用者关联，并发送请求。
命令模式的优点包括： 解耦请求发送者和接收者： 命令模式将请求的发送者和接收者解耦，使得它们不需要直接了解对方。这提高了系统的灵活性和可维护性。
支持撤销和重做： 通过在命令对象中添加 undo() 和 redo() 方法，可以轻松实现撤销和重做操作。
容易扩展： 可以轻松添加新的命令类，无需修改现有的代码。
命令模式通常在需要对请求进行参数化、排队、记录日志、支持撤销和重做等场景中发挥作用。
简易命令模式示例： &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Command Pattern Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 页面标题 --&gt; &lt;h1&gt;Command Pattern Demo&lt;/h1&gt; &lt;!-- 按钮触发灯的开关命令 --&gt; &lt;button onclick="pressLightButton()"&gt;Toggle Light&lt;/button&gt; &lt;!-- 按钮触发风扇的开关命令 --&gt; &lt;button onclick="pressFanButton()"&gt;Toggle Fan&lt;/button&gt; &lt;!-- 按钮触发撤销操作 --&gt; &lt;button onclick="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07615574163c8fbfa2e7d09a29a469aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e705897542f3636500be2fe26683834f/" rel="bookmark">
			Simpy简介：python仿真模拟库-03/5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说明 在过去的两篇文章中，我们了解了 simpy 的基础知识、声明变量和处理表达式。值得注意的例子包括评估导数和积分。现在，让我们继续使用函数。 二、SymPy — 函数类 SymPy 包包含 sympy.core.function 模块中的 Function 类。该类作为各种数学函数的基础，也充当未定义函数类的构造函数。
以下类别的函数继承自 Function 类 -
复数函数三角函数整数函数组合函数其他杂项功能 三、复数函数 这组函数在sympy.functions.elementary.complexes模块中定义。
re -- 该函数返回表达式的实部 from sympy import * re(5+3*I) Output: 5 re(I) Output: 0 Im --表达式的虚部 im(5+3*I) Output: 3 im(I) Output: 1 sign --表达式的符号 他的函数返回表达式的复数符号。
对于真实的表达，符号将是 -
1 如果表达式为正如果表达式等于 0，则为 0如果表达式为负数，则为 -1 如果表达式是虚数，则返回的符号为 -
I 如果 im(表达式) 为正-I 如果 im(表达式) 为负数 sign(1.55), sign(-1), sign(S.Zero) Output: (1, -1, 0) sign (-3*I), sign(I*2) Output: (-I, I) Abs 该函数计算复数的大小，测量复平面上从原点 (0,0) 到点 (a, b) 的距离。它是 abs() 函数的扩展，允许符号输入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e705897542f3636500be2fe26683834f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc28ba3d94196098dc6caa87f63c697/" rel="bookmark">
			sqlalchemy expire_all 方法详解，强制刷新会话缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 SQLAlchemy 中，expire_all() 方法是 Session 类的一个重要方法，用于使会话（Session）中所有当前加载的对象过期。这意味着下次访问任何已加载对象的属性时，SQLAlchemy 将从数据库中重新加载这些对象的最新状态。这是一个强制刷新加载对象状态的方法，确保您获取的是数据库中的最新数据。
功能 当您调用 session.expire_all() 时，会发生以下事情：
标记所有对象为过期：在该会话中加载的所有对象都被标记为“过期”。这意味着它们的当前状态将被丢弃，而不是从会话的缓存中提取。
延迟加载：在下次访问这些对象的任何属性时，SQLAlchemy 会自动从数据库中重新加载它们的最新状态。这是一个延迟操作，只有在实际访问属性时才会触发。
不影响未修改的对象：即使对象自加载后未被修改，它们的状态也会被清除并在下次访问时重新加载。
使用场景 您可能会在以下情况下使用 expire_all()：
保证数据一致性：在长时间运行的会话中，为了确保获取到数据库中的最新数据，可以使用 expire_all() 方法。
避免脏读：在有可能发生并发修改的场景中，使用 expire_all() 可以防止读取到过时的数据。
手动刷新状态：在某些复杂的交互逻辑中，您可能需要手动刷新对象状态，以确保应用逻辑的正确性。
示例 from sqlalchemy.orm import sessionmaker from my_model import MyModel # 假设您有一个模型类 MyModel from sqlalchemy import create_engine # 创建会话 engine = create_engine("sqlite:///mydatabase.db") Session = sessionmaker(bind=engine) session = Session() # 查询并使用对象 my_object = session.query(MyModel).first() print(my_object.some_attribute) # 确保从数据库重新加载对象 session.expire_all() # 当再次访问属性时，将从数据库重新加载它的最新状态 print(my_object.some_attribute) SQLAlchemy 2.0 代码展示 print("=====================================会话缓存==================================================") # 第一次查询，并加载用户的所有关联部门项 sql1 = select(models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cc28ba3d94196098dc6caa87f63c697/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08e713e0f4ceec3c51971856101a8289/" rel="bookmark">
			git 上传出现“ ! [rejected] master -＞ master (non-fast-forward)”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设置git仓库
1、先删除原来仓库
git remote rm origin 2、添加仓库
git remote add origin [url] 注意：若要修改仓库
git remote origin set-url [url] 二、
在使用Git 配置公司的远程仓库时git push origin master，出现以下问题
xu:QProj xiaokai$ git push origin master To https://gitee.com/XXXXX.git ! [rejected] master -&gt; master (non-fast-forward) error: failed to push some refs to 'https://gitee.com/XXXXX.git' hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: 'git pull .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08e713e0f4ceec3c51971856101a8289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65adbf34fe0753ae0ae28b3c499b5997/" rel="bookmark">
			LeetCode 2696. 删除子串后的字符串最小长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 1、题目描述 给你一个仅由 大写 英文字符组成的字符串 s 。
你可以对此字符串执行一些操作，在每一步操作中，你可以从 s 中删除 任一个 "AB" 或 "CD" 子字符串。
通过执行操作，删除所有 "AB" 和 "CD" 子串，返回可获得的最终字符串的 最小 可能长度。
注意，删除子串后，重新连接出的字符串可能会产生新的 "AB" 或 "CD" 子串。
2、接口描述 ​ class Solution { public: int minLength(string s) { } }; 3、原题链接 2696. 删除子串后的字符串最小长度
二、解题报告 1、思路分析 当成括号匹配问题即可，一次遍历维护一个栈，和栈顶配对就记录
2、复杂度 时间复杂度： O(N) 空间复杂度：O(N)
3、代码详解 ​ class Solution { public: int minLength(string s) { stack&lt;char&gt; st; int ret = s.size(); for(auto x : s) { if(st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65adbf34fe0753ae0ae28b3c499b5997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0329657c64f1a6f74f97094bb5fae51c/" rel="bookmark">
			编程语言的未来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程语言的未来？ 预测编程语言的未来是一项复杂的任务，因为它受到技术趋势、行业需求、社区支持和开发者偏好等多种因素的影响。然而，以下是一些当前观察到的趋势和可能的发展方向：
多样性和专业化： 软件开发领域的多样性正在增加。不同的编程语言在不同的领域和任务上可能更为适用。专业化的语言和工具可能会得到更多关注，以满足特定需求。Web 开发和云计算： JavaScript 和 Python 等语言在 Web 开发和云计算领域取得了很大成功。未来，这些领域的重要性可能会继续增加，对应的语言和框架也会持续发展。机器学习和人工智能： 由于机器学习和人工智能的发展，像 Python、TensorFlow、PyTorch 等语言和框架在这一领域的应用逐渐增多。未来，可能会出现更多专门用于机器学习的语言和工具。安全性： 对于安全性的关注不断增加，因此更注重安全性的编程语言和工具可能会受到更多关注。例如，Rust 被认为在系统级编程中具有较高的安全性。并发和并行编程： 随着硬件越来越多地朝着多核和分布式系统发展，对并发和并行编程的需求也在增加。具有良好并发支持的语言可能会更受欢迎。低代码/无代码平台： 随着低代码/无代码平台的兴起，未来可能会出现更多简化开发流程的工具，降低编程门槛，使非专业开发者也能参与到应用开发中。可维护性和易用性： 更强调代码的可维护性和易用性。一些语言和框架可能会采用更直观的语法和工具，以提高开发效率。社区和生态系统： 语言的成功不仅仅取决于语言本身的特性，还取决于社区的活跃程度和生态系统的丰富度。支持广泛的社区和生态系统可能会对语言的持续发展起到关键作用。 总体而言，未来编程语言的发展将受到技术和行业趋势的影响，同时还会受到开发者社区和市场需求的塑造。不同的语言可能会在不同的领域和场景中发挥作用，而多样性和灵活性可能成为编程语言生态系统的主要特征。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c28b5d544ed8b50f47d8dc6017d32e9b/" rel="bookmark">
			软件定义存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件定义存储源于VMware公司于2012年提出的软件定义的数据中心（SDDC）。存储作为软件定义的数据中心不可或缺的一部分，其以虚拟化为基础，但又不仅限于虚拟化。存储虚拟化一般只能在专门的硬件设备上应用，很多设备都是经过专门的定做才能够进行存储虚拟化。而软件定义存储则没有设备限制，可以简单地理解为存储的管理程序（类似于软件定义计算中虚拟机管理程序VMM）。
软件定义存储是对现有操作系统和管理软件的一个结合，能够完整实现我们对存储系统的部署、管理、监控、调整等多种要求，可以给我们的存储系统带来敏捷、高可用、跨数据中心支持等特点。
软件定义存储通常具有如下几大特性：
·开放性（Open） · 简单化（Simplified） · 可扩展性（Scalable） 开放的软件定义存储主要指两个维度：API的标准化与可编程平台的支持。使用标准的开放的API，任何人都可以基于此而构建数据服务。这一点不仅有利于大的企业，对于创业公司更加方便，因为它为客户提供一个开放式底层的存储平台可以利用。开放的API必然是用来支撑一套可编程架构，可以实现一次编程、多次运行、无处不在的数据服务。此二者结合起来促进开放式开发社区的全局数据和自动化服务的交付。
简单化是所有存储应用与用户追求的目标，包括统一的管理接口与界面、自动化的存储配置与部署，便捷的存储扩展、升级及优化。现代存储系统自20世纪中叶诞生以来一直是一个非常专业化的领域，它的复杂性与挑战性令另很多人望而止步，但是软件定义存储的出现在逐渐颠覆这一现象，存储变得更容易被管理，更容易满足客户与应用的需求。
可扩展性指的是存储系统中对同构或异构存储解决方案、服务的可接入性，它在一定程度上与系统的开放性类似，允许对存储系统实施动态的升级、扩展，接入第三方存储服务或设备等。
作为软件定义的存储的核心技术，我们先聚焦存储虚拟化，它可以在计算、网络和存储层实施。
·在计算层，虚拟机管理程序为虚拟机分配存储空间，而屏蔽掉了（不暴露）物理存储的复杂性。
· 数据块（Block）和文件级别（File）的虚拟化是基于网络的虚拟化技术。这两项技术在网络层中嵌入虚拟化存储资源的智能，我们常见的NFS/CIFS网络协议正是这些存储虚拟化技术在网络层面的体现。
事实上数据块与文件类型的存储从操作系统技术栈角度看通常是在不同层实现的。以Linux操作系统为例，如下图所示，文件系统通常在块设备之上实现（每多一层抽象、虚拟化，效率就会降低一点），这也解释了为什么通常基于块设备的解决方案的效率（数据吞吐率）高于基于文件系统。
Linux内核系统调用接口
· 在存储层，虚拟资源调配和自动存储分层一起简化存储管理，并帮助优化存储基础架构（见下图）。
虚拟化的存储
下面我们以虚拟机为例介绍一下虚拟化计算、存储与网络如何整合工作。
虚拟机通常是作为一组文件存储在分配给虚拟机管理程序的存储设备上。其中一个名为“虚拟磁盘文件”的文件表示虚拟机用来存储其数据的虚拟磁盘。虚拟磁盘对于虚拟机显示为本地物理磁盘驱动器。虚拟磁盘文件的大小表示分配给虚拟磁盘的存储空间。虚拟机管理程序可以访问光纤通道存储设备或IP存储设备，例如iSCSI和网络连接存储设备。虚拟机一直察觉不到可用于虚拟机管理程序的总存储空间和底层存储技术。虚拟机文件可以由虚拟机管理程序的本机文件系统［也被称为虚拟机文件系统 （VMFS）］或网络文件系统 （NFS）（如网络连接存储文件系统）来管理。
主流的软件定义存储技术方案通常对数据管理（Control Plane）与数据读写（Data Plane）实现分离，由统一的管理接口与上层管理软件交互，而在数据交互方面，则可以兼容各种不同的连接方式。这种方式可以很好地与传统的软硬件环境兼容，从而避免“破坏性”的改造。如何合理利用各级存储资源，在数据中心的级别上提供分层、缓存也是需要特别考虑的。因此，软件定义存储中的控制层通常提供如：:系统配置、自动化、自服务、管控中心等服务，而在数据层则暴露给应用不同类型的存储服务，如对象存储、HDFS、文件或块存储。整个SDS系统逻辑组件可参考下图所示。
软件定义存储的逻辑组件与分层
软件定义的存储将抽象的控制层与数据层进行了分离，并提供接口给用户。用户可以使用接口定义自己的数据控制策略。为什么要将抽象的控制层与数据层分离，并且提供接口给用户调用？如表3-5所示，控制层是指对数据的管理策略，控制层不需要知道数据具体的存储方式，如块、文件或者对象存储。控制层的时间损耗（延迟）级别是在毫秒级。数据层则是指具体读写硬件方式，如块、文件或者对象读。时间延迟是在微秒级。
存储控制层和数据层（下表）：
存储控制层存储数据层速度级别毫秒级微秒级例子数据服务的策略Block、NAS、Object I/O表示数据服务策略数据服务特性 用户在使用存储时，着重关注数据服务的策略，而这些策略与具体的数据存储方式无关。当今的存储虚拟化产品将存储控制和数据层结合，即数据服务的策略紧密依赖于数据存储的方式。事实上，数据存储速度是微秒级，而数据存储控制较慢。当实现数据服务策略时，主要的时间开销在控制层，而传统的存储虚拟化技术不能灵活配置存储控制，因此针对某个服务的变化，响应时间主要是控制开销。再者，用户存储数据时，必须对数据的控制和存储方式都需要足够的了解，这增加了使用存储资源的难度，而且存储资源的可扩展性不高。此外，由于传统的存储虚拟化技术缺少标准的存储数据监控功能，当某个设备出现问题时，用户只能依赖底层的一些存储机制（如日志）进行问题发现和定位。表3-6中描述了存储虚拟化与软件定义的存储之间的异同。
存储虚拟化与软件定义的存储（下表）：
存储虚拟化软件定义的存储Control Plane抽象抽象Data Plane抽象不抽象隔离性要求高低时间开销高低可扩展性低高数据监控低高数据安全低高 从软件定义的数据中心角度看，软件定义存储形成了一个统一的虚拟存储池（Unified Virtualized Storage Pool），该存储池提供了标准化接口的存储应用服务，例如典型的企业级Exchange（邮件）、Hadoop（大数据分析）、VDI（远程桌面、瘦客户端后台）、数据库等存储服务。这些服务的等级、特性、优先级等可以通过软件定义数据中心的SLA等策略来规范与定制。图3-35形象地展示了软件定义存储与软件定义数据中心的逻辑关系。
软件定义的数据中心之软件定义的存储
换一个角度，从技术栈视角去看软件定义的存储、网络与计算，结合曾经流行的OpenStack平台组件（或者K8S...），我们可以把一个软件定义的数据中心从功能上分为四层（自下而上，如图3-36所示）：
· 基础架构层 ·云管理层 · 云服务层 ·管理界面层 软件定义的数据中心之软件定义的存储（技术栈角度）
基础架构层由典型的计算虚拟化组件（KVM/Docker等）、网络虚拟化（NVP/OpenFlow/Open vSwitch等）以及存储虚拟化（Ceph/ScaleIO/VSAN等）构成；云管理层则可视为对基础架构层的封装、标准化并向上层提供统一可编程与管理接口；云服务层向之上的管理界面提供了标准化服务接口，如计费、日志、数据库服务、数据备份与恢复等服务。
上图中的软件定义数据中心依旧缺失了另外两块主要的组件：
·Security（安全组件） ·M&amp;O（Management &amp; Orchestration）管理与编排组件 随着数据中心系统的规模与复杂度指数级地提高，管理这样一个庞大的系统需要高度的自动化以及与之匹配的安全保障。因此，对硬件与软件的综合管理与编排以及安全管理系统变得越来越重要，例如VMware的vCenter、微软的System Center、开源OpenStack项目都提供了各自的SDDC M&amp;O组件。安全组件则通常会以系统安全分析、入侵预防与报警、漏洞检测、事件流分析等功能组件形式与M&amp;O系统对接。图3-37展示了在软件定义的数据中心中，五大组件（软件定义的计算、存储、网络、安全及M&amp;O）的逻辑、分层关系。
软件定义的数据中心五大组件逻辑架构图
需要指出的是无论是安全还是M&amp;O，它们整体的发展趋势都是朝着大数据、快数据、流数据的方向发展，相关系统的体系架构也一定是朝着分布式、并行式的云计算架构方向前进，这其中对网络（负责数据的迁移）、计算（负责通过对数据的计算、分析得出信息与智能）以及存储（负责数据最终的存放与管理）具有天然的需求。因此，我们在看待其中任何一个环节、部件或组件的时候，都需要有一个五位一体（见上图）的全局观，这样才能避免片面、孤立或过度微观。
另据IDC 2015年提供的报告，未来企业级存储变革的四大关键技术分别是：闪存、软件定义、融合存储和云。闪存与融合存储指的都是硬件层面设备的迭代更新，而软件定义与云则是通过软件化、虚拟化（抽象化）来更好地把硬件接入到云化的软件系统架构内，以更好地服务于用户需求。今天看来，这份6年前报告依然是有价值的，不过有一些新的变化。闪存，特别是企业级闪存，显然需要更激进的替代现有的仍旧基于磁盘的存储模式，随着闪存的成本不断降低，闪存存储所带来的10倍以上的性能优势不言而喻，特别是对于数据库级别的产品而言，脱离了底层的硬件性能提升而谈软件定义存储，未免显得舍本逐末了。另外，最近1-2年随着大内存（持久化内存）产品的推出（例如Intel的Optane），笔者以为，这将会是颠覆性的 -- 没有人可以拒绝内存级别的持久化存储产品，想想数据库如果持久化在内存级存储设备上面，没有IOPS的世界会是什么样子的？光速对高铁、高铁对蜗牛的感觉？
让我们把剩下的交给时光和人心。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/295821a14d5c78b7bd3f862510e87fa0/" rel="bookmark">
			Redis 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数据库架构发展 随着互联网+和大数据时代的来临，传统的关系型数据库已经不能满足中大型网站日益增长的访问量和数据量，这个时候就需要一种能够快速存取数据的组件来缓解数据库服务 I/O 的压力 ，来解决系统性能上的瓶颈。
数据库应用的发展历史：
架构
描述
单数据库实例
在互联网大数据时代来临前，企业的一些内部信息管理系统，一个单个数据库实例就可以应付系统的需求。
缓存+数据库实例
随着系统访问量用户的增多，数据量的增大 ，单个数据库实例已经满足不了系统读取数据的需求 。
缓存+主从数据库+读写分离
缓存可以缓解数据库的读取压力，但是数据量的写入压力持续增大，可以采取数据库主从进行读写分离
缓存+主从数据库集群
+读写分离+分库分表
数据量再次增大，读写分离以后 ，主数据库的写库压力出现瓶颈。
NoSql 数据库 +主从数据库集群
+读写分离 +分库分表
互联网+大数据时代来临，关系型数据库不能很好的存取一些并发性大，实时性高而且格式不固定的数据。
2、Redis 介绍 Redis 是当前比较热门的 NOSQL 数据库系统之一，它是一个开源的使用 C 语言编写的键值对（key-value）数据存储系统（区别于 MySQL 的二维表格的形式存储。）
关系型数据库：Oracle/ Mysql/ SqlServerNoSql数据库：Redis / MongoDB/Hbase Redis 默认端口是 6379
Redis 和 Memcache 类似，但很大程度补偿了 Memcache 的不足，Redis 数据都是缓存在计算机内存中，不同的是，Memcache 只能将数据缓存到内存中，无法自动定期写入硬盘，这就表示，一断电或重启，内存清空，数据丢失。所以 Memcache 的应用场景适用于缓存无需持久化的数据。而 Redis 不同的是它会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，实现数据的持久化。
a. redis 特点 ① Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
② Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供字符串（strings）、lists（列表）、sets（集合）和 zsets（有序集合）、散列（hash）等数据结构的存储。
③ Redis 支持数据的备份，即 master-slave 模式的数据备份。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/295821a14d5c78b7bd3f862510e87fa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6d03097d0462617a5c9d26bde358bc1/" rel="bookmark">
			数据结构02附录02：哈希表[C&#43;&#43;]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图源：文心一言
上机题目练习整理~🥝🥝
本篇作为线性表的代码补充，每道题提供了优解和暴力解算法，供小伙伴们参考~🥝🥝
第1版：在力扣新手村刷题的记录，优解是Bard老师提供的建议~🧩🧩 编辑：梅头脑🌸
题目：1512. 好数对的数目 - 力扣（LeetCode）
📇目录 📇目录
🧵好数对的题目
🧩题目
🌰时间复杂度更好 🌰空间复杂度更好
🔚结语
🧵好数对的题目 🧩题目 给你一个整数数组 nums 。
如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。
返回好数对的数目。
示例 1：
输入：nums = [1,2,3,1,1,3] 输出：4 解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始 示例 2：
输入：nums = [1,1,1,1] 输出：6 解释：数组中的每组数字都是好数对 示例 3：
输入：nums = [1,2,3] 输出：0 🌰时间复杂度更好 📇优解思路
算法思想： 使用哈希表 hash 存储元素出现的次数。遍历哈希表，统计每个元素出现的次数大于 1 的情况。对于每个出现的次数大于 1 的元素，其好数对的数目为 出现的次数 - 1。时间复杂度：O(n)，其中n是数组的长度，因为遍历1遍数组。空间复杂度：O(n)，其中n是数组的长度，因为哈希表占用的长度为n。 ⌨️优解代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6d03097d0462617a5c9d26bde358bc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d0075ff2342d1c01b4f7309f52a1f07/" rel="bookmark">
			leetcode - 2385. Amount of Time for Binary Tree to Be Infected
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description You are given the root of a binary tree with unique values, and an integer start. At minute 0, an infection starts from the node with value start.
Each minute, a node becomes infected if:
The node is currently uninfected. The node is adjacent to an infected node. Return the number of minutes needed for the entire tree to be infected.
Example 1:
Input: root = [1,5,3,null,4,10,6,9,2], start = 3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d0075ff2342d1c01b4f7309f52a1f07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f273b65577437db6cbf919ce94d41ac6/" rel="bookmark">
			TDA7388引脚图说明，参数说明及应用电路分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、TDA7388概括
二、TDA7388的主要参数说明
三、TDA7388的引脚说明
四、TDA7388的应用电路和原理说明分享
一、TDA7388概括 TDA7388是一款集成的四声道BTL功放器，由STMicroelectronics（意法半导体）公司生产。该芯片具有高效能、低失真和可靠性等特点，适用于汽车音响系统和其他音频应用。
TDA7388的主要特点包括：
四声道BTL输出：可以驱动4个喇叭或2个喇叭和1个低音炮。最大输出功率：每个声道可提供4x41W（4欧姆负载）或4x25W（8欧姆负载）的功率。低失真：在最大输出功率时，失真水平较低。宽工作电压范围：可以在9V至18V的供电范围内正常工作。低静态功耗：在待机模式下，芯片的静态功耗非常低。内置过温保护和短路保护电路：能够保护芯片免受过热和短路等故障的影响。 二、TDA7388的主要参数说明 1.输入电压（VCC）范围：9V至18V
2.输出功率：
4欧姆负载时，每个声道最大输出功率为41W8欧姆负载时，每个声道最大输出功率为25WBTL模式下，最大输出功率为82W 3.频率响应范围：20Hz至20kHz
4.杂散失真（THD+N）：在1kHz时，输出功率为1W时，杂散失真小于0.2%
5.静态电流：在无音频输入时，芯片静态电流为45mA
6.工作温度范围：-40°C至+105°C
7.封装类型：多种封装可选择，如ZIP-25和DBS23P
8.芯片引脚数目：25个
需要注意的是，以上参数仅为TDA7388的一般性能说明，具体使用时请参考其官方资料手册或数据表，以确保正确地使用和应用该芯片。
以上数据可参考资料手册：TDA7388资料
三、TDA7388的引脚说明 IN1 / IN2 / IN3 / IN4：音频输入引脚。分别对应四个声道。-IN1 / -IN2 / -IN3 / -IN4：负相输入引脚。通过这些引脚接入负相输入信号。STBY：待机控制引脚。当STBY引脚接地时，芯片处于待机状态，功耗较低。当STBY引脚接高电平时，芯片开始工作。MUTE：静音控制引脚。当MUTE引脚接地时，音频输出被静音。当MUTE引脚接高电平时，音频输出正常。OUT1 / OUT2 / OUT3 / OUT4：音频输出引脚。分别对应四个声道，接入扬声器。FILT：低通滤波引脚。通过连接外部电容到FILT引脚，可以实现低通滤波。BP：带通滤波引脚。通过连接外部电容到BP引脚，可以实现带通滤波。BOOT：驱动器引导引脚。通过连接外部电容到BOOT引脚，可以提供驱动器所需的引导信号。VCC：芯片电源引脚。接入正电源。GND：芯片地引脚。 四、TDA7388的应用电路和原理说明分享 TDA7388的应用电路一般采用BTL桥接模式，即两个声道组成一个桥接输出，用于驱动一个扬声器。每个声道的输入信号通过IN引脚输入，通过负相输入引脚（-IN）接入负相输入信号。输入信号经过放大处理后，通过音频输出引脚（OUT）输出到扬声器。
TDA7388支持外部滤波器以提高音质。通过连接外部电容到FILT引脚，可以实现低通滤波；通过连接外部电容到BP引脚，可以实现带通滤波。
此外，TDA7388还需要提供正电源电压（VCC）和地引脚（GND）以供电使用。通过待机控制引脚（STBY）可以实现功耗控制，通过静音控制引脚（MUTE）可以实现静音功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da7bb1021758ea6293f36f3d5824d0ca/" rel="bookmark">
			FTP真的安全吗？如何寻找合适的替代FTP?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于企业而言，FTP作为一种传统的文件传输方式，最早出现于1970年代，由于它的简单、易用等优势，被许多企业广泛使用，但是随着网络安全问题的日益突出，FTP的安全性逐渐受到质疑，本文将探讨FTP 的安全问题以及帮助企业寻找合适的替代方案。
一、FTP传输安全方面分析
1.明文传输，容易被窃听和攻击
FTP采用明文传输方式，即数据在传输过程中是不加密的，这使得黑客可以通过监听网络数据包来窃取敏感信息，如用户名、密码等。同时，黑客还可以利用漏洞对FTP服务器进行攻击，进而窃取或篡改数据。
2.用户认证方式简单，易被破解
FTP常用的用户认证方式包括用户名和密码、SSH等，而这些认证方式的安全性相对较低。例如，用户名和密码容易被猜测或破解，SSH则可能因为配置不当而存在漏洞。
3.数据存储不安全，易被篡改
FTP传输过程中，数据是存储在FTP服务器上的，这使得数据容易遭到篡改或删除，同时，FTP服务器也可能会因为遭受攻击而出现系统崩溃或数据丢失等问题。
二、替代FTP的几种方案
市场上有多种替代FTP的方案，如FTPS提高数据安全性但仍有FTP缺点，SFTP基于SSH协议实现安全传输，AS2基于HTTP协议支持数字签名和加密，HTTPS通过SSL/TLS加密实现安全访问。各方案均有特点和限制，如FTPS需证书管理，SFTP速度受TCP协议影响，AS2配置复杂，HTTPS不支持文件上传。在选择时需根据具体需求综合考虑。
除了以上这些基于标准协议的方案，还有一些基于专有技术的文件传输软件，例如镭速。镭速（私有化部署方案，也可接入公有云，企业、社会组织用户可申请免费试用）是一款基于自研的Raysync协议的文件传输软件，它可以克服UDP协议的缺点，实现百倍的传输提速，同时保证数据的安全性和完整性，而FTP则存在很多安全问题和局限性，传输速度慢，效率低。镭速还支持多模式、多终端的文件传输和管理，快速部署，易于集成，可以满足各种复杂的文件传输场景。
三、总结
综上所述，FTP已经不再适应当前的文件传输需求，而FTP的替代方案有很多，不同的方案有不同的特点和优势，需要根据实际的场景和需求进行选择。镭速作为一款基于自研协议的文件传输软件，具有高速、安全、稳定、多模式、多终端、快速部署、易于集成等特点，可以满足各种复杂的文件传输场景，是一款值得推荐的FTP替代方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c314ea5abe6167c8e296465fa1befd61/" rel="bookmark">
			开源C语言库Melon：数据恢复算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文讲述开源C语言库Melon中的里德所罗门纠错码的使用。
关于 Melon 库，这是一个开源的 C 语言库，它具有：开箱即用、无第三方依赖、安装部署简单、中英文文档齐全等优势。
Github repo
简介 里德所罗门编码是一种纠错码技术，常被用于网络传输丢包恢复、磁盘RAID等领域。
关于里德所罗门算法原理的详细讲解，可以参考笔者以前的一篇文章《神奇的数据恢复算法》。
本文将主要利用Melon库实现的里德所罗门纠错码模块，配以实例代码，给大家直观展示纠错码的恢复能力。
使用 话不多说，我们上代码，然后进行说明：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "mln_core.h" #include "mln_log.h" #include "mln_string.h" #include "mln_rs.h" int main(int argc, char *argv[]) { mln_rs_result_t *res, *dres; char origin[] = "AAABBBCCCDDD"; uint8_t *err[6] = {0}; mln_string_t tmp; struct mln_core_attr cattr; cattr.argc = argc; cattr.argv = argv; cattr.global_init = NULL; cattr.master_process = NULL; cattr.worker_process = NULL; if (mln_core_init(&amp;cattr) &lt; 0) { fprintf(stderr, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c314ea5abe6167c8e296465fa1befd61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44d7d32e015a9114abf18e3a0bfb2dbd/" rel="bookmark">
			数字孪生&#43;可视化技术 构建智慧新能源汽车充电站监管平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 充电基础设施为电动汽车提供充换电服务，是重要的交通能源融合类基础设施。近年来，随着新能源汽车产业快速发展，我国充电基础设施持续增长，已建成世界上数量最多、服务范围最广、品种类型最全的充电基础设施体系。着眼未来新能源汽车特别是电动汽车快速增长的趋势，充电基础设施仍存在布局不够完善、结构不够合理、服务不够均衡、运营不够规范等问题。
建设背景 市场背景 新能源汽车作为国家七大战略性产业之一，是我国从汽车大国走向汽车强国的必由之路。截至2022年底，我国新能源汽车保有量达1310万辆，突破一千万辆大关，同比增长66%。随着新能源汽车产业快速发展，充电基础设施建设提速，我国公共充电基础设施保有量高速增长。根据中国充电联盟统计，2023年5月我国充电基础设施累计数量为635.6万台。据统计，截至2023年11月，我国充电基础设施保有量达到826.4万台，同比增长67.0%。其中，公共充电基础设施保有量达到262.6万台，私人充电基础设施保有量为563.8万台，全国已建设充电停车位的服务区6000余个，占高速公路服务区总数的95%，全国高速公路服务区累计建成充电桩两万个。
政策背景 2022.01.《关于进一步提升电动汽车充电基础设施服务保障能力的实施意见》，加快推进居住社区充电设施建设安装，优化城市公共充电网络建设布局。2022.02.《“十四五”现代能源体系规划》，优化充电基础设施布局，全面推动车桩协同发展，推进电动汽车与智 能电网间的能量和信息双向互动，开展光、储、充、换相结合的 新型充换电场站试点示范。2022.12.《扩大内需战略规划纲要(2022-2035年)》，推进汽车电动化、网联化、智能化，加强停车场、充电桩、换电站、加氢站等配套设施建设。2023.01.《关于组织开展公共领域车辆全面电动化先行区试点工作的通知》，推进汽车电动化、网联化、智能化，加强停车场、充电桩、换电站、加氢站等配套设施建设。2023.01.《关于进一步构建高质量充电基础设施体系的指导意见》，适度超前建设，到 2030 年建成高质量充电基础设施体系，形成城市面状、公路线状、乡村点状布局的充电网络。 建设目标 聚焦智能识别和安防监控相关场景应用，全面提升充电站管理的智能化、可视化、数字化水平，更好支撑充电站运维管理。系统设计遵循结构化、标准化、模块化、集成化，建成一套集中监控、统一管理的智慧充电站运维平台，形成功能完善、反应快速的数字化运维体系,实现充电站设备、资产的智慧化监控与管理，为覆盖项目设计、基建、运营的全生命周期过程。
系统概述 智慧充电桩通过数字孪生和可视化技术，构建充电站三维可视化场景，实时监测和管理充电桩的状态、诊断故障、调整参数等，为充电运营商和用户提供更好的充电体验。
需求分析 场站三维场景 系统基于WebGL标准下的B/S框架，前端采用HTML5+JavaScript技术为基础，进入Sovit2D/Sovit3D可视化平台后，结合物理世界建立三维场景(也可上传背景图)，对场站、充电桩等进行可视化呈现，涵盖道闸、充电桩、地锁、网络、布线、运行、环境等检测要索，并将数据接入 2D 面板，便于运维人员对整个充电站运行的有效掌控。
站点信息概览 提供场站、桩、车、物联设备等实际情况的定制化3D建模，建立智慧充电站孪生体，对站点、充电桩进行三维可视化呈现，展示环境监控、安防监控、网络监控、充电监控等数据，辅助管理人员掌握站点态势。
车位智能管理 通过现场设备精准识别车辆信息，比对通过即可自动打开车位锁，允许电动汽车进入充电。支持联动车位监测功能，当监测到车位上没有停车时，就能自动升起预防燃油车进入。该功能可有效预防城区快充站被燃油车非法占位的情况出现。
智能设备管理 基于物联网技术，实时采集场站内充电桩等设备的实时数据，对设备的运行状态、故障信息进行可视化展示，系统打破数据孤岛，对场站间设备功率、充电情况、故障情况等进行及时、准确监测，为决策者科学管理设备、优化用电决策提供支撑。
智能安防管理 通过视频监控、报警设备等技术手段，实现对场站内部安全的实时监控和管理。智能安防系统可以根据楼宇内的安全情况，自动发出警报和报警信息，提高安全性。
视频监控管理 支持无缝融合 HTML5 各项多媒体功能，根据真实世界摄像头分布情况，在三维场景中1:1还原视频监控点位，以摄像头图标标注其位置。支对场站内进行安防动态监测，并可结合前端智能感知设备应用，对异常目标自动抓拍、留存，出现异常警告时，监控点位会有声光报警效果。
智能告警管理 系统对充电桩实时监控，并基于多个维度为各类重点事件建立阈值告警触发机制，对故障进行告警，完成告警详情和故障工单记录跟踪，实现问题终端实时预警、快速定位、快速解决。
智能运维管理 通过对充电设备进行24小时监控与日常运维巡检，系统进行实时诊断和故障预测。自定义查看工单数量、用时情况，结合异常告警工单统计，可减少大量业务处理时间。
……
开发平台 数维图(SovitJs)应用自主研发的 Sovit2D、Sovit3D 产品，无缝融合 2D、3D 技术，搭建了一套3D 可视化智慧充电桩可视化运维管理平台。通过数维图可视化开发平台实现可交互式的 Web 二三维场景，基于多维感知、场景物联、物信融合的技术理念，不断丰富与完善充电站全面感知，实现设备设施智能监控、环境风险监测预警，助力集控中心集中运维，辅助决策和全局掌控。
建设价值 数字孪生智慧充电桩3D可视化运维平台有助于提高行业数字化水平，对用户而言，有利于破解“找桩难、找桩慢”的难题，更好地满足用户充电需求，提升用户体验;对行业而言，有利于提高对新能源汽车产业的支撑能力，推动物联网、大数据、人工智能等新一代ICT技术与能源、汽车产业融合发展，提高行业运营效率和效益。
总结 我国在充电桩建设、数据平台打造、个性化服务开发等方面仍有完善和提升的空间，建议未来以数字化、智能化为导向，以促进多网融合为重点，以完善规划布局、健全充电数据库、开发智能充电服务为主要抓手，促进我国数字充电桩突破性、创新性的发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d2057b82b7b9341e4dd12ef70ded56/" rel="bookmark">
			pycharm&#43;pyqt 外部工具：ui转py、打开qtDesigner、.qrc转py
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、打开设置-外部工具
2、qtdesigner工具
3、ui转py
4、prc转py
5、找到配置好的外部工具进行使用
1、打开设置-外部工具 点击“ctrl+alt+s”一键打开设置界面，进入界面后“工具-外部工具-+按钮-创建工具栏”打开创建外部工具窗口，如下图所示：
2、qtdesigner工具 程序位置：可以通过everything工具搜索designer.exe，然后直接选择复制完整路径和文件名
工作目录：固定格式$FileDir$
点击“确定-应用”后，在菜单栏中点击“qtDesigner_2017x64”打开：
打开界面后：
3、ui转py 在pycharm中使用qtdesigner制作界面之后没有办法直接使用，需要转为py文件才可以使用，我们在这里使用pyuic5.exe工具进行转换。
程序：可以通过everything工具搜索pyuic5.exe，然后直接选择复制完整路径和文件名
参数：$FileName$ -o $FileNameWithoutExtension$.py
工作目录：$FileDir$
4、prc转py 和ui文件一样，我们需要把资源文件等转为py文件才可以使用，我们在这里使用pyrcc5.exe。
程序：可以通过everything工具搜索pyrcc.exe，然后直接选择复制完整路径和文件名
参数：$FileName$ -o $FileNameWithoutExtension$.py
工作目录：$FileDir$
5、找到配置好的外部工具进行使用 点开“菜单栏-工具-External Tools”，可以看到刚才添加的三个工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8affb03cb7a5a7ddab0585c19d9e8b2/" rel="bookmark">
			Gitlab-ci:从零开始的前端自动化部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.概念介绍 1.1 gitlab-ci &amp;&amp; 自动化部署工具的运行机制 以gitlab-ci为例：
(1) 通过在项目根目录下配置.gitlab-ci.yml文件，可以控制ci流程的不同阶段，例如install/检查/编译/部署服务器。gitlab平台会扫描.gitlab-ci.yml文件，并据此处理ci流程
(2) ci流程在每次团队成员push/merge后之后触发。每当你push/merge一次，gitlab-ci都会检查项目下有没有.gitlab-ci.yml文件，如果有，它会执行你在里面编写的脚本，并完整地走一遍从intall =&gt; eslint检查=&gt;编译 =&gt;部署服务器的流程
(3)gitlab-ci提供了指定ci运行平台的机制，它提供了一个叫gitlab-runner的软件，只要在对应的平台(机器或docker)上下载并运行这个命令行软件，并输入从gitlab交互界面获取的token,就可以把当前机器和对应的gitlab-ci流程绑定，也即：每次跑ci都在这个平台上进行。
(4).gitlab-ci的所有流程都是可视化的，每个流程节点的状态可以在gitlab的交互界面上看到，包括执行成功或失败。如下图所示,因为它的执行看上去就和多节管道一样，所以我们通常用“pipeLine”来称呼它
(5).不同push/merge所触发的CI流程不会互相影响，也就是说，你的一次push引发的CI流程并不会因为接下来另一位同事的push而阻断，它们是互不影响的。这一个特点方便让测试同学根据不同版本进行测试。
(6)pipeline不仅能被动触发，也是可以手动触发的。
1.2 自动化部署给我们带来的好处 自动化部署的好处体现在几个方面
Before
如果按照传统的流程，在项目上线前的测试阶段，前端同学修复bug之后，要手动把代码部署之后。才能通知测试同学在测试环境进行测试。
这会造成几个问题：本身手动部署服务的工作是比较繁琐的，占用了开发时间。同时开发-测试之间的环节的耦合问题，则会增加团队沟通成本。
After
通过gitlab-ci，前端开发在提交代码之后就不用管了，ci流程会自动部署到测试或集成环境的服务器。很大程度上节约了开发的时间。
同时，因为开发和测试人员可以共用gitlab里的pipeline界面, 测试同学能够随时把握代码部署的情况，同时还可以通过交互界面手动启动pipeline，自己去部署测试，从而节约和开发之间的沟通时间。
2.从更细的粒度把握代码质量 我们可以把eslint或其他的代码检查加到pipeline流程中，每当团队成员提交和合并一次，pipeline都会触发一次并对代码做一次全面检测，这样就从一个更细的粒度上控制代码质量了。
二.知识预备 介绍完gitlab-ci的基本概念，接下来我将会介绍编写一个gitlab-ci用例所需要的知识。这是在实战之前的一点准备工作，主要包括三部分
2.1 gitlab-ci涉及的抽象概念(Runner/PipeLine/Executor/Job ) 首先要了解的是gitlab-ci中涉及的一些基本概念
1.Pipeline &amp; Job
Pipeline是Gitlab根据项目的.gitlab-ci.yml文件执行的流程，它由许多个任务节点组成, 而这些Pipeline上的每一个任务节点，都是一个独立的Job
Job在YML中的配置我们将会在下面介绍，现在需要知道的是：每个Job都会配置一个stage属性，来表示这个Job所处的阶段。
一个Pipleline有若干个stage,每个stage上有至少一个Job，如下图所示：
2.Runner
Runner可以理解为：在特定机器上根据项目的.gitlab-ci.yml文件，对项目执行pipeline的程序。Runner可以分为两种： Specific Runner 和 Shared Runner
Shared Runner是Gitlab平台提供的免费使用的runner程序，它由Google云平台提供支持，每个开发团队有十几个。对于公共开源项目是免费使用的，如果是私人项目则有每月2000分钟的CI时间上限。Specific Runner是我们自定义的，在自己选择的机器上运行的runner程序，gitlab给我们提供了一个叫gitlab-runner的命令行软件，只要在对应机器上下载安装这个软件，并且运行gitlab-runner register命令，然后输入从gitlab-ci交互界面获取的token进行注册, 就可以在自己的机器上远程运行pipeline程序了. Shared Runner 和 Specific Runner的区别Shared Runner是所有项目都可以使用的，而Specific Runner只能针对特定项目运行Shared Runner默认基于docker运行，没有提前装配的执行pipeline的环境，例如node等。而Specific Runner你可以自由选择平台，可以是各种类型的机器，如Linux/Windows等，并在上面装配必需的运行环境，当然也可以选择Docker/K8s等私人项目使用Shared Runner受运行时间的限制，而Specific Runner的使用则是完全自由的。 3.Executor
什么是Executor？ 我们上面说过 Specific Runner是在我们自己选择的平台上执行的，这个平台就是我们现在说到的“Executor”，我们在特定机器上通过gitlab-runner这个命令行软件注册runner的时候，命令行就会提示我们输入相应的平台类型。可供选择的平台一共有如下几种，下面是一张它们各方面特点的比较表格
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8affb03cb7a5a7ddab0585c19d9e8b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee4ec9e3f3b66ddf02276d1d603fa20f/" rel="bookmark">
			激活函数整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sigmoid函数 import torch from d2l import torch as d2l %matplotlib inline ​ x=torch.arange(-10,10,0.1,requires_grad=True) sigmoid=torch.nn.Sigmoid() y=sigmoid(x) ​ d2l.plot(x.detach(),y.detach(),'x','sigmoid(x)',figsize=(5,2.5)) sigmoid函数连续、光滑、单调递增，以 (0,0.5) 中心对称，是一个良好的阈值函数。在x超出[-6,6]的范围后，函数值基本上没有变化，值非常接近，在应用中一般不考虑。
sigmoid函数的值域范围限制在(0,1)之间，恰巧与概率值的范围相对应，这样Sigmoid函数就能与一个概率分布联系起来了。
存在等式：
当输入值为0时，sigmoid函数的导数达到最大值0.25；而输入在任一方向上越远离0点时，导数越接近0。
#清除以前的梯度 #retain_graph如果设置为False，计算图中的中间变量在计算完后就会被释放。 y.backward(torch.ones_like(x),retain_graph=True) d2l.plot(x.detach(),x.grad,'x','grad of sigmoid') sigmoid函数可用作逻辑回归模型的分类器。除此之外还存在其自身的推到特性。
对于分类问题，尤其是二分类问题，都假定服从伯努利分布，
根据指数分布族的一半表现形式
伯努利分布可变形为：
故，伯努利分布也属于指数分布族，
令，可得
此为sigmoid函数形式。
tanh函数 与sigmoid类似，tanh函数也会将输入压缩至（-1,1）。
import torch from d2l import torch as d2l %matplotlib inline ​ x=torch.arange(-8.0,8.0,0.1,requires_grad=True) tanh=torch.nn.Tanh() y=tanh(x) ​ d2l.plot(x.detach(),y.detach(),'x','tanh(x)',figsize=(5,2.5)) 存在等式：
tanh函数的导数如下，当输入接近0时，tanh函数的导数接近最大值1，输入在任一方向上远离0点，导数越接近0。
y.backward(torch.ones_like(x),retain_graph=True) d2l.plot(x.detach(),x.grad,'x','grad of tanh',figsize=(5,2.5)) ReLU函数 ReLU函数的求导表现很好：要么让参数消失，要么让参数通过。
ReLU减轻了神经网络的梯度消失问题。ReLU函数有很多变体，如LeakyReLU，pReLU等。
#原函数 import torch from d2l import torch as d2l %matplotlib inline ​ x=torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee4ec9e3f3b66ddf02276d1d603fa20f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e418aee4be52874d9d08aef5e2d5883/" rel="bookmark">
			GE IC695CPU315集成IO步进电机控制器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GE IC695CPU315集成IO步进电机控制器是一款由通用电气（GE）公司生产的工业自动化控制器。该控制器集成了输入输出（IO）功能，可以控制步进电机，广泛应用于各种需要精确控制和定位的工业自动化应用中。
该控制器的特点包括：
集成IO功能：能够接收和发送各种输入输出信号，实现与各种传感器和执行器的通信和控制。步进电机控制：能够精确控制步进电机的速度和位置，实现高精度的定位和运动控制。可靠性高：采用高品质的电子元件和严格的品质控制，确保在恶劣的工作环境下稳定运行。易于使用：具有友好的人机界面和简洁的配置选项，方便用户进行操作和调试。灵活性高：支持多种不同的控制需求，可根据实际需求进行定制和优化。模块化设计：易于进行扩展和升级，可根据实际需求进行定制和优化。 总之，GE IC695CPU315集成IO步进电机控制器是一款高效、可靠、易于使用的工业自动化控制器，能够广泛应用于各种需要精确控制和定位的自动化系统中。
The GE IC695CPU315 Integrated IO Stepper Motor Controller is an industrial automation controller produced by General Electric (GE). This controller integrates input output (IO) functions and can control stepper motors, widely used in various industrial automation applications that require precise control and positioning.
The characteristics of this controller include:
Integrated IO function: capable of receiving and sending various input and output signals, enabling communication and control with various sensors and actuators.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e418aee4be52874d9d08aef5e2d5883/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3070910593df6e7f251f7b67c3c96ed9/" rel="bookmark">
			禁用code server docker容器中的工作区信任提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VSCode 添加受限模式，主要是防止自动运行代码的，比如在vscode配置的task和launch参数是可以运行自定义代码的。如果用VScode打开未知的工程文件就有可能直接运行恶意代码。
但是当我们的实验基础模板文件可控的情况下，要想禁用code server docker容器中的工作区信任提示，怎么办？办法来了，
往这个文件路径/root/.local/share/code-server/User/settings.json
写入以下内容
{ "security.workspace.trust.enabled": false } 可以使启动的时候不弹出那个信任工作区的提示。
不要通过挂载配置字典实现，要让用户可操作。后续用户修改配置也会写入这个文件
测试语句
echo "{ \"security.workspace.trust.enabled\": false }" &gt; /root/.local/share/code-server/User/settings.json 在界面上禁用的方式如下，点击进入设置页面
搜索关键词security，然后取消工作区信任的启用状态即可。这里的更改实际也会被写入上面所说的用户配置文件/root/.local/share/code-server/User/settings.json中，所以说写入这个文件的权限不能给用户设置为只读
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d39d53de168da1e4779d0b37b4f3b89/" rel="bookmark">
			ABB REF615K 继电器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ABB REF615K继电器是一种综合保护继电器，主要用于电力系统和工业配电网的保护、控制、测量和监视。它是一种专用的馈线保护和测控装置，专门用于保护、控制、测量和监视公共和工业配电系统。
该继电器具有以下特点：
高性能：采用高性能的电子元件和先进的控制算法，具有高精度、快速响应和低能耗等特点。可靠性：具有可靠的机械结构和稳定的运行性能，能够在恶劣的工作环境下稳定运行。易于使用：具有友好的人机界面和简洁的配置选项，方便用户进行操作和调试。灵活性：支持多种不同的保护和控制需求，可根据实际需求进行定制和优化。模块化设计：易于进行扩展和升级，可根据实际需求进行定制和优化。 总之，ABB REF615K继电器是一种高效、可靠、易于使用的综合保护继电器，广泛应用于各种电力系统和工业配电网中。
ABB REF615K relay is a comprehensive protection relay mainly used for protection, control, measurement, and monitoring of power systems and industrial distribution networks. It is a specialized feeder protection and measurement device specifically designed for protecting, controlling, measuring, and monitoring public and industrial distribution systems.
This relay has the following characteristics:
High performance: Adopting high-performance electronic components and advanced control algorithms, it has the characteristics of high precision, fast response, and low energy consumption.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d39d53de168da1e4779d0b37b4f3b89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf47db2ceca9f5d731c9559ffc0acd1f/" rel="bookmark">
			Python专家编程系列: 8. 高级数据结构介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 标题 Python专家编程系列: 8. 高级数据结构介绍
id:4
作者: quantgalaxy@outlook.com blog: https://blog.csdn.net/quant_galaxy 欢迎交流 1. 介绍 Python中，除了大家常用的数据结构外，还有几个非常好用的数据结构，这里主要介绍下Heap（堆），Deque（双端队列），Array（数组）。
2. 高级数据结构介绍 2.1 Heap（堆） 堆是一种基于树的数据结构，用于实现称为优先队列的抽象数据类型。
二叉树通常用于实现堆，堆主要有两种类型:
最小堆
根结点的键值是所有堆结点键值中最小者的堆。最大堆
根结点的键值是所有堆结点键值中最大者的堆。 python提供了heapq模块，用于使用堆结构。
2.1.1 创建一个堆 import heapq lst = [1,5,3,6,2] heapq.heapify(lst) print(lst) #[1, 2, 3, 6, 5] 2.1.2 给最小堆中添加一个元素 heapq.heappush(lst, 10) heapq.heappush(lst, 20) print(lst) #[1, 2, 3, 6, 5, 10, 20] 2.1.3 从最小堆中移除最小元素 heapq.heappop(lst) #1 print(lst) # [2, 5, 3, 6, 20, 10] 2.1.4 查询堆中的最小的n个元素 heapq.nsmallest(3, lst) # [2, 3, 5] 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf47db2ceca9f5d731c9559ffc0acd1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f32ffcee3dac87b416c8cf4451974ed/" rel="bookmark">
			FC-PSUUNI2450U Honeywell 电源模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Honeywell FC-PSU-UNI2450U电源模块是一种专为工业自动化控制系统和设备设计的电源模块。它通常用于为各种传感器、执行器、控制器等设备提供稳定的电源，以保证系统的可靠性和稳定性。
该电源模块的特点包括：
高效稳定：采用先进的电源技术和优质的电子元件，能够提供稳定、高效的电源输出。宽范围输入：支持多种不同的输入电压和频率，能够适应不同的电源环境。可靠性高：具有过流、过压、欠压等保护功能，能够保证电源系统的稳定运行。易于安装和维护：采用标准化的接口和连接方式，方便用户进行安装和维护。可扩展性强：可根据实际需求进行定制和扩展，支持多种不同的电源需求。长寿命：采用优质的电子元件和材料，具有较长的使用寿命。 总之，Honeywell FC-PSU-UNI2450U电源模块是一种高效、稳定、可靠、易于安装和维护的电源模块，广泛应用于各种工业自动化控制系统中。
Honeywell FC-PSU-UNI2450U power module is a power module designed specifically for industrial automation control systems and equipment. It is usually used to provide stable power supply for various sensors, actuators, controllers and other equipment to ensure the reliability and stability of the system.
The characteristics of this power module include:
Efficient and Stable: Adopting advanced power technology and high-quality electronic components, it can provide stable and efficient power output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f32ffcee3dac87b416c8cf4451974ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e746e43f9aa4a142c4dd1c7f2b81d17/" rel="bookmark">
			设备管理系统建设方案书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.设备管理系统 1.1.系统概述 需求描述 建立设备信息库，对设备相关档案的登录、整理。通过建立完善的设备档案，将设备的各类原始信息进行信息化统一管理，使设备档案查询工作方便快捷，维修管理，针对维修计划、维修工单等管理。设备的维修情况随时查阅。并为设备全生命周期的管理提供基础数据。
1.1.2.需求分析 设备运营管理是对设备的购、管、用、养、修等全过程进行有效控制，以保持设备的生产能力，满足生产需要和环境、职业安全健康管理的要求。设备管理系统以设备及备品配件为基本管理对象，涵盖设备设计、选型、安装、维护、维修、分析和报废等全生命周期各个环节，提供设备故障维修、预防维修以及状态维修等各种维护模式，坚持设备维护任务的计划、提交、审批、执行和分析等业务主线，全面集成设备采购、库存、维护、成本核算等信息，提升企业设备管理信息化建设水平。
设备因所在地点不同可分为库存设备和已安装设备，库存设备保存在库房，已安装设备运行在安装地点。已安装设备具有唯一编码，可和GIS，BIM等系统做唯一编码关联，参与设备运行，保养，维修，巡检，改进，报废等业务场景。
设备管理系统以用户工业生产过程中所采购和使用的设备管控为核心，涉及设备从采购、入库、出库、领用、归还、安装、运行、保养、巡检、维修、改进、调拨、报废的全生命周期的信息化管理，并形成使用过程各阶段的台账及统计信息。设备管理系统与图档管理系统结合，拥有对设备资料、维保资料、规章制度、设备知识等资料的存取查看功能。
1.1.3.重难点分析 以确定的安全要求（国家法规、公司规则、设备设施特点）和合理的成本保障设备处于良好状态——对设备设施进行系统的研究和管理，并采取相应的措施，使其达到效率最高，性能最好，成本最低，故障最少，安全可靠。
1.1.4.重难点解决措施 1.实时响应
对软件系统的各类人机交互操作、信息查询、图形操作等能实时响应；
信息查询、操作、输入界面用图形、文字和数据三种方式在计算机上展现，数据表格具有报表打印功能，系统的操作简单易用。
2.系统实用性、经济性
实用性是系统的生命，软件系统是企业现代化、信息化、规范化管理的一种体现。它的实用性是其获得认可的基础。在设计系统时采用各种技术方法和措施来保证系统的实用性。它体现在系统规划的合理性、系统的可靠性、功能的完善性、使用的方便性、人机界面的友好简洁、操作简单方便、信息展示形象直观，使系统具有很强的实用性。系统既能相关部门日常事务，又能处理突发性事件等紧急事务。
系统符合业务的特点和要求全方位深层次地满足用户的要求，集输入、维护、查询、筛选、统计和各种处理为一体，信息导入导出方便共享，灵活、专业的报表设计，形象、增强的数据处理，完美的信息图形分析，充分考虑了偶然的网络拥塞、过载等现象。
3.系统高效性、易用性
系统功能层次分明，有良好的交互性，符合用户习惯，提供提示、警告、运行状态显示以及帮助等人性化功能。系统设计时，充分考虑性能的优化策略，系统能根据实际运行环境进行性能优化处理、能自动选择合理的优化算法，考虑极限条件下的并行情况，响应速度快捷，具体有良好的响应性能，使系统运行效率最高，满足用户的要求。
科学的流程和结构设计保证了系统高效性流程设计上以及系统体系的设计上充分保证了系统运行的高效性。这种高效性包括人员的高效性和设备的高效性两个方面：
l人员的高效性：由于系统的业务流程的设计上采用了高度分工协作的流水线模式，系统中的各个角色各司其职。从而使得系统处于最高效运行的状态，另外这种精确分工的流程设计原则，也降低了人员的培训成本和培训时间。
l设备的高效性：由于系统采用分布式计算环境，在这个环境中彼此协作，可用通过有效的设备配置比例（有冗余），来使得系统中的所有设备都处于高效运行状态，从而最大限度地保护了系统的投资。避免计算资源的浪费。
4.数据统一管理
采用数据集中管理，统一标准体系。
1.2.系统架构设计 1.2.1.系统架构图 设备管理系统分为六层，包括：访问层，表现层，业务层，服务层，系统层和数据中心。
1、访问层
提供用户访问系统的接口和方式，B/S构架的设备管理系统可以通过HTTP协议进行访问；C/S构架的设备管理系统由服务器承载相应的各种服务，不同的客户通过服务器使用、共享服务，以及用户的信息交互。
2、 表现层
即设备管理系统的用户界面层，提供和用户交互，将用户的行为输入转化为系统操作，进入后台逻辑。即当设备管理系统的用户在进行设备管理工作时，系统会进行一定的数据采集，分析并存储，实现基础数据的采集。
3、 业务层
即设备管理系统的业务管理功能层，也是系统的业务逻辑层和主体应用层，定义了包括具体的系统操作逻辑、操作流程等。主要包括设备档案管理、设备采购管理、设备计划管理、设备发放调拨管理、设备运行管理、设备使用运行监控管理、设备清理维护、设备维修管理、报废等功能。系统业务层的职责就在于按照实际需求和流程，实现一系列的完整的设备管理。
4、 服务层
主要负责定义和执行系统的业务流程和服务管理标准，实现对权限、搜索、分析、业务流转等功能深度挖掘。
5、 系统层
基于J2EE技术设计设备管理软件运行的服务环境。
6、 数据中心
对各种设备数据按照类型、环节、先后进行封装，通过各种封装技术和标准的数据传输接口，方便地实现对各种数据来源的插入、删除、修改、查找等操作。
1.2.2.关键技术 设备编码规则：
正确的设备分类编码是实现设备统一管理的重要手段，设备编码要遵循可拓性、稳定性、可操作性，以及唯一性等原则。目前的设备编码种类很多，该设备管理系统在依据实际情况的基础上采用数据库通用的混合编码形式，具体为：单元码-类别码-组别码-主参数码-序列号码，各码间用连字符隔开。单元码是指设备所在的具体位置，用小写汉语拼音字头表示，长度一般为4个字母，例如设备在“生成车间”则用“sccj”表示；类别码主要是指设备、量具、配件、模具等，用小写汉语拼音字头表示，长度一般为2～4个字母；组别码是指设备的种类，长度小于5个字母，用设备种类的小写拼音字头表示；主参数码表示设备最主要的加工参数，一般用字母加数字表示。
维修等业务的工作流流程管理：
工作流技术是对企业中具有结构化程序的领域进行管理的技术，其实质是调查业务流程，发现其中的瓶颈，对其进行改进、优化，从而提高企业信息化、集成化水平。一个工作流中包含有一组活动、活动的关系，以及每个活动的内容描述，如执行者，以及过程的启动、终止条件等。
工作流管理技术是指通过计算机代替企业落后的书面记录形式，将各个业务流程通过电子信息管理的方式建立起模型，将有关的信息如零/部件信息、维护信息等传递到相应的用户对象手中。同样接受者也是通过工作流管理技术接收各种信息，如果其中某个步骤完成，工作流会根据有关模型继续传递给下一个用户。在此过程中，工作流系统与执行者共同监控工作流的运行状况，并交互进行，保证将数据准确地传递给相应的对象。
设备维修过程主要包括设备维护、保养、维修计划和保养计划等工作。传统的维护方式都是依据设备维护人员的主观经验，有极大的人为因素，任务的执行一般是以管理阶层的命令方式为主，费事、费力，使维护工作失误、遗漏很多。该系统在研究传统模式的前提下，将设备维护内容进行了动态管理，依据工作流技术提出了设备动态管理模式。
维护任务管理模块主要是查看系统中的设备故障、保养等任务，选取其中的任务派发给相应的维护人员，并动态查看任务的完成状态。
维护任务执行模块主要是获取需要维护的任务信息，同时核对维护资源及维护方案是否有相同的维护案例存在，若有，按此案例实现维护；若没有，设置新的维护方案实现维护，同时动态跟踪维护任务的进展情况，并通过维护任务表单将任务的完成信息传递给任务管理模块。
库存控制策略：
配件作为设备维修的基础，具有类型多、无规律性、数量大和占用资金大等特点，实现对设备配件的动态管理可以提高设备的利用率及产品的生产效率。当低于预设库存时启动配件预警提示，提交采购申请，由采购部门发出采购订单，循环进行，实现周期性动态管理。
根据实际情况，在该设备管理系统中采用了设定最高库存量及最低库存量的上、下限库存动态控制的方法，将当前的实际库存量与预设的配件预订货量即库存最低点相比较。
1.3.系统功能设计 1.3.1.功能清单列表 表1.3.1-1 功能表
序号
功能点
描述
1
采购管理
供应商管理
采购基础信息维护
采购计划
采购计划是根据生产部门或其他使用部门的计划制定的包括采购物料、采购数量、需求日期等内容的计划
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e746e43f9aa4a142c4dd1c7f2b81d17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3af2e585b776329dba93616ad6ed2685/" rel="bookmark">
			uniapp中实现H5录音和上传、实时语音识别（兼容App小程序）和波形可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Recorder-UniCore插件特性集成到项目中调用录音上传录音ASR语音识别 在uniapp中使用Recorder-UniCore插件可以实现跨平台录音功能，uniapp自带的recorderManager接口不支持H5、录音格式和实时回调onFrameRecorded兼容性不好，用Recorder插件可避免这些问题。
DCloud插件市场下载插件（有demo项目源码）：https://ext.dcloud.net.cn/plugin?name=Recorder-UniCore
Recorder-UniCore插件特性 支持vue2、vue3、nvue支持编译成：H5、Android App、iOS App、微信小程序支持已有的大部分录音格式：mp3、wav、pcm、amr、ogg、g711a、g711u等支持实时处理，包括变速变调、实时上传、ASR语音转文字支持可视化波形显示 集成到项目中 1、通过npm安装recorder-core
//在uniapp项目跟目录进行npm安装 npm install recorder-core 2、下载导入Recorder-UniCore插件
// 到插件市场 https://ext.dcloud.net.cn/plugin?name=Recorder-UniCore 下载插件 然后添加到你的项目中 /uni_modules/Recorder-UniCore 3、在vue页面文件内引入js
&lt;script&gt; /**这里是逻辑层**/ //必须引入的Recorder核心（文件路径是 /src/recorder-core.js 下同） import Recorder from 'recorder-core' //使用import、require都行 //必须引入的RecordApp核心文件（文件路径是 /src/app-support/app.js） import RecordApp from 'recorder-core/src/app-support/app' //所有平台必须引入的uni-app支持文件（如果编译出现路径错误，请把@换成 ../../ 这种） import '@/uni_modules/Recorder-UniCore/app-uni-support.js' /** 需要编译成微信小程序时，引入微信小程序支持文件 **/ // #ifdef MP-WEIXIN import 'recorder-core/src/app-support/app-miniProgram-wx-support.js' // #endif /** H5、小程序环境中：引入需要的格式编码器、可视化插件，App环境中在renderjs中引入 **/ // #ifdef H5 || MP-WEIXIN //按需引入你需要的录音格式支持文件，如果需要多个格式支持，把这些格式的编码引擎js文件统统引入进来即可 import 'recorder-core/src/engine/mp3' import 'recorder-core/src/engine/mp3-engine' //如果此格式有额外的编码引擎（*-engine.js）的话，必须要加上 //可选的插件支持项 import 'recorder-core/src/extensions/waveview' // #endif &lt;/script&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3af2e585b776329dba93616ad6ed2685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e16ae2168e6aca8de6668f7a6dd71eef/" rel="bookmark">
			谭浩强C语言程序设计习题-选择结构程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[编程入门]三个数找最大值 #include&lt;stdio.h&gt; int main() { int a,b,c,d; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(a&gt;b) d=a; else d=b; if(c&gt;d) d=c; printf("%d",d); return 0; } [编程入门]分段函数求值 #include"stdio.h" int main(){ int x,y; scanf("%d",&amp;x); if(x&lt;1){ y=x; } else if(1&lt;=x&amp;&amp;x&lt;10){ y=2*x-1; } else{ y=3*x-11; } printf("%d",y); return 0; } [编程入门]成绩评定 #include&lt;stdio.h&gt; int main(){ int a; scanf("%d",&amp;a); switch(a/10){ case 10: case 9: putchar('A'); break; case 8: putchar('B'); break; case 7: putchar('C'); break; case 6: putchar('D'); break; default: putchar('E'); } } [编程入门]数字的处理与判断 #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e16ae2168e6aca8de6668f7a6dd71eef/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/8/">«</a>
	<span class="pagination__item pagination__item--current">9/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/10/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>