<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c5496308dfa464d8ab06304d36356ba/" rel="bookmark">
			【tensorflow】保存模型、再次加载模型等操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于经常要使用tensorflow进行网络训练，但是在用的时候每次都要把模型重新跑一遍，这样就比较麻烦；另外由于某些原因程序意外中断，也会导致训练结果拿不到，而保存中间训练过程的模型可以以便下次训练时继续使用。
所以练习了tensorflow的save model和load model。
参考于http://cv-tricks.com/tensorflow-tutorial/save-restore-tensorflow-models-quick-complete-tutorial/，这篇教程简单易懂！！
1、保存模型 # 首先定义saver类 saver = tf.train.Saver(max_to_keep=4) # 定义会话 with tf.Session() as sess: sess.run(tf.global_variables_initializer()) print "------------------------------------------------------" for epoch in range(300): if epoch % 10 == 0: print "------------------------------------------------------" # 保存模型 saver.save(sess, "model/my-model", global_step=epoch) print "save the model" # 训练 sess.run(train_step) print "------------------------------------------------------" 注意点：
创建saver时，可以指定需要存储的tensor，如果没有指定，则全部保存。
创建saver时，可以指定保存的模型个数，利用max_to_keep=4，则最终会保存4个模型（下图中我保存了160、170、180、190step共4个模型）。
saver.save()函数里面可以设定global_step，说明是哪一步保存的模型。
程序结束后，会生成四个文件：存储网络结构.meta、存储训练好的参数.data和.index、记录最新的模型checkpoint。
如：
2、加载模型 def load_model(): with tf.Session() as sess: saver = tf.train.import_meta_graph('model/my-model-290.meta') saver.restore(sess, tf.train.latest_checkpoint("model/")) 注意点：
首先import_meta_graph，这里填的名字meta文件的名字。然后restore时，是检查checkpoint，所以只填到checkpoint所在的路径下即可，不需要填checkpoint，不然会报错“ValueError: Can’t load save_path when it is None.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c5496308dfa464d8ab06304d36356ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77199aa21c673e8ccccf751d67ccce43/" rel="bookmark">
			实现滚动条丝滑滚动，流畅不卡顿，有回弹效果。-webkit-overflow-scrolling
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.我们经常会实现横划的滚动列表，如下图。但是手指离开屏幕 滑动停止，而且明显有点卡顿感，那么怎么解决这个问题～
解决方式：给父类加-webkit-overflow-scrolling;touch 属性
解析：-webkit-overflow-scrolling;touch 属性控制元素在移动设备上是否使用滚动回弹效果.、
-webkit-overflow-scrolling;touch 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效 果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。
其他：-webkit-overflow-scrolling;auto 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。
属性源码解析：https://developer.mozilla.org/zh-CN/docs/Web/CSS/-webkit-overflow-scrolling
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f90648bc0fc3fd7024ea37be26356db3/" rel="bookmark">
			matlab  向量的基本运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要参考：王沫然编著的MATLAB与科学计算（第2版）
博客文章：点击打开链接
1、向量生成 1.1、直接输入 1.2、 x=x0:step:xn 1.3、线性等分向量—linespace 1.4、对数等分向量—logspace 2、向量运算 21、加（减）与数加（减） 22、数乘 23、点积 参考 ：点击打开链接
别名 ：数量积、内积，可用于计算向量的模
定义 ： 两个向量a = [a1, a2,…, an]和b = [b1, b2,…, bn]的点积定义为： a·b=a1b1+a2b2+……+anbn 几何意义： a·b——向量a在向量b方向上的投影长度 函数 ：dot(a,b) eg: a=[1,2,3]; &gt;&gt; b=[3,4,5]; &gt;&gt; dot(a,b)%**************************(1) ans = 26.00 &gt;&gt; sum(a.*b)%*************************(2) ans = 26.00 &gt;&gt; a*b'%******************************(3) ans = 26.00 2.4、叉积 参考 ： 点击打开链接 函数 ：cross eg: &gt;&gt; a=[1,2,3]; &gt;&gt; b=[4,5,6]; &gt;&gt; c=cross(a,b) c = -3.00 6.00 -3.00 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f90648bc0fc3fd7024ea37be26356db3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78489afcbccbf119cacec3552f244dec/" rel="bookmark">
			Spring 当返回对象转JSON时不希望空值属性存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们可以在作为返回值的类上加一个注解：
@JsonInclude(value=Include.NON_NULL)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc52630e554ec6d078c22673210ec09/" rel="bookmark">
			RCNN系列之Faster RCNN详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RCNN系列：RCNN，SPPNet，Fast RCNN，Faster RCNN，R-FCN。这一系列是个递进关系，也是目标检测使用two-stage方法的一个发展过程。想要更好的理解Faster RCNN和R-FCN，只能把这些算法都梳理清楚了，才能明白算法的整个优化过程。 本篇讲解的是Faster RCNN。2016年，发表在CVPR。 理解了SPPNet之后，我们知道了RCNN已经进化到了SPPNet阶段，那么，Fast RCNN又更进一步提高了速度。那么耗时最多的几乎都来自selective search了。 为了解决这个问题，Faster RCNN终于来了。 多说几句，起初我看论文的时候是从Faster RCNN开始看的，但是怎么都看不太明白，为什么要这样？为什么要那样？都不太清楚，将RCNN的一系列梳理了一遍之后， 才有些恍然大悟的一点感觉。 但是，基础还是不够扎实，有些理解还是会出现问题，之后随着理解的加深，慢慢再更新。 希望看到博客的读者，也能这样从头开始学RCNN，并不会浪费时间，反而会理解的更加深刻。 再看Fast RCNN过程： 使用selective search算法为每一张待检测的图片提取出2000左右的候选框，这一点和RCNN相同；特征提取阶段，同样是提取出整张图片的feature map，然后将原图上的候选框映射到feature map上。然后对各个候选框对应的feature map上的块做ROI pooling，提取出固定长度的特征向量；对于上一步的每一个ROI，网络输出每个类的概率和每个bounding box；最后，使用NMS算法。 经过两次迭代优化，原始RCNN算法训练过程的三步走，现在只有两步，但是最终还是要使用selective search来做region proposal（候选框的生成）。 那么能不能使用CNN来做候选框的生成呐？ 答案是可以！ 由此，RPN（Region Proposal Network）被设计出来了。中文名就是区域生成网络。 Faster RCNN 可以看作是RPN 和 Fast RCNN的结合。 意味着我们把RPN理解透彻就能够很好的理解Faster RCNN了。 题外话: 这一段算是我的个人总结吧，在起初学习RPN的时候，很不明白，为什么RPN就能提取物体的候选框了，为什么要使用Anchor？ 这些问题即使看了别人讲解RPN的博客也是一头雾水，根本不明白。 要理解这些问题，我们要学会用CNN做两件事情。 第一件：分类，这个问题是只要接触了CNN，我们就能基本知道怎么做，LeNet就是一个10分类，到了后来的AlexNet，VGG是1000分类。 如果这块还是不明白的话，只能好好推推CNN了。 第二件：回归，使用CNN做回归，我是开始没有搞明白。也就是怎么才能用CNN提取出来物体的bounding box呐？ bounding box 不就是学到目标的（x，y，h，w）四个参数吗？其中（x，y）是目标的在图片上面的中心坐标或者是左上角的坐标，h和w是目标框的长宽。 由于这四个参数都是连续的，所以是个回归问题。 为了弄明白这个道理，我们从最简单的开始，比如一张图中只有一个目标，且这一个目标只有三个种类比如是猫，狗，鼠。 我们只需要利用CNN计算出这一个目标的 四个坐标参数和 类别即可。 那么我们利用CNN需要得到什么信息呐？ 首先需要一个参数p来确定这张图片是否含有目标，p=1代表有目标，p=0代表不含有目标。 如果图中存在目标，那么我们还要指定这个目标是三类中哪一个？ 这时用SoftMax的方法一般是给出三个种类的概率即用c，d，m分别代表猫狗鼠在图中出现的概率。 然后存在目标后，我们还要标出目标的位置，也是上文所说的 （x，y，h，w）。 那么我们需要CNN最后输出的结果即是：（p，c，d，m，x，y，h，w ）维的向量即可。 更准确点就是让CNN的全连接层的最后输出是8维的向量，其中每一个输出单元代表了以上含义。 以上过程可以看作是CNN的前向传播过程，从输入一张图片，到输出这8维向量。 后向传播最主要的就是设计合理的loss函数，一般常用的loss函数可以按照以下： loss=SoftMax（p,c,d,m）+s*L2( （x，y，h，w）-GT) 以上，SoftMax就不用讲了，L2范数其实就是欧氏距离（两点距离），其中s是两者的权重。 这样有了loss函数，我们就可以使用后向传播来反复迭代了，直到收敛。 这样单目标的提取目标检测框的过程就完成了。 理解了CNN做这两件事的过程，我们再来理解RPN网络，就会变得轻松一些了。 在正式开始RPN之前，还是先熟悉一下RPN的基础网络VGG16： 上图中D网络就是VGG16，如果你不太理解上图的含义，请移步： http://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fc52630e554ec6d078c22673210ec09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5092c1a15e614adf7a304ea0caaeafac/" rel="bookmark">
			js购物车选中商品实现计算商品总价格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了在激烈的互联网竞争中获得一席之地，都努力使自己的网站更为人性化。比如在购物网站一般都有这样的功能，那就是在结算商品的时候，网站可以自动计算要购买商品所需要花费的金钱数量。
代码实例如下:
01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 &lt;!DOCTYPE html&gt; &lt; html &gt; &lt; head &gt; &lt; meta charset = " utf-8" &gt; &lt; title &gt;购物车选中商品实现计算商品总价格&lt;/ title &gt; &lt; script type = "text/javascript" &gt; function jisuan(obj){ var total=0; var fruits=document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5092c1a15e614adf7a304ea0caaeafac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f707815d437a4d72f8867d99f9835ed1/" rel="bookmark">
			JavaScript点击一个按钮隐藏和显示div
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章节通过代码实例介绍一下如何实现点击同一按钮实现一个元素的显示和隐藏效果。
此效果还是比较实用的，比如点击按钮可以实现一个功能模块的显示或者隐藏。
下面就通过代码实例介绍一下如何实现此功能。
代码实例如下:
01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 &lt;!DOCTYPE html&gt; &lt; html &gt; &lt; head &gt; &lt; meta charset = "utf-8" &gt; &lt; title &gt;点击一个按钮隐藏和显示div&lt;/ title &gt; &lt; style type = "text/css" &gt; #thediv{ width:200px; height:50px; background:#ccc; } &lt;/ style &gt; &lt; script type = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f707815d437a4d72f8867d99f9835ed1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b8635100f2350544358468982967913/" rel="bookmark">
			node 爬虫，使用 Google puppeteer 抓取 One一个 的网页数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		puppeteer 就不多介绍了，就是一个无界面化的谷歌浏览器。 作者本人是前端，后端方面的知识不太擅长，感觉漏洞还是蛮多的。 本教程是作者见猎心喜然后把玩了一下写的，有不合理的地方还请包涵。
爬虫思路 本例子是使用顺序爬取，没有用并行爬取，并设置了延时器，主要是担心访问频次太高会被屏蔽访问。
puppeteer 写爬虫感觉思路比别的更简单，按视觉化的流程去走就可以。
启动浏览器和打开一个新页面跳转到要抓取数据的页面获取页面上的信息和图片打印信息和保存图片重复 2 ~ 4 步，直到所有页面抓取结束关闭浏览器退出进程 爬虫代码 要抓取的页面：http://wufazhuce.com/one/35
对于要抓取的资源，没有弄复杂的逻辑，根据 URL 推断是按ID排列的。 那么只要对页面 ID 依次累加就行了成功就抓取，错误就跳过。
const puppeteer = require('puppeteer'); const fs = require('fs'); const request = require('request'); // 延时器 let timeout = function (delay) { console.log('延迟函数：', `延迟 ${delay} 毫秒`) return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { try { resolve(1) } catch (error) { reject(error) } }, delay); }) } /** * One 爬虫类 */ class OnePaChong { constructor () { // 最大索引 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b8635100f2350544358468982967913/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cf5a5856571c413e349ccc6db0d2f90/" rel="bookmark">
			哔哩哔哩（B站）的前端之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2017年即将过去了，总结一下B站的前端进阶之路。
过去的开发模式中，我们采用了以后端为主的 MVC 架构方式。具体来说，每次项目评审后，前后端会先一起约定好接口，之后分别进行开发，开发完，前端需要把页面提供给后端，后端配置上数据，然后返回出来。正式基于这样的开发模式，导致了总工作量的增加，同时沟通和联调成本的消耗也十分显著。
前后端分离
为了摆脱这种前后端过分依赖的情况，（其实前端也不想每次修改或者发布都要后端这边发布，后端也不想每次前端只改个标题，都要发布一下,影响服务的稳定性），那么先从前后端分离开始吧~
前后端分离，最基本的两种模式，有中间层和没有中间层。
第一种，没有web中间层就很简单，提供一个html模板放到静态资源机上面，html模板里面引用了所需的js和css，访问页面的时候 把这个静态模板返回给用户，然后执行js 在浏览器端通过ajax请求api拿到数据，渲染页面。
（前后端分离）
第二种，有node中间层，随着2009年，Node的横空出世，把前端慢慢的推向了后端，有了node之后，JavaScript可以做更多的事情。
B站，一开始做前后端分离的时候，也确实按照第一种方式去做的,现在还有一些页面仍然是这种模式,例如：https://www.bilibili.com/account/history (可查看网页源代码)。对于不需要seo的页面来说，是一个不错的方式。前端开发完成之后，通过webpack打包出对应的js和css 上传到cdn上面，然后将webpack打包出来的 引用了对应的资源的html文件 上传到一台专门的静态机上面，然后运维配置路由 将页面流量导过去就好了。后端的同学只需要提供对应的api接口就可以。前后端分开维护，自己按照自己的节奏走，降低了页面与服务的耦合度
这种方式确实是一种很快能够进行前后端分离的方法。我们花了一段时间，在pc端使用vue 进行重构，移动端H5端 用react进行了重构。 进度很快，但是也慢慢展现出了弊端。
首屏的时候，因为他要等待资源加载完成，然后再进行渲染，会导致了首屏有白屏，如果是单页面还好，如果是spa应用 那么 他的加载时间就会变得很长，白屏时间会很影响用户体验，再有就是由于国内的搜索公司 对于spa 应用没有很好的兼容，导致了客户端渲染会对seo非常的不友好，有seo 需求的页面就很迫切的需要服务端渲染。
（B站的首页，右边模块做了服务端渲染，左边模块没有做服务端渲染）
那么，依赖node 进行服务端渲染就被提上了日程。
选型
首先进行node 框架的选型，市面上主流框架有三种，hapi express koa ,还有一些是经过一些封装和定制的框架，例如：eggjs等。
一开始我就把eggjs 排除在外了，第一因为eggjs,的功能很强大，有很多功能，多到有些根本用不着，从而导致了他会重 不轻量级，第二，eggjs对于我来说是个黑盒，如果有什么问题，我解决起来将会花费很长的时间。（但是有很多地方 我还是借鉴了eggjs的，毕竟 很强大）
然后剩下的三种框架，express的使用相对简单，文档也比较多，比较全面，所以我就选择了express(后来还是重构掉了 = =!)
然后是前端框架的选型 因为前端框架主流的有很多，ng r v 等等，我站在用的是react和vue, 他们有个优势就是可以进行前后端同构，一样的逻辑不用写两份，很棒。
（同构逻辑大概如此吧）
由于之前前后端分离的时候，pc上面已经再用vue 进行了重构，所以自然，这次服务端渲染也建立在vue上面 用的是vue ssr (这也为我后面的一个想法埋下了伏笔)
首先 我们选择一个简单的页面来做打样，就用tag页吧（被神选中的孩子：https://www.bilibili.com/tag/3503159 ）
开发
目录结构
- client 【客户端代码 同构代码】
- build 【构建相关】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cf5a5856571c413e349ccc6db0d2f90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e420fda912de9e41c3333a184287311/" rel="bookmark">
			各种浏览器的userAgent收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		window.navigator.userAgent 1) Chrome Win7: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.163 Safari/535.1 2) Firefox Win7: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0) Gecko/20100101 Firefox/6.0 3) Safari Win7: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50 4) Opera Win7: Opera/9.80 (Windows NT 6.1; U; zh-cn) Presto/2.9.168 Version/11.50 5) IE Win7+ie9： Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e420fda912de9e41c3333a184287311/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cd501bfb27eac1ed58795a89063cf98/" rel="bookmark">
			Bash on Windows各种配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创文，最初发布于 szhshp的第三边境研究所 , 转载请注明
安装 PowerShell里面执行
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 重启电脑
配置 apt-get换源 原文件重命名备份 sudo mv /etc/apt/sources.list /etc/apt/source.list.bak 编辑源列表文件 sudo vim /etc/apt/sources.list 使用下面的内容
(注意这个只是给Ubuntu16.04版本使用, 你安装的时候应该默认就是这个版本)
deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse ##测试版源 deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse # 源码 deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb-src http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cd501bfb27eac1ed58795a89063cf98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2d820ecf04a5115cd46cb8b2b54b9a6/" rel="bookmark">
			使用51单片机驱动舵机程序分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		舵机，又称伺服马达，是一种具有闭环控制系统的机电结构。舵机主要是由外 壳、电路板、无核心马达、齿轮与位置检测器所构成。其工作原理是由控制器发出PWM（脉冲宽度调制）信号给舵机，经电路板上的IC处理后计算出转动方向， 再驱动无核心马达转动，透过减速齿轮将动力传至摆臂，同时由位置检测器（电位器）返回位置信号，判断是否已经到达设定位置，一般舵机只能旋转180度。舵机有3根线，棕色为地，红色为电源正，橙色为信号线，但不同牌子的舵机，线的颜色可能不同，需要注意。 舵机的转动位置是靠控制PWM（脉冲宽度调制）信号的占空比来实现的，标准PWM（脉冲宽度调制）信号的周期固定为20ms，占空比0.5～2.5ms 的正脉冲宽度和舵机的转角-90°～90°（即0~180度）相对应。注意，由于舵机牌子不同，其控制器解析出的脉冲宽度也不同，所以对于同一信号，不同牌子的舵机旋转的角度也不同。其原理是：它内部有一个基准电路，产生周期为20ms，宽度为1.5ms的基准信号， 控制信号由接收机的通道进入信号调制芯片，获得直流偏置电压。将获得的直流偏置电压与电位器的电压比较，获得电压差输出。最后，电压差的正负输出到电机驱动芯片决定电机的正反转。当电机转速一定时，通过级联减速齿轮带动电位器旋转，使得电压差为0，电机停止转动。
0.5ms------------0度；
1.0ms------------45度；
1.5ms------------90度；
2.0ms-----------135度；
2.5ms-----------180度；
采用11.0592MHZ的51单片机驱动舵机转动程序如下：
//上电自动转动 #include &lt;reg52.h&gt; unsigned char count; //0.5ms次数标识 sbit pwm =P1^0 ; //PWM信号输出 sbit jia =P2^4; //角度增加按键检测IO口 sbit jian =P2^5; //角度减少按键检测IO口 unsigned char jd; //角度标识 sbit pwm1 =P0^0 ; //PWM信号输出给示波器，检测PWM波用 void delay(unsigned char i)//延时 { unsigned char j,k; for(j=i;j&gt;0;j--) for(k=125;k&gt;0;k--); } void Time0_Init() //定时器0初始化 { //定时器0装初值 用示波器检测后，11.0592MHZ晶振 定时0.5ms进入中断 装初值如下 TH0 = (65536-445)/256; TL0 = (65536-445)%256; TMOD = 0x01; //定时器0工作在方式1 IE = 0x82;	//IE=0x82=1000 0010 等价于 EA=1 开总中断 ET0=1 开定时器0中断 TR0=1; //开定时器0 } void Time0_Int() interrupt 1 //中断程序 { //重装初值 TH0 = (65536-445)/256; TL0 = (65536-445)%256; if(count&lt; jd) { pwm=1; //确实小于，PWM输出高电平 pwm1=pwm; //接示波器用的io口，观测PWM波形用	}	//判断0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2d820ecf04a5115cd46cb8b2b54b9a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec487afced7acf9ffe9496dbd670772/" rel="bookmark">
			C#连接sqlServer数据库详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 是如何跟SQL Server进行连接的？ 在C#/.NET程序设计中，离不开ADO.NET。ADO.NET是.NET连接数据库的重要组件。使用其可以很方便地访问数据库，ADO.NET还可以访问Oracle数据库、Access数据库、SQL Server数据库等主流的数据库。使用ADO.NET连接数据库主要使用ADO.NET中的5个类。
数据库连接类Connection：如果连接SQLServer数据库，可以使用SqlConnetion类。在使用SqlConnection类是要引用一个System.Data.SqlClient的命名空间。
数据库命令类Command：如果连接的是SQLServer数据库，可以使用SqlCommand。数据库命令类主要执行对数据库的操作，比如插入、删除、修改等。
数据库读取类DataReader：如果连接SQLServer数据库，可以使用SqlDataReader。数据库读取类是数据库命令类在执行了查询操作后返回的结果的数据类型。数据库读取类只是数据库的连接状态处于打开状态时才能使用，当数据库关闭时数据库读取类中就不能够再取值了。
数据集类DataSet：数据集相当于一个虚拟数据库，每一个数据集中包括了多张数据表。即使数据库的连接处于断开状态，还是可以从数据集中继续存取记录，只是数据是存放在数据集中的，并没有存放在数据库中。
数据适配类DataAdapter：如果连接SQLServer数据库，可以使用SqlDataAdapter。数据适配器经常和数据集一起使用，通过数据适配器可以把数据库中的数据存放到数据集中，数据适配器可以说是数据集和数据库之间的一个桥梁。
连接数据库一般有两种方式： 1、使用SQL用户名、密码验证
Data Source = 服务器名；Initial Catalog = 数据库名；User ID = 用户名；Pwd = 密码（没有密码可以省略）
例如：public string connString = "Data Source=xp;Initial Catalog=ExpressManager;User ID = sa;Pwd = 123";
2、使用windows身份验证
Data Source = 服务器名；Initial Catalog = 数据库名；Integrated Security = TRUE(或者：SSPI)
例如：public string connString = "Data Source=xp;Initial Catalog=ExpressManager;Integrated Security=TRUE";
在身份验证可以选SQL 用户名、密码验证。
接下来就是在源文件里加入连接数据库的代码，首先得在xxx.cs源文件中加入以下语句
using System.Data; using System.Data.SqlClient;
接下来就是对数据库的操作类方法的实现：
[csharp] view plain copy print ? // 数据库操作类 class Express { public string connString = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ec487afced7acf9ffe9496dbd670772/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07282210afeda57867f96ae897af5fa9/" rel="bookmark">
			django2.x报错No module named &#39;django.core.urlresolvers&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法就是:
from django.urls import reverse
最近从django1.9迁移到django2.0中出现一个意外的报错：
这个报错的原因在stack overflow上有很直接的解释，但是百度上并没有直接的答案。
简单来说，原因就是：django2.0 把原来的 django.core.urlresolvers 包 更改为了 django.urls包，所以我们需要把导入的包都修改一下就可以了。
下面是stack overflow上的解释：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/987e7550b8b7cb02989cc707435270b7/" rel="bookmark">
			java中冒号(:)的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击：原文链接
今天看代码的时候看到了下面第一种冒号，没怎么看懂，于是上网找了下资料，转到博客做一个笔记吧。
你见到的冒号是在哪个地方的，java中不同的地方的冒号的作用是不同的，例如：
1、
String[] abc = new String[3]{"a","b","c"};
for （String str : abc）｛
System.out.println(str); //这个地方的冒号就是遍历abc的集合，取出每一个元素
｝
2、三元运算符boolean?true的内容:false的内容
int a=1;
int b=3;
int i = a&gt;b?3:1;//这个地方的冒号用来选择值，如果a大于b，那么i=3，否则i=1
3、跳转标记
outer:for(int i=0;i&lt;5;i++){
for(int i=0;i&lt;5;i++){
if(i==3){
continue outer;
}
}
}
//这个地方就是跳转标识,可用来标记地方 里层循环 continue直接跳出外层循环，继续执行外层循环
4.switch选择
switch(i){
case 1:oprate....；break；
case 2:oprate....；break；
case 3:oprate....；break；
//用于switch选择，当i等于下面的值事，执行后面的操作，然后break跳出，如果没有break，那么将执行下面的oprate操作，一直到底！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8ef1bb45fc011d591174dbeefe66361/" rel="bookmark">
			已确定学生人数，输入成绩求平均成绩（JAVA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、已确定学生人数，输入学生成绩，求平均成绩 代码为： import java.util.Scanner; public class clock { private static Scanner sc; public static void main(String[] args) { double grade=0; double averagegrade=0; sc = new Scanner(System.in); for(int i=0;i&lt;5;i++) {	grade=sc.nextDouble();	averagegrade=averagegrade+grade; } averagegrade=averagegrade/5; System.out.println("平均成绩 ："+averagegrade); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/786bac3e021410c0912012098fd64009/" rel="bookmark">
			我的keytool
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[root@localhost bin]# keytool -genkey -alias zljh -keypass talent -keyalg RSA -keysize 1024 -validity 3650 -keystore /home/certificates/zljh.keystore -storepass talent What is your first and last name? [Unknown]: tong liu What is the name of your organizational unit? [Unknown]: zhonglijiahua What is the name of your organization? [Unknown]: hop What is the name of your City or Locality? [Unknown]: chengdu What is the name of your State or Province? [Unknown]: ^C[root@localhost bin]# [root@localhost bin]# ^C [root@localhost bin]# [root@localhost bin]# keytool -genkey -alias zljh -keypass talent -keyalg RSA -keysize 1024 -validity 3650 -keystore /home/certificates/zljh.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/786bac3e021410c0912012098fd64009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/552fbe7b5413686d7067129bff4cd2d3/" rel="bookmark">
			2018 年 数据证书的生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 keytool -genkey -alias zljh -keypass talent -keyalg RSA -keysize 1024 -validity 3650 -keystore /home/certificates/zljh.keystore -storepass talent keytool -genkey -alias client1 -keypass 123456 -keyalg RSA -keysize 1024 -validity 15 -storetype PKCS12 -keystore /home/certificates/client1.p12 -storepass 123456 keytool -export -alias client -keystore /home/certificates/client1.p12 -storetype PKCS12 -keypass 123456 -file /home/certificates/client.cer keytool -import -v -file /home/certificates/client1.cer -keystore /home/certificates/zljh.keystore -storepass 123456 keytool -keystore /home/certificates/zljh.keystore -export -alias zljh -file /home/certificates/client1.cer 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059a0c7decddc541f2b5232ee42cb621/" rel="bookmark">
			unity表情动画与动态捕捉表情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人物表情可以使游戏场景中的人物更加逼真，有趣，而人物表情在3A大作中非常常见，自己独立游戏中正好要使用这个功能，所以探讨下这个问题。
常用的表情动画使用以下这么几种
1骨骼动画，2顶点动画，3uv动画，4贴图动画
第一种骨骼动画，在某些游戏，比如一些商业游戏中会使用这种方法，来模拟脸部表情的变化。因为过多的骨骼会影响效率，所以我不太使用这种方式
第二种游戏顶点动画改变
应该是最常用的方式，许多日本方面的模型动画软件也是采用这种方式，诸如MikuMikuDance
通过制作3DMAX中的变形器或者Maya中的blendShape，然后在unity3d中SetBlend的数值来改变表情。
自己Demo中的例子
3.uv动画
通过修改uv坐标，达到角色表情变化，一般是在贴图模型上，没有做嘴巴的模型，用贴图来显示张口闭口的效果。
leftEye.GetComponent&lt;MeshRenderer&gt;().materials[0].SetTextureOffset("_MainTex", new Vector2(eyeLeftEmotionNormal.x*1.0f/eyeRowCol.x, (eyeRowCol.y-1-eyeLeftEmotionNormal.y)*1.0f/eyeRowCol.y)); rightEye.GetComponent&lt;MeshRenderer&gt;().materials[0].SetTextureOffset("_MainTex", new Vector2(eyeRightEmotionNormal.x*1.0f/eyeRowCol.x, (eyeRowCol.y-1-eyeRightEmotionNormal.y)*1.0f/eyeRowCol.y)); 4.贴图动画
通过程序来控制模型贴图的更换，材质球更换
人物的表情捕捉
主要方法为opencv人脸识别，获取特征点，位移值映射到模型的方法
一开始以为得使用kinect这些设备，后来研究了发现一般的手机摄像头就可以
自己尝试过，确实通过手机摄像头，追踪脸部，获取特征点，最后通过脸部特征点匹配，与图片上本来设置好的特征点进行映射。
就像一张图片对应覆盖到人物脸上，如上图显示的效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4a882e93cf8742670bac944a326720f/" rel="bookmark">
			Git强制覆盖更新、commit 强行终止后如何操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.我需要放弃本地的修改，用远程的库的内容就可以，应该如何做？傻傻地办法就是用心的目录重新clone一个，正确的做法是什么？
正确的做法应该是：
git fetch --all git reset --hard origin/master git fetch 只是下载远程的库的内容，不做任何的合并git reset 把HEAD指向刚刚下载的最新的版本
2.今天在服务器上git pull是出现以下错误：
error: Your local changes to the following files would be overwritten by merge:
application/config/config.php
application/controllers/home.php
Please, commit your changes or stash them before you can merge.
Aborting
如果希望用代码库中的文件完全覆盖本地工作版本. 方法如下:
git checkout .
git pull
3.git commit 强行终止后如何操作
今天 当我 执行 git add somefile 的时候，出现 如下 错误：
If no other git process is currently running, this probably means a git process crashed in this repository earlier.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4a882e93cf8742670bac944a326720f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdc29d2f5671da5eb4aadbd5c61f63f1/" rel="bookmark">
			Python3中的urllib.request模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 3.x版本后的urllib和urllib2 现在的Python已经出到了3.5.2
在Python 3以后的版本中，urllib2这个模块已经不单独存在（也就是说当你import urllib2时，系统提示你没这个模块），urllib2被合并到了urllib中，叫做urllib.request 和 urllib.error 。
urllib整个模块分为urllib.request, urllib.parse, urllib.error。
例： 其中urllib2.urlopen()变成了urllib.request.urlopen() urllib2.Request()变成了urllib.request.Request()
urllib和urllib2模块之间的区别 在python中，urllib和urllib2不可相互替代的。
整体来说，urllib2是urllib的增强，但是urllib中有urllib2中所没有的函数。
urllib2可以用urllib2.openurl中设置Request参数，来修改Header头。如果你访问一个网站，想更改User Agent（可以伪装你的浏览器），你就要用urllib2.
urllib支持设置编码的函数，urllib.urlencode,在模拟登陆的时候，经常要post编码之后的参数，所以要想不使用第三方库完成模拟登录，你就需要使用urllib。
urllib一般和urllib2一起搭配使用
官方文档地址 翻译的是Python 3.5.2版本，对应的urllib
https://docs.python.org/3.5/library/urllib.html
urllib整体介绍 原地址：https://docs.python.org/3.5/library/urllib.html
翻译的对应的是21.6. urllib.request — Extensible library for opening URLs
urllib- - - - - - URL处理模块
源代码:Lib / urllib /
urllib是一个包,收集几个模块来处理网址:
urllib.request打开和浏览url中内容 urllib.error包含从 urllib.request发生的错误或异常 urllib.parse解析url urllib.robotparser解析 robots.txt文件
urllib.request 原地址： https://docs.python.org/3.5/library/urllib.request.html#module-urllib.request
urllib.request — 为打开url提供的可扩展类库
源代码:Lib / urllib / request.py
urllib.request模块定义了方法和类,帮助打开url(主要是HTTP)在一个复杂的世界——基本和摘要式身份验证,重定向,cookies等等。
————-urllib.request模块定义了以下功能：—————–
urllib.request.urlopen() urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdc29d2f5671da5eb4aadbd5c61f63f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc7ed0f574360e1f6447d0f6825e701f/" rel="bookmark">
			Highway Networks (Training Very Deep Networks, 2015 NIPS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Reference arxiv papercsdnHighway Networks vs ResNetDeep Residual Learning for Image Recognition (ResNet 2016 CVPR)Densely Connected Convolutional Networks (DenseNet 2017 CVPR) Why Deeper Networks? The Deeper, The Better. (No Consider Computation Complexity) Recent evidence [40, 43] reveals that network depth is of crucial importance
Why Train Deeper Networks Harder? An obstacle to answering this question was the notorious problem of vanishing/exploding gradients [14, 1, 8]
How To Train Very Deep Networks ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc7ed0f574360e1f6447d0f6825e701f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a14d3d84245db485c782a68df239c28f/" rel="bookmark">
			梯度下降法的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些时间接触了机器学习，发现梯度下降法是机器学习里比较基础又比较重要的一个求最小值的算法。梯度下降算法过程如下：
1）随机初始值；
2）迭代，直至收敛。表示在处的负梯度方向，表示学习率。
在这里，简单谈一下自己对梯度下降法的理解。
首先，要明确梯度是一个向量，是一个n元函数f关于n个变量的偏导数，比如三元函数f的梯度为(fx,fy,fz)，二元函数f的梯度为(fx,fy），一元函数f的梯度为fx。然后要明白梯度的方向是函数f增长最快的方向，梯度的反方向是f降低最快的方向。
我们以一元函数为例，介绍一下梯度下降法。
设f(x) = (x-1)2+1/2，
上图给出了函数f的图像和初始值x0，我们希望求得函数f的最小值，因为沿负梯度方向移动一小步后，f值降低，故只需x0沿着负梯度方向移动一小步即可。
而f在点x0的导数大于0，从而f在点x0的梯度方向为正，即梯度方向为f’(x0)，故由梯度下降法可知，下一个迭代值，也就是说x0向左移动一小步到了x1，同理在x1点的导数同样大于零，下一次迭代x1向左移动一小步到达x2，一直进行下去，只要每次移动的步数不是很大，我们就可以得到收敛1的解x。
上述证实了我们对分析（蓝色倾斜字体）的验证。
同样，如果处置选在了最小值的左边，即如图所示：
由于f’(x0)&lt;0，所以梯度方向为负，负梯度方向为正，故需将x0沿负梯度方向移动一小步，即向右移动一小步，这样使得f值更小一些。或用梯度下降法迭代公式，依次我们可以得到如图所示的x1,x2,...,xk,...，直到收敛至最小值。
对于二元函数，我们也可以通过实例验证梯度下降法的合理性：
在每次得到一个点(xk,yk)时，我们需要计算(fx(xk),fy(yk))，这个方向表示梯度f增长最快的方向，-(fx(xk),fy(yk))表示梯度下降最快的方向，故只需将(xk,yk)沿着-(fx(xk),fy(yk))这个方向移动一小步，就可以减少f的值，直至收敛到最小值，如上图所示。
谈几点梯度下降法需要注意的地方，也是自己对梯度下降法的理解：
1）梯度下降不一定可以收敛到最小值。
梯度下降法是收敛到局部最小值，不一定可以收敛到全局最小值。
比如：
我们初始值选择了如图的x0，由于f在点x0的导数大于0，梯度方向向右，负梯度方向向左，从而x0向左移动，逐渐收敛到了局部最小值，而不能收敛到全局最小值。
2）学习率的大小要适中。
学习率太小，每次移动步长太小，收敛太慢，这个比较容易理解。
学习率太大，每次移动步长大，可能导致不收敛，这里用一个图来表示一下：
由于距离最小值点越远，导数越大，从而导致步长越来越大，不会收敛。
3）不一定选择负梯度方向，只要是值下降的方向即可。
在每一次迭代选择方向时，我们只要选择与梯度方向夹角小于90度的向量的反方向就可，不一定要选择负梯度方向。但由于，满足这样条件的向量不太容易求出，我们就选择了与梯度方向0度的向量的反方向（负梯度方向），而且这个方向函数值减少的更快，更快的收敛，故是个不错的选择。
4）求最大值的梯度上升法。
f的梯度方向是f的值增长最快的方向。我们每次沿负梯度方向移动一小步可以逐步收敛到局部最大值，因此我们每次沿梯度方向也可以得到函数f的局部最大值。迭代公式为：
，
这里表示在处的梯度方向，与梯度下降法的含义不同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcce5d9f5a07f39baa97e693597c578b/" rel="bookmark">
			登陆公司服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ssh root@192.168.0.168 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d1ee973ff888096c702c7a61d18c3df/" rel="bookmark">
			方向导数与梯度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方向导数与梯度 在许多问题中，不仅要知道函数在坐标轴方向上的变化率（即偏导数），而且还要设法求得函数在其他特定方向上的变化率。这就是接下来要谈论的方向导数。
定义 1 设三元函数 在点 的某邻域 内有定义， 为从点 出发的射线， 为 上且含于 内的任一点，以 表示与两点间 与 的距离，若极限 存在，则称此极限为函数 在点 沿方向 的 方向导数 ，记作 沿任一方向的方向导数与偏导数的关系由下述定理给出。 定理 若函数 在点 可微，则 在点 处沿任一方向 的方向导数都存在，且 其中 为方向 的方向余弦。 注：最后会介绍方向余弦的知识
例1 设 ，求 在点 沿方向 的方向导数。 解 易见 在点 可微。故由 及 方向的方向余弦 可按定理中的公式求得沿方向的方向导数为
. 定义 2 若在存在所有自变量的偏导数，则称向量为函数在点的梯度，记作
. 向量 的长度（或模）为 在上述定理的条件下，若记方向上的单位向量为
. 于是方向导数公式又可以写成 这里 是梯度向量 与 的夹角。 因此当时，取得最大值。这就是说当在点可微时，在点的梯度方向是的值增长最快的方向，且沿这一方向的变化率就是梯度的模。 而当 与梯度向量反方向 时，方向导数取得最小值 。 例 2 设 ，求 在点 处的梯度及它的模。 解 由于 所以 补充：方向余弦 定义：在解析几何里，一个向量的三个 方向余弦 分别是这向量与三个坐标轴之间的角度余弦。 计算方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d1ee973ff888096c702c7a61d18c3df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/358424b0cea6eca4003bb8535410375d/" rel="bookmark">
			caffe添加python数据层（ImageData）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		caffe 添加python数据层 本文主要是详细介绍如何在caffe中添加自定义python数据层（imagedata类型）。我之所以要实现这个python数据层是因为最近准备使用caffe+LSTM结构做行为识别，需要给视频每帧添加一个clips数据层，这意味着整个网络的输入有三个（data，label，clips），而caffe中是没有的，所以就尝试使用python实现自定义数据层，废话不多说，下面就开始详细介绍如何实现python数据层（imagedata类型）。 1.修改prototxt文件，格式如下图所示 从上图可以看出，python_param中有三个部分：module，layer，param_str。其中module就是我们需要实现python层的文件名，如下图示： 注意，这个文件一定要和上面的prototxt文件放在同一个路径下。下面就具体看一下image_data_layer.py文件具体都需要实现哪些内容。 2.实现image_data_layer.py 在caffe中添加自定义层时，必须要实现这四个函数，在C++中是（LayerSetUp，Reshape，Forward_cpu，Backward_cpu），在python 中是（setup，reshape，forward_cpu，backword_cpu）。下面是.py文件的具体内容： import sys sys.path.append('../python') import caffe import numpy as np import skimage.io from PIL import Image import scipy import random class ImageDataLayer(caffe.Layer): """ This is a simple python datalayer for reading image data """ def setup(self, bottom, top): self.top_names = ['data', 'label'] # === Read input parameters === # params is a python dictionary with layer parameters. params = eval(self.param_str) # Check the parameters for validity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/358424b0cea6eca4003bb8535410375d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/897dd95f27ea7793ed652175192bff7c/" rel="bookmark">
			Android 5分钟实现ShareSDK分享各平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图 一 首先，到官网下载shareSDK的jar包，我demo里的是3.1.2版本 http://www.mob.com/downloadDetail/ShareSDK/android 然后将你需要分享的平台的jar包导入lib 二 在你的根目录下（就是包名目录），new一个package叫wxapi，然后把你下载好的sdk里的WXEntryActivity扔进去 三 在你的 AndroidManifest.xml中application下，添加如下代码 权限：
&lt;!-- 添加必要的权限 --&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt; &lt;uses-permission android:name="android.permission.GET_TASKS" /&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt; &lt;!-- 短信验证登陆功能需要添加次权限来自动填充验证码，用不到可以去掉 --&gt; &lt;uses-permission android:name="android.permission.RECEIVE_SMS" /&gt; &lt;!--ShareSDK相关start--&gt; &lt;activity android:name="com.mob.tools.MobUIShell" android:theme="@android:style/Theme.Translucent.NoTitleBar" android:configChanges="keyboardHidden|orientation|screenSize" android:windowSoftInputMode="stateHidden|adjustResize" &gt; &lt;!-- 调用新浪原生SDK，需要注册的回调activity --&gt; &lt;intent-filter&gt; &lt;action android:name="com.sina.weibo.sdk.action.ACTION_SDK_REQ_ACTIVITY" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt; &lt;!--集成line客户端登录授权，需要添如下格式的过滤器--&gt; &lt;intent-filter&gt; &lt;data android:scheme="line.1477692153" /&gt; &lt;action android:name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/897dd95f27ea7793ed652175192bff7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/453888ff18067537923798165513aa20/" rel="bookmark">
			常用注解（Annotation）整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Java中@Autowired或@Resource这两个注解功能都是相同的，这两个注解的区别：@Autowired默认按类型装配，@Resource默认按名称装配，当找不到与名称匹配的bean时才会按类型装配。 2.@Autowired、@Qualifier、@Resource三者的区别： 简单理解： @Autowired 默认根据类型注入； @Resource 默认根据名字注入，其次按照类型注入； @Autowired @Qualifier(“userService”) 两个结合起来默认按类型注入，其次按名字注入。
3.spring/springMVC中常用注解对比： @Configuration — spring配置文件中的&lt;beans&gt;&lt;/beans&gt;
@Bean — spring配置文件中的&lt;bean&gt;&lt;/bean&gt;
@Autowired 、@Named 两个注解可以互换使用 @Component 、@Inject两个注解可以互换使用
@ContextConfiguration — spring整个配置文件(applicationContext.xml)
@componentScan — spring配置文件中的&lt;context：component-scan base-package=“xxx”/&gt;
@Service(“name”) — spring配置文件中的&lt;bean class="xxx" id="name"&gt; id=name
@Scope 代表spring容器的生命周期，取值有singleton、prototype 、request 、session 、global session五种。 注意：request、session和global session类型只实用于web程序，通常是和XmlWebApplicationContext共同使用。
@EnableScheduling:开启对定时任务的支持; @Scheduled：声明一个定时任务;
@Conditional:满足一定条件来创建一个特定的bean;
@RequestHeader ： 可以把Request请求header部分的值绑定到方法的参数上。
Request的Header部分： Host localhost:8080 Accept text/html,application/xhtml+xml,application/xml;q=0.9 Accept-Language fr,en-gb;q=0.7,en;q=0.3 Accept-Encoding gzip,deflate Accept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7 Keep-Alive 300 @RequestMapping("/displayHeaderInfo.do") public void displayHeaderInfo( @RequestHeader("Accept-Encoding") String encoding, @RequestHeader("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/453888ff18067537923798165513aa20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceac4379865ec3382c17b032b8997962/" rel="bookmark">
			spring data jpa 学习整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Data Jpa 依赖 maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; .yml文件 配置mysql,jpa等 server: port: 8080 context-path: / helloWorld: spring Boot\u5927\u7237\u4F60\u597D msyql: jdbcName: com.mysql.jdbc.Driver dbUrl: jdbc:mysql://localhost:3306/wj33 userName: root password: spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/wj33?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: jpa: hibernate.ddl-auto: update show-sql: true database-platform: com.lunwen.wangjie.config.MySQL5DialectUTF8 thymeleaf: cache: false 实体类 实体类的注解 会根据注解自动生成表字段，@Table指定表名，不填，默认为类名@Column指定字段名，不填，默认为属性名其他注解指定字段的规则 import javax.persistence.*; @Entity @Table(name = "user") public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; /** 姓名 */ @Column(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceac4379865ec3382c17b032b8997962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60252e86e50d4b16848f91a423a07287/" rel="bookmark">
			Kinect V2.0得到RGB图像各个像素点对应的三维坐标（相机坐标系）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kinect2.0 SDK中有函数原型如下的映射机制，可得到1920*1080的RGB图像中各个像素点对应的相机坐标系下的三维坐标
public: HRESULT MapColorFrameToCameraSpace( UINT depthPointCount, const UINT16 *depthFrameData, UINT cameraPointCount, CameraSpacePoint *cameraSpacePoints ) 简单Demo如下
#include &lt;iostream&gt; #include &lt;opencv2/opencv.hpp&gt; #include &lt;Kinect.h&gt; using namespace std; using namespace cv; UINT16 *depthData = new UINT16[424 * 512];//深度图输出为512*424 CameraSpacePoint* m_pColorCoordinates = new CameraSpacePoint[1920 * 1080];//RGB图输出为1920*1080 int main(void) { HANDLE DetectorServiceThreadHandle = CreateThread(NULL, 0, DetectorServiceThread, NULL, 0, NULL); IKinectSensor * mySensor = nullptr; GetDefaultKinectSensor(&amp;mySensor); mySensor-&gt;Open(); IColorFrameSource * myColorSource = nullptr; mySensor-&gt;get_ColorFrameSource(&amp;myColorSource); IColorFrameReader * myColorReader = nullptr; myColorSource-&gt;OpenReader(&amp;myColorReader); int colorHeight = 0, colorWidth = 0; IFrameDescription * myDescription = nullptr; myColorSource-&gt;get_FrameDescription(&amp;myDescription); myDescription-&gt;get_Height(&amp;colorHeight); myDescription-&gt;get_Width(&amp;colorWidth); IColorFrame * myColorFrame = nullptr; Mat original(colorHeight, colorWidth, CV_8UC4);; //**********************ColorFrame************************** IDepthFrameSource * myDepthSource = nullptr; mySensor-&gt;get_DepthFrameSource(&amp;myDepthSource); int depthheight = 0, depthwidth = 0; IFrameDescription * myDepthDescription = nullptr; myDepthSource-&gt;get_FrameDescription(&amp;myDepthDescription); myDepthDescription-&gt;get_Height(&amp;depthheight); myDepthDescription-&gt;get_Width(&amp;depthwidth); myDepthDescription-&gt;Release(); IDepthFrameReader * myDepthReader = nullptr; myDepthSource-&gt;OpenReader(&amp;myDepthReader); IDepthFrame * myDepthFrame = nullptr; while（1）{ while (myDepthReader-&gt;AcquireLatestFrame(&amp;myDepthFrame) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60252e86e50d4b16848f91a423a07287/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc845703e60a7e12aed0600c1feb6d7b/" rel="bookmark">
			C3P0连接池参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;c3p0-config&gt; &lt;default-config&gt; &lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --&gt; &lt;property name="acquireIncrement"&gt;3&lt;/property&gt; &lt;!--定义在从数据库获取新连接失败后重复尝试的次数。Default: 30 --&gt; &lt;property name="acquireRetryAttempts"&gt;30&lt;/property&gt; &lt;!--两次连接中间隔时间，单位毫秒。Default: 1000 --&gt; &lt;property name="acquireRetryDelay"&gt;1000&lt;/property&gt; &lt;!--连接关闭时默认将所有未提交的操作回滚。Default: false --&gt; &lt;property name="autoCommitOnClose"&gt;false&lt;/property&gt; &lt;!--c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试使用。Default: null --&gt; &lt;property name="automaticTestTable"&gt;Test&lt;/property&gt; &lt;!--获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常。但是数据源仍有效保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试获取连接失败后该数据源将申明已断开并永久关闭。Default: false --&gt; &lt;property name="breakAfterAcquireFailure"&gt;false&lt;/property&gt; &lt;!--当连接池用完时客户端调用getConnection()后等待获取新连接的时间，超时后将抛出SQLException,如设为0则无限期等待。单位毫秒。Default: 0 --&gt; &lt;property name="checkoutTimeout"&gt;100&lt;/property&gt; &lt;!--通过实现ConnectionTester或QueryConnectionTester的类来测试连接。类名需制定全路径。Default: com.mchange.v2.c3p0.impl.DefaultConnectionTester --&gt; &lt;property name="connectionTesterClassName"&gt;&lt;/property&gt; &lt;!--指定c3p0 libraries的路径，如果（通常都是这样）在本地即可获得那么无需设置，默认null即可Default: null --&gt; &lt;property name="factoryClassLocation"&gt;null&lt;/property&gt; &lt;!--Strongly disrecommended. Setting this to true may lead to subtle and bizarre bugs. （文档原文）作者强烈建议不使用的一个属性 --&gt; &lt;property name="forceIgnoreUnresolvedTransactions"&gt;false&lt;/property&gt; &lt;!--每60秒检查所有连接池中的空闲连接。Default: 0 --&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc845703e60a7e12aed0600c1feb6d7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d13f6646b8e6b33b3c03f0032cd231dc/" rel="bookmark">
			UE4 多人联机显示每个人的playid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的：在多人联机模式下，在每个pawn的上方显示textrender，并且在textrender里显示每个pawn的playerid
下面以一个listen server和两个client的方式测试。
1. 创建一个带有textrender的actor，并且勾选其replicated开关
2. 在Charactor的蓝图里面创建出textrender的actor并attach到Charactor上，并且将spawn出来的actor设置到本地
变量，后面需要用到这个变量来设置其文子，因为其实动态创建出来的。
这里是由服务器来动态创建出带有textrender的actor，然后attach到Charactor上，然后把textrender同步
到客户端上，这样客户端的textrender就是服务器端一个副本了。
另外也可以直接在蓝图里把textrender的actor挂载成charactor的子组件，就不用上面的蓝图动态创建了。
3. 在GameMode里面获得并保存所有的player control
4. 在textrender的actor里面创建一个成员变量name，并且把他的同步属性设置为RepNotify，并实现
其onRepName函数，来设置textrender要显示的player id
做到这里，textrender已经被我们同步了，名子变量也同步了，名子变量一旦有变化，就会设置textrender显示。
接下来只要在服务器端吧player id正确设置即可。
5 . 这里就是使用GameState里面保存的playid，GameMode里面保存的Player Control得到Pawn来设置其
textrender里面的name变量。
总结：
1. textrender上面显示的文件并不会同步，因此我们只能使用一个变量来保存文字，然后同步这个变量，并且
在变量的repnotify函数里来设置文字显示。
2. 只有服务器能拿到所有的playcontrol，因为设置文字变量由服务器来完成
效果展示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fa1722aa25cd038ccf4794f748bf674/" rel="bookmark">
			关于Win10系统-svchost大量占用网速及自动更新问题——完美解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 -2018.04.03更新
最近发现这个要命的svchost.exe竟然还在抢我的网，于是又折腾了一番，现在更新解决办法，另附带win10系统完全关闭自动更新解决办法。
首先先将之前更新的方法做一遍，就是在开始菜单找到应用商店或者在系统设置–更新和安全–激活–右侧转到应用商店。然后点击应用商店右上角的…，找到设置项–将自动更新应用关闭。
然后win键+R 打开运行，输入 services.msc，回车，在右侧服务中找到Background Intelligent Transfer service设置禁用。
此时注意很多人就只告诉你这样做,然而过几天你发现还是一样网速占满 他又自动开了
**因为 后面选项卡叫“恢复”，就是处理如果这个服务 打不开怎么办 **
对，没错，把这些全都改成 什么都不做 或者 无操作 或者 take no action
同理，下面还有个Windows Update 服务 ，也是 先禁用，然后设置恢复选项卡。完美解决。
另外还可以加强一下，就是把你的无线设置为按流量计费的连接。
连接上无线网，然后打开电脑设置，点击网络和Internet，找到高级设置，点击该选项，然后就会出现是否将此无线设置为按流量计费的连接，选择是，就大功告成了。
-2017.12.28更新
近几天在刚上班的时候，打开电脑发现刚开始的网速特别慢，但是用电脑管家查看实时下载速度并不慢，于是怀疑有进程占用了网速，于是找到了这个名叫svchost.exe的进程在占用大量网速。
后来从网上搜集了一些信息，svchost.exe是一个属于微软Windows操作系统的系统程序，而且权利很大，可以 监控应用程序，纪录输入，隐藏自身，接到互联网，操纵其他程序等等。
感兴趣的可以看看svchost.exe 百度百科
步入正题，一开始试了好多办法都没有解决，包括禁用服务，关闭windows更新，而且这个进程属于系统关键进程，不能用腾讯电脑管家限速或禁止。
最终解决办法：
在开始菜单找到应用商店或者在系统设置–更新和安全–激活–右侧转到应用商店。然后点击应用商店右上角的…，找到设置项–将自动更新应用关闭，解决。
觉得有帮助的小伙伴记得点个赞鼓励下~ 扫描上方二维码关注我的订阅号~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e944885cee1af241294c674f379abfc5/" rel="bookmark">
			windows之打开文件夹、控制面板显示服务器运行失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开文件夹、控制面板显示服务器运行失败，网上众说纷纭。
步骤一：开始菜单–&gt; 右击点属性 –&gt; 点击自定义 –&gt; 将控制面板选项下的单选框选择显示为菜单 ； 步骤二：开始菜单–&gt; 搜索 输入 文件夹选项 –&gt; 在查看中将在单独的进程中打开文件夹窗口前的勾去掉，点击确认即可。
一部分转载自[这里].(http://blog.csdn.net/zhaozheng7758/article/details/9373189)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b09b80c83c96464f7f7839b20bfc8e7f/" rel="bookmark">
			STM32的时钟系统RCC详细整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、综述： 1、时钟源
在 STM32 中，一共有 5 个时钟源，分别是 HSI 、 HSE 、 LSI 、 LSE 、 PLL 。
①HSI 是高速内部时钟， RC 振荡器，频率为 8MHz ； ②HSE 是高速外部时钟，可接石英 / 陶瓷谐振器，或者接外部时钟源，频率范围是 4MHz – 16MHz ； ③LSI 是低速内部时钟， RC 振荡器，频率为 40KHz ； ④LSE 是低速外部时钟，接频率为 32.768KHz 的石英晶体； ⑤PLL 为锁相环倍频输出，严格的来说并不算一个独立的时钟源， PLL 的输入可以接 HSI/2 、 HSE 或者 HSE/2 。PLL倍频可选择为 2 – 16 倍，但是其输出频率最大不得超过 72MHz 。 其中， 40kHz 的 LSI 供独立看门狗 IWDG 使用，另外它还可以被选择为实时时钟 RTC 的时钟源。另外，实时时钟 RTC 的时钟源还可以选择 LSE ，或者是 HSE 的 128 分频。 STM32 中有一个全速功能的 USB 模块，其串行接口引擎需要一个频率为 48MHz 的时钟源。该时钟源只能从 PLL 端获取，可以选择为 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b09b80c83c96464f7f7839b20bfc8e7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ed8bc720e96fa31eb41994469d58de/" rel="bookmark">
			智能运维挑战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能运维，对应的架构如何设计，才能满足以上的场景和未来需要，学术界众说纷纭，我们可以选取。。。中的架构设计中来略见一斑。这个架构是由分析处理模块，模型管理，推荐决策，校验应用四个主要模块构成。其对应的职责如下：
分析处理（Lift，Analyze，Process）：主要对于生产环境的实时的数据进行预处理，完成相关性分析，归一化之后，之后通过模型匹配来输出结果，此类结果包含系统内部的各种异常（单板，用户行为，KPI指标，KQI指标等等），网络关键事件的各种预测结果（小区负荷，信道频率，指纹覆盖，天馈老化，容量趋势），通过根因分析输出的某一个特殊事件的上下文（对于某一种具体故障的所有相关信息被搜集，被确认，为后续的自动运维打下基础）。这个模块实际就是一般机器学习中的推理模块的高级版本。
模型分类模块：主要职能是获取历史数据，进行机器学习，输出各种推理模型。其中输出上下文识别，预测，异常检测模型到分析处理模块进行上下文处理，策略和规则等到推荐决策模块用于自动化运维。
推荐决策模块：基于分析处理的上下文识别来确定当前事件所处的环境，根据策略进行匹配对应的后续执行行为，而行为列表则是基于用户的维护习惯学习得来。基于以上的组合，在发生某个事件时，通过策略自动匹配到特定用户采取的后续动作，进行执行，达到自动运维的地步。
校验应用：主要是对自动运维进行业务监控，防止整个自动化运维跑偏。
整个系统设计分析处理对应上述的智能监测闭环，推荐决策对应于智能控制闭环，两个闭环可以分别演进；其次存在一个纠偏系统，这个是由大量的业务规则组成的，这也是由于通信网络的重要性造成的，也是由于通信网络生成（设备商）和经营（运营商）分离的特性导致的；最后这个架构的特性仔细观察可以发现存在超级管理者，在整个智能运维过程中可以随时切断自动化，这也是因为通信网络的影响比较大而导致；另外可以看到整个通信网络机器学习中重要的推理模型种类分为需求，预测，推荐，模式四种，分别代表用户对于结果的要求，预测行为，上下文识别行为，自愈行为
目前通信网络一般由OSS，EMS，NE一层网络实体和两层管理系统构成。上述的方案的智能运维的训练，分析，推荐，反馈系统和现有系统的关系如下图，网元一般情况下会增加一个通用推理功能，其接收其他管理系统训练后的推理模型，在实际生产环境中接收实时数据后，实时推理，这种方式的特点是对网络的反应具备实时性，这个称之为自环；其次是在EMS中，对于本网络的数据进行训练，得到推理模型，在收到数据后进行推理，或者把模型推送给网元。他具备了以上架构中的所有元素，区别在于由于成本和职责的定位，其主要面对数据量不太的情况，非实时的推理情况，不会采取集群运算和大规模矩阵运算。最上面一层则是采取类似EMS，只不过其支持大数据量训练，集群计算，可能是第三方系统，同样其训练的模型可以在图中的三个层次进行共享。
最后这个架构和当前各层生产系统的关系还体现在其主要设计为侧挂系统，如Cognet报告中所述，即提供各种服务给当前生成系统，如果撤除智能运维框架，现有生产系统也照样运行，只是自动化程度降低而已。
对于智能控制，这个专项领域相关论文进展不大。所以在解决方案的最有一部份，我们针对最先落地智能检测的一些典型问题，思路和相关算法做一下讨论，首先给看下面一张问题导图
自上而下看，任何一个异常，在监测之后都希望找到其根本原因，根本原因则是通过故障传播链来得到。一个故障传播链需要从这样几个部分得到，
通过机器聚类学习在一些随机事件中自动发现属于同一类别的事件；通过异常事件之间的相关性分析，来发现这些事件的相关性有多大；通过异常服务和事件的相关性分析，找到导致异常服务的具体网络事件；通过全链路调用挖掘发现不同组件之间的关系。通过这样一些关系的挖掘，找到故障传播链。另外对于事件的预测也可以成为事件异常检测的一种手段，因为如果发现检测的值相离预测值较远，则认为是异常。这些问题的通用算法总结如下：
事件异常检测：基于窗口，基于预测，基于近似性，基于隐式马尔可夫模型，也有机器学习，集成学习，迁移学习，深度学习，深度生成模型等等
事件趋势预测：有ARIMA、EWMA、时序数据分解、RNN等
事件相关性：基本算法包括DTW，MK最佳配对等
事件聚类：聚类用到的基本算法包括DBSCAN，K-medoids、CLARANS
服务-事件相关:用基本算法包括Pearson 关联分析， J-Measure， Two-sample test等
故障传播链：现有文献中常见的算法有：FP-Growth、Apriori、随机森林
机会和挑战：
尽管智能运维有着灼热的前景，但是不可否认，未来依然是机会和挑战共存。笔者认为，未来的挑战来自如下几个方面：
首先是算法的挑战，由于智能运维属于专业领域，人工智能在这个领域的学术研究并不太多。目前的一些经典算法主要集中在监测领域，对于控制领域的算法和应用则需要从业人员自行研究，和计算机视觉，语言等直接可以拿到一些效果很好的算法以及相关参数相比，智能运维起点则低了很多，需要从基础算法的选择，调优等探索开始，可借鉴性的论文也比较少；同时高水平的人工智能学者目前也都处于目前最热的视觉，语言等领域，本领域如果要提高影响力，则需要从数据，业务开源，公开比赛做起，如同谷歌李飞飞教授举办的ImageNet一样把图像识别的识别率经过几年的努力，直接超过了人类，这些则需要大家的共同努力
其次是数据同源的挑战，不可否认目前在电信的领域沉淀着非常多的数据，不同数据来自不同厂商，类型也不同，例如关系型，对象型，日志，文件型等等，相互之间的数据关联和访问，以及访问的效率也是一个非常大的挑战。
最后一个是电信领域特有的问题，电信领域目前网络是生产和运营分离，由于不同运营商，以及不同地域的地理，经济都不同，会直接影响到期业务模型。这样对于生产商做出来的原始算法模型，在不同的运营商不同的地域都需要重新训练和调整，这个涉及到目前机器领域相关迁移学习的问题。这个也是本领域面临的问题。
尽管存在一些问题，但是基于机器学习的智能运维不可阻挡，周边的生态环境已经发生变化，物联网，虚拟化网络，巨大的数据量喷发，百舸争流的经营常态都让我们思考，未来，我们还能从智能运维中期待到什么？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/105487879a04a592d9967ef6cd0522bc/" rel="bookmark">
			深度学习人脸关键点检测方法----综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料 一、 引言二、 检测方法 总结 近期对人脸关键点相关方法进行了研究，在深度学习大行其道的背景之下，此博客对近期人脸关键点检测深度学习方法进行了记录和总结，希望给广大朋友一点点启发，也希望大家指出我阅读过程中的错误~
主要有如下模型： 2.1 ASM (Active Shape Models) 2.2 AAM（Active Appearance Models） 2.3 CPR（Cascaded pose regression） 2.4 DCNN 2.5 Face++版DCNN 2.6 TCDCN 2.7 MTCNN 2.8 TCNN（Tweaked Convolutional Neural Networks） 2.9 DAN（Deep Alignment Networks） 先贴参考资料，想进入主题的直接跳过
参考资料 主要参考资料： 2017-Facial feature point detection A comprehensive survey–综述
标注文献： [1] T.F. Cootes, C.J. Taylor, D.H. Cooper, et al. Active Shape Models-Their Training and Application[J]. Computer Vision and Image Understanding, 1995, 61(1):38-59.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/105487879a04a592d9967ef6cd0522bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee90cfb3e490b7facb8121a4a2061bd2/" rel="bookmark">
			【数据集整理】人体行为识别和图像识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一共12个人体行为识别的数据集，基于视频的；
6个图像识别的，有关物体识别、行人识别、年龄识别和人头检测的，基于图像，图像识别数据集参考于博客：http://blog.csdn.net/qq_14845119/article/details/51913171
后续可能还会补充。
视频识别 1、Weizmann 内容：
1、10个类别，每个类别9个视频，背景单一。
2、180x144
下载链接： http://www.wisdom.weizmann.ac.il/~vision/SpaceTimeActions.html
2、KTH 内容：
1、共25个人采集，6个类别，每个类别4个情境，3中室外，1种室内，共600个视频。
2、给出了每个视频4个片段的始末帧位置。
3、规格：160x120，25fps。
下载链接： http://www.nada.kth.se/cvap/actions/
自己整理了一份放在百度云，
链接：https://pan.baidu.com/s/1cMhy1nW76dFIcOK0RjlkQw 密码：naw4，
有效期7天
3、Fire Detection 内容： 共6个视频，火灾检测。
下载链接： http://crcv.ucf.edu/data/fire.php
4、UCF101 内容：
1、共13320个视频101个类别，从YouTube采集的真实场景。
2、分为5大类：人与物交互、baby动作、人人交互、乐器演奏、运动。
3、规格：320x240，25fps，最小视频为28帧。
下载链接： http://crcv.ucf.edu/data/UCF101.php
5、HMDB51 内容：
1、共51个类别，6849个视频。每一个类别至少包含101个视频。
2、从电影、视频网站上采集。
3、包含5大类：面部动作（微笑、大笑、咀嚼、说话）；面部与物交互动作（吃饭、喝水、抽烟）；身体运动（翻跟斗、拍手、爬上等）；身体与物交互运动（梳头发、拔剑等）；人人交互运动（击剑、拥抱、接吻等）
下载链接： http://serre-lab.clps.brown.edu/resource/hmdb-a-large-human-motion-database/#dataset
6、VISAL 内容：
1、包含很多数据集，船只数据、纹理合成数据、交通拥挤数据、拥挤人群数据UCSD（行人、人注释、人数、线划分）、人3D姿态数据MADS。
2、可下载拥挤人群和人姿态。
下载链接： http://visal.cs.cityu.edu.hk/downloads/
7、Monitoring Human Activity 内容：
1、数据量很小，且需要单独下载，有空可下载。
下载链接： http://mha.cs.umn.edu/index.shtml
8、HOLLYWOOD2 内容：
1、人体动作：12个类别。
2、场景：10个类别。
3、共3669个视频，20.1个小时。
4、从69部电影中采集。
5、视频样本中行为人的表情、姿态、穿着，以及相机运动、光照变化、遮挡、背景等变化很大，接近于真实场景下的情况，因而对于行为的分析识别极具挑战性。
下载链接： http://www.di.ens.fr/~laptev/actions/hollywood2/
9、YouTube-8M 内容：
1、800万个标注视频，每个视频120s到500s。
下载链接： https://research.google.com/youtube8m/
10、Moments in Time Dataset 内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee90cfb3e490b7facb8121a4a2061bd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c62b7ecaaf5ffd1e042f63b41fdf8495/" rel="bookmark">
			跨 境 电 子 商 务 年 度 个 人 额 度 查 询--跨境电商两万限额
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://ceb2pub.chinaport.gov.cn/limit/outIndex 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17f2c2c5128ad11a93bd5d3877ea3233/" rel="bookmark">
			人工智能之自动驾驶系列（一）：概要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能之自动驾驶系列（一）：概要 蓬生麻中 http://blog.csdn.net/wangdaiyin/article/details/77403592 版权声明：本文系个人经多处资料学习、吸收、整理而得，如需转载，请注明出处：作者名+链接。
内容说明：本系列内容大致包括自动驾驶概念、前沿动态、市场分析、应用场景、国家政策、技术框架、研究现状、典型方案、未来趋势与个人思考、动手实践简易版L3自动驾驶汽车等。
关键词：人工智能，自动驾驶，机器学习，深度学习，创新创业，前沿
一、自动驾驶背景 随着深度学习技术的崛起、人工智能的备受关注，自动驾驶，作为AI中备受关注的重要落脚点，也被炒的火热，更让人充满了幻想。
1.1 自动驾驶的概念 自动驾驶，也常被人称作无人驾驶、无人车等，但这几个词的表述其实是有所区别的，英文里常见的表述有autopilot，automatic driving，self-driving，driveless等，这里不作科普。关于自动驾驶，在概念上业界有着明确的等级划分，主要有两套标准：一套是NHSTAB（美国高速公路安全管理局）制定的，一套是SAE International（国际汽车工程师协会）制定的。现在主要统一采用SAE分类标准。以下附上专业分级定义：
0级：人工驾驶，即无自动驾驶。由人类驾驶员全权操控汽车，可以得到警告或干预系统的辅助； 1级：辅助驾驶，通过驾驶环境对方向盘和加减速中的一项操作提供驾驶支持，其他的驾驶动作都由人类驾驶员进行操作； 2级：半自动自动驾驶，通过驾驶环境对方向盘和加减速中的多项操作提供驾驶支持，其他的驾驶动作都由人类驾驶员进行操作； 3级：高度自动驾驶，或者称有条件自动驾驶，由自动驾驶系统完成所有的驾驶操作。根据系统要求，人类驾驶者需要在适当的时候提供应答； 4级：超高度自动驾驶，由自动驾驶系统完成所有的驾驶操作。根据系统要求，人类驾驶者不一定需要对所有的系统请求做出应答，包括限定道路和环境条件等； 5级：全自动驾驶，在所有人类驾驶者可以应付的道路和环境条件下，均可以由自动驾驶系统自主完成所有的驾驶操作。
总的来说，分级的核心区别在于自动化程度，重点体现在转向与加减速控制、对环境的观察、激烈驾驶的应对、适用环境范围上的自动化程度。就目前来说，还在进行L3、L4级的研发，离电影中所展示的那些L5全自动驾驶还有比较长的一段距离。
1.2 前沿动态 现阶段，无人驾驶技术发展正如火如荼，以下先梳理了一下2016年来国外自动驾驶的一些大事件：
2016年1月，通用汽车投资5亿美元给Lyft（美国第二大移动出行公司），此后3月，通用汽车六亿美元收购无人车技术初创企业Cruise Automation，吹响了传统车企“以资金换技术”的号角。2016年5月，一位来自美国俄亥俄州的40岁男子Joshua Brown，驾驶特斯拉Model S到一个十字路口时，与一辆大型拖车发生意外碰撞事故后死亡。事故发生时Model S的 Autopilot自动辅助驾驶模式处于开启状态。但这一事件并未停止特斯拉在无人驾驶上的投入与发展，反而大幅增加了研发和投资力度。面对现有技术中存在的弊端，研发更先进的技术是最好的解决途径。2016年7月，宝马（世界知名汽车厂商）、英特尔（世界顶级芯片厂商）、Mobileye（ADAS高级辅助驾驶系统领域专家）联合宣布将合作研发无人驾驶汽车，优势互补，各取所需，也减少了筹措发展自动驾驶技术的资金和人才对自身主营业务的冲击。类似的模式曾也发生在微软、英特尔、戴尔联想等身上。2016年8月，负责新加坡无人驾驶出租车项目的科技公司nuTonom，宣布世界上第一批无人驾驶出租车在新加坡开始载客运营。2016年8月，Uber出资6.8亿美元收购无人驾驶货车公司Otto，Otto联合创始人是前谷歌无人驾驶核心工程师Anthony Levandowski。此外，Uber有投资5亿美元用于构建自身地图服务，并与沃尔沃联合投资3亿美元共同开发自动驾驶汽车，基本完善了自动驾驶领域的技术布局。9月份，Uber在匹兹堡推出自由的无人驾驶汽车队。（小插曲：今年2月，Google子公司Waymo对Levandowski提出了一项诉讼，声称其离职前窃取了公司自动驾驶汽车的机密资料。）2016年8月，福特联合百度投资1.5亿美元于激光雷达制造商Velodyne2016年9月，纽约时报发布报告，显示以软硬件一体化出名的苹果在无人驾驶项目（Titan）上遭遇重大挫折，苹果可能放弃打造硬件，全面转向无人驾驶软件。而此前5月，苹果还曾宣布10亿美元投资滴滴出行，但一概保密的苹果的无人驾驶项目发展究竟几何，还有待时间来揭晓答案。2016年10月，特斯拉宣布，旗下搭载全自动驾驶硬件的汽车开始量产，特斯拉由此成为世界上第一家量产全自动驾驶硬件的汽车制造商。虽然该套件是否能完全实现自动驾驶在业界仍有争议（新硬件依然未采用识高精度识别的激光雷达），但这一做法仍然大大推动了整个业界自动驾驶技术的发展。2016年12月，谷歌无人驾驶项目独立，专门成立新公司Waymo，主要合作对象是菲亚特-克莱斯勒。谷歌作为第一家主营业务跟汽车制造并无关系、依据互联网优势跨界涉足无人驾驶技术的公司，依靠人工智能和深度学习技术，在无人驾驶技术软件上取得了得天独厚的优势。2016年末，福特Fusion第二代自动驾驶汽车亮相，且此前有发布无人驾驶项目5年计划，执行力一流。福特是传统车企里唯一一家迭代自动驾驶汽车到第二代的汽车制造商，但其自动驾驶汽车相比特斯拉要稍显逊色。（除福特之外，这一年大众、奔驰、宝马、丰田、沃尔沃等也提出了自动驾驶相应计划）2017年7月，软银、通用和宝马等向无人驾驶初创公司Nauto投资1.59亿美元。下面是2017年的一些重大进展预测： 福特将在欧洲测试无人驾驶汽车; 沃尔沃将在中国测试100辆无人驾驶汽车; 通用无人驾驶汽车雪地测试； 特斯拉马斯克声称将在11月或12月演示无人驾驶汽车从洛杉矶行驶到纽约。 接着，我们来说说国内自动驾驶的情况，毕竟这跟我们的关联更加密切。先看看大公司，腾讯、阿里、华为基本无论是战略布局还是技术实力来看，其起步和现有成果都落户于百度一截，就目前来说如何最好的入局自动驾驶想必也该是这些大公司一直在思考的。 这里重点说一下百度：
百度是BAT里唯一一家大举押注无人驾驶技术的公司，跟Google一样拥有人工智能和深度学习技术优势，从布局来看，百度有联合福特投资激光雷达制造商Velodyne，和芯片制造商英伟达达成合作，在整车制造商上主要与北汽达成了合作，同时与宝马、奇瑞、比亚迪等一众厂商也有展开合作。
2013年百度无人驾驶项目在百度研究院起步；2014年7月，百度首次证实已启动“百度无人驾驶汽车”研发计划；2015年12月，百度宣布正式成立自动驾驶事业部，并提出著名时间表：“三年商用，五年量产”，预计2018年输出在城市简单路况下的自动驾驶实现商用；2020年前，逐步开放至高速公路和普通城市道路上的全自动驾驶实现量产。2016年9月，L3事业部正式亮相，后更名为智能汽车事业部，宣布已获得美国加州第15张无人驾驶测试牌照，2016年11月，已在公共道路上测试L3自动驾驶汽车。2017年4月，百度宣布“Apollo（阿波罗）计划”，将向汽车行业及自动驾驶领域的合作伙伴提供一个开放、完整、安全的软件平台，帮助他们结合车辆和硬件系统，快速搭建一套属于自己的完整的自动驾驶系统。据了解，百度Apollo平台的结构包括一套完整的软硬件和服务体系，包括车辆平台、硬件平台、软件平台、云端数据服务等四大部分。百度会在车辆和传感器等领域选择协同度和兼容性最好的合作伙伴，共同组成协作联盟，推荐给项目参与方使用，进一步降低无人车的研发门槛，促进技术的快速普及。据悉，百度也是全球范围内第一家宣布对外开放自己技术和平台的无人车技术企业。 腾讯：2016年下半年，腾讯成立自动驾驶实验室；现已有入股特斯拉但不参与公司运营、联手四维图新入股地图公司Here，2017年5月与上海国际汽车城签约，将其无人驾驶汽车路测项目组落户上海；
阿里：阿里正在与中国兵器工业集团公司共同推进中国自行研制的全球卫星导航系统——北斗卫星导航系统在民用化市场的落地。在投资汽车方面，阿里在2017年4月携手上汽推出首款互联网汽车，这是继阿里巴巴去年宣布设立10亿元的“互联网汽车基金”以来做出的首个成果，也是为未来开发无人驾驶所做的热身运动。华为：2017年，华为发布一份白皮书，详细介绍了电信网络对互联的汽车空间的价值，拿5G作为无人驾驶的敲门砖。涉及的领域包括智能停车，车队管理，与车载娱乐有关的数据，基于LTE的紧急服务等。报告还显示，截至2017年2月，该公司已经组建了无人驾驶研发团队，拥有超过200名开发者。在2017年巴塞罗那移动世界大会上，华为与沃达丰合作展示了其最新的创新成果，其中包括用于连接Cellular V2X（C-V2X）汽车的蜂窝技术。传统汽车公司：广汽、北汽等都在积极部署和研发、争取分得一杯羹。 接着，主要是一些初创公司。与其他创业领域蓬勃井喷的创业公司相比，无人驾驶这一领域的数量可谓寥寥无几，而真正具有核心技术，并拥有一定成熟商业模式的创业公司更是凤毛麟角，而且大多主要都是聚焦于某一细分技术上，举例来说：
蔚来科技：目前最北看好的创业公司，已获D轮融资；景驰科技：原百度高级副总裁王劲所创，已获天使轮；地平线机器人：提供计算机视觉芯片系统和自动驾驶平台研发，已获得B轮融资；纵目科技、驭势科技、天隼图像等：聚焦于计算机视觉领域中辅助驾驶、智能监控或模式识别解决方案；速腾聚创、禾赛科技、北科天绘、北醒光子等：聚焦于各类激光雷达系统；行易道等：聚焦于自动驾驶所用的毫米波雷达解决方案； 其中最受关注、最被看好的初创公司（景驰科技、地平线机器人等）基本都跟百度系（原百度高管或技术负责人）有关。 总的来说，现在资本大量涌入自动驾驶领域，正处于群雄逐鹿的时代，风起云涌。至于实力强弱，可参考如下两个报告，评比角度不同，结果也是很不一致：
市场研究机构Navigant发布的最新报告中，列出了18家未来10年内最有可能把L2、L3、L4级别自动驾驶汽车带进消费市场的18家公司，还根据技术、市场战略、生产实力、耐力、销售，营销和分销等9个不同维度对各公司的自动驾驶进展打分排名。其中，福特、通用（GM）、尼桑、戴姆勒位于第一梯队，而常被我们提起的Google Waymo、Tesla与宝马等一并分布在第二梯队，百度、Uber、nuTomy等位于第三梯度。美国科技媒体The Information调研结果，主要根据技术、工程、商业模式对当今主要的17家发展L4级别及以上无人驾驶技术的公司进行了一次综合评估和排名，Google Waymo排名第一，Uber第二，戴姆勒、特斯拉nuTonomy、百度、通用等普遍靠前。 1.3 市场分析 这里就拿数据说话：
报告|2017-2021年中国互联网+汽车行业发展前景预测及投资分析报告|奔向2021：自动驾驶汽车发展现状和重要的行业驱动者报告|2017年上半年全球无人驾驶投融资最全盘点报告|2016年智能网联汽车报告：自动驾驶汽车的机遇、风险和动荡并存付费报告|2015-2021年中国无人驾驶汽车市场分析及投资策略研究报告 据《财富》网站报道，英特尔和市场研究公司Strategy Analytics联合开展的一项最新研究表明，2035年无人驾驶汽车将创造达8000亿美元的市场规模，到2050年，与无人驾驶汽车相关的经济活动规模将达7万亿美元，包括无人驾驶汽车提供的打车服务规模将达到约4万亿美元，无人驾驶汽车提供的快递和商业物流服务规模将达到约3万亿美元。
根据麦肯锡预测：到2025年，无人驾驶汽车可以产生2000亿~1.9万亿美元的产值。
据另一家全球分析机构IHS Research分析：全球无人驾驶量产汽车将在2025年上市，估计销量可达23万辆；到2035年，无人驾驶汽车年销量将达到1180万辆，约占总销量的10%；2035年无人驾驶汽车在北美市场份额可以达到29%，中国无人驾驶汽车市场份额为24%，欧洲市场份额为20%。
从上述材料可以直观地了解到，自动驾驶未来市场空间巨大，投资界、产业界都普遍看好，下面从需求角度再来说说：
个体需求：开车本质上是一个需要保持长久视觉分析和肌肉反应的机械重复运动——这并非是人类的长处也往往不是人类所喜欢做的事情，而这恰恰是机器所擅长的。市场需求：自动驾驶不仅可以应用于交通出行，而且对于物流运输、城市规划等都将产生根本性的革新。资本需求：目前已有大量资本流入自动驾驶涉及的大数据、新型传感器、深度学习技术、全套解决方案等，资本的流动往往是行业发展最关键的催化剂，有投入就会要求回报，资本拥有者、想赚钱的各大公司必定会竭尽全力推动无人驾驶的尽早到来。社会需求：从现阶段美国、德国、中国等各个国家针对自动驾驶的政策来看，社会需求强烈，国家重视度也极高。 有报告称，如果自动驾驶汽车得到普及，美国每年可避免超过3万人死于交通事故，节约多达40%的出行时间成本，可节省因拥堵而浪费的800亿小时，并减少40%的燃油消耗。 1.4 应用场景 根据应用场景的不同，自动驾驶系统可分为高速自动驾驶和低速自动驾驶（速度低于20km/h），后者实现难度要低很多。 现有看好的主要业务模式有产品输出（与汽车厂商或一级供应商合作，将自有产品植入到汽车的前装序列，或者制作特定形状的自动驾驶机器）、技术输出(汽车厂商或一级供应商合作，提供软硬件解决方案)、物流合作等。 高速自动驾驶，个人项目中无法企及，这里就针对低速自动驾驶来谈谈其主要应用场景： 1. **物流场景**：高速无人驾驶为城际物流运输车队提供自动驾驶技术，低速无人驾驶可解决末端物流（即最后3km），结合自动存货机，实现无人配送； 2. **移动广告平台**：低速无人驾驶可实现不知疲倦无须人工成本的移动商业广告； 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17f2c2c5128ad11a93bd5d3877ea3233/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c6a74e26e4ba8e01c9a160751a9c9c9/" rel="bookmark">
			extract-text-webpack-plugin配置出错的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Webpack集成extract-text-webpack-plugin中，总提示无法找到正确的loader，如下：
Module build failed: ModuleParseError: Module parse failed: Unexpected token (1:0) You may need an appropriate loader to handle this file type. ERROR in ./styles/header.css Module parse failed: Unexpected character '@' (1:0) You may need an appropriate loader to handle this file type. 开始以为是引用的问题，按照提示将代码
import 'styles/header.css' 改为
import 'css!styles/header.css' 或者
import 'css-loader!styles/header.css' 或者
require('css-loader!styles/header.css') 但错误依旧，翻阅官方文档，发现配置已经不是用“!”连接，而是多了fallback，于是按照官方示例进行更改：
{ test: /\.css$/, loader: ExtractTextPlugin.extract({ fallback: 'style-loader', use: ['css-loader'] }) }, { test: /\.less$/, loader: ExtractTextPlugin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c6a74e26e4ba8e01c9a160751a9c9c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/922ccccd7f3eba7566bfe5f59e3009a3/" rel="bookmark">
			centos7.3删除网桥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 brctl show #查看网桥状态 brctl delif &lt;网桥名&gt; &lt;端口名&gt; #卸载网桥上的端口 ifconfig #查看是否有网桥网卡名 ifconfig &lt;网桥名&gt; down #关闭此网卡 brctl delbr &lt;网桥名&gt; #删除网桥 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aabec9b21db8dafa69d6174900a0dec5/" rel="bookmark">
			集成学习基本原理：Adaboost，Bagging和Stacking
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集成学习的基本原理是，训练多个“个体学习器”或者叫基分类器，基学习器。然后用某种策略将它们结合起来，最后可以产生比单一学习器优越得多的性能。 集成学习的基本原理是什么呢？假设对于每个基分类器，错误率有： P(hi(x)≠f(x))=ϵ 并且 假设分类器之间之互相独立的，那么最终的错误率为： P(H(x)≠f(x))≤exp(−12T(1−2ϵ)2) 可以看到当错误率 ϵ&gt;0.5 随着个体分类器数目 T 的增大,最终的错误率会趋向于0。我们把分类正确率稍大于0.5，也就是比瞎猜好一点的分类器称为弱分类器。按照上面的分析，只要基分类器不比弱分类器差，最终我们的集成的结果都可以任意好！ 但是上面有一个非常重要的假设条件，各个分类器之间需要相互独立，但是实际中基分类器都是由同一个数据集中训练出来的，不可能完全独立，所以如何从一个数据集中训练出来具有“多样性”的基学习器是非常重要的，但是其实多样性和准确性是相互矛盾的。 按照基学习器的生成方式，目前的集成学习的方法分成两大类。一种是学习器之间是串行生成的，学习器互相之间有很强的依赖性，代表算法是Boosting。另一种是并行生成的学习器，学习器之间相关关系不大，代表算法是Bagging 和Random Forest(随机森林)。 下面介绍这两类算法
Boosting 首先介绍两个概念 “强可学习”：一个类，如果存在一个多项式的学习算法能够学习它，并且正确率很高，那么就称这个类是强可学习的。 “弱可学习”：一个类，如果存在一个多项式的学习算法能够学习它，但是正确率仅仅比随机猜测要好，那么就称这个类是弱可学习的。
那么问题来了，如果我们有了一个弱可学习的算法，如何把它提升成为一个强可学习的算法？这就是下面将要介绍的提升（boost）算法，代表算法是AdaBoost算法。
提升算法的基本原理是，开始的时候，我们给数据集所有数据以相同的权重。然后首先我们有一个弱分类器，分类之后，我们对分类错误的数据以更高的权重，这就产生了一个新的样本分布，在此基础上我们再生成一个基分类器，再重复以上步骤，直到分类器个数达到要求。之后把所有的分类器按照权重相加（这个权重在每一步单独计算），就得到最终的分类器。看不懂没关系，我理解的AdaBoost的基本原理就是，每训练一个基学习器都要对之前没有分类好的数据进行修正，最终达到我们的要求。 下面是AdaBoost的算法的描述
再仔细描述一下上面的步骤： （1） 先初始化所有点的权值分布 D1=(w11,⋯,w1i,⋯,w1m),w1i=1m,i=1,2,⋯,m 注意这里的花写的D代表的是数据点的权重分布，脚标1代表第一次初始化得来的分布，这一点不要忘记，否则后面的证明等很容易糊涂。 （2）进入循环，不断执行以下四步，对于第t次循环 （a）根据具有权重分布 Dt 的数据集 D ，训练得到一个基学习器ht （b）计算分类器 ht 在训练数据集上的分类误差率 ϵt=P(ht(xi)≠yi)=∑i=1mwtiI(ht(xi)≠yi) 注意这里面的求和的式子里是加权的，这里也体现出了权重的作用，如果一个点的权重较大，那么他一旦分错，对总的误差率影响也较大。 （c）计算 ht(x) 的系数 αt=12ln1−ϵtϵt 注意这里的系数是分类器的系数，最后按照系数将所有分类器相加的到最后的分类器 （d）更新数据集的权重分布 Dt+1=(wt+1,1,⋯,wt+1,i,⋯,wt+1,m) wt+1,i=wtiZtexp(−αtyiht(xi)),i=1,2,⋯,m Zt 是一个规范化因子，使得 Dt+1 成为一个概率分布。在上一步中预测错误的点 yiht(xi)=−1 （因为是二分类，两个取值为1或者-1），这一次更新之后权重会增加。 （3）当循环结束后，我们把所有基分类器按照系数相加，得到 f(x)=∑t=1mαtht(x) 那么最终的分类器 H(x)=sign(f(x))=sign(∑t=1mαtht(x)) 下面证明一下AdaBoost，主要是证明 αt 和 D 的更新是怎么来的，不感兴趣的可以跳过
AdaBoost 证明 1. 当基分类器 ht(x) 基于权重分布 D 产生之后，我们要生成 ht 的权重 αt ，而 α 应该最小化 αtht 的指数损失函数（下面公式里面的 f(x) 代表的是数据集上的数据的类，这点要记住，不然容易糊涂） ℓexp(αtht|Dt)=Ex∼Dt[e−f(x)αtht(x)] =e−αtPx∼Dt(f(x)=ht(x))+eαtPx∼Dt(f(x)≠ht(x)) 注意上面这一步是把输出和预测值相等和不相等两种情况拆开来写的。然后令 ϵt=Px∼Dt(f(x)≠ht(x)) ,注意这里不是简单的错误率，注意脚标就知道，是将预测错误的数据点的权重相加。下面我们就可以得到上式等于： =e−αt(1−ϵt)+eαtϵt 指数损失函数是在AdaBoost中默认使用的损失函数，具体因为什么，我也不知道了。 可以看到指数损失函数是单调递增的凸函数，求它的极值点就能够得到最值点。我们对指数损失函数求导，可以得到 ∂ℓexp(αtht|Dt)∂αt=−e−αt(1−ϵt)+eαtϵt 再令上式为0，可以得到 αt=12ln(1−ϵtϵt) 而这个正好就是上面的对 αt 的更新公式。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aabec9b21db8dafa69d6174900a0dec5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bf94a6b787de95a91e70291f8549db/" rel="bookmark">
			IDEA下安装JRebel详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用JRebel最好注册一个账号。注册网址https://my.jrebel.com IDEA下安装步骤： File → Settings → plugins注意此方法是在线安装。如果是本地安装需要提前下载好放到硬盘，然后选择Install pligin from disk 。 选择在线安装后，出现如图下所示，在搜索框中输入JRebel进行查找。 这里需要注意的是，如果不是Android开发的话选JRebel for IntelliJ。然后点击Install进行安装，安装后需要重启IDEA,方可生效。 这里是我安装好的。 重启之后，Help → JRebel. 访问JRebel官网:https://my.jrebel.com。 如果你有Facebook或者Twitter账号的话最好先登录一下，这样直接点击就可以关联生效了。登录完Twitter之后，在JRebel官网上点开Twitter完成登录授权。完成一系列的信息（主要是邮箱账号，其他姓名公司都可以瞎填，电话号码也不需要发送验证码，所以也可以瞎填），填写后会发送一份邮件到你注册的邮箱。注意查收，如果没收到也可能被自动放到邮箱垃圾箱里了。 点开邮箱发型果然立马收到了链接 -点开链接之后，进入到激活页面。注意是电话号码，经我验证不需要发送验证码，所以不需要填写真实手机号。到了Install and Activate就会给出激活码了。 复制方框中的激活码。 填入到IDEA里面(Activation)。 激活成功后如图所示。成功后会挑战到链接https://zeroturnaround.com/software/jrebel/quickstart/intellij/?run=ide#!/project-configuration这是JRebel的使用教程。调出JRebel工具栏，并把项目纳入管理： Activation code: u847AuD0FNCtmyy8/aA6O8kHdS7s741UGVN0U1crcbBwg8Wz7Nm584omd34CN6ucsjc7YiquaX5JnyBC9DQYR+XsH+F02i+g4cD09EnDsOGW6KV3MtqdtJkID7J6EAqfquL5zg== 如果研究技术可以加群：569332087 二维码： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65926191e185898d2b02b0f43f854fab/" rel="bookmark">
			MFC 控件添加热键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自https://www.cnblogs.com/hungryvampire/p/5297927.htmlMFC 控件添加热键 2014-12-24 14:28:47标签：C++ MFC 控件 热键使用 给MFC中的控件添加我们想要的控件热键，在动手之前，必须清楚，热键分为local的和global的， 其中local的职能在当前程序有焦点（被激活）时有效，而global的，则无论什么时候都有效，测试local的要优先于global的，就是如果当前激活窗口的快捷键与未激活窗口的快捷键重叠，当前激活窗口优先响应。另外还包括menu，button。 自然而然，创建热键的方法也有多种，不同的创建方法创建的热键作用范围不一定相同。应该根据需求合理的选择自己的方法。方法一： 打开对话框资源，选择指定控件的属性--&gt;在caption项中你定义的名字后添加（&amp;Y）。这样就可以实现热键。其中Y表示你要制定的快捷按键，我选的是Y，按下ALT+Y即可执行这个控件。 该方式热键只有当FOCUS在控件上时才起作用，算是局部热键。方法二：1. 在资源视图中添加资源，选择"Accelerator"选项新建即可；2. 打开新建的文件夹下的"IDR_ACCELERATOR1"中编辑，其中包括ID、修饰符、键、类型。ID中选择你要添加快捷键的菜单、按钮的ID编号，修饰符中选择你是否要使用组合键，如：Alt、Alt+Shift等等，键中选择你要使用什么样的虚拟键码，类型中选择VK形式或者是ASCII形式。3. 在你的对话框的头文件中添加快捷键变量，如HACCEL m_hAcc；4. 在你的对话框的源文件的OnInitDialog函数中加载快捷键，如：1 HACCEL m_hAcc=LoadAccelerators(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_ACCELERATOR1)); 5. 重载函数PreTranslateMessage，使用类向导，重载虚函数PreTranslateMessage，如：12345678910 BOOL CVideoMonitorDlg::PreTranslateMessage(MSG* pMsg) { if (WM_KEYFIRST&lt;=pMsg-&gt;message&amp;&amp;pMsg-&gt;message&lt;= WM_KEYLAST) { HACCEL hAccel=m_hAcc; if (hAccel &amp;&amp; ::TranslateAccelerator(m_hWnd, hAccel, pMsg)) return TRUE; } return CDialogEx::PreTranslateMessage(pMsg); } 6. 通过以上5个步骤基本上即可对工程中的菜单或者按钮添加热键。方法三：使用WM_HOTKEY。在对话框头文件中：12 afx_msg LRESULT OnHotKey(WPARAM wParam,LPARAM lParam); afx_msg void OnDestroy(); 在对话框CPP文件中：1234 BEGIN_MESSAGE_MAP(CYourDlg, CDialog) ON_MESSAGE(WM_HOTKEY,OnHotKey) ON_WM_DESTROY() END_MESSAGE_MAP() hotkey对应映射：1234567 LRESULT CYourDlg::OnHotKey(WPARAM wParam,LPARAM lParam) { if（wParam==IDC_XXX） OnYourFunction(); //ToDo: add function return 0; } 注册热键：1234 BOOL CYourDlg::OnInitDialog() { ::RegisterHotKey(GetSafeHwnd(), IDC_XXX, MOD_ALT, 'D');//注册热键alt+D（D必须大写） } 记得销毁：1234 void CYourDlg::OnDestroy() { ::UnregisterHotKey(GetSafeHwnd(),IDC_XXX);//销毁热键 } 另外一篇参考：http://lty2154216.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65926191e185898d2b02b0f43f854fab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62b9c73f44459c34d2c7b942a0bae1ca/" rel="bookmark">
			画图网页http://weavesilk.com/
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		画图网页
http://weavesilk.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576615ccffd8bf3620ee3b6904628745/" rel="bookmark">
			《Cascaded Pyramid Network for Multi-Person Pose Estimation》--旷世2017COCO keypoints冠军论文解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简介 《Cascaded Pyramid Network for Multi-Person Pose Estimation》，这是Face++旷世科技2017年取得COCO Keypoints Challenge冠军的文章，主要目的是解决 in the wild 场景下多人的姿态估计，即关键点回归。 这里对这篇文章做一个简单的总结，如有理解不对的地方，欢迎指正！！ 文章的主要贡献是：重点内容 1 提出了一种金字塔型的串接模型，即CPN（cascaded pyramid network），这个模型能够同时兼顾人体关节点的局部信息以及全局信息，结果取得了不错的效果;
2 使用了在线难例挖掘（online hard keypoints mining）的技术，这对于人体姿态估计任务中一些存在遮挡的“hard”的关键点的预测有所帮助；
3 测试阶段考量了soft-NMS和传统的hard-NMS（非极大值抑制）在human detection阶段产生的影响，结论是soft-NMS对于最后的结果是有所帮助的。 方法 pipeline 首先，整体的方法仍然是一个传统的top-down的pipeline，即现在图片中检测到人体，再做一个单人的human pose estimation。 motivation 下面这张图阐述了作者的网络设计思路，即一些比较容易识别出来的人体关键点，直接利用一个CNN模型就可以回归得到；而对于一些遮挡比较严重的关节点，则需要增大局部区域感受野以及结合上下文信息才能够进一步refine得到。 网络结构 Figure1给出的就是作者提出的CPN模型网络结构。 可以看到，整个模型由两部分构成，GlobalNet和RefineNet。 GlobalNet的作用就是简单的前向CNN组成的回归模型，目的是回归得到一些易于识别的人体关键点位置，这里作者是使用的ResNet的网络架构回归heatmap。 RefineNet的目的则是利用GlobalNet产生的金字塔模型的特征图，融合多个感受野信息，最后concatenate所有的同一尺寸特征图进一步回归一些有歧义的关键点位置。注意，这里作者使用的是concatenate的策略，而并不是像Stacked Hourglass Networks那样的简单的upsampling。 实验 针对上面所提到的三个贡献，作者通过下面几个实验进行了证明： 首先针对human detection阶段NMS的策略，结论毫无疑问的是Soft-NMS（关于soft-NMS，这是目标检测领域提出来的一个策略，具体可以参考原文）更好，下面的表是几个不同阈值的NMS和Soft-NMS的结果比较。
对于在线难例挖掘策略的使用，主要体现在RefineNet究竟需要对多少个关键点进行Refine，根据COCO keypoints人体标注的关键点数量（17个）作者做了下面的一个实验：
可以看到，对于“Hard”的关键点的定义，在M=8的时候是比较好的，这可以理解为当M增大时一些之前GlobalNet已经预测得到非常好的关键点反而被RefineNet加上了人工干扰。
接下来，对于两个子网络的训练，是否使用在线难例挖掘，作者也做了实验：
可以看到当RefineNet加上在线难例挖掘之后取得的效果是最好的，这也证明了这个措施的有效性，至于为什么最后两行GlobalNet加上在线难例挖掘之后结果反而下降了，大概是这个阶段的网络效果受限于感受野尺寸，即预测不准的点loss加大惩罚之后还是预测不准，也就没有什么用处了。 最后，当然就是这个方法在COCO关键点挑战赛上面的表现了：
72.1的准确率，比第二名高了0.7个点。
总的说来，这篇文章的设计思路是比较巧妙的，用人体关键点中存在的一些遮挡严重的情况作为切入点，设计了拥有两个子网络构成的CPN模型，这对于其他的一些CV任务也有一定的参考意义。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/323f5df23040585851e38eed802c23e9/" rel="bookmark">
			各种数据类型的随机数生成器 -- Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于比较简单，直接看代码吧
public class RandomDataGenerator { public static long getInteger(long minValue, long maxValue) { return (long)(Math.random() * (maxValue - minValue + 1)) + minValue; } public static String getDouble(int exponent, int precision) { StringBuilder sb = new StringBuilder(); sb.append((Math.random() &lt; 0.5 ? "+" : "-")); sb.append((int)(Math.random() * 10) + "."); precision = (int)(Math.random() * precision); for (int i = 0; i &lt; precision; i++) sb.append((int)(Math.random() * 10)); sb.append("e" + (Math.random() &lt; 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/323f5df23040585851e38eed802c23e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bba4a1ad101b215769f52bdb805ab1a3/" rel="bookmark">
			mysql大量数据迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/blakefez/article/details/51076588
最近有个需求，要把机器a上的一个数据库迁移到机器b上，这个数据库的数据有100多个G。所以，果断抛弃用mysqldump的方法来迁移。这时候想到的就是直接复制文件来做迁移。 于是我按照网上的说法，步骤如下： 一、把机器b的mysql停掉。 二、把机器a上要迁移的库的整个目录复制到机器b的mysql data目录下。 三、修改目录权限为700，修改文件权限为660，并修改他们的所属用户和所属组为mysql。 四、再启动机器b的mysql。 操作完成后，我进入机器b的mysql，此时，执行show databases可以看到要迁移的数据库。然后执行use databasename,再执行show tables，也可以看到所有的表。但是问题来了，我执行select * from table limit 10，这时候却报错了，提示表不存在。 所以，我们大致可以指定mysql的工作机制，show databases和show tables时，mysql其实是去目录下扫描，但执行select这些操作的时候，mysql优化器会去information_schema.TABLES 这个表里面获取信息。由于我们是直接复制文件过去，所以，这个表里面是没有信息的，所以就会提示表不存在。 知道了这点之后，我修改了上述步骤： 一、在机器b上，创建需要的database 二、在该database建好所有的表。 三、把机器b的mysql停掉。 四、到机器b上，刚才建的那个数据库的目录下，把所有的(.ibd)文件删除掉。 五、把机器a上，对应数据库目录下所有的(.ibd)文件复制到机器b上，修改文件的权限。 六、启动机器b的mysql。 这时候再连接上b的mysql，就可以看到所有的数据了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05718a774067911315e75d3b73b36c81/" rel="bookmark">
			数据挖掘学习------------------1-数据准备-４-主成分分析（PCA）降维和相关系数降维
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		１.４数据降维 在分析多个变量时发现它们中有一定的相关性。有一种方法将多个变量综合成少数几个相互无关的代表性变量来代替原来的变量，这就是数据降维，可以考虑主成分分析法。
1)、主成分分析法（PCA） 1、基本思想 （1）如果将选取的第一个线性组合即第一个综合变量记为F1，自然希望它竟可能多的反映原来的变量信息。（这里的“信息”用方差来测量，即希望Var（F1）方差函数越大，表示F1包含的信息愈多），因此在所有的线性组合中所选取的F1应该是方差最大的，故称F1为第一主成分。 （2）如果第一主成分不足以代表原来P个变量的信息，在考虑选取F2（即第二个线性组合）,为了有效的反映原来的信息，F1已有的信息就不需要出现在F2中（即用数学表达式Cov函数为统计学协方差：Cov（F1 , F2）=0），称F2为第二主成分。
（3）以此类推可以构造第三、第四。。。。。第p个主成分。
2、PCA步骤 观测数据矩阵：
（1）、对原始数据进行标准化处理。
变量：i：矩阵的行，j：矩阵的列；~X j：表示 j 列的均值（期望）var（）函数：方差
（2）、计算样本相关系数矩阵。
（3）、计算相关系数矩阵R的特征值和相应的特征变量。
这里不在论述，不懂得看看线性代数，这里有matlab的
（4）、选着重要的成分，并写出主成分表达式。
①主成分分析可以得到P个主成分。但是，由于各个主成分的方差是递减的，包含的信息量也是减少的，所以实际分析时，一般不是选取P个主成分，而是根据各个主成分累计贡献率的大小选取前K个主成分。但要要求累计贡献率达到85%以上，这样才能保证综合变量包括原始变量的绝大多数信息。
②贡献率：某个主成分的方差占全部方差的比重，即某个特征值占全部特征值合计的比重。
③接下来要进行综合变量（即主成分变量）在一起应赋予怎样的实际含意解释，这要结合具体的实际问题和专业给出合理的解释，进而才能达到深刻分析的目的。
④一般而言，这个解释是根据主成分表达式的系数结合定性分析来进行的。
⑤主成分是原本变量的线性组合，在这个线性组合中各变量的系数有大有小，有正有负，有的大小相当，因而不能简单地认为这个主成分是某个变量的的属性的作用。
⑥线性组合中各变量的绝对值大者表明该主成分主要综合了绝对值大的变量，有几个变量系数大小相当时，应该认为这一主成分是这几个变量的总和。
（5）、计算主成分得分。
根据标准化的原始数据，按着这个样品，分别代入主成分表达式，就可以得到各主成分下的各个样品的新数据（即主成分得分）。
（6）、依据主成分得分的数据，进一步对问题进行后续的分析和建模。
后续的分析和建模常见的形式：主成分回归，变量子集合的选择，综合评价等。
3、PCA实例 由上图可知：15个企业进行综合实例排序。这里有8个指标，但是他们间的关联关系并不是太明确，且各指标数值的数量级也有差异，为此这里首先借助PCA方法对指标体系进行降维处理。然后根据PCA打分结果实现对企业的综合实例排序。
这里是用matlab进行编码的
（1）数据导入及处理
程序：
参数：xlsread（）：将表格导入并赋值给A
（2）数据标准化处理
程序：
参数：A：矩阵，a：矩阵的行数，b：矩阵列数，SA：标准化后矩阵，mean（）函数：均值函数，std（）函数：方差函数
相关公式：
x*：标准化矩阵，x：原始矩阵，~x j：表示列均值，var（）函数：方差函数
（3）计算相关系数矩阵的特征值和特征向量 程序：
参数：CM：相关系数矩阵，SA：标准化后矩阵，V：相关系数的特征向量，D：相关系数的特征值，corrcoef（）函数：计算相关系数，eig（）函数：计算特征值和特征向量
相关公式：
r：标准化矩阵的相关系数，cov（）函数：协方差函数，var（）函数：方差
（4）计算主成分
①计算贡献率和累计贡献率
程序：
参数：b：矩阵列数，D：相关系数的特征值，DS：关于特征值、贡献率和累计贡献率的矩阵，sum（）函数：求和函数
相关公式：， 累计贡献率G(m) 参数λ：为相关系数的特征值
结果：DS第一列为特征值，并且排过序，第二列为贡献率，第三列为累计贡献率
②选择的主成分以及对应的的特征向量
程序：
参数：T：主成分保留率，b：标准化矩阵的列，Com_num：选取的主成分数量；V：相关系数矩阵的的特征向量；PV：选取的主成分对应的特征向量
结果：
（5）计算各评价对象的主成分得分
程序：
参数：new_score ：选取的主成分得分矩阵，SA：标准化之后的X矩阵 ，PV：选取的主成分对应的特征向量，total_score：选取的主成分的和以及企业编号，result_report：选取的主成分和总分以及编号，sum（）函数：求和，sortrows（）函数：排序
相关公式：
F：主成分得分，a：相关系数特征向量，x：标准化矩阵里面的数值
结果：result_report：1,2,3,列是各主成分得分；4列是前三列的和，是各主成分的总分；5列为企业编号
从上面报告可知，第9综合实例最强，第12最弱
2）、相关系数降维 定义：X，Y 为两组观测数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05718a774067911315e75d3b73b36c81/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/443/">«</a>
	<span class="pagination__item pagination__item--current">444/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/445/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>