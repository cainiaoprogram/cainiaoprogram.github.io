<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e54e8404f6b7c6706f96ddb5c72a71f/" rel="bookmark">
			一图看懂阿里云突发性能实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在阿里云的突发性能实例t5上测试Redis的安装编译，因CPU消耗较大，超出CPU基准性能20%，故耗用CPU积分。任务完成，CPU空闲，CPU积分逐渐积累增加至最大累计积分288分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6311e04b0bd0e14724275f8aa0d82c9e/" rel="bookmark">
			Qt之输入控件（QTextEdit）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述 QTextEdit类提供了一个控件，用于编辑和显示纯文本和富文本。
QTextEdit是一种高级WYSIWYG（所见即所得）查看器/编辑器，支持使用HTML样式标记的富文本格式。它经过优化，可处理大型文档并快速响应用户输入。如果只需要显示一小段富文本，请使用QLabel。
QTextEdit也可以显示图像，列表和表格。
功能描述 QTextEdit适用于段落和字符。段落是经过格式化的字符串，将其自动换行以适合窗口小部件的宽度。默认情下，阅读纯文本时，一个换行符表示一个段落。一个文档包含零个或多个段落。段落中的单词根据段落的对齐方式对齐。段落之间用强行换行符分隔。段落中的每个字符都有其自己的属性，例如字体和颜色。
如果文本太大而无法在文本编辑的视口中查看，则会出现滚动条。文本编辑可以加载纯文本文件和富文本文件。使用HTML 4标记的子集描述富文本，请参阅“支持的HTML子集”页面以获取更多信息。
Qt中的富文本格式支持旨在提供一种快速，可移植且有效的方式，以便为应用程序添加合理的联机帮助功能，并为富文本编辑器提供基础。如果您发现HTML支持不足以满足您的需求，则可以考虑使用Qt WebKit，它提供了功能齐全的Web浏览器小部件。
默认情况下，QTextEdit上鼠标光标的形状为Qt::IBeamCursor。可以通过viewport()的cursor属性进行更改。
基本使用 下面的例子来自Qt官方案例，源码请到官方查看。
常用功能介绍 加载文件 QString fileName = QFileDialog::getOpenFileName(this); QFile file(fileName); if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) return "read failed !!"; QTextStream textStream(&amp;file); textStream.setCodec(codec); QString text = textStream.readAll(); textEdit-&gt;setPlainText(text);//加载html用setHtml QFile类的功能是读取文件，默认情况下，它不会对文件进行任何处理，只负责将文件以二进制的方式读出并存放到一个字节数组中。QTextStream类用来将存储介质中的8位字节数据转换为16位的Unicode字符串。默认情况下，QTextStream假定我们使用系统本地8位编码。可以通过QTextStream::setCodec()来改变解析数据时所采用的编码格式（类unix系统一般采用utf-8编码）。
保存文件 QFileDialog dialog(this); dialog.setWindowModality(Qt::WindowModal); dialog.setAcceptMode(QFileDialog::AcceptSave); if (dialog.exec() != QDialog::Accepted) return false; return saveFile(dialog.selectedFiles().first()); 常见文本属性设置 效果
源码
QPushButton *italicBtn = new QPushButton("斜体"); italicBtn-&gt;setCheckable(true); italicBtn-&gt;setChecked(false); italicBtn-&gt;setStyleSheet("QPushButton {background:transparent;}" "QPushButton:checked {background-color:white}"); QPushButton *boldBtn = new QPushButton("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6311e04b0bd0e14724275f8aa0d82c9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f10529145482961a4b970126508ff0cf/" rel="bookmark">
			php yield运行流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;?php public function y($n) { echo 'start'; for ($i=0;$i&lt;$n;$i++){ yield $i; } echo 'end'; return 'return结果'; } $g = $this-&gt;y(5); //返回Generator实例【因为代码含yield关键词】 foreach ($g as $k=&gt;$v){ //foreach开始执行y()函数，输出start,遇到yield结束 echo $v; //依次输出yield的值0,1,2,3,4,直到for循环结束，输出end } echo $g-&gt;getReturn(); //输出return结果,必须foreach结束后执行，否则报错 //start01234endreturn结果 ?&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d90bbbc10e5a344f2e67c6b4e9498b0/" rel="bookmark">
			java之Vertx.web开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 创建一个基本的web服务并监听8080端口。 //创建核心vertx Vertx vertx = Vertx.vertx(); //创建http的服务器 HttpServer httpServer = vertx.createHttpServer(); httpServer.requestHandler(request-&gt;{ request.response().end("helloworld"); }); //监听端口 httpServer.listen(8080); 启动成功后，访问路由器：http://localhost:8080/
效果图：
2、动态路由，不同的访问给出不同的响应。 public class VertxDynamicResponse { public static void main(String[] args) { //创建vertx Vertx vertx = Vertx.vertx(); //创建http的服务器 HttpServer httpServer = vertx.createHttpServer(); //创建web路由对象 Router router = Router.router(vertx); //当访前端访问，http://8080/aaa时就会触发这个路由 router.get("/aaa").handler(routerContext-&gt;{ //获取request请求对象，前段传递的参数可以使用request.getParam("变量名")获得 HttpServerRequest request = routerContext.request(); //获取response对象 HttpServerResponse response = routerContext.response(); //设置响应编码 response.putHeader("content-type","text/plain; charset=UTF-8"); //给前段的响应内容 response.end("adafa"); }); router.get("/bbb").handler(routerContext-&gt;{ //获取request请求对象，前段传递的参数可以使用request.getParam("变量名")获得 HttpServerRequest request = routerContext.request(); //获取response对象 HttpServerResponse response = routerContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d90bbbc10e5a344f2e67c6b4e9498b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/806d4d9f763d380c6e8b821759fce8dc/" rel="bookmark">
			按字节编址与按字编址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们先从一道简单的问题说起！
设有一个1MB容量的存储器，字长32位，问：按字节编址，字编址的寻址范围以及各自的寻址范围大小? 如果按字节编址，则 1MB = 2^20B （ps：1MB=1024kb，1kb=1024btye，1024是2的10次方）
1字节=1B=8bit 2^20B/1B = 2^20 地址范围为0~(2^20)-1,也就是说需要二十根地址线才能完成对1MB空间的编码，所以地址寄存器为20位,寻址范围大小为2^20=1M
（ps：求出该存储器最多可容纳多少字节，从0到最多可容纳的字节数就是地址范围）
如果按字编址，则
1MB=2^20B
1字=32bit=4B
（ps：字长是32位，就是指1字=32bit，该信息只有在按字编址时才有用。这里的字长说的是存储字长）
2^20B/4B = 2^18 地址范围为0~2^18-1，也就是说我们至少要用18根地址线才能完成对1MB空间的编码。因此按字编址的寻址范围是2^18
以上题目注意几点：
1.区分寻址空间与寻址范围两个不同的概念，寻址范围仅仅是一个数字范围，不带有单位
而寻址范围的大小很明显是一个数，指寻址区间的大小
而寻址空间指能够寻址最大容量，单位一般用MB、B来表示；本题中寻址范围为0~(2^20)-1,寻址空间为1MB。
2.按字节寻址，指的是存储空间的最小编址单位是字节，按字编址，是指存储空间的最小编址单位是字，以上题为例，总的存储器容量是一定的，按字编址和按字节编址所需要的编码数量是不同的，按字编址由于编址单位比较大（1字=32bit=4B），从而编码较少，而按字节编址由于编码单位较小（1字节=1B=8bit），从而编码较多。
3.区别M和MB。
M为数量单位。1024=1K，1024K=1M
MB指容量大小。1024B=1KB，1024KB=1MB.
某机字长为32位,存储容量为64MB,若按字节编址.它的寻址范围是多少?
问题：
某机字长为32位,存储容量为64MB,若按字节编址.它的寻址范围是多少? 问题：
1、某计算机字长为32位,其存储容量为16MB,若按双字编址,它的寻址范围是多少?
2、某机字长为32位,存储容量为64MB,若按字节编址.它的寻址范围是多少?
解答：
我的方法是全部换算成1位2进制的基本单元来算。先计算总容量，如第一题中是16mb中，一B为8位，也就是8个一位基本单元组成，16M=2^24位=2^24个一位基本单元。所以总的基本单元是2^24*8。
一个字长是n位，就是说一个字是由n个一位基本单元组成。按照字来编址就是说由一个字所包含的一位基本单元的个数作为一个地址单元，它对应一个地址。同理，双字编址就是两个字所包含的的基本单元数作为一个地址单元。由于一个字节（1B）永远是8位，所以按字节编址永远是8个一位基本单元作为一个地址单元。寻址范围就是说总共有多少个这样的地址。
第一题中一个字长是32位，对于按字编址来说一个地址单元有32个基本单元，按双字编址则是一个地址单元有64个，按字节是8个，总容量是2^24*8个。所以按字编址的地址数是2^24*8/32个，按双字是2^24*8/64个，按字节是2^24*8/8个。因此，第一题答案是2^21=2M。
同理，第二题答案是2^26*8/8=2^26=64M。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/670f9f628a6bebbd6bb65947c173c3d9/" rel="bookmark">
			elementUI    el-select怎么获取多个属性值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;el-select v-model="Performance" placeholder="请选择" @change="handleChange"&gt;&lt;!--value-key="ddeta"--&gt;
&lt;el-option
v-for="item in dataArr"
:key="item.month"
:label="item.allDay"
:value="{value:item.allDay,label:item.ddeta}" ※※※※※※※※※※※※※※※※※※※※
&gt;&lt;/el-option&gt;
&lt;/el-select&gt;
handleChange(params){
const { value, label } = params;
console.log( value, label );
},
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd953d785f61d2cc56a761ffbbd38ae8/" rel="bookmark">
			数据分析师还是算法工程师｜用数据多角度解读如何选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
疫情即将散去，又到了求职季。学习Python的各位该如何选择自己的职业方向，算法工程师还是数据分析师？跟随本文一起看看吧！
01 数据获取与处理
本次样本数据采集于拉勾网，因为本文的重点是招聘数据分析，而在之前的文章中我们讲解过很多次如何使用requests爬取网页数据，这里就不再赘述，来看下爬取网站部分代码
url_html = 'https://www.lagou.com/jobs/list_' + job_position + '?labelWords=&amp;fromSearch=true&amp;suginput=' params = { 'city': job_address, 'first': 'true' if i == 1 else 'false', 'pn': i, 'kd': job_position} # 创建一个session对象 s = requests.Session() # 发送请求，获得cookies s.get(url_html, headers=headers, data=params, timeout=4) cookie = s.cookies res = s.post(url_request, data=params, headers=headers, cookies=cookie, timeout=4) # 注意分析网页数据获取格式 res.encoding = res.apparent_encoding text = json.loads(res.text) 本文在拉勾网招聘信息中选择北京、上海、广州、深圳、杭州这五个城市下分别以数据分析师、算法工程师为筛选条件来采集样本，采集到的原始数据如下
当然我们在进行数据分析时不需要图中这么多变量，因此对数据进行清洗后最终样本数量为1979条，并选择以下几个变量进行分析
02 薪资水平
我们首先来看下数据分析师与算法工程师的薪资水平密度分布图，绘制出这两个岗位的薪资分布密度图并标记出薪资的均值(图中虚线)👇
图中红色部分为算法工程师的薪资分布密度，蓝色部分为数据分析师的薪资分布密度，可以看出不论是数据分析师还是算法工程师，其薪资水平都是比较高的，但是算法工程师的薪资会更高一点，从两条虚线的位置可以看出算法工程师的平均薪资以29619元超过数据分析师的18841元！值得注意的是这两个岗位薪资均呈现明显的多峰形态，说明存在一类薪资相当可观的精英职位。
03 企业所属行业分析
本节通过制作词云图来对发布招聘企业所属的领域/行业进行分析
上图为我们根据发布招聘信息的企业所属领域/行业的文本信息绘制的词云图，从图中可以看出数据分析师与算法工程师的行业有较大的交叉，主要都属于移动互联网、金融相关企业，但数据分析师的数据服务、电商、消费生活企业更多，而算法工程师的人工智能相关企业占比较高，所以想从事人工智能相关岗位的同学就往算法方向准备吧。
04 学历对的薪资影响
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd953d785f61d2cc56a761ffbbd38ae8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4824e9338d6011a2b5b73f8c122d8783/" rel="bookmark">
			python代码：编写一个可接受任意n个参数（参数为任意数据类型），判断并输出其中包含数字的参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码 import re def text(*acc): for i in acc: if type(i) == int or type(i) == float: print(i) elif type(i) == str: if re.sub("\D", "", i) != "": # 在个字符串中找到非数字的字符（正则表达式中'\D'表示非数字）， # 并用""(空）替换，然后返回的就是只剩下数字的字符串，若此时只剩空，那么就没有数字。 print(i) elif type(i)==list or type(i)==dict or type(i)==set or type(i)==tuple: for a in i: if hit(a)==1: print(i) break#避免多次打印列表 def hit(n): if type(n) == int or type(n) == float: return 1 elif type(n) == str: if re.sub("\D", "", n) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4824e9338d6011a2b5b73f8c122d8783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37d2bb9c349e44da0d744bb6350869e5/" rel="bookmark">
			安装git，解决&#34;git 不是内部或外部命令，也不是可运行的程序&#34;问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 若是为解决：git 不是内部或外部命令，也不是可运行的程序 问题，在文末，点击此处 可快速到达。
官网链接：https://git-scm.com/download/win
Tips：官网下载的速度忒慢，我是右键复制了链接地址，然后好在迅雷上下载的，这样的速度很快。
安装步骤 一路火花带闪电，除了第二步修改了安装目录和第六步修改为命令行环境，其他基本上都是默认操作。
1、 2、 3、 4、 5、 6、 这里进行了修改 ，使用命令行环境
7、 8、 9、 10、 11、 最后验收 鼠标右键屏幕查看，如下截图即安装成功。
大字说明，先别急着就走，要想在cmd环境里使用git，还需配置环境变量，看后面的操作 配置git的Path变量 这里主要是针对解决了如下问题： “git 不是内部或外部命令，也不是可运行的程序”，因为我自己是进了这坑，所以这里提前和大家说好要配置这个Path。
想要在cmd中使用git命令，还需要在Path环境变量中添加以下两个路径，只消要将"自己文件路径"替换一下就行了。
如：D:\Git\bin
自己文件路径\Git\bin 如：D:\Git\mingw64\libexec\git-core
自己文件路径\Git\mingw64\libexec\git-core 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa30280f4c6006fd3640cc76dded9cc2/" rel="bookmark">
			软件工程——背单词软件对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一． 概要介绍 3
《墨墨背单词》 3《百词斩》 4《扇贝单词英语》 6《不背单词》 6
二：优劣对比 7
三． 个人分析 7投资意向 7开发关注点 8开发困难之处 8 一．概要介绍
1.《墨墨背单词》
图 1.1 墨墨背单词logo
(1)简介：一款抗遗忘的背单词软件，通过大量数据加算法等技术，根据不同用户的遗忘曲线来规划每天的学习内容，以此达到高效抗遗忘的策略。
(2)标语：高效抗遗忘，轻松规划海量单词记忆
(3)开发商 ：清远墨墨教育科技有限公司
(4)目标用户：
①　因工作或学习的需要，有不断提升自己的需求和主动学习的意识的人群；
②　记忆力较差，但是并不主动复习单词的用户；
③　准备专业考试正在与纸质书籍配合学习的学生用户。
(5)核心功能
图 1.2 统计
①　调整学习量：通过修改每日的学习量来调整自己每天的学习的压力；
②　设置学习模式：其中包括 “英中模式”“中英模式”，前者快速认知学习，后者深度掌握；
③　自主选词： 可以自主选择当前最新的词典并自主选择当天学习列表的单词，可以灵活选择，或经过词汇排序后选择；
④　复习：学习时每个单词包括认识，模糊，忘记三种形式，根据用户的选择，系统会自主选择复习词汇；
⑤　统计：根据使用软件背单词的情况，对遗忘曲线、学习情况和记忆持久度进行统计；
⑥　签到及回顾：完成当天学习任务后，你可以有奖签到并回顾今日所学。
2.《百词斩》
图 2.1 百词斩 logo
(1)简介：百词斩是一款可离线使用的英语考试大杀器的背单词的学习软件。
(2)开发商：成都超爱学习科技有限公司
(3)目标用户：
①　以图背单词，特别适用于视觉记忆型的学生；
②　喜欢轻松的背单词环境，寓教于乐的学习模式；
(4)核心功能：
图 2.2 图背单词
①　图背单词：利用人类对图像的记忆，一次配一图，加强单词记忆；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa30280f4c6006fd3640cc76dded9cc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1b7152b9680c18ef18dc4decc4d01d1/" rel="bookmark">
			FTP：快速搭建一个ftp服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 到https://www.wftpserver.com/download.htm下载合适的版本
windows版 对于Windows版本，启动安装文件“WingFtpServer”。，并填写所需的选项，以完成安装。
Linux $ tar xzvf wftpserver-linux-64bit.tar.gz $ cd wftpserver $ sudo ./setup.sh Welcome to the Wing FTP Server setup wizard! Please setup administrator account for Wing FTP Server. This account is very important as it will be used to administrate your server. Enter your administrator name: oceanstar Enter your administrator password: 123456 Admin password must have 8 or more characters! Enter your administrator password: 123456789 Please specify a port that web based administration will be listening to.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1b7152b9680c18ef18dc4decc4d01d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddb1fb3794fbf4d51ddfa660b514f247/" rel="bookmark">
			虚拟机黑屏问题的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此处提供的方法主要是网上收集得来，本人一一尝试过，但有时效果并不很好，比较玄学。之后可能会尝试理解其中的原理。
主要“症状”：看不到操作系统安装界面，黑屏；操作系统安装极慢（预计12h这种）；安装好操作系统后，重启，黑屏。
下列方法顺序的排列与新建虚拟机的步骤基本一致。
1，LSP清理 可能有效。在最终试验成功时，已经部署了清理脚本，每次开机启动运行一个.BAT文件，核心命令是netsh winsock reset，需要以管理员身份运行，重启后生效。但可能并不必要。
最终生效时安装的是Ubuntu 18，一开始安装Ubuntu 19的时候也总是出现上述症状，LSP清理的方法时灵时不灵，所以可能并不是主要原因。网上似乎非常推崇这个方法，但我觉得该方法不一定起效。
2，开启VMware的五个服务 Win+R - services.msc打开服务一览表，发现有五个属于VMware的服务，将它们设置成“自动”。
这可能会导致开机变慢，但这很可能是必须的。五个服务分别为VMware Authorization Service, VMware DHCP Service, VMware NAT Service, VMware USB Arbitration Service, VMware Workstation Server。
可能有效。在最终试验成功时，本人打开了这五个服务。
3，启用虚拟打印机 编辑-首选项-设备-虚拟打印机，使用管理员权限启用虚拟打印机。
可能有效。在最终试验成功时，本人启用了虚拟打印机。
3，更换Workstation版本 新建虚拟机时选择自定义，硬件兼容性选择Workstation14.x而不是最新的15.x。
可能无效。在最终试验成功时，本人选择的仍然是最新的15.x。
4，不使用VMware自带的简易安装 之后再添加DVD虚拟硬件，使用需要安装的操作系统镜像.iso文件。
可能有效。在最终试验成功时，本人没有使用简易安装。
5，不使用拆分文件，而使用单个磁盘文件。 可能有效。在最终试验成功时，本人使用的是单个磁盘文件。
2，不使用3D图形加速 虚拟机设置-显示器-3D图形，取消“加速3D图形”的勾选。需要在虚拟机关闭时调整，或在以下界面选择自定义硬件-显示器-3D图形。
可能有效。在最终试验成功时，本人没有勾选“加速3D图形”。
6，更换系统版本！ 亲测有效。原本安装Ubuntu 19的时候一直出问题，老是搞不好，要么安装极慢，要么安装界面不显示（黑屏），要么安装成功，但重启后界面黑屏。更换成Ubuntu 18.04后，一切都干净了，一次成功。
最新版的操作系统、程序、软件补丁乃至游戏、mod之间的相容性可能都会有问题，所以出现各种诡异的情况也很正常。问题是我们可能想不到是版本的问题，很多人的博客里都推崇LSP清理、启用虚拟打印机、取消3D图形加速这三个方法，可能是复制粘贴的。
亲测有效不代表在所有机器上都有效，如果这些方法无效请勿气馁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32a4c016e0870f5389e221add85102fc/" rel="bookmark">
			算法笔记基础（结构体）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结构体练习总结
1.结构体的定义和赋值
#include&lt;stdio.h&gt; struct studentInfo { int id; char gender; char name[20]; char major[20]; // //默认构造体 studentInfo(){} /*写法一 studentInfo(int _id,char _gender) { id = _id; gender = _gender; } */ //写法二 studentInfo(int _id,char _gender):id(_id),gender(_gender){} //利用结构体初始化 }; int main(){ studentInfo Alice;//定义 //对结构体变量进行赋值 Alice.id = 1; Alice.gender = 'M'; studentInfo Bob = studentInfo(10086,'M'); //调用特定初始化函数 printf("Alice:%d %c\n",Alice.id,Alice.gender); printf("Bob:%d %c",Bob.id,Bob.gender); return 0; } 复习gets方法
#include&lt;stdio.h&gt; int main(){ char a[20]; gets(a);//每次输入一行，即识别换行符作为输入的结束 puts(a); char b[5][10];//二维数组存储 m行 n列 for(int i=0;i&lt;3;i++){ gets(b[i]);//输入三行 } for(int i=0;i&lt;3;i++){ puts(b[i]); } return 0; } 对于数组对象的操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32a4c016e0870f5389e221add85102fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6c00f9ed92a2eb7a93b5eb3685d4aa3/" rel="bookmark">
			C# 异步委托 BeginInvoke  EndInvoke
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简单主线程中委托: static void Main(string[] args) { //定义一个委托，并初始化 Func&lt;int, int, string&gt; delFunc = (a, b) =&gt; (a + b).ToString();//黄色底纹部分换成{ return (a + b).ToString(); }更好理解 //同步方法调用（跟调用一个方法一样）,即是主线程执行这个委托 string str = delFunc(1, 2);//以往做法 Console.WriteLine(str); Console.ReadKey(); } 执行结果：
2. 异步委托: static void Main(string[] args) { Console.WriteLine("主线程id："+Thread.CurrentThread.ManagedThreadId); //定义一个委托，并初始化 Func&lt;int, int, string&gt; delFunc = (a, b) =&gt; { //由于下面执行这个委托时使用了BeginInvoke方法，所以就为开启一个新线程去执行，所以称为异步线程 Console.WriteLine("异步线程id：" + Thread.CurrentThread.ManagedThreadId); //Thread.Sleep(3000); return (a + b).ToString(); }; //同步方法调用,即是主线程执行这个委托 //string str = delFunc(1, 2); //BeginInvoke() 方法用于异步委托的执行开始。有返回值，返回值为IAsyncResult，并不是执行委托方法的返回值 //BeginInvoke() 是可以接受多个参数的，它的参数个数和参数类型取决于定义委托时的参数个数和类型，无论它有多少个参数，最后两个参数都是不变的。 倒数第二个参数为回调函数，暂用null， //最后一个参数是给回调函数传入参数的参数，暂用null //IAsyncResult result = delFunc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6c00f9ed92a2eb7a93b5eb3685d4aa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1257e50fb2f7c3df0a532da14713694/" rel="bookmark">
			MTK |Android KK&amp;L 平台TP调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MTK Android KK&amp;L 平台TP调试 一． 简介二． 硬件电路三． 添加TP的简单流程（以GT9XX为例）3.1首先在Projecconfig.mk定义的TP宏控3.2如果是第一次调试，需要在alps\mediatek\custom\common\kernel\touchpanel添加对应的TP驱动代码，3.3根据具体的项目的分辨率和硬件信息，需要在tpd_custom_xx.h中配置宏控。3.4简单介绍一下TP driver文件里面一些需要重点注意的配置 四． TP的测试五． TP需要完善的功能六．Touchpanel的主要参考资料七． 驱动代码流程介绍（以GT9XX为例）八． 对于TP异常的主要调试方法 一． 简介 本文描述了针对touchpanel驱动调试的流程步骤，以及具体的功能代码的讲解。 二． 硬件电路 对于一个TP，主要需要量测以下信号：
VIO28_PMU供电电压，需要在tpd_custom_xx.h里面定义
#define TPD_POWER_SOURCE_CUSTOM XX
CTP_EINT_CTP 中断信号，在开机过程中点击触摸屏，正常会有高低电平变化
CTP_GPIO_CTP_RSTB复位信号，有些TP不需要，在上电过程中有拉高拉低
CTP_SCL_1,CTP_SDA_1 I2C信号，通过抓LOG看i2C的读写是否成功，
必要时需要用示波器抓一下I2C的电平电压和波形，看是否正常
另外需要注意DCT里面的PIN配置
三． 添加TP的简单流程（以GT9XX为例） 3.1首先在Projecconfig.mk定义的TP宏控 CUSTOM_KERNEL_TOUCHPANEL = gt9xx ft5206 //TP型号
MTK_TOUCH_PHYSICAL_ROTATION_RELATIVE_TO_LCM=180
//如果屏幕倒装需要定义180，否则为0(这个宏控在mk文件里面还存在，
但是在72平台最新代码验证了一下不开启180度，TP也是能正常使用的)
3.2如果是第一次调试，需要在alps\mediatek\custom\common\kernel\touchpanel添加对应的TP驱动代码， 如果项目需要特别改动，则在wingcust自己的项目下添加。 一般配置文件tpd_custom_xx.h需要在wingcust自己的项目下面增加。 3.3根据具体的项目的分辨率和硬件信息，需要在tpd_custom_xx.h中配置宏控。 因为每个IC的配置信息都有所不同，不同IC 具体的宏控定义需要在调试时找FAE确认清楚， 下面只介绍一下GT9XX的配置定义：
#define GTP_AUTO_UPDATE 0 //update FW，默认关
#define GTP_FW_DOWNLOAD 0 //update FW to TP SRAM，默认关
GTP_AUTO_UPDATE，GTP_FW_DOWNLOAD这两个宏控同时打开时，
会在开机时把gtp_default_FW[]数组写入TP固件。
如果只打开GTP_AUTO_UPDATE，则会查找T卡路径下的BIN文件，写入TP固件（未验证)
#define TPD_HAVE_BUTTON 1 //有虚拟按键需要在.h开启这个宏控
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1257e50fb2f7c3df0a532da14713694/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87898fff80f82ae4c56ded42eadcaed6/" rel="bookmark">
			sigrity speed 2000的 操作流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sigrity speed 2000的 操作流程
喜欢请关注-头条-海哥前沿技术-一起探讨技术
speed 2000 DDR时域仿真的流程 本流程基于sigrity 2018
打开speed2000 新建 general SI simulation
打开一个PCB文件（brd）或者.spd文件
选择general SI simulation 流程
选择好之后会打钩
设置叠层
GND层和电源层需要为plane， 材质设置为copper和FR4
设置完成之后，点击auto set layer special viod，然后点击OK 退出
先关闭所有网络，然后选择所需仿真的DDR网络和电源网络
并将电源网络赋予电压
将所用的电阻电容赋予模型
添加模型库，路径
D:\cadence\Cadence\Cadence_Sigrity_2018\share\library\decap library\Samsung_MLCC_Capacitors\SamSung_Capacitors
选择所响应参数的物料，然后OK退出
添加完模型后，会显示模型的路径。每个勾选的物料都需要添加相应的模型
添加CPU和DDR的 IBIS 库
并选择相应的型号，点击OK后，
自动生成所有差分对
设置所有的仿真参数，完成后保存文件，并检查是否有报错
完成之后开始仿真
仿真完查看报告
带尺寸的图片: 居中的图片: 居中并且带尺寸的图片: 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。
如何插入一段漂亮的代码片 去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片.
// An highlighted block var foo = 'bar'; 生成一个适合你的列表 项目 项目 项目 项目1项目2项目3 计划任务 完成任务 创建一个表格 一个简单的表格是这么创建的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87898fff80f82ae4c56ded42eadcaed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca23fe68b06f3ba112d87540d69b4bf/" rel="bookmark">
			远程代码注入及DLL注入教程(InlineHook)---植物大战僵尸为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程代码注入及DLL注入教程 说明 ​ 本人刚开始学习逆向，不知道有没有动力学下深去，这一块也没有详细的实战教学，学多少就上传多少，希望能给想学的朋友一点帮助吧，本教程想通过植物大战僵尸这一经典游戏来抛砖引玉，教大家如何编写一个单机辅助。
​ CE找数据的过程本教程不提供，本文着重讲述如何根据找到的数据实现无限阳光，无冷却，其他诸如秒杀僵尸，后台运行等均大同小异。
所需基础 CE找关键数据基址（网上教程很多）、基本汇编命令
涉及工具 VS、CheatEngine（CE，网上很多）、汇编转机器码工具（我在用的https://www.jb51.net/softs/629217.html）、DLL注入工具（网上很多）
开始 无限冷却 ​ 假设第一个植物栏的冷却地址已找到，如图：
此时种下植物后暂停游戏，切到CE，选中冷却地址，右键-找出什么改写了这个地址，然后继续游戏，发现改写的代码：
点击显示汇编代码：
经过分析发现：如果还在冷却，那么在②处判断会跳走，把②处代码nop掉，让代码无论如何也会去Call③，发现植物已经实现无冷却（有很多种方法，比如把①修改为cmp eax,0），那么只需要如下代码即可实现：
BYTE noCD[2] = {0}; memset(noCD, 0x90, 2);//nop硬编码为0x90 WriteProcessMemory(hProcess, (LPVOID)(0x487296), noCD, 2, NULL); 无限阳光 像前面这种替换指令所用空间小于当前代码的方式，实现起来非常简单，但如果替换的汇编指令超过当前代码长度，将会导致后面指令被覆盖，引起崩溃，此时需要用到代码注入。
选中找到的阳光值地址，右键-找出什么访问了这个地址
可以看到有两处频繁访问，我们选择访问次数较少的第二条-显示反汇编程序。
那就在这里注入吧，前面已经知道，阳光值的地址为[[[基址006A9EC0]-&gt;偏移768]-&gt;偏移5560]，所以要注入的汇编代码可以写成：
push eax mov eax,[006A9EC0] mov eax,[eax+768] mov [eax+5560],0xFFF // 0xFFF为阳光值，别太小就行 pop eax mov eax,[esi+00005560] //恢复被覆盖掉的代码 而在注入处发现eax被赋值，所以push eax 及 pop eax可以删掉（实际情况实际分析）。
因此，运行流程为：
代码到达"PlantsVsZombies.exe"+89825（0x489825）处时，JMP到空闲空间，执行我们注入的汇编代码，JMP到"PlantsVsZombies.exe"+8982B处继续向后执行，两种方法的示意图：
远程代码注入 我们需要计算0x489825处 JMP的偏移，推导过程如下：
起跳地址(0x489825) + 5（JMP远跳占用固定5字节，0xE9 + 4字节偏移量） + 偏移量 = 目标地址 因此
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ca23fe68b06f3ba112d87540d69b4bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03abe92b50e9562bb85e203e9746ba88/" rel="bookmark">
			java实现定时备份数据库sql文件，并且通过FTP协议向远程机器发送sql文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数据库备份的类 package com.dbtool; import java.io.*; import java.text.SimpleDateFormat; import java.util.Date; import java.util.TimerTask; /** * 实现数据表的备份 * @author whh * */ public class DataBaseTool{ // 读取配置文件中的信息 // MySql的安装bin目录路径和dump等参数 static String sqlurl = GetProperties.getSqlurl(); // 保存备份文件的路径及名称 static String path = GetProperties.getPath(); static String sqlNum = null; public DataBaseTool() throws IOException { backup(); // 备份数据库 } public static void backup() { try { // 返回与当前的Java应用程序的运行时对象 Runtime rt = Runtime.getRuntime(); // 调用 调用mysql的安装目录的命令 Process child = rt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03abe92b50e9562bb85e203e9746ba88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b36ea52df1500503302e3b102d1f2eb/" rel="bookmark">
			Excel工作表事件（4）- 单元格修订记录跟踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Change事件看起来并不复杂，但是在很多应用场景，都会用到Change事件，并且可以给大家带来很多工作上的便利性。
例如很多用户都希望能够保存单元格内容的修订记录，但是靠人工记录下来这个修改过程，确实有些繁琐，合理使用Change事件，就可以实现这个功能，修订记录保存在单元格批注中。
当前数据表内容如下所示。
现在做如下修改：
Math_05 =&gt; CS_01
Tom =&gt; Jerry
修改后工作表如下图所示，修订记录自动添加到批注中。
示例代码如下。
Private Sub Worksheet_Change(ByVal Target As Range) Dim strCmt As String Application.EnableEvents = False With Target If .Count = 1 Then Application.DisplayAlerts = False On Error Resume Next strCmt = .Comment.Text If Err.Number &gt; 0 Then strCmt = Date &amp; "-" &amp; .Value .AddComment strCmt Else strCmt = strCmt &amp; Chr(10) &amp; Date &amp; "-" &amp; .Value .Comment.Text strCmt End If On Error GoTo 0 Application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b36ea52df1500503302e3b102d1f2eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a4748c3346227b44a61a07f2b55adae/" rel="bookmark">
			Excel工作表事件（3）- Change事件连锁反应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Excel工作表Change事件是最常用的事件代码之一，通俗的讲工作表内容发生变化时，此事件将被激活。这个事件代码貌似很简单，事件被激活后，使用代码想干啥就干啥，然后呢 … 就没有然后了。
先了看一个很常见的需求，在第一行任意单元格输入任意内容后，在该单元格之下记录当前的日期，这个就是典型的Change事件应用，3行代码将搞定。
Private Sub Worksheet_Change(ByVal Target As Range) Target.Offset(1, 0) = Date End Sub 在A1单元格随便输入一个字母，按回车结束输入，启动着B1单元格自动写入当前的日期，结果如何呢？
理想很丰满，现实很骨感。A2单元格确实记录了我们需要的当前日期，可是之下的几十个单元格在搞什么鬼，为什么也都被填充了同样的内容。
我们来分析一下事件代码的执行过程：
A1输入完成后，Change事件（第一次被激活，记作Change_1）被激活，执行第2行代码时修改A2单元格的值此时将Change事件将再次被激活（Change_2），此时Change_1的第3行代码尚未被执行，执行第2行代码时修改A3单元格的值此时将Change事件将再次被激活（Change_3）… 如此继续下去，如果没有任何资源限制，理论上可以将第1列填满，但是实际上只填充到A79之后就结束了，并未给出任何错误（如果哪位高手知道原因，欢迎留言赐教），估计和递归调用的堆栈空间有关。
无论如何，在使用事件代码时，我们肯定不希望这样发生这样的连锁反应，解决方案也很简单，使用如下EnableEvents可以禁用系统事件的激活，注意不影响控件事件的激活，例如工作表中的按钮仍然可以正常响应Click事件。
Private Sub Worksheet_Change(ByVal Target As Range) Application.EnableEvents = False Target.Offset(1, 0) = Date Application.EnableEvents = True End Sub 需要注意在结束事件代码之前一定要恢复系统的事件激活机制，否者工作表内容的变化，将无法再激活事件代码。例如如下代码，只有用户输入的内容是数字，并且大于10的时候，才在其下一行单元格记录日期。
Private Sub Worksheet_Change(ByVal Target As Range) Application.EnableEvents = False If VBA.IsNumeric(Target.Value) And Target.Value &gt; 10 Then Target.Offset(1, 0) = Date Application.EnableEvents = True End If End Sub 如果输入内容不满足条件，那么第5行代码将不会执行，在此之后系统事件将被禁用。正确的事件代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a4748c3346227b44a61a07f2b55adae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ede3913e5fccf42b7e02b99aa0c385ba/" rel="bookmark">
			OpenBmc开发错误5：error: RPC failed; curl 18 transfer closed with outstanding read data remaining
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误提示：
error: RPC failed; curl 18 transfer closed with outstanding read data remaining
fatal: The remote end hung up unexpectedly
fatal: early EOF
fatal: index-pack failed
原因分析：
由于git clone的文件过大传输导致clone失败。
本地git没有配置SSH
解决方法：
方法1、查看log日志，使用log日志中提到的URL进行下载，下载完成后复制到downloads文件夹下，再次执行编译命令即可。（有一些地址可能访问是404，那就没辙啦，只能配置git）
方法2、配置本地git的SSH：请参数ubuntu 安装git并进行配置，配置好后再执行编译命令，可参考do_fetch error配合进行处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/272e3e951337b7177d1588440e0ce55b/" rel="bookmark">
			图像增强与图像恢复的概念比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在对图像进行分析之前，必须要对图像质量进行改善，一般情况下改善的方法有两类：图像增强和图像复原
图像增强不考虑图像质量下降的原因，只将图像中感兴趣的特征有选择的突出，而衰减不需要的特征，它的目的主要是提高图像的可懂度。图像增强的方法分为空域法和频域法两类，空域法主要是对图像中的各个像素点进行操作；而频域法是在图像的某个变换域内，对图像进行操作，修改变换后的系数，例如付立叶变换、DCT变换等的系数，然后再进行反变换得到处理后的图像。
空域法：点处理（图像灰度变换、直方图均衡化、伪彩色处理等）
频域法：高、低通滤波等
图像增强的方法：
灰度变换：
图像的灰度变换，一种稍微复杂一点的方法是直方图均衡化。直方图均衡化是灰度变换的一个重要应用，广泛应用在图像增强处理中，它是以累计分布函数变换为基础的直方图修正法，可以产生一幅灰度级分布具有均匀概率密度的图像，扩展了像素的取值动态范围。
直方图均衡化：
直方图均衡化是将原始图像的直方图变换为均匀分布的形式，从而增加灰度值的动态范围，达到增强图像的目的
图像平滑：
图像平滑主要是为了消除噪声。噪声并不限于人眼所能看的见的失真和变形，有些噪声只有在进行图像处理时才可以发现。图像的常见噪声主要有加性噪声、乘性噪声和量化噪声等。图像中的噪声往往和信号交织在一起，尤其是乘性噪声，如果平滑不当，就会使图像本身的细节如边界轮廓、线条等变的模糊不清，如何既平滑掉噪声有尽量保持图像细节，是图像平滑主要研究的任务。
一般来说，图像的能量主要集中在其低频部分，噪声所在的频段主要在高频段，同时一般我们要提取的图像的边缘信息也主要集中在其高频部分，因此，重要的就是如何去掉高频干扰又同时保持边缘信息。为了去除噪声，有必要对图像进行平滑，可以采用低通滤波的方法去除高频干扰。图像平滑包括空域法和频域法两大类，在空域法中，图像平滑的常用方法是采用均值滤波或中值滤波，对于均值滤波，它是用一个有奇数点的滑动窗口在图像上滑动，将窗口中心点对应的图像像素点的灰度值用窗口内的各个点的灰度值的平均值代替，如果滑动窗口规定了在取均值过程中窗口各个像素点所占的权重，也就是各个像素点的系数，这时候就称为加权均值滤波；对于中值滤波，对应的像素点的灰度值用窗口内的中间值代替。实现均值或中值滤波时，为了简便编程工作，可以定义一个n*n的模板数组。另外，读者需要注意一点，在用窗口扫描图像过程中，对于图像的四个边缘的像素点，可以不处理；也可以用灰度值为"0"的像素点扩展图像的边缘。
图像锐化：
图像平滑往往使图像中的边界、轮廓变的模糊，为了减少这类不利效果的影响，这就需要利用图像鋭化技术，使图像的边缘变的清晰。图像銳化处理的目的是为了使图像的边缘、轮廓线以及图像的细节变的清晰，经过平滑的图像变得模糊的根本原因是因为图像受到了平均或积分运算，因此可以对其进行逆运算（如微分运算）就可以使图像变的清晰。从频率域来考虑，图像模糊的实质是因为其高频分量被衰减，因此可以用高通滤波器来使图像清晰。
锐化的作用是使灰度反差增强，因为边缘和轮廓都位于灰度突变的地方，所以锐化算法的实现是基于微分作用。
图像复原技术与增强技术不同，它需要了解图像质量下降的原因，首先要建立"降质模型"，再利用该模型，恢复原始图像
根据退化原因，图像恢复的方法有：(
图像退化现象：指由场景得到的图像没有完全地反映场景的真实内容而产生的失真问题现象。)
退化原因： 恢复方法：
加性噪声引起 去噪声
系统引起 系统退化逆运算
图像复原是利用退化现象的某种先验知识，建立退化现象的数学模型，再根据模型进行反向的推演运算，以恢复原来的景物图像。因而，图像复原可以理解为图像降质过程的反向过程。建立图像复原的反向过程的数学模型，就是图像复原的主要任务。经过反向过程的数学模型的运算，要想恢复全真的景物图像比较困难。所以， 图像复原本身往往需要有一个质量标准， 即衡量接近全真景物图像的程度，或者说，对原图像的估计是否到达最佳的程度。
由于引起退化的因素众多而且性质不同，为了描述图像退化过程所建立的数学模型往往多种多样，而恢复的质量标准也往往存在差异性，因此图像复原是一个复杂的数学过程，图像复原的方法、技术也各不相同。
图像恢复与图像增强有什么的联系？
图像增强”是一个启发式过程，目的是处理后的图像有利于人眼系统的观察图像内容“图像增强”是一个启发式过程，目的是处理后的图像有利于人眼系统的观察图像内容
（1）相同点：在某种意义上改善给定图像的视觉效果,有部分内容是相通的。
（2）不同点：
a.图像恢复可利用退化现象的某种先验知识（退化模型），把退化的图像加以重建和恢复。这种技术需要弄清楚退化的原因，进行数学建模，再沿着图像降质的逆过程恢复图像。图像增强技术对图像的退化或降质的过程基本上不进行建模，只追求较好的满足需要的视觉效果。
b.图像恢复技术有明确规定的质量标准，这样可以对恢复的图像给出最佳的评估。图像增强技术是一种人的心理接受过程，一般没有客观和统一的评价标准。
c.“图像增强”是一个启发式过程，目的是处理后的图像有利于人眼系统的观察图像内容
“图像恢复”是根据某最优准则，使得恢复后的图像是对理想图像的最佳逼近。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7b33d36fc3298c41aae1596dbc73971/" rel="bookmark">
			【列表综合练习2】Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【列表综合练习2】 写代码，有如下列表，按照要求实现每一个功能。Lis = [9,“hello” , “jack”, [“rose”, 250, [“kdf1”, [“tsfat”, 3, “1”]], 0], “cdfab”, “addgfv”]
（1）将列表Lis中的"d"变成大写。
（2）将列表中的数字3变成字符串"whoo"
（3）将列表中的字符串"tsfat"变成数字 100
（4）在 "rose"前面插入字符串：“movie”
（5）打印列表
Lis = [9,"hello","jack",["rose",250,["kdf1",["tsfat",3,"1"]],0],"cdfab","addgfv"] del Lis[3][2][0] Lis[3][2].insert(0, 'kDf1') del Lis[4] Lis.insert(4, 'cDfab') del Lis[5] Lis.append('aDDgfv') Lis[3][2][1][1] = "whoo" Lis[3][2][1][0] = 100 Lis[3].insert(0,"movie") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ade92ecaf55387aa6d42fdbcf2605e/" rel="bookmark">
			UnicodeEncodeError: &#39;ascii&#39; codec can&#39;t encode characters in position 0-2: ordinal not in range(128)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在linux（ubuntu）下，输出文字时报错UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 0-2: ordinal not in range(128)，经过查找方法1和方法2（方法2需要下载包，有时网络不佳，就选择方法1）都可以，记录备忘。
方法1 使用python命令查看输出内容的编码方式
&gt;&gt;&gt;import sys &gt;&gt;&gt;sys.stdout.encoding 'ANSI_X3.4-1968' # 编码方式是ANSI_X3.4-1968，所以任何中文都会报错。ASCII本来就不包含中文，所以一般发现这种错误就是把ASCII换成utf8 使用PYTHONIOENCODING
运行python的时候加上PYTHONIOENCODING=utf-8，即：
PYTHONIOENCODING=utf-8 python ***.py 方法2
所用的Linux系统不支持中文，遇见输出中文就报错。
安装中文支持包language-pack-zh-hans
sudo apt-get install language-pack-zh-hans 修改/etc/environment（在文件的末尾追加）
LANG="zh_CN.UTF-8" LANGUAGE="zh_CN:zh:en_US:en" 修改/var/lib/locales/supported.d/local(没有这个文件就新建，同样在末尾追加)
en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 zh_CN.GBK GBK zh_CN GB2312 执行命令
sudo locale-gen 对于中文乱码是空格的情况，安装中文字体解决。
sudo apt-get install fonts-droid-fallback ttf-wqy-zenhei ttf-wqy-microhei fonts-arphic-ukai fonts-arphic-uming 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b0140e027ffa887a8b6152359ec936/" rel="bookmark">
			史上最全《计算机网络 自顶向下方法》答案合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 史上最全《计算机网络 自顶向下方法》答案合集 封面： 英文名：Computer Networking: A Top-Down Approach (7th Edition) 答案 第一章 （一） 第一章 （二） 第二章 （一） 第二章 （二） 第三章 （一） 第三章 （二） 第三章 （三） 第四章 第五章 第六章 （一） 第六章 （二） 第七章 第八章 （一） 第八章 （二） 第八章 （三） 第八章 （四） 第八章 （五） 第八章 （重制版） 第九章 感谢疫情期间妻子的支持 附妻子照片
完 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9720ba1b56c2ea152de673c2d0e389d/" rel="bookmark">
			CentOS|Ubuntu软件安装分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码
CentOS|Ubuntu均可支持源码安装，需要手动编译安装，可以指定安装过程及位置
流程大致
1 ./configure (生成makefile)
2 make
3 makeinstall
说明：通过脚本.sh安装也是源码安装
二进制码包
CentOS：RPM包安装
缺点：需要手工解决依赖问题
Ubuntu：.deb文件安装
软件管理系统
CenOS：yum
优点：可以自动解决依赖，且可以进行软件组安装
Ubuntu：apt-get
共同点：两者都需要指定源
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43173c5fb275caef2dd9a3649d90b0d6/" rel="bookmark">
			数据库垂直切分迁移实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://github.com/Elin-Zhou/develop-doc/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9E%82%E7%9B%B4%E5%88%87%E5%88%86%E8%BF%81%E7%A7%BB.md
背景 原来的业务所有数据库都在一个实例上，配置为8C64G 1TB。由于业务快速增长，在业务高峰期时，数据库QPS大约12k+，频繁出现数据库CPU使用率达到100%的情况。
问题分析 短期问题可以通过升级数据库配置解决，但是单机配置有上限，且约往后越不划算，单机的瓶颈会越来越明显，所以需要考虑对数据库进行拆分。
水平拆分OR垂直拆分 一般情况下，考虑数据拆分时，分为水平拆分和垂直拆分两个方向。根据经验，水平拆分适合数据量非常大的单表，而垂直拆分适合多个数据表按业务情况拆分到不同的数据库实例中，所以此处选择垂直拆分。
实现 流程 整体流程参照下图，大致分为五个步骤
数据同步 此处需要DBA配置，创建一个新的数据库实例，并且把需要迁移到新库中的业务表结构与数据进行同步，需要保证旧表与新表的数据是准实时的。一般来说两表的同步时延很短，最多不过几秒钟。
上线/下线路由代码 由于业务逻辑比较简单，此处不引入第三方中间件，通过Sping自带的AbstractRoutingDataSource来实现数据的路由功能，具体实现下文会详细描述。
因为切换的操作是单向的，所以路由功能只需要在操作时使用，如果确定业务正常，则可以下线动态路由功能，改为静态配置选择具体使用的数据源。
路由开关 由于线上机器较多，路由代码上线后不能直接开启，需要有一个开关统一来开启，保证所有机器路由的一致性。
关键点 数据源路由 上文提到，动态路由功能可以通过使用Spring提供的动态数据源来实现，即继承AbstractRoutingDataSource类，实现其determineCurrentLookupKey方法，简单看一下这个方法的签名及注释
/** * Determine the current lookup key. This will typically be * implemented to check a thread-bound transaction context. * &lt;p&gt;Allows for arbitrary keys. The returned key needs * to match the stored lookup key type, as resolved by the * {@link #resolveSpecifiedLookupKey} method. */ protected abstract Object determineCurrentLookupKey(); 在AbstractRoutingDataSource中有一个Map类型的成员变量targetDataSources，其key可以进行自定义，value即为对应的数据源，需要在初始化实例的是往这个map中写入所有动态的数据源，每次有请求数据源的请求时，均会调用determineCurrentLookupKey，需要方法实现中根据情况返回key来选择对应的数据源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43173c5fb275caef2dd9a3649d90b0d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4493ba55671896f18273b4ac41eb719a/" rel="bookmark">
			mysql5.7 索引where和orderby排序问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引(a,b,c)
select * from table where a=1 and b=2 order by a; 索引排序 select * from table where a=1 and b=2 order by b; 索引排序 select * from table where a=1 and b=2 order by c; 索引排序 select * from table where a=1 order by a; 索引排序 select * from table where a=1 order by b; 索引排序 select * from table where a=1 order by c; Using filesort 结论：全等情况下，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4493ba55671896f18273b4ac41eb719a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e598764f75702ae1ff8f77392237ba7/" rel="bookmark">
			Live2D(Cubism3.x)网页看板娘设置（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		教程已经更新，如果你是第一次看这个系列的请移步下方链接 Live2D(WebSDK 4.X)网页看板娘设置（一）
live2d（Web SDK 4.x）Web看板娘进阶
这篇文章的操作内容已经更新到官方最新的SDK，但视频还未及时更新，由于新版与旧版大多是目录结构上的差异，所以影响并不大
上一期主要讲了官方的Demo的修改方法，导入自己的模型文件并导出编译后的js脚本。
但是由于我们用的是官方Demo，人物的交互方式并不符合我们要求，而且页面布局也有问题。
本期就解决部分交互问题和页面布局。
本期所做的修改请一定要使用官方提供的人物模型进行测试
1. Typescript源文件修改 1.1修改过程中涉及的文件（src内的） 文件名作用Demo\src\lappdefine.ts主要用来改变加载的模型文件Demo\src\lappdelegate.ts这个文件我们修改的比较多，将网页的各种事件传递给模型加载器，负责人机交互的功能Demo\src\lappview.ts主要是将鼠标坐标转为模型核心驱动需要的坐标的，也可以对一些事件进行更有针对性的定制 1.2 去掉Demo中不需要的背景图案和切换模型的按钮 demo中的模型占据了整个网页正中央，而且右上角还带有齿轮切换标志，直接作为看板娘是肯定不行的啦，下面来说一下如何去掉背景图片和齿轮图案。我们找到Sample\TypeScript\Demo\src\lappview.ts文件，定位至以下位置，将我们不需要的功能注释掉。
initializeSprite()函数
/** * 执行图像初始化 */ public initializeSprite(): void { let width: number = canvas.width; let height: number = canvas.height; let textureManager = LAppDelegate.getInstance().getTextureManager(); const resourcesPath = LAppDefine.ResourcesPath; let imageName: string = ""; //注释掉所有图片加载方法 /** // 背景画像初期化 imageName = LAppDefine.BackImageName; // 创建回调函数，因为它是异步的 let initBackGroundTexture = (textureInfo: TextureInfo): void =&gt; { let x: number = width * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e598764f75702ae1ff8f77392237ba7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/432b60ef0473591e8607e16fdd890392/" rel="bookmark">
			PointAugment：一种自动增强的点云分类框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PointAugment的点云分类框架，当训练分类网络时，该框架会自动优化和扩充点云样本以丰富数据多样性。与现有的2D图像自动增强方法不同，PointAugment具有样本感知功能，并采用对抗学习策略来共同优化增强器网络和分类网络，学习生成最适合分类器的增强样本。PointAugment根据形状分类器和点位移来构造可学习的点增强函数，并根据分类器的学习进度精心设计损失函数以采用增强样本。PointAugment在改善形状分类和检索中的有效性和鲁棒性得到了实验的验证。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab63bde4f5ef177ae30ee1a8526df169/" rel="bookmark">
			js通过match方法和正则表达式截取某两个字符串中间部分的字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 比如我要从下面base64编码字符串中截取一个文件后缀名，即image/和;之间的字符串，方法如下：
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA......
代码：
let src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA......' let res = src.match(/^data:image\/([a-zA-Z]+);/)[1] console.log(res) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e0df5826b2129887c6835d86f9d24b/" rel="bookmark">
			Vant Uploader 文件上传手机上所遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司H5项目文件上传用到了Vant Uploader文件上传组件，但是这个组件的坑属实是真的多，写这篇文章给大家分享一下，如果问题和我同样的话就不用纠结了，可以直接换组件了~~
问题1：我在谷歌浏览器的模拟器中测试可以，为什么在手机上却没有办法显示，如下图
这个问题总共是有2处坑
关乎公司所购买的服务器，图片上传是经过服务器上传的，如果你们公司购买的服务器很便宜，那么它的传输速度就会很慢，这会导致图片上传以后回显加载的很慢或者是直接不回显。 解决方案：
前端可以在图片上传前压缩图片，这类代码其他博客有很多，随便搜索下就有了，这里顺便也给大家贴出来，这里要注意，如果你使用过这个方法却失败了还是不行，有可能是因为你没有转换文件，与后端所需要的格式不一致，所以会导致失败
//这里是把上传的文件转换 dataURLtoFile(dataurl, filename) { var arr = dataurl.split(","), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) { u8arr[n] = bstr.charCodeAt(n); } return new File([u8arr], filename, { type: mime }); } 然后就是压缩图片大小 if (/\/(?:jpeg|png)/i.test(event.file.type) &amp;&amp; event.file.size &gt; 500000) { // 创建Canvas对象(画布) let canvas = document.createElement("canvas"); // 获取对应的CanvasRenderingContext2D对象(画笔) let context = canvas.getContext("2d"); // 创建新的图片对象 let img = new Image(); // 指定图片的DataURL(图片的base64编码数据) img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72e0df5826b2129887c6835d86f9d24b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57cbc772915e553ab7c02fdd005cba08/" rel="bookmark">
			java基础9——几个重要的API之迭代器Iterator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 体系结构 ---| Itreable 接口 实现该接口可以使用增强for循环
---| Collection 描述所有集合共性的接口
---| List接口 可以有重复元素的集合
---| Set接口 不可以有重复元素的集合
2. 常用API 2.1. Iterator iterator() 返回该集合的迭代器对象
2.2 public interface Iterable&lt;T&gt;
注意：Itreable 该接口仅有一个方法，用于返回集合迭代器对象。
2.3 Iterator接口定义的方法，该接口是集合的迭代器接口类
1：boolean hasNext() 判断集合中是否有元素，如果有元素可以迭代，就返回true。
2： E next() 返回迭代的下一个元素，注意： 如果没有下一个元素时，调用next元素会抛出NoSuchElementException
3： void remove()从迭代器指向的集合中移除迭代器返回的最后一个元素（可选操作）。
3. 迭代器遍历 3.1 while循环 public static void main(String[] args) { ArrayList list = new ArrayList(); // 增加：add() 将指定对象存储到容器中 list.add("计算机网络"); list.add("现代操作系统"); list.add("java编程思想"); list.add("java核心技术"); list.add("java语言程序设计"); System.out.println(list); Iterator it = list.iterator(); while (it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57cbc772915e553ab7c02fdd005cba08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8264c653c051014ed245a854366c294/" rel="bookmark">
			Python时间格式转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、标准库
1、import time
time模块中时间表现的格式主要有三种：
a、timestamp时间戳，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量
b、struct_time时间元组，共有九个元素组。
c、format time 格式化时间，已格式化的结构使时间更具可读性。包括自定义格式和固定格式。
2、import datetime
datatime模块重新封装了time模块，提供更多接口，提供的类有：date,time,datetime,timedelta,tzinfo。
二、格式名称
1、时间格式名称：时间戳
示例：1584039884.0
float格式
2、时间格式名称：结构化时间格式，时间元组
示例：time.struct_time(tm_year=2020, tm_mon=3, tm_mday=13, tm_hour=3, tm_min=9, tm_sec=0, tm_wday=4, tm_yday=73, tm_isdst=0)
获取方式：
# time.time() 得到的是float型时间戳 struct_time = time.localtime(time.time()) # 得到结构化时间格式
3、时间格式名称：format_time
示例：2016-10-26 16:48:41
获取方式：
# 生成format_time #struct_time to format_time time.strftime("%Y-%m-%d %X") time.strftime("%Y-%m-%d %X",time.localtime())
4、时间格式名称：datetime格式
示例：2020-03-13 03:02:13.469749
获取方式：
date_time = datetime.datetime.now() print(date_time)
5、ISO 8601标准（字符串）格林治时间格式
type:str
例如：2018-06-20T02:31:00Z
字母T ==&gt; 代表使用UTC时间结尾；
字母Z ==&gt; 4位数字格式的时间偏移量，不写的时候默认不偏移(当前时区)，为Z的时候表示0时区：
获取方式：
date_time = datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8264c653c051014ed245a854366c294/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66b58c3083c172fa6fbe35fc6d98dc40/" rel="bookmark">
			【Excel2019(十五)：条件格式与公式】【使用简单的条件格式&#43;定义多重条件的条件格式&#43;使用公式定义条件格式】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇：【Excel2019(十四)：日期函数】【认识时间和日期+日期函数+计算日期间隔+星期计算】
文章目录 使用简单的条件格式案例一：标记大于某固定值案例二：标记包含某文本案例三：标记重复值切片器 定义多重条件的条件格式标记错误值 使用公式定义条件格式案例一案例二 使用简单的条件格式 开始-条件格式
案例一：标记大于某固定值 原数据
标记大于1500000的值
数据变格式也会改变
案例二：标记包含某文本 原数据
选中该列，按以下步骤
结果
可以提前设置条件格式，输入数据自动标记
案例三：标记重复值 原数据
步骤
结果
切片器 必须打开xlsx文件
也可以在插入中找到切片器
定义多重条件的条件格式 原数据
从小范围到大范围即可。
结果
标记错误值 原数据
新建规则
结果
使用公式定义条件格式 使用公式一般跟本单元格值无关
案例一 原数据
过程
结果
案例二 原数据
操作
结果
下一篇：【Excel2019(十六)：简单文本函数】【使用文本截取字符串+获取文本中的信息+身份证的应用】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb60f7fe21d2435c581ad7dd5b3cd849/" rel="bookmark">
			zabbix安装及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装官网源
# rpm -Uvh https://repo.zabbix.com/zabbix/4.4/rhel/7/x86_64/zabbix-release-4.4-1.el7.noarch.rpm
# yum clean all
如果速度太慢可选择阿里云源
安装阿里云源
# rpm -ivh https://mirrors.aliyun.com/zabbix/zabbix/4.5/rhel/7/x86_64/zabbix-release-4.5-1.el7.noarch.rpm
# yum clean all
如果还下不来的使用百度云下载（包含数据库及依赖包）
链接：https://pan.baidu.com/s/1W6cc9wfCZUuFODhl06azUg 提取码：6ism
安装下载yum源(解决依赖，以及安装数据库) wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 下载epel源 wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
开始安装
yum install zabbix-server-mysql zabbix-web-mysql zabbix-agent
yum install mariadb mariadb-server
初始化数据库
# mysql -uroot -p
password，空密码
mysql&gt; create database zabbix character set utf8 collate utf8_bin;
mysql&gt; grant all privileges on zabbix.* to zabbix@localhost identified by 'zabbix';
mysql&gt; quit;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb60f7fe21d2435c581ad7dd5b3cd849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7445ba1ebb65e2d28d8ff8e303eca91/" rel="bookmark">
			【论文解读】BERT和ALBERT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.前言2. BERT2.1 引入2.2 以前的工作2.2.1 feature-based 方法2.2.2 fine-tuning 方法2.2.3 迁移学习方法 2.3 BERT架构2.3.1 MLM2.3.2 NSP 2.4 实验2.4.1 BERT模型的效果2.4.2 验证性实验 3.ALBERT3.1 引入3.2 相关工作3.2.1 cross-layer parameter sharing（交叉层的参数共享）3.2.2 sentence-order prediction (SOP，句子顺序预测) 3.3 ALBERT的模型3.3.1 factorized embedding parameterization3.3.2 Cross-layer parameter sharing3.3.3 Inter-sentence coherence loss. 3.4 实验3.4.1 BERT和ALBERT的对比3.4.2 交叉层参数共享实验3.4.2 SOP 4. 参考 1.前言 最近重新阅读了BERT和ALBERT文章，所以写下自己的一些感悟。这两篇文章都是Google发出来的。其中BERT是2018年，在Transformer的基础上进行扩展；而ALBERT发表在2020年ICLR上，它是基础BERT来进行改进。
BERT论文 ALBERT论文 2. BERT BERT全称是Bidirectional Encoder Representations from Transformers，它通过连接从左到右和从右到左的文本，设计了一个预处理的深度双向表达模型。在fine-tuned阶段，只需要增加简单的输出层，就可以在BERT模型基础上达到SOTA的效果。
BERT在GLUE数据集上能够达到80.4%，在MultiNLI上则有86.7%，在SQuAD v1.1则有93.2%。
2.1 引入 在NLP场景中，预处理的模型往往能够提升下游任务的效果。在natural language inference（语言推断）、relation classification、NER和QA任务中，预处理的语言模型都是有效果的。
预处理的语言模型到下游任务中，主要有两种策略方法：
feature-based方法：类似于ELMO那样，设计了一个比较精细的结构，作为额外的特征进行输入。fine-tuning 方法：类似于Transformer和GPT那样的模型，它们可以在下游任务中进行简单的调节参数，使得模型适应于下游任务。 这些方法都是单方向（unidirectional）的语言模型。
BERT引入了两个预处理时的学习目标，包括：Masked language model（MLM）、next sentence predicton（NSP）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7445ba1ebb65e2d28d8ff8e303eca91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7092fd015f88786cb51dc454db1d3fb4/" rel="bookmark">
			PostGIS实现空间数据转GeoJSON对象 （1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：在实际开发过程中，有时了满足前端特定需求，或者数据交换的需要，在对地理空间数据进行一系列的查询、关联、分析后，需要返回geojson格式的空间数据，本篇就介绍如何通过Postgis和Postgresql提供的相关函数实现地理空间数据到GeoJSON格式的转换，功能比较实用，这里也得益于Postgresql对json数据、数组数据支持的特性，涉及不少知识点以此总结记录。详细内容参见公众号。
https://mp.weixin.qq.com/s?__biz=MzI2NTU5NTk5NA==&amp;mid=2247483771&amp;idx=1&amp;sn=da0284b41d71550e1a05e70f2c1b713f&amp;chksm=ea9bbc4eddec35586e24952337c2e6d7ae3738793b17a443e61f9c80600e5c2d25cd1b3a9fe2&amp;token=165633271&amp;lang=zh_CN#rd
推荐下公众号，后续主要更新开源GIS相关知识技能，包括PostgreSQL、PostGIS、Geoserver等，欢迎有兴趣同学关注学习交流
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54c19a5c9392819d6c9bf09a05e06bae/" rel="bookmark">
			redis&#43;lua实现高并发商品秒杀案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果多redis服务节点不建议使用此方法。多节点可以用redLock实现分布式锁实现 用redis+lua不会出现商品卖超，减库存问题，不用加锁，只需要在lua脚本中把业务写好，一切都是这么简单。redis的好处就是多路io复用，基于内存。存储快速。 redis+Lua脚本 1、减少网络开销,如果一个功能需要多次请求redis,使用脚本完成同样的操作只需要请求一次,减少了网络往返 2、原子操作,redis会将lua脚本作为一个整体执行,中间不会被其他命令插入,无需担心竞态条件,无需使用事务 3、复用,客户端发送的脚本会永久存储在redis中,其他客户端可以复用这一脚本 我用的是单体服务进行跑批。999个商品一万个线程。用了一分钟（redis+lua执行时间+异步订单写入数据库）tomcat服务拒绝3500次（单体），tomcat服务吐吞量在400/s,如果真正意义上的秒杀，单体服务肯定是不行的，服务肯定要考虑负载和集群，分布等，此次模拟只是测试。由于高并发的特点是瞬间用户量大，对服务配置要求要高点。我的电脑配置是算差的了。所以真正线上商品秒杀要根据用户量去选型配置。 好了今天就说到这里。看下面的代码吧。有问题可以随时撩我。只要我在线 1、定义lua脚本 local productId = tostring(KEYS[1]) local uid = tostring(ARGV[1]) -- 成功函数 local function successFun(success, msg, data) success = success or 1 msg = msg or "" data = data or {} return cjson.encode({success = success, msg = msg, data = data}) end -- 错误函数 local function response(errno, msg, data) errno = errno or 0 msg = msg or "" data = data or {} return cjson.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54c19a5c9392819d6c9bf09a05e06bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a7cf35d08c52a50952946e5e7b29d6d/" rel="bookmark">
			解决openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No s
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 在Centos7上编译安装openssl后，运行openssl version出现如下错误：
openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory 这是由于openssl库的位置不正确造成的。
解决方法： 在root用户下执行：
ln -s /usr/local/lib64/libssl.so.1.1 /usr/lib64/libssl.so.1.1 ln -s /usr/local/lib64/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a1bd3562ed9eff995b5c01b7052e3a8/" rel="bookmark">
			centos网络配置（包含4种类型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux网络配置
（1）ifconfig临时配置IP
ifconfig etho 192.168.0.23 netmask 255.255.255.0
（2）setup工具永久配置（redhat系列）
service network restart
（3）修改网络配置文件(标准)
1.网卡信息
vi /etc/sysconfig/network-scripts/ifcfg-eth0
BOOTPROTO 是否自动获取IP（none、static、dhcp）
2.主机名修改文件
vi /etc/sysconfig/network
hostname +name 临时修改
3.DNS配置文件
vi /etc/resolv.conf
DNS值：公用114.114.114.114/114.114.115.115 阿里223.5.5.5 备用223.6.6.6
百度180.76.76.76
谷歌8.8.8.8 8.8.4.4
（4）图形界面配置IP地址setup
修改UUID
#删除MAC地址
1. vi /etc/sysconfig/network-scripts/ifcfg-eth0 #删除网卡和MAC地址绑定文件
2.rm -rf /etc/udev/rules.d/70-persistent-net.rules 3.重启系统
虚拟机通信：
桥接：可以和局域网及公网通信，利用真实网卡
NAT：只能和公网通信
Host-only：只能和局域网通信
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f81be6ca59097eba0b161847a30cabd2/" rel="bookmark">
			Docker学习二之主要命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker 学习2 Docker 是什么？ 我们在理解 Docker 之前，首先得先区分清楚两个概念，容器和虚拟机。
可能很多读者朋友都用过虚拟机，而对容器这个概念比较的陌生。我们用的传统虚拟机如 VMware ， VisualBox 之类的需要模拟整台机器包括硬件。
每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。
每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。
而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。
容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。
容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。
通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。
容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。
容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。
通过下面这幅图，我们可以很直观的反映出这两者的区别所在：
Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。
而 Linux 容器是 Linux 发展出的另一种虚拟化技术，简单来讲， Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。
对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。
Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。
程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker ，就不用担心环境问题。
总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。
Docker 的优势 Docker 相比于传统虚拟化方式具有更多的优势：
Docker 启动快速属于秒级别。虚拟机通常需要几分钟去启动。
Docker 需要的资源更少。Docker 在操作系统级别进行虚拟化，Docker 容器和内核交互，几乎没有性能损耗，性能优于通过 Hypervisor 层与内核层的虚拟化。
Docker 更轻量。Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。
与虚拟机相比，Docker 隔离性更弱。Docker 属于进程之间的隔离，虚拟机可实现系统级别隔离。
安全性。Docker 的安全性也更弱，Docker 的租户 Root 和宿主机 Root 等同，一旦容器内的用户从普通用户权限提升为 Root 权限，它就直接具备了宿主机的 Root 权限，进而可进行无限制的操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f81be6ca59097eba0b161847a30cabd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ff0f696b4eb8e388d46aed75f86487/" rel="bookmark">
			51单片机重定向printf函数 打印数值不正确问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串口一重定向printf函数 #include &lt;STC12C5A60S2.H&gt; #include &lt;stdio.h&gt; #include "usart.h" //函数的声明文件 #define boud 9600 #define sys_clk 11059200 //UART1 初始化 void Uart1Init(void)	{ PCON &amp;= 0x7F;	//波特率不倍速 SCON = 0x50;	//8位数据，可变波特率 AUXR |= 0x04;	//1T模式 BRT = 256 - (int)(sys_clk/boud/32 + 0.5);	//设置独立波特率发生器重装值 AUXR |=0X01;	//串口1选择独立发生器为波特率发生器 AUXR |=0X10;	//启动独立波特率发生器 ES = 1; //使能串口1中断 } //UART1 发送串口数据 void UART1_SendData(char dat) { ES=0;	//关串口中断 SBUF=dat;	while(TI!=1);	//等待发送成功 TI=0;	//清除发送中断标志 ES=1;	//开串口中断 } //UART1 发送字符串 void UART1_SendString(char *s) { while(*s)//检测字符串结束符 { UART1_SendData(*s++);//发送当前字符 } } //重写putchar函数 重定向printf char putchar(char c) { UART1_SendData((unsigned char)c); return c; } 关于打印数值问题需注意 打印8,16,32位数据不能像PC机或者是32位位单片机那样，直接使用 %d,占位符，具体使用格式如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20ff0f696b4eb8e388d46aed75f86487/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79dcf361dec554da57becd2e1e25c1a9/" rel="bookmark">
			妙用CSS变量，让你的CSS变得更心动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：JowayYoung
仓库：Github、CodePen
博客：掘金、思否、知乎、简书、头条、CSDN
公众号：IQ前端
联系我：关注公众号后有我的微信哟
特别声明：原创不易，未经授权不得对此文章进行转载或抄袭，否则按侵权处理，如需转载或开通公众号白名单可联系我，希望各位尊重原创的知识产权
前言 CSS变量又叫CSS自定义属性，为什么会突然提起这个很少人用到的东西呢？因为最近在重构个人官网，不知道为什么突然喜欢用上CSS变量，可能其自身隐藏的魅力，让笔者对它刮目相看。
谈到为什么会在CSS中使用变量，下面举个栗子，估计大家一看就会明白。
/* 不使用CSS变量 */ .title { background-color: red; } .desc { background-color: red; } /* 使用CSS变量 */ :root { --bg-color: red; } .title { background-color: var(--bg-color); } .desc { background-color: var(--bg-color); } 看完可能会觉得使用CSS变量的代码量多了一点，但是有没有想到突然某天万恶的策划小哥哥和设计小姐姐说要做一个换肤功能。按照平常的思路，估计有些同学就会按照默认颜色主题增加一份对照的新颜色主题CSS文件。这样每次新增需求都同时维护几套主题颜色多麻烦啊。
此时CSS变量就派上用场了，提前跟设计小姐姐规范好各种需要变换的颜色并通过CSS变量进行定义，通过JS批量操作这些定义好的CSS变量即可。这也是变换主题颜色的一种解决方案之一，好处在于只需写一套CSS代码。
["red", "blue", "green"].forEach(v =&gt; { const btn = document.getElementById(`${v}-theme-btn`); btn.addEventListener("click", () =&gt; document.body.style.setProperty("--bg-color", v)); }); 在此总结下CSS使用变量的好处：
减少样式代码的重复性增加样式代码的扩展性提高样式代码的灵活性增多一种CSS与JS的通讯方式不用深层遍历DOM改变某个样式 可能有些同学会问，Sass和Less早就实现了变量这个特性，何必再多此一举呢。可是细想一下，CSS变量对比Sass和Less的变量，又有它的过人之处。
浏览器原生特性，无需经过任何转译就可直接运行DOM对象一员，极大便利了CSS与JS之间的联系 认识 本来打算用一半篇幅讲述CSS变量的规范和用法，但是网上一搜一大把就感觉没必要了，贴上阮一峰老师写的教程《CSS变量教程》。同时笔者也对CSS变量的细节地方进行一个整理，方便大家记忆。
声明：--变量名读取：var(--变量名, 默认值)类型 普通：只能用作属性值不能用作属性名字符：与字符串拼接 "Hello, "var(--name)数值：使用calc()与数值单位连用 var(--width) * 10px 作用域 范围：在当前元素块作用域及其子元素块作用域下有效优先级别：内联样式 &gt; ID选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器 接下来使用几个特别的场景展示CSS变量的魅力。还是那句话，一样东西有使用的场景，那自然就会有它的价值，那么用的人也会越来越多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79dcf361dec554da57becd2e1e25c1a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de52d1a7b552050757da2276155ff46e/" rel="bookmark">
			【C&#43;&#43;】VS Code提示“include 错误，请更新includepath”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题
第一次使用VS Code，在官网上下载了最新版本。安装好后，想输个“Hello World!”，结果“#include”下面出现波浪曲线，程序运行错误。光标移动到波浪曲线，提示“#include 错误，请更新includePath”。
解决过程
在网上，看到有的解决办法是:打开cmd，输入“gcc -v -E -x c++ -”。试了一下，发现提示“gcc 不是内部或外部命令”。为了解决这个问题，重新找解决办法。之后安装MinGW，在安装程序的指导下，勾选了下载g++(忘记是g++还是gcc了，但我这个安装程序默认情况下，只勾选了MinGW xxxx base。为了防止出错，我勾选了全部…)。
之后是系统环境变量配置。我的MinGW是安装在C:\MinGW\下。之后，将“C:\MinGW;C:\MinGW\bin;C:\MinGW\lib;C:\MinGW\include”写到“系统变量”的Path中，点击“确定”。
之后，我选择重启电脑，因为我发现波浪曲线警告还在…重启后，波浪曲线消失，“Hello World!”成功输出。原本我还以为接下来要执行“gcc -v -E -x c++ -”
。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1adec007b32daa2edd866caf3ad71f6d/" rel="bookmark">
			js 使用摄像头进行拍照上传功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;js开启摄像头拍照并上传图片&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;video id="video" width="640" height="480" autoplay="autoplay"&gt;&lt;/video&gt; &lt;canvas id="canvas" style="display: none;" width="640" height="480"&gt;&lt;/canvas&gt; &lt;button onclick="openMedia()"&gt;开启摄像头&lt;/button&gt; &lt;button id="capture" onclick="takePhoto()"&gt;拍照&lt;/button&gt; &lt;button onclick="closeMedia()"&gt;关闭摄像头&lt;/button&gt; &lt;div&gt;&lt;img id="imgTag" src="" alt="imgTag"&gt;&lt;/div&gt; &lt;script&gt; let video = document.getElementById("video"); let canvas = document.getElementById("canvas"); let context = canvas.getContext("2d"); // 开启摄像头 function openMedia() { // 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象 if (navigator.mediaDevices === undefined) { navigator.mediaDevices = {}; } // 一些浏览器部分支持 mediaDevices。我们不能直接给对象设置 getUserMedia // 因为这样可能会覆盖已有的属性。这里我们只会在没有getUserMedia属性的时候添加它。 if (navigator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1adec007b32daa2edd866caf3ad71f6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/838ca15efb6d07fd7d2c787afca6c15d/" rel="bookmark">
			java 后端服务  调用 google api 直接获取access toekn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发google api 的时候遇到的问题 需要维护google上的搜索商品 google 需要获取access token 才能正常调用
相关文档
google api 文档
请求示例和文档
https://developers.google.com/shopping-content/v2/quickstart
身份平台
https://developers.google.com/identity/protocols/OAuth2ServiceAccount
创建项目生成json和p12文件
https://console.cloud.google.com/projectselector2/iam-admin/serviceaccounts?supportedpurview=project
创建项目
https://console.developers.google.com/cloud-resource-manager
https://developers.google.com/identity/protocols/OpenIDConnect
google身份平台
https://developers.google.com/identity/protocols/OAuth2ServiceAccount
作用域
https://developers.google.com/identity/protocols/googlescopes
api请求 示例
https://developers.google.com/identity/protocols/OAuth2ServiceAccount
网上看了很多相关文章 没有直接获取access token的 大部分都是需要 url 重定向 取URL里面的code 然后用code取access token
服务端这样处理比较难 应该是直接调一个接口返回 access token 这样处理比较方便 前面的步骤简单说一下
1.创建服务项目 2.生成加密文件 (json或者p12)
这两个步骤网上都有教程
获取access token
方式一 直接用google原生的api public static void main(String[] args) throws IOException {
HttpTransport httpTransport = GoogleNetHttpTransport.newTrustedTransport();
JsonFactory jsonFactory = JacksonFactory.getDefaultInstance();
GoogleCredentials credential = GoogleCredentials.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/838ca15efb6d07fd7d2c787afca6c15d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0edb0598fc10e79d9a806d47ec0e6df4/" rel="bookmark">
			整理pytorch报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element 0 of tensors does not require grad and does not have a grad_fn Stack Overflow[1]中有这个问题的描述，自己写了一个dice loss，没法反向传播，报这个错。原因应该是因为用了torch.argmax()，好像这个函数不可导，所以没法反向传播。input.size()是[10,2,513,513]，target.size()是[10,513,513]，最后写了一个multi-class dice loss，可以了。
def diceloss(self, output, target): predicted = F.softmax(output, dim=1) # # print(np.sum(predicted[:, 0]==0),np.sum(predicted[:, 0]&gt;0),np.sum(predicted[:, 1]==0),np.sum(predicted[:, 1]&gt;0)) a = dice_coef(predicted[:, 0], (target == 0).float()) b = dice_coef(predicted[:, 1], (target == 1).float()) return 1 - (a*0.3 + b*0.7) RuntimeError: invalid argument 0: Tensors must have same number of dimensions: got 3 and 4 at .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0edb0598fc10e79d9a806d47ec0e6df4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73949c51f1f7e6382118752b63c73e4d/" rel="bookmark">
			vue 中html不能写入的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		basic.other_photo是一个数组
&lt;h4 v-if="basic.other_photo.length != 0"&gt;附加资料&lt;/h4&gt;
结果报错
改成这种就不报错
&lt;h4 v-if="basic.other_photo !== undefined &amp;&amp; basic.other_photo.length &gt; 0"&gt;附加资料&lt;/h4&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c4dbdf4c0d375160bfd22e744138454/" rel="bookmark">
			vue框架中使用fontAwesome图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、第一步：安装fontAwesome图标依赖
npm install fontAwesome --save 2、第二步：在main.js中引入fontAwesome图标依赖
import 'font-awesome/css/font-awesome.css'; 3、第三步：使用图标
&lt;i class="fa fa-address-book-o" aria-hidden="true"&gt;&lt;/i&gt; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/376/">«</a>
	<span class="pagination__item pagination__item--current">377/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/378/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>