<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0e921b6bf81a053d634ffbce3447039/" rel="bookmark">
			错误: 不兼容的类型: 从double转换到float可能会有损失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常定义浮点型变量时，使用double型。
定义float类型变量时，变量要以“ f ”或“ F ”结尾
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cead6df4927beededbf0ef1715842dcf/" rel="bookmark">
			Python小白之路 图形化程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import turtle 导入库 海龟绘图
import turtle
turtle.showturtle() #显示箭头
turtle.write(“GAO”) #名字
turtle.forward(300) #前进300像素
turtle.color(“red”)
turtle.left(90) #左转90°
turtle.forward(300)
turtle.goto(0,50)
turtle.goto(0,0) #到原点
turtle.penup() #抬笔
turtle.gaoto(0,300)
turtle.pendown() #落笔
没画线但点的方向变了
turtle.circle(100) #画⚪
#绘制奥运五环
import turtle
turtle.circle(50)
turtle.goto(120,0)
turtle.circle(50)
turtle.goto(240,0)
turtle.circle(50)
turtle.goto(60,-50)
turtle.circle(50)
turtle.goto(180,-50)
turtle.circle(50)
有bug
所以要加上抬笔和落笔，因为抬笔和落笔不在画布上显示
在移动的地方前后加上 penup() pendown()
import turtle
turtle.circle(50)
turtle.penup()
turtle.goto(120,0)
turtle.pendown()
turtle.circle(50)
turtle.penup()
turtle.goto(240,0)
turtle.pendown()
turtle.circle(50)
turtle.penup()
turtle.goto(60,-50)
turtle.pendown()
turtle.circle(50)
turtle.penup()
turtle.goto(180,-50)
turtle.pendown()
turtle.circle(50)
还需要进一步改善，因为五环是圆心圆，而且还有五个不同的颜色
设置宽度及不同的颜色
turtle.width(10) #设置圆环的宽度10px
然后在每个pendown()下面添加下一个圆圈相应的颜色
turtle.color(“英文单词”)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cead6df4927beededbf0ef1715842dcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a281deeddde7d3420eb3672643b5ff1b/" rel="bookmark">
			求最长不下降子序列的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最长不下降子序列的个数 0.问题 1.计算一个序列的最长不下降子序列长度2.并且给出这个序列中最长不下降子序列的个数 1.代码 如下所示。其中
1.len[i]存放以i为递增序列尾部元素的最长序列长度(注意是最长序列)2.cnt[i]存放以i为递增序列尾部元素的最长序列个数(注意是最长序列) #include&lt;iostream&gt; using namespace std; const int maxH = 155; int main(){ int arr[maxH]; int n,m; cin &gt;&gt; m; while(m &gt; 0){ cin &gt;&gt; n;	for(int i = 0;i&lt; n;i++){ cin &gt;&gt; arr[i]; } int res,maxLen = 0; int len[maxH] , cnt[maxH]; for(int i = 0; i &lt; n; i++){ //一定要注意这里的初始化 len[i] = cnt[i] = 1; for(int j = 0; j &lt; i ; j++){ if(arr[i] &gt;= arr[j]){ if(len[i] == len[j] + 1) //这行代码是否多余？ //不多余，因为，从cnt[j]也可以到达cnt[i]，所以需要加上cnt[j]的 种类数 cnt[i] += cnt[j]; if(len[i] &lt; len[j] + 1){ //如果len[i]是从len[j]过来的，就要将cnt[i]赋值为cnt[j]，而不同于上面的 cnt[i] += cnt[j] 操作 len[i] = len[j] + 1; cnt[i] = cnt[j]; } } } if(maxLen == len[i]) res += cnt[i]; if(maxLen &lt; len[i]){ maxLen = len[i]; res = cnt[i]; } } cout &lt;&lt;maxLen&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a281deeddde7d3420eb3672643b5ff1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e723c1813347f10d261c55b134d51d8f/" rel="bookmark">
			Eclipse如何设置自动提示？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 **1、**运行Eclipse开发工具，在开发工具最顶端菜单栏，点击“windows”-&gt;“preferences”,弹出preferences设置窗口。
**2、**在preferences中找到Java，依次展开列表"Editor"-&gt;“Content Assist”,点击Content Assist后，在设置窗口下方找到Auto activation栏，进行代码提示延时和代码提示字符设置。
把下列字母串粘贴到里面：.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
3、在preferences中找到XML，依次展开列表"XML Files"-&gt;“Editor”-&gt;“Content Assist”,点击Content Assist后，在设置窗口上方找到Auto activation栏，进行代码提示延时和代码提示字符设置。把下列字母串粘贴到里面：
&lt;=:abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
我用双手实现你的梦想 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9d9d2097b2eef6e80ec3106d6151bba/" rel="bookmark">
			MyBatis报错分析There is no getter for property named &#39;XXX&#39; in &#39;class XXX&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		There is no getter for property named 'XXX' in 'class XXX' 前言问题描述问题分类 前言 今天遇到一个比较常见的问题，但因为出错原因不止一种，所以还是可以总结一下的。
问题描述 当我们使用Mybatis时可能会经常看到类似这样的报错信息There is no getter for property named ‘XXX’ in ‘class XXX’，意思是没有找到对应字段的getter方法。这个报错很大可能是在使用动态SQL中的&lt;if&gt;标签中的test判断时发生的，因为这里判断非空默认调的是对应字段的Getter方法。
问题分类 如果在Mapper中我们传入的参数是自定义对象类型，而属性‘XXX’是对象的属性时，一般就是因为实体类中变量名和Mapper中不一致导致的，这个时候就要检查是否是变量名拼写错误或是没有加@Data，@Getter等注解同时又没有自己添加Getter方法。
如果传入的参数是String，或是Integer这一类的且只有一个的时候，不应该使用变量名而应该使用_parameter代替变量名，这是因为此时如果使用变量名，并不是在你定义的对象里找Getter方法，而是在String或Integer里找，当然是找不到的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/966b8973da85050b3190d90a2cf8e32e/" rel="bookmark">
			java8 CompletableFuture_异步执行多个任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
CompletableFuture是java8提供的基于异步操作的封装，日常开发中怎能不用上一番呢。
1)聚合多个异步任务
需求：多个tab页包含不同的表格数据，并且带分页，页面首次加载时需要显示第一页数据，并且在tab顶上显示总量，如下图所示：
各个表格数据从es中查询，涉及到计算，此处可以让前端调用多个接口来组装数据，但考虑到查询效率和网络交互，采用后端以多线程的形式查询，组合多个结果返回给前端，后端实现如下：
//所有订单
CompletableFuture&lt;OrdersBo.Item&gt; allOrdersFuture = fillAllOrders(pd, ordersBo);
//及时量订单
CompletableFuture&lt;OrdersBo.Item&gt; inTimeOrdersFuture = fillInTimeOrders(pd, ordersBo);
//超时量订单
CompletableFuture&lt;OrdersBo.Item&gt; timeOutFuture = fillOverTimeOrders(pd, ordersBo);
//失败量
CompletableFuture&lt;OrdersBo.Item&gt; failOrderFutrue = fillFailOrders(pd, ordersBo);
//异常量
CompletableFuture&lt;OrdersBo.Item&gt; exceptionOrderFuture = fillExceptionOrders(pd, ordersBo);
//聚合几个查询的结果返回给前端
CompletableFuture.allOf(allOrdersFuture, inTimeOrdersFuture, failOrderFutrue, timeOutFuture, exceptionOrderFuture).join();
return ordersBo;
1
2
3
4
5
6
7
8
9
10
11
12
13
14
上述其实就是用到了CompletableFuture的特性，CompletableFuture.allOf()方法需要其中的每个异步任务都结束，配合join实现阻塞的效果，类似的还有很多方法，可以在不同的场景下使用，比如anyOf,当面临多份数据来源时,选择最快的一方。
CompletableFuture提供的api方法很多,我们可以将其归类来理解，首先是以then开头的方法，如thenAccept
凡是带accept的方法都没有返回值，接收的是一个消费者（Customer）
accept和acceptAsync的区别是,带Async的方法，可以异步执行，默认是使用forkjoinpool并且可以指定其他线程池。
以apply结尾的参数是接收的一个生产者(FUNCTION)，具有返回值。
以run开头的对先前的执行结果不关心，执行完毕后直接执行下一个操作。
带Either的用在两个异步方法，只要取其中一个执行完毕就执行操作。
2）配合spring的@Async使用
在演示程序里，我定义了两个方法，分别是请求百度和请求新浪，我希望让这两个请求再我自定义的线程池中执行。其中用到的spring-web中的restTemplate来做请求，在具体方法中打印出当前执行的线程（为线程取名是很重要的哦，特别是线上发生问题能很好的通过工具定位）,主要代码如下
@Autowired
private RestTemplate restTemplate;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/966b8973da85050b3190d90a2cf8e32e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d642cd79d6d95e76d9d6e491ecf6638/" rel="bookmark">
			idea启动项目时报错，workspace.xml文件第一行存在错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 一次意外关机，正在运行的idea也被关闭，重启电脑后，打开idea，加载项目出错，提示说明.idea文件夹的workspace.xml存在错误
workspace.xml这个文件的作用就是记录idea针对该项目的配置，包括服务器的相关配置，maven或者jdk的相关配置，第三方jar的配置等。打开该文件，发现全是乱码，那肯定会加载不了项目。
解决方法 这种情况一般是意外关闭idea导致文件的编码被修改了，重新修改该文件的编码为utf-8如果有将该文件放到svn或者git里，可以还原文件删除该文件，再次打开idea的时候进行重新配置即可生成一个正常的workspace.xml文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8849f42f92541c148dc3b4831d833d85/" rel="bookmark">
			UserWarning: PySoundFile failed. Trying audioread instead.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		老子安装librosa后出现这个warning，真是够了，啥玩意。虽是警告，但看起来不顺眼，不舒服，想去掉。
完整错误如下：
UserWarning: PySoundFile failed. Trying audioread instead. warnings.warn('PySoundFile failed. Trying audioread instead.') 我之前安装librosa后也没出现这个警示啊，难道这个库用新的依赖库了？？那么可以降级试试。
果然是版本更新的问题，降级为0.6.1完美解决。
拜拜。
另外有相关问题可以加入QQ群讨论，不设微信群
QQ群：868373192 语音图像视频深度-学习群
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed7db598fa7725a640f6a69fe7e9e115/" rel="bookmark">
			LTE物理层过程--小区搜网、随机接入、功率控制、测量、数据传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 终端和网络进行通讯需要进行哪些物理层的交互呢？
终端需要搜索到服务自己的网络，然后接入网络，这就涉及小区搜索过程和随机接入过程；在交互过程中，终端和网络都需将功率调节到合适的大小，以增强覆盖或抑制干扰，这就是功率控制过程；网络想找到某一个终端，以期与其建立业务连接，这就是寻呼过程；网络的自适应能力依赖于对无线环境的精确感知，测量过程为网络的自适应提供依据；终端和网络的有用信息交互，依赖于共享信道的物理层过程。
LTE中按照上行和下行来分：
下行物理层过程有：小区搜索过程、下行功率控制、寻呼过程、手机下行测量过程、下行共享信道物理过程。
上行物理层过程有：随机接入过程、上行功率控制、基站上行测量过程、上行共享信道物理过程。
1、小区搜索过程 终端和基站建立无线通信链路的前提是必须先进行小区搜索。具体是在以下两种情况：一是用户开机，二是小区切换。
在LTE中，用户终端开机或小区切换时，需要和小区取得新的联系，和小区的时频保持同步，获取小区的必要信息。
小区搜索过程中，用户UE要达到以下三个目的：
下行同步：符号定时、帧定时、频率同步。小区的标识号（ID）获取。广播信道（BCH）的解调信息获取。 BCH信道广播的信息有：小区的传输带宽（LTE中各小区传输带宽不固定）、发射天线的配置信息（每个基站天线数目可能不一致）、循环前缀（CP）的长度（单播、多播业务CP长度不同）等。
1.1、 三个信道、四个步骤 UE完成小区搜索过程需要借助三个信道：
同步信道（SS、SCH）包括：主同步信道（PSS、P-SCH）和从同步信道（SSS、S-SCH）；参考信道（RS）；广播信道（BCH）。 小区的搜索过程分为以下四个步骤：
第一步：从PSS信道上获取小区的组内ID；第二步：从SSS信道上获取小区组号，范围是0~167；协议规定了3个PSS信号，使用长度为62的频域Zadoff-Chu（ZC序列，较好的自相关特性和较低峰均比），分别对应小区组内ID；SSS信号则使用二进制M序列，有168种组合，与168个物理层小区标识组对应。所以UE把PSS和SSS接收下来后就可以确定小区标识。先获取组内顺序号，再获取小区组的顺序号。第三步：UE接收下行参考信号（DL-RS），用来进行精确的时频同步。DL-RS是UE获取信道估计信息的指示灯。对于频率偏差、时间提前量、链路衰落情况，UE从这里了解清楚，然后在时间和频率上紧跟基站的步伐。第四步：UE接收小区广播信息。完成前三步后UE就完成了和基站的时频同步，可以接受基站的面向小区内所有UE的广播信号。有需要就听一下，从广播信号上可以获得下行系统带宽值，天线配置，本小区的系统帧号等。 以往无线制式下行系统带宽和天线配置是定死的。在LTE中得益于OFDM、MIMO，配置是灵活的，但增加了这部分信令开销。
1.2、 在合适的位置寻找合适的信息 SS信号和BCH信道是小区搜索时UE最先捕获的物理信道。因此必须保证用户在没有任何先验信息情况下能够得到这些信息。办法就是：在时域和频域上安排固定位置。
如之前的文章，同步信号每个帧发送两次，PSS和SSS在时域上的位置TDD和FDD不一样。FDD中，PSS、SSS分别在第0个和第5个子帧的第一个时隙的最后两个符号位置上。TDD中，PSS在DwPTS上，SSS在第0个子帧的第1#时隙的最后一个符号上。BCH在SS之后被用户接收，因此二者须有一个固定的时间间隔τ，如图所示：
每个下行帧，SS和BCH可以发送多次，SS和BCH数目也可不同，对于BCH出现的时间位置，终端需要知道，否则无法找到它。
不管小区总传输带宽多大，SCH信道和BCH信道只在小区传输带宽的中心位置传输，而且SCH、BCH总是占用相同的带宽（1.25MHz）.其中有用子载波数目是64个，中间有一个直流子载波（DC）。
在小区搜索的开始，监测系统的中心带宽为1.25MHz。利用同步信道进行下行同步，获取小区标识；然后还是在这1.25Mhz中心带宽上，接收BCH相关的解调信息。UE从BCH的解调信息中获取了分配的系统带宽，然后将工作带宽偏移到指定的频带位置上，至此才可以进行数据传输，整个过程如图所示。
2、随机接入过程 随机接入过程主要完成用户信息在网络侧的初始注册。通过小区搜索，用户知道了网络侧的信息；而通过随机接入，网络侧又知道了用户的必要信息。
和UMTS随机接入过程不同，LTE的随机接入过程不仅完成用户信息的初始注册，还需要完成上行时频同步（Time Advance，时间提前量，TA）与用户上行带宽资源的申请。
在LTE中，上行时频同步和重新申请上行带宽资源，都需要启动随机接入过程来完成。大致来说启动随机接入过程的场景有以下三种：开机、UE从空闲状态到连接态、小区切换。
根据接入时终端的同步状态不同，随机接入过程可分为同步的随机接入和非同步的随机接入。同步的随机接入过程已经处于同步状态，没有上行同步的目的，主要的目的只是上行带宽资源的申请。
非同步随机接入是在用户UE没有上行同步、或者失去上行同步时，需要和网络侧请求资源分配时所使用的接入过程。
2.1 Preamble结构 上行失步情况下，终端和网络侧都不知道彼此间的距离，容易导致基站的上行接收窗错位。这就要求时域采用特殊的Preamble结构（加CP）来克服可能的时间窗错位。
随机接入在接入用户数目较多时基于竞争会发生严重的冲突碰撞，降低系统容量。一般采用基于资源预留的接入机制。在随机接入过程中一定要选用冲突概率小、相关性较低的同步序列，做上行同步。
随机接入前导消息Preamble的位置，在时域上是可配置的，在频域上一般位于PUCCH信道的内侧，如图所示。
2.2、 LTE与UMTS随机接入过程对比 对于物理层来讲，物理层的随机接入过程包含两个步骤：
发送：UE发送随机接入Preamble；
应答：eUTRAN对随机接入的响应。
UE物理层首先要从高层（传输层的RACH信道）获取随机接入的PRACH信道参数，包括：
（1）PRACH信道配置信息（时域、频域上的信道结构信息）；
（2）前导Preamble格式（前导用于上行时钟对齐和UE识别符，系统规定其由Zadoff-Chu序列产生）；
（3）前导发射功率；
（4）Preamble根序列及其循环位移参数（小区用来解调前导消息）。
UMTS随机接入信道（PRACH）（上行）包括前导消息（Preamble）、正交消息部分（Message），如图所示
在LTE中，随机接入信道（PRACH）只包括前导消息（Preamble），但较UMTS的前导消息内涵更加丰富一些。正文消息部分是在共享信道PUSCH上进行传输，不属于PRACH的一部分。物理层随机接入过程不包括正文消息的发送过程。
LTE基站给终端随机接入的应答，也不像UMTS中简单地回应一个AI，而是有丰富内涵的一个回应，由PDCCH（指示是否有回应）和PDSCH（指示回应的具体内容），如图所示。
基站通过PDSCH信道告知UE随机接入允许的内容（UL-SCH grant），这个内容需要传给UE的传输层在共享SCH信道上才能解析。随机接入响应准许（UL-SCH grant）包括：无限资源RB指派情况、调制编码信息、功率控制命令、是否请求CQI等信息。UE根据随机接入响应准许的要求，在上行PUSCH信道上发送随机接入的消息部分。
随机接入的具体过程如下：
（1）UE高层请求触发物理层随机接入过程。
高层在请求中指示Preamble index、Preamble 目标接收功率、相关的RA-RNTI（Random Access Radio Network Temporary Indentifier，随机接入无线网络临时标识），以及随机接入信道的资源情况等信息。
（2）UE决定随机接入信道的发射功率。
由于随机接入在与网络侧建立联系之前发生，因此采用开环功率控制。终端在PARCH信道发射随机接入前导消息（Preamble）时，自己根据高层指示计算一个发射功率，如下式：
发射功率 = preamble的目标接收功率+路径损耗
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed7db598fa7725a640f6a69fe7e9e115/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66d18cef3cba95bbca8feb19041d47d3/" rel="bookmark">
			我的Java学习之路（第十四天）------ 在字符串中查找字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法indexOf用于在字符串中查找字符
package de1; public class Test { public static void main(String[] args) { String name = "yangwenhao"; int index = name.indexOf('a'); System.out.println(index); } } 这个示例确定字符‘a’在字符串中的索引，但这个字符在name里面出现了两次，它会返回字符第一次出现处的索引；
如果想要确定后面位置出现的索引，则使用另一版本的indexOf；
package de1; public class Test { public static void main(String[] args) { String name = "yangwenhao"; int index = name.indexOf('a',3); System.out.println(index); } } int index = name.indexOf(‘a’,3);从索引3（每个字符编号从0开始）开始查找下一个字符‘a’；
🌂如果字符串中没有指定的字符，indexOf将返回-1；
🌂另外indexOf也可以用于查找子串
package de1; public class Test { public static void main(String[] args) { String name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66d18cef3cba95bbca8feb19041d47d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3480549b53ded00a6a4cd71d017086d4/" rel="bookmark">
			PHP 使用HTML 导出并下载 Word
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?php $html= "Hello World"; // 导出Word ob_start(); echo '&lt;html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40"&gt;&lt;head&gt;&lt;xml&gt;&lt;w:WordDocument&gt;&lt;w:View&gt;Print&lt;/w:View&gt;&lt;/xml&gt;&lt;/head&gt;'; echo $html; echo "&lt;/html&gt;"; $word_content = ob_get_contents(); ob_end_clean(); $word_path = "写自己的存放路径"; // 生成的 word 存放的路径 $word_name = "写生成的文件名"; // 生成的 文件名 $location_path = "生成的 word 文件路径"; if(!file_exists($word_path)) { mkdir($word_path, 0777, true); chmod($word_path, 0777); } $fp=fopen($word_path.$word_name,"wb"); $create = fwrite($fp,$word_content); fclose($fp); if($create) { // 创建好 word文件后 重定向到该文件就直接下载了。 header("Location: ".$location_path); exit(); } else { echo "下载失败,请联系技术"; } ?&gt; 注意：当我们写的样式失效在Word中失效时，我们可以写在Word中写个模板，然后找个Web在线编辑器，将Word模板复制到里面再转成HTML格式查看，然后将生成的HTML样式复制使用就行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edc4824e9799a860fe84e82fa8ef5fd3/" rel="bookmark">
			钉钉接入红包指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		钉钉接入红包指南
一、钉钉只支持C2C红包，而且无开发接口，因此通过钉钉无法实现B2C红包
二、借助支付宝B2C红包功能，具体过程如下
1）找到B2C红包文档功能，首先想到在线模拟测试推送红包，支付宝也确实有在线推送功能，可是经测试，必须得有发送方和接收方，也就是只支持C2C推送测试，无奈只能自己接入代码实现。
2）经过查阅文档，B2C红包发放需要准备如下相关信息
a)通过支付宝提供的签名工具生成应用签名（私钥及公钥），公钥需要填写到开发平台对应应用上去；但测试发现，这里的公钥无法达到红包发包发放要求，需必须再生成“支付宝公钥”，后面测试发现，只通过公钥字符串无法发放红包，需要生成公钥文件；
b)生成支付宝公钥：支付宝公钥属于企业属性，不属于某个应用，因此在开发平台的对应应用上是找不到的。
c)发放对象方式：支付宝支持2种对象支持方式（1：通过授权登录获取到的支付宝用户Id；2：通过支付宝账号+真实姓名）
3）发放红包测试Demo
a)通过授权登录方式发放红包；条件：APPID+应用私钥+公钥证书（3个证书）+授权登录获取到的UserId；可以模拟发放成功，但切换到钉钉应用中发现，无法拉取授权（支付宝不支持），而且在浏览器中也无法拉取授权（提示只能在支付宝客户端打开），而且钉钉没有提供开发接口获取绑定支付宝UserId（通过特殊权限申请有可能达到，但我申请未通过）
b)通过支付宝账号+真实姓名发放红包；条件：APPID+应用私钥+公钥证书（3个证书）+&lt;支付宝账号+真实姓名&gt;；PC模拟发放成功，钉钉中模拟发放成功；
三、总结
钉钉目前不支持B2C企业红包，借助于支付宝企业红包实现的方式。
而借助支付宝实现理想的方式是通过特殊权限申请获取绑定的支付宝UserId（可申请，钉钉不一定有此特殊接口，或有此特殊接口也不一定同意提供）
目前通过支付宝账号+真实姓名发放红包方式已明确可行，但需要钉钉平台进入药动销平台需手动填写绑定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e20895f7853811f3b3b2890edd494b0/" rel="bookmark">
			C&#43;&#43; static_cast与dynamic_cast的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。 当我们将这两个运算符用于某种类型的指针或引用时，并且该类型含有虚函数，运算符将使用指针或引用所绑定对象的动态类型 类型转换名称和语法
c风格的强制类型转换(Type Cast)很简单,不管什么类型的转换统统是:
TYPE b = (TYPE)a
c++风格的类型转换提供了4中类型转换操作符来应对不同场合的应用
static_cast 静态类型转换。如int转化成char
reinterpret_cast 重新解释类型
dynamic_cast 命名上理解是动态类型转换,如子类和父类之间的多态类型转换
const_cast 字面上理解就是去const属性
类型转换格式 TYPE b = static_cast&lt;TYPE&gt; a 类型转换介绍
static_cast&lt;&gt;() 静态类型转换,编译时c++编译器会做类型检查
若不同类型之间,进行强制类型转换,reinterpret_cast&lt;&gt;() 进行重新编译
dynamic_cast&lt;&gt;() 动态类型转换,安全的基类和子类之间转换,运行时类型检查
const_cast&lt;&gt;() 去除变量的只读属性
三种使用形式 dynamic_cast&lt;type*&gt; (e) //e必须为指针
dynamic_cast&lt;type&amp;&gt; (e) // e 必须为一个左值
dynamic_cast&lt;type&amp;&amp;&gt; (e) //e不能是左值
#include &lt;iostream&gt; using namespace std; class Tree { }; class Animal { public: virtual void cry() { } }; class Dog:public Animal { public: Dog():Animal() { age = 0; } virtual void cry() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e20895f7853811f3b3b2890edd494b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c13f24f927aac54c1745dd58ad79276/" rel="bookmark">
			Antlr4.8 &#43; VisualStadio 2019  C# 配置生效，实测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为要写ST语言结构化文本编译器，在看了很多文献的前提下，找到了Antlr 是一个不错的工具。
配置方法如下
1. 下载 antlr-4.8-complete.jar
https://www.antlr.org/download.html
2. 打开VS，在扩展里面,下载最新的插件
3. 安装Java运行环境
jre1.8.0_191
https://download.csdn.net/download/weixin_44543941/10920516
4. 在VS安装好 AntlrVSIX后，编译的时候，会报错的解决方法
在VS的新建向导，新建一个Antlr工程
在工具，NuGet,键入如下 Install-Package Antlr4.Runtime.Standard -Version 4.8.0
安装一个NuGetPage包。
完成之后，编译项目，弹出如下错误！
Unknown build error: Yo, I haven't a clue where Java is on this system. Crashing...
b.此时只要把 项目 构建文件给修改一下就行了，因为项目构建未见找不到对应的 Java文件
一个是 antlr-4.8-complete.jar文件路径，对应ToolPath
一个是 Java运行环境的安装路径， 对应JavaHome.
5. 本人是怎么找到这个问题的解决方法的，就是看源代码
6. 请看我 编译后，自动生成的CS代码
觉得对你有帮助，请给我点个赞！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a64552a89e5871e6579bbbae3ab1ea7a/" rel="bookmark">
			新机and老机优化（软件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部分参考：CSDN博主「Ben_小b」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/xiao_xiao_b/article/details/96177359
最近给一个电脑特别卡的朋友进行优化，发现自己好多优化的方法都忘了，所以趁着有时间，写一下博客，方便以后使用。
目录 1.服务优化2.自启动项优化3.外观优化4.安全设置禁止建立空链接禁止管理共享 5.缩短系统响应时间6.清除内存中使用不到的Dll文件7.日常清理养护 1.服务优化 右键我的电脑–&gt;管理–&gt;服务和应用程序–&gt;服务–&gt;鼠标右击想要关闭的服务–&gt;属性
Distributed Link Tracking Client
个人用户一般用不到，设置为手动
Remote Registry
这个服务是必停的服务之一，设置为禁用
Superfetch
I/O操作频繁的功能，如果不需要这个功能，设置为禁用
Windows Defender Service
I/O操作频繁的功能，如果不需要这个功能，设置为禁用
Windows Search
I/O操作频繁的功能，如果不需要这个功能，设置为禁用
Security Center
Windows安全中心服务，可以禁用
Distributed Link Tracking Client:
这个功能一般都用不上，完全可以放心禁用。
Fax
利用计算机或网络上的可用传真资源发送和接收传真。不用我说了吧，很明显就能看出来是和传真有关的。手动或禁用
Windows Error Reporting Service
没人喜欢错误，对你和微软而言，错误报告传送过去都没什么用。关了它。
Print Spooler
如果不需要连接打印机设备，设置为手动(不用打印机的可以关闭，不过一些软件需要此功能)
Server
如果不会共享文件或打印机，设置为手动
Smart Card(默认手动)
如果不用U盾等智能卡，设置为禁用
Windows Update
如果你不用自动更新，设置为手动
HomeGroup Listener
为家庭群组提供接收服务，该服务的默认运行方式是手动，如果你不使用家庭群组来共享图片视频及文档,那么该服务可以禁用。
HomeGroup Provider
为家庭群组提供网络服务，该服务的默认运行方式是自动，如果你不使用家庭群组来共享图片视频及文档,那么该服务可以禁用。
Windows Biometric Service
如果你没有使用生物识别设备，如指纹识别系统,该功能就可以放心禁用，否则保持默认。
Windows CardSpace
像Smart Card一样的个人标识管理，.NET Framework 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a64552a89e5871e6579bbbae3ab1ea7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8234438c6930a8ef525a09808d5c0314/" rel="bookmark">
			ubuntu 18.04 增加新磁盘、挂载、格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20200118 在阿里云 ECS linux 上尝试云盘卸载、挂载操作，先在本地 virtualbox 上尝试和学习 1、停止虚拟机，设置–存储–增加虚拟硬盘 ** 注意：要选 控制器 SATA
选择 创建新的虚拟盘（使用现有磁盘的话，后续就不用格式化、挂载了）
** 因为是学习，所以，全部使用缺省，一路回车即可
2、挂载新硬盘 查看文件系统 （file system）
df -h
Filesystem Size Used Avail Use% Mounted on udev 1.9G 0 1.9G 0% /dev tmpfs 395M 1008K 394M 1% /run /dev/sda2 98G 11G 83G 11% / tmpfs 2.0G 0 2.0G 0% /dev/shm tmpfs 5.0M 0 5.0M 0% /run/lock tmpfs 2.0G 0 2.0G 0% /sys/fs/cgroup /dev/loop0 91M 91M 0 100% /snap/core/6405 /dev/loop1 90M 90M 0 100% /snap/core/6673 /dev/loop2 92M 92M 0 100% /snap/core/6531 Downloads 234G 171G 63G 74% /media/sf_Downloads tmpfs 395M 0 395M 0% /run/user/1000 没有看到我们新建的硬盘，看不到分区信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8234438c6930a8ef525a09808d5c0314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3156c5f75733d1cf4df8817b5ffb387d/" rel="bookmark">
			我的Java学习之路（第十三天）------ 子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法substring会返回一个心得字符串，其中包含已有字符串中从指定索引到末尾的字符；
下面是一个例子
package demo1; public class Test { public static void main(String[] args) { String text = "woshishuaige"; System.out.println(text.substring(0)); System.out.println(text.substring(2)); System.out.println(text.substring(5)); } } 下面是运行结果截图：
我认为理解为把字符串里面每个字符都编号从0-n就很容易理解；
此外，这个方法还有一种用法
package demo1; public class Test { public static void main(String[] args) { String text = "woshishuaige"; System.out.println(text.substring(0,2)); System.out.println(text.substring(2,5)); System.out.println(text.substring(5,10)); System.out.println(text.substring(10,12)); } } 下面是运行截图：很好理解！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7c22917d70c00d70ac183f87ca9bcf1/" rel="bookmark">
			我的Java学习之路（第十三天）------字符串是否可修改（字符串修改问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个问题毫无疑问，答案是否定的！！！
我们知道字符串提供了toUpperCase和tolowerCase来转换大小写的方法，但并不意味着字符串可以修改；
但是一个很有用的方法就是使用replace，它可以在字符串中查找并替换指定的字串。例如下面的代码讲把“aaa”替换为“bbb”；
package demo1; public class Test { public static void main(String[] args) { String text = "aaa"; text = text.replace("aaa", "bbb"); System.out.println(text); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059192c85ba3c0767c0773d1d5254a93/" rel="bookmark">
			JDK8时间类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. JDK8之前的时间日期API
1.1 java.lang.System类
public static native long currentTimeMillis();
用于返回当前时间与1970年1月1日0:0:0之间以毫秒为单位的时间差
时间戳
1.2 java.util.Date类
两个构造器
new Date(); —&gt; 当前时间
new Date(Long 毫秒数) — &gt; 根据毫秒数创建指定日期
两个方法的使用
toString() 显示当前的年,月,日,时,分,秒
getTime() 获取当前date对象的对应的毫秒数(时间戳)
java.util.Date 和java.sql.Date 互相转换
Date date = new java.sql.Date()
java.sql.Date date2 = (java.sql.Date) date;
java.sql.Date date3 = new java.sql.Date(new Date().getTime());
1.3 java.text.SimpleDateFormat类
Date类的API不易于国际化,大部分被废弃,SimpleDateFormat类 一个与语言环境有关的方式来格式化和解析时间的具体类
format() 方法 按照具体的格式格式化时间
parse() 方法将字符串解析成时间
1.4 java.util.Calendar 日历类
获取Calendar的实例
使用其子类 (GregorianCalendar)的对象
使用Calendar.getInstance()
常用方法
set()
calendar.set(Calendar.DAY_OF_MONTH,22) —&gt; 将日期设置为这个月的第几天
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/059192c85ba3c0767c0773d1d5254a93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b876bcf683388b9738ffaba4d2b7931f/" rel="bookmark">
			一个有趣的问题---java.lang.String的&#43;到底做了什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间同学问了我一个有趣的问题：
String str3 = "what"; String str4 = str3 + " a nice day"; //运行时， + 相当于 new，所以堆中会有 "what a nice day"对象，常量池中会有"what"," a nice day"两个对象，而不会有 "what a nice day"对象。 //这句话大佬们看看对不对啊，我怎么感觉不对啊 //常量池不会有"what a nice day" 对象吗？ 看完这个问题，说实话我也是有点懵的，我只是知道 "what a nice day"不会在常量池，但是不知道具体的原因，后来问了同事说 + 号是调用了 StringBuffer 的append 方法。
我去证实了，发现确实调用了 append 方法，但是当时没有调用toString()方法，我很疑惑。（最后经过证实，是StringBuilder的append 方法，不是StringBuffer）。
代码验证：
public static void main(String[] args) { //#1 String str1 = "what"; //#2 String str2 = str1 + " a nice day"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b876bcf683388b9738ffaba4d2b7931f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc98a934e17aa6bc0b3dcd3a9f3350b/" rel="bookmark">
			Opencv之特征匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Brute-Force 蛮力匹配 1、导入需要的库 import cv2 import numpy as np import matplotlib.pyplot as plt %matplotlib inline 2、定义绘图函数 def cv_show(name,img): cv2.imshow(name, img) cv2.waitKey(0) cv2.destroyAllWindows() 3、读入需要进行匹配的两张图片 img1 = cv2.imread('box.png', 0) img2 = cv2.imread('box_in_scene.png', 0) cv_show('img1',img1) cv_show('img2',img2) 展示图片：
4、实例化SIFT函数 sift = cv2.xfeatures2d.SIFT_create() 5、检测特征点并计算特征 kp1, des1 = sift.detectAndCompute(img1, None) print(np.array(kp1).shape) print(np.array(des1).shape) kp2, des2 = sift.detectAndCompute(img2, None) print(np.array(kp2).shape) print(np.array(des2).shape) 可以得到结果：img1中有603个特征点，img2中有969个特征点，因为从img1和img2本身的图像来看，img2中是包含img1的，所以进行特征匹配的时候只会匹配img1和img2共有的603个特征点。
ps：当然，这里也可以分开来做，即先检测特征点再计算特征。即：
kp1 = sift.detect(img1, None) kp2 = sift.detect(img2, None) kp1, des1 = sift.compute(img1, kp1) kp2, des2 = sift.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dc98a934e17aa6bc0b3dcd3a9f3350b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efb98803bae8702ba2162eb8a8effea6/" rel="bookmark">
			足球运动员的数据分析实战(python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、本案例的相关说明 本人把这篇文章拿出来进行写作的主要原因是为了让大家对数据分析有一个较为清楚的认识，其实数据分析并不是那么高深，只是看你怎么从一堆杂乱无章的数据中能够发现一定的有规律性的结论，有时候可能会觉得某些结论有些牵强，但这属于每个人对每个问题而见解不同，因而较强的数据分析能力，需要我们在实际工作中进行慢慢培养出来。同时这篇文章很好的将pandas库运用到其中，这个也可以帮助我们学以致用，用而学，会起到更好的效果。
1、案例背景 足球运动是最受欢迎的运动之一。在此万受瞩目的运动下，打算针对足球运动员个人的信息，技能水平等各项指标进行相关的分析与统计。例如，我们可能会关注如下的内容：
足球运动员是否受出生日期的影响？左撇子适合踢足球吗？足球运动员的号码是否与位置相关？足球运动员的年龄与能力具有怎样的关联？ 2、任务说明 目前，我们收集到了某年现役运动员的数据集data.csv。我们希望通过该数据集，针对众多的足球运动员进行分析与统计，从而能够发现一些关于足球运动员的特征，解开我们上述疑问。
3、数据列名的含义 4、足球场上各位置说明 5、什么是数据分析？ 数据分析指的就是利用统计学知识，对一系列杂乱无章的数据进行数据分析前的预处理，同时结合数据的具体应用场景，提炼出数据中的有效信息，帮助我们定位、分析、解决某些问题，高效决策。
6、数据分析的基本流程 明确需求
数据收集
内部数据
购买数据
爬取数据
调查问卷
数据预处理
数据清洗
缺失值
异常值
重复值
数据转换
数据分析
数据建模
数据可视化
编写报告
7、理解流程 现在网上最常见的一种比喻数据分析流程的方式，就是利用“炒菜”来对比“数据分析的每个流程”。
做菜步骤数据分析步骤确定做菜明确需求与目的买菜数据收集洗菜数据清洗切菜数据转换炒菜数据分析盛菜数据可视化写日记编写报告 1）熟悉数据集 熟悉数据集，就是在进行数据处理之前，应该先熟悉数据，只有对数据充分熟悉之后，才能更好的进行分析。
熟悉数据常用的方法和属性有shape、head()、tail()、sample()、info()、describe()。
shape：以元组形式返回数据集的行、列大小。head()或tail()：当数据量过大时，我们不可能直接查看所有数据，这样会很消耗电脑内存，因此，使用head()或tail()，可以默认返回数据集的前五行、后五行的数据；当向head()或tail()中传入整数n时，则可以返回任意前n行、后n行的数据。sample()：向方法中传入整数n时，则会从当前数据集中随机抽样n条记录显示出来，对于我们了解数据很有帮助。info()：可以显示每列的列名、非空值数量、数据类型，内存占用等信息。describe()：可以帮助我们掌握数值的分布情况，会返回每个字段的count()、mean()、std()、min()、25%、50%、75%、max()。对于非数值型字段，只会显示count()计数。 2）缺失值处理 缺失值就是由于某些原因导致部分数据为空。进行缺失值处理之前，首先应该查看是否有缺失值。
① 检查缺失值的办法：一般有以下两种处理方式；
1、通过info查看数据信息。2、可以通过isnull与sum结合，查看缺失值情况。 data.info() data.isnull().sum(axis=0) ② 缺失值的处理办法：一般也有两种处理方式；
1、直接删除(当某一列或某一行存在大量的缺失值的时候)。2、采用某个值填充。 ③ 直接删除缺失值
采用dropna()方法，默认删除所有含有缺失行的数据（即：某一行只有要一个字段缺失，就删除）。传入参数how=”all”，只删除那些全为空的行。
# inplace=True表示原地修改数据集 data.dropna(axis=0, inplace=True) # 对删除后缺失值后的数据集，再次进行缺失值统计 data.isnull().sum(axis=1) ④ 填充
可以采用均值、中位数、众数、附近值进行填充。
对于缺失值填充，这里做一个简单的说明：1、当数据服从正态分布，这时候可以采用均值填充；2、当数据为偏态分布（不管左偏还是右偏），则采用中位数进行填充；3、若某个字段为离散型数据，则最好采用众数填充；4、若像温度这样的数据，前后时刻之间的温度关联肯定是最大的，这时采用前后时刻温度进行填充更好。
3）异常值处理 异常值：就是和正常数据相比，过高或者过低的数据。
异常值检测：对异常值进行检测，主要有以下几种方式：1、根据业务需求和经验对不同指标所划分的范围，超过指定范围的数据叫做异常值；2、绘制箱线图，大于上边缘和小于下边缘的数据叫做异常值；3、通过descride()函数，可以找出数据的25%和75%分位数，然后把“小于q1+1.5IQR，大于q3+1.5IQR”的数据叫做异常值，q1为25%分位数，q3为75%分位数，IQR= q3- q1的差值。
异常值处理：主要有三种处理办法。1、直接删除；2、把异常值当做缺失值填充；3、把异常值当做特殊情况，研究异常值出现的原因。
4）重复值处理 重复数据，指的是数据集中同样的记录有多条。对于这样的数据一般就是直接删除。
重复值的检测：data.duplicated().sum()可以查看，重复数据有多少行。
重复值的删除：data.drop_duplicates(inplace=True)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efb98803bae8702ba2162eb8a8effea6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6e917439351ca3e9ec869df74346b55/" rel="bookmark">
			queue的pop,top ?! 为什么会有segmentation fault !!!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		忘记是哪一道题了，但是重要的是：要 pop 或者访问 top 元素必须要先看队列是否为空！！！就算用&amp;&amp;连接，empty也要写在前面！！！
就像这样：
if ( !que.empty() &amp;&amp; que.top() == a) // 注意必须要把empty写在前面 que.pop(); if ( !que.empty() ) que.pop(); 别忘了哟~~~~~~~~~~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51e1b0e08a2e4b6d0fc85463bb9dd8a9/" rel="bookmark">
			稀疏表示SRC、协同表示CRC、自适应稀疏表示ASRC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SRC 出处：《Robust Face Recognition via Sparse Representation》
ESRC 考虑到图像里的噪声，提出了Extended SRC(ESRC):
根据每类的残差进行分类
CRC 全称Collaborative Representation based Classification with regularized least square
当样本高度相关时，样本y在各个类的投影可能大致相同，SRC的结果就不稳定。于是CRC提出
数学表达如下
m i n ∥ α ∥ 2 s . t . ∥ y − X α ∥ 2 ≤ ϵ min \|\alpha\|_2\qquad s.t.\|y-X\alpha\|_2\leq\epsilon min∥α∥2​s.t.∥y−Xα∥2​≤ϵ
ASRC 出处：《Robust Face Recognition via Adaptive Sparse Representation》
综合SRC和CRC，提出自适应的稀疏表示方法
数学表达为
m i n ∥ X D i a g ( α ) ∥ ∗ s .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51e1b0e08a2e4b6d0fc85463bb9dd8a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d431a72bfe040a45ca7c2ea9cbae6501/" rel="bookmark">
			我的Java学习之路（第十二天）------字符串的遍历以及字符串的反转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、字符串的遍历
在Java中，字符串提供了提取字符的方法charAt，这个方法会返回一个char，因此我们可以利用这一点来实现字符串的遍历；
package demo1; public class Test_3 { public static void main(String[] args) { String str ="abcdefg"; for(int i=0;i&lt;str.length();i++) { char letter = str.charAt(i); System.out.println(letter); } } } 很通俗的代码，看看就行！
2、字符串的反转
package demo1; public class Test_3 { public static void main(String[] args) { String str ="abcdefg"; String str2 = reverse(str); printArr(str); printArr(str2); } private static void printArr(String str) { for(int i=0;i&lt;str.length();i++) { char letter = str.charAt(i); System.out.print(letter); } System.out.println(""); } public static String reverse(String s) { String a ="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d431a72bfe040a45ca7c2ea9cbae6501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66418912d2a538a21ad74ba44d50e33c/" rel="bookmark">
			python strip()函数和Split函数的用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、python中for循环如何控制步长
2、python strip()函数和Split函数的用法总结
1、python中for循环如何控制步长 for i in range(开始/左边界, 结束/右边界, 步长): print i #例如 for i in range(1, 10, 2): print i #等价于 for (i=1;i&lt;=10;i+=2) 2、python strip()函数和Split函数的用法总结 strip函数原型
声明：s为字符串，rm为要删除的字符序列. 只能删除开头或是结尾的字符或是字符串。不能删除中间的字符或是字符串。
s.strip(rm) 删除s字符串中开头、结尾处，位于 rm删除序列的字符
s.lstrip(rm) 删除s字符串中开头处，位于 rm删除序列的字符
s.rstrip(rm) 删除s字符串中结尾处，位于 rm删除序列的字符
注意：
1. 当rm为空时，默认删除空白符（包括'\n', '\r', '\t', ' ')
例如：
2.这里的rm删除序列是只要边（开头或结尾）上的字符在删除序列内，就删除掉。
例如 ：
字符串的split用法
说明：
Python中没有字符类型的说法，只有字符串，这里所说的字符就是只包含一个字符的字符串！！！
split返回的是一个列表。
首先列出一种常用的情况，不带参数，默认是空白字符。如下：
结果为：
1.按某一个字符分割，如‘.’
str = ('www.google.com') print str str_split = str.split('.') print str_split 结果如下：
2.按某一个字符分割，且分割n次。如按‘.’分割1次
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66418912d2a538a21ad74ba44d50e33c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b03b010263ff4f219f73dc980b60f03e/" rel="bookmark">
			基于SSM框架的Web项目数据库由MySql5升级到MySql8爬坑之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、出现问题1、2、3、其他问题就不再现了 二、问题解决1、环境配置2、pom配置，解决驱动问题3、jdbc连接配置，解决驱动问题到此所有问题就解决了，能帮到各位，请点个赞谢谢 一、出现问题 由于数据库版本的升级，会出现很多问题，解决一个出现另一个。问题
比如
1、 No suitable driver mysql 2、 Unsupported major.minor version 5 3、其他问题就不再现了 二、问题解决 针对第一个问题明显是由于 MySql版本的升级带来的驱动问题，第二个由于Java版本的问题。
1、环境配置 win10JDK 1.7/1.8eclipseMySql 8.0.1 2、pom配置，解决驱动问题 mysql-connector-java:8.0.16 (可以是最新）c3p0:0.9.5.2 (MySql8.0的驱动必须用0.9.5.2以上的c3p0版本）mchange-commons-java:0.2.11 (0.9.5.2以上的c3p0版本,必须有mchange）
Maven中c3p0-0.9.5.2版本可能下载不下来，反正我是没有进入下面连接
https://sourceforge.net/projects/c3p0/ 把下载下来的jar包复制到对应的maven文件夹内
&lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;mchange-commons-java&lt;/artifactId&gt; &lt;version&gt;0.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; 3、jdbc连接配置，解决驱动问题 driver可以是“com.mysql.jdbc.Driver”，也可以是“com.mysql.cj.jdbc.Driver”
亲测可以
datasource.type=mysql datasource.autoCommitOnClose=false datasource.driverClassName=com.mysql.jdbc.Driver datasource.url=jdbc:mysql://127.0.0.1:3306/kedarjxy?useUnicode=true&amp;serverTimezone=UTC&amp;zeroDateTimeBehavior=convertToNull datasource.username=root datasource.password=******** serverTimezone=UTC 这个得加否则会报
The server time zone value '?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b03b010263ff4f219f73dc980b60f03e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b187b029a142942a4cb4afaa73e47cee/" rel="bookmark">
			NPM提示版本依赖报错：No matching version found for
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
升级了VS2015到VS2017,发现gyp竟然不支持(瀑布汗)，找方法双开了，没问题后，执行npm install竟然报错，错误如下：
。。。 5666 silly saveTree `-- yargs-parser@7.0.0 5666 silly saveTree `-- camelcase@4.1.0 5667 warn optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.2.7 (node_modules\chokidar\node_modules\fsevents): 5668 warn notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.11: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"}) 5669 verbose notsup SKIPPING OPTIONAL DEPENDENCY: Valid OS: darwin 5669 verbose notsup SKIPPING OPTIONAL DEPENDENCY: Valid Arch: any 5669 verbose notsup SKIPPING OPTIONAL DEPENDENCY: Actual OS: win32 5669 verbose notsup SKIPPING OPTIONAL DEPENDENCY: Actual Arch: x64 5670 verbose type range 5671 verbose stack mime-db: No matching version found for mime-db@&gt;= 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b187b029a142942a4cb4afaa73e47cee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47f954723de5a5209682c12f3effa795/" rel="bookmark">
			Linux 内存管理篇(2)内核初始化与内存管理启用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 继内存寻址之后， 本篇开始介绍Linux内核地址空间初始化过程。
通过内存寻址篇我们知道， Linux 系统运行过程中位于保护模式,系统必须要是用MMU来完成地址寻址， 这就依赖于段表跟页表。
但是问题来了, 系统是如何将段表跟页表是如何装入的呢？
本文通过 Linux 系统初始化过程，开始介绍内存管理的构建过程。
BIOS 时代: 当PC机加电的那一刻，主机开始获取操作指令，初始化操作系统。
这个时候，系统cpu是运行在实模式(详情见说明)下的, CPU最开始从0xFFFF0 处定位BIOS通过影子内存(详情见说明)定位BIOS第一条指令。
BIOS 就开始地检测内存、显卡等外设信息，当硬件检测通过之后，就在内存的物理内存的起始位置 0x000 ~ 0x3FF建立中断向量表。
然后, BIOS 将启动磁盘中的第1个扇区（MBR 扇区，Master Boot Record）的 512 个字节的数据加载到物理内存地址为 0x7C00 ~ 0x7E00 的区域，然后程序就跳转到 0x7C00 处开始执行，至此，BIOS 就完成了所有的工作，将控制权转交到了 MBR 中的代码。通过MBR加载Linux 内核映像。
实模式运行阶段: 先将内核镜像文件中的起始第一部分 boot/setup.bin 加载到 0x7c00 地址之上的物理内存中，然后跳转到 setup.bin 文件中的入口地址开始执行。
涉及的文件有 arch/x86/boot/header.S、链接脚本setup.ld、arch/x86/boot/main.c。header.S 第一部分定义了 .bstext、.bsdata、.header 这 3 个节，共同构成了vmlinuz 的第一个512字节(即引导扇区的内容)。常量 BOOTSEG 和 SYSSEG 定义了引导扇区和内核的载入的地址。
BOOTSEG = 0x07C0 /* original address of boot-sector */ SYSSEG = 0x1000 /* historical load address &gt;&gt; 4 */ 主要完成的工作:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47f954723de5a5209682c12f3effa795/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/189652fa3489d70434b617be2728e94d/" rel="bookmark">
			python中print用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、print()函数概述 print() 方法用于打印输出，是python中最常见的一个函数。
该函数的语法如下：
print(*objects, sep=' ', end='\n', file=sys.stdout) 参数的具体含义如下：
objects --表示输出的对象。输出多个对象时，需要用 , （逗号）分隔。
sep – 用来间隔多个对象。
end – 用来设定以什么结尾。默认值是换行符 \n，我们可以换成其他字符。
file – 要写入的文件对象。
print(1) #数值类型可以直接输出 ''' 运行结果如下 1 ''' print("Hello World") #字符串类型可以直接输出 ''' 运行结果如下： Hello World ''' a=1 b="Hello World" print(a, b) #可以一次输出多个对象，对象之间用逗号分隔 ''' 运行结果如下： 1 Hello World ''' #如果直接输出字符串，而不是用对象表示的话，可以不使用逗号 print("Duan""Yixuan") print("Duan","Yixuan") ''' 运行结果如下： DuanYixuan Duan Yixuan 可知，不添加逗号分隔符，字符串之间没有间隔 ''' print("www", "snh48", "com", sep=".") # 设置间隔符 ''' 运行结果如下： www.snh48.com ''' 二、变量的输出 无论什么类型的数据，包括但不局限于：数值型，布尔型，列表变量，字典变量…都可以直接输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/189652fa3489d70434b617be2728e94d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d023d02fa6ad597b7d24727a88239cc/" rel="bookmark">
			oracle资源检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、查询执行最慢的sql
select *
from(select sa.SQL_TEXT,
sa.SQL_FULLTEXT,
sa.EXECUTIONS"执行次数",
round(sa.ELAPSED_TIME / 1000000, 2)“总执行时间”,
round(sa.ELAPSED_TIME / 1000000 / sa.EXECUTIONS, 2)“平均执行时间”,
sa.COMMAND_TYPE,
sa.PARSING_USER_ID"用户ID",
u.username"用户名",
sa.HASH_VALUE
from v$sqlarea sa
left join all_users u
on sa.PARSING_USER_ID = u.user_id
where sa.EXECUTIONS &gt; 0
order by(sa.ELAPSED_TIME / sa.EXECUTIONS)desc)
where rownum &lt;= 50;
二、查询次数最多的 sql
select *
from(select s.SQL_TEXT,
s.EXECUTIONS"执行次数",
s.PARSING_USER_ID"用户名",
rank() over(order by EXECUTIONS desc) EXEC_RANK
from v$sql s
left join all_users u
on u.USER_ID = s.PARSING_USER_ID) t
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d023d02fa6ad597b7d24727a88239cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3727f3d70685436a1a40b101a4066590/" rel="bookmark">
			C&#43;&#43;修改WIN10的ip、子网掩码、网关、DNS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码 if (bDHCP) { string strParameter; strParameter ="netsh interface ip set address name=\"本地连接\" source=dhcp"; WinExec(strParameter.c_str(), SW_HIDE); strParameter.clear(); strParameter = "netsh interface ip set dns name=\"本地连接\" source=dhcp"; WinExec(strParameter.c_str(), SW_HIDE); } else { string strParameter; strParameter="netsh interface ip set address name=\"本地连接\" static "; strParameter += T2A(pIPAddress); strParameter += " "; strParameter += T2A(pNetMask); strParameter += " "; strParameter += T2A(pNetGate); strParameter += " "; strParameter += "1"; if (WinExec(strParameter.c_str(), SW_HIDE) &gt; 32) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3727f3d70685436a1a40b101a4066590/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ca36554b9a32a6f42a28edbc99d6df7/" rel="bookmark">
			使可执行文件以管理员权限运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10权限 SHELLEXECUTEINFO ShExecInfo = {0}; ShExecInfo.cbSize = sizeof(SHELLEXECUTEINFO); ShExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS; ShExecInfo.hwnd = NULL; ShExecInfo.lpVerb = LPCSTR("runas"); ShExecInfo.lpFile = LPCSTR("cmd"); ShExecInfo.lpParameters = LPCSTR(""); ShExecInfo.lpDirectory = NULL; ShExecInfo.nShow = SW_SHOW; ShExecInfo.hInstApp = NULL; ShellExecuteEx(&amp;ShExecInfo); 运行效果 直接运行cmd效果下图:
上述代码运行之后效果:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa7eed8cde2081fb8f8306687900917/" rel="bookmark">
			机器学习算法之_逻辑斯蒂回归（Logistics）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逻辑斯蒂回归虽然名字叫回归，但是其实分类， 而且这个分类很强大（以后工作是必须要用的（分类问题））。逻辑回归假设数据服从伯努利分布,通过极大化似然函数的方法，运用梯度下降来求解参数，来达到将数据二分类的目的。
【关键词】Logistics函数，最大似然估计，梯度下降法 一.原理 利用Logistics回归进行分类的主要思想是：根据现有数据对分类边界线建立回归公式，以此进行分类。这里的“回归” 一词源于最佳拟合，表示要找到最佳拟合参数集。训练分类器时的做法就是寻找最佳拟合参数，使用的是最优化算法。接下来介绍这个二值型输出分类器的数学原理
1.实现步骤 Logistic Regression和Linear Regression的原理是相似的，可以简单的描述为这样的过程：
（1）找一个合适的预测函数，一般表示为h函数，该函数就是我们需要找的分类函数，它用来预测输入数据的判断结果。这个过程是非常关键的，需要对数据有一定的了解或分析，知道或者猜测预测函数的“大概”形式，比如是线性函数还是非线性函数。
（2）构造一个Cost函数（损失函数），该函数表示预测的输出（h）与训练数据类别（y）之间的偏差，可以是二者之间的差（h-y）或者是其他的形式。综合考虑所有训练数据的“损失”，将Cost求和或者求平均，记为J(θ)函数，表示所有训练数据预测值与实际类别的偏差。
（3）显然，J(θ)函数的值越小表示预测函数越准确（即h函数越准确），所以这一步需要做的是找到J(θ)函数的最小值。找函数的最小值有不同的方法，Logistic Regression实现时有梯度下降法（Gradient Descent）。
二、构造函数 1 构造预测函数
logistic Regression虽然名字里带“回归”，但是它实际上是一种分类方法，用于两分类问题（即输出只有两种）。首先需要先找到一个预测函数（h），显然，该函数的输出必须是两类值（分别代表两个类别），所以利用了Logistic函数（或称为Sigmoid函数），函数形式为
2构造损失函数
Cost函数和J(θ)函数是基于最大似然估计推导得到的。
最大似然估计就是要求得使l(θ)取最大值时的θ，其实这里可以使用梯度上升法求解，求得的θ就是要求的最佳参数
3梯度下降法求J(θ)的最小值
求J(θ)的最小值可以使用梯度下降法，根据梯度下降法可得θ的更新过程:
三、逻辑斯蒂回归算法的优缺点及常见问题 1、优点 形式简单，模型的可解释性非常好。从特征的权重可以看到不同的特征对最后结果的影响，某个特征的权重值比较高，那么这个特征最后对结果的影响会比较大；
模型效果不错。在工程上是可以接受的（作为baseline)，如果特征工程做的好，效果不会太差，并且特征工程可以大家并行开发，大大加快开发的速度；
训练速度较快。分类的时候，计算量仅仅只和特征的数目相关。并且逻辑回归的分布式优化sgd发展比较成熟，训练的速度可以通过堆机器进一步提高，这样我们可以在短时间内迭代好几个版本的模型；
资源占用小,尤其是内存。因为只需要存储各个维度的特征值；
方便输出结果调整。逻辑回归可以很方便的得到最后的分类结果，因为输出的是每个样本的概率分数，我们可以很容易的对这些概率分数进行cutoff，也就是划分阈值(大于某个阈值的是一类，小于某个阈值的是一类)。
2、缺点 准确率并不是很高。因为形式非常的简单(非常类似线性模型)，很难去拟合数据的真实分布；
很难处理数据不平衡的问题。举个例子：如果我们对于一个正负样本非常不平衡的问题比如正负样本比 10000:1.我们把所有样本都预测为正也能使损失函数的值比较小。但是作为一个分类器，它对正负样本的区分能力不会很好；
处理非线性数据较麻烦。逻辑回归在不引入其他方法的情况下，只能处理线性可分的数据，或者进一步说，处理二分类的问题；
逻辑回归本身无法筛选特征。有时候，我们会用gbdt来筛选特征，然后再上逻辑回归。
3、常见问题 （1）逻辑回归的损失函数为什么要使用极大似然函数作为损失函数？
损失函数一般有四种，平方损失函数，对数损失函数，HingeLoss0-1损失函数，绝对值损失函数。将极大似然函数取对数以后等同于对数损失函数。在逻辑回归这个模型下，对数损失函数的训练求解参数的速度是比较快的。 因为目标是要让预测为正的的概率最大，且预测为负的概率也最大，即每一个样本预测都要得到最大的概率，将所有的样本预测后的概率进行相乘都最大，这就能到似然函数了。
（2）逻辑回归在训练的过程当中，如果有很多的特征高度相关或者说有一个特征重复了100遍，会造成怎样的影响？
如果在损失函数最终收敛的情况下，其实就算有很多特征高度相关也不会影响分类器的效果。
（3）为什么我们还是会在训练的过程当中将高度相关的特征去掉？
去掉高度相关的特征会让模型的可解释性更好，可以大大提高训练的速度。如果模型当中有很多特征高度相关的话，就算损失函数本身收敛了，但实际上参数是没有收敛的，这样会拉低训练的速度。其次是特征多了，本身就会增大训练的时间。
（4）使用L1L2正则化，为什么可以降低模型的复杂度？
模型越复杂，越容易过拟合，这大家都知道，加上L1正则化给了模型的拉普拉斯先验，加上L2正则化给了模型的高斯先验。从参数的角度来看，L1得到稀疏解，去掉一部分特征降低模型复杂度。L2得到较小的参数，如果参数很大，样本稍微变动一点，值就有很大偏差，这当然不是我们想看到的，相当于降低每个特征的权重。
（5）为什么L1能得到稀疏解呢？
L1正则化是L1范数而来，投到坐标图里面，是棱型的，最优解在坐标轴上取到，所以某些部分的特征的系数就为0。
（6）L1正则化不可导，怎么求解？
坐标轴下降法（按照每个坐标轴一个个使其收敛），最小角回归（是一个逐步的过程，每一步都选择一个相关性很大的特征，总的运算步数只和特征的数目有关，和训练集的大小无关）
四、实战 sklearn.linear_model.LogisticRegression(penalty=‘l2’, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver=‘liblinear’, max_iter=100, multi_class=‘ovr’, verbose=0, warm_start=False, n_jobs=1)
solver参数的选择：
“liblinear”：小数量级的数据集 “lbfgs”,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fa7eed8cde2081fb8f8306687900917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67f51ba9f79d555bb41f469c747a843b/" rel="bookmark">
			python使用opencv实现图像的重映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重映射的概念：把一副图像内的像素点放置到另外一副图像内的指定位置，这个过程叫做重映射
重映射可以实现的功能有，图片的复制，图片绕x轴翻转，绕y轴翻转，绕xy轴翻转，x和y轴互换等功能
现在举一个简单的例子，利用重映射实现图片的复制
import cv2 import numpy as np img = cv2.imread('../data/1.jpg', 1) mapx = np.zeros(img.shape[:2], dtype=np.float32) mapy = np.zeros(img.shape[:2], dtype=np.float32) rows, cons = img.shape[:2] for i in range(rows): for j in range(cons): mapx.itemset((i, j), j) mapy.itemset((i, j), i) rst = cv2.remap(img, mapx, mapy, cv2.INTER_LINEAR) # mapy表示的是图片高的坐标 cv2.imshow('rst', rst) cv2.waitKey() cv2.destroyAllWindows() 原图
效果图和原图相同
这个函数的重点是计算映射矩阵mapx和mapy，但是我觉得重映射的功能很鸡肋，不知道有木有大神告诉我重映射的优点是什么
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80db05a19cac2ff9b75ff28eb2041798/" rel="bookmark">
			我的Java学习之路（第九天）------ 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(参考网易云课堂：龙马高新教育)
1、方法的基本定义
修饰符 返回值类型 方法名（参数列表）{
方法体
[return 返回值]
}
🌂比如下面这个例子：
package demo1; public class T1 { public static int max(int num1,int num2) { int result; if(num1&gt;num2) { result = num1; }else { result = num2; } return result; } } 2、方法的使用
Add:this代表本类对象
哪个对象调用这个方法this就是它；
比如Person p1 = new Person(); 此时this代表p1；
Person.java
package demo2; public class Person { String name; int age; void talk() { System.out.println("冲冲冲！！！"); System.out.println("我是"+name+"今年"+age+"岁"); } //当局部变量与成员变量重名的时候用this区分 void setName(String name){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80db05a19cac2ff9b75ff28eb2041798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e8fdae7458fb212dbe2325c2e5348c/" rel="bookmark">
			LeetCode 刷题记录 95. Unique Binary Search Trees II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.
Example:
Input: 3
Output:
[
[1,null,3,2],
[3,2,null,1],
[3,1,null,null,2],
[2,1,3],
[1,null,2,null,3]
]
Explanation:
The above output corresponds to the 5 unique BST’s shown below:
1 3 3 2 1
\ / / / \ 3 2 1 1 3 2
/ / \ 2 1 2 3
解法：
递归法：
1 … n.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43e8fdae7458fb212dbe2325c2e5348c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d509b58f4e47c9094c0df4326512f251/" rel="bookmark">
			xen虚拟机的启动（引导）方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xen虚拟机的启动（引导）方式
有几种不同的方式来引导虚拟机，各有利弊。
1.BIOS bootloader
适用于全虚拟化，loader模拟了BIOS
原文：
Booting via the BIOS is available for hypervisors supporting full virtualization. In this case the BIOS has a boot order priority (floppy, harddisk, cdrom, network) determining where to obtain/find the boot image.
...
&lt;os&gt;
&lt;type&gt;hvm&lt;/type&gt;
&lt;loader&gt;/usr/lib/xen/boot/hvmloader&lt;/loader&gt;
&lt;boot dev='hd'/&gt;
&lt;boot dev='cdrom'/&gt;
&lt;bootmenu enable='yes'/&gt;
&lt;smbios mode='sysinfo'/&gt;
&lt;/os&gt;
...
type
The content of the type element specifies the type of operating system to be booted in the virtual machine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d509b58f4e47c9094c0df4326512f251/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60f9f4197d3bdaaa663e5af47863088c/" rel="bookmark">
			LTE中的算术题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. RSRP及RSRQ计算
RSRP=-140+RsrpResult（dBm）；
-44&lt;=RSRP&lt;-140dbm
0&lt;= RsrpResult&lt;=97
下行解调门限：18.2dBm来计算的话，下行支持的最小RSRP为18.2-130.8= -112.6
下行解调门限：上行支持的最小RSRP为23-126.44= -103.44dBm
RSRQ=-20+1/2RsrqResult（dB）
RSRQ=N×RSRP/(E-UTRA carrier RSSI)，即RSRQ =10log10(N) + UE所处位置接收到主服务小区的RSRP – RSSI。
RSRQ=20+RSRP – RSSI
-3&lt;=RSRQ&lt;=-19.5 2. W及dBm换算
“1个基准”：30dBm=1W
“2个原则”：
a:+3dBm，功率乘2倍；-3dBm，功率乘1/2 33dBm=30dBm+3dBm=1W×2=2W
27dBm=30dBm-3dBm=1W×1/2=0.5W b:+10dBm，功率乘10倍；-10dBm，功率乘1/10 40dBm=30dBm+10dBm=1W×10=10W 20dBm=30dBm-10dBm=1W×0.1=0.1W 3. 功率计算
其中max transmissionpower = 43dBm 等效于20W Partofsectorpower=100(%) ;confOutputpower=20(W)
Sectorpower=20(W)
需确保 Sectorpower=confOutputpower*Partofsectorpower*% 如Partofsectorpower=50(%) ; confOutputpower=40(W) Sectorpower(20W)=confOutputpower(40W)*Partofsectorpower(50%)
4.参考信号接收功率计算
RSRP功率=RU输出总功率-10lg(12*RB个数) , 如果是单端口20W的RU,那么可以推算出,RSRP功率为43-10lg1200=12.2dBm.
a:A类符号指整个OFDM符号子载波上没有RS符号，位于时隙的索引为1、2、3、5、6（常规CP、2端口），2、3、5、6（常规CP、 4端口）。
b:B类符号指整个OFDM符号子载波上有RS符号，位于时隙索引0、4（常规CP、2端口），0、1、4（常规CP、 4端口）。
c:βA表征没有导频的OFDM symbol（A类符号）的数据子载波功率（和导频子载波功率的比值）。
d:βB表征有导频的OFDM symbol （B类符号）的数据子载波功率（和导频子载波功率的比值）。
5. 上下行频率计算
下行频点：FDL = FDL_low + 0.1(NDL – NOffs-DL)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60f9f4197d3bdaaa663e5af47863088c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcaa5c82bbee1003130d2e2873348012/" rel="bookmark">
			PTA 日期格式化   (天梯赛真题集)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述：
世界上不同国家有不同的写日期的习惯。比如美国人习惯写成“月-日-年”，而中国人习惯写成“年-月-日”。下面请你写个程序，自动把读入的美国格式的日期改写成中国习惯的日期。
输入格式：
输入在一行中按照“mm-dd-yyyy”的格式给出月、日、年。题目保证给出的日期是1900年元旦至今合法的日期。
输出格式：
在一行中按照“yyyy-mm-dd”的格式给出年、月、日。
输入样例：
03-15-2017 输出样例：
2017-03-15 用字符串：
#include &lt;bits/stdc++.h&gt; using namespace std; int main() { string date; string str; cin&gt;&gt;str; date = str.substr(6);//取子串，将str中第六个字符后的所有子串组成一个新串赋给date date = date.insert(4,"-");//插入字符串，在date的第四个字符后插入 date = date.insert(5,str.substr(0,5));//在date的第五个字符后插入str的第一到第六个字符组成的字符串 cout&lt;&lt;date; return 0; } 用数字：
#include &lt;bits/stdc++.h&gt; using namespace std; int main() { int year,month,day; scanf("%d-%d-%d",&amp;month,&amp;day,&amp;year); printf("%d-%02d-%02d",year,month,day); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94bd403b5696d91a1604bc5f74112b32/" rel="bookmark">
			java获取当前日期和后一天的日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 System.out.println("String类型 "+endDate);　//页面传递到后台的时间 为String类型
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Date sDate = sdf.parse(endDate); System.out.println("String类型转Date类型 "+sDate);　//要实现日期+1 需要String转成Date类型 Format f = new SimpleDateFormat("yyyy-MM-dd"); System.out.println("Date结束日期:" + f.format(sDate)); Calendar c = Calendar.getInstance(); c.setTime(sDate); c.add(Calendar.DAY_OF_MONTH, 1); //利用Calendar 实现 Date日期+1天 sDate = c.getTime(); System.out.println("Date结束日期+1 " +f.format(sDate));　//打印Date日期,显示成功+1天 SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd"); endDate = sdf1.format(sDate); System.out.println("Date类型转String类型 "+endDate);　//将日期转成String类型 方便进入数据库比较 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24a972962e634765257a5b50c2de4d5a/" rel="bookmark">
			我的Java学习之路（第七天）------数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(参考网易云课堂：龙马高新教育)
一、一维数组
定义：类型[ ] 数组名 = new 类型[长度]；
数组中存有默认值0，而在引用类型[ ]中为null;
如果在定义前，已经知道数组里存放的内容，那可以简单定义为：
类型[ ] 数组名 = {值1，值2，…，值n}；
类型[ ] 数组名 = new 类型[ ]{值1，值2，…，值n}；
Add:
动态初始化如：int[ ] array = new int[4];
静态初始化如：int[] array = new int[]{1,2,3,4};
但是像int[] array = new int[3]{1，2，3};就是错误的写法
这样也是错的，int[ ] array；array[ ] = {1,2,3};也是错的！！！
而这样是可以的：把String names[ ] = new String[ ]{“加油”，“冲呀”}；
拆为：String names[ ] ；和 names[ ] = new String[ ]{“加油”，“冲呀”}；
这里老师拓展了一个知识点：就是创建一个随机的数组
package demo; import java.util.Random; //导入包 public class Tst_1 { public static void main(String[] args) { Random rand = new Random(); int[] a = null; a = new int[rand.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24a972962e634765257a5b50c2de4d5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7ef90036ce7b6d232c1691ac7449e9a/" rel="bookmark">
			Matlab quiver函数用法 - 画矢量箭头图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提要：
quiver (x, y,u,v)在点（x,y）处画(u,v)所定义的向量箭头。x,y,u,v必须是维度和元素数都一样的矩阵。如果是一维数组的话，x,y,u,v的元素数必须一致。quiver函数会自动调整箭头的长度以适应显示quiver(x,y,u,v,scale)scale 用于限定箭头的长度，如果scale = 1 则等值显示矢量的长度，而scale = 0.2 则显示0.2倍的矢量长度。quiver(u,v)在x-y平面上均匀地画箭头图quiver(x,y,u,v,LinSpec)用于限定箭头的属性，比如颜色，线型等。 quiver就是“箭筒，箭套”的意思
quiver用于画矢量函数的箭头图(也叫速度图）（quiver plot, velocity vector plot)
举一个矢量函数的例子：
F ⃗ = i ⃗ x + j ⃗ y \vec{F}=\vec{i}x+\vec{j}y F =i x+j ​y
如下图，你可以把这个函数看作位置矢量 r ⃗ \vec{r} r ，图中每一个箭头的方向都是向径（即从原点出发的一条直线),并且它的长度等于它到原点的距离。
quiver (x, y,u,v)在点（x,y）处画(u,v)所定义的向量箭头。x,y,u,v必须是维度和元素数都一样的矩阵。如果是一维数组的话，x,y,u,v的元素数必须一致。quiver函数会自动调整箭头的长度以适应显示。
%% draw the velocity vector arrow of the vector function i*x + j*y % generate grids in a sub-definition area clc x = -1:0.5:1; y = -1:0.5:1; % generate the function values u = x; v = y; % draw vector arrow graph quiver(x, y, u, v) text(0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7ef90036ce7b6d232c1691ac7449e9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/039100b43aa5f550092297dd893569fb/" rel="bookmark">
			看完这篇HTTP，跟面试官扯皮就没问题了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是一名程序员，我的主要编程语言是 Java，我更是一名 Web 开发人员，所以我必须要了解 HTTP，所以本篇文章就来带你从 HTTP 入门到进阶，看完让你有一种恍然大悟、醍醐灌顶的感觉。
最初在有网络之前，我们的电脑都是单机的，单机系统是孤立的，我还记得 05 年前那会儿家里有个电脑，想打电脑游戏还得两个人在一个电脑上玩儿，及其不方便。我就想为什么家里人不让上网，我的同学 xxx 家里有网，每次一提这个就落一通批评：xxx上xxx什xxxx么xxxx网xxxx看xxxx你xxxx考xxxx的xxxx那xxxx点xxxx分。虽然我家里没有上网，但是此时互联网已经在高速发展了，HTTP 就是高速发展的一个产物。
认识 HTTP 首先你听的最多的应该就是 HTTP 是一种 超文本传输协议(Hypertext Transfer Protocol)，这你一定能说出来，但是这样还不够，假如你是大厂面试官，这不可能是他想要的最终结果，我们在面试的时候往往把自己知道的尽可能多的说出来，才有和面试官谈价钱的资本。那么什么是超文本传输协议？
超文本传输协议可以进行文字分割：超文本（Hypertext）、传输（Transfer）、协议（Protocol），它们之间的关系如下
按照范围的大小 协议 &gt; 传输 &gt; 超文本。下面就分别对这三个名次做一个解释。
什么是超文本 在互联网早期的时候，我们输入的信息只能保存在本地，无法和其他电脑进行交互。我们保存的信息通常都以文本即简单字符的形式存在，文本是一种能够被计算机解析的有意义的二进制数据包。而随着互联网的高速发展，两台电脑之间能够进行数据的传输后，人们不满足只能在两台电脑之间传输文字，还想要传输图片、音频、视频，甚至点击文字或图片能够进行超链接的跳转，那么文本的语义就被扩大了，这种语义扩大后的文本就被称为超文本(Hypertext)。
什么是传输 那么我们上面说到，两台计算机之间会形成互联关系进行通信，我们存储的超文本会被解析成为二进制数据包，由传输载体（例如同轴电缆，电话线，光缆）负责把二进制数据包由计算机终端传输到另一个终端的过程（对终端的详细解释可以参考 你说你懂互联网，那这些你知道么？这篇文章）称为传输(transfer)。
通常我们把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。请求方和应答方可以进行互换，请求方也可以作为应答方接受数据，应答方也可以作为请求方请求数据，它们之间的关系如下
如图所示，A 和 B 是两个不同的端系统，它们之间可以作为信息交换的载体存在，刚开始的时候是 A 作为请求方请求与 B 交换信息，B 作为响应的一方提供信息；随着时间的推移，B 也可以作为请求方请求 A 交换信息，那么 A 也可以作为响应方响应 B 请求的信息。
什么是协议 协议这个名词不仅局限于互联网范畴，也体现在日常生活中，比如情侣双方约定好在哪个地点吃饭，这个约定也是一种协议，比如你应聘成功了，企业会和你签订劳动合同，这种双方的雇佣关系也是一种 协议。注意自己一个人对自己的约定不能成为协议，协议的前提条件必须是多人约定。
那么网络协议是什么呢？
网络协议就是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为网络协议。
没有网络协议的互联网是混乱的，就和人类社会一样，人不能想怎么样就怎么样，你的行为约束是受到法律的约束的；那么互联网中的端系统也不能自己想发什么发什么，也是需要受到通信协议约束的。
那么我们就可以总结一下，什么是 HTTP？可以用下面这个经典的总结回答一下： HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范
与 HTTP 有关的组件 随着网络世界演进，HTTP 协议已经几乎成为不可替代的一种协议，在了解了 HTTP 的基本组成后，下面再来带你进一步认识一下 HTTP 协议。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/039100b43aa5f550092297dd893569fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdcc6a47f74829fd89664282ab3cf40e/" rel="bookmark">
			java多线程之--(3)线程状态锁阻塞&#43;计时等待&#43;无限等待详解&#43;(图解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中， 有几种状态呢？下面介绍一下常见的线程状态及等待唤醒机制
1. 线程状态概述 我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间的转换问题
先列出各个线程状态,下面会详细讲解
线程状态导致状态发生改变的条件NEW(新建)线程刚被创建,但是并未启动,还没有调用start方法Runnable(可运行)线程可以在java虚拟机中运行的状态,可能正在运行自己代码,也可能没有,这取决于操作系统处理器Blocked(锁阻塞)当一个线程试图获取一个对象锁,而该对象锁被其他的线程持有,则该线程进入Blocked状态；当该线程持有锁时,该线程将变成Runnable状态Timed Waiting(计时等待)同waiting状态,有几个方法有超时参数,调用他们将进入Timed Waiting状态,这一状态将一直保持到超时期满或者接收到唤醒通知,带有超时参数的常用方法有Thread.sleep、锁对象.wait()Waiting(无限等待)一个线程在等待另一个线程执行一个(唤醒)动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒Teminated(被终止)因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡 1.1 BLOCKED锁阻塞 Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。 我们已经学完同步机制，那么这个状态是非常好理解的了。
比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。 这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，而这部分内容作为扩充知识点带领大家了解一下
BLOCKED 线程状态图
1.2 Timed Waiting 计时等待 Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？ 在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就 强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。 其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)
举例说明:
实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串 /** * @Description * @auther 宁宁小可爱 * @create 2020-01-10 13:02 */ public class ThreadDemo { public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { if (i % 10 == 0){ System.out.println("-----------------" + i); } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdcc6a47f74829fd89664282ab3cf40e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64004c0e72a94d906aeb0d4f1376e936/" rel="bookmark">
			MyBatis项目实战 快速将MySQL转换成Oracle语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 因项目需求，小编要将项目从mysql迁移到oracle中 ~
之前已经完成 数据迁移 (https://zhengqing.blog.csdn.net/article/details/103694901)
现在将完成 基于MyBatis-Plus将项目中的MySQL语句全部转换成Oracle语句
大概实现步骤： 将项目改成支持双库配置(因项目基于mysql数据库已经全部完成，也不想直接替换掉，于是新增oracle库，让整个项目可支持多个数据库，这里不是多数据源哦！)Oracle中创建常用函数遍历项目中的xxxMapper.xml文件，找到mysql与oracle语句的区别，然后替换绝大部分SQL最后将一些特殊的mysql语句手动修改为oracle语句 二、MyBatis-Plus 支持双库配置 【mysql，oracle】 1、application.yml中配置mybatis-plus的database-id # mybatis-plus配置 mybatis-plus: configuration: jdbc-type-for-null: 'null' # 解决oracle更新数据为null时无法转换报错 database-id: oracle # 支持多库配置 mysql,oracle 2、MybatisPlus核心配置文件 -&gt; 根据不同的数据库厂商执行不同的SQL @Configuration @MapperScan("com.zhengqing.demo.modules.**.mapper*") public class MybatisPlusConfig { /** * `xxxMapper.xml`文件中的`databaseId`会自动识别使用的数据库类型与这里相对应 * 注: 如果没有指定`databaseId`则该SQL语句适用于所有数据库哦~ * * databaseIdProvider：支持多数据库厂商 * VendorDatabaseIdProvider: 得到数据库厂商的标识(驱动getDatabaseProductName())，mybatis就能根据数据库厂商标识来执行不同的sql; * MySQL，Oracle，SQL Server,xxxx */ @Bean public DatabaseIdProvider getDatabaseIdProvider(){ DatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider(); Properties properties = new Properties(); // 为不同的数据库厂商起别名 properties.setProperty("MySQL","mysql"); properties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64004c0e72a94d906aeb0d4f1376e936/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2c357b5494f4dd062d502406fddbc17/" rel="bookmark">
			Centos7开放及查看端口记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、开放端口 firewall-cmd --zone=public --add-port=8080/tcp --permanent # 开放8080端口 firewall-cmd --zone=public --remove-port=8080/tcp --permanent #关闭8080端口 # 配置立即生效 firewall-cmd --reload # 或者 systemctl restart firewalld.service 2、查看防火墙所有开放的端口 firewall-cmd --list-ports 3.、关闭防火墙 如果要开放的端口太多，嫌麻烦，可以关闭防火墙，安全性自行评估
systemctl stop firewalld.service 4、查看防火墙状态 firewall-cmd --state 5、查看监听的端口 netstat -lnpt # PS:centos7默认没有 netstat 命令，需要安装 net-tools 工具，yum install -y net-tools 6、检查端口被哪个进程占用 netstat -lnp | grep 8080 7、查看进程的详细信息 ps 6832 8、中止进程 kill -9 6832 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9492a63f4244fa1e42bbd7da5d21ee3/" rel="bookmark">
			ENVI5.3安装过程及常见问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装过程
（1）找到下图的应用程序，打开该应用程序；
（2）弹出以下窗口点击“是”，然后进入后续过程，具体如下图所示；
（3）上述结束，点击next，进入下一步，点击接受许可，点击next，选择文件安装的位置我这里安装在F盘, 点击next，然后默认点击next，等待安装结果，选择稍后重启电脑。具体如下图所示；
（4）许可安装过程：提示是否立即运行许可，点击“是”，然后选择Install a license you have received点击next,导入许可文件，点击Finish完成许可安装。具体如下图所示；
（5）破解过程：找到破解文件下→Exelis→IDL85→bin→bin.x86_64→idl.dll，将这个idl.dll复制，粘贴到安装目录ENVI→IDL85→bin→bin.x86_64里面，替换原有文件。
（6）ENVI能正常打开，程序安装完成；
2、安装过程出现问题
（1）、出现The installation
of msvc_2005_sp1_x86 has failed。setup will now exit这样的错误，或者The installation of MSVC_2010_SP1_x64_32bit has failed。setup will now exit这样的错误，如图所示；
解决方案：
①首先下载安装windows
installer clean up（可在softonic官网下载）
②打开windows installer
clean up，对于2005_sp1_x64的错误选择如图1所示，点击Remove移除。 同理MSVC_2010_SP1_x64如图2所示，点击Remove移除.
（2）ENVI启动过程中出现下图1和图2所示的问题：即图1的无效的许可证文件，许可文件不能用，图2的idl.dll文件缺失。
解决方案：
①保证在断网的情况下；
②进入到ENVI的安装目录下打开License Wizard重复上述的许可文件导入和破解的步骤即可以解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09cbfa53bf737329adac7d0f49721b25/" rel="bookmark">
			如何限制用户登录到域计算机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登录到属性对于内置域管理员Administrator无效。
默认情况下，创建新的Active Directory用户时，它们会自动添加到“ 域用户”组中。反过来，默认情况下，将域用户组加入AD域后，会将其添加到域工作站上的本地用户组。这意味着任何域用户都可以登录到域网络中的任何计算机。在本文中，我们将考虑如何限制用户登录到域计算机的主要方法。
内容：
限制用户帐户仅登录到特定的AD计算机如何在PowerShell中修改LogonWorkstations属性？如何限制用户使用GPO登录到AD工作站？ 限制用户帐户仅登录到特定的AD计算机
在小型域中，可以在Active Directory中每个用户帐户的属性中将用户登录限制为域计算机。例如，您要只允许特定用户登录其计算机。去做吧：
通过运行dsa.msc命令来运行ADUC管理单元（Active Directory用户和计算机）。使用AD搜索，找到要限制访问的用户帐户并打开其属性；转到“ 帐户”标签，然后单击“ 登录到”按钮。如您所见，允许用户登录到所有域计算机（用户可以登录到：所有计算机）。要只允许用户访问特定的计算机，请选择“以下计算机”选项并添加用户可以登录的计算机的名称； 注意。您必须指定完整的NetBIOS或DNS计算机名称（不要使用通配符）。该值不区分大小写。
您最多可以将64台计算机添加到此列表。如果您尝试添加65 个计算机，将出现如下错误信息：This property is limited to 64 values. You must remove some of the existing values before you can add new ones;保存更改。现在，用户只能登录到指定的AD计算机。 如何在PowerShell中修改LogonWorkstations属性？
手动将用户登录限制为域计算机是非常麻烦的。您可以使用PowerShell自动执行此操作。允许用户登录的计算机列表存储在AD用户属性“ LogonWorkstations ”中。例如，我们的任务是允许特定用户仅登录到名称在文本文件computers.csv中列出的计算机。
该脚本如下所示：
Import-Module ActiveDirectory
$ADusername = ‘asmith’
$complist = Import-Csv -Path "C:\PS\computers.csv" | ForEach-Object {$_.NetBIOSName}
$comparray = $complist -join ","
Set-ADUser -Identity $ADusername -LogonWorkstations $comparray
Clear-Variable comparray
使用Get-ADUser cmdlet，可以显示允许用户登录的计算机的列表。
Get-ADUser $ADusername -Properties LogonWorkstations | Format-List Name, LogonWorkstations
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09cbfa53bf737329adac7d0f49721b25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20847ce1b507d4cd7c34c282132b1869/" rel="bookmark">
			@ConfigurationProperties(prefix = )异常报错解决方案：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 读取shiro配置文件时出错！
分析原因：
SpringBoot需要读取配置文件.yml时，需要添加此注解：
@ConfigurationProperties(prefix = "shiro") 这个注解的意思就是查找配置文件里，前缀为shiro的配置信息：
但是有时会出现不知道哪个地方引用这个配置文件，所以需要特别指明哪个类使用这个配置信息：
解决方法：
添加注解@EnableConfigurationProperties(当前类文件.class) @EnableConfigurationProperties(ShiroProperties.class) @ConfigurationProperties(prefix = "shiro") @Data class ShiroProperties { private String hashAlgorithmName="md5"; private Integer hashIterations=2; private String loginUrl; private String unauthrizedUrl; private String [] anonUrls; private String logoutUrl; private String [] authcUrls; } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/382/">«</a>
	<span class="pagination__item pagination__item--current">383/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/384/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>