<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd54f28b35b0aaaebe4ca5ccba04397e/" rel="bookmark">
			Midjourney教程(一)——如何使用Midjourney
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Midjourney教程——如何使用Midjourney 注册 登陆Midjourney官网https://www.midjourney.com/home/注册Discord账号，注册完成后登陆即可 在Midjourney的公共服务器中使用 注册并进入到Discord的Midjourney的服务器后，你会看到如下界面，选择左侧的Midjourney服务器(帆船图标)并选择newbies-XXX的频道
在聊天窗口中输入/imagine，在弹出的prompt中输入你想生成的图片信息(注意只能用英文)后按回车
发送后你会看到Midjourney机器人重复了你刚刚说的话，并且状态是(Waiting to start)，这说明你的prompt已经被服务器接受了，正在等待生成图片
稍等片刻你会看到生成了一张模糊不清的图，并且后面有个百分比，这说明midjourney正在帮你生成图片
当看到图片下方有U1、V1等等的按钮时，说明图片已经生成公共啦
Upscale 第一排的四个按钮是upscale按钮。默认生成的4张图是512*512分辨率的，如果你想要生成更加清晰的图片就可以点击下方的U按钮，U1、U2、U3、U4分别代表左上、右上、左下、右下的图片
Variation 第二排的四个按钮是variation按钮。点击variation按钮后midjourney会根据你选择的图片重新生成4张相似的图片
Re-roll 🔄是re-roll按钮，点击后midjourney会根据你的prompt重新生成4张图片。
在自己的服务器中使用Midjourney 如果不希望在公共频道中生成图片，就需要创建自己的服务器了，这也十分简单。
创建服务器 点击最左侧的“+”号,然后选择Create My Own，然后选择For me and my friends. 填写自己的服务器名称就创建成功。
然后回到Midjourney的图片把Midjourney添加到自己的服务器
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GStdVUeK-1681011893190)(Midjourney%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Midjourney%201c4b053f78c9482c998f8a618504a055/Untitled%206.png)]
然后你就可以在自己的服务器中使用Midjourney啦
最后我们一起来看下我花了30秒生成出来的凌晨的杭州街道吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/955924b61e3c02f14bace213dc51fd16/" rel="bookmark">
			docker方式搭建、配置gitLab（傻瓜式、完整）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 一、拉取镜像1、查看GitLab存在的镜像2.拉取镜像3.查看镜像 二、启动Gitlab容器三、修改配置四、查看是否配置成功五、修改root用户登录六、完成gitLab图形化操作平台 一、拉取镜像 1、查看GitLab存在的镜像 # 查找Gitlab镜像 docker search gitlab 2.拉取镜像 # 拉取Gitlab镜像 docker pull gitlab/gitlab-ce:latest 3.查看镜像 # 查看Gitlab镜像 docker images 二、启动Gitlab容器 # 启动容器 docker run \ -itd \ -p 9980:80 \ -p 9922:22 \ -v /home/gitlab/etc:/etc/gitlab \ -v /home/gitlab/log:/var/log/gitlab \ -v /home/gitlab/opt:/var/opt/gitlab \ --restart always \ --privileged=true \ --name gitlab \ gitlab/gitlab-ce 命令描述-i以交互模式运行容器，通常与 -t 同时使用命令解释-t为容器重新分配一个伪输入终端，通常与 -i 同时使用-d后台运行容器，并返回容器ID-p 9980:80将容器内80端口映射至宿主机9980端口，这是访问gitlab的端口-p 9922:22将容器内22端口映射至宿主机9922端口，这是访问ssh的端口-v /home/gitlab/etc:/etc/gitlab以交互模式运行容器，通常与 -t 同时使用命令解释–restart always将容器/etc/gitlab目录挂载到宿主机/usr/local/gitlab-test/etc目录下，若宿主机内此目录不存在将会自动创建，其他两个挂载同这个一样–privileged=true容器自启动–name gitlab设置容器名称为gitlabgitlab/gitlab-ce镜像的名称，这里也可以写镜像ID 三、修改配置 #进容器内部 docker exec -it gitlab /bin/bash #修改gitlab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/955924b61e3c02f14bace213dc51fd16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d27ba5d8f19848cc5472b4203aabd1/" rel="bookmark">
			matplotlib画图中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在jupyter使用matplotlib绘图时，虽然使用了如下设置，但仍然出现了中文乱码。
plt.rcParams['font.sans-serif'] = ['SimHei'] plt.rcParams['axes.unicode_minus']=False 记录一下解决办法：
首先，在C:\Windows\Fonts目录下查找SimHei字体是否存在，注意SimHei是常规黑体，可以通过在某字体上右键选属性查看字体名称。
复制该字体文件，到anaconda的字体库目录
重新加载字体库 from matplotlib.font_manager import _rebuild _rebuild() jupyter中Kernel重启
重新运行代码，汉字正常显示。 import numpy as np import pandas as pd import matplotlib.pyplot as plt plt.rcParams['axes.unicode_minus'] = False plt.rcParams['font.sans-serif'] = ['SimHei'] data = np.random.randn(100) df = pd.DataFrame({'长度':data }) df.plot.hist(bins=20) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ab76c521dcf930862db676db30bb0b/" rel="bookmark">
			2024中国科学技术大学计算机考研信息汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中国科学技术大学计算机科学与技术学院官网
http://cs.ustc.edu.cn/
中国科学技术大学软件学院官网
https://sse.ustc.edu.cn/pages/index.php
中国科学技术大学大数据学院官网
http://sds.ustc.edu.cn/
中国科学技术大学网络空间安全学院官网
http://infosec.ustc.edu.cn/
中国科学技术大学研究生院科学岛分院官网
http://hfcasyz.v.360eol.com/
中国科学技术大学（University of Science and Technology of China），简称“中国科大”，位于安徽省合肥市，由中国科学院直属，中央直管副部级建制，位列“双一流”、“211工程”、“985工程”，入选“珠峰计划”、“111计划”、“2011计划”、“中国科学院知识创新工程”、“卓越工程师教育培养计划”，为“九校联盟”成员、中国大学校长联谊会、东亚研究型大学协会、环太平洋大学联盟成员，是一所以前沿科学和高新技术为主、兼有特色管理和人文学科的综合性全国重点大学。
初复试信息
【考研必看】2024计算机考研报考指南&amp;全国各院校数据分析
24中国科学技术大学计算机考研群：875075286（为了防止各类广告，长期禁言，学习资料见群文件，内部学习交流群点击上方学校Q群可查看）
2023年最新报考信息
计算机相关专业：
软件学院
083500 软件学硕085400 电子信息 计算机科学与技术学院
081200 计算机学硕085400 电子信息085400 电子信息【非全日制】 大数据学院
99J100 数据科学（计算机科学与技术）085400 电子信息 网络空间安全学院
083900 网安学硕 研究生院科学岛分院
081200 计算机学硕085400 电子信息 先进技术研究院
085400 电子信息 学制、学费、奖学金情况
学制
计算机学/专：3年网安：3年软院：2.5-3年（计划内联合培养项目的学制原则上3年） 学费
学硕统一为8000/年计算机专8000/年软件专硕20000/年先进研究院11000/年 奖学金
学业奖学金一等奖12000，二等奖10800。
统考生中，部分为二等奖学金。研二之后，根据大家的表现，奖学金的等级会重新评定。
国家助学金（每人都有）500元/月
学校配套国家助学金（每人都有）200元/月
22计算机相关专业目录
软件学院
083500 软件学硕 2统考+4推免
思想政治理论、英语一、数学一、408计算机统考
085400 电子信息 524统考+6推免
思想政治理论、英语二、数学二、408计算机统考
学费标准：共计4万元，第一学年初缴费2万元，第二学年初缴费2万元。
本专业在生源不足的情况下接受调剂。
复试内容
1、专业基础测评（上机100分）：专业基础测评主要考察考生有关编程和数据结构的基础知识及基本运用能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13ab76c521dcf930862db676db30bb0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90fc92d739d5de5d1d6900f2f87a762/" rel="bookmark">
			如何搭建Pytorch环境（linux版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 安装Anaconda 首先打开Anaconda官网，下载对应平台的安装包
Anaconda官网
我们这里安装的包是Anaconda3-2022.05-Linux-x86_64.sh
然后，打开terminal，将安装包上传到服务器，运行命令
bash Anaconda3-2022.05-Linux-x86_64.sh 等待安装，安装结束后，在terminal输入python，应该能够跳转到解释器：
2 安装Pytorch 初始化.condarc文件
conda config --set show_channel_urls yes 此时，输入命令ls -alh，可以看到已经有.condarc文件了
修改.condarc文件成如下所示：
vi .condarc PC端
channels: - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ - http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - http://mirrors.aliyun.com/anaconda/pkgs/main - http://mirrors.aliyun.com/anaconda/pkgs/r - http://mirrors.aliyun.com/anaconda/pkgs/msys2 show_channel_urls: true custom_channels: conda-forge: http://mirrors.aliyun.com/anaconda/cloud msys2: http://mirrors.aliyun.com/anaconda/cloud bioconda: http://mirrors.aliyun.com/anaconda/cloud menpo: http://mirrors.aliyun.com/anaconda/cloud pytorch: http://mirrors.aliyun.com/anaconda/cloud simpleitk: http://mirrors.aliyun.com/anaconda/cloud 服务器端
channels: - defaults show_channel_urls: true channel_alias: https://mirrors.tuna.tsinghua.edu.cn/anaconda default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free - https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a90fc92d739d5de5d1d6900f2f87a762/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e45eca40b4bee4a97a71e620ae14fdb9/" rel="bookmark">
			修改运行中的docker容器的端口映射（简单、高效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言查看已经存在容器id关闭docker服务，修改配置文件结束，启动容器 前言 在docker run创建并运行容器的时候，可以通过-p指定端口映射规则。但是，我们经常会遇到刚开始忘记设置端口映射或者设置错了需要修改。当docker start运行容器后并没有提供一个-p选项或设置，让你修改指定端口映射规则。
优缺点：这个方法的优点是没有副作用，操作简单。缺点是需要重启整个docker服务，如果在同一个宿主机上运行着多个容器服务的话，就会影响其他容器服务。
提示：以下是本篇文章正文内容，下面案例可供参考
通过这个方式处理的，亲测有效。前提需要停止docker。1分钟
查看已经存在容器id #查看容器id docker ps -a 此时需要记住要修改的容器id前几位即可
关闭docker服务，修改配置文件 #关闭docker服务 systemctl stop docker 关闭之后，找到容器的配置文件路径，通常都是安装在这个路径下方
cd /var/lib/docker/containers ls 查看可以对应上
如果找不到安装的docker位置，可以通过find全局查找
find / -name docker 进入需要修改容器的id目录中，查看内容
[root@localhost f59526....]# ls checkpoints config.v2.json f595262...bc-json.log hostconfig.json hostname hosts mounts resolv.conf 修改容器中的 hostconfig.json 文件
vim hostconfig.json 修改该端口映射关系，增删改查
#json格式展示 "PortBindings": { "22/tcp": [ ], "80/tcp": [ { "HostIp": "", "HostPort": "9980" } ] } 完成后，退出保存
按下 ESC ---&gt; :wq 结束，启动容器 #启动容器 systemctl start docker 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44e1d71a01dbd7e8b9a1526b01f88649/" rel="bookmark">
			ffmpeg的解码过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. ffmpeg cpu解码 视频解码，是将压缩后的视频（压缩格式如H264）通过对应解码算法还原为YUV视频流的过程；在计算机看来，首先输入一段01串（压缩的视频），然后进行大量的浮点运算，最后再输出更长的一段01串（还原的非压缩视频）。计算机内部可以进行浮点数计算的部件是CPU，目前市场上涌现了一批GPU和类GPU芯片，如Nvidia、海思芯片甚至Intel自家的核显。利用前者进行解码一般称为“软解码”，后者被称为“硬解码”，如果没有特殊指定，FFMPEG是用CPU进行解码的，即软解。本文将介绍的是软解，也就是FFMPEG最通用的做法。
1.1 ffmpeg 软解API变化 FFPEAG官方参考技术手册：ffmpeg.org/developer.h…
1.2 ffmpeg解码套路 和很多工具一样，FFMPEG解码也是有套路的，以下是雷神的解码过程：
最新版的解码过程如下所示：
★文末名片可以免费领取音视频开发学习资料，内容包括（FFmpeg ，webRTC ，rtmp ，hls ，rtsp ，ffplay ，srs）以及音视频学习路线图等等。
见下方!↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
1.3 详解解码过程 1.3.1 连接和打开视频流
连接和打开视频流**必然是后续进行解码的关键，该步骤对应的API调用为：
[int avformat_network_init(void)]：官方文档建议加上avformat_network_init()，虽然这个不是必须的。深入阅读该实现过程，说白了，该函数会初始化和启动底层的TLS库，这也就解释了网上很多资料关于如果要打开网络流的话，这个API是必须的的说法了。
int avformat_open_input(AVFormatContext * ps, const char filename, AVInputFormat* fmt, AVDictionary ** options) avformat_open_input()官方说法是“打开并读取视频头信息”，该函数较为复杂，笔者还没有完全吃透他的每一行源码，大致了解其功能为AVFormatContext内存分配，如果是视频文件，会探测其封装格式并将视频源装入内部buffer中；如果是网络流视频，则会创建socket等工作连接视频获取其内容，装入内部buffer中。最后读取视频头信息。
上面步骤结束后，就可以调用APIav_dump_format()打印文件的基本信息了，如文件时长、比特率、fps、编码格式等，信息大概如下：
Input #0, avi, from '${input_video_file_name}': Metadata: encoder : Lavf57.83.100 Duration: 00:10:00.00, start: 0.000000, bitrate: 4196 kb/s Stream #0:0: Video: h264 (High) (H264 / 0x34363248), yuvj420p(pc, bt709, progressive), 1920x1080, 4194 kb/s, 12 fps, 12 tbr, 12 tbn, 24 tbc
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44e1d71a01dbd7e8b9a1526b01f88649/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfcd2cf4b4b291c10778b1860bd96531/" rel="bookmark">
			降低gitlab的资源占用（直接干）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言话不多，直接修改配置 前言 已经搭建gitLab环境，成功运行后，
话不多，直接修改配置 # 进入容器 docker exec -it 1fb6eab6fe54 /bin/bash # 修改配置文件 /etc/gitlab/gitlab.rb vi /etc/gitlab/gitlab.rb 添加以下配置减少内存的占用
# 禁用 puma cluster 模式， 可以减少 100-400 MB占用 puma['worker_processes'] = 0 # Sidekiq 是一个后台处理守护进程。默认情况下使用 GitLab 配置时，它以50. 这确实会影响它在给定时间可以分配多少内存。建议将其配置为使用明显更小的值5或10（首选）。 sidekiq['max_concurrency'] = 10 # GitLab 默认启用所有服务，无需任何额外配置即可提供完整的 DevOps 解决方案。一些默认服务，如监控，对于 GitLab 的运行不是必需的，可以禁用以节省内存。 # 禁用监控 prometheus_monitoring['enable'] = false # GitLab 由许多组件（用 Ruby 和 Go 编写）组成，其中 GitLab Rails 是最大的组件，并且消耗最多的内存。 gitlab_rails['env'] = { 'MALLOC_CONF' =&gt; 'dirty_decay_ms:1000,muzzy_decay_ms:1000' } 添加完以上代码后执行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfcd2cf4b4b291c10778b1860bd96531/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeb00282b12162cfc335611050f711d2/" rel="bookmark">
			Golang中基于HTTP协议的网络服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于HTTP协议的网络服务 文章目录 基于HTTP协议的网络服务一、HTTP协议的网络服务1.1 使用`http.Get`函数访问HTTP协议的网络服务1.2 使用缺省客户端DefaultClient（类型为`*http.Client` ）1.3 使用`http.Client`访问HTTP协议的网络服务 二、`http.Client`中的Transport字段（1）`http.Transport`类型中的DialContext字段（2）`http.Transport`类型中的其它字段 三、为什么会出现空闲的连接3.1 空闲连接的产生3.2 杜绝空闲连接的产生 四、`http.Server`4.1 `http.Server`类型的`ListenAndServe`方法4.2 `ListenAndServe`方法主要做的事情4.3 （衍生问题）`net.Listen` 函数都做了哪些事情4.4 （衍生问题）`http.Server`类型的Serve方法是怎么接受和处理HTTP请求的 五、思考：怎么优雅地停止基于HTTP协议的网络服务程序？ 一、HTTP协议的网络服务 HTTP协议是基于TCP/IP协议栈的，并且它也是一个面向普通文本的协议。
只要搞清楚了HTTP请求的报文（报文的头部（header）和主体（body））应该包含的内容，使用任何一个文本编译器，就饿可以编写一个完整的HTTP请求报文。
在这种情况下，直接使用net.Dial函数，就可以。
使用net/http代码包中的程序实体，可以更便捷的访问基于HTTP协议的网络服务。其中最便捷的是使用http.Get函数。
1.1 使用http.Get函数访问HTTP协议的网络服务 package main import ( "fmt" "net/http" ) func main() { url1 := "http://www.google.cn/" fmt.Printf("Send request to %q with method GET ... \n", url1) response1, err := http.Get(url1) if err != nil { fmt.Printf("request sending error: %v\n", err) } defer response1.Body.Close() line1 := response1.Proto + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeb00282b12162cfc335611050f711d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a28cf4d3176e313f3e987d944032fd26/" rel="bookmark">
			openwrt远程抓包与分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 openwrt做为一款基于linux的路由器系统，本身可以安装很多linux平台的工具，今天我们就来玩玩如何将通过路由器的网络数据都抓下来。
首先请您在路由器安装好tcpdump,安装的方法，最好是通过包管理器，毕竟如果依赖包很多的话，手动安装比较繁琐。
思路一 我们可以先在路由器上通过tcpdump等抓包工具将接口的数据先抓下来并保存为标准的抓包文件，然后导回到本机进行后续的分析，这种方式临时使用是可以的，但操作比较麻烦。
思路二 我们通过ssh链接到openwrt的路由，然后通过执行tcpdump的抓包命令，将数据包通过ssh传回到我们的PC机，在PC机上通过wireshark进行分析。
#命令格式 ssh -p ssh端口 -o StrictHostKeyChecking=no ssh用户名@ssh地址 'tcpdump -s 0 -U -n -w - -i br-lan not port ssh端口' | wireshark -k -i - #对应我的环境的命令 ssh -p 2222 -o StrictHostKeyChecking=no root@192.168.2.1 'tcpdump -s 0 -U -n -w - -i br-lan not port 2222' | wireshark -k -i - 简单的说明 根据openwrt文档，所有的局域网的数据最后都是通过br-lan虚拟网卡来做转发，所以对此网卡进行监控即可 此命令本质是远程在路由器上执行网络监控命令，输入文本到本机的wireshark里面 使用wireshark作为可视化工具来查看 示例：ssh root@192.168.1.1 'tcpdump -s 0 -U -n -w - -i br-lan not port 22' | .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a28cf4d3176e313f3e987d944032fd26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18374af8e1c215cf7cce8dd0b61b7509/" rel="bookmark">
			【洛谷】【二分】最长公共子序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【洛谷】【二分】最长公共子序列 题目 P1439
解题思路 好久以前打的题，发现没打题解
主要思路就是开数组将第一个序列的数位置存下来
然后开m数组存最长公共子序列,len存长度
当b[i]这个数在a中的位置在m[len]后面，可以直接加入
如果在前面，可以优化m数组，替换掉位置在其后面的
正确性易证，不影响长度，也会让解更优
代码 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; int n,len; int f[100010],a[100010],b[100010],m[100010]; int main() { scanf("%d",&amp;n); for (int i=1;i&lt;=n;i++) { scanf("%d",&amp;a[i]); f[a[i]]=i; } for (int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i]); m[0]=0; for (int i=1;i&lt;=n;i++) { if (f[b[i]]&gt;m[len]) m[++len]=f[b[i]]; else { int l=0,r=len,mid; while (l&lt;r) { mid=(l+r)/2; if (m[mid]&gt;f[b[i]]) r=mid; else l=mid+1; } m[l]=min(f[b[i]],m[l]); } } cout&lt;&lt;len; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dbec4f0c05be45a8acf6a5ae9d1f880/" rel="bookmark">
			JSON格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，通常用于 Web 应用程序中的数据交换。 加粗样式JSON 格式采用键值对的方式来组织数据，具有以下特点： 采用键值对的方式组织数据，即使用一个键（字符串）来表示值的名称，用冒号分隔键和值，用逗号分隔不同的键值对。
支持多种数据类型，包括字符串、数字、布尔值、数组和对象等。
字符串类型必须使用双引号括起来，不能使用单引号或反斜杠。
数组类型使用方括号括起来，不同的元素之间使用逗号分隔。
对象类型使用花括号括起来，不同的属性之间使用逗号分隔，每个属性由属性名和属性值组成，属性名必须使用双引号括起来。
下面是一个 JSON 格式的示例： { "name": "John", "age": 30, "isStudent": true, "hobbies": ["reading", "swimming", "traveling"], "address": { "street": "123 Main St", "city": "New York", "state": "NY", "zip": "10001" } } 这个 JSON 格式表示一个人的信息，包括姓名、年龄、是否是学生、爱好和地址等。其中，姓名、年龄和是否是学生的值分别为字符串、数字和布尔值类型，爱好是一个字符串数组，地址是一个对象，包含街道、城市、州和邮编等属性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8b5d23d64439a9ee8178fafed0d79f3/" rel="bookmark">
			shell函数、数组练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.编写函数，实现打印绿色OK和红色FAILED，判断是否有参数，存在为OK，不存在为FAILED
2.编写函数，实现判断是否无位置参数，如无参数，提示错误
3.编写函数实现两个数字作为参数，返回最大值
4.编写函数，实现两个整数位参数，计算加减乘除
5.将/etc/shadow文件的每一行作为元素赋值给数组
6.使用关联数组统计文件/etc/passwd中用户使用不同类型shell的数量
7.使用关联数组按扩展名统计指定目录中文件的数量
1.编写函数，实现打印绿色OK和红色FAILED，判断是否有参数，存在为OK，不存在为FAILED 代码部分
#!/bin/bash ######################### #File name:test1.sh #Author: BenJM #Created time:2023-04-08 08:17:33 ######################### Print_Ok() { echo -e "\033[32m OK \033[0m" #打印绿色OK函数 } Print_Failed() { echo -e "\033[31m FAILED \033[0m" #打印红色FAILED函数 } if [ $# -eq 0 ] then Print_Failed #判断没有参数，则调用打印FAILED函数 else Print_Ok #否则调用打印OK函数 fi 测试部分
[root@localhost shell_test2]# bash test1.sh FAILED [root@localhost shell_test2]# bash test1.sh haha OK 2.编写函数，实现判断是否无位置参数，如无参数，提示错误 代码部分
#!/bin/bash ######################### #File name:test2.sh #Author: BenJM #Created time:2023-04-08 08:50:42 ######################### #判断是否有位置参数,没有则提示错误，否则输出所有参数 PD() { if [ $# -eq 0 ] then echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8b5d23d64439a9ee8178fafed0d79f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a35d240a1bce78527780db88c86fbbd5/" rel="bookmark">
			【sqlite3_prepare_v2()和sqlite3_bind_text()函数的函数说明】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 sqlite3_prepare_v2()函数的函数说明：函数功能：sqlite3_bind_text()函数的函数说明：函数功能：函数参数：占位符说明 sqlite3_prepare_v2()函数的函数说明： int sqlite3_prepare_v2( sqlite3 *db, //数据库连接对象 const char *zSql, //要编译的 SQL 语句 int nByte, //要编译的 SQL 语句的长度，如果是-1，则自动计算其长度 sqlite3_stmt **ppStmt, //编译后的 SQLite3 语句对象 const char **pzTail //未编译部分的指针 ); 函数功能： 该函数将 SQL 语句编译成 SQLite 虚拟机指令，并将编译后的 SQLite3 语句对象存储在 ppStmt 指向的指针中，以备执行。如果 pzTail 不是 NULL，则该指针将指向 SQL 语句中未编译部分的起始位置。
函数返回值：
如果编译成功，则返回 SQLITE_OK。
如果编译失败，则返回一个错误代码。
sqlite3_bind_text()函数的函数说明： int sqlite3_bind_text( sqlite3_stmt*, // SQLite3 语句对象 int, // 值占位符的索引，从 1 开始 const char*, // 文本值的指针 int, // 文本值的长度，如果是-1，则自动计算其长度 void(*)(void*) // 当值变成不需要时要调用的析构函数 ); 函数功能： 该函数将文本值绑定到 SQLite3 语句对象中的值占位符上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a35d240a1bce78527780db88c86fbbd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf0e8aa39761fd5ccfcf0ca6158fb9df/" rel="bookmark">
			中国国产操作系统有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国产操作系统 是由中国公司或组织开发的操作系统，其目的是为了减少对外国技术的依赖，保护本土技术产业并提升国家的信息安全。
国产操作系统具有很重要的战略意义，发展国产操作系统不仅是国家信息化建设的需要和对国家信息安全的保护，对于促进本土产业发展也具有重要意义。
减少对外部技术的依赖：操作系统是计算机系统的核心，是其他软件和硬件的基础，国产操作系统可以减少对外部技术的依赖，保护本土技术产业，提高国家的信息安全。
保护国家安全：操作系统的安全性对于国家安全具有极其重要的意义，通过开发国产操作系统，可以更好地保护国家关键信息和数据不被泄露。
发展本土产业：国产操作系统的推广和应用，可以促进本土产业的发展，提高本土厂商在全球市场竞争中的地位。
开源软件发展：国产操作系统可以推动开源软件的发展，开放源代码可以激发创新和合作，形成良性竞争环境，推动业界技术进步。
将来市场潜力：操作系统是未来信息通信领域的基础设施之一，国家将所有应用都基于本土化操作系统进行开发和部署，这将在未来的信息技术市场上占有更重要的地位，反过来也会带动整个产业的发展。
推荐的国产系统 : 银河麒麟， OpenEuler
以下是其他的国产操作系统，欢迎补充和纠正. 银河麒麟操作系统
银河麒麟操作系统是由中国电子技术标准化研究院开发的一款企业级服务器操作系统，主要面向政府、军事、金融等领域。该系统具有高可靠性、高安全性、高扩展性、高性能等特点，支持多节点集群、虚拟化、云计算等特性。
中标麒麟服务器操作系统
中标麒麟NeoKylin是一款国产、面向企业级应用的操作系统，具有高性能、稳定、安全等特点。该系统主要面向政企、金融、电信等领域，支持多节点集群、web管理、可信计算等功能。
鲲鹏操作系统
鲲鹏操作系统（Kunpeng OS）是华为公司推出的服务器操作系统，基于Linux内核，具有高效易用、能力先进、高度安全等特点。该系统支持X86和ARM体系架构，并可在公有云和私有云平台上灵活运行，与华为的鲲鹏服务器互为配套使用。
统信UOS
统一操作系统UOS是由包括中国电子集团（CEC）、武汉深之度科技有限公司、南京诚迈科技、中兴新支点在内的多家国内操作系统核心企业自愿发起“UOS(unity operating system)统一操作系统筹备组”共同打造的中文国产操作系统。
Red Flag Linux
红旗Linux是由北京中科红旗软件技术有限公司开发的一系列Linux发行版，包括桌面版、工作站版、数据中心服务器版、HA集群版和红旗嵌入式Linux等产品。
OpenEuler
EulerOS是华为自主研发的服务器操作系统，能够满足客户从传统IT基础设施到云计算服务的需求。EulerOS对ARM64架构提供全栈支持，打造完善的从芯片到应用的一体化生态系统
Kylin
Kylin操作系统是一个中国自主知识产权操作系统，是国家高技术研究发展计划（863计划）的重大成果之一，是以国防科技大学为主导，与中软、联想等单位联合设计和开发的基于Linux的系统，可支持多种微处理器和多种计算机体系结构，具有高性能、高可用性和高安全性，并与Linux应用二进制兼容的国产中文服务器操作系统。
Deepin
Deepin是由武汉深之度科技有限公司在Debian基础上开发的Linux操作系统，最初是面向桌面的操作系统，后来也开始面向服务器领域。Deepin操作系统主打美观易用的操作界面和人性化的应用，已被广泛用于各种使用场景，如工作办公、个人娱乐等等。
中科红旗Asianux
asianux是一款Linux 操作系统，其独特之处主要在于其是亚洲软件市场上第一个符合国际标准和统一的Linux 操作系统，打破了欧美公司的技术垄断，并且其较低的成本和系统的稳定都受到了市场的重视。而由中韩日三方共同成立Asianux公司则通过这款软件和努力的拼搏不断发展壮大。而我们也可以预见这款 Linux 操作系统的不断增进的努力，定会为用户的 IT 平台提供一个开放而强大的选择。
中兴新支点操作系统：
中兴新支点操作系统基于Linux稳定内核，分为嵌入式操作系统（NewStart CGEL）、服务器操作系统（NewStart CGSL）、桌面操作系统（NewStart NSDL）
普华Linux（i-soft）
普华Linux是由普华基础软件股份有限公司开发的一系列Linux发行版， 包括桌面版、服务器版、国产CPU系列版本，IBM Power服务器版、HA和虚拟化系列等产品。
中科方德桌面操作系统：
方德桌面操作系统由中科方德软件有限公司推出，适配海光、兆芯、飞腾、龙芯、申威、鲲鹏等国产CPU，支持x86、ARM、MIPS等主流架构，支持台式机、笔记本、一体机及嵌入式设备等形态整机、主流硬件平台和常见外设。方德桌面操作系统还预装软件中心，已上架运维近2000款优质的国产软件及开源软件。
起点操作系统StartOS（原雨林木风操作系统YLMF OS）
StartOS是由东莞瓦力网络科技有限公司发行的开源操作系统，其前身是由广东雨林木风计算机科技有限公司ylmf os开发组所研发的ylmf os，符合国人的使用习惯，预装常用的精品软件，操作系统具有运行速度快，安全稳定，界面美观，操作简洁明快等特点。
凝思磐石安全操作系统
凝思磐石安全操作系统：是由北京凝思科技有限公司开发，凝思磐石安全操作系统遵循国内外安全操作系统GB17859、GB/T18336、GJB4936、GJB4937、GB/T20272以及POSIX、凝思磐石安全操作系统TCSEC、ISO15408等标准进行设计和实现。
一铭操作系统
一铭操作系统(YMOS)是一铭软件股份有限公司在龙鑫操作系统基础上推出的系统软件，是2013、2014、2015年度中央机关政府协议供应产品，列入全国各级省市的政府采购目录。
优麒麟Ubuntu Kylin
Ubuntu Kylin是由麒麟软件有限公司和CCN开源软件, 创新联合实验室主导开发的全球开源项目，其宗旨是通过研发用户友好的桌面环境以及特定需求的应用软件。
开放麒麟openKylin
开放麒麟openKylin是中国首个桌面操作系统开发者平台，由国家工业信息安全发展研究中心等单位联合成立，将打造具有自主创新技术的开源桌面操作系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf0e8aa39761fd5ccfcf0ca6158fb9df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/307bba7db198fc34cd3954ef46a900cd/" rel="bookmark">
			pytorch常用模版代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用模版代码 0.参考1.一个网络最基础的四个python文件模版1.1 model.py( 两个类; 四个函数)1.2 train.py( 两个函数)1.3 dataset.py ( 一个类; 三个函数)1.4 utils.py ( 多个函数) 2 PyTorch常用代码段2.1 基本配置2.1.1 导入包和版本查询2.1.2 可复现性2.1.3 显卡设置 2.2 张量(Tensor)处理2.2.1 张量的数据类型2.2.2 张量基本信息2.2.3 命名张量2.2.4 数据类型转换2.2.5 torch.Tensor与np.ndarray转换2.2.6 Torch.tensor与PIL.Image转换2.2.7 np.ndarray与PIL.Image的转换2.2.8 从只包含一个元素的张量中提取值2.2.9 张量形变2.2.10 打乱顺序2.2.11 水平翻转2.2.12 复制张量2.2.13 张量拼接2.2.14 将整数标签转为one-hot编码2.2.15 得到非零元素2.2.16 判断两个张量相等2.2.17 张量扩展2.2.18 矩阵乘法2.2.19 计算两组数据之间的两两欧式距离 2.3 模型定义和操作2.3.1 一个简单两层卷积网络的示例2.3.2 双线性汇合（bilinear pooling）2.3.3 多卡同步 BN（Batch normalization）2.3.4 将已有网络的所有BN层改为同步BN层2.3.5 类似 BN 滑动平均2.3.6 计算模型整体参数量2.3.7 查看网络中的参数2.3.8 模型可视化（使用pytorchviz）2.3.9 类似 Keras 的 model.summary() 输出模型信息（使用pytorch-summary ）2.3.10 模型权重初始化2.3.11 提取模型中的某一层2.3.12 部分层使用预训练模型2.3.13 将在 GPU 保存的模型加载到 CPU2.3.14 导入另一个模型的相同部分到新的模型 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/307bba7db198fc34cd3954ef46a900cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/811490ec42587d3e7d943b9f1db95f86/" rel="bookmark">
			kali更新源（源、软件更新，附kali源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多系统安装好以后都需要进行更新源，或者软件需要更新，小编在这里进行一次更新源和软件的记录，还请路过大牛指出不足。
1、在/etc/apt下有文件sources.list文件，将下方提供的源粘贴一个即可
#命令 vi /etc/apt/sources.list 输入 i 进行编辑，把文章下方附有的kali源粘贴一个即可
2、 执行命令更新源
#命令 apt-get update 3、更新软件并安装
(1)更新软件
#命令 apt-get upgrade 更新所有软件 #命令 apt-get upgrade hydra 更新指定软件，hydra可以为任意软件名 (2) 软件升级安装
#命令 apt-get dist-upgrade (3) 清理
# apt-get clean (4) 重启系统
# reboot 附kali源
使用哪个把注释去掉，不使用就注释一下
kali官方源 deb http://http.kali.org/ moto main non-free contrib
deb-src http://http.kali.org/ moto main non-free contrib
deb http://security.kali.org/ moto/updates main contrib non-free
deb-src http://security.kali.org/ moto/updates main contrib non-free
#中科大kali源
deb http://mirrors.ustc.edu.cn/kali kali main non-free contrib
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/811490ec42587d3e7d943b9f1db95f86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a928f198a811aeeee8922c9deb52c73/" rel="bookmark">
			稀疏卷积spconv1.2编译安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础环境python3.8+cuda11.1+ubuntu18.04 一.安装cmake3.13.2 wget https://cmake.org/files/v3.13/cmake-3.13.2-Linux-x86_64.tar.gz sudo tar zxvf cmake-3.13.2-Linux-x86_64.tar.gz sudo mv cmake-3.13.2-Linux-x86_64 /opt/cmake-3.13.2 sudo ln -s /opt/cmake-3.13.2/cmake-3.13.2-Linux-x86_64/bin/* /usr/bin/ 若安装了cmake的可能要先卸载，别的版本的我没试过，另外使用sudo apt-get install安装不上的话可能需要更新一下:
sudo apt-get upgrade sudo apt-get update 之后有显示版本信息说明安装成功了：
cmake --version 二.克隆pybind11 git clone https://github.com/pybind/pybind11 可能有时github的项目已经更新啥的，然后采用git clone下载下来的会出现版本不一样的问题，我一般都是下载zip文件然后解压。下载下来的pybind11工程名可能有很长的乱码后缀需要改成pybind11，把这个下级目录含有docus，include等文件的pybind11复制到spconv工程下的third_party下覆盖那个pybind11。
三.克隆spconv git clone https://github.com/traveller59/spconv.git git checkout -b v1.2 origin/v1.2.1 第二行命令不太清楚是干嘛用的看字面意思可能是切换什么版本吧，或者可以执行这条命令但是本人没有试过：
git clone -b v1.2.1 https://github.com/traveller59/spconv.git 之后在spconv下建立build目录：
mkdir build 最后在spconv目录下编译setup.py:
python setup.py bdist_wheel 编译不报错就能生成dist目录，在这个目录下有对应python3.8版本的spconv-1.2.1-cp38-cp38-linux_x86_64.whl文件：
四.其它问题 更多编译细节可以查看日志:spconv/build/temp.linux-x86_64-3.7/CMakeFiles/目录下的CMakeError.log.
编译setup.py时还可能报错:
1.Unable to locate package libboost-filesystem-dev. 执行:
sudo apt-get upgrade sudo apt-get update sudo apt-get install libboost-all-dev 或者使用aptitude
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a928f198a811aeeee8922c9deb52c73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52780c86f2307ca00c645f63097c9134/" rel="bookmark">
			Qt下Tcp套接字（socket）通信的整个流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、QT如果要进行网络编程首先需要在.pro中添加如下代码： QT += network
二、QT下的TCP通信过程 Qt中提供的所有的Socket类都是非阻赛的
Qt中常用的用于socket通信的套接字类
QTcpServer
用于TCP/IP通信，作为服务器端套接字使用
QTcpSocket
用于TCP/IP通信，作为客户端套接字使用。
QUdpSocket
用于UDP通信，服务器，客户端均使用此套接字
三、描述Qt下Tcp通信的整个流程 服务器端: 1. 创建用于监听的套接字 //监听套接字 tcpServer = new QTcpServer(this); 2. 给套接字设置监听 tcpServer-&gt;listen(QHostAddress::Any,8888); setWindowTitle("服务器：8888"); 3. 如果有连接到来, 监听的套接字会发出信号newConnected 4. 接收连接, 通过nextPendingConnection()函数, 返回一个QTcpSocket类型的套接字对象(用于通信) connect(tcpServer,&amp;QTcpServer::newConnection,[=](){ //取出建立好连接的套接字 tcpSocket = tcpServer-&gt;nextPendingConnection(); }); 5. 使用用于通信的套接字对象通信 （1）. 发送数据: write if(NULL == tcpSocket) { return; } //获取编辑区内容 QString str = ui-&gt;textEditWrite-&gt;toPlainText(); //给对方发送数据，使用套接字是tcpSocket tcpSocket-&gt;write(str.toUtf8().data()); （2）. 接收数据: readAll/read connect(tcpSocket,&amp;QTcpSocket::readyRead,[=](){ //从通信套接字中取出内容 QByteArray array = tcpSocket-&gt;readAll(); array = "客户端；" + array; ui-&gt;textEditRead-&gt;append(array); }); 客户端： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52780c86f2307ca00c645f63097c9134/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5a6286423cb765d605f4d755ac3efd1/" rel="bookmark">
			python中递归函数或DFS深度优先搜索，用记忆数组（列表）减少递归次数和运行时间【使用记忆数组前后运行时间对比】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用记忆数组（列表）实现减少遍历次数和运行时间： 这里我们用，斐波那契数列 fib（n）= fib（n-1）+ fib（n-2）来做例子，下面看图：
（1）使用记忆数组的运行结果和代码【fib（50）】： import sys sys.setrecursionlimit(30000) #改变系统默认递归深度 def fib(n) : global cnt cnt += 1 if n==1 or n==2: data[n]=1 return data[n] if data[n] != 0: # 在记忆数组的，直接用，减少递归运算次数 return data[n] data[n] = fib(n-1)+fib(n-2) # 没有在记忆数组的，计算完后保存到data[] return data[n] data=[0]*52 # 记忆数组，开始用0来填充，后续存储的结果会替代0 #为什么data[]是51，因为就是要多放1个 cnt =0 print(fib(50)) print('递归次数为:',cnt) # 递归次数cnt= （2）“不使用记忆数组”的运行结果和代码【fib（40）】： import sys sys.setrecursionlimit(30000) #改变系统默认递归深度 def fib(n): global cnt cnt += 1 # 统计执行了多少次递归 if n==1 or n==2: # 到达终止条件 return 1 return fib(n-1)+fib(n-2) cnt =0 print(fib(50)) print('递归次数为:',cnt) # 递归次数cnt= 上面两个案例的对比，可以得出结论：使用记忆数组明显减少递归次数和运行时间 —————————————关于如何知道函数的运行时间，请看下面———————————
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5a6286423cb765d605f4d755ac3efd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d43fd6b1b8d807e8b21c0034f82b812/" rel="bookmark">
			allegro一个工程的原理图部分电路复制到另一个工程的原理图中去
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步点击 create by rectangle
第二步在需要复制的原理图左上角点击一下，然后对要复制的区域进行框选
第三步点击copy group,然后右击选择Done
第四步在需要复制的到的工程原理图界面进行粘贴paste
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33dec1ffd65c1437613441c2643314d/" rel="bookmark">
			CTF（Capture The Flag ）环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CTFd是什么？以及如何查看它的官方使用文档 CTFd是目前最流行的开源CTF框架之一,是一个有Python开发的框架，侧重于易用性和可定制性。它提供了运行CTF题目所需要的一切条件，并可使用插件和主题轻松进行自定义。
CTFd网盘下载链接
Github下载链接（官方下载渠道）
我们在Kali-Linux-2023（其他Linux操作系统均可）上进行安装，下面介绍安装方法
1、如果没有安装Python，则首先需要安装Python的集成环境,命令如下 sudo apt install python-pip(python3-pip) 2、按回车键后等待安装即可。接下来安装Flask框架，命令如下： pip install Flask	因为我已经安装过了，所以是这种情况
3、安装完成后，需要的依赖环境就准备就绪了。下面开始搭建CTFd环境，在主目录下新建一个文件夹：CTFd,将下载好的压缩包（zip格式）放到此文件夹里面，进行解压缩 (我这里因为手快（jian）了一点，直接就放到“下载”里面了，兄弟们不要学我，合理放置文件，从你我做起）
mkdir CTFd#创建文件夹 unzip CTFd-1.0.5.zip#解压缩 4、解压后会在当前目录中出现一个同名的CTFd-1.0.5的文件夹 5、进入CTFd-1.0.5目录，安装依赖项，执行如下命令： cd CTFd-1.0.5#进入CTFd-1.0.5 pip install -r requirements.txt#安装依赖 安装到最后的时候出现了error，吓得我马上去度娘搜了好就，结果没有发现有效的解决办法，那还是继续下去咯
6、安装完成后，执行脚本，运行如下命令，会更新安装一些依赖项 ./perpare.sh 发现这个报红没有影响到后续安装，属实虚惊一场了
执行成功的最后截图
7、启动环境，命令如下 sudo python server.py md，草率了，还是出现错误了，晕了晕了
我服了，看别人说要把python的版本降级，然后我把现有的Python3.11卸载了，干干净净的，然而并没有什么用！
还好我做了快照，不然芭比Q了
继续寻找办法
下午六点半开始安装，现在晚上十一点，啊，妈耶，CTF入门第一天就这么艰难！
接下来记叙一下解决bug的过程
（1）、CSDN搜了无数篇
算了算了，不记录了，上床睡觉了，明早还有课
CTFd安装的最终界面
8、此时，CTFd的安装基本完成。不过为了让其他与服务器不在同一个网络的主机也能够访问该环境，我们需要安装“gunicorn”工具。执行如下命令 pip install gunicorn 如图所示
9、安装完成后通过本地的80端口发布环境，执行命令如下： sudo gunicorn --bind 0.0.0.0:80 -w "CTFD:create_app()" 10、我们在Windows10 物理机上进行访问（http://[虚拟机的IP地址]） 第一次访问环境需要设置管理员的账户、邮箱、密码等信息。设置完成后，即可登录后台查看各项配置。
至此CTFd的基本安装与配置就完成了，接下来就可以按照官方的指导说明进行学习使用，具体链接如下
https://github.com/CTFd/CTFd
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2c541a6cb90a9dbd27157a3a1bdde44/" rel="bookmark">
			PTA习题7-4 堆栈模拟队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设已知有两个堆栈S1和S2，请用这两个堆栈模拟出一个队列Q。
所谓用堆栈模拟队列，实际上就是通过调用堆栈的下列操作函数:
int IsFull(Stack S)：判断堆栈S是否已满，返回1或0；int IsEmpty (Stack S )：判断堆栈S是否为空，返回1或0；void Push(Stack S, ElementType item )：将元素item压入堆栈S；ElementType Pop(Stack S )：删除并返回S的栈顶元素。 实现队列的操作，即入队void AddQ(ElementType item)和出队ElementType DeleteQ()。
输入格式: 输入首先给出两个正整数N1和N2，表示堆栈S1和S2的最大容量。随后给出一系列的队列操作：A item表示将item入列（这里假设item为整型数字）；D表示出队操作；T表示输入结束。
输出格式: 对输入中的每个D操作，输出相应出队的数字，或者错误信息ERROR:Empty。如果入队操作无法执行，也需要输出ERROR:Full。每个输出占1行。
输入样例: 3 2 A 1 A 2 A 3 A 4 A 5 D A 6 D A 7 D A 8 D D D D T 输出样例: ERROR:Full 1 ERROR:Full 2 3 4 7 8 ERROR:Empty 给大家讲一个乐子事儿，这是我原始的代码，在第一个测试点屡屡碰壁：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define ERROR -1 typedef int ElementType; typedef int Pos; typedef struct SNode *Stack; struct SNode { ElementType *Data; Pos Top; int MaxSize; }; Stack Creastack(int size) { Stack S=(Stack)malloc(sizeof(struct SNode)); S-&gt;Data=(ElementType*)malloc(size*sizeof(ElementType)); S-&gt;Top=-1; S-&gt;MaxSize=size; return S; } int IsFull(Stack S) { return S-&gt;Top==(S-&gt;MaxSize-1); } int IsEmpty(Stack S) { return S-&gt;Top==-1; } void Push(Stack S,ElementType item) { if(IsFull(S)) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2c541a6cb90a9dbd27157a3a1bdde44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72f6ccb82a77d68cc7fc6690e3e8f9e1/" rel="bookmark">
			python中float(“inf“)、float(“-inf“)用法，以及递归函数和DFS中巧妙利用正负无穷大每次返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在学习python利用递归函数实现算法和深度搜素(DFS)，我发现很多时候需要使用这个玩意去进行一下利用。
例如：在递归函数中，每次都需要返回值，这时候就派上用场了
首先说明：float(“inf“)、float(“-inf“) 相当于是正负无穷大
下面请看DFS利用的实例： def DFS(seed): if seed in have_cnt: #判断已经拥有的作物中是否有该作物 return 0 min_time = float("inf") #设置一个变量最大值，用于后面返回 for p1,p2 in rule[seed]: #将可以杂交成这个作物的作物迭代 tmp = max(cnt[p1],cnt[p2]) #看这两个作物哪一个时间最长 min_t = max(DFS(p1),DFS(p2)) +tmp #将这个时间加进去，并且递归这两个作物 if min_t &lt; min_time: #将时间和无穷大进行比较，得出较小的，赋值 min_time = min_t return min_time #迭代结束就结束这个函数，并且返回最小时间 print(DFS(T)) '''这样利用正负无穷大，就可以实现每次都返回一个值，并且不影响下次遍历''' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b03d22d81f42ff58dd7007dec26893/" rel="bookmark">
			网络安全行业名词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		行业名词 红队使用 APT - 高级持久威胁网络攻击
使用复杂的技术持续对目标政府和公司进行网络间谍活动或其他恶意活动。通常有民族或国家背景。 Attack signature - 攻击特征
一种特征性或独特性模式，可以帮助将一种攻击与另一种攻击联系起来，从而确定可能的参与者和解决方案。 DoS - 拒绝服务攻击
是一种网络攻击类型，通常会通过使服务超载请求来阻止信息系统服务或资源的授权使用或损害访问。 DDoS - 分布式拒绝服务攻击
主要利用大量傀儡电脑集中对一个或多个目标发动DDoS攻击，从而成倍地提高攻击的威力。 Phishing - 钓鱼攻击
钓鱼式攻击是指企图从电子通讯中，通过伪装成信誉卓著的法人媒体以获得如用户名、密码和信用卡明细等个人敏感信息的犯罪诈骗过程。 Container escape - 容器逃逸
攻击者通过劫持容器化业务逻辑，或直接控制；攻击者利用这种命令执行能力，借助一些手段进一步获得该容器所在直接宿主机上某种权限下的命令执行。 Decryption - 解密
将编码文本解密为原始原始格式的过程。 Landscape attack - 横向攻击
当通过外部打点进入到目标内网时，需要利用现有的资源尝试获取更多的凭证与权限，进而达到控制整个内网、拥有最高权限、发动 APT （高级持续性威胁攻击）等目地。 host of lateral - 主机横向
收集密码信息、通过rdp和ssh进行主机权限横向获取 Remote code execution（RCE）- 远程代码执行
远程命令执行漏洞，用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行系统命令。 Authentication - 认证方式
验证用户，进程或设备的身份或其他属性的过程。 CS
CobaltStrike ,红队最常用的后渗透软件 unsecured network - 无保障网络/不安全的网络
顾名思义，使用不安全无线网路或者没有安全设备防护的内网 0DAY漏洞/0DAY攻击
在网络安全中，0DAY漏洞 通常是指还没有补丁的安全漏洞。而 0DAY攻击 则指利用这种漏洞进行的攻击。提供该漏洞细节或者利用程序的人通常是该漏洞的发现者。0day 漏洞的利用程序对网络安全具有巨大威胁，因此 0day 漏洞不但是黑客的最爱，掌握多少 0day 漏洞也成为评价黑客技术水平的一个重要参数。 POC(Proof of Concept) - 利用证明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2b03d22d81f42ff58dd7007dec26893/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f9865d688aa76b8bb037d052ce5a117/" rel="bookmark">
			STM32将数据从十六进制转换为ascii通过串口发送显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/**************************************************************************** * 名	称：char HexToAscii(u8 nHex) * 功	能：单个16进制转ASCII码	* 入口参数：nHex	0x0A-0x0F.0x00-0x09 * 出口参数：转换后的ASCII码 * 说	明：16进制0x0A-0x0F.0x00-0x09转ASCII码A-F.0-9 ****************************************************************************/ char HexToAscii(u8 nHex) { if(nHex &lt;= 9)	//数字0~9 { return (nHex + 0x30); } else { if(nHex &gt;= 0x0A &amp;&amp; nHex &lt;= 0x0F)	//字母A~F { return (nHex + 0x37); } else { return 0xFF; } } } /**************************************************************************** * 名	称： * 功	能：发送字符串 * 入口参数：无 * 出口参数：无 * 说	明：无 ****************************************************************************/ void Usart_SendString(USART_TypeDef * pUSARTx, char *str) { unsigned int k=0; do { Usart_SendByte( pUSARTx, *(str + k) ); k++; } while(*(str + k)!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f9865d688aa76b8bb037d052ce5a117/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c45ff9cad685c95df98014dfe596d8/" rel="bookmark">
			获取IP地址信息的API合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家分享一些获取IP地址信息的API合集 一、ip.cn查询网获取当前客户端IP二、ip查询网获取当前客户端IP三、百度获取IP地址信息四、本站获取当前客户端IP信息五、其他平台获取IP地址信息接口一. 埃文科技平台接口二、第三方个人开放IP信息归属查询API 3. 其他API 有时候开发时偶尔会需要前端传客户端的ip地址，往往都要自己写方法去实现，今天给大家分享一些 API解放你们的双手。以下方法可以获取客户端外网ip。 一、ip.cn查询网获取当前客户端IP API地址： https://www.ip.cn/api/index?ip&amp;type=0
返回值：
{ "rs": 1, "code": 0, "address": "美国 加利福尼亚 旧金山 ", "ip": "172.70.211.115", "isDomain": 0 } 二、ip查询网获取当前客户端IP API地址：https://2023.ipchaxun.com/
返回值：
{ "ret": "ok", "ip": "220.202.233.76", "data": [ "中国", "湖南", "长沙", "岳麓", "联通", "410000", "0731" ] } 三、百度获取IP地址信息 API地址：https://opendata.baidu.com/api.php?query=[ip地址串]&amp;co=&amp;resource_id=6006&amp;oe=utf8
返回值
{ "status": "0", "t": "", "set_cache_time": "", "data": [ { "ExtendedLocation": "", "OriginQuery": "172.0.90.2", "appinfo": "", "disp_type": 0, "fetchkey": "172.0.90.2", "location": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0c45ff9cad685c95df98014dfe596d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d3c6b204c87b19680d78201d08d188/" rel="bookmark">
			vue项目切换页面会白屏，刷新之后才会正常显示(已解决)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 面对这种问题有两个方面：
1.就是&lt;template&gt;中没有div标签&lt;/template&gt;
错误写法：
&lt;template&gt; 直接开始布局了 &lt;/template&gt; 正确写法： 切记：div标签必须是包裹住所有的标签，除了&lt;template&gt;外这个div就是爹
&lt;template&gt; &lt;div&gt; 开始布局 &lt;/div&gt; &lt;/template&gt; 2.&lt;template&gt;中有div标签&lt;/template&gt;
错误写法：原因：他会把注释当作为一个节点，所以div就不是最大的容器了，他要先识别div标签，在识别div里面的标签，这时又多了其他节点就会出现白屏
&lt;template&gt; &lt;!-- &lt;zujian @seleted="shuju" /&gt; --&gt; &lt;div&gt; 开始布局 &lt;/div&gt; &lt;!-- &lt;zujian @seleted="shuju" /&gt; --&gt; &lt;/template&gt; 正确写法：注释写到div里面，任何除了这一！个div标签外都放到div里面
&lt;template&gt; &lt;div&gt; &lt;!-- &lt;zujian @seleted="shuju" /&gt; --&gt; 开始布局 &lt;!-- &lt;zujian @seleted="shuju" /&gt; --&gt; &lt;/div&gt; &lt;/template&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7b621ebd9ecd8726bdaa77f9dead52b/" rel="bookmark">
			安装Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker的简介：
Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。
一个完整的Docker有以下几个部分组成：
DockerClient客户端
Docker Daemon守护进程
Docker Image镜像
DockerContainer容器
1.下载关于Docker的依赖环境
在Xterm中输入以下代码安装依赖环境 回车
yum -y install yum-utils device-mapper-persistent-datalvm2
使用yum工具下载
yum是软件包管理工具
通过 执行 man yum
可以查看yum的帮助信息
2.设置下载Docker的镜像源
依赖环境下载完毕以后，设置下载的镜像源，如果不设置，会默认去Docker的官方下载，但是官方的服务器在国外，下载会比较缓慢，设置下载国内的镜像源（镜像就是英文单词image）
使用国内的阿里云
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
3.安装Docker
下面这个命令是将软件包信息提前在本地缓存一份，用来提高搜索安装软件的速度
yum makecache fast
提高安装速度以后，安装docker相关的。（docker-ce 社区版 而ee是企业版）
yum install docker-ce docker-ce-cli containerd.io
4.1启动，并设置为开机自动启动，测试
systemctl start docker
4.2设置开机自动启动
systemctl enable docker
4.3 测试
docker run hello-world
如果出现以下代码，说明运行成功：
[root@w510-2-1~]# docker run hello-world
Unable to find image 'hello-world:latest' locally
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7b621ebd9ecd8726bdaa77f9dead52b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9143f76256b1d99626b153e5cb9011da/" rel="bookmark">
			VMware虚拟机如何设置CentOS 7 磁盘扩容？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：https://www.cnblogs.com/friendwang1001/p/15725732.html
步骤一：虚拟机扩展磁盘容量 1、首先，打开已经安装好的虚拟机，选择需要扩展磁盘的虚拟机，点击设备中的“硬盘”。如图： 2、接着，进入虚拟机设置界面，在界面的右侧选择“扩展”。如图： 3、接着，在弹出的扩展磁盘容量中，输入需要扩展磁盘的大小，完成后点击“确定”。如图： 4、接着，等待系统自动扩展完成，在弹出的对话框中选择“确定”，这样虚拟机的磁盘就扩展完成了。如图： 5、接着，回到虚拟机设置界面，点击下方的“确定”保存刚设置的参数。如图： 6、这样，虚拟机扩展磁盘容量步骤就完成了，接下来进入centos扩展磁盘容量。 步骤二：在centos 7 系统中挂载磁盘 1、首先，开机启动虚拟机，进入centos 7系统中，打开终端，在终端界面中输入“# df -h”命令，并回车，在终端界面中可以看到原本30G的磁盘，并未扩容。如图： 2、接着，在终端界面中输入“# fdisk -l”命令，查看新磁盘的分区信息。如![在这里插入图片描述] 3、接着，在终端界面中输入“# fdisk /dev/sda”命令，对新加的磁盘进行分区操作（选择新增的磁盘），并回车。如图： 4、接着，在终端命令中，输入“p”命令，回车，查看已分区的数量。如图： 5、接着，在终端命令中，输入“n”命令，回车，新增一个分区。如图： 6、接着，在终端命令窗口中输入“p”命令,回车，在打开的分区号命中使用默认的分区号，并回车。如图： 7、接着，在显示的起始扇区直接敲回车键，在弹出的Last后面中，直接敲回车键即可进入下一步（在如图画框位置直接使用回车即可进入下一步）。如图： 8、接着，继续在终端命令窗口中输入“p”回车，查看当前分区的信息，在显示的信息中就可以看到已经多了一个新的分区了，大小就是刚设置的大小。如图： 9、接着，在终端命令中输入“w”命令，回车，写入磁盘信息并保存。如图： 10、接着，在终端命令窗口中，输入“# reboot”回车，重启虚拟机格式化新建分区。如图： 11、接着，等待系统自动重启完成后，打开终端命令，在命令窗口中输入“# vgdisplay”，查看磁盘卷组名。如图： 12、接着，在终端命令窗口中输入“# pvcreate /dev/sda3”命令并回车，初始化刚建立的分区。如图： 13、接着，在终端命令窗口中输入“# vgextend centos /dev/sda3”命令并回车，把刚初始化的分区加入到虚拟卷组名中（命令：# vgextend 虚拟卷组名 新增的分区）。如图： 14、接着，继续在终端命令窗口中输入“# vgdisplay”命令，查看卷组的详细信息，在详细信息中可以看到刚增加的10G空间还是处于空闲的状态。如图： 15、接着，继续在终端命令窗口中输入“# df -h”命令并回车，查看并记下需要扩展的文件系统名（小编这边查看到的系统名是：/dev/mapper/centos-root，不同版本查看到的应该有所区别，大家应该注意区分）。如图： 16、接着，继续在终端命令窗口中输入“# lvextend -L +9G /dev/mapper/centos-root”命令并回车，扩容已有的卷组容量（注意：如果您扩容的是10G，这里10G就不能全部扩展，只能扩展比10G小的容量，不然系统会报错导致扩容失败，小编这里只扩容9G。命令：# lvextend -L +需要扩展的容量 需要扩展的文件系统名，需要注意命令中区分字母的大小写）。如图： 17、接着，继续在终端命令窗口中输入“# pvdisplay”命令并回车，查看当前的卷组，在显示的信息中卷组已经扩容成功了，接下来需要将文件系统也扩容。如图： 18、接着，继续在终端命令窗口中输入“# cat /etc/fstab | grep centos-root”命令并回车，查看文件系统的格式。如图： 19、接着，在上一步已经看到了文件系统的格式了，就需要使用相应的命令来扩展磁盘空间，在终端命令中输入“# xfs_growfs /dev/mapper/centos-root”命令并回车（命令：# xfs_growfs 文件系统名，不同的文件系统要用不同的命令，不然会导致报错）。如图： 20、接着，等待系统自动扩容完成，完成后，在终端命令窗口中输入“# df -h”命令并回车，查看磁盘大小是否扩容成功，在显示的磁盘信息中，可以看到磁盘扩容成功了。如图： 21、至此，VMware虚拟机如何设置CentOS 7 磁盘扩容教程分享结束。 转载自：https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9143f76256b1d99626b153e5cb9011da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64295461a958de5416d9c7f8778c2248/" rel="bookmark">
			【汇总版】计算机组成原理思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 导读与总结汇总思维导图 导读与总结 这是一份涵盖计算机组成原理基础知识的思维导图，它包括计算机系统的层次结构、指令和指令执行、CPU的组成和工作原理、存储器的层次结构和管理、输入输出设备的原理和接口、以及汇编语言的基础知识。通过这份思维导图，读者可以了解计算机系统的组成和工作原理，以及各个组成部分之间的关系。
首先，导图介绍了计算机系统的层次结构，包括硬件层、操作系统层、高级语言层和应用程序层。通过这个层次结构，读者可以了解计算机系统各个部分之间的关系和作用。接着，导图介绍了指令和指令执行的基本概念，包括指令的组成、指令的执行过程、指令的寻址方式等方面。通过这些介绍，读者可以了解指令是如何被计算机执行的。然后，导图介绍了CPU的组成和工作原理，包括CPU的寄存器、运算器、控制器等方面。通过这些介绍，读者可以了解CPU是如何执行指令的，以及各个部分之间的协作关系。之后，导图介绍了存储器的层次结构和管理，包括主存储器、高速缓存、虚拟存储器等方面。通过这些介绍，读者可以了解计算机如何管理和使用存储器。此外，导图还介绍了输入输出设备的原理和接口，包括输入输出设备的种类、输入输出设备的接口方式、输入输出设备的驱动程序等方面。通过这些介绍，读者可以了解计算机如何通过输入输出设备与外部环境进行交互。最后，导图介绍了汇编语言的基础知识，包括汇编语言的基本语法、汇编程序的编写和调试、汇编程序的优化等方面。通过这些介绍，读者可以了解计算机如何将汇编程序翻译为机器码，并可以编写简单的汇编程序。总之，《计算机组成原理思维导图》是一份详细介绍计算机组成原理基础知识的思维导图，通过对计算机组成原理的讲解，读者可以了解计算机的基本工作原理、各个组成部分之间的关系，并可以深入了解CPU、存储器、输入输出设备和汇编语言等方面的知识。 汇总思维导图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9abac24bd5a97e58d48ff42693eadaa7/" rel="bookmark">
			现代 CSS 高阶技巧，像 Canvas 一样自由绘图构建样式！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在今天，是否 CSS 还存在着更进一步的功能，能够实现更为强大的效果？没错，是可以的，这也就引出了今天的主角，CSS Houdini 之 CSS Paint API。
在上一篇文章中 -- 现代 CSS 之高阶图片渐隐消失术[1]，我们借助了 CSS @Property 及 CSS Mask 属性，成功的实现了这样一种图片渐变消失的效果：
CodePen Demo -- 基于 @property 和 mask 的文本渐隐消失术[2]。
但是，这个效果的缺陷也非常明显，虽然借助了 SCSS 简化了非常多的代码，但是，如果我们查看编译后的 CSS 文件，会发现，在利用 SCSS 只有 80 的代码的情况下，编译后的 CSS 文件行数高达 2400+ 行，实在是太夸张了。
究其原因在于，我们利用原生的 CSS 去控制 400 个小块的过渡动画，控制了 400 个 CSS 变量！代码量因而变得如此之大。
CSS Houdini 之 CSS Paint API 那么，如何有效的降低代码量呢？
又或者说，在今天，是否 CSS 还存在着更进一步的功能，能够实现更为强大的效果？
没错，是可以的，这也就引出了今天的主角，CSS Houdini 之 CSS Paint API。
首先，什么是 CSS Houdini？
Houdini 是一组底层 API，它们公开了 CSS 引擎的各个部分，从而使开发人员能够通过加入浏览器渲染引擎的样式和布局过程来扩展 CSS。Houdini 是一组 API，它们使开发人员可以直接访问 CSS 对象模型[3] （CSSOM），使开发人员可以编写浏览器可以解析为 CSS 的代码，从而创建新的 CSS 功能，而无需等待它们在浏览器中本地实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9abac24bd5a97e58d48ff42693eadaa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5129123ab78bdde4f043e65ab40fa926/" rel="bookmark">
			服务器常用密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IBM RD系列lenovo/len0vO
默认地址：192.168.70.125
默认用户/密码：USERID/PASSW0RD
联想服务器 联想 thinkserver RQ940
管理口IP192.168.0.120
账户/密码：admin/admin
rd350
IP：192.168.70.125
账号密码：USERID/PASSW0RD
admin/admin
albert/admin
lenovo/lenovo
lenovo/len0vO
USERID/PASSW0RD
DELL IP：192.168.0.120
默认账号：root 密码：calvin
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bae639dee5fe6341cb09e19a5f53ebc/" rel="bookmark">
			Docker配置镜像加速器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决
使用Docker 的时候，需要经常从官方获取镜像，但是由于显而易见的网络原因，拉取镜像的过程非常耗时，严重 影响使⽤ Docker 的体验。目前已经拥有了⼴泛的⽤户群体，并得到了 Docker 官方的大力推荐。 如果您是在国内的⽹络环境使用 Docker，那么 Docker 加速器⼀定能帮助到您。
Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：
1、阿里云加速器
2、DaoCloud 加速器 3、registry mirror阿里云加速器
二、配置镜像加速器 2.1、配置镜像加速器
提前进入阿里云。
1.在浏览器搜索阿里云官网
2.进入创建账号，提前有账号的直接进入账户中心，然后点击左上角的三横图标找到下图所示
3.
2.2、创建/etc/docker目录
在docker目录下创建一个daemon.json文件，并配置阿里云镜像加速地址
mkdir -p /etc/docker Sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'
{
"registry-mirrors": ["https://ethfeiv1.mirror.aliyuncs.com"]
}
EOF
2.3、激活docker配置文件 如果新安装了一个服务，归属于systemctl管理，要使新服务的服务程序配置文件生效，需要重新加载。
systemctl daemon-reload
2.4、重启docker服务 systemctl restart docker
三、检查加速器是否生效 docker info
（注：如果是centos6.8系统，可执行ps -ef|grep docker命令进行验证。）
至此docker镜像加速器的配置就完成了，感谢观赏。 如需要安装docker可查看其他文章。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aa7c38bbc4057ee3c07155ba8522af1/" rel="bookmark">
			top 并grep 特定信息打印至txt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux
1.sudo apt-key adv --kerserver keyserver.ubuntu.com --recv-keys 2CC98497A1231595
2.工程中我们经常会查看程序的占用情况，并统计相关数据，以下命令可实现打印top输出的cpu 内存占用率至txt
top -n 10 -d 1 -b |grep -E "chrome" |tr -s " "| cut -d ' ' -f 9,10,11|&gt; test.txt 其中
-n 10 -d 1 分别为监控次数和时间间隔chrome为所要监控的应用tr -s " " 表示将多个空格替换为一个空格cut为分隔命令， -d ’ '为分隔标志， -f 9,10,11 为保留第9,10,11列 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb2a085917621edba6d4b421c888f20/" rel="bookmark">
			小说作者推荐：漫漫何其多合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		壬寅年，我找你的第十一年。
——迟铮
深情命不太好扛不住就拜拜了失忆受（千途）X死缠烂打拜拜了还要再追回来年下攻（迟铮）
现代灵异 破镜重圆
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76ba36c57353a3e8cc16bdb2bf88a9a1/" rel="bookmark">
			docker安装elasticsearch报错 main ERROR No Log4j 2 configuration file found. Using default configuration
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Exception in thread "main" ElasticsearchParseException[malformed, expected settings to start with 'object', instead was [VALUE_STRING]]
报错信息
2023-04-06 15:40:50,427 main ERROR No Log4j 2 configuration file found. Using default configuration (logging only errors to the console), or user programmatically provided configurations. Set system property 'log4j2.debug' to show Log4j 2 internal initialization logging. See https://logging.apache.org/log4j/2.x/manual/configuration.html for instructions on how to configure Log4j 2
Exception in thread "main" ElasticsearchParseException[malformed, expected settings to start with 'object', instead was [VALUE_STRING]]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76ba36c57353a3e8cc16bdb2bf88a9a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1d7782071a05a830e04cb7e5093425/" rel="bookmark">
			在springboot项目中全局设置都用 UTC&#43;8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在springboot项目中, 我该如何全局设置java中跟时间相关的操作都用 UTC+8呢 总结 在Spring Boot项目中，全局设置Java中所有与时间相关的操作都使用UTC+8时区，可以通过以下方法实现：
首先，在Spring Boot应用程序启动时设置java.util包中的默认时区： import java.util.TimeZone; @SpringBootApplication public class MyApplication { public static void main(String[] args) { // 设置默认时区为 UTC+8 TimeZone.setDefault(TimeZone.getTimeZone("UTC+8")); SpringApplication.run(MyApplication.class, args); } } 这将使得基于java.util.Date和java.util.Calendar的时间操作都使用UTC+8时区。
对于Java 8中的新的日期和时间API（位于java.time包中），你可以创建一个全局的ZoneId实例，然后在你的代码中使用这个实例。可以通过以下方式创建一个全局的ZoneId实例： 在src/main/java/com/example/yourpackage/目录下创建一个名为GlobalZoneId.java的文件，并在其中添加以下内容：
package com.example.yourpackage; import java.time.ZoneId; public class GlobalZoneId { public static final ZoneId ZONE_ID = ZoneId.of("UTC+8"); } 然后，在你的项目中，每当你需要使用时区时，直接使用GlobalZoneId.ZONE_ID，例如：
import java.time.ZonedDateTime; import java.time.Instant; import com.example.yourpackage.GlobalZoneId; public class MyClass { public static void main(String[] args) { Instant instant = Instant.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e1d7782071a05a830e04cb7e5093425/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e94e667df420e3abf4ec6e03119798/" rel="bookmark">
			YOLOv5训练自己的数据集（labelImg制作标签）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOv5官方讲解： Train Custom Data - YOLOv8 Docs (ultralytics.com)
labelImg（制作标签用） ：GitHub - liyunfei0411/labelimg-master
目录
1、Create dataset.yaml
2、Create Labels
1、下载labelimg仓库并安装labelimg
2、开始标注
①创建文件夹
②设置路径
③打标
3、xml文件
4、txt文件（YOLO v5）
3、Organize Directories
4、运行命令行
1、Create dataset.yaml 将yaml文件放入yolov5/datasets文件夹中，此处命名为lego.yaml文件，接下来需要对yaml文件 进行修改。yaml文件主要进行2个设置：①dataset的路径设置；②classes的设置
①路径设置
（1）path：训练集和测试集所在的上一级文件夹
（2）train：训练集所在文件夹，路径为path/train
（3）val：验证集所在文件夹，路径为path/val
（4）test：测试集所在文件夹，路径为path/test，可不设置，为空
举例：
②classes设置
nc -- 类别数
类名字典 -- 编号: 类别名
例：0对应lego
或
2、Create Labels 1、下载labelimg仓库并安装labelimg https://github.com/liyunfei0411/labelimg-master.git win+anaconda环境下根据提示进行安装 打开Anaconda Prompt 后切换到labelimg文件夹输入以下命令
conda install pyqt=5 pyrcc5 -o libs/resources.py resources.qrc python labelImg.py python labelImg.py [IMAGE_PATH] [PRE-DEFINED CLASS FILE] 运行labelImg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4e94e667df420e3abf4ec6e03119798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23fae1d42bc39fc1051ab512f6113729/" rel="bookmark">
			一万小时定律-二进制安全一路杀到黑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MJ0011曾经发表过的一段话:
很有感触，也算了一下，接触程序、逆向、底层也有6年之久了，每天花费的时间，差不多在10~12个小时，那么取个平均数，11*365(节假日不休）*6= 24090，二万小时多一点。
每天投入10个小时 * 365天(一年) * 3 = 10950 小时
比起基础与天赋，更重要的是:
敢于开始的勇气 + 持之以恒的毅力.
1.博观而约取，厚积而薄发
2.学而不思则罔，思而不学则殆
3.书读百遍其义自见
4.聪明在于勤奋，天才在于积累
我们都是攀登者，我们都在翻越"二进制安全"这座高山。
所以亲爱的攀登者，请你不要担忧，当你已经开始攀登时，你已经成为这条路上的"先行者"。
这一条路上你会是孤独的，无助的，这是你一个人的战场。
我们在无数个日日夜夜里反编译与调试,在一个无人问津的问题上苦思冥想不得其解。
但是攀登者们，请你相信，未来的某天，数不清的CVE编号，高额的漏洞悬赏奖金，将会如期而至！
请保持耐心，日拱一卒，拱一拱吧!
我们将会翻越一座有又一座高峰，探索安全领域的未知秘密！
更多精彩内容:
二进制安全学习路线
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c39d619fdb9630214f6d3a4693d78b6f/" rel="bookmark">
			计组简答题（面试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 计算机系统概述
1.摩尔定律和Amdahl定律
摩尔定律：集成电路芯片的集成度每 18 个月翻一番
Amdahl 定律：计算机系统中某一部件由于采用某种更快的执行方式后，整个系统性能的提高与这种执行方式的使用频率或占总执行时间的比例有关。
2.翻译程序、解释程序、编译程序、汇编程序的区别联系
翻译程序：
编译程序：将高级语言一次性翻译成目标程序，生成目标程序。
解释程序：将源程序的一条语句翻译成对应的机器目标代码，并立即执行，不生成目标程序。
汇编程序：把汇编语言源程序翻译成机器语言程序。
3.什么是透明性
在计算机领域，站在某类用户的角度，感受不到某个事物或属性的存在。在CPU中，IR\MAR\MDR对各类程序员都是透明的。
4.字，字长，机器字长，指令字长，存储字长
字：用来表示被处理信息的单位，用来度量数据类型的宽度
字长：通常是指CPU内部用于整数计算的数据通路的宽度
机器字长：指字长
指令字长：一个指令字中包含的二进制代码的位数
存储字长：一个存储单元存储的二进制代码的长度
5.基准程序执行的越快说明机器性能越好吗
一般情况下，基准测试程序能够反应机器性能的好坏，但是，由于基准程序中的语句存在频度的差异，因此运行结果并不能完全说明问题。
6.早期冯诺依曼计算机的特点：
(1)将计算机要处理的问题用指令编成程序。
(2)指令和数据以同等地位存放在存储器中，并可按地址访问。
(3)以二进制形式表示指令和数据。
(4)在控制器的控制下，指令被逐条从存储器中取出来执行，产生控制流，在控制流的驱动下完成指令的功能。
(5)早期的冯·诺依曼机以运算器为中心，输入/输出设备通过运算器与存储器传送数据。
7.哈佛结构的优点：
(1)指令存储器只读，设计、控制简单；
(2)避免了数据对程序可能造成的破坏；
(3)利用 n 位地址可以获得 2 个 2n大小的地址空间。
目前大多数 RISC 系统采用哈佛结构
8.指令集体系结构（ISA）：
处理器支持的指令和指令的字节级编码称为指令集体系结构。ISA是软件和硬件的分界面，软件（程序）是由 ISA 规定的“指令”组成的，指令通过二进制编码规定其功能、源操作数和目的操作数的位置等信息。ISA 需要规定计算机程序员可见的所有组件及操作包括：
指令集：处理器可执行的指令的集合；
软件可见的处理器状态；
存储模式；
系统模型。
典型的 ISA：x86、ARM、POWER、MIPS、SPARC、RISC-V
9.SISD：传统串行计算机；SIMD：阵列/向量处理机；
MISD：无实际；MIMD：多处理机、机群（集群）系统。
10.计算机体系结构和计算机组成的区别联系
计算机系统结构：从外部研究计算机系统。它是使用者所看到的物理计算机的抽象，是编写出能够在机器上正确运行的程序所必须了解到的计算机的属性。
计算机组成：从计算机系统的内部来研究计算机的构成，主要内容包括：运算方法、CPU 组成、主存储器和输入输出设备、输入输出接口等。
第二章 数据的表示和运算
1.原码的优缺点：
优点：
 简单、直观，机器数和真值间的相互转换很容易。
 实现乘、除运算的规则简单。
缺点：实现加、减运算的规则较复杂。
2.IEEE754 标准：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c39d619fdb9630214f6d3a4693d78b6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c66863fbe1a4159ebaf0aad2d97102a/" rel="bookmark">
			函数传参问题（指针传参，值传参，引用传参）：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
形参和实参：
形参和实参关系：
实参为值传值
实参为指针传值
实参本身为普通变量
实参本身为指针
一级指针
二级指针
引用传值
形参和实参： 什么是形参（parameter），什么是实参（argument）
在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参。
给形参传递值的变量称为实际参数，简称实参。
形参和实参关系： 1) 形参变量只有在函数被调用时才会分配内存，调用结束后，立刻释放内存，所以形参变量只有在函数内部有效，不能在函数外部使用。
2) 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的数据，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参，所以应该提前用赋值、输入等办法使实参获得确定值。
3) 实参和形参在数量上、类型上、顺序上必须严格一致，否则会发生“类型不匹配”的错误。当然，如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型。
实参为值传值 代码：
#include&lt;iostream&gt; using namespace std; void swap(int a,int b) { cout&lt;&lt;"a address1 = "&lt;&lt;&amp;a&lt;&lt;endl; cout&lt;&lt;"b address1 = "&lt;&lt;&amp;b&lt;&lt;endl; int temp = a; a = b; b = temp; } int main() { int a = 10; int b = 20; cout&lt;&lt;"a address = "&lt;&lt;&amp;a&lt;&lt;endl; cout&lt;&lt;"b address = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c66863fbe1a4159ebaf0aad2d97102a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ecc4e3f61f83cf656b12649aadc18e2/" rel="bookmark">
			VScode配置8086汇编环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0、感慨 1、VScode的安装
2、下载MASM/TASM插件
3、测试汇编环境
新建文件
汇编文件配置
汇编代码的运行
0、感慨 搭配一个简单些的环境，对于我们汇编的学习很有帮助，在这里又不得不感叹vscode的强大，使用VScode+MASM/TASM插件就可以实现8086汇编。真的相对于其他的安装方式，我们都会认同越简单越好。
1、VScode的安装 Visual Studio Code - Code Editing. Redefined
vscode的安装过程没有什么难度，出了选择安装路径外，一律通过即可。
2、下载MASM/TASM插件 在扩展当中，搜索并下载MASM/TASM。
3、测试汇编环境 新建文件 这里我们只需要点击Ctrl+Shift+N即可出现，下面这个界面。
在这里需要已经新建好的工程文件夹。如我下图所示的“8086masm”。
在其左侧资源管理器中的文件夹下，新建一个temp.asm文件，这里一定要有.asm后缀。
汇编文件配置 vscode它仅仅是一个代码编辑器，并不会像IDLE一样写好代码就可以点击进行运行，这里需要自己进行相应的配置。在vscode界面，同时按下Ctrl+Shift+P调出命令面板，输入setting。
打开工作区设置(JSON)。下面是我的配置信息，仅供参考。
{ "masmtasm.ASM.emulator": "msdos player", "masmtasm.dosbox.run": "exit", "masmtasm.ASM.assembler": "MASM-v5.00", "masmtasm.ASM.actions": { "TASM": { "baseBundle": "&lt;built-in&gt;/TASM.jsdos", "before": [ "set PATH=C:\\TASM" ], "run": [ "TASM ${file}", "TLINK ${filename}", "&gt;${filename}" ], "debug": [ "TASM /zi ${file}", "TLINK /v/3 ${filename}.obj", "TD ${filename}.exe" ] }, "MASM-v6.11": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ecc4e3f61f83cf656b12649aadc18e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f0f2e82e581e67629579dbefb642fa3/" rel="bookmark">
			软考中级——计算机网络与信息安全基础概要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、OSI/RM七层模型
二、网络的拓扑结构
三、计算机网络的分类
四、TCP /IP 协议族
五、 IP地址 与子网划分
六、网络攻击的分类
七、对称加密技术与数字签名
八、各个网络层次的安全保障
九、防火墙
十、常见病毒与木马
十一、重点网络相关命令
一、OSI/RM七层模型 广播域：如果站点发出一个广播信号后能接收到这个信号的范围，通常来说一个局域网就是一个广播域。通常网络层的设备可以隔离广播域冲突域：一个站点向另一个站点发出信号，除目的站点外，有多少站点能收到这个信号，这些站点就构成一个冲突域。通常数据链路层设备可以隔离冲突域 (1)物理层：完全面向硬件，通过一系列协议定义了通信设备的机械、电气、功能和规程特征。负责将数字信号从一端传到另一端
(2)数据链路层：建立一条可靠的数据传输通道，在相邻结点之间有效地传输数据。实现了封装成帧，流量控制、差错控制、传输管理的功能。
(3)网络层：从发送端向接收端传送分组。解决了通信双方不相邻时，中间结点需要路由的问题。解决了异构网络互联的问题
(4)传输层：负责端到端的数据分组传送，保证实现数据包无差错，按顺序，无丢失，无冗余地传输。还负责检错和纠错。以及更有效地利用网络层所提供的服务。
(5)会话层：负责管理远程用户或进程间通信。包括通信控制、检查点设置、重建中断的传输链路、名字查找和安全验证服务。
(6)表示层：负责将数据转化为计算机程序的表示方法。负责通信协议的转换，数据的翻译、数据的加密、数据的压缩，字符的转换等工作。
(7)应用层：直接提供服务给使用者的应用软件层。包括各类应用过程的接口和用户接口。
1.三层交换机工作内容
三层指的是核心层，汇聚成，接入层，分别对应的交换机是核心交换机，汇聚交换机，接入交换机 。
当因特网经过防火墙后，进入核心交换机。核心交换机能够快速高效地数据分发，之后进入汇聚交换机，主要功能为过滤数据，之后接入交换机的功能就是为了接入PC电脑
2.网络接入技术
主要分为两种：(记一记名词)
有线接入技术：公用交换电话网络(PSTN)、数字数据网(DDN),综合业务数字网(ISDN),非对称数字用户线路(ADSL)、同轴光纤技术（HFC）无线接入技术：IEEE 802.11(WIFI) , IEEE802.15(蓝牙Bluetooth) 、红外(IrDA)、WAPI、 二、网络的拓扑结构 1.总线结构
特点：总线拓扑结构中只有一条双向通路，便于进行广播式传播信息；总线拓扑结构属于分布式控制；节点的增删和位置变动较容易；节点的接口通常采用无源电路；设备少，价格低，安装使用方便；对信号的质量要求高,通路故障则断网等。
2.星形结构
星形结构使用中央交换处理单元以放射状连接到网中的各个节点。中央单元采用电路交换方式以建立所希望通信的两点间专用的路径，通常用双绞线将节点与中央单元进行连接。
特点：维护管理容易；故障隔离检测容易；网络延迟时间短等。中央交换处理单元负载高，故障则断网
3.环形结构
环形结构的信息传输线路构成一个封闭的环，各节点通过中继器连入网内，各中继器首位相接，信息单向沿环路逐点传送。
特点：环形网中信息的流动方向是固定的，两个节点仅有一条通路； 有旁路设备；信息要串行通过多个节点，系统响应速度慢，一个节点故障则断网等。
4.树形结构
树形结构是总线结构的扩充形式，传输介质是不封闭的分支电缆，主要用于多个网络组成的分级结构中。
特点：同总线结构。
5.分布式结构
无严格的布点规则和形状，各节点之间有多条线路相连。
特点：有较高的可靠性；资源共享方便，网络响应时间短；节点的路由选择和流量控制难度大，管理软件复杂；硬件成本高。
三、计算机网络的分类 分类方式类别通信距离广域网、局域网、城域网信息交换方式电路交换网、分组交换网、综合交换网网络拓扑结构星形网、树形网、环形网、总线网通信介质双绞线网、同轴电缆网、光纤网、卫星网等传输带宽基带网、宽带网适用范围公用网、专用网速率高速网、中速网、低速网通信传播方式广播式网络、点到点式网络 四、TCP /IP 协议族 服务 端口telnet ，TCP端口23FTP， TCP端口21(传输命令和参数) ，20(传送文件) TFTP 简单文件传输协议 ，UDP端口
69HTTP协议，WWW万维网服务，TCP端口80SMTP 简单邮件传输协议 ，TCP端口25POP3 邮局协议3 邮件接收 ，TCP端口110DNS（域名解析）服务 ，UDP端口53 DHCP服务，UDP端口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f0f2e82e581e67629579dbefb642fa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abfcc57a9c7b6e16f9e002b060a1f1cc/" rel="bookmark">
			【数据库运维】MYSQL备份恢复管理（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
五，mysql备份策略
3，策略三：mydumper备份数据库
案例一：备份数据库sc的信息
4，策略四：lvm快照从物理角度实现几乎热备的完全备份，配合二进制日志备份实现增量备份
案例：lvm备份
5，策略五：xtrabackup 备份数据库，实现完全热备份与增量热备份
案例一：完全备份
案例二：增量备份
五，mysql备份策略 3，策略三：mydumper备份数据库 （1）Mydumper安装
[root@node1 ~]# rz -E rz waiting to receive. [root@node1 ~]# ll [root@node1 ~]# yum localinstall mydumper-0.10.5-1.el7.x86_64.rpm （2）安装完后，查看产生了哪些文件
[root@node1 ~]# rpm -ql mydumper /usr/bin/mydumper 备份
/usr/bin/myloader 恢复
案例一：备份数据库sc的信息 （1）查看数据库sc的详细信息
mysql8.0.30 [it]&gt;select * from sc; 备份
（1）备份数据库sc的信息
-B 指定数据路
-S 套接字
-o 指定备份的路径
[root@node1 ~]# mydumper -u root -p 123456 -B it -S /tmp/mysql.sock -o /backup/db/it （2）上述命令备份的为目录，查询目录结构
[root@node1 ~]# tree /backup/db/it （3）查看文件metadata;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abfcc57a9c7b6e16f9e002b060a1f1cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5184c1b4591c213a00c2f01b13b86cf2/" rel="bookmark">
			高频小信号谐振放大器【Multisim】【高频电子线路】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实验目的与要求
二、实验仪器
三、实验内容与测试结果
1、观察输入、输出波形，估算谐振电压增益
2、测试放大器的频率响应特性，估算谐振电压增益和通频带
3、测试负载电阻对放大器性能的影响
四、实验结果分析
五、扩展实验（选做）
一、实验目的与要求 1、了解Multisim的基本功能，初步学习其使用方法
2、熟悉谐振放大器电路结构及工作原理
3、掌握谐振放大器的放大与选频功能的测试方法
4、掌握谐振放大器的性能参数的测试方法
二、实验仪器 微机，仿真软件Multisim13.0
三、实验内容与测试结果 在Multisim13.0电路窗口中，创建如下图所示仿真电路。
图1
如何将电路的节点显示出来？
Options---Sheet properties
1、观察输入、输出波形，估算谐振电压增益 对图1，单击仿真按钮，从示波器中观察到的输入输出波形如下：
峰-峰值 的精确读取：
移动最左侧两根光标，一根移动到任一波峰附近，另一根移动到任一波谷附近，然后用左侧T1、T2右边的左移右移箭头微调光标，观察通道A、通道B的输出数据，直到（绝对值）最大值，然后读取T2-T1的数据，就是峰-峰值） 光标在两个波形上的的切换
鼠标单击哪一根波形，光标的就会定位到哪一个波形上
电压增益 = 输出电压/输入电压 = 5.475V / 140.185mV = 39.0555
20*log(39.0555)= 31.834dB
2、测试放大器的频率响应特性，估算谐振电压增益和通频带 选择软件AC analysis，参数设置如下：Start frequency: 1MHz, Stop frequency: 11MHz, Sweep type: Linear, Number of points: 1000, Vertical scale: Decibel, V(4)为输出变量
中文版：开始频率：1MHZ、截止频率：11MHZ、扫描类型：线性扫描、点数：1000、垂直规模：db（分贝），v(5)为输出变量
Multisim13.0 具体操作步骤如下：
Simulate --- Analyses --- AC analysis
参数设置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5184c1b4591c213a00c2f01b13b86cf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5387b4ea35e0d64cffe52884b70ea6f0/" rel="bookmark">
			超详细IDEA配置SSM环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 数据库建表 create database idcard; create table usertable ( id int(11) primary key not null auto_increment, uname varchar(50) not null, upwd varchar(32) not null ); 2. 新建maven项目 New Project，只选择左边的Maven和上面的SDK，其他全部不选，next：
输入GroupId和ArtifactId：
完成Finish：
进入主界面如下图所示：
（可以选择右下角自动提示的 Enable Auto-Import，后期就能自动导入maven坐标了）
3. 配置pom.xml 打开pom.xml，填入如下dependencies，亲测这些坐标是相互兼容的，包括了spring、spring mvc、mybatis、mysql、servlet、junit、log4j等：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5387b4ea35e0d64cffe52884b70ea6f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b9f07649601956641e0942f6067883/" rel="bookmark">
			搭建WeCross跨链平台，并编写跨链智能合约
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WeCross是由微众银行自主研发并完全开源的区块链跨链协作平台，支持应用与多链互操作、同/异构链间互操作等多维跨链交互。——来自《WeCross技术文档》
本教程基于wecross-demo，以实现多群组跨链为例：
跨链示例：以group1作为源链、group2作为目标链，group2上部署了智能合约，其中包括了全局变量data和修改全局变量data的函数setData(_data)。在跨链过程中，group1发起跨链请求传递函数参数data，指定目标函数就是group2上智能合约对应的setData，试图修改group2上的全局变量data，以此实现跨链合约调用。
0. 环境配置 Ubuntu Linux 18.04
MySQL
Java 11.0.18
1. 安装wecross-demo 下载脚本：
cd ~bash &lt;(curl -sL https://gitee.com/WeBank/WeCross/raw/master/scripts/download_demo.sh) 执行脚本：
cd ~/wecross-demobash clear.shbash build_cross_groups.sh 执行期间需要输入MySQL数据库的ip、端口port、用户名username和密码password： 下载完成之后输入y，开启控制台console：
输入login，进入管理员控制台：
2. 编写跨链合约 跨链合约需要包含三个函数：
源链中发起跨链交易的函数目标链中处理跨链交易的函数源链中接收跨链交易执行结果的回调函数 合约源码路径：~/wecross-demo/WeCross-Console/conf/contracts/solidity/SetDataInterchain.sol
如下所示：
pragma solidity ^0.5.0; pragma experimental ABIEncoderV2; import "./WeCrossHub.sol"; contract SetDataInterchain { // 声明WeCrossHub WeCrossHub hub; function init(address _hub) public { hub = WeCrossHub(_hub); } // 全局变量data string data; constructor() public {} function setData(string memory _data) public { data = _data; } function getData() public returns (string memory) { return data; } // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9b9f07649601956641e0942f6067883/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef361141c18bb8d95329ca33dbed5303/" rel="bookmark">
			vue-video-player 一款vue的前端视频播放插件 支持m3u8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目进行时, 对视频模块需要进行组件开发，结合当前使用的开发框架是vuecli。 于是寻找到vue-video-player 根据github上的文档进行开发，发现并不能实现播放功能，于是在网站上进行寻找发现，vue-video-player依赖于videojs
效果图
1、安装： npm install vue-video-player --save
推流/m3u8 需要：npm install --save videojs-contrib-hls
2、当前版本： "vue": "^2.6.11", "vue-video-player": "^5.0.2", "videojs-contrib-hls": "^5.15.0", 3、vue-video-player 官方文档： &lt;template&gt; &lt;!-- video-player-box ==&gt; video-player vjs-custom-skin --&gt; &lt;video-player class="video-player vjs-custom-skin" ref="videoPlayer" :options="playerOptions" :playsinline="true"&gt; &lt;/video-player&gt; &lt;/template&gt; &lt;script&gt; // 需要添加的配置 // videojs -- videoPlayer 核心 import videojs from 'video.js' import 'vue-video-player/src/custom-theme.css'; // 根据官方文档配置发现没有效果 import 'video.js/dist/video-js.css' import { videoPlayer } from 'vue-video-player' export default { components: { videoPlayer }, data() { return { playerOptions: { // videojs options muted: true, language: 'en', playbackRates: [0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef361141c18bb8d95329ca33dbed5303/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5955c6cfa21cc98404869291097ab38/" rel="bookmark">
			stable-diffusion-webui安装（2）：扩展模块extensions——汉化、双语等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关博文- stable-diffusion-webui的基础功能手动安装，了解代码结构、依赖、模型出处主要教程参考：https://jihulab.com/hunter0725/stable-diffusion-webui-localization-zh_CNstable-diffusion 训练GUI安装——lora、dreambooth 原始界面，空空如野 中文（双语、日语）插件安装与使用 Simplified Chinese localization / bilingual 中文原始插件：https://github.com/dtlnor/stable-diffusion-webui-localization-zh_CN加速下载插件：https://jihulab.com/hunter0725/stable-diffusion-webui-localization-zh_CN （该链接内也有详细教程）双语 插件：https://github.com/journey-ad/sd-webui-bilingual-localization日语插件：https://github.com/Katsuyuki-Karasawa/stable-diffusion-webui-localization-ja_JP 下载插件 方法1 直接下载包后放到扩展文件夹中（服务器非本机只能使用这个方法） github下载插件整个包到本机 或者中文加速下载 或者通过git下载 git clone https://jihulab.com/hunter0725/stable-diffusion-webui-localization-zh_CN.git 放置在 webui 的 extensions 目录下 解压，并把文件夹，放好之后应该会如下图
方法2 UI界面下载 extensions的选项卡
搜索 Simplified Chinese localization () Simplified Chinese localization 方法3 通过项目网址下载 启用翻译功能 中文操作步骤 setting &gt;&gt; user interface &gt;&gt; Localization (requires restart) &gt;&gt; 选择 zh-CN &gt;&gt; apply setting &gt;&gt; reload ui
中文切换成功 选择 None就变回去了
切换为双语（中文设置为None） 双语切换成功 日语 手动下载或者在extensions目录下载
git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5955c6cfa21cc98404869291097ab38/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/148/">«</a>
	<span class="pagination__item pagination__item--current">149/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/150/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>