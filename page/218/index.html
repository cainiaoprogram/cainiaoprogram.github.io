<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c4ce30f2111ecc328de5ec150ee5fb1/" rel="bookmark">
			【云原生】k8s(Kubernetes)中yaml文件快速阅读理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简言： k8s yaml中文件内容一般有kind类型之分，每种类型有不同的功能（一般用---符号隔开）
常见的kind类型：
（1）Endpoints：Endpoints可以把外部的链接到k8s系统中（可以理解为引用外部资源，如将一个外部mysql连接到k8s中）
（2）Service：部署一个内部虚拟IP，其他deployment可以链接。（可以简单理解为K8S的端口映射，如外部3444端口映射到pod应用中80端口）
（3）Secrets：用于存储和管理一些敏感数据，比如密码，token，密钥等敏感信息。（可以理解为ssh中的密钥）
（4）Deployment：部署一个Pod，内部只能链接service，无法互相链接。（可以简单理解为一个pod应用的部署工具，即使部署的应用挂了还能重启，但只能链接service服务）
备注：
（1）metadata一般每个类型中会带有metadata.name即表示该类型生成的名字，如
metadata: name: suncat （2）spec，资源详细定义，后面一般会带有该类型的详细信息。
如Service类型中定义接口的信息
spec: ports: - port: 3306 targetPort: 3306 protocol: TCP name: http 下面分别对下面几种kind类型来进行讲解：
一、Endpoints 先来看个需求：
我有个一个外部的mysql，不是使用本机的k8s部署的。但是现在我的应用程序想用它。那这时候，我改怎么使用它呢？毕竟k8s中的pod大部分只能通过service来链接。
这时候Endpoints就出现了，他是可以把外部的链接到k8s系统中，如：
apiVersion: v1 kind: Endpoints metadata: name: suncat-endpoints subsets: - addresses: # 代理ip - ip: 192.168.14.144 ports: - port: 3306 # 服务的端口 protocol: TCP name: http --- apiVersion: v1 kind: Service metadata: name: suncat-endpoints # 这里的名称要和上面一样才能关联 spec: ports: - port: 3306 targetPort: 3306 protocol: TCP name: http （1）首先我们看到，我们定义了名为suncat-endpoints的Endpoints，同时往suncat-endpoints配置了代理IP以及服务的端口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c4ce30f2111ecc328de5ec150ee5fb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de70e363787a409412ec57ee1612488/" rel="bookmark">
			【云原生之k8s】k8s管理工具kubectl详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【云原生之k8s】k8s管理工具kubectl详解 前言一、陈述式管理(1)陈述式资源管理方法(2)k8s相关信息查看①查看版本信息②查看节点信息③查看资源对象简写④查看集群信息⑤配置kubectl自动补全⑥查看日志⑦基本信息查看1、查看master节点状态2、查看命名空间 ⑧命名空间操作1、查看default命名空间的所有资源2、创建命名空间3、删除命名空间 ⑨deployment/pod操作1、在命名空间kube-public创建副本控制器（deploment）来启动Pod（nginx-test）2、描述某个资源的详细信息3、查看命名空间kube-public中pod信息4、登录容器5、测试（重启）pod资源6、若无法删除，总是处于terminate状态，则要强行删除pod7、扩缩容7.1扩容7.2缩容 8、删除副本控制器 ⑩删除/增加label1、增加label2、删除label 二、声明式管理(1)声明式管理方法(2)查看资源配置清单(3)解释资源配置清单(4)修改资源配置清单并应用①离线修改1、修改yaml文件2、删除资源3、新建资源4、查看service资源 ②在线修改 (5)删除资源配置清单①陈述式删除②声明式删除 三、K8S模拟项目(1)项目的生命周期(2)创建kubectl run命令(3)发布kubectl expose命令①Service的作用②Service的类型③查看Pod网络状态详细信息和service暴露端口④查看关联后端的节点⑤查看service的描述信息 ⑥访问查看⑦查看访问日志 (4)更新kubectl set①获取修改模板②查看当前nginx的版本号③将nginx版本更新为1.15④监听pod状态⑤查看pod的ip变化 (5)回滚kubectl rollout①查看历史版本②执行回滚到上个版本③执行回滚到指定版本④检查回滚状态 (6)删除kubectl delete①删除副本控制器②删除service 四、金丝雀发布/灰度发布（Canary Release）(1)金丝雀发布简介(2)更新deployment的版本，并配置暂停deployment①创建pod②发布服务③查看nginx版本④定义版本change-cause1、查看历史版本2、定义版本3、再次查看历史版本4、更新nginx版本为1.15并配置暂停⑤观察更新状态⑥监控更新的过程⑦查看nginx版本⑧查看并更新历史版本change-cause⑨resume继续更新 前言 一、陈述式管理 (1)陈述式资源管理方法 kubernetes 集群管理集群资源的唯一入口是通过相应的方法调用 apiserver 的接口kubectl 是官方的 CLI 命令行工具，用于与 apiserver 进行通信，将用户在命令行输入的命令，组织并转化为apiserver 能识别的信息，进而实现管理 k8s 各种资源的一种有效途径kubectl 的命令大全
kubectl --helpk8s官方中文文档：http://docs.kubernetes.org.cn/683.html对资源的增、删、查操作比较容易，但对改的操作就不容易了 (2)k8s相关信息查看 ①查看版本信息 kubectl version ②查看节点信息 kubectl get nodes ③查看资源对象简写 kubectl api-resources ④查看集群信息 kubectl cluster-info ⑤配置kubectl自动补全 source &lt;(kubectl completion bash) 可通过TAB键实现命令补全，建议将其写入 /etc/profile
⑥查看日志 journalctl -u kubelet -f ⑦基本信息查看 kubectl get [-o wide|json|yaml] [-n namespace] 获取资源的相关信息，-n指定命名空间，-o指定输出格式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6de70e363787a409412ec57ee1612488/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/427564c8c33b22a5b947fb91d2a3d6c9/" rel="bookmark">
			BGP选路原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
BGP的选路原则
1，优选PV值最大的路由
修改PV影响选路的配置：
方法一：全局修改
方法二：精细化控制
2，优选LP属性值最大的路由
方法一：全局修改
方法二：精细化控制
3，自己始发的路由优先级高于从对等体处学来的
4，优选AS_PATH属性最短的路由
方法一：在R1的出方向修改AS_PATH属性。
5，优选起源码属性最优的路由。
控制选路的方法：
6，优选MED属性值较小的路由
干涉选路的方法：
7，EBGP对等体路由优于IBGP对等体
BGP的选路原则 BGP选路的前提条件 --- 丢弃所有不可用的路由信息 1，优选PV值最大的路由 PV值是华为的私有属性，可以理解为是权重，数值越大，其优先级越高，又因为他是所有选路原则中的第一条原则，所以，该属性是 本设备 上选路最方便的一个属性。 --- 这个属性只能在本设备上生效，他无法传递给任何BGP对等体。 修改PV影响选路的配置： 方法一：全局修改 [r4-bgp]peer 3.3.3.3 preferred-value ? INTEGER&lt;0-65535&gt; Preference value [r4-bgp]peer 3.3.3.3 preferred-value 100 AS-path 1, origin igp, MED 0, localpref 100, pref-val 0, valid, internal,pre 2 55, IGP cost 1, not preferred for PreVal 负载分担 --- 即让不同的流量走不同的线路，分担单一线路的压力 。 方法二：精细化控制 1，抓取流量 [r4]ip ip-prefix PV permit 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/427564c8c33b22a5b947fb91d2a3d6c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6687b24ec83c5124bdb095b5f816968/" rel="bookmark">
			计算机病毒，蠕虫，木马三者之间的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		病毒、蠕虫和木马是可导致计算机和计算机上的信息损坏的恶意程序。
1. 计算机病毒(Computer Virus) 根据《中华人民共和国计算机信息系统安全保护条例》，病毒的明确定义是“指编制或者在计算机程序中插入的破坏计算机功能或者破坏数据，影响计算机使用并且能够自我复制的一组计算机指令或者程序代码”。
病毒必须满足两个条件： （1）它通常将自己的代码置于另一个程序的执行路径之中。
（2）能自我复制。它可能用受病毒感染的文件副本替换其他可执行文件，既可以感染台式计算机也可以感染网络服务器。
2. 蠕虫（Worm） 蠕虫(worm)病毒是一种常见的计算机病毒，它利用网络进行复制和传播。蠕虫病毒是自包含的程序（或是一套程序），它能传播自身功能的拷贝或自身的某些部分到其他的计算机系统中（通常是经过网络连接）。
两个典型的蠕虫病毒 （1）震网（Stuxnet）病毒 该病毒于2010年6月首次被检测出来，是第一个专门定向攻击真实世界中基础（能源）设施的“蠕虫”病毒，比如核电站、水坝、国家电网；
（2）比特币勒索病毒 WannaCry（又叫Wanna Decryptor），一种“蠕虫式”的勒索病毒，在2017年5月份爆发。WannaCry主要利用了微软“视窗”系统的漏洞，以获得自动传播的能力，能够在数小时内感染一个系统内的全部电脑。
3. 木马（Trojan Horse） 木马(Trojan Horse)，是指那些表面上是有用的软件、实际目的却是危害计算机安全并导致严重破坏的计算机程序。
两大特性 隐蔽性：是指木马的设计者为了防止木马被发现，会采用多种手段隐藏木马，这样服务端即使发现感染了木马，也难以确定其具体位置。
非授权性：是指一旦控制端与服务端连接后，控制端将窃取到服务端的很多操作权限，如修改文件、修改注册表、控制鼠标、键盘、窃取信息等等。一旦中了木马，你的系统可能就会门户大开，毫无秘密可言。
4.病毒，蠕虫，木马之间的区别 这三种东西都是人为编制出的恶意代码，都会对用户造成危害，它们之间有着共性，但也有着很大的差别。
普通病毒与蠕虫病毒的区别 复制方式：普通病毒需要传播受感染的驻留文件来进行复制，而蠕虫不使用驻留文件即可在系统之间进行自我复制。
传染目标：普通病毒的传染能力主要是针对计算机内的文件系统而言，而蠕虫病毒的传染目标是互联网内的所有计算机。
木马与病毒的区别 木马不具传染性，它并不能像病毒那样复制自身，也并不“刻意”地去感染其他文件，它主要通过将自身伪装起来，吸引用户下载执行。
木马一般主要以窃取用户相关信息或隐蔽性控制为主要目的，相对病毒而言，可以简单地说，病毒破坏你的信息，而木马窥视你。
参考书籍 《软件安全:漏洞利用及渗透测试》刘哲理老师主编
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76de31182bd289518a1e625885496176/" rel="bookmark">
			软件安全内存区域详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识回顾 编制程序的四个步骤：编辑、编译、链接和运行
编译：检查语法并对单个文件产生可执行程序
链接：多个可执行文件进行关联（函数调用信息），增加启动程序等如何认识BUG和漏洞
BUG就是缺陷，一种表现就是用户部分操作导致程序崩溃，比如输入超长、除以0等
程序崩溃就意味着用户的输入会影响程序正常执行，意味着可能通过BUG提供的入口输入构造的恶意程序让程序做非法的事情，因此在安全人眼里，BUG是一种软件漏洞 知识点一：内存区域 内存区域：一个进程可能被分配到不同的内存区域去执行
代码区：通常是指用来存放程序执行代码的一块内存区域。这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取指并执行。静态数据区：通常是指用来存放程序运行时的全局变量、静态变量等的内存区域。通常，静态数据区包括初始化数据区（Data Segment）和未初始化数据区（BSS Segment）两部分。未初始化数据区BSS区存放的是未初始化的全局变量和静态变量，特点是可读写，在程序执行之前BSS段会自动清0。堆区：用于动态地分配进程内存。进程可以在堆区动态地请求一定大小的内存（给代码区的代码使用），并在用完之后归还给堆区。动态分配和回收是堆区的特点。栈区：用于支持进程的执行，动态地存储函数之间的调用关系、局部变量等，以保证被调用函数在返回时恢复到母函数中继续执行。
程序在执行的过程需要两种不同类型的内存来协同配合，即栈区和堆区。
堆区和栈区的区别
申请方式： 栈：由系统自动分配。例如，声明一个局部变量int b，系统自动在栈中为b开辟空间。堆：需要程序员自己申请，并指明大小，在c中malloc函数，如 p 1 = ( c h a r ∗ ) m a l l o c ( 10 ) p1 = (char^*)malloc(10) p1=(char∗)malloc(10) 。 申请效率： 栈由系统自动分配，速度较快，但程序员是无法控制的。堆是由程序员分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来方便。
**注意：指向堆块的指针或者句柄，指向的是块身的首地址。**也就是，我们使用函数申请得到的地址指针都会越过8字节(32位系统)的块首，直接指向数据区(块身)。
堆块的大小包括块首在内，如果申请32字节，实际会分配40字节，8字节的块首+32字节的块身。
堆块的单位是8字节，不足8字节按8字节分配。
在Windows系统中，占有态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。其中，最重要的堆表有两种：空闲双向链表freelist（简称空表）和快速单向链表lookaside（简称快表）。快表是为了加速堆块分配而采用的堆表，从来不发生堆块合并。由于堆溢出一般不利用快表，故不作详述。
空表包含空表索引(Freelist array)和空闲链块两个部分。空表索引也叫空表表头，是一个大小为128的指针数组，该数组的每一项包括两个指针，用于标识一条空表。
堆块释放。堆块的释放操作包括将堆块状态由占用态改为空闲态、链入相应的堆表。所有释放的堆块都链入相应的表尾。
堆块合并。堆块的分配和释放操作可能引发堆块合并，即当堆管理系统发现两个空闲堆块相邻时，就会进行堆块合并操作。
堆块的合并包括几个动作：将堆块从空表中卸下、合并堆块、修改合并后的块首、链接入新的链表（合并的时候还有一种操作叫内存紧缩）。
知识点二：函数调用 函数调用时候将借助系统栈来完成函数状态的保存和恢复。代码区中精确的跳转都是在与系统栈巧妙地配合过程中完成的。当函数被调用时，系统栈会为这个函数开辟一个新的栈帧，并把它压入栈中。**每个栈帧对应着一个未运行完的函数。**栈帧中保存了该函数的返回地址和局部变量。从逻辑上讲，栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数执行完后返回到哪里等等。当函数返回时，系统栈会弹出该函数所对应的栈帧。函数调用的步骤： 参数入栈：将参数从右向左依次压入系统栈中。返回地址入栈：将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行。代码区跳转：处理器从当前代码区跳转到被调用函数的入口处。栈帧调整： 保存当前栈帧状态值，已备后面恢复本栈帧时使用。将当前栈帧切换到新栈帧。 知识点三：常见寄存器 寄存器（register）是中央处理器CPU的组成部分。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。我们常常看到32位CPU、64位CPU这样的名称，其实指的就是寄存器的大小。32位CPU的寄存器大小就是4个字节。
CPU本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU要用的时候就去内存读写数据。但是，CPU的运算速度远高于内存的读写速度，为了避免被拖慢，CPU都自带一级缓存和二级缓存。基本上，CPU缓存可以看作是读写速度较快的内存。但是，CPU缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU使用寄存器来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU优先读写寄存器，再由寄存器跟内存交换数据。
每一个函数独占自己的栈帧空间。当前正在运行的函数的栈帧总是在栈顶。
ESP：栈指针寄存器（extended stack pointer），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。
EBP：基址指针寄存器（extended base pointer），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。
ESP和EBP之间的内存空间为当前栈帧，EBP标识了当前栈帧的底部，ESP标识了当前栈帧的顶部。
EIP：指令寄存器（extended instruction pointer），其内存放着一个指针，该指针永远指向下一条等待执行的指令地址。可以说如果控制了EIP寄存器的内容，就控制了进程——我们让EIP指向哪里，CPU就会去执行哪里的指令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76de31182bd289518a1e625885496176/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4450d6b19df6921b7f8874a40639d13/" rel="bookmark">
			缓存穿透、击穿、雪崩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 缓存穿透、击穿、雪崩 前言一、缓存穿透二、缓存击穿三、缓存雪崩总结 前言 在实际开发中，常常会用到redis作为存储层（例如Mysql等常用数据库）的缓存层。作为缓存层也会常常遇到缓存失效等问题，这些问题的如何来的，又要怎样解决，可以一起来往下探讨。
一、缓存穿透 概念
缓存穿透从字面意思上看，就是穿过缓存层直接访问存储层。其原因是因为redis里没有用户想要查询的数据，从而去访问持久层数据库查询。例如在双11的时候，用户量增大，想要查询一个不存在的物品，缓存都没有命中就会去找持久层的数据库查询，此时给了数据库很大的压力，从而造成缓存穿透。
解决办法
缓存一个空对象
​ 当访问到数据库层时，如果没有查询到，则立刻将返回的空对象缓存起来，同时设置一个过期时间（一般不超过5min），于是当再查询此数据时就不会去访问数据库层了。
设置一个过滤规则处理
​ 这样的规则有布隆过滤器。布隆过滤器是一种数据结构，对所哟可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。
二、缓存击穿 概念
缓存击穿与缓存穿透的区别是，由于大量用户访问同一个热点key，在热点key失效的一瞬间，就会有大量用户穿过缓存层去访问数据库层，增加数据库的压力。
解决办法
设置热点数据永不过期
​ 将所需的热点key不设置过期时间，就不会出现失效的情况。
加互斥锁
​ 使用分布式锁，保证每个key同时只有一个线程去查询，其他线程只需等待即可。
三、缓存雪崩 概念
缓存雪崩是指，在某个时间段内，缓存集中过期失效，此时当有大用量用户访问时，所有请求都会到达数据库层，从而造成数据库宕机。
解决办法
设置不同过期时间
​ 由于是缓存集体失效，那我们只需将key设置不同过期时间即可。
数据预热
​ 我们可以先把热点数据全部预先访问一遍，此时可能会有大量访问的数据就会写入到缓存中。
设置热点数据永不过期
​ 和缓存击穿一样，将所需的热点key不设置过期时间，就不会出现失效的情况。
加互斥锁
​ 和缓存击穿一样，保证每个key同时只有一个线程查询，从而重新写入缓存。
总结 通俗来讲三种缓存情况：
缓存穿透是大量用户查询不到所需要的数据缓存击穿是大量用户查询单条热点key，并且缓存在此时失效缓存雪崩是大量用户查询多个热点key，并且缓存在此时失效 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e145b44d4c00060f22e499df38fa6dbd/" rel="bookmark">
			MyBatisPlus详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatisPlus 一、MyBatisPlus概述 为什么要学习？ MyBatisPlus可以节省我们大量工作时间，所有的CRUD代码都可以自动化完成JPA、tk-mapper、MyBatisPlus偷懒用的~ 简述 官网https://baomidou.com/为简化开发而生MyBatis-Plus（简称 MP）是一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作，BaseMapper强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 二、快速开始体验 官网地址：https://baomidou.com/pages/226c21/#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B
步骤
创建数据库 DROP TABLE IF EXISTS user; CREATE TABLE user ( id BIGINT(20) NOT NULL COMMENT '主键ID', name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名', age INT(11) NULL DEFAULT NULL COMMENT '年龄', email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (id) ); DELETE FROM user; INSERT INTO user (id, name, age, email) VALUES (1, 'Jone', 18, 'test1@baomidou.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e145b44d4c00060f22e499df38fa6dbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f72f0ce1825c841723a0055c232bea81/" rel="bookmark">
			python 使用pip安装报错 FileNotFoundError：[WinError 2]系统找不到指定的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在Anaconda Prompt可以使用pip 在Windows自带的cmd却无法使用pip 系统一直说FileNotFoundError
我通过网上说的通过命令安装卸载pip没有效果 一直报错
后面我就觉得可能是冲突 就把anaconda Promptk可以使用的pip安装路径的环境变量设置了 pip是可以运行了但是发现是anaconda路径下的 安装下载还是不可以用
环境安装
此电脑-&gt;右键选择属性-&gt;高级系统设置-&gt;环境变量-&gt;选择path-&gt;点击编辑-&gt;点击新建 把自己Anaconda的安装路径和bin路径和Script的路径复制粘贴进去 点击确定
最后还是通过重新卸载安装python版本解决了此问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b7b35aeba642d032c88dbe62b86b3c6/" rel="bookmark">
			解决java.net.SocketTimeoutException: Read timed out
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1:在debugger的时候过久会出现该现象,或者读写过大的文件的时候 在tomcat中修改server.xml，增加 disableUploadTimeout=“false”，取消读写连接超时设置 &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" disableUploadTimeout="false" redirectPort="8443" URIEncoding="UTF-8"/&gt; 或者增加keepAliveTimeout=“100000”，增大连接生存时间 &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" keepAliveTimeout="100000" redirectPort="8443" URIEncoding="UTF-8"/&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac3061a1e96a21b4e6ce65ea8537089/" rel="bookmark">
			MQTT学习笔记(1)--网络调试助手连接阿里云物联网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初探 MQTT的网络调试助手通信测试 上手之前觉得很有难度，但是当你慢慢上手，你回过头来，你会发现哦，原来是这样的啊！
这里用的平台是阿里云的物理网平台所以有必要要介绍一下如何使用平台，如何申请，和白嫖平台。
物联网平台申请 阿里云 - 物联网 MQTT注册
产品 ProductKey
设备 DeviceName
设备三元组 DeviceSecret
进入阿里云物联网平台免费注册 物联网平台 (aliyun.com)
填写 产品名称、所属品类 “、” 节点类型 “、” 连接方式 “、” 数据格式 “、” 认证方式 "，点击下方保存
找到设备三元组
三元组为
{“ProductKey”:“hhyyFwo5b9l”,
“DeviceName”:“D001”,“DeviceSecret”:
“be5c22218e57fc60a64a00c23c05849a” }
添加功能。添加了几个开关和温湿度的属性。
点击产品步骤如下
添加页面
添加标准模块
发布上线
第一步是申请，然后第二步可以说是通过这个设备来了解mqtt报文协议的报文发送原理。
利用网络调试助手连接阿里云物联网
{
“ProductKey”: “hhyyFwo5b9l”,
“DeviceName”: “D001”,
“DeviceSecret”: “be5c22218e57fc60a64a00c23c05849a”
}
客户端id D001|securemode=3,signmethod=hmacsha1| 38字节
16 进制
44 30 30 31 7C 73 65 63 75 72 65 6D 6F 64 65 3D 33 2C 73 69 67 6E 6D 65 74 68 6F 64 3D 68 6D 61 63 73 68 61 31 7C
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ac3061a1e96a21b4e6ce65ea8537089/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df0beab0098a7347518c3206ff4ef67/" rel="bookmark">
			解决url中&amp;times被转成×的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1:&amp;符号和times结合会被转义，那就不写在一起，将参数放在第一位 2:【&amp;】符号转义成html实体，【&amp;】的实体是【&amp;】 3:&amp;符号和times结合会被转义，那就放在点击跳转不会被转义 4:&amp;符号和times结合会被转义，那就htmlspecialchars(url)结果正常，未转义 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ec55f5b6391e0a469ae34b6e291b492/" rel="bookmark">
			机器视觉 飞拍曝光计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相机飞拍存在拖影问题，需正确选择高帧率相机，高频高亮光源，以及曝光时间设定。
参考公式：曝光时间 *物体运动速度 ≤ 运动方向精度需求
例如：
相机现在的曝光时间是2000us，传送带运动的速度是 100mm/s，使用的相机分辨率为 2448*2048，视野范围是 300mm*250mm，物体运动的方向是水平方向 ，精度要求拖影不超过 1/2像素。此时的场景能满足飞拍要求吗？
曝光时间*物体运动速度 =2000*100/1000000=0.2mm
水平方向像素精度 要求为 =300/2448*1/2=0.061mm
由于0.2mm&gt;0.061mm，所以无法满足此飞拍运动场景的精度要求 。
根据以上计算，有以下解决办法：
（1）提高光源亮度，降低相机的曝光时间
曝光时间 ≤ 0.061/100 = 610us
只要将曝光时间设置小于610us，拖影即不超过1/2像素。
（2）降低传送带的速度
物体运动速度 ≤ 0.061mm/2000us = 30.5mm/s
只要将传送带速度降至30.5mm/s，即可保证2000us的曝光时间产生的拖影不超过1/2像素。
相互学习，共同富裕。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4d06d8dfe2c85bfc873c57c64fe30cb/" rel="bookmark">
			myBatis配置文件模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis-config.xml模板如下：
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!--事务管理器--&gt; &lt;transactionManager type="JDBC"/&gt; &lt;!--数据源--&gt; &lt;dataSource type="POOLED"&gt; &lt;!--旧版mysql应使用com.mysql.jdbc.Driver--&gt; &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;!--useSSL=true 使用安全连接--&gt; &lt;!--&amp;amp; 转义 &amp;--&gt; &lt;!--useUnicode=true 防止编码错误--&gt; &lt;!--characterEncoding=UTF-8 防止中文乱码--&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis_?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--mapper--&gt; &lt;mappers&gt; &lt;mapper resource="com/jiu/mapper/PersonMapper.xml"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; mapper.xml如下:
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;!--namespace 与哪个接口对应--&gt; &lt;mapper namespace="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4d06d8dfe2c85bfc873c57c64fe30cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7601f41130c636bb1ca3d32ae30a0123/" rel="bookmark">
			PTA 1017 A除以B(Python版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。
输入格式： 输入在一行中依次给出 A 和 B，中间以 1 空格分隔。
输出格式： 在一行中依次输出 Q 和 R，中间以 1 空格分隔。
输入样例： 123456789050987654321 7 输出样例： 17636684150141093474 3 提交结果：
代码： a, b = input().split() a = int(a) b = int(b) s1 = a % b s2 = (a - s1) // b print('{} {}'.format(s2, s1)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c93a752a51271c76cee2681fb021e78e/" rel="bookmark">
			JSP的九种内置对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSP有九个内置对象（又叫隐含对象），不需要预先声明就可以在脚本代码和表达式中随意使用，即不需要实例化，直接使用其方法即可。
pageppagecontentoutconfigexceptionrequestreponsesessionapplication 作用域：
前五种都是作用于页面，request是一次请求（客户端向服务器），response是一次响应（服务器向客户端），session是一次会话（一次请求，一次响应），application是全局范围，只要app存在就有作用。
1 JSP九大内置对象分为四类： 输入输出对象：out对象、response对象、request对象
通信控制对象：pageContext对象、session对象、application对象
Servlet对象:page对象、config对象
错误处理对象：exception对象
2.九种对象简介： out对象：用于向客户端、浏览器输出数据。out 对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。
request对象：封装了来自客户端、浏览器的各种信息。request 对象是 javax.servlet.httpServletRequest类型的对象。 该对象代表了客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。request对象的作用域为一次请求。
response对象：封装了服务器的响应信息。response 代表的是对客户端的响应，主要是将JSP容器处理过的对象传回到客户端。response对象也具有作用域，它只在JSP页面内有效。
exception对象：封装了jsp程序执行过程中发生的异常和错误信息。exception 对象的作用是显示异常信息，只有在包含 isErrorPage=“true” 的页面中才可以被使用，在一般的JSP页面中使用该对象将无法编译JSP文件。excepation对象和Java的所有对象一样，都具有系统提供的继承结构。exception 对象几乎定义了所有异常情况。在Java程序中，可以使用try/catch关键字来处理异常情况； 如果在JSP页面中出现没有捕获到的异常，就会生成 exception 对象，并把 exception 对象传送到在page指令中设定的错误页面中，然后在错误页面中处理相应的 exception 对象。
config对象：封装了应用程序的配置信息。config 对象的主要作用是取得服务器的配置信息。通过 pageConext对象的 getServletConfig() 方法可以获取一个config对象。当一个Servlet 初始化时，容器把某些信息通过 config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数
page对象：指向了当前jsp程序本身。page 对象代表JSP本身，只有在JSP页面内才是合法的。 page隐含对象本质上包含当前 Servlet接口引用的变量，类似于Java编程中的 this 指针。
session对象：用来保存会话信息。也就是说，可以实现在同一用户的不同请求之间共享数据。session 对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用户都生成一个session对象，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用Map类来保存数据，因此保存数据的格式为 “Key/value”。 session对象的value可以使复杂的对象类型，而不仅仅局限于字符串类型。
application对象：代表了当前应用程序的上下文。可以在不同的用户之间共享信息。application 对象可将信息保存在服务器中，直到服务器关闭，否则application对象中保存的信息会在整个应用中都有效。与session对象相比，application对象生命周期更长，类似于系统的“全局变量”。
pageContext对象：提供了对jsp页面所有对象以及命名空间的访问。pageContext 对象的作用是取得任何范围的参数，通过它可以获取 JSP页面的out、request、reponse、session、application 等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用 pageContext对象。
3 常用方法 3.1request 模拟获取用户信息：
&lt;%-- Created by IntelliJ IDEA. User: 86187 Date: 2022/8/4 Time: 19:18 To change this template use File | Settings | File Templates.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c93a752a51271c76cee2681fb021e78e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cb4767654077236b70d486670f0fb3d/" rel="bookmark">
			Echart按需引入时报错---[ECharts] Component legend（‘XX‘） is used but not imported.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [ECharts] Component legend（‘XX’） is used but not imported. 解决： import { LegendComponent } from 'echarts/components'; echarts.use([LegendComponent]); 关于Echart全局/按需引入请参考 Echart全局/按需引入 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ad281fc6a3f5f36ac1ff6d30160881f/" rel="bookmark">
			Vscode Remote SSH Unexpected line break at... 相关问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vscode 使用 Remote SSH 时出现 Unexpected line break at…提示，无法使用Remote SSH 原因：
ssh 无法使用，查看相关教程需要将本地OpenSSH 的ssh.exe路径写入到Remote SSH配置文件中(Ctrl+shift+p，选择remote ssh settings)，写入之后提示了此错误，后面发现路径写错了位置(因为这个路径在设置里面第一项…)。解决方法：
写入到正确的路径位置即可，如图。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23727ff0d92ac96402f708f06621e44/" rel="bookmark">
			Lux 安装以及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lux 的安装： Github地址：UGitHub - iawia002/lux: 👾 Fast and simple vLideo download library and CLI tool written in Go
具体的安装步骤在github中已经讲述。
Windows安装
这里为了方便操作就不使用CMD了，直接使用PowerShell，需要的条件PowerShell 5+和.NET Framework 4.5+。
先在电脑左下角程序搜索框输入PowerShell，然后双击Windows PowerShell工具，再输入以下命令查看版本：
$PSVersionTable.PSVersion Major为版本号，一般目前常用电脑Windows 10符合条件，Windiows 7还需要升级，大致步骤如下：
1、安装.Net 4.5.2全量包 下载地址：https://www.moerats.com/usr/down/powershell/NDP452-KB2901907-x86-x64-AllOS-ENU.exe 2、升级PowerShell的补丁包 32位下载地址：https://www.moerats.com/usr/down/powershell/Win7-KB3191566-x86.zip 64位下载地址：https://www.moerats.com/usr/down/powershell/Win7-KB3191566-x64.zip 接下来安装一个命令行安装工具Scoop，使用命令：
iex (new-object net.webclient).downloadstring('https://get.scoop.sh') 再安装lux：
scoop install lux 该命令会给你把ffmpeg也一起安装好。
使用 使用命令：
lux [OPTIONS] URL [URL...] #可选参数如下 Options -i Information only -F string URLs file path -d Debug mode -j Print extracted data -v Show version Download: -f string Select specific stream to download -p Download playlist -n int The number of download thread (only works for multiple-parts video) (default 10) -c string Cookie -r string Use specified Referrer -cs int HTTP chunk size for downloading (in MB) (default 0) Network: -s string SOCKS5 proxy -x string HTTP proxy -retry int How many times to retry when the download failed (default 10) Playlist: -start int Playlist video to start at (default 1) -end int Playlist video to end at -items string Playlist video items to download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c23727ff0d92ac96402f708f06621e44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65971db75eaed208237677367f555474/" rel="bookmark">
			深入浅出Spring源码（一）构建Spring源码阅读环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文环境：windows10 + spring-5.3.22 + gradle-7.2 + IDEA2020 + jdk11
STEP 1.下载spring-framework源码2.下载gradle工具3.修改build.gradle配置4.导入IDEA步骤 1.下载spring-framework源码 🔥 地址：https://github.com/spring-projects/spring-framework/releases
2.下载gradle工具 🔥地址：https://gradle.org/releases/
✨解压缩即可
✨配置环境变量
① GRADLE_HOME : gradle工具路径
② GRADLE_USER_HOME ： gradle依赖保存路径，如果不配置会默认在C盘用户目录下生成.gradle文件
③ path ： %GRADLE_HOME%\bin
✨测试 gradle -v
✨添加初始化脚本
📑在init.d目录下添加的脚本，每次build之前都会被执行
init.gradle内容如下(注意协议是https，否者会报不安全异常)：
allprojects{ repositories { def ALIYUN_REPOSITORY_URL = 'https://maven.aliyun.com/nexus/content/groups/public' def ALIYUN_JCENTER_URL = 'https://maven.aliyun.com/nexus/content/repositories/jcenter' all { ArtifactRepository repo -&gt; if(repo instanceof MavenArtifactRepository){ def url = repo.url.toString() if (url.startsWith('https://repo1.maven.org/maven2')) { project.logger.lifecycle "Repository ${repo.url} replaced by $ALIYUN_REPOSITORY_URL." remove repo } if (url.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65971db75eaed208237677367f555474/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af8a5721d3a67da625508e6fad7c100/" rel="bookmark">
			Python基于PC版微信实现机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在github中有基于web版的微信实现的实时收发消息api，python调用起来非常简单。但是目前来说，大部分的用户没法登录web版的微信，因此也就没法使用。
今天我们介绍基于windows版的微信，实现实时收发信息。本文站在巨人的肩膀上，基于第三方提供的库，实现自动聊天机器人。效果如下：
1 微信实时收发消息 1.1 第三方库 基于第三方pc-wechat-hook-http-api实现微信实时收发消息。
需要注意的是，此库基于3.6.0.18版本微信。下载对应版本微信后，直接覆盖安装，这样可以保留聊天记录。
如果找不到对应版本的微信，可以直接到文末获取相关连接。
1.2 开启注入dll 想要实时获取微信消息，需要劫持响应的入口。这一部分内容我们无需过多关心技术细节，只需傻瓜式点击一下即可。
从pc-wechat-hook-http-api官方地址下载到如下三个文件。
如果pc-wechat-hook-http-api地址失效，读者可以直接到文末获取相关dll下载资源。
将HPSocket4C.dll文件复制到微信目录下（例如E:\Tencent\WeChat\[3.6.0.18]）
点击Daen注入器.exe文件：
其中：
文件目录是指微信安装路径，参考上图。DLL路径指的是DaenWxHook.dll文件的完整路径。进程参数直接使用默认即可。其中图中8089指本地用于接收微信实时消息的http server端口。8055指的是dll开启的http server端口，发送消息时只需往这个端口post数据即可。 点击注入并启动，登录微信即可。
1.3 实时收发消息 实时收发消息官方文档：https://www.apifox.cn/apidoc/project-1222856/doc-1012539
1.3.1 接收微信消息 对于实时接收消息，简单来说，就是在本地创建一个http server，端口与进程参数一致，即默认地址为：http://localhost:8089/wechat/。我们通过使用flask库创建http server
from flask import Flask, request import json import requests app = Flask(__name__) def on_rcv_chatroom_msg(from_wxid, msg): print("收到群消息") def on_rcv_p2p_txt(from_wxid, msg_txt): print("收到文本消息", from_wxid, msg_txt) @app.route('/wechat/', methods=['get', 'post']) def wechat(): data = request.stream.read() data = data.decode('utf-8') data = json.loads(data) type = data['type'] if type == 'D0003': data = data['data'] msg = data['msg'] from_wxid = data['fromWxid'] if "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0af8a5721d3a67da625508e6fad7c100/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8df9fa94a4359fb0020abb5c6e4014e/" rel="bookmark">
			红外图像是什么？红外线与计算机视觉相关的研究方向？（Visible and infrared image fusion）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 红外图像成像特点：由于红外图像是通过“测量”物体向外辐射的热量而获得的，故与可将光图像相比：分辨率差、对比度低、信噪比低、视觉效果模糊、灰度分布与目标反射特征无线性关系。
红外图像为什么有时候是黑白的，有时候是彩色的？ 红外摄像仪得到的是灰度图像，就是黑白报纸上的照片那样的图像。灰度图像经过伪彩色增强，把原图中各像素点的灰度级按照某种映射函数变换成不同的色彩，才得到彩色图像。
红外图像是单通道图像，并不是三通道。我们看的的红外彩色图像实际上是伪彩色，这和我们看到的可见光的彩色还是不同的。
红外和可见光图像融合算法研究是什么？ 可见光与红外图像融合（Visible and infrared image fusion）是图像融合领域的一个分支。
其在很多领域都有应用，例如可见光与红外图像融合跟踪（RGB-T tracking）、人脸识别、人耳识别、SLAM、国防领域。
图像融合不是简单的数据叠加，而是对多个图像传感器获得的互补或冗余信息进行集合的过程。它使得新图像满足图像处理中的特征提取、目标识别或分割的需要。因此，图像融合技术被广泛应用于计算机视觉、军事、遥感和医学等领域。
红外图像和可见光图像分别是通过红外成像传感器与可见光成像传感器获得的。由于两种传感器工作原理不同, 性能也就不同。
红外图像能较好地反应图像的热目标特性，但对场景亮度变化特征不敏感, 且图像清晰度较低；可见光图像能够较好地反应目标所在的场景细节信息，且清晰度较高。 所以将它们两者的优势结合： 红外和可见光图像融合能有效地综合红外图像目标特征信息和可见光图像的场景细节信息，得到信息更全面的融合图像（利用可见光和红外图像包含互补的信息） 。
可见光图像容易受光照影响但包含很多细节信息，而红外图像不易受光照影响但是缺乏细节信息。下图展示了一个可见光与红外图像融合的例子。
从方法上来讲，传统的图像融合方法主要包含基于空间域的和基于变换域的方法：
基于空间域的方法是指直接在空间域对源图像进行操作从而得到融合图像的方法，主要包含基于像素的(pixel-based)、基于块的(block-based)和基于区域(region-based)的方法。基于变换域的方法是指首先将源图像变换到某个变换域，然后在该变换域内进行图像融合（一般以系数的形式），最后再用逆变换得到融合图像的过程。常用的变换包括多尺度变换（例如小波变换）、压缩感知、稀疏表达等。近年来，随着深度学习的发展，深度学习技术也被引入到了可见光与红外图像融合领域。包括CNN，GAN，AutoEncoder等在内的一些深度学习模型被应用到了可见光与红外图像融合领域，并“取得了不错的效果”。 因此，目前的图像融合方法主要有三种：基于空间域的方法、基于变换域的方法、基于深度学习的方法。
相关链接：
红外与可见光图像融合论文阅读（一） - 知乎
红外和可见光图像融合算法研究 - 知乎
然后我看到知乎这个人一直在学习相关的融合技术，或许可以在它的博客看到相关的技术：奥本海默 - 知乎
拒绝“王婆卖瓜，自卖自夸” | VIFB：第一个可见光与红外图像融合Benchmark 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/205cbd117ff31250e531c4459f054549/" rel="bookmark">
			C&#43;&#43;哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、哈希表1.1 哈希概念1.2 哈希冲突1.3 哈希函数1.4 载荷因子 二、解决哈希冲突2.1 闭散列2.2 闭散列代码实现2.3 开散列2.4 开散列代码实现 一、哈希表 1.1 哈希概念 顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O( logN)，搜索的效率取决于搜索过程中元素的比较次数。
理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。 如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。
当向该结构中：
插入元素
根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放搜索元素
对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功 该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(Hash Table)(或者称散列表)
1.2 哈希冲突 对于两个数据元素的关键字ki 和 kj (i != j)，有ki != kj，但有：Hash(ki) == Hash(kj)，即：不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。
把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。
1.3 哈希函数 引起哈希冲突的一个原因可能是：哈希函数设计不够合理。 哈希函数设计原则：
哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0
到m-1之间.
哈希函数计算出来的地址能均匀分布在整个空间中,哈希函数应该比较简单。
常见哈希函数
直接定制法–(常用)
取关键字的某个线性函数为散列地址：Hash（Key）= A*Key + B
优点：简单、均匀
缺点：需要事先知道关键字的分布情况 使用场景：适合查找比较小且连续的情况。除留余数法–(常用)
设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：Hash(key) = key% p(p&lt;=m),将关键码转换成哈希地址。平方取中法–(了解)
假设关键字为1234，对它平方就是1522756，抽取中间的3位227作为哈希地址； 再比如关键字为4321，对它平方就是18671041，抽取中间的3位671(或710)作为哈希地址 平方取中法比较适合：不知道关键字的分布，而位数又不是很大的情况。折叠法–(了解)
折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。
折叠法适合事先不需要知道关键字的分布，适合关键字位数比较多的情况。随机数法–(了解)
选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key) = random(key),其中random为随机数函数。通常应用于关键字长度不等时采用此法。数学分析法–(了解)
设有n个d位数，每一位可能有r种不同的符号，这r种不同的符号在各位上出现的频率不一定相同，可能在某些位上分布比较均匀，每种符号出现的机会均等，在某些位上分布不均匀只有某几种符号经常出现。可根据散列表的大小，选择其中各种符号分布均匀的若干位作为散列地址。 哈希函数设计的越精妙，产生哈希冲突的可能性就越低，但是无法避免哈希冲突
1.4 载荷因子 散列表的载荷因子定义为：a = 填入表中的元素个数 / 散列表的长度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/205cbd117ff31250e531c4459f054549/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a22fb7e555d40acd4df5d178ab8fe895/" rel="bookmark">
			Servlet获取请求参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Servlet 获取请求参数【重点】 前端页面
&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;测试从前端获取请求参数&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="GetParameter" method="post"&gt; &lt;span&gt;账号: &lt;/span&gt;&lt;input type="text" name="username"&gt;&lt;br&gt;&lt;br&gt; &lt;span&gt;密码: &lt;/span&gt;&lt;input type="password" name="password"&gt;&lt;br&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;hr&gt; &lt;form action="GetParameter" method="get"&gt; &lt;span&gt;账号: &lt;/span&gt;&lt;input type="text" name="username"&gt;&lt;br&gt;&lt;br&gt; &lt;span&gt;密码: &lt;/span&gt;&lt;input type="password" name="password"&gt;&lt;br&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 案例代码
/** * 获取前端请求的参数 */ @WebServlet("/GetParameter") public class GetParameter extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 此方法用于获取从前端传递过来的参数，要求形参名必须和前端中的name一致 String username = req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a22fb7e555d40acd4df5d178ab8fe895/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d75a172b658ebece5523c112969786f6/" rel="bookmark">
			如何用python搭建神经网络,python实现人工神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何利用python实现神经网络 官方不支持，建议等支持吧。dll有自己版本对应的，必须使用专门为python3.4编译的dll（），你拿python2.7的肯定用不了。
如果非要使用——方法一：自己编译opencv的源码方法二：安装python2.7。
怎么用python训练神经网络 无需深度学习框架，如何从零开始用Python构建神 搭建由一个输入层，一个隐藏层，一个输出层组成的三层神经网络。输入层中的节点数由数据的维度来决定，也就是2个。相应的，输出层的节点数则是由类的数量来决定，也是2个。
（因为我们只有一个预测0和1的输出节点，所以我们只有两类输出，实际中，两个输出节点将更易于在后期进行扩展从而获得更多类别的输出）。
以x，y坐标作为输入，输出的则是两种概率，一种是0（代表女），另一种是1（代表男）。
怎样用python构建一个卷积神经网络模型 上周末利用python简单实现了一个卷积神经网络，只包含一个卷积层和一个maxpooling层，pooling层后面的多层神经网络采用了softmax形式的输出。
实验输入仍然采用MNIST图像使用10个featuremap时，卷积和pooling的结果分别如下所示。
部分源码如下：[python] viewplain copy#coding=utf-8'''''Created on 2014年11月30日@author: Wangliaofan'''import numpyimport structimport matplotlib.pyplot as pltimport mathimport randomimport copy#testfrom BasicMultilayerNeuralNetwork import BMNN2def sigmoid(inX):if (-inX)== 0.0:return 999999999.999999999return 1.0/((-inX))def difsigmoid(inX):return sigmoid(inX)*(1.0-sigmoid(inX))def tangenth(inX):return (1.0*(inX)-1.0*(-inX))/(1.0*(inX)+1.0*(-inX))def cnn_conv(in_image, filter_map,B,type_func='sigmoid'):#in_image[num,feature map,row,col]=&gt;in_image[Irow,Icol]#features map[k filter,row,col]#type_func['sigmoid','tangenth']#out_feature[k filter,Irow-row+1,Icol-col+1]shape_image=numpy.shape(in_image)#[row,col]#print "shape_image",shape_imageshape_filter=numpy.shape(filter_map)#[k filter,row,col]if shape_filter[1]&gt;shape_image[0] or shape_filter[2]&gt;shape_image[1]:raise Exceptionshape_out=(shape_filter[0],shape_image[0]-shape_filter[1]+1,shape_image[1]-shape_filter[2]+1)out_feature=numpy.zeros(shape_out)k,m,n=numpy.shape(out_feature)for k_idx in range(0,k):#rotate 180 to calculate convc_filter=numpy.rot90(filter_map[k_idx,:,:], 2)for r_idx in range(0,m):for c_idx in range(0,n):#conv_temp=numpy.zeros((shape_filter[1],shape_filter[2]))(in_image[r_idx:r_idx+shape_filter[1],c_idx:c_idx+shape_filter[2]],c_filter)(conv_temp)if type_func=='sigmoid':out_feature[k_idx,r_idx,c_idx]=sigmoid(sum_temp+B[k_idx])elif type_func=='tangenth':out_feature[k_idx,r_idx,c_idx]=tangenth(sum_temp+B[k_idx])else:raise Exceptionreturn out_featuredef cnn_maxpooling(out_feature,pooling_size=2,type_pooling="max"):k,row,col=numpy.shape(out_feature)max_index_Matirx=numpy.zeros((k,row,col))out_row=int(numpy.floor(row/pooling_size))out_col=int(numpy.floor(col/pooling_size))out_pooling=numpy.zeros((k,out_row,out_col))for k_idx in range(0,k):for r_idx in range(0,out_row):for c_idx in range(0,out_col):temp_matrix=out_feature[k_idx,pooling_size*r_idx:pooling_size*r_idx+pooling_size,pooling_size*c_idx:pooling_size*c_idx+pooling_size]out_pooling[k_idx,r_idx,c_idx](temp_matrix)max_index=numpy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d75a172b658ebece5523c112969786f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2cf37af01cd0a4de3597e1be2dcab52/" rel="bookmark">
			什么是P = NP?问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言天才基本法什么是P/NP问题？P = NP 成立吗？ 总结 提示：以下是本篇文章正文内容，Java系列学习将会持续更新 引言 今天我们先放松一下，这篇文章并不是Java课程的学习，而是带大家认识一个学术问题。但是请大家放心，这里并不是学术的探讨，因为我也不懂，我只是搜集一些相关的资料带大家了解一下这个问题。更多的是出于满足一下各位的好奇心。。。
天才基本法 相信大家应该都知道最近有一部剧非常火——天才基本法，由雷佳音、张子枫、张新成主演的由同名小说改编的电视剧。
该剧具体讲了什么内容我就不在这里详细说了，相信有好多小伙伴都已经刷完了(反正我已经刷完了，确实不错，值得推荐)，没有看的小伙伴也很值得一看。
我们今天只研究剧中提到的P=NP?问题，芝士世界的老林和裴之共同证明了P=NP完全成立，这也使得芝士世界的计算机、医疗、环保等多个领域得到了跨越式的发展。
而草莓世界的老林用尽二十多年的时间都没有能够证明，最后也只是在芝士裴之的帮助下证明了图同构是NP类问题的证明，这只是证明P=NP的一个阶段性胜利。。。
那我们就了解一下究竟P=NP？是个什么样的问题？
回到目录…
什么是P/NP问题？ P/NP问题是克雷数学研究所高额悬赏的七个千禧年难题之一，同时也是计算机科学领域的最大难题，关系到计算机完成一项任务的速度到底有多快。
P/NP问题是Steve Cook于1971年首次提出。
P指多项式时间（Polynomial），一个复杂问题如果能在多项式时间内解决，那么它便被称为P问题，这意味着计算机可以在有限时间内完成计算；
NP指非确定性多项式时间（nondeterministic polynomial），一个复杂问题不能确定在多项式时间内解决。
假如NP问题能找到算法使其在多项式时间内解决，那说明它转变成了P类问题。
有点难以理解，那就拿股市举个例子：
昨天某只股票收盘价为10元，今天收盘价为11元。涨幅是多少？
我们很容易就可以通过公式计算出来，(11-1)/10=10%，这就是P类问题。
那再请问，明天的收盘价是多少？是涨还是跌？
这个问题我们不能通过一个具体的算法得到答案，只有等到了明天才能验证得到正确答案，这就是NP类问题。
P/NP问题就是研究能否把NP类问题转变为P类问题。如果能，则P = NP 成立；否则，P != NP。
回到目录…
P = NP 成立吗？ 我们先假设P = NP成立，那么给这个世界带来些什么影响呢？
如果P=NP真的成立，那么对于任何一件随机的事件，我们都可以找出针对性的算法来计算或控制事件的走向。还是刚刚那个股市的例子，我们就可以计算出每支股票在未来的涨跌情况，这样岂不成了“股票之神”？在医疗上，我们可以解决很多目前无法攻克的疾病如癌症；在科技上，我们可以通过特定的算法来解决我们无法实现的技术难题；总之无论在哪个领域都会取得很大的突破。毫不夸张地说，甚至有可能做到跨越时间、空间，知晓未来、洞察于千里之外。
当然，也存在一定的弊端，如对密码学的影响，破译密码会变得很容易。甚至会对计算机网络安全构成巨大的威胁。
这虽然听起来好像很扯淡！但确实有很大一部分数学家和科学家在一直研究这个问题。那到底 P = NP 能否成立？有没有人证明了它的成立？或是证明了它不可能成立？
学术界的最新消息：
公元2010年：
8 月 6 日，HP LAB的 Vinay Deolalikar 教授宣布证明了P!=NP，并且公布了证明过程。
8 月 8 日，Lipton 在博客上讨论了这篇论文，给出了略显乐观的评价：这是一个值得认真对待的证明。这篇文章引来大量严肃的学术性回复，大多来自业内人士，各方看法不一。
8 月 9 日，Lipton 写了一篇新的博客文章，指出了 Deolalikar 证明思路中的一些重大漏洞。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2cf37af01cd0a4de3597e1be2dcab52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceede51a2cab440fa26c7b36d580e623/" rel="bookmark">
			Opecv检测多个圆形（霍夫圆检测，轮廓面积筛选，C/C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要是利用霍夫圆检测、面积筛选等完成多个圆形检测，具体代码及结果如下。
第一部分是头文件（common.h）：
#pragma once #include&lt;opencv2/opencv.hpp&gt; #include&lt;opencv2/highgui.hpp&gt; #include&lt;iostream&gt; using namespace std; using namespace cv; extern Mat src; void imageBasicInformation(Mat&amp; src);//图像基本信息 const Mat houghCirclePre(Mat&amp; srcPre);//霍夫圆检测预处理 void houghCircle(Mat&amp; srcPreHough);//霍夫圆检测 const Mat RectCirclePre(Mat&amp; srcPre);//面积筛选拟合圆的预处理 void AreaCircles(Mat&amp; AreaInput);//面积筛选拟合圆检测 第二部分是主函数：
#include"common.h" Mat src; int main() { src = imread("1.jpg",1); if (src.empty()) { cout &lt;&lt; "图像不存在！" &lt;&lt; endl; } else { namedWindow("原图", 1); imshow("原图", src); imageBasicInformation(src); Mat srcPreHough = houghCirclePre(src); houghCircle(srcPreHough); Mat RectCir = RectCirclePre(src); AreaCircles(RectCir); waitKey(0); destroyAllWindows(); } return 0； } 第三部分为霍夫圆检测函数（hough.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceede51a2cab440fa26c7b36d580e623/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3627e6eca730c85dd813fbb3ad5a211/" rel="bookmark">
			用户认证——Kerberos集成Hadoop的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 创建Hadoop系统用户 为Hadoop开启Kerberos，需为不同服务准备不同的用户，启动服务时需要使用相应的用户。须在所有节点创建以下用户和用户组。
创建hadoop组
[root@hadoop102 ~]# groupadd hadoop
hadoop103和hadoop104做同样的操作。
创建各用户并设置密码
[root@hadoop102 ~]# useradd hdfs -g hadoop
[root@hadoop102 ~]# echo hdfs | passwd --stdin hdfs
[root@hadoop102 ~]# useradd yarn -g hadoop
[root@hadoop102 ~]# echo yarn | passwd --stdin yarn
[root@hadoop102 ~]# useradd mapred -g hadoop
[root@hadoop102 ~]# echo mapred | passwd --stdin mapred
hadoop103和hadoop104做同样的操作。
2 Hadoop Kerberos配置 2.1 为Hadoop各服务创建Kerberos主体（Principal） 主体格式如下：ServiceName/HostName@REALM，例如 dn/hadoop102@EXAMPLE.COM
1.各服务所需主体如下
2.创建主体
1）在所有节点创建keytab文件目录
[root@hadoop102 ~]# mkdir /etc/security/keytab/
[root@hadoop102 ~]# chown -R root:hadoop /etc/security/keytab/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3627e6eca730c85dd813fbb3ad5a211/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d106efae5efba00cd36bce056d47a2be/" rel="bookmark">
			Tomcat安装及运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat 操作 Tomcat 安装 1、解压压缩文件
【注意】不要有中文路径
2、效果如下
Tomcat 运行 1、移动到tomcat安装路径下，双击进入
2、进入bin目录
3、双击 startup.bat 启动 Tomcat
【注意】区别于 startup.sh ，此脚本用于 Linux 下 Tomcat 的启动，建议打开文件扩展名方便查看
查看 -&gt; 勾选文件扩展名 双击之后稍等片刻，会弹窗下面的窗口
4、出现图中显示毫秒值的字样说明启动成功
Tomcat 运行失败原因 如果一闪而过，说明没有配置 JAVA_HOME 环境变量
1、选择此电脑中的属性并打开
2、点击高级系统设置
3、选择高级下面的环境变量
4、在系统变量下点击新建
5、输入变量名并点击浏览目录
JAVA_HOME 6、找到 JDK 在系统中的位置并选中点击确定
7、配置好变量名和变量值后点击确定
8、此时我们发现系统变量中已经有了JAVA_HOME，点击确定
9、点击确定
10、此时环境变量已经配置好，重新点击 startup.bat 就能成功打开 Tomcat 服务器软件
Tomcat 测试访问 打开 Tomcat 服务器软件后在浏览器的网址栏中输入下面的网址，能跳转到 Tomcat 主页说明访问成功
http://localhost:8080 Tomcat 停止 在 Tomcat 的 bin 目录下点击 shutdown.bat 即可
Tomcat 中导入前端静态项目 我们可以将一些写好的 HTML、CSS、JavaScript、图片等静态资源组成的项目通过 Tomcat 服务器使用浏览器对其进行访问，这里我使用了一个最简单的测试项目，同学们可自行选择自己写好的页面进行测试，只需要把项目所在文件夹整个复制到 Tomcat 的 webapps 目录下即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d106efae5efba00cd36bce056d47a2be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5113f9b5d13c9cce6bd0c78f124e37e5/" rel="bookmark">
			【校内模拟8.5】【搜索】A
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【校内模拟8.5】【搜索】A 题目 解题思路 这个题跟纪中的火炬手还挺像的
不过本题搜索的是在后面添0/1能到达什么新状态（就是余数，如果两个数mod n余数相同，显然只需要保留小的那个）
代码 #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; struct lzf{ int a[50]; }d[1000010]; bool vis[1000100]; int n,h,t=1,x,dq,q[1000010]; int main() { scanf("%d",&amp;n); if (n==1) { printf("1\n"); return 0; } q[1]=1; d[1].a[1]=d[1].a[0]=1; vis[1]=1; while (h&lt;t) { h++; dq=q[h]; x=dq*10%n; //在后面多填一个0 if (!vis[x]) { vis[x]=1; d[x]=d[dq]; ++d[x].a[0]; if (x==0) { for (int i=1;i&lt;=d[x].a[0];i++) printf("%d",d[x].a[i]); return 0; } q[++t]=x; } x=(dq*10+1)%n; //在后面多填一个1 if (!vis[x]) { vis[x]=1; d[x]=d[dq]; d[x].a[++d[x].a[0]]=1; if (x==0) { for (int i=1;i&lt;=d[x].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5113f9b5d13c9cce6bd0c78f124e37e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fae661a0b3cba17b25745faaecfe133e/" rel="bookmark">
			（附代码）入门 | 如何使用C/C&#43;&#43;调用Python脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编者荐语 在进行 C/C++ 进行开发的时候，很多非核心的功能，可以使用 Python 进行实现，因此学习在 C/C++ 程序中如何调用 Python 程序也是非常有必要的。实现的方法有许多种，今天给大家介绍一种小编认为的最方便的方法。
文章将会介绍一种通过嵌入 Python 来丰富你的 C/C++ 应用程序的方法（Python/C API），这种方式会使您的应用程序能够在不改变程序原有功能的基础上，使用 Python 编程语言而不是 C/C++ 语言来实现应用程序的某些功能。
这种方式可以用于多种目的，主要目的是允许我们通过用 Python 编写一些脚本来根据需要定制应用程序（某些功能可以更容易地用 Python 编写）。当你嵌入 Python 时，主程序一般情况下与 Python 实现无关，应用程序的某些部分会在需要的时候调用 Python 解释器，运行一些我们编写的 Python 代码。所以，如果你需要嵌入 Python，那么你首先需要一个 C/C++ 主程序。
基本使用方法 Python 提供了一套 C API库，使得开发者能很方便地从C/ C++ 程序中调用 Python 模块，C++ 用户应该注意，尽管 API 是完全使用 C 来定义的，但头文件已将入口点声明为 extern “C”，因此 API 在 C++ 中使用此 API 不必再做任何特殊处理。
具体的文档参考官方指南：https://docs.python.org/3.9/extending/embedding.html
如果需要使用这个套API，我们需要引入一个头文件和一个库文件，以Cmake构建为例，我们需要在 CMakeLists.txt 中加入：
find_package (Python COMPONENTS Interpreter Development REQUIRED) target_include_directories(${PROJECT_NAME} PRIVATE ${Python_INCLUDE_DIRS}) target_link_libraries(${PROJECT_NAME} PRIVATE ${Python_LIBRARIES}) Windows环境下应该是需要保证如下两个环境变量的存在（暂未测试）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fae661a0b3cba17b25745faaecfe133e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2e5aab312f98f0dc0bc6ceea6f025d2/" rel="bookmark">
			shap库源码和代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SHAP有两个核心，分别是shap values和shap interaction values，在官方的应用中，主要有三种，分别是force plot、summary plot和dependence plot，这三种应用都是对shap values和shap interaction values进行处理后得到的。
代码实现 a waterfall plot def waterfall(shap_values, max_display=10, show=True): """ Plots an explantion of a single prediction as a waterfall plot. The SHAP value of a feature represents the impact of the evidence provided by that feature on the model's output. The waterfall plot is designed to visually display how the SHAP values (evidence) of each feature move the model output from our prior expectation under the background data distribution, to the final model prediction given the evidence of all the features.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2e5aab312f98f0dc0bc6ceea6f025d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f63cd8328cbf17c21c1e825d878af45/" rel="bookmark">
			uniapp开发的h5网页如何去掉网址里的#号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在manifest.json里配置history模式，这里特别注意下面的 运行的基础路径 里不要写./因为这个默认会强制hash模式
如图
然后再服务器端配置下规则
history模式下配置nginx
location / {
try_files $uri $uri/ /index.html;
}
history模式下配置Apache RewriteEngine On
RewriteBase /
RewriteRule ^index\.html$ - [L]
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule . /index.html [L]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/589e9530503ddaeea8f1ce5bae2a894b/" rel="bookmark">
			数据库汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 什么是MySQL?
2.MySQL存储引擎MyISAM与InnoDB
3.事务四大特性
4.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景
5. 索引
6. InnoDB索引和MyISAM索引的区别
7. Sql的优化
8. 数据库的主从复制
9.varchar和char的使用场景
10.数据库连接池的作用
11. 数据库三范式
12. 关系型数据库和非关系型数据库区别
13. 数据库中join的left join , inner join, cross join
14.有哪些锁,select时怎么加排它锁
15. 死锁怎么解决
16. 事务
17. 视图
18. 游标
19. 存储过程
20. 触发器
21. drop、delete与truncate的区别
22. UNION与UNION ALL的区别
23. Mysql分页
24. 数据库优化
1. 什么是MySQL? MySQL是一个关系型数据库管理系统
2.MySQL存储引擎MyISAM与InnoDB 常用的存储引擎有以下： Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。
MyISAM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。
MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。
MyISAM与InnoDB区别： MyISAM：
每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件；存储空间较小数据和索引是分别存储的，数据.MYD，索引.MYI按记录插入顺序保存不支持外键和事务；不支持哈希索引，支持全文索引；表级锁定B+树索引，myisam 是堆表 Innodb：
所有的表都保存在同一个数据文件中数据和索引是集中存储的，.ibd按主键大小有序插入支持外键和事务行级锁定、表级锁定，锁定力度小并发能力高支持哈希索引，不支持全文索引B+树索引，Innodb 是索引组织表 select count(*)，myisam更快，因为myisam内部维护了一个计数器，可以直接调取。INSERT、UPDATE、DELETEInnoDB更优，SELECTMyISAM更优。
3.事务四大特性 原子性，要么执行，要么不执行 隔离性，所有操作全部执行完以前其它会话不能看到过程一致性，事务前后，数据总额一致持久性，一旦事务提交，对数据的改变就是永久的 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/589e9530503ddaeea8f1ce5bae2a894b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a2678adba4c3bde503c8d520fee11e/" rel="bookmark">
			redis高可用集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis高可用集群搭建_恶魔的复活的博客-CSDN博客_redis集群搭建
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8127a344b4e95672ea5d3dece832232f/" rel="bookmark">
			Pytorch入门--详解Mnist手写字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 什么是Mnist?
Mnist是计算机视觉领域中最为基础的一个数据集。
MNIST数据集（Mixed National Institute of Standards and Technology database）是美国国家标准与技术研究院收集整理的大型手写数字数据集，包含了60,000个样本的训练集以及10,000个样本的测试集。Mnist中所有样本都会将原本28*28的灰度图转换为长度为784的一维向量作为输入，其中每个元素分别对应了灰度图中的灰度值。Mnist使用一个长度为10的向量作为该样本所对应的标签，其中向量索引值对应了该样本以该索引为结果的预测概率。
2、代码实现
需导入的python库
import torch import scipy.misc from torch.utils.data import DataLoader from torchvision import transforms from torchvision.datasets import MNIST from torch import optim import torch.nn as nn import torch.nn.functional as F 构建模型
# 构建模型（简单的卷积神经网络） class LeNet(nn.Module): def __init__(self): super(LeNet, self).__init__() self.conv1 = nn.Conv2d(in_channels=1, out_channels=6, kernel_size =5, padding = 2) # 卷积 self.conv2 = nn.Conv2d(6, 16, 5) # Linear(in_feactures(输入的二维张量大小), out_feactures) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8127a344b4e95672ea5d3dece832232f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0cdfbcfea6fc9ce528e0a041de357d8/" rel="bookmark">
			Linux搭建Maven私服、依赖的上传与下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux搭建Maven私服、下载依赖 Linux搭建Maven私服在/usr/local下新建nexus目录，并进入下载nexus安装包将nexus-3.40.1-01-unix.tar.gz上传至nexus目录解压nexus-3.40.1-01-unix.tar.gz修改配置文件不能用root用户启动需要修改/usr/local/nexus/nexus-3.40.1-01/bin的nexus修改启动端口与访问路径 启动nexus 访问nexus登录nexus配置依赖推送修改本地Maven中的settings.xml文件修改需推送Maven的pom.xml文件依赖推送测试 配置私服依赖下载修改本地Maven中的settings.xml文件修改需下载依赖的pom.xml文件 Linux搭建Maven私服 需熟练Linux服务器的连接与基本操作命令
在/usr/local下新建nexus目录，并进入 // 进入/usr/local cd /usr/local // 创建nexus mkdir nexus // 进入nexus cd nexus 创建nexus图片: 下载nexus安装包 官网: 下载地址
整合资源下载: 下载地址
将nexus-3.40.1-01-unix.tar.gz上传至nexus目录 方式一：Linux命令上传 // 前提是进入前文创建好的nexus目录 rz -y 方式二：XFTP上传(需安装XFTP)，直接拖入即可
解压nexus-3.40.1-01-unix.tar.gz // 前提是进入前文创建好的nexus tar -zxvf nexus-3.40.1-01-unix.tar.gz 出现两个目录nexus-3.40.1-01和sonatype-work如下图所示：
修改配置文件 不能用root用户启动需要修改/usr/local/nexus/nexus-3.40.1-01/bin的nexus // 修改命令 vim nexus 将run_as_root=true改成run_as_root=false
修改启动端口与访问路径 // 进入 /usr/local/nexus/sonatype-work/nexus3/etc cd /usr/local/nexus/sonatype-work/nexus3/etc // 编辑 nexus-default.properties vim nexus-default.properties 将application-port的8081端口进行修改，默认为8081(可能会被占用)
将nexus-context-path=/的路径随自己意愿修改，可以不修改，默认为ip+端口访问
启动nexus // 进入 /usr/local/nexus/nexus-3.40.1-01/bin ./nexus start 访问nexus 没有修改端口和路径的情况：在浏览器输入ip:8081即可访问修改端口的情况：ip:已修改端口修改路径的情况：ip:8081/修改路径既修改端口又修改路径的情况：ip:新端口/新路径 小编因为业务需要二者全部修改，访问路径为 http://10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0cdfbcfea6fc9ce528e0a041de357d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/191c47a25cf346f2f8e46f613666cf0e/" rel="bookmark">
			redis连接不上，两种解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天某个项目的redis连不上了，将自己用到的两个解决办法写篇记录（实际使用时方法二选一即可）。
redis连接不上，两种解决方式 一、首先排查本地redis连接有没有问题1. 在服务器上查看redis2. 进入容器测试连接 二、连接redis的两种方式（二选一使用即可）1. 第一种：配置远程策略2. 第二种：使用redis network 地址替换作为redis的连接主机地址以上就是两种连接redis的办法。 我们最初在项目的application.yml文件上的redis配置是服务器ip+端口，但是这样的配置项目并没有成功连接redis： redis: isRedisCache: 1 #是否使用redis缓存 database: 0 # Redis数据库索引（默认为0） host: 176.17.0.9 # Redis服务器地址 port: 6379 # Redis服务器连接端口 password: 123456 # Redis服务器连接密码（默认为空） timeout: 1000 # 连接超时时间（毫秒） 一、首先排查本地redis连接有没有问题 1. 在服务器上查看redis [root@iZxxxxxxxxx20t8shdhZ ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 137f72546f00 redis "docker-entrypoint.s…" 10 days ago Up 10 days 0.0.0.0:6379-&gt;6379/tcp redis 2. 进入容器测试连接 进入容器：docker exec -it 137f72546f00 bash
连接redis：redis-cli -h ip地址 -p 端口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/191c47a25cf346f2f8e46f613666cf0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edda257ae4ff2b0c7abbb7267ed84232/" rel="bookmark">
			联邦学习：论文阅读小笔记（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、联邦学习的目的 1.防止隐私数据泄露，保障数据安全
2.打破不同行业、部门之间的数据壁垒，以实现机器学习模型的全局最优化
二、技术简述 将机器学习的数据存储和模型训练阶段转移至本地用户，客户端金鱼中心服务器交互模型更新的参数信息
三、联邦学习分类 完整的训练数据集D应该由（I,Y,X）构成。即 I:用户id、Y:标签信息、 X：特征信息
该采用哪种联邦学习方法应该看两部分信息重叠情况：
１ ） ２ 个数据集的用户特征重叠部分较大，而用户重叠部分较小，为横向联邦学习 ； ２ ） ２ 个数据集 的用户重叠部分较大， 而用户特征重叠部分较小，为纵向联邦学习 ； ３ ） ２ 个数据集的用户与用户特征重叠部分都比较小，为联邦迁移学习； 横向联邦学习纵向联邦学习联邦迁移学习（I,Y,X）X、Y相同；I不同X、Y不同；I相同X、Y、Z都不同应用场景不同地区不同银行之间的模型训练（模型训练特征重合，但不同银行提供用户不同）同一地区银行与电商平台之间训练模型（用户重叠，但银行提供特征情况不同于电商提供特征）不同地区银行与电商平台之间训练模型（用户id、标签信息、特征均不相同）本质将多方对不同目标的相同特征描述训练提取将多方对相同目标的不同特征描述训练提取问题客户端易发生恶意连接窃取信息问题恶意用户推测他方用户隐私数据举措增加检测方法；引入多方安全计算可通过RSA和哈希函数确保 四、联邦学习存在的问题 1.通信效率短板明显 全局模型训练时间=数据处理时间+通讯传输时间
可见通信传输效率是限制训练速度的主要因素
联邦学习数据：非独立同分布（Non-IID：只在概率统计理论中，各数据集的随机变量不服从于同意分布）
在传统分布框架算法中Non-IID比IID更难收敛，会出现通信轮数过多的问题
2.隐私安全有缺陷 在真实网络环境中会出现：恶意客户端修改模型更新、破坏全局模型聚合；恶意分析者分析模型信息推测源数据隐私；恶意服务器企图获得客户端源数据；
3.缺乏信任与激励机制 无高效激励机制➡难吸引足够的训练用户（数据）➡无法保证模型质量
无信任机制➡没能有效选择优质客户端➡模型精度降低
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3a1e6484b088b1e83229612124974bc/" rel="bookmark">
			SpringMVC执行流程简图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图如下：
SpringMVC执行流程文字叙述：
1. 浏览器发送请求，SpringMVC的中央管理器DisPatcherServlet进行拦截并处理；
2.中央管理器DisPatcherServlet进行调用处理器映射器HandlerMapping；
3.处理器映射器HandlerMapping返回处理器执行链HandlerExecutionChain,HandlerInterceptor拦截器,Handler给中央管理器DisPatcherServlet；
4.中央管理器DisPatcherServlet进行调用处理器适配器HandlerAdapter；
5.处理器适配器HandlerAdapter进行调用Handler；
6.Handler返回ModelAndView结果;
7.处理器适配器HandlerAdapter返回ModelAndView结果给中央管理器DisPatcherServlet；
8.中央管理器DisPatcherServlet根据ModelAndView结果调用视图解析器;
9.视图解析器再返回视图View;
10.中央管理器DisPatcherServlet根据视图View进行视图渲染；
11.最后中央管理器DisPatcherServlet进行响应。
---文章仅供个人记载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67e91d435f9341c35bf15eabc9d72832/" rel="bookmark">
			登录，注册（flask）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登录与注册 思路代码的实现注册的模型类注册蓝图注册路由写视图 思路 可以把登录注册写到一个视图里边，用一个post方法来实现登录注册
接收参数 首先先接收需要用的参数，也就是手机号，密码，验证码等，如果只用手机号登录注册，那就不需要接收密码。校验参数 看看接受的参数是否为空判断验证码是否正确 把接收过来的验证码与redis数据库里的验证码进行比对，如果正确则进行下一步，否则就返回验证码错误判断手机号是否已经注册，如果注册过的话就直接登录，否则就注册 简单来说，就是看看数据库里是否有这个手机号，有的话就登录，没有话就注册，提交到数据库手机号已经注册过，那就判断用户输入的密码是否正确，正确则登录成功，并返回token，否则就是返回登录失败 代码的实现 注册的模型类 class User(db.Model): id = db.Column(db.Integer, primary_key=True, autoincrement=True, comment="用户ID") phone = db.Column(db.String(11),comment="电话号码") username = db.Column(db.String(32),default="",comment="用户名") password = db.Column(db.String(16),default="",comment="密码") 注册蓝图 新建一个文件写入蓝图
from flask import Blueprint user_bp = Blueprint("work_bp",__name__,url_prefix="/work") 在create_app下注册
from flask import Flask from views.user import work_bp from models.model import db from flask_cors import CORS def create_app(config): flask_app = Flask(__name__) flask_app.config.from_object(config) db.init_app(flask_app) cors = CORS(flask_app) flask_app.register_blueprint(work_bp) return flask_app 注册路由 from flask import Blueprint from flask_restful import Api,Resource user_bp = Blueprint("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67e91d435f9341c35bf15eabc9d72832/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b58097c9886ef9671efa248ffc3b0d2/" rel="bookmark">
			如何写好一份PPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写工作汇报PPT，核心是：要让领导一眼看懂你做的汇报（PPT）。本着这个原则，这里老秦提供4种解决方案。
PowerPoint的核心作用是什么？——「Power」 your 「Point」。
PPT 的第一目的是沟通和传达，它是架在讲者和听者之间的桥梁，辅助两者之间进行更好的传达信息，让听众更容易理解、记忆、行动，从而实现演示目标。
那如何才能「Power」你的「Point」，让听众一眼看懂呢？——有4种信息处理的模式。
01：高桥流 虽然PPT优势在于图文并茂，但并不意味着单纯的文字表现力就会很弱。
在一定的场景下，没有图片的干扰，反而能更集中听众的注意力。
比如，讲座、发布会等场合的PPT，在需要特别强调某个观点，想要狠抓一把听众注意力时，这种类型的PPT也是很好的一种选择，是小米、华为、锤子等各类手机发布会上的常客。
这种全字型PPT中，最具代表的要属「高桥流」。
这种风格的PPT，一页一个关键词/句，串联起整个演示，简单直接，回到本质，完美的诠释了什么是「Power Point」。
这个手法的起源，有一个有趣的故事：有一位叫高桥征义的人，在2001年一次演讲中，由于现场没有合适演示工具，他用HTML制作投影片，用极快的节奏配上巨大的文字进行演示，给观众带来非常大视觉冲击。
这种形式颠覆了以往PPT演示模式，迅速流行开来，并以他的名字命名，即「高桥流」。
当然，由于一些重大的场合，白底黑字毕竟看起来有点简陋，所以这个风格在演变过程中，有时候也会加个背景图。
你看，哪怕现场照片放这么小，PPT上的内容和观点依旧看的很清晰，对于后续的传播也非常有利。
其实直到今天，演示现场突然工具出问题，或者要很紧急做一个PPT，这样的情景依然经常出现。
不过最近也发现，秒速制作这种风格的幻灯片，现在倒是越来越容易，有时候都用不着用PPT。
比如，公司内部开一些工作会议，其实很多情况下，最重要的还是内容的讨论，不需要做过于花哨的形式，我会用「坚果云笔记」把我的开会重点或者项目方案做成思维导图，导图模式非常方便可以全局而快速地看到整个全部的思路。
比如这是之前一份关于王牌P计划的会议讨论要点。
思路定好了，直接点击坚果云笔记的【演示模式】，一键进入坚果云大纲笔记的演示模式，一键直接就转成高桥流式幻灯片，直接可以开讲，甚至还带一点缩放动画，视觉上也不会枯燥。
还有一个功能值得一说，那就是改了很多版本也没关系，它支持自动备份，随时还能找回历史版本，不用担心任何突发意外。
使用这个方法，用于内部演示和讲解，会很方便。
02：结构化 做PPT尤其是做工作总结PPT，最忌讳写成流水账。
比如这个案例，内容都是日常部门里面的零零碎碎，一笔流水账自然没有人认为你工作做得好。
这个时候需要结构化总结，与领导关心的问题直接挂钩，让领导判断你的贡献是否有价值，而不是堆积一大坨信息，让领导做思考题。
如果你是领导，你会喜欢做思考题，还是判断题？答案显而易见。
这样信息经过结构化的总结，调整的汇报结构非常好借助了领导的成本管理思维，且用领导熟悉的语言讲话，有力说明了琐碎的工作和重要的成本控制工作之间的联系，这就借助了成本管理思考框架的力量。
有了框架结构，将信息结构化处理，最大的好处是可以减轻观众的阅读负担。比如这样的一页PPT：
这一页PPT上的文字都是未经整理的信息，直接堆积到PPT上甩给领导，这是偷懒和不负责的表现，当然也很难获得领导好的评价。
很多人会说：领导一字不让删啊！其实，我们可以保持原稿一字不删，只给每一段增加一个结构化的标题。
你会发现，这样的话，这一页上文字其实变多了，但阅读的负担却降低了。在职场中，「结构化」不仅是一种技巧，更是一种好的思维习惯，让领导和同事觉得你「条理清晰」。
03：说人话 做PPT时，我们很容易陷入到「专业思维」，做完PPT觉得自己特别厉害，但在没有同样专业知识背景的听众那里，或许他完全get不到。
比如你是一位在线教育创业者，有机会用5分钟向投资人做PPT演示，其中最重要的一页就是要传递：跟竞品相比，自己的产品有什么样独特的优势？
很多人会做成什么样呢？来看一下：
做完之后，可能自己觉得好厉害，那是因为自己是这个行业的专家，背后有很多知识背景。
但对这个领域不一定很懂的投资人，存在专业屏障，无法在这么短的时间快速理解你的「AI录播」、「人工智能场景化」、「蒲公英式」……于是信息的传达就有了障碍。
所以此时应该用最通俗的大白话，直接说出谁都能听明白的一句话，最大化引发对方的兴趣，比如：
没错，这个表达的方式俗称：说人话！
当然可能会有人觉得，PPT上使用专业的名词对于传递专业和严谨的形象也非常重要，但其实两者并不冲突，来看看老罗是怎么做的。
他在演示中，先是在PPT上罗列了产品的专业名词，「我们用的是高通骁龙四核处理器balabala……」
正当大家不明觉厉的时候，他话锋一转，「如果我们定义我们是一位大众消费品的公司，虽然团队技术上需要非常专业，把这些东西理解并且用到，大家只需要的只是这一句，就行了……」
然后PPT翻页，展示了一句大白话的总结：
此时，掌声雷动，欢呼声响起。
这个方式，不但把专业和通俗兼顾，还很好地掌控到了观众的节奏，高手。
04：视觉化 PPT中视觉化的表达，我认为起码有3种作用。
能够引发听众情感共鸣，耐人寻味能够提升信息传达效率，快速理解能够吸引观众的注意力，印象深刻 尤其现在是一个「读图时代」，这几点就显得更为重要。
比如这样的一页PPT：
如果只是寡淡的一段文字，你可能都不太会有去阅读的欲望，从中去体会一些情感就更无从谈起了。
怎么去做视觉化呢？
这段文字想表达的是，信息技术高速发展的新世代下，女性通过网络等渠道和方式了解世界了解自我，那么可以找一张女性刷手机这样一个具有场景感的图片，将这个氛围烘托出来，比如这样：
感觉好些了，但是好像还不够。「了解世界」「了解自我」，这是一个持续的动态，上面单纯的一张图片，没有表现出这个持续的动作，而且对「通过多种渠道和方式」这一点的表达也还不到位。怎么进一步优化？
用一些图标来表示功能，进而指代APP：
如果在演示时讲故事，讲到这里，再配合一点小动画，引起听众的注意，效果更佳：
不过视觉化表达的应用，很多时候最难的其实也不一定是技术，而是在于信息的提炼。
比如这一页PPT，文字中存在的逻辑关系没有提炼，信息传达的效率就会降低：
其实，用几个简单的图示来呈现，一眼就懂：
而且随着软件进化，视觉化表达的武器也越来越多元。举个例子。这是我们中学时期生物课上，关于细胞结构的课件，这个手绘风格的细胞图比较抽象，要理解很多知识点，全靠学生的想象力：
而现在PPT已经支持插入3D素材，从网站下载3D素材，直接就可以插入PPT中：
有了这个功能，可以突破平面的限制，让你的PPT打破次元，呈现更丰富直观的视觉表达，让知识点的讲解和理解更轻松。
再比如，要给小朋友们讲解恐龙，这样的视觉表达，很难吸引到小朋友们的注意力：
而如果直接插入动态3D素材：
就可以直接轻松做出视觉冲击力，将小朋友们的注意力吸引到幻灯片上：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b58097c9886ef9671efa248ffc3b0d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f371d00806004d6e0dd0c4c15e577d80/" rel="bookmark">
			接口测试的测试用例该怎么写呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：字节开发测试
链接：https://www.zhihu.com/question/305629217/answer/2530044958
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
一、什么是接口 接口就是有特定输入和特定输出的一套逻辑处理单元。
在计算机领域中，我们所说的接口一般分两种，一种是内部接口，一种是外部接口。
内部接口：内部接口指的是系统内提供的方法、函数等，它是不对外开放的，仅供系统内部调用的
外部接口：外部接口是指系统对外提供的，通过某种特定的协议与外部程序进行交互的方法
二、什么是接口测试 接口测试就是使用某种工具或编写程序与系统提供的外部接口进行交互，通过接口返回的结果判断接口内部逻辑实现是否满足预期的过程。
三、为什么要掌握接口测试 1.接口测试直接测试后端服务，更容易发现影响广泛的bug
2.通过接口自动化完成接口回归测试，让工作更轻松、更高效
3.掌握接口测试思维，对测试框架搭建有很大的帮助
4.测试工程师的招聘一般都要求掌握接口测试
四、接口都有哪些类型 接口一般分为两种：
1.程序内部的接口
2.系统对外的接口
系统对外的接口：比如你要从别的网站或服务器上获取资源或信息，别人肯定不会把数据库共享给你，他只能给你提供一个他们写好的方法来获取数据，你引用他提供的接口就能使用他写好的方法，从而达到数据共享的目的。
程序内部的接口：方法与方法之间，模块与模块之间的交互，程序内部抛出的接口，比如bbs系统，有登录模块、发帖模块等等，那你要发帖就必须先登录，那么这两个模块就得有交互，它就会抛出一个接口，供内部系统进行调用。
接口的分类：
1.webservice接口
2.http api接口
webService接口是走soap协议通过http传输，请求报文和返回报文都是xml格式的，我们在测试的时候都用通过工具才能进行调用，测试。
http api接口是走http协议，通过路径来区分调用的方法，请求报文都是key-value形式的，返回报文一般都是json串，有get和post等方法，这也是最常用的两种请求方式。
json是一种通用的数据类型，所有的语言都认识它。（json的本质是字符串，他与其他语言无关，只是可以经过稍稍加工可以转换成其他语言的数据类型，比如可以转换成Python中的字典，key-value的形式，可以转换成JavaScript中的原生对象，可以转换成java中的类对象等。）
五、接口的本质是什么 接口你可以简单的理解他就是URL，工作原理就会说URL通过get或者post请求像服务器发送一些东西，然后得到一些相应的返回值，本质就是数据的传输与接收。
六、怎样做接口测试 工具有很多如：postman、jmeter、soupUI、java+httpclient、robotframework+httplibrary等。
--也可以用 接口自动化来实现，就是用代码实现，框架和UI自动化差不多，发送请求用断言来判断。
七、接口测测试点是什么 目的：测试接口的正确性和稳定性；
原理：模拟客户端向服务器发送请求报文，服务器接收请求报文后对相应的报文做处理并向客户端返回应答，客户端接收应答的过程；
重点：检查数据的交换，传递和控制管理过程，还包括处理的次数；
核心：持续集成是接口测试的核心；
优点：为高复杂性的平台带来高效的缺陷监测和质量监督能力，平台越复杂，系统越庞大，接口测试的效果越明显（提高测试效率，提升用户体验，降低研发成本）；
用例设计重点：通常情况下主要测试最外层的两类接口:数据进入系统接口（调用外部系统的参数为本系统使用）和数据流出系统接口（验证系统处理后的数据是否正常）；
PS：设计用例时还需要注意外部接口提供给使用这些接口的外部用户什么功能，外部用户真正需要什么功能；
1、基本功能测试：
由于是针对基本业务功能进行测试，所以这部分是两种测试重合度最高的一块，开发同学通常所指的也主要是这部分的内容。
2、边界分析测试：
在基本功能测试的基础上考虑输入输出的边界条件，这部分内容也会有重复的部分（比如业务规则的边界）。但是，前端的输入输出很多时候都是提供固守的值让用户选择（如下拉框），在这种情况下测试的边界范围就非常有限，但接口测试就不存在这方面的限制，相对来说接口可以覆盖的范围更广，同样的，接口出现问题的概率也更高。
3、性能测试：
这个比较容易区分，虽然都需要做性能测试，但关注点确大不相同。App端性能主要关注与手机相关的特性，如手机cpu、内存、流量、fps等。而接口性能主要关注接口响应时间、并发、服务端资源的使用情况等。两种测试时的策略和方法都有很大区别，所以这部分内容是需要分开单独进行测试的，理论上来说这也是不同的部分。
综论：
1、接口测试和app测试的活动有部分重复的内容，主要集中在业务功能测试方面。除此之外，针对各自特性的测试都不一样，需要分别进行有针对性的测试，才能确保整个产品的质量。
2、接口测试可以关注于服务器逻辑验证，而UI测试可以关注于页面展示逻辑及界面前端与服务器集成验证
3、接口测试持续集成：
对接口测试而言，持续集成自动化是核心内容，通过持自动化的手段我们才能做到低成本高收益。目前我们已经实现了接口自动化，主要应用于回归阶段，后续还需要加强自动化的程度，包括但不限于下面的内容：
a) 流程方面：在回归阶段加强接口异常场景的覆盖度，并逐步向系统测试，冒烟测试阶段延伸，最终达到全流程自动化。
b) 结果展示：更加丰富的结果展示、趋势分析，质量统计和分析等
c) 问题定位：报错信息、日志更精准，方便问题复现与定位。
d) 结果校验：加强自动化校验能力，如数据库信息校验。
e) 代码覆盖率：不断尝试由目前的黑盒向白盒下探，提高代码覆盖率。
f) 性能需求：完善性能测试体系，通过自动化的手段监控接口性能指标是否正常。
4、接口测试质量评估标准：
a) 业务功能覆盖是否完整
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f371d00806004d6e0dd0c4c15e577d80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fc2f7188e338bc09cbb86110c507cf9/" rel="bookmark">
			【python】将多个txt文件合并为一个txt文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【python】将多个txt文件合并为一个txt文件 思路代码展示代码可直接运行可直接运行文件 思路 代码目的
在做词云图的时候需要用到多个txt文件中的内容，但是一个个复制粘贴到一个文件中十分麻烦，因此需要借助python将多个txt内容合并到同一个txt文件中
代码模块
有两个模块，一个用于读取相关文件夹下的文件名，另一个读取并存储。
代码展示 def read_files(): """该函数用于读取对应文件夹下各txt文件的名字""" path = input("目标文件夹：") + '/' #建议直接将文件夹的绝对路径写入即可 files = os.listdir(path) file_names=[] for file in files: if file.split('.')[-1] =='txt':#如果不是txt文件就跳过 file_names.append(file) return path,file_names def mixed_file( path,files): """该函数用于合并刚才读取的各文件 输入：文件路径，read_files()返回的文件名 输出：一个合并后的文件""" content = '' #读取文件 for file_name in files: with open( path+file_name , 'r' ,encoding='utf-8') as file: content = content + file.read() file.close() #保存文件 with open(path + '合并后的文件.txt', 'a',encoding='utf-8') as file: file.write(content) content = '' file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fc2f7188e338bc09cbb86110c507cf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d2cff11d7e61d4ce947c80e3a7214e3/" rel="bookmark">
			ftp 报错 553 Could not create file
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ftp 报错 553 Could not create file ftp 报错 553 Could not create file 问题说明：
在使用 ftp put 命令进行文件上传时报错 553 Could not create file
解决方案：
1.查看当前配置文件中 local_root 配置信息
示例：
vim /etc/vsftpd/vsftpd.conf local_root=/ftpFile 2.查看 local_root 目录下是否存在当前登陆 ftp 时使用用户的目录
示例：
[root@master ~]# cd /ftpFile/ [root@master ftpFile]# ll 总用量 0 drwxr-xr-x 2 admin admin 17 8月 4 23:49 ftpFile /ftpFile 文件夹中的 ftpFile 文件用户为 admin 即登陆 ftp 时使用的用户名 3.注意使用 put 命令时使用相对路径，不要使用绝对路径，或者使用 cd 到 ftp 文件目录下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d2cff11d7e61d4ce947c80e3a7214e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c5f543c9fdd41f12d563f44111049f1/" rel="bookmark">
			IDEA安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IDEA的安装 我觉得激活破解太麻烦了，其实可以淘宝一个正版激活码
下载地址：
https://www.jetbrains.com/idea/download/#section=windows打开exe，开始安装，步骤如下：
然后这一步需要登录账户，没有的注册一个
注册完成后 ，会呈现出已登录样子
点击start trial，然后下一步continue
新建项目，点击新建项目，这里简单创建了一个javase项目
name是项目名称，location可以自定义存放项目位置，
点击create创建就可以了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a47de8b4e86ddc0093a2cf51e4d2eb86/" rel="bookmark">
			IPV6地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
IPV6地址的特点
IPV6地址
IPV6地址接口标识的生成方法：
IPV6地址分类
IPV6的配置
IPV6地址配置
静态路由配置
RIPNG配置
OSPFV3配置
MP-BGP配置
IPV4和IPV6的过渡
IANA --- 因特网地址分配组织 IPV6地址的特点 1，“无限”的地址空间：因为IPV6地址由128位二进制构成，所以其地址数量是非常多的。 2，层次化的地址结构：所谓层次化的地址结构其实就是指地址分配更加合理，更利于汇总。主要由IANA组织来完成。 3，即插即用：SLAAC --- 无状态地址自动配置 --- 只需要拥有网关设备，则将自动下发一个IPV6地址。 4，简化了报文的头部： TOS --- 服务类型 --- Traffic Class --- 流量分类 TTL --- 生存时间 --- HOP Limit --- 跳数限制 Protocol --- 协议 --- next header --- 下一个头部 名称变化，描述的更加准确 Flow Label --- 流标签 --- 可以用来区分和标记不同的流量，便于做Qos，目前并没有启用。 删除的部分（简化的部分） --- 头部长度 --- 主要是因为下面的选项字段也被删除了，导致IPV6包头从一个可变长头部变为定长头部，支持硬件处理。 --- 校验和 ---- 因为各个层次的协议封装时，都会存在校验和来确保数据的完整性，但其实只需要校验一次就可以，所以，完全可以删除掉。 5，保证端到端网络的完整性：在IPV4网络当中，因为NAT技术的存在，导致端到端网络完整性遭到破坏，而IPV6中因为地址足够多，不需要运行NAT技术，所以，可以保证其完整性。 6，安全性增强：在IPV6中，为了保证数据传输的安全性，专门设计了一套IPSEC（因特网协议安全协议）体系，当然，目前IPV4也可以使用IPSEC来保证安全。 7，增强Qos特性：主要体现在增加了流标签字段，更方便完成Qos，但是，目前尚未启用。 IPV6地址 --- 128位二进制 ---- 冒分16进制 2001：0123：0000：4560：0000：0000：0000：001A --- 首选格式 A = a 压缩格式的方式： 1，每一段前导0可以省略，如果一段全是0，则至少保留1个，拖尾的0不能省略； 2001：123：0：4560：0：0：0：1A 2，如果存在一个或多个整段全0的情况，可以使用“：：”来表示，但整个IPV6地址的 压缩格式中最多只能有1个"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a47de8b4e86ddc0093a2cf51e4d2eb86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e29f5e813e6ff38dbea4fc739514fc4/" rel="bookmark">
			【java】输入输出流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入输出应用编程 Input/Output：指跨越出了JVM 的边界，与外界数据的源头或者目标数据源进行数据交换
Java程序会从各种地方输入数据，比如文件，磁盘，网络，其它程序中Java会采用不同的方式输出执行结果，比如屏幕、文件、磁盘、网络等
输入/输出是针对JVM 而言 输入输出种的流模型 在Java程序中，对于数据的输入输出操作以流Stream方式进行，JavaSE提供各种各样的类用于使用相同的方法获取不同类型的数据，程序中通过标准的方法输入或者输出数据
流是处理输入/输出的一个洁净的方法，它不需要代码理解键盘和网络的不同。Java中流的实现是基于java.io包定义的类层次结构的
流概念 java.io包通过数据流、序列化和文件系统为用户提供一种完成I/O操作的输入/输出流
数据流是指所有的数据通信通道
流是字节或字符数据的数据源或目的，用以隐藏数据传输细节，可以从流读取数据或将数据写到流
Java程序不能直接操纵I/O设备，而是在程序和设备之间加入了一个中间介质，这就是流。IO输入输出通常指数据在内部存储器和外部存储器或其它周边设备之间的输入输出
流是数据传输的抽象表达，与具体设备无关。程序一旦建立了流，就可以不用理会起点或终点是何种设备
建立流实际上就是建立数据传输通道，将起点和终点连接起来
Java程序通过流来完成输入/输出，它是生产或消费信息的抽象
流通过Java的输入/输出系统与物理设备链接。尽管与它们链接的物理设备不尽相同，但是所有流的行为具有同样的方式
相同的输入/输出类和方法适用于所有类型的外部设备。这意味着一个输入流能够抽象多种不同类
型的输入， 从磁盘文件，从键盘或从网络套接字获取输入，一个输出流可以输出到控制台，磁盘文件或相连的网络。流是处理输入/输出的一个洁净的方法，它不需要代码理解键盘和网络的不同。
流的分类 从Java不同版本上来说，流可以分为BIO、NIO和AIO三大类。Java 中的 BIO、NIO和 AIO 理解为是 Java语言对操作系统的各种 IO 模型的封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知
识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。
BIO即同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。NIO即同步非阻塞，一个线程不断的轮询每个输入输出的状态改变，如果有状态发生了改变，则进行下一步的操作。AIO即异步非阻塞I/O模型，无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。 同步/异步关注的是消息通信机制。
同步Synchronous是指发起一个调用后，调用方必须等待此调用返回结果后才能继续执行。异步Asynchronous是指发起一个调用后，调用方可继续执行后续操作，被调用者执行结束主动给调用方返回结果。 阻塞/非阻塞关注的是程序在等待调用结果时的状态，区别在于第一步发起 IO 请求后是否会被阻塞。
阻塞是指调用结果返回前，当前线程会被挂起，调用线程只有在得到结果之后才返回。非阻塞是指在调用结果返回前，不影响当前线程执行其他操作，也就是不会阻塞当前线程。
BIO是一种同步阻塞的通信模式，是一个比较传统的通信方式，模式简单、使用方便，但并发处理能力低，通信耗时，依赖网速。 NIO(Non-Bock) IO 是一种同步非阻塞的通信模式，针对网络传输效能优化的新功能。
AIO(Asynchronous IO)是一种异步非阻塞的通信模式。
同步阻塞的工作模式是先来到厨房，开始烧水，并在水壶旁等待直到水开了为止同步非阻塞的工作模式是指来到厨房，开始烧水，这次不在水壶旁等着，回到客厅看电视，每隔几分钟去检查水是否烧开了异步非阻塞的工作模式是指来到厨房，开始烧水，回到客厅看电视，直到听到水烧开后水壶的提示音。 同步vs异步：指的是被调用方以何种方式返回调用结果？（我们如何知道水壶中的水烧开了，是主动发现还是水壶被动提醒）
阻塞vs非阻塞：指的是调用方在调用后的状态是否是阻塞？（我们把水壶烧水开关打开后，我们是否在水壶旁等待水烧开）
适用场景 BIO适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解NIO适用于连接数目比较多且连接比较短的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持AIO方式适用于连接数目多且连接比较长的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。按流向分为输入流和输出流，可以从输入流读取数据但不能写，要从输入流读取数据，则必须有一个与这个流相关的字符源按传输单位分为字节流和字符流 Java具备平台无关性，这里的字节是指8位，字符是16位字节流从InputStream/OutputStream派生出来，以字节为基本处理单位，一般用于操作二进制数据，字节次序是有意义的字符流从Reader/Writer派生出来的，以16位的Unicode码表示字符为基本处理单位，一般用于操作字符数据使用桥接流可以实现两个流之间的转换 按功能还可以分为节点流和过滤流 节点流：负责数据源和程序之间建立连接，结点流对特定的地方读写过滤流：用于给节点增加功能，过滤流使用结点流进行输入/输出并添加附加功能
过滤流的构造方式是以其他流位参数构造（这样的设计模式称为装饰模式）。Java的IO流使用装饰器模式，将IO流分成底层节点流和上层处理流。其中节点流用于和底层的物理存储节点直接关联。过滤流是连接在已存在的流之上，通过对数据的处理为程序提供更为强大的读写功能。 注意：I/O流是一类很宝贵的资源，使用完后必须调用close()方法关闭流并释放资源。在关闭流时只用关闭最外层的流
字符流就是字节流读取文字字节数据后，不直接操作而是先查指定的编码表以获取对应的文字。简单的说：字符流 = 字节流 + 编码表
字符流的两个顶层父类：Reader和Writer字节流的两个顶层父类：InputStream和OutputStream输入输出靠reader和writer, inputstream和outputstream四个类和子类支持读入的内容有对象，字符，图像和声音等 Java输入输入靠reader、writer、InputStream、OutputStream四个类和子类支持。JDK的I/O包中使用Decorator模式，并运用此模式，实现一个新的输出流类
扩展类的功能 扩展一个类功能的最简单方式就是继承
继承 public interface IShape { void draw(); } 需要追加功能的类实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e29f5e813e6ff38dbea4fc739514fc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4db7da841e71380e640935eecf30a78b/" rel="bookmark">
			js 数组方法的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组方法 slice,splice,splite 三者这件的区别与用法
slice()方法：
1、slice() 方法可以从已有数组中返回选定元素。
2、slice()方法可提取字符串的某个部分，并以新的字符串返回被提取的的部分。
3、注意：clice() 方法不会改变原始数组
4、用法：
array.slice(start,end);
start：可选。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。
end：可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。
splice() 方法：
1、splice()方法用于插入、删除或替换数组的元素。
2、注意：这种方法会改变原始数组
3、语法：
array.splice(index,howmany,item1,...,itemx)
index 必需。规定从何处添加/删除元素。该参数是开始插入和（或）删除的数组元素的下标，必须是数字。
howmany 必需。规定应该删除多少元素。必须是数字，但可以是 “0”。如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。
item1, …, itemX 可选。要添加到数组的新元素
split()方法：
1、split() 方法用于把一个字符串分割成字符串数组。
2、提示： 如果把空字符串 ("") 用作 separator，那么 stringObject 中的每个字符之间都会被分割。
3、注意： split() 方法不改变原始字符串。
4、用法：
string.split(separator,limit)
separator可选。字符串或正则表达式，从该参数指定的地方分割 string Object。
limit 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d16bf37d82b6e1b62ccb3cd76eb39aeb/" rel="bookmark">
			Comparison method violates its general contract 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 今天下午正在摸鱼，这时候突然客户在群里反馈，说今天数据没有了，催我赶紧去看，于是我连上客户服务器，打开今天的项目日志，看到了下面的错误
Comparison method violates its general contract
问题原因 花了几分钟解决，记录一下
先看下之前的代码，功能就是获取指定目录下最近修改的文件名称，里面用到了Arrays.sort 排序
/** 读取特定目录下最新的文件名称 * @param filePath 文件路径 * @return String */ public static String getLatestFile(String filePath ) { String latestFile = ""; // 获取最新改动的文件名 try { File path = new File(filePath); if (path.exists()) { // 列出该目录下所有文件和文件夹 File[] files = path.listFiles(); if (null == files || files.length &lt;= 0) { return latestFile; } // 按照文件最后修改日期倒序排序 Arrays.sort(files, (file1, file2) -&gt; { Long result = file2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d16bf37d82b6e1b62ccb3cd76eb39aeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6639f00a4135cd0eb9ec4158d1d4f316/" rel="bookmark">
			查找字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.indexOf
定义： indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。
如果没有找到匹配的字符串则返回 -1。
注意： indexOf() 方法区分大小写。
var s = "baidu.com.cn"; var b = s.indexOf("."); //返回值为5,为第一个.的下标 var e = s.indexOf(".", b + 1); //将第一个下标后一个位置为开始位置查找第二个.的下标位置，返回9 第一个参数为一个子字符串，指定要查找的目标。第二个参数为一个整数，指定查找的起始位置，取值范围是 0~length-1。 2. lastIndexOf
定义：lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，如果指定第二个参数 start，则在一个字符串中的指定位置从后向前搜索。
注意： 该方法将从后向前检索字符串，但返回是从起始位置 (0) 开始计算子字符串最后出现的位置。 看它是否含有字符串。
开始检索的位置在字符串的 start 处或字符串的结尾（没有指定 start 时）。
如果没有找到匹配字符串则返回 -1 。
注意：lastIndexOf() 方法是区分大小写的！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/217/">«</a>
	<span class="pagination__item pagination__item--current">218/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/219/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>