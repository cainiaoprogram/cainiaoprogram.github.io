<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9edcaa8993f54cf217bda4c422caceb6/" rel="bookmark">
			使用宝塔面板搭建WordPress网站（图文教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用宝塔面板搭建WordPress网站 图片来自宝塔官网
现在搭建一个自己的网站已经不是一件难事了，有出色的WordPress程序，有价格实惠的云服务器，有像七牛云这种对草根站长友好的云存储服务，还有像宝塔面板这类易操作的面板，让不会linux命令的小白也可以快速建立一个网站。话是这么说，但是对于纯小白来讲，还是有一定的难度，但是只要你有足够的耐心和细心，就可以拥有自己的网站。
一、准备材料 一台1H1G1M以上配置并且系统为centos7的云服务器（不是虚拟主机）
云服务器可以选择阿里云或者腾讯云一个已经备案的域名（没有已备案域名暂时可以用公网IP代替）你的耐心 二、安装宝塔面板 先在宝塔面板官网上注册宝塔面板账号，后面登录需要用到。
购买云服务器之后，使用密码或SSH连接到你的云服务器，一定要保证是个干净的服务器，不然可能会出现无法预知的问题，引起不必要的麻烦。参考官网安装方法，安装linux免费版即可，根据网络状况的不同，等待时间也不同，一般情况下，差不多5分钟左右，安装成功后会在屏幕输出你的面板访问地址，用户名和密码。面板默认使用8888端口，如果访问不了，要在云服务器提供商的安全组中放开相应的端口。
安装成功后会提示访问网址、用户名和密码：
三、安装网站环境 成功进入宝塔面板后，会提示安装LNMP运行环境
LNMP即Nginx、MySQL和PHP，这些环境是运行WordPress程序必不可少的。推荐使用PHP7以上版本，其他保持默认即可，推荐使用编译安装，耐心等待，可以在左上角查看进度。
四、必要的安全设置 为了提高安全性，建议修改面板的别名、默认端口、安全入口、面板用户和密码。
不建议修改并发线程，不建议添加域名和授权IP，以免出现访问不了面板的情况，其他的保持默认即可。
建立WordPress网站 宝塔面板有一键部署WordPress网站插件，但是版本较老，后期进入WordPress后台得升级。手动部署需要到WordPress官网下载最新的安装程序，还可以保证安全性。下面介绍的也会是手动建立站点，其实并没有很复杂。
添加站点 在宝塔界面找到网站，点击添加站点，会出现以下界面：
域名根据实际情况填写，如果是国内空间，则域名必须备案，国外空间则不需要，一般写一个顶级域名和一个www二级域名即可，比如www.pandacui.com,pandacui.com，搭建阶段可以也用云服务器的公网IP代替。
FTP可以选择不创建，后面可以用宝塔面板的文件管理。
数据库选择MySQL，会提示输入用户名名称和密码，自动建立与用户名同名的数据库
PHP版本选择你安装的PHP版本，我安装的是PHP7.2，建议安装版本不低于7。
点击提交，会提示站点创建成功，并显示数据库用户名和密码，这里不用刻意去记录，可以在宝塔的数据库管理界面再次查看。
站点创建完成之后，可以通过公网IP或你绑定的域名测试一下，在浏览器输入公网IP或你绑定的域名即可，如果成功，会显示以下页面：
到这里，网站的基本架构已经搭建完成了，下面要做的就是安装WordPress网站程序。
下载WordPress安装程序 到WordPress中文官网下载最新的中文安装包，一定要选择tar.gz格式
下载完成后需要将安装程序上传到刚刚建立的网站目录下，进入宝塔面板首页，找到你刚刚创建的网站目录
进入此目录会看到如下文件列表，这是宝塔创建站点时的默认主页和404页面，删除即可，.htaccess和.user.ini如果你不懂，就不要动。
上传WordPress安装程序 在你的网站目录下，点击上传，将你刚刚下载的WordPress程序上传，上传成功后是这个样子的：
解压WordPress压缩包 这一步可以使用命令行操作或使用宝塔面板操作，如果使用面板解压，那么解压后的目录权限默认是www用户的。如果使用命令解压，不要忘记把目录所属组更改为www用户，并把权限设置为755。
鼠标移上WordPress压缩包，右侧会出现工具栏，选择解压，在弹出的界面再次选择解压即可，解压完成后文件列表会是这样：
进入wordpress目录，全选所有文件，点击复制或剪切，然后返回到站点目录，选择粘贴所有，你的站点目录一定要是这个样子的：
之后就可以删除wordpress目录和wordpress压缩包，现在已经没用了。到此就完成了WordPress安装的准备工作。
运行WordPress安装程序 浏览器输入域名或公网IP，可以看到WordPress的安装程序页面，出现这个页面说明你之前做的都没问题。
在开始之前，我们需要找到之前创建的MySQL数据库用户名和密码，在宝塔面板-数据库中可以看到
回到WordPress安装页面，点击现在就开始，填入你的数据库名称、用户名和密码，其他项目保持默认即可。
如果信息都正确的话，点击提交会出现以下页面：
输入站点标题、用户名、密码和电子邮件，同时勾选“建议搜索引擎不索引本站点”，因为在网站建设初期不需要搜索引擎收录，后期可以改，点击“安装WordPress”，安装完成之后会出现以下界面：
你可以选择登录或者在浏览器输入你的域名或公网IP，出现以下类似的网页就说明站点搭建成功了。
设置伪静态和固定链接 这一步尤其重要，正确设置伪静态和固定链接可以保证网站被正常访问，顺序一定不要搞错了，先在宝塔设置伪静态规则，再设置WordPress固定链接，否则可能导致除首页之外的任何页面都访问不了。
设置伪静态规则 打开宝塔面板，找到你的站点，点击设置，找到伪静态，选择WordPress
设置固定链接 进入WordPress后台管理界面，找到设置-固定链接，我们使用自定义结构，用文章ID作为链接地址。
结束语 搭建一个网站的步骤还是挺多的，好在有这么多好用的工具来帮助我们建站，除了安装宝塔面板，没有输入一行命令就这么快速地搭建一个网站，真是太赞了。在此过程中要有足够的耐心，看起来容易，但是做起来，还是挺费时间的。对于后期的网站优化可以参考我的其他文章。
原文地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/302ac1806c9b9ac6eb27db9accc662a3/" rel="bookmark">
			快速幂之Java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主针对2021校招字节跳动的第五轮笔试第二，学习了快速幂算法
文章目录 一、简介二、性能优化三、对性能进行压榨 一、简介 求A^B的最后三位数表示的整数。
说明：A^B的含义是“A的B次方”
当一个数的幂很大时，如果直接使用Math.pow()运算，会导致溢出，所以最简单的方法就是，累乘B次，每次对结果进行求模运算，我们以2的1000000000次方为例，Java代码如下：
public class Test { private static int mod = 1000; public static void main(String[] args) { int x = 2; int n = 1000000000; long startTime = System.currentTimeMillis(); int result = fastPower(x,n); System.out.println("结果是："+result); long endTime = System.currentTimeMillis(); System.out.println("运行时间为："+(endTime-startTime)+" ms. "); } private static int fastPower(int x, int n) { int result = 1; for (int i = 1; i &lt;= n; i++) { result %= mod; result *= x; } return result%mod; } } 结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/302ac1806c9b9ac6eb27db9accc662a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481ed8fb2f47eb91747c496022b351f6/" rel="bookmark">
			如何在Windows 8或10中安装或启用Hyper-V虚拟化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 8 and 10 includes Hyper-V as a virtualization platform, but since not everybody will use this feature, it’s not enabled by default. Here’s how to enable it on your Windows 8 or Windows 10 PC.
Windows 8和10包括Hyper-V作为虚拟化平台，但是由于并非所有人都会使用此功能，因此默认情况下未启用该功能。 这是在Windows 8或Windows 10 PC上启用它的方法。 混乱 (Confusion) Hyper-V only allows you to create a new virtual machine on 64-bit versions of Windows 10 or 8, but the client tools are available on both versions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/481ed8fb2f47eb91747c496022b351f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3500f4a2281bea64de9aab61471d63a/" rel="bookmark">
			median函数的使用方法_如何在Google表格中使用MEDIAN函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		median函数的使用方法
Should you need to find the middle value in a set of data in your spreadsheet without having to do it manually, Google Sheets has a function that does it instantly for you. Here’s how to use the MEDIAN function.
如果您需要在电子表格中的一组数据中找到中间值而不必手动进行操作，则Google表格可以立即为您提供此功能。 这是使用MEDIAN函数的方法。 Fire up Google Sheets and open a spreadsheet with datasets for which you want to find the median.
启动Google表格，然后打开一个包含要查找中位数的数据集的电子表格。 Click on an empty cell and type =MEDIAN(&lt;value1&gt;, [&lt;value2&gt;, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3500f4a2281bea64de9aab61471d63a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/691850fcadcad4b7e0d6209ab8dc9bae/" rel="bookmark">
			论文阅读笔记-DEEP COMPRESSION
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次阅读的论文是斯坦福大学韩松的博士论文《DEEP COMPRESSION: COMPRESSING DEEP NEURAL
NETWORKS WITH PRUNING, TRAINED QUANTIZATION
AND HUFFMAN CODING》
一、Abstract Why? 近年来，神经网络在人们实际生活中取得了巨大成功，但是，神经网络这类算法存在着一个鲜明的特点，它是一种计算密集型和存储密集型的算法，这就导致神经网络很难在嵌入式设备上部署，本文就旨在解决这一个限制。
How？ 作者在文章中提出了一种叫做“Deep Compression"的方法，主要分为三个步骤：pruning, trained quantization and Huffman coding。剪枝（pruning)就是将权重中一些相对不重要的参数剪去（设为0），量化（trained quantization)则是用低比特的数据表示高比特的数据，Huffman coding则是一种常见的数据无损的压缩算法。
Result 通过Deep Compression， 在ImageNet数据集上, 作者将AlexNet模型的存储所需空间缩小了35倍（240MB-&gt;6.9MB)，并且没有精度损失，同样，将VGG-16模型所占用的存储空间缩小了49倍（552MB-&gt;11.3MB)，同样也没有精度上的损失。
二、INTRODUCTION 近年来,深度神经网络已经成为了计算机视觉领域十分有力的一个工具，但是，这些强大的深度神经网络都有相当数量的参数，对存储空间和存储带宽提出了很高的要求。
1、在手机等移动工具上，一般都存在这一个问题，例如在苹果的APP STORE上，大于100MB的文件必须在连接wifi的情况下才能下载，这就妨碍了深度神经网络在手机等设备上的部署。 2、手机等移动设备电池续航能力有限，而且散热也差，而深度神经网络在运行时需要频繁的访存以及乘累加运算，这些操作的功耗都是非常高的，因此这一点也限制了深度神经网络的部署。 文章针对这种情况，主要实现以下目标：
1、解决存储空间占用过大的问题
2、解决功耗过高的问题
于是，作者提出了deep compression的方法，将模型的大小压缩至原来的数十倍，使得模型参数能完全放在SRAM内，免去了对DRAM的访问，大大降低了功耗，最终实现了很高的加速比和功率效率。
三、Methods Network Pruning 如何剪枝 剪枝是一种能有效压缩模型大小和防止过拟合的方法，所谓剪枝，就是剪去一些不重要的连接：设置某个阈值，低于每个阈值的权重都被永久置为0，不再参与今后的计算。每次剪枝之后，我们还可以对模型进行retrain，微调权重，这样不断迭代，直至结果满意为止。
在本文中，我们通过剪枝将AlexNet模型的大小缩减了9倍，将VGG-16的模型大小缩减了13倍。
剪枝后参数的存储 剪枝之后，模型中绝大多数参数都会被置为0，因此，剪枝之后的权重矩阵是一个稀疏矩阵，针对稀疏矩阵的存储方式有很多，例如CSR、CSC等，本文作者采用CSR来存储稀疏化后的权重。
如上图所示，AA数组存储的是稀疏矩阵中非零元素的值，JA数组存储A中每一行第一个非零元素在AA中的索引，JA中最后一个元素为非零元素个数+1，而IC数组存储的是AA中对应元素的列号，若设A中非零元素有a个，A矩阵有n行，那么采用CSR存储只需要2a+n+1个数据即可。
那么如果有乘法A*v，则操作如下：
for(i=1;i&lt;=n;i++){
y0=0;
for(k=JA[i];k&lt;JA[i+1];k++)
y0+=AA[k]*v[IC[k]];
y[i]=y0;
}
TRAINED QUANTIZATION AND WEIGHT SHARING 量化即用低比特的权重来代替高比特的权重，权重共享则是指让多个权重共享一个值。本文在剪枝之后，即对模型进行量化和权值共享，并且重新训练微调模型。
如图，是我们进行量化和权值共享的示意图，在上图中，输入神经元为4个，权重矩阵为4x4，我们将这16个权重分为4组，每组的颜色相同，并且它们共享同一个值，这些共享的值则没有必要使用32bit来表示，因为他们可能的取值很少，因此可以用低bit来表示这些共享的全值。下方的矩阵则是梯度矩阵，按照权重矩阵的分组对梯度矩阵分组，相同组内的梯度值相加，乘以学习率后对相应的共享权值进行更新。
在本文中，作者对剪枝后的AlexNet模型进行了量化，将卷积层权重量化为8bit，全连接层权重量化为5bit。
为了计算这种方法的压缩率，作者假定权重有k个组，组的索引则需要 l o g 2 ( k ) log_2(k) log2​(k)bit,整个权重矩阵共有n个权重，每个权重用b比特表示，那么压缩率为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/691850fcadcad4b7e0d6209ab8dc9bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a15525da1111eee9c990bcab260c4a04/" rel="bookmark">
			基于服务器部署的OCR在线识别应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 前段时间，接了一个OCR在线识别的外包程序，在实现过程中遇到了很多麻烦，也走过很多弯路。在网络查阅了许多相关资料后，发现关于这一块知识详细而完整的文章不多，故写下此文，既是对前段时间的总结，也为今后有同样困扰的朋友提供一些帮助。
几经比较，本文最终决定使用百度的开源OCR框架作为基础，实现服务器部署以及端口调用。PaddleOCR是百度开源的OCR识别框架，采用Paddlehub可快速一键部署。PaddleOCR 的 github 地址：https://github.com/PaddlePaddle/PaddleOCR
二、准备 1、自备服务器，如果没有服务器使用ubuntu作为模拟服务器也行，本文使用的是阿里云服务器
2、在服务器内安装Python环境，建议直接安装Anaconda，可以省去很多时间
3、安装百度的PaddlePaddle，这是个所有百度框架的老大哥，只要你想使用百度的框架产品，这个是必备的
4、安装百度的PaddleHub，这是PaddlePaddle的头号小老弟，安装这个后才能一键部署PaddleOCR
5、安装第三方库shapely、pyclipper，这是运行PaddleOCR的依赖库，没有他们PaddleOCR运行不了
6、安装百度的PaddleOCR框架，有基于移动端的识别框架，也有基于服务端的识别框架，本文使用服务端框架
三、详细步骤 1、配置Python环境 对于初始的服务器来说，其内置的Python版本一般为2.7，已经不再适用当前环境所需的要求，所以需要重新安装新版本的Python环境。为了方便，我直接使用了Anaconda，它把Python和一些常用的库有集合起来了，不需要后续再一个个下载安装。下面进行第一步，下载Anaconda安装包。建议使用使用清华的镜像下载，速度会快很多，清华园镜像地址
将镜像下载进自己的服务器内，我新建了一个Downloads目录专门来存放下载下来的文件
把Anaconda的安装包下载下列后，只需要执行一个bash命令即可： bash Anaconda3-2020.02-Linux-x86_64.sh。然后就是根据提示，要么回车要么输入 yes 。由于笔者写文的时候，环境已经配置好了，没有保留Anaconda的安装截图，如果中途没有报错，一般就是安装成功了。要验证也非常简单，只需要输入：anaconda -V 和 conda -V ，有显示相对应的版本号就算成功了，如下图。
因为有用到图像处理，所以还需要安装一个openCV，安装步骤也非常简单，一句命令即可
pip install opencv-python 2、安装PaddlePaddle PaddlePaddle是百度旗下的一个人工智能开发框架，功能类似于tensorflow和PyTorch等等。对于PaddlePaddle的安装和使用，百度有给出非常简单而清楚的使用教程，教程链接：https://www.paddlepaddle.org.cn/install/quick#show_info ，这里给出了各个系统各个环境对应的安装教程，笔者也是根据这份教程进行简易安装的。
需要确认您的 Ubuntu 14.04/16.04/18.04 是 64 位操作系统*确认您需要安装 PaddlePaddle 的 Python 是您预期的位置，因为您计算机可能有多个 Python which python3 （根据您的环境您可能需要替换本说明中所有命令行中的 python3 为 python ，或者替换为具体的 Python 路径）
同时检查 Python 3 的版本，确认是 3.5.1+/3.6/3.7： python3 --version 确认 Python 有对应的 pip，检查 Python 对应的 pip 的版本，确认是 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a15525da1111eee9c990bcab260c4a04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1fd84660c46c9fae1d66318e9d308da/" rel="bookmark">
			2020年清华伯克利（TBSI）预推免面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流程与形式 TBSI在7月的时候办了线上夏令营，入营率很高，周围报名了的基本上都入了。今年夏令营期间不发offer，发一个welcome letter，这个welcome letter可以在预推免时免掉材料审查直接进入复试。welcome letter发的相对比较多，但是也并不是每个人都有。不过对于像我这样报名博士项目的，基本上只要和意向老师在夏令营期间多交流一下就能拿到。
一般老师会要求接下来的暑假去TBSI实习，我因为大三暑假还有一门实训必修课没法去。如果去了的话，有welcome letter再加上复试时候老师关照一下应该就比较稳妥。
TBSI的博士项目会在预推免复试说明中明确说明30分钟以上的全英文面试。而硕士项目则只会说20分钟以上的综合面试，但实际上**也是全英文的！！！**我有个朋友被坑的很惨。
博士和硕士项目都大致流程都可归纳如下：
开始前给一定时间阅读一篇英文文章。博士10分钟时间，文章长度大约1页半word文档，硕士5分钟时间，文章长度大约1页word文档。正式面试开始，自我介绍环节。TBSI不要求是否使用PPT也不要求时间，但由于硕士面试时间较紧张，如果超过5分钟可能会被直接打断。面试官针对之前阅读的英文文章进行提问。面试官针对个人介绍进行专业知识提问或者询问具体项目内容。面试官进行非专业知识提问，比如发展规划，为什么选择TBSI，平时是否有兴趣爱好，反向提问等。 其中从自我介绍开始，所有问题和回答都会是英文的。网上有一些其他面经提到如果自己没有听懂问题的话面试官会告知中文意思和如果自己实在用英文答不出来的话面试官会允许中文作答。然而遗憾的是，在两点至少在我的博士面试和我朋友的硕士面试中都完全不成立。我问过两次Can I answer it in Chinese? 答复都是，No, you must answer in English. 我也试过一次Could you tell me how to say xxx in Chinese? 答复是Sorry, I don’t kone how to say it in Chinese. 总之，别抱任何侥幸。
接下来对我和我朋友两场面试具体问题如下。我们两个申请的方向都是Computer System.
我的博士项目面试 阅读读的是一篇通过硬件实现神经网络的文章，着重介绍了现在通过硬件方式实现神经网络的局限性并且分析了原因。
自我介绍后，具体问题如下：
讲一讲刚刚的那篇文章在讲什么？你在自我介绍中提到了LLVM，它的GCC的区别在哪里？介绍一下LLVM IR.你知道JIT吗，它的AOT相比优缺点是什么？尽可能多地讲一讲你关于垃圾回收的了解。我们这里计算机系统有很多子方向，你最想做什么？你有什么问题想问我们的吗？你为什么选择TBSI？TBSI有非常优秀的学术资源，当你拿到博士学位之后你的规划是什么？ 朋友的硕士项目面试 阅读读的是一篇通过硬件实现branch prediction的文章，提出了一种新的设计方法，着重介绍了新的方法相比于传统方法的改进。
自我介绍后，具体问题如下：
讲一讲你现在对于branch prediction的认识（这里有个专业问题但这个朋友他根本没有听懂）你知道图灵机吗？你对未来的规划是什么？你平时的兴趣爱好是什么？ 其他 TBSI对于英语水平欠缺的人是相当不友好的，我已经确定自己凉掉了，我朋友估计也凉掉了。如果想要报名TBSI最好还是至少提前两个月开始准备自己的口语，不然真的很容易问题都听不懂。
如果可能的话，尽可能在复试前和老师多交流，比如老师之所以问我LLVM，是因为他做的三个方向中只有编译器这个方向在我的自我介绍中有体现。（可惜我并没有提前意识到这点，那几个专业问题都答的很烂）。
标准答案 待补充。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43024e6489592f85a8fb523da8b14bca/" rel="bookmark">
			outlook 收件箱分组_如何在Mac版Outlook 2016中禁用统一收件箱（和分组文件夹）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		outlook 收件箱分组
By default, the folder list in Outlook 2016 for Mac is grouped into similar folders, which means that folders that are common to all your accounts, such as Inbox, Drafts, Sent Items, and Deleted Items, are grouped together.
默认情况下，Outlook 2016 for Mac中的文件夹列表被分组为相似的文件夹，这意味着所有帐户(例如“收件箱”，“草稿”，“已发送邮件”和“已删除邮件”)都公用的文件夹被分组在一起。 The Inbox folder at the top of the folder list combines messages received in the inboxes for all your accounts, and then each separate inbox is listed below that.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43024e6489592f85a8fb523da8b14bca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0753d54cebffd94f2fa808d9040e4bc6/" rel="bookmark">
			黑苹果检测_苹果技术进行情绪检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黑苹果检测
介绍 (Introduction) Before we get our hands dirty, let’s prepare ourselves for what’s coming next.
在弄脏手之前，让我们为接下来发生的事情做好准备。 第一件事 (First things first) Artificial Intelligence can be defined as an area of computer science that has an emphasis on the creation of intelligent machines that can work and react like humans.
人工智能可以定义为计算机科学领域，其重点是创建可以像人类一样工作和做出React的智能机器 。 Machine Learning can be defined as a subset of AI, in which machines can learn on their own without being explicitly programmed: they can think and perform actions based on their past experiences.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0753d54cebffd94f2fa808d9040e4bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec4b128d5f72f6f044c122743c44786f/" rel="bookmark">
			PHP使用PHPMailer发送邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、PHPMailer概述 1.1PHPMailer是什么 PHPMailer 是一个非常强大的 php发送邮件类,可以设定发送邮件地址、回复地址、邮件主题、html网页,上传附件,并且使用起来非常方便。
1.2PHPMailer优点 1、在邮件中包含多个 TO、CC、BCC 和 REPLY-TO。2、平台应用广泛，支持的 SMTP 服务器包括 Sendmail、qmail、Postfix、Gmail、Imail、Exchange 等等。3、支持嵌入图像，附件，HTML 邮件。4、可靠的强大的调试功能。5、支持 SMTP 认证。6、自定义邮件头。7、支持 8bit、base64、binary 和 quoted-printable 编码。 1.3下载 PHPMailer 从 github 上下载: https://github.com/PHPMailer/PHPMailer/
二、准备工作 2.1PHP环境准备 确保PHP环境开启openssl，如果未开启，检查ext文件夹下是否有php_openssl.dll、php_sockets.dll两个dll,php.ini文件中把前面的；去掉
2.2开启QQ邮箱的 SMTP服务（其他主流邮箱也一样支持） 邮箱名称下面点击设置
点击账户
拉到下面，开启POP3/SMTP服务、IMAP/SMTP服务以及生成授权码
2.3下载PHPMailer源码 Github下载地址：https://github.com/PHPMailer/PHPMailer
需要用到的两个类分别是PHPMailer、SMTP，将这两个文件拷到项目中
三、完整代码 /*发送邮件方法 *@param $to：接收者 $title：标题 $content：邮件内容 *@return bool true:发送成功 false:发送失败 */ function sendMail($to,$title,$content) { // 这个PHPMailer 就是之前从 Github上下载下来的那个项目 require 'src/PHPMailer.php'; $mail = new PHPMailer; // 是否启用smtp的debug进行调试 开发环境建议开启 生产环境注释掉即可 默认关闭debug调试模式， // 可选择的值有 1 、 2 、 3 // $mail-&gt;SMTPDebug = 2; //使用smtp鉴权方式发送邮件 $mail-&gt;isSMTP(); //smtp需要鉴权 这个必须是true $mail-&gt;SMTPAuth = true; // qq 邮箱的 smtp服务器地址，这里当然也可以写其他的 smtp服务器地址 $mail-&gt;Host = 'smtp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec4b128d5f72f6f044c122743c44786f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d4167384e39b30d430308667dbc8927/" rel="bookmark">
			Python Pillow(PIL)库的用法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python Pillow(PIL)库的用法介绍 Pillow库是一个Python的第三方库。
在Python2中，PIL(Python Imaging Library)是一个非常好用的图像处理库，但PIL不支持Python3，所以有人(Alex Clark和Contributors)提供了Pillow，可以在Python3中使用。
官方文档路径：https://pillow.readthedocs.io/en/latest/
一、安装Pillow
pip install pillow Pillow库安装成功后，导包时要用PIL来导入，而不能用pillow或Pillow。
import PIL from PIL import Image 在Pillow库中，除了有二十多个模块，还支持非常多的插件。其中最常用的是Image模块中同名的Image类，其他很多模块都是在Image模块的基础上对图像做进一步的特殊处理，Image模块中会导入部分来使用。本文介绍Image模块的常用方法。
二、打开本地图片
原图：
# coding=utf-8 from PIL import Image image = Image.open("yazi.jpg") image.show() 运行结果：
open(fp, mode='r'): 打开一张图片，是Image模块中的函数。如果图片与当前代码在同一目录下，可以只写图片的文件名，其他情况需要拼接图片的路径。mode默认为'r'，也必须为'r'。
show(): 调用图片显示软件打开图片。打开后程序会阻塞，需要手动关闭。
三、创建一张新图片
from PIL import Image image = Image.new('RGB', (160, 90), (0, 0, 255)) image.show() 运行结果：
new(mode, size, color=0): 创建一张图片(画布)，用于绘图，是Image模块中的函数。有3个参数。
mode, 图片的模式，如“RGB”(red,green,blue三原色的缩写，真彩图像)、“L”(灰度，黑白图像)等。
size, 图片的尺寸。是一个长度为2的元组(width, height)，表示的是像素大小。
color, 图片的颜色，默认值为0表示黑色。可以传入长度为3的元组表示颜色，也可以传入颜色的十六进制，在版本1.1.4后，还可以直接传入颜色的英文单词，如上面代码中的(0, 0, 255)可以换成‘#0000FF’或‘blue’，都是表示蓝色。
四、Image模块的常用属性
from PIL import Image image = Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d4167384e39b30d430308667dbc8927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f049fbc2b8f4c3f6fdf2011d554e5f13/" rel="bookmark">
			【ros学习】5.gazebo闪退修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、打开gazebo黑屏、闪退各种error 解决办法： 1.下载模型包文件到本地
cd ~/.gazebo/ mkdir -p models cd ~/.gazebo/models/ wget http://file.ncnynl.com/ros/gazebo_models.txt 2.下载模型包，共539个
wget -i gazebo_models.txt ls model.tar.g* | xargs -n1 tar xzvf 解压模型包
3.装完模型包发现还是闪退
然后百度了一波
按这个博主的方法，问题解决——Gazebo闪退及无法运行.
先是关闭了硬件加速，还是闪退
echo " export SVGA_VGPU10=0" &gt;&gt; ~/.bashrc source ~/.bashrc 又关闭了3d加速就可以打开使用了
二、启动某些软件包 报[gazebo.launch] is neither a launch file in package [e100_sim] nor is [e100_sim] a launch file name
The traceback for the exception was written to the log file
这是因为setup.bash文件没有进一步说明包的来源，解决方法是：
source catkin_ws/devel/setup.bash
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5ad560b0f79381c0c5ead92574d6edc/" rel="bookmark">
			解决jupyter notebook打不开无反应 浏览器未启动的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决jupyter notebook打不开无反应 浏览器未启动的问题
来源: 互联网 作者: vegecken
收藏一下。已注明转载地址。方便以后查看
问题：
这几天要看几个ipython格式的文件,但是jupyter notebook打开之后一直卡在命令行的界面那里(如图),然后就不动了,浏览器也没有预期地自动弹出来.
解决方法：
如果你的命令行显示的结果和我的一样,那你只需要把如图的地址,复制粘贴到浏览器的地址栏,就能打开jupyter notebook.
成功：
补充知识：打开jupyter notebook时浏览器不能自动弹出，网页不显示问题解决
问题：
在windows下打开jupyter notebook时，卡在黑框，浏览器界面加载不出来
解决办法一：
将http://localhost:8888/tree复制到浏览器打开
此种方法每次需要重新输入，或复制链接，略显麻烦，请移步到方法二
解决办法二：
1、win+r 然后输入cmd,回车打开命令窗口
2、在命令窗口中输入jupyter notebook --generate-config，回车，有的电脑会提示输入y/N，输入y，回车
找到jupyter notebook --generate-config的路径
3、找到jupyter notebook --generate-config文件，用记事本或者Notepad++打开
4、Ctrl+F查找c.NotebookApp.password =
5、在这句后面加上
import webbrowser
webbrowser.register(‘chrome’, None, webbrowser.GenericBrowser(u’C:\Program Files(x86)\Google\Chrome\Application\chrome.exe’))
c.NotebookApp.browser = ‘chrome’
注意这里。复制过去最好检查一下标点是否正确。我从原文复制过去的时候单引号是中文的，就一直失败，现在已修改过来了。不过大家还是检查一下。
建议使用谷歌浏览器，路径要填写正确，注意双斜杠
6、保存，退出
7、重新打开jupyter notebook就可以看到可以打开了
转载地址: http://www.cppcns.com/jiaoben/python/306949.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c4a545492f65be9aac532d069a896b/" rel="bookmark">
			os模块-获取文件大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取文件大小 os.path.getsize(file) 返回文件大小(非占用空间)，结果为整型，单位：字节(B)
1KB = 1024B
1MB = 1024KB
故，getsize的结果除以1024可得单位为KB的文件大小
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3174d8a99e6b6135532b988e09ede972/" rel="bookmark">
			VS2019&#43;QT5.2&#43;MySql安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Qt + VS+mysql报错：driver not loaded解决方法】 VS2019安装教程QTMySQL 把所有的坑都在这里说一遍吧
1、VS2019就正常安装吧
2、QT我安装的是qt-opensource-windows-x86-5.14.2
3、QT安装的时候要点QT安装的时候除了选MSVC 2017_64-bit还有Source
Source很重要！！关系到后面安数据库，选择了Source才有src这个文件夹
4、mysql密码要记好！
5、driver not loaded报错看最后！！
VS2019安装教程 转载：vs2019安装和使用教程（详细）
QT 转载：VS2019+QT
QT安装的时候除了选MSVC 2017_64-bit还有Source
旧版本的就是Qt GUI Application
新版本改了叫Qt Widget Application
MySQL 安装转载：MySQL
添加数据库：Visual Studio 2019 环境下加入 Qt 的 SQL 库引用
安装Navicat for MySQL
然后在main.cpp里修改代码
#include "Mysql.h" #include &lt;QtSql/QSqlDatabase&gt; #include &lt;QtSql/QSqlTableModel&gt; #include &lt;QtSql/QSqlError&gt; #include &lt;QMessageBox&gt; #include "qdebug.h" int main(int argc, char *argv[]) { QApplication a(argc, argv); /* demo01 w; w.show(); return a.exec(); */ qDebug() &lt;&lt; QSqlDatabase::drivers(); QSqlDatabase db = QSqlDatabase::addDatabase("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3174d8a99e6b6135532b988e09ede972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54860833d76285d1ce3f7c00073911c9/" rel="bookmark">
			Android EditText 编辑框 获取焦点的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EditText 获取焦点的方法为：setOnFocusChangeListener
下面写一个EditText 编辑框获取焦点之后改变背景颜色
主要代码如下
public class MainActivity extends AppCompatActivity { private EditText editText; private LinearLayout linearLayout; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText = findViewById(R.id.edt); linearLayout = findViewById(R.id.main); editText.setOnFocusChangeListener(new View.OnFocusChangeListener() { @Override public void onFocusChange(View v, boolean hasFocus) { if (hasFocus) { linearLayout.setBackgroundColor(Color.RED); } else { linearLayout.setBackgroundColor(Color.WHITE); } } }); } } xml 中代码就写了一个编辑框如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/main" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;EditText android:id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54860833d76285d1ce3f7c00073911c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847ae502245f74420d782942e3ea402f/" rel="bookmark">
			面试官：换人！他连 TCP 这几个参数都不懂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
TCP 性能的提升不仅考察 TCP 的理论知识，还考察了对于操作系统提供的内核参数的理解与应用。
TCP 协议是由操作系统实现，所以操作系统提供了不少调节 TCP 的参数。
Linux TCP 参数 如何正确有效的使用这些参数，来提高 TCP 性能是一个不那么简单事情。我们需要针对 TCP 每个阶段的问题来对症下药，而不是病急乱投医。
接下来，将以三个角度来阐述提升 TCP 的策略，分别是：
TCP 三次握手的性能提升；
TCP 四次挥手的性能提升；
TCP 数据传输的性能提升；
本节提纲 正文 01 TCP 三次握手的性能提升 TCP 是面向连接的、可靠的、双向传输的传输层通信协议，所以在传输数据之前需要经过三次握手才能建立连接。
三次握手与数据传输 那么，三次握手的过程在一个 HTTP 请求的平均时间占比 10% 以上，在网络状态不佳、高并发或者遭遇 SYN 攻击等场景中，如果不能有效正确的调节三次握手中的参数，就会对性能产生很多的影响。
如何正确有效的使用这些参数，来提高 TCP 三次握手的性能，这就需要理解「三次握手的状态变迁」，这样当出现问题时，先用 netstat 命令查看是哪个握手阶段出现了问题，再来对症下药，而不是病急乱投医。
TCP 三次握手的状态变迁 客户端和服务端都可以针对三次握手优化性能。主动发起连接的客户端优化相对简单些，而服务端需要监听端口，属于被动连接方，其间保持许多的中间状态，优化方法相对复杂一些。
所以，客户端（主动发起连接方）和服务端（被动连接方）优化的方式是不同的，接下来分别针对客户端和服务端优化。
客户端优化 三次握手建立连接的首要目的是「同步序列号」。
只有同步了序列号才有可靠传输，TCP 许多特性都依赖于序列号实现，比如流量控制、丢包重传等，这也是三次握手中的报文称为 SYN 的原因，SYN 的全称就叫 Synchronize Sequence Numbers（同步序列号）。
TCP 头部 SYN_SENT 状态的优化
客户端作为主动发起连接方，首先它将发送 SYN 包，于是客户端的连接就会处于 SYN_SENT 状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847ae502245f74420d782942e3ea402f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce1b64838120909502e7f1d83c910f96/" rel="bookmark">
			系统安装无法创建新的系统分区的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装Windows7时，想必有很多人都安碰到这样的情况吧!在安装界面里选择安装时，却出现“安装程序无法创建新的系统分区，也无法定位现有系统分区”
安装程序无法创建新的系统分区，也无法定位现有分区 网上提供的另外解决方法大全： 方法一：有朋友经过测试，找到一种非常简单的办法，这个方法首先需要将C盘重新格式化。格式化完之后，不做任何操作，把U盘拔出来，然后再插上。点一下刷新，这时候，选中C盘，点下一步，应该成功了。当然此方法如果奏效那就再好不过了。
方法二：如果你安装过程能看到“驱动器高级选项”。那么点击安装界面右下角的“驱动器高级选项”，选中上面的c盘，删除，然后重新建立系统分区。这时候的操作就比较简单，这时候重新建立分区会有多个100M，300M左右的分区。那是做引导或者恢复什么的，可以自行搜索学习。也可以忽略不理。
方法三：以上两种方法仍然不能解决问题，请用pe启动盘进行安装。这时候方法就多了去了，小工具也多了去了，原理基本是PE上去后把安装文件复制到硬盘上。可以用nt6的方法，也可以用复制个别文件到c盘使用命令方法都可以实现。统统算作是硬盘安装法。能这么做前提是你得有U盘，其他可用电脑，网络等。
示例一种：
重启机器，通过U 盘启动．进入win pe系统
进入win pe系统，格式化C 盘为NTFS 。C盘最好有15 G以上的空间，在这里建议大家分30 G 甚至更多。
从你解压的安装程序的文件夹中找到boot , bootmgr 和sources这三个文件，并且复制到C盘根目录下。
在win pe系统中运行cmd ，输入“ c:\boot\bootsect.exe /nt60 c: ”（注意exe和/nt60、/nt60和c:之间有空格），然后回车，看到提示successfully 字样的语句即成功了！然后重起电脑。
方法四：以上方法都不太好使嫌麻烦的时候，还有个更麻烦的那就是PE下用diskgenius这个神器分区。麻烦事麻烦，但是能从根本上解决问题。分区的本事还是得学习学习的，但是一定要注意电脑上有重要数据的时候千万不要乱动。切记，切记。伤了数据最TMD的心痛了。win8e小编干过这么一次惊悚的事儿。以后不敢瞎弄分区了。
方法五：也就是今天我自己用的解决办法，分别测试uefi和非uefi两种方式安装。uefi时候提示是mbr不是gpt不能安装。非uefi时候就提示安装程序无法创建新的系统分区这个问题。总之不行。那么索性shift+F10把SSD清洗了，重新分区。120的SSD干嘛非得分两个盘，既然用Win10就漂漂亮亮的UEFI+64位Win10+SSD做C盘程序也给这里装。剩下的硬盘做数据存储多潇洒。既然这个打算就需要以下操作：
shift+F10打开命令框，
输入”Diskpart”(不用输入引号，下同)，并按回车，进入操作界面
输入：”list disk”，查看磁盘信息。
输入：”select disk 0”，选择disk 0为当前操作的磁盘，注意看你的0是不是要干掉的，别搞错了。
输入：”Clean”，清空当前磁盘分区
输入：”convert gpt”，转换为GPT分区。
操作完成，关闭此命令提示符窗口
这时候刷新看到的是未分配的硬盘，直接操作新建确定即可。我是把SSD只当作C盘了，你要想分几个调整数字创建即可。到此分配完毕点击要装系统的盘符，下一步。一切顺利。
转载于:https://my.oschina.net/kyeeliu/blog/757676
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c74668f43b753e3bbd810d6c921d38f9/" rel="bookmark">
			线程中的生产者消费者问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个线程同步问题，生产者消费者共享一个资源，并且生产者消费者之间相互依赖，互为条件：
对于生产者，没有生产产品之前，需通知消费者等待，而生产产品之后需要马上通知消费者消费；
对于消费者，在消费之后，需要通知生产者已经结束消费，需要生产新的产品提供消费；
在生产者消费者问题中，仅有synchronized是不够的；
synchronized可阻止并发更新同一个共享资源，实现了同步；
synchronized不能用来实现不同线程之间的消息传递（通信）；
解决方式一：管程法（并发协作模型）
生产者：负责生产数据模块 消费者：负责处理数据模块 缓冲区：生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据 实例：
package com.keji.oop; //解决生产者消费者之间的问题，利用缓冲区解决--管程法 public class PC { public static void main(String[] args) { Buffer container = new Buffer(); new Producer(container).start(); new Consumer(container).start(); } } //生产者 class Producer extends Thread{ Buffer container; public Producer(Buffer container) { this.container = container; } //生产 @Override public void run() { for (int i = 0; i &lt; 100; i++) { container.push(new Product(i)); System.out.println("生产了"+i+"个产品"); } } } //消费者 class Consumer extends Thread{ Buffer container; public Consumer(Buffer container) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c74668f43b753e3bbd810d6c921d38f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e33deb6087aa1613eda4af86bb30487/" rel="bookmark">
			L1distance和L2distance区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		L1distance和L2distance区别：
L1distance即曼哈顿，即城市距离，各维度距离之和
L2distance即欧式距离，两点间直线距离
参考cs231n课程的一幅图，图上方形和圆形上的点都有相同距离。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e67497ed8e0dc733b815f4238e9e5509/" rel="bookmark">
			蚂蚁金服（Java研发岗），26岁小伙斩获三面，收获Offer定级P6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进阿里一直都是身为程序员的我，最初的梦想，经过去年面试蚂蚁金服失败的挫折后，今年再次鼓起勇气投简历，经过一位前辈的内推省了很多流程，经过多重面试后最终通过。当时收到offer的时候整个人开心的要跳起来，因为最初的目标实现了。当然能进阿里也是感谢去年面试官的一些建议，告诉了我一些需要补进的知识盲区，然后经过一年的学习以及总结最终达成心愿，具体面试过程下面详细分析。
蚂蚁金服4面面试大概过程： 一面总体上还是围绕Java基础、JVM、并发编程、数据结构等展开。一面结束后很快安排了二面，相对一面，二面和三面从项目入手多数问的是数据库，缓存，分布式架构等问题且更深入，问题比较刨根问底，更加注重对一些技术细节的理解和把握。比如数据库操作，面试官会详细的问你数据库插入和删除一条数据的过程在底层是如何执行的，项目里配置了读写分离，也会比较深入的就实现方法和底层逻辑展开讨论。HR面很愉快，问了一些薪资和职业规划上的问题！
主要分享下技术四面的问题 一面与二面
技术三面
总结 技术方面，结合自己的体会，总结下面几点：
基础知识必须要扎实，包括语言基础，计算机基础，算法和基本的Linux运维等设计模式，造轮子的能力，各种缓存和数据库应用，缓存，中间件技术，高并发和高可用的分布式系统设计软性指标，包括快速学习，良好的沟通能力，以及对相关行业的了解 同时对这次的面试经历和平时的学习复习做了一个总结，现在分享出来也是希望能帮助到和我有一样梦想的朋友。希望将来我们能成为同事。
这份资料非常适合开发2年及以上的朋友学习参考！这份资料包括Java基础，JVM，数据结构，Spring，操作系统，分布式，Linux，网络等等
由于篇幅原因，这份4万字的阿里面经及详细笔记答案就不做全部展示了，这些题我已经整理成pdf文档免费分享给那些有需要的朋友，同时整理也花费了蛮多时间，有需要的朋友可以点击这里即可获取免费领取方式！
同时还有Java面试必备的知识体系文档和一份Java中高级面试高频考点文档免费分享给大家，这2份文档和面经掌握其中的大部分知识足以面对很多互联网公司包括阿里蚂蚁金服等面试了
Java面试核心知识点笔记
其中囊括了JVM、锁、并发、Java反射、Spring原理、微服务、Zookeeper、数据库、数据结构等大量知识点。
Java中高级面试高频考点整理
更多Java进阶知识笔记文档分享，这些对于面试还是学习来说都是一份不错的学习资料
有需要的朋友可以帮忙点击这里即可获取免费领取方式！
最后还分享Java进阶学习及面试必备的视频教学
获取方式：关注我后，点击这里即可获取免费领取方式！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0f4649aacf4320b26352afc07e887de/" rel="bookmark">
			SpringBoot中使用属性文件（yml、properties）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Spring Boot中使用属性文件，可以采用其默认的application.properties和application.yml配置文件，也可以使用自定义的配置文件。
属性文件依赖 如果使用的是yml文件进行配置，则会自动对配置字段进行自动提示。如果使用的使用的是properties文件进行配置，则需要引入以下依赖才能进行自动提示（即使不引入这个依赖，配置字段也会生效，只是不方便快捷书写配置）：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;!--下面一行设置为true说明这个依赖是可选的，且不进行依赖传递，不设置则默认为false，为必须依赖 --&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 使用属性配置 我们可以通过@Value注解，使用${…}这样的占位符读取配置在属性文件的内容。假如我们自定义了一个字段"my.value=123"在properties文件中，那么获取属性的示范代码如下： public class ValueTest { @Value("${my.value}") private String valueTest; public void test01(){ System.out.println(valueTest); } } 执行代码的话控制台将会输出：123
2. 还可以使用@ConfigurationProperties注解进行获取，代码示范如下：
@ConfigurationProperties("my") public class ValueTest { private String value; public void test01(){ System.out.println(value); } 同样可以拿到值，注意这里“my”和属性名组合后要完全匹配配置文件里的全限定名。使用这个注解可以方便获取大量的属性值，唯一注意的就是要使用对应的属性名称。
载入自定义的配置文件 1.使用@PropertySource注解来载入非默认的properties配置文件
@propertySource(value={"classpath:haha.properties"}, ignoreResourceNotFound=true) public class ValueTest { @Value("${my.value}") private String valueTest; public void test01(){ System.out.println(valueTest); } } 第一种方法是不支持yml配置文件载入的，但是如果我们要载入非自定义的yml配置文件的话，需要在application.yml配置文件中这样写： spring: profiles: active: dev, test 如上配置，我们可以载入名为application-dev.yml和application-test.yml的配置文件，注意文件名要加上“application-”的前缀。通过这个注解我们可以方便切换配置文件从而达到切换测试、开发、生产等环境的目的。也可以将多个环境配置写在同一个配置文件中，如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0f4649aacf4320b26352afc07e887de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/809a83716bd3ea1eecb5aae053cfd893/" rel="bookmark">
			jenkins网页打不开问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.环境：macOs10.15.6
2.问题描述：重启电脑后浏览器输入http://localhost:8080提示网页错误
3.解决方法：terminal进入Jenkins目录下（jenkins.war所在路径）,执行命令
java -jar jenkins.war --httpPort=8080
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c339e527f929676e43c53811f2ad0ad8/" rel="bookmark">
			SpringBoot Bean的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般情况下，我们只是关心如何正确地将Bean装配到容器中，并不关心Ioc容器是如何装配和销毁Bean的过程。但是恰恰有时候，我们需要自定义初始化或销毁Bean的过程，以满足一些“特殊的”需求。比如，数据源在关闭的时候调用其close方法，这是项目开发过程中很常见的需求。
Bean的生命周期大致可以分为4个部分：
1. Bean的定义
2. Bean的初始化
3. Bean的生存期
4. Bean的销毁
Bean的定义 资源定位的过程。
如使用@ComponentScan定义的扫描路径去找@Component的类（PS：现在启动类@SpringBootApplication会直接扫描本包内的@Compnent注释的类）
解析资源并保存定义。
Spring IoC容器装载Bean定义。
（PS：此时还是没有实例化Bean）
Bean的生命周期 完成了以上三步，还没有实例化的生成，更没有完成依赖注入。默认情况下，Spring会继续完成Bean的实例化和依赖注入。
但是在某些情况下，我们希望Spring 在装载Bean之后，不采取自动实例化和依赖注入，而是在我们要取出这个Bean的时候再执行初始化等操作。
ComponentScan中还有一个配置项lazyInit，默认值为false，就是说不会延迟初始化。但我们将其配置为true时，将会执行延迟初始化。但在spring boot中，这个配置项目即使配置了也可能无效，具体看下面的方法。
资源定位 解析Bean的定义 装载Bean的定义 实例化 依赖注入DI 解析Bean定义后会将定义保存在BeanDefinition实例中。依赖注入例如@Autowired注入的资源。默认情况下，在Spring IoC容器初始化的时候，Bean将会自动实例化和注入。如果不想跟随Ioc容器初始化，在Spring web开发中可以通过以下步骤进行延迟加载（缺少一个都不能实现）： 首先在对应实体类上面加上@Lazy注解。然后在@Autowired注解引用该Bean的地方同时再加上@Lazy注解。使用@Bean注入的地方（如果有）也要加上@Lazy。
接口BeanNameAware Spring容器在初始化和销毁Bean之前，会自动回调BeanNameAware中的setName方法。
接口BeanFactoryAware Spring容器会继getName方法后自动回调BeanFactoryAware中的setBeanFactory方法。
接口ApplicationContextAware 需要容器实现ApplicationContext接口才会被调用。ApplicationContext是BeanFactory的子接口，BeanFactory在初始化容器时，并未实例化Bean，直到第一次访问某个Bean时才实例化目标Bean。而ApplicationContext在初始化上下文时就实例化所有单实例的Bean。基于注解配置的应用上下文的IoC容器实现了AnnotationConfigApplicationContext，它就是ApplicationContext接口的一个实现类，默认实例化DefaultListableBeanFactory工厂。
示范Bean：
@Component @Data public class Animal implements BeanNameAware, BeanFactoryAware, ApplicationContextAware { private String name; private Integer age; private String cry; @Override public void setBeanName(String name) { System.out.println("Animal被赋予了姓名：" + name); } @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c339e527f929676e43c53811f2ad0ad8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2ddcb5b65fbb799a7715c9cd20b7c5/" rel="bookmark">
			js判断是否是时间类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js里怎么判断一个对象是否是日期类型，即Date，用typeof返回的是object
例如：
var object="123"; var object2=new Date(); console.log(object instanceof Date);//false console.log(object2 instanceof Date);//true 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e60b6fd67f2839de47657f7e836b7a13/" rel="bookmark">
			圣杯布局和双飞翼布局的理解与思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。
圣杯布局来源于文章In Search of the Holy Grail，而双飞翼布局来源于淘宝UED。虽然两者的实现方法略有差异，不过都遵循了以下要点：
两侧宽度固定，中间宽度自适应中间部分在DOM结构上优先，以便先行渲染允许三列中的任意一列成为最高列只需要使用一个额外的&lt;div&gt;标签 下面我将依次介绍圣杯布局和双飞翼布局的实现方法，并在最后根据个人思考对原有方法做出一些修改，给出其它一些可行的方案。
圣杯布局 1. DOM结构 &lt;div id="header"&gt;&lt;/div&gt; &lt;div id="container"&gt; &lt;div id="center" class="column"&gt;&lt;/div&gt; &lt;div id="left" class="column"&gt;&lt;/div&gt; &lt;div id="right" class="column"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt;&lt;/div&gt; 首先定义出整个布局的DOM结构，主体部分是由container包裹的center,left,right三列，其中center定义在最前面。
2. CSS代码 假设左侧的固定宽度为200px，右侧的固定宽度为150px，则首先在container上设置：
#container { padding-left: 200px; padding-right: 150px; } 为左右两列预留出相应的空间，得到如下示意图：
创建布局框架
随后分别为三列设置宽度与浮动，同时对footer设置清除浮动：
#container .column { float: left; } #center { width: 100%; } #left { width: 200px; } #right { width: 150px; } #footer { clear: both; } 得到如下效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e60b6fd67f2839de47657f7e836b7a13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b75c2f798f2f9f0000a0d9a0f39543/" rel="bookmark">
			整理了 15 个好用的 API 接口管理神器，你们随便挑...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方 蓝字 加关注吧
赞！Windows 10 20H2陆续推送：微软换上新UI界面
一二线城市知名 IT 互联网公司名单！
常用Maven插件终极大全，速度收藏！
一图看懂鸿蒙2.0：终于上手机、128KB内存就能跑！
RabbitMQ 的核心概念，看了必懂！
如今，API 已在软件、Web 和移动应用程序开发领域无处不在，从企业内部到面向公众的应用以及与合作伙伴进行系统集成。通过使用 API，开发人员可以创建满足各种客户需求的应用程序。而软件架构也在随着应用程序开发方法的改变而改变。
由于 API 在软件开发过程中如此关键，那么对 API 的管理就显得格外重要。通过 API 管理工具和平台能够大大简化 API 管理的难度和复杂度。下面列举了一些顶级 API 管理工具和平台，可供您参考。
1. API Umbrella
API Umbrella 是用于管理 API 和微服务的顶级开源工具之一。通过为不同的域授予不同的管理员权限，它可以使多个团队使用同一个 Umbrella。该平台还提供速率限制，API 密钥，缓存，实时分析和 Web 管理界面等功能。
2. Gravitee.io
Gravitee.io 是一个用于管理 API 的开源平台，这个工具是灵活的并且是轻量级的。它具有开箱即用的功能，例如速率限制，IP 过滤，跨域资源共享，即插即用选项，具有基于 OAuth2 和 JSON Web 令牌策略的开发者门户，负载平衡等。
但是，此 API 管理工具的主要功能是能够生成细粒度的报告以理解 API 的数据是如何使用的。
3. APIman.io
APIman.io 是由 Red Hat 引入的一个顶级 API 管理平台，这个平台在 GitHub 中可以找到，为后端开发人员提供了很多便利。这包括：
快速运行 具有可分离策略引擎的基于策略的治理 异步功能 增强的结算和分析选项 REST API 可用性的管理 限速，还有其他
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76b75c2f798f2f9f0000a0d9a0f39543/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea8704599146497f97da892a24f2864/" rel="bookmark">
			Python自动化之pytest常用插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、失败重跑 pytest-rerunfailures 安装：pip install pytest-rerunfailures
使用：pytest test_class.py --reruns 5 --reruns-delay 1 -vs (失败后重新运行5次，每次间隔1秒)
@pytest.mark.flaky(reruns = 5 ,reruns-delay = 1 )　指定某个用例
#!/usr/bin/python # -*- coding: UTF-8 -*- """ @author:chenshifeng @file:test_calc2.py @time:2020/09/16 """ import pytest @pytest.mark.parametrize('a,b,result', [ (1, 1, 3), (2, 2, 4), (100, 100, 200), (0.1, 0.1, 0.2), (-1, -1, -2) ], ids=['int', 'int', 'bignum', 'float', 'fushu']) # 参数化 def test_add(a, b, result): # cal = Calculator() assert result == a + b 命令行执行：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eea8704599146497f97da892a24f2864/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/302f6a946fc936cf588498587b765825/" rel="bookmark">
			已解决 : org.apache.catalina.connector.ClientAbortException: java.io.IOException: 你的主机中的软件中止了一个已建立的连接。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置CROS跨域请求 进行EXCEL模板下载的时候出现了这个错误 前台报错为: 后台报错为:org.apache.catalina.connector.ClientAbortException: java.io.IOException: 你的主机中的软件中止了一个已建立的连接。
具体原因是因为设置过CROS跨域请求信息之后,设置浏览器下载弹出框的时候把请求头信息清除掉了, response.reset();把这段代码注释掉就搞定了
具体代码如下
/** * 设置让浏览器弹出下载对话框的Header. * 兼容各个浏览器下载 */ private static &lt;T extends Object&gt; void setDownloadableHeader(HttpServletResponse response, ExcelConfig&lt;T&gt; manager, String businessErrMsg) { try { String busiSuccess = "true"; if (StringUtil.isEmpty(businessErrMsg)) { response.setCharacterEncoding("GB2312"); String userAgent = manager.getUserAgent(); String fileName = manager.getFileName() + ".xls"; if (manager.getExcelVersion() == ExcelVersion.EXECL_VERSION_2007) fileName += "x"; if (userAgent.toLowerCase().indexOf("firefox") &gt; 0) { fileName = new String(fileName.getBytes("UTF-8"), "ISO8859-1"); } else if (userAgent.toUpperCase().indexOf("MSIE") &gt; 0) { fileName = URLEncoder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/302f6a946fc936cf588498587b765825/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e1a9a6428bf1f5c0a57ac9b3cbe1100/" rel="bookmark">
			NVDEC_VideoDecoder_API_ProgGuide
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 从 NVIDIA® Fermi™ 一代开始，英伟达GPU包含一个视频解码器引擎（本文中简称NVDEC），它提供全硬件加速解码视频的能力。NVDEC能解码许多码流格式： H.264, HEVC (H.265), VP8, VP9, MPEG-1, MPEG-2, MPEG-4 and VC-1. NVDEC运行完全独立于计算/图像引擎。
英伟达提供编程NVDEC的软件API和库。这套软件API，以下称为NVDECODE API，它使开发者能访问NVDEC的解码特性，并且能让NVDEC与GPU上的其它引擎交互。
NVDEC解码压缩的视频流，然后复制解码后的YUV帧到显存，因此CUDA可以后续处理位于显存中的YUV帧。对于大多数流行的输出视频格式，NVDECODE API 也提供一些常用的CUDA优化的后处理，比如缩放、裁剪、宽高比转换、反交错和色彩空间转换。
解码后的视频帧可以传递给显示器播放，直接传给NVENC进行高性能视频转码，用于GPU加速的推理，通过CUDA或者基于CPU后续处理。
NVDECODE API 支持的解码格式如下：
‣ MPEG-1,
‣ MPEG-2,
‣ MPEG4,
‣ VC-1,
‣ H.264 (AVCHD) (8 bit),
‣ H.265 (HEVC) (8bit, 10 bit and 12 bit),
‣ VP8,
‣ VP9(8bit, 10 bit and 12 bit),
‣ Hybrid (CUDA + CPU) JPEG
视频解码能力 下表展示每种GPU架构支持的解码格式和视频解码能力。
[1] 只支持 GP104, Turing 和 GA100
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e1a9a6428bf1f5c0a57ac9b3cbe1100/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c1cf47e7c2a4a687f7bc98ec7334b04/" rel="bookmark">
			pymysql的使用-从数据库获取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、pymysql从数据库获取数据
1.导入pymysql包
import pymysql 2.创建数据库连接
connect = pymysql.connect(host=host,port=port,user=dbuser,password=pwd,database=db) 注意：参数host、port、user、password、database需根据实际情况修改，port为整型，其他为字符型
3.创建游标对象
cursor = connect.cursor() 4.执行查询语句
cursor.execute("select * from table") 注意：查询语句中table指数据库中具体的数据表名
5.获取查询结果
cursor.fetchall() # 全量查询结果 cursor.fetchone() # 单条查询结果 6.关闭游标
cursor.close() 7.关闭与数据库的链接
connect.close() 二、封装类
class MysqlReader(object): def __init__(self): self.connect = pymysql.connect(host=host,port=port,user=dbuser,password=pwd,database=db) def getData(self): cursor = self.connect.cursor() cursor.execute("select * from table") q = cursor.fetchall() cursor.close() self.connect.close() return q 将代码进行封装方便后续调用。
# 类调用 MR = MysqlReader() q = MR.getData() getData返回结果为元组，后续可通过以下方式转换成DataFrame
q = [list(i) for i in q] df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c1cf47e7c2a4a687f7bc98ec7334b04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ba385f50eedc7169b7a192419b13f64/" rel="bookmark">
			学习matlab画图 地理图  线条  散点  气泡 密度图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 加标记 text([lat lon],'balabala')
2 图范围 geolimits([lat1 lat2],[lon1 lon2])
3 具体图
3.1 线条图 geoplot 如有两点 A(lat1 lon1) B（lat2 lon2）
geoplot([lat1 lat2 ]，[lon1 lon2],'g-') %g- 和plot一样 或者画出图以后再调整
3.2 散点图 geoscatter
geoscatter（lat,lon,A,C,'^'） A为每个标记的面积（以平方磅为单位） C为颜色 ^ （三角形）散点图形 3.2 气泡图 geobubble 两种方法表示
text %加载向量 eg：readtable('xxxx.xlsx') 1. geobubble(text,lat,lon,'SizeVariable','part3','ColorVariable','part4') 第一个变量填text，之后写text里面对应部分
2. geobubble(text.lat,text.lon,text.part2) 用text加 ‘ . ’ 表示对应部分 ，对于两边注释
gb.SizeLegendTitle = 'Max Height'; gb.ColorLegendTitle = 'Cause' 4 密度图 geodensityplot
和上面类似，geodensitypltot(lat,lon,'FaceColor','interp') 其中facecolor 可以调节图形颜色，如果不加那图像只是以一种颜色的深浅度来显示，加上更好看。
2020/9/16 写的第一篇，没有用markdown写，马上打个比赛，以此记忆一些知识，一点点来吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6227b2263e115038f33b0cd9a6fe7b9/" rel="bookmark">
			google  firefor  历史版本下载谷歌火狐浏览器版本下载大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/liuxueyi521/article/details/107292629
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/676ec12cbfceb125493131d567d980f6/" rel="bookmark">
			Python读取中文Excel问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python读取中文Excel问题解决 为什么读取中文Excel会出错两个难题试验结果 为什么读取中文Excel会出错 在计算机中，一个字节(byte)有8个比特，即可以表达2^8次方即256个字符，一个英文字母或符号占一个字节，即ASCII码。ASCII码有意只编了128个。
但是这个表达对于其他语言是不够用的，特别是东亚文字。于是上世纪八九十年代出现了很多并行的编码表，将2个字节对应为日文、韩文、简体或繁体汉字。Windows官方使用cp936的编码表，相当于gb18030. 所以在Windows系统里，不论是文本内容，还是文件名，都是以它来解码的。
这样就造成了两种错误，一是如果以ASCII码去读，会发生错误（因为还有128种字节不被ASCII定义），这就逼的程序去指定编码表。但是依然会发生编码表错误，即错误解码，例如原来是日文的编码错解成gb18030就会出错，形成乱码。
后来又出现了UTF-8，用1-3个字节将所有的语言的字符都包括进来，1-3个字节是为了兼容ASCII，实际可以只用2个字节，而2个字节的是unicode，规定内存中使用。
这样，尽管在内存中字节是通用的unicode，但是永久存储却有多种编码，即便都是中文，也有cp936, gb2312, gbk, gb18030和utf-8几种. 我忘了cp936是对应哪种gb了，但是一个割裂的后果是微软体系只要安装时指定简体中文，都用cp936，而后来流行的网页，Linux及新兴语言，特别是Python都默认utf-8.
两个难题 如上，一个是在Windows系统中运行，如果碰上中文文件名，必须用cp936或gb18030去解码它。如果你写了一个中文的文件名，而python根据utf-8规则去把它翻译成字节，就会在底层的文件名上不匹配，因为该中文在cp936的规则下翻译成另外的字节。报错是找不到该文件。
我参照了很多网上内容，有以下三种解决方法，前两种类似，是用unicode：
u'中文.xlsx' r'中文.xlsx' '中文.xlsx'.encode('cp936') 而最后一种直接指定解码出字节。最后一种经常是失效的，而前两种在所有的库中都可以调用，应该是被python底层支持了。
第二个难题是读取文件内容时正确指定编码。如果直接用Excel编辑，或者c#之类的插件生成的一般里面的文字是cp936的，而python的各excel库偏偏喜欢默认编码为utf-8
一个非常简单粗暴的办法是在加载了相应库之后，把Excel文件对象的encoding属性强行从utf-8更改：
xlrd改文件内容编码
xlrd.Book.encoding = "gbk" 这样即使库没有提供改编码接口，也实际改了。当然xlrd还提供了接口。
如果cp936的内容强行用utf-8去解，会发生报错
UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xce in position 64: invalid continuation byte 试验结果 xlrd和openpyxl可以同时解决以上两个问题, 下面是xlrd的一段代码。
import xlrd, xlwt xlrd.Book.encoding = "cp936" exl = xlrd.open_workbook(u'上海代码.xlsx') print("首行为\n ", exl.sheets()[0].row_values(0) ) openpyxl也可以，但是它的语法过于复杂：
# a trial to see if openpyxl works import openpyxl openpyxl.Workbook.encoding="cp936" book = openpyxl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/676ec12cbfceb125493131d567d980f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911e119a11f83df95bd641aa2124e11b/" rel="bookmark">
			PowerBI x Python 之关联分析（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
据说，全球零售业巨头沃尔玛在对消费者购物行为分析时发现，男性顾客在购买婴儿尿片时，常常会顺便搭配几瓶啤酒来犒劳自己，于是尝试推出了将啤酒和尿布摆在一起的促销手段。没想到这个举措居然使尿布和啤酒的销量都大幅增加了。这个“啤酒＋尿布”的购物篮组合，就是关联分析的一个经典应用场景。简单来说，关联分析就是在大量数据中找到最常出现的组合。
关于Power BI如何做关联分析，网上已经有不少文章（如马老师之前的推文，以以及power bi星球等等），其中的核心是合并及userelationship。但以往这些PowerBI的案例里，纯用dax和PQ的技巧，只做出了两两之间的关联度，难以求出三个或者更多产品之间的关联度。所以本文介绍如何在PowerBI里借助Python快速求出频繁项集（关联度较大的组合）。
解决方案
对于本案，在PowerBI中使用Python有两种方法：一种是使用Py可视化控件，在控件里用Python直接作图；另一种是在PQ里处理数据，求出所需的频繁项集，再用PowerBI的原生控件进行可视化。本文先讲解前者。
本案的数据(BreadBasket，面包购物篮)结构如下。前两列是购物时间，Transaction是购物单编号，Item是物品。
首先选取Py可视化控件，拖动到画布上，然后再选中所需的字段，结果如下：
在Power Bi的下方出现了一个新的窗口（编辑器）。选中字段后，编辑器生成6行代码：意味着Pandas和matplotlib两个库默认导入，同时生成了包含所选字段的数据帧dataset。接下来，即可在编辑器中编辑代码。只要本地安装了库，都可以导入。而该控件要求代码最后必须显示图表，否则会提示出错。
Python进行关联分析有几个好用的库。在输入和输出数据的便捷性上，个人认为Mlxtend最合适。具体代码如下：
from mlxtend.frequent_patterns import apriori from mlxtend.preprocessing import TransactionEncoder import pandas as pd import matplotlib.pyplot as plt data=dataset data.Item=data.Item.str.lower() data=data.drop(data[data["Item"]=='none'].index) #删除无物品的记录 # 将数据集进行格式转换 orders_series = data.set_index("Transaction")["Item"] transactions = [] temp_index = 0 for i, v in orders_series.items(): if i != temp_index: temp_set = set() temp_index = i temp_set.add(v) transactions.append(temp_set) else: temp_set.add(v) # 数据转码 te = TransactionEncoder() te_ary = te.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/911e119a11f83df95bd641aa2124e11b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5694b5d837999ebf6c06741e2862b430/" rel="bookmark">
			C#：KeyPress事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#：KeyPress事件 KeyChar键值表(常用)实操C#窗体小型项目——BMI计算器添加KeyPress事件其中，计算公式 BMI= 体重（千克）/身高（米）/身高（米） KeyChar键值表(常用) KeyPress事件过程在截取Textbox或Combox控件输入的击键时,可立即测试击键的有效性或在字符输入时对其进行格式处理。
通常可以在处理限定输入类型时使用。
常用键的ASCII编码
ASCII编码对应字符功能0NUL空字符1SOH标题开始2STX正文开始3ETX正文结束4EOT传输结束5ENQ请求6ACK收到通7BEL响铃8BS退格9HT水平制表符10LF换行键11VT垂直制表符12FF换页键13CR回车键14SO禁用切换15SI启用切换 实操C#窗体小型项目——BMI计算器 项目效果：
首先要明确一下这个BMI计算器使用的时候，输入框的值只能是数字或者小数点。明确这一点后就可以就开始进行下一步，编写代码。
首先打开视图》》工具箱》》拖曳公共控件，标签label，文本框textBox、按钮button、图片框pictureBox 如项目效果所示。
其中显示结果的两个文本框的ReadOnly属性置为true。
重要的部分是，处理输入数据，以便用户输入错误的字母或符号导致程序错误退出。
添加KeyPress事件 点击文本框控件，在属性框上方点击 事件（闪电符号），找到KeyPress事件添加 自写函数 的函数名。
在函数中添加检查输入的代码：
private void keypressed(object sender, KeyPressEventArgs e) { //数字8是退格键的ASCII码，0X2E即十进制46，是符号‘.’的ASCII编码 //Char.IsDigit(parameter)函数的功能是判断字符是否属于十进制数字类别。 if (e.KeyChar != 8 &amp;&amp; !Char.IsDigit(e.KeyChar) &amp;&amp; e.KeyChar != 0x2E) { e.Handled = true; } //当先输入的是'.'，可以使用退格键 if (e.KeyChar == '.') { //as运算符用于将表达式显式转换为给定类型（如果其运行时类型与该类型兼容） TextBox tb = sender as TextBox; //当先输入的为符号‘.’时，文本框显示的是“0.” if (tb.Text == "") { tb.Text = "0."; //select(parameter1,parameter2)函数选择文本框中的文本范围 //参数1和参数2 分别表示文本的起始和结束位置。 tb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5694b5d837999ebf6c06741e2862b430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4679ccc5e9a47ffb8aabbe160251c6f2/" rel="bookmark">
			Java中的重写实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、重写需要继承父类，子类重写父类的方法
2、方法名必须相同；
3、参数列表也必须相同；
4、修饰符：public&gt;protected&gt;Default&gt;private，范围可以扩大但是不能缩小；
5、抛出的异常，可以被缩小但不能扩大
使用非静态方法重写：
当使用静态方法时：
静态方法只能被继承，不能被重写，如果子类有和父类相同的静态方法，那么父类的静态方法将会被隐藏，对于子类不可见，也就是说，子类和父类中相同的静态方法是没有关系的方法，他们的行为不具有多态性。但是父类的静态方法可以通过父类.方法名调用。
具体参考：https://www.cnblogs.com/love-programming/p/12458693.html
为什么要重写？因为父类的方法子类不一定需要。
不能重写的方法：
1、static方法；
2、final 常量的；
3、private方法；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a70b36bb8acded261767d18d4fefab1f/" rel="bookmark">
			es生产集群部署之各个节点以daemon模式运行以及优雅关闭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、以daemon模式运行
在生产环境中，会使用daemon进程的方式来启动es，而不是直接采用前台进程的方式来启动es，具体命令如下
./bin/elasticsearch -d -p pid
上面命令中的-d option用来指定es以daemon进程方式启动，并且-p option指定将进程id记录在指定文件中
es启动后，日志信息可以在ES_HOME/logs目录中查看
此外，启动es进程的时候，还可以直接覆盖一些配置，使用-E即可，如下面的命令，通常用于调试集群参数时，方便快速调节参数，查看效果
（1）log4j的配置不能有空格
（2）创建专门运行elasticsearch的用户，并授权
像我之前讲课，为了方便，全都是用root用户在做各种操作，但是实际生产环境中，大家应该都知道，root都是那些运维人员的权限
es其实是禁止用root用户去启动es进程的，那么可以加一个配置来允许用root去启动，但是还是算了吧
adduser elasticsearch
passwd elasticsearch
chown -R elasticsearch /usr/local/elasticsearch
chown -R elasticsearch /var/log/elasticsearch
chown -R elasticsearch /var/data/elasticsearch
chown -R elasticsearch /var/plugin/elasticsearch
chown -R elasticsearch /etc/elasticsearch
chown -R elasticsearch /usr/local/tmp
（3）修改/etc/security/limits.conf中的用户为elasticsearch，而不是root
（4）加入memlock的soft unlimited
（5）path.plugins失效，删除这一行配置
（6）jvm.options看来还是用的老的目录中的配置文件
（7）将es的bin加入环境变量PATH中
（8）切换到elasticsearch用户来启动es进程
su elasticsearch
elasticsearch -d -Epath.conf=/etc/elasticsearch
2、访问es
一般建议在管理机上安装一个curl工具，可以手工发送rest api请求
可以对启动了es的节点的9200端口，发送一个GET /请求，可以看看es是否启动成功
curl -XGET elasticsearch02:9200
curl -XGET elasticsearch02:9200/_cat/nodes?v
3、停止es
优雅的关闭es，可以确保es关闭的很干净，并且优雅关闭资源。举例来说，如果node在一个合理的顺序下关闭了，首先会将自己从cluster中优雅移除，fsync translog日志到磁盘中去，然后执行其他相关的cleanup活动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a70b36bb8acded261767d18d4fefab1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/931034a1d8850c1d9bfd35fe55368830/" rel="bookmark">
			matplotlib 基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用matplotlib时遇到一些问题，特记录在此 1. 图表中中文不能正常显示 新建pyhton脚本文件 matplotlib_sup_ch.py
# matplotlib_sup_ch.py import matplotlib.pyplot as plt plt.rcParams['font.sans-serif'] = ['SimHei'] plt.rcParams['axes.unicode_minus'] = False cplt = plt 在需要绘图的地方将cplt导入使用，就可以解决中文不能正常显示的问题
# test.py from matplotlib_sup_ch import cplt as plt import math import numpy as np if __name__ == '__main__': x = list(np.linspace(0, 2*math.pi, 100)) # 从[0, 2π]中取100个数据点 y = [math.cos(e) for e in x] plt.title('cos曲线') plt.xlabel('弧度') plt.plot(x, y) plt.show() 2. matplotlib中可用的颜色列表 新建color.py
# color.py cnames = { 'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqua': '#00FFFF', 'aquamarine': '#7FFFD4', 'azure': '#F0FFFF', 'beige': '#F5F5DC', 'bisque': '#FFE4C4', 'black': '#000000', 'blanchedalmond': '#FFEBCD', 'blue': '#0000FF', 'blueviolet': '#8A2BE2', 'brown': '#A52A2A', 'burlywood': '#DEB887', 'cadetblue': '#5F9EA0', 'chartreuse': '#7FFF00', 'chocolate': '#D2691E', 'coral': '#FF7F50', 'cornflowerblue': '#6495ED', 'cornsilk': '#FFF8DC', 'crimson': '#DC143C', 'cyan': '#00FFFF', 'darkblue': '#00008B', 'darkcyan': '#008B8B', 'darkgoldenrod': '#B8860B', 'darkgray': '#A9A9A9', 'darkgreen': '#006400', 'darkkhaki': '#BDB76B', 'darkmagenta': '#8B008B', 'darkolivegreen': '#556B2F', 'darkorange': '#FF8C00', 'darkorchid': '#9932CC', 'darkred': '#8B0000', 'darksalmon': '#E9967A', 'darkseagreen': '#8FBC8F', 'darkslateblue': '#483D8B', 'darkslategray': '#2F4F4F', 'darkturquoise': '#00CED1', 'darkviolet': '#9400D3', 'deeppink': '#FF1493', 'deepskyblue': '#00BFFF', 'dimgray': '#696969', 'dodgerblue': '#1E90FF', 'firebrick': '#B22222', 'floralwhite': '#FFFAF0', 'forestgreen': '#228B22', 'fuchsia': '#FF00FF', 'gainsboro': '#DCDCDC', 'ghostwhite': '#F8F8FF', 'gold': '#FFD700', 'goldenrod': '#DAA520', 'gray': '#808080', 'green': '#008000', 'greenyellow': '#ADFF2F', 'honeydew': '#F0FFF0', 'hotpink': '#FF69B4', 'indianred': '#CD5C5C', 'indigo': '#4B0082', 'ivory': '#FFFFF0', 'khaki': '#F0E68C', 'lavender': '#E6E6FA', 'lavenderblush': '#FFF0F5', 'lawngreen': '#7CFC00', 'lemonchiffon': '#FFFACD', 'lightblue': '#ADD8E6', 'lightcoral': '#F08080', 'lightcyan': '#E0FFFF', 'lightgoldenrodyellow': '#FAFAD2', 'lightgreen': '#90EE90', 'lightgray': '#D3D3D3', 'lightpink': '#FFB6C1', 'lightsalmon': '#FFA07A', 'lightseagreen': '#20B2AA', 'lightskyblue': '#87CEFA', 'lightslategray': '#778899', 'lightsteelblue': '#B0C4DE', 'lightyellow': '#FFFFE0', 'lime': '#00FF00', 'limegreen': '#32CD32', 'linen': '#FAF0E6', 'magenta': '#FF00FF', 'maroon': '#800000', 'mediumaquamarine': '#66CDAA', 'mediumblue': '#0000CD', 'mediumorchid': '#BA55D3', 'mediumpurple': '#9370DB', 'mediumseagreen': '#3CB371', 'mediumslateblue': '#7B68EE', 'mediumspringgreen': '#00FA9A', 'mediumturquoise': '#48D1CC', 'mediumvioletred': '#C71585', 'midnightblue': '#191970', 'mintcream': '#F5FFFA', 'mistyrose': '#FFE4E1', 'moccasin': '#FFE4B5', 'navajowhite': '#FFDEAD', 'navy': '#000080', 'oldlace': '#FDF5E6', 'olive': '#808000', 'olivedrab': '#6B8E23', 'orange': '#FFA500', 'orangered': '#FF4500', 'orchid': '#DA70D6', 'palegoldenrod': '#EEE8AA', 'palegreen': '#98FB98', 'paleturquoise': '#AFEEEE', 'palevioletred': '#DB7093', 'papayawhip': '#FFEFD5', 'peachpuff': '#FFDAB9', 'peru': '#CD853F', 'pink': '#FFC0CB', 'plum': '#DDA0DD', 'powderblue': '#B0E0E6', 'purple': '#800080', 'red': '#FF0000', 'rosybrown': '#BC8F8F', 'royalblue': '#4169E1', 'saddlebrown': '#8B4513', 'salmon': '#FA8072', 'sandybrown': '#FAA460', 'seagreen': '#2E8B57', 'seashell': '#FFF5EE', 'sienna': '#A0522D', 'silver': '#C0C0C0', 'skyblue': '#87CEEB', 'slateblue': '#6A5ACD', 'slategray': '#708090', 'snow': '#FFFAFA', 'springgreen': '#00FF7F', 'steelblue': '#4682B4', 'tan': '#D2B48C', 'teal': '#008080', 'thistle': '#D8BFD8', 'tomato': '#FF6347', 'turquoise': '#40E0D0', 'violet': '#EE82EE', 'wheat': '#F5DEB3', 'white': '#FFFFFF', 'whitesmoke': '#F5F5F5', 'yellow': '#FFFF00', 'yellowgreen': '#9ACD32' } 绘图时颜色不够丰富，从color.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/931034a1d8850c1d9bfd35fe55368830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a3ae79435de4ed9c51e156b8c9d80c1/" rel="bookmark">
			利用更新后的tushare.pro数据库免费获得股票的基本信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		==================== 利用更新后的tushare.pro数据库获得股票的基本信息 ==================== 获取tushare数据的前期准备 ‘’’
一、用户注册
1.访问https://tushare.pro,点击右上角“注册”
2.填入注册信息，按提示操作注册
3.完成后登录验证是否注册成功
二、获取token
1.登录成功后，右击右上角→个人主页
2.在“用户中心”中点击接口“接口TOKEN"
3.点击右侧复制按钮复制token，token是调取数据的唯一凭证，请妥善保管，如被盗用，回到个人主页刷新
三、通过tushare python包调取数据
安装 pip install tushare
如果安装网络超时可用国内pip源，如 pip install tushare -i https://pypi.tuna.tsinghua.edu.cn/simple
查看当前版本
import tushare
print(tushare.version)
升级当前版本
pip install tushare --upgrade
获取日线数据需要120积分，积分不消耗，是获取的前提
Tushare高级用户群：1038535887(付费50后，进群后私信群主可获得500积分)
‘’’
import tushare as ts import pandas as pd ts.set_token('c8811a29e9b51d03b2b3f6be3937f331d6187999563900664056c438') # 输入token码 初始化pro接口 pro = ts.pro_api() pro = ts.pro_api('c8811a29e9b51d03b2b3f6be3937f331d6187999563900664056c438') # 如果上一步骤ts.set_token('your token')无效或不想保存token到本地，也可以在初始化接口里直接设置token 一、获取交易日历信息 df = pro.trade_cal(exchange='', start_date='20200102', end_date='20200913', fields='exchange,cal_date,is_open,pretrade_date', is_open='0') pd.set_option('display.max_columns', None) # 显示DataFrame所有列 print(df) 二、获取当前所有正常上市交易的股票列表 import tushare as ts pro = ts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a3ae79435de4ed9c51e156b8c9d80c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7bcc0799789ff75f6aac05b4d665877/" rel="bookmark">
			如何在Google Home上收听播客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Google has podcasts baked into the Play Music app for Android, and it recently released a dedicated Podcast app, as well. But you also can listen to podcasts directly on your Google Home pretty easily.
Google已将播客纳入Android的Play音乐应用中，并且最近还发布了专用的播客应用 。 但是，您也可以非常轻松地直接在Google Home上收听播客。 There are a couple of ways to do this: by using your voice, or by casting. We’ll cover both.
有两种方法可以做到这一点：使用您的声音或投射。 我们都将介绍。 如何用声音听家里的播客 (How to Listen to Podcasts on Home with Your Voice) The easiest way to fire up a podcast on Google Home is by simply telling your Google Assistant to play the podcast you want to hear.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7bcc0799789ff75f6aac05b4d665877/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68a2dca5b2ede4cfbe7a0b787f08bafd/" rel="bookmark">
			2. 编写程序，求 x&#43;xx&#43;xxx&#43;……（例如：8&#43;88&#43;888&#43;……）前 n 项之和。x 和 n 的值由 用户从键盘输入。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2. 编写程序，求 x+xx+xxx+……（例如：8+88+888+……）前 n 项之和。x 和 n 的值由 用户从键盘输入。
package com.temp; import java.util.Scanner; /** * @Author lanxiaofang * @email 983770299@qq.com * @date 2020/09/14 08:15 */ public class SumOfX { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println("请输入您想要求和的数："); int x = scanner.nextInt(); System.out.println("请问求前几项的和？"); int n = scanner.nextInt(); int n1=x, sum = x; for(int i = 1; i &lt; n; i++){ n1 = n1*10+x; sum = sum+n1; } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68a2dca5b2ede4cfbe7a0b787f08bafd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/478ce1ddf12b87507cd5d02896fe2102/" rel="bookmark">
			国庆游玩攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		终于到了国庆节，我要去杭州和我的北鼻约会了：
10.1 - 10.2出发
到杭州之后就已经是10.2了，到的这么晚，肯定要和宝贝睡到12点了。那么10.2就只能在市内玩了
10.2 - 10.3
去趟游乐园吧！！！，和宝贝还没去过游乐园
10.3 - 10.4：看海（住一晚）
经过一波网上信息的搜寻，最终决定把看海的地方定在了舟山
看看地理位置
看看路线
嗯。。为了节省时间，我和宝贝要尽早 出发----6:30从家出发到杭州东站
好了，到了余杭站已经是7:10了，然后坐高铁去宁波站；定了7:31的高铁票，提前二十分钟到？但是感觉已经有点赶
到宁波了，现在已经是9:00了，接下来就要出发去舟山市了，全程四个多小时，真是辛苦呀！
嗯。。到舟山之后就已经是13:00了，接下来先去酒店休息休息，在市内玩玩。第二天再开始我们的happy。
如上所示：舟山市 ~ 桃花岛 ~ 普陀山 ~ 舟山市；时间点安排如下
7：00出发
~2小时22分钟后
9：22到达桃花岛码头，在这里玩到13：00
~3小时38分钟后
13：00依旧在桃花岛码头
~30分支后
13：30到达普陀山码头，在这里玩到18：00
~4：30分钟后
18：00依旧在普陀山码头，回市区（因为要赶八点的末班车）
10.4 - 10.5：go to 魔都
10.4号早上出发，中午到上海，看看上海的夜景（细节待定），座晚上的高铁回杭州
好了，到家就已经是10.5号了。
10.5 - 10.6： 今天休息一天，毕竟跑了这么多了；王者 &amp; 电影（八佰？）搞起来
10.4 - 10.7：爬山爬山爬山
百度得知是一个5a的景区（具体待定）
10.7打道回府
总结：
时间做事10.1出发10.2游乐园10.3宁波看海10.4宁波看海 &amp; 打卡上海10.5游戏&amp;电影10.6台州神仙居。爬上！10.7肥家 十一就要和女友嗨皮，嗨皮，嗨皮！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7281f5095771e4d3ff20a1868ceb090/" rel="bookmark">
			复合选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;复合选择器&lt;/title&gt; &lt;style&gt; /* 将class为red的元素设置为红色（字体） */ .red{ color:red; } /* 将class为red的div字体大小设置为30px */ /* 交集选择器 作用：选中同时复合多个条件的元素 语法：选择器1选择器2选择器3选择器n{} 注意点： 交集选择器中如果有元素选择器，必须使用元素选择器开头 */ div.red{ font-size: 30px; } .a.bb.ccc{ font-size: 50px; } /* 选择器分组（并集选择器） 作用：同时选择多个选择器对应的元素 语法：选择器1,选择器2,选择器3,选择器n{} #b1,.p1,h1,span,div.red{} */ h1,span{ color:blueviolet; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="red"&gt;我是red div&lt;/div&gt; &lt;div class="green a bb ccc"&gt;我是green div&lt;/div&gt; &lt;p class="red"&gt;我是p元素&lt;/p&gt; &lt;h1&gt;我是h1&lt;/h1&gt; &lt;span&gt;我是span&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e87afb180272e51d630883b84e942c6d/" rel="bookmark">
			剑指offer 38-字符串的排列 C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
输入描述:
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。
思路：采用递归+set去重
（1）将第一个字符与后面所有字符交换；
（2）固定第一个字符，求后面所有字符的排列
class Solution { public: vector&lt;string&gt; Permutation(string str) { if (str.size() == 0) return {}; set&lt;string&gt; res; PermutationSub(str, res, 0); return vector&lt;string&gt;({ res.begin(),res.end() }); } set&lt;string&gt; PermutationSub(string str, set&lt;string&gt;&amp; res, int count) { for (int i = count; i &lt; str.size(); i++) { //将第count所在位置的字符和后面所有字符进行交换 swap(str[count], str[i]); res.insert(str); //将交换后的结果放到set容器 PermutationSub(str, res, count + 1); //注意此处不能写成count++ swap(str[count], str[i]); } return res; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4f1cfd59acb6ababcfc9c78c5743fd/" rel="bookmark">
			go test 在用kind 安装了kubernetes 之后就不灵了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我怀疑kind 在安装kubernetes的时候， 加了某些命令行参数。 改变了go 里面的东西。 暂时还找不到原因。
我先把go 重装了一下。 以后在看看吧。
如何复现：
1. 先用 kind 安装kubernetes 集群。
2. 用 go test 测试 发现需要 kubeconfig 参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f73c3fb628747505e2bf427bc3145285/" rel="bookmark">
			面试官问我：如何设计 QQ、微信等第三方账号登陆 ？还要我说出数据库表设计！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试官问我：如何设计 QQ、微信等第三方账号登陆 ？还要我说出数据库表设计！ 多账户的统一登录名称解释内容架构演进创业初期用户名密码注册登陆手机号注册登陆数据库设计引入第三方账户方案数据库设计 总结 多账户的统一登录 名称解释 这里的多账户区别于系统级别的，我们讲的多账户系统是指，在我们互联网应用当中，我们的应用会使用多个第三方账号进行登录，比如现在常用的APP：网易、微信、QQ等等。
内容 通过这一篇文章：
1.可以学到：多用户下面的技术方案细节，以及相应的表设计，流程设计。
2.不可以学到：与其他文章一样，我这里不会有具体代码实现细节，方案做的对，代码咋写都不会太烂。
架构演进 创业初期 归结为创业初期是因为这个时候用户量比较少，甚至还没有接入上面所说的其他第三方的账户系统，只是自建的体系就可以满足，自建体系的话，目前常用的有
用户名密码注册登陆 这种方式在很多初期网站建设会使用，先注册，再进行登录，在老一点的cms中都能找到这个影子。
流程图：
流程说明：
1.前端将用户名、密码发送到服务器，服务器进行常规的判断，判断用户名、密码长度是否满足，用户名是否重复等条件，条件不通过直接返回对应错误码给到前端，这里密码字段，为了防止传输过程中被截胡，建议加密再上传，我们的传输密码默认都是会进行一个md5加密，然后记录到数据库再进行一层加密，就算是脱库也没事，密码不要明文存储。
2.校验通过后，就将用户名密码写入数据库，并进行后面积分发放等操作，这里不展开。
3.现在进行登录，前端将用户名，密码发送给到服务端，服务端首先会校验登录次数是否超过设置的阈值，如果超过只能继续等待被关小黑屋。
4.如果未超过继续登录逻辑，判断用户名、密码是否正确，不正确密码则进行阈值的判断，如果超过则关小黑屋，记住小黑屋必须设置过期时间，要不然就会永久关上了，这个可以用redis的过期来做。
5.登录成功后进行后续的一切后置逻辑，比如加积分。。。等操作。
手机号注册登陆 流程图：
流程说明：
1.首先输入手机号，然后发送到服务端，服务端将手机号记录在我们数据库中，然后生成随机验证码，并将手机号和验证码绑定到一个redis里面，然后记录过期时间，这个过期时间一般是10分钟左右，这就是我们一般手机验证码的有效期。
2.手机接收到手机短信后，那么就在界面填写验证码发送服务端，服务端收到验证码后就会在redis里面查询到这个手机号对应的验证码，失败就返回错误码。
3.成功后就进行登录操作。
这里看起来没有明确的注册登录操作，其实在发送手机号码就可以认为是一个常规的注册，然后后面的验证码输入就是一个登陆操作，
问： 那我要密码咋办？
答： 在后续产品里面增加一个 手机号码密码补录的功能 即可，这也是现在很常规的手法，但是现在移动互联网大爆炸时代，密码已经显得不是那么重要了，反正我从来记不住密码，如果手机号码能操作的app，绝对不用密码来操作。
数据库设计 表结构 ：
自增id用户名密码手机错误次数1user17fef6171469e80d32c0559f88b3772451345678901202user27fef6171469e80d32c0559f88b377245134567890120 说明 ：
这里只是单纯说明需要用到的数据，没有扩展具体场景,这个表结构能够满足上面两个方案的设计。
引入第三方账户方案 这里是以QQ-SDK的登录逻辑， 我们先来一波时序图
说明：
1.客户端自己调起登录的界面，进行输入用户名、密码，这里的是第三方的用户名，密码，登录成功后，会返回access_token openid expire_in,这过程会使用到oauth2.0，不过在sdk里面进行内置回调获取了，后面我们会说明我们自身实现的oauth2.0
2.客户端拿到access_token、openid、login_type（qq、wechat…）请求应用服务器，应用服务器拿到这些数据后就会根据对应的login_type去对应的用户中心进行access_token和openid进行校验。校验不通过则返回对应错误码
3.校验通过后就会判断本地是否有这个login_type和openid是否存在，不存在则进行获取远程的用户名、头像等基础信息来作为本地基础数据，并且返回code值
4.如果已经存在，那就是进行登录操作，返回code值。
5.客户端拿到code值后进行token值的换取，这个完全遵照oauth2.0的协议来走的，后续每次请求必须带上token，token值在服务端的时间比较久，因为我们想要做的是那种永不下线的操作，所以每次请求我们都将token过期时间进行累加。
数据库设计 根据部分小伙伴的的建议，我这里做一下数据库的整理：
用户基础表（users）
字段备注user_id用户idtoken用户登陆的tokenexpire_intoken过期时间try_times登录失败次数 用户验证关联表（user_auth_rel）
字段备注id自增iduser_id用户idauth_id验证表idauth_type验证类型(local、third) 本地用户表|（user_local_auth）
字段备注auth_id认证id，自增iduser_name用户唯一标识password用户密码mobile用户手机 第三方用户表（user_third_auth）
字段备注auth_id用户idopenid第三方用户唯一标识login_type第三方平台标识(qq、wechat…)access_token第三方获取的access_token,校验使用 说明
1.users表只是单纯针对我们业务侧的登录，主要是做自身业务的oauth2.0业务，
2.user_local_auth是做自己用户名、密码登录，手机号码登录信息记录，
3.user_third_auth是我们第三方用户体系的数据记录，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f73c3fb628747505e2bf427bc3145285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1438f2e6529f3f4ab489a160a44a53ad/" rel="bookmark">
			springboot源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 概述
2. 基于springboot开发web项目
3. spring容器的创建
4. springboot启动类加入spring容器
5. 基于条件配置bean
5.1 什么时候进行条件判断
5.2 条件判断处理分析
5.3 常见Conditional注解分析
5.3.1 @ConditionalOnBean
5.3.2 @ConditionalOnClass
5.3.3 @ConditionalOnProperty
6. 自动配置
6.1 加载所有的META-INF/spring.factories文件中配置
6.2 将spring.factories文件中EnableAutoConfiguration配置类加入spring
7. 内嵌Tomcat的创建和配置
7.1 创建Tomcat服务器
7.2 DispatcherServlet的创建和加入web容器
8. springboot属性加载
8.1 springboot默认属性加载文件
8.2 springboot配置bean的扫描和初始化
8.2.1 ServerProperties注册到spring容器
8.2.2 ServerProperties属性注入
（本篇测试、分析项目代码路径https://gitee.com/yejuan/springboot-learning.git 对应tag: c1）
1. 概述 springboot有大量的自动配置、条件注册bean使开发者很简单快捷地接入各种服务和组件，是优秀的敏捷开发工具。
springboot中有大量的服务配置在META-INF/spring.factories文件中，使用时通过key找到相应的类再反射获取实例；springboot会自动过滤注册META-INF/spring.factories文件中配置的key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的class到spring容器 2. 基于springboot开发web项目 代码示例
jar包依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${springboot.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;${springboot.version}&lt;/version&gt; &lt;/dependency&gt; spring boot启动类
@SpringBootApplication(scanBasePackages={"com.yej.learning"}) public class App { public static void main( String[] args ) { /** * App.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1438f2e6529f3f4ab489a160a44a53ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2693754423c66ffbc0723018c460272/" rel="bookmark">
			lotus-miner 设置多个存储路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 lotus-miner 设置多个存储路径 1，初始化矿工 1，初始化矿工 # lotus-miner --version lotus-miner version 0.6.2+git.8b2862a1.dirty 初始化矿工设置--no-local-storage lotus-miner init --no-local-storage --owner=t3钱包地址 --sector-size=32GiB # cat miner/storage.json { "StoragePaths": null } nohup lotus-miner run &gt;&gt; /var/log/miner/miner.log 2&gt;&amp;1 &amp; 设置缓存/seal为SSD lotus-miner storage attach --init --seal /seal 设置存储目录/storage/store为HDD lotus-miner storage attach --init --store /storage/store # cat miner/storage.json { "StoragePaths": [ { "Path": "/seal" }, { "Path": "/storage/store" } ] } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7fca3821a321db3f30ff613d49e5eb5/" rel="bookmark">
			修改element ui 小三角 dropdown
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;style scoped&gt; .el-popper /deep/ .popper__arrow { border-bottom-color: #1EBEF4 !important; left: 50% !important; visibility: hidden; } 因为style在scoped内部需要用/deep/进行穿透
visibility：hidden，使其不显示
参考
https://blog.csdn.net/xuhua32100/article/details/107494873?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2allfirst_rank_v2~rank_v25-4-107494873.nonecase&amp;utm_term=element%20ui%20%E5%8E%BB%E6%8E%89%E5%B0%8F%E4%B8%89%E8%A7%92
https://blog.csdn.net/weixin_42304808/article/details/106118025?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2allfirst_rank_v2~rank_v25-1-106118025.nonecase&amp;utm_term=element%20ui%20%E5%8E%BB%E6%8E%89%E5%B0%8F%E4%B8%89%E8%A7%92
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/352/">«</a>
	<span class="pagination__item pagination__item--current">353/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/354/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>