<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1edffd3bacccb0b79c56643aface02f/" rel="bookmark">
			docker容器引擎（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker 一、docker的理论部分docker的概述容器受欢迎的原因容器与虚拟机的区别docker核心概念 二、安装docker三、docker镜像操作四、docker容器操作 一、docker的理论部分 docker的概述 一个开源的应用容器引擎，基于go语言开发并遵循了apache2.0协议开源再Linux容器里运行应用的开源工具一种轻量级的“虚拟机”docker的容器技术可以在一台主机上轻松位任何应用创建一个轻量级的、可移植的、自给自足的容器 目的：一次封装，到处运行
容器受欢迎的原因 灵活：即使是最复杂的应用也可以集装箱化轻量级：容器利用并共享主机内核可互换：可以即时部署更新和升级便携式：可以在本地构建，部署到云，并在任何地方运行可扩展：可以增加并自动分发容器副本可堆叠：可以垂直和即时堆叠服务
容器与虚拟机的区别 特性docker虚拟机启动速度秒级分钟级计算能力耗损几乎无耗损50%左右性能接近原生弱于系统支持量（单机）上千个几十个隔离性资源隔离/限制完全隔离 容器在内核中支持2种重要技术：
docker容器本质就是宿主机的一个进程，docker是通过namespace实现资源隔离，通过cgroup实现资源限制，通过写时复制技术（copy-on-write）实现了高效的文件操作（类似虚拟机的磁盘比如分配500G并不是实际占用物理磁盘500G，只有当修改时才复制一份数据）
Linux namespace的六大类型
docker核心概念 镜像
docker的镜像是创建容器的基础，类似于虚拟机的快照，可以理解为一个面向docker容器引擎的只读模板
通过镜像启动一个容器，一个镜像是一个可执行的包，其中包括运行应用程序所需要的所有内容包含代码、运行时间、库、环境变量、配置文件
docker镜像也是一个压缩包，只是这个压缩包不只是可执行文件，环境部署脚本，他还包含了完整的操作系统。因为大部分的镜像都是基于某个操作系统来构建，所有很轻松的就可以构建本地和远端一样的环境，这也是docker镜像的精髓
容器
docker的容器是从镜像创建的运行实例，它可以被启动、停止、删除。所创建的每一个容器都是相互隔离、互不可见，以保证平台的安全性
可以把容器看做是一个简易版的Linux环境（包括root用户权限、镜像空间、用户空间和网络空间登）和运行在其中的应用程序
仓库
docker仓库是用来集中保存镜像的地方，当创建了自己的镜像之后，可以使用push命令将它上传到公有仓库（piblic）或者私有仓库（private）。当下次要在另外一台机器上使用这个镜像时，只需要从仓库中获取。
docker的镜像、容器、日志等内容都默认存储在/var/lib/docker
二、安装docker 目前 Docker 只能支持 64 位系统。
systemctl stop firewalld.service
setenforce 0
#安装依赖包
yum install -y yum-utils device-mapper-persistent-data lvm2
yum-utils：提供了 yum-config-manager 工具。
device mapper： 是Linux内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构。
device mapper存储驱动程序需要 device-mapper-persistent-data 和 lvm2。
#设置阿里云镜像源
yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
#安装 Docker-CE并设置为开机自动启动
yum install -y docker-ce docker-ce-cli containerd.io
systemctl start docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1edffd3bacccb0b79c56643aface02f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8534a5ccd028285452369640af827b46/" rel="bookmark">
			火狐安卓版支持油猴了！后面将支持更多扩展插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日前火狐浏览器每夜构建版的安卓版已经带来了更多扩展程序支持，这其中就包括大名鼎鼎的油猴扩展程序。本次火狐浏览器每夜构建版更新新增五款扩展程序支持，并且按照谋智基金会说法还会支持更多的扩展程序。
下载地址：https://ftp.mozilla.org/pub/fenix/nightly/2022/12/
要达成在桌面和安卓端的扩展程序同时支持，火狐浏览器希望通过 Manifest v3 标准增加移动扩展的可用性。因此最终目的应该是让扩展同时支持桌面和移动端，当然iOS版用户请不要多想除非苹果真放开WebKit限制。
新增的5款扩展程序：
Firefox Relay：谋智基金会官方推出的隐私中继服务 , 实际就是火狐与其他服务商联合提供的VPN加密隧道。
Tampermonkey：最为知名的脚本扩展程序之一 , 可以让你安装各种自定义脚本为浏览器实现更多独特功能。
Read Aloud：支持40多种语言的朗读扩展程序 ，如果不想看文字那可以使用该扩展自动大声读出网页内容。
AdNauseum：基于 uBlock Origin 的分支，屏蔽广告的同时还模拟点击广告，从而迷惑广告网络的跟踪器。
ClearURLs：帮助你自动删除网址中的追踪标识符，比如之前B站分享链接自动携带用户 UID 就可以清除掉。
扩展程序跨平台使用：
根据谋智基金会的公告，未来将为Firefox for Android版带来更多扩展程序丰富用户的功能使用提高易用性。同时开发者目前可以专注于在桌面平台实现Manifest v3 API支持 , 到2023年将可以用来开发移动扩展程序。
在博客中谋智基金会还解释新版接口将为扩展提供拆分进程的能力，这反过来将支持更好地处理进程重启等。简言之就是确保安卓系统在后台关闭应用程序优化体验时，火狐浏览器也可以更好地处理扩展后台运行问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bca1324aa827e13428380b047ccd7d4/" rel="bookmark">
			《Linux0.11源码解读》理解(五) head之开启分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先回顾一下地址长度以及组合的演变：16位cpu意味着其数据总线/寄存器也是16位，但是地址总线（寻址能力）与此无关，可能是20位。可以参考：cpu的位宽、操作系统的位宽和寻址能力的关系_cpu位宽_brahmsjiang的博客-CSDN博客
也就因为寄存器和地址总线位数的不对等，于是16位cpu的寻址方式是： 物理地址=段地址×16+偏移地址。这叫做实模式。但随着历史的演进，cpu已经支持32位（地址总线可以36位）、甚至64位（地址总线可以40位）。为了提升寻址能力和安全性，也为了兼容16位系统，在setup阶段就开始准备从16位实模式往32位保护模式做准备。
在32位保护模式下，段寄存器中存储是段选择子。根据段选择子的索引去查询全局描述符表以获得段描述符，其中存储着基地址，物理地址=基地址+偏移地址。
一旦开启了分段机制，还要多一步： 即程序员写代码时给出的地址叫逻辑地址，其中包含段选择子和偏移地址两部分。通过分段后得到的叫线性地址，线性地址通过分页后得到的叫物理地址。比如我们得到的线性地址是32位，分页机制大概是这样运作的：
线性地址被分为高 10 位、中间 10 位、后 12 位。高 10 位在页目录表中找到一个页目录项，这个页目录项的值加上中间 10 位拼接后的地址去页表中去寻找一个页表项，这个页表项的值，再加上后 12 位偏移地址，就是最终的物理地址。这个过程是由硬件MMU（内存管理单元）完成的。
现在我们继续上一节，将head程序跳转至setup_paging开启分页：
setup_paging: mov ecx,1024*5 ;用来计数 xor eax,eax xor edi,edi pushf ;保存所有标志, 这里主要为了DF(方向标志位) cld ;让DF=0，用于串操作指令中。决定内存地址递增 rep stosd ;重复执行后面的指令stos。每次执行时从ecx-1，直到ecx=0则结束重复 mov eax,_pg_dir ;设置页目录中的项，仅需4个。_pg_dir为页表目录标号（0地址开始） mov [eax],pg0+7 ;pg0+7表示：0x00001007，是页目录表中的第1项 mov [eax+4],pg1+7 mov [eax+8],pg2+7 mov [eax+12],pg3+7 mov edi,pg3+4092 mov eax,00fff007h ;16Mb-4096+7 (r/w user,p) std L3: stosd ;将eax的内容复制到edi，复制4字节，并将edi加/减4个字节 sub eax,00001000h jge L3 popf xor eax,eax mov cr3,eax mov eax,cr0 or eax,80000000h mov cr0,eax ret 上述代码的意义就是在内存中一次写好页目录表和页表，之后开启cr0寄存器的分页开关。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bca1324aa827e13428380b047ccd7d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8c1ec71f4709a3df60c4e7aab4a938b/" rel="bookmark">
			Internal server error: No known conditions for “./lib/locale/lang/zh-cn“ specifier in “element-plus“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Internal server error: No known conditions for "./lib/locale/lang/zh-cn" specifier in "element-plus" package问题解决，导致原因:element-plus 版本不兼容，回退老版本即可（我的：2.3.8-&gt;2.3.4）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bc054ee68dcca33f9c5efdf2dcc92fe/" rel="bookmark">
			ENSP实验四：搭建VPN（GRE，配置安全策略）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先分析一下数据的流向：
PC1-&gt;PC2 1、FW1：trust-&gt;dmz 【192.168.1.1-&gt;192.168.2.1 ICMP】
2、AR1-&gt;AR2：【202.1.1.1-&gt;202.1.3.1|GRE|192.168.1.1-&gt;192.168.2.1 icmp】
3、FW2：
①untrust-&gt;local 202.1.1.1-&gt;202.1.3.1 GRE
②dmz-&gt;trust 【192.168.1.1-&gt;192.168.2.1 ICMP】
PC2-&gt;PC1 4、FW2： trust-&gt;dmz 【192.168.1.1&lt;-192.168.2.1 ICMP】
5、AR2-&gt;AR1： 【202.1.1.1&lt;-202.1.3.1|GRE|192.168.1.1&lt;-192.168.2.1 icmp】
6、FW1:
① untrust-&gt;local 202.1.1.1&lt;-202.1.3.1|GRE
②dmz-&gt;trust 【192.168.1.1&lt;-192.168.2.1 ICMP】
一、基础配置+建立VPN通道+引流（参考ENSP实验三带内容） **将Tunnel1逻辑接口配到dmz区域中
ping流量【192.168.1.1-&gt;192.168.2.1 icmp】从PC1流至FW1
二、FW1配置安全策略（单向：PC1-&gt;PC2）： [FW1]security-policy [FW1-policy-security]rule name test1 [FW1-policy-security-rule-test1]source-zone trust [FW1-policy-security-rule-test1]destination-zone dmz [FW1-policy-security-rule-test1]source-address 192.168.1.1 mask 255.255.255.255 [FW1-policy-security-rule-test1]destination-address 192.168.2.1 mask 255.255.255 .255 [FW1-policy-security-rule-test1]service icmp [FW1-policy-security-rule-test1]action permit 将流量送至FW1后，根据外层头二次查表，送至下一个路由AR1【202.1.1.1-&gt;202.1.3.1|GRE|192.168.1.1-&gt;192.168.2.1 icmp】
AR1查表，将流量送至AR2
三、配置FW2收流量带安全策略（单向：PC1-&gt;PC2） 收到AR2传来的流量【202.1.1.1-&gt;202.1.3.1|GRE|192.168.1.1-&gt;192.168.2.1 icmp】
1、策略1：决定收不收流量 [FW2]security-policy [FW2-policy-security]rule name test1 [FW2-policy-security-rule-test1]source-zone untrust [FW2-policy-security-rule-test1]destination-zone local [FW2-policy-security-rule-test1]source-address 202.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bc054ee68dcca33f9c5efdf2dcc92fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb65fe8d9f9f7159e1e44ebc27a92f05/" rel="bookmark">
			CnOCR 使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、 简介二、使用教程三、效果展示 一、 简介 CnOCR 是 Python 3 下的文字识别（Optical Character Recognition，简称OCR）工具包，支持简体中文、繁体中文（部分模型）、英文和数字的常见字符识别，支持竖排文字的识别。自带了20+个训练好的识别模型，适用于不同应用场景，安装后即可直接使用。同时，CnOCR也提供简单的训练命令供使用者训练自己的模型。
二、使用教程 1. 相关文档
项目地址：https://github.com/breezedeus/cnocr介绍文档：https://cnocr.readthedocs.io/zh/latest/ 2. 安装
pip安装pip install cnocr 国内安装源 pip install cnocr -i https://pypi.doubanio.com/simple 推荐使用python3.6及以上版本 3. 使用
初始化
类CnOcr 是识别主类，包含了三个函数针对不同场景进行文字识别。类CnOcr的初始化函数如下： class CnOcr(object): def __init__( self, rec_model_name: str = 'densenet_lite_136-fc', *, det_model_name: str = 'ch_PP-OCRv3_det', cand_alphabet: Optional[Union[Collection, str]] = None, context: str = 'cpu', # ['cpu', 'gpu', 'cuda'] rec_model_fp: Optional[str] = None, rec_model_backend: str = 'onnx', # ['pytorch', 'onnx'] rec_vocab_fp: Union[str, Path] = VOCAB_FP, rec_more_configs: Optional[Dict[str, Any]] = None, rec_root: Union[str, Path] = data_dir(), det_model_fp: Optional[str] = None, det_model_backend: str = 'onnx', # ['pytorch', 'onnx'] det_more_configs: Optional[Dict[str, Any]] = None, det_root: Union[str, Path] = det_data_dir(), **kwargs, ) 参数说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb65fe8d9f9f7159e1e44ebc27a92f05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf594a2679770f9e2346407abb74aa36/" rel="bookmark">
			Nginx 图片防盗链设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片防盗链，只允许图片在特定的站点内访问和URL访问，不允许图片在其他站点上访问。
如：图片是 A 服务器的图片，但是被其他不法站点展示在页面上。
在 nginx 配置中 的 server 增加 location 限制
# 只有gif|jpg|jpeg|png|bmp|swf后缀进入该位置 # 指定防篡改的文件类型 location ~*\.(gif|jpg|jpeg|png|bmp|swf)&amp; { # valid_referers 指定资源访问的合法方式 # 直接通过url访问，无referer值的情况 # blocked referer值被防火墙修改 # 1、允许url访问 和 127.0.0.1:8080 的网站访问 valid_referers none blocked 127.0.0.1:8080; # 1、允许url访问 和 *.baidu.com 的网站访问 valid_referers none blocked *.baidu.com; if ($invalid_referer) { # 不符合访问情况，则返回 403 ，也可以重定向到指定的资源 return 403; } } 配置示例： server { listen 80; server_name edo.test.com; root "D:/xxx"; location ~*\.(gif|jpg|jpeg|png|bmp|swf)&amp; { valid_referers none blocked *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf594a2679770f9e2346407abb74aa36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23c04aed350c00e85cfeb4e62de09576/" rel="bookmark">
			IIR和FIR滤波器的区别-公式与思想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从网上查了下FIR和IIR的思想，这一篇介绍的最好理解，收藏记录一下。
一、FIR滤波器(有限脉冲响应)
1.定义:
FIR滤波器是有限长单位冲激响应滤波器，又称为非递归型滤波器，是数字信号处理系统中最基本的元件，它可以在保证任意幅频特性的同时具有严格的线性相频特性，同时其单位抽样响应是有限长的，因而滤波器是稳定的系统。 2.特点:
1.FIR滤波器的最主要的特点是没有反馈回路，稳定性强，故不存在不稳定的问题； 2.FIR具有严格的线性相位，幅度特性随意设置的同时，保证精确的线性相位； 3.FIR设计方式是线性的，硬件容易实现； 4.FIR相对IIR滤波器而言，相同性能指标时，阶次较高，对CPU的性能要去较高。 二、IIR滤波器
定义:
IIR滤波器是无限脉冲响应滤波器，又称递归型滤波器，即结构上带有反馈环路。
特点:
IIR数字滤波器的系统函数可以写成封闭函数的形式，具有反馈回路；
IIR数字滤波器的相位非线性，相位特性不好控制，随截止频率变化而变化，对相位要求较高时，需加相位校准网络；
IIR滤波器有历史的输出参与反馈，同FIR相比在相同阶数时取得更好的滤波效果；
IIR数字滤波器采用递归型结构，由于运算中的舍入处理，使误差不断累积，有时会产生微弱的寄生振荡。
图2 IIR基础原理图
三、公式
四、区别
1、稳定性
由于FIR滤波器没有反馈回路，稳定性要强于IIR。
2、相位特性
FIR 为线性相位延迟，IIR 为非线性相位延迟。
如下图所示为10Hz的方波信号，采样率为1KHz。
图3 方波信号
FIR滤波器后，滤波后效果图下图所示。
图4 FIR滤波效果图
IIR滤波器后，滤波后效果图下图所示。
图5 IIR滤波效果图
通过对比不难发现，IIR滤波器存在非线性相位延迟，校正时需要双向滤波进行校正，复杂不易控制；FIR滤波器为线性延迟，可通过左右平移的方式直接校正，误差小。
3、信号处理速度
FIR的滤波输出取决于当前输入数据和历史输入数据，IIR的滤波输出取决于当前输入数据、历史输入数据和历史输出数据。以基于FPGA硬件的数字滤波器为例，FIR在处理信号时不需等待前一个信号的滤波输出，只需要考虑输入数据便可实时滤波；IIR需要等待上一个信号的滤波输出，存在一定的时间延迟，所以处理速度上没有FIR快。
图6 FIR和IIR滤波对比图
从上面的简单比较可以看到IIR与FIR滤波器各有所长，所以在实际应用时应该从多方面考虑来加以选择。从使用要求上来看，在对相位要求不敏感的场合，如语言通信等，选用IIR较为合适，这样可以充分发挥其经济高效的特点；对于图像信号处理，数据传输等以波形携带信息的系统，则对线性相位要求较高，采用FIR滤波器较好。当然，在实际应用中可能还要考虑更多方面的因素。
ZDS3000/4000系列示波器标配FIR硬件滤波，截止频率从50Hz-200MHz可调，对ADC采样的信号进行实时低通滤波，主要应用于电机、电源测试等场合有效滤出噪声与干扰信号。
图7 FIR滤波界面
图8 FIR噪声滤波效果图
五、 滤波器有四个主要的属性:
**通频带(Pass Band)**–通频带中的数据直接输出到输出时间序列. 为了保证通频带内的数据与原始时程数据一致，滤波器中不应有纹波. 纹波是振幅随频率的微小变化，理想情况下，在这个波段，滤波器的振幅应该恰好为1. 过渡带宽(Transition Width)–根据应用程序的不同，可能希望通过和截止频带之间的转换在频率方面尽可能窄，该方法和滤波器的阶数决定了通带和截止带之间转换发生的速度.
截止频带(Stop Band)–如果滤波器有纹波，截止带也可以包含输出数据. 在某些应用中，纹波的存在可能无关紧要，而在某些特定的场合下，则不能接受纹波的存在.
**群时延(Group Delay/Phase)–**滤波器在输出时间序列中引入了时延，该时延可能是随频率变化的函数. 如前所述，通过前向和后向滤波器(零相位滤波器)可以消除输出时间序列中的时延现象. 在某些应用程，相位也是很重要的，此时就不能再用零相位滤波器了.
FIR方法在从频域到时域的转换中使用了不同的谱窗。一些窗口方法包括:
Chebyshev - 停止带纹波最小，过渡带最宽
Hamming - 过渡区窄，波纹比Hanning小
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23c04aed350c00e85cfeb4e62de09576/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f76204970e5fa91e13b8958f2f4e31dd/" rel="bookmark">
			【Flutter】自动测试探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据flutter官方文档的说明，flutter可以对我们的应用，进行自动化测试，保证我们应用的稳定性和功能的完整性，并且可以快速修复问题。
自动化测试可分为以下几类：
单元测试：测试单一的函数，方法或类
组件测试：测试单一的 widget
集成测试：测试一个完整的应用或者一个应用的大部分功能。
我的整个探索，也是根据这上面3项项进行的。
官方文档地址：
测试 Flutter 应用 - Flutter 中文文档 - Flutter 中文开发者网站 - Flutter学习不同类型的测试以及如何编写它们。https://flutter.cn/docs/testing
一.单元测试 测试单一的函数，方法或类。单元测试的目标是验证逻辑单元在各种条件下的正确性。因为，在很多对日项目，都在追求单元测试覆盖率的前提下，推荐以一个物理文件为单位，编写一组测试。整个过程如下：
step1.新建一个Flutter 项目 fluttertest并编写一个逻辑处理类lib/counter.dart
class Counter { int value = 0; void increment() =&gt; value++; void decrement() =&gt; value--; } step2.项目追加test依赖
flutter pub add test
step3.创建一个单元测试类，在test目录中 counter_test.dart
import 'package:counter_app/counter.dart'; import 'package:test/test.dart'; void main() { group('Counter', () { test('value should start at 0', () { expect(Counter().value, 0); }); test('value should be incremented', () { final counter = Counter(); counter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f76204970e5fa91e13b8958f2f4e31dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a540bf331f1c88434f95b31d78f8a91/" rel="bookmark">
			【引用】引用的概念与基本使用原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习导航 一、引用的基本介绍二、引用的基本特性三、引用的基本原则①引用类型和引用实体类型相同②引用类型和引用实体类型不同 四、引用的基础应用①对标传址操作②作为返回值 一、引用的基本介绍 什么是引用？通俗的讲，引用就是"取别名"，我们看下面的例子：
可以看到，引用并不会开辟新的空间。
二、引用的基本特性 特性①：必须有初始化
特性②：一个变量可以有多个引用
可以给别名取别名，但本质上都是对a的引用
特性③：一旦引用了一个实体，就不能引用其他实体
可以看到，之后b不会再引用实体c，只能对b做赋值修改
三、引用的基本原则 ①引用类型和引用实体类型相同 引用的一个极其重要的基本原则是：对变量实体的读写权限只能缩小不能放大。我们在接下来的例子中来说明这个原则。
引用可以引用常量吗？答案是可以的。但是我们需要加上const来保证读写权限没有被放大：
✪代码分析
我们来分析这段代码我们需要注意到，引用就是给实体取的别名，二者在地址上是一样的，对别名的修改也会改变实体的值，所以我们在取别名的时候就要保证对引用的读写权限没有扩大。就像上面的例子，10是一个只读变量，如果不加上const，那么就意味着可以通过a来修改常变量10，这显示是不行的。
②引用类型和引用实体类型不同 引用类型必须和引用实体是同种类型吗？不一定！怎么理解这个问题呢？我们可以类比我们在C语言中学到的隐式类型转化，我们来分析中间的过程：
int main() { double d = 6.66; int a = d; } 为什么可以将类型为double的变量赋值给类型为int的变量呢？实际上这个赋值过程不是一步到位的，而是存在一个 “中间变量”。这个中间变量接收d的整数部分，最后再把这个中间变量拷贝给a。需要注意的是，这个中间变量具有常属性。引用也是同样的道理：
✪代码分析
a并不是直接引用d，而是引用这个中间变量。由于中间变量具有常属性，所以前面必须加上const修饰避免扩大读写权限。
通过取地址我们可以确认a没有引用d，从而也间接说明了中间临时变量的存在。
四、引用的基础应用 ①对标传址操作 void swap(int&amp; a, int&amp; b) { int tmp = a; a = b; b = tmp; } int main() { int a = 10; int b = 20; swap(a, b); return 0; } 正是由于引用和引用实体存在互相改变的关系，所以我们可以用引用来替代传值操作。拿我们C语言中常写的swap函数举例，这样写起来是不是更爽了呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a540bf331f1c88434f95b31d78f8a91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/398f2e59ea4a582955b0dcb8e98a4be7/" rel="bookmark">
			VSCode像Idea一样为springboot启动设置Environment variables
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期开始使用vsCode进行java工程的开发，因为我的项目需要设置启动环境变量为代码中System.getenv("xxx")使用获取，网是找了一圈没找到，还得自己来找。
在idea中是这样用的
在vsCode是这样用的
先启动一下你的main方法，然后在这里找到你的启动类，点击这个设置按钮
然后会自动弹出右边这个launch.json文件编辑
你只需要按图，在env{}中添加你的启动环境参数就好啦，如下的aaa;bbb
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6528c0023eab679ea501d87f8ce35053/" rel="bookmark">
			Ping和tracert的原理和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Ping协议 1.Ping协议是什么？ Ping协议是一种网络通讯协议，用于测试网络连接质量和测量计算机之间的延迟和丢包率。Ping协议通过向目标计算机发送数据包并等待响应来测试连接的可达性，如果目标计算机接收并回复了数据包，则表示连接正常；否则，连接存在问题。
2.Ping协议的作用？ 2.1测试网络连通性：通过发送和接收数据包测试网络设备之间的连接状态，可以快速定位网络故障和排除故障。
2.2诊断网络故障：通过Ping协议可以获取到网络设备之间的延迟、丢包等信息，从而有助于诊断网络故障。
2.3检测网络性能：对于网络管理员或者网络运营商来说，通过Ping协议可以监测网络的性能，了解网络的质量和可靠性，及时发现和解决问题。
3.Ping协议的工作原理是什么？ 以该图为例：假设PC1已经通过ARP协议获取到PC2的mac地址，此时PC1发送给PC2的ip数据报文可以完成封装。此时PC1pingPC2，报文格式如下
从抓取的报文中可以看到，ping协议是依靠ICMP协议发送出去的。协议类型是type 8 （request报文）
再看一下回包：
回复报文的话协议类型是type 0 （response 报文）
只有回复报文里面包含有响应时间
再看一下PC1中的ping中包含有什么信息：
可以看到回复response报文的IP地址、序列号和TTL以及响应时间（可以判断网络的质量，响应时间越短网络质量越好）
工作原理总结：ping协议依靠ICMP协议中的type 8（request 报文）和type 0（response 报文）来完成源ip地址对目的IP地址的网络连接可达性的检测以及通信质量的检测。
二.tracert协议 1.tracert协议是什么？ tracert是一种用于跟踪网络路径和诊断网络故障的协议。它通常用于Windows和Unix系统中，也称为跟踪路由或网络跟踪工具。当使用tracert协议时，将向目标主机发送一系列的ICMP（Internet控制报文协议）数据包，每个数据包会在 Internet 网络中的每个步骤上被路由器记录，并返回到发送方。因此，tracert协议跟踪并记录了数据包的路径和所经过的所有路由器，可以帮助判断网络故障所在位置。 2.tracert协议的作用？ 2.1 检查网络连接：tracert 可以帮助用户确定从本地计算机到目标计算机的网络连接是否正常，以及网络连接的质量如何，帮助用户快速排查网络问题。
2.2 确定网络传输路径：tracert 可以确定网络数据包在从源计算机到目标计算机的传输路径中经过的节点（路由器），以及每个节点的响应时间。通过这些信息，用户可以优化网络路径，提高传输效率。
2.3 排查网络问题：当网络出现问题时，通过 tracert 协议可以查看网络数据包在传输过程中的具体路径，判断网络故障出现的位置，帮助用户快速排查问题。
3.tracert协议的工作过程？ 以该图为例：每个接口的IP地址都是自身设备的数字，例如：AR1：g0/0/0 ip address 13.1.1.1/24 g0/0/1 ip address 12.1.1.1/24
3.1 PC3发送第一个数据包：当我们PC3上tracert PC4的IP地址时，R1会向34.1.1.4发送UDP的包，第一次发送TTL=1的包，连续发送三个。
3.2 接收第一个路由器的回应：因为其TTL=1，所以此包只能发送到AR1。AR1处理完后会把TTL减为0则不能再继续发送，然后会向PC3返回一个TTL减为0的错误报告消息
3.3 发送第二个数据包：之后PC3再发送TTL=2的UDP或ping包出去。
3.4 接收第二个路由器的回应：此包会发送到第二跳设备。第二跳设备同样返回TTL减为0错误消息，此消息源IP又为第二跳设备的IP的地址，所以我们就能知道第二跳设备的IP地址，依次类推，就能知道整条路径上所有设备的IP地址。
3.5 显示完整的路由路径：一旦Tracert协议到达目标主机，它将显示完整的路由路径，即从本地计算机到目标计算机所经过的所有路由器的IP地址和延迟时间。
总结：Tracert协议通过向目标主机发送一系列数据包并显示每个路由器的回应，确定了数据包的完整路由路径。当我们tracert某个地址时，设备会发送TTL逐次加1的ping包或者UDP包，并且默认情况下每个TTL值发送三个包。
#UDP包是为了有相同开销的负载分担路由时能够从不同路径tracert到目的主机
#华为路由器或者交换机上tracert某个目的地址时，设备不是发送ICMP的ping包，而是发送UDP的包，并且该UDP报文的目的端口号再依次加1
4.tracert协议的报文有什么？ tracert协议使用的是ICMP协议，其报文有以下几个字段：
1. 类型(Type)：报文类型，通常为8，表示请求报文；11表示超时报文。还有目的ip地址回复的type 0 的响应报文。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6528c0023eab679ea501d87f8ce35053/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c55137f114bbc0e4dd09f9f682d91a2/" rel="bookmark">
			Vue成绩案例实现添加、删除、显示无数据、添加日期、总分均分以及数据本地化等功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、成绩案例 ✅✅✅通过本次案例实现添加、删除、显示无数据、添加日期、总分均分以及数据本地化等功能。
准备成绩案例模板，我们需要在这些模板上面进行功能操作。 &lt;template&gt; &lt;div class="score-case"&gt; &lt;div class="table"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;科目&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;th&gt;考试时间&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for="(item,i) in list" :key="item.id"&gt; &lt;td&gt;{{ i+1 }}&lt;/td&gt; &lt;td&gt;{{ item.subject }}&lt;/td&gt; &lt;td class="red"&gt;{{ item.score }}&lt;/td&gt; &lt;td&gt;{{ item.date }}&lt;/td&gt; &lt;td&gt;&lt;a href="#"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;!-- &lt;tbody &gt; &lt;tr&gt; &lt;td colspan="5"&gt; &lt;span class="none"&gt;暂无数据&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; --&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td colspan="5"&gt; &lt;span&gt;总分：321&lt;/span&gt; &lt;span style="margin-left:50px"&gt;平均分：80.25&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class="form"&gt; &lt;div class="form-item"&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c55137f114bbc0e4dd09f9f682d91a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72ac05a98ce6d696505ed92d8a866821/" rel="bookmark">
			【计算机视觉 | 目标检测 | 图像分割】arxiv 计算机视觉关于目标检测和图像分割的学术速递（7 月 17 日论文合集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、检测相关(5篇)1.1 TALL: Thumbnail Layout for Deepfake Video Detection1.2 Cloud Detection in Multispectral Satellite Images Using Support Vector Machines With Quantum Kernels1.3 Multimodal Motion Conditioned Diffusion Model for Skeleton-based Video Anomaly Detection1.4 Brain Tumor Detection using Convolutional Neural Networks with Skip Connections1.5 cOOpD: Reformulating COPD classification on chest CT scans as anomaly detection using contrastive representations 二、分割|语义相关(5篇)2.1 SynTable: A Synthetic Data Generation Pipeline for Unseen Object Amodal Instance Segmentation of Cluttered Tabletop Scenes2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72ac05a98ce6d696505ed92d8a866821/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e57d9c52fd179f4c746442986eaac910/" rel="bookmark">
			(七) 构建应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chapter 7 Building Applications 译：章节7 构建应用 7.1 Using MapServer 译：7.1 使用 MapServer The Minnesota MapServer is an internet web-mapping server which conforms to the OpenGIS Web Map Service specification.
译：Minnesota 地图服务器是一个符合OpenGIS网络地图服务规范的互联网网络地图服务器。
• MapServer 主页
• OpenGIS Web地图服务规范
7.1.1 Basic Usage 译：7.1.1 基础用法 To use PostGIS with MapServer, you need to know how to configure MapServer, which is beyond the scope of this documentation. This section covers specific PostGIS issues and configuration details.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e57d9c52fd179f4c746442986eaac910/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a031ae1b309de0691c0476b358089de4/" rel="bookmark">
			数据可视化——用python绘制简单的折线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言JSON使用 pyecharts 模块绘制折线图下载 pyecharts 模块使用 pyecharts 模块绘制简单的折线图添加配置选项 前言 前面我们已经学习了python的基础语法和面向对象，那么接下来我们将学习python编程语言的过人之处——数据的可视化之折线图。
JSON 说到数据可视化，我们需要先知道什么是JSON。
json是一种轻量级的数据交互格式，可以按照json指定的格式去组织和封装数据json本质上是一个带有特定格式的字符串 JSON的主要功能是：
数据序列化和传输：JSON可以将复杂的数据结构（如对象和数组）转换为字符串形式，以便在网络上进行传输。它跨平台兼容，可以在不同的编程语言中解析和生成。
人类可读的数据格式：JSON采用了简洁的文本格式，易于阅读和理解。它使用键/值对表示数据，并使用大括号（{}）表示对象，方括号（[]）表示数组。
对象表示：JSON支持对象表示，可以通过键/值对形式表示复杂的数据结构。键是字符串，值可以是字符串、数字、布尔值、对象、数组或null。
数组表示：JSON支持数组表示，可以在方括号中包含多个值，用逗号分隔。数组可以嵌套，允许存储多层次的数据结构。
数据交换和存储：JSON广泛用于数据交换和存储。它是许多API和服务的常用数据格式，可以方便地将数据从一个应用程序传输到另一个应用程序。
跨语言支持：JSON可以在不同的编程语言中解析和生成，因此在不同的平台上可以轻松地共享和处理数据。
因为JSON数据类型使用大括号{ }表示对象，方括号[ ]表示数组，而这样的形式在python中与字典和列表的表现方式相同，所以这就很方便。
python 数据与 JSON数据的转换
要进行 python 数据与 JSON 数据的转换，我们需要用到 python 的 json 模块中的 dumps 方法和 loads 方法。
json.dumps(data) 将 python 数据转换为 JSON 数据json.loads(data) 将 JSON 数据转换为 python 数据 import json data = [{'name':'张三','age':18},{'name':'李四','age':20}] json_str = json.dumps(data) print(type(json_str)) result = json.loads(json_str) print(type(result)) 因为 JSON 是一种带有特定格式的字符串，所以他的类型是 str 类型。
使用 pyecharts 模块绘制折线图 下载 pyecharts 模块 我们需要先下载 pyecharts 模块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a031ae1b309de0691c0476b358089de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9cf8f193aa5d061f7717627f6f9b94/" rel="bookmark">
			Python爬虫学习笔记（八）————Phantomjs与Chrome handless
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.Phantomjs
（1）什么是Phantomjs？
（2）如何使用Phantomjs？
2 .Chrome handless
（1）系统要求：
（2）配置：
（3）配置封装：
（4）封装调用：
1.Phantomjs （1）什么是Phantomjs？ ①是一个无界面的浏览器
②支持页面元素查找，js的执行等
③由于不进行css和gui渲染，运行效率要比真实的浏览器要快很多
（2）如何使用Phantomjs？ ①获取PhantomJS.exe文件路径path
②browser = webdriver.PhantomJS(path)
③browser.get(url)
扩展：保存屏幕快照:browser.save_screenshot('baidu.png')
from selenium import webdriver path = 'phantomjs.exe' browser = webdriver.PhantomJS(path) url = 'https://www.baidu.com' browser.get(url) browser.save_screenshot('baidu.png') import time time.sleep(2) input = browser.find_element_by_id('kw') input.send_keys('昆凌') time.sleep(3) browser.save_screenshot('kunling.png') 目前Phantomjs已经停止更新 ，会提醒你使用下面的handless
2 .Chrome handless Chrome-headless 模式， Google 针对 Chrome 浏览器 59版 新增加的一种模式，可以让你不打开UI界面的情况下 使用 Chrome 浏览器，所以运行效果与 Chrome 保持完美一致。
（1）系统要求： Chrome
Unix\Linux 系统需要 chrome &gt;= 59
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e9cf8f193aa5d061f7717627f6f9b94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/859264538188be6796df7fd77b1a5497/" rel="bookmark">
			Offer收割机！Github爆火的Java面试知识全栈小册太香了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几位阿里P9级架构师的大佬总结了Java面试知识点，可以说是涵盖了Java基础、JVM、多线程与高并发、架构、数据库、数据结构与算法、Netty、网络底层知识、日志、微服务、消息中间件等等内容！
这份总结分享给了几位朋友，已经帮助几位朋友共计拿到了7个Offer， 同时也收到了他们“幸福的喜报”！
这个一个关系十分不错的朋友反馈，真的替他高兴，这份资料能够帮助朋友拿到他自己很满意的Offer，我这个做朋友的也很欣慰，他的涨幅算是很高的了，涨幅大概在50％，大家都知道，一般跳槽HR差不多是给出30％的涨幅，能够涨50％真心很不错了！
下面就来分享这份Java面试知识点总结！ JVM总结（文章篇幅有限，里面的小标题就不为大家详细展示打开看了！）
JAVA集合总结
JAVA多线程并发总结
volatile 关键字的作用（变量可见性、禁止重排序）
JAVA基础总结
Spring原理总结
IOC 容器实现
微服务总结
Netty与RPC总结
网络总结
TCP 三次握手/四次挥手
日志总结
Zookeeper总结
Kafka总结
RabbitMQ总结
Hbase总结
Cassandra总结
设计模式总结
负裁均衡总结
数据库总结
TokuDB（Fractal Tree-节点带数据）
一致性算法总结
算法总结
数据结构总结
排序二叉树
加密算法总结
分布式缓存总结
总结 最后祝大家Offer拿到手软，每天无BUG！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057f517b10c3e53cc13d7dc8c82025ae/" rel="bookmark">
			基于单片机的照明灯智能控制器系统（设计报告&#43;电路原理图&#43;程序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：
本文设计了一种基于单片机的照明灯智能控制器系统。该系统通过使用单片机与光照传感器和人体感应器进行通信，实时感知环境光照和人的存在情况，并根据预设的控制策略控制灯光亮度和开关。通过适当的算法和控制逻辑，实现了对照明灯的智能控制。实验结果表明，该系统在节能和舒适性方面具有良好的性能。
1. 引言
随着智能家居技术的快速发展，智能照明系统在住宅和商业场所中得到广泛应用。本文旨在设计一种基于单片机的照明灯智能控制器系统，以满足对照明灯的智能化控制需求。
2. 系统结构
2.1 单片机
本系统采用单片机作为主控制器，负责与光照传感器和人体感应器进行通信，并接收传感器发送的数据。单片机可使用适当的接口和通信协议与传感器进行连接。
2.2 光照传感器
系统使用光照传感器感知环境的光强信息。传感器可以是光敏电阻或光电二极管等。传感器将采集到的光强数据发送给单片机进行处理和控制。
2.3 人体感应器
系统使用人体感应器感知人的存在情况。人体感应器可以是红外传感器或超声波传感器等。传感器将感知到的人的存在情况发送给单片机进行处理和控制。
3. 控制算法和策略
本文设计了一种基于预设的控制算法和策略对照明灯进行智能控制。根据光照传感器和人体感应器的数据，单片机判断当前环境的亮度和人的存在情况，并根据预设的控制策略调整照明灯的亮度和开关。
4. 实验结果分析
通过实验测试，本文设计的照明灯智能控制器系统在节能和舒适性方面取得了满意的结果。实验结果表明，系统能够根据环境光照和人的存在情况智能地调整照明灯的亮度和开关，达到节能和舒适的效果。
5. 结论
本文设计的基于单片机的照明灯智能控制器系统可以实现对照明灯的智能化控制。该系统在智能家居领域有着广阔的应用前景，能够提高照明效果，节约能源。未来可以进行更多的改进，以满足更多应用场景的需求。
关键词: 单片机，照明灯，智能控制器，光照传感器，人体感应器，控制算法与策略
参考资料
基于单片机的照明灯智能控制器系统（设计报告+电路原理图+程序）
https://download.csdn.net/download/woaimx_1314/87930237
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72b64f80d45524612a0bfaac2d98739b/" rel="bookmark">
			尚硅谷学习笔记-Kubeadm安装K8S集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 安装要求 文章目录 一、 安装要求二、 环境准备1. 关闭防火墙功能2.关闭selinux3. 关闭swap4. 服务器规划5. 主机名配置:6. 时间同步配置7.开启转发8. 时间同步 三、 Docker安装1. Docker配置cgroup驱动[所有节点]2. kubernetes源配置[所有节点]3. 安装kubeadm，kubelet和kubectl[所有节点]4. 部署Kubernetes Master [ master节点]5. kubectl命令工具配置[master]6.分别在master和node节点上执行授权操作，不然会出现下面的报错信息:7. node节点加入集群[Node节点]8. 安装网络插件[master] 四. 验证部署应用和日志查询1 验证部署应用2 查询日志:3. 验证集群网络是否正常 2台纯净centos虚拟机,版本为7.x及以上 机器配置 2核2G以上 x2台 服务器网络互通 禁止swap分区 禁止selinux 关闭防火墙 时间同步 二、 环境准备 1. 关闭防火墙功能 systemctl stop firewalld systemctl disable firewalld 2.关闭selinux sed -i 's/enforcing/disabled/' /etc/selinux/config setenforce 0 3. 关闭swap 临时
swapoff -a 永久
sed -ri 's/.*swap.*/#&amp;/' /etc/fstab 关闭swap分区后，可以用free -m命令进行查看
4. 服务器规划 cat &gt; /etc/hosts &lt;&lt; EOF 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72b64f80d45524612a0bfaac2d98739b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4013d3cf24eea8f7e0420c081b0c4151/" rel="bookmark">
			ICCV 2023 | 论文及代码合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，世界三大顶级视觉会议之一ICCV公开了最新录用结果。
根据文件里给出的ID，总共有2160篇论文入选。
我们整理了部分录用论文及其代码合集（持续更新…）
[1] Rethinking Mobile Block for Efficient Attention-based Models
[Code]GitHub - zhangzjn/EMO: [ICCV 2023] Official PyTorch implementation of "Rethinking Mobile Block for Efficient Attention-based Models"
[Area]backbone
[2] IntrinsicNeRF: Learning Intrinsic Neural Radiance Fields for Editable Novel View Synthesis
[Code]https://zju3dv.github.io/intrinsic_nerf/
[Area]NeRF
[3] PoseDiffusion: Solving Pose Estimation via Diffusion-aided Bundle Adjustment
[Code]PoseDiffusion: Solving Pose Estimation via Diffusion-aided Bundle Adjustment
[Area]Diffusion Models
[4] FreeDoM: Training-Free Energy-Guided Conditional Diffusion Model
[Code]GitHub - vvictoryuki/FreeDoM: [ICCV 2023] Official PyTorch implementation for the paper "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4013d3cf24eea8f7e0420c081b0c4151/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc81ebc7ccec077031671169cba8704/" rel="bookmark">
			CSS中的BFC，是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常见定位方案 普通流 默认，从上而下，行内元素水平排列，行满换行，块级元素渲染成一个新行。 浮动 先按普通流位置出现，然后根据浮动方向偏移。 绝对定位 元素具体位置由绝对定位坐标组成。 二、什么是BFC BFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。
BFC 即 Block Formatting Contexts (块级格式化上下文)，属于普通流。
可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。
三、形成BFC的条件 1、浮动元素，float 除 none 以外的值； 2、绝对定位元素，position（absolute，fixed）； 3、display 为以下其中之一的值 inline-block，table-cell，table-caption、flex； 4、overflow 除了 visible 以外的值（hidden，auto，scroll）； 5、body 根元素 四、BFC的特性 1、内部的Box会在垂直方向上一个接一个的放置。 2、垂直方向上的距离由margin决定 3、bfc的区域不会与float的元素区域重叠。 4、计算bfc的高度时，浮动元素也参与计算 5、bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。 五、实例讲解 1、BFC中的盒子对齐 特性的第一条是：内部的Box会在垂直方向上一个接一个的放置。 &lt;template&gt; &lt;div id="app"&gt; &lt;!-- 1、BFC中的盒子对齐 --&gt; &lt;div class="container"&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;div class="box3"&gt;&lt;/div&gt; &lt;div class="box4"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'App', data(){ return { } }, methods:{ } } &lt;/script&gt; &lt;style scoped&gt; /* 1、BFC中的盒子对齐 */ div { height: 20px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffc81ebc7ccec077031671169cba8704/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a909e5590d3c48901c5839d29b18ef8/" rel="bookmark">
			GTID概念介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GTID概念介绍 1 GTID概念介绍2 GTID工作原理3 GTID主从配置4mysql安装4.1node1 主机4.2node2 主机 5测试，是否同步 1 GTID概念介绍 GTID即全局事务ID (global transaction identifier), 其保证为每一个在主上提交的事务在复制集群中可以生成一个唯一的ID。GTID最初由google实现，官方MySQL在5.6才加入该功能。mysql主从结构在一主一从情况下对于GTID来说就没有优势了，而对于2台主以上的结构优势异常明显，可以在数据不丢失的情况下切换新主。使用GTID需要注意: 在构建主从复制之前，在一台将成为主的实例上进行一些操作（如数据清理等），通过GTID复制，这些在主从成立之前的操作也会被复制到从服务器上，引起复制失败。也就是说通过GTID复制都是从最先开始的事务日志开始，即使这些操作在复制之前执行。比如在server1上执行一些drop、delete的清理操作，接着在server2上执行change的操作，会使得server2也进行server1的清理操作。
GTID实际上是由UUID+TID (即transactionId)组成的。其中UUID(即server_uuid) 产生于auto.conf文件(cat /data/mysql/data/auto.cnf)，是一个MySQL实例的唯一标识。TID代表了该实例上已经提交的事务数量，并且随着事务提交单调递增，所以GTID能够保证每个MySQL实例事务的执行（不会重复执行同一个事务，并且会补全没有执行的事务）。GTID在一组复制中，全局唯一。 下面是一个GTID的具体形式 :
mysql&gt; show master status; +------------------+----------+--------------+------------------+------------------------------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+------------------------------------------+ | mysql_bin.000001 | 1150 | | | b35dffb0-fc03-11ec-920f-000c29f6e7cf:1-4 | +------------------+----------+--------------+------------------+------------------------------------------+ 1 row in set (0.01 sec) D:b35dffb0-fc03-11ec-920f-000c29f6e7cf:1-4 UUID:b35dffb0-fc03-11ec-920f-000c29f6e7cf transactionId:1-4 在整个复制架构中GTID 是不变化的,即使在多个连环主从中也不会变。 例如：ServerA ---&gt;ServerB ----&gt;ServerC GTID从在ServerA ,ServerB,ServerC 中都是一样的。 了解了GTID的格式，通过UUID可以知道这个事务在哪个实例上提交的。通过GTID可以极方便的进行复制结构上的故障转移，新主设置，这就很好地解决了下面这个图所展现出来的问题。
如图, Server1(Master)崩溃，根据从上show slave status获得Master_log_File/Read_Master_Log_Pos的值，Server2(Slave)已经跟上了主，Server3(Slave)没有跟上主。这时要是把Server2提升为主，Server3变成Server2的从。这时在Server3上执行change的时候需要做一些计算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a909e5590d3c48901c5839d29b18ef8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/906d6871eecfdc03a5549bf90e10491a/" rel="bookmark">
			【数字IC前端笔试真题精刷（2023）】专栏内容规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 声明：本专栏所收集的数字IC笔试题目均来源于互联网，仅供学习交流使用。如有侵犯您的知识产权，请及时与博主联系，博主将会立即删除相关内容。
重要声明：本篇文章旨在博主为后续文章做整理规划，而非承诺本专栏的最终展现状态，请认真理解！重要声明：本篇文章旨在博主为后续文章做整理规划，而非承诺本专栏的最终展现状态，请认真理解！重要声明：本篇文章旨在博主为后续文章做整理规划，而非承诺本专栏的最终展现状态，请认真理解！ 文章目录 华为联发科芯原大疆芯动AMD艾为乐鑫蔚来燧原 华为 【数字IC前端笔试真题精刷（2023.4.12）】华为 —— 数字IC/硬件-逻辑 联发科 芯原 【数字IC前端笔试真题精刷（2022.8.28）】芯原——数字前端设计/验证 大疆 【数字IC前端笔试真题精刷（2020）】大疆——数字芯片开发工程师A卷【详细解析】【必刷卷】【数字IC前端笔试真题精刷（2020）】大疆——数字芯片开发工程师B卷【数字IC前端笔试真题精刷（2021）】大疆——数字芯片开发工程师A/B卷【数字IC前端笔试真题精刷（2022.8.7）】大疆——数字芯片开发工程师A卷【数字IC前端笔试真题精刷（2022.8.14）】大疆——数字芯片开发工程师B卷 芯动 【数字IC前端笔试真题精刷（2022.7.28）】芯动——数字IC验证工程师（1号卷-验证） AMD 【数字IC前端笔试真题精刷（2022.8.28）】AMD——芯片验证工程师 Design Verification Engineer / 芯片设计工程师 ASIC Design Engineer 艾为 【数字IC前端笔试真题精刷（2022.8.29）】艾为——数字ic设计工程师 乐鑫 蔚来 【数字IC前端笔试真题精刷（2022.7.3）】蔚来——数字IC设计工程师【数字IC前端笔试真题精刷（2022.7.3）】蔚来——数字IC验证工程师 燧原 【数字IC前端笔试真题精刷（2022.7.7）】燧原——AI芯片验证工程师 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ac8698f4a3969d2ce404260b4bd2469/" rel="bookmark">
			C语言学习-关于三个数字排序问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /* 题目：输入三个整数x,y,z，请把这三个数由小到大输出。 程序分析：我们想办法把最小的数放到x上， 先将x与y进行比较，如果x&gt;y则将x与y的值进行交换， 然后再用x与z进行比较，如果x&gt;z则将x与z的值进行交换，这样能使x最小。 */ #include &lt;stdio.h&gt; int main() { int a,b,c,t; printf("请输入三个数字，并用逗号隔开："); scanf("%d,%d,%d,",&amp;a,&amp;b,&amp;c); printf("a=%d,b=%d,c=%d\n",a,b,c); if (a&gt;b) //如果a大，则交换b和a位置。 { t=a; a=b; b=t; } if (a&gt;c) { t=a; a=c; c=t; } if (b&gt;c) { t=b; b=c; c=t; } printf("从小到大排序:%d,%d,%d\n",a,b,c); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34a88d6622f5d5080c6330e1c832f391/" rel="bookmark">
			重学| 面试复习（九）MySql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述下MySql体系架构
网络连接层
客户端连接器 服务层
连接池系统管理和控制工具SQL接口解析器查询优化器缓存 存储引擎层
系统文件层
日志文件配置文件数据文件pid 文件socket 文件 从客户端建立连接到查询执行引擎负责执行 SQL 语句是如何执行的
1.建立连接,通过客户端/服务器通信协议与MySQL建立连接
2.查询缓存,这是MySQL的一个可优化查询的地方，如果开启了查询缓存且在查询缓存过程中查询到完全相同的SQL语句，则将查询结果直接返回给客户端；如果没有开启查询缓存或者没有查询到完全相同的 SQL 语句则会由解析器进行语法语义解析，并生成“解析树”。
3.解析器将客户端发送的SQL进行语法解析，生成"解析树"。预处理器根据一些MySQL规则进一步检查“解析树”是否合法，例如这里将检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义，最后生成新的“解析树”。
4.查询优化器根据“解析树”生成最优的执行计划。MySQL使用很多优化策略生成最优的执行计划，可以分为两类：静态优化（编译时优化）、动态优化（运行时优化）
5.查询执行引擎负责执行 SQL 语句，此时查询执行引擎会根据 SQL 语句中表的存储引擎类型，以及对应的API接口与底层存储引擎缓存或者物理文件的交互，得到查询结果并返回给客户端。若开启用查询缓存，这时会将SQL 语句和结果完整地保存到查询缓存（Cache&amp;Buffer）中，以后若有相同的 SQL 语句执行则直接返回结果。
MySql存储引擎区别对比
事务和外键
InnoDB支持事务和外键，具有安全性和完整性，适合大量insert或update操作MyISAM不支持事务和外键，它提供高速存储和检索，适合大量的select查询操作 锁机制
InnoDB支持行级锁，锁定指定记录。基于索引来加锁实现。MyISAM支持表级锁，锁定整张表。 索引结构
InnoDB使用聚集索引（聚簇索引），索引和记录在一起存储，既缓存索引，也缓存记录。MyISAM使用非聚集索引（非聚簇索引），索引和记录分开。 并发处理能力
MyISAM使用表锁，会导致写操作并发率低，读之间并不阻塞，读写阻塞。InnoDB读写阻塞可以与隔离级别有关，可以采用多版本并发控制（MVCC）来支持高并发 存储文件
InnoDB表对应两个文件，一个.frm表结构文件，一个.ibd数据文件。InnoDB表最大支持64TB；MyISAM表对应三个文件，一个.frm表结构文件，一个MYD表数据文件，一个.MYI索引文件。从MySQL5.0开始默认限制是256TB。 Undo Log，Redo Log和Binlog区别和作用
Undo Log：数据库事务开始之前，会将要修改的记录存放到 Undo 日志里，当事务回滚时或者数据库崩溃时，可以利用 Undo 日志，撤销未提交事务对数据库产生的影响。
Redo Log：指事务中修改的任何数据，将最新的数据备份存储的位置（Redo Log），被称为重做日志。
Binlog是记录所有数据库表结构变更以及表数据修改的二进制日志，不会记SELECT和SHOW这类操作。Binlog日志是以事件形式记录，还包含语句所执行的消耗时间。开启Binlog日志有以下两个最重要的使用场景(1.主从复制 2.数据恢复)
详情PDF/p22
事务是如何提交的？事务提交先写binlog还是redo log？如何保证这两部分的日志做到顺序一致性？
为保证binlog和InnoDB redo日志的一致性MySQL引入二阶段提交2PC
1.准备阶段（Storage Engine（InnoDB） Transaction Prepare Phase）
此时SQL已经成功执行，并生成xid信息及redo和undo的内存日志。然后调用prepare方法完成第一阶段，papare方法实际上什么也没做，将事务状态设为TRX_PREPARED，并将redo log刷磁盘。
2.提交阶段(Storage Engine（InnoDB）Commit Phase)
2.1 记录协调者日志，即Binlog日志。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34a88d6622f5d5080c6330e1c832f391/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88abc1e477fbf60ae9ac6d4dfeba6503/" rel="bookmark">
			重学| 面试复习（七）Dubbo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述Dubbo 的整体架构设计
接口服务层（Service）：该层与业务逻辑相关，根据 provider 和 consumer 的业务设计对应的接口和实现
配置层（Config）：对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心
服务代理层（Proxy）：服务接口透明代理，生成服务的客户端 Stub 和 服务端的 Skeleton，以 ServiceProxy 为中心，扩展接口为 ProxyFactory
服务注册层（Registry）：封装服务地址的注册和发现，以服务 URL 为中心，扩展接口为 RegistryFactory、Registry、RegistryService
路由层（Cluster）：封装多个提供者的路由和负载均衡，并桥接注册中心，以Invoker 为中心，扩展接口为 Cluster、Directory、Router 和 LoadBlancce
监控层（Monitor）：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory、Monitor 和 MonitorService
远程调用层（Protocal）：封装 RPC 调用，以 Invocation 和 Result 为中心，扩展接口为 Protocal、Invoker 和 Exporter
信息交换层（Exchange）：封装请求响应模式，同步转异步。以 Request 和Response 为中心，扩展接口为 Exchanger、ExchangeChannel、ExchangeClient 和 ExchangeServer
网络 传输 层（Transport）：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel、Transporter、Client、Server 和 Codec
数据序列化层（Serialize）：可复用的一些工具，扩展接口为 Serialization、ObjectInput、ObjectOutput 和 ThreadPool
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88abc1e477fbf60ae9ac6d4dfeba6503/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb0a1275e067ccf0f743cb993ce74cd1/" rel="bookmark">
			Docker-compose&#43;Swarm部署mysql&#43;redis&#43;springboot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境安装 docker安装 yum install -y yum-utils yum-config-manager --add-repo https://download.docker.com/linux/centos/docker- ce.repo yum install -y docker-ce docker-ce-cli containerd.io #开机启动 systemctl enable docker #启动 systemctl start docker 测试安装
#查看Docker状态 docker info Swarm安装 #拉取镜像 docker pull swarm 测试安装
#查看版本 docker run --rm swarm -v docker-compose安装 运行以下命令以下载Docker Compose的当前稳定版本：
curl -L "https://github.com/docker/compose/releases/download/1.26.0/docker- compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose 将可执行权限应用于二进制文件
chmod +x /usr/local/bin/docker-compose 添加到环境中
#ln -s ： 软链接 ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose 测试安装
docker-compose --version 拉取镜像 mysql镜像 docker pull mysql:5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb0a1275e067ccf0f743cb993ce74cd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b5ac5418d01b4ed00e7ebc86e51821/" rel="bookmark">
			大文件上传最全方案：秒传、断点续传、分片上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 文件上传是一个老生常谈的话题了，在文件相对比较小的情况下，可以直接把文件转化为字节流上传到服务器，但在文件比较大的情况下，用普通的方式进行上传，这可不是一个好的办法，毕竟很少有人会忍受，当文件上传到一半中断后，继续上传却只能重头开始上传，这种让人不爽的体验。那有没有比较好的上传体验呢，答案有的，就是下边要介绍的几种上传方式
详细教程 秒传 1、什么是秒传 通俗的说，你把要上传的东西上传，服务器会先做MD5校验，如果服务器上有一样的东西，它就直接给你个新地址，其实你下载的都是服务器上的同一个文件，想要不秒传，其实只要让MD5改变，就是对文件本身做一下修改（改名字不行），例如一个文本文件，你多加几个字，MD5就变了，就不会秒传了.
2、本文实现的秒传核心逻辑 a、利用redis的set方法存放文件上传状态，其中key为文件上传的md5，value为是否上传完成的标志位，
b、当标志位true为上传已经完成，此时如果有相同文件上传，则进入秒传逻辑。如果标志位为false，则说明还没上传完成，此时需要在调用set的方法，保存块号文件记录的路径，其中key为上传文件md5加一个固定前缀，value为块号文件记录路径
分片上传 1.什么是分片上传 分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（我们称之为Part）来进行分别上传，上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件。
2.分片上传的场景 1.大文件上传
2.网络环境环境不好，存在需要重传风险的场景
断点续传 1、什么是断点续传 断点续传是在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传或者下载未完成的部分，而没有必要从头开始上传或者下载。本文的断点续传主要是针对断点上传场景。
2、应用场景 断点续传可以看成是分片上传的一个衍生，因此可以使用分片上传的场景，都可以使用断点续传。
3、实现断点续传的核心逻辑 在分片上传的过程中，如果因为系统崩溃或者网络中断等异常因素导致上传中断，这时候客户端需要记录上传的进度。在之后支持再次上传时，可以继续从上次上传中断的地方进行继续上传。
为了避免客户端在上传之后的进度数据被删除而导致重新开始从头上传的问题，服务端也可以提供相应的接口便于客户端对已经上传的分片数据进行查询，从而使客户端知道已经上传的分片数据，从而从下一个分片数据开始继续上传。
4、实现流程步骤 a、方案一，常规步骤
将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；
初始化一个分片上传任务，返回本次分片上传唯一标识；
按照一定的策略（串行或并行）发送各个分片数据块；
发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件。
b、方案二、本文实现的步骤
前端（客户端）需要根据固定大小对文件进行分片，请求后端（服务端）时要带上分片序号和大小
服务端创建conf文件用来记录分块位置，conf文件长度为总分片数，每上传一个分块即向conf文件中写入一个127，那么没上传的位置就是默认的0,已上传的就是Byte.MAX_VALUE 127（这步是实现断点续传和秒传的核心步骤）
服务器按照请求数据中给的分片序号和每片分块大小（分片大小是固定且一样的）算出开始位置，与读取到的文件片段数据，写入文件。
5、分片上传/断点上传代码实现 a、前端采用百度提供的webuploader的插件，进行分片。因本文主要介绍服务端代码实现，webuploader如何进行分片，具体实现可以查看如下链接:
“
http://fex.baidu.com/webuploader/getting-started.html
b、后端用两种方式实现文件写入，一种是用RandomAccessFile，如果对RandomAccessFile不熟悉的朋友，可以查看如下链接:
https://blog.csdn.net/dimudan2015/article/details/81910690
另一种是使用MappedByteBuffer，对MappedByteBuffer不熟悉的朋友，可以查看如下链接进行了解:
https://www.jianshu.com/p/f90866dcbffc
后端进行写入操作的核心代码 a、RandomAccessFile实现方式
@UploadMode(mode = UploadModeEnum.RANDOM_ACCESS) @Slf4j public class RandomAccessUploadStrategy extends SliceUploadTemplate { @Autowired private FilePathUtil filePathUtil; @Value("${upload.chunkSize}") private long defaultChunkSize; @Override public boolean upload(FileUploadRequestDTO param) { RandomAccessFile accessTmpFile = null; try { String uploadDirPath = filePathUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53b5ac5418d01b4ed00e7ebc86e51821/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a63b48323e670721360eecc092e744a4/" rel="bookmark">
			简单介绍GMP调度器模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、调度器的由来 动机：单进程计算机只能一个任务一个任务地处理；CPU浪费
CPU调度器：轮询调度进程A\B\C，时间片轮转调度。这种有切换成本。
多线程的劣势：
1.每个线程创建一个线程，导致频繁切换线程CPU消耗
2.每个进程、线程占用一定内存
N：1的协程关系，线程调度CPU，通过一个调度器切换协程，避免CPU高消耗
go协程：改了内存-&gt;几KB；灵活调度；
GM调度器模型的缺点：
1.创建、销毁、调度G需要频繁地获取锁，造成激烈地锁竞争
2.从M转移到G会造成延迟和额外的系统负载
3.系统调用导致频繁的线程阻塞和取消阻塞操作增加了系统开销
二、GMP模型 新建goroutine会放到localP中，最大256G，不行再放到全局队列中
P数量可以设置，M数量根据程序动态销毁
三、GMP设计 设计策略分为四种：复用线程、利用并行、抢占、全局G队列
复用线程的两个机制：working stealing和hand off
3.1 working stealing机制 M2空闲，所以从M1从偷取协程。（先从localP偷，再从global偷）
3.2 hand off机制 M1阻塞在G1，创建和唤醒一个线程，绑定G1和M1
3.3 利用并行：GOMAXPROCS = CPU核数/2 3.4 新的协程会抢占老协程 四、go func()执行过程 大循环：创建协程-》进入局部队列-》M获取G-》小循环（调度-》执行-》时间片用完）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9312cfc9781d3bb43e0c6348d410f723/" rel="bookmark">
			BERT系列算法解读:（RoBERTa/ALBERT/DistilBERT/Transformer/Hugging Face/NLP/预训练模型/模型蒸馏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BERT（Bidirectional Encoder Representations from Transformers，基于Transformers的双向编码器表示）系列算法在自然语言处理任务中是必不可少的经典模型，当初第一代GPT模型发布的时候，坐了冷板凳，罪魁祸首就是BERT。
有任何问题欢迎在下面留言
本篇文章配套的PPT资源已经上传
目录
1、如何训练BERT
1.1相关背景
1.2 方法1随机遮挡
1.3 方法2连接预测
2 ALBERT
2.1 什么是ALBERT
2.2 第一点大矩阵拆分
2.3 第二点跨层参数共享
2.4 实验中还告诉我们的故事
3 RoBERTa
3.1 如何训练RoBERTa
3.2RoBERTa-wwm
4 DistilBERT
1、如何训练BERT 在图像任务中，针对不同的任务需要设计不同的策略以及不同的网络设计，但是NLP任务真没有五花八门的操作，太多NLP的基础基本都是不需要的。基于2023的今天，大多数的NLP我觉得都比较啰嗦，后续也不可能用到，硕博学位论文那肯定还是会用到的。
1.1相关背景 语言模型，BERT只是其中的一种，后续本人会在CSDN上分析多个语言模型。
17年，Transformer提出来，给了NLP一个新的方法新的架构
18年，谷歌带头做出BERT，他说他有数据，他有算力，用Transformer训练一个大的语言模型出来即BERT模型
19年-20年，出现了很多对于BERT的改进（改进不是说把模型结构改变，把模型做的更大，是想办法把训练效率做的更高一些）
这么说吧，整个NLP领域都是基于Transformer去做的，只不过做的更大而已，这么多年过去了，还是用的17年这个结构，只不过做的更大。
打开Hugging Face的模型页面，按销量排：
（截止2023年7月13日）排前18的模型有10个都是BERT相关的，其中标红的第一个bert-base-uncased是原装的bert。
关于这方面已经不推荐大家去看“很多论文”了，因为论文很多告诉你的都是一个训练过程。
1.2 方法1随机遮挡 方法1：句子中有15%的词汇被随机mask掉交给模型去预测被mask的家伙到底是什么词语的可能性太多了，中文一般是字如果BERT训练的向量好，那分类自然OK 比如我现在有很多文本数据，但是其实并没有一个实际要做的目的。语言模型并不是一个固定的任务，不是做什么分类和回归，也不是做什么NER。就是让模型理解人类的文字，理解人说话的逻辑，这才叫语言模型，并不是一个具体的任务。
现在需要的是培养模型的语言能力，所以需要标签吗？不需要标签，在互联网中有海量的数据，随便去取一个句子，这句话有四个词，我随机mask掉一个词，这是随机选择的，然后让模型去猜这个被mask的词是哪个。
想一想英语考试，考试考的是什么？是你英文的一个学习能力，怎么考察呢？有一些完形填空的任务，有一些选择题，有一些阅读理解题，让你理解这些题在什么前提下？在你英语水平比较高的前提下，你就能做的比较好了
1.3 方法2连接预测 方法2：预测两个句子是否应该连在一起[seq]：两个句子之前的连接符[cls]：表示要做分类的向量 第二种方法没有mask，将两句完整句子用[SEP]连接起来，判断两个句子有没有相关性，做一个二分类
如果模型能够理解语言的含义，自然而然能够预测准，看第二张图：
这两句话就没有连接性，老师上召唤师峡谷给你点名吗？
两种方法都是为了让模型理解我们文字的含义，想想你在英语考试中什么前提能让你在考试中做的好，就是语言能力。
有了语言模型，有一个能理解语言含义的模型之后，就能做一下下游任务，比如：
情感分类NER（Named Entity Recognition，命名实体识别）关系抽取语法检查纠错 仅仅列出一小部分，这些都是一个下游任务，怎么把这些下游任务做好，归根到底就是模型的语言能力非常强，能够很好的理解上下文的含义，拼的就是一个把语言模型做好的前提。
你让一个清华的状元和一个街溜子去做同一件事，清华状元的学习能力强可能就能做得好。
2 ALBERT 2.1 什么是ALBERT A Lite BERT，轻量级的BERT
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9312cfc9781d3bb43e0c6348d410f723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872a8e8663d9acfd7ea125ee46e96c35/" rel="bookmark">
			docker中配置mysql主从分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1、下载mysql安装包
2、mysql 读写分离
3、docker安装三台mysql服务
4、修改主从配置文件
5、重启mysql
6、配置主库
7、配置从库创建同步账户
7.1、进入MySQL01和MySQL02和mysql03服务器新增MySQL用户user 密码root 用于同步账号和密码；
7.2、验证
7.3、进入从数据库停止同步
8、查看主机ip(mysql01)
9、查看主库同步状态
9.1、在主库中查询
9.2、在从库(mysql02,mysql03)中执行如下代码
9.3、启动从库同步
9.4、检查同步状态
9.4.1、错误及处理方法
1、防火墙是否关闭
shutdown -r now #重启系统
2、停止同步
3、检查主从库中的同步数据是否和主库保持一致
4、查看输入错误日志信息
5、重新同步
6、检查同步状态
7、检测是否完成
前言 MySQL读写分离是将数据库的读操作和写操作分配到不同的数据库服务器上的一种架构设计。它的主要意义包括以下几个方面：
提高性能：通过将读操作分散到多个从数据库上，可以分担主数据库的负载，提高整体的数据库性能和吞吐量。读写分离架构特别适合读多写少的应用场景。
优化用户体验：将读操作分流到从数据库上，可以减少主数据库的并发访问压力，提高响应速度和用户访问体验。对于读密集型应用，如电商网站或新闻门户，读写分离可以优化用户访问速度。
提高系统可靠性：通过主从复制的方式，从数据库实时复制主数据库的数据，起到冗余备份的作用。当主数据库发生故障或宕机时，可以快速切换到从数据库，确保系统的持续可用性和故障恢复能力。
方便维护和升级：通过读写分离，可以只对从数据库进行维护和升级操作，而不影响主数据库的正常使用。这样可以减少对整个系统的停机时间和维护成本，提高系统的可维护性。
节约成本：通过合理配置硬件资源，可以在从数据库上使用较低配置的服务器，减少硬件成本。主数据库可以独立配置高性能的服务器，提高写操作的处理能力。
综上所述，MySQL读写分离可以提升数据库性能、优化用户体验、提高系统可靠性、方便维护和降低成本。在高并发的应用场景下，读写分离是一种常用的架构设计方案。
1、下载mysql安装包 从其他可以连接外网的docker 环境中pull mysql：5.7
然后打包好拷贝到本机
2、mysql 读写分离 删除已经有的mysql容器，准备三台mysql服务器
配置要求：mysql01 为主 mysql02 、mysql03 为从
关闭三台mysql服务器防火墙
vi /etc/selinux/config #SELINUX=enforcing #注释掉 #SELINUXTYPE=targeted #注释掉 SELINUX=disabled #增加 :wq #保存，关闭。 shutdown -r now #重启系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/872a8e8663d9acfd7ea125ee46e96c35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76170e30c51e509616473f2282c3f888/" rel="bookmark">
			mmcv报错No module named ‘mmcv._ext‘及mmcv-full简单有效的安装方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用MM的一系列框架时候必不可少的是安装mmcv，其中中间有一些小坑需要我们注意下。
否则可能会出现
1.AssertionError: MMCV==1.3.5 is used but incompatible. Please install mmcv&gt;=(1, 3, 13, 0, 0, 0), &lt;=(1, 5, 0, 0, 0, 0).
2.No module named 'mmcv._ext'
3.卡到Building wheels for collected packages: mmcv-full
Building wheel for mmcv-full (setup.py) ... |
mmcv报错及简单有效安装mmcv-full No module named 'mmcv._ext' 是因为直接pip安装mmcv导致的，需要安装完整版的mmcv-full。
如果直接pip安装mmcv-full，可以看到安装包是tar.gz结尾的，安装过程可能会卡到这里
Building wheels for collected packages: mmcv-full Building wheel for mmcv-full (setup.py) ... | 网上找到的有的whl安装包链接又是老的，版本不够高会报错
AssertionError: MMCV==1.3.5 is used but incompatible. Please install mmcv&gt;=(1, 3, 13, 0, 0, 0), &lt;=(1, 5, 0, 0, 0, 0).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76170e30c51e509616473f2282c3f888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81eff38f77caa6432c6bf49326dabbf6/" rel="bookmark">
			传奇开服技术教程传奇GOM引擎写入方法通杀开服请注意
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的新手小白GM或者是刚开服的小白遇到过这样的问题，不知道怎么处理，网上查解决方法也没用，只能去找技术来解决，今天我把我的方法告诉大家，大家有遇到什么不懂的问题随时留言私信我
GOM引擎写入方法通杀，开服请注意
利用行会招人NPC的公告写入一个元宝代码 然后配合一个软件来调用这段元宝代码！
或者利用二级密码NPC的写入方式刷出元宝
如果不配合这个软件 直接调用QF文本的元宝代码，是没任何反映的！
想必很多人都无法突破这里！
就是因为这些NPC的写入功能，而导致了开区的版本出现莫名的刷元宝 装备等
而众多私服里，基本都存在行会招募NPC！所以说能刷很多服 也不是夸大其词！
我记得以前有一个版主也发过一个置顶帖子，教GM如何修复这个漏洞！
不过没几天就被这个版主删除了帖子！
今天从新整理教GM如何修复这个BUG？把利益降到最低点！
第一修复方法：把行会招募NPC的管理选项去掉，就是只可竞价，不可修改公告！
第二修复方法：删掉没用的二级密码NPC
第三修复方法：直接屏蔽掉一些敏感字符！
如何屏蔽字符？ 在M2Server上点查看-列表信息-其他设置-用户过滤字符列表-添加（把@添加进去就OK）最后点保存就好了！
以上就是今天的分享了，感谢您的阅读，若是想要了解更多传奇技术干货，关注我主页更精彩
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fb21cc70c9e15340ca173a10fe8c21f/" rel="bookmark">
			40岁的程序员失业了，如何自救？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、我作为“大龄”IT人，身边的同学同事朋友现状如何？
同学、前同事、一些朋友，大部分都过了35岁了。
1、前华为同事，之前部门业务没怎么增长，领导还是早些年混上去那几个，有两三个都过40了，手下则是换了一波又一波。出去的，有些转到互联网大厂做一线开发，但是卷的严重，上升通道很窄，不知能做到什么时候。有到OPPO、[大疆]这样的硬件厂商的，跟华为业务上比较类似，加班甚至比华为还猛，待遇也不错。出走的，也有到小公司的当CTO或技术主管的，压力也很大，大环境不佳，风雨飘摇。也有几个回了三四线老家，之前就有一个北航的哥们回了长沙，具体做什么没再细问；一个[西电]的女孩子，也30出头了，看留深无望，卷的厉害，回了河南老家，后来听说进了研究所。这些人基本上还在IT领域，但是能持续多久，谁也不知道。
2、同学A，算混的比较好的，本科毕业后上了清华硕士，AI相关专业。毕业后对口工作难找，进入航天院，月薪几千块，好在拿了[北京户口]。父母资助，早早在北京买了第一套房。没多久离开，BAT兜了一圈，前两年升了P8同等级别，股票赶在大跌之前卖了几百万，一线城市两套房。按他的话说，现在如果离开，外面匹配的坑位极少，而且几乎接不住这样的待遇，职业上也有焦虑。但是，这样的人如果心态放平一些，要躺平是完全可以躺平的。
3、同学D，早年创业，没做起来，打工没热情但又不得不搬砖。错过了大厂历练机会，虽然技术能力不错，但是职业履历一般，后劲不足。房子没解决，又赶上[房价暴涨]的几年，面临很大的风险。几乎是得回老家的一族，但是又很难回去，没有找到出路。
4、同学E，小厂兜兜转转几年后，进了外企，虽待遇一般，但另一半待遇OK，房子问题解决。喜欢音乐，平常做点效果器之类的，卖到国外，收入比上班好。顺比较顺利度过中年危机的一家。
5、朋友F，卖了房回老家发展，回家做一些小生意了，后来发家致富，当然也有运气好，赌对了赛道和行情。
7、朋友G，跟别人合伙创业，做技术合伙人，目前只领基本生活费的。但公司融资境况堪忧，不知道什么时候就散伙了。[技术合伙人]一般坑多，听着好听，实际上，很可能给CEO做慈善。
10、朋友J，深圳土著程序员，生活压力不大，自己接一些私活，赚点除收租之外的零花钱的。
8、前同事H，有几个仍然在职场上飘着，打一枪换一个地方，月薪从之前四五万，降到两万多的也有。但现在的环境下，有稳定收入也算不错了。
9、同学B，大概工作两三年之后去了某BAT企业，干了两年多，不想在大厂卷而且受制于人，到初创公司当CTO，title说出来有点唬人，其实就三五个人的技术团队，从0开始摸索。又干了两三年，公司没赚到钱，撑不下去，解散了。创业公司，你懂得的，工作有些年头的人都懂。真正靠谱的创业公司，不到1%。一般人，真没有这种火眼金睛，去识别能成[独角兽])并发展上市的公司。后来兜兜转转又去了几家小公司，都没呆多久，转眼就奔四了，房子和家庭都没有着落，而且每次换工作感觉越来越吃力。按他的话，可能没多久就要回老家了。
10、前同事I，在小公司做[技术总监]和CTO。目前做这角色的，没有一个混得安心的，公司前景不明，有的已经开始拖欠工资了。
11、朋友K，转行跟别人一起搞融资的，搞了几年，没听到进一步的消息。
12、同学C，毕业就到某知名通信公司（TOP2），干了很多年，后身体和家庭原因，抗不下去了，换到一家WLB的互联网大厂干了几年（国内还真有，没那么卷的，比如网易，但是门槛也高）。后到一家小公司，技术水平几乎是最高的那一类。凭着在大厂十几年的高绩效表现，趁着房价没那么高的时候，买了两套房。算比较顺利的实现了中产。但是要养家庭，他压力也挺大，不敢失业，更不敢创业。
13、前同事L，转行做产品经理的，虽然转得早，但到了35岁这个坎，一样被社会吊打。产品经理、运营经理一样受35岁困扰，不止是程序员有这个焦虑。
14、还有更多从同事同学口中得知的他们的身边人，早早离开一线城市、离开大厂、甚至离开IT行业的。有的因为定居的问题，有的因为职场瓶颈，有的因为有其他出路或者更想做的事，还有的就是单纯不喜欢。有的三五年，有的十年左右。
二、35岁以上程序员有哪些出路？
1、[技术管理]
这个对人软性的能力要求比较高。也看机遇，不是技术能力上去了，就可以升管理层。得看有没有机会，有没有坑。另外，得看你和领导的脾性、风格之类的，是否对的上。还得看一个人的[沟通协调能力]、规划能力等。比较综合。
国内早些年的环境是“[学而优则仕]”，也就是你技术OK了，就把人往管理上拉。但是有些人就喜欢做技术、写代码，并不喜欢也不擅长管人。所以，发展了一阶段，大家也看明白了，得综合去看个人的意愿和潜质。
这条路线也并不好走，人际资源、影响力和个人能力一样重要，不是所有的人都能走到顶端，但是大部分努力的人都不会太差。
走管理也不是就高枕无忧了，做了几年纯管理，可能技术就退化了。这个时候，如果公司情况不妙，出去再找个管理的岗位并不容易，因为坑少。很多公司倾向于从内部去选拔，因为知根知底，业务也更熟悉，同时价值观有比较匹配。空降领导的失败率是很高的，一方面，新公司老板对他的期望高；另一方面，价值观能不能匹配得呆一段时间才能体现出来；再者，得让老员工服你，这个很难。
2、[技术专家]
依靠专业实力往上升成为领域专家、[架构师]等，这条职业道路窄且深，需要持续不断的学习新技能，精进老技能，如果不是天赋异禀或比较热爱，大部分人到了一定的程度都会选择往对能力宽度、综合度要求较高的职业方向发展。
在国内，技术能力很多时候指的开发能力。国内IT企业很多都是应用层面的开发，很难有很深的技术积累。在5年内经验积累有作用，超过十年就未必。真正做华为之类的基础研发的很少，基本上只有大公司才养得起这样的团队。包括算法也是一样，听上去好像挺高深，但是目前国内的算法开发，基本上也是算法库的调用为主，企业层面的真正的基础算法研究极少。
所以，这条路也很难。不可替代的人，可能不到1%，而且还只是暂时性的不可替代。
3、项目经理
这个更多是沟通协调能力，未必需要太多的技术积累，所以护城河也不深。工作几年的人也可以做。但要做的好也不容易，需要知识面比较广，而且得能摆平各领域的人。 待遇方面整体没有前两个高。但有机会往高层走。
4、产品经理
研发是要弄明白怎么做和实际落地，产品经理要弄明白做什么、为什么要做和做成什么样。对产品要有足够的认知，广义上讲，像马化腾、[张小龙]和雷军，某种意义上讲也是产品经理。但是也有年龄焦虑。毕竟，年轻人更懂年轻人。
5、上岸（考公考编）
这个也是很现实的一条路，如果厌烦了996，厌烦了大城市，可以考虑这条路，需要尽早准备。不过这几年特别火爆，也是卷了惊人 。这个就不多讲了，网上一大堆。
6、做培训
这也是一条路。到了一定年龄，有一些经验，最好还有一些大厂背书，做做培训，兼职也好，线上也行，也能挣点钱。有的适合做的，可能就全职做了。 都年龄要求也就不苛刻了，甚至年长的、有经验的还更有优势。
7、做咨询或顾问
这也是经验的一种变现方式了，以组织的形式也好，以个人的形式也好，会越来越多。包括知乎、[知识星球]等线上咨询等，也是一种方式。 跟年龄就没有太大关系了。
8、转行
到了一定年纪，特别是35、40岁以上，能不能干IT，适不适合吃这碗饭，大家早已很清楚了。有的可能早早就转行了，这个就各显神通了。
技术就是技术，本质上是工具，可以带来收益，没错，但也不一定就非得把它和能力强挂钩。有的人就是当老板的料，就没必要非把他摁着写代码。
题外话 在这个大数据的时代，你要想走在潮流前端，就必须要学习前沿有用的知识。而今人工智能和数据分析爆发，python就是一颗冉冉升起的新星，学好 Python 不论是就业还是做副业赚钱都不错。
全球知名TIOBE编程语言社区发布了2023年最新的编程语言排行榜。我们一起来看看
口说无凭，请大家继续来看一下Python的招聘数据。
据职友集数据显示，分别来自50家招聘网站，与Python有关的招聘职位薪资待遇如下：
那么为什么各地对Python工程师需求这么大？工资给的这么高？因为Python程序员太少啦！很多高校并未开设Python课程，因此市场上Python开发人才供小于求。很多企业为了争夺有限的Python程序员，不得不给出极其丰厚的薪资待遇，现在初级Python开发工程师的起薪一般在10-20K！
目前来学的人群分为以下几类：
第一类：入行编程新手：大学刚毕业或者其他行业转岗，想从事编程开发的工作，目前认为Python比较火，想入行；Python简单易学，非常适合新手入门。
第二类：Linux系统运维人员：Linux运维以繁杂著称，对人员系统掌握知识的能力要求非常高，那么也就需要一个编程语言能解决自动化的问题，Python开发运维工作是首选，Python运维工资的薪资普遍比Linux运维人员的工资高。
第三类：做数据分析或者人工智能：不管是常见的大数据分析或者一般的金融分析、科学分析都比较大程度的应用了数据分析，人工智能的一些常见应用也使用了Python的一些技术。
第四类：在职程序员转Python开发：平常只关注div+css这些页面技术，很多时候其实需要与后端开发人员进行交互的，现在有很多Java程序在转到Python语言，他们都被Python代码的优美和开发效率所折服。
第五类：其他：一些工程师以前在做很多SEO优化的时候，苦于不会编程，一些程序上面的问题，得不到解决，只能做做简单的页面优化。现在学会Python之后，你和我一样都可以编写一些查询收录，排名，自动生成网络地图的程序，解决棘手的SEO问题。
当然，这里总结的只是常见的一些情况，关于职业和岗位。
Python的优点：
易于学习：简单、易学、对新手极度友好。免费开源：Python的所有内容都是免费开源的，不需要花一分钱就可以免费使用Python，并且可以自由地发布这个软件的拷贝、阅读其源代码、对其做改动、把其一部分用于新的自由软件中；可扩展：Python除了使用Python本身编写外，还可以混合使用像C语言、Java语言等编写； 对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑的。
一方面是学习时间相对较短，学习内容更全面更集中。
二方面是可以找到适合自己的学习方案
包括：Python激活码+安装包、Python web开发，Python爬虫，Python数据分析，人工智能、机器学习等习教程。带你从零基础系统性的学好Python！
👉Python学习路线汇总👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fb21cc70c9e15340ca173a10fe8c21f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26d3d62870153921f4b2308069b997ee/" rel="bookmark">
			吸烟(抽烟)检测和识别1：吸烟(抽烟)数据集说明(含下载链接)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		吸烟(抽烟)检测和识别1：吸烟(抽烟)数据集说明(含下载链接) 目录
吸烟(抽烟)检测和识别1：吸烟(抽烟)数据集说明(含下载链接)
1. 前言
2. 吸烟(抽烟)类别说明
3. 吸烟(抽烟)分类数据集
（1）smoking-dataset
（2）smoking-video
4. 吸烟(抽烟)分类数据集下载
5. Pytorch实现吸烟(抽烟)检测和识别
6. Android实现吸烟(抽烟)检测和识别
1. 前言 这是项目《吸烟(抽烟)检测和识别》系列文章之《吸烟(抽烟)数据集说明(含下载链接)》；网上有很多吸烟(抽烟)数据集的数据，在CSDN下载那一搜一大堆，但下载下来，真是不尽人意，质量参差不齐，说多了都是泪呀，都是血泪史的教训。本篇，我们将分享一个我自己项目整合的吸烟(抽烟)分类数据集；smoking-dataset和smoking-video，总共15000+张图片。数据质量较高，可用于深度学习吸烟(抽烟)识别项目的分类模型算法开发。
【尊重原则，转载请注明出处】 https://blog.csdn.net/guyuealian/article/details/130337263
更多项目《吸烟(抽烟)检测和识别》系列文章请参考：
吸烟(抽烟)检测和识别1：吸烟(抽烟)数据集说明(含下载链接): https://blog.csdn.net/guyuealian/article/details/130337263吸烟(抽烟)检测和识别2：Pytorch实现吸烟(抽烟)检测和识别(含吸烟(抽烟)数据集和训练代码)：https://blog.csdn.net/guyuealian/article/details/131521338吸烟(抽烟)检测和识别3：Android实现吸烟(抽烟)检测和识别(含源码，可实时检测)：https://blog.csdn.net/guyuealian/article/details/131521347吸烟(抽烟)检测和识别4：C++实现吸烟(抽烟)检测和识别(含源码，可实时检测)：https://blog.csdn.net/guyuealian/article/details/131521352 2. 吸烟(抽烟)类别说明 在吸烟(抽烟)检测识别算法开发中，我们需要定义吸烟(抽烟)的行为类别；项目将吸烟(抽烟)状态分为两种情况，分别为：smoking(吸烟)，notsmokint(未吸烟)，为了便于大家理解，下面给出这吸烟(抽烟)的行为类别定义：
人体检测框：人体检测框是通过人体(行人)检测算法预测和定位的人体区域，每个人体用一个矩形框表示吸烟检测区：将人体检测框的左上角位置保存不变，右下角的高度(Height)缩短三分之一左右，得到吸烟检测区吸烟和未吸烟：项目定义，若吸烟检测区存在烟只，则判断为smoking(吸烟)行为；反之，若吸烟检测区不存在烟只，则判断为notsmoking(未吸烟)行为。由于吸烟的行为状态不一，环境复杂多样，尽管这样的吸烟行为定义不全面，但基本可以覆盖业务的大部分场景需求。 notsmoking：在吸烟检测区内无烟只，则定义为无吸烟行为（notsmoking）；若主体存在吸烟行为，但烟只不在吸烟检测区内，受算法局限性，这时依然定义无吸烟（notsmoking）smoking：在吸烟检测区内有烟只，则定义为有吸烟行为（smoking）；受算法局限性，只要吸烟区内存在烟只，不管是否吸烟，都定义为有吸烟行为（smoking） 代码实现：定义函数get_smoking_roi()用于获得吸烟检测区，基于该方法，项目可以制作吸烟(抽烟)的分类数据集。
# -*-coding: utf-8 -*- import numpy as np from pybaseutils import image_utils import cv2 def get_smoking_roi(xyxy, scale=(), cut=0.3): """ 获得吸烟检测区 :param xyxy: shape is (num-boxes,4),box is (xmin,ymin,xmax,ymax) :param scale: boxes缩放大小 :param cut: 裁剪比例 :return: """ up_boxes = [] for i in range(len(xyxy)): xmin, ymin, xmax, ymax = xyxy[i] w, h = (xmax - xmin), (ymax - ymin) ymax = max(ymin + h * cut, ymin + w) up_boxes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26d3d62870153921f4b2308069b997ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b2c2e4669ed6ab4760ed5b7c4bc5383/" rel="bookmark">
			Redis7分布式缓存之高阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis7分布式缓存之高阶 一. Redis单线程 VS 多线程(入门篇)1.Redis为什么选择单线程？① 是什么② ``厘清一个事实我们通常说Redis是单线程究竟何意?``③ Redis3.x单线程时代但性能依旧很快的主要原因④`Redis 4.0`之前一直采用单线程的主要原因有以下三个 2. `既然单线程这么好，为什么逐渐又加入了多线程特性?`① 单线程也有单线程的苦恼② 如何解决案例 3. redis6/7的多线程特性和IO多路复用`入门篇`① 对于Redis`主要的性能瓶颈是内存或者网络带宽而并非 CPU。`② 最后Redis的瓶颈可以初步定为: 网络IOⅠ `redis6/7，真正多线程登场`Ⅱ `主线程和IO线程是怎么协作完成请求处理的-精讲版` 4. Jnix网终编程中的五种IO模型① `lO multiplexing - lO多路复用`Ⅰ FileDescriptorⅡ 首次浅谈I0多路复用l0多路复用是什么Ⅲ `场景体验，说人话引出epoll`场景解析IO多路复用模型，简单明了版理解 Ⅳ 小总结Ⅴ redis为什么这么快 5. 简单说明：`Redis工作线程是单线程的；但是，整个Redis来说，是多线程的`① 主线程和IO线程是怎么协作完成请求处理的-精简版② 结论 6. Redis7默认是否开启了多线程? 二. Bigkey1. Morekey案例① 大批量往redis里面插入2000W测试数据key② 某快递巨头真实生产案例新闻keys* 你试试100W花费多少秒遍历查询`生产上限制keys */flushdb/flushall等危险命令以防止误删误用？` ③ `不用keys *避免卡顿，那该用什么`Scan 命令用于迭代数据库中的数据库键 2. BigKey案例① 多大算big参考《阿里云Redis开发规范》string和二级结构 ② 有那些危害③ 如何产生④ 如何发现redis-cli --bigkeysMEMORY USAGE 键 ⑤ 如何删除Ⅰ StringⅡ hashⅢ listⅣ setⅤ zset 3. Bigkey生产调优 三、缓存双写一致性之更新策略探讨1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b2c2e4669ed6ab4760ed5b7c4bc5383/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df1bc7a0aeb62ce831972336970f1662/" rel="bookmark">
			基于的python的文件判断、处理，地址存表的模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import pandas as pd import numpy as np data = [['E:/桌面/数据', ".csv",1], ['K:/文件名', ".csv", 1], ['E:/桌面/数据2', ".csv", 1]] df = pd.DataFrame(data, columns=['address',"format", 'times']) df 做表
df.to_csv("E:/桌面/地址.csv",index=True) 保存
def address(address): flie_a = pd.read_csv("E:/桌面/地址.csv") flie_a.drop(columns='Unnamed: 0', axis=1, inplace=True) # print(flie) row = flie_a.loc[flie_a["address"] == address] index = (row.index).tolist() if address == "调用事件": flie_s = flie_a.groupby("address").max().sort_values("times", ascending=False) return flie_s.index,"无" else: pass if os.path.exists(address) == True: # print("可以找到文件") name = os.path.split(address) f = name[1].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df1bc7a0aeb62ce831972336970f1662/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/157ccb69ff6640f4889b3d7ac0a60587/" rel="bookmark">
			AltiumDesigner中PCB无法选中元器件的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AltiumDesigner中PCB无法选中元器件的解决方案，供大家参考！
AltiumDesigner中PCB元器件出现黑色底色而且无法显示。
第一种方法，我们可以直接按shift+C组合键清除筛选，如下图所示
第二种方法，点击菜单上的清除过滤器按钮也可以解除，如下图所示
第三种方法，点击pcb环境编辑器右下角的clear即可，如下图所示
通过上面三种方式解除筛选过滤器后，元器件就都可以选中了，如下图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/218cde32823d60bdf63f91b79b9d33a1/" rel="bookmark">
			Altium designer自动布线设置GND或其他网络不布线的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，在导航栏里面找到设计栏，找到类选项打开
2，在Net Classes选项下 右击鼠标，找到添加类选项，会创建一个New Class。
3，设置好需要布线的网络，以及不需要布线的网络，如下图
4，找到自动布线菜单栏下的网络类，点击进去如下图，选择好新建的类，然后确定。
5，等到布线完成即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12409b6db52d9ae07fab959ba005d7b9/" rel="bookmark">
			Altium Designer编辑PCB时，器件跑出可视界面外的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人在使用AD等进行PCB设计的时候，由于制作封装问题或者是其他操作问题，会遇到在PCB界面下某一个或者几个封装超出软件显示范围，不论如何移动和放大缩小，都无法显示出来，也就没法选中和编辑。下面就讲讲如何解决这个问题。
一个封装超出界外，不论如何也无法显示出来。可以看到网络连线，这表示有元件在可视范围外。
第一招：全局移动。
这招比较适用于所有封装没有被锁定的情况。首先按Ctrl+A组合键，全选。然后点工具栏上的移动选择按钮（快捷键E-M-S），此时鼠标变成一个十字。
然后鼠标在一个合适的位置（靠近超出的那一个边界）点一下，然后鼠标向超出边界相反的方向移动，可以移动较大的距离，直到消失在边界外的封装出现。如下图
这样就解决问题了。但是你会发现图上有一个封装没有跟着鼠标移动而移动，还是停留在原来的位置，这样就破坏了原来的布局。这是因为这个封装是锁定的，可以在移动之前先双击这个封装然后取消锁定就可以移动了。
第二招：单独移动
如前所述，如果有锁定的封装，要先打开锁定才能移动，但是锁定的封装比较多的话，将会比较麻烦（当然可以使用全局批量解锁），如果不想改变锁定状态的话。就需要如下方法来单独将跑丢了的封装找回来。
首先要知道是哪个元件跑丢了，比如我们的例子里是U3。然后在工具栏里的第二个下拉菜单里面找到U3，并点击。
这时就会发现，全部页面变成灰黑色，除了我们选中的U3，当然我们是看不到的。这时候再使用Ctrl+A全选，然后重复第一招里面的移动，就会把U3给移到可见范围内。最后再点清除过滤器（SHIFT+C）就可以了
第三招：反向选择
在编辑菜单栏下，“选中”→“区域外部”，快捷键“SO”
这时候鼠标会变成一个十字光标，只需要在板子画一个区域，AD软件会自动选中你所画区域外部的所有对象。
选中之后，选择区域内排列器件，快捷键“IL”,在你想要放置的地方画一个区域，前面所选中的内容就会排列在区域内。这样就可以将板框外的东西快速的拉回来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ff4890ed62527e564ac4e69b138520/" rel="bookmark">
			聚水潭对接打通金蝶云星空销售出库查询接口与销售出库新增接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚水潭对接打通金蝶云星空销售出库查询接口与销售出库新增接口 接入系统：聚水潭 聚水潭是SaaS协同平台、电商ERP软件。聚水潭成立于2014年，创始人兼CEO骆海东拥有近三十年传统及电商ERP的研发和实施部署经验。聚水潭创建之初，以电商SaaSERP切入市场，凭借出色的产品和服务，快速获得市场的肯定。
对接目标平台:金蝶云星空 金蝶K/3Cloud（金蝶云星空）是移动互联网时代的新型ERP，是基于WEB2.0与云技术的新时代企业管理服务平台。金蝶K/3Cloud围绕着“生态、人人、体验”，旨在帮助企业打造面向新时代的生态互联与协同平台，围绕生态中的每个角色，提供随手可得的云服务，最终实现敏捷协同，智慧运营的企业运营新境界。整个产品采用SOA架构，完全基于BOS平台组建而成，业务架构上贯穿流程驱动与角色驱动思想，结合中国管理模式与中国管理实践积累，精细化支持企业财务管理、供应链管理、生产管理、供应链协同管理、人力资源管理等核心应用。技术架构上该产品采用平台化构建，支持跨数据库应用，支持本地部署、私有云部署与公有云部署三种部署方式，同时还在公有云上开放中国第一款基于ERP的协同开发云平台。任何一家使用金蝶K/3Cloud产品的企业，其拥有的是包含金蝶在内的众多基于同一个平台提供服务的IT服务伙伴。
系统对接接口配置 数据集成平台对应的配置聚水潭与金蝶云星空的对接只要三步就能完成两个系统之间的数据对接。第一步根据聚水潭的接口参数要求记录在轻易云集成平台。第二步配置聚水潭与金蝶云星空之间的字段对应关系（更多方案可借鉴轻易云数据集成社区论坛中找到相关方案信息）第三步完成方案的检查参数设置：传递时间、重试次数、是否启动、前置条件等上线运行。
聚水潭接口明细 接口：/open/orders/out/simple/query接口名称：销售出库查询接口方法：POST 请求参数 字段名称类型描述hop_id店铺编码string店铺编号is_offline_shopshop_id为0且is_offline_shop为true查询线下店铺单据stringshop_id为0且is_offline_shop为true查询线下店铺单据status单据状态string单据状态: WaitConfirm=待出库; Confirmed=已出库; Cancelled=作废modified_begin修改开始时间string修改起始时间，和结束时间必须同时存在，时间间隔不能超过七天，与线上单号不能同时为空modified_end修改结束时间string修改结束时间，和起始时间必须同时存在，时间间隔不能超过七天，与线上单号不能同时为空so_ids线上单号string指定线上订单号，和时间段不能同时为空page_index页数string第几页，从第一页开始，默认1page_size每页行数string每页多少条，默认30，最大50 响应参数 字段名称类型描述co_id公司编号string公司编号shop_id店铺编号string店铺编号io_id出库单号string出库单号o_id内部单号string内部单号so_id线上单号string线上单号created创建时间string创建时间modified修改时间string修改时间status状态string状态;Archive:归档,WaitConfirm:待出库,Confirmed:已出库,Cancelled:取消,Delete:作废,OuterConfirming:外部发货中order_type单据类型string单据类型invoice_title发票抬头string发票抬头shop_buyer_id买家帐号string买家帐号receiver_country国家string国家receiver_state省string省receiver_city市string市receiver_district区string区receiver_town街道string街道receiver_address地址string地址receiver_name收件人姓名string收件人姓名receiver_phone收件人手机string收件人手机receiver_mobile收件人电话string收件人电话buyer_message买家留言string买家留言remark备注string备注is_cod是否货到付款string是否货到付款pay_amount应付金额string应付金额l_id物流单号string物流单号io_date出库时间string出库时间lc_id快递公司编码string快递公司编码stock_enabled是否启用库存管理string是否启用库存管理drp_co_id_from分销商编号string分销商编号labels标记多标签string标记 多标签paid_amount实付金额string实付金额free_amount优惠金额string优惠金额freight运费string运费weight预估重量string预估重量f_weight实称重量string实称重量merge_so_id合并订单号string合并订单号wms_co_id分仓编号string分仓编号business_staff业务人员string业务人员currency货币类型string货币类型items商品集合array商品集合items.ioi_id子单号string子单号items.pic图片string图片items.sku_id商品编码string商品编码items.qty数量string数量items.name商品名称string商品名称items.properties_value颜色规格string颜色规格items.sale_price单价string单价items.sale_amount金额string金额items.i_id款式编码string款式编码items.sale_base_price原价string原价items.batchs批次集合array批次集合items.batchs.batch_no批次号string批次号items.batchs.product_date批次日期string批次日期items.batchs.supplier_id供应商编号string供应商编号items.batchs.supplier_name供应商名称string供应商名称items.batchs.expiration_date有效期至string有效期至items.batchs.sns唯一码集合array唯一码集合items.batchs.sns.sn唯一码string唯一码items.batchs.sns.pay_date支付时间string支付时间items.batchs.sns.code错误码string错误码items.batchs.sns.issuccesstrue代表成功stringtrue代表成功items.batchs.sns.msg执行描述string执行描述items.batchs.sns.F_UYEP_Base_cw仓位string 金蝶云星空接口明细 接口：batchSave接口名称：销售出库新增接口方法：POST 请求参数 字段名称类型描述FBillTypeID单据类型string单据类型FBillNo单据编号string单据编号FDate日期string日期FSaleOrgId销售组织string销售组织FCustomerID客户string客户 FStockOrgId发货组织string发货组织FNote备注string备注FEntity明细信息array明细信息FEntity.FMaterialId物料编码string物料编码FEntity.FRealQty实发数量string实发数量FEntity.FPrice单价string单价FEntity.FTaxPrice含税单价string含税单价FEntity.FIsFree是否赠品string是否赠品FEntity.FEntryTaxRate税率%string税率%FEntity.FAllAmount价税合计string价税合计FEntity.FStockId仓库string仓库FEntity.FEntrynote备注string备注FEntity.SubHeadEntity财务信息object财务信息FEntity.SubHeadEntity.FSettleOrgId结算组织string结算组织FEntity.SubHeadEntity.FSETTLECURRID结算币别string结算币别FEntity.SubHeadEntity.FSalesManId业务员stringFEntity.SubHeadEntity.F_UYEP_Text1制单人stringFEntity.SubHeadEntity.F_UYEP_Text内部订单号stringFEntity.SubHeadEntity.FLot批次stringFEntity.SubHeadEntity.FormId业务对象表单Idstring必须填写金蝶的表单ID如 UR_PurchaseOrderFEntity.SubHeadEntity.Operation执行的操作stringFEntity.SubHeadEntity.IsAutoSubmitAndAudit提交并审核boolFEntity.SubHeadEntity.IsVerifyBaseDataField验证基础资料bool是否验证所有的基础资料有效性，布尔类，默认false（非必录） 系统打通概况 从API服务总线层面解决企业烟囱式业务系统集成现状 相互连接企业各业务系统，实现流程端到端打通，复用已有的业务系统能力，让集成架构、服务关系更清晰 使用统一的API管理平台，对API进行显性化、可视化，使所有API服务成为企业的数字资产，提升API利用率，发挥业务系统价值，实现企业IT资产的可插拔、可复用、可组成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3164073141384b656d1612d0526929bd/" rel="bookmark">
			Python案例分析｜使用Python图像处理库Pillow处理图像文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本案例通过使用Python图像处理库Pillow，帮助大家进一步了解Python的基本概念：模块、对象、方法和函数的使用
使用Python语言解决实际问题时，往往需要使用由第三方开发的开源Python软件库。
本案例使用图像处理库Pillow中的模块、对象来处理图像：实现读取图像、获取图像信息、调整图像大小、旋转图像、平滑图像、剪切图像等基本图像处理任务。
01、安装Pillow Pillow是Python中的图像处理库（PIL，Python Image Library），提供了了广泛的文件格式支持，强大的图像处理能力，主要包括图像储存、图像显示、格式转换以及基本的图像处理操作等。
Pillow位于Python包索引（PyPI）中，可以使用pip来安装。注意，Anaconda包含了Pillow库。
【例1】使用pip安装Pillow库。
以管理员身份运行命令行提示符，输入命令pip3 install Pillow，安装Pillow库。如图1所示。
■ 图1 使用pip安装Pillow库
02、打开和显示图像 Pillow库包含几十个模块，组织在名为PIL的包中。PIL包中的一个模块是Image。PIL.Image提供了一些包括从文件中加载图像和创建新图像的函数，其中的Image用于表示图像对象。
【例2】打开和显示图像。
使用PIL.Image模块的open()函数可以打开一个图像，返回一个图像对象，然后调用图像对象的show()方法，可以在屏幕上显示图像。
&gt;&gt;&gt; import PIL; from PIL import Image &gt;&gt;&gt; im = PIL.Image.open("c:/pythonpa/cs/img/mandrill.jpg") &gt;&gt;&gt; im.show() &gt;&gt;&gt; print(im.format, im.size, im.mode) #显示图像的格式、大小和模式信息 JPEG (298, 298) RGB 说明/
（1）im.format返回包含图像格式的字符串（JPEG、GIF、TIFF、BMP、PNG、…）。
（2）im.size返回包含图像宽度和高度的元组，单位为像素。与每个像素相关的是一对坐标(i, j)，用于标识像素的列i和行j。列从左到右编号，从0开始；行从上到下编号，也从0开始。
（3）im.mode返回包含图像模式的字符串（RGB、CYMK、Grayscale、…）。
03、图像的基本操作 图像对象的copy()方法用于拷贝图像；crop()方法用于剪裁图像；paste()方法用于将一个图像粘贴（覆盖）在另一个图像上面；resize()方法用于调整图像大小；rotate()方法用于旋转和翻转图像；filter()方法用于图像过滤。
Pillow提供的图像处理工具包括其它众多模块。有关Pillow的更多信息，请查阅在线文档http://pillow.readthedocs.org。
使用PIL.Image模块中的函数new()可以创建一个给定模式和大小的新图像对象。例如，创建一个新的大小为800×600的RGB图像的代码如下：
&gt;&gt;&gt; im2 = PIL.Image.new('RGB', (800,600)) 【例3】图像的基本操作示例。
把一幅图像的4个副本排列成2×2网格：在左上方的副本是原始图像，而画面右上方、左下方、右下方则分别使用模块PIL.ImageFilter中定义的内置过滤器CONTOUR、EMBOSS、FIND_EDGES进行过滤。
#模块：c:\pythonpa\cs\image_test.py #命令行：python image_test.py c:\pythonpa\cs\img\mandrill.jpg #功能：把c:\pythonpa\cs\img\mandrill.jpg的4个副本排列成2×2网格并显示 import sys import os import PIL.Image import PIL.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3164073141384b656d1612d0526929bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19b061dd5a6b3ee17ddd20a8709165dd/" rel="bookmark">
			PoolFormer实战：使用PoolFormer实现图像分类任务（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 训练部分导入项目使用的库设置随机因子设置全局参数图像预处理与增强读取数据设置Loss设置模型设置优化器和学习率调整算法设置混合精度，DP多卡，EMA定义训练和验证函数训练函数验证函数调用训练和验证方法 运行以及结果查看测试热力图可视化展示完整的代码 在上一篇文章中完成了前期的准备工作，见链接： PoolFormer实战：使用PoolFormer实现图像分类任务（一） 这篇主要是讲解如何训练和测试 训练部分 完成上面的步骤后，就开始train脚本的编写，新建train.py
导入项目使用的库 在train.py导入
import json import os import matplotlib.pyplot as plt import torch import torch.nn as nn import torch.nn.parallel import torch.optim as optim import torch.utils.data import torch.utils.data.distributed import torchvision.transforms as transforms from timm.utils import accuracy, AverageMeter, ModelEma from sklearn.metrics import classification_report from timm.data.mixup import Mixup from timm.loss import SoftTargetCrossEntropy from timm.models import poolformer_s24 from torch.autograd import Variable from torchvision import datasets torch.backends.cudnn.benchmark = False import warnings warnings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19b061dd5a6b3ee17ddd20a8709165dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3da063009bf12c52e8eb73b1390b3d64/" rel="bookmark">
			【论文阅读】《Distilling the Knowledge in a Neural Network》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【论文阅读】《Distilling the Knowledge in a Neural Network》 推荐指数： 1. 动机 （1）虽然一个ensemble的模型可以提升模型的效果，但是在效率方面实在难以接受，尤其是在每个模型都是一个大型的网络模型的时候。
（2）前人的研究结果也已表明：模型参数有很多其实是冗余的。
2. 方法 distilling the knowledge in an ensemble of models into a single model.
作者们之所以这么做又是因为之前有篇文章得到的结论，这个结论【这是一个很重要的结论】是： it is possible to compress the knowledge in an ensemble into single model.
更加具体的就是：
raise the temperature of the final softmax until the cumbersome model produces a suitably soft set of targets.
3.具体实现 在谈具体实现之前，先把本文涉及到的一些专有术语解释一下：
distilled model : 小模型（学生模型） We have shown that distilling works very well for transferring knowledge from an ensemble or from a large highly regularized model into a smaller, distilled model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3da063009bf12c52e8eb73b1390b3d64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/251c0e74b1ddf562f66444df9eab7467/" rel="bookmark">
			【Python笔记】多级雷达图绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实例1：个人能力画像雷达图
二、实例2：霍兰德人格分析雷达图
三、实例3：某校数字校园指标分析雷达图
（一）基础设施分析
（二）信息资源分析
（三）应用服务分析
（四）网络安全分析
（五）保障体系分析
（六）程序代码
一、实例1：个人能力画像雷达图 # -*- coding: utf-8 -*- """ Created on Sat Jul 1 20:52:54 2023 @author: zcq """ import numpy as np import matplotlib.pyplot as plt import matplotlib matplotlib.rcParams['font.family']='SimHei' matplotlib.rcParams['font.sans-serif']=['SimHei'] labels = np.array(['A1：综合','A2：学历','A3：职称','A4：教学','A5：培训','A6：科研']) nAttr = 6 data = np.array([7,5,9,7,8,6]) angels = np.linspace(0,2*np.pi,nAttr,endpoint=False) data = np.concatenate((data,[data[0]]))#级联函数data=[7, 5, 6, 9, 8, 6, 7] angels = np.concatenate((angels,[angels[0]])) fig = plt.figure(facecolor='white') plt.subplot(111,polar=True) plt.plot(angels,data,'bo-',color='g',linewidth=2) plt.fill(angels,data,facecolor='g',alpha=0.25) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/251c0e74b1ddf562f66444df9eab7467/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e25ac985b477f5bfba0f0688a260cc/" rel="bookmark">
			ubuntu18.04输入密码后又到输入密码界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		How to Fix the Ubuntu Login Loop Issue
可以参看上述的链接
基本的解决方法：
1.开机后在登录界面按下shift+ctrl+F1或者Ctrl+Alt+F1进入tty命令行终端；
2. cd ~ 进入家目录
3. ls -la 会有一个名为.Xauthority的文件，看下用户和用户组
4.sudo chown A:A .Xauthority 更改文件属组，A是登录的用户名。
5. sudo chmod -R 777 .Xauthority 更改文件权限
6.按Ctrl+Alt+F7返回图形界面，再次尝试登录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d1cb5dce82336c5922cc363d6115cf3/" rel="bookmark">
			【面试笔试算法】——拓扑排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 拓扑排序讲的是一件什么事呢？ 就拿学习来说，学习有时候讲究先后顺序，就是你得先修完某个前导课程，你才能开启后续的更高阶的课程。我们可以把这样的关系反映到一张由结点和有向边构成的有向图中。拓扑排序就是遍历这张图中的所有结点，同时确保当遍历到每一个结点时，所有该节点的前置结点都已经遍历过了（这就要求图中不能有环）。我们把遍历所有结点得到的顺序序列称为拓扑序列。拓扑排序就是求这样的一个个序列。
由此可见拓扑序列并不唯一。所以拓扑排序的结果也不唯一。
同时我们还可以利用不能成环这一性质，使用拓扑排序来判断一个图是否成环。
求解方法就是：不断取出图中度为0的结点，然后所有被该结点所指的结点的入度-1
2. 用队列方式求解拓扑排序 /************************************************************************* &gt; File Name: toposort.cpp &gt; Author: jby &gt; Mail: &gt; Created Time: Sun 16 Jul 2023 08:47:26 AM CST ************************************************************************/ #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; struct edge { int e, next; }; edge edg[100005]; int n ,m, head[105], in_degree[105], ans[105], cnt; int main() { memset(head, -1, sizeof(head)); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; edg[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d1cb5dce82336c5922cc363d6115cf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41bbfc4c2d227420e3718c63e9687aeb/" rel="bookmark">
			【数据结构】——队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		队列的代码实现方式有两种：一种实现方式是连续内存的数组，一种实现方式是离散内存的链表。
而循环队列一般采用连续内存的数组来实现。
1.数组实现方式 / 循环队列 /************************************************************************* &gt; File Name: queue.c &gt; Author: &gt; Mail: &gt; Created Time: Sat 15 Jul 2023 07:59:42 PM CST ************************************************************************/ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;time.h&gt; // 定义一个队列的数据结构 typedef struct Queue { int *data; int size; int head, tail; } Queue; int expand(Queue *q); // 初始化一个长度为n的队列 Queue *initQueue(int n) { Queue * q = (Queue *)malloc(sizeof(Queue)); q-&gt;data = (int *)malloc(sizeof(int) * n); q-&gt;size = n; q-&gt;head = q-&gt;tail = 0; return q; } // 释放空间，养成习惯，一开始就写好 void freeQueue(Queue *q) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41bbfc4c2d227420e3718c63e9687aeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a70b64a8ca1460838e8f0af57af5aa/" rel="bookmark">
			互联网行业真的不行了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、起因二、互联网真的完了吗？三、是不是要转行？四、十年磨一剑五、统一回复 前言 英雄算法联盟 - 七月集训 已经开始 16 天，八月算法集训 将于 08月01日 正式开始，目前已经提前开始报名，报名方式参见（八月算法集训报名），想要参加的同学，建议提早报名，因为对于算法零基础的同学，会有一些提前的准备工作，比如需要 1 - 5 天的时间完成预训练 和 九日集训 提前养成刷题的习惯，再参加算法集训会更加有成效。
一、起因 昨天在某音上发了一个刷题视频，一条评论引起了一些观众的争议，他说：“互联网已经完了”，我觉得单纯回复一下，几行字写不清楚，所以专门写了一篇文章。
二、互联网真的完了吗？ 那么互联网真的完了吗？肯定不是呀。
现在没有互联网，真的寸步难行，就算所有实体经济都垮了，互联网也同样屹立不倒。那么为什么会有人觉得互联网完了呢？本质是岗位少了，面试的时候给的HC少了，招的人少了，自然面试就变难了，才会有人发出这样的感慨，而实际上，这些都是供需关系决定的。
用人单位开始降本增效，不想招这么多人，而作为我们个体而言，只能比以往更加十倍，百倍的努力才行，你不卷，有的是人卷。
三、是不是要转行？ 你以为转行就能改变命运吗？哎，还真能！但也不一定。
要知道，工作对于我们普通人来说，可能是一辈子的事情，一旦不工作了，要么就是财务自由，要么就是退休吃养老金。是的，这里说的是普通人，也就是大部分人。
所以，找到一份自己喜欢的工作，就尤为重要，任何行业都有寒冬，一切事情不能都向钱看，如果在最困难的时候，坚持不下去，那么等到行业崛起的时候，也只能望洋兴叹。我常说：“兴趣是最好的老师”，刷题就是我最大的兴趣，所以很多人以为我是算法工程师，其实我是一个游戏开发者，做游戏十几年了，经历过游戏的春天，同样也经历过游戏的寒冬，三年又三年，不可能一直一帆风顺，如果在低谷期我放弃了，那么前面的积累都白费了，也不可能到达成功的彼岸。
虽然说选择大于努力，找到一个正确的方向很重要，但是没有成功之前，谁都不知道这个方向是不是正确的，但有一点是可以肯定的，如果自己的信念不够强，没有对这个行业有浓厚的兴趣，巨大的热爱，很可能中途放弃。
所以，核心是 —— 你到底热不热爱这个行业！？
四、十年磨一剑 任何一个行业，如果你能够深耕十年，一定会成为这个领域的专家，关键是你能不能坚持十年。找工作找不到是因为供大于求，当别人找不到就放弃，而你还在往下深耕，把熬不下去的人都熬走的时候，那不就是你的天下了嘛！
当然，是浑浑噩噩的度过十年，还是有规划的度过十年，又是不一样的结果。注重积累，把每天学到的东西都积累下来，形成文章分享、视频创作，在有正反馈的情况下，能够更好的督促你坚持把这件事情做下去，所以我目前积累的内容除了在公域发布的视频、博文以外，更大一部分是在我的私域里的，我目前创立了两个知识星球，一个是《英雄算法联盟》，目前成员 1800+，主要是帮助想学好算法的同学，更快的完成 0 到 1 ，因为我本身从上学到现在，刷了 5000+ 的题，ACM区域赛金、银、铜都拿过，ACM就是一个非常磨练人意志的比赛，能够把ACM坚持下来，其它事情更不在话下了，当然加入我的星球，学到的也不仅仅是算法，你会发现，当你快要放弃的时候，总会有一个人会推你一把；另一个是《英雄哥的流量密码》，记录我做自媒体的点点滴滴，记录了一些不为人知的做流量的技巧，这个目前20+的人，里面的成员也基本属于铁粉中的铁粉了，这些内容也只给铁粉看，所以这个星球我没有做过宣传，也不打算做宣传。
五、统一回复 最近有不少同学从 B站 和 抖音 的评论区里告诉我，我把他好友给删了，这里我给被删除的同学们道个歉，由于微信好友最多10000人，每天加我的人都有100+，我的好友列表也一直处于满负荷的状态，基本就是删一些没有聊天记录、没有印象的好友，才能再去加到新的人，也已经关闭了自动添加好友的渠道，所有能够加到我微信的渠道也都下架了。
当然，曾经或者现在还在我的知识星球《英雄算法联盟》里的同学，我有特殊分组，不会删除，可以在星球内部找到我的联系方式，报星球编号和昵称添加。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/113/">«</a>
	<span class="pagination__item pagination__item--current">114/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/115/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>