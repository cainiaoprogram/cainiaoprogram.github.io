<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995ccfd6aab976de6da9a043aaeda226/" rel="bookmark">
			HTTPS、SSL、TLS三者之间有什么不一样？分别是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSL(Secure Socket Layer 安全套接层)是基于HTTPS下的一个协议加密层，最初是由网景公司（Netscape）研发，后被IETF（The Internet Engineering Task Force - 互联网工程任务组）标准化后写入（RFCRequest For Comments 请求注释），RFC里包含了很多互联网技术的规范！ 起初是因为HTTP在传输数据时使用的是明文（虽然说POST提交的数据时放在报体里看不到的，但是还是可以通过抓包工具窃取到）是不安全的，为了解决这一隐患网景公司推出了SSL安全套接字协议层，SSL是基于HTTP之下TCP之上的一个协议层，是基于HTTP标准并对TCP传输数据时进行加密，所以HPPTS是HTTP+SSL/TCP的简称。
由于HTTPS的推出受到了很多人的欢迎，在SSL更新到3.0时，IETF对SSL3.0进行了标准化，并添加了少数机制(但是几乎和SSL3.0无差异)，标准化后的IETF更名为TLS1.0(Transport Layer Security 安全传输层协议)，可以说TLS就是SSL的新版本3.1，并同时发布“RFC2246-TLS加密协议详解”，如果想更深层次的了解TLS的工作原理可以去RFC的官方网站：www.rfc-editor.org，搜索RFC2246即可找到RFC文档！ ——以上就是历史背景
SSL 是指安全套接字层，简而言之，它是一项标准技术，可确保互联网连接安全，保护两个系统之间发送的任何敏感数据，防止网络犯罪分子读取和修改任何传输信息，包括个人资料。两个系统可能是指服务器和客户端（例如，浏览器和购物网站），或两个服务器之间（例如，含个人身份信息或工资单信息的应用程序）。
要说清楚 HTTPS 协议的实现原理，至少需要如下几个背景知识。
大致了解几个基本术语（HTTPS、SSL、TLS）的含义大致了解 HTTP 和 TCP 的关系（尤其是“短连接”VS“长连接”）大致了解加密算法的概念（尤其是“对称加密与非对称加密”的区别）大致了解 CA 证书的用途 5.TCP通信协议的几次握手 TLS（传输层安全）是更为安全的升级版 SSL。由于 SSL 这一术语更为常用，因此我们仍然将我们的安全证书称作 SSL。但当您从赛门铁克购买 SSL 时，您真正购买的是最新的 TLS 证书，有 ECC、RSA 或 DSA 三种加密方式可以选择。 TLS/SSL是一种加密通道的规范 它利用对称加密、公私钥不对称加密及其密钥交换算法，CA系统进行加密且可信任的信息传输
在HTTP SSL中常用的对称加密算法有RC4,AES,3DES,Camellia等
SSL由从前的网景公司开发
有1,2,3三个版本，但现在只使用版本3
TLS是SSL的标准化后的产物
有1.0 1.1 1.2三个版本
默认使用1.0
TLS1.0和SSL3.0几乎没有区别
事实上我们现在用的都是TLS，但因为历史上习惯了SSL这个称呼
平常还是以SSL为多。
SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。
SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/995ccfd6aab976de6da9a043aaeda226/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66cbc0ec3229ca6ec4af4aca2189bf37/" rel="bookmark">
			[转]：git报错：Pull is not possible because you have unmerged files解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git报错：Pull is not possible because you have unmerged files解决 本地的push和merge会形成MERGE-HEAD(FETCH-HEAD), HEAD（PUSH-HEAD）这样的引用。HEAD代表本地最近成功push后形成的引用。MERGE-HEAD表示成功pull后形成的引用。可以通过MERGE-HEAD或者HEAD来实现类型与svn revet的效果。
解决：
1.将本地的冲突文件冲掉，不仅需要reset到MERGE-HEAD或者HEAD,还需要–hard。没有后面的hard，不会冲掉本地工作区。只会冲掉stage区。
git reset --hard FETCH_HEAD
2.git pull就会成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a19d8760915e5993322175a211dfde05/" rel="bookmark">
			如何添加SQL Server登录服务器地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 打开SQL Server后，需要连接服务器，但是在安装SQL Server时只注册了一个服务器，如果现在想连接到其它服务器地址，该如何操作呢？笔者与大家分享一下SQL Server中添加登录服务器地址的操作经验
一、单击“开始”----&gt;“所有程序”----&gt;“Microsoft SQL Server 2008 R2”----&gt;“配置工具”----&gt;“SQL Server 配置管理器”，打开配置管理器。 二、找到“SQL Server网络配置”，展开后单击“MRSQLSERVER的协议”选项。 三、在右侧的“TCP/IP”选项上右击，选择“启动”。 四、双击“TCP/IP”选项，打开“TCP/IP属性”窗口。 五、单击“IP地址”选项卡，如下图所示。 六、将下方所有的“TCP端口”，都改为1433，如下图所示（注：是所有TCP端口）。 七、将IP1和IP2中的“TCP动态端口”的值修改为空，如下图所示。 八、将IP1的IP地址改为需要连接的服务器地址，本例为“192.168.0.104”。 九、选择SQL Server服务，在右侧的SQL Server（MRSQLSERVER）选项上右击，选择“停止”。 十、最后，在SQL Server（MRSQLSERVER）选项上右击，选择“启动”。 十一、在SQL Server的“服务器名称”中输入设置的服务器地址，单击“连接”就可以接入自己需要连接的服务器了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40813bd47f0374c94ec1d698994f3695/" rel="bookmark">
			激光光路中镜片阈值计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		条件
脉冲激光器，能量3.5J，频率100HZ，时间10ns，波长1064nm，出射光斑直径14mm
每秒做功：3.5J*100=350J
平均功率：350W
峰值功率：3.5J/10ns=3.5*10^8w
计算
1：假设镜子1KW/cm^2，平均功率可以满足，但峰值功率不满足，所以不满足要求
2：假设镜子3J@10ns@1064，考虑到激光器能量高斯分布，激光光斑能量比较集中，因此选光斑直径为10mm，在此光斑条件下镜子能承受的最大能量为3/1*3.14=9.42J&gt;3.5J，因此满足要求。
注意：
镜子在激光器内部时，可以按照上述推导计算，但是当镜子在空气中时，应考虑灰尘的影响，损失阈值应该比理论计算结果大。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8f2863c379956e7a0692bd5760a5fa5/" rel="bookmark">
			struts2提交请求的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.链接方法 以下方式使用链接提交请求，其中deleteStudent为请求名student为Action中的属性，student.id表示Action类中的student属性中的id，以下代码将#stu.id的值传递到Action类中student属性中的id
&lt;a href="deleteStudent?student.id=&lt;s:property value="#stu.id" /&gt;"&gt;删除&lt;/a&gt; 2.按钮方法 1.表单方式
action后面写请求的名字，在struts2.xml文件里面根据该请求名找到对应的Action类，并且实例化对应的Action类，将类中属性student中的id设值为textfield中的内容
&lt;s:form action="queryStudent" method="post" theme="simple"&gt; &lt;s:textfield name="student.queryParameter"/&gt;&lt;s:submit value="查询"/&gt; &lt;/s:form&gt; 2.onclick方式 比较简单的方式，其中javascript:window.location.href='请求名?类中属性=要传递的数值‘，这个方法也可以写在javascript中。
&lt;input type="button" value="修改" onclick="javascript:window.location.href='showStudentInformation?student.id=&lt;s:property value="#stu.id"/&gt;'"/&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5944126b3181afaf89a8689172fda5b5/" rel="bookmark">
			论文笔记：Cascaded Pyramid Network for Multi-Person Pose Estimation（CPN）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cascaded Pyramid Network for Multi-Person Pose Estimation 1、主要成果2、细节2.1、网络构成2.2、实验设置2.3、实验结果 3、总结4、看法 1、主要成果 提出 C P N ( C a s c a d e d P y r a m i d N e t w o r k ) CPN(Cascaded~Pyramid~Network) CPN(Cascaded Pyramid Network)探索不同因素对自顶向下的多人姿态估计的影响 2、细节 2.1、网络构成 使用基于 F P N FPN FPN 检测器的算法检测人体边界框。（ R O I A l i g n ROIAlign ROIAlign 替代 R O I P o o l i n g ROIPooling ROIPooling） G l o b a l N e t GlobalNet GlobalNet：基于 F P N FPN FPN 的网络结构定位易检测关键点 R e f i n e N e t RefineNet RefineNet：结合 F P N FPN FPN 的各层特征推理难检关键点，基于训练损失，在线挑选难检关键点 网络结构如图 1 1 1 和图 2 2 2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5944126b3181afaf89a8689172fda5b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02e0f14622982f8d30c7546ccda8ff4/" rel="bookmark">
			Android使用SharedPreferences保存状态，实现第一次进入引导页，第二次进入首页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只需要把这个实体类给放到Activity就可以
private SharedPreferences pref; //用于判断是否是第一次运行，运行后变为false private boolean isFirst = true; private Intent intent; private void DaoHangYe() { RelativeLayout layoutWelcome = (RelativeLayout) findViewById(R.id.layoutwelcome); AlphaAnimation alphaAnimation = new AlphaAnimation(0.1f, 1.0f); alphaAnimation.setDuration(3000); layoutWelcome.startAnimation(alphaAnimation); alphaAnimation.setAnimationListener(new Animation.AnimationListener() { @Override public void onAnimationStart(Animation animation) { } @Override public void onAnimationRepeat(Animation animation) { } @Override public void onAnimationEnd(Animation animation) { judgeIntent(); } private void judgeIntent() { pref = getSharedPreferences("isFirst", MODE_PRIVATE);//创建SharedPreferences对象 isFirst = pref.getBoolean("isFirstIn", true);//如果第一次运行，无isFirstIn值，自动获取第二个参数为默认值 if (isFirst) {//如果为true，进入if语句 intent = new Intent(MainActivity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f02e0f14622982f8d30c7546ccda8ff4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ca7617f74f6f09a51d1fbf55ed347f4/" rel="bookmark">
			C#实现在图片上添加文字和二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源程序下载地址：
https://download.csdn.net/download/u012577474/11224784
原始素材：
我的公众号二维码图片：
运行程序后的效果图：
源代码如下：
添加图片方法：
DrawImage(Image, 画图位置x, 画图位置y, 图片宽, 图片高)；
添加文字方法：
DrawString(文字, 字体, 画笔, 位置);
//窗口加载事件 private void Form1_Load(object sender, EventArgs e) { pictureBox1.Image = Image.FromFile("C:/Users/Administrator/Desktop/c#picture/1.jpg"); //设置背景图片 string imgPath = "C:/Users/Administrator/Desktop/c#picture/IT爱好者.jpg"; //要插入的二维码图片路径 Image QRcodePic; //用来存储读取的二维码图片 //读取二维码图片文件流 FileStream fileStream = new FileStream(imgPath, FileMode.Open, FileAccess.Read); int byteLength = (int)fileStream.Length; //二维码图片字节数 byte[] fileBytes = new byte[byteLength]; //根据图片字节数创建一个存储该图片的字节数组 fileStream.Read(fileBytes, 0, byteLength); //读取二维码图片到数组 fileStream.Close(); //关闭文件流，解除对外部文件的锁定 //取得二维码图片image对象 QRcodePic = Image.FromStream(new MemoryStream(fileBytes)); Graphics g = Graphics.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ca7617f74f6f09a51d1fbf55ed347f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aa587b760505eeef3a57d5bca07918e/" rel="bookmark">
			git pull提示remote error:CAPTCHA required
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在从bitbucket上更新代码的时候，提示失败，错误提示为remote error:CAPTCHA required。
出现这个问题的原因一般是因为近期修改过bitbucket的密码或者使用错误的密码多次登录bitbucket，导致bitbucket需要验证码才能登录，然而git客户端都是命令行，当然没办法输入验证码了。
解决方案：
1.如果是因为多次输入错误密码
打开浏览器，在浏览器上登录一遍bitbucket，网页上会提示输入验证码，输入验证码，正常登录后，git可用。
2.如果是因为bitbucket密码修改，则最好做两步
（1）修改git连接bitbucket使用的用户名密码，修改方法见使用HTTPS方式向git托管网站推送项目时输错用户名密码。
（2）打开浏览器，在浏览器上登录一遍bitbucket，网页上会提示输入验证码，输入验证码，正常登录后，git可用。
搞定
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d0bf94c71a8b2c9c1af0324bc77ae7/" rel="bookmark">
			SASBASE认证考试划重点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、SAS基本设置
proc import
infile选项控制输入
sas遇到错误会怎么处理
sas系统选项optinos
读取文件的input
贡献变量in选项
put输入格式
lable
二、函数
字符型函数
循环函数
平均函数的变量简写
条件判断IF/ELSEIF
数组命名方式
将字符型变量转换成数值型变量的方式：
排序函数
求和函数
first/last应用
retain的应用
scan函数
三、打印描述数据
数值型变量输出格式format
proc tabulate
proc report
report中break和rbreak用法
proc report 输出中添加统计量
proc means
输出output
四、数据合并：
set合并数据
MERGE合并数据
数据转换TRANSPOSE
过程中创建输出file/put对应从原始文件中读取数据infile/input
datasets步的选项
激活data步debug
_error_
format
五、报告输出
html输出
一、SAS基本设置 proc import ---
infile选项控制输入 FIRSTOBS= FIRSTOBS= 选项告诉SAS从哪一行开始读取数据，当数据开头有些说明信息，或者想要跳过某些行时，这个选项很有用。
OBS= OBS=告诉SAS一直读取到哪一行位置，注意是行而不是观测值（有的观测值占据多行）比如，如下的原始数据文件中，结尾处还有一句不需要的数据说明时。
&lt;T123例题36&gt;
sas遇到错误会怎么处理 数据错误：当sas遇到数据错误时候，缺失数据值以恰当的值代替，并继续执行程序。数据错误不会中止程序运行。
&lt;T50例题49&gt;
语法错误：程序将停止执行
sas系统选项optinos OPTIONS语句 是SAS程序的一部分，并可影响之后的所有语句。由OPTIONS关键词开头，后面是相关选项。
OPTIONS语句既不属于数据步也不属于过程步，这个全局变量可以出现在程序的任何部分，但放在开头最有意义，你可以很容易看到哪些选项在发挥作用。如果OPTIONS语句只出现在数据步或者过程步中，那么它会影响那个过程。注意，后面的OPTIONS语句会覆盖前面的，即以后面的OPTIONS为主。
OPTIONS LINESIZE=80 NODATE; options date；在报告中显示时间 &lt;T123例题102&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65d0bf94c71a8b2c9c1af0324bc77ae7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/581bb54e56f6151dba3c31d573274c25/" rel="bookmark">
			在K8s上部署Redis 集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
架构原理：每个Master都可以拥有多个Slave。当Master下线后，Redis集群会从多个Slave中选举出一个新的Master作为替代，而旧Master重新上线后变成新Master的Slave。
二、准备操作
本次部署主要基于该项目：
https://github.com/zuxqoj/kubernetes-redis-cluster 其包含了两种部署Redis集群的方式：
StatefulSet
Service&amp;Deployment
两种方式各有优劣，对于像Redis、Mongodb、Zookeeper等有状态的服务，使用StatefulSet是首选方式。本文将主要介绍如何使用StatefulSet进行Redis集群的部署。
三、StatefulSet简介
RC、Deployment、DaemonSet都是面向无状态的服务，它们所管理的Pod的IP、名字，启停顺序等都是随机的，而StatefulSet是什么？顾名思义，有状态的集合，管理所有有状态的服务，比如MySQL、MongoDB集群等。
StatefulSet本质上是Deployment的一种变体，在v1.9版本中已成为GA版本，它为了解决有状态服务的问题，它所管理的Pod拥有固定的Pod名称，启停顺序，在StatefulSet中，Pod名字称为网络标识(hostname)，还必须要用到共享存储。
在Deployment中，与之对应的服务是service，而在StatefulSet中与之对应的headless service，headless service，即无头服务，与service的区别就是它没有Cluster IP，解析它的名称时将返回该Headless Service对应的全部Pod的Endpoint列表。
除此之外，StatefulSet在Headless Service的基础上又为StatefulSet控制的每个Pod副本创建了一个DNS域名，这个域名的格式为：
$(podname).(headless server name) FQDN： $(podname).(headless server name).namespace.svc.cluster.local 也即是说，对于有状态服务，我们最好使用固定的网络标识（如域名信息）来标记节点，当然这也需要应用程序的支持（如Zookeeper就支持在配置文件中写入主机域名）。
StatefulSet基于Headless Service（即没有Cluster IP的Service）为Pod实现了稳定的网络标志（包括Pod的hostname和DNS Records），在Pod重新调度后也保持不变。同时，结合PV/PVC，StatefulSet可以实现稳定的持久化存储，就算Pod重新调度后，还是能访问到原先的持久化数据。
以下为使用StatefulSet部署Redis的架构，无论是Master还是Slave，都作为StatefulSet的一个副本，并且数据通过PV进行持久化，对外暴露为一个Service，接受客户端请求。
四、部署过程
本文参考项目的README中，简要介绍了基于StatefulSet的Redis创建步骤：
1.创建NFS存储
2.创建PV
3.创建PVC
4.创建Configmap
5.创建headless服务
6.创建Redis StatefulSet
7.初始化Redis集群
这里，我将参考如上步骤，实践操作并详细介绍Redis集群的部署过程。文中会涉及到很多K8S的概念，希望大家能提前了解学习
1.创建NFS存储
创建NFS存储主要是为了给Redis提供稳定的后端存储，当Redis的Pod重启或迁移后，依然能获得原先的数据。这里，我们先要创建NFS，然后通过使用PV为Redis挂载一个远程的NFS路径。
安装NFS
yum -y install nfs-utils（主包提供文件系统） yum -y install rpcbind（提供rpc协议） 然后，新增/etc/exports文件，用于设置需要共享的路径：
[root@ftp pv3]# cat /etc/exports /usr/local/k8s/redis/pv1 192.168.0.0/24(rw,sync,no_root_squash) /usr/local/k8s/redis/pv2 192.168.0.0/24(rw,sync,no_root_squash) /usr/local/k8s/redis/pv3 192.168.0.0/24(rw,sync,no_root_squash) /usr/local/k8s/redis/pv4 192.168.0.0/24(rw,sync,no_root_squash) /usr/local/k8s/redis/pv5 192.168.0.0/24(rw,sync,no_root_squash) /usr/local/k8s/redis/pv6 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/581bb54e56f6151dba3c31d573274c25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a650cdecedcf1b5ef5781056fd1758b7/" rel="bookmark">
			Android判断网络连接状态及双击退出APP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次是安卓常用的两个小功能，一个是判断网络是否连接，另一个是双击返回键退出APP，这两个类都是放到代码里都能用
判断网络的实体化类
public void getNetInfor() { //首先是获取网络连接管理者 ConnectivityManager manager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo info = manager.getActiveNetworkInfo(); //网络状态存在并且是已连接状态 if (info != null &amp;&amp; info.isConnected()) { Toast.makeText(ShouyeActivity.this, "网络已连接", Toast.LENGTH_SHORT).show(); } else { Toast.makeText(ShouyeActivity.this, "网络连接失败", Toast.LENGTH_SHORT).show(); //下面的这种写法你应该看得懂 new AlertDialog.Builder(ShouyeActivity.this) .setTitle("请检查网络连接") .setNegativeButton("确定", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { if (android.os.Build.VERSION.SDK_INT &gt; 10) { //安卓系统3.0以上打开设置界面，也可以直接用ACTION_WIRELESS_SETTINGS打开到wifi界面 startActivity(new Intent(android.provider.Settings.ACTION_SETTINGS)); } else { startActivity(new Intent(android.provider.Settings.ACTION_WIRELESS_SETTINGS)); } } }) .show(); } } 下面是双击退出APP 也是个实体化类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a650cdecedcf1b5ef5781056fd1758b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a5850e7fe9601898f9d7d443b09d6b/" rel="bookmark">
			AndroidStudio 断点走了但不停、断点不走或看不到断点的数据问题；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		万恶之源是混淆！！！ 在AS断点调试时记得关闭混淆：minifyEnabled false！！！
不然断点调试时什么幺蛾子都可能出现；什么断点不停啊、断点停了但看不到属性啊之类的；
在APP的build.gradle中关掉混淆，minifyEnabled false；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/945f3fc449518a73b9f5f32868db466c/" rel="bookmark">
			lambda
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是lambda 把“一块代码”赋给了一个变量。而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式。其实就是个匿名函数。
为什么要用lambda 使用lambda表达式可对一个接口进行简洁的实现。
lambda对接口的要求 要求接口中定义的必须实现的抽象方法只能有一个（必须要实现的，不是default修饰的）。
Java8对接口加了一个新特性：default，修饰接口方法，就可以有默认实现，这样实现类可以实现该方法也可以不实现。
@FunctionalInterface
修饰函数式接口的，接口中抽象方法只能有一个。
实现接口的三种方式 public static void main(String[] args) { //实现接口方法实现 CompareImpl compare = new CompareImpl(); System.out.println(compare.compare(10,5)); //内部类方法实现 Compare compare1 = new Compare() { public int compare(int a,int b){ return a-b; } }; System.out.println(compare1.compare(10,5)); //lanbda实现 Compare compare2 = (a,b) -&gt; a - b; System.out.println(compare2.compare(10,5)); } lambda语法 public static void main(String[] args) { //lambda的基础语法 //lambda是一个匿名函数 //参数列表 方法体 //() ：参数列表 //()： 方法体 // -&gt; lambda运算符 goes to //无参无返回 NoneReturnNoneParameter lambda1=() -&gt; { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/945f3fc449518a73b9f5f32868db466c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee508fcd30ced8eb1110313b61b04614/" rel="bookmark">
			opencv特征检测和匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		opencv可以检测图像的主要特征，然后提取这些特征，使其成为图像描述符，利用这些图像描述符来搜索数据库里，进行图像的检测
1.特征检测算法
算法：
Harris：用于检测角点SIFT：用于检测斑点SURF：用于检测斑点FAST：用于检测角点BRIEF：用于检测斑点ORB：代表带有方向的FAST算法与具有旋转不变性的BRIEF算法 方法：
暴力匹配法基于FLANN的匹配法 2.cornerHarris角点检测
import cv2 import numpy as np img = cv2.imread('E:\\opencv3\\charpter6\\chess_board.jpg') gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) gray = np.float32(gray)#为了使用cornerHarris函数，需要将棋盘图像转化为灰度个事 dst = cv2.cornerHarris(gray,4,21,0.04)#从灰度图像做处理，提取角点信息 #第二个参数：参数值越小，标记点的大小越小 #第三个参数：参数值只能在3-31之间，而且必须是奇数，表示敏感度，越小，敏感度越强，会把很多细节的东西也算成角点 #第三个参数：自由参数,取值参数为 [0,04,0.06] img[dst&gt;0.01*dst.max()] = [0,0,255] while (True): cv2.imshow('result',img) if cv2.waitKey(5) &amp; 0xff == ord('q'): break cv2.destroyAllWindows() dst&gt;0.01*dst.max()这么多返回是满足条件的dst索引值，根据索引值来设置这个点的颜色，这里是设定一个阈值　当大于这个阈值分数的都可以判定为角点
3.DOG和SIFT进行特征提取与描述
cornerHarris函数可以很好的检测到角点，这与焦点的特性有关，即使图片旋转，也能检测到角点，但是如果图像压缩了或者增大了，那么cornerHarris检测的角点信息就可能遗漏，图像越小越有可能丢失掉角点信息
这使我们可以用一种与图像比例无关的角点检测方法：SIFT
该函数在图像尺度变化时依然能输出同样的结果，但是SIFT并不检测关键点，关键点是由DOG检测的，但是SIFT会通过一个特征向量来描述特征点周围的区域情况
DOG（Differen Of Gaussians）
DOG是对同一副图像使用不同的高斯滤波器所得到的结果，前面有提到过cv2.GaussianBlur()低通滤波的模糊处理效果，DOG技术可以有效地检测到边缘，做种结果是感兴趣的区域（关键点）
import cv2 import numpy as np impath = 'E:\\opencv3\\charpter6\\chess_board.jpg' img = cv2.imread(impath) gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) sift = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee508fcd30ced8eb1110313b61b04614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d4db3bc00924085f28755662aac65d/" rel="bookmark">
			软件构造Lab2实验总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本实验当中最主要的工作是实现一个图结构， 并要求使用泛型实现。
各个方法的实现过程：
public boolean add(L vertex)
判断以vertex为名称的点是否已经存在。若存在，不执行任何操作。否则在vertices中增加该节点。
public int set(L source, L target, int weight)
首先区分weight是否等于零。不等于0时再判断点是否已经包含了相应的节点。若未包含则进行添加。查找目标的边。若查找到，更改该边的权重。若查找不到，则添加边。等于0时则查找边集，如果查找到则进行删除，否则不进行任何操作。
public boolean remove(L vertex)
在顶点集当中查找节点。查找到则执行删除操作。查找不到，则什么都不做。
public Set vertices()
遍历顶点集合，将顶点的名称收集到一个集合当中即可。
Map&lt;L, Integer&gt; sources(L target)
遍历所有的点，将以target为终止点的边找出并放置在结果集合当中。遍历完成后将结果集合返回。
public Map&lt;L, Integer&gt; targets(L source)
返回该顶点的所有邻接到的边即可。
后半部分要求实现一个棋盘结构。这是我第一次真正意义上的面向对象编程，也走了很多弯路，但是仍然得到了实现。最主要的思路是定义一个全局变量指示当前的活动玩家，所有的操作都依据这个变量判断操作是否合法。在游戏进行的过程当中，如果操作正确合法，就进行活动玩家的转换，否则提醒该玩家重新进行操作。实际上本部分还有一定的改进空间，比如使用单例模式等减少内存的占用。
总而言之，这是我第一次体验面向对象编程的思维方法，极好地强化了java语言的基础知识，使我收获颇丰。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adef04b08387ec84025a1898e5086ccf/" rel="bookmark">
			vue中公共方法调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，在assets文件夹下，新建js文件夹，创建common.js
export default {	text(){ console.log("测试，测试！！！") } } （1）如果是全局（多页面）使用：
1.在main.js中引入
/* 引入公共js*/ import common from '@/assets/js/common.js' Vue.prototype.common=common; 2.在vue中使用
this.common.text(); //测试，测试！！！ （1）如果是单页面使用：
1.在vue的script中引入
import common from '@/assets/js/common.js' 2.在vue中使用
common.text(); //测试，测试！！！ -------------------------------------------------------------------------------------------------------------------------
区别：static文件夹一般用来存放外部资源；assets文件夹一般存放自身资源
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b2d655596afa5f6263a9a7228b9b81/" rel="bookmark">
			hadoop dfsadmin -report时出现数据都为0B
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行hadoop dfsamin -report 时出现数据时都为0B
如下所示：
[root@master hadoop]# hadoop fsadmin -report Error: Could not find or load main class fsadmin [root@master hadoop]# hadoop dfsadmin -report DEPRECATED: Use of this script to execute hdfs command is deprecated. Instead use the hdfs command for it. Configured Capacity: 0 (0 B) Present Capacity: 0 (0 B) DFS Remaining: 0 (0 B) DFS Used: 0 (0 B) DFS Used%: NaN% Under replicated blocks: 0 Blocks with corrupt replicas: 0 Missing blocks: 0 Missing blocks (with replication factor 1): 0 ------------------------------------------------- 那么我们就删除hadoop下的hdfs和tmp两个文件夹就可以啦
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b2d655596afa5f6263a9a7228b9b81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cbfb842f8e16ef0e0e9df7c4f5d6e9d/" rel="bookmark">
			8254定时/计数器实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载的：
https://blog.csdn.net/as1072966956/article/details/80718843
8254定时/计数器应用实验
1 实验目的
掌握8254的工作方式及应用编程。
掌握8254典型应用电路的接法。
2 实验设备
PC机一台，TD-PITE实验装置一套。
3 实验内容
计数应用实验。编写程序，应用8254的计数功能，使用单次脉冲模拟计数，使每当按动‘KK1＋’5次后，产生一次计数中断，并在屏幕上显示一个字符‘M’。
定时应用实验。编写程序，应用8254的定时功能，产生一个1s的方波。
4 实验原理
8254是Intel公司生产的可编程间隔定时器。是8253的改进型，比8253具有更优良的性能。8254具有以下基本功能：
（1）有3个独立的16位计数器。
（2）每个计数器可按二进制或十进制（BCD）计数。
（3）每个计数器可编程工作于6种不同工作方式。
（4）8254每个计数器允许的最高计数频率为10MHz（8253为2MHz）。
（5）8254有读回命令（8253没有），除了可以读出当前计数单元的内容外，还可以读出状态寄存器的内容。
（6）计数脉冲可以是有规律的时钟信号，也可以是随机信号。计数初值公式为：
n=fCLKi÷fOUTi、其中fCLKi是输入时钟脉冲的频率，fOUTi是输出波形的频率。
图4.27是8254的内部结构框图和引脚图，它是由与CPU的接口、内部控制电路和三个计数器组成。8254的工作方式如下述：
（1）方式0：计数到0结束输出正跃变信号方式。
（2）方式1：硬件可重触发单稳方式。
（3）方式2：频率发生器方式。
（4）方式3：方波发生器。
（5）方式4：软件触发选通方式。
（6）方式5：硬件触发选通方式。
图4.27 8254的内部接口和引脚
8254的控制字有两个：一个用来设置计数器的工作方式，称为方式控制字；另一个用来设置读回命令，称为读回控制字。这两个控制字共用一个地址，由标识位来区分。控制字格式如表4.3—4.5所示。
表4.3 8254的方式控制字格式
D7
D6
D5
D4
D3
D2
D1
D0
计数器选择
读/写格式选择
工作方式选择
计数码制选择
00－计数器0
01－计数器1
10－计数器2
11－读出控制
字标志
00－锁存计数值
01－读/写低8位
10－读/写高8位
11－先读/写低8位
再读/写高8位
000－方式0
001－方式1
010－方式2
011－方式3
100－方式4
101－方式5
0－二进制数
1－十进制数
表4.4 8254读出控制字格式
D7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cbfb842f8e16ef0e0e9df7c4f5d6e9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2aeae4cf83fb796d01a0ff11fd55f6e/" rel="bookmark">
			No certificate for team  matching &#39;iPhone Distribution
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打包的时候出现如下错误： 这是电脑上缺少证书的错误，错误提示中的'iPhone Distribution:....'就是证书名字。
可以打开钥匙串的登陆的证书中 有没有叫这个名字的证书（如何查看证书的名字请戳这里）
安装对应的证书文件即可
添加证书 如果提示 不能修改“System Roots”钥匙串错误
解决方法：
打开钥匙串---登录，直接把证书拖过来
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d7a12e898fb5705d076d875d90b9d75/" rel="bookmark">
			Android--Intent和过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android–Intent和过滤器
什么是Intent Android中提供了Intent机制来协助应用间的交互与通讯。Intent 可以通过多种方式促进组件之间的通信，其基本用例主要包括以下三个：
启动Activity。使用Context.startActivity() 或 Activity.startActivityForResult()，传入一个intent来启动一个activity。使用 Activity.setResult()，传入一个intent来从activity中返回结果。
启动服务。将intent对象传给Context.startService()来启动一个service或者传消息给一个运行的service。将intent对象传给 Context.bindService()来绑定一个service。
传递广播。将intent对象传给 Context.sendBroadcast()，Context.sendOrderedBroadcast()，或者Context.sendStickyBroadcast()等广播方法，则它们被传给 broadcast receiver。
Intent的类别 显式 Intent：需要按名称（完全限定类名）指定要启动的组件。 通常在自己的应用中使用显式 Intent 来启动组件，因为此时知道要启动的 Activity 或服务的类名。
隐式 Intent ：不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理。
创建显式 Intent 启动 Activity 或服务时，系统将立即启动 Intent 对象中指定的应用组件。
创建隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上其他应用的清单文件中声明的 Intent 过滤器进行比较，从而找到要启动的相应组件。如果多个 Intent 过滤器兼容，系统会显示一个对话框，支持用户选取要使用的应用。
Intent的属性 component(组件)
Component属性明确指定Intent的目标组件的类名称。该属性是可选项，只用于显示Intent，如果没有指定，则 Intent 是隐式的。
可以使用 setComponent()、setClass()、setClassName() 或 Intent 构造函数设置组件名称。
比如启动一个Activity：
Intent intent = new Intent(); //创建组件，通过组件来响应 ComponentName component = new ComponentName(MainActivity.this, AnotherActivity.class); intent.setComponent(component); startActivity(intent); //或者可以简写为 Intent intent = new Intent(); intent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d7a12e898fb5705d076d875d90b9d75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5a87b041597b4cda6d3a8f4454b045c/" rel="bookmark">
			[Vue warn]: Property or method &#34;name&#34; is not defined on the instance but referenced during render
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小咸儿在做Vue项目的时候，有时候会在浏览器中看到Vue的警告，如下：
含义：页面使用了name，但是未定义
在此有两种解决办法：
一：在定义变量区定义该属性
在此可以查看你的data或者methods或者prop中有没有定义该属性
export default { data() { return { xxx::"" } }, methods: { xxx() {} } } 二：在是在使用了表单验证的时候，解决办法
在使用表单时，不可避免的会使用prop属性，可以看一下官网上对于prop属性的介绍：
可以看出prop属性的类型是字符串，如果加上：，则**:prop**的值为data定义的一个属性值，如果去掉：，那么prop=“name”就是一个字符类型的，或者是使用:prop="‘name’"，在中间的字段名上添加单引号。
特别感谢：小咸儿在解决问题的时候，主要参考了下面两篇博客，在此感谢两位博主。
方法一：在变量区定义
方法二：用于表单验证时
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe4e8d65ee6278543b0ae63754619057/" rel="bookmark">
			Android ButterKnife not found view
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以下错误本人经历两次了，痛苦地记录一下吧 Caused by: java.lang.IllegalStateException: Required view 'rv_content' with ID 2131297021 for field 'rvContent' was not found. If this view is optional add '@Nullable' (fields) or '@Optional' (methods) annotation. 此异常，编译不会产生，只有在运行时才会产生。 产生原因：组件化过程中，一个模块中的activity或是fragment移动到了另一个模块，没有重新对R和R2导包,导致ButterKnife绑定发生错乱，无法找到正确的id。 解决办法：重新导包即可。导入新模块的包名。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/116f07b4c6c36541e72dbae75a3464ad/" rel="bookmark">
			用SAS如何读取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你可能有各种形式的数据，包括手写在纸上、存放在电脑上、或是在数据库管理系统里，不论如何，总有一种方法可以让SAS来读取。
SAS读取的数据的方法主要有以下几种类型：
 直接输入；
 从原始数据文件中创建一个SAS数据集（creating SAS data sets from raw data files）；
 将其他软件中的数据文件转换成SAS数据集；
 直接读取其他软件的数据集；
直接输入
View table窗口可以让你以表格形式输入数据，可以定义变量、设置属性，如name、length和 type(character or numeric).
 SAS 企业向导模块
 SAS/FSP 模块，是Full Screen Product的简称，可以设计定制的数据输入窗口，也有检测数据输入错误的功能（The SAS/FSP product is licensed separately from Base SAS software.）。
从原始数据文件中创建一个SAS数据集
你有两种方法读取原始数据文件：
 数据步可以读取任何形式的原始数据文件，比如text, ASCII, sequential, flat files。
 导入向导（Import Wizard）、导入过程（IMPORT procedure）适用于UNIX、OpenVMS和 Windows操作环境的简单方法，可以读取CSV（comma-separated values）和其他一些限定的文件类型。
将其他软件中的数据文件转换成SAS数据集
如果数据在一个软件中以某种格式存放，但需要用另一种软件分析时，就会很麻烦。有几种方法可以将某种软件中的数据转换成SAS数据集：
 如果安装SAS/ACCESS模块，可以用导入过程（import procedure）和导入向导（Import Wizard）将Excel、Lotus、dBase和Access文件导入SAS数据集。
 如果没有安装，可以用存放数据的软件创建一个原始文件，并用数据步或导入过程（import procedure）读取。很多软件都可以创建CSV文件。
 Windows操作环境下也可以用动态数据交换技术（Dynamic Data Exchange，DDE）。前提是必须有一个其他的Windows程序与SAS同时运行，再使用DDE和数据步。
直接读取其他软件的数据集
 SAS/ACCESS产品可以不用转换数据格式读取数据，并适用于大部分数据库管理系统，包括ORACLE,DB2,INGRES和 SYBASE（但使用方法本书没有介绍）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/116f07b4c6c36541e72dbae75a3464ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3738d1cba9f4734e859126ba03bbf359/" rel="bookmark">
			django 跨域报错(corsheaders.E013)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		?: (corsheaders.E013) Origin '127.0.0.1:8080' in CORS_ORIGIN_WHITELIST is missing scheme or netloc
HINT: Add a scheme (e.g. https://) or netloc (e.g. example.com).
自己在学习的时候在django跨域的时候，默认设置如下
'127.0.0.1:8080', 'localhost:8080', 'www.meiduo.site:8080', 'api.meiduo.site:8000', 按照提示给网址加上http
'http://127.0.0.1:8080', 'http://localhost:8080', 'http://www.meiduo.site:8080', 'http://api.meiduo.site:8000' 再次启动即可正常启动
Access to XMLHttpRequest at 'http://api.meiduo.site:8000/sms_codes/13007549056/?text=p86i&amp;image_code_id=f0db0f9c-65d9-4826-a73f-97ad04626725' from origin 'http://api.meiduo.site:8080' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
报这个错误意思是自己跨域的时候地址写错了
'http://127.0.0.1:8080',
'http://localhost:8080',
'http://www.meiduo.site:8080',
'http://api.meiduo.site:8000'
上文中的 'http://api.meiduo.site:8000' -&gt; 'http://api.meiduo.site:8080'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ec4ceace52e101b4569759aa0eeb90/" rel="bookmark">
			系统设计六大原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SOLID 原则：
S 单一职责原则 单一责任，一个类只负责一个职责。(single responsiblity)
O 开闭原则 对继承和发展开放，对修改关闭。(open and close)
L 里式替换原则 子类可是替换父类 （Liskov substituation principle）
L 迪米特法则 尽可能的少知道其他类，目的在于降低耦合，减少类之间的依赖关系 (Low of demeter)
i 接口隔离原则，实现最小接口，使接口类不包括多余的方法，子类不用实现用不上的方法 (interface )
D 依赖倒置原则 (dependency reverse)
至于以上六个原则如何在实际中应用，后面我也将详细讲解。下面将会继续学习23种设计模式。
设计模式总共分为三个大类：创建型，结构型，行为型。
1.创建型： 5种，工厂方法，抽象工厂，单例，建造者，原型
2.结构型：7种，适配器，装饰器，代理，外观，桥接，组合，享元
3.行为型：11种，策略，模板方法，观察者，责任链，命令，备忘录，状态，访问者，中介者，解释器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4de6828f0c80f84b9c6274b3bd857b89/" rel="bookmark">
			若图片链接失效请转 AIUAI.CN - https://www.aiuai.cn 相应博文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于以前采用的 markdown 写的，图片放在了微博图床，自2019.04 月份开始，微博开启了防盗链，导致早期博文图片失效，出现 403 错误. 替换的话工作量比较大，另一方面，CSDN 体验越来越坑，现在主要是使用自建博客 - AIUAI.CN，一般都会有对应的博文，且会随时更新、更改、重新编辑文章. 非常欢迎访问交流学习.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5ae930043e755d34f7844dbd68b7197/" rel="bookmark">
			问题与解决error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No suc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		openssl version
提示：/usr/local/openssl/bin/openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory
这是由于openssl库的位置不正确造成的。
可以做一个软连接假如你的libssl.so.1.1
文件在/usr/local/openssl/lib/下面，
可以这样做
ln -s /usr/local/openssl/lib/libssl.so.1.1 /usr/lib64/libssl.so.1.1
ln -s /usr/local/openssl/lib/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1
这时
openssl version得
openssl versionOpenSSL 1.0.1e-fips 11 Feb 2013
如果要删除软连接直接删掉就好
rm /usr/lib64/libcrypto.so.1.1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35efcee680bd6cd5f59c4ae006e63634/" rel="bookmark">
			Github 项目 - OpenPose Python API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenPose 的 Python 模块提供了 Python API，可以用于构建 OpenPose 类(class)，其输入是 numpy array 格式的图像，并得到 numpy array 格式的 Pose 位置估计.
该 Python API 还提供了直接从网络(network)得到的 heatmaps 作为输入，并提取出 pose 关键点(需要安装 Caffe Python接口).
现阶段，Python API 仅支持 Body 姿态估计，Hands 和 Face 将来会支持.
最近发现新近版本的 OpenPose v1.5.0 更新了 Python API 的例示.
可分别参考：
[1] - Github 项目 - OpenPose Python API - AIUAI
[2] - Github 项目 - OpenPose Python API V1.5.0 - AIUAI
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d05f64677f583f6f0cfb6f7cc4ebe722/" rel="bookmark">
			OpenCV - 计算相机和视频的帧速率FPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：OpenCV - 计算相机和视频的帧速率FPS[译] - AIUAI
原文：How to find frame rate or frames per second (fps) in OpenCV ( Python / C++ ) ? - 2015.11.12
OpenCV 库中的 VideoCapture 类主要处理视频读取以及从连接的相机中获取图像帧.
基于VideoCapture 中的 get(PROPERTY_NAME) 方法可以获取到视频文件的很多信息. 其中，关于视频的最常用的属性是帧速率(frame rate)，也叫每秒帧数(frames per second).
1. 计算相机的帧速率FPS OpenCV 并不能很直接的得到所连接的相机(camera/webcam) 的帧速率.
在 OpenCV 的文档中，所述的是，get(CAP_PROP_FPS) 和 get(CV_CAP_PROP_FPS) 方法给出了每秒帧数. 这对于视频文件而言是正确的，但是并不适用于 webcams. 对于webcams 以及许多其它 cameras，不得不手工计算每秒的帧数. 可以从视频中读取一定量的视频帧，然后根据所耗时间，计算得到每秒帧数.
1.1. Python 实现 #!/usr/bin/env python #! --*-- coding:utf-8 --*-- import cv2 import time if __name__ == '__main__' : # 启动默认相机 video = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d05f64677f583f6f0cfb6f7cc4ebe722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4086515aa8b2445d1b5e8ae892a3a30c/" rel="bookmark">
			Linux内核中使用crypto进行sha1方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编写Linux驱动的时候常常需要对内核空间的某些数据进行hash计算，而在编写内核模块的时候很多用户空间的方法不能使用，例如Openssl(理论上可以，但是我没成功过)。但是Linux自身提供了一个Crypto API对数据进行各种加密计算，使用这个API就能够在内核模块中进行一些加密和签名操作，下面以sha1位例子。
在4.15内核下编译加载通过。
头文件需要包含：
#include &lt;crypto/hash.h&gt; #include &lt;crypto/skcipher.h&gt; #include &lt;linux/crypto.h&gt; struct sdesc { struct shash_desc shash; char ctx[]; }; static struct sdesc *init_sdesc(struct crypto_shash *alg) { struct sdesc *sdesc; int size; size = sizeof(struct shash_desc) + crypto_shash_descsize(alg); sdesc = kmalloc(size, GFP_KERNEL); if (!sdesc) return ERR_PTR(-ENOMEM); sdesc-&gt;shash.tfm = alg; sdesc-&gt;shash.flags = 0x0; return sdesc; } static int calc_hash(struct crypto_shash *alg, const unsigned char *data, unsigned int datalen, unsigned char *digest) { struct sdesc *sdesc; int ret; sdesc = init_sdesc(alg); if (IS_ERR(sdesc)) { pr_info("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4086515aa8b2445d1b5e8ae892a3a30c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc66de8e08c7a7baf1c09b8226d54f8/" rel="bookmark">
			STM32中位变量的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于STM32没有位处理，所以STM32不像51单片机一样支持BIT变量，下面教大家怎么在STM32中实现位变量
1、首先定义一个结构体
typedef struct { unsigned char b0:1; unsigned char b1:1; unsigned char b2:1; unsigned char b3:1; unsigned char b4:1; unsigned char b5:1; unsigned char b6:1; unsigned char b7:1; } BIT8; 2、然后宏定义就行
unsigned char addrNewCode; #define addrNewBit0 (((BIT8*) &amp; addrNewCode) -&gt; b0) #define addrNewBit1 (((BIT8*) &amp; addrNewCode) -&gt; b1) #define addrNewBit2 (((BIT8*) &amp; addrNewCode) -&gt; b2) #define addrNewBit3 (((BIT8*) &amp; addrNewCode) -&gt; b3) #define	addrNewBit4 (((BIT8*) &amp; addrNewCode) -&gt; b4) #define addrNewBit5 (((BIT8*) &amp; addrNewCode) -&gt; b5) #define addrNewBit6 (((BIT8*) &amp; addrNewCode) -&gt; b6) #define addrNewBit7 (((BIT8*) &amp; addrNewCode) -&gt; b7) 3、这样的话addrNewBit0 等等就能当成位变量使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a191a7f29693156e6944bfdebcbe2e7/" rel="bookmark">
			AS使用protobuf序列化方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		protobuf是google开源的序列化解决方案，本文只做记录配置，具体自行百度
protobuf的AS插件地址
https://github.com/google/protobuf-gradle-plugin 1 在AS项目根目录下的 build.gradle dependencies下 增加classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.8'
2在app目录下的build.gradle配置 apply plugin: 'com.google.protobuf' protobuf {//和android同级 protoc { artifact = 'com.google.protobuf:protoc:3.0.0' } plugins { javalite { artifact = 'com.google.protobuf:protoc-gen-javalite:3.0.0' } } generateProtoTasks { all().each { task -&gt; task.builtins { remove java } task.plugins { javalite { } } } } } 3 最后dependencies下加入implementation 'com.google.protobuf:protobuf-lite:3.0.0' 最后编写 .protobuf文件 buidl项目 将会在app\build\generated\source\proto\debug\javalite 下生成相应的class文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64e70a28c5f48f6a1eafc357fb44e67a/" rel="bookmark">
			（九）基于face&#43;&#43;的人脸识别功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一章我们使用完成了人脸的检测功能，这一次我们要完成人脸识别，也就是识别不同的人脸。当摄像头识别到有人脸的时候，就会抓拍这张图片，并在事先准备好的人脸库中进行查找匹配，判断这张人脸是否与库中的某一人脸匹配，如果有，匹配成功，如果没有，匹配失败。
OpenCV有官方的人脸检测haar算子，检测的人脸还算比较准确，但是官方的人脸检测算法的正确率就比较低了，这在正式投产的时候是绝对不允许的，所以我们不能使用官方的人脸识别算法。那么只有两条路可以走了，第一，自己写一个识别率较高的人脸识别算法，还有人脸查找比对算法，这种方法对工程师的要求就极其的高了，一般光一个人是难以完成的。第二，使用别人已经完善的算法，通过API接口进行调用。
第二种方法是比较可行的，在对比了互联网上几家比较有名的机器视觉公司，我最后选择了旷视科技的face++来完成这次的任务。
首先，face++可以申请开发者账号，并且有一个免费的key密钥，而且大部分功能都可以使用，速度和正确率都很不错。（最重要的是可以免费使用，对于在校开发者来说，实在无法抵御）
二话不说，感觉先去官网注册个账号
https://console.faceplusplus.com.cn
至于API文档我就不细说了，这个还是要大家仔细看一遍才能领悟。
Face++的API是基于HTTP的POST方法进行访问，并且会返回JSON格式的数据。而且官方友好的给出了实例和SDK，SDK都给了，还有比这更友好的吗？二话不说，赶紧下载一个。
我使用QT进行开发，所以下载C++接入工具，这个接入工具是一个打包好的代码包，用户不需要知道POST的具体格式，也不需要知道如何发起POST访问，只需要通过调用SDK里面的函数，将需要的参数传进去，SDK就会帮你完成所有与网络访问有关的代码，并且返回JSON格式的字符串。是不是十分的友好，减少了很多开发遇到的问题。
接下来我说一下识别一个人脸的具体流程。代码我这里就不展示了，可以直接去github里下载。API参数自己看官方给的文档吧。
首先我们要创建一个人脸库，免费用户可以创建1000个库，每个库可以存放1万个人脸，肯定是足够用了。创建人脸库的API文档如下
https://console.faceplusplus.com.cn/documents/4888391
创建完成后会返回一个标识符face_tokens，这个一定要记下来，他是这个人脸库的唯一标识符，之后的添加人脸，删除人脸，搜索全部要用到他。
然后往人脸库添加一个人脸
https://console.faceplusplus.com.cn/documents/4888373
使用detect API，传入一张图片（这张图片可以从本地读取，传入图片的地址），他会返回这张图片的唯一标识符face_token，接着使用增加人脸的API
https://console.faceplusplus.com.cn/documents/4888389
将刚刚返回的faceset_token传入，face_tokens传入人脸库的，这样就将这张照片中的人脸特征添加到了人脸库中。
如何搜索人脸
使用人脸搜索的API
https://console.faceplusplus.com.cn/documents/4888381
image_file传入需要对比的图片，faceset_token传入人脸库的识别符。
返回值是人脸库中与传入图片最相思的face_token标签，可以通过confidence和thresholds参数来确认是否为同一个人，也可以将人脸库中的face_token都记录在本地，然后进行遍历，就可以确认扫脸人的身份了。
注意的问题 因为我是在Ubuntu环境下进行开发，在移植SDK的时候碰到一些问题，官方给的SDK中，curl的库是不能用的，导致编译时报错，我的解决方法如下
apt-get install libcurl4-openssl-dev 然后在qt的.pro文件中加入
/usr/lib/x86_64-linux-gnu/libcurl*.so* 还有JSONCPP库在Ubuntu环境下也有问题，但是QT自带了JSON库，所以我就没有用官方SDK中的JSON库。
完整的源码放在github上，有需要可以自行下载。 代码名称为190526.zip
https://github.com/ljy980330/opencv_face_sys
有任何问题可以在下面给我留言！大家一起学习！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bace4f429d5822a58df39c43831dda5e/" rel="bookmark">
			【转载】CentOS 7自动以root身份登录gnome桌面  操作系统开机后自动登录到桌面 跳过GDM...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7自动以root身份登录gnome桌面
###################
#cd /etc/gdm
]# cat custom.conf
# GDM configuration storage
[daemon]
AutomaticLoginEnable=True
AutomaticLogin=root
[security]
[xdmcp]
[chooser]
[debug]
# Uncomment the line below to turn on debugging
#Enable=true
[root@localhost gdm]# pwd
/etc/gdm
######################################
刚刚在虚拟机中成功的安装上了CentOS 7 64位，发现在登录gnome桌面时必须创建一个普通用户，否则不让登录。
重启CentOS发现下方藏有一个使用其他用户登录选项，可以输入用户名使用root登录。
流畅且犀利的操作了一会儿，感觉很爽XD。想以后都用root登录，反正不是用于生产环境的服务器而是VMware虚拟机，有着强大的快照功能，随时可以恢复到上一个快照。好，赶紧进入正文。
1. 配置root自动登录gnome
在配置的时候会遇到GDM：
GDM是什么？
GDM (The GNOME Display Manager)是GNOME显示环境的管理器，并被用来替代原来的X Display Manager。与其竞争者(X3DM,KDM,WDM)不同，GDM是完全重写的，并不包含任何XDM的代码。GDM可以运行并管理本地和远程登录的X服务器(通过XDMCP)。
gdm仅仅是一个脚本，实际上是通过他来运行GDM二进制可执行文件。
gdm-stop是用来迅速终止当前正在运行的gdm守护进程的一个脚本。
gdm-restart脚本将迅速重启当前守护进程。
gdm-safe-restart会当所有人都注销后再重启。
gdmsetup是一种可以很简单的修改多数常用选项的图形化界面工具。
百度上搜到的都是RHEL、CentOS 6的配置方法，并不适用于CentOS 7。我在此贴出供各位看官参考：
在CentOS 6较新版本的Linux发行版中预设不允许以root账号登入gnome图形用户桌面，因此一般使用者登入后，可以在终端机以su root，暂时取得root权限；
如果一定要以root登入图形界面，可以修改/etc/pam.d/gdm以及 /etc/pam.d/gdm-passwd，把这行auth required pam_succeed_if.so user != root quiet加上#注释掉，保存后就可以用root账号了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bace4f429d5822a58df39c43831dda5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1525c8bf98317bbdcd61c9d31614fd77/" rel="bookmark">
			Huffman编码效果的唯一性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7个字符{A，B，C，D，E，F，G}，这7个字符在文本中出现的次数为{5，24，7，17，34，5，13}
在构造霍夫曼树的时候发现会出现两个17，这时就有两条路可以走下去，当然，因为树的不固定会有若干种结果，比如你的A是10110，他的A是00000，但就编码长度而言都是5，这里说的两条路就是A的长度可以为4也可以为5，最后总的效果还是一样的。
第一种编码方式
A：0010 B：01 C：000 D：101 E：11 F：0011 G：100 平均码长：(5*4+24*2+7*3+17*3+34*2+5*4+13*3)/105=2.542857143
第二种编码方式
A：00000
B：11
C：0001
D：10
E：01
F：00001
G：001
平均码长：(5*5+24*2+7*4+17*2+34*2+5*5+13*3)/105=2.542857143
可以看到平均码长都是一样的 2.542857143，小于不压缩的长度3。
#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; double func(double x){ return -x*log2(x); } int main() { double a=(double)5/105,b=(double)24/105,c=(double)7/105,d=(double)17/105,e=(double)34/105,f=(double)5/105,g=(double)13/105; cout&lt;&lt;func(a)+func(b)+func(c)+func(d)+func(e)+func(f)+func(g); } 计算了一下信息熵为 2.49066，可见霍夫曼编码效果不错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4db84e37dd2c2144b60a68364f6c135/" rel="bookmark">
			iphone备忘录自带的扫描功能扫完文件后如何保存为图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：https://zhidao.baidu.com/question/2122390808329146227.html
材料/工具：iPhoneX。
具体操作有如下几个步骤：
一、打开“备忘录”后点击下方的“添加”进入。
二、选择“扫描文稿”进行点击。
三、将“扫描框”对准文稿，调整完成后点击“继续扫描”。
四、然后点击“存储”进行下一步操作。
五、此时的照片还是“PAF格式”的，不能进行存储。然后对照片进行点击。
六、点击“照片"后可以单独进行查看，然后长按照片点击”拷贝“。
七、新建一个”备忘录“，粘贴照片后点击上方的”分享“按钮。
八、最后选择“存储图像”就可以在相册中查看了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdf2cedb22ebf171e76779cfa053c1d1/" rel="bookmark">
			vue源码解析3——数据劫持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3 数据劫持 数据劫持是vue中用来实现数据绑定的一种技术，通过defineProperty()来监视data中所有属性(任意层次)数据的变化, 一旦变化就去更新界面。
function Watcher(vm, exp, cb) { this.cb = cb; // &lt;1&gt;保存回调函数，主要用与更新节点 this.vm = vm; this.exp = exp; this.depIds = {}; // 声明dep容器 用来存放dep this.value = this.get(); } Watcher.prototype = { update: function() { this.run(); }, run: function() { var value = this.get(); // var oldVal = this.value; if (value !== oldVal) { this.value = value; this.cb.call(this.vm, value, oldVal); // &lt;2&gt;调用回调函数更新对应的界面 } }, addDep: function(dep) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdf2cedb22ebf171e76779cfa053c1d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac7b812a8e0dcbf7882f223eb1d1d85/" rel="bookmark">
			HTML选择框的联动模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以省市为例：
在这里插入代码片 ```&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;省市联动&lt;/title&gt; &lt;/head&gt; &lt;body onload="add()"&gt; &lt;select name="" id="province" onchange="setCity()"&gt; &lt;/select&gt;省 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;select name="" id="city" &gt; &lt;/select&gt;市 &lt;script type="text/javascript"&gt; &lt;!-- 设置省市信息 --&gt; var provinceList=['河南','山西','河北']; var cityList=[['郑州','驻马店','许昌'],['太原','大同','晋中'],['唐山','石家庄','邢台']]; //使得页面打开就填充省数据 function add(){ var sel=cz("province"); //遍历,添加到省数据里 for(var i=0;i&lt;provinceList.length;i++){ var op=document.createElement("option"); op.text=provinceList[i]; sel.add(op); } } //设置city select内容 function setCity(){ //获取选中的省级列表index var sel=cz("province"); // alert(sel.selectedIndex); //通过省级列表index 获取市级列表集合 var ccList=cityList[sel.selectedIndex]; //清空city select 中的option cz("city").innerHTML=" "; 遍历cityList 将内容设置进入city select for(var i=0;i&lt;ccList.length;i++){ var op=document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ac7b812a8e0dcbf7882f223eb1d1d85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5affc9231775797133cb79e40a99f7f9/" rel="bookmark">
			RoundCube部署过程中，测试时提示IMAP错误处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RoundCube部署过程中，测试时提示IMAP错误处理
背景：Postfix+Dovecot+PostfixAdmin+RoundCube，采用虚拟域的方式，进行邮箱部署。
错误表现：
1）在RoundCube安装步骤三中，
Test IMAP config
Server 127.0.0.1 （在安装的步骤二中，可配置Server对应IP地址“127.0.0.1”数值）
Port 143 （在安装的步骤二中，可配置Port对应的端口“143”数值）
Username （确认用户名正确）
Password （确认密码正确）
在确认用户名和密码没有错误的情况下，点击"Check login"，提示错误，无法登录（具体信息不记得了）
2）访问Roundcube登录页面，填写用户名和密码后，登录提示，IMAP错误。在日志文件（/var/log/mail.err）中，可找到如下错误信息
mail dovecot: lmtp(x, x@x.com): Error: User initialization failed: Namespace ' ': stat(x/x/x.com/x) failed: Permission denied (euid=x(x) egid=x(x) missing +x perm: /x/x/x.com, dir owned by x:x mode=x)
初步判断：
不是密码错误，不是IMAP错误，是uid/gid无法访问邮件存储目录的权限导致提示错误
解决方法：
sudo chown -R uidName:gidName /x/x
其中，uidName，用户名，例如virtual；gidName，用户组名，例如virtual。/x/x为邮件存储目录的路径，可指向到域名。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3824ff3c7c3b657abff4812b15a572f3/" rel="bookmark">
			微信h5网页点击链接跳转到默认浏览器是怎么弄的？Mindjump为您深度解答实现教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多朋友不知道如何实现微信h5网页点击链接直接跳到默认浏览器的功能是如何实现，经常能在各大论坛看到这样的提问，故特写了这篇文章分享一下之前在网上看到的一个在线使用该功能的平台的操作方法。
Mindjump在线操作步骤
首先用浏览器打开我们需要用到的 Mindjump 地址:http://www.mindjump.cn ,然后将你的链接输入工具框，点击生成，然后复制新生成的跳转链接和二维码，最后在微信内打开跳转链接或扫码识别二维码
这个平台最大的亮点就是无论你的链接是否已经被拦截都可以正常使用接口从微信内跳到外部浏览器访问。是不是觉得特别赞，觉得好就分享给更多的朋友知道吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a390e45919b88a46a7a42909bb1dfacb/" rel="bookmark">
			RFB-Net论文代码映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、网络部分
Vgg网络 代码实现如下：
layers = [] # i=3,说明图像是3通道 in_channels = i # cfg：[64, 64, 'M', 128, 128, 'M', 256, 256, 256, 'C', 512, 512, 512, 'M', # 512, 512, 512] for v in cfg: if v == 'M': layers += [nn.MaxPool2d(kernel_size=2, stride=2)] elif v == 'C': layers += [nn.MaxPool2d(kernel_size=2, stride=2, ceil_mode=True)] else: #不用管in_channels取值，默认stride=1，故不改变特征图大小 conv2d = nn.Conv2d(in_channels, v, kernel_size=3, padding=1) if batch_norm: layers += [conv2d, nn.BatchNorm2d(v), nn.ReLU(inplace=True)] else: layers += [conv2d, nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a390e45919b88a46a7a42909bb1dfacb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c4f293ad259879881c4ccf0ececbc4a/" rel="bookmark">
			github 搜索技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、in
springcloud in:name,description,readme //搜索项目名字，描述，自述文件中含有springcloud的项目 2、stars
springcloud stars:&gt;=500 //搜索star数大于等于500的springcloud的项目 springcloud stars:100..500 //搜索star数在100-500的springcloud的项目 3、forks
springcloud forks:&gt;=500 //搜索fork数大于等于500的springcloud的项目 springcloud forks:100..500 //搜索fork数在100-500的springcloud的项目 4、awesome
awesome springcloud //搜索springcloud相关的学习项目 5、location
location:beijing //搜索地址在北京的用户 6、language
language:java //搜索开发语言是java的用户 7、#L
// 高亮显示第几行代码，在具体文件后面加上此后缀 https://github.com/ityouknow/spring-boot-examples/blob/master/spring-boot-elasticsearch/pom.xml#L26-L36 以上可混合搭配使用：
springcloud stars:&gt;1000 forks:&gt;1000 language:java 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4362dc98f3feee44eaabe41b63953bf4/" rel="bookmark">
			C# CheckedListBox控件的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.加入项 checkedListBox1.Items.Add("蓝色"); checkedListBox1.Items.Add("红色"); checkedListBox1.Items.Add("黄色");
2. 推断第i项是否选中,选中为true,否则为false
if（checkedListBox1.GetItemChecked(i)）
{
return true;
}
else
{
return false;
}
3. 设置第i项是否选中
checkedListBox1.SetItemChecked(i, true); //true改为false为没有选中。
4. 设置全选 加入一个名为select_all的checkbox控件，由其控制checkedListBox是全选还是全不选。
private void select_all_CheckedChanged(object sender, EventArgs e) { if(select_all.Checked)
{
for (int j = 0; j &lt; checkedListBox1.Items.Count; j++) checkedListBox1.SetItemChecked(j, true);
}
else
{
for (int j =0; j &lt; checkedListBox1.Items.Count; j++) checkedListBox1.SetItemChecked(j, false);
}
}
5.得到所有选中的值 ，并将选中的项的文本组合成为一个字符串。
string strCollected = string.Empty;
for (int i = 0; i &lt; checkedListBox1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4362dc98f3feee44eaabe41b63953bf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3088e984db2d4121024ec1aa690f4095/" rel="bookmark">
			SPM12入门案例2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Face fMRI data 要求实验者通过按键来判断知名度。因此这里有4种兴趣的类型；第一二步显示出有知名度和没有知名度的人脸，代表着N1,N2,F1和F2。
###准备工作
通过EPI获得图像，其中回复时间TE=40ms，重复时间TR=2s，24个下降的切片，3mm厚和1.5mm间距。数据获取：Face Repetition dataset创建face_rep的文件夹用来存放分析的结果，创建4个子文件夹jobs存,categorical,parametric,bayesian。 除了分类和贝叶斯的区别，我们还将展示如何从参数和分类的角度分析这些数据。具体基础详见上节
Spatial pre-processing Display 点击Display显示图片，注意眶额部(orbitofrontal)和颞下部的缺失和重影。点击Brighten能够更清晰的看到图片
Realignment 在SPM基本窗口的空间预处理部分中，从REALIGN的下拉菜单中选择**Realign (Est &amp; Res) **。选择data,然后点击New Session创建新的Session，在数据集test_face_rep下的RawEPI中选择351个图片。保存批处理命名为realign.mat，点击Run运行，在源文件夹下产生functional image并且以r为前缀命名，然后SPM将估算的绘制出translation和rotation的时间序列图。重新分配的参数的数据将被存储于类似rp_sM03953_0005_0006.txt，当拟合广义线性模式时(GLMs)这些变量可以作为回归量(regressors)。在寻找大脑活动时，运动产生的影响能够被忽略。
在spatial processing - coregistration中，SPM将产生mean image。 Slice timing correction 点击Slice Timing按钮，弹出批处理窗口。这些数据由TR=2s并且N=24个连续采集的轴向切片按照递减的序列组成，并且按照逆序的序列获得。
注意:TA=(TR-TR/N)
点击Data然后选择New Session，过滤并且选择**^r.***的文件总共351个文件Number of Slices输入24，表示连续采集的轴向切片TR=2,TA=(2-2/24)Slice order输入24?1,Reference Slice输入12保存为slice_timing.mat点击运行，产生默认前缀是a的slice-time校准的文件。在RawEPI文件夹下形成 Coregistration 在Coregister的下拉菜单中选择COREGISTER(ESTIMATE)。Reference Image选择RawEPI文件夹下的meansM03953_0005_0006.img，Source Image中选择结构图像在Structural的sM03953_0007.img保存为coreg.job然后点击Run按钮
然后SPM将实现结构数据与功能数据之间的配准，即最大化实现共同的信息。
左侧为Reference Image右侧为Source Image Segmentation 点击SEGMENT按钮，点击Volumes，选择Structral中的配准后的实验者解剖图像sM03953_0007.img。将Save Bias Corrected中的Save Nothing修改为Save Bias Corrected，在最下面的**“Deformation Fields中的值由Nothing修改为Forward**。保存为segment.mat，点击运行按钮。SPM将使用默认的组织概率图作为先验对结构图像进行分割。SPM将产生灰质、白质的图像和偏磁场校正的结构图像。通过使用Check Reg工具能够显示这些图片。选择Structural中c1sM03953_0007.nii的灰质图像与原始的结构图像sM03953_0007.img，并将产生空间正则化图像y_sM03953_0007.nii
Normalise 选择Normalise(Write)按钮，点击Data，然后点击New Subject点击Deformation Field，选择y_sM03953_0007.nii按钮点击Image to write选择经Slice timing corrected处理过的351个文件以及在realign期间生成的平均功能图像e meansM03953_0005_006.img将Voxel size从[2 2 2]修改为[3 3 3]保存为normalise.mat 并运行程序。在RawEPI文件夹下生成带有前缀w的spatially normalised文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3088e984db2d4121024ec1aa690f4095/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a7222699383502e2f3deb0332efdd9/" rel="bookmark">
			RTL-SDR（电视棒）——收听FM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SDR基本概念 软件定义的无线电(Software Defined Radio，SDR) 是一种无线电广播通信技术，它基于软件定义的无线通信协议而非通过硬连线实现。 一、初期准备 1. 软件基础 ①zadig.官网下载最新版驱动，勾选“List All Devices”即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7abbdd26491d4b61fd0c667c908ff40a/" rel="bookmark">
			这33篇区块链必读论文, 读过5篇以上的竟不到1%
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | Bhaskar Krishnamachari
译者 | Guoxi
责编 | Aholiab
出品 | 区块链大本营（blockchain_camp）
区块链行业中，很多开发者都是半路出家的，想要成为区块链的「正规军」并非易事。
不少人想到要向学术界“取取经”。看看学术界是怎样培养区块链人才的？学术圈又如何入门区块链？
为此南加州大学教授 Bhaskar Krishnamachari 结合自己的授课经验，为我们带来了这份来自学术界的区块链入门圣经。
让我们看看，南加州大学教授的书单上，都有哪些必读资料吧。
在我的区块链学习和教学生涯中，我精心挑选并标注了一些令人眼前一亮，值得一读的论文和文献，现在将它们整理出来，希望它们可以帮你拨开眼前迷雾，帮你了解区块链和去中心账本技术的起源以及最新的研究成果。
区块链技术的初学者往往会淹没在各种想法、协议标准、白皮书的汪洋大海中，而且初学者往往缺乏鉴别的能力，因而通常会在那些毫无干货的“垃圾”中浪费过多的时间。
这也是我刚入门时的写照，在我这两年的学习中，通过不断踩坑锻炼了我的鉴别能力，到现在我已经能很好地确定和理解区块链领域中的主次。
这两年里，我还在南加州大学开设了一门区块链的课程，并面向研究生创建了一个区块链研究的读书小组。在教学生涯中，我积累了很多的经验，并将这些经验整理成了本篇文章。
我认为，区块链初学者最开始应该学习大而广的区块链知识，打好基础后再选择一个感兴趣的方向深入研究，这样能激发初学者更多的可能。
因此在本篇文章中我对各个区块链协议雨露均沾，并没有针对某个主流的区块链“打破砂锅问到底”。
现在让我们开始吧~
入门：那些必读的白皮书
这一部分都是经典的区块链开山之作，相信读完了这些你就会对区块链有了初步的了解。
1.《比特币：一个点对点的电子现金系统》：中本聪（ Satoshi Nakomoto ）在 2008 年发表的这篇论文开创了区块链的时代。论文中中本聪革命性地将哈希链、公钥加密、使用工作量证明进行去中心化的共识、最长链机制、挖矿激励等几个核心要素有机结合，赋予区块链巨大的能量。这篇论文可谓是所有区块链从业者的入门必读，当然了，如果你读起来吃力的话，可以在网上找一下翻译的版本。 *地址：
https://bitcoin.org/bitcoin.pdf
区块首尾相连就组成了区块链
2.《以太坊：下一代智能合约和去中心化应用程序平台》：准确地说，这是一本白皮书，它介绍了以太坊这个 2015 年面世的基于状态机的第二代区块链协议。以太坊拥有一个（准）图灵完备的虚拟机，它支持在区块链上进行计算，并以”燃料费用”计价，用户可以在以太坊上运行脚本（虽然这种表述有些误导性），也就是我们常说的智能合约。
*地址：
https://github.com/ethereum/wiki/wiki/White-Paper
3. 《 Hyperledger Fabric：基于私有区块链（也叫许可区块链）的去中心化操作系统》：这是一篇 2018 年发表的同行评审文章，它介绍了当下最受欢迎的私有区块链 Hyperledger Fabric 的架构。与比特币和以太坊这些公有区块链不同，私有区块链是封闭的，只有得到许可的用户才能参与其中。这篇文章论证了将交易的执行过程与交易的验证过程分离，以及不等交易完成验证就执行交易的好处。Hyperledger Fabric 的共识机制可以支持定制化，模块化的设计。
*地址：
https://arxiv.org/pdf/1801.10228.pdf
Hyperledger Fabric 架构
4. 《 Tendermint：关于拜占庭容错共识算法的最新进展》：这是一篇 2018 年发表的论文，文章中提出了简化的拜占庭容错（ Byzantine Fault Tolernant ，BFT ）共识协议。这个改进的协议需要多回合的执行，每一个回合都会有一个专门的提议者。协议为便于理解和实现做出了优化，在提议者不表现出恶意行为且通信不受影响的理想情况下，它只需执行三个回合就能达成共识。同时，文章中提供了协议正确性的形式化证明。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7abbdd26491d4b61fd0c667c908ff40a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378072b60deda859e4c0dc913038d7e9/" rel="bookmark">
			SLAM——数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数据集
1-1 超级全的SLAM数据集
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/671036424f2095f319d446e6d722cb89/" rel="bookmark">
			SVG  stroke-dasharray 、stroke-dashoffset
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stroke-dasharray stroke-dasharray用来绘制路径虚线。可以有一个或者多个参数，下面看一下它在不同参数下的效果。
1.不添加stroke-dasharray属性
#rect { stroke-width: 6px; fill: yellow; stroke: red; /*stroke-dasharrry:10;*/ } &lt;svg height="100" width="300"&gt; &lt;rect id="rect" height="100" width="300" /&gt; &lt;/svg&gt; 图1：矩形的边框为实线
2.一个参数
stroke-dasharray:10; 图2：矩形的边框为虚线。红色线段和间隙都是10px;
3.两个参数
stroke-dasharray:10 20; 图3：矩形的边框为虚线。红色线段:10px , 间隙是20px;
4.三个参数
stroke-dasharray:10 20 30; 图4：红色线段和间隙长短不一。从矩形绘制的起点左上角开始：红-&gt;10，间隙-&gt;20，红-&gt;30，间隙-&gt;10，…
可以发现它是以所给的参数为一个周期，从路径起点开始进行循环绘制。
stroke-dashoffset stroke-dashoffset 是对整条虚线从起点开始向相反的方向做偏移。
stroke-dashoffset:100; 图5：向反方向偏移100px;
应用： stroke-dashoffset动画
#rect { stroke-width: 6px; fill: #fff; stroke: red; stroke-dasharray: 20; animation: path-animation 5s; animation-timing-function:linear; animation-iteration-count:infinite; } @keyframes path-animation { from { stroke-dashoffset: 100%; } to { stroke-dashoffset: 0%; } } 动画效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c3f8c5b8d38ffea22b1c922108c7e99/" rel="bookmark">
			C#网络编程学习(4)---Socket Tcp进阶之 使用异步循环接收客户端连接和信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、方法介绍 BeginAccept(AsyncCallback callback, object state);
异步开始监听客户端连接。
callback为一个委托，在成功接收客户端连接时调用委托方法。向委托方法中传递的参数 EndAccept (IAsyncResult result);
结束监听客户端连接，一般在委托中成功接收连接后使用。
result：它存储此异步操作的状态信息以及任何用户定义数据。
返回。使用result.AsyncState 可以接收传递过来的参数。 BeginReceive (byte[] buffer, int offset, int size, SocketFlags flag, AsyncCallback callback, object state);
异步接收服务器发送来的数据
存储接收的数据从buffer哪开始存储数据要接受最大的字节数SocketFlags 值的按位组合接收成功后调用的委托方法要传递的参数 2、服务器端 namespace Tcp服务器端 { class Program { /// &lt;summary&gt; /// 接收客户端发送数据数组 /// &lt;/summary&gt; static byte[] data = new byte[1024]; static void Main(string[] args) { StartServerAsync(); } static void StartServerAsync() { Socket serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); EndPoint point = new IPEndPoint(IPAddress.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c3f8c5b8d38ffea22b1c922108c7e99/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/405/">«</a>
	<span class="pagination__item pagination__item--current">406/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/407/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>