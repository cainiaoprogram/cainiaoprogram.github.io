<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dafaee2a2e193a77d73803acdd2a69bf/" rel="bookmark">
			Scrcpy投屏软件教程（将手机内容投屏到电脑上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载投屏所需的资源 应用下载：去github下载最新的或你所需要的资源。
下载地址：[Genymobile/scrcpy: Display and control your Android device] ，网页最下方Assets里选择WIN版本32位/64位。
然后请按照你想连接手机的方式，选择有线连接或无线连接。
二、有线连接电脑和手机 1.将下载的资源解压缩到任意路径。
2.配置scrcpy应用的系统变量。
3.将手机与电脑用USB连接, USB连接方式选择传输文件。
4.打开手机开发者模式（华为手机为：设置 ==》关于手机 ==》点击版本号7次 ==》输入锁屏密码；华为鸿蒙系统的开发者选项在系统与更新选项里，其余手机打开开发者模式请自行百度 ），设置内系统与更新选项点击进入开发人员选项并打开USB调试功能。
5.快捷键 win + R打开cmd。
6.在命令行输入 adb devices,可以看到你的手机。
7.输入scrcpy，即可成功投屏你的手机。
三、无线连接（需数据线）** 步骤1.2.3.4.5与上面有线连接一样设置。
6.确保你的电脑和手机在同一wifi下，查看手机IP信息（华为手机IP查看路径为**：设置** ==》 关于手机 ==》状态信息 ==》IP地址，其余手机查看IP地址请自行百度）。
7.在命令行输入ping 192.168.0.100
(注：192.168.0.100需要替换为上方你的手机IP)
若数据包发送成功，则说明在同一局域网下。
8.输入adb tcpip 5555 回车；再输入adb connect 10.10.5.169:5555 回车，再输入adb devices 展示以下信息。
9.拔下数据线（此时可能你手机的USB调试可能自动关闭了，重新将其打开）再次输入adb devices 。若展示以下信息则说明你的设备是可以投屏的。
10.输入scrcpy，即可成功投屏你的手机。
四、无线连接问题总结 1.如果在第8步出现错误（cannot connect to x.x.x.x:5555“由于目标计算机积极拒绝，无法连接”），首先是否按要求设置好了以及通过第7步检测是否处于同一局域网，然后输入adb devices 查看设备状态，若显示设备不在线，请看问题2的解决方案。
2.如果在第h步拔下数据线后，
a.显示设备不在线（192.168.0.100：5555 offline)，首先检查第3步的设置是否符合要求，设置好后重新输入adb devices 若仍显示设备不在线，请从第2步重新设置。
b.若显示没有设备，请通过命令 adb connect 192.168.0.100，再输入adb devices 查看设备状态，若仍然无效，请从第2步重新设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dafaee2a2e193a77d73803acdd2a69bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9396044dd4ea3878bde976033ead1c51/" rel="bookmark">
			If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 今天在用spring boot弄个小项目，测试过程中突然报这个问题 If you want an embedded database (H2, HSQL or Derby), please put it on the classpath. 纳闷怎么突然启动就报错了，也没有改啥代码呀，于是上网搜搜，试了好多都没有解决，后来clean几次就好了，什么原因还是不知道，先记录下来，大概就跟下面这篇文章遇到的似的，好多方法只不是不能解决问题，但是解决不了自己的问题，哎，我也先记着 参考文章 如果遇到可以尝试下面文章的介绍，但是不敢保证能解决，但是不妨一试If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/984406388207441f9b1e0bed9d859118/" rel="bookmark">
			1.《剑指Java面试-Offer直通车》--计算机网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络
1. 物理层【传输比特流 模数/数模 网卡】
2. 链路层【封装成帧 SOH EOT、透明传输 增加转义字符、 差错检查 cro循环冗余】
3. 网络层【路由器的分组交换，有个转发表，知道下一条的路有】【MTU 】
————物理地址是数据链路层和物理层使用的地址。主机或者路由器收到MAC帧后，根据硬件地址决定是否需要接受
————ARP：高速缓存。广播出，单播回
4. 传输层【为应用进程提供通信】
5. 会话层
6. 表示层
7. 应用层
8. TCP【MSS 536】
————TCP和UDP在发送报文时，所采用的方式完全不同。TCP不关心应用进程一次把多长的报文发送到TCP缓存中，而是根据对方给出的窗口值和当前网络拥塞来决定一个报文段应该包含多少字节；UDP发送的报文长度是应用进程决定的，如果应用进程传送到TCP缓存的数据块太长，TCP就可以把它划分短一些再传送。如果应用进程一次只发送一个字节，TCP也可以等待累积足够多字节后再传送
————TCP下层网络提供的是不可靠的传输。因此：TCP必须采用适当的措施才能变得可靠【理想传输条件有两个特点：1. 传输信道不产生差错2. 不管发送方多快的发送数据，接收方总是来得及处理收到的数据 ————停止等待、连续ARQ、滑动窗口流量控制（让发送方发送的不要太快，接收方来得及接受）、Nagle算法、拥塞控制算法【慢开始、快重传（让发送方尽早知道个别报文段的丢失）】
————三次握手：【SYN、ACK CLOSED-》SYN_SENT-》LISTEN-》SYN_RECVED-》ESTABLISTED】【三次握手也可以变成四次握手】【保证数据序列正确、为了防止失效的报文浪费资源】
————SERVER没有收到三次握手的最后一次（SERVER会不断重试直到超时，Linux默认等待63s后超时） SYN FLOOD攻击：SYN队列满后，通过tcp_syncookies回发SYNC—COOKIE
————三次握手后，客户端故障，服务端触发保活机制【向对方发送保活探测包，如果未收到响应则继续发送，一定次数后中断】
————四次挥手：【FIN_WAIT-1、CLOSE_WAIT、FIN_WAIT2、LAST_ACK、TIME_WAIT】 2msl原因: 最后ack可以有效到达、本次连接相关的请求都可以在网络中消失
9. keep-alive
————Connection: keep-alive。【指定时间或者达到最大连接数就会断开】
————Transfer-Encoding - 分块传输和Content-Length【服务端和客户单都保持长链接，那么客户端如何知道此刻已经响应完成了呢？】有时候响应体长度不好获取
10. cookie. session
————用来跟踪浏览器用户身份的会话方式。cookie数据保存在客户端，session数据保存在服务端
11. Https
————什么是安全？A与B通信的内容，有且只有AB能看到通信的真正内容
————使用非对称加密算法对对称加密算法协商【为了不让对称加密算法被第三者知道。所以使用了随机数】
————使用非对称加密算法，服务器端发送公钥给客户端时，被中间人调包了，怎么办？【中间人攻击，无法确认返回公钥的是中间人还是真实的人。密码学的身份验证问题】——使用第三方机构的公钥
【所以，我们不能直接将服务器的公钥传递给客户端，而是第三方机构使用它的私钥对我们的公钥进行加密后，再传给客户端。客户端再使用第三方机构的公钥进行解密。】
————数字证书+数字签名 【XX.com 非对称公钥 md5】-》编码【第三方机构siyao加密】
一、网络基础知识讲解 OSI开放式互联参考模型 第1层 物理层
首先解决两台物理机之间的通信需求，具体就是机器A往机器B发送比特流，机器B能收到比特流。
主要作用是传输比特流（0101二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即常说的数模转化和模数转换。这层数据叫做比特。网卡工作在这层。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/984406388207441f9b1e0bed9d859118/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03185afc2c385d719a58dd716b210934/" rel="bookmark">
			构建YOCTO项目详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统要求 最少 4-8 GB 内存磁盘剩余空间至少 60-80 GB CentOS 7.6 或者其他支持Linux发行版
安装软件依赖（ CentOS-7）：
sudo yum install -y epel-release sudo yum makecache sudo yum install gawk make wget tar bzip2 gzip python3 unzip perl patch diffutils diffstat git cpp gcc gcc-c++ glibc-devel texinfo chrpath socat perl-Data-Dumper perl-Text-ParseWords perl-Thread-Queue python36-pip xz which SDL-devel xterm mesa-libGL-devel zstd lz4 -y sudo pip3 install GitPython jinja2 如果要构建Yocto项目文档手册，所需的包:
sudo yum install make python3-pip which -y sudo pip3 install sphinx sphinx_rtd_theme pyyaml 为了使用构建系统，主机开发系统必须满足Git、tar和Python的以下版本要求：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03185afc2c385d719a58dd716b210934/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b3103e03a749f68649b584d6c0422ef/" rel="bookmark">
			基于FPGA的MobileNet V2卷积神经网络加速器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MobileNet V2介绍 MobileNetV2是在V1基础之上的改进。V1主要思想就是深度可分离卷积。而V2则在V1的基础上，引入了Linear Bottleneck 和 Inverted Residuals。下图是MobileNet V2中的一个基本模块
可以看到，该模块由三个卷积组成，第一第三个卷积是标准的1x1卷积，起到升维和降维的作用，而中间的是一个depthwise卷积，每一个卷积层之后，都紧接着一个BN层，以加速网络的收敛。
同时，我们观察到，该模块的输入和输出有一个残差连接，即输入和最终的输出求和，这就是MobileNet V2中的Inverted Residuals，同时，我们注意到，第三个卷积层之后，并没有跟着一个激活函数，这就是上面所说的Linear Bottleneck，因为从高维向低维转换时，使用ReLU激活函数可能会造成信息丢失或破坏（不使用非线性激活数数）。所以在最后一个卷积之后，我们不再使用ReLU激活函数而是使用线性激活函数。
有了上边的基础，整体的网络结构就很好理解了，如下图所示
下图则是MobileNet V2和其他网络在参数量、计算复杂度方面的对比，可以看到，MobileNet V2的参数数目为3.4M，乘累加数目为300M.
模型训练以及参数预处理 模型训练，我们采用的是一个有5种花卉类别的数据集，输入图像的尺寸为3x224x224,我们仅修改网络的最后一层(即将输出向量维度由1000改为5)
以下是训练代码:
import os import torchvision.transforms as transforms from torchvision import datasets import torch.utils.data as data import torch import numpy as np import matplotlib.pyplot as plt import torchvision.models as models #模型加载 model = models.mobilenet_v2(pretrained=True) model.classifier = torch.nn.Sequential(torch.nn.Dropout(p=0.5), torch.nn.Linear(1280, 5)) print(model) model.load_state_dict(torch.load('model.pkl')) #在训练过的参数的基础上再进行训练 #参数 BATCH_SIZE=32 DEVICE='cuda' #数据集加载 path='F:\\data\\flower_photos\\flower_photos' flower_class=['daisy','dandelion','roses','sunflowers','tulips'] transform = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b3103e03a749f68649b584d6c0422ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb85cd6565dbd2e53c0ea1cfd642567f/" rel="bookmark">
			数据挖掘——决策树和K近邻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		决策树和K近邻 一、线性回归（房价预测）第1关：线性回归算法思想（一）相关知识1&gt;简单线性回归2&gt;多元线性回归 （二）编程要求（三）参考答案 第2关：动手实现线性回归（一）相关知识1&gt;数据集介绍2&gt;线性回归算法原理模型训练流程正规方程解 3&gt;线性回归算法流程 （二）编程要求（三）参考代码 第3关：衡量线性回归的性能指标（一）相关知识1&gt;前言2&gt;MSE3&gt;RMSE4&gt;MAE5&gt;R-Squared （二）编程要求（三）参考代码 二、决策树第1关：决策树算法思想（一）相关知识1&gt;引例2&gt;决策树的相关概念 （二）编程要求（三）参考答案 第2关：决策树算法原理（一）相关知识1&gt;信息熵2&gt;条件熵3&gt;信息增益 （二）编程要求（三）参考代码 第3关：线性回归算法思想（一）相关知识1&gt;ID3算法2&gt;使用决策树进行预测 （二）编程要求（三）参考代码 三、k-近邻第1关：knn算法概述（一）相关知识1&gt;knn算法思想2&gt;距离度量 （二）编程要求（三）参考代码 第2关：动手实现knn算法（一）相关知识1&gt;数据集介绍2&gt;加权投票3&gt;knn算法流程 （二）编程要求（三）参考代码 一、线性回归（房价预测） 第1关：线性回归算法思想 （一）相关知识 为了完成本关任务，你需要掌握：1.简单线性回归，2.多元线性回归。
1&gt;简单线性回归 在生活中，我们常常能碰到这么一种情况，一个变量会跟着另一个变量的变化而变化，如圆的周长与半径的关系，当圆的半径确定了，那么周长也就确定了。还有一种情况就是，两个变量之间看似存在某种关系，但又没那么确定，如青少年的身高与体重，他们存在一种近似的线性关系：身高/cm = 体重/kg +105。
但是，并不是每个青少年都符合这个公式，只能说每个青少年的身高体重都存在这么一种近似的线性关系。这就是其实就是简单的线性回归，那么，到底什么是线性回归呢？假如我们将青少年的身高和体重值作为坐标，不同人的身高体重就会在平面上构成不同的坐标点，然后用一条直线，尽可能的去拟合这些点，这就是简单的线性回归。
简单的线性回归模型如下：
y = w x + b y=wx+b y=wx+b 其中x表示特征值(如：体重值)，w表示权重，b表示偏置，y表示标签(如：身高值)。
2&gt;多元线性回归 简单线性回归中，一个变量跟另一个变量的变化而变化，但是生活中，还有很多变量，可能由多个变量的变化决定着它的变化，比如房价，影响它的因素可能有：房屋面积、地理位置等等。如果我们要给它们建立出近似的线性关系，这就是多元线性回归，多元线性回归模型如下：
y = b + w 1 x 1 + w 2 x 2 + . . . + w n x n y=b+w1x1+w2x2+...+wnxn y=b+w1x1+w2x2+...+wnxn 其中xi表示第i个特征值，wi表示第i个特征对应的权重，b表示偏置，y表示标签。
（二）编程要求 根据相关知识，按照要求完成选择题任务，包含单选题和多选题。
（三）参考答案 第2关：动手实现线性回归 （一）相关知识 为了完成本关任务，你需要掌握：1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb85cd6565dbd2e53c0ea1cfd642567f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1178b5c4981376704a61fed5aeba9a8/" rel="bookmark">
			数据挖掘——数据采集和数据清洗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据采集和数据清洗 一、数据清洗1.数据去重（一）相关知识1&gt; pandas读取csv文件-read_csv()2&gt; pandas的去重函数-drop_duplicates() （二）本关任务（三）参考代码 2.处理空值（一）相关知识1&gt; DataFrame中空值的表示2&gt; 查找空值及计算空值的个数3&gt; 处理空值-fillna （二）本关任务（三）参考代码 二、数据采集实战1. 单网页爬取（一）相关知识1&gt; 爬虫简介2&gt; 网络爬虫3&gt; 网络爬虫：载入4&gt; 网络爬虫：动态载入5&gt; 网络爬虫：解析 （二）本关任务（三）参考代码 2.网页爬取策略（一）相关知识1&gt; 深度优先爬虫（一路到底）2&gt; 广度优先爬虫（逐层爬取） （二）本关任务（三）参考代码 3.爬取与反爬取（一）相关知识1&gt;常见反爬手段：2&gt; 应对措施： （二）本关任务（三）参考代码 4.爬取与反爬取进阶（一）相关知识（二）本关任务（三）参考代码 一、数据清洗 1.数据去重 （一）相关知识 1&gt; pandas读取csv文件-read_csv() CSV为简单的文本格式文件，每行为一条用逗号分隔的数据。Excel保存文件时可以选择csv格式；在记事本里输入内容，保存时使用.csv扩展名，也能生成CSV文件。
只要能阅读文本文件的编辑器，就能打开CSV文件，也可以用Excel把它作为电子表格打开。现在，我们要用pandas中的read_csv函数读取csv文件中的数据。这个函数有很多参数，在本关卡和接下来的关卡中，我们将逐个介绍其中几个常用的参数。
在本关卡中，我们只需要将CSV文件的文件名作为参数即可。
import pandas as pd a=pd.read_csv('示例数据.csv') #此时，a就存储了示例数据.csv文件中的数据 print(a) # 输出结果如下： # 1 2 # 0 3 4 # 1 5 6 # 2 1 3 # 3 1 2 # 4 4 2 2&gt; pandas的去重函数-drop_duplicates() pandas中的drop_duplicates()函数是对DataFrame格式的数据，可以去掉特定列的重复行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1178b5c4981376704a61fed5aeba9a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b2b1ce071bb33776cc0b6eb4bc204b4/" rel="bookmark">
			数据挖掘——数据可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据可视化 1.数据可视化第一关 数据可视化的内涵1&gt;数据可视化是什么？2&gt;为什么需要数据可视化？3&gt;历史演变4&gt;习题 第二关 初识数据第三关 柱状图第四关 散点图第五关 直方图 2.数据可视化进阶第一关 热图1&gt;热图的作用？2&gt;习题 第二关 文本可视化1&gt;文本可视化之wordcloud2&gt;wordcloud参数3&gt;习题 第三关 文本调整和美化(主要运用seaborn) 1.数据可视化 第一关 数据可视化的内涵 1&gt;数据可视化是什么？ 数据可视化是将数据和信息通过用图来表示展示其价值。直观来讲，常见画图的目的有：
1.按区间划分的数据，进行比较；
2.展现变量间的关系或分布；
3.展现网络结果的节点、边、集群，寻找路径，找到影响力大的节点；
4.表示关系，将相关性等属性用不同颜色展示；
5.用字词大小展示频率、重要性；
6.在 3D 空间上展示变量关系、分布。
可视化在数据科学中的地位：
数据可视化的位置虽然靠后，但是十分重要，因为它往往是最后呈现结果的，且本身具有交叉学科属性：信息技术、自然科学、统计分析、图形学、交互、地理信息。
2&gt;为什么需要数据可视化？ 哪种数据的表示形式更让人容易接受，是以文字形式还是以图形化呢？“人类有五官，能通过 5 种渠道感受这个物质世界，那么为什么单单要青睐可视化的方式来传递信息呢？这是因为人类利用视觉获取的信息量巨大，人眼结合大脑构成了一台高带宽巨量视觉信号输入的并行处理器。具有超强模式识别能力，有超过 50% 功能用于视觉感知相关处理的大脑。大量视觉信息在潜意识阶段就被处理完成，人类对图像的处理速度比文本快得多。所以数据可视化是一种高带宽的信息交流方式。面对复杂数据，图形化表示更容易让人脑接受，方便挖掘数据中的规律和价值。
3&gt;历史演变 当今世界，数据量猛增，对于如何理解数据提出了更高要求，催生了数据可视化技术的发展。数据表示精细化，高维度化，时序化：
这些进步和演变得益于数据可视化工具，新兴数据可视化工具提高了作图效率
：
Matplotlib ：功能全，可定制性好；
Pandas Visualization ：基于 Matplotlib ，接口设计好；
Seaborn ：高级作图语言，默认样式精美。
4&gt;习题 第二关 初识数据 import pandas as pd import numpy as np pd.set_option('display.max_columns', 1000) pd.set_option('display.width', 1000) pd.set_option('display.max_colwidth', 1000) def student(): # ********* Begin *********# print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b2b1ce071bb33776cc0b6eb4bc204b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7be32c820444820f0a3e91a2caba4b40/" rel="bookmark">
			vscode编辑器快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按 Press功能 Function
Ctrl + Shift + P，F1显示命令面板 Show Command Palette
Ctrl + P快速打开 Quick Open
Ctrl + Shift + N新窗口/实例 New window/instance
Ctrl + Shift + W关闭窗口/实例 Close window/instance
基础编辑 Basic editing
按 Press功能 Function
Ctrl+X剪切行（空选定） Cut line (empty selection)
Ctrl+C复制行（空选定）Copy line (empty selection)
Alt+ ↑ / ↓向上/向下移动行 Move line up/down
Shift+Alt + ↓ / ↑向上/向下复制行 Copy line up/down
Ctrl+Shift+K删除行 Delete line
Ctrl+Enter在下面插入行 Insert line below
Ctrl+Shift+Enter在上面插入行 Insert line above
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7be32c820444820f0a3e91a2caba4b40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3c33f91f88c56b826a8c02df0a173db/" rel="bookmark">
			菜菜sklearn——XGBoost(3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4 XGBoost应用中的其他问题 4.1 过拟合：剪枝参数与回归模型调参 class xgboost.XGBRegressor (max_depth=3, learning_rate=0.1, n_estimators=100, silent=True,objective=‘reg:linear’, booster=‘gbtree’, n_jobs=1, nthread=None, gamma=0, min_child_weight=1,max_delta_step=0, subsample=1, colsample_bytree=1, colsample_bylevel=1, reg_alpha=0, reg_lambda=1,scale_pos_weight=1, base_score=0.5, random_state=0, seed=None, missing=None, importance_type=‘gain’, kwargs)
作为天生过拟合的模型，XGBoost应用的核心之一就是减轻过拟合带来的影响。作为树模型，减轻过拟合的方式主要是靠对决策树剪枝来降低模型的复杂度，以求降低方差。在之前的讲解中，我们已经学习了好几个可以用来防止过拟合的参数，包括上一节提到的复杂度控制 γ \gamma γ，正则化的两个参数 λ \lambda λ和 α \alpha α，控制迭代速度的参数 η \eta η以及管理每次迭代前进行的随机有放回抽样的参数subsample。所有的这些参数都可以用来减轻过拟合。但除此之外，我们还有几个影响重大的，专用于剪枝的参数：
这些参数中，树的最大深度是决策树中的剪枝法宝，算是最常用的剪枝参数，不过在XGBoost中，最大深度的功能与参数 γ \gamma γ相似，因此如果先调节了 γ \gamma γ ，则最大深度可能无法展示出巨大的效果。当然，如果先调整了最大深度，则 γ \gamma γ也有可能无法显示明显的效果。通常来说，这两个参数中我们只使用一个，不过两个都试试也没有坏处。
三个随机抽样特征的参数中，前两个比较常用。在建立树时对特征进行抽样其实是决策树和随机森林中比较常见的一种方法，但是在XGBoost之前，这种方法并没有被使用到boosting算法当中过。Boosting算法一直以抽取样本（横向抽样）来调整模型过拟合的程度，而实践证明其实纵向抽样（抽取特征）更能够防止过拟合。
参数min_child_weight不太常用，它是一篇叶子上的二阶导数 h i h_{i} hi​之和，当样本所对应的二阶导数很小时，比如说为0.01，min_child_weight若设定为1，则说明一片叶子上至少需要100个样本。本质上来说，这个参数其实是在控制叶子上所需的最小样本量，因此对于样本量很大的数据会比较有效。如果样本量很小（比如我们现在使用的波士顿房价数据集，则这个参数效用不大）。就剪枝的效果来说，这个参数的功能也被 γ \gamma γ替代了一部分，通常来说我们会试试看这个参数，但这个参数不是我的优先选择。
通常当我们获得了一个数据集后，我们先使用网格搜索找出比较合适的n_estimators和eta组合，然后使用gamma或者max_depth观察模型处于什么样的状态（过拟合还是欠拟合，处于方差-偏差图像的左边还是右边？），最后再决定是否要进行剪枝。通常来说，对于XGB模型，大多数时候都是需要剪枝的。接下来我们就来看看使用xgb.cv这个类来进行剪枝调参，以调整出一组泛化能力很强的参数。
让我们先从最原始的，设定默认参数开始，先观察一下默认参数下，我们的交叉验证曲线长什么样：
dfull = xgb.DMatrix(X,y) param1 = {'silent':True ,'obj':'reg:linear' ,"subsample":1 ,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3c33f91f88c56b826a8c02df0a173db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d8fe93d6acefaba325b1cbe2300803/" rel="bookmark">
			菜菜sklearn——XGBoost(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3 XGBoost的智慧 class xgboost.XGBRegressor (kwargs，max_depth=3, learning_rate=0.1, n_estimators=100, silent=True,objective=‘reg:linear’, booster=‘gbtree’, n_jobs=1, nthread=None, gamma=0, min_child_weight=1,max_delta_step=0, subsample=1, colsample_bytree=1, colsample_bylevel=1, reg_alpha=0, reg_lambda=1,scale_pos_weight=1, base_score=0.5, random_state=0, seed=None, missing=None, importance_type=‘gain’)
3.1 选择弱评估器：重要参数booster 梯度提升算法中不只有梯度提升树，XGB作为梯度提升算法的进化，自然也不只有树模型一种弱评估器。在XGB中，除了树模型，我们还可以选用线性模型，比如线性回归，来进行集成。虽然主流的XGB依然是树模型，但我们也可以使用其他的模型。基于XGB的这种性质，我们有参数“booster"来控制我们究竟使用怎样的弱评估器。
两个参数都默认为"gbtree"，如果不想使用树模型，则可以自行调整。当XGB使用线性模型的时候，它的许多数学过程就与使用普通的Boosting集成非常相似，因此我们在讲解中会重点来讲解使用更多，也更加核心的基于树模型的XGBoost。简单看看现有的数据集上，是什么样的弱评估器表现更好：
for booster in ["gbtree","gblinear","dart"]: reg = XGBR(n_estimators=180 ,learning_rate=0.1 ,random_state=420 ,booster=booster).fit(Xtrain,Ytrain) print(booster) print(reg.score(Xtest,Ytest)) #gbtree #0.9231068620728082 #gblinear #0.6286510307485139 #dart #0.923106843149575 3.2 XGB的目标函数：重要参数objective 梯度提升算法中都存在着损失函数。不同于逻辑回归和SVM等算法中固定的损失函数写法，集成算法中的损失函数是可选的，要选用什么损失函数取决于我们希望解决什么问题，以及希望使用怎样的模型。比如说，如果我们的目标是进行回归预测，那我们可以选择调节后的均方误差RMSE作为我们的损失函数。如果我们是进行分类预测，那我们可以选择错误率error或者对数损失log_loss。只要我们选出的函数是一个可微的，能够代表某种损失的函数，它就可
以是我们XGB中的损失函数。
在众多机器学习算法中，损失函数的核心是衡量模型的泛化能力，即模型在未知数据上的预测的准确与否，我们训练模型的核心目标也是希望模型能够预测准确。在XGB中，预测准确自然是非常重要的因素，但我们之前提到过，XGB的是实现了模型表现和运算速度的平衡的算法。普通的损失函数，比如错误率，均方误差等，都只能够衡量模型的表现，无法衡量模型的运算速度。回忆一下，我们曾在许多模型中使用空间复杂度和时间复杂度来衡量模型的运算效
率。XGB因此引入了模型复杂度来衡量算法的运算效率。因此XGB的目标函数被写作：传统损失函数 + 模型复杂度。
O b j = ∑ i = 1 m l ( y i , y ^ i ) + ∑ k = 1 K Ω ( f k ) O b j=\sum_{i=1}^{m} l\left(y_{i}, \hat{y}_{i}\right)+\sum_{k=1}^{K} \Omega\left(f_{k}\right) Obj=i=1∑m​l(yi​,y^​i​)+k=1∑K​Ω(fk​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57d8fe93d6acefaba325b1cbe2300803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadafaa0b3244b0359e29a5606c78cd7/" rel="bookmark">
			terminator alt &#43; n 不切换tab 的深究收获
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在terminator下，默认输入 alt + 1,2会出现 arg 111的输出，这个输出是干嘛的？一直困扰着我，我想用 alt + number 来切换终端，
在terminal bash 这种终端下，默认输入 alt + 2就会快速切换到 某个终端下。
其中在preference中有一个配置，就是 enable mnemonics。打开它，在输入 alt 2 时，就会输出 arg 2 然后输入一个字母，终端就会快速将输入的字母重复 arg中数字的次数，进行输出，从而完成快速N个相同字母的目的。
后来查了查，这个功能的实现是靠readline的库函数实现的，是为了方便 命令行输入和编辑。
很多命令终端都在用这个库，在知乎上有一个对这个readline的介绍，引用一下，同时对这种，简单实用，但默默不被人知晓的无私奉献的开发者致意
你所不知的 GNU Readline | Linux 中国 - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59774ed254f058b69c87eddd0f758e9b/" rel="bookmark">
			python划分训练集、验证集和测试集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将图片和标注文件分别划分到文件夹中去
# 将图片和标注数据按比例切分为 训练集和测试集、验证集 import shutil import random import os # 原始路径 image_original_path = 'a/images/' label_original_path = 'a/annotations/' # 训练集路径 train_image_path = 'a/train/images/' train_label_path = 'a/train/labels/' # 验证集路径 val_image_path = 'a/val/images/' val_label_path = 'a/val/labels/' # 测试集路径 test_image_path = 'a/test/images/' test_label_path = 'a/test/labels/' # 数据集划分比例，训练集80%，验证集10%，测试集10% train_percent = 0.8 val_percent = 0.1 test_percent = 0.1 # 检查文件夹是否存在 def mkdir(): if not os.path.exists(train_image_path): os.makedirs(train_image_path) if not os.path.exists(train_label_path): os.makedirs(train_label_path) if not os.path.exists(val_image_path): os.makedirs(val_image_path) if not os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59774ed254f058b69c87eddd0f758e9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28959493281a9223ba10f1c8d1b2bc2c/" rel="bookmark">
			vivado中coe文件的生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://blog.csdn.net/qq_34741466/article/details/106155003
参考了https://www.xilinx.com/support/documentation/ip_documentation/blk_mem_gen/v8_3/pg058-blk-mem-gen.pdf文档的第87页开始的内容，并对其进行了适当的翻译。
Specifying Initial Memory Contents
指定内存的初始内容
​ The Block Memory Generator的核心使用coe文件或vivado默认的形式进行初始化
.coe文件能填充内存中每一块位置。coe文件中有两个参数：
memory_initialization_radix（存储数值的基数，就是进制数）: 只能选2，10，16进制
memory_initialization_vector（存储的数值）: 定义其中存储的数值
一个例子：
memory_initialization_radix = 16;
memory_initialization_vector =
12, 34, 56, 78, AB, CD, EF, 12, 34, 56, 78, 90, AA, A5, 5A, BA;
创建coe文件的图示：
Select/check Load Init File.Click Edit.Create or select a file.Enter the required memory_initialization_radix and memory_initialization_vector. 如何在matlab中创建coe文件或者quartusII中的mif文件：
N=2^8; s_p=0:255; % 正弦波一个周期的采样点数 Mem_depth = 256; % 存储深度 Mem_width = 8; % 存储宽度 sin_data=sin(2*pi*s_p/N); % 打印我们的波形 % plot(sin_data,'r*'); % hold on; % plot(sin_data); % 定点化 fix_p_sin_data=fix(sin_data*((N / 2) -1)); for i=1:N % 负数的定点化 if fix_p_sin_data(i)&lt;0 fix_p_sin_data(i)=N+fix_p_sin_data(i); %记住这里是负数用加号即可 else % 正数的定点化 fix_p_sin_data(i)=fix_p_sin_data(i); end end % 生成.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28959493281a9223ba10f1c8d1b2bc2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36743b3d39a9cd973d65618ec431df1b/" rel="bookmark">
			onnxruntime cuda版本使用时出现的错误汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 用qt c++ 推理 onnxruntime cuda时出现诸如
E:onnxruntime:barcode, provider_bridge_ort.cc:995 onnxruntime::ProviderLibrary::Get] LoadLibrary failed with error 126 "找不到指定的模块。" when trying to load onnxruntime_providers_cuda.dll c等错错误
解决方法:
下载带onnxruntime_providers_cuda.dll 等动态库的onnxruntime库，，基本是1.8.1以上，然后把dll放在程序路径上，如果还出现这种错误，大概率是cuda，cudnn版本问题或者cuda路径没找到,想找到onnxruntime需要的cuda,cudnn版本进行重新安装，然后应该可以解决CUDA - onnxruntime 另外车辆，车牌，反光衣，安全帽等数据集，链接，有兴趣的朋友可以看下 链接：https://pan.baidu.com/s/1ebCKOAE5Rx0PejiyRsTSXg 提取码：5555
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feb1d8d343872392d5eba4f5f8f770bf/" rel="bookmark">
			Rust 中的 RefCell
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RefCell 与 Cell 基本相同，区别在于 RefCell 读取内容时，返回的是引用，本质上是一个指针。这是因为 RefCell 要包装的数据没有实现 Copy 特性。代码示例如下：
use std::cell::{Ref, RefCell}; fn main() { let x = RefCell::new("good".to_string()); let a = &amp;x; let b = &amp;x; *a.borrow_mut() = "nice".to_string(); *b.borrow_mut() = "best".to_string(); let y: Ref&lt;String&gt; = x.borrow(); println!("x = {:?}", x); println!("y = {:?}", y); } --------------------------------------------------- &gt;cargo run x = RefCell { value: "best" } y = "best" rust 的这套工具确实做的很漂亮呀！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc0be4da5b14db134da4750c40b90a81/" rel="bookmark">
			【字符编码】Unicode字符集与字符编码方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unicode字符集与字符编码方式 字符集和字符编码的区别和联系字符集编码的发展Unicode字符集的编码方式UTF-8UTF-16UTF-32UTF BOM 问题小结 字符集相关命令fileiconv 字符集转换编程字符集应用案例字符集在线工具集合 字符集和字符编码的区别和联系 字符集：多个字符的集合。例如 GB2312 是中国国家标准的简体中文字符集，GB2312 收录简化汉字（6763 个）及一般符号、序号、数字、拉丁字母、日文假名、希腊字母、俄文字母、汉语拼音符号、汉语注音字母，共 7445 个图形字符。字符编码：把字符集中的字符编码为（映射）指定集合中的某一对象（例如：比特模式、自然数序列、电脉冲），以便文本在计算机中存储和通过通信网络的传递。 字符集和字符编码的关系：
字符集是书写系统字母与符号的集合而字符编码则是将字符映射为一特定的字节或字节序列，是一种规则。 通常特定的字符集采用特定的编码方式（即一种字符集对应一种字符编码（例如：ASCII、IOS-8859-1、GB2312、GBK，都是即表示了字符集又表示了对应的字符编码，但 Unicode 不是，它采用现代的模型））
字符集编码的发展 单字节 -&gt; 双字节 -&gt; 多字节
(1) 单字节
ASCII（American Standard Code for Information Interchange）, 128 个字符, 用 7 位二进制表示（00000000-01111111 即 0x00-0x7F）;EASCII（Extended ASCII）,256 个字符，用 8 位二进制表示（00000000-11111111 即 0x00-0xFF）。
当计算机传到了欧洲，国际标准化组织在 ASCII 的基础上进行了扩展，形成了 ISO-8859标准，跟 EASCII 类似，兼容 ASCII，在高 128 个码位上有所区别。但是由于欧洲的语言环境十分复杂，所以根据各地区的语言又形成了很多子标准，ISO-8859-1、ISO-8859- 2、ISO-8859-3、……、ISO-8859-16。
(2) 双字节
当计算机传到了亚洲，256 个码位就不够用了。于是乎继续扩大二维表，单字节改双字节，16 位二进制数，65536 个码位。在不同国家和地区又出现了很多编码，大陆的GB2312、港台的 BIG5、日本的 Shift JIS 等等。
注意 65536 个码位这种说法只是理想情况，由于双字节编码可以是变长的，也就是说同一个编码里面有些字符是单字节表示，有些字符是双字节表示。这样做的好处是，一方面可以兼容 ASCII，另一方面可以节省存储容量，代价就是会损失一部分码位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc0be4da5b14db134da4750c40b90a81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5b41fc27a8d22948fa4519bcab786b3/" rel="bookmark">
			SpringCloud概念性内容整理记录，SpringCloud整体学习思路整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置小知识：在idea中，配置虚拟机选项可以修改服务端口号。
配置虚拟机修改服务端口号：-Dserver.port=[端口号]
一、服务注册中心 常用服务注册中心 （1）Eureka（来源于Netflix，停止更新，但有仍有少量使用）
Eureka包含两个组件：Eureka Server和Eureka Client。
&lt;!--引入 eureka server--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; 官方停止更新说明
- https://github.com/Netflix/eureka/wiki
- 在1.x版本项目还是活跃的,但是在2.x版本中停止维护
（2）Consul（来源于Google，Go语言开发，是以软件的形式存在，独立于我们的Java程序外）
Linux、Windows和Mac OS X多平台支持。
下载地址：https://www.consul.io/downloads
（3）nacos（来源于阿里巴巴）
Nacos是微服务架构中服务注册中心统一配置中心,用来替换eureka,consul以及config组件。
# 0.准备环境
- 1.64 bit OS，支持 Linux/Unix/Mac/Windows，推荐选用 Linux/Unix/Mac。必须满足
- 2.64 bit JDK 1.8+；必须满足
- 3.Maven 3.2.x+；
# 1.下载nacos
- https://github.com/alibaba/nacos/releases （4）Zookeeper（并非SpringCloud的服务注册中心）
主要使用是dubbo + zookeeper
二、服务间通信方式 1.服务间的负载均衡 （1）Ribbon（来源Netflix） Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。
- 说明: 1.如果使用的是eureka client 和 consul client,无须引入依赖,因为在eureka,consul中默认集成了ribbon组件
2.如果使用的client中没有ribbon依赖需要显式引入如下依赖：
&lt;!--引入ribbon依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5b41fc27a8d22948fa4519bcab786b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1633994b7b8b069b67d020bd7a9100a1/" rel="bookmark">
			创建并运行一个Android Studio项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 as 创建批处理文件新建项目初学者可以尝试修改引号内容，如下图 完结，撒花！！！ 创建批处理文件 在C:\Users\86180\AppData\Local\Android\Sdk\platform-tools根目录(目录不一定跟我完全一样，可以在文件管理-此电脑-搜索platform-tools找到你的platform-tools)下创建restartADB.txt文件，内容为:
adb kill-server &amp;&amp; adb start-server pause 保存并将文件名改为restartADB.bat，双击运行。
当出现图1内容时，重新双击运行，直到出现图2内容。
双击打开Android Studio
新建项目 ###等待，直到出现下图内容
###等待，直到出现
###默认打印内容为hello world。
初学者可以尝试修改引号内容，如下图 然后运行：run-run’app’
###等待，直到出现下图
鼠标悬停大概这根线的位置，拖动，放大手机屏幕。
完结，撒花！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96cd6db199a086dca3e883a6e24a7a6c/" rel="bookmark">
			【生物信息学】正常和突变的蛋白质结构可视化？构建蛋白结构模型，常见的4种构建蛋白模型方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景1：
A同学想要从对蛋白结构影响的角度说明 自己发现 的 患者（病人）携带的DNAH1 突变（如 p.Val131Ala）对蛋白结构的影响，通过SWISS-Model自己构建了 正常情况下的蛋白结构，又同时构建了突变情况下的蛋白结构，如何对它们进行展示 以用于文章中的图呢？
文章中关于这个结果的描述：in silico analysis The location of the two variants is shown in Figure 2A.The affected AA residues, E446 and R971 of the DNAH1peptide, **are evolutionarily conserved with high consensus across eight species (**Fig. 2B). Only the domain containingthe p.R971H variant was credibly modeled using the PDB:6sc2.1 file as its wild-type template (Seq identity: 25.11%;Qualitative Model Energy Analysis: -4.63). The R971Hvariant, which replaced the arginine with a histidine, changed the number of hydrogen bonds from two to one at theside chain with E974, thus reducing the stability of the protein (Fig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96cd6db199a086dca3e883a6e24a7a6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb043421d663b50b4bd35fb18dd9d85a/" rel="bookmark">
			重启ADB的bat文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		adb.exe,start-server’ failed – run manually if necessary
意思是adb.exe服务运行失败，在必要情况下请手动运行。
原因可能是你电脑上有其他的安卓读写工具的进程运行着，比如各种手机管家、助手之类
============以下内容来自网络
尝试重启ADB服务。
你可以在sdk目录如c:\Program Files\Android\android-sdk-windows\platform-tools\下建一个叫restartADB.bat的windows批处理文件，文件中写入：
adb kill-server &amp;&amp; adb start-server
pause
需要重启ADB,只要双击运行文件即可,注意adb.exe须在platform-tools目录下，不然脚本可能运行不了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9a08ccf9fa9f6e0f9f6ff8610fbfc49/" rel="bookmark">
			文档级实体关系抽取——知识获取的新挑战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作者：姚远、叶德铭、刘知远 （欢迎转载，请标明原文链接、出处与作者信息即可）
关系抽取是自然语言处理中的一项重要任务，通过从纯文本中抽取结构化的实体关系事实，可用于自动构建和扩充知识图谱。例如，从句子「北京是中国的首都」中，可以抽取出关系事实（北京, 首都, 中国），其中北京和中国被称为实体，而首都则是他们的关系。关系抽取是知识获取的重要途径，对于深度理解自然语言和实现自动问答具有重要研究价值。
前段时间我们介绍了实体关系抽取的现状与挑战。接下来，我们将分别详细介绍在几个方面上的思考与探索。这篇就来介绍知识获取的新挑战之一：文档级实体关系抽取。
目前大多数关系抽取方法抽取单个实体对在某个句子内反映的关系，在实践中受到不可避免的限制：在真实场景中，大量的关系事实是以多个句子表达的。文档中的多个实体之间，往往存在复杂的相互关系。
以下图为例，就包括了文章中的两个关系事实（这是从文档标注的19个关系事实中采样得到的），其中涉及这些关系事实的命名实体用蓝色着色，其它命名实体用下划线标出。为了识别关系事实（Riddarhuset，country，Sweden），必须首先从句子4中抽取Riddarhuset位于Stockholm的关系事实，然后从句子1确定Stockholm是Sweden的首都，以及Sweden是一个国家，最后从这些事实推断出Riddarhuset的主权国家是瑞典。该过程需要对文档中的多个句子进行阅读和推理，这显然超出了句子级关系抽取方法的能力范围。
根据从维基百科采样的人工标注数据的统计表明，至少40％的实体关系事实只能从多个句子联合获取。因此，有必要将关系抽取从句子级别推进到文档级别。
为了加速对文档级的关系抽取的研究，我们与腾讯微信模式识别中心联合制作发布了DocRED，这是一个大规模的、人工标注的、通用的文档级关系抽取数据集。DocRED包含对超过5000篇Wikipedia文章的标注，包括96种关系类型、143,375个实体和56,354个关系事实。这在规模上超越了以往的同类精标注数据集。与传统的基于单句的关系抽取数据集相比，不同之处在于，DocRED中超过40%的关系事实只能从多个句子中联合抽取，因此需要模型具备较强的获取和综合文章中信息的能力，尤其是抽取跨句关系的能力。
DocRED是以 Wikipedia 作为语料库、以 Wikidata 作为知识图谱构建的。Wikipedia 作为互联网上的自由百科全书，因其巨大的体量和蕴含的丰富知识而备受 NLP 学者青睐。Wikidata是一个和Wikipedia紧密联系的知识图谱，存储了大量结构化知识。目前 Wikidata 中已有超过 5000 万个实体，千余种关系。
上面例子也是从DocRED抽样出来的。可以看到，DocRED基于Wikidata对Wikipedia的文章标注了命名实体和关系事实，包括句内关系和跨句关系。为了支持更多样的应用场景，DocRED还标注了实体之间的指代信息，以及关系事实对应的证据语句，因此也可以支持关系抽取外的很多文档级任务。数据集相关论文《DocRED: A Large-Scale Document-Level Relation Extraction Dataset》发表在ACL 2019上。文章对DocRED数据集的构造原理给出了详细解释，感兴趣的同学可以点击下面的论文地址阅读原文。
DocRED网址：
thunlp/DocRED​github.com/thunlp/DocRED正在上传…重新上传取消
论文地址：
DocRED: A Large-Scale Document-Level Relation Extraction Dataset​arxiv.org/abs/1906.06127
由于DocRED中至少40.7％的关系事实只能从多个句子中提取，模型需要阅读、综合文档中的所有信息来推断实体之间的关系。下表列举了DocRED中包含的文档级关系抽取的推理类型，其他剩余的0.3%为其他推理类型，例如时序推理；文章中头实体用正体表示，尾实体用斜体表示。该数据分析表明，DocRED中包含多种复杂的推理类型，包括逻辑推理、指代推理和常识推理等，因此模型需要具备多种推理能力才能有效进行文档级关系抽取。
除了人工精标注的数据集，DocRED还提供了超过10万篇的基于远程监督数据，以支持弱监督的关系抽取研究。数据分析显示，文档级的关系抽取中，通过远程监督方法产生的数据的噪音比例远高于句子级的远程监督，这表明基于远程监督的文档级关系抽取十分具有挑战性。
为了支持公平透明的定量比较，我们在Codalab开放了DocRED竞赛：
CodaLab - Competition​competitions.codalab.org/competitions/20717正在上传…重新上传取消
目前已经吸引超过30支队伍参加，竞赛排行榜中选手们提交的模型效果相比于论文中的基线模型已经有了明显提升，但是和人类表现相比仍然存在较大差距：
我们期待，通过构建和发布 DocRED 能够推动文档级关系抽取的研究，同时也能够支持更多的文档级自然语言处理研究。
作者简介 姚远 清华大学计算机科学与技术系博士二年级同学，主要研究方向为自然语言处理、知识图谱、关系抽取。在人工智能领域国际著名会议ACL、EMNLP上发表多篇论文。
叶德铭 清华大学计算机科学与技术系博士二年级同学，主要研究方向为自然语言处理、关系抽取、问答系统。在人工智能领域国际著名会议ACL、ECCV上发表多篇论文。
刘知远 清华大学计算机系副教授、博士生导师。主要研究方向为表示学习、知识图谱和社会计算。主页：
Zhiyuan Liu​nlp.csai.tsinghua.edu.cn/~lzy/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8537c3ab0ea0c2a9b1f743fb335292c/" rel="bookmark">
			c&#43;&#43; substr()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		s.substr(a,b)
1、s是需要截取的字符串
2、a 截取字符串的开始位置（注：当a等于0或1时，都是从第一位开始截取）
3、b 要截取的字符串的长度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/785e126b12a8c76340953f6426420215/" rel="bookmark">
			Python&#43;scrcpy&#43;pyminitouch实现自动化（一）——scrcpy的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是scrpy?
是一种通过adb调试的方式来将手机屏幕投到电脑上，并且可以通过电脑控制Andorid设备，也可以通过Wifi连接，相当于隔空投屏，而且也不需要root权限，不需要再手机里面安装任何程序。
adb（Android Debug Bridge），是Android SDK中的一个工具，使用adb可以直接操作管理Android模拟器或者真实的Android设备，起到调试桥的作用。adb工具包一般只是一个压缩文件，不需要安装，只需要解压就可以使用了，解压后有三个必须文件adb.exe动态链接库文件、adbWinApi.dll和adbWinUsbApi.dll，解压后即可直接使用。
scrpy特性：
亮度（原生，仅显示设备屏幕）
性能（30~60fps）
质量（1920*1080或以上）
低延迟（35~70ms）
启动时间短（显示第一张图象约1s）
非侵入性（设备上没有安装任何东西）
电脑端完成配置后，还需要在手机端开启开发者选项及USB调试，然后使用数据线将手机和电脑连接并且允许USB调试，双击解压得到的scrpy.exe文件，就可以实现有线投屏。
手机使用scrpy要求：
Android设备至少需要API21（Android5.0以上版本）。
确保在设备上启动了adb调试。
在某些设备上，您还需要启动其他选项以使用键盘和鼠标进行控制。
二、下载scrcpy
下载地址：Releases · Genymobile/scrcpy · GitHub
需要注意的是，需要搭建Java运行环境，在之前已经搭建过了，所以现在不需要了。解压打开后如下：
以上都是需要在终端cmd上进行调试的，打开cmd定位到此目录：
方式一：使用USB进行连接（推荐）
使用usb连接到PC，一直信任电脑
运行adb usb查看连接是否成功
cd E:\&gt;scrcpy-win64-v1.22&gt;adb usb 之后输入scrcpy，就可以成功投屏手机：
方式二：无线连接（需要数据线进行前期操作）
将手机与电脑用USB连接，USB连接方式传输文件
打开开发者模式
打开cmd 定位到所在的文件夹，输入adb devices。
确保手机与手机连接于同一wifi下，查看手机的IP信息，
在设备上启用 adb over TCP/IP：adb tcpip 5555 拔下usb线
连接到设备 adb connect DEVICE_IP:5555，DEVICE_IP为你自己手机的IP地址。
运行scrpy
无线连接所有过程：
性能是与usb不同的，默认的scrcpy比特率是8Mbps，这对于WIFI连接可能太多了，根据使用情况，降低比特率和分辨率。
scrcpy --bit-rate 2M --max-size 800 或者简写
scrcpy -b2M -m800 如果要回到usb调试方式，则需要使用adb usb。
最后是常用的快捷方式以及命令
scrcpy -v版本信息scrcpy -c裁剪投屏屏幕（长：宽：偏移x：偏移y）就是把某一区域放大scrcpy -p 27184设置端口scrcpy --help帮助scrcpy --max-size 1024 （缩写 scrcpy -m 1024）缩小尺寸scrcpy --bit-rate 2M（缩写 scrcpy -b 2M）更改比特率scrcpy --max-fps 15限制帧率scrcpy -- crop 1224:1440:0:0裁剪以仅为镜像屏幕的一部分scrcpy --lock-video-orientation(=0、1、2、3)锁定镜像的方向（0为正常显示模式、1为左旋90、2为旋转180、3为右旋90）scrcpy --encoder _编码器scrcpy --record file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/785e126b12a8c76340953f6426420215/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0fae70e1aac0c7579bef0a95ce4330e/" rel="bookmark">
			CANNOT RESOLVE PLUGIN ORG.SPRINGFRAMEWORK.BOOT:SPRING-BOOT-MAVEN-PLUGIN:「UNKNOWN」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		还是用idea 真是bug多这软件
把版本号加上，行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30ef07e088e26b42937d320ed715a72f/" rel="bookmark">
			git错误，OpenSSL SSL_read: Connection was reset, errno 10054
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在idea里导入项目时，报这个错
打开Git命令页面，执行git命令脚本：修改设置，解除ssl验证
git config --global http.sslVerify "false" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7eaea75e1a12df8fb8dcb300372aa94/" rel="bookmark">
			JS浏览器换肤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核心：把当前图片的路径取出来给body做背景
遇到的问题：
在JS注册事件的时候，图片点击没有效果，原因，这是由于上面加了一个mask的div盒子，所以点击不起作用
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box { width: 1200px; margin: 0 auto; position: relative; background-color: white; } button { width: 36px; height: 36px; background-color: white; border: none; position: absolute; top: 20px; right: 20px; background-image: url('关闭.png'); background-repeat: no-repeat; background-position: center; background-size: 100%; } h1 { padding-top: 60px; } h1, p { padding-left: 120px; } li { list-style: none; width: 470px; height: 274px; display: inline-block; margin-left: 10px; margin-right: 10px; margin-top: 5px; margin-bottom: 5px; border-radius: 10px; background-repeat: no-repeat; background-position: center; position: relative; } ul { text-align: center; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7eaea75e1a12df8fb8dcb300372aa94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c7839fa26179e492da6eb814732c25b/" rel="bookmark">
			在idea中使用Tomcat出现中文变问号(乱码)的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(在idea中使用Tomcat出现中文问号的解决方案)
第一步：
第二步：
点击 Edit Configurations... ;
第三步：
在 VM options：输入 -Dfile.encoding=utf-8 ;
第四步：
重启Tomcat或idea ;
结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/860e9b529434a9d33c8497c0711f4d8a/" rel="bookmark">
			Android Studio模拟器无法上网问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.无法上网的原因
使用android studio开发时经常使用其自带的模拟器进行app模拟和仿真，并且可以使用模拟器创建android各种版本的模拟器设备来测试自己的app是否可以兼容运行。但是如果需要使用网络时就会发现无法正常上网，打开浏览器输入网址时不能打开。
通过搜索资料可以发现是模拟器的DNS问题，模拟器默认的DNS是10.0.2.3这种，这个DNS电脑是无法ping通的，因此无法对域名进行解析也就无法访问网址，如果是直接输入ip地址的话是可以访问的，比如输入百度的ip地址14.215.177.39进行访问，此时是可以访问的。如果直接输入ip也无法进行网络访问的话，那么可能本身的网络就有问题需要先检查一下自己电脑的网络问题。
2.解决方法
针对这个问题网络上有挺多的解决方法的，一般都是说用命令行来启动模拟器，启动的时候通过命令行来指定dns，但是这个方法不是很好用，我还是习惯了直接用android studio来启动模拟器。
这里分享一个在模拟器启动后设置dns实现一劳永逸的方法，启动模拟器后wifi会默认连接一个叫AndroidWifi的热点，此时点击这个热点进去查看详情，我的连接详情如下。我们需要记录下IP地址和网关，每个人的都不太一样，我这个是Pixel_API26的模拟器，不同的模拟器版本操作方法可能不完全一样，大家可以参考。
然后修改AndroidWifi的网络设置，我的模拟器是长按热点就会弹出菜单，点击Modify network进行网络设置，展开高级设置选择IP地址为static，然后将刚刚记录的ip地址和网关输入进去，DNS可以输入自己电脑的DNS，如果自己电脑的DNS不是IPv4地址的话就可以使用网络上公用的DNS，我这里输入的是阿里的DNS 223.5.5.5，输入完成后点击保存。
此时需要将WiFi进行关闭，然后重新打开，等待连接AndroidWifi完成后应该就有internet了，之前的no internet文字就消失了。如果重启WiFi后还是没有网络的，可以多次重启然后多等一会看看是否有网络。
可以打开浏览器输入www.baidu.com进行测试是否可以访问网络。通过这个方法设置后就不需要每次启动模拟器都重新设置DNS，相比较用命令行来启动模拟器的方法更加的方便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fecd18e0de953b3fa0206670b8b5b1cf/" rel="bookmark">
			uni-app学习日记4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.uni-app模板示例
解析：
[1]顶部选项卡
[2]组件通讯
[3]列表到详情示例
[4]GlobalData和vuex
2.手机号码登录
解析：
&lt;button open-type="getPhoneNumber" @getphonenumber="getPhoneNumber"&gt;快捷登录&lt;/button&gt; 3.原生渲染和webview渲染
解析：
[1]uni-app是vuejs的语法+小程序的API，它有独立的js引擎，原生能力的扩展基于独立js引擎，而不是基于webview的扩展方案。
[2]在App端，uni-app支持视图层使用原生渲染，也支持使用webview渲染，开发者可以自行选择。
4.uni小程序sdk
解析：即英文uniMpSDK，为原生App开发者提供的sdk：
[1]快速打造自己的小程序生态
[2]将App里的部分栏目实现小程序化，方便解耦、快速迭代升级
5.uniCloud
解析：
[1]uniCloud与微信小程序云开发、支付宝小程序云开发类似。
[2]uniCloud可通过云函数URL化实现普通http通信接口，非uni-app开发的应用也可以通过这种方式连接uniCloud。
6.5+App项目[不建议]
解析：
[1]5+是html5plus的缩写，即基于html5的增强扩展。
[2]它是一个跨iOS、Android的混合开发App解决方案，与cordova类似。
[3]它基于webview渲染，封装了大量原生能力给js API。
7.mui项目[不建议]
解析：
[1]mui是mobile ui的全称，它是为5+App而配套推出的开源ui框架。
[2]5+App可以使用很多基于html的ui库，mui是DCloud官方推出的一个库，在性能与5+App的结合上，拥有更好的优势。
8.wap2app[不建议]
解析：
[1]wap2app，wap是手机网站的意思，它是一个快速将手机H5站点转换为跨平台App的方案。
[2]它是基于5+App的一套前端框架，利用5+App引擎增强了远端网页的功能和性能，以接近App的效果。
9.uni.checkSession
解析：检查登录状态是否过期。
10.auth.code2Session
解析：换取用户唯一标识OpenID和会话密钥session_key。
11.uni.getProvider(OBJECT)
解析：获取服务供应商，仅App平台支持。
12.uni.login()返回结果
解析：
{code: "011ZzfHa1uBqgC0zAOIa17ps4r2ZzfHA", errMsg: "login:ok"} 13.uni.getUserInfo()返回结果
解析：
{ cloudID: undefined, encryptedData: "25oUUf429xOfSLENXKY/W055PawZ15dTCGF9bUlKUBJVpA3lH", errMsg: "getUserInfo:ok", iv: "9u4NZ7zXIJYvbdHRASlCHA==", rawData: "{"nickName":"微信用户","gender":0,"language":"","city":"","province":"","country":"","avatarUrl":"https://thirdwx"}", signature: "7ce5625ca8e9d7082fd200802bd345ef03636b2e", userInfo: {avatarUrl: "https://thirdwx", city: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fecd18e0de953b3fa0206670b8b5b1cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aadb11182a540ca9cfae8797fbca17e/" rel="bookmark">
			Docker容器间网络互通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实现效果 docker下的三个容器相互ping通，docker0相当于一个路由器或者网关，容器之间并可以ping通是因为有docker0存在，并不是直接容器ping通容器，每新建一个容器就会出现一个成对存在的网卡，新建容器如果没有指定网络那么默认会在docker0下。这钟技术叫veth-pair技术。
二、准备工作 一台linux系统虚拟机，提前拉取busybox镜像，我们以busybox镜像为例子，同时需要安装一个网桥管理工具，sudo yum install -y bridge-utils。
！！！如果不以busybox为例子，镜像可能自身不带ping命令，需要用命令获得ping命令，apt-get update &amp;&amp; apt-get install iputils-ping。！！！
三、实例配置 1、创建三个容器，分别是test1、test2、test3。 docker run -dit --name test1 busybox sh
查看容器是否启动docker ps
2、进入容器：docker exec -it test1 sh，尝试ping。 使用docker network ls可以显示当前的docker网络，所有新建的容器网络参数都会记录在bridge网络中,且包括该网络的网关，如果不新建网络的话，只能通过ip才能ping通。
通过查看bridge网络的内容，查看容器的ip地址：docker inspect bridge
再次进入容器ping ip地址，发现可以ping通。（ctrl+p+q可以不关闭容器退出）
或者用docker exec -it test1 ping 172.17.0.2（不用进入容器查看，快捷一点）
现在我们通过ip已经可以互ping了，但我们在实际生活中ip有时候是会变化的，所以我们为了方便一般都是通过容器名称来互ping；现在就来解决这个问题。
首先我们要自定义一个网络，然后再把我们刚刚建立好的容器把他们都放到该网络里面，然后再ping。
3、新建一个名为my-bridge的docker网络（可以用容器的id去ping） ！！！此处有个重点，bridge网络和自行建立的my-bridge的区别，bridge记录所有容器的ip，以及bridge网络的网关，网关一般是172.17.0.1，而my-bridge网络一开始仅仅只有网关，只有你加入的容器，容器网络信息才会在my-bridge里。！！！
docker network create --driver bridge my-bridge
检查网络是否存在：docker network ls
将容器加入该网络：docker network connect my-bridge test1
检查容器是否成功加入my-bridge网络：docker inspect my-bridge
另外，值得一提的是如果你想要删除docker网络，使用命令docker network rm my-bridge，如果网络里还有容器的话会报错，可以用docker network disconnect my-bridge test1将容器拿出网络。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aadb11182a540ca9cfae8797fbca17e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb830b0f39d194f8c31dad2e9dc9305e/" rel="bookmark">
			netcat使用及反弹shell
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NetCat参数简单通讯创建一个服务器端创建一个客户端 返回shell使用（建立后门）windows监听型后门连接型后门 linux监听型后门连接型后门 解决乱码 文件传输服务器接受客户端传来的文件客户端接受服务器传来的文件 端口扫描windowslinux banner信息抓取连接转发（端口转发）正常情况进行端口转发使用bat方法使用后门方法 Netcat反弹shellLinux反弹shellbash反弹bash变型不支持nc -ebash base64awk反弹telnet反弹python反弹php反弹 Windows反弹shellnc反弹metasploit反弹shell NetCat Netcat是一款非常出名的网络工具，简称“NC”,有渗透测试中的“瑞士军刀”之称。它可以用作端口监听、端口扫描、远程文件传输、还可以实现远程shell等功能。总之功能强大，可以用一句较为风趣的话来描述NC的强大——“你的想象力是局限NC的瓶颈”。
参数 -g &lt;网关&gt; 设置路由器跃程通信网关，最多可设置8个；
-G &lt;指向器数目&gt; 设置来源路由指向器，其数值为4的倍数；
-i &lt;延迟秒数&gt; 设置时间间隔，以便传送信息及扫描通信端口；
-l 使用监听模式，管控传入的资料；
-L 使用监听模式，客户端失去连接，服务器依然保持监听（低版本没有）
-n 直接使用IP地址，而不通过域名服务器；
-o &lt;输出文件&gt; 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存；
-p &lt;通信端口&gt; 设置本地主机使用的通信端口；
-r 乱数指定本地与远端主机的通信端口；
-s &lt;来源位址&gt; 设置本地主机送出数据包的IP地址；隐藏自己
-u 使用UDP传输协议；
-v 显示指令执行过程；
-w &lt;超时秒数&gt; 设置等待连线的时间；
-z 使用0输入\输出模式，只在扫描通信端口时使用。
-d nc命令在后台执行（退出cmd窗口仍在执行，nc1.11以上版本才有）
-e 执行某个程序，常用于后门建立（有的版本为了安全删除这个选项）
简单通讯 创建一个服务器端 nc -l -p port 创建一个客户端 nc target_ip target_port -w3 -w3设置等待连线的时间3s,防止未连接上服务器的“假死”现象
返回shell使用（建立后门） windows 监听型后门 服务器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb830b0f39d194f8c31dad2e9dc9305e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/026ea6719d5854246d400e0238b4c301/" rel="bookmark">
			Python 2D游戏项目开发日记——像素世界（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020/2/19
前言 接下来我会在这个号持续更新我的游戏开发日记——这是一款RPG类游戏名为“像素世界”，游戏主体由Python的Pygame库实现，登录系统可能会以Tkinter或Easygui实现。主要是记录我的游戏开发的过程，希望我能坚持下去吧！
实现目标 本期的实现目标：
整理游戏素材搭建游戏窗口载入背景图载入背景音乐 正文 1.先将图片素材和背景音乐素材分类整理 图片素材：背景音乐素材 2.搭建游戏窗口 第一部分（基本结构）
import pygame class Main(object): def __init__(self, title, height, width, Fps=60): self.title = title self.height = height self.width = width self.Fps = Fps self.main() self.events() def main(self): pygame.init() # Pygame初始化 pygame.display.set_caption(self.title) # 设置窗口标题 # 设置窗口尺寸 self.screen = pygame.display.set_mode([self.height, self.width]) # 将屏幕赋值为全局变量方便之后的调用 def events(self): while True: # 持续侦测事件 （循环使窗口一直显示 否则窗口会一闪而过） for event in pygame.event.get(): if event.type == pygame.QUIT: # 侦测窗口右上角的x是否被按下 # 如果x被按下 则关闭窗口 pygame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/026ea6719d5854246d400e0238b4c301/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74253fd101f03b4b6cf8dcf911e62ea7/" rel="bookmark">
			实现 App 自动检测更新（Vue3 &#43; Ionic &#43; Cordova &#43; Capacitor）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 实现 App 自动检测更新的原理
1. 效果
2. 原理
二. 实现 App 自动检测更新的实践
1. 需要安装的插件
1.1 capacitor
1.2 cordova
2. 封装 app-update-main.ts（应用检查更新 - 入口）
2.1 定义应用信息的全局变量
2.2 获取服务器上最新的应用信息
2.3 获取当前设备信息
2.4 获取当前应用信息
2.5 处理版本号
2.6 根据全局信息、当前平台，判断是否更新及所需方法
2.7 添加 询问用户是否更新 的提示框
3. 封装 app-update-auxiliary.ts（应用检查更新 - 辅助）
3.1 根据文件名，判断文件媒体类型
3.2 获取 存放下载文件 的基本路径
3.3 添加下载 安装包（.apk） 的方法
3.4 计算文件下载进度
3.5 添加下载进度提示框
3.6 添加文件是否打开的提示框
3.7 添加打开 安装包（.apk）的方法
4. App 自动检查更新 方法执行的位置
一. 实现 App 自动检测更新的原理 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74253fd101f03b4b6cf8dcf911e62ea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcf7da98be51410e61c3dc9a705c8dd7/" rel="bookmark">
			Java之hashMap遍历方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在java开发中，hashMap是非常重要的容器类，存储的是键值对(key，value)。
HashMap继承AbstractMap，实现了Map、Cloneable、Serializable接口，非线程安全类，但是效率高。HashMap允许null健和null值，允许value重复，但不允许key重复。HashMap有两个参数影响其性能，初始容量和加载因子，当哈希表中的条目数超出加载因子与当前容量的乘积时，要对哈希表进行refresh操作，重建内部数据结构，容量扩大为之前的两倍，加载因子默认值为0.75。
HashMap的遍历方式
第一种，遍历HashMap的entrySet键值对集合，通过HashMap.entrySet()得到键值对集合，通过迭代器Iterator遍历集合得到key和value。
public static void main(String[] args) { Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put("caocao","11"); map.put("liubei","22"); map.put("sunquan","33"); first(map); } private static void first(Map&lt;Object, Object&gt; map) { Iterator&lt;Map.Entry&lt;Object, Object&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry&lt;Object, Object&gt; entry = iterator.next(); System.out.println("key:" + entry.getKey() + ",vaule:" + entry.getValue()); } } 第二种，遍历HashMap的keySet集合，通过HashMap.keySet()得到key集合，通过迭代器Iterator遍历集合得到key和value。
private static void second(Map&lt;Object, Object&gt; map) { Iterator&lt;Object&gt; iterator = map.keySet().iterator(); while (iterator.hasNext()) { Object key = iterator.next(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcf7da98be51410e61c3dc9a705c8dd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5232978ca75f8b4bb7019976d0b6c348/" rel="bookmark">
			移动互联网寒冬，Android 程序员的出路在哪里？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安卓行业主要问题是初级Android太多了，会写XML和Activity的程序员太多了，初中级程序员面临很大的竞争，现状也就偏于高级开发者。
越来越多的初中级Android程序员找不到满意的工作，甚至根本找不到工作！所以很多人觉得Android要凉了，甚至不惜转行，从头学其它技术。
现在的Android招聘要求，已经不是多年之前的要求了。
Android 应用开发发展到今天，已经成为一个非常成熟的技术方向，从目前的形势来看，Android开发相当火热，但是高级Android开发人才却比较少，现在移动互联网的开发者也逐步开始关注插件化技术、性能优化、行业新技术，系统架构等进阶技术。
这也同时造成了一种现像，安卓开发人员感受到行业现在已经是冰火两重天的环境了，技术不全面，还停留在中低端技术水平的，辛辛苦苦写代码，为了一年涨2千块钱的工资,疯狂加班，还要被降薪，还要时刻担心被裁员。
而中高级开发人员却是企业青睐的对象，工资越来越高，同时也出现了市场岗位情况是中低端开发人员多人竞争一个岗位，而中高级开发人员一人竞争多个岗位的现状。
要如何成为一名Android移动互联网架构师？ 这份《2022年Android中高级面试题汇总》PDF版免费分享给大家，内容概要：包括 Handler、Activity相关、Fragment、service、布局优化、AsyncTask相关、Android 事件分发机制、 Binder、Android 高级必备 ：AMS,WMS,PMS、Glide、 Android 组件化与插件化等面试题和技术栈！需要的小伙伴请扫下方csdn官方二维码备注暗号“2”免费领取
Java基础 Android基础 UI控件篇 网络通信篇 架构设计篇 性能优化篇 源码流程篇 面试题合集 文末 由于篇幅限制不能把每个技术栈的面试题截全就只截图部分了，还望谅解。需要这份《2022年Android中高级面试题汇总》PDF版的小伙伴请扫下方csdn官方二维码免费领取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64c07f5d9ed963f2488a986f998b2af0/" rel="bookmark">
			Arrays类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Arrays类的定义 Arrays类位于 java.util 包中，主要包含了操纵数组的各种方法
使用时导包:import java.util.Arrays
二、Arrays常用函数 1. void Arrays.sort() void Array.sort(Object[] array) 功能：对数组按照升序排序 示例：
int[] nums = {2,5,0,4,6,-10}; Arrays.sort(nums); for(int i :nums) System.out.print(i+" "); /* 之前:2 5 0 4 6 -10 * 结果:-10 0 2 4 5 6 */ Arrays.sort(Object[] array, int from, int to) 功能：对数组元素指定范围进行排序（排序范围是从元素下标为from,到下标为to-1的元素进行排序） 示例：
int[] nums = {2,5,0,4,1,-10}; //对前四位元素进行排序 Arrays.sort(nums, 0, 4); for(int i :nums) System.out.print(i+" "); /* 之前:2 5 0 4 1 -10 * 结果:0 2 4 5 1 -10 */ 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64c07f5d9ed963f2488a986f998b2af0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d7a1845927613c673240f99891382d/" rel="bookmark">
			【Java编程性能调优】常用的性能测试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常用的性能测试工具 开源免费： ab（ApacheBench）、JMeter
付费：LoadRunner
ab：简单易上手，在测试 Web 服务时非常实用；JMeter：功能性比较全，Windows 环境下有图形界面，不仅可以实现简单的并发性能测试，还可以实现复杂的宏基准测试；LoadRunner：在性能压测时，表现得非常稳定和高效。相比 JMeter，LoadRunner 可以模拟出不同的内网 IP 地址，通过分配不同的 IP 地址给测试的用户，模拟真实环境下的用户。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/746e862c54e8af90c18c7bd8d6580720/" rel="bookmark">
			NSIS 简单教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NSIS Setup 如果这个页面是您第一次使用NSIS，那么您将需要NSIS编译器来将以下脚本和您创建的其他脚本转换为有效的安装程序。您可以使用NSIS菜单，并在编译器部分下单击编译NSI脚本启动MakeNSISW。
NSIS安装文件夹中的makensisw.exe是实际的编译器。它有一个图形化的前端，解释了三种加载脚本的方法，所以它非常容易使用。安装NSIS之后，要创建一个安装程序，需要将脚本复制到文本编辑器中，保存扩展名为.nsi的文件，并将该文件加载到makensisw编译器中。
最简代码 # name the installer OutFile "Installer.exe" # default section start; every NSIS script has at least one section. Section # default section end SectionEnd 简单的Hello World-弹出框 当安装程序运行时，这个hello world脚本将创建一个带有单词“hello world”和一个“OK”按钮的弹出框
# set the name of the installer Outfile "hello world.exe" # create a default section. Section # create a popup box, with an OK button and the text "Hello world!" MessageBox MB_OK "Hello world!" SectionEnd 简单的Hello World-写文本到文件 当安装程序运行时，这个hello world脚本将把“hello world”写入一个文本文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/746e862c54e8af90c18c7bd8d6580720/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc16de431b1a8beb95d18d7def14dd20/" rel="bookmark">
			旋转向量（旋转矩阵）与欧拉角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		旋转向量（旋转矩阵）与欧拉角，这里相互转换的方法是：
旋转向量--&gt;旋转矩阵--&gt;欧拉角
旋转矩阵--&gt;欧拉角
一、旋转向量--&gt;旋转矩阵--&gt;欧拉角 SO(3)的旋转矩阵有9个量，但是只有3个自由度，同理SE(3)有16个量，但是也只有6个自由度。在实际的旋转中，任意的旋转都可用一个旋转轴和一个旋转角来表示，我们使用一个向量，方向与旋转轴一致，长度等于旋转角，这样只需要一个三维向量即可描述旋转。对于SE(3),用一个旋转向量和一个平移向量即可表达，恰好自由度为6.如果用旋转向量来描述R：旋转轴为一个单位长度的向量n,角度为𝜃θ，那么𝜃nθn可以表示这个旋转。旋转矩阵R和旋转向量𝜃nθn的转换过程为罗德里格斯变换：
此处末尾的n∧n∧ 如上面所示，代表矩阵表示的向量。那么反过来通过旋转矩阵获取转角 𝜃θ; tr(R)为矩阵R的迹。对于转轴n,Rn=n;表示为转轴绕自身转动不生改变，从数学来说n是矩阵R特征值为1时对应的特征向量。从现在来看旋转轴和旋转角来表示的旋转是紧凑的，没有冗余性，但是欧拉角RPY的空间中，当一个旋转达到+⎯⎯⎯90∘+_90∘是就出现了奇异性。相当于地球的经纬度中当纬度为+⎯⎯⎯90∘+_90∘时，经度无意义。
二、旋转矩阵--&gt;欧拉角 这是工作上遇见的一些问题，简单记录下 ，更为丰富的三维转换可以了解。
欧拉角、四元数、旋转矩阵、轴角之间的转换 三维旋转：欧拉角、四元数、旋转矩阵、轴角之间的转换 - 知乎 (zhihu.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0d2db962d7a25ada9be29a11936439d/" rel="bookmark">
			解析java字节码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java字节码划分区域
图中u4、u2等表示的是字节u4就是4个字节u2就是2个字节以此类推
idea查看class的十六进制的方式
看这里 https://blog.csdn.net/weixin_45112292/article/details/115609491 开始分析准备解析
其中魔术就是magic它表示的是字节码的开头CAFEBABE这个单词
然后次版本号也就是minor version
然后主版本号majorversion
然后常量池。。。现在应该会看图了后面的不写了
对应的次版本号与主版本号
然后常量池类型图 先看一个简陋的图
描述符
* byte B // 这个B就是描述符 描述的是byte类型 下面都是同理 * char C * short S * int I * float F * long J 注意，不是L * double D * void V * * 引用类型 Ljava/lang/StringLjava/lang/String; 这个引用类型是L * 数组 [[[[I =&gt; 一维int类型的数组 数组是[ 一个[是一维数组两个是二维数组也就是[[这样N * 维数组就是N个[ * * [Ljava/lang/String; 这样就表示一个String类型的数组 String[] 这样的 描述符图
修饰符的标记
大端小端 就是数据在内存中的样子可能是反着的
描述的列值为1 这个下面看字节码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0d2db962d7a25ada9be29a11936439d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3811d34264d35b690c321555e2c43a68/" rel="bookmark">
			Tomcat 安装配置与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat 安装配置与使用 1.简单介绍 Tomcat2. Tomcat 的使用Tomcat 下载与解压Tomcat 的启动与运行 3. 部署 web 应用部署单个 HTML文件部署 博客系统 页面 1.简单介绍 Tomcat 简单来说，Tomcat 就是一个中间件，在B/S架构中，浏览器发出的 HTTP 请求经过 Tomcat 中间件，转发到最终的目标服务器上，响应再通过 Tomcat 返回给浏览器；
Tomcat 所做的事情主要有：
开启监听端口监听用户的请求；
解析用户发送的 HTTP 请求；
封装 HTTP 响应；
2. Tomcat 的使用 Tomcat 下载与解压 下载地址
进入网址之后选择如下页面：
Tomcat 版本有很多, 此处使用 Tomcat 8.5.75；
注意：
需要下载解压工具，否则点击启动脚本就无法运行；下载存放的路径不要有中文、空格以及特殊字符； Tomcat 目录解压缩之后, 可以看到如下结构:
上述目录结构中：
bin 目录：用来存放执行脚本（如启动脚本、终止脚本）；conf 目录：用来存放配置文件，配置文件可以配置服务器端口；lib 目录：存放Tomcat 服务器需要的运行内库，里边都是 jar 格式的文件；（jar 是一个压缩格式，里边存放 class 文件）logs 目录：存放日志文件，包含运行产生的信息；webapps 目录：存放 web 应用（一个webapp 就是一个web应用，该文件夹为复数形式，因此可以存放多个webapp） Tomcat 的启动与运行 在启动 Tomcat 之前，需要先配置 JDK 的环境变量； 配置方法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3811d34264d35b690c321555e2c43a68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5346854dd2e2a01b9d95683749cc4cc/" rel="bookmark">
			(35)pycharm在debug模式下一直显示collecting data
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		setting --&gt; Build, Execution, Deployment --&gt; Python Debugger下，选中第三项"Gevent compatible"即可
参考：[debug] pycharm在debug模式下一直显示collecting data_真理无穷，进一步有进一步的欢喜-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0368d136f46edd8d83708dbbaf6ac533/" rel="bookmark">
			Java算法题整理--2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、求 s=a+aa+aaa+aaaa+aa…a 的值
public class Work4 { public static void main(String[] args) { int x = 0; int sum = 0; System.out.println("请输入数字a:"); Scanner inputNumber = new Scanner(System.in); int i = inputNumber.nextInt(); System.out.println("请输入几个数字相加:"); Scanner num = new Scanner(System.in); int j = num.nextInt(); for (int temp1 = 0;temp1 &lt; j;temp1++) { for (int temp2 = 0;temp2 &lt;= temp1 ;temp2++) { System.out.print(i); x = temp2; } if(x != j - 1 ) System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0368d136f46edd8d83708dbbaf6ac533/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04ad39bd581b5fb0face8d2fdbb65d4a/" rel="bookmark">
			Js实现简单购物车系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次实验目的主要是熟悉对document方法的使用，比如append()、setAttribute()、querySelectAll()等，以及元素的兄弟元素，父亲元素的操作。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; table th, td{ border: 1px solid white; } table th { background-color: #B0C4DE; } table td{ background-color: #F0F0F0; } table{ text-align: center; width:800px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="box"&gt; &lt;div id="addGoods"&gt; 商品名称：&lt;input type="text" id="goodsName"&gt;&lt;br /&gt; 商品价格：&lt;input type="text" id="goodsPrice"&gt;&lt;br /&gt; 商品数量：&lt;input type="text" id="goodsAmounts"&gt;&lt;br /&gt; &lt;input type="button" value="添加" id="add" onclick="addGoods()"/&gt; &lt;/div&gt; &lt;div id="goodsCar"&gt; &lt;h2&gt;购物车&lt;/h2&gt; &lt;table &gt; &lt;tr&gt; &lt;th&gt;&lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04ad39bd581b5fb0face8d2fdbb65d4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f470323f69c3adcc5084c89c6a2e78c8/" rel="bookmark">
			MOD04_L2下载2019.1.1-today
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、地址 EarthData: https://search.earthdata.nasa.gov/点击进入
二、登录 之后弹出下载界面
https://search.earthdata.nasa.gov/downloads/3314666153
save脚本
得到脚本
使用cyg运行脚本 使用Cygwin批量下载卫星数据，以MODIS数据为例
打开Cygwin64 Terminal，依次输入如下命令，每行命令输完点回车。
1、cd G:\MOD04_L2
cd 2019-2021
将路径切换至.sh文件所在的文件夹。斜体改为你自己存放.sh文件的路径。
2、chmod 777 3314666153-download.sh
将.sh文件变为可执行文件。斜体改为你自己的.sh文件名。
3、./3314666153-download.sh
执行.sh文件。./后的斜体改为你自己的.sh文件名。
输入Username和password，即EARTHDATA的用户名和密码，注意输入密码的时候窗口不会显示，输完直接点回车即可。
数据 [ 2019-01-01~today]
https://search.earthdata.nasa.gov/downloads/6364574764
https://ladsweb.modaps.eosdis.nasa.gov/search/order/4/MYD04_3K–61/2019-01-01…2019-06-01/DB/Country:CHN
https://ladsweb.modaps.eosdis.nasa.gov/search/order/4/MYD04_3K–61/2019-06-02…2019-09-30/DB/Country:CHN
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a627ea18530bcf4b52f655001412b75/" rel="bookmark">
			Js实现图片无缝滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; div{ white-space: nowrap; display: inline-block } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="box" style="overflow:hidden; border:1px solid; padding:0px; width:300px; height:98px"&gt; &lt;img src="img-1.jpg" &gt; &lt;img src="img-1.jpg" &gt; &lt;img src="img-1.jpg" &gt; &lt;img src="img-1.jpg" &gt; &lt;/div&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; // 初始化无缝滚动 function initScroll(){ var boxDom = document.getElementById("box"); var ulDom = boxDom.firstElementChild; var ulDom1 = ulDom.cloneNode(); ulDom1.innerHTML = ulDom.innerHTML; boxDom.append(ulDom1); } // 调用初始化函数 initScroll(); // 滚动的内容 // 准备一个实例，用来保存计时器对象 var timeInstance = undefined; var step = 3; function doScroll(){ var boxDom = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a627ea18530bcf4b52f655001412b75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae52bdca6e5db26f734a3e2deaaf1ce/" rel="bookmark">
			SVD计算旋转，平移矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 最近在做手眼标定，3D点云相机+ABB机器人，因相机与机器人在流水线同侧，无法通过传统的eye-to-hand标定板固定在机械臂末端进行手眼标定。
相机与机械臂的位置如下图所示，C是相机，B是机械臂base。
已知：物体在P1点时在C坐标系下的位置坐标，求物体运动到P2点时在B坐标系下的位置，其中P1-&gt;P2的运动是固定的。
问题建模 问题简化为由C下点集和B下的点集，求C-&gt;B的变换矩阵Hcb = Hcp1*Hp1p2*Hp2b.
其中物体在C下的坐标通过点云上获得，物体在B下的坐标通过机械臂末端指向获得。
奇异值分解 假设有两个点集A（同上文点集C）和B，且这两个点集合的元素数目相同且一一对应。为了寻找这两个点集之间的旋转矩阵R RR和转移矩阵t tt。可以将这个问题建模成如下的公式：
为了寻找R 和t ，通常需要一下三个步骤：
（1）计算点集合的中心点
（2）将点集合所有点减去中心点（点集合移动到原点），计算最优旋转矩阵R
（3）计算平移矩阵t
（1）计算中心点 （2）点集移动到中心点计算最优旋转矩阵R 为了计算旋转矩阵R ，需要消除转移矩阵t的影响，所以我们首先需要将点集重新中心化，生成新点集合A ′ 和B ′ 计算点集之间的协方差矩阵H
通过SVD方法获得矩阵的U 、S 和V ,可以计算点集之间的旋转矩阵R 最后，通过R 可以获得转移矩阵t
python代码实现 import numpy as np import open3d as o3d # Input: expects Nx3 matrix of points # Returns R,t # R = 3x3 rotation matrix # t = 3x1 column vector def rigid_transform_3D(A, B): assert len(A) == len(B) N = A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cae52bdca6e5db26f734a3e2deaaf1ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d160f61da8efbd9ff4dc412faa5c330/" rel="bookmark">
			前端开发面试经历分享（苏宁总部-苏宁易购面试题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间参加了苏宁总部面试，跟大家分享一下面试经验、流程、面试题。总共两轮技术面。
第一轮是电话面试，根据谈话语气，我觉得考官应该是前端的同事级别。 首先肯定是自我介绍以及所做项目的技术栈，然后就是考官问的一些有关前端的技术问题（应该是准备好的问题，一连串的问）
css3的动画属性了解吗？说一下描述一下promise异步操作说一下vue的生命周期、钩子函数对ES6熟悉吗？简单介绍一下？this指针知道吗？说一下打包工具：webpack的相关配置，有没有手动配置过？webpack与gulp有什么区别？跨域是怎么解决的？ 总体来说，第一轮技术面问题没有太深入，只是第一层，没什么难度。
第二轮现场面试，短信通知来到苏宁总部 HR发你一个表格、一个面试题，十来个人在填写（不同的岗位），前端总共三道简答题，有一道题不记得了。
网页出现白屏的原因有哪些？ES7的相关知识 面试官来了，拿钥匙另一个房间，一对一面试，先也是自我介绍，然后问了技术问题，整理如下：
BFC和IFC（一个例子三个li标签设置inline-block，第一个添加文本，问为什么不对齐）浅拷贝、深拷贝怎么实现vuex数组合并方法，考官注重原型链中方法promiseH5的哪些新特性canvas、svg判断是否是数组还是对象，原型链的方法toString.call原生js实现下拉框的城市联动，描述下思路css怎么实现三角形css3动画属性div中的图片旋转，怎么不让其脱离外框axios在请求前结束请求catch，请求拦截webpack优先级加载优化浏览器回流了解吗 问的问题比较广，考官很善谈，没答出来的，他会告诉你。
最后聊了一下公司的主要项目，以及工作时间，跟我说是朝九晚八。哈哈哈，据我了解苏宁晚上不到十点下班的是少之又少。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d18941d05fb75597835a49939e1402/" rel="bookmark">
			机器学习四 KNN算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KNN算法 前言一、距离常量二、KNN算法步骤三、算法优点四、算法缺点五、代码示例 前言 KNN解决的是分类问题。
k-Nearest Neighbor算法,也叫K最近邻算法K近邻算法KNN就是给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例（K个邻居），这K个实例的多数属于某个类，就把该输入实例分类到这个类中通俗地讲，就是“物以类聚，人以群分”。分类策略，就是“少数从属于多数”。
提示：K一般取奇数
样本类别的分布足够好的话，那么K值越大，划分的类别就越正确。而KNN中的K表示的就是划分数据时，所取相似样本的个数。
一、距离常量 KNN可以采用Euclidean（欧几里得）、Manhattan（曼哈顿）、Mahalanobis（马氏距离）等距离用于计算。
示例：pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。
二、KNN算法步骤 算距离：给定待分类样本，计算它与已分类样本中的每个样本的距离；找邻居：圈定与待分类样本距离最近的K个已分类样本，作为待分类样本的近邻；做分类：根据这K个近邻中的大部分样本所属的类别来决定待分类样本该属于哪个分类； 三、算法优点 算法本身简单有效，精度高,对异常值不敏感,易于实现，无需估计参数，分类器不需要使用训练集进行训练，训练时间复杂度为0。特别适合于多分类问题(multi-modal,对象具有多个类别标签)适合对稀有事件进行分类； 四、算法缺点 算法计算量较大分类时需要先计算待分类样本和全体已知样本的距离，才能求得所需的K近邻点，计算量较大，尤其是样本数量较多时。加入某些类别的样本容量很大，而其他类样本容量很小，即已知的样本数量不均衡，有可能当输入一个和小容量类相同的的新样本时，该样本的K个近邻中，大容量类的样本占多数，从而导致误分类。 五、代码示例 代码如下（示例）：
import numpy as np import matplotlib.pyplot as plt import matplotlib #数据集 x_data = np.array( [[3,104], [2,100], [101,10], [1,81], [99,5], [98,2] ] ) #标签 y_data = np.array(['R','R','A','R','A','A']) #测试数据 x_test = np.array([18,90]) #计算数据大小 num = x_data.shape[0] #打印散点图 for i in range(num): if y_data[i] == 'R': scat1 = plt.scatter(x_data[i][0],x_data[i][1],c='r') else: scat2 = plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1d18941d05fb75597835a49939e1402/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/260/">«</a>
	<span class="pagination__item pagination__item--current">261/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/262/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>