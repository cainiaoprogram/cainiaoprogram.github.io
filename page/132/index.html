<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10da4e122cd05f5f050761caea91a1f4/" rel="bookmark">
			使用Docker容器运行Mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
使用Docker容器运行Mysql 前言一、基础的虚拟机环境二、安装过程安装配置docker拉取Mysql镜像用docker启动mysql命令的使用和参数具体解释如下：1.必要参数：2.数据卷配置参数：3.MySQL账户安全参数：4.容器启动参数： 总结 前言 随着虚拟化技术和云计算的普及，容器技术的优点也逐步体现，软件部署和环境迁移的优势无可替代。
目前Docker已经成为容器技术中的主要代表，恰好涉及需要在liunux系统上部署Mysql数据库用于测试，由于是初次使用docker部署Mysql，所以对其中一些操作进行记录。
一、基础的虚拟机环境 使用虚拟机，安装ubuntu系统，发行版和内核信息如下：
root@ldap:/# cat /etc/lsb-release DISTRIB_ID=Ubuntu DISTRIB_RELEASE=22.04 DISTRIB_CODENAME=jammy DISTRIB_DESCRIPTION="Ubuntu 22.04.2 LTS" root@ldap:/# uname -r 5.15.0-72-generic root@ldap:/# 只所以使用ubuntu是因为centos各大镜像站都已经停止维护，在基础系统安装过程中，经常出现一些莫名其妙的问题，虽然可以解决但比较浪费时间。
二、安装过程 安装配置docker # 安装 docker 和 docker-compose #先移除docker。其实也不用重装docker，我用的ubuntu里已经安装了完整的docker，但我想用用华为云发布的docker-ce，所以就按说明对原docker进行了移除操作 #如果不是root用户，则需要加sudo，否则不用。 sudo apt remove docker docker-engine dockdocker.io containerd runc #更新后，安装依赖，apt源已经改为华为镜像源 sudo apt update sudo apt install -y \ apt-transport-https \ ca-certificates \ curl \ gnupg-agent \ software-properties-common #运行公钥，添加docker软件仓库 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10da4e122cd05f5f050761caea91a1f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b673d8cef3a01c2621ebbb3794b7db3e/" rel="bookmark">
			C#/.Net开发chatGPT、openAI的简单步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenAI提供了多个API接口，可以用于自然语言处理、文本生成、图像处理等领域。以下是OpenAI常用的API接口介绍：
GPT-3：自然语言处理模型，可以用于生成文本、回答问题、翻译等。
DALL-E：图像生成模型，可以根据文本描述生成图像。
Codex：代码生成模型，可以根据自然语言描述生成代码。
CLIP：图像处理模型，可以将图像和文本进行匹配。
GPT-2：自然语言处理模型，可以用于生成文本、对话系统等。
API Playground：可以在其中测试OpenAI的各种API接口。
以上是OpenAI常用的API接口介绍，可以根据需要选择相应的接口进行开发和使用。
要在C#/.Net开发chatGPT、openAI，可以按照以下步骤进行：
注册openAI账号，获取API Key。可以在openAI官网上注册账号，并创建API Key。
安装openAI的C#/.Net SDK。可以在NuGet包管理器中搜索openai-csharp-sdk，并安装。
在C#/.Net项目中引用openAI SDK，并调用openAI API。可以通过以下代码示例来调用openAI的API：
using OpenAI_API; using OpenAI_API.Model; // 创建API客户端 var client = new OpenAIClient("YOUR_API_KEY"); // 调用API var response = client.Completions.CreateCompletion( new CompletionRequest { Model = "davinci", Prompt = "Hello, my name is", MaxTokens = 5 } ); // 获取API响应 var result = response.Choices[0].Text; 如果需要使用chatGPT，可以使用类似的步骤，只需要将API请求参数和响应解析进行相应的调整即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a0ca99a0ba09a75b0ac41037ca169b/" rel="bookmark">
			Flutter 笔记 | Flutter 自定义组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter 自定义组件的几种方式 当Flutter提供的现有组件无法满足我们的需求，或者我们为了共享代码需要封装一些通用组件，这时我们就需要自定义组件。在Flutter中自定义组件有三种方式：通过组合其他组件、自绘和实现RenderObject。
1. 组合多个Widget
这种方式是通过拼装多个组件来组合成一个新的组件。例如我们之前介绍的Container就是一个组合组件，它是由DecoratedBox、ConstrainedBox、Transform、Padding、Align等组件组成。
在Flutter中，组合的思想非常重要，Flutter提供了非常多的基础组件，而我们的界面开发其实就是按照需要组合这些组件来实现各种不同的布局而已。
2. 通过CustomPaint自绘
如果遇到无法通过现有的组件来实现需要的UI时，我们可以通过自绘组件的方式来实现，例如我们需要一个颜色渐变的圆形进度条，而Flutter提供的CircularProgressIndicator并不支持在显示精确进度时对进度条应用渐变色（其valueColor 属性只支持执行旋转动画时变化Indicator的颜色），这时最好的方法就是通过自定义组件来绘制出我们期望的外观。我们可以通过Flutter中提供的CustomPaint和Canvas来实现UI自绘。
3. 通过RenderObject自绘
Flutter提供的自身具有UI外观的组件，如文本Text、Image都是通过相应的RenderObject渲染出来的，如Text是由RenderParagraph渲染；而Image是由RenderImage渲染。RenderObject是一个抽象类，它定义了一个抽象方法paint(...)：
void paint(PaintingContext context, Offset offset) PaintingContext代表组件的绘制上下文，通过PaintingContext.canvas可以获得Canvas，而绘制逻辑主要是通过Canvas API来实现。子类需要重写此方法以实现自身的绘制逻辑，如RenderParagraph需要实现文本绘制逻辑，而RenderImage需要实现图片绘制逻辑。
可以发现，RenderObject中最终也是通过Canvas API来绘制的，那么通过实现RenderObject的方式和上面介绍的通过CustomPaint和Canvas自绘的方式有什么区别？其实答案很简单，CustomPaint只是为了方便开发者封装的一个代理类，它直接继承自SingleChildRenderObjectWidget，通过RenderCustomPaint的paint方法将Canvas和画笔Painter(需要开发者实现，后面介绍)连接起来实现了最终的绘制（绘制逻辑在Painter中）。
总结：“组合”是自定义组件最简单的方法，在任何需要自定义组件的场景下，我们都应该优先考虑是否能够通过组合来实现。而通过CustomPaint和RenderObject自绘的方式本质上是一样的，都需要开发者调用Canvas API手动去绘制UI，优点是强大灵活，理论上可以实现任何外观的UI，而缺点是必须了解Canvas API细节，并且得自己去实现绘制逻辑。
组合现有组件 实例：自定义渐变按钮 Flutter Material组件库中的按钮默认不支持渐变背景，为了实现渐变背景按钮，我们自定义一个GradientButton组件，它需要支持以下功能：
背景支持渐变色手指按下时有涟漪效果可以支持圆角 我们先来看看最终要实现的效果：
DecoratedBox可以支持背景色渐变和圆角，InkWell在手指按下有涟漪效果，所以我们可以通过组合DecoratedBox和InkWell来实现GradientButton，代码如下：
import 'package:flutter/material.dart'; ///组合方式定义一个渐变色按钮 ///使用DecoratedBox、Padding、Center、InkWell等组合而成 class GradientButton extends StatelessWidget { const GradientButton({ Key? key, this.colors, this.width, this.height, this.onPressed, this.borderRadius, required this.child, }): super(key: key); // 渐变色数组 final List&lt;Color&gt;? colors; // 按钮宽高 final double? width; final double? height; final Widget child; final BorderRadius?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43a0ca99a0ba09a75b0ac41037ca169b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb770aa0172356f2663e76ac4bda092/" rel="bookmark">
			centos下载内容失败---连接不上网络问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@CentOS7使用yum命令安装软件提示cannot find a valid baseurl for repo: base/7/x86_64的解决方案
问题一：在搭建Centos中，发现使用yum安装软件联网失败 [root@localhost ~]# yum install vim 已加载插件：fastestmirror Loading mirror speeds from cached hostfile * base: mirrors.163.com * extras: mirrors.163.com * updates: mirrors.163.com base | 3.6 kB 00:00:00 docker-ce-stable | 3.5 kB 00:00:00 https://download.docker.com/linux/centos/docker-/repodata/repomd.xml: [Errno 14] HTTPS Error 404 - Not Found 正在尝试其它镜像。 To address this issue please refer to the below wiki article https://wiki.centos.org/yum-errors If above article doesn't help to resolve this issue please use https://bugs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcb770aa0172356f2663e76ac4bda092/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39fbf623beef68130b7e40b939058bad/" rel="bookmark">
			蓝牙模块（HC-05）与手机连接，蓝牙与蓝牙互联,电脑通过蓝牙控制单片机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务一：蓝牙与手机连接 所用模块： HC-05蓝牙模块，USB TO TTL手机APP为SPP蓝牙串口
第一章：蓝牙模块配置 一：HC-05与USB TO TTL连接 EN：为使能引脚，一般不接
VCC：接USB TO TTL模块的5ｖ脚（3.3v不亮）
GND：接USB TO TTL模块的GND脚
TXD：接USB TO TTL模块的RXD脚
RXD：接USB TO TTL模块的TXD脚
STATE：状态引脚，一般不接
二：进入AT模式 按住按键的同时插上USB TO TTL，指示灯1S慢闪
三：设置参数 进入AT模式后，电脑连接串口助手，设置波特率为38400（AT模式下，默认）
依次发送以下指令，返回均为OK
1）AT：进入AT模式
2）AT+ORGL：恢复出厂设置，以防止该模块被其他人使用过
3）AT+PSWD=“XXXX”：设置匹配密码，最低4位（AT+PSWD？：查看蓝牙模块密码）
4）AT+NAME=XXX：设置蓝牙模块名字（AT+NAME？：查看蓝牙模块名字）
5）AT+UART=115200,0,0：设置通信波特率，但不是AT模式波特率，波特率设置为115200，停止位和校验位为0（AT+UART？：查看波特率）
第二章：手机APP下载以及配置 一：手机应用商店下载SPP蓝牙串口APP 测试过几款应用，该应用比较好用
二：不按按键重新连接蓝牙模块 进入正常工作模式，此时波特率为115200，停止位和校验位为0
三：连接蓝牙 打开SPP蓝牙串口APP连接蓝牙即可发送接受数据
== 注意:==串口助手设置波特率为115200，手机APP设置为utf-8编码模式
任务二：蓝牙模块之间的相互通信 所用模块： 两个HC-040蓝牙模块，两个USB TO TTL
第一章：蓝牙模块配置 一：连接HC-05与USB TO TTL（两个蓝牙均是） EN：为使能引脚，一般不接
VCC：接USB TO TTL模块的5ｖ脚（3.3v不亮）
GND：接USB TO TTL模块的GND脚
TXD：接USB TO TTL模块的RXD脚
RXD：接USB TO TTL模块的TXD脚
STATE：状态引脚，一般不接
二：进入AT模式（两个蓝牙均是） 按住按键的同时插上USB TO TTL，指示灯1S慢闪
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39fbf623beef68130b7e40b939058bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2890d6a818ee8b73df8775ffbfdabc6/" rel="bookmark">
			【wx 小功能】frame_tools.py
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WX 小工具学习
# -*- coding: utf-8 -*- ########################################################################### ## Python code generated with wxFormBuilder (version 3.10.1-0-g8feb16b3) ## http://www.wxformbuilder.org/ ## ## PLEASE DO *NOT* EDIT THIS FILE! ########################################################################### # from datetime import time import datetime import wx import wx.xrc import wx.adv ########################################################################### ## Class mainFrame ########################################################################### TRAY_ICON = 'tray.ico' class mainFrame(wx.Frame): def __init__(self, parent): wx.Frame.__init__(self, parent, id=wx.ID_ANY, title=u"常用功能展示", pos=wx.DefaultPosition, size=wx.Size(1053, 596), style=wx.CAPTION | wx.CLOSE_BOX | wx.MINIMIZE_BOX | wx.SYSTEM_MENU | wx.TAB_TRAVERSAL) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2890d6a818ee8b73df8775ffbfdabc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad0505249f879f532469e597f8828a0/" rel="bookmark">
			git 文件恢复与项目还原：008
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 【文件恢复】：将文件恢复到上一次提交的状态 注意：新建且没有提交的文件无法使用文件恢复
命令：
git checkout -- 文件名 假如我们的一开始是这样的，这是没有报错的状态文件
然后我添加了一段内容， 比如我添加这段内容项目报错了， 我需要恢复到没有报错的状态
方法一：代码比较，找到修改的内容将其修改回来，这种方法只适用修改比较少的情况。这种方法不做演示
方法二：文件恢复，将文件恢复到未被修改的状态
首先使用git status查看一下状态， 可以看到这个文件是未被追踪状态
然后可以使用命令：git checkout -- test_file.txt 将文件恢复到未被修改的状态
1.1：撤销追踪：对于那些已经使用了git add 的文件， 这时候是无法对文件进行恢复的，需要将文件撤销追踪才能对文件使用恢复功能
假如我们对文件进行一个修改， 并对他使用 git add 命令
这个时候使用 checkout 命令是无法起作用的，如下，文件还是无法恢复到未被修改状态
这个时候就需要使用命令 git reset HEAD 文件名 对它进行追踪撤销。
然后使用 git status 命令查看当前文件状态，可以看到该文件是未添加到缓存区一个状态， 这个时候就可以对这个文件使用 checkout 命令来恢复了
恢复命令，可以看到文件已经被恢复了
2. 【版本还原】 命令：
git reset -- hard DEAD^ 回退到上一个版本
git reset -- hard DEAD^^ 回退到上上一个版本
git reset -- hard 版本号 指定退回到指定版本(注意不能使用HEAD。且一旦回退到指定版本， 那指定版本之前的版本都会消失，所以不建议使用)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ad0505249f879f532469e597f8828a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fb9dea20fed3f45eb39c190c00a8db1/" rel="bookmark">
			PCA主成分分析 | 机器学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、概述(Principal componet analysis,PCA) 是一种无监督学习方法，是为了降低特征的维度。将原始高维数据转化为低维度的数据，高维数据指的是数据的特征维度较多，找到一个坐标系，使得这些数据特征映射到一个二维或三维的坐标系中，尽可能地保留原始数据的主要信息（方差信息），信息损失是最小的。
举个例子： 在实际工作中，可能会遇到特征维数过多，且部分特征具有一定相关性。如：在一个学生成绩数据集中，一个特征是学习时长，另一个特征是成绩，一般来讲，学习时间越长，越容易取得好成绩，即时长与成绩呈正相关。因此没必要用两个维度（时长和成绩）表达这一特征。我们可以找出另一个维度，表现这两个特征，且不会带来过多信息损失。
信息保留最多（从图像上看就是越分散，方差越大。如果点都比较重合，失去了意义）
怎么样最好：
找到数据分布最分散的方向（方差最大），作为主成分（坐标轴）
利用正交变换把线性相关变量表示的观测数据转换为几个由线性无关变量表示的数据，线性无关的变量成为主成分。主成分的个数通常小于原始变量的个数，属于降维方法。
根据分解协方差矩阵的策略，分为两种PCA方法，第一种是基于特征值分解协方差矩阵实现PCA算法，第二种是**基于奇异值分解法(SVD)**分解协方差矩阵实现PCA算法。
PC：找到的每个新特征向量，降低特征个数，降维找出数据中最主要的，用最主要的代替原始数据。非监督的降维方法
信息衡量指标： 样本方差，方差越大，特征所带信息量越多。
2、算法流程 输入：n维样本集D=(x(1),x(2),…,x(m))，要降维到的维数n’.
输出：降维后的样本集D′
1 .数据标准化
对所有样本进行中心化（把坐标原点（0，0）放在数据中心，数据中心通过计算均值，样本-均值）；第二是找坐标系（找到方差最大的方向）；
2 计算样本协方差矩阵XXT
将标准化后的数据组成一个n×d的矩阵X，其中n表示样本数量，d表示特征数量。计算协方差矩阵C=XTX/n-1。因为样本协方差矩阵XXT包含了数据的方差和协方差信息。
3.计算特征值和特征向量：
对协方差矩阵进行特征值分解，得到特征值λ1,λ2,…,λd和对应的特征向量v1,v2,…,vd。特征向量是单位向量，满足Cvi=λivi。对协方差矩阵进行特征值分解，将特征值从大到小排列。
那么为什么计算呢，要通过计算协方差矩阵的特征值和特征向量，我们可以找到原始数据中最具有代表性的主成分（也就是方差最大的方向），从而实现降维。因为在PCA中，特征值是协方差矩阵的特殊值，代表着数据在某个方向上的方差大小。具体来说，对于一个d维数据集，其协方差矩阵C的每个特征值λi表示数据在第i个主成分方向上的方差大小。λi越大，说明数据在第i个主成分方向上的方差越大，也就是说，这个方向上的信息量越多，越能够代表原始数据的特征。因此，在PCA中，我们通常选择前k个最大的特征值对应的特征向量作为新的坐标系，并将原始数据投影到这个新的坐标系上，从而实现降维。
在PCA中，特征值是协方差矩阵的特殊值，代表着数据在某个方向上的方差大小。具体来说，对于一个d维数据集，其协方差矩阵C的每个特征值λi表示数据在第i个主成分方向上的方差大小。λi越大，说明数据在第i个主成分方向上的方差越大，也就是说，这个方向上的信息量越多，越能够代表原始数据的特征。因此，在PCA中，我们通常选择前k个最大的特征值对应的特征向量作为新的坐标系，并将原始数据投影到这个新的坐标系上，从而实现降维。
接下来用数据例子说明下
假设我们有一个2维数据集，包含5个样本点：
X = [[2, 3], [3, 4], [4, 5], [5, 6], [6, 7]] 我们希望对这个数据集进行降维，将其从2维降到1维。首先，我们需要计算协方差矩阵C：
C = np.cov(X.T) 计算得到的协方差矩阵C为：
array([[ 0.7, 0.7], [ 0.7, 0.7]]) 接下来，我们需要计算C的特征值和特征向量：
eig_vals, eig_vecs = np.linalg.eig(C) 计算得到的特征值和特征向量为：
eig_vals = [1.4, 0] eig_vecs = [[ 0.70710678, -0.70710678], [ 0.70710678, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fb9dea20fed3f45eb39c190c00a8db1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8361cf1f76ae42d4048808ac150f6927/" rel="bookmark">
			latent diffusion model 复现问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		latent diffusion model 复现问题记录 按照官方github配置虚拟环境下载预训练模型ModuleNotFoundError: No module named 'ldm'生成数据集效果展示参考链接 按照官方github配置虚拟环境 官方github地址：
latent diffusion model
下载environment.yaml和setup.py文件进行环境配置
conda env create -f environment.yaml
conda activate ldm
在配置环境的过程中，会出现报错
Installing pip dependencies: \ Ran pip subprocess with arguments: ['/home/****/.conda/envs/ldm/bin/python', '-m', 'pip', 'install', '-U', '-r', '/mnt/****/****/latent-diffusion-main/condaenv.ie4dsr_m.requirements.txt'] Pip subprocess output: Obtaining taming-transformers from git+https://github.com/CompVis/taming-transformers.git@master#egg=taming-transformers (from -r /mnt/****/****/latent-diffusion-main/condaenv.ie4dsr_m.requirements.txt (line 13)) Cloning https://github.com/CompVis/taming-transformers.git (to revision master) to ./src/taming-transformers Pip subprocess error: ERROR: Command errored out with exit status 128: git clone -q https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8361cf1f76ae42d4048808ac150f6927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeac64b1bfaeb284e17005e56dc8c963/" rel="bookmark">
			【C&#43;&#43;】Map、Set 模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 📕 概念📕 实现框架Find()★ 迭代器 ★反向迭代器map 的 operator[ ] 📕 源代码rb_tree.hset.hmap.h 📕 概念 map、set 是 C++ 中的关联式容器，由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 红黑树 的操作行为。
关联式容器也是用来存储数据的，与序列式容器不同的是，其里面存储的是&lt;key, value&gt;结构的键值对，在数据检索时比序列式容器效率更高。
📕 实现 框架 map、set 一个很明显的区别就是，set 存储值，map存储键值对。
set 的结构如下，只需要传入一个模板参数 K ，也就是其实际存储的值的数据类型。复用红黑树的时候，第二个参数就是 K 类型。
#pragma once #include"rb_tree.h" namespace SetSimulate { template&lt;class K&gt; class set { struct KeyOfT { const K&amp; operator()(const K&amp; k) { return k; } }; public: typedef typename RBTree&lt;K, K, KeyOfT&gt;::const_iterator iterator; typedef typename RBTree&lt;K, K, KeyOfT&gt;::const_iterator const_iterator; private: RBTree&lt;K, K, KeyOfT&gt; _t; }; } 而 Map 就不一样了，要传入两个参数，第一个是 K（键值），第二个是 V （映射值）。实际存储的数据类型是 pair&lt;K,V&gt; 。如下，复用红黑树的时候，将其第二个模板参数设为 pair&lt;K,V&gt; 即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeac64b1bfaeb284e17005e56dc8c963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b5498ddf98464b7164c6f117dbe0c34/" rel="bookmark">
			基于tabular包的Latex表格尺寸设置方法（列宽和行高）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于tabular包的Latex表格尺寸设置方法（列宽和行高） tabel语法的小技巧 设置表格的说明文字时，有的场合要求说明文字在表格下方，有的要求说明文字在表格上方，该怎么调整呢？
只需要把\caption语句分别放在\end{tabular}的下面或者\begin{tabular}的上面即可。
设置表格列宽 \begin{tabular}{}语句的大括号中设置每一列的属性，包括有无框线、宽度、对齐方式。详细的说明如下：
指定列宽的设置：
p{width}：例如，第一个表示没有指定列宽（c|lll，即第1列居中，第2-4列左对齐）。第二个表指定了列宽（c|lp{2in}p{1in}，即第1列居中，第2列左对齐，第3列2英尺，第4列1英尺）。其中宽度可以使用的单位有cm、pt、in、em等。
\begin{table}[htbp] \centering \caption{顶层优先疏散策略改进前后时间表} \label{tab:402} \begin{tabular}{p{3cm}&lt;{\centering}p{1.5cm}&lt;{\centering}p{1.5cm}&lt;{\centering}p{1.5cm}&lt;{\centering}p{1.5cm}&lt;{\centering}} \toprule 时间间隔（秒） &amp; T=40 &amp; T=50 &amp; T=60 &amp; T=100 \\ \midrule 改进前（秒） &amp; 3006.3 &amp; 3035.2 &amp; 3038.0 &amp; 3030.5 \\ 改进后（秒） &amp; 2764.8 &amp; 2744.3 &amp; 2745.2 &amp; 2799.0 \\ 提升百分比 &amp; 8.03\% &amp; 9.58\% &amp; 9.64\% &amp; 7.64\% \\ \bottomrule \end{tabular} \end{table} 指定当前列的列宽之后，如果该列文字过多，会自动换行。
设置表格行高 在每个换行符\\后面加上[width]，控制当前行的高度。示例如下，设置每行高度为0.5cm：
\begin{table}[htbp] \centering \caption{一张展示实验结果的三线表} \label{tab:404} \begin{tabular}{@{}cccccc@{}} \toprule \multirow{2}{*}{实验批次} &amp; \multirow{2}{*}{组合方式} &amp; \multicolumn{4}{c}{采样时间（秒）} \\ \cmidrule(l){3-6} &amp; &amp; T=30 &amp; T=50 &amp; T=100 &amp; T=150 \\ \midrule 1 &amp; \begin{tabular}[c]{@{}c@{}}Al+Zn\\HCl\end{tabular} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\[0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b5498ddf98464b7164c6f117dbe0c34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b283fa3a3b83faddc9ef6d17e1cf973b/" rel="bookmark">
			可编程计数器/定时器8253和8254
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 计数器/定时器8253和8254 什么是计数和定时8253/8254的编程结构8253/8254的编程方法8253/8254的工作模式模式0——计数结束产生中断模式1——单负脉冲发生器（可编程单稳态触发器）模式2——频率发生器（分频器）模式3——方波发生器模式4——软件触发的选通信号发生器模式5——硬件触发的选通信号发生器8253/8254的工作模式小结 什么是计数和定时 对于计算机来说，定时就是计数。因为：数数的过程中，如果频率是固定的，时间就知道了两者在实际应用里又有区分。计数：指对外部的输入进行数数。减到0时，输出一个信号便结束。定时：减到0时，自动恢复初值重新计数，并不断产生信号。但从芯片内部来说，这两种情况下的工作过程没有本质差别，都是基于计数器的减1操作微机系统中经常用到定时信号。比如：DRAM刷新定时，多任务分时系统作中断信号实现程序切换，对外设信息进行采样，作为一个可编程波特率发生器，实现时间延迟8254是8253的改进型，体现在8254频率更高，功能更多。8253没有状态寄存器，8254有 8253/8254的编程结构 只有8254有状态寄存器核心是执行部件，执行部件实际上是一个16位的减法计数器 8253/8254的编程方法 8253/8254的控制寄存器和三个计数器具有独立的编程地址：A1A0=00时，选中计数器0；A1A0=01时，选中计数器1；A1A0=10时，选中计数器2；A1A0=11时，选中控制/状态端口控制字本身也会指明所控制的寄存器是哪一个由以上两点原因，对8253/8254的编程没有顺序规定。但有以下三条原则需遵守： 对计数器设初值前需先写控制字设置初值时要符合控制字的格式规定（即只写低位字节或只写高位字节或高低位都写）要读计数器的当前值或状态字，必须先锁存再读取 8253/8254的工作模式 8253/8254作为一个可编程计数器/定时器，可分别在6种不同模式下工作
不论哪种模式，都会遵守下面几条基本规则
写入控制字时，所有控制逻辑电路立即复位，输出端OUT进入初态（可能是高电平，也可能是低）初值写入后，要经过一个时钟周期，计数执行部件才开始计数在时钟脉冲CLK的上升沿，门控信号GATE被采样模式0、4，门控信号为电平触发；模式1、5，门控信号为上升沿触发；模式2、3，既可用电平触发，也可用上升沿触发时钟脉冲的下降沿，计数器作减1计数0是计数器所能容纳的最大初值。用二进制格式时，0相当于216;用BCD码格式时，0相当于104 模式0——计数结束产生中断 写入控制字后，输出端OUT以低电平为初始电平写入计数初值后，GATE=1时，开始计数，计到0时，OUT跳变为高电平，并一直保持（GATE=0时，暂停计数） 注意：
计数过程中，如果写入新初值，则立即将按新初值重新计数计到0时，不会自动装入初值重复计数，除非重新写入初值 模式1——单负脉冲发生器（可编程单稳态触发器） 写入控制字后，输出端OUT以高电平为起始电平写入计数初值N，且GATE受到上升沿触发后，输出端OUT变为低电平，计到0时，OUT跳变为高电平。于是就输出了一个宽度为N个时钟周期的负脉冲（触发后，GATE变为低电平也不会影响计数） 注意:
计数过程中或计数完毕后，若GATE又经历一个从低变高的跳变，那么立即会再次装入初值，重新计数计数过程中，写入新的计数值，当前计数和输出也不会受影响。要想重新计数，只会认准GATE的上升沿在提前触发（即单稳态受触发后未回到稳态而又受到触发）时，会使单稳态输出变宽 模式2——频率发生器（分频器） 写入控制字后，输出端OUT以高电平为起始电平写入初值N，并受到触发后，开始作减1计数，减到1时（注意，不是0），输出端OUT变为低电平，输出1个负脉冲，脉冲宽度为1个时钟周期。然后周期性重复，是个N分频器 注意：
对于计数初值N，输出端OUT用N个时钟周期作为1个周期，并在GATE为高电平时周而复始的重复计数过程中，如果写入新的计数初值，输出端OUT不会受影响。等计数器计到0后，按新的计数值进行计数计数过程中，若GATE变低，则停止计数，GATE变高后，从头开始计数 模式3——方波发生器 写入控制字后，输出端OUT以高电平为起始电平写入初值并受到触发后，开始计数。计数到一半时，输出变为低电平，到0时，又变为高电平，从而完成一个周期 注意：
模式2要注意的就是模式3要注意的 模式4——软件触发的选通信号发生器 写入控制字后，输出端OUT以高电平为起始电平写入初值并受到触发后，开始计数。计到0时，输出1个宽度为1个时钟周期的负脉冲。一般将此负脉冲作为选通信号 注意：
计数过程中，GATE变低电平时，停止计数。GATE变高后，从头开始计数计数过程中，若写入新初值，将立即按新初值从头计数。(这种情况叫软件再触发)无法自动周期性计数，必须靠软件再触发 模式5——硬件触发的选通信号发生器 食用方式同模式4 注意：
模式4是电平触发，模式5是上升沿触发计数过程中，GATE端变低电平不影响计数，若由低跳变到高，则将按计数初值从头计数(这种情况叫硬件再触发)计数过程中，写入新初值，在硬件再触发的条件下，按新初值从头计数与模式4的区别概括下来就是：模式4是软件触发，模式5是用外部电路产生的门控上升沿触发（硬件触发） 8253/8254的工作模式小结 对于方式0，写入控制字后OUT端变低，其余5种方式都是变高模式0、1、4、5是计数器：在GATE控制下进行减1计数，计到0时就停止模式2、3是定时器：在GATE控制下进行减1计数，计到0时，又自动装入初值，重头计数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8a360be8e995b810afaa2118e5b507/" rel="bookmark">
			基于JavaWeb&#43;MySQL的企业员工信息管理系统（考勤、工资、岗位、奖惩等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
绪论 1
1.1 设计背景 1
1.2 设计意义 1
1.3 设计思路 1需求分析 2
2.1 需求描述 2
2.2 用例建模 2
2.3 用例描述 3
2.3.1 个人信息用例描述 3
2.3.2 员工管理用例描述 3
2.3.3 部门管理用例描述 4
2.3.4 考勤管理用例描述 4
2.3.5 奖惩管理用例描述 5
2.3.6 工资管理用例描述 5系统设计 6
3.1 数据库设计 6
3.1.1 数据库整体设计 6
3.1.2 数据库脚本 7
3.2 系统架构设计 8
3.3 模块设计 9
3.3.1 功能模块设计 9产品实现 10
4.1 登录模块的实现 10
4.1.1 界面设计 10
4.1.2 功能实现 10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8a360be8e995b810afaa2118e5b507/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaa2f69076325c20e04be0515949b9d4/" rel="bookmark">
			Git进阶之代码回滚、合并代码、从A分支选择N次提交，合并到B分支【revert、merge、rebase、cherry-pick】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B站视频地址： https://www.bilibili.com/video/BV1KX4y1a7N9
Git学习文档：https://d9bp4nr5ye.feishu.cn/wiki/PeDPw3mm3iFA36k9td9cVeignsZ
在很长一段时间里，我对Git的操作只限于：提交代码，拉取代码，合并代码。
虽然上面这些操作在日常工作中也足够了，但不会点高级知识不利于装X，今天我们来学习几个高级点的操作。
一、前提 在正式操作之前，我们先来共知几个命令和概念。
SHA标识 每一次提交Git都会生成一个唯一SHA标识（简单来说就是为这次提交生成一个唯一字符串），代码合并、回滚、检出都和这个标识相关。
注：SHA标识是指Git中的SHA-1哈希标识符，它是一个40个字符的字符串，用于唯一标识Git中的每个提交、对象和分支。SHA-1是一个加密哈希函数，它接受输入（例如文件内容或提交信息）并生成一个唯一的40字符长的哈希值。
git log Git 的每次提交都会携带很多信息，提交者、提交时间、唯一SHA标识等，想要查看这些信息，可以使用 git log 命令。
git log 完整的查看 log信息，展示效果如下：
git log --oneline 精简提交信息，以一行的方式展示
git log --graph --oneline 以时间线的方式查看精简的日志信息
二、回滚代码 代码回滚，提交了错误的代码、代码错合并到非目标分支
commit 回滚merge 回滚 回滚 使用 git log --graph --oneline 查看日志线，并找到我们要撤回提交的hash
1、找到我们要回滚commit的 hash git log --graph --oneline 2、执行回滚命令 回滚之后可能是有冲突的，是需要手动解决冲突 git revert 1b17801 git push 3、回滚 mergn git revert f259bf5 git push 冲突 如果回滚的时候有冲突，会这样提示
方式一
可以选择放弃这次的回滚 git revert --abort
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaa2f69076325c20e04be0515949b9d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/494ad5d48f8d6d2a4a57746368179a8e/" rel="bookmark">
			【VS2022】Visual Assist v10.9.2435.0 VA_X_Setup2443_0.exe 支持 VS2022
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支持vs2022 的crack版本，无积分下载
VA_X_Setup2440_0
官方 https://www.wholetomato.com/
如果安装多次，启动vs 报错，识别到一些之前版本的信息。
使用everything逐个搜索下 你覆盖的文件，把他们都删掉，重新安装新的就好了。
2476 已上传
官方 2451 官方版本 VA_X_Setup2451_0.exe 下载似乎也不影响。 v10.9.2443.0 win11的 defender 会清理掉piaoyun.dll， 导致vs2022 无法启动恢复了文件也不行只好重新下载一个安装，vs2022就能正常启动，不闪退了。Whole Tomato Visual Assist X v10.9.2443.0 (21 Jan 2022) 无积分。
2440 无积分 这个版本win11双击无反应，要设置下 以兼容win7 运行
VA_X_64 打开路径 C:\Users\zhangbin\AppData\Local\Microsoft\VisualStudio\17.0_9e19d3d4\Extensions\u31j1b2m.l0q 实测VA_X_64替换后 实测vs2022 是VA_X_64位的启动vs ，卡主了？ -牛啊
-------------------------------------分割线-----------------------------------------------
当前还是VA_X.dll crack的大佬们在努力 OLEDLG-for-Visual-Assist-Xvs2022 安装的 Visual Assist X 有木有啥办法 安装 How To VisualAssist Based on Double Sine Study v10.9.2435.0 By DFoX
How To :
Search and replace VA_X.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/494ad5d48f8d6d2a4a57746368179a8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c92aa49fa4346f3546829c7734e2cb/" rel="bookmark">
			CLion - A cross-platform IDE for C and C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CLion - A cross-platform IDE for C and C++ https://www.jetbrains.com/clion/
1. Other Versions - Version 2019.1 https://www.jetbrains.com/clion/download/other.html
2019.1.4 for Linux (tar.gz)
2019.1.4 for Windows (exe)
2019.1.4 for Windows ZIP Archive (win.zip)
2019.1.4 for macOS (dmg)
2. Installation Instructions Unpack the CLion-*.tar.gz file to an empty directory using the following command: tar -xzf CLion-*.tar.gz. A new instance MUST NOT be extracted over an existing one. The target folder must be empty.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52c92aa49fa4346f3546829c7734e2cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc5261cd3db3ab9123d9cea9f3292895/" rel="bookmark">
			Minecraft 1.16.5mod开发 （2.总线概念和第一个物品）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总线 在编写代码之前，介绍一下事件系统。
所谓事件就是我们游戏中所作出的动作、附魔、达成条件替换、特殊效果等一系列都属于事件，但是我们所编写的事件系统不是Minecraft自带的，是Forge实现的。
如果要详细了解可以查看Boson 1.16其中还牵扯总线的概念与事件处理器。
在编写事件时有两种方式 一种是实例方式，一种是静态的方式。
public class MyForgeEventHandler { @SubscribeEvent public void pickupItem(EntityItemPickupEvent event) { System.out.println("666!"); } } @SubscribeEvent注解，这个注解的作用就是标记下方的pickupItem 方法是一个事件处理器
所监听的事件是由其中的参数控制
EntityItemPickupEvent，说明监听的是实体捡起物品这个事件。
当然写完只会还需要注册到总线中（Forge总线和Mod总线）
Forge总线负责的就是除了生命周期事件外的所有事件
命令：MinecraftForge.EVENT_BUS.register()
Mod总线主要负责游戏的生命周期事件，也就是初始化过程的事件
命令：FMLJavaModLoadingContext.get().getModEventBus().register()
所以这个例子我们就要注册到Forge总线中（可以在初始建立的java类中写入，直接当成所有总线的类）
FMLJavaModLoadingContext.get().getModEventBus().register()
如果都采取实例方法的注册会变得非常麻烦，这时就可以使用Forge提供的静态方法
在类上加入
@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD)注解
其中最后的MOD为Mod总线 Forge为Forge总线。
题外话：我们可以把modid封装在使用时直接调用 @Mod(类名.MODID) public class 类名{ public static final String MODID = "自己的MODID"; } 将自己的modid封装一下在调用的时候直接调用类
物品 明确具体步骤 创建自己物品的类继承原版中的物品--》》实例化物品--》》注册物品
1.首先创建两个平级的包 存放我们的物品等和总线各种实例化（名字看自己）
这里就用我自己的来进行介绍 在common中再次创建item包存放我们所有item类后创建咱们的一个物品类并且让这个类继承原版的Item类
public class testItem extends Item { public testItem(Properties p_i48487_1_) { super(p_i48487_1_); } } 非常EZ，然后我们要重写一下这个构造方法（也可以在实例时写入属于的位置和属性）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc5261cd3db3ab9123d9cea9f3292895/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42413da3585205e609417e91285692af/" rel="bookmark">
			《Linux0.11源码解读》理解(四) head之重新设置IDT/GDT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上节提到，现在cs:ip指向0地址，此处存储着作为操作系统核心代码的system模块，是由head.s和 main.c以及后面所有源代码文件编译链接而成。head.s(以下简称head)紧挨着main.c，我们先执行head。
重新设置内核栈 _pg_dir: _startup_32: mov eax,0x10 mov ds,ax mov es,ax mov fs,ax mov gs,ax lss esp,_stack_start 标号 _pg_dir表示页目录，意为在设置分页机制时，页目录会存放在这里，也会覆盖这里的代码。setup.s(以下简称setup)已经设置了gdt，现在要对段描述符重新设置包括ds/es/fs/gs。都被设置为0x10（00010000），在保护模式下即段选择子为2，指向数据段描述符。根据我们之前gdt表的内容，数据段的基地址是0，于是ds/es/fs/gs的基地址也是0。
lss 指令相当于让 ss:esp 这个栈顶指针（esp是sp的32为扩展），指向了 _stack_start 这个标号的位置（对比lds mem,reg：将段描述符mem的高位存储在 reg 寄存器的高位，而段描述符的低位存储在ds寄存器的低位）。当然之前在bootsec所设置的栈顶0x9ff00位置现在变成了0:stack_start：
// include/linux/mm.h #define PAGE_SIZE 4096 // kernel/sched.c long user_stack [ PAGE_SIZE&gt;&gt;2 ] ; struct { long * a; short b; } stack_start = { &amp; user_stack [PAGE_SIZE&gt;&gt;2] , 0x10 }; 其实从第三节得知我们已经在setup的内存（位于0x90200）设置了idt、gdt。现在则通过call setup_idt和setup_gdt重新设置位于head的内存（位于0x90000）的idt、gdt。为何重复设置？
因为位于setup的内存会在将来设计缓冲区时被覆盖，而且也不能将setup中的idt和gdt直接copy到现在的位置（在执行setup的时候copy无意义，因为如果先执行setup后移动system会覆盖掉copy的idt、gdt；如果先移动system后执行setup则会覆盖掉head内容），于是我们不得不在head重新设置它们。
设置IDT 即便是setup里面的idt也都是空的，现在由head程序正式设置。
setup_idt: lea edx,ignore_int ;lea将ignore_int偏移地址(16bit)/而mov将第二操作数的内存内容 放入edx mov eax,00080000h ;将段选择子0x0008置入eax高16位 mov ax,dx ;将ignore_int偏移地址置入eax低16位 mov dx,8E00h ;interrupt gate - dpl=0, present lea edi,_idt ;lea将_idt所代表偏移地址放入edi mov ecx,256 ;cx用来计数，256次 rp_sidt: mov [edi],eax ;[]寄存器间接寻址,表示eax的内容赋予“以edi的内容作为地址指针的”内存。 mov [edi+4],edx add edi,8 dec ecx jne rp_sidt lidt fword ptr idt_descr ;fword ptr是48位指针，用于远程跳转 ret idt_descr: dw 256*8-1 ;db字节(1 byte)类型，dw字类型(2 byte)，dd双字类型(4 byte) dd _idt _idt: DQ 256 dup(0) ;伪操作，用来定义操作数占用的字节数 ignore_int作为默认中断处理程序函数地址，会放入中断描述符内。中段描述符结构如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42413da3585205e609417e91285692af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a85a0683e5ce387b4f6f5e4b012b9445/" rel="bookmark">
			【华为OD统一考试B卷 | 100分】数组拼接（C&#43;&#43; Java JavaScript Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为OD统一考试A卷+B卷 新题库说明 2023年5月份，华为官方已经将的 2022/0223Q(1/2/3/4)统一修改为OD统一考试（A卷）和OD统一考试（B卷）。 你收到的链接上面会标注A卷还是B卷。请注意：根据反馈，目前大部分收到的都是B卷。但是仍有概率抽到A卷。 A卷对应2023的新题库（2022Q4 20223Q1） B卷对应20022部分考题以及新出的题目
专栏：2023华为OD机试(A卷+B卷)（C++JavaJSPy） 专栏：2023华为OD机试(A卷)（C++ Java JS Py） 专栏：2023华为OD机试(B卷)（C++ Java JS Py）
题目描述 现在有多组整数数组，需要将它们合并成一个新的数组。
合并规则，从每个数组里按顺序取出固定长度的内容合并到新的数组中，取完的内容会删除掉，
如果该行不足固定长度或者已经为空，则直接取出剩余部分的内容放到新的数组中，继续下一行。
华为OD统一考试A卷+B卷 新题库说明 2023年5月份，华为官方已经将的 2022/0223Q(1/2/3/4)统一修改为OD统一考试（A卷）和OD统一考试（B卷）。 你收到的链接上面会标注A卷还是B卷。请注意：根据反馈，目前大部分收到的都是B卷。但是仍有概率抽到A卷。 A卷对应2023的新题库（2022Q4 20223Q1） B卷对应20022部分考题以及新出的题目
专栏：2023华为OD机试(A卷+B卷)（C++JavaJSPy） 专栏：2023华为OD机试(A卷)（C++ Java JS Py） 专栏：2023华为OD机试(B卷)（C++ Java JS Py）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d5c75339acb362c4f0ecc4dfbd495f9/" rel="bookmark">
			安装 TensorFlow GPU版（2023年）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装CUDA与cuDNN 1.1 确定所需的CUDA与cuDNN版本 查看所需的CUDA与cuDNN的版本网址（右上角语言那选English，中文的内容不全）Build from source on Windows | TensorFlow (google.cn)https://tensorflow.google.cn/install/source_windows
此处以安装TensorFlow2.10版为例（对于Windows，TensorFlow GPU版所支持的版本最高为2.10，CUDA需要安装11.2版本，cuDNN需要安装8.1版本。
1.2 安装CUDA 检查GPU支持CUDA的最高版本
nvidia-smi.exe 下载网址CUDA Toolkit Archive | NVIDIA Developerhttps://developer.nvidia.com/cuda-toolkit-archive
找到下图所示内容，点击进入下载页面。 依次点击windows，x86_64，10，exe（local）。
下载完后安装，一定要记住安装的路径。
注意下图为临时的缓存路径，并不是真正的安装路径。
检查cuda是否安装成功
nvcc -V 下图为cuda已经安装成功的例子。
1.3 安装cuDNN 下载网址
cuDNN Archive | NVIDIA Developerhttps://developer.nvidia.com/rdp/cudnn-archive找到下图所示内容，点击出现下拉菜单。 找到下图所示内容，点击下载。 下载完后解压缩，将所有文件复制到下图所示的文件夹。
如果安装时是默认路径，文件夹路径：C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.2
如不是：安装时指定的安装路径
2.安装TensorFlow 2.0版本以后，TensorFlow GPU版与CPU版已经合并，只需运行如下代码。
pip install "tensorflow&lt;2.11" 安装完成后，运行如下代码检查是否安装成功。
import tensorflow as tf print(tf.config.experimental.list_physical_devices(device_type="GPU")) 成功案例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b12187782349864fa8a60903fd337c4c/" rel="bookmark">
			unity脚部IK实时贴合地面，布娃娃系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
角色的导入
下面开始介绍这个插件的使用
GroundIK
AimIK
RagdollUtility布娃娃系统
角色的导入 为了方便我们对人物的控制，这边为了方便我们为其添加一个免费的第三人称控制器
将该控制器的脚本与动画状态机添加到我们的模型中
下面开始介绍这个组件的使用 添加Full BodyBipped Ik组件，这个组件会将模型的骨骼节点都添加上去，如果报红就需要调整骨骼节点的旋转，位置，直至正常。 FixTrransformS 该属性用于控制所有骨骼都收IK的影响，关闭该属性其余骨骼节点不会跟随选中的骨骼做IK运动
Referencces 用于绑定各部分的骨骼节点，可以手动调节
Spin与Eyes 手动添加其他部分的骨骼节点
RootNode 所有骨骼的父类
Weight 整体的权重设置
Iterations 当前骨骼节点对于其他骨骼节点影响的大小，如果调节成0，该节点不会影响其他节点
下面的几个属性分别是控制身体四肢节点的属性
GroundIK 该组件用于脚部实时贴合地面
Weight 控制整体的权重
Layers 射线检测的层，一般设置地面层
MaxStep 脚部能踩的最大高度，可以理解为阶梯的高度
HeightOffset 脚部距离地面的高度差当该属性值大于0时，脚部会跟地面有一段距离
FootSppeed 行走时脚部IK到达地面的速度，数值越大Ik的速度越快
FootRadius 脚部射线检测的半径，他会发射一条圆形射线检测范围
Prediction 判断前方碰撞体大小，主要是防止穿模，数值越大越不容易穿模
FootRotatiomWeight 脚部旋转的偏移
FootRotatiomSpeed 脚部旋转的速度
MaxFootRotatiomAngle 脚部旋转的最大偏移量（角度）
PelvisSpeed 盘骨上下移动的速度，人物向前移动时盘古一定也会移动
PelvisDamper 盘骨位移速度的一个缓冲值
RootSphereCCastRadius 根节点的射线检测距离
Quality 质量
Spine 可以设置其它节点的IK影响
Size 受影响节点的个数
EffectorType 设置受影响节点的部位
HorizontalWeight 水平影响力
VerticalWeight 垂直影响力
AimIK 该组件一般用于射击游戏的瞄准
Target 瞄准的目标
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b12187782349864fa8a60903fd337c4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb7fa711ff49471708d0e6fc6867e0b/" rel="bookmark">
			STM32---按键控制小灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32按键点灯的实现需要用到STM32的GPIO外设，不同开发板的LED外设不同，本文将采用野火STM32mini开发板来实现按键点灯。 1.首先，我们要想使用mini开发板按键控制小灯，就需要找到它的原理图，查找到板载的led和按键是用的哪一个引脚。
下图为led的板载引脚图，从图中我们可以知道mini板的两个led灯连接的是PC2、PC3引脚。且为低电平点亮、高电平熄灭
下图为mini板的按键引脚图，从图中我们也可以知道两个按键的引脚为PA0、PC13。且为高电平驱动，低电平阻断。
所以当我们在使用不同的STM32开发板时，led和按键的引脚以及驱动方式是不同的，这就需要我们必须使用相应开发板的原理图这里我把mini板的原理图奉上，希望能帮助到有缘人。
2.代码驱动
首先我们需要创建一个led的驱动文件以及按键的驱动文件。
key.c #include "stm32f10x.h" // Device header void delay(uint32_t ms)//毫秒延时 { uint32_t i, j; for (i = 0; i &lt; ms; i++) { for (j = 0; j &lt; 5000; j++) { __NOP(); // 空操作，不做任何事情，占用一个CPU周期 } } } void Key_Init(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOC, ENABLE);//开启GPIOA、GPIOC时钟 GPIO_InitTypeDef GPIO_InitStructure;//初始化GPIO引脚 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//输入上拉模式 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;// GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//时钟频率 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; GPIO_Init(GPIOC, &amp;GPIO_InitStructure);//初始化GPIOC } uint8_t Key_GetNum(void) { uint8_t KeyNum = 0; if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0) == 1) { delay(20); while (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0) == 1); delay(20); KeyNum = 1; } if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13) == 1) { delay(20); while (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13) == 1); delay(20); KeyNum = 2; } return KeyNum; } key.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bb7fa711ff49471708d0e6fc6867e0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d20b7df1d97e94b67057ec901e66e60/" rel="bookmark">
			k8s可视化管理工具Rancher安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s系列入门级教程—k8s可视化管理工具Rancher安装和使用 《超低成本的k8s集群搭建教程》
使用rke安装企业级k8s集群—待填坑
prometheus+grafana监控搭建教程—待填坑
kubectl命令大全—待填坑
k8s efk日志系统搭建教程—待填坑
k8s使用nfs持久化存储—待填坑
文章目录 k8s系列入门级教程---k8s可视化管理工具Rancher安装和使用前言一、部署准备1.部署方式1.1.单机版1.2.高可用版1.3.推荐方式 2.环境准备2.1.k8s集群2.2.域名和证书 二、安装步骤1.安装helm2.安装rancher3.访问rancher3.1.首页3.2.主机信息3.3.项目3.3.工作负载 三、结语 前言 作为一个新手，上手k8s时未免比较枯燥,要理解很多的k8s相关知识，并且要非常熟悉k8s命令，相信这是很多自学者被劝退的理由之一，当年我也是这个理由被劝退的，后来偶然的一次机会我接触了rancher，发现他可以通过可视化界面实现大部分k8s功能，从而帮助你快速上手k8s，没有任何其他学习方式比直接上手更快了。
一、部署准备 1.部署方式 你可以通过先安装单机版rancher，在使用rancher管理k8s集群，也可以选择先安装k8s集群，并将rancher高可用方式部署至k8s，二者区别如下。
1.1.单机版 通过docker安装；会自建一个k3s集群，用来运行rancher，你自己要用的k8s集群需要额外部署；部署简单，需要资源更多，最终会有两个k8s集群和一个rancher实例； 1.2.高可用版 通过helm安装；直接安装进已有的k8s集群，更适合生产级别使用；部署复杂，需要资源更少，最终会有1个k8s集群和自由配置的rancher实例数(可为1)； 1.3.推荐方式 推荐使用高可用形式安装，更接近真实的使用方式，而且经测试2c4g无法支撑两个k8s集群+1个rancher实例。
2.环境准备 2.1.k8s集群 首先要准备个k8s集群，安装方式在上文有介绍。
《超低成本的k8s集群搭建教程》
2.2.域名和证书 k8s的负载均衡以域名的形式向外部提供http(s)服务，为了以后的学习方便建议拥有一个自己的域名，rancher仅支持https，所以需要申请一个免费的ssl证书，当然也可以使用自定义域名，自行配置hosts，并使用自签名证书。
在下一步之前需要备好自己的域名如k8s.xxxx.io和ssl证书k8s_xxxx_io.key/k8s_xxxx_io.crt。
阿里云域名
腾讯云域名
二、安装步骤 1.安装helm Helm是Kubernetes的包管理器，类似于Python的pip centos的yum，主要用来管理 Charts Helm Chart是用来封装Kubernetes原生应用程序的一系列YAML文件。
helm直接使用二进制文件，在helm官方找到适合自己的版本放入usr/local/bin下即可。
如果下载过慢，我这里有之前使用的helm-v3.7.1-linux-amd64可供下载。
chmod 777 helm mv helm /usr/local/bin/ 2.安装rancher 请将命令中的&lt;CHART_REPO&gt;，替换为latest，stable，alpha或版本号。更多信息，请查看官方文档选择 Rancher 版本来选择最适合你的仓库。
latest: 建议在尝试新功能时使用。
stable: 建议在生产环境中使用。（推荐）
alpha: 未来版本的实验性预览。
#选择适合你的版本安装仓库 helm repo add rancher-&lt;CHART_REPO&gt; http://rancher-mirror.oss-cn-beijing.aliyuncs.com/server-charts/&lt;CHART_REPO&gt; #创建k8s命名空间cattle-system kubectl create namespace cattle-system #使用ssl证书创建密文至cattle-system命名空间 kubectl -n cattle-system create secret tls tls-rancher-ingress \ --cert=k8s_xxxx_io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d20b7df1d97e94b67057ec901e66e60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/984e1319a40f227122cdc9b815f7ee20/" rel="bookmark">
			Spring Cloud 实战系列：服务网关 Spring Cloud Gateway
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈 服务网关 Spring Cloud Gateway 🐙 为什么需要服务网关 微服务架构的系统，拥有众多子服务，如果客户端直接与各个微服务进行通信，会有以下的问题：
客户端需要记录各个服务的地址各个服务都需要单独处理跨域各个服务都需要单独权限认证。。。 🐙 什么是服务网关 服务网关是介于客户端和服务端之间的中间层，所有的外部请求都会先经过网关这一层。由网关决定将请求路由到具体服务。
可以处理非业务的的逻辑，如安全、监控、限流、熔断、授权等等。
🐙 什么是 Spring cloud Gateway 一个构建在 Spring 生态系统之上的 API 网关，包括：Spring 6、Spring Boot 3、Spring Webflux 和 Project Reactor。Spring Cloud Gateway 旨在提供一种简单而有效的方法来路由到 API，并为它们提供横切关注点，例如：安全性、监控/指标和弹性。
🍅 1、术语
Route：Gateway 的基本构建块。它由 ID、目标 URI、谓词集合和过滤器集合定义。如果聚合谓词为真，则路由匹配。
Predicate：是一个Java 8 函数谓词。输入类型是Spring FrameworkServerWebExchange。可以匹配 HTTP 请求中的任何内容，例如请求头或参数。
Filter：是GatewayFilter使用特定工厂构建的实例。可以在发送下游请求之前或之后修改请求和响应。
🍅 2、工作原理
官网提供了 Spring Cloud Gateway 工作原理的高级概述图：
客户端向 Spring Cloud Gateway 发出请求。如果 Gateway Handler Mapping 确定请求与路由匹配，则将其发送到 Gateway Web Handler。此处理程序通过特定于请求的过滤器链运行请求。过滤器被虚线分开的原因是过滤器可以在发送代理请求之前和之后运行逻辑。执行所有 “pre” 过滤器逻辑。然后进行代理请求。发出代理请求后，运行 “post” 过滤器逻辑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/984e1319a40f227122cdc9b815f7ee20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3904717f24553589e651a52dfe1fea51/" rel="bookmark">
			Spring Cloud 实战系列：服务注册与发现 Alibaba Nacos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈 服务注册与发现 Alibaba Nacos 版本定义
&lt;spring.boot.version&gt;2.6.13&lt;/spring.boot.version&gt; &lt;spring.cloud.version&gt;2021.0.5&lt;/spring.cloud.version&gt; &lt;spring.cloud-alibaba.version&gt;2021.0.5.0&lt;/spring.cloud-alibaba.version&gt; 官方资料
https://nacos.io
🌈 服务注册与发现 🐯 什么是 Alibaba Nacos Nacos 是一个 Alibaba 开源的、易于构建云原生应用的动态服务发现、配置管理和服务管理平台。
使用 Spring Cloud Alibaba Nacos Discovery，可基于 Spring Cloud 的编程模型快速接入 Nacos 服务注册功能。
🐯 为什么需要 Alibaba Nacos 服务发现是微服务架构体系中最关键的组件之一。如果尝试着用手动的方式来给每一个客户端来配置所有服务提供者的服务列表是一件非常困难的事，而且也不利于 服务的动态扩缩容。Nacos Discovery 可以帮助您将服务自动注册到 Nacos 服务端并且能够动态感知和刷新某个服务实例的服务列表。
🌈 Nacos 服务注册 在提供者微服务引入 Nacos，将服务信息注册到 Nacos Server。
🐯 引入 Alibaba Nacos 添加依赖
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; 🐯 配置 Alibaba Nacos 添加 Nacos 基本的配置
spring: application: name: spring-cloud-alibaba-nacos-demo cloud: nacos: discovery: server-addr: localhost:8848 # Nacos 服务端地址 management: endpoints: web: exposure: include: '*' 启动类添加注解，开启服务注册/发现功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3904717f24553589e651a52dfe1fea51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f18b745b4b67e0833014a7c07a0b64/" rel="bookmark">
			基于TCP、UDP网络编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 网络协议分层套接字UDP和TCP差异UDP的APIDatagramSocketDatagramPacket 基于UDP Socket 实现一个回显程序TCP的APISocket的API基于TCP实现回显程序 网络协议分层 应用层： 应用程序拿到数据怎么用传输层： 负责关注传输过程中起点和终点网络层 ：负责整个传输过程中的路线规划数据链路层 ：负责相邻节点之间的数据传输物理层： 基础设施，硬件设备 套接字 程序员写网络程序，主要编写的应用层代码，真正要发这个数据，调用下层协议，应用层要调用传输层，传输层给应用层提供一组api称为Socket。
系统主要提供socket的API有两种，基于UDP的api和基于TCP的API。
UDP和TCP差异 UDPTCP无连接有连接不可靠传输可靠传输面向数据报面向字节流全双工全双工 有连接：通信双方各自记录对方的信息
可靠传输：不是100%能够传输成功，而是当我传输失败我能够知道。
面向数据报：以一个UDP数据报为基本单位
面向字节流：以字节为单位进行传输，读写灵活
全双工：一条路径双向通信
UDP的API DatagramSocket Datagram：“数据报”
Socket：说明此对象是一个socket对象。
socket对象：相当于对应到系统的一个特殊文件（socket文件），socket文件并非是对应到硬盘的某个区域，而是对应到网卡，所以，要想进行网络通信必须要有socket文件这样的对象，借助这个对象，才能间接操控网卡。往socket对象写数据，相当于通过网卡发送消息，从这个socket对象读数据，相当于通过网卡接受消息。
DatagramPacket DatagramPacket：这个对象就是一个UDP数据报
基于UDP Socket 实现一个回显程序 读取请求并解析根据请求计算响应把响应返回到客户端 package demo; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class demo5 { //通过网络通信，必须要使用socket对象 private DatagramSocket socket=null; public demo5(int port) throws SocketException { //构造的同时绑定端口号，绑定端口不一定成功，可能某个端口被占用 //同一个主机上，一个端口同一时刻，只能被一个进程绑定。 socket=new DatagramSocket(port); } public void start() throws IOException { System.out.println("服务器启动"); while(true){ DatagramPacket packet=new DatagramPacket(new byte[4096],4096); socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94f18b745b4b67e0833014a7c07a0b64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dde9ca6219d5740b9d854651689da93/" rel="bookmark">
			AI人工智能再次进化，星云虚境AI会独立思考究竟是福是祸？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近爆火的可以独立思考的GBT已经把之前的扎的BT给淘汰了，就像VR史密斯主演的我机器人有思想的AI比什么都恐怖。之前GBT4.0虽然强大，但也都建立在人工的基础上，你的指令越模糊，他给你的回答越敷衍。然而chatGpt会自我迭代，自己思考，就算你的指令再模糊，他也会围绕你的问题进行全方面的回答。你只问了他，我是一名跨境卖家，我的产品是假发，我想把它卖到北美市场，你有什么建议？他首先告诉我，北美假发市场预计在2020年至二五年期间将以5.5%的复合年增长率增长，之后围绕市场需求制定营销策略，识别遵守当地市场跨境销售相关法律法规给出了回答。如果看到这里，你认为以上gpt4.0也能完成，那你就错了接着看auToGpt又能进行思考，给出产品定价建议，组建调查小组，收集北美客户对首选假发款式以及颜色的反馈，且指出如何推广并提高品牌的知名度。说到这里，你不要以为他只会提问，他的恐怖在于他会自问自答，例如他给自己提问，给出与北美。美容和时尚影响者建立合作关系的策略。接着给我列出十几名本地网红，因此YouTube等渠道都有，还附上了账号名称、粉丝数以及选他们的原因，并且我跟人家怎么谈合作都给我写好了，给他们免费提供样品、谈分佣，或者给他们的账号软广植入等。除了网红推广，又给我列出了五个北美优质的零售商、分销商，使我的产品除了在亚马逊、TikTok、独立站、eBay等电商平台以外的线下渠道也可以进行销售。最后还给出了此策略的预算，并制定了一份时间表十几分钟。围绕我的问题，AuToGt已经给自己提了32次，并做出了回答
再看另外一个升级版chatgpt一个十秒之内就能看到百款设计方案，它可以让设计的效率是几万倍的提升，成本是几百倍的降低。星云虚境呢，是以AI设计为核心竞争力的新型的创新公司，主要为客户提供的，是企业的形象设计，包装设计以及商品设计的服务，比如你在星云虚境说猎豹汉堡，可以搞一个汉堡，然后点下一步，然后选择餐饮，点智能生成，默数十秒钟，不会吧，又来了，好像没有十秒，大家会看到各种丰盛的猎豹汉堡，还有各种风格的，然后您还可以再点最下面那个，可以换一批换一批，然后顶部呢，为了可商用授权类型，然后还有可买断，像可买断，就是刚才所讲的用户买完之后系统会下架，会发出来权证给，就是就是这个权力独占是吧？对权力独占，那您这儿完成一次设计怎么算？logo是79块钱起，然后包装设计是99块钱起，智能logo设计主要是针对于餐饮、食品、服饰以及互联网这些行业，再给大家介绍一下星云虚境系统的包装设计的体验。包装设计主要针对的是产业带的厂牌，包括新兴的农户品牌，如果今天在星云虚境的平台上怎么做呢？随便输入一个网红产品，他可以在里边选择他最喜欢的方案，他可以只购买设计作品，他也可以购买设计，加上这个包装的打样，小批量的生产，三天他就可以收到他定制化的设计的这一批货。智能商品设计呢，主要是基于消费者数据驱动，基于IP驱动去做个性化的方案和商品，而在这一切的背后，在这些智能logo、智能包装、智能商品的背后，核心的其实是一个叫做chagpt升级的星云虚境AI设计引擎，能够更好地去理解客户的需求，能够更好地去做设计创意的。联想同时能够让我们为小微用户提供快对每省的设计。以前小微是怎么做设计的呢？
我是老猫，然后我像开个面馆叫老猫面馆，我想做个设计，预算几百块钱，1000块钱吧，基本上没什么设计师愿意理我，好容易有一个设计师愿意理我，好先交500块钱押金，你做什么？我想要一个高大上的，好回去等着，一周之后呢，我拿到了设计师给我做的三个面馆的logo，一看，哎呀，这个不对啊，这三个好像不够高大上，但是也来不及了，我要参加这个外卖平台双11的活动，我线下的这个门头也得赶紧装上。算了，就这样吧，稀里糊涂就只能先这样了。这是小微过去在做设计的整个的体验，它充满了整个设计流程的不透明，价格很高，周期非常的长。设计的方案非常不可控，所以星云虚境才下定决心，一定要把过去服务五百强的经验完完全全结构开，用算法去降低设计的成本，然后把设计这件事情真正做到普惠，能够赋能给更多的小微商家。过去我们一个设计方案需要七到15天，而今天AI设计只需要十秒钟。过去一个设计师可以为一个需求做两到三款方案，而今天AI设计在这十秒钟内可以生成百款方案。过去设计需要预付款，而今天的AI设计你先看到方案，你满意你再付款，这是我们认为这个时代对于我们最大的变革，现在展现在各位面前的应该是这一年当中累计的极少量的作品，是的，这是茶，这个茶从外到内都是定制的，就是这个大家能看到的手提袋，然后还有这一条的茶，它的盒子，然后包括它里边的软包，那我们可以去做企业定制，每一件都不一样，一件定制的意思是说一提起订，我不是从你这儿只拿设计方案是吧，你还能帮我生产是吧？是的是的，你可以直接订到货，所以你是有你自己的工厂，还是说你有你的供应商，我们是有柔性供应链的合作伙伴，大家分别擅长的不一样，有的可能是擅长软装，有的擅长礼盒，有的擅长做柴。所以我们是在每一个类目下。都有强势的柔心供应链的合作伙伴，星云虚境跟他们去进行联通，这个太狠了，这个也是我们合作伙伴所提供的这个能力。
我比较感兴趣的是说客户是只跟电脑发生关系吗？客户首先是跟电脑在发生关系，那在我们的客户觉得说这个方案我还希望调整一下，我希望跟设计师做更深入的沟通，那我们也可以唤起人类设计师，这里面会不会牵扯到会有版权的问题，会因为我们做ToB的设计，做商业设计这么多年，我们对于版权可商用非常非常的在意，当的用户下单之后，平台会下架，不会让其他的商家买到相同的，同时会发区块链存证给到他，包括我的版权授权使用证书给到他，一旦他被侵权，其他用户可能这个截屏了，然后去使用了，他可以链上一键取证。那这是一个知识产权的闭环，我去设计一个智能汽车，如果C级车，它的用户可能只有几万，而我去做智能设计，我的用户我到现在一年多的时间已经是几百万了，一年多你已经服务了几百万，对，我觉得这个价值是完全不同的。其实一方面这里边有很大的群体是增量，以前设计师是不理他们的，因为他们也说不清楚自己想要什么样的设计，他们也没有足够的设计预算，是被设计师、被设计行业所遗弃的那样的一帮客户，但我觉得他们是有价值的，因为他们会发展到很大。说的意思就是说这个是最层的服务，对，那其实我们是在一定程度上替代掉了美工以及初级设计师的一些任务，然后我们希望我们能够推动整个设计行业的从业人群，一起往上走，能把自己发展到更高端，更有能力。你会对未来的行业造成巨大的威胁吗？小编觉得不会，因为星云虚境希望是能够提供的是普惠设计，没有想要跟任何人为敌或者干掉任何人。在这个过程当中，客观地来讲，星云虚境会觉得在这个行业里边的低端工种会被AI替代掉，而高端的工种会跟机器进行很好的人机协同，星云虚境会共同创作更好的设计作品。在咱们自己的土壤上也有去把这个设计，然后还有这个技术去服务到啊这么多的一些中小的一个企业，确实是一种颠覆式的创新，而且更让我惊讶的就是说，不仅是提供了这个设计这样的一个环节，包括后面的这个柔性供应链，这个也是未来非常关注的一个方向，现在想问一下，你们是一个做设计的公司，那做供应链管理是不是你们的强项？过去的十几年当中，我们通过设计加上研发加上供应链做出的产品很多，比如大家知道的55度杯。所以供应链对于来说并不陌生，这里边非常重要的一点是智能设计跟柔性供应链能不能直通。所以在柔性供应链上面，会认为非常非常重要的，就是把柔性供应链的尺寸、材质、参数全部都前置。在设计环节，会在每一个类目连接最好的柔性供应链的合作伙伴，如果你们能做到的话，我都想有创业的冲动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e738f8a35fb0d01532a456c237c8703/" rel="bookmark">
			【Multisim14.0】彻底卸载删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
安装失败案例
卸载步骤
重新安装
之前培训时，老师要求提前安装好这款仿真软件，但是我一直安装不上……
卸载重新了好多遍，还是同一个问题！（顺便吐槽一下，这个po软件，真难用~谁爱用谁用吧）
在删除相关文件时，发现这个软件已经和系统建立好动态链接（也就是.dll文件删除不了），从而整个软件删除不干净。
安装失败案例 卸载步骤 搜了好多文章，找到了一个它的卸载软件
通过百度网盘分享的文件：Multisim…
链接:https://pan.baidu.com/s/1anudENqMEUgRsAQO9CzSdw?pwd=lbdl 提取码:lbdl
复制这段内容打开「百度网盘APP 即可获取」
这个是软件安装包 和 卸载软件的应用
双击打开uninst.exe
删除你的multisim版本（第一项）
卸载之后再安装
如果还是安装失败，就把这些文件都删除，重新安装~_~
重新安装 点击下面链接即可跳转到安装教程！
【Multisim 14.0】软件安装教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ddbdd742be45afc1f72d93ab5cfb147/" rel="bookmark">
			【亲测有效】idea部署jrebel插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea部署jrebel插件 1.背景 最近在维护tomcat项目，工程修改代码后需要rebuild才能更新class文件，进而运行生效。
同事介绍jrebel可以实现热部署，于是接入使用。
2.简介 JRebel是一套JavaEE开发工具。
Jrebel 可快速实现热部署，节省了大量重启时间，提高了个人开发效率。
JRebel是一款JAVA虚拟机插件，它使得JAVA程序员能在不进行重部署的情况下，即时看到代码的改变对一个应用程序带来的影响。JRebel使你能即时分别看到代码、类和资源的变化，你可以一个个地上传而不是一次性全部部署。当程序员在开发环境中对任何一个类或者资源作出修改的时候，这个变化会直接反应在部署好的应用程序上，从而跳过了构建和部署的过程，可以省去大量的部署用的时间。
JRebel是一款JVM插件，它使得Java代码修改后不用重启系统，立即生效。
IDEA上原生是不支持热部署的，一般更新了 Java 文件后要手动重启 Tomcat 服务器，才能生效，浪费时间浪费生命。
目前对于idea热部署最好的解决方案就是安装JRebel插件。
————————————————
版权声明：本文为CSDN博主「梁云亮」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/lianghecai52171314/article/details/105637251
3.安装步骤 3.1下载jrebel插件 因为idea商店搜索的jrebel插件是2023版的，网上提示jrebel是最新版的2022.4.2更换了激活方式，所以没有继续研究，直接到官网下载2021版插件。附下载链接🔗
3.2安装插件 下载后，打开idea，然后将压缩文件拖入idea，重新启动idea
打开setting-&gt;Plugins搜索jrebel，如果看见版本号则说明安装成功（记得将圈着的勾勾上！！！）
3.3破解jrebel 参考wiki：
JRebel 破解最简单的使用
https://jrebel.qekang.com/
启动项目后控制台输出如下内容即为jrebel破解成功
4.热部署设置 4.1设置成离线工作模式 设置离线模式后可以避免使用期间https://jrebel.qekang.com服务挂了导致激活失效
离线180天后再次激活一次即可，
4.2设置自动编译 要想实现热部署，首先需要对Intellij按如下进行设置：
setting-&gt;Build-&gt;Compiler
由于JRebel是实时监控class文件的变化来实现热部署的，所以在idea环境下需要打开自动变异功能才能实现随时修改，随时生效。
4.3 设置运行时编译 idea快捷键 Ctrl+Shift+Alt+/ ，选择 Registry
4.4 配置选中生效的工程 破解jrebel后运行并不一定能让热部署生效，那是因为没有配置好生成rebel.xml文件，导致插件没办法检测项目的class文件。
在View &gt; Tool Windows &gt; JRebel 中打开JRebel的视图，勾选上需要启动热部署的项目，具体效果如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1709499970726ea3821c7cc430dbe518/" rel="bookmark">
			第十四届蓝桥杯青少组省赛Python真题（2023年5月14日）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、选择题
第一题
第二题
第三题
第四题
第五题
二、编程题 第一题
第二题
第三题
第四题
第五题 第六题（仅中、高级组）
一、选择题 第一题 第二题 第三题 第四题 第五题 二、编程题 第一题 题目描述：(注.input()输入函数的括号中不允许添加任何信息)
编程实现：
给定一个正整数N，计算出N+N的值。
例如：N = 4，4+4的值为8（8=4+4）。
输入描述
输入一个正整数N
输出描述
输出N+N的值
样例输入
3
样例输出
6
第二题 题目描述：(注.input()输入函数的括号中不允许添加任何信息)
编程实现：
给定一个只包含小写字母的字符串S（S长度≥3），请输出字符串S的第一个字符和最后一个字符。
例如：
当S =“abc”，abc的第一个字符为a，最后一个字符为c，故输出ac。
输入描述
输入一个只包含小写字母的字符串S（S长度≥3）
输出描述
输出字符串S的第一个字符和最后一个字符，两个字符之间没有空格及其他字符
样例输入
abc
样例输出
ac
第三题 题目描述：(注.input()输入函数的括号中不允许添加任何信息)
提示信息：
合数：合数指自然数中除了能被1和本身整除外，还能被其它正整数整除的数。
例如4，4除了能被1和4整除，还可以被2整除。
编程实现：
小明收藏了N（2≤N≤25）个数字币，每个数字币上都有一个面值（面值可以重复）。从数字币中任选K（2≤K≤N）个，有多种选法，请将每次选择的数字币上的面值累加，然后解决以下两个问题。
问题1：累加的和中有多少种不同的结果；
问题2：累加的和中有多少个不同的合数。
例如：N=5，K=3，5个数字币上的面值分别为2、1、4、5、3，任选3个数字币，有10种选法，将每种选法上的面值累加：
2+1+4=7、2+1+5=8、2+1+3=6、2+4+5=11、2+4+3=9、2+5+3=10、1+4+5=10、1+4+3=8、1+5+3=9、4+5+3=12。
其中累加的和中有7种不同的结果，分别是7、8、6、11、9、10、12，
累加的和中有5个不同的合数，分别是8、6、9、10、12。
输入描述
第一行输入一个正整数N（2≤N≤25），表示数字币的个数
第二行输入N个正整数（1≤正整数≤1000），表示数字币上的面值，正整数之间以一个英文逗号隔开
第三行输入一个正整数K（2≤K≤N），表示所要选取的数字币个数
输出描述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1709499970726ea3821c7cc430dbe518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff624fc0134403ebc25e673214df87f7/" rel="bookmark">
			记录一些log4j2相关内容，以及删除策略不生效原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下面是一段log4j2日志配置：
&lt;RollingFile name="logger" fileName="${path}/filename.log" filePattern="${path}/%d{yyyyMMdd}/filename.%i.log"&gt; &lt;Filters&gt; &lt;MarkerFilter marker="" onmatch="NEUTRAL" onMismatch="DENY"/&gt; &lt;LogMdcFilter useSwitch="true" onmatch="NEUTRAL" onMismatch="DENY"/&gt; &lt;ThresholdFilter level="info" onmatch="ACCEPT" onMismatch="DENY"/&gt; &lt;/Filters&gt; &lt;PatternLayout pattern="${COMMON_PATTERN}"/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval="1" modulte="true"/&gt; &lt;SizeBasedTriggeringPolicy size = "300MB" /&gt; &lt;Policies&gt; &lt;DefaultRolloverStrategy max="7"&gt; &lt;Delete basePate="${path}" maxDepth="2"&gt; &lt;IfFileName glob="*/filename*.log"/&gt; &lt;IfLastModified age="5d"/&gt; &lt;/Delete&gt; &lt;/DefaultRolloverStrategy&gt; &lt;/RollingFile&gt; 其中配置了滚动策略，比如配置了删除5天前的日志，单个日志文件最大300MB。具体每个参数意义…不想写，等哪天勤快了再更新。
先记录一下需要注意的点：
不是项目重启就会清理过期日志文件。当只有上边的滚动策略触发时，才会进行删除不符合策略的日志文件，拿这个配置举例，比如触发时间滚动策略时，也就是在一天后有日志产生时，前一天的日志要存入新的文件夹，这时会删除5天前的过期日志文件。当maxDepth设置的深度是2时，需要注意下边删除规则glob中日志名字前需要加*/，表示外一层目录，不加的话日志滚动时不会删除过期日志文件，相反，如果深度是1，删除当前目录时是不需要加的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bf8c5671d73af6c95ac72f8a6416b98/" rel="bookmark">
			VMD分解及其matlab实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简介 VMD是一种信号分解方法，由韩庆祥等人在2014年提出。VMD方法可以将一个信号分解成一系列具有不同中心频率和带宽的本征模态函数（Intrinsic Mode Functions，IMF），每一个IMF都是代表了信号的某个频带的振动模式。
VMD方法应用广泛，例如在信号处理、图像处理、声音处理、生物医学信号处理等方面都有很好的效果。
本文将介绍VMD分解的原理、流程和Matlab实现方法。
2. VMD分解原理 VMD方法主要通过将信号分解成具有不同振动模式的IMF来实现。在VMD方法中，每一个IMF都是具有固定中心频率和带宽的振动模式，并且可以通过固定的带宽进行分辨率的调整。VMD方法的分解过程可以概括为以下几个步骤：
首先，将信号嵌入到经典的一阶的Hilbert变换（H1）中，得到一系列包络函数。然后，通过优化一定的分离约束条件，将信号分解成若干个IMF，并计算出相应的包络函数和相位函数。最后，将所有IMF加和重构成原始信号。 VMD方法的优点在于可以自适应地适用于不同的复杂信号，并且可以提高信号的分辨率和保证分解的可靠性和准确性。
3. Matlab实现 Matlab提供了vmd函数来实现VMD方法。使用vmd函数，可以将一个一维或二维的数据进行分解。vmd函数的主要输入和输出参数如下：
3.1 输入参数描述
x: 代表需要分解的一维或二维数据;vmd_h: VMD算法中的一个参数，VMD函数中默认为0.05;vmd_tol: VMD算法中的另一个参数，VMD函数中默认为1e-7;fs: 信号采样频率;freq_begin: IMFs分解开始的中心频率;freq_end: IMFs分解结束的中心频率; 3.2 输出参数描述
u: 分解后的信号IMFs矩阵；f: 每个IMF的对应带宽。 3.3 代码示例
以下是一个简单的Matlab代码示例，展示了如何实现VMD方法：
% 定义需要分解的信号
fs = 2000; % 采样频率
t = 0:1/fs:1-1/fs;
x = sin(2pi50t) + sin(2pi100t) + sin(2pi200*t);
% 进行VMD分解
[u, f] = vmd(x, fs, ‘FreqRange’,[1, 500], ‘MaxMode’, 3);
% 画出分解后的IMFs
figure;
subplot(4,1,1);
plot(x);
title(‘Original Signal’);
for i=1:size(u, 1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bf8c5671d73af6c95ac72f8a6416b98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecdc5d59be73f4d22cc939bfc17f6130/" rel="bookmark">
			Java的Atomic原子类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java SDK 并发包里提供了丰富的原子类，我们可以将其分为五个类别，这五个类别提供的方法基本上是相似的，并且每个类别都有若干原子类。
对基本数据类型的变量值进行原子更新；对对象变量的指向进行原子更新；对数组里面的的元素进行原子更新；原子化的对象属性更新器；原子化的累加器。 基本数据类型 AtomicBoolean、AtomicLong、AtomicInteger 这三个类提供了一些对基本数据类型的变量值进行原子更新的方法。
这些类提供的方法是相似的，主要有（以 AtomicLong 为例）：
// 原子化的 i++ long getAndIncrement() // 原子化的 i-- long getAndDecrement() // 原子化的 ++i long incrementAndGet() // 原子化的 --i long decrementAndGet() // 原子化的 i+=delta，返回值为+=前的i值 long getAndAdd(long delta) // 原子化的 i+=delta，返回值为+=后的i值 long addAndGet(delta) // CAS操作。如果写回成功返回true，否则返回false boolean compareAndSet(long expect, long update) // 以下四个方法新值可以通过传入函数式接口(func函数)来计算 long getAndUpdate(LongUnaryOperator updateFunction) long updateAndGet(LongUnaryOperator updateFunction) long getAndAccumulate(long x, LongBinaryOperator accumulatorFunction) long accumulateAndGet(long x, LongBinaryOperator accumulatorFunction) // 演示 getAndUpdate() 方法的使用 public static void main(String[] args) { AtomicLong atomicLong = new AtomicLong(0); long result = atomicLong.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecdc5d59be73f4d22cc939bfc17f6130/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c3559aa6fc2855e08a0016861bab00d/" rel="bookmark">
			图片怎么转换成pdf文件，多方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片怎么转换成PDF文件呢？将多张图片合并为一个PDF文件方便了用户的管理和传输。通过将多张图片转换为一个PDF文件，我们可以更方便地对图像文件进行分类、归档和共享，也可以避免出现多个单独的图像文件难以管理的问题。同时，PDF格式还支持搜索功能，可以方便地进行文本检索，便于用户查找需要的内容。通过图片转换为PDF还可以保证图像的高质量和完整性。图片转换为PDF后，文件会被压缩成一个单一的文件，而不会因为单独存储多个图片文件而丢失或损坏其中的一部分。此外，PDF格式还支持矢量图形格式，可以保证图像质量的同时减少文件大小。PDF格式支持在文档中添加密码、数字签名等安全保护措施，保护文件的安全性和可信度。
综上所述，将图片转换为PDF格式是一项重要的技术操作。通过转换，可以更方便地管理和共享图像文件，同时保证图像质量和文件完整性。此外，PDF格式还提供了安全保护功能，保证文件的机密性和可信度。那么，大家快学习起来如何将图片转换成PDF文件吧！
方法一：借助的PDF工具：优速PDF工厂
步骤1、首先我们需要下载电脑端所使用的软件工具“优速PDF转换器”，这个软件可以很轻松地帮我们将图片转换成PDF。所以大家下载安装完成软件后，打开软件，直接选择首页面中的【文件转PDF】功能。
步骤2、接着点击【文件转PDF】下拉功能中的【图片转PDF】功能，通过点击【添加文件】按钮，上传需要进行转换的图片文件。
步骤3、PDF文件上传到软件中后，我们可以设置是否将图片合成一个PDF，如图所示，选择“是”软件将会把所有图片转换成在一个PDF文件中；选择否则表示所有图片会被单独转换成pdf文件。
步骤4、设置完成后，点击【开始转换】按钮，如此软件就开始按照我们的设置把图片转PDF处理了，当处理完成后，系统会自动弹出打开输出文件夹，那么在这里保存着已转换好的PDF文件。
步骤5、如下图所示，从结果我们不难看出，软件成功帮助我们将所有图片单独转成了pdf。
方法二：使用zemzer将图片转PDF
如果您需要将一张图片转换成PDF格式，可以使用zemzer在线文件转换工具来实现。该工具支持转换的文件格式种类繁多，操作简单易行。下面是具体的转换步骤：
步骤1：搜索工具名称直接打开工具网站，在网站上可以进行将图片转PDF操作。首先，点击左侧的“Choose Files”按钮，将需要转换的图片上传到工具中。
步骤2：上传完毕后，点击中间的下拉框，选择要转换的格式，我们本次案例是将其设置为PDF格式。这样才能将图片转PDF。
步骤3：最后，点击右侧的绿色按钮，工具开始在线将图片转PDF程序。等待转换完成后，工具会自动将转换成的PDF文件显示在页面上，您可以直接下载保存使用。
通过以上步骤，我们可以快速方便地使用zemzer在线文件转换工具将图片转换成PDF格式，适用于日常办公和学习等各种场合。
方法三：使用讯速图片大师进行转换
使用讯速图片大师软件工具将一张图片转换为PDF格式，操作也十分简单明了。下面是具体的转换步骤：
步骤1：打开电脑，打开我们已经安装好的“讯速图片大师”软件工具，我们在首页恨到很多功能。点击“特殊转换”下方的“通用格式转换”功能，接着点击“添加图片”按钮，将需要转换的图片上传到软件中。
步骤2：在界面中找到“输出格式”下拉框，将其设置为PDF格式。然后，在输出目录中设置要保存转换后的PDF文件的路径。
步骤3：上述操作完毕之后，点击右下角的“开始转换”按钮，工具开始把图片转PDF。等待一小会，会弹出提示框，在提示框上点击蓝色按钮即可查看转换成的PDF文件。
方法四：使用云朵办公软件图片转PDF
步骤1：首先，在电脑上安装并打开云朵办公软件，选择“PDF处理”功能，然后在左侧子功能栏中点击“图片转PDF”。
步骤2：在接下来的操作界面中，我们通过点击“添加文件”按钮，将需要转换的图片上传到软件中。我们看到上传的速度也是很快的。
​
步骤3：接着，调整图片的前后顺序，选择是否合并图片转换为一个PDF文件。最后，点击右下角的“开始处理”按钮，启动转换程序。等待转换结束后，我们就能在指定地方看到图片转成的PDF文件。
在我们日常生活和工作中，常常需要使用大量的图片文件，但随着图片数量的增多，文件管理变得越来越麻烦。此时，将多张图片合并成一个PDF文件就变得尤为重要。通过图片转换为PDF，不仅可以更方便地对图像文件进行分类、归档和共享，避免了单独存储多个图片文件的繁琐，同时也能保证图片质量和文件完整性。因此，我们可以借助优速PDF工厂将图片进行转换，从而保证文件的利用率。上面小编分享了几个“图片怎么转换成pdf文件”的解决办法，这几个办法都非常的实用，有需要的小伙伴都可以一一去尝试的，正所悟不做不知道。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6edd482d488567c5374dde8d7a29a80/" rel="bookmark">
			Jquery复制DIV中的内容到粘贴板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML代码：
&lt;div id="myDiv"&gt; 这是要复制的内容 &lt;/div&gt; &lt;button id="copyButton"&gt;复制&lt;/button&gt; jQuery代码：
$(document).ready(function() { $('#copyButton').click(function() { var content = $('#myDiv').html(); var tempElement = $('&lt;textarea&gt;').val(content).appendTo('body').select(); document.execCommand('copy'); tempElement.remove(); alert('内容已复制到粘贴板！'); }); }); 实现的效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d465c14d6cecf34faf716409f73e65/" rel="bookmark">
			springboot集成xxjob
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天做项目发现统计有很多定时任务需要处理，而项目中都是采用注解得方式去做导致就很分散，不是很好得去做统一管理，找起来也比较麻烦。所以就想着集成一下xxjob 做统一管理
1.什么是xxjob
xxjob是一款分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用
它支持通过Web页面对任务进行CRUD操作，操作简单
支持动态得修改任务状态，参数，即时生效
任务执行器支持集群部署
支持故障转移和动态扩容等等，，，，
1.下载源码 源码仓库地址:
https://github.com/xuxueli/xxl-job
http://gitee.com/xuxueli0323/xxl-job
下载下来后解压用ideal 打开
mysql 执行table_xxl_job.sql脚本 这里面得一些表主要就是一些存储账户，任务日志，任务之类得
主要是启动xx-job-admin这个服务
先修改一些配置
比如数据库配置
或者端口都可以还有一些别的配置你有得话就改了玩玩
最后启动
效果图：
默认账户：admin 密码：123456
2.创建一个springboot项目
引入核心依赖 这里之所以没写版本号是因为我在父类已经统一设置好了版本
&lt;!-- xxl-job-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;/dependency&gt; 然后写个demo
3.创建配置文件：application.properties
# web port server.port=8081 # no web #spring.main.web-environment=false # log config logging.config=classpath:logback.xml ### xxl-job admin address list, such as "http://address" or "http://address01,http://address02" xxl.job.admin.addresses=http://192.168.10.111:8089/xxl-job-admin ### xxl-job, access token xxl.job.accessToken=default_token ### xxl-job executor appname xxl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57d465c14d6cecf34faf716409f73e65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f39191dcb3626b7cf38fa1503ba239c9/" rel="bookmark">
			【数据结构】C语言必备知识学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 结构体类型
结构体是一种用户自定义类型，一般由基本数据类型复合而成，如学生的定义可以包括：学号、性别、英语成绩和数学成绩。下例定义并输出小明同学的性别和数学成绩。
#include&lt;stdio.h&gt;
int main() {
struct student
{
int stdID;
char gender;
int English;
int Math;
};
struct student Xiaoming; // 声明结构体变量Xiaoming
Xiaoming.stdID=20190102; // 对结构体中的学号赋值
Xiaoming.gender='M'; // 对结构体中的性别赋值
Xiaoming.English=90; // 对结构体中的英语成绩赋值
Xiaoming.Math=85; // 对结构体中的数学成绩赋值
printf("Xiaoming\n");
printf("Gender:%c",Xiaoming.gender); // 输出结构体中的性别
printf("\nMath:%d",Xiaoming.Math); // 输出结构体中的数学成绩
return 0;
}
2. typedef定义新的类型
请看如下语句：
typedef int ElemType;
其中，标识符 ElemType 是一个用户自定义标识符，其实来自 Element Type，表示数据元素类型的含义。
typedef 则来自两个词 type definition，表示类型定义，是系统关键字。
int是系统关键字，表示整数类型。
typedef int ElemType；表示在程序中将用标识符ElemType替换int，可以用来声明变量。
如 ElemType a; 表示 a 就是一个整型变量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f39191dcb3626b7cf38fa1503ba239c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9a323b2287255fe6bed49995fe1bd6e/" rel="bookmark">
			【图像安全性分析】噪声攻击MATLAB代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【高斯噪声】
I=imread('coins.png'); J=imnoise(I, 'gaussian', 0, 0.01);%方差为0.01的高斯噪声 K=imnoise(I, 'gaussian', 0, 0.03);%方差为0.03的高斯噪声 figure; subplot(121); imshow(J);title('方差为0.01的高斯噪声') subplot(122); imshow(K);title('方差为0.03的高斯噪声') 【椒盐噪声】
I=imread('cameraman.tif'); I=im2double(I); J=imnoise(I, 'salt &amp; pepper', 0.01);%添加密度为0.01的椒盐噪声 K=imnoise(I, 'salt &amp; pepper', 0.03);%添加密度为0.03的椒盐噪声 figure; subplot(121); imshow(J);title('%添加密度为0.01的椒盐噪声'); subplot(122); imshow(K);title('%添加密度为0.03的椒盐噪声'); 【泊松噪声】
clear all; close all; I=imread('cameraman.tif'); J=imnoise(I, 'poisson');%添加泊松噪声 figure; subplot(121); imshow(I);title('原图'); subplot(122); imshow(J);title('添加泊松噪声后的图像'); 【乘性噪声】
clear all; close all; I=imread('cameraman.tif'); J=imnoise(I, 'speckle');%添加方差为0.04的乘性噪声 K=imnoise(I, 'speckle', 0.5);%添加方差为0.5的乘性噪声 figure; subplot(121); imshow(J);title('添加方差为0.04的乘性噪声'); subplot(122); imshow(K);title('添加方差为0.5的乘性噪声'); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/818f6f4967ea7444dcc1bfe05130f503/" rel="bookmark">
			CADENCE Allegro导入网表报SPMHNI-184、SPMHNI-195、SPMHNI-191错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 导入网表时报下列错误
#1 ERROR(SPMHNI-191): Device/Symbol check error detected.
ERROR(SPMHNI-195): Symbol 'xxxx' for device 'xxxx' is missing pin '2'.
查看网表文件pstchip.dat发现元器件中存在"NC_PINS='(0)';"一行。
body
PART_NAME='MARK';
JEDEC_TYPE='MARK-BAD';
VALUE='BAD-MARK[NC]';
NC_PINS='(0)';
end_body;
解决方法：
检查元器件在建立的时候属性是否含有NC属性。
检查下"Options -&gt; CIS Configuration File -&gt; Setup","Part Database"选项卡，
"Configuration"区域中众多属性中是否含有命名为“NC”的属性 有的话，需要把CIS数据库中的NC栏重命名掉，或者删掉
然后在"Edit properties"中，选中“NC”栏，右键"Delete Property"删除，再生成网表就没有“NC_PIN”这一行了。
笔者B站帐号：我就是我是兪 https://www.bilibili.com/read/cv23928065?spm_id_from=333.999.0.0 出处：bilibili
欢迎关注 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7902f3747c437780560c0b08897df457/" rel="bookmark">
			stable-diffusion安装controlnet插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、通过url安装controlnet插件 1）extensions → install from URL → install
然后填入：https://github.com/Mikubill/sd-webui-controlnet
2）installed → apply and restart UI
2、下载模型 下载controlnet模型（50G左右）到 E:\stable-diffusion-webui\extensions\sd-webui-controlnet\models 目录下：
lllyasviel/ControlNet at main
把所有8个模型放到models文件夹下
3、查看controlnet插件 4、使用controlnet插件 （待续）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f5d9b796acd88b574f4eabfa8f7cdd7/" rel="bookmark">
			Rancher添加集群报错：Etcd Cluster is not healthy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：
有一台虚拟机在升级内核失败后，回滚至快照。但由于快照版本太老旧，和当前的rancher版本不匹配，服务器上的agent等需要清楚后，重新在rancher添加集群；但是只删除了rancher镜像以及agent相关容器，在添加之后连接失败，报错[etcd] Failed to bring up Etcd Plane: [etcd] Etcd Cluster is not healthy，查看etcd容器日志如下，
解决方法
百度之后找到原因：删除齐郡的适合需要把所有相关容器资源全部删除，需要执行以下操作
# 在虚拟机上执行以下操作
step1：删除rancher相关容器（注：以下命令会删除所有容器，如果你的虚拟机还有rancher集群之外的其他容器，也会被删掉） $ docker rm -f $(docker ps -qa)
$ docker rmi -f $(docker images -q)
step2：删除mount挂载点 $ for mount in $(mount | grep tmpfs | grep ‘/var/lib/kubelet’ | awk ‘{ print $3 }’) /var/lib/kubelet /var/lib/rancher; do umount $mount; done
step3：删除映射的目录 $ rm -rf /etc/ceph /etc/cni /etc/kubernetes /opt/cni /opt/rke /run/secrets/kubernetes.io /run/calico /run/flannel /var/lib/calico /var/lib/etcd /var/lib/cni /var/lib/kubelet /var/lib/rancher/rke/log /var/log/containers /var/log/kube-audit /var/log/pods /var/run/calico
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f5d9b796acd88b574f4eabfa8f7cdd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3b226f69522a513fa83d9a72be6449f/" rel="bookmark">
			小程序包体优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分包
因为小程序限制了主包的大小不能超过2MB，而分包却没有限制这么，因此分包可以极大的优化包体。css
对于主包中要用的css抽提出来，放在一个css中然后在app.tsx中引入，避免重复引入，打包后占包体大小。图片
包中最好不要放1KB以上的图片，也可以全部放到CDN服务器上 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acc67d437b3d4156a230a720b3e93940/" rel="bookmark">
			Java 如何在 Array 和 Set 之间进行转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 在本文章中，我们对如何在 Java 中对 Array 和 Set 进行转换进行一些说明和示例。
这些示例通过使用 Core Java 和一些第三方的转换工具，例如 Guava 和 Apache Commons Collections。
更多有关的文章，请访问：Java - OSSEZ 相关的内容和参与讨论。
从 List 转换为 Set 使用原生 Java 代码 让我们首先来看看如何在原生 Java 中把数组转换为 Set。
通过下面的代码，我们了解到首先需要把 Array 转换为 List，然后再把这个 List 转换为 Set。
@Testpublic void givenUsingCoreJavaV1_whenArrayConvertedToSet_thenCorrect() { Integer[] sourceArray = { 0, 1, 2, 3, 4, 5 }; Set&lt;Integer&gt; targetSet = new HashSet&lt;Integer&gt;(Arrays.asList(sourceArray));} 复制代码
可选的，我们可以首先定义一个 Set 对象，然后把这个 Set 对象的元素进行填充：
@Testpublic void givenUsingCoreJavaV2_whenArrayConvertedToSet_thenCorrect() { Integer[] sourceArray = { 0, 1, 2, 3, 4, 5 }; Set&lt;Integer&gt; targetSet = new HashSet&lt;Integer&gt;(); Collections.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acc67d437b3d4156a230a720b3e93940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a7dd3e450c0440975bcb38d45ccd06c/" rel="bookmark">
			compressorjs 参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd937eb0053b44e71e74c9737c553816/" rel="bookmark">
			Docker Emby 开心版 安装及硬解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下。网上查的零零碎碎的。
安装命令 docker run -d /
--v /mnt/sda1/Configs/Emby:/config / #设置配置目录
--v /mnt/sda1/视频:/data / #设置你的视频文件目录
--net=bridge /
--restart=always /
--device=/dev/dri:/dev/dri / #映射 显卡设备 硬解用
--name Emby / -p 8896:8096 / #映射端口号
-p 8920:8920 /
lovechen/embyserver:latest /
开启硬解
需要在终端运行一下命令
chmod 777 /dev/dri/render128
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb55fde64916931f214061d29311a4e/" rel="bookmark">
			Java中读取properties配置文件的八种方式总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import org.junit.Test; import org.springframework.core.io.ClassPathResource; import org.springframework.core.io.Resource; import org.springframework.core.io.support.PropertiesLoaderUtils; import java.io.BufferedInputStream; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.util.*; /** * @desc: Properties读取配置文件属性值的方式 * @author: cao_wencao * @date: 2020-12-29 10:08 */ public class PropertiesTest { /** * 1. 方式一 * 从当前的类加载器的getResourcesAsStream来获取 * InputStream inputStream = this.getClass().getResourceAsStream(name) * * @throws IOException */ @Test public void test1() throws IOException { InputStream inputStream = this.getClass().getResourceAsStream("jdbc.properties"); Properties properties = new Properties(); properties.load(inputStream); properties.list(System.out); System.out.println("=============================================="); String property = properties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfb55fde64916931f214061d29311a4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3cc99193b066e931b171f1cc5cb7c45/" rel="bookmark">
			MonoRUn: Monocular 3D Object Detection by Reconstruction and Uncertainty Propagation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3D 空间中的目标定位是单目 3D 目标检测的一个具有挑战性的方面。 6DoF 姿态估计的最新进展表明，预测图像和对象 3D 模型之间的密集 2D-3D 对应图，然后通过 Perspective-nPoint (PnP) 算法估计对象姿态可以实现显着的定位精度。然而，这些方法依赖于目标的几何真值的训练，这在真实的户外场景中很难获得。为了解决这个问题，我们提出了 MonoRUn，这是一种新颖的检测框架，它以自监督的方式学习密集对应关系和几何图形，并带有简单的 3D 边界框注释。
单目 3D 目标检测是计算机视觉中一个活跃的研究领域。尽管基于深度学习的 2D 对象检测取得了显着进展 [3, 30]，但 3D 对应物仍然对准确的对象定位提出了更大的挑战，因为 单个图像无法提供明确的深度信息 。为了解决这个问题，大量工作利用几何先验并通过 2D-3D 约束解决对象姿态（相机帧中的位置和方向）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b9f37bbfd681b4a10c9e872401834a1/" rel="bookmark">
			SelFlow: Self-Supervised Learning of Optical Flow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文提出了一种用于光流的自监督学习方法。该方法从非遮挡像素中提取可靠的流估计，并使用这些预测作为真值来学习幻觉遮挡的光流。 本文设计了一个简单的 CNN，以利用 来自多个帧的时间信息 来更好地进行流估计。本方法可以在 MPI Sintel、KITTI 2012 和 2015 等具有挑战性的基准上为无监督光流学习产生最佳性能。 光流估计是各种计算机视觉系统的核心构建模块。由于遮挡，准确的流估计仍然是一个悬而未决的问题。传统方法最小化能量函数以 鼓励视觉上相似像素的关联 并规范非相干运动 以将流估计从非遮挡像素传播到遮挡像素。然而，这一系列方法通常很耗时，并且不适用于实时应用。 最近的研究学习使用卷积神经网络 (CNN) 从图像中端到端地估计光流。然而，训练完全监督的 CNN 需要大量标记的训练数据 ，这对于光流来说是极其难以获得的，尤其是在存在遮挡的情况下。训练数据的大小是光流估计的关键瓶颈。 在没有大规模真实世界注释的情况下，现有方法转向在 合成标记数据集 上进行 预训练，然后在小型注释数据集上 进行微调。然而，合成数据的分布与自然场景之间通常存在很大差距。为了训练一个稳定的模型，我们必须仔细遵循不同数据集的特定学习计划 。 受益于未标记数据的无监督光流学习方法的基本思想 是根据估计的光流 将目标图像向参考图像扭曲，然后使用 光度损失 最小化参考图像和扭曲目标图像之间的差异。这种想法适用于非遮挡像素，但会为遮挡像素提供误导性信息。最近的方法建议在计算光度损失时排除那些被遮挡的像素，或者使用额外的空间和时间平滑项来规范流量估计 。DDFlow [26] 提出了一种 数据蒸馏 方法，该方法采用 随机裁剪 来创建遮挡以进行自监督。但这些方法不能很好地泛化所有自然遮挡。因此，将无监督方法与最先进的全监督方法相比，仍然存在很大的性能差距。 （data distillation：对没有标签的数据进行多种变换(类似与数据增强)，使用单模型进行预测，然后集成预测结果，自动生成图像标签的方法 ） 本文展示了一种自监督的方法 可以学习从未标记的数据中 使用任何形式的遮挡 来估计光流。本文的工作基于从非遮挡像素中提取可靠的流估计，并使用这些预测 来指导遮挡的光流学习。图 1 说明了本文通过 扰动超像素 来创建合成遮挡的想法。本文进一步 利用 来自多个帧的时间信息 来提高简单 CNN 架构中的流预测精度。由此产生的学习方法在 Sintel 和 KITTI 基准上的所有无监督光流学习方法中产生了最高的准确性。 图1：首先用经典的光度损失（测量参考图像（a）和扭曲的目标图像（d）之间的差异）训练我们的 NOC 模型，由遮挡图（g）引导。然后 扰动目标图像（b）中随机选择的超像素 以产生幻觉遮挡。最后，使用来自NOC 模型的可靠流估计来指导 OCC 模型学习那些新被遮挡的像素（由自监督掩码 (i) 表示，其中值 1 表示像素在 (g )中未遮挡 但在 (h) 中被遮挡。请注意，黄色区域是移动狗的一部分。我们的自监督方法学习运动物体和静态场景的光流。 Selflow是监督学习方法第一次在不使用任何外部标记数据的情况下实现如此出色的准确性。 Related Work： 经典的光流估计： 经典变分方法将光流估计建模为 基于亮度恒定性和空间平滑度的能量最小化问题。这种方法 对小运动有效，但当位移很大时往往会失败 。后来的工作集成了特征匹配以初始化稀疏匹配，然后以金字塔粗到细的方式插入密集流图 [6, 47, 38]。 最近的工作使用卷积神经网络 (CNN) 通过学习有效的特征嵌入来改进稀疏匹配 [49, 2]。然而，这些方法通常计算成本高，并且无法进行端到端的训练。 提高流估计的鲁棒性和准确性的一种自然扩展是在多个帧上合并时间信息。一种直接的方法是添加时间上的约束 ，例如恒定速度、恒定加速度、低维线性子空间 或刚性/非刚性分割。 但本文的方法要简单得多，并且不依赖于任何数据假设。Selflow直接为数据中 存在更广泛的具有挑战性的案例 学习光流。 光流的监督学习：使用 CNN 学习光流 FlowNet 是第一个端到端的光流学习框架。它以两个连续的图像作为输入并输出一个密集的流图。 FlowNet 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b9f37bbfd681b4a10c9e872401834a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e0a0f080101fec609b7072c026b8352/" rel="bookmark">
			弹性盒最后一个元素靠左显示 而不是居中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在弹性盒中，可以使用 justify-content 属性来控制主轴上的对齐方式， align-items 属性来控制交叉轴上的对齐方式。
如果你想让最后一个元素靠左显示，可以使用 justify-content: flex-start 和 align-items: center，如下所示：
.parent {
display: flex;
justify-content:
flex-start;
align-items: center;
}
这样，所有子元素都会沿着主轴从左到右排列，同时在交叉轴上居中对齐，最后一个元素就会靠左显示了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fd272a264e46caee3fd90f8877f8e0e/" rel="bookmark">
			Hang Detect 问题分析案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此题是 上层发生SWT 喂狗超时 hang detect 主动call 重启 我司测试反馈跑monkey发生过重启现象
LOG 中有明显的db.fatal.00.KE DB文件, 解压DB， 在exp_main 里面可以看到：
Flavor Info: 'None' Exception Log Time:[Tue Nov 19 18:12:25 CST 2019] [17.91493] Exception Class: Kernel (KE) PC is at [&lt;ffffff80087db8b4&gt;] hang_detect_thread+0x20c/0x338 LR is at [&lt;ffffff80087db8ac&gt;] hang_detect_thread+0x204/0x338 Current Executing Process: [hang_detect, 196][kthreadd, 2] Backtrace: [&lt;ffffff800808a798&gt;] bug_handler.part.2+0x40/0x80 [&lt;ffffff800808a7fc&gt;] bug_handler+0x24/0x30 [&lt;ffffff80080829e8&gt;] brk_handler+0x88/0xd0 [&lt;ffffff8008081704&gt;] do_debug_exception+0x94/0x148 [&lt;ffffff800808470c&gt;] el1_dbg+0x18/0x8c [&lt;ffffff80080c4014&gt;] kthread+0xec/0x100 [&lt;ffffff8008084fa0&gt;] ret_from_fork+0x10/0x30 [&lt;ffffffffffffffff&gt;] 0xffffffffffffffff 从exp_main log种可看出此题是hang detect 主动call bug, 即hang detect 检测到android 上层或底层已经卡住，主动重启手机。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fd272a264e46caee3fd90f8877f8e0e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/131/">«</a>
	<span class="pagination__item pagination__item--current">132/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/133/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>