<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9b00a6b5864d53ee6afac33ca5455a2/" rel="bookmark">
			MYSQL解析json字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.数据库存储数据
[{"key":"禁口食材","value":"葱，香菜"},{"key":"用户病症","value":"低血糖"}] 2.读出JSON数组中的所有KEY
SELECT JSON_EXTRACT(user_features,'$[*].key') FROM customer_info WHERE customer_id = '35523232' 3.读出JSON数组中的所有value
SELECT JSON_EXTRACT(user_features,'$[*].value') FROM customer_info WHERE customer_id = '35523232' 4.读出某个key为XX的值,并以字符串展示
SELECT JSON_UNQUOTE(JSON_EXTRACT(JSON_EXTRACT(user_features,'$[*].value'), JSON_UNQUOTE(JSON_SEARCH(JSON_EXTRACT(user_features,'$[*].key'), 'one', 'XX')))) userFeatures FROM customer_info WHERE customer_id = '35523232' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09faff44f17f301a9110025751308751/" rel="bookmark">
			MySQL创建事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DELIMITER //
CREATE EVENT fill_NUll_in_evalmanager ON SCHEDULE EVERY 1 DAY STARTS '2019-12-18 05:58:00' ON COMPLETION PRESERVE
DO BEGIN
UPDATE eval_fundmanager SET ManagerName= '0' WHERE UpdateTime &gt; DATE_SUB(NOW(), INTERVAL 18 HOUR) AND ManagerName IS NULL;
END; //
DELIMITER ;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c87a9e9c5e9d2a5c73cb5b7baa46d9aa/" rel="bookmark">
			Linux下GDB调试指令汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的指令如下： 运行指令：
run（简写r）: 运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步命令continue（简写c） : 继续执行，到下一个断点停止（或运行结束）next（简写n） : 单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。**step （简写s）：**单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的until（简写u）：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。until+行号： 运行至某行，不仅仅用来跳出循环finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。call 函数（参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)quit（简写q） : 退出gdb 设置断点：
break n （简写b n）: 在第n行处设置断点（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）b fn1 if a＞b：条件断点设置break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_buttondelete 断点号n：删除第n个断点disable 断点号n：暂停第n个断点enable 断点号n：开启第n个断点clear 行号n：清除第n行的断点info b （info breakpoints） ：显示当前程序的断点设置情况delete breakpoints：清除所有断点： 查看源代码：
list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12list 函数名：将显示“函数名”所在函数的源代码，如：list mainlist ：不带参数，将接着上一次 list 命令的，输出下边的内容。 打印表达式：
print 表达式（简记p）: 其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。print a：将显示整数 a 的值print ++a：将把 a 中的值加1,并显示出来print name：将显示字符串 name 的值print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display awatch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch awhatis ：查询变量或函数info function： 查询函数扩展info locals： 显示当前堆栈页的所有变量 查询运行信息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c87a9e9c5e9d2a5c73cb5b7baa46d9aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d9e7410695ef197b5b13c452bfe50a9/" rel="bookmark">
			centos 使用 scl 软件集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		os: centos 7.4
yum repolist 之前已经安装了 epel
# yum repolist repo id repo name status base/7/x86_64 CentOS-7 - Base 10,097 epel/x86_64 Extra Packages for Enterprise Linux 7 - x86_64 13,490 extras/7/x86_64 CentOS-7 - Extras 305 updates/7/x86_64 CentOS-7 - Updates 997 yum install scl # yum install centos-release-scl centos-release-scl-rh # yum repolist repo id repo name status base/7/x86_64 CentOS-7 - Base 10,097 centos-sclo-rh/x86_64 CentOS-7 - SCLo rh 8,770 centos-sclo-sclo/x86_64 CentOS-7 - SCLo sclo 869 epel/x86_64 Extra Packages for Enterprise Linux 7 - x86_64 13,490 extras/7/x86_64 CentOS-7 - Extras 305 updates/7/x86_64 CentOS-7 - Updates 997 可以看到已经有 centos-sclo-rh、centos-sclo-sclo 的源了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d9e7410695ef197b5b13c452bfe50a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b41552d13ea9846fdcfdc29f799e5e/" rel="bookmark">
			混淆矩阵 confusion matrices
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度百科 混淆矩阵也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。具体评价指标有总体精度、制图精度、用户精度等，这些精度指标从不同的侧面反映了图像分类的精度。 [1] 在人工智能中，混淆矩阵（confusion matrix）是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。在图像精度评价中，主要用于比较分类结果和实际测得值，可以把分类结果的精度显示在一个混淆矩阵里面。混淆矩阵是通过将每个实测像元的位置和分类与分类图像中的相应位置和分类相比较计算的。
混淆矩阵的每一列代表了预测类别，每一列的总数表示预测为该类别的数据的数目；每一行代表了数据的真实归属类别，每一行的数据总数表示该类别的数据实例的数目。每一列中的数值表示真实数据被预测为该类的数目：如下图，第一行第一列中的43表示有43个实际归属第一类的实例被预测为第一类，同理，第一行第二列的2表示有2个实际归属为第一类的实例被错误预测为第二类。
如有150个样本数据，预测为1,2,3类各为50个。分类结束后得到的混淆矩阵为：
、
每一行之和表示该类别的真实样本数量，每一列之和表示被预测为该类别的样本数量，第一行说明有43个属于第一类的样本被正确预测为了第一类，有两个属于第一类的样本被错误预测为了第二类。
分类模型的评估指标 原文链接：https://blog.csdn.net/Orange_Spotty_Cat/article/details/80520839
混淆矩阵是ROC曲线绘制的基础，同时它也是衡量分类型模型准确度中最基本，最直观，计算最简单的方法。
混淆矩阵是评判模型结果的指标，属于模型评估的一部分。此外，混淆矩阵多用于判断分类器（Classifier）的优劣，适用于分类型的数据模型，如分类树（Classification Tree）、逻辑回归（Logistic Regression）、线性判别分析（Linear Discriminant Analysis）等方法。
在分类型模型评判的指标中，常见的方法有如下三种：
混淆矩阵（也称误差矩阵，Confusion Matrix）ROC曲线AUC面积 以分类模型中最简单的二分类为例，对于这种问题，我们的模型最终需要判断样本的结果是0还是1，或者说是positive还是negative。
我们通过样本的采集，能够直接知道真实情况下，哪些数据结果是positive，哪些结果是negative。同时，我们通过用样本数据跑出分类型模型的结果，也可以知道模型认为这些数据哪些是positive，哪些是negative。
因此，我们就能得到这样四个基础指标，我称他们是一级指标（最底层的）：
真实值是positive，模型认为是positive的数量（True Positive=TP） 真实值是positive，模型认为是negative的数量（False Negative=FN）：这就是统计学上的第一类错误（Type I Error） 真实值是negative，模型认为是positive的数量（False Positive=FP）：这就是统计学上的第二类错误（Type II Error） 真实值是negative，模型认为是negative的数量（True Negative=TN） 将这四个指标一起呈现在表格中，就能得到如下这样一个矩阵，我们称它为混淆矩阵（Confusion Matrix）：
但是，混淆矩阵里面统计的是个数，有时候面对大量的数据，光凭算个数，很难衡量模型的优劣。因此混淆矩阵在基本的统计结果上又延伸了如下4个指标，我称他们是二级指标（通过最底层指标加减乘除得到的）：
准确率（Accuracy）—— 针对整个模型
精确率（Precision）
灵敏度（Sensitivity）：就是召回率（Recall）
特异度（Specificity）
我用表格的方式将这四种指标的定义、计算、理解进行了汇总：
通过上面的四个二级指标，可以将混淆矩阵中数量的结果转化为0-1之间的比率。便于进行标准化的衡量。
三级指标 这个指标叫做F1 Score。他的计算公式是：
其中，P代表Precision，R代表Recall。
F1-Score指标综合了Precision与Recall的产出的结果。F1-Score的取值范围从0到1的，1代表模型的输出最好，0代表模型的输出结果最差。
混淆矩阵的实例 当分类问题是二分问题是，混淆矩阵可以用上面的方法计算。当分类的结果多于两种的时候，混淆矩阵同时适用。
一下面的混淆矩阵为例，我们的模型目的是为了预测样本是什么动物，这是我们的结果：
通过混淆矩阵，我们可以得到如下结论：
Accuracy
在总共66个动物中，我们一共预测对了10 + 15 + 20=45个样本，所以准确率（Accuracy）=45/66 = 68.2%。
以猫为例，我们可以将上面的图合并为二分问题：
Precision
所以，以猫为例，模型的结果告诉我们，66只动物里有13只是猫，但是其实这13只猫只有10只预测对了。模型认为是猫的13只动物里，有1条狗，两只猪。所以，Precision（猫）= 10/13 = 76.9%
Recall
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54b41552d13ea9846fdcfdc29f799e5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a89d849422cc714d931726217eb869c/" rel="bookmark">
			如何实现统计numpy列表中各元素的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		numpy和pandas中的Series不同，不能直接用values_count()做统计
如：生成一个包含10000个1~6的列表
import numpy as np import pandas as pd random_data=np.random.randint(1,7,10000) random_data.mean() #均值 random_data.std() #标准差 尝试用value_counts()方法，统计不同元素的个数，报以下错误。
random_data.value_counts() --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-32-2f4c42b180a9&gt; in &lt;module&gt; ----&gt; 1 random_data.value_counts() AttributeError: 'numpy.ndarray' object has no attribute 'value_counts' 可以用以下两种方法做列表元素个数的统计。
#第一种 unique,count=np.unique(random_data,return_counts=True) data_count=dict(zip(unique,count)) #第二种 import collections data_count2=collections.Counter(random_data) Counter({1: 1637, 2: 1686, 6: 1604, 5: 1678, 3: 1728, 4: 1667}) 返回的是一个dict字典，可以用data_count2.keys()和data_count2.values()取相应的key值和value值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02d246457c3ff7ba524db27a6b2317a7/" rel="bookmark">
			SAS 学习笔记（十）— SAS函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介字符变量处理字符处理函数案例 数值变量处理取整函数描述性统计函数 变量类型转换字符型转换为数值型数值型转换为字符型案例 简介 函数类型
数组函数 / 字符函数 / 日期时间函数 / 描述统计函数 / 金融函数 / 数学函数
概率函数 / 随机数函数 / 三角函数 / 特殊函数 / 州和Zip码换算函数
SAS 变量列表
SAS变量列表是对要引用的一组变量的简写形式
在第一个变量名称前需使用OF关键字
四种形式：
序号区间 Total = sum(of Year1-Year4);名称区间 Total = sum(of Year2--Year4);名称前缀 Total = sum(of Year:);特殊SAS名称列表
字符变量处理 字符处理函数 SUBSTR 函数 （右侧）
在赋值语句右侧的SUBSTR 函数可用于提取字符。
NewVar=SUBSTR(string,start&lt;,length&gt;);
PROPCASE 函数
PROPCASE函数将变量中的所有字符转换为合适的格式。
（第一个字符为大写，其他的字符为小写 ）
NewVar = PROPCASE(argument &lt;,delimiter(s)&gt;);
delimiter(s)是用于分隔的字符。若缺失，默认的分隔符包括空格， /， - ，制表符等 SCAN 函数
用于返回一个字符串中的第 n个词。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02d246457c3ff7ba524db27a6b2317a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6efe2ad835b61152063064ec8f1db12a/" rel="bookmark">
			解读 | 2019年10篇计算机视觉精选论文（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 神经小兮
来源 | HyperAI超神经（ID:HyperAI）
2019 年转眼已经接近尾声，我们看到，这一年计算机视觉（CV）领域又诞生了大量出色的论文，提出了许多新颖的架构和方法，进一步提高了视觉系统的感知和生成能力。因此，我们精选了 2019 年十大 CV 研究论文，帮你了解该领域的最新趋势。
我们看到，近年来，计算机视觉（CV）系统已经逐渐成功地应用在医疗保健，安防，运输，零售，银行，农业等领域，也正在逐渐改变整个行业的面貌。
而今年，CV 领域依然硕果累累，诞生了多篇优秀论文。我们选择了其中十篇论文，以供大家参考、学习，了解该领域的最新趋势与前沿技术。
这十篇论文涵盖了卷积网络的优化，计算机视觉中的无监督学习，图像生成和机器生成图像的评估，视觉语言导航，使用自然语言为两个图像标注变化等。
以下是我们精选的 10 篇论文目录，先一睹为快：
1.EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks
EfficientNet：卷积神经网络模型缩放的反思
2.Learning the Depths of Moving People by Watching Frozen People
通过观看静止的人来学习移动的人的深度
3.Reinforced Cross-Modal Matching and Self-Supervised Imitation Learning for Vision-Language Navigation
增强的跨模态匹配和自我监督的模仿学习，用于视觉语言导航
4.A Theory of Fermat Paths for Non-Line-of-Sight Shape Reconstruction
非视线形状重构的费马路径理论
5.Reasoning-RCNN: Unifying Adaptive Global Reasoning into Large-scale Object Detection
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6efe2ad835b61152063064ec8f1db12a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bc0300a54185e2e46231793f6a861cb/" rel="bookmark">
			Android WebView 常见问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Native调用js（一定要在UI线程操作）WebView 加载超长JS数据，JS方法不回调问题Android WebView白屏或onJsAlert只调用一次 Native调用js（一定要在UI线程操作） 调用js的两种方式：
String js = "javascript:" + function + "(" + param + ")"; webview.evaluateJavascript(js, calllback); //(4.4+)：不会使页面刷新 webview.loadUrl(js); // 页面会刷新 WebView 加载超长JS数据，JS方法不回调问题 Android 16及以下的手机上，能正常使用，但是在17 及以上的手机上，发现JS没有执行。这是因为，WebView在Android 17及以后对之前的WebView存在的安全问题做了调整。需要使用evaluateJavascript。
String js = "javascript:" + function + "(" + param + ")"; webview.evaluateJavascript(js, calllback); Android WebView白屏或onJsAlert只调用一次 当我们不希望网页显示弹窗时，若直接设置onJsAlert/onJsConfirm返回true
@Override public boolean onJsAlert(WebView view, String url, String message, JsResult result) { return true; } 可导致页面白屏，无法继续成功加载任何页面，且onJsAlert/onJsConfirm只调用一次，不会继续调用。
需要按照如下方式设置：
@Override public boolean onJsAlert(WebView view, String url, String message, JsResult result) { result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bc0300a54185e2e46231793f6a861cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf0620a1ce6ebc7bd77991a592680a88/" rel="bookmark">
			Java编程：常用的字段脱敏工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import org.apache.commons.lang.StringUtils; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * @author zhibo * @date 2019-12-12 15:10 */ public class EncryptUtil { public static final String MOBILE_REG = "^\\d{11}$"; public static final String EMAIL_REG = "@+"; // 手机号码前三后四脱敏 public static String mobileEncrypt(String mobile) { if (StringUtils.isEmpty(mobile) || (mobile.length() != 11)) { return mobile; } return mobile.replaceAll("(\\d{3})\\d{4}(\\d{4})", "$1****$2"); } /** * 隐藏邮箱信息 * * @param email * @return */ public static String emailEncrypt(String email) { if (StringUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf0620a1ce6ebc7bd77991a592680a88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10d471123e473512cc84a99065156673/" rel="bookmark">
			目标检测中的不平衡问题及其解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（不平衡问题综述文章：Imbalance Problems in object Detection：A Review）
我们最常想到的不平衡问题是：目标类别不平衡，然而实际上有以下不平衡问题：
（1）类别不平衡：前景和背景不平衡、前景中不同类别输入包围框的个数不平衡；
（2）尺度不平衡：输入图像和包围框的尺度不平衡，不同特征层对最终结果贡献不平衡；
（3） 空间不平衡：不同样本对回归损失的贡献不平衡、正样本IoU分布不平衡、目标在图像中的位置不平衡；
（4）目标函数不平衡：不同任务（比如回归和分类）对全局损失的贡献不平衡
附上github参考网址：（https://github.com/kemaloksuz/ObjectDetectionImbalance）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3dc21c81ac8406fa7ebeca74ebf80ac/" rel="bookmark">
			浏览器访问跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中遇到一个问题：用ajax来获取数据，但返回的status为0，从浏览器的打印看应该是跨域问题：
origin 'file://' has been blocked by CORS policy: Response to preflight request does not pass access control chech: No "Access-Control-Allow-Origin" header is present on the requested resource.
我用浏览器启动一个本地网页(file:///a.html),然后在js代码中用ajax来向一个远程服务器请求数据，出现的这个问题。
引用阮一峰老师的博客内容：
CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。
整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。
因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。
浏览器需要开启CORS跨域选项。
但还是没有正常访问到数据，问题还需要进一步调试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8db805c56a853452c51da95c96aed360/" rel="bookmark">
			如何比较本地git分支与其远程分支？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何查看本地分支和远程分支之间的diff ？ #1楼 第一种 git branch -a 获取可用分支列表。 在输出上你可能会看到类似的东西 * master remotes/main/master remotes/origin/HEAD -&gt; origin/master remotes/origin/master remotes/origin/mt remotes/upstream/master remotes/upstream/mt 然后显示差异 git diff --stat --color remotes/main/master..origin/master git diff remotes/main/master..origin/master #2楼 要更新远程跟踪分支，您需要先键入git fetch然后： git diff &lt;masterbranch_path&gt; &lt;remotebranch_path&gt; 你可以git branch -a列出所有分支机构（本地和远程）然后选择分支的名字从名单（只是删除remotes/远程分支的名字。 示例： git diff master origin/master （其中“master”是本地主分支，“origin / master”是远程，即origin和master分支。） #3楼 git diff &lt;local branch&gt; &lt;remote&gt;/&lt;remote branch&gt; 例如git diff master origin/master ，或git diff featureA origin/next 当然， 曾经说过，你需要远程跟踪分支 git fetch第一; 并且您需要它以获得有关远程存储库中分支的最新信息。 #4楼 简单的方法： git fetch git log -p HEAD.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8db805c56a853452c51da95c96aed360/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c7a80a3d06e99795d870eb1fc984c8/" rel="bookmark">
			如何使用extern在源文件之间共享变量？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我知道C中的全局变量有时具有extern关键字。 什么是extern变量？ 声明是什么样的？ 它的范围是什么？ 这与跨源文件共享变量有关，但是它如何精确地工作？ 我在哪里使用extern ？ #1楼 extern的正确解释是您向编译器告知了一些信息。 您告诉编译器，尽管目前尚不存在，但声明的变量将以某种方式由链接器（通常在另一个对象（文件）中）找到。 然后，无论您是否有外部声明，链接器都将是找到所有内容并将其放在一起的幸运者。 #2楼 在C中，文件内的变量example.c被赋予局部作用域。 编译器期望该变量在同一文件example.c中具有其定义，而在未找到该变量的情况下，它将引发错误。另一方面，函数默认具有全局范围。 因此，您不必向编译器明确提及“老兄……您可能会在这里找到此函数的定义”。 对于一个包含声明文件的函数就足够了（您实际上称为头文件的文件）。 例如，考虑以下2个文件： example.c #include&lt;stdio.h&gt; extern int a; main(){ printf("The value of a is &lt;%d&gt;\n",a); } example1.c int a = 5; 现在，当您使用以下命令将两个文件编译在一起时： 步骤1）cc -o ex example.c example1.c步骤2）./ ex 您将获得以下输出：a的值为&lt;5&gt; #3楼 首先， extern关键字不用于定义变量。 而是用于声明变量。 我可以说extern是存储类，而不是数据类型。 extern用于让其他C文件或外部组件知道此变量已在某处定义。 示例：如果您正在构建库，则无需在库本身的某个位置强制定义全局变量。 该库将直接编译，但是在链接文件时，它将检查定义。 #4楼 extern关键字与变量一起使用，以将其标识为全局变量。 它也表示您可以在任何文件中使用使用extern关键字声明的变量，尽管该变量是在其他文件中声明/定义的。 #5楼 extern允许程序的一个模块访问在程序的另一个模块中声明的全局变量或函数。 通常，您在头文件中声明了外部变量。 如果您不希望程序访问变量或函数，请使用static ，它告诉编译器该变量或函数不能在该模块外部使用。 #6楼 Extern是用于声明变量本身位于另一个翻译单元中的关键字。 因此，您可以决定在翻译单元中使用变量，然后从另一个变量中访问它，然后在第二个变量中，将其声明为extern，链接器将解析该符号。 如果不将其声明为extern，则将获得2个名称相同但完全不相关的变量，以及多个变量定义的错误。 #7楼 extern变量是在另一个转换单元中定义的变量的声明（感谢sbi进行更正）。 这意味着该变量的存储在另一个文件中分配。 假设你有两个.c -files test1.c和test2.c 。 如果定义一个全局变量int test1_var; 在test1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52c7a80a3d06e99795d870eb1fc984c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86c587393fbd36ac8a59783194f7acc8/" rel="bookmark">
			Redis学习之getrange命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 getrange命令语法返回值例子 getrange命令 Redis getrange， 命令用于获取存储在指定 key 中字符串的子字符串。
字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。
语法 getrange key start end 返回值 截取得到的子字符串
例子 127.0.0.1:6379&gt; set test:getrange "long live China." OK 127.0.0.1:6379&gt; getrange test:getrange 0 -1 "long live China." 127.0.0.1:6379&gt; getrange test:getrange -6 -1 "China." 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/518e955c82aab54600673db5f0398404/" rel="bookmark">
			Abaqus和Python结合实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标 利用 p y t h o n python python中的循环大大简化 A b a q u s Abaqus Abaqus中参数的输入过程。
问题 已知某物体有50个箱形截面，每个截面相关参数如图所示：
宽度和高度可以通过 m a t l a b matlab matlab根据转动惯量和面积相同求出（具体过程在此处不做推导）。
在 A b a q u s Abaqus Abaqus中的过程为 1、部件 2、材料 3、剖面 此时需要手动将50个剖面的高度和宽度输入。（厚度已知为1mm）
4、截面 需要在剖面名称中手动选择50个之前定义好的剖面。
5、指派截面 指派 → \rightarrow →截面。
手动选择每一段 s e c t i o n section section，如上图所示，直至指派完50个截面。
6、指派截面方向 指派 → \rightarrow →梁截面方向。
选中整个梁
直接回车确定即可。
7、创建分析步 双击steps
8、装配 → \rightarrow →实例 9、边界条件、载荷 边界条件：使梁的一端完全固定即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/518e955c82aab54600673db5f0398404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f7b00f5e0dbed777b236fca832bdaac/" rel="bookmark">
			实力败给流量的时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《我就是演员之巅峰对决》所谓的下半季第1期节目郭晓东被淘汰让人大跌眼镜，在不少观众心目中，他的表演就算不是当期最精彩的，也无论如何不可能排名末位。而这样让人质疑节目公平性的结果今年已经不是第1次出现了，郭涛的演技有目共睹，在上半季也惨遭淘汰。如果说彼时还有剧本的感染力等因素，郭晓东的淘汰就赤裸裸地体现了节目的选人标准——流量第一，实力第二。实际上要判断哪位演员会出局很简单，甚至可以不看他们的表演，只看他们的受关注度：名气、话题性、吸引的流量、引起讨论的热度，后面这些幕后的“硬”指标是节目组最关心的，自然也就决定了他们的命运。循着这条线索，迄今为止每一位演员的淘汰都是顺理成章的。
话说回来，流量称王是这个时代的特征，在这种环境下也不能过分苛责我就是演员节目组，毕竟收视率和随之而来的广告收入的竞争是残酷的。我就是演员前两季开了好头，算是一款有自主知识产权的好综艺。这时候资本嗅到了商机，跟风节目铺天盖地而来，演员请就位、演技派……为了避免同质化和观众流失，我就是演员想出了巅峰对决这一招，把PK的演员从渴望认可和重获新生这两类一下子升级到成名已久的大腕。老演员的演技是有保证，但又怕对年轻人的号召力不足，所以总要搭配一个偶像。不过说实话，无论是跨界的李宇春还是少年成名的关晓彤，表演得都不错。问题就在于节目组追求的不仅是一款有质量的综艺，更是一款火爆的综艺，所以在实力和流量的竞争中，总是偏向后者。
最后补充一下我认为的节目组控制排名的机制。演员的分数来自两部分，一是专业评委的节目评分，二是普通观众的演员评分。从几期节目公布的评分来看，节目评分还是挺真实客观的，没有潜规则的观感；演员评分则给了“调节”排名巨大的操作空间，和观众印象反差巨大的也基本上来自于此。换言之，前者体现的是节目组的品质追求，也是真正热爱表演在乎演技的演员更应该看重的；后者反映的是节目组的市场考虑，最新追话题和捧自家偶像的粉丝在意的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b10a65413dbe199a5f79561ed9d51a0/" rel="bookmark">
			【数据处理】 python 极速极简画图——频数(率)分布直方图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 当我们拿到数据的时候，第一时间就是想知道数据的特点，然鹅单个的数值如平均数、中位数仍不够直观，我们更想得到数据的分布，以便后续的工作，此时就可以采用频数(率)分布直方图。这里以我的一个实际问题为例，一步步讲如何得到想要的图，分为极简版、完整版和进阶版。
画图总结，同系列其他文章请浏览：
【数据处理】 python 极速极简画图(黑白)——简单条形图、多维并列条形图【数据处理】 python 极速极简画图——频数(率)分布直方图【数据处理】 python 极速极简画图——二维连线、散点图【数据处理】 python 极速极简画图——折线图 方法 用python实现直方图画法有很多种：
1. 纯python自己编写
2. matplotlib.pyplot，调hist
3. pandas 里DataFrame，调hist
4. seaborn里画
…
感兴趣的同学移步教你利用Python玩转histogram直方图的五种方法.这里主要展示基于matplotlib.pyplot的画法。
数据 准备好一列数值型的数据，list或numpy.array都行。这里采用的是纽约一段时间内发布事件的生命周期，看其分布。下图为数据展示，147013是数据条数。
极简版 以频数分布直方图为例，若要改成频率分布直方图，plt.hist(x,normed=True)即可，注意纵坐标不是概率，面积才是。
plt.figure() #初始化一张图 x = life_cycle plt.hist(x) #直方图关键操作 plt.grid(alpha=0.5,linestyle='-.') #网格线，更好看 plt.xlabel('Life Cycle /Month') plt.ylabel('Number of Events') plt.title(r'Life cycle frequency distribution histogram of events in New York') plt.show() 可以看到总体分布特征呈长尾分布，这种分布的数据集中在“头部”，而“尾部”过长，越接近尾部的数量越少。
可以看出不加任何参数控制的极简版画图会有些问题：
描述能力问题。对数据特征的表达不够细致,只能通过图得知，大部分事件的生命周期在0~20个月里，然鹅这很有可能是描述不准确的，因为看不到0-20月里更细致的分布(有可能大部分集中在更小的区间里)。刻度问题。长尾分布，尾过长导致刻度间隔过大，无法看出直方之间的刻度是多少。 下面针对这些问题进行微调。
极简版微调 所有的微调都基于plt.hist()里的参数，所有参数如下：
matplotlib.pyplot.hist( x, bins=10, range=None, normed=False, weights=None, cumulative=False, bottom=None, histtype=u'bar', align=u'mid', orientation=u'vertical', rwidth=None, log=False, color=None, label=None, stacked=False, hold=None, **kwargs) 调“直方条”的个数 “直方条”的个数由参数bins决定，为了得到更细致的分布，我们调大点，这里我选择bins=50。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b10a65413dbe199a5f79561ed9d51a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/100b04f0c6c550009c7126d4c9629ac2/" rel="bookmark">
			LTE切换信令详析及注释（附图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		典型的前台切换信令如下图所示，从测量报告上报到切换完成后直至读取目标小区的系统消息，与前台UE相关的总共有7条层三信令。
7条信令的作用基本如下：
UE测量报告上报：告知源eNodeB目标小区的PCI，需要进行切换；
源小区向UE下发RRC连接重配置信息：此信息中将分配的专用接入签名配置给UE；
UE向目标小区发RRC连接重配置完成消息：表示UE已经切换到了目标侧；
目标小区向UE下发RRC连接重配置信息：此信息中将目前小区中的邻区信息下发给UE，开测量。
UE向目标小区发RRC连接重配置完成消息：表示UE已经打开了测量，可以进行下次切换；
UE在目标小区读取系统消息。
下面对各个前台信令中的解码内容进行详细说明：
1---测量报告
测量报告中报告了本小区RSRP值、RSRQ值以及目标小区PCI、目标小区RSRP值、目标小区RSRQ值。
其中主要注意的是目标小区PCI以及目标小区RSRP值。（测出来的RSRP值减去140即可转换为通常的负值。后面括号中的区间即为转换为转换后的值。）
2---源小区向UE下发RRC链接重配置信息
在UE上包测量报告后，源小区向目标小区发起“Handover Request”请求。目标小区收到请求后回应“Handover Request Acknowlege”，然后源小区向UE下发RRC连接重配置信息。
此时，消息将告诉UE的信息有：
告诉UE停止进行测量（MeasObjectToRemoveList）；
告诉UE目标小区PCI（mobilityControlInfo消息中）；
告诉UE目标小区相对频点号；
告诉UE目标小区载频带宽；
T304定时器（T304是连接模式下UE等待UE Capability Information Confirm的定时器，单位为毫秒默认设置为1S）；
无线资源配置
PRACH信道相关的配置信息参考如下表：
RRC Connection Reconfiguration还包含各个信道的配置信息，如PDSCH、PUSCH、PHICH、PUCCH、上行功率控制信息，以及小区通道数配置信息。
PDSCH- referencesignalpower为单个RE的参考信号的功率（绝对值），D=(P+60)*10，取值范围(-60…50) Step:0.1,单位dBm，如上图值为12，实际功率值为12/10-60= -58.8dBm。
P_B为包含小区RS的PDSCH的EPRE与不包含小区RS的PDSCH的EPRE的比值，取值范围enumerate(0,1,2,3)。
PUSCH信道相关配置信息如下表所示：
Antennalportscount为小区支持的天线端口数目，配置范围为0~2，分别对应的天线端口数目enumerate(1,2,4)。
3---UE向目标小区发RRC连接重配置完成
UE收到目标小区下发的重配消息后，按照消息内的要求进行重配，重配完成后对RRC Connection Reconfiguration消息的回应消息，无实质内容。
4---目标小区向UE下发RRC连接重配置信息
在UE向目标小区发RRC连接重配置完成消息后，若后台信令正常，则目标小区再次向UE下发RRC连接重配置信息，此次重配消息中包含了目标小区的邻区列表以及开测量（代替TDS中的测量控制）。
1、目标小区的频点、带宽、邻区配置数量和小区质量偏移 RRC Connection Reconfiguration信令首先提供给终端目标小区的频点、带宽、邻区配置数量和小区质量偏移。
AllowedMeasBandWidth表示可测量带宽，配置值范围为0~5，分别对应1.4M(6RB)，3M(15RB)，5M(25RB)，10M(50RB)，15M(75RB)，20M(100RB)。
NeighCellConfig值表示配置的邻区数目，为16进制数值。
Q_OffsetRange是频间偏移值，影响小区间重选的偏移值，配置值范围为0~30，分别对应的实际取值：enumerate(-24,-22,-20,-18,-16,-14,-12,-10,-8,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,8,10,12,14,16,18,20,22,24)dB
2、邻区信息及A3事件相关参数 在RRC Connection Reconfiguration中还包括把邻区信息、A3事件相关参数提供给终端，因而在TD-LTE系统里没有测量控制信令
上图所示，RRC Connection Reconfiguration还包含邻区列表信息，包括所有邻区的小区编号Cell ID、PCI、Q_Offset等信息。
另外，携带了A3事件相关的测量信息，包括如下信息：
A3_Offset表示触发A3事件的偏移量。
Hysterisis表示进行判决时迟滞范围，取值范围0~30，分别对应(0，0.5，…，15)dB，step 0.5dB。
Time to Trigger监测到事件发生的时刻到事件上报的时刻之间的时间差，其含义是只有当特定测量事件（如2a）条件在一段时间即触发时间（TimeToTrigger）内始终满足事件条件才上报该事件，取值范围0~15，对应的实际取值enum(0, 40, 64, 80, 100, 128, 160, 256, 320, 480, 512, 640, 1024, 1280, 2560, 5120)ms。上图配置为8对应320ms。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/100b04f0c6c550009c7126d4c9629ac2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/270e0a7cf81bbcc73f33c5d7587cca68/" rel="bookmark">
			JPA：Spring Data JPA     @OneToMany级联，多方删除修改新增总结（尤其删除操作:添加注解属性orphanRemoval在下一篇解释删除）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一方维护关系体现在更新多方中的外键字段。
一方在oneToMany上设置的级联保存和更新很好理解，多方会随着一方进行保存和更新。但是级联删除其实只是指一方删除时会把关联的多方数据全部删除，并不能删除一方维护的多方list中remove掉的数据。所以本文所讨论的实验和是否设置级联删除是没有关系的。
本文基于实验，我们先设定有如下对象，User为一方，ContactInfo为多方。每个user有多个contactInfo。
所做的操作是先查询User，然后对关联的ContactInfo做增删改。
public class User { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String userName; private String password; @Fetch(FetchMode.SUBSELECT) @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY) @JoinColumn(name = "user_id") private List&lt;ContactInfo&gt; contactInfos = new ArrayList&lt;&gt;(); } public class ContactInfo { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String phoneNumber; private String address; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = "user_id") @JsonIgnore private User user; } 一对多关系，通过@onToMany注解实现，此注解有个属性mappedBy，这个属性默认为空（上面示例代码未设置，取默认值），代表一方要维护关系。如果mappedBy设置为一方对象的值，如mappedBy = "user"，代表一方放弃维护关系，具体表现就是在插入或者删除操作的时候，一方不会去update多方的外键。这在后面的实验中会有所体现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/270e0a7cf81bbcc73f33c5d7587cca68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1343242e9b299581f2ba2e3f5314d8d4/" rel="bookmark">
			win10怎样永久设置护眼颜色，注册表改了以后重新开机又回到了原来的颜色，怎样才能永久设置，求救？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://zhidao.baidu.com/question/2142445980368027508.html
我猜你应该只修改了一处注册表，网上的教程多数只提到一处，所以系统就冲突了
请参考以下步骤：
1.win+r，输入regedit
2.定位：HKEY_CURRENT_USER\Control Panel\Colors ，找到Windows
3.双击，更改数值：199 237 204（绿豆色，可根据您的个人爱好调整色号）
4. 定位：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes\DefaultColors\Standard，找到Windows
5.双击Windows，更改数值：caeace，选择：十六进制
6.重启电脑
但由于系统本身设定的原因， 有些系统活动界面的背景色无法更改。
希望以上信息能够帮助到您。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df625be02414146fec21517510c5e3e5/" rel="bookmark">
			Linux的/var/www/html目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 给CDH添加入Flink、Kylin等组件的时候，需要把下载Flink的Parcel放在/var/www/html目录下，把文件放到这个目录下就可以通过IP很方便的访问，比如我在/var/www/html目录下创建/flink-1.9.0文件，并把Parcel文件放在该目录，然后就可以通过浏览器访问了
如何访问 http://[ip]/flink-1.9.0 我第一次访问的时候，出现了一个低级的错误，由于公司并没有把该ip对应的默认端口80打开，因此无法访问，打开以后在浏览器中直接输入ip回车，可以看到如下图：
然后再次切换到flink-1.9.0文件夹则可以访问到了：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db007f77dd6ee1e88a6b13aeafeba0af/" rel="bookmark">
			使用快照的方式把一个elasticsearch集群的数据迁移到另一个elasticsearch集群上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：把elasticsearch5.5集群的数据迁移到elasticsearch6.5的集群上
1.安装sshfs 在elasticsearch集群上的节点都要安装sshfs服务，过程如下：
1.1 下载安装包 wget http://ftp.tu-chemnitz.de/pub/linux/dag/redhat/el7/en/x86_64/rpmforge/RPMS/fuse-sshfs-2.5-1.el7.rf.x86_64.rpm yumdownloader fuse-libs yumdownloader fuse 注：
如果只想通过yum下载软件的安装包，但是不需要进行安装的话，可以使用 yumdownloader 命令。 yumdownloader 命令在软件包 yum-utils 里面。 先安装 yum-utils: yum install yum-utils -y 通过以上的命令可以得到如下安装包：
1.2 安装 命令如下：
rpm -Uvh fuse-libs-2.9.2-6.el7.x86_64.rpm rpm -Uvh fuse-2.9.2-6.el7.x86_64.rpm rpm -ivh fuse-sshfs-2.5-1.el7.rf.x86_64.rpm 2. 在一个elasticsearch的操作（例如es5.5） 2.1 前期准备 # 设置共享目录 # 选一个节点创建备份目录/data/backup，确保目录大小足够备份，这里选择了idr03 mkdir -p /data/backup chown -R es:es /data/ chmod -R 777 /data # 在所有Elasticsearch5.5节点创建挂载目录 mkdir /mnt/backup # 将所有挂载目录的所属用户及用户组修改为Elasticsearch用户 chown -R es:es /mnt/backup chmod -R 777 /mnt/backup # 各个Elasticsearch5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db007f77dd6ee1e88a6b13aeafeba0af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f792a045c9904245d522dc14f7db97/" rel="bookmark">
			IBM服务器诊断面板LED指示灯详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		诊断面板板LED指示灯目录 Light Path Diagnostics（光径诊断系统）：（1）REMIND:（2）OVER SPEC：（3）LOG:（4）LINK:(5)PS:(6)PCI:(7)SP:(8)FAN:(9)TEMP:(10)MEM:(11)NMI:(12)CNFG:(13)CPU:(14)VRM:(15)DASD:(16)RAID:(17)BRD: Light Path Diagnostics（光径诊断系统）： （1）REMIND: 提醒按钮
您可以使用光通路诊断面板上的提醒按钮，将操作员信息面板上的系统错误指示灯置于提醒方式。当您按下提醒按钮时，您对错误进行了肯定应答，但表明不会立即采取操作。处于提醒方式时，系统错误指示灯闪烁，并且在出现以下任何一种情况之前，它都保持提醒方式： a.已纠正所有已知的错误。 b.服务器重新启动。 c.发生了新的错误，造成系统错误指示灯再次点亮。
（2）OVER SPEC： 超过规格 由于电源通道之一上的电源过载情况，服务器已关闭。电源使用的功率超过其最大额定值。 如果系统板上的任何12v电源通道错误指示灯（A，B，C，D，E或240v AUX）也点亮。（有关12v电源通道错误LED的位置，请参阅主板 LED。）
检查电源LED上是否有错误指示（AC LED和DC LED均未点亮，或者电源错误LED点亮）。相互交换电源1和2。
如果错误是由电源引起的，（仅限经过培训的维修技术人员）请更换发生故障的电源。
如果电源托架仍然存在错误，请（仅限经过培训的技术服务人员）更换主板。
（仅限经过培训的维修技术人员）从服务器上卸下可选设备。
（3）LOG: 日志 错误消息已写入系统日志 有关错误的详细信息，请参见系统日志。
（4）LINK: 链接 SMP扩展端口或SMP扩展电缆存在故障（需要启用可扩展性）。
(5)PS: 电源 电源故障。 检查电源LED上是否有错误指示（AC LED和DC LED均未点亮，或者电源错误LED点亮）。
（仅限经过培训的维修技术人员）请确保已正确安装故障电源。
（仅限经过培训的维修技术人员）彼此交换电源1和2。
如果错误跟随电源，请更换发生故障的电源。
如果电源托架仍然存在错误，请（仅限经过培训的技术服务人员）更换主板。
(6)PCI: PCI接口 PCI总线或系统板上发生错误。发生故障的PCI插槽旁边的指示灯将点亮。 检查PCI插槽上的LED，以识别引起错误的组件。
检查系统错误日志以获取有关错误的信息。
（仅限经过培训的维修技术人员）如果无法通过指示灯和系统错误日志中的信息隔离出现故障的适配器，请一次从发生故障的PCI总线中删除一个适配器，并在删除每个适配器后重新启动服务器。
致电下一级支持。
(7)SP: SP 服务处理器（IMM）发生故障。 （仅限经过培训的服务技术人员）断开服务器电源；然后，重新连接服务器电源并重新启动服务器。
在IMM上更新固件。
致电服务。
(8)FAN: 风扇 风扇出现故障，运行速度太慢或已卸下。TEMP LED也可能点亮。 （仅限经过培训的技术服务人员）更换出现故障的风扇，该风扇由系统板上风扇连接器附近的点亮的LED指示。
(9)TEMP: 温度 系统温度超过阈值水平。风扇故障可能导致TEMP LED点亮。 检查错误日志，以确定在何处测量了过热情况。如果风扇发生故障，请更换它。
确保室温不要太高。
确保通风孔未被堵塞。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86f792a045c9904245d522dc14f7db97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31e782a459727e0a34dfe9bf60f74e08/" rel="bookmark">
			使用pyinstaller打包遇到的错误---Failed to execute script pyi_rth_certifi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在用pyinstaller打包python文件时，遇到如下错误：
Failed to execute script pyi_rth_certifi 不能执行 pyi_rth_certifi脚本，作为小白的我在site-packages文件夹里找到这个脚本后也看不懂什么问题，最后在绝望中从anaconda的虚拟环境中用pyinstaller打包后成功了。
最开始因为我有三个.py程序，以及会使用到data文件夹的数据txt文件，和star图标，胡乱用了pyinstaller中的 -p 、–hidden-import这些命令
后面发现那些命令都是不需要使用的，直接在cmd中使用下面的命令就好了。
pyinstaller geduo.py geduo.py为我的主程序。然后会生成dist文件夹和build文件夹，最后把data文件夹以及star图标复制到dist文件夹中的geduo文件件下就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d754c8ce779a7de08c159fe15b23fd1e/" rel="bookmark">
			在VS2015安装RDLC报表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转：https://www.cnblogs.com/JuneZhang/p/7492994.html
系统重装了，用到微软自带的RDLC报表,但是在VS2015张找了一圈也没找，难道是我VS版本 不支持，在网上查了下，有的人说VS2015社区版，企业版不支持，只有专业版支持，各说不一，想想不科学呀，微软自带的报表之前的版本都支持呀。自己又在找各种资料，终于找到了，原来VS2015 默认安装里面Microsoft SQL Server Data Tools 没有勾选，只需勾选Microsoft SQL Server Data Tools 安装即可，如下图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eadba712a0f6afa9095a1bb617d511c/" rel="bookmark">
			Prometheus源码系列：指标采集(scrapeManager)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指标采集(scrapeManager)简介 从上篇文章：Prometheus源码系列：服务发现 (serviceDiscover)，我们已经知道，为了从服务发现(serviceDiscover)实时获取监控服务(targets)，指标采集(scrapeManager)通过协程把管道(chan)获取来的服务(targets)存进一个map类型：map[string][]*targetgroup.Group．其中，map的key是job_name，map的value是结构体targetgroup.Group，该结构体包含该job_name对应的Targets，Labels和Source．
指标采集(scrapeManager)获取服务(targets)的变动，可分为多种情况，以服务增加为例，若有新的job添加，指标采集(scrapeManager)会进行重载，为新的job创建一个scrapePool，并为job中的每个target创建一个scrapeLoop．若job没有变动，只增加了job下对应的targets，则只需创建新的targets对应的scrapeLoop．
为本文分析的代码都基于版本 v2.7.1，会通过dlv输出多个参数的示例，所用的配置文件：Prometheus.yml配置文件示例．
指标采集(scrapeManager)实时获取监控服务 指标采集(scrapeManager)获取实时监控服务(targets)的入口函数：scrapeManager.Run(discoveryManagerScrape.SyncCh())：
prometheus/cmd/prometheus/main.go // Scrape manager. g.Add( func() error { // When the scrape manager receives a new targets list // it needs to read a valid config for each job. // It depends on the config being in sync with the discovery manager so // we wait until the config is fully loaded. &lt;-reloadReady.C err := scrapeManager.Run(discoveryManagerScrape.SyncCh()) level.Info(logger).Log("msg", "Scrape manager stopped") return err }, func(err error) { // Scrape manager needs to be stopped before closing the local TSDB // so that it doesn't try to write samples to a closed storage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eadba712a0f6afa9095a1bb617d511c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b17bbf8cd8815063363ceca36707a71/" rel="bookmark">
			MVG（second）学习笔记- 摄像机模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 摄像机是3D世界到2D图像之间的一种映射。本部分总结一下单目摄像机基本针孔模型和理论推导，畸变：
目录
1.基本概念
2.相机模型
3. 畸变模型
4.摄像机矩阵P
注意：成像平面放于相机主平面前面主要是便于建立数学模型 1.基本概念 光心：投影中心O为摄像机中心，也成为了光心。
主轴：摄像机中心到图像平面的垂线称为摄像机的主轴或主射线。
主心：主轴和图像平面的交点为主心
主平面：过摄像机中心且平行于图像平面的平面称为摄像机的主平面
图像坐标系：如图（u-v）
世界坐标系：如图（o-x-y-z）
摄像机坐标系：如图 世界坐标系(Ow-x-y-z)
f为焦距
2.相机模型 坐标系量的标记：
1 世界坐标系：Pw(Xw,Yw,Zw) 2 2 摄像机坐标系：P(X,Y,Z) 3 . 图像坐标系 Puv(u,v) : 世界坐标系： 分为过程： 1.摄像机坐标系的透视变换 到图像坐标系的变化 2.摄像机坐标系到世界坐标系的变化 总的变换： 3. 畸变模型 图像畸变是由于透镜制造精度以及组装工艺的偏差会引入畸变，导致原始图像失真。镜头的畸变分为径向畸变和切向畸变两类。
主要分为径向和切向畸变 径向畸变是由于镜头自身凸透镜的固有特性造成的，产生原因是光线在远离透镜中心的地方比靠近中心的地方更加弯曲。
畸变沿着透镜半径方向分布，主要包括桶形畸变和枕形畸变两种，如下图所示：
畸变的数学模型可以用主点（principle point）周围的泰勒级数展开式的前几项进行描述，通常使用前两项，即k1和k2，对于畸变很大的镜头，可以增加使用第三项k3来进行描述：
切向畸变是由于透镜本身与相机传感器平面（成像平面）或图像平面不平行而产生的，这种情况多是由于透镜被粘贴到镜头模组上的安装偏差导致。
畸变模型可以用两个参数p1和p2来描述：
加畸变采用上面的公式即可 去畸变推荐opencv函数 https://blog.csdn.net/KYJL888/article/details/81043133 所以摄像机矩阵： 内参为11个：fx,fy,cx,cy,k1,k2,k3,p1p2 外参为6个： R(3),t(3) 4.摄像机矩阵P 参考：
1.视觉SLAM 14讲
2.MVG（计算机多视几何）第二版
X w Y w Z w , , X c Y c Z c , , [ u , v ] [ x , y ] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/464c0bfb2575efdf45d8f76c89afd2ec/" rel="bookmark">
			spring的面向切面编程AOP最强解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向切面编程 AOP 也就是面向横切面编程, 在软件原有流程中横向织入扩展功能代码, 在不改变原有功能的情况下扩展横切功能.
生活中的横切面功能: 面向切面编程解决的横切问题: 面向切面编程中的关键概念: 切面组件通知切入点运行期间织入 1. 切面组件 切面组件本身也是一个被Spring管理的Bean组件, 这个组件用于封装面向切面的功能扩展方法.
在软件中执行切向功能的组件. 是一种"拦截器"组件.
案例:
@Component @Aspect public class DemoAspect { //通知(切入点) 通知+切入点=织入位置 @Before( "execution(* cn.tedu.note.service.*Service.*(..))") public void hello(){ System.out.println("Hello World!"); } } 使用如上功能必须导入 AspectJ 相关的包, Spring提供的AOP功能是利用 AspectJ 的API实现的.
&lt;dependency&gt; &lt;groupId&gt;aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjlib&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; 2. 通知 用于指定发生切向事件的位置点:
通知有如下几种:
@Before @AfterRetuning@AfterThrowing@After@Around 其在方法的切位置关系如下: try{ // @Before 切入点 方法 // @AfterRetuning }catch(e){ // @AfterThrowing }finally{ // @After } @Around 通知, 是在方法前后调用的通知:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/464c0bfb2575efdf45d8f76c89afd2ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5d44611244e088b73c905b4d50b1656/" rel="bookmark">
			【Java】- Incompatible types. Found: java. lang. String&#39;, required:&#39; byte, char, short or int&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA项目编译报错：Incompatible types. Found: java. lang. String’, required:’ byte, char, short or int’，switch语句，提示编译失败，类型错误，不支持字符串类型；
错误原因：
java的语言级别没有设置好导致的问题，也就是说JDK版本不兼容
解决方案：
首先确认电脑安装JDK版本，jdk1.7之前的版本是不支持switch的字符串类型的
检查工程配置JDK版本：File-&gt;Project Structure-&gt;Project,然后具体操作如下图，之前创建项目没有进行JDK配置，默认使用的是5.0-‘enum’keyword,generics,autoboxing etc.所以是不支持switch字符串类型的，电脑安装的是JDK1.8，我们设置成相对应的版本就可以啦；
查看项目Modules的配置，Language level与Dependencies配置，将这两项配置成一致的版本
检查并设置完以上内容，运行项目我们会发现又出现新的编译错误：Error:java: Compilation failed: internal java compiler error，提示Java编译错误
这时候我们需要去检查Java Compiler配置项：
File-&gt;Other Settings-&gt;Default Settings-&gt;Build,Execution,Deployment-&gt;Compiler-&gt;Java Complier，可以直接搜索Java Coplier:
设置完以上内容，运行项目成功，开发还是要养成一个良好的习惯的，引入一个新项目，引入项目后就应该先去检查检查版本配置是否一致性问题，而不是等问题出现了，才想起来版本的问题。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10c7daf2d8a7bdc2fd06c762fef4739b/" rel="bookmark">
			java.lang.String 的 &#43; 号操作到底做了什么事情？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击蓝色“架构文摘”关注我哟
加个“星标”，每天上午 09:25，干货推送！
在之前的面试经历中，对于String的考察还是挺频繁的，大致考察以下几个知识点：
String 常量池
new String()
== 和 equals 的区别
native 方法 String.intern()
虽然面试中大体答对了，但是今天早上微信群里的一个问题我却答不上来，这个问题是这样的：
String str3 = "what"; String str4 = str3 + " a nice day"; //运行时， + 相当于 new，所以堆中会有 "what a nice day"对象，常量池中会有"what"," a nice day"两个对象，而不会有 "what a nice day"对象。 //这句话大佬们看看对不对啊，我怎么感觉不对啊 //常量池不会有"what a nice day" 对象吗？ 看完这个问题，说实话我也是有点懵的，我只是知道 "what a nice day"不会在常量池，但是不知道具体的原因，后来群里的同学说 + 号是调用了 StringBuffer 的append 方法。我去证实了，发现确实调用了 append 方法，但是当时没有 调用toString()方法，我很疑惑。（最后经过证实，是StringBuilder的append 方法，不是StringBuffer）。
代码验证 public static void main(String[] args) { //#1 String str1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10c7daf2d8a7bdc2fd06c762fef4739b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9cf86d9f380f5b5f03e1a9425dcd7df/" rel="bookmark">
			RFBNet 代码复现笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RFBNet 代码复现笔记 1.准备工作 （1）下载RFBNet
git clone https://github.com/ruinmessi/RFBNet 环境配置需要pytorch0.4.0和python3+，网上有安装方式，不做赘述
（2）编译
cd RFBNet ./make.sh 编译时注意修改make.sh文件，cuda 的路径要与自己安装路径相同，python版本要对应python3以上。
作者提到在 utils/build.py 里面需要根据自己电脑的GPU算力修改对应的值，不知道具体算力值的可以百度，有详细的说明。
(4)准备数据集
代码复现支持两种数据集，分别是VOC和COCO，下载过程如下:
cd RFBNet sh data/scripts/VOC2007.sh #该文件将VOC2007数据集自动下载整理好，但下载速度慢，建议自行下载 sh data/scripts/VOC2012.sh #该文件将VOC2012数据集自动下载整理好，但下载速度慢，建议自行下载 COCO数据集较大，建议自行下载，可以使用迅雷之类的下载工具，速度比较快。
2.训练 （1）预训练模型下载
mkdir weights cd weights wget https://s3.amazonaws.com/amdegroot-models/vgg16_reducedfc.pth （2）训练
python train_RFB.py -d VOC -v RFB_vgg -s 300 -d 选择数据集，VOC，或者COCO
-v 选择主干网络的类型，RFB_VGG, RFB_E_VGG ，RFB_mobile
-s 输入图片的尺寸，300或512
在训练过程可以指定从断点继续训练，只要指定训练权重即可。
作者代码不提供可视化检测结果，这个有点伤。
3.评估 python test_RFB.py -d VOC -v RFB_vgg -s 300 --trained_model /path/to/model/weights 默认评估的是VOC2007或者COCOtminival2014 的测试集，想要评估其他的数据集，修改test_RFB.py
训练好的权重：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9cf86d9f380f5b5f03e1a9425dcd7df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45322826b930f0bec250cab15ae5f220/" rel="bookmark">
			22. flowable 驳回 回退 并行网关驳回  多实例驳回 子流程驳回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目地址：https://gitee.com/lwj/flowable.git 分支flowable-base
视频讲解地址 https://www.bilibili.com/video/av78779999/
驳回：当前处理人可以驳回历史走过的任何一个节点
1、驳回任意普通节点
2、驳回多实例节点
3、驳回并行网关节点
4、驳回子流程节点
5、子流程节点驳回主流程节点
实际情况中，为了获取可驳回的节点列表，我们做了一些规定，比方说并行网关节点，要求必须成对出现，也只能驳回到并行网关节点的 fork节点
一、演示 由于情况很多，截图反而不能重点讲述驳回的事情，这里只截一张图，如果想看详情请查看视频里面的讲解
二、代码分享 2.1 获取可驳回节点
public List&lt;FlowNodeVo&gt; getBackNodesByProcessInstanceId(String taskId,String processInstanceId) { List&lt;FlowNodeVo&gt; backNods = new ArrayList&lt;&gt;(); TaskEntity taskEntity = (TaskEntity) taskService.createTaskQuery().taskId(taskId).singleResult(); String currActId = taskEntity.getTaskDefinitionKey(); //获取运行节点表中usertask String sql = "select t.* from act_ru_actinst t where t.ACT_TYPE_ = 'userTask' " + " and t.PROC_INST_ID_=#{processInstanceId} and t.END_TIME_ is not null "; List&lt;ActivityInstance&gt; activityInstances = runtimeService.createNativeActivityInstanceQuery().sql(sql) .parameter("processInstanceId", processInstanceId) .list(); //获取运行节点表的parallelGateway节点并出重 sql = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45322826b930f0bec250cab15ae5f220/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fba730257fc2a9c9d973b5fa10715b4d/" rel="bookmark">
			Wonderware-InTouch 弹窗输入密码二次确认执行动作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在设备运行过程中，为了避免操作失误，我们会增加二次确认按钮，例如执行启停风机或者电机水泵时，会弹出小窗口提示你是否确认执行此动作，一般会在弹窗里面增加“是”和“否”两个按钮。
还有一种情况就是限制人员操作，使用输入密码的方式去执行动作，一般只有高权限的人才能使用此功能，保证动作的安全性。如下视频所示：
需要进一步了解方法的可以访问下面学习：
Wonderware-InTouch 弹窗输入密码二次确认执行动作
Intouch-弹窗输入密码、二次确认执行动作学习
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc7a3b213a85c1d8531963c78f851991/" rel="bookmark">
			Wonderware-InTouch历史报警、操作记录导出为Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Intouch自身的历史记录控件为AlmDbViewCtrl,可以查询历史报警和操作记录。我们需要在控件向导中拉出时间控件DTPicker，选择时间，关键字等，即可查询想要的结果，这些需要编写程序去实现。
显示时： #DTPicker9.value = $DateString; #DTPicker10.value = "00:00:00"; #DTPicker11.value = $DateString; #DTPicker12.value = "23:59:59"; #AlmDbViewCtrl2.SpecificTime = 1; #AlmDbViewCtrl2.StartTime = StringMid(#DTPicker9.value,6,2) + "/" + StringMid(#DTPicker9.value,9,2) + "/" + StringMid(#DTPicker9.value,1,4) + " " + #DTPicker10.value; #AlmDbViewCtrl2.EndTime = StringMid(#DTPicker11.value,6,2) + "/" + StringMid(#DTPicker11.value,9,2) + "/" + StringMid(#DTPicker11.value,1,4) + " " + #DTPicker12.value; #AlmDbViewCtrl2.Refresh(); 查询： #AlmDbViewCtrl2.SpecificTime = 1; #AlmDbViewCtrl2.StartTime = StringMid(#DTPicker9.value,6,2) + "/" + StringMid(#DTPicker9.value,9,2) + "/" + StringMid(#DTPicker9.value,1,4) + " " + #DTPicker10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc7a3b213a85c1d8531963c78f851991/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bf4489783ef1b9df4caddb13927dd30/" rel="bookmark">
			Wonderware-InTouch用脚本实现*邮件*发送功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景介绍： 随着客户对生产自动化，信息自动化，管理自动化的要求越来越高，在【intouch】行业，上至管理层，下至基层员工有一些迫切的需求，他们希望【intouch】不仅可以实现远程监控和操作，同时可以远程实时关注现场设备的运行状态，当设备发生报警的时候【intouch】会自动将报警信息以邮件的形式立刻发送到相关人员手上，并且可每日将生产报表以附件的形式邮件发送。
实现途径： 但要实现【邮件】发送的功能，往往会想到购买专门的上位机邮件发送软件，或者开发第三方邮件发送的接口软件，这些都要花费很多费用和时间来完成。
然而，【intouch】具有大量不为人知的隐蔽功能，一般的使用者是绝不会发现的。它本身无需任何插件，只通过自身脚本函数就轻松实现了邮件的实时发送，并且没有邮件数量限制。
【intouch】实现【邮件】内容发送仅仅是第一步，还要对邮件的格式进行排版，这样的话，客户收到的报警/报表邮件会有一种很专业的感觉，有利于突出重点内容。
发送邮件对于Intouch来说很少被用到，只有在特殊时候客户要求才会使用，更多的只是功能上的点缀。并且此功能也非常隐蔽，一般是个不会被人所知的无名Function.
在这里只讲三种方法，前两种方法是基于SMTP服务的，后一种方法是借用外部语言结合使用的。可用此进行自我发育，融会贯通，举一反三，做出适合自己的符合项目要求的实现起来更加丰富的发送更快的邮件功能。
方法一: 使用 SendMail()函数，配置Outlook邮箱
配置Outlook邮箱账户，填写发件人的邮箱地址。
SendMail()是Intouch的控件函数，编辑如下脚本即可实现：
实现原理是，将需要发送的内容写进txt文件里面，然后发送txt文件到邮箱，在邮箱里面看到的就是txt文件的内容，并没有附件。图片中显示txt文件里面的第一行信息成为了邮件的标题，下面几行的信息是邮件的内容
收到的邮件内容如图：
方法二: 使用 SendSMTPMail()函数，SendSMTPClearConfig()函数，SendSMTPConfig()函数
实际上这是同时发送邮件给两个收件箱。
收到的邮件内容如图：
方法三: 使用 VBS消息脚本
新建一个后缀为.vbs的文件
内容为：
在Intouch中通过脚本来执行此VBS文件，即可发送邮件。
startapp "D\REPORT.TXT"；
前两种方法都需要依靠两个文件以提供函数支持：WWTechSp.dll和WWTechSp.wdf 放入到intouch的安装目录下即可使用。并且这三种方法都需要事先将邮件信息写入到txt文档中才能发送，可能也不限于.txt格式的文档。
以上就是Intouch发送邮件的基本方法了，仅用此原理当然不能做出好的功能来，需要在此基础上添砖加瓦，比如内容排版，颜色，字体等都可以设置。
Wonderware-InTouch用脚本实现*邮件*发送功能
相关的视频学习教程可进入下面链接自主学习：
Intouch-脚本实现邮件发送功能课程学习
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/284caf602830c4c7f092701bbe5a0f81/" rel="bookmark">
			什么是 LTV / CAC?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LTV 是客户终身价值，CAC 是客户获取成本， LTV / CAC 为二者的比值。
客户终身价值（LTV：Life time Value)：有时被称为客户全生命周期价值，指的是每个用户（购买者、会员、使用者）在未来可能为该服务带来的收益总和。
客户获取成本(CAC：Customer Acquisition Cost)：是获得单个客户的平均费用。
② 为什么要计算 LTV / CAC？
LTV / CAC 是一个计算效率的关键工具，即销售和市场营销漏斗。它通过提出一个简单的问题：一个客户的价值（LTV）是否大于获取该客户的成本（CAC）？来帮助创始人和投资者解决以下问题：
尽管这家公司像大多数 SaaS 公司一样正在亏损，未来它会扭亏为盈吗？
进入市场战略是否有效、全面以及带来边际效应？何时/何处投更多的钱到销售和营销中？应该在销售和营销中投入多少资金？哪种客户、产品、业务种类等是最盈利的？ 计算CAC的方法比较简单如下：
CAC=市场总花费/同时期新增用户数
市场总花费一般包括推广渠道花费，营销和销售的总费用，甚至包括所有市场，运营人员的人力成本，这里只要把我们付出的成本都算进去就好。
LTV的计算方法为：
如何有效计算LTV和CAC？
其中LT为用户的平均生命周期，ARPU(Average Revenue Per User) 为用户在平均生命周期中的平均收入。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f52906102ec7c60a067aaa2447a2d0f/" rel="bookmark">
			linux下tomcat无法访问中文路径或中文文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置tomcat，配置conf文件夹下server.xml文件，加入 URIEncoding="UTF-8" 如下
&lt;Connector port="80" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" URIEncoding="UTF-8" /&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bcc9a1747c52f72a15b23279114b6b2/" rel="bookmark">
			free -h 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、命令 free -h
2、参数详解 total: 内存总数
used: 已经使用内存数
free: 完全空闲内存
shared: 多个进程共享的内存
buffers: 用于块设备数据缓冲，记录文件系统metadata（目录，权限，属性等)
cached: 用于文件内容的缓冲
available：真正剩余的可被程序应用的内存数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cf7ea0a9427eff0ced1ae7bdfd04da5/" rel="bookmark">
			three.js DragControls 移动整个模型 group
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近天天有人问这个问题啊
打开DragControls.js 改案例的话主意好你用的是jsm还是js里的
//第122行找到这个事件 function onDocumentMouseDown( event ) { event.preventDefault(); _raycaster.setFromCamera( _mouse, _camera ); var intersects = _raycaster.intersectObjects( _objects, true ); if ( intersects.length &gt; 0 ) { //从这射线返回的mesh上获取上级的group //如果多层group嵌套需要递归到最上层 _selected = intersects[ 0 ].object.parent;//这里加上.parent console.log(_selected); if ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) { _inverseMatrix.getInverse( _selected.parent.matrixWorld ); _offset.copy( _intersection ).sub( _worldPosition.setFromMatrixPosition( _selected.matrixWorld ) ); } _domElement.style.cursor = 'move'; scope.dispatchEvent( { type: 'dragstart', object: _selected } ); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/973f25a80c249e95d493a0b8186ee912/" rel="bookmark">
			使用本地浏览器打开远程服务器上的Jupyter Notebook
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在github找到一些工程的代码都是.ipynb格式的文件，就好奇这个JupyterNotebook格式可以直接运行吗，还是需要另存成本地常见的格式，就查了一下，发现是可以的，这里记录一下。
主要思路：
（假设你的服务器上已经安装好了Jupyter Notebook）
配置Jupyter notebook 1. 服务器端安装Anaconda， 安装好jupyter notebook 等等 2. 生成jupyter notebook配置文件 jupyter notebook --generate-config 3.配置密码 打开python，输入指令：
from notebook.auth import passwd passwd() 输入自己想要设置的密码，之后会自动生成一个密码序列，复制下来。
4.配置密码生成ssl证书（最后用https登录） openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mykey.key -out mycert.pem 5.修改jupyter配置文件 打开第2步生成的配置文件，一般是在~/.jupyter
打开配置文件：
vi ~/.jupyter/jupyter_notebook_config.py 对以下几行做如下修改：
c.NotebookApp.password=u'sha1：XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX' // (注：XXXXXXXXXXXXXXXXXXXXXXX 为第3步中生成的密码序列) c.NotebookApp.certfile = u'/absolute/path/to/your/certificate/mycert.pem' c.NotebookApp.keyfile = u'/absolute/path/to/your/certificate/mykey.key' //（注：为第4步中生成的mycert.pem和mykey.key两个文件的绝对路径，可用pwd查看） c.NotebookApp.ip = '*' c.NotebookApp.open_browser = False c.NotebookApp.port = 8889 //自己可以设定成别的 :wq!保存并退出
6. 在服务器上运行jupyter Notebook 在服务器端打开监听端口：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/973f25a80c249e95d493a0b8186ee912/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68fb3211692edab604db509c525a5e01/" rel="bookmark">
			python变量的作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作用域又可以被称为命名空间，指变量起作用的范围。Python变量作用域可以分为四种，分别为局部作用域、嵌套作用域、全局作用域、内置作用域。
作用域英文简写局部作用域LocalL嵌套作用域EnclosedE全局作用域GlobalG内置作用域Built-inB 四种作用域中变量的调用顺序采取“就近原则”，即为 LEGB
局部作用域 指某个函数内部的范围。每次执行函数时都会创建的新命名空间，同一函数不同时间运行其作用域相互独立，不同函数内部可以使用同一变量名。局部作用域内声明的变量名在函数外也可以使用，程序运行过程中两者互不干扰。
def myfun(): a = 0 # 局部变量 a += 1 print("myfun a = ", a) def myfun2(): a = [1, 2, 3] # 局部变量 a = [i + 1 for i in a] print("myfun2 a = ", a) a = 'Hello Python' # 此处a为全局变量 myfun() myfun2() print("函数外 a = ", a) 输出结果： myfun a = 1 myfun2 a = [2, 3, 4] 函数外 a = Hello Python 嵌套作用域 嵌套一般是指一个函数嵌套另一个函数的情况，外层函数包含变量的作用范围称为嵌套作用域；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68fb3211692edab604db509c525a5e01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d816234c7d055ed262818d16a859fd7/" rel="bookmark">
			各大洲时区以及Linux环境下修改时区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时区 整个地球被分为二十四时区，每个时区都有自己的本地时间。为了克服时间上的混乱，1884年在华盛顿召开的一次国际经度会议（又称国际子午线会议）上，规定将全球划分为24个时区（东、西各12个时区）。使用一个统一的时间， 称为通用协调时(UTC, Universal Time Coordinated)。UTC与格林尼治平均时(GMT, Greenwich Mean Time)一样，都与英国伦敦的本地时相同。
所以我们经常可以看到时间后面添加UTC的标识。而北京处于东八区的时区，所以北京使用常用UTC+8标识。同理对于西八区就会使用UTC-8进行标识。
ES中的时区转换
像是之前使用ES的日期格式转换的时候，尝试设置"timezone": "Asia/Shanghai"的时候会返回"2019-12-06T21:00:00.000+08:00"。
Linux中的时区 查看服务器时区
Linux中我们可以使用date -R查看本地时区。在结果中+0800表明此时使用的是东八区时区。
[root@**** etc]# date -R Mon, 09 Dec 2019 14:48:15 +0800 或者直接使用date查看的是CST的时区
[root@**** etc]# date Mon Dec 9 14:50:12 CST 2019 或者使用-u显示UTC时间，显示的是伦敦本地时间。
[root@**** etc]# date -u Mon Dec 9 07:00:54 UTC 2019 CST
所谓的CST时间代表四个不同的时区：
Central Standard Time (USA) UT-6:00 美国标准时间Central Standard Time (Australia) UT+9:30 澳大利亚标准时间China Standard Time UT+8:00 中国标准时间Cuba Standard Time UT-4:00 古巴标准时间 修改Linux时区
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d816234c7d055ed262818d16a859fd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e991b76b7e112a4d3e0da2a7a0c8a39/" rel="bookmark">
			numpy将矩阵中小于0的值换成0的实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 a is a matrix or an array
np.maximum(a, 0)(a+np.abs(a))/2a[a&lt;0]=0np.where(a &gt; 0, a, 0) a中大于0的用a中的元素不变，小于0的就用0补上b = np.float32(a&lt;=0)-1 np.float32(a&lt;=0)会将小于0的变成1，所以要换成0需要减去1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a07be202d4ba9e03693f26e2756331/" rel="bookmark">
			解决“Cannot fit requested classes in a single dex file”的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 编译时出现Cannot fit requested classes in a single dex file (# methods: 73436 &gt; 65536)的问题。
原因：项目貌似有点大，已经超过65k个方法。一个dex已经装不下了，需要个多个dex，也就是multidex ，因为Android系统定义总方法数是一个short int，short int 最大值为65536。
解决办法 ①、在 app 的 build.gradle 文件中
android { defaultConfig { ··· // 这里添加 multiDexEnabled true } } dependencies { // 引入support支持库的multidex库 implementation 'com.android.support:multidex:1.0.3' //或androidx支持库的multidex库 implementation 'androidx.multidex:multidex:2.0.1' } ②、在自定义的 application 中初始化 MultiDex
import android.app.Application; import android.content.Context; import androidx.multidex.MultiDex; public class MyApplication extends Application { @Override protected void attachBaseContext(Context context){ super.attachBaseContext(context); MultiDex.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2a07be202d4ba9e03693f26e2756331/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c039466e9ed4a60ace08e007d9362a4e/" rel="bookmark">
			iPhone安装企业包出现“无法验证证书”问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		企业包安装出现证书无法验证问题,不论重新启动,还是还原网络设置都无法解决,最终还原所有设置,重启手机,才解决
﻿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed1e9ead054a969b81ae1940db591b5e/" rel="bookmark">
			Java 8 Lambda 表达式（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例1、用lambda表达式实现Runnable 我开始使用Java 8时，首先做的就是使用lambda表达式替换匿名类，而实现Runnable接口是匿名类的最好示例。看一下Java 8之前的runnable实现方法，需要4行代码，而使用lambda表达式只需要一行代码。我们在这里做了什么呢？那就是用() -&gt; {}代码块替代了整个匿名类。
// Java 8之前： new Thread(new Runnable() { @Override public void run() { System.out.println("Before Java8, too much code for too little to do"); } }).start(); //Java 8方式： new Thread( () -&gt; System.out.println("In Java8, Lambda expression rocks !!") ).start(); 输出：
too much code, for too little to do Lambda expression rocks !! 这个例子向我们展示了Java 8 lambda表达式的语法。你可以使用lambda写出如下代码：
(params) -&gt; expression (params) -&gt; statement (params) -&gt; { statements } 例如，如果你的方法不对参数进行修改、重写，只是在控制台打印点东西的话，那么可以这样写：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed1e9ead054a969b81ae1940db591b5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff72e211ce06c30c06604e68ba70f758/" rel="bookmark">
			EPON缺点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.扩展性差：存在光衰问题，（一般6个节点）
2.可靠性差：存在单点故障，无冗余保护，无法满足高可靠性的业务转发。
3.二层互通不方便：ONU各端口、ONU之间都是隔离状态，保证安全的同时带来不能互访的问题（只能用性能更好的OLT，或增加eth三层交换机功能，或开启OLT代理，但成本会提高）
4.成本优势低：EPON设备价格高于常规以太网设备，成本优势只有在大型项目中体现，中小型不适用
5.灵活性差：IEEE802.3ah只规定MAC层和物理层，MAC以上需厂商自行开发，不同厂商不能对接，导致后期对设备厂商选择单一
6.系统开销大：效率低，采用8B/10B编码方式，效率只有80%。控制帧多，上行总开销约144Mbit/s,实际理论可用带宽856Mbit/s(即1000-144)
7.需预先计算上行带宽需求：上行带宽是所有ONU共享，采用TDMA（时分多址）技术，同时间只能有一台ONU上传数据。因为需计算好每条EPON主干链路，是否能满足所有节点的带宽需求
PS：
ONU：光网络单元提供数据、语音业务
OLT：光线路终端，用于连接光纤干线的终端设备，向ONU(光网络单元）以广播方式发送以太网数据
经典拓扑：PON—OLT—ONU
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55c8c44be074bed8150262037787b645/" rel="bookmark">
			彻底卸载Vscode安装的插件以及个人配置信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.删除安装的插件
2.删除一些用户信息和缓存信息
卸载vscode:
控制面板---&gt;程序---&gt;程序与功能：vscode---&gt;鼠标右键：卸载
但是这样卸载完之后，你再重新下载安装好vscode之后，会发现，之前下载的一些插件和配置过的信息还是会加载出来，所以还要再进行以下的步骤：
1.删除安装的插件 2.删除一些用户信息和缓存信息 执行完这两步，重新安装vscode，就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61a88675253ca0638cf48a2f69331335/" rel="bookmark">
			Python如何设置文件保存位置（txt文件保存位置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如想在当前目录下保存目标文档
那么在写with open操作的时候，按照如下方式写就可以了：
file_path = r"C:\Users\lenovo\Desktop\python\arithmetic\{}吧第{}页HTML内容.txt".format(self.tieba_name, page_number) with open(file_path, "w", encoding="utf-8") as f: f.write(html_str) 文件就会自动生成
效果如下：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/385/">«</a>
	<span class="pagination__item pagination__item--current">386/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/387/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>