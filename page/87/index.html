<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/372af2990c113d362b1db4fc3153ded7/" rel="bookmark">
			[论文阅读]H3DNet——基于混合几何基元的3D目标检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		H3DNet 3D Object Detection Using Hybrid Geometric Primitives
论文网址：H3DNet
总结 这篇论文提出了H3DNet,一个用于3D对象检测的端到端神经网络。该方法的关键创新点是预测一个混合的、过完备的几何基元集合(包括边界框中心、面中心和边中心),然后拟合检测到的对象以契合这些原语及其相关特征。主要贡献总结如下:
将对象检测表述为回归和聚合一个过完备的几何基元集合。预测适合不同对象类型和场景的多种几何基元。在ScanNet和SUN RGB-D数据集上实现了最先进的结果,仅使用点云输入。 具体来说,H3DNet包含三个模块:
几何基元模块:该模块对点云进行密集的点描述子计算,并预测三种几何基元,即边界框中心、面中心和边中心。提议生成模块:该模块将预测的几何基元转换为对象提议,关键是定义了一个距离函数来评估对象边界框和预测基元之间的距离。优化这个距离函数可以连续地优化对象提议。分类和调整模块:该模块对每个对象提议进行分类,并对检测到的对象进行调整,包括预测偏移向量来微调边界框参数和预测语义标签。该模块的关键是聚合与每个对象提议相关的几何原语的特征。 整个网络端到端训练。实验结果显示,与仅使用一种几何基元的方法相比,预测并聚合混合的过完备几何基元集合可以显著提高检测性能,特别是对于薄型或部分遮挡的对象。该方法在两个数据集上都获得了最先进的结果。
总之,本文的主要创新点是提出了使用过完备的混合几何基元进行3D对象检测的框架,并设计了对应的网络结构和优化目标。这种方法可容忍基元预测中的错误,并融合不同类型基元的优势,从而提高了检测性能。
网络前向传播过程 几何基元模块
(1) 使用基于PointNet++的网络backbone提取点云的稀疏点特征。这里使用了4个不同的backbone网络（使用4个不同backbone的目的是学习区分的特征描述子,来更好地预测不同类型的原语。）分别提取特征。
(2) 将4个backbone网络提取的特征拼接,并通过全连接层降维到256维。
(3) 分别输入到3个不同的Cluster Network中,预测点云中每个点到对应的原语(包括中心、面、边)的偏移向量。同时也预测每个点是否接近原语的flag。
(4) 根据偏移向量预测聚类得到原语的坐标,根据flag进行筛选。每个原语同时也得到一个256维的特征表示。
提议生成模块
(1) 利用原语的坐标和特征生成初始的对象提议bounding box。
(2) 定义目标函数计算每个初始提议与原语的距离,进行优化调整提议使其逼近原语。
(3) 保留不同的局部最优解作为最终对象提议。
分类和调整模块
(1) 对于每个对象提议,在其相关原语周围采样获取原语特征。
(2) 汇聚原语特征并与对象中心特征拼接,输入全连接网络。
(3) 网络输出对象标记、边界框参数调整量和语义标签。
(4) 根据对象标记筛选出最终检测结果。
整个网络端到端训练,通过定义针对每个模块的损失函数进行监督。
摘要 本文引入了H3DNet，它以无色点云作为输入，输出定向对象边界框及其语义标签的集合。H3DNet的关键思想是预测一组混合的几何基元（边界框中心，边界框面中心和边界框边中心）。
结论 本文介绍了一种新颖的3D目标检测方法，该方法将3D场景作为输入，输出一组带标签和定向的边界框。关键思想是预测一组混合几何基元，然后将检测到的对象拟合到这些几何基元及其相关特征上。
未来希望该方法应用在其他3D场景理解任务上，例如实例分割和CAD模型重建。另一个未来的方向是集成更多的几何基元，例如边界框的角，等等。
引言 目标检测是计算机视觉识别中的一个基本问题。本项工作的目标是从3D点云中检测对象（即定向3D边界框和相关语义信息）。
挑战：点云数据的不规则性以及不同场景中目标的数量不同。
关键：选择合适的中间表征，将低层次的物体线索整合到检测到的物体中，是决定系统性能的关键。
早期的工作是对滑动窗口进行分类，判断该区域是否包含感兴趣的目标物体（效率低）。最近的工作[Three-dimensional object detection and layout prediction using clouds of oriented gradients-2016, Multi-view 3d object detection network for autonomous driving-2017， 2d-driven 3d object detection in RGB-D images-2017， Frustum pointnets for 3d object detection from rgb-d data-2018， VoxelNet-2018]显示，设计端到端的神经网络用于生成，分类和细化目标提议有巨大的前景。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/372af2990c113d362b1db4fc3153ded7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53a104e8c3b7855b52b5c410f8bf97a3/" rel="bookmark">
			react-路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端路由 前端根据不同的地址，对应渲染不同的组件或页面。
前端路由一般分为两种：
hash:以#代表hash值，这个给浏览器识别，根据这个hash值来切换显示不同的内容，这个hash值不会发送给后端，能够兼容低版本的浏览器。
http://localhost:8000/#/login history：相比于hash路由，history路由更好看，它会发送给服务端，如果前端的路由和后端服务器的路由一样的话，那么会访问服务器路由，上线后需要后端配合才能使用。
http://localhost:8000/login react路由的安装 react本身没有提供路由，我们需要安装第三方插件react-router-dom
react路由v6版本地址：https://reactrouter.com/en/6.8.1/start/overview
v5版本地址：https://v5.reactrouter.com/
v6版本更偏向于函数式组件开发
v5版本兼容类组件和函数组件开发。
1）安装路由
yarn add react-router-dom@5.3.4 # or npm i react-router-dom@5.3.4 2）配置一级路由
App.jsx
import React from "react"; import { BrowserRouter as Router, Switch, Route, Link } from "react-router-dom"; import Login from "./pages/Login"; import Home from "./pages/Home"; export default function App() { return ( &lt;Router&gt; &lt;div&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to="/"&gt;首页&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/login"&gt;登录页面&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; {/* A &lt;Switch&gt; looks through its children &lt;Route&gt;s and renders the first one that matches the current URL.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53a104e8c3b7855b52b5c410f8bf97a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ff023d6be6fe313fa451bf0273f3a9c/" rel="bookmark">
			汉字编码技術與標準
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近來在學習字體相關技術，收集整理一些學習筆記，特記錄如下：
一、二进制編碼和ASCII編碼 发明世界上第一台电子计算机的美国人，在1967年將英文字母和一些英文符号安排成第一批被编码能够在电子计算机的屏幕上显示的字符。因为一开始要编码的字符并没有多少，一些不可见的控制字符和可见的字符加一起才有128个，虽然这是2的7次方，仅仅需要7位久就能完成这些字符的编码工作。但是由于一般计算机内存的寻址方式为2的偶数次方较为方便，于是人们用一字节（8位）的低7位来编码这些字符，最高位为0，而这128个字符被称为标准ASCII码（ASCII的全称为American Standard Code for Information Interchange，直译为：美国信息交换标准代码），或者叫做基础ASCII码。
后来又有一部分字符需要编码，在1981年人们又凑了128个字符，最高位为1，利用一字节剩下的7位来编码这128个字符。这样一来新的编码方式便兼容了之前的标准ASCII，使得之前用便准ASCII编码的数据还可以继续在计算机屏幕上正常显示。而这部分新的128个字符被对应地称为扩展ASCII码。
二、JIS基本漢字標準 1978年，日本工业规格协会制定了JIS C 6226，即 7ビット及び8ビットの2バイト情報交換用符号化漢字集合（直译为：七位元及八位元之双字节资讯交换用符号化汉字集，简称JIS基本汉字）。这也是全世界最早的汉字编码字符集。
JIS基本汉字收录了6879个图形字符，包括6355个汉字和524个非汉字图形符号，采用了行号列号和区位结合的方式定位，共分为94区，而每区编入94个字符（但实际上为了分类方便，并不是每个区都是满编94个字符）。习惯上称第一个字节为高字节，第二个字节为低字节。高字节表示该字符所在的区，低字节由行列号确定该字符在区内的位。01区-09区为非汉字图形字符，16区-84区为汉字。其中主要各区编码内容如下：
01区-02区 特殊文字共147个字符
03区 阿拉伯数字以及英文字母大小写共62个字符
04区 平假名共83个字符
05区 片假名共86个字符
06区 希腊字母大小写共48字符
07区 西里尔字母大小写共66个字符
08区 制表符共32个字符
16区-47区 一级汉字共2965个字符
48区-84区 二级汉字共3390个字符
85区-94区 私人造字区
注：一级汉字和二级汉字的划分依据是使用频率，将使用频率高的汉字划分为一级汉字。
为什么是94个区呢？94也不是2的n次幂的结果啊？
这个问题问得好，很多人刚接触汉字编码时都对这个数字一头雾水。但是其实这个数字也是在尽可能的范围内取得最大值。还记得前文ASCII中提到的控制字符吗？ASCII的前32个字符就是控制字符，实际上第128个字符也是控制码（DEL，删除），而区位又是从01开始计数，所以128-32-1-1=94。
三、GB2312標準 我國於1981年制定了一套汉字编码标准。这套编码标准称为GB2312，即中华人民共和国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，通常简称为GB。GB2312为中国大陆地区的强制标准，亦被使用于新加坡。（香港特区、澳门特区以及台湾省使用的是另一种名为Big5码的编码标准）
GB2312收录了汉字6763个（其中一级汉字3755个，二级汉字3008个），除此之外还收录了包括英文字母、希腊字母、日文假名、西里尔字母在内的682个字符，共计7445个字符。同JIS基本汉字一样，GB2312也划分了94个区，每个区94个位。但二者各个区的内容略有出入：
01区-09区 特殊符号、数字等682个全角字符（全角字符与半角字符的区别为全角字符占用两个字节，而半角字符只占用一个字节）
10区-15区 空区，待扩展
16区-55区 一级汉字共3755个字符（按拼音排序）
56区-87区 二级汉字共3008个字符（按部首/笔画排序）
88区-94区 空区，待扩展
而国标码和基本ASCII码冲突，于是把最高位置为1，得到对应的机内码，简称内码。内码正是计算机内存单元中真正储存的编码。
随着国内少数民族对计算机的使用需求和GB2312对汉字收录过少的局限性，我国于2000年在GB2312的基础上扩充，制定了GB18030标准。在GB2312的基础上，增加了4字节编码的方式，涵盖了中文汉字，日文假名，朝鲜谚文以及其他中国少数民族的文字。
四、CJK編碼標準 为了交流方便，汉字文化圈的中国、日本、朝鲜、韩国希望能一统一的标准处理汉字，于是在国际社会的共同努力下，于1993年正式制定了收录字符20902个的中日韩统一表意文字，简称CJK编码。其中C代表中文、J代表日文、K代表谚文。经过多年来的不断修订，现已收录包括古籍生僻字、少数民族文字、朝鲜国字（又称韩国制汉字）、越南喃字和儒字、琉球汉字、人名生僻字以及科技文献生僻字等在内的87888个字符，并被广泛使用于中国、日本、朝鲜、韩国、越南、马来西亚等国。
五、常見的漢字字符集編碼標準 GB2312编码：1981年5月1日实施的简体中文汉字编码国家标准。GB2312对汉字采用双字节编码，收录7445个图形字符，其中包括6763个汉字。自2017年3月23日起，该标准转化为推荐性标准：GB/T2312-1980，不再强制执行。
BIG5编码：台湾地区、香港及澳門特區繁体中文标准字符集，采用双字节编码，共收录13053个中文字，1984年实施。
GBK编码：1995年12月发布的汉字编码国家标准，是对GB2312编码的扩充，对汉字采用双字节编码。GBK字符集共收录21003个汉字，包含国家标准GB13000-1中的全部中日韩汉字，和BIG5编码中的所有汉字。
GB18030编码：2000年3月17日发布的汉字编码国家标准，是对GBK编码的扩充，覆盖中文、日文、朝鲜语和中国少数民族文字，其中收录27484个汉字。GB18030字符集采用单字节、双字节和四字节三种方式对字符编码。兼容GBK和GB2312字符集。2005年11月8日，发布了修订版本：GB18030-2005字符集，在GB18030-2000的基础上，增加了CJK Ext-B的42711个汉字，共计70244个汉字。2022年7月19日，发布了第二次修订版本：GB18030-2022，收录汉字总数八万余个。完全兼容2005标准，并在其基础上增加扩展C、D、E、F区1.7万多字，将于2023年8月1日正式实施。
Unicode编码：（也稱 ISO/IEC 10646 ），Unicode采用四个字节为每个字符编码。这是全球可以共享的编码字符集，两者相互兼融，涵盖了世界上主要语文的字符，其中包括简繁体汉字，计有：CJK统一汉字编码20992个、CJK Ext-A 编码 6582个、CJK Ext-B 编码 36862个、CJK Ext-C 编码 4160个、 CJK Ext-D 编码 222个，共计74686个汉字。SimSun-ExtB（宋体)、MingLiU-ExtB（细明体）能显示全部Ext-B汉字。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ff023d6be6fe313fa451bf0273f3a9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e6914bc9cd99bfead5cd44533a70427/" rel="bookmark">
			BlueBell注册功能逻辑及其实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注册路由 r.POST("/signup", controller.SignupHandler) 控制层实现 第一步，获取参数和参数校验 在models包中定义一个注册请求参数的结构体（ParamSignUp），用于将JSON参数绑定至结构体中。
json 的tag用于绑定参数，binding参数是gin内置validator校验的tag，required代表此字段是传入参数中必须要有的，eqfield=xxx，代表此字段与结构体中的xxx字段值需要相等，否则会校验失败，返回错误
package models // 定义请求的参数结构体 // ParamSignUp 注册请求参数 type ParamSignUp struct { Username string `json:"username" binding:"required"` // 代表校验此字段是必须在的 Password string `json:"password" binding:"required"` RePassword string `json:"re_password" binding:"required,eqfield=Password"` } 得到一个注册请求参数结构体指针
p := new(models.ParamSignUp) // 得到一个注册请求参数结构体指针 ps：new返回类型的指针。
gin自带ShouldBindJSON方法将传入参数序列化到p结构体中
if err := c.ShouldBindJSON(p); err != nil { // 请求参数有误，直接返回响应 zap.L().Error("SignUp with invalid param", zap.Error(err)) // 判断err类型是不是validator.ValidationErrors类型 errs, ok := err.(validator.ValidationErrors) // 如果不是就返回正常错误 if !ok { c.JSON(http.StatusOK, gin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e6914bc9cd99bfead5cd44533a70427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9bcdb5054a4eea30c0daa0da7dc1970/" rel="bookmark">
			spring boot图片上传，存到数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 图片上传 */ public Map&lt;String, Object&gt; uploading(MultipartFile file, String code) throws RuntimeException { System.out.println("请求进来了"); Object obj = redisTemplate.opsForValue().get(code); UserInfo userInfo = JSON.parseObject(JSON.toJSONString(obj), UserInfo.class); String openid = userInfo.getOpenId(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); if (file == null || file.isEmpty()) { map.put("result",false); return map; } // openid="oLZ0d61_0pX8KsoyERE8X4uYeXSs"; // 查询数据库以检查用户是否存在 Student existingStudent = findByOpenid(openid); if (existingStudent == null) { map.put("result",false); return map; } ByteArrayOutputStream out = null; try { InputStream inputStream = file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9bcdb5054a4eea30c0daa0da7dc1970/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af1fa824c2e5366616a2c8158ba0959b/" rel="bookmark">
			https://openai.com/blog/chatgpt/
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Introducing ChatGPTWe’ve trained a model called ChatGPT which interacts in a conversational way. The dialogue format makes it possible for ChatGPT to answer followup questions, admit its mistakes, challenge incorrect premises, and reject inappropriate requests.https://openai.com/blog/chatgpt/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971936a4f23484d8d863da4996dd508b/" rel="bookmark">
			【数据分析】利用机器学习算法进行预测分析（六）：长短时记忆网络（LSTM）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列包含：
基于时间序列的预测方法利用机器学习算法进行预测分析（一）：移动平均（Moving Average）利用机器学习算法进行预测分析（二）：线性回归（Linear Regression）利用机器学习算法进行预测分析（三）：最近邻（K-Nearest Neighbours）利用机器学习算法进行预测分析（四）：自回归差分移动平均模型（AutoARIMA）利用机器学习算法进行预测分析（五）：Prophet利用机器学习算法进行预测分析（六）：长短时记忆网络（LSTM）基于Streamlit制作的时间序列数据分析APP（上手简单，附可运行源码） 时间序列预测中的机器学习方法（六）：长短时记忆网络（LSTM） 1.LSTM 简介 长短期记忆（Long Short-Term Memory，LSTM）是一种在深度学习领域中使用的人工循环神经网络（RNN）架构。与标准前馈神经网络不同，LSTM具有反馈连接。它不仅可以处理单个数据点（例如图像），而且可以处理整个数据序列（例如语音或视频）。
LSTM网络非常适合基于时间序列数据进行分类、处理和预测，因为在时间序列中的重要事件之间可能存在未知持续时间的滞后。开发LSTM是为了处理在训练传统RNN时可能遇到的爆炸和消失的梯度问题。对于间隙长度的相对不敏感性是LSTM相较于RNN，隐马尔可夫模型和其他序列学习方法在许多应用中的优势。
2.“股价预测”实例 数据集和前面提到的文章相同，目的是为了比较不同算法对同一数据集的预测效果。数据集和代码放在了我的GitHub上，需要的朋友可以自行下载。
导入包，并读入数据。请确保正确安装了sklearn、keras包。
import pandas as pd import numpy as np import matplotlib.pyplot as plt from sklearn.preprocessing import MinMaxScaler from keras.models import Sequential from keras.layers import Dense, Dropout, LSTM df = pd.read_csv('NSE-TATAGLOBAL11.csv') 设置索引。为了不破坏原始数据，重新构建一个new_data。
# setting the index as date df['Date'] = pd.to_datetime(df.Date,format='%Y-%m-%d') df.index = df['Date'] #creating dataframe data = df.sort_index(ascending=True, axis=0) new_data = pd.DataFrame(index=range(0,len(df)),columns=['Date', 'Close']) for i in range(0,len(data)): new_data['Date'][i] = data['Date'][i] new_data['Close'][i] = data['Close'][i] new_data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/971936a4f23484d8d863da4996dd508b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/753465045c124b498bf431b40d472aed/" rel="bookmark">
			【Python从入门到进阶】38、selenium关于Chrome handless的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上篇《37、selenium关于phantomjs的基本使用》
上一篇我们介绍了有关phantomjs的相关知识，但由于selenium已经放弃PhantomJS，本篇我们来学习Chrome的无头版浏览器Chrome Handless的使用。
一、Chrome Headless简介 Chrome Headless是一个无界面的浏览器环境，它是Google Chrome浏览器在59版本之后新增的一种运行模式。与传统的浏览器不同，Chrome Headless可以在后台执行网页操作，而无需显示可见的用户界面。
Chrome Headless提供了一种方便的方式来进行自动化测试、网络爬虫和数据抓取等任务。它通过模拟用户在浏览器中的行为，实现了对网页的自动化操作和交互。在执行过程中，Chrome Headless可以访问和操纵网页的DOM结构、执行JavaScript代码、提交表单、点击按钮等。
由于没有可见的界面，Chrome Headless相比传统浏览器具有一些优势。首先，它更轻量级，节省了系统资源，并且执行速度更快。其次，它稳定性高，不受弹窗、广告或其他干扰因素的影响。此外，Chrome Headless还提供了丰富的调试工具和API，方便开发者进行调试和监控。
使用Selenium框架结合Chrome Headless可以实现自动化测试和网页爬虫等应用场景。开发人员可以利用Selenium的API来编写脚本，控制Chrome Headless执行各种操作，并获取网页内容和处理结果。
二、Chrome Headless安装及使用 1、环境确认 我们使用Chrome Headless之前，首先要确认一下相应的环境是否满足：
（1）Chrome浏览器版本
Unix\Linux操作系统环境下，浏览器版本需要&gt;=59；
Windows操作系统环境下，浏览器版本需要&gt;=60；
（2）软件和框架版本
Python版本&gt;=3.6
Selenium版本&gt;=3.4.*
ChromeDriver&gt;=2.31
2、安装Python和Selenium库 确保我们已经安装了Python，并安装了Selenium库。可以使用命令pip install selenium来进行Selenium库的安装。
3、谷歌浏览器驱动安装 需要安装ChromeDriver，这个我们在学习Selenium框架之前就已经安装过了，这里不再赘述，需要的同学请查看博文《34、selenium基本概念及安装流程》中有关“下载浏览器驱动”的章节。
4、Chrome Headless的使用 和之前使用PhantomJS不同，Chrome Headless已经内置到我们之前下载好的ChromeDriver驱动程序中了，我们只需要设置一下创建ChromeDriver对象的参数即可，将模式改为Headless模式，即可调用Chrome的无头浏览器了。整体需要以下三步：
（1）创建ChromeOptions对象，配置Chrome Headless选项
options = Options() # 设置Chrome为Headless模式 options.add_argument("--headless") # 禁用GPU加速 options.add_argument("--disable-gpu") （2）创建Chrome WebDriver对象，传入ChromeOptions对象
driver = webdriver.Chrome(options=options) 然后使用driver调用需要的API方法即可。
5、Python调用示例 这里以使用Chrome Headless打开百度页面获取其标题为例：
from selenium import webdriver # 导入selenium的webdriver模块 from selenium.webdriver.chrome.options import Options # 导入ChromeOptions模块 # 创建ChromeOptions对象，配置Chrome Headless选项 options = Options() options.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/753465045c124b498bf431b40d472aed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3972035b172a4787a56e954c8d702412/" rel="bookmark">
			从57%到11%‼️句子意思转换器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天来聊聊句子意思转换器，希望能给大家提供一点参考。
以下是针对论文重复率高的情况，提供一些修改建议和技巧：
句子意思转换器是一种人工智能（AI）工具，它可以自动地将一个句子的意思转换成另一种语言或另一种表达方式，而不需要人工翻译。这种工具通常被用于机器翻译、文本生成、语音识别和对话系统等领域。
1、句意转换例句 以下是一些句子意思转换器的示例：
2、句子转换是什么意思? 3、句子转换器在线转换 4、句子转换器下载 5、句子转换大全 英语句子：“The quick brown fox jumps over the lazy dog.”
转换成中文的意思是：“敏捷的棕色狐狸跳过了懒狗。”中文句子：“我喜欢吃苹果。”
转换成英文的意思是：“I like to eat apples.” 6、句子句型转换 句子意思转换器的实现需要基于深度学习和自然语言处理等技术。它通常会使用大量的语料库来训练模型，以使模型能够准确地识别和理解语言的结构和意义。这种工具的应用范围非常广泛，可以用于自动化翻译、文本摘要、语音识别和聊天机器人等领域。
7、句型转换的意思 需要注意的是，由于不同语言和文化之间的差异，句子意思转换器并不总是能够完全准确地传达原句的意思。因此，在使用这种工具时，需要谨慎地评估其输出结果，并在必要时进行人工编辑和调整。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58faa859338e706bf521b6af2a62331d/" rel="bookmark">
			1.批量下载Gimms NDVI3g1981-2022年NDVI数据(R)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 安装和加载gimms包（如果尚未安装） if (!requireNamespace("gimms", quietly = TRUE)) { install.packages("gimms")} library(gimms) # 指定下载目标文件夹路径 output_folder &lt;- "F:/A 毕业论文/original data/ndvi原始数据" # 循环下载1980年到2022年的数据 for (year in 1980:2022) { start_date &lt;- as.Date(paste0(year, "-01-01")) end_date &lt;- as.Date(paste0(year, "-12-31")) cat("Downloading data for year", year, "\n") gimms_files_date &lt;- downloadGimms(x = start_date, y = end_date, dsn = output_folder, format = "nc4") } cat("Data download completed.\n") 上面批量下载了1991-2022年的ndvi数据。
NDVI数据取自GIMMS NDVI 3g，该产品由美国国家航空和航天局（NASA）的全球监测与模型研究组（GIMMS）发布。数据使用AVHRR（Advanced Very High Resolution Radiometer）卫星传感器，时间分辨率为半月，空间分辨率0.0083°。数据时间范围包括1981年至2022年。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c5cd57ff69978329a7904bc01c2c836/" rel="bookmark">
			基于单片机四路温度报警系统仿真设计-毕设资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DS18B20 为数字温度传感器，主要用于组网测温，它是I-Wire 总线通信协议数字式温度传感器，测温范围为-55～125 ℃，分辨率为9～12位
。SJA1000 是PHILIPS 公司生产的符合CAN2.0B 协议的协议转换器. PCA82C250 是CAN
协议控制器和物理总线之间的接口，对总线提供差动发送能力，对CAN 控制器提供差动接收能力，使用PCA82C250
可以增大通信距离、提高系统的瞬间抗干扰能力、保护总线及降低射频干扰. 6N137则是高速光电隔离器件.根据DALLAS 公司提供的DS18B20
资料，每根单线总线上最多可以挂248 个1-WIRE 器件.本系统在实际实验中发现，当1 根单总线上所挂的DS1820 超过8
个时，就需要解决控制节点的单片机对单线总线驱动问题，否则单片机就不能实现对DS18B20 的正确读写.因此在本系统中，每个控制节点1
根单总线接4个DS1820，这样的设计保证单片机对总线的驱动，实现系统的稳定运行。
本设计以AT89S52单片机为控制单元、温度传感器DS18B20为主要检测器件，实现多路温度的测量、显示、存储和报警。本设计使用C语言进行设计开发，采用Proteus7.4进行电路的设计并仿真，实现：四路温度循环检测，超限自动报警还可固定其中一路检测，测量温度的同时，还能记录当时的时间，温度测量范围为
-55℃ ～ +125℃，精度为±0.5℃。
​
#include "lcd1602.h" #include "ds18b20.h" #include "DS1302.h" #include "24C16B.h" sbit WN=P3^7; sbit X0=P3^2; sbit X1=P3^3; uchar n=1,count=0,smb=0; extern char zhen_temp[5],*wendu; extern bit flag; uchar code ds18b20_num1[8]={0xfd,0x00,0x00,0x00,0xb8,0xc5,0x45,0x28}; uchar code ds18b20_num2[8]={0x8e,0x00,0x00,0x00,0xb8,0xc5,0x30,0x28}; uchar code ds18b20_num3[8]={0xb9,0x00,0x00,0x00,0xb8,0xc5,0x31,0x28}; uchar code ds18b20_num4[8]={0xe0,0x00,0x00,0x00,0xb8,0xc5,0x32,0x28}; void delay(unsigned int time) { unsigned int i,j; for(i=0;i 项目获取: https://gitee.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c5cd57ff69978329a7904bc01c2c836/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cffee28e22f4f633888788ceea8494e4/" rel="bookmark">
			打包spring boot项目时候出现Error starting ApplicationContext. To display the conditions report re-run your a
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我今天来分享一下我打包项目遇到的一个坑，就是一道早起来昨天没干完的项目干完然后终于到了打包的阶段我匆匆忙忙的先mvn clean一下《以防万一》再来mvn package 一下此打包过程中出现了以下错误并且中断了打包
Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 2023-10-06 11:01:12.247 ERROR 27480 --- [ main] o.s.boot.SpringApplication : Application run failed java.lang.IllegalStateException: Failed to execute ApplicationRunner at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:762) ~[spring- boot-2.7.6.jar:2.7.6] at org.springframework.boot.SpringApplication.callRunners(SpringApplication.java:749) ~ [spring-boot-2.7.6.jar:2.7.6] at org.springframework.boot.SpringApplication.run(SpringApplication.java:314) ~[spring-boot- 2.7.6.jar:2.7.6] at org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContext Loader.java:136) [spring-boot-test-2.7.6.jar:2.7.6] at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextIn ternal(DefaultCacheAwareContextLoaderDelegate.java:141) [spring-test-5.3.24.jar:5.3.24] at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(D efaultCacheAwareContextLoaderDelegate.java:90) [spring-test-5.3.24.jar:5.3.24] at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTe stContext.java:124) [spring-test-5.3.24.jar:5.3.24] at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNece ssary(ServletTestExecutionListener.java:190) [spring-test-5.3.24.jar:5.3.24] at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(Servl etTestExecutionListener.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cffee28e22f4f633888788ceea8494e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87137d0e0210f6b07c65740db7d71fab/" rel="bookmark">
			看源码逐行学习ChatGLM2-6B大模型，项目中的modeling_chatglm.py文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型代码地址
""" PyTorch ChatGLM model. ChatGLMModel模型结构 (假设输入X大小为 3x5) 转载自：https://blog.csdn.net/hjyai94/article/details/132504200 (embedding) Embedding (转置后 5x3x4096) word_embeddings: Embedding(65024, 4096) (rotary_pos_emb) RotaryEmbedding() (encoder) GLMTransformer (layers) ModuleList 0-27: 28 x GLMBlock (input_layernorm) RMSNorm() (输入输出大小: 5x3x4096) (self_attention) SelfAttention (query_key_value) Linear(in_features=4096, out_features=4608, bias=True) (core_attention) CoreAttention(attention_dropout) Dropout(p=0.0, inplace=False)) (dense) Linear(in_features=4096, out_features=4096, bias=False) (post_attention_layernorm) RMSNorm() (mlp) MLP (dense_h_to_4h) Linear(in_features=4096, out_features=27392, bias=False) (dense_4h_to_h) Linear(in_features=13696, out_features=4096, bias=False) (final_layernorm) RMSNorm() (output_layer) Linear(in_features=4096, out_features=65024, bias=False) (输出大小: 3x5x65024) """ #导入基础库 import math import copy import warnings import re import sys #导入pytorch相关库 import torch import torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87137d0e0210f6b07c65740db7d71fab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/886e9c3cbdc9480dc9a460a2c01ddc2b/" rel="bookmark">
			Vue中如何进行音视频录制与视频剪辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Vue中进行音视频录制与视频剪辑 随着互联网的发展，音视频处理已经成为前端开发中一个越来越重要的领域。Vue.js作为一款流行的前端框架，为我们提供了丰富的工具和生态系统，使得音视频录制和编辑变得更加容易。本文将介绍如何在Vue中进行音视频录制与视频剪辑，并提供相应的代码示例。
准备工作 在开始之前，请确保您已经安装了Node.js和Vue CLI。如果尚未安装，您可以按照Vue CLI官方文档的说明进行安装。
# 安装Vue CLI npm install -g @vue/cli 创建Vue项目 首先，让我们创建一个新的Vue项目。在终端中执行以下命令：
vue create video-editor-app 在项目创建过程中，您可以选择自定义配置或使用默认配置，具体根据您的需求来选择。创建完成后，进入项目目录：
cd video-editor-app 安装依赖 为了进行音视频录制和编辑，我们将使用一些外部库和组件。执行以下命令来安装这些依赖项：
npm install vue-video-editor recordrtc vue-recordrtc vue-video-editor：用于视频编辑的Vue组件。recordrtc：用于音视频录制的JavaScript库。vue-recordrtc：用于在Vue中集成recordrtc的插件。 集成音视频录制 首先，让我们集成音视频录制功能。在src/components目录中创建一个名为VideoRecorder.vue的组件：
&lt;template&gt; &lt;div&gt; &lt;h1&gt;音视频录制&lt;/h1&gt; &lt;button @click="startRecording" v-if="!recording"&gt;开始录制&lt;/button&gt; &lt;button @click="stopRecording" v-if="recording"&gt;停止录制&lt;/button&gt; &lt;video ref="videoPlayer" controls&gt;&lt;/video&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import RecordRTC from 'recordrtc'; export default { data() { return { recorder: null, recording: false, videoStream: null, }; }, methods: { async startRecording() { try { const stream = await navigator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/886e9c3cbdc9480dc9a460a2c01ddc2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48181c815ad0d142a456022b83e01ef4/" rel="bookmark">
			golang：在int64和base64字符串间转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一种数字编码方法，在int64和base64字符串间转换：
func Int64ToBase64(i int64) string { bytesBuffer := bytes.NewBuffer([]byte{}) _ = binary.Write(bytesBuffer, binary.BigEndian, i) return base64.StdEncoding.EncodeToString(bytesBuffer.Bytes()) } func Base64ToInt64(s string) (int64, error) { b, err := base64.StdEncoding.DecodeString(s) if err != nil { return 0, err } bytesBuffer := bytes.NewBuffer(b) var i int64 err = binary.Read(bytesBuffer, binary.BigEndian, &amp;i) if err != nil { return 0, err } return i, nil } --end--
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12b75671c5e1a73f0e14367483a87875/" rel="bookmark">
			Java中的锁与锁优化技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 自旋锁与自适应自旋锁消除锁粗化轻量级锁偏向锁重量级锁 自旋锁与自适应自旋 自旋锁是一种锁的实现机制，其核心思想是当一个线程尝试获取锁时，如果锁已经被其他线程持有，那么这个线程会在一个循环中不断地检查锁是否被释放，而不是进入睡眠状态。
自旋锁在JDK 1.4.2中就已经引入，只不过默认是关闭的，在JDK 6中就已经改为默认开启了。自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。自旋次数的默认值是十次。
在 JDK 6中对自旋锁的优化，引入了自适应的自旋。自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。
锁消除 锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。
锁消除通常基于逃逸分析（Escape Analysis）。逃逸分析是一种确定对象的作用域和访问范围的技术。如果确定某个对象只能在一个线程内部访问，并且不会“逃逸”到其他线程，那么该对象上的同步操作是不必要的。
public String concatenate(String str1, String str2) { StringBuffer sb = new StringBuffer(); sb.append(str1); sb.append(str2); return sb.toString(); } /* StringBuffer的append方法上面有synchronized，说明是同步代码块 */ @Override public synchronized StringBuffer append(String str) { toStringCache = null; super.append(str); return this; } 在上面示例中，StringBuffer是线程安全的，其方法是同步的。但在concatenate方法中，sb对象只会被一个线程访问，不会逃逸到其他线程。通过逃逸分析和锁消除，JVM可以确定在这种情况下，sb上的同步操作是不必要的，并且可以安全地消除它们。
锁粗化 锁粗化是Java虚拟机为了优化锁操作而采取的一种技术。基本思想是将多个连续的加锁、解锁操作合并为一个大的锁块，以减少锁操作的开销。
synchronized (lock) { // code block 1 } // other operations synchronized (lock) { // code block 2 } 在上面代码中，两个连续的synchronized块可以被合并为如下一个大的synchronized块，从而减少锁的开销：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12b75671c5e1a73f0e14367483a87875/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48a21d3210d483f31fbb536f6cb804ca/" rel="bookmark">
			未来冲突的AI化：探讨战争中的人工智能！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI技术：战争中的利器还是威胁！ 人工智能（AI）很快可能会比人类更聪明。人工智能在过去几十年里迅速发展，每一代新的版本都超越了之前的版本。OpenAI发布的最新语言模型GBT5引发了有关其潜在风险的争议。有人声称它可能最终对国际安全构成威胁。科学家们也对升级人工智能的能力发出了警告。在这个视频中，你将了解到由于AI升级而在美国潜在的风险因素，所以让我们开始吧。
OpenAI Chat GPT5，这是GPT系列中最新的语言模型。由Chat GPT5生成的文本以自然语言编写，与人类编写的文本相同。通过分析大量文本数据，它生成语法正确、与情境相关且语义清晰的内容。它使用各种学习策略来实现这一点，与它的前身相比，Chat GPT5旨在更加多功能和灵活，可以为更多的情况生成文本。此外，GPT5还具备一种基本的常识推理能力，使其能够提供更富有洞察力和可接受的回答。这些进步改善了用户体验，并提供了各种潜在应用，如客户服务、个人数字助手和语言翻译。
如果你还没有GPT PLus 账号 前往：AI意识觉醒 | Link3
可以领取一个10天左右的 GPT Plus 号
然而，GPT 5的高度可信深度伪造材料或虚假新闻可能会利用其强大的语言生成能力来创建。这项技术增加了虚假信息在线传播的可能性，通过制造似乎合理的故事来夸大事实。在我们已经应对信息过载的世界中，验证信息和识别可信源变得更加困难。它生成具有说服力且与情境相关的语言的能力，可能会用于钓鱼攻击，生成具有说服力的虚假电子邮件或消息，甚至可以欺骗最警觉的接收者。它分析和复制沟通模式的能力还可能导致更复杂的社交工程攻击，危及个人和企业的安全。
但GPT5的能力不仅限于语言，它还可以自动化以前仅由人类执行的任务，这可能导致多个行业的就业丧失。尽管自动化可以提高生产力，但如果处理不当，也可能导致严重的经济扰乱。考虑到这种先进的人工智能的广泛部署，我们可能需要重新评估当前的经济模型和劳动力规划策略。
许多专家和计算机科学家最近几个月一直在警告公众，他们开发了一些极具危险性的东西，这些东西最终可能导致人类灭亡。虽然人们正在讨论杀手机器人，但人们可能忽略了AI所面临的更迫在眉睫的风险。我们讨论了当前的情况以及如何为即将到来的风险做好准备。人工智能可能对人类在不久的将来构成的潜在威胁引起了高层商界领袖的深切关注。现代人工智能系统无法根除人类，有些甚至不知道如何进行加减法，那么为什么那些对人工智能最了解的人会担心呢？
现在，人工智能不仅用于问题解决，还用于战争。这是一个主要的问题和风险因素。从所有AI工具和开发中的创新来看，可以确定AI的知识和能力超越了人类的能力，这将逐渐破坏人类的能力。还有一种可能性，即将它们用作武器，这将增加潜在的危险。
如果AI武器的发展继续下去，火药和核武器将在第三次军备革命之前出现，而第三次军备革命是自主武器。从地雷到导弹是真正的AI启用自主的一个跳板，这将允许全面参与杀戮，寻找选择参与和彻底摧毁另一个人的生命，而无需人的干预。今天使用的自主武器的一个例子是以色列的哈尔皮无人机，它被设计成飞到特定位置，寻找特定目标，然后摧毁它们，搭载高爆弹药，被称为“发射后不管”。
但更令人担忧的例子可以在反乌托邦短片《屠杀机器人》中看到，该片讲述了能够主动寻找特定个体并向其头部发射一点爆炸物的鸟大小的无人机的故事。由于其小巧灵活，这些无人机自己飞行，无法轻易捕获、停止或销毁。这些屠杀机器人在现实生活中也存在，一个技术宅今天可以用不到1000美元的成本制造出这些无人机，并于2018年差点刺杀委内瑞拉总统。
这是人工智能和机器人技术易于获取和负担得起的副作用，是一个令人意外的结果。一个刺客只需支付1000美元就可以用来杀害一名政治家，这是一个真实的现实风险，而不是未来的遥远威胁。
AI被用于战争可能会引发严重的安全和伦理问题，这是与上下文相关的一项重要讨论点。上文提到，现代AI系统不仅用于问题解决，还用于战争，而这带来了一些潜在风险。
首先，AI在战争中的使用可能会导致自主武器系统的出现。这些系统可以自动执行杀伤行动，包括选择和攻击目标，而无需人类干预。这种自主性可能导致误伤、误杀和不可控制的局面，因此引发了道德和法律上的争议。上下文中提到的例子包括以色列的哈尔皮无人机和屠杀机器人的短片，它们展示了自主武器的潜在危险性。
其次，AI在战争中的使用可能会引发国际安全问题。如果各国开始广泛采用高度发展的AI技术用于军事目的，可能会导致军备竞赛和冲突的升级。此外，AI可能被用于网络攻击、情报搜集和军事情报分析，这也可能引发国际紧张局势。
总之，AI在战争中的应用可能会加剧安全和伦理挑战，需要严密的监管和国际协议来确保其负责任和安全的使用。这是一个复杂的问题，需要深思熟虑，并在国际社会中进行广泛的讨论和协商。
研究创新者和商业领袖，如一直对风险表示关切的伊隆·马斯克（Elon Musk），最近也发出了警告。Openai的首席执行官Sam Altman和Deepmind的创始人之一Demis Hassabis目前负责一个新的人工智能实验室，汇集了Deepmind和Google的最优秀的研究人员，两人都签署了最近的警告信。其他杰出人士，包括Dr. Bengio和Jeffrey Henson，他们最近辞去了Google的职务，也签署了一封或两封警告信。
令人欣慰的是，已经有许多保护和规定已经制定出来，以减少潜在的风险，在应对AI威胁的复杂环境中，公司OpenAI处于前沿，并已采取一些措施，以确保其人工智能技术的负责任和安全应用。首先，OpenAI坚守了人工智能的创作和应用的严格道德标准，专注于更广泛和长期的社会后果。他们意识到高度发展的人工智能可能带来的潜在危险，并承诺进行必要的研究，以使人工智能变得更加安全，并鼓励AI社区广泛接受此类研究。这些举措突显了OpenAI减少GPT5可能带来的风险的承诺，以及其他前沿人工智能系统。
然而，控制这些风险是一个共同的责任，需要各方积极参与，包括消费者、政治家和AI开发者。尽管对GPT 5可能具有危险性存在一些基础担忧，但重要的是客观地对待这种情况，以最大程度地发挥人工智能的好处，同时最小化潜在的风险。伦理的人工智能开发和部署，以及严格的规定和安全措施，将是至关重要的。组织应该制定、开发和实施AI系统的转移、终止和退役程序，当事情出错时应该有明确的程序来停用和停用特别高后果的AI系统，有效地将AI从系统中移除。
随着人们越来越熟悉人工智能，您认为这个问题能够完全解决吗？
欢迎在评论区分享您的想法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68bcd693b5e631a534ffe69cc55e64a0/" rel="bookmark">
			基于SpringBoot的ElasticSearch操作（超详细教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ElasticSearch 简介 1、简介 ElasticSearch 是一个基于 Lucene 的搜索服务器。它提供了一个分布式多员工能力的全文搜索引擎，基于 RESTful web 接口。Elasticsearch 是用 Java 语言开发的，并作为 Apache 许可条款下的开放源码发布，是一种流行的企业级搜索引擎。
ElasticSearch 用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。
2、特性 分布式的文档存储引擎
分布式的搜索引擎和分析引擎
分布式，支持PB级数据
3、使用场景 搜索领域：如百度、谷歌，全文检索等。
门户网站：访问统计、文章点赞、留言评论等。
广告推广：记录员工行为数据、消费趋势、员工群体进行定制推广等。
信息采集：记录应用的埋点数据、访问日志数据等，方便大数据进行分析。
二、ElasticSearch 基础概念 1、ElaticSearch 和 DB 的关系 在 Elasticsearch 中，文档归属于一种类型 type，而这些类型存在于索引 index 中，我们可以列一些简单的不同点，来类比传统关系型数据库：
Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns
Elasticsearch -&gt; Indices -&gt; Types -&gt; Documents -&gt; Fields
Elasticsearch 集群可以包含多个索引 indices，每一个索引可以包含多个类型 types，每一个类型包含多个文档 documents，然后每个文档包含多个字段 Fields。而在 DB 中可以有多个数据库 Databases，每个库中可以有多张表 Tables，没个表中又包含多行Rows，每行包含多列Columns。
2、索引 索引基本概念（indices）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68bcd693b5e631a534ffe69cc55e64a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42eee9b9046be486680553b6e91ea6ba/" rel="bookmark">
			Epoll 与 Select
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		epoll: epoll的优势在于它不会随着监听fd数目的增长而降低效率。
select: 在内核中select采用轮询方式来处理，轮询的fd数目越多，耗时就越多。
在linux/posix_types.h头文件有这样的声明：
#define __FD_SETSIZE 1024 表示 select 最多同时监听1024个fd，可以通过修改头文件在重新编译内核来扩大这个数目，但这似乎并不治本。
一 IO 多路复用的 select
IO 多路复用相对于阻塞式和非阻塞式的优势在于它可以监听多个socket，并且不会消耗过多资源。当用户进程调用select时，它会监听其中所有socket知道有一个或多个socket数据已经准备好，否则就一直处于阻塞式状态。select的劣势在于单个进程能够监视的文件描述符的数量存在最大限制，select() 所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络相应时间的延迟使得大量TCP链接处于非常活跃状态，但调用select()会对所有的select进行一次线性扫描，所以这也浪费了一定的开销。优势在于它具有跨平台特性。
二 Epoll
epoll 的ET 是必须对非阻塞的socket 才能工作，LT对阻塞与非阻塞的socket 都可以。
所有I/O 多路复用操作都是同步的，涵盖select/poll。
阻塞/非阻塞是相对同步I/O来说的，与异步I/O无关。
select/poll/epoll 本身是同步的，可以阻塞与可以不阻塞。(其中，阻塞与非阻塞 与 同步不同步不同；阻塞与否是自身，异步与否是与外部协作的关系)
skater：无论是阻塞I/O、非阻塞I/O，还是基于非阻塞I/O的多路复用都是同步调用。因为他们在read调用时，内核将数据从内核空间拷贝至应用程序空间(epoll应该是从mmap)，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read调用就会在这个同步过程中等待比较长的时间。
epoll事件： EPOLLIN ： 表示对应的文件描述符可以读（包括对端SOCKET正常关闭）； EPOLLOUT： 表示对应的文件描述符可以写； EPOLLPRI： 表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）； EPOLLERR： 表示对应的文件描述符发生错误； EPOLLHUP： 表示对应的文件描述符被挂断； epoll高效的核心是：1 用户态和内核态共享内存mmap。2 数据到来采用事件通知机制(不需要轮询)。
epoll 的api：
epoll - I/O event notification facility #include &lt;sys/epoll.h&gt; int epoll_create(int size); int epoll_create1(int flags); int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, int timeout, const sigset_t *sigmask); ① int epoll_create(int size);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42eee9b9046be486680553b6e91ea6ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eaa13255ca881b69098715328a0fa3d/" rel="bookmark">
			CentOS 7 设置swap分区 (内存置换空间)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以设置2G大小的swap分区为例:
查看当前swap分区大小： free -m 如果没有swap分区，则输出如下：
如果没有的话, 就创建 2G 大小的 swap 文件, 有的话这步就省略.
这里的count= 就是要设置的大小,根据需求填写 dd if=/dev/zero of=/swapfile bs=1M count=2048 格式化 swap 文件： mkswap /swapfile 将 swap 文件挂载到 swap 分区： swapon /swapfile 修改 /etc/fstab 文件，将 swap 分区添加到 fstab 文件中，以便系统在启动时自动挂载 swap 分区：
(这一步决定着, 重启后会不会自动挂载到 swap 分区, 如果没有这一步,或者没成功的话, 重启就失效, 不会被挂载) vi /etc/fstab 在 /etc/fstab 文件中添加以下行：
/swapfile swap swap defaults 0 0 备注: 点 i 键为编辑, 点ESC键退出编辑 , shift + : 输入wq 保存退出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eaa13255ca881b69098715328a0fa3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0a802a2946ea5abda63f809fe3c7e31/" rel="bookmark">
			Linux Strace命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 What strace: 是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互、例如：系统调用、信号传递、进程状态变更等。
strace底层使用内核的ptrace 特性来实现其功能。
在故障处理和问题诊断过程中，strace作为一种动态跟踪工具，能够帮助高效地定位进程和服务故障，它像是一个侦探，通过系统调用的过程，使你知道真相。
二 Why ① 通过strace 启动要跟踪的进程。
在执行想要执行的命令前加上strace就好。例如：想要跟踪 "ls -lh /var/log/messages" 命令的执行过程，则
strace ls -lh /var/log/messages ② 跟踪已经在运行的进程，在不中断进程执行的情况下，追踪它在做什么；这时在执行 strace -p pid 例如当前存在some_server 进程再执行，则先查看该进程的pid，
pidof some_server 17558 执行 strace 命令进行跟踪：
strace -p 17558 完成跟踪时，执行 Ctrl+C 即可结束strace。
strace命令的参数：
option: -tt：在每行输出的前面，显示毫秒级别的时间 -T：显示每次系统调用所花费的时间 -v：对于某些相关调用，把完整的环境变量，文件 stat 结构等打出来。 -f：跟踪目标进程，以及目标进程创建的所有子进程 -e：控制要跟踪的事件和跟踪行为，比如指定要跟踪的系统调用名称 -o：把 strace 的输出单独写到指定的文件 -s：当系统调用的某个参数是字符串时，最多输出指定长度的内容，默认是 32 个字节 -p：指定要跟踪的进程 pid，要同时跟踪多个 pid，重复多次 -p 选项即可。 三 How 1、定位进程异常退出
问题：机器上有个叫做run.sh的常驻脚本，运行一分钟后会死掉。需要查出死因。
定位：进程还在运行时，通过ps命令获取其pid, 假设我们得到的pid是24298
strace -o strace.log -tt -p 24298 查看 strace.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0a802a2946ea5abda63f809fe3c7e31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19bfae3baabd9b18c98adcad816f8f3/" rel="bookmark">
			基于微信小程序的付费自习室
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌程序员徐师兄、7年大厂程序员经历。全网粉丝30W+、csdn博客专家、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和毕业项目实战✌
文章目录 1 简介2 技术栈3 需求分析3.1用户需求分析3.1.1 学生用户3.1.3 管理员用户 4 数据库设计4.4.1 ER图设计4.4.2 数据库表设计 **第五章 系统实现**5.1小程序功能的实现5.2管理员模块的实现5.2.1 留言管理5.2.2 学生信息管理5.2.3 公告管理5.2.4 高校自习室信息管理5.2.5 自习室预约审核管理 6 源码咨询 1 简介 Java 基于微信小程序的自习室预约系统
本文研发的基于微信小程序的新乡学院自习室预约系统结合高校具体的实际，利用编程基础和数据库实现教务信息化管理。充分利用校园的现有资源，把目前落后的管理现状提升到信息化管理模式中，减轻自习室管理工作量，有助于教学工作规范。基于微信小程序的新乡学院自习室预约系统帮助教师有效的管理自习室信息，学生通过系统了解自习室的使用情况，变化情况。减少徒步到自习室查看状态的时间，并通过系统可以查看各种公告以及教学公告信息。在交流模块也可以和其他同学或者老师在线交流。获取校园生活中的问题和解决方法，有效提升在校时间利用情况，提高了学习效率
2 技术栈 说明技术栈备注后台Java前端小程序数据库MYSql架构B/S 结构 3 需求分析 3.1用户需求分析 基于微信小程序的新乡学院自习室预约系统的用户是系统最根本使用者，按需要分析系统包括两类用户：学生、管理员。这两类用户对系统的需求简要如下。
3.1.1 学生用户 学生用户只要实现了前台信息的查看，打开首页，查看网站介绍、自习室信息、在线留言、轮播图信息公告等，通过点击首页的菜单跳转到对应的功能页面菜单，包括网站首页、自习室信息、注册登录、个人中心、后台登录。
学生用户通过账户账号登录，登录后具有所有的操作权限，如果没有登录，不能在线预约。学生用户退出系统将注销个人的登录信息。
3.1.3 管理员用户 管理员通过后台的登录页面，选择管理员权限后进行登录，管理员的权限包括轮播公告管理、老师学生信息管理和信息审核管理，管理员管理后点击退出，注销登录信息。
管理员用户具有在线交流的管理，自习室信息管理、自习室预约管理。
在线交流是对前台用户留言内容进行管理，删除留言信息，查看留言信息。自习室类型管理，添加某一个自习室类型信息。高校自习室管理，用户添加高校自习室信息，包括高校自习室名称、最大容纳数、高校自习室的位置、高校自习室的状态、对应高校自习室的图片，添加后在高校自习室管理中对信息进行。操作后退出系统。
4 数据库设计 4.4.1 ER图设计 本基于微信小程序的新乡学院自习室预约系统实体清晰，所以这里只绘制系统整体E-R图，其它的略去E—R图的绘制。
(1)管理员信息实体E-R图：
图4.3管理员E-R图
(2)公告信息实体E-R图
图4.4公告信息实体E-R图
(3)类型信息实体E-R图
图4.5自习室类型信息E-R图
(4)学生信息实体E-R图
图4.6 学生信息实体E-R图
(5) 高校自习室信息E-R图
图4.7 高校自习室信息实体E-R图
(6)留言交流信息E-R图
图4.8 留言交流信息实体E-R图
4.4.2 数据库表设计 基于微信小程序的新乡学院自习室预约系统包括多个数据库表，下面对数据表进行详细的介绍，每个数据库表包括这个名称，对于类型是否逐渐、是否与空字段的备注信息等。
表: 自习室信息表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e19bfae3baabd9b18c98adcad816f8f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/758741e34b7da39f75932269ce45eb09/" rel="bookmark">
			LLM下半场之Agent基础能力概述：Profile、Memory、Plan、Action、Eval学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Agent发展将会是LLM的下半场
目前大家都在讨论LLM，LLM解决的问题是帮助机器像人类一样理解彼此的意图，本质上来讲，LLM更像是一个技术或者工具。但是人类社会发生变革的引线，往往是一个产品或者解决方案，比如电池技术的发展带来了长续航，但是真正改变大家生活的是电动车这样一个产品。Agent的概念是创造一个个场景的智能体，可以在某些领域，比如在社会分析、电商导购、工业制造方面提供解决方案。LLM的发展将会让Agent的诞生成为可能，也会推动各个领域的Agent发展，所以我说Agent将会是LLM的下半场。
最近也是学习了一篇高瓴机构发布的论文《A Survvey on Large Language Model based Autonomous Agents》，将里面的内容和最近的思考做个整理。
二.Agent的整体结构
如果要实现以LLM为Base的Agent，主要需要从两个角度思考问题，（1）如何设计一种架构可以更高效的应用LLM（2）如何让Agent具备解决不同任务的范化能力，当然这个也依赖于LLM。目前行业里通常通用的一种架构是由Profile、Memory、Planning、Action所构建的四级架构。
1.Profile模块
Profile模块解决的问题是告诉Agent他的角色，或者换一种说法，是告诉Agent需要解决的问题的背景信息。Profile有三种实现模式。第一种是人工设定模式，比如告诉Agent你是个外向的厨师，你需要解决点餐环节客人的问题。第二种是LLM延申模式，先把一些背景告诉LLM，让LLM给出一些候选集，比方说告诉LLM生成几种人物，解决点餐的问题，然后基于LLM的输出选择合适的Profile方向。第三种是基于database，比方说已经在数据库中存储了某些厨师的数据，包含他的各种身体特征，然后完成设定。
2.Memory模块
Memory模块是Agent解决方案中的重要一环。Memory主要解决的是行业知识的传递问题，可以让Agent拥有长期和短期记忆，让他表现得更智能。
Shot-Memory一般用来传递上下文的的对话信息，常常通过Prompt作为传递介质。而Long-Memory更多的是领域知识，需要有独立的存储模块。Long-Memory的存储结构可能是自然语言、Embedding、结构化的表等。比如做一个餐厅服务点餐Agent，那么完全可以把菜单内容以自然语言的形式存储为Long-Memory，每次点餐要求Agent从约定内容里面选择。随着LLM的发展，目前向量数据库也成为了投资的重点领域，因为以Embedding存储，可以更有利于在大规模数据的前提下压缩信息和高效检索。
3.Planning模块
这一模块是最体现智能能力的模块，这个模块需要根据任务设定具体的执行方案。
Planning模块可以是两种结构，一种是Single-Path，这里引入CoT的概念（Chain of thought），可以要求LLM基于任务一步步推理，形成一个解决方案。每一步推理后产出的内容可以再次输入给LLM去判断下一步如何走。
另一种是Muti-Path，这个方案更符合人类的思维方式，因为要解决问题，很难完全设定好端到端的流程，需要给出几种候选的模式，另外需要考虑环境反馈，可以每走一步再次推理和选择最优模式，这里可以参考最近非常火的ReAct的模式，另外LLM也可以代替人类去做多种方案的选择，我们可以把需要考虑的边界给到LLM，由LLM去思考每一步如何选择。
4.Action模块
这一步是执行模块，需要按照Planning的设计，完成目标。在这一步需要建设的能力是与外部的服务关联，比如我们的Agent是解决帮用户买飞机票的问题，那么在执行阶段就需要与飞机票务系统的订票接口关联，也需要与用户的信用卡付款接口关联。
三、Agent的评估模式
相比于LLM，Agent是一种更广泛的解决方案，于是如何评估Agent的能力是一个很有挑战性的问题。
通常，评估有两种，，一种是主观评估，需要将Agent的执行结果给到人类去打分，所以最近许多类似于标注的众包平台也吸引到了资本的关注，但是这种评估模式的成本较高，很难规模化复制，这也是为什么Agent的迭代优化目前都只能在特定领域展开。
客观评估工作看上去更可能以程序化的模式低成本实现，但这也严重依赖与评价的Metrics设定和Benchmark集合，目前在社会学、自然科学、工程科学范畴已经沉淀了一些相关工作，这也使得相关领域的Agent看上去更有可能率先实现。
四、总结
目前行业中还没有特别出色或者优秀的Agent范本的出现，但是我个人对这个方向是深信不疑的，因为已经有许多工具可以应用，除了上面提到的评估相关的工作，如何串联四个流程，Langchain给了很好的参考。另外在Prompt设计方面，CoT、ReACT都提供了不错的思路，接下来行业内的各个玩家一定会在各个领域去探索Agent的落地可能，相信会在近期有一些成功案例诞生。
参考材料：
https://arxiv.org/pdf/2308.11432.pdf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aea4629d66c131f4fae4be3f6a69702/" rel="bookmark">
			《LeetCode零基础指南》(第一讲) 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 零、了解网站1、输入输出2、刷题步骤3、尝试编码4、调试提交 一、概念定义1、函数简介2、函数的基本概念3、函数的基本结构4、返回类型5、函数名6、参数列表7、函数体8、返回值 二、题目分析1、整数乘法2、整数除法3、次幂函数4、开方函数5、最值函数 三、推荐学习四、课后习题1、必做2、选做 零、了解网站 1、输入输出 对于算法而言，就是给定一些输入，得到一些输出，在一般的在线评测系统中，我们需要自己手写输入输出函数（例如 C语言中的scanf和printf），而在 LeetCode 这个平台，只需要实现它提供的函数即可。函数的传入参数就代表了的算法的输入，而函数的返回值则代表了的算法的输出。
2、刷题步骤 找到一道题，以 两整数之和 为例，如何把这道题通过呢？如下图所示：
第 1 步：阅读题目；
第 2 步：参考示例；
第 3 步：思考数据范围；
第 4 步：根据题意，实现函数的功能；
第 5 步：本地数据测试；
第 6 步：提交；
3、尝试编码 这个题目比较简单，就是求两个数的和，我们可以在编码区域尝试敲下这么一段代码。
int getSum(int a, int b){ // (1) return a + b; // (2) } ( 1 ) (1) (1) 这里int是C/C++中的一种类型，代表整数，即 Integer，传入参数是两个整数； ( 2 ) (2) (2) 题目要求返回两个整数的和，我们用加法运算符实现两个整数的加法； 4、调试提交 第 1 步：实现加法，将值返回；
第 2 步：执行代码，进行测试数据的调试；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aea4629d66c131f4fae4be3f6a69702/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbfabdc9514fbef627840499884b2aac/" rel="bookmark">
			添加驱动模块到内核的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加驱动模块到内核的两种方法 1. 放在内核源代码树中 步骤总结：
新建文件夹编写Makefile、编写Kconfig修改上层Kconfig执行make menuconfig执行make zImage 或 make modules 1.1 源码放入文件夹 例如：添加一个按键字符设备模块
在内核目录下的 drivers/char 目录下新建文件夹 mykey
在 drivers/char/ 下的 Makefile 中添加一行
obj-m += mykey/ 这行指令告诉模块构建系统，在编译模块时需要进入 mykey/ 子目录中 有可能的选择是，驱动程序的编译取决于一个特殊的配置选项，例如 CONFIG_MYKEY ，则指令要替换成 obj-$(CONFIG_MYKEY) += mykey/ 最后，在 drivers/char/mykey/ 目录下添加一个 Makefile，其中需要有下面这行指令
obj-m += mykey.o 表示进入 mykey/ 子目录后，要将 mykey.c 编译成 mykey.o，但最终会生成 mykey.ko 文件 如果加了编译选项，则指令如下 obj-$(CONFIG_MYKEY) += mykey.o 另外，如果后续你的按键程序需要使用到其他的源文件，可以将 mykey/ 目录下的 Makefile 做如下修改
obj-$(CONFIG_MYKEY) += mykey.o mykey-objs := mykey_main.o other.o 表示 mykey_main.c 和 other.c 会一起被编译和链接进 mykey.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbfabdc9514fbef627840499884b2aac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45bc9eec5b9da4e106b4310f61d7877f/" rel="bookmark">
			第三章、运输层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 3.1 概述和运输层服务3.1.1 运输层和网络层的关系3.1.2 因特网运输层概述 3.2 多路复用与多路分解3.3 无连接运输：UDP3.4 可靠数据传输原理3.4.1构造可靠数据传输协议rdt1.0rdt2.xrdt3.0 3.4.2 流水线可靠数据传输协议3.4.3 回退N步3.4.4选择重传 3.5 面向连接的运输：TCP5.1 TCP 连接3.5.2 TCP报文段结构3.5.3 往返时间的估计与超时3.5.4 可靠数据传输3.5.5 流量控制3.5.6 TCP连接管理三次握手四次挥手 3.6 拥塞控制原理3.6.1 拥塞原因与代价3.6.2拥塞控制方法 3.7 TCP拥塞控制3.7.1 公平性3.7.2 明确拥塞通告：网络辅助拥塞控制 3.8 小结 3.1 概述和运输层服务 运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信（logic communication）功能。
运输层协议是在端系统中而不是在路由器中实现的。
3.1.1 运输层和网络层的关系 网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信。
网络层：
网络层确实提供了主机之间的逻辑通信，它负责选择最佳的路径来传输数据包从源主机到目标主机。在这个层次中，通信看起来就像是直接从一个主机到另一个主机，而不考虑中间可能经过的路由器和交换机等网络设备。 运输层：
运输层为运行在不同主机上的进程之间提供逻辑通信。它使得源主机和目标主机上的进程能够通过网络进行通信，就好像它们是直接连接的一样，即使实际上它们可能通过多个网络和路由器连接。运输层通过使用端口号来区分不同的进程，并确保数据准确无误地发送和接收。 3.1.2 因特网运输层概述 因特网的运输层主要负责端到端的通信。它在网络层之上，应用层之下，为运行在不同主机上的进程提供逻辑通信。运输层的主要协议有两种：传输控制协议 (TCP) 和用户数据报协议 (UDP)。
运输层的其他功能包括多路复用和解复用，它允许多个网络应用共享同一网络连接，同时保证数据能正确无误地发送到正确的应用。通过这些机制，运输层对于网络通信的效率和可靠性起到了关键的作用。
3.2 多路复用与多路分解 一个进程(作为网络应用的一部分)有一个或多个套接字 (socket),它相当于从网络向进程传递数据和从进程向网络传递数据的门户。因此，在接收主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字。
将运输层报文段中的数据交付到正确的套接字的工作称为多路分解(demultiplexing)。在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息(这将在以后用于分解)从而生成报文段，然后将报文段传递到网络 层，所有这些工作称为多路复用(multiplexing)。
3.3 无连接运输：UDP 用户数据报协议（UDP, User Datagram Protocol）是一种无连接的网络通信协议，由于它的特性，UDP成为许多特定类型的网络通信的首选。
无连接性：UDP是无连接的，意味着发送数据之前不需要建立连接。每个数据包的发送是独立的，它们可能到达目的地，也可能不会，也可能会按不同的顺序到达。
头部结构：UDP头部非常简单，只有8字节。其中包括源端口、目标端口、长度和校验和字段。这个简单的头部结构使得UDP的处理速度非常快。
校验和（Checksum）：校验和字段用于检测数据在传输过程中是否出现错误。虽然它可以提供基本的错误检测，但如果需要更高的数据完整性保证，通常会需要应用层的错误处理机制。
数据包传输：UDP数据被封装成数据报，每个数据报包括头部和数据两部分，并且每个数据报都是独立发送的。
实时通信：由于UDP的低延迟特性，它常用于需要实时交互的应用，例如VoIP、视频流、在线游戏等。
多播和广播：UDP支持多播和广播通信，这使得它能够一次性向多个节点发送相同的数据包，非常适用于多节点通信场景。
流量控制和拥塞控制：UDP不提供流量控制和拥塞控制功能。它会不断地发送数据，不管网络的状态如何，这可能会导致网络拥塞。
应用场景：除了实时通信，UDP也适用于那些不需要确保每个数据包都到达目的地的场景，例如DNS查询、SNMP等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45bc9eec5b9da4e106b4310f61d7877f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f57603cdfd98c0e9615dd4d2e9513af8/" rel="bookmark">
			Python语法随笔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python语法随笔 第一次测试代码 - 语法差异多行注释三目运算符随机数除法列表删除 牛客习题基础语法掌握输出解密码栈队列使用print()语句和切片第一行输出x除以y的商和余数；第二行输出x除以y的非整除结果，保留两位小数。与，或，非方法1方法 2 Python的位运算列表计算平均绩点方法1方法2 字典 遍历列表方法1方法2 循环时初始化列表跳跃被5整除的数字方法1方法2 二维列表方法1方法2 元组元组操作编辑元组方法1方法2 牛牛的元组字典操作创建遍历字典字典遍历对应的字典内容方法2 封装字典字典添加字典记录数学函数输入初始化列表绝对值ASCII码表转换进制转换幂运算count计数集合index查询判断字符find函数count字符计数列表切割join函数方法2 replace函数题目1 范围函数题目 计算公式函数集合和列表转换题目 cal函数递归函数面向对象-牛客题目题目2题目3题目4 坐标 正则表达式匹配题目1模式匹配正则裁剪正则识别 语法进阶闭包面向对象-继承初始化结构类的内置函数:hasattr(),getattr(),setattr(),delattr()对象关系方法issubclass (类名,类名或元组) 判断第一个类是不是后面的任意一个类的子类isinstance 判断 对象 是否是后面任意一个 类的对象当调用属性不存在时,一般会报错,为了防止报错,并且有提示语可以设置__getattr__函数提示用户 迭代器 iter() 从可迭代对象中返回一个迭代器生成器 也是一种特殊的迭代器1.推导式:python中是一种特殊的数据处理方式,是可以从一个数据序列构建另一个新的数据序列的结构体2.元组推导试：将普通推导式的括号改为()就会变成一个生成器了！！！3.函数 装饰器 第一次测试代码 - 语法差异 Python 是一种高级的、通用的解释型编程语言。它被广泛用于各种领域，使用时最主要的就是注意缩进。
print("不换行",end="") print("666") d=a=c=101 c=",k"+",." print(type(d)) if d==101: print("456") elif d==1: print(a) else: print(c) k=0 i=0; while True: if i==9: break; print(i) i+=1 #这里值得注意的是,i++是不存在的 多行注释 """ 这是个 多行注释 """ multiline = """ 这是个多行 字符串 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f57603cdfd98c0e9615dd4d2e9513af8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df562aa34d6f333a25a585832157f12/" rel="bookmark">
			python小波分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于python进行小波分析，频率谱分析_python 频谱分配-CSDN博客
python小波分析，频率普分析——代码修改_sunny_xx.的博客-CSDN博客
wavelets/wave_python at master · chris-torrence/wavelets · GitHub
https://github.com/chris-torrence/wavelets/tree/master/wave_python
以上借鉴前人经验
python代码
import sys # 添加指定目录到模块搜索路径 module_path = r'F:\A 毕业论文\original data\waveletAnalysis' sys.path.append(module_path) # 现在可以导入子目录中的模块 from waveletFunctions import wavelet, wave_signif import numpy as np import matplotlib.pylab as plt from matplotlib.gridspec import GridSpec import matplotlib.ticker as ticker from mpl_toolkits.axes_grid1 import make_axes_locatable # READ THE DATA sst = np.loadtxt('F:\\A 毕业论文\\original data\\waveletAnalysis\\sst_nino3.dat') # input SST time series sst = sst - np.mean(sst) variance = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3df562aa34d6f333a25a585832157f12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b52b20fe3231e48ea68bff3093c0ef96/" rel="bookmark">
			Makefile输出调试信息print(第二节)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		低端的乃头乐发出人性的呼喊，高端的享受来自精神，享受自己进步的每一瞬间，欢迎来到我第二节课，加油。——张顺
文章目录 输出语句Makefile打印语句echo指令（输出字符串） echo（打印变量）"$"符号 结束 输出语句 printf(“hello world!\n”);
输出语句，大家也许并不陌生，所有同志开始学习程序都离不开一句打印语句，还记得当时你敲完第一句代码运行的奇迹感吗。
学习任何代码都离不开输出，输出语句可以调试，可以方便的让我们知道代码运行的情况及状态。
Makefile也有自己的输出，有了输出信息才可以继续深入的学习。不然写了点代码，报错，你知到如何修改吗
Makefile打印语句 Makefile里面的打印语句和windows的bat脚本的打印语句类似（不知道没关系，接着向下看）
我们都知道c语言当中打印是printf语句，那Makefile一定有自己的打印语句和格式，是什么命令呢----&gt;是echo命令
echo指令（输出字符串） 非常兴奋马上写一个自己的makefile文件验证一下。
为什么出错了呢，还记得第一节课时候的三大规则吗（目标，依赖，命令）？命令应该写道什么地方？
马上添加对应规则：
添加了一个print规则，命令是echo打印
成功出现！！！
但是有点不完美，我不想让别人或者自己看到我的命令行，只想让看到程序执行的结果怎么做。
在echo前面加@即可隐藏命令 可以自己试试
echo（打印变量） 字符串解决了，如何打印变量呢？
一顿操作，这还不简单，搞个变量，往echo后面一放不就可以了。
来一起试试，看是否可行：
似乎他将a当成了字符串处理了。
这里有经验的小伙伴肯定知道了，要a里面的值放在这个地方才可以，又要出来新的符号啦
"$"符号 这个符号可以取到变量里面的值，则：
结束 各位大佬，和小白们，看到这里如果有问题或者请教欢迎留言，共同进步讨论，试读到此结束啦，喜欢我的朋友们可以订阅一手，持续更新以及优化老文章……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc42c9c212bb942a88b97b8e5b0c2391/" rel="bookmark">
			Kafka源码简要分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、生产者的初始化流程
二、生产者到缓冲队列的流程
三、Sender拉取数据到Kafka流程
四、消费者初始化
五、主题订阅原理
六、消费者抓取数据原理
七、消费者组初始化
八、消费者组消费流程
九、提交offset原理
一、生产者的初始化流程 首先获取事务id和客户端id（用到事物必须要事物id不然报错，每个生产者都需要唯一标识客户端id）监控kafka相关情况的JmxReporter配置然后获取分区器，如果用户有自定义的就读取配置的，如果没有配置就用默认分区器然后key和value进行序列化然后就读取自定义拦截器，可以定义多个拦截器，组成拦截器链然后初始化控制单条日志的大小，默认是1m；缓冲区大小，默认32m；创建内存池，缓存队列，初始化批次大小默认16k，压缩相关处理，默认是none，重试间隔时间默认100ms连接kafka集群，获取元数据，才能知道要发送到哪个分区创建sender线程，会有个创建sender的方法，sender线程负责拉取缓冲队列消息到Kafka，在方法里面会定义缓存请求的个数默认5个，然后请求超时的时间，然后创建一个网络请求客户端对象，会传入刚刚的参数还有客户端id，重试时间，发送缓冲区的大小128和接受缓冲区的大小32，还有acks等配置。sender继承了Runnbale接口，然后会new个sender线程出来用上面这些参数，然后返回。sender放到后台，启动sender线程 二、生产者到缓冲队列的流程 在执行到拦截器的时候就要调用一个onSend方法，如果有多个拦截器，每个拦截器都会走一次这个方法，这个方法就是拦截器对数据加工的然后获取元数据，要根据主题的分区放到对应的缓存队列序列化相关操作key和value的序列化和压缩分区操作，如果指定了分区，直接分配到指定分区；没有指定就会根据分区器进行分配，没有指定key就会粘性分区处理（如果批次大小和活着时间到了不然就一直是那个，满足才能创建新队列用），如果指定key就根据key到hashcode进分区数取模，保证（序列化和压缩后）数据大小能够传输，他去读取配置的消息最大值和缓冲区大小，如果有超过的抛异常向缓存队列里面追加数据，获取或者创建一个队列按照分区，然后尝试添加数据（一般不成功，因为还没申请内存），然后根据16k和现在压缩后的总大小取最大值，申请内存就申请这个大小，内存池分配内存，然后sender线程拿走就了会释放内存。如果批次大小满了或者有了新的批次需要创建，就唤醒sender线程把缓冲队列的数据拉取过去。 三、Sender拉取数据到Kafka流程 事务相关操作获取元数据信息，为了知道发到哪个分区判断32m缓存是否准备好，先获取队列的信息，先判断内存队列有没有数据判断leader是不是空如果没有目标那还是会抛出异常，如果批次大小或时间满足一个条件，就会发送。把所有请求按照节点为单位来发送请求，这样一台机器只需要建立一次连接封装了个request然后通过网络客户端把数据发送过去然后服务端还是通过网络客户端获取结果 四、消费者初始化 消费者组平衡获取消费者组id和客户端id设置请求服务端等待时间，默认30秒；重试时间，默认100毫秒拦截器链相关处理key和value的反序列化判断offset从什么位置开始消费获取消费者元数据（重试时间、是否允许访问系统主题默认false，是否允许自动创建topic主题默认true）连接Kafka集群创建网络客户端对象（连接重试时间默认50ms，最大重试时间1s，发送缓冲区128kb和接受缓冲区64kb大小）指定消费者分区分配策略创建coordinator对象设置自动提交offset时间，默认5s，配置抓取数据的参数（最少抓取多少最大一次抓取多少等） 五、主题订阅原理 传入要订阅的主题，如果为null直接抛出异常注册负载均衡监听器，如果消费者组中有节点挂了，要通知其他消费者按照主题自动订阅进行分配 六、消费者抓取数据原理 他首先先初始化消费者组和队列然后回调消息会到缓冲队列，然后去队列抓取数据，最多一次500条然后抓取后拦截器开始处理数据 七、消费者组初始化 先判断coordinator不为null那就说明为消费者组如果没有指定分区分配策略会抛出异常判断coordinator是否准备好，他会循环创建查找coordinator的请求并发送，并获取服务器返回到结果 他这整个消费者组初始化就是判断coordinator有没有准备好
八、消费者组消费流程 他会用判断coordinator是不是空，是的话就等待他上来先去队列拉取数据，一般是拉取不到的他先构造请求的入参（最少一次抓多少，最多抓多少，超时时间等待）然后调用send他送后返回future，通过回调获取数据的他会循环遍历数据获取分区，获取分区的数据，如果有数据就放到消息队列里面然后就调用从队列拉取数据的方法拉取，然后他有大小限制最大500，他会循环一波一波拉取过去然后放到拦截器走加工操作 九、提交offset原理 同步提交：找到coordinator然后调用commitOffset进行发送，然后不停dowhile循环，调用发送提交请求，然后等待回调获取结果，一直循环到成功为止。异步提交：他还是用coordinator去提交但是他不等待结果，他new了个监听等待结果。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b22ef752253a10c21c8b5f615570d25/" rel="bookmark">
			OpenCV读取摄像头视频流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV读取摄像头视频流
""" 1.OpenCV读取摄像头视频流，并且显示 2.保存摄像头录制视频到本地 """ #导入相关包；OpenCV、numpy import cv2 import numpy as np # 调用摄像头 # cv2.VideoCapture(0):调用摄像头，0：默认摄像头 cap = cv2.VideoCapture(0) # 保存摄像头录制视频 # 视频格式，windows推荐DIVX,X264 fourcc = cv2.VideoWriter_fourcc(*'X264') fps = 30 # FPS # 保存视频的长宽,获取摄像头默认的长宽，也可以直接设置大小 # int():去整，cap.get(cv2.CAP_PROP_FRAME_WINTH)获取的是小数 width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)) height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)) writer = cv2.VideoWriter('./video/capdemo.mp4',fourcc,fps,(width,height)) while True: # 返回frame ret,frame = cap.read() # 读取的为一帧一帧的图 # 镜像：Y轴翻转(1) frame = cv2.flip(frame,1) # 灰度显示 # frame = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY) # 保存视频真正的操作,写入画面到文件 # 是将没一帧的画面写入 writer.write(frame) # 显示画面 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b22ef752253a10c21c8b5f615570d25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f39c989f5b5043120859ae10f963c49/" rel="bookmark">
			python货币转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在Python中进行货币转换，可以使用外部库或手动计算。以下是使用外部库和手动计算的两种方法：
方法1：使用外部库 - forex-python
你可以使用外部库forex-python来进行货币转换。首先，你需要安装这个库：
pip install forex-python
然后，可以使用以下代码进行货币转换：
from forex_python.converter import CurrencyRates
c = CurrencyRates()
amount = 100 # 要转换的金额
from_currency = "USD" # 起始货币
to_currency = "EUR" # 目标货币
converted_amount = c.convert(from_currency, to_currency, amount)
print(f"{amount} {from_currency} = {converted_amount} {to_currency}")
这个示例将100美元转换为欧元。你可以根据需要更改起始货币和目标货币。
方法2：手动计算
如果你不想使用外部库，你可以手动计算货币转换。你需要查找当前的汇率，并使用它来进行计算。这通常需要从外部数据源获取实时汇率数据。以下是一个手动计算的示例，假设你知道了汇率：
amount = 100 # 要转换的金额
exchange_rate = 0.85 # 汇率（例如，1美元=0.85欧元）
converted_amount = amount * exchange_rate
print(f"{amount} USD = {converted_amount} EUR")
手动计算汇率需要你有一个可靠的数据源，并且需要定期更新汇率以确保准确性。
使用外部库通常更方便和准确，因为它们会自动获取最新的汇率数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9963038536a15d789ceec9728ec6b1c/" rel="bookmark">
			AW3D30高程文件下载（CSDN_0033_202301006）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AW3D30简介 AW3D30（ALOS World 3D）DEM数据由日本太空发展署（JAXA，Japan Aerospace Exploration Agency）研制的ALOS卫星搭载的PRISM（Panochromatic Remote-Sensing Instrument for Stereo Mapping）仪器拍摄的立体影像制作。ALOS（Advanced Land Observing Satellite）卫星发射于2006年1月24日，轨道高691.65 km，倾角98.16°，该卫星设计使用寿命为3年，目标寿命为5年。ALOS由于电力故障于2011年4月退役。卫星发射目标为提供能够生产1:25000比例尺地图的高分辨率数据，观测水平分辨率为2.5m，垂直经度为3~5m。
JAXA根据2006~2011年ALOS PRISM立体影像数据制作了全球2.5m/5m/30m分辨率的DEM产品。其中2.5m和5m为收费产品可在https://www.aw3d.jp/en/about/ 购买。30m为免费产品，由2.5m/5m分辨率数据制作得到，可通过 https://www.eorc.jaxa.jp/ALOS/en/aw3d30/index.htm 注册后下载。
值得提出的是目前网上提到ALOS 12.5m DEM数据，部分称ALOS PALSAR 12.5m DEM数据，可从NASA ASF（Alaska Satellite Facility）ASF Data Search https://search.asf.alaska.edu/#/ 下载。但事实上ALOS卫星DEM数据是由PRISM拍摄的立体影像制作的，搭载的PALSAR（Phased Array type L-band Synthetic Aperture Radar）主要用于获取正射影像。NASA ASF提供的ALOS PALSAR Hi-Res Terrain Corrected数据中的DEM分辨率确实是12.5m，但是这个DEM数据实际上是用来对PALSAR原始数据做地形校正的，在ASF radiometrically terrain corrected ALOS PALSAR products product guide中明确指出了地形校正所采用的DEM数据来源，如下图所示。
从上图可知除美国或部分加拿大外，其余地区采用的基本为SRTM GL1 30m分辨率DEM。从ASF下载的12.5m DEM是根据原始DEM（如SRTM GL1 30m）up Sampling得到。如果把两种数据（ASF ALOS PALSAR 12.5 DEM于SRTM GL1 30 m）对比就会发现，二者趋势几乎完全一致，但同一位置存在几米到几十米的差异（见后文），这主要是因为SRTM GL1 30m DEM采用的高程基准为EGM 96，为Orthometric Height，而SRTM GL1 30m DEM在被用于做ALOS PALSAR数据地形校正之前，ASF将其高程系统由相对EGM 96的Orthometric Height转换为了相对椭球面的Ellipsoidal Height，高程系统不一样所以同一位置高程当然会存在差异。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9963038536a15d789ceec9728ec6b1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e36a221419d9cc4aa5f5f1017976f605/" rel="bookmark">
			尺度空间和使用各向异性扩散进行边缘检测——Scale-Space and Edge Detection Using Anisotropic Diffusion
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.摘要 由Witkin引入的尺度空间技术涉及使用高斯核将原始图像与卷积以生成更粗糙的分辨率图像。这种方法有一个主要缺点：在粗糙的尺度上准确获取“语义上有意义”的边缘位置很困难。在本文中，我们提出了尺度空间的新定义，并引入了一类利用扩散过程实现此定义的算法。扩散系数的选择在空间上变化，以鼓励区域内平滑而不是区域间平滑。实验证明了常规尺度空间的“在粗糙的尺度上不应生成新的极大值”这一特性得到了保留。由于我们方法中的区域边界保持清晰，我们获得了一个成功利用全局信息的高质量边缘检测器。在多幅图像上展示了实验结果。该算法涉及到在图像上复制的基本局部操作，因此可以实现并行硬件实现。
索引词-自适应滤波，模拟VLSI，边缘检测，边缘增强，非线性扩散，非线性滤波，并行算法，尺度空间。
1.引言 从计算机视觉的早期，例如Rosenfeld和Thurston [20]，人们就开始意识到多尺度描述的重要性。这个问题的一个清晰的形式化方法是由Witkin [21]引入的尺度空间滤波的概念，并在Koenderink [11]，Babaud，Duda和Witkin [1]，Yuille和Poggio [22]以及Hummel [7]，[8]中进行了进一步的发展。这种方法的基本思想非常简单：将原始图像嵌入到一族派生图像I(x,y,t)中，这些图像是通过将原始图像Io(x,y)与方差为t的高斯核G(x,y;t)进行卷积得到的。
较大的尺度空间参数t对应于更粗糙分辨率的图像。请参见图1。正如Koenderink [11]和Hummel [7]所指出的那样，这一参数族的派生图像可以等价地看作是热传导或扩散方程的解。根据Koenderink的论述，扩散方程的公式化是基于两个准则：
1）因果关系：在粗糙的分辨率水平上，任何特征都需要在更细的分辨率水平上具有一个（不一定是唯一的）“原因”，尽管反过来不一定成立。换句话说，当分辨率降低时，不应该产生虚假的细节。
2）均匀性和各向同性：模糊处理需要具有空间不变性。这些准则自然地导致了扩散方程的公式化。值得注意的是，第二个准则仅仅是为了简化而陈述的。稍后我们将对此进行更详细的讨论。事实上，本文的主要主题是用更有用的内容替换这个准则。还应该注意，因果关系准则并不唯一地强制选择高斯进行模糊处理，尽管高斯是最简单的选择。Hummel [7]提出了一个重要的观察结果，即抛物型偏微分方程理论中的最大值原理的一个版本等效于因果关系。我们将在IV-A节中进一步讨论这个问题。本文的结构如下：第二节批评了标准的尺度空间范式，并提出了一组额外的准则来获得“语义上有意义”的多尺度描述。在第三节中，我们展示了通过允许扩散系数的变化可以满足这些准则。在IV-A节中，回顾了最大值原理，并用它来展示我们的方案如何满足因果关系准则。第五节展示了一些实验结果。第六节将我们的方案与其他边缘检测方案进行比较。第七节提出了一些结论性的评论。
图1. 通过将原始的一维信号（底部）与方差从底部到顶部逐渐增大的高斯核进行卷积得到的一族一维信号I(x,t)（改编自Witkin [21]）。
2.标准尺度空间范式的弱点 我们现在要考察标准尺度空间范式在需要"语义上有意义"的多尺度描述的视觉任务中的适用性。自然界中的表面通常具有分层的组织结构，由少量离散的层级组成[13]。在最细的层级上，一棵树由具有复杂脉络结构的叶子组成。在下一层级上，每片叶子被一个单一的区域所取代，而在最高层级上，有一个对应于树顶的单一斑块。每个描述层级都对应着一定的分辨率范围（尺度空间参数的区间）。此外，在每个描述层级上，区域（叶子、树顶或森林）都有明确定义的边界。在标准尺度空间范式中，粗糙尺度上边界的真实位置在粗糙尺度图像中并不直接可用。这在图2的一维示例中可以清楚地看到。粗糙尺度上的边缘位置与其真实位置有所偏移。在二维图像中，还存在另一个问题，即包含边缘绘制的大部分空间信息的边界交叉点被破坏。获取在粗糙尺度上检测到的边缘的真实位置的唯一方法是通过跟踪穿越尺度空间，找到它们在原始图像中的位置。这种技术证明是复杂且昂贵的[5]。
这种空间失真的原因非常明显，高斯模糊并不“尊重”对象的自然边界。假设我们有一张带有天空作为背景的树顶的图片。高斯模糊处理会导致树叶的绿色与天空的蓝色在树顶作为特征出现之前就被“混合”在一起（在树叶被模糊在一起之后）。图3显示了通过高斯模糊得到的一系列较粗的图像，说明了这一现象。还可以注意到，区域边界通常是模糊的，而不是清晰的。基于这一动机，我们提出了生成图像多尺度“语义上有意义”描述的候选范式必须满足的几项标准[18]：
因果性：正如Witkin和Koenderink指出的，尺度空间表示应该具有这样的特性，即从较细的尺度到较粗的尺度时不应产生虚假的细节。立即定位：在每个分辨率上，区域边界应该清晰，并与该分辨率上的语义上有意义的边界重合。分段平滑：在所有尺度上，应该优先进行区域内的平滑，而不是区域间的平滑。在前面提到的树的例子中，在与天空背景合并之前，叶子区域应该先被折叠成一个树顶。 图2. 边缘的位置（相对于x的Laplacian的零点）在图1的线性尺度空间中（改编自Witkin [21]）。图3. 通过各向同性线性扩散（离散8个最近邻实现的0.2.4,8,16,32次迭代）产生的尺度空间（尺度参数从上到下，从左到右递增）。与图12进行比较。
3.各向异性扩散 有一种简单的方法可以修改线性尺度空间范式，以实现我们在前一节中提出的目标。在尺度空间的扩散方程框架中，扩散系数c被假定为与空间位置无关的常数。并没有根本性的理由要求这样。引用Koenderink的话[11, p.3641]：“...我不允许空间变体模糊。显然这对问题并非必要，但它极大地简化了分析。”我们将展示如何选择适当的c(x, y, t)将使我们能够满足前一节中列出的第二和第三个标准。此外，在不牺牲因果性的情况下可以做到这一点。考虑各向异性扩散方程。
其中，我们用div表示散度算子，用V和A分别表示梯度和拉普拉斯算子，与空间变量相关。如果c(x, y, t)是一个常数，它会简化为各向同性热扩散方程I ,=cAZ。假设在时间（尺度）t上，我们知道适合该尺度的区域边界的位置。我们希望在区域内部而不是跨越边界进行平滑。这可以通过在每个区域内部设置导热系数为1，在边界上设置为0来实现。然后，模糊将在每个区域中单独进行，区域之间没有相互作用。区域边界将保持清晰。当然，我们事先不知道每个尺度上的区域边界（如果我们知道的话，问题已经解决了！）。可以计算的是适合该尺度的边界位置（边缘）的当前最佳估计。设E(x, y, t)是这样一个估计值：一个在图像上定义的矢量值函数，理想情况下应具有以下特性：
1）E(x, y, t)在每个区域的内部为0。
2）E(x, y, t)=Ke(x, y, t)在每个边缘点处，其中e是边缘上的法向量单位，K是边缘的局部对比度（左右图像强度的差异）。需要注意的是，上述中使用的边缘一词并未正式定义-我们在这里指的是感知主观概念中的边缘作为区域边界。一个完全令人满意的正式定义很可能是解决方案的一部分，而不是问题的定义！如果有一个估计值E(x, y, t)，则可以选择导热系数c(x, y, t)为一个关于E的大小的函数c=)IE 11 (x, y, t )g()IE 11 )。根据先前所述的策略，g()必须是一个非负的单调递减函数，且g(0)=1（见图4）。这样，扩散过程主要发生在区域的内部，并且不会影响E的大小较大的区域边界。直观上来说，扩散过程能否满足第II节中的三个尺度空间目标在很大程度上取决于估计E作为边缘位置的“猜测”的准确性。然而，准确性在计算上是昂贵的，需要复杂的算法。我们能够证明，幸运的是，亮度函数的最简单的边缘位置估计，即E(x, y, t)=VZ(x, y, t)，给出了出色的结果。g()有许多可能的选择，最明显的是一个二值函数。在下一节中，我们将展示，如果我们使用边缘估计E(x, y, t)=VZ(x, y, t)，那么g()的选择将受到一类单调递减函数的限制。
图4.非线性函数g(.)的定性形状
4.各向异性扩散的特性 首先，我们通过回顾偏微分方程理论中的一个普遍结果，即最大值原理，来证明各向异性扩散满足第II节的因果性准则。在第IV-B节中，我们将展示，如果扩散中的导热系数被选择为亮度函数梯度的大小的局部函数，即，如果函数g(.)被适当选择，不仅可以保持亮度边缘，还可以使其更加清晰。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e36a221419d9cc4aa5f5f1017976f605/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2cd4e3f3c6bf9d593f2dac584de14e/" rel="bookmark">
			二进制ply点云文件转ascii格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 ply点云格式转化方法 ply点云格式 有两种binary和ascii。其中，ascii格式通过Notepad++（或者其他文本查看软件），可以看到ply里面的内容，都是由点构成，如下图所示：
binary通过Notepad++（或者其他文本查看软件），可以看到ply里面的内容，都是由点构成，如下图所示：
所以有时候会需要转化一下。
转化方法 用cloudcompare 打开binary格式的ply文件。
1、点击需要转化的点云文件
2、然后点击 file,Save.。
3、在保存过程中，选择保存ascii格式即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be2fa9b7264478b6e05744b38e282adb/" rel="bookmark">
			一篇文章带你弄懂Kafka基本原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Kafka介绍
1、Kafka的定义
2、消息队列应用场景
3、Kafka结构
4、zk和Kafka
二、Kafka生产者
1、基本原理介绍
2、Kafka的异步发送
3、生产者分区原理
4、提高生产者吞吐，发送能力
5、生产者数据可靠性
6、生产者数据去重
7、消息有序
8、数据乱序
三、Kafka的broker
1、kafka的borker和zk的关系
2、broker总体流程
3、Kafka的副本
4、分区副本分配
5、手动调整分区
6、leader partition自动平衡
7、kafka文件存储（重要）
8、文件清除策略
9、Kafka如何保证高效读写
三、Kafka消费者
1、Kafka的消费方式
2、消费者组
3、消费者组初始化流程
4、消费者组消费流程
5、消费者消费分区分配和再平衡
6、offset维护位置
7、自动提交offset
8、制定offset来消费
9、重复消费和漏消费
10、数据积压
10、Kafka的Kraft模式（需要补充）
一、Kafka介绍 1、Kafka的定义 老定义：分布式的基于发布/订阅的消息队列，主要用于大数据实时处理，发布的消息分为不同的类别，订阅者只接收感兴趣的消息。
新定义：Kafka是一个开源的分布式事件流平台，高性能数据管道、流分析、数据集成和关键任务应用。
2、消息队列应用场景 缓冲消峰、解耦
3、Kafka结构 Kafka是分主题topic的，一个topic又分为多个broker，broker中有多个partition
一个partition的数据只能有一个消费者来消费，为了防止一个partition数据可能会丢失的风险，他也有partition副本的概念，每个partition分为leader和follower，生产和消费只会针对leader来进行0，follower只是负责数据同步的，只有leader挂掉之后，follower有机会变成leader。partition的leader和follower是不会存在同一个broker中的（为了防止一个borker宕机都丢失）
broke中的partition是只能增加不能减少的，因为消费者消费进度可能是不同的。
4、zk和Kafka 2.8以前必须要用zk搭配使用，zk负责记录整个集群中哪些broke运行的状态，上下线信息，也会记录leader相关信息，帮助选主。
2.8之后还可以karaft模式，随着kafka的不断发展，zk已经成为他的性能瓶颈。
二、Kafka生产者 1、基本原理介绍 首先producer调用send方法到Interceptors拦截器，然后到序列化器，partitioner分区器，然后分配到对应的队列里面，整个这些操作都是在内存里面完成的，每个分区在内存中都会对应一个队列方便管理，总内存的大小默认是32m，没一批次的大小是16k。
然后有个专门的sender线程去读取缓冲队列中的消息然后发送到集群，每批次的数据满了16k之后才会开始拉取数据，或者达到了一定的毫秒数，也会拉取（批次大小达到16k或达到时间）默认是0毫秒，也就是缓冲大小没用了，来一条就发一条，没有延迟，也可以自己设置时间。
拉取是以节点的方式来拉取的，每个内存队列都是一个节点，以这个为key，然后value是数据，发送到对应的broker，然后根据参数来看是直接返回ack还是leader收到返回还是全部接受才返回。
拉取发送的时候是允许还没有应答继续发的，比如现场拉去队列1到broker1，他前面那个没ack还是可以发送后面的，但是最多只有5个，直到有应答了才能发，最多缓冲5个；应答级别0表示生产者发送数据，不需要数据落盘应答，1leader收到后应答，-1 all要leader和isr队列所有节点收集后才应答。
2、Kafka的异步发送 只要把消息放到内存队列就代表有了，后期都是由sender线程异步去拉取不需要等kafka集群ack
有带回调的异步发送，发送完成之后可以给我们返回：主题、分区等信息，发到缓存队列里面，缓存队列返回的。
同步发送：需要发送到队列之后，等待sender发送到kafka集群，然后返回ack就清楚队列才能发送下一批，如果没有发送到kafka还需要重试，所以效率很低。在异步方法调用后加个get就是同步了。
3、生产者分区原理 发送先走拦截器，序列化器，然后分区器，然后就会到队列了。分区器可以合理使用存储资源，把每个pratition在一个broker上存储，把海量数据切割成一块块存储到多个broker上，合理的分区可以实现负载均衡。可以提高并行度，以分区为单位发送数据，消费者可以以分区为单位进行消费数据。
默认是defaultParttioner分区器，如果你指定了分区规则就用自己的，如果没有就会根据patition的数量根据key的hash去映射。如果没有partition也没有key值，那就粘性分区发往一个满了再建
4、提高生产者吞吐，发送能力 批量发送：默认的应答级别为0表示来一个在队列就拉取一个，这样效率很低，我们可以设置批次大小，然后时间修改了，等批次大小满了再发也可以异步发送分区并行压缩消息 5、生产者数据可靠性 应答模式acks是0，这种就是不需要等数据落盘，应答直接继续发，这种是最不可靠的，生产环境一般不用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be2fa9b7264478b6e05744b38e282adb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ee7d35c77f0cb7e09298a6830d6b88/" rel="bookmark">
			STM32物联网项目——TM1620驱动数码管显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序功能：
TM1620
这里主要说说关于TM1620指令与数据传输，其他概述等内容详细见TM1620手册：
链接：https://pan.baidu.com/s/1C4I_oy9n9QjSPu8UD-FJRg 提取码：9ec0 --来自百度网盘超级会员V2的分享
TM1620一共有4条指令：
(1) 显示模式命令设置： 该指令用来设置选择段和位的个数（4～6 位,8～10 段）。当该指令被执行时,显示被强制关闭。在显示模式不变时,显存内的数据不会被改变,显示控制命令控制显示开关。
本项目使用的是6位8段的数码管，即0x020。
(2) 数据命令设置： 该指令用来设置数据写和读,B1和B0位不允许设置01或11。
(3) 显示控制命令设置： 该指令用来设置显示的开关以及显示亮度调节。共有8级辉度可供选择进行调节。 (4) 地址命令设置： 该指令用来设置显示寄存器的地址。 最多有效地址为12位(00H-0BH)。上电时,地址默认设为00H。
▲注意：芯片显示寄存器在上电瞬间其内部保存的值可能是随机不确定的,此时我们直接发送开屏命令,将有可能出现显示乱码。所以建议对显示寄存器进行一次上电清零操作,即上电后向12位显存地址（00H-0BH）中全部写入数据0x00。具体操作方法是：初始化TM1620时使用（2）数据命令中的自动地址增加命令，依次给所有地址写0x00.
串行数据传输格式
空闲时，时钟和STB线均被拉高；STB线拉低，准备发送数据；CLK线拉低，此时准备数据位，之后拉高CLK线，发送数据（在CLK上升沿发送数据），循环此步骤8次，可发送1Byte数据。
两种地址模式的传输
两种模式的区别就是发送数据时，固定地址模式必须先发送地址地址命令，才能发送数据，而地址增加模式不用。
强调：起始地址命令字发送完毕,“STB”不需要置高紧跟着传数据,最多14BYTE,数据传送完毕才将“STB”置高。
数码管
本项目使用的是共阴极数码管，即单片机发送高电平点亮。
若想让数码管显示“0”字样，只需要向00H（GRID1）地址中从低位开
始写入0x3F数据点亮相应的段选位，低位到高位依次对应图中的a、b、c、d、e、f、g、dp或SEG1~SEG8。
数码管位选与地址关系如图：
即GRID1的低4位为00HL，高4位为00HU...
功能实现
硬件电路：
TM1620的STB、CLK、DIN引脚分别连接单片机的PC0、PC1、PC2引脚。
初始化：
初始化TM1620的3个输出引脚：
初始化Key1按键引脚并在NVIC中打开外部中断0：
代码部分：
定义结构体类型：
typedef struct { Brightness_level_t Brightness; void (*TM1620_Init)(void); //TM1620初始化 void (*Disp)(Disp_NUM_t,uint8_t,Disp_DP_Status_t); //数码管显示 } Display_t; 还定义了6个枚举，分别定义了显示模式、写数据地址模式、辉度等级、显示寄存器地址、数码管编号、小数点状态（即数码管dp段），这里就不一一列举。
写入字节函数：
/* * @name TM1620_Write_Byte * @brief TM1620写入字节 * @param dat -&gt; 待写入数据 * @retval None */ static void TM1620_Write_Byte(uint8_t dat) { uint8_t i = 0; CLR_STB; for(i=0;i&lt;8;i++) { CLR_CLK; //准备数据位 if((dat &amp; BIT0) == BIT0) //BIT0为宏定义，为0x01 SET_DIN; else CLR_DIN; dat = dat &gt;&gt; 1; //移位，为发送下一位做准备 //拉高CLK，发送数据	SET_CLK;	__nop(); }	} TM1620初始化函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27ee7d35c77f0cb7e09298a6830d6b88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbc5859e6be87ee72886038523912917/" rel="bookmark">
			Luogu P4107 [HEOI2015] 兔子与樱花
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：传送门
对于每个点来说，它的权重分为两部分，一部分是子树大小，一部分是自身的点权。很明显是要从叶子节点开始删除，因为只有从下往上处理我们才能知道这个点子树的所有情况。一个点的点权是不会消失的，只会转移到自己的上层节点上，所以说要想删除更多的节点，就要在 m m m的限制内按权值从小到大删除子节点。
在输入就可以时处理好每个点的权重，也就是 w [ i ] = s i z [ i ] + c [ i ] w[i]=siz[i]+c[i] w[i]=siz[i]+c[i]。之后从叶子节点开始向上删除。遍历一个点 f r fr fr的所有子节点 i i i，将它们按权重从小到大排序，对每个子节点 i i i，判断 w [ f r ] − 1 + w [ i ] &lt; = m w[fr]-1+w[i]&lt;=m w[fr]−1+w[i]&lt;=m，也就是是否可以删除这个子节点，从小到大排序能保证删除最多的子节点，若上式成立，则删除子节点 i i i，并更新 f r fr fr的权值 w [ f r ] w[fr] w[fr]（少了一个子节点，权值的增加量为 w [ i ] w[i] w[i]，总变化量为 w [ i ] − 1 w[i]-1 w[i]−1）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbc5859e6be87ee72886038523912917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2856525763649a222e1aac8cafae88f1/" rel="bookmark">
			从56%到6%‼️怎么写论文才能减少重复率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天来聊聊怎么写论文才能减少重复率，希望能给大家提供一点参考。
以下是针对论文重复率高的情况，提供一些修改建议和技巧：
写论文时，减少重复率的方法有很多种，以下是一些建议：
一、怎么写论文才能减少重复率呢 二、论文怎样写才能减少重复率 三、论文写作怎样减少重复率 四、论文怎么能降低重复率 五、怎样论文减少重复率 六、论文如何减少重复率 七、怎样写论文才会降低重复率 理解论文主题和研究领域：在撰写论文之前，需要充分理解论文主题和研究领域。了解论文主题和研究领域的背景信息、研究现状和研究目的等，可以帮助你更好地理解论文中需要讨论和阐述的内容，从而避免简单地复制或重复他人的研究。创新性的研究内容和结构：创新是避免论文重复的关键。在撰写论文时，应该提出新的观点、方法和结论，同时要合理安排论文的结构和内容。在阐述研究目的时，应该从不同的角度和方面进行论述，同时要注意论文的逻辑性和连贯性。引用和参考文献管理：正确引用和参考文献管理是避免论文重复的重要措施。在撰写论文时，应该明确标注引用的观点、数据或信息，并列出完整的参考文献。同时，在引用他人的研究时，应该注明引用的内容、方式和原因。这样可以避免被认定为抄袭或自我重复。避免使用直接复制粘贴的方式：在撰写论文时，应该避免使用直接复制粘贴的方式。如果需要引用他人的研究或数据，应该进行适当的改写和加工，以避免被查重平台认定为抄袭。例如，可以通过改变语句的结构和表达方式、使用同义词替换等方法来降低重复率。合理使用表格、图表和数据：表格、图表和数据是论文中容易出现重复率的部分。在撰写论文时，应该合理使用表格、图表和数据，并尽量避免简单地复制或重复他人的研究。例如，可以通过改变表格、图表和数据的表达方式、增加新的数据和方法等方法来降低重复率。 八、写论文如何降低重复率 总之，写论文时，需要从多个方面入手，尽量避免重复率的出现。通过理解论文主题和研究领域、创新性的研究内容和结构、正确引用和参考文献管理、避免使用直接复制粘贴的方式以及合理使用表格、图表和数据等方法，可以降低论文的重复率，提高论文的质量和原创性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e04bc6c91d33a767835c4d0c229051/" rel="bookmark">
			ArcGIS Pro 3.0学习版安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、官网下载Microsoft.net SDK 6.0 https://dotnet.microsoft.com/zh-cn/download/dotnet/6.0
下载后直接管理员安装即可。
2、安装ArcGISPro_30_zh_CN_182227.exe 首先会解压安装包文件 ，之后执行程序。这里解压的安装包文件，最后解压文件可以删掉。之后一直下一步
3、复制dll文件，运行reg文件，复制licensing文件 有的文件可能会隐藏，从显示里面修改，显示隐藏的文件。
首先复制dll文件到安装路径下，默认路径是：C:\Program Files\ArcGIS\Pro\bin
之后运行reg文件
最后复制liensing文件夹到：C:\Users\ 用户名 \AppData\Local
4、安装语言包等其他需要的内容 包括中文文件包、数据转换拓展模块等等，可以用得到的时候再安装
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e54e85771e2e7b2be4e6b70caefeb68f/" rel="bookmark">
			PCB放置过孔技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		合理的放置过孔能有效的节约面积。
我们根据嘉立创的pcb工艺能力中写出单双面板最小过孔为0.3mm(内径)/0.5mm(外径)
设置过孔尺寸外直径为24mil（0.61mm））内直径为12mil（0.305mm）
嘉立创PCB工艺加工能力范围说明-嘉立创PCB打样专业工厂-线路板打样 (jlc.com)
那么在此基础下我们应如何进行布局呢？
类似于蛇形走形的方法进行布局可以减少过孔的占用长度。当布置8个过孔时，蛇形的布局所需长度为4.1mm，而直线布局为5.3mm。蛇形布局只需要原长度的77.4%。大大节约了空间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/630c64886ed04fbd7a65a515b6bd97aa/" rel="bookmark">
			页表 页表项 页表大小等相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何计算页表大小如何计算页表项大小如何计算页表项位数 在计算机发展过程中, 有很多内容是逐步添加到计算机中的. 由于主存并不是可持续增大的, 人们需要考虑成本和其他一些因素, 所以人们想出了使用虚拟内存来增加存储, 一部分虚拟内存在计算机内部划分了物理地址, 另一部分虚拟内存和主存之间是需要通过虚拟接口连接, 计算机将数据暂时存储在外部的磁盘存储器中, 但是如何解决续存和主存的数据交互, 这里就用到了页表
页表和Cache-主存体系中的地址映射存储器很类似. 主要是页表项和标识位构成
页表项是一排关于主存信息的东西,比如主存的位数啊, 主存从哪里开始啊之类的
页表大小是使用 页表项的个数 * 页表项的位数(+1) 计算的
页表项个数 = 虚拟内存大小 / 页面大小 (页面大小并非是页表大小, 页表是页面内的一个映射表
页表项大小 = 主存内存大小(物理地址大小) / 页面大小 页表项位数 = log页表项大小 (eg: 页表项大小为2^10, 那么页表项位数就是10)
计算页表大小的时候通常使用页表项位数+1 表示页表项真实位数, 这一个1是标识位, 表示此处页表项生效, 也就是有主存地址对应虚拟地址
ps: 网上的一些观点不好评价,我的观点也不一定是对的, 仅提供一个思路
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e759bc5581741150c639aa7dd9041e89/" rel="bookmark">
			srand()函数，C语言中的一个随机数生成函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		srand()函数是C语言中的一个随机数生成函数，它用于设置随机数生成器的种子。随机数生成器是一个算法，可以生成一个随机数序列。这个算法基于一个称为种子的初始值，通过对种子进行一系列的计算得到随机数序列。
使用srand()函数可以改变随机数生成器的种子值。如果不使用srand()函数，随机数生成器的种子默认为1。每次程序执行时，如果种子相同，那么生成的随机数序列也是相同的。
srand()函数的原型如下：
void srand(unsigned int seed);
参数seed是一个无符号整数，用于设置随机数生成器的种子值。通常情况下，可以使用当前时间作为种子值，以确保每次程序执行时都生成不同的随机数序列。例如：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;
#include &lt;time.h&gt; int main() { // 设置种子为当前时间 srand((unsigned) time(NULL)); // 生成随机数 int randomNum = rand(); printf("Random number: %d\n", randomNum);
return 0; }
在上面的例子中，首先包含了三个头文件：stdio.h、stdlib.h和time.h。然后使用time(NULL)函数获取当前时间，并将其作为种子值传递给srand()函数。最后，使用rand()函数生成一个随机数，并将结果打印出来。
需要注意的是，srand()函数只需要在程序的开头调用一次即可，之后的每次调用rand()函数都会生成一个新的随机数。在实际应用中，通常将srand()函数的调用放在程序的初始化部分，而不是在随机数生成的地方调用。这样可以确保每次程序执行时都使用不同的种子值，从而生成不同的随机数序列。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b16eeb40fbaad7cb6db65e061dac2c/" rel="bookmark">
			[NOIP2010 提高组] 乌龟棋
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[NOIP2010 提高组] 乌龟棋 题目背景 小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。
题目描述 乌龟棋的棋盘是一行 N N N 个格子，每个格子上一个分数（非负整数）。棋盘第 1 1 1 格是唯一的起点，第 N N N 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。
乌龟棋中 M M M 张爬行卡片，分成 4 4 4 种不同的类型（ M M M 张卡片中不一定包含所有 4 4 4 种类型的卡片，见样例），每种类型的卡片上分别标有 1 , 2 , 3 , 4 1,2,3,4 1,2,3,4 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。
游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。
很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。
现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？
输入格式 每行中两个数之间用一个空格隔开。
第 1 1 1 行 2 2 2 个正整数 N , M N,M N,M，分别表示棋盘格子数和爬行卡片数。
第 2 2 2 行 N N N 个非负整数， a 1 , a 2 , … , a N a_1,a_2,…,a_N a1​,a2​,…,aN​，其中 a i a_i ai​ 表示棋盘第 i i i 个格子上的分数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78b16eeb40fbaad7cb6db65e061dac2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/204311b61b839839e7d951a1268f61af/" rel="bookmark">
			C语言编译与链接过程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言编译与链接过程详解 源文件 main.c #include &lt;stdio.h&gt; extern int data; extern int add(int a,int b); int a1; int a2 = 0; int a3 = 10; static int b1; static int b2 = 0; static int b3 = 20; int main() { int c1; int c2 = 0; int c3 = 30; static int d1; static int d2 = 0; static int d3 = 40; c1 = data; c2 = add(a1,a2); while(1); return 0; } add.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/204311b61b839839e7d951a1268f61af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf6d04eeab48d9ac68f3902434035cce/" rel="bookmark">
			基于51单片机的音乐喷泉彩灯proteus仿真原理图PCB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能：
0.本系统采用STC89C52作为单片机
1.彩灯由8个LED组成，喷泉由5V小水泵模拟
2.音乐信号通过ADC0832采集到单片机，单片机通过信号幅度的大小来调节喷泉和彩灯的工作，从而实现音乐喷泉彩灯节奏协同
4.采用DC002作为电源接口可直接输入5V给整个系统供电
原理图：
PCB ：
主程序：
#include &lt;reg52.h&gt; #include "main.h" #include "tlc0832.h" unsigned char dat; unsigned char h1; void main() { while(1) { Fountain(); } } void Delay(unsigned char z) { unsigned char y; for (; z &gt; 0; z--) for (y = 5; y &gt; 0; y--) ; } void Fountain(void) { dat = ReadADC(AIN0_GND); //检测AD值，音量越大值越小 dat = (dat&gt;128)?128:dat; //去掉大于128的数据 dat = 128 - dat; //处理AD值，以使音量越大，dat值越大 h1 = 128 - dat; //处理h1值 WATERPUMP = 1; //关闭水泵 Delay(h1); if(h1&gt;40) LED0=1; else LED0=0; //ad值对比 点亮相应的灯 if(h1&gt;50) LED1=1; else LED1=0;	//ad值对比 点亮相应的灯 if(h1&gt;60) LED2=1; else LED2=0;	//ad值对比 点亮相应的灯 if(h1&gt;70) LED3=1; else LED3=0;	//ad值对比 点亮相应的灯 if(h1&gt;80) LED4=1; else LED4=0;	//ad值对比 点亮相应的灯 if(h1&gt;90) LED5=1; else LED5=0;	//ad值对比 点亮相应的灯 if(h1&gt;100) LED6=1; else LED6=0;	//ad值对比 点亮相应的灯 if(h1&gt;110) LED7=1; else LED7=0;	//ad值对比 点亮相应的灯 WATERPUMP = 0; //开启水泵 Delay(dat+10); //加10是为了使喷泉达到喷发临界值 } ADC代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf6d04eeab48d9ac68f3902434035cce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3415758b29eee2fbd163359d38f15e2d/" rel="bookmark">
			基于STM32单片机的智能水表水流量计原理图PCB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能：
0.本系统采用STM32F103C8T6作为单片机
1.该系统采用LCD1602液晶显示各种参数，包括瞬时流量速度，已经总流量，同时可通过按键设置最大阈值，一旦流量超过该值将启动报警
2.报警电路采用的是蜂鸣器和LED组成的声光报警系统
3.系统具有三个功能按键，同时具备蓝牙功能，可以与手机通信传输当前的流量信息
4.采用DC002作为电源接口可直接输入5V给整个系统供电
5.系统具备一路继电器来驱动水泵，水泵可通过软管与流量传感器相接，从而实现流量的检测
原理图：
PCB ：
主程序：
#include "led.h" #include "delay.h" #include "sys.h" #include "usart.h" #include &lt;stdio.h&gt; #include "timer.h" #include "key.h" #include "bsp_lcd1602.h" #include "exti.h" #define ON 0 #define OFF 1 char dis0[18]; //显示暂存数组 unsigned long plu = 0; //脉冲计数 float shunShiVal = 0; //瞬时流量mL/s float leiJiVal = 0;	//累计流量mL float leiJiValMax = 1000; //累计最大流量mL unsigned char dealLiuliang = 0; //流量处理 unsigned char sendDelay = 0; //流量处理 unsigned char i; unsigned char relayFlag1 = 1; //继电器标志1 unsigned char relayFlag2 = 1; //继电器标志2 void CheckKey(void); int main(void) { NVIC_Configuration(); UART_Init(9600);	//串口初始化为9600 TIM3_Int_Init(50000-1, 72-1); // 50ms LED_Init(); //初始化与LED连接的硬件接口 KEY_Init(); EXTIX_Init(); //外部中断初始化 LCD_GPIO_Init(); LCD_Init(); LCD_Clear(); LCD_DispStr(4,0,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3415758b29eee2fbd163359d38f15e2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3dccc0b7b6998e183a31815c93c505d/" rel="bookmark">
			基于STM32单片机的智能家居窗户窗帘控制系统红外遥控proteus仿真原理图PCB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能：
0.本系统采用STM32F103RCT6作为单片机
1.LCD1602液晶实时显示当前时间/窗帘状态/光照强度
2.支持手动按键/定时/光强检测三种模式控制窗帘
3.'设置’键进入设置界面
4.默认状态下’确定’键可切换模式
5.设置界面’确定’为确定
6.支持掉电保存
7.采用DC002作为电源接口可直接输入5V给整个系统供电
原理图：
PCB ：
主程序：
/************************************************************* 智能窗帘 补充说明： ***************************************************************/ #include "reg52.h" #include "LCD1602.h" #include "DS1302.h" #include "28BYJ48.h" #include "eeprom52.h" #include "tlc0832.h" #include "infrared.h" #include "delay.h" #define uchar unsigned char //宏定义 #define uint unsigned int /*******************引脚定义*********************/ sbit KEY_MODE = P3^3; //设置键 sbit KEY_ADD = P3^4; //加值键 sbit KEY_SUB = P3^6; //减值键 sbit KEY_ENTER = P3^5; //确定键 sbit BUZZER = P2^0; //蜂鸣器 sbit SW1 = P1^3; //全开 限位开关 /*******************变量定义*********************/ uchar light_up = 80; uchar light_down = 30; //存储光强上、下限值 uchar set_f = 0; //设置选择标记，=0非设置，=1设置年，=2设置月，=3设置日，=4设置时，=5设置分，=6设置秒 // =7设置定时-时，=8设置定时-分，=9设置定时-开关，=10设置窗帘打开/关闭 //	=11设置光强上限，=12设置光强下限，=13设置校准窗帘位置 unsigned char dis[10] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}; uchar num; //计数变量 uchar ds[4] = {8, 30, 16, 20}; //定时控制开时、分、控制关时、分 uchar mode = 0; //模式标记。=0手动，=1定时，=2光控 uchar light; //存储光强 uint moto_num = 0; //记录窗帘位置 uchar motor_state = 0; //窗帘状态，=0已经关闭，=1处于运转过程中，=2已经打开 bit moto_f = 0; //标记当前控制状态，=0控制关，=1控制开 uchar code display_mode[3][3] = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3dccc0b7b6998e183a31815c93c505d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7235736a801dc273fb38ee1ff475383a/" rel="bookmark">
			Maven下载源码出现：Cannot download sources Sources not found for org.springframwork...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven下载源码出现：Cannot download sources Sources not found for org.springframwork… 最近重装了IDEA再次查看源码时发现总是报错，网上找了很多，发现解决方法都是在项目终端执行如下命令：
mvn dependency:resolve -Dclassifier=sources 好多人都可以，但是我的不可以
解决方法 问题出现原因，是目构建工具 Maven 的主路径消失了，或者说被 IDEA 改了，然后导致匹配不到下载的执行文件。所以需要把Maven主路径重新设置一下，构建成如下即可解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7363022dba074829691bd5e30664dd33/" rel="bookmark">
			查看进程里面各线程占用CPU的情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发中，当我们遇到CPU飙高的时候，想要知道是哪个线程在搞事情，就需要查看进程里面各线程占用CPU的情况，这个命令就可以帮助我们。
执行命令：
ps H -eo pid,tid,%cpu |grep 2266
2266为java进程id
执行结果如图（可以看出2276占用cpu很高），
那怎么看这个2276在我们代码所在呢，其实可以使用jstack命令查看栈信息，但是所看到里面的线程id是16进制的，这里的2276是十进制，要找到2276所对应的16进制id在哪里就需要做一个转换，再拿这个16进制去匹配就可以了，具体做法：
2276十进制转16进制，运行命令：
printf "%x \n" 2276
得到的8e4就是16进制
在执行命令：jstack 2266
d打印的信息如图，在里面就可以看见8e4对应的线程（8e4前面的0x代表的16进制）
在这个图中，可以看到这个线程id对应的代码里面报了Application.java的第9行有问题，那么再去看自己的代码就行了。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/86/">«</a>
	<span class="pagination__item pagination__item--current">87/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/88/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>