<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35deca1e8e128dfa540b8d21dfab8a71/" rel="bookmark">
			Java中timeZone 的可用ID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中通过TimeZone getTimeZone(String ID) 方法可以获取各种不同时区，
其中可的用所有ID.
Etc/GMT+12
Etc/GMT+11
MIT
Pacific/Apia
Pacific/Midway
Pacific/Niue
Pacific/Pago_Pago
Pacific/Samoa
US/Samoa
America/Adak
America/Atka
Etc/GMT+10
HST
Pacific/Fakaofo
Pacific/Honolulu
Pacific/Johnston
Pacific/Rarotonga
Pacific/Tahiti
SystemV/HST10
US/Aleutian
US/Hawaii
Pacific/Marquesas
AST
America/Anchorage
America/Juneau
America/Nome
America/Yakutat
Etc/GMT+9
Pacific/Gambier
SystemV/YST9
SystemV/YST9YDT
US/Alaska
America/Dawson
America/Ensenada
America/Los_Angeles
America/Tijuana
America/Vancouver
America/Whitehorse
Canada/Pacific
Canada/Yukon
Etc/GMT+8
Mexico/BajaNorte
PST
PST8PDT
Pacific/Pitcairn
SystemV/PST8
SystemV/PST8PDT
US/Pacific
US/Pacific-New
America/Boise
America/Cambridge_Bay
America/Chihuahua
America/Dawson_Creek
America/Denver
America/Edmonton
America/Hermosillo
America/Inuvik
America/Mazatlan
America/Phoenix
America/Shiprock
America/Yellowknife
Canada/Mountain
Etc/GMT+7
MST
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35deca1e8e128dfa540b8d21dfab8a71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e1fe75d037fb4a212068a667ac407a/" rel="bookmark">
			路由中的管理距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		管理距离定义 管理距离是一种对路由选择信息的可信度进行排序的方法。管理距离是一个0-255的证书，值越小可信度越高。尽管管理距离可以配置为1-9，但是他们被保留内部使用，不推荐使用他们。 默认的管理距离 在默认情况下，各种路由选择协议都有自己的默认管理距离，但是可以手动修改。 路由选择协议 默认管理距离 直连接口 0 指向接口的静态路由 0 指向下一条的静态路由 1 EIGRP汇总路由 5 外部BGP 20 内部EIGRP 90 IGRP 100 OSPF 110 ISIS 115 RIP 120 外部网关协议(EGP) 140 按需路由选择(ODR) 160 外部EIGRP 170 内部BGP 200 修改管理距离 一、修改静态路由的管理距离 ip route 192.168.1.0 255.255.255.0 s1/0 10 二、修改EIGRP路由协议的管理距离 1、修改默认的内部EIGRP和外部EIGRP的管理距离 rotuer eigrp 100 distance eigrp 12 67 前面为内部EIGRP，第二个为外部EIGRP 2、修改EIGRP具体路由的管理距离 router eigrp 100 distance 20 0.0.0.0 255.255.255.255 12 20为修改后的AD,0.0.0.0 255.255.255.255 表示匹配任何IP，12是访问控制列表，该访问控制列表控制到达远程的网络。 三、修改OSPF路由的管理距离 1、修改OSPF默认的管理距离 router ospf area 0 distance ospf inter-area 12 intra-area 12 external 12 inter-area 表示区域内部路由，intra-area表示区域间路由，external表示区域外的路由，冲发布进来的路由 2、修改OSPF具体路由的管理距离 这个和上面修改EIGRP具体路由的管理距离语法类似 转载于:https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6e1fe75d037fb4a212068a667ac407a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ffd02d24c138c31498252019bcfc45b/" rel="bookmark">
			Redis安装整理(window平台和Linux平台)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[b]window平台Redis安装 [/b] [b]redis windows安装文件下载地址[/b]:[url]http://code.google.com/p/servicestack/wiki/RedisWindowsDownload#Download_32bit_Cygwin_builds_for_Windows[/url] 我选择的redis为最新版的安装文件，见下图： [img]http://dl.iteye.com/upload/attachment/0065/8339/76cba281-426f-3be8-b739-089269408eae.jpg[/img] [b]Redis安装文件解压后，有以下几个文件。见下图[/b] [img]http://dl.iteye.com/upload/attachment/0065/8335/9992dac5-202b-3c46-b712-bb43e4eb66e5.jpg[/img] redis-server.exe：服务程序 redis-check-dump.exe：本地数据库检查 redis-check-aof.exe：更新日志检查 redis-benchmark.exe：性能测试，用以模拟同时由N个客户端发送M个 SETs/GETs 查询 (类似于 Apache 的ab 工具). 在解压好redis的安装文件到E:\根目录后，还需要在redis根目录增加一个redis的配置文件redis.conf，文件具体内容附件中有，不过这里我仍然把配置文件的内容贴上来： # Redis configuration file example
# By default Redis does not run as a daemon. Use 'yes' if you need it.
# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
daemonize no
# When run as a daemon, Redis write a pid file in /var/run/redis.pid by default.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ffd02d24c138c31498252019bcfc45b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ff2c0318f251b68d8cb8b0fa9d625a2/" rel="bookmark">
			手把手教你用C#编写一个简单的文本编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，打开你的开发工具Microsoft visual studio 2005。文件——》新建项目——》项目类型选择visualc#，模板选择windows 应用程序，到此我们已经创建好一个window窗体了！
接着修改窗体的属性，窗体名字修改为EditorForm，窗体的text属性修改为你要的命名。在工具箱了选择MenuStrip控件如图，把菜单拖到窗体去!
然后选择插入标准项
插入完菜单之后，再从工具箱里拖一个RichTextBox到菜单下面，然后选择停靠父容器，最后一个简单的编辑器的界面出来了！如图：
-----------------------------------------------------------------------------------------------------------------------------------------
好了，界面我们已经设计好了，现在我们来实现功能了！首先从工具箱里面拖一个叫做openFileDialog的控件，这是一个用于打开文件的对话框来的，把这个拖到窗体，然后点击一下OpenFileDialog选定此控件，设置Filter属性默认文本(*.txt)|*.txt|富文本文件(*.rtf)|*.rtf 。当然以后功能扩充后，可以打开别的文件，例如设置Filter的属性为括号里的（数据库文件(*.dat)|*.dat|图像文件(*jpg;*bmp;*gif)|*jpg;*bmp;*gif|文本文件(*.txt)|*.txt|所有文件(*.*)|*.*）。（注意，次数是用于打开文件对话框对要打开的文件进行筛选的，我们这里只是做简单的文本编译器，所以支持的格式分别是.txt 和.rtf格式的文本），最后双击菜单的打开菜单出现
private void 打开OToolStripMenuItem_Click(object sender, EventArgs e) { //确定用户选择了文件 if (this.openFileDialog.ShowDialog() == DialogResult.OK) { //得到用户选择的文件路径和文件名 path = this.openFileDialog.FileName; //读取文件内容 this.LoadFile(); } } private void LoadFile() { if (this.openFileDialog.FilterIndex == 1) { //纯文本文件 this.richTextBox1.LoadFile(path, RichTextBoxStreamType.PlainText); } if (this.openFileDialog.FilterIndex == 2) { this.richTextBox1.LoadFile(path, RichTextBoxStreamType.RichText); } } 我们要在里面写代码实现把PC机上的文件打开到我们的编辑器中进行简单的文字编译了，但是在写代码前，我们要定义一个全局变量，用于记录是否文件是新建的，还是打开来编辑的，我们要把这个变量定义为 string path = null ; 附上所有代码
刚刚学习不久，功能没有完全的实现
using System; using System.Collections.Generic; using System.ComponentModel; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ff2c0318f251b68d8cb8b0fa9d625a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c875d6327c5dbe923f5a5a7a8037a4f/" rel="bookmark">
			Android获取SharedPreferences三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android数据持久化方法中最简单的一种，即使用Preferences的键值对存储方式。这种方式主要用来存储比较简单的一些数据， 而且是标准的Boolean、Int、Float、Long、String等类型。
android.content.SharedPreferences是一个接口，用来获取和修改持久化存储的数据。
有三种获取系统中保存的持久化数据的方式：
1.this.getPreferences (int mode)
通过Activity对象获取，获取的是本Activity私有的Preference，保存在系统中的xml形式的文件的名称为这个Activity的名字，因此一个Activity只能有一个，属于这个Activity。
2.this.getSharedPreferences (String name, int mode)
因为Activity继承了ContextWrapper，因此也是通过Activity对象获取，但是属于整个应用程序，可以有多个，以第一参数的name为文件名保存在系统中。
3.PreferenceManager.getDefaultSharedPreferences(this);
PreferenceManager的静态函数，保存PreferenceActivity中的设置，属于整个应用程序，但是只有一个，Android会根据包名和PreferenceActivity的布局文件来起一个名字保存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a812595293fd43b348088949e3a351f/" rel="bookmark">
			oracle安装sqlplus的help帮助系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用sqlplus的时候可以通过help或?获得帮助信息，那么这些帮助信息是哪来的呢？
其实sqlplus的帮助信息从是 数据库里表(system.help)里获取的。在$ORACLE_HOME/sqlplus/admin/help 目录下的helpus.sql文件里包含的帮助的信息，不过 oracle默认带的帮助信息太少，自己可以通过其它途径获取更全的帮助脚本。那么我们自己如何来 安装帮助呢？下面以系统自带的脚本为例来演示安装过程。 所有用的 sql脚本都保存在 $ORACLE_HOME/sqlplus/admin/help 目录下，包含了四个文件：helpbld.sql helpdrop.sql helpus.sql hlpbld.sql，第一个helpbld.sql实际是调用第四个脚本hlpbld.sql来进行安装的，helpdrop.sql是删除help表和HELP_TEMP_VIEW视图的脚本，helpus.sql是安装的帮助信息。如果自己找到其它更全的脚本也放到这个目录下，便于 管理。 因为help表是存在于oracle数据库里的，所以我们要保证oracle数据库已经启动，而且安装了sqlplus。之后以system身份登录在执行安装脚本helpbld.sql或hlpbld.sql均可。我们在执行脚本的时候需要输入两个参数 SQL&gt; @ ?/sqlplus/admin/help/helpbld.sql Enter value for 1: $ORACLE_HOME/sqlplus/admin/help Enter value for 2: $ORACLE_HOME/sqlplus/admin/help/helpus.sql Enter value for 1: 帮助系统脚本所在目录 Enter value for 2: 帮助系统内容脚本 运行后sqlplus的help帮助系统就装好了。 也可以用另外方法安装，设置环境变量 SYSTEM_PASS=SYSTEM/ password EXPORT SYSTEM_PASS 然后运行$ORACLE_HOME/bin/helpins脚本也实现安装。 其实上面所有的安装过程都可以通过helpins脚本分析得到。内容如下可以读一遍自然晓得其中奥秘。 附录： [oracle@rhel5 bin]$ cat helpins : # # Copyright (c) 1988, 2003, Oracle Corporation. All rights reserved. # # NAME # helpins # # DESCRIPTION # Script.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a812595293fd43b348088949e3a351f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58cc25b65eb72b256053a2a4f9cf1478/" rel="bookmark">
			&#34;error while loading shared libraries: xxx.so.x&#34; 错误的原因和解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般我们在Linux下执行某些外部程序的时候可能会提示找不到共享库的错误, 比如:
tmux: error while loading shared libraries: libevent-1.4.so.2: cannot open shared object file: No such file or directory
原因一般有两个, 一个是操作系统里确实没有包含该共享库(lib*.so.*文件)或者共享库版本不对, 遇到这种情况那就去网上下载并安装上即可. 另外一个原因就是已经安装了该共享库, 但 执行需要调用该共享库的程序的时候, 程序按照默认共享库路径找不到该共享库文件. 所以安装共享库后要注意共享库路径设置问题, 如下: 1) 如果共享库文件安装到了/lib或/usr/lib目录下, 那么需执行一下ldconfig命令 ldconfig命令的用途, 主要是在默认搜寻目录(/lib和/usr/lib)以及动态库配置文件/etc/ld.so.conf内所列的目录下, 搜索出可共享的动态链接库(格式如lib*.so*), 进而创建出动态装入程序(ld.so)所需的连接和缓存文件. 缓存文件默认为/etc/ld.so.cache, 此文件保存已排好序的动态链接库名字列表. 2) 如果共享库文件安装到了/usr/local/lib(很多开源的共享库都会安装到该目录下)或其它"非/lib或/usr/lib"目录下, 那么在执行ldconfig命令前, 还要把新共享库目录加入到共享库配置文件/etc/ld.so.conf中, 如下: # cat /etc/ld.so.conf include ld.so.conf.d/*.conf # echo "/usr/local/lib" &gt;&gt; /etc/ld.so.conf # ldconfig 3) 如果共享库文件安装到了其它"非/lib或/usr/lib" 目录下, 但是又不想在/etc/ld.so.conf中加路径(或者是没有权限加路径). 那可以export一个全局变量LD_LIBRARY_PATH, 然后运行程序的时候就会去这个目录中找共享库. LD_LIBRARY_PATH的意思是告诉loader在哪些目录中可以找到共享库. 可以设置多个搜索目录, 这些目录之间用冒号分隔开. 比如安装了一个mysql到/usr/local/mysql目录下, 其中有一大堆库文件在/usr/local/mysql/lib下面, 则可以在.bashrc或.bash_profile或shell里加入以下语句即可: export LD_LIBRARY_PATH=/usr/local/mysql/lib:$LD_LIBRARY_PATH 一般来讲这只是一种临时的解决方案, 在没有权限或临时需要的时候使用.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58cc25b65eb72b256053a2a4f9cf1478/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f0bf8cb8a8b0cb7e2fa0fd3a1ab1ae/" rel="bookmark">
			linux下trap命令和SIGHUP信号量详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		trap命令用于指定在接收到信号后将要采取的动作。常见的用途是在脚本程序被中断时完成清理工作。不过，这次我遇到它，是因为客户you个需求：从终端访问服务器的用户，其登陆服务器后会自动运行某个命令，例如打开应用（命令写在.bashrc等文件中），最后退出，并断开连接；期间是不能允许其使用Ctrl+C等中断退出应用，而回到Shell环境，否则可能会带来安全问题。
当然，解决de方式有很多，如在应用中屏蔽中断信号、使用chroot方式访问等。但这些方法都you一些限制，如需要修改应用，让telnet等支持chroot方式（ssh可支持chroot）等。而使用trap也是一种比较好的解决方法。
一、关于信号
历史上，shell总是用数字来代表信号，而新de脚本程序应该使用信号de名字，它们保存在用#include命令包含进来designal.h头文件中，在使用信号名时需要省略SIG前缀。
kill和trap等都可以看到信号编号及其关联de名称。“信号”是指那些被异步发送到一个程序de事件。默认情况下，它们通常会终止一个程序de运行。
引用
# trap -l
1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL
5) SIGTRAP 6) SIGABRT 7)SIGBUS 8) SIGFPE
9) SIGKILL 10) SIGUSR1 11)SIGSEGV 12) SIGUSR2
13) SIGPIPE 14) SIGALRM 15)SIGTERM 17) SIGCHLD
18) SIGCONT 19) SIGSTOP 20)SIGTSTP 21) SIGTTIN
22) SIGTTOU 23) SIGURG 24)SIGXCPU 25) SIGXFSZ
26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29)SIGIO
30) SIGPWR 31) SIGSYS 34)SIGRTMIN 35) SIGRTMIN+1
36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39)SIGRTMIN+5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f0bf8cb8a8b0cb7e2fa0fd3a1ab1ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/777c72b415d3a43acf2811f447990987/" rel="bookmark">
			转：profibus dp和pa有什么差别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DP /PA : 通信速率：一个是高度；一个是低速；
ＤＰ：设备一级的，高速数据传输；
转自：
profibus dp和pa的差别在物理层。它们都能从现场设备存取相同的数据。
profibus dp 可以直接整合到simatic plc，但你必须使用耦合器（coupler)才能将profibus　pa转换成profibus　dp信号。
profibus dp 提供最高12 mbit/s (mag6000 and mass6000 只支持1.5 mbit/s) 的通信速率，但profibus pa 只有一个固定的通信速率 31,25kbit/s.
profibus pa 可应用于本安等防爆场合，但profibus　dp不能
profibus-dp：用于设备级控制系统与分散式i/o的通信。它的设计旨在用于设备一级的 高速数据传送。
profibus-pa：专为过程自动化设计，可使传感器和执行机构联在一根总线上，并有本质安全规范。
profibus dp和pa在应用方面的区别，大家解释的非常清楚，下面是它们在物理层方面的区别：
（1）dp采用rs485电气标准，两根电缆仅传输数据，不能供电；
pa采用iec1158-2 mbp-is标准，两根电缆除了传输数据外，还可以为仪表供电；
（2）传输速率方面，
dp可以是9.6k、19.2k、45.45k、93.75k、187.5k、1.5m、3m、6m、12m；
pa只能为31.25k；
（3）编码方面，
dp为nrz,即不归零编码；
pa为manchester，即曼彻斯特编码；
（4）数据格式方面，
dp为基于字符的异步传输方式，每个字符包括11位，即1个起始位、8个数据位、1个停止位和1个奇偶校验位；
pa为基于帧的同步传输方式，每次发送一个数据帧；
（5）数据校验方面，
dp为1 bit的奇偶校验；
pa为16 bit的crc校验； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c497341323637c3e1fed5026488d1e0f/" rel="bookmark">
			CENTOS下搭建SVN服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装svn yum install -y subversion 2.验证安装是否成功 svnserve --version 3.创建svn版本库 mkdir svn svnadmin create svn/repo 注：repo是版本库名称 4.配置svn 创建版本库后，在这个版本库的conf目录下会生成3个配置文件：
[root@singledb conf]# pwd /root/svn/repo/conf [root@singledb conf]# ls authz passwd svnserve.conf 说明：
（1）svnserve.conf： svn服务综合配置文件。 （2）passwd： 用户名口令文件。
（3）authz： 权限配置文件。
4.1 修改passwd文件 [users] shang=123456 li=123456 注：shang为用户名，123456为密码
4.2配置可使用明文密码 vi /$HOME/.subversion/servers #找到以下内容，注释去掉并改成yes就行了 store-plaintext-passwords = yes 4.3修改authz文件 [groups] team=shang,li [repo:/] @team=rw 注：repo为之前建立的svn版本库名称 4.4修改svnserve.conf [general] anon-access = none auth-access = write password-db = passwd authz-db = authz 5.启动和停止svn 5.1启动svn svnserve -d -r /root/svn/ 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c497341323637c3e1fed5026488d1e0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a59b1283c604c6452b9ecb3c8b8beebc/" rel="bookmark">
			stdafx.h和int _tmain(int argc, _TCHAR* argv[])
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stdafx.h和int _tmain(int argc, _TCHAR* argv[]) 以下内容摘自百度知道：
stdafx.h = Standard Application Fram Extend
没有函数库，只是定义了一些环境参数，使得编译出来的程序能在32位的操作系统环境下运行。
Windows和MFC的include文件都非常大，即使有一个快速的处理程序，编译程序也要花费相当长的时间来完成工作。由于每个.CPP文件都包含相同的include文件，为每个.CPP文件都重复处理这些文件就显得很傻了。
为避免这种浪费，AppWizard和VisualC++编译程序一起进行工作，如下所示：
◎AppWizard建立了文件stdafx.h，该文件包含了所有当前工程文件需要的MFCinclude文件。且这一文件可以随被选择的选项而变化。
◎AppWizard然后就建立stdafx.cpp。这个文件通常都是一样的。
◎然后AppWizard就建立起工程文件，这样第一个被编译的文件就是stdafx.cpp。
◎当VisualC++编译stdafx.cpp文件时，它将结果保存在一个名为stdafx.pch的文件里。(扩展名pch表示预编译头文件。)
◎当VisualC++编译随后的每个.cpp文件时，它阅读并使用它刚生成的.pch文件。VisualC++不再分析Windowsinclude文件，除非你又编缉了stdafx.cpp或stdafx.h。
这个技术很精巧，你不这么认为吗？(还要说一句，Microsoft并非是首先采用这种技术的公司，Borland才是。)在这个过程中你必须遵守以下规则：
◎你编写的任何.cpp文件都必须首先包含stdafx.h。
◎如果你有工程文件里的大多数.cpp文件需要.h文件，顺便将它们加在stdafx.h(后部)上，然后预编译stdafx.cpp。
◎由于.pch文件具有大量的符号信息，它是你的工程文件里最大的文件。
如果你的磁盘空间有限，你就希望能将这个你从没使用过的工程文件中的.pch文件删除。执行程序时并不需要它们，且随着工程文件的重新建立，它们也自动地重新建立。 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int _tmain(int argc, _TCHAR* argv[])
与 int main(int argc, char *argv[])
类似，可以接收命令行位置参数
_TCHAR 可以接收 中文等双字节编码字符书写的命令行。
_tmain 中文等双字节编码 编码 主程序名
当然兼容 单字节编码 ASCII码 程序. ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
类似的答案：
int main( int argc[ , char *argv[ ] );
argc：
整型，指示随后的argv中参数的个数；
argv：
代表运行后接的参数 补充：argv[0]存的是文件本身名字字符串。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66ff4e55a94542944f853e3fce51f24/" rel="bookmark">
			AFX_MANAGE_STATE(AfxGetStaticModuleState())讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前写MFC的DLL的时候，总会在自动生成的代码框架里看到提示，需要在每一个输出的函数开始添加上AFX_MANAGE_STATE(AfxGetStaticModuleState())。一直不明白这样做的含义，也一直没有这样做，而且代码也工作得好好的，所以感觉这好像一句废话。
最近的项目中，需要在DLL里使用MFC生成界面，这才发现一旦资源放在不同的动态库里，而且还和多线程搅和在一起的时候，事情就变得异常的复杂，以前对MFC的一知半解已经不足与应付了。程序莫名的崩溃，莫名的ASSERT，资源怎样也装载不起来，为什么呢？每次，总是尝试着，在每一个线程的开始，把AFX_MANAGE_STATE(AfxGetStaticModuleState())添加上去，或者在某些地方用 AfxSetResourceHandler()一把，然后问题就解决了，但是不是很明白到底是怎么回事，总感觉这种解决办法让人很不安心，仿佛在下一秒问题又会突然冒出来。
前天，这个问题终于发挥到了极致，任我花费了好几个小时，怎样的尝试都不能成功，在项目的关键时候发生这种事情，让我暗暗发誓以后再也不用MFC了。正像很多的电影情节一样，事情最后还是得到了解决，这次我决定不能再这么算了，一定要把这个事情理解得明明白白。
在这里，我遇到的问题就是，如何让DLL里的界面代码使用该DLL的资源（Resource），如何在工作线程里加载有IE控件的对话框？
我问同事，他们是如何实现DLL资源切换的？AFX_MANAGE_STATE(AfxGetStaticModuleState())这就是他们的答案，一如微软的推荐，原来就是这么简单啊！让我们来看看，这句代码到底做了什么？
#define AFX_MANAGE_STATE(p) AFX_MAINTAIN_STATE2 _ctlState(p);
AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(AFX_MODULE_STATE* pNewState)
{
m_pThreadState = _afxThreadState;
m_pPrevModuleState =m_pThreadState-&gt;m_pModuleState;
m_pThreadState-&gt;m_pModuleState =pNewState;
}
_AFXWIN_INLINE AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2()
{ m_pThreadState-&gt;m_pModuleState = m_pPrevModuleState; }
原来，就是定义一个局部的对象，利用其构造和析构函数在函数的入口和函数的出口进行State状态的切换，我猜AfxGetStaticModuleState()一定是获取当前代码所在DLL的State。
果然，请看
static _AFX_DLL_MODULE_STATE afxModuleState;
AFX_MODULE_STATE* AFXAPI AfxGetStaticModuleState()
{
AFX_MODULE_STATE* pModuleState =&amp;afxModuleState;
return pModuleState;
}
class _AFX_DLL_MODULE_STATE : public AFX_MODULE_STATE
// AFX_MODULE_STATE (global data for a module)
class AFX_MODULE_STATE : public CNoTrackObject
{
...
CWinApp* m_pCurrentWinApp;
HINSTANCE m_hCurrentInstanceHandle;
HINSTANCE m_hCurrentResourceHandle;
LPCTSTR m_lpszCurrentAppName;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a66ff4e55a94542944f853e3fce51f24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a76a43070aaf649e246f181400f64c/" rel="bookmark">
			c&#43;&#43;位运算符 | &amp;  ^  ~ &amp;&amp; ||,补码，反码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：简介 1 位逻辑运算符：
&amp; （位 “与”） and ^ （位 “异或”） | （位 “或”） or ~ （位 “取反”） 2 移位运算符： &lt;&lt;（左移） &gt;&gt;（右移）
优先级
位“与”、位“或”和位“异或”运算符都是双目运算符，其结合性都是从左向右的，优先级高于逻辑运算符，低于比较运算符，且从高到低依次为&amp;、^、| 二：位逻辑运算 &amp; 运算 ----------------------- -2个都为1-》1 0&amp;1 =0; 0&amp;0 =0; 1&amp;0 =0; 1&amp;1 =1;
00111
&amp; =00100
11100
&amp;运算通常用于二进制取位操作，例如一个数 &amp;1的结果就是取二进制的最末位。
这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数是偶数，最末位为1表示该数为奇数
----------------------------------------------------------------- | 运算---------------------------1个为1--》1
0|0=0; 0|1=1; 1|0=1; 1|1=1;
00111
| =11111
11100
| 运算通常用于二进制特定位上的无条件赋值，例如一个数|1的结果就是把二进制最末位强行变为1
如果需要把二进制最末位变成0，对这个数 |1之后再减一就可以了，其实际意义就是把这个数强行变成最近接的偶数
--------------------------------------------------------------------
^ 运算---------------------------不同则为1，相同则为0 // 当且仅当两个运算值中有一个为1但不同时为1时，返回值为1
0^1=1；
1^0=1；
1^1=0；
0^0=0；
00111
^ =11011
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a76a43070aaf649e246f181400f64c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/607473a0cf89f5b51b2318c9301959c8/" rel="bookmark">
			视频码率,帧率和分辨率的联系与区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频码率,帧率和分辨率到底哪一个影响电影的清晰度
码率：影响体积，与体积成正比：码率越大，体积越大；码率越小，体积越小。
码率就是数据传输时单位时间传送的数据位数,一般我们用的单位是kbps即千位每秒。也就是取样率（并不等同与采样率，采样率的单位是Hz，表示每秒采样的次数），单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件体积与取样率是成正比的，所以几乎所有的编码格式重视的都是如何用最低的码率达到最少的失真，围绕这个核心衍生出来cbr（固定码率）与vbr（可变码率）， “码率”就是失真度，码率越高越清晰，反之则画面粗糙而多马赛克。
下面是通过一个wav文件的采样率来计算码率和文件大小，通过MediaInfo工具显示的文件信息如下：
概要
完整名称 :audio\wav\adele-rolling_in_the_deep.wav
文件格式 : Wave
文件大小 : 38.3 MiB
长度 : 3分 47秒
平均混合码率 : 1 411 Kbps
音频
ID : 0
文件格式 : PCM
格式设置,Endianness : Little
编码设置ID : 1
编码设置ID/提示信息 : Microsoft
长度 : 3分 47秒
码率 : 1 411.2 Kbps
声道 : 2声道
采样率 : 44.1 KHz
位深度 : 16位
大小 : 38.3 MiB (100%)
1.码率计算公式：
码率=采样率 x 位深度 x 声道
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/607473a0cf89f5b51b2318c9301959c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/849447c082f50cac8e56f8d6c08ffed1/" rel="bookmark">
			JSON(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//第一个案例：java转换成JSON字符串
@Test
public void fromObject(){
//将java对象转换成JSON字符串
Teacher teacher=new Teacher();
teacher.setName("aa");
teacher.setSex("男");
teacher.setAge(28);
teacher.setBirth(new Date());
//JSON字符串
//{name:"aa",sex:"男",age:"28",birth:"...."}
//需要引入类库文件
System.out.println(JSONObject.fromObject(teacher));
}
{"age":28,"birth":{"date":28,"day":2,"hours":9,"minutes":32,"month":1,"seconds":5,"time":1330392725328,"timezoneOffset":-480,"year":112},"name":"aa","sex":"男"}
//将java集合转换成JSON字符串
@Test
public void fromVector(){
List&lt;Teacher&gt; teas=new ArrayList&lt;Teacher&gt;();
for(int i=0;i&lt;3;i++){
Teacher teacher=new Teacher();
teacher.setName("aa");
teacher.setSex("男");
teacher.setAge(28);
teacher.setBirth(new Date());
teas.add(teacher);
}
//teas集合
System.out.println(JSONArray.fromObject(teas).toString());
}
[{"age":28,"birth":{"date":28,"day":2,"hours":9,"minutes":29,"month":1,"seconds":18,"time":1330392558562,"timezoneOffset":-480,"year":112},"name":"aa","sex":"男"},{"age":28,"birth":{"date":28,"day":2,"hours":9,"minutes":29,"month":1,"seconds":18,"time":1330392558562,"timezoneOffset":-480,"year":112},"name":"aa","sex":"男"},{"age":28,"birth":{"date":28,"day":2,"hours":9,"minutes":29,"month":1,"seconds":18,"time":1330392558562,"timezoneOffset":-480,"year":112},"name":"aa","sex":"男"}]
// JSON字符串转换为对象
@Test
public void fromJsonObject() {
// 第一步：定义成字符串
String teaObj = "{\"age\":28,\"birth\":{\"date\":28,\"day\":2,\"hours\":9,\"minutes\":20,\"month\":1,\"seconds\":25,\"time\":1330392025906,\"timezoneOffset\":-480,\"year\":112},\"name\":\"aa\",\"sex\":\"男\"}";
// 第二步：使用JsonObject.fromObject方法将其字符串转换为JsonObject对象
JSONObject jsonObj = JSONObject.fromObject(teaObj);
// 第三步：调用JsonObject的toBean的方法，将其转换成一个Object对象
Teacher teac = (Teacher) JSONObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/849447c082f50cac8e56f8d6c08ffed1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b2d8528d27fa0ab15fc250c976b0a93/" rel="bookmark">
			Oracle快捷版 Oracle XE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天给大家推荐一款轻量级Oracle数据库,即Oracle10G快捷版(Oracle XE)。 相对于庞大的原正式版来说，快捷版只有206MB大，而且可以安装在自己电脑上，跑起来也并不影响速度，可用于个人的开发和学习，觉得很方便，不用再去安装正式版的那些大家伙了。。。 官方下载地址，速度挺快的： Oracle服务端官方下载地址： http://download.oracle.com/otn/nt/oracle10g/xe/10201/OracleXEUniv.exe Oracle客户端官方下载地址： http://download.oracle.com/otn/nt/oracle10g/xe/10201/OracleXEClient.exe 下面是从其它地方Copy过来的介绍： oracle10g的家族的最轻量级成员——Oracle Database 10g Express Edition (Oracle Database XE)。可别以为它是Oracle家族的什么新宠，它早在2005年底就问世了，只是知道的人和应用的人比较少，至少我听说它的时候，身边的同事还没几个知道的。为什么会这样呢？因为它只是Oracle公司推出的一款供Oracle学习者免费使用的限制版数据库，供专业人员在学习及应用开发的起步阶段使用。所以并没有引起大家的广泛关注。不过对于这种轻量级的oracle我个人倒是觉得很有应用价值——尤其对于应用开发人员来说更是如此。 随着Oracle Database XE的推出，甲骨文现有的产品系列扩充为六个版本：Oracle Enterprise Edition、Oracle Standard Edition(SE)、Oracle Standard Edition One(SE 1)、Oracle Personal Edition、Oracle Database Lite和免费的Oracle Database XE。 由于XE的免费性，只需登陆Oracle官网即可下载到它http://www.oracle.com/technology/products/database/xe。Oracle XE的安装主要包括两套组件，Server and Client。没什么好说，这和oracleDB历来的产品没什么两样。如果想在单机运行oracle数据库，只要安装一个server就好了，他同时兼具了client的全部功能。如果非要练练远程访问数据，大不了在另外的机器上装个client玩吧。整个安装过程不过几分钟的，不愧是express。 说到轻量级，Oracle XE对OS的要求到底低到什么程度呢？看一下官方的文档说得很清楚， 可是就像减肥很痛苦一样，轻量级是付出了很大代价的。XE的官方文档里也特别说明了这款DB的主要Restrictions： # 至多使用1个CPU或1个双核CPU的处理能力； # 最多可使用1GB内存; # 每个操作系统上只能安装一份实例; # 最多存储4GB的用户数据。 伴随XE的发布，Oracle同时提供了详尽的说明文档和手册，以及有关oracle的学习资料，有时间慢慢研究吧。这里只提醒大家一点，在win 上安装XE一定要以系统管理员角色登陆，并保证网络连接正常。如果你是域用户登陆的，请先切换至本地Administrator登陆。在XE安装完成后，如果想在域用户登陆的情况下使用它，只要将oraclexe\app\oracle\product\10.2.0\server\NETWORK \ADMIN\sqlnet.ora文件中的SQLNET.AUTHENTICATION_SERVICES = (NTS)改为SQLNET.AUTHENTICATION_SERVICES = (NONE)即可。补充一点，win上安装XE之前，请先删除ORACLE_HOME这个环境变量（如果存在的话）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b05cbd41a9a76259d8e2695b4f8e56c/" rel="bookmark">
			getpy() 汉字转为拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;%
'取字段数据每个汉字的拼音首字母
Function getpychar(char)
tmp = 65536 + Asc(char)
If(tmp&gt;= 45217 And tmp&lt;= 45252) Then
getpychar = "A"
ElseIf(tmp&gt;= 45253 And tmp&lt;= 45760) Then
getpychar = "B"
ElseIf(tmp&gt;= 47761 And tmp&lt;= 46317) Then
getpychar = "C"
ElseIf(tmp&gt;= 46318 And tmp&lt;= 46825) Then
getpychar = "D"
ElseIf(tmp&gt;= 46826 And tmp&lt;= 47009) Then
getpychar = "E"
ElseIf(tmp&gt;= 47010 And tmp&lt;= 47296) Then
getpychar = "F"
ElseIf(tmp&gt;= 47297 And tmp&lt;= 47613) Then
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b05cbd41a9a76259d8e2695b4f8e56c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/873bc32a38a94c93e1d8ac68bf68ab97/" rel="bookmark">
			VB如何执行命令 打开资源管理器 并选择指定的文件夹或文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Option ExplicitPrivate Sub Command1_Click()Dim cmd As String'*打开资源管理器 焦点 在【MyDotNetFiles】文件夹cmd = "cmd /k explorer /select,d:\MyDotNetFiles"'*打开资源管理器 焦点 在【sn_office2007.txt】文件'cmd = "cmd /k explorer /select,d:\sn_office2007.txt"Call Shell(cmd)End Sub作者：段利庆（Lee） QQ：14035344
一卡通水电暖专家 http://www.duanliqing.kudos.cc/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb984b1416d9fae011008ebad15c052/" rel="bookmark">
			Android 获取AndroidManifest.xml文件versionCode，versionName属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android 获取AndroidManifest.xml文件versionCode，versionName属性 String pName = "cn.nedu.math.ninebox";
try {
PackageInfo pinfo = getPackageManager().getPackageInfo(pName, PackageManager.GET_CONFIGURATIONS);
String versionCode = pinfo.versionName;
Strint versionName = pinfo.versionCode;
} catch (NameNotFoundException e) {
}
AndroidManifest.xml文件如下 &lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="cn.nedu.math.ninebox"
android:versionCode="1"
android:versionName="1.0"&gt;
&lt;application android:icon="@drawable/icon" android:label="@string/app_name"&gt;
&lt;activity android:name=".NineBox"
android:label="@string/app_name"&gt;
&lt;intent-filter&gt;
&lt;action android:name="android.intent.action.MAIN" /&gt;
&lt;category android:name="android.intent.category.LAUNCHER" /&gt;
&lt;/intent-filter&gt;
&lt;/activity&gt;
&lt;/application&gt;
&lt;uses-sdk android:minSdkVersion="3" /&gt;
&lt;/manifest&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f85917ca3cddaae5f8f77431615ebe7/" rel="bookmark">
			CAsyncSocket进行UDP通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAsyncSocket进行UDP通信 客户端代码：
CString m_ServerIP;
CString m_ClientIP;
int m_ClientPort;
CString m_ReceiveData;
UINT m_ServerPort;
CAsyncSocket m_sockReceive;
m_ServerIP="127.0.0.1";
m_ClientIP="127.0.0.1";
m_ClientPort=6665;
m_ServerPort=6666;
void CSocketUDPClientDlg::OnReceive() {
// TODO: Add your control notification handler code here
UpdateData(TRUE);
if (m_sockReceive.Create(m_ClientPort,SOCK_DGRAM,NULL))
{
m_sockReceive.Bind(m_ClientPort,m_ClientIP);
SetTimer(1,2000,NULL);
GetDlgItem(IDC_RECEIVE)-&gt;EnableWindow(FALSE);
GetDlgItem(IDC_STOP)-&gt;EnableWindow(TRUE);
}
else
{
AfxMessageBox("创建套接字失败");
}
}
void CSocketUDPClientDlg::OnStop() {
// TODO: Add your control notification handler code here
KillTimer(1);
m_sockReceive.Close();
m_ReceiveData="停止接收数据";
UpdateData(FALSE);
GetDlgItem(IDC_RECEIVE)-&gt;EnableWindow(TRUE);
GetDlgItem(IDC_STOP)-&gt;EnableWindow(FALSE);
}
void CSocketUDPClientDlg::OnTimer(UINT nIDEvent) {
// TODO: Add your message handler code here and/or call default
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f85917ca3cddaae5f8f77431615ebe7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eb99188402f792f22b99598d8e26df6/" rel="bookmark">
			Android中JNI编程的那些事儿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说明，Android系统不允许一个纯粹使用C/C++的程序出现，它要求必须是通过Java代码嵌入Native C/C++——即通过JNI的方式来使用本地（Native）代码。因此JNI对Android底层开发人员非常重要。
如何将.so文件打包到.APK
让我们 先 从最简单的情况开始，假如已有一个JNI实现——libxxx.so文件，那么如何在APK中使用它呢？
在我最初写类似程序的时候，我会将libxxx.so文件push到/system/lib/目录下，然后在Java代码中执行System.loadLibrary(xxx)，这是个可行的做法，但需要取得/system/lib 目录 的写权限（模拟器通过adb remount取得该权限）。但模拟器 重启之 后libxxx.so文件会消失。现在 我找到了更好的方法，把.so文件打包到apk中分发给最终用户，不管是 模拟器 或者 真机 ，都不再需要system分区的写权限。实现步骤如下：
1、在你的项目根目录下建立libs/armeabi目录；
2、将libxxx.so文件copy到 libs/armeabi/下；
3、此时ADT插件自动编译输出的.apk文件中已经包括.so文件了；
4、安装APK文件，即可直接使用JNI中的方法；
我想还需要简单说明一下libxxx.so的命名规则，沿袭Linux传统，lib&lt;something&gt;.so是类库文件名称的格式，但在Java的System.loadLibrary(" something ")方法中指定库名称时，不能包括 前缀—— lib，以及后缀——.so。
准备编写自己的JNI模块
你一定想知道如何编写自己的xxx.so，不过这涉及了太多有关JNI的知识。简单的说：JNI是Java平台定义的用于和宿主平台上的本地代码进行交互的“Java标准”，它通常有两个使用场景：1.使用(之前使用c/c++、delphi开发的)遗留代码；2.为了更好、更直接地与硬件交互并 获得更高性能 。你可以通过以下链接了解JNI的更多资料：
Java Native Interface Developer Guides Java Native Interface Specification Java本地接口(JNI)基本功能 Book：JNI Programmer's Guide and Specification JNI之Hello World
1、首先创建含有native方法的Java类：
Java代码 package com.okwap.testjni; public final class MyJNI { //native方法, public static native String sayHello(String name); } 2、通过javah命令生成.h文件，内容如下(com_okwap_testjni.h文件)：
C代码 /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9eb99188402f792f22b99598d8e26df6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1858e455f622a3703ad33cd62db67559/" rel="bookmark">
			合并排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己编写的合并排序
/* name: merge-sort.c * usage: realize merge sort * writer: shangliuyan * * description: * * merge_sort(A,b,e) *	m&lt;-(b+e)/2 *	if b&lt;e *	merg_sort(A,b,r) *	merg_sort(A,m+1,e) *	merge(A,b,m,e) * * merge(A,b,m,e) * n1&lt;-m-b+1 * n2&lt;-e-m * i&lt;-j&lt;-0 * while(i&lt;=n1) * L1[i]&lt;-A[b+i] * i++ * while(i&lt;=n1) * L2[j]&lt;-A[m+j] * j++ * m&lt;-b * i&lt;-j&lt;-0 * for m to e * if i&gt;n1-1 * while j&lt;=n2-1 *	A[m++]&lt;-L2[j++] *	break *	if j&gt;n2-1 *	while i&lt;=n1-1 *	A[m++]&lt;-L1[i++] *	break * if L1[i]&lt;L2[j] * A[m]=L1[i] * i++ * else * A[m]=L2[j] * j++	* * * * */ #include&lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1858e455f622a3703ad33cd62db67559/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5218d4d70dd88b9f3dec280eb1d78c57/" rel="bookmark">
			编程珠玑番外篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Plan 9 的八卦
在 Windows 下喜欢用 FTP 的同学抱怨 Linux 下面没有如 LeapFTP 那样的方便的工具. 在苹果下面用惯了 Cyberduck 的同学可能也会抱怨 Linux 下面使用 FTP 和 SFTP 是一件麻烦的事情. 其实一点都不麻烦, 因为在 LINUX 系统上压根就不需要用 FTP. 为什么呢? 因为一行简单的配置之后, 你就可以像使用本机文件一样使用远程的任何文件. 无论是想编辑, 查看还是删除重命名, 都和本机文件一样的用. 这么神奇的功能到底如何使用呢, 待我一一道来.
首先, 如果你的内核版本是 2.6.14 或者更新(uname -r 可以查看你的内核版本), 你的机器上的已经有了这个支持了. 在这种情况下, 你可以使用:
sudo modprobe fuse
激活内核模块. 然后, 比如说, 你想SSH远程 remote.com 上的 /dir 目录, 作为本机的 ldir 目录, 你可以使用:
sshfs name@remote.com:/dir /ldir
然后, 您就可以完全在 ldir 目录下操作任何的远程机器上的文件了. 是不是很简单 :)
如果要使用 ftp, 我们要使用一个叫做 curlftpfs 的开源软件.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5218d4d70dd88b9f3dec280eb1d78c57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41afe395ecde5461bd3c28334324d333/" rel="bookmark">
			URL编码以及GET和POST提交乱码解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是URL编码。
URL编码是一种浏览器用来打包表单输入的格式，浏览器从表单中获取所有的name和其对应的value，将他们以name/value编码方式作为URL的一部分或者分离的发送到服务器上。
2. URL编码规则。
每对name/value由&amp;分开，每对来自表单的name/value用=分开。如果用户没有输入值的那个name依旧会出现不过就是没有值。
URL编码是在字符ASCII码的十六进制数的前面加上%。例如\（她的十六进制数表示为5c）的URL编码就是%5c。
3. 简单介绍乱码和http请求
其实做web开发乱码问题是经常出现的，有了上面编码的基础之后下面来看看乱码。
1) 乱码问题是web开发过程中经常遇到的问题，主要原因就是URL中使用了非ASCII码造成服务器后台程序解析出现乱码的问题。
2) URL中最容易出现中文的地方就是在QueryString的参数值还有Servletpath中。
3) 简单用一个图来说明一下http请求的流程：
第一步：浏览器把URL经过编码送给服务器；
第二步：服务器把这些请求解码处理完毕之后将显示的内容进行编码发送给客户端浏览器；
第三步：浏览器按照指定的编码显示网页
4) 详细剖析GET提交如何编码以及服务器如何解码以及乱码解决方案
对于GET方式，我们知道它的提交是将请求数据附加到URL后面作为参数，这样依赖乱码就会很容易出现，因为数据name和value很有可能就是传递的为非ASCII码。
当URL拼接后，浏览器对其进行encode，然后发送到服务器。具体规则见URL编码规则。
这里详细说一下encode的过程中容易出现的问题，在这个过程中我们要明白需要URL encode的字符一般都是非ASCII码字符，所以我们就能知道出现乱码主要是URL中附加了中文或特殊字符做成的，另一个要知道URL encode到底是以什么样的编码方式对字符进行编码的，其实这个编码方式是由浏览器决定的，不同的浏览器和同一浏览器的不同设置影响了URL的编码，所以为了避免我们不需要的编码，我们可以通过java代码或javaspcript代码统一进行控制。
完成了URL encode之后URL就成了ASCII范围内的字符了，然后就以iso-8859-1的编码方式转换为二进制随着请求头一起发送出去。
到了服务器之后，首先服务器会先用iso-8859-1进行解码，服务器获取的数据都是ASCII范围内的请求头字符，其中请求URL里面带有参数数据，如果是中卫或特殊字符，那么encode后的%XY（编码规则中的十六进制数）通过request.setCharacterEncoding()是不管用的。这时候我们就能发现出现乱码的根本原因就是客户端一般是通过用UTF-8或GBK等对数据进行encode的，到了服务器却用iso-8859-1方式decoder显然不行。
这里的解决方式有两种，
一种：是通过String类的getBytes方法进行编码转换，具体java代码是：
new String(request.getParameter(“name”).getBytes(“iso-8859-1”),“客户端编码方式”)
第二种：在服务器xml代码中改配置信息：
&lt;Connector port="8080"protocol="HTTP/1.1" maxThreads="150" connectionTimeout="20000"
redirectPort="8443"URIEncoding="客户端编码"/&gt;
5) 详细剖析POST提交如何编码以及服务器如何解码以及乱码解决方案
对于POST方式，表单中的参数值对是通过request包发送给服务器，此时浏览器会根据网页的ContentType("text/html; charset=GBK")中指定的编码进行对表单中的数据进行编码，然后发给服务器。
在服务器端的程序中我们可以通过
Request.setCharacterEncoding()设置编码，然后通过
request.getParameter获得正确的数据。
这里出现乱码可以通过Request.setCharacterEncoding()直接解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc8ecaf9147eecc0836856f0388e70b/" rel="bookmark">
			F2C用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		f2c是一个能将Fortran程序转换成c程序的软件和库，其官网为http://www.netlib.org/f2c/。
官网中的资源如下：
f2c.1：f2c程序使用手册
f2c.pdf：介绍了转换的原理
libf2c.zip（combined libf77, libi77, with several makefile variants）：利用命令行nmake -f makefile.vc编译，得到一个vcf2c.lib。
mswin：下载win32下的命令行程序f2c.exe，用这个程序来转换文件。
src：没有下载，估计是f2c.exe的源代码
readme：没仔细看，瞄了一眼，仿佛是介绍如何编译f2c.exe和libf2c。
使用的大体过程：
1）用f2c.exe将f程序转成c程序
2）先加上f2c.h头文件的引用和链接vcf2c.lib库，编译链接c程序
可参考http://blog.chinaunix.net/u/6140/showart_313600.html和http://www.stat.rice.edu/~helpdesk/howto/Fortran-Dll-SPlus-R.txt
f2c完整源代码(126KB)
f2c的mswin平台命令行(131KB)
f2c使用说明
f2c更新记录
其实f2c的使用方法非常简单：
f2c [	option ... ] file ... 一般option取默认即可，如 f2c romform.f 。
需要注意的是，fortran的文件后缀必须是.f或者.F，.for是不认的，而且严格执行72列的限制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d34f47cbfee3b3c4925fc2d2fea2c8c/" rel="bookmark">
			将窗体上的滚动条设置位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 void MainWindow::ToOri() { m_view-&gt;verticalScrollBar()-&gt;setSliderPosition(0); m_view-&gt;horizontalScrollBar()-&gt;setSliderPosition(0); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c5f3a5b5b46fa3aab56fc7bcc47ba49/" rel="bookmark">
			数学  11  12
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数学 11 12 17小时前 2012届同心圆梦专题卷数学专题十一答案及解析 1．【命题立意】本题以等差数列的定义立意，主要考查等差数列定义，中项公式，或者性质． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）建立3个字母的方程；（2）把a,b用x表示． 【答案】C【解析】依题意得，所以，即，于是有． 2．【命题立意】本题主要考查数列中与的关系，通项公式的求法以及解方程思想． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）利用求的方法；（2）利用通项公式求数列 的项；（3）解方程的思想方法． 【答案】A【解析】由可得，因此，即，解得，故选A． 3．【命题立意】本题以等差数列立意，主要考查等差数列与等比数列基本量的运算． 【思路点拨】解答本题需要掌握以下关键知识点：（1）等差数列的通项公式（2）等比数列的定义（3）与的关系． 【答案】A【解析】设的公差为d，则依题意有，即，整理得，由于，所以．故． 4．【命题立意】本题以等比数列的立意，主要考查数列基本量的观点和方法． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）建立方程；（2）求解方程，取舍值． 【答案】C【解析】依题意有，即，整理得，解得舍去），所以或． 5．【命题立意】本题以等差数列的立意，主要考查数列基本量的观点和方法． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）建立方程，求公差；（2）解方程． 【答案】C【解析】由，即得，即，所以，即，所以． 6．（理）【命题立意】本题以等差数列的立意，主要考查充要条件． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）推理证明；（2）原命题，逆命题． 【答案】C【解析】显然，如数列（n=1,2,3,…）成等差数列，则，得；反之，也成立．应为充要条件． （文）【命题立意】本题以等比数列、不等式的立意，主要考查充要条件． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）用基本量转化不等关系；（2）推理和证明． 【答案】C【解析】C．由得，所以，由得，所以，因此“”是“”的充要条件． 7．【命题立意】本题以等差数列与等比数列立意，考查等差数列与等比数列的通项公式、前n项和公式． 【思路点拨】解答本题要熟练掌握下列关键知识点：（1）等差数列与等比数列的通项公式；（2）等差数列与等比数列的前n项和公式． 【答案】A【解析】由已知可得，于是， 因此． 8．【命题立意】本题以等差数列立意，主要考查等差数列的性质、通项公式． 【思路点拨】解答本题需要掌握以下关键的知识点：（1）等差数列的基本性质；（2）等差数列的通项公式． 【答案】B【解析】因为，所以． 9．【命题立意】本题主要考查新颖情景的信息转换，等比数列通项． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）把新颖情景转化为数列的递推关系；（2）应用等比通项公式． 【答案】C【解析】设，于是有，则数列是等比数列，所以，得． 10．【命题立意】本题主要考查等比数列的通项，前n项和公式，比较大小． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）转化为基本量首项和公比q；（2）对公比q分类处理． 【答案】C【解析】当时，有；当时，有．综合以上，应当选C． 11．【命题立意】本题以等差数列立意，主要考查等差数列的性质与求和． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）等差数列的性质；（2）等差数列前n项和公式． 【答案】88【解析】由得，又，所以，于是． 12．【命题立意】本题以等比数列立意，考查等比数列的基本性质、等比数列的基本量运算． 【思路点拨】解答本题要掌握以下几个关键的知识点：（1）等比数列的基本性质；（2）整体运算的思想方法． 【答案】【解析】由等比数列的性质可得，于是，若设公比为q，则，于是，故． 13．【命题立意】本题主要考查新定义的数列：“等积数列”，求和等知识． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）分项数为偶数和奇数的情况进行计算；（2）应用分类处理的方法． 【答案】8【解析】设这个等积数列的公积为m，由于，所以，于是这个数列各项依次为：，由于前21项的和等于62，所以，解得． 14．【命题立意】本题主要考查累加法求数列通项公式、裂项相消法求数列和等知识． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）合理地堆递推关系式进行转化；（2）利用累加法求数列的通项公式；（3）利用裂项相消法求数列和． 【答案】【解析】将的两边同除以，得，令，有：，且，从而，故． 15．【命题立意】本题主要考查等比数列中项性质，对数换底公式． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）应用等比数列中项性质；（2）应用对数换底公式． 【答案】【解析】由题意知． 16．【命题立意】本题主要考查等比数列定义和通项，等比、等差数列前n项和和对数运算． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）应用点在曲线上，等比数列定义；（2）应用等比、等差数列前n项和公式． 【答案】（1）由题意，得，（3分）所以（6分） （2）因为，（8分）所以（10分） ．（12分） 17．【命题立意】本题主要考查数列的递推关系，等差数列的判断，以及数列最大、最小项的探求． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）针对进行计算；（2）构造函数，获知函数的单调性，据此探求数列中的最大项与最小项． 【答案】（1）∵，∴，而，（3分）∴（n∈N+）． 故数列是首项为，公差为1的等差数列．（6分） （2）依题意有，而，所以（8分）函数在x＜3.5时， y＜0，在上也为减函数．故当n＝3时，取最小值，；（10分）函数，在x＞3.5时，y＞0，在上为减函数．故当n＝4时，取最大值3．（12分） 18．【命题立意】本题主要考查前n项和与通项的关系，等比数列，对数知识，裂项求前n项和． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）应用前n项和与通项的关系；（2）应用裂项方法，求数列前n项和． 【答案】（1）由题意得，,（2分）两式相减,得，所以,当时，是等比数列，（4分）要使时，是等比数列，则只需,从而得出．（6分） （2）由（1）得知，，（8分）,（10分） ．（12分） 19．【命题立意】本题主要考查等比数列的定义、通项，数列的求和． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）应用等比数列的定义证明，等比数列通项；（2）应用错位相减法，等比数列前n项和公式． 【答案】（1）因为，所以，（3分） 两式相减得，所以，因此,数列从第二项起，是以2为首项，以3为公比的等比数列．（6分） （2）由（1）知，故；于是当时，，所以,当时，，（9分），两式相减得，又也满足上式，所以．（12分） 20．【命题立意】本题主要考查数列的实际应用，等差数列和常数数列，以及不等式的有关推理和运算．考查学生的综合解题能力． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）将实际问题数列化，进行翻译转化之；（2）分类列出不等式，研究不等式的解． 【答案】（1）设表示第个月的收入，则由图得，，且数列的前五项是公差为2的等差数列，第六项开始是常数列，（2分）所以=（4分）即=（6分） （2）不改造时的第n个月累计纯收入:；（8分） 投资改造后的第n个月累计纯收入:当n≤5时，纯收入为+100n400，由+100n400＞，解得n＞－8+，由－8+＞－8+=8，得n＞8，即前5个月不效．（10分） 当n＞5时，纯收入，由＞，得，解得 而n=9适合上述不等式．所以，必须经过8个月后，即第9个月才见效．（13分） 21．（理）【命题立意】本题主要考查分段数列，前n项和，通项，等比数列，分类求前n项和，不等式证明． 【思路点拨】解答本题需要掌握以下几个关键的知识点： （1）应用已知关系填表； （2）分类求前200项和，前50项是等差数列，后面的奇数项均为1，偶数项均为4． （3）奇偶性分析法，求和，放大获得不等式证明． 【解析】（1）（4分） n 2 3 51 200 an 196 192 1 4 （2）当时，由题意知数列的前50项构成首项为，公差为的等差数列，从第51项开始，奇数项均为1，偶数项均为4．（6分）从而，∴．（8分） （3）当时，易知，∴（10分） ①当（k∈N*）时， ∵，∴，（12分） ②当（k∈N*）时， 综上，有．（14分） （文）【命题立意】本题主要考查数列通项，前n项和的探求，等差数列，等比数列，错位相减法求数列前n项和． 【思路点拨】解答本题需要掌握以下几个关键的知识点：（1）构造等差数列，求通项；2）应用错位相减法，求数列前n项和．（3）恰当缩小，获得所要证明的不等式． 【解析】（1）且n∈N*），,即(,且N*),（3分）所以，数列是等差数列,公差,首项，（5分）于是．（7分） （2） ① ②（9分） ①②得 （12分） （14分） 2012届同心圆梦专题卷数学专题十二答案与解析 1．【答案】D【解析】∵∴令，得或4，故选D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c5f3a5b5b46fa3aab56fc7bcc47ba49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26993f3a08de0e8191499d2b764e5b94/" rel="bookmark">
			2012英语专四单项选择模拟题(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2012英语专四单项选择模拟题(1) 2012年01月18日 来源：新东方网 1. There is no ___ in the world for her children. A. love greater than a mother B. love greater than that of a mother C. love greater as a mother D. great love as that of a mother 2. I didn't see her in the meeting-room this afternoon. She ___ at the meeting. A. mustn't have spoken B. shouldn't have spoken C. needn't have spoken D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26993f3a08de0e8191499d2b764e5b94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc4eb3715b42508d3b847a72f542758/" rel="bookmark">
			(2)马裤分:七分裤(长度为 70cm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(2)马裤分:七分裤(长度为 70cm 2012年01月09日 ，一线品牌究竟?结果完备专业风范，看后觉得获益非浅。如今转给各位开店的伴侣看看，为行家经营服装及兴盛自己的品牌提供参考。好了，废话不多说，上面文章对比的长，要想从中取得好处请务必耐烦把它看完:) 《阿玛尼的导购手册》 第一章 企业文明 一 企业理念 企业目的：立足中原，辐射全国，誓创男装第一品牌 企业宗旨：创作发明完善时尚，倡议精致生活 企业经营理念：品质为本，办事顾客，构筑连锁网络，创作发明双赢共享 企业质量观念：armani中文官网。市场化决策，当代化经营，体系化管理，专业化办事 企业人才观念：人力资源是企业生存的核心 企业价值观念：朴拙办事是企业生存的基本 座右铭：言必信. . .，行必果 二 公司概况 意大利阿玛尼国际无限公司，兴办于****年，是集安排、临蓐、出卖为一体的大型服装企业，以"兴办男装品牌，复兴男装产业"为已任。****年在中国区域推出"啊玛尼"时尚男装。多年来，依赖香港时尚的流行讯息上风，采用国际创办的"男装专卖"经营形式，在公司前辈创新的管理和兢业专注的职业团队的主动推动下，专卖网络笼罩延长至华中、华北、西北、西南等区域一线都市，并博得了顾客集体的主动信任和热中赞誉。 为适应"阿玛尼"迅猛兴盛的须要，公司进一步完善了临蓐管理中心、营销策划中心和产品开拓中心三大模块，组织组织合理，运营高效，临蓐研发本事优裕饱满。建立了郑州、北京、太原、徐州、石家庄、济南、西安、沈阳、乌鲁木齐等九大配货中心。 在"阿玛尼"逐渐的兴盛强壮中，"****"、"****"、"****"、"****"、"****"等多品牌的兴盛战略已着手实施。其中，"****"时尚衬衣以其奇异的品格定位，时尚的款形安排，已取得众多年老男性的认可；"****"典范休闲裤以其安适的版型，得体时髦的品格，已被昌大中年男性所喜爱。 意大利阿玛尼国际无限公司正以奇异的产品定位及、新颖实效的运营思绪、强无力的职业团队，在服装业界创作发明一个又一个行状。 第二章 服装面料学问 [b]一、纤维的分类： [/b]A.天然纤维 B.化学纤维 天然纤维：正品阿玛尼手表。 （1）植物纤维：种籽纤维、韧皮纤维、叶纤维、果实纤维 （2）植物纤维：听说阿玛尼手表中国官网。毛绒、腺分泌物 （3）矿物纤维：又叫无机纤维 化学纤维： （1）天然纤维：天然纤维素纤维、天然蛋白质纤维、天然无机纤维 （2）分解纤维：锦纶、晴纶、莱卡等。 [b]二、面料三原组织： [/b]A.平纹组织 B.斜纹组织 C.缎纹组织 特性：A.平纹组织-----布面平整、布质耐磨、不易挂丝。 B.斜纹组织-----布面较松软，不耐磨。 C.缎纹组织-----布面松软，光泽好，不耐磨，易磨毛。 [b]三、面料与特性 [/b]Ａ、麻纱-----麻纱不是由麻纤维织成，而是用棉纤维经过议定纺织工艺治理织成的，具有麻 织品品格的织物，特性：布面平挺、滑爽而细洁、挑?透凉，穿戴不贴身，抗皱性优于麻织品，但缩水率较大，有网眼、提花、方格等。 Ｂ、亚麻布-----亚麻布是由亚麻纤维纺织而成。特性：布面细洁、平整、挺括，手感柔 软且富饶弹性，具有穿戴凉爽，透气性好，吸湿散热快，看着阿玛尼彩妆官网。出汗不贴身的优点。 Ｃ、苎麻织物-----苎麻织物是由苎麻纤维纺织而成的面料，可折柳工与机织两类。 特性：苎麻布透气性好，吸湿散热快，穿戴爽挺透凉，不贴身。 Ｄ、麻棉混纺-----平常采用55％麻与45％的棉，或麻棉各50％的比例举办混纺，外观上连结了麻织物独有的粗莽挺括的品格，又具有棉织物优柔的特性改善了麻织品外观不够细洁，易起毛的缺点。 Ｅ、毛麻人字呢-----以羊毛50％，苎麻50％举办混纺，手感滑爽挺括，富饶弹性。 Ｆ、涤棉织品-----涤纶与棉混纺常采用35％的棉与65％的涤棉混纺布，既连结了涤纶纤维的特性，而且完备棉纤维的吸湿性强，易染色和穿戴安适透气的职能。 G、卡其布-----卡其布是斜纹布中的首要种类。轮廓斜纹细密，纹路笔挺，质地精细厚实，坚牢耐磨，平整挺括。织物密度大，事实上阿玛尼男装。在染色进染料不易排泄因而常摩擦之处易磨白，折边处易折断。 H、绒布-----棉布经拉绒治理，在织物轮廓出现一层疏松的绒毛，这种布称绒布，由于这一层绒毛的存在，绒毛间储备了大批的空气，具有较好的保暖职能。特性：手感优柔厚实，穿戴安适。 I、天然棉-----天然棉布是指由纯粘胶纤维纺织而成的具有棉布特征的织品，其吸湿性、透气性、染色性与棉布一样，布面匀整细洁、颜色灿艳、质地优柔、但缩水率大。 J、涤纶-----又叫聚脂纤维，特性是：弹性好、强度大，对比耐磨，抗皱职能凌驾了任何纤维，耐热性好，化学安稳性好，不怕虫蛀，但吸湿性差。 K、晴纶-----又叫聚炳烯纤维。特性：疏松性好。密度小，保湿职能好，手感优柔、挺括，质轻强力大，70cm。耐晒，化学安稳性好，不霉不蛀，但不耐磨，抗皱性差，且弹力差。 L、醋酯纤维-----又叫醋酸纤维。特性：悬重性好，防皱吸湿排汗，抗紫外线，抗静电，70cm。抗菌防臭，但手感涩。 M、氨纶-----又叫莱卡，是目前全球运用广泛的弹力纤维，回弹职能好，不易变形。 N、:莫代尔-----莫代尔是全球公认的一种新型环保资料。其临蓐是在对环境无净化的情状下举办的，具有优秀绿色环保效力，是纯粹的天然纤维。相比看阿玛尼手表中国官网。特性：具有棉的优柔、丝的光泽、麻的滑爽，而具其吸水透气性都优于棉，色泽度好，有时会起毛。 第三章 裤装的分类与搭配 [b]一、女裤的分类 [/b]1、按长度分类：长裤和马裤 （1）长裤的长度平常为： 3 尺长、 3 尺 1 寸长、3尺 2 寸长、3 尺3 寸长。 （2）马裤分：七分裤（长度为 70cm， 2 尺 1 寸） 八分裤（长度为 80cm， 2 尺 4 寸） 九分裤（长度为 90cm， 2 尺 7 寸） 特别很是裤（长度为 97cm， 2 尺 9 寸） 2、按版型分类：直筒、西裤、锥型裤、喇叭裤、斜裁裤 （1）直筒： Ａ：小直筒特性：裤口 6 寸 5 左右，中裆以下基本一致，穿戴合体。 Ｂ：（2）马裤分：七分裤（长度为。中直筒特性：裤口 7 寸左右，裤腿比小直筒稍胖，穿戴能拉长腿型，把腿衬得均匀颀长而直。 Ｃ：大直筒特性：裤口 8 寸左右，裤腿较宽，穿戴飘逸。 （2）西裤特性：胯围，臀围.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dc4eb3715b42508d3b847a72f542758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66d5cf9929ef417e7e7f47c6e77929ea/" rel="bookmark">
			Configuration Error配置错误 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Configuration Error配置错误 解决方案 2011年10月12日 (2010-10-15 02:34:15) 转载 问题：Configuration Error[b]Description:[/b] An error occurred during the processing of a configuration file required to service this request. Please review the specific error details below and modify your configuration file appropriately. [b]Parser Error Message:[/b] It is an error to use a section registered as allowDefinition='MachineToApplication' beyond application level. This error can be caused by a virtual directory not being configured as an application in IIS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66d5cf9929ef417e7e7f47c6e77929ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f7cec33e297121c81f6c550ae3faa2f/" rel="bookmark">
			事件管理器――PWM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件管理器――PWM 2011年02月15日 “简简单单DSP”系列学习活动―第七期事件管理器――PWM 四、 PWM电路 每一个事件管理器有三个比较单元，每一个比较单元有两个互补的PWM输出，这样三个比较单元就可以产生6路PWM，并且死区时间和输出极性可编程，能够被灵活的应用在电机控制、三相电源变换器中。 PWM单元电路包括如下功能单元： A、 非对称/对称波形发生器 B、 可编程的死区单元 C、 输出逻辑 D、 空间矢量PWM状态机 PWM单元的存在就减少了CPU的开销，只要设置好就会自动产生PWM波形，就像DMA的存在一样，也同定时器工作一样。可以用到它的中断去改变占空比，如果是固定输出的配置好一切皆OK。对于EVA模块产生PWM用到的寄存器主要有：CMPRX、T1PR、T1CNT、T1CON、COMCONA、ACTRA、DBTCONA(死区控制寄存器)，他用的时基单元是通用定时器1，参照上面说得比较单元的设置，因此还包括通用定时器1的基本设置。 使用比较单元以及相关电路产生PWM波形，需要对事件管理器的寄存器进行配置，具体步骤和C代码如下： （1）时钟设置和通用定时器1的时钟设置操作一样，包括选择内部还是外部时钟以及与分频系数在设置这个之前要保证EVA的时钟开启； SysCtrlRegs.PCLKCR.bit.EVAENCLK=1;// EVA的时钟开启 EvaRegs.T1CON.bit.TCLKS10=0;//选择内部时钟 EvaRegs.T1CON.bit.TPS=3;//预分频8倍，如果HSPCLK=150M,那么通用定时器时钟频率是150/8M. （2） 设置通用定时器1，参照上面的通用定时器设置，这里包括设置T1CNT,T1PR，通常T1CNT初始化设置为0，T1PR设置的是你的PWM的频率，根据自己的需要计算设置。 （3） 设置CMPRX，这个就是设置你的占空比 EvaRegs.CMPR1 = 0x0C00; EvaRegs.CMPR2 = 0x3C00; EvaRegs.CMPR3 = 0xFC00; 通用定时器计数器T1CNT一直与比较寄存器比较，当发生比较匹配后，输出PWM引脚就会根据您的设置跳变，通用定时器计数器T1CNT继续计数一直到与周期寄存器周期匹配后，PWM输出引脚再次跳变，这样一直循环下去。 （4） 设置ACTRA 比较方式控制寄存器就是控制输出引脚发生跳变时的极性，还有就是空间矢量PWM产生的设置，这里不作介绍。ACTRA后12位设置PWM输出跳变的极性，每两位设置一个PWM引脚，这里设置和比较产生PWM时一样，需要注意的是一个比较寄存器控制的互补输出的一对PWM设置要正好相反。 EvaRegs.ACTRA.all = 0x0666;//PWM1、PWM3、PWM5输出高有效，PWM2 PWM4 PWM6输出低有效 （5） 设置比较控制寄存器COMCONA 这个寄存器包括设置比较寄存器CMPRX重新装载条件、方式控制寄存器重新装载条件、空间矢量PWM模式使能、使能比较寄存器、全比较器输出使能，其他三个比较器输出使能。 具体设置如下： （5）比较器控制寄存器COMCONA设置 A、设置CMPRX重载条件 EvaRegs.COMCONA.bit.CLD=0;//当T1CNT=0(下溢) EvaRegs.COMCONA.bit.CLD=1;//当T1CNT=0或T1CNT =T1PR(下溢后周期匹配) EvaRegs.COMCONA.bit.CLD=2;//立即 EvaRegs.COMCONA.bit.CLD=3;//保留，结果不可测) B、方式控制寄存器ACTRA重载条件设置 EvaRegs.COMCONA.bit.ACTRLD=0;// 当T1CNT=0(下溢) EvaRegs.COMCONA.bit.ACTRLD=1; 当T1CNT=0或T1CNT =T1PR(下溢后周期匹配) EvaRegs.COMCONA.bit.ACTRLD=2;// 立即 EvaRegs.COMCONA.bit.ACTRLD=3;// 保留，结果不可测 E、 比较器使能位设置 EvaRegs.COMCONA.bit.CENABLE=0;//禁止比较操作，影子寄存器变透明 EvaRegs.COMCONA.bit.CENABLE=1;//使能 F、 单个比较器使能 EvaRegs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f7cec33e297121c81f6c550ae3faa2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63db35e9a850c912e3636057d9bd7068/" rel="bookmark">
			开源工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开源工具 2011年03月22日 软件集成开发环境（代码编辑、浏览、编译、调试） Emacs http://www.gnu.org/software/emacs/ Source-Navigator 5.2b2 http://sourceforge.net/projects/sourcenav Anjuta http://anjuta.sourceforge.net(可用yum安装) 代码索引工具 Cscope http://cscope.sourceforge.net/ KScope http://www.kde-apps.org GLOBAL http://www.gnu.org/software/global/(可用yum安装) 调试器(GNU gdb的GUI前端) DDD http://www.gnu.org/software/ddd/ Insight 6.4.0 http://sourceware.org/insight/ KDbg http://www.kdbg.org/ 评测器(内存、性能、覆盖等的profiler，类似IBM Purify) Valgrind http://www.valgrind.org/，FC5自带3.1.0-2 ggcov(GNU gcov的GUI) http://ggcov.sourceforge.net/ kprof(GNU gprof的GUI) http://kprof.sourceforge.net/ KCachegrind http://kcachegrind.sf.net BoundsChecking http://www.doc.ic.ac.uk/~phjk/BoundsChecking.html 代码静态检查工具(类似Windows平台的PC-Lint) Splint http://www.splint.org/(可用yum安装) flawfinder http://www.dwheeler.com/flawfinder/ 代码静态测量工具 --暂缺，Windows上非开源的LineCount(http://liangs.autodebug.com/)统计C/C++/Java代码还凑合。 PyMetrics(http://sourceforge.net/projects/pymetrics/)测量Python代码复杂度。 http://www.chris-lott.org/resources/cmetrics/罗列了好些C static metric tools。 软件构建系统(build system) SCons http://www.scons.org/(用yum安装的版本太低) CMake http://www.cmake.org/ GNU Make http://www.gnu.org/software/make/ 交叉工具链 crosstool http://www.kegel.com/crosstool/ 代码版本控制系统及相关工具 Subversion http://subversion.tigris.org (用yum安装) WorkBench http://pysvn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63db35e9a850c912e3636057d9bd7068/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12e03e934afee554c5c6849377ff1c4f/" rel="bookmark">
			ARM中B __Main和B Main的区别(好文)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ARM中B __Main和B Main的区别(好文) 2011年04月11日 第一种答案如下： 在软件仿真的情况下，执行“[b]B __main[/b]”指令，能使程序跳到[b]C[/b]文件的[b]main[/b]函数，但用硬件仿真时，还没执行到[b]main[/b]函数时就进入了异常中断。 原因是执行“B __main”指令后，程序先跳到__main库函数的入口，再进行一些初始化操作，最后再跳入用户的main函数。但在初始化过程中，由于堆栈或其它原因造成程序出错。有两种方法可以解决这个问题。第一：将“B __main”指令直接改成“B main”，使程序不进行初始化而直接跳入用户的main()函数。第二：合理初始化堆栈。由于考虑到刚接触ARM和将问题简单化，我选择了第一种方法。 第二种答案如下： IMPORT __main .... .... BL TargetResetInit B __main 1、此后流程将跳转到ADS提供的启动代码__main函数处，负责完成库函数的初始化及相关功能，并最终引导处理器入口用户代码main()函数，其代码流程为： 嵌入式系统在进入应用主程序之前必须有一个初始化的过程，该过程完成系统的启动和初始化功能，初始化过程可以分成两部分来看： √ _main负责设置运行映像存储器映射； √ _rt_entry负责库函数的初始化。 _main完成代码和数据的复制，并把ZI数据区清零，这一步当代码和数据区在存储和运行时处于不同的存储器位置时有意义。接着_main跳进_rt_entry，进行STACK和HEAP等的初始化。最后_rt_entry跳进应用程序的入口main()。当应用程序执行完时，_rt_entry又将控制权交还给C库函数，函数main()在ADS中有特殊的意义。当一个程序工程项目中存在main()时，连接器会把_main和_rt_entry中的初始化代码连接进来；如果没有main()函数，初始化过程就不会被连接，初始化过程中一些标准的C库函数失效。而用户应用程序初始化过程并未显式的完成这些堆栈初始化及数据拷贝操作，应用程序将启动不成功。 2、__main()为编译系统提供的一个库函数，使用__main标号引导系统时必须将应用程序的入口数定义为main()； 3、若希望系统进入应用程序前自动完成系统调用（如库函数的初始化、RW、ZI数据从Flash到RAM的拷贝（加载映像---&gt;执行映像）等）的初始化过程，必须使用__main标号以跳至ADS提供的初始化函数库，这种情况一般需做一些库函数移植及重定向问题解决；这一点上，应用程序入口必须以main函数标识； 4、若所有的初始化步骤都已显式的完成（如堆栈初始化、加载映像到执行映像RW、ZI数据的拷贝等），应用程序入口函数XXXX()可以任意定义（非main，这样可以避免自动链接上__main,从而跳过__main），初始化完成后直接B XXXX即可，这一点上，main()函数并不具有特殊性； 5、若必须的初始化步骤都未显示的完成，一意孤行的B XXXX，程序运行的结果将不可预料。一个典型的例子是：若用户并未显示完成加载映像---&gt;执行映像的数据初始化而直接B XXXX，[b]则应用程序中所有的全局变量并不会被预期的初始化，而所有的ZI变量也不会被预期的清零[/b]； 6、本人在调试LPC2294 LCD模块时才认识到上述第五点（5、）的重要性：程序指令流并没有错，但LCD上显示的全部是乱码。我用两种方法解决了这一bug： （1）将所有的字库数据定义为const常量，程序运行正确； （2）将B Main 修改成B __main接着将应用入口改为int main(void) 而非int Main(void)，程序也得到正确的执行； [b]Initializing memory required by C code[/b] The initial values for any initialized variables (RW) must be copied from ROM to RAM. All other ZI variables must be initialized to zero.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12e03e934afee554c5c6849377ff1c4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6e919a2b352bbc2cd79a728bcd94ca/" rel="bookmark">
			张志晨VB实例教程之打开word方法种种
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		张志晨VB实例教程之打开word方法种种 2011年08月31日 张志晨VB实例教程之打开word方法种种 方法一： Dim mWordapp As Word.Application 'word 应用程序 Dim mobjDoc As Word.Document 'word 文档 Dim fullFileName As String '文件路径 Private Sub Command1_Click() CommonDialog1.Filter = "word文件|*.docx" CommonDialog1.ShowOpen fullFileName = CommonDialog1.FileName Set mWordapp = CreateObject("Word.Application") Set mobjDoc = mWordapp.Documents.Add(fullFileName) mWordapp.Visible = True End Sub ................................................ 方法二： Dim fullFileName As String '文件路径 Private Sub Command1_Click() CommonDialog1.Filter = "word文件|*.docx" CommonDialog1.ShowOpen fullFileName = CommonDialog1.FileName Shell "cmd /c " &amp; fullFileName, vbHide'使用shell.exe与cdm.exe End Sub .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a6e919a2b352bbc2cd79a728bcd94ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b1ac420ce73bfe9960040546e8c4ce0/" rel="bookmark">
			AndroidManifest.xml文件解析(总有一个你不清楚)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、关于AndroidManifest.xml
AndroidManifest.xml 是每个android程序中必须的文件。它位于整个项目的根目录，描述了package中暴露的组件（activities, services, 等等），他们各自的实现类，各种能被处理的数据和启动位置。 除了能声明程序中的Activities, ContentProviders, Services, 和Intent Receivers,还能指定permissions和instrumentation（安全控制和测试）
二、AndroidManifest.xml结构
&lt;?xmlversion=”1.0″encoding=”utf-8″?&gt;
&lt;manifest&gt;
&lt;application&gt;
&lt;activity&gt;
&lt;intent-filter&gt;
&lt;action/&gt;
&lt;category/&gt;
&lt;/intent-filter&gt;
&lt;/activity&gt;
&lt;activity-alias&gt;
&lt;intent-filter&gt;&lt;/intent-filter&gt;
&lt;meta-data/&gt;
&lt;/activity-alias&gt;
&lt;service&gt;
&lt;intent-filter&gt;&lt;/intent-filter&gt;
&lt;meta-data/&gt;
&lt;/service&gt;
&lt;receiver&gt;
&lt;intent-filter&gt;&lt;/intent-filter&gt;
&lt;meta-data/&gt;
&lt;/receiver&gt;
&lt;provider&gt;
&lt;grant-uri-permission/&gt;
&lt;meta-data/&gt;
&lt;/provider&gt;
&lt;uses-library/&gt;
&lt;/application&gt;
&lt;uses-permission/&gt;
&lt;permission/&gt;
&lt;permission-tree/&gt;
&lt;permission-group/&gt;
&lt;instrumentation/&gt;
&lt;uses-sdk/&gt;
&lt;uses-configuration/&gt;
&lt;uses-feature/&gt;
&lt;supports-screens/&gt;
&lt;/manifest&gt;
三、各个节点的详细介绍
上面就是整个am(androidManifest).xml的结构，下面以外向内开始阐述～～
1、第一层(&lt;Manifest&gt;):(属性)
&lt;manifest xmlns:android=”http://schemas.android.com/apk/res/android”
package=”com.woody.test”
android:sharedUserId=”string”
android:sharedUserLabel=”string resource”
android:versionCode=”integer”
android:versionName=”string”
android:installLocation=["auto" | "internalOnly" | "preferExternal"] &gt;
&lt;/manifest&gt;
A、xmlns:android
定义android命名空间，一般为http://schemas.android.com/apk/res/android，这样使得Android中各种标准属性能在文件中使用，提供了大部分元素中的数据。
B、package
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b1ac420ce73bfe9960040546e8c4ce0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a972eee3401edae1275ad424ea00341c/" rel="bookmark">
			Android-sharedUserId数据权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android给每个APK进程分配一个单独的用户空间,其manifest中的userid就是对应一个Linux用户 (Android 系统是基于Linux)的. 所以不同APK(用户)间互相访问数据默认是禁止的. 但是它也提供了2种APK间共享数据的形式: 1. Share Preference. / Content Provider APK可以指定接口和数据给任何其他APK读取. 需要自己实现接口和Share的数据. 本文对于这个不做详细解释 2. Shared User id 通过Shared User id,拥有同一个User id的多个APK可以配置成运行在同一个进程中.所以默认就是 可以互相访问任意数据. 也可以配置成运行成不同的进程, 同时可以访问其他APK的数据目录下的 数据库和文件.就像访问本程序的数据一样. 比如某个公司开发了多个Android 程序, 那么可以把数据,图片等资源集中放到APK A中去. 然后 这个公司的所有APK都使用同一个User ID, 那么所有的资源都可以从APK A中读取. 举个例子: APK A 和APK B 都是C公司的产品,那么如果用户从APK A中登陆成功.那么打开APK B的时候就不用 再次登陆. 具体实现就是 A和B设置成同一个User ID: * 在2个APK的AndroidManifest.xml 配置User ID: &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.android.demo.a1" android:sharedUserId="com.c"&gt; 这个"com.c" 就是user id, 然后packagename APK A就是上面的内容, APK B可能 是"com.android.demo.b1" 这个没有限制 这个设定好之后, APK B就可以像打开本地数据库那样 打开APK A中的数据库了.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a972eee3401edae1275ad424ea00341c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/498a14ab4006b103d6fe31352609974d/" rel="bookmark">
			Android Hal 分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Hal 分析
-------rockchip Andy
本文是基于android4.0.3.对应其他低版本的代码，可能有所差异，但基本大同小异。
Android的HAL是为了保护一些硬件提供商的知识产权而提出的，是为了避开linux的GPL束缚。思路是把控制硬件的动作都放到了Android HAL中，而linux driver仅仅完成一些简单的数据交互作用，甚至把硬件寄存器空间直接映射到user space。而Android是基于Aparch的license，因此硬件厂商可以只提供二进制代码，所以说Android只是一个开放的平台，并不是一个开源的平台。也许也正是因为Android不遵从GPL，所以Greg Kroah-Hartman才在2.6.33内核将Andorid驱动从linux中删除。GPL和硬件厂商目前还是有着无法弥合的裂痕。Android想要把这个问题处理好也是不容易的。
总结下来，Android HAL存在的原因主要有：
1. 并不是所有的硬件设备都有标准的linux kernel的接口
2. KERNEL DRIVER涉及到GPL的版权。某些设备制造商并不原因公开硬件驱动，所以才去用HAL方 式绕过GPL。
3. 针对某些硬件，An有一些特殊的需求
现有HAL架构由Patrick Brady (Google) 在2008 Google I/O演讲中提出的，如下图：
一、 源码位置
/hardware/libhardware_legacy/ - 旧的架构、采取链接库模块的方式
/hardware/libhardware 新架构、调整为 HAL stub 目录的结构如下：
/hardware/libhardware/hardware.c 编译成libhardware.s置于/system/lib /hardware/libhardware/include/hardware目录下包含如下头文件：
hardware.h 通用硬件模块头文件
copybit.h copybit模块头文件
gralloc.h gralloc模块头文件
lights.h 背光模块头文件
overlay.h overlay模块头文件
qemud.h qemud模块头文件
sensors.h 传感器模块头文件
/hardware/libhardware/modules 目录下定义了很多硬件模块
/hardware/msm7k /hardware/qcom /hardware/ti /device/Samsung /device/moto 各个厂商平台相关的hal
这些硬件模块都编译成xxx.xxx.so，目标位置为/system/lib/hw目录
二、 HAL层的实现方式
目前HAL存在两种构架，位于libhardware_legacy目录下的“旧HAL架构”和位于libhardware目录下的“新HAL架构”。两种框架如下图所示：
libhardware_legacy 是将 *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/498a14ab4006b103d6fe31352609974d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b836062df7da75286d4ecc2b75254a03/" rel="bookmark">
			linux下的C语言开发（开篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【 声明：版权所有，欢迎转载，请勿用于商业用途。 联系信箱：feixiaoxing @163.com】 在很多人的眼里，C语言和linux常常是分不开的。这其中的原因很多，其中最重要的一部分我认为是linux本身就是C语言的杰出作品。当然，linux操作系统本身对C语言的支持也是相当到位的。作为一个真正的程序员来说，如果没有在linux下面用C语言编写过完整的程序，那么只能说他对C语言本身的理解还相关肤浅，对系统本身的认识也不够到位。作为程序员来说，linux系统为我们提供了很多理想的环境，这其中包括了下面几个方面， （1）完善的编译环境，包括gcc、as、ld等编译、链接工具 （2）强大的调试环境，主要是gdb工具 （3）丰富的自动编译工具，主要是make工具 （4）多样化的os选择，ubuntu、redflag等等 （5）浩瀚的开源代码库 当然，不管我怎么说，最终朋友们还是应该自己勇敢地跨出前进的第一步。如果还没有过Linux编程经验的朋友可以首先在自己的pc上面安装一个虚拟机，然后就可以在shell下面编写自己的C语言代码了。
#include &lt;stdio.h&gt; int main() { printf("hello!\n"); return 1; } 编写完上面的代码后，你需要做的就是两个步骤：1、输入 gcc hello.c -o hello；2、输入./hello。如果一切正常的话，此时你应该会在屏幕上看到一行hello的打印。如果你看到了，那么恭喜你，你已经可以开始linux的c语言编程之旅了。 当然，我们不会满足于这么简单的打印功能。下面就可以编写一个简单的迭代函数， #include &lt;stdio.h&gt; int iterate(int value) { if(1 == value) return 1; return iterate(value - 1) + value; } int main() { printf("%d\n", iterate(10)); return 1; } 此时，同样我们需要重复上面的步骤：1、输入gcc hello.c -o hello；2、输入./hello。当然此时如果一切OK的话，你就会看到屏幕会有55这个数的输出。本来1到10的数据之和就是55， 这说明我们的程序是正确的。 当然， 还会有一些朋友对程序的反汇编感兴趣，那么他需要两个步骤：1、gcc hello.c -g -o hello；2、objdump -S -d ./hello。之所以在gcc编译的时候加上-g是为了添加调试信息，objdump中的-S选项是为了在显示汇编代码的时候同时显示原来的C语言源代码。 int iterate(int value) { 8048374: 55 push %ebp 8048375: 89 e5 mov %esp,%ebp 8048377: 83 ec 08 sub $0x8,%esp if(1 == value) 804837a: 83 7d 08 01 cmpl $0x1,0x8(%ebp) 804837e: 75 09 jne 8048389 &lt;iterate+0x15&gt; return 1; 8048380: c7 45 fc 01 00 00 00 movl $0x1,0xfffffffc(%ebp) 8048387: eb 16 jmp 804839f &lt;iterate+0x2b&gt; return iterate(value -1) + value; 8048389: 8b 45 08 mov 0x8(%ebp),%eax 804838c: 83 e8 01 sub $0x1,%eax 804838f: 89 04 24 mov %eax,(%esp) 8048392: e8 dd ff ff ff call 8048374 &lt;iterate&gt; 8048397: 8b 55 08 mov 0x8(%ebp),%edx 804839a: 01 c2 add %eax,%edx 804839c: 89 55 fc mov %edx,0xfffffffc(%ebp) 804839f: 8b 45 fc mov 0xfffffffc(%ebp),%eax } 80483a2: c9 leave 80483a3: c3 ret 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f9cc55b761083cb583b553b57b89833/" rel="bookmark">
			ps vita 说明书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://games.sina.com.cn/t/psv/sms/basic/screens.shtml 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe442ceb6c1d899d6c242dadd52dc3e9/" rel="bookmark">
			grep的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.thegeekstuff.com/2009/03/15-practical-unix-grep-command-examples/ 首先创建我们练习grep命令时需要用到的demo文件demo_file。
$ cat demo_fileTHIS LINE IS THE 1ST UPPER CASE LINE IN THIS FILE.this line is the 1st lower case line in this file.This Line Has All Its First Character Of The Word With Upper Case.Two lines above this line is empty.And this is the last line. 1.从单个文件中搜索指定的字串 grep的基础用法是如下例的从指定的文件中搜索特定的字串。
语法：grep "literal_string" filename $ grep "this" demo_filethis line is the 1st lower case line in this file.Two lines above this line is empty.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe442ceb6c1d899d6c242dadd52dc3e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c704ce42eb068bb15d66977da70d151/" rel="bookmark">
			java与javascript数据互传乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当java想前台返回数据时包含汉字，在Firefox中没问题，但是在IE中显示出现乱码，解决方式如下
后台:java.net.URLEncoder.encode("导入成功","UTF-8")
前台:javascript:-&gt; decode(str);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05a5de894b7edc297f9f087887f68abf/" rel="bookmark">
			138个被撤出EI检索的会议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于受国内某不负责任国际会议影响，IEEE将2010年10月至2011年2月期间出版的138个会议全部撤出EI检索并退回版权。详情见 http://www.ieee.org/conferences_events/conferences/publishing/author_form.html 以下是IEEE官方网站的原文： Technical Program Integrity Committee Actions IEEE has a long-standing commitment to ensuring the high quality of its conferences and of the conference proceedings published in IEEE Xplore&amp;reg;. Through its regular conference quality-monitoring process, IEEE became aware of inconsistencies in some conferences with regard to the quality of the peer review and technical program development. In 2010, IEEE launched an in-depth investigation through its Technical Program Integrity Committee, a volunteer-based committee responsible for ensuring the quality of IEEE publications.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05a5de894b7edc297f9f087887f68abf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87dc6b48d44c4e6bf1fad8f12eb7b3a5/" rel="bookmark">
			获取Android的APK包签名信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取Android的APK包签名信息 发表于133 天前 ⁄ 编程开发 ⁄ 暂无评论 1、使用命令获取Android的APK包签名信息
jarsigner -verify -verbose -certs &lt;your_apk_path.apk&gt; 对于一个keystore的指纹信息获取可以用如下命令：
D:/&gt;keytool -list -alias alias_name -keystore keystore_name.KEYSTORE 输入keystore密码： sodino_keystore, 2010-8-9, PrivateKeyEntry, 认证指纹 (MD5)： CB:5E:F5:33:23:F4:D2:D3:CC:74:9D:BF:14:36:EB:8D 2、PC上使用java代码获取APK信息：
可以参考http://zhuq0516-struts2.googlecode.com/svn/
转帖：http://www.ziyouku.com/archives/obtain-the-signature-of-android-apk-package-information.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31db1a1ec7edc2ebc327b1ab34eb4411/" rel="bookmark">
			C语言中printf格式化输出函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用 法: int printf(const char *format,[argument]);
format 参数输出的格式，定义格式为：
%[flags][width][.perc] [F|N|h|l]type
规定数据输出方式，具体如下：
1.type 含义如下：
d 有符号10进制整数
i 有符号10进制整数
o 有符号8进制整数
u 无符号10进制整数
x 无符号的16进制数字，并以小写abcdef表示
X 无符号的16进制数字，并以大写ABCDEF表示
F/f 浮点数
E/e 用科学表示格式的浮点数
g 使用%f和%e表示中的总的位数表示最短的来表示浮点数 G 同g格式，但表示为指数
c 单个字符
s 字符串
% 显示百分号本身
p 显示一个指针，near指针表示为：XXXX
far 指针表示为：XXXX：YYYY
n 相连参量应是一个指针，其中存放已写字符的个数
2.flags 规定输出格式，取值和含义如下：
无 右对齐，左边填充0和空格
- 左对齐，右边填充空格
+ 在数字前增加符号 + 或 -
一个空格 只对负数显示符号
# 当type=c,s,d,i,u时没有影响
type=o,x,X时，分别在数值前增加'0',"0x","0X"
type=e,E,f时，总是使用小数点
type=g,G时，除了数值为0外总是显示小数点 3.width 用于控制显示数值的宽度，取值和含义如下n(n=1,2,3...) 宽度至少为n位，不够以空格填充
0n(n=1,2,3...) 宽度至少为n位，不够左边以0填充 * 格
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31db1a1ec7edc2ebc327b1ab34eb4411/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f8e9e4a52494dd82191da7468558733/" rel="bookmark">
			F5负载均衡机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		F5 BIGIP 服务器负载均衡介绍 随着Internet的普及以及电子商务、电子政务的发展，越来越多的应用系统需要面对更高的访问量和数据量。同时，企业对在线系统的依赖也越来越高，大量的关键应用需要系统有足够的在线率及高效率。这些要求使得单一的网络服务设备已经不能满足这些需要，由此需要引入服务器的负载均衡，实现客户端同时访问多台同时工作的服务器，一则避免服务器的单点故障，再则提高在线系统的服务处理能力。从业界环境来说，如下的应用需求更是负载均衡发展的推动力： 业务系统从Client-Server转向采用Browser-Server 系统结构，关键系统需要高可用性 电子商务系统的高可用性和高可靠性需要 IT应用系统大集中的需要 （税务大集中,证券大集中,银行大集中） 数据中心降低成本,提高效率 。 负载均衡技术在现有网络结构之上提供了一种廉价、有效、透明的方法，来扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。它有两方面的含义：首先，大量的并发访问或数据流量分担到多台节点设备上分别处理，减少用户等待响应的时间；其次，单个重负载的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后，将结果汇总，返回给用户，系统处理能力得到大幅度提高。 BIG/IP利用定义在其上面的虚拟IP地址来为用户的一个或多个应用服务器提供服务。因此，它能够为大量的基于TCP/IP的网络应用提供服务器负载均衡服务。BIG/IP连续地对目标服务器进行L4到L7合理性检查，当用户通过VIP请求目标服务器服务时，BIG/IP根椐目标服务器之间性能和网络健康情况，选择性能最佳的服务器响应用户的请求。 1. 客户发出服务请求到VIP 2. BIGIP接收到请求，将数据包中目的IP地址改为选中的后台服务器IP地址，然后将数据包发出到后台选定的服务器 3. 后台服务器收到后，将应答包按照其路由发回到BIGIP 4. BIGIP收到应答包后将其中的源地址改回成VIP的地址，发回客户端，由此就完成了一个标准的服务器负载均衡的流程。 2.负载均衡典型流程 通过VIP来截获合适的需要负载均衡的流量 服务器监控和健康检查,随时了解服务器群的可用性状态 负载均衡和应用交换功能,通过各种策略导向到合适的服务器 2.1 通过VIP来截获合适的需要负载均衡的流量 在BIGIP上通过设置VIP来截获需要进行负载均衡的流量，这个VIP地址可以是一个独立的主机地址和端口的组合（例如：202.101.112.115:80）也可以是一个网络地址和端口的组合（例如：202.101.112.0:80），当流量经过BIGIP的时候，凡是命中VIP的流量都将被截获并按照规则进行负载均衡。 2.2 服务器的健康监控和检查 服务器 (Node) - Ping (ICMP) BIGIP可以定期的通过ICMP包对后台服务器的IP地址进行检测，如果在设定的时间内能收到该地址的ICMP的回应，则认为该服务器能提供服务 服务 (Port) – Connect BIGIP可以定期的通过TCP包对后台服务器的服务端口进行检测，如果在设定的时间内能收到该服务器端口的回应，则认为该服务器能提供服务 扩展内容查证(ECV: Extended Content Verification)—ECV ECV是一种非常复杂的服务检查，主要用于确认应用程序能否对请求返回对应的数据。如果一个应用对该服务检查作出响应并返回对应的数据，则BIG/IP控制器将该服务器标识为工作良好。如果服务器不能返回相应的数据，则将该服务器标识为宕机。宕机一旦修复，BIG/IP就会自动查证应用已能对客户请求作出正确响应并恢复向该服务器传送。该功能使BIG/IP可以将保护延伸到后端应用如Web内容及数据库。BIG/ip的ECV功能允许您向Web服务器、防火墙、缓存服务器、代理服务器和其它透明设备发送查询，然后检查返回的响应。这将有助于确认您为客户提供的内容正是其所需要的。 扩展应用查证(EAV: Extended Application Verification) EAV是另一种服务检查，用于确认运行在某个服务器上的应用能否对客户请求作出响应。为完成这种检查，BIG/IP控制器使用一个被称作外部服务检查者的客户程序，该程序为BIG/IP提供完全客户化的服务检查功能，但它位于BIG/IP控制器的外部。例如，该外部服务检查者可以查证一个Internet或Intranet上的从后台数据库中取出数据并在HTML网页上显示的应用能否正常工作。EAV是BIG/IP提供的非常独特的功能，它提供管理者将BIG/IP客户化后访问各种各样应用的能力，该功能使BIG/IP在提供标准的可用性查证之外能获得服务器、应用及内容可用性等最重要的反馈。 该功能对于电子商务和其它应用至关重要，它用于从客户的角度测试您的站点。例如，您可以模拟客户完成交易所需的所有步骤－连接到站点、从目录中选择项目以及验证交易使用的信用卡。一旦BIG/ip掌握了该“可用性”信息，即可利用负载均衡使资源达到最高的可用性。 BIG/ip已经为测试Internet服务的健康情况和状态，预定义的扩展应用验证(EAV)，它有二种用户界面：浏览器和CLI配置。BIG/IP预定义的应用检查：FTP、NNTP、SMTP、POP3和MSSQL。 2.3 负载均衡和应用交换功能,通过各种策略导向到合适的服务器 BIGIP是一台对流量和内容进行管理分配的设备。它提供12种灵活的算法将数据流有效地转发到它所连接的服务器群。而面对用户，只是一台虚拟服务器。用户此时只须记住一台服务器，即虚拟服务器。但他们的数据流却被BIGIP灵活地均衡到所有的服务器。这12种算法包括： 轮询（Round Robin）：顺序循环将请求一次顺序循环地连接每个服务器。当其中某个服务器发生第二到第7层的故障，BIG/IP就把其从顺序循环队列中拿出，不参加下一次的轮询，直到其恢复正常。 比率（Ratio）：给每个服务器分配一个加权值为比例，根椐这个比例，把用户的请求分配到每个服务器。当其中某个服务器发生第二到第7层的故障，BIG/IP就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。 优先权（Priority）：给所有服务器分组，给每个组定义优先权，BIG/IP用户的请求，分配给优先级最高的服务器组（在同一组内，采用轮询或比率算法，分配用户的请求）；当最高优先级中所有服务器出现故障，BIG/IP才将请求送给次优先级的服务器组。这种方式，实际为用户提供一种热备份的方式。 最少的连接方式（Least Connection）：传递新的连接给那些进行最少连接处理的服务器。当其中某个服务器发生第二到第7层的故障，BIG/IP就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。 最快模式（Fastest）：传递连接给那些响应最快的服务器。当其中某个服务器发生第二到第7层的故障，BIG/IP就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。 观察模式（Observed）：连接数目和响应时间以这两项的最佳均衡为依据为新的请求选择服务器。当其中某个服务器发生第二到第7层的故障，BIG/IP就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。 预测模式（Predictive）：BIG/IP利用收集到的服务器当前的性能指标，进行预测分析，选择一台服务器在下一个时间片内，其性能将达到最佳的服务器相应用户的请求。(被bigip进行检测) 动态性能分配（Dynamic Ratio-APM):BIG/IP收集到的应用程序和应用服务器的各项性能参数，动态调整流量分配。 动态服务器补充（Dynamic Server Act.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f8e9e4a52494dd82191da7468558733/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95db80448747d4e86549d4d19ab37cb0/" rel="bookmark">
			解决缺少streams.h的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在编译一个网上下载的源文件时，发现有个缺少streams.h的错误。摸索了很久，最终解决，方法如下：
首先在电脑中搜索出streams.h文件的位置，我电脑中文件的路径如下：。于是在VC6.0的TOOL中的options的directories选项中包含这个include的项，如下：。再重新编译，发现又少了reftime.h文件，再在电脑中进行搜索，发现路径在SDK包中：，同上，再将该目录包含到编译器中区。再中心编译。除此之外还需要包含一个：dxsdk\samples\c++\common\include。方法相同。
有了这个例子，以后解决类似的缺少头文件的错误就很容易了，按照相同的方法，一步步的解决就可以了。当然，如果网上有现成的方法，直接照搬就行，节省时间嘛。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e5eb90168a4e713c9d48b847862f463/" rel="bookmark">
			VC&#43;&#43;6.0关于分割窗口的CSize初始大小不起作用问题的解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先多谢小虫同学一直关注我的博客，昨日小虫同学按照我的分割窗体的文章举一反三自己写了一段代码，但是运行后发现问题，即，分割后显示的大小和CSize设置的初始大小不一样，那么我们现在来看一下这段代码：
BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext) {
// TODO: Add your specialized code here and/or call the base class
//创建一个静态分栏窗口，分为1行2列
CRect rect;
GetClientRect(&amp;rect);
if(wndSplitter_erect.CreateStatic(this,1,2)==NULL) return FALSE;
wndSplitter_erect.CreateView(0,1,RUNTIME_CLASS(CDownView),CSize(rect.Width()-rect.Width()/6,rect.Height()),pContext);
if(wndSplitter_horizontal.CreateStatic(&amp;wndSplitter_erect,2,1,WS_CHILD|WS_VISIBLE, wndSplitter_erect.IdFromRowCol(0, 0))==NULL)
return FALSE;
wndSplitter_horizontal.CreateView(0,0,RUNTIME_CLASS(CUpView),CSize(rect.Width()/6,rect.Height()/3),pContext);
wndSplitter_horizontal.CreateView(1,0,RUNTIME_CLASS(CLeftView),CSize(rect.Width()/6,rect.Height()-rect.Height()/3),pContext);
return TRUE;
//return CFrameWnd::OnCreateClient(lpcs, pContext);
}
我把这段代码运行一遍以后发现，CLeftView占满了整个视图，而CDownView和CUpView则被压缩为一小条。
好了，现在先来分析一下这段代码，首先将视图分割为一行两列，再然后将第一列分为两行一列，原本看似没有什么问题的程序，为什么运行起来就出问题了呢？
这个问题在于，第一次把视图分为一行两列后，我们指定了第二列的宽度，但是我们没有指定第一列的宽度，后来，我们又将第一列分为两行一列了，虽然第二次分割为两个视图CDownView和CUpView指定了宽和高，但是，它的父视图，即第一次分割后的第一列没有指定，系统则自动将大小设为0了。所以，我们看到的CDownView和CUpView被压缩为一小条。
现在我们把问题的原因搞清楚了，那么有什么解决办法呢？现在我们来看两个函数，如下：
1、SetRowInfo函数：
CSplitterWnd::SetRowInfo
void SetRowInfo( int row, int cyIdeal, int cyMin );
参数： row 指定一个分隔器窗口行。 cyIdeal 指定分隔器窗口行的以像素表示的理想高度。 cyMin 指定分隔器窗口行以像素表示的最小高度。
现在我通俗的解释下这三个参数，row：表示要设置哪行的高度。cyldeal：表示你所要设置的理想行高，即显示时的高度。cyMin：表示当用鼠标拖动分隔条的时候，此行的最小高度，通常，我们设置为0即可。
2、SetColumInfo函数：
CSplitterWnd::SetColumnInfo
void SetColumnInfo( int col, int cxIdeal, int cxMin );
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e5eb90168a4e713c9d48b847862f463/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d59c73708720ba71ed3f3966f7db3ae5/" rel="bookmark">
			Android工程师不得不看的建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关键字： Android 随着移动平台的发展和其应用的不断改善，质量成为决定成败的关键。用户要求他们选择安装的应用响应快、性能好，如果某个应用不能提供卓越的功能和稳定的用户体验，那这样的应用注定会被很快卸载。
尽管现在Android智能手机和平板电脑的运行速率越来越快，但开发者仍需牢记，应用的运行环境仍受到电池和处理器等诸多资源的限制。以下是如何为应用“瘦身”的十条建议，以便能在当前和以后的所有Android设备都能运行出最佳效果。
1）首先要有良好的编码习惯
一个优秀的开发者应该善于运用常识、完善的算法和标准设计模式。要有资源意识，打开了就要记得关闭，尽量做到晚获取，早释放。这些由来已久的编码准则同样适用Android应用开发，尤其是使用基础设备服务时。
2）让阻塞操作远离主UI线程
通过使用AsyncTask、线程、IntentService和自定义后台服务，保证应用的灵活性。使用加载工具简化游标等长时间加载数据的状态管理。当有其他程序运行时，不能让你的应用滞后或中止。
如果一个操作需要消耗较多时间和资源时，取消该操作，换成异步处理，这样应用就能保持响应，用户可以继续各种操作。该方法适用磁盘读写、访问内容提供方、数据库和互联网，以及解析和其他需要花费较长时间的任务。
3）使用最新的Android SDK版本和API
使用Android平台的最新产品，保证你的应用紧跟Android的更新步伐。随着Android平台的不断发展，部分功能可能被弃用或被更好的功能取代，核心API接收了bug修复和性能改进，新API有助于开发者编写出更稳定的应用。要明白最佳的做法总是随着时间的推移而变，聪明的开发者应该总是站在整个平台的最前沿。
4）考虑使用StrictMode
从Android 2.3开始提供了一个新的类StrictMode，该类可以用于捕捉发生在应用程序主线程中耗时的磁盘、网络访问或函数调用，可以帮助开发者改进程序，使主线程处理UI和动画在磁盘读写和网络操作时变得更平滑，避免主线程被阻塞。
5）发布前禁用或尽量减少调试
如果开发周期较长，你很可能在应用中内置了一些日志或调试代码，在发布前确保这些功能已经最小化或完全禁用。
6）确保UI布局简单优雅
简单的屏幕不仅方便阅读，还能加快加载速度。与其在一个单一屏幕上堆砌太多不必要的功能，不如花时间去开发优雅的用户界面。简单优雅的UI不仅能提高应用性能，还能提高用户使用该应用时的效率。
7）根据目标设备调整应用资源
为尽可能高效地被加载，需要根据具体设备的配置调整相应资源，尤其是图片资源。为使应用包文件合理适用不同设备，首先可只添加运行该应用需要的核心资源，然后再根据具体设备下载相关内容。
8）使用Hierachy Viewer可视化调试工具
Hierachy Viewer能很方便地在开发者设计，调试和调整界面时，快速定位问题，解决问题，提高开发效率。
9）使用layoutopt进行布局优化
Layoutopt是一款简单的命令行工具，可帮助找到不必要的控件嵌套以及缩减布局资源，从而使应用变得可能“苗条”。控件越少、布局层次越浅，性能就越好。
10）使用Traceview及其他Android工具进行分析
Android SDK随带了很多用于应用分析的工具，其中最受欢迎的是Traceview，这款图形工具可以帮助调试和找到应用中的性能瓶颈。
结语
提升Android应用性能的方法有很多，有些需要使用特定的算法，有些依赖切实可行的调试和性能监测技术。幸运的是，Android平台随带了众多免费的实用工具，可以帮助跟踪和解决应用程序中的性能问题。
转载处 http://mips.eefocus.com/article/11-12/2453681323092039.html?sort=1751_0_0_0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef8d8cdfa5da88f439f76086c50bfce7/" rel="bookmark">
			Windows进程间各种通信方式浅谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Windows进程间通信的各种方法 进程是装入内存并准备执行的程序，每个进程都有私有的虚拟地址空间，由代码、数据以及它可利用的系统资源(如文件、管道等)组成。多进程/多线程是Windows操作系统的一个基本特征。Microsoft Win32应用编程接口(Application Programming Interface, API)提供了大量支持应用程序间数据共享和交换的机制，这些机制行使的活动称为进程间通信(InterProcess Communication, IPC)，进程通信就是指不同进程间进行数据共享和数据交换。 正因为使用Win32 API进行进程通信方式有多种，如何选择恰当的通信方式就成为应用开发中的一个重要问题，下面本文将对Win32中进程通信的几种方法加以分析和比较。 2 进程通信方法 2.1 文件映射 文件映射(Memory-Mapped Files)能使进程把文件内容当作进程地址区间一块内存那样来对待。因此，进程不必使用文件I/O操作，只需简单的指针操作就可读取和修改文件的内容。 Win32 API允许多个进程访问同一文件映射对象，各个进程在它自己的地址空间里接收内存的指针。通过使用这些指针，不同进程就可以读或修改文件的内容，实现了对文件中数据的共享。 应用程序有三种方法来使多个进程共享一个文件映射对象。 (1)继承：第一个进程建立文件映射对象，它的子进程继承该对象的句柄。 (2)命名文件映射：第一个进程在建立文件映射对象时可以给该对象指定一个名字(可与文件名不同)。第二个进程可通过这个名字打开此文件映射对象。另外，第一个进程也可以通过一些其它IPC机制(有名管道、邮件槽等)把名字传给第二个进程。 (3)句柄复制：第一个进程建立文件映射对象，然后通过其它IPC机制(有名管道、邮件槽等)把对象句柄传递给第二个进程。第二个进程复制该句柄就取得对该文件映射对象的访问权限。 文件映射是在多个进程间共享数据的非常有效方法，有较好的安全性。但文件映射只能用于本地机器的进程之间，不能用于网络中，而开发者还必须控制进程间的同步。 2.2 共享内存 Win32 API中共享内存(Shared Memory)实际就是文件映射的一种特殊情况。进程在创建文件映射对象时用0xFFFFFFFF来代替 文件句柄(HANDLE)，就表示了对应的文件映射对象是从操作系统页面文件访问内存，其它进程打开该文件映射对象就可以访问该内存块。由于共享内存是用 文件映射实现的，所以它也有较好的安全性，也只能运行于同一计算机上的进程之间。 a.设定一块共享内存区域 HANDLE CreateFileMapping(HANDLE,LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCSTR)// 产生一个file-mapping核心对象 LPVOID MapViewOfFile( HANDLE hFileMappingObject, DWORD dwDesiredAcess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, DWORD dwNumberOfBytesToMap );得到共享内存的指针 b.找出共享内存 决定这块内存要以点对点（peer to peer)的形式呈现每个进程都必须有相同的能力，产生共享内存并将它初始化。每个进程都应该调用CreateFileMapping(),然后调用GetLastError().如果传回的错误代码是 ERROR_ALREADY_EXISTS,那么进程就可以假设这一共享内存区 域已经被别的进程打开并初始化了，否则该进程就可以合理的认为自己 排在第 一位，并接下来将共享内存初始化。还是要使用client/server架构中只有server进程才应该产生并初始化共享内存。所有的进程都应该使用 HANDLE OpenFileMapping(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName); 再调用MapViewOfFile(),取得共享内存的指针 c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef8d8cdfa5da88f439f76086c50bfce7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1683159c9274704c6434fb7612c7e391/" rel="bookmark">
			在objc项目中使用常量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		objc不像java，有静态常量。比如：
public static final RADIAS=180;
目前我的做法是，使用c的预处理#define。比如，在头文件中：
#define MIN_VELOCITY 10 #define LOOP_COUNT 100
@interface AnimationView : UIView &lt;UIGestureRecognizerDelegate&gt;{
在代码中使用：
if (data.panLocation.x&lt;MIN_X) { data.panLocation.x=MIN_X; }
这些预定义常量，会在编译器编译的时候用define中定义的字符串替代。
——————————————————————————————————————————————————————————
在objc项目中使用常量的最佳实践 之前，在在objc项目中使用常量中，使用c的预处理#define来设置常量。比如，可以做个头文件，然后在需要的类文件中import，使用常量。
但这不是最佳实践。这样做可能是最好的方式，首先在比如叫Constants.h的头文件中：
#import &lt;Foundation/Foundation.h&gt;
extern NSString * const kInitURL;
@interface Constants : NSObject {
}
@end
这里使用到extern c关键字，表示这个变量已经声明，只是引用。const关键字表示变量是常量，不可修改。
在objc的约定里，常量也是大小写混排的驼峰命名规则，首字母小写，另外，第一个字母是k。
然后，在Constants.m文件中：
#import "Constants.h"
NSString * const kInitURL = @"http://marshal.easymorse.com";
@implementation Constants
@end
在这里给常量kInitURL赋值。
如何使用常量？只需在所需的m文件引入Constants头文件，下面是使用示例：
#import "BasicDemosViewController.h" #import "Constants.h"
@implementation BasicDemosViewController
// Implement loadView to create a view hierarchy programmatically, without using a nib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1683159c9274704c6434fb7612c7e391/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/482/">«</a>
	<span class="pagination__item pagination__item--current">483/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/484/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>