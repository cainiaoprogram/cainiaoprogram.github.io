<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f947fe812ec8cbf6a3e47d78bbf08c6f/" rel="bookmark">
			ai个性化 国庆 头像 合成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码地址 https://github.com/tencentmusic/cube-studio/tree/master/aihub/deep-learning/face-paint/web
实现过程 将个人头像人体人脸识别，裁剪出肩膀以上部分，并将图片进行卡通化处理，最后与背景图片和文字合成，效果如下
实现代码：
import argparse import base64 import datetime import os import sys import cv2 import numpy as np from tqdm import tqdm import pysnooper from PIL import ImageFont from PIL import Image from PIL import ImageDraw from paddleseg.utils import get_sys_env, logger, get_image_list from infer import Predictor import os import dlib import collections from typing import Union, List import numpy as np from PIL import Image import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f947fe812ec8cbf6a3e47d78bbf08c6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add6a30c99419e73331b7e03241d61c8/" rel="bookmark">
			Person re-identification行人重识别（二）——实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于上次的文章再次进行补充：http://t.csdn.cn/75EPC
在这篇文章开始前，我使用了模型《Relation-Aware Global Attention》去进行实践，但是环境配置一直出现问题，首先是环境配置的问题，torch与numpy的版本无法正常的匹配，还要无法检测到torch的一些函数等等问题，这一篇主要是要针对《Relation Network for Person Re-identification》这篇论文进行实践。
目录
0x01 基于行人局部特征融合的再识别实战
（一）数据集的准备
（二）参数配置
（三）配置环境依赖
（四）数据源构建方法分析
（五）dataloader加载顺序解读
（六）网络计算整体流程
（七）损失函数
（八）开始训练以及测试
0x01 基于行人局部特征融合的再识别实战 （一）数据集的准备 pid（人）+摄像头的编号+每个摄像头对应的图片id：
那么数据集的文件下就有这些文件：
可以注意到有一个名称为poses的文件，这个文件是用于训练检测人体姿态的信息，用于姿态估计，在这个当前的情景下我们是用不上了，可以删掉。
再看看json文件：
splits.json是数据集的划分。
meta.json是数据集的对每个人每组摄像头的数据进行处理，将每个人的数据以及对应的摄像头为一组，使用【】括起来，最后再把每个人的数据全都括起来：
（二）参数配置 使用pycharm打开下载好的源码，之后可以发现有这么几行参数：
在训练的时候指定GPU就可以了，比如我刚开始训练在py文件后带上：--gpus 0。源码GitHub在这里：https://github.com/cvlab-yonsei/RRID
（三）配置环境依赖 Python 3.6 PyTorch &gt;= 0.4.1 numpy h5py 那么就使用anaconda来进行配置叭：
conda create -n RRID python==3.6 conda activate RRID 这里我是使用gpu跑的，安装符合要求的pytorch：
conda install pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 cudatoolkit=10.2 -c pytorch conda install numpy conda install h5py （四）数据源构建方法分析 构建dataset：
# Dataset Loader dataset, train_loader, val_loader, _ = get_data(args.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/add6a30c99419e73331b7e03241d61c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7cefcafb0a0a9881d0a5374dd61ad94/" rel="bookmark">
			HTML教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章.HTML标签 网页格式	html	网页的开始与结束。 body	网页的主体部分，显示在网页中用户可以浏览到的内容。 head	网页的头部，大部分不显示在用户浏览界面。 meta	网页的摘要信息，不会显示在浏览器浏览界面。 title	网页标签，显示在浏览器中用户看到的标签。 table	表格的开始和结束，但是表格是由行和列组成。 tr	组成表格的行。 td	组成表格的列。 colspan	表格的跨列。 rowspan	表格的跨行。 thead	表格头部。 tbody	表格主体。 tfoot	表格尾部。 cellpadding	表格中文本与表格边框的距离。 cellspacing	表格中表格与表格的距离。 h1--h6	网页中文本标题标签，以次是从大到小。 sub	文本下标标签。 sup	文本上标标签。 &amp;	文本特殊符号索引标签。 p	换段落。 br	换行。 hr	水平线。 img	图片掉用标签。 a	超链接标签 ul	无序列表,内部使用li。 ol	有序列表,内部使用li。 dl	列标签，dt文本顶头，dd文本缩进。 &lt;!-- --&gt;	注释内容，网页中不显示。 form	表单的开始于结尾，中间包含的内容是待提交的内容。 text	单行文本框。 password	密码框。 radio	单选按钮。 file	文件域。 textarea	多行文本框。 checkbox	多选按钮。 select	列表框。 option	用于列表框中书写列表内容。 input	插入表单元素。 submit	提交按钮。 reset	重置按钮。 button	普通按钮。 image	图片按钮。 iframe	内嵌框架。 font	字体。 marquee	滚动标签(behavior=滚动方式)（direction=滚动方向）（scrollamount=滚动速度） css规则定义代码对应关系	区块	table-caption	表格标题	list-style-image 代码	说明	word-spacing	单词间距	inherit	继承	list-style-position 类型	letter-spacing	字母间距	方框	inside font-family	字体	vertical-align	垂直对齐	width	宽度	outside font-size	字体大小	baseline	基线	height	高度	定位 font-style	字体样式	sub	下标	float	浮动	position italic	斜体	super	上标	clear	清楚	absolute oblique	偏斜体	top	顶部	padding	填充	fixed line-height	行间距/行高	text-top	文本顶对齐	margin	边界	relative font-weight	字体粗细	middle	中线对齐	top	上	static font-variant	字体变形	bottom	底部	right	右	visibility small-caps	小型大写字母	text-bottom	文本底对齐	bottom	下	inherit text-transform	大小写	text-align	文本对齐	left	左	visible capitalize	首字母大写	text-indent	文本缩进	边框	hidden uppercase	大写字母	white-space	空格	style	样式	width lowercase	小写字母	normal	正常	dotted	点划线	z-index text-decoration	文本修饰	pre	保留	dashed	虚线	height underline	下划线	nowrap	不换行	solid	实线	overflow overline	上划线	display	显示	double	双线	scroll line-through	删除线	inline	内嵌	groove	槽状	placement blink	闪烁	block	块	ridge	脊状	clip none	无	list-item	列表项	inset	凹陷	扩展 color	颜色	run-in	追加部分	outset	突出	page-break-before 背景	inline-block	内联块	width	宽度	page-break-after background-color	背景颜色	compact	紧凑	color	颜色	auto background-image	背景图片	marker	标记	列表	always background-repeat	背景重复	table	表格	list-style-type	类型	cursor backgrount-attachment	附件	inline-table	内嵌表格	disc	圆点	filter fixed	固定的	table-row-group	表格行组	circle	圆圈	scroll	滚动	table-header-group	表格标题组	square	方块	background-position(X)	背景水平位置	table-footer-group	表格注脚组	decimal	数字	background-position(Y)	背景垂直位置	table-row	表格行	lower-roman	小写罗马数字	right	右对齐	table-column-group	表格列组	upper-roman	大写罗马数字	center	居中对齐	table-column	表格列	lower-alpha	小写字母	left	左对齐	table-cell	表格单元格	upper-alpha	大写字母	&lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7cefcafb0a0a9881d0a5374dd61ad94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4a212c0f2f680a1b3fe65dbf2e4b149/" rel="bookmark">
			RTMP直播推流（二）音频推流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		音频推流java层代码：
package com.example.push.channel; import static android.media.AudioFormat.CHANNEL_IN_STEREO; import android.media.AudioFormat; import android.media.AudioRecord; import android.media.MediaRecorder; import com.example.push.LivePusher; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class AudioChannel { private int inputSamples; private ExecutorService executor; private AudioRecord audioRecord; private LivePusher mLivePusher; private int channels=2; private boolean isLiving; public AudioChannel(LivePusher livePusher){ mLivePusher=livePusher; //启动一个线程 线程池 executor = Executors.newSingleThreadExecutor(); //准备录音机 来采集pcm数据 传送到native层 int channelConfig; if (channels==2){ channelConfig= AudioFormat.CHANNEL_IN_STEREO; }else { channelConfig= AudioFormat.CHANNEL_IN_MONO; } mLivePusher.native_setAudioEncInfo( 44100, channels) ; //16位 两个字节 inputSamples= mLivePusher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4a212c0f2f680a1b3fe65dbf2e4b149/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af943f1dd0a8f0915525c2bda3fd936a/" rel="bookmark">
			全排列demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 从0到10^n - 1全排列。
class Solution: def printNumbers(self, n: int) -&gt; List[int]: res = [] #记录全排列结果 nums = [] #记录单次排列结果 idx = 0 #记录单次排列位置 def dfs(idx): if idx == n:#判断终止条件，加入res结果 res.append(int("".join(nums))) return #终止搜索 #搜索空间 for i in range(10): #搜索结果生效进nums nums.append(str(i)) #开启下个位置搜索 dfs(idx+1) #退栈/列表 nums.pop(-1) dfs(idx) return res 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75f595e793028787dbae1550af772043/" rel="bookmark">
			最新 | Ask Me Anything 一种提示(Prompt)语言模型的简单策略（斯坦福大学 &amp; 含源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源: AINLPer微信公众号（每日干货分享！！）
编辑: ShuYini
校稿: ShuYini
时间: 2022-09-30
引言 提示(Prompt)的微小变化就会引起大型语言模型(LLM)较大的性能变化，这将会有大量时间花费在提示（prompt）设计上。为此本文提出了ASK ME ANYTHING(AMA)方法，该方法首先产生多个有效且不完美的prompt，然后将它们进行聚合，最后产生高质量的提示(prompt)。
关注 AINLPer公众号，最新干货第一时间送达
背景介绍 大型语言模型(LLM)让我们更接近任务无关机器学习的目标。LLM 不是为新任务训练模型，而是开箱即用地应用于新任务。在上下文学习的范式中，通过自然语言任务规范或提示（prompt）来控制LLM。其中提示（prompt）由模板定义，该模板包含用于描述和表示任务输入和输出的占位符。
最近的工作评估了LLM在一系列任务中的提示（prompt）性能，实验发现，提示（prompt）的微小变化会导致较大的性能变化。并且提示（prompt）性能还取决于所选LLM系列和模型大小。为了提高可靠性，大量的工作致力于精心设计一个完美的提示（prompt）。例如，就有专家建议用户手动探索大型搜索空间的策略，以便在逐个任务的基础上优化提示（prompt）。
相反，本文考虑聚合多个有效但不完美的提示（prompt）的预测，以提高在各种的模型和任务上的提示（prompt）性能。 给定一个任务输入，每个提示（prompt）都会对输入的真实标签进行投票，这些投票被聚合以产生最终预测。
遇到的问题 在追求聚合的高质量提示（prompt）过程中，我们面临以下挑战：
高质量的提示（Effective prompts）：高质量的提示是聚合效果提升的首要条件。在两个SuperGLUE任务(CB, RTE)中，我们采用了原始提示，这些提示产生了近乎随机的性能。以相同的格式生成多个提示并在提示之间进行多数投票预测的影响较小(CB为+4%)，甚至可能损害平均提示性能(RTE为-2%)。许多改进提示（prompt）的建议关注单一任务类型，并基于单一模型系列和/或大小进行评估。为此，我们需要一个跨任务和模型工作的提示结构。
可扩展的集合(Scalable collection) ：在确定有效的提示格式之后，我们需要获得这些格式的多个提示----这些提示主要是为输入的真实标签收集投票。任务的原始格式变化很大，之前的工作以特定于任务的方式手动将输入示例重写为新格式，这是具有挑战性的扩展。我们需要一种可伸缩的策略来重新格式化任务输入。
提示聚合(Prompt aggregation) ：使用上面的提示(对于CB和RTE)，我们看到准确性的平均变化为9.5%，并且错误的Jaccard指数比识别提示错误高出69%。之前提示工作中，多数投票(MV)是主要无监督聚合策略，但它没有考虑这两种特性，因此不可靠。我们需要一种策略来解释不同的准确性和依赖性。
AMA模型方法介绍 问题解决 1、识别提示的属性，这些属性可以提升跨任务、模型类型和模型大小的效率。我们研究了先前工作分类的标准提示格式，发现支持开放式回答(“约翰去哪儿了?”)的提示比将模型输出限制为特定tokens 的提示更有效。例如，将[Brown等人，2020]中最初的限制性格式中的三个SuperGLUE任务(CB、RTE、WSC)转换为开放式格式可以提高72%的性能。给定一个任务输入，我们发现根据输入形成问题、提示LLM回答问题的简单结构，可以适用于相当普遍的情况并在不同的基准测试任务中提升性能。
2、提出了一种可伸缩地将任务输入重新格式化为(1)中发现的有效格式的策略。通过在固定的两步管道中递归地使用LLM本身，将任务输入转换为有效的开放式问答格式。我们首先使用question()提示符，它包含如何将语句转换为各种(例如，yes-no，完形填空)问题的任务无关示例，然后使用answer()提示符演示回答问题的方法(例如，简明或冗长的回答)。应用提示链-答案(问题(x)) ----给出输入 x 2 x^2 x2的最终预测。该链可以在输入之间重复使用，并组合不同的功能提示对来产生多样性。我们将不同的功能提示链应用于输入，为输入的真实标签收集多次投票。
3、使用弱监督(WS)来可靠地聚合预测。实验发现，由不同链的预测所产生的误差可以是高度变化和相关的。虽然多数投票(MV)可能在某些提示集上表现良好，但在上述情况下表现不佳。AMA通过识别提示之间的依赖关系并使用WS来解释这些情况，WS是在没有任何标记数据的情况下建模和组合噪声预测的过程。这里，本文首次将WS广泛应用于提示，表明它提高了使用现成的LLM并且无需进一步训练。
AMA模型方法 总结以上问题解决方法，本文提出了 ASK ME ANYTHING PROMPTING (AMA)，这是一种简单的方法，它不仅使开源 LLM 的参数减少30倍，而且超过了 GPT3-175B 的Few-Shot性能。
其中如上图所示：AMA首先递归地使用LLM将任务和提示重新格式化为有效的格式，然后使用弱监督聚合跨提示的预测。重新格式化是使用提示链来执行的，提示链由在不同的任务输入上操作的功能性(固定的、可重用的)提示组成。在这里，给定输入示例，提示链包括一个question()提示符，LLM通过这个提示符将输入声明转换为一个问题，以及一个answer()提示符，LLM通过这个提示符回答它生成的问题。不同的提示链(即不同的上下文问题和答案演示)导致对输入的真实标签的不同预测。
实验结果 1、下表1中比较开源GPT-J-6B和Few-Shot(k∈[32…70])GPT3- 175B的基准测试结果。可以发现，在20个基准测试中，有15个开源6B参数模型超过了GPT3-175B模型的平均Few-Shot性能。在20个任务中，AMA比6B参数模型的少次数(k = 3)性能平均提高了41%。
2、跨模型大小的分析和基准评估。 我们报告了 AMA 对少样本 (k = 3) 性能的绝对提升，平均超过 7 个任务，置信区间为 95%（左）。 按 7 项任务的平均 AMA 提升排序（右）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75f595e793028787dbae1550af772043/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bb1660f1b33d5d4bf0ce3ab27d10dfd/" rel="bookmark">
			eNSP基础命令_01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eNSP 是一款由华为提供的、可扩展的、图形化操作的网络仿真工具平台。
主要对企业网络路由器、交换机进行软件仿真，完美呈现真实设备实景，支持大型网络模拟，让广大用户有机会在没有真实设备的情况下能够模拟演练，学习网络技术
路由：数据出去旅游
命令不区分大小写
视图区分
1. &lt;ensp&gt; 用户视图
2. [ensp] 系统视图
3. [ensp-GigabitEthernet0/0/1] 接口视图
&lt;ensp&gt;display version //查看版本
&lt;ensp&gt;save //保存
&lt;ensp&gt;system-view //进入系统视图
[ensp] interface Gigbitethernet0/0/1 //进入 g0/0/1的接口视图
[ensp]display current-configuration //查看当前所有配置
[ensp-GigabitEthernet0/0/1]shutdown //禁用接口 g0/0/1
[ensp-GigabitEthernet0/0/1]undo shutdown //开启接口g0/0/1
quit //返回上一个视图
return //返回用户视图 或 ctrl +z &lt;ensp&gt;language-mode Chinese //更改语言为中文（不推荐）
Change language mode, confirm? [Y/N] y
提示：改变语言模式成功。
&lt;ensp&gt;undo terminal monitor //关闭终端提示
&lt;ensp&gt;reset saved-configuration ·//恢复出厂设置
&lt;Huawei&gt;reboot //重启
Info: The system is now comparing the configuration, please wait.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bb1660f1b33d5d4bf0ce3ab27d10dfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c5a80d169ec073818f10127c29ddc6/" rel="bookmark">
			reactive-native踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IOS篇 1.Failed to install Cocopods depencies for iOS project 按照提示的命令进入ios的文件夹执行[pod install]，这个是由于网络问题导致pod的依赖无法下载安装，所以执行命令的时候能够科学上网即可，目前几个RN版本都已经不支持手动去下载依赖包放到本地缓存目录的方式了。如果在install的过程中还有失败，如下图所示，继续保持顺畅的网络执行pod install，直到全部完成。
以最新的0.70版本为例，一共下载了如下依赖包
2.error Failed to build iOS project. We ran "xcodebuild" command but it exited with error code 65. 问题出现环境
Rn版本：0.70
Mac系统: 10.15
Xcode版本：12.4
该问题在网上搜索有各种说法，但是试下来都没有解决问题，把整个项目复制到mac 12.x/Xcode 13.x的系统上便可以正常运行了，这么看来是运行环境的问题(按理说应该有兼容的处理，目前对于rn不够深入，暂没有找到好的解决方案)。
考虑到之前是有运行起来过rn，于是通过逐个降低版本进行测试，在当前环境下可以运行0.66.0版本(环境搭建都是采用的官方react-native命令行工具)。
3. We ran "xcodebuild" command but it exited with error code 65. 问题出现环境
Rn版本：0.66.0
Mac系统: 10.15
Xcode版本：12.4
解决方案：到ios目录下，使用Xcode运行.xcworkspace
4.react-native/Libraries/Vibration/RCTVibration.mm:16:28: Cannot find protocol declaration for 'NativeVibrationSpec' 问题出现环境
Rn版本：0.66.0
Mac系统: 10.15
Xcode版本：12.4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60c5a80d169ec073818f10127c29ddc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eefe345aedc733890cd525dd8c89cc08/" rel="bookmark">
			文件在IDEA中已进行Git的Commit操作，使其从暂存区提交到本地仓库，但是未Push到远程仓库，此时进行Pull操作出现代码冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述：文件在IDEA中已进行Git的Commit操作，使其从暂存区提交到本地仓库，但是未Push到远程仓库，此时进行Pull操作出现代码冲突
解决方法：出现上述情况时，我们要先将文件从本地仓库中拉取到工作区，等待合并之后再进行其它操作
第一步：找到VCS--&gt;Git下面的“ Reset HEAD”
第二步：点击上述的“ Reset HEAD”之后就会弹出如下所示的界面
此处我们在上述输入“head~1”并点击Reset之后就可以将最近一次提交到本地仓库的所有文件拉取到工作区。
上述这些操作对应的Git命令为：
git reset head~1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/074f659c651194f2691a7ed17c424e8e/" rel="bookmark">
			c# modbus/Tcp通讯连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、新建一个Winform窗体应用
二、建好后添加管理程序包
三、在浏览中输入EasyModbus,找到第一个包下载
四、代码部分
using EasyModbus;
using System;
using System.Windows.Forms;
namespace Modbus
{
public partial class Form1 : Form
{
public Form1()
{
InitializeComponent();
}
static ModbusClient mc; private void button4_Click(object sender, EventArgs e)
{
try
{
int add = Convert.ToInt32(textBox1.Text);
int num = Convert.ToInt32(textBox2.Text);
mc.WriteSingleRegister(add, num);
}
catch (Exception ex)
{
MessageBox.Show(ex.Message);
}
}
private void button1_Click(object sender, EventArgs e)
{
try
{
mc = new ModbusClient();
mc.Connect(textBox6.Text, Convert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/074f659c651194f2691a7ed17c424e8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7fbccab2ad86d3e97b15e233c24c9ba/" rel="bookmark">
			Spring同一个class类中的@Transactional事务调用另一个事务不生效的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java的Impl实现层中，经常会遇到如下的方法之间调用
public class xxxServiceImpl implements xxxService { @Override @Transactional public void A() { …… B(); } @Transactional private void B() { …… } } 事务方法A() 中调用事务方法B() ，在执行代码的时候会发现，B方法出现异常后，事务不会回滚。
Spring采用动态代理(AOP)实现对Bean的管理和切片，它为我们的每个class生成一个代理对象。只有在代理对象之间进行调用时，可以触发切面逻辑。而在同一个class类中，方法A调用方法B，调用的是原对象的方法，而不是代理对象。所以直接调用当前类中的事务方法是不会生效的。
解决方案：
方法一：调用新事务方法时，将当前事务挂起，重新开启另一个新的事务来执行语句
1、启动类：添加注解@EnableAspectJAutoProxy(exposeProxy = true)
import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.EnableAspectJAutoProxy; @SpringBootApplication @EnableAspectJAutoProxy(exposeProxy = true) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 2、实现类：通过AopContext.currentProxy())代理的方式调用
public class xxxServiceImpl implements xxxService { @Override @Transactional(propagation = Propagation.REQUIRED) public void A() { …… ((xxxServiceImpl) AopContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7fbccab2ad86d3e97b15e233c24c9ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08898f21701c194559b71a42862e838a/" rel="bookmark">
			Java Io流学习理解（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JAVA IO流的学习理解 JAVA IO流简介JAVA IO流的类包以及使用方法JAVA NIO流（同步非阻塞）简介JAVA NIO2流（AIO：异步非阻塞）简介结论 JAVA IO流简介 Java IO是实现输入和输出的基础，可以方便的实现数据的输入和输出操作。通过流的形式允许Java程序使用相同的方式来访问不同的输出/输入源。根据数据流向的不同，可以分为输入(Input)和输出(Output)流两种。 JAVA IO流的类包以及使用方法 数据流可以分为输入输出两大流向，细分可以分为：字节输入流、字符输入流、字节输出流、字符输出流 输入流: 只能从中读取数据，不能向其写入数据，InputStream是字节输入流，Reader是字符输入流，它们是所有的输入流的基类。
输入流字符字节抽象基类ReaderInputStream访问文件FileInputStreamFileReader访问数组ByteArrayInputStreamCharArrayReader访问管道PipedInputStreamPipedReader访问字符串无StringReader缓冲流BufferedInputStreamBufferedReader转换流无InputStreamReader对象流ObjectInputStream无抽象基类FilterInputStreamFilterReader特殊流DataInputStream无 输出流:只能向其写入数据，不能向其读取数据，OutputStream是字节输出流，Writer是字符输出流，它们是所有输出流的基类。
JAVA NIO流（同步非阻塞）简介 JAVA NIO2流（AIO：异步非阻塞）简介 2021-12-12 11:33:47
结论 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a04fa4430db83b3609ddcb8a642b37/" rel="bookmark">
			Pycharm: cannot find declaration to go to无法跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		莫名其妙重启项目之后pycharm左侧的project导航全部变为有个浅黄色阴影，并且project中所有的定义都没法跳转，点击都是提示“cannot find declaration to go to”
解决办法：
File-&gt;Setting-&gt;Project-&gt;project structure进去以后是空白的。这里把他指向自己的整个project
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f74cb6cb76df2062561da11fc62fe851/" rel="bookmark">
			Ubuntu20.04安装Nvidia显卡驱动&#43;CUDA11.1&#43;cuDNN8.0.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu20.04安装Nvidia显卡驱动+CUDA11.1+CUDNN8.0.5 一、安装 Nvidia 显卡驱动1.安装依赖2.禁用nouveau通用驱动3.安装显卡驱动 二、安装 CUDA 11.11.安装一些依赖库2. cuda11.1下载和安装 三、配置 cuDNN 8.0.5 一、安装 Nvidia 显卡驱动 1.安装依赖 # Ctrl + Alt + T 启动终端，逐行操作 sudo apt-get update #更新软件列表 sudo apt-get install g++ sudo apt-get install gcc sudo apt-get install make 2.禁用nouveau通用驱动 (1).首先输入以下：
sudo gedit /etc/modprobe.d/blacklist.conf (2).在打开的blacklist.conf最后面添加如下两行后，保存文本并关闭：
blacklist nouveau options nouveau modeset=0 (3).更新配置：
sudo update-initramfs –u (4).输入以下指令，如没有任何输出则屏蔽成功：
lsmod | grep nouveau 屏蔽完成
3.安装显卡驱动 注意：无须另外下载lightdm，用自带的gdm3即可
(1).进入全屏黑色的非图形界面（按Ctrl + Alt + F1～F6其中一个 分别对应进入tty1~tty6）
(2).输入用户名和密码后进行指令操作。
(3).关闭图形界面：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f74cb6cb76df2062561da11fc62fe851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22a20be766b95db9c1e8bfc12e14fded/" rel="bookmark">
			数据挖掘零基础入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据挖掘基础day01 1.jupyter notebook的使用两种模式下的通用快捷键命令模式编辑模式 2. Matplotlib2.1实现一个简单的画图2.2Matplotlib三层结构2.3折线图绘制2.3.1Matplotlib.pyplot模块2.3.2设置画布属性与图片保存2.3.2.1图片保存 2.3.3修改x，y刻度Matplotlib不显示中文解决办法Matplotlib不显示负号解决办法 2.3.4添加网格显示2.3.5添加描述信息2.3.6多个图像绘制2.3.7多个坐标系显示图像2.3.8折线图应用场景 2.4散点图2.5柱状图2.5.1如何实现首日数据和首周数据的显示 2.6直方图注意点 2.7饼图 3numpyndarray属性形状方法生成数组的方法生成0和1的数组从现有数组中生成生成固定范围的数组生成随机数组 ndarray运算逻辑运算统计运算数组间运算矩阵运算 数组的合并数组的分割IO操作与数据处理 Pandas核心数据结构DataFrameDataFrame属性方法DataFrame索引的设置MultiIndex与Panelseries属性 基本数据操作DataFrame运算Pandas画图文件的读取与存储CSVHDF5JSON Pandas高级処理缺失值处理数据离散化合并交叉表和透视表分组与聚合 1.jupyter notebook的使用 两种模式下的通用快捷键 Shift+Enter ，执行本单元代码，并自动跳转到下一个cell
Ctrl+Enter，执行本单元代码，并留在本cell中
cell行号前面的*号，代表本cell正在运行
命令模式 按Esc进入命令模式
Y,切换到代码模式
M,切换到Markdown模式
A,在本cell前添加一个单元格
B,在本cell后添加一个单元格
双击D,删除本单元格
Z,回退
编辑模式 按Enter进入编辑模式
多光标操作：ctrl键点击鼠标
回退：ctrl+z
补全代码：Tab
注释：ctrl+/
屏蔽输出结果：在输出结果前双击
2. Matplotlib 专门用于2D画图
能将数据进行可视化，帮助理解数据。
2.1实现一个简单的画图 import matplotlib.pyplot as plt %matplotlib inline plt.figure() plt.plot([1, 0, 9], [4, 5, 6]) plt.show() 2.2Matplotlib三层结构 1）容器层
画板层Canvas
画布层Figure
绘图区/坐标系 x、y轴区域
2）辅助显示层 辅助信息显示，如网格线等
3）图像层 画不同类型的图，如柱状图，折线图等
2.3折线图绘制 2.3.1Matplotlib.pyplot模块 #画图三步走 # 创建画布 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22a20be766b95db9c1e8bfc12e14fded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a26ab1a022de3875d9fa8855f167b1b1/" rel="bookmark">
			Pytorch基础入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pytorch介绍 Torch是一个开源的机器学习的框架，早在2002年就发布了Torch的初版， Torch的编程语言为C和Lua。如今的Torch7依旧是热门的深度学习框架之一。
PyTorch是在2017年1月由Facebook推出的。它是经典机器学习库Torch框架的一个端口，主要编程语言为python.
Torch： 2002年发布，早期的机器学习框架。
Theano： 2008年开发，第一个影响力较大的python深度学习框架。
CNTK：2016年1月由微软公司开源，在语音领域效果比较突出。
TensorFlow：2015年11月Google开源，目前最热门深度学习框架之一。
Keras： 以Theano/Tensorflow/CNTK作为底层，最容易使用的深度学习框架。
Caffe/Caffe2:2013年开源的C++深度学习框架，曾经计算机视觉领域的王者。
MXNet： 2015年发布，AWS云计算的官方深度学习平台。
Paddle： 2016年8月开源的百度深度学习框架。
PyTorch： 2017年开源，Torch的python版本，目前最有潜力，最热门的深度学 习框架之一。
Pytorch安装 https://pytorch.org/打开Pytorch官网进行下载，
根据自己电脑选择相应的选项，最后把下方的指令输入CMD中执行即可。
MNIST数据集介绍 数据集被分成两部分： 60000行的训练数据集（ mnist.train）和10000行的测试数据集（ mnist.test）
一张图片包含28* 28个像素，我们把这一个数组展开成一个向量，长度是28* 28=784。如果把数据用矩阵表示，可以把MNIST训练数据变成一个形状为 [60000, 784] 的矩阵，第一个维度数字用来索引图片，第二个维度数字用来索引每张图片中的像素点。图片里的某个像素的强度值介于0-1之间。
One-hot编码 MNIST数据集的标签是介于0-9的数字，我们要把标签转化为“one-hotvectors” 。一个one-hot向量除了某一位数字是1以外，其余维度数字都是0，比如标签0将表示为([1,0,0,0,0,0,0,0,0,0])，标签3将表示为
([0,0,0,1,0,0,0,0,0,0])
Softmax函数介绍 在多分类问题中，我们通常会使用softmax函数作为网络输出层的激活函数，softmax函数可以对输出值进行归一化操作，把所有输出值都转化为概率，所有概率值加起来等于1， softmax的公式为：
损失函数 均方误差（二次代价函数） 激活函数的梯度f’(z)越大， w的大小调整得越快，训练收敛得就越快。激活函数的梯度f’(z)越小， w的大小调整得越慢，训练收敛得就越慢。
按理来说，如果损失函数越大，应该进行的求导越快，而二次代价函数做不到，引出交叉熵函数。
交叉熵 过拟合 防止过拟合 增大数据集 增大数据集方法：
Early stopping 在训练模型的时候，我们往往会设置一个比较大的迭代次数。 Earlystopping便是一种提前结束训练的策略用来防止过拟合。
一般的做法是记录到目前为止最好的validation accuracy，当连续10个Epoch没有达到最佳accuracy时，则可以认为accuracy不再提高了。此时便可以停止迭代了（ Early Stopping）。
Dropout 在训练数据集的时候，随机的屏蔽掉一些神经元，以提高数据的鲁棒性
正则化项 优化器 Adadelta
Adagrad
Adam 一般使用Adam
Adamax
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a26ab1a022de3875d9fa8855f167b1b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a89ff17422d5db189e1c8fef2ff0f95/" rel="bookmark">
			知识蒸馏小总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义 知识蒸馏是一种模型压缩方法，是一种基于“教师-学生网络思想”的训练方法，由于其简单，有效，在工业界被广泛应用。
更简单的理解：用一个已经训练好的模型去“教”另一个模型去学习，这两个模型通常称为老师-学生模型。
用一个小例子来加深理解：
相关知识 pytorch中的损失函数：
Softmax：将一个数值序列映射到概率空间 # Softmax import torch import torch.nn.functional as F # torch.nn是pytorch中自带的一个函数库，里面包含了神经网络中使用的一些常用函数， # 如具有可学习参数的nn.Conv2d(),nn.Linear()和不具有可学习的参数(如ReLU，pool，DropOut等)(后面这几个是在nn.functional中) # 在图片分类问题中，输入m张图片，输出一个m*N的Tensor，其中N是分类类别总数。 # 比如输入2张图片，分三类，最后的输出是一个2*3的Tensor，举个例子： # torch.randn:用来生成随机数字的tensor，这些随机数字满足标准正态分布（0~1） output = torch.randn(2, 3) print(output) # tensor([[-1.1639, 0.2698, 1.5513], # [-1.0839, 0.3102, -0.8798]]) # 第1,2行分别是第1,2张图片的结果，假设第123列分别是猫、狗和猪的分类得分。 # 可以看出模型认为第一张为猪，第二张为狗。 然后对每一行使用Softmax，这样可以得到每张图片的概率分布。 print(F.softmax(output,dim=1)) # tensor([[0.1167, 0.1955, 0.6878], # [0.8077, 0.0990, 0.0933]]) log_Softmax：在Softmax的基础上进行取对数运算 # log_softmax print(F.log_softmax(output,dim=1)) print(torch.log(F.softmax(output,dim=1))) tensor([[-1.8601, -0.7688, -0.9655], [-0.9205, -1.1949, -1.2075]]) tensor([[-1.8601, -0.7688, -0.9655], [-0.9205, -1.1949, -1.2075]]) # 结果是一致的 NLLLoss：对log_softmax和one-hot编码进行运算 # NLLLoss print(F.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a89ff17422d5db189e1c8fef2ff0f95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efbcec80b49fb0bf6ebf833111e8474a/" rel="bookmark">
			使用MobaXterm远程连接Linux服务器（Ubuntu）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、先在linux中下载ssh
1.进入liunx系统之后打开终端
输入命令
sudo apt install openssh-server 2.下载好之后再输入命令
sudo apt install openssh-client 3.下载好之后修改两个文件的配置
打开第一个文件
输入命令
sudo vi /etc/ssh/ssh_config 打开之后将PasswordAuthentication yes前面的#去掉
vi+文件名就是进入了编辑模式，用键盘方向键移动光标到需要修改的位置，按i进入编辑模式，删除光标位置的字符按Delete，删除好之后按Shift+：wq之后就是保存并且退出。
打开第二个文件
输入命令
sudo vi /etc/ssh/sshd_config 增加一行PermitRootLogin yes之后保存退出
3、重启ssh服务
sudo /etc/init.d/ssh restart 4.查看ip，输入命令
ip address 即可看到该虚拟机的ip地址，记下该ip地址，后续用MobaXterm连接的时候就是用该ip地址
二、MobaXterm连接服务
1.打开MobaXterm页面，点击Session
2.点击SSH服务
3.输入刚刚查看到的ip地址以及自己linux系统的用户名
4.连接成功之后输入linux系统的密码
5.此时弹出一个是否连接的窗口，点击yes即可
6.接下来就可以在此处对虚拟机进行所需要的操作了，即远程连接成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d7ef5f1b8e253e1254013be807fa7af/" rel="bookmark">
			yolov7训练自己的数据集及报错处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		######################1########################## D:\Anaconda3\envs\py38torch_gpu\python.exe D:\needed\yolov7-main\train.py --weights weights/yolov7.pt --cfg cfg/training/yolov7.yaml --data data/datasets.yaml --device 0 --batch-size 8 --epoch 5 YOLOR 2022-9-16 torch 1.9.0+cu111 CUDA:0 (NVIDIA GeForce RTX 3060 Ti, 8191.5MB)
Namespace(adam=False, artifact_alias='latest', batch_size=8, bbox_interval=-1, bucket='', cache_images=False, cfg='cfg/training/yolov7.yaml', data='data/datasets.yaml', device='0', entity=None, epochs=5, evolve=False, exist_ok=False, freeze=[0], global_rank=-1, hyp='data/hyp.scratch.p5.yaml', image_weights=False, img_size=[640, 640], label_smoothing=0.0, linear_lr=False, local_rank=-1, multi_scale=False, name='exp', noautoanchor=False, nosave=False, notest=False, project='runs/train', quad=False, rect=False, resume=False, save_dir='runs\\train\\exp5', save_period=-1, single_cls=False, sync_bn=False, total_batch_size=8, upload_dataset=False, v5_metric=False, weights='weights/yolov7.pt', workers=0, world_size=1)
tensorboard: Start with 'tensorboard --logdir runs/train', view at http://localhost:6006/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d7ef5f1b8e253e1254013be807fa7af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d01008246a8588c955e67f55b7100cf/" rel="bookmark">
			Android中ConstraintLayout布局的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		约束布局（ConstraintLayout）是目前谷歌推荐的一种布局，它的功能强大。相对于LinearLayout和RelationLayout相比，它的用法更加灵活，同时代码量更小。下面介绍一下约束布局的简单用法。
例子1：最简单用法 app:layout_constraintStart_toStartOf="id"//该模块的左边和id模块的左边对齐 app:layout_constraintEnd_toStartOf="id"//该模块的右边和id模块的左边对齐 app:layout_constraintStart_toEndOf="id"//该模块的左边和id模块的右边对齐 app:layout_constraintEnd_toEndOf="id"//该模块的右边和id模块的右边对齐 app:layout_constraintTop_toTopOf="id"//该模块的上边和id模块的上边对齐 app:layout_constraintTop_toBottomOf="id"//该模块的上边和id模块的底边对齐 app:layout_constraintBottom_toTopOf="id"//该模块的底边和id模块的上边对齐 app:layout_constraintBottom_toBottomOf="id"//该模块的底边和id模块的底边对齐 前四条是横向的约束条件，后四条是纵向的约束条件，一个模块必须同时要有横向和纵向的约束条件。
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:textSize="20dp" app:layout_constraintStart_toStartOf="parent" //模块的左边和父布局的左边对齐 app:layout_constraintTop_toTopOf="parent" /&gt; //模块的顶端和父布局的顶端对齐 &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 例子2：两模块相对布局 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;TextView android:id="@+id/Text1" //设置ID android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="I'm first" android:textSize="20dp" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;TextView android:id="@+id/Text2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="I'm second" android:textSize="20dp" app:layout_constraintStart_toEndOf="@id/Text1" //Text2模块的左边和Text1模块的右边对齐 app:layout_constraintTop_toBottomOf="@id/Text1" /&gt; //Text2模块的上边和Text1模块的底边对齐 &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 例子3：基线对齐 &lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d01008246a8588c955e67f55b7100cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da779d7bcb1e1471e2ac359342fe99fc/" rel="bookmark">
			zotero&#43;谷歌翻译不能用，一招教你解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想必最近大家都听说了谷歌翻译已经停用对中国大陆的服务, 但对于习惯于谷歌翻译看 文献的我们不免有些失望, 后台也有许多小伙伴咨询解决zotero+谷歌翻译的解决办法, 有道 是：方法总比办法多。下面图片即是解决后的谷歌翻译示意图。
详细教程请转下文：
zotero+谷歌翻译不能用，一招教你解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b96a58f69b9e4b8e188a161332c4ab/" rel="bookmark">
			计算机视觉数据增强系列1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1.ColorJitter2.图像的标准化3.多边形class4.垂直翻转5.水平翻转6.resize6.Pad7.结果展示 前言 突然想总结一下数据增强，这篇博客主要针对于场景文字检测的数据增强，主要是多边形。当然目标检测也是同理，毕竟同样都是点集。
1.ColorJitter 随机调整图像的亮度、对比度、饱和度和色调。这里笔者对torchvision的接口包装了一下：
class ColorJitter(object): def __int__(self, brightness=0, contrast=0, saturation=0, hue=0): ''' 随机增强brightness, contrast, saturation, hue :param brightness: :param contrast: :param saturation: :param hue: :return: ''' self.transform = transforms.ColorJitter(brightness, contrast, saturation, hue) def __call__(self, data: dict): ''' 随机增强brightness, contrast, saturation, hue :param img:rgb图像 :return:numpy.array ''' img = data.get('img', None) img = Image.fromarray(img) img = self.transform(img) img = np.asarray(img) data['img'] = img return data 2.图像的标准化 class Normalize: def __init__(self, mean, std=None): ''' 标准化 :param mean: list or np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47b96a58f69b9e4b8e188a161332c4ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c87c700bda00552f1bf16ec81d93f07/" rel="bookmark">
			Linux服务器初始化工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容基于AlmaLinux 8系统。 以下为一键运行脚本，此脚本在AlmaLinux8，9系统上测试通过，其它版本系统无法保证全部功能正常运行。推荐仅在全新的服务器操作系统上运行此脚本，如二次执行可能会出现未知错误！
# bash &lt;(curl -L https://github.com/AlexWalker97/Shell/raw/main/linux_init.sh) 一、修改主机名 通常在购买一台新的服务器时服务器Hostname会被云厂商定义为特定的名称，如果需要修改的话可以按照下面步骤进行：
1. 查看系统信息 你可以使用下面指令查看到主机的相关信息：
# hostnamectl 例如下面截图是我的服务器信息：
2. 修改主机名 接下来修改服务器主机名：
# hostnamectl set-hostname 主机名 修改成功并重连ssh后可以看到服务器名称变成了server007：
二、禁用ICMP协议 部分攻击者会使用ping工具来测试服务器是否"存在"，我们可以禁用ICMP协议（让我们的服务器不响应其它服务器的ping请求）来保护服务器安全。
在 /etc/sysctl.conf 文件中增加一行 net.ipv4.icmp_echo_ignore_all = 1 (= 号后面的值0表示允许，1表示禁止)，之后执行 sysctl -p 使新配置生效：
# echo "net.ipv4.icmp_echo_ignore_all = 1" &gt;&gt; /etc/sysctl.conf # sysctl -p 此时使用windows cmd工具ping服务器时会发现无法ping通：
三、关闭SELinux y1s1，SELinux是个好东西，它能为linux服务器带来很强的安全防护功能。但是这个系统总是会和各种软件之间出现莫名其妙的冲突，有些问题排查极为浪费时间。在此直接将SELinux一关了之，再见！
输入getenforce检测selinux是否打开：
# getenforce 如结果如下：
Enforcing或Permissive表示SELinux为已打开(后者表示临时关闭，但重启后还会打开)，若结果为Disabled则代表selinux系统未启用，无需关闭。
输入以下指令已永久关闭SELinux：
# setenforce 0 # sed -i "s/SELINUX=enforcing/SELINUX=disabled/g" /etc/selinux/config 四、修改ssh端口 22端口为服务器默认ssh端口，因此易受攻击。我们可以通过修改服务器默认ssh端口的方式来规避风险。
1. 准备端口 首先确认我们需要开放的ssh端口（此处以端口1234为例）未被占用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c87c700bda00552f1bf16ec81d93f07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c01bfb8162b588f0884f26cc2c37d75f/" rel="bookmark">
			大数据工程师、数据挖掘师和数据分析师有啥区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网技术的不断提升，数据已经成为各大企业新的战场，而对于从业者来说，如果你对数据科学领域的工作感兴趣的话，肯定首先要了解一下数据科学领域都有哪些岗位。从岗位性质和主要工作内容不同我们可以把数据科学的岗位大概分为四类：数据产品经理、大数据工程师、数据挖掘师、数据分析师。数据产品经理显而易见就是精通并擅长数据产品设计的PM。这里我们具体了解一下大数据工程师、数据挖掘师和数据分析师有什么区别。
首先这三个技术方向都是与数据打交道，但是根据他们的主要工作内容、入门门槛、职业前景等方面进行对比，三个岗位有非常大的差异化。
工作内容区别：
大数据工程师：大数据工程师是利用大户数技术处理大量数据的专业技术人员。其工作重点在于通过开发技术实现数据仓库管理、数据的实时计算等，可以定位为数据仓库的管理员。
数据挖掘师：主要指从大量的数据中通过算法搜索隐藏域其中知识的工程技术人员。其工作重点在与通过将算法运用到开发技术中，从而挖掘数据中的价值，其核心在于算法的运营，具体岗位有算法工程师、机器学习工程师等。
数据分析师：专门从事行业数据搜集、整理、分析，并依据数据做出行业研究、评估和预测的专业人员。数据分析师更注重业务层的分析能力，而不需要过多的掌握数据仓储以及获取，有人认为数据分析师相对来说层次较低，可能是没有看到在大数据领域的数据分析师的强悍吧。
入门门槛区别
大数据工程师：大数据工程师可以说是没有学历的入门门槛，主要是应用层面的开发能力，只要能掌握大数据开发技术，并且能够顺利并且出色的完成相关的开发任务就可以达到企业用人标准。但是大数据技术学习的过程还是会形成一个分水岭，因为大数据开发技术内容相对较多，甚至如果从Java基础开始学习，所需要学习的内容体系非常庞大，完全掌握大数据开发技术也并非易事。
数据挖掘师：数据挖掘工程师在算法层面对从业人员是一个天然的屏障。应该说是在数据科学领域中数据挖掘是入门要求最高的。一般要求从业者具备数据、算法等核心技能，而这些知识的学习一般都在要求在理工科专业本科及以上层次的人才才能接触到的。
数据分析师：初级的数据分析师（一般指中小企业少量数据的分析）基本是没有入门门槛的，只要掌握了相应的工具应用即可从事该工作，而在大数据分析领域，同样需要大量的统计学以及算法知识做为支撑，但是相对另外两个岗位而言，在开发技术方向的要求并不高。因此相对来说更好入门一些。
职业前景
大数据工程师：大数据开发工程师以技术为核心，其职业发展方向包括高级开发、大数据开发架构，或者通过系统学习成为大数据分析师。然而有算法作为天然屏障，大数据工程师很难成为数据挖掘工程师，甚至数据科学家。
数据挖掘师：数据挖掘工程师是最接近数据科学家的数据岗位方向，在职业发展前景方面，主要还是围绕算法进一步发展成为算法研究员、高级算法工程师、数据科学家等。
数据分析师：数据分析师作为业务层面的高级人才，其职业发展路线同样与业务直接相关，如业务专家、企业管理、策略专家、高级分析师等等。
想学习数据科学的你是否对这三个方向了解了呢？目前最适合大家学习的领域就是大数据开发工程师方向，对你自身的学历和知识储备没有太苛刻的要求，只要你肯下功夫学习，还是可以进入大数据开发工程师岗位的大门，而如果你具备较高层次的数学和算法基础，可以考虑数据挖掘工程师和数据分析师岗位。当然这里有必要提一下，对于初级数据分析师岗位未来可能会成为每个岗位的基本技能要求，单纯的学习初级数据分析师的技能可能在未来的职业发展中会遇到瓶颈。
任何学习过程都需要一个科学合理的学习路线，才能够有条不紊的完成我们的学习目标。Python+大数据所需学习的内容纷繁复杂，难度较大，为大家整理了一个全面的Python+大数据学习路线图，帮大家理清思路，攻破难关！
Python+大数据学习路线图详细介绍
第一阶段 大数据开发入门 学前导读：从传统关系型数据库入手，掌握数据迁移工具、BI数据可视化工具、SQL，对后续学习打下坚实基础。
1.大数据数据开发基础MySQL8.0从入门到精通
MySQL是整个IT基础课程，SQL贯穿整个IT人生，俗话说，SQL写的好，工作随便找。本课程从零到高阶全面讲解MySQL8.0，学习本课程之后可以具备基本开发所需的SQL水平。
2022最新MySQL知识精讲+mysql实战案例_零基础mysql数据库入门到高级全套教程
第二阶段 大数据核心基础 学前导读：学习Linux、Hadoop、Hive，掌握大数据基础技术。
2022版大数据Hadoop入门教程
Hadoop离线是大数据生态圈的核心与基石，是整个大数据开发的入门，是为后期的Spark、Flink打下坚实基础的课程。掌握课程三部分内容：Linux、Hadoop、Hive，就可以独立的基于数据仓库实现离线数据分析的可视化报表开发。
2022最新大数据Hadoop入门视频教程，最适合零基础自学的大数据Hadoop教程
第三阶段 千亿级数仓技术 学前导读：本阶段课程以真实项目为驱动，学习离线数仓技术。
数据离线数据仓库，企业级在线教育项目实战（Hive数仓项目完整流程）
本课程会、建立集团数据仓库，统一集团数据中心，把分散的业务数据集中存储和处理 ；目从需求调研、设计、版本控制、研发、测试到落地上线，涵盖了项目的完整工序 ；掘分析海量用户行为数据，定制多维数据集合，形成数据集市，供各个场景主题使用。
大数据项目实战教程_大数据企业级离线数据仓库，在线教育项目实战（Hive数仓项目完整流程）
第四阶段 PB内存计算 学前导读：Spark官方已经在自己首页中将Python作为第一语言，在3.2版本的更新中，高亮提示内置捆绑Pandas；课程完全顺应技术社区和招聘岗位需求的趋势，全网首家加入Python on Spark的内容。
1.python入门到精通（19天全）
python基础学习课程，从搭建环境。判断语句，再到基础的数据类型，之后对函数进行学习掌握，熟悉文件操作，初步构建面向对象的编程思想，最后以一个案例带领同学进入python的编程殿堂。
全套Python教程_Python基础入门视频教程，零基础小白自学Python必备教程
2.python编程进阶从零到搭建网站
学完本课程会掌握Python高级语法、多任务编程以及网络编程。
Python高级语法进阶教程_python多任务及网络编程，从零搭建网站全套教程
3.spark3.2从基础到精通
Spark是大数据体系的明星产品，是一款高性能的分布式内存迭代计算框架，可以处理海量规模的数据。本课程基于Python语言学习Spark3.2开发，课程的讲解注重理论联系实际，高效快捷，深入浅出，让初学者也能快速掌握。让有经验的工程师也能有所收获。
Spark全套视频教程，大数据spark3.2从基础到精通，全网首套基于Python语言的spark教程
4.大数据Hive+Spark离线数仓工业项目实战
通过大数据技术架构，解决工业物联网制造行业的数据存储和分析、可视化、个性化推荐问题。一站制造项目主要基于Hive数仓分层来存储各个业务指标数据，基于sparkSQL做数据分析。核心业务涉及运营商、呼叫中心、工单、油站、仓储物料。
全网首次披露大数据Spark离线数仓工业项目实战，Hive+Spark构建企业级大数据平台
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7575695c286f058a1b0bb9efc2eeb3d1/" rel="bookmark">
			Java中涉及常见面试整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中涉及常见面试整理 1．JDK 与 JRE 区别？
JDK 是Java开发工具包，包含Java的运行时环境；
JRE是Java运行时环境（包含Java基础的使用类库以及Java虚拟机）
2．Java基本数据类型有哪些
Java 基本数据类型：
整形：byte short int long
浮点型：float double
字符型：char
布尔型：boolean
3．final在Java中的作用？
修饰类：表示 该类不能被继承，类中所有成员方法都被隐式指定为final方法；
修饰方法：不可被重写；
修饰变量：不可被改变，修饰引用变量表示引用不可变，引用的内容可变；
修饰常量：编译阶段被存入常量池中；
4．Java 中操作字符串都有那些类，区别？
操作字符串的类有：String StringBuilder StringBuffer
String：只读字符串，每次对String的操作都会产生一个新的对象；
StringBuilder： 可变的字符数组，线程不安全，效率相对高；
SringBuffer ： 可变的字符数组，线程安全。
5．接口与抽象类的区别？
（1）抽象类中可以定义构造器，接口不能；
（2）抽象类可以有抽象方法和具体方法，接口中不能有具体方法；
（3）抽象类中可以定义成员变量，接口中只能是常量；
（4）抽象类中可以包含静态方法，接口不行；
6．TCP协议三次握手与四次挥手，能否是2次握手或者是4次？
三次握手：
第一次握手：客户端给服务端发送SYN(同步序号标志位)报文，申请建立客户端到服务端的连接；
第二次握手：服务端接收客户端的数据报文后，服务端返回 SYN+ACK(确认号是否有效) 给客户端以确认连接服务端到客户端的请求；
第三次握手：客户端接收到服务端返回的数据报，将状态置为established，并返回ACK 给服务端，服务端接收到这个ACK，就将状态置为established，建立了服务端到客户端的连接；
四次挥手：
第一次挥手：客户端发送FIN（结束报文段）到服务端，申请建立关闭客户端到服务端的连接；第二次挥手：服务端接收到FIN，将状态置为close_wait，并返回一个ACK应答给客户端（TCP协议默认执行）第三次挥手：服务端发送一个FIN到客户端，申请关闭服务端到客户端的连接，并执行关闭前的一些操作；第四次挥手：客户端返回ACK到服务端，并将状态置为close_wait，需要等待一段时间（防止丢包重传FIN），客户端在将状态置为closed，等服务端接收到这个数据报时，将状态置为closed关闭连接； 不可以是2次，不可靠；
可以是4次，但存在效率问题；
7．Java常见容器有哪些？
list：有序的集合，元素可以重复，可以进行索引访问以及动态扩容；
map：使用键值对存储元素，元素不允许重复，无序；
set：元素不能重复，无序；
8．ArrayList 与LinkedList 区别？
ArrayList：底层采用数组来存储元素，因此物理上连续，支持随机访问，支持扩容，但在任意位置插入删除元素，需要进行元素的搬移，因此，时间复杂度为O(N)；
LinkedList：底层采用双向链表结构，因此逻辑上是连续的但物理上不一定连续；，不支持随机访问，并且没有扩容的概念；任意位置插入删除元素，只需要修改引用即可，因此时间复杂度为O(1)。
9．栈、虚拟机栈、栈帧、操作数栈区别？
栈：是一种后进先出的数据结构，在Java中对应的实现为Stack；
虚拟机栈：是一块具有特殊作用的内存空间，生命周期与线程相同，JVM为了方便管理，将内存分为栈区与堆区；栈区，线程是私有的，主要存放函数调用的一些信息，主要有栈帧，堆区：一般new出来的空间都在堆区；
栈帧：用于支持Java虚拟机进行方法调用和执行的数据结构，每个方法在执行时都会创建一个栈帧，用于保存局部变量表、操作数栈、动态链接以及方法出口等信息，当方法调用结束时，该方法对应的栈帧会从虚拟机栈中进行出栈；
操作数栈：也被称作操作栈，是一个后进先出的栈，同局部变量表一样，在编译期间，操作数栈的最大最大深度就被确定下来了。
10．HashMap 为什么要重写 HashCode 与 equals 方法？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7575695c286f058a1b0bb9efc2eeb3d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db00d4c2b43e89dd706f19bd6eadc79a/" rel="bookmark">
			Python报错UnicodeDecodeError: ‘gbk‘ codec can‘t decode byte
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python报错UnicodeDecodeError: ‘gbk‘ codec can‘t decode byte，这个错误是做NLP的小伙伴常见的一个错误，报错原因是读取的文件中有中文。
核心思路：
将 with open(file) as f: 改成with open(file, ‘r’, encoding=‘utf-8’) as f:
例如：
def load_data(filename): D = [] with open(filename,'r', encoding='utf-8') as f: for i, l in enumerate(f): l = json.loads(l) text, label = l['sentence'], l['label'] D.append((text, labels.index(label))) return D 即将原始的
with open(filename) as f: 修改为
with open(filename,'r', encoding='utf-8') as f: 即可解决以上问题。
还有一种情况：不加encoding默认编码方式采用utf-8 ，因为cvs文件的表头带中文汉字，所以报错。汉字采用的编码方式是gb2312 ,一般都是表头带汉字引起的，更改为如下代码即可。
data = pd.read_csv(filename,encoding = 'gb2312') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e480533735f0f5315583de12701d031c/" rel="bookmark">
			pytorch-实现天气识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍨 本文为🔗365天深度学习训练营 中的学习记录博客🍦 参考文章：[365天深度学习训练营-第P3周：天气识别](365天深度学习训练营-第P3周：天气识别 · 语雀 (yuque.com))**🍖 原作者：K同学啊|接辅导、项目定制 我的环境
语言环境：Python3.6编译器：jupyter lab深度学习环境：pytorch1.10参考文章：本人博客(60条消息) 机器学习之——tensorflow+pytorch_重邮研究森的博客-CSDN博客 🍺要求：
本地读取并加载数据。（✔） 测试集accuracy到达93%（✔） 🍻拔高：
测试集accuracy到达95%（✔）调用模型识别一张本地图片（✔） 目录
一 前期工作
1.设置GPU或者cpu
2.导入数据
二 数据预处理
三 搭建网络
四 训练模型
1.设置学习率
2.模型训练
五 模型评估
1.Loss和Accuracy图
2.对结果进行预测
3.总结
一 前期工作 环境：python3.6，1080ti，pytorch1.10（实验室服务器的环境😂😂）
1.设置GPU或者cpu import torch import torch.nn as nn import matplotlib.pyplot as plt import torchvision device = torch.device("cuda" if torch.cuda.is_available() else "cpu") device 2.导入数据 import os,PIL,random,pathlib data_dir = 'weather_photos/' data_dir = pathlib.Path(data_dir) print(data_dir) data_paths = list(data_dir.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e480533735f0f5315583de12701d031c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76132dbe7bf43d922e053653650be0ef/" rel="bookmark">
			CentOS8配置本地yum源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CentOS8配置本地yum源 要切换到root用户下进行以下操作 一 创建我们准备要挂载目录 mkdir -p /media/cdrom 二 将光盘目录挂载到/media/cdrom目录下 mount /dev/cdrom /media/cdrom 用df -h命令查看挂载结果 三 配置开机自动挂起 vim /etc/fstab #在最后一行添加如下代码 /dev/cdrom /media/cdrom iso9660 defaults 0 0 四 配置本地yum源 cd /etc/yum.repos.d vim CentOS-Media.repo 以下红框为需要修改的地方（图片里为正确的修改） baseurl：指定挂载目录下的BaseOS和AppStream gpgcheck：是否校验 enable：是否启用该镜像 接下来依次打开CentOS-AppStream.repo、CentOS-Base.repo和CentOS-Extras.repo，分别修改enable=0 。 五 更新yum源 yum clean all yum makecache 验证有没有配成功 yum install httpd 出现如下结果，我们配置成功了。 注意我们只是测试一下有没有配置成功，所以图片中红框的地方我们选择N,也就是不安装httpd。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e29401c5f2a1a3dab7180694a4a50cfa/" rel="bookmark">
			基于Matlab的非线性规划问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Matlab的非线性规划问题 1、题目2、解析问题1：问题2： 3、代码求解问题1：问题2： 1、题目 题目：
某集团拟在某市东、西、南、北建立4座超市，有10个候选位置Aj(j=1, 2, 3, … ,10)，考虑到各地区的消费水平及居住密度，规定如下：
(1) 东区由A1, A2, A3三个点中之多选择两个。
(2) 西区由A4, A5两个点中至少选择一个。
(3) 南区由A6, A7两个点中至少选一个。
(4) 北区由A8, A9, A10三个点中至少选两个。
试题说明：
问题1：
A j A_{j} Aj​各点的设备投资及每年可获利润由于地点不同而不一样，预测情况见表1(单位：万元)，总投资额不能超过720万元，问应该选择哪几个位置建立超市，可使年利润最大？
表格1 A j A_{j} Aj​各点投资与利润情况
项目A1A2A3A4A5A6A7A8A9A10投资额10012015080109080140160180利润35405022203025485861 问题2：
现在需要建立一个仓库给四个超市供货，为简化问题，假设仓库到每个超市是单独供货，即送完某个超市即返程，不再接着送下一个超市 (即仅考虑路程，不考虑图论)，且从仓库到各超市的运费单价一致，问该仓库建立在何处才能使超市的运输成本最低？
表格 2 A j A_{j} Aj​各点的位置情况
项目A1A2A3A4A5A6A7A8A9A10x67-120721634910373-3029-79y89-115-107-81-29414333-75137-171 2、解析 问题1： 该集团拟定东南西北四个方向建立四座超市，从候选的10个位置中又根据各地区的消费水平和居住密度设定了一系列规则，在满足规则的同时使超市收益的年利率最大，由此我们构建了一个优化方程，最终通过matlab中的非线性规划fmincon函数求解，得出最终结果 A = ( A 4 , A 6 , A 9 , A 10 ) A = ({A_4},{A_6},{A_9},{A_{10}}) A=(A4​,A6​,A9​,A10​)。
根据规定：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e29401c5f2a1a3dab7180694a4a50cfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05a0b96839bc84f242ce1ae4bfa21b9d/" rel="bookmark">
			MySQL建立图书管理系统后续 mysql查询实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验内容
1. SELECT语句对表进行查询操作，是最基本的查询语句。
语法格式如下：
Select &lt;目标列组&gt; From &lt;数据源&gt; [Where &lt;元组选择条件&gt;] [Group by &lt;分组列&gt; [Having &lt;组选择条件&gt;]]
[Order by &lt;排序列1&gt; &lt;排序要求&gt; [, …n]]
2．用SELECT语句对表进行连接查询操作，连接查询涉及被连接和连接两个表，所以数据源一般为多个表。用来连接两个表的条件称为连接条件，一般格式为：
[&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;.]&lt;列名2&gt;
其中比较运算符主要有：=、&gt;、&lt;、&gt;=、&lt;=、!=。
3．用SELECT语句对表进行嵌套查询操作，一个Select…From…Where语句称为一个查询块，将一个查询块嵌套在另一个查询块的Where子句或Having短语的条件中的查询，就是嵌套查询。主要有使用In操作符、使用比较运算符的嵌套查询方式。
4．用SELECT语句对表进行组合查询操作，将SELECT语句的查询结果集，再进行集合运算就构成了SQL的组合查询。组合查询操作符有Union(并操作)、Intersect(交操作)和Minus(差操作)。
5. SQL函数是综合信息的统计函数，包括计数，求最大值、最小值、平均值、和值等。基本的SQL函数如下：
AVG(数值表达式) 功能：求与字段相关的数值表达式的平均值
SUM(数值表达式) 功能：求与字段相关的数值表达式的和值
MIN(字段表达式) 功能：求字段表达式的最小值
MAX(字段表达式) 功能：求字段表达式的最大值
COUNT(*|字段表达式) 功能：求记录行数(*)，或求不是NULL的字段的行数
6. 在SQL查询语句中，如果有GROUP BY分组子句，则语句中的函数为分组统计函数；如果没有GROUP BY分组子句，则语句中的函数为全部结果集的统计函数。语法为
Select [统计函数]&lt;目标列组&gt; From &lt;数据源&gt; [Where &lt;元组选择条件&gt;] [Group by &lt;分组列&gt; [Having &lt;组选择条件&gt;]]
7，having语法
#1．列出自动化类图书的书号，名称，价格。 #提示：列起别名，如 书名 名称 或者 书名 as 名称 SELECT 书号,书名 AS 名称,定价 AS 价格 FROM 图书; /*2．查询计算机类与电子工业出版社出版的图书 提示：结果应该既包含计算机类的图书又包含电子工业出版社的图书，用UNION 或者OR。*/ SELECT 书名 FROM 图书借阅.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05a0b96839bc84f242ce1ae4bfa21b9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6f665be15c382a6643d34a6ee91a07a/" rel="bookmark">
			Centos 7 虚拟机安装 harbor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 说明
2. 安装
1. 安装docker
2. 安装docker-compose 3. 安装Harbor
1. 说明 在 CentOS 7 环境下安装 docekr 及 harbor
2. 安装 1. 安装docker # 安装yum工具集 yum install -y yum-utils # 安装docker源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # 更新yum缓存 yum makecache fast # 安装docker yum install -y docker-ce # 启动docker systemctl start docker # 设置docker开机自启动 systemctl enable docker # 验证 docker version docker run hello-world 👉 注1：运行“sudo docker run hello-world”时报错：docker: Error response from daemon。解决方法：docker默认的源为国外官方源，下载速度较慢，可修改docker镜像源为国内:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6f665be15c382a6643d34a6ee91a07a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eca3dcc78eb5ea859b8a3a22f3c3f5d/" rel="bookmark">
			基于Matlab的自动控制系统频率法串联校正仿真分析（含仿真代码和结果图像）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文利用Matlab进行了基于频率法的串联超前、滞后和滞后—超前校正仿真研究，验证了校正后会使系统瞬态响应的速度变快，相对稳定性提高，并使得系统的稳态精度能满足设计的要求。
目录
一、线性系统的基本控制规律
1.1 比例控制规律
1.2 比例微分控制规律
1.3 比例积分控制规律
1.4 比例积分微分控制规律
二、校正装置及其特性
2.1 PD控制校正网络及超前校正网络
2.2 PI控制校正网络及滞后校正网络
2.3 PID控制校正网络及滞后-超前校正网络
三、频率法串联校正装置设计与仿真分析
3.1 串联超前校正装置设计与仿真分析
3.2 串联滞后校正装置设计与仿真分析
3.3 串联滞后—超前校正装置设计与仿真分析
四、总结
参考文献
一、线性系统的基本控制规律
1.1 比例控制规律
比例环节的传递函数为：
​​​​​对应的频率特性为：
幅频特性：
对数幅频特性：
相频特性：
​对数相频特性:
​​​
比例控制器实际上是一个具有可调增益的放大器，只改变信号的增益而不影响其相位。可提高开环放大系数，能减小稳态误差。
1.2 比例微分控制规律
比例微分环节的传递函数为： 对应的频率特性为：
幅频特性： 对数幅频特性：
相频特性： 对数相频特性: 比例微分控制器中的微分控制作用能反应输入信号的变化趋势，产生有效的早期修正信号，以增加系统的阻尼程度，降低系统超调，改善动态性能，并改善系统的稳定性。
微分控制作用只在暂态过程有效，信号无变化时将失效，因此纯微分环节不能单独使用。
1.3 比例积分控制规律
比例积分环节的传递函数为： 对应的频率特性为： 幅频特性： 对数幅频特性：
相频特性： 对数相频特性:
引入比例积分环节，相当于在系统中增加了一个位于原点的开环极点和一个位于S左半平面的开环零点。位于原点的极点可提高系统的型别，以消除或减小系统稳态误差，改善系统稳态性能；增加的负实数零点则用来减小系统的阻尼程度，减小比例积分控制器极点对系统稳定性及动态过程产生的不利影响。
在实际的控制工程中，比例积分控制器主要用来改善控制系统的稳态性能。
1.4 比例积分微分控制规律
比例积分微分环节的传递函数为： 对应的频率特性为：
幅频特性： 对数幅频特性：
相频特性： 对数相频特性: 分析图7中曲线可以得出，低频段通过积分控制作用，提高了系统型别，改善了系统的稳态性能。中频段通过微分控制作用，幅值穿越频率增大，系统的过渡过程时间缩短，系统的快速性提高，系统的相角裕量增大，系统稳定性提高，全面有效地提高了系统的动态性能。
当利用PID控制器进行串联校正时，除了可使系统的型别提高1级外，还将提供两个负实数零点。通常，应使PID中的积分部分发生在系统频率特性的低频段，以提高系统的稳态性能；而使微分部分发生在系统频率特性的中频段，以改善系统的动态性能。
二、校正装置及其特性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eca3dcc78eb5ea859b8a3a22f3c3f5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3242240f2a9c90c753439143b61b0079/" rel="bookmark">
			无卷积步长或池化:用于低分辨率图像和小物体的新 CNN 模块SPD-Conv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		No More Strided Convolutions or Pooling:A New CNN Building Block for Low-Resolution Images and Small Objects 原文地址：
https://arxiv.org/pdf/2208.03641v1.pdf pdf下载： (67条消息) 无卷积步长或池化:用于低分辨率图像和小物体的新CNN模块SPD-Conv-行业报告文档类资源-CSDN文库https://download.csdn.net/download/weixin_53660567/86737435
无卷积步长或池化:用于低分辨率图像和小物体的新 CNN 模块SPD-Conv 摘要
卷积神经网络(CNNs)在图像分类和目标检测等计算机视觉任务中取得了显著的成功。然而，当图像分辨率较低或物体较小时，它们的性能会迅速下降。在本文中，我们指出这根源为现有CNN常见的设计体系结构中一个有缺陷，即使用卷积步长和/或池化层，这导致了细粒度信息的丢失和较低效的特征表示的学习。为此，我们提出了一个名为SPD-Conv的新的CNN构建块来代替每个卷积步长和每个池化层(因此完全消除了它们)。SPD-Conv由一个空间到深度(SPD)层和一个无卷积步长(Conv)层组成，可以应用于大多数CNN体系结构(如果不是全部的话)。我们从两个最具代表性的计算机视觉任务:目标检测和图像分类来解释这个新设计。然后，我们将SPD-Conv应用于YOLOv5和ResNet，创建了新的CNN架构，并通过经验证明，我们的方法明显优于最先进的深度学习模型，特别是在处理低分辨率图像和小物体等更困难的任务时。我们在https://github.com/LabSAINT/SPD-Conv上开放了源代码。
1.介绍
自AlexNet[18]以来，卷积神经网络(CNNs)在许多计算机视觉任务中表现出色。例如在图像分类方面，CNN的知名模型有AlexNet、VGGNet[30]、ResNet[13]等;在目标检测中，包括R-CNN系列[9,28]，YOLO系列[26,4]，SSD [24]，EfficientDet [34]，等等。然而，所有这样的CNN模型在训练和推理中都需要“高质量”的输入(精细图像、中型到大型对象)。例如，AlexNet最初在227×227清晰图像上进行训练和推理，但在将图像分辨率降低到1/4和1/8后，其分类准确率分别下降了14%和30%，[16]。VGGNet和ResNet too[16]上也有类似的情况。在目标检测的情况下，SSD在1/4分辨率的图像或相当于1/4较小尺寸的目标上受到显著的mAP损失34.1，如文献[11]所描述的那样。事实上，小物体检测是一项非常具有挑战性的任务，因为小物体固有的分辨率较低，而且可供模型学习的背景信息也有限。此外，它们经常(不幸地)与同一图像中的大型目标共存，而大型目标往往会主导特征学习过程，从而使小型目标无法被检测到。
在本文中，我们认为这种性能下降的根源在于现有CNN的一个常见的设计缺陷。也就是说，使用卷积步长和/或池化，特别是在CNN体系结构的早期层中。这种设计的负面影响通常不会表现出来，因为大多数被研究的场景都是“和蔼可亲的”，图像有良好的分辨率，物体的大小也适中; 因此，存在大量的冗余像素信息，跨跃卷积和池化可以方便地跳过，模型仍然可以很好地学习特征。然而，在图像模糊或物体很小的更困难的任务中，冗余信息的大量假设不再成立，当前的设计开始遭受细粒度信息丢失和学习特征不足的影响。
为了解决这个问题，我们为CNN提出了一个新的构建模块，称为SPD-Conv，完全替代(从而消除)卷积步长和池化层。SPD- conv是一个空间到深度(SPD)层，后面跟着一个无步长卷积层。SPD层对特征映射X进行下采样，但保留了通道维度中的所有信息，因此没有信息丢失。我们受到了图像转换技术[29]的启发，该技术在将原始图像输入神经网络之前将其缩放，但我们基本上将其推广到整个网络内部和整个网络中的下采样特征映射;此外，我们在每个SPD之后添加了一个无步长卷积操作，以在增加的卷积层中使用可学习参数减少(增加的)通道数量。我们提出的方法既通用又统一，因为SPD-Conv (i)可以应用于大多数(如果不是所有)CNN架构，并且(ii)以相同的方式替代卷积步长和池化。综上所述，本文的贡献如下:
我们在现有的CNN体系结构中发现了一个常见的设计缺陷，并提出了一个名为SPD-Conv的新构建块来代替旧的设计。SPD-Conv下采样不丢失可学习信息，完全摒弃了目前广泛使用的步长卷积和池化操作。SPD-Conv代表了一种通用和统一的方法，可以很容易地应用于大多数(如果不是所有)基于深度学习的计算机视觉任务。利用目标检测和图像分类这两个最具代表性的计算机视觉任务，对SPD-Conv的性能进行了评价。具体而言，我们构建了YOLOv5-SPD、ResNet18-SPD和ResNet50-SPD，并在COCO-2017、Tiny ImageNet和CIFAR-10数据集上对它们进行了评估，并与几种最先进的深度学习模型进行了比较。结果表明，该算法在AP方面有显著提高，并获得了top-1精度，特别是在小物体和低分辨率图像上。如图1所示。SPD-Conv可以很容易地集成到流行的深度学习库中，如PyTorch和TensorFlow，有可能产生更大的影响。我们的源代码可在https://github.com/LabSAINT/SPD-Conv获得。 图1:比较AP中的小目标(APS)。“SPD”表示我们的方法。
本文的其余部分组织如下。第2节介绍了背景并回顾了相关工作。第3节描述了我们提出的方法，第4节介绍了两个使用目标检测和图像分类的案例研究。第5节提供了性能评估。本文的结论在第6部分。
2 前期工作及相关工作
我们首先提供这个领域的概述，更多地关注目标检测，因为它包含了图像分类。
目前最先进的目标检测模型是基于CNN的，可以分为一级和二级检测器，或基于锚框的或无锚框检测器。两阶段检测器首先生成粗区域提取，然后使用一个head(全连接网络)对每个提取进行分类和细化。相比之下，一级检测器跳过区域提取步骤，直接在密集的位置采样上运行检测。基于锚框的方法使用锚框盒，锚框盒是一个预定义的盒子集合，匹配训练数据中对象的宽度和高度，以提高训练过程中的损失收敛性。我们提供了表1，它对一些众所周知的模型进行了分类。
一般而言，一级检测器比二级检测器速度快，基于锚框的模型比无锚框的模型更精确。因此，在后面的案例研究和实验中，我们更多地关注单级和基于锚框的模型，即表1中的第一个行。一个典型的单阶段目标检测模型如图2所示。它由一个基于CNN的视觉特征提取backbone和一个预测每个包含对象的类别和边界框的检测头组成。在这两者之间，添加一个额外的NECK来组合多个尺度的特征，以产生语义上强的特征，用于检测不同大小的目标。
表1:OD模型的分类
图2:一级目标检测通道
2.1小目标检测
传统上，检测小物体和大物体都被视为一个多尺度的物体检测问题。一种经典的方法是图像金字塔[3]，它将输入图像调整为多个尺度，并为每个尺度训练专用检测器。为了提高精度，提出了SNIP[31]，它根据每个探测器中不同的物体大小进行选择性反向传播。SNIPER[32]提高了SNIP的效率，它只处理每个目标实例周围的背景区域，而不是图像金字塔中的每个像素，从而减少了训练时间。采用另一种提高效率的方法，特征金字塔网络FPN[20]在卷积层中利用横向连接将固有的多尺度特征联系在一起，并使用自顶向下的结构将这些特征结合起来。随后引入PANet[22]和BiFPN[34]，利用较短的路径改善FPN的特征信息流。此外，引入SAN[15]将多尺度特征映射到尺度不变换子空间，使检测器对尺度变化具有更强的鲁棒性。所有这些模型都一致使用卷积步长和最大池化，我们完全摆脱了这一点。
2.2低分辨率图像分类
解决这一挑战的早期尝试之一是[6]，它提出了一个端到端CNN模型，在分类之前添加一个超分辨率步骤。随后，[25]提出将从高分辨率训练图像中获得的细粒度知识转移到低分辨率测试图像中。然而，这种方法需要对应于特定应用程序(例如，类)的高分辨率训练图像，而这些图像并不总是可用的。
其他一些研究，如[37]，也需要对高分辨率训练图像的同样要求。最近，[33]提出了一个包含属性级可分离性(属性表示细粒度、分层的类标签)的损失函数，以便模型能够学习特定于类的鉴别特征。然而，细粒度(分层)类标签很难获得，因此限制了该方法的采用。
3.一个新的构建模块:SPD-Conv
SPD- conv由一个空间到深度(SPD)层和一个非跨步卷积层组成。本节将对此进行详细描述。
我们的SPD组件推广了一种(原始)图像转换技术[29]来对CNN内部和整个CNN的特征映射进行下采样，如下所示。
考虑任意大小为S × S × C1的中间特征映射X，将子特征映射序列切片为：
一般来说，给定任何(原始)特征映射X，子映射fx,y由所有特征映射组成特征图X(i, j) ,i + x和j + y可以被比例整除。因此，每个子图按一个比例因子向下采样X。图3(a)(b)(c)给出了一个例子，当scale = 2时，我们得到四个子映射f0,0,f1,0,f0,1,f1,1，它们的形状为(S/2,S/2,C1)并对X进行2倍的下采样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3242240f2a9c90c753439143b61b0079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/625c87973600d5defad67b80bd26e02c/" rel="bookmark">
			Python入门 - 数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python入门 数据类型1、可变数据（list、dict、set）1.1 list1.2 set1.3 dict 2、不可变数据（number、string、tuple）2.1 number2.2 string2.3 tuple 3、序列3.1 有序序列3.2 无序序列 数据类型 1、可变数据（list、dict、set） 允许变量的值发生变化，如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化。不过对于相同的值的不同对象，在内存中则会存在不同的对象，即每个对象都有自己的地址，相当于内存中对于相同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。
1.1 list 列表（list）有序和可更改的集合，允许重复的成员。在Python中，元组是用中括号编写的。
list_test = ["apple", "banana", "cherry"] print(list_test) ['apple', 'banana', 'cherry'] # list_test（列表）的类型 type(list_test) &lt;class 'list'&gt; # list_test（列表）可使用的方法【“append” ~ “sort”】 dir(list_test) ['__add__', '__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/625c87973600d5defad67b80bd26e02c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a410bf5b99196edd51a0cfe5c3ebc99/" rel="bookmark">
			有公网IP内网穿透配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于GRE协议的隧道穿透实验 概念介绍 名称：VPN专线，虚拟专用网
定义：虚拟专用网(VPN)被定义为通过一个公用网络（通常是因特网）建立一个临时的、安全的连接，是一条穿过混乱的公用网络的安全、稳定的隧道。虚拟专用网是对企业内部网的扩展。
用途：1.一个内部网络访问另一个内部网络；
​ 2.保持稳定的可持续的用户链接会话；
优点：安全、稳定、可扩展、灵活、易管理
缺点：缺乏第三方责任、用户无法访问VPN以外的网络、易于被拒绝
网络实验 实验环境： ​ Cicso Packet Tracer 8.0.0.0212
实验目的： ​ 搭建基于GRE协议的VPN，实现不同子网的主机间的通信
网络拓扑设计： 实验步骤： 1.设置客户端内网：
路由器R1网关192.168.10.254/24 公网IP12.1.1.1/24，PC0：192.168.10.1,PC0：192.168.10.2;
路由器R1:
（1）内网口为Interface 0/0/0：
（2）公网口为Interface 0/0/1:
(3) 设置默认路由为公网IP：（实现公网IP间互通）
​ 输入命令enable进入路由configure terminal执行命令ip route 0.0.0.0 0.0.0.0 12.1.1.2 添加静态路由
设置PC网络：
（1）设置网关：
（2）设置网口IP：
2.设置服务端内网：
路由器R3:
（1）公网口为Interface 0/0/0：
（2）内网口为Interface 0/0/1：
（3）设置默认路由为公网IP：（实现公网IP间互通）
​ 输入命令enable进入路由configure terminal执行命令ip route 0.0.0.0 0.0.0.0 23.1.1.2 添加静态路由
3.设置外网分配的路由IP：（一般是运营商给的固定IP，现在一般都是通过了动态Nat转发，所以没有固定IP，如果需要可以咨询运营商）
注：只是模拟公网分配IP；
（1）公网IP1：
（2）同样可以利用第二个网口设置公网IP2；
4.PC0 发送ICMP报文到Server0：（不通）
5.设置VPN：（对R1，R3配置隧道）
配置R1:
（1）R1&gt;enable
（2）R1#configure terminal
（3）R1(config)#interface tunnel 0 // 创建编号为 0 的 IP 隧道接口并进入配置模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a410bf5b99196edd51a0cfe5c3ebc99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/696083229909cd7b707b2b7ae7c62328/" rel="bookmark">
			Java Fork/Join框架学习（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 序言：分治算法 ForkJoinTask使用了的分治算法的思想，因此在学习ForkJoinTask前，回顾下分治算法实际问题：国家开展人口普查，如何统计人口数？负责该事项的工作人员，肯定不会傻傻地带上电脑，一个人走遍全中国而是将该事项下发到省，省下发到市，市下发到县，县下发到镇，镇下发到乡（divide，分）假设乡足够小，工作人员能够轻松完成乡上人口的统计，这时候便可以不再下发任务，直接统计乡人口然后镇汇总乡、县汇总镇、市汇总县、省汇总市，中央汇总省，从而完成此次人口普查（combine，合）分治算法包含三大步： Divide：将问题划分为两个或两个以上与原始问题相似但规模较小的子问题。Conquer：如果子问题足够小，则直接求解；否则，递归求解子问题。Combine: 合并子问题的解决方案，以构建原始问题的解 如何理解递归求解子问题？ 在笔者看来，divide：需要将问题分解为足够小的子问题，但是很难一次就完成。因此，需要递归地对子问题进行分解，直到能直接求解这样来看，divide和conquer是无法严格界定的，因为在conquer时，如果发现子问题不能直接求解，还需要递归地进行divide &amp; conquer 下面的代码很好地解释了分治算法的整个流程：divideAndConquer(big_problem){ if (canSolve(big_problem)){ //问题可以直接求解则直接求解返回 solve(big_problem); //求解 return; } else { small_problem_A = divide(big_problem); //不能直接求解的问题拆分 small_problem_B = divide(big_problem); //不能直接求解的问题拆分 divideAndConquer(small_problem_A); //递归求解子问题 divideAndConquer(small_problem_B); //递归求解子问题 return merge(); //合并子问题的解 } } 2. Fork/Join框架 2.1 Fork/Join框架概述 JDK 7开始，引入了Fork/Join框架
该框架采用了分治算法的思想，将大任务拆分为若干个独立的小任务，最后合并每个小任务的执行结果以得到大任务的执行结果
这样可以充分利用操作系统的多核特性，加速对小任务的并行处理，从而提高大任务的吞吐量
可以说，Java的Fork/Join框架，提供了一种充分利用所有可用的处理能力来加速并行处理的工具
伪代码解释如下：
// from 《A Java Fork/Join Framework》Dong Lea Result solve(Problem problem) { if (problem is small) directly solve problem else { split problem into independent parts fork new subtasks to solve each part join all subtasks compose result from subresults } } 注意： ForkJoinTask的类注释中，明确提到：一个非常粗略的经验法则，一个任务的基本计算步骤应该 &gt; 100 且 &lt; 10000，同时需要避免无循环
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/696083229909cd7b707b2b7ae7c62328/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb04f3e76616e5897507ecfe21d97deb/" rel="bookmark">
			常见的css兼容问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么会出现css的兼容性问题
原因：不同的浏览器使用的内核不一样，对css的解析不一样，所以效果也不一样
二、常见的浏览器内核
浏览器内核表示法IE浏览器-ms-谷歌浏览器、360浏览器-webkit-火狐浏览器 -moz-
三、双倍浮动bug
描述：块级元素设置了float属性后，又设置了横向的margin值，在IE6下显示的margin值比设置的值大
解决：给设置了浮动的元素添加display:inline
四、表单行高不一样 1、给表单元素添加vertical-align:middle
2、给表单元素添加float:left
五、IE6（默认最小尺寸为16px） 不识别较小高度的标签（一般为10px）
1、给标签添加：overflow:hidden
2、给标签添加font-size:0
六、图片添加超链接时，在IE浏览器中会有蓝色的边框 给图片添加border:0;或者border:none;
七、最小高度min-height不兼容IE6 1、min-height:100px;_height:100px;
2、min-height:100px;height:auto !important;height:100px
八、图片默认有间隙 1、给img添加float属性
2、给img设置为块级元素 九、百分比bug
描述：父元素设置100%，子元素各占50%，在IE6下，50%+50%大于100%
解决：给右边的浮动元素添加clear:right
十、透明度设置，IE不识别opacity属性 解决：
标准写法：opacity:value(取值范围0到1)
兼容IE浏览器：fliter:alpha(opacity=value)（取值范围1-100）
十一、上下margin重叠问题
描述：给上面的元素设置margin-bottom，给下面的元素设置margin-top,只能识别其中较大的那个值
解决：
1、margin-top和margin-bottom只设置一个值
2、给其中一个元素再包裹一个盒子并设置overflow:hidden; 十二、给子元素设置margin-top却用在了父元素上
1、给父元素设置overflow:hidden
2、给父元素设置float:left
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e40458917790c81c8fccb4fbd4d6899/" rel="bookmark">
			分页查询功能详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 1.分页查询概述2.原始的JDBC实现分页查询步骤2.1 需求2.2导入相关jar包/Maven依赖2.2 创建实体类（pojo）2.3 创建数据库配置信息druid.properties2.4 创建JDBCUtils.java工具类2.5 编写Dao(持久)层代码2.6 编写service(业务)层2.7 编写测试类 3.通过Mybatis插件来实现分页查询步骤3.1 需求3.1 导入相关依赖/jar包3.2 创建实体类(pojo)3.3 编写数据库连接信息配置文件jdbc.properties3.4 编写核心配置文件mybatis-config.xml3.5 编写映射配置文件StudentDao.xml3.6 编写Dao(持久)层3.7 编写Service(业务)层3.8 编写测试类 1.分页查询概述 常规查询全部出现的风险 : 分页查询将数据库中庞大的数据分段显示,每页显示用户自定义的行数,提高用户体验度,最主要的是如果一次性从服务器磁盘中读出全部数据到内存,有内存溢出的风险。后端分页与前端分页的最大不同就是，它不需要一次性向后端请求大量的数据，而是根据用户的设定，一次请求一定量的数据，然后将这些数据回显到页面上，后端分页也才是分页的正确打开方式，其避免了一次性从数据库获取很多数据，也可以美化前端展示效果，优化用户体验。在开发过程中，我们经常会从数据库中查询数据，然后在客户端显示出来。当数据少时，可以在一个页面显示。当我们查询几百条以上数据，直接显示在一个页面上，不仅浏览不方便，查询效率也会受到影响，这是，我们就可以使用分页查询来解决这个问题。基本分页查询思路 我现阶段的分页查询的实现是基于sql语句的。select * from user where id limit a, b构造出相应的a和b就可以查询出想要的数据，在显示在页面上。重点是要构造出当前的页数，就要封装一个javaBean，存储有关分页的基本属性。这样只需在service层计算想要的页数，并封装基本的信息，在查询出来显示在前端就可以了。 2.原始的JDBC实现分页查询步骤 2.1 需求 在后端项目中总是避免不了admin管理，当后台管理需要展示数据时就会需要用到分页，接下来通过分页查询的方式，来查询学生信息 2.2导入相关jar包/Maven依赖 &lt;dependencies&gt; &lt;!--数据库连接--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;/dependency&gt; &lt;!--Lombok插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.2 创建实体类（pojo） 学生实体类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e40458917790c81c8fccb4fbd4d6899/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/921e940940db1910208ba4ecc9799d01/" rel="bookmark">
			PDF目录书签生成器 PDG
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 PDF Dir Generator安装 PyPDF2 和 wxPython获取 PDF 目录信息格式化书签生成书签使用说明基本流程参数设置最终效果 源码下载参考 PDF Dir Generator PDF Dir Generator，PDF 目录生成器， 是基于 wxpython 和 PyPDF2 开发的一个简易的 GUI 程序，主要功能是给未添加书签的 PDF 添加目录书签。
安装 PyPDF2 和 wxPython 可使用 pip 安装 PyPDF2 和 wxpython.
pip install PyPDF2 pip install wxPython 我使用的版本号为： Python 3.9.12, wxpython 4.2.0, PyPDF2 2.11.0
如果 PDF 经过其他软件修改（如删除书签）可能会有如下报错：
File "C:\Users\q2799\.conda\envs\py36\lib\site-packages\PyPDF2\_writer.py", line 1195, in addBookmark title, pagenum, parent, color, bold, italic, fit, *args File "C:\Users\q2799\.conda\envs\py36\lib\site-packages\PyPDF2\_writer.py", line 1174, in add_bookmark parent = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/921e940940db1910208ba4ecc9799d01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/966090c41ef3d53635e690630925c9de/" rel="bookmark">
			（附源码）SSM学生网上请假系统JAVA计算机毕业设计项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
SSM + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
3.1 需求分析 学生网上请假系统主要是为了提高工作人员的工作效率和更方便快捷的满足用户，更好存储所有数据信息及快速方便的检索功能，对系统的各个模块是通过许多今天的发达系统做出合理的分析来确定考虑用户的可操作性，遵循开发的系统优化的原则，经过全面的调查和研究。
系统所要实现的功能分析，对于现在网络方便的管理，系统要实现用户可以直接在平台上进行查看所有数据信息，根据需求可以进行在线添加，删除或修改学生网上请假系统信息，这样既能节省时间，不用再像传统的方式耽误时间，真的很难去满足用户的各种需求。所以学生网上请假系统的开发不仅仅是能满足用户的需求，还能提高管理员的工作效率，减少原有不必要的工作量。
3.2 系统可行性分析 3.2.1技术可行性：技术背景 本企业网站在Windows操作系统中进行开发，并且目前PC机的性能已经可以胜任普通网站的web服务器。系统开发所使用的技术也都是自身所具有的，也是当下广泛应用的技术之一。
系统的开发环境和配置都是可以自行安装的，系统使用SSM开发工具，使用比较成熟的Mysql数据库进行对系统前台及后台的数据交互，根据技术语言对数据库，结合需求进行修改维护，可以使得网站运行更具有稳定性和安全性，从而完成实现网站的开发。
（1）硬件可行性分析
学生网上请假系统及信息分析的设计对于所使用的计算机没有什么硬性的要求，计算机只要可以正常的使用进行代码的编写及页面设计就可行，主要是对于服务器有些要求，对于平台搭建完成要上传的服务器是有一定的要求的，服务器必须选择安全性比较高的，然后就是在打开网站必须顺畅，不能停顿太长时间；性价比高；安全性高。
（2）软件可行性分析
开发整个系统使用的是云计算，流量的可扩展性和基于流量的智能调整云计算的优点就是流量的可扩展性和基于流量的智能调整，保障系统的安全及数据信息的及时备份。
因此，我们从两个方面进行了可行性研究，可以看出系统的开发没有问题。
3.2.2经济可行性 在学生网上请假系统开发之前所做的市场调研及其他的物流公司相关的管理系统，都是没有任何费用的，都是通过开发者自己的努力，所有的工作的都是自己亲力亲为，在碰到自己比较难以解决的问题，大多是通过同学和指导老师的帮助进行相关信息的解决，所以对于学生网上请假系统的开发在经济上是完全可行的，没有任何费用支出的。
使用比较成熟的技术，系统是基于SSM的开发，采用Mysql数据库。所以系统在开发人力、财力要求不高，具有经济可行性。
3.2.3操作可行性： 可操作性主要是对学生网上请假系统设计完成后，用户的使用体验度，以及管理员可以通过系统随时管理相关的数据信息，并且对于管理员、教师和学生三个用户角色，都可以简单明了的进入到自己的系统界面，通过界面导航菜单可以简单明了地操作功能模块，方便用户信息的操作需求和管理员管理数据信息，对于系统的操作，不需要专业人员都可以直接进行功能模块的操作管理，所以在系统的可操作性是完全可以的。本系统的操作使用的也是界面窗口进行登录，所以操作人员只要会简单的电脑操作就完全可以的。
3.3 项目设计目标与原则 1、关于学生网上请假系统的基本要求
（1）功能要求：可以管理首页、个人中心、教师管理、学生管理、请假信息管理、学校公告管理等功能模块。
（2）性能：在不同操作系统上均能无差错实现在不同类型的用户登入相应界面后能不出差错、方便地进行预期操作。
（3）安全与保密要求：用户都必须通过身份验证才能进入系统，并且用户的权限也需要根据用户的类型进行限定。
（4）环境要求：支持多种平台，可在Windows系列、Vista系统等多种操作系统下使用。
2、开发目标
学生网上请假系统的主要开发目标如下：
（1）实现管理系统信息关系的系统化、规范化和自动化；
（2）减少维护人员的工作量以及实现用户对信息的控制和管理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/966090c41ef3d53635e690630925c9de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be47612d47d08e8708b4f3691733c9e9/" rel="bookmark">
			【MM32F5270开发板试用】播放TF卡WAV格式音乐，I2S驱动CS4344
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【MM32F5270开发板试用】播放TF卡WAV格式音乐，I2S驱动CS4344 上四篇文章：
【MM32F5270开发板试用】一、依靠SPI_SD，移植FatFs文件系统
【MM32F5270开发板试用】SysTick+Scheduler轮询
【MM32F5270开发板试用】如何将数据存放在DTCM
【MM32F5270开发板试用】依靠SPI_SD，移植FatFs文件系统（优化版本）
本次所有代码按照以前习惯全部开源：我的Github地址是：https://github.com/kings669/MM32F5
代码比较多，一篇文章也放不下，大家可以直接Clone下代码看就行。
一、I2S总线 I2S(Inter—IC Sound)总线, 又称
集成电路内置音频总线，是飞利浦公司为数字音频设备之间的音频数据传输而制定的一种总线标准，该总线专门用于音频设备之间的数据传输，广泛应用于各种多媒体系统。它采用了沿独立的导线传输时钟与数据信号的设计，通过将数据和时钟信号分离，避免了因时差诱发的失真，为用户节省了购买抵抗音频抖动的专业设备的费用。
在MM32F5270中，SPI与I2S共用引脚。在I2S的描述中，支持半双工通信，也支持全双工模式（通过配置 SPI_I2S_I2SCFGR.HDSEL 位来决定）。
在看一下引脚定义：
我们发送给CS4344的格式是飞利浦标准
我们需要配置为主模式，具体流程可以参考手册。
驱动代码部分
void I2S_Configure(I2S_Protocol_Type Standard, I2S_DataWidth_Type DataFormat, uint32_t AudioFreq, I2S_XferMode_Type Mode) { /* Setup the I2S. */ I2S_Master_Init_Type i2s_master_init; i2s_master_init.ClockFreqHz = CLOCK_APB1_FREQ; i2s_master_init.SampleRate = AudioFreq; i2s_master_init.DataWidth = DataFormat; i2s_master_init.Protocol = Standard; i2s_master_init.EnableMCLK = true; i2s_master_init.Polarity = I2S_Polarity_1; i2s_master_init.XferMode = Mode; I2S_InitMaster(SPI2, &amp;i2s_master_init); I2S_EnableDMA(SPI2, true); I2S_Enable(SPI2, true); } void I2S_DMA_Transfer(uint16_t *Buffer, uint32_t BufferSize) { /* Setup the DMA for I2S RX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be47612d47d08e8708b4f3691733c9e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7392a15c6db799c9c4b0334cad4d477/" rel="bookmark">
			【MM32F5270开发板试用】依靠SPI_SD，移植FatFs文件系统（优化版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【MM32F5270开发板试用】依靠SPI_SD，移植FatFs文件系统（优化版本） 上三篇文章：
【MM32F5270开发板试用】一、依靠SPI_SD，移植FatFs文件系统
【MM32F5270开发板试用】SysTick+Scheduler轮询
【MM32F5270开发板试用】如何将数据存放在DTCM
本次所有代码按照以前习惯全部开源：我的Github地址是：https://github.com/kings669/MM32F5
可能关注我的朋友发现，我最近没有更新文章，那是因为我前段时间去参加今年的智能车竞赛。现在，已经比完，可以有时间完成我后续的计划😄。
一、优化背景
在测试的过程中，发现播放音频卡顿十分卡顿，经过排除后发现，在官方适配的SPI是软件SPI。想到我们的整体流程是从SD卡开始，源头就卡了，何来最大吞吐率😄。
二、优化过程
1、开启时钟，在clock_init.c中
/* SPI3. */
RCC_EnableAPB1Periphs(RCC_APB1_PERIPH_SPI3, true);
RCC_ResetAPB1Periphs(RCC_APB1_PERIPH_SPI3);
2、引脚设置，在pin_init.c中
/* PC12 - GPIO output: SPI3_MOSI. */
gpio_init.Pins = GPIO_PIN_12;
gpio_init.PinMode = GPIO_PinMode_AF_PushPull;
gpio_init.Speed = GPIO_Speed_50MHz;
GPIO_Init(GPIOC, &amp;gpio_init);
GPIO_PinAFConf(GPIOC, gpio_init.Pins, GPIO_AF_6);
/* PC11 - GPIO input: SPI3_MISO. */
gpio_init.Pins = GPIO_PIN_11;
gpio_init.PinMode = GPIO_PinMode_In_Floating;
gpio_init.Speed = GPIO_Speed_50MHz;
GPIO_Init(GPIOC, &amp;gpio_init);
GPIO_PinAFConf(GPIOC, gpio_init.Pins, GPIO_AF_6);
/* PC10 - GPIO output: SPI3_SCK. */
gpio_init.Pins = GPIO_PIN_10;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7392a15c6db799c9c4b0334cad4d477/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df6241c2770e3fbfb6f593f7e74df304/" rel="bookmark">
			【MM32F5270开发板试用】如何将数据存放在DTCM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【MM32F5270开发板试用】如何将数据存放在DTCM 上两篇文章：
【MM32F5270开发板试用】一、依靠SPI_SD，移植FatFs文件系统
【MM32F5270开发板试用】SysTick+Scheduler轮询
本次所有代码按照以前习惯全部开源：我的Github地址是：https://github.com/kings669/MM32F5
我打算做：MM32F5 系列漫谈 2：吞吐率最大化的总线设计中的播放器，里面就有说到需要将数据放入DTCM中。
一、DTCM 在MM32F5270中有：
– 多达 192KB 的 SRAM，其中包括 32KB 指令 TCM（ITCM）， 32KB 数据 TCM（DTCM）和 128KB 的系统 RAM，DTCM地址是从0x20000000开始，大小32KB
TCM=Tightly Coupled
Memory，是一种被直接集成在CPU芯片中的高速缓存。DS有两种TCM，分别是ITCM（Instruction
TCM）和DTCM（Data TCM）。 DTCM 用于数据存取，特点是跟内核速度一样
内置 32K 字节指令 TCM SRAM 和 32K 字节数据 TCM SRAM。指令 TCM（ITCM）起始地址为 0x00000000，数据 TCM（DTCM）起始地址为 0x2000 0000。
TCM SRAM 可以被 CPU 或者 DMA 用最快的系统时钟且不插入任何等待进行访问。
二、使用DTCM 1、我们打开keil魔术棒工具：
0x300000000 开始是SRAM1的区域，勾选后是给Keil进行管理
2、我们点击 Linker
点击编辑
3、我们就可以在这里开始编写一部分代码
RW_RAM1 0x20000000 0x00008000{ ;DTCM *(.RAM_D1) } 分配一个用户段（section），段的名字是RAM_D1，段的地址是 0x2000000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df6241c2770e3fbfb6f593f7e74df304/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c401dfdc9265b0f4e8df1e03bfdbb07/" rel="bookmark">
			再见 Notebook？数据科学家专属 IDE？DataSpell初体验！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Part1DataSpell 大家好，我是早起。
最近续费了JetBrains全家桶，看到多了一个 DataSpell
看了一圈介绍，貌似 jetbrains 在 Pycharm 原生支持 jupyter notebook，既有插件也有 DataGrip 操作数据库的前提下，还选择为 Jupyter notebook 群体开发一款软件。
于是趁着国庆，果断下载体验了一波，看看后面是否需要切换到这个软件进行工作，下面是一些使用下来的感受。
Part2亮点 1数据面板 一个让我觉得比较亮眼的操作，是可以在单独的窗口预览数据、修改数据、导出数据
单独面板看数据，不用再设置max_columns等参数，就像操作 Excel 一样，有需要调整的甚至可以直接右键修改值，右键也可以直接导出到Excel
这种让你少写几行代码的快捷操作，在代码开发阶段还是比较舒服的，毕竟有时候一些简单的操作需要写很长的代码。
不过转念一想，Pandas 将操作 Excel 代码化，IDE又将一些功能 Excel 化，确实有些灰色幽默。
2自动补全 这也是得益于 IDE 的一个非常好的功能，当我们敲代码时可以智能的进行自动提示，这样代码写起来就很舒服了，至少对于我来说，平时一半的代码都是 IDE 写的
3快速搜索 如果你使用过 Alfred ，那么一定是喜欢那种一个搜索框搜索全部文件软件的功能，在DS中也支持敲两下 shift 键来快速搜索一些功能、文件等操作，例如输入run below 就会自动运行当前单元格之后的全部代码
4文件管理 回想之前机遇浏览器的数据科学任务，每次新建一个文件，都要返回到目录页面，新建 ipynb 文件，若要是项目关联的文件比较多，可能急需要打开一排窗口。
如果在加上需要写一些本地的 py 文件，操作起来将会在多个软件之间切换，过程是比较痛苦的。
现在使用 DS 将会更好的进行项目开发，
5异常调试 既然是基于强大的 IDE 开发出来的产品，断点调试等debug功能，自然是原生支持，用起来很丝滑。
6插件 让我想的一个重要原因就是我已经离不开 Pycharm 的一些插件，现在有种回到家的感觉
7Git支持 同插件一样，如果你的工作需要用到 Git 进行版本管理的话，那么使用 DS 进行数据科学工作将会更有效率。
此外，一些 IDE 该有的功能例如远程开发、终端调用、代码统计分析、包管理等功能都能极大提升效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c401dfdc9265b0f4e8df1e03bfdbb07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/426e12409ef6425cbe38cbbae6f37ced/" rel="bookmark">
			深入理解Java双冒号(::)运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 双冒号（::）运算符在Java8中被用作方法引用（method reference），方法引用是与lambda表达式相关的一个重要特性。它提供了一种不执行方法的方法。为此，方法引用需要由兼容的函数接口组成的目标类型上下文
常用语法 静态方法引用语法：className::methodName 例如：Person::getAge对象的实例方法引用语法：instanceName::methodName 例如：System.out::println对象的超类方法引用语法：super::methodName类构造器引用语法：className::new 例如：ArrayList::new数组构造器引用语法：typename[]::new 例如：String[]::new 静态方法语法例子 public class StaticMethodDemo { public static void main(String[] args) { List&lt;String&gt; list = Arrays.asList("aaa", "bbb", "ccc"); list.forEach(StaticMethodDemo::print); } public static void print(String content) { System.out.println(content); } } 类实例语法例子 public class ClassInitializeDemo { public static void main(String[] args) { List&lt;String&gt; list = Arrays.asList("aaa", "bbb", "ccc"); list.forEach(new ClassInitializeDemo()::print); } public void print(String content) { System.out.println(content); } } 超类方法引用例子 @SpringBootTest public class SuperClassDemo extends BaseClass { @Test public void test() { List&lt;String&gt; list = Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/426e12409ef6425cbe38cbbae6f37ced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a364adc214bbf78442ec8fc41f09e570/" rel="bookmark">
			idea中的gradle项目添加Lombok依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果仅仅添加：
compileOnly 'org.projectlombok:lombok:1.18.10' 编译无效，会报错：
正常添加为：
compileOnly 'org.projectlombok:lombok:1.18.10' annotationProcessor 'org.projectlombok:lombok:1.18.10' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30cac11249a5a2c0900473b650185da6/" rel="bookmark">
			uvm-最小工程hello_world
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 uvm 算是当前验证最常用的方法学，提供了很多基于system verilog 的组件和流程控制。通过使用uvm 节省自己搭建流程控制验证结构和常用组件，比如uvm_tlm_analysis_fifo 对于包装过的语言，上手总是有点困难，需要在使用中学习积累。 试验语法了解组件使用为了节省时间最好在小工成里面做，新人开始也最好从小系统开始学习搭建，了解扩展过程。 代码： 文件名 hello_world.sv ``` import uvm_pkg::*; #include "uvm_macro.svh" class hello_world extends uvm_test; `uvm_component_utils(hello_wordl); function new(string name = "hello_world", uvm_component parent); super.new(name, parent); endfunction task run_phase(uvm_phase phase); `uvm_info(get_full_name, "hello_world", UVM_LOW); endtask endclass: hello_world module top(); import uvm_pkg::*; `include "uvm_macros.svh" initial begin run_test("hello_world"); end endmodule ``` 编译命令： 关键是要配置一个uvm 路径 irun -sv -uvmhome xxx/UVM/CDNS-1.1d/sv/ hello_world.sv 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06d40298085ca4a348ffbfc9e934a9c7/" rel="bookmark">
			sv-最小工程hello_world
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般语言都是通过最小工程来起步，最常见的就是hello_world 作为工程名，例如c 的 #include &lt;stido.h&gt; void main() { printf("hello_world!"); } 通过这个最小工程可以了解基本语法 和编译链接过程，建立一个大工程都是从最小工程开始扩展。
这种最小工程编译运行快，也是作为语法练习实验的常用手段，毕竟在大工程中遇到错误直接调试需要经历长时间的编译，再等到运行到出错点会非常费时消耗资源，在小工程里面实验通过再大工程改正验证结果就好了。
sv 代码： 一段验证randc 随机循环的代码 文件名： test.sv
class test; rand bit [31:0] addr,data; constraint c1 { addr inside {[1:100]}; data inside {[1:100]}; } endclass module test_m; test t; initial begin t = new(); t.randomize() with{addr == 100; data== 15;} $display(t.addr); $display(t.data); end endmodule 编译命令：
xrun test.sv -notimingcheck -sv -access +rwc -64 -timescale 1ns/10ps -sem2009 -gui
也可以换成irun 的命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06d40298085ca4a348ffbfc9e934a9c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6060c12baac0b5e311dfab7189c37992/" rel="bookmark">
			分布式场景下的稳定性保障
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是稳定性保障
稳定性保障简单理解就是不让系统出现不可用的情况，或者不可用的情况每年只能发生几十分钟。
为什么要稳定性保障？因为现在很多的电商系统和支付系统已经属于社会基础服务，持续一段时间不可用会对社会影响比较大，同时也损失了用户的信任。
稳定性保障的场景非常多，只要流量非常大的业务就需要系统性的进行稳定性保障，包括直播、电商秒杀、电商大促等场景。2022年9月3日晚刘德华“把我唱给你听”线上演唱会，最终这场线上演唱会的在线观看人次达到3.5亿，那么支持3.5亿人次观看就是一种稳定性保障场景。每年电商网站618、99、双11和双12大促。除了大促以外，还有很多亿级用户的产品也需要稳定性保障，如电商交易、第三方支付、演唱会直播等场景。还有很多秒杀的场景，如每晚8点某电商网商1499秒杀茅台、在12306网站提前N天抢票。
2、明确稳定性保障目标
做稳定性保障的第一件事是要明确保障的一级目标，比如某明星直播要明确保障目标是3亿还是6亿人次观看，某大促交易峰值是20WTPS还是40W TPS。
2.1、明确一级目标
业务稳定性保障的目标通常是在保障某业务不可用的时间每年持续多久，某业务全年可用率目标99.995%，一年一共有525600分钟，每年的不可用时间必须控制在26(525600*0.00005)分钟以内。
系统稳定性目标是峰值QPS（每秒请求数）和TPS（每秒写入数）达到多少。注意一定是要峰值目标！这个峰值分为日常峰值和大促峰值，所以稳定性保障有日常保障目标和大促保障目标。从成本角度考虑，每场大促需要做单独保障，大促保障完之后需要回收服务器和各种资源，线上运行的机器一般只能支撑日常峰值或小促。那么我怎么知道今年大促峰值要支撑多少TPS呢，这个只能根据经验估算，一般的估算经验是日常峰值的十倍，或去年大促峰值的2倍，这个其实很难估算非常准确只能尽量估大。
2.2、拆解二级目标
如果一级目标是支付峰值，那么需要进一步拆解支付咨询量，交易创建量等二级指标，针对这些二级指标做稳定性保障。否则交易创建失败了，只做支付TPS的一级目标保障也没有任何用。
3、如何进行稳定性保障
稳定性保障的过程分为链路梳理、全链路压测、集群扩容、服务限流、增加提前预案和增加紧急预案。本文会用秒杀业务举例说明。
（稳定性保障的7个步骤）
3.1、全链路梳理
全链路梳理是梳理各系统之间的调用量，包括主链路系统、消息中间件和数据库等。下面以秒杀系统来举例说明如何进行全链路梳理
分析出主链路中需要改造的点：
减少依赖：部分服务直接依赖缓存，如果电商系统查询某数据依赖A系统，如果数据更新不频繁，可以把A系统的数据直接放在缓存集群里。
同步改异步：对于性能要求高的接口，又不需要及时得到相应，我们改成了同步受理，然后异步处理。
增加限流配置，主链路中用到的接口都要配置限流。
增加降级开关，如果秒杀系统负载过大，可以通过降级配置拦截一部分秒杀请求。
稳定性保障最关键的手段是减少依赖。
我负责的支付线稳定性架构升级做的最核心的事情就是降低下游依赖，把下游的服务依赖改成依赖下游的近端包、在近端包里缓存依赖或数据库。把依赖2个系统服务改成依赖1个系统的服务。
3.2、全链路压测
全链路压测是检验稳定性最重要的手段。
秒杀系统是一个高并发的系统，由于并发请求量很大很容易出现高可用问题。所以系统开发完成之后，需要通过压测了解系统高可用水位，比如系统最大能承受的QPS是多少万，系统最大能承受的TPS是多少万，单机最大承担的TPS是多少。
压测前需要注意以下几点
优先在线上压测，压测时需要通知链路上系统OWNER。
压测前需要配置限流，压测流量逐渐摸高触发限流，检查限流是否生效。触发限流时，可以打开限流提高流量压测。
区分读流量压测和写流量压测。读流量逐渐摸高，对线上影响不大，一旦有问题停止压测。写流量对线上会有影响，需要写影子表，即压测流量写到单独的表和线上数据隔离。
每次变更后会再次进行压测，确保变更无性能问题。
压测过程中需要观察以下几个指标
系统指标，如应用错误数，业务流程是否正常。
机器性能指标，如IO，CPU利用率，LOAD，TCP重发率，流入流出带宽流量（一般机器是千兆网卡），GC等，不同机器的流量是否均衡。日志是否打的太快，导致磁盘飙高。
检查下线程池的容量，活跃线程是否已经达到最大线程，阻塞队列是否已满。应用的线程池很多，比如消息客户端线程池、消息接收线程池、消息处理线程池和RPC线程池等。
消息是否有挤压，有挤压多长时间可以处理完。是否会影响正常业务，如果影响就直接抛弃掉。
检查限流的
设置是否正常，压测的时候可能要打开限流。
如果压测之后发现TPS一直很低，需要DUMP内存和线程堆栈，帮助你做进一步分析。如果代码没问题又需要追求更高的TPS或QPS那么需要考虑扩容。
3.3、集群扩容
集群扩容包括服务器集群扩容、缓存集群扩容、分布式存储扩容和数据库容量扩容等。
全链路梳理的是集群流量，服务器扩容时要考虑单机承担的QPS，比如集群承担的QPS是20W，单机最多能承受2000QPS，所以一共需要100台机器。扩容需要注意几个关键点，因为限流配置是针对单机的，扩容之后需要重新配置限流。每个机房的机器数和流量要匹配，比如A机房有60%的流量，那么60%的机器要在A机房，不过高稳定性业务单机房能承担所有流量，既当B机房不可用时候，A机房虽然只有60%的机器仍然能支撑100%的流量。检查机器是否有状态，比如机器需要在白名单里才能访问某个IP，CPU是不是全是独享或是共享，机器有状态扩容会出现问题。适当的冗余机器，有可能秒杀过程中刚好遇到了几台机器宕机，这个时候最佳处理办法就是下线这几台机器，因为排查机器问题进行修复的时间会比较长。
需要定期对容量进行评估。如大促前进行压测和容量预估，根据需要进行扩容。根据资源的使用率自动或手动进行扩容。如带宽不够用时，快速增加带宽。
3.4、服务限流
为了保护系统稳定性，服务必须设置限流，如果单机压测到了3000QPS和1000TPS，且系统性能在一个60%水位，配置的限流最好低于3000QPS或1000TPS。每次压测完之后记得调整限流。限流配置分为单机限流配置、机房限流配置和集群限流配置，可以通过单机限流配置计算出机房限流数值和集群限流数值。
3.5、提前预案
提前预案是指在大促开始之前执行的预案。需要记录并录入到预案平台，记录是为了回滚，放到预案平台是为了方便执行。预案有如下这些：
服务降级：打开和关闭某些功能，比如消息量过大，系统处理不了，把开关打开后直接丢弃消息不处理。上线新功能增加开关，如果有问题关闭新功能。
主链路依赖服务的限流配置
关闭大数据同步任务，关闭把大量数据从离线同步到在线DB，降低数据库压力。
关闭部分可降级的业务入口，比如签约和解约等。
关闭变更入口，如大促期间不允许发布和变更配置。
3.6、紧急预案
如果流量太大导致服务器出现问题，直接进行秒杀功能降级，让用户的秒杀请求跳转到一个纯静态的HTML页面，提示用户秒杀活动结束。紧急预案在执行的时候都会找另外一个同学一起double check下，确保紧急预案执行正确，我们差点出现过紧急预案执行错的case。
增加熔断机制，当监控出线上数据出现大幅跌涨时，及时中断，避免对业务产生更大影响。如我们做指标计算时，指标可以计算慢，但是不能算错，如果发现某个用户的指标环比或同比增长一倍或跌零，会考虑保存所有消息，并中止该用户的指标计算，大促之后再进行指标计算。
3.7、系统监控
系统监控主要从两个维度进行配置，一个是业务流量监控，一个是系统问题监控。
业务流量监控，主要监控业务流量的波动，通过业务流量的波动可以发现系统问题，业务数据包括秒杀活动访问量、秒杀请求量和秒杀成功量。因为秒杀业务在几秒内完成，所以可以配置秒级监控。
系统问题监控，主要监控应用错误数、CPU、内存、以及是否触发限流等指标。精准监控 CPU利用率，load、内存、带宽、系统调用量、应用错误量、系统PV、系统UV和业务请求量，避免内存泄露和异常代码对系统产生影响，配置监控一定要精准，如平时内存利用率是50%，监控可以配置成60%进行报警，这样可以提前感知内存泄露问题，避免应用在大促造成雪崩现象。
4、大促稳定性保障
大促保障除了要做以上七件事情以外，还要做大促计划、大促准备、大促值班和大促复盘。
4.1、制定大促计划
整个大促保障准备的事情非常多，具体事情如下
目标
主链路分析
系分设计
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6060c12baac0b5e311dfab7189c37992/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f0623f2129387a8ec0f81b664492761/" rel="bookmark">
			pycharm更改项目存储路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装好pycharm后默认的路径是c盘。
它占用的空间很大，需要更改路径。
方法：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/201/">«</a>
	<span class="pagination__item pagination__item--current">202/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/203/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>