<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d91435bba0ff2660007d7f0365be9341/" rel="bookmark">
			Python 画降雨图，mash 数据掩膜 裁剪出想要的区域，根据shp文件裁剪tif数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景介绍 2. 导库 import numpy as np import xarray as xr import matplotlib.pyplot as plt from matplotlib.cm import get_cmap import cartopy.crs as ccrs import cartopy.feature as cfeat import cartopy.io.shapereader as shpreader import shapefile from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER import matplotlib.ticker as mticker from netCDF4 import Dataset from wrf import to_np, getvar, interplevel, ALL_TIMES, latlon_coords, get_cartopy import warnings warnings.filterwarnings('ignore') 3. 准备工作： 兰伯特刻度线补丁子程序 from copy import copy import numpy as np import shapely.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d91435bba0ff2660007d7f0365be9341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c00396d03914433854f77877f4fead/" rel="bookmark">
			Python [ ]、[:]和[::]的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对切片进行操作：
[ ]： 主要是取序列中的一个元素，例如：str_list[2]取序列中的第3个元素，这里2指序列中的index。
[:]： 主要是取序列中的一段元素，例如 str_list[1:4] 表示访问 str_list 序列中的第二到第四个元素 (str_list[1]，str_list[2]，str_list[3])，不包含 str_list[4] 元素。
如果没有提供索引值，则默认从 0 开始。str_list[:4] 表示访问这个序列的第一到第四个元素 (不包含 str_list[4] 元素)，str_list[4:] 表示访问第五到最后一个元素。注意：m\n可以为负，m&gt;n时返回空。
[::]：主要逆序和间隔取序列中的元素，例如：(1)翻转序列的元素，例如 str_list[::-1] 表示翻转取序列中的元素， str_list 序列中的元素。(2)：间隔取元素：str_list[1::2]，从索引1开始，每次跳2个取取元素。注意：当n为负时逆序取数，当n为正的时候，m为空则默认m=0，n为负时，m为空则默认为-1。
#!/usr/bin/env python # -*- coding: utf-8 -*- from __future__ import absolute_import from __future__ import print_function from __future__ import division import os import sys import cv2 import numpy as np import matplotlib.pyplot as plt print(16 * "++--") str_list = ['A', 'B', 'C', 'D', 'E', 'F', 'G'] print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8c00396d03914433854f77877f4fead/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c7f539ab30ff1b256712fc37fe284d/" rel="bookmark">
			ROS2（三）使用colcon编译package
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方指导文档为：
https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Colcon-Tutorial.html
1. 安装colcon 在安装ros2时，如果按照官方指导操作应该是已经安装了colcon，可以使用命令colcon -h，测试是否已经有colcon，如果没有安装，则执行以下命令进行安装：
sudo apt install python3-colcon-common-extensions colcon是一个ROS构建的集成工具，包括：catkin_make\catkin_make_isolated\catkin_tools和ament_tools；colcon支持多种构建方式，推荐的构建方式是ament_cmake和ament_python，也支持纯cmake包；
2. 创建工作空间 ROS的工作空间是有固定的结构的。一般情况在/home目录下创建工作空间文件夹，例如：ros2_ws，则ros2_ws就是工作空间根目录。
mkdir -p ~/ros2_ws/src cd ~/ros2_ws 工作空间目录下一定要有一个src文件夹，里面放置ROS package的源代码。
3. 编译工作空间 在工作空间根目录下进行编译，使用如下命令：
colcon build 只创建一个空的src文件夹，也可以构建，会自动生成其他文件夹：
├── build
├── install
├── log
└── src
4.设置环境变量 当colcon编译成功后，会自动生成对应install文件夹，其中包含setup.sh文件，在使用编译的库或者程序前，都需要将其路径加入到环境变量中，在install文件夹下运行如下命令。
source setup.bash 这样就可以把编译的库添加到系统环境中。
如果不需要编译某个package时，只需要在其对应的文件夹下创建一个名称为COLCON_IGNORE的空文件，则该文件则不会被编译。
5.package.xml 下面是默认的package.xml内容：
&lt;?xml version="1.0"?&gt; &lt;?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?&gt; &lt;package format="3"&gt; &lt;name&gt;my_package&lt;/name&gt; &lt;version&gt;0.0.0&lt;/version&gt; &lt;description&gt;TODO: Package description&lt;/description&gt; &lt;maintainer email="user@todo.todo"&gt;user&lt;/maintainer&gt; &lt;license&gt;TODO: License declaration&lt;/license&gt; &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt; &lt;test_depend&gt;ament_lint_auto&lt;/test_depend&gt; &lt;test_depend&gt;ament_lint_common&lt;/test_depend&gt; &lt;export&gt; &lt;build_type&gt;ament_cmake&lt;/build_type&gt; &lt;/export&gt; &lt;/package&gt; name：包的名称
version：包的版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33c7f539ab30ff1b256712fc37fe284d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26d6cb2841656fe43fe9815868a90b68/" rel="bookmark">
			Java中如何为HTTP请求设置代理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.什么是代理服务器 代理服务器充当你和Internet之间的网关，就像一个中间人。它实际上是一个中间服务器，可以将用户与它们游览的网站区分开。
如果你使用了代理服务器，那么网络流量会通过代理服务器流向你请求的地址。然后该请求通过同一台代理服务器返回,然后代理服务器将从网站接收到的数据转发给你。
当然如果仅仅是这样，也没什么必要使用代理服务器，我们直接访问网站岂不更美？
现在代理服务器的功能远不只是转发Web请求，而这一切都是为了保证数据安全和网络性能。代理服务器充当防火墙和Web筛选器，提供共享的网络连接，并缓存数据以加快常见请求的速度。
而且还可以保护用户和内部网络以免收到外部Internet的不良影响。
二.Java如何使用代理服务器 java 有两种方式可以设置代理服务器
1.如何设置 1.通过命令行选项进行设置
java -Dhttp.proxyHost=webcache.example.com -Dhttp.proxyPort=8080 -Dhttp.nonProxyHosts="localhost|host.example.com" test.jar 所有http连接都将通过webcache.example.com上的代理服务器在端口8080上监听(如果不指定端口默认是80),此外，连接到localhost或host.example.com时将不使用代理。
2.通过System.setProperty(String，String)方法
// 设置代理 System.setProperty("http.proxyHost", "webcache.example.com"); System.setProperty("http.proxyPort", "8080"); // 下一个连接将会使用代理 URL url = new URL("http://java.example.org/"); InputStream in = url.openStream(); // 清除代理 System.clearProperty("http.proxyHost"); // 从现在开始，http连接将直接完成而不再使用代理 2.参数说明 1.http.proxyHost : 代理服务器主机名
2.http.proxyPort : 端口号,默认是80
3.https.proxyHost : https代理服务器主机名
4.https.proxyPort: 代理端口号,默认是443
5.http.nonProxyHosts : 指定绕过代理的主机列表，使用 | 分割的模式列表,可以以通配符 * 开头或者结尾,任何匹配这些模式之一的主机都将通过直接连接而不是通过代理访问。该设置对http,https通用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5cbe7e4f03ebcd6e80cb7e47b37f0d2/" rel="bookmark">
			@Documented注解的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @Documented和@Deprecated注解长得有点像，@Deprecated是用来标注某个类或者方法不建议再继续使用，@Documented只能用在注解上，如果一个注解@B，被@Documented标注，那么被@B修饰的类，生成文档时，会显示@B。如果@B没有被@Documented标注，最终生成的文档中就不会显示@B。这里的生成文档指的JavaDoc文档！
@Deprecated注解基本上所有框架自定义的注解都会添加，所谓javadoc其实就是JDK给我们提供的一个生成文档的工具！
使用示例如下：
@Documented public @interface DocumentedMy { String value() default "这是一个自定义类"; } @DocumentedMy public class MyTest1 { public String getStr() { return "123"; } } 生成javadoc文档有两种方式，一种是直接基于javadoc命令，一种是ide提供的！当然实际在开发当中我们很少会使用这个文档！除非我们要开源某个框架什么的才会用到！
通过ider生成javadoc文档：
1.点击项目当中的任意包
2.点击生成JavaDoc
3.指定生成位置
4.点击index.html
5.查看我们使用自定义注解的类，会发现他文档上面会展示这个自定义注解！
假如把自定义注解当中的@Documented去掉，然后使用该自定义注解的类，生成的文档就会不显示该注解！
@Deprecated：被标注过的方法，调用就会出现横线，表示不建议再继续使用，但是还能用！
/** * 测试Deprecated注解 * @author Administrator */ public class DeprecatedDemoTest { public static void main(String[]args) { // 使用DeprecatedClass里声明被过时的方法 DeprecatedClass.DeprecatedMethod(); } } class DeprecatedClass { @Deprecated public static void DeprecatedMethod() { } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aead63c0006ed1e22c88b71ab8a5697/" rel="bookmark">
			谈谈你用过的编程语言和编辑工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、我使用过的编程语言 Java、 c 和 c++、shell。
C 语言的未来： 在编程语言流行程度方面，Java、Python、C++ 等现代编程语言已经取代了C语言的地位；但是C语言已经存在了很长时间，并且到目前仍然被大量使用。
C语言失败的一个主要原因是 C++的诞生。C++ 在C语言的基础上进行了扩展，不但保留了几乎所有的C语言特性，还包含了面向对象编程和模板编程等新的思想。对于用户使用的应用程序，人们更喜欢使用 C++，它的开发效率更高，使用更方便。
但是，C++ 程序占用内存较多，尤其是在使用 C++ 标准模板库时，内存更是疯长，对于资源有限的嵌入式系统，或者在意资源消耗的系统组件来说，内存疯长是不能承受的，所以C语言仍然是嵌入式系统开发、驱动开发、算法开发的更可靠的选择。
总之，在应用层开发中，C语言已经被 Java、Python、PHP 等现代语言取代了，C语言几乎没有了用武之地。但是，在嵌入式系统开发、驱动开发、底层组件开发、算法开发方面，C语言仍然是不可被替代的。
C语言在可见的未来虽然不会有蓬勃的发展，但是它也不会消失，它仍然有用武之地，在某些领域仍然是不可或缺的。C语言没有未来，但是仍不可被取代。
讲完风光历史，接下来看一看C/C++的未来，究竟其在未来在哪些领域能占据一席之地。
C++ 的未来 1、游戏
游戏领域，效率和稳定性是十分重要的，以腾讯微代表的游戏公司，很多游戏都是C++开发的。
2、科学计算在科学计算领域，FORTRAN是使用最多的语言之一。但是近年来，C++凭借先进的数值计算库、泛型编程等优势在这一领域也应用颇多。
3、网络软件
C++拥有很多成熟的用于网络通信的库，其中最具有代表性的是跨平台的、重量级的ACE库，该库可以说是C++语言最重要的成果之一，在许多重要的企业、部门甚至是军方都有应用。
4、中层框架
很多大型公司都会利用自己的技术积累，利用C++写一些高性能的中间框架，再上层接入开发效率高的语言如python、go等，从而实现高运行效率和高开发效率兼得。
5、嵌入式
C/C++在嵌入式的地位不用多说。
6、工业互联网领域
关于这一点我深有体会，现在工业互联网已经上升到国家战略层级，而很多工业机床或者系统都是数据接口都是提供的C++的接口，并且由于工业设备性能较落后对运行效率有较大要求，所以C++在工业数据采集和交互控制方面有天然优势和广阔应用前景。
7、人工智能
最后一个，今年火爆的人工智能方面，C++也逐渐占据一席之地。虽然python还是占据主导地位，但是C++也是在逐渐追赶，目前也占有一定市场。
Java 的未来 二、我使用过的编程工具 Clion、Sublime Text、 DevC++、 vscode、 visual studio 2022 、 codeblock。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a12e6abf71fec43be58bef33639722a3/" rel="bookmark">
			Web3.0介绍与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Web3.0的概念二、Web3.0的技术架构1.基础设施层2.协议层3.应用层 三、Web3.0的应用场景1.去中心化交易所2.去中心化身份验证3.去中心化社交平台 四、Rust-Web3：一个Web3.0的Rust语言实现总结 前言 当今互联网的发展速度快速加快，人们对网络的期望也越来越高。Web3.0作为下一代互联网技术，被认为将会是一个更加开放、去中心化、安全、私密、可信的网络。本篇技术博客将介绍Web3.0的概念、特点、技术架构、应用场景等方面内容。
一、Web3.0的概念 Web3.0被认为是下一代互联网技术，也被称为“去中心化互联网”或“分布式互联网”。Web3.0不仅是一个技术概念，更是一种新的思维模式和网络形态，它将重新定义互联网的本质和未来。
Web3.0的主要特点包括：去中心化、安全、私密、可信、开放、互操作性、智能化、分布式计算等。这些特点的实现离不开区块链、智能合约、分布式存储、加密技术、P2P网络等关键技术的支持。
二、Web3.0的技术架构 Web3.0的技术架构可以分为三层，从下到上分别是基础设施层、协议层和应用层。
1.基础设施层 基础设施层包括分布式存储、P2P网络、区块链等技术。其中，分布式存储技术可以解决Web2.0时代存在的中心化存储问题，P2P网络技术可以实现去中心化的通信，而区块链技术则是Web3.0的核心技术之一，它可以保证网络的去中心化、安全、可信等特性。
2.协议层 协议层是Web3.0的重要组成部分，它包括以太坊协议、IPFS协议、Whisper协议等。其中，以太坊协议是实现智能合约的基础协议，它可以支持各种去中心化应用程序（dApps）的开发和部署。IPFS协议则是分布式存储协议，它可以将文件和数据存储在全球各地的节点上，实现数据的去中心化存储和访问。Whisper协议则是实现消息传递的协议，它可以实现点对点的加密通信。
3.应用层 应用层是Web3.0的最上层，包括各种去中心化应用程序（dApps），如去中心化交易所、去中心化投票系统、去中化社交平台等。这些应用程序可以在以太坊网络上运行，利用智能合约和去中心化存储等技术，实现无需信任的交互和数据共享。
三、Web3.0的应用场景 Web3.0的应用场景非常广泛，以下是其中几个比较典型的应用场景：
1.去中心化交易所 在Web3.0时代，去中心化交易所（DEX）将会成为一个非常重要的交易平台，因为它们可以在保证用户资产安全和私密性的同时，实现无需信任的交易和清算。例如，以太坊上的Uniswap、Sushiswap等就是比较典型的去中心化交易所。
2.去中心化身份验证 在Web3.0时代，去中心化身份验证将成为一个非常重要的应用场景。通过基于区块链的身份验证，用户可以在互联网上实现更加安全和私密的身份验证，并且不需要第三方机构的支持。例如，基于区块链的身份验证协议DID就是一个比较典型的应用。
3.去中心化社交平台 在Web3.0时代，去中心化社交平台将成为一个非常有前途的应用场景。通过去中心化存储和通信技术，用户可以实现在互联网上更加安全、私密和自主控制的社交互动。例如，基于IPFS和以太坊的去中心化社交平台AKASHA就是一个比较典型的应用。
四、Rust-Web3：一个Web3.0的Rust语言实现 Rust-Web3是Web3.0的一个Rust语言实现，它是以太坊生态系统中非常重要的一个组成部分。Rust-Web3可以让Rust开发者更加方便地与以太坊网络进行交互，实现以太坊应用程序的开发和部署。
Rust-Web3的主要特点包括：高性能、类型安全、易用性、可扩展性等。它可以通过HTTP、IPC、WebSocket等多种方式与以太坊节点进行通信，支持各种常见的以太坊操作，如获取块高、发送交易等。
以下是一个简单的Rust-Web3使用示例，用于获取最新的块高：
use web3::Web3; use web3::types::BlockNumber; fn main() { let web3 = Web3::new("http://localhost:8545").unwrap(); let block_number = web3.eth().block_number().wait().unwrap(); println!("Latest block number: {}", block_number); } 总结 Web3.0作为下一代互联网技术，将会为互联网应用带来更加安全、去中心化、自治的特性。其中，以太坊作为Web3.0的代表性技术，将会扮演非常重要的角色。Rust-Web3作为Web3.0的Rust语言实现，可以让Rust开发者更加方便地开发以太坊应用程序，实现与以太坊网络的交互。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72864748d85b59fc98b19cca299baff1/" rel="bookmark">
			连接池 Druid （一） - 初始化过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HikariPool之后，今天研究另一主流连接池Druid。
#### 关于数据库连接池的基本认知
先对数据库连接池的基本工作原理做个了解，不管是HikariPool、还是druid，所有的数据库连接池应该都是按照这个基本原理工作和实现的，带着这个思路去学习数据库连接池，避免盲人摸象。
数据库连接池一定会包含以下基本逻辑：
1. 创建连接并池化：初始化的时候创建、或者是在应用获取连接的过程中创建，连接创建好之后放在连接池（内存中的容器，比如List）中保存。
2. 获取数据库连接：接管了获取数据库连接的方法，从连接池中获取、而不是创建连接。
3. 关闭数据库连接：接管了关闭数据库连接的方法，将连接归还到连接池、而不是真正的关闭数据库连接。
4. 连接池维护：连接池容量、连接超时清理等工作。
带着这个思路研究HikariPool的源码，会有事半功倍的功效。
#### 认识Druid的结构
包括以下几个部分：
1. DruidConnectionHolder
2. Connections
3. evictConnections
4. keepAliveConnections
5. destroyConnectionThread/destroySchedulerFuture
6. createConnectionThread/createSchedulerFuture
#### DruidConnectionHolder
HikariPool通过poolEntry持有数据库连接，Druid通过DruidConnectionHolder持有数据库连接。
DruidConnectionHolder持有物理数据库连接Connectin对象，以及该连接的相关属性，比如connectTimeMillis、lastActiveTimeMillis、lastExecTimeMillis，以及underlyingReadOnly、underlyingAutoCommit、underlyingTransactionIsolation等等。连接池可以根据这些属性以及相关参数执行相应的houseKeep。
#### Connections
Connections是DruidConnectionHolder组成的数组，是Druid连接池中唯一存储可用连接的地方，看起来会比HikariPool简单许多（HikariPool有三个存储连接的地方），但是这可能也是Druid在性能上稍逊于HikariPool的原因之一。
#### evictConnections
存储需要被回收的连接的数组，在连接池进行清理的时候用来存储需要被关闭的连接。
#### keepAliveConnections
存储保持活动的连接的数组。
#### createConnectionThread/createSchedulerFuture
Druid根据配置，可以通过createConnectionThread线程、或者createSchedulerFuture线程任务创建数据库连接并加入连接池。
Druid也许并没有默认的createSchedulerFuture的实现，如果要启用createSchedulerFuture，需要配置createSchedulerFuture的实现类。
createConnectionThread是Druid默认的创建连接的线程，负责获取物理连接、组装物理连接为DruidConnectionHolder并加入到connections数组中。
#### destroyConnectionThread/destroySchedulerFuture
与创建连接的方式类似，Druid提供两种不同的方式销毁（或者关闭）过期的数据库连接。默认实现是destroyConnectionThread。
***好了，Druid的基础结构了解完了，我们采用和HikariPool完全一样的分析套路，接下来要进入源码分析了，主要包括：***
1. Druid连接池的初始化
2. 获取数据库连接 - getConnection方法
3. 关闭数据库连接 - close方法
#### Druid的初始化
Druid的初始化过程貌似和HikariPool稍有不同，因为HikariPool默认的在获取连接之前的HikariPool实例化过程中就完成了连接池的初始化。
所谓完成连接池的初始化，指的是按照参数的设定，完成了数据库连接的创建和池化，也就是说连接池已经准备好了，应用在通过getConnecton方法获取连接的时候，直接从连接池中borrow就可以了。
Druid貌似不这样。我们看一下DruidDataSource的实例化方法：
```
public DruidDataSource(){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72864748d85b59fc98b19cca299baff1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f715c78b13d1f83caaf8bce3937807/" rel="bookmark">
			github文件上传全流程-新手入门系列（超详细！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.获取网络连接windowsmac 2.进入github官网创建个人账号3.进入github内部创建个人仓库(repositories)4.安装git软件windowsmac 5.第一次提交文件到github仓库时（仓库中无文件）5.0总体流程5.1配置免密登录5.2设置提交代码时的用户信息5.3构建本地仓库数据5.4连接本地仓库和远程仓库5.5提交代码到远程仓库(github) 6.非第一次使用github仓库（仓库中有文件）6.1删除远程仓库中的部分内容6.2在有文件的条件下，向远程仓库添加文件 7.上传大文件7.1安装git lfs7.2上传大文件 8.GitHub 用户名与昵称修改8.1昵称修改8.2用户id(用户名)修改 9.git修改需要连接的远程仓库地址1.修改命令2.先删后加3.直接修改config文件 10.添加或更新token11.GitHub分支 1.获取网络连接 直接访问github网站是非常慢的，甚至有时可能不能访问，所以需要重新获取网络连接。
使用下面网站:https://tool.chinaz.com/dns/ -&gt;在输入框中输入github.com,github.global.ssl.fastly.net,assets-cdn.github.com
不断点击并查看其给出的ip地址和TTL时间（响应往返时间，越小越好） 记录一个TTL时间比较短的IP地址。根据上图我们选择第二个IP。
windows 在windows本地打开/c/windows/system32/drivers/etc/HOSTS文件并在文件最后一行
添加我们得到的最短ttl时间对应的IP地址+github.com,github.global.ssl.fastly.net,assets-cdn.github.com
eg:
mac 进入命令行
vi /etc/hosts
同样添加上述内容
保存并关闭
解释下为什么这样有一定效果，这不得不提我们访问网站的流程：
域名解析（这里需要借助DNS域名服务器，所以如果我们与域名服务器的TTL越短，我们就能更快的得到github服务器的IP，从而能够更快访问github网站）为了将消息从你的 PC 上传到服务器上.过程中需要用到 1P 协议、ARP 协议和 0SPF 协议发起TCP的3次握手建立 TCP 连接后发起 http 请求服务器响应 htp 请求浏览器解析 html 代码,并请求 html 代码中的资源(如 js、css、图片等)断开 TCP 连接浏览器对⻚面进行渲染呈现给用户 当然，从以上过程我们可以发现上述办法只是加快了我们知道网站IP的速度，但是有些时候在内网情况下，github就是访问不到的。这种情况，我们可以考虑换成手机热点，或者使用科学上网软件。再不济就在Gitee上找找是否有这个资源。
2.进入github官网创建个人账号 github
3.进入github内部创建个人仓库(repositories) 4.安装git软件 windows 下载链接：https://git-scm.com/downloads
下载后，只需要选一下安装路径，其他不用考虑，直接下一步，下一步…即可。
如果需要详细选择可以参考：知乎
安装完成后，可在任意一个文件夹下鼠标右键选择使用git bash（命令行的方式）来进行操作
mac 1.下载并安装brew
​/bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)"
x86架构：
2.下载并安装git
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53f715c78b13d1f83caaf8bce3937807/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de669ef736e163f775bd2e44ed93d474/" rel="bookmark">
			Java8 Lambda表达式 List转Map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近项目中，因为业务需要，我使用了for循环进行List转Map，但是使用传统的for循环可以实现功能，但是一点不优雅。作为一名程序员，不能仅限于实现功能，只有不断的去优化代码，才能提升自己的编码能力，于是我就想到了Java8的新特性，使用stream流进行操作，让代码一下子优雅起来了，给你们看看我是如何一步步将代码优雅起来的，顺便学习了一波 Collectors.toMap() 的源码。
当我们处理一些数据时，将一个列表转换为映射是一个常见的需求。在Java 8中，我们可以使用stream和Lambda表达式、来轻松地将列表转换为映射。在这篇博客文章中，我们将学习如何使用Java 8将List转换为Map。
让我们先来看一个简单的例子，假设我们需要给前端返回一个MessageTypeDTO类，该类具有id、type和titleName属性
// 需要操作的对象 @Data public class MessageTypeDTO { // id（唯一） private Integer id; //消息类型 private String type; // 标题名称 private String titleName; // 业务字段 ... public MessageTypeDTO() {} public MessageTypeDTO(Integer id, String type,String titleName) { this.id = id; this.type = type; this.titleName = titleName; } } // 业务层代码 // 先看看传统for循环的写法 public static void main(String[] args) { List&lt;MessageTypeDTO&gt; messageTypeList = new ArrayList&lt;&gt;(); // 需要处理的集合 // 我先造一些数据 List&lt;MessageTypeDTO&gt; msgTypeList = Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de669ef736e163f775bd2e44ed93d474/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87fb4c495ffb3a0a884b9cf6642ed426/" rel="bookmark">
			缓存穿透、雪崩、击穿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文全部代码地址
缓存穿透 介绍 缓存穿透是指客户端请求的数据再缓存中和数据库中都不存在,这样缓存永远不会生效,这些请求都会打到数据库,失去了缓存保护数据库的意义.
常见的解决方案有两种:
缓存空对象:当我们客户端访问不存在的数据时,先请求redis,但此时redis中没有数据,此时会访问到数据库,但是数据库中也没有数据,这个数据穿透了缓存,直击数据库,我们都知道数据库能够承载的并发不如redis这么高,如果大量的请求同时过来访问这种不存在的数据,这些请求就都会访问到数据库,简单的解决方案就是哪怕这个数据在数据库中也不存在,我们也把这个数据存入到redis中,设置一个较短的过期时间.这样,下次用户过来访问这个不存在的数据,那么在redis中也能找到这个数据就不会进入到缓存了.但是如果这条记录后来在数据库中存在对应的记录,就会造成数据短暂的不一致布隆过滤器:布隆过滤器详解博客 代码实现 /** * @author fanqiechaodan * @Classname UserServiceImpl * @Description */ @Service @Slf4j public class UserServiceImpl implements UserService { @Autowired UserMapper userMapper; @Autowired StringRedisTemplate stringRedisTemplate; /** * 储存用户信息的key前缀 */ private static final String REDIS_USER_PREFIX = "user_"; @Override public User getUser(String id) { String resStr = stringRedisTemplate.opsForValue().get(REDIS_USER_PREFIX + id); if (StringUtils.isNotBlank(resStr)) { log.info("从redis获取返回..."); return JSON.parseObject(resStr, User.class); } if (StringUtils.EMPTY.equals(resStr)) { log.info("缓存虽然命中,但是为StringUtils.EMPTY,直接返回null"); return null; } log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87fb4c495ffb3a0a884b9cf6642ed426/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a57cc250be4bef4bba8e7c31c87fe67/" rel="bookmark">
			Spring boot连接Redis服务器报Unable to connect to Redis问题分析与解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.Unable to connect to Redis：翻译：无法连接到Redis
很明显是Redis服务未被连接
比如我这个，是因为打连接不上本地端口：6379。
呢么就有两种可能：
1.查看Spring boot的yml文件，看是否连接的是6379端口
如下：
没问题是 本地的6379，呢么就只有一种情况是因为本地的服务没打开。
打开Redis服务
正确开启服务如何重新启动Spring boot项目，就ok喽！
总结一下，这是Redis新手常见的一种问题，个人觉得主要是因为马虎粗心造成的，哈哈哈，恰恰我就遇见了！这就是我今天的分享解决问题方案。有问题可以私聊或留言。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82f16b6394dad3118840dca97d890e5d/" rel="bookmark">
			ZoKrates&#43;Remix在线实现zkSNARK零知识证明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：在之前的文章里，我介绍了利用circom和snarkjs实现zkSNARK零知识证明，包含了snarkjs的使用步骤，并且我的毕业论文也全部采用snarkjs实现zkSNARK算法。
不过snarkjs里的signal信号的概念和高级语言变量之间的差别有点大，很多运算操作都不能直接进行，而且在执行circom库里的SHA256哈希算法时需要调整powersOfTau可信设置（snarkjs ptn bn128 10 powersOfTau10_0000.ptau，修改10为更大值），只能采用snark友好的MiMC哈希算法。于是我开始探索其他zkSNARK工具。
有些报告指出，snarkjs、libsnark和ZoKrates号称三大最常用的zkSNARKs零知识开发库。经过测试发现ZoKrates在编写代码的过程中更接近高级语言，算术电路的输入输出都是以变量的形式，天然支持comparator数值比较，更易实现零知识范围证明（Zero-Knowledge Range Proof，ZKRP），而且ZoKrates支持log输出利于debug。此外，ZoKrates实现了Remix插件，也就可以在线运行zkSNARK算术电路，特此记录下ZoKrates+Remix在线实现zkSNARK零知识证明的步骤。
ZoKrates是以太坊上zkSNARKs的工具箱。它可以帮助您在DApp中使用可验证的计算，从高级语言的程序规范到生成计算证明，再到在Solidity中验证这些证明。（ZoKrates官网介绍）
Remix官网：https://remix.ethereum.org/
1.安装插件 点击左下角的插件按钮，找到ZOKRATES插件，点击Activate激活插件：
2.编写zkSNARK算术电路 新建文件命名为main.zok，输入如下代码：
def main(private u8 p, private u8 q, u8 n) -&gt; bool { return p * q == n; } 2.1代码解释 两个隐私输入p和q、一个公开输入n，u8代表8位无符号整型，返回bool类型。
根据“大整数质因子分解”是NP困难问题（Nondeterministic polynomial-time，非确定性多项式时间），给定两个素数p和q，他们的乘积是n，但是如果只提供这个数字n，找出n的两个素因子是困难的。
根据这个难题，利用zkSNARK向外界证明自己“知道n的两个素因子”，但是不向外界泄露p和q的真实值。因此，zkSNARK的隐私输入是p和q、公开输入是n、算术电路是p*q==n。
2.2在线测试 ZoKrates提供了在线编译算术电路的测试环境，进入官网https://play.zokrat.es：
3.编译与测试 进入ZOKRATES插件，点击compile编译：
输入错误样例进行测试，p=3、q=7、n=22，输出是false：
输入正确样例进行测试，p=3、q=7、n=21，输出是true：
4.初始化密钥verification_key.json 点击Run Setup进行初始化，得到verification_key.json作为验证密钥：
5.生成证明proof.json 点击Generate，生成proof.json：
复制Verifier inputs备用：
[["0x1dc9038012cef119c740a52bffc3280d6ed125bbd9bfc474bcca78dd982a901d","0x0fa4945211306b5d0a50bbc80e5def88fe1224b927fcace75d725384d31755f9"],[["0x15ae9c563fcfcb4cdf74780bbefd44bd54e6be9222170bd907bd962f0928c103","0x27ad25d6aa4089fd27622e8f17524b3bb05ffa67d2c099a1f880d69357a0b168"],["0x297ea2971f2296ba60e9e4fe3b9535455e9130e14a0c973f584deec0437448d2","0x05484d4637c39f5b7eadf920686d3290f4f5dfeae3ae7d486a9f753521cc12c5"]],["0x0760832bd07407205278074a131c8e67de0e90f8e45f6ac43c083ffa44873b34","0x014b52710266031a08b23d556f0ca1c64b4b579db8f6e0c4720ffe649bbd3bf9"]],["0x0000000000000000000000000000000000000000000000000000000000000015","0x0000000000000000000000000000000000000000000000000000000000000001"]
0x0000000000000000000000000000000000000000000000000000000000000015对应十进制的21，就是zkSNARK的公开输入n。
6.导出验证合约verifier.sol 点击Export，生成verifier.sol智能合约： 7.编译并部署验证合约verifier.sol 点击Compile verifier.sol编译：
选择verifier.sol，点击Deploy部署：
8.运行验证合约 在Deployed Contracts里选择VERIFIER，在verifyTX函数的输入框里填写刚才复制备用的Verifier inputs，点击verifyTX。
右下角log出现了函数执行结果，input是21，输出true：
将verifyTX的input里的21改成22，即十六进制0x0000000000000000000000000000000000000000000000000000000000000016，再测试一下，输出false：
9.结语 至此便实现了大整数质因子分解的零知识证明，p和q是隐私输入，仅在生成证明的过程由证明者知道，n是公开输入，可以输入到公开的智能合约，智能合约自动验证零知识证明的有效性，并且修改n之后能检测出零知识证明已失效。
ZoKrates也有离线的命令行版本，结合Remix在线自动部署与运行较为方便，适合部署前测试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ee615cda85faf978cf406ed36bf8a0/" rel="bookmark">
			谈谈我了解的测试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谈谈我了解的测试工具 一、测试管理工具 1、Jira
特点：基于Java 架构的管理系统，简单好用，开源。
jira 是Atlassian公司出品的项目与事务跟踪工具，被广泛应用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理等工作领域，其配置灵活、功能全面、部署简单、扩展丰富。
2、git
特点：免费开源，是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。
二、接口测试工具 1、Jmeter
特点：开源，免费，能够加载和测试许多不同的应用程序/服务器/协议类型。
JMeter 可对服务器、网络或对象模拟巨大的负载，在不同压力类别下测试它们的强度和分析整体性能。
2、postman
特点：使用简单，无需搭建环境，可以保存接口请求的历史记录。
Postman 是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件，提供功能强大的 Web API &amp; HTTP 请求调试。它能够发送任何类型的HTTP 请求 ，附带任何数量的参数+ headers。
三、性能测试工具 1、loadrunner
特点：不开源，收费，平台大，功能全，要学精通还是有一定的难度。
LoadRunner是一种预测系统行为和性能的负载测试工具，通过模拟实际用户的操作行为进行实时性能监测，来帮助测试人员更快的查找和发现问题。LoadRunner适用于各种体系架构，能支持广泛的协议和技术，为测试提供特殊的解决方案。企业通过LoadRunner能最大限度地缩短测试时间，优化性能并加速应用系统的发布周期。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f974d324b600910995044c440a7e7b5d/" rel="bookmark">
			ubuntu22.04安装nvidia驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu22.04安装nvidia驱动 环境前言？直通显卡ubuntu2204虚拟机配置禁用默认显卡驱动安装显卡驱动查看显卡状态参考文章 环境 ESXi-7.0U3l
ubuntu22.04
前言 在第一次成功之后，重启了虚拟机，失败了很多次，重装了n次系统和驱动，但是发现在windows下好用，linux下不行，记录一下成功的配置
？ 这个方案对我的环境就是失败的，已经改用直通win10，并且完美配置好环境，可惜windows下的docker没有linux下好用，但是能用
直通显卡 开启vtd这部分可以根据自己的主板情况自行搜索，、
在esxi中点主机-&gt;管理-&gt;pci设备 筛选支持直通 选择需要直通的网卡，点击切换直通即可，不需要重启esxi
ubuntu2204虚拟机配置 最开始使用的bios引导，成功一次后就没有在成功过，后续重装系统均使用efi引导
在虚拟机上点编辑 虚拟机选项 高级 编辑配置 将svga.present由TRUE改为FALSE，保存并启动虚拟机
禁用默认显卡驱动 touch /etc/modprobe.d/blacklist-nvidia-nouveau.conf 在文件的尾部追加两行
blacklist nouveau options nouveau modeset=0 touch /etc/modprobe.d/nvidia.conf 在文件的尾部追加
options nvidia NVreg_OpenRmEnableUnsupportedGpus=1 rmmod nouveau 安装显卡驱动 ubuntu-drivers autoinstall 查看显卡状态 nvidia-smi 你以为这样就成功了？nonono
重启之后又失败了，但是已经证明不是驱动和vm配置的问题
参考文章 https://zhuanlan.zhihu.com/p/337013545
https://blog.csdn.net/lixushi/article/details/118575942
https://forums.developer.nvidia.com/t/nvidia-smi-no-devices-were-found-vmware-esxi-ubuntu-server-20-04-03-with-rtx3070/202904/19
https://forums.developer.nvidia.com/t/nvidia-smi-no-devices-were-found-vmware-esxi-ubuntu-server-20-04-03-with-rtx3070/202904/43
https://blog.csdn.net/aoeii/article/details/125834294
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0138ee1fd19da99ed49fb51f700579e0/" rel="bookmark">
			scanf读入整形(int), 字符(char), 字符串的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.scanf读入整形 (int) 代码: scanf("%d %d %d", &amp;a, &amp;b, &amp;c); 输入: 1 2 3 %d之间也可以不加空格 代码: scanf("%d%d%d", &amp;a, &amp;b, &amp;c); 输入: 1 2 3 因为：读入的是数字(不是字符)，scanf()在读入数字时会忽略 空格(字符) 和 换行符
实际输入: 1(空格)2(空格)3(空格)(换行) 但是：如果scanf 读入的是 字符 就会把空格，换行，当成一个字符
2.scanf读入字符(char) 先看一段代码
#include &lt;stdio.h&gt; int main() { char input = 0; while (scanf("%c", &amp;input) != EOF) { if (('A' &lt;= input &amp;&amp; 'Z' &gt;= input) || ('a' &lt;= input &amp;&amp; 'z' &gt;= input)) { printf("%c is an alphabet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0138ee1fd19da99ed49fb51f700579e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f33b83a9ac7608fc7cea5cdc784220c1/" rel="bookmark">
			docker-compose 端口映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker Compose 是一个用于定义和运行多个 Docker 容器的工具。在 Docker Compose 中，可以通过设置端口映射来将容器内部的端口映射到主机上的端口。
例如，以下是一个使用 Docker Compose 启动一个 WordPress 和 MySQL 容器的示例：
version: '3' ​ services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: wordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress ​ wordpress: depends_on: - db image: wordpress:latest ports: - "8000:80" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress ​ volumes: db_data: 在这个示例中，MySQL 容器的端口没有被映射到主机上，而 WordPress 容器的端口则被映射到了主机的 8000 端口。
因此，当使用 Docker Compose 启动这个应用时，可以通过访问 http://localhost:8000 来访问 WordPress 应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0c007d73879b1e3048a1ed62febed17/" rel="bookmark">
			docker-compose 挂载目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker Compose可以使用volumes关键字来挂载目录，将宿主机的目录或文件映射到容器中。
语法：
volumes: - &lt;宿主机目录&gt;:&lt;容器目录&gt; 其中，&lt;宿主机目录&gt;为需要映射的宿主机目录路径，可以是相对路径或绝对路径；&lt;容器目录&gt;为容器内挂载的目标路径，也可以是相对路径或绝对路径。
示例：
挂载宿主机当前目录到容器的/app目录下：
version: "3" services: web: image: nginx volumes: - .:/app 在上述示例中，web服务使用了Nginx镜像，同时将当前目录（即docker-compose.yml所在目录）映射到了容器中的/app目录。此时，/app目录就可以读写宿主机当前目录的文件了。
注意，在Windows系统中，由于文件系统不同，需要使用绝对路径来进行挂载。例如：
version: "3" services: web: image: nginx volumes: - C:\Users\myuser\project:/app 以上示例将本地C:\Users\myuser\project目录映射到容器的/app目录中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/769d8188eb3716d52c3946e6f33afb8a/" rel="bookmark">
			mysql 根据一个表创建另一个表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以使用以下语法来根据一个表创建另一个表：
CREATE TABLE new_table_name AS SELECT * FROM old_table_name; 这将会复制旧表中的所有行和列到新表中。可以在创建新表时增加筛选条件或者修改列名，以便根据需求进行定制化操作。
例如，下面的语句将创建一个名为 new_table 的新表，并从 old_table 中只选择 id、name 和 age 这三个列：
CREATE TABLE new_table AS SELECT id, name, age FROM old_table; 注意，在使用此方法创建新表时，需要确保原始表中的数据类型和约束已经适用于新表。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9af4eb06dc71ce712f298d5b5e91d9f/" rel="bookmark">
			诱导契合对接（Induced Fit Docking）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		诱导契合对接（Induced Fit Docking） 在半柔性对接中，配体的构象允许发生一定变化。在柔性对接中，受体和配体构象均可发生变化。
打开薛定谔软件中的Induced Fit Docking模块做柔性对接，格点文件会自动生成，此处省去配体准备，以1IEP为例。
柔性对接一般用于精确考虑分子间的识别情况。由于计算过程中体系的构象可以变化，所以计算耗费最大。相比半柔性对接，Nilotinib配体的对接打分在柔性对接中偏高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2e4b8c3b8588c92a81a46f8028f5a1b/" rel="bookmark">
			导入和导出的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. commonJS 导出和导入 设置好方法 使用 module.exports 进行导出
function fn(fun) { console.log(`这是一个${fun}函数`); } const jian = (j) =&gt; { console.log(`这是一个${j}函数`); }; module.exports = { fn: fn, jian: jian, }; 在vue文件里面使用 let log = require('../utils/commonjs') 进行导出赋值使用
&lt;template&gt; &lt;div&gt; &lt;button @click="clickFn"&gt;click&lt;/button&gt; &lt;button @click="clickJian"&gt;click&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; let log = require('../utils/commonjs') export default { data() { return { } }, methods: { clickFn() { log.fn('fn') }, clickJian() { log.jian('jian') } } } &lt;/script&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2e4b8c3b8588c92a81a46f8028f5a1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa1b4204ae0ce59d04222010b70fa596/" rel="bookmark">
			MySQL的检查点checkpoint是干什么的？底层原理是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL的检查点（Checkpoint）是一种用于将内存中的数据持久化到磁盘上的机制。当MySQL运行时，所有的数据都首先保存在内存中，因为内存的读写速度比磁盘快得多。但是，内存中的数据是不稳定的，如果MySQL突然崩溃，所有的内存数据都将丢失，导致数据丢失或数据不一致。因此，需要将内存中的数据定期持久化到磁盘上，以保证数据的安全性和一致性。
检查点机制的基本原理是在一定的时间间隔内，将内存中的数据写入磁盘。当MySQL启动时，会从磁盘中加载之前保存的数据文件，然后将数据加载到内存中进行操作。在MySQL运行过程中，每当达到一定的条件时，就会触发一个检查点操作，将内存中的数据写入磁盘。
具体实现上，MySQL会将内存中的数据写入redo log，然后将redo log中的数据写入到磁盘上的数据文件中。redo log是MySQL用来记录事务操作的日志文件，当MySQL崩溃或重启时，可以使用redo log进行恢复。MySQL会将redo log定期写入磁盘，以确保数据的持久化。
除了定期检查点之外，MySQL还有一些其他机制来保证数据的一致性和安全性，例如InnoDB存储引擎中的Double Write Buffer、页清理（Page Cleaner）等机制。这些机制都是为了保证MySQL的高可用性和数据安全性而设计的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f8afc99f03d3426e27757b4d3e62b2/" rel="bookmark">
			怎么设计一个秒杀系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、系统部署 秒杀系统部署要单独区别开其他系统单独部署，这个系统的流量肯定很大，单独部署。数据库也要单独用一个部署的数据库或者集群，防止高并发导致整个网站不可用。
2、防止超卖 100个库存，1000个人买，要保证不会超卖
防止超卖要保证原子性，判断库存名额是否充足和减少库存扣减成功放到一个lua脚本里面
3、限流 防止机器一直点
IP限流：IP限流的实现方法是根据请求IP地址来进行限制。具体做法是在服务器端记录每个IP地址的请求次数，当请求次数超过设定的阈值时，就拒绝该IP地址的请求。可以使用分布式缓存技术如Redis来记录每个IP的请求次数，并设置定时清除缓存的策略，以保证数据的准确性和实时性。
请求频率限制：实现方法是根据一定时间内的请求次数来进行限制。具体做法是在服务器端记录每个用户请求的时间，并对请求进行计数，当请求次数超过设定的阈值时，就拒绝该用户的请求。可以使用令牌桶算法或者漏桶算法来实现请求频率限制，同时也可以使用分布式缓存技术如Redis来记录每个用户的请求时间和请求次数。
4、静态优化 很多用户在活动前会访问静态页面进行刷新，所以要静态分离开
URL唯一化处理，我们在进行静态化资源的时候，对页面静态资源进行提前缓存，保证用户直接接请求URL时候，无需解析请求头，无需重组HTTP协议，可以直接找到静态资源返回，不与后端做数据交互，一般静态资源我们放到CDN上，CDN就近原则可提高我们的响应速度和命中率，同时cdn开启资源压缩，减少传输数据量。
5、降级 降级就是系统容量达到一定程度时，限制或关闭系统的某些非核心功能，从而把资源保留给更核心的业务，例如秒杀下单后给用户增加积分，这个功能不是下单的核心功能，可以先记录一条信息，等后面流量下来后在调用积分系统给用户补上
6、按钮置灰 12点的秒杀，11点59用户猛点，猛发请求也会对服务器性能造成影响，所有我们的秒杀一定是在未达到时间点的时候，不让点，时间点一到，通过前端的定时器来将按钮变更。
7、预热 秒杀读多写少，访问商品人数往往大于购买人数，活动和库存都可以提前预热，数据提前放到redis中，并且redis搭建好集群部署防止缓存击穿。谁知好过期时间逻辑删除策略等
8、流量错峰、防刷 使用各种手段，将流量分担到更大宽裕的时间点，比如用验证码
9、异步下单 使用消息队列来完成异步下单，注意后台经过了校验、限流后流入的都是有效的，队列接收到消息之后异步生成订单，然后订单创建成功之后，入库没有问题的话，可以使用短信或其他方式告知用户秒杀成功，如果失败的话，我们可以引入一些补偿机制进行重试。
10、多级缓存 在传统的缓存架构下，tomcat成为了并发瓶颈
商品详情页是不会经常变动的，这些数据可以提前用多级缓存缓存到nginx本地缓存中，离用户最近的地方，就可以这样设计多级缓存架构来解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad00510691a6734f08a38b5a923a3e84/" rel="bookmark">
			python中Polars库详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python中的Polars库 什么是polars Polars 是一个用于数据处理的 Python 库，提供了类似于 Pandas 的 API，但却更加快速和内存高效。
Polars 能够处理非常大的数据集，并在运行时对其进行快速操作。它具有类似 Pandas 的 API，可以进行诸如筛选、聚合和转换等常见操作。此外，Polars 还提供了一个更加直观和易于使用的 API，可以让你轻松地使用一些复杂的数据处理技术。
常用函数 1.read_csv()
read_csv() 函数用于从 CSV 文件中读取数据，并返回一个 DataFrame 对象。该函数可以接受多种参数，例如文件路径、列分隔符、行分隔符等。
示例代码：
import polars as pl df = pl.read_csv('data.csv') 2.head()
head() 函数用于返回 DataFrame 中的前 n 行数据，默认为 5 行。
示例代码：
import polars as pl df = pl.read_csv('data.csv') print(df.head()) 3.filter()
filter() 函数用于根据指定的条件筛选 DataFrame 中的行数据。
示例代码：
import polars as pl df = pl.read_csv('data.csv') filtered_df = df.filter(pl.col('age') &gt; 18)#找age大于18的数据 print(filtered_df) 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad00510691a6734f08a38b5a923a3e84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67fcc4cbb197c8752b8dd163fe47dc0f/" rel="bookmark">
			成功解决 ImportError: cannot import name ‘Field‘ from ‘torchtext.data‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		待解决问题 import datetime import time from torchtext.data import Field, Dataset, Example, Iterator import copy import torch.nn as nn 当试图导入以上包的时候，出现了报错
13 import datetime 14 import time ---&gt; 15 from torchtext.data import Field, Dataset, Example, Iterator 16 import copy 17 import torch.nn as nn ImportError: cannot import name 'Field' from 'torchtext.data' (/usr/local/lib/python3.9/dist-packages/torchtext/data/__init__.py) 初步尝试 根据网上的教程，尝试命令“!pip install torchtext==0.9.0”
Looking in indexes: https://pypi.org/simple, https://us-python.pkg.dev/colab-wheels/public/simple/ Collecting torchtext==0.9.0 Downloading torchtext-0.9.0-cp39-cp39-manylinux1_x86_64.whl (7.0 MB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 7.0/7.0 MB 64.6 MB/s eta 0:00:00 Collecting torch==1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67fcc4cbb197c8752b8dd163fe47dc0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/981c3454153027ab2d07e02cb0054a4f/" rel="bookmark">
			VSCode &#43; GCC编译器（MinGW）开发环境中文字符乱码问题踩坑与解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题背景问题描述测试代码测试结果现象描述问题分析 解决方案修改默认配置1. 已经存在的文件全部使用gbk编码重新保存。2. 在工程目录下新建`.vscode`目录，如果已存在则跳过此步骤。3. 在`.vscode`目录中新建`settings.json`，`launch.json`两个文件，已有则跳过。4. settings.json文件添加以下内容，使文件全部变成gbk编码：5. launch.json中修改以下内容，使用外置控制台运行编译后程序： 修改后测试代码的运行结果 问题背景 在较长一段时间里，C/C++开发者所使用的集成开发环境（IDE）要么是比较重量级的VS（Visual Studio），要么是Codeblocks·、·Visual C++ 6.0等轻量级IDE，又或者是诸如notepad++、sublime text等文本编辑器+GCC编译器+命令行工具的组合式开发环境。这几种开发方式要么太过庞大比较吃硬件资源，比如VS动辄就要占用几十个G的硬盘空间，要么虽然轻量但是没有友好的代码提示和自动化的编译链接运行过程，开发体验并不是很友好。
近几年来，随着VSCode（Visual Studio Code）的流行，越来越多的开发者选择以此来作为个人的集成开发环境。使用VSCode开发C/C++程序可以下载安装VSCode官方的C/C++ for Visual Studio Code插件实现开发过程中的代码提示、调试、运行等功能，但是需要自行安装C/C++编译器，笔者是用的是GCC编译器MinGW。具体开发环境的搭建过程在此不作讲解，本文关注点在于开发过程中遇到的中文字符相关的乱码问题。
问题描述 测试代码 英文字符串文本文件 es_src.txt Chinese 中文字符串文本文件 ch_src.txt 中文 main.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { char str_es[] = "Chinese"; char str_ch[] = "中文"; char str[30]; // 读英文字符串的文本文件测试 printf("读文件测试：\n"); FILE *fpr_es = fopen("es_src.txt", "r"); while (fgets(str, 30, fpr_es) != NULL) { printf("strcmp(%s, %s)=%d\n", str_es, str, strcmp(str_es, str)); } fclose(fpr_es); // 直接打印含中文字符串测试 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/981c3454153027ab2d07e02cb0054a4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23162c8c35acb09459c7424ba02be6bb/" rel="bookmark">
			Qt中 qtabwidget用法示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先创建了一个窗口，并在窗口中添加了一个QTabWidget。QTabWidget有三个标签页，每个标签页都是一个QWidget。在第一个标签页中，还创建了一个QPushButton作为子部件，并将其放置在标签页的中央。运行程序后，你应该可以看到一个带有三个标签页和一个按钮的窗口。
下面是一个简单的使用QTabWidget的示例：
#include &lt;QtGui&gt; ​ int main(int argc, char *argv[]) { QApplication app(argc, argv); ​ // 创建一个QWidget作为整个窗口的容器 QWidget window; ​ // 创建一个QTabWidget作为主部件 QTabWidget tabWidget(&amp;window); // 创建三个QWidget作为标签页的子部件 QWidget *tab1 = new QWidget(); QWidget *tab2 = new QWidget(); QWidget *tab3 = new QWidget(); ​ // 将这些子部件添加到QTabWidget中，并设置每个标签页的标题 tabWidget.addTab(tab1, "Tab 1"); tabWidget.addTab(tab2, "Tab 2"); tabWidget.addTab(tab3, "Tab 3"); ​ // 在第一个标签页中创建一个QPushButton QPushButton *button = new QPushButton("Hello World", tab1); ​ // 将按钮放在标签页的中央 button-&gt;setGeometry(QRect(QPoint(100, 100), QSize(200, 50))); ​ // 显示窗口 window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23162c8c35acb09459c7424ba02be6bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9f00729ba0c5fc4219a26c388b50840/" rel="bookmark">
			docker 容器怎么打成镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将 Docker 容器打包成镜像通常有两种方法：使用 docker commit 命令或者编写一个 Dockerfile 文件。
使用 docker commit 命令
首先，需要运行容器并在其中进行修改（例如安装新的软件或更改配置）。然后，可以使用以下命令将容器保存为镜像：
docker commit [OPTIONS] CONTAINER NEW_IMAGE[:TAG] 其中，CONTAINER 是要打包为镜像的容器 ID 或者名称，NEW_IMAGE 是要创建的新镜像的名称，可以带上可选的 tag。例如：
docker commit mycontainer myimage:latest 这个命令会将容器 mycontainer 打包成一个名为 myimage 的新镜像，并且标记为 latest。
使用 Dockerfile 文件
Dockerfile 是一个文本文件，其中包含了构建 Docker 镜像所需的一系列步骤和指令。通过编写 Dockerfile 文件，可以自动化整个构建过程，从而更方便地管理和维护镜像。
下面是一个简单的 Dockerfile 示例：
FROM ubuntu:latest RUN apt-get update &amp;&amp; apt-get install -y nginx EXPOSE 80 CMD ["nginx", "-g", "daemon off;"] 这个 Dockerfile 文件告诉 Docker 它应该基于最新的 Ubuntu 镜像构建一个新镜像。然后，它会更新系统并安装 Nginx Web 服务器。接着，它会将容器的 80 端口暴露出来，并设置 CMD 命令以在镜像启动时启动 Nginx。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9f00729ba0c5fc4219a26c388b50840/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764cb510b171fc938d3346988d081725/" rel="bookmark">
			深度森林gcForest的原理及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 gcForest基本原理1 级联森林2 多粒度扫描多粒度扫描具体过程 3 gcForest挑战 代码实现 gcForest基本原理 周志华教授团队认为模型复杂度并不是DNN成功的关键，而逐层处理才是DNN成功的关键因素。提升集成算法及其决策树模型只是在数据的原始特征上做处理，没有对模型内的特征做特征变换，且只有有限的模型复杂度。因此，他们推测深度模型成功的三个因素为逐层处理、特征变换和巨大的模型复杂度。
gcForest受逐层处理的启发，采用级联结构，并采用不同种类的树提高模型的多样性。下面详细介绍gcForest的基本原理。
1 级联森林 可将级联结构理解为类似神经网络，它对原始数据进行逐层处理，每个级联层都将上一层的输出作为输入，并将处理的信息输出到下一层。级联森林如下图所示。
完全随机森林由若干棵CART决策树构成，森林中每棵树分裂时随机选取一个属性作为当前节点的最优分裂属性。一直生长到每个叶子节点只包含一个类别或者每个叶子节点包含的类别数低于参数指定的最小样本划分数目。
普通随机森林也由若干CART决策树构成，森林中每棵树分裂时先随机选取一个大小为sqrt(m)的候选属性集（m表示特征属性的个数），然后在候选属性集中选择最优的分裂属性（分类问题计算基尼指数，回归问题计算均方差）。
两者的不同在于完全随机森林是在完整的特征空间随机选取特征来分裂，而普通随机森林在特征空间的一个子空间根据基尼指数或者均方差选取最优分类属性。
决策树其实是在特征空间中不断划分子空间，并且给每个子空间打上标签（分类问题就是一个类别，回归问题就是一个目标值），例如一条测试样本，每棵树会根据样本所在子空间的训练样本的类别占比生成一个类别的概率分布，然后对森林内所有树的各类别比例取平均，输出整个森林中各类别的比例。
一层结果输出之后，会用此模型来对一个检验即进行评估，若得到的结果准确率或者误差达到了可接受的阈值，训练就会终止。这个操作非常关键，相当于自动决定了层数，对模型复杂度的自适应调节使得gcForest能够可伸缩的应用于不同规模的数据集上。
2 多粒度扫描 gcForest的多粒度扫描类似于CNN和RNN的采样窗口，增强了模型的特征提取能力。
多粒度扫描具体过程 首先输入一个P维样本，然后通过一个长度为k的采样窗口进行滑动采样，设定滑动步长s，得到N=(P-k)/s+1个K维的特征子样本向量。每个子样本都用于所有的随机森林训练，并且每个森林都会获得一个长度为C的概率向量（C为类别数），这样一个森林就能获得一个N*C的表征向量。最后把每层的F个森林的结果拼接在一起得到本层输出。上述描述了一种滑动窗口大小的扫描过程，实际上可以利用多种大小的滑动窗口进行采样，这样会获得更多的特征子样本，真正达到“多粒度”扫描的。
3 gcForest挑战 由于深度森林不能像深度学习那样使用GPU进行加速，树结构难以像矩阵操作一样在GPU上运行，所以任务的规模很大程度上限制了深度森林的表现。周志华教授对gcForest的发展现状表示：需要克服的问题还有很多，不过所有这些付出都是值得的。因为“没有免费的午餐”，没有哪个学习模型永远是最好的，尽管深度神经网络很成功，但我们还是要继续探索其他类型的模型。我们猜测深度神经网络确实是适用于数值建模问题的，但当你面对的是符号化、离散、表格数据时，深度森林可以做的更好。
代码实现 # -*- coding: utf-8 -*- from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score from deepforest import CascadeForestRegressor import pandas as pd import numpy as np # 载入训练数据集 train_path = input('请输入训练数据集路径（含文件名）：') data = pd.read_csv(train_path, encoding='utf-8') x = data.iloc[:, :5].values y = data.iloc[:, 6:7].values # 深度随机森林模型 model = CascadeForestRegressor() # 模型训练 model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/764cb510b171fc938d3346988d081725/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8696a96dbc4c6c285a4497ae4e6f6ec/" rel="bookmark">
			图像处理与分析（一）图像处理与图像滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 绪论模拟图像和数字图像数字图像相关概念 图像处理图像增强空间域和频率域灰度直方图对比度变换法线性变换分段线性变换非线性变换 直方图修整法直方图均衡化直方图规定化(直方图匹配) 图像滤波平滑滤波超限像素平滑灰度最相近的K个邻点平均法结构相近的相似像素平均法引导图滤波器 锐化滤波 绪论 模拟图像和数字图像 数字图像相关概念 图像数字化是在成像过程中把图像分割成一个个小区（像素或像元），并将各个小区亮度用整数来表示。
灰度级数。
灰度图像。灰度图像是指每个像素由一个灰度值来描述的图像，没有彩色信息。
彩色图像。彩色图像是指每个像素由**红、绿、蓝（R、G、B）**三原色构成的图像，R、G、B由不同灰度来描述。
图像处理 具体而言，数字图像处理的内容包括：图像数字化、图像变换、图像增强、图像的恢复与重建、图像编码、图像分割、二值图像处理与形状分析、纹理分析以及图像识别等。
图像增强 图像增强是指采用一系列技术去改善图像的视觉效果，或者将图像转换为一种更适合于人或机器进行分析和处理的形式。
空间域和频率域 空间域增强是指直接对图像各个像素进行处理；
频率域增强是对图像经傅里叶变换后的频谱成分进行处理，然后逆傅里叶变换获得所需的图像；
灰度直方图 ni表示灰度值等于i的像素的个数
若一幅图的像素倾向于占据整个可能的灰度级数并且分布均匀，则该图像会有高对比度的视觉效果，其色调变化较大。
对比度变换法 对比度是指图像中最大亮度与最小亮度的比值。
对比度变换是通过改变图像像素的亮度值来改变图像的对比度。扩大图像灰度的范围。
线性变换 将图像的灰度范围从[a,b]拉伸到[a’,b’]
分段线性变换 突出感兴趣目标所在的灰度区间，抑制不感兴趣的灰度区间。假设感兴趣目标的灰度范围为[a,b]，则将该区域灰度范围进行拉伸，具体示意如下：
非线性变换 与线性变换类似，只不过使用非线性函数来实现灰度图的非线性变换。
对数变换。对数变换可以扩展图像中暗像素的值，压缩更高灰度级的值。
指数变换。指数变换可以扩展图片中亮像素的值，压缩更低灰度级的值。
直方图修整法 直方图均衡化 直方图均衡化是指将原图像通过某组变换，得到一副灰度直方图为均匀分布的新图像的方法。
直方图规定化(直方图匹配) 直方图规定化是指使原图像灰度直方图变成规定形状的直方图而对图像作修正的增强方法。
局部直方图匹配
图像滤波 图像滤波是指图像借助掩膜进行卷积操作。
图像滤波分为平滑和锐化两种处理。
平滑滤波 为了抑制噪声改善图像质量所进行的处理称为图像平滑或去噪。
掩膜矩阵=滤波器核、窗口
滤波=卷积
选择的掩膜不同，中心点或邻域的重要程度也不相同，需根据实际问题进行选取。
为克服简单局部平均法的弊病，目前已提出许多保边缘、细节的局部平滑算法。它们的出发点都集中在如何选择领域的大小、参加平均的点数以及邻域各点的权重系数等。
超限像素平滑 对领域平均法稍加改进，可导出超限像素平滑法。
该算法对抑制椒盐噪声比较有效，对保护仅有微小灰度差的细节及纹理也有效。随邻域的增大，去噪能力增强，但模糊程度也更大。
灰度最相近的K个邻点平均法 在n*n的窗口内，属于同一类型的像素，它们的灰度值高度相关。因此，可在窗口内与中心像素的灰度值最接近的K个邻像素的平均灰度来代替窗口中心像素的灰度值。该方法适用于高斯噪声。较小的K值使噪声方差下降较小，但保持细节效果较好；而较大的K值平滑噪声效果好，但会使图像边缘模糊。
结构相近的相似像素平均法 引导图滤波器 引导图滤波器是一种自适应权重滤波器，能够在平滑图像的同时起到保持边界的作用。
这样处于平坦区域的像素则会被加以较大的权重，平滑效果更明显；而处于边界两侧的像素则会被加以较小的权重，平滑效果较弱，能起到保持边界的效果。
锐化滤波 在图像的识别中通常需要突出边缘和轮廓信息。图像锐化就是增强图像的边缘和轮廓。
常见的锐化算子有:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcc81cbf9ddfb66f4bc4f0fb866df146/" rel="bookmark">
			图像处理与分析（二）傅里叶变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 傅里叶变换时域与频域为什么做傅里叶变换傅里叶变换的作用信号分解.去噪 二维傅里叶变换二维与一维傅里叶变换的关系二维傅里叶变换应用 傅里叶变换 从数学上讲，傅里叶变换将任意的周期函数分解成无穷个正余弦函数和的形式；
从物理意义上讲，傅里叶变换就是指将信号从空间域转换到频率域；
从信号分析来看，傅里叶变换将杂乱的信号从时域转换的频域，将信号分解成多个正余弦波的叠加；
时域与频域 这是两种完全不同的看信号的角度
从时域看是变化的（波的传递），从频域看是静止的（波的频率）
为什么做傅里叶变换 任何周期信号都可以看作是：不同振幅，不同相位的正弦波/余弦波的叠加。做傅里叶变换的原因是因为其强大的拆分能力。
傅里叶级数：
傅里叶级数的合成：
傅里叶级数的分解：
傅里叶级数分解后，从不同视角看，可以看到时域和频域影像。
复杂信号经过分解后，变得简单，更好分析。
傅里叶变换的作用 基于其强大的拆分能力进行信号分解，用于信号分析以及信号去噪等。
信号分解.去噪 卷积定理
二维傅里叶变换 二维与一维傅里叶变换的关系 二维傅里叶变换=两次一维傅里叶变换
二维傅里叶变换应用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b3dd15e22b4aa826208e992a57ff312/" rel="bookmark">
			Java面试技巧之每天一个Tip——Redis持久化方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis持久化方式的问题，可能是被问到最多的有关Redis的问题了，几乎一提到Redis这个主题，肯定是要被问到这个问题的，所以大家应该好好准备。
当然，还是简单的Tips，简单直接地回答：
两种方式：RDB和AOF。
这里不要等着面试官问，继续往下答，解释下两种方式的内涵就好，完整地答完是什么的问题。
RDB，指定时间的数据快照（dump.rdb文件），从内存复制到磁盘，等到Redis重启的时候加载使用。
AOF，将每条写入命令通过追加的方式插入日志文件，等到Redis重启的时候，通过回放命令进行恢复。
答到这里，基本就答清楚了「是什么」的问题了。
扩展性问题：
1、RDB是如何进行持久化的？
答：save和bgsave方式，save方式由于会阻塞Redis服务器，非开发环境已经不推荐使用了，一般使用bgsave命令。
bgsave的流程是：
向服务器发送bgsave命令；系统调用fork函数，fork一个子进程；子进程创建rdb文件，从内存拷贝快照数据到磁盘上的rdb文件中；子进程负责将旧的rdb文件替换成新的；通知redis服务端完成状态； 2、RDB和AOF的优缺点比较？
RDB可以指定压缩成二进制文件，节省空间，效率高；适合需要全量备份的应用场景，并且可以方便地进行灾备传输；RDB恢复数据要比AOF快。
但是，RDB会造成数据丢失，fork子进程会丧失一些性能，不同版本Redis的rdb文件格式不统一，产生兼容问题。
AOF可以通过设置fsync策略（默认是每秒）进行及时追加，最多丢失1秒内的数据。AOF具有重写极致，会合并重复的命令，只保留最新的；性能损耗要比RDB模式大（即时备份的代价），日志文件体积更大，恢复速度较慢。
3、RDB和AOF模式同时开启会如何？
注意，RDB是默认开启的，AOF默认不开启。
redis4.0版本之前，即使两种方式同时开启，redis服务器恢复时也只会使用AOF的文件来进行恢复，rdb文件根本不用。
redis4.0版本之后，两种方式同时开启，RDB会将二进制快照数据写入aof文件！AOF的命令会追加到rdb文件内容之后，结果就是前半部分是rdb数据，后半部分是aof的命令。
这样，恢复的时候，二进制数据先加载进内存，后面再执行剩余的aof命令，这时候要执行的aof命令肯定要比只使用aof模式更少。
二者完美结合～
追加清单：
这里的追加问题清单就太多了，可以列一下，有关普通hash、一致性hash、hash槽的内容后面准备单独一篇文章给大家讲，敬请期待～
Redis哨兵模式的原理； Redis-Cluster模式的原理； 为什么Redis用hash槽来解决数据分配的问题？ hash槽为什么是16384？具体是如何做的数据分配？ 说说Redis的缓存问题？缓存穿透、缓存击穿和缓存雪崩的区别，以及你遇到的应用场景是什么？ Redis如何实现互斥锁？ 你使用过哪些Redis客户端？ 这里提到了锁——这就意味着问题可以无限扩展了……
好了，大家周末愉快，就写到这里吧，下次说点别的，😁
～以上为本人原创，请尊重知识产权，不接受任何抄袭、演绎和未经注明出处的转载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33e483895d47f1ec2a330aec2c762ef0/" rel="bookmark">
			Android默认时区、语言设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间
&lt;timezone id="Pacific/Majuro"&gt;马朱罗&lt;/timezone&gt;
&lt;timezone id="Pacific/Midway"&gt;中途岛&lt;/timezone&gt;
&lt;timezone id="Pacific/Honolulu"&gt;檀香山&lt;/timezone&gt;
&lt;timezone id="America/Anchorage"&gt;安克雷奇&lt;/timezone&gt;
&lt;timezone id="America/Los_Angeles"&gt;美国太平洋时间 (洛杉矶)&lt;/timezone&gt;
&lt;timezone id="America/Tijuana"&gt;美国太平洋时间 (提华纳)&lt;/timezone&gt;
&lt;timezone id="America/Phoenix"&gt;美国山区时间 (凤凰城)&lt;/timezone&gt;
&lt;timezone id="America/Chihuahua"&gt;奇瓦瓦&lt;/timezone&gt;
&lt;timezone id="America/Denver"&gt;美国山区时间 (丹佛)&lt;/timezone&gt;
&lt;timezone id="America/Costa_Rica"&gt;美国中部时间 (哥斯达黎加)&lt;/timezone&gt;
&lt;timezone id="America/Chicago"&gt;美国中部时间 (芝加哥)&lt;/timezone&gt;
&lt;timezone id="America/Mexico_City"&gt;美国中部时间 (墨西哥城)&lt;/timezone&gt;
&lt;timezone id="America/Regina"&gt;美国中部时间 (里贾纳)&lt;/timezone&gt;
&lt;timezone id="America/Bogota"&gt;哥伦比亚时间 (波哥大)&lt;/timezone&gt;
&lt;timezone id="America/New_York"&gt;美国东部时间 (纽约)&lt;/timezone&gt;
&lt;timezone id="America/Caracas"&gt;委内瑞拉时间 (加拉加斯)&lt;/timezone&gt;
&lt;timezone id="America/Barbados"&gt;大西洋时间 (巴巴多斯)&lt;/timezone&gt;
&lt;timezone id="America/Manaus"&gt;亚马逊标准时间 (马瑙斯)&lt;/timezone&gt;
&lt;timezone id="America/Santiago"&gt;圣地亚哥&lt;/timezone&gt;
&lt;timezone id="America/St_Johns"&gt;纽芬兰时间 (圣约翰)&lt;/timezone&gt;
&lt;timezone id="America/Sao_Paulo"&gt;圣保罗&lt;/timezone&gt;
&lt;timezone id="America/Argentina/Buenos_Aires"&gt;布宜诺斯艾利斯&lt;/timezone&gt;
&lt;timezone id="America/Godthab"&gt;戈特霍布&lt;/timezone&gt;
&lt;timezone id="America/Montevideo"&gt;乌拉圭时间 (蒙得维的亚)&lt;/timezone&gt;
&lt;timezone id="Atlantic/South_Georgia"&gt;南乔治亚&lt;/timezone&gt;
&lt;timezone id="Atlantic/Azores"&gt;亚述尔群岛&lt;/timezone&gt;
&lt;timezone id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33e483895d47f1ec2a330aec2c762ef0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/166fe092af8f437274d689daf67f7eeb/" rel="bookmark">
			nginx安装配置、动静分离、压缩、缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Nginx环境搭建 1.首先创建Nginx的目录并进入：
[root@localhost]# mkdir /soft &amp;&amp; mkdir /soft/nginx/ [root@localhost]# cd /soft/nginx/ 2.下载解压Nginx的安装包，下载依赖
[root@localhost]#wget https://nginx.org/download/nginx-1.21.6.tar.gz [root@localhost]#tar -xvzf nginx-1.21.6.tar.gz [root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ gcc-c++ [root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ pcre pcre-devel4 [root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ zlib zlib-devel [root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ openssl openssl-devel 执行完成后，然后ls查看目录文件，会看一大堆依赖：
3.紧接着通过rpm命令依次将依赖包一个个构建，或者通过如下指令一键安装所有依赖包：
[root@localhost]# rpm -ivh --nodeps *.rpm 4.进入解压后的nginx目录，然后执行Nginx的配置脚本，为后续的安装提前配置好环境，默认位于/usr/local/nginx/目录下（可自定义目录）：
[root@localhost]# cd nginx-1.21.6 [root@localhost]# ./configure --prefix=/soft/nginx/ 5.编译并安装Nginx：
[root@localhost]# make &amp;&amp; make install 最后回到前面的/soft/nginx/目录，输入ls即可看见安装nginx完成后生成的文件。
6.修改安装后生成的conf目录下的nginx.conf配置文件：
[root@localhost]# vi conf/nginx.conf 修改端口号：listen 80; 修改IP地址：server_name 你当前机器的本地IP(线上配置域名); 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/166fe092af8f437274d689daf67f7eeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a31cca1ddfbfeb3336f818de9b429a8b/" rel="bookmark">
			AI安防视频平台EasyNVR忘记密码无法登录，应该如何重置密码？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EasyNVR安防视频云服务主要功能在于通过RTSP/ONVIF协议，接入前端音视频采集设备，通过平台将拉取过来的音视频流转化成适合全平台播放的RTMP、RTSP、FLV、HLS、Webrtc等视频流格式，方便用户进行网页直播，或接入自身业务平台。
我们在实际项目中，经常有遇到用户反馈说部署了EasyNVR平台后，忘记了密码，导致无法登录。由于这类情况出现的比较多，我们今天就来分享一下，如果忘记了密码，那么应该如何解决平台的登录问题呢？
具体操作步骤如下：
1）修改easynvr.db文件的user表，进行密码重置；
2）修改easynvr.db文件，提示attempt to write a readonly database，这表示数据库权限不够，需要修改easynvr.db文件的权限；
3）将属性【只读】去掉，重新连接数据库，此时即可成功修改密码。
如有用户遇到类似的情况，可以参照以上步骤进行修改。若遇到无法解决的问题，也可以联系我们进行协助排查。
EasyNVR是一款稳定的流媒体服务平台，它可实现设备接入、实时直播、录像、检索与回放、存储、视频分发等视频能力服务，在很多场景中均有落地应用，如智慧工厂、智慧工地、智慧园区、智慧港口等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfc49f8c68cb9e1c3479e1aa2d352ee3/" rel="bookmark">
			Ubuntu操作系统学习路线推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我也算是Ubuntu的初学者，对Linux系统比较感兴趣，学习在Ubuntu下进行网站开发与系统开发。
这是我正在进行的一个学习路线：
1. 学习 Linux 基础知识：首先需要学习 Linux 的基础知识，包括文件系统、进程管理、用户管理、权限管理等。推荐《鸟哥的 Linux 私房菜》。（我认为鸟哥说得很生动，容易理解）
2.掌握 Ubuntu 命令行：Ubuntu 的默认界面是基于命令行的，因此需要掌握常用的命令行操作。推荐《Linux 命令行与 Shell 脚本编程大全》。
3. 学习系统管理技能：学习如何进行系统管理和维护，包括安装、配置、管理软件和服务等。推荐《Ubuntu Server 安装配置与管理》。
4. 学习网络管理技能：学习如何进行网络管理和配置，包括网络设备、网络协议、网络服务等。推荐《TCP/IP 网络编程》。
5. 学习云计算技术：学习如何使用 Ubuntu 进行云计算相关的技术，包括容器化技术、虚拟化技术、集群管理等。可以参考 Docker、Kubernetes、OpenStack 等技术的官方文档和社区论坛。
这些资源在网上都能找到。
希望对你有帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5141509d95f1f731fe0313a29c657d6d/" rel="bookmark">
			Linux内核模块的插入和删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		陈莉君老师Linux内核分析与应用课程，一个helloworld内核模块的插入和删除。
目录
编写helloworld.c
一个内核模块大致架构：
编写Makefile
插入模块指令：
删除模块：
编写helloworld.c 代码如下： #include&lt;unistd.h&gt;//主要对一些系统调用的封装 #include&lt;linux/module.h&gt;//支持内核的模块机制 static int __init lkm_init(void)//__init修饰符，告诉程序只进行初始化，初始化之后释放内存 { printk("Hello World\n");//内核模块编写时不能使用printf，使用对应的printk，两者接口完全一样。 //printk支持消息打印的级别，一般支持八个级别。 return 0; } static void __exit lkm_evit(void) { printk("Goodbye"); } module_init(lkm_init);//模块的入口函数 module_exit(lkm_exit);//模块的出口函数 MODULE_LICENSE("GPL"); 一个内核模块大致架构： 首先包含module.h头文件支持内核的模块机制；
接下来编写入口函数和出口；
引导内核入口点，出口点，和许可证的声明。 编写Makefile 代码如下： obj-m:=helloworld.o #使用目标文件建立一个模块，最终生成模块就是helloworld.ko CURRENT_PATH:=$(shell pwd) LINUX_KERNEL:=$(shell uname -r) #当前的内核版本 LINUX_KERNEL_PATH:=/usr/src/kernels/$(LINUX_KERNEL) #指定内核路径 #为了使makefile文件具有较强的移植性，定义两个路径和一个内核版本 all: make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules #前面用tab而不是空格 #指定内核路径，编译后的文件放在当前目录，最后加上modules表示我们编译的是内核模块 clean: make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean 保存文件名为大写的Makefile。
此处需要安装内核头文件，当前使用的linux系统为CentOS 7。
1.首先使用 uname -r 命令查看当前正在运行的内核版本号，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5141509d95f1f731fe0313a29c657d6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1732feb4b8380c69bbfa190975d2ab5b/" rel="bookmark">
			c&#43;&#43;使用onnxruntime加载模型进行图片去噪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. visual stdio 安装使用onnxruntime
visual stdio 安装onnxruntime，工具-&gt;Nuget包管理-&gt;点管理台后输入如第二张图 PM&gt; xxx, 等下载好后就可以在本项目的目录中看到package文件夹中的onnxruntime了
2. 模型推理代码
首先配置好项目的依赖 属性中配置include和lib，如下二图。再找到onnxruntime.dll copy到项目根目录下。（注不清楚这一步做不做有没有关系，因为后来我发现vs中自己导入了onnxruntime.dll，onnxruntime_providers_shared.dll这两个文件）
代码如下：
c++接口 导出成dll后还依赖源码
void printModelInfo(Ort::Session &amp;session, Ort::AllocatorWithDefaultOptions &amp;allocator) { //输出模型输入节点的数量 size_t num_input_nodes = session.GetInputCount(); size_t num_output_nodes = session.GetOutputCount(); cout &lt;&lt; "Number of input node is:" &lt;&lt; num_input_nodes &lt;&lt; endl; cout &lt;&lt; "Number of output node is:" &lt;&lt; num_output_nodes &lt;&lt; endl; //获取输入输出维度 for (auto i = 0; i &lt; num_input_nodes; i++) { std::vector&lt;int64_t&gt; input_dims = session.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1732feb4b8380c69bbfa190975d2ab5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a5371a3b20cd9c3953301b84f6899c5/" rel="bookmark">
			jackson序列化时传入前端Long类型缺失精度问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无拦截器 因为我们id是Long类型的会存在精度缺失，所以全局转换下
import com.fasterxml.jackson.databind.ser.std.ToStringSerializer; import org.springframework.boot.autoconfigure.jackson.Jackson2ObjectMapperBuilderCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder; /** * @author baoyuankai */ @Configuration public class JacksonConfig { /** * Jackson全局转化long类型为String，解决jackson序列化时传入前端Long类型缺失精度问题 */ @Bean public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() { Jackson2ObjectMapperBuilderCustomizer cunstomizer = new Jackson2ObjectMapperBuilderCustomizer() { @Override public void customize(Jackson2ObjectMapperBuilder jacksonObjectMapperBuilder) { //变成字符串 jacksonObjectMapperBuilder.serializerByType(Long.class, ToStringSerializer.instance); } }; return cunstomizer; } 拦截器 /** * 自定义请求头拦截器，将Header数据封装到线程变量中方便获取 * @author */ @Configuration public class HeaderInterceptor implements AsyncHandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { SecurityContextHolder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a5371a3b20cd9c3953301b84f6899c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf90ad99a663f3911498c3931ef8f16/" rel="bookmark">
			完美的alert美化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认的alert总是在好看的样式下显得格格不入，所以在网上搜寻良久，终于找到了一个完美的美化方案。
一、引入js和css文件
二、js调用替代alert
一、引入js和css文件
1、直接在head引入
&lt;link rel="stylesheet" type="text/css" href="http://css.huangwx.cn/css/sweetalert.css"&gt; &lt;script type="text/javascript" src="http://css.huangwx.cn/js/sweetalert-dev.js"&gt;&lt;/script&gt; 2、下载之后再引入，下载链接在文末。
二、js调用替代alert
直接使用swal()函数替代alert函数即可，同时sweetalert还提供更加多样化的弹出框。
1、标准弹出框
swal("开始这个完美的弹出框旅程吧！") 2、带标题和文本的alert
swal("这是标题！","这是文本") 3、成功的提示，可以带动画效果的哦
swal("这还是标题！","这还是文本","success") 4、带函数传值的alert
swal({ title: "确定删除吗？", text: "你将无法恢复该虚拟文件！", type: "warning", showCancelButton: true, confirmButtonColor: "#DD6B55", confirmButtonText: "确定删除！", cancelButtonText: "取消删除！", closeOnConfirm: false, closeOnCancel: false	}, function(isConfirm){ if (isConfirm) { swal("删除！", "你的虚拟文件已经被删除。", "success"); } else { swal("取消！", "你的虚拟文件是安全的:)", "error"); } }); 5、可以内嵌html代码的alert
swal({ title: "HTML &lt;small&gt;标题&lt;/small&gt;!", text: "自定义&lt;span style='color:#0000FF'&gt;这是蓝色的&lt;span&gt;。", html: true }); 附：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bf90ad99a663f3911498c3931ef8f16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84fa051e14540e6e93b3a33c60bb3497/" rel="bookmark">
			从系统快速进入BIOS，关闭secure boot （win11|详细操作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先需要进入BIOS页面，可以根据主板要求选择关机启动按F12或F2等。本文从Windows系统直接进入。并且不同品牌看到的页面可能不同。
本文目的是关闭secure boot
先看看我的
详细操作如下：
（如果使用按键进入请直接转到第（3）步）
（1）设置—系统—恢复
（2）点击恢复—立即重新启动
（3）进入蓝色页面—点击疑难解答
（4）点击高级选项
（5）点击UEFI固件设置—重启
（6）进入这个界面—进阶设置。（不同电脑可能不同）
（7）建议关闭快速启动，看情况（某些计算机上快速启动对secure boot的修改有影响）
（8）点击安全性—安全启动控制—关闭secure boot
（9）保存与退出
如需要进行其他BIOS修改，操作类似
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91afcdde45d473e3918558e7e1753455/" rel="bookmark">
			【随笔四】JavaScript 中的 rest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		某次开发中，看到项目代码中用到了 rest 这个参数，但又没看到在哪里定义或者传入，当时没太理解它的意思，查了下资料才恍然大悟。含义也很简单，写个随笔记录下。
关键字 rest 的用法（剩余参数） 在 JavaScript 中，函数可以接收任意数量的参数。在大部分情况下，我们只处理函数的固定数量的参数，但有时候，我们无法预先知道函数需要接收多少个参数，这个时候就可以使用 rest （或者也可以使用 args）。
rest 参数是一种特殊类型的参数，它允许我们在函数声明中使用省略号（…）来表示函数可以接收任意数量的参数。
这些参数会被接收到一个数组中，同时，我们可以在该函数体中使用该数组。
语法如下：
function handleSum(...rest) { // ...rest 代表所有传入的参数 console.log(rest) } handleSum(1, 2, 3) // [1, 2, 3] function handleSum(num, ...rest) { // ...rest 代表所有剩余参数 console.log(rest) // [2, 3, 4] console.log(arguments) // [1, 2, 3, 4] } handleSum(1, 2, 3, 4) // [2, 3, 4] 注意： rest 要与 arguments 做好区分。
rest 关键字 指的是剩余参数
arguments 指的是全部参数
其他用法 rest 关键字不止可以用在 函数 的传参中，也可以用于变量中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91afcdde45d473e3918558e7e1753455/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d04eaf9d4449c0129799daea3a357ef/" rel="bookmark">
			linux安装软件 -- jdk,tomcat,mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.软件的安装方式 二进制安装。—只需要解压就可以。 只针对特殊平台。 比如jdk tomcatRPM： 按照一定的规范就可以按照该软件。 无法安装依赖的文件。yum 远程安装 基于RPM 帮你把依赖的文件安装上去。 多安装源码安装。 编译—&gt;打包----&gt;安装。 2 二进制-JDK–Tomcat 安装的是图形化centos --默认安装了jdk 需要把原来默认的jdk卸载
（1）把window中的jdk软件托到centos中并解压
/usr/local/
(2)重命名
这里看个人习惯,也可以不用重命名
(3)配置环境变量
/etc/profile
export JAVA_HOME=/usr/local/jdk1.8 export PATH=$JAVA_HOME/bin:$PATH (4)重新加在profile文件
source /etc/profile
验证:
在任意位置输入javac
3 安装tomcat （1）把tomcat放置到linux并解压
tar -zxvf XXXX.tar.gz
(2)重命名:略
(3)启动tomcat
如何指定tomcat是否启动呢。
ps -ef | grep tomcat —查询进程tomcat
(4)访问tomcat
http://服务器IP:8080
出现上面的错误：
原因: 服务器有防火墙:----而该防火墙没有把8080这个端口号放行。
解决: 第一种关闭防火墙 -----不建议太危险了
​ 第二种解决方案:----放行指定的端口号
systemctl status firewalld 查看防火墙的状态
systemctl stop firewalld 关闭防火墙
关闭后就可以正常显示了
4 安装mysql数据库 4.1 下载wget命令 yum -y install wget
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d04eaf9d4449c0129799daea3a357ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f87f3a7ca345d3cb3ba82207bfc9488/" rel="bookmark">
			Python词云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		词云图wordcloud 1.安装第三方库 j i e b a 库、 m a t p l o t l i b 、 w o r d c l o u d 库 jieba库、matplotlib、wordcloud库 jieba库、matplotlib、wordcloud库
2.过程 1.使用 j i e b a jieba jieba 库对数据进行分词整理，转为 t x t txt txt文件，转变为以空格分隔的词语字符串 s t r i n g string string。
2.调用 w o r d c o l u d wordcolud wordcolud等函数绘制。
英文分词： 对于英文，使用空格来分开每个单词。
中文分词： 中文单独一个汉字跟词有时候就完全不是一个含义，所以中文分词比英文分词要难很多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f87f3a7ca345d3cb3ba82207bfc9488/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/340aa4ea35ac770e606a61359c8617d1/" rel="bookmark">
			Pytorch加载数据dataset时PIL和cv2的异同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用cv2读取并加载数据 使用 OpenCV (cv2) 库来读取图像文件，相对于 PIL.Image，OpenCV 具有更快的读取速度和更强的图像处理功能，尤其适用于图像预处理、增强等操作。
下面是一个使用 OpenCV 读取图像并转换为 PyTorch 张量的例子：
import cv2 import torch class CustomDataset(torch.utils.data.Dataset): def __init__(self, data_dir, transforms=None): self.data_dir = data_dir self.transforms = transforms def __getitem__(self, index): img_name = 'image{}.jpg'.format(index) img_path = os.path.join(self.data_dir, img_name) img = cv2.imread(img_path) # 使用 OpenCV 读取图像 img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # 转换通道顺序为 RGB if self.transforms is not None: img = self.transforms(img) return img def __len__(self): return len(os.listdir(self.data_dir)) 在上述代码中，我们首先通过 cv2.imread() 方法读取指定路径下的图像文件，并将图像像素值按 BGR 顺序存储在 numpy 数组中。接着，使用 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/340aa4ea35ac770e606a61359c8617d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1cb76ee0b12b3a13eaa4532fe5e05ff/" rel="bookmark">
			Mac 安装Java反编译工具JD-GUI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载JD-GUI软件
1.首先到Github下载JD-GUI软件：
github java-decompiler/jd-gui Public
选择jd-gui-osx-1.6.6.tar.
2.解压打开软件，但是提示错误：
3.确保本机已安装JDK.
4.如果确定已经安装了JDK海报这个这个错误，选中JD-GUI,右键显示包内容，找到这个文件：
5.文本编辑器编辑这个universalJavaApplicationStub.sh
6.使用以下内容替换：
#!/bin/bash ################################################################################## # # # universalJavaApplicationStub # # # # A BASH based JavaApplicationStub for Java Apps on Mac OS X # # that works with both Apple's and Oracle's plist format. # # # # Inspired by Ian Roberts stackoverflow answer # # at http://stackoverflow.com/a/17546508/1128689 # # # # @author Tobias Fischer # # @url https://github.com/tofi86/universalJavaApplicationStub # # @date 2020-03-19 # # @version 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1cb76ee0b12b3a13eaa4532fe5e05ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b407d32fe06549f1a80877f6ecb8868e/" rel="bookmark">
			mysql数据转为pgsql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.选择要转的表---选择模型
2.选择转出的模型
3.点击【确定】后，导出表结构
4.选择导出的路径。
5.查看导出的表结构 1.选择要转的表---选择模型 2.选择转出的模型 3.点击【确定】后，导出表结构 4.选择导出的路径。 5.查看导出的表结构 复制sql去pgsql里面就可以直接执行。这个导的是表结构。
你可以打开表直接复制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46924770eccc3a315e52576ec478077/" rel="bookmark">
			Java中json格式的字符串数组，list，json，map相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常开发中免不了和json格式的字符串数组，list，json，map打交道，因此这篇文章的着重点就是这四者的相互转换
1、json格式的字符串数组转list
String json = "['北京','天津','杭州']";//"[\"北京\",\"天津\",\"杭州\"]";
String[] pathArr = (json.substring(1, json.length() - 1)).split(",");//string数组
// 使用Arrays.asList 转换
List&lt;String&gt; pathList = Arrays.asList(pathArr);
for (String s : pathList) {
System.out.println(s);
}
//使用collections
List list=new ArrayList();
Collections.addAll(list,pathArr);
for (Object o : list) {
System.out.println(o);
}
2、list转json格式数组
List&lt;String&gt; list1=new ArrayList&lt;String&gt;();
list1.add("a");
list1.add("b");
list1.add("vc");
JSONArray jsonArray = JSONArray.fromObject(list1);
String string=jsonArray.toString();//string
String[] sd = (string.substring(1, string.length() - 1)).split(",");//string数组
System.out.println(sd instanceof String[]);
for (String s : sd) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d46924770eccc3a315e52576ec478077/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e454cd06a0dd51fcac52d9c99b43c0c0/" rel="bookmark">
			【element Vue】＜el-select＞回显问题，应该回显 label 却只显示了id
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回显问题，应该回显 label 却只显示了id
原因是，数据类型不匹配，导致，无法识别，才只显示了id
重点重点重点重点 注意看 重点啊 问题描述：
&lt;el-col :span="12"&gt; &lt;el-form-item label="中午吃啥" prop="lunch"&gt; &lt;el-select v-model="wlong.lunch" placeholder="中午吃啥" size="small"&gt; &lt;el-option v-for="(t, i) of lunchList" :key="i" :label="t.label" :value="t.value" // 重点1， 显示的是 id，id的数据类型 是字符串 &gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;script&gt; export default { data () { return { wlong: { lunch: '' // 重点2，回显的数据类型是 字符串 。 如果是 数字 }, lunchList: [ {label: '西北风', value: '1'}, // 重点3， value 值是字符串，字符串，字符串，这也是字符串。如果是数字这里也应该是数字 {label: '米饭', value: '2'}, {label: '面条子', value: '3'} ] } }, } &lt;/script&gt; 但是回显出来的结果居然是这样的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e454cd06a0dd51fcac52d9c99b43c0c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e46cc40e76c4534a98dc98e8befa21ba/" rel="bookmark">
			Altium Designer 原理图变灰怎么快速恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Altium Designer 原理图变灰怎么快速恢复 偶然间遇到了这个小问题，CTRL+F 查找一个元器件后，网络变灰并且编辑不了，SHIFT+C来清除过滤器失效，关闭原理图或者重启软件可以解决这个问题，但是有点拖效率，其实这并不是软件的BUG，只是我们没有找到正确的方法，今天和大家分享一下如何快速恢复原理图的可编辑模式。
没有恢复前时的原理图如下图：
到这里就有人说了，欸我的直接 SHIFT+C就可以恢复了，emmm，请便吧哈哈
恢复正题，如果遇到了SHIFT+C 没有清除过滤器这种情况，请注意原理图左下角的位置，有两个选项：
第一个：Editor
第二个：你的原理图名字（做示范，本人原理图名字叫 dsp）
其实现在你是处于第二个选项模式下，如下图
选择Editor模式，这时候SHIFT+C就可以清除过滤器了
这样我们就可以恢复到正常的编辑模式啦
希望对你有帮助哦！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/143/">«</a>
	<span class="pagination__item pagination__item--current">144/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/145/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>