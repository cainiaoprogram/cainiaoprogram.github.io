<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2074dab671eea59c223f303324e593f0/" rel="bookmark">
			将网易云API通过宝塔面板布署到云服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将网易云API通过宝塔布署到云服务器 购买云服务器&amp;创建实例购买云服务器创建云服务器实例 放行端口远程连接安装宝塔面板系统通过宝塔面板将文件托管到云服务器登陆宝塔面板绑定宝塔账号安装LNMP添加端口规则上传文件解决Nginx安装失败添加Node项目 其他错误启动Node项目失败将进程通过虚拟终端挂载 购买云服务器&amp;创建实例 购买云服务器 我选择的是阿里云服务器（学生免费白嫖一个月版），选择免费领取一台ECS云服务器（我已经领取过了，完成下列相关任务还可延长6个月），如下图所示
若未进行学生认证的，需要通过支付宝辅助完成学生认证，完成学生认证后，可购买对应云服务器（支付0元），操作系统可选择自己喜欢的，我选择的操作系统版本是Ubuntu 22.04 64，其余选项默认即可
创建云服务器实例 进入到如下界面，云服务器实例已经创立好了（自动创立），主要关注的内容包括：实例ID/名称（点击可查看更多关于此实例的详细信息）、IP地址（公网IP地址是我们外部访问的地址）以及远程连接
放行端口 点击上述实例ID/名称-&gt;安全组-&gt;管理规则
进入到此界面后，点击快速添加，可以把所有端口全部勾选。然后在可单独添加自己需要的端口，例如我的云服务器默认端口为3000，则我需要放行一个3000的端口
请根据实际场景设置授权对象的CIDR，另外，0.0.0.0/0或者掩码为0，代表允许或拒绝所有IP的访问，设置时请务必谨慎。支持输入多种授权对象，以","隔开，支持安全组名称模糊搜索。跨账号安全组以“账号ID/安全组id”格式输入,请填写账号ID而不是账号信息
远程连接 点击远程连接，我选择的是默认方式Workbench
点击立即登陆之后，进入下列界面，用户名默认是root，这个无需更改。一开始只有默认密码，可以通过下列重置密码将密码改为自己熟悉的
下列为重置实例密码界面，改完之后，登陆即可
安装宝塔面板系统 我选择的是Ubuntu系统，进入下列界面输入安装Ubuntu系统的脚本指令即可
wget -O install.sh https://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh ed8484bec 若遇yum相关错误，请移步此文章解决阿里云远程连接yum无法安装问题（Ubuntu 22.04）若遇yum相关错误，请移步此文章解决阿里云远程连接yum无法安装问题（Ubuntu 22.04）若遇yum相关错误，请移步此文章解决阿里云远程连接yum无法安装问题（Ubuntu 22.04）
其余系统脚本指令如下
Centos安装脚本 yum install -y wget &amp;&amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec Debian安装脚本 wget -O install.sh https://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; bash install.sh ed8484bec 万能安装脚本 if [ -f /usr/bin/curl ];then curl -sSO https://download.bt.cn/install/install_panel.sh;else wget -O install_panel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2074dab671eea59c223f303324e593f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd2fd38826b28a4e2ea7166e8487a7c/" rel="bookmark">
			解决阿里云远程连接yum无法安装问题（Ubuntu 22.04）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决阿里云远程连接yum无法安装问题（Ubuntu 22.04） 第一步 进入阿里云远程连接后，尝试安装宝塔面包第二步：尝试更新软件包等一些列操作第三步：完成上述操作之后，尝试安装yum第四步：尝试更换清华镜像源第五步：添加公钥并再次尝试安装yum第六步：解决上述python问题第七步：再一次安装宝塔面板 第一步 进入阿里云远程连接后，尝试安装宝塔面包 使用下列命令安装宝塔面板(Ubuntu版本)
wget -O install.sh https://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh ed8484bec 随即出现yum没有安装的错误
Command 'yum' not found, did you mean: command 'gum' from snap gum (0.13.0) command 'num' from deb quickcal (2.4-1) command 'sum' from deb coreutils (8.32-4.1ubuntu1) command 'zum' from deb perforate (1.2-5.1) command 'uum' from deb freewnn-jserver (1.1.1~a021+cvs20130302-7build1) command 'yum4' from deb nextgen-yum4 (4.5.2-6) See 'snap info &lt;snapname&gt;' for additional versions. 第二步：尝试更新软件包等一些列操作 apt-get install build-essential 出现如下结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bd2fd38826b28a4e2ea7166e8487a7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/891a03c3f3ca8cca5502d570af8f20a6/" rel="bookmark">
			MySQL数据库高级SQL语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、高级SQL语句
（一）select：查询语句
1.where：根据条件查询
2.in：显示已知值的数据
3.not in：显示除了已知值的数据
4.between：显示两个值范围内的数据
5.like+通配符：模糊查询
6.order by：按关键字排序
（二）函数
1.数学函数
（1）函数类型
（2）示例
2.聚合函数
（1）函数类型
（2）示例
3.字符串函数
（1）函数类型
（2）示例
① concat(字段1, 字段2, ....) ② 字段1 || 字段2 ③ substr(x,y,z) ④ length(x)
⑤ 替换
（三）group by分组
1.group by
2.having
（四）as：别名
（五）连接查询
1.inner join(内连接)
2.left join(左连接)
3.right join(右连接)
（六）联集
1.union
2.union all
（七）子查询
一、高级SQL语句 （一）select：查询语句 1.where：根据条件查询 select '字段' from 表名 where 条件 #示例：显示store_Name和store_info 字段 并且要找到Sales小于1000 select store_name from store_info where Sales &gt; 1000; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/891a03c3f3ca8cca5502d570af8f20a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6e904e16c97414f6842ac2dde29af3b/" rel="bookmark">
			中间件系列 - Redis入门到实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 学习视频： 黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目资源地址：Redis入门到实战教程资源本内容仅用于个人学习笔记，如有侵扰，联系删除 目录 中间件系列 - Redis入门到实战(基础篇)中间件系列 - Redis入门到实战(实战篇)中间件系列 - Redis入门到实战(高级篇-分布式缓存)中间件系列 - Redis入门到实战(高级篇-多级缓存)中间件系列 - Redis入门到实战(高级篇-最佳实践)中间件系列 - Redis入门到实战(原理篇) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/061fb3f9867e9703ecfc83a1944ffc39/" rel="bookmark">
			用好它们！没有你找不到的电子书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前读书的时候很喜欢买纸质书籍 ，但自从有了 iPad 和智能手机。我发现用智能设备看书似乎性价比更好，不仅可以随时随地阅读
而且还能省不少书的钱，因为电子书网上很多分享几个本人常用的电子书搜索工具。用好这几个工具99% 的书籍你都可以下载下来
01 无名图书 界面设计非常好看 ，使用起来也非常简单，即可下载直接下载推荐的书籍，也可以根据关键词去搜索下载想要的电子书
书籍分类比较详细，书籍资源不是太多，都是比较正能量的，完全免费下载
**传送门 **https://www.book123.info/
02 Book Searcher 这个是本人平时用的最多的一个 ,书籍数量比较多，而且你可以根据书名、作者、出版社 ···去精准的搜索自己想要的书籍
现在我都是一般在某当当 ，或者知乎等平台寻找一些大佬推荐的书籍 然后在这里直接下载阅读，不好了直接卸载，不用担心付费踩坑
传送门 https://zbook.eu.org/
03 Z-library 这个估计都不用本人太多介绍了吧,全球最大的电子书图书馆。可惜了，这么好的网站在国内是无法直接访问的
如果你可以突破国内的限制 ，这个网站绝对是书籍大宝藏。但是如果你没办法突破限制。那就乖乖的用上面那两个国内的就可以了
传送门 https://zlibrary-cn.se/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ae622d5f6f294cb856f8f6c4a87f28/" rel="bookmark">
			Halcon License - 2024.01.01（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024.01.01 元旦快乐！ 链接：https://pan.baidu.com/s/1LEcXNGF9lVFKa3uLjZvSXA
提取码：98wo
2023.12.1 抓住尾巴！ 链接：https://pan.baidu.com/s/1vDNLzBkbbUPeu-yWqlweCg
提取码：ib38
2023.11.1 蜕，变！ 链接：https://pan.baidu.com/s/1pneI4kHZ79uII-X_CX6zqw
提取码：ck77
2023.10.1 双节快乐！ 链接：https://pan.baidu.com/s/1UUauBv1OtN40kXGP5CMjXw
提取码：dv5n
2023.9.1 金秋九月！ 链接：https://pan.baidu.com/s/1A0OFzGRmjFY7BgZawyQcEA
提取码：9uc9
2023.8.1 一切顺利！ 链接：https://pan.baidu.com/s/1cr8DGzmJdmuHcHan8XUGkQ
提取码：suip
2023.7.1 稳中求进！ 链接：https://pan.baidu.com/s/1ooObZcwzODZhbKp9gunguw
提取码：71y7
2023.6.1 66大顺！ 链接：https://pan.baidu.com/s/1e9J-5sgvq6UAnKpr-1jZ8w
提取码：d141
2023.5.1 五一假日快乐！ 链接：https://pan.baidu.com/s/1TmUOYHWfCIoBbufstbdCQw
提取码：2f68
2023.4.1 一切顺利！ 链接：https://pan.baidu.com/s/1DY8By9Z-qzMj6btPH3ZpZQ
提取码：9793
2023.3.1 一年之计在于春！ 链接:
https://pan.baidu.com/s/1G_e2TmrYJ3wqcOhhrEshBQ
提取码:26xp
2023.2.1 开工大吉！ 链接：https://pan.baidu.com/s/1yGJ9Bjn3wYNKlRo3Q1oxoQ
提取码：uv21
2023.1.1 新年快乐！ 链接：https://pan.baidu.com/s/1Emegrydot3Kg1W_2JroQpA
提取码：h5pa
2022.12.1 Keep Moving！ 链接：https://pan.baidu.com/s/1mOXabZxcatqht-T6z4o-tA
提取码：0tj3
2022.11.1又一年购物节！ 链接：https://pan.baidu.com/s/1RCdcoHyioVkcrvk_r9tBHg
提取码：a4zm
2022.10.1国庆快乐！ 链接：https://pan.baidu.com/s/19RAVVyVbh8hqD7gkxefdAA
提取码：2bvn
2022.9.1秋意绵绵！ 链接：https://pan.baidu.com/s/1EBjQ3jW7H88vsUj7TMgDEQ
提取码：3jim
2022.8.1建军节快乐！ 链接：https://pan.baidu.com/s/1b0DQZmXjetY-dFCPNWcAcg
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3ae622d5f6f294cb856f8f6c4a87f28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80a5435d9774abe0b47ed1cf40f8cd64/" rel="bookmark">
			像素抖动(Pixel Dithering) 的Shader实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		莫列波纹(Moiré pattern)与Banding有时候会会对图像画面造成显示问题，如此文所示：
莫列波纹(Moiré pattern)与Banding_moir茅 patterns-CSDN博客
在实时渲染中，用Shader实现的Dithering能缓解这类问题。
没有dithering效果(Banding现象):
使用dithering效果(Smooth):
这里给出HLSL, GLSL, WGSL这些环境下的Pixel Dithering Shader实现。具体细节再具体调整。
DirectX中实现的Dithering实现:
static const float PI = 3.141592653589793; static const float factor = 0.25 / 255.0; static const float c = 43758.5453; static const float2 uvFactor = float2( 12.9898 ,78.233 ); float randUV( float2 uv ) { float dt = dot( uv.xy, uvFactor ); float sn = fmod( dt, PI ); return frac(sin(sn) * c); } static const float4 dither_fector = float4( factor, -factor, factor, factor); float4 dithering( float4 color, float2 puv ) { float grid_position = randUV( puv ); return color + lerp( 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80a5435d9774abe0b47ed1cf40f8cd64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1cfdedd3967172048a7ca22e332fff0/" rel="bookmark">
			直线未必是捷径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假装定义一句名言：直线未必是捷径。 ​想想概率，想想AI，想想量子。不确定性，未必不会造就好的结果。因为所谓结果，时常是多种因素综合作用的效果。So, 请记住这句名言。[呲牙][呲牙][呲牙][呲牙][呲牙][呲牙][呲牙]。 ​
所谓非线性，所谓创造力，所谓灵感，何去何从？
所以才有了：融会贯通，触类旁通。
为何有相对性？最大的原因，应该就是有不确定性。因此，确定性也是相对的确定性。水到渠成这句古老的成语，也许是对此很不错的阐释。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d18f237ab93cc57c5a7db4ece10e78c7/" rel="bookmark">
			蓝桥圣诞树（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 输入样例： 1 3
101
1 2
2 3
输出样例： YES
思路： 这道题还是比较好想的，因为它构造的二叉树是用边连接起来的，不是像之前一样从上到下从左到右按编号构造的，所以可以用邻接表来存每个点还有边，这样可以很方便的找到每个点的相邻点，然后再判断每个点是否有两个相邻点和它颜色一样（即三个连续点同色），这样就可以判断不美观的圣诞树了。
示例代码： #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N = 1010; int h[N], e[N], ne[N], idx; char color[N]; void add(int a, int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx++; } int main() { int t; cin &gt;&gt; t; while (t--) { idx=0; //对于每个样例，都需要重置idx为0，不然上一个样例创建的邻接表就会影响下一个样例 int n; cin &gt;&gt; n; memset(h, -1, sizeof(h)); //邻接表初始化 for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; color[i]; } for (int i = 0; i &lt; n - 1; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b); add(b, a); } //遍历每个点，如果它有两个邻点颜色和它本身都一样就不行 int flag = 0; for (int i = 1; i &lt;= n; i++) //遍历所有点 { int res = 0; for (int j = h[i]; j !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d18f237ab93cc57c5a7db4ece10e78c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f866cdef5dc1d19bd1083975c885ac0/" rel="bookmark">
			Android NDK开发详解连接性之连接蓝牙设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android NDK开发详解连接性之连接蓝牙设备 连接技术作为服务器连接作为客户端连接 如需在两台设备之间创建连接，您必须同时实现服务器端和客户端机制，因为其中一台设备必须开放服务器套接字，而另一台设备必须使用服务器设备的 MAC 地址发起连接。服务器设备和客户端设备分别以不同的方式获取所需的 BluetoothSocket。接受传入连接时，服务器会收到套接字信息。客户端会在打开到服务器的 RFCOMM 通道时提供套接字信息。 当服务器和客户端在同一 RFCOMM 通道上都具有已连接的 BluetoothSocket 时，就会将两者视为彼此连接。此时，每台设备都可以获得输入和输出流，并且可以开始传输数据，我们将在有关传输蓝牙数据的部分对此进行讨论。本部分介绍如何在两台设备之间发起连接。
在尝试查找蓝牙设备之前，请确保您拥有适当的蓝牙权限并为应用设置蓝牙。
连接技术 一种实现技术是自动将每个设备准备为服务器，使每台设备打开服务器套接字并监听连接。在这种情况下，任一设备都可以发起与另一台设备的连接并成为客户端。或者，其中一台设备可明确托管连接并按需打开服务器套接字，而另一台设备则发起连接。
图 1. “蓝牙配对”对话框。
注意 ：如果这两个设备之前尚未配对，则 Android 框架会在连接过程中自动向用户显示配对请求通知或对话框，如图 1 所示。因此，当您的应用尝试连接设备时，无需担心设备是否已配对。在用户成功配对两台设备之前，您的 RFCOMM 连接尝试会被阻止；如果用户拒绝配对，或者配对过程失败或超时，尝试连接就会失败。
作为服务器连接 当您想要连接两台设备时，其中一台设备必须保持打开状态的 BluetoothServerSocket 来充当服务器。服务器套接字的用途是监听传入的连接请求，并在请求被接受后提供已连接的 BluetoothSocket。从 BluetoothServerSocket 获取 BluetoothSocket 后，您可以（并且应该）舍弃 BluetoothServerSocket，除非您希望设备接受更多连接。
如需设置服务器套接字并接受连接，请完成以下步骤序列：
通过调用 listenUsingRfcommWithServiceRecord(String, UUID) 获取 BluetoothServerSocket。 该字符串是您的服务的可识别名称，系统会自动将其写入设备上的新服务发现协议 (SDP) 数据库条目。该名称可以任意设置，可以直接使用应用名称。 通用唯一标识符 (UUID) 也包含在 SDP 条目中，并且构成了与客户端设备连接协议的基础。也就是说，当客户端尝试与此设备连接时，它会携带 UUID，该 UUID 可唯一标识其想要连接的服务。这两个 UUID 必须匹配，系统才会接受连接。 UUID 是用于唯一标识信息的字符串 ID 的 128 位标准化格式。UUID 用于标识在系统或网络中需要具有唯一性的信息，因为 UUID 重复的概率实际上为零。它可以独立生成，无需使用集中式授权机构。在这种情况下，它用于唯一标识应用的蓝牙服务。如需获取用于您的应用的 UUID，您可以使用网络上的众多随机 UUID 生成器之一，然后使用 fromString(String) 初始化该 UUID。 通过调用 accept() 开始监听连接请求。 这是阻塞调用。它会在连接被接受或发生异常时返回。仅当远程设备发送的连接请求中包含的 UUID 与使用此监听服务器套接字注册的 UUID 相匹配时，系统才会接受连接。如果操作成功，accept() 会返回一个已连接的 BluetoothSocket。 除非您想接受其他连接，否则请调用 close()。 此方法调用会释放服务器套接字及其所有资源，但不会关闭 accept() 返回的已连接 BluetoothSocket。与 TCP/IP 不同，RFCOMM 一次只允许每个通道有一个已连接的客户端，因此在大多数情况下，在接受已连接的套接字后立即在 BluetoothServerSocket 上调用 close() 是合理的。 由于 accept() 调用是一个阻塞调用，因此请勿在主 activity 界面线程中执行该调用。在其他线程中执行该操作可确保您的应用仍然可以响应其他用户互动。通常而言，可以在应用管理的新线程中执行涉及 BluetoothServerSocket 或 BluetoothSocket 的所有工作。如需取消被阻塞的调用（例如 accept()），请从另一个线程对 BluetoothServerSocket 或 BluetoothSocket 调用 close()。请注意，BluetoothServerSocket 或 BluetoothSocket 上的所有方法都是线程安全的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f866cdef5dc1d19bd1083975c885ac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be983cdf91a408fd482faa486821fac7/" rel="bookmark">
			科研学习|论文解读——融合类目偏好和数据场聚类的协同过滤推荐算法研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文链接（中国知网）：
融合类目偏好和数据场聚类的协同过滤推荐算法研究 - 中国知网 (cnki.net)
摘要：[目的/意义]基于近邻用户的协同过滤推荐作为推荐系统应用最广泛的算法之一，受数据稀疏和计算可扩展问题影响，推荐效果不尽如人意。[方法/过程]针对上述问题，提出了一种改进的推荐算法（Category Preferred Data Filed Clustering based Collaborative Filtering Recommendation, CPDFC-CFR）。首先，该算法舍弃用户评分，利用评论情感构建用户—项目矩阵，以增强用户偏好表示能力。其次，该算法引入类目偏好和语义偏好的概念，利用类目偏好比对高维用户—项目矩阵进行降维，并在用户相似度计算中纳入评论情感偏好、项目类目偏好和语义偏好，以降低数据稀疏性。最后，该算法将数据场作为用户聚类的前置算法，把数据场输出（极大值点）作为K-means算法输入，以提升算法实时性和稳定性。[结果/结论]实验结果表明：（1）项目类目级别越低，CPDFC-CFR算法准确性（F-measure）和即时性（相似度计算次数和推荐耗时）越优；（2）与其它推荐算法相比，CPDFC-CFR算法能够有效提升推荐准确性和计算效率，对协同过滤推荐系统建设具有重要参考价值。
关键词：推荐系统；协同过滤；数据稀疏；计算可扩展；类目偏好；数据场聚类
Category Preferred Data Field Clustering based Collaborative Filtering Recommendation Algorithm Research
Abstract: [Purpose/Significance] Collaborative filtering recommendation based on nearest users, one of the most widely used algorithms in recommender systems, is affected by the issues of data sparsity and computational scalability, and the recommendation effect is unsatisfactory. [Method/Process] To address these issues, a category preferred data filed clustering based collaborative filtering recommendation algorithm(CPDFC-CFR) is proposed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be983cdf91a408fd482faa486821fac7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e06a11e3c7279e8d0dcf484fad740721/" rel="bookmark">
			db2中多种方式备份数据（含db2中clob字段如何使用create table as方式备份）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		db2中多种方式备份数据（含db2中clob字段如何使用create table as方式备份） 1. 前言——关于DB2的其他操作2. 单表备份（备份数据）2.1 使用create table as ...2.1.1 对于没有clob的字段的备份2.1.2 对于有clob的字段的备份 2.2 使用 export 命令备份ixf文件2.2.1 导出数据命令（export）2.2.1.1 导出到当前路径2.2.1.2 导出到当指定路径 2.2.2 导入数据命令（load）2.2.3 导出表中部分数据（可加where） 2.3 使用 export 命令备份del文件 3. 导出表结构、存储过程、函数等4. 导出数据（多表）5. 导入表结构 1. 前言——关于DB2的其他操作 更多请看下面的文章： 使用docker安装db2.DB2中实现数据字段的拼接（LISTAGG() 与 xml2clob、xmlagg）.DB2—03（DB2中常见基础操作 ➕ DB2实现递归查询 ➕ DB2中自定义递归函数）. 2. 单表备份（备份数据） 2.1 使用create table as … 2.1.1 对于没有clob的字段的备份 语法如下：--1. 创建表my_table_test CREATE TABLE my_table_test AS( SELECT t.DEPT_ID ,t.DEPT_NAME FROM SYS_COMPANY_DEPT t )DATA INITIALLY DEFERRED refresh DEFERRED; --2. refresh 之后，表就可以查询了 refresh TABLE my_table_test; --3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e06a11e3c7279e8d0dcf484fad740721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b1146a441fc6072c5b07c50e529f47/" rel="bookmark">
			redis—Hash哈希
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1.常见命令
1.1命令小结
1.2内部编码
2.使用场景
前言 几乎所有的主流编程语言都提供了哈希(hash) 类型，它们的叫法可能是哈希、字典、关联数组、映射。在Redis中，哈希类型是指值本身又是一个键值对结构，形如key= "key", value={{
field1, value1 }, ... {fieldN, valueN }}, Redis 键值对和哈希类型二者的关系可以用图2-15来表示。
图2-15字符串和哈希类型对比
哈希类型中的映射关系通常称为field-value, 用于区分Redis整体的键值对(key-value) ，注意这里的value是指field对应的值，不是键(key) 对应的值，请注意value在不同上下文的作用。
1.常见命令 HSET
设置hash中指定的字段(field) 的值(value) 。
语法:
HSET key field value [field value ...] 命令有效版本: 2.0.0之后
时间复杂度:插入一组field为0(1),插入N组field为O(N)
返回值:添加的字段的个数。
示例:
redis&gt; HSET myhash field1 "Hello" (integer) 1 redis&gt; HGET myhash field1 "Hello" HGET
获取hash中指定字段的值。
语法:
HGET key field 命令有效版本: 2.0.0之后
时间复杂度: O(1)
返回值:字段对应的值或者nil。
示例:
redis&gt; HSET myhash field1 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8b1146a441fc6072c5b07c50e529f47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ca57bae73fd9e8bad8fd09e075ba76/" rel="bookmark">
			SerializationException: End of Stream encountered before parsing was completed.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		socket发送的数据转为byte[]后长度超过1460，导致每次循环只接收了一部分，导致反序列化失败。把当前数据存起来，和下次的拼在一起就行了。
public static void ReceiveMessage() { if (server == null) { if (clientOrListening) server = link; else server = link.Accept(); } while (true) { byte[] buffer = new byte[1024 * 1024]; int currentLength = server.Receive(buffer);//利用阻塞防止界面卡住 while (server.Available &gt; 0) { byte[] bytes = new byte[1460]; int receiveLength = server.Receive(bytes); Array.Copy(bytes, 0, buffer, currentLength, receiveLength); currentLength += receiveLength; } if (currentLength &gt; 0) { MemoryStream memory = new(); memory.Write(buffer, 0, currentLength); memory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71ca57bae73fd9e8bad8fd09e075ba76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fd74f3d253c981a4d44423297b4d42d/" rel="bookmark">
			超详细||深度学习环境搭建记录cuda&#43;anaconda&#43;pytorch&#43;pycharm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文用来记录windows系统上深度学习的环境搭建，目录如下
一、安装显卡驱动 首先为装有NVIDIA gpu的电脑安装显卡驱动，如果安装过了，或者想使用cpu的，可以跳过这一步。（其实这一步可以跳过，因为显卡驱动好想和深度学习环境没什么关系，保险起见还是安装上吧）
1. 去官网下载对应的显卡驱动：官方驱动 | NVIDIA 2. 完成下载，选择文件开始安装，直接解压在默认地址
3. 选择自定义安装选项，执行清洁安装（按情况选择）
4. 一直点下一步即可。
二、安装Visual Studio 可以跳过，但是很多深度学习环境需要用到，建议安装
1. 官网下载 Visual Studio Tools - 免费安装 Windows、Mac、Linux (microsoft.com)
2. 选择python开发和c++桌面开发，开始安装
三、cuda+cudnn安装 1. 打开cmd，输入nvidia-smi查看GPU的CUDA版本，可以看到CUDA版本12.1，意味着只能安装小于12.1的CUDA版本。
CUDA Toolkit Archive | NVIDIA Developer2. 去网站下载适合的CUDA版本：CUDA Toolkit Archive | NVIDIA Developer
要根据两个条件选择：
1. CUDA版本要小于上面的版本信息2. 先去pytorch官网Start Locally | PyTorch，看一眼自己需要的pytorch版本对应的CUDA版本 例如：pytorch1.12.0只支持CUDA10.2，11.3，11.6
3. 然后去官网下载：CUDA Toolkit Archive | NVIDIA Developer，以11.6版本举例，选好系统参数，点击下载，
4. 下载完成，直接默认解压位置
5. 默认勾选即可，点下一步
6. 安装cudnn
去官网下载CUDA Deep Neural Network (cuDNN) | NVIDIA Developer，需要注册一个NVIDIA账号，然后选择CUDA对应版本的cudnn即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fd74f3d253c981a4d44423297b4d42d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9015dd3dc96deeafeedf1d0c25b0523/" rel="bookmark">
			论文-三线表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1点击表格
2选择自己所需要的行列
3点击左下角新建表格样式
4进行如下修改
5接着点击格式-边框和底纹
6.设置上下宽度为1.5磅
7.格式应用于标题行，接着进行标题行边框和底纹设置值下0.75上1.5
8.接着点击左下角格式进行字体设置
9.最后进行段落设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebfffe21c32bd215f0770ccaa81d8bbb/" rel="bookmark">
			NLP论文阅读记录 - 01 | 2021 神经抽象摘要方法及摘要事实一致性综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言0、论文摘要一、Introduction二.背景2.1自动总结任务2.2 数据集DUC-2004Gigaword [Graff et al., 2003, Napoles et al., 2012]CNN/DailyMail [Nallapati 等人，2016]XSum [Narayan 等人，2018] 2.3 摘要系统的评估2.3.1 Rouge [Lin, 2004] 三.抽象概括技术3.1 前神经网络时代3.1.1 统计方法 [Banko et al., 2000]3.1.2 基于删除的方法 [Knight 和 Marcu，2002] 3.2基于 CNN/RNN 的方法3.2.1 ABS [Rush et al., 2015]3.2.2 RAS-LSTM &amp; RAS-Elman [Chopra et al., 2016]3.2.3 分层注意力 RNN [Nallapati 等人，2016]3.2.4 指针生成器网络 [参见 et al., 2017]3.2.5 自下而上的总结 [Gehrmann et al., 2018] 3.3 基于变压器的方法3.3.1 BertSum [Liu and Lapata, 2019]3.3.2 BART [Lewis et al.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebfffe21c32bd215f0770ccaa81d8bbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce5f914097a0ea7caa6c6be12a81d65b/" rel="bookmark">
			字体使用软件分享（电脑软件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 字体软件 概述：本文为分享型文档
目录 本文摘要ifonts字体助手ifonts字体助手界面ifonts输出 本文摘要 本文主要介绍可以用的电脑软件输出各种形式字体。
ifonts字体助手 ifonts字体助手界面 ifonts输出 顶 End 顶 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8689edd99f2db2abb3c67bc9fb2f40c4/" rel="bookmark">
			第三章 语言基础（中） 数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.4 数据类型 ECMAScript有6种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String和Symbol。Symbol（符号）是ECMAScript 6新增的。还有一种复杂数据类
型叫Object（对象）。Object是一种无序名值对的集合。因为在ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之一来表示。只有7种数据类型似乎不足以表示全部数据。但ECMAScript的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。
3.4.1 typeof操作符 因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof操作符就是为此而生的。对一个值使用typeof操作符会返回下列字符串之一：
"undefined"表示值未定义；"boolean"表示值为布尔值；"string"表示值为字符串；"number"表示值为数值；"object"表示值为对象（而不是函数）或null；"function"表示值为函数；"symbol"表示值为符号。 下面是使用typeof操作符的例子：
在这个例子中，我们把一个变量（message）和一个数值字面量传给了typeof操作符。注意，因为typeof是一个操作符而不是函数，所以不需要参数（但可以使用参数）。
注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeof null返回的是"object"。这是因为特殊值null被认为是一个对空对象的引用。
注意 严格来讲，函数在ECMAScript中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过typeof操作符来区分函数和其他对象。
3.4.2 Undefined类型 Undefined类型只有一个值，就是特殊值undefined。当使用var或let声明了变量但没有初始化时，就相当于给变量赋予了undefined值：
在这个例子中，变量message在声明的时候并未初始化。而在比较它和undefined的字面值时，两者是相等的。这个例子等同于如下示例：
这里，变量message显式地以undefined来初始化。但这是不必要的，因为默认情况下，任何未经初始化的变量都会取得undefined值。
注意 一般来说，永远不用显式地给某个变量设置undefined值。字面值undefined主要用于比较，而且在ECMA-262第3版之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。
注意，包含undefined值的变量跟未定义变量是有区别的。请看下面的例子：
在上面的例子中，第一个console.log会指出变量message的值，即"undefined"。而第二个console.log要输出一个未声明的变量age的值，因此会导致报错。对未声明的变量，只能执行一个有用的操作，就是对它调用typeof。（对未声明的变量调用delete也不会报错，但这个操作没什么用，实际上在严格模式下会抛出错误。）
在对未初始化的变量调用typeof时，返回的结果是"undefined"，但对未声明的变量调用它时，返回的结果还是"undefined"，这就有点让人看不懂了。比如下面的例子：
无论是声明还是未声明，typeof返回的都是字符串"undefined"。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。
注意 即使未初始化的变量会被自动赋予undefined值，但我们仍然建议在声明变量的同时进行初始化。这样，当typeof返回"undefined"时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。
undefined是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。所以一定要明确自己想检测的就是undefined这个字面值，而不仅仅是假值。 let message; // 这个变量被声明了，只是值为undefined // age没有声明 if (message) { // 这个块不会执行 } if (!message) { // 这个块会执行 } if (age) { // 这里会报错 } 3.4.3 Null类型 Null类型同样只有一个值，即特殊值null。逻辑上讲，null值表示一个空对象指针，这也是给typeof传一个null会返回"object"的原因：
在定义将来要保存对象值的变量时，建议使用null来初始化，不要使用其他值。这样，只要检查这个变量的值是不是null就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如：
if (car != null) { // car是一个对象的引用 } undefined值是由null值派生而来的，因此ECMA-262将它们定义为表面上相等，如下面的例子所示：
用等于操作符（==）比较null和undefined始终返回true。但要注意，这个操作符会为了比较而转换它的操作数。
即使null和undefined有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将变量值设置为undefined。但null不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用null来填充该变量。这样就可以保持null是空对象指针的语义，并进一步将其与undefined区分开来。
null是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。所以一定要明确自己想检测的就是null这个字面值，而不仅仅是假值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8689edd99f2db2abb3c67bc9fb2f40c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89a70ee026f6ece06e1cec53bfa99eb3/" rel="bookmark">
			身份证正则表达式验证（高级版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 身份证号码 function validateIdCard(idCard) { //15位和18位身份证号码的正则表达式	var regIdCard = /^(^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$)|(^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[Xx])$)$/; //如果通过该验证，说明身份证格式正确，但准确性还需计算 if (regIdCard.test(idCard)) { if (idCard.length == 18) { var idCardWi = new Array(7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2); //将前17位加权因子保存在数组里 var idCardY = new Array(1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2); //这是除以11后，可能产生的11位余数、验证码，也保存成数组	var idCardWiSum = 0; //用来保存前17位各自乖以加权因子后的总和	for (var i = 0; i &lt; 17; i++) { idCardWiSum += idCard.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89a70ee026f6ece06e1cec53bfa99eb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de2dc9a6e3825f7adf38822a2dbb4917/" rel="bookmark">
			TensorFlow的实战（详细代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 TensorFlow基础 1.1 TensorFlow概要 TensorFlow使用数据流式图规划计算流程，它可以将计算映射到不同的硬件和操作系统平台。 1.2 TensorFlow编程模型简介 TensorFlow中的计算可表示为一个有向图(计算图)，其中每个运算操作为一个节点，每个节点可有任意多个输入和输出；在计算图的边中流动(flow)的数据被称为张量(tensor)，tensor在计算图中flow，故命名为TensorFlow；Session是用户使用TensorFlow的交互式接口，可通过Session的Extend方法添加新的节点和边；反复执行计算图时一般的tensor不会被持续保留，Variable中的数据tensor会被保存。 2 TensorFlow和其他深度学习框架的对比 3 TensorFlow第一步 3.1 TensorFlow的编译及安装 3.2 TensorFlow实现Softmax Regression识别手写数字 载入MNIST数据集 from tensorflow.examples.tutorials.mnist import input_data import tensorflow as tf mnist = input_data.read_data_sets("Mnist_data/", one_hot=True) 创建placeholder用以输入数据 x = tf.placeholder(tf.float32, [None, 784]) y_ = tf.placeholder(tf.float32, [None, 784]) #None代表不限条数的输入 给模型中的weights和biases创建Variable对象，以存储模型参数(其他的tensor将不保存) W = tf.Variable(tf.zeros([784, 10])) b = tf.Variable(tf.zeros([10])) 构建计算公式 y = softmax(Wx + b) 定义Loss，确定优化器 cross_entropy = tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(y), reduction_indices=[1])) train_step = tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy) 初始化变量，执行计算 tf.global_variables_initializer().run() for i in range(1000): batch_xs, batch_ys = mnist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de2dc9a6e3825f7adf38822a2dbb4917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7230aab1d3df3118181e17d3207c32a4/" rel="bookmark">
			open_vins 安装（ubuntu18.04 opencv3.2.0）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		openvins官网
Getting Started » Installation Guide (ROS1 and ROS2) | OpenVINS
Ubuntu 18.04 ROS 1 Melodic (uses OpenCV 3.2)
这里他指的是ros1 melodic，他们用的opencv3.2测试过。
open_vins 官方给的组合Ubuntu 18.04 ROS 1 Melodic (uses OpenCV 3.2)
Ubuntu 18.04 opencv 3.2.0 我本机是3.4.8其实，别人的博客用的3.4.6,肯定是没限定，但是你得踩坑。
opencv默认没有aruco
SourceURL:file:///home/hqw/openvins.docx
openvins官网
Getting Started » Installation Guide (ROS1 and ROS2) | OpenVINS
Ubuntu 18.04 ROS 1 Melodic (uses OpenCV 3.2)
这里他指的是ros1 melodic，他们用的opencv3.2测试过。
open_vins 官方给的组合Ubuntu 18.04 ROS 1 Melodic (uses OpenCV 3.2)
Ubuntu 18.04 opencv 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7230aab1d3df3118181e17d3207c32a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61fc6dea37fcf2373e86d08d969dde1f/" rel="bookmark">
			黑客入门指南（超详细），学习黑客必须掌握的技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.黑客一词，原指热心于计算机技术，水平高超的电脑专家，尤其是程序设计人员。是一个喜欢用智力通过创造性方法来挑战脑力极限的人，特别是他们所感兴趣的领域，例如电脑编程等等。
提起黑客，总是那么神秘莫测。在人们眼中，黑客是一群聪明绝顶，精力旺盛的年轻人，一门心思地破译各种密码，以便偷偷地、未经允许地打入政府、企业或他人的计算机系统，窥视他人的隐私。那么，什么是黑客呢？
学习黑客必须掌握的技术
黑客术语、TCP/IP协议原理、编程、黑客工具使用、Linux和Windows命令使用、各种漏洞的原理。
1、黑客术语 在学习的时候，你起码需要对常见的黑客术语需要掌握，了解术语的话可以去看看这里的百度文库，写的还是可以，对大多数的黑客术语都有过渡，而且对计算机网络原理需要有着一定的基础，所以务必要去学习一下。
就好比：肉鸡是什么？端口、shell、webshell、shellcode、bypass…等等，你得知道它是什么意思！
了解好黑客术语后，你可能就会认为，我现在是不是就能去入侵别人家的电脑、网站挂黑页了？ No，你还需要掌握一些网络的协议，比如TCP/IP协议，了解一些渗透技术和技巧，秉着黑客这门职业就是对计算机技术研究的执着，并不是去恶意攻击、破坏别人的系统就是黑客。
2、网络协议 在成为黑客前，你还要知道网络协议：TCP/IP协议，因为你只要懂了个大概，在你后期做渗透测试以及了解一些漏洞原理帮助是非常大的，比如SSRF漏洞，他支持一些http、ftp、file…等等！
网站的重要性就不需要多说了，要想成为一名黑客，不懂网站怎么可以。http、www、html、css、JavaScript等建站所需的技术都要会，这算是基本功。
3、编程 为什么要学习编程？
因为编程能让我们懂得很多原理，就好比你学会PHP编程，你就懂得了网站的基本运作原理。有一句话说得好：“只有对原理了然如心，才能突破更多的限制！”，也就是说，当你懂得了原理以后，你就会知道哪些地方可能会存在漏洞，哪些地方可以进行突破，最终得到一个shell。在这里我推荐大家前期需要学习的编程语言：PHP、Web前端（HTML、CSS、JavaScript）、Python！
编程是最基础的技能，新手学习建议从Python开始。好多小白总感觉学编程得从C语言开始，其实没必要，语言只是工具，编程最核心的还是编程思想，要学会用计算机的思维去思考问题。在宋丹丹的小品中，有这么一个笑话，把大象装冰箱里需要几步。如果是真的开发一个程序去把大象装冰箱里，还真就得一步步都要考虑到，而且每一步操作，可能出现的异常都要充分考虑清楚，尽可能在程序中把可能出现的所有异常都要做出处理。语言都是一通百通，所以找一个相对容易入门的语言开始学就可以，不必纠结到底什么语言好。
4、黑客工具 这里绝对不是说的那些什么抓鸡啊、远控啊一些无脑软件，你觉得你用了那些软件后有什么？一丝虚荣心？还是成就感？不，你在别人大牛的眼里什么都不是，你还拿着别人玩烂了的东西到处一顿乱扫。
所以你需要系统的学习，就算你说你时间不够，但是常见的工具还是要知道的，比如：Hydra、medusa、sqlmap、AWVS、Burpsuite、Beef-XSS、Metasploit、Nessus、wireshark等安全工具，这些是在安全圈和渗透圈比较知名的渗透工具与平台。在这里我提醒大家一下，一定要学会sqlmap、burpsuite、metasploit这三款工具！
5、漏洞原理 当你学会了一些工具的使用，那么你就可以去学习一些漏洞原理，比如：XSS、CSRF、CORS、SSRF、SQL注入、文件上传、文件包含、未授权访问…等等。
因为我只前说了，你学会编程那么你学这些漏洞原理理解起来会很快，在这里我提醒大家一下，学习漏洞的时候必须一个漏洞学精通了再学习下一个漏洞，这样才能打好基础！
6、熟练掌握常用的操作系统 Windows系统作为使用人数最多的操作系统，这个是必须要掌握的。其次就是Linux系统， 选择一个合适的发行版，开始学习就可以，例如：Ubuntu，CentOS。
7、必要的英语能力 这项不是必须，但是却很重要，因为很多的资料都是英文版的，英语好，可以在第一时间获取更多有价值的信息。
最后（黑客&amp;网络安全如何学习） 网络安全很多技术干货，都可以共享给你们，如果你肯花时间沉下心去学习，它们一定能帮到你
网络安全工程师学习资料包
循序渐进地对黑客攻防剖析。适合不同层次的粉丝。我希望能为大家提供切实的帮助，讲解通俗易懂，风趣幽默，风格清新活泼，学起来轻松自如，酣畅淋漓！
最后 朋友们如果有需要全套网络安全入门+进阶学习资源包，可以点击免费领取（如遇扫码问题，可以在评论区留言领取哦）~
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
1.网安必备全套工具包和源码 2.视频教程 网上虽然也有很多的学习资源，但基本上都残缺不全的，这是我自己录的网安视频教程，路线图上的每一个知识点，我都有配套的视频讲解。
3.技术文档和电子书 技术文档也是我自己整理的，包括我参加护网行动、CTF和挖SRC漏洞的经验和技术要点。
网安方面的电子书我也收藏了200多本，基本上热门的和经典的我都有，也可以共享。
4.NISP、CISP等各种证书备考大礼包 5.CTF项目实战 学习网安技术最忌讳纸上谈兵，而在项目实战中，既能学习又能获得报酬的CTF比赛无疑是最好的试金石！
6.网安大厂面试题 这几年整理的网安方面的面试题，如果你是要找网安方面的工作，它们绝对能帮你大忙。
朋友们如果有需要全套网络安全入门+进阶学习资源包，可以点击免费领取（如遇扫码问题，可以在评论区留言领取哦）~
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f044c33ac199f00c140f78ae2d15ada/" rel="bookmark">
			干货满满，网络安全知识赶快学起来！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着“互联网+”时代的到来，人们的生活变得更加便利，与此同时，生活中各种诈骗短信、垃圾邮件、钓鱼网站也随之而来，导致我们个人信息泄露，甚至财产损失。网络是把双刃剑，如何安全使用成了关键。那么网络安全知识，你知道多少呢？
网络安全是什么？
网络安全从本质上讲，就是网络上的信息安全。是指通过采取必要措施，防范对网络的攻击、侵入、干扰、破坏和非法使用以及意外事故，使网络处于稳定可靠运行的状态，以及保障网络数据的完整性、保密性、可用性、真实性和可控性的能力。
网络安全为何重要？
当今时代，网络安全和信息化对一个国家很多领域都是牵一发而动全身的，网络安全已是国家安全的重要组成部分。没有网络安全就没有国家安全，就没有经济社会稳定运行，广大人民群众利益也难以得到保障。从世界范围看，网络安全威胁和风险日益突出，并向政治、经济、文化、社会、生态、国防等领域传导渗透。网络安全已经成为我国面临的最复杂、最现实、最严峻的非传统安全问题之一。
网络安全现状
攻击者需要的技术水平逐渐降低，手段更加灵活，联合攻击急剧增多；网络蠕虫具有隐蔽性、传染性、破坏性、自主攻击能力，新一代网络蠕虫和黑客攻击、计算机病毒之间的界限越来越模糊、网络攻击趋利性增强、顽固性增加；病毒传播的趋利性日益突出、病毒的反杀能力不断增强。
网络安全常见问题隐患
01
网络病毒攻击
02
网络黑客入侵
03
电信套路诈骗
04
网络交友诈骗
05
恶意app“钓鱼”
06
虚假信息陷阱
07
公共免费网络陷阱
08
网络游戏大额充值引诱
网络安全技能普及
如何安全使用电子邮件？
①不要随意点击不明邮件中的链接、图片、文件。
②适当设置找回密码的提示问题。
③当收到与个人信息和金钱相关（如中奖、集资等）的邮件时要提高警惕。
如何安全使用智能手机？
①不要轻易打开陌生人发送至手机的链接和文件。
②在微信、QQ等程序中关闭定位功能，仅在需要时开启蓝牙。
③安装手机安全防护软件，经常对手机系统进行扫描。
④不要见Wi-Fi就连，见码就刷。
⑤到权威网站下载手机应用软件，并在安装时谨慎选择相关权限。
⑥不要尝试破解自己的手机。
如何保护手机支付安全？
①保证手机随身携带，建议手机支付客户端与手机绑定，开启实名认证。
②从官方网站下载手机支付客户端和网上商城应用。
③使用手机支付服务前，按要求在手机上安装专门用于安全防范的插件。
④登录手机支付应用、网上商城时，勿选择“记住密码”选项。
⑤经常查看手机任务管理器，检查是否有恶意程序在后台运行，并定期使用手机安全软件扫描手机系统。
谨防钓鱼网站
①通过网络购买商品时，仔细查看登录的网站域名是否正确，谨慎点击商家从即时通讯工具上发送的支付链接。
②谨慎对待手机上收到的中奖、积分兑换等信息，切勿轻易点击短信中附带的不明网址。
③不要在陌生网站随意填写个人资料。
慎重参加网络调查、抽奖活动
网络上经常会碰到各种问卷调查、购物抽奖或申请免费试用等活动，参与此类活动前，要选择信誉可靠的网站，不要贸然填写个人资料从而导致信息泄露。
如何安全使用Wi-Fi？
①使用可靠的Wi-Fi接入点。
②关闭手机和平板电脑等设备的无线网络自动连接功能，仅在需要时开启。
③在公共场所使用陌生的无线网络时，尽量不要进行与资金有关的银行转账与支付。
④修改无线路由器默认的管理员用户名和密码，将家中无线路由器的密码设置得复杂一些。
⑤启用WPA2加密方式。
⑥修改默认SSID号，关闭SSID广播。
⑦无人使用时，关闭无线路由器电源。
如何安全设置微信个人信息？
①不建议使用自己的照片作为头像。
②不要使用自己的真实姓名作为昵称。
③建议使用假的地理位置信息。
④开启“加我为朋友时需要验证”选项。
⑤关闭“允许陌生人查看十张照片”选项。
⑥微信密码设置不要过于简单，数字和字母尽量都涉及到，并且字母要大小写全都包含。
⑦停用“漂流瓶”和“摇一摇”功能。
⑧停用“附近的人”功能。
营造网络安全之风、文明之风、法治之风，不能只依靠警察的严厉打击，不能只依靠政府的呼吁号召，真正依靠的是使用网络的你、我、他。我们每一个人，都是网络安全的守护者。“网络安全为人民 网络安全靠人民”，快快转发分享吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3f64c22b3687acd1b3dd97c05e42715/" rel="bookmark">
			Android Security PIN 相关代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发项目遇到一个问题，具体描述及复制步骤如下：
就是开启"Enhanced PIN privacy"(增强的PIN隐私)的时候输入秘密的时候还是会显示数字
如下图，应该是直接是“.” 不应该出现PIN 密码
想要的效果如下图：
设置的步骤如下图：
其中涉及到的部分code如下：
/frameworks/base/core/java/com/android/internal/widget/LockPatternUtils.java
/frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardPinBasedInputViewController.java
/frameworks/base/packages/SystemUI/src/com/android/keyguard/PasswordTextView.java
/frameworks/base/services/core/java/com/android/server/locksettings/LockSettingsStorage.java
I.LockPatternUtils.java:
/** * @return Whether enhanced pin privacy is enabled. */ public boolean isPinEnhancedPrivacyEnabled(int userId) { return getBoolean(LOCK_PIN_ENHANCED_PRIVACY, false, userId); } /** * Set whether enhanced pin privacy is enabled. */ public void setPinEnhancedPrivacyEnabled(boolean enabled, int userId) { setBoolean(LOCK_PIN_ENHANCED_PRIVACY, enabled, userId); } private boolean getBoolean(String secureSettingKey, boolean defaultValue, int userId) { Log.i("TD","LockPatternUtils-----&gt;getBoolean: "+secureSettingKey); try { return getLockSettings().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3f64c22b3687acd1b3dd97c05e42715/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2447bcf31eb3bfb997db1a12709dbb0/" rel="bookmark">
			使用Rust发送邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SMTP协议与MIME协议 SMTP（简单邮件传输协议,Simple Mail Transfer Protocol）是一种用于发送和接收电子邮件的互联网标准通信协议。它定义了电子邮件服务器如何相互发送、接收和中继邮件。SMTP 通常用于发送邮件，而邮件的接收通常由 POP（邮局协议）或 IMAP（互联网消息访问协议）来处理。
POP3，全名为“Post Office Protocol - Version 3”，即“邮局协议版本3”。是TCP/IP协议族中的一员，由RFC1939 定义。本协议主要用于支持使用客户端远程管理在服务器上的电子邮件。提供了SSL加密的POP3协议被称为POP3S
因特网信息访问协议（缩写为IMAP，以前称作交互邮件访问协议）是一个应用层协议，用来从本地邮件客户端（如Microsoft Outlook、Outlook Express、Foxmail、Mozilla Thunderbird）访问远程服务器上的邮件。
SMTP 的作用包括：
邮件发送：它允许用户通过电子邮件客户端（如 Outlook、Thunderbird 等）发送邮件。 邮件中继：SMTP 服务器可以将邮件从一个服务器转发到另一个服务器，最终到达收件人的邮箱服务器。 邮件排队：如果目标服务器不可用，SMTP 服务器可以将邮件保存在队列中，稍后再次尝试发送。 SMTP 基于 TCP（传输控制协议），而不是 UDP（用户数据报协议）。TCP 提供了一种可靠的方式来确保数据包的顺序和完整性，这对于电子邮件传输非常重要。
尽管 SMTP 非常有效于处理文本信息的发送，但它本身并不支持非文本附件（如图片、视频、文档等）。
MIME扩展了电子邮件标准，使其能够支持：
非ASCII字符文本；
非文本格式附件（二进制、声音、图像等）；
由多部分（multiple parts）组成的消息体；
包含非ASCII字符的头信息（Header information）
MIME（多用途互联网邮件扩展,Multipurpose Internet Mail Extensions）协议, 是一种扩展 SMTP 的标准，使电子邮件能够支持诸如文本、图像、音频和视频等不同格式的内容，以及多部分消息体和字符编码。通过 MIME，电子邮件能够包含丰富的多媒体内容，这在现代通信中是非常必需的。
使用Rust发送邮件 在 Rust 中发送电子邮件可以通过使用第三方库来实现，例如 lettre库[1]。lettre 提供了发送邮件的功能，包括与 SMTP 服务器的交互。此外，可能还需要使用 mime 库来设置邮件内容的类型。
将 lettre 和 mime 库添加到项目的 Cargo.toml 文件中：
[dependencies] lettre = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2447bcf31eb3bfb997db1a12709dbb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08556aa6c0e3dcb1e4c8016dd92ec8b/" rel="bookmark">
			React使用echarts-for-react出现Module not found: Can‘t resolve ‘echarts‘ ..
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题产生：项目中使用node16.20.1安装echarts-for-react使用正常，构建采用的时14.x.x降低项目版本后发现包文件获取失败
原因 node高版本在使用echarts-for-react时不需要自身安装echarts，node14版本中需要手动安装echarts
解决方案 npm install echarts echarts-for-react 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c50ca01cff53ea717c1d427b9c1828cb/" rel="bookmark">
			EasyExcel实现百万级数据的导入导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EasyExcel实现百万级数据的导入导出 一、前言 通过SpringBoot集成EasyExcel实现百万级数据的导入导出
二、准备工作 1. 数据库 create table employee ( employee_id bigint not null primary key, employee_name varchar(100) not null, age int not null, gender varchar(10) not null, create_time datetime not null ); 2. 导入数据(使用存储过程向MySQL中加入100w条数据) DELIMITER // drop procedure IF EXISTS InsertTestData; CREATE PROCEDURE InsertTestData() BEGIN DECLARE counter INT DEFAULT 0; DECLARE gender VARCHAR(10); WHILE counter &lt; 1000000 DO IF counter % 2 = 0 THEN SET gender = '男'; ELSE SET gender = '女'; END IF; INSERT INTO demo64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c50ca01cff53ea717c1d427b9c1828cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dddbbf12280658872566757c04aa4800/" rel="bookmark">
			过滤器和监听器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、过滤器 什么是过滤器
当浏览器向服务器发送请求的时候，过滤器可以将请求拦截下来，完成一些特殊的功能，比如：编码设置、权限校验、日志记录等。
过滤器执行流程
1.Filter实例 package com.by.servlet; import javax.servlet.*; import java.io.IOException; public class FilterServletDemo implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } //真正执行过滤业务的方法 @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { //设置请求编码格式 servletRequest.setCharacterEncoding("UTF-8"); //设置响应编码格式 servletResponse.setContentType("text/html;charset=utf-8"); //获取前端传送过来的数据 System.out.println("请求进来，经过过滤器......"); //一个web路径，可以配置多个过滤器，这多个过滤器就被称为过滤器链 filterChain.doFilter(servletRequest,servletResponse); System.out.println("响应过去，经过过滤器....."); } @Override public void destroy() { } } 使用过滤器需要注意的事项：
1.过滤器必须实现Filter接口。
2.过滤器拦截的请求执行完毕之后，必须要放行，否则我们的请求就不会被执行。
filterChain.doFilter(request,response); //过滤器放行 3.在web.xml来配置过滤器要拦截的资源，当然我们也可以通过xml的方式配置过滤器。
&lt;filter&gt; &lt;filter-name&gt;filterServlet&lt;/filter-name&gt; &lt;filter-class&gt;com.by.servlet.FilterServletDemo&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filterServlet&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; Filter的拦截路径的配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dddbbf12280658872566757c04aa4800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb67bd9938402f5b5ceb092ac6fc44f3/" rel="bookmark">
			中间件系列 - Redis入门到实战(高级篇-最佳实践)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 学习视频： 黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目中间件系列 - Redis入门到实战本内容仅用于个人学习笔记，如有侵扰，联系删除学习目标 Redis键值设计批处理优化服务端优化集群最佳实践 1 Redis键值设计 1.1 优雅的key结构 Redis的Key虽然可以自定义，但最好遵循下面的几个最佳实践约定：
遵循基本格式：[业务名称]:[数据名]:[id]长度不超过44字节不包含特殊字符 例如：我们的登录业务，保存用户信息，其key可以设计成如下格式：
这样设计的好处：
可读性强避免key冲突方便管理更节省内存： key是string类型，底层编码包含int、embstr和raw三种。embstr在小于44字节使用，采用连续内存空间，内存占用更小。当字节数大于44字节时，会转为raw模式存储，在raw模式下，内存空间不是连续的，而是采用一个指针指向了另外一段内存空间，在这段空间里存储SDS内容，这样空间不连续，访问的时候性能也就会收到影响，还有可能产生内存碎片
1.2 拒绝BigKey BigKey通常以Key的大小和Key中成员的数量来综合判定，例如：
Key本身的数据量过大：一个String类型的Key，它的值为5 MBKey中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB 那么如何判断元素的大小呢？redis也给我们提供了命令
推荐值：
单个key的value小于10KB对于集合类型的key，建议元素数量小于1000 1.2.1 BigKey的危害 网络阻塞 对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢 数据倾斜 BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡 Redis阻塞 对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞 CPU压力 对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用 1.2.2 如何发现BigKey ①redis-cli --bigkeys 利用redis-cli提供的–bigkeys参数，可以遍历分析所有key，并返回Key的整体统计信息与每个数据的Top1的big key
命令：redis-cli -a 密码 --bigkeys
②scan扫描 自己编程，利用scan扫描Redis中的所有key，利用strlen、hlen等命令判断key的长度（此处不建议使用MEMORY USAGE）
scan 命令调用完后每次会返回2个元素，第一个是下一次迭代的光标，第一次光标会设置为0，当最后一次scan 返回的光标等于0时，表示整个scan遍历结束了，第二个返回的是List，一个匹配的key的数组
import com.heima.jedis.util.JedisConnectionFactory; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import redis.clients.jedis.Jedis; import redis.clients.jedis.ScanResult; import java.util.HashMap; import java.util.List; import java.util.Map; public class JedisTest { private Jedis jedis; @BeforeEach void setUp() { // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb67bd9938402f5b5ceb092ac6fc44f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a125404bd8039e5a4beaa8a63e3da388/" rel="bookmark">
			虚幻UE 光源-色温和光度学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、色温二、光度学1、lux勒克斯2、cd坎德拉3、nit尼特4、总结 三、EV曝光值 一、色温 色温可以简单的认为就是颜色的温度。
但他是有范围的，也是有要求的，并不是所有的颜色都可以有色温。
以上就是色温范围图。
而这些颜色的温度是怎么定义的呢？和我们平常的温度一样？
色温是指绝对黑体从绝对零度（约-273℃）开始加温后所呈现的颜色。黑体在受热后，会逐渐由黑变红，转黄，发白，最后发出蓝色光。当加热到一定的温度，黑体发出的光所含的光谱成分，就称为这一温度下的色温，计量单位为“K”（开尔文）。
注意：并不是所有有着色温表现的都是加热导致的，可能是其他原因，但呈现着色温特性。 绝对黑体是什么？
黑色是吸收任何颜色，不反射任何颜色的。所以绝对黑体也就是它能够吸收外来的全部电磁辐射，并且不会有任何的反射与透射的物体。
上图是人对于颜色的感知然后通过xy表示出来的一个标准，称为CIE 1931xy，z表示颜色的亮度。
中间那条黑体轨迹也就对应着色温，可以看出来，并不是所有颜色都有色温，如绿色，紫色等
在摄像中色温的代名词就是 白平衡。
常见的色温有哪些？
色温值代表物品1700 K火柴1850 K蜡烛2800 K白炽灯3000 K卤素灯4000 K下午阳光4300 K氙气灯5500 K中午阳光6420 K氙弧灯6500 K标准白平衡7000 K阴天8000 K氙气灯9300 K老式电视屏幕 二、光度学 光度学主要研究光的强度问题。
所以本段将展示三个光度学的单位：lux(lx) 勒克斯、cd坎德拉、nit（cd/m²） 尼特。
1、lux勒克斯 照度单位，即从被照物的角度 出发测量亮度的单位。
这也是UE中定向光源（太阳光）的单位，为什么去考虑被照物的亮度呢？
因为去考虑太阳的亮度，实在是没什么意义。
所以为了定义从被照物的角度去测量的亮度我们叫照度单位：lux勒克斯。
当照度一定，物体反射的光线越多，则越亮。
现实生活中我们使用照度计去测量：
常见的不同环境对应的照度值如下：
环境照度值晴天100000阴天500-10,000专柜750-3,000工业绘图750-1,500阅读500-1,000普通房间300-750暗室30-75街灯5-30满月0.2 因为晚上和早上太阳下山和升起会导致照度值不同，所以我们可以通过照度值去控制路灯的开关（当然还会有别的因素一起去判断）。
2、cd坎德拉 发光强度单位，指光源本身有多亮
并不是所有的光源的亮度都无意义，像灯泡、蜡烛、手电筒的光源亮度都很有意义。
所以形容UE内的这些点光源、聚光源、矩形光源都可以使用cd坎德拉来形容发光强度。
3、nit尼特 尼特的概念大家应该更熟悉，手机厂商（显示器）也都很喜欢用这个参数去展示它的屏幕。
亮度单位，也叫cd/m²。
从cd坎德拉光源发出的光的强度不一定就是我们肉眼感受到的。
我们人眼感受到的亮度就叫nit尼特，也就对应着cd/m²，每平方米的光源强度。
发光强度不变，照明面积越大则亮度越低。
4、总结 三、EV曝光值 在摄影中，我们最长听到这样一句话，曝光三要素：光圈、快门、ISO
那曝光值是什么呢？
曝光值就是用来描述光圈+快门组合后的拍摄亮度（应该还有ISO，这部分没这么听明白）
光圈f/1.4（数值越小，光圈越大）：光圈越大，进光量越多，景深越大，背景模糊越强。
快门1/1000(数值越小，快门越快) ：快门速度越快，拍摄越清晰，运动物体不会有运动模糊。
ISO1000（数值越大，感光越强）：感光越强，越容易出现噪点。
具体内容可以看下面这张图：
虚幻中的景深依赖于光圈，但最终亮度默认不考虑光圈值，且运动模糊可脱离快门单独设置，因此在虚幻中直接使用EV更方便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c13f9818e78915e0c7cc05cd28bfa36d/" rel="bookmark">
			java获取前一天/周/月/年的日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java获取前一天/周/月/年的日期
//获取前一天 Date beforeDate = Date.from(LocalDate.now().minusDays(1).atStartOfDay(). atZone(ZoneId.systemDefault()).toInstant()); //获取前一周 Date beforeDate = Date.from(LocalDate.now().minusWeeks(1).atStartOfDay(). atZone(ZoneId.systemDefault()).toInstant()); //获取前一个月 Date beforeDate = Date.from(LocalDate.now().minusMonths(1).atStartOfDay(). atZone(ZoneId.systemDefault()).toInstant()); //获取前一年 Date beforeDate = Date.from(LocalDate.now().minusYears(1).atStartOfDay(). atZone(ZoneId.systemDefault()).toInstant()); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30fb1788081638e64188dbe6c49ffb4d/" rel="bookmark">
			香橙派5plus从ssd启动Ubuntu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官方接口图 我实际会用到的就几个接口，背面的话就一个M.2固态的位置：
其中WIFI模块的接口应该也可以插2230的固态，不过是pcie2.0的速度，背面的接口则是pcie3.0*4的速度，差距还是挺大的。
开始安装系统 准备工作 一张内存卡(如果买的时候没有emmc的话)下载并安装balenaEtcher一个m.2固态硬盘读卡器(可选，有的电脑能直接插内存卡) 下载系统镜像 可选镜像看官网，我选择的是第三方维护的Ubuntu
香橙派5plus下载的是这个文件：
如果不知道自己的设备下载的哪个文件可以先打开Wiki看一下，比如
也可以去 https://joshua-riek.github.io/ubuntu-rockchip-download/这个链接下载。
系统刷入内存卡 刷入前先解压下下载的系统镜像，最后得到一个img格式的文件，然后在balenaEtcher里选择这个镜像和你的内存卡，点击现在烧录，等待烧录成功的提示。
启动系统 假设你现在已经将固态硬盘、内存卡和网线都插上了，现在只需要接通电源后将HDMI的接口接到显示器上，按下电源按钮，等待片刻。
电源按钮旁边的红灯会开始闪烁，然后显示器也会显示Ubuntu的启动画面，使用ip addr查看IP地址后，然后使用xshell连接到ssh。
先运行下sudo fdisk -l | grep nvme0n1查看下固态是否被识别，我以前买的杂牌固态不识别，换了下双十一新买的识别正常
主要看有没有/dev/nvme0n1这个设备
先将bootloader刷写到SPI Flash(时间较长，耐心等待): sudo u-boot-install-mtd /dev/mtdblock0
然后将系统复制到固态：
sudo ubuntu-rockchip-install /dev/nvme0n1
完成后关机，把内存卡取下来断电再接电系统应该就已经启动了，不需要再按电源键
默认启动顺序 这个bootloader默认加载系统的顺序
SD CardUSBNVMeeMMC 参考 http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/service-and-support/Orange-Pi-5-plus.htmlhttps://github.com/Joshua-Riek/ubuntu-rockchip/discussions/435 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5be708577447cd2cd5b9e8dacf3b982/" rel="bookmark">
			华为 AC&#43;FIT AP 直连二层组网直接转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组网需求
AC组网方式：直连二层组网。DHCP部署方式：AC作为DHCP服务器为AP和STA分配IP地址。业务数据转发方式：直接转发 拓扑图
一、交换机设置
1、基础配置，创建VLAN &lt;Huawei&gt;sys [Huawei]sys SW1 [SW1]un in en [SW1]vlan batch 2 3 2、设置交换机与AP下联接口，默认VLAN为2，以实现上游发送数据时剥离VLAN
[SW1]int g0/0/1 [SW1-GigabitEthernet0/0/1]p l t [SW1-GigabitEthernet0/0/1]p t p v 2 [SW1-GigabitEthernet0/0/1]p t a v a [SW1-GigabitEthernet0/0/1]quit 3、设置交换机与AC上联接口
[SW1]int g0/0/2 [SW1-GigabitEthernet0/0/2]p l t [SW1-GigabitEthernet0/0/2]p t a v a [SW1-GigabitEthernet0/0/2]quit 二、AC控制器设置
1、创建VLAN，为AP跟STA配置DHCP
&lt;AC6005&gt;sys [AC6005]sys AC1 [AC1]un in en [AC1]vlan batch 2 3 [AC1]int g0/0/1 [AC1-GigabitEthernet0/0/1]p l t [AC1-GigabitEthernet0/0/1]p t a v a [AC1-GigabitEthernet0/0/1]quit [AC1]dhcp enable # 配置DHCP为AP分配地址 [AC1]int vlanif 2 [AC1-Vlanif2]ip addr 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5be708577447cd2cd5b9e8dacf3b982/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d4e5155b52d2d5136bdd2d73154e56a/" rel="bookmark">
			【电商应用提升用户体验：抖音商品详情API的技术实践与优化策略无标题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在电商领域中，提升用户体验是持续追求的目标。抖音商品详情API作为一种强大的工具，为电商应用提供了丰富的数据和功能，使其能够更好地满足用户需求。本文将介绍如何利用抖音商品详情API来提升电商应用的用户体验，并探讨相关的技术实践与优化策略。
一、抖音商品详情API概述
抖音商品详情API是抖音开放平台提供的一种服务，允许电商应用获取抖音平台上的商品详情数据。通过这个API，电商应用可以获取商品的图片、视频、价格、销量等详细信息，为电商领域的商业决策提供有力依据。
二、利用抖音商品详情API提升用户体验的策略
1.实时获取商品信息
通过抖音商品详情API，电商应用可以实时获取商品信息，确保用户在浏览商品时获得最新、最准确的数据。这种实时性能够提高用户的信任度，并增强用户对应用的依赖性。
2.丰富的商品展示方式
利用抖音商品详情API返回的商品数据，电商应用可以采用更加生动、形象的展示方式呈现商品。例如，通过高清图片、短视频或3D模型等形式展示商品，让用户更加直观地了解商品的特点和细节。这种交互式的展示方式能够提高用户的参与度和购买意愿。
3.个性化推荐与定制化服务
通过分析抖音商品详情API返回的数据，电商应用可以更加准确地了解用户喜好和需求。基于这些信息，电商应用可以为用户提供个性化的推荐服务，推送符合其需求的商品。同时，应用还可以根据用户的购买记录和浏览习惯，定制个性化的服务和优惠方案，提高用户满意度和忠诚度。
4.便捷的购物流程与高效的物流配送
除了商品信息的展示和推荐外，电商应用还需要提供便捷的购物流程和高效的物流配送服务。通过抖音商品详情API返回的数据，电商应用可以优化购物流程，提高用户购买的便捷性和效率。同时，根据用户的地理位置和配送需求，应用可以合理安排物流配送，缩短配送时间，提升用户的购物体验。
5.用户反馈与互动机制
为了更好地了解用户对商品的满意度和需求，电商应用可以利用抖音商品详情API建立用户反馈与互动机制。通过收集用户对商品的评论、评分和投诉等信息，电商应用可以及时发现并解决潜在问题，改进商品和服务质量。同时，应用可以积极回复用户的评论和问题，与用户建立良好的互动关系，增强用户对应用的信任感和归属感。
三、技术实现示例（使用Python语言）
下面是一个简单的技术实现示例，演示如何使用Python调用抖音商品详情API并获取商品数据：
首先，需要安装Python的requests库：
pip install requests 然后，使用以下代码示例：
import requests import json # 定义抖音商品详情API的URL和请求参数 api_url = "https://api.douyin.com/v1/product/xxxxxx" # 替换为实际的API URL params = { "product_id": "xxxxxx", # 商品的ID或唯一标识符 "fields": "title,price,image_urls,video_urls,sales", # 需要获取的字段列表 # 其他可选参数... } # 发送HTTP请求并获取响应数据 response = requests.get(api_url, params=params) data = response.json() # 将响应数据解析为JSON格式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b092e42625d93950f4f73039f9f3332/" rel="bookmark">
			中间件系列 - Redis入门到实战(高级篇-分布式缓存)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 学习视频： 黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目
中间件系列 - Redis入门到实战
本内容仅用于个人学习笔记，如有侵扰，联系删除
学习目标
Redis持久化Redis主从Redis哨兵Redis分片集群 一 分布式缓存 - 基于Redis集群解决单机Redis存在的问题
单机的Redis存在四大问题：
1.Redis持久化 Redis有两种持久化方案：
RDB持久化AOF持久化 1.1.RDB持久化 RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。
1.1.1.执行时机 RDB持久化在四种情况下会执行：
执行save命令执行bgsave命令Redis停机时触发RDB条件时 1）save命令
执行下面的命令，可以立即执行一次RDB：
save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。
2）bgsave命令
下面的命令可以异步执行RDB：
这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。
3）停机时
Redis停机时会执行一次save命令，实现RDB持久化。
4）触发RDB条件
Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：
# 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save "" 则表示禁用RDB save 900 1 save 300 10 save 60 10000 RDB的其它配置也可以在redis.conf文件中设置：
# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱 rdbcompression yes # RDB文件名称 dbfilename dump.rdb # 文件保存的路径目录 dir ./ 1.1.2.RDB原理 bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。
fork采用的是copy-on-write技术：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b092e42625d93950f4f73039f9f3332/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/849ab9e5a6f97f80defe683f1e8b348a/" rel="bookmark">
			中间件系列 - Redis入门到实战(实战篇)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 学习视频： 黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目
中间件系列 - Redis入门到实战
本内容仅用于个人学习笔记，如有侵扰，联系删除
本章学习目标：
短信登录 这一块我们会使用redis共享session来实现
商户查询缓存 通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容
优惠卷秒杀 通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列
附近的商户 我们利用Redis的GEOHash来完成对于地理坐标的操作
UV统计 主要是使用Redis来完成统计功能
用户签到 使用Redis的BitMap数据统计功能
好友关注 基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下
达人探店 基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能
以上这些内容咱们统统都会给小伙伴们讲解清楚，让大家充分理解如何使用Redis
1 短信登录 1.1 导入黑马点评项目 1.1.1 导入SQL 1.1.2 有关当前模型 手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。
在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群使得Redis对外提供更好的服务。
1.1.3 导入后端项目 在资料中提供了一个项目源码：
1.1.4 导入前端工程 1.1.5 运行前端项目 1.2 基于Session实现登录流程 发送验证码：
用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号
如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户
短信验证码登录、注册：
用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息
校验登录状态:
用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行
1.3 实现发送短信验证码功能 页面流程
具体代码如下
贴心小提示：
具体逻辑上文已经分析，我们仅仅只需要按照提示的逻辑写出代码即可。
发送验证码
1、controller层
类路径：com.hmdp.controller.UserController
@Slf4j @RestController @RequestMapping("/user") public class UserController { @Resource private IUserService userService; /** * 发送手机验证码 */ @PostMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/849ab9e5a6f97f80defe683f1e8b348a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bab710ddb5f406ddf5a47485091eff9/" rel="bookmark">
			从零开发短视频电商 Sagemaker端点模型部署方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介多模型端点的工作原理设置SageMaker多模型端点模型缓存行为总结 https://docs.aws.amazon.com/zh_cn/sagemaker/latest/dg/realtime-endpoints-options.html
简介 分为两种模型托管方式
单一模型端点
多模型端点
将多个模型托管在一个容器内，通过一个端点提供服务 多模型端点提供了一种可扩展且成本效益的解决方案，用于部署大量模型。它们使用相同的资源池和共享的服务容器来托管所有模型。与使用单一模型端点相比，这降低了托管成本，因为提高了端点利用率。同时，由于Amazon SageMaker管理内存中的模型加载和根据端点的流量模式进行扩展，这也减少了部署的开销。
以下图示说明了多模型端点与单一模型端点的工作方式的对比。
多模型端点非常适合托管大量使用相同ML框架的模型，它们共享一个服务容器。如果您有一组经常访问和不经常访问的模型，多模型端点可以使用更少的资源和更高的成本节省高效地为这些流量提供服务。您的应用程序应该能够容忍偶尔冷启动相关的延迟，这些延迟发生在调用不经常使用的模型时。
多模型端点支持托管既支持CPU又支持GPU的模型。通过使用支持GPU的模型，您可以通过增加端点及其基础加速计算实例的使用来降低模型部署成本。
多模型端点还支持在模型之间共享内存资源的时间共享。当模型在大小和调用延迟上相当相似时，这种方式效果最好。在这种情况下，多模型端点可以有效地跨所有模型使用实例。如果您有具有显著较高每秒事务数（TPS）或延迟要求的模型，我们建议将它们托管在专用端点上。
多模型端点的工作原理 SageMaker 管理托管在多模型端点容器内的模型的生命周期。与在创建端点时将所有模型从Amazon S3存储桶下载到容器的方法不同，SageMaker 在调用时动态加载和缓存它们。当SageMaker收到对特定模型的调用请求时，它执行以下操作：
将请求路由到端点后面的实例。从S3存储桶下载模型到该实例的存储卷。将模型加载到容器的内存中（取决于您是否使用CPU或GPU支持的实例）在加速计算实例上。如果模型已经加载到容器的内存中，调用速度会更快，因为SageMaker无需再次下载和加载它。 SageMaker 继续将对模型的请求路由到已经加载该模型的实例。然而，如果该模型接收到许多调用请求，并且多模型端点有其他实例，SageMaker 将一些请求路由到另一个实例以适应流量。如果第二个实例上没有加载该模型，该模型将被下载到该实例的存储卷并加载到容器的内存中。
当实例的内存利用率较高且SageMaker需要将另一个模型加载到内存中时，它会从该实例的容器中卸载未使用的模型，以确保有足够的内存来加载模型。已卸载的模型仍然保留在实例的存储卷上，稍后可以将其加载到容器的内存中，而无需再次从S3存储桶下载。如果实例的存储卷达到其容量，SageMaker 将从存储卷中删除任何未使用的模型。
要删除模型，请停止发送请求并从S3存储桶中删除它。SageMaker 在一个服务容器中提供了多模型端点的能力。向多模型端点添加模型以及从中删除模型不需要更新端点本身。要添加模型，您将其上传到S3存储桶并调用它。您无需更改代码即可使用它。
注意 当您更新多模型端点时，端点上的初始调用请求可能会因多模型端点中的智能路由适应您的流量模式而经历较高的延迟。但是，一旦它学习了您的流量模式，您可以在使用最频繁的模型时体验低延迟。不经常使用的模型可能会因为模型被动态加载到实例上而产生一些冷启动延迟。
设置SageMaker多模型端点模型缓存行为 默认情况下，多模型端点将常用模型缓存在内存中（取决于您是否使用CPU或GPU支持的实例）和磁盘上，以提供低延迟的推理。缓存的模型仅在容器因内存或磁盘空间不足以容纳新的目标模型而卸载和/或删除时才会被卸载和/或删除。
您可以通过在调用create_model时设置参数ModelCacheSetting来更改多模型端点的缓存行为，并明确启用或禁用模型缓存。
我们建议将ModelCacheSetting参数的值设置为Disabled，用于不从模型缓存中获益的用例。例如，当需要从端点中服务大量模型，但每个模型只被调用一次（或非常不经常调用）时。对于这种用例，将ModelCacheSetting参数的值设置为Disabled可以使invoke_endpoint请求的事务每秒（TPS）比默认缓存模式更高。在这些用例中，高TPS是因为SageMaker在invoke_endpoint请求之后执行以下操作：
在调用后异步从内存中卸载模型并立即从磁盘中删除。为推理容器中的模型下载和加载提供更高的并发性。对于CPU和GPU支持的端点，并发性是容器实例的vCPUs数量的一个因素。 总结 多模型端点和专用端点都是Amazon SageMaker中用于托管机器学习模型的方式，它们适用于不同的使用场景和需求。以下是它们的优缺点和适用场景的总结：
多模型端点（Multi-Model Endpoints）
优点：
资源共享： 多模型端点允许在同一容器内托管多个模型，通过共享资源以提高端点的利用率。成本效益： 由于多个模型共享相同的计算资源，相比于专用端点，使用多模型端点可以减少托管成本。灵活性： 适用于部署大量模型，尤其是当这些模型使用相同的机器学习框架时。 缺点：
性能： 在某些情况下，多模型端点可能因为动态加载模型而引入一些冷启动延迟，尤其是对于不经常使用的模型。资源分配： 如果有明显不同的模型访问模式或延迟要求，多模型端点可能不如专用端点。 专用端点（Dedicated Endpoints）
优点：
性能： 专用端点通常提供更稳定和可控的性能，适用于对延迟要求较高的场景。定制化： 可以为每个端点定制独立的资源配置，以满足特定模型的要求。预测性： 适用于对端点性能和行为有明确预期的应用场景。 缺点：
成本： 由于资源独立分配，专用端点可能在资源利用率方面较多模型端点更昂贵。管理复杂性： 需要单独管理每个端点，可能会增加系统的复杂性和维护成本。 总结：
多模型端点： 适用于大规模部署相似或相对较小的模型，具有成本效益和资源共享的优势。
专用端点： 适用于对性能和资源分配有严格要求的场景，以及当模型异构性较大时。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ac380b058e0e1c8542a1fe7c407644d/" rel="bookmark">
			学会这10种定时任务，我有点飘了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好我是苏三，又跟大家见面了。 前言 最近有几个读者私信给我，问我他们的业务场景，要用什么样的定时任务。确实，在不用的业务场景下要用不同的定时任务，其实我们的选择还是挺多的。我今天给大家总结10种非常实用的定时任务，总有一种是适合你的。
一. linux自带的定时任务 crontab 不知道你有没有遇到过这种场景：有时需要临时统计线上的数据，然后导出到excel表格中。这种需求有时较为复杂，光靠写sql语句是无法满足需求的，这就需要写java代码了。然后将该程序打成一个jar包，在线上环境执行，最后将生成的excel文件下载到本地。
为了减小对线上环境的影响，我们一般会选择在凌晨1-2点，趁用户量少的时候，执行统计程序。（其实凌晨4点左右，用户才是最少的）
由于时间太晚了，我们完全没必要守在那里等执行结果，一个定时任务就能可以搞定。
那么，这种情况用哪种定时任务更合适呢？
答案是：linux系统的crontab。（不过也不排除有些项目没部署在linux系统中）
运行crontab -e，可以编辑定时器，然后加入如下命令：
0 2 * * * /usr/local/java/jdk1.8/bin/java -jar /data/app/tool.jar &gt; /logs/tool.log &amp; 就可以在每天凌晨2点，定时执行tool.jar程序，并且把日志输出到tool.log文件中。当然你也可以把后面的执行java程序的命令写成shell脚本，更方便维护。
使用这种定时任务支持方便修改定时规则，有界面可以统一管理配置的各种定时脚本。
crontab命令的基本格式如下：
crontab [参数] [文件名] 如果没有指定文件名，则接收键盘上输入的命令，并将它载入到crontab。
参数功能对照表如下：
参数功能-u指定用户-e编辑某个用户的crontab文件内容-l显示某个用户的crontab文件内容-r删除某用户的crontab文件-i删除某用户的crontab文件时需确认 以上参数，如果没有使用-u指定用户，则默认使用的当前用户。
通过crontab -e命令编辑文件内容，具体语法如下：
[分] [小时] [日期] [月] [星期] 具体任务 其中：
分，表示多少分钟，范围：0-59
小时，表示多少小时，范围：0-23
日期，表示具体在哪一天，范围：1-31
月，表示多少月，范围：1-12
星期，表示多少周，范围：0-7，0和7都代表星期日
还有一些特殊字符，比如：
*代表如何时间，比如：*1*** 表示每天凌晨1点执行。
/代表每隔多久执行一次，比如：*/5 **** 表示每隔5分钟执行一次。
,代表支持多个，比如：10 7,9,12 *** 表示在每天的7、9、12点10分各执行一次。
-代表支持一个范围，比如：10 7-9 *** 表示在每天的7、8、9点10分各执行一次。
此外，顺便说一下crontab需要crond服务支持，crond是linux下用来周期地执行某种任务的一个守护进程，在安装linux操作系统后，默认会安装crond服务工具，且crond服务默认就是自启动的。crond进程每分钟会定期检查是否有要执行的任务，如果有，则会自动执行该任务。
可以通过以下命令操作相关服务：
service crond status // 查看运行状态 service crond start //启动服务 service crond stop //关闭服务 service crond restart //重启服务 service crond reload //重新载入配置 使用crontab的优缺点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ac380b058e0e1c8542a1fe7c407644d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d7e42044993385577d07c8e25ec0f9/" rel="bookmark">
			2023 泛微流程统计 （流程耗时统计:归档周期，节点审批周期）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		---流程耗时统计:归档周期
select LEFT(Minoperatetime,4) as mYear, LEFT(Minoperatetime,7) mYearMonth,creater,createdate,createtime,
workflow_requestbase.requestid, requestmark, requestname,status ,
Minoperatetime,Maxoperatetime,
CAST ( CAST ( DATEDIFF ( ss, Minoperatetime, Maxoperatetime ) / ( 60 * 60 * 24 ) AS INT ) AS VARCHAR ) + '天' + CAST ( CAST ( DATEDIFF ( ss, Minoperatetime, Maxoperatetime ) % 86400 / 3600 AS INT ) AS VARCHAR ) + '小时' + CAST ( CAST ( DATEDIFF ( ss, Minoperatetime, Maxoperatetime ) % 3600 / 60 AS INT ) AS VARCHAR ) + '分' + CAST ( CAST ( DATEDIFF ( ss, Minoperatetime, Maxoperatetime ) % 60 AS INT ) AS VARCHAR ) + '秒' LengthOfTime
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2d7e42044993385577d07c8e25ec0f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311da9b323716d2c44cb8c749ade7229/" rel="bookmark">
			面试必考：秒杀系统的9个核心知识点，一次性打包给你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 高并发下如何设计秒杀系统？这是一个高频面试题。这个问题看似简单，但是里面的水很深，它考查的是高并发场景下，从前端到后端多方面的知识。
我的个人技术博客：https://susan.net.cn
秒杀一般出现在商城的促销活动中，指定了一定数量（比如：10个）的商品（比如：手机），以极低的价格（比如：0.1元），让大量用户参与活动，但只有极少数用户能够购买成功。这类活动商家绝大部分是不赚钱的，说白了是找个噱头宣传自己。
虽说秒杀只是一个促销活动，但对技术要求不低。下面给大家总结一下设计秒杀系统需要注意的9个细节。
1 瞬时高并发 一般在秒杀时间点（比如：12点）前几分钟，用户并发量才真正突增，达到秒杀时间点时，并发量会达到顶峰。
但由于这类活动是大量用户抢少量商品的场景，必定会出现狼多肉少的情况，所以其实绝大部分用户秒杀会失败，只有极少部分用户能够成功。
正常情况下，大部分用户会收到商品已经抢完的提醒，收到该提醒后，他们大概率不会在那个活动页面停留了，如此一来，用户并发量又会急剧下降。所以这个峰值持续的时间其实是非常短的，这样就会出现瞬时高并发的情况，下面用一张图直观的感受一下流量的变化：
像这种瞬时高并发的场景，传统的系统很难应对，我们需要设计一套全新的系统。可以从以下几个方面入手：
页面静态化
CDN加速
缓存
mq异步处理
限流
分布式锁
2. 页面静态化 活动页面是用户流量的第一入口，所以是并发量最大的地方。
如果这些流量都能直接访问服务端，恐怕服务端会因为承受不住这么大的压力，而直接挂掉。
活动页面绝大多数内容是固定的，比如：商品名称、商品描述、图片等。为了减少不必要的服务端请求，通常情况下，会对活动页面做静态化处理。用户浏览商品等常规操作，并不会请求到服务端。只有到了秒杀时间点，并且用户主动点了秒杀按钮才允许访问服务端。
这样能过滤大部分无效请求。
但只做页面静态化还不够，因为用户分布在全国各地，有些人在北京，有些人在成都，有些人在深圳，地域相差很远，网速各不相同。
如何才能让用户最快访问到活动页面呢？
这就需要使用CDN，它的全称是Content Delivery Network，即内容分发网络。
使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。
3 秒杀按钮 大部分用户怕错过秒杀时间点，一般会提前进入活动页面。此时看到的秒杀按钮是置灰，不可点击的。只有到了秒杀时间点那一时刻，秒杀按钮才会自动点亮，变成可点击的。
但此时很多用户已经迫不及待了，通过不停刷新页面，争取在第一时间看到秒杀按钮的点亮。
从前面得知，该活动页面是静态的。那么我们在静态页面中如何控制秒杀按钮，只在秒杀时间点时才点亮呢？
没错，使用js文件控制。
为了性能考虑，一般会将css、js和图片等静态资源文件提前缓存到CDN上，让用户能够就近访问秒杀页面。
看到这里，有些聪明的小伙伴，可能会问：CDN上的js文件是如何更新的？
秒杀开始之前，js标志为false，还有另外一个随机参数。当秒杀开始的时候系统会生成一个新的js文件，此时标志为true，并且随机参数生成一个新值，然后同步给CDN。由于有了这个随机参数，CDN不会缓存数据，每次都能从CDN中获取最新的js代码。此外，前端还可以加一个定时器，控制比如：10秒之内，只允许发起一次请求。如果用户点击了一次秒杀按钮，则在10秒之内置灰，不允许再次点击，等到过了时间限制，又允许重新点击该按钮。
4 读多写少 在秒杀的过程中，系统一般会先查一下库存是否足够，如果足够才允许下单，写数据库。如果不够，则直接返回该商品已经抢完。
由于大量用户抢少量商品，只有极少部分用户能够抢成功，所以绝大部分用户在秒杀时，库存其实是不足的，系统会直接返回该商品已经抢完。
这是非常典型的：读多写少 的场景。
如果有数十万的请求过来，同时通过数据库查缓存是否足够，此时数据库可能会挂掉。因为数据库的连接资源非常有限，比如：mysql，无法同时支持这么多的连接。
而应该改用缓存，比如：redis。
即便用了redis，也需要部署多个节点。
最近我建了新的技术交流群，打算将它打造成高质量的活跃群，欢迎小伙伴们加入。
我以往的技术群里技术氛围非常不错，大佬很多。
加微信：su_san_java，备注：加群，即可加入该群。
5 缓存问题 通常情况下，我们需要在redis中保存商品信息，里面包含：商品id、商品名称、规格属性、库存等信息，同时数据库中也要有相关信息，毕竟缓存并不完全可靠。
用户在点击秒杀按钮，请求秒杀接口的过程中，需要传入的商品id参数，然后服务端需要校验该商品是否合法。
大致流程如下图所示：
根据商品id，先从缓存中查询商品，如果商品存在，则参与秒杀。如果不存在，则需要从数据库中查询商品，如果存在，则将商品信息放入缓存，然后参与秒杀。如果商品不存在，则直接提示失败。
这个过程表面上看起来是OK的，但是如果深入分析一下会发现一些问题。
5.1 缓存击穿 比如商品A第一次秒杀时，缓存中是没有数据的，但数据库中有。虽说上面有如果从数据库中查到数据，则放入缓存的逻辑。
然而，在高并发下，同一时刻会有大量的请求，都在秒杀同一件商品，这些请求同时去查缓存中没有数据，然后又同时访问数据库。结果悲剧了，数据库可能扛不住压力，直接挂掉。
如何解决这个问题呢？
这就需要加锁，最好使用分布式锁。
当然，针对这种情况，最好在项目启动之前，先把缓存进行预热。即事先把所有的商品，同步到缓存中，这样商品基本都能直接从缓存中获取到，就不会出现缓存击穿的问题了。
是不是上面加锁这一步可以不需要了？
表面上看起来，确实可以不需要。但如果缓存中设置的过期时间不对，缓存提前过期了，或者缓存被不小心删除了，如果不加速同样可能出现缓存击穿。
其实这里加锁，相当于买了一份保险。
5.2 缓存穿透 如果有大量的请求传入的商品id，在缓存中和数据库中都不存在，这些请求不就每次都会穿透过缓存，而直接访问数据库了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/311da9b323716d2c44cb8c749ade7229/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed39d72af767c941034eb278ca51a7c4/" rel="bookmark">
			百万级数据excel导出功能如何实现？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近我做过一个MySQL百万级别数据的excel导出功能，已经正常上线使用了。
这个功能挺有意思的，里面需要注意的细节还真不少，现在拿出来跟大家分享一下，希望对你会有所帮助。
原始需求：用户在UI界面上点击全部导出按钮，就能导出所有商品数据。
咋一看，这个需求挺简单的。
但如果我告诉你，导出的记录条数，可能有一百多万，甚至两百万呢？
这时你可能会倒吸一口气。
因为你可能会面临如下问题：
如果同步导数据，接口很容易超时。如果把所有数据一次性装载到内存，很容易引起OOM。数据量太大sql语句必定很慢。相同商品编号的数据要放到一起。如果走异步，如何通知用户导出结果？如果excel文件太大，目标用户打不开怎么办？ 我们要如何才能解决这些问题，实现一个百万级别的excel数据快速导出功能呢？
1.异步处理 做一个MySQL百万数据级别的excel导出功能，如果走接口同步导出，该接口肯定会非常容易超时。
因此，我们在做系统设计的时候，第一选择应该是接口走异步处理。
说起异步处理，其实有很多种，比如：使用开启一个线程，或者使用线程池，或者使用job，或者使用mq等。
为了防止服务重启时数据的丢失问题，我们大多数情况下，会使用job或者mq来实现异步功能。
1.1 使用job 如果使用job的话，需要增加一张执行任务表，记录每次的导出任务。
用户点击全部导出按钮，会调用一个后端接口，该接口会向表中写入一条记录，该记录的状态为：待执行。
有个job，每隔一段时间（比如：5分钟），扫描一次执行任务表，查出所有状态是待执行的记录。
然后遍历这些记录，挨个执行。
需要注意的是：如果用job的话，要避免重复执行的情况。比如job每隔5分钟执行一次，但如果数据导出的功能所花费的时间超过了5分钟，在一个job周期内执行不完，就会被下一个job执行周期执行。
所以使用job时可能会出现重复执行的情况。
为了防止job重复执行的情况，该执行任务需要增加一个执行中的状态。
具体的状态变化如下：
执行任务被刚记录到执行任务表，是待执行状态。当job第一次执行该执行任务时，该记录再数据库中的状态改为：执行中。当job跑完了，该记录的状态变成：完成或失败。 这样导出数据的功能，在第一个job周期内执行不完，在第二次job执行时，查询待处理状态，并不会查询出执行中状态的数据，也就是说不会重复执行。
此外，使用job还有一个硬伤即：它不是立马执行的，有一定的延迟。
如果对时间不太敏感的业务场景，可以考虑使用该方案。
1.2 使用mq 用户点击全部导出按钮，会调用一个后端接口，该接口会向mq服务端，发送一条mq消息。
有个专门的mq消费者，消费该消息，然后就可以实现excel的数据导出了。
相较于job方案，使用mq方案的话，实时性更好一些。
对于mq消费者处理失败的情况，可以增加补偿机制，自动发起重试。
RocketMQ自带了失败重试功能，如果失败次数超过了一定的阀值，则会将该消息自动放入死信队列。
2.使用easyexcel 我们知道在Java中解析和生成Excel，比较有名的框架有Apache POI和jxl。
但它们都存在一个严重的问题就是：非常耗内存，POI有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。
百万级别的excel数据导出功能，如果使用传统的Apache POI框架去处理，可能会消耗很大的内存，容易引发OOM问题。
而easyexcel重写了POI对07版Excel的解析，之前一个3M的excel用POI sax解析，需要100M左右内存，如果改用easyexcel可以降低到几M，并且再大的Excel也不会出现内存溢出；03版依赖POI的sax模式，在上层做了模型转换的封装，让使用者更加简单方便。
需要在maven的pom.xml文件中引入easyexcel的jar包：
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/dependency&gt; 之后，使用起来非常方便。
读excel数据非常方便：
@Test public void simpleRead() { String fileName = TestFileUtil.getPath() + "demo" + File.separator + "demo.xlsx"; // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭 EasyExcel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed39d72af767c941034eb278ca51a7c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50f9affb67ec33f443114853e854a225/" rel="bookmark">
			windows脚本 批量删除指定文件夹、指定文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 用于批量删除项目中的测试数据，提供用户纯净的软件。
使用说明：
创建一个bat脚本，粘贴源码。
修改file_list和folder_list对应的数据，来自定义删除的内容
效果图 源码 @echo off chcp 65001 &gt; nul 2&gt;&amp;1 REM 设置文件列表，可以包含多个文件路径和文件夹路径，每个路径用空格分隔 set "file_list=1\2 1\*" set "file_list=%file_list% 11" REM 循环遍历文件列表并删除文件 for %%F in (%file_list%) do ( if exist "%%F" ( del /f /q "%%F" echo 删除文件 '%%F' 成功。 ) else ( echo 文件 '%%F' 不存在，无需删除。 ) ) REM 循环遍历文件夹列表并删除文件夹 for %%D in (%folder_list%) do ( if exist "%%D" ( rd /s /q "%%D" echo 删除文件夹 '%%D' 成功。 ) else ( echo 文件夹 '%%D' 不存在，无需删除。 ) ) REM 这里是脚本的其他部分，不会因为文件或文件夹不存在而受影响，可以继续运行。 pause 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89ea59a9cee14f8603c25165a3238c60/" rel="bookmark">
			Spring Security入门5：创建首个HelloWorld项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页：Designer 小郑
作者简介：3年JAVA全栈开发经验，专注JAVA技术、系统定制、远程指导，致力于企业数字化转型，CSDN博客专家，阿里云社区专家博主，蓝桥云课讲师。
一、创建新的 Spring Boot 项目 首先，请同学们在你本地的IDE中创建一个新的Maven项目，选择 Spring Initializr 作为项目的初始化方式。
在项目元数据中，选择你的项目坐标（Group/Artifact）、语言（Java/Kotlin/Scala等）和 SpringBoot 的版本。
添加所需的依赖项，至少包括 spring-boot-starter-web，它将提供用于创建 Web 应用程序的基本功能。
请同学们在本地项目中创建一个新的Java类，比如 HelloWorldController.java。
import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloWorldController { @GetMapping("/") public String helloWorld() { return "Hello World"; } } 请同学们运行应用程序，同学们可以使用IDE中的运行按钮或者使用命令行运行 mvn spring-boot:run。
打开浏览器，访问 http://localhost:8080/，就看到 “Hello World” 的输出。
同学们创建了一个RestController类HelloWorldController，它映射到根路径/。
在 helloWorld() 方法中，我们返回字符串"Hello World"，当同学们访问根路径时，SpringBoot会调用该方法并将字符串返回给浏览器。
二、引入 Spring Security 依赖 在 pom.xml 文件中，添加以下依赖可以引入Spring Security。
&lt;dependencies&gt; &lt;!-- Spring Security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 这里使用 spring-boot-starter-security 作为 Spring Security 的依赖项，这个依赖项包含了 Spring Security 的核心库以及与Spring Boot集成所需的其他依赖项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89ea59a9cee14f8603c25165a3238c60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21e647dd84ebe746f92697f52d564eb3/" rel="bookmark">
			【年度总结】互联网不行了？对IT技术行业的深度思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /bin/bash 目录
一、互联网寒冬的内涵和表现
二、互联网寒冬对我们有以下几方面的影响
三、程序员如何如何挺过寒冬，我认为有以下几点建议
近年来，中国互联网行业经历了从高速增长到低速增长，甚至负增长的转变，一些曾经风光无限的互联网公司也遭遇了业绩下滑、股价暴跌、裁员潮等困境，人们纷纷感叹互联网的寒冬已至。那么，中国互联网寒冬的根本原因是什么？我们又该如何应对和突破呢？本文将从以下几个方面来分析：
一、互联网寒冬的内涵和表现 首先，我们要明确互联网寒冬的内涵和表现。所谓互联网寒冬，并不是指互联网行业本身的衰败或消亡，而是指互联网行业在经历了一段快速发展和繁荣之后，进入了一个调整和转型的阶段，表现为市场需求、用户规模、营收利润、创新活力等方面的放缓或下降。
具体来说，互联网寒冬主要有以下几个方面的表现：
1、市场需求饱和。随着中国经济增速放缓、消费升级趋势减弱、人口红利消失等因素的影响，中国互联网市场的需求增长趋于饱和或下降。根据工信部数据，2022年上半年，全国规模以上的互联网及相关服务企业完成的互联网业务收入为7170亿元（人民币，下同），同比仅增长了0.1%，与之对比，2021年上半年这一数字为6951亿元，同比增长25.6%。
2、用户规模停滞。随着中国智能手机普及率接近饱和、移动网络覆盖率达到高水平、用户获取成本不断上升等因素的影响，中国互联网用户规模增长趋于停滞或下降。根据CNNIC数据，截至2022年6月，中国网民规模达到10.62亿人，较2021年底仅增加了1400万人；而截至2021年6月，中国网民规模达到9.88亿人，较2020年底增加了4400万人。
3、 营收利润下滑。随着中国互联网广告市场竞争加剧、监管政策收紧、用户付费意愿低迷等因素的影响，中国互联网公司的营收利润增长趋于下滑或下降。根据QuestMobile数据，2022年第二季度，中国互联网广告规模为1474.4亿元，同比减少了7.6%，而在2020年和2021年的第二季度，互联网广告规模的同比变化率还分别为增长19.3%和增长19.6%。
4、创新活力不足。随着中国互联网行业竞争格局趋于稳定、垄断现象日益严重、创业环境恶化等因素的影响，中国互联网行业的创新活力不足或缺乏。根据IT桔子数据，2022年上半年，在A轮及以上融资中获得投资的创业公司数量为1018家，较2021年上半年减少了28.5%；而在天使轮及Pre-A轮融资中获得投资的创业公司数量为1729家，较2021年上半年减少了36.7%。
5、发展重点转移。以前我们都说学计算机，这好、那好的，但是学计算机，到底学的是什么？前端？后端？运维？等等，各种技术非常多，从以前的c到c++，再到python，golang，各种语言层出不穷，到底学什么？当前市面上仍存在诸多教培机构，专门培养短期的计算机工作者，计算机专业有将如何发展？尤其是当前大模型，大数据，人工智能AI，chatgpt的发展，低代码能力计算机工作者被逐步代替，互联网寒冬，老板们的降本提效，恨不得你一个人干全栈、又搞开发、又干运维，然后给你开一个单人的工资，要是你，你去吗？
二、互联网寒冬对我们有以下几方面的影响 1、对于互联网公司来说，寒冬意味着更大的竞争压力和更高的生存门槛。一些优秀的互联网公司将借此机会进行优化调整和战略转型，提升自身实力和竞争力；而一些落后或不合规的互联网公司将面临淘汰或重组的命运。
2、对于互联网从业者来说，寒冬意味着更少的就业机会和更高的职业要求。一些有能力和经验的互联网从业者将获得更多的发展空间和回报；而一些缺乏能力或经验的互联网从业者将面临失业或转行的困境。
3、对于互联网用户来说，寒冬意味着更好的产品质量和更多的权益保障。一些优质和合规的互联网产品将获得更多用户的认可和支持；而一些劣质或不合规的互联网产品将被淘汰或整改。
三、程序员如何如何挺过寒冬，我认为有以下几点建议 （一）技术学习
在 T行业中，技术是核心竟争力。因此，不断学习和提升技术水平是非常重要的。以下是我在技术学习方面的心得:
1，多角度学习:IT 行业涉及的领域广泛，包括软件开发、网络安全、数据库管理等等。在学习过程中，要有广度和深度，多角度了解不同领域的知识。
2.注重实践:理论知识很重要，但实践能够真正提升自己。通过参与项目、解决实际问题等方式，将理论应用到实践中，不断积累经验
3.跟上科技发展:T 行业的技术更新换代非常快，要及时了解新的技术趋势和发展动态，不断学习新知识和新技术，保持自己的竞争力。
（二）职业发展
在 IT 行业中，职业发展也是大家关注的话题。以下是我在职业发展方面的心得:
1.设定目标:明确自己想要达到的职业目标，并制定相应的计划。
要根据自身兴趣和优势选择适合自己的方向，并不断努力追求。
2.持续学习:在技术学习的基础上，还要注重其他方面的能力提升,包括沟通能力、团队协作能力、领导力等。这些综合能力对于职业发展同样至关重要。
3.拓宽视野:IT 行业与其他行业密切联系，要保持对其他领域的关注和了解，拓宽自己的职业发展路径。
（三）行业趋势
随着科技的进步，IT 行业也在不断发展和变化。以下是我对行业趋势的一些观察和体会:
1.人工智能的兴起:人工智能是当今IT 行业的热点和趋势之一。在未来，随着人工智能的应用越来越广泛，IT 行业将迎来更多的机遇和挑战。
2.云计算与大数据:云计算和大数据技术的发展，为IT 行业带来了新的增长点。未来的IT 行业将更加依赖云计算和大数据技术，因此在这方面的学习和掌握也非常重要。
3.安全与隐私保护:随着网络安全问题的日益凸显，安全与隐私保护成为 IT 行业的重要议题。未来，IT 行业将继续加强对安全与隐私的保护，为用户提供更加安全可靠的服务。
以上是我在 IT 行业多年来的心得体会。只有不断学习和提升自己,才能在这个竞争激烈的行业中保持竞争力。相信通过不断努力，我们都能在 IT 行业取得成功!
hello world 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eefb22a0a84073cfdb5aff56937b386c/" rel="bookmark">
			企业数据防泄密解决方案！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PC访问地址：
https://isite.baidu.com/site/wjz012xr/2eae091d-1b97-4276-90bc-6757c5dfedee
数据防泄密解决方案有： 透明加密文件：计算机中常用文档类型可以加密，打开加密文档类型下的文件后，文件将自动变为加密状态。
文件操作审计和自动备份：在电脑中打开文件可以进行自动审计，自动备份操作的文件，可以防止文件被删除或丢失。
usb文件操作审计：可以在计算机上对使用U盘中的文件进行操作记录。
第三方身份验证：现在有许多基于标准且高度安全的身份验证产品可供选择。
禁用USB接口：可以有效防止恶意的数据拷贝。
控制网络访问权限：网站白名单，只允许访问工作需要的网站，其他一律禁止掉。
控制内部文件访问权限：比如销售类企业要保护的就是客户的信息。
移动端访问地址：
https://aisite.wejianzhan.com/site/wjz012xr/971c4604-0613-4200-bbcb-1e72f43c19ef
#数据防泄密解决方案#
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ed38da6f3c5ef4b1833938b9b7dd25/" rel="bookmark">
			「天锐绿盾」——电脑文件透明加密软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天锐绿盾是一款电脑文件透明加密软件 该软件基于核心驱动层的透明加密技术，能对企业信息化提供一体化安全管理方案，不仅不改变操作习惯，而且也不降低工作效率，可以有效地防止数据信息泄露。
天锐绿盾主要包括：终端安全管理系统、文档加密软件、上网行为管理软件、桌面管理软件、移动介质管控软件等
PC访问地址：
https://isite.baidu.com/site/wjz012xr/2eae091d-1b97-4276-90bc-6757c5dfedee
透明加密是一种针对企业文件数据保密需求应运而生的一种文件加密技术。 透明加密技术是一种核心驱动层的加密技术，在用户使用过程中不改变操作习惯，不降低工作效率，可以有效地保护文件数据的安全。
透明加密的应用场景有：
内部文件流通。
外发。
服务器存储。
员工出差。
使用加密文件过程中可以禁止进行复制、剪切、打印、截屏等操作。
透明加密技术原理 透明加密技术是与Windows、Mac、Linux紧密结合的一种技术，工作于操作系统的底层。通过监控应用程序对文件的操作，在打开文件时自动对密文进行解密，在写文件时自动将内存中的明文加密写入存储介质，从而保证存储介质上的文件始终处于加密状态。
透明加密和普通加密的区别在于加密的方式和用户感知度不同 透明加密。通过驱动层动态加解密技术，对企业内部所有涉密文档进行强制加密处理，从文件创建开始即可自动加密保护。
普通加密。需要用户手动加密和解密，增加用户负担。
支持任意类型文件、文档、图纸、源代码、音视频等！
移动端访问地址：
https://aisite.wejianzhan.com/site/wjz012xr/971c4604-0613-4200-bbcb-1e72f43c19ef
#文件透明加密软件#
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f6b4daae0cbe88551bc59a15ca2a7f4/" rel="bookmark">
			数据库的结构与模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库技术中采用分级的方法将数据库的结构划分为多个层次。最著名的是美国ANSI/ SPARC 数据库系统研究组 1975年提出的三级划分法，如图 3-1 所示。
1．三级抽象
数据库系统划分为三个抽象级：用户级、概念级、物理级。
（1）用户级数据库。用户级数据库对应于外模式，是最接近用户的一级数据库，是用户可以看到和使用的数据库，又称用户视图。用户级数据库主要由外部记录组成，不同的用户视图可以互相重叠，用户的所有操作都是针对用户视图进行的。
（2）概念级数据库。概念级数据库对应于概念模式，介于用户级和物理级之间，是所有用户视图的最小并集，是数据库管理员可看到和使用的数据库，又称 DBA（DataBase Administrator，数据库管理员）视图。概念级数据库由概念记录组成，一个数据库可有多个不同的用户视图，每个用户视图由数据库某一部分的抽象表示所组成。一个数据库应用系统只存在一个 DBA 视图，它把数据库作为一个整体的抽象表示。概念级模式把用户视图有机地结合成一个整体，综合平衡考虑所有用户要求，实现数据的一致性、最大限度降低数据冗余、准确地反映数据间的联系。
（3）物理级数据库。物理级数据库对应于内模式，是数据库的低层表示，它描述数据的实际存储组织，是最接近于物理存储的级，又称内部视图。物理级数据库由内部记录组成，物理级数据库并不是真正的物理存储，而是最接近于物理存储的级。
2．三级模式
数据库系统的三级模式为外模式、概念模式、内模式。
（1）概念模式。概念模式（模式、逻辑模式）用以描述整个数据库中数据库的逻辑结构，描述现实世界中的实体及其性质与联系，定义记录、数据项、数据的完整性约束条件及记录之间的联系，是数据项值的框架。
数据库系统概念模式通常还包含有访问控制、保密定义、完整性检查等方面的内容，以及概念/物理之间的映射。
概念模式是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个概念模式。
（2）外模式。外模式（子模式、用户模式）用以描述用户看到或使用的那部分数据的逻辑结构，用户根据外模式用数据操作语句或应用程序去操作数据库中的数据。外模式主要描述组成用户视图的各个记录的组成、相互关系、数据项的特征、数据的安全性和完整性约束条件。
外模式是数据库用户（包括程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。一个数据库可以有多个外模式。一个应用程序只能使用一个外模式。
（3）内模式。内模式是整个数据库的最低层表示，不同于物理层，它假设外存是一个无限的线性地址空间。内模式定义的是存储记录的类型、存储域的表示以及存储记录的物理顺序，指引元、索引和存储路径等数据的存储组织。
内模式是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。一个数据库只有一个内模式。
内模式、模式和外模式之间的关系如下：
（1）模式是数据库的中心与关键；
（2）内模式依赖于模式，独立于外模式和存储设备；
（3）外模式面向具体的应用，独立于内模式和存储设备；
（4）应用程序依赖于外模式，独立于模式和内模式。
3．两级独立性
数据库系统两级独立性是指物理独立性和逻辑独立性。三个抽象级间通过两级映射（外模式—模式映射，模式—内模式映射）进行相互转换，使得数据库的三级形成一个统一的整体。
（1）物理独立性。物理独立性是指用户的应用程序与存储在磁盘上的数据库中的数据是相互独立的。当数据的物理存储改变时，应用程序不需要改变。
物理独立性存在于概念模式和内模式之间的映射转换，说明物理组织发生变化时应用程序的独立程度。
（2）逻辑独立性。逻辑独立性是指用户的应用程序与数据库中的逻辑结构是相互独立的。当数据的逻辑结构改变时，应用程序不需要改变。
逻辑独立性存在于外模式和概念模式之间的映射转换，说明概念模式发生变化时应用程序的独立程度。
逻辑独立性比物理独立性更难实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd63b335c11a6837fa16f2c382e19404/" rel="bookmark">
			mysql除法运算保留小数的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参照：MySQL数据类型DECIMAL用法 - 森林木马 - 博客园
在工作中会遇到计算小数而且需要显现出小数末尾的0，我们会用到DECIMAL这个函数，这是一个函数非常强悍：具体用法DECIMAL(P,D);
在上面的语法中：
P是表示有效数字数的精度。 P范围为1〜65。
D是表示小数点后的位数。 D的范围是0~30。MySQL要求D小于或等于(&lt;=)P。
DECIMAL(P，D)表示列可以存储D位小数的P位数。十进制列的实际范围取决于精度和刻度。
与INT数据类型一样，DECIMAL类型也具有UNSIGNED和ZEROFILL属性。 如果使用UNSIGNED属性，则DECIMAL UNSIGNED的列将不接受负值。
如果使用ZEROFILL，MySQL将把显示值填充到0以显示由列定义指定的宽度。 另外，如果我们对DECIMAL列使用ZERO FILL，MySQL将自动将UNSIGNED属性添加到列。
测试案例：
数据库的表结构
第一种计算方式：
select convert(t/100,decimal(15,2)) as money from test select convert(t/100,decimal(10,2)) as money from test 第二种计算方式
返回数字X，截断到D小数位。 如果D为0，结果没有小数点或小数部分。 D是负数，导致值X的小数点左边的D数字变为零。（简单说就是没有四舍五入）
SELECT TRUNCATE(t/100,2) as g from test select convert(4545.1366,decimal(10,3)); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a681d94a7ba02a2c5011f3d7c53c89ed/" rel="bookmark">
			k8s调度priorities
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/47/">«</a>
	<span class="pagination__item pagination__item--current">48/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/49/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>