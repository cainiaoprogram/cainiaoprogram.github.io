<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aca0a2d5526fbfda0ecebe2e7312744/" rel="bookmark">
			微信小程序 云开发 WeUI组件Uploader 报错upload file fail, urls not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上传到云存储的方法
function uploadFile(cloudParentPath, filePath){ var temps = filePath.split('.') var cloudPath = cloudParentPath + app.globalData.openid + '_' + new Date().getTime() + '.' + temps[temps.length -1] console.log(cloudPath) return new Promise((resolve, reject) =&gt; { wx.cloud.uploadFile({ cloudPath: cloudPath, // 上传至云端的路径 filePath: filePath, // 小程序临时文件路径 success: res =&gt; { // 返回文件 ID console.log(res) resolve(res.fileID) }, fail: error =&gt; { console.error(error) reject(error) } }) }) } wxml
&lt;mp-uploader bindfail="uploadError" bindsuccess="uploadSuccess" select="{{selectFile}}" upload="{{uplaodFile}}" files="{{files}}" max-count="3" title="图片上传" tips="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aca0a2d5526fbfda0ecebe2e7312744/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7527cd98bd09fcc5aea3d139c62e72df/" rel="bookmark">
			Unity Editor 小工具 选择文件夹批量修改Texture属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作为笔记记录下： 工作中经常大量导入图片，但文件夹比较多，如果一个设置比较麻烦，所以就写连这个小工具。批量修改选中文件夹下的所有图片属性转为 Sprite2D
[MenuItem("Tools/SetTexture To Sprite")] public static void SelectTex() { Object[] textures = Selection.GetFiltered&lt;Texture2D&gt;(SelectionMode.DeepAssets); int index = 0; int total = textures.Length; foreach (Texture2D texture in textures) { string path = AssetDatabase.GetAssetPath(texture); TextureImporter texImporter = AssetImporter.GetAtPath(path) as TextureImporter; //不处理类型为“Lightmap”的Texture if ("Lightmap" != texImporter.textureType.ToString()) { texImporter.textureType = TextureImporterType.Sprite; AssetDatabase.ImportAsset(path); } EditorUtility.DisplayCancelableProgressBar("执行中...", index+"/" + total, (float)index / total); index++; } EditorUtility.ClearProgressBar(); AssetDatabase.Refresh(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e1446bcbed99d09e4fba6c9c79a78ca/" rel="bookmark">
			剑指offer47 礼物的最大价值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单记录下动态规划中，扩充边界兼容处理边界问题
源自于题解评论中
题目：https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/
class Solution { public int maxValue(int[][] grid) { int n = grid.length, m = grid[0].length; int[][] dp = new int[n+1][m+1]; //这里扩充边界，最外面都是0 for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1]; } } return dp[n][m]; } } 要简洁、优雅👍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f8e1165873424617e7193126cc0298/" rel="bookmark">
			FileCoin 挖矿实战-基础命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础命令 启动创建完整的 CAR 快照在首次启动 daemon 的时候执行导入快照初始化矿工创建钱包备份钱包创建矿工 修改 Miner 配置修改 API 连接配置，主要用于 worker 连接 miner修改 [Storage] 选项，将密封相关的任务全部分配给 worker 去做 使用远程 lotus daemon配置你的 lotus daemon config.toml 文件 启动 lotus-miner启动 lotus-worker(1) 启动一个只接 P1 任务的 worker(2) 启动一个可以同时接 P1 和 P2 任务的 worker(3) 启动一个只接 C2 任务的 worker查看已经连接到 miner 的 worker 列表质押扇区，启动挖矿查询当前集群的任务分配情况 启动 lotus daemon &gt; daemon.log 创建完整的 CAR 快照 lotus chain export &lt;filename&gt; 命令你可以导出一个完整的 lotus chain 快照。不过这个快照比较大，可能超过 100 GB。你也可以只导出最新的区块，跳过以前的旧消息。–recent-stateroots 参数指定要导出的状态根数。 --skip-old-msgs 参数表示只导出那些 stateroots 直接引用的区块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2f8e1165873424617e7193126cc0298/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7291ac762769ae4bf7b77ff66774ec26/" rel="bookmark">
			C&#43;&#43;数组去重的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Set 利用Set的特点：自动除重、自动排序
set&lt;char&gt; ab; for(int i=0;i&lt;m;i++) ab.insert(aa[i]); //这里的aa[i]是前面需要去重的数组 for(set&lt;char&gt;::iterator i=ab.begin();i!=ab.end();i++) cout&lt;&lt;*i; //注意指针运算符 去重并且排序了 2.字符串操作 int main() { char str[100]; int i=0,j; printf("input a string \n"); gets(str); while(i&lt;strlen(str)) { j=i+1; printf("delelte result %d\n",strlen(str)); while(j&lt;strlen(str)) { if(str[j]==str[i]) { str[j]='\0'; strcat(str,str+j+1) ; } else j++; } i++ ; } puts(str); } 3.字符数组 #define MAXSIZE 100 int main() { char array[MAXSIZE]; char del; //要删除的元素 int len, i, j; printf( "请输入数据:"); gets( array ); printf( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7291ac762769ae4bf7b77ff66774ec26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/546aaf083269201d2228005d269861d9/" rel="bookmark">
			Android——一个简单的智能家居系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个简单的智能家居系统 效果展示启动应用界面登陆界面导航界面温度界面湿度界面烟雾传感器界面人体红外传感器界面 效果展示 以下为整个程序的操作流程，因为CSDN不能上传太大文件，所以画质比较模糊。
启动应用界面 先来看一下启动界面：效果图如下：
这是一个比较简单的布局由一个ImageView,Textview,Switch组成
其中Switch组件的样式由俩个文件组成，thumb.xml,track.xml(都在Drawable文件里面创建)
thumb.xml文件代码：
其实两个Item都是一样的效果，因为thumb代表的滑动的轨迹，可以理解为滑块。一个是被按下的状态，一个是普通时的状态
&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_checked="true" android:drawable="@drawable/open_thumb"/&gt; &lt;item android:drawable="@drawable/shut_thumb"/&gt; &lt;/selector&gt; 因为两个item都是一样的，那我们就分析其中一个item,下面为滑块的效果
open_thumb.xml代码如下：
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle" &gt; &lt;!-- 高度40 --&gt; &lt;size android:height="40dp" android:width="40dp"/&gt; &lt;!-- 圆角弧度 20 --&gt; &lt;corners android:radius="20dp"/&gt; &lt;!-- 渐变色 --&gt; &lt;gradient android:endColor="#eeeeee" android:startColor="#eeeeee" /&gt; &lt;!--描边的大小和颜色--&gt; &lt;stroke android:width="1dp" android:color="#33da33"/&gt; &lt;/shape&gt; 我们接下来看一下承载滑块容易的track.xml他们同样表示两种状态，但他们是不一样的效果，因为为了突出滑动与未滑动的区别，所以背景色不一样，代码如下：
&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_checked="true" android:drawable="@drawable/open_track"/&gt; &lt;item android:drawable="@drawable/shut_track"/&gt; &lt;/selector&gt; 我们看一个open_track.xml文件效果和代码
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;!-- 高度30 此处设置宽度无效--&gt; &lt;size android:height="40dp"/&gt; &lt;!-- 圆角弧度 15 --&gt; &lt;corners android:radius="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/546aaf083269201d2228005d269861d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bc5cea64ce392b9798472cbea917cfb/" rel="bookmark">
			通过HTML5构建Web页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、新建HTML目录和文件 二、开发教程（VS Code） （一）HTML解析
1、元素：&lt;head&gt;，&lt;title&gt;，&lt;body&gt;，&lt;header&gt;，&lt;footer&gt;，&lt;article&gt;，&lt;section&gt;，&lt;p&gt;，&lt;div&gt;，&lt;span&gt;，&lt;img&gt;，&lt;aside&gt;，&lt;audio&gt;，&lt;canvas&gt;，&lt;datalist&gt;，&lt;details&gt;，&lt;embed&gt;，&lt;nav&gt;，&lt;output&gt;，&lt;progress&gt;，&lt;video&gt; 等等
2、注释
用&lt;!--和--&gt;包括起来
3、空元素
&lt;br&gt;, &lt;hr&gt;, &lt;input&gt;, &lt;img&gt;, &lt;a&gt;等等 4、属性
元素属性，不会在页面中显示出来
&lt;p title="这是一个title属性"&gt;移过来试试！&lt;/p&gt; 5、标题
h1-h6各等级标题
例如：
&lt;h1&gt;我的第一个世界&lt;/h1&gt; &lt;p&gt;欢迎来到!&lt;br&gt;王者联盟&lt;/p&gt; &lt;p title="这是一个title属性"&gt;移过来试试！&lt;/p&gt; &lt;h2&gt;第二个标题&lt;/h2&gt; &lt;p&gt;王者&lt;/p&gt; &lt;hr&gt; &lt;h3&gt;第三个标题&lt;/h3&gt; &lt;p&gt;世界&lt;/p&gt; &lt;hr&gt; 显示效果：
6、格式
&lt;p&gt;我是 &lt;mark&gt;可爱的&lt;/mark&gt;猪猪！&lt;/p&gt; &lt;p&gt;&lt;del&gt;我是可爱的猪猪!&lt;/del&gt;&lt;/p&gt; &lt;p&gt;&lt;s&gt;我是可爱的猪猪!&lt;/s&gt;&lt;/p&gt; &lt;p&gt;&lt;ins&gt;我是可爱的猪猪!&lt;/ins&gt;&lt;/p&gt; &lt;p&gt;&lt;u&gt;我是可爱的猪猪!&lt;/u&gt;&lt;/p&gt; &lt;p&gt;&lt;small&gt;我是可爱的猪猪!&lt;/small&gt;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;我是可爱的猪猪!&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&lt;em&gt;我是可爱的猪猪!&lt;/em&gt;&lt;/p&gt; 显示效果：
7、超链接
&lt;a href="https://www.4399.com/" target="_blank"&gt;4399小游戏&lt;/a&gt; 显示效果：
8、瞄点
&lt;h2 id="C3"&gt;第三章&lt;/h2&gt; &lt;a href="#C3"&gt;跳到第三章&lt;/a&gt; 显示效果：
9、图片以及路径
路径分为相对路径和绝对路径
相对路径例子：
例如：
&lt;img src="1111.jpg" alt="MDB Logo" width="200" height="400"&gt; 后面数字是设置的尺寸。
显示效果：
10、表格
&lt;table&gt; &lt;tr&gt; &lt;th&gt;语文&lt;/th&gt; &lt;th&gt;数学&lt;/th&gt; &lt;th&gt;英语&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;90&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;td&gt;89&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;87&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;td&gt;94&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 其中：tr表示行，th表示表头，td表内单元
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bc5cea64ce392b9798472cbea917cfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd598fcbb339322fc73fd3e84c79f1a/" rel="bookmark">
			点云分割-kmeans-原理&#43;代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kmeans做为无监督学习的一种聚类方法，原理非常简单，本质上是根据重心（密度中心）不断进行迭代的一个分割方法。
其主要步骤为：
（1）初始化k个中心点
（2）计算所有点到中心点的欧氏距离，形成集合dist
（3）找到dist最小值所在的索引i，将点加入第i个簇
（4）重新计算簇的所有中心，重复2-3直到中心点不变或者达到最大迭代次数。
具体的数学原理可以参考知乎
show the codes
语言：C++ 依赖库：PCL1.9.1 //Kmeans.h #pragma once #include &lt;iostream&gt; #include &lt;algorithm&gt; #include&lt;pcl/point_cloud.h&gt; #include&lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/common/centroid.h&gt; class KMeans { private: unsigned int max_iteration_; const unsigned int cluster_num_;//k double pointsDist(const pcl::PointXYZ&amp; p1, const pcl::PointXYZ&amp; p2); public: pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr centre_points_; //KMeans() = default; KMeans(unsigned int k, unsigned int max_iteration); void kMeans(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr&amp; cloud, std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;&gt; &amp;cluster_cloud1); ~KMeans(){} }; //Kmeans.cpp #include "KMeans.h" double KMeans::pointsDist(const pcl::PointXYZ&amp; p1, const pcl::PointXYZ&amp; p2) { //std::cerr &lt;&lt; p1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dd598fcbb339322fc73fd3e84c79f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bbc40ef6eb47f147294a6409c58e67d/" rel="bookmark">
			转载：手把手亲测：Ubuntu下迁移MySQL库文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：《Ubuntu下迁移MySQL数据库文件目录（亲测成功方法）》https://blog.csdn.net/qq_27608983/article/details/92736333
原文地址：《Ubuntu下迁移MySQL数据库文件目录（亲测成功方法）》https://blog.csdn.net/qq_27608983/article/details/92736333
以下根据自己的情况，手把手亲测并改写了部分
需求：
将数据库mysql的库文件，转移到大容量的硬盘上
为以后维护和扩容积累些许经验
背景：
1、台机安装了ubuntu，有三块硬盘m2.nvme + SSD + 机械硬盘
2、Ubuntu系统中已安装了mysql，请参看《Ubuntu18.04下安装MySQL，删除卸载MySQL，及四个重要文件夹介绍，Win下安装Navicat》https://blog.csdn.net/garbageceo/article/details/114775976
3、计划把mysql的库文件转移到机械硬盘上
4、当前mysql Ver 14.14 Distrib 5.7.33
其它：ubuntu下挂载硬盘的方法，请参看《随笔：Ubuntu挂载新硬盘》https://blog.csdn.net/garbageceo/article/details/87473241
其它：postgresql的迁移，请参看《手把手：ubuntu下将postgresql数据库从默认存储位置 迁移到 其它指定的位置》https://blog.csdn.net/garbageceo/article/details/87750318
大致步骤：
一）、确定mysql数据库文件存放目录
二）、迁移数据库文件到新的目录下
三）、修改配置文件
四）、重启数据库
五）、其它：权限问题
若要查询mysql的版本，可直接在终端对话框中，输入：sudo mysql --version
一）、先查询mysql库文件的安装位置
这有2个方法，一种方法是通过mysql的show命令列出datadir的值，另一种是通过mysql配置文件中datadir的值来确定位置。注意：不同版本的mysql的配置文件名可能会不同。
方法一：通过mysql的show命令列出datadir的值
1.1.1）终端窗口中，依次执行(文档是后补的，datadir已被修改过了)：
mysql -u root -p
show variables like 'datadir';
quit;
方法二：通过mysql配置文件中datadir的值来确定位置
1.2.1）先查询mysql的安装路径（一般情况是在/etc/mysql中），在终端中执行：
sudo find / -name mysql
1.2.2）访问/etc/mysql并列出文件
cd /etc/mysql &amp;&amp; ls -l
my.cnf是软链接文件至其他处，一路查下来，最终还是回到了文件/etc/mysql/mysql.conf.d/mysqld.cnf
1.2.3）查看mysql.cnf文件
sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf
大约在36行，可见：datadir = /var/lib/mysql，这是当前库文件存放地址（等会更改）。
二）、迁移mysql库文件到新目录下
2.1）停止MySQL服务
sudo service mysql status
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bbc40ef6eb47f147294a6409c58e67d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6816c9a717dd1e97e971f41ca01eee9/" rel="bookmark">
			MySQL数据类型-整数类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL提供了多种数据类型，包括整数类型、浮点数类型、定点数类型、日期和时间类型、字符串类型、二进制数据类型；
不同的数据类型有各自的的类型，使用范围也各不相同，而且存储方式也不相同
有两种类型的数字：整数和实数 整数类型 整数类型参考：各种整数类型的取值范围、存储的字节数
上图分析如下：
1，int类型和integer类型的字节数和取值范围是一样的，其实在MySQL中int类型和integer类型是一样的。2，tinyint类型占用的字节最小，只需要一个字节。取值范围也是最小的。3，bigint类型占用的字节最大，需要8个字节。气质范围是最大的。4，不同类型的整数类型的字节数不同，根据类型所占的字节数可以算出该类型的取值范围。比如intyint的空间是一个字节，一个字节是8位。那么tinyint无符号数的最大值就是2的8次-1，也就是255。tinyint有符号数的最大值就是2的7次-1，也就是127。5，MySQL支持数据类型的名称后面指定该类型的显示宽度，其基本形式如下：数据类型(显示宽度)【数据类型参数是整数数据类型的名称，显示宽度参数是指定宽度的数值，显示宽度是指能够显示的最大数据的长度。比如int（4）就是指定int类型的显示宽度是4】。 实际操作下整数相关的数据类型
关于上图我们发现，每个整数类型默认显示宽度与其有符号数的最小值的显示宽度相同，因为次数负号是占有一个位置，如果是正数的话，一个整数的数据类型的默认显示宽度刚好能显示该数据类型的所有值 ；tinyint类型的取值范围是-128~127 ，那么tinyint默认显示宽度就是4，int类型的最大值10位，所以int的默认显示宽度就是11
unsigned，zerofill，auto_increment属性：
总结：字段选择那个整数类型，取决于该字段的范围，如果字段的最大值不超过255，那么tinyint足够了，取值很大的时候，根据最大值的范围选择int 或者bigint类型，
比较常用的的整数类型时int
实数类型 实数类型包括 单精度浮点数float、双精度浮点数double、定点数类型decimal
几种数据类型的取值范围和字节数
总结：在MySQL中，定点数以字符串形式存储，因此，其精度比浮点数要高，而且浮点数会出现误差，这是浮点数一直存在的误差；如果要对数据的精度要求比较高，还是选择定点数decimal比较安全
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a9cb42f459a4068cffba942367ec47e/" rel="bookmark">
			史上最全的xpath定位方法 全在这了!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xpath常用的定位方法
相信做过selenium UI自动化的朋友都知道，工作中大部分的元素定位都是使用xpath进行定位，所以xpath是UI自动化工作中非常重要的一个环节，所以我单独整理出来一篇博客出来~~希望对大家有帮助~
相对定位
相对定位是两个杠表示“//”，相对路径易维护
绝对路径
绝对定位用一个杠“/”， 绝对路径一个层级变化所有空间都有变化
/html/body/div[1]/section/section/main/div[2]/div[2]/div[1]/div[2]/button[1]/span last()方法
当标签存在多个相同的时候，可以使用xpath中的last()方法，定位到最后一个
//标签名[last()] //span/ul//li[last()] 如果我们要定位到倒数第二个，可以在last() 后面加上 -1，代表倒数第二个
//标签名[last()-1] //span/ul//li[last()-1] 属性查找@
如，这里我们以百度为例，如果我们要定位到百度的id元素，那么可以使用 //标签名[@元素名称=‘元素值’]
//标签名[@元素名称='元素值'] //input[@id='kw'] xpath逻辑表达式-and
当一个元素无法定位到唯一值得时候，我们可以使用and表达式，同一个标签下定位多个元素
//标签名[@元素名称='元素值' and @元素名称='元素值'] //input[@id='kw' and @class='s_ipt'] xpath表达式-or
xpath 中 or的表达式和and很像，指的是当你元素满足其中一个条件的时候，就可以定位到，如图，在百度搜索框中，我们故意将@class='s_t’元素写错，内容中并没有这个元素，
// 标签名[@元素名称='元素值' or @元素名称='元素值'] //input[@id='kw' or @class='s_t'] 非查找控件
如图，如果我们想要查找元素值不等于某个值的内容，可以使用！=方法，但是这个方法在工作中用的比较少，目前我还没有用到过，不过xapth提供了这个方法，可以结合场景使用~
//标签名称[@元素名称 != '元素值'] //input[@class!='1111'] Not查找
//标签名[not(.='元素值') //year[not(.=2005)] //div[not(@id="tab-AndroidVersions")] 这里没有找到合适的场景，意思就是查找year内容不为2005的内容 注：“.”就等于text()
模糊匹配
//标签名[contains(text(), "内容"] //div[contains(text(), "更新")] 这里的意思是模糊查询内容包含“更新”的元素
精准匹配
//标签名[(text()='内容')] //div[(text()='更新文案')] 使用大于小于符号定位
//div[@class="cell" and text()&gt;'1336'] //div[@class="cell" and text()&lt;'1336'] 如图，当我们商品列表中有多个商品ID，那我们想要定位到ID大于或者小于1336的数据，可以通过上面的方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a9cb42f459a4068cffba942367ec47e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36e069730ede5e6c430d7b688bfb5c0a/" rel="bookmark">
			中缀表达式 转成 后缀表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中缀表达式 将运算符写在两个操作数中间的表达式 eg: (6+3*(7-4))-8/2
后缀表达式 将运算符写在操作数之后, 逆波兰式（Reverse Polish notation，RPN，或逆波兰记法），也叫后缀表达式 eg: 6 3 7 4 - * + 8 2 / -
前缀表达式 将运算符写在两个操作数之前的表达式 eg: - + 6 * 3 - 7 4 / 8 2
中缀表达式转换成后缀表达式 eg. (6+3*(7-4))-8/2
1.直接转换法 确定表达式的运算方式, 加括号, 给每一次能运算的都加上: (6+(3*(7-4)))-8/2(6+(3*(7-4)))-(8/2)((6+(3*(7-4)))-(8/2)) 从最里面的一层括号开始运算，转换成后缀表达式的方法为：（忽略括号）数字在前，符号在后 (7-4) =&gt; 74-(3*(7-4)) =&gt; (3*(74-)) =&gt; 374-* (把74-看成一个整体)(6+(3*(7-4))) =&gt; (6+ (374 -* )) =&gt; 6 374-* + (把374-*看成一个整体)(8/2) =&gt; 82 /((6+(3*(7-4)))-(8/2)) =&gt; (6 374-* + ) - ( 82 /) =&gt; 6 374-* + 82 /- (把(6 374-* +) 和 ( 82 /)) 看成一个整体 后缀表达式: 6 3 7 4 - * + 8 2 / - 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36e069730ede5e6c430d7b688bfb5c0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2a430e40439a5c3f4ea310e6429bf9/" rel="bookmark">
			ODL 氧版本(karaf-0.8.1.tar.gz)安装、karaf操作基础、安装组件模块、dlux三个页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		karaf-0.8.1.tar.gz 氧版本
sudo apt-get install openjdk-8-jdk
openjdk 安装
一般命令 ：
在/karaf-0.8.1/bin目录下
./karaf 启动
./karaf daemon 后台启用，可以关terminal
ps -ef | grep java 可看到后台启用
./karaf stop 关掉
用gedit 可看下 karaf文件，也能知道有哪些命令使用
什么都没用直接用list ，等同于 bundle:list
list -t 0 可以看哪些bundle
bundle list 显示激活和未激活的bundle
feature:list
exit 退出进入 bundle
查看最新日志 log:tail
设置出错级别log:set
桌面/bin 目录下和 /etc /log
用gedit打开看一看，后面会用到
安装组件
opendaylight-user@root&gt;log:set DEBUG org.opendaylight.openflowplugin opendaylight-user@root&gt;log:lsit Command not found: log:lsit opendaylight-user@root&gt;log:list Logger │ Level ────────────────────────────────────┼────── ROOT │ INFO org.apache.aries.spifly │ WARN org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb2a430e40439a5c3f4ea310e6429bf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a53b08029ac8151d9d432cf4212cdeaf/" rel="bookmark">
			VM 虚拟机无法配置网卡(eth0)的ip地址？ens33是啥？如何解决？(使用版本Centos7)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOs 7的"网络连接"模式的一招解决 安装 Centos7 镜像的VM 无论 host-only 网络连接模式 还是其他 NAT 模式 还是 桥接模式，输入 ifconfig ，会出现ens33，表示Centos7动态自动分配地址，因此无需手动分配，可以直接使用红标的 172.21.8.4 使用到后续的secureCRT 或 Xshell 即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5255e1019ee890ccbc0980e7d71c7e1/" rel="bookmark">
			MTK(mt6797)-DTS修改---I2C设备(Kernrl3.18)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改kernel-3.18\drivers\misc\mediatek\mach\mt6797\amt6797_evb_m\dct\dct\codegen.dws目录下的DWS文件，在对应的I2C_CHANNEL上添加GOODIX的设备，并设定I2C的地址，如下代码段1中所示： 代码段1
kernel-3.18\drivers\misc\mediatek\mach\mt6797\amt6797_evb_m\dct\dct\codegen.dws &lt;device16&gt;
&lt;varName&gt;CAP_TOUCH&lt;/varName&gt;
&lt;channel&gt;I2C_CHANNEL_4&lt;/channel&gt;
&lt;address&gt;0x5D&lt;/address&gt;
&lt;/device16&gt;
该DWS文件，在内核编译后会在\out\arch\arm64\boot\dts目录下生一个cust.dtsi文件，在该文件中会出现刚在DWS文件中添加的设备，此文件对应的设备下仅包含有设备的： compatible, reg, status等信息，而GPIO、IRQ、PINCTRL等信息都不在该cust.dtsi文件中，如下代码段2中所示。
代码段2
\out\arch\arm64\boot\dts &amp;i2c4 {
#address-cells = &lt;1&gt;;
#size-cells = &lt;0&gt;;
clock-frequency = &lt;400000&gt;;
mediatek,use-open-drain;
cap_touch@5d {
compatible = "mediatek,cap_touch";
reg = &lt;0x5d&gt;;
status = "okay";
};
fts_touch@70 {
compatible = "mediatek,fts_touch";
reg = &lt;0x70&gt;;
status = "okay";
};
};
这里的“compatible”就是用于与驱动中的MODULE_INIT相匹配的ID，两者一致了驱动的probe函数才能正常运行起来。比如这个例子中的“cap_touch”，驱动中设置相应的compatible也为“cap_touch”即可保证probe函数能起来。
Linux内核在启动的过程中会加载设备树文件，并最终生成相应的i2c_client对象，设备树中的相关资源信息都会被内核保存到“i2c_client-&gt;dev.of_node”中，驱动中使用该“of_node”通过of_get_named_gpio等方法即可获取到dts中的信息。比如下面的代码段3，我们在驱动中调用of_get_named_gpio(node,"goodix,reset-gpio", 0)，该方法即可为我们返回DTS中与"goodix,reset-gpio"相对应的信息，非常简便。 我们刚才也说过了i2c_client-&gt;dev.of_node中的信息是内核从DTS中抽取并存放到该对象中的，内核中不止一个i2c_client，DTS中也不止一个设备的信息，内核是怎样将它们进行对应的呢？在DTS中，每个设备都会有一个设备名，在该设备下我们可以设置compatible, addr以及GPIO、IRQ等资源，内核最终在生成i2c_client时会将这些资源存放在of_node中。但MTK有些特殊，它将设备的compatible, addr设备和GPIO、IRQ等资源的设置分散在了不同的文件中。因此，如代码段3中所示，开头的“&amp;touch”，代表的就是对设备名为“touch”的设备的资源信息补充。
在目前MTK开发板的内核中，对于设备“cap_touch”仅仅只设置了其compatible, addr，而且还是从DWS中生成过来的，其它的，GPIO、IRQ等资源都没有声明，而是将这些资源全都放了在kernel-3.18/arch/arm64/boot/dts/amt6797_evb_m.dts文件中的设备名为“touch”的设备下。那么肯定的，驱动是无法从i2c_client-&gt;dev.of_node获取资源信息的，因为我们在DTS中根本就没有为“cap_touch”声明任何资源。
那在驱动中如何去获取资源信息呢？在MTK平台上，使用
of_node = of_find_node_by_name(NULL,"goodix,touch");
将of_node指向了设备“touch”，有了of_node，后面即可一样地通过of_get_named_gpio等函数去获取资源了。
这是MTK平台比较坑的几点： 1、 从DWS去生成设备，而不是直接在DTS中修改/添加设备； 2、 设备树中设备compatible,addr的声明与GPIO、IRQ等资源的声明分散在不同的文件中； 3、 MTK平台上的驱动中对of_node进行了重新的定位，将其将向了”touch”设备； 其实完全可以将MTK平台做的与高通平台一样的，不修改DWS，而是直接去修改DTC，并且将设备相关的信息放在一起而不要再分散开来，最后，不要在驱动中去修改of_node的指向，而是将对应设备的资源信息都放在对应的设备下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5255e1019ee890ccbc0980e7d71c7e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3716d9e33182bb89d857c713326f7f81/" rel="bookmark">
			matlab学习——线性规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab及lingo软件处理线性规划 文章目录 matlab及lingo软件处理线性规划一、matlab线性规划求解二、lingo求解线性规划问题lingo可用来求解线性规划及非线性规划问题 一、matlab线性规划求解 其矩阵形式为：
常用的是linprog形式，求解线性规划问题
[x,fval]=linprog(c,A,b,Aeq,beq,vlb,vub)
其中x表示x优化的取值，fval表示优化后目标函数的值，c为目标函数x的系数矩阵，A为等式约束x的系数，Aeq为非等式约束的自变量x的系数，vlb和vub是x自变量的约束上界和下界。
例：
c=[-10,-6,-4]; A=[1,1,1;10,4,5;2,2,6]; b=[100;600;300]; Aeq=[];beq=[];vlb=[0,0,0];vub=[]; [x,fval]=linprog(c,A,b,beq,beq,vlb,vub) 其中，linprog只能求局部最小值优化，全局求最小值可用模拟退火法、差分进化法等，求最大值加负号求解
二、lingo求解线性规划问题 lingo可用来求解线性规划及非线性规划问题 例：
model: max=10*x1+6*x2+4*x3; x1+x2+x3&lt;=100; 10*x1+4*x2+5*x3&lt;=600; 2*x1+2*x2+6*x3&lt;=300; @gin(x1);@gin(x2);@gin(x3); end 较matlab程序简明易行，其优点还在于它的求解界面
其中Reduced Cost 表示当系数为多少时，可以取值相应x
Dual Price 表示增加一个单位值时，最终结果上升多少
灵敏度分析，表示x波动范围，系数波动范围，规划不变
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24807106795b793423ad3294a3e664d7/" rel="bookmark">
			手撕 Go 面试官：Go 结构体是否可以比较，为什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是煎鱼。
最近金三银四，是面试的季节。在我的 Go 读者交流群里出现了许多小伙伴在讨论自己面试过程中所遇到的一些 Go 面试题。
如果大家也有兴趣共同交流，欢迎关注煎鱼的公众号，加我微信后拉你进群。
今天的男主角，是 Go 工程师的必修技能，也是极容易踩坑的地方，就是 “Go 面试题：Go 结构体（struct）是否可以比较？”
如果可以比较，是为什么？如果不可以比较，又是为什么？
请在此处默念自己心目中的答案，再往和煎鱼一起研讨一波 Go 的技术哲学。
结构体是什么 在 Go 语言中有个基本类型，开发者们称之为结构体（struct）。是 Go 语言中非常常用的，基本定义：
type struct_variable_type struct { member definition member definition ... member definition } 简单示例：
package main import "fmt" type Vertex struct { Name1 string Name2 string } func main() { v := Vertex{"脑子进了", "煎鱼"} v.Name2 = "蒸鱼" fmt.Println(v.Name2) } 输出结果：
蒸鱼 这部分属于基础知识，因此不再过多解释。如果看不懂，建议重学 Go 语言语法基础。
比较两下 例子一 接下来正式开始研讨 Go 结构体比较的问题，第一个例子如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24807106795b793423ad3294a3e664d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0455a1d6058ef55541896f902e6423b/" rel="bookmark">
			Python---tk类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 创建tk对象创建标签创建按钮创建文本窗口 创建tk对象 在对象创建时，使用关键字参数
fred = Button(self, fg="red", bg="blue") 创建对象后，将选项名称视为字典索引
fred["fg"] = "red" fred["bg"] = "blue" # bg是“背景”的简写 创建对象后，使用config（）方法更新多个属性
fred.config(fg="red", bg="blue") 按钮有一个command参数，标签没有。即鼠标的点击效果
Packer
它是设置按钮的位置和颜色的。
pack(side)side参数有效值是left,right,top,bottom
fred.pack() # defaults to side = "top" fred.pack(side="left") fred.pack(expand=1) 交互窗口中当需要输入文本时，需要先创建一个对应的对象。
如：StringVar,IntVar,DoubleVar和BooleanVar。用get(),读取此类变量的当前值。用set()，修改它的值。
创建标签 from tkinter import * import tk.font as tkFont # 创建一个Tk对象（交互窗口对象） master = Tk() # 创建一个字体对象。 ft = tkFont.Font(family='Fixdsys', size=9, weight=tkFont.BOLD) # 创建一个标签对象，将Tk对象传入进去，内容使用`text=`设置，'font=字体对象' 设置字体格式 l1 = Label(master, text='内容---&gt;',font = ft) # 设置标签的位置，x y 是坐标，anchor是放的位置，‘nw’是靠左边。 l1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0455a1d6058ef55541896f902e6423b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c784d2fce867c596e454262d396c7612/" rel="bookmark">
			一文读懂RPA是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RPA（ Robotic Process Automation 机器人流程自动化软件），是一种新型的人工智能的虚拟流程自动化机器人。经过几年的发展，RPA已经广泛应用于各个需要流程自动化的领域，特别是在财税自动化领域。
一、基本定义：
RPA的核心是通过自动化、智能化技术来“替代人”进行重复性、低价值、无需人工决策等固定性流程化操作，从而有效提升工作效率，减少错误。
二、RPA给我们带来神马好处？
首先是直接的降本增效，RPA可以代替人或者辅助人进行很多流程自动化任务，它可以为企业减少大量的成本。其次，他由于是自动化操作，它相当于一个“虚拟的员工”在您下达指令之后，他就可以快速的给您工作，并且不会感觉疲惫，它处理的业务更加具有效率，并且错误率几乎为“0”
三、发展渊源
1、物理机器人：在开采、制造、物流、科研、医学、军事等领域已经广泛应用了机器人。特别是在制造领域：很多流水线，机器人只需做重复的流水线操作，即可完成相关作业。而进行流水线作业的物理机器人，后台都需要进行流程设计的。
“这些物理机器人”和RPA一样，大多都是重复有规律的工作，而物理机器人后台的流程设计为RPA机器人后台流程。
2、日常软件中RPA的影子
游戏类插件：其中类似于“大脚”、“按键精灵”、“多玩盒子”等网游辅助类插件，就有RPA的概念。简单来说，你用了这些插件，特别是插件中的“宏”的时候，你玩游戏就会特别轻松，就和RPA辅助机器人类似，你可以只需按1按键，就可以自动刷本，自动采药挖矿。
办公软件中辅助功能：例如邮件终端的自动群发单显功能，office中的“宏”的功能，等等都有软件自动化概念。
但无论是游戏插件还是办公软件的辅助，是固定的，你不能根据自己的需求进行设计，这操作了这类软件的局限。
3、用户实体行为分析：
在金融行业中，因为数据的庞大性和特殊性，在审计合规、保密等方面有着特别的需求，很多时候需要对用户行为进行监控。
例如笔者公司的UEBA（User Entity Behavior Analytics用户实体行为分析），可以全面采集用户的行为，并以文本化的形式展现。这其中的用户行为采集过程，就是RPA执行的第一步。
四、RPA机器人现阶段的几种形式
1、辅助机器人：主要是用在客服领域，例如保险行业，用于客户要咨询保险相关业务，由于保险业险种特别多，中间的保险的条款又特别复杂，纯人工进行客户服务时，效率并不高，又可能影响客户服务体验。有了RPA机器人之后，机器人可以自动提示业务信息，这样客服效率就大大提高！
再比如，在通信客服领域，客户需要办理的业务都是相关的，当客户要办理套餐的时候，RPA机器人可以直接提示相关业务办理，这个就大大减少了客户办理业务的时间。
2、值守机器人：这个应用的领域特别广泛，例如在对外公共服务领域，人通常都会面对生老病死，而相应的社会保障数据就要随之调整。要是人为操作，日工作量可能不是太大，但工作随机重复的，这种类型的工作就可以交给RPA机器人，RPA自动检测源数据变化，自动执行数据的增删改。
3、自主工作机器人：随时开始，随时使用。机器人后台经过工程师预设计后。RPA就可以随时执行工作所需了。例如财税数据处理，订单处理，邮件发送等等。
五、RPA发展呈现的方向
1、工具化特征
现在人工智能产品日益普及，但对于普通人来说，我们并不能将人工智能作为一个工具，并且根据我们的实际需求，将工具进行优化和调整，最终为我所用。人工智能产品基本都是固定的，或帮你扫地，或帮你开车，或帮你放音乐，但他们的串联度不高。
在虚拟人工智能方面，则不同，RPA机器人就有定制化的特点。在RPA后台，完成了大量的命令封装，让终端的试用者可以最简洁，最快速的嫁接终端业务。伴随界面流畅度、模块封装、适用场景的日臻完善，终端用户的操作也变得日益简单，并且您可以自主更加业务所需进行调整。当然这里并不是说RPA没有局限性，例如我在项目中，经常要抓取网页，有时不定时的弹出广告（通常是日常办公中的电脑端），我们要设置更多容错机制。
2、美的和简单好用的
界面更“美”:越来越多的厂商开始重视UI设计，这里举个不恰当的例子，设计师最不喜欢人家喊他美工，而现在很多公司都给了设计师一个高大上的称呼——视觉设计师，由此可见对界面美感的重视。
操作更简单:在流程衔接上，支持拖拽和划线方式，让逻辑业务链接更加的顺畅;RAP将各种命令完成封装，很多步骤地方都可以采用选择、拖拽的方式，并有的RPA产品已支持代码联想，版本管理，历史记录，Debug检索。
3、开放化初现端倪
更加开“源”虽然这里并没有完全开放，但在互联网和资源共享时代的今天，商业模式也逐渐朝这个方向发展。
互联网化：社区化、互联网化模式，登录方式，获取资料的方式越来越方便，和社区化的微信、钉钉、手机等方式进行快捷的绑定
4、RPA未来期待
1）更多的自主能力
人工智能一般来说，分为“强”人工智能和“弱”人工智能
“强”人工智能，希望研制出和人一样聪明，甚至比人更聪明的机器，他们有更多自主能力。
“弱”人工智能，是觉得人做事的时候很聪明，这类人工智能是辅助人类进行工作。
从以上分类来说，RPA未来会加入更多“自主”能力，模仿人更多方面，甚至加入思考和辨别的特征，例如RPA机器人可以帮你设计，写简单的稿件…
2）更多接口
例如OCR接口，语音识别等等，未来在客户说出自己的业务需求的时候，RPA机器人就可以以模拟人的方式，帮助客户处理业务。RPA在未来会和更多人工智能产品结合，让人们的生活更加便捷。
3）工作更加标准化
未来，由于RPA产品更好的封装，类似于传统软件中的售前售后技术人员将大大减少，RPA就如同现在的作图、建模的软件一样，在拖拖拽拽后就可以完成后台流程设计。RPA使用的培训将会越来越受到重视。
互联互通社区
互联互通社区专注于IT互联网交流与学习，旨在打造最具价值的IT互联网智库中心，关注公众号：互联互通社区，每日获取最新报告并附带专题内容辅助学习。
方案咨询、架构设计、数字化转型、中台建设、前沿技术培训与交流，合作请+微信：hulianhutongshequ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e814b8335cbe0590679896e7dc9fe37d/" rel="bookmark">
			Android ImageView设置图片自适应的方法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ImageView 通过xml
网络上下载下来的图片自适应： android:adjustViewBounds="true" //保持比例（其详细解释在下面）
&lt;ImageView android:id="@+id/dynamic_item_image" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="top" android:layout_marginTop="5dip" android:adjustViewBounds="true" android:background="@drawable/imageview_background" /&gt; 另外，imageview_background.xml是给图片加一个边框
&lt;?xmlversion="1.0" encoding="utf-8"?&gt; &lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;solid android:color="@color/white"/&gt; &lt;stroke android:width="2.0dip" android:color="#99D9D9D9" /&gt; &lt;cornersandroid:radius="2.0dip" /&gt; &lt;paddingandroid:left="5.0dip" android:top="5.0dip" android:right="5.0dip" android:bottom="5.0dip" /&gt; &lt;/shape&gt; ImageView属性说明：
1、类概述 ：显示任意图像，例如图标。ImageView类可以加载各种来源的图片（如资源或图片库），需要计算图像的尺寸，比便它可以在其他布局中使用，并提供例如缩放和着色（渲染）各种显示选项
2、XML属性
属性名称
描述
android:adjustViewBounds
是否保持宽高比。需要与maxWidth、MaxHeight一起使用，否则单独使用没有效果。
android:cropToPadding
是否截取指定区域用空白代替。单独设置无效果，需要与scrollY一起使用，效果如下，实现代码见代码部分：
android:maxHeight
设置View的最大高度，单独使用无效，需要与setAdjustViewBounds一起使用。如果想设置图片固定大小，又想保持图片宽高比，需要如下设置：
1） 设置setAdjustViewBounds为true；
2） 设置maxWidth、MaxHeight；
3） 设置设置layout_width和layout_height为wrap_content。
android:maxWidth
设置View的最大宽度。同上。
android:scaleType
设置图片的填充方式。
matrix
0
用矩阵来绘图
fitXY
1
拉伸图片（不按比例）以填充View的宽高
layout_height:30px
layout_width:120px
fitStart
2
按比例拉伸图片，拉伸后图片的高度为View的高度，且显示在View的左边
fitCenter
3
按比例拉伸图片，拉伸后图片的高度为View的高度，且显示在View的中间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e814b8335cbe0590679896e7dc9fe37d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/035e06bedbb27ddad4b5dde472f41f33/" rel="bookmark">
			Robotics Toolbox工具箱使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Robotics Toolbox工具箱简介
Robotics Toolbox工具箱是一个功能强大的机器人工具箱，包含了机器人正、逆向运动学，正、逆向动力学，轨迹规划等，其中可视化仿真使得学习抽象的机器人学变得相对直观、好理解。学习这个工具箱，对理解机器人学很有帮助；然而MATLAB发行版中并没有自带该工具箱，需要自行安装；
2.Robotic Box工具箱安装
安装方式官网上已给出，可自行参考：
https://petercorke.com/toolboxes/robotics-toolbox/
简单来说有两种安装方式，这里使用的压缩包文件进行安装，即上面第一种。
安装步骤：
第一步：下载工具箱，这里直接给出一个链接打开后的界面如下，点击“DOWNLOAD”进行下载,下载速度颇慢，需要耐心等待；
链接：https://petercorke.com/resources/downloads/
第二步：将下载的文件进行解压至matlab安装目录toolbox中，解压文件和目录如下；
第三步：设置路径，打开matlab，单击设置路径，进行添加文件，添加完成后保存；
第四步：安装及验证
a、在命令行窗口输入：startup_rvc 进行安装；
b、在命令行窗口输入ver查看是否安装成功；
3.常用函数介绍
主要介绍Link类和SerialLink类；前者用于初始化机器人的运动参数、动力学参数、刚体惯性矩参数、电机参数和传动参数。后者用于创建机器人，并对动机器人进行正运动学、逆运动学、动力学求解等；
1、Link类
操作函数：
% A 连杆变换矩阵
% RP 关节类型: ‘R’ 或 ‘P’
% friction 摩擦力
% nofriction 摩擦力忽略
% dyn 显示动力学参数
% islimit 测试关节是否超出软限制
% isrevolute 测试是否为旋转关节
% isprismatic 测试是否为移动关节
% display 连杆参数以表格形式显示
% char 转为字符串
运动学参数：
% theta 关节角度
% d 连杆偏移量
% a 连杆长度
% alpha 连杆扭角
% sigma 旋转关节为0，移动关节为1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/035e06bedbb27ddad4b5dde472f41f33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d676f5278ceddfd0fb32e378aa97ce5/" rel="bookmark">
			mysql2安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nodejs中mysql2模块 安装 npm i mysql2 -S 使用 const mysql2 = require("mysql2"); 配置和数据库之间的连接 const connection = mysql2.createConnection({ host: 'localhost', //主机 user: "root", //用户名 password: "102327", //自己设置的密码 database: "js05", //表名 charset: "utf8" }); app.use(static(__dirname + "/static")); // app.use(views(__dirname + "/views")); router.get("/", async ctx =&gt; { let mydata; let sql = "SELECT age,hobby FROM user WHERE id&lt;=2";//引用数据库中的数据操作 curd操作 // connection.query(sql, (err, result) =&gt; { // if (err) { // console.log(err); // } // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d676f5278ceddfd0fb32e378aa97ce5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b5cc4eaa92e7e4e114feb8da66893e9/" rel="bookmark">
			springcloud上传文件提示wMissingServletRequestPartException: Required request part ‘advert‘ is not present]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 springcloud/springboot在上传文件的时候出现： Resolved [org.springframework.web.multipart.support.MissingServletRequestPartException: Required request part 'advert' is not present],如下图所示:
二、原因分析 造成这个问题的原因在于后台控制器中 RequestParam("") 中的值和方法体中的名字不统一,即: @RequestParam("advert") ≠ MultipartFile file.
三、解决办法 保持两个属性值一样即可，即： @RequestParam("file") MultipartFile file.
`
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a42df43a3bc59d3e9e10ff602fa6bc89/" rel="bookmark">
			单词接龙（BFS，有点意思的题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接！
思路：
这道题是道BFS题，但是比较有难度，这里我们是用bfs“建图”，是虚拟建图，先用set容器保存我们的单词列表（当然我们先把begin_word这个单词在列表中删除，如果有的话。）通过队列从begin_word出发，开始一层一层遍历；
首先我们先出队首，对head_word进行每个字母的转换（s.size()*26的时间复杂度）,对了，我们还得用visit_set容器记录我们之前遍历过的单词（是指在单词列表中），因为我们知道bfs搜索一旦到达终点，一定是最少步数的答案！
步数是很好记录的，有多少层就有多少步。那么怎么才知道达到终点呢？那肯定是在单词列表中能找到end_word这个单词以及在visit_set容器中没有访问过才可以！
代码：
class Solution { public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { unordered_set&lt;string&gt; words(wordList.begin(), wordList.end()); if ( words.empty() || words.find(endWord) == words.end() ) return 0; words.erase(beginWord); queue&lt;string&gt; que; que.push(beginWord); unordered_set&lt;string&gt; visited; visited.insert(beginWord); int step = 1; while ( !que.empty() ) { int n = que.size(); //抽出每一层进行遍历 while ( n-- ) { string curWord = que.front(); que.pop(); //这里进行每个字母的转换 for ( int i = 0; i &lt; curWord.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a42df43a3bc59d3e9e10ff602fa6bc89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d3b1945082c98a3800c880377eb9029/" rel="bookmark">
			vue中css共用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue中css共用问题 问题：
在做学生宿舍管理模块时，当退出了管理员模块进入到宿舍管理员模块时，同一个title使用了同一个类名出现了css的覆盖问题
提示：这里描述项目中遇到的问题：
管理员模块
宿舍管理员模块
原因：
在前端路由加载时之前的css文件已经上传到了路由器
当进行切换时代码css文件并没有清楚，所以导致css重用
提示：这里填写问题的分析：
解决方案：
修改css名是最简单的方案，当然后续会去查阅如何能够做到退出时将其加载文件全部刷新的问题
提示：这里填写该问题的具体解决方案：
&lt;div class="mangertop"&gt; &lt;div class="left" @click="back()"&gt; &lt;div class="lefticon"&gt; &lt;van-icon name="arrow-left" /&gt; &lt;/div&gt; &lt;div class="txt"&gt;返回&lt;/div&gt; &lt;/div&gt; &lt;div class="title"&gt;{{title}}&lt;/div&gt; &lt;/div&gt; 提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab238f13e88b70488888753da61ff627/" rel="bookmark">
			_C.cpython-36m-x86_64-linux-gnu.so: undefined symbol: _ZN6caffe28TypeMeta21_typeMetaDataInstanceISt7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错原因 torch 和 torchvision 不匹配
解决 CUDA 10.2
原来安装的版本：
torch 1.6.0torchvision-0.7.0 重新安装
torch 1.5.0torchvision-0.6.0 安装语句
pip install torchvision==0.6.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03c74f0c70988ec79307a840c05bd379/" rel="bookmark">
			GEE：批量下载数据，按月合成，不同景，全实验区域，一键执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们下载的数据可能因为遥感影像采集时间不同，下载的数据需要拼接。所以在这里给大家一个GEE代码，可以直接下载按月份拼接的遥感影像。比如，将2021年3月的不同景的数据按最大值合成且拼接在一起。此代码可以下载2014年-2020年每个月的数据，且按照矢量边界裁剪。方便了下载数据的繁琐过程。当然也可能有一些莫名的错误，希望大家指正，欢迎讨论。
（此代码没有去云，读者可以根据需要自行加入）
一、批量下载 结果如图所示
批量下载代码 版本2.0
源代码：https://code.earthengine.google.com/ee57dcf1354d86bbd1418e48b98a2761?noload=true
var roi = table; for(var i=2019;i&lt;=2020;i++){ for(var j=1;j&lt;=12;j++){ var data_collection = imageCollection.filter(ee.Filter.calendarRange(j, j,'month')) .filter(ee.Filter.calendarRange(i, i, 'year')) .map(function(img) { return img.set('year', img.date().get('year')); }).filterBounds(roi); var HY_collection = data_collection.max().clip(roi) print(data_collection,i+"_year_"+j+"_month"); Map.addLayer(HY_collection,{},i+'-'+j); Export.image.toDrive({ image: HY_collection, description: i+'-'+j, crs: "EPSG:32649", scale: 30, region: roi, maxPixels: 1e13, folder: 'ShanXi' }) } } Map.addLayer(roi,{},'hengyang Boundary'); 版本1.0
源代码：https://code.earthengine.google.com/0b36b131830d748366bd94c50e65f0a6?noload=true
var HY = table.filterBounds(point).geometry(); for(var i=2014;i&lt;=2020;i++){ for(var j=1;j&lt;=12;j++){ var data_collection = imageCollection.filterDate(i+'-'+j+'-01',i+'-'+j+'-28').filterBounds(table); var HY_collection = data_collection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03c74f0c70988ec79307a840c05bd379/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28ac2e201baa009d3644cc524313ae8c/" rel="bookmark">
			vector 内存位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. vector 在函数中定义(vector&lt;int &gt; arr；)， 对象是在栈上(&amp;arr 是栈内存地址)， 数据在堆上(&amp; arr[0] 是队内存地址)。
2. vector 在函数中new 出（vector&lt;int&gt;* temp = new vector&lt;int&gt;(10,1);）， 指针在栈上（&amp;temp）， 对象地址在堆上（temp ）， 数据在堆上 （数据 (*temp ).at(i); or (*temp )[i]; 取址） 。
其中at（i）会做越界检查，耗时多。
总结： vector 的数据总是在堆上的，但对象的地址根据定义的方式不同可能在堆上，也可能在栈上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db3f1af1c251f27a7c684db472b50712/" rel="bookmark">
			xjview脑区结果怎么看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		view界面 按照下列顺序记录
1 脑区结果 1-5大概对应下图，半球水平-叶-回-组织-cell（Lancaster，2000）。 半球水平：大脑中最大的解剖结构（大脑，小脑和脑干）被分配到半球水平。
叶水平：对于大脑，由四个主要的额叶，颞叶，顶叶和枕叶和一个边缘叶组成。
回：包括主要叶的回和子叶区域内的各种深灰质结构。
组织水平：包括灰质，白质和脑脊髓液（CSF）。
Cell Level： The brain was labeled by cell-type in the cortex using Brodmann’s scheme [Garey, 1994] and tracts, spaces, and sub-nuclear regions for other portions of the brain. Forty-seven Brodmann areas (BA) labels were defined.
6 AAL Automated Anatomical Labeling 见参考文献2，也是命名系统
摘录一下标记方法
We implemented three procedures for the automatic anatomical labeling of the functional activation map: (1) local maxima labeling, (2) extended local maxima labeling, and (3) cluster labeling.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db3f1af1c251f27a7c684db472b50712/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf2ceeb0fea5bd3b3f2bea3f8f4d17eb/" rel="bookmark">
			matlab实验数据拟合,利用Matlab对实验数据拟合曲线与函数方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1：命令方式
clc,clear all;
a=[0.0141 0.0154 0.0164 0.0155 0.0149 0.0142 0.0129 0.0115 0.0114 0.0111 0.0105 0.0104 0.0100 0.0091 0.0081 0.0076 0.0069 0.0064 0.0060 0.0059 0.0059 0.0053 0.0052];%可表示输出Y轴的数据，共23个
b=1985:2007;%可表示为输入X轴的数据，对应有23个
p=polyfit(b,a,2);%得到输出函数表达式系数，p为输出2阶函数的系数
f = polyval(p,b);%得到对应的函数表达式f
plot(b,a,'o',b,f,'-r');%分别画出输出的点和拟合的曲线，其中阶数2根据需要进行调节
方法2：工具箱方式
1、在启动系统后的主界面以命令方式输入矩阵a、b
2、使用命令cftool，进入工具箱界面
3、点击Data按钮后在弹出的Data窗口中分别选择xData、Ydata，Weights可加权值拟合(可
不用)----数据集Data sets命名----
4、点击Fitting进入拟合----New fit----命名匹配拟合文件----可选择拟合格式Type of
fit 中的多项式polynomial中的文件的一种形式(如线性多项式)----点应用Apply----结果Results中即可得到拟合函数式的描述。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa6fcce5a675be4b1bac2f1f5030c4c8/" rel="bookmark">
			【经典论文精读】浅谈神经网络的万能近似定理（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​上篇文章我们介绍了神经网络强大的根本：万能近似定理的一些证明思路，今天这篇文章我们继续来聊一聊它，并给出若干定义，以及定理的简要证明和一些理解。
原文链接：https://doi.org/10.1016/0893-6080(89)90020-8
一·若干定义 二.定理即简单证明 3、结语 到此就介绍完了论文的一些相关证明，这里只叙述了当输出向量为一维的时候的情况，文中最后的一些推论也证明了在输出向量为多维的情况下定理依然成立，这里不做过多介绍感兴趣的朋友可以阅读原文了解。
●【经典论文精读】浅谈神经网络的万能近似定理
●小贝万文长字带你详谈Transformer
●图神经网络（03）-图与图学习(二)
欢迎关注我们的微信公众号ChallengeHub，第一时间掌握竞赛信息！！！！
想和各位大佬一起学习可以扫描下方二维码添加群管理员加入ChallengeHub粉丝群。
也欢迎各位加入我们qq群一起讨论学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89bc046aa6deb005cd7e3bee8e36af06/" rel="bookmark">
			opencv-之图像细化（直线细化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时在我们图像处理的时候会经常用到图像细化或者称为直线细化，在这里我跟大家分享一下我个人的理解，这是我花了一天的时间才搞明白其中的原理，具体的原理大家可以在其他博主的博客里搜索到，偶有详细的解释，我这里只是为大家做一下补充，希望能够帮助大家理解
一下就是我对代码的理解，我对每一行的代码进行注解，
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;opencv2/opencv.hpp&gt; using namespace cv; using namespace std; void gThin(cv::Mat&amp; src, cv::Mat&amp; dst, int intera);/*这里传入参数，分别为两个 */图像模板和一个整型的迭代次数 int main() //这里是主函数 { //主函数里面的代码估计就不用我注释了吧？不懂得请留言 cv::Mat src = imread("D:\\vspic\\6.jpg"); cvtColor(src,src,COLOR_BGR2GRAY); threshold(src,src,100,255,THRESH_BINARY); Mat dst; /*imshow("src",src);*/ gThin(src,dst,12); waitKey(0); return 0; } //提取图像的骨架 void gThin(cv::Mat&amp; src, cv::Mat&amp; dst, int intera) { //这里先用判断语句看看图像通道数是否正确，这里必须使用单通道得图像 if(src.type()!=CV_8UC1) { printf("只能处理二值或灰度图像\n"); return; } //非原地操作时候，copy src到dst //对图片进行拷贝 if(dst.data!=src.data) { src.copyTo(dst); } int i, j, n;/*这里定义三个变量变量n是一个循环迭代的作用, 变量i、j是遍历像素的判断条件*/ int width, height;//定义两个变量，接收图片的宽度与高度 width = src.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89bc046aa6deb005cd7e3bee8e36af06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3545375337d19e87c616f546e526422/" rel="bookmark">
			mysql图形化2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据库中的数据操作 curd操作 删 DELETE FROM 表名 WHERE 条件 改 UPDATE 表名SET 设置的内容WHERE 条件语句 查 SELECT 字段一,字段二 FROM 表名 WHERE 条件语句 条件语句 ADN 2 OR 3. ORDER BY (DESC/ASC) 4.LIMIT 5.LIKE 6.JOIN ON 7.AS Mysql2 学习 MySQL2项目是MySQL本机. 协议解析器代码被从头重写，api也被更改以匹配流行的 mysqljs/mysql. 安装 npm install --save mysql2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7037206d07d18c5ed3337f94334bcc7b/" rel="bookmark">
			机器视觉（五）——摄像头坐标系，图像坐标系，世界坐标系的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器视觉（五）——摄像头坐标系，图像坐标系，世界坐标系的转换
目录 1、图像坐标系(Pixel coordinate system)2、成像平面坐标系(Retinal coordinate system)3、摄像机坐标系(Camera coordinate system)4、世界坐标系(World coordinate system)5、摄像机线性模型 1、图像坐标系(Pixel coordinate system) 摄像机采集的数字图像在计算机内可以存储为数组，数组中的每一个元素(象素，pixel)的值即是图像点的亮度(灰度)。如图4.1所示，在图像上定义直角坐标系u-v，每一象素的坐标(u,v)分别是该象素在数组中的列数和行数。故(u,v)是以象素为单位的图像坐标系坐标。
2、成像平面坐标系(Retinal coordinate system) 由于图像坐标系只表示象素位于数字图像的列数和行数，并没有用物理单位表示出该象素在图像中的物理位置，因而需要再建立以物理单位(例如厘米)表示的成像平面坐标系x-y，如图4.1所示。我们用(x,y)表示以物理单位度量的成像平面坐标系的坐标。在x-y坐标系中，原点定义在摄像机光轴和图像平面的交点处，称为图像的主点(principal point)，该点一般位于图像中心处，但由于摄像机制作的原因，可能会有些偏离，在坐标系下的坐标为(u0,v0)，每个象素在x轴和y轴方向上的物理尺寸为dx、dy，两个坐标系的关系如下：
其中s’表示因摄像机成像平面坐标轴相互不正交引出的倾斜因子(skew factor)。
3、摄像机坐标系(Camera coordinate system) 摄像机成像几何关系可由图4.2表示，其中O点称为摄像机光心，轴和轴
与成像平面坐标系的x轴和y轴平行，轴为摄像机的光轴，和图像平面垂直。光轴与图像平面的交点为图像主点O’，由点O与轴组成的直角坐标系称为摄像机坐标系。OO’为摄像机焦距。
4、世界坐标系(World coordinate system) 在环境中还选择一个参考坐标系来描述摄像机和物体的位置，该坐标系称为世界坐标系。摄像机坐标系和世界坐标系之间的关系可用旋转矩阵R与平移向量t来描述。由此，空间中一点P在世界坐标系和摄像机坐标系下的齐次坐标分别为和且存在如下关系：
其中R是3×3正交单位矩阵，t是3维平移向量，，M1是两个坐标系之间的联系矩阵。
5、摄像机线性模型 透视投影是最常用的成像模型，可以用针孔成像模型近似表示。其特点是所有来自场景的光线均通过一个投影中心，它对应于透镜的中心。经过投影中心且垂直于图像平面的直线称为投影轴或光轴，如图4.3所示。其中是固定在摄像机上的直角坐标系，遵循右手法则，其原点位于投影中心，轴与投影重合并指向场景，轴和轴与图像平面的坐标轴和平行，平面与图像平面的距离为摄像机的焦距f。在实际摄像机中，图像平面位于投影中心后距离为f的位置，其投影图像是倒立的，为了避免图像倒立，假定有一个虚拟成像x 'y 'z’平面位于投影中心的前面，点在图像平面上的投影位置(x ,y)可以通过计算点的视线与虚拟成像平面的交点得到。
摄像机坐标系与成像平面坐标系之间的关系为：
其中，(x ,y)为P点在成像平面坐标系下的坐标，为空间点P在摄像
机坐标系下的坐标。用齐次坐标与矩阵来表示：
将(4.1)与(4.2)代入上式，得到图像坐标系和世界坐标系之间的关系：
其中，，，[R t]完全由摄像机相对于世界坐标系的方位决定，称为摄像机外部参数矩阵，它由旋转矩阵和平移向量组成；K只与摄像机内部结构有关，称为摄像机内参数矩阵，其中(u0,v0)为主点坐标，分别为图像u轴和v轴上的尺度因子，s是描述两图像坐标轴倾斜程度的参数；P为3 ×4矩阵，称为投影矩阵，即从世界坐标系到图像坐标系的转换矩阵。可见，如果已知摄像机的内外参数，就已知投影矩阵P，对任何空间点，如果已知其三维坐标就可以求出其图像坐标点的位置(u ,v)。但是，如果知道空间某点的图像点的坐标(u ,v)，即使已知投影矩阵，其空间坐标也不是唯一确定的它对应的是空间的一条直线。即单目摄像头只能测平面信息，不能获取深度信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b542e9d44b8c6f4ffc0671176ee19bc6/" rel="bookmark">
			《软件测试的艺术》高清脑图总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位朋友，大家好，我是财哥。
今天财哥为大家带来一本软件测试的经典书籍分享：《软件测试的艺术》，这本书堪称软件测试书籍中的圣经，该书首次印刷于1979年，距今一共发行过三版：第一版，第二版和第三版。很难想象有一本如此“古老”的书籍能存活30多年，本书作者由Glenford J. Myers，Tom Badgett，Corey Sandler几位大佬联手完成。本书在豆瓣上也获得了8.4的评分。
豆瓣评分：
作者简介：
Glenford J. Myers，IBM系统研究所前高级研究员，同时还是RadiSys公司的创始人和前CEO。
Tom Badgett，曾经主管大型企业软件开发团队，已出版超过60本关于计算机软件和硬件的技术书籍，同时他还是PcJr,Digital News等主流计算机杂志的技术编辑。
Corey Sandler，计算机新闻的先锋，他曾经负责Gannett Newspapers 和the Associated Press的技术部分以及之后成为Pc Magazine的第一任主编。他同时还是Digital News（针对DEC小型机的一份报纸）的编辑创始团队成员，他著作等身，目前已经出版了超过150本书籍，覆盖了从计算机到商业以及很多其他领域。
我与本书是2013年刚去百度时候相识的，之前我是在外企负责C++开发，对于软件测试的理解仅限于在大学时期的一些概念。后来去百度做测试开发后，当时的mentor把这本书送给我研读，书很薄，才120页，当时我花了几天时间草草地翻阅完了这本书。说来惭愧，后来我也重读过几遍《软件测试的艺术》，但始终没有投入精力去思考这本书于我的意义。如今我工作将近十年了，在测试开发这个航道大约也有近八年的职场历程，期间也亲身过各式各样软件测试的技术和流程的实践与落地，回想起来，很多软件测试的理念和原则早已经在这本书被作者描绘地一清二楚。
这回再次重读本书，我将对照着逐个章节，反复思考自己是否有在正确地践行软件测试活动，文末也我也为大家整理了一份高清脑图，对本书进行了较为全面的内容整理。下面我就根据书中的每个章节，分享下我的感悟，包括其中的得与失。
第一章「一次自我评价的测试」是本书开篇之章，作者仅仅用了两页，就一语道破软件测试的天机："所谓软件测试，就是一个过程或一些系列的过程，用来确认计算机代码完成了其该完成的功能，不执行不该有的操作。"，这句话可能对很多刚入行软件测试的朋友，或者非软件测试人员（譬如项目经理，产品经理，或者很多开发，算的上是认知上的挑战。软件测试不是仅仅为了验证功能，而是验证在验证其功能的基础上，去尽最大努力发现其没有做不该做的事情。第一章最后也留下了软件测试的小测验，非常建议新入行软件的测试或者对软件测试还不太了解的朋友尝试着做下，可能做完后你会发现，软件测试绝对是一项需要智慧才能完成的活动。
第二章的标题是「软件测试的心理学和经济学」，作者从经济学出发，告诉大家：软件测试无法穷尽测试，需要制定适当的策略（黑盒和白盒）来发现软件的缺陷。另外从心理学上来讲，软件测试应该致力于认为程序/软件是有问题的，用破坏性的思维去设计测试用例，用发散性的思维找出可能之前没有想到的问题，最终作者也给出了软件测试的十大经典原则：
原则1：测试用例中一个必须的部分是对预期输出或结果的定义。
原则2：程序员应当避免测试自己编写的程序。
原则3：编写软件的组织不应当测试自己编写的软件。
原则4：应当彻底检查每个测试的执行结果。
原则5：测试用例的编写不仅应当根据有效和预期的输入情况，而且也应当根据无效和未预料到的输入情况。
原则6：检查程序是否“未做其应当做的”仅是测试的一半，测试的另一半是检查程序是否“做了其不应该做的”。
原则7：应避免测试用例用后即弃，除非软件本身就是一个一次性的软件
原则8：计划测试工作时不应该默许假定不会发现错误。
原则9：程序某部分存在更多错误的可能性，与该部分已发现错误的数量成正比。
原则10：软件测试是一项极富创造性、极具智力挑战性的工作。
在实际的软件测试活动中，我们需要时刻去反思自己是否遵循了以上原则，并应当时时刻刻地用原则去指引自己的软件测试行为，采用PDCA（计划，执行，检查，重复）的方法，不断优化我们的测试模型。
第三章讲到了「代码检查，走查与评审」，我相信除了一二线的软件公司，在其它大部分的公司里面，软件测试人员可能没有义务和权限去评审开发的代码。但不得不说的是：认真地阅读开发的代码，不仅能让自己的业务深度更深，还可以提升自己的技术层次，最终这种代码评审活动会让测试和开发两者产生深厚地联系。所以要做一个好的测试，尽量给自己创造机会，阅读开发的代码，对自己的以后的职场发展，绝对是大有裨益的。在百度的时候，几乎每个人都需要参与code review，对于测试而言，code review不仅帮自己了解清楚了业务逻辑，很多时候对开发代码的设计模式也是叹为观止。经常听有的测试同行抱怨技术得不到提升，其实主动去review 开发同事的代码，并多向其请教细节，就是一件能够快速提升自己代码能力的快捷之路。
第四章是「测试用例的设计」，这一章应该是很多测试小伙伴有共鸣的一章。作者分享了白盒测试，黑盒测试两种测试方法和实用的测试策略。白盒测试是检查程序内部逻辑和结构的一种测试方法，简单来讲：白盒测试需要对代码的分支逻辑进行足够多的用例设计，来验证每条语句的执行结果符合其预期性。白盒测试有如下几类覆盖深度（由浅到深）：
语句覆盖：较弱的准则，将程序中的每条语句至少执行一次。
判定覆盖或分支覆盖：较强的逻辑覆盖准则，必须编写足够的测试用例，使得每个判断都至少有一个为真和为假的输出结果。也就是说每条分支路径都必须至少遍历一次。
条件覆盖：比判定覆盖更强的准则，条件覆盖要编写足够的测试用例以确保将一个判断中的每个条件的所有可能的结果至少执行一次。
判定/条件覆盖：设计出充足的测试用例，将一个判断中的每个条件的所有可能的结果至少执行一次，将每个判断的所有可能的结果至少执行一次，将每个入口点都至少调用一次。
多重条件覆盖：要求编写足够多的测试用例，将每个判定中的所有可能的条件结果的组合，以及所有的入口点都至少执行一次。
从我个人的实际经验来看，从经济和效率的角度出发，我比较建议至少做到条件覆盖，如果能做到判定/条件覆盖更好。很多代码覆盖率检查工具提供了软件测试的代码覆盖度，一般都能分析出语句覆盖率和判定覆盖率。除了代码逻辑的覆盖，我们更常规的测试方法是黑盒的，通过程序功能，设计对应的测试用例，设计输入，判读输出预期，下面再看下黑盒测试：
等价类划分：简单来讲，就是把输入条件进行分类，分为有效等价类（代表对程序的有效输入）无效等价类（代表的则是其他任何可能的输入条件，即不正确的输入值），一分为二地对软件功能进行验证。
边界值分析：挑选出输入和输出等价类中的那些恰好处于边界、或超越边界、或在边界以下的状态，这种临界状态更容易发现一些非预期的问题。
因果图：是一种形式语言，用自然语言描述的规格说明可以转换为因果图，简单来讲就是通过"与,或,非"三类逻辑运算，梳理不同输入条件组合得到的结果。
判定表：对因果图的转换，最终方便设计测试用例。
错误猜测：利用直觉和经验猜测出错的可能类型，然后编写测试用例来暴露这些错误。
黑盒测试中，我觉得比较常用是等价类划分，边界值分析和错误猜测这三类测试方法，这三类测试用例设计方法能够覆盖80%以上的case。因果图和判定表虽然能够更全地设计测试用例，但由于互联网的迭代和节奏的原因，想要完全实践起来并不是那么有效，我建议在一些核心的功能点上去使用因果图判定表去设计测试思路，而在大多数的情况下，因果图可以作为梳理测试用例思路的辅助方法。最终作者也提出了建议的测试策略，先以黑盒测试为主，然后辅佐以白盒测试用例，在测试用例的设计过程中，尽可能地使用错误猜测。
第五章是「模块（单元）测试」，这一部分主要是讲如何设计单元/模块的测试用例，里面讲到了非增量测试和增量测试的两种测试方法。可能大部分的软件测试同行都没在实际的软件测试活动中写过单元测试，原因主要有两个：一是大部分公司不要求写单元测试用例，另外原因是单元测试一般由开发人员编写。我说说我的经历：我在阿里的时候参与过一个大项目的单元测试的编写，最大的感受就是：太过于完整的单元测试确实可以在早期发现很多问题，但是如果工期较紧，最终其实也会拖累软件工期。毕竟在软件开发初期，很多服务都没有一开始就打算完美，都是存在着各种不完美的实现，随着这个过程中不断重构，单元测试用例也需要重构，这个时候，测试用例的工作量可能比软件代码本身工作量还大。
另外再说说模块测试，模块测试其实比较适合现在的软件架构中的微服务模式，作为测试人员，可以基于模块的接口进行测试用例的设计，一般接口的代码稳定程度都还比较高，比函数或者类级别单元测试要稳定许多。和单元测试一样，如果采用的是自底向上的软件开发模式，我们需要及时编写测试驱动程序（driver），去验证已实现模块的功能；如果是自顶向下的软件开发模式，也可以使用mock的方式，编写stub（代码桩）程序，及时对已完成的模块进行输入逻辑的验证。
第六章是「更高级别的测试」，作者分别从如下维度，对功能测试之外的部分进行了测试类型补充。
能力测试：确保程序的目标功能实现。
容量测试：发现处理大容量数据时的程序异常。
强度测试：发现在大规模负载、高强度不间断持续的数据处理中的异常。
可用性测试：评估最终用户在使用软件并与软件交互时存在的可用性问题。
安全性测试：试图攻破程序的安全防线。
性能测试：评估程序的的响应时间和吞吐率。
存储测试：确保程序可以正确处理其对存储的需求。
配置测试：检查程序是否能在推荐配置上流程运行。
兼容性/转换测试：评估新版本是否能兼容老的版本。
安装测试：确保能够在所有支持的平台上安装软件。
可靠性测试：评估程序是否能达到规格说明中的运行时常和平均故障间隔时间要求。
可恢复性测试：测试系统恢复相关的功能是否按设计要求实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b542e9d44b8c6f4ffc0671176ee19bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be0d1bd06996a21bd1f5fc4164080acb/" rel="bookmark">
			蓝桥杯：人物相关性分析（双指针&#43;双数组存储）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 蓝桥杯：人物相关性分析 题解： 最容易想到的便是枚举遍历，但由于数量巨大必定会超时。
因此我们可考虑使用双指针来模拟滑动窗口解决该题。
首先我们创建两个数组用双指针查找分别存储出现的Alice和Bob的头部下标，接着我们再遍历两个数组，任选出现的Alice和Bob的下标进行逻辑上的比较，符合题目范围则sum加一，否则不加即可。
（这里我写的是这里我写的是Alice左边和右边为空格的情况，该题为左右不能为字母即可 ，所以将左右两个字符的范围根据ascii码限制一下即可）
代码： #include &lt;bits/stdc++.h&gt; using namespace std; char str[1000001]; int a1[1000000]; int a2[1000000]; int main() { int i,j,k,t; i = 0; j = 0; k = 0; cin&gt;&gt;t; while(getchar()!='\n');//需要吸收缓冲区字符 gets(str);//其会录入空格 int n = strlen(str); while(i&lt;n) { if(i+6&lt;n)//保证不越界，且不满足时查找也没有意义了 { if(str[i]==' '&amp;&amp;str[i+1]=='A'&amp;&amp;str[i+2]=='l'&amp;&amp;str[i+3]=='i'&amp;&amp;str[i+4]=='c'&amp;&amp;str[i+5]=='e'&amp;&amp;str[i+6]==' ')//这里我写的是Alice左边和右边为空格的情况，该题为左右不能为字母即可 {	//所以将左右两个字符的范围根据ascii码限制一下即可 a1[j++] = i+1; } } if(i+4&lt;n)//同 { if(str[i]==' '&amp;&amp;str[i+1]=='B'&amp;&amp;str[i+2]=='o'&amp;&amp;str[i+3]=='b'&amp;&amp;str[i+4]==' ')//同 { a2[k++] = i+1; } } i++; } int sum = 0;//记录个数总和 for(int m=0;m&lt;j;m++)//再遍历一次存储alice和bob的数组看是否有符合的 { for(int q=0;q&lt;k;q++) { if(a2[q]-a1[m]-5&lt;=t&amp;&amp;a2[q]-a1[m]-5&gt;0)//一前一后，两种情况 { sum++; } if(a1[m]-a2[q]-3&lt;=t&amp;&amp;a1[m]-a2[q]-3&gt;0) { sum++; } } } cout&lt;&lt;sum; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8a104054d8c71e13fff25428af9a89b/" rel="bookmark">
			IDEA配置JDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA配置jdk 一、前提条件：已经下载安装jdk，并且配置好环境变量。如没有安装，请点击下方链接，进行安装与配置。
链接在这里
二、配置jdk
1.打开IDEA，点开File-&gt;Project Structure,点击标签
2.点击SDK，如果没有，请点击NEW，然后点击JDK选择路径（地址是你自己的安装目录），然后点击OK，页面显示成功，结束配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf85741b99c595fd8e371acde50121c/" rel="bookmark">
			SpringMVC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring 包结构
Spring Web MVC 框架
Spring web MVC 框架提供了模型-视图-控制的体系结构和可以用来开发灵活、松散耦合的 web 应用程序的组件。MVC 模式导致了应用程序的不同方面(输入逻辑、业务逻辑和 UI 逻辑)的分离，同时提供了在这些元素之间的松散耦合。
1)模型封装了应用程序数据，并且通常它们由 POJO 组成
2)视图主要用于呈现模型数据，并且通常它生成客户端的浏览器可以解释的 HTML 输出。
3)控制器主要用于处理用户请求，并且构建合适的模型并将其传递到视图呈现。
注解
bean注解
i.@Component --/
ii.@Repository – dao
iii.@Service - service
iv.@Controller - controller
注入注解
i.@Autowired – 自动注入
ii.@Resource – 先根据名字匹配，再根据类型匹配
iii.@Qualifier –
Aop注解
i.@Aspect
ii.@Pointcut(“execution(* com.srr.service..(…))”)
iii.@Before(“pointcut()”)
iv.@AfterReturning(pointcut = “pointcut()”,returning = “result”)
v.@After(“execution(* com.srr.service..(…))”)
vi.@Around(“execution(* com.srr.service..(…))”)
vii.@AfterThrowing(pointcut = “execution(* com.srr.service..(…))”,throwing = “e”)
mvc注解
i.@RequestMapping(“hello1”)
ii.@RequestParam(value = “id”,required = false)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebf85741b99c595fd8e371acde50121c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f15406816f86fbe2999f296c556db0ef/" rel="bookmark">
			php sqlite3 fetch,PHP sqlite_fetch_array 用法 手册 | 示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Editor's note: to get short column names there's an undocumented PRAGMA setting. You can exec "PRAGMA short_column_names = ON" to force that behavior.]
I noticed that if you use Joins in SQL queries, the field name is messed up with the dot!
for example if you have this query:
SELECT n.*, m.nickname FROM news AS n, members AS m WHERE n.memberID = m.id;
now if you want to print_r the results returned using SQLITE_ASSOC type, the result array is like this :
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f15406816f86fbe2999f296c556db0ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34185c73116eebf7402bc67a3cb2f1af/" rel="bookmark">
			多层跳板攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 首先，我们在上一章的基础上，即在Windows Server2003的主机上又发现了另一层的网络，所以我们就必须在以win2003为跳板机，再去访问下一个网段的主机，即多层跳板攻击。
攻击过程 我们这里使用一台Linux主机为另一个服务器，并设置一个新的网段来进行隔离，原理和上一章的差不多
查看win2003时发现新的网段
然后我们使用arp_scan模块扫描出更多的主机
更新路由表并打印出来
然后我们再新开一个socks4a代理，并使用jobs命令查看任务，因为之前使用了1080这个端口，因此我们端口必须要重新设置一个新的
接着我们使用相同的方法，使用proxychains对目标主机服务进行探测，首先我们得先配置proxychains配置文件
发现目标主机开放了22,80,139,445端口
我们可以用之前章节使用的密码爆破的方法将主机的用户名和密码都爆破出来，因为我们这里使用的是metasploitable2靶机，默认用户名和密码是msfadmin，我们用proxychains登录其主机中
从上面我们也发现目标主机开启了80端口服务，因此我们也能从网页的形式进一步渗透目标主机，但是浏览器上要设置相应的代理，因为目标网段本身不对外开放，这里我使用的是FoxyProxy这个浏览器代理插件
访问成功
总结 现在我们对整个入侵思路进行一个总结。首先我们先使用kali攻击机，在本公司的防火墙上设置好NAT端口映射，目的是为了接受目标机反弹回来的shell，当我们对其中一台目标机①掌握了控制权后，我们在这台主机上发现了另一个网段(104网段吧)，然后我们以主机①为跳板机，去访问104网段，我们使用proxychains工具隐藏自己的真实访问IP，然后拿下主机②时，又发现另一个网段时，用相同的方法进行横向，多层跳板攻击的过程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/427b9ea18b28ba177f9a9ce9a4b477cd/" rel="bookmark">
			微服务架构-分布式解决方案-108：XXL-JOB分片集群模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		108：XXL-JOB分片集群模式 1 如何高效的定时群发所有的数据2 定时任务与业务逻辑一定要分离3 XXL-Job任务调度平台设计原理4 SpringBoot整合XXL-Job5 XXL-Job轮询机制底层执行方式6 XXL-Job底层分片集群模式7 执行器如果宕机了，任务会丢失吗 1 如何高效的定时群发所有的数据 课题内容
腾讯课堂、微信公众号定时消息推送实现原理随着用户的增长，如何高效定时群发完所有数据定时任务执行器如何实现动态的扩容与缩容设计一套千万级定时消息推送平台 腾讯课堂公开课定时群发推送消息
假设第一天每特教育公开课订阅人数2万人，5分钟全部推送完毕，第二天每特教育公开课订阅人数增加到3万人，请问5分钟能够全部推送完毕吗？
思考：如何随着用户数的不断增加，消息推送要在规定的时间内群发完毕。
2 定时任务与业务逻辑一定要分离 定时任务监听最大的缺陷：
非常占用服务器的内存，底层一定是通过死循环实现。
定时任务代码是否能够和业务代码放入同一个jar包中部署？
稍微比较大的互联网公司业务代码和定时任务代码都是分开部署的。
定时任务模块为了提高效率集群部署，要注意保证幂等性。
定时任务集群执行的时候，如何保证数据的幂等性？
任务调度分片集群。
3 XXL-Job任务调度平台设计原理 分布式任务调度平台的原理：
将定时任务项目（执行器）服务ip和端口号手动注册到分布式任务调度平台的注册中心中，触发定时任务的时候先走分布式任务调度中心，先去注册中心获取执行器集群列表，采用负载均衡算法得到一个地址，再采用rpc通知执行器执行定时任务。
注意任务调度中心给每个执行器发rpc通知的时候都会带不同的参数。
4 SpringBoot整合XXL-Job maven依赖
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.11.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置文件（resources目录下）
application.yml
# web port server.port=8081 # log config logging.config=classpath:logback.xml ### xxl-job admin address list, such as "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/427b9ea18b28ba177f9a9ce9a4b477cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2edf2a289c4cbd4fd7f6b848dd5cd1f9/" rel="bookmark">
			Window网络编程之简单TCP建立
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 步骤分解搭建SOCKET开发环境开发环境说明启动SOCKET说明 创建TCP服务器创建SOCKET原型使用 绑定端口原型使用 监听连接原型使用 连接客户端原型使用 向客户端发送数据原型使用 关闭服务器原型使用 创建TCP客户端创建SOCKET使用 连接服务器原型使用 接收数据原型使用 运行结果 步骤分解 服务端建立
步骤说明涉及函数建立服务端SOCKETsocket绑定服务IP和端口bind监听网络端口listen等待建立连接accept发送数据send关闭服务端SOCKETclosesocket 客户端建立
步骤说明涉及函数建立客户端SOCKETsocket连接服务器connect接收数据recv关闭服务端SOCKETclosesocket 搭建SOCKET开发环境 开发环境说明 window下进行SOCKET编程依赖两个库如下所示：
较早的DLL是wsock32.dll，对应的头文件为winsock1.h；最新的DLL是ws2_32.dll，对应的头文件为winsock2.h。 基本所有的window操作系统都已经支持了ws2_32.dll，因此可以直接使用这个库无需考虑第一个比较早的库。除了导入头文件之外还需要导入ws2_32.lib链接库，可使用显示导入方式
#pragma comment (lib, "ws2_32.lib") 如果在vs开发环境下也可以在项目属性中添加依赖库，如果使用Clion则在CMakeLists中add_executable语句前增加一条语句
link_libraries(ws2_32) 启动SOCKET说明 SOCKET标准的启动过程如下：
#include &lt;iostream&gt; #include &lt;WinSock2.h&gt; int main(int argc, char * argv[]) { WSADATA wsa_data; WSAStartup(MAKEWORD(2, 2), &amp;wsa_data); // ...... WSACleanup(); return 0; } 使用MAKEWORD(2, 2)来明确SOCKET的版本号，WinSock规范的最新版本号为2.2版本，wsock32.dll仅支持1.0和1.1，wsock32.dll已经能够很好的支持TCP/IP通信程序的开发，ws2_32.dll主要增加了对其他协议的支持，建议使用最新的2.2版本。
如果当前工程中还需要用到window.h头文件，需要在引入任何头文件之前增加WIN32_LEAN_AND_MEAN宏定义，减少对较早SOCKET版本的依赖，如果能保证window.h在WinSock2.h之后引入也可不添加次宏定义。
创建TCP服务器 创建SOCKET 原型 int socket(int af, int type, int protocol); 参数说明：
字段说明参数填写af地址族，使用IP的类型AF_INET = IPv4，AF_INET6 = IPv6type数据传输方式SOCK_STREAM = 面向连接，SOCK_DGRAM = 面向连接protocol传输协议IPPROTO_TCP，IPPTOTO_UDP 使用 int main(int argc, char * argv[]) { WSADATA wsa_data; WSAStartup(MAKEWORD(2, 2), &amp;wsa_data); SOCKET server_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); WSACleanup(); return 0; } 绑定端口 原型 int bind(SOCKET sock, const struct sockaddr *addr, int addrlen); 参数说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2edf2a289c4cbd4fd7f6b848dd5cd1f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac0db453b4b172212e7396a09d44fba7/" rel="bookmark">
			正运动学建模方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【前言】
回顾前面，通过二连杆引入了机器人建模一些内容，其中包括机器人正运动的建模、机器人逆运动学建模、机器人动力学建模，以及涉及一点机器人控制的方法。大体了解了机器人领域需要的知识。详细的内容还需根据相关书籍进一步丰富。重回机器人正运动学，本篇的主要目的在于掌握机器正运动学的建模方法。
【正运动学】 以平面二自由度机械臂为例，正运动学的目的在于：在已知机械臂的关节变量θ1、θ2的情况下，求解机械臂末端的位姿。涉及目标的位姿，需要考虑的目标坐标系的建立（毕竟姿态和位置是相对坐标系而言）；而坐标系的建立可以任意选择，每个人建立坐标系的方式不同，将不利于行业人员的交流。因此，为了解决这个问题，业内制定了一套约定----Denavit-Hartenberg约定。
1.1 Denavit-Hartenberg约定
简称DH约定，用于正运动的分析；其主要的约束条件有：
（DH1）坐标轴xi垂直于坐标轴zi-1；
（DH2）坐标轴xi与坐标轴zi-1相交；
通过这两条约定，存在唯一的a、d、θ、α使得相邻的坐标齐次变换矩阵可以表示为：
A=Rot(θ)Trans(d)Trans(a)Rot(α)
关于这四个变量以下图为例，有以下定义：
图1满足DH1与DH2约定的坐标系
a-----表示连杆长度，z0与z1之间沿公共法线x1测得得距离；
α----表示连杆扭曲，一个关节轴相对另一个关节轴绕公共法线旋转的角度；
d----表示连杆偏置，O1到x1与z0交点的距离；
θ-----表示关节角度，垂直于Z0平面内x0与x1的角度
1.2 建模实例
（1）DH约定建模
根据DH约定，对以下平面肘型机械臂进行正运动学建模。
第一步：编号
需注意坐标系、杆和关节变量的下标的编号：
a.坐标系从0开始编号，O0,O1,…On,其中O0为基坐标系;
b.关节变量从1开始编号，θ1,θ2,…θn+1;
c.杆从1开始编号，L1,L2,…Ln+1;
第二步：根据以上绘制DH表
第三步：写出齐次变换矩阵；
第四步：根据链式法则写出齐次变换矩阵(4*4)；
第五步：根据变换矩阵写出杆件各连接点的坐标；
clc;clear; close all; global ulink; %定义机械臂参数 ulink.l1=5; ulink.l2=5; ulink.sida1 = 45/180*pi; ulink.sida2 = 90/180*pi; %---------------------------------------------- % | a_i | alfa_i | d_i | sida_i % 1 | l1 | 0 | 0 | sida1 % 2 | l2 | 0 | 0 | sida2 %-------------------------------------------- %DH约定：xi与zi-1相交且垂直 %DH齐次变换矩阵 % Ai = % [ cos(sida_i), -cos(alfa_i)*sin(sida_i), sin(alfa_i)*sin(sida_i), a_i*cos(sida_i)] % [ sin(sida_i), cos(alfa_i)*cos(sida_i), -sin(alfa_i)*cos(sida_i), a_i*sin(sida_i)] % [ 0, sin(alfa_i), cos(alfa_i), d_i] % [ 0, 0, 0, 1] syms sida_i alfa_i a_i d_i %计算齐次矩阵 sida_i = ulink.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac0db453b4b172212e7396a09d44fba7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a9d1326020613edb4830b0b4762cd14/" rel="bookmark">
			宏定义的用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
宏定义是一个给定名称的代码片段，当我们使用这个名称的时候，预处理器会自动将其替换为宏定义的内容。宏定义有两种，一种是object-like宏定义，在使用的时候相当于一个数据对象；另一种是function-like，在使用的时候就像调用函数那样。
宏定义的内容可以是任意的，甚至是C关键词(不可以的内容特例[预处理命令]defined,[c++ named operators]and_eq,bitand,bitor,compl,not,not_eq,or,or_eq,xor,xor_eq)
宏展开会使源程序变长，但是宏展开发生在编译过程中，不占运行时间，只占编译时间。
宏展开因为在预处理阶段发生，不会分配内存。
宏替换发生时机
编译c源程序的过程：
预处理
编译
汇编
连接
预处理产生编译器的输出，实现功能如下
文件包含
把#include中包含的内容拓展为文件的正文，即找到.h文件，同时展开到#include所在处
条件编译
根据#if和#ifdef等编译命令，将源程序文件中的部分包含进来，部分排除，排除在外的一般转换为空行
宏展开
将对宏的调用展开成相对应的宏定义
object-like宏定义
形式
通常形式：#define &lt;宏名&gt; &lt;字符串&gt;
#define后面紧跟的是宏定义的代码段的名称，再然后是宏名所要表示的token序列
通常来说我们用object-like宏定义对于数字常量给出一个符号代替
例子: #define BUFFER_SIZE 1024
这里面宏名就是BUFFER_SIZE，所要代替的token序列就是1024。然后当你使用BUFFER_SIZE的时候，预处理器就会将其拓展，这样编译器在处理的时候就会将其看作1024
例如源代码foo = (char*)malloc(BUFFER_SIZE)，经过预处理器处理后，编译器将其等同于foo = (char*)malloc(1024)。
用法
通常来说宏名以全大写字母书写(约定俗成，方便阅读)
#define命令会在该行结束的时候停止，如果想要同时作用于多行，那么需要在后面加上\，注意\后面不要在加空格等空白符，直接是换行符
例如
#define NUMBERS 1, \
2, \
3
1
2
3
等价于
#define NUMBERS 1, 2, 3
1
宏定义的字符串内容几乎没有限制(需要保证括号的相互平衡)
由于C预处理器在处理程序的时候是顺序的，因此宏定义从其定义的位置开始作用。
宏定义可以嵌套定义，也就是说如果在替换的时候，遇到了另一个宏定义名称，那么将会继续进行替换
也就是说
#define A B
#define B 1
1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a9d1326020613edb4830b0b4762cd14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3884633a9a9881b8fd5cfbac16479d8f/" rel="bookmark">
			Eclipse安装、激活、配置最新版JRebel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Eclipse安装JRebel 1.1打开Eclipse Marketplace 1.2搜索jrebel，选择第一个进行安装 1.3 继续安装，一路下一步，过程截图如下： 2.在线激活 2.1 在设置中打开JRebel，点击左侧的Jrebel Configuration 2.2 在设置中打开JRebel，点击左侧的Jrebel Configuration，如下为未激活的状态 2.3 输入网址及GUID在线生成，邮箱，直接激活 2.4 激活成功 3.配置及使用 必须设置项目为自动编译，否则无法触发热部署
3.1 选择运行方式（本人Spring boot项目） 3.2 启动（如出现如下信息，说明配置成功） 3.3 修改代码验证（修改代码并保存后，控制台输出如下信息代表已经热部署成功） 3.4 改为离线方式 成功切换到离线方式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/977ebd72078d36616cc999b3de698d4d/" rel="bookmark">
			matlab p值 z值,显著性水平 p值 z值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 显著性水平
显著性水平是估计总体参数落在某一区间内，可能犯错误的概率，用α表示。
α表示原假设为真时，拒绝原假设的概率。
1-α 为置信度或置信水平，其表明了区间估计的可靠性 。
2 P值
在假设检验中常见到P值即概率，反映某一事件发生的可能性大小。
统计学根据显著性检验方法所得到的P 值，一般以P &lt; 0.05 为有统计学差异， P&lt;0.01 为有显著统计学差异，P&lt;0.001为有极其显著的统计学差异。其含义是样本间的差异由抽样误差所致的概率小于0.05 、0.01、0.001。
数据解释
P值
碰巧的概率
对无效假设
统计意义
P&gt;0.05
碰巧出现的可能性大于5%
不能否定无效假设
两组差别无显著意义
P&lt;0.05
碰巧出现的可能性小于5%
可以否定无效假设
两组差别有显著意义
P &lt;0.01
碰巧出现的可能性小于1%
可以否定无效假设
两者差别有非常显著意义
3 P值和显著性水平区别
显著性水平：显著性水平是假设检验中的一个概念，是指当原假设为正确时人们却把它拒绝了的概率或风险。它是公认的小概率事件的概率值，必须在每一次统计检验之前确定，通常取α=0.05或α=0.01。这表明，当作出接受原假设的决定时，其正确的可能性(概率)为95%或99%。
P值：p值是指在一个概率模型中，统计摘要(如两组样本均值差)与实际观测数据相同，或甚至更大这一事件发生的概率。换言之，是检验假设零假设成立或表现更严重的可能性。p值若与选定显著性水平(0.05或0.01)相比更小，则零假设会被否定而不可接受。
4 z值
z统计是用来衡量样本均值偏离整体均值的方差倍数，就是偏离方差的程度。
根据中心极限定理，总体样本N，每次抽样数n，每次抽样的均值的分布趋近正态分布。也就是随机误差符合正态分布。其分布的数学期望为总体均值μ，方差为总体方差的1/n。
Z值与P值关系
P值 差异程度
非常显著
显著
&lt;1.96
&gt;0.05
不显著
如果检验一个样本平均数(
)与一个已知的总体平均数(μ0)的差异是否显著。其Z值计算公式为：
其中：
是检验样本的平均数；
μ0是已知总体的平均数；
S是样本的标准差；
n是样本容量。
标签：显著性,无效假设,假设,水平,显著,概率,0.05
来源： https://blog.csdn.net/genghaihua/article/details/91958522
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fd6bdabd9d3eec7bdb0d5a1b035f350/" rel="bookmark">
			php 调用eth智能合约,以太坊常见问题和错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我对如何使怎么用Web3.js 1.0认证和发送提交智能合约的方法感到很困惑。
这是工作代码(通常我要先手动解锁帐户)：
var contract = new web3.eth.Contract(contractJson, contractAddress);
contract.methods
.transfer("0x0e0479bC23a96F6d701D003c5F004Bb0f28e773C", 1000)
.send({
from: "0x2EBd0A4729129b45b23aAd4656b98026cf67650A"
})
.on('confirmation', (confirmationNumber, receipt) =&gt; {
io.emit('confirmation', confirmationNumber);
});
我得到这个错误(如果我不手动解锁的话)：
Returned error: authentication needed: password or unlock
上面的代码是Node.js中的一个API端点，我希望它以编程方式解锁或做身份认证(鉴权)。
在Web3.js 1.0中好像没有解锁帐户的方法。
我也不认为这是必要的(这就是我所困惑的)。因为我在管理帐号，所以我知道私钥是什么。
我想交易需要用私钥签名吗？这是正常的吗？这与unlocking the account账户解锁是否有关？
我又试着这样写代码：
var contract = new web3.eth.Contract(contractJson, contractAddress);
var tx = {
from: "...{fromAddress -- address that has the private key below}",
to: "...",
value: ...
};
var signed = web3.eth.accounts.signTransaction(tx,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fd6bdabd9d3eec7bdb0d5a1b035f350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6cd6c5c98550803e738cc9cf5b5a9ec/" rel="bookmark">
			【C语言】 --- 段错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接 https://blog.csdn.net/xuleilx/article/details/7365424
http://www.blog.chinaunix.net/uid-28414100-id-5759543.html
https://blog.csdn.net/weixin_40005437/article/details/111210315
https://baike.so.com/doc/4335071-4539876.html
一、段错误的概念 存储器区段错误（英语：Segmentation fault，经常被缩写为segfault），又译为存储器段错误，也称访问权限冲突（access violation），是一种程序错误。
它会出现在当程序企图访问CPU无法寻址的存储器区段时。当错误发生时，硬件会通知操作系统产生了存储器访问权限冲突的状况。操作系统通常会产生核心转储（core dump）以方便程序员进行调试。通常该错误是由于调用一个地址，而该地址为空（NULL）所造成的，例如链表中调用一个未分配地址的空链表单元的元素。数组访问越界也可能产生这个错误。（摘抄自wiki）
段错误就是指访问的内存超出了系统所给这个程序的内存空间，通常这个值是由gd tr来保存的，他是一个48位的寄存器，其中的32位是保存由它指向的 gdt表，后13位保存 相应于gdt的下标，最后3位包括了程序是否在内存中以及程序的在cpu中的运行级别，指向 的gdt是由以64位为一个单位的表，在这张表中就保存着程序运行的代码段以及数据段的起 始地址以及与此相应的段限和页面交换还有程序运行级别还有内存粒度等等的信息。（摘自360百科）
二、编程中常遇到段错误的地方有那些 1. 指针指向非法内存 定义了指针变量，但是没有为其分配内存，即指针没有指向一块合法的内存。这里列举几个比较隐蔽的例子。
1.1 结构体指针变量的定义和引用错误 #include &lt;stdio.h&gt; struct student { char *name; int score; }stu,*pstu; int main() { strcpy(pstu.name,"Jimy"); stu.score = 99; return 0; } 这里的pstu只是一个结构体指针，并没有分配具体的内存。
直接去引用pstu当然会出错。
关于结构体变量的定义可以查看我之前的一篇文章
1.2 结构体内部指针变量处理错误 还是上面的例子，稍作修改
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { struct student { char *name = (char *)malloc(sizeof(char) * 10); int score; }stu, *pstu; pstu = (struct student*)malloc(sizeof(struct student)); strcpy(pstu-&gt;name, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6cd6c5c98550803e738cc9cf5b5a9ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd614bddaaf46b2f468dd804268624f4/" rel="bookmark">
			景观格局指数计算方法及代表的生态学意义（待补充）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		景观指数 景观指数是指高度浓缩景观格局信息，反映其结构组成和空间配置某些方面特征的简单定量指标
景观指数的指标有很多种，包括以下多种指数（拼块现多称为斑块）：参考景观格局指数及各指数意义
这里对部分景观指数进行说明
斑块面积指标 斑块面积：斑块总面积A,或者某一类型景观斑块总面积CA.
斑块面积百分比(PLAND) 斑块面积百分比，有的也叫斑块面积比例，即各种类型地类占总面积的比例，面积最大的为主要景观。
其中：aij代表第 i 类景观类型中第 j 个斑块的面积(m2)；A 为景观的总面积（hm2）。斑块面积百分比值接近于零时，表明景观中该斑块类型减少；比值等于 100 时则表示整个景观中只由 1 类斑块构成。
最大斑块指数(LPI) 最大斑块指数(LPI)用于确定景观中的优势斑块类型
其中：amax指景观或某一种斑块类型中最大斑块的面积（m2）。该指数值的大小可以帮助确定景观中的优势斑块类型，间接反映人类活动干扰的方向和大小。 有效网格面积(MESH) 是景观中斑块面积的平方和与景观总面积的比值，可用于比较景观中斑块的平均面积。景观总面积不变时，有效网格变大，反映该类型面积增加，表明其在景观中的比重加大。
密度大小及差异指标 斑块数量（NP) 斑块的个数，或者某一类景观斑块的个数
斑块密度(PD) 斑块密度(PD)表现某种斑块在景观中的密度，可反映出景观整体的异质性与破碎度以及某一类型的破碎化程度，反映景观单位面积上的异质性。
公式为：PD=NP/A
式中NP———斑块数量，个；A———景观或斑块的总面积，hm2；PD———斑块密度，个/hm2
多样性指标 香农多样性(SHDI) 公式：H=-ΣPilnPi
生态意义：SHDI是一种基于信息理论的测量指数，在生态学中应用很广泛。该指标能反映景观异质性，特别对景观中各拼块类型非均衡分布状况较为敏感，即强调稀有拼块类型对信息的贡献，这也是与其它多样性指数不同之处。在比较和分析不同景观或同一景观不同时期的多样性与异质性变化时，SHDI也是一个敏感指标。如在一个景观系统中，土地利用越丰富，破碎化程度越高，其不定性的信息含量也越大，计算出的SHDI值也就越高。景观生态学中的多样性与生态学中的物种多样性有紧密的联系，但并不是简单的正比关系，研究发现在一景观中二者的关系一般呈正态分布。
香农均匀度(SHEI) 公式描述：SHEI等于香农多样性指数除以给定景观丰度下的最大可能多样性（各拼块类型均等分布）。
其中：m 是指景观中斑块类型的总数，Pi是指斑块类型 i 占整个景观的面积比。当指数值为 0 时代表景观中不存在多样性，值为 1 时是指景观中不同斑块类型所占总体面积比一致，呈现完全均匀状态，在范围内指数值越大代表景观中不同斑块类型所占面积比越接近，均匀程度越高。即 SHEI 值越小则景观中可能存在优势斑块类型支配该景观，值越大接近于 1 时表明景观中斑块类型分布均匀不存在明显的优势类型。
SHEI=0表明景观仅由一种拼块组成，无多样性；SHEI=1表明各拼块类型均匀分布，有最大多样性。
生态意义：SHEI与SHDI指数一样也是我们比较不同景观或同一景观不同时期多样性变化的一个有力手段。而且，SHEI与优势度指标（Dominance）之间可以相互转换（即evenness=1-dominance）,即SHEI值较小时优势度一般较高，可以反映出景观受到一种或少数几种优势拼块类型所支配；SHEI趋近1时优势度低，说明景观中没有明显的优势类型且各拼块类型在景观中均匀分布。
斑块形状指标 周长面积分维数(PAFＲAC) 指景观不规则几何形状的非整数维数，反映景观形状复杂程度。
该指数能在一定程度上反映出人类活动对景观格局的干扰程度，当指数值越小即趋于 1 时说明景观中斑块形状较简单，则可能受人类活动干预程度较小，而指数值越大即接近 2 时则越复杂，受人类活动干扰程度越大。 聚散性指标 凝聚度(COHESION) 聚集度(CLUMPY)反映斑块在景观中的聚集和分散状态，数值在－1～1之间，当指数结果为－1时斑块为完全分散型状态，结果为0时呈随机分布，结果为1时为聚集状分布。
其中：aij指第 i 类景观中第 j 个斑块的面积(m2)；pij代表第 i 类景观中第 j 个斑块的周长(m)；A 为该景观的总面积（hm2）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd614bddaaf46b2f468dd804268624f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1581ed101dcd2a87ccc0c6cda1135d4/" rel="bookmark">
			信息编码表示：ASCLL、汉字信息编码略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ASCLL 全称：美国国家信息交换标准代码（American Standard Code for Information Interchange）。
ASCLL码是一种7位二进制编码，能表示27=128种国际上最通用的西文字符，是目前计算机中，特别是微型计算机中，使用最普遍的字符编码集。
字符分为：大小写字母、数字0~9（整数）、其他符号、控制符
需要记住的一些值：
'A' = 65
'a' = 97
' ' = 32（空格）
'0' = 48
口诀：大A加上空格等于小a。
ASCLL码由基本和扩充的ASCLL码组成。
基本ASCLL码：二进制最高位为0的数字都称为基本的ASCLL码，基本ASCLL码有27=128个。范围是0~127。扩充ASCLL码：二进制最高位为1的数字都称为扩展的ASCLL码，扩充ASCLL码有27=128个。范围是128~255。 汉字编码 汉字编码
目前的文字编码标准主要有 ASCII、GB2312、GBK、Unicode等。ASCII 编码是最简单的西文编码方案。GB2312、GBK、GB18030 是汉字字符编码方案的国家标准。ISO/IEC 10646 和 Unicode 都是全球字符编码的国际标准 。下面对与汉字相关的编码方案GB2312，GBK与GB18030做简要的分析。
GB2312-80 标准
GB2312-80 是 1980 年制定的中国汉字编码国家标准。共收录 7445 个字符，其中汉字 6763 个。GB2312 兼容标准 ASCII码，采用扩展 ASCII 码的编码空间进行编码，一个汉字占用两个字节，每个字节的最高位为 1。具体办法是：收集了 7445 个字符组成 94*94 的方阵，每一行称为一个“区”，每一列称为一个“位”，区号位号的范围均为 01-94，区号和位号组成的代码称为“区位码”。区位输入法就是通过输入区位码实现汉字输入的。将区号和位号分别加上 20H，得到的 4 位十六进制整数称为国标码，编码范围为 0x2121～0x7E7E。为了兼容标准 ASCII 码，给国标码的每个字节加 80H，形成的编码称为机内码，简称内码，是汉字在机器中实际的存储代码GB2312-80 标准的内码范围是 0xA1A1～0xFEFE 。
GBK 编码标准
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1581ed101dcd2a87ccc0c6cda1135d4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/320/">«</a>
	<span class="pagination__item pagination__item--current">321/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/322/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>