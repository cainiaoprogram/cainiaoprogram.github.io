<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b96b4b94d38986e407fd28df7cc059/" rel="bookmark">
			Ubuntu20.04安装Navigation功能包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu20.04安装Navigation功能包 ​ 1、在用户目录下（~/）创建工作空间目录：nevigation_ws/src；
cd ~/ mkdir -p nevigation/src ​ 2、进入到~/nevigation/src目录下，下载navigation功能包（下载地址：https://github.com/ros-planning/navigation.git）；
cd ~/nevigation/src git clone https://github.com/ros-planning/navigation.git ​ 3、安装依赖；
sudo apt-get install ros-noetic-navigation* sudo apt-get install ros-noetic-pointcloud-to-laserscan ​ 4、编译：在~/nevigation目录下，执行catkin_make；
cd ~/nevigation catkin_make ​ 5、编译成功。
​ 执行编译后可能会报的错误：
​ 1、Could NOT find Bullet (missing: BULLET_DYNAMICS_LIBRARY BULLET_COLLISION_LIBRARY BULLET_MATH_LIBRARY BULLET_SOFTBODY_LIBRARY BULLET_INCLUDE_DIR)
​ 解决方法：
sudo apt-get install ros-noetic-navigation* ​ 2、Could NOT find Bullet SDL
​ 解决方法：
sudo apt-get install ros-noetic-navigation* ​ 3、报错
Could not find a package configuration file provided by "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64b96b4b94d38986e407fd28df7cc059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/912f5ebce5248d14edae412c8935d129/" rel="bookmark">
			Python基础之爬取豆瓣图书信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 所谓爬虫，就是帮助我们从互联网上获取相关数据并提取有用的信息。在大数据时代，爬虫是数据采集非常重要的一种手段，比人工进行查询，采集数据更加方便，更加快捷。刚开始学爬虫时，一般从静态，结构比较规范的网页入手，然后逐步深入。今天以爬取豆瓣最受关注图书为例，简述 python教程在爬虫方面的初步应用，仅供学习分享使用，如有不足之处，还请指正。
涉及知识点 如果要实现爬虫，需要掌握的Pyhton相关知识点如下所示：
requests模块：requests是python实现的最简单易用的HTTP库，建议爬虫使用requests。关于requests模块的相关内容，可参考及简书上的BeautifulSoup模块：Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库。它能够通过你喜欢的转换器实现惯用的文档导航，查找，修改文档的方式。关于BeautifulSoup的更多内容，可参考。json模块：JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写。使用 JSON 函数需要导入 json 库。关于json的更多内容，可参考。re模块：re模块提供了与 Perl 语言类似的正则表达式匹配操作。关于re模块的更多内容，可参考。 目标页面 本例中爬取的信息为豆瓣最受关注图书榜信息，共10本当前最受欢迎图书。
爬取页面URL【Uniform Resource Locator,统一资源定位器】：https://book.douban.com/chart?subcat=F
爬取页面截图，如下所示：
爬取数据步骤 1. 分析页面 通过浏览器提供的开发人员工具（快捷键：F12），可以方便的对页面元素进行定位，经过定位分析，本次所要获取的内容，包括在UL【class=chart-dashed-list】标签内容，每一本书，都对应一个LI元素，是本次爬取的目标，如下所示：
每一本书，对应一个Li【class=media clearfix】元素，书名为对应a【class=fleft】元素，描述为P【class=subject-abstract color-gray】标签元素内容，具体到每一本书的的详细内容，如下所示：
2. 下载数据 如果要分析数据，首先要进行下载，获取要爬取的数据信息，在Python中爬取数据，主要用requests模块，如下所示：
1 def get_data(url): 2 """ 3 获取数据 4 :param url: 请求网址 5 :return:返回请求的页面内容 6 """ 7 # 请求头，模拟浏览器，否则请求会返回418 8 header = { 9 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) ' 10 'Chrome/70.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/912f5ebce5248d14edae412c8935d129/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8276d7d33f4b484fba724d11b8061742/" rel="bookmark">
			RoBERTa 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0. 背景1. 介绍2. 背景3. 实验设置3.1 配置3.2 数据3.3 评估 4. 训练过程分析4.1 Static vs Dynamic Masking4.2 Model Input Format and NSP4.3 Training with large batches4.4 Text Encoding 5. RoBERTa5.1 GLUE上的结果5.2 SQuAD上的结果5.3 RACE上的结果 6. 总结 0. 背景 机构：Facebook &amp; 华盛顿大学
作者：Yinhan Liu 、Myle Ott
发布地方：arxiv
论文地址：https://arxiv.org/abs/1907.11692
论文代码：https://github.com/pytorch/fairseq
1. 介绍 RoBERTa 模型是BERT 的改进版(A Robustly Optimized BERT，即简单粗暴称为强力优化的BERT方法)。
在模型规模、算力和数据上，与BERT相比主要有以下几点改进：
更大的模型参数量（论文提供的训练时间来看，模型使用 1024 块 V100 GPU 训练了 1 天的时间）更大bacth size。RoBERTa 在训练过程中使用了更大的bacth size。尝试过从 256 到 8000 不等的bacth size。更多的训练数据（包括：CC-NEWS 等在内的 160GB 纯文本。而最初的BERT使用16GB BookCorpus数据集和英语维基百科进行训练） 另外，RoBERTa在训练方法上有以下改进：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8276d7d33f4b484fba724d11b8061742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70a8e61cbe0f941628609f7a71a58ef7/" rel="bookmark">
			Nginx配置txt、pdf、doc、xls等文件直接下载或在线预览的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx也可用来作为附件服务器使用,毕竟nginx对静态文件支持较好,那么直接贴网址直接访问想下载，但是问题就来了,各大浏览器都针对,图片 txt,pdf,都是直接打开的,没法弹出另存为按钮。
解决思路就是,告诉浏览器这个文件需要下载而不是直接打开
1、下载方式 使用Nginx时，如果要让一些附件比如 txt,pdf,doc等不直接在浏览器打开，而是 弹出另存为的对话框（也就是下载）
则可以在nginx的加上头配置如下：
代码如下:
if ($request_filename ~* ^.*?\.(txt|pdf|doc|xls)$){ add_header Content-Disposition: 'attachment;'; } 关键,$request_filename 是nginx变量文件名称,正则表达式,是匹配已.所需文件类型,这样就在响应中告诉浏览器可以下载了
如果客户端请求的文件以txt、pdf、doc、xls为后缀的话则会让浏览器出现另存为对话框。
2,预览方式 因为项目需要下载和预览,下载时能下载了但是预览也都变成下载了,这个有点悲催,似乎两个不能同时存在.
预览的思路还是和下载一样告诉浏览器我要预览这文件不许下载.
这里用到$request_uri,这个变量是访问的url地址,获取到url地址那么我们就可以在url上添加参数来辨别我是预览文件
代码:
server { #监听的端口 listen 80; server_name localhost; location / { root html; set $flag 0; if ($request_filename ~* ^.*?.(txt|doc|pdf|rar|gz|zip|docx|exe|xlsx|ppt|pptx|jpg|png)$){ set $flag 1; } #如果带有view说明是预览 if ($request_uri ~* view$){ set $flag 2; } if ($flag = 1){ add_header Content-Disposition: attachment; } index index.html index.htm; } 这里$flag nginx自定义的一个变量,为什么要两个if来判断,这里也就不解释了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70a8e61cbe0f941628609f7a71a58ef7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b8c90464363a017d1049909ba66f2a2/" rel="bookmark">
			Unity里如何停掉Coroutine, Invoke的函数的执行，以及脚本的Start()和Update()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先列出所有可选的方法：
StopAllCoroutines(); //只对Coroutine起作用，会停掉此脚本里所有的Coroutine。
this.enable = false; // 禁掉脚本，其实只是禁掉Start(), Update()函数，脚本里其他的东东还是有效。
this.gameobject.SetActive(false); //脚本所挂靠的gameobject被禁掉了，在场景中消失不见，不可访问了。用GameObject.Find()也找不到了。
Destory(gameObject); //终极解决方案，gameObject被彻底从内存干掉了，依赖于gameObject存在的Invoke,Coroutine,其他的各种函数自然也被干掉了。
终极解决方案适用于所有。
下面列出各自的独特适用方法。
停掉Coroutine： 方法1：StopAllCoroutines();
方法2：this.gameObject.SetActive(false);
Coroutine的运行前提是：gameObject存在，且gameObject.SetActive(true)。当gameObject.SetActive(false)时，这时StartCoroutine()会直接报错，已经被StartCoroutine()调用的Coroutine会被强制停掉。
停掉Invoke(string methodname, float time): 方法1：CancelInvoke();
Invoke的运行前提是：gameObject存在，且gameObject.SetActive(true)时，Invoke()调用才有效。但对于已经被调用的Invoke(), gameObject.SetActive(false)无法影响之。
停掉Start()、Update(): 方法1：this.enable = false;
方法2：this.gameobject.SetActive(false); 脚本作为场景中某个Gameobject的Component，当脚本中有Awake(),Start(),Update()函数时，在该GameObject的Inspector栏里，脚本前会有一个勾，this.enable=false，只是禁掉Start(), Update()函数的执行而已。但对于已经开启执行的Coroutine, Invoke的函数，不会干扰其执行。
需要注意的是，使用这些方法的细节。
Destroy(gameObject); this.gameobject.SetActive(false); this.enable = false; StopAllCoroutines(); 都不是马上执行的，具体生效时间未知，不过知道是在此frame里函数执行完之后到下一个frame函数开始执行之前。
因此，可以看到：
void Start() { Debug.Log ("Enter Start()"); Destroy(gameObject); StartCoroutine(Coroutine1()); Invoke("ShowMsg", 2.0f); } IEnumerator Coroutine1() { Debug.Log("Coroutine1 Enter."); yield return new WaitForSeconds(1.0f); Debug.Log("Hello, I am Coroutine1."); } void ShowMsg() { if (bShowMsg) { Debug.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b8c90464363a017d1049909ba66f2a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cac54e4912795dd5bc9807b993a48a6/" rel="bookmark">
			精品教程，用Pandas解析json格式的数据，建议收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际工作中，尤其是网页端数据的传输，我们经常会遇到json数据，看上去和Python当中的字典类型的数据很像，本文呢小编就通过pandas当中的内置方法json_normalize()来处理json格式的数据，最终生成DataFrame数据集方便我们进行后续的操作。本文主要想通过json_normalize()这个方法解析复杂格式的json形式的数据
在开始之前，我们先导入相应的依赖库，
import pandas as pd 01
解析基本的json格式的数据
我们先来看一个简单的例子
a_dict = { '学校': '北京大学', '地理位置': '北京', '排名': 2 } 代码如下
pd.json_normalize(a_dict) 输出的结果如下
下面我们来看一个稍微有点复杂的例子，在列表中带有多个json格式的数据
json_list = [ {'学校': '清华大学', '地理位置': '北京', '排名': 1}, {'学校': '北京大学', '地理位置': '北京', '排名': 2}, ] pd.json_normalize(json_list) 输出的结果为
02
解析带有多层数据的json数据
下面我们来看一个带有多层json格式数据的对象，在“联系方式”这一层中还有“邮件”和“电话号码”，在“信息”这一层中有“学生”和“联系方式”两层，层层相套
json_obj = { '学校': '清华大学', '地理位置': '北京', '排名': 1, '信息': { '学生': '张三', '联系方式': { '邮件': { 'qq邮箱': 'zhangsan@qq.com', '163邮箱': 'zhangsan@.com' }, '电话号码': '123456789', } } } 我们尝试用json_normalize()方法来解析一下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cac54e4912795dd5bc9807b993a48a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad0c6fcee9de86b24b2751280574e8d4/" rel="bookmark">
			node-red查询oracle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境部署 在node-red中安装node-red-contrib-oracledb-mod下载安装oracle-instantclient11.2-basic (instantclient在centos下安装）编写node-red流程 [ { "id": "7f6af7842123485a", "type": "tab", "label": "流程 5", "disabled": false, "info": "" }, { "id": "4a2d5d0893025e2a", "type": "oracledb", "z": "7f6af7842123485a", "name": "", "usequery": false, "query": "", "usemappings": false, "mappings": "", "server": "5aca54d4391a7987", "resultaction": "multi", "resultlimit": 100, "x": 580, "y": 200, "wires": [ [ "f9ce8dc04e8dc97f" ] ] }, { "id": "f9ce8dc04e8dc97f", "type": "debug", "z": "7f6af7842123485a", "name": "", "active": true, "tosidebar": true, "console": false, "tostatus": false, "complete": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad0c6fcee9de86b24b2751280574e8d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/211defe5e9d89130aa75815df0d7701f/" rel="bookmark">
			【教程】ENVI主成分分析详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 主成分分析(PCA)是一种统计方法，简而言之就是用几种特性去描述事物。每个事物都可以用不同的特性去进行表达，但这些特性一般而言是存在相互的融合和冗余，而用主成分分析方法将这些特性进行转换成不相关的新特性。
在ENVI软件中共提供了三种主成分分析方式分别为：(1)Forward PCA Rotation Existing Statistics（2）Forward PCA Rotation New Statistics and Rotate（3）Inverse PCA Rotation。下面就以Forward PCA Rotation New Statistics and Rotate工具以Landsat8数据作为实验数据分别进行说明。
Forward PCA Rotation Existing Statistics工具详解 该工具主要是用于计算各数据的特征值、协方差、相关系数以及PC正向的旋转。工具具体使用如下：
（1）点开工具后，首先需要进行数据的选择，本文中使用的是预处理之后的Landsat8的数据，因此选择Landsat8数据作为输入数据。
（2）参数界面设置。
①Stats X/Y Resize Factor：主要为进行抽样参数的设置，在该栏内需要填入小于等于1的数，当设置的数值越小，则表示运算时所参与的像元数越少，运算速度就越快。
②output stats filename[.sta]：该部分主要是设置sta文件的输出名称及路径，在sta文件中包含着主成分分析计算中的统计信息，主要为协方差、相关系数、特征值以及特征向量。
③calculate using ：这里提供了两种选择分别为协方差矩阵和相关系数矩阵供选择。常规而言是使用协方差矩阵，当波段之间数据范围差异较大时，要用到相关系数矩阵。
④enter output filename ：这里为设置主成分的输出名称及路径。
⑤output date type：选择需要的输出类型（字节型，整型，无符号整型，长整型，无符号长整型，浮点型，双精度型），一般默认浮点型。
⑥Select Subset from Eigenvalues：如果设置为YES，则默认全部波段参与计算并输出，如果设置NO则可以在number of output pc bands中设置需要计算并输出的波段数。如果这里设置波段数不为全部波段，则会根据所输入的数值进行选择前几个波段进行运算。
（3）计算完成后弹出波段选择情况以及特征值和贡献率的显示框，在该对话框内可以设置所需要的波段数进行选择，默认为所有波段。
（4）计算完毕后，会显示出PC特征图，该图中显示着各主成分的信息。
（5）在所有步骤运算完毕后，我们可以通过view Statistics file工具进行打开之前所计算输出的sta 文件进行查看主成分分析所统计输出的协方差、相关系数、特征值和特征向量等相关信息。
（6）主成分荷载计算。
通过上述步骤中已经得到了相关的统计信息，之后我们可以基于这些统计信息进行计算主成分荷载以及得分。主成分的荷载可以通过下面的公式进行计算。
式中的表示特征值，e表示特征向量。
觉着有用的话，欢迎分享、点赞和关注生态与遥感应用公众号。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e692e401270be07d77fc0cbdc0c41f3a/" rel="bookmark">
			如何删除Mysql注册列表残余文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、按 Win+R 组合键，输入 regedit点击确定；
2、删除这三个文件下的Msql文件；
1&gt; HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL
2&gt; HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL
3&gt; HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL
3、删除完即可；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23dfc4a2e9c1c785c67a11d462da2a16/" rel="bookmark">
			做个计算器--实现一机一码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章我们讲解了实现注册码的原理，以及实现了注册机生成注册码。这篇文章我们将完成计算器注册代码的实现，和复制功能的实现。
零、实现注册 在实现代码前我先简单说一下注册的思路，当我们点击注册按钮时，会先拿到输入的注册码，然后程序会根据机器码生成注册码，接着用输入的注册码和生成的注册码进行对比，如果一样就跳转到计算器窗体，反之弹出提示框。代码实现如下：
private void Registered_button_Click(object sender, EventArgs e) { //1.获取注册码 string registrationCode = RegistrationCode_TextBox.Text; //2.根据机器码生成注册码 string machineCode = MachineCode_TextBox.Text; machineCode = $"miao{machineCode}shu"; string md5Str = MD5(machineCode); md5Str = MD5(md5Str); md5Str = md5Str.Replace("-", ""); //3.对比填入的注册码和生成的注册码 if (registrationCode == md5Str) { //3.1.如果注册码一样跳转到计算器窗体 this.DialogResult = DialogResult.OK; } else { //3.2.如果注册码不一样则弹出提示框 MessageBox.Show("注册码不正确！"); } } private static string MD5(string str) { MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider(); byte[] bytes = Encoding.UTF8.GetBytes(str); string md5Str = BitConverter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23dfc4a2e9c1c785c67a11d462da2a16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9f03f79e3da881ada9eebd98feb3006/" rel="bookmark">
			【正点原子Linux连载】第三十九章 系统烧写 -摘自【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）实验平台：正点原子阿尔法Linux开发板
2）平台购买地址：https://item.taobao.com/item.htm?id=603672744434
2）全套实验源码+手册+视频下载地址：http://www.openedv.com/thread-300792-1-1.html
3）对正点原子Linux感兴趣的同学可以加群讨论：935446741
4）关注正点原子公众号，获取最新资料更新
第三十九章 系统烧写
前面我们已经移植好了uboot和linux kernle，制作好了根文件系统。但是我们移植都是通过网络来测试的，在实际的产品开发中肯定不可能通过网络来运行，否则没网的时候产品岂不是就歇菜了。因此我们需要将uboot、linux kernel、.dtb(设备树)和rootfs这四个文件烧写到板子上的EMMC、NAND或QSPI Flash等其他存储设备上，这样不管有没有网络我们的产品都可以正常运行。本章我们就来学习一下如何使用NXP官方提供的MfgTool工具通过USB OTG口来烧写系统。 39.1 MfgTool工具简介
MfgTool工具是NXP提供的专门用于给I.MX系列CPU烧写系统的软件，可以在NXP官网下载到。此工具已经放到了开发板光盘中，路劲为：5、开发工具-&gt;3、NXP官方原版MFG_TOOL烧写工具-&gt;L4.1.15_2.0.0-ga_mfg-tools.tar.gz。此软件在Windows下使用，对于我们来说太友好了。将此压缩包进行解压，解压完成以后会出现一个名为L4.1.15_2.0.0-ga_mfg-tools的文件夹，进入此文件夹，此文件夹的内容如图39.1.1所示：
图39.1.1 mfg_tools工具目录
从图39.1.1可以看出，有两个.txt文件和两个.gz压缩包。.txt文档就不去看了，重点是这两个.gz压缩包，这两个压缩包的区别在名字上已经写的很详细了。“without-rootfs”和“with-rootfs”，一个是带rootfs和一个是不带rootfs。mfg_tools这个工具本意是给NXP自己的开发板设计的烧写软件，所以肯定带有自家开发板对应的uboot、linux kernel和rootfs的文件。我们肯定是要烧写文件系统的，所以选择mfgtools-with-rootfs.tar.gz这个压缩包，继续对其解压， 解压出一个名为mfgtools-with-rootfs的文件夹，此文件夹就包含有我们需要的烧写工具。
进入目录mfgtools-with-rootfs\mfgtools中，在此目录下有几个文件夹和很多的.vbs文件，如图39.1.2所示：
图39.1.2 mfgtools目录内容
我们只关心图39.1.2中Profiles这个文件夹，因为后面要烧写文件就放到这个文件夹中。MfgTool2.exe就是烧写软件，但是我们不会直接打开这个软件烧写，mfg_tools不仅能烧写I.MX6U，而且也能给 I.MX7、I.MX6Q等芯片烧写，所以在烧写之前必须要进行配置，指定烧写的是什么芯片，烧写到哪里去？下面的这些众多的.vbs文件就是配置脚本，烧写的时候通过双击这些.vbs文件来打开烧写工具。这些.vbs烧写脚本既可以根据处理器的不同，由用户选择向I.MX6D、I.MX6Q、I.MX6S、I.MX7、I.MX6UL和I.MX6ULL等的哪一款芯片烧写系统。也可以根据存储芯片的不同，选择向EMMC、NAND或QSPI Flash等的哪一种存储设备烧写，功能非常强大！！我们现在需要向I.MX6U烧写系统，因此需要参考表39.1.1所示的5个烧写脚本：
脚本文件 描述
mfgtool2-yocto-mx-evk-emmc.vbs EMMC烧写脚本。
mfgtool2-yocto-mx-evk-nand.vbs NAND烧写脚本
mfgtool2-yocto-mx-evk-qspi-nor-n25q256a.vbs QSPI Flash烧写脚本，型号为n25q256a
mfgtool2-yocto-mx-evk-sdcard-sd1.vbs 如果SD1和SD2接的SD卡，这两个文件分别向SD1和SD2上的SD卡烧写系统。
mfgtool2-yocto-mx-evk-sdcard-sd2.vbs 表39.1.1 I.MX6U使用的烧写脚本
其他的.vbs烧写脚本用不到，因此可以删除掉，防止干扰我们的视线。本书用的是正点原子的EMMC版核心板，因此只会用到mfgtool2-yocto-mx-evk-emmc.vbs这个烧写脚本，如果用其他的核心板请参考相应的烧写脚本。
39.2 MfgTool工作原理简介
MfgTool只是个工具，具体的原理不需要去深入研究，大概来了解一下其工作原理就行了，知道它的工作流程就行了。
39.2.1 烧写方式
1、连接USB线
MfgTool是通过USB OTG接口将系统烧写进EMMC中的，正点原子I.MX6U-ALPHA开发板上的USB OTG口如图39.2.1.1所示：
图39.2.2.1 USB OTG1接口
在烧写之前，需要先用USB线将图39.2.2.1中的USB_OTG1接口与电脑连接起来。
2、拨码开关拨到USB下载模式
将图39.2.2.1中的拨码开关拨到“USB”模式，如图39.2.2.2所示：
图39.2.2.2 USB下载模式
如果插了TF卡，请弹出TF卡，否则电脑不能识别USB！等识别出来以后再插上TF卡！
一切准备就绪以后，按一下开发板的复位键，此时就会进入到USB模式，如果是第一次进入USB模式的话可能会久一点，这个是免驱的，因此不需要安装驱动。第一次进入USB模式会在电脑右下角有如图39.2.2.3所示提示：
图39.2.2.3 第一次进入USB模式
一旦第一次设置好设备以后，后面每次连接都不会有任何提示了。到这里，我们的开发板已经和电脑连接好了，可以开始烧写系统了。
39.2.2 系统烧写原理
开发板连接电脑以后双击“mfgtool2-yocto-mx-evk-emmc.vbs”，打开下载对话框，如图39.2.2.1所示：
图39.2.2.1 MfgTool工具界面
如果出现“符合 HID 标准的供应商定义设备”就说明连接正常，可以进行烧写，如果出现其他的字符那么就要检查连接是否正确。点击“Start”按钮即可开始烧写，烧写什么东西呢？肯定是烧写uboot、Linux kernel、.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9f03f79e3da881ada9eebd98feb3006/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab1a6eef22366e835afdfef5b22a7fb3/" rel="bookmark">
			Hive不同存储格式占空间比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.47G大小结构化文件2642845690
分别在hive
上建表 （默认压缩算法）
在HDFS上对应目录如下图：
将这个文件load进stored as textfile 的表里
stored as textfile 在HDFS上占空间和linux上一样2642845690 约2.47G
stored as orc 从textfile表插入数据花费Time taken: 72.333 seconds
在HDFS上占空间585377591约0.55G
stored as sequencefile 从textfile表插入数据花费Time taken: 58.538 seconds
在HDFS上占空间2823942397约2.63G
stored as parquet 从textfile表插入数据花费Time taken: 89.844 seconds
在HDFS上占空间625366787约0.582G
stored as rcfile 从textfile表插入数据花费Time taken: 55.115 seconds
在HDFS上占空间2513468031约2.34G
结论 占用空间排序sequencefile 〉textfile〉rcfile 〉parquet〉orc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a99f71467fa359837dcaaff8d6cc0e3/" rel="bookmark">
			XManager5连接CentOS7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装源
# yum install epel-release -y
2.安装lightdm
# yum install lightdm -y
3.编写配置文件
# vi /etc/lightdm/lightdm.conf
[XDMCPServer]
enabled=true
port=177
4.设置默认显示为lightdm
# systemctl disable gdm ; systemctl enable lightdm
5.启动lightdm
#systemctl start lightdm
6.安装xfce桌面，
#yum groupinstall -y xfce
7.删除gnome文件
关键的一步，删除gnome文件，不然启动的时候还是gnome而不是xfce
# cd /usr/share/xsessions/
# mkdir bak
# mv gnome* bak
# systemctl restart lightdm
8.将Display Manager切换为lightdm
#systemctl disable gdm &amp;&amp; systemctl enable lightdm
9.启动lightdm
#systemctl start lightdm
10.关闭防火墙
#systemctl stop firewalld.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a99f71467fa359837dcaaff8d6cc0e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e45f61c1ab58f3757b42cf5a5286f2/" rel="bookmark">
			启动和测试oracle是否安装成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试步骤1：请执行操作系统级的命令：tnsping orcl
测试步骤 2：请执行操作系统级的命令：sqlplus system/password@orcl
安装完oracle后要启动oracle服务，后监听
1 su - oracle 2 sqlplus /nolog 3 sql&gt; conn / as sysdba 4 sql&gt; startup (一般不需要加参数，只要设置好环境变量）启动oracle服务
5 sql&gt; quit (退出sql模式) 6 lsnrctl start (启动监听器）
7 lsnrctl stop(关闭监听器，在这之前，应该先关闭应用程序） 8 sqlplus /nolog 要测试数据安装是否成功，可按顺序执行以下两个步骤：
测试步骤1：请执行操作系统级的命令：tnsping orcl
上述命令假定全局数据库名是 orcl。以下是命令执行后的示例：
C:\&gt;tnsping orcl
TNS Ping Utility for 32-bit Windows: Version 10.2.0.1.0 - Production on 10-11月-2005 10:09:58
Copyright (c) 1997, 2005, Oracle. All rights reserved.
已使用的参数文件:
C:\oracle\product\10.2.0\db_1\network\admin\sqlnet.ora
已使用 TNSNAMES适配器来解析别名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02e45f61c1ab58f3757b42cf5a5286f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41e338f555498ea0eaa1837650ccf5c/" rel="bookmark">
			Session 0x0 for sever , Closing socket connection. Attempting reconnect except it is a SessionExpire
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案：换版本号，我测试的么问题的版本号3.4.12
背景： 使用dockerfile镜像搭建Kafka集群时，里面zookeeper集群连接测试时报了上述的错误，然后网上找了很长时间，通过
https://issues.apache.org/jira/browse/ZOOKEEPER-3828
这个issue找到了解决方案。
连接测试，一直报错
(base) ➜ [/Users/admin] docker run -it --rm \ --link zoo1:zk1 \ --link zoo2:zk2 \ --link zoo3:zk3 \ --net docker-compose_default --name zk-cluster-test2 \ zookeeper zkCli.sh -server zk1:2181,zk2:2181,zk3:2181 docker-compose yml文件 version: '3.0' services: zoo1: image: zookeeper:3.4.12 container_name: zoo1 ports: - "2181:2181" volumes: - "/Users/docker/data/zookeeper/zookeeper1/data:/data" - "/Users/docker/data/zookeeper/zookeeper1/datalog:/datalog" environment: ZOO_MY_ID: 4 ZOO_SERVERS: server.4=0.0.0.0:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888 zoo2: image: zookeeper:3.4.12 container_name: zoo2 ports: - "2182:2181" volumes: - "/Users/docker/data/zookeeper/zookeeper2/data:/data" - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41e338f555498ea0eaa1837650ccf5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1c4ff8a6c9791044172c8e7ca8060f4/" rel="bookmark">
			ADC电压采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ADC电压采集 ADC简介
ADC——Analog to Digital，模拟数字转换器。STM32F407ZGT6有3个ADC，每个ADC有12位、10位、8位和6位可选，每个ADC有16个外部通道（f1只有12位）分辨率就决定了转换的时间，精度高就要位数高的。 另外还有两个内部ADC源和VBAT通道挂在ADC1上。ADC具有独立模式、双重模式和三重模式， 对于不同AD转换要求几乎都有合适的模式可选。ADC功能非常强大，具体的我们在功能框图中分析每个部分的功能。
ADC功能框图
(1)电压输入范围：
ADC输入范围为：V(REF)- ≤ V(IN) ≤ V(REF)+。由V(REF)-、V(REF)+ 、V(DDA) 、V(SSA)、这四个外部引脚决定。
ADC引脚
原理图在设计的时候一般把V(SSA)和V(REF)-接地，把V(REF)+和V(DDA) 接3.3V，得到ADC的输入电压范围为：0~3.3V。（芯片和众多外设的供电电压就是3.3V，因此模拟供电就是接3.3V）
如果想让输入的电压范围变宽，去到可以测试负电压或者更高的正电压，可以在外部加一个电压调理电路， 把需要转换的电压抬升或者降压到0~3.3V，这样ADC就可以测量了。
(2)输入通道:
确定好ADC输入电压之后，如何将电压输入到ADC？STM32的ADC多达19个通道， 其中外部的16个通道就是框图中的ADCx_IN0、ADCx_IN1…ADCx_IN5。这16个通道对应着不同的IO口， 具体是哪一个IO口可以从手册查询到。对ADC来说，PB0、PB1、PA6、PC2是完全供其使用的，其他引脚需要复用操作，而且可能使用时产生杂波；做实验时若想验证其有无杂波，可将其单独接到0和3.3V，验证ADC采集的两个端电压是否是相应的，如果是，则可以使用。其中ADC1/2/3还有内部通道： ADC1的通道ADC1_IN16连接到内部的VSS， 通道ADC1_IN17连接到了内部参考电压VREFINT 连接， 通道ADC1_IN18连接到了芯片内部的温度传感器或者备用电源VBAT。ADC2和ADC3的通道16、17全部连接到了内部的VSS。
引脚分配
外部的16个通道在转换的时候又分为规则通道和注入通道，其中规则通道最多有16路，注入通道最多有4路。具体解释如下：
规则通道
规则通道：顾名思意，规则通道就是很规矩的意思，平时一般使用的就是这个通道。
注入通道
它是一种在规则通道转换的时候强行插入要转换的一种通道。如果在规则通道转换过程中， 有注入通道插队，那么就要先转换完注入通道，等注入通道转换完成后，再回到规则通道的转换流程。这点跟中断程序很像。所以，注入通道只有在规则通道存在时才会出现。
左边的0-15可全用于规则通道，注入通道可从其中选4个GPIO
注入又分为触发注入和自动注入，区别如下：
触发注入
要使用触发注入，必须将 ADC_CR1 寄存器中的 JAUTO 位清零。
1.通过外部触发或将 ADC_CR2 寄存器中的 SWSTART 位置 1 来启动规则通道组转换。
2.如果在规则通道组转换期间出现外部注入触发或者 JSWSTART 位置 1，则当前的转换会复位，并且注入通道序列会切换为单次扫描模式。
3.然后，规则通道组的规则转换会从上次中断的规则转换处恢复。
如果在注入转换期间出现规则事件，注入转换不会中断，但在注入序列结束时会执行规则序列。
注意： 使用触发注入时，必须确保触发事件之间的间隔长于注入序列。例如，如果序列长度为 30 个ADC 时钟周期（即，采样时间为 3 个时钟周期的两次转换），则触发事件的最小间隔不能小于 31 个ADC 时钟周期
自动注入
如果将 JAUTO 位置 1，则注入组中的通道会在规则组通道之后自动转换。这可用于转换最多由 20 个转换构成的序列，这些转换在 ADC_SQRx 和 ADC_JSQR 寄存器中编程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1c4ff8a6c9791044172c8e7ca8060f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c6fca1c5e565fa587af7902cbfe197d/" rel="bookmark">
			新手搭建个网站如何入手？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新手建站，可以选择模板建站(自助)建站，或者自己买域名和云服务器搭建个人网站，对于新手来说，最重要的是缺乏经验，下面我简单梳理了下搭建网站的一些过程，分享了几篇干货文章，希望对你有用。
1. 如何快速搭建网站环境 下面是模板建站有点像写PPT，平台提供很多行业建站模板，也不用买云服务器什么的，最便宜的需要500元，主要适合没有建站基础的人群。
目前常见的建站环境，从程度上细分，有可视化面板和命令行面板两大类。目前命令行面板由于操作复杂完全已不适用新手入门，所以这里只说主流的国产可视化面板。
可视化面板包括：宝塔面板、AMH、WDCP。当然国内目前最受欢迎的，就是宝塔面板了。
只需点几下鼠标就可快速建站。对于老手也很好用，不管建站、安全防御、维护等都是鼠标点几下的事情。宝塔面板具有可视化、符合国人的操作习惯优异特点，即使没有建站经验的小白也能快速上手。
2. 传统建站过程描述 自己买服务器的建网站流程
2.1 购买域名和云服务器
域名建议用.com后缀的（一般五十左右）就可以了，想要更加便宜的域名可以买.top等后缀的（一般几块钱）。
云服务器的话，按需购买即可，买大了或者买下了都不合适，如果只是简单的发发文章图片，视频等，网站访问量不高的话，1核2G1M的配置够用了。当然，如果对响应速度等体验比较看重的话，可以买个稍微高点配置的，比如2核4G的这样的。
下面是一张云服务器需求与配置对照表，按需购买。
2.2 将域名解析到云服务器
文章推荐
阿里云服务器实现域名解析步骤(小白教程)_Linux_脚本之家​
腾讯云服务器域名解析操作详解
2.3 在云服务器上配置环境和部署网站程序
自己搭建网内站并不难，新手建议采用宝塔面板一键部署自己网站，这样操作简单。这里推荐看看这三篇教程。
基于阿里云ECS服务器搭建云上博客WordPress教程（详细图文版）
如何用阿里云服务器建立个人网站（宝塔面板+wordpress）​
腾讯云服务器搭建wordpress网站新手教程​
2.4 网站备案：
网站部署使用中国大陆的云服务器，备案往往是必不可少的一环，如果购买了腾讯云或者阿里云服务器，可以参考它们官网的备案流程进行备案，详细的备案流程如下：
网站备案-如何快速备案你的网站—腾讯云备案流程
阿里云备案_个人域名备案申请_企业网站备案流程_服务-阿里云
聊完这些，那么该选择哪家的云服务器呢？
主流云平台例如阿里云、腾讯云的活动机在安全性、稳定性、易用性及高性价比等方面都占据绝对的优势，是上云的最佳选择。
国内云服务器性能和配置对比参阅：【云服务器推荐】腾讯云、阿里云、华为云服务器价格和配置评测
参考来源：知乎
作者：云网计算
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3d03bba9f94777f13a1d32484f1cad2/" rel="bookmark">
			测试从零开始-No.6-测试用例设计方法（等价类&#43;边界值）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的用例设计方法 等价类划分法（适用于输入项少，输入项的属性或者特性相同） 边界值分析法（适用于有范围约束的情况）
判定表法（适用于有明显的条件及其对应的动作的情况）
因果图法
状态迁移图法（适用于状态随事件而改变的情况）
场景分析法（适合于由事件触发而形成的使用场景，同一事件不同的触发逻辑形成不同的场景，从而形成不同的业务流程（路径），根据覆盖不同的路径来设计测试用例）
正交实验法（适用于多条件或多输入情况）
异常分析法（适用于大多数软件，从经验上判断容易出现错误或缺陷的地方设计用例）
错误猜测法
等价类划分法 是把所有可能的输入数据,即程序的输入域划分成若干部分子集,然后从每一个子集中选取少数具有代表性的数据作为测试用例。该方法是一种重要的,常用的黑盒测试用例设计方法。
有效等价类：有效等价类是程序规格说明有意义，合法的输入数据
无效等价类：无效等价类是程序规格说明无意义，不合法的输入数据。
等价类法设计测试用例的步骤: 1、为每个输入划分等价类，得到等价类表，为每个等价类规定一个唯一编号
2、设计一个测试用例，使其尽可能多的覆盖所有尚未覆盖的有效等价类。重 复这一步骤，使得有效等价类均被测试用例所覆盖
3、设计一个测试用例，使其只覆盖一个无效等价类。重复这一步骤使得所有无效等价类均被覆盖
等价类划分的原则 1、在输入条件规定了取值范围或值的个数的情况下,则可以确立一个有效等价类和两个无效等价类. 2、在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下,可确立一个有效等价类和一个无效等价类. 3、在输入条件是一个布尔量的情况下,可确定一个有效等价类和一个无效等价类. 4、在规定了输入数据的一组值假定n个,并且程序要对每一个输入值分别处理的情况下,可确立n个有效等价类和一个无效等价类. 5、在规定了输入数据必须遵守的规则的情况下,可确立一个有效等价类符合规则和若干个无效等价类从不同角度违反规则. 6、在确知已划分的等价类中各元素在程序处理中的方式不同的情况下,则应再将该等价类进一步的划分为更小的等价类. 等价类表可以参考下图所示：
等价类划分法用例设计实战： 根据下面给出的规格说明，进行测试用例的设计。
一个程序读入3个整数，把这三个数值看作一个三角形的3条边的长度值。程序输出：说明这个三角形是普通的、是等腰的、还是等边的。
等价类划分如下：
3条边分别为A，B，C。满足：A&gt;0，B&gt;0，C&gt;0，且A+B&gt;C，B+C&gt;A，A+C&gt;B；
等腰需满足A=B，或B=C，或A=C ；
等边需满足A=B，且B=C，且A=C ；
最终输出的场景如下：
边界值分析法 边值分析方法的理论基础，是假定大多数的错误是发生在各种输入条件的边界上，如果在边界附近的取值不会导致程序出错，那么其它的取值导致程序错误的可能性也很小。
边界值分析使用条件 输入条件明确了一个值的取值范围，或是规定了值的个数
边值点的定义 上点：边界上的点，不区分开闭区间。
离点：就是离上点最近的一个点，如果域的边界是封闭的，离点就在域范围外，如果域的边界是开放的，离点就在域范围内
内点：顾名思义，就是在域范围内的任意一个点 可通过下面这张图更形象的理解：
再举个案例：
正整数值域[66,88]：
上点就是66，88，并且都是在域内。内点就是域内得任意点，离点是65，89。
正整数值域(66,88]
这种情况上点是66，88，其中一个是域内，一个是域外，内点就是域内的任意点，离点是：67，89。
正整数值域(66,88)
这样的情况上点还是66，88，只是都是在域外，内点还是域内的任意点，离点此时为：67，87。
边界值分析的原则 1、如果输入（输出）条件规定了取值范围，或是规定了值的个数，则应该以该范围的边界内及边界附近的值作为测试用例
2、如果输入（输出）条件规定了值的个数的取值范围，则用最大个数，最小个数，比最小个数少一，比最大个数多一的数作为测试数据
3、如果程序规格说明中提到的输入或输出是一个有序的集合，应该注意选取有序集合的第一个和最后一个元素作为测试用例
4、如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试用例
边界值分析方法是对等价类划分方法的补充。长期的测试工作经验告诉我们,大量的错误是发生在输入或输出范围的边界上,而不是发生在输入输出范围的内部。因此针对各种边界情况设计测试用例,可以查出更多的错误。使用边界值分析方法设计测试用例,首先应确定边界情况.通常输入和输出等价类的边界,就是应着重测试的边界情况.应当选取正好等于,刚刚大于或刚刚小于边界的值作为测试数据,而不是选取等价类中的典型值或任意值作为测试数据。
小伙伴看到这，是不是觉得这样写用例写起来很麻烦呢？每次还要画很多的图表之类的，画图表只是一个分析的过程，等熟练之后，在实际工作中，可以根据自己的实际情况忽略某些步骤，只要在最终的测试点中能将这些测试点都考虑进去就行。详细的编写过程只是在初级测试找工作的时候，可能会在笔试题中考到，对相关的概念有个简单的了解就行。
关注公众号【小博测试成长之路】，下期带你了解其他的用例设计方法，后续会以项目实战的方式带大家熟悉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7b4b3d8ffd314d1756a911d5950a8e1/" rel="bookmark">
			openbmc开发22：添加sensor信息到ipmi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面说过如何添加sensor传感器信息(I2C、ADC、FAN），这些信息添加后是可以展示到web页面，而不能通过ipmitool工具展示出来，那么怎么才能把这些传感器信息添加到ipmi中呢？别着急，下面将一一道来。
1 ipmi配置文件转换成cpp 在软件包下有一个scripts文件夹，这里边是python脚本、模板、示例yaml文件以及使用说明，本内容介绍sensor的yaml文件。在configure阶段，通过autoconf工具，解析configure.ac以及Makefile.am生成Makefile文件，在编译阶段执行sensor_gen.py的python脚本，利用writesensor.mako.cpp模板，并根据sensor.yaml文件生成sensor-gen.cpp文件。
2 配置ipmi配置文件 指定自己sensor的yaml文件，有两种方法：
方法一：
通过安装覆盖的方式。参考meta-ibm/meta-romulus。
1 、在your-layer下创建recipes-phosphor/configuration文件夹，创建xxx-yaml-config文件夹和xxx-yaml-config.bb文件，xxx-yaml-config文件夹中存放yaml文件，xxx-yaml-config.bb文件中SRC_URI指定该yaml文件。xxx-yaml-config.bb文件内容如下：
SUMMARY = "YAML configuration for xxx" PR = "r1" LICENSE = "Apache-2.0" LIC_FILES_CHKSUM = "file://${COREBASE}/meta/files/common-licenses/Apache-2.0;md5=89aea4e17d99a7cacdbeed46a0096b10" inherit allarch SRC_URI = " file://xxx-ipmi-sensors.yaml " S = "${WORKDIR}" do_install() { install -m 0644 -D xxx-ipmi-sensors.yaml \ ${D}${datadir}/${BPN}/ipmi-sensors.yaml } FILES_${PN}-dev = " ${datadir}/${BPN}/ipmi-sensors.yaml " 2、在your-layer/recipes-phosphor/ipmi/phosphor-ipmi-host_%.bbappend文件中添加如下内容：
DEPENDS_append = " xxx-yaml-config" EXTRA_OECONF = " SENSOR_YAML_GEN=${STAGING_DIR_HOST}${datadir}/xxx-yaml-config/ipmi-sensors.yaml " 方法二：
在your-layer/conf/machine/machine.conf中指定配置文件。可参考meta-quanta/meta-q71l
1、machine.conf添加内容如下
PREFERRED_PROVIDER_virtual/phosphor-ipmi-sensor-inventory = "xxx-ipmi-sensor-map-native" 2、在your-layer/recipes-phosphor/ipmi/下创建xxx-ipmi-sensor-map-native文件夹和xxx-ipmi-sensor-map-native.bb文件，xxx-ipmi-sensor-map-native文件夹下放yaml文件，xxx-ipmi-sensor-map-native.bb文件内容如下
SUMMARY = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7b4b3d8ffd314d1756a911d5950a8e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9087a59647730734070dc41956fcdb0d/" rel="bookmark">
			解决idea新建Maven项目后无法新建package和Java Class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家在新建Maven项目后无法新建package和Java Class，就像下图一样，这类问题该怎么解决呢？我总结到的有两种解决方法
方法一：点击右键，打开Mark Directory as，点击Sources Root即可
方法二：点击右键，打开Open Module Settings，然后找到Modules下Sources，选择你要新建package和Java Class的目录，点击OK即可
结果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/903f9e77ab951d0c50179292b1fe4d70/" rel="bookmark">
			chales偶现异常导致关闭后xcode无法编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无缘无故报网络错误，xcode无法编译，
猛然间发现打开Chales可以编译，关闭则会失败
Showing Recent Messages ValueError: ('======= Exception:------------------&gt;', ProxyError(MaxRetryError("HTTPSConnectionPool(host='volantis-api.pdd.net', port=443) : Max retries exceeded with url: /component/components/script/prod/apps/all (Caused by ProxyError('Cannot connect to proxy.', NewConnectionError('&lt;urllib3.connection.HTTPSConnection object at 0x10d3f4110&gt; : Failed to establish a new connection: [Errno 61] Connection refused',)))",),)) 原因：
使用Charles时，会自动打开网络代理。正常退出后，也会替我们关闭代理，但是偶尔出现异常就没帮我们关闭。
解决办法：
手动关闭网络代理即可。
Mac 系统偏好设置 -&gt; 网络 -&gt; 高级 -&gt; 代理 将所有打钩的代理都取消掉，保存设置，OK
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e5b571ebcff5e799f8691294e176b31/" rel="bookmark">
			Block 中使用成员变量引发crash分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Block 中使用成员变量引发crash 有如下一段代码块，在执行这段代码时有时候会触发crash
void(^test)() = ^() { __strong typeof (weakSelf)strongSelf = weakSelf; strongSelf -&gt; _xx = xxx; //引发crash strongSelf.yy = yyy; // 不会引发crash [strongSelf doSomething]; [strongSelf doMoreThing]; } __weak typeof (self)weakSelf = self; [self test]; 现状：
在self因某些情况被释放掉，变成nil，然后执行blcok体。
结论：
使用使用nil.yyy不会引发crash，使用nil -&gt; _xxx 会引发crash。
解决方案：
在block中__strong后判断strongSelf是否为nil，为空的话直接return
原因：
在block中使用self -&gt; _xxx，如果在执行到block时，self被释放了，在block中就算是使用了__strong typeof () ，这个时候self是nil，并没有强持有self，使用nil -&gt; _xxx 便会引发crash。
详细解释及分析：
在block外使用weak是为了弱引用self，self强引用block，如果在block中在强引用self，会导致死循环。故在声明时使用weak，在block体正式被执行的时候，使用strong，这里主要是为了防止block在执行的过程中，如果self是被弱引用，可能会由于外界失去引用而被释放，导致block中的代码错误执行。
在block执行的时候，执行到strong，如果 WeakSelf 还没有变成 nil，那么就会 retain self，让 self 在 block 执行期间不会变为 nil。这样上面的 doSomething 和 doMoreThing 要么全执行成功，要么全失败，不会出现一个成功一个失败，即执行到中间 self 变成 nil 的情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e5b571ebcff5e799f8691294e176b31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e176f9a450a92dae82a1a3dce7c0c8f5/" rel="bookmark">
			Unity 之 关于停止协程的五种方式解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：了解协程
协程的不同用法：
协程的误用：
方式一：函数的方式
方式二：函数名的方式
方式三：接收返回值
方式四：StopAllCoroutines
方式五：禁用/销毁游戏对象
本文小结：
前言：了解协程 官方描述 调用函数时，函数将运行到完成状态，然后返回。这实际上意味着在函数中发生的任何动作都必须在单帧更新内发生；函数调用不能用于包含程序性动画或随时间推移的一系列事件。
协程是一个可暂停执行 (yield) 直到给定的 YieldInstruction 达到完成状态的函数。
协程的不同用法： yield null：在下一帧上调用所有 Update 函数后，协程将继续。yield WaitForSeconds： 在为帧调用所有 Update 函数后，在指定的时间延迟后继续协程yield WaitForFixedUpdate： 在所有脚本上调用所有 FixedUpdate 后继续协程yield WWW：在 WWW 下载完成后继续。yield StartCoroutine：将协程链接起来，并会等待 MyFunc 协程先完成。 协程的误用： 如果一个协程几乎每帧都运行并且在长时间运行操作中不会暂停，那么用 Update 或 LateUpdate 回调来替换该协程通常更合理一些。例如长时间运行或无限循环的协程。尽可能的减少嵌套使用：虽然嵌套的协程非常有利于确保代码的条理性和进行维护，但协程跟踪对象本身会导致产生更高的内存开销。 方式一：函数的方式 使用传递函数的方式来 开启协程:
StartCoroutine(Cor_1()); 停止协程：(❎ 错误的使用方式1)
StopCoroutine(Cor_1()); 虽然传递的是一样的函数名，但是停止时传递进去的并不是开始时传递的函数的地址。
停止协程：(❎ 错误的使用方式2)
StopCoroutine("Cor_1"); 新手的错误用法：使用传递函数的方式开启协程，使用传递字符串的形式停止协程。
那么使用StartCoroutine(Cor_1());这种方式开启协程，要如何才能手动停掉它呢？请继续往下看…
方式二：函数名的方式 使用传递函数名的方式 开启协程：
StartCoroutine("Cor_1"); 停止协程：
StopCoroutine("Cor_1"); 这样使用是没问题的（我猜测是内部是实现是通过&lt;Key, Value&gt;的形式保存了一下）。
缺点：只支持传递一个参数。
由一,二得出结论，只有通过函数名的形式开启和关闭是可行的，但是这并没有解决我们方式一中留下的问题，请继续往下看吧…
方式三：接收返回值 不管使用下面哪种方式启动协程，都可以结束其返回值用以停止对应协程；
private Coroutine stopCor_1; private Coroutine stopCor_2; stopCor_1 = StartCoroutine("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e176f9a450a92dae82a1a3dce7c0c8f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/917ede7b1dcce3036072b6b79b637485/" rel="bookmark">
			Lantronix xPico240
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 介绍 Lantronix®xPico®200系列嵌入式物联网网关是最小和高度之一集成工业Wi-Fi，以太网和蓝牙解决方案。xPico 200系列提供始终在线的双频企业Wi-Fi®、双模式蓝牙®(Bluetooth Classic v2.1+EDR和Bluetooth Low Energy v4.2)以及以太网连接对于业务关键资产。它是一个独立的模块，不需要外部主机处理器无线和网络堆栈。与客户验证的TruPort技术，包括生产准备基本的物联网连接固件、基于云的管理和集成设备安全框架，xPico 200系列提供完整的网络和物联网连接卸载任何微控制器的解决方案。
xPico 240系列亮点 双频Wi-Fi (802.11 a/b/g/n)和以太网自动网络连接管理并发软AP +客户端模式，直接无线服务接入而不中断机器现场操作使操作作为网络协处理器或无线MCU全球认证(FCC, IC, ETSI，日本，AU/NZS，中国)工业级设计，适用于极端环境(-40℃至+85℃)通过ConsoleFlow™进行远程更新和设备管理 应用 对于需要以太网和无线连接选项的应用程序，xPico 200提供了一个紧凑的组合解决方案，不需要集成两个不同的网络堆栈不同的模块或控制器。集成的蓝牙功能(在xPico 250模型上)也支持创建网关模块
需要聚合蓝牙传感器设备或提供BLE定位服务的连接产品。
主要应用包括:
♦医疗设备
♦工业机器
♦零售/ POS
♦重量表
♦资产和仓库管理
♦环境监测
♦运输和远程信息技术
xPico 200框图 2 使用网页配置 参考 1、Lantronix xpico-240
2、xPico-WiFi配置手册
3、xPico240 CLI 配置方法
4、Lantronix xPico240说明书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbf155f55fad81e5c0453e4dedcad3d5/" rel="bookmark">
			SSM配置文件总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先对Spring SpringMVC和Mybatis单独进行配置，最后对三者进行整合配置
文章目录 SpringspringMVCMybatisSSM整合 Spring 实际使用中，一般会使用注解+xml配置来实现spring功能，其中xml配置对上文进行总结，配置内容如下
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!--在使用spring 相关jar包的时候进行配置 每个jar包对应一个xmlns和schemaLocation路径--&gt; &lt;!--格式基本相关 只要修改相关的关键字--&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx = "http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 开启注解扫描 ，才可以使用注解 可以使用use-default-filter配合include-filer和exclude-filter使用 --&gt; &lt;context:component-scan base-package="com.jdbcTemplate" &gt;&lt;/context:component-scan&gt; &lt;!-- 开启aop--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;!-- JdbcTemplate使用--&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" destroy-method="close"&gt; &lt;property name="url" value="jdbc:mysql:/book"/&gt; &lt;property name="username" value = "root"/&gt; &lt;property name="password" value = "LRY990722"/&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;/bean&gt; &lt;bean id="'jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbf155f55fad81e5c0453e4dedcad3d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8611f55046603ee912c97c8556f203e/" rel="bookmark">
			Vue Treeselect使用常见问题汇总及解决办法（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue Treeselect组件使用问题汇总及解决办法（持续更新！！！） 文章中使用的数据样例（数据字段和值，仅便于突出展示效果，并非实际使用需要）如下：
const mockData = [ "id": 1, "name": "手机", "subOptions": [ { "value": 21, "name": "5G手机", "subOptions": [] } ], ] 1.自定义展示字段： &lt;tempalte&gt; &lt;treeselect :options="options" :normalizer="normalizer" /&gt; &lt;/tempalte&gt; &lt;script&gt; export default { data (){ return { options: mockData, normalizer() { // 自定义数据字段 id: node.key, // 自定义选中值 label: node.name,	// 自定义标签显示 children: node.subOptions,	// 自定义下级chidlren字段 } } } } &lt;/script&gt; 2.chidlren为空（包含[]和null）时，不展示下拉角标和No options available.提示： 1. API调整：chidlren没有值时，将children字段移除;
2. 前段自行处理，代码如下：
&lt;tempalte&gt; &lt;treeselect :normalizer="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8611f55046603ee912c97c8556f203e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ca15fb753bed8cfad11d21d3b3db793/" rel="bookmark">
			解构领域驱动设计--思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7d6970f9db373b9907f30840eb93b47/" rel="bookmark">
			CSS实现点击改变元素背景色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可通过使用css伪类实现点击元素变色的效果，两个伪类是:active, :focus :active :active选择器用于选择活动链接。当在一个链接上点击时，它就会成为活动的（激活的），:active选择器适用于所有元素，不仅限于链接a元素 :focus :focus 选择器用于选取获得焦点的元素。仅接收键盘事件或其他用户输入的元素允许 :focus 选择器。 由于上面的特性，如果想实现点击时变色效果，有以下两种方法，两者区别在
:active，元素被点击时变色，但颜色在点击后消失
:focus， 元素被点击后变色，且颜色在点击后不消失
button:active{ background:olive; } button:focus{ background:olive; } 由于div等元素无法接受键盘或其他用户事件，即不支持:focus伪类，可通过增加tabIndex属性使其支持:focus。
&lt;div tabindex="1"&gt; Section 1 &lt;/div&gt; &lt;div tabindex="2"&gt; Section 2 &lt;/div&gt; &lt;div tabindex="3"&gt; Section 3 &lt;/div&gt; div:focus { background-color:red;&lt;br&gt;　outline: none; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3c898447eb2412c49629bc3577be6a6/" rel="bookmark">
			nginx--中文域名解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： 各大域名供应商目前已出现中文域名，记录中文域名在Linux环境下的配置。
解决方案： 在站长之家的进行中文域名转码 在nginx.conf中进行域名配置 server { listen 80; server_name xn--0zwm56d.xn--fiqs8s; ... } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adf3de7d162bc2a8787cfd678d1e46df/" rel="bookmark">
			有哪些网站提供较好的网页模板？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		市面上用户群体目前最流行的两块网页模板网站可以说是WordPress与CMS织梦。
那么问题来了，这两款网页模板哪个比较好？更好用？
要想知道这一个答案，其实并不在于哪一个系统好用，因为要想用好任何一个CMS都必须要付出学习的成本，如果你织梦用得很好，我觉得使用织梦已经满足于目前的项目需求，就不需要额外浪费时间去学习WordPress.
如果你觉得在使用织梦CMS时，早就已经进入到如火纯青的阶段，那么此时就应该深入通过源码来了解项目的设计理念，从而让自己具备更强的能力，可以打造一套类似的CMS，而并不是切换一条平行的赛道而去选择学习wordpress.
当然这里所说的这种深入方法，很多人可能依然会选择保守的路线，即便是使用一个CMS直到无法使用为止，当你在接到新的项目时，肯定是在最为熟悉的框架下开发。
因为也没有看到哪个人能够真正把这两款建站系统都用的很好，能够从开发者的角度把这两者的优缺点对比出来，因为这根本就不符合一个正常人的思维。
所以要说这两个系统到底是哪个好，自然是各有各的说法，不能够以偏概全，没有一个人可以把这两者都运用的出神入化，以高高在上的姿态来回答这种问题，当然也包括一些资深的人士。
不过此时也出现一个客观的问题，目前的织梦CMS已经停止维护，停止维护到底代表什么意思呢？织梦和wp如果没有选择更新，那么最短一个月，最长可能1~2年必然会被黑掉，毕竟会有很多的人都在背后研究漏洞。好在wp一直都在更新，如果能够时刻保持更新，就意味着还是拥有安全性的，相反如果几个月不更新就会变成不安全的CMS。
所以现在根本就没有必要对比这两种系统，如果你两个全部都没有使用过，自然应该选择wordpress。几年前可能不好说，可是在进入到2021年时，估计也只有傻子会选择织梦CMS吧。目前周围站长使用最多就是wp，但是今天也希望能够从开发者的角度去了解一下织梦CMS到底有哪一些优缺点？
安全性
如果说wordpress插件不安全，那么在目前的市场上，wp的插件数以计万，到底不安全在什么地方呢？是因为旧版本使用的不安全还是新版本不安全，估计没有人能够说出正确的答案，所以建议你不要胡乱的使用插件。
还有一点不少人都曾经有过相同的经验，就是网站被黑，大部分在使用开源CMS时，站长多少都会遇到这类的情况，织梦CMS不更新，网站没有过多久可能就会被黑掉。
速度
也有人说wordpress并不适合做大网站，这其实只是一部分人的想法，wp大网站数不胜数，有一部分人缺乏技能说的话并不代表所有人这样看。
其它方面
其他方面，比如模板插件的多少，其实两者并没有什么可比性，插件再多也没有时间去试用，你需要比较的本身就是各种类型的网站，是否拥有成熟的CMS以及插件能够实现，比如社交或者是电商，wp是有的，但是织梦有没有就不知道，所以暂时也不展开讨论。
如果你打算做某一个类型的网站，应该先确定这种类型，然后再做出提问，比如：“想要做一个电商网站，首先关心需要实现哪些功能？然后考虑是选织梦，还是wordpress？各自都有哪些坑？”。总之从我的经验来看：越是精准的问题更越容易得到精准的回答，否则在后期使用的过程中，会让你苦不堪言。
现在还有一个重点，在今年年初时出现了一个织梦V6，不过后来官方又否认说这完全是侵权的做法，因为织梦CMS早就已经长时间没有更新，如果2021年依然还在选择织梦，说明这就是一种非常热爱的表现，因为正常的情况下大部分的人都会选择wordpress。
现在的织梦CMS早就已经不再更新维护，拥有着数不胜数的漏洞，但是wordpress还是拥有着比较好的性能，用户群体比较大，80%左右的博客类网站全部都会用这一项系统，当然其他的一些功能它也是可以实现的，所以答案已经非常的明显。
另外国内主流云商家其实也有很多，比如腾讯云或者是阿里云，全部都会为大家提供一些轻量级的应用服务器，里面也会加上wordpress系统镜像，可以说购置云服务器就已经给大家安装好，是非常适合于初学者的。
聊完这些，那么该选择哪家的云服务器呢？
主流云平台例如阿里云、腾讯云的活动机在安全性、稳定性、易用性及高性价比等方面都占据绝对的优势，是上云的最佳选择。
国内云服务器性能和配置对比参阅：【云服务器推荐】腾讯云、阿里云、华为云服务器价格和配置评测
参考来源：知乎
作者：云网计算
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28b512f89291477e2f611d30fe2d5173/" rel="bookmark">
			下载最新的阿里云centos镜像和yum源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、登录阿里云的镜像网站 https://opsx.alibaba.com/mirror 可以下载。
2、选择最新版本号
3、选择isos
4、x86_64
5、选择自己需要的版本
Linux中的官方源、镜像源汇总。：
http://url.cn/5LHrSSJ
第一步、下载yum源
CentOS系统更换软件安装源
第一步：备份你的原镜像文件，以免出错后可以恢复。
cd /etc/yum.repos.d/ #切换到/etc/yum.repos.d/
备份系统原来的repo文件
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
第二步：用wget下载repo文件，下载新的CentOS-Base.repo 到/etc/yum.repos.d/ CentOS 7
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
添加epel源wget -P /etc/yum.repos.d/ http://mirrors.aliyun.com/repo/epel-7.repo
清理缓存并生成新的缓存
第三步：执行yum源更新命令 ，运行yum makecache生成缓存，更新cache。
注意：此过程时间可能较长，请耐心等待！！！
yum clean all yum makecache yum -y update 阿里云CentOS 镜像配置 简介
CentOS，是基于 Red Hat Linux 提供的可自由使用源代码的企业级 Linux 发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台。
配置方法
备份
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/
CentOS 6
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28b512f89291477e2f611d30fe2d5173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdaad87cf8c50e85bf88fd7e8be562a7/" rel="bookmark">
			Mybatis的一级、二级缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Sessionflush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。
2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置 ；
3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D操作后，默认该作用域下所有 select 中的缓存将被 clear 掉并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/850b0a1b201ddc73a13e0035bc965036/" rel="bookmark">
			最简单的MP分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//pageSize 页码
//pageNum 数量
PageHelper.startPage(pageSize,pageNum);
或
PageMethod.startPage(pageSize,PageNum);
List&lt;Object&gt; list = this.baseMapper.selectList();
//自动分页
PageInfo&lt;List&gt; pageInfo = new PageInfo&lt;List&gt; (list);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7213d52d615da4dc4a3274eed5fe89e0/" rel="bookmark">
			windchil 部分常用API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设置对象状态：
ReferenceFactory rf = new ReferenceFactory(); WTDocument doc = (WTDocument) rf.getReference("OR:" + WTDocument.class.getName() + ":" + "1706046").getObject(); LifeCycleHelper.service.setLifeCycleState((LifeCycleManaged) doc , State.toState("INWORK"));// 设置状态 升级请求添加及移除受影响对象：
WTHashSet oldSets = new WTHashSet();// 用来保存旧版本对象 oldSets.add(doc); StandardMaturityService maturityService = new StandardMaturityService(); PromotionNotice pro = (PromotionNotice) rf .getReference("OR:" + PromotionNotice.class.getName() + ":" + "1985285").getObject(); pro = maturityService.deletePromotionTargets(pro, oldSets);// 删除升级流程中旧版本对象 WTHashSet newSets = new WTHashSet();// 用来保存新版本对象 newSets.add(doc); maturityService.savePromotionTargets(pro, newSets); 添加新版本对象到升级流程中 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71eef146dd3cdb8f35c9c4dc3a04a84a/" rel="bookmark">
			Java Web面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java Web面试题 1、Session 和Cookie 的区别 1、Cookie存储在浏览器或者本地，session存在服务器
2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。
3、Session占用服务器性能，Session过多，增加服务器压力
4、单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie
2、 forward和redirect的区别 Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。转发（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。重定向（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。举个通俗的例子：
forward就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；
间接转发就相当于：“A找B借钱，B说没有，让A去找C借”。
3、REST接口与HTTP幂等性 URL定位资源，用HTTP动词（GET,POST,DELETE,PUT）描述操作 比如，我们有一个friends接口，对于“朋友”我们有增删改查四种操作，怎么定义REST接口？增加一个朋友，uri: generalcode.cn/v1/friends 接口类型：POST 删除一个朋友，uri:generalcode.cn/v1/friends 接口类型：DELETE 修改一个朋友，uri: generalcode.cn/v1/friends 接口类型：PUT 查找朋友，uri: generalcode.cn/v1/friends 接口类型：GET HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。
4、如何防止form表单重复提交 表单什么时候会出现重复提交
参考：https://www.cnblogs.com/yangheIT/p/11546920.html
5、简述CSRF,跨域解决方案CORS 参考：https://blog.51cto.com/tdcqvip/2096090
参考：https://www.jianshu.com/p/f5a88983f42d
6、简述 Web容器 Listener,Filter,Servlet执行顺序和生命周期 执行顺序 启动的顺序：Listener-&gt;Filter-&gt;Servlet 简单记为：理(Listener)发(Filter)师(Servlet) 执行的顺序不会因为三个标签在配置文件中的先后顺序而改变。同类别的定义顺序影响优先级，越靠前，优先级越高。如果web.xml中配置了，初始化顺序：context-param &gt; Listener &gt; Filter &gt; Servlet
生命周期 Listener生命周期：一直从程序启动到程序停止运行。ServletRequestListener：每次访问一个Request资源前，都会执行requestInitialized()方法，方法访问完毕，都会执行requestDestroyed()方法。
HttpSessionListener：每次调用request.getSession()，都会执行sessionCreated()方法，执行session.invalidate()方法，都会执行sessionDestroyed()方法。
ServletRequestAttributeListener：每次调用request.setAttribute()都会执行attributeAdded()方法，如果set的key在request里面存在，就会执行attributeReplacerd()方法，调用request.removeAttribute()方法，都会执行attributeRemoved()方法。
Filter生命周期：程序启动调用Filter的init()方法(一旦触发，但是永远只调用一次)，程序停止调用Filter的destroy()方法(永远只调用一次，服务器移除或者彻底关闭，并且在Servlet destory() 之后)，doFilter()方法每次的访问请求如果符合拦截条件都会调用(程序第一次进入一个新的Servlet，会运行在Servlet调用init()方法后执行)，但是不管第几次，都在调用doGet()，doPost()方法之前。
Servlet生命周期：程序第一次访问（而不是启动Tomcat时调用init()），会调用servlet的init()方法初始化（只执行一次），每次程序执行都会根据请求调用doGet()或者doPost()方法，程序停止调用destory()方法（服务器移除或者彻底关闭）。
7、JSP9大隐视对象中四个作用域的大小与作用范围 输入/输出对象：request response out 作用域通信对象：session application pageContext Servlet 对象： page config 错误对象： exception
8、web.xml的作用 web.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71eef146dd3cdb8f35c9c4dc3a04a84a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa504d109f53bb1fe262bbe2fb28bd44/" rel="bookmark">
			【数据结构笔记】数据结构基础—链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.线性表的链式存储结构 特点：下一节点data的起始地址存在了上一节点的next中，所以链表末尾的指针一定会指向NULL
将线性表中各元素分布在存储器的不同存储块，成为节点，通过地址或指针建立元素之间的联系。
节点的data域存放数据元素，而next域是一个指针，指向直接后继所在的节点。
节点类型描述：
typedef struct node{ data_t data; //结点的数据域// struct node *next; //结点的后继指针域// }listnode, *linklist; 设p指向链表中节点，
获取 ：p-&gt;data
获取：p-&gt;next-&gt;data
若指针p的值为NULL，则它不指向任何节点，此时取p-&gt;data或p-&gt;next-&gt;data是错误的，会报段错误。
向系统申请节点的存储空间：
linklist p; p = (linklist)malloc(sizeof(listnode)); 2.单链表的基本操作 创建 ①申请内存 ②赋值 ③返回头部指针
linklist list_create() { linklist H; H = (linklist)malloc(sizeof(listnode)); if (H == NULL) { printf("malloc failed\n"); return H; } H-&gt;data = 0; H-&gt;next = NULL; return H; } 尾部插入 ①建一个新节点
②找尾节点
③尾部插入
int list_tail_insert(linklist H, data_t value) { linklist p; linklist q; if (H == NULL) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa504d109f53bb1fe262bbe2fb28bd44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6617e798298c8fe80f995b2275a2a224/" rel="bookmark">
			wifihal的实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		modified: make/target/product/base_system.mk　//这次添加JNI的时候，单边模块是可以生成的jni的库的，但是，整编就是不能生成．　最后，在这个MK文件中添加JNI的模块名，结果还是生成了的．
— a/make/target/product/base_system.mk
+++ b/make/target/product/base_system.mk
@@ -273,6 +273,7 @@ PRODUCT_PACKAGES += wificond wifi.rc wm \
libwifi-service \ ( w a r n i n g C F G T E E S U P P O R T = (warning CFG_TEE_SUPPORT= (warningCFGT​EES​UPPORT=(CFG_TEE_SUPPORT))　//在ＭＡＫＥＦＩＬＥ中添加ＬＯＧ
typedef enum {
WIFI_POWER_SCENARIO_INVALID = -2,
WIFI_POWER_SCENARIO_DEFAULT = -1,　//wifi_reset_tx_power_scenario
WIFI_POWER_SCENARIO_VOICE_CALL = 0,
WIFI_POWER_SCENARIO_ON_HEAD_CELL_OFF = 1,
WIFI_POWER_SCENARIO_ON_HEAD_CELL_ON = 2,
WIFI_POWER_SCENARIO_ON_BODY_CELL_OFF = 3,
WIFI_POWER_SCENARIO_ON_BODY_CELL_ON = 4,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6617e798298c8fe80f995b2275a2a224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b2b6f14df8a37635ae2c52fa9ad8f1/" rel="bookmark">
			谷歌8.0新版iframe嵌套跨域请求cookie丢失问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?php // &lt;php7.3版本,cookie设置sameiste参数方法 header('Set-Cookie: cross-site-cookie=bar; SameSite=None; Secure'); // 注意: secure参数 // 1.指示仅应从客户端通过安全的HTTPS连接传输cookie。 // 设置true为时，仅当存在安全连接时(域名必须添加https证书)才设置cookie。 // 2.在Chrome 84版本启动时，没有安全属性secure的cookie也会被拒绝。 // &gt;php7.3版本,cookie设置方法 $arr_cookie_options = array ( 'expires' =&gt; time() + 60*60*24*30, 'path' =&gt; '', 'domain' =&gt; '', // leading dot for compatibility or use subdomain 'secure' =&gt; true, // or false 'httponly' =&gt; false, // or false 'samesite' =&gt; 'None' // None || Lax || Strict ); setcookie('TestCookie', 'The Cookie Value', $arr_cookie_options); ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47b2b6f14df8a37635ae2c52fa9ad8f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0becca215d93b78f0d42c14e54f5c2c/" rel="bookmark">
			分布式系统Sentinel整合Open-Feign限流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式系统Sentinel整合Open-Feign限流 一、前言二、sentinel控制台1、调用与被调用方引入依赖2、控制台搭建3、启动 三、限流配置1、多个微服务接入Sentinel配置 四、面板介绍五、基于并发线程数进行限流配置六、降级熔断策略1、熔断实操2、自定义降级异常数据 七、Sentinel整合OpenFeign配置容错设计实战1、加入依赖2、开启Feign对Sentinel的支持3、配置feign容错类4、FallBack类继承外调service接口5、调用方controller6、当被调用方服务出现宕机异常 八、升级jdk11 一、前言 提示：本文讲到的代码部分来自上文
上文链接地址
二、sentinel控制台 1、调用与被调用方引入依赖 &lt;!--sentinel依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; 2、控制台搭建 控制台搭建地址
下载安装包sentinel-dashboard-1.8.0.jar
3、启动 //启动 Sentinel 控制台需要 JDK 版本为 1.8 及以上版本， //-Dserver.port=8100 用于指定 Sentinel 控制台端口为 8100 //默认用户名和密码都是 sentinel ​ //普通进程 java -Dserver.port=8100 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.0.jar //守护进程 nohup java -Dserver.port=8100 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.0.jar &amp; 三、限流配置 1、多个微服务接入Sentinel配置 调用与被调用都需配置port不一样
spring: cloud: sentinel: transport: dashboard: 127.0.0.1:8080 port: 9999 ​ #dashboard: 8080 控制台端口 #port: 9999 本地启的端口，随机选个不能被占用的，与dashboard进行数据交互，会在应用对应的机器上启动一个 Http Server，该 Server 会与 Sentinel 控制台做交互, 若被占用,则开始+1一次扫描 设置QPS单机阀值为2，一秒大于两个会被流控
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0becca215d93b78f0d42c14e54f5c2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5071a4926815d59c7f99f0bfadc9a8eb/" rel="bookmark">
			SpringBoot后端接收参数方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、类对象+属性（省略@RequestParam注解） @Controller public class Test { @RequestMapping("/test1") @ResponseBody public void test(User user,String username,String password) { System.out.println(user.getUsername()); System.out.println(user.getPassword()); System.out.println(username); System.out.println(password); } } 2、属性（加@RequestParam注解） @RequestMapping("/test2") @ResponseBody public void test(@RequestParam String username,@RequestParam String password){ System.out.println(username); System.out.println(password); } 3、对象（加@RequestBody注解） @RequestMapping(value = "/test3",method = {RequestMethod.POST}) @ResponseBody public void test(@RequestBody User user){ System.out.println(user.getUsername()); System.out.println(user.getPassword()); } 4、Map数据结构（加@RequestBody注解） @RequestMapping(value = "/test4",method = {RequestMethod.POST}) @ResponseBody public void test(@RequestBody Map map){ System.out.println(map.get("username")); System.out.println(map.get("password")); } 5、String转对象（加@RequestBody注解） @RequestMapping(value = "/test5",method = {RequestMethod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5071a4926815d59c7f99f0bfadc9a8eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e03cc4024945a631cd9bdfb9ddf26bd/" rel="bookmark">
			BeanPostProcessor的作用和应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@BeanPostProcessor的作用和应用场景 目录概述Spring问题 实现思路分析相关工具如下： 分析： 小结：参考资料和推荐阅读 LD is tigger forever，CG are not brothers forever， throw the pot and shine forever.
Modesty is not false, solid is not naive, treacherous but not deceitful, stay with good people, and stay away from poor people.
talk is cheap, show others the code,Keep progress，make a better result.
Survive during the day and develop at night。
目录 概述 有时候，我们希望Spring容器在创建bean的过程中，能够使用我们自己定义的逻辑，对创建的bean做一些处理，或者执行一些业务。而实现方式有多种，比如自定义bean的初始化话方法等，而BeanPostProcessor接口也是用来实现类似的功能的。
如果我们希望容器中创建的每一个bean，在创建的过程中可以执行一些自定义的逻辑，那么我们就可以编写一个类，并让他实现BeanPostProcessor接口，然后将这个类注册到一个容器中。容器在创建bean的过程中，会优先创建实现了BeanPostProcessor接口的bean，然后，在创建其他bean的时候，会将创建的每一个bean作为参数，调用BeanPostProcessor的方法。而BeanPostProcessor接口的方法，即是由我们自己实现的。下面就来具体介绍一下BeanPostProcessor的使用。
我们先看一看BeanPostProcessor接口的代码：
public interface BeanPostProcessor { // 注意这个方法名称关键的是before这个单词 Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; // 注意这个方法名称关键的是after这个单词 Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException; } bean：容器正在创建的那个bean的引用；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e03cc4024945a631cd9bdfb9ddf26bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a69f8135e823de6ebc5654874c0d3507/" rel="bookmark">
			启动AndroidStudio报错Missing essential plugin:org.jetbrains.android Please reinstall Android Studio...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 今天升级Android Studio 后，打算重新启动，却发现启动报错如下：
Missing essential plugin: org.jetbrains.android Please reinstall Android Studio from scratch. 分析 导致这个问题最主要的问题可能是版本不一致或插件等问题
解决 1、Windows版本Android Studio下解决方案 如下图所示：
1、打开windows目录下该路径，其中AppData默认是隐藏文件，需要先打开查看隐藏文件；
2、打开 disabled_plugins.txt文件，删除文件中org.jetbrains开头的文件字样即可。
2、Mac版本Android Studio下解决方案 1、打开Mac下如下目录：/Users/apple/Library/Application Support/Google/AndroidStudio2020.3/disabled_plugins.txt。
其中：
（1）apple -&gt; 代表用户，AndroidStudio2020.3 -&gt; 代表使用的as版本
（2）Library -&gt; 指资源库，默认为隐藏文件不可见，需要打开查看隐藏文件。
2、打开该文件，如下图所示，删除引起问题的配置即可
disabled_plugins.txt：
com.vladsch.idea.multimarkdown org.jetbrains.kotlin 我的项目本次报错为Kotlin插件引起的，所以只需要删除“org.jetbrains.kotlin”这行，然后重新启动Android Studio即可。
对应的如果你明确知道是因为哪个插件报错，删除对应插件配置即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23866c111af3a908bc3ee04b6f637378/" rel="bookmark">
			Mybatis配置文件中的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis配置文件中的设置 设置名描述有效值默认cacheEnabled全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。true | falsefalselazyLoadingEnabled延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。true | falsefalseaggressiveLazyLoading开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按 需加载（参考 lazyLoadTriggerMethods )。true | falsefalse （在 3.4.1 及之前的版本中默认为 true）multipleResultSetsEnabled是否允许单个语句返回多结果集（需要数据库驱动支持）。true | falsetrueuseColumnLabel使用列标签代替列名。实际表现依赖于数据库驱动，具体可参考数据库驱动的相关文档，或通 过对比测试来观察。true | falsetrueuseGeneratedKeys允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成 主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。true | falseFalseautoMappingBehavior指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自 动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌 套）。NONE, PARTIAL, FULLPARTIALautoMappingUnknownColumnBehavior指定发现自动映射目标未知列（或未知属性类型）的行为。 NONE : 不做任何反应WARNING : 输出警告日志 （ ‘org.apache.ibatis.session.AutoMappingUnknownColumnBehavior’ 的日志等级必须设置为 WARN ） FAILING : 映射失败 (抛出 SqlSessionException )NONE, WARNING, FAILINGNONEdefaultExecutorType配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句 （PreparedStatement）； BATCH 执行器不仅重用语句还会执行批量更新。SIMPLE REUSE BATCHSIMPLEdefaultStatementTimeout设置超时时间，它决定数据库驱动等待数据库响应的秒数。任意正整数未设置 (null)defaultFetchSize为驱动的结果集获取数量（fetchSize）设置一个建议值。此参数只可以在查询设置中被覆盖。任意正整数未设置 (null)defaultResultSetType指定语句默认的滚动策略。（新增于 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23866c111af3a908bc3ee04b6f637378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f0affd2ee1646133a1be1f6a7591152/" rel="bookmark">
			我的个人博客live2d插件模型模块汇总（仅本人可使用，无需看）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。 所以看到这的可以退出这篇文章了！！！ shizuku
------------------------*************************************------------------------
nipsilon
------------------------*************************************------------------------
nito
------------------------*************************************------------------------
nico
------------------------*************************************------------------------
ni-j
------------------------*************************************------------------------
haru
------------------------*************************************------------------------
haruto
------------------------*************************************------------------------
tsumiki
------------------------*************************************------------------------
z16
------------------------*************************************------------------------
tororo
------------------------*************************************------------------------
koharu
------------------------*************************************------------------------
hijiki
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a3d77fb68fbced33aa83ebbbaed80e/" rel="bookmark">
			电脑风扇转一下停一下开不了机解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：电脑开机键按下后、电脑风扇转一下停一下、再转一下停一下，开不了机
解决方案：
1、有部分主板有保护模块
主板有一个保护线模块 取掉就可以正常开机
2、静电原因
放静电：主板电池取掉、 拔掉电源然后多按几次开机键释放静电后，插好上电源 即可正常开机
3、内存问题
3.1 将内存条拔下：用硬纸或橡皮擦将金手指擦一下 、插上即可
3.2 若还是不能开机内存条换一个插口试试。
4、电源坏掉
更换新的电源试试
5,主板boiss 重新刷入即可
找网上相关教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/435f3078aef91f56f35b8d4397c93a3d/" rel="bookmark">
			【深度学习】目前几种热门的数据增强方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1）Mosaic增强
2）Mixup增强
3）Cutout增强
3）CutMix增强
前言
传统的镜像、旋转、缩放、调整亮度、对比度、高斯噪声这里不详细讲解。主要讲一下现在几种火爆的数据增强方式。
1）Mosaic增强 将4张图片缩放，然后拼接到一起。
Mosaic增强的主要优点：
丰富数据集：随机使用4张图片，随机缩放，再随机分布进行拼接，大大丰富了检测数据集，特别是随机缩放增加了很多小目标，让网络的鲁棒性更好。减少GPU：同时Mosaic增强训练时，可以直接计算4张图片的数据，使得Mini-batch大小并不需要很大，一个GPU就可以达到比较好的效果。
2）Mixup增强 MixUp增强：将随机的两张样本按比例混合，分类的结果按比例分配；yolo_x采用Mosaic+MixUp的数据增强方式。
3）Cutout增强 Cutout增强：随机的将样本中的部分区域cut掉，并且填充0像素值，分类的结果不变；
3）CutMix增强 就是将一部分区域cut掉但不填充0像素而是随机填充训练集中的其他数据的区域像素值，分类结果按一定的比例分配;带Mix就是混合的意思，带Cut就是裁剪的意思。
上述三种数据增强的区别：
cutout和cutmix就是填充区域像素值的区别；mixup和cutmix是混合两种样本方式上的区别：mixup是将两张图按比例进行插值来混合样本，cutmix是采用cut部分区域再补丁的形式去混合图像，不会有图像混合后不自然的情形 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d957d0be6fac7141269010f32c5a58bf/" rel="bookmark">
			NLP预训练方法：从BERT到ALBERT详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BERT基于所有层中的左、右语境进行联合调整，来预训练深层双向表征。只需要增加一个输出层，就可以对预训练的BERT表征进行微调，就能够为更多的任务创建当前的最优模型。使用的是Transformer，相对于rnn而言更加高效、能捕捉更长距离的依赖。
1. 预训练优点 假设已有A训练集，先用A对网络进行预训练，在A任务上学会网络参数，然后保存以备后用，当来一个新的任务B，采取相同的网络结构，网络参数初始化的时候可以加载A学习好的参数，其他的高层参数随机初始化，之后用B任务的训练数据来训练网络，当加载的参数保持不变时，称为"frozen"，当加载的参数随着B任务的训练进行不断的改变，称为“fine-tuning”，即更好地把参数进行调整使得更适合当前的B任务
优点：当任务B的训练数据较少时，很难很好的训练网络，但是获得了A训练的参数，会比仅仅使用B训练的参数更优
2. BERT模型 BERT：全称是Bidirectional Encoder Representation from Transformers，即双向Transformer的Encoder，BERT的模型架构基于多层双向转换解码，因为decoder是不能获要预测的信息的，模型的主要创新点都在pre-traing方法上，即用了Masked LM和Next Sentence Prediction两种方法分别捕捉词语和句子级别的representation
其中“双向”表示模型在处理某一个词时，它能同时利用前面的词和后面的词两部分信息，这种“双向”的来源在于BERT与传统语言模型不同，它不是在给你大牛股所有前面词的条件下预测最可能的当前词，而是随机遮掩一些词，并利用所有没被遮掩的词进行预测
如图其中 BERT 和 ELMo 都使用双向信息，OpenAI GPT 使用单向信息。
3. ALBERT 通常情况下，增加预训练模型大小会带来效果的提升；然而，当模型大小达到一定的程度之后，就很难再进行了，因为受到了GPU内存和训练时间的限制。为了减小模型参数和模型训练时间，ALBERT提出了两种解决方法。ALBERT也是采用和Bert一样的Transformer的Encoder[1]结构，激活函数也是GLUE[2]。相比于Bert，ALBERT主要改进之处在于以下几点：Embedding因式分解(Factorized embedding parameterization)、层间参数共享(Cross-layer parameter sharing)、句子间关联损失(Inter-sentence coherence loss)。
3.1 Embedding因式分解 我们用H表示隐藏层大小，E表示embedding维度，V表示词汇表的大小。
Bert base模型的Encoder输出大小(H)和embedding维度(E)都是768，然而，ALBERT认为词级别的embedding是没有上下文依赖的表述；而隐藏层的输出值，不仅包括了词本身的意思，还包含了上下文信息。理论上来说隐藏层包含的信息更多一些，因此应该让H &gt;&gt; E。所以ALBERT的embedding维度是小于encoder输出维度的。在NLP任务中，通常词典都很大，embedding矩阵的大小是E×V，如果和Bert一样让H = E，那么embedding矩阵的参数量会很大，并且在反向传播过程中，更新的内容也比较稀疏。
结合上述所说的两点，ALBERT采用了一种因式分解的方法来降低参数量。首先把one-hot向量映射到一个低纬度的空间，大小为E，然后再映射到一个高纬度的空间(H)；从而把参数量从O(V×H)降低到了O(V×E + E×H)，当E &lt;&lt; H时，参数量就减少得很明显了。
3.2 层间参数共享 Transformer中共享参数的方案有多种，比如，只共享全连接层，只共享Attention[1]层。ALBERT结合了上述两种方案，对全连接层和Attention都进行参数共享，也就是共享encoder所有的参数。同量级下的Transformer采用该共享方案后实际效果有所下降，但是参数量减少了很多，训练速度也提升了很多。
ALBERT减小了模型参数，提升了训练速度，且每一层的输出的embedding相比于BERT来说震荡幅度更小一些。可见参数共享其实是有稳定网络参数的作用的。
3.3 构建自学习任务-句子连贯性预测 在预训练任务上提高：改造NSP任务，强化网络学习句子的连续性；
NSP任务实际上是一个二分类任务，即预测两句话是采样于同一个文档中的两个连续的句子（正样本），还是采样于两个不同的文档中的句子（负样本）。NSP任务实际上包含两个子任务，即topic预测和关系一致性预测，而topic预测其实很简单；NSP在很多实践中被证明没有太好效果；
因此，ALBERT选择去除topic预测的影响，只保留关系一致性预测，于是提出了一个新的任务 Sentence-Order Prediction (SOP)，SOP的正样本和NSP的获取方式一样，负样本把正样本的两句话顺序反转；
3.4 去掉dropout dropout在防止过拟合上有显著效果，但是实际上MLM很难过拟合，去掉dropout，由于可以腾出很多临时变量占用的内存而使得内存上有所提升；
from transformers import AlbertConfig, TFAlbertMainLayer config = AlbertConfig(vocab_size=0,embedding_size=item_dim, hidden_size=hidden_size,num_hidden_layers=num_layers,num_hidden_groups=1,num_attention_heads=num_heads,intermediate_size=intermediate_size,inner_group_num=1,max_position_embeddings=self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d957d0be6fac7141269010f32c5a58bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c4fb4013f489675230fccb89b3ee1f/" rel="bookmark">
			反弹shell与正向shell的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正向shell： 攻击机A，受害者B
正向shell:正常大家都能理解 A主动连接B，直接使用ssh命令；受害者的命令行的输入输出转到控制端
反弹shell: 反弹shell就是控制端监听在某TCP/UDP端口，被控端发起请求到该端口，将受害者的命令行的输入输出转到控制端
结论： 无论是正向shell还是反弹shell，都是A控制B，只是请求端不一样，一个是主动控制，一个被动控制，与正向代理和反向代理一样
反弹shell就会更加的稳定，用途更大
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bd299babc9d58fa919bd46f02635a4c/" rel="bookmark">
			记录一个tableView不能滚动的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：tableView的父视图的父视图关闭了用户交互
即 .userInteractionEnabled = NO;
去掉即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7de949bc4472bd4c027defa8ab221c84/" rel="bookmark">
			信息安全工程第三章密码学基本理论要点小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 3.1密码学概况3.2密码体制分类3.3常见密码算法3.4Hash函数与数字签名3.5密码管理与数字证书3.6安全协议3.7密码学网络安全应用 3.1密码学概况 密码学是一门研究信息安全保护的科学，以实现信息的保密性、完整性、可用性及抗抵赖性。密码学主要由密码编码和密码分析两个部分组成。其中，密码编码学研究信息的变换处理以实现信息的安全保护，而密码分析学则研究通过密文获取对应的明文信息。
2005 4月1日起国家施行《中华人民共和国电子签名法》。2006 年我国政府公布了自己的商用密码 法，成为我国密码发展史上的一件大事。 2019 年《中华人民共和国密码法》草案已经发布。
密码学的主要目的是保持明文的秘密以防止攻击者获知，而密码分析学则是在不知道密钥的情况下，识别出明文的科学。
明文是指需要采用密码技术进行保护的消息。而密文则是指用密码技术处理过明文的结果，通常称为加密消息。将明文变换成密文的过程称作加密，其逆过程，即由密文恢复出原明文的过程称作解密。
加密过程所使用的一组操作运算规则称作加密算法，而解密过程所使用的一组操作运算规则称作解密算法。加密和解密算法的操作通常都是在密钥控制下进行的，分别称为加密密钥和解密密钥。
密码分析攻击类型分为五种：
(1) 唯密文攻击 (ciphertext-only attack) 。
(2) 已知明文攻击 (known-plaintext attack) 。
(3) 选择明文攻击 (chosen-plaintext attack) 。
(4) 密文验证攻击 (ciphertext verification attack) 。
(5) 选择密文攻击 (chosen-ciphertext attack) 。
3.2密码体制分类 私钥密码体制又称为对称密码体制，指广泛应用的普通密码体制，该体制的特点是加密和解密使用相同的密钥。
当用户应用这种体制时，消息的发送者和接收者必须事先通过安全渠道交换密钥，以保证发送消息或接收消息时能够有供使
用的密钥。
存在很大的问题就是密钥该如何传输过去才能保障其安全。
私钥密码体制的缺陷可归结为三点：密钥分配问题、密钥管理问题以及无法认证源。虽然私钥密码体制有不足之处，但私钥密码算法处理速度快，人们常常将其用作数据加密处理。目前，私钥密码典型算法有 DES IDEA AES 其中 DES 是美国早期数据加密标准，现在已经被 AES 取代。
公钥密码体制又称为非对称密码体制，其基本原理是在加密和解密的过程中使用不同的密钥处理方式，其中，加密密钥可以公开，而只需要把解密密钥安全存放即可。在安全性方面，密码算法即使公开，由加密密钥推知解密密钥也是计算不可行的。不适合大数据、明文加密
与私钥密码体制相比较，公钥密码体制有以下优点：
(1) 密钥分发方便，能以公开方式分配加密密钥。
(2) 密钥保管量少。
(3) 支持数字签名。
混合密码体制利用公钥密码体制分配私钥密码体制的密钥，消息的收发双方共用这个密钥，然后按照私钥密码体制的方式，进行加密和解密运算。
混合密码体制的工作原理：
第一步，消息发送者 Alice 用对称密钥把需要发送的消息加密 。
第二步， Alice 用Bob公开密钥将对称密钥加密，形成数字信封。然后， 起把加密消息和数字信封传送给 Bob 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7de949bc4472bd4c027defa8ab221c84/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/286/">«</a>
	<span class="pagination__item pagination__item--current">287/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/288/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>