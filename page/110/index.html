<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1553bcbd23b5349cc7db5d9cc2401b9/" rel="bookmark">
			Vue2通过点击渲染循环的echarts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		底下放置源码cv即可食用
几个注意事项：
echartsData 这个变量是为了模拟后端数据格式changeTag() 这个方法是为了控制最多可以多选几条最后关于循环echarts的灵感来源于 明天也要努力 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/echarts/4.2.1-rc1/echarts.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;style&gt; * { padding: 0; margin: 0; box-sizing: border-box; } .container { width: 1000px; margin: 0 auto; background-color: #fff; padding-top: 20px; height: 100%; } .typeBox { display: flex; flex-wrap: wrap; } .type_list { width: calc((100% - 60px) / 2); height: 105px; background: #ffffff; box-shadow: 0px 2px 6px 0px rgba(0, 0, 0, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1553bcbd23b5349cc7db5d9cc2401b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c604195b5e9b2a0cce27c2739b897943/" rel="bookmark">
			AI 绘画Stable Diffusion 研究（二）sd模型ControlNet1.1 介绍与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部署包作者:秋葉aaaki
免责声明:
本安装包及启动器免费提供 无任何盈利目的
大家好，我是风雨无阻。
众所周知，StableDiffusion 是非常强大的AI绘图工具，需要详细了解StableDiffusion的朋友，可查看我之前的这篇文章： 最近大火的两大AI绘图工具 Midjourney VS StableDiffusion。
今天为大家带来的是 Stable Diffusion 研究（二）sd模型ControlNet1.1 介绍与安装 。
首先来明确一下这个ControlNet1.1 到到底是什么？
ControlNet1.1 是Stable Diffusion 绘画插件，在2023年4月份更新了 V1.1 版本，发布了14 个优化模型，并新增了多个预处理器，并且在原有的模型上进行了一些优化，让它的功能比之前更加好用了。
那么我们先来详细了解一下 ControlNet1.1 的新模型新功能。
一、ControlNet1.1 的新模型新功能
1、新增Lineart模型 和 lineart_anime模型
现在新增了两个模型，lineart和lineart anime，完全可以替代原来的Canny强大的线稿上色，无论是上色黑白和彩色功能都非常强大。
2、新增Instruct Pix2Pix 模型
模型能够接受一张图像和相应的文字指令(也就是prompt)，根据指令来编辑图像，局部整体操纵图像程度的能力。
将白天变为夜晚 ，如图：
​ 换发型 ，如图：
​ 换装 ，如图：
​ 3、 新增Tile 模型
Tile 模型对于图片高清修复、提升细节、根据画面自动推断内容有着很好效果，根据官方的介绍有5种功能：
可以进行图片放大 2x、4x 或 8x 超分辨率可以在图像中添加、更改或重新生成图像细节可以修复、细化和改进通过任何其他超分辨率方法获得的不良图像细节它可以引导SD放大脚本，生成错误的问题可以完成未完成的图稿，如果这些图稿是用色块绘制的 图像修复前：
图像修复后：
细节调整前：
细节调整后：
4 、新增shuffle 模型
shuffle模型可以称为重组模型，从shuffle模型的是使用效果来看，shuffle模型可以通过获取原图的风格后借助这个风格进行新的图片生成，所以当我们找到比较好的参考图时，就可以使用shuffle模型进行图片创作。
我们先来看一下人物图处理效果：
从成图效果来看，新生成的图片风格、色调、人物的部分姿态都进行还原和保留，因此我们使用Shuffle模型可以使用原图进行参考借鉴，重组画面进行生成的新图片。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c604195b5e9b2a0cce27c2739b897943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfda0f81cc926b551222f78e597dade6/" rel="bookmark">
			「Elasticsearch 」Es复合查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Bool 查询 Dis_max 查询
Function_score 查询
Nested 查询 Geospatial 查询 1. Geo Point 查询
2. Geo Shape 查询
Elasticsearch（简称为ES）是一个基于Lucene的分布式搜索和分析引擎，它提供了丰富的查询语言和API，可以用于构建高性能、可扩展的全文搜索、日志分析和数据可视化等应用。
在 Elasticsearch 中，复合查询是一种将多个查询组合起来进行检索的方式，可以根据用户的需求进行灵活的组合和定制，常见的复合查询包括 bool、dis_max、function_score 等。以下是一些常见的 ES 复合查询：
1. Bool 查询
bool 查询是 ES 中使用最为广泛的复合查询，可以组合多个查询条件和过滤器，支持must、should、must_not 等子句，可以实现AND、OR、NOT 等逻辑关系操作。
2. Dis_max 查询
dis_max 查询是一种多字段查询，可以在多个字段中搜索相同的关键字，并对得分较高的结果进行返回。它适用于搜索关键字在多个字段中都可能出现的情况。
3. Function_score 查询
function_score 查询可以通过自定义的函数计算得分，可以根据业务需求进行加权排序、过滤、封顶等操作。
4. Nested 查询
nested 查询可以在文档的嵌套对象中进行搜索，适用于包含多个内部对象的文档结构。
5. Geospatial 查询
geospatial 查询可以在 ES 中进行地理位置检索，可以对符合条件的位置信息进行查询和过滤，支持圆形、多边形、距离等多种方式。
总之，ES提供了丰富的查询语言和API，用户可以根据实际的业务需求进行灵活的组合和定制，以实现高效、准确的全文搜索和数据分析。
Bool 查询 bool 查询是 Elasticsearch 中一个非常灵活的查询方式，可以根据多个子查询的组合来实现复杂的查询需求。其语法如下：
{ "query": { "bool": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfda0f81cc926b551222f78e597dade6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c2baf13ced380c40c318cf8ee302451/" rel="bookmark">
			mybatis-plus自定义类型转换器typeHandler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 将list属性保存进数据库，数据库中的字段属性为text，需要将list转为JSON格式进行保存，查询的时候再将JSON格式转为list集合
实体类 @TableName(value = "t_member",autoResultMap = true) public class Member implements Serializable { private static final long serialVersionUID = 1L; @TableField(typeHandler = JsonStringListTypeHandler.class) private List&lt;CarInformation&gt; carInformationList; public List&lt;CarInformation&gt; getCarInformationList() { return carInformationList; } public void setCarInformationList(List&lt;CarInformation&gt; carInformationList) { this.carInformationList = carInformationList; } @Override public String toString() { return JSON.toJSONString(this); } } 转换类 /** * 将list集合转为为JSON格式 * * @author xiangtianlei * @date 2023/06/29 */ public class JsonStringListTypeHandler extends BaseTypeHandler&lt;List&lt;CarInformation&gt;&gt; { private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(); @Override public void setNonNullParameter(PreparedStatement ps, int i, List&lt;CarInformation&gt; parameter, JdbcType jdbcType) throws SQLException { try { String jsonString = OBJECT_MAPPER.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c2baf13ced380c40c318cf8ee302451/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b43c76415e8c55471c1b9349f3c11a11/" rel="bookmark">
			「JVM」Full GC和Minor GC、Major GC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Full GC和Minor GC、Major GC 一、Full GC1、什么是Full GC?2、什么情况下会触发full gc？ 二、Minor GC1、什么是Minor GC？2、什么情况下会触发Minor GC？ 三、Major GC1、什么是Major GC？2、什么情况下会触发Major GC？ 四、Major GC和Full Gc的区别五、总结 一、Full GC 1、什么是Full GC? Full GC（Full Garbage Collection）是Java虚拟机（JVM）中的一种垃圾回收操作。它是指对整个堆内存进行回收，包括新生代和老年代。
在Java中，垃圾回收器通常会将堆内存划分为不同的区域，如新生代和老年代。当新生代空间不足时，会触发Minor GC，只清理新生代内存。而当老年代空间不足或者为了整理碎片化的内存，会触发Full GC，对整个堆内存进行回收。
Full GC 可能会导致较长的停顿时间，因为它需要扫描整个堆内存，标记可回收对象，并进行内存整理。这意味着在 Full GC 过程中，应用程序的执行会被暂停。
Full GC 的频率会受多种因素影响，如堆内存的大小、JVM配置参数、对象分配速度等。如果 Full GC 发生过于频繁或耗时过长，可能会导致应用程序的性能下降。
为了减少 Full GC 的频率和时间，可以采取以下策略：
调整堆内存大小：适当设置堆内存大小，避免过小或过大的情况。优化对象分配：减少临时对象的创建和使用，避免过多的对象进入老年代。设置合适的垃圾回收器：根据应用程序的需求和性能特点，选择合适的垃圾回收器和相应的配置参数。进行代码优化：减少内存泄漏和不必要的对象引用，使垃圾回收更高效。 需要注意的是，Full GC 是一项比较重型的操作，在设计和调优应用程序时需要综合考虑内存分配、垃圾回收和应用程序的执行性能，以达到良好的性能和响应速度。
2、什么情况下会触发full gc？ Full GC（Full Garbage Collection）在Java虚拟机（JVM）中触发的情况主要有以下几种：
Minor GC后老年代空间不足：Minor GC（新生代垃圾回收）时，如果存活的对象无法全部放入老年代，或者老年代空间不足以容纳存活的对象，则会触发Full
GC，对整个堆内存进行回收。
显式调用System.gc()：尽管调用System.gc()方法不能保证立即进行Full GC，但它可以向JVM建议执行垃圾回收操作，包括Full GC。不过，频繁调用System.gc()是不推荐的。
永久代空间不足（仅适用于JVM 8及之前版本）：在传统的JVM版本中，永久代（Permanent Generation）用于存储类和方法相关信息。如果永久代空间不足，JVM会触发Full GC来清理永久代。
CMS初始化标记阶段出现Promotion Failed：CMS回收器（Concurrent Mark Sweep）是一种用于减少停顿时间的垃圾回收器。在CMS的初始化标记（InitialMark）阶段，如果发现无法为所有存活对象标记，可能会触发Full GC。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b43c76415e8c55471c1b9349f3c11a11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255456fa190e9c29b18ed0de17b12a96/" rel="bookmark">
			使用云服务器和Frp(快速反向代理)框架快速部署实现内网穿透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 背景1.1 内网穿透1.2 Frp介绍1.3 Frp配置流程 二. 云服务器配置2.1 配置安全组2.2 编写frps.ini 三. 内网主机配置3.1 编辑frpc.ini文件3.2 启动服务并配置开机自启动 四. 参考文献 一. 背景 现在有一台ubuntu云服务器，我想通过内网穿透将一台内网的主机当成云服务器来使用（包括但不限于ssh、http和https服务），比如我想在外地通过ssh远程连接到一台内网没有桌面的主机（可以是Ubuntu或者Windows，Windows配置类似），就可以使用frp内网穿透， 配置起来非常方便快捷。
1.1 内网穿透 内网穿透是指，通过一些代理工具，允许你在内网主机上运行代理工具客户端，通过连接到公网上运行的代理服务器，将内网主机的服务暴露到公网上，实现内网穿透，让外部用户可以访问内网的服务。
常见的内网穿透工具：
1.Ngrok：Ngrok是一个简单易用的内网穿透工具，它可以将本地服务暴露到公网上，并提供一个临时的公网地址供外部访问。Ngrok支持多种协议和自定义子域名，但其免费版功能有限，需要购买许可证来解锁更多功能。
2.Frp（Fast Reverse Proxy）：Frp是一个快速的反向代理工具，用于将局域网中的内部服务暴露给公网，实现内网穿透的功能。Frp是开源的，支持TCP、UDP、HTTP和HTTPS等协议，配置简单，支持身份验证和加密功能。
3.SSH反向隧道：SSH反向隧道是通过SSH协议建立一个安全的连接，将本地端口转发到公网服务器，实现内网穿透。SSH反向隧道是一种简单、安全的方法，但对SSH服务有一定的依赖。
4.ZeroTier：ZeroTier是一种虚拟局域网（SD-WAN）技术，它可以将多个设备虚拟连接成一个局域网，实现内网穿透。ZeroTier支持多平台，包括Windows、Linux、macOS、iOS和Android等。
1.2 Frp介绍 Frp（Fast Reverse Proxy）是一个快速的反向代理工具，它是一款基于Golang语言开发的开源项目，用于将局域网中的内部服务暴露给公网，实现内网穿透的功能。
主要特点和用途：
1.内网穿透：Frp允许你在内网主机上运行frpc客户端，通过连接到公网上运行的frps服务器，将内网主机的服务暴露到公网上，实现内网穿透，让外部用户可以访问内网的服务。
2.简单易用：配置简单，可以通过编辑ini配置文件来指定要暴露的内网服务和端口号等信息。
3.多种协议支持：Frp支持多种协议，如TCP、UDP、HTTP、HTTPS等，适用于各种类型的服务。
4.安全性：Frp提供了身份验证和加密功能，可以保障数据传输的安全性。
Frp由两个组件组成：
（1）frps（Frp Server）：运行在公网服务器上，用于接受来自frpc客户端的连接请求，并将请求转发到内网主机上的指定服务。
（2）frpc（Frp Client）：运行在内网主机上，用于与frps服务器建立连接，并将本地服务的请求转发到frps服务器上。
1.3 Frp配置流程 1.在公网服务器上配置frps，编辑frps.ini文件指定公网服务器的IP地址和端口号，以及认证令牌等。
2.在内网主机上配置frpc，编辑frpc.ini文件指定frps服务器的IP地址和端口号，以及要暴露的内网服务的端口号等。
3.运行frps服务器和frpc客户端。
二. 云服务器配置 2.1 配置安全组 打开云服务器的7000、80和443端口：
2.2 编写frps.ini 下载frp: https://github.com/fatedier/frp/releases
tar -zxvf frp_0.37.1_linux_amd64.tar.gz cd frp_0.37.1_linux_amd64/frps [common] # frps服务监听的IP地址和端口 bind_addr = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/255456fa190e9c29b18ed0de17b12a96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55dc5efa51bc86b59dc5ce759dc94861/" rel="bookmark">
			【状态压缩dp】蒙德里安的梦想、最短Hamiltona路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		状态压缩dp是动态规划里一种常见类型，顾名思义，状态压缩要把状态表示“压缩一下”，那么何为压缩，下面用两道例题来体会一下“压缩”的概念。
目录 1、蒙德里安的梦想2、最短Hamilton路径3、总结 1、蒙德里安的梦想 原题acwing 蒙德里安的梦想
求把 N×M 的棋盘分割成若干个 1×2 的长方形，有多少种方案。
例如当 N=2，M=4 时，共有 5 种方案。当 N=2，M=3 时，共有 3 种方案。
如下图所示：
输入格式
输入包含多组测试用例。
每组测试用例占一行，包含两个整数 N 和 M。
当输入用例 N=0，M=0 时，表示输入终止，且该用例无需处理。
输出格式
每个测试用例输出一个结果，每个结果占一行。
数据范围
1≤N,M≤11
输入样例：
1 2
1 3
1 4
2 2
2 3
2 4
2 11
4 11
0 0
输出样例：
1
0
1
2
3
5
144
51205
这道题目的思路就是，先填横向的小长方形，剩下的区域填竖向的小长方形，那么竖向的就只有一种填法了。所以总的填法等于横向小长方形的所有填法。
这里一列一列的思考，想要在当前列填充横向小长方形，就要考虑上一列的横向小长方形是怎么填的，因为只有一列，但是小长方形是1×2的，所以前一列的横向小长方形必然会捅到这一列。这时候就会有人问：那捅到前面一列的呢？捅到前面一列的就算是前面一列捅过来的即可。
下一步就要开始dp流程了。先思考状态表示，根据上面的推导，得到：
用 f ( i , j ) f(i,j) f(i,j)表示第 i − 1 i-1 i−1列捅到第 i i i列的情况是 j j j时，前 i i i列所有的摆法（比较绕，仔细体会）。首先想想怎么存，可以用1表示捅过来，0表示没有捅过来。想要表示捅过来的情况有点难，但是注意到每个格子只有捅过来和不捅过来这两种情况，所以可以考虑用状态压缩，也即对位进行操作，第几位代表第几列，这一位上是1代表有捅过来的，0代表没有捅过来的。举个例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55dc5efa51bc86b59dc5ce759dc94861/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c497f828cf83c4b9e1f97d97fc76fd/" rel="bookmark">
			gcc 编译时指定动态链接器与libc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 笔者在尝试使用多libc编译源代码时，遇到了一些问题，现已经解决，将自己的理解记录如下。
本文为使用多版本libc编译提供了一个新思路，对笔者的帮助较大，也希望与读者多多讨论。
程序如何动态链接？ - libc 与 ld 通常我们编译的程序都采用动态链接的方式，在程序运行中查找公共链接库中的函数，并跳转执行。这对减小可执行文件的体积和提升程序可维护性非常有帮助。毕竟，我们都不想让一个简单的hello world程序就占用MB甚至10MB级别的空间（实测静态链接大小为800+KB，动态链接为20KB，空间占比40 : 1）。
glibc就是linux系统中常用的C语言库，其中包含我们常用的大多数函数，如printf, malloc等。它也负责程序的初始化、维护堆状态，以及程序推出后的部分事项等。
但是程序在运行时，是怎么找到glibc，以及其中函数的位置的呢？这依靠dynamic loader —— 动态链接器完成。dynamic loader通过动态链接库文件的符号表查询到对应函数和变量的地址，并返回给可执行文件，可执行文件就可以调用对应地址上的函数。glibc对应的动态链接器是ld，注意与GNU linker的ld不同，它也是以库的形式出现的(ld-version.so)。
传统方法 - patchelf 常见的修改ld和libc路径的方法是使用patchelf工具
--set-interpreter设置动态链接器路径--replace-needed替换所需so的路径，如glibc等 注意两个命令必须都执行后才能完全替换，若glibc版本与ld版本不匹配将产生运行时错误SEGFAULT
在拥有源码的情况下，编译后再通过命令替换libc库比较费力。但该方法在仅拥有libc库，并且目标文件libc版本与本机默认版本不一致时非常有效。
编译时修改libc 其实在编译中，就可以修改libc位置。通过设置环境变量和链接参数就可以做到这一点。
通过设置环境变量LD_LIBRARY_PATH增加默认库文件搜索路径，会优先匹配我们提供目录中的libc
export LD_LIBRARY_PATH=/your/libc/root/lib:$LD_LIBRARY_PATH 通过传递链接参数指定interpreter
-Wl,-dynamic-linker,/your/libc/root/lib/ld-2.31.so 注意上面是一整个参数，其中Wl表示将后面逗号分隔的参数传递给链接器（linker） 通过LDD可以查看链接结果
ldd test linux-vdso.so.1 (0x00007ffed4beb000) libc.so.6 =&gt; /your/libc/root/lib/libc.so.6 (0x00007f606e155000) /your/libc/root/lib/ld-2.31.so =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007f606e30f000) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd427d9a64236f3cbdabf547057a2fe9/" rel="bookmark">
			leaftjs实现全国温度降水气压风速等值面风场洋流效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现内容
数据爬取、地图marker聚合、鼠标移动显示pop，风场，洋流，温度等值面、降水等值面、气压等值面、风速等值面，洋流方向、洋流流速展示、风场方向、风场风速展示，后期扩展小时预报，分钟预报、7天预报。
实现效果
访问地址：无极低码https://wheart.cn
Leaflet.js是一个开源的JavaScript库，用于在Web上创建交互式地图。它具有以下特性和功能：
轻量级：Leaflet.js是一个轻量级的库，文件大小小，加载速度快。这使得它在Web应用程序中的使用变得更加高效。
易于使用：Leaflet.js提供了简单而直观的API，使得创建地图变得容易。它具有一致的语法和简单的配置选项，使得开发人员可以快速上手。
可定制性：Leaflet.js提供了丰富的配置选项和可扩展性。开发人员可以根据自己的需求自定义地图样式、图层、控件和交互功能。
兼容性：Leaflet.js兼容各种现代浏览器和移动设备。它使用HTML5和CSS3技术，可以在不同的平台上无缝运行。
支持多种地图提供商：Leaflet.js支持多种地图提供商，如OpenStreetMap、Mapbox、Google Maps等。开发人员可以根据自己的需求选择合适的地图提供商。
丰富的地图功能：Leaflet.js提供了丰富的地图功能，如缩放、平移、标记、路径绘制、地理编码等。开发人员可以根据自己的需求添加各种交互和操作。
插件生态系统：Leaflet.js拥有一个庞大的插件生态系统，开发人员可以根据自己的需求选择合适的插件来扩展地图功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/651296b8a2bb0596cebcaa3bd1298641/" rel="bookmark">
			Python 如何让程序重新启动（PyCharm测试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了完成python期末设计，我们小组三个人分工合作找到三份代码，其中我的另一项任务就是将这三份代码融合成一个程序，这看似简单的任务却被一件事困扰，那就是另外两个人的代码都是小游戏，如果玩完前一个人的游戏，那么再进入后者的游戏那就会报错。再经过半小时的调试，我发觉到，他们的游戏可能都用的是一个平台，这导致玩完一个游戏之后再进入另一个游戏时，前一个游戏设定还保留着，但又不能更改设定，所以最终报错。
所以解决上述问题最有效的方法就是结束一个游戏就重启一次程序，恢复初始化。这样就不会对进入下一次进入游戏创建设定造成影响，就是如此简单粗暴。
代码（函数）：
import os import sys def again(): # 重启程序函数 os.system("python text1.py")# 当前程序所在位置 sys.exit() # 结束当前程序 参考来源：python满足某个条件后重新启动程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93ecd7434fd6bc4c1957a3e76fe8ea38/" rel="bookmark">
			解决 VisualStudio中 C2001 常量中有换行符 的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VisualStudioz中出现 C2001 常量中有换行符 的错误。
这个问题的解决方案是: 处理项目熟悉高级里面的字符集使用Unicode之外，还需要更改代码文件编码，选择 UTF-8-BOM 编码即可， 也就是加上BOM头。例如 Notepad++这个小软件就能清楚的看到文件编码信息，也可以做相应的更改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d741bc0b78ccf525849216df34273da/" rel="bookmark">
			Cypress VS Selenium
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Majority of the automation testing tools like Selenium perform by executing from outside the browser and running remote commands through the network. Cypress has a different functionality altogether.
Cypress is sitting on the browser itself. In the background of Cypress, there exists the Node.js server. The Node server and the Cypress interacts constantly, adjusts and executes actions in support of each other.
Thus Cypress has access to both the front and back end of the application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d741bc0b78ccf525849216df34273da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26a5b2f5581bc24b394b5ba8751e30ad/" rel="bookmark">
			Postman报错处理：为开发者提供的详细解答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Postman 是一个流行的 API 测试工具，它可以帮助开发者和测试人员快速地创建和发送各种 HTTP 请求，并查看响应结果。但是，在使用 Postman 的过程中，有时候会遇到一些报错或异常情况，影响了正常的测试流程。本文将介绍一些 Postman 常见的报错与处理方法，希望能够对大家有所帮助。想要学习更多关于 Postman 的知识，可访问 Postman 中文文档。
Postman 一直转圈打不开的问题 这种问题一般是因为缓存过多，所以需要清理下缓存文件。具体操作如下：
关闭 Postman 应用程序打开 %appdata% 目录（在 Windows 系统中，在文件资源管理器中输入 %appdata% 并回车即可） !
删除 Postman 文件夹 重新打开 Postman 应用程序 其他常见的报错或异常情况 除了上述两种比较常见的问题外，还有一些其他可能出现的报错或异常情况，例如：
请求超时：可能是由于网络原因或服务器原因导致的，可以尝试更换网络环境或检查服务器状态。或者更改 Settings 中 ssl 开启状态，将其关闭。 请求被拦截：可能是由于请求头部缺少必要的参数或值导致的，可以检查请求头部是否符合 API 规范。 以上就是本文介绍的 Postman 一些常见报错与处理方法，希望对大家有所启发和参考。
知识扩展：更多 Postman 使用技巧 如何在 Postman 中配置和使用证书Postman 如何传递 Date 类型参数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f03817ad7c600f29444f4335bf158826/" rel="bookmark">
			flink cdc多种数据源安装、配置与验证（超详细总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2. 数据源安装与配置2.1 MySQL2.1.1 安装2.1.2 CDC 配置 2.2 Postgresql2.2.1 安装2.2.2 CDC 配置 2.3 Oracle2.3.1 安装2.3.2 CDC 配置 2.4 SQLServer2.4.1 安装2.4.2 CDC 配置 3. 验证3.1 Flink版本与CDC版本的对应关系3.2 下载相关包3.3 添加cdc jar 至lib目录3.4 验证 本文目录结构：
|___ 1. 前言
|___ 2. 数据源安装与配置
|______ 2.1 MySQL
|_________ 2.1.1 安装
|_________ 2.1.2 CDC 配置
|______ 2.2 Postgresql
|_________ 2.2.1 安装
|_________ 2.2.2 CDC 配置
|______ 2.3 Oracle
|_________2.3.1 安装
|_________2.3.2 CDC 配置
|_______2.4 SQLServer
|_________2.4.1 安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f03817ad7c600f29444f4335bf158826/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31176243bcfa572e03d9188fd0533d10/" rel="bookmark">
			三言两语说透关于 MySQL2 和 MySQL 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL是最流行的开源关系型数据库管理系统,拥有大量的使用者和广泛的应用场景。而MySQL2是MySQL官方团队推出的新一代MySQL驱动，用于取代老版的MySQL模块，提供更好的性能和更丰富的功能。本文将介绍MySQL2相较于MySQL有哪些优势以及具体的技术区别。
MySQL2的由来 随着Node.js的流行，基于Node.js连接MySQL数据库变得十分普遍。Node.js社区最初广泛使用的MySQL模块是基于libmysqlclient开发的，这是一个阻塞式的数据库驱动，性能和可靠性都存在一定问题。
为了改善这一情况，MySQL官方团队利用JavaScript开发了一个全新的驱动mysqljs，该驱动非阻塞式异步IO，并重新实现了协议解析器。在此基础上，他们开发了MySQL2模块，用于在Node.js中连接MySQL数据库。
MySQL2自2012年发布1.0版本以来，经过多年积累已经成为Node.js连接MySQL最流行的解决方案。它被广泛应用于Web应用、API服务、微服务等场景。
性能提升 相较于老版的MySQL模块，MySQL2在性能上有显著提升，主要体现在:
采用异步非阻塞IO，可以并发处理更多请求，避免阻塞事件循环。
优化的协议解析器，减少解析时间。
支持流式查询，可以边读取边处理数据，降低内存使用。
支持连接池，重用连接可以避免重复创建连接的开销。
编译过的二进制文件启动更快。
通过 above benchmarks 可以看出，在单查询场景下，MySQL2比MySQL快2.5倍；而在并发查询场景下，增速可以达到8倍以上。所以MySQL2可以明显提升Node.js应用程序的数据库访问速度。
Promise 和 async/await 支持 MySQL模块使用回调函数实现异步查询，而MySQL2使用了Promise来实现，可以利用async/await来编写异步代码:
// MySQL模块 connection.query('SELECT * FROM users', function(err, results) { // ... }); // MySQL2模块 async function getUsers() { const [rows] = await connection.query('SELECT * FROM users'); // ... } Promise接口使代码更简洁，支持then/catch错误处理，配合async/await可以像编写同步代码一样编写异步数据库逻辑，提高开发效率。
流式查询 MySQL2提供了流式查询功能，可以逐行获取查询结果，而不是把所有结果一次性加载到内存中。
这在处理大数据集时可以明显减少内存使用。流式获取结果的方法是使用query()而不是execute():
connection.query('SELECT * FROM users').stream() .on('data', (row) =&gt; { // 处理每一行 }) .on('end', () =&gt; { // 完成 }); 流接口使得结果集可以被推送式处理，而不是全部加载后再处理，非常适合处理大数据量的场景。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31176243bcfa572e03d9188fd0533d10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/016e0af7488c7426d3c3f3b508279381/" rel="bookmark">
			什么是OpenCV，它有什么作用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 OpenCV（全称为Open Source Computer Vision Library）是一个开源的计算机视觉库，由英特尔公司发起并开发，支持多种编程语言（如C++、Python、Java等），旨在为计算机视觉领域的研究、开发和应用提供一组通用的工具和算法。
什么是OpenCV，它有什么作用？
OpenCV可以用于处理数字图像和视频数据，其功能包括图像和视频的读取、写入、显示、变换、滤波、特征提取、目标检测、人脸识别、物体跟踪、相机标定、三维重建、机器学习等。
当今，计算机视觉在各种应用领域中都扮演着重要的角色，如自动驾驶、智能家居、医学影像、机器人视觉等，而OpenCV则作为计算机视觉领域的重要工具之一，为这些应用领域提供了丰富的功能和算法支持。
OpenCV最初由Intel开发，现在已经成为了一个开源项目，其源代码可以免费获取和使用。OpenCV提供了许多计算机视觉中常用的算法和工具，例如：
读取和保存图像和视频数据图像和视频的显示、缩放、剪切和旋转等操作直方图均衡化、图像滤波和形态学操作等图像处理技术特征提取和描述符匹配算法，如SIFT和SURF等目标检测和跟踪算法，如Haar Cascade和MeanShift等人脸检测和识别算法，如LBPH和FisherFace等相机标定和三维重建算法，如SfM和PnP等机器学习算法，如SVM、KNN和随机森林等 除了以上的功能，OpenCV还有一个重要的特点就是跨平台性，可以在Windows、Linux、macOS等操作系统上运行，并且支持多种编程语言，如C++、Python和Java等。
总之，OpenCV作为一个强大的计算机视觉库，在实现计算机视觉应用的过程中，可以节省开发者大量的时间和精力，提高开发效率和准确性，因此受到了广大开发者的欢迎和使用。
免费分享一些我整理的人工智能学习资料给大家，整理了很久，非常全面。包括一些人工智能基础入门视频+AI常用框架实战视频、计算机视觉、机器学习、图像识别、NLP、OpenCV、YOLO、pytorch、深度学习与神经网络等视频、课件源码、国内外知名精华资源、AI热门论文等。
下面是部分截图，点击文末名片关注我的公众号【AI技术星球】发送暗号 321 领取（一定要发 321） 学好人工智能，要多看书，多动手，多实践，要想提高自己的水平，一定要学会沉下心来慢慢的系统学习，最终才能有所收获。
点击下方名片，扫码关注公众号【AI技术星球】发送暗号 321 免费领取文中资料。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab41da0fa4d154a66257378111c5933e/" rel="bookmark">
			geojsonl转shp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import geopandas as gpd
import fiona
import json
from shapely.geometry import shape
定义GeoJSONL文件和输出SHP文件的路径 geojsonl_file = “path/to/input.geojsonl”
shp_file = “path/to/output.shp”
读取GeoJSONL文件并提取地理坐标信息 features = []
with open(geojsonl_file, “r”) as f:
for line in f:
feature = json.loads(line)
geometry = shape(feature[‘geometry’])
feature[‘geometry’] = geometry
features.append(feature)
将GeoJSONL转换为GeoDataFrame gdf = gpd.GeoDataFrame.from_features(features)
保存为SHP文件 gdf.to_file(shp_file, driver=“ESRI Shapefile”)
print(“转换完成！”)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63ca5e514591594d40c711dd1134d540/" rel="bookmark">
			Python案例｜使用Scikit-learn实现客户聚类模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚类是一种经典的无监督学习方法，无监督学习的目标是通过对无标记训练样本的学习，发掘和揭示数据集本身潜在的结构与规律，即不依赖于训练数据集的类标记信息。聚类试图将数据集划分为若干个互不相交的类簇，从而每个簇对应一个潜在的类别。
聚类算法体现了“物以类聚，人以群分”的思想。“物以类聚，人以群分”出自《战国策·齐策三》，用于比喻同类的东西常聚在一起，志同道合的人相聚成群。俗话说“近朱者赤，近墨者黑”，每一个人都或多或少地受周围的人的影响，所以我们要“见贤思齐，择善而从”，向优秀的人学习，树立积极进取、乐观向上的人生态度，从而形成正确的人生价值评判标准。
01、案例导入——客户聚类 通过对客户的消费行为进行聚类分析，将客户细分，从而企业可以针对不同客户提供不同的产品内容，采取不同的促销手段等。
本案例数据集来自UCI机器学习数据集Wholesale customers，该数据集记录了某批发经销商不同商品的年度销售情况。数据集包括440行记录和8个属性列，这些属性分别为客户渠道（channel）、客户所在区域（region）以及新鲜商品（fresh）、奶制品（milk）、零食（grocery）、冷冻商品（frozen）、洗涤剂和纸品（detergents_paper）、熟食（delicatessen）6种商品的年度销售。该数据集的部分数据如图1所示，详细介绍可以查看UCI机器学习数据集http://archive.ics.uci.edu/ml/datasets/Wholesale+customers。
■图1 Wholesale customers数据集的部分数据展示
本案例通过6种商品的销售数据对客户进行聚类，分析客户的消费行为，从而帮助经销商针对不同客户制订营销计划。
02、案例实现 使用某批发经销商的6种商品的年度销售数据集Wholesale customers，采用K-means聚类算法对其客户进行聚类，分析客户的消费行为。
（1） 导入库。代码如下。
import numpy as np import pandas as pd import matplotlib.pyplot as plt from sklearn.preprocessing import Normalizerfrom sklearn.cluster import KMeans from sklearn.metrics import silhouette score from collections import Counter （2） 导入数据，并对数据做预处理。为了方便展示字段名称，从数据表中读取数据时，将列名指定为中文。因为本案例主要通过6种商品的年度销售量分析客户行为，所以只使用数据表中的6列商品数据，即列号从2至7。代码如下。
dfO=pd.read csv("Wholesale customers data.csv"，header=0,names=渠道区域’，'新鲜商品’，'奶制品’，'零食’，'冷冻商品 ，"洗涤剂和纸品’，"熟食门)df=df0.iloc[:，2:8] print(df.info())#输出数据表的基本信息(维度、列名称、数据格式、所占空间等) 输出结果为:
&lt;class 'pandas .core .frame .DataFrame'&gt; RangeIndex: 440 entries，0 to 439 Data columns (total 6 columns): 新鲜商品 440 non-null int64 奶制品 440 non-null int64 零食 440 non-null int64 冷冻商品 440 non-null int64 洗涤剂和纸品 440 non-null int64 熟食 440 non-null int64 从数据表的基本信息可以看出，数据表没有缺失值。下面对数据表的异常值进行处理，然后对数据进行标准化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63ca5e514591594d40c711dd1134d540/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5069eeea3e24437b275f3f968c85c6b/" rel="bookmark">
			Mybatis-Plus详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Mybatis-Plus简介
（一）什么是Mybatis-Plus
（二）Mybatis-Plus的优势
（三）Mybatis-Plus的框架结构
二、SpringBoot整合Mybatis-Plus入门
（一）创建maven工程，添加依赖
（二）创建数据库表employee
（三）构建数据模型Employee
（四）配置application.yml
（五）编写SpringBoot启动类
（六）编写mapper接口
（七）启动服务测试结果
三、Lombok插件
（一）Lombok插件简介
（二）常用的Lombok注解介绍
（三）idea安装Lombok插件
（四）Lombok插件的使用
1、引入依赖
2、去除Employee类中的setter和getter方法
3、在Employee类上添加Lombok注解
四、CRUD
（一）BaseMapper接口方法介绍
（二）Insert方法
（三）@TableId注解
（四）@TableName注解
（五）@TableField注解
（六）插入数据获取主键值
（七）更新数据的通用方法
1、updateById方法
2、update(entity，wrapper)方法
（八）查询数据的通用方法
1、selectById方法
2、selectBatchIds方法
3、selectByMap方法
（九）删除数据方法
1、deleteById方法
2、deleteByMap方法
3、deletebatchIds方法
五、Mybatis-Plus条件构造器
（一）条件构造器介绍
（二）SelectOne方法
（三）SelectList方法
（四）SelectPage方法
（五）Update方法
（六）Delete方法
六、Mybatis-Plus的Service封装
（一）通用service简介
（二）通用service常用方法介绍
（三）通用service的案例
1、构建工程，添加依赖
2、构建service接口
3、构建service实现类
4、通用service测试
七、Mybatis-Plus代码生成器
（一）代码生成器介绍
（二）构建maven工程，引入依赖
（三）编写生成器代码
1、GlobalConfig全局配置编码
2、DataSourceConfig数据源配置编码
3、PackageConfig包名策略配置
4、StrategyConfig策略配置编码
5、执行
（四）执行生成器代码完成测试
一、Mybatis-Plus简介 （一）什么是Mybatis-Plus Mybatis-Plus是一个Mybatis（opens new window）的增强工具，在Mybatis的基础上只做增强不做改变，为简化开发。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5069eeea3e24437b275f3f968c85c6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbac62e7c8644bb590a1703435c1fd99/" rel="bookmark">
			java 接口的继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，接口之间也可以进行继承，这被称为接口的继承或接口的扩展。
接口的继承允许一个接口继承另一个接口的方法签名。通过继承，子接口可以获得父接口定义的方法签名，并且可以在子接口中添加新的方法签名。子接口继承了父接口的方法签名后，必须提供这些方法的具体实现。
接口的继承使用关键字extends，后面跟着要继承的父接口名称。一个接口可以继承多个接口，多个父接口之间使用逗号分隔。
下面是一个接口继承的示例：
interface Shape {void draw();}interface Circle extends Shape {double getRadius();}interface Colorable {void setColor(String color);}interface ColoredCircle extends Circle, Colorable {void rotate();} 在上面的示例中，接口Circle继承了接口Shape，表示Circle接口扩展了Shape接口的方法签名。接口ColoredCircle继承了接口Circle和Colorable，表示ColoredCircle接口扩展了这两个父接口的方法签名，并且可以在子接口中添加新的方法签名rotate()。
接口的继承使得接口之间可以建立层次结构，从而实现方法签名的复用和组合。通过继承，我们可以定义更具体和特定的接口，以满足不同的需求和功能。
2.3.3 经典面试题目：接口和抽象类的区别
面试时候可以尝试从语法层面回复这个问题：
接口和抽象类在语法上有一些区别，主要涉及以下几个方面：
声明方式：抽象类使用 abstract 关键字进行声明，使用 class 关键字定义类。接口使用 interface 关键字进行声明。
继承关系：抽象类通过使用 extends 关键字继承其他类或抽象类。一个类只能继承一个抽象类。接口通过使用 implements 关键字实现一个或多个接口。一个类可以实现多个接口。
方法实现：抽象类可以包含实现的方法和抽象的方法。接口只能包含抽象的方法，不包含具体的方法实现。所有的方法都隐式地被声明为抽象方法，不需要使用 abstract 关键字。实现接口的类必须提供方法的具体实现。Java 8 引入了接口中的静态方法和默认方法，使得接口具备了一定的实现能力。
2.3.4 经典面试题目：Java如何实现多继承的
在Java中，类是单继承的，即一个类只能继承自一个父类。然而，通过接口的使用，Java可以实现多继承的效果。类可以实现多个接口中的方法，从而获得多个接口定义的行为和功能。这种机制提供了灵活性和可扩展性，使得Java在面对多继承需求时能够更好地满足设计和开发的需要。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e345ad0a6c723a7e6ab60bc322c2e59f/" rel="bookmark">
			java 接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.1.2 什么是接口
接口在JAVA编程语言中是一个抽象类型，通常以interface来声明。
从面向对象编程的角度，可以将接口理解为对不同类型的事物的共同的行为特征的抽象。例如，鹰和飞机属于不同类型的事物，但是都有飞行的行为特征。
2.1.3 接口和抽象类
抽象类和接口都属于抽象的概念，它们有一些区别，可以从同类别和跨类别的角度来考虑：
同一种类别的公共行为和属性可以抽取到抽象类中。抽象类用于表示一种具有共性的类，可以包含实现的方法和具体的属性。比如，对于喜鹊和老鹰这两种鸟类，它们都属于鸟类的范畴，可以将它们共同的行为和属性抽象到一个抽象类（如Bird）中，以实现代码的重用和扩展。不同种类的公共行为可以抽取到接口中。接口用于定义一组相关的方法，用于表示某种能力或行为。比如，喜鹊、老鹰和飞机都具有起飞和着陆的功能，但它们并不属于同一种类，此时可以将与飞行相关的共同行为抽取到一个接口（如Flyable）中，不同类别的对象可以通过实现该接口来具备飞行的能力。 根据以上原则，对于喜鹊来说，它可以继承自抽象类Bird，以获取鸟类的共性属性和行为，并且还可以实现接口Flyable，以具备飞行的能力。
抽象类和接口的设计原则：
将所有子类共有的方法抽象化到父类中，可以使用抽象类。将部分子类中的公共方法抽象化到接口中，适用于不同类别但具有相似行为的对象。 通过合理地使用抽象类和接口，可以实现代码的复用和扩展，并且更好地表示对象之间的关系和行为。选择使用抽象类还是接口取决于具体的设计需求和对象之间的关系。
2.2.1 接口的语法
使用interface定义接口：
1、接口中只能定义常量和方法
可以省略常量的修饰词 public static final可以省略抽象方法修饰词 public abstract 2、接口不能实例化创建对象,
3、接口只能被继承，作为父类型被子类型实现
比如，定义飞行接口：
包含常量ID包含 3 个抽象方法 一个类可以实现多个接口：实现的接口直接用逗号分隔。
定义接口 Flyable 和类 Bird，并类 Plane实现接口Flyable，以及类 Eagle 继承Bird并实现Flyable；编写代码测试接口的用法。
案例示意代码如下所示：
package oop_04.interface01;/*** 飞行接口*/public interface Flyable {int ID = 1;/*** 起飞*/void takeOff();/*** 飞行*/void fly();/*** 着陆*/void land();}package oop_04.interface01;public class Plane implements Flyable{@Overridepublic void takeOff() {System.out.println("Plane takeOff...");}@Overridepublic void fly() {System.out.println("Plane fly...");}@Overridepublic void land() {System.out.println("Plane land...");}}package oop_04.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e345ad0a6c723a7e6ab60bc322c2e59f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d85d008779401eb49429dfea488c242c/" rel="bookmark">
			MySQL数据库笔记——进阶篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 存储引擎MySQL体系结构存储引擎简介InnoDB介绍MyISAMMemory 存储引擎的选择小结 索引概述索引结构概述BtreeB+TreeHash“严肃的思考题” 索引分类“严肃的思考题” 索引语法SQL性能分析查看执行频次慢查询日志show profilesexplian 索引使用规则验证索引效率最左前缀法则范围查询索引失效情况一索引失效情况二SQL提示覆盖索引前缀索引单列索引与联合索引的选择索引的设计原则总结 SQL优化插入数据主键优化order by优化group by优化limit优化count优化update优化小总结 视图介绍及基本语法检查选项更新和作用案例 存储过程介绍基本语法变量系统变量用户变量局部变量 if判断参数case炫酷的循环whilerepeatloop 游标条件处理程序 存储函数触发器介绍语法 about 视图、存储过程、触发器的小结锁介绍全局锁介绍特点 表级锁表锁元数据锁意向锁 行级锁介绍行锁间隙锁/临建锁 小结 InnoDB引擎逻辑存储结构架构内存架构磁盘架构后台线程 事务原理概述redo logundo log MVCC基本概念 实现原理undolog版本链 readview小总结 MySQL管理系统数据库常用工具mysqlmysqladminmysqlbinlogmysqlshowmysqldumpmysqlimport/source小总结 存储引擎 MySQL体系结构 连接层：
最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。
服务层：
第二层结构主要是完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。
引擎层
存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。
存储层：
主要是讲数据存储在文件系统之上，并完成与存储引擎的交互。
注意：索引是在存储引擎层实现的，也就意味着不同的存储引擎，索引的结构是不一样的
存储引擎控制的是数据库的数据该如何来存，如何来取，如何来组织，而具体的数据库数据最终是存储在磁盘当中的
存储引擎简介 what is 存储引擎？
do not know？
what is 引擎？
引擎就是发动机，发动机是一个机器的核心部分
而不同的引擎实际上是有不同的应用场景的（就像火箭的引擎不能放在汽车上）
引擎没有好坏，只要在合适的场景使用合适的引擎就可以了
存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所有存储引擎也可被称为表类型
没有指定的存储引擎，那就是默认的InnoDB
1、在创建表时，指定存储引擎
CREATE TABLE 表名( ... )ENGINE = INNODB [ COMMIT 表注释]; 2、查看当前数据库支持的存储引擎
SHOW ENGINES; memory：存储在内存当中的，通常用来做临时表及缓存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d85d008779401eb49429dfea488c242c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65693436c38a1a86e155a994823895e0/" rel="bookmark">
			python 使用streamlit实现的京东爬虫分析系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要的功能有 爬取 评论地址 爬取次数 爬取什么评论 爬取时间 保存名称 文件管理 爬取过程有问题或者查看数据 删除文件 重命名 下载文件 上传文件 处理 简单处理，去除换行符去除表情符号 删除列 可视化 饼图 聚合方法 count sum mean 标题 保存 词云图 对词云图参数修改 折线图 时间数量 文本感情处理 评论情感分析 情感分析可视化 关键词提取 主题个数 迭代次数 import streamlit as st import pymysql import pandas as pd import streamlit.components.v1 as components import mysql.connector from wordcloud import WordCloud from schedule import every, repeat, run_pending from PIL import Image import time import io import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65693436c38a1a86e155a994823895e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dff1efe37c737dde81d1b9ebed80e60e/" rel="bookmark">
			NLP-预训练模型-2020：Electra【预训练任务RTD（ReplacedTokenDetection）替代MLM；借鉴GAN；生成器&#43;判别器；判别器用于下游；比RoBert预训练速度大幅提升】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预训练模型(Pretrained model)：一般情况下预训练模型都是大型模型，具备复杂的网络结构，众多的参数量，以及在足够大的数据集下进行训练而产生的模型.
在NLP领域，预训练模型往往是语言模型，因为语言模型的训练是无监督的，可以获得大规模语料，同时语言模型又是许多典型NLP任务的基础，如机器翻译，文本生成，阅读理解等，常见的预训练模型有BERT, GPT, roBERTa, transformer-XL等.
一、Electra概述 在 2019 年 11 月份，NLP 大神 Manning 联合谷歌做的 ELECTRA 一经发布，迅速火爆整个 NLP 圈，其中 ELECTRA-small 模型参数量仅为 BERT-base 模型的 1/10，性能却依然能与 BERT、RoBERTa 等模型相媲美，得益于 ELECTRA 模型的巧妙构思 LOSS,在 2020 年 3 月份 Google 对代码做了开源。
BERT 的预训练的过程中使用了 Masked Language Model (MLM)，随机选择输入句子中 15% 的单词，然后其中的 80% 的单词用 [mask] 替换，10% 保持不变，10% 随机替换。然后 BERT 会对这 15% 的单词进行预测，还原回真实的单词。例如输入的句子是 “the artist sold the painting”，MLM 将其中的 painting 用 [mask] 替换，变成 “the artist sold the [mask]”，然后 BERT 要预测 [mask] 真实的单词是什么。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dff1efe37c737dde81d1b9ebed80e60e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0ff16c3aa23fbd8b11fe0cdc82680d7/" rel="bookmark">
			同名但是类型不同的bean的BUGorg.springframework.beans.factory.BeanDefinitionStoreException: Failed to parse con
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抛出的异常为BeanDefinitionStoreException
这个BUG会导致Springboot程序无法运行，报错的地址指向启动类
这个错误是因为在 Spring 应用程序上下文中，有两个具有相同名称的 bean，但它们的类型不一致，会导致冲突。在你的情况下，有两个不同的 类型的 bean 都使用了相同的名称 。
为了解决这个问题，你需要为其中一个或两个 bean 更改名称或更改其类型，以便它们没有相同的名称和类型。例如，你可以在一个 @Controller 类上使用另一个名称，或者在其中一个上使用 @Qualifier 注解来明确其 bean 名称。
具体来说，如果你想保留两个类型的 bean，但需要使用不同的名称来避免冲突，你可以将其中一个 bean 的名称更改为不同的名称：
如分别在两个同名的Controller类的@RestController注解后面加上(“xxxController”)
@RestController(“xxxController”)
以下是报错原文
2023-07-27 21:54:29.098 ERROR 20016 --- [ main] o.s.boot.SpringApplication : Application run failed org.springframework.beans.factory.BeanDefinitionStoreException: Failed to parse configuration class [com.sky.SkyApplication]; nested exception is org.springframework.context.annotation.ConflictingBeanDefinitionException: Annotation-specified bean name 'orderController' for bean class [com.sky.controller.user.OrderController] conflicts with existing, non-compatible bean definition of same name and class [com.sky.controller.admin.OrderController] at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0ff16c3aa23fbd8b11fe0cdc82680d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7081c9239d4800750db0f8bc9329256/" rel="bookmark">
			如何用 Nginx 代理 MySQL 连接，并限制可访问IP？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 我们的生产环境基本上都部署在云服务器上，例如应用服务器、MySQL服务器等。如果MySQL服务器直接暴露在公网，就会存在很大的风险，为了保证数据安全，MySQL服务器的端口是不对外开放的。
好巧不巧，线上业务遇到bug了，开发的小伙伴需要远程连接MySQL来查看数据，那应该怎么办呢？
我们可以通过Nginx代理（“跳板机”）来进行连接。
2.Nginx代理连接 要实现对连接的代理转发，我们需要一台服务器并安装Nginx，且与MySQL服务器处于一个内网之中，内网之间可以访问。
其次，我们需要用到ngx_stream_core_module模块，该模块不是默认构建的，我们需要在configure时添加--with-stream来进行构建。
添加过程可以参照【Nginx基本命令&amp;不停机版本升级】一文进行，我们这里不再赘述。
既然要用到ngx_stream_core_module模块，首当其冲，是看看其提供的指令，我们才知道怎么来进行配置。
1）stream 该指令定义了stream服务器。与http块平级，定义在main块中。
作用域：main
语法：stream {...}
示例：
stream { server { ...... } } 2）server 该指令定义一个虚拟主机，与http块中的server类似。我们可以在stream块中定义多个server块。
作用域：stream
语法：server {...}
stream { server { ...... } server { ...... } } 3）listen 该指令定义虚拟主机server要监听的socket的地址和端口。
作用域：server
语法：listen address:port;
示例：
listen 127.0.0.1:3306; listen *:3306; # 效果与listen *:3306一样 listen 3306; listen localhost:3306; 4）配置示例 MySQL服务器，端口3306（单机环境）
stream { server { listen 3306; proxy_pass 192.168.110.101:3306; } } MySQL服务器，端口3306（集群环境）
stream { upstream mysql_socket { server 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7081c9239d4800750db0f8bc9329256/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88008df77b26682e65ec8f02a225243a/" rel="bookmark">
			Nuxt3项目配置项整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、使用Sass(Scss)二、配置Pinia及持久化存储1. Pinia2. 使用插件为 Pinia Store 提供持久化存储3.使用demo 三、配置Vant及移动端适配1. Vant 42. Viewport 布局3. Rem 布局适配 四、使用head标签与SEO优化五、定义公共变量与环境变量1. 公共变量2. 环境变量3. 运行不同环境 六、Nuxt 开发工具（Nuxt DevTools）七、打包分析八、移除调试代码九、开启gzip或brotli压缩十、本地代理跨域总结 前言 这篇文章介绍一下 Nuxt 3 搭建项目时常用的配置项，包括一些移动端专属的配置项，Nuxt配置写在根目录的nuxt.config文件里，看了这篇文章，相信有助于大家对Vue项目的迁移，尝鲜Nuxt3。
Nuxt可以用一个nuxt.config文件轻松配置，该文件可以有js, ts or mjs扩展名。如果配置中有更改时，Nuxt将完全重新启动，所以无需手动重启服务或刷新浏览器，确实方便了不少。
一、使用Sass(Scss) npm i -D sass （可选）将 assets/css 目录里的scss文件引入全局使用（包含在每个页面中）。
export default defineNuxtConfig({ //... css: ['~/assets/css/app.scss', '~/assets/css/main.scss'], }); 二、配置Pinia及持久化存储 1. Pinia npm install pinia @pinia/nuxt export default defineNuxtConfig({ // ... modules: [ '@pinia/nuxt', { autoImports: [ // 自动引入 `defineStore()` 'defineStore', //（可选）自动引入 `defineStore()` 并重命名为 `definePiniaStore()` ['defineStore', 'definePiniaStore'], ], }, ], }) 更多配置参考官方文档：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88008df77b26682e65ec8f02a225243a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e16d3c6fd40592b17ac68284f8de843/" rel="bookmark">
			项目文档管理的基本指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目文档是一种关键的项目管理资源，它可以提供清晰度，保证参与项目的每个人都在同一页面上，从而确保项目按时、按预算完成。
本文将讨论项目文档的重要性、如何在项目中使用项目文档以及选择好合适的项目文档管理软件的技巧。
什么是项目文档？
项目文档是收集项目信息的数据和文档。项目经理通常会收集项目每个阶段的所有相关文档，包括与提案、目标、需求、设计、实施、预算、测试、部署和支持有关的文档。
项目文档的目的是将所有文档集中在一处，以便于参考和沟通。
项目文档的好处
收集项目的所有文档有助于提高工作效率，这一点不足为奇；当你需要参考预算或利益相关者要求查看项目建议书或设计时，不必浪费时间搜索文档或打乱团队的工作流程。以下是项目文档管理的一些好处：
1.改善沟通
项目文档化可确保项目保持透明，确保所有利益相关方都在同一起跑线上，从而更容易更新不同的里程碑、时间表和交付成果。
2.加强协作
通过记录所有文档，不同团队的成员都能获得相同的信息，协作变得更加容易。项目文档可确保每个人都为共同的目标而努力。
3.增强责任感
项目文档使你能够清楚地说明谁被分配了哪些任务，以及谁负责哪些可交付成果。当有人想询问有关项目的问题时，他们可以很容易地看到谁在负责相关方面。
项目文档的类型
根据项目的范围、类型和参与成员的不同，每个项目可能会有不同的文档。尽管如此，任何类型的项目都可以从使用项目文档中获益，因项目文档可以提供组织性和清晰度。让我们看看常用的项目文档有哪些：
● 项目章程：概述项目范围、目标、组成部分和利益相关者的文档，是指导完成阶段性目标的总依据。
● 工作说明书（SOW）： 双方之间的正式协议，概述项目的范围和目标，通常在与外部方合作时使用。
● 项目状态报告： 这些报告可帮助项目经理跟踪任务的最新进展，了解项目的进展情况。
● 风险管理计划： 项目中潜在风险和障碍的概述，以及如何减轻或应对这些风险和障碍的计划。
● 财务计划： 预算的细目，以及如何将预算分配给不同的任务和里程碑。
● 技术文档： 包含使用、设计或开发技术系统的详细信息以及功能和安全信息的文档。
如何创建项目文档
以下是项目文档流程的分步说明，可以让你正确地开始：
第 1 步：收集所有必要文档
文档可能分散在不同的平台上，如电子邮件、硬盘、Word 文档、PDF 文档、内部信息等。项目文档流程的第一步就是将所有这些文档集中到一个空间，比如像 8Manage PM这样的项目管理平台，让团队成员和其他利益相关者都可以轻松访问。
第 2 步：确保文档具有描述性
项目的每个阶段都需要不同的文档，确保项目从头到尾都有所需的文档。当然，随着项目的进展，会产生更多的文档，但一开始就准备好正确的文档将有助于任务按部就班地进行。
第 3 步：调整文档结构，方便搜索
现有文档可能充满不必要的信息或注释，在搜索特定数据时可能会分散注意力。为了节省团队时间，可以考虑在每份文档中添加内部链接、目录或子类别等功能。
第 4 步：协同工作
让团队参与到项目文档流程的早期阶段，帮助贡献或审查和改进重要文档。这样可以确保任何缺失、不清晰或过时的内容都能得到更新。
第 5 步：发布和维护文档
文档定稿后，在文档平台中添加标签和索引等功能，以便随时搜索。项目文档管理是一项持续性工作，需要随着项目的发展进行定期维护。请确保定期审查项目文档，以保证其相关性和最新性。
选择正确的项目文档管理软件
如果你正在参与项目的文档编制，则需要合适的工具来存储以及共享文档。那么选择项目文档软件时，请考虑以下因素：
● 有直观的导航，易于使用
● 项目经理应该能够设置访问控制
● 具有内置项目文档模板
● 提供即时、可靠的搜索功能
● 确保软件和模板均可根据需求定制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e16d3c6fd40592b17ac68284f8de843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa0660a11556e780a1fbcc1002b9d50b/" rel="bookmark">
			Date时间相关语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SimpleDateFormat格式化 Date date = new Date(); /*注意，dd需要小写，另外，需要注意的是，匹配符字母不能随意写*/ /*获取date*/ SimpleDateFormat sdf1 = new SimpleDateFormat("YYYY年MM月dd日 "); SimpleDateFormat sdf2 = new SimpleDateFormat("hh:mm:ss"); System.out.println(date); System.out.println(sdf1.format(date)); System.out.println(sdf2.format(date)); Date Date date = new Date(); //年份 System.out.println(date.getYear()+1900); //月份 System.out.println(date.getMonth()+1); //日期 System.out.println(date.getDate()); //星期数 System.out.println(date.getDay()); //时 System.out.println(date.getHours()); //分 System.out.println(date.getMinutes()); //秒 System.out.println(date.getSeconds()); //毫秒值时间戳 System.out.println(date.getTime()); Calendar Date date = new Date(); Calendar cal = Calendar.getInstance(); cal.setTime(date); //获得年数 int year = cal.get(Calendar.YEAR); //获得月数(比实际少一个月) int month = cal.get(Calendar.MONTH); //获得这一天在是这个年的第多少天 int day1 = cal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa0660a11556e780a1fbcc1002b9d50b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bb0367d02f49fb01e3716a2bacce9a1/" rel="bookmark">
			记一次docker-compose启动elk的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接贴错
ERROR: [1] bootstrap checks failed. You must address the points described in the following [1] lines before starting Elasticsearch. bootstrap check failure [1] of [1]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] ERROR: Elasticsearch did not exit normally - check the logs at /usr/share/elasticsearch/logs/es-cluster.log 错误描述是本地虚拟内存太少了，需要增加到262144
所以：
vim /etc/sysctl.conf 写入
vm.max_map_count=655360 保存退出
加载一下：
sysctl -p 重启一下：
docker-compose -f docker-elk.yml up -d 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/118531ccfb7a2acce5e62724b2ff07f0/" rel="bookmark">
			flink sqlserver cdc实时同步（含sqlserver安装配置等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 01 引言02 SQLServer安装03 开启SQLServer代理04 开启CDC功能05 Flink SQL06 验证 01 引言 官方文档：https://github.com/ververica/flink-cdc-connectors/blob/master/docs/content/connectors/sqlserver-cdc.md
如果要使用flink cdc做sqlserver的实时同步，需要满足以下条件：
需要安装SQLServer（需要支持CDC的功能，SQLServer 2008之后的版本都支持）；需要开启SQL Server代理；启用CDC功能。 ok，接下来开始讲解。
02 SQLServer安装 首先需要先安装SqlServer（使用的是2019版本），有兴趣的同学可以参考博主之前写的《Docker下安装SqlServer2019》。
主要就是两个步骤：
## 拉取最新镜像 docker pull mcr.microsoft.com/mssql/server:2019-latest ## 运行 SQL Server 容器（密码必须是8个字符，并包含字母、数字和特殊字符，如：abc@123456 ，下面映射主机端口为30027） docker run -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=abc@123456' -p 30027:1433 --name sql_server_2019 -d mcr.microsoft.com/mssql/server:2019-latest 03 开启SQLServer代理 首先使用root用户进入容器：
docker exec -it --user root sql_server_2019 bash 进入容器后，执行命令启用SqlServeragent：
/opt/mssql/bin/mssql-conf set sqlagent.enabled true 退出，并重启容器：
exit docker restart sql_server_2019 具体操作如下：
04 开启CDC功能 step1：创建’cdc_test’数据库，并使用连接工具登录该数据库，使用以下 SQL 命令启用 CDC 功能：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/118531ccfb7a2acce5e62724b2ff07f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac8b86f87a19dc36945f1690b3fca05/" rel="bookmark">
			树莓派 安装 ubuntu 笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的树莓派 树莓派4B 2GB
ubuntu server 系统
参照文章 树莓派4B家庭服务器搭建指南 第一期：刷Ubuntu Server 20.04：这个介绍了ubuntu的安装，主要重点是在后面的通过内网穿透，为家用树莓派提供了一个 frp.v2fy.com 域名，并可通过公网访问；通过配置 ssh, 可以在互联网任何地方，使用 frp.v2fy.com 的 6000 端口进行 SSH 远程登录。
树莓派安装Ubuntu server无屏幕开机自动连接WIFI：network-config 的配置。
树莓派4b安装Ubuntu和ROS的完整爬坑记录——2021年6月25日：详细的记录了4b安装ubuntu的过程，并且中间也会提到network-config 的配置。
树莓派3B装ubuntu server后开启wifi：提到了安装ubuntu后怎么启动wifi并加入到开机启动。
Ubuntu Server 20.04.4 在树莓派上的体验之连接网络和WIFI(WLAN0)：详细解释了ubuntu在4b中连接网络的各种操作。
成功方法 主要问题 按照网上的各种教程，tf卡啊、烧录啊都很简单，对我来说困扰很大的就是开机怎么无屏幕连接上树莓派。
解决方法 背景：首先因为在公司的网络里，我登录不了我自己的路由，所以不能看出哪个是树莓派或者都不能判断是树莓派有没有开机、连接上网络等情况。
尝试的方法：我按照网上文章在烧录的盘中设置了 network-config、wpa_supplicant.conf，这两种都没有开机启动wifi。
最终方法：
连接树莓派：最后是树莓派通过网线连接笔记本电脑，然后笔记本电脑打开“以太网”的共享，然后通过网络IP地址扫描工具Advanced IP Scanner发现树莓派。 这里要吐槽下，使用 Advanced IP Scanner 的时候显示的树莓派根本没有名称，不知道是因为安装了ubuntu还是其他原因。
启动无线：发现树莓派ip后通过ssh连接，然后根据Ubuntu Server 20.04.4 在树莓派上的体验之连接网络和WIFI(WLAN0)里面的各种方法启动无线、连接无线，主要是设置 wpa_supplicant.conf 然后启动无线。 注意我这里开启无线后并没有显示ip地址，需要使用 sudo dhclient wlan0 的方法分配一个无线ip
无线连接树莓派：最后就是将连接电脑的网线拔掉，通过无线的ip连接上树莓派，这样就完成了无屏幕连接树莓派的工作。 总结 对于有过折腾电脑经验的人来说，下载、烧录都不是问题，最终这个无线连接的问题特别是在没有屏幕连接的情况下还是很烦人的，第一次连接最困难。
2023-07-27 更新 连接树莓派详细方法 连接树莓派 树莓派开机笔记本打开网咯共享，路径：控制面板\网络和 Internet\网络和共享中心=》属性=》共享》点击运行其他网络用户…并选择以太网通过网线连接笔记本和树莓派（也是因为通过网线连接所以上面这步是选择以太网）通过网络IP地址扫描工具Advanced IP Scanner扫描ip地址（网上有设置成固定ip的，但是我嫌弃设置太麻烦所以就直接扫描了，所以每次重启这个ip都会变，需要再扫描一次），我这里会显示ubuntu的字样打开xshell，填写ip、用户名、密码（ubuntu初始的用户名和密码都是ubuntu） 开启无线 安装包 sudo apt install net-tools sudo apt install wireless-tools sudo apt install network-manager 查询机器ip和无线情况 ifconfig iwconfig 查询无线
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ac8b86f87a19dc36945f1690b3fca05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2641cc329ecbcc53726e7bcc7c89a6d3/" rel="bookmark">
			如何在MySQL中使用触发器？MySQL触发器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在MySQL中使用触发器？MySQL触发器详解
MySQL是一个常用的关系型数据库管理系统，支持触发器的使用。触发器是MySQL中的一种特殊的存储过程，它可以在特定的表上执行一系列的SQL语句，类似于事件驱动的编程模型。使用触发器可以实现复杂的业务逻辑，提高数据库的性能和可靠性。本文将详细介绍如何在MySQL中使用触发器。
一、创建触发器 在MySQL中，可以使用CREATE TRIGGER语句来创建触发器。CREATE TRIGGER语句的基本语法如下：
CREATE TRIGGER trigger_name trigger_time trigger_event ON table_name FOR EACH ROW trigger_body;
其中，trigger_name是触发器的名称；trigger_time是触发器的执行时间，可以是BEFORE或AFTER；trigger_event是触发器的事件，可以是INSERT、UPDATE或DELETE；table_name是触发器所在的表名；trigger_body是触发器的SQL语句。
例如，下面的触发器在employee表上创建了一个BEFORE INSERT的触发器，当有新的员工加入时，自动将入职时间设置为当前时间：
CREATE TRIGGER set_join_date BEFORE INSERT ON employee FOR EACH ROW
BEGIN
SET NEW.join_date = NOW();
END;
二、触发器的执行时间 在MySQL中，触发器可以在INSERT、UPDATE或DELETE事件之前或之后执行。触发器的执行时间可以是BEFORE或AFTER。
BEFORE触发器 BEFORE触发器在执行INSERT、UPDATE或DELETE操作之前执行，可以在数据库中实现一些数据的预处理和验证。
例如，下面的触发器在employee表上创建了一个BEFORE UPDATE的触发器，当员工的工资大于10000时，将其工资设置为10000：
CREATE TRIGGER limit_salary BEFORE UPDATE ON employee FOR EACH ROW
BEGIN
IF NEW.salary &gt; 10000 THEN
SET NEW.salary = 10000;
END IF;
END;
AFTER触发器 AFTER触发器在执行INSERT、UPDATE或DELETE操作之后执行，可以在数据库中实现一些数据的后处理和计算。
例如，下面的触发器在order表上创建了一个AFTER INSERT的触发器，当有新的订单加入时，自动更新产品的库存量：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2641cc329ecbcc53726e7bcc7c89a6d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b798212d2ef7424f44d8b224875afe/" rel="bookmark">
			Mybatis插件拦截器实现异常条件拦截检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 实际开发过程中可能会因为各种原因导致对数据库操作的代码缺少where条件，对于查询操作可能会导致全表扫描，对于更新操作可能会导致整个表的字段错误更新。大多数场景都不是符合我们的预期的。
所以做了这样一个插件(可以根据配置application.yml动态开启/关闭插件。可以检测where条件是否合法来决定打印error日志or抛出异常)
插件原理 Mybatis 预留了org.apache.ibatis.plugin.Interceptor 接口，通过实现该接口，可以对Mybatis的执行流程进行拦截，接口的定义如下：
public interface Interceptor { // 插件的核心逻辑在这个方法中 Object intercept(Invocation invocation) throws Throwable; // 使用当前的Interceptor创建代理，通常的实现都是 Plugin.wrap(target, this)，wrap方法内使用 jdk 创建动态代理对象； Object plugin(Object target); // 可以获取Mybatis配置文件中中设置的参数 void setProperties(Properties properties); } Mybatis插件可拦截的类为以下四个：
Executor
StatementHandler
ParameterHandler
ResultSetHandler
这些类的代理流程
在执行query方法之前都可以获取到我们要执行的原始sql，然后进行条件检测判断。所以我们可以织入我们代码的拦截类可以为 Executor、StatementHandler、ParameterHandler。这里选择了Executor。
mybatis的详细执行流程和动态代理实现sql代理等流程戳这里：编码技巧——数据加密（二）Mybatis拦截器
插件实现 插件代码： common项目：
自定义条件检测配置类(把配置文件中的mybatis配置注入到该类中，实现配置和拦截器代码分离的作用。方便各个服务灵活接入)
/** * mybatis自定义条件检测配置类 * * @see MybatisConditionDetectionInterceptor * */ @Data @AllArgsConstructor @NoArgsConstructor @Component @ConfigurationProperties(prefix = "mybatis.condition.detection") @ConditionalOnProperty(prefix = "mybatis.condition.detection", name = "enable", havingValue = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25b798212d2ef7424f44d8b224875afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a74e5fcfd50194fa0835bb1833fb670b/" rel="bookmark">
			【Java编码】使用java代码通过URL将图片下载保存到本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用java代码通过URL将图片下载保存到本地 一、实现思路可以使用Java中的URL和URLConnection类来实现 1.1、以下是一个基本的Java代码示例： String imageUrl = "http://example.com/image.jpg"; // 替换成你需要下载的图片URL String savePath = "/path/to/your/save/directory/image.jpg"; // 替换成你需要保存图片的本地目录 try { // 打开连接 URL url = new URL(imageUrl); URLConnection connection = url.openConnection(); // 设置请求超时为5秒 connection.setConnectTimeout(5 * 1000); // 读取数据流并保存到本地 InputStream input = connection.getInputStream(); byte[] data = new byte[1024]; int len; FileOutputStream output = new FileOutputStream(savePath); while ((len = input.read(data)) != -1) { output.write(data, 0, len); } output.close(); input.close(); System.out.println("图片保存成功：" + savePath); } catch (IOException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a74e5fcfd50194fa0835bb1833fb670b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff48284ac634bfba10be42f5e7f1e94/" rel="bookmark">
			（二）docker无法访问github但可以访问gitee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 错误信息： gnutls_handshake() failed: The TLS connection was non-properly terminated.2. 解决方法其他：docker run/exec/attach三者的区别 1. 错误信息： gnutls_handshake() failed: The TLS connection was non-properly terminated. 配docker的时候，遇到一个很奇怪的问题，gitee上的仓库就可以拉下来，但是github上的就拉不下来
根据问答：
docker run 命令加上–network=host 指定的端口就不生效
所以这里由于我启动容器的时候是以指定端口的方式，所以容器里的网络并不能访问github（没有共享主机的网络）
另外根据问题：
Docker container unable to clone from github.com
可以知道，确实问题就出在启动镜像时的端口/网络设置上。
2. 解决方法 其实就是要在docker run的时候加上--net=host这个参数。但是由于这个参数只能在run的时候添加，所以。。。就比较尴尬
🥳灵机一动
由于我当时创建容器的时候，指定了容器和本机映射的目录
docker run -it -d --gpus "device=3" --ipc=host -p 10035:22 -v /ws/huangshan:/ws --name "OCR" paddlepaddle/paddle:2.0.1-gpu-cuda11.0-cudnn8 bash -c "/etc/rc.local; /bin/bash" 所以完全可以
在本机那个映射的目录下使用git clone，这样本机clone出的内容（目录/文件）就会自动关联到容器中，Good！ 类似这样，哈哈哈！
其他：docker run/exec/attach三者的区别 关于docker run和docker exec的区别，参考网上资料
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ff48284ac634bfba10be42f5e7f1e94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4df6024099eb10ba271894af3c287c60/" rel="bookmark">
			移动开发之Wifi列表获取功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、场景
业务需要通过App给设备配置无线网络连接，所以需要App获取附近的WiFi列表，并进行网络连接验证。
二、安卓端实现
1、阅读谷歌官网文档，关于Wifi 接口使用
https://developer.android.com/guide/topics/connectivity/wifi-scan?hl=zh-cn
文档的使用流程说的相当明了清晰，注册--扫描--获取。
但是其提到了关于Android 10 以上版本的特别说明， 而且看到代码中：
标明接口过期，但是实际调试使用，发现在10以上版本中也是能正常接收到广播获取扫描结果的。只要申请号对应的权限：
&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;uses-permission android:name="android.permission.CHANGE_NETWORK_STATE" /&gt; 权限当然也需要动态申请：
ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION},WIFI_REQUEST_FOR_PERMISSION); Android13 权限额外需求：
https://developer.android.com/guide/topics/connectivity/wifi-permissions
NEARBY_WIFI_DEVICES 这个在实际调试过程中发现，加了和没加都能够获取到wifi列表数据。
另外需要注意的是，定位权限是一回事，手机系统有没有打开定义又是另外一回事，所以在使用此功能前要先判断定位开关是否打开：
// 通过GPS卫星定位，定位级别可以精确到街（通过24颗卫星定位，在室外和空旷的地方定位准确、速度快） boolean gps = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER); // 通过WLAN或移动网络(3G/2G)确定的位置（也称作AGPS，辅助GPS定位。主要用于在室内或遮盖物（建筑群或茂密的深林等）密集的地方定位） boolean network = locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER); if (gps || network) { return true; } 再者就是WLAN 的开关有没有打开，安卓10以下的可以直接通过代码设置，10以上的需要跳转到设置界面，引导用户打开：
int wifiState = wifiManager.getWifiState(); if (WifiManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4df6024099eb10ba271894af3c287c60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eeb546a2c834674827b0b7cf882ceaf/" rel="bookmark">
			2024百度校招内推码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024百度校招内推码：IV9M0R，供大家使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16c9ec81f8bdd61e6f226beb4642e847/" rel="bookmark">
			flink oracle cdc实时同步（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 01 引言02 前提条件03 配置3.1 启用日志归档3.2 用户赋权3.3 表或数据库上启用增量日志记录（supplemental log）3.3.1 Oracle 逻辑结构3.3.2 创建表3.3.3 启用增量日志 04 flink sql05 其它问题06 文末 01 引言 官方文档：https://github.com/ververica/flink-cdc-connectors/blob/release-master/docs/content/connectors/oracle-cdc.md
本文参照官方文档来记录Oracle CDC 的配置。
在本文开始前，需要先安装Oracle，有兴趣的同学可以参考博主之前写的《docker下安装oracle11g（一次安装成功）》。
02 前提条件 如果要做oracle的实时同步，Oracle数据库配置必须满足如下：
Oracle数据库启用日志归档；定义具有适当权限的Oracle用户；被捕获的表或数据库上必须启用增量日志记录； 在官网的安装教程中，可以看到有两种数据库类型的配置，分别是：
类型描述版本独立的数据库架构（Non-CDB database）是传统的独立数据库架构，每个数据库实例包含所有的对象和数据Oracle 11g以及之前的版本中使用多租户数据库架构（CDB database）多租户架构的数据库，包含一个根容器和多个子容器（PDB），每个PDB可以看作是一个独立的数据库Oracle 12c开始 因为 之前安装 的是Oracle11g，所以本文以独立的数据库架构（Non-CDB database）的配置来讲解。
03 配置 注意：以下执行的条件是基于之前安装好的oracle环境来执行的，详情参阅：《docker下安装oracle11g（一次安装成功）》。
3.1 启用日志归档 Step1：进入容器：
docker exec -it oracle_11g bash Step2：以DBA的权限登录数据库：
sqlplus /nolog CONNECT sys/system AS SYSDBA Step3：启用日志归档：
-- 设置数据库恢复文件目标大小为10G alter system set db_recovery_file_dest_size = 10G; -- 设置数据库恢复文件目标路径 alter system set db_recovery_file_dest = '/home/oracle/app/oracle/product/11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16c9ec81f8bdd61e6f226beb4642e847/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b62efd24aa7704d47383623c05c2b162/" rel="bookmark">
			vue组件缓存之keep-alive正确使用姿势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来看一个项目中的需求 作为苦逼的前端开发者，我们无时无刻都要面对产品经理提的各种需求, 比如下图这个场景
场景：
从首页的点击导航进入列表页,
列表页点击列表进入 该 数据详情页
从详情页返回，希望列表页缓存，不重新渲染数据，这样会提高用户体验。
分析一下 这样需求，如果是小程序的话，默认列表页就会缓存，因为小程序的运行环境是微信客户端，当我们打开一个页面会新建一个webview，
所有列表页和详情页是两个webview，当我们进入详情页，列表页webview，只是会在详情页webview下面，不会销毁。
以下是小程序运行环境：我们可以看到每个页面都有一个webview
但是但是，我们的项目是用vue开发的webapp,多个组件共用一个窗口，当我们切换路由时，切出路由组件会销毁，所有列表页进入详情页列表页会销毁，重新回到列表页，列表页组件会重新加载。
解决方案 睡服提需求的人，改个简单的需求 emm... ,看了看镜子中的自己，估计这辈子没办法从脸上得到任何的便利了,老老实实换个方案吧。
keep-alive keep-alive是Vue提供的一个抽象组件，主要用于保留组件状态或避免重新渲染。
&lt;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们。
和&lt;transition&gt; 相似， &lt;keep-alive&gt; 是一个抽象组件，它自身不会渲染一个DOM元素，也不会出现在父组件链中。
但是 keep-alive 会把其包裹的所有组件都缓存起来。
em...怎么办呢，我们只是需要让列表页缓存啊.
分析一下 我们可以把需求拆分为2步
(1) 把需要缓存和不需要缓存的组件区分开，在组件的路由配置的元信息，meta中定义哪些需要缓存哪些不需要缓存
具体代码如下
1，定义两个出口 router-view
&lt;keep-alive&gt; &lt;!-- 需要缓存的视图组件 --&gt; &lt;router-view v-if="$route.meta.keepAlive"&gt; &lt;/router-view&gt; &lt;/keep-alive&gt; ​ &lt;!-- 不需要缓存的视图组件 --&gt; &lt;router-view v-if="!$route.meta.keepAlive"&gt; &lt;/router-view&gt; 2，在router配置中定义哪些需要缓存哪些不需要缓存
new Router({ routes: [ { path: '/', name: 'index', component: () =&gt; import('./views/keep-alive/index.vue') }, { path: '/list', name: 'list', component: () =&gt; import('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b62efd24aa7704d47383623c05c2b162/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6ccb92a19b5ab93dacbc53cd3f55280/" rel="bookmark">
			@click.native和@click的区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@click 是 Vue.js 框架提供的模板语法，用于绑定 DOM 元素的 click 事件，等价于 v-on:click。它只能监听 Vue 组件内部元素的 click 事件，并且会阻止默认行为和事件冒泡。
而 @click.native 则是 Vue.js 框架提供的修饰符之一，用于监听 DOM 元素的原生 click 事件，不会对默认行为和事件冒泡进行任何处理。相比于 @click，它可以监听任何 DOM 元素的 click 事件，包括组件内嵌套的子组件和子元素。
举个例子，如果你想监听一个来自于 slot 内的元素的 click 事件，可以使用 @click.native 来绑定该事件。
使用@click点击事件不生效、使用@click.native才生效是为啥？
在引入 better-scroll 组件中使用 @click 事件会失效，需要在 better-scroll 的配置项中设置 click: true，才能使 @click 事件生效。这是因为 better-scroll 会阻止默认的浏览器事件，并将其转化为自定义的滚动事件，从而导致原生的 click 事件无法响应。
而 @click.native 可以监听 DOM 元素的原生 click 事件，不会经过 better-scroll 的处理，因此能够正常响应用户的点击操作。
综上所述，如果在使用 better-scroll 或其他可能影响原生 click 事件响应的组件时，建议使用 @click.native 来绑定 click 事件，从而避免事件失效的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/430c55475cccbee22e874a327bb15820/" rel="bookmark">
			【基于Spark的电影推荐系统】环境准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概览 本科毕设做过电影推荐系统，但当时的推荐算法只有一个，现在已经忘记大部分了，当时也没有记录，因此写这个博客重新来记录一下。此外，技术栈由于快秋招原因来不及做过多的部分，因此只实现简单的功能，在此不做搜索引擎部分。
技术栈：Vue+Element-ui、SpringBoot、Spark、Redis、Mongodb、Flume、Kafka、Azkaban
1 云服务器选择 由于电脑比较老，开太多应用实在太卡（之前做毕设的体会），因此选用了云服务器。之前使用过云服务器，但由于大数据需要的内存比较大些，实在没钱。发现轻量服务器貌似便宜一点，因此使用腾讯的轻量服务器4cpu+16GB来开发。 2 大数据环境搭建 时间原因+服务器配置原因，在此我只用买了一台来进行开发，这是出于开发的简单，旦可能这样做一台机器上压力比较大。由于配置实在太费时间（之前每次配置都心累），因此直接使用docker拉取镜像操作系统：centos7.6 2.1 docker安装 参考博客docker安装 2.2 使用docker-compose快速部署spark环境 安装docker-compose见docker-compose安装。 我使用curl方式安装，若遇见curl: (35) Encountered end of file，则原因可能是云服务器没有开放443端口（解决方案：443端口开放） 快速部署Spark环境
（1）新建test文件夹并进入，依次执行下列命令 wget https://raw.githubusercontent.com/zq2599/blog_demos/master/sparkdockercomposefiles/docker-compose.yml wget https://raw.githubusercontent.com/zq2599/blog_demos/master/sparkdockercomposefiles/hadoop.env # 在test文件下执行该命令，该命令需要等待一会 docker-compose up -d （2）使用docker-compose ps查看当前的镜像
（3）使用docker-compose ps查看当前运行的情况
这里我出现两个exit，查询日志(docker-compose logs)检查错误原因 # 发现错误 could only be replicated to 0 nodes instead of minReplication (=1). There are 1 datanode(s) running and no node(s) are excluded in this operation. 可能是因为端口原因，设置云服务器全部端口开放（有风险但先暂时这样做），重新启动docker-compose up -d，成功
（4）查看HDFS（xxxx:50070）
(5)查看Spark界面（xxxx:8080）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/430c55475cccbee22e874a327bb15820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/783c561022bba80d1aa599e0143450ea/" rel="bookmark">
			SpringBoot应用常用的工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot应用常用的工具类 一、统一返回结果类二、统一异常处理类1. 全局异常类2. 自定义异常类 三、常用的配置类1. MybatisPlus配置类2. Redis配置类3. Swagger2配置类 一、统一返回结果类 在前后端分离系统中，统一返回结果类的作用更为突出，其主要作用包括以下几个方面：
a.格式统一：在前后端分离系统中，前端通过Ajax请求来获取后端数据，而每个请求都需要获取后端数据，并且数据格式需要保持一致。通过使用统一返回结果类，可以规范前后端数据传输格式和约定，减少数据解析和格式判断的开销。
b.错误处理：前后端分离系统中，错误处理非常重要，错误提示信息需要明确，便于开发人员识别和修复。统一返回结果类可以将错误信息封装在同一个结构体中，有利于前端进行错误提示和用户交互。
c.数据传输效率高：在前后端分离系统中，由于前端需要通过Ajax请求来向后台请求数据，每个请求都被视为一个独立的HTTP请求，可以使用同一个返回结果类降低请求的传输开销，以提高应用程序的效率和响应速度。
d.易于扩展：在前后端分离系统中，数据传输需要的格式可能随着需求变更而改变。通过使用统一返回结果类，可以方便地修改结构体，来适应新需求和扩展。
综合来看，利用统一返回结果类，可以规范前后端数据传输格式和约定，减少数据解析和错误处理的开销，提高数据传输效率和用户体验。
下面有一个结果类的模板：
@Data public class Result&lt;T&gt; { // 状态码 private Integer code; // 信息 private String message; // 数据 private T data; // 构造私有化 private Result() { } // 设置数据,返回对象的方法 public static&lt;T&gt; Result&lt;T&gt; build(T data,Integer code,String message) { // 创建Resullt对象，设置值，返回对象 Result&lt;T&gt; result = new Result&lt;&gt;(); // 判断返回结果中是否需要数据 if(data != null) { // 设置数据到result对象 result.setData(data); } // 设置其他值 result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/783c561022bba80d1aa599e0143450ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f1c05c0fae3dbdce85ab1c3ceb2492b/" rel="bookmark">
			Python数据处理入门教程（非常详细）从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本教程内容旨在帮助没有基础的同学快速掌握 numpy 的常用功能，保证日常绝大多数场景的使用。可作为机器学习或深度学习的先修课程，也可作为快速备查手册。
值得一提的是，深度学习的各大框架很多 API 和 numpy 也是一脉相承的哦，可以说 numpy 玩儿熟了，几个深度学习框架的不少 API 也同时学会了。本文是教程的「第一部分」，从实际的代码应用出发，讲解了Numpy创建到统计的操作。
开源项目地址：https://github.com/datawhalechina/powerful-numpy
教程原则如下：
· 偏实用高频 API
· 展示实际用法
· 简单直接
使用说明：内容中⭐（1-5个）表示重要程度，越多越重要；⚠️ 表示需要特别注意的
提示：使用过程中无须过多关注 API 各种参数细节，教程提供的用法足以应付绝大部分场景，更深入的可自行根据需要探索或学习后续的教程。
下面正式开始讲解。
# 导入 library import numpy as np # 画图工具 import matplotlib.pyplot as plt 创建和生成 本节主要介绍 array 的创建和生成。为什么会把这个放在最前面呢？主要有以下两个方面原因：
首先，在实际工作过程中，我们时不时需要验证或查看 array 相关的 API 或互操作。同时，有时候在使用 sklearn，matplotlib，PyTorch，Tensorflow 等工具时也需要一些简单的数据进行实验。
所以，先学会如何快速拿到一个 array 是有很多益处的。本节我们主要介绍以下几种常用的创建方式：
使用列表或元组
使用 arange
使用 linspace/logspace
使用 ones/zeros
使用 random
从文件读取
其中，最常用的一般是 linspace/logspace 和 random，前者常常用在画坐标轴上，后者则用于生成「模拟数据」。举例来说，当我们需要画一个函数的图像时，X 往往使用 linspace 生成，然后使用函数公式求得 Y，再 plot；当我们需要构造一些输入（比如 X）或中间输入（比如 Embedding、hidden state）时，random 会异常方便。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f1c05c0fae3dbdce85ab1c3ceb2492b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/152e9fbe63062e16be6d3601a2a42adb/" rel="bookmark">
			linux的C/C&#43;&#43;线程池（VS2019开发）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、准备工作二、C语言threadpool实现三、C++ 11标准实现 代码看视频敲的，非原创 一、准备工作 创建项目
连接linux虚拟机
启动测试：VS2019运行Linux程序报错：无法启动gdb。系统中缺少gdb。sudo yum install -y gdb
线程池的组成主要分为3个部分，这三部分配合工作就可以得到一个完整的线程池：
任务队列，存储需要处理的任务，由工作的线程来处理这些任务
通过线程池提供的API函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除
已处理的任务会被从任务队列中删除
线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程工作的线程（任务队列任务的消费者） ，N个
线程池中维护了一定数量的工作线程, 他们的作用是是不停的读任务队列, 从里边取出任务并处理
工作的线程相当于是任务队列的消费者角色，
如果任务队列为空, 工作的线程将会被阻塞 (使用条件变量/信号量阻塞)
如果阻塞之后有了新的任务, 由生产者将阻塞解除, 工作线程开始工作管理者线程（不处理任务队列中的任务），1个
它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测
当任务过多的时候, 可以适当的创建一些新的工作线程
当任务过少的时候, 可以适当的销毁一些工作的线程 二、C语言threadpool实现 threadpool.h
#pragma once #ifndef _THREADPOOL_H #define _THREADPOOL_H #include &lt;pthread.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; // 任务结构体 typedef struct Task { void (*function)(void* arg); void* arg; }Task; // 线程池结构体 typedef struct ThreadPool { // 任务队列 Task* taskQ; int queueCapacity; // 容量 int queueSize; // 当前任务个数 int queueFront; // 队头 -&gt; 取数据 int queueRear; // 队尾 -&gt; 放数据 pthread_t managerID; // 管理者线程ID pthread_t* threadIDs; // 工作的线程ID int minNum; // 最小线程数量 int maxNum; // 最大线程数量 int busyNum; // 忙的线程的个数 int liveNum; // 存活的线程的个数 int exitNum; // 要销毁的线程个数 pthread_mutex_t mutexPool; // 锁整个的线程池 pthread_mutex_t mutexBusy; // 锁busyNum变量 pthread_cond_t notFull; // 任务队列是不是满了 pthread_cond_t notEmpty; // 任务队列是不是空了 int shutdown; // 是不是要销毁线程池, 销毁为1, 不销毁为0 }ThreadPool; // 创建线程池并初始化 ThreadPool* threadPoolCreate(int min, int max, int queueSize); // 销毁线程池 int threadPoolDestroy(ThreadPool* pool); // 给线程池添加任务 void threadPoolAdd(ThreadPool* pool, void(*func)(void*), void* arg); // 获取线程池中工作的线程的个数 int threadPoolBusyNum(ThreadPool* pool); // 获取线程池中活着的线程的个数 int threadPoolAliveNum(ThreadPool* pool); // // 工作的线程(消费者线程)任务函数 void* worker(void* arg); // 管理者线程任务函数 void* manager(void* arg); // 单个线程退出 void threadExit(ThreadPool* pool); #endif // _THREADPOOL_H threadpool.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/152e9fbe63062e16be6d3601a2a42adb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d3b8045137579ee6f0d8115bd997c99/" rel="bookmark">
			uniapp 实现多语言切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先在项目安装 npm install vue-i18n
在根目录新建common/locales/zh.js和common/locales/en.js
//zh.js export default { login: { title:'登录', register: '注册' } } //en.js export default { login: { title:'Login', register: 'Register' } } 在main.js引入
// 引入并使用vue-i18n import VueI18n from 'vue-i18n' Vue.use(VueI18n) // 引入语言包，注意路径 import Chinese from '@/common/locales/zh.js'; //简体中文 import English from '@/common/locales/en.js'; //英文 // 构造i18n对象 const i18n = new VueI18n({ // 默认语言，这里的local属性，对应message中的cn、en属性 locale: uni.getStorageSync('locale') || 'zh_CN', // 引入语言文件 messages: { // 这里的属性名是任意的，您也可以把zh设置为cn等，只是后续切换语言时 // 要标识这里的语言属性，如：this.$i18n.locale = zh|en|cn|xxx 'zh_CN': Chinese, 'en_US': English } }) Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d3b8045137579ee6f0d8115bd997c99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e57c07f04f49f1e6b80ccf4b07fcb1/" rel="bookmark">
			LSTM/GRU详细代码解析&#43;完整代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LSTM和GRU目前被广泛的应用在各种预测场景中，并与卷积神经网络CNN或者图神经网络GCN这里等相结合，对数据的结构特征和时序特征进行提取，从而预测下一时刻的数据。在这里整理一下详细的LSTM/GRU的代码，并基于heatmap热力图实现对结果的展示。
一、GRU GRU的公式如下图所示：
其代码部分：
class GRU(torch.nn.Module): def __init__(self, hidden_size, output_size, num_layers): super().__init__() self.input_size = 1 self.hidden_size = hidden_size self.num_layers = num_layers self.output_size = output_size self.num_directions = 1 self.gru = torch.nn.GRU(self.input_size, self.hidden_size, self.num_layers, batch_first=True) self.linear = torch.nn.Linear(self.hidden_size, self.output_size) def forward(self, input_seq): # input(batch_size, seq_len, input_size) batch_size, seq_len = input_seq.shape[0], input_seq.shape[1] h_0 = torch.randn(self.num_directions * self.num_layers, batch_size, self.hidden_size).to(device) # output(batch_size, seq_len, num_directions * hidden_size) output, _ = self.gru(input_seq, (h_0)) pred = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e57c07f04f49f1e6b80ccf4b07fcb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c3cb1cbd62ed5b22f9d27dd5ec0687/" rel="bookmark">
			AI语音合成 VITS Fast Fine-tuning，半小时合成专属模型，部署训练使用讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 项目名：VITS-fast-fine-tuning （VITS 快速微调）
项目地址：https://github.com/Plachtaa/VITS-fast-fine-tuning
支持语言：中、日、英
官方简介：
这个代码库会指导你如何将自定义角色（甚至你自己），加入预训练的VITS模型中，在1小时内的微调使模型具备如下功能：
在 模型所包含的任意两个角色 之间进行声线转换
以 你加入的角色声线 进行中日英三语 文本到语音合成。
本项目使用的底模涵盖常见二次元男/女配音声线（来自原神数据集）以及现实世界常见男/女声线（来自VCTK数据集），支持中日英三语，保证能够在微调时快速适应新的声线。
数据集 干声数据收集 干声，一般指录音以后未经过任何空间性质或的后期处理和加工的纯人声。
为了保证最好的合成效果，数据集越干净越好。当然也不是必须使用干声数据，也可以使用从视频中分离的人声来进行训练，效果也还可以。
录制可以直接使用手机进行录音，如果电脑有效果较好的麦克风，也可以使用麦克风进行录制（如果可以自定义录制音频格式，建议选择wav）。
如果进行视频人声分离，我这给大家推荐几个分离相关的网站和项目。
vocalremover：https://vocalremover.org/zh/
tme_studio：https://y.qq.com/tme_studio/index.html#/editor
UVR5：https://github.com/Anjok07/ultimatevocalremovergui
demucs：https://github.com/facebookresearch/demucs
音频转码 将音频转码为wav格式，码率等配置保持原始音频质量即可。可以使用格式工厂、ShanaEncoder等转码软件进行音频转码。
音频分割 将我们的音频数据切分成多个5-15s的小段，这个范围仅供参考。需要注意的是，如果音频时长过长，在训练过程中会占用更多的显存，所以为了降低显存和显卡负担，建议大家切分成小段。
那么切分方式同样也多种多样，可以使用视频剪辑软件、音频编辑软件、格式转换软件、第三方软件等。
我这边就以windows用户为例，给大家推荐一款开源的音频批量自动分割软件slicer-gui（源自b站），官方下载地址：https://github.com/flutydeer/audio-slicer/releases/download/v1.1.0/slicer-gui-windows-v1.1.0.zip
下载完成，解压后打开，运行slicer-gui.exe
选择待处理的音频文件，设置需要切分的音频参数，选择输出路径，点击start即可。默认配置运行也可以，视情况可以微调参数。(需要注意，软件需要
完成以上分割后，我们将我们分割好的音频文件，存入一个文件夹中，需要注意的是，此文件夹的命名就是我们训练时的说话人配置，所以需要慎重取名，并不要和其他说话人重复。最后将存放音频的文件夹再存入一个名为：custom_character_voice 的文件夹中，最后打包压缩包即可。需要注意，此文件夹在源码中是默认的配置，所以建议大家保持一致，可以避免不必要的麻烦。那么最终的文件目录结构如下：
custom_character_voice ├───speaker0 │ ├───1.wav │ ├───... │ └───2.wav └───speaker1 ├───1.wav ├───... └───2.wav 环境搭建 服务器选购 本文中，以AutoDL平台为例，如果您的个人计算机显卡显存在4GB及以上（建议4GB+），可以使用个人来进行训练。
AutoDL官网：https://www.autodl.com/home
完成注册后，我们选购一台合适的服务器，我这以Tesla T4为例（期间的付费实名等操作这里不做展开）。
服务器购买后，可以使用镜像，平台社区有很多作者发布了自己的镜像，可以搜索vits查找相关镜像。选择做好的镜像可以大大降低我们的环境部署的时间。大家可以直接选择以下的vits-fast的镜像，然后运行我们的服务器。
开机后，在右上角控制台，容器实例中，我们可以看到我们的服务器的相关信息。
点击JupyterLab，打开在线面板，再打开终端。
运行环境和前期准备 由于我选择的镜像是so-vits-svc-v10，会有些许出入，但整体不会对项目运行使用造成影响。
python：3.8.10
我们先安装git，在终端运行命令sudo apt install git -y
然后clone项目到/root目录。（注意，如果您选择的VITS-fast-fine-tuning的镜像，那可能需要先删除默认的VITS-fast-fine-tuning文件夹，重新clone项目）
git clone https://github.com/Plachtaa/VITS-fast-fine-tuning.git 如果您没有选择做好的官方镜像，则需要手动安装相关环境，具体可以参考官方笔记：https://colab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1c3cb1cbd62ed5b22f9d27dd5ec0687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ce4178b8b7818db3e68e94f57637fc/" rel="bookmark">
			Gstreamer-音频数据播放之PCM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下述代码使用场景：
用于需要在当前设备端播放PCM音频数据
// push buffer to appsrc bool push_data(const char *data, int data_size) { GstBuffer *buffer = gst_buffer_new_allocate(NULL, data_size, NULL); GstMapInfo map; gst_buffer_map(buffer, &amp;map, GST_MAP_WRITE); memcpy((guchar *)map.data, data, gst_buffer_get_size(buffer)); GstFlowReturn ret; g_signal_emit_by_name(m_app_src, "push-buffer", buffer, &amp;ret); gst_buffer_unmap(buffer, &amp;map); gst_buffer_unref(buffer); if (ret != GST_FLOW_OK) { g_printerr("[push_data], push_data fail ret: %d.\n", ret); return false; } return true; } // 初始化 pipeline // |---------------------------pipeline-----------------------------| // | appsrc-&gt;audioconvert-&gt;audioresample-&gt;capsfilter-&gt;autoaudiosink | // |----------------------------------------------------------------| bool init(int sample_rate, int channel, const char *formate) { m_app_src = gst_element_factory_make("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44ce4178b8b7818db3e68e94f57637fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcf613f6b77b732232fca5643e690d2f/" rel="bookmark">
			Python web实战 | 使用Flask框架进行Web开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 本文将介绍Flask和Python，两个非常流行和易于使用的工具，来帮助你快速创建你自己的Web应用。
1、Flask简介 Flask是一个基于Python的Web框架。它是一个轻量级框架，非常适合小型项目和快速原型开发。Flask提供了一个简单的API，使得开发者可以快速构建Web应用。Flask的灵活性和可扩展性是它受欢迎的原因之一。
2、Flask的安装和基本使用 首先你需要确保你的机器上安装了Python，然后运行以下命令来安装Flask：
pip install flask 这将安装Flask及其依赖项。完成安装后，你可以开始构建你的第一个Flask应用程序。以下是一个简单的示例：
from flask import Flask app = Flask(__name__) @app.route('/') def index(): return 'Hello, World!' if __name__ == '__main__': app.run() 在这个示例中，我们首先导入了Flask类。然后，我们创建了一个Flask应用程序实例，并将其存储在名为“app”的变量中。接下来，我们使用Flask的route装饰器来定义一个路由。这个路由指定了我们的应用程序将如何响应根路径（'/'）。最后，我们使用Flask的run方法来启动我们的应用程序。
运行这个示例后，你可以在浏览器中访问http://localhost:5000/ ↗，应该会看到“Hello, World!”的字样。
3、Flask的路由和视图函数 在Flask中，路由是指URL和应用程序之间的映射关系。路由告诉Flask应用程序如何响应来自客户端的请求。在Flask中，你可以使用route装饰器来定义一个路由。
视图函数是指Flask应用程序中与路由相关联的Python函数。视图函数负责处理来自客户端的请求，并返回响应。在Flask中，你可以使用route装饰器来将一个视图函数绑定到一个路由上。
以下是一个简单的示例，介绍如何在Flask中定义路由和视图函数：
from flask import Flask app = Flask(__name__) @app.route('/') def index(): return 'Hello, World!' @app.route('/about') def about(): return 'About us' if __name__ == '__main__': app.run() 在这个示例中，我们定义了两个路由：'/'和'/about'。'/‘是默认路由，当我们访问根路径时，将调用index函数。'/about'是自定义路由，当我们访问'/about'路径时，将调用about函数。
4、Flask的模板引擎 Flask的模板引擎使得开发者可以将动态内容插入到HTML页面中。这使得开发者可以更轻松地构建复杂的Web应用程序。
Flask支持多种模板引擎，包括Jinja2和Mako。在本篇文章中，我们将使用Jinja2作为我们的模板引擎。
要使用Jinja2，我们需要创建一个名为templates的目录，并在其中创建一个HTML模板文件。以下是一个示例：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;{{ title }}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;{{ title }}&lt;/h1&gt; &lt;p&gt;{{ content }}&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 在这个示例中，我们定义了一个HTML模板，它有两个变量：title和content。这些变量将在渲染模板时传递给模板引擎。要渲染这个模板，我们需要在视图函数中使用render_template函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcf613f6b77b732232fca5643e690d2f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/109/">«</a>
	<span class="pagination__item pagination__item--current">110/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/111/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>