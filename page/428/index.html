<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b3469018ef22b858d1840d27380ebd/" rel="bookmark">
			深度学习：基本概要：监督，无监督，半监督，弱监督，多示例，迁移学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/limiyudianzi/article/details/78921450
什么是监督学习、无监督学习、强化学习、弱监督学习、半监督学习、多示例学习？
随着机器学习问题不断深入人心，人们也将现实中遇到不同的问题分为不同的学习方式，其中，最基础的应属监督学习，无监督学习和强化学习了。
监督学习(supervised learning)：已知数据和其一一对应的标签，训练一个智能算法，将输入数据映射到标签的过程。监督学习是最常见的学习问题之一，就是人们口中常说的分类问题。比如已知一些图片是猪，一些图片不是猪，那么训练一个算法，当一个新的图片输入算法的时候算法告诉我们这张图片是不是猪。
无监督学习(unsupervised learning)：已知数据不知道任何标签，按照一定的偏好，训练一个智能算法，将所有的数据映射到多个不同标签的过程。相对于有监督学习，无监督学习是一类比较困难的问题，所谓的按照一定的偏好，是比如特征空间距离最近，等人们认为属于一类的事物应具有的一些特点。举个例子，猪和鸵鸟混杂在一起，算法会测量高度，发现动物们主要集中在两个高度，一类动物身高一米左右，另一类动物身高半米左右，那么算法按照就近原则，75厘米以上的就是高的那类也就是鸵鸟，矮的那类是第二类也就是猪，当然这里也会出现身材矮小的鸵鸟和身高爆表的猪会被错误的分类。
强化学习(reinforcement learning)：智能算法在没有人为指导的情况下，通过不断的试错来提升任务性能的过程。“试错”的意思是还是有一个衡量标准，用棋类游戏举例，我们并不知道棋手下一步棋是对是错，不知道哪步棋是制胜的关键，但是我们知道结果是输还是赢，如果算法这样走最后的结果是胜利，那么算法就学习记忆，如果按照那样走最后输了，那么算法就学习以后不这样走。
弱监督学习(weakly supervised learning)： 已知数据和其一一对应的弱标签，训练一个智能算法，将输入数据映射到一组更强的标签的过程。标签的强弱指的是标签蕴含的信息量的多少，比如相对于分割的标签来说，分类的标签就是弱标签，如果我们知道一幅图，告诉你图上有一只猪，然后需要你把猪在哪里，猪和背景的分界在哪里找出来，那么这就是一个已知若标签，去学习强标签的弱监督学习问题。
半监督学习(semi supervised learning) ：已知数据和部分数据一一对应的标签，有一部分数据的标签未知，训练一个智能算法，学习已知标签和未知标签的数据，将输入数据映射到标签的过程。半监督通常是一个数据的标注非常困难，比如说医院的检查结果，医生也需要一段时间来判断健康与否，可能只有几组数据知道是健康还是非健康，其他的只有数据不知道是不是健康。那么通过有监督学习和无监督的结合的半监督学习就在这里发挥作用了。
多示例学习(multiple instance learning) ：已知包含多个数据的数据包和数据包的标签，训练智能算法，将数据包映射到标签的过程，在有的问题中也同时给出包内每个数据的标签。多事例学习引入了数据包的概念，比如说一段视频由很多张图组成，假如1000张，那么我们要判断视频里是否有猪出现，一张一张的标注每一帧是否有猪太耗时，所以人们看一遍说这个视频里有猪或者没猪，那么就得到了多示例学习的数据，1000帧的数据不是每一个都有猪出现，只要有一帧有猪，那么我们就认为这个包是有猪的，所有的都没有猪，才是没有猪的，从这里面学习哪一段视频（1000张）有猪哪一段视频没有就是多事例学习的问题。
参考：https://cloud.tencent.com/developer/article/1077499
迁移学习：可以使我们在他人训练过的模型基础上进行小改动便可投入使用。
1. 什么是迁移学习？ 神经网络需要用数据来训练，它从数据中获得信息，进而把它们转换成相应的权重。这些权重能够被提取出来，迁移到其他的神经网络中，我们“迁移”了这些学来的特征，就不需要从零开始训练一个神经网络了 。针对训练数据集小，防止过拟合使用。通常在计算机视觉imagenet 进行预训练。
2. 什么是预训练模型？ 简单来说，预训练模型(pre-trained model)是前人为了解决类似问题所创造出来的模型。你在解决问题的时候，不用从零开始训练一个新模型，可以从在类似问题中训练过的模型入手。
比如说，如果你想做一辆自动驾驶汽车，可以花数年时间从零开始构建一个性能优良的图像识别算法，也可以从Google在ImageNet数据集上训练得到的inception model(一个预训练模型)起步，来识别图像。
一个预训练模型可能对于你的应用中并不是100%的准确对口，但是它可以为你节省大量功夫。
3.怎样使用预训练模型？ 当在训练经网络的时候我们的目标是什么？我们希望网络能够在多次正向反向迭代的过程中，找到合适的权重。
通过使用之前在大数据集上经过训练的预训练模型，我们可以直接使用相应的结构和权重，将它们应用到我们正在面对的问题上。这被称作是“迁移学习”，即将预训练的模型“迁移”到我们正在应对的特定问题中。
ImageNet数据集已经被广泛用作训练集，因为它规模足够大(包括120万张图片)，有助于训练普适模型。ImageNet的训练目标，是将所有的图片正确地划分到1000个分类条目下。这1000个分类基本上都来源于我们的日常生活，比如说猫猫狗狗的种类，各种家庭用品，日常通勤工具等等。
在迁移学习中，这些预训练的网络对于ImageNet数据集外的图片也表现出了很好的泛化性能。
既然预训练模型已经训练得很好，我们就不会在短时间内去修改过多的权重，在迁移学习中用到它的时候，往往只是进行微调(fine tune)。
在修改模型的过程中，我们通过会采用比一般训练模型更低的学习速率。
5. 微调模型的方法 特征提取
我们可以将预训练模型当做特征提取装置来使用。具体的做法是，将输出层去掉，然后将剩下的整个网络当做一个固定的特征提取机，从而应用到新的数据集中。
采用预训练模型的结构
我们还可以采用预训练模型的结构，但先将所有的权重随机化，然后依据自己的数据集进行训练。
训练特定层，冻结其他层
另一种使用预训练模型的方法是对它进行部分的训练。具体的做法是，将模型起始的一些层的权重保持不变，重新训练后面的层，得到新的权重。在这个过程中，我们可以多次进行尝试，从而能够依据结果找到frozen layers和retrain layers之间的最佳搭配。
如何使用与训练模型，是由数据集大小和新旧数据集(预训练的数据集和我们要解决的数据集)之间数据的相似度来决定的。
下图表展示了在各种情况下应该如何使用预训练模型：
场景一：数据集小，数据相似度高(与pre-trained model的训练数据相比而言)
在这种情况下，因为数据与预训练模型的训练数据相似度很高，因此我们不需要重新训练模型。我们只需要将输出层改制成符合问题情境下的结构就好。
我们使用预处理模型作为模式提取器。
比如说我们使用在ImageNet上训练的模型来辨认一组新照片中的小猫小狗。在这里，需要被辨认的图片与ImageNet库中的图片类似，但是我们的输出结果中只需要两项——猫或者狗。
在这个例子中，我们需要做的就是把dense layer和最终softmax layer的输出从1000个类别改为2个类别。
场景二：数据集小，数据相似度不高
在这种情况下，我们可以冻结预训练模型中的前k个层中的权重，然后重新训练后面的n-k个层，当然最后一层也需要根据相应的输出格式来进行修改。
因为数据的相似度不高，重新训练的过程就变得非常关键。而新数据集大小的不足，则是通过冻结预训练模型的前k层进行弥补。
场景三：数据集大，数据相似度不高
在这种情况下，因为我们有一个很大的数据集，所以神经网络的训练过程将会比较有效率。然而，因为实际数据与预训练模型的训练数据之间存在很大差异，采用预训练模型将不会是一种高效的方式。
因此最好的方法还是将预处理模型中的权重全都初始化后在新数据集的基础上重头开始训练。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44b3469018ef22b858d1840d27380ebd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab7c50b3028fd5bd7c5f4b30579fb160/" rel="bookmark">
			mininet walkthrough 中遇到 dpctl failed to send packet to switch:connection refused
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试一下命令 ovs-ofctl dump-flows s1(s1是交换机的名字)
参考 https://mailman.stanford.edu/pipermail/mininet-discuss/2013-June/002416.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e069c3cfcf18d71b24546de9497213a/" rel="bookmark">
			bootstrap-select selectpicker动态设置选中无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家都知道一般设置select选中都是下面这几种，当然还有其他方式，没有列完
$("#infoLevel").val(d.level); $("#infoLevel").find("option[value="+d.level+"]").prop("selected","selected"); 今天设置一直没起作用，然后去看了下元素
id为parent的元素可以直接当成上面的infoLevel，这个图片只是个例子。
可以看到除了select元素下面还生成了一个div，div里面有button等，下拉option展示的是里面的button，看到元素后我是这样理解的
第一次使用bootstrap-select selectpicker这个东东
正确设置的方法是：
$('#infoLevel').selectpicker('val',d.level); 如果是要修改元素内容，比如往里面添加html元素等,记得最后加上另外2行重新渲染页面的代码(以id为parent的元素为例子):
//要以编程方式更新JavaScript的选择，首先操作选择，然后使用refresh方法更新UI以匹配新状态。 在删除或添加选项时，或通过JavaScript禁用/启用选择时，这是必需的。 $('#parent').selectpicker('refresh'); //render方法强制重新渲染引导程序 - 选择ui,如果当您编程时更改任何相关值而影响元素布局，这将非常有用。 $('#parent').selectpicker('render'); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6618e5145ae194d091c17a4f0a722823/" rel="bookmark">
			独家 | 一文读懂最大似然估计(附R代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：阿尼·辛格
翻译： 陈之炎
校对：丁楠雅
本文约4200字，建议阅读10+分钟。
本文将研究MLE是如何工作的，以及它如何用于确定具有任何分布的模型的系数。
简介
解释模型如何工作是数据科学中最为基本最为关键的问题之一。当你建立了一个模型之后，它给了你预期的结果，但是它背后的过程是什么呢？作为一个数据科学家，你需要对这个经常被问到的问题做出解答。
例如，假设您建立了一个预测公司股价的模型。您注意到夜深人静的时候，股票价格上涨得很快。背后可能有多种原因，找出可能性最大的原因便是最大似然估计的意义所在。这一概念常被用于经济学、MRIs、卫星成像等领域。
来源：YouTube 在这篇文章中，我们将研究最大似然估计(以下简称MLE)是如何工作的，以及它如何用于确定具有任何分布的模型的系数。理解MLE将涉及到概率和数学，但我将尝试通过例子使它更通俗易懂。
注：如前所述，本文假设您已经了解概率论的基本知识。您可以通过阅读这篇文章来澄清一些基本概念：
《每个数据科学专业人员都应该知道的概率分布常识》：
https://www.analyticsvidhya.com/blog/2017/09/6-probability-distributions-data-science/
目录 为什么要使用最大似然估计(MLE)？
通过一个实例了解MLE
进一步了解技术细节
分布参数
似然
对数似然
最大似然估计
利用MLE确定模型系数
R语言的MLE实现
为什么要使用最大似然估计(MLE)？ 假设我们想预测活动门票的销售情况。数据的直方图和密度如下。
你将如何为这个变量建模？该变量不是正态分布的，而且是不对称的，因此不符合线性回归的假设。一种常用的方法是对变量进行对数、平方根（sqrt）、倒数等转换，使转换后的变量服从正态分布，并进行线性回归建模。
让我们试试这些转换，看看结果如何：
对数转换：
平方根转换：
倒数转换：
所有这些都不接近正态分布，那么我们应该如何对这些数据进行建模，才能不违背模型的基本假设？如何利用正态分布以外的其他分布来建模这些数据呢？如果我们使用了不同的分布，又将如何来估计系数？
这便是最大似然估计(MLE)的主要优势。
举一个例子来加深对MLE的理解 在研究统计和概率时，你肯定遇到过诸如x＞100的概率，因为x服从正态分布，平均值为50，标准差为10。在这些问题中，我们已经知道分布（在这种情况下是正态分布）及其参数（均值和标准差），但在实际生活问题中，这些参数是未知的，并且必须从数据中估计出来。MLE可以帮助我们确定给定数据的分布参数。
让我们用一个例子来加深理解：假设我们用数据来表示班级中学生的体重(以kg为单位)。数据如下图所示(还提供了用于生成数据图的R代码)：
图 1 x = as.data.frame(rnorm(50,50,10))
ggplot(x, aes(x = x)) + geom_dotplot()
这似乎遵循正态分布。但是我们如何得到这个分布的均值和标准差呢？一种方法是直接计算给定数据的平均值和标准差，分别为49.8公斤和11.37公斤。这些值能很好地表示给定的数据，但还不能最好地描述总体情况。
我们可以使用MLE来获得更稳健的参数估计。因此，MLE可以定义为从样本数据中估计总体参数(如均值和方差、泊松率(Lambda)等)的方法，从而使获得观测数据的概率(可能性)最大化。
为了加深对MLE的理解，尝试猜测下列哪一项会使观察上述数据的概率最大化？
1. 均值=100，标准差=10
2. 均值=50 ，标准差=10
显然，如果均值为100，我们就不太可能观察到上述数据分布图形。
进一步了解技术细节 知道MLE能做什么之后，我们就可以深入了解什么是真正的似然估计，以及如何对它最大化。首先，我们从快速回顾分布参数开始。
分布参数 首先，来了解一下分布参数。维基百科对这个词的定义如下：“它是一个概率分布的量化指数”，可以将它视为样本总数的数值特征或一个统计模型。通过下面的图表来理解它：
图 2
钟形曲线的宽度和高度的两个参数决定均值和方差。这就是正态分布的分布参数。同样，泊松分布由一个参数lambda控制，即事件在时间或空间间隔内发生的次数。
图 3
大多数分布都有一个或两个参数，但有些分布可以有多达4个参数，比如4参数β分布。
似然 从图2和图3中我们可以看到，给定一组分布参数，一些数据值比其他数据的概率更大。从图1中，我们已经看到，当平均值是50而不是100时，给定的数据更有可能发生。然而，在现实中，我们已经观察到了这些数据。因此，我们面临着一个逆向问题：给定观测数据和一个感兴趣的模型，我们需要在所有概率密度中找到一个最有可能产生数据的概率密度函数/概率质量函数(f(x_\θ)。
为解决这一逆向问题，我们通过逆转f(x=θ)中数据向量x和(分布)参数向量θ来定义似然函数，即：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6618e5145ae194d091c17a4f0a722823/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7241d1e7e1dfc4aced396185d603ebcf/" rel="bookmark">
			【NOIP2017普及组】跳房子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目背景 NOIP2017普及组 T4
题目描述 跳房子，也叫跳飞机，是一种世界性的儿童游戏，也是中国民间传统的体育游戏之一。跳房子的游戏规则如下：
在地面上确定一个起点，然后在起点右侧画 n 个格子，这些格子都在同一条直线上。每个格子内有一个数字（整数），表示到达这个格子能得到的分数。玩家第一次从起点开始向右跳，跳到起点右侧的一个格子内。第二次再从当前位置继续向右跳，依此类推。规则规定：玩家每次都必须跳到当前位置右侧的一个格子内。玩家可以在任意时刻结束游戏，获得的分数为曾经到达过的格子中的数字之和。
现在小R研发了一款弹跳机器人来参加这个游戏。但是这个机器人有一个非常严重的缺陷，它每次向右弹跳的距离只能为固定的 d 。小R希望改进他的机器人，如果他花 g 个金币改进他的机器人，那么他的机器人灵活性就能增加g，但是需要注意的是，每次弹跳的距离至少为 1 。具体而言，当 g&lt;d 时，他的机器人每次可以选择向右弹跳的距离为 d-g, d-g+1, d-g+2，…，d+g-2，d+g-1，d+g ；否则（当g≥d时），他的机器人每次可以选择向右弹跳的距离为 1，2，3，…，d+g-2，d+g-1，d+g 。
现在小R希望获得至少 k 分，请问他至少要花多少金币来改造他的机器人。
输入格式 第一行三个正整数 n，d，k ，分别表示格子的数目，改进前机器人弹跳的固定距离，以及希望至少获得的分数。相邻两个数之间用一个空格隔开。
接下来 n 行，每行两个正整数 xi，si，分别表示起点到第 i 个格子的距离以及第 i 个格子的分数。两个数之间用一个空格隔开。保证 xi 按递增顺序输入。 输出格式 共一行，一个整数，表示至少要花多少金币来改造他的机器人。若无论如何他都无法获得至少 k 分，输出 -1 。
样例数据 1 输入
7 4 10 2 6 5 -3 10 3 11 -3 13 1 17 6 20 2 输出
2 样例数据 2 输入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7241d1e7e1dfc4aced396185d603ebcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a9de94def917713955717aca43ad9b6/" rel="bookmark">
			分布式存储系统可靠性系列一：如何估算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来自网易云社区
作者：孙建良
1. 存储系统的可靠性 常规情况下，我们一般使用多幅本技术来提高存储系统的可靠性，不论是结构化数据库存储(典型mysql)、文档型Nosql数据库存储(mongodb)或者是常规的blob存储系统(GFS、Hadoop)等。
数据几乎是企业的生命所在，那么如何去衡量较为正确得去衡量集群数据的可靠性？如何进行系统设计使得集群数据达到更高的可靠性，这是本文要解答的疑问。
2. 数据丢失与copyset（复制组） “在999块磁盘3备份系统中，同时坏三块盘情况下的数据丢失概率?” ，这个跟存储系统的设计息息相关。我们先考虑两个极端设计下的情况
设计一：把999块磁盘组层333块磁盘对。
在这种设计情况下，只有选中其中一个磁盘对才会发生数据丢失。这种设计中，丢失数据的概率为 333/C(999,3) = 5.025095326058336*e-07。
设计二：数据随机打散到999盘中，极端情况下，随机一块盘上的逻辑数据的副本数据打散在在所有集群中的998块盘中。 这种设计中，丢失数据的概率为 C(999,3)/C(999,3)=1，也就是必然存在
通过这两种极端的栗子，我们可以看到数据的丢失概率跟数据的打散程度息息相关，为了方便后续阅读，这里我们引入一个新的概念copyset(复制组)。
CopySet：包含一个数据的所有副本数据的设备组合，比如一份数据写入1，2，3三块盘，那么{1,2,3}就是一个复制组。复制代码 9个磁盘的集群中，最小情况下的copyset的组合数为3，copysets = {1,2,3}、{4,5,6}、{7,8,9}，即一份数据的写入只能选择其中一个复制组，那么只有 {1,2,3}、{4,5,6}或者{7,8,9} 同时坏的情况下才会出现数据丢失。即最小copyset数量为N/R。
系统中最大的copyset的数目为 C(N,R) ，其中R为副本数，N为磁盘的数量。在完全随机选择节点写入副本数据的情况下，系统中的copyset数目会达到最大值C(N,R)。即任意选择R个磁盘都会发生一部分数据的三个副本都在这R个盘上。
磁盘数量N，副本为R的存储系统中，copyset数量S, N/R &lt; S &lt; C(N, R)复制代码 3. 磁盘故障与存储系统可靠性估算 3.1 磁盘故障与柏松分布 在正式估算概率之前还需要科普下一个基础的概率学分布：柏松分布，wiki百科详见柏松分布。柏松分布主要描述在一个系统中随机事件发生的概率，譬如汽车站台的候客人数的概率，某个医院1个小时内出生N个新生儿的概率等等，更佳形象的可参见 阮一峰的《泊松分布和指数分布：10分钟教程》)。
如上为泊松分布的公式。等号的左边，P 表示概率，N表示某种函数关系，t 表示时间，n 表示数量，λ 表示事件的频率。
举个栗子：1000块磁盘在1年内出现10块概率为P(N(365) = 10)[注：t的平均单位为天]。λ 为1000块磁盘1天内发生故障磁盘的数量，按照google的统计，年故障率在8%，那么 λ = 1000*8%/365 。
如上只是损坏N块磁盘的概率统计，那么怎么利用这个信息计算分布式系统中数据的可靠性(即数据丢失概率)的近似估算。
3.2 分布式存储系统中的丢失率估算 3.2.1 T时间内故障率 分布式存储存储系统中如何进行年故障率估算，我们先假定一种情况，T(1年时间内)，系统存满数据的情况下，坏盘不处理。这种情况下统计下数据的年故障率。
这里我们先定义一些数据 N:磁盘数量 T：统计时间 K：坏盘数量 S: 系统中copyset数量(复制组的个数) R：备份数量复制代码 如何计算T（1年）时间内数据丢失的概率，从概率统计角度来说就是把T(1年)时间内所有可能出现数据丢失的事件全部考虑进去。包含N个磁盘R副本冗余的系统中，在T时间内可能出现数据丢失数据的事件为坏盘大于等于R的事件，即R，R+1，R+2，... N (即为 K∈[R,N] 区间所有的时间)，这些随机事件发生时，什么情况下会造成数据丢失？没错就是命中复制组的情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a9de94def917713955717aca43ad9b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e74c1fe8e8726007d6cd6f911909c7c3/" rel="bookmark">
			你不知道的 Electron (二)：了解 Electron 打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自IMWeb社区，作者：laynechen，原文链接
我们知道 Electron 提供了一个类似浏览器，但有更多权限的环境来运行我们的网页，那么 Electron 是怎么做到将我们的网页代码打包成一个可执行程序的呢？
这篇文章主要介绍如何打包 Electron 应用，以及分析 electron-builder 是如何对我们的应用进行打包的。
如何打包 Electron 目前有两种打包工具：electron-userland/electron-builder 和 electron-userland/electron-packager。
使用 electron-builder 打包 安装依赖： yarn add electron-builder --dev // 或 npm i electron-builder --save-dev 复制代码 打包： 在项目的 package.json 文件中定义 name、description、version 和 author 信息。在项目的 package.json 文件中定义 build 字段： "build": { "appId": "your.id", "mac": { "category": "your.app.category.type" } } 复制代码 (全部选项)
添加 scripts 到 package.json 中 "scripts": { "pack": "electron-builder --dir", "dist": "electron-builder" } 复制代码 打包 生成 package 目录但是没有打包为一个文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e74c1fe8e8726007d6cd6f911909c7c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/982059e88d941d874f25a0e969f6c54a/" rel="bookmark">
			前端面试——回调、Promise、Generator和async-await
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们回顾一下javascript异步的发展历程。
ES6 以前：
回调函数（callback）：nodejs express 中常用，ajax中常用。
ES6：
promise对象：nodejs最早有bluebird promise的雏形，axios中常用。
generator函数：nodejs koa框架使用率很高。
ES7:
async/await语法：当前最常用的异步语法，nodejs koa2 完全使用该语法。
回调函数CALLBACK：
将一个函数当做参数传到另一个函数里，当那个函数执行完后，再执行传进去的这个函数；这个过程就叫做回调。
Promise对象：
promise 对象用于一个异步操作的最终完成（或最终失败）及其结果的表示。
简单地说就是处理一个异步请求。我们经常会做些断言，如果我赢了你就嫁给我，如果输了我就嫁给你之类的断言。
这就是promise的中文含义：断言，一个成功，一个失败。
举个例子，方便大家理解：
promise构造函数的参数是一个函数，我们把它称为处理器函数。
处理器函数接收两个函数reslove和reject作为其参数，当异步操作顺利执行则执行reslove函数, 当异步操作中发生异常时，则执行reject函数。
async-await
async函数返回一个promise对象，如果在async函数中返回一个直接量，async会通过Promise.resolve封装成Promise对象。
我们可以通过调用promise对象的then方法，获取这个直接量。
await会暂停当前async的执行，await会阻塞代码的执行，直到await后的表达式处理完成，代码才能继续往下执行。
await后的表达式既可以是一个Promise对象，也可以是任何要等待的值。
如果await等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51e210ca19f1d79ae8329fe7a8cf357d/" rel="bookmark">
			Conference Partner 会议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.myhuiban.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ece78a70b624b88f562799ec52ddb02d/" rel="bookmark">
			ServiceConnection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绑定到一个Service 应用组件(客户端)可以调用bindService()绑定到一个service．Android系统之后调用service的onBind()方法，它返回一个用来与service交互的IBinder．
绑定是异步的．bindService()会立即返回，它不会返回IBinder给客户端．要接收IBinder，客户端必须创建一个ServiceConnection的实例并传给bindService()．ServiceConnection包含一个回调方法，系统调用这个方法来传递要返回的IBinder．
注：只有activities,services,和contentproviders可以绑定到一个service—你不能从一个broadcastreceiver绑定到service．
所以，从你的客户端绑定到一个service，你必须：
１实现ServiceConnection.
你的实现必须重写两个回调方法：
onServiceConnected()
系统调用这个来传送在service的onBind()中返回的IBinder．
OnServiceDisconnected()
Android系统在同service的连接意外丢失时调用这个．比如当service崩溃了或被强杀了．当客户端解除绑定时，这个方法不会被调用．
２调用bindService()，传给它ServiceConnection的实现．
３当系统调用你的onServiceConnected()方法时，你就可以使用接口定义的方法们开始调用service了．
４要与service断开连接，调用unbindService()．
当你的客户端被销毁，它将从service解除绑定，但是你必须总是在你完成与service的交互时或当你的activity暂停于是service在不被使用时可以关闭此两种情况下解除绑定．(下面会讨论更多在适当的时候绑定和解除绑定的问题．)
例如，下面是前一篇＂派生Binder类＂中创建的代码片段，它把客户端连接到了service．所有需要做的就是把返回的IBinder强制转换到LocalBinder类并且请求LocalService实例：
LocalService mService; private ServiceConnection mConnection = new ServiceConnection() { // 当与service的连接建立后被调用 public void onServiceConnected(ComponentName className, IBinder service) { // Because we have bound to an explicit // service that is running in our own process, we can // cast its IBinder to a concrete class and directly access it. LocalBinder binder = (LocalBinder) service; mService = binder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ece78a70b624b88f562799ec52ddb02d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a87d3f47a9872fe8b28e4d99c7a98436/" rel="bookmark">
			java 根据模板文件生成word文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://blog.csdn.net/zhangzhangjava/article/details/52937159
最近需要做一个导出word的功能, 在网上搜了下, 有用POI,JXL,iText等jar生成一个word文件然后将数据写到该文件中,API非常繁琐而且拼出来的样式也不美观,于是选择了另一种方式----feemarker基于word模板的导出方式, 这种方式非常简单而且导出的样式美观, 其原理就是先做一个word模板, 该模板中变量数据用${xxx}这种方式填写, 然后再导出时只需读取模板然后用相应的数据替换其中的${xxx}即可. 一,简单模板导出(不含图片, 不含表格循环) 1, 新建一个word文档, 输入如下类容: 2, 将该word文件另存为xml格式(注意是另存为,不是直接改扩展名) 3, 将xml文件的扩展名直接改为ftl 4, 用java代码完成导出(需要导入freemarker.jar) Java代码：
@Test public void test(){ Map&lt;String,Object&gt; dataMap = new HashMap&lt;String, Object&gt;(); try { //编号 dataMap.put("id", "123456"); //日期 dataMap.put("date", new SimpleDateFormat("yyyy年MM月dd日").format(new SimpleDateFormat("yyyy-MM-dd").parse("2018-09-19"))); //附件张数 dataMap.put("number", 1); //受款人 dataMap.put("payee", "张三"); //付款用途 dataMap.put("use_of_payment", "test"); //大写金额 dataMap.put("capitalization_amount", MoneyUtils.change(100.20)); //小写金额 dataMap.put("lowercase_amount", "100"); //Configuration 用于读取ftl文件 Configuration configuration = new Configuration(new Version("2.3.0")); configuration.setDefaultEncoding("utf-8"); /** * 以下是两种指定ftl文件所在目录路径的方式，注意这两种方式都是 * 指定ftl文件所在目录的路径，而不是ftl文件的路径 */ //指定路径的第一种方式（根据某个类的相对路径指定） // configuration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a87d3f47a9872fe8b28e4d99c7a98436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0c6a8b2277da17bfce196d7027a89b9/" rel="bookmark">
			什么是scala?scala有什么用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.scala是什么？
Scala是一种多范式的编程语言，其设计的初衷是要集成面向对象编程和函数式编程的各种特性。Scala运行于Java平台（Java虚拟机），并兼容现有的Java程序。http://www.scala-lang.orgScala是一种多范式的编程语言，其设计的初衷是要集成面向对象编程和函数式编程的各种特性。Scala运行于Java平台（Java虚拟机），并兼容现有的Java程序。http://www.scala-lang.orgScala是一种多范式的编程语言，其设计的初衷是要集成面向对象编程和函数式编程的各种特性。Scala运行于Java平台（Java虚拟机），并兼容现有的Java程序。http://www.scala-lang.org
2.为什么要用scala?
1、优雅：这是框架设计师第一个要考虑的问题，框架的用户是应用开发程序员，API是否优雅直接影响用户体验。
2、速度快：Scala语言表达能力强，一行代码抵得上Java多行，开发速度快；Scala是静态编译的，所以和JRuby,Groovy比起来速度会快很多。
3、能融合到Hadoop生态圈：Hadoop现在是大数据事实标准，Spark并不是要取代Hadoop，而是要完善Hadoop生态。JVM语言大部分可能会想到Java，但Java做出来的API太丑，或者想实现一个优雅的API太费劲。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85221fd5c3e6685b7c022364b107bec/" rel="bookmark">
			SpringBoot项目打成war包在tomcat中启动两次原因及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 笔者新建了一个QQ群：571278542 。欢迎大家加入！
tomcat重启两次的原因是appBase和Context中docBase设置的值导致的，只需要把appBase置为空，docBase写项目的绝对路径就可以了，代码如下：
&lt;Host name="localhost" appBase="" unpackWARs="true" autoDeploy="true"&gt; &lt;Context path="/" docBase="F:/Tomcat8.5/webroot/taocloud" debug="0"/&gt; &lt;!-- SingleSignOn valve, share authentication between web applications Documentation at: /docs/config/valve.html --&gt; &lt;!-- &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt; --&gt; &lt;!-- Access log processes all example. Documentation at: /docs/config/valve.html Note: The pattern used is equivalent to using pattern="common" --&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log" suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;/Host&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afd3f3f6fb4a5ddb97cff39ff6d5ad96/" rel="bookmark">
			curl请求参数带中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP的curl请求中参数带中文，直接拼接地址后，会出现请求地址错误的问题。但是将拼接的地址复制到浏览器中，请求正常。这是因为现在基本所有主流的浏览器都自带url转码功能，就是自动将汉字转换为url编码后的字符。那么在代码中如何解决。其实只要手动转换下参数中的汉字就行了，使用urlencode需要传参的字符，拼接后就行，其他参数及域名原样传输。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb0723e8d882ff660b02b8166bf16da9/" rel="bookmark">
			js实现页面滑动到最底部触发内容加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要清楚3个定义:
文档高度: 这是整个页面的高度可视窗口高度: 这是你看到的浏览器可视屏幕高度滚动条滚动高度: 滚动条下滑过的高度 所以, 当 文档高度 == 可视窗口高度 + 滚动条高度 时,滚动条正好到底.
以下三个方法分别获取上面3个高度值
scroll-event.js
//文档高度 function getDocumentTop() { var scrollTop = 0, bodyScrollTop = 0, documentScrollTop = 0; if (document.body) { bodyScrollTop = document.body.scrollTop; } if (document.documentElement) { documentScrollTop = document.documentElement.scrollTop; } scrollTop = (bodyScrollTop - documentScrollTop &gt; 0) ? bodyScrollTop : documentScrollTop; return scrollTop; } //可视窗口高度 function getWindowHeight() { var windowHeight = 0; if (document.compatMode == "CSS1Compat") { windowHeight = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb0723e8d882ff660b02b8166bf16da9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b6aa74ebc12cca3899a6a55e3a2c97/" rel="bookmark">
			最全最新：Windows 64bit下安装   免安装版本的mysql8.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步，当然是下载了，给一个官方下载链接 https://dev.mysql.com/downloads/mysql/
然后再截两张图
下载完之后 解压，然后放到一张盘 下面，再解压出来的文件中添加一个data文件夹，和一个my.ini文件，文件目录如下图：
打开my.ini 文件 ，编辑如下
# For advice on how to change settings please see # http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html # *** DO NOT EDIT THIS FILE. It's a template which will be copied to the # *** default location during install, and will be replaced if you # *** upgrade to a newer version of MySQL. [mysqld] #skip-grant-tables # Remove leading # and set to the amount of RAM for the most important data # cache in MySQL.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9b6aa74ebc12cca3899a6a55e3a2c97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70f93bce70ba87aba8acf55a822cbb2c/" rel="bookmark">
			linux文件结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux目录结构 阶层式的树状目录结构：
bin：可执行命令。
boot：内核、系统引导。
etc：所有的配置文件。
usr：系统用户工具和程序，bin：用户命令，include：标准头文件，lib：库文件，src：内核源代码。
tmp：临时文件。
dev：所有外部设备文件（驱动）。
home：用户文件夹。
lib：放动态库。
mnt：临时挂载其他文件。
linux文件类型 普通文件：流式文件。第一个字符-表示普通文件
目录：第一个字符d表示目录
连接文件：指向另一个文件的路径（似乎类似快捷方式），第一个字符l
设备文件：第一个字符字符设备c，快设备b。socket第一个字符是s。
分区：先有目录，再将物理地址映射到目录中。默认三个分区：boot分区、swap分区、根分区。
挂载（mount）：把磁盘某个分区内容放在某个目录下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad6189be56c0166df98b34d1ed803193/" rel="bookmark">
			spring boot 热更新、热加载（idea使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每修改一下代码再去run一次实在是很麻烦啦，接触springboot不久，但既然用这个框架的，它所包含的特性什么的还是要充分利用，不能浪费呀！springboot的热部署网上有太多的教案，在此呢，也只是真实记录一下自己在实际操作过程中的方法步骤。
1、pom.xml配置：这是一定要配置的，忘记吃饭都不能忘记这个
2、File-&gt;setting：该√的√上
3、手指刚刚够用的：ctrl+alt+shift+/ 就会出来Registry...
4、结束了。进行学习吧 转载：https://blog.csdn.net/babyyaoyao/article/details/80832417
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92e794388ed87fdd7ea8d9e403fc8389/" rel="bookmark">
			#面试--主线程与子线程的执行顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般情况下，主线程总是优于子线程的执行，我们看一下下面的情况：
package com.yzh.job.test; public class Thread2 { public static void main(String[] args) { Thread t1 = new Thread(new Runnable(){ @Override public void run() { for(int i = 0;i&lt;2;i++){ System.out.println("Thread1"); } Thread t2 = new Thread(new Runnable(){ @Override public void run() { for(int i = 0;i&lt;2;i++){ System.out.println("Thread2"); } } }); t2.start(); } }); t1.start(); System.out.println("main"); } } 说明：在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。不过主线程先启动占用了cpu资源，因此主线程总是优于子线程。然而，其实设置了优先级，也无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。 线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5。但是如果存在主线程和子线程争抢cpu执行权的话，看运气，谁抢到就让谁执行。因此，此时main主线程和t1、t2子线程之间存在争抢cpu执行权，因此无法判断谁优先执行。如果现在要求Thraed2子线程先于Thread1父线程，Thread1子线程优于main主线程，那么我们就可以这样修改：
package com.yzh.job.test; public class Thread2 { public static void main(String[] args) { Thread t1 = new Thread(new Runnable(){ @Override public void run() { for(int i = 0;i&lt;2;i++){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92e794388ed87fdd7ea8d9e403fc8389/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57012bf9104a69c66ade1e1813fed778/" rel="bookmark">
			ActiveMQ消息中间件使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ActiveMQ介绍 ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。
jms介绍 JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。
JMS是一种与厂商无关的 API，用来访问消息收发系统消息，它类似于JDBC(Java Database Connectivity)。这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。
ActivcMQ在linux下的安装 1.解压ActiveMQ安装包 tar -xvf apache-activemq-5.12.0-bin.tar.gz -C /usr/local/
2.进入bin目录,运行activemq ./activemq start
3.到页面访问 ip+8161端口号,点击下图箭头所指位置进入管理页面,默认用户名密码为admin
补充: 如果页面无法访问可能存在如下情况:
1.主机名没有映射,8161端口没有被监听
netstat -tnlp查看端口监听
若没有监听查看主机名是否映射
(1)vim /etc/sysconfig/network
(2)vim /etc/hosts
若没有则添加映射,重启activemq。
2.8161端口正常监听,页面仍然无法访问,检查防火墙是否关闭。
activemq使用java代码实现 对于消息的传递有两种类型,1点对点(一个provider一个consumer),2.发布/订阅(一个消息可被多个consumer消费,注意:consumer端需在provider端前面开启,否则无法接收到发送的消息)
使用jms实现消息的发送与接收 在maven工程的pom文件中加入activemq依赖
&lt;dependency&gt;
&lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
&lt;artifactId&gt;activemq-client&lt;/artifactId&gt;
&lt;version&gt;5.13.4&lt;/version&gt;
&lt;/dependency&gt;
1.点对点(queue)java代码实现
producer端
public static void main(String[] args) throws JMSException { //1.创建练连接工厂 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.219.128:61616"); //2.创建连接 Connection connection = connectionFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57012bf9104a69c66ade1e1813fed778/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e86f1e2107d33664fa79d3496c327c50/" rel="bookmark">
			python字典更新时出现value为None的情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字典在python中是非常重要的一种结构，因其用哈希的方式存储数据，其复杂度为O(1)，速度非常快。
大多数的情况下，更改字典里key对应的值，会使用重新赋值的方法
person = {'name': 'jack', 'age': 18} print person person['name'] = 'jhon' # 修改字典的值 print person 运行结果
{'age': 18, 'name': 'jack'} {'age': 18, 'name': 'jhon'} python内置的字典类型是无序的，所以输出结果和原来的字典顺序是不一样的。
如果，key对应的值是一个对象或者数据结构，该怎么去修改其对应的值呢，如：对应的值是一个列表
person = {'name': ['jack', 'alis'], 'age': 18} print person person['name'] = person['name'].append('hanjun') # 修改字典的值 print person 运行结果
{'age': 18, 'name': ['jack', 'alis']} {'age': 18, 'name': None} 结果中name对应的值为None，这样就出现了细节上的bug，并且这个bug是不容易被发现的，看起来好像没什么错。
这种错误就说明对python的理解还不够，本人就遇到了这个坑，而且花了好几个小时的时间，悲哀呀。
正确的做法应该是：
person = {'name': ['jack', 'alis'], 'age': 18} print person person['name'].append('hanjun') # 修改字典的值 print person 运行结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e86f1e2107d33664fa79d3496c327c50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1e7b2af19da83b406774db3438e321c/" rel="bookmark">
			k8s的LNMP部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		架构图： 镜像 首先我们将nginx和php镜像准备好，并且将其推送到镜像仓库中：
自己没有Dockerfile文件得可以下载我的：
https://download.csdn.net/download/qq_25611295/10672202
docker login 192.168.1.40:5000 nginx: docker build -t 192.168.1.40:5000/lnmp/nginx . docker push 192.168.1.40:5000/lnmp/nginx php： docker bulid -t 192.168.1.40:5000/lnmp/php . docker push 192.168.1.40:5000/lnmp/php mysql: docker pull mysql:5.6 docker tag 1f47fade220d 192.168.1.40/lnmp/mysql docker push 192.168.1.40:5000/lnmp/mysql 检测仓库：
仓库配置：https://blog.csdn.net/qq_25611295/article/details/80967135
[root@k8s-g1 ~]# curl -u liaochao:123456 192.168.1.40:5000/v2/_catalog {"repositories":["lnmp/mysql","lnmp/nginx","lnmp/php","nginx","php"]} 认证： 镜像准备好以后我们需要配置一些认证文件，比如，mysql的账户密码，仓库的账户密码等等，我们需要将这些放入k8s的认证中
mysql:
创建mysql密码的认证
kubectl create secret generic mysql-pass --from-literal=password=123456 检测：
[root@master LNMP]# kubectl get secret NAME TYPE DATA AGE default-token-5bjhk kubernetes.io/service-account-token 3 24d liaochao-https kubernetes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1e7b2af19da83b406774db3438e321c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1f09e7e89fee2360d57fd5db37f723d/" rel="bookmark">
			element-ui 实现卡片式列表，选择，分页代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是浏览器效果：
以下是代码实现：
实际应用中，踩了几个坑，总结为下面代码中的3个关键点。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;!-- import CSS --&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt; &lt;!-- import jquery --&gt; &lt;script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"&gt;&lt;/script&gt; &lt;!-- import Vue before Element --&gt; &lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;!-- import JavaScript --&gt; &lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;style type="text/css"&gt; html, body { /***关键点1：设置body高度100%!***/ height: 100%; overflow-x: hidden; margin: 0px; padding: 0px; } /* 中间列表 */ .page_l{ /***关键点3：设置列表部分overflow样式!***/ float:left; margin-left:1%; overflow: scroll; overflow-x: hidden; overflow-y: auto; } .page_photo2{clear:both; width:100%;} .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1f09e7e89fee2360d57fd5db37f723d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e4822203db2d7fd28a8d5355f6e5155/" rel="bookmark">
			R语言开发之CSV文件的读写操作了解下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在R中，我们可以从存储在R环境外部的文件读取数据，还可以将数据写入由操作系统存储和访问的文件。这个csv文件应该存在于当前工作目录中，以方便R可以读取它， 当然，也可以设置自己的目录，并从那里读取文件。
我们可以使用getwd()函数来检查R工作区指向哪个目录，并且使用setwd()函数设置新的工作目录，如下：
输出结果如下：
csv文件是一个文本文件，其中列中的值用逗号分隔，我们可以将以下数据保存入txt文件中，并且修改后缀名称为csv：
id,name,salary,start_date,dept 1,Rick,623.3,2012-01-01,IT 2,Dan,515.2,2013-09-23,Operations 3,Michelle,611,2014-11-15,IT 4,Ryan,729,2014-05-11,HR ,Gary,843.25,2015-03-27,Finance 6,Nina,578,2013-05-21,IT 7,Simon,632.8,2013-07-30,Operations 8,Guru,722.5,2014-06-17,Finance 我将其命名为a.csv，之后就来使用read.csv()函数读取这个csv文件，并且检查列和行的数量，如下：
输出结果为：
默认情况下，read.csv()函数将输出作为数据帧，当我们在数据帧中读取数据，可以应用所有适用于数据帧的函数，来看下实例：
输出结果为：
R可以从现有数据帧中来创建csv文件，其中write.csv()函数用于创建csv文件，并且该文件在工作目录中创建，如下：
输出结果为：
这里列X来自数据集更新器，我们在编写文件时可以使用其他参数来删除它，如下：
输出结果为：
好啦，本次记录就到这里了。
如果感觉不错的话，请多多点赞支持哦。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70292b7f77ddaad850018b6777f486a8/" rel="bookmark">
			安装virtualbox可能遇到的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		virtualbox打不开和我遇到有关的virtualbox的问题总结（仅供参考） 一.步骤如下： 1、WIN+R打开命令行 2、在命令行中输入：regedit，然后按下回车 3、找到这个文件，找到HKEY_CLASSES_ROOT、再找{00020420-0000-0000-C000-000000000046}，然后点击InprocServer32；接下来双击默认最后修改路径为：C:\Windows\system32\oleaut32.dll。 4、同理 找到HKEY_CLASSES_ROOT，在找到{00020424-0000-0000-C000-000000000046}，然后点击InprocServer32，双击默认，修改路径为：C:\Windows\system32\oleaut32.dll 5、最后关闭命令行，就可以打开虚拟机了。 二.驱动未安装
提示错误：
—————————
VirtualBox – Error In supR3HardenedWinReSpawn
—————————
NtCreateFile(\Device\VBoxDrvStub) failed: 0xc0000034 STATUS_OBJECT_NAME_NOT_FOUND (0 retries)
Driver is probably stuck stopping/starting. Try ‘sc.exe query vboxdrv’ to get more information about its state. Rebooting may actually help. (rc=-101) Make sure the kernel module has been loaded successfully. ————————— Abort ————————— sc.exe query vboxdrv执行结果是停止状态（cmd） 运行“sc.exe query vboxdrv”检测vboxdrv的运行状态。 如果"STATE"不是“RUNNING”，则需要启动该服务 解决方案： 因为vboxdrv驱动没有安装或没有成功启动，64位的系统经常这样，找到**安装目录**下的vboxdrv文件夹， 如D:\Program Files\Oracle\VirtualBox\drivers\vboxdrv，右击VBoxDrv.inf，选安装，然后重启电脑 三.启动无法启动，cpu不允许64位
解决方法，重启进入boss模式找到高级下找到 “Intel Virtualization Technology”改成自启动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70292b7f77ddaad850018b6777f486a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a19c5c6bad53a7c2623bf0fc52fa440/" rel="bookmark">
			Java语言程序设计（基础篇）第十版 编程练习题**3.15（游戏：彩票）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为第三章还没有数组和循环，所以只能用IF语句和组合数的方法来判别用户是否匹配到数字。
import java.util.Scanner; public class Lottery { public static void main(String[]args) { int lottery = (int)(Math.random() * 900)+100; //随机生成100-999之间的数 //Math.random()来获得一个0.0到1.0之间的伪随机数的double值，可以取到0 ，但不包括1。 Scanner input = new Scanner(System.in);//调用Scanner类创建对象 System.out.print("Enter your lottry pick (two digits):"); int guess = input.nextInt(); //Get digits from lottry int lotteryDigit1 = lottery / 100; int lotteryDigit2 = lottery / 10 %10; int lotteryDigit3 = lottery %10; //Get digits from guess int guessDigit1 = guess / 100; int guessDigit2 = guess / 10 % 10; int guessDigit3 = guess % 10; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a19c5c6bad53a7c2623bf0fc52fa440/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae32a10c6f52791a65b6e863fb76087a/" rel="bookmark">
			java中接口是否可以继承多个接口？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口是常量值和方法定义的集合。接口是一种特殊的抽象类。
java类是单继承的。classB Extends classA
java接口可以多继承。Interface3 Extends Interface0, Interface1, interface……
不允许类多重继承的主要原因是，如果A同时继承B和C，而B和C同时有一个D方法，A如何决定该继承那一个呢？
但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。
注意：
1）一个类如果实现了一个接口，则要实现该接口的所有方法。
2）方法的名字、返回类型、参数必须与接口中完全一致。如果方法的返回类型不是void，则方法体必须至少有一条return语句。
3）因为接口的方法默认是public类型的，所以在实现的时候一定要用public来修饰（否则默认为protected类型，缩小了方法的使用范围）。
以下内容转自：http://www.cnblogs.com/littlepanpc/p/3616300.html
java中接口之间的继承 最近在读一些源码的时候突然发现了一个很神奇的东西，它的原始形态是这样的：
在这行代码中，BlockingDeque、BlockingQueue和Deque是三个接口。刚发现这个问题时，我是十分吃惊的，因为即使在《Thinking in Java》中也没有提到接口之间的继承。所以我立即把这个疑问提交到了stackoverflow上面。
这个问答的过程十分简单，在这个链接上面的：http://stackoverflow.com/questions/22498245/one-uncertainty-on-multiple-inheritance-in-universal-image-loader
# 正如在stackoverflow上面所讨论的一样，一个类只能extends一个父类，但可以implements多个接口。java通过使用接口的概念来取代C++中多继承。与此同时，一个接口则可以同时extends多个接口，却不能implements任何接口。因而，Java中的接口是支持多继承的。
然后我又做了个实验，来验证如果多个父子接口中有多个相同的方法声明，然后在实现这个最终的接口的时候，相同的方法声明在实现的时候会不会有冲突呢？
首先写了个接口：TestInterfaceA.java：
复制代码
复制代码 1 package com.peter.java.dsa.interfaces; 2 3 public interface TestInterfaceA { 4 String pri_key = “guess what the private key is”; 5 6 int add(int x, int y); 7 8 String encryt(byte[] result); 9 10 int get(); 11 } 复制代码 复制代码 注意，里面声明了三个方法和一个变量；
然后再与了一个接口：TestInterfaceB.java：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae32a10c6f52791a65b6e863fb76087a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7da9ef9efa2bf02e9c9521178d634514/" rel="bookmark">
			计算机网络基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 说起计算机网络大家可以从字面上来看就是，把许多计算机通过传输介质连接起来组成的网络。来实现我们的信息交换，和资源共享。下面是我整理的计算机网络的一些基础知识，分享给大家，希望能帮助到大家的学习。
正文： 一、计算机网络的概述 1.计算机网络的概念：
计算机网络是利用通信线路和通信设备，把地理上分散的，并具有独立功能的多个计算机系统互相连接起来，按照网络协议进行数据通信，用功能完善的网络软件实现资源共享的计算机系统的集合。
2.计算机网络的基本功能：
软硬件共享、信息共享、通信、负荷均衡与分布处理、系统的安全和可靠性。
3.计算机网络的基本应用：
在教育，科研中的应用、在办公中的应用、在商业上的应用、在通信娱乐上的应用。
4.计算机的产生与发展：
第一代计算机网络是: 面向终端的计算机网络。
第二代计算机网络是：以共享资源为目的的计算机通信网络。
注：计算机通信网络在逻辑上可分为两大部分：通信子网、资源子网。
资源子网：由主计算机系统、终端、终端控制器、联网外设、各种软件资源与信息资源组成。资源子网主要负责全网的数据处理业务，向网络用户提供各种网络资源与网络法服务。
通信网络：通信网络是由通信控制处理机、通信线路和其他通信设备组成。主要完成网络数据传输和转发等通信处理任务。
5.计算机网络的发展趋势：
三网合一、光通信技术、IPV6协议、宽带接入技术、移动通信系统技术。
二、计算机网路的基本组成 1.计算机网路的组成：
计算机系统、通信线路和通信设备、网络协议、网络软件。
计算机系统：主要作用是：负责数据信息的接收、处理、存储、传播和提供共享资源。
通信线路和通信设备：主要负责控制数据的发出、传递、接收和转发，包括信号的转换、路径选择、编码与解码、差错检验、通信控制管理等，以完成信息的交流。
网路协议：通信双方必须共同遵守的约定和通信规则，比如什么样的表接收什么样的信息。
网络软件：主要负责控制和管理网络工作的计算机软件。
2.网络七层协议：
3.计算机网络的拓扑结构:
总线型结构、环形结构、星型结构、树型结构、网络状结构和混合型结构
三、计算机网络的分类： 1.按照网络覆盖的地理范围的大小分为：
局域网、城域网、广域网
2.按照所使用的传输技术可分为：
广播式网络和点对点网络
3.网络的传输方式：
有线传输和无线传输
有线传输的介质有：光纤、同轴电缆、双绞线等。
无线传输的介质有：无线电、微波、红外线、激光等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46b54fc1155bdff656b7bdcef9241628/" rel="bookmark">
			sqlloader的使用------windows版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 作用 SQL*LOADER是ORACLE的数据加载工具，用来将文件导入到ORACL数据库，可以导入一个表或者多个表，甚至可以在导入时修改数据。
二. ORACLE下载地址 sqlloader需要电脑上有sqlldr文件才可实现传输功能，如果没有无法使用sqlloader，由于网上有很多ORACLE是精简版本的，精简版安装完成后oracle包中没有sqlldr.exe这个文件，这里我提供了一个下载地址，这个版本中有sqlldr，sqlplus，本人亲测过，将链接分享给大家。
链接：https://pan.baidu.com/s/1IihYzlxqq1cwz9LO9Yf9xw 密码：w0i6
三. 如何确定电脑中有没有sqlldr文件 两种方式： ① 在oracle目录中的bin下看有没有sqlldr.exe文件，本人安装目录为
D:\app\Administrator\product\11.2.0\dbhome_1\BIN
② 直接在dos（win+R）中输入“sqlldr”，如果出现“sqlldr不是内部或外部命令，也不是可运行程序”字样，说明电脑中没有sqlldr.exe这个文件。如果出现如下所示，说明sqlldr安装成功。 四. 实现txt文件导入到数据库（较简单） 1. 创建表结构
目的：将表建立出来，让外面的数据插入到表格中
创建student1表
create table student1(
sname varchar(20),
sage integer,
semall varchar(20),
sphone varchar(20),
saddress varchar(20)
)
2. 创建input.txt文件（数据文件）
目的：txt文件中是外部插入的数据，前提是txt中数据的格式和上面student1的格式相同，因为只有格式相同了数据才可以插入。
3. 创建input.ctl文件（控制文件）
目的：让input.txt中的数据加载到sdudent1中，该文件中可以指定输入的文件名、输入到哪个表中、各个字段是用什么符号间隔的等，都可以在里面进行设置。
4. 执行命令
注意：将input.txt数据文件和input.ctl控制文件放在一个f盘text文件夹中，注意了这里需要在test文件夹中执行命令，比如我将数据文件和控制文件放在F:/test文件夹下，那么在dos中需要切换到test下运行这个命令，命令格式为
sqlldr userid = 用户名/ 密码@数据库名 control=控制文件名
我执行的命令如下 如果成功了，得到如下的结果
运行成功后在test文件夹中会出现input.log文件，显示如下
5. 查看数据
操作：打开plsql developer，输入select * from student1，就会出现下图的结果，说明外部txt文件已成功导入到数据库。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26950579d4ef9e8abae05ba98a948e93/" rel="bookmark">
			直流电机PID调节——P
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实要用PID调节的话，最好是使用带有编码器的比较高端一点的直流减速电机，但是因为它价格有点贵，所以我们一般做智能小车就会选用普通的直流电机，但是普通的直流电机也是可以使用PID调节的，虽然它的效果没有带编码器得到直流减速电机的好，但是我们也可以在调节的过程中慢慢地深刻的理解PID调节的含义。今天先来分享一下我刚刚涉及的PID中的P调节。
P就是比例：Proportion 它直接影响的是我们整个系统的响应速度，P参数越大，系统对外界的响应速度越快，P参数越小，系统对外界的响应速度越慢，当然P也不是越大越好，P大的话，就会让我们的系统产生比较大的超调量，这当然不是我们想要的结果，所以说任何事物都要适度才好。
我们都知道，PID调节中的一个很重要的参数就是误差，误差顾名思义就是我们目标值和实际值的差值，而这个P就是直接作用于这个差值上的，我们来看下部分代码
void SetLeftSpeed(u16 LeftSet,u16 LeftReal)//入口参数：目标值，实际值 { static int LeftMotorPWM=0; int LeftError=0,LeftIncPWM=0; LeftError=LeftSet-LeftReal;//本次偏差等于目标值减去实际值 LeftIncPWM=(int)(LeftPID_Kp*LeftError); LeftMotorPWM+=LeftIncPWM; if(LeftMotorPWM&gt;=90) LeftMotorPWM=90; else if(LeftMotorPWM&lt;=10) LeftMotorPWM=10; SetLeftPWM(LeftMotorPWM); } 上面这个子函数就是我小车上左轮子的PID调节（里面只有P调节）。 我们需要注意的是里面的几个变量： 1、LeftMotorPWM：通过PID调节出来的要赋给电机的PWM，它是本次PID调节和前面所有的PID调节共同积累出来的数值，所以它需要用static来进行修饰，把它变成静态变量，并且它的值有正有负，所以我们定义成int，而不是unsigned int。 2、LeftIncPWM：本次通过PID调节算出来的PWM值，他不是直接赋给电机的PWM，它只是本次PWM算出来的值，这也就是它和LeftMotorPWM的区别了。LeftIncPWM也是有正有负，我们同样需要定义成int，但它不是静态变量。 3、LeftError：本次PID调节中目标值与实际值的差值，这是一个很重要的参数。同样他也是有正有负，我们把它也定义成int，它也不是静态的。
然后我们来看一条重要的语句
LeftIncPWM=(int)(LeftPID_Kp*LeftError); 这个说白了就是PID调节中的P调节，没错就这么简单的一条语句。 他其实就是在我们的本次目标值与实际值的差值上面乘上了一个参数，这个参数就是Kp，回想一下我开头说的那句话，P参数越大，系统的响应速度就越快，仔细想一下是不是这个道理，我们要给电机的PWM就是由目标值与实际值的差值来实时决定的，误差越大，计算出来的PWM就越大，误差越小计算出来的PWM就越小，而P参数就相当于一条直线的斜率，斜率越大，纵坐标对于横坐标的变化就越敏感，也就是系统对于外界的变化的响应速度越快。
接下来看一下调试数据 其中Kp*100就是我设置的P参数，为了显示方便，我是让真正的P参数乘以100之后再用串口打印出来，也就是说，此时真正的P参数是0.12，左轮值是测速模块（测速光耦）返回来的电机实际速度值（其实不是电机的实际速度，只是测速模块触发的外部中断次数，在这里我就先称它为电机实际速度，它是可以代表电机速度变化的一个数值，所以说我们现在没有必要再去用公式计算电机的物理实际速度），这个电机实际速度是统计周期是100ms，即我是统计100ms测速模块触发的外部中断的次数。 设定值就是我们的目标值，就是我们想要电机达到的速度值，这里我同样是用相对于测速模块触发外部中断的次数来进行设定的，然后PWM值就是PID调节之后要赋给电机实际的PWM数值。 从串口打印的数据我们可以看出，刚开始电机的速度是0，设定值时3，因为实际值没有达到设定值，所有PID调节中P调节就会使PWM值一直在增加，增加到我们测到了电机实际值最大为12，我们设定值时5，他现在加速到了12，这个12-5=7就是所谓的超调量。继续往后看串口的数据，我们就会发现，电机的实际值慢慢地又降下来了，最终稳定在了设定值（也就是5）的附近，这就说明达到了PID调节中P的效果。
然后我简单的用matlab画了一下速度的大概曲线，虽然不是很专业，但是将就着看看效果吧 从曲线上我们可以看到，最终速度会稳定在设定值5附近，当然他不会一直稳定在5，他会一直在5附近上下波动。
接下来我把P参数调大，再来看一下效果 从串口打出来的数据就可以看出来，P调大之后，系统的响应速度变得快了，即它现在可以花很少的时间就可以把速度调到我们的目标值，但是随之而来的缺点就是，它现在对于外界的变化过于敏感，以至于它调节出来的PWM值会不停地波动，或者我们来看左轮值，也就是电机的实际值，它没有像刚才那样基本稳定在我们的设定值5附近，而是变化很大，这就是所谓的抖动现象，造成抖动的原因就是P参数太大，这个时候我们就应该再把P参数调小一点，直到达到我们想要的效果。然后看一下matlab画出来的曲线 我们发现，我们把P调大之后，电机的实时速度和我们设定的速度的差值就变得大了，即曲线波形的振幅变得更大了。
在串口打印的数据中，由于我设定的目标值有点小，所以可能只通过数据看的不是很清楚，但是整体上可以大概反映出PID调节的效果，具体参数是个人情况而定。
PID中的P调节就说到这吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cd71f50140d7b33fd1777bc7153bda3/" rel="bookmark">
			深度学习之Softmax&amp;SVM  loss&amp;gradient公式图及其python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Softmax与SVM都是用来对数据进行分类的。Softmax常用于神经网络的输出层，SVM常常直接与SGD配合实现物体分类。无论是Softmax还是SVM在工作时都需要计算出loss和gradient，学习使用中发现两者有很多相似之处，特拿来对比学习。
公式 图解 scores是计算得到的分类得分公式中的s，y是ground truth python代码实现 """ Structured softmax and SVM loss function. Inputs have dimension D, there are C classes, and we operate on minibatches of N examples. Inputs: - W: A numpy array of shape (D, C) containing weights. - X: A numpy array of shape (N, D) containing a minibatch of data. - y: A numpy array of shape (N,) containing training labels; y[i] = c means that X[i] has label c, where 0 &lt;= c &lt; C.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cd71f50140d7b33fd1777bc7153bda3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f321d6bfad760f4d2914f1d6a4ee901b/" rel="bookmark">
			Echarts设置点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通常在使用Echarts画图之后会碰到一个需求，通过点击生成后图形具体某一项来传递相应的参数然后进行一个页面的跳转，当我遇到这个需求第一就想到了用on绑定点击事件的方法，然后就在代码上进行尝试，果然可以实现这个功能，我在这块展示的是一个柱状图，通过点击事件输出一下获取的参数可以得到什么结果呢？
代码如下：
myChart.on('click',function(params){ console.log(params); }); 我们通过点击柱状图的每一项可以看到输出了如下对应项的详细信息：
在这块我点击了8月份降水量，可以看到这块输出了，这一栏所对应的信息，包括名称seriesName：降水量，以及data值182.2，还以一些其他的信息，同样点击其他的也可以输出对应信息，这样我们就可以进行点击跳转并且传递对应的参数就ok了，这也是我首先想到的方法。
但是这个方法有一个不友好的地方就是只有用户点击到柱状图上它才会触发到这个点击事件，比如图中的一月份对应的数值就特别小，点击那一列的其他位置是没有作用的，只有点击阴影部分才触发，只一点对于用户来说就非常不友好，因此我找到了另外一种方法实现这个需求，通过点击所在值的这一列就会触发，实现代码如下：
myChart.getZr().on('click',function(params){ let point=[params.offsetX,params.offsetY]; if(myChart.containPixel('gird',point)){ let xIndex=myChart.convertFromPixel({seriesIndex:0}, point)[0]; let op=myChart.getOption(); let name=op.xAxis[0].data[xIndex]; } }) 这部分的代码可以实现点击某一列就能触发这个事件，主要的信息集中在op这个变量中，name变量是点击某一列对应的名称，使用时可以将这个变量打印出来然后选择所需要传递的参数，其实这个代码是通过鼠标点击图形的坐标来进行判断点击的位置属于哪一列，从而实现这个需求，在这块我在写的时候碰到一个问题，有一个图形点击一次总是触发两次这个函数，如果你也出现了这个问题可以通过在绑定事件之前加上一句代码。
myChart.getZr().off('click'); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f75f1be35bf681dbb66bff31f85362bc/" rel="bookmark">
			hadoop审计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://note.youdao.com/noteshare?id=2357666dd623ae0517318e75d0e3ebf9&amp;sub=8F0EF54044F64CB5A0B28EA3D58454BD
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fe86b1628ca3a377fa88cd0a315d6db/" rel="bookmark">
			hadoop鉴权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://note.youdao.com/noteshare?id=39ff6786436c894d2a585abb2cfb876b&amp;sub=4F93B83F28654F9595B58A1121B2E709
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cdabea289dbf7457503357e32736983/" rel="bookmark">
			隔离模块介绍-隔离信号模块-光耦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中涉及到强电和弱电混合设计，所以相关的“隔离”就显得尤为重要，以下是一些自己收集到的资料，本人能力尚浅，说错的地方敬请见谅。 这里将隔离模块分为隔离电源模块和隔离信号模块部分，分别以隔离电源模块和光耦为目标进行介绍，大部分数据都来自相应的数据手册，侵删！
隔离模块介绍-隔离信号模块-光耦 光耦的内容可能比较多，可能会从以下几个方面进行介绍：
光耦电阻的选择光耦电路的真值表光耦电路的应用
1.介绍 1.1普通光耦 来源：网上收集 光电耦合器亦称光电隔离器，简称光耦。光电耦合器以光为媒介传输电信号。它对输入、输出电信号有良好的隔离作用，所以，它在各种电路中得到广泛的应用。目前它已成为种类最多、用途最广的光电器件之一。光耦合器一般由三部分组成：光的发射、光的接收及信号放大。输入的电信号驱动发光二极管（LED），使之发出一定波长的光，被光探测器接收而产生光电流，再经过进一步放大后输出。这就完成了电—光—电的转换，从而起到输入、输出、隔离的作用。由于光耦合器输入输出间互相隔离，电信号传输具有单向性等特点，因而具有良好的电绝缘能力和抗干扰能力。 常用光糯合器内电路如图1所示。分为四引脚和六引脚两种。
1）四引脚的光糊合器的输入端为个发光极管，般由砷化嫁发光一极、磷化馈或磷砷闸化嫁等发光二极担任，①脚为正极，②脚为负极。输出端为光敏晶体管，③脚为光敏晶体管的发射极，④脚为光敏晶体管的集电极。2）六引脚的光稠合器的输人端①脚仍为发光二极管的正极，②脚仍为发光二极管的负极。输出端的③脚为空脚，④脚为光敏晶体管的集电极，⑤脚为光敏晶体管的发射极，⑥脚为光敏晶体管的基极。
图1所示光藕合器的内部电内部电路图 1.1线性光耦 来自：http://www.elecfans.com/yuanqijian/guangou/20180409659103.html
光隔离是一种很常用的信号隔离形式。常用光耦器件及其外围电路组成。由于光耦电路简单，在数字隔离电路或数据传输电路中常常用到，如UART协议的20mA电流环。对于模拟信号，光耦因为输入输出的线形较差，并且随温度变化较大，限制了其在模拟信号隔离的应用。
对于高频交流模拟信号，变压器隔离是最常见的选择，但对于支流信号却不适用。一些厂家提供隔离放大器作为模拟信号隔离的解决方案，如ADI的AD202，能够提供从直流到几K的频率内提供0.025%的线性度，但这种隔离器件内部先进行电压- 频率转换，对产生的交流信号进行变压器隔离，然后进行频率-电压转换得到隔离效果。集成的隔离放大器内部电路复杂，体积大，成本高，不适合大规模应用。
模拟信号隔离的一个比较好的选择是使用线形光耦。线性光耦的隔离原理与普通光耦没有差别，只是将普通光耦的单发单收模式稍加改变，增加一个用于反馈的光接受电路用于反馈。这样，虽然两个光接受电路都是非线性的，但两个光接受电路的非线性特性都是一样的，这样，就可以通过反馈通路的非线性来抵消直通通路的非线性，从而达到实现线性隔离的目的。
市场上的线性光耦有几中可选择的芯片，如Agilent公司的HCNR200/201，TI子公司TOAS的TIL300，CLARE的LOC111等。这里以HCNR200/201为例介绍。
HCNR201的结构及工作原理 HCNR201光电耦合器是一种由三个光电元件组成的器件，主要技术指标如下：
具有±5％的传输增益误差和±0．05％的线性误差；具有DC～1MHz的带宽；绝缘电阻高达1013Ω，输入与输出回路之间的分布电容为0．4pF；耐压能力为一分钟5000V，最大绝缘工作电压为1414V；具有0～15V的输入／输出范围。 HCNR201光电耦合器的内部结构如图1所示，其中LED为铝砷化镓发光二极管，PD1、PD2是两个相邻匹配的光敏二极管，这种封装结构决定了每一个光敏二极管都能从LED得到近似的光照，因而消除了LED的非线性和偏差特性所带来的误差。当电流流过LED时，LED发出的光被耦合到PD1与PD2，从而在器件输出端产生与光强成正比的输出电流。 在使用时，可将第3、4输出端与第1、2输入端一起接入控制回路，其中第3、4端的光敏二极管起反馈作用，它可将产生的输出电流再反馈到第1、2端的LED上，以对输入信号进行反馈控制。 工作原理 hcnr201的led、pd1及运放a1等组成隔离电路的输入部分，pd2及运放a2等组成隔离电路的输出部分。设隔离电路输入电压为vin，输出电压为vout，led上电流为if，二极管pd1上产生的电流为ipd1，二极管pd2上产生的电流为ipd2，如图2所示。 图2 线性光耦hcnr201模拟电压隔离电路 隔离电路中pd1形成了负反馈，当有电压vin输入时，运放a1的输出使led上有电流if流过，且输入电压的变化体现在电流if上，并驱动led发光把电信号转变成光信号。led发出的光被pd1探测到并产生光电流ipd1。同时，输入电压vin也会产生电流流过r1。假定a1是理想运放，则没有电流流入a1的输入端，流过r1的电流将会流过pd1到地，因此，ipd1=vin/r1。注意，ipd1只取决于输入电压vin和r1的值，与led的光输出特性无关。又因led发出的光同时照射在两个光敏二极管上，且pd1和pd2完全相同的，理想情况下ipd2应该等于ipd1。定义一个系数k，有ipd1=kipd2，k约为1±5%（当芯片制作完成后随之确定）。运放a2和电阻r2把ipd2转变成输出电压vout，有vout=ipd2r2，组合上面的3个方程得到输出电压和输入电压关系：vout/vin=kr2/r1，因此，输出电压vout具有稳定性和线性，其增益可通过调整r2与r1的值来实现，通常取r1和r2的值相同。
隔离电路中电阻r1起限流作用。r3用于控制led的发光强度，从而对控制通道增益起一定作用。电容c1、c2为反馈电容，用于提高电路的稳定性。运算放大器a1的作用是把电压信号转变成电流信号，运算放大器a2的作用是把光耦输出的电流信号转变为电压信号，并增强负载驱动能力。
线性光耦的使用实例（一） 在某随动检测系统中，需要用检测板对系统中的各电路板的参数进行监测，以对工作不正常的电路板给出故障指示，并用单片机来处理检测结果。由于实际工作环境比较恶劣，为了防止干扰信号由采集信道进入检测板及保证单片机系统工作正常，笔者采用光电耦合器来实现信号的传输。由于光电耦合器的发光二极管为电流驱动器件，因而应以电流环路的形式进行传送，而且电流环路是低阻抗电路，它对噪声的敏感度较低，因此提高了电路的抗干扰能力。有时干扰噪声虽有较大的电压幅度，但其能量小，所以只能形成微弱的电流，而光电耦合器输入部分的发光二极管是在电流状态下工作的，只有在通过一定强度的电流时才能发光，因此，即使有很高电压幅值的干扰，也会因其所形成的电流大小而被抑制掉。
在实际检测电路的某一采集信道中，如需对一组差动输入信号进行检测，可将电路接成如图3所示的连接方式。图中，通过放大器N1可将输入的差动信号变为单边信号后输出。由于二极管V1和V2的作用，当输入信号为正时，V2导通，V1截止，放大器N2呈开环状态，光耦N5工作，N4关断；而当输入信号为负时，则正好相反。当HCNR201的第3、4端的光敏二极管受光后，其输出信号将反馈到放大器的输入端，以提高光耦的线性并减少温漂。第5、6端输出的信号经运放放大后输出。电位器RP1的作用是调节运放输入偏置电流的大小。电容C2、C3为反馈电容，可用于提高电路的稳定性，消除自激振荡，滤除电路中的毛刺信号，降低电路的输出噪声，其容值可根据电路的频率特性来选取。放大器N6的作用是把光耦输出的电流信号转变为电压信号以供后级电路使用，并增强负载驱动能力，降低输出阻抗。调整电阻RP2的值可以调整信道的增益。 线性光耦的使用实例（二） 设输入端电压为Vin，输出端电压为Vout，光耦保证的两个电流传递系数分别为K1、K2，显然，，和之间的关系取决于和之间的关系。
将前级运放的电路提出来看，如下图所示： 设运放负端的电压为，运放输出端的电压为，在运放不饱和的情况下二者满足下面的关系：
Vo=Voo-GVi （1）
其中是在运放输入差模为0时的输出电压，G为运放的增益，一般比较大。
忽略运放负端的输入电流，可以认为通过R1的电流为IP1，根据R1的欧姆定律得： 其中，为光耦2脚的电压，考虑到LED导通时的电压（）基本不变，这里的作为常数对待。
根据光耦的特性，即
K1=IP1/IF （4）
将和的表达式代入上式，可得： 辅助电路与参数确定
上面的推导都是假定所有电路都是工作在线性范围内的，要想做到这一点需要对运放进行合理选型，并且确定电阻的阻值。
运放选型
运放可以是单电源供电或正负电源供电，上面给出的是单电源供电的例子。为了能使输入范围能够从0到VCC，需要运放能够满摆幅工作，另外，运放的工作速度、压摆率不会影响整个电路的性能.TI公司的LMV321单运放电路能够满足以上要求，可以作为HCNR200/201的外围电路。
阻值确定
电阻的选型需要考虑运放的线性范围和线性光耦的最大工作电流IFmax.K1已知的情况下，IFmax又确定了IPD1的最大值IPD1max，这样，由于Vo的范围最小可以为0，由于考虑到IFmax大有利于能量的传输，这样，一般取另外，由于工作在深度负反馈状态的运放满足虚短特性，因此，考虑IPD1的限制，这样，R2的确定可以根据所需要的放大倍数确定，例如如果不需要方法，只需将R2=R1即可。
另外由于光耦会产生一些高频的噪声，通常在R2处并联电容，构成低通滤波器，具体电容的值由输入频率以及噪声频率确定。
参数确定实例
假设确定Vcc=5V，输入在0-4V之间，输出等于输入，采用LMV321运放芯片以及上面电路，下面给出参数确定的过程。
确定IFmax:HCNR200/201的手册上推荐器件工作的25mA左右;
确定R3:R3=5V/25mA=200;
确定R1：;
确定R2:R2=R1=32K.
2.光耦电阻的选择 来自：http://www.360doc.com/content/16/1222/22/18548705_616929449.shtml
上面两图是型号为PS2501-1的电路原理图，是最基本的也是最常用的光耦的原理图，光耦内部由发光二极管和光电三极管构成，当发光二极管发光时，如果光强达到要求，光电三极管就会导通。
其中，1脚就是发光二极管的阳极，2脚就是发光二极管的阴极，3脚是三极管的发射极，4脚是三极管的集电极。
2.1发光二极管电阻的选择 数据手册中，IF是发光二极管的允许最大正向电流，值是80mA。这是需要考虑的第一个条件。 再看第二张图，VF是二极管上的电压，图中给出，当IF是10mA的时候，VF的值最大是1.4V。这是需要考虑的第二个条件。
我们需要考虑的第三个条件就是，你使用3.3V的电压驱动？还是用5V的电压驱动？
确定最小初级电阻 在手册中找到前向电压和前向电流的关系曲线，用来确定初级最小限流电阻。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cdabea289dbf7457503357e32736983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12adb879ba378c0d0c1b8ab25e3b3158/" rel="bookmark">
			scala中reduce函数原理解析------------------------------reduceLeft和reduceRight
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 看完图之后看具体实例
scala&gt; val list = List(1,2,3,4,5) list: List[Int] = List(1, 2, 3, 4, 5) scala&gt; list.reduce(_+_) res0: Int = 15 #这里0初始值，也是后面高阶函数的柯里化 scala&gt; list.fold(0)((x, y) =&gt; x+y) res1: Int = 15 #默认值是100 scala&gt; list.fold(100)((x, y) =&gt; x+y) res2: Int = 115 #步骤解析 (((((100+1)+2)+3)+4)+5) ((((101+2)+3)+4)+5) (((103)+3)+4)+5) ((106+4)+5) (110+5） 115 foldLeft(从左到右计算) foldRight（从右到左计算） #从右到左进行计算 scala&gt; list.foldRight("Hello")(_+_) res6: String = 12345Hello 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef84d1c91dec4772a9724af8c0743ee3/" rel="bookmark">
			自定义快捷键【个人常用】VBA代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Office2013版蓝色填充合并居中换行保存当前sheet全域字体格式色阶（绿）热力图（红-蓝） Office2019版热力图（红-蓝） Office2013版 蓝色填充 Sub FillBule() ' 快捷键: Ctrl+Shift+B With Selection.Interior 'interior：内部 .ThemeColor = xlThemeColorAccent1 'accent：强调 .TintAndShade = 0.8 'tint：色彩 End With End Sub 合并居中换行 Sub MergeCells() ' 快捷键: Ctrl+Shift+C Application.DisplayAlerts = False With Selection .HorizontalAlignment = xlCenter .VerticalAlignment = xlCenter .WrapText = True 'wrap：缠绕 .MergeCells = True 'merge：合并 End With Application.DisplayAlerts = True End Sub 保存当前sheet 修改bookname
Sub SaveSheet() ' 快捷键: Ctrl+Shift+S '声明 Dim newbook As Workbook, nowsheet As Worksheet, sheetname$, bookname$, ymd$ '赋值 ymd = [Text(today(), "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef84d1c91dec4772a9724af8c0743ee3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d043a838b27399bd63d58e77e6b92ca2/" rel="bookmark">
			TMOD、SCON、PCON寄存器的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TMOD控制寄存器 TMOD是定时器、计数器模式控制寄存器，它是一个逐位定义的8为寄存器，但只能使用字节寻址。 其各位是： 由上图我们就可以看出，这个寄存器控制了两个定时器/计数器 寄存器的高四位控制定时器1，低四位控制定时器0 GATE：门控制 GATE=0： 仅由TR0，TR1置位分别启动定时器T0、T1 GATE=1：由外部中断引脚INT0、INT1来启动定时器T0、T1 当INT0引脚为高电平时TR0置位，启动定时器T0； 当INT1引脚为高电平时TR1置位，启动定时器T1 C/T：功能选择位 C/T=0：定时功能 C/T=1：计数功能 M1、M0：工作方式选择位 如果我们同时使用定时器1和定时器0的时候，一定要注意对他们初始化的时候，不能够相互影响，即当我们配置好TMOD的低四位之后，再去配值TMOD的高四位的时候，一定不能破坏低四位的数据。
SCON控制寄存器 串行口控制寄存器，它用于控制串行通信的方式选择、接收和发送，指示串口的状态。SCON既可以字节寻址，也可以位寻址。 它的各位为： SM0、SM1：串行口工作方式控制位 其中我们在初始化串口通信的时候，最有用的就是SM0、SM1、SM0这三位了，具体配置如下： 一般情况下我们可以选择方式1。 SM2：多机通信控制位 多机通信是工作于方式2和方式3，即SM2主要用于方式2和方式3。当串行口工作于方式2或3，以及SM2=1时，只有当接收到第9位数据（RB8）为1时，才把接收到的前8位数据送入SBUF，且置位RI发出中断申请，否则会将接收到的数据放弃。当SM2=0时，就不管第9位数据是0还是1，都会将数据送入SBUF，并发出中断申请。 REN：允许接受位（一般配置为1） REN=1：允许接收 REN=0：禁止接收 TB8：发送数据位8（一般配置为0） 在方式2和方式3中，TB8是要发送的——即第9位数据位。在多机通信中同样亦要传输这一位，并且它代表传输的地址还是数据，TB8=0为数据，TB8=1时为地址。 RB8：接收数据位8（一般配置为0） 在方式2和方式3中，RB8存放接收到的第9位数据，用以识别接收到的数据特征。 TI：发送中断标志位 可寻址标志位。方式0时，发送完第8位数据后，由硬件置位，其它方式下，在发送或停止位之前由硬件置位，因此，TI=1表示帧发送结束，TI可由软件清“0”。 RI：接收中断标志位 可寻址标志位。接收完第8位数据后，该位由硬件置位，在其他工作方式下，该位由硬件置位，RI=1表示帧接收完成。
在配置串口初始化程序的时候，我们一般只用配置高四位，如果我们选择工作方式1，那么就是SCON=0X50；（SM0=0，SM1=1，SM2=0，REN=1）
PCON控制寄存器 PCON全称Power Control Register，即功率控制寄存器，我们在配置51单片机中的波特率的时候会用到它，其各位如下 系统复位默认为SMOD=0。当用51单片机的定时器2产生波特率时，波特率不受SMOD的影响。 各位的定义： SMOD： SMOD=0：串口方式1，2，3时，波特率正常 SMOD=1：串口方式1，2，3时，波特率加倍 LVDF：低电压检测标志位，同时也是低电压检测中断请求标志位 GF1、GF0：两个通用工作标志位，用户可以自由使用 PD：掉电模式设定位 PD=0：单片机处于正常工作状态 PD=1：单片机进入掉电模式可由外部中断或硬件复位模式唤醒，进入掉电模式后，外部晶振停振，CPU、定时器、串行口全部停止工作，只有外部中断工作。在该模式下，只有硬件复位和上电能够唤醒单片机。 IDL：空闲模式设定位 IDL=0：单片机处于正常工作状态 IDL=1：单片机进入空闲（Idle）模式，除CPU不工作外，其余仍继续工作，在空闲模式下可由任一个中断或硬件复位唤醒。
一般我们只用到了SMOD这一位，当我们选择波特率加倍的时候，就配置为PCON=0X80；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61c9f47bcc1ca8340434df8e3b92ebd9/" rel="bookmark">
			Python模块学习——logging
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		logging模块是在2.3新引进的功能，下面是一些常用的类和模块级函数
模块级函数
logging.getLogger([name]):返回一个logger对象，如果没有指定名字将返回root logger
logging.debug()、logging.info()、logging.warning()、logging.error()、logging.critical()：设定root logger的日志级别
logging.basicConfig():用默认Formatter为日志系统建立一个StreamHandler，设置基础配置并加到root logger中
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
import logging
import sys
LEVELS = {'debug': logging.DEBUG,
'info': logging.INFO,
'warning': logging.WARNING,
'error': logging.ERROR,
'critical': logging.CRITICAL}
if len(sys.argv) &gt; 1:
level_name = sys.argv[1]
level = LEVELS.get(level_name, logging.NOTSET)
logging.basicConfig(level=level)
logging.debug('This is a debug message')
logging.info('This is an info message')
logging.warning('This is a warning message')
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61c9f47bcc1ca8340434df8e3b92ebd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abd6f36d0cdf4b921c743e6fca1270ec/" rel="bookmark">
			安卓开发 Fragment的简单使用与解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Fragment的简介：
Fragment是Android3.0以后引入的新的api，为了适配大屏的平板。
在普通手机开发的过程中，使用Fragment能实现一个界面的多次使用，能加快效率。Fragment可以被认为是Activity界面的一个布局，其依赖于Activity，但是拥有自己的活动事件与生命周期。可以通过替换Activity中的Fragment实现界面的优化处理。
现在Android提供一下两种包，在一个项目中最好使用同一个包下的Fragment，否则会出现一些不兼容问题，例如V4包不支持属性动画，app包下的不支持逐帧动画等
android.app.Fragment 兼容的最低版本是android:minSdkVersion=”11” 即3.0版。
android.support.v4.app.Fragment 兼容的最低版本是android:minSdkVersion=”4” 即1.6版。
2.Fragment的生命周期，依赖于Activity
可以看到Fragment比Activity多了几个额外的生命周期回调方法：
onAttach(Activity)
当Fragment与Activity发生关联时调用。
onCreateView(LayoutInflater, ViewGroup,Bundle)
创建该Fragment的视图
onActivityCreated(Bundle)
当Activity的onCreate方法返回时调用
onDestoryView()
与onCreateView想对应，当该Fragment的视图被移除时调用
onDetach()
与onAttach相对应，当Fragment与Activity关联被取消时调用
也就是Fragment的创建与删除过程都是先链接（Attach）到Avtivity，再创建视图（View）
注意：除了onCreateView，其他的所有方法如果你重写了，必须调用父类对于该方法的实现
3.Fragment的三个常用类
android.app.Fragment 主要用于定义Fragment
android.app.FragmentManager 主要用于在Activity中操作Fragment
android.app.FragmentTransaction 对Fragment进行增加删除等操作
a.得到Fragment
getFragmentManager() // v4中，getSupportFragmentManager
b.使用FragmentTransaction 操作Fragment的基本用法
transaction.add() 往Activity中添加一个Fragment
transaction.remove()
从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈，这个Fragment实例将会被销毁。
transaction.replace()
使用另一个Fragment替换当前的，实际上就是remove()然后add()的合体
transaction.hide()
隐藏当前的Fragment，仅仅是设为不可见，并不会销毁
transaction.show()
显示之前隐藏的Fragment
detach()
会将view从UI中移除,和remove()不同,此时fragment的状态依然由FragmentManager维护。
attach()
重建view视图，附加到UI上并显示。
transatcion.commit()//提交一个事务，注意一定要在onSaveInstance()前面执行，否则会出现stateloss异常
上述，基本是操作Fragment的所有的方式了，在一个事务开启到提交可以进行多个的添加、移除、替换等操作
4.Fragment的使用
1.静态的使用
步骤：
创建fragment的xml
自定义Fragment继承自Fragment，在其中绑定fragment的视图，写fragment自己的事件
再Activity的xml中通过id引用该fragment
评价：
简单易用，直接引用对应的Fragment就好，但是如果一个屏幕中只有一个且需要切换Fragment就不方便使用。此时需要动态使用Fragment
静态使用Fragment的例子：
fragment_one.xml
&lt;RelativeLayout android:background="@color/colorAccent" xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abd6f36d0cdf4b921c743e6fca1270ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecfbe9d2a001cbcf1e719f96dd9cea01/" rel="bookmark">
			stm32学习笔记---ADC电压采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. ①电压输入范围
ADC 输入范围为：VREF- ≤ VIN ≤ VREF+。由 VREF-、VREF+ 、VDDA 、VSSA、这四个外部
引脚决定。
我们在设计原理图的时候一般把 VSSA 和 VREF-接地，把 VREF+和 VDDA 接 3V3，得到
ADC 的输入电压范围为：0~3.3V。
如果我们想让输入的电压范围变宽，去到可以测试负电压或者更高的正电压，我们可
以在外部加一个电压调理电路，把需要转换的电压抬升或者降压到 0~3.3V，这样 ADC 就
可以测量了。
2. ②输入通道
我们确定好 ADC 输入电压之后，那么电压怎么输入到 ADC？这里我们引入通道的概念，
STM32 的 ADC 多达 18 个通道，其中外部的 16 个通道就是框图中的 ADCx_IN0 、
ADCx_IN1...ADCx_IN5。这 16 个通道对应着不同的 IO 口，具体是哪一个 IO 口可以从手
册查询到。其中 ADC1/2/3 还有内部通道：ADC1 的通道 16 连接到了芯片内部的温度传感
器，Vrefint 连接到了通道 17。ADC2 的模拟通道 16 和 17 连接到了内部的 VSS。
ADC3 的模拟通道 9、14、15、16 和 17 连接到了内部的 VSS。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecfbe9d2a001cbcf1e719f96dd9cea01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/983fd01f81c1b1d12863bb51d63ad3c9/" rel="bookmark">
			cnpm 搭建私有库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境介绍： 1.mac(自带msq,就没有去额外的安装) 搭建方法： 1. npm install -g cnpm 2. npm install -g cnpmjs.org 3. 修改配置文件～/·cnpmjs.org/config/index 4. 配置文件如下： { "debug": false, // 是否启动 debug 模式 "enableCluster": true, // 是否启用 cluster 模式 "mysqlServers": [ // 数据库配置，以 mysql 为例 { "host": "host", "port": 3306, "user": "root", "password": "root" } ], "mysqlDatabase": "cnpmjs", // 数据库名 "enablePrivate": true, // 是否启用私有化，这样只有定义在 `admins` 中的用户才能发布 "admins": { // 管理员配置，可以配置多个 "senntyou": "jiangjinbelief@163.com" }, "syncModel": "exist", // 同步模式 "scopes": [ // 包前缀，如果不是以这个前缀命名的包将不能发布，可以配置多个 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/983fd01f81c1b1d12863bb51d63ad3c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/041c0e755cdb60bad2fabf2779209cf8/" rel="bookmark">
			title属性鼠标放在按钮上显示文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 title属性 &lt;div&gt; &lt;button title="我是要显示的文字"&gt;要显示的文字&lt;/button&gt;	&lt;/div&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4285897ec920c357e965211a2ae1b659/" rel="bookmark">
			HTML中字体加粗属性或标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 字体加粗属性 &lt;style type="text/css"&gt; .类名{ font-weight: 700;//加粗 font-weight: 400;//正常 } &lt;/style&gt; 字体加粗标签 &lt;b&gt; &lt;p&gt;我是字体加粗b标签&lt;/p&gt; &lt;/b&gt; &lt;strong&gt; &lt;p&gt;我是字体加粗strong标签&lt;/p&gt; &lt;/strong&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39765340f5c88e733bff50cea060fc07/" rel="bookmark">
			Error in render: &#34;TypeError: Cannot read property &#39;XXXXX&#39; of undefined&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近，小弟在使用vue开发界面时，出现一个有趣问题：功能正常使用，但F12却报出一个XXX Undefined的错误。这个错误已经见了无数次，于是果断去Ctrl+F搜索XXX,仔细浏览一圈后发现xxx明明是定义了的。整体流程：界面渲染前先通过mounted加载数据，然后绑定数据进行界面渲染。没毛病啊！难道是mounted偷懒了，果断换成created。但是还是有这个问题，为什么呢，在看一遍 嗯？难道是staff.staffCerd.certType没获取到值？去查询方法里alert（）一下。哎？有值啊！在看一遍，难道是staff.staffCerd.certType层数太多了？，改一下，改为一层 在查询方法里 手动赋值 我一运行，呀还真的不报错了，为什么呢，先记下解决过程，后续追寻原理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f3b2cc474b1ac28eb0bc11ebcb224b2/" rel="bookmark">
			win10-未知的USB设备-解决自己问题的记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若是没有解决你的问题，再找找其他办法看看
我也是网上搜的，刚好解决了我的问题我就记录了一下而已，哈哈哈
原文链接 [修复]未知的USB设备（设备描述符请求失败）在Windows 10中 1、设备管理器 -&gt; 通用串行总线控制器 -&gt; 未知USB设备(设备描述符请求失败)，右键属性（我这里没有未知USB设备，图片只是举例仅供参考）；
2、属性 -&gt; 详细信息，属性选择 设备实例路径，复制显示的值；
如：USB\ROOT_HUB30\4&amp;300F60A4&amp;0&amp;0
3、regedit 打开注册表，搜索路径：计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Enum\ + 第2步复制的值；
4、根据第2步复制的值，第2步复制的值，第2步复制的值（重要的事情说3遍）如
(好多小伙伴说找不到对应的值，这里一定要参考第2步复制的值，，每个机器的不一样，图片只是举例子，千万不要按部就班操作，会出意想不到的问题，同志们注意了，图片只是参考，根据第2步复制的值)
在Device Parameters下新建DWORD(32-bits) Value 命名为EnhancedPowerManagementEnabled。DWORD值数据应对应于0；
5、关闭注册表，拔下USB设备，重启电脑、重新插入设备，问题不应再持续存在。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30132339630814825d6ec433b0c55276/" rel="bookmark">
			Es查询（模糊，精确，多条件《模糊精确多条件查询》），修改，编辑，删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		----------------------------------------------配置文件jar-----------------------------------------------------------
&lt;!-- ES --&gt;
&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;transport&lt;/artifactId&gt; &lt;version&gt;6.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.21.0-GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.dropwizard.metrics&lt;/groupId&gt; &lt;artifactId&gt;metrics-core&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.hankcs&lt;/groupId&gt; &lt;artifactId&gt;hanlp&lt;/artifactId&gt; &lt;version&gt;portable-1.3.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.cn21&lt;/groupId&gt; &lt;artifactId&gt;Time-NLP&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/dependency&gt; 《------------------------模糊精确多条件查询------------------》
must : 相当于 MySQL and should ： 相当于MySQL or (效率低)
setExplain(true) 匹配顺序
BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); boolQueryBuilder.must(QueryBuilders.wildcardQuery("name", "*豆鼓焗带鱼*")).must(termQuery("foodType", "套餐")); SearchResponse response1 = EsUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30132339630814825d6ec433b0c55276/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13211a25679c55cb8adb0ffcdf6af55a/" rel="bookmark">
			M3DB存储引擎浅度探究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
M3组件
M3DB特性：
M3DB限制：
分布式机制
​
存储引擎
1.压缩算法
2. 内存架构布局
架构图
架构说明：
block分类
持久存储：
commitlog
snapshot
blocksize
灾难恢复
存储策略
写入
属性
简要流程
读取
属性
流程
后台进程
Ticking
Flush
大厂UBER背书过的M3存储解决方案共有4个组件:
M3组件 M3 coordinator
协调上游系统和M3DB之间的读写操作，长期存储和其他监控系统的多DC(数据库集群)设置
M3DB
M3DB是一个分布式时间序列数据库，提供可扩展存储和时间序列的反向索引。
M3 query
包含分布式查询引擎，用于查询实时和历史指标，支持多种语言。
支持低延迟实时查询和可能需要更长时间执行的查询，聚合更大的数据集，用于分析用例
M3 Aggregator
专用度量聚合器。
基于存储在etcd中的动态规则提供基于流的下采样。
它使用领导者选举和聚合窗口跟踪，利用etcd来管理状态，从而可靠地为地采样标准发送至少一次聚合到长期存储。
最关心的就是其中的M3DB。
M3DB特性： 1. 分布式存储，单个节点使用一个WAL日志，并独立保存每个shard的时间窗
2. 基于ETCD的集群管理
3. 内置同步赋值，可配置的耐用性和读一致性（1个，多数，所有，等等）
4. M3TSZ float64压缩算法，根据Gorilla TSZ启发而来。可配置成无损或有损耗
5. 时间精度可配置，从秒到纳秒
6. 可配置的无序写入，目前限制于blocksize的大小。
M3DB限制： M3DB目前支持基于ID的精确查找。它不支持标记/辅助索引。
这个特性正在开发中，M3DB的未来版本将支持内置的反向索引。
M3DB不支持更新/删除。所有写入M3DB的数据都是不可变的。
M3DB不支持任意写入时间。这通常用于监视工作负载，但对于传统的OLTP和OLAP工作负载可能是有问题的。M3DB的未来版本将更好地支持任意时间戳的写入。
M3DB不支持用双精度浮点以外的值编写数据池。M3DB的未来版本将支持存储任意值。
M3DB不支持存储具有不确定保留期的数据，M3DB中的每个名称空间都需要有一个保留策略，该策略指定该名称空间中的数据将保留多长时间。虽然这个值没有上限
M3DB不支持后台数据修复或CasDANRA样式的读取修复。M3DB的未来版本将支持数据作为正在进行的后台进程的自动修复。
分布式机制 m3coordinator
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13211a25679c55cb8adb0ffcdf6af55a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1365239f44cb99c6cf642776432644b1/" rel="bookmark">
			python提取具有某种特定字符串的行数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天又帮女朋友处理了一下，她的实验数据，因为python是一年前经常用，最近找工作，用的是c，c++，python的有些东西忘记了，弄的慢了一点，哈哈哈
好的，数据是这样的，我截个图
我用红括号括起来的，就是我所要提取的数据
其中lossstotal.txt是我要提取的原始数据，考虑两种方法去提取，前期以为所要提取行的数据是有一定规律的，后来发现，并不是，所以，我考虑用正则来提取，经过思考以后，完成了数据的提取，如下午所示，数据变的非常好看
代码如下：
#coding:utf-8 #__author__ ='dell' import re f1=file('losstotal.txt','r') data1=f1.readlines() # print data1 f1.close() results = [] f2 = open('loss2.txt', 'w') # # 按照特定行提取，发现后面的行并无规律 # i = 0 # for line in data1: # i+=1 # # print line # if((i-1)%3==0): # f2.write(line) # print line # 利用正则表达式 for line in data1: data2=line.split() # print data2 for i in data2: n = re.findall(r"Iteration", i) # m=re.findall(r"loss", i) if n: # print line f2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1365239f44cb99c6cf642776432644b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/454fbb0a2b727de6a73c1f370b4ab9d2/" rel="bookmark">
			软件测试学习教程（一）-学习路线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写这些，一些是个人总结与学习，一些是汇总他人经验与智慧，他山之石可以攻玉，无论如何，知识共享才是最终目的，希望可以为想入软件测试行业的小白明确学习的方向，也可以帮助工作多年的中高级工程师能查漏补缺，更欢迎能对文章体现的不当之处予以纠正，对不足之处加以补充，为后来者开辟道路，指引方向。
这个学习路线是某培训机构编制，但我看了之后综述觉得这个很详细，是以分享给大家
将软件测试的基础学习分为十个阶段：
第一个阶段：测试基础
第二个阶段：Linux和数据库
第三个阶段：功能测试
第四个阶段：Python编程
第五个阶段：Web自动化测试
第六个阶段：接口测试
第七个阶段：
第八个阶段：性能测试
第九和第十阶段：数据结构+Redis+单元测试+Shell
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/427/">«</a>
	<span class="pagination__item pagination__item--current">428/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/429/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>