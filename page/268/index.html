<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/261afd99542d5ea38c1f78465fbac1b3/" rel="bookmark">
			Windows11系统的分区调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前WIN10系统下的分区调整非常熟悉了，后续升级到WIN11也是必然趋势，毕竟历史车轮滚滚，技术也会不断升级换代，新买的电脑分区C盘直接给了200G，而总共500G的固态硬盘表示不能忍，调整到100G应该就可以了，WIN11的分区调整步骤如下：
1、我的电脑-&gt;右键属性
2、点击系统-&gt;存储-&gt;磁盘和卷(&amp;v)-&gt;windows(c)-&gt;属性
3、更改大小，在框里填写希望最终的大小，图中是100G
4、保存即可
5、返回上一步找到未分配，点击创建卷
6、点击格式化，即将从C盘分出来的空间，创建了一个新的分区
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f6065f0c830f36a012f2b03c6783f2b/" rel="bookmark">
			动态规划求解最长公共子序列、最大字段和、最长单调递增子序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.最长公共子序列问题描述最长公共子序列的结构子问题的递归函数计算最优值,最优解相关代码 2. 最大字段和问题描述最大字段和的结构子问题的递归结构相关代码 3.最长单调递增子序列问题描述最长单调递增子序列的结构实例相关代码 1.最长公共子序列 问题描述 给定序列X={x1,x2,…xm}和Y={y1,y2,y3…yn},找出X和Y的最长公共子序列
最长公共子序列的结构 假设序列X={x1,x2,… , xm }和Y={y1, y2 , … , yn}的一个最长公共子序列为
Z= {z1,z2 ,… ,zk }，则有
假设序列X={x1,x2,… , xm}和Y={y1, y2 , … , yn}的一个最长公共子序列为
Z={z,z2 ,.….,zk }
1)若xm=yn.则zk=xm =yn,且Zk-1是Xm-1，和Yn-1的最长公共子序列。
2)若xm≠ yn,且zk ≠ xm，则Z是Xm-1,和Yn的最长公共子序列.
3)若xm≠yn且zx ≠yn，则Z是X和Yn-1的最长公共子序列.
其中, Zk-1={z1, z2 ，… ,zk-1}，Xm-1={x1,x2,…xm-1},Yn-1={y1, y2 … yn-1}
子问题的递归函数 设Xi= {x1, x2 ,… ,xi } , Yj = {y1, y2 ,… , yi},用c[i]lj]记录Xi和Yj的最长公共子序列的长度，则原问题的最优值为c[m][n]。
根据最优解的结构,很容易得下列关于c[i][j]的递归方程:
一般情况,c[i][j]等于c[i-1][j]、c[i-1][j-1]、c[i][j-1]三者之一。用b[i][j]来记载c[i][j]的取值情况:
计算最优值,最优解 例:设X={A,B,C,B,D,A,B}，Y={B,D,C,A,B,A}由上述算法可求得c[i][j]和b[i][j]如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f6065f0c830f36a012f2b03c6783f2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c1e1cb2af151cf2177264b9d777fb46/" rel="bookmark">
			ELK--- Elastic Stack映射和数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Mapping映射介绍自动映射手动映射修改映射删除映射 ES数据类型String类型TextKeyword Number类型如何更好的使用Number？ Date类型Object类型Nested类型 Mapping映射介绍 概念：自动或手动为index中的文档建立的一种数据结构和相关配置，称为mapping映射。
如果很难理解，可以把ES中的文档想象成MySQL数据库中的Table表，而映射就是对表中的字段创建对应的数据类型。
一般来说，Mapping映射分为自动映射和手动映射。
自动映射 在第一次在插入数据时，ES自动创建索引，同时也会对插入的数据创建相对应的数据类型和分词器，我们将此称为自动映射。
演示：
插入一条数据
使用语法 GET /index/_mapping 查询映射。
{ "student" : { "mappings" : { "properties" : { "age" : { "type" : "long" }, "birthday" : { "type" : "date" }, "name" : { "type" : "text", "fields" : { "keyword" : { "type" : "keyword", "ignore_above" : 256 } } } } } } } 可以看到的是，我们并未对字段的数据类型进行定义，而在ES中，自动将name 定义为了text，age 定义为了long，birthday 定义为了date，这就是ES所提供的自动映射。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c1e1cb2af151cf2177264b9d777fb46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c69e8ec443e429599c4f8fad3a336757/" rel="bookmark">
			控制反转（IOC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.什么是Spring （两个最大特性:控制反转（IOC）和面向切面编程（AOP）） 1.spring是一个轻量级的非入侵的框架或容器更好理解
2.轻量级就是小，mybatis也是轻量级应用
3.非入侵是指引入他不会对你的程序造成什么影响反而会使你的代码更加简单
4.支持事务的处理 和 对框架的整合
二.首先是控制反转 控制反转是一种设计思想，ioc是控制反转的缩写，DI是实现控制反转的一种方法。
控制反转是一种通过描述（XML或注解）并通过第三方生产或获取特定对象的方式。
在Spring中实现控制反转的是IOC容器，其实现方法是DI（依赖注入）。
用配置文件将Bean交给spring管理。
无参构造 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="Hello" class="pojo.Hello"&gt; &lt;property name="str" value="我爱你"/&gt; &lt;/bean&gt; &lt;bean id="UserImpl" class="dao.UserImpl"/&gt; &lt;bean id="UserMysqlImpl" class="dao.UserMysqlImpl"/&gt; &lt;bean id="UserServiceImpl" class="service.UserServiceImpl"&gt; &lt;property name="userdao" ref="UserMysqlImpl"/&gt; &lt;/bean&gt; &lt;/beans&gt; IOC创建对象的方式为使用无参构造创造对象（默认实现）
假如使用有参构造 1.使用下标赋值（有参构造下标选中第一个参数）
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="Hello" class="pojo.Hello"&gt; &lt;constructor-arg index="0" value="我你"/&gt; &lt;/bean&gt; &lt;/beans&gt; 2.使用参数类型赋值但重复类型无法使用（不建议使用）
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c69e8ec443e429599c4f8fad3a336757/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5906b3f4b6f9660a8bcdf8c562e4ffa3/" rel="bookmark">
			Towards Open Vocabulary Object Detection without Human-provided Bounding Boxes(2021CVPR)----论文阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Towards Open Vocabulary Object Detection without Human-provided Bounding Boxes----论文阅读笔记 Abstract1. Introduction如何实现? pseudo bounding box label如何生成的? 2. Related Work3. Related Work3.1. Generating Pseudo Box Labels 3.2. Open vocabulary Object Detection with Pseudo LabelsExperiment Abstract 简单来说： 实现了无需人工提供边界框标注OVD检测框架
如何实现：预先训练的 vision-language 模型的 localization 能力和 生成可直接用于训练目标检测的伪边界框标签来实现这一点。
**效果：**在COCO新类别上，作者的训练没有配备手动bounding box标签 比使用了 人工标注bounding box 框进行训练的(SOTA)高出3%的AP，当使用bounding box标签作为我们的基线时，作者的方法超过SOTA 8%的AP。
1. Introduction 提及到了ZSD,OVD的检测方法，它们都需要基类有bounding box label。
作者的想法借力于 来自大规模弱对齐图像-标题对进行预训练的网络 得到的 视觉语言模型 Vision-language models。
它们在图像分类中表现出惊人的零镜头性能，在文本-视觉区域对齐任务(如引用表达式)中也表现出良好的结果，这意味着它们具有很强的定位能力
如何实现? pseudo bounding box label如何生成的? 从大规模图像标题数据集中自动获取不同对象集合的伪框标注。
具体地说，给定一个预先训练的视觉语言模型和一个图像-标题对，我们在图像中计算一个** activation map (Grad-
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5906b3f4b6f9660a8bcdf8c562e4ffa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54611b92afb29c6c62f884381511f947/" rel="bookmark">
			ELK--- Elastic Stack文档存储机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据路由增删改内部机制查询内部机制Bulk 存储的JSON格式传统的JSON数组：现有的特殊形式 数据路由 存储文档时应该存储到哪个分片上，ES通过数据路由来进行确定。
数据路由分为自动的路由算法或者手动指定。
路由算法 shard = hash(routing) % number_of_primary_shards 哈希值对主分片数取模
例如有三个主分片，当存储hash(id)=5的文档时，5%3=2，此时ES会将文档存储在shard2上，这就是路由算法。
手动指定
语法：PUT /index/type/id?routing=key 例如进行以下插入
PUT /stu/class1/1?routing=jerry { "name":"jack", "age": 18 } 此时ES会将其分配到一个主分片中，当再次插入到其它文档的routing的值为jerry，会将其存入同一个主分片中。
但是缺点是当设计的不合理的时候，会造成数据倾斜，大量数据堆积在同一个主分片。
因此不同文档尽量放到不同的索引中，剩下的事情交给ES集群自己处理。
增删改内部机制 对于增删改，统一可以看成是UPDATE，都是对数据的改动。
一个改动请求发送到ES集群，经历以下步骤:
客户端选择一个node发送请求过去，此节点作为coordinating node(协调节点)。协调节点对document(文档)进行路由，将请求转发给对应的node。实际的node上的主分片处理请求，然后将数据同步到副本分片上。协调节点如果发现主分片和所有副本分片都完成后，就返回响应结果给客户端。 查询内部机制 一个查询请求发送到ES集群，经历以下步骤:
客户端发送请求到任意一个node，成为协调节点。协调节点对文档进行路由，将请求转发到对应的node， 此时会使用round-robin随机轮询算法，在主分片以及其所有副本分片中随机选择一个，保证读请求的负载均衡。收请求的node返回文档给协调节点。协调节点返回文档给客户端。 特殊情况：文档如果还在建立索引过程中，可能只存在主分片有数据，任何一个副本分片都没有，此时可能会导致无法读取到文档，但是当文档完成索引建立之后，此时主分片和副本分片就都有了。
Bulk 存储的JSON格式 传统的JSON数组： [ { "action":{ "method":"create" }, "data":{ "id":1, "name":"java" } }, { "action":{ "method":"create" }, "data":{ "id":2, "name":"cpp" } } ] 这种JSON的表示形式是我们平常所用的形式，看起来比较直观，可读性较好。
但是对于ES来说，未必友好。
ES对于标准格式的JSON，需要按照下述流程去进行处理：
将JSON数组解析为JSONArray对象，此时整个数据会在内存中出现一份一模一样的拷贝，一份数据是JSON文本，一份数据是 JSONArray对象。解析JSON数组里的每个JSON，对每个请求中的文档进行路由。为路由到同一个分片上的多个请求，创建一个请求数组。将这个请求数组序列化 。将序列化后的请求数组发送到对应的节点上去。 这些会加大内存和资源的消耗，同时增加JVM的GC开销。JVM的垃圾回收次数频繁，导致ES的JVM停止工作线程的时间更多，从而大大降低效率和性能。
现有的特殊形式 POST /_bulk { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54611b92afb29c6c62f884381511f947/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90a5cdad2f11b88d2f944dbcf79b5930/" rel="bookmark">
			一个小破网站，比Pandas官网还好用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家好，我是早起。
在去年九月，我将Pandas120题升级到Pandas300题，意外的收获了很多好评，到目前总下载量有数千次。
伴随着刷题人数越来越多，很多粉丝问我能否提供一份查询版，让答案附在习题下面，就像这样👇
但整理出来之后发现使用反馈并不是很好，偶尔想查询一些小的操作都需要先启动 Jupyter Notebook ，再点开多层文件夹才能找到，十分繁琐。
此外，相信大家在搜索部分 pandas 操作时，并不难找到相关的帖子或者教程，但是在阅读这些文章时会有一个体验即看上去很过瘾，自己一操作就各种报错，加上有些作者并没有分享源数据，导致很多文章内的操作复现很难。
我也在阅读某些讲解时，常常会想要是能直接在这个页面执行一下该有多爽！
于是，干脆直接将这份习题做成了网页版 -&gt; 「图解Pandas」，一个重要的特点就是，大部分页面的代码支持在线执行
在线执行pandas
是不是很酷！就像上面视频演示的一样，无需跳转到其他网站，可以在感兴趣的单元格下直接执行对应代码，或者修改相关参数来验证你的想法。
当然，网页版不是用来刷题的，为什么叫 图解Pandas 呢？
从上面的视频中也可以看到，页面最上方有一张图解，如果你对这个函数不熟悉可以先一图看懂大致用法，再去学习具体操作。
这是考虑到很多新手朋友，我对一些核心章节（分组、合并、透视、聚合等）添加了过程图解，以方便更多刚接触 pandas 的用户快速上手
👇就像这样学习 groupby 和merge 是不是更加直观易懂？
除了在线执行和图解这两大新特点，我还加入了一些300题之外的内容，这就需要你自行探索了，最后是网址
pandas.liuzaoqi.com
复制上方网址到浏览器即可打开（建议在电脑端打开以获得最完美的体验，部分手机端无法很好的适配页面内容）
最后，如果你觉得做的不错，可以将这篇文章（网站）收藏并分享出去，让更多喜爱pandas的用户看到，我也会持续更新更多内容。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a5c7942362361e093c3133ba21a4f0f/" rel="bookmark">
			井字棋LeetCode简单题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定一个二维数组board，代表棋盘，其中元素为1的代表是当前玩家的棋子，0表示没有棋子，-1代表是对方玩家的棋子。当一方棋子在横竖斜方向上有连成排的及获胜（及井字棋规则），返回当前玩家是否胜出。
测试样例：
[[1,0,1],[1,-1,-1],[1,-1,0]] 返回：true class Board { public: bool checkWon(vector&lt;vector&lt;int&gt; &gt; board) { // write code here if(board[0][0] + board[1][1] + board[2][2] == 3 || board[2][0] + board[1][1] + board[0][2] == 3) return true; for(int i = 0; i &lt; 3; i++) if(board[i][0] + board[i][1] + board[i][2] == 3 || board[2][i] + board[1][i] + board[0][i] == 3) return true; return false; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc0ef18260b70597521524eca1b1e5f/" rel="bookmark">
			redis集群重新启动案例-步骤详细-有启动脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis集群重新启动案例
（启动脚本，在文末~~~）
切换root账户cd 到集群所在文件夹myapps，找到集群节点配置文件redis.conf里面指示的存放数据的dir，这里是同目录下的redis删除数据文件aof、rdb删除集群节点配置文件nodes*.conf关闭防火墙启动集群服务器脚本startall.sh启动创建集群脚本creat-cluster.sh选择任意节点，如：7001，启动redis客户端，并且指定集群，-cset几个key value，发现ok，并且分配到集群其他节点，对应的插槽cluster info ，查看集群信息，ok，正常用redis可视化工具，如redis desktop manage，查看redis节点存储值情况java连接redis，用Jedis包，版本要对应上，报错时多是版本不匹配导致 linux启动redis集群情况：
[water@centos-water001 ~]$ su Password: [root@centos-water001 water]# cd / [root@centos-water001 /]# cd /home/admin/myapps [root@centos-water001 myapps]# ll total 8 drwxr-xr-x. 3 root root 4096 Jan 6 01:27 redis drwxr-xr-x. 3 root root 69 Jan 4 21:48 redis1 drwxr-xr-x. 3 root root 69 Jan 4 21:53 redis2 drwxr-xr-x. 8 root root 4096 Jan 5 22:06 redis-cluster [root@centos-water001 myapps]# cd redis [root@centos-water001 redis]# ll total 100 -rw-r--r--.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dc0ef18260b70597521524eca1b1e5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07126b8bae3bada635df3c4d02bb2847/" rel="bookmark">
			SpringMVC中使用静态资源（css、js等）无法加载问题，需要开放资源访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于MVC通过前端控制器DispatcherServlet来帮我们找寻资源，生成资源路径。但由于静态资源没有对应的Controller路径，前端控制器找不到，所以会报错。
有2种解决方法
1.在核心配置文件spring-mvx.xml中加入静态资源的解析路径
&lt;mvc:resources mapping="/js/**" location="/js/"/&gt; 2.在核心配置文件spring-mvc.xml中添加默认的servlet处理器，让tomcat来为找不到资源路径的静态资源分配路径（SpringMVC找不到，让默认的tomcat来找）
&lt;mvc:default-servlet-handler/&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77fd4833c7bd2947f10bfe7418c854ae/" rel="bookmark">
			pandas中的read_csv参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.官网语法 pandas.read_csv(filepath_or_buffer, sep=NoDefault.no_default**,** delimiter=None**,** header='infer’, names=NoDefault.no_default**,** index_col=None**,** usecols=None**,** squeeze=False**,** prefix=NoDefault.no_default**,** mangle_dupe_cols=True**,** dtype=None**,** engine=None**,** converters=None**,** true_values=None**,** false_values=None**,** skipinitialspace=False**,** skiprows=None**,** skipfooter=0**,** nrows=None**,** na_values=None**,** keep_default_na=True**,** na_filter=True**,** verbose=False**,** skip_blank_lines=True**,** parse_dates=False**,** infer_datetime_format=False**,** keep_date_col=False**,** date_parser=None**,** dayfirst=False**,** cache_dates=True**,** iterator=False**,** chunksize=None**,** compression='infer’, thousands=None**,** decimal=’.', lineterminator=None**,** quotechar=’"', quoting=0**,** doublequote=True**,** escapechar=None**,** comment=None**,** encoding=None**,** encoding_errors='strict’, dialect=None**,** error_bad_lines=None**,** warn_bad_lines=None**,** on_bad_lines=None**,** delim_whitespace=False**,** low_memory=True**,** memory_map=False**,** float_precision=None**,** storage_options=None**)**
read_csv()函数在pandas中用来读取文件(逗号分隔符)，并返回DataFrame。
2.参数详解 2.1 filepath_or_buffer(文件) 注：不能为空
filepath_or_buffer: str, path object or file-like object 设置需要访问的文件的有效路径。
可以是URL，可用URL类型包括：http, ftp, s3和文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77fd4833c7bd2947f10bfe7418c854ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2a6398991798fbfd5fe0b3c63d83034/" rel="bookmark">
			pandas之apply函数简介及用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基本信息 ​ Pandas 的 apply() 方法是用来调用一个函数(Python method)，让此函数对数据对象进行批量处理。Pandas 的很多对象都可以使用 apply() 来调用函数，如 Dataframe、Series、分组对象、各种时间序列等。
2.语法结构 ​ apply() 使用时，通常放入一个 lambda 函数表达式、或一个函数作为操作运算，官方上给出DataFrame的 apply() 用法：
DataFrame.apply(self, func, axis=0, raw=False, result_type=None, args=(), **kwargs) 参数：
func：函数或 lambda 表达式,应用于每行或者每列
axis：{0 or ‘index’, 1 or ‘columns’}, 默认为0
0 or ‘index’: 表示函数处理的是每一列1 or ‘columns’: 表示函数处理的是每一行 raw：bool 类型，默认为 False;
False ，表示把每一行或列作为 Series 传入函数中；True，表示接受的是 ndarray 数据类型； result_type：{‘expand’, ‘reduce’, ‘broadcast’, None}, default None
These only act when axis=1 (columns):
‘expand’ : 列表式的结果将被转化为列。‘reduce’ : 如果可能的话，返回一个 Series，而不是展开类似列表的结果。这与 expand 相反。‘broadcast’ : 结果将被广播到 DataFrame 的原始形状，原始索引和列将被保留。 args: func 的位置参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2a6398991798fbfd5fe0b3c63d83034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd5b65060f48c060f3c45ce1ab2733a1/" rel="bookmark">
			百度智能云OCR获取APIKey和SecretKey
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先打开百度文字识别官网，输入百度账号登陆，一般来讲，你有百度网盘账号，就可以直接扫码登录了。
2.进入通用场景文字识别
3.领取免费资源
4.然后点击创建应用
5.应用名称，填你自己的应用名称
6.查看APIKey和SecretKey
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eae54b65413e77d30ce8c4a0d6e8c70/" rel="bookmark">
			Go-每日面试题目~（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：Go-每日面试题目~（四）
1、说说以下代码会输出什么内容？
func main() { defer_call() } func defer_call() { defer func() { fmt.Println("打印前") }() defer func() { fmt.Println("打印中") }() defer func() { fmt.Println("打印后") }() panic("触发异常") } 上述代码会先输出【打印前】，之后是【打印中】，再然后是【打印后】，最后则是panic内容【panic:触发异常】，原因也不复杂就是defer的执行顺序是后进先出，当出现panic语句时，会先按照defer的后进先出的顺序执行，最后才会执行panic。
2、以下代码将会输出什么？请简要说明原因。
func main() { slice := []int{0,1,2,3} m := make(map[int]*int) for key,val := range slice { m[key] = &amp;val } for k,v := range m { fmt.Println(k,"-&gt;",*v) } } 上述代码出现问题的原因是for range循环的时候会创建每个元素的副本，而不是元素的引用，所以m[key] = &amp;val取的都是变量val的地址，所以最后map中的所有元素的值都是变量val的地址，因为最后val被赋值为3，所有输出都是3。
至此，本次分享就结束了，后期会慢慢补充。
以上仅为个人观点，不一定准确，能帮到各位那是最好的。
好啦，到这里本文就结束了，喜欢的话就来个三连击吧。
扫码关注公众号，获取更多优质内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/954edda15d0470ca80386fb982c2eb7e/" rel="bookmark">
			Kerberos，安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装 kerberos基于client-server模式, 所以每台服务器都需要安装client, server挑一台服务器即可
yum -y install krb5-server krb5-libs krb5-workstation 配置文件
/etc/krb5.conf/var/kerberos/krb5kdc/kdc.conf/var/kerberos/krb5kdc/kadm5.acl 2. 配置krb5.conf vi /etc/krb5.conf kerberos可以有多个命名空间(realm)配置default_realm, 不指定realm时默认的命名空间ticket_lifetime, 票据有效时间, 默认1天renew_lifetime, 票据最大延期时间, 默认1周 3. 配置kdc.conf vi /var/kerberos/krb5kdc/kdc.conf 指定kdc监听端口88
4.初始化kerberos数据库 /usr/sbin/kdb5_util create -s -r EXAMPLE.COM 生成4个printcipal开头的文件
如果需要重建数据库, 将4个文件删除即可, 再次执行/usr/sbin/kdb5_util create命令
[root@localhost ~]# ll /var/kerberos/krb5kdc total 24 -rw-------. 1 root root 22 Nov 4 2016 kadm5.acl -rw-------. 1 root root 451 Nov 4 2016 kdc.conf -rw-------. 1 root root 8192 Nov 11 20:28 principal -rw-------.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/954edda15d0470ca80386fb982c2eb7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34dd5e7c6f10dfbb2225af54250cdb6b/" rel="bookmark">
			HT66F2390/STM32——AM2320温湿度传感器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、说明 AM2320 数字温湿度传感器采用单总线、标准 I²C 两种通信方式。本文主要基于HT66F2390单片机，采用单总线通讯，实现AM2320传感器数据获取。关于AM2320传感器的使用，可参考AM2320产品手册。在文章最后，分享了AM2320的相关资料，里面有我写的STM32的例程，大家可以参考一下。
2、AM2320单总线通讯 3、代码 下面是基于HT66F2390的AM2320传感器开发代码：
AM2320.h #ifndef __AM2320_H #define __AM2320_H #include "HT66F2390.h" //#include "sys.h" #include "Type.h" #define GPIO_AM2320 _pdc3 #define PIN_AM2320	_pd3 void AM2320_IO_OUT(void); void AM2320_IO_IN(void); void AM2320_DQ_OUT(u8 i); u8 AM2320_DQ_IN(void); u8 AM2320_Init(void); void AM2320_Rst(void); u8 AM2320_Check(void); u8 AM2320_Read_Bit(void); u8 AM2320_Read_Byte(void); u8 AM2320_Read_Data(float *temperature,float *humidity); #endif sys.h文件为系统时钟配置头文件，没用到可以不调用。
Type.h文件主要是结构体类型的重定义，方便后面调用。
Type.h typedef	unsigned char	u8; typedef	char	s8; typedef	unsigned short	u16; typedef	short	s16; typedef	unsigned long	u32; typedef	long	s32; AM2320.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34dd5e7c6f10dfbb2225af54250cdb6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0888e615195a3bf3fc62a86d82b5ad19/" rel="bookmark">
			ELK--- Elastic Stack内部机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 分布式机制的透明隐藏特性水平扩容与垂直扩容rebalance机制master节点节点对等的分布式架构shard&amp;replica机制单节点创建索引横向扩容 分布式机制的透明隐藏特性 分布式机制：分布式数据存储及共享(如何分配数据和共享ES已经帮我们实现)。分片机制：数据存储到哪个分片，副本数据如何写入ES已经帮我们实现。集群发现机制：新启动的ES实例，会自动加入集群。shard负载均衡机制：大量数据写入及查询，ES会将数据平均分配。shard副本机制：新增副本数，分片会重分配。 水平扩容与垂直扩容 假设原来有6台1TB的机器，现在需要8TB的ES集群。
水平扩容
新增两台1TB加入集群。
垂直扩容
使用2台2TB的机器替换原来的两台1TB机器。
由于成本的原因，在现实中常常采用水平扩容以节省成本。 rebalance机制 新增或减少ES实例或服务器负载不均匀时，ES集群会将数据重新分配。
master节点 master节点的作用主要是管理索引的创建与删除和节点的新增和减少。
默认情况下，ES会自定选择一台机器作为master。
当master宕机时，ES会选举出新的机器作为master(不必担心，老大是一直有的)。
节点对等的分布式架构 当系统随机向shard6请求id=1的数据时，shard6不存在id=1的数据，此时会自动向其它机器寻找，使得每个节点都能接收所有的请求，这就是节点对等。
shard&amp;replica机制 每个index包含一个或多个shard。每个shard都是一个最小工作单元，承载部分数据和完整的建立索引和处理请求的能力。增减节点时，shard会自动在nodes中负载均衡。每个文档(document)只存在于某一个主分片(primary shard)以及其对应的副本分片(replica shard)中，不可能存在于多个主分片。副本分片是主分片的副本，负责容错以及承担读请求负载。主分片的数量在创建索引的时候已经固定，副本分片的数量可以随时修改。主分片的默认数量是1，副本默认是1，默认共有2个分片，1个主分片，1个副本分片。
注意:es7以前主分片的默认数量是5，副本默认是1，默认有10 个分片，5个主分片，5个副本分片。主分片不能和自己的副本分片放在同一个节点上，否则节点宕机，主分片和副本都丢失，起不到容错的作用，但是可以和其它主分片的副本分片放在同一个节点上。 单节点创建索引 单节点环境下创建索引，有3个主分片，3个副本分片。此时集群status是yellow，因为副本分片不可用。3个主分片会分配到仅有的一个节点上，另外3个副本节点是无法分配，积压在内存中。集群可以正常工作，但是一旦出现节点宕机，数据全部丢失。 横向扩容 分片自动负载均衡，分片向空闲机器转移。每个节点存储更少分片，系统资源给予每个分片的资源更多，整体集群性能提高。扩容极限:节点数大于整体分片数，则必有空闲机器。超出扩容极限时，可以增加副本数，提高搜索性能和容错性。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/346000da8877a25e19f9d54587c078ed/" rel="bookmark">
			微信开发者工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.微信小程序测试号的申请
2.微信开发者工具的下载和安装
3.小程序项目的创建
4.微信原生框架目录结构
4.1.小程序结构与传统web对比 4.2.目录结构 5.小程序配置文件
1.微信小程序测试号的申请 官方网站：https://mp.weixin.qq.com/cgi-bin/wx
1.点击前往注册
2.我们可以看到右侧的立即申请，点击立即申请
3.扫码后在手机上确认申请就OK了！
2.微信开发者工具的下载和安装 下载地址：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html
点击选中的 Windows 64， 会发现文件正在下载
点击下载后的文件
双击，点击下一步
点击我接受 点击浏览选择自己想要存放的位置 点击安装后等待
点击完成，微信开发者工具就下载好了~
3.小程序项目的创建 选择小程序，点击 ＋ 这里我们测试阶段，点击测试号会自动绑定你刚刚申请的测试号
点击确定之后，就进入了我们创建好的小程序
这里由于我们用的是测试号，是测试阶段没有域名，但是实际上要做一个微信小程序是需要域名的，所以我们点击设置并选择项目设置，勾选所指的选项就可以进行下面的操作了
4.微信原生框架目录结构 小程序框架的目标是尽可能通过简单,高效的方式让开发者在微信中开发具有原生app体检的服务
题外话：有微信原生框架(MINA)，当然也有非微信原生框架，例如：uni-app/wepy/mpvue
学会原生框架，其它都搞得定，另外，非原生框架会被淘汰，而微信原生框架不会，除非腾讯GG了 4.1.小程序结构与传统web对比 结构 传统web 小程序
结构 html wxml
样式 css wxss
逻辑 js js(TypeScript)
配置 无 josn
注1：小程序除了使用JS还可以使用TypeScript进行开发。新问题：JavaScript与TypeScript有什么区别？
TypeScript是Javascript的超集，实现以面向对象编程的方式使用Javascript。当然最后代码还是编译为Javascript 题外话：Angular2是基于typescript来开发的JS框架 4.2.目录结构 1.主体结构
小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。
一个小程序主体部分(即app)由三个文件组成，必须放在项目的根目录，如下：
文件 必需 作用 app.js 是 小程序逻辑
app.json 是 小程序公共配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/346000da8877a25e19f9d54587c078ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ed1161861d02ff9597d1aa8c41753b9/" rel="bookmark">
			Spring boot 项目（十三）——实现微信公众号授权登录获取用户信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 微信公众号开发中，必不可少的一环：公众号授权登录、获取微信用户信息
前期准备 内网渗透=&gt;生成本地指定端口映射的外网域名 链接：内网渗透工具natapp使用详解
域名生成之后修改yml文件配置
申请并配置微信测试公众号 01、链接：点击申请微信测试公众号，并扫码关注测试公众号
02、备份appID和appsecret，后面需要用
03、接口配置信息修改（注：此处会回调后台签名验证方法，配置时需启动后台）
04、配置网页授权域名，用于获取微信用户信息
下载微信开发者程序进行测试 链接：微信开发者工具下载
代码部分 01、maven依赖
&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.54&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.github.binarywang/weixin-java-mp --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.binarywang&lt;/groupId&gt; &lt;artifactId&gt;weixin-java-mp&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.github.binarywang/weixin-java-common --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.binarywang&lt;/groupId&gt; &lt;artifactId&gt;weixin-java-common&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; 02、html
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt; &lt;title&gt;微信授权登录示例&lt;/title&gt; &lt;script src="http://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body style="text-align: center;"&gt; &lt;h2&gt;欢迎您：[[${session.userInfo?.nickname}]]!&lt;/h2&gt; &lt;hr/&gt; &lt;span&gt;用户信息：[[${session.userInfo}]]&lt;/span&gt; &lt;script th:inline="javascript"&gt; var sceneStr; var t; var userInfo = [[${session.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ed1161861d02ff9597d1aa8c41753b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57c145a555ec964796b52d3a3f5c1cfe/" rel="bookmark">
			什么是word embedding？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Word embedding 的任务是把词转换成可以计算的向量
https://easyai.tech/ai-definition/word-embedding/#representation
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55ce7ea06ac9a7100150f4b50de54ed7/" rel="bookmark">
			ubuntu下google浏览器安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌浏览器下载链接：
对于谷歌Chrome32位版本，使用如下链接： wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb 对于64位版本可以使用如下链接下载： wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb ​ 运行如下命令安装
sudo dpkg -i google-chrome* sudo apt-get -f install 然后，就可以去搜索使用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7601440f4961fa743d80c4160ad5669b/" rel="bookmark">
			什么是RPN，ROIAlign？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RPN RPN
RPN
RPN（Region Proposal Network）用来产生Regin Proposal（前景框，候选区域，检测框（Faster RCNN 直接拿来做检测框）
Regin Proposal
RoIPooling、RoIAlign 和 RoIWarp RoIPooling、RoIAlign 和 RoIWarp 这个非常好
ROI Pooling 步骤：量化----》池化
量化 池化 ROI 的缺陷在于 ， 量化会带来数据的缺失和新数据，池化也会缺失数据，这都会影响精度。
ROIAlign ROIAlign：RoI Align没有将量化用于数据池化
ROIAlign 最大的特点是，没有使用量化，而是使用双线性插值采样四个点进行对方框值求得。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d1f4603d670fbfe74d7f9a8e8aa8d90/" rel="bookmark">
			Qt控件--QComboBox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt控件--QComboBox QComboBox属性editable : boolcurrentText : QStringcurrentIndexmaxVisibleItems : intmaxCount : intinsertPolicy : InsertPolicysizeAdjustPolicy : SizeAdjustPolicyminimumContentsLength : inticonSize : QSizeduplicatesEnabled : boolframe : boolmodelColumn : int 增加项ui界面增加代码增加 QComboBox列表项的访问int currentIndex()QString currentText()QVariant currentData(int role = Qt::UserRole)QString itemText(int index)QVariant itemData(int index, int role = Qt::UserRole)int count()在一个QComboBox组件上选择项发生变化时，会发射如下两个信号： QComboBox QComboBox主要的功能是提供一个下拉列表供选择输入。
属性 Properties：
count : const int
currentData : const QVariant
currentIndex : int
currentText : QString
duplicatesEnabled : bool
editable : bool
frame : bool
iconSize : QSize
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d1f4603d670fbfe74d7f9a8e8aa8d90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203a49b8f34b57f4a844587679364e56/" rel="bookmark">
			python-pymysql-获取字段名称-获取内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取字段名称-获取内容 import pymysql # 连接数据库 db = pymysql.connect(host='192.168.254.109', user='root', password='123456', database='blog') # 使用cursor()方法创建一个游标对象 cursor = db.cursor() # 查询语句 sql = """select * from a""" # 执行 sql语句 cursor.execute(sql) # 查询全部 results = cursor.fetchall() # 获取表结构 cursor.description fields = [field[0] for field in cursor.description] # 序列化 成字典 zip 把两个可迭代对象合并成2维元组。然后用dict 转化为字典。 res = [dict(zip(fields, result)) for result in results] print(res) # 关闭游标和数据库的连接 cursor.close() db.close() pro_res = """ [{'id': 1, 'name': '111', 'create_time': datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/203a49b8f34b57f4a844587679364e56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ab028d7aa28afe0de5fd071fb9f206/" rel="bookmark">
			Kubernetes学习总结（17）—— Kubernetes 快速入门需要掌握的知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Docker Docker 是基于操作系统的沙盒技术，使得用户更简单和完整的去打包自己的应用。docker 底层是基于 Linux 的操作系统级别的虚拟化技术 LXC 实现；LXC 是通过 CGroup 实现了虚拟化资源管理，用来保证应用资源的隔离和应用系统资源的限制；服务器运行了多个服务，这些服务之间是可以互相影响的，其中的一个服务可以查看另外一个服务，这些是我们不愿意看到的，我们更希望同一台机器运行的服务能够完全隔离，互不影响就像运行在多台机器上一样。而 Linux 为我们提供了 NameSpaces 为我们提供了分离进程树、网络接口、资源挂载点的方法，docker 正是利用了 Linux 的 NameSpaces 技术实现了不同容器间资源的隔离；如果我们进入 docker 命令进入容器内部会发现只能看到当前容器的目录而不能看到原系统的目录，而 Linux 的 chroot 又称（change root）具有改变当前系统的根目录功能。docker 正是利用 chroot 的功能而实现了容器内部目录与原系统目录隔离的效果。通过 NameSpaces 文件系统、网络并与宿主机器之间的进程相互隔离，CGroup 实现了 CPU、内存等物理资源的隔离，docker 镜像本质上是一个基于 Linux 底层文件系统的压缩包，虽然 Docker 是最近几年流行起来但是 Docker 的核心技术其实已经有很多年的历史了，Linux Namespaces、CGroup 和 UnionFS 三大技术支撑了目前 Docker 的实现，也是 Docker 能够出现的最重要原因。
二、Docker-compose Docker-compose 是一个单节点编排技术。如果把 docker 比喻成一堆杂乱无章的集装箱，而 compose 能够对这些集装箱整理归类，作为一个整体启动运行，docker-compose 是以 docker 为核心进行构建的，本身只支持单节点编排，在复杂多变的生产环境是无法投入使用的。docker-compose 适合于需要多个容器相互配合来完成服务的运行，当我们在开发工作中遇到一个项目运行，需要多个服务配合甚至数据库、负载均衡等这个时候我们可以考虑使用 Compose 编排管理，提高部署效率。
三、Kubernetes 工业级的编排平台主要提供服务的部署、弹性和管理；Kubernetes是希腊语，翻译中文是“舵手、飞行员”的意思。k8s，省略中间8个ubernete替换为8，而得来k8s。如果说 docke 把应用打包成镜像，那么 Kubernetes 保证容器化应用简单高效运行。他跟 docker-swarm、moby 项目不同，它不在以 docker 为核心，而是把 docker 作为一个运行时组件，更多是提供应用部署，规划，更新，维护，在复杂多变的生产环境中，这些往往是我们更加需要的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43ab028d7aa28afe0de5fd071fb9f206/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fa265e45317b6b05622581287d34806/" rel="bookmark">
			python100天-字符串及切片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 根据python100天学习：​​​​​​https://github.com/jackfrued/Python-100-Days/
记录一下切片的一些内容
s1 = 'hello ' * 3 # 字符串重复输出n次 print(s1) # hello hello hello s2 = 'world' s1 += s2 # 字符串拼接符号：+ print(s1) # hello hello hello world print('ll' in s1) # True 字符包含在某变量内，会输出布尔型 print('good' in s1) # False 字符包含在某变量内，会输出布尔型 str2 = 'abc123456' # 从字符串中取出指定位置的字符(下标运算) ，和数组的下标类似，下标从0开始 print(len(str2)) #字符串长度为9，下标从0-8 print(str2[2]) # 输出下标2对应的信息，即第三位==&gt;c print(str2[-2]) # 输出倒数第二个字符，即第7位==&gt;5 # 字符串切片(从指定的开始索引到指定的结束索引) print(str2[2:5]) # c12 从下标为2的字符开始输出，截止到下标为4的字符，即含前不含后 print(str2[2:]) # c123456 从下标为2的字符开始输出，一直到最后一个字符 print(str2[:3]) #abc 从第一个字符开始输出，截止到下标为2的字符，即含前不含后 #str2 = 'abc123456' print(str2[2::2]) # c246 从下标为2的字符开始输出，步数为2，一直到最后 print(str2[1::4]) #b3 从下标为1的字符开始输出，步数为4，直到最后 print(str2[::1]) #abc123456 从最开始的字符开始输出，步数为1，直到最后。即挨着全部输出 print(str2[::2]) # ac246 从最开始的字符开始输出，步数为2，一直到最后。即跳一位输出一位 print(str2[::-1]) # 654321cba ::后跟的负数，代表逆序，即从最后一位，步数为1，一直到第一位。即逆序全部 print(str2[::-6]) # 6c ::后跟的负数，代表逆序，即从最后一位，步数为6，一直到第一位。 print(str2[-3::-1]) # 4321cba ::后跟的负数，代表逆序，即从倒数第三位开始，步数为1，一直到倒数第一位。 # 由于-3在-1前，故逆序从第三位输出到第一位 print(str2[-3:-1]) # 45 从倒数第三位开始输出，到倒数第二位，含前不含后 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7c8aac009c24a0831a32f538ac04255/" rel="bookmark">
			python100天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 根据python100天学习：​​​​​​https://github.com/jackfrued/Python-100-Days/
记录一下函数的一些内容：最大公约数和最小公倍数
# 最大公约数从最大的开始尝试 def big(x,y): (x, y) = (y, x) if x &gt; y else (x, y) for i in range(x,1,-1): if x%i ==0 and y%i ==0: return i # 最小公倍数从最大的开始到两数之积尝试 def mal(x,y): (x, y) = (y, x) if x &gt; y else (x, y) for i in range(y, x*y): if i % x == 0 and i % y == 0: return i #简便：最小公倍数 = 两数乘积 除以 最大公倍数 （涨知识了） def mal2(x,y): return x*y // big(x,y) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2062f5f8f7c4bc65c36f8313e098ac1/" rel="bookmark">
			Jrebel 教程：热部署插件提高代码调试效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文旨在提供一个方法，在 IDEA 下，使用热部署插件 JRebel ，解决代码调试过程中，编辑打包重启所占用的无意义时间
中大型项目的代码调试往往面临一个问题，只是简单的一两行代码修改，需要进行整个项目的重新编辑打包。而本地机器的性能，导致这种简单的代码修改，从发现问题到问题解决，往往需要以分钟计算的时间
作为懒癌晚期患者，对于这种情况实在是无法容忍，这使得效率低下，浪费时间
因此，我找到了一个热部署插件 JRebel ，可快速实现热部署，节省大量重启时间，解决项目的编辑打包所占用的无意义时间
配置 JRebel JRebel，我目前使用的编译器是 IDEA ，Eclipse 我已经很久没有用过了，我百度了下是支持的，有需要的可以自行搜索教程
在 IDEA 上打开插件市场查找 JRebel，第一个插件就是
这里要注意一点的是，插件市场不一定能打开，有时候需要科学上网
装好之后需要重启 IDEA，这个时候右侧会出现 JRebel的安装引导页，最开始的一项是使用许可，这个时候就需要生成许可地址了，富可敌国的同学可以支持下官方，我介绍下学习版
使用许可
在这个网站中生成一个GUID：在线GUID地址
以https://jrebel.qekang.com/{GUID}的格式填入第一行，比如http://jrebel.cicoding.cn:80/28997DD8-6FD0-3823-CA78-D98C7BECE9BC；第二行是邮箱随便填填，然后确认
使用配置
使用许可弄好了之后，下边几项都是说明，教你如何使用，我这里不展开，因为配置还没结束，在 IDEA 设置界面打开 JRebel的配置页，使其进行离线工作，不然每次线上验证卡住，就很尴尬
这个是热部署加载时间，我建议改短一点
记得打开 IDEA 的自动编辑
打开 IDEA 内的注册表，打开 IDEA 全局搜索 双击shift 搜 registry，翻下配置，打开热部署
使用 这两个按钮，对应原来的启动和调试，当使用它们启动及调试项目后，后续改动项目中的代码就不用重启整个项目了， JRebel 会自动热部署最新的代码，节省时间
怎么看新代码有没有部署好？改完代码， JRebel 热部署完成后，会在控制台输出日志
完
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a453409a10c570ce7823e1966d03e734/" rel="bookmark">
			计算机网络课后答案(谢希仁第八版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络课后答案(谢希仁第八版)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9004be87ed3af57337dab861212d9fed/" rel="bookmark">
			SEATA整合sharding-jdbc思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ 这里主要是参考了ShardingSphere官网的整合思路
​参考连接：https://shardingsphere.apache.org/document/legacy/4.x/document/cn/features/transaction/principle/base-transaction-seata/
​ 具体内容如下：
​ 整合Seata AT事务时，需要把TM，RM，TC的模型融入到ShardingSphere 分布式事务的SPI的生态中。在数据库资源上，Seata通过对接DataSource接口，让JDBC操作可以同TC进行RPC通信。同样，ShardingSphere也是面向DataSource接口对用户配置的物理DataSource进行了聚合，因此把物理DataSource二次包装为Seata 的DataSource后，就可以把Seata AT事务融入到ShardingSphere的分片中。
​ 解读：
​ 这里注意ShardingSphere分布式事务的SPI的生态中，已经提供了整合的实现类SeataATShardingTransactionManager，只需要导入对应jar包就可以使用了
&lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-transaction-base-seata-at&lt;/artifactId&gt; &lt;version&gt;demo里面用的4.1.1版本&lt;/version&gt; &lt;/dependency&gt; ​ 我们来看下SeataATShardingTransactionManager里面的内容：
// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package org.apache.shardingsphere.transaction.base.seata.at; import com.google.common.base.Preconditions; import io.seata.config.FileConfiguration; import io.seata.core.context.RootContext; import io.seata.core.rpc.netty.RmRpcClient; import io.seata.core.rpc.netty.TmRpcClient; import io.seata.rm.RMClient; import io.seata.rm.datasource.DataSourceProxy; import io.seata.tm.TMClient; import io.seata.tm.api.GlobalTransactionContext; import java.sql.Connection; import java.sql.SQLException; import java.util.Collection; import java.util.HashMap; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9004be87ed3af57337dab861212d9fed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7547ee64b985f3ff55973f1b8caa02b7/" rel="bookmark">
			IDEA: Internal error (java.lang.UnsupportedClassVersionError)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建spark项目后测试一个“hello word”，遇到一下错误。
Internal error (java.lang.UnsupportedClassVersionError): org/intellij/erlang/jps/model/JpsErlangModelSerializerExtension has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0
java.lang.UnsupportedClassVersionError: org/intellij/erlang/jps/model/JpsErlangModelSerializerExtension has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0
解决方案：关闭Erlang 插件，然后重启IDEA
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7547ee64b985f3ff55973f1b8caa02b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a5cce33ad8e9b283c59a0634dad387/" rel="bookmark">
			线扫相机的行频计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，变量的定义 首先设定以下变量：
（1）线阵相机的每线像素数（单位：pixel）：Hc
（2）目标物的宽幅（单位：m）：Lo
（3）目标物运行速率（单位：m/s）：Vo
（4）线阵相机线扫描速率（单位：Hz，即 线/s）：Vc
（5）扫描一帧图像目标物运行的时间（单位：s）：To
（6）扫描一帧图像线阵相机的扫描时间（单位：s）：Tc
（7）横向精度（每个像素代表的实际宽度）：PH
（8）纵向精度（每个像素扫描的实际长度）：PL
横向的扫描精度为：线阵相机的每线像素数/目标物的宽幅 即ph= Hc/( Lo)；
纵向扫描精度为：
[线阵相机线扫描速率（单位：Hz，即 线/s）*扫描一帧图像线阵相机的扫描时间（单位：s）]/
[目标物运行速率（单位：m/s）*扫描一帧图像目标物运行的时间（单位：s）]
PL=(Vc×Tc)/( 1pixel×Vo× To)（To=Tc）=(Vc)/( 1pixel×Vo)
要想成像条件好，需要横向分辨率和纵向分辨率相等
Lo/Hc=Vo/Vc
二，线扫速度的计算 根据“横向和纵向的分辨率相等”的原则，得到公式如下：Lo/Hc=Vo/Vc
则相机的线扫描速率为：Vc =(Hc ×Vo)/( Lo)，其中Hc是线阵相机的每线像素数， Lo目标物的宽幅，Vo目标物运行速率；
三，线阵相机的关键参数 resolution: 像素数， 传感器上有多少个像元。 MAX DATA RATE（应该叫相机时钟吧）： 意思是相机每秒可以采取最大的数据量 Linerate 行频： 意思是每秒钟相机最大可以采取多少行影像 比如线扫相机中一行的像素为8192，每秒可以获得的最大数据量是160Mhz
则行频为：160000000/8192=19000 line/sec
也可以理解为：
四，实例说明 电子铜带宽度450mm,生产线速度120米/分=120000mm/60s=2000mm/s，需要检测的最小缺陷是0.2mm；
横向的分辨率的计算选择线扫相机的分辨率：450/Hc=0.2mm/pixel-------&gt;Hc=450/0.2=2250,但是真正的相机拍照，直接达到这和精度是有难度的，所以选型一般是Hc=450/0.2*2=4500，按照相机的分辨率的规律，可以选择4096像素的线扫相机；
纵向的选择（关键参数是线扫相机的行频）：
根据上面的选型可以得到横向的分辨率：450mm/4096pixel=0.11mm/pixel
如果需要行和列的分辨率相等，则需要(2000mm/s)/(0.11mm/pixel)=18181line, 这样就可以推算出行频（意思是每秒钟相机最大可以采取多少行影像）满足18181line；
综上所述，相机的选型可以为行向分辨率4098，行频为19000的线扫相机即可；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd6eb5c78d0b54dacf551a410af2ba0c/" rel="bookmark">
			内网渗透工具——Natapp的注册和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Natapp简介 1、natapp 基于ngrok的反向代理软件，通过在公网和本地运行的 Web 服务器之间建立一个安全的通/道。
2、natapp 可捕获和分析所有通道上的流量，便于后期分析和重放。
3、通过 natapp 免费隧道，映射随机域名到本地指定端口，可用于第三方服务器回调测试完整闭环业务，例如：微信授权登录、微信支付、支付宝支付等。
Natapp注册 01、使用手机号完成注册：Natapp账号注册
02、实名认证，以便购买免费隧道
03、购买免费隧道（注：每个注册用户可以买两次免费隧道）
Natapp使用（生成公网域名） 01、下载 natapp 客户端：natapp.exe
02、进入客户端所在目录，执行cmd命令，输入下面的指令
natapp.exe -authtoken=xxxxxxxx 03、完成公网域名的生成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef0bfc0e61b7a79ced8d89edb2449d9e/" rel="bookmark">
			quartz 常规增删改查方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.controller封装
@RestController @RequestMapping("/api") public class SchedulerJobController { private Logger logger = LoggerFactory.getLogger(SchedulerJobController.class); @Autowired private SchedulerJobService schedulerJobService; /** * 获取所有任务 * @param pageNum * @param pageSize * @return */ @PostMapping("/getAllJobs") public Map&lt;String, Object&gt; getAllJobs(@RequestParam("pageNum") Integer pageNum, @RequestParam("pageSize") Integer pageSize){ logger.info("getAllJobs：Request{pageNum：" + pageNum + ",pageSize：" + pageSize + "}"); PageInfo&lt;ScheduleJob&gt; jobList = schedulerJobService.getAllScheduleJob(pageNum,pageSize); Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); resultMap.put("errCode",200); resultMap.put("errMsg","查询任务成功"); resultMap.put("jobList", jobList.getList()); resultMap.put("count", jobList.getTotal()); resultMap.put("begin", pageNum); logger.info("getAllJobs：Response" + JSON.toJSONString(resultMap)); return resultMap; } /** * 更新或者添加一个任务 * @param scheduleJobStr * @return * @throws Exception */ @PostMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef0bfc0e61b7a79ced8d89edb2449d9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add6952a57818db4407d8a34eb55b868/" rel="bookmark">
			使用MIB Builder 生成MIB文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件下载链接
链接：https://pan.baidu.com/s/1COMy6jdKLNTHJ5InvmIuzA 提取码：pcw2
安装软件 set-up.exe
点击菜单File—&gt;New—&gt;SMIv2 MIB Module
3、在Module name框中输入模块名称，点击Apply
4、导入父OID结点所在的mib模块，此处我需要创建一个位于"enterprises"下的一个私有结点2020，因此需要导入"enterprises"所在的模块SNMPv2-SMI
点击菜单File—&gt;Import，找到mib浏览器安装目录下的MIB Browser/MIB/SMI目录下的SNMPv2-SMI.my文件，打开
5、将"enterprises"结点插入到我们自己的模块中
在导入的SNMPv2-SMI模块的enterprises结点上右键—&gt;Copy
切换到自己的模块MyTest-MIB窗口，在根节点"MIB Tree"上右键—&gt;Paste 此时系统将提示"结点不能被链接到树中，因为无该结点的父结点，是否导入所有丢失的父结点?"
选择"是"，即可将enterprises结点导入我们的文件中
粘贴完成后就可以在enterprises下面新增私有节点了
6、新增节点
1、新增-非叶子节点
将右边"SMIv2 Components"中的MODULE-IDENTITY拖拽到enterprises节点下，Name编辑框输入自定义名字"myModule"，节点OID为自定义为2020 将右边的的OBJECT-IDENTIFIER拖拽到节点如myModule节点下，Name编辑框输入自定义名字"myOid"，节点OID为自定义为1
2、新增叶子节点，新增一个标量
将右边"SMIv2 Components"下的"OBJECT-TYPE(Scalar)"拖到结点如"myOid"结点下，Name编辑框输入节点名字如"myScalar"，OID编辑框输入我们希望的OID值如1，
再根据需要设置节点的读写属性(Max Access)、节点的类型(Status)，节点的状态(Syntax)等
3、新增表格
3.1、将右边"SMIv2 Components"下的"OBJECT-TYPE(Table)"拖到结点如"myOid"结点下，Name编辑框输入希望的名字如"myTable"，OID编辑框输入OID值如2，
再根据需要设置其它的属性。需要注意的是结点名称必须以"Table"结尾。 3.2、将右边"SMIv2 Components"下的"OBJECT-TYPE(Row)"拖到上一步新建的"myTable"结点下，Name和Child编辑框不允许输入，由系统默认设置，根据需要可设置其它的属性。
3.3、添加索引index
添加字段 将右边"SMIv2 Components"下的"OBJECT-TYPE(Columnar)"拖到上一步新建的"myEntry"结点下，Name编辑框输入希望的名字如"myIndex"，OID编辑框输入我们希望的OID值如1，再根据需要设置其它的属性。
将字段设置为索引 选择"myEntry"结点，在右边的属性设置窗口中左下角的下拉框中选择"Index"，点击右边的浏览按钮
在弹出的对话框中将希望做索引的结点如myIndex结点选择到"Selected indexes"列表框中，最后点击OK 设置索引取值范围 索引需设置取值范围，点击Syntax右边的浏览按钮
选择Value of Range ，输入取值范围如1 、10000 ，点击Add按钮，设置取值范围，完成后点击OK
3.4、新增表格列结点：将右边"SMIv2 Components"下的"OBJECT-TYPE(Columnar)"拖到上一步新建的"myEntry"结点下，Name编辑框输入希望的名字如"myCol1"，OID编辑框输入我们希望的OID值如2，再根据需要设置其它的属性。
3.5、重复第3.4步加入其它列结点。 4、将叶子节点添加到group中
将右边"SMIv2 Components"下的"OBJECT-GROUP"拖到myOid结点下，Name编辑框输入希望的名字如"myGroup"，OID编辑框输入我们希望的OID值如3。
点击Objects右边的浏览器按钮
在弹出的对话框中，删除右边列表框中的"object1"，将左边列表框中的节点"myScalar"、"myIndex"、"mycol1"、"mycol2" 加入右边列表框中，点击OK
7.进行正确性检查
点击Tools—&gt;Check SMI Consistency按钮，即可看到检测结果。如下为检测通过
8、预览mib文件：点击菜单File-&gt;Export Preview
9、生成mib文件：点击菜单File-&gt;Export
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9992a951af26508fcea60aca7d7d330f/" rel="bookmark">
			Windows10系统添加虚拟网卡(Microsoft Loopback Adapter)的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、按下win + R键，在其中输入：hdwwiz，然后 （enter）
2、点击下一步即可
3、其次选择【网络适配器】，然后点击【下一步】。
4、在厂商处选择Microsoft，网络适配器处选择【Microsoft Loopback Adapter】选项 ，点击【下一步】。 5、通过上面几个步骤的设置后，一块虚拟网卡的安装设置就算是完成了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/720b3aa5603c6062cbef06489023a158/" rel="bookmark">
			AlphaFold2算法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正文：https://www.nature.com/articles/s41586-021-03819-2
补充文件：https://static-content.springer.com/esm/art%3A10.1038%2Fs41586-021-03819-2/MediaObjects/41586_2021_3819_MOESM1_ESM.pdfhttps://static-content.springer.com/esm/art%3A10.1038%2Fs41586-021-03819-2/MediaObjects/41586_2021_3819_MOESM1_ESM.pdf学习视频（强烈推荐）：
【公开课】基于AI预测蛋白质折叠的三维空间结构——AlphaFold2原理及安装使用_哔哩哔哩_bilibili
1. 搜索同源序列和模板： 去按序列数据库以及PDB数据库中去搜索同源序列和模板
给定序列A，到Uniref90、MGnify、Uniclust30、BFD数据库中搜索他的同源序列，从Unire90中得到MSA。然后到PDB70中搜索同源模板得到对应的mmCif文件
1）当相似度高于50%，常推测检测序列和目标序列有可能是同源序列。
2）MSA
MSA是Multiple Sequence Alignment的缩写，即多序列对齐，这个技术用于从一个大的数据库中抽取和输入氨基酸序列相近的序列，并且顺便进行对齐。抽取这个特征的原因是类似的氨基酸序列一般来说折叠方式也类似，相当于在特征中就加入了相近的序列结构信息。
这里我们举个例子，HHblit工具也可以用来做MSA，在网站中输入用于举例的59个氨基酸组成的序列，HHblit工具就会在数据库中开始搜索序列与之相近的氨基酸序列，并且进行对齐。检索完成后会显示查询结果，而这些氨基酸序列与输入序列的对齐也会作为输出的一部分：
那么这样一来，这些比较接近的氨基酸序列和其结构也可以作为特征的一部分来辅助模型判断，这是一个很典型的将专家知识加入机器学习系统的方法。作者也提到如果不加上MAS特征，准确率会掉将近10个点。所以MSA特征是AlphaFold的一个重要组成部分。
2 特征构造 通过同源序列和模板表示成深度学习可以作为输入的矩阵结构
21：one-hot+unknown
49：
25：
剩下的维度没看明白。
3 特征表示 用这6个矩阵构造MSA和pair respresentation矩阵
如下图，MSA包含了多物种信息特征，pair representation只包含一个物种的信息
Input feature embeddings. Dimension names: r: residues, f: features, c: channels, sc: clustered MSA sequences, se: extra MSA sequences, st: template sequences.
4 MSA表示与残基对表示之间互换交换信息 由于物种进化的共变信息是蛋白质结构预测的重要信息来源，将共变信息融合到单一物种是通过Evoformer结构实现的。
1）从MSA中提取蛋白质的共变信息
a. MSA row-wise gated self-attention with pair bias
每次取一条（行）序列进行更新：self-attention并加入残基对的信息,构建残基之间的进化关系 。
b. MSA column-wise gated self-attention
每次取1列：来自不同序列的相同残基交换信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/720b3aa5603c6062cbef06489023a158/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77fabf287982de633d68bdc28d7d4c65/" rel="bookmark">
			使用for循环打印出大写字母的ASCII码对照表（c语言实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大写字母对应的ASCII码如下：
A → 65 B → 66 C → 67 D → 68 E → 69
F → 70 G → 71 H → 72 I → 73 J → 74
K → 75 L → 76 M → 77 N → 78 O → 79
P → 80 Q → 81 R → 82 S → 83 T → 84
U → 85 V → 86 W → 87 X → 88 Y → 89 Z → 90
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77fabf287982de633d68bdc28d7d4c65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b2377a8bc4cd78831a4573ef57c3449/" rel="bookmark">
			Python实现归一化和标准化处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python实现归一化和标准化处理 1）归一化处理 将数据归一化到[0 , 1]；
公式：
代码：
import pandas as pd #加载数据 df_test = pd.read_csv("./result.csv") #归一化处理 df_test = df_test.apply(lambda x: (x - np.min(x)) / (np.max(x) - np.min(x))) 2）标准化处理 标准化后的数据是均值为0，方差为1的正态分布。
公式：
代码：
import pandas as pd #加载数据 df_test = pd.read_csv("./result.csv") #标准化处理 df_test = df_test.apply(lambda x: (x - np.mean(x)) / np.std(x)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101b17a12e21fa0ef95d58df471e8dfa/" rel="bookmark">
			Webpack学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前端项目的本质无非就是一个HTML文件。在前端刚兴起的时候，大家都将前端代码写在一个HTML文件中，里面的style标签用于写css样式或者使用link标签进行引入，script标签用于写js代码或者使用script标签进行引入。但是这样写代码会出现一些弊端，比如引用的css包和js包过多就会出现页面卡死和引用前后顺序难以管理等情况，这无疑是致命的缺点。于是人们都在想解决办法，后来AMD和commonJS应运而生，他们都致力于前端模块化开发，再到后来更加完整、强大、工程华、现代化的webpack诞生了。
webpack的官网解释是：本质上，webpack是一个用于现代JavaScript应用程序的静态模块打包工具。对于一开始接触前端的人来说，无非就是js+html+css，而浏览器只能认识这三兄弟，也许这个时候你会问，既然浏览器只认识这三兄弟，那么我们现在用的less、sass、ts、tsx等文件是怎么被浏览器认识的？这是webpack的功劳，是webpack将这些乱七八糟的东西统统打包为一个或几个js文件给浏览器读取。
下面我将记录一下webpack常用的名次解释。
publicPath：publicPath翻译过来就是公共路径，不错，它的确是一个公共路径，它提供了一个所有资源的基础路径。plugin和loader的区别：loader翻译过来是加载器，它是针对文件的，比如less-loader的作用是将less转为css，css-loader是将css转为style。而plugin翻译过来是插件，它是对webpack功能的扩充，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行任务。比如说CleanWebpackPlugin用于每次打包前清理上次的dist文件夹，HtmlWebpackPlugin用于生成html文件入口。webpack's Watch Mode、webpack-dev-server和webpack-dev-middleware的区别：我们每次编译了代码都需要手动build，这很麻烦，在自己学习webpack之前使用的是vue或者react脚手架来创建的项目，在使用这些工具创建项目的时候，只需要执行npm start就可以得到一个ip地址，本地代码保存一下页面就会同步更新，这些都是webPack做的。其中webpack's Watch Mode代表观察模式，build一次之后就不会退出命令行，一直在“监听”代码的变化，缺点是想要看到修改后的效果需要刷新浏览器。webpack-dev-server与webpack's Watch Mode有本质的不同，它为我们提供了一个简单的web服务器，而不在是通过文件协议（文件协议不能使用ajax访问资源）打开的网页，并且可以无需刷新浏览器就可以看到最新的修改结果。webpack-dev-server是实际上相当于启用了一个express的Http服务器+调用webpack-dev-middleware。HMR：HMR即Hot Module Replacement是指当你对代码修改并保存后，webpack将会对代码进行重新打包，并将改动的模块发送到浏览器端，浏览器用新的模块替换掉旧的模块，去实现局部更新页面而非整体刷新页面。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17681c47a5e4db4f5de2c92409df9567/" rel="bookmark">
			STM32F103VCT6 Keil工程配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键是对“options for targets..”配置，重点关注配置其中的页面：Device/Target/Debug，及Debug里的Settings配置，使用的Keil软件版本：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/385b22057a01e1d9d109f563d9e9fbe4/" rel="bookmark">
			C/C&#43;&#43;调试总结：IDE（visual studio和Dev C&#43;&#43;）和GDB使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、IDE调试总结二、GDB调试教程：1小时玩转Linux gdb命令 GDB是什么？GDB是什么 GDB下载和安装教程快速安装GDB源码安装GDB 如何在Windows平台上安装GDB调试器？MinGW安装GDB调试器1、在线安装GDB调试器2、手动安装GDB调试器3、修改PATH环境变量 GDB调试C/C++程序使用GDB的前期准备启动GDB调试器 调用GDB调试器的4种方式调用GDB的方式2) 调试尚未执行的程序3) 调试正在执行的程序4) 调试执行异常崩溃的程序 GDB调试器启动可用参数 gdb run（r）命令：启动程序GDB break（b）：设置断点GDB break命令GDB tbreak命令GDB rbreak 命令总结 GDB watch命令：监控变量值的变化watch命令的实现原理 GDB catch命令：建立捕捉断点GDB条件断点（condition命令）详解GDB condition命令GDB ignore命令 GDB单步调试程序GDB next 命令GDB step命令GDB until命令 如何使用GDB进行断点调试？GDB finish和return命令GDB jump命令 GDB print和display命令：查看变量的值GDB print命令GDB display命令 GDB禁用和删除断点查看当前已建好的断点GDB删除断点1) clear命令2) delete 命令 GDB禁用断点 如何用GDB调试多线程程序？GDB查看所有线程GDB调整当前线程GDB执行特定线程GDB为特定线程设置断点GDB设置线程锁 GDB调试多进程程序GDB attach命令调试进程GDB显式指定要调试的进程GDB follow-fork-mode选项GDB detach-on-fork选项 一、IDE调试总结 之前的博客已经讲解了使用IDE进行调试的方法：
C语言调试教程总结（以visual studio和Dev C++为例）
Dev C++调试程序方法详解
但是在linux环境下，一般我们是使用GDB来进行调试，下面我们就对GDB的使用方法进行讲解。
二、GDB调试教程：1小时玩转Linux gdb命令 GNU symbolic debugger，简称「GDB 调试器」，是 Linux 平台下最常用的一款程序调试器。GDB 编译器通常以 gdb 命令的形式在终端（Shell）中使用，它有很多选项，这是我们要重点学习的。
发展至今，GDB 调试器已经对 C、C++、Go、Objective-C、OpenCL、Ada 等多种编程语言提供了支持。实际场景中，GDB 更常用来调试 C 和 C++ 程序，虽然 Linux 平台下有很多能编写 C、C++ 代码的集成开发工具（IDE），但它们调试代码的能力往往都源自 GDB 调试器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/385b22057a01e1d9d109f563d9e9fbe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67350d7e0fb3bac465a27c1936eb5f5c/" rel="bookmark">
			区块链知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简述一下区块链的分叉技术
分叉技术：主要用于区块链系统的更新，又分为软分叉和硬分叉
软分叉：就是小更新，新的代码逻辑依旧可以兼容之前版本。用户可以自行选择是否更新系统版本，
硬分叉：大更新，新的代码逻辑不能兼容之前的版本，并且要求用户强制更新，不更新的话就不能保证用户的正常使用。
2.说明默克尔树的作用和生成过程
默克尔树的作用用于快速校验交易的正确性，并且推算出交易信息。
生成过程图：（两两相加，单个复制）
3.说明所知道的共识算法
分布式共识算法： raft算法，
基于图结构的共识算法： tangle、 hashgraph、
竞争式的共识算法：pow工作量证明算法、 pos股权类证明、 po*凭证类共识算法、
协作式的共识算法：BFT拜占庭容错算法、 PBFT实用拜占庭容错算法、
结合硬件的共识算法： 结合可信执行环境的共识算法。
4.区块链中哈希算法的作用
hash主要是将不定长的字符串转换成固定长度的字符串，并且他不可还原，安全
1、用于构建默克尔树，实现内容的快速检测。想要验证交易信息，只要判断默克尔树根值即可。
2、构建区块链的链式结构，防止篡改
5.区块链智能合约的流程
智能合约流程： 先制定一套电子合约标准，然后基于特定的事件，只要满足事件的规则，合约自动执行。
主要组成部分： 智能合约 + 预置触发条件 + 获取结果途径 + 预置响应事件
注意：虽然合约是写死的，但并不是不好的，因为他严格执行。
区块链中利用智能合约：
保证了所有参与节点都严格遵循合约里的规定，
如果有恶意节点想篡改内容，就需要篡改所有节点的内容。
6.币圈和链圈的区别
币圈：主要注重加密数字货币的价值，并期望从中能获得利益，币圈人员分类：盈利，投资
链圈：更多注重的是底层的技术，他们研究算法，或者研究区块链的性能问题及应用场景，以求更快的落地。
7.数字签名流程
数字签名流程：私钥签名，公钥验签 （签名）
1、私钥持有者对原文数据进行hash计算，得到数字摘要
2、然后使用私钥对数字摘要进行签名，得到数字签名
3、数字签名 + 原文使用密钥进行加密，得到加密信息（对称加密）
4、A使用B的公钥对上一步的密钥进行加密，得到一个信封，（非对称加密）
5、A把信封和加密信息(数字签名数据+原文)一起发送给B， （验签）
6、B使用公钥解封信封，得到密钥。
7、B使用密钥解密加密信息，得到数字签名+ 原文
8、B使用A的公钥对数字签名进行验签，得到数字摘要1（验证消息来源的合法性）
9、B对原文进行hash计算，得到数字摘要2
10、对比数字摘要1和数字摘要2是否相同，（验证消息的正确性）
注意：比对两个数字摘要是否一致，一致的话就合法，不一致说明数据在中途被篡改，不安全
数字签名的作用：
1、保证消息来源的合法性(身份验证)
2、保证数据的正确性(不被篡改)
区块链中使用数字签名识别交易发起者的身份，防止恶意节点冒充。
8.区块链的特性和解释
特征和解释：
去中心化：
就是‘去信任’，不需要依赖第三方中心节点，私钥作为唯一标识
透明可信：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67350d7e0fb3bac465a27c1936eb5f5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4dc69a1e9cdfe72f0a6b60be69b97c7/" rel="bookmark">
			条件判断语句之if语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		if语句 if语句可以由很多种表示写法，我们可以根据我们的需要选择我们需要的写法
最简单的是一个if单分支语句
其形式是
if(条件判断)
{
}
现在举个例子给大家演示一下：输出两个数的较大值
#include&lt;stdio.h&gt; int main() { int a, b = 10; scanf("%d", &amp;a); if (a &gt; b) printf("%d\n", a); //如果a&gt;b,则输出a的值 printf("%d", b); //否则输出b的值 return 0; } if else语句 if else之后有两个分支，在不同情况下可以分别执行
格式如下
if（表达式)
{
语句一
}
else
{
语句二
}
举个同样的例子，输出两个数中较大的那个数
#include&lt;stdio.h&gt; int main() { int a, b, max; scanf("%d%d", &amp;a, &amp;b); if (a &gt; b) printf("max=%d", a); else printf("max=%d", b); } 我们可以发现
if单分支语句和if else的可以实现一样的功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4dc69a1e9cdfe72f0a6b60be69b97c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26f9db5d125b1b79dee24601682793f4/" rel="bookmark">
			k8s 架构图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K8S集群架构：
一个K8S集群是由两大部分组成：
Master节点和Node节点
一.Master节点主要包括API Server、Scheduler、Controller manager、etcd几大组件
1.API Server （提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接和etcd进行交互）
Kubernetes 集群中，API Server 扮演着通信枢纽的位置。API Server 不仅负责和 etcd 交互（其他组件不会直接操作 etcd，只有 API Server 这么做），并切对外提供统一的API调用入口, 所有的交互都是以 API Server 为核心的。API Server 提供了以下的功能：
1).整个集群管理的 API 接口：所有对集群进行的查询和管理都要通过 API 来进行。集群内部的组件(如kubelet)也是通过Apiserver更新和同步数据到etcd中。
2).集群内部各个模块之间通信的枢纽：所有模块之前并不会之间互相调用，而是通过和 API Server 打交道来完成自己那部分的工作。
3).集群安全控制：API Server 提供的验证和授权保证了整个集群的安全。
4).数据中心枢纽: API Server 负责和 Etcd 交互存放集群用到的运行数据。
2.Scheduler （负责对集群内部的资源进行调度，相当于“调度室”。）
Scheduler负责节点资源管理，接收来自kube-apiserver创建Pods的任务，收到任务后它会检索出所有符合该Pod要求的Node节点（通过预选策略和优选策略），开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上。
3.Controller manager
controller-manager 作为 k8s 集群的管理控制中心，负责集群内 Node、Namespace、Service、Token、Replication 等资源对象的管理，使集群内的资源对象维持在预期的工作状态。
每一个 controller 通过 api-server 提供的 restful 接口实时监控集群内每个资源对象的状态，当发生故障，导致资源对象的工作状态发生变化，就进行干预，尝试将资源对象从当前状态恢复为预期的工作状态，常见的 controller 有 Namespace Controller、Node Controller、Service Controller、ServiceAccount Controller、Token Controller、ResourceQuote Controller、Replication Controller等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26f9db5d125b1b79dee24601682793f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e181fc0c0b99b37a7bfcf0fa0051f39/" rel="bookmark">
			esp8266显示时间温湿度（WiFi配网）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用esp8266物联网，显示温湿度 内容参考技新课堂：https://www.bilibili.com/video/BV1dJ411S723
下载软件配置参考：https://blog.csdn.net/felix_tao/article/details/106698643
需要物件：
esp8266开发板一块（淘宝里很多小开发板且不贵）
oled屏幕一块（我用的是0.96寸的）
温湿度传感器一个（DHT11）
准备工作：
下载软件AiThinkerIDE
烧录固件工具-ESP_DOWNLOAD_TOOL
安信可串口调试助手AiThinker Serial Tool V1.2.3
这些资料可以在安信可官网获取：
环境配置完成后可以打开软件进行烧写，烧写过程：
1.先点击File中的import将工程导入（如果没有工程，从官方下载sdk，保留最基础的驱动程序，再进行相应的开发）
2.对于要编译的而工程先“clean project”再“build project”才行（必须这样操作，这里是安信可IDE的问题）
3.编译成功后打开烧录软件进行配置烧录；这里CrystalFreq要设置成26M，FLASH SIZE要设置成32Mbit
4.成功后显示界面：
问题 重点说说我在这过程中产生的问题，提醒大家避坑：
1.安信可官方的IDE对makefile文件识别有问题，当报错识别不了某个文件下的makefile的时候，去那个文件下把make文件改成.bak文件，如下：
2.对于版本为v1.5的下载软件，顶部分享的一个博主文章配置很详细，可以参考；但是，如果上述.bak仍不能解决报错，那么试试老版本下载软件
3.安信可官方的最新下载软件flash_download_tool_3.9.2取消了一些频率上设置，按理说会自动识别或者兼容才对，但是我用v3.9.2版本来下载程序，板子识别不出，指示灯闪烁。也就是说兼容性有点问题（我没细察，只知道退回老版本一切都正常了）
4.下载程序的时候不要先擦除再下载了（我养成的老习惯，总喜欢先擦除）；有的时候这样操作也会导致板子出现问题，先擦除再下载板子指示灯也闪烁，串口接收信息乱码；暂且怀疑某一部分有冲突导致，总之直接下载覆盖掉上一个程序就行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c182e42d82f1b3e63979792103c3ad51/" rel="bookmark">
			【牛客网C&#43;&#43;服务器项目学习】Day12-网络编程的两种事件处理模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目学习地址：【牛客网C++服务器项目学习】
day12 本该日更的项目学习进度，因为个人原因导致了拖更。虽然该专栏并没有读者，但是我觉得打乱了自己的计划，属实不该。由于课程【4.20】多进程服务器开发之后的学习笔记在pad上，暂时还没来得及迁移。这篇文章记录的是第五章项目学习的内容。
day x 1. 服务器编程基本框架
项目的改进点在 网络存储单元
这个课不可能能够涉及到完整的服务器开发，还需要自己去钻研和学习
两种高效的事件处理模式
准备知识：
阻塞、非阻塞：阻塞是指进程/线程在调用某些阻塞函数后未获得需要的资源时，被放入等待队列中等待的一种状态描述。例如，调用read函数进行数据读取时，进程/线程会被阻塞，一直等到内核将数据准备好，再把数据从内核缓冲区拷贝到用户的程序缓冲区后，read函数才会返回。
阻塞 I/O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。
非阻塞 I/O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。
同步、异步：同步和异步相较于【阻塞/非阻塞】是一种抽象的概念。它是一种消息通知机制。在我看来，阻塞和非阻塞是 同步/异步技术理念的具体实现方式。同步是指调用方法在没得到返回结果之前，会在原地一直等待（等待的方式有两种：一是放入线程/进程等待队列中，二是while循环忙等待）。实现异步的函数有：aio_read, aio_write
异步 I/O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。
Reactor：
Reactor是网络编程中的一种非阻塞、同步事件处理模式。其主要的特点是将监听客户端连接和处理事件进行分离，更具体的讲，是使用Reactor负责监听的和分发事件，在处理资源池（线程池）中进行事件的处理。Reactor的模式是灵活多变的： 单Reactor + 单进程/线程（redis使用该模式）单Reactor + 多进程/线程（本项目使用的模式） 多Reactor + 多进程/线程（Netty、Memcache、Ngnix） 在单Reactor + 多线程的模式中，引入了一个线程池的概念：
所谓线程池，是在内核中开辟一块内存，在客户端连接到来之前提前创建好。每建立一个客户端连接，便从线程池中分配一个线程给该客户端，客户端连接结束后，将该线程还给线程池。
线程池的好处是可以避免频繁的创建和销毁线程。 各种类型的Reactor的优缺点：
单Reactor + 单线程 ： 优点是简单，上手快，没有多线程之间的资源竞争问题。但是缺点是无法充分利用多核CPU的性能。（不过在redis上性能瓶颈不是CPU的性能）
单Reactor + 多线程： 效率高，能够充分利用多核CPU的性能优势。缺点是：使用多线程开发的话需要在各自线程上加锁保护临界区数据，比较复杂
多Reactor + 多线程：效率高，相较于【单Reactor + 多线程】能够处理更高的并发情况，此外子线程在业务处理完成后，无需将数据返还到主线程中进行发送，可以直接在子线程中发送给客户端。
Proactor
Proactor模式是一种基于异步I/O的事件处理模式。（异步I/O就没有阻塞和非阻塞的区别了）。 异步I/O的调试比较复杂。 可惜的是，在 Linux 下的异步 I/O 是不完善的，aio 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。而 Windows 里实现了一套完整的支持 socket 的异步编程接口，这套接口就是 IOCP，是由操作系统级别实现的异步 I/O，真正意义上异步 I/O，因此在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/192a84f336cd81c499311381438ed976/" rel="bookmark">
			VS2019编译 ODB 开源项目以及示例程序运行详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 编译准备配置ODB工具环境编译ODB运行时库编译ODB驱动Sqlite源码编译libodb-sqlite-2.4.0编译 运行实例程序 编译准备 ODB是一个开源、支持多平台、多数据库基于C++的ORM框架，可将C++类对象与数据库表映射，进行轻松的数据库查询和操作，编译使用时需要在官网下载三个库包括：odb-2.4.0-i686-windows、libodb-2.4.0、libodb-sqlite-2.4.0，作为学习还需要下载odb-examples-2.4.0。
配置ODB工具环境 odb-2.4.0-i686-windows类似与ODB的源码编译工具，ODB的框架需要将特定的数据结构文件(.hxx)编译成特定文件一个是三个，例如：person.hxx经过编译会生成person-odb.hxx、person-odb.ixx和``person-odb.cxx`，解压缩下载的zip包并配置到环境变量中即可，配置如下所示：
配置完成后可以在CMD控制台上进行验证：
编译ODB运行时库 libodb-2.4.0是在具体程序运行时所依赖的动态库，可以使用Visual Studio直接打开进行编译，本文使用VS2019为例。解压缩下载的zip包，双击其中的对应版本的.sln文件，VS2013或以上版本都选择libodb-vc12.sln即可，编译完成后生产bin、lib、bin64和lib64四个文件夹，前两个表示32位，后两个表示64位。
编译ODB驱动 ODB数据库的驱动编译依赖具体使用的数据库提供的运行时库，在使用使用ODB进行编程时也需要使用这些运行时库，以下使用SQLite数据库的编译作为例子。
Sqlite源码编译 在编译libodb-sqlite-2.4.0前需要先编译一下SQLite源码，生成相对应的lib文件后续会用到。在SQLite官网下载源码zip，下载的压缩包解压缩后得到四个文件，如下所示：
使用VS2019创建静态库项目，如下所示：
将SQLite源码都拷贝到创建的项目中，并删除其中项目创建后自动生成的源码文件，在VS工程文件中做相同修改，如下图所示：
右键点击项目-&gt;属性，对项目进行修改，包括如下几个部分：
配置Debug，平台x64
常规-&gt;输出目录-&gt;$(SolutionDir)\bin64常规-&gt;目录文件名-&gt;$(ProjectName)dC\C+±&gt;预处理器-&gt;SQLITE_ENABLE_UNLOCK_NOTIFY; 配置Debug，平台Win32
常规-&gt;输出目录-&gt;$(SolutionDir)\bin
常规-&gt;目录文件名-&gt;$(ProjectName)d
C\C+±&gt;预处理器-&gt;SQLITE_ENABLE_UNLOCK_NOTIFY;
配置Release，平台x64
常规-&gt;输出目录-&gt;$(SolutionDir)\bin64目录文件名-&gt;$(ProjectName)C\C+±&gt;预处理器-&gt;SQLITE_ENABLE_UNLOCK_NOTIFY; 配置Release，平台Win32
常规-&gt;输出目录-&gt;$(SolutionDir)\bin
目录文件名-&gt;$(ProjectName)
C\C+±&gt;预处理器-&gt;SQLITE_ENABLE_UNLOCK_NOTIFY;
配置完成后分别使用这四个不同模式编译SQLite静态库，生成内容如下如下：
libodb-sqlite-2.4.0编译 解压缩下载的libodb-sqlite-2.4.0.zip文件得到libodb-sqlite-2.4.0文件夹，双击其中的对应版本的.sln文件，VS2013或以上版本都选择libodb-sqlite-vc12即可。
在编译前还需要对项目的属性进行修改，在修改前建议将编译好的文件都拷贝到一起，根据之前的生成的动态库和静态库，整理目录如下：
ODB运行时库：bin、lib、bin64、lib64和odb文件夹五个文件夹拷贝到libodb-sqlite-2.4.0文件夹的common_lib文件夹中(common_lib文件夹是自己创建的)。
SQLite静态库：bin、bin64两个文件夹和sqlite3.h文件拷贝到libodb-sqlite-2.4.0文件夹的db_source文件夹中(db_source文件夹是自己创建的)。
拷贝完成后打开.sln后找到需要修改，右键点击项目-&gt;属性-&gt;C/C++-&gt;常规-&gt;附加包含目录、右键点击项目-&gt;属性-&gt;链接器-&gt;常规-&gt;附加库目录、右键点击项目-&gt;属性-&gt;链接器-&gt;输入-&gt;附加依赖项，具体配置如下：
配置Debug，平台x64
附加包含目录-&gt;$(SolutionDir)\common_lib\;$(SolutionDir)\db_source\;附加库目录-&gt;$(SolutionDir)\common_lib\lib64\;$(SolutionDir)\db_source\bin64\;附加依赖项-&gt;sqlite3.lib改为sqlite3d.lib 配置Debug，平台Win32
附加包含目录-&gt;$(SolutionDir)\common_lib\;$(SolutionDir)\db_source\;
附加库目录-&gt;$(SolutionDir)\common_lib\lib\;$(SolutionDir)\db_source\bin\;
附加依赖项-&gt;sqlite3.lib改为sqlite3d.lib
配置Release，平台x64
附加包含目录-&gt;$(SolutionDir)\common_lib\;$(SolutionDir)\db_source\;附加库目录-&gt;$(SolutionDir)\common_lib\lib64\;$(SolutionDir)\db_source\bin64\;附加依赖项-&gt;不用修改 配置Release，平台Win32
附加包含目录-&gt;$(SolutionDir)\common_lib\;$(SolutionDir)\db_source\;
附加库目录-&gt;$(SolutionDir)\common_lib\lib\;$(SolutionDir)\db_source\bin\;
附加依赖项-&gt;不用修改
配置完成后编译对应的四个版本源码同样得到bin、lib、bin64和lib64四个文件夹，前两个表示32位数据库驱动，后两个表示64位数据库驱动。至此准备工作均已完成。
运行实例程序 解压缩odb-examples-2.4.0.zip压缩包，其中是ODB官方的实例程序，对于不同的数据库有不同的.sln文件本文使用的是SQLite因此打开examples-sqlite-vc12.sln解决方案，以hello-sqlite-vc12示例项目为例，如下所示：
此时如果双击上图中的三个文件会显示文件不存在，这就是需要使用ODB工具进行编译，可以编译hello-sqlite-vc12整个项目就会生成文件。但在编译整个项目之前还是需要整合之前编译的文件以及修改项目属性。
ODB运行时库：bin、lib、bin64、lib64和odb文件夹五个文件夹拷贝到odb-examples-2.4.0文件夹的odb\common_lib文件夹中(odb\common_lib文件夹是自己创建的)。
ODB数据库驱动：bin、lib、bin64、lib64、odb四个文件夹和sqlite3.h文件拷贝到odb-examples-2.4.0文件夹的odb\db_lib\lib_sqlite文件夹中(odb\db_lib\lib_sqlite文件夹是自己创建的)。
拷贝完成后同样修改两个位置，右键点击项目-&gt;属性-&gt;C/C++-&gt;常规-&gt;附加包含目录、右键点击项目-&gt;属性-&gt;链接器-&gt;常规-&gt;附加库目录，具体配置如下：
配置Debug，平台x64
附加包含目录-&gt;$(SolutionDir)\odb\common_lib\;$(SolutionDir)\odb\db_lib\lib_sqlite\;附加库目录-&gt;$(SolutionDir)\odb\common_lib\lib64\;$(SolutionDir)\odb\db_lib\lib_sqlite\lib64\; 配置Debug，平台Win32
附加包含目录-&gt;$(SolutionDir)\odb\common_lib\;$(SolutionDir)\odb\db_lib\lib_sqlite\;附加库目录-&gt;$(SolutionDir)\odb\common_lib\lib\;$(SolutionDir)\odb\db_lib\lib_sqlite\lib\; 配置Release，平台x64
附加包含目录-&gt;$(SolutionDir)\odb\common_lib\;$(SolutionDir)\odb\db_lib\lib_sqlite\;附加库目录-&gt;$(SolutionDir)\odb\common_lib\lib64\;$(SolutionDir)\odb\db_lib\lib_sqlite\lib64\; 配置Release，平台Win32
附加包含目录-&gt;$(SolutionDir)\odb\common_lib\;$(SolutionDir)\odb\db_lib\lib_sqlite\;附加库目录-&gt;$(SolutionDir)\odb\common_lib\lib\;$(SolutionDir)\odb\db_lib\lib_sqlite\lib\; 配置好后进行编译会生成driver.exe。在运行前需要把对应版本的动态库都拷贝到driver.exe同级目录下，以debug为例需要拷贝obd\common_lib\bin64\odb-d-2.4-vc12.dll和odb\db_lib\lib_sqlite\odb-sqlite-d-2.4-vc12.dll。
ODB在创建DB对象时依赖参数配置，对于当前这个示例而言在运行时需要进行参数设置，右键点击项目-&gt;属性-&gt;调试-&gt;命令参数填写--database $(OutDir)\hello.db
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab4d1ef903e03e33d4d2fa95fe04df1/" rel="bookmark">
			论文阅读-2022.1.2-A Neural Network Approach for_2016_一种用于知识驱动响应生成的神经网络方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 We present a novel response generation system.我们提出了一种新颖的响应生成系统。
The system assumes the hypothesis that participants in a conversation base their response not only on previous dialog utterances but also on their background knowledge.
系统假设对话的参与者不仅基于先前的对话话语而且基于他们的背景知识做出响应。
Our model is based on a Recurrent Neural Network (RNN) that is trained over concatenated sequences of comments, a Convolution Neural Network that is trained over Wikipedia sentences and a formulation that couples the two trained embeddings in a multimodal space.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ab4d1ef903e03e33d4d2fa95fe04df1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7797ef1b6c31d1d3feeddc47566043f/" rel="bookmark">
			AOP简单实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、自定义注解 @Target(value = {ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface MyAnnotation { } 2、切面类 @Aspect @Component public class MyAnnotationAspect { /** * 定义切点，拦截的位置，可避免下面重复声明变量 */ @Pointcut("@annotation(com.yjz.common.annotation.MyAnnotation)") private void pointCut(){} // @Before("@annotation(myAnnotation)") // public void doBefore(JoinPoint joinPoint, MyAnnotation myAnnotation){ // // } @Before("pointCut()") public void doBefore(JoinPoint joinPoint){ System.out.println("-----切入点的相关信息-----"); //目标方法的传入参数 Object[] args = joinPoint.getArgs(); System.out.println("共"+args.length+"个参数"); for (int i = 0; i &lt; args.length; i++) { System.out.println("第"+i+1+"个参数为："+args[i]); } //获取目标方法信息 Signature signature = joinPoint.getSignature(); System.out.println("目标方法名为："+signature.getName()); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7797ef1b6c31d1d3feeddc47566043f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/267/">«</a>
	<span class="pagination__item pagination__item--current">268/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/269/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>