<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be62e00f32a8f58e1db7811698821cd2/" rel="bookmark">
			jenkins构建触发器设置（定时任务）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jenkins构建触发器定时任务设置 1.jenkins构建触发器定时任务
2. 在构建触发器处
定时构建语法：
* * * * *
(五颗星，中间用空格隔开）
第一颗 * 表示分钟，取值0~59
第二颗 * 表示小时，取值0~23
第三颗 * 表示一个月的第几天，取值1~31
第四颗 * 表示第几月，取值1~12
第五颗 * 表示一周中的第几天，取值0~7，其中0和7代表的都是周日
1.每30分钟构建一次：H/30 * * * *
2.每2个小时构建一次：H H/2 * * *
3.每天早上8点构建一次：0 8 * * *
4.每天的8点，12点，22点，一天构建3次：0 8,12,22 * * *
（多个时间点，中间用逗号隔开）
Job关联
1.举个案例场景，比如我下面Job1是web项目打包并发布的构建任务，我想每次打完包发布后，然后触发自动化测试Job2的构建。
（当然发布后，一般会等几分钟才会完全加载完成，再下一次构建的时候，可以用python加个脚本sleep几分钟）
2.构建触发器勾选其他工程构建后触发（Build after other projects are built），关注的项目（Projects to watch）输入Job1的名称
（这里可以输入多个依赖的jobs，多个job中间用逗号隔开）
3.下面有三个选择，一般默认第一个就行
构建稳定时触发（Trigger only if build is stable）
构建不稳定时触发（Trigger even if the build is unstable）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be62e00f32a8f58e1db7811698821cd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f2d92d3e68dc259e45bc854e3355b15/" rel="bookmark">
			tensorflow2.X和pytorch实现polyloss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		polyloss介绍 polyloss是Cross-entropy loss和Focal loss的优化版本，PolyLoss在二维图像分类、实例分割、目标检测和三维目标检测任务上都明显优于Cross-entropy loss和Focal loss。
作者认为可以将常用的分类损失函数，如Cross-entropy loss和Focal loss，分解为一系列加权多项式基。
它们可以被分解为 ∑ j = 1 n α j ( 1 − P t ) j \sum_{j=1}^n\alpha_j(1-P_t)^j ∑j=1n​αj​(1−Pt​)j的形式，其中 α j ∈ R + \alpha_j∈R^+ αj​∈R+为多项式系数， P t P_t Pt​为目标类标签的预测概率。每个多项式基 ( 1 − P t ) j (1-P_t)^j (1−Pt​)j由相应的多项式系数 α j ∈ R + \alpha_j∈R^+ αj​∈R+进行加权，这使PolyLoss能够很容易地调整不同的多项式基。
当 α j = 1 / j \alpha_j=1/j αj​=1/j时，PolyLoss等价于常用的Cross-entropy loss，但这个系数分配可能不是最优的。 tensorflow2.X实现 注意：在图像分类训练时该polyloss已经对网络预测结果进行softmax缩放，在网络的最后一层可以不加softmax激活函数。但是预测图片时记得添加！
import tensorflow as tf def poly1_cross_entropy(epsilon=1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f2d92d3e68dc259e45bc854e3355b15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f5d60e938e261bfdb360e60548c30b/" rel="bookmark">
			解决vue代码不规范而出现的问题：Eslint修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们刚创建一个vue项目，写代码时候，因为代码写的不规范会出很多问题，报很多错误，除了一个一个去修改他们，还有没有其他办法去解决他们呢？
这里介绍三种办法去统一解决：
方法一：每次运行npm run lint
package.json文件里有一个"lint"：“vue-cli-service lint”，每次写完代码，运行一下lint：npm run lint，会自动帮你修复，但是变量没有用，不会给你自动修复，需要你自己手动修复。
方法二：自动修复eslint（推荐）
（1）安装eslint插件，并启用；
（2）在【文件】=&gt;【首选项】=&gt;【设置】，找到setting.json，加上以下配置：
"editor.codeActionsOnSave":{ "source.fixAll":ture } setting.json位置： 配置完，当你每次写完代码ctrl+s保存以下就自动给你修复了。
但是这个方案跟你的vscode和eslint版本是息息相关的，所以会出现版本不适用问题，有时候就没用了。
方案三：暂时关掉eslint，等代码都写完了，最后运行一次 npm run lint（推荐）
创建一个vue.config.js文件，在文件中加上下面这句代码：
module.exports = { lintOnSave:false //暂时关闭代码格式检测 } 然后重启项目，直接运行：
npm run lint 代码不规范就被修复了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf57fffe74060818ed97aaaad519c7b6/" rel="bookmark">
			海康威视网络摄像头sdk的开发（Demo的使用）指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果您是想实现海康sdk包的Demo实例中MFC的分功能，那么请慢慢看，这篇文章百分之九十九可以帮你实现。
提醒：内容来自网络和自己实际操作，如有问题请联系hww168@yeah.net
首先，我们去下载海康威视提供的sdk开发包。
https://open.hikvision.com/download/5cda567cf47ae80dd41a54b3?type=10
下载官网我也放在上面了，大家根据自己需要去下载。
这是我下载好的sdk开发包
打开
大致看一下，这里包含Demo例程（可以拿来跑的程序），有相关开发文档，有头文件、库文件。
其中，Demo还分为很多类型MFC、C#、Java、Python。
这里呢，我是用的是MFC分功能，我们打开其中一个Demo，这里我以“实时回流解码”文件为例，其他一样的操作。
第一步，点击这个sln文件进入Visual Studio
出现下面的弹窗是因为版本不支持，不过没关系，直接点确定。
第二步，更改Demo属性页配置
在Demo属性页中，输出目录与输出文件路径不符，咱们需要手动改一下，改成.\bin\，配置完记得点击应用，记得应用。
第三步，我们还需要进行头文件和库文件的导入。
先打开属性管理器
选择文件Debug|x64右击鼠标打开属性界面（文件选择跟你下载的sdk与电脑系统有关）
第四步，打开sdk包，找到头文件的路径，复制粘贴到C++常规的附件目录里。
然后去复制添加库文件路径，粘贴到链接器的附加库目录里
第五步，解决库文件调用问题
去库文件里面全选，复制到“实时回流解码获取”文件的bin文件夹下，因为我这里是以“实时回流解码获取”文件为例，你用的什么文件就添加到它的bin文件夹下
（关于库文件全选问题 ，如果你懂你要什么文件，复制添加相应文件即可，不懂的话就全选）
这样，配置就完成了，点击开始调试。
大功告成，输入你摄像头的相关参数即可使用了
本人也是小白，只是这方面熟悉一点点🤏🏻，如果文章看不懂或者达不到我最前面讲的效果，请留言，我会及时更改或删除内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b15f3476ad8fb304cbd2697116f3b101/" rel="bookmark">
			数据结构-树1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树的基本定义 D：D是具有相同特性的数据元素的集合, hi是di上的二元关系(说明了谁是谁的孩子,谁是谁的父母)
(di,{hi})就是一颗子树；
基本操作 二叉树 基本操作 二叉树的性质 几种特殊的树 二叉树的存储结构 二叉树的顺序存储 缺点就是浪费空间
代码实现 // c6-1.h 二叉树的顺序存储表示 #define MAX_TREE_SIZE 100 // 二叉树的最大结点数 typedef TElemType SqBiTree[MAX_TREE_SIZE]; // 0号单元存储根结点 struct position { int level,order; // 结点的层,本层序号(按满二叉树计算) }; // bo6-1.cpp 二叉树的顺序存储(存储结构由c6-1.h定义)的基本操作(23个) //以数组的形式存储数据,但进行数据的读取操作却是树 Status InitBiTree(SqBiTree T) { // 构造空二叉树T。因为T是固定数组，不会改变，故不需要&amp; int i; for(i=0;i&lt;MAX_TREE_SIZE;i++) T[i]=Nil; // 初值为空 return OK; } void DestroyBiTree() { // 由于SqBiTree是定长类型,无法销毁 } Status CreateBiTree(SqBiTree T) { // 按层序次序输入二叉树中结点的值(字符型或整型), 构造顺序存储的二叉树T int i=0; #if CHAR int l; char s[MAX_TREE_SIZE]; cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b15f3476ad8fb304cbd2697116f3b101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d94fd8b5f6ccc94c5d41f0ccbb734bce/" rel="bookmark">
			git diff 命令6种使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景&amp;目标
二、git三个区了解
三、git diff 6种场景介绍
3.1 工作区和暂存区差异对比
3.2 工作区和版本库之间差异
3.3 暂存区和版本库之间差异对比
3.4 本地版本库之间提交记录对比
3.5 不同分支对比
3.6 不同分支下同一文件对比
四、git diff 中@@ -x1,y1 +x2,y2 表示的意思
4.1 demo
4.2 具体解释
一、背景&amp;目标 在之前公司中大家合并代码都是自己解决冲突，然后提交一个MR，具体负责人只是进行简单的代码查看和MR,所以并没了解过git其他命令，因为用不到。但是最近小伙伴们一个需求少的会创景3-4个分支，多的有7-8个分支，上线时自己合并代码是一件比较“艰难”的事情，所以我们需要git的diff 命令来查看具体区别，但是diff 有多种使用场景下面我们来了解一下；
二、git三个区了解 因为diff的介绍是离不开这三个区，所以优先了解一下这三个区；
Git中的划分为工作区（Working Directory），暂存区（Index，也就是Stage区），版本库（也就是每次提交commit以后的版本） 工作区、暂存区、本地版本库三个区具体讲解见文章：git 工作区、暂存区、版本库三个区域介绍
三、git diff 6种场景介绍 3.1 工作区和暂存区差异对比 3.1.1 工作区和暂存区之间的差异
git diff --stat 这个命令展示工作区和暂存区之间有区别的文件，以及该文件中有多少区别；
从这里可以看到工作区和暂存区之间有2个文件被修改过，每个文件中有1处改动；
3.1.2 工作区和暂存区之间的详细差异
git diff 这个命令显示的是详细的差异，比如是哪个文件中的哪行有变化; 相比上面对比情况来看，工作区和暂存区（index 2e6f7ce...）中文件有区别，具体去区别会在下面展示。看上面1、2、3 发现1说明了工作区和暂存区中哪个记录有区别，2中列出了具体文件，3中展示具体文件中具体区别；
3.2 工作区和版本库之间差异 3.2.1 工作区和版本库之间差异
git diff HEAD --stat git diff commit_id --stat 这个命令展示工作区和版本库之间有区别的文件，以及该文件中有多少区别；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d94fd8b5f6ccc94c5d41f0ccbb734bce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26b58ded6365f5c4ff412dc63aacaf68/" rel="bookmark">
			CNN卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CNN卷积神经网络 前言一、相关概念卷积彩色图像卷积池化paddingDropout正则化局部归一化 二、经典网络AlexNetVGGNet介绍GoogLeNetResNet介绍resnet解决方案结果 三、实操一般步骤结构举例代码链接 前言 为什么用卷积神经网络
全连接神经网络问题
参数过多过拟合需要更多数据收敛到较差的局部极值 卷积神经网络
局部连接参数共享 提示：以下是本篇文章正文内容，下面案例可供参考
一、相关概念 卷积 彩色图像卷积 池化 最大池化平均池化 padding 每次卷积图像都会缩小，层数越多，缩小的越多。
边沿的像素会被忽略
padding大小
n+2p-f+1=npadding 类型
valid
same如果有步长则
（n-f)/S+1+2p=n Dropout正则化 目的
减少过拟合方法
在一次训练时的迭代中，对每一层中的神经元（总数为N）以概率P随机剔除，用余下的（1-P）×N个神经元所构成的网络来训练本次迭代中的数据。
一般来说对于CNN，Dropout仅在池化层后使用
局部归一化 LRN ( Local Response Normalization) 局部响应归一化
二、经典网络 AlexNet 作者：
– Alex Krizhevsky2012 ILSVRC（ImageNet Large Scale Visual Recognition Challenge）竞赛的冠军网络
– 分类准确率从传统的74%提升到84%
– top-5错误率16.4%
亮点：首次使用了GPU进行网络加速训练
– 使用了ReLU 激活函数，而不是传统的sigmoid和tanh
– 在全连接层前两层使用了Dropout，减少过拟合
– 局部归一化（Local Response Normalization，简称LRN） VGGNet介绍 VGGNet由牛津大学计算机视觉组合和Google DeepMind公司研究员一起研发的深度卷积神经网络成绩：
ILSVRC 2014年比赛的亚军和定位项目的冠军
将 Top-5错误率降到7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26b58ded6365f5c4ff412dc63aacaf68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70bd35d58b29514db1e82c29464c599e/" rel="bookmark">
			1.CSS-属性和选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文字属性 fon-style:italic斜体；font-weight:bold加粗；font-size:10px；大小font-family:"微软雅黑"字体。字体设置需要注意：字体可以进行备选的，就是后面设置多种字体。如果设置英语和中文的字体不一样？该怎么做，英文字体不能去设置中文，而中文字体可以设置英文。根据这个特性和字体备选这个特性相结合，我们就可以在前面放英文字体，后面放中文字体，就能达到中英字体不同的效果。另外可以使用font:italic bold 10px "微软雅黑";这样的写法代替那种四行的写法。在这种缩写中，style和weight是可以省略的，而size和family是不可以省略的。并且style和weight的顺序可以颠倒，而size和family的顺序不能颠倒。
2.文本属性 text-decoration:underline下划线、line-through删除线、overline上划线、none无，a标签自带下划线，若想去掉，可通过此方式。
text-align：center、left、right。对齐
text-indent：2em;缩进两个字符。em是字符单位，1em代表一个字符的宽度
3.颜色属性 color:赋值方法有5种，分别是（1）英文单词，（2）rgb(),（3）rgba(),（4）十六进制如#FF0000，（5）十六进制缩写如#F00。
英文单词并不能显示所有的颜色。rgb中r、g、b的取值若一样，就是灰色。十六进制中前两个字符代表的是R的取值，中间两个字符代表的是G的取值，最后两个代表的是B的取值.在css中，只要颜色的每两位都是一样的，就可以写成缩写形式。这也就明白了之前写的#CCC和#CCCCCC是一样的道理，并且#CCC代表的是r、g、b取值一样，那么就一定是灰色的了。并且十六进制中大小写都一样。
4.选择器 标签选择器、ID选择器、class选择器、后代选择器、子元素选择器之前经常使用，已经掌握。
（1）交集选择器，作用是选择两个选择器的交集，用法为：选择器1选择器2，注意两个选择器之间不能有任何符号和空格，在企业开发中不建议使用这个方法。
（2）并集选择器，用法：选择器1，选择器2{}，这个之前用过
（3）兄弟选择器分为相邻兄弟选择器和通用兄弟选择器。相邻兄弟选择器用法：选择器1+选择器2{}，但是这个只能找到和选择器1近邻着的选择器2，中间不能隔任何标签。而通用选择器用法：选择器1~选择器2，能够找到选择器1的所有兄弟中符号选择器2的兄弟。
（4）CSS3中新增的最具有代表性的选择器就是序选择器。
:first-child：匹配的是某父元素的第一个子元素，可以说是结构上的第一个子元素。
:first-of-type：匹配的是某父元素下相同类型子元素中的第一个，比如 p:first-of-type，就是指所有类型为p的子元素中的第一个。这里不再限制是第一个子元素了，只要是该类型元素的第一个就行了。
p:nth-child(n)，同样，先把每一代给分出来，然后从每一代中进行查找，选择p中的第n个，这个是不区分类型的。同样也有p:nth-of-type(n)
p:nth-last-child(n)，同样，先分代，然后选择p中倒数第n个，不区分类型。同样也有nth-last-of-type(n)
p:only-child,是指从html的body标签开始进行遍历，假如遍历到一个div标签，里面只有一个p标签，那么p标签被选中,若还有其他标签，那么p就不被选中，即不区分类型。同样，only-of-type是指从body标签开始遍历，假如遍历到一个div，里面有一个p标签和很多h标签，那么p标签将被选中。
p:nth-child(odd){}选择同级别中所有序号为奇数的p标签，同样p:nth-child(even)是偶数。同样p:nth-of-type(odd){}选中的是同类型的奇数，同样even是偶数。
p:nth-child(xn+y){}选择同级别中的p标签，规则是，n取0-n，x和y客户自即定义。
p[id]{},属性选择器,首先找到所有的p标签，然后找到p标签中有id的标签。
p:[attribute=value],比如p:[class=cc],就是指在所有的p标签中，先找到有class的，再从中筛选出class=cc的。
CSS3中img[alt^=abc]代表img标签中alt的属性是以abc开头的标签。CSS2中img[alt|=value]代表img标签中alt的属性是以abc开头的标签，但是这个abc只能以-进行分割，比如，abcdef就不行，而abc-def却可以，在css3中，这些都可以。
img[alt$=abc]是指结尾，其他和上面那个一样
css3中img[alt*=abc]代表包含abc的都被选中，css2中img[alt~=abc]代表包含abc的，但这个abc的前后必须要被空格隔开
*{}这个全选的选择器叫做通配符选择器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1150f245d60739ef8ea850015dff9b0c/" rel="bookmark">
			攻防世界新手练习区——unseping
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
知识点
解读题目源码：
命令绕过
知识点 PHP代码审计PHP序列化和反序列化PHP中魔术方法命令执行绕过方式 解读题目源码： 这道题首先一上来就是一段PHP代码，其中看到unserialize()就知道考的是反序列化，但是我们再往上看代码会发现还有命令执行绕过的知识点。做出这道题的第一步就是能够理清代码执行顺序和各个函数的功能。接下来我们先分析一下源码。
&lt;?php highlight_file(__FILE__); class ease{ private $method; private $args; function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct(){ if (in_array($this-&gt;method, array("ping"))) { call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } } function ping($ip){ exec($ip, $result); var_dump($result); } function waf($str){ if (!preg_match_all("/(\||&amp;|;| |\/|cat|flag|tac|php|ls)/", $str, $pat_array)) { return $str; } else { echo "don't hack"; } } function __wakeup(){ foreach($this-&gt;args as $k =&gt; $v) { $this-&gt;args[$k] = $this-&gt;waf($v); } } } $ctf=@$_POST['ctf']; @unserialize(base64_decode($ctf)); ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1150f245d60739ef8ea850015dff9b0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fc7c94ffd336cda62c700ef40231507/" rel="bookmark">
			【c&#43;&#43;】友元函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要引入友元函数：在实现类之间数据共享时，减少系统开销，提高效率。
c++利用friend修饰符，可以让一些你设定的函数能够对这些保护数据进行操作，避免把类成员全部设置为public，最大限度的保护数据成员的安全。
具体来说：为了使其它类的成员函数直接访问该类的私有变量。
即：允许外面的类或函数去访问类的私有变量和保护变量，从而使两个类共享同一函数。（友元函数不是类的成员函数，是普通函数）
优点：能够提高效率，表达简单、清晰。
缺点：友元函数破坏了封装机制，尽量使用成员函数，除非不得已的情况下才使用友元函数。
什么时候使用友元：
运算符重载的某些场合需要使用友元。两个类要共享数据的时候。 怎么使用友元：
友元函数的参数：
因为友元函数是没有this指针的，则参数要有三种情况：
要访问非static成员时，需要对象做参数。（常用）要访问static成员或全局变量时，不需要对象做参数。如果做参数的对象是全局对象，则不需要对象做参数。 友元函数的位置：
因为友元函数是类外的函数，所以它的声明可以放在类的私有段或公有段且没有区别。
友元函数的调用：
可以直接调用友元函数，不需要通过对象或者指针。
友元函数 友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需要在友元的名称前面加上关键字friend。
具体格式为friend 类型 函数名(形式参数);
友元函数的声明可以放在类的私有部分，也可以放在类的公有部分，它们是没有区别的，都说明是该类的一个友元函数。
一个函数可以是多个类的友元函数，只需要在各个类中分别声明。
友元函数的调用与一般函数的调用方式和原理一致。
友元类 友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。
当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。定义友元类的语句格式如下：friend class 类名;其中：friend和class是关键字，类名必须是程序中的一个已经定义过的类。
函数来源总结 1 普通函数的友元函数 目的：使普通函数能够访问类的友元
语法：声明位置：公有私有均可，常写为公有
声明：friend+普通函数声明
实现位置：类内类外均可
实现代码：与普通函数相同
调用：类似普通函数，直接调用
2 类Y的所有成员函数都是类X的友元函数–友元类 目的：使用单个声明使Y类的所有函数成为类X的友元
它提供了一种类之间合作的一种方式，使类Y的对象可以具有类X和类Y的功能。
前提：A是Ｂ的友元　可推　Ａ中的成员函数可以访问Ｂ中的所有成员。
语法：声名位置：公有私有均可，常写为私有（把类看成一个变量）。
声明：friend＋类名。
代码：
#include&lt;iostream&gt; using namespace std; class girl{ private: char *name; int age; friend class boy;//声明类boy是类girl的友元 public: girl(char *n,int age):name(n),age(age){}; }; class boy{ private: char *name; int age; public: boy(char *n,int age):name(n),age(age){}; void disp(girl &amp;); }; void boy::disp(girl &amp;x){//该函数必须在girl类定义的后面定义，否则girl中的私有变量还是未知的 cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fc7c94ffd336cda62c700ef40231507/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96f62588b03c05387e357db1e04db937/" rel="bookmark">
			Power BI 11个必学官方示例数据案例（附下载链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开始学习Power BI时，最大的问题就是不知道哪里找数据，或者有数据却对搭建看板毫无头绪， 不知道该从哪里下手。
本文收集整理了官网上最值得学习的11个案例，包括不同行业和分析方法，方便大家按需学习。点击标题即可转到下载页面
PS：Desktop要用2022年11月之后的版本。
1.销售和退货示例 这个示例报表使用书签、分解树、关键影响者等功能，同时添加了What if分析和购物篮分析，适合有一定基础的学习者。
2.人工智能示例 这个报表一共包含三个页面：
关键影响者：了解产品和区域在收入赢/亏方面的主要参与者；分解树：确定收入的最高或最低细分类别；异常检测：确定数据中是否存在异常。
整体版面设计更加简洁，也都用到了最新功能，但是背后的数据模型和计算逻辑复杂。
"异常检测"页面, 添加了时间区间的选项、动态摘要和问答功能。
数据模型结构比较复杂，计算表、列等计算代码比较多。
同个数据集在线上登录页面还有个更加完善的区域销售示例案例，需要注册账号登录才能下载。
3.美国新冠肺炎数据 官方提供的新冠数据示例，本身数据集和报表都简单。
4.客户盈利 此仪表板由 CFO 创建，用于查看有关他们的五名业务部门经理（管理人员）、产品、客户和毛利 (GM) 的关键指标。
下面是在线的仪表板视图，官方提供的PBIX下载文件，不包含仪表板只包含了报表，接下来的几个案例也是如此。
5.人力资源 在此示例中，人力资源部门跨不同公司使用相同的报表模型，即使公司所处的行业或规模不同，也不例外。 此示例研究新员工数、在职员工数和离职员工数。 它力求发掘雇佣策略中的任何趋势。
6.IT支出分析 此示例分析比较了 IT 部门的计划成本与实际成本，帮助了解公司年度计划的效果如何并调查与计划有巨大偏差的区域。 此示例中的公司经历了一个年度计划周期，然后按季度生成新的最新估计 (LE)，以帮助分析会计年度中的 IT 支出变化。
7.商机分析 示例包含采用以下两种销售渠道的软件公司的仪表板、报表和数据集：直接销售和合作伙伴销售 。 销售经理创建此仪表板以按照区域、成交额和渠道来跟踪商机和收入。
8.采购分析 本示例探讨以下几方面：
首选供应商有哪些我们在哪些类别上的支出最多哪些供应商给我们最高折扣以及在何时给我们最高折扣
9.零售分析 零售分析内置示例包含仪表板、报表和数据集，用于分析跨多个商店和地区销售的商品的零售数据。 这些指标将今年的业绩与去年的销售额、单位、毛利率和方差进行比较，并进行新店分析。
10.销售和市场营销 销售与市场营销示例包含一家名为 VanArsdel Ltd 的虚构制造公司的仪表板和报表。VanArsdel 首席市场官 (CMO) 创建了此仪表板，主要关注业界及公司的市场份额、产品量、销售额和人气。
VanArsdel 有许多竞争对手，但仍是业内的市场领导者。 CMO 想要增加市场份额，探索发展的商机。 然而由于未知原因，VanArsdel 的市场份额在 6 月已开始大幅滑落。
11.供应商质量分析 此行业示例仪表板与基础报表着重于传统供应链的其中一项挑战 - 供应商质量分析。 有两个主要度量值在此分析中发挥作用：瑕疵品总数和瑕疵品所造成的停工时间总计。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32b31a0e975456310fccd703f1000fab/" rel="bookmark">
			RTSP安防网络摄像头/海康大华硬盘录像机/NVR网页无插件低延时播放流媒体服务器EasyNVR页面显示网络请求失败问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入移动互联网时代以来，企业微信公众号已成为除官网以外非常重要的宣传渠道，当3.2亿直播用户与9亿微信用户的势能累加，在微信上开启直播已成为越来越多企业的必然选择。
青犀团队研发的EasyNVR核心在于摄像机的音视频流的获取、转换、转码与高性能分发，同时同步完成对实时直播流的录像存储，在客户端（PC浏览器、Android、iOS、微信）进行录像文件的检索、回放和下载。
EasyNVR方案一
EasyNVR方案二
EasyNVR方案三
EasyNVR页面显示网络请求失败问题 发现问题
很多用户在使用EasyNVR进行安防互联网直播时，出现显示“网络请求失败”问题，无法访问服务。
分析问题
遇到此问题很多用户第一反应是重启EasyNVR服务，但有时候重启大法并不能真正解决问题。此时很大可能是EasyNVR后台服务已经停止，重启时表面上我们已经终止EasyNVR服务，实际上进程中nginx服务并没有停止运行，重启只会让任务管理器进程中有多个nginx服务，问题依然存在。
解决问题
到这一步解决方法已经很明朗，只需要在任务管理器的进程管理中，将nginx.exe停止。然后启动easynvr服务，刷新后即可正常登陆查看。
本文转自：RTSP安防网络摄像头/海康大华硬盘录像机/NVR网页无插件低延时播放流媒体服务器EasyNVR页面显示网络请求失败问题 - EasyNVR - 博客园
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a73adf93fbb2fe3a8181a786a1c46692/" rel="bookmark">
			Servlet实现分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
为什么要使用分页去显示数据?
思路
实现效果
步骤
(1)创建PageUntil分页工具类
(2)声明对应的属性进行封装
(3)计算数据可以显示的总页数
(4)获取页码数据记录
问题
(5)servlet填充对象内容
Service层根据参数查找数据
Dao层访问数据库
(6)设置页面
为什么要使用分页去显示数据? 当我们在浏览器看一堆很长的列表时，滚动条一滑动，很容易找不到位置，当数据量庞大时，数据库的加载和浏览器解析请求时变的很慢。
思路 确定每页需要的数据数量。计算数据可以显示的总页数实现获取指定页码的数据记录 实现效果 步骤 (1)创建PageUntil分页工具类 Constats类用来存放常量，固定不变的值，如每页的数据量
(2)声明对应的属性进行封装 //当前页数 private int pageIndex; //每页数据量 private int pageSize = Constats.PAGE_SIZE; //总数据量 private int pageTotalCount; //总页数 private int pageTotal; //存储列表分页数据 private List&lt;T&gt; listdata; public List&lt;T&gt; getListdata() { return listdata; } public void setListdata(List&lt;T&gt; listdata) { this.listdata = listdata; } public int getPageIndex() { return pageIndex; } public void setPageIndex(int pageIndex) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a73adf93fbb2fe3a8181a786a1c46692/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf4f04110fa5c3158c9b033930be331/" rel="bookmark">
			UniGUI 后台管理系统框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TOC](UniGUI 管理系统框架)
UniGUI 确实是D的网站开发利器，熟悉D的同学很快就能上手， 除了界面美化需要一部分css外。
已经实现的功能：
免密登录
平台和供应商多组织架构
表格导出到Excel
PDF报表内嵌图片
邮件任务通知
格式图表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe5378d9e3039ad7a0cee3c081279c71/" rel="bookmark">
			利用FormData上传本地文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近接了个小项目，有个用客户端本地文件的需求。
正常这种需求都是前台传文件，后台去解析。
但这次C++的老哥非让我给文件路径，说公司平台有解析文件的能力。
我说web不是桌面端，拿不到真实路径，他还不信😪
最后一顿‘掰头’，还是传文件
本来还是想用element-plus省事，但想到用公司平台做前后台通信也就放弃了
还是用FormData吧！
FormData FormData 对象是ajax2.0新提出的接口，它将数据编译成键值对，以便用来发送数据。
使用：new一个FormData对象，然后调用它的append()方法来添加字段；
当然， FormData还有其他的方法，这里就不一一介绍了。
上传文件 首先，我们创建一个input框，用于上传文件并绑定change事件，然后通过change事件拿到文件。
然后，实例化一个FormData对象, 将文件通过append方法，添加到FormData对象。
最后，将添加好的FormData通过xhr发送到后台。
示例代码 &lt;input type="file" onchange="upload(event)"&gt; const upload = function (event) { let file = event.target.files[0]; const formData = new FormData(); formData.append('file', file); // xhr发送到后台 // ... } 拓展 在此基础之上，可以拓展一下，将数据（通过 Blob 对象，以及File 对象）转成文件后，再发到后台。
虽然，这么说有点蠢，一般没有人会这么干，但是在上传一些工程文件还是有应用场景的。
至少我用到了，你呢？
结语
本文到此结束，谢谢大家的观看！
如有问题，欢迎各位指正！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08d107488b0445409c1eea089ea7430c/" rel="bookmark">
			注意力机制与外部记忆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		==《神经网络与深度学习》By 邱锡鹏 ==
在实践中很难达到通用近似的能力。在处理复杂任务时，比如需要处理大量的输入信息或者复杂的计算流程时，目前计算机的计算能力依然时限制神经网络发展的瓶颈。
通过引入人脑的生物神经网络中两个重要机制可以解决信息过载问题：注意力和记忆机制。目的是在有限的资源条件下，提高神经网络处理信息的能力。
1 认知神经学中的注意力 注意力分为两种：
聚焦式注意力，指有预定目的、依赖人物的，主动有意识地聚焦于某一对象的注意力。基于显著性的注意力，由外界刺激驱动的注意，不需要主动干预，也和任务无关。 鸡尾酒效应：
当一个人在吵闹的鸡尾酒会上和朋友聊天时， 尽管周围噪音干扰很多， 他还是可以听到朋友的谈话内容， 而忽略其他人的声音（ 聚焦式注意力）． 同时， 如果背景声中有重要的词（ 比如他的名字）， 他会马上注意到（ 显著性注意力）
2 注意力机制 注意力机制作为一种资源分配方案，将有限的计算资源用来处理更重要的信息，是解决信息超载问题的主要手段。
注意力分布 为了从N个输入向量中选择出某个特定任务相关的信息，这时引入一个和任务相关的表示，称为查询向量，通过一个打分函数来计算每个输入向量和查询向量之间的相关性。 给定一个和任务相关的查询向量q，我们用注意力变量z表示选择信息的索引位置，为方便计算，采用“软性”的信息选择机制。令αn为注意力分布参数，s(x,q)为注意力打分函数：
加权平均： 注意力分布αn可以解释为在给定任务相关的查询q时，第n个输入向量受关注的程度。采用“软性”的信息选择机制对输入信息进行汇总：
以下是软性注意力机制的示例
2.1 硬性注意力 软性注意力，其选择的i学你系是所有输入向量在注意力分布下的期望。而影星注意力只关注某一输入向量。
两种实现方式：
选取最高概率的输入向量
通过在注意力分布式上随机采样的方式实现 影星注意力缺点是基于最大采样或随机采样的方式来选择信息，是的最终的损失函数与注意力分布之间的函数关系不可导，无法使用反向传播算法进行训练。因此，Hard Attention 需要使用强化学习来进行训练。
2.2 键值对注意力 用键值对(key-value pair) 格式来表示输入信息，其中“键”用来计算注意力分布，“值”用来计算聚合信息。
注意力函数为：
2.3 多头注意力 利用多个查询Q，来并行从输入信息中选取多组信息、每个注意力关注输入信息的不同部分。
2.4 结构化注意力 之前假设所有的输入信息是同等重要的，是一种扁平结构，注意力分布实际上实在所有输入信息上的多项分布。如若输入信息本身具有层次结构，比如文本可以分为词、句子、段落、篇章等不同粒度的层次，此时可以使用层次化的注意力来进行更好的信息选择。此外还可以假设注意力为上下文相关的二项分布，用一种图模型来构建更复杂的结构化注意力分布。
2.5 指针网络 注意力机制主要是用来做信息筛选，从输入信息选取相关的信息。注意力机制可以分为两步：计算注意力分布α，根据α来计算输入信息的加权平均。这里指利用注意力机制的第一步，将注意力分布作为一个软性的指针来指出相关的信息位置。
3 自注意力模型 如果要建立输入序列之间的长距离依赖关系， 可以使用以下两种方法： 一种
方法是增加网络的层数， 通过一个深层网络来获取远距离的信息交互； 另一种方法是使用全连接网络。全连接网络是一种非常直接的建模远距离依赖的模型， 但是无法处理变长的输入序列。 不同的输入长度， 其连接权重的大小也是不同的。这时我们就可以利用注意力机制来“动态” 地生成不同连接的权重， 这就是自注意力(亦称内部注意力)模型（ Self-Attention Model）。
具体计算过程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08d107488b0445409c1eea089ea7430c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4083fb5661616ee7e0ae361add23e03/" rel="bookmark">
			华为BGP协议基础配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、原理概述
二、实验目的
三、实验拓扑
四、实验步骤
五、查看代码：
一、原理概述 1、自治系统（AS）是由一个技术管理机构管理，使用统一选路策略的一组路由器集合,自治系统编号范围：1-65535，其中1-64511是互联网上注册公有AS号，类似公网IP地址。64512-65535是私有AS号，类似私网IP地址
2、IGP：自治系统内部路由协议，主要：RIP1/RIP2、OSPF、ISIS、EIGRP（思科私有协议.
3、IGP是运行在AS内部的路由协议，主要解决AS内部的选路问题，发现、计算路由EGP：自治系统之间的路由协议，通常：BGP
4、EGP是运行在AS与AS之间的路由协议，他解决AS之间问题。
5、BGP是边界网关协议，版本BGP4，是一种增强的距离矢量路由协议。该协议运行在不同的AS的路由器之间，用于选择AS之间花费最小的协议。BGP协议基于TCP协议端口为179,使用面向连接的TCP可以进行身份认证，可靠地交换路由信息。BGP4+支持IPv6。
特点：
1）、不用周期性发送路由信息。
2）、路由变化，发送增量路由（变化的路由信息）。
3）、周期性发送Keepalive报文效验TCP的连通性。
6、对等体（Peer）
在BGP中，两个路由器之间的相邻连接称为对等体连接，两个路由器互为对等体。如果路由器对等体在同一个AS中，就称为IBGP对等体，否则称为EBGP对等体。BGP4网关向对等实体发布可以到达的AS列表。
7、BGP消息，BGP常见四种报文：OPEN报文、KEEPLIVE报文、UPDATE报文和NOTIFICTION报文。
1）、OPEN报文：建立邻居关系。
2）、KEEPLIVE报文：保持活动状态，周期性确认邻居关系，对OPEN报文回应。
3）、UPDATE报文：发送新的路由信息。
4）、NOTIFICATION报文：报告检测到的错误。
8、BGP工作流程
1）、BGP路由器直接进行TCP三次握手，建立TCP会话连接。
2）、交换OPEN信息，确定版本等参数，建立邻居关系。
3）、路由器交换所有BGP路由，直到平衡，之后只交换变化了的路由信息。
4）、路由更新由UPDATE完成
5）、通过KEEPALIVE难路由器是否可用。
6）、出现问题，发送NOTIFICATION消息通知错误。
二、实验目的 BGP基本配置AR2、AR3、AR4间配置IBGPAR1、AR2间配置EBGP 三、实验拓扑 四、实验步骤 1、各路由器及PC配置IP地址：
//AR1
[Huawei]sysname AR1
[AR1]int g0/0/0
[AR1-GigabitEthernet0/0/0]ip add 172.16.1.1 24
[AR1-GigabitEthernet0/0/0]int g0/0/01
[AR1-GigabitEthernet0/0/1]ip add 192.168.1.1
[AR1-GigabitEthernet0/0/1]ip add 192.168.1.1 24
[AR1-GigabitEthernet0/0/1]q
[AR1]q
&lt;AR1&gt;sa
//AR2
&lt;Huawei&gt;sys
[Huawei]sysname AR2
[AR2]int g0/0/0
[AR2-GigabitEthernet0/0/0]ip add 172.16.1.2 24
[AR2-GigabitEthernet0/0/0]int g0/0/1
[AR2-GigabitEthernet0/0/1]ip add 172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4083fb5661616ee7e0ae361add23e03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22f9944b28bc55dc5d68f9ac65bbe209/" rel="bookmark">
			HFSS使用经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、如何找到Project工程变量
二、coverlines是什么东西
三、参数建模的第一步
四、让HFSS模型居中的快捷键Ctrl+D
五、关于介质颜色的修改
六、如何在HFSS中添加变量
七、如何绘制微带线
八、如何绘制带缺口的微带线谐振腔
九、如何设置激励源
十、HFSS如何镜像的对称操作
​十一、HFSS设置Boundaries的注意点
十二、HFSS中Edit Sources设置
一、如何找到Project工程变量 点击工程文件HFSSDesign1，就可以在左下角看到Properties了。
二、coverlines是什么东西 coverlines 就是利用几条首尾相接的线来形成一个面，这些线就为所形成的面的轮廓。 三、参数建模的第一步 Position标注的是图中红色圆圈的点，这是矩形的起始位置，画出的矩形块是图中黑色线标注的区域 。
XSize和YSize表示向X轴和Y轴延申的距离。
四、让HFSS模型居中的快捷键Ctrl+D 如图，可以达到图示的效果。
五、关于介质颜色的修改 我们可以看到介质颜色是成黄铜的红棕色，我们徐娅在sub中修改颜色
在这个时候，Ground的颜色就会和介质片的颜色有明显区分了 六、如何在HFSS中添加变量 双击左下角蓝色的框，点击ADD按钮，添加variable类型的变量，注意unit type要选择Length. 七、如何绘制微带线 图中淡紫色的线是由合并操作构成的，我们要写分别画两个矩形，最后UNIT操作就可以，如下图所示。
因为微带线的厚度可以忽略，我们可以创建sheet类型。图标位置可能不太一样，但是画rectangle的图标是一样的。
八、如何绘制带缺口的微带线谐振腔 简易的微带线谐振器如上图所示，其实是由三个矩阵做substract的布尔操作构成的。如下图，需要确定做差的是哪几个矩形。 如果是不小心误选了HFSS软件中的bool操作，想要撤销，可以直接delete就可以
可以恢复到原来的形式，如下图
九、如何设置激励源 注意，要先修改平面为激励源所在的平面。此处的矩形是激励端口，我们仍需要先绘制sheet，然后再Assign Excitation. 为什么要在Sheet里面设置为端口呢，因为HFSS仿真时候不允许出现没有指定材料的物体
设置激励端口的方法如下图，注意图中我们只是示范，实际上我们需要设置为集总端口
因为已经有两个Port了，所以Port的名字HFSS自动设置为3.注意到Port Impedence自动设置为Resistence是50.
下一页的integration Line 是用来指定电场方向的(具体我不是很理解)。
可以看到在中点处鼠标会变为三角形，我们可以画出Integration Line
注意这只是Lumped Port加积分线的方法，对于Wave port是不同的。
如果想要设置wave port的方向，需要画一个PEC材料的、有厚度的长方体，如下图所示。带箭头的线就是积分线。通过这样可以限制能量的传输方向。
十、HFSS如何镜像的对称操作 在特殊点处，鼠标的形状会发生改变，我们在这里需要选择为原点，并且复制镜像就可以完成。
十一、HFSS设置Boundaries的注意点 设置Perfect E Boundary时，可以让同一平面的Perfect E取同一个名字，这样可以便于直接查看。
十二、HFSS中Edit Sources设置 在Field Overlays中有Edit Sources按钮，单击进入
"1:1",前面一个1是表示激励端口的名字，后面一个1是激励的模式。1表示单模工作
十三、如何设定介质材料 我们可以观察到没有厚度的片，在HFSS中是无法设定材料的。 可以看到，Location位于Project中，所以它是我们自己设定的材料
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22f9944b28bc55dc5d68f9ac65bbe209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f53ba1338b03fe4e637f691b3175714b/" rel="bookmark">
			「网络工程师必会技能」-路由器介绍和路由器基本配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「网络工程师必会技能」-路由器介绍和路由器基本配置，这是每个网络必须会的技能，不是你有证书就一个网络工程师了哦！
以Cisco路由器为例说明：
（1）访问路由器。访问路由器与访问交换机一样，可以通过Console（控制台）端口连接终端或安装了终端仿真软件的PC；通过设备AUX端口连接Modem；通过Telnet；通过浏览器；以及通过网关软件5种方式进行访问。
使用console端口连接的方式，通常也是使用“超级终端”仿真软件，并将端口的属性配置为：端口速率为9600b/s，数据位为8，奇偶校验为“无”，停止位为1，流控为“无”。
（2）路由器的组成。与交换机一样，Cisco路由器也有4种功能不同、材质不同的内存：用来存储引导软件的ROM，用来保存ISO系统软件的Flash，用来作为主存的RAM，用来保存启动配置的NVRAM。在路由器中，也包括两份配置，一份是当前运行的（Running-config），存储在RAM中；另一份则是备份配置（Start-config），存储在NVRAM中，每次启动时会自动装入。
（3）配置状态与转换命令。与交换机一样，Cisco路由器也分为用户模式（登录时自动进入，只能查看简单的信息）、特权模式（也称EXEC模式，能够完全配置修改、重启等工作）、全局配置模式（对会影响ISO全局运作的配置项进行设置）、子配置模式（对具体的组件，如网络接口等进行配置），4种状态的转换命令如下图所示：
1、路由器基本配置
（1）配置enable口令和主机名
Router &gt; （用户模式提示符）
Router &gt; enable （进入特权模式）
Router # （特权模式提示符）
Router # config terminal （进入配置模式）
Router（config）# （配置模式提示符）
Router（config）# enable password test （设置enable口令为test）
Router（config）# enable secret test2 （设置enable加密口令为test2）
Router（config）# hostname R1 （设置主机名为R1）
Router（config）# end （返回特权模式）
R1 #
注意：enable password和enable secret只要配置一个就好，两者同时配置时后者生效。它们的区别在于，enable password在配置项中是明文显示，而enable secret是密文显示。
（2）接口基本配置：在Cisco路由器通常是模块化的，每个模块都有一些响应的接口，例如以太网接口、快速以太网接口、串行口（Serial，即广域网口）等。与交换机不同，它们在默认情况下是关闭的，需要人为启动它。
Router &gt; enable
Router &gt; config terminal
Router（config）# interface fastethernet0/1
Router（config）# ip address 192.168.0.1 255.255.255.0
Router（config）# no shutdown (激活接口)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f53ba1338b03fe4e637f691b3175714b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d6314485d2b500315d4b30a9c3749e1/" rel="bookmark">
			Nginx搭建Netty负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx搭建Netty负载均衡
参考链接:利用Nginx的stream实现Netty的TCP负载均衡
笔记记录一下用Nginx实现netty的负载均衡学习过程。
一、实现nettyserver，springboot+netty ServerNetty示例代码
package com.example.demo1.netty; import io.netty.bootstrap.ServerBootstrap; import io.netty.buffer.PooledByteBufAllocator; import io.netty.channel.Channel; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.nio.NioServerSocketChannel; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.stereotype.Component; @Component public class ServerNetty implements ApplicationRunner { final static Logger log = LogManager.getLogger(ServerNetty.class); @Value("${netty.port}") private int port; private String ip = "127.0.0.1"; public void start() throws InterruptedException { NioEventLoopGroup boss = null; NioEventLoopGroup worker = null; try { ServerBootstrap b = new ServerBootstrap(); boss = new NioEventLoopGroup(); worker = new NioEventLoopGroup(); b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d6314485d2b500315d4b30a9c3749e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44664f20e42081ec5f8f7e6d19c71d76/" rel="bookmark">
			获取输入日期的下一天(Java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		年份的范围在1920-2050之间
代码实现 import java.util.Scanner; //获取输入日期的下一天 public class NextDate { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); NextDate nextdate = new NextDate(); System.out.println("请输入年份:"); int year = scanner.nextInt(); System.out.println("请输入月份:"); int month = scanner.nextInt(); System.out.println("请输入天数:"); int day = scanner.nextInt(); nextdate.DataWay(year,month,day); } private int year;//年 private int month;//月 private int day;//日 //获取输入日期的下一天 public void DataWay(int year,int month,int day){ this.year = year; this.month = month; this.day = day; //检验天数 if(!(day &gt;= 1 &amp;&amp; day &lt;= 31)){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44664f20e42081ec5f8f7e6d19c71d76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06e381590ac756f1ce2f1804977811d7/" rel="bookmark">
			读取excel文件read_excel()--Pandas
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 函数功能 读取excel文件，支持读取xls,xlsx,xlsm等类型的EXCEL文件。能够读取一个sheet表或多个sheet表
2. 函数语法 pandas.read_excel(io, sheet_name=0, *, header=0, names=None, index_col=None, usecols=None, squeeze=None, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, decimal='.', comment=None, skipfooter=0, convert_float=None, mangle_dupe_cols=True, storage_options=None) 3. 函数参数 3.1 读取文件 参数含义IO文件路径sheetname读取的sheet表，取值可以是字符串、表示sheet索引的整数，或列表；取值为None时表示读取所有的sheet表数据；默认读取第一个sheet的数据 3.1.1 默认读取第一个sheet表 3.1.2 指定读取文件的索引 3.1.3 指定读取文件的名字 3.1.4 读取多个文件 可以使用文件名或文件索引组成的列表或者sheet_name=None：
读取的内容将： 以DataFrame组成的字典形式展示
3.2 其他常用参数 参数含义IO文件路径sheetname读取的sheet表，取值可以是字符串、表示sheet索引的整数，或列表；取值为None时表示读取所有的sheet表数据；默认读取第一个sheet的数据header用于列名的行，默认取值为0，第一行作为列名 ，当文件中不存在列名时，指定header=Nonenames指定列名，当文件中不存在列名，可通过header=None,并指定列名names列表index_col指定用于数据框行标签的列，默认值为None，不存在这样的列，会创建range(n)的行标签usecols选取要读取的列，默认取值为None，表示读取所有列；取值可以是字符串或者字符串或索引值组成的列表skiprows取值可以是要跳过的行索引组成的列表；也可以是整数表示要从头开始要跳过的行数nrows整数，指定读取数据的行数na_values指定识别为空值NA的内容，取值为字符串、数值、列表或字典keep_default_na布尔值，默认取值为TRUE，是否将默认为空值的字符串识别为NaN 详细内容参见：读取csv格式的数据–Pandas
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8499444c2f7ffd469381d6fdef248b38/" rel="bookmark">
			pytorch 模型训练（以CIFAR10数据集为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pytorch模型训练时，基本的训练步骤可以大致地归纳为：
准备数据集---&gt;搭建神经网络---&gt;创建网络模型---&gt;创建损失函数---&gt;设置优化器---&gt;训练步骤开始---&gt;测试步骤开始
本文以pytorch官网中torchvision中的CIFAR10数据集为例进行讲解。
需要用到的库为（这里说一个小技巧，比如可以在没有import对应库的情况下先输入"torch",，之后将光标移到torch处单击，这时左边就会出现一个红色的小灯泡，点开它就可以import对应的库了）：
import torch import torchvision from torch import nn from torch.utils.data import DataLoader from torch.utils.tensorboard import SummaryWriter 准备数据集 数据集分为“训练数据集”+“测试数据集”。CIFAR数据集是由50000训练集和10000测试集组成。这里可以调用torchvision.datasets对CIFAR10数据集进行获取：
#训练数据集 train_data=torchvision.datasets.CIFAR10(root='./dataset',train=True,transform=torchvision.transforms.ToTensor(),download=True) #测试数据集 test_data=torchvision.datasets.CIFAR10(root='./dataset',train=False,transform=torchvision.transforms.ToTensor(),download=True) #利用dataloader来加载数据集 train_data_loader=DataLoader(train_data,batch_size=64) test_data_loader=DataLoader(test_data,batch_size=64) root是数据集保存的路径，这里笔者使用的是相对路径；对于训练集train=True，而测试集train=False；transform是将数据集的类型转换为tensor类型；download一般设置为True。之后利用DataLoader对数据集进行加载即可，其中batch_size表示单次传递给程序用以训练的数据（样本）个数。
（这里可以再获取下测试集数据的长度，这样后面在测试步骤时就可以通过计算得到整体测试集上的准确率）
搭建神经网络 pytorch官网提供了一个神经网络的简单实例：
import torch.nn as nn import torch.nn.functional as F class Model(nn.Module): def __init__(self): super().__init__() self.conv1 = nn.Conv2d(1, 20, 5) self.conv2 = nn.Conv2d(20, 20, 5) def forward(self, x): x = F.relu(self.conv1(x)) return F.relu(self.conv2(x)) 这个实例展示了神经网络的基本架构。
从百度上我们可以搜索到CIFAR10数据集的网络基本架构：
从原理图中可以看到，该网络从输入（inputs）到输出（outputs）先后经过了
卷积(Convolution)---&gt;最大池化(Max-pooling)---&gt;卷积---&gt;最大池化---&gt;卷积---&gt;最大池化---&gt;展平(Flatten)---&gt;2次线性层
由此可以开始搭建神经网络，笔者将网络命名为MXC：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8499444c2f7ffd469381d6fdef248b38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ae52d74e98b6b7ff5ff0f3a61d5d59a/" rel="bookmark">
			新型企业级分布式数据库oceanbase介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，什么是OceanBase？记得一两年前，在很多技术社区，我经常遇到这样的问题。有同学问OceanBase是企业级分布式数据库还是键值数据库。甚至有同学问阿里的数据库是怎么开发的。是从开源数据库转化而来的吗？最近这种问题已经很少了，但还是想简单说一下。OceanBase是阿里巴巴和蚂蚁金服集团自研的数据库。我们拥有OceanBase所有源代码的完全知识产权。
如果我三年前说什么是海洋基地？我可能会说OceanBase是一个分布式存储系统，但是今天，让我很有信心地告诉你，OceanBase是一个通用的全功能企业级分布式数据库产品。
作为基于分布式架构的企业级分布式数据库OceanBase有很多技术优势，但我认为其中的核心是ocean base，它完全可以搭建一个基于普通PC服务器的数据库集群，可以满足财务可靠性和数据一致性的要求。
如前所述，OceanBase是自研的企业级分布式数据库。其实我们称之为类似数据库的基础软件产品，国内目前还有很多团队在开发基础软件产品。对于所有这样的团队来说，其实在他们发展的过程中，都会面临一个非常关键、生死攸关的问题，那就是你如何让你的客户相信你的产品是稳定可靠的，你的产品是可用的？要证明这一点，往往需要这个产品在典型应用中长时间稳定运行，所以很多情况下会形成死锁。
OceanBase诞生并成长于阿里巴巴、蚂蚁金服集团等快速发展的互联网公司。如此快速成长的互联网公司，本身就是一个巨大的企业级分布式数据库应用市场。所以OceanBase这几年的发展，其实就是在这个市场上不断证明自己的过程。通过在这个市场的不断应用，帮助OceanBase加速产品成熟，帮助OceanBase度过一个自研基础软件产品最难的应用壁垒。
蚂蚁金服也通过OceanBase的应用，实现了所有核心业务的100%去O化。如今，OceanBase已在数十项关键业务上投入运营，包括支付、交易、会计、网商银行等系统。其实很多核心系统已经稳定运行多年，期间也经历了双十一大会等多次实战的考验。
去年我们正式发布了OceanBase的最新产品OceanBase1.0。OceanBase1.0在整个系统架构以及产品性能和兼容性方面都有了很大的进步。最重要的是，OceanBase1.0是整个OceanBase产品发展史上第一款具备大规模应用推广能力的产品。
接下来，我们将从几个方面向您介绍OceanBase的一些重要特性:
扩展性
我们知道商用企业级分布式数据库 extension模型本质上是单机扩展，可以通过引入处理能力更强、可靠性更高的软硬件设备来解决系统的可靠性和可扩展性问题，但也更昂贵。这种延伸模式也称为垂直延伸。垂直扩张有其非常重要的优势。它的优点是整个系统的整体交付非常好，所以垂直扩展非常有利于业务。
但是纵向扩展有两个缺点:一是成本非常高，二是扩展性差。以互联网行业为代表的企业，面对自身业务的快速增长和现有IT系统的可扩展性和成本之间的矛盾，选择在企业级分布式数据库之外解决系统可靠性和可扩展性问题。简单来说，在业务层面，将业务的数据层面进行拆分，将原本由一个数据库集群完成的功能分割成几个独立的单机数据库。原来很多应该由企业级分布式数据库来完成的功能都是由一个统一的中间层来管理的，也就是我们常说的子数据库子表的模型。
这种数据库和表划分模型有其非常重要的优点，有两点:
第一点是，整个数据的划分在应用程序设计的早期就已经决定了，因此这种模型通常具有良好的可扩展性。
第二点是，这种以中间层为核心的扩展，大大降低了对硬件包括数据库本身的依赖，从而可以显著降低整个系统的成本。
但是这种中间成本模式有一个很重要的缺点，就是对业务的侵扰很重，采用这种模式通常需要对业务本身进行比较大的改造。对企业整体的IT建设能力，包括运维能力提出了很高的要求。所以目前如果想把这样的模式复制到互联网以外的其他行业，其实是有很大挑战的。
OceanBase希望在这方面做得更多，希望通过我们产品的能力，把系统的可靠性和可扩展性重新纳入数据库的范围。基于统一部署的分布式数据库集群，用户在使用OceanBase时不需要知道数据是如何分布的，负载是如何平衡的，甚至不需要知道系统是如何容灾的，这样他们就可以减少对现有服务的改造，尽可能简化业务架构的设计，同时保持低成本和线性扩展。所以这是OceanBase的一个非常重要的客户价值:对业务透明。
我前面说过OceanBase是一个分布式集群，扩展性很好，但其实了解OceanBase的同学可能知道，在早期的OceanBase场景中，系统其实是单点的。具体来说，集群中的每个节点都可以提供读服务，但是只有一个节点可以提供写服务，这有点像传统的读写分离的设计。这是一个早期的选择。这种架构的问题是系统的可靠性和可扩展性是单点的，业务写作能力的提升依赖于纵向扩展。所以在OceanBase 1.0中，我们首先解决了这个问题，真正实现了全对等集群。目前集群中的所有节点都可以提供读写服务，使得整个系统的可扩展性和可靠性有了质的飞跃。这种架构的引入也使得OceanBase整体架构稳定，这一点非常重要，这使得OceanBase为加速下一步产品和技术的开发打下了非常重要的基础。
在OceanBase1.0中，我们还正式引入了数据分区的概念。数据分区是OceanBase实现可扩展性和高可用性的基本单元。数据分区和子数据库子表中的子表在功能上非常相似，都可以支持扩展，唯一不同的是数据分区是由数据库内核自己实现的。通过用户定义数据分区，系统可以帮助业务自动完成多机扩展，系统自动容灾。整个过程对企业是透明的。我们希望在未来，更多的企业可以使用分区来代替现有的子表，并帮助他们简化中间层的设计。
海洋基地的可用性
关系数据库传统的主备架构，无论一主一备，一主多备，基于主备强同步的最大保护模式，还是基于主备弱同步的最大性能模式，当主备间任意一个节点失效时，系统要么选择停止服务，要么选择忍受主备间的数据不一致。对于关键业务，停止服务是不可接受的，这意味着在这种架构下，当我们在活动和备用之间切换时，系统通常会丢失数据。OceanBase很好的解决了这个问题。
OceanBase的核心是Paxos分布式选举协议的工业化实现。Paxos协议本身是一个多数协议。根据Paxos协议，对数据库的任何更改都需要大多数成员的同意才能进行。这句话可以反过来理解，对数据库的任何改动都要经过大多数成员的同意才能进行。因此，在Paxos协议下，任何少数成员的故障都不会影响系统的可用性和数据一致性。
下图显示了一个简单的三节点OceanBase集群，其中有一个主集群和两个备用集群。在Paxos协议下，如果三个节点中的任何一个出现故障，系统都不会停止服务或丢失数据。同时，如果主节点出现故障，其他两个备用节点可以在短时间内自动重新选择一个主节点恢复服务。目前OceanBase级别的故障恢复时间是20秒，加上服务级别是几十秒，不超过一分钟。这不是实验环境的数据，而是很多真实故障下的实际表现。海洋基地的可用性
关系数据库传统的主备架构，无论一主一备，一主多备，基于主备强同步的最大保护模式，还是基于主备弱同步的最大性能模式，当主备间任意一个节点失效时，系统要么选择停止服务，要么选择忍受主备间的数据不一致。对于关键业务，停止服务是不可接受的，这意味着在这种架构下，当我们在活动和备用之间切换时，系统通常会丢失数据。OceanBase很好的解决了这个问题。
OceanBase的核心是Paxos分布式选举协议的工业化实现。Paxos协议本身是一个多数协议。根据Paxos协议，对数据库的任何更改都需要大多数成员的同意才能进行。这句话可以反过来理解，对数据库的任何改动都要经过大多数成员的同意才能进行。因此，在Paxos协议下，任何少数成员的故障都不会影响系统的可用性和数据一致性。
下图显示了一个简单的三节点OceanBase集群，其中有一个主集群和两个备用集群。在Paxos协议下，如果三个节点中的任何一个出现故障，系统都不会停止服务或丢失数据。同时，如果主节点出现故障，其他两个备用节点可以在短时间内自动重新选择一个主节点恢复服务。目前OceanBase级别的故障恢复时间是20秒，加上服务级别是几十秒，不超过一分钟。这不是实验环境的数据，而是很多真实故障下的实际表现。
基于OceanBase的这种高可用架构，我们可以根据业务和机房条件的不同容灾需求，跨机房部署数据库集群。
简要介绍三种常见的部署模式:
第一种本地部署。
这种模式比较简单。业务流量只能在本地部署。我们知道Paxos协议要求多数，三个以上的成员才能形成多数，所以我们要求至少三个机房，三份数据。这种部署模式具有机房级容灾能力，城市级故障时系统无法服务。
第二种本地部署+异地容灾模式。
同一业务的流量只能在本地部署，三个机房两个在本地，一个在异地。这种模式还具有机房级的容灾能力，可以在发生城市故障时提供异地容灾的能力。在很多场景下，客户可能在本地找不到第三机房，采用这种模式也是不错的选择。
我们需要付出的成本是，远程容灾室不提供日常情况下的流量。这里我们使用了5份数据，而不是我们刚刚看到的3份。为什么不是3份？因为使用了三个副本，所以当本地机房的任何一个服务器出现故障时，这个服务器的数据分区就只剩下两个副本，一个在另一个本地机房，另一个在容灾机房。此时，当系统的大部分形成时，需要两个城市之间的强同步，这在性能上是不可接受的。因为用来搭建OceanBase的数据库集群都是普通的PC服务器，单机故障非常常见。这里引入了5个数据副本，并以2+2+1的方式部署。第一，确保每个机房的份数不会形成多数。第二，如果本地机房一个副本出现故障，其他三个本地副本可以形成多数，也就是说单机故障不会导致业务的RT，因为需要引入城市间的强同步而显著增加。
多站点部署的第三种模式。
这也是一种具备城市级容灾能力的部署模式，意味着数据容灾可以交给底层数据库，可以大大简化容灾架构的设计。
支持城市级容灾有两点:一是流量本身可以在很多地方部署，当一个城市级故障发生时，流量本身可以切换到其他城市。
其次，支持城市容灾意味着我们应该在城市层面形成多数，这意味着整个数据库集群需要部署在至少三个城市。同样的数据也是五份，我们也避免了单机故障导致的业务流量跨城市的切换。支持城市容灾的成本很高，因为城市容灾意味着对数据库的任何更改都需要两个城市之间的强同步，这意味着任何更新事务的提交延迟都会增加。这个延迟就是两个城市之间的网络同步延迟，根据城市之间的距离不同，通常在几毫秒到几十毫秒之间。因此，要支持多站点部署模式，首先必须对业务进行评估。这种延迟会对服务的性能和容量产生重大影响吗？如果是这样，需要对其进行优化，以减少在同步链路上提交的更新事务的数量。
这里要说明的是，无论采用哪种部署模式，所有这些跨多个机房部署的节点都是一个完整数据库集群的一部分。OceanBase可以在这个数据库集群中自动实现流量路由、故障转移和负载均衡。从业务使用或者运维的角度来说，整体交付，这是前面说的最重要的客户价值。对于业务透明，这也是OceanBase接下来最重要的工作方向，我觉得。
这里看一下我们目前的表现水平。应该说，在OceanBase架构稳定之后，OceanBase的整体性能水平在过去一年有了很大的提升。这个性能水平也是目前公布的所有三个同步性强的数据库产品的性能测试结果中最好的。
OceanBase的其他功能描述如下。
首先是Mysql完全兼容。完全兼容Mysql的工作量其实非常大。去年我们也投入了大量的人力进行相关产品的研发。到目前为止，OceanBase已经实现了从sql语法、数据类型到系统函数等对Mysql的完全兼容。作为这项工作的副产品，我们去年向Mysql开源社区提交了200多个有效的bug。Mysql完全兼容的事实，大大强化了OceanBase作为通用关系数据库的产品特性，真正帮助商家迁移到OceanBase，无需更改一行代码，降低了用户的迁移成本和学习成本。同时，OceanBase真正具备大规模应用和部署的能力。
OceanBase1.0支持的另一个重要特性是多租户。该功能的推出也正式宣布OceanBase成为云数据库产品，可以对外提供云服务，支持业务云。OceanBase对多租户的支持是系统在内核层面的原生支持。我们称之为SaaS或DBaaS架构。我们可以看到Oracle最新版本推出的多租户也是基于这种架构，而我们目前在市场上看到的云数据库产品，大部分都是基于这样一种隔离不同数据库实例的IaaS架构。相比IaaS架构，OceanBase这种原生支持的架构可以实现不同租户之间底层资源的共享，从而提高硬件的利用率和集群部署的密度。同时，多租户的资源隔离大大加强了产品在整个资源中的整合，包括系统运维的能力。
以上是OceanBase 1.0在其他方面的一些重要特性。
其中很多已经超过了Mysql现有的支持能力。在设计这方面的功能性能时，我们查阅了很多商业数据库。比如OceanBase1.0就推出了完整的诊断监控系统，很大程度上参考了Oracle，所以ORACLE中很多基础的监控设施，比如Top SQL，Top Wait等。，目前实际上已经得到了OceanBase的全力支持。其他类似的功能，包括SQL大纲、闪回、物化视图等等，都是一样的。这些特性使得基于ORACLE知识体系的客户，包括运维方面的学生，如果以后使用OceanBase，对很多方面都很熟悉。
我刚才说的是OceanBase的一些核心的特点。作为一个完整的产品形态，OceanBase还包括一个非常强大的管理和运营平台OCP。
目前无论是内部客户还是外部客户，无论是开发生还是运维生，都是基于同一个平台接入和使用OceanBase。通过OCP平台，我们可以为业务构建从业务接入、数据迁移、在线部署、日常运维的完整、封闭的功能链，从而帮助业务实现整体上云。
经过几年的发展，OceanBase在产品上积累了很多重要的技术优势。同时，随着近年来整个核心业务的稳定运行，蚂蚁金服向业界证明了OceanBase能够支撑金融核心业务。去年我们也正式启动了OceanBase通过阿里云平台对外提供服务的进程。到目前为止，我们已经与一些金融客户开展了实质性的项目合作，欢迎大家进一步了解和使用OceanBase！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d80cd0a5dc2320cbd29ada5950f99984/" rel="bookmark">
			SANGFOR深信服远程办公客户端EasyConnect在Windows11使用兼容性问题解决案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日在使用深信服远程办公客户端EasyConnect时发现，很多装有Windows11的计算机在开启EasyConnect连接服务器时初始化一直不成功，使用其他浏览器打开服务器网页正常。用vbs脚本打开ie11：
CreateObject("InternetExplorer.Application").Visible=true 发现ie11访问服务器网页报错，显示站点连接不安全。使用fiddler抓包得到以下内容：
A SSLv3-compatible ClientHello handshake was found. Fiddler extracted the parameters below. Version: 3.3 (TLS/1.2) Random: XX XX "Time": 2018/11/9 4:11:14 SessionID: empty Extensions: 注意到浏览器使用了tls 1.2版本进行握手，同时返回内容为：
fiddler.network.https&gt; HTTPS handshake to ssl.xxx (for #6) failed. System.Security.Authentication.AuthenticationException 调用 SSPI 失败，请参见内部异常。 &lt; 给函数提供的标志无效 Win32 (SChannel) Native Error Code: 0x80090308 怀疑是两端tls协议不兼容导致问题，于是将ie11中tls 1.2支持关闭，仅保留1.0和1.1。刷新网页后网页显示正常。但从网页输入账号还是无法打开easyconnector客户端，另外在fiddler中抓包发现除浏览器外还有ecagent进程发起的https请求报以上错误。
于是尝试在Windows11中全局禁用tls 1.2，在注册表编辑：计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2\Client，加入dword名为Enabled值为0代表禁用：
重启计算机后EasyConnect使用恢复正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6be093ccf3b0f169f9799f99650a365d/" rel="bookmark">
			树莓派下载及安装PyCharm软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 运行 PyCharm 需要 Java 环境，如果树莓派上还没有安装过 JRE，可以使用以下命令安装即可：
sudo apt install default-jre -y PyCharm 有专业版和社区版。专业版的功能更全，但是要收费，社区版是免费的，所以推荐下载这个版本。 通过点击这个链接:https://www.jetbrains.com/pycharm/download/#section=linux下载 Pycharm软件。 注意我们要下载的是 Linux 版本的软件。
一、下载方式 下载的方式多种多样，这里我们为了免去很多中间操作，最后使用的是树莓派自带的浏览器进行的软件包下载，文件默认下载到 /home/pi/Downloads 目录下。下载的文件是 tar.gz 格式的压缩包。
二、进入软件包的目录 下载完成后，首先需要通过在命令行输入：cd /home/pi/Downloads 进入到文件的下载目录；然后通过 ls 命令查看该目录下的文件。
三、解压软件包 通过输入：sudo tar -zxvf pycharm-community-2022.3.tar.gz 对软件包进行解压。
四、复制软件包到系统 通过输入：sudo mv pycharm-community-2022.3 /opt/ 把软件包复制到/opt目录，然后输入：cd /opt/pycharm-community-2022.3/bin/ 切换到文件路径。
五、安装运行PyCharm 通过输入：sudo ./pycharm.sh 即可安装PyCharm软件。因为在终端运行.sh文件运行太慢（也可能是网速的原因），因此可直接在文件夹/opt/pycharm-community-2020.3/bin中直接运行pycharm.sh文件。
六、配置运行PyCharm 七、创建桌面快捷方式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca2c080925c7b36d64bde40913374051/" rel="bookmark">
			Docker搭建Cloudreve云盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Docker快速搭建cloudreve云盘，轻量快捷且功能强大，目前cloudreve已经可支持多家云存储，分别有 阿里云OSS、七牛云、腾讯云COS、又拍云等。 1、默认拉取最新版本镜像 docker pull cloudreve/cloudreve 2、在本地创建cloudreve数据卷映射目录 mkdir -p /data/cloudreve/uploads 3、启动cloudreve容器(我这里用的是4777端口) docker run -d --name cloudreve \ -p 4777:80 --restart=always \ -v /data/cloudreve/uploads:/cloudreve/uploads \ cloudreve/cloudreve:latest 4、进入cloudreve容器，需要将 conf.ini 文件中的端口设置为80才能正常访问 docker exec -it cloudreve /bin/sh vi conf.ini 将5212端口修改为80，保存退出，重启cloudreve容器即可
docker restart cloudreve 5、访问方式 localhost:4777 6、查看初始化的账号和密码 docker logs cloudreve 登录后查看到的界面
7、进入管理面板，修改原登录账号和密码，也可以手动新建用户 账号需要设为Email的格式
8、为了安全起见，禁止新用户通过登录页面注册，把“允许新用户注册”选项关闭，保存即可 这样我们就可以使用cloudreve云盘来保存自己的文件了，还有很多实用的功能可以使用，比如添加新的存储策略和离线下载节点、修改页面样式、创建分享链接等，快去部署一个自己研究吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6e30db848111e015fb933818d40049b/" rel="bookmark">
			redis的下载和安装详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载redis安装包 进入redis官网查看当前稳定版本：
https://redis.io/download/ 发现此时的稳定版本是6.2.4，
此时可以去这个网站下载6.2.4稳定版本的tar包。
暂时不考虑不在windows上使用redis，那样将无法发挥redis的性能
二、上传tar包到虚拟机并解压 2.1 新建存放目录并上传tar包 # 进入/usr/local目录 cd /usr/local/ # 新建soft目录存放软件 mkdir soft # 进入刚新建的soft目录下 cd soft 完成上述步骤使用finalshell上传redis安装包到/usr/local/soft目录下：
2.2 解压tar包 tar -zxvf redis-6.2.4.tar.gz 三、安装编译环境并安装redis 3.1 下载安装最新版的gcc编译器 1）安装C 语言的编译环境
# -y 对所有提问都说yes yum -y install gcc 2）查看gcc版本
gcc --version 3.2 编译redis # 进入redis安装目录 cd /usr/local/soft/redis-6.2.4 # 执行编译操作 make 如果没有安装gcc直接进行make会报错：
# 表示没有这个文件 Jemalloc/jemalloc.h 解决方案：
安装gcc运行make distclean然后再进行make 3.2 安装redis 编译完成之后，可以执行安装命令。
make install 安装完成之后/usr/local/bin目录下将会多出一些命令：
命令解析：
redis-benchmark：测试电脑性能的redis-check-aof -&gt; redis-server：检查修复aof文件的，本质是执行了redis-server文件redis-check-rdb -&gt; redis-server：检查修复rdb文件的，本质是执行了redis-server文件redis-cli：redis自带的客户端，可以使用它来连接redis服务端。（这个自带的通常不会使用）redis-sentinel：redis哨兵，用于监控redis集群中Master状态的工具。redis-server：启动服务 四、启动redis 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6e30db848111e015fb933818d40049b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d99f69da58be6ae0a1b89edc088745f/" rel="bookmark">
			机器人开发--CanOpen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器人开发--CanOpen 1 介绍1.1 概述1.2 应用 2 历史发展3 协议3.1 协议细节（来自CiA文档）3.2 协议框架OSI 模型服务COB-IDNMTSYNC紧急事件对象 (EMCY)服务数据对象 (SDO)SDO 下载SDO 上传SDO 加速写传输报文 过程数据对象PDO 3.3 应用细节（伺服电机）通信（设置与连接）调试运行控制模式CiA 402 电源状态机相关参数运动范围限制工作模式标准定位工作模式速度工作模式标准速度工作模式找零工作模式插补位置模式工作模式周期同步定位工作模式周期同步速度工作模式脉冲方向工作模式 数字输入和输出 3.3 应用细节（IO）3.4 对象目录说明 4 组织4.2 CANopen Solutions4.3 nanotec 纳诺达克 参考 1 介绍 1.1 概述 CANopen是一种架构在控制局域网络（Controller Area Network, CAN）上的高层通信协议，包括通信子协议及设备子协议，常在嵌入式系统中使用，也是工业控制常用到的一种现场总线。
CANopen由非营利组织CiA（CAN in Automation）进行标准的起草及审核工作，基本的 CANopen 设备及通讯子协定定义在 CAN in Automation (CiA) draft standard 301中。针对个别设备的子协定以 CiA 301 为基础再进行扩充。如针对 I/O 模组的 CiA401 及针对运动控制的 CiA402。
1.2 应用 机器控制工厂自动化实验室自动化交通运输多功能车楼宇自动化医疗系统 2 历史发展 1994年:CiA发布了CANopen规范的第一个版本:CiA 301是最成功的Esprit研究项目之一。1997年:CiA发布了用于驱动和运动控制的CiA 402 CANopen设备配置文件。该配置文件规范了伺服驱动器、变频器和步进电机控制器的功能行为。介绍了几种操作模式及相应的配置参数。2001年:CiA 304 (CANopen Safety)规范发布，同时在EN 50325-5中标准化。2003年:CiA 417 (CANopen电梯控制系统应用概要)规范系列发布。它也称为CANopen Lift，为不同的虚拟设备指定通信接口。2009年:CiA组织了第一届CANopen Lift插件大赛。这些事件的目的是检查和提高CANopen设备的互操作性。2017年:CiA 1301 (CANopen FD应用层和通信配置文件)规范公布。CANopen FD利用CAN FD数据链路层提供更高的比特率和更大的有效负载(每帧高达64字节)。此外，CiA还发布了CiA 601 (CAN FD节点和系统设计)系列，包括规范、指南和建议。2019年:为了改善CAN FD网络的使用，CiA开发了SIC(信号改善能力)收发器规范，该规范已记录在CiA 601-4规范中。2020: CiA 510规范指定了sdo和EMCY等CANopen协议到J1939参数组(pg)的映射。结合将特定于概要文件的pdo映射到pg，这使得也可以在J1939应用层上使用CiA概要文件(CiA 4XX系列)。2021年:另一个里程碑是CAN XL的发展，这是第三代CAN数据链路和物理层。揭示了CiA 610-1(数据链路层和物理编码子层要求)和CiA 610-3(物理介质附件子层要求)规范。CAN XL帧格式允许数据字段的长度从1字节到2 048字节。2022年:6月初，中央情报局以为期两天的面对面会议的方式庆祝其30岁生日。该项目包括CiA技术小组(CAN XL和CAN FD Light)的最新CAN发展，从海事电子到牙医椅的应用，以及CiA规范的未来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d99f69da58be6ae0a1b89edc088745f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9a779dead57f51d87a1b83943f615c6/" rel="bookmark">
			Mysql中的find_in_set() 函数用法详解及使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、find_in_set() 函数详解
示例：
select FIND_IN_SET('1', '1,2,3'); // 结果：1 select FIND_IN_SET('3', '1,2,3'); // 结果：3 select FIND_IN_SET('4', '1,2,3'); // 结果：0 // 后一个包含前一个返回大于0的元素所在位置,不包含前一个则返回0 相信大家看完以上示例就知道这个函数的大概作用了，以下是MySQL手册中官方说明
FIND_IN_SET(str,strlist)，该函数的作用是查询字段(strlist)中是否包含(str)的结果， 返回结果为null或记录 。 str 要查询的字符串 strlist 需查询的字段，参数以”,”分隔，例如如 '1,2,3' 假如字符串str在由N个子链组成的字符串列表strlist 中，则返回值的范围在 1 到 N 之间。 一个字符串列表 就是一个由一些被’,‘ 符号分开的子链组成的字符串。如果第一个参数是一个常数字符串，而第二个是type SET列， 则FIND_IN_SET() 函数被优化，使用比特计算。 如果str不在strlist 或strlist 为空字符串，则返回值为 0 。 如任意一个参数为NULL，则返回值为 NULL。 这个函数在第一个参数包含一个逗号( , )时将无法正常运行。 概括一下就是（前一个字符串是A，后一个字符串是B）：
如果B字符串包含A字符串：则返回大于0的值，这个值就是A字符串在B字符串的所在位置；
如果B字符串不包含A字符串：则返回0；
如果B字符串或者A字符串有任意一个是null，则返回null；
如果A字符串包含逗号，则无法执行。
二、应用场景
就拿若依的权限认证的其中一条sql来给大家举例吧：
SELECT dept_id, parent_id, ancestors, order_num, leader, phone FROM sys_dept WHERE dept_id = 101 or FIND_IN_SET(101, ancestors) ; 查询结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9a779dead57f51d87a1b83943f615c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57cc293423dbf34be591c008f54f12e0/" rel="bookmark">
			手机也可以轻松码代码！两款手机端代码最佳神器Pydroid和Pythonista！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pyroid是一款支持Android系统的移动代码编译器。
Python 3可以说是Android上一个易于使用且功能强大的Python 3 IDE，它可以帮助您在Android上使用Python、Jupyter笔记本等。
安装
我们可以从应用程序商店下载并安装。安装完成后，需要在第一次打开Python库时安装它。稍后，您可以根据需要为pip选择各种库。
安装后，我们可以正常使用。Pyroid 3可以编辑、预测代码、突出显示语法等。接下来，我们将介绍该应用程序的实用功能之一。
#代码补全和错误提示
手机代码的屏幕很小，输入方式不如电脑键盘完整。如果你一个一个地写代码，你会有很多工作，你的手指会不舒服。
代码中的大多数重复单词都是编程语言附带的变量和函数。代码完成可以一键输入这些变量函数。
上图是编辑页面。很明显，下面有三列：
1.错误提示，包括错误和警告提示。
2.直接打印当您输入以“p”开头的函数/单词时，pass、pow、print和property将显示在下面。此时，只需单击所需的功能，代码就会自动完成。
3.特殊符号列在Python中经常使用。你可以根据自己的习惯调整顺序。
除了上述主要功能外，还有语法高亮显示和主题、脱机运行Internet程序、示例学习和其他功能
Python
#Pythonista
Python ista是一个旧的Python IDE，在iOS系统中具有很高的评价。Python ista 3支持在iPhone和iPad上运行Python 2和3，并且可以随时随地编写代码。
图片
安装
iOS系统就只能从自带的App Store里下载，下载完成之后，里面会有自带的很多Python标准库。
除了Python 3的代码完成功能，Python 3还有一个非常有趣的功能，这是一个内置的示例。你可以看到其他人如何编写代码，也可以自己练习。
#内置强大的有趣示例
Python ista有一些内置脚本库。新手可以友好地参考其中的源代码。
例如，上面的时钟只有几十行源代码。理解那些具有基本编程技能的人并不难，他们可以学习其他人的写作方法。还有笑笑乐、俄罗斯方块等小游戏~
Python ista还可以编写脚本、照片库、iOS剪贴板等以访问运动传感器数据，还可以用于构建交互式多点触摸体验、动画等
不过，如果还有你不明白的地方，网上也有很多相关信息，你也可以去官方论坛讨论和提问。
----------------------------------------THE END-------------------------------
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/880bfe38e32638019e17522db74475c0/" rel="bookmark">
			进阶体验：5个方面解锁Eolink高级玩法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eolink专为开发者设计的免费 API 协作平台 前言 大家好我是路飞，上一篇文章 Eolink — 一站式API协作平台 向大家介绍了关于 Eolink 的产品特性、定位，以及作为API管理工具的一些基础用法（API文档生成、MOCK服务、API配置等）。那么本篇文章，就来带大家体验下 Eolink 的API文档数据导入导出、IDEA插件一键生成API文档、API并行测试等扩展功能的玩儿法。
Eolink：https://www.eolink.com/
在介绍Eolink扩展功能之前，我们通过一张图简单对比下Eolink和国外API主流测试工具Postman的差异：
相比于Postman，Eolink支持的功能更丰富，而且在UI交互、引导提示、功能扩展、数据迁移方面，Eolink要比 Postman做的更好。
作为国产API管理工具，Eolink本身就支持中文界面，不需要像Postman一样单独安装语言包插件，另外 Eolink 支持飞书、企业微信、钉钉等国内办公软件配套使用。
目前产品免费，可使用web版同时也可下载桌面端，Windows、Linux 、Mac平台均支持使用！
体验地址：Eolink专为开发者设计的免费 API 协作平台
下面我们从5个方面体验下Eolink的强大功能：
玩法一：Eolink IDEA插件全代码注释自动生成API测试用例 1、插件安装 打开IDEA插件商店搜索：
Generate EolinkerDocEolink ApiKit 2、插件配置 打开IDEA setting，搜索Eolink：
这里需要配置4个参数：
Server：服务器地址（自己的Eolink控制台域名）。SpaceKey：空间Key。ProjectHashKey：项目hashKey，唯一标识一个独立的项目空间。Token：登录用户身份标识，就是我们首次注册时分配的注册账号。 那么，这4个参数从哪里获取呢？
首先访问Eolink官网：https://www.eolink.com/，从官网入口进入Eolink产品控制台~
Token 登录用户身份标识获取：
将上面步骤中获取的参数，添加到Eolink IDEA插件配置中，即可完成Eolink API工作台和IDEA的绑定。
3、API 文档一键生成 完成1、2两步骤配置后，就可以通过Eolink IDEA插件一键生成API测试用例，并同步到Eolink控制台个人空间。
为了演示方便，拿一个之前项目中的Controller接口测试效果，源代码如下：
/** * @描述 文章分类相关操作的Controller接口 * @作者 天天发呆的程序员 * @创建时间 2022-06-04 */ @RestController @RequestMapping("/category") @CrossOrigin public class CategoryInfoController { @Autowired private CategoryInfoService categoryInfoService; /** * 获取文章分类列表 * * @return */ @GetMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/880bfe38e32638019e17522db74475c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/404fec038fbcacc74e45acf439de6a1d/" rel="bookmark">
			linux提升Python和pip版本及版本切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.相关配置 Ubuntu版本：18.04Python版本：2.7及3.6 1.提升Python版本 先下载新版本python
#安装通用软件依赖 sudo apt install software-properties-common #添加Ubuntu的python版本所在库 sudo add-apt-repository ppa:deadsnakes/ppa 根据输出提示安装环境依赖：
按照上图输出提示安装依赖，其中python#.#替换为你要下载的python版本，例如此处我要下载python3.9，则全部替换为如下命令：
sudo apt-get install python3.9-dev python3.9-venv python3.9-distutils python3.9-lib2to3 python3.9-gdbm python3.9-tk #安装python3.9 sudo apt-get install python3.9 修改系统默认python版本，可实现版本间切换
看一下系统如今有的python版本：
whereis python 可以看到很多目录下的python，对/usr/bin/目录下的python分配优先级：
sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1 sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.6 2 sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.9 3 后面跟的数字越大优先级越高，最高级别的就是系统默认的python版本，可以通过python--version测试一下。
如果需要版本间切换，只需要输入命令：
sudo update-alternatives --config python 如下图所示：
3.pip版本提升 如果你不曾安装过pip，直接通过新的python安装pip就可以得到和新版本python匹配的pip。如果想要升级当前版本pip使其能够和新版本python匹配：#安装curl sudo apt-get install curl #下载最新pip curl https://bootstrap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/404fec038fbcacc74e45acf439de6a1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/471c3b4a54d812ca90422faec5b9fcf5/" rel="bookmark">
			js练习：换肤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 功能实现：点击该图片让背景变成该图片 思路：设置默认第一张为背景，获取元素，利用for循环给所有的li绑定一个点击事件，然后修改样式（改背景图片），实现点击随意图片切换背景 效果展示
HTML
css
js
&lt;style&gt; *{ padding: 0; margin: 0; } body{ background-image: url('img/img01.jpg'); /* background-size: 100%; */ } li { list-style: none; } .baidu{ margin: 100px auto; width: 410px; overflow: hidden; padding-top: 3px; background-color: #fff; } .baidu li{ float: left; margin: 0 1px; cursor: pointer; } .baidu img{ width:100px; } &lt;/style&gt; &lt;body&gt; &lt;ul class="baidu"&gt; &lt;li&gt;&lt;img src="img/img01.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/img02.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/img03.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/img04.jpg"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;script&gt; var imgs = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/471c3b4a54d812ca90422faec5b9fcf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/693ef973fa70ea1dac89cd4bfce9215a/" rel="bookmark">
			Android和iOS设备截图优化的一点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常规的截图方式 在日常需要截图的工作中，常规的处理方式是手机自带的截图功能，完成后再通过工具发送到PC设备，整个过程分为两步，比较的麻烦
另一种方式是直接在PC端使用adb 命令或者tidevice工具对目标设备进行截图，然后手动去拉取
Android：
截图：
adb shell screencap -p /sdcard/screen.png
拉取：
adb pull /sdcard/screen.png ~/desktop/screen.png iOS：
依赖tidevice工具：
tidevice screenshot ~/Desktop/screen.png 对于日常截图的需求也是足够的，比较的方便
组合截图方式 我们可以将以上的两个步骤组合起来，实现比较的方便的截图和查看图片一步到位
Android：adb shell screencap -p /sdcard/screen.png &amp;&amp; adb pull /sdcard/screen.png ~/desktop/screen.png &amp;&amp; open ~/desktop/screen.png
iOS :
tidevice screenshot ~/Desktop/screen.png &amp;&amp; open ~/Desktop/screen.png
组合起来之后，再分别为两个组合命令加个别名到zsh, 用起来也是非常的方便，但对于某些时候，我们需要进行比较多的截图工作的时候，这种方式并不很好用，因为每次截图保存的图片名称都是一样的，会导致下一次截图覆盖上一次截图，导致不能同时保存多张截图，除非手动修改
脚本实现随机名称命名截图 于是我们可以写个shell 脚本，对文件名进行随机命名优化
1.新建一个shell 脚本，获取当前的时间作为图片的名称，它是绝对随机的，不会出现重复的情况
2.在拉取到PC端时再为其命名，不用管它之前是什么名称
Android：
#!/bin/sh file_name=$(date +%s) adb shell screencap -p /sdcard/screen.png &amp;&amp; adb pull /sdcard/screen.png ~/Desktop/$file_name.png &amp;&amp; open ~/Desktop/$file_name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/693ef973fa70ea1dac89cd4bfce9215a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2e8b549a3e157e5269e7942de03868d/" rel="bookmark">
			java取奇偶数的基本练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class JiOu {
public static void main(String[] args)
{
int a = 11;
System.out.println("这个数是" + (a % 2 == 0?"偶数":"奇数"));
int b = 11;
if (b % 2 ==0)
{
System.out.println("这个数为偶数");
}
else
{
System.out.println("这个数是奇数");
}
int c = 12;
switch (c % 12)
{
case 0 :
System.out.println("这个数是偶数");
break;
default:
System.out.println("这个数是奇数");
break;
}
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8cc8a283a4df6e0f7bb4e0202b17d29/" rel="bookmark">
			我的世界(MC) forge 1.19.3 开服教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Debian系统使用MCSManager9面板搭建Minecraft Java版MOD服务器的教程，本教程用的forge1.19.3服务端，用其他服务端的也可以参考一下。
其他版本我的世界服务器搭建教程：https://blog.zeruns.tech/tag/mc/各种Minecraft服务端介绍和下载：https://blog.zeruns.tech/archives/626.html高性价比和便宜的VPS/云服务器推荐: https://blog.zeruns.tech/archives/383.html我的世界(Minecraft)服务器添加MOD和插件的教程：https://blog.zeruns.tech/archives/696.html MCSM9介绍 分布式，稳定可靠，开箱即用，高扩展性，支持 Minecraft 和其他少数游戏的控制面板。
MCSManager 面板（简称：MCSM 面板）是一款全中文，轻量级，开箱即用，多实例和支持 Docker 的 Minecraft 服务端管理面板。
此软件在 Minecraft 和其他游戏社区内中已有一定的流行程度，它可以帮助你集中管理多个物理服务器，动态在任何主机上创建游戏服务端，并且提供安全可靠的多用户权限系统，可以很轻松的帮助你管理多个服务器。
准备 首先你得有台服务器（已经有的可以忽略），下面推荐一些：
华为云：https://url.zeruns.tech/HWY天翼云：https://www.ctyun.cn/agent/#/invitation/10366809腾讯云每日秒杀：https://url.cn/0ReBKx8A指点云12900K：https://www.awsl9527.cn/archives/1331.html雨云5900X：https://blog.zeruns.tech/archives/686.html 其他性价比高的服务器推荐：https://blog.zeruns.tech/archives/383.html
各大云服务厂商 轻量应用服务器 性能评测对比，阿里云、腾讯云、华为云、Ucloud：https://blog.zeruns.tech/archives/675.html
如果你是新用户有优惠，建议能买多长时间就买多长时间，因为优惠价的服务器到期后续费很贵的，而且新用户优惠只能买一次，所以尽量买长时间点划算。
1.19版本内存占用和性能要求很高，最低4G内存起！！！ 不要买低于4G的，之前总有人买个2G的服务器开1.19报错内存溢出，然后过来问我为什么开不了…
2核4G内存 5兆带宽的服务器大约可以同时在线1到5人，4核8G 10兆的服务器大约可以同时在线5到20人，仅供参考，MOD多的需要更高配置。
不要买1兆带宽的！！！ 1兆带宽最多一两个人玩，建议5兆起！！！
还有就是Java版我的世界服务器对单核性能要求较高，特别是高版本和MOD服，建议选择5900X和12900K之类的高主频的服务器。
购买服务器后选择安装 Debian10或11 系统，然后用ssh登录服务器。ssh客户端软件推荐putty或mobaxterm。
默认账号一般是：root 密码是你自己在购买时设置的，有些可能购买时没有设置密码的可以购买后在控制台重置密码。
连接服务器 下载安装并打开ssh客户端软件，ssh客户端软件推荐putty或mobaxterm。
在SSH客户端中输入服务器IP地址，然后点击打开。
如果弹出下图的警告就点是
然后输入账号并按回车，账号一般默认为root，接着输入密码并按回车确定，输入密码时不会显示出来。
温馨提示：在SSH终端中按住鼠标左键选择文字，然后松开鼠标，再在空白处单击一下，这样就把选中的文字复制了；在SSH终端单击右键即为粘贴。
端口开放 面板需要 23333 和 24444 端口。
Minecraft游戏服务器默认端口是 25565。
如果你使用阿里云，腾讯云或者其他云服务商，请进入控制台到防火墙安全组策略，放行以上端口。
或者放行全部端口，入和出方向都要。
关闭系统自带防火墙：
# 关闭防火墙，依次执行 systemctl stop firewalld systemctl disable firewalld service iptables stop 安装JAVA环境 1.19.3版需要JDK17版，需要安装其他版本JDK的看这篇文章：https://blog.zeruns.tech/archives/653.html
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8cc8a283a4df6e0f7bb4e0202b17d29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28d0b73509cb550364fd2e722b2e1828/" rel="bookmark">
			MyBatis如何实现一对多查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis实现一对多查询 新建Department和Employee表 sql语句 SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for department -- ---------------------------- DROP TABLE IF EXISTS `department`; CREATE TABLE `department` ( `d_id` int(11) NOT NULL AUTO_INCREMENT, `d_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL, PRIMARY KEY (`d_id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact; -- ---------------------------- -- Records of department -- ---------------------------- INSERT INTO `department` VALUES (1, '财务部'); INSERT INTO `department` VALUES (2, '王五'); -- ---------------------------- -- Table structure for employee -- ---------------------------- DROP TABLE IF EXISTS `employee`; CREATE TABLE `employee` ( `e_id` int(11) NOT NULL AUTO_INCREMENT, `e_name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL, `e_gender` varchar(6) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL, `e_age` int(11) DEFAULT NULL, `e_depart_id` int(11) DEFAULT NULL, PRIMARY KEY (`e_id`) USING BTREE, INDEX `e_depart_id`(`e_depart_id`) USING BTREE, CONSTRAINT `employee_ibfk_1` FOREIGN KEY (`e_depart_id`) REFERENCES `department` (`d_id`) ON DELETE RESTRICT ON UPDATE RESTRICT ) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact; -- ---------------------------- -- Records of employee -- ---------------------------- INSERT INTO `employee` VALUES (1, '李四', '男', 20, 1); INSERT INTO `employee` VALUES (2, '王五', '男', 19, 1); INSERT INTO `employee` VALUES (3, '李三', '男', 18, 2); INSERT INTO `employee` VALUES (4, '李丽', '女', 22, 2); INSERT INTO `employee` VALUES (5, NULL, NULL, NULL, NULL); SET FOREIGN_KEY_CHECKS = 1; pom依赖 &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28d0b73509cb550364fd2e722b2e1828/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6db7959f67c1f6274f2e572676aad71/" rel="bookmark">
			Nginx 同时运行多个服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 版本：nginx-1.16.1
nginx官网 : http://nginx.org/
远程工具：finalshell
编辑nginx.conf 配置文件，复制一个新的 server 保证端口不冲突
server 1:
server 2:
重启nginx
cd /usr/local/nginx/sbin./nginx -s reload 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7b2332296d3b57855ba63133f459b21/" rel="bookmark">
			MyBatis如何实现多对多查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis如何实现多对多查询 多个学生有多个老师代课教师 创建：student(学生表)，teacher(老师表)，以及中间表 CREATE TABLE student( sid INT NOT NULL AUTO_INCREMENT, sname VARCHAR(30), PRIMARY KEY(sid) ); CREATE TABLE teacher( tid INT NOT NULL AUTO_INCREMENT, tname VARCHAR(30), PRIMARY KEY(tid) ); CREATE TABLE student_teacher( s_id INT NOT NULL, t_id INT NOT NULL, PRIMARY KEY(s_id,t_id), FOREIGN KEY(s_id) REFERENCES student(sid), FOREIGN KEY(t_id) REFERENCES teacher(tid) ); INSERT INTO student(sname) VALUES('张三'),('李四'); INSERT INTO teacher (tname) VALUES('刘老师'),('李老师'); INSERT INTO student_teacher(s_id,t_id) VALUES(1,1),(1,2),(2,1) pom &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7b2332296d3b57855ba63133f459b21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c97d72113ee2f05b36e6a0cf262c3a7a/" rel="bookmark">
			【顺序程序】甲流疫情死亡率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天，我们来了解一下顺序程序中的甲流疫情死亡率的做法。
正文 题目描述：甲流并不可怕，在中国，它的死亡率并不是很高。请根据截止2009年12月22日各省报告的甲流确诊数和死亡数，计算甲流在各省的死亡率。 输入：输入仅一行，有两个整数，第一个为确诊数，第二个为死亡数。
输出：输出仅一行，甲流死亡率，以百分数形式输出，精确到小数点后3位。（敲黑板！）
样例输入：10433 60
样例输出：0.575%
题目看上去非常简单，似乎只是让我们求B÷A的值，但是一定要注意：以百分数形式输出，精确到小数点后3位。然后我们就可以写代码了。
来自Minecraft__Him大佬的代码：
#include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;(double)b/a*100&lt;&lt;"%"&lt;&lt;endl; return 0; } 本蒟蒻的代码：
#include&lt;iostream&gt; #include&lt;iomanip&gt; using namespace std; int main() { double a,b,num; cin&gt;&gt;a&gt;&gt;b; num=100*b/a; cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(3); cout&lt;&lt;num&lt;&lt;"%"&lt;&lt;endl;//在得到的数字后加% return 0; } 好了，我们下期再见👋
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2daeb2a20342aeeee3c5bc275b0859eb/" rel="bookmark">
			SpringBoot文件上传同时，接收复杂参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
环境信息
问题描述
错误分析
解决方法
简单参数
总结
环境信息 Spring Boot：2.0.8.RELEASE
Spring Boot内置的tomcat：tomcat-embed-core 8.5.37
问题描述 收到文件上传的开发工作，要求能适配各种场景，并且各场景的请求参数不一样，因此接收的参数不能是固定的几个字段，要有类似Map的字段来接收动态参数。
拟使用MultipartFile[] files来接收文件列表，用自定义对象UploadFileDto来接收上传参数（里面包含一个Map）
UploadFileDto.java
@ApiModel("文件上传dto") @Data public class UploadFileDto { @ApiModelProperty("处理器，在Spring容器里的名称") private String handlerName; @ApiModelProperty("交易代码") private String bizCode; @ApiModelProperty("交易ID") private String bizId; @ApiModelProperty("上传配置名称，对应配置文件里的配置") private String uploadConfigName; @ApiModelProperty("动态信息") private Map&lt;String, Object&gt; dynamicDto; @ApiModelProperty("上传时间") private String uploadDt; @ApiModelProperty("限定文件大小") private long defaultFileSize; @ApiModelProperty("限定文件格式，多个用逗号隔开") private String defaultFileSuffix; @ApiModelProperty("默认路径之后的文件上级目录") private String parentDir; @ApiModelProperty("备注信息") private String remark; @ApiModelProperty("上传后的文件信息") private List&lt;FileInfoDto&gt; fileInfoDtos; } Controller:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2daeb2a20342aeeee3c5bc275b0859eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca81c10085797dfba29059d2fa41456/" rel="bookmark">
			Python-OpenCV实现图片和视频相互转换的简单&#43;实用方法（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近两天刚好需要操作图片转视频，视频转图片小操作，在网上搜了一些博文发现会存在一些小bug。因此，在这里记录一下直接调好就可以使用的代码。
首先是图片转视频（使用对象：尺寸大小都一样的图片）
import os import cv2 import numpy as np path = './Output/' # 路径设置（ps:路径不要出现中文！） filelist = os.listdir(path) filelist = sorted(filelist) # 按照文件数字进行顺序排序 fps = 24 # 视频每秒24帧 size = (512, 512) # 需要转为视频的图片的尺寸 video = cv2.VideoWriter("VideoTest.avi", cv2.VideoWriter_fourcc(*'DIVX'), fps, size) # 视频保存在当前目录下 for item in filelist: if item.endswith('.png'): # 找到路径中所有后缀名为.png的文件，可以更换为.jpg或其它 item = path + item img = cv2.imread(item) video.write(img) video.release() cv2.destroyAllWindows() 然后，还是图片转视频，使用对象改变（使用对象：图片尺寸大小不同）
import cv2 import glob def resize(img_array, align_mode): _height = len(img_array[0]) _width = len(img_array[0][0]) for i in range(1, len(img_array)): img = img_array[i] height = len(img) width = len(img[0]) if align_mode == 'smallest': if height &lt; _height: _height = height if width &lt; _width: _width = width else: if height &gt; _height: _height = height if width &gt; _width: _width = width for i in range(0, len(img_array)): img1 = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ca81c10085797dfba29059d2fa41456/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a39884b681b71f4b31194552b3bb2bb4/" rel="bookmark">
			从 0 开始最详细的微信公众号接入 AI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从 0 开始最详细的微信公众号接入 AI 文章目录 从 0 开始最详细的微信公众号接入 AI写在前面注册公众号克隆到服务器使用过微信机器人项目未使用过微信机器人项目 更改配置文件启动项目更换机器人接口写在最后 大家也可以浏览我其他的博客：
从 0 开始最详细的 ChatGPT 注册教程从 0 开始最详细的部署自己的 ChatGPT 微信机器人 注意⚠️：因为微信公众号接口有回复时间限制🚫，所以作者试了一下使用 openai 的接口，发现如果问一些复杂的问题肯定会超过限制，然后就会在微信窗口提示：
该公众号提供的服务出现故障，请稍后再试 所以作者找了一下国内的 AI 接口，详细可以看这里，当然肯定还要很多，然后找了一个免费的接口：青云客智能聊天机器人，大家可以尝试其他的。
写在前面 想要部署到微信公众号非常简单，只要以下四步，所以大家要看到最后啊：
注册一个公众号克隆这个项目到自己的服务器填写 config.js 文件启动项目 如果是新的服务器，那么需要安装 node，npm，pm2，具体命令如下：
安装node 和 npm ： curl -sL https://deb.nodesource.com/setup_19.x | sudo -E bash - sudo apt-get install -y nodejs # 安装后 node -v npm -v 安装 pm2： npm i pm2 -g 注册公众号 详细步骤可以参考注册微信公众号，大家应该能自己完成的 克隆到服务器 使用过微信机器人项目 如果你之前克隆过作者那个微信机器人的项目，那么可以按照如下操作克隆这个项目，作者已经将项目同步至 Gitee 了，这样服务器就能快速下载：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a39884b681b71f4b31194552b3bb2bb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a8c0f3e918cf8240da1f9ec7d94d94/" rel="bookmark">
			centos7 增加swap分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先用free -m查看一下swap的大小
1.添加swap分区 使用dd命令创建/home/swap这么一个分区文件。文件的大小是2048000 个block，一般情况下1个block为1K，所以这里空间是2G。
dd if=/dev/zero of=/var/swapfile bs=1024 count=2048000 //添加交换文件并设置其大小为2G
2.执行完毕，对交换文件格式化并转换为swap分区： mkswap /var/swapfile
3.挂载并激活分区： swapon /var/swapfile
4 赋权限 chmod -R 0600 /var/swapfile
现在再用free -m命令查看一下内存和swap分区大小，就发现增加了2G的空间了。
注意当计算机重启了以后，发现swap还是原来那么大，新的swap没有自动启动，还要手动启动。那我们需要修改/etc/fstab文件
5.设置开机自动挂载该分区： vi /etc/fstab 在fstab文件末尾追加如下内容后:wq!保存即可： /var/swapfile swap swap defaults 0 0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1e49543ab72f4c6e1a3a5ae717d88a9/" rel="bookmark">
			SpringBoot请求参数传递与接收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、GET请求和POST请求的区别是什么 GET和POST请求的区别主要有下面几点
GET没有请求体，POST有请求体GET传输比POST快GET只能携带少量数据（因为其请求url有长度限制），POST可以携带的数据量较大POST因为将数据放在请求体中，GET将数据拼接到url中，所以POST比GET要安全 二、不同类型参数传递方法 GET请求没有请求体，所以在发送GET请求时，都是进行请求URL的拼接。而POST请求携带有请求体，所以在请求时，不仅仅可以拼接URL，还可以在请求体中放入数据。
1、单个基本数据类型参数传递
单个基本类型数据传递时，后端往往只需要在接收方法中定义相应数据类型的数据，就可以直接接收。
1）GET请求
（1）无注解
@GetMapping(path = "/em") public Result demo1(String person) { System.out.println(person); return Result.success("OK!"); } （2）@RequestParam
获取查询参数。即url?name=这种形式
@GetMapping("/de/{name}") public Result demo1( @RequestParam(name = "name") String name) { System.out.println("name="+name); return Result.success("OK!"); } （3）@PathVariable
获取路径参数。即url/{id}这种形式。
@GetMapping("/ded/{id}") public Result demo(@PathVariable(name = "id") String id) { System.out.println("id="+id); return Result.success("OK!"); } 2）POST请求
@PostMapping(path = "/emo") public Result demo2(String person) { System.out.println(person); return Result.success("OK!"); } 2、多个参数传递
1）多个变量接收
（1）get
@GetMapping("/de") public Result demo11(String id, String name) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1e49543ab72f4c6e1a3a5ae717d88a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4273b590ef8f897ca733c4c6fd190199/" rel="bookmark">
			python 编程 函数的返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介：一名在校计算机学生、每天分享Python的学习经验、和学习笔记。 座右铭：低头赶路，敬事如仪
个人主页：网络豆的主页​​​​​​
目录
前言
一.函数
1.函数的返回值介绍
2.函数的返回值定义
例子：
3.函数多个返回值
前言 本章将会讲解Python编程的返回值，以及它的值定义。
一.函数 1.函数的返回值介绍 当两个函数之间，想要互相使用到内部变量时，就可以应用到函数的返回值。 例如：两所房子408,409,如果408借给409电脑，这个过程，是先把电脑拿出来，放到408门口，再到409门口，409再出来把电脑拿进去才可以使用。
2.函数的返回值定义 使用 return 关键字返回内容 将内容 返回到 函数调用处 函数体中没有 return 语句时，函数运行结束, 则默认返回 None，也被称为隐含返回值 例子： 摄氏度与华氏度关系如：摄氏度/1.8 + 32 = 华氏度 需求： 定义函数1：用于输出摄氏度 定义函数2：通过摄氏度计算得出华氏度 #定义摄氏度函数 def c_temp(): c_t = 14 print(f"今天的摄氏度：{c_t}") #今天的摄氏度：14 # 如果不做任何返回，默认返回值为None #将c_t返回到该函数的调用处 return c_t #定义华氏度函数 def f_temp(c_t): f_t = round( c_t/1.8 + 32,3) print(f"今天的华氏度：{f_t}") #今天的华氏度：39.778 if __name__ == '__main__': #注意1：函数在定义完之后，统一在最后去调用 c_t_two = c_temp() f_temp(c_t_two) #实参 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4273b590ef8f897ca733c4c6fd190199/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39293401082507e755fd42dd6f481863/" rel="bookmark">
			ArcGIS And ENVI：如何进行植被指数的提取并制作成专题地图？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
01 目的
02 操作步骤
2.1 在ENVI加载tm_860516.img文件
2.2 进行NDVI指数的计算
2.3 使用ArcGIS对NDVI植被指数提取图进行专题制作
2.3.1 加载NDVI植被指数提取图
2.3.2 对NDVI植被指数提取图进行重分类
2.3.3 布局视图下的NDVI植被指数的相关编辑
03 实验结果
01 目的 对遥感影像进行植被指数的提取，并对植被指数提取图制作成标准的，好看的专题地图。
02 操作步骤 2.1 在ENVI加载tm_860516.img文件 2.2 进行NDVI指数的计算 2.3 使用ArcGIS对NDVI植被指数提取图进行专题制作 2.3.1 加载NDVI植被指数提取图 2.3.2 对NDVI植被指数提取图进行重分类 2.3.3 布局视图下的NDVI植被指数的相关编辑 包括插入图例，标题，比例尺，指北针等等
03 实验结果 制作好的NDVI专题地图展示：
结果分析 这次的结果比较满意吧，主要就是先对遥感影像进行NDVI植被指数的提取（使用ENVI），接着将得到的NDVI植被指数提取图进行重分类（使用ArcGIS），接着在布局视图进行精美的修饰（包括但是不限于插入标题，图例，比例尺，指北针），然后就是没了。
如果有问题，欢迎一起探讨.
&lt;p&gt;炒茄子&lt;/p&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29add4810ad4b55ea30db626f608fe40/" rel="bookmark">
			ZERO-SHOT：多聚焦融合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZERO-SHOT MULTI-FOCUS IMAGE FUSION （零镜头多焦点图像融合）
多聚焦图像融合 (Multi-focus image fusion (MFIF)) 是消除成像过程中产生的离焦模糊的有效方法。The difﬁculties in focus level estimation and the lack of real training set for supervised learning make MFIF remai a challenging task after decades of research.
我们提出了一种名为IM-Net的新颖体系结构，该体系结构由I-Net组成，用于对融合图像的深度先验进行建模，而M-Net则用于对焦点图的深度先验进行建模。在没有任何大规模训练集的情况下，我们的方法通过提取的先验信息实现了零射击学习。
介绍 在成像系统中，由于深度场 (depth-of-ﬁeld (DOF)) 的限制，相机焦平面外的物体会变得模糊，从而难以获得全聚焦图像，并导致图像质量大大降低。近年来，已经提出了各种多焦点图像融合 (MFIF) 算法来解决此问题。它们可以将源图像对的聚焦区域 (具有不同焦距) 在同一场景中进行组合，从而获得全聚焦高质量和信息性的聚焦图像，具有广泛的应用。
通常，MFIF方法可以分为三类: 基于变换域的方法，基于空间域的方法和基于深度学习的方法。
基于变换域的方法使用手工制作的图像分解算法将原始图像转换为变换域，以便能够更好地编码以区分清晰的几何特征，然后融合变换后的图像，最后进行逆变换以获得融合的图像。1985年，Burt等人 提出了第一个基于拉普拉斯金字塔的多尺度分解MFIF方法。之后出现了一系列基于多尺度分解的融合方法，包括基于小波变换、基于DCT等。
这些基于变换域的方法已被广泛使用，因为它们可以避免直接操纵像素引起的伪像（artifacts），但是由于对高频分量的敏感性，它们容易导致失真。通过估计二进制焦点图，然后基于获得的焦点图执行源图像对的加权和，基于空间域的方法开始引起注意。
但是这些传统的基于先验的方法以活动度量和融合规则的设计为主要任务，并提出了许多手工制作的活动度量来估计基于低级特征的清晰度，例如边缘信息或梯度信息的减少，以及像素强度或对比度的降低。
同时缺点也是：这些手工制作的功能无法准确表征图像是否聚焦。为了减轻手工先验 (手工图像分解方法或手工特征) 的依赖性，已经提出了许多基于深度学习的方法，通过这些方法可以共同优化活动度量和融合规则，以获得更好的效果。
基于深度学习的MFIF方法可以进一步分为基于监督学习的方法和基于无监督学习的方法。Liu等人提出了第一个有监督的暹罗结构（Siamese structured ）CNN网络，用于MFIF在补丁级别执行分类。Guo等人提出使用全卷积网络来获得从源图像对到焦点图的端到端映射。Xiao等人设计了一个精致的监督模型，以充分利用低级和高级信息。
这些使用具有手工参数的合成数据集的基于监督学习的模型可能与真正的成像过程不一致，后者需要考虑点扩散函数 (PSF) 以及物体和镜头之间的距离。--------&gt;所以，无监督学习成为一种直接解决方案。具体来说，Prabhakar等人采用了预先训练的自动编码器来提取特征，并将原始图像映射到高维特征空间中。由于发现提取的深层特征具有良好的泛化，鲁棒性和开发潜力，因此基于这项工作进行了一些改进 。最近，一种称为MFF-GAN的无监督融合方法在联合梯度约束下进行了对抗博弈。此外Ma等人训练了一个strongly self-supervised mask generator 以直接生成binary mask，而无需任何后处理 。尽管这些基于深度学习的方法已经达到了最先进的 (SOTA) 性能，但它们中的大多数都以有监督的 (具有地面真相) 或经过训练的 (具有用于训练的大图像集) 方式工作。为了解决这种具有挑战性且较少触及的问题，人们高度期望开发一种新颖的深度神经网络，该网络可以同时以无监督和未经训练的方式工作，同时实现有希望的性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29add4810ad4b55ea30db626f608fe40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84155c41d0043875d33a2941fa4c7ea/" rel="bookmark">
			国产实时操作系统&#43;intel x86/龙芯平台超边缘计算机方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言
近年来，物联网、云计算、机器学习和网络安全等技术不断推动工业 4.0 的发展，“云边端” 的架构正逐步替代 “云管端”，边缘计算成为新时代许多领域转型的关键要素。以智能制造为例，不同于为互联网服务的 CDN 边缘计算技术，工业现场也需要性能更强、更智能的超边缘计算机，直接服务于数据源头：它能够在封闭的局域网环境中直接为 OT 设备提供智能计算服务，通过不同规格的配置和多种可扩展的硬件接口，充分满足各种工业计算场景中的算力和数据存储等需求；通过本地高速以太网或 5G 专网满足工业环境低时延和高带宽、高可靠性的网络通信需求；通过运行在超边缘计算机上的工业应用和 AI 算法模型，在本地网络环境内完成绝大多数的业务计算，大幅提升业务响应速度、降低互联网流量和带宽需求、减小数据泄露风险，从而提高企业的生产效率，同时降低总体生产运营成本。因此，翼辉信息 SuperSpirit 1 应运而生，通过强劲的性能和领先的智能边缘计算操作系统，推动企业快速数字化转型和智能制造广泛落地。
柔性工业 4.0
智能制造不仅需要高性能的计算硬件，更需要完整的软件解决方案。由信息管理层、超边缘计算层、工业控制层，上中下三层构成：信息管理层覆盖企业 IT 网络和公共互联网，企业管理员即使出差在外，也可以通过爱智云的加密连接访问企业内部的信息管理平台；在企业内部 IT 网络中，生产管理员可以通过超边缘计算机集群上的管理平台或者工业应用，查看生产状态甚至调整产线配方和生产节拍；工业控制层的自动控制器将协调产线设备并采集实时产线数据，并通过超边缘计算机上的工业应用动态下发生产配方和执行策略。
工业超边缘计算机作为超边缘计算的硬件载体，在整个方案中起到了承上启下的作用。向上，超边缘计算机可以对接运行于同样硬件平台的基于 EdgerOS 的柔性管理平台，或者功能更为强大丰富的企业管理平台。向下，运行于超边缘计算机上的 EdgerOS 工业应用通过系统服务和 API 轻松对接翼辉工业控制器 IGC1500，并由 IGC1500 完成工业 OT 侧设备的控制和数据集成。通过 MQTT、CoAP、SDDC、RTSP、ONVIF 等开放协议和 REST API，EdgerOS 应用也可以直接与工业设备通讯或者集成第三方的 IT 系统如 ERP 等。
用户针对自身业务研发的 EdgerOS 工业应用和 AI 模型，通过柔性或企业管理平台，即可在企业内实现应用的分发和部署。超边缘计算机支持 Type 1 虚拟化，可以同时运行 EdgerOS 和伴生 Linux 算力加速系统。超边缘计算层的设备接收来自管理平台的控制和基于 Web 技术的应用分发请求，同时伴生 Linux 系统也支持容器化的 AI 模型部署分发。借助 Linux 通用 AI 引擎的模型研发优势，EdgerOS 应用能够快速构建基于深度学习的机器视觉能力，实现基于超边缘计算和人工智能的柔性制造。
SuperSpirit 1 概述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f84155c41d0043875d33a2941fa4c7ea/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/180/">«</a>
	<span class="pagination__item pagination__item--current">181/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/182/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>