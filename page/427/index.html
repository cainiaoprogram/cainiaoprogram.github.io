<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab626361a1bae69b3bc3f2b7fb2ef625/" rel="bookmark">
			常见的状态码：HTTP Status Code
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP状态码(HTTP Status Code) 是当我们访问网页服务器，服务器做出相应的状态的3位数的数字代码。主要包括“1xx”（消息）、“2xx”（成功）、“3xx”（重定向）、“4xx”（请求错误）和“5xx”或“6xx”（服务器错误）五种不同类型。
比较常见的状态码有： HTTP: Status 200 – 服务器成功返回网页
HTTP: Status 404 – 请求的网页不存在
HTTP: Status 503 – 服务不可用
一、“1xx”（消息）(临时响应)： 属于临时相应，代表所发出的请求已经被接受，需要继续进行处理。只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。
1、“100 Continue”（继续）：
–&gt;表示临时响应并需要请求者继续执行操作的状态代码。
2、“101 Switching Protocols”(切换协议)：
–&gt;请求者已要求服务器切换协议，服务器已确认并准备切换。
3、“102 Processing”：
–&gt;由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。
二、“2xx”（成功）： 表示成功处理了请求的状态代码。
1、“200 OK”(成功)：
–&gt; 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
2、“201 Created”(已创建)：
–&gt;请求成功并且服务器创建了新的资源。
3、“202 Accepted”(已接受)：
–&gt;服务器已接受请求，但尚未处理。
4、“203 Non-Authoritative Information”(非授权信息):
–&gt;服务器已成功处理了请求，但返回的信息可能来自另一来源。
5、“204 No Content”(无内容)：
–&gt;服务器成功处理了请求，但没有返回任何内容。
6、“205 Reset Content”(重置内容)：
–&gt; 服务器成功处理了请求，但没有返回任何内容。
7、“206 Partial Content”(部分内容)：
–&gt;服务器成功处理了部分 GET 请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab626361a1bae69b3bc3f2b7fb2ef625/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14d4526e076d14e4b994a10182c0ade8/" rel="bookmark">
			vs2017设置控制台输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 工具 -&gt; 选项-&gt; 调试 -&gt; 调试停止是显示控制台
将调试停止时自动关闭控制台前面的勾去掉
更多详情请关注个人工作号： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6d21063c185b5ecb16a5185c666e53e/" rel="bookmark">
			spring整合struts2:struts2报java.lang.UnsupportedOperationException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.lang.UnsupportedOperationException at java.util.Collections$UnmodifiableMap.put(Collections.java:1457) at com.opensymphony.xwork2.config.entities.ResultTypeConfig$Builder.addParam(ResultTypeConfig.java:140) at org.apache.struts2.convention.ConventionsServiceImpl.disableParse(ConventionsServiceImpl.java:127) at org.apache.struts2.convention.ConventionsServiceImpl.getResultTypesByExtension(ConventionsServiceImpl.java:110) at org.apache.struts2.convention.DefaultResultMapBuilder.build(DefaultResultMapBuilder.java:188) at org.apache.struts2.convention.PackageBasedActionConfigBuilder.createActionConfig(PackageBasedActionConfigBuilder.java:951) at org.apache.struts2.convention.PackageBasedActionConfigBuilder.buildConfiguration(PackageBasedActionConfigBuilder.java:734) at org.apache.struts2.convention.PackageBasedActionConfigBuilder.buildActionConfigs(PackageBasedActionConfigBuilder.java:355) at org.apache.struts2.convention.ClasspathPackageProvider.loadPackages(ClasspathPackageProvider.java:53) at com.opensymphony.xwork2.config.impl.DefaultConfiguration.reloadContainer(DefaultConfiguration.java:274) at com.opensymphony.xwork2.config.ConfigurationManager.getConfiguration(ConfigurationManager.java:67) at org.apache.struts2.dispatcher.Dispatcher.getContainer(Dispatcher.java:967) at org.apache.struts2.dispatcher.Dispatcher.init_PreloadConfiguration(Dispatcher.java:435) at org.apache.struts2.dispatcher.Dispatcher.init(Dispatcher.java:479) at org.apache.struts2.dispatcher.ng.InitOperations.initDispatcher(InitOperations.java:74) at org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.init(StrutsPrepareAndExecuteFilter.java:57) at org.apache.catalina.core.ApplicationFilterConfig.initFilter(ApplicationFilterConfig.java:285) at org.apache.catalina.core.ApplicationFilterConfig.getFilter(ApplicationFilterConfig.java:266) at org.apache.catalina.core.ApplicationFilterConfig.&lt;init&gt;(ApplicationFilterConfig.java:108) at org.apache.catalina.core.StandardContext.filterStart(StandardContext.java:4708) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5348) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1408) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1398) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) spring整合struts2,将action交给spring管理,在使用注解的时候发生了异常
java.lang.UnsupportedOperationException
Action如下
import org.apache.struts2.convention.annotation.*; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Controller; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6d21063c185b5ecb16a5185c666e53e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f8000561273d9acdcdd55077159b3cb/" rel="bookmark">
			source insight怎么让一整块代码忘左缩进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按下Shift按键后再按TAB键进行的就是左缩进，比右缩进正好多了一个Shift按键。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44daa03ebcefd385e0ef0e3626e1dd42/" rel="bookmark">
			Java - 获取PDF文档的总页数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们需要判断一个pdf文档中的总页数。这篇文章将介绍如何在Java应用程序中获取一个PDF文档中的页数。
本文所使用的控件是免费Java PDF组件Free Spire.PDF for JAVA。
在使用以下代码前，你需要下载Free Spire.PDF for JAVA包并解压缩，然后从lib文件夹下，导入Spire.Pdf.jar包和Spire.Common.jar包到你的Java应用程序中：
CountPagesOfPDF.Java 代码如下：
import com.spire.pdf.PdfDocument; public class CountPagesOfPDF { public static void main(String[] args) { //创建PdfDocument实例 PdfDocument doc=new PdfDocument(); //加载PDF文件 doc.loadFromFile("Test.pdf"); //获取PDF文件的页数 int pageCount = doc.getPages().getCount(); System.out.print(pageCount); } } 原PDF文件Test.pdf共有73页：
输出结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f4974346fa03b5c6922b4e3af75232/" rel="bookmark">
			C#中base关键字的几种用法:base()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		base其实最大的使用地方在面相对象开发的多态性上，base可以完成创建派生类实例时调用其基类构造函数或者调用基类上已被其他方法重写的方法。
例如：
2.1关于base调用基类构造函数
public class A { public A() { Console.WriteLine("Build A"); } } public class B:A { public B():base() { Console.WriteLine("Build B"); } static void Main() { B b = new B(); Console.ReadLine(); } } 创建一个B的实例对象，获得结果是同时打印Build A和Build B．
2.2关于base在派生类中调用基类的方法。
public class A { public virtual void Hello() { Console.WiriteLine("Hello"); } } public class B : A { public override void Hello() { base.Hello();//调用基类的方法,显示Hello Console.WiriteLine("World"); } } 这样如果程序调用B.Hello()获得的效果将会使Hello World.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7f4974346fa03b5c6922b4e3af75232/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff9f665cb43f96a32e265a332ee5116a/" rel="bookmark">
			LAMMPS命令行-partition选项的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LAMMPS在命令行部分，设置了partition选项，并且在in文件中设置了partition命令来进行辅助处理。
一般来说，partition命令用的不多，下面主要介绍下下-partition(或-p)命令行参数的意义和设置。
-partition用于唤醒lammps采用多分块模式，这个分块是指把计算用的cup进行分块划分。假设你在并行时用 -n指定了p个CPU内核。
那么如果不设置-p，那么p个核会只跑一个作业，也是我们常用的模式，也就是p个核进行并行。
可是有些情况，我们需要做一些副本交换的模拟（LAMMPS有好几种算法可以实现），
来加强抽样，那么这时候，我们用一个命令提交的这个作业，可能要分成几个副本进行模拟，这时候就要用到-p的参数了。
这个参数可以把你指定的核分成多个不同块，每块独立的进行计算，这些块之间有可能进行简单数据的交换（依赖于算法）
举例来说吧：
-partition MxN 或者（-p MxN）是指把计算核心，化成M个块，每块有N个计算核心; M乘以N应该等于 -n指定的核心数
-p a b c d是指 总共化成了 4个块，每块计算核心分别是 a b c d个，那么这a+b+c+d应该等于 -n指定的核心数。
有时候，上面的两个参数形式可能联合使用，比如
-p 4x6 8 6 12
意思是 把核心数这样划分的， 分块总数为 4 + 1 + 1 +1 = 7个； 前四个块每个块包含6个核心，后面三个块，分别是8，6，12.
在时间操作是，如果模拟系统差不多，每块最好使用相同的计算核心数，这个计算的时候，每个副本计算时间上基本是差不多的。
此外，LAMMPS也支持虚拟计算核心，比如你在单核机器上装了MPI并行软件后，你可以在上面跑副本交换，上述方法也可以用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eafbe222fe04a9232003ed56d742e22a/" rel="bookmark">
			人生就像K线图，别想靠几个妖股就能改变的了的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位投资朋友大家好，欢迎收听《抢财猫股票课堂》，我是你们的老朋友波哥。
今天我们聊聊“人生就像K线图，别想靠几个妖股就能改变的了的”这个话题
按照波浪理论的结构（上升5浪，下跌3浪），我们去想象一下人生，把人生用K线图画一下
人生一般就三次创业机会：第一次没钱，没经验，太年轻（刚毕业20多岁）， 第二次没钱，有经验，等机会（30多岁），第三次，有钱，有经验，年纪大了一些（40多岁）。
这里面有个特殊群里，职业创业者，也叫连续创业者，他们有连续成功创业者也有连续失败创业者，明星创业者可以聊聊美团创始人王兴。
好了，我们开始展开这个话题，人生这三次创业机会，你会根据手里资源掌控情况去选择风险偏好程度的项目，越年轻为了找机会就会越喜欢风险大的项目，随着吃的亏多了，年纪成熟稳定了，对于项目要求比较高了，会做自己擅长领域的项目，回报率不会那么高，但是成功率要求一定高。从这个角度，我们思考我们的自身风险喜好程度，去选择股票，人应该越来越趋于理性投资，求稳而不是短期暴利，历史经验短期暴利是不可持续，但是会让人上瘾迷恋，那种感觉就是如此；但是在投资里面过去的成功不代表未来的你一定就能成功，你的现在研究的经验只是过去的而已，不要试图用已知的经验去试图准确预测市场未来的趋势，但是你能做的就是两手准备，如果这样你怎么做，否则那样你怎么做。尽量去做一些大的行业背景知识的研究和积累，能够清楚认清楚行业发展的动态和未来，这种能力需要积累，对于投资大周期的品种很有帮助。
那么在我们个人职业发展或者创业积累过程中需要不断积累行业经验和专业技能，还有自身的快速学习能力和个人心理上的成熟，这些都是跟交易中的交易系统和交易心理都是一一对应的。
所以，今天我提一个概念，交易预期，这个就是说创业的时候我们也有一个成功预期的，创业跟投资一样，并不容易，失败率很高，所以一开始不要有很高的成功预期，那么我们交易预期一开始就不要想着赚大钱，甚至赚小钱都不要去想，只想着如果不亏钱好了，甚至尽量少亏钱，去保住你的大部分本金。
先买列举一些小例子：
1、职业发展和创业经历：
刚开始经验比较少，需要不断积累项目经验，随着项目经验不断丰富，经历的失败多了，成功的经验逐步多了起来，自然有了自信心；对于职业规划和创业规划的路径逐渐清晰化。
交易经历：
刚开始就是亏钱，不断亏钱，甚至不断爆仓，需要我们不断积累交易经验，随着对于市场和自己交易的不断深入了解，逐步总结出一套适合自己的交易体系，自己交易心理逐渐成熟起来，自然就有了交易信心，那么其实对于你的交易路径规划也会逐渐清晰化。
所以，我们创业不可能碰大运随随便便成功，投资买股票也不要想着买几个妖股就能发财致富了，道理上面都说过了，你也不要因为前面投资失败遇到挫折就觉得整个人生就毁了，需要理性分析，合理规划，人生的路很长，人活着就是不断解决问题的，如何正确解题才是关键。
最后我想说的：我们很多时候都是困在某段K线里，这段K线其实就像人生里的一个盘整期，上也上不去，下倒是很容易，如果放量突破整理平台？这需要我们能够蓄积力量去打开自己的上升空间！这一点非常重要，只有有方法和能力，不断突破自己的压力线，你的人生K线才能不断创新高，否则一生可能就是前半生有过一个主升浪然后就没有然后了，后半生全部在回调浪里呆着。
本期节目内容讲到这，希望投资朋友们有问题留言与我交流，也希望大家转发分享给更多的朋友，关注微信公共号抢财猫，谢谢，再见。
完整 音频 收听 ， 点击：
http://www.ximalaya.com/swf/sound/red.swf?id=118729813​www.ximalaya.com
打开喜马拉雅 FM手机APP，搜索并关注：抢财猫股票课堂，可以完整看到全部课程 节目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f2984750305522b5adb78460244cb69/" rel="bookmark">
			Redis实现排行榜功能(实战)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明出处：https://blog.csdn.net/m0_37459380/article/details/82971525
需求 前段时间，做了一个世界杯竞猜积分排行榜。对世界杯64场球赛胜负平进行猜测，猜对+1分，错误+0分，一人一场只能猜一次。
1.展示前一百名列表。
2.展示个人排名(如：张三，您当前的排名106579)。
分析 一开始打算直接使用mysql数据库来做，遇到一个问题，每个人的分数都会变化,如何能够获取到个人的排名呢？数据库可以通过分数进行row_num排序，但是这个方法需要进行全表扫描，当参与的人数达到10000的时候查询就非常慢了。
redis的排行榜功能就完美锲合了这个需求。来看看我是怎么实现的吧。
实现 一.redis sorts sets简介 Sorted Sets数据类型就像是set和hash的混合。与sets一样，Sorted Sets是唯一的，不重复的字符串组成。可以说Sorted Sets也是Sets的一种。
Sorted Sets是通过Skip List(跳跃表)和hash Table(哈希表)的双端口数据结构实现的，因此每次添加元素时，Redis都会执行O(log(N))操作。所以当我们要求排序的时候，Redis根本不需要做任何工作了，早已经全部排好序了。元素的分数可以随时更新。
二.springboot 中使用RedisTemplate 本文主要通过redisTemplate来操作redis,当然也可以使用redis-client,看个人喜好.
我在本机开启了一个单点的redis，配置文件如下
server: port: 9001 spring: redis: database: 0 url: redis://user:123@127.0.0.1:6379 host: 127.0.0.1 password: 123 port: 6379 ssl: false timeout: 5000 Maven依赖引入如下
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 三.代码实现 1.注入redis，将key声明为常量SCORE_RANK
@Autowired private StringRedisTemplate redisTemplate; public static final String SCORE_RANK = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f2984750305522b5adb78460244cb69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3187f9088a5d89a202a61498d44d12f6/" rel="bookmark">
			Maven安装与配置过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，进入官网http://maven.apache.org/，或者直接百度maven，都可以进去，再点击Download可以进到下载界面，
接着，从Files中点击 apache-maven-3.5.4-bin.zip进行下载便可
将他放在一个文件内进行解压，
做到这一步就已经下载解压完成了，现在就是配置maven环境的时候了 ， 配置环境变量，
在系统变量中点击新建，命名一个变量名m2_Home, 变量值为你文件放的地址 D:\Maven\apache-maven-3.5.4，点击确定
在系统变量找到变量path, 在其末尾加上"%m2_Home%\bin; "，记住末尾要加上分号
点击确定后，打开cmd 输入命令行mvn -version, 如果出现下面这种情况就代表配置成功了
接着还要进入刚才解压出来的那个文件，在conf中找到settings文件，修改俩个地方
第一个，
修改localRepository的默认路径
第二
修改mirror，是的下载时不会有其他异常，不然的话选择默认的话，会出现有些jar包下载不了
运行mvn help:system 出现这个提示表示配置已经成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee376581b51a0168a390ae0198e4808/" rel="bookmark">
			IDEA代码高亮设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://blog.csdn.net/qq_35246620/article/details/79056530
版权声明：Follow your heart and intuition. https://blog.csdn.net/qq_35246620/article/details/79056530 温馨提示：本教程的 GitHub 地址为「intellij-idea-tutorial」，欢迎感兴趣的童鞋Star、Fork，纠错。
首先，给出一系列 IntelliJ IDEA 代码的彩色主题，供大家选择：
VibrantUnknown(Darcula) FadeComments NicePython Solarized Havenjark GeditForElegantGnome Gvim 在选完我们中意的主题之后，需要大家到「intellij-idea-tutorial」中下载相应的主题。以「SublimeMonoKai」主题为例：
如上图所示，到 GitHub 中下载jar包，备用。然后，
依次选择File -&gt; Import Settings，导入我们已经下载完的「SublimeMonoKai」主题的jar包。
以 Mac 为例，再选择IntelliJ IDEA -&gt; Preferences，进入Preferences：
然后选择Colors &amp; Fonts，设置Scheme为SublimeMonoKai即可。在我们完成以上操作，重新启动 IntelliJ IDEA 之后（必须重新启动才能生效），效果如下图所示：
最后，希望大家在编程的时候都能够有一个愉悦的心情！
———— ☆☆☆ —— 返回 -&gt; 史上最简单的 IntelliJ IDEA 教程 &lt;- 目录 —— ☆☆☆ ————
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d18e4a3155bad988e08a799e6000e927/" rel="bookmark">
			Qt---之Q_OBJECT详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信号和槽是Qt应用开发的基础，它可是将两个毫无关系的对象连接在一起，槽和普通的C++函数是一样的，只是当它和信号连接在一起后，当发送信号的时候，槽会自动被调用只有加入了Q_OBJECT，你才能使用QT中的signal和slot机制。
所有QObject的派生类在官方文档中都推荐在头文件中放置宏Q_OBJECT，那么该宏到底为我们做了哪些工作？在qobjectdef.h中有下面的代码：
view plain #define Q_OBJECT \ public: \ Q_OBJECT_CHECK \ static const QMetaObject staticMetaObject; \ Q_OBJECT_GETSTATICMETAOBJECT \ virtual const QMetaObject *metaObject() const; \ virtual void *qt_metacast(const char *); \ QT_TR_FUNCTIONS \ virtual int qt_metacall(QMetaObject::Call, int, void **); \ private: 首先定义了一个Q_OBJECT_CHECK宏，这个宏在Q_OBJECT宏的上方定义： view plain #define Q_OBJECT_CHECK \ template &lt;typename T&gt; inline void qt_check_for_QOBJECT_macro(const T &amp;_q_argument) const \ { int i = qYouForgotTheQ_OBJECT_Macro(this, &amp;_q_argument); i = i; } Q_OBJECT_CHECK实现了一个模板函数，该函数调用了qYouForgotTheQ_OBJECT_Macro的函数，qYouForgotTheQ_OBJECT_Macro在宏Q_OBJECT_CHECK下面有定义： view plain template &lt;typename T&gt; inline int qYouForgotTheQ_OBJECT_Macro(T, T) { return 0; } template &lt;typename T1, typename T2&gt; inline void qYouForgotTheQ_OBJECT_Macro(T1, T2) {} 从返回值情况上可以看到，调用的是有int返回值的那个模板函数。但是很不明白，为什么之后还要添加一句 i=i?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d18e4a3155bad988e08a799e6000e927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19d9476306c0a0200b8cc4bc4e88e8ab/" rel="bookmark">
			常用服务器和协议 、介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FTP 、TFTP 、SSH 、Telnet 、HTTP 、HTTPS 、SMTP 、POP3 、DNS 、DHCP 、SNMP 、NFS 、PPP通道
重要概念 ：公钥私钥
一、网络协议 【C/S 客户端/服务器 架构】
1&gt;. FTP 【File Transfer Protocol 文件传输协议】
：TCP 端口 21 ，PORT 方式 端口 20 ，Passive 被动方式 传输数据。
：传输方式 ，文本 和 二进制 、完整、 面向会话、 常规用途文件传输协议。
：FileZilla CuteFTP ，FTP图形客户端
用于网络上控制文件的双向传输，它是一个文件传输的应用程序，不同平台的程序遵守相同的FTP协议，FTP使用前必须登陆，授权。
-&gt; 上传 Upload ，将本地文件传输到远程服务器
-&gt; 下载 Download ，将远程服务器文件下载到本地。 ：用户分类
-&gt; Real 账户，在FTP服务上拥有帐号。当这类用户登录FTP服务器的时候，其默认的主目录就是其帐号命名的目录。
-&gt; Guest用户 ，只能够访问自己的主目录。
-&gt; Anonymous（匿名）用户 ，FTP服务器中没有指定帐户，但是其仍然可以进行匿名访问某些公开的资源。
匿名FTP是这样一种机制，用户可通过它连接到远程主机上，并从其下载文件，而无需成为其注册用户。系统管理员建立了一个特殊的用户ID，名为anonymous, Internet上的任何人在任何地方都可使用该用户ID。其口令可以是任意的字符串。
2&gt;. TFTP 【Trivial File Transfer Protocol 简单文件传输协议】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19d9476306c0a0200b8cc4bc4e88e8ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00d526316b67c4903ee52a898d16a691/" rel="bookmark">
			怎么看自己的win10激活时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鼠标右键点击开始按钮，选择“运行”
然后在打开的运行窗口中，输入命令“Slmgr.vbs -xpr”，然后点击确定按钮
一会就会弹出窗口，显示我们的系统激活的过期时间了，如果为永久激活的话，在窗口中就会显示出永久激活的字样。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7e6008d95917e382acdbf2084372588/" rel="bookmark">
			Spring Aop 面向切面编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Aop是什么？ 注明（此段话引自）：https://blog.csdn.net/when_less_is_more/article/details/78175891?utm_source=copy
Aspect Oriented Programming 面向切面编程。解耦是程序员编码开发过程中一直追求的。AOP也是为了解耦所诞生。
具体思想是：定义一个切面，在切面的纵向定义处理方法，处理完成之后，回到横向业务流。
AOP 在Spring框架中被作为核心组成部分之一，的确Spring将AOP发挥到很强大的功能。最常见的就是事务控制。工作之余，对于使用的工具，不免需要了解其所以然。学习了一下，写了些程序帮助理解。
2 spring AOP 可以用来干什么？ 1 防止过多代码沉积 （比如记录日志等，再也不需要每个代码里面 添加记录日志代码）
2 统一组织 管理代码 拦截某些方法执行前后，做一些操作（如关闭 流，操作事务，记录日志等等）， 不影响原程序。
3 实现方式 注解实现 通知：
就是你想要用到的功能，也就是上面说的 安全，事物，日志等。自己 先定义好，然后在想用的地方用一下。
连接点：
就是spring允许你使用通知的地方，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，spring只支持方法连接点.其他如aspectJ还可以让你在构造器或属性注入时都行，不过那不是咱关注的，只要记住，和方法有关的前前后后（抛出异常），都是连接点。
切面：
可以是具体的一个类
切点：
声明需要切入方法的定义 ，此方法不会执行 5种类型：
Before 某方法调用之前发出通知。After 某方法完成之后发出通知，不考虑方法运行的结果。After-returning 将通知放置在被通知的方法成功执行之后。After-throwing 将通知放置在被通知的方法抛出异常之后。Around 通知包裹在被通知的方法的周围，在方法调用之前和之后发出通知。 maven依赖：
&lt;dependencies&gt;
&lt;!-- spring的依赖包 --&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework&lt;/groupId&gt;
&lt;artifactId&gt;spring-context&lt;/artifactId&gt;
&lt;version&gt;4.3.1.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework&lt;/groupId&gt;
&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
&lt;version&gt;4.3.1.RELEASE&lt;/version&gt;
&lt;type&gt;jar&lt;/type&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjrt --&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.aspectj&lt;/groupId&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7e6008d95917e382acdbf2084372588/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46cfe161e473027040fc50c2149f382d/" rel="bookmark">
			19.C 语言与 C&#43;&#43;在定义常量时有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常量是在程序中不能更改的量！在C/C++中有两种定义常量的的方式。
一种是define宏定义；一种是在C++中新提出来的const型常量；
define是预处理指令的一种，它用来定义宏，宏只是一个简单的替换，将宏变量所对应的值替换。
const定义常量的时候并没有这个替换的操作，与使用正常的变量无异。const型变量只是在语法层面上限定这个变量的值不可以修改，我们可以通过强制类型转化或者通过内嵌汇编的形式修改这个变量的值。
我们可以总结出const和define的几个不同之处：
1）define是一个预处理指令，const是一个关键字。
2）define定义的常量编译器不会进行任何检查，const定义的常量编译器会进行类型检查，相对来说比define更安全
3）define的宏在使用时是替换不占内存，而const则是一个变量，占内存空间
4）define定义的宏在代码段中不可寻址，const定义的常量是可以寻址的，在数据段或者栈段中。
5）define定义的宏在编译前的预处理操作时进行替换，而const定义变量是在编译时决定
6）define定义的宏是真实的常量，不会被修改，const定义的实际上是一个变量，可以通过相关的手段进行修改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b7ec875f6fbfdd3f5d6f1046ea55a2/" rel="bookmark">
			C语言ascII与数字转化的问题，值得新手看看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 从键盘输入一个字符，若该字符是小写字母，输出“该字符 is a lower case letter.”，若该字符是大写字母，输出“该字符 is a capital letter.”，若既不是小写字母也不是大写字母，则输出“该字符 is the other one.”。
输入一个字符输出该字符的类型样例输入?样例输出? is the other one.
请问这个怎么写？
C语言的字符类型char缺省就是存储的ASCII不用转换的
另外,C语言本身提供一套判断字符的函数的(不用自己写的)
程序很简单的
#include&lt;stdio.h&gt; #include&lt;ctype.h&gt; int main() { char c; c=getchar(); if (islower(c)) printf("该字符 is a lower case letter.\n"); else if (isupper(c)) printf("该字符 is a capital letter.\n"); else printf("该字符 is the other one.\n"); return 0; } 若要自己写判断也简单的,如
if(islower(c)) 可用 if(c&gt;='a' &amp;&amp; c&lt;='z') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65fba982981c8bf5a67f7ea3ea49b1f/" rel="bookmark">
			MapReduce之WordCount程序详解及常见错误汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
在之前的笔记中，我们已经成功的关联了eclipse和hadoop，对FileSystem的使用进行了简单了解。
下面就是Hadoop中的重点MapReduce程序的开发。作为MapReduce（以下使用MR来代替）开发中的入门程序WordCount，基本是每个学习MapReduce的同学都必知必会的。有关于WordCount的概念笔者就不再赘述，网上有N多文章讲解。
本次博客主要是记录笔者在Windows环境下使用eclipse进行WordCount程序编写过程中所遇到的问题及解决方案。
准备工作：
* Windows环境下Eclipse工具的准备（需要使用插件关联hadoop，更多细节请参考笔者另一篇文章https://blog.csdn.net/qq_26323323/article/details/82936098 ）
* 创建maven项目，命名为hadoop，将Linux环境下hadoop的配置文件core-site.xml/mapred-site.xml/hdfs-site.xml/yarn-site.xml放入hadoop/src/main/resources中（主要是因为MR程序需要加载这些配置文件中的配置内容）
* 在hadoop/src/main/resources中创建log4j.properties文件，内容如下
log4j.rootLogger=DEBUG, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n log4j.appender.logfile=org.apache.log4j.FileAppender log4j.appender.logfile.File=target/spring.log log4j.appender.logfile.layout=org.apache.log4j.PatternLayout log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n 注意：之所以要创建该文件，是因为在eclipse中启动MR程序时，默认是没有日志的，我们加载log4j的配置后，root设置为DEBUG级别，那么程序的每一步操作我们都可以通过日志来观察到，有利于我们定位问题
* 使用用户hxw（笔者）来启动hadoop
HADOOP_HOME/sbin/start-dfs.sh HADOOP_HOME/sbin/start-yarn.sh 1.WordCount程序的编写
具体内容如下，笔者不再详述
package hadoop.mr; import java.io.IOException; import java.net.URI; import java.util.StringTokenizer; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.FileSystem; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.LongWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.Mapper; import org.apache.hadoop.mapreduce.Reducer; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; public class WordCount { public static class WCMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt;{ private final static IntWritable ONE = new IntWritable(1); private Text word = new Text(); /** * map程序，进行切割转换 */ @Override protected void map(LongWritable key, Text value, Mapper&lt;LongWritable, Text, Text, IntWritable&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a65fba982981c8bf5a67f7ea3ea49b1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e668794c7c49620af82d3e9a3b43eccc/" rel="bookmark">
			web页面编写过程中的中文乱码问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文乱码的出现是由于编码和解码的方式不同，只要将二者修改为对应的方式就成。具体解释如下：
在刚学习web开发的时候常遇见中文乱码的问题，而且根据网上的教程时而能解决，时而不能，主要原因是很多初学者不知道中文系统的浏览器的默认解码字符集是 GB2312，而我们的编辑器常采用的是 UTF-8的解码方式，一般情况下只要修改编辑器汇总的解码方式就可以了。
但是还有一种情况就是，我已经写了好几个文件或者是从网上下载的代码，这个时候的话需要在html文件中添加一些标签来告诉浏览器你所使用的编码方式，如下：
&lt; meta charset = “utf-8” /&gt;
charset后的双引号内写上你所需要的字符集名称，并放在&lt;head&gt;标签之后就可以达到效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8259f25850d7a00ca205aaaab9556a92/" rel="bookmark">
			html版本声明和浏览器的怪异模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一直没搞清楚做前台页面的时候总会出现的一些声明有什么用，如下图中的第一行：
之后通过网课了解到，这是不同版本间html的版本声明，浏览器通过这些声明采用对应方法对代码进行解析。以下是目前常用的版本声明：
HTML 4版本声明：
XHTML 版本声明：
以上版本都是比较早时期的版本了，需要这么多版本的声明也是因为早期的HTML的代码规范十分松散，非常容易导致浏览器的不兼容，而2014年推出来的HTML5对此也进行了简化，变成如下：
&lt; ！doctype html&gt;
以上声明大小写都可以，如果不写版本声明会发生什么事？浏览器为了兼容一些旧的网页，设置了标准模式和怪异模式（Quirks Mode），当浏览器进入怪异模式，不能正常解析代码，因此版本声明是必须要写的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52aaf9621262baadab8cc41e6d60874c/" rel="bookmark">
			【说明书】迪士尼儿童手表说明书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表盘上共四个按键，左上为冷光灯键S1，左下为功能键S2，右上为调试键S4，右下为切换键S3
1、闹铃的调试：首先按功能键S2两下，松开，进入闹钟的调试模式，按下右下切换键S3，时闪动，然后按下右上的调试键S4，进行调试到您要的时的时间，调好后再按下右下切换键S3，分闪动，按右上调试键S4，进行分的调试，调好后按下功能键S2恢复到正常模式。
2、时间的调试：按下功能键S2三下，松开，秒的数字开始闪动，按下右下切换键S3，切换到时闪动，按下右上调试键S4进行时的调试。调好后按下右下的切换键S3，分闪动，按下右上调试键S4进行分的调试。按下右下切换键S3月的数字闪动，按下右上调试键S4进行月的调试。按下右下切换键S3，日的数字闪动，按下右上调试键S4进行日的调试。按下右下切换键S3，表盘上星期的字母闪动，按下右上调试键S4进入星期的调试。最后按功能键S2恢复到正常模式
3、闹钟与整点报时的开启/关闭：在正常时间显示状态下，按左下功能键S2两下，松开，再按下右上键S4，闹铃开启（表盘中出现ALM）。再按下右上键S4，整点报时开启（表盘中出现SIG）。按下右上键S4，闹铃和整点报时同时关闭（ALARM和CHIME同时消失）。
4、在正常时间显示状态下，按左下键S2一次，秒表显示画面，按右上键S4开始计时，再按S4停止计时，停止时按右下键S3秒表归零。秒表最大范围是23小时59分59秒。
5、12/24小时的切换：按下功能键S2三下，松开，秒的数字开始闪动，按下右下切换键S3，切换到时闪动，按下右上调试键S4进行时的调试，连续按24下，完成12/24小时的切换，12小时制下午时间会出现一个字母P。调试完之后按左下角S2键恢复到正常模式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c708815fb1e5523fc7acdc960ebe707/" rel="bookmark">
			Mysql安装与设置用户名、密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人博客网：https://wushaopei.github.io/ (你想要这里多有) 关于MySQL程序中数据库调度的流程图解： 1-MySql数据库的安装 安装前要注意，看看当前系统是32位系统，还是64位的，根据不同的系统位数安装对应的MySQL程序！
关于MySQL的安装包，各位盆友如果没有的话，可以在博主的资源内查找，没有分下载的朋友也可以发言，博主不定时上线，然后再分享给你们！
安装步骤： 双击运行安装程序：以Win32位为例
点击 Next 进入下一步，
选择安装类型，分别有“Typical（默认）”、“Complete（完全）”、“Custom（用户自定义）”三个选项，
我推荐选择“Custom”，有更多的选项，也方便熟悉安装过程。
默认安装路径： 手动修改路径示例： 在“MySQL Server（MySQL服务器）”上左键单击，选择“This feature, and all subfeatures, will be installed on local hard drive.”，即“此部分，及下属子部分内容，全部安装在本地硬盘上”。点选“Change...”，手动指定安装目录(分为安装目录和数据库目录） 确认一下先前的设置，如果有误，按“Back”返回重做。按“Install”开始安装。
正在安装中，请稍候，直到出现下面的界面。
点击“next”继续，出现如下界面。
现在软件安装完成了，出现上面的界面，这里有一个很好的功能，mysql 配置向导，不用向以前一样，自己手动乱七八糟的配置my.ini 了，将“Configure the Mysql Server now”前面的勾打上，点“Finish”结束软件的安装并启动mysql配置向导。
MySQL Server配置向导启动，点击“next”
选择配置方式，“Detailed Configuration（手动精确配置）”、“Standard Configuration（标准配置）”，
我们选择“Detailed Configuration”，方便熟悉配置过程。
选择服务器类型，“Developer Machine（开发测试类，mysql 占用很少资源）”、“Server Machine（服务器类型，mysql占用较多资源）”、“Dedicated MySQL Server Machine（专门的数据库服务器，mysql占用所有可用资源）”，大家根据自己的类型选择。
选择mysql数据库的大致用途，“Multifunctional Database（通用多功能型，好）”、“Transactional Database Only（服务器类型，专注于事务处理，一般）”、“Non-Transactional Database Only（非事务处理型，较简单，主要做一些监控、记数用，对MyISAM数据类型的支持仅限于non-transactional），随自己的用途而选择了，我这里选择“Multifunctional Database ”，按“Next”继续
对InnoDB Tablespace进行配置，就是为InnoDB 数据库文件选择一个存储空间，如果修改了，要记住位置，重装的时候要选择一样的地方，否则可能会造成数据库损坏，当然，对数据库做个备份就没问题了，这里不详述。我这里没有修改，使用默认位置，直接按“Next”继续。
选择您的网站的一般mysql 访问量，同时连接的数目，“Decision Support(DSS)/OLAP（20个左右）”、“Online Transaction Processing(OLTP)（500个左右）”、“Manual Setting（手动设置，自己输一个数）”，我这里选“Decision Support(DSS)/OLAP”，自己的服务器，应该够用了，按“Next”继续。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c708815fb1e5523fc7acdc960ebe707/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ef38fbcb3d27d5e775a2f8a7eb4eb2f/" rel="bookmark">
			Linux三剑客（grep、sed、awk）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面所说的是Linux中最重要的三个命令在业界被称为“三剑客”，它们是awk,sed,grep。
我们现在知道Linux下一切皆文件，对Linux的操作就是对文件的处理，那么怎么能更好的处理文件呢？这就要用到我们上面的三剑客命令。
在说这三个命令前我们要插入一个小插曲就是“正则表达式”。
一、正则表达式 所谓的正则表达式我个人理解就是正规的表示方法。他是用简单的方法来实现强大的功能，所以深受计算机爱好者的使用。
三剑客与正则表达式是什么关系呢？
我们可以这样理解，三剑客就是普通的命令，有的把他们叫做工具，在我看来都一样。而正则表达式就好比一个模版。三剑客能读懂这个模版。就这么简单。注意只有三剑客才能读懂这个模版哦！
现在他们的关系和功能都搞懂了，接下来我们就来认识下他们怎么结合的。正则表达式是一个模版，这个模版是由一些普通字符和一些元字符组成。普通字符包括大小写的字母和数字，而元字符则具有特殊的含义。具体如下
元字符
功能
意思
^
匹配行首
表示以某个字符开头
$
匹配行尾
表示以某个字符结尾
^$
空行的意思
表示空行的意思
.
匹配任意单个字符
表示任意一个字符
*
字符* 匹配0或多个此字符
表示重复的任意多个字符
\
屏蔽一个元字符的特殊含义
表示去掉有意义的元字符的含义
[]
匹配中括号内的字符
表示过滤括号内的字符
.*
代表任意多个字符
就是代表任意多个字符
lele\{n\}
用来匹配前面lele出现次数。n为次数
就是统计前面lele出现的次数
lele\{n,\}
含义同上，但次数最少为n
从功能就可以看出
lele\{n,m\}
义同上，但lele出现次数在n与m之间
从功能也可以看出
lele\{n,m\}
义同上，但lele出现次数在n与m之间
从功能也可以看出
三剑客的功能非常强大，但我们只需要掌握他们分别擅长的领域即可：grep擅长查找功能，sed擅长取行和替换。awk擅长取列。
二、grep 文本过滤(模式：pattern)工具，grep, egrep
grep [OPTIONS] PATTERN [FILE...] --color=auto 对匹配到的文本着色显示-v 显示不被pattern匹配到的行-i 忽略字符大小写-n 显示匹配的行号-c 统计匹配的行数-o 仅显示匹配到的字符串-q 静默模式，不输出任何信息-A # after, 后#行-B # before, 前#行-C # context, 前后各#行-e 实现多个选项间的逻辑or关系
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ef38fbcb3d27d5e775a2f8a7eb4eb2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f40d0ddb1aa172fa879eb233409021/" rel="bookmark">
			MATLAB图像处理之图像边缘提取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB中有几种算法可以对图像进行边缘提取，其中一种就是edge算法，这个edge算法中有好几个算子，每一个算子分别对应着一种边缘提取的原理，接下来就来看一下几种方法的异同
%读取一张图片，并显示 original_picture=imread('D:\SoftWare\matlab2016a\Project\Picture\cat.jpg'); Pic2=im2bw(original_picture,thresh); figure(1) subplot(2,2,1); imshow(original_picture); title('原始RGB图像') subplot(222) imshow(Pic2) title('二值化图像') %用edge算法对二值化图像进行边缘提取 PicEdge1=edge(Pic2,'log'); subplot(223); imshow(PicEdge1); title('log算子') PicEdge2 = edge(Pic2,'canny'); subplot(224); imshow(PicEdge2); title('canny算子'); PicEdge3=edge(Pic2,'sobel'); figure(2) subplot(221) imshow(PicEdge3); title('sobel算子') PicEdge4=edge(Pic2,'prewitt'); subplot(222) imshow(PicEdge4); title('sprewitt算子') PicEdge5=edge(Pic2,'zerocross'); subplot(223) imshow(PicEdge5); title('zerocross算子') PicEdge6=edge(Pic2,'roberts'); subplot(224) imshow(PicEdge6); title('roberts算子') 虽然我们从提取的结果来看，可能他们的差别不是很明显，但是这几个算子的基本原理还是有区别的，另外由于我采用的原始图片可能图中的猫和背景颜色有的部分很相似，所以会导致有些猫的边缘没有被提取出来，以后还需改善。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72aa64c2e2882057cfa384dc9c2f2d11/" rel="bookmark">
			图像的灰度直方图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		灰度直方图是反映一幅图像中各灰度级像素出现的频率与灰度级的关系，以灰度级为横坐标，频率为纵坐标，绘制频率同灰度级的关系图像就是一幅灰度图像的直方图。
简单地说，就是把一幅图像中每一个像素出现的次数都先统计出来，然后把每一个像素出现的次数除以总的像素个数，得到的就是这个像素出现的频率，然后再把像素与该像素出现的频率用图表示出来，就是灰度直方图。
例如：
如上图这个例子，假如说现在有一幅图像的数据为8*8的，每一个坐标点的像素值都在图中的表格中，取值为0-7，如果我们要画直方图的话，我们就需要把0-7中的每个数字都先统计一下，然后把每一个统计的次数都除以总像素数，也就是除以64，得到的就是每一个像素出现的频率，就是图中的v0、v1…，然后就可以画直方图了
直方图的一些性质：
1、灰度直方图只能反映图像的灰度分布情况，而不能反映图像像素的位置，即丢失了像素的位置信息
2、一幅图像对应唯一的灰度图像图，但是不同的图像可对应相同的直方图，如下
3、一幅图像分成多个区域，多个区域的直方图之和即为原图像的直方图
直方图有一个应用就是它可以确定图像二值化的阈值。当我们的发现某一幅图像的灰度直方图中有两个波峰，有一个波谷的话，那么这个波谷就可以作为这幅图像二值化的阈值
另外我们画图像的灰度直方图一般是用MATLAB来画的，用到的函数是imhist()，这个函数有一个参数，这个参数就是我们需要操作的图像名称，但是这个图像不能是一个RGB图像，它只能是一幅灰度图像或者二值化图像（即它在MATLAB中存储的图像数据不能是一个三维的数组，最多只能是二维的）。如果我们有一幅RGB图像，那么我们必须先把它转化为灰度图像或者二值化图像才能去画灰度直方图，这可能也是这个直方图叫做灰度直方图的原因吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c7e9a64db8cfc1daabe780797e2e69/" rel="bookmark">
			MATLAB图像处理之图像的像素矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考博文地址：https://blog.csdn.net/jiugedexiaodi/article/details/79661441
首先我们用MATLAB打开一张图像可以发现在工作区中就会多一个变量，这个变量是一个三维数组，第一维代表图像的X坐标，第二维代表图像的Y坐标，第三维代表R、G、B，第三维中的数字1代表R，数字2代表G，数字3代表B。
如下图，我打开一张图片，在MATLAB工作区就会出现这样一个变量，变量名字是自己设定的
然后我们可以把这三个分量给分离开，并且可以绘制出各个分量的图像，代码如下：
%读取一张图片，并显示 original_picture=imread('C:\Users\MyPC\Desktop\cat.jpg'); subplot(2,2,1); imshow(original_picture); title('原始图像的直方图') %分别读取R、G、B的值，1代表R，2代表G，3代表B image_r=original_picture(:,:,1); image_g=original_picture(:,:,2); image_b=original_picture(:,:,3); subplot(222) imshow(image_r); title('R Part'); subplot(223) imshow(image_g); title('G Part'); subplot(224) imshow(image_b); title('B Part'); 然后我们可以随便看一下分离出来的三个变量中的一个，假如说我要看原始图像中R的分量的像素矩阵，我们可以直接在MATLAB的工作区中点击对应的变量名称即可：
点击之后，我们就可以看到一个二维矩阵，这个二维矩阵就是原始图像中R的分量的像素矩阵
这个矩阵为640*640的，即640行、640列，这是和你原始图像的分辨率有关系的应该。每一个单元格的数值就代表了原始数据中那一个坐标点的R分量的数值。
接下来，我们可以继续画出相对应的直方图，直方图具体是个啥，目前我还不是很清楚
%画直方图 GrayPic=rgb2gray(original_picture);%把RGB图像转化成灰度图像，imhist()函数的参数好像只能是二维的图像，不能是三维的，所以这里先把原始彩色图像转化为灰度图像 hist_image=imhist(GrayPic);%原始图像的灰度图像的直方图 hist_r=imhist(image_r);%R部分的直方图 hist_g=imhist(image_g);%G部分的直方图 hist_b=imhist(image_b);%B部分的直方图 figure(2) subplot(221) bar(hist_image); title('原始图像的灰度图像的直方图') subplot(222) bar(hist_r); title('R部分的直方图') subplot(223) bar(hist_g); title('G部分的直方图') subplot(224) bar(hist_b); title('B部分的直方图') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4fcda91f694380bce7eabdec60f12b3/" rel="bookmark">
			nginx多实例目录结构配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx支持多实例启动，只需要创建一套实例运行的环境配置就可以启动该实例
基本目录结构
woker01 |-- conf | `-- nginx.conf |-- data |-- html | |-- 50x.html | `-- index.html |-- logs 启动实例
cd /root/woker01 ores -p `pwd` -c conf/nginx.conf 启动两个实例查看进程，一个实例总是对应一个master进程和worker进程
[root@VM_0_17_centos worker01]# ores -p `pwd` -c conf/nginx.conf [root@VM_0_17_centos worker01]# ps -aux | grep nginx root 26203 0.0 0.1 54764 2812 ? Ss 10:41 0:00 nginx: master process ores -p /root/worker02 -c conf/nginx.conf root 26240 0.0 0.1 57216 2552 ? S 10:41 0:00 nginx: worker process root 26450 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4fcda91f694380bce7eabdec60f12b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847b848c05aad64cf369facc2d6c0eea/" rel="bookmark">
			Python获取当前路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Refs:
https://blog.csdn.net/qq_15188017/article/details/53991216
假设py文件路径为
F:/SEG/myResearch/myProject_2/test.py
Method 1: sys.argv[0] import sys print sys.argv[0]#获得的是当前执行脚本的位置（若在命令行执行的该命令，则为空）12 运行结果（在python脚本中执行的结果）：
F:/SEG/myResearch/myProject_2
注意：对于py文件和py可执行文件sys.path[0]返回的结果不同。
import sys,os #获取脚本文件的当前路径 def cur_file_dir(): #获取脚本路径 path = sys.path[0] #判断为脚本文件还是py2exe编译后的文件，如果是脚本文件，则返回的是脚本的目录，如果是py2exe编译后的文件，则返回的是编译后的文件路径 if os.path.isdir(path): return path elif os.path.isfile(path): return os.path.dirname(path) Method 2: os模块 import os print os.getcwd()#获得当前工作目录 print os.path.abspath('.')#获得当前工作目录 print os.path.abspath('..')#获得当前工作目录的父目录 print os.path.abspath(os.curdir)#获得当前工作目录 运行结果：
F:\SEG\myResearch\myProject_2 F:\SEG\myResearch\myProject_2
F:\SEG\myResearch F:\SEG\myResearch\myProject_2
注：若要改变当前工作路径，可以用：os.chdir(path) 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b56b69c9129281be4ca524e28ef3d0c/" rel="bookmark">
			Linux内核学习笔记（1）—— 什么是Linux内核？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：《Linux内核设计与实现（第2版）》第一章 Robert Love 内核，不外乎就是一个程序。 1. 什么是操作系统？ 操作系统是负责整个系统最基本功能和系统管理，包括内核、设备驱动程序、启动引导程序、命令行shell或其它种类的用户界面、基本的文件管理工具和系统工具。
用户界面是操作系统的外在表象，内核是操作系统的内在核心。
2. 什么是内核？ 内核由一系列程序组成，包括负责响应中断的中断服务程序、负责管理多个进程从而分享处理器时间的调度程序、负责管理地址空间的内存管理程序、网络、进程间通信的系统服务程序等。
内核负责管理系统的硬件设备。
3. 内核空间 VS 用户空间 内核空间表示内核拥有的内存空间，用户空间表示用户程序执行时的内存空间。
内核拥有直接访问硬件设备的所有权限，用户程序不能直接访问硬件设备，因此用户程序通过系统调用和内核通信来运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed1500f06cdd54963ee66a1a96a45e67/" rel="bookmark">
			求极限、等价无穷小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python 自带常数E
解答：
x = Symbol('x') limit(E,x,0) 解答：
x0 = Symbol('x0') #常数可省略 x = Symbol('x') limit(x,x,x0) 解答：
x = Symbol('x') limit((2*x-1),x,1) 解答：
x = Symbol('x') limit((pow(x,2)-1)/(x-1),x,1) 解答：
x = Symbol('x') x0 = Symbol('x0') #常数可省略 limit((pow(x,1/2)),x,x0) 解答：
n = Symbol('n') x = Symbol('x') limit((pow((1+x),1/n)-1)/(1/n*x),x,0) #等价无穷小 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3036580dbf1a4b557534f408440cc742/" rel="bookmark">
			基于MATLAB的二进制数字调制与解调信号的仿真——2ASK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现二进制数字调制与解调信号的仿真是我的MATLAB课程设计的一部分，我参考了网上的一些资料，并加入了一些自己的想法，代码已在本地MATLAB编译通过且能正常运行
2ASK——二进制振幅键控
i=10;%10个码元 j=5000; t=linspace(0,5,j);%0-5之间产生5000个点行矢量，即将[0,5]分成5000份 fc=10;%载波频率 fm=i/5;%码元速率 %产生基带信号 x=(rand(1,i));%rand函数产生在0-1之间随机数，共1-10个 %figure(2)l;plot(x); a=round(x);%随机序列，round取最接近小数的整数 %&gt;0.5的值就为1，&lt;0.5的值就为0 %figure(3);stem(a);%火柴梗状图 st=t; for n=1:10 if a(n)&lt;1 disp(j/i*(n-1)) for m=j/i*(n-1)+1:j/i*n %a(1)是1的话,就将0-1赋值为1 st(m)=0; end else for m=j/i*(n-1)+1:j/i*n st(m)=1; end end end figure(1); subplot(421); plot(t,st); axis([0,5,-1,2]); title('基带信号st'); %载波 s1=cos(2*pi*fc*t); subplot(422); plot(s1); title('载波信号s1'); %调制 e_2ask=st.*s1;%st是基带信号,s1是载波 subplot(423); plot(t,e_2ask); title('已调信号'); noise =rand(1,j); e_2ask=e_2ask+noise;%加入噪声 subplot(424); plot(t,e_2ask); title('加入噪声的信号'); %相干解调 at=e_2ask.*cos(2*pi*fc*t);%这里用的cos必须和载波s1完全同步 %subplot(428);plot(t,at); at=at-mean(at);%因为是单极性波形，还有直流分量，应去掉 subplot(425); plot(t,at); title('与载波相乘后信号'); [f,af] = T2F(t,at);%通过低通滤波器 [t,at] = lpf(f,af,2*fm); subplot(426); plot(t,at); title('相干解调后波形'); %抽样判决 for m=0:i-1 %i=10 i是码元个数 if (at(1,m*500+250)+0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3036580dbf1a4b557534f408440cc742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b958dfa6aa247061632d35491e897a05/" rel="bookmark">
			使用auto-encoder实现数据压缩、分类预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理简介： （文章编辑bug太多，白码字了，只能简化说了。）通过encoder-decoder的结构形成一个负、正金字塔的瓶颈结构(必须是瓶颈结构，才能起到压缩的效果，不然就成了复制了)，对数据进行压缩并还原，以还原程度为指标来训练网络。训练完网络就有了一个encoder和decoder，decoder先不管，encoder能把数据压缩，因为压缩还能还原，证明原数据有冗余，压缩后的code可以直接用来分类，而不是直接用原数据。所以在encoder后边接一个分类器就能完成分类工作。（如果你要进行分类工作，当你训练完auto-encoder，decoder应该是没有用的，下边会说）
结构示意
++++++++++++ input
++++++ encoder
+++ code
++++++ decoder
++++++++++++ output
下边放一个示意图：
如果要直观的解释auto-encoder实现了什么功能，如何实现，如果说压缩到z之后信息已经损失了，为什么还要恢复到x^？况且，本来最后也用不到decoder？
可以这样说，encoder把成绩从100～0分成了优良中差，既然z是瓶颈，恢复到x^时确实已经丢失信息了，优不知道对应91还是99了，但是，仍然要reconstruct到x^的意义是，有个参照来矫正，用x^和目标x对比，至少优还让你在九十多分，而不会到六十分以下，这一部分是要实现训练的功能，让auto-encoder有据可依。（那么，为何不直接用优良中差来训练z呢？因为你没有优良中差的标签，现实的神经网络，也不一定刚好用60分来标记差，如果可以，还要神经网络干嘛？回过头来讲，不就因为你不知道怎么给成绩分类优良中差，所以才要让它自动学习的嘛）
下图有loss公式（不用label训练），训练之后，decoder就没用了，注意，是没用了！！！要记住，目的是得到encoder！而VAE则是保留Decoder（当然，VAE的核心是学到z分布，只是相对auto-encoder，VAE是保留decoder）
这个才是完全体，抛弃decoder，用encoder直接作为输入的过渡（不过，反思一下，一定需要它么？我觉得在深度网络大行其道的当下，这个必要性不存在，网络容量够大，什么特征提取不来？都不耽误训练！够用！当然，这块是个人认为，有待求证）
大概去搜了一下网上的说法，关于auto-encoder在深度学习的必要性：
autoencoder方法可能的一些优势
（1）用于supervised learning可作为特征转换的手段
在观察到的数据上能探测到一些潜藏的structures，可以用于深度神经网络的pre-training部分，得到较好的初始的权重。(这是前边提到的分类问题，监督学习，也仅仅是预训练，感觉不是绝对的必要)
（2）用于unsupervised learning
density estimation和离群点检测（所谓离群点检测，大概也就是通过encoder再通过decoder，两者都要有，看重建之后的偏差，大于一个阈值就算离群点（前提，训练auto-encoder的数据一定要正常）。总的来说，这是偏向于人工去观察和可视化方面的，也就是说，一定程度上近似PCA的功能）
（3）学习数据的典型表示
小结：可能在不同场景下确实有些用处，没用到的暂时不讨论。理论上，压缩数据确实可能节省不少参数量和计算量。至少在本文提到的用于预处理特征从而进行分类，在网络性能没达到瓶颈的前提下（毕竟resnet都一百多层了，虽然我的显卡不行，土豪的显卡也不是瓶颈），用encoder处理不具有十足的必要性。尤其是BN的使用，使得一个精心挑选的初始化显得不是那么必要。相似的还有word2vec的n-gram，也算是一个简单的数据压缩，算是输入层面的一个转换。
todo:上边三点也不一定代表全部，有空也看看论文怎么说。
训练过程： 用三层auto-encoder进行训练，encoder逐层递减，decoder逐层递增。
训练结束后把encode的输出接到全连接层，实现分类预测。
图像压缩到3维大概是77%的准确率。可以把不同层的encode（en2、en1、en0）输出接入到全连接层，根据压缩程度不同，准确率不同。激活函数也有略微影响。暂时就不试所有情况了，有兴趣的可以多试试。
因为两层全连接层的输出同是10（encode输出是3维，所以fc1没设置太大，没意义；en2以前不小于12，所以fc1也没设太小），有点像平行输出，所以第二层不能再加tanh激活，准确率会下降。
import tensorflow as tf from tensorflow.examples.tutorials.mnist import input_data import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm import numpy as np tf.set_random_seed(1) # Hyper Parameters BATCH_SIZE = 64 LR = 0.002 # learning rate CLR = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b958dfa6aa247061632d35491e897a05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d7aa3e728fa1e3dcae3550d975e03c0/" rel="bookmark">
			使用CentOS6.8搭建Hadoop集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述： 集群cluster，能将很多进程分布到多台计算机上；通过联合使用多台计算机的存储、计算资源完成更庞大的任务。
为了实现无限量的存储和计算能力，在生产环境中必须使用集群来满足需求。
注意事项： 1)集群中的计算机在时间上要同步，系统时间不能差太多（约30秒内），如果设置时间后重启时间又不准确了（可能是主板电池老化），可以启用NTP（Network Time Protocol网络时间协议）服务解决（CentOS7安装时就可以设置自动同步）。
2)集群中的计算机在网络上能够相互访问
i.虚拟机的网络使用NAT模式
ii.固定IP，要规划好IP地址和主机名（）
iii.全部关闭防火墙
iv.全部实现Hosts解析
v.全部实现免密码SSH访问（可以统一密钥对）
-.NameNode-对应的是-master、DataNode-对应的是-slave
--前提：安装三个虚拟机（内存最好在8~13G）,分别作为master、slave1、slave2
记住三个虚拟机的名字和IP
1.安装JDK 如果安装的是minimal（最小版），跳过卸载直接去下载安装，如果安装的不是minimal（最小版），那么你需要卸除原有的JDK。
1.1卸载非LinuxJDK
卸载OpenJDK（最小化安装不带Open JDK）
Gnome桌面版自带OpenJDK，OpenJDK是JDK的一个开源实现
与Oracle官方JDK相似度近95%，一般情况下可以使用
但大数据的Hadoop不支持OpenJDK
通过rpm查找jdk和java的安装信息
rpm是RedHat包管理器，包管理器能够管理应用的安装卸载
类似于Maven管理Jar包
rpm -qa | grep jdk
java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64 java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64 java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64 java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64 卸载
对于如上的每一行输出，都调用rpm -e --nodeps，如（：
rpm -e --nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64
-e 表示卸载
--nodeps 表示不考虑是否有依赖问题，强制卸载
1.2下载：
上浏览器上下载linuxJDK压缩包（搜索Linux JDK 64）
提示路径：http://download.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-linux-x64.tar.gz
或者温馨jdk链接：https://pan.baidu.com/s/1Yg7Nwp-JQSC7eNDDe2uaaA 提取码：mjnk
1.3：将JDK压缩包上传到虚拟机的 ~/
解压提取 tar zxvf jdk….tar.gz
将得到的jdk1.8…移动到/usr/local/中
mv jdk1.8…/ /usr/local/jdk
1.4配置环境变量
vi /etc/profile 在/etc/profile的最后添加如下内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d7aa3e728fa1e3dcae3550d975e03c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67c15d97471031d190c6ab4fdb74c084/" rel="bookmark">
			服务器虚拟化和桌面虚拟化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 服务器虚拟化和桌面虚拟化依托的都是KVM架构，两者的底层的东西是一样的，只不过是人为的将这个底层系统二次开发成不同的系统版本，有些功能做了限制，有些做了优化。这样的好处是，不同的场景可以使用不同的虚拟化系统，更好的满足客户的需求和发挥不同系统的优越性。
桌面虚拟化，主要应用在终端接入上，比如学生机房、培训教室、办公室，支持的操作系统也比较少，仅支持Windows系统的。
而服务器虚拟化，功能就比较强大，除支持Windows服务器系统外，还支持基于LInux内核的操作系统。另外，其不仅可以实现传统服务器的存储、运算功能，而且可以在其系统上，运行防火墙、VPN、交换机、路由器等网络设备，将传统的硬件通过虚拟化的方式实现其功能。实现，采购一套服务器虚拟化系统即可实现购买诸多硬件才能满足的需求。
服务器虚拟化同时还支持网络虚拟化（网络视图），服务器监控aCMP等等。
桌面虚拟化仅仅是为了实现虚拟化办公，虚拟我们日常办公电脑等。
服务器虚拟化的鼻祖是Vmware，主要把物理硬件虚拟成虚拟硬件，这样就可以在一台物理服务器上跑多个虚拟机，提高物理服务器的选用率。而且这些物理服务器和虚拟机之前可以进行漂移，就是vmotion，HA等功能。
桌面虚拟化的鼻祖是微软，我们经常用的RDP协议，共享桌面就是VDI的最高的雏形。但现在效果做的最好的是思杰。
总结：桌面虚拟化是基于服务器虚拟化的，桌面虚拟化通过特有的协议（如：RDP，ICA，Pcoip，Spice）去访问服务器上的虚拟机。这样就能代替普通PC的作用。
创作不易，谢谢支持，有钱的捧个钱场 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bc80e8a7962b567d9d188cdd503711b/" rel="bookmark">
			那些你不知道的 getClientRects()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.getClientRects()。是可以获取内联元素的内容有多少行 最近一个交互，在限定文字展现是5行，超过5行，则在后面添加。。。展开。如果没有展开二字，我们一般用css就能完成了。但是为了交互更人性化
text-overflow: -o-ellipsis-lastline; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 5; -webkit-box-orient: vertical; 来看看代码，是如何实现的,一定要弄一个默认的span来判断行数，得到5行嗯能显示什么文字。然后记录下来
let txtDom = this.$refs.textContainer; txtDom.innerHTML = originalTxt; //第一次全部渲染 let showtxtdom = originalTxt; let texLength = txtDom.getClientRects(); let h = getLength(texLength); let tl = 0; if (h &lt;= 5) { obj.unfoldFlag = false; } else { obj.unfoldFlag = true; } while (h &gt; 5) { var step = 1; if (/&lt;br\/&gt;$/.test(showtxtdom)) { //回退的时候，如果碰到换行要整体替换 step = 5; } showtxtdom = showtxtdom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bc80e8a7962b567d9d188cdd503711b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97cf735636e0daff1122928fd28b2153/" rel="bookmark">
			关于Epson喷墨打印机的记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		L系列机型打印输出有空白横纹或严重偏色，如何解决？(有运输锁) http://www.epson.com.cn/Apps/tech_support/faq/QA-content.aspx?ColumnId=30568&amp;ArticleId=11815&amp;pg=&amp;view=&amp;columnid2=30568 2、喷墨打印机，一个过去被定义为家用应用的产品，越来越多的出现在各种应用中。这当然得益于喷墨打印技术的日新月异，为我们在打印办公提供了更多的应用选择。不过，喷墨打印机的“固有弊端”始终没有得到很好的解决--喷头堵塞。
造成喷头堵塞的原因很多，例如很久没有打印，或者墨水杂质，或者喷头磨损等等。这里编辑整理了一些喷头堵塞的解决办法，希望可以帮助大家快速排除喷头堵塞故障。
一、喷墨打印机的墨头结构： 喷墨打印机的常见墨头结构主要有喷墨头和墨水盒一体机和分离式两种方式，一体机墨头结构在墨水盒墨水用尽后，墨头和墨水盒要一起更换，这样的结构相对结合 较为紧密，可靠性较高，但相对成本较高;分离式结构的墨头和墨水盒分离，墨水用尽后可单独更换墨水盒，一定程度上可以节省成本。
二、喷墨打印机“堵头”的形成：因打印头正常打印归位后密封不严或长时间放置，水份过度蒸发，导致墨粒干结在精细的打印头尖部，使墨水无法正常喷出;或者不同墨水之间相互混用，产生化学反应，通常表现为常出现断线、颜色缺失、字迹模糊甚而无法正常打印等故障。
三、喷墨打印机“堵头”的分类：大致可分为软性堵头、硬性堵头两大类。
(一)、软性堵头的修复：
1、软性堵头堵塞指的是因种种原因造成墨水在喷头上粘度变大所致的断线故障。有时只附着在出墨口喷嘴表面，一般蘸取原装墨水经多次清洗即可恢复。其优点是操作简单、快捷，无任何物理损害;缺点是使用成本较高，较浪费墨水。
2、使用打印机驱动程序的应用工具中打印头清洗功能清洗。其优点是操作简便、快捷;缺点是清洗效果不太理想。
注意事项：1、以上两种清洗方法一般不宜超过三次。打印机“堵头”不严重时，三次以内即应冲开。若三次仍冲不开，说明堵头较严重，清洗次数再多也不一定管用，且无谓浪漫很多昂贵的墨水，此时就应视具体情况作进一步处理;
3、因墨盒(如海绵体填充型)与打印头之间会产生“气阻”现象，会出现少量的不规则断线，此时不必反复清洗，放置一段时间后，重新开机即可正常使用;
4、切忌墨水混用。新购墨水不可急于往墨盒中添加。先用一洁净的一次性注射器吸入一些墨水在光亮的地方仔细观察，看墨水中有没有悬浮物，如有悬 浮物则不可混用。然后从使用的墨盒中吸入一点墨水和新购的墨水进行混合后静置24小时后再观察，看混合后的墨水有无化学反应，若产生了变化(如结晶等)则 说明两种墨水的兼容性不好，切忌混用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28bb42decff29899c14a54870b7004ed/" rel="bookmark">
			oracle------详解动态SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 为什么要用动态SQL 对于静态SQL大家可能都知道，每一个字段或表都是固定的，也就是说表提供给你了，让你执行DML操作，这就是静态SQL；
而如果表或条件都提供给你了，但是有很多，你无法确定哪个是你要的表或条件，这时就要用到动态SQL。
二 静态SQL和动态SQL区别 静态SQL：性能较高，不灵活
动态SQL：性能较差，比较灵活
三 创建动态SQL的几种方式 1 EXECUTE IMMEDIATE语句实现 适用条件：DDL语句、DCL语句、非查询的DML语句、单行查询的SELECT语句
语法：
EXECUTE IMMEDIATE dynamic_sql_string
[into define_variable_list]
[using bind_argument_list]
① 创建表t1，用的是DDL语句（create）
DECLARE tablename VARCHAR2(20) := 't1'; --表名 field1 VARCHAR2(20) :='id'; --字段id datatype1 VARCHAR2(20) :='number'; --字段id类型 field2 VARCHAR2(20) :='name'; --字段name datatype2 VARCHAR2(20) :='varchar(20)'; --字段name类型 str_sql VARCHAR2(500); --拼接SQL语句的字符串 BEGIN str_sql := 'create table '||' '||tablename||'('||field1 ||' '||datatype1||','||field2 ||' '||datatype2||')'; EXECUTE IMMEDIATE str_sql; END; ② 向t1表中插入数据，用的是DML语句（insert）
DECLARE v_id NUMBER; --输入序号； v_name VARCHAR(20); --输入姓名； str_sql VARCHAR2(500); --保存拼接的SQL语句 BEGIN v_id := '&amp;vid'; v_name := '&amp;name'; str_sql := 'insert into t1 values(:1,:2)'; --使用占位符代表变量 EXECUTE IMMEDIATE str_sql USING v_id,v_name; --使用变量替换SQL中的占位符,v_id替换:1,v_name替换:2 COMMIT; --执行完毕后直接提交 END; ③ 查询表中的数据有多少行，用的是单行查询的select语句
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28bb42decff29899c14a54870b7004ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1a85018ef3a2089dd27839d635c11c4/" rel="bookmark">
			Mission Planner 开发环境搭建 二次开发编译方法与问题解决   新手篇 vs2017
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个星期我用VS2017编译 Mission Planner ,编译出现各种错误，在网上找到了许多资料，发现都是年代比较久远，很多都是雷同，vs2010版本，VS 2013版本居多，经过几天终于编译通过了。如下图 ：版本号改了。
教程： 首先先观看官方教程
原官方教程链接为：http://ardupilot.org/dev/docs/buildin-mission-planner.html
Mission Planner源码地址为：https://github.com/ArduPilot/MissionPlanner
最新版Mission Planner上位机软件下载链接为：http://firmware.ardupilot.org/Tools/MissionPlanner/MissionPlanner-latest.msi
1.安装vs 2017,下载链接去官方下载地址https://visualstudio.microsoft.com/zh-hans/?rr=https%3A%2F%2Fwww.so.com%2Fs%3Fq%3Dvs2017%25E5%25AE%2598%25E7%25BD%2591%26psid%3D0fe86ef8d5d4467e982c7bf8f091bb3f%26src%3Dpdr_guide_2.30%26fr%3Dhao_360so_b 国外网站可能有点慢。
2.下载missplaner 源码 https://github.com/ArduPilot/MissionPlanner 。
3.官方说下载最新的上位机 ，我测试了不用下也可以 。
4.解压下载的源码，用VS 2017打开，如下图：
等待工程加载。会发现报许多错误，或者警告如下图
如果你出现上图说明 你系统是不支持的！最好用 win10 专业版 ，本来已经测试了 win7 ，win8 都不行，给开发者反馈，建议用win10 系统。
还要编译报错有两种：
一种是 Error CS0006 Metadata file 'D:\WIND\Documents\Visual Studio 2017\Projects\MissionPlanner\ExtLibs\Utilities\bin\Debug\netstandard2.0\MissionPlanner.Utilities.dll' could not be found MissionPlanner.Maps
另一种是 Error CS0103 The name 'SynthesizerState' does not exist in the current context MissionPlanner.Utilities(netstandard2.0) 上图这两个错误 解决办法在下图 打开VS 更新包 点击工具 -&gt;获取工具与功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1a85018ef3a2089dd27839d635c11c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b47dc871b9071fd133523798bd4fa4/" rel="bookmark">
			Deep Learning for Generic Object Detection: A Survey -- 目标检测综述总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，中国国防科技大学、芬兰奥卢大学、澳大利亚悉尼大学、中国香港中文大学和加拿大滑铁卢大学等人推出一篇最新目标检测综述，详细阐述了当前目标检测最新成就和关键技术。文章最后总结了未来8个比较有前景的方向，对学习目标检测的人员提供了很大的帮助，在此翻译这篇文章，方便阅读与理解。
此外，来自首尔国立大学的 Lee hoseong 在近期开源了「deep learning object detection」GitHub 项目，正是参考该论文开发的。该项目集合了从 2013 年 11 月提出的 R-CNN 至在近期举办的 ECCV2018 上发表的 RFBNet 等四十多篇关于目标检测的论文，相当全面。这些论文很多都曾发表在机器学习或人工智能顶会上，如 ICLR、NIPS、CVPR、ICCV、ECCV 等。正如图中红色字体标示的那样，其中也包含了很多代表性的成果，如从 R-CNN 到 Mask R-CNN 的 R-CNN 系列、YOLO 系列、RPN、SSD、FPN 以及 RetinaNet 等。无论对刚入门的机器学习新手，还是想深入研究目标检测的研究者，都是难得的学习、参考资源。不仅如此，项目作者还给出了相应的完整资源列表，包括论文、官方/非官方实现。下边就是GitHub的链接。
GitHub - hoya012/deep_learning_object_detection: A paper list of object detection using deep learning.
文章目录 摘要1.介绍1.1与之前目标检测方法相对比1.2 分类方法 2.背景2.1目标检测的问题2.2主要挑战2.2.1 有关精准度的挑战2.2.2 有关效率的挑战2.3 过去二十年取得的进展 3. 目标检测的结构3.1 Two Stage FrameworkRCNNSPPNetFast RCNNFaster RCNNRFCNMask RCNNLight Head RCNN 3.2 Unified Pipeline (One Stage Pipeline)DetectorNetOverFeatYOLOYOLOv2 and YOLO9000SSD 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37b47dc871b9071fd133523798bd4fa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4732154ef81bd002c5573674994bd560/" rel="bookmark">
			numpy数组与list之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		a=([3.234,34,3.777,6.33])
a为python的list类型
将a转化为numpy的array: np.array(a)
array([ 3.234, 34. , 3.777, 6.33 ])
将a转化为python的list a.tolist()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/892c50166c8ab15c9962fc44d492b781/" rel="bookmark">
			source Insight 常用配置&#43;Astyle自动缩进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、AStyle下载路径
Astyle为开源项目，支持C/C++和java的代码格式化 下载路径
https://download.csdn.net/download/caofengtao1314/10685905
下载最新Windows版本的AStyle，解压到你指定位置，笔者解压到D:\program files下的。
二、下面介绍如何在Source Insight中外挂和使用astyle,非常简单,只需三步就可完成.
第一步: 下载https://download.csdn.net/download/caofengtao1314/10685905下的AStyle.exe文件就是编译好的在windows平台的astyle的代码整理工具,请下载此文件并保存到Source Insight的安装目录:如在我的机器上是: C:\Program Files\Source Insight 3\
第二步:打开Source Insight，点击菜单栏的 Options-&gt;Custom Commands,如下图所示：
点击右上角的Add,在弹出的对话框中键入Format with astyle,然后点Ok,在Run栏对应的右边点Browser,找到AStyle.exe所在的目录,
选中AStyle.exe,点击”打开”.如下图所示:
在Run栏的路径后边输入如内容: --style=ansi -t %f 这是一些astyle的参数设置,--style=表示你所整理的代码是用何种语言写的.如果你要整理java,可写成--style=java. -t表示缩进是按Tab键来缩进的.如果不写-t参数,则默认按4个Space 缩进.这可按照您的风格或小组的编码规范来设置.而%f则是必需的,表示只整理当前文件(astyle可以整理一个目录下所有代码,现在我介绍的方法只针对文件),注意:每个参数之间用空格分开,输入完后如图所示:
第三步:将我们的Format with astyle命令加入Source Insight的菜单栏.点击上图所示框中右边的Menu,弹出如下图所示的框:
选中左栏的CustomCmd:Format with astyle,再点击右边Menu的下拉菜单,我这里选的是Edit,这可根据您的喜好和方便程度放在别的菜单下,然后选择放置的命令的位置,我这里选的是Edit菜单的最后一行放置.选好后点击右边的Insert,然后点击Run. Ok,世界简单了, Source Insight用起来更加得心应手.
另外如何添加快捷键，点击"Assigh New Key"，输入快捷键：Ctrl+Alt+C。以后格式化C/C++文件，就可以直接使用快捷键了。
参考文档 https://blog.csdn.net/gw_cs/article/details/7927735
source insight的常用配置
1.Options菜单“Preferences Typing”卡，
勾选Typing tab indents line，regardless of selection
作用：按Tab键整行缩进，空行按Tab键不起作用
勾掉 Typing tab replaces current selection
2.Options菜单“Document Options” “Editing Options”框中，
tab width=4，并且勾选Expand tabs
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/892c50166c8ab15c9962fc44d492b781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34ee369fc385bba86485d00c4a5cae4a/" rel="bookmark">
			Face&#43;&#43; 人脸识别系统 核心概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Face++ 人脸识别系统 核心概念 Face++ 人脸识别系统包含五个核心概念：Image, Face, Person, Faceset 和Group。这是在运用Face++ API时需要重点区分的。 Image 指用户或应用程序给Face++ API提供的图片，以供后续检测/识别使用。用户可以通过指定url或在程序中上传（通过HTTP POST提交图片的二进制文件）提供Image。
Face 指Image中检测出的人脸。一张Image中可能包含多个Face。
Person 指同一个人的Face集合。Person中的多个Face可能来源于多个Image，但必须是同一个人的多张Face。一个Face可以属于多个不同的Person。Person被用在人脸验证（verify）和人脸识别（identify）中。
Faceset 指一个或多个Face的集合。Faceset和Person一样，都是Face的集合，但Faceset并不要求Face来源于同一个人。一个Face可以属于多个不同的Person和Faceset。Faceset被用在人脸搜索（search）中。
Group 指多个Person的集合。在多数Face++人脸识别场景中，用户需指定一个Group来限定在此集合中进行识别。
ID和Name两套索引系统用来定位和访问上述所有元素， Image，Face，Person，Faceset 和 Group都有系统分配的全局唯一的ID。为便于用户使用有语义信息的名字进行开发，用户也可给Person 和 Group设置一个Name。Name由用户提供，必须在App内全局唯一。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/705c95c6194531b9e046f019d673149d/" rel="bookmark">
			一文看懂π型滤波电路原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		π型滤波器简介 π型滤波器包括两个电容器和一个电感器，它的输入和输出都呈低阻抗。π型滤波有RC和LC两种，
在输出电流不大的情况下用RC，R的取值不能太大，一般几个至几十欧姆，其优点是成本低。其缺点是电阻要消耗一些能量，效果不如LC电路。滤波电容取大一点效果也不错。
LC电路里有一个电感，根据输出电流大小和频率高低选择电感量的大小。其缺点是电感体积大，笨重，价格高。现在一般的电子线路的电源都是RC滤波。很少用LC滤波电路.
π型滤波电路原理图 滤波电路的作用就是去除不需要的谐波，在直流电源中就是减小电流的脉动，是电流更平滑。常用的有电容滤波电路（C），电感滤波电路（L），电容电感滤波电路（LC），电容电感π型滤波电路（LCπ型），这些都是常常用到电源电路中的。其他还有电子滤波电路等，常常用到复杂的精度高的脉冲电路中。
基本π型滤波滤波电路 实际上，在电源中差模干扰和共模干扰往往同时存在，因此，电源滤波电路一般指将共如图4所示。模和差模滤波结合起来，
Le为共模扼流圈，由于LC的两个线圈绕向一致，当电源输人电流流过LC时，所产生的磁场可以互相抵消，不会引起磁芯的饱和，因此，它使用导磁率高的磁芯。Le对共模噪声来说，相当于一个很大电感量的电感，故它能有效地抑制共模传导噪声。负载输入端分别对地并接的电容Cy对共模噪声起旁路作用。共模扼流圈两端并联的电容CX对差模噪声起抑制作用。R为CX的放电电阻，它是VDE-0806和IEC-380安全技术条件标准所推荐的。图中各元件的参数范围：Cx=0.1~2pF;Cy=22~33nF;Le=几~几十mH，随工作电流不同而取不同的参数值。如电流为25A时，Le=1，8mH;电流为0.3A;Le=47mH。扼流圈一般用高磁导率棒状磁芯材料，对于消除高频干扰效果很好，但对于大工作电流之情况，扼流圈的体积比较庞大，用以避免磁饱和。
典型π型RC滤波电路 图7-27所示是典型的兀型RC滤波电路。电路中的Cl、C2是两只滤波电容，Rl是滤波电阻，Cl、Rl和C2构成一节π型RC滤波电路。由于这种滤波电路的形式如同字母π且采用了电阻、电容，所以称为π型RC滤波电路。ADP3211AMNG从电路中可以看出，π型RC滤波电路接在整流电路的输出端。
这一电路的滤波原理是：从整流电路输出的电压首先经过Cl的滤波，将大部分的交流成分滤除，见图中的交流电流示意图。
经过Cl滤波后的电压，再加到由Rl和02构成的滤波电路中，电容C2进一步对交流成分进行滤波，有少量的交流电流通过C2到达地线，见图中的电流所示。
这一滤波电路中共有两个直流电压输出端，分别输出U01、U02两个直流电压。其中，U01只经过电容Cl滤波；U02则经过了Cl、Rl和C2电路的滤波，所以滤波效果更好，直流输出电压U02中的交流成分更小。
上述两个直流输出电压的大小是不同的，Uo1电压最高，一般这一电压直接加到功率放大器电路，或加到需要直流工作电压最高、工作电流最大的电路中，这是因为这一路直流输出电压没有经过滤波电阻，能够输出最大的直流电压和直流电流；直流输出电压U02稍低，这是因为电阻Rl对直流电压存在电压降，同时由于滤波电阻Rl的存在，这一滤波电路输出的直流电流大小也受到了一定的限制。
多节π型RC滤波电路 关于实用的滤波电路中通常都是多节的，即有几节π型RC滤波电路组成，各节π型RC滤波电路之间可以是串联连接，也可以是并联连接。多节π型RC滤波电路也是由滤波电容和滤波电阻构成。图7-29所示是多节π型RC滤波电路。电路中，Cl、C2、C3是三只滤波电容，其中Cl是第一节的滤波电容，C3是最后一节的滤波电容。Rl和R2是滤波电阻。
这一滤波电路的工作原理与上面的π型RC滤波电路基本相同，这里再说明下列几点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbd104405e7821441cc74d4d04dbbf06/" rel="bookmark">
			python爬虫----全国天气预报的获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次是通过全国天气预报的网站去抓取实时天气和预测未来24小时的天气，抓取的数据包括：地区的区号、地区名称、实时气温、湿度、风向、风力、预测的最高温和最低温、晚间风向、日间的风向和各自的风力大小，把这些数据存储到mysql的数据库当中，并利用pygal库来对数据进行可视化操作。
抓取的网页 通过分析可以看到一个数据的接口，可以获取全国的地区码，或者点击地图上的区域也能找到 http://forecast.weather.com.cn/napi/h5map/city/10113/jQuery1537792324377?callback=jQuery1537792324377，city后面的数字是要查询的地区码，只要知道地区码就可以获取到该地区的天气预报。
抓取网页的链接 http://www.weather.com.cn/static/html/weather.shtml
目标链接：
http://forecast.weather.com.cn/napi/h5map/city/101/jQuery1537791723170?callback=jQuery1537791723170
从该链接可以获取到所有地区的地区号和地区名称，参数jQuery1537791723170后面的数字1537791723170是当前的时间戳，可以通过本机的当前时间来替代，实现实时性。
http://forecast.weather.com.cn/napi/h5map/city/10113/jQuery1537792324377?callback=jQuery1537792324377
该链接是跟上面获取到的地区码去通过字符串的拼接得到新的url，再去抓取该地区的天气预报。
导包 import pymsql---数据库的操作
import requests---网页抓取
import re----正则表达式的使用
import json----数据格式的转换
import time----获取当前的时间
import pygal----数据可视化操作
网页抓取和解析 编写一个类来实现网页的抓取。
# coding:utf-8 import requests import re import json import time class WeatherSpider(): """docstring for WeatherSpider""" def __init__(self): self.headers={ 'Accept-Encoding':'gzip, deflate', 'Connection':'keep-alive', 'Cookie': 'vjuids=-9fcc3e115.165947a9a2a.0.48bc4b39849d4; UM_distinctid=165947a9ae1324-0ae8457e8abdee-47e1039-100200-165947a9ae219e; f_city=%E5%B9%BF%E5%B7%9E%7C101280101%7C; returnUrl=%2Fweb%2Fdashboard%2Fmobile%2Findex.do; vjlast=1535794387.1536491754.11; Hm_lvt_080dabacb001ad3dc8b9b9049b36d43b=1536491927,1536491942,1536492078,1536492148; Hm_lpvt_080dabacb001ad3dc8b9b9049b36d43b=1536492148; Wa_lvt_1=1536491927,1536491942,1536492079,1536492148; Wa_lpvt_1=1536492148', 'Host':'forecast.weather.com.cn', 'Upgrade-Insecure-Requests':'1', 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbd104405e7821441cc74d4d04dbbf06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c6e5d4f572a641b936e69981244a407/" rel="bookmark">
			Jquery和Js获得元素标签名称的方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、$( this ).get(0).tagName
2、$( this )[0].tagName
3、$( this ).prop("tagName")
4、$( this ).prop("nodeName")
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a6ac22873aed62bf51ba6d25fa0c7b/" rel="bookmark">
			C#异步委托
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大多数时候，我们写的代码都是同步代码，也就是从上到下按照顺序执行。但有时候遇到耗时较多的任务时，同步方法的弊端往往就会显现出来。例如下载一个较大的文件，如果采用同步代码，那么直到这个文件下载完成之前，我们都无法进行任何操作，这就带来了较差的用户体验。这种情况下就得异步方法出马了。在C#中，Delegate类包含Invoke和BeginInvoke两个方法，其中Invoke是同步的，而BeginInvoke则是异步的。先看一段代码：
using System; using System.Collections.Generic; using System.Linq; using System.Runtime.Remoting.Messaging; using System.Text; using System.Threading; using System.Threading.Tasks; namespace ConsoleApplication1 { public delegate void DoWorkHandler(); class Program { static void Main(string[] args) { Console.WriteLine("开始烧水了"); // 一直等到水烧开 DoWorkHandler handler = (() =&gt; { Thread.Sleep(5000); Console.WriteLine("水烧好了"); }); handler.Invoke(); // 在水未烧开之前一直会有阻塞 Console.WriteLine("扫一下地吧"); } } } 运行结果如下:
上面的代码描述的是一个烧水的过程，Thread.Sleep(5000)模拟一个耗时操作，例如把水烧开花了5秒钟。这时如果调用Invoke方法，由于Invoke是同步的，线程就会被阻塞，即：在水没有烧开之前我们无法进行其他任何操作。而一般情况下，我们习惯于在烧水的同时还做一些其他的事情，以此提高工作效率和时间利用率，例如在水没有烧开之前，我们可以扫扫地、做做饭之类的。如果要实现一边烧水一边做其他事情，那么就需要用到BeginInvoke方法。看下面一段代码：
using System; using System.Collections.Generic; using System.Linq; using System.Runtime.Remoting.Messaging; using System.Text; using System.Threading; using System.Threading.Tasks; namespace ConsoleApplication1 { public delegate void DoWorkHandler(); class Program { static void Main(string[] args) { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02a6ac22873aed62bf51ba6d25fa0c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6ce58f63dc0435a58db80041e557e2e/" rel="bookmark">
			oracle------分析函数和开窗函数over( )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 什么是分析函数 1 概念 分析函数是Oracle专门用于解决复杂报表统计需求的功能强大的函数，它可以在数据中进行分组然后计算基于组的某种统计值，并且每一组的每一行都可以返回一个统计值。
2 和聚合函数的区别 普通的聚合函数用group by分组，每个分组返回一个统计值，而分析函数采用partition by分组，并且每组每行都可以返回一个统计值。
3 开窗函数 开窗函数指定了函数所能影响的窗口范围，也就是说在这个窗口范围中都可以受到函数的影响，有些分析函数就是开窗函数。
4 分析函数语法 function_name (&lt;argument&gt;,&lt;argument&gt;...) -----1 over -----2 (&lt;Partition-Clause&gt; -----3 &lt;Order-by-Clause&gt; -----4 &lt;Windowing-Clause&gt;) -----5 语法解释： 1. function_name：对窗口中的数据进行操作，Oracle常用的分析函数有（这里就列举了一些常用的，其实有很多）
① 聚合函数
sum：一个组中数据累积和
min：一个组中数据最小值
max：一个组中数据最大值
avg：一个组中数据平均值
count：一个组中数据累积计数
② 排名函数
row_number( )：返回一个唯一的值，当碰到相同数据时，排名按照记录集中记录的顺序依次递增。
rank( )：返回一个唯一的值，当碰到相同的数据时，此时所有相同数据的排名是一样的，同时会在最后一条相同记录和下一条不同记录的排名之间空出排名。
dense_rank( )：返回一个唯一的值，当碰到相同数据时，此时所有相同数据的排名都是一样的，同时会在最后一条相同记录和下一条不同记录的排名之间紧邻递增。
2. over：关键字，用于标识分析函数
3. Partition-Clause：分区子句，根据分区表达式的条件逻辑将单个结果集分成N组
格式： partition by......　4. Order-by-Clause：排序子句，用于对分区中的数据进行排序
格式：order by......
5. Windowing-Clause：窗口子句，用于定义function在其上操作的行的集合，即function所影响的范围
格式：
order by 字段名 range|rows between 边界规则1 AND 边界规则2 边界规则的取值如下表所示：
可取值 说明 CURRENT ROW 当前行 N PRECEDING 前N行 UNBOUNDED PRECEDING 一直到第一条记录 N FOLLOWING 后N行 UNBOUNDED FOLLOWING 一直到最后一条记录 注意：RANGE表示按照值的范围进行范围的定义，而ROWS表示按照行的范围进行范围的定义 二 分析函数和开窗函数实例 1 创建表格并插入数据 --创建表格 create table student ( name varchar2(20), city varchar2(20), age int, salary int ) --插入数据 INSERT INTO student(name,city,age,salary) VALUES('Kebi','JiangSu',20,3000); INSERT INTO student(name,city,age,salary) VALUES('James','ChengDu',21,4000); INSERT INTO student(name,city,age,salary) VALUES('Denglun','BeiJing',22,3500); INSERT INTO student(name,city,age,salary) VALUES('Yangmi','London',21,2500); INSERT INTO student(name,city,age,salary) VALUES('Nana','NewYork',22,1000); INSERT INTO student(name,city,age,salary) VALUES('Sunli','BeiJing',20,3000); INSERT INTO student(name,city,age,salary) VALUES('Dengchao','London',22,1500); INSERT INTO student(name,city,age,salary) VALUES('Huge','JiangSu',20,2800); INSERT INTO student(name,city,age,salary) VALUES('Pengyuyan','BeiJing',24,4500); INSERT INTO student(name,city,age,salary) VALUES('Baoluo','London',25,8500); INSERT INTO student(name,city,age,salary) VALUES('Huting','ChengDu',25,3000); INSERT INTO student(name,city,age,salary) VALUES('Hurenxiang','JiangSu',23,2500); 表格创建完后，查看表格中的内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6ce58f63dc0435a58db80041e557e2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2edc0fc19caead3515c63a82a44fb49a/" rel="bookmark">
			实习生、应届生、三方协议、实习协议、劳动合同的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.应届生与实习生的区别
应届生——毕业的最后一年，而校园招聘会招聘的就是应届生，通常来的都是有实力的企业，通过网申、笔试、技术面试、hr面试等，你大概率就算是企业的人了，只要最后考核过了就算正式员工了，整个流程因企业不同，至少会有技术面试和hr面试。拿到校招的offer就相当于拿到初步的劳动合同书了。
实习生——在整个没有毕业期间，去企业都算实习生，有的企业最近项目较紧张，招聘实习生来干活，没有转正资格。其余企业想要为自己培养明年入职的员工，则提供优秀可转正政策，福利待遇会和正常员工一样，薪资则为实习生薪资，通过考核后成为正式员工。
二.实习协议、三方协议和劳动合同的区别
实习协议
实习期间学生并不能享受到工资、最低工资、工伤、社会保险等劳动法法定的保障，双方权利义务基本靠实习协议来自行约定，受教育法规及民事法规的保护。
三方协议
对单位、学校、个人都有很强的约束力，是正式的签约形式。
指向未来劳动合同，为保障劳动关系的建立可约定违约金，学生未到单位报到则应支付违约金并签署解约协议以便于下一次就业。
除非就业协议一方毁约，否则就业意向书或三方就业协议的归宿就是劳动合同。学生毕业后到单位报到，即可签署劳动合同，三方就业协议失效。
劳动合同
是指劳动者与用人单位建立劳动关系，明确双方权利义务关系的合同。
三.不同身份的福利待遇补助和薪资待遇区别
实习生：
毕业之前都为实习生，薪资为公司规定，并且福利待遇也由公司规定，有的公司会看你的表现调薪，或者优秀会提前转正。
试用期：
在成为正式员工之前，会有试用期，期间薪资最少为正式工资的80%，试用期法律规定不得超过6个月，签订一年合同试用期最多为两个月，两年四个月，三年六个月，如果之前拿到offer或者有实习又或表现优异，那么试用期时间看公司规定会有所减少。
祝各位找到心仪的工作！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcecdf759ca644bd3ce39a418811ea98/" rel="bookmark">
			人狠话不多，细说大牛直播SDK之RTMP播放器和RTSP播放器
    ...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大牛直播RTSP/RTMP播放器SDK特点： 在没测试过大牛直播SDK的RTMP和RTSP播放器之前，你甚至不相信行业内，RTMP和RTSP播放器（特别是RTMP播放器）延迟可以稳定的做到1秒以内。
无需赘述，全自研内核，行业内一致认可的跨平台RTSP/RTMP直播播放器SDK，功能齐全、高稳定、超低延迟、近200家公司明智之选。
功能支持： 如不单独说明，系Windows、Android、iOS全平台支持。
[支持播放协议]高稳定、超低延迟（一秒内，行业内几无效果接近的播放端）、业内首屈一指的RTMP/RTSP直播播放器SDK； [多实例播放]支持多实例播放（如同时播放多路RTMP/RTSP流）； [事件回调]支持网络状态、buffer状态等回调； [视频格式]支持RTSP H.265、RTMP扩展H.265，RTSP/RTMP H.264； [音频格式]RTMP/RTSP支持AAC/PCMA/PCMU，此外RTMP还支持Speex； [H.264/H.265软解码]支持H.264/H.265软解； [H.264硬解码]Android/iOS支持H.264硬解； [H.265硬解]Android支持H.265硬解； [H.264/H.265硬解码]Android支持设置Surface模式硬解和普通模式硬解码； [硬解码自适应]Android/iOS平台支持硬解码码自适应，如检测到硬解码不支持，自动切换到软解； [RTSP模式设置]支持RTSP TCP/UDP模式设置； [RTSP TCP/UDP自动切换]支持RTSP TCP、UDP模式自动切换； [RTSP超时设置]支持RTSP超时时间设置，单位：秒； [RTSP 401认证处理]支持上报RTSP 401事件，如URL携带鉴权信息，会自动处理； [缓冲时间设置]支持buffer time设置； [首屏秒开]支持首屏秒开模式； [低延迟模式]支持类似于线上娃娃机等直播方案的超低延迟模式设置(公网200~400ms)； [复杂网络处理]支持断网重连等各种网络环境自动适配； [快速切换URL]支持播放过程中，快速切换其他URL，内容切换更快； [音视频多种render机制]Android平台，视频：surfaceview/OpenGL ES，音频：AudioTrack/OpenSL ES； [实时静音]支持播放过程中，实时静音/取消静音； [实时快照]支持播放过程中截取当前播放画面； [渲染角度]支持0°，90°，180°和270°四个视频画面渲染角度设置； [渲染镜像]支持水平反转、垂直反转模式设置； [实时下载速度更新]支持当前下载速度实时回调(支持设置回调时间间隔)； [解码前视频数据回调]支持H.264/H.265数据回调； [解码后视频数据回调]支持解码后YUV/RGB数据回调； [解码前音频数据回调]支持AAC/PCMA/PCMU/SPEEX数据回调； [音视频自适应]支持播放过程中，音视频信息改变后自适应； [扩展录像功能]完美支持和录像SDK组合使用，录像相关功能，可参见"8. Windows/Android/iOS录像SDK"； [全屏]Windows平台双击画面进入全屏模式； [Windows本地FLV播放器]支持本地FLV文件播放(支持获取FLV文件的duration(时长)；支持显示当前播放位置； [Windows本地FLV播放器]支持开始播放或播放过程中seek(跳转播放位置)，也许是行业内seek最快的flv点播播放器)。 对应Demo：
Windows测试程序：SmartPlayer.exe； Windows C++工程：WIN-PlayerSDK-CPP-Demo； Windows C#工程：WIN-PlayerSDK-CSharp-Demo； Android工程：SmartPlayerV2； iOS工程：SmartiOSPlayerV2。 相关Demo下载：https://github.com/daniulive/SmarterStreaming/ 或 http://daniulive.com/index.php/sdk-demo%E4%B8%8B%E8%BD%BD/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e4a71dc20f998eed4dddb305d2b5ac0/" rel="bookmark">
			Linux 模拟网络丢包和延迟命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Ubuntu上使用 tc 和 netem命令组合模拟客户环境网络波动情况测试，如丢包和延迟,
1. 延迟设置 //延迟 300ms ± 100ms sudo tc qdisc add dev eth0 root netem delay 300ms 100ms sudo tc qdisc del dev eth0 root netem delay 300ms 100ms 2. 丢包 //丢包率 5% sudo tc qdisc add dev eth0 root netem loss 5% sudo tc qdisc del dev eth0 root netem loss 5% 3. 使用iptables设置丢包，对输入报文随机丢包50% iptables -I INPUT -s 121.14.48.1 -m statistic --mode random --probability 0.5 -j DROP 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/426/">«</a>
	<span class="pagination__item pagination__item--current">427/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/428/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>