<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbfc122260248fe4de05d63af62b259a/" rel="bookmark">
			基于diffusion扩散模型/GAN生成对抗方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、DreamBooth: Fine Tuning Text-to-Image Diffusion Models for Subject-Driven Generation 大型文本生成图像模型已取得显著进展，有能力从给定的文本提示中生成高质量和多样化的图像。然而，给定目标个体的一些参考图片（这里不妨称之为“主题”），这些模型还无法做到的是，在不同的上下文环境里去生成关于它们不同图片的能力。
DreamBooth是一种新的文本到图像扩散模型的“个性化”方法。给定一个主题的几张图像作为输入，对预训练的文本到图像模型进行微调，使其学会将一个唯一标识符（identifier）绑定到特定的主题。一旦主题被嵌入到模型的输出域中，唯一的标识符就可以用来生成不同场景下关于主题的新颖逼真图像。通过利用模型中嵌入的语义先验和一种类特定先验保留损失，能够在参考图像中没有出现的不同场景、姿势、视图和光照条件下合成主题。
在保留主题关键特征的同时，应用于主题重新背景化、文本引导的视图合成和艺术渲染等任务。此外，研究者还为这个新的主题驱动生成任务提供了一个新的数据集和评估协议。项目页面:https://dreambooth.github.io/
2、Ablating Concepts in Text-to-Image Diffusion Models 大规模的文本到图像扩散模型可以生成高保真图像。模型通常是根据大量互联网数据进行训练的，这些数据通常包含受版权保护的材料、许可图像和个人照片。此外，它们被发现可以复制各种艺术家的风格或记住准确的训练样本。如何在不从头开始重新训练模型的情况下删除此类受版权保护的概念或图像？
为了实现这一目标，提出了一种在预训练模型中消除概念的有效方法，即防止目标概念的生成。算法将希望消融的目标样式、实例或文本提示的图像分布与锚概念对应的分布相匹配。这可以防止模型在给定文本条件的情况下生成目标概念。大量实验表明，方法可以成功地防止消除概念的产生，同时在模型中保留密切相关的概念。
3、Multi-Concept Customization of Text-to-Image Diffusion 生成模型从大型数据库中学习到概念，但用户通常希望合成他们自己的概念（例如，他们的家人、宠物或物品）的实例。可以教一个模型快速获得一个新概念吗？可以将多个新概念组合在一起吗？
本文提出了 Custom Diffusion，一种增强现有文本到图像模型的有效方法。仅优化文本到图像调节机制中的几个参数就足以代表新概念，同时实现快速调整（∼ 6 分钟）。
此外，可以联合训练多个概念，或通过闭式约束优化将多个微调模型组合成一个。经过微调的模型生成多个新概念的变体，并将它们与新设置中的现有概念无缝组合。方法在定性和定量评估方面优于多个基线和并行工作，同时具有内存和计算效率。
4、Imagic: Text-Based Real Image Editing with Diffusion Models 以文本为条件的图像编辑最近引起了相当大的兴趣。然而，目前大多数方法要么仅限于特定的编辑类型（例如，目标融合叠加、风格迁移），要么适用于合成生成的图像，或者需要一个公共对象的多个输入图像。
本文首次展示了将复杂（例如，非刚性）文本引导语义编辑应用于单个真实图像的能力。例如，可以改变图像中一个或多个对象的姿势和构图，同时保留其原始特征。方法可以让站立的狗坐下或跳跃，让鸟张开翅膀等等——每一个都在用户提供的单个高分辨率自然图像中。
与以前的工作相反，提出的方法只需要一个输入图像和一个目标文本（所需的编辑）。使用真实图像，不需要任何额外的输入（例如图像掩码或对象的额外视图）。方法称之为“Imagic”，利用预训练的文本到图像扩散模型来完成这项任务。它生成与输入图像和目标文本对齐的文本嵌入，同时微调扩散模型以捕获特定于图像的外观。
在来自不同领域的大量输入上展示了方法的质量和多功能性，展示了大量高质量的复杂语义图像编辑。
https://imagic-editing.github.io/
5、Shifted Diffusion for Text-to-image Generation 本文提出了一种新的文本到图像生成方法Corgi。Corgi基于本文出的shifted扩散模型，从输入文本中实现了更好的图像特征嵌入生成。与在DALL-E 2中使用的基线扩散模型不同，方法通过设计新的初始化分布和新的扩散步骤，无缝地编码预训练的CLIP模型在扩散过程中的先验知识。
与强DALL-E 2基线相比，方法在从文本生成图像嵌入方面的效率和有效性都更好，从而获得更好的文本到图像生成。进行了大量的大规模实验，从定量测量和人工评价两方面进行了评价，表明方法比现有方法具有更强的生成能力。
此外，模型支持半监督和无语言的文本到图像生成训练，其中训练数据集中只有部分或没有图像具有相关的文本描述。半监督模型在只有1.7%的图像被配上文本的情况下进行训练，在MS-COCO上评估零镜头文本到图像生成时，得到的FID结果与DALL-E 2相当。Corgi还在下游无语言文本到图像生成任务的不同数据集上获得了最新的结果，大大超过了之前的Lafite方法。
6、SpaText: Spatio-Textual Representation for Controllable Image Generation 最近的文本到图像扩散模型能够以前所未有的质量生成令人信服的结果。然而，当前方法无法以精细控制不同区域/对象的形状或它们的布局。以前提供此类的尝试，却因依赖标签而有所受限制。
为此，本文提出了 SpaText，一种使用开放式词汇场景控制、进行文本到图像生成的新方法。除了描述整个场景的全局文本外，用户还提供了一个分割图，其中每个感兴趣的区域都用自由形式的自然语言描述进行了注释。由于缺乏对图像中每个区域进行详细文本描述的大规模数据集，选择利用当前的大规模文本到图像数据集，并将方法基于一种新的基于 CLIP 的空间文本表示，并展示其在两种最先进的扩散模型上的有效性：基于像素和基于潜在。
此外，展示了如何将扩散模型中的无分类器指导方法扩展到多条件情况，并提出了一种替代加速推理算法。最后，除了 FID 分数和用户研究之外，还提供了几个自动评估指标并评估方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbfc122260248fe4de05d63af62b259a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57caa4649209118cbeef0f1933396fb1/" rel="bookmark">
			elementUI中使用tooltip遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 elementUI中使用tooltip遇到的坑 1、button添加属性disabled，造成el-tooltip失效 1、button添加属性disabled，造成el-tooltip失效 当鼠标移入的时候，通过tootip显示提示内容，但是发现移入进去发现失效，并没有显示提示信息，示例代码如下：
&lt;el-tooltip content="Top center" placement="top"&gt; &lt;el-button disabled&gt;Dark&lt;/el-button&gt; &lt;/el-tooltip&gt; 网上查阅后，按钮的disabled属性影响tooltip 的使用
按理来说disabled属性写在el-tooltip上会影响其可用性，但是万万没想到写在button上的disabled属性也会造成影响…
解决办法
在el-button外边嵌套了一个div，这样子操作能避免了el-button的disabled属性对el-tooltip显示的影响。
&lt;el-tooltip content="Top center" placement="top"&gt; &lt;div&gt; &lt;el-button disabled&gt;Dark&lt;/el-button&gt; &lt;/div&gt; &lt;/el-tooltip&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f063e59a40f87b84989648ad50b6dd3f/" rel="bookmark">
			LINUX——安装虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装需求二、安装虚拟机1、新建虚拟机2、选择类型3、选择稍后安装操作系统4、选择操作系统、版本5、选择虚拟机的存放路径6、指定磁盘容量7、配置完成 三、修改配置1、点击编辑虚拟设备2、修改内存大小3、根据需求可修改处理器大小4、设置ISO镜像5、开启虚拟机6、选择语言7、选择桌面8、选择安装位置，点击自动分区9、开始安装10、设置密码11、创建用户12、完成后重启13、打开 四、添加终端 一、安装需求 1、需要ios镜像
CentOS-7-x86_64-DVD-1708
2、vmware 版本
安装的是VMware16Pro版本
二、安装虚拟机 1、新建虚拟机 或者
2、选择类型 3、选择稍后安装操作系统 4、选择操作系统、版本 5、选择虚拟机的存放路径 6、指定磁盘容量 7、配置完成 三、修改配置 1、点击编辑虚拟设备 2、修改内存大小 3、根据需求可修改处理器大小 4、设置ISO镜像 5、开启虚拟机 回车
6、选择语言 7、选择桌面 8、选择安装位置，点击自动分区 9、开始安装 10、设置密码 11、创建用户 12、完成后重启 13、打开 一直跳过
四、添加终端 右击选择打开终端
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/936d1cf316702800a753c64ee560c373/" rel="bookmark">
			万能芯片 — FPGA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是FPGA芯片 集成电路芯片包括数字芯片和模拟芯片两大类，数字芯片可以分为存储器芯片和逻辑芯片，我们熟知的逻辑芯片一般包括CPU、GPU、DSP等通用处理器芯片，以及专用集成电路芯片ASIC。FPGA（现场可编程门阵列，FieldProgrammableGateArray）也是逻辑芯片的一种。
FPGA是在PAL(可编程逻辑阵列)、GAL(通用阵列逻辑)、CPLD(复杂可编程逻辑器件)等传统逻辑电路和门阵列的基础上进一步发展的产物。它利用计算机辅助设计，绘制出实现用户要求的原理图、编辑布尔方程或用硬件描述语言等方式作为设计输入；然后经一系列转换程序、自动布局布线、模拟仿真的过程；最后生成FPGA的数据文件，对FPGA器件初始化。这样就实现了满足用户要求的专用集成电路，真正达到了用户自行设计、自行研制和自行生产集成电路的目的。
FPGA与CPU、GPU、ASIC等芯片的核心区别是：其底层逻辑运算单元的连线和逻辑布局未固化。用户可通过EDA软件对逻辑单元和开关阵列编程，进行功能配置，从而去实现特定功能的集成电路芯片。而其他类别逻辑芯片，像ASIC、CPU和GPU等，物理底层逻辑单元的运算关系均已固定且不可变。简单地说，如果CPU、GPU、ASIC等是像建好的楼房，楼房中房间、走廊及楼梯等格局是已经固定了；而FPGA的内部类似霍格沃兹中的魔法楼梯，可以随时改变房间到房间的路线关系。
FPGA由可编程逻辑块（CLB）、输入/输出模块（IOB）、可编程互连资源（PIR）等三种可编程电路和用于存放编程数据的静态存储器SRAM组成。CLB是实现逻辑功能的基本单元，它们通常规则排列成一个阵列，散布于整个芯片中。IOB主要完成芯片上的逻辑与外部引脚的接口，通常排列在芯片的四周。PIR提供了丰富的连线资源，包括纵横网状连线、可编程开关矩阵和可编程连接点等，它们将各个CLB之间、CLB与IOB之间以及IOB之间连接起来，构成特定功能的电路。静态存储器SRAM用于存放内部IOB、CLB和PIR的编程数据，并形成对IOB、CLB及PIR的控制，从而完成系统逻辑功能。
由于FPGA需要被反复烧写，它实现的组合逻辑基本结构无法通过固定的与非门来完成，而只能采用一种易于反复配置的结构。查找表（Look-Up-Table，简称为LUT）可以很好地满足这一要求。
LUT实质上是一个RAM，当用户描述了一个逻辑电路后，软件会计算所有可能的结果，并写入RAM。每一个信号进行逻辑运算，就等于输入一个地址进行查表，找出地址对应的内容，输出结果。这样也大大加快了FPGA的运算速度。目前主流FPGA都采用了基于SRAM工艺的查找表结构，也有一些FPGA采用Flash或反熔丝工艺的查找表结构。
01概要 FPGA中文名是现场可编程门阵列，是指一切通过软件手段更改、配置期间内部连接结构和逻辑单元，完成既定设计功能的数字集成电路。
FPGA属于逻辑芯片，区别于其他逻辑芯片，FPGA最大的特点便是现场可编程性，这个特点，可以使FPGA通过编程实现任意芯片的逻辑功能，例如ASIC、DSP甚至PC处理器等，这也是为什么FPGA被成为“万能芯片”的原因。
举个简单的例子，逻辑芯片中，例如ASIC和DSP等于一张出厂时就写有数据且不可擦除的CD，用户只需要放在CD播放器就可以听到音乐；而FPGA使一张出厂时空白的CD，需要用户自己使用刻录机烧写数据内容到盘里，并且还可以擦除上面的数据，反复刻录。
02 FPGA的特点 FPGA有三大特点，其中一个便是上面所讲的可编程灵活性高，另外两个特点是开发周期短和并行计算效率高。
（1）开发周期短
在逻辑芯片里面，如ASIC制造流程包括逻辑实现、布线处理和流片等多个步骤；而FPGA无需布线、掩膜和定制流片等，芯片开发大大简化。一般逻辑芯片，如ASIC、DSP、SOC等，开发周期需要14-24个月，甚至更长，而FPGA则只需要6-12个月，比其他芯片开发周期减少55%的时间。
正如全球FPGA第一大厂商Xilinx认为，更快比更便宜重要，产品晚上市6个月，5年内将减少33%的利润，每晚四周等于损失14%的市场份额。
（2）并行计算效率高
FPGA属于并行计算，也即一次可执行多个指令算法。而传统的ASIC、DSP、CPU都是串行计算，一次只能处理一个指令集。因此在部分特殊任务中，FPGA的并行计算效率比串行计算效率更高。
03 应用场景 FPGA由于具备可编程灵活性高、开发周期短以及并行计算效率高的特点，使得FPGA的应用场景特别地广泛。
FPGA可应用于包括网络通信、消费电子、数据中心、汽车电子、人工智能等领域。在国内FPGA主要应用于通讯领域和工业领域，2020年通讯领域和工业领域占FPGA使用量的41.3%和31.5%。
根据Frost&amp;Sullivan数据，中国FPGA市场2020年的市场规模约150.3亿元，预计2025年中国FPGA市场规模将达到332.2亿元，复合增速为17.2%。
（1）通讯领域
通讯领域是FPGA芯片的主要应用市场之一，Frost&amp;Sullivan数据显示2020年应用于该领域的FPGA芯片中国销售额将达到62.1亿元，占中国FPGA芯片市场份额的41.3%，2021年至2025年年复合增长率将达17.5%。
FPGA芯片目前被大量应用在无线通信和有限通信设备中，实现接口扩展、逻辑控制、数据处理、单芯片系统等各种功能。
在有线通信领域，FPGA芯片被应用于数据接入、传送、路由器、交换机的多种电路板中，以实现信号控制、传输加速等各种功能。
在无线通信领域，FPGA芯片被应用在无线通信基站和射频处理单元的多种电路板中以实现通信协议的各种功能和未来升级需求，集成CPU的现场可编程系统级芯片产品被应用在室外微基站、室内微基站等无线网络通信中，以单芯片完成商业、住宅、工厂区域的多模覆盖、网络容量增加、人工智能计算等多样性功能需求。
在网络通信领域，FPGA芯片得到大规模运用主要是由于其具有高度的灵活性、极强的实时处理和并行处理能力，大大加强了通信设备的处理能力。
（2）工业领域
工业领域是FPGA芯片的主要应用市场之一，Frost&amp;Sullivan数据显示2020年应用于该领域的FPGA芯片中国销售额将达到47.4亿元，占中国FPGA芯片市场份额的31.5%，2021年至2025年年复合增长率将达16.1%。
FPGA在工业领域主要应用于视频处理、图像处理、数控机床等领域实现信号控制和运算加速功能。随着智能化与自动化技术的发展，工业领域也正逐渐从以人力资源微核心要素转向以自动化微核心要素的智能化无人工厂。
受益于工业智能化、无人化的发展趋势，FPGA芯片高效能、实时性、高灵活性的特点使其在工业领域得到了广泛应用，以数控机床的伺服系统为例，相较传统的只能控制单一马达的专用芯片，FPGA芯片可以做到多通道的马达控制。
（3）数据中心
数据中心是FPGA芯片的新兴应用市场之一，Frost&amp;Sullivan数据显示2020年应用于该领域的FPGA芯片中国销售额将达到16.1亿元，占中国FPGA芯片市场份额的10.7%，2021年至2025年年复合增长率将达16.6%。
数据中心是全球协作的特定设备网络，用来在网络基础设施上传递、加速、展示、计算、存储数据信息。服务器和存储器作为数据中心的通用基础设备，为了应对复杂多变的应用情景，需要FPGA芯片实现逻辑控制、数据转换、功能扩展、系统升级等功能。
在数据中心运算处理领域，相比于CPU，FPGA芯片由于其无指令、无需共享内存的体系结构，能够同时提供强大的计算能力和足够的灵活性；相比GPU，FPGA芯片在数据中心具有低延迟及高吞吐的优势；相比ASIC，FPGA芯片在性能、灵活性、同构性、成本和功耗等五个方面可以达到出色的平衡。
FPGA芯片在数据中心领域主要用于硬件加速，数据中心使用FPGA芯片代替传统的CPU方案后，处理其自定义算法时可实现显著的加速效果。因此从2016年开始，微软Azure、亚马逊AWS、阿里云的服务器上都开始部署FPGA加速器用于运算加速。在云计算大面积应用的背景下，未来数据中心对芯片性能的要求将进一步提高，更多数据中心将采纳FPGA芯片方案，这将提高FPGA芯片在数据中心芯片中的价值占比。
（4）汽车电子
汽车的智能化打开了FPGA增量空间，Frost&amp;Sullivan数据显示2020年应用于该领域的FPGA芯片中国销售额将达到9.5亿元，2021年至2025年年复合增长率将达22.7%。
在汽车智能化发展的趋势下，FPGA可用于控制和驱动电动汽车电机控制系统，连接驾驶系统、仪表盘、雷达、超声波传感器等各种车载设备，实现激光雷达、毫米波雷达等信号处理和控制。
在视频桥接和融合领域，FPGA可用于实现多个图像传感器的信号桥接、3D环视视频融合、倒车辅助视频、辅助驾驶视频等功能。
在辅助驾驶和自动驾驶领域，FPGA可用于实现机器视觉与目标检测等各种功能。相比较其他通用芯片方案，FPGA在辅助驾驶的视频分析功能中可采用超低延时精确算法对来自车辆摄像机的实时视频输入信号进行分析，及时做出判断，并且FOGA可以在不进行重新设计的前提下实现重新编程，以适应不断发展的算法，从而缩短整体方案的开发周期。
（5）人工智能
Frost&amp;Sullivan数据显示2020年应用于该领域的FPGA芯片中国销售额将达到5.8亿元，2021年至2025年年复合增长率将达16.9%。
人工智能算法芯片实现分为云侧处理和端侧处理。在云侧处理时，和GPU及ASIC芯片相比，FPGA芯片内在并行处理单元达到百万级，可以做到真正并行运算，其可编程性又可实现灵活搭建数据处理流水线，因此运算速度快，数据访问延迟低，较为适合人工智能的实时决策需求。
在端侧处理领域，FPGA芯片可实现快速推断决策，另外其具有的现场可编程、可实现定制功能、高吞吐量和低延迟等特点有效地满足了用户对各种神经网络设计的要求，成为适配各种经过压缩优化的神经网络部署和升级的理想选择。
04 国外巨头主导国内FPGA市场，国内厂商逐步替代中低端市场 FPGA芯片国外起步较早，技术积累深厚，高度垄断市场。根据Frost&amp;Sullivan的统计数据，以出货量为口径，2019年中国FPGA芯片市场有超80%的份额被外商占据，前三名供应商为赛灵思、英特尔和莱蒂斯，出货量占比36.6%、25.3%和23.2%，国产厂商安路科技排在第四位，占比仅6%。若以销售额口径统计，市场呈现双寡头形式，2019年赛灵思和英特尔两家的合计占有率达91.1%，安路科技排名第四，占比0.9%，在国产厂商中排名第一。
目前国内有安路科技、紫光同创、复旦微电、高云半导体、京微齐力等厂商进入FPGA行业，近年来由于美国对中国半导体的限制日益趋严，FPGA国产替代迫切需求叠加国产FPGA厂商产品快速迭代和品类扩张，目前面向500K以下容量和非先进制程市场，国内厂商已逐步实现国产替代。
100K以下和100K-500K逻辑容量的FPGA需求量大，是国内FPGA龙头厂商国产替代的主要市场。根据Frost&amp;Sullivan的数据，2019年100K以下逻辑容量的FPGA芯片中国市场份额为38.2%，100K-500K逻辑容量的FPGA芯片市场份额为31.7%，500K-1KK和&gt;1KK分别占比24.4%和5.7%。从逻辑容量来看，100K以下和100K-500K逻辑容量的FPGA芯片是中国市场需求量最大的部分，国内厂商安路科技和紫光同创目前均已覆盖，是FPGA国产替代的主要市场。
28nm以上制程占大部分市场份额，是FPGA国产替代的重要方向。从工艺制程来看，由于28nm-90nm制程FPGA在性价比和良品率方面具有优势，占据了主要的市场地位。根据Frost&amp;Sullivan的数据，2019年28nm-90nm制程的FPGA占中国市场份额为63.3%，28nm以下制程的FPGA芯片占据20.9%的市场份额，&gt;90nm制程的FPGA占比15.8%。由于中国在先进制程制造方面受到限制，28nm以上制程也是FPGA国产替代的重要方向。
05 总结 FPGA又被成为“万能芯片“，可以应用于多个行业中，根据Frost&amp;Sullivan数据，中国FPGA市场2020年的市场规模约150.3亿元，预计2025年中国FPGA市场规模将达到332.2亿元，复合增速为17.2%。
目前国内FPGA市场仍被国外巨头垄断，但在500K以下容量和非先进制程占主要市场份额的中国来说，目前国内厂商的产品已逐步覆盖到这些领域，国内厂商获得了较好的发展机遇。
本文来源：e-works，红林财富
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb4c1cac1bc34cde56d69667a89192bd/" rel="bookmark">
			SD- prompt辑录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成原理
语法结构
1.前缀
写实风:masterpiece,CG,illustration,highres,8k,wallpaper,original
效果器:shadow,volume lighting,ray tracing,cinematic lighting, dramatic angle,dynamic veiw,professional light,soft light
2.主体 注：权重范围0.4-1.6
人物细节:1girl,angel face,slim body,cute,beautiful eyes,long hair, full body,claviculate
定制服装:yoga pants,shirt,sports bra
3.场景
4.反向词
Negative prompt:
(((ugly))),(((duplicate))),((morbid)),((mutilated)),(((tranny))),(((trans))),
(((trannsexual))),(((mutation))),(((deformed))),(((long neck))),((bad anatomy)),
(((bad proportions))),(((extra arms))),(((extra legs))),(((disfigured))),
(((more than 2 nipples))),malformed,mutated,(hermaphrodite),
((extra limbs)),((missing arms)),((missing legs)),((poorly drawn hands)),
((poorty drawn face)),(mutation,poorly drawn 1.2),(long body 1.3),
multiple breasts,cloned face,gross proportions,mutated hands,bad hands,
bad feet,long neck,missing limb,(malformed limbs),malformed hands,
(fused fingers),(too many fingers),extra fingers,missing fingers,extra digit,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb4c1cac1bc34cde56d69667a89192bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd14ca6d239cf298538e7c70c1c8fcd/" rel="bookmark">
			Android 监听返回事件 /onBackPressed 失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在高版本的api中onBackPressed 失效了
替代方案 在onCreate 中 新增一个监听
onBackPressedDispatcher.addCallback(object : OnBackPressedCallback(true) { override fun handleOnBackPressed() { viewModel.reviewSetEnd() finish() } }) 这样便可以监听到了返回事件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e34bdbd0c568284a65243129bc556f6/" rel="bookmark">
			csv文件的读与写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 csv文件的写：
with open("1.csv","w",encoding="utf-8",newline="") as file: f=csv.writer(file) con=["1","2","3"] f.writerow(con) tes=[("a","b","c"),("d","e","f"),("g","h","j"),("a","b","d"),("a","d","c"),("a","b","d"),("c","d","c")] f.writerows(tes) 写是一行一行的写入，写入表头直接用列表["1","2","3"],代表第一行的1，2，3列分别是1，2，3
写入表格内容格式为[(第二行内容)，（第三行内容），（第四行内容）......],元组里面的格式对应表头的列，第一个元素对应第一列，第二个元素对应第二列..
csv文件的读：
with open("xiaoshuo.csv.csv","r",encoding="utf-8") as file: bb=csv.reader(file) for i in bb: print(i) //此时出来的i格式为: ['1', '2', '3']，是一行一行获取的，要想得到某一列，假设第二 ['a', 'b', 'c'] 列是i[1] ['d', 'e', 'f'] ['g', 'h', 'j'] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed7aa14a880b31788d6ac3a09e54c9c2/" rel="bookmark">
			人脸识别-Java实现刷脸登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人脸识别 一、相关概念 人脸人脸库人脸特征标识（face_token）并发 (QPS)API KeyAPI Secretconfidencethresholds人脸比对/人脸搜索（控制台分析） 人脸检测人脸搜索人脸对比 二、Web API face++里注册账号 创建API Key postman调用API接口 人脸检测人脸对比 使用face_token参数进行对比 人脸搜索创建人脸库添加人脸获取人脸信息：删除人脸 三、刷脸登录 代码 一、相关概念 人脸 人脸（Face）在人脸识别技术中特指图像中发现的人脸，当对一张图片进行人脸检测时，会将检测到的人脸记录下来，包括人脸在图片中的位置，用一个系统标识 face_token 来表示。注意：对同一张图片进行多次人脸检测，对同一个人脸会得到不同的 face_token。
人脸库 人脸库（FaceSet）是用来存储检测到人脸的存储对象。一个 FaceSet 内的 face_token 是不重复的。
人脸特征标识（face_token） Face_token 是系统为人脸分配的唯一标识。当对一张图片进行人脸检测后，检测到的人脸以及人脸在图片中的位置会用一个用一个人脸特征标识 face_token 来表示。在进行人脸比对或人脸关键点检测时必须指定 face_token。针对同一张图片进行多次人脸检测，同一个人脸会得到不同的人脸特征标识 (face_token) 。 并发 (QPS) 并发 (QPS) 指每秒可以发起的 API 请求次数。调用同一个功能模块下的各个 API ，会统一计算 QPS。例如人脸识别并发 (QPS) 为 10 个，人脸识别包括人脸检测 API、人脸比对 API、人脸搜索API、人脸库管理 API 组、获取人脸信息 API 和自定义人脸信息 API，则每秒可以发起 10 次 API 调用请求，不限制具体调用了哪一个 API。超过 10 次请求，将返回 403 并发超限错误码 (CONCURRENCY_LIMIT_EXCEEDED)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed7aa14a880b31788d6ac3a09e54c9c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4092d60f9c6de8e72d5bb11ca0ad9c2e/" rel="bookmark">
			python爬取视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import urllib.request import requests from bs4 import BeautifulSoup from urllib import request html=urllib.request.urlopen("https://www.audibrand.cn/") data=html.read() datas=BeautifulSoup(data,"html.parser")//将获得的页面以html树型的方式呈现，而不是挤在一行，并且如果没有这条语句，使用find()函数会报错 # print(datas) a=datas.find("video",attrs={"class":"video-player mobile-video embeded-video"}) # print(a) b=a.find("source") c=b.get("src") # print(c) urls="https://www.audibrand.cn/"+c urllib.request.urlretrieve(urls,"shiping/1.mp4")//视频的爬取与下载与图片类似，但是要把后缀换成.mp4 # print(b) # print(b) 代码如上，与图片爬取类似，但是需要修改后缀名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6cc6b31cb63b1f94a14bcc998856098/" rel="bookmark">
			python爬虫爬取王者英雄图片，图片对应名字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下
import urllib.request import requests from urllib import request from bs4 import BeautifulSoup URL="https://pvp.qq.com/web201605/herolist.shtml" header={"user-agent":"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36 Edg/112.0.1722.48"} resp=requests.get(url=URL,headers=header) # print(resp) data=BeautifulSoup(resp.content,"html.parser") a=data.find("div",attrs={"class":"herolist-content"}) b=a.find_all("img") for i in b: picture=i.get("src") # print(i) picture_url="https:"+picture//补全图片下载信息 name=i.get("alt") urllib.request.urlretrieve(picture_url,"yixiong/{}.jpg".format(name))//使用urlretrieve下载，并将名字命名 print("{} is ok ".format(name)) # print(name) # print(picture_url) # print(b) # print(data) 运行结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c2b1791d9bdecdc179ba53cfcde3ad/" rel="bookmark">
			利用selenium爬取京东男士衣服
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import time from selenium import webdriver #获取属性 # wd.find_element().get_attribute() #获取文本也是.text #关闭弹窗 # wd.close() # time.sleep(5) # 创建驱动 # #wd.save_screenshot()截屏 # wd.execute_script() # wd.find_elements() wd=webdriver.Chrome(r"C:\Users\caixi\Downloads\chromedriver_win32\chromedriver.exe")//获取chrome的版本信息，通过设置找到版本 # 爬取网站 wd.get("https://www.jd.com/") # 放大窗口 wd.maximize_window() wd.find_element_by_css_selector("#key").send_keys("男士衣服") #点击搜索 wd.find_element_by_css_selector("#search &gt; div &gt; div.form &gt; button").click() # 滑动 wd.execute_script("window.scrollTo(0,document.body.scrollHeight);") li_all=wd.find_elements_by_css_selector("#J_goodsList &gt; ul &gt; li") for i in li_all: price=i.find_element_by_css_selector("div &gt; div.p-price &gt; strong &gt; i").text print(price) name=i.find_element_by_css_selector("div &gt; div.p-shop &gt; span &gt; a").get_attribute("title") print(name) # 直到不能翻页 翻到最后一页 不能翻 wd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71c2b1791d9bdecdc179ba53cfcde3ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2607ed607e534c9cecf0425cc0ad2b49/" rel="bookmark">
			【Idea】人工智能编程他来了，Idea集成一款和ChatGPT一样智能的编码辅助神器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介官方介绍功能介绍 注册使用使用方法功能说明 结尾 简介 Bito是一款建立在OpenAI和ChatGPT之上的开发辅助神器！他可以帮我们生成代码、语法提示、生成测试用例、解释代码含义、生成注释、优化代码、检测代码安全性以及学习理论知识等！我们可以提出任何关于技术的问题，Bito都能够给你很好分反馈，以及代码优化建议！最重要的是，没有注册限制，不用国外手机号，只需要你提供一个邮箱即可完成注册！快来卷死你的同事吧！
官方介绍 有了建立在OpenAI和ChatGPT之上的Bito，你将能够在你的IDE和CLI中获得最先进的AI。 想象一下，你可以在几秒钟内生成高质量的代码，将重复性任务自动化，并通过机器学习探索新的可能性。Bito就像一把瑞士军团的开发刀，可以释放你的全部潜力，给你成功所需的竞争优势。
官网地址：https://docs.bito.ai/
功能介绍 生成代码(Generate Code)：要求 Bito 使用自然语言提示生成任何语言的代码。 （例如，编写 Java 函数将数字从一种基数转换为另一种基数）命令语法(Command Syntax): 询问任何技术命令的语法。(例如，“如何为git设置全局变量？”)测试用例(Test Cases)：为代码生成测试用例。解释代码(Explain Code)：解释所选代码。询问这段代码是如何工作的或者它做了什么。注释方法(Comment Method)：为要添加到代码中的函数或方法生成注释。提高性能(Improve Performance)：询问如何提高给定代码的性能。检查安全性(Check Security)：询问所选代码是否存在任何已知的安全问题。学习技术概念(Learn Technical Concepts)：提出有关任何技术概念的问题（例如，解释 B+ 树、解释银行家算法） 注册 打开idea设置界面，找到插件，在插件市场搜索bito，选择安装（我这里安装过了，没安装按钮）。
安装完成后无需重启，关闭设置界面，查看我们idea编辑器右侧栏，找到Bito，点击打开Bito界面
点击后，输入我们邮箱
输入邮箱接收到的验证码，Submit
这里我们如果是要加入工作组后进行使用，一般为同一个组织加入一个工作组，我们直接拉到最后
找到Create Workspace进行注册一个我们自己的工作组
填写我们工作组的名称，然后点击Next
这里我们可以邀请我们需要加入用一个组织的人的邮箱，也可以直接跳过
完成后，我们就可以使用了
使用 使用方法 选中我们要操作的代码，右击，选择Bito AI，我们也可以直接按照上面的快捷键进行快速操作
我们也可以直接在Bito界面输入我们得问题，然后点击小飞机发送
功能说明 功能快捷键说明Explain CodeAlt + Shift + E解释选中代码含义以及作用Generate CommentAlt + Shift + V为生成注释，解释参数和输出Performance CheckAlt + Shift + Q代码性能优化提示Security CheckAlt + Shift + Z检测选中代码是否存在潜在安全问题Style CheckAlt + Shift + U检测选中代码格式规范Improve Readability提高选中代码可读性Clean Code整洁代码，去除代码中的debug和log等Generate unit tests为选中方法生成单元测试 官网示例：https://docs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2607ed607e534c9cecf0425cc0ad2b49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704465e764012f4bb3227a51159b8622/" rel="bookmark">
			探索性空间数据分析的相关信息解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引言 这篇帖子内容有关arcmap地图绘制和局部空间自相关等等，希望可以帮助到你，先发布，后续会完善 2.新版白话空间统计（46）局部莫兰指数计算原理与操作篇（GeoDa版）（转自虾神说D公众号，极力推荐大家关注他） 2.1前言 我们在新版白话空间统计第44节，展示过这样一张图：
用四个象限来表示LISA的结果划分，今天我们具体来讲讲如何计算LISA也就是详细讲讲如何计算这个坐标轴上的空间滞后值和标准化（观测）值。
（PS：LISA是Local Indicators of Spatial Association的简写，是anselin在1995年提出的一种方法论，里面用到的模型，就是local moran's i）
首先我们先来看这个笛卡尔坐标系的X轴和Y轴。
X轴是标准化之后的观测值，标准化的方法有很多，而这里用的是z-score标准化（zero-mena normalization，此方法最为常用的标准化方法）。
用官方的说法：多指标评价体系中，由于各评价指标的性质不同，通常具有不同的量纲和数量级。当各指标间的水平相差很大时，如果直接用原始指标值进行分析，就会突出数值较高的指标在综合分析中的作用，相对削弱数值水平较低指标的作用。因此，为了保证结果的可靠性，需要对原始指标数据进行标准化处理。
数据的标准化(normalization)是将数据按比例缩放，使之落入一个小的特定区间。在某些比较和评价的指标处理中经常会用到，去除数据的单位限制，将其转化为无量纲的纯数值，便于不同单位或量级的指标能够进行比较和加权。
Z-Score标准化的方法非常简单，公式如下：
Z-Score标准化 = (要标准化的值（观测值） - 平均值) / 标准差
z-score标准化方法适用于属性A的最大值和最小值未知的情况，或有超出取值范围的离群数据的情况。
而Y轴表示的是空间滞后值（何为空间滞后值，我们在下篇中会详细说明），即该要素的相邻要素的所有ZScore标准化观测值的空间加权平均。
为了验证我们的理解对不对，可以直接用Excel来计算，来与GeoDa计算的结果进行对比，对比如下：
用Excel，对我们要计算的字段，进行ZScore标准化，可以得到如下结果：
然后利用Queen's Case的空间关系矩阵，求空间滞后值（因为太多了，所以我示例性的求其中一个就行）：
比如求北京的空间滞后值，空间权重矩阵如下：
北京有两个邻居，分别是河北和天津，计算北京的空间滞后值，算法如下：
北京的空间滞后值 = 累加 (邻居的观测值的ZScroe标准化值 * 权重）/ 邻居的数量
其实也就是，也就是求了空间关系加权之后的平均值
我们的空间权重矩阵用的是queen's case，那么所有的邻居权重都是一样的，直接计算平均值就可以了：
北京的空间滞后值 = (-0.490978428[天津的zscore] * 1[天津对北京的空间关系加权] + 0.242135744[河北的zscroe] * 1[河北对北京的空间关系加权]）/ 2 = -0.124421342
依此把所有的数据都算一遍，就可以得到所有要素的Zscroe和空间滞后值，然后，只要有两个值，就构成了X轴和Y轴，就可以绘制出散点图来了。
注意，大家在测试的时候，如果计算的结果和我不同，切记看这里：
如果用默认的空间权重矩阵，海南没有邻居，是不会参与计算的，所以你在手动计算平均值和标准差的时候，需要把海南排除掉。（有同学问，如果我要加入海南呢？答案是需要自定义修改空间权重矩阵，参考以前的文章）
新版白话空间统计（18）空间关系概念化之Geoda的面邻接构建及自定义
下面，我们用GeoDa来做局部莫兰指数，并且把值添加到属性里面，为什么要用GeoDa？因为ArcGIS不支持把计算保存计算出来的ZScore标准化值和空间滞后值，要看这两个值，只能用GeoDa（R语言和Python也行，以后有空说）。
2.2GeoDa进行局部莫兰指数分析，并且获得数值的完整操作流程： STEP1:打开GeoDa软件之后，在连接数据源界面点击选择文件后面的打开按钮，选择我们需要打开的数据，这里我们需要打开shape file，所以选择第一项即可。
STEP2:
找到我们需要打开的Shapefile
STEP 3:在计算之前，需要先定义空间权重矩阵，所以在工具栏上选择空间权重管理：
STEP 4:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704465e764012f4bb3227a51159b8622/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de95fb05f878cea40d077684082c4f9/" rel="bookmark">
			【C&#43;&#43;11】判断std::map中是否存在某个元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 方法代码 方法 用find函数，会返回一个迭代器，如果迭代器指向了map的尾部，则可以判定不存在这个元素；否则，就存在；
代码写法
单独一个函数；用lambda函数的方式写在需要用到的位置； 代码 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;map&gt; bool checkExist(const std::map&lt;std::string, int&gt;&amp; map, const std::string&amp; key){ auto temp = map.find(key); if(temp == map.end()){ std::cout &lt;&lt; "not found" &lt;&lt; std::endl; return false; } std::cout &lt;&lt; "found" &lt;&lt; std::endl; return true; } int main() { std::map&lt;std::string, int&gt; map; std::string key1 = "1234"; map[key1] = 1; auto checkExistFunc = [&amp;](const std::string&amp; key) -&gt; bool { auto temp = map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0de95fb05f878cea40d077684082c4f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa1ecaaf866a2d70fdf349cf8c7c33f9/" rel="bookmark">
			毫米波雷达测量原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		毫米波雷达测量原理 简介测距测速测角度 简介 波长1~10mm的电磁波，频率为30～300GHz，基于其工作模式可以分为“脉冲”和“连续波”两种。而FMCW调频连续波是最常用的车载毫米波雷达。
测距 1.原理：发射天线（Tx）和接收天线（Rx）信号合并生成中频（IF）信号，由中频信号的频率、光速可以得到单个目标的距离，如果是多个目标，雷达通过接收不同物体的发射信号，并转为IF信号，利用傅里叶变换FFT产生一个具有不同的分离峰值的频谱，每个峰值表示在特定距离处存在物体。
2.距离分辨率：距离分辨率是指辨别两个或更多物体的能力。当两个物体靠近到某个位置时，雷达系统将不能将二者区分开。距离分辨率仅取决于线性调频脉冲扫频的带宽。
3.最远探测距离：IF信号通常经过数字化处理（LPF + ADC），才在DSP上进行进一步处理，因此，中频信号的大小取决于ADC采样频率（FS）。ADC的采样频率限制了雷达的最远探测距离。
测速 1.原理：依据多普勒效应。当移动台以恒定的速率沿某一方向移动时，由于传播路程差的原因，会造成相位和频率的变化，通常将这种变化称为多普勒频移。它揭示了波的属性在运动中发生变化的规律。
根据相位差、目标的位移、发射间隔来计算速度。
2.速度分辨率：取决于帧的时间。
测角度 1.原理：目标距离的微小变化会导致range-FFT峰值的相位变化。角度估计至少需要2个RX天线。从目标到每个天线的差分距离导致FFT峰值发生相位变化，该相位变化用于估计到达角。
根据天线间距、相位差计算角度。
2.分辨率：取决于天线个数，天线个数越多，分辨率越小，越能分辨出目标的角度。
参考：毫米波雷达原理介绍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6776b2a589b0f5d2d56306eaa0024ff/" rel="bookmark">
			Anaconda安装第三方库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.打开Anaconda。
2.输入：其中sdsd_torch是我想加进行操作的环境
conda activate sdsd_torch 3.输入：
pip install 包名称 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbcfda91a1420a15879066077cb305e7/" rel="bookmark">
			【渐进交互学习网络：轻量级：超分：工业应用】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Progressive Interaction-Learning Network for Lightweight Single-Image Super-Resolution in Industrial Applications （工业应用中轻量级单幅图像超分辨率渐进交互学习网络）
近年来，基于深度学习（DL）的工业应用因其先进的性能而受到广泛关注。然而，便携式设备中有限的计算资源总是使得大DL模型不适用于工业。基于DL的单幅图像超分辨率算法由于计算量大也会遇到这个问题。此外，大多数基于卷积神经网络的轻量级方法对特征的利用不足，限制了其工业重构的能力。为了缓解这一问题，我们提出了一个进程交互学习网络（PILN），以细化不同层次的特征：在全局层次上，我们采用渐进式交互学习策略来整合时间和空间维度上的层次特征;在中间层，增强交互学习单元采用增强交互学习，显著提高重构性能;在局部层面上，采用逐像素学习，提出残差单元以通过权重分布来搜索最优信息流。大量的实验表明，PILN算法优于现有的其他算法。
介绍 随着机器学习/深度学习（DL）的不断兴起，提出了广泛的基于机器学习/DL的工业应用，以在相应任务中实现更好的性能。单幅图像超分辨率（SISR）技术在监控系统、遥感、机械制造和物联网（IoT）等众多工业应用中发挥着重要作用，近年来DL大力推广。然而，大多数基于DL的SISR方法需要大量的存储和计算，这是许多工业系统所不能承受的。例如，具有高速和多个时间敏感操作要求的物联网工业应用广泛地通过小规模平台实现。因此，轻量级SISR神经网络的设计对于工业应用具有重要意义，这也是本文的研究目的。SISR是一种低层次视觉任务，旨在从低分辨率（LR）图像重建高分辨率（HR）图像。多幅HR图像可以退化为一幅LR图像，这是一个不适定问题，引起了广泛的关注。因此，研究人员提出了多种高质量图像超分辨率（SR）的方法，其中深度卷积神经网络（CNN）因其优越的性能而备受关注。为了使基于神经网络的方法能够应用于工业应用，一些轻量化方法不断被提出。为了高效地重建图像，Fu等人尝试通过多尺度知识转移来构建适合物联网（IoT）应用的轻量级结构。
虽然轻量级网络在实际应用中取得了优异的性能，但在工业应用场景中仍然受到各种限制。特别是在充分利用特征方面，直观效果主要体现在以下两个方面。
1）大多数特征提取策略只关注单个层次，而忽略了层次特征之间的相关性。例如，残差学习强调全局特征但忽略局部细节；密集连接策略扩大了不同模块之间的空间相关性，但忽略了时间关系。
2）现有的信息流策略对特征的利用效率较低，影响了精确表示的能力.以权重贡献策略为例，空间关注度（SA）只关注空间特征，而忽略了其他有效信息（如：通道或像素细节）。
为了解决轻量级SISR神经网络中的上述问题，提出了一种渐进交互学习网络（PILN）来聚合不同层次的特征。一方面，我们在不同的层次上实施不同的特征细化策略（例如，全局、中间和局部）以促进分层特征融合。具体而言，PILN通过全局的渐进交互学习策略（PILS）、中间的增强交互学习（EIS）和局部的逐像素学习（PWL）有效地提高了重建能力。另一方面，我们设计了残差单元（R-Cells）和特征提取单元（FEU）来构造增强的交互学习单元（EILUs），该交互学习单元在时间和空间两个方向上聚合特征。通过使用精细的块来形成PILN，最大限度地利用了多维特征，在保持轻量级的同时获得了相似的重建结果，增加了PILN在工业应用中的实用性。
贡献 1）我们提出了一种有效的用于SISR的PILN，它在不同的层次上细化时空特征，即：局部、中间和全局。实验结果表明，该算法在保持较少资源消耗的同时，性能优于其他SOTA算法。
2）在全局层面上，我们采用PILS来收集时间和空间方向上的特征。利用PILS，层次信息可以在多维空间中交互聚合，保证了特征的充分利用。
3）在中间层，利用EIS，多个EILU通过有效的特征聚合优化信息流。在EIS的辅助下，EILUs在SR任务中表现出了强大的表征能力。
4）在局部层次上，我们设计R-Cells和FEU以形成EILU，EILU在像素级聚合特征。实验结果表明，PILN通过自适应地对R-Cells进行权值贡献，并用FEU聚集RCells，提高了图像重建性能。
相关工作 CNN-Based Image SR 近年来，基于神经网络的结构使SR性能得到了迅速发展，并取得了优异的性能，作为先驱，超分辨率卷积神经网络（SRCNN）成功地将插值LR图像映射到具有浅三层结构的HR副本。之后，大量的方法试图通过使用不同的学习策略来深化它们的模型以提高重构性能：1)残差学习，用于缓解梯度消失问题的有效训练方法；2)密集连接策略，充分挖掘不同层次特征之间的相关性，实现强大的特征表；;3）递归学习，例如超分辨率反馈网络（SRFBN），使用深度SRFBN通过提取时间信息来提高表示能力；4）注意机制，例如，渠道关注（CA）和SA，以促进信息流动；以及5）在深度维度或时间维度上展开网络以提高重建性能。然而，现有的基于神经网络的模型参数较多，资源消耗大，不适合实际应用。
为了减少参数，已经提出了多个紧凑且有效的神经网络来释放用于匹配移动的设备的计算成本。适度信息蒸馏网络（IDN）使用基于状态的递归结构，旨在缓解参数问题，同时保持高质量的重建。同时Hui等人通过多重蒸馏发展了信息多重蒸馏网络，称之为信息多重蒸馏网络（IMDN）。然而，上述轻量级结构忽略了层次特征的使用，导致了不满意的结果。为了获得高质量的重建结果，有学者提出了性能和计算量之间的最佳折衷方案。受上述方法的启发，我们设计了基于渐进学习（PL）的研究，以构建一个有效的网络用于层次多维特征提取。
Attention Mechanism CA注重通道的特征细化，在许多计算视觉任务中取得了优异的性能。Zhang等人将CA机制集成到SISR的残余信道注意网络中。然后，由几个二阶信道注意力组成，提出了一个二阶注意力网络，以从一个新的角度执行权重分配。虽然CA已经取得了显著的进步，但由于信息利用的不足，CA仍有其局限性。另一方面，SA的目标是在空间维度上对特征进行加权，从而帮助网络找到一个高效、可信的模型。例如，SPP-Net 使用空间金字塔池（SPP）策略来提高图像表示的质量。在SA的指导下，SPP-Net产生了固定长度的结果，并进一步应用于分类和检测任务。之后，SA的应用场景更加通用，例如：自我注意生成对抗网络在生成对抗网络上进行空间特征细化。尽管单维注意机制有了很大的改进，但仍不能适应工业应用的发展。为了充分利用不同维度的信息，Zhao等人通过混合注意策略来提高其表征能力。基于这种思路，我们提出了一种自适应学习注意机制R-Cell，它可以集中学习通道权重和空间权重，以获得更强大的SR。
方法 Global Level: PILS Description ofthe Backbone Network: 在图2中，PILN是一种轻质高效的结构，具有几个合理排列的块。主干由三个EILUs组成（即，EILU-S、EILU-M和EILU-D）进行精细特征提取（参见图3）。
然后，网络的输入和输出分别用ILR和ISR表示。该公式可说明如下：
其中HLFE(·)、HPIL(·)和HHFE(·)分别表示低级特征提取、渐进式交互学习和高级特征提取的操作。符号Iup是ILR的上采样结果，并且“+”表示残差学习。为了更清楚地解释特征提取，我们逐步表示PILN。对于输入的ILR，通过低层特征提取HLFE(·)，可以获得浅层特征FSF。
然后，可以通过HPIL(·)的操作来细化FSF，HPIL(·)在全局层面采用PILS
为了更好地适应阶段学习，我们对改进的FPIL进行高层特征提取，并获得融合信息FHF
其中HHFE(·)表示高级特征提取的函数。最后，通过在放大的ILR和FHF之间进行残差学习，可以通过下式形成高质量画面ISR：
其中，函数Hup(·)为上采样，用于将LR插值为HR的大小。
Description ofthe PILS: 如图2所示，所提出的模型可分为三个层次：全局、中间和局部。PILS（图3）主要用于全局水平，以进行精确的图像重建。此外， E j E^j Eji是在第j阶段从第i个EILU提取的纯特征。总体PL可描述如下。
Stage 1 self-study (T = 1): EILUS的主要任务是对浅层特征进行预处理，获得中间信息 E 1 E^1 E11，提高图像重建质量
其中ΦEILUS(·)表示浅层特征的细化，FSF表示初始信息。
Stage 2mutual study (T = 2): 当T= 2时，我们深入地集成了一个全新的功能块EILU-M。首先，我们在EILU-S中对先前的输出 E 1 E^1 E11使用自学习，这可以被视为自学习。然后，EILU-M将特征(即： E 1 E^1 E11和FSF），结合层次特征和时间相关特征，通过以下步骤完成不同模块间的交互学习
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbcfda91a1420a15879066077cb305e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fef7932e851b640dc36895de81773829/" rel="bookmark">
			真滴泰裤辣！！！！字节跳动最全Git应用及面试问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Git1. git常用命令1.1、git init1.2、git remote add origin 远程仓库地址1.3、git remote -v1.4、git status1.5、git add [file] 、git add .1.6、git commit -m "提交日志"1.7、git log --oneline1.8、git diff1.9、git push origin &lt;本地分支名&gt;1.10、git pull1.11、git merge &lt;其他分支名&gt;1.12、git merge --abort1.13、git branch 分支名称1.14、git checkout 分支名称1.15、git checkout -b 新分支名称1.16、git branch、git branch -r、git branch -a1.17、git branch -d 分支名称1.18、git clean -f1.19、git reset1.20、git rm 文件、git rm --cached 文件名1.21、git stash 和 git stash pop 二、常用面试Git问题1.git提交时发生冲突，你能解释冲突时如何产生的吗？你是如何解决的？2.如果本次提交失误，如何撤销?3.git和svn有什么区别?4.分布式和集中式的区别?5.git fetch、git merge、git pull的区别?6. Git的rebase和merge的区别是什么？&lt;1&gt;使用 Merge&lt;2&gt;使用 Rebase 总结 一、Git 1. git常用命令 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fef7932e851b640dc36895de81773829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a36d0c1efe36c12ce54b521aed6c7940/" rel="bookmark">
			关于k8s中ingress、Gateway、nginx之间关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Kubernetes中，Ingress是一种用于将外部流量路由到集群内部服务的API对象。它通常与Ingress控制器一起使用，Ingress控制器负责根据Ingress规则路由外部流量到不同的服务上。
下面是使用Ingress的一些步骤：
安装Ingress控制器 在Kubernetes中，Ingress控制器是需要安装和配置的。有许多流行的Ingress控制器，如Nginx Ingress Controller、Traefik、Haproxy Ingress等，你需要选择一个适合你的需求的Ingress控制器并安装它。
创建Ingress对象 创建Ingress对象可以通过yaml文件进行定义，例如：
apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: example-ingress spec: rules: - host: example.com http: paths: - path: /app1 pathType: Prefix backend: service: name: app1-service port: name: http 上述定义的Ingress对象将把example.com上的请求路由到名称为app1-service的Service对象上的http端口。
部署服务并暴露端口 你需要创建一个Deployment和一个Service对象，并暴露Service的端口，使得Ingress控制器可以路由流量到该服务。例如：
apiVersion: apps/v1 kind: Deployment metadata: name: app1-deployment spec: replicas: 3 selector: matchLabels: app: app1 template: metadata: labels: app: app1 spec: containers: - name: app1 image: example/app1:latest ports: - containerPort: 80 --- apiVersion: v1 kind: Service metadata: name: app1-service spec: selector: app: app1 ports: - name: http port: 80 上述定义的Deployment和Service将创建一个名为app1-service的Service对象，并将其暴露在80端口上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a36d0c1efe36c12ce54b521aed6c7940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75657c5e32746da9524a5f57bb9daa87/" rel="bookmark">
			【openbmc 开发专栏】：openbmc 开发步骤、源码分析、feature 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 openbmc 开发编译详细步骤 openbmc 开发编译详细步骤 OpenBMC是基于Linux操作系统的开源项目，用于管理和控制硬件平台。以下是OpenBMC的开发编译详细步骤：
安装必要的软件包和工具链 在Linux主机上安装Git、Python、Yocto
Project和OpenBMC所需的软件包和工具链。具体要求可以参考OpenBMC官方文档。
克隆OpenBMC源代码 使用Git克隆OpenBMC源代码仓库：
$ git clone https://github.com/openbmc/openbmc.git 进入OpenBMC代码目录 $ cd openbmc 配置构建环境 配置构建环境变量：
$ . openbmc-env 该脚本将设置必要的环境变量和别名，以便正确构建OpenBMC。
选择目标平台 OpenBMC支持多个硬件平台。在代码目录中选择目标平台：
$ cd meta-&lt;platform&gt; 配置OpenBMC 使用bitbake工具配置OpenBMC：
$ bitbake obmc-phosphor-image 该命令将下载和编译所有必要的组件和依赖项，并生成可引导的OpenBMC映像文件。
编译OpenBMC 使用bitbake编译OpenBMC：
$ bitbake obmc-phosphor-image 该命令将下载和编译所有必要的组件和依赖项，并生成可引导的OpenBMC映像文件。
烧写OpenBMC映像 将生成的OpenBMC映像烧写到目标硬件平台的闪存中。具体步骤因平台而异，可以参考OpenBMC官方文档。
以上是OpenBMC的开发编译详细步骤。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abd23824ec6b6daa3b7999e34bdd5c70/" rel="bookmark">
			Jmeter 操作使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jmeter -测试计划的页面
jmeter设置系统操作前的语言（中文）设置 使用记事本打开文件 jmeter.properties》文件中搜索：language ，添加language=zh_CN》文件中搜索：encoding，在encoding最后一行的改为 #sampleresult.default.encoding=UTF-8》保存，即可
测试范围： 由于后台系统为内部人员使用，性能测试优先级较低，故本次性能测试范围只限于前台系统 一、服务器端性能测试 性能需求分析，指定测试计划 设计、编写测试用例 搭建环境，准备数据——准备数据——访问数据库，创建存储过程 创建数据（使用php造数据） #SQL语句中不用缩进，不用"" ,主键不能重复、用户名不能重复 create procedure createuser() begin declare i int default 1; #这里i是个变量 #declare声名变量为int整型 while i&lt;=50000 do #while条件，操作50000次循环，必须加入set递进 insert into `ecs_users` VALUES (10000+i,concat('user',10000+i,'@1.com'),concat('user',10000+i),'1dde592c59b28160ccd55bb70746f190','','',0,'0000-00-00', #从10000次开始 #concat函数用于连接 0.00,0.00,0,0,4,1681870085,1682284331,'0000-00-00 00:00:00','0.0.0.0',147,0,0,'9094','0',0,0, '','000000','1044265594','000000','000000','000000',0,0.00,NULL,NULL); set i=i+1; #set表示递进 end while; end 下图是造的数据内容： 调用数据 调用完成后，可以在相应的ecs_users表中查看‘数据浏览’，即有显示user_id从10001到60000的数明细，共计50000条数据
call createuser(); 测试脚本——采用录制+编写，生成脚本 录制——工具1：badboy 录制——使用工具：badboy，该工具一般用于web端的测试，app端不适用
录制——工具2：jmeter：http代理服务器 录制——工具3：fiddler抓包，转化为脚本》 headers》 Content-Type: application/x-www-form-urlencoded 关于Fiddler的设置，且过滤掉其他数据 Actions——Run Fileterset now——（过滤器） 1、单功能点场景测试用例 实操 步骤一： 按照预期并发数500设置线程数为：500，Ramp-Up时间（秒）：5
步骤二： 在线程组下》添加事务控制器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abd23824ec6b6daa3b7999e34bdd5c70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d654a98834f2e49969cec5c53eb8b5bf/" rel="bookmark">
			启动盘安装windows系统时提示：“windows安装程序无法创建新的分区，也找不到现有分区”的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用启动盘安装Windows系统时有时会遇到无法安装的问题，选定主分区或新建主分区出现“windows安装程序无法创建新的分区，也找不到现有分区”的提示信息，导致安装失败。提示信息如下图所示：
出现这种问题就很头疼，我们来看一下如何解决吧！
出现这种情况有可能是硬盘格式通过指令写死，需要通过指令把格式清零。本文以安装Windows10为例：
在硬盘分区格式化界面时按着Shit+F10打开命令符，这个时候我们就进入到了具有管理员权限的CMD。
进入CMD程序后，依次输入以下命令：
diskpart（启动Diskpart程序） list disk （查看电脑中有哪些磁盘） select disk 0（选中编号为0的磁盘） clean（清除磁盘所有分区） convert gpt（将磁盘转换成GPT格式）根据实际的需要如果是legacy启动的就转成mbr格式 list partition（查看当前磁盘分区情况） create partition efi size=100（默认大小为M） create partition msr size =128 create partition primary size =102400(此处为你想设置C盘的大小) 两次输入exit，或直接关闭CMD窗口 执行完上述命令返回硬盘分区格式化界面，刷新即可看到分区结果，这个时候就可以选磁盘主分区继续安装系统啦。
操作过程流程图如下图所示：
好了，至此结束，你应该可以顺利安装系统啦！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c35534a1a199016fc4f84b5740234fe5/" rel="bookmark">
			Qt QTableView 实现数据改变表格自动刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里提供一份简单的代码示例，实现QTableView实时刷新数据：
#include &lt;QApplication&gt; #include &lt;QWidget&gt; #include &lt;QTableView&gt; #include &lt;QStandardItemModel&gt; ​ int main(int argc, char *argv[]) { QApplication a(argc, argv); ​ QWidget *widget = new QWidget(); widget-&gt;setWindowTitle("QTableView Example"); ​ QTableView *tableView = new QTableView(widget); tableView-&gt;setGeometry(10, 10, 400, 300); ​ // 创建数据模型 QStandardItemModel *model = new QStandardItemModel(); ​ // 设置表格行数和列数 model-&gt;setRowCount(3); model-&gt;setColumnCount(2); ​ // 设置表头 model-&gt;setHeaderData(0, Qt::Horizontal, "Name"); model-&gt;setHeaderData(1, Qt::Horizontal, "Age"); ​ // 填充数据 model-&gt;setData(model-&gt;index(0, 0), "Tom"); model-&gt;setData(model-&gt;index(0, 1), 20); model-&gt;setData(model-&gt;index(1, 0), "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c35534a1a199016fc4f84b5740234fe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ed68b3977361534914e2b54a8aeb992/" rel="bookmark">
			pycharm和数据库链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库连接 pycharm 社区版链接mysql数据库
Pycharm社区版连接数据库
解决pycharm连接mysql报错（DB Navigator-Connection error）
Error: 1045
学习 python3基础：操作mysql数据库
Python3 MySQL 数据库连接 - PyMySQL 驱动-菜鸟教程
Python异常处理及常见报错解决
# 函数介绍 pymysql.connect() #连接数据库函数 conn.cursor() #获取游标 #创建pythonBD数据库 cursor.execute('CREATE DATABASE IF NOT EXISTS pythonDB;') cursor.close()#先关闭游标 conn.close()#再关闭数据库连接 #创建user表 cursor.execute('DROP TABLE IF EXISTS EMPLOYEE;') sql= """CREATE TABLE EMPLOYEE( FIRST_NAME CHAR(20) NOT NULL, LAST_NAME CHAR(20) ， PRIMARY KEY (FIRST_NAME) )""" cursor.execute(sql) #取一条数据 res=cur.fetchone() cursor.fetchone() #获取游标所在处的一行数据，返回元组，没有返回None cursor.fetchmany(size) #接受size行返回结果行。如果size大于返回的结果行的数量，则会返回cursor.arraysize条数据。 cursor. fetchall() #接收全部的返回结果行。 rowcount #这是一个只读属性，并返回执行execute()方法后影响的行数。 # 创建数据库 import pymysql #打开数据库连接 conn = pymysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ed68b3977361534914e2b54a8aeb992/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a1bba869e2cdeff8277f1938b6e46ef/" rel="bookmark">
			golang 字符串时间转换成时间戳的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Golang 中，可以使用 time 包中的 Parse 函数将字符串时间转换为 Time 类型，并使用 Unix() 函数将其转换为时间戳。
以下是一个示例代码：
package main ​ import ( "fmt" "time" ) ​ func main() { // 定义需转换的时间格式 layout := "2006-01-02 15:04:05" // 定义需转换的时间字符串 str := "2021-10-28 13:16:00" // 使用 Parse 将时间字符串转换为 Time 类型 t, err := time.Parse(layout, str) if err != nil { fmt.Println(err) return } // 使用 Unix 函数将 Time 类型转换为时间戳 timestamp := t.Unix() fmt.Println(timestamp) } 上述代码会输出转换后的时间戳。需要注意的是，转换的时间字符串和时间格式要匹配，否则会返回错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c91308b2f58fb6655264330c015f5f86/" rel="bookmark">
			STM32（2）-串口通讯实际应用：串口屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章以UART基础知识和串口屏实际应用来说明串口的作用。
文章目录 前言一、UART是什么？二、USART HMI1.引入字库和图片库2.控件与指令集的使用（1）控件的事件编写(2)STM32串口程序编写 总结 前言 、
一、UART是什么？ UART是通用异步收发传输器（Universal Asynchronous Receiver/Transmitter）的缩写，是一种串行通讯协议，通常用于将计算机或微处理器与其他设备（如传感器、模块、显示器等）进行通信。UART可以将数据以一定速率和格式（如数据位、校验位、停止位等）从发送器传输到接收器，从而实现双方的数据交换。常见的串口通讯协议如RS-232、RS-485等都是基于UART的。
异步是什么意思？
异步通信是指在通信过程中，数据的传输不依赖于时钟信号的同步。在异步通信中，数据是以字符为单位进行传输的，每个字符之间可能存在不等的时间间隔。通常使用UART协议来实现异步通信，其中发送端和接收端通过约定好的波特率、数据位、校验位、停止位等参数来进行通信。相对于同步通信，异步通信具有传输速率不受限制、成本低廉等优点，但也存在传输错误率高等缺点。
USART
USART是通用同步/异步收发传输器（Universal Synchronous/Asynchronous Receiver/Transmitter）的缩写，包含了UART的异步传输和同步传输两种模式。在异步模式下，USART与UART的通讯方式相同，支持异步串行数据传输，数据以字符为单位进行传输，每个字符之间可能存在不等的时间间隔；在同步模式下，USART可以将数据与时钟信号同步传输，数据和时钟信号的传输速率完全一致，并且不需要停止位，在传输速率较高的应用场景中，同步模式更为常用。USART可以支持多种数据格式和传输速率，具有较高的通信灵活性和可靠性
并行与串行
串行传输是指数据以一位一位的方式进行传输，每次只能传输1位数据，传输速度比较慢；并行传输是指多个数据位同时传输，每次可以传输多个二进制位，传输速度比串行传输快，但是需要使用更多的电线或光纤来传输数据。
二、USART HMI 适用于陶晶驰串口屏的上位机开发软件，无需代码即可完成屏幕内容DIY。
1.引入字库和图片库 这里可以选择引入图片、字库、动画等等，
引入字库方法是：点击左上角工具：
选择字库制作，弹出该界面，可自定义字高、编码方式和字体：
点击所有语言，只选择CJK表意字符（目的是减少字符占用空间），
自定义字库名称，保存后在左下角就会出现保存的字库。
引入图片：
较为简单，只需要点击左下角的加号，把你文件夹中的图片添加进来就可以。
2.控件与指令集的使用 这是串口屏使用的核心。这里以一个实例:串口屏设置按钮，发送特定信息给STM32，STM32接收后，根据指令控制LED亮灭。
首先是HMI部分：
界面如图，其中b0控件是按钮，t2文本控件，他的显示（熄灭或点亮）会随着LED状态而改变。
（1）控件的事件编写 这里，对LED按钮的弹起事件编写：printh 01，即按下串口屏的LED按钮并弹起后，将通过串口发送16进制的数据：0x01到STM32中去。对于t2文本控件，不做编写，t2控件的改变是接收STM32串口发送来的字符串数据而改变的，这是在stm32中编写。
(2)STM32串口程序编写 这里参考CSDN一位大佬的程序：首先进行串口配置（串口初始化），使用stm32的USART3，所以硬件连接应为
RX------------PB10
TX------------PB11
先看头文件：
#ifndef __USART3_H #define __USART3_H #include "sys.h" void HMISendb(u8 k)	; void HMISends(char *buf1); void uart3_init(u32 bound); void USART3_IRQHandler(void); //串口1中断服务程序 #endif 这里声明了四个函数：
1.uart3_init(u32 bound)
void uart3_init(u32 bound) { //GPIO端口设置 GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);//时钟GPIOB、USART3 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE); //USART1_TX PB10 GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c91308b2f58fb6655264330c015f5f86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f77159496475c5daf7a68df1bd93433/" rel="bookmark">
			python3 接口测试 requests 基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
目录
前言
一、介绍GET请求
二、介绍POST请求
1. post格式
2. 传入data
三、get、post通用方法
headers
timeout
代理（proxies参数）
verify
files:字典
四、获取响应参数的值
1.查看响应内容
2.查看完整url地址
3.查看响应头部字符编码
4.查看响应码status_code
5.获取响应的headers
6.获取响应的cookies
五、会话保持Sission
六、requests控制访问参数
前言 接口测试，本篇文章主要介绍通过python语言中的requests模块来进行接口请求；requests模块是常用的接口自动化框架，学习相对容易；单纯的接口测试，也可以postman、jmeter等测试工具；
一、介绍GET请求 HTTP默认的请求方法就是GET
1.没有请求体
2.数据必须在1K之内
3.GET请求数据会暴露在浏览器的地址栏中
具体参数是：
格式：r=requests.get(url,params,**kwargs)
url: 需要爬取的网站地址。params: 翻译过来就是参数， url中的额外参数，字典或者字节流格式，可选。**kwargs : 12个控制访问的参数(与post通用)
params：字典或字节序列， 作为参数增加到url中,使用这个参数可以把一些键值对以 【?key1=value1&amp;key2=value2】的模式增加到 url 中，例如：kv = {'key1':' values', 'key2': 'values'} 例
import requests url='http://mobile.atguat.com.cn/xx/xxx/xxx.jsp' params={"sn":"=19c77bf96505f7de4d2a3fe4d22a320608e0b614"} r = requests.get(url,params) print(r.url) print(r.text) """ 请求地址包含入参 print(r.url)实例： http://mobile.atguat.com.cn/xx/xxx/xxx.jsp?sn=%3D19c77bf96505f7de4d2a3fe4d22a320608e0b614 返回参数 print(r.text)实例： {"status":"200","isSuccess":"N","isSessionExpired":"N","isActivated":"Y","serverTime":"2022-03-21 16:43:48","pendingShipmentOrderNum":0,"waitPayOrderNum":0,"waitConfirmOrderNum":0,"waitEvaluateGoodsNum":0, "waitReadMessageNum":0,"expiringCouponNum":0,"couponNum":0,"isNeedCaptcha":"N","traceID":"EA93B8FA7DE64CF5852B4D49E31796E4"} """ 二、介绍POST请求 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f77159496475c5daf7a68df1bd93433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c06da02e5aac223df0b70ada3136328/" rel="bookmark">
			antDesign vue layout布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用框架对vue页面进行布局时，要注意组件的命名，注意不能用类似footer、header等关键字。
例如
import footer from './components/footer.vue' // 在template中导入该组件时就会有问题
推荐命名方式
import FooterLayout from './components/footer.vue'
由于我用的是vue3+typescript开发，在组件中不需要导出name，直接在需要引用的地方命名即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da99ce27d2bb61daed6f42d2233cc18b/" rel="bookmark">
			Android Studio 生成JAR包和调用JAR包方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio 生成JAR包和调用JAR包方法 一、生成JAR包步骤。
1、新建Module，New-&gt;New Module。
2、选择Android Library。
3、module name 为mylibrary。
4、生成mylibrary文件夹
5、新建mylibrary\src\main\java\com\example\mylibrary\Jarlibrary.java
package com.example.mylibrary; import android.os.Bundle; import android.widget.ImageView; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; public class Jarlibrary { static int val; public static void setvalue(int v) { val=v; } public static int getvalue() { return val; } } 6、mylibrary\build.gradle 添加
//Copy类型 task makeJar(type: Copy) { //删除存在的 delete 'build/libs/jarsdk.jar' //设置拷贝的文件 // from('build/intermediates/bundles/release/') from('build/intermediates/aar_main_jar/release/') //打进jar包后的文件目录 into('build/libs/') //将classes.jar放入build/libs/目录下 //include ,exclude参数来设置过滤 //（我们只关心classes.jar这个文件） include('classes.jar') //重命名 rename ('classes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da99ce27d2bb61daed6f42d2233cc18b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/291ad3c5624de829bd0fa733fdf9898d/" rel="bookmark">
			1分钟搭建自己的GPT网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果觉得官方免费的gpt（3.5）体验比较差，总是断开，或者不会fanqiang，那你可以自己搭建一个。但前提是你得有gpt apikey。年初注册的还有18美金的额度，4.1号后注册的就没有额度了。不过也可以自己充值。
有了apikey我们才能有可能完成上层的应用。
来吧，让我们1分钟搭建，自己的gpt网站，而且自动支持https，证书都不需要自己申请。
可能用不了一分钟。。。。
有个前提，得有自己的域名。
搭建步骤 第一步：注册自己的vercel。
第二步：找到gpt开源项目，点击一建搭建，仓库最好选择public。一切都是自动化的，不需要做任何操作。
开源项目 推荐一： ChatGPT Next Web One-Click to deploy well-designed ChatGPT web UI on Vercel.
一键免费部署你的私人 ChatGPT 网页应用。
image.png github地址：https://github.com/Yidadaa/ChatGPT-Next-Web
点击部署即可！
image.png 推荐二： Chatbot UI 这也是我在用的，觉得和官网很像。
Chatbot UI is an open source chat UI for AI models.
image.png 点击部署即可！
image.png 域名绑定 vercel部署后，会自动分配一个域名，但也只能fangqiang才能访问。但可以绑定自己的域名，就可以解除魔法，做到随时随地访问。
添加一个cname指向。
image.png 绑定域名
这就有接口了 网站上线后，我们就能拿到对应的接口了，传入apikey 就可以对话了。
看下接口定义，就知道如何实现多轮对话了。
image.png 所以是每次都会把对话内容传过去。当然这样会更费token。
我的网站 最后发下我部署的站： https://ai.bigerfe.com
如果你有key可以直接用起来。
image.png 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e297d3b4521521bb765f31dfdf79d075/" rel="bookmark">
			RabbitMQ的几种消息确认机制详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：大家好，我是小威，24届毕业生，在一家满意的公司实习。本篇文章将详细介绍RabbitMQ的几种消息确认机制。
如果文章有什么需要改进的地方还请大佬不吝赐教👏👏。
小威在此先感谢各位大佬啦~~🤞🤞
🏠个人主页：小威要向诸佬学习呀
🧑个人简介：大家好，我是小威，一个想要与大家共同进步的男人😉😉
目前状况🎉：24届毕业生，在一家满意的公司实习👏👏
💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘
以下正文开始
文章目录 🍹RabbitMQ的消息确认机制🍰消息可靠抵达-ConfirmCallback🍨消息可靠抵达-ReturnCallback🍖RabbitMQ自动确认和手动确认🎠RabbitMQ处理消息方法🧉图书推荐 🍹RabbitMQ的消息确认机制 RabbitMQ消息确认机制指的是在消息传递过程中，发送方发送消息后，接收方需要对消息进行确认，以确保消息被正确地接收和处理。RabbitMQ的消息确认机制分为两种：
生产者确认机制：生产者发送消息后，需要等待RabbitMQ服务器的确认消息，以确保消息已经被成功地发送到RabbitMQ服务器。如果RabbitMQ服务器没有收到消息或者消息发送失败，生产者会收到一个确认消息，从而可以进行重发或者其他处理。
消费者确认机制：消费者接收到消息后，需要向RabbitMQ服务器发送确认消息，以告诉服务器已经成功地接收并处理了该消息。如果消费者没有发送确认消息，RabbitMQ服务器会认为该消息没有被正确地处理，从而会将该消息重新发送给其他消费者进行处理。
在RabbitMQ中，消息确认机制是通过ACK机制来实现的。ACK代表Acknowledgement，即确认消息。当消息发送方发送消息后，接收方需要向消息发送方发送ACK消息，以表示已经成功地接收和处理了该消息。如果消息发送方没有收到ACK消息，就会认为该消息没有被正确地处理，从而进行重发或者其他处理。
总之，RabbitMQ的消息确认机制可以保证消息的可靠性，从而提高系统的稳定性和可靠性。
🍰消息可靠抵达-ConfirmCallback RabbitMQ的消息确认机制确保了消息的可靠抵达，其中ConfirmCallback是其中一种实现方式。
ConfirmCallback是一个回调函数，用于在消息被确认时进行回调，以确保消息已经被正确地发送到RabbitMQ Broker并被处理。当生产者发送消息时，可以通过调用channel的confirmSelect()方法将channel设置为confirm模式，然后通过添加ConfirmCallback回调函数来处理消息确认。
当消息被发送到Broker后，如果Broker成功地将消息路由到目标队列，则会调用ConfirmCallback回调函数的handleAck()方法，表示消息已被确认。如果Broker无法将消息路由到目标队列，则会调用handleNack()方法，表示消息未被确认。
使用ConfirmCallback可以确保消息已经被正确地发送到RabbitMQ Broker并被处理，从而避免了消息丢失或重复发送的情况。同时，ConfirmCallback还可以在消息未被确认时进行重试或记录日志等操作，以确保消息的可靠性和稳定性。
ConfirmCallback使用说明：
在配置文件中配置：spring.rabbitmq.publisher-confirms=true
在创建 connectionFactory 的时候设置 PublisherConfirms(true) 选项，开启
confirmcallback 。
CorrelationData：用来表示当前消息唯一性。
消息只要被 broker 接收到就会执行 confirmCallback，如果是 cluster 模式，需要所有broker 接收到才会调用 confirmCallback。
被 broker 接收到只能表示 message 已经到达服务器，并不能保证消息一定会被投递 到目标 queue 里。所以需要用到接下来的 returnCallback 。
🍨消息可靠抵达-ReturnCallback RabbitMQ的ReturnCallback机制是为了解决消息无法路由到指定队列的问题。当发送的消息无法被路由到指定队列时，RabbitMQ会将消息返回给生产者，这时候如果生产者设置了ReturnCallback回调函数，就可以在回调函数中处理这种情况。
ReturnCallback机制的使用场景一般是在消息发送时，指定了mandatory参数为true，表示如果消息无法被路由到指定队列，则将消息返回给生产者。如果mandatory参数为false，则消息会被直接丢弃。
当生产者设置了ReturnCallback回调函数后，RabbitMQ在将消息返回给生产者时，会触发该回调函数。在ReturnCallback回调函数中，可以处理消息无法路由的情况，例如重发消息、记录日志等。
下面是一个使用ReturnCallback机制的示例代码：
channel.addReturnListener(new ReturnCallback() { @Override public void handle(ReturnedMessage returnedMessage) { String message = new String(returnedMessage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e297d3b4521521bb765f31dfdf79d075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/985c617048961c21ae2a9e9b71de10dd/" rel="bookmark">
			python打包exe,用pyinstaller，减小打包体积方法[pipenv]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，第一次写csdn，主要是自己碰到的问题查了好几地方都没讲透，今天把自己碰到问题和大家一起分享，希望大家也避坑。
今天用pyinstaller打包，一个程序打包完有340Mb,翻一下之前打包文件仅30Mb~40Mb,分析了一下，网上也找了一下原因：
1、原来打包文件时，我电脑只安装了python，编辑器用的pycham，刚用没多久，库文件装得很少。
2、这次电脑安装了Anaconda，里内置了很多库，打包时会将一些不需要的库都打包进程序，而且速度也慢。
我的解决方法：
1.网上查完建议用Pipenv虚拟环境，具体步骤：
安装pipenv库： pip install pipenv -i https://pypi.tuna.tsinghua.edu.cn/simple/ #（清华镜像源）
运行pipenv虚拟环境 ： pipenv shell 这是未进虚拟环境前：
进入虚拟环境后 注意：多了“（python学习视频-0l8esk90）”表示已进入虚拟环境。每个人python路径不一样，前部分名称不一样，根据自己查看。
在此虚拟环境下安装pyinstaller库(原程序已安装的，在虚拟环境下再装一次）
pip install pyinstaller -i https://pypi.tuna.tsinghua.edu.cn/simple/ 安装要自己打包文件调用的库文件，比如我的：
在pipenv虚拟环境下以此安装pandas/requests/ jsonpath/bs4库，random不用装，自己程序逐个pip install xxx安装所需库。
可以开始打包了，我的xxx.py文件就在“ F:\python学习视频”下面，所以直接打包
pyinstaller -i aaa.ico -F xxx.py (自己常用，我的基本都需要控制台dos界面，输入程序所要的信息用，所以不要 - w )
一般步骤有三种，可以根据需求使用:
Pyinstaller -F py_word.py 打包exe
Pyinstaller -F -w py_word.py 不带控制台的打包
Pyinstaller -F -w -i aaa.ico xxx.py 打包指定exe图标打包
ico图片可以自己设计好后，在网上直接在线转ico 保存本地,文件放在和打包程序xxx.py同位置即可（注不可直接将图片后缀改成ico）
重点来了：
打包完成后，生成的程序在dist文件夹下面。运行exe文件，我在窗口下输入所需要信息后等待几秒后运行一下，弹出几条信息立马闪退，程序报错了，还看不见。
于是用微信或qq截图快捷键做好准备，运行程序弹出报错信息时快速截图
识别文字后贴入百度一搜，原来是pandas里面嵌套了openpyx1库文件，再次再pipenv环境中安装pip install openpyx1 （大家注意自己程序报错截图）查原因解决后基本不会出问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5997f06eed2e36d9802b56727f25f359/" rel="bookmark">
			Jetson Nano一步到位打开USB摄像头（Rosmaster小车）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：我用的rosmaster r2小车配的摄像头是Astra pro，也就是下图这款：
1. 支持的摄像头 Jetson开发包有多个用于连接相机的接口，包括USB、以太网和MIPI CSI-2。流行的相机是现成的支持，而Jetson生态系统合作伙伴支持广泛的附加相机组合。
现成支持的流行摄像头包括IMX219摄像头模块，如Raspberry Pi camera Module V2、Intel Realsense和Stereozed 3D摄像头以及标准USB网络摄像头,这里以usb接口的摄像头为例。
2. nvgstcapture 下面的示例使用nvgstcapture gstreamer应用程序通过nvidiaapi访问相机功能。
3. USB摄像头 安装v4l2-utils协助工具 sudo apt install v4l-utils 查看主板usb摄像头设备连接情况 v4l2-ctl --list-devices 可以看到是可以识别Astra pro相机的插入的
需要告诉nvgstcapture在哪里可以找到USB摄像头设备（代替默认的CSI摄像头）。
# V4L2 USB camera (where &lt;N&gt; is the /dev/videoN node) nvgstcapture-1.0 --camsrc=0 --cap-dev-node=0 不出意外的话就可以直接看到摄像头实时画面了：
如果还想进行拍摄和录像等操作可以参考以下一些文章：
英伟达 Jetson Nano 新手必备：使用CSI或USB摄像头拍摄第一张照片
零基础入门Jetson Nano——通过OpenCV调用CSI和USB摄像头
Jetson Nano使用CSI摄像头以及USB摄像头（CSI摄像头打开失败,USB摄像头打不开）
关于rosmaster r2小车的Astra pro相机:
本来官网教程里说的可以实现的功能有骨骼检测、手指跟随、深度相机等一系列效果：
但由于jetson的CPU是ARM64架构,区别于电脑上的X86架构,所以小车官网上针对Ubuntu18.4（x86）的教程不适用于jetson的arm64架构：
Astra相机使用
按理来说，这教程里截图所示，相机的资源也有匹配Ubuntu arm版本的，问题不大：
但不幸的是：
我能力有限，花了俩小时也没搞懂所谓“提供Orbbec SDK搭配Orbbec Pose SDK方案或者Orbbec SDK搭配Astra Pose SDK方案，用于替代Astra SDK。” 的路子怎么走。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5997f06eed2e36d9802b56727f25f359/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a723cd6b3f03de51ab5a71c85b4a122d/" rel="bookmark">
			在使用微信小程序开发中用vant2框架中的Uploader 文件上传wx.uploadFile无反应和使用多图上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照官方的例子我照着写了一下
&lt;van-uploader multiple="{{true}}" file-list="{{ fileList }}" bind:after-read="afterRead" /&gt;
js代码
Page({ data: { fileList: [], }, afterRead(event) { const { file } = event.detail; console.log("file",file); // 当设置 mutiple 为 true 时, file 为数组格式，否则为对象格式 wx.uploadFile({ url: 'https://example.weixin.qq.com/upload', // 仅为示例，非真实的接口地址 filePath: file.url, name: 'file', formData: { user: 'test' }, success(res) { console.log("res",res); // 上传完成需要更新 fileList const { fileList = [] } = this.data; fileList.push({ ...file, url: res.data }); this.setData({ fileList }); }, }); }, }); 发现不执行wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a723cd6b3f03de51ab5a71c85b4a122d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea8b784140bdb1255d4816377ac5b6c/" rel="bookmark">
			如何将b站缓存的m4s视频转换成mp4格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读前请看一下：我是一个热衷于记录的人，每次写博客会反复研读，尽量不断提升博客质量。文章设置为仅粉丝可见，是因为写博客确实花了不少精力。希望互相进步谢谢！！ 文章目录 阅读前请看一下：我是一个热衷于记录的人，每次写博客会反复研读，尽量不断提升博客质量。文章设置为仅粉丝可见，是因为写博客确实花了不少精力。希望互相进步谢谢！！1、前言2、步骤2.1 设置b站视频缓存路径2.2 安装notepad++2.3 ffmpeg2.2 打开缓存的文件夹2.3 用 3、知识点24、总结 提示：以下是本篇文章正文内容 1、前言 windows端在b站缓存的视频格式为m4s格式，如何转换为mp4格式，这里记录以下。
具体参考《超级详细，如何把B站缓存m4s文件转换成mp4格式》
说下具体思路：如下图，b站缓存的主要是两个m4s文件，其中大的是视频，小的是音频。
我们需要将视频的m4s转化为MP4，音频的ms4转化为MP3，两者再用FFmpeg进行合成即可。
但是下图缓存的视频和音频，开头还有00000000，需要用notepad++删掉，才能用FFmpeg进行合成。
合成时，命令行直接用脚本语言合成即可。
2、步骤 2.1 设置b站视频缓存路径 设置一个自己能找得到的路径，比如我这里设置到的桌面。
2.2 安装notepad++ 具体参考《基于Windows系统安装Notepad++详细过程》，已安装的跳过。
2.3 ffmpeg 到ffmpeg官网下载安装包Download FFmpeg，这里以windows为例。
解压下载的文件：
进入到bin目录，可以看到有如下3个文件（这里不用安装！！！到这一步就ok了）：
2.2 打开缓存的文件夹 2.3 用 3、知识点2 4、总结 码字不易，谢谢点赞！！！
码字不易，谢谢点赞！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b64c014dcd465dceeb651708dc9cbcf/" rel="bookmark">
			「npm」安装依赖时，报错Error: EACCES: permission denied
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 运行环境：CentOS Linux release 7.5.1804
node版本：v16.19.0
运行时执行：npm install
报错如下：
vue-demi@0.13.11 postinstall /root/h-management-prototype/node_modules/@nuxtjs/i18n/node_modules/vue-demi node ./scripts/postinstall.js node:internal/fs/utils:347 throw err; ^ Error: EACCES: permission denied, open '/root/h-management-prototype/node_modules/@nuxtjs/i18n/node_modules/vue-demi/lib/index.cjs' at Object.openSync (node:fs:590:3) at Object.writeFileSync (node:fs:2202:35) at copy (/root/h-management-prototype/node_modules/@nuxtjs/i18n/node_modules/vue-demi/scripts/utils.js:24:6) at switchVersion (/root/h-management-prototype/node_modules/@nuxtjs/i18n/node_modules/vue-demi/scripts/utils.js:52:3) at Object.&lt;anonymous&gt; (/root/h-management-prototype/node_modules/@nuxtjs/i18n/node_modules/vue-demi/scripts/postinstall.js:15:3) at Module._compile (node:internal/modules/cjs/loader:1165:14) at Object.Module._extensions..js (node:internal/modules/cjs/loader:1219:10) at Module.load (node:internal/modules/cjs/loader:1043:32) at Function.Module._load (node:internal/modules/cjs/loader:878:12) at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12) { errno: -13, syscall: 'open', code: 'EACCES', path: '/root/h-management-prototype/node_modules/@nuxtjs/i18n/node_modules/vue-demi/lib/index.cjs' } 报错原因 在 Linux 系统中，root 用户并不会自动获得 npm 包的安装权限，需要手动设置权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b64c014dcd465dceeb651708dc9cbcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7ac362fc270ebf47f927011c4a38190/" rel="bookmark">
			python使用youtube_dl库获取网站上的音频/音乐文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import youtube_dl url = "你需要的音乐网址" ydl_opts = { 'format': 'bestaudio/best', 'outtmpl': 'downloaded_audio.%(ext)s', } with youtube_dl.YoutubeDL(ydl_opts) as ydl: ydl.download([url]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b9580a251303f5ee0d784fab93d7350/" rel="bookmark">
			unity实现按钮长按效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 !
上面是官方的UI支持的事件
举例：实现一个按钮，按下去text文本框从密码类型变成普通类型，显示密码；以及松开切换回去。
using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.UI; public class DisplayPass : MonoBehaviour, IPointerDownHandler, IPointerUpHandler { public InputField inputField; public void OnPointerDown(PointerEventData eventData) { //切换contentType ，一开始默认为Password inputField.contentType = InputField.ContentType.Standard; //刷新数据，不然没反应 inputField.ForceLabelUpdate(); } public void OnPointerUp(PointerEventData eventData) { inputField.contentType = InputField.ContentType.Password; //另一种刷新状态的方法 inputField.Select(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2c88d2358cace865103340f2a95b814/" rel="bookmark">
			Windows Server 2012R2 安装mysql 丢失VCRUNTIME140_1.dll------亲测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无去启动此程序,因为计算机中丢失VCRUNTIME140_1.dll。尝试重新安装该程序以解决此问题。
1.解决思路
说到底还是缺少底层的依赖，先下载依赖然后安装，最后安装vc。要不然vc是安装不成功。
下载安装--一下的插件 安装过程中需要重启一次电脑。
注意:必须按以下顺序安装更新: clearcompressionflag.exe　38 KB　管理员身份运行，没有界面，后台运　Windows8.1-KB2919355-x64.msu 690.8 MB　安装完成后，需要重起，这个安装过程根据你的硬件配置和网络决定安装速度。 Windows8.1-KB2932046-x64.msu 48.0 MB Windows8.1-KB2934018-x64.msu 126.4 MB Windows8.1-KB2937592-x64.msu 303 KB Windows8.1-KB2938439-x64.msu 19.6 MB Windows8.1-KB2959977-x64.msu 2.8 MB 安装的时候有的安装不上，不要纠结，继续下一个。
2.下载
先安装补丁 KB2919442 立即下载基于 x64 的 Windows Server 2012 R2 的KB2919442补丁。Download Windows Server 2012 R2 更新程序 (KB2919442) from Official Microsoft Download Center
Windows Server 2012 R2 Update (KB2919355) 所有补丁
Download Windows Server 2012 R2 Update (KB2919355) from Official Microsoft Download Center
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2c88d2358cace865103340f2a95b814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4392db2c6512a3b03aed60401b1d44ee/" rel="bookmark">
			Spring配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#编写applicationContext.xml文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 使用setter方法注入，class指向实体类路径--&gt; &lt;bean id="" class=""&gt; &lt;property name="" value=""/&gt; &lt;/bean&gt; &lt;!-- 使用构造方法注入，class指向实体类路径--&gt; &lt;bean id="" class=""&gt; &lt;constructor-arg name="" value=""/&gt; &lt;/bean&gt; &lt;!-- 自动装配，class指向实现类路径--&gt; &lt;bean id="" class="com..Impl"/&gt; &lt;bean id="" class="com..Impl" autowire="byName"/&gt; &lt;!-- Spring数据库编程========--&gt; &lt;!-- 1，配置数据源--&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/spring?useUnicode=ture&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=UTC"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="sql123"/&gt; &lt;/bean&gt; &lt;!-- 2，配置JDBC模板--&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4392db2c6512a3b03aed60401b1d44ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09df1e312f9b15c73792267d086f39ed/" rel="bookmark">
			common.js标准和ES6标准下Node模块的导入导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CommonJS 标准 , Node.js项目现在还普遍使用的标准.
ES6标准,一般在前端工程化项目中才会使用,普通Node项目还是用CommonJS的标准.
每一个文件即可看做一个模块,运行Node.js时,需要引入其他模块内的方法就会涉及到不同标准下的导入导出方法
CommonJS 标准:
导出 : module.exports = { 要导出的内容 } 导出的是一个对象
导入: 一般定义一个变量接收 const 变量名 = require('模块名或者路径')
ES6 标准:
默认 导出 export default { } '命名'导出 export 变量名,或者指定对象等
导入 import 变量名 from '模块名或路径' '命名导入' import {同名变量} from '模块名或路径'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae8b57c9842390428c6886b74d8af968/" rel="bookmark">
			150个CMD命令(史上更全CMD命令 NET命令)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cmd命令大全: 1.calc-----------启动计算器
2.certmgr.msc----证书管理实用程序
3.charmap--------启动字符映射表
5.chkdsk.exe-----Chkdsk磁盘检查
6.ciadv.msc------索引服务程序
7.cleanmgr-------垃圾整理
8.cliconfg-------SQL SERVER 客户端网络实用程序
9.Clipbrd--------剪贴板查看器
10.cmd.exe--------cmd命令提示符1
11.compmgmt.msc---计算机管理
12.conf-----------启动netmeeting
13.dcomcnfg-------打开系统组件服务
14.ddeshare-------打开DDE共享设置
15.devmgmt.msc--- 设备管理器
16.dfrg.msc-------磁盘碎片整理程序
17.diskmgmt.msc---磁盘管理实用程序
18.drwtsn32------ 系统医生
19.dvdplay--------DVD播放器
20.dxdiag---------检查DirectX信息
21.explorer-------打开资源管理器
22.eudcedit-------造字程序
23eventvwr-------事件查看器
24.fsmgmt.msc-----共享文件夹管理器
25.gpedit.msc-----组策略
26.iexpress-------木马捆绑工具，系统自带
27.logoff---------注销命令
28.lusrmgrmsc----本机用户和组
29.notepad--------打开记事本
30.magnify--------放大镜实用程序
31.mem.exe--------显示内存使用情况
32.mmc------------打开控制台
33.mobsync--------同步命令
34.mplayer2-------简易widnowsmediaplayer
35.Msconfig.exe---系统配置实用程序
36.mspaint--------画图板
37.mstsC----------远程桌面连接
38.narrator-------屏幕“讲述人”
39.net start messenger----开始信使服务
40.netstat-an----(TC)命令检查接口
41.net stopmessenger-----停止信使服务
42.Nslookup-------IP地址侦测器，是一个监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具
43.ntbackup-------系统备份和还原
44.ntmsmgr.msc----移动存储管理器
45.ntmsoprq.msc---移动存储管理员操作请求
46.odbcad32-------ODBC数据源管理器
47.oobe/msoobe/a----检查XP是否激活
48.osk------------打开屏幕键盘
49.packager-------对象包装程序
50perfmon.msc----计算机性能监测程序
51.progman--------程序管理器
52.regedit.exe----注册表
53.regedt32-------注册表编辑器
54.regsvr32/u*.dll----停止dll文件运行
55.regsvr32/u zipfldr.dll------取消ZIP支持
56.rononce-p----15秒关机
57.rsop.msc-------组策略结果集
58secpol.msc-----本地安全策略
59.services.msc---本地服务设置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae8b57c9842390428c6886b74d8af968/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6027625ce259af444763ba26841a788/" rel="bookmark">
			Mybatis数据库多对多查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，进行多对多查询商品与订单之间的关联关系，首先准备两个mysql数据表
#创建goods表用来储存商品信息
CREATE TABLE `goods`( `id` INT(10) PRIMARY KEY AUTO_INCREMENT, `gsName` VARCHAR(100), `gsPrice` DOUBLE(15,2), `gsNum` INT(60), `gsInformation` VARCHAR(255) ); #插入数据 INSERT INTO goods VALUES(1,'Java程序设计',39.50,342,'一门计算机程序设计类语言'); INSERT INTO goods VALUES(2,'JavaEE企业级应用',59.80,645,'Java三大框架Mybatis，Spring，Spring MVC'); INSERT INTO goods VALUES(3,'笔记本电脑',4999.90,342,'办公室笔记本电脑，游戏本电脑'); INSERT INTO goods VALUES(4,'VIVO手机',2999.50,1120,'一款移动5G手机'); INSERT INTO goods VALUES(5,'牛肉干',15.9,637,'一种学生党热爱的小零食'); INSERT INTO goods VALUES(3,'七波辉皮鞋',69.80,2362,'一种耐磨的皮鞋'); INSERT INTO goods VALUES(6,'外套',129.45,453,'阿迪达斯品牌的衣服'); #创建tb_orders表用来储存订单信息
CREATE TABLE `tb_orders`( `id` INT(32) PRIMARY KEY AUTO_INCREMENT, `number` VARCHAR(32) NOT NULL, `tb_user_id` INT(32) NOT NULL, FOREIGN KEY (tb_user_id) REFERENCES `tb_user` (id) ); #插入数据 INSERT INTO tb_orders VALUES(1,'1000011',1); INSERT INTO tb_orders VALUES(2,'1000012',1); INSERT INTO tb_orders VALUES(3,'1000013',2); INSERT INTO tb_orders VALUES(4,'1000013',4); INSERT INTO tb_orders VALUES(5,'1000014',5); INSERT INTO tb_orders VALUES(6,'1000015',5); INSERT INTO tb_orders VALUES(7,'1000016',6); INSERT INTO tb_orders VALUES(8,'1000017',4); INSERT INTO tb_orders VALUES(9,'1000018',1); INSERT INTO tb_orders VALUES(10,'1000019',2); INSERT INTO tb_orders VALUES(11,'1000020',3); 2，在IDEA创建maven项目并命名JavaEE
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6027625ce259af444763ba26841a788/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c63689c07ad9ecc2a0e80c51844744/" rel="bookmark">
			Android开发之应用更新或软件下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章学习前提:okHttp3或以上，EventBus或其它事件总线工具，四大组件的Activity和Service，安卓通知基础知识 新建项目文件 目录结构如下:
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dyFbPQpv-1682242404904)(https://img2022.cnblogs.com/blog/3034026/202211/3034026-20221115194526774-1687743823.png)]
MainActivity.java 获取权限 本项目所需权限
&lt;!-- 网络权限--&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;!-- 软件安装权限--&gt; &lt;uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES" /&gt; &lt;!-- 文件读写权限--&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; Android 6.0以上并且targetSDKVersion&gt;=23时需要动态申请权限
在MainActivity.java中创建权限申请方法
// 获取权限方法 public static void getPermissionCamera(Activity activity) { // 检查权限 int readPermissionCheck = ContextCompat.checkSelfPermission(activity, Manifest.permission.READ_EXTERNAL_STORAGE); int writePermissionCheck = ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE); // 检查是否有该权限，没有才去申请 // PackageManager.PERMISSION_GRANTED---&gt;有 // PackageManager.PERMISSION_DENIED----&gt;无 if (readPermissionCheck != PackageManager.PERMISSION_GRANTED|| writePermissionCheck != PackageManager.PERMISSION_GRANTED) { // 将这些权限添加到数组中 String[] permissions = new String[]{Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48c63689c07ad9ecc2a0e80c51844744/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d4dc88fc3891d91a4e85eb1b34067d2/" rel="bookmark">
			Java学习日记（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四、面向对象编程（三） 1、类的继承
1、继承的特点
java通过extends关键字实现继承，实现继承的类叫做子类，被继承的类叫做父类。例如水果和苹果的关系，苹果继承了水果，苹果是水果的子类，则苹果是一种特殊的水果。
因为子类是一种特殊的父类，因此父类包含的范围总要比子类广。
Java里子类继承父类的语法格式如下：
修饰符 class SubClass extends SuperClass { //类定义部分 } 下面程序作为子类继承父类的示范代码
先定义一个水果类
public class Fruit { public double weight; public void info() { System.out.println("我是一个水果！重“ +weight+"g"); } } 接下来定义一个水果类的子类，程序如下：
5.8 继承与组合
继承是实现类复用的重要手段，但继承带来了一个最大的坏处：破坏封装。相比之下，组合也是实现类复用的重要方式，而采用组合方式来实现类复用则能提供更好的封装性。
子类扩展父类时，子类可以从父类继承得到成员变量和方法，如果访问权限允许，子类可以直接访问父类的成员变量和方法，相当于子类可以直接复用父类的成员变量和方法。
为了保证父类有良好的封装性，不会被子类随意改变，设计父类通常应该遵循如下规则。
➢ 尽量隐藏父类的内部数据。尽量把父类的所有成员变量都设置成private访问类型，不要让子类直接访问父类的成员变量。
➢ 不要让子类可以随意访问、修改父类的方法。父类中那些仅为辅助其他的工具方法，应该使用private访问控制符修饰，让子类无法访问该方法；如果父类中的方法需要被外部类调用，则必须以public修饰，但又不希望子类重写该方法，可以使用final修饰符（该修饰符后面会有更详细的介绍）来修饰该方法；如果希望父类的某个方法被子类重写，但不希望被其他类自由访问，则可以使用protected来修饰该方法。
➢ 尽量不要在父类构造器中调用将要被子类重写的方法。
如果想把某些类设置成最终类，即不能被当成父类，则可以使用final修饰这个类，例如JDK提供的java.lang.String类和java.lang.System类。除此之外，使用private修饰这个类的所有构造器，从而保证子类无法调用该类的构造器，也就无法继承该类。对于把所有的构造器都使用private修饰的父类而言，可另外提供一个静态方法，用于创建该类的实例。
如果需要复用一个类，除把这个类当成基类来继承之外，还可以把该类当成另一个类的组合成分，从而允许新类直接复用该类的public方法。
5.9 初始化块
一个类里可以有多个初始化块，相同类型的初始化块之间有顺序：前面定义的初始化块先执行，后面定义的初始化块后执行。
在 Java 语言中，当实例化对象时，对象所在类的所有成员变量首先要进行初始化，只有当所有类成员完成初始化后，才会调用对象所在类的构造函数创建象。
初始化一般遵循3个原则：
静态对象（变量）优先于非静态对象（变量）初始化，静态对象（变量）只初始化一次，而非静态对象（变量）可能会初始化多次；
父类优先于子类进行初始化；
按照成员变量的定义顺序进行初始化。 即使变量定义散布于方法定义之中，它们依然在任何方法（包括构造函数）被调用之前先初始化；
加载顺序
父类（静态变量、静态语句块）
子类（静态变量、静态语句块）
父类（实例变量、普通语句块）
父类（构造函数）
子类（实例变量、普通语句块）
子类（构造函数）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cf52e9d4cbf69f335471c2c7c5b2d6e/" rel="bookmark">
			Geometry空间几何数据的处理应用（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学前小故事
学前必备基础知识
WTK格式的Geomotry
GeoJSON格式的Geomotry
JTS(Java Topology Suite) Java拓扑套件
JTS(Java Topology Suite) 可视化界面
泰森多边形
向空间数据库插入数据
栅格
GDAL GeoTools QGIS
快速导航
学前小故事
项目需求是跟用户当前位置判断是否在给定的地理位置范围内，符合位置限制才可以打卡，其中的位置范围是一个或多个不规则的多边形。如下图，判断用户是在清华还是北大。
图形获取区域坐标
因为项目前端使用微信小程序的wx.getLocation获取地理位置，为了坐标的一致性，后台选取区域范围采用了腾讯地图的地理位置服务，在应用工具-&gt;绘制几何图形里，提供了点、线、多边形和圆形可以方便的选取看这里
在官方提供的示例上稍加改动即可获取选定的位置坐标。
存储位置
取到坐标位置后，接着就是怎么存储？
开放地理空间联盟(OGC)是一个由 250多家公司，机构和大学组成的国际联盟，参与开发公开可用的空间解决方案，这些解决方案可用于管理空间数据的各种应用程序。OGC发布了地理信息的 OpenGIS®Implementation 标准，该规范可从 OGC 网站http://www.opengeospatial.org/standards/sfs获得。
为了遵循 OGC 规范，MySQL 将空间 extensions 实现为具有 Geometry Types 环境的 SQL 的子集，提供生成、存储、分析空间的功能。总之，MySQL可以满足我们的需求。
MySQL提供单个的存储类型 POINT、LINESTRING、POLYGON 对应几何图形点、线、多边形，GEOMETRY 可以存储三种中的任何一种。
同时拥有存储多种类型的能力， MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION依次对应单个图形的复数。
回到项目中，我们用到的是 POLYGON ，建表语句 如下：
CREATE TABLE `polygon` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `polygon` polygon NOT NULL, PRIMARY KEY (`id`), SPATIAL KEY `d` (`polygon`) ) DEFAULT CHARSET=utf8; 插入数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cf52e9d4cbf69f335471c2c7c5b2d6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b794f7b08088444dd1ef3154d48dea7/" rel="bookmark">
			【Python_Matplotlib学习笔记（一）】pyplot模块的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyplot模块的基本用法 前言正文1、导入pyplot模块2、plt.plot()方法绘制图像3、plt.plot()方法添加描述信息4、plt.lim()方法设置坐标轴取值范围5、plt.ticks()方法设置坐标轴刻度范围6、plt.grid()方法绘制网格线7、plt.axhline()方法绘制平行于坐标轴的水平参考线8、plt.axvspan()方法绘制垂直于坐标轴的参考区域9、pyplot模块绘制柱状图、饼图、散点图10、plt.subplot()绘制多个子图对象(Axes对象)11、plt.figure()绘制多个绘图对象(Figure对象) 前言 Matplotlib 是一个 Python 的 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形（来自：百度百科）。pyplot 模块是 Matplotlib 模块提供的快速绘图模块，它模仿了 MATLAB 的部分功能。在本文中主要介绍 pyplot 模块的基本用法，会进行持续的更新，欢迎各位读者朋友点赞收藏。
正文 1、导入pyplot模块 import matplotlib.pyplot as plt # 导入pyplot模块 2、plt.plot()方法绘制图像 传入一个参数绘制图像
import matplotlib.pyplot as plt plt.plot([1, 3, 4, 6]) # 如果只传入一个数组作为参数， matplotlib 认为是 Y 轴的坐标 plt.show() 注意：
如果只传入一个数组作为参数， Matplotlib 认为是 Y 轴的坐标并自动生成 x 值。 由于 Python 范围从 0 开始，默认 x 向量具有与 y 相同的长度，但从 0 开始。因此 x 数据是 [0,1,2,3]。plt.show() 函数：默认情况下，matplotlib.pyplot 不会直接显示图像，只有调用 plt.show() 函数时，图像才会显示出来，类似 print() 函数。plt.show() 默认是在新窗口打开一幅图像，并且提供了对图像进行操作的按钮。 传入两个参数绘制图像
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b794f7b08088444dd1ef3154d48dea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f4d24964a0eabaa583964976b6bbb26/" rel="bookmark">
			关于FIO测试和硬盘性能问题测试学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到了两个现场的问题是关于硬盘性能偏低的问题，测试工具是FIO。之前做对外测试时硬盘的性能测试结果都没出过什么问题，测完以后很多东西都没记住，现在做维护了，要基于客户提出的问题做测试调优，涉及知识维度更大了，所以总结下这次处理所了解到的知识和思路，好记性不如烂笔头
首先关于FIO这个工具的测试结果，我们一般需要关注的指标有三个，分别是带宽，IOPS，延时。这三个指标在硬盘厂商的官网上都会有相应的规格书去写明一个基本的规格值。在具体的测试结果中，这三个值是下面read这一行的bw，iops以及lat这一行的avg值。其中延时默认的单位是微秒。清楚这三个值以后我们才能去具体的进行测试调优，还有一些关于延时时间分布占比以及IO占比的这里就不赘述了，属于比较深入的指标，在比较复杂的硬盘测试中可能才会涉及，网上的相关资料也很多
[root@localhost ~]# fio -name=test -filename=/dev/sda -direct=1 -iodepth=128 -rw=randread -ioengine=libaio -bs=4K - group_reporting -numjobs=1 -size=1G -runtime=300 -time_based test: (g=0): rw=randread, bs=4K-4K/4K-4K/4K-4K, ioengine=libaio, iodepth=128 fio-2.2.8 Starting 1 process Jobs: 1 (f=1): [r(1)] [100.0% done] [420.1MB/0KB/0KB /s] [108K/0/0 iops] [eta 00m:00s] test: (groupid=0, jobs=1): err= 0: pid=32820: Tue Feb 15 06:30:01 2022 read : io=128376MB, bw=438189KB/s, iops=109547, runt=300002msec slat (usec): min=2, max=1744, avg= 4.49, stdev= 5.73 clat (usec): min=25, max=12153, avg=1161.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f4d24964a0eabaa583964976b6bbb26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/625975945f98864aa7cd1511c8191f4c/" rel="bookmark">
			富文本编辑器TinyMCE使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用网址
https://www.tiny.cloud/
js使用
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;script src="https://cdn.tiny.cloud/1/no-api-key/tinymce/6/tinymce.min.js" referrerpolicy="origin"&gt;&lt;/script&gt; &lt;script&gt; tinymce.init({ language: 'zh_CN', //注意大小写 selector: '#mytextarea', plugins: [ 'a11ychecker','advlist','advcode','advtable','autolink','checklist','export', 'lists','link','image','charmap','preview','anchor','searchreplace','visualblocks', 'powerpaste','fullscreen','formatpainter','insertdatetime','media','table','help','wordcount' ], toolbar: 'undo redo | formatpainter casechange blocks | bold italic backcolor | ' + 'alignleft aligncenter alignright alignjustify | ' + 'bullist numlist checklist outdent indent | removeformat | a11ycheck code table help' }); //tinyMCE.activeEditor.getContent() 获取编辑器的所有内容 &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;TinyMCE Quick Start Guide&lt;/h1&gt; &lt;form method="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/625975945f98864aa7cd1511c8191f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/769604c95633b4cb97665f50153bdf99/" rel="bookmark">
			MySQL一文教你学会视图（包含with check option检查选项）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
视图概念介绍
视图语法
检查选项（with check option）
视图的更新
视图的作用
​编辑 总结
视图概念介绍 视图（View）只不过是通过相关的名称存储在数据库中的一个 SQL 语句。视图（View）实际上是一个以预定义的 SQL 查询形式存在的表的组合。
视图（View）可以包含一个表的所有行或从一个或多个表选定行。视图（View）可以从一个或多个表创建，这取决于要创建视图的 SQL 查询。
视图（View）是一种虚表，允许用户实现以下几点：
用户或用户组查找结构数据的方式更自然或直观。
限制数据访问，用户只能看到有限的数据，而不是完整的表。
汇总各种表中的数据，用于生成报告。
视图中的数据并不在数据库中实际存在，行和列数据来自自定义视图的查询中使用的表，并且是在使用视图时动态生成的。 通俗的讲，视图只保存了sql语句的逻辑。
视图语法 演示示例：
首先我们先创建演示所用的表和插入数据：
-- 创建表---------------------- create table student( id int auto_increment primary key comment 'id', name varchar(30) not null comment '姓名', sid varchar(20) not null unique comment '学号' )comment '学生表'; INSERT INTO student(name, sid) VALUES ('张三', '20190001'); INSERT INTO student(name, sid) VALUES ('李四', '20190002'); INSERT INTO student(name, sid) VALUES ('王五', '20190003'); INSERT INTO student(name, sid) VALUES ('赵六', '20190004'); INSERT INTO student(name, sid) VALUES ('刘七', '20190005'); INSERT INTO student(name, sid) VALUES ('周八', '20190006'); INSERT INTO student(name, sid) VALUES ('吴九', '20190007'); INSERT INTO student(name, sid) VALUES ('郑十', '20190008'); INSERT INTO student(name, sid) VALUES ('钱十一', '20190009'); INSERT INTO student(name, sid) VALUES ('孙十二', '20190010'); 然后我们利用上面的语法来创建，查询，修改并且删除视图。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/769604c95633b4cb97665f50153bdf99/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/142/">«</a>
	<span class="pagination__item pagination__item--current">143/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/144/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>