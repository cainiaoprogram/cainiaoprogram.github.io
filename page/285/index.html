<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b7b557511a4a16b14dc9bf91c00560/" rel="bookmark">
			电脑内存介绍（精心整理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存是电脑的主要硬件之一，主要用于存储和交换正在运行的程序和数据。简单的说就是，断电之后，内存存储的数据就会消失。所以我们常用的软件需要安装在硬盘等外存设备里，打开游戏或者软件时，就需要把他们调出到内存中运行，内存的运行速度是要远高于硬盘的。
一：内存的分类
目前市场上主流的是DDR家族的，有DDR，DDR2，DDR3和DDR4四种类型，每次更新，内存频率和内存时序都在不断增加。1.1DDR3
DDR3是计算机内存规格，是DDR家族中的，主要规格有DDR3 1333和DDR3 1600以及DDR3 1866、DDR3 2133等。
1.2DDR4
相比于DDR3，DDR4内存拥有更高数据传输速度，DDR3传输速度最高可达2133MHz，而DDR4是2133MHz起到4266MHz，内存容量则是DDR3的4倍。
二，内存的容量
如果内存容量不够，CPU和内存之间的交互会存在一定的限制。在选购内存时，我们所说的4GB或者8GB都是指内存的容量。通常情况下，内存容量大，电脑运行速度也越快。目前，内存容量常见的有4GB，8GB，16GB等。如果你只是听一听歌，或者从事一些简单的办公软件，4G内存就够了。如果是喜欢打一打游戏，例如CF，LOL，原神之类的，或者从事一些办公的，8G就可以。如果想玩一些单机大作，例如GTA，偶尔使用AE，PR，3DMAX等生产力软件推荐使用16GB内存。通常情况下，主板都至少提供了2个内存插槽，电脑的内存容量是这些内存的总和。
三，内存的频率
和CPU，显卡一样，内存频率是衡量内存数量的重要指标，以MHz为单位。内存频率性能越高越好，当然价格也会很贵。那为什么同样的DDR4内存有的出厂默认频率只有2133MHz，有的达到了4800MHz呢？这是因为有的内存颗粒体质好，可以轻松运行到更高的频率。比如我们常听说的三星B—DIE和C98KV。体质普通的内存颗粒每秒能承受2400MHz频率的访问，只能做成普通的内存条。而一些体质好的内存条，每秒能承受更高的频率的访问，这些可以做成高频内存条。
内存条上标出来的频率，是内存厂家保证的内存颗粒能够承受的频率。
那我们买内存的时候需要注意什么，首先我们得看我们主板，比如b460主板，他并不支持内存超频，最大只支持2933MHz的内存。
如果你购买的内存超出这个频率，他就会自动向下兼容，有些大材小用。所以购买内存时也需要主板的型号。只有Intel的Z系列和X系列主板支持3600MHz及以上内存频率的。而B系列和H系列最高也就到2666MHz。而AMD系列的还好一些，全都能支持3200MHz的。
题外话
如果真要比速度，一个内存条怎么比两个内存条快呢，双通道就是使用两个内存条同时传输数据。速度能快将近一倍，两根普通内存条频率是要优于一条高频率内存的，至于怎么组双通道，由于较复杂，可以自己百度一下。
四，内存的时序
时序表示数据的延迟，拿2400MHz的内存来说，CPU去内存中拿数据了，到了内存后，要想精确的找出来，并且拿到手中的时间，就是数据的延迟，以纳秒作为单位，在cpu完成了2400MHz次的取货后，把这2400MHz取货的延迟全都加起来得出的总延迟就是时序。通常我们会在内存标签中看到横杠结尾的四个数字，这就是内存时序。
时序越低，内存延迟也越低 ，CL值就是时序的第一位，也是影响内存延迟最大的一位，如果你爱好超频，就是喜欢超负荷工作的，可以在超频时选择频率高且时序低的内存条，
时序越低，超频潜力也就越大。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44e3fcd88e55d6f687474e610a939a20/" rel="bookmark">
			JavaWeb文件上传的实现及ServletFileUpload类的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、文件上传代码所依赖的jar包： &lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 2、在JSP中编写表单代码 &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%-- 千万不能忘记 enctype="multipart/form-data" --%&gt; &lt;form action="${pageContext.request.contextPath}/uploadFile.do" method="post" enctype="multipart/form-data" &gt; &lt;input type="text" name="name" value="姓名"&gt; &lt;br&gt; &lt;input type="file" name="file1"&gt;&lt;br&gt; &lt;input type="file" name="file2"&gt;&lt;br&gt; &lt;input type="text" name="address" value="住址"&gt;&lt;br&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44e3fcd88e55d6f687474e610a939a20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83dbff2306668fee3273bab8fb33e181/" rel="bookmark">
			pip3 install mysqlclient 报错 Command “python setup.py egg_info“ failed with error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip3 install mysqlclient 报错 Command “python setup.py egg_info” failed with error 鉴于文章被盗：被盗网址：http://smartadmin.com.cn/smartadmin/show-13216.html
特此声明：源文链接：https://blog.csdn.net/weixin_44331765/article/details/120242211
源文链接
1. 软件描述 centos 8.0python3.6鉴于文章被盗：被盗网址：http://smartadmin.com.cn/smartadmin/show-13216.html
特此声明：源文链接：https://blog.csdn.net/weixin_44331765/article/details/120242211 2. 问题描述 使用命令
pip3 install mysqlclient 报错 [root@z ~]# pip3 install mysqlclient WARNING: Running pip install with root privileges is generally not a good idea. Try `pip3 install --user` instead. Collecting mysqlclient Using cached https://files.pythonhosted.org/packages/3c/df/59cd2fa5e48d0804d213bdcb1acb4d08c403b61c7ff7ed4dd4a6a2deb3f7/mysqlclient-2.0.3.tar.gz Complete output from command python setup.py egg_info: /bin/sh: mysql_config: 未找到命令 /bin/sh: mariadb_config: 未找到命令 /bin/sh: mysql_config: 未找到命令 mysql_config --version mariadb_config --version mysql_config --libs Traceback (most recent call last): File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83dbff2306668fee3273bab8fb33e181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21eabbac0b7dae85b97c40e6afa0814e/" rel="bookmark">
			机器学习（11）线性回归（1）理论：损失函数(含最小二乘法)、正规方程、梯度下降、回归性能评估（均方差）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、线性回归基础理论
1、定义与公式
2、线性关系（单特征与双特征）
2-1、单特征线性关系
2-2、双特征平面关系
2-3、其他线性模型
二、线性回归的损失和优化原理
1、损失函数
1、定义
2、公式
3、损失函数举例
2、损失函数 -- 最小二乘法
2、优化方法：
2-1、正规方程 1、公式
2、原理
2-2、梯度下降
1、单特征
2、双特征
3、梯度下降过程（单特征）
4、梯度下降过程（双特征）
3、正规方程与梯度下降优缺点对比
三、回归性能评估（均方差）
公式
API
一、线性回归基础理论 1、定义与公式 定义：
线性回归：利用回归方程，对一个或多个自变量（特征值）和因变量（目标值）之间关系进行建模的一种分析方式。
线性关系公式 ：
权重系数：w
偏置：b 2、线性关系（单特征与双特征） 2-1、单特征线性关系 2-2、双特征平面关系 2-3、其他线性模型 （该图是线性模型，但不是线性关系）
二、线性回归的损失和优化 尽可能让假定的参数贴近真实的参数，越贴近，结果越准确。
1、损失函数 1、定义 损失函数（loss function）：是用来估量模型的预测值f(x)与真实值Y的不一致程度，它是一个非负实值函数，通常使用L(Y, f(x))来表示，损失函数越小，模型的鲁棒性就越好。
2、公式 其中，前面的均值函数表示的是经验风险函数，L代表的是损失函数，后面的ΦΦ是正则化项（regularizer）或者叫惩罚项（penalty term），它可以是L1，也可以是L2，或者其他的正则函数。整个式子的目的：找到使目标函数最小时的θ值（损失最小的情况）。
3、损失函数举例 1、log对数损失函数（逻辑回归）
2、平方损失函数（最小二乘法）
3、指数损失函数（Adaboost）
4、Hinge损失函数（SVM）
5、0-1损失函数
6、绝对值损失函数
4、损失函数 -- 最小二乘法 2、优化方法： 优化目的：让损失函数取得最小值。
优化方法：
1、正规方程；
2、梯度下降。
2-1、正规方程 1、公式 2、原理 优点：不需要试错，可以直接取得最小值，比较快捷。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21eabbac0b7dae85b97c40e6afa0814e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82bed24d7e342558b82c718fe19d2eab/" rel="bookmark">
			Small Object Detection using Context and Attention
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Small Object Detection using Context and Attention阅读记录 论文链接：https://arxiv.org/abs/1912.06319v2
Abstract 作者使用上下文信息和注意力机制检测小目标。
作者使用传统的SSD为基线，当网络输入为300x300时，其在Pascal VOC2007上的mAP为78.1%。
Introduction 作者认为解决小目标检测的关键是如何有效的利用上下文信息。
作者使用深层的抽象信息作为上下文信息，在浅层使用注意力机制，使网络更加关注小目标。
Related Works 省略
Method 首先介绍传统的SSD模型，模型结构如下图，其在VOC2007数据集上的小目标跑分为0.207。
然后是使用上下文信息的SSD模型(F-SSD)，模型结构如下图，他在传统的SSD模型上添加特征融合的过程。
传统SSD与注意力机制结合成A-SSD模型，其结构如下：
其中的注意力模块的结构如下：
Residual block结构：
上下采样1、2阶段分别为：
作者最终的模型(FA-SSD)如下，主要是新增了特征融合和注意力模块：
Experiments 上表为作者的实验结果，特征融合会提升检测网络对各个尺寸的检测性能。增加注意力机制可以提升模型对小目标的检测。除此之外，作者还更换特征提取网络进行测试，结果如下。
Conclusion 省略
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30cb0a5891b5475a031bf0ff85095bd5/" rel="bookmark">
			如何选购自己满意的主板（建议观看）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主板是电脑的核心组件之一，其作用就像人的“身躯”一样，用于连接CPU，内存，硬盘，显卡和光驱等硬件。因此我们选择一个合适的主板非常重要。
一：主板芯片组芯片组是主板的核心部件，其型号直接影响一块主板的功能和性能。可分为Intel和AMD的。
Intel芯片组
Intel芯片组是Intel公司针对自己的CPU产品研发出来的主板芯片组，只能支持Intel公司的目前主流的有8系列，9系列，100系列，200系列和300系列。
***8系列芯片组：主要包括高性能可超频的Z87，主流的H87，低端的B85/H81和商务平台的Q87/Q85，采用新一代LGA1150处理器接口，主要搭配第4代Core i系列CPU。
***9系列芯片组：主要包括Z97，H97和X99等型号，主要搭配第5代酷睿i系列CPU。与Z87/H87相比，Z97/H97芯片组最大的提升是在硬盘性能方面，在读写速度和安全性方面有了较大改进。而X99是上一代X79的升级产品，接口为LGA2011.它主要搭配第五代酷睿i7X系列处理器，专为高端用户而推出的芯片组。
***100系列芯片组：主要包括Z170,H170,Q170,H150,Q150,B150和H110等型号，分别取代之前的Z87/Z97,H87/H97,Q87,Q85,B85和H81，采用了LGA1151处理器接口。主要搭配第6代酷睿i系列处理器。
***200系列芯片组：主要包括Z270，B250和H270等型号，在性能上比100系列有了较大的提升。主要搭配第7代酷睿i系列处理器，同时兼容第6代酷睿i处理器。
***300系列芯片：Intel在2017年底推出了第8代酷睿处理器，采用LGA1151处理器接口，但并不能与之前的100和200系列芯片组兼容。因此Intel推出了全新300系列芯片组，以搭配第8代酷睿i系列处理器，主要包括H30，Q370，B360和H310等型号。
注意！！！！
Intel芯片组型号代码中的前缀字母代表了该芯片组的性能定位，其中H代表低端芯片组，B代表中断芯片组，Z代表高端芯片组，规格最高，可以超频带K的处理器；X是顶级CPU的专用板，常用于服务器，Q为商用版，常用于品牌机。
AMD芯片组
AMD公司主流的有9系列，A系列，300系列和400系列。
***9系列芯片组：主要包括970，980G，990X，990FX共四种型号，分为独立和集成显卡芯片组。其中980G是集成显卡芯片组，其余3款是独立显卡芯片组。该芯片组可搭配AMD速龙，羿龙Ⅱ及AMD FX处理器。
***A系类处理器：包括A55，A68，A78，A85，A88等型号。这种芯片组通常搭配A（X）系列CPU。
***300系列芯片组：包括X399，X370，B350，A320等型号。为AMD新一代芯片组，支持AMD Ryzen（锐龙）3，5，7系列。***400系列芯片组：目前包括X470和B450两种型号，缓解了Ryzen处理器的压力。
二：主板插槽类型
目前主流的有这些
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b78bfae5f4a3eb8b5644dec05505772/" rel="bookmark">
			驱动（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、驱动具体是做什么？
我不知道。
二、驱动步骤。
1）在内核源码的目录下，编写驱动代码，生成.ko文件，并装载或卸载我们写的模块。
三、具体实现
1）驱动代码
驱动代码和我们平常写的代码不一样，他有固定的格式。
驱动代码所需的四个部分。
1）头文件
2）驱动模块装载和卸载入口的声明。
3）实现模块装载和卸载函数入口
4）GPL申明
一般的格式就是这样，这里注意的是，
实现模块的装载和卸载的入口 ，这个函数原型只能是
int 型加函数名加（void）
2）编译的规则
我们使用自己编写的Makefile进行编译。
1）定义变量ROOTFS_DIR为指定路径（我们使用nfs挂载根文件系统的路径）
2）ifeq：kernelrelease 为 0 则执行下面程序，否则执行ELSE的程序
3）定义变量为我们存放的kernel的路径
4）定义变量为我们当前路径
5）all:执=执行make就执行all里的代码：
6）make -C是编译模块 $(kernel_dir)表示我们编译内核的路径 M代表要编译的模块 变量是当前目录的模块。
7）执行make clean 则执行以下程序
8）执行make install :则把当前文件下所有的.ko文件都复制到nfs的文件里面。
9）else：make:开始执行all里面的程序，后面在不到。。。会到链接kernel的makefiel这样ifeq就不为0，则执行
ELSE程序，把工程编译成对应的.o文件。
执行make之后会生成以下文件
执行make install把hello.ko文件放到nfs文件里面。
4）装载模块。
：装载卸载都是在root超级用户才可以使用：sudo su root
在ubunt下面就提供了装载的卸载的命令
insmod + xxx.ko ：
这样就实现了模块的装载。（模块装载在根文件系统？内核加载完成再把模块装载进去？）
lsmod:
查看装载的模块
rmmod + xxx ：（注意不要加.ko）
卸载模块。
5）模块ko参数的传递
我们要给模块传递参数怎么办？直接在insmod XXXXXX.ko 加上要传递的名称+参数
eg: insmod parameter.ko myname=“wzf” myage=23 mysex=“man”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b78bfae5f4a3eb8b5644dec05505772/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91fdcfec0bbe1c31e766a8a2bbc54f43/" rel="bookmark">
			JS获取字符串的长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 获取字符串的长度描述示例题解 获取字符串的长度 描述 如果第二个参数 bUnicode255For1 === true，则所有字符长度为 1
否则如果字符 Unicode 编码 &gt; 255 则长度为 2
示例 输入：
'hello world, 牛客', false 输出：
17 题解 function strLength(s, bUnicode255For1) { let len = s.length; if(!bUnicode255For1){ for(let i = 0;i &lt; len;i++){ if(s.charCodeAt(i) &gt; 255) len++; } } return len; } charCodeAt() 方法返回指定位置字符的 Unicode 码, 返回值是 0 - 65535 之间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82e76b3909431a8125ce88954a6e5a01/" rel="bookmark">
			编写一个Java程序实现多线程，在线程中输出线程的名字，隔300毫秒输出一次，共输出20次
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package test10; /** * @program: TestDemo * @description: 编写一个Java程序实现多线程，在线程中输出线程的名字，隔3000毫秒输出一次，共输出20次。 * @author: xin yi * @create: 2021-09-10 19:06 */ public class Demo06 { public static void main(String[] args) { /** * 线程a */ new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(Thread.currentThread().getName()); try { Thread.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } } } },"我是线程a").start(); /** * 线程b */ new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82e76b3909431a8125ce88954a6e5a01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66a33c68a7c35d909ec7b4f63bf5208a/" rel="bookmark">
			JavaCard概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaCard概述 Java Card是指一种软件技术，它允许基于Java的Applet在智能卡等类似的小内存设备上运行。 Java Card 是面向嵌入式设备的最小 Java 平台。Java Card 使开发者能够对设备开发特定的应用程序。它广泛用于智能卡卡。1996 年，Schlumberger的卡片部门推出了第一款 Java Card，该部门后来与Gemplus合并形成Gemalto。Java Card 产品是基于 Java Card Platform 规范开发的Sun Microsystems公司（后来成为Oracle的子公司）。许多 Java 卡产品还依赖 GlobalPlatform 规范对卡上的Applet进行安全管理（下载、安装、个性化、删除）。
Java Card 技术的主要设计目标是可移植性和安全性。
可移植性 Java Card 旨在定义一个标准的智能卡计算机环境，允许同一个 Java Card 小程序运行在不同的智能卡上，就像 Java 小程序运行在不同的计算机上一样。与 Java 一样，这是通过使用虚拟机（Java Card Virtual Machine）和定义良好的运行时库来实现的，后者在很大程度上从智能卡之间的差异中抽象出小程序。内存大小、性能和运行时支持（例如，对于通信协议或加密算法）的问题仍然降低了可移植性。
安全性 Java Card 技术最初是为了保护存储在智能卡上的敏感信息而开发的。安全性由该技术的各个方面决定：
数据封装
数据存储在应用程序中，Java Card 应用程序在与底层操作系统和硬件分离的隔离环境（Java Card VM）中执行。
Applet防火墙
与其他 Java VM 不同，Java Card VM 通常管理多个应用程序，每个应用程序都可能有自己的敏感数据。因此，不同的应用程序通过防火墙相互隔离，该防火墙限制和检查应用程序对非本应用的数据访问。
密码学
支持常用的对称密钥算法（如DES、TDES、AES）和非对称密钥算法（如RSA、SM）以及其他加密服务（如签名、密钥生成和密钥交换）。
其他语言特性 在语言级别，Java Card 是 Java 的一个子集：Java Card 的所有语言结构都存在于 Java 中并且行为相同。这意味着Java Card 程序能被 Java 编译器编译成 Java 类文件，类文件由特定于 Java Card 平台的工具进行后续的处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66a33c68a7c35d909ec7b4f63bf5208a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9368e9ed54c5281bd48eef71b4ec6d30/" rel="bookmark">
			C&#43;&#43;：安装包添加防火墙端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、检测当前系统 判断是否是XP系统，防火墙端口不一样。
bool CUtil::IsXpSystem(){ OSVERSIONINFO osver; osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); GetVersionEx(&amp;osver); if(osver.dwPlatformId == 2) { if(osver.dwMajorVersion == 5 &amp;&amp; osver.dwMinorVersion == 1) { return true; } } return false; } 2、添加防火墙端口 区分当前系统添加知道的防火墙例外端口。
void C101ServiceCtrl::AddFirewall(){ PROCESS_INFORMATION pi; STARTUPINFO si = {0}; //隐藏进程窗口 si.cb = sizeof(STARTUPINFO); si.lpReserved = NULL; si.lpDesktop = NULL; si.lpTitle = NULL; si.dwFlags = STARTF_USESHOWWINDOW; si.wShowWindow = SW_HIDE; si.cbReserved2 = NULL; si.lpReserved2 = NULL; wstring strPptParam = L""; if (CUtil::IsXpSystem()) strPptParam = L"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9368e9ed54c5281bd48eef71b4ec6d30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/207988840f67f08f418de99ee4dd5669/" rel="bookmark">
			centos7单网卡设置多个IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #!/bin/bash if [ $# != 3 ];then echo "Usage: $0 ad_name st_num end_num" exit 1 fi for i in `seq $2 $3` do ipfile='/etc/sysconfig/network-scripts/ifcfg-'$1 ipfile_2=$ipfile":$i" cp $ipfile $ipfile_2 sed -i "s/^DEVICE.*/DEVICE=$1:$i/g" $ipfile_2 sed -i "s/^IPADDR.*/IPADDR=10.10.10.$i/g" $ipfile_2 done 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bc61f3bda5d1e003b913a997d059bf1/" rel="bookmark">
			运行报错No matching version found for @具体SDK包名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		No matching version found for @xx/xx-xxxxxx@0.0.1 遇到这种情况，指的是你要拿的包没有这个版本的，却确认一下是否真的没有，如果有那就要看缓存情况了，
缓存情况 去看一下搭建的npm私有库是否缓存了老版本，如果有需清理缓存后，重新刷新，即可成功解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7407357f209cf61b4e1a49e7219b284e/" rel="bookmark">
			pip3 安装mysqlclient报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在Liunx搞 Django项目，需要用到数据库，就pip3 安装mysqlclient.
结果报错，不仅报错，还不停得重复连接下载报错的界面，真是头大。
上网查了资料，说是没有mysql的配置源。
根据网上的资料 执行命令yum install mysql-devel，又报错。应该是缺少mysql的yum源
为此一个一个解决。
解决方案：
1，下载对应版本mysql的yum源的rpm包。我的mysql是5.7.31.centos7.8。不知道系统的版本号可以通过命令cat /etc/redhat-release 查看。然后57表示mysql的版本，el7-8表示系统版本号。这个文件也可以去官网下载，Index of /232905https://repo.mysql.com/
wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm 2，下载完了 接着安装rpm包。在文件的目录下执行安装命令。这样进入/etc/yum.repos.d/路径下面会多出两个文件：mysql-community.repo、mysql-community-resource.repo。
rpm -ivh mysql57-community-release-el7-8.noarch.rpm 3，yum源解决的了，就要解决Mysql的配置源，执行命令：两个都选y
yum install mysql-devel 4,最后安装mysqlclient.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c4ced7b14e0540ef3896888a881634c/" rel="bookmark">
			JavaWeb药物管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统由java+sevlet+mysql+idea实现的Java web药物管理系统，实现一个用户登录注册，管理员登录注册，用户购买药物和充值，管理员增删改查药物和用户的功能。
1.登录界面
2.项目界面
3.用户界面
4.充值功能界面(弹窗)
5.购买界面
6.用户购买的记录界面
7.管理员界面
8.添加药物界面
9.用户管理界面
10.MySql数据库界面
部分实现功能代码 充值用户代码
public User rechargeUserMoney(User user) { DBUtil.init(); User getuser = new User(); String sql = "update user set userMoney = userMoney + '" + user.getUserMoney() + "' where userName = '" + user.getUserName() + "'"; int i = DBUtil.addUpdDel(sql); if (i &gt; 0) { DBUtil.closeall(); try { DBUtil.init(); String sql1 = "select * from user where userName = '"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c4ced7b14e0540ef3896888a881634c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148797135864f9dcd495b61cff6f5ebc/" rel="bookmark">
			后端返给前端的数据格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端返给前端的数据格式 一、数据格式简介1. 数据格式分类2. json数据类型 二、单个json三、集合型json四、json可以写嵌套型五、json对象与字符串的相互转化1.json对象转化为字符串2.字符串转化为json对象a. 方法一---JSON.parse()b. 方法二---eval() 六、json数据的截取 一、数据格式简介 1. 数据格式分类 数据格式：json、xml(树形结构文档，类似html) 2. json数据类型 数组型（key:value） 对象型（ object） 二、单个json json标准格式要求写双引号key可以不写引号 var stu={"name":"张三","age":18,"sex":"男"}; console.log(stu);//Object console.log(stu.name);//张三 console.log(stu.age);//18 console.log(stu.sex);//男 三、集合型json 类似数组 var stu1=[ {"name":"张三","age":18}, {"name":"张三","age":18}, {"name":"张三","age":18}, {"name":"张三","age":18}, {"name":"张三","age":18}, {"name":"张三","age":18}, {"name":"张三","age":18}, {"name":"张三","age":18}, {"name":"张三","age":18}, {"name":"张三","age":18}, {"name":"张三","age":18}, {"name":"张三","age":18}, ] console.log(stu1); 对整个集合进行遍历 //对整个集合进行遍历 for(var i=0;i&lt;stu1.length;i++){ console.log(stu1[i]); console.log(stu1[i].name); } 四、json可以写嵌套型 var list=[ { "name":"小黑", "sex":"男", "age":20, "hobby":[ {"name":"听歌"}, {"name":"排球"}, {"name":"跑步"} ] } ]; console.log(list); for-in循环遍历 for(var index in list){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/148797135864f9dcd495b61cff6f5ebc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a44e0182331444ff284f078a252d4970/" rel="bookmark">
			微信支付(Native)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.支付方式
二.Native支付
1.业务流程时序图
2.关键代码
2.1利用google提供的矩阵对象生成二维码
2.2提交请求参数为XML方式的请求
2.3业务controller
一.支付方式 1.付款码支付
付款码支付是用户展示付款码，然后商家通过扫描用户的付款码来完成支付。
2.Native支付
Native支付是商户系统按微信支付协议生成支付二维码，用户再用微信"扫一扫"完成支付的模式。该模式适用于PC网站支付、实体店单品或订单支付、媒体广告支付等场景。 订单金额商家指定，用户扫描后不能更改支付金额。
总结特点∶生成的二维码是微信的URL地址扫描二维码直接打开微信客户端完成支付
3.JSAPI支付 JSAPI支付是用户在微信中打开商户的H5页面，商户在H5页面通过调用微信支付提供的JSAPI接口调起微信支付模块完成支付。应用场景有：
◆ 用户在微信公众账号内进入商家公众号，打开某个主页面，完成支付◆ 用户的好友在朋友圈、聊天窗口等分享商家页面链接，用户点击链接打开商家页面，完成支付◆ 将商户页面转换成二维码，用户扫描二维码后在微信浏览器中打开页面后完成支付 4.微信小程序支付
小程序支付是专门被定义使用在小程序中的支付产品。目前在小程序中能且只能使用小程序支付的方式来唤起微信支付。
5.APP支付
APP支付又称移动端支付，是商户通过在移动端应用APP中集成开放SDK调起微信支付模块完成支付的模式。
6.H5支付
H5支付主要是在手机、ipad等移动设备中通过浏览器来唤起微信支付的支付产品。总结特点:H5支付与JSAPI支付的区别在于H5支付不要求在微信客户端打开H5页面。
7.刷脸支付
用于线下消费场景，无需提前录入人脸，无需拿出手机，在支持微信刷脸支付的机具上，刷脸并输入手机号验证，即可完成付款，使用方便。使用专用3D活体检测摄像头，安全性高。
二.Native支付 1.业务流程时序图 2.关键代码 2.1利用google提供的矩阵对象生成二维码 /** * 生成二维码 * @throws WriterException * @throws IOException */ public static String generateQRCode(String code_url) throws WriterException, IOException { //生成二维码 //设置二维码的尺寸 int width = 200; int hight = 200; //创建map Map&lt;EncodeHintType, Object&gt; hints = new HashMap&lt;EncodeHintType, Object&gt;(); hints.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a44e0182331444ff284f078a252d4970/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eff17aea40f5ce259068a9ec373a8bfb/" rel="bookmark">
			2021-09-09 Java中的日期时间 - yahya
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念 日期：
2019-11-202020-1-1 时间：
12:30:592020-1-1 20:21:59 日期是指某一天，它不是连续变化的，而是应该被看成离散的。
而时间有两种概念，一种是不带日期的时间，例如，12:30:59。另一种是带日期的时间，例如，2020-1-1 20:21:59，只有这种带日期的时间能唯一确定某个时刻，不带日期的时间是无法确定一个唯一时刻的。
本地时间 当我们说当前时刻是2019年11月20日早上8:15的时候，我们说的实际上是本地时间。在国内就是北京时间。在这个时刻，如果地球上不同地方的人们同时看一眼手表，他们各自的本地时间是不同的：
不同的时区，在同一时刻，本地时间是不同的。全球一共分为24个时区，伦敦所在的时区称为标准时区，其他时区按东／西偏移的小时区分，北京所在的时区是东八区。
时区 只根据本地时间还无法唯一确定一个准确的时刻，所以我们还需要给本地时间加上一个时区。时区有好几种表示方式。
一种是以GMT或者UTC加时区偏移表示，例如：GMT+08:00或者UTC+08:00表示东八区。
GMT和UTC可以认为基本是等价的，只是UTC使用更精确的原子钟计时，每隔几年会有一个闰秒，我们在开发程序的时候可以忽略两者的误差，因为计算机的时钟在联网的时候会自动与时间服务器同步时间。
另一种是缩写，例如，CST表示China Standard Time，也就是中国标准时间。但是CST也可以表示美国中部时间Central Standard Time USA，因此，缩写容易产生混淆，我们尽量不要使用缩写。
最后一种是以洲／城市表示，例如，Asia/Shanghai，表示上海所在地的时区。特别注意城市名称不是任意的城市，而是由国际标准组织规定的城市。
因为时区的存在，东八区的2019年11月20日早上8:15，和西五区的2019年11月19日晚上19:15，他们的时刻是相同的：
时刻相同的意思就是，分别在两个时区的两个人，如果在这一刻通电话，他们各自报出自己手表上的时间，虽然本地时间是不同的，但是这两个时间表示的时刻是相同的。
夏令时 时区还不是最复杂的，更复杂的是夏令时。所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。我们国家实行过一段时间夏令时，1992年就废除了，但是矫情的美国人到现在还在使用，所以时间换算更加复杂。
计算夏令时使用标准库提供的相关类，不要试图自己计算夏令时。
本地化 在计算机中，通常使用Locale表示一个国家或地区的日期、时间、数字、货币等格式。Locale由语言_国家的字母缩写构成，例如，zh_CN表示中文+中国，en_US表示英文+美国。语言使用小写，国家使用大写。
对于日期来说，不同的Locale，例如，中国和美国的表示方式如下：
zh_CN：2016-11-30en_US：11/30/2016zh_CN：12000.00en_US：12,000.00 计算机用Locale在日期、时间、货币和字符串之间进行转换。
Date和Calendar 经常看到的日期和时间表示方式如下
2019-11-20 0:15:00 GMT+00:002019年11月20日8:15:0011/19/2019 19:15:00 America/New_York 它们实际上是数据的展示格式，分别按英国时区、中国时区、纽约时区对同一个时刻进行展示。而这个“同一个时刻”在计算机中存储的本质上只是一个整数，我们称它为Epoch Time。
Epoch Time是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数，例如：
1574208900表示从从1970年1月1日零点GMT时区到该时刻一共经历了1574208900秒，换算成伦敦、北京和纽约时间分别是：
1574208900 = 北京时间2019-11-20 8:15:00 = 伦敦时间2019-11-20 0:15:00 = 纽约时间2019-11-19 19:15:00 因此，在计算机中，只需要存储一个整数1574208900表示某一时刻。当需要显示为某一地区的当地时间时，我们就把它格式化为一个字符串：
Epoch Time又称为时间戳，在不同的编程语言中，会有几种存储方式：
以秒为单位的整数：1574208900，缺点是精度只能到秒；以毫秒为单位的整数：1574208900123，最后3位表示毫秒数；以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。 它们之间转换非常简单。而在Java程序中，时间戳通常是用long表示的毫秒数，即：
long t = 1574208900123L; 转换成北京时间就是2019-11-20T8:15:00.123。要获取当前时间戳，可以使用System.currentTimeMillis()，这是Java程序获取时间戳最常用的方法。
标准库API 我们再来看一下Java标准库提供的API。Java标准库有两套处理日期和时间的API：
一套定义在java.util这个包里面，主要包括Date、Calendar和TimeZone这几个类；一套新的API是在Java 8引入的，定义在java.time这个包里面，主要包括LocalDateTime、ZonedDateTime、ZoneId等。 因为历史遗留原因，旧的API存在很多问题，所以引入了新的API。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eff17aea40f5ce259068a9ec373a8bfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9996d9578565807c6aea838cf7faf4f5/" rel="bookmark">
			基于VGG的图像多标签分类算法详解及实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 将深度学习与人物穿着上的服装图像分类结合是目前的研究热点之一,然而目前对服装图像分类主要是分成单个标签单独处理。在现实生活中,随着网络购物等服装商务新模式的出现、复杂决策的迫切需要,单标签服装图像分类已经不能解决问题,多标签服装图像分类成为一个重要的学习问题,展现出巨大的应用价值。多标签服装图像分类的目标是预测每张服装图像的一组服装属性标签。 1. 多标签分类定义 multi-label classification problem：多标签分类（或者叫多标记分类），是指一个样本的标签数量不止一个，即一个样本对应多个标签。
为了方便大家理解多标签，举个例子：一个女生穿个蓝色的裙子
那么黑色加粗字体的标签的可以设置为：
Black
Blue
Dress
Jeans
Red
Shirt
male
famale
.... [“female' ‘red’ ’shirt’]01100001... 通过MultiLabelBinarizer()的fit就可以得到上述label的编码。
2. 多标签分类模型的输出问题 传统在进行实现多分类任务时，常采用softmax函数，其输出为：
z = np.array([-1.0, 5.0, -0.5, 5.0, -0.5]) print(Softmax_sim(z)) # 输出为[ 0.00123281 0.49735104 0.00203256 0.49735104 0.00203256] 通过使用softmax，我们可以清楚地选择标签2和标签4。但我们必须知道每个样本需要多少个标签，或者为概率选择一个阈值。这显然不是我们想要的，因为样本属于每个标签的概率应该是独立的。因此，在完成整个模型构建之后，最后一步中最重要的是为模型的编译选择损失函数。在多标签分类中，大多使用binary_crossentropy损失而不是在多类分类中使用categorical_crossentropy损失函数。这可能看起来不合理，但因为每个输出节点都是独立的，选择二元损失，并将网络输出建模为每个标签独立的bernoulli分布。整个多标签分类的模型为：
from keras.models import Model from keras.layers import Input,Dense inputs = Input(shape=(10,)) hidden = Dense(units=10,activation='relu')(inputs) output = Dense(units=5,activation='sigmoid')(hidden) model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy']） 3. 多标签数据集 本人的数据集有6类，在网上爬虫分类整理得到的。
女性蓝色裙子：female_bule_dress：415张
女性蓝色T袖：female_bule_shirt：311张
女性红色裙子：female_red_dress:259张
男性黑色T袖：male_black_shirt:257张
男性蓝色T袖：male_bule_shirt:247张
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9996d9578565807c6aea838cf7faf4f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8a876675d828eb30cc6db6389dd0122/" rel="bookmark">
			下载安装python扩展库re（整理5个方法，总能有一个成功吧）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.numpy扩展包安装成功2.xlwt扩展包安装未成功 方法一、最基本的尝试方法二、使用镜像源加速，避免超时而失败方法三、pip版本过低，需要更新pip方法四、pip和pip3方法五、仅限安装re扩展包总结 前言 在IDLE中输入import+包名不报错(返回红字)则安装成功
举例：验证扩展包是否安装成功
1.numpy扩展包安装成功 2.xlwt扩展包安装未成功 方法一、最基本的尝试 1.win + r 打开运行窗口，输入cmd，敲回车
2.输入 pip install ***（扩展库名）
举例：安装openpyxl扩展库
pip install openpyxl
方法二、使用镜像源加速，避免超时而失败 1.win + r 打开运行窗口，输入cmd，敲回车
2.输入 pip install ***（扩展库名） -i https://pypi.douban.com/simple/
举例：安装openpyxl扩展库
pip install openpyxl -i https://pypi.tuna.tsinghua.edu.cn/simple/
（一般来说，清华源和豆瓣源二选一，这里是清华源）
方法三、pip版本过低，需要更新pip 1.win + r 打开运行窗口，输入cmd，敲回车
2.输入python -m pip install --upgrade pip
更新那一份没有截图，
建议更新后再次输入此代码验证是否最新。
3.重复方法一或方法二
方法四、pip和pip3 1.执行方法一或方法二，但将pip改为pip3（适用于之前装过python2的情况）
pip和pip3的区别引用于My木岩
原文链接：https://blog.csdn.net/weixin_42840933/article/details/85308265
其实这两个命令效果是一样的，没有区别：
比如安装库openpyxl，pip3 install openpyxl或者pip install openpyxl：只是当一台电脑同时有多个版本的Python的时候，用pip3就可以自动区分用Python3来安装库。是为了避免和Python2发生冲突的。
（2）如果你的电脑只安装了Python3，那么不管用pip还是pip3都一样的。
安装了python3之后，会有pip3
（1）使用pip install XXX ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8a876675d828eb30cc6db6389dd0122/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8abfeb6c893ffd4b815b77d3bb22ed6/" rel="bookmark">
			go语言结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.type关键字
import "fmt" //声明一种数据类型myint,是int的一个别名 type myint int func main() { var a myint =10 fmt.Println("a=",a) fmt.Printf("type of a=%T\n",a) } 2.结构体声明
package main import "fmt" type Book struct { title string auth string } //结构体传参 func ChangeBook(book Book) { //传递一个副本，调用此函数并不会发生改变 book.auth="xiaoz" } func ChangeBook1(book *Book) { book.auth="xz" } func main() { var mybook Book //结构体赋值 mybook.title="golang" mybook.auth="xiaozhang" //%v表示输出任意类型 fmt.Printf("%v\n",mybook) //此时输出的结构体值没有变 ChangeBook(mybook) fmt.Printf("%v\n",mybook) ChangeBook1(&amp;mybook) fmt.Printf("%v\n",mybook) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0588c4ccbef422c843389e59d783f85/" rel="bookmark">
			go语言-map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.map声明变量的方式
//map的声明方式 func main() { //第一种 var myMap1 map[string]string if myMap1==nil{ fmt.Println("map为空") } myMap1=make(map[string]string,10) myMap1["one"]="xiaoming" myMap1["two"]="xiaohong" myMap1["three"]="xiaoli" fmt.Println(myMap1) //第二种 myMap2:=make(map[int]string) myMap2[1]="xiaoming" myMap2[2]="xiaohong" myMap2[3]="xiaoli" fmt.Println(myMap2) //第三种 myMap3:=map[string]string{ "one":"xiaoming", "two":"xiaoli", "three":"xiaohong", } fmt.Println(myMap3) } 2.map的使用方式
//遍历输出函数 func PrintMap(map1 map[int]string) { //map1是引用传递，传递过来的是指针 for key,vaule:=range map1{ fmt.Println("key=",key) fmt.Println("value=",vaule) } } //数值修改函数 func ChangeMap(map1 map[int]string) { map1[2]="hhh" } func main() { map1:=make(map[int]string) //添加 map1[1]="hello" map1[2]="hi" map1[3]="he" //遍历 for key,vaule:=range map1{ fmt.Println("key=",key) fmt.Println("value=",vaule) } //删除 delete(map1,1) //修改 map1[3]="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0588c4ccbef422c843389e59d783f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a75579faa4d8ec7a6b7b25d46a6dd3/" rel="bookmark">
			STM32F429入门（九）：使用固件库新建工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先新建一个文件夹
二、新建文件夹：Project、Libraries、User、Doc,之后就打开keil 5，在project的目录里新建工程，之后在Libraries中添加固件库里的两个文件，分别是：
之后再删除我们不需要的文件：比如Release_Notes.html，还有CMSIS中除了Device和Include的：
在 \Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates中只保留如下选中，其余都删除：
在User文件夹我们需要以下文件，可以从固件库中复制过来\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Project\STM32F4xx_StdPeriph_Templates：
到现在为止，所有文件就大概配置好了，接下来到keil5中将这些文件导入：
嗯...然后开始编译：
出现这么多个错是因为我们的根目录的路径问题，所以我们要将包含根目录的文件的路径添加进去。
可是添加完路径后，也无法解决以上的问题，但是根目录这个时候已经都被包含进去了，然后我们打开main.c下包含的stm32f4xx.h文件，找到#if !defined (USE_STDPERIPH_DRIVER)，单从字面意思理解就是“使用标准外设驱动”，在C/C++预定义中加入“USE_STDPERIPH_DRIVER”就是允许“使用标准外设驱动”了。
也就是说只有预先定义了USE_STDPERIPH_DRIVER后，才会包含stm32f4xx_conf.h头文件。在stm32f4xx_conf.h中，包含了各个驱动脚本的头文件，从而被main.c用到，这就解释了，为什么我们没有在“main.c”中包含"stm32f4xx_conf.h"，而在编译之后却被包含进了"main.c"中。所以，我们需要定义这个USE_STDPERIPH_DRIVER；
之后，再定义一下我们使用此芯片的宏：
最后在魔术棒中：
但是到这一步只解决了一部分错误，还有几十个错，找到了原因是我们有个驱动外设位FMC，它包含了FSMC，407的芯片没有FMC，它称之为FSMC，这是驱动屏幕使用的，这两个文件产生了冲突，所以我们需要在驱动库中找出这两个文件，把它删掉，或者是在编译的时候选择不编译。
之后再全局编译，出现了这个错误：.\Objects\YH-429.axf: Error: L6218E: Undefined symbol TimingDelay_Decrement (referred from stm32f4xx_it.o).
在中断的文件中将所圈的函数删掉即可，我们不需要使用这个函数，到后面我们使用中断时才需要在这里配置我们想要的。
最后，终于搞定啦！
最后的最后，再总结一下吧：
先再本地新建一个文件夹用于存储固件库文件
在工程里面添加组，然后再里面添加文件
编译，会出现很多的错误，然后打开stm32f4xx.h
在工具链中的C/C++选项卡里面指定头文件的目录
在工具链中的C/C++选项卡里面添加两个宏：USE_STDPERIPH_DRIVER、STM32F429_439xx
把stm32f4xx_fsmc.c屏蔽掉，不编译
修改stm32f4xx_it.c文件，去掉#include ”main.h“以及在中断函数下面的一个子函数。
配置仿真器，而且这个配置不是一次配置成功之后就不会变，有时候会莫名其妙地改变。
配置好输出的文件，如Output、Listing，指定好生成文件后生成在哪个文件，我们最开始也已经配置好了。
因为由于编译生成的文件均为垃圾文件，所以我们可以将例程中删除该文件的脚本复制到我们的文件中去。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c90fcdfa8b2a3158091f22a1ef01760b/" rel="bookmark">
			go语言——slice切片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 slice切片声明方式
1.定义切片方式，声明slice1是一个切片，并且初始化，默认值为1，2，3，长度为3
slice1:=[]int{1,2,3} 2.声明slice2是一个切片，但是并没有给slice分配空间，长度为0，里面没有任何值
var slice2 []int 用make为slice2开辟一个长度为3的int型数据，值全部为0
slice2=make([]int,3) 给切片长度赋值
slice2[0]=100 3.将第二方式结合在一起，声明slice1是一个切片，并开辟空间，3个空间，初始化值为0
var slice3[]int=make([]int,3) slice3[0]=11 4.将第三种方式简化一下，通过:=推到出slice是一个切片（最常用）
slice4:=make([]int,3) slice4[0]=22 判断一个slice是否为空
if slice1==nil{ fmt.Println("slice1 是一个空切片") }else{ fmt.Println("slice1不是空切片") } slice切片的使用方式
1.切片容量的追加
//1.指定初始cap //定义一个切片长度为3，容量为5的切片numbers var numbers=make([]int,3,5) fmt.Printf("len=%d,cap=%d,slice=%v\n",len(numbers),cap(numbers),numbers) //向切片numbers追加一个值为1的元素，numbers len=4,cap=5,[0,0,0,1] numbers=append(numbers,1) //向切片numbers追加一个值为1的元素，numbers len=5,cap=5,[0,0,0,1,2] numbers=append(numbers,2) //此时cap容量已经满了，切片会动态开辟初始容量那么大的空间 //向切片numbers追加一个值为1的元素，numbers len=6,cap=10,[0,0,0,1,2,3] numbers=append(numbers,3) //2.没有指定初始cap var numbers1=make([]int,3) //numbers len=3,cap=3,[0,0,0] fmt.Printf("len=%d,cap=%d,slice=%v\n",len(numbers1),cap(numbers1),numbers1) //numbers len=4,cap=6,[0,0,0,1] numbers1=append(numbers1, 1) fmt.Printf("len=%d,cap=%d,slice=%v\n",len(numbers1),cap(numbers1),numbers1) 2.切片容量的截取
func main() { s:=[]int{1,2,3} //s1=[1,2],这种方式s1和s指向同一个地址 s1:=s[0:2] fmt.Println(s1) //修改第一个值之后，切片s和s1都发生了改变 s1[0]=10 //s=[10,2,3] fmt.Println(s) //s=[10，2] fmt.Println(s1) s2:=make([]int,3) //copy可以将底层数组的slice一起进行拷贝，重新开辟了存储空间，深拷贝。此时修改切片里面的值是不会两个切片一起变的 copy(s2,s) println(s2) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d8bc707b30bd224b859ce61e5ae034/" rel="bookmark">
			《格蠹汇编》读书笔记—windbg的使用（中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记本唤醒失败的原因探究（16章） 1)如何产生dmp文件 方法在前一章说过《格蠹汇编》读书笔记—windbg的使用_u012138730的专栏-CSDN博客_windbg怎么用
当唤醒失败了以后，按ctrll+scrolllock 强制蓝屏（需要注册表的设置） 然后就有dmp文件可以分析了。
2)一些常规的命令 分析dmp文件的时候的一些常规操作，之前也介绍过。
设置调试符号路径 .symfix c:\symbols
自动分析 !analyze -v
3)进一步分析dmp文件 当自动分析没有什么价值的时候，尝试用两种方法
第一种：!pcr 了解CPU的当前状态 !pcr是查看处理器控制区，从而了解cpu的当前的状态
!cpuinfo————怎么看当前有几个cpu。
!pcr 0 和 !pcr 1————看0号cpu和1号cpu的具体的状态，看看有什么猫腻。
上图中1 号cpu的当前线程和空闲线程不一样 ，看看是啥。（如果当前线程就是空闲线程那没什么好看的。）
所以查看查看的当前线程
!thread 8688e568——— 通过这个命令可以查看寄存器的上下文等等。。然后程序指针寄存器ip指向用户态空间，说明1号正在用户态执行。因为系统挂死通常是在内核态，所以先不往这个方向探究。
第二种：!locks 查看锁 这个命令查看存在的内核对象锁
显示了系统所持有的资源对象。上图显示了3个。
对于每一个对象，都显示了这个对象的持有线程，等待线程，持有方式。
以上图显示有一个线程特别可疑，以上三个对象都是被87474da8这个线程拥有，且第一个和第三个资源都是独占方式持有
!thread 87474da8——发现这个线程属于 WinLogon 进程 并且 整个线程正在处于等待状态 疑点1：执行过 serenum 和ser2pl 这两个驱动程序的函数 (怎么知道是驱动程序的函数呢)
疑点2：ser2pl这个没有符号文件，所以没有显示出来函数名字，但是看到是这个函数导致的线程进行了等待状态，调用了一个wait函数 。 后面要研究一下 ser2pl是个什么东西
继续研究这个线程，关注跟驱动相关的信息。
执行 .thread /p 87474da8 ——设置为当前线程 (跟 !thread 87474da8 有什么不同吗 栈回溯 更加底层了 显示的内容更多了 )
执行 kvn 查看栈回溯 然后看图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6d8bc707b30bd224b859ce61e5ae034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/123326568179f5311c1be9165ec8a270/" rel="bookmark">
			Windows聚焦图片不更新解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 锁屏壁纸设置为 Windows聚焦 ，锁屏壁纸突然显示为固定的图片，不会自动更新。（特征为锁屏键面不显示花絮，提示，技巧按钮)
方法 将锁屏界面设置为“图片”
打开资源管理器，依次进入C:\Users\用户名\AppData\Local\Packages\Microsoft.Windows.ContentDeliveryManager_\Settings
删除该目录下的所有文件
然后将锁屏界面重新设置为“Windows聚焦” （此时settings目录里重新生成了新的.dat文件）
win+L进入锁屏界面，等待1分钟，壁纸自动更换为聚焦图片。(*可能会等待时间久一点）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81cdad5d19c6e41dd0c6f63e4a66ff85/" rel="bookmark">
			Chrome多设备书签同步方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Chrome多设备书签同步方案 众所周知因为某些原因Chrome无法与它的服务器正常通讯,这就影响到了我们书签的同步,这里介绍一个插件,将书签同步到GitHub或GItee上.
项目地址: ↓
Github项目 | Gitee项目
将项目整个下载下来,解压缩,在浏览器地址栏输入：chrome://extensions/，进入扩展程序管理界面点击【加载已解压的扩展程序】-&gt; 选择项目根目录，导入源码文件夹这里只介绍GitHub操作.进入自己的GitHub创建一个私有项目,随便命名获取Github项目私有访问Token（如何获取：Github -&gt; Settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Generate new token）选择repo,时间选无限,将生成的token拷贝下来,这个只会出现一次,最好拿小本本记下来点击书签工具配置,将仓库地址和token填入,选择保存配置重新点击书签图标工具，就可以选择上传或者下载书签了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd563bd3562cc05ed509dd99417d212b/" rel="bookmark">
			求200 -300 之间的素数和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package test09; import org.junit.Test; /** * @program: TestDemo * @description: 质数又称素数,是指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数 * @author: xin yi * @create: 2021-09-09 09:51 */ public class Demo01 { /** * 求200 -300 之间的素数和 */ @Test public void demo01(){ int sum = 0; int count = 0; for (int k = 200; k &lt; 300; k++) { /*调用封装的判定素数的方法*/ if (isPrime(k)){ System.out.println(k + "是素数"); sum += k; count ++; } } System.out.println("和为：" + sum + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd563bd3562cc05ed509dd99417d212b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16cd5d8736a2b1ae3f46e796b3d7b66d/" rel="bookmark">
			go语言数组学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义数组的方式
1.定义int数组定长数组，初始值为0(在go语言中初始化时初始值均为0)
var arr1 [5] int 2.定义给数组赋初值的数组，没有赋初值的数组的值为0
var arr2 = [5] int {1,2,3,4,5} var arr3 = [5] int {1,2,3} 数组遍历的方式
1.循环遍历数组
var myArray1 [10] int for i:=0;i&lt;len(myArray1);i++{ fmt.Println(myArray1[i]) } 2.利用range遍历数组，会返回一个元素对
for index,value :=range myArray2{ fmt.Println("index=",index,"value",value) } 数组传参
1.静态传参
需要注意的是，传入数组是什么数据类型，在数组传递时就应该是什么数据类型。如代码所示，myArray3属于长度为5的int型数组，因此在printArray函数中定义传递参数就应该是myArray [5]int，名字任意
func printArray(myArray [5]int) { for index,value:=range myArray{ fmt.Println("index=",index,"value=",value) } } func main() { var myArray3 [5] int printArray(myArray3) } 2.动态传参
可以动态修改数组内容，数组类型是动态数组
func printArray1(myArray []int) { //_表示匿名遍历，因为返回两个值，但是index我们不关心，还必须用两个参数接收返回数据，因此就必须用_这种匿名方式接收 for _,vaule:=range myArray{ fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16cd5d8736a2b1ae3f46e796b3d7b66d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb09da9d965ade1817966c5a5b4781c3/" rel="bookmark">
			Java 方法如何允许多个返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景 开发中, 有时抽取方法后, 想要返回两个 int 值, 然而事实上, Java 中方法的返回值最多只能有一个.
不过如果我们想要返回两个值, 可以曲线救国.
即把需要返回的多个值, 都封装到同一个类内, 作为属性.
例如返回两个 int 值, 那么我们可以新建一个 ReturnDTO.java, 然后返回值就是这个类, 把 int 值设值到该类的实例即可
@Data public class ReturnDTO { private int value1; private int value2; } ReturnDTO returnDTO = new ReturnDTO(); returnDTO.setValue1(123); returnDTO.setValue1(456); return returnDTO; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d82456d96fede507071bbdde7bdd3630/" rel="bookmark">
			基于内网搭建node-red
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在一些网络受限的内网环境下，没有办法通过互联网下载和安装node-red及其插件，本次就是要解决这样的问题，实现基于内网环境搭建node-red应用。
环境准备 操作系统centos7.5一台能联网的设备用来下载所需的包 搭建过程 基础包安装 下载Node.js
使用准备好的联网设备到https://nodejs.org/en/download/下载相应的Node.js程序包下载PM2
和node.js不同，PM2不能下载tar.gz包，为了能安装PM2我们要下载它的npm包然后自己制作tarball，在这之前，先确定机器上已经安装了node.js 和 npm。
执行npm-bundle安装命令： npm install -g npm-bundle npm-bundle可以让我们根据pm2和它的依赖创建tar包
在npm-bundle安装完成以后，执行以下命令：
mkdir pm2 cd pm2 npm install pm2 安装完pm2以后，在我们创建的pm2文件夹下打包：
npm-bundle pm2 文件夹下生成了pm2-5.1.0.tgz这个包
3. 拷贝文件
将前面两步得到的安装包复制到内网环境中
4.解压文件
tar xpf 源文件名 -C 解压目录 5.设置系统环境变量
cat &lt;&lt;EOF &gt; "/etc/profile.d/node.sh"export PATH="/opt/node-v10.16.3-linux-armv7l/bin:/opt/pm2/bin:\$PATH" . /etc/profile.d/node.sh 验证安装
安装node-red 在联网的设备上安装node-red
mkdir node-red cd node-red npm install node-red npm install node-red-contrib-kafka-manager 上面的命令除了安装node-red以外，还安装了node-red的kafka插件，我们将node-red文件夹拷贝到内网设备上，就可以启动了。
启动node-red pm2 start /opt/node-red/node-red/node_modules/node-red/red.j 如果要设置开机启动，则可以执行以下命令：
pm2 save pm2 startup 启动完毕以后就可以访问node-red了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d82456d96fede507071bbdde7bdd3630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf69355e512e8821d949f14071160995/" rel="bookmark">
			uni-app ios 在线推送 和 store 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		App.vue onLaunch中添加以下代码
const _self = this; const _handlePush = function(message) { /** * 通过 vuex 来同步页面的数据，仅做演示。 * 实际开发中，这里可能是跳转到某个页面等操作，请根据自身业务需求编写。 */ _self.updatePushMessage(message); uni.navigateTo({ //点击后页面路径 }) }; var platform = uni.getSystemInfoSync().platform; //#ifdef APP-PLUS /* 5+ push 消息推送 ps:使用:H5+的方式监听，实现推送*/ plus.push.addEventListener("click", function(msgc) { // &amp;&amp; msgc.type == 'click' if (platform == 'ios') { //离线是payload为object , 在线时本地创建的为string(本地创建通知只能传string，否则无法传递payload) if (typeof msgc.payload == 'string' &amp;&amp; msgc.payload.indexOf('{') &gt; -1) { var paymsg = JSON.parse(msgc.payload); } else { console.log('obj') var paymsg = msgc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf69355e512e8821d949f14071160995/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d836af2feeee1c0fd0e57d5fa2921046/" rel="bookmark">
			清华学姐教你如何用python处理excel数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
python处理excel数据的方法：1、使用xlrd来处理；2、使用【xlutils+xlrd】来处理；3、使用xlwt来处理；4、使用pyExcelerator来处理；5、使用Pandas库来处理。
下面我们通过示例来看看xlrd、xlwt、xluntils、pyExcelerator和Pandas是如何处理excel文件数据的。
python处理excel数据的方法：
方法一：使用xlrd来处理excel数据
示例1：python读取excel文件特定数据
示例2：python读取excel文件所有数据
方法二：使用xlutils+xlrd来处理excel数据
示例：向excel文件中写入数据
方法三：使用xlwt来处理excel数据
示例1：新建excel文件并写入数据
方法四：使用pyExcelerator来处理excel数据
示例1：读excel文件中的数据
示例2：新建excel文件并写入数据
方法五：使用Pandas库来处理excel数据
示例1：读取excel数据
示例2：操作Excel中的行列
以上就是本篇文章的全部内容，希望能对大家的学习有所帮助。更多精彩内容大家可以关注微信公众号【编程简单学丶】中会有相关资料分享！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb340bd13008f06d25b9d1ec6a131261/" rel="bookmark">
			EF Core NotMapped、Column、Comment
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、NotMapped 模型中的每个实体类型都具有一组属性，这些属性 EF Core 将从数据库中读取和写入数据。 如果使用关系数据库，实体属性将映射到数据库表列。但当某个属性只用于展示，不需要映射到数据库，就需要使用 [NotMapped]属性
[Table("QcwGoodss")] public class Goods : AuditedEntity&lt;Guid&gt; { /// &lt;summary&gt; /// 货品名称 /// &lt;/summary&gt; public string GoodsName { get; set; } /// &lt;summary&gt; /// 货品类型 /// &lt;/summary&gt; public string GoodsType { get; set; } /// &lt;summary&gt; /// 存放位置 /// &lt;/summary&gt; public string Location { get; set; } /// &lt;summary&gt; /// 货品数量 /// &lt;/summary&gt; public int GoodsNum { get; set; } /// &lt;summary&gt; /// 用于显示 /// &lt;/summary&gt; [NotMapped] public string GoodsCode { get { return GoodsName.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb340bd13008f06d25b9d1ec6a131261/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8da02908963c64a7c7e011e5ea8ad2cb/" rel="bookmark">
			XML中的＜![CDATA[]]＞是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 维护项目时，发现一个SQL语句大概意思如下：
select DISTINCT(name) from student where type &lt;![CDATA[&lt;&gt;]]&gt; 'node' and name like '%ABC%' 其实就是一个&lt;![CDATA[]]&gt;是什么的问题，我直接告诉你：
这句SQL在执行时就是
select DISTINCT(name) from student where type &lt;&gt; 'node' and name like '%ABC%' 多说一句，本sql是运行在SqlServer中 "&lt;&gt;" 就是不等于，并且也会把null作为满足条件过滤
&lt;![CDATA[]]&gt;就是为了转义，在XML中很多东西不能被直接写里面，否则XML会错误识别。要写成如下的转义，或者使用&lt;![CDATA[]]&gt;。将转义字符写到&lt;![CDATA[这里]]&gt;
&amp;lt;&lt;小于&amp;gt;&gt;大于&amp;amp;&amp;和号&amp;apos;'省略号&amp;quot;"引号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50bcef0e89920c5dd2ad13970f19a36f/" rel="bookmark">
			instruction-tuning
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		instruction-tuning是在Prompt-tuning之后提出的，它的思想是：在对A做Prompt-tuning之前，先在其他若干的任务之上做Prompt-tuning。如图：
每个任务有多个Prompt，作者使用了10个。
比较注意的是，instruction-tuning的prompt-tunning方法不能是生成式的应该是指令式的。
生成式：
指令式：
因为生成式比较难，而且生成式的prompt-tunning只适用于本任务，没有迁移能力。
引用：
别再Prompt了！谷歌提出tuning新方法，强力释放GPT-3潜力！
Instruction Tuning｜谷歌Quoc V.Le团队提出精调新范式！香过Prompt！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b43124ff3d2c13cdfe9865d6ed22ad/" rel="bookmark">
			学习flutter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、刚开始认识接触flutter还是两年前在大学的时候，那时候前端三大框架鼎力，而移动端的开发更是有数不胜数的相关技术栈可供选择，快应用，小程序再到现在的低代码和无代码平台，前端技术的发展一直是一个高速发展和迭代的过程，真是应了那句老话：“什么时候你学不动了，你就要被社会淘汰了”。现在从事前端开发的工作两年之后再回头看一次这个flutter，在文档看了很久我还是觉得“入门”这两个字是最难的一步，现在每天上班的工作量不是很多，我可以抽出部分时间学习学习这个当初被我遗弃的技术（我当时选择了web开发，用vue框架）。
2、首先布局和交互事件的写法和之前的web开发很不一样，dart语法很不适应，一个部件一个Widget，每一个Widget都可以嵌套很深，相对于html，css和JavaScript分开来写的写法，后者更能一目了然，这可能也是我知道的唯一的缺点了，因为flutter跨平台开发声称是可以媲美原生开发的响应和体验的。一套代码可以编译成安卓、苹果App。我也用过原生的微信小程序开发过应用，这种方式相比于H5又会方便和实用很多，还有如uni-app、mp-vue等框架配合vue来开发的生态，也能让你的小程序开发路上的探索事半功倍。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cddaaac83d5d285c7a241cee87a9093a/" rel="bookmark">
			我与Echarts 的虐缘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：作为一个涉及广泛的前端开发工程师，总会接触到一些奇奇怪怪的编码风格以及技术。而我最近就接触到了 Echarts 与 vue 的结合项目，稍微有点前端基础的程序员，都会觉得 Echarts 就那么几个配置项，按官网开发就行了，然而，我遇到的并不仅仅止步于此，听我娓娓道来。
正文：后端管理系统中用echarts来展示数据，你说奇不奇怪吧，他不仅用，还大量使用，我数数看看有多少，，有12种之多，有的还不单一，还点击下钻，我的个天，真是把echarts 玩出花了，你以为这就完了么，不是的，我们的组建封装，复用，Echart 配置项封装的 我都找不到在哪下手，在官网上知道是那个配置项控制，当我要操作项目的时候，无从下手，就跟拿着筷子夹着大骨头吃一下，怎么啃都不好啃，这样就导致了我一天的收获微乎其微，这样一系列的问题就来了，焦虑呀，刚来这个公司还没一个月，你说一天不敲几行代码你心里慌不慌吧，反正我是挺慌的，你老焦虑不行呀，还是得弄，有一点点入行了吧发现过个星期天跑出去玩两天，一上班完了，发现啥都忘了，，弄一个双y 轴的单位搞一天没出来，在这将近一个月的工作中，从刚开始的想放弃，因为实在是太难了，一天写不出什么功能，后来开窍了一丢丢，真的是一丢丢，找到了点自信，觉得自己还可以再坚持坚持，就这样反反复复，为什么我今天来发一篇博客呢，是因为我现在就是完了两天，然后上班发现自己都忘了，现在还没下班，但是我在看代码，实在扛不住了，跟别人聊天吧，发现不知道聊点什么来调节这种心情，想出去走一圈，又怕说擅离岗位，真么这么胆小呢，还有，我的工作性质是外包，到现在还没体现外包的不好，也不知道自己能在这家公司待多长时间，我小伙伴告诉我，你要给自己一个适应期，如果这个适应期内你觉得不开心或者太难了，那就可以考虑去换个行业或者工作了，觉得她讲的好有道理，我也想了想，是这个项目太难了，还是我太菜了，或许两者都有吧，你说问别人吧，你能怎么问echarts 呢，就那样，哎，烦恼
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc3996064c0a7fa7bc4b1889a804b9d6/" rel="bookmark">
			this 的指向问题和箭头函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.this的指向问题 在es5中，this的指向是非常混乱的，
1：在方法中，this指向调用者
2：没有调用者时，this指向window
3：构造函数中，指向创建出来的实例本身改变this指向的方法
强制改变this指向 call apply bind
call方法 语法 call(this的指向,function的参数)
apply方法 语法 apply(this的指向,[function的参数])
bind本身不会去执行要改变this指向的这个方法,而是返回一个已经被改变了this指向的新方法 2.箭头函数 es6中的箭头函数，就是为了解决 es5 中this指向混乱的问题的箭头函数没有this，它的this来自上下文的父级，并且指向上下文的父级箭头函数的this指向不会发生改变，声明时便永久的确定了箭头函数是匿名函数，不能作为构造函数，不能使用new箭头函数没有arguments，可以使用展开运算符进行解决“…”箭头函数不能通过call，apply，bind方法直接修改它的this指向箭头函数没有原型属性 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0de637089270bcab6bcd54a1228b936/" rel="bookmark">
			【深度学习】深度学习基础-Warm_up训练策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 学习率是最影响性能的超参数之一，如果我们只能调整一个超参数，那么最好的选择就是它。 其实在我们的大多数情况下，遇到 loss 变成 NaN 的情况大多数是由于学习率选择不当引起的。
warmup介绍 warmup可以称为训练热身。由于神经网络在刚开始训练的时候是非常不稳定的，因此刚开始的学习率应当设置得很低很低，这样可以保证网络能够具有良好的收敛性。但是较低的学习率会使得训练过程变得非常缓慢，因此这里会采用以较低学习率逐渐增大至较高学习率的方式实现网络训练的“热身”阶段，随着训练的进行学习率慢慢变大，到了一定程度，以设置的初始学习率进行训练，接着过了一些inter后，学习率再慢慢变小；学习率变化：上升——平稳——下降；
warmup具体步骤 启用warm up，设置warm up setp（一般等于epoch*iter_one_epoch），当step小于warm up setp时，学习率等于基础学习率×(当前step/warmup_step)，由于后者是一个小于1的数值，因此在整个warm up的过程中，学习率是一个递增的过程！当warm up结束后，学习率以基础学习率进行训练，再学习率开始递减。
warmup学习率计算公式：
其中base_lr是初始学习率，后面分式就是用来控制warm_up操作的，分子是模型训练当前迭代的step步数，分母中warm_epoch是设置的热身的epoch数(例如另epoch=5)，iter_one_epoch是训练集迭代一个epoch需要的步数。
从上式中可以看出，前warm_epoch个训练阶段，随着step增加，学习率是递增的，一直到warm_epoch时，分子等于分母，此时学习率增长到初始学习率的值，warmup阶段完成。
学习率变化曲线： 应用场景 （1）训练出现NaN：当网络非常容易nan时候，采用warm up进行训练，可使得网络正常训练；
（2）过拟合：训练集损失很低，准确率高，但测试集损失大，准确率低，可用warm up；
应用原理 这个问题目前还没有被充分证明，目前效果有：
（1）有助于减缓模型在初始阶段对mini-batch的提前过拟合现象，保持分布的平稳；
（2）有助于保持模型深层的稳定性。
参考链接：https://blog.csdn.net/weixin_40051325/article/details/107465843
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3bec0c92242cedc153247e9a97e040a/" rel="bookmark">
			python解决读取文件时中文乱码的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用python读取文件的时候，报了下面的错误：
UnicodeDecodeError: ‘utf8’ codec can’t decode byte 0xb1 in position 0: invalid start byte.
我当时的现象是cat可以正常读出中文，vim里面中文乱码的，python读文件加上了encoding='utf8’也不好使
这种问题很是头疼
解决方法
更改文件的编码格式：
vim/vi编辑器（进入esc命令模式），执行命令，set fileencoding=utf-8，然后回车，此时我们将文件的格式改成了utf-8格式的了，使用utf-8读取，就能正确的读出文件
VIM配置
vim /etc/vim/vimrc 末尾追加
set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936 set termencoding=utf-8 set encoding=utf-8 脚本
os.system("vim -S script.vim %s" % file_name) # cat script.vim set fileencoding=utf-8 wq! 就这样的就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516f52b2372a9bf1ea5c2af523939386/" rel="bookmark">
			Hebb学习规则与Hopfield神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文简单介绍了一下Hebb学习规则和Hopfield神经网络，并讨论了二者的特性和意义，以及它们之间的联系。最后代码实现了一个简单Hopfield网络，能够记忆并联想回忆出一张图片。
Hebb学习规则 Hebb学习规则是一种神经网络连接权值的调整方法，它基于心理学家D.O.Hebb提出的“突触修正”假设。该假设指出当该突触前神经元和后神经元同时兴奋或抑制时，则该突触连接增强；反过来，若同一时刻两者状态相反，则突触连接减弱。神经元模型以及具体的调整公式如下：
Δ W j = η f ( W j T X ) X \Delta W_j = \eta f (W_j^T X)X ΔWj​=ηf(WjT​X)X
其中， η \eta η为学习率， f ( W j T X ) f (W_j^T X) f(WjT​X)为神经元 j 的输出， f ( ) f() f()为激活函数，一般为 s g n ( ) sgn() sgn()函数，即大于某一阈值输出值为1，否则输出值为-1。
使用这个规则更新突触连接权值后，当突触前神经元再次发出同样的刺激时，后神经元更容易兴奋或抑制。具体可参考巴甫洛夫的条件反射实验，通过同时刺激狗相应的听觉和控制分泌唾液腺体的神经元，人为地增强了两者的连接。通过重复刺激，最后就在两个原本毫不相干的神经元中建立了很强的突触连接，制造出了全新地条件反射。
Hopfield神经网络 Hopfield网络是一种单层反馈神经网络，具有联想记忆的功能。在使用时通过灌输式学习的方法对其进行训练，即完成记忆，然后在推理阶段通过反馈机制对网络状态进行更新，最后就可以实现联想的功能。Hopfield神经网络可分为离散型(DHNN)和连续型（CHNN）两种，这里主要介绍DHNN。
离散型Hopfield神经网络 离散型Hopfield神经网络（DHNN）的状态是随其迭代的轮数而改变的，所以其状态在时间轴上是离散的，这与下面的CHNN不同。其网络结构如下：
可以发现，每个神经元的输出都将作为所有神经元的输入，即当下任何一个神经元的状态（输出）都将影响所有神经元的下一个状态。有时候DHNN中的神经元没有自反馈，这在具体实现时直接将权重矩阵中对角线上的元素置为0即可。在实际测试中发现，对简单任务有无自反馈连接并不影响DHNN的功能和最终结果。
每个神经元的输出有1和-1两种情况，分别对应着神经元的兴奋和抑制状态，而整个网络的状态由所有神经元的状态决定，因此该网络总共就有 2 n 2^n 2n种状态，其中 n n n为神经元个数。
DHNN功能的实现分为两个阶段：记忆阶段和联想阶段。在记忆阶段输入想要记忆的模式，通过特定的规则调整连接权值，然后在联想阶段给出相似的输入，网络通过迭代能够逐渐收敛于已经记忆的模式，就实现了联想的功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/516f52b2372a9bf1ea5c2af523939386/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/280e1b1d4523f6001002355e8d43f912/" rel="bookmark">
			Derivative finite-differencing step was artificially reduced to be within bound constraints.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		警告: Derivative finite-differencing step was artificially
reduced to be within bound constraints. This may adversely affect convergence. Increasing distance between bound constraints, in dimension 172, to be at least 1.1102e-16 may improve results.
解答：
Also, as the warning message tells you, your bounds are very tight in absolute terms. It would be advisable to change the units of your coefficients so that they, and their bounds, are on the order of 1 instead of 1e-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/280e1b1d4523f6001002355e8d43f912/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab19629b358d0278f5cc5e6428b3189b/" rel="bookmark">
			史上最全的Schnorr签名方案和BLS签名方案的全面对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
Schnorr 签名算法最初是由德国密码学家 Claus Schnorr 于 2008 年提出的，而来自区块链协议公司 Blockstream 的密码学家 Gregory Maxwell、Pieter Wuille 等人，则在 2018 年提出了一种名为 MuSig 的 Schnorr 签名方案，这也是我们即将探索的签名方案。
而 BLS 签名方案，最初是由斯坦福大学教授 Dan Boneh 等人于2001年便提出的一种方案，目前则在 Boneh 教授等人的完善下，变得更适用于区块链。
总的来说，两大签名方案各有千秋，它们在不同的场景下都有各自的优势。
原文 | Stepan
目录
目录
1、椭圆曲线数字签名算法（ECDSA）
2、什么是 Schnorr 签名？
3、Schnorr 签名的批量验证
4、Schnorr 签名的密钥聚合
5、MuSig：由 Blockstream 提出的 Schnorr 签名方案
6、默克尔多重签名（Merkle Multisig）
7、什么是 BLS 签名方案？
8、BLS 签名的魔法
9、BLS 签名方案的具体原理
10、BLS 签名的签名聚合
11、BLS 签名的密钥聚合和 n-of-n 多重签名
12、子群多重签名方案（m-of-n multisig）
13、BLS 签名可能的应用场景
14、BLS 签名的弊端：配对效率低下
15、结论
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab19629b358d0278f5cc5e6428b3189b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49eb25bdebfecd00ecd9897663a03d4c/" rel="bookmark">
			C&#43;&#43;MFC常用控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		_按钮(Button)
_编辑框(Edit Control)
_标签(Static Text)
_超级列表框(List Control)
_分组框(Group Box)
_复选框(Check Box)
_树形框(Tree Control)
_图片框(Picture Control)
_文件选择框(MFC EditBrowse Control)
_选择夹(Tab Control)
_组合框(Combo Box)
_avi短动画
命令按钮(Command Button Control)
自定义控件(Custom Control)
日期选择框(Date Time Picker)
扩展组合框(Extended Combo Box)
滚动条_水平(Horizontal Scroll Bar)
热键编辑框(Hot Key)
列表框(List Box)
按钮(MFC Button Control) 跟button区别不大
颜色选择框(MFC ColorButton Control)
字体选择框(MFC FontComboBox Control)
超链接(MFC Link Control)
指定格式编辑框(MFC MaskedEdit Control)
带下拉菜单的按钮(MFC MenuButton Control)
_属性编辑框(MFC PropertyGrid Control)
文件列表框(MFC ShellList Control)
文件树形框(MFC ShellTree Control)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49eb25bdebfecd00ecd9897663a03d4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02b4e5619edc624e333595ec2e233b84/" rel="bookmark">
			uboot移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、我们知道uboot就是一个Bootloader。但是，arm不像我们的pc机一样，用一个老毛桃随便找一个网站下一个windows镜像就可以直接装了。
我们的uboot对应的就是老毛桃里面刷的引导程序。
虽然uboo支持很多架构很多不同的厂家的板子，但是UBOOT它不具备通用性。
跟我们的电脑不一样，电脑无论是华为的，小米的，华硕的老毛桃刷的底层引导程序都i是一样的。
所以uboot移植是要跟做手术一样对一些东西进行一些裁剪和配置。让uboot适配我们板子。
下面我们说一下移植的步骤。
1）首先肯定要去下载一个ubbot的源码。
没有源码你怎么去裁剪和配置。
直接百度uboot的官网然后找source code(源码)
下载和我们的在我们的开发板所用的测试板发布之后的版本且时间要最好相近一点。这样的版本适配性才是最好的。比如说我现在用的是SAMSUNG的a9exyons的芯片，三星的这个芯片的发行板叫origen。
这个发行版的时间大概在12年所以我们下载13年的就可以了。
下载完之后把它复制到uboot里面，并且解压出来。
这样我们就得到了uboot的源码。
这些是源码的分类。
1)API:就是接口的一下实现。
2)arch:就是架构类型，
3）board:J就是板子的类型大部分大公司的发行板都有
这些都是公司名称，有熟悉的SAMSUNG和ST等等，这些公司下的目录就是他们发行的板子类型
我们要找的origen也在里面。
uboot之所以支持很多处理 器就是因为它把常用的架构和公司的板子都写进去了，有大公司发行板子，它又重新写进去，所以版本不要最新，只要最近。
4)COMMON:就是我们通用的uboot命令就是我们在板子的终端上按下help下所打印的命令，比如我们的设置环境变量的命令。
5）fs：文件管理系统
6）drinver：就是驱动的设备。
7）net:网络文件，比如我们之前用的TFTP和nfs都在这里。
8）MAKEFILE:这个是写好的makefile辅助我们去编译代码。
。。。。。。。。。。。
——————————————————————
以上讲了Uboot里面大概有什么东西。下面讲移植的过程。
1、指定我们当前的硬件平台，比如我们是samsung的
origen芯片。我们就用
make origen_config
这样makefile就知道我们的硬件平台了，然后就不会编译其它的硬件。
2、指定编译器。
我们是arm架构肯定得用arm的编译器，所以你得告诉makefile的用ARM的编译器
vi Makefile
//CORSS_COMPILE (找到交叉编译)
改成这个样子，指定用arm-none-linux-guneabi-
这个交叉编译工具链去编译。
3、编译Uboot
make
4、消除中间文件，只要目标文件。那些对与我们没有用，的编译过程中产生的中间文件我们要删掉
用makeclean
5、恢复原来到make之前的状态用
make distclean
——————————————————————
这样make出来的.bin的文件是只使用于三星的origen的这个评估板用的。并且只能在这个评估板上面用，换另一个板子就不可以了。那我们的芯片类型知识和origen的芯片一样，那些板子的硬件不一样，所以这个uboot肯定还不行。比如电源接口，网络接口，串口，这些东西和origen的板子的地址和配置方式完全不一样。
所以我们还要对这些东西做一个配置。
1)我们先重uboot下面 的三星的origen复制一个，并改上我们自己的名字fs4412，然后makefile的名字也要改。
2）添加三星加密引导方式。
查看我们下的uboot很明显它没有bios的程序，这是因为，三星把这些东西不设为开源，加密了，这加密文件需要我们自己去获取。
将资料中“移植相关文件”下的sdfuse_q、CodeSign4SecureBoot目录拷贝到uboot源 码的顶层目录下
3）添加调试代码（点灯法）
添加我们一上电的初始现象代码。
4）添加编译脚本
我们之前添加了三星的加密引导，但是这个加密引导得和其它文件一起编译才行啊，要不然放在目录里面上面都不干。
使用make命令编译时只链接uboot源码中的相关代码，而我们添加的初始引导加密的 代码不会被连接到u-boot.bin中，所以这里我们自己编写编译脚本build.sh，这个脚本 中除了对uboot源码进行配置和编译外还将初始引导加密代码链接到了u-boot.bin上， 最终生成一个完成的uboot镜像u-boot-fs4412.bin
这样改以后可以运行，但是你会发现我们的超级终端上面都不显示，这是因为，串口的有问题，你运行起了，但是信息不知道打过哪里去了。
5)实现串口输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02b4e5619edc624e333595ec2e233b84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afb39f13af356b00af99ca8e9980ebc2/" rel="bookmark">
			4.数仓项目—hadoop3.1.3的安装和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数仓项目—hadoop3.1.3的安装和配置1. hadoop3.1.3的安装2. 配置hadoop3.1.3core-site.xmlhdfs-site.xmlyarn-site.xmlmapred-site.xmlworkers 3. 配置历史服务器配置mapred-site.xml 4. 配置日志聚集功能配置yarn-site.xml 5. 分发配置文件6. 格式化7. 启动集群配置hadoop-env.sh配置yarn-env.sh配置mapred-env.sh 8. hadoop群起脚本9. 集群时间同步9.1 时间服务器配置（必须root用户）9.2 其他机器配置（必须root用户） ☆ 数仓项目—hadoop3.1.3的安装和配置 服务器hadoop103服务器hadoop103服务器hadoop105HDFSNameNode DataNodeDataNodeDataNode SecondaryNameNodeYarnNodeManagerResourcemanager NodeManagerNodeManager 1. hadoop3.1.3的安装 hadoop-3.1.3.tar.gz
hadoop-lzo-0.4.20.jar
#上传到服务器，解压 tar -zxvf hadoop-3.1.3.tar.gz -C /opt/module #配置环境变量,本机是centos6.8 vim /etc/profile #HADOOP_HOME export HADOOP_HOME=/opt/module/hadoop-3.1.3 export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:$HADOOP_HOME/sbin 2. 配置hadoop3.1.3 core-site.xml &lt;configuration&gt; &lt;!-- 指定NameNode的地址 --&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://hadoop103:8020&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定hadoop数据的存储目录 官方配置文件中的配置项是hadoop.tmp.dir ,用来指定hadoop数据的存储目录,此次配置用的hadoop.data.dir是自己定义的变量， 因为在hdfs-site.xml中会使用此配置的值来具体指定namenode 和 datanode存储数据的目录--&gt; &lt;property&gt; &lt;name&gt;hadoop.data.dir&lt;/name&gt; &lt;value&gt;/opt/module/hadoop-3.1.3/data&lt;/value&gt; &lt;/property&gt; &lt;!-- 配置HDFS网页登录使用的静态用户为atguiug --&gt; &lt;property&gt; &lt;name&gt;hadoop.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afb39f13af356b00af99ca8e9980ebc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8794993f479f37366cc811da2569fbe0/" rel="bookmark">
			【教科书】软件测试系统测试报告实例（满分模板）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号：程序员阿沐
系统测试总结报告
1 引言 1.1 编写目的 1.2 背景 1.3 用户群 1.4 定义 1.5 测试对象 1.6 测试阶段 1.7 测试工具 1.8 参考资料 2 测试概要 2.1 进度回顾 2.2 测试执行 2.3 测试用例 2.3.1 功能性 2.3.2 易用性 3 测试环境 3.1.1 软硬件环境 3.1.2 网络拓扑 4 测试结果 4.1 Bug趋势图 4.2 Bug优先级分布 4.3 问题类型分布 4.4 Bug模块分布图 4.5 最近提交缺陷图 4.6 Bug状态分布 5 测试结论 5.1 功能性 5.2 易用性 5.3 可靠性 5.4 兼容性 5.5 安全性 6 分析摘要 6.1 覆盖率 6.2 遗留缺陷的影响 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8794993f479f37366cc811da2569fbe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f88aa174f634d3eb5d38a45c66f9bb/" rel="bookmark">
			vuforia&#43;unity,使用一段录制好的视频流进行目标识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vuforia+unity,使用一段录制好的视频流进行目标识别（转载请说明出处） 因为项目需要，使用一段事先录制好的视频进行增强现实。笔者一开始想在unity或vuforia中实现，但长时间摸索，不得不承认此思路不行。在vuforiaSDK中的ARCamera是连接现实世界和虚拟世界的桥梁，现实世界的相机用来输入视频流，虚拟世界的相机用来设置增强现实的内容，然而vuforia并不开源，想要修改ARCamera的输入源从修改camera属性方面至少我现在没找到相应的方法。
笔者的方法是从硬件方面着手，在电脑系统里安装一个虚拟摄像头。
1.安装虚拟摄像头WeCam 安装完以后在设备管理器会发现多了一个虚拟摄像头，先禁用笔记本电脑中的摄像头。e2eSoft WeCam为虚拟摄像头。
2.添加视频文件 在WeCam中添加事先录制好的视频文件
3.设置好unity的内容 unity+vuforia的AR设置没变，与原先一致，不会的可以查看其他教程。本文使用的是Model Target识别。
4.结果 首先打开WeCam的输出按钮，设置相应的内容。
在点击播放按钮后在运行unity。结果如下：
欢迎大佬指教。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab86388b4fe4d00f3fd6f5e1d3c947f/" rel="bookmark">
			Package should contain a content type part [M1.13]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 今天项目导出时，报错了，
Package should contain a content type part [M1.13]异常的解决方式，这个问题已经
问题描述： 提示：这里描述项目中遇到的问题：
放弃的
原因分析： 主要是xl,xlsx的格式问题，
解决方案： 新建一个对应的xls 文件COPY新的导出名称就可以完成了。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/284/">«</a>
	<span class="pagination__item pagination__item--current">285/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/286/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>