<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b6be5d6787af3f62550fc2a27f8f159/" rel="bookmark">
			window10官网镜像安装到VMware出现问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这样就可以正常启动了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb86e472c4165501469155e4b9248843/" rel="bookmark">
			HOW2J.CN - 学习笔记（类和对象）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用 引用的概念，如果一个变量的类型是 类类型，而非基本类型，那么该变量又叫做引用。
1. 引用和指向
new Hero(); 代表 创建 了一个Hero对象
但是也仅仅是创建了一个对象，没有办法访问它
为了访问这个对象，会使用 引用 来 代表 这个对象
Hero h = new Hero(); h这个遍历是Hero类型，又叫做引用
=的意思指的h这个引用 代表 右侧创建的对象
“代表” 在面向对象里，又叫做“指向”
public class Hero { String name; // 姓名 float hp; // 血量 float armor; // 护甲 int moveSpeed; // 移动速度 public static void main(String[] args) { // 创建一个对象 new Hero(); // 使用一个引用来指向这个对象 Hero h = new Hero(); } } 2. 多个引用，一个对象
引用有多个，但是对象只有一个。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb86e472c4165501469155e4b9248843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21874e68dee8e7c852092ba98e60bbef/" rel="bookmark">
			thymeleaf手动渲染@{}的问题与解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 最近写了一个项目，然后想利用TemplateEngine实现thymeleaf的手动渲染，将生成的html页面加入Redis缓存，提高项目访问速度。
二、SpringBoot 1.x实现 以前使用的maven版本如下所示：
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- thymeleaf --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 可以看出是springboot1.x版本。
附上该版本thymeleaf手动渲染的实现。
@RequestMapping(value = "/to_list", produces = "text/html") @ResponseBody public String toGoods(Model model, MiaoshaUser user, final HttpServletRequest request, final HttpServletResponse response) { //取缓存 String html; html = redisService.get(GoodsKey.getGoodsList(), "", String.class); if (html != null) {//如果缓存有这个页面 return html; } else {//如果没有这个页面 //访问数据库获取商品数据 List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo(); if (user !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21874e68dee8e7c852092ba98e60bbef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320d43481235bd1c4198df0d72d44836/" rel="bookmark">
			K8s集群重新初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习来源： 51cto: https://edu.51cto.com/sd/518e5
腾讯课堂: https://ke.qq.com/course/2738602
K8s集群环境搭建：https://blog.csdn.net/qq_26900081/article/details/109291999
学习过程中一不小心把K8s给折腾坏了，重新初始化一下群里，一顿操作猛如虎，万幸恢复如初了。
master1上的命令kubectl都执行不了，众node上docker ps发现都容器全部不在了。
vi /var/log/messages 错误信息: K8s node "localhost.master1.131" not found
1、所有节点（master和node）重置：kubeadm reset 2、我修改了配置文件（所有master节点），所以重新配置一下： kubeadm config images pull --config ./kubeadm-config.yaml
3、初始化(master1主节点)：kubeadm init --config kubeadm-config.yaml --upload-certs
4、将master2、master3和所有node节点加入集群：参考 https://blog.csdn.net/qq_26900081/article/details/109331192
5、执行以下命令解决错误，需要重新配置这个目录.kube和文件：
错误信息：Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of "crypto/rsa: verification error" while trying to verify candidate authority certificate "kubernetes")
[root@localhost ~]# rm -rf $HOME/.kube [root@localhost ~]# mkdir -p $HOME/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/320d43481235bd1c4198df0d72d44836/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb93cf93637b14ee8c37adedf0a46093/" rel="bookmark">
			decimal这个数据类型的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		decimal(18,0)，数值中共有18位数，其中整数占18位，小数占0位。baiDecimal(n,m)表示数值中共有n位数，其中整数n-m位，小数m位。
例：decimal(2,1)，此时，插入数据“12.3”、“12”等会出现“数据溢出错误”的异常；插入“1.23”或“1.2345...”会自动四舍五入成“1.2”；插入“2”会自动补成“2.0”，以确保2位的有效长度，其中包含1位小数。
当用 int类型会有溢出时，可以用 decimal 类型进行处理，把结果可以用 convert 或是 cast 进行转换。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fbb4e7485fb306491d3d2573cec08e4/" rel="bookmark">
			聚类-kmeans
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# -*- coding: utf-8 -*- from matplotlib import pyplot as plt import numpy as np import pandas as pd #计算距离 def GetDistance(v1,v2): distance =np.sqrt(np.sum( (v1-v2)**2)) return distance def kmeans(data,k): nSamples , dim =data.shape #初始化K个质心 Centroids = np.zeros((k,dim)) indexs = [] indexs = np.random.randint(0,nSamples,size =k) Centroids = data[indexs , :] ClusterData = np.array(np.zeros((nSamples,)),dtype = int) minIndex = 0 ClusterChanged = True while ClusterChanged : #计算每个样本与质心的距离 ClusterChanged = False for i in range(nSamples) : minDistance =1000000 #定义一个很大的值 for j in range(k) : distance = GetDistance(data[i,:] , Centroids[j,:]) if minDistance &gt; distance : minDistance = distance minIndex = j #样本的归属 if ClusterData[i,] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fbb4e7485fb306491d3d2573cec08e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d22cfac75b2da745e95e22e9f2bc9657/" rel="bookmark">
			Xpath
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xpath解析：最常用且最便捷高效的一种解析方法
属性定位：
r=tree.xpath('//div[@class="song"]') #//是定位到div的 #@是定位到class属性 取属性值，网址链接
实例爬取58同城二手房信息 import requests from lxml import etree if __name__ == "__main__": #爬取到页面源码数据 headers={'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:74.0) Gecko/20100101 Firefox/74.0'} url='https://qd.58.com/ershoufang/?PGTID=0d100000-0007-a561-8676-fc901c0b0a3b&amp;ClickID=2' page_text=requests.get(url=url,headers=headers).text #数据解析 tree=etree.HTML(page_text) li_list=tree.xpath('//ul[@class="house-list-wrap"]/li') fp=open('58.txt','w',encoding='utf-8') #//表示从任意地方开始定位 for li in li_list: title=li.xpath('./div[2]/h2/a/text()')[0] print(title) fp.write(title+'\n') xpath 爬取图片 爬取图片
import requests from lxml import etree import os if __name__ == "__main__": #爬取到页面源码数据 headers={'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:74.0) Gecko/20100101 Firefox/74.0'} url='http://pic.netbian.com/4kmeinv/' res=requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d22cfac75b2da745e95e22e9f2bc9657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/790f6afb4b995efdab540a52d22f93ec/" rel="bookmark">
			自学python需要安装什么软件-零基础入门Python怎么学习？老男孩python用什么软件...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在培训学习Python时，怎么才能学好Python？随着Python技术的发展，越来越多的人开始学习Python编程语言，那么零基础入门Python该怎么学习？
1.要养成良好的代码编写习惯，注重细节问题。
2.要锻炼独立解决问题的能力，如果自己解决不了就去利用百度等搜索引擎，还解决不了就需要问老师了，不管如何解决问题但一定不能堆积问题。解决问题时要有自己思考的过程，这对提升解决问题能力有很大帮助。
3.在上课时必须认真听讲并遵循老师的节奏。如果课堂上学习不好，那么课后弥补将会浪费很多时间和精力。
4.必须多敲代码并加以练习，这是重点，只听视频并观看视频是没有用的。许多人可以在教室学习，在课后看视频复习，但并没有练习操作，就没有自己的逻辑思维，这就是代码敲少了不熟悉，敲多了自然而然就会敲，也慢慢会形成自己的编程思维，熟能生巧么。
5.学会思考，要有举一反三的能力，有自己独有的编程思维，不要怕苦怕累，坚持下去一定会成功的。
Python培训的学习时间有限，一般只有四至六个月，要学习的内容却是非常多，要尽量做到全身心的投入，哪怕是周末也不要放松，努力辛苦几个月换取一个好工作是非常值得的。而且一旦进入IT互联网行业，就会一直走在学习的路上，不断的学习新的知识，接触着新的领域。
学习是对自己最好的投资，机会是留给有准备的人，想要众多的IT工作者中脱颖而出，就需要拥有高深的技术，学习增值是必不可少的。学习之路，是贵在坚持的!对Python感兴趣的可以深入了解一下，还可关注老男孩教育，Python课程紧跟企业技术潮流，实际企业应用技术，打造行业标杆，全企业真实案例结合理论授课，让您更快速的成为合格的Python开发工程师。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e6ff100822a762184ebad5d099bcee0/" rel="bookmark">
			lotus 扇区状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* * Empty &lt;- incoming deals | | | v *&lt;- WaitDeals &lt;- incoming deals | | | v *&lt;- Packing &lt;- incoming committed capacity | | | v | GetTicket | | ^ | v | *&lt;- PreCommit1 &lt;--&gt; SealPreCommit1Failed | | ^ ^^ | | *----------++----\ | v v || | *&lt;- PreCommit2 --------++--&gt; SealPreCommit2Failed | | || | v /-------/| * PreCommitting &lt;-----+---&gt; PreCommitFailed | | | ^ | v | | *&lt;- WaitSeed -----------+-----/ | ||| ^ | | ||| \--------*-----/ | ||| | | vvv v----+----&gt; ComputeProofFailed *&lt;- Committing | | | ^--&gt; CommitFailed | v ^ | SubmitCommit | | | | | v | *&lt;- CommitWait ---/ | | | v | FinalizeSector &lt;--&gt; FinalizeFailed | | | v *&lt;- Proving | v FailedUnrecoverable UndefinedSectorState &lt;- ¯\_(ツ)_/¯ | ^ *---------------------/ */ Empty SectorState = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e6ff100822a762184ebad5d099bcee0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81c3b7d13371bc29d1abc5bcc7faedb0/" rel="bookmark">
			css的兼容性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、为什么会出现css的兼容性问题
二、如何解决css的兼容性问题
1、双倍浮动BUG
2、表单元素行高不一致
3、IE6（默认16px为最小）不识别较小高度的标签（一般为10px）
4、图片添加超链接时，在IE浏览器中会有蓝色的边框
5、最小高度min-height不兼容IE6
6、图片默认有间隙
7、按钮默认大小不一
8、百分比BUG
9、鼠标指针BUG
10、透明度设置，IE不识别opacity属性
11、上下margin重叠问题
12、给子元素设置margin-top.应用在了父元素上
一、为什么会出现css的兼容性问题 浏览器众多，对css解析出的效果不一致。浏览器的内核（即浏览器的渲染引擎） 二、如何解决css的兼容性问题 1、双倍浮动BUG 描述：块状元素设置了float属性后，又设置了横向的margin值，在IE6下显示的margin值要比设置的值大；解决方案：给float的元素添加 display:inline;将其转换为内联元素； 2、表单元素行高不一致 解决方案：　①、给表单元素添加vertical-align:middle;　②、给表单元素添加float:left； 3、IE6（默认16px为最小）不识别较小高度的标签（一般为10px） 解决方案：　①、给标签添加overflow:hidden;　②、给标签添加font-size:0; 4、图片添加超链接时，在IE浏览器中会有蓝色的边框 解决方案：　给图片添加border:0或者border：none; 5、最小高度min-height不兼容IE6 解决方案：　①、min-height:100px;_height:100px;　②、min-height:100px;height:auto!important;height:100px; 6、图片默认有间隙 解决方案：　①、给img添加float属性；　②、给img添加display：block; 7、按钮默认大小不一 解决方案：　①、如果按钮是一张图片，直接用背景图作为按钮图片；　②、用a标记模拟按钮，使用JS实现其他功能； 8、百分比BUG 描述：父元素设置100%，子元素各50%，在IE6下，50%+50%大于100%；解决方案：　给右边的浮动元素添加clear:right； 9、鼠标指针BUG cursor:hand 只有IE浏览器识别；　cursor:pointer;IE及以上浏览器和其他浏览器都识别（手型）； 10、透明度设置，IE不识别opacity属性 解决方案：　标准写法：opacity:value;(取值范围0-1)；　兼容IE浏览器 filter:alpha(opacity=value);(取值范围1-100)； 11、上下margin重叠问题 描述：给上面的元素设置margin-bottom，给下面的元素设置margin-top,只能识别其中较大的那个值；解决方案：　①、margin-top和margin-bottom 只设置其中一个值；　②、给其中一个元素再包裹一个盒子，并设置over-flow:hidden; 12、给子元素设置margin-top.应用在了父元素上 解决方案：　①、把给子元素设置的margin-top改为给父元素设置padding-top;　②、给父元素设置1px的border,即border-top:1px solid transparent;　③、给父元素设置over-flow:hidden;　④、给父元素设置float:left； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db9c5ca341254a7c463d9c5bdaa44eeb/" rel="bookmark">
			人脸识别实例-颜值打分系统简易版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点：
创建百度AI 人脸识别应用，获取自己的[APP_ID]、[API_KEY]、[SECRET_KEY]查看SDK文档，调用人脸识别接口，实现颜值打分系统 实现步骤：
搜索【百度大脑】，打开【百度AI开放平台】网站，其中有人脸识别技术，根据人脸识别SDK文档安装Python SDK。安装命令（cmd命令）：
pip install baidu-aip # 安装了pip，可通过该命令安装 python setup.py install　# 安装了setup.tool,通过该命令安装 在【百度AI开放平台】中控制台中创建人脸识别应用，获取系统为你分配的APPID AK SK（需先注册百度账号）
代码实现：
导包
import base64 from aip import AipFace 创建百度对象
""" 你的 APPID AK SK """ APP_ID = '你的 App ID'　# 百度AI平台提供 API_KEY = '你的 Api Key' # 百度AI平台提供 SECRET_KEY = '你的 Secret Key' # 百度AI平台提供 client = AipFace(APP_ID, API_KEY, SECRET_KEY) 设置人脸检测接口的参数
# 该参数为可选参数，默认只返回face_token、人脸框、概率和旋转角度，其他的属性值需自行获取并用 , 隔开 option = {'face_field': "age,gender,beauty"} # 图片类型 BASE64:图片的base64值，base64编码后的图片数据，编码后的图片大小不超过2M imageType = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db9c5ca341254a7c463d9c5bdaa44eeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d4fcae376b782849be33d544244174/" rel="bookmark">
			设计模式的目的以及七大原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设计模式的目的 1.代码重用性(即：相同功能的代码，不用多次编写) 2.可读性(即：编程规范性，便于其他程序员阅读和理解) 3.可扩展性(即：当我们需要增加新功能时，非常的方便，称为可维护性) 4.可靠性(即：当我们增加新功能后，对原来的功能没有影响) 5.使程序呈现高内聚，低耦合额特性 设计原则核心思想
1.找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起
2.针对接口编程，而不是针对实现编程
3.为了交互对象之间的松耦合设计而努力
设计模式七大原则 1.单一职责原则
基本介绍 对类来说，即一个类应该只负责一项职责。如类A负责两个不同的职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2
注意事项和细节 降低类的复杂度，一个类只负责一项职责提高类的可读性，可维护性降低变更引起得风险通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级别违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则。 2.接口隔离原则
基本介绍 客户端不应该依赖它不需要的接口，即一个类对应另一个类的依赖应该是建立在最小的接口上类A通过接口Interface1依赖B，类C通过接口Interface1依赖D，如果接口Interface1对类A和类C不是最小接口，那么类B和类D必须去实现他们不需要的方法。按隔离原则应当这样处理：讲接口Interface1拆分成几个独立的接口，类A和类C分别对应他们接口需要的接口建立依赖关系。也就是采用接口隔离原则。 3.依赖倒转原则
基本介绍 高层模块不应该依赖低层模块，二者都应该依赖其抽象抽象不应该依赖细节，细节应该依赖抽象依赖倒转（倒置）的中心思想是面向接口编程依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定得多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口和抽象类，细节就是具体的实现类使用接口和抽象类的目的是制定好规范，而不涉及具体的操作，把细节展现的任务交给他们的实现类去完成 依赖关系传递的3种方式 接口传递构造方法传递Setter方式传递 注意事项和细节 底层模块经量都要有抽象类或接口，或者两者都有，程序稳定性会更好变量的声明尽量是抽象类或接口，这样我们变量的引用和实际对象之间，就存在一个缓冲层，有利于程序的扩展和优化继承时遵循里氏替换原则 4.里式替换原则
OO中的继承性的思考和说明 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然他不强制要求所有子类都必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。继承再给程序带来便利的同时，也给程序带来弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类继承，则当这个功能需要修改时，必须考虑到所有子类，并且父类修改后，所有涉及到的子类功能都有可能产生故障问题提出：在编程中，如何正确使用继承? =&gt; 里氏替换原则 基本介绍 里氏替换原则在1988年，是由麻省理工学院的一位姓里的女士提出的。如果对每个类型为T1的对象o1，都有对象类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型，换句话说，所有引用基类的地方必须能透明的使用其子类对象。在使用继承时，遵循里氏替换原则，在子类经量不要重写父类的方法。里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当情况下，可以通过聚合，组合，依赖来解决问题。 5.开闭原则 ocp
基本介绍 开闭原则(Open Close principle)是编程中最基础，最重要的设计原则一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。用抽象构造框架，用实现扩展细节当软件需要变化时，尽量通过扩展实体的行为来实现变化，而不是通过修改已有的代码来实现变化编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则 6.迪米特法则
基本介绍 一个对象应该对其他对象保持最少的了解类与类关系越密切，耦合度越大迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对于除了提供的public方法，不对外部泄露任何信息迪米特法则还有个更简单的定义：只与直接的朋友通信直接的朋友：每个对象都会与其他的对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系，耦合的关系很多，依赖，关联，组合，聚合等，其中，我们称出现成员变量，方法参数，方法返回值中的类为直接朋友，而出现在局部变量中的类不是直接朋友。也就是说，陌生的类不要以局部变量的形式出现在类的内部 迪米特法则注意事项和细节 迪米特法则的核心是降低类之间的耦合但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)的耦合关系，并不是要求完全没有依赖关系 7.合成复用原则
基本原则 原则是尽量使用合成/聚合的方式，而不是使用继承 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73ea358a04f53c8ce9ce7882bd3a1efd/" rel="bookmark">
			K8s中Pod的三种健康检查探针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Pod的三种探针 StartupProbe：k8s 1.16版本后新加的探测方式，用于判断容器内应用程序是否已经启动。如果配置了startupProbe，就会先禁止其他的探测，直到它成功为止，成功后将不再进行探测。比较适用于容器启动时间长的场景。
LivenessProbe：用于探测容器是否运行，如果探测失败，kubelet会根据配置的重启策略进行相应的处理。若没有配置该探针，默认就是success。
ReadinessProbe：一般用于探测容器内的程序是否健康，它的返回值如果为success，那么久代表这个容器已经完成启动，并且程序已经是可以接受流量的状态。
# startupProbe: # 可选，检测容器内进程是否完成启动 # httpGet: # httpGet检测方式，生产环境建议使用httpGet实现接口级健康检查，健康检查由应用程序提供。 # path: /api/successStart # 检查路径 # port: 80 readinessProbe: # 可选，健康检查 httpGet: # httpGet检测方式，生产环境建议使用httpGet实现接口级健康检查，健康检查由应用程序提供。 path: / # 检查路径 port: 80 # 监控端口 livenessProbe: # 可选，健康检查 #exec: # 执行容器命令检测方式 #command: #- cat #- /health #httpGet: # httpGet检测方式 # path: /_health # 检查路径 # port: 8080 # httpHeaders: # 检查的请求头 # - name: end-user # value: Jason 二、Pod探针的检测方式 注意：三种检查方式同时只能使用一种。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73ea358a04f53c8ce9ce7882bd3a1efd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c458e5f5b0801940b07b5aba831f75e9/" rel="bookmark">
			回归模型 第5篇：knn回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于最邻近算法的分类，本质上是对离散的数据标签进行预测，实际上，最邻近算法也可以用于对连续的数据标签进行预测，这种方法叫做基于最邻近数据的回归，预测的值(即数据的标签)是连续值，通过计算数据点最临近数据点平均值而获得预测值。
一，sklearn的knn回归 scikit-learn实现了两个不同的最邻近回归模型：
KNeighborsRegressor：根据每个查询点的最邻近的k个数据点的均值作为预测值，其中，k是用户指定的整数。RadiusNeighborsRegressor：基于查询点的固定半径内的数据点的均值作为预测值，其中r是用户指定的浮点值。 回归模拟器的定义如下，该定义只列出最重要的参数，详细参数请参考sicikit-learn 官网：
sklearn.neighbors.KNeighborsRegressor(n_neighbors=5, weights='uniform', algorithm='auto', metric='minkowski',...) sklearn.neighbors.RadiusNeighborsRegressor(radius=1.0, weights='uniform', algorithm='auto', metric='minkowski',...) 参数注释：
radius：寻找最邻近数据点的半径n_neighbors：最邻近的邻居数量algorithm：寻找最邻近的数据点的算法，有效值是['auto'，'ball_tree'，'kd_tree'，'brute']metric：计算距离的度量，详细信息请查看：DistanceMetric weights：权重，默认值weights ='uniform'，为每个邻居分配统一的权重。 weights ='distance'分配的权重与距查询点的距离成反比。用于也可以提供定义函数来计算权重。在某些情况下，最好对邻居加权，以使较近的邻居对拟合的贡献更大，这可以通过weights关键字完成。 最基本的最邻近回归使用统一的权重，也就是说，在特定范围中的每个数据点对查询点的分类(回归)的作用是相同的。在某些情况下，对权重点进行加权可能会比较有利，以使邻近的点比远离的点对回归的贡献更大，这可以通过weights关键字完成。默认值weights ='uniform'，为所有点分配相等的权重。 weights ='distance'分配的权重与距查询点的距离成反比。
二，基于最邻近的数据点的数量来预测 当使用knn计算某个数据点的预测值时，模型会从训练数据集中选择离该数据点最近的k个数据点，并且把它们的y值取均值，把该均值作为新数据点的预测值：
from sklearn.neighbors import KNeighborsRegressor 对于knn分类，使用score方法评估模型，对于回归的问题，返回的是R^2分数，R^2分数也叫做决定系数，是回归模型预测的优度度量，位于0到1之间，R^2等于1对应完美预测，R^2等于0对应于常数模型，即总是预测训练集响应(y_train)的均值。
from sklearn.datasets import make_regression from sklearn.neighbors import KNeighborsRegressor from sklearn.model_selection import train_test_split kng=KNeighborsRegressor(n_neighbors=5) x_data,y_data=make_regression(n_features=1,n_informative=1,noise=50,random_state=1) x_train,x_test,y_train,y_test=train_test_split(x_data,y_data,random_state=1) kng.fit(x_train,y_train) prediction=kng.predict(x_test) kng_test_score=kng.score(x_test,y_test) kng_train_score=kng.score(x_train,y_train)
print('test data score:{:.2f}'.format(kng_test_score)) 三，knn回归模型的优缺点 knn回归有两个重要的参数：最邻近数据点的数量k，数据点之间距离的度量方法。
在实践中，通常使用较小的k值，在knn分类中通常把k值设置为奇数，便于找到多数邻居的标签。默认的距离度量是欧式距离，它在多数情况下的效果都很好，除此之外，还有曼哈顿距离等，详细信息，请阅读《Scipy 学习第3篇：数字向量的距离计算》。
在确定knn回归或knn分类的k值时，可以通过折叠交叉验证来寻找最佳的k值，示例代码如下：
from sklearn import datasets from sklearn.neighbors import KNeighborsClassifier from sklearn.model_selection import GridSearchCV #通过网络方式来获取参数 # 导入iris数据集 iris2=datasets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c458e5f5b0801940b07b5aba831f75e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b5cd64bfb0d30b69407130572e296e1/" rel="bookmark">
			类和对象-----引用和指向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果一个变量的类型是 类类型，而非基本类型，那么该变量又叫做引用。
有无引用指向的区别
无指向创建出来的对象，既不能引用又不能访问，也不能修改，无法进行控制。
有指向的可以进行修改，访问等控制。
引用本身不是对象，需要通过引用来间接的对对象进行控制。
引用有多个，但是对象只有一个。
如果等号左边和右边都是引用，不把这个等号叫做赋值，把他叫做左边的引用指向右边的对象。
导致h1和h2指向了同一个对象。
以上为一个对象，多个引用。
多个对象，一个引用。
当一个对象，没有任何引用指向她的时候，会被垃圾回收机制，回收掉。
练习引用
public static void main(String[] args) { Hero h1=new Hero(); Hero h2=new Hero(); Hero h3;//引用 Hero h4;//引用 h3=h1; h4=h3; System.out.println(h4); System.out.println(h2); } h4所指向的对象和h2所指向的对象，是否是同一个对象？
答：不是。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ff3db234cd1d41286fe5efe1679c49d/" rel="bookmark">
			企业实施一体化管理系统的十大好处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着市场竞争的日益加剧，中国企业集团化管理、全球化管理、个性化管理需求日益凸显，对管理软件的需求开始呈现出整合的、集成的、一体化的、平台化的产品组合形态。在强烈的市场需求拉动下，一体化管理系统应运而生，并开始走红。
一体化管理系统可以通过提高效率和效益以及降低成本的方式使企业受益，同时最大程度地减少由多次外部审计造成的破坏。该系统还能显示企业对提高绩效、员工和客户满意度以及持续改进方面的投入。
有了一体化管理系统，企业团队就可以协同工作而不再是孤岛，各部门在同一目标下密切合作，提高企业的整体绩效。
关于部门如何相互影响以及相关风险方面，一体化管理系统能为企业提供清晰统一的视图，减少重复工作，提高作业效率。
以下是企业实施一体化管理系统的10个重要好处：
1.提高绩效
一体化管理系统将对特定的管理系统组件和结果（例如质量、安全性、风险和生产率的提高）产生积极影响。
2.消除冗余
实施多个管理系统标准的最大好处之一是，企业能够调整所有标准，找到通用或单个管理系统组件。这些组件可能包括政策、目标、流程或资源。
例如，你可能会有单独的流程，用于培训、文档控制、管理评审、内部审计或改进。当你一次实施多个标准时，就会发现相似之处，这能为你的企业节省大量时间，并获得资金回报。
3.问责制
当你一次集成多个管理系统，并建立一致的目标、流程和资源时，随着系统的调整，你将会看到问责制的改进。
4.建立一致性
使用一体化方法，企业能够创建更好的管理系统一致性。创建一致性时，系统的复杂性将会降低，因此更容易理解。一致性使人们更加注重共同目标的实现，这些目标对企业来说非常重要。
5.减少官僚主义
官僚主义的减少源于冗余的消除。通常，在实施多个管理标准而不进行集成的情况下，由于层次结构的原因，无法精简决策可能会导致进退两难。
在集成管理系统后，你的企业可以采取系统化的方法，企业流程可以更好地适应变更。如果变更和决定能够轻松做出，这将减少官僚主义。
对于有效的方法来说，建立流程负责人以及跨部门团队可能非常有益。这些团队用有效的方式承担责任和任务，打破决策和部署道路上的障碍。你也可以考虑聘请一位企业管理体系经理（SHEQ Manager），负责支持和响应所有国际标准化组织（ISO）相关的问题。
6.降低成本
一体化管理系统使你的企业能够开展综合审计和评估，优化流程和资源。当你能集成这些系统，这会帮助你减少完成某些活动所需要的时间，消除被打断的时间，从而降低成本。
7.优化流程和资源
查看标准需求时，不要认为这些需求是企业额外的负担或任务。要记住，这些需求是实现客户、有关各方和企业期待、创建平稳有效流程的一种方式。资源可以得到优化，因为资源专注于流程实现和价值增加，而不是额外的系统维护。
8.减少维护
维护是指持续进行的合规性检查，确保你遵守管理系统标准要求。当拥有一体化管理系统，你就能同时维护需求、简化流程，使企业专注于改进，而不是在不需要时维护多个系统。
9.综合审计
当开始使用一体化管理系统，你就拥有了综合审计，这给你带来的好处非常多。
10.促进决策
消除冗余并在企业内创建一致性，能让你对功能需求和绩效有更全面的了解。这种一体化方法还支持企业对职能障碍和部门障碍进行分析，从而改善沟通和决策制定。
结语：
一体化管理的实质是构建一个信息充分共享的平台，实现关联信息的互通互联，消除冗余数据，实现充分共享。8MSaaS FAS等现代企业级全自动化软件可以为企业提供上述所有好处。
8MSaaS FAS能够使各类信息在管理者、业务部门、客户、合作伙伴、供应商及其他相关部门之间充分自由、安全可控地传输。
并且，8MSaaS FAS全自动化管理软件的所有功能建立在统一的平台上，同时还支持与国内外其他厂商系统完美对接，实现了真正而全面的一体化管理。
全面的一体化管理系统8MSaaS FAS涵盖企业管理的所有功能，如客户管理、人力资源管理、合同管理、项目管理、OA、文档管理、移动办公等，基本可覆盖企业管理的所有功能。
无论是中小企业，还是大集团，8MSaaS FAS提供的各项功能均能全面满足各种企业的管理需求，帮助企业解决各项管理难题。
如果没有一套像8MSaaS FAS 的一体化管理系统，现代很多企业的管理者和员工会因为滞后分散的信息、没有代表性或不能向下钻取细节的信息变得相互责备而不能真正解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36a65591f97a7c00d4140220af3915e1/" rel="bookmark">
			散列表查找失败平均查找长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你看了很多其他博客然后都看不懂看到了这篇，你一定可以容易懂的！我佛了，这么简单的东西死板地讲题目不讲原理鬼看得懂啊，这种风气真的不行，我忍不住想骂一声垃圾，啥玩意儿，误人子弟！原理懂了啥题不会做？
要想知道 散列表查找失败的平均查找长度，就要知道什么叫做查找失败！举个栗子：8个数字 key%11 如下算好了：
散列地址012345678910关键字331131234382722 冲突次数00023017 什么叫做查找失败？比如你要查55这个关键字，你必须%11，等于0，查地址0为33，不对，下一位1，不对，继续往下查找直到出现空的才知道这个关键字一定不存在，否则就放在空着的那个地址。所以以上表，计算地址为0的关键字查了9次才才知道没有这个关键字称为查找失败；计算地址为1的关键字只有探测完1-8号才能确定该元素不存在，以此类推。但是注意了，如果计算地址为8的或者9的、10的，只需要查找一次就知道该地址为空，失败了。因此查找一次就行。而且要知道如果查找成功是除以关键字个数，但是查找失败是除以你要模的数字本题是11，千万记住了，不是地址个数，不是关键字个数。综上所述，查找失败的平均查找长度为（9+8+7+6+5+4+3+2+1+1+1）/11=47/11。放心错不了，书上原题。
还要注意，如下题型H(key)=key%7：
散列地址012345678关键字982230871140620 千万注意，%7只能映射到0-6，散列函数不可能映射7，因此查找失败平均查找长度为（9+8+7+6+5+4+3)/7=6。看到这你可能想骂娘，啥玩意儿，别急。我会让你看懂，因为我最讨厌虾鸡吧写博客的傻逼玩意儿，写的不清楚又不解释，还误人子弟，low咖！！！好了回归正题。首先要知道，我们求平均查找长度其实在求概率，对于成功的平均查找长度，查找每个元素的概率是1/8，这个8就是关键字个数。就是说，查找成功你只能选择8个中的一个，否则成功不了，所以都是在等概率1/8情况下。查找失败也是一样，这里对每个位置的查找概率都是1/7,注意7是你要模的数字，就是说，你随便拿几个数，模7，只能是0、1、2、3、4、5、6，其中一种情况，不可能是7、8以后的数字，所以只需要计算地址在0-6中的概率。如果计算地址后为0，那么需要比较9次，以此类推，所以只能是上面的计算式子，别搞错了噢！还有要注意有些散列表不是完全填满，中间有空位，那相信你看完上面原理就不用我解释了，找到了空位还没有就说明不存在嘛，否则它就占位这个空位了。注意以上所讨论的全部是线性探测，如果是平方探测注意左右跳动，具体问题具体分析，就不展开了。相信你看到这个已经真正明白了什么叫做查找失败平均查找长度。对于垃圾博客需要狠狠骂，对于我也是，我写的烂的大家给我狠狠骂，这样才能少一些误人子弟的渣渣了，只讲怎么怎么操作不讲原理有什么狗屁用，换个方式描述不还是不会。知其然要知其所以然！！！以上如果有错误，还请大家狠狠指出来，谢谢大家！
比如这篇博客，真佛了，一来就巴拉巴拉在那算算算，好像谁不会计算散列表似的，人家真正不懂的是查找失败的平均查找长度的计算，真正的标题党。垃圾文章！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1af151387a40553ed086d7792102d938/" rel="bookmark">
			python是什么怎么用-什么是python items函数？怎么使用它？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章我们来学习一下关于python字典之中的python items函数的相关知识，items函数是什么意思，这个函数有什么作用都将会在接下来的文章之中得到解答。
描述
Python 字典(Dictionary) items() 函数以列表返回可遍历的(键, 值) 元组数组。
语法
items()方法语法：dict.items()
参数
NA。
返回值
返回可遍历的(键, 值) 元组数组。
实例
以下实例展示了 items()函数的使用方法：# !/usr/bin/python
# coding=utf-8
dict = {'Google': 'www.google.com', 'Runoob': 'www.runoob.com', 'taobao': 'www.taobao.com'}
print "字典值 : %s" % dict.items()
# 遍历字典列表
for key, values in dict.items():
print key, values
以上实例输出结果为：字典值 : [('Google', 'www.google.com'), ('taobao', 'www.taobao.com'), ('Runoob', 'www.runoob.com')]
Google www.google.com
taobao www.taobao.com
Runoob www.runoob.com
以上就是这篇文章所讲的全部内容，python中字典内置的items函数。希望所说的内容以及所举的例子能对你有所帮助。
更多相关知识，请访问php中文网Python教程栏目。
以上就是什么是python items函数？怎么使用它？的详细内容，更多请关注php中文网其它相关文章！
本文原创发布php中文网，转载请注明出处，感谢您的尊重！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbe1083f75c4f31302163b033de1ee6d/" rel="bookmark">
			简单高效的模型小挂件——CBAM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文传送门: CBAM: Convolutional Block Attention Module
代码(Pytorch): https://github.com/Jongchan/attention-module
Content Introduction
Convolutional Block Attention Module
Channel attention moduleSpatial attention moduleArrangement of attention modules Experiment
Image Classification on ImageNet-1KMS COCO and VOC 2007 Object Detection Conclusion
Introduction 卷积神经网络发展到现在, 各路大佬主要在网络的三个重要的维度发光发热——深度(depth), 宽度(width), 基数(cardinality*). VGG通过不断堆叠多个相同的模块获得深层网络; ResNet 巧妙地通过 residual blocks 和 skip connection 构造出更深的网络; 而 GoogLeNet 注意到了 width 这个重要的因素; Xception 和ResNext 则是不断增加网络的 cardinality. 后者不仅能减少参数, 还能拥有比前两者更好的表达能力. 这次作者则从另一个截然不同的角度 attention 提出了 CBAM 这个可以在模型中即插即用的小模块.
cardinality*: 这个概念在 ResNeXt 的论文中被提出, 定义为the size of the set of transformations, 在 ResNext 中指其 block 的分支数量.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbe1083f75c4f31302163b033de1ee6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004924f7a5f85bff4bdcfe7e43549aee/" rel="bookmark">
			光谱测量数据处理（matlab）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		光谱测量数据处理（matlab） 一、数据格式二、数据处理2.1 数据导出2.2 数据处理2.3 处理结果 三、地物光谱特征分析3.1 光谱曲线平滑3.2 光谱曲线一阶导数 一、数据格式 导出文件：
文件内容：
内容说明：
Columnname1Wavelengths (nanometers)2Reference Values (see below)3Target Values (see below)4Reflectance (percent) 二、数据处理 2.1 数据导出 将光谱仪测的不同地物的光谱数据以SVC软件中导出到计算机中，并按不同地物类型存储在不同Excel表格中。
2.2 数据处理 （一）原理公式
实验采用垂直测量方法，计算公式为
式中，L——测得地物反射辐射通量，Rr 为白板反射率（已知) ； Lr 为测得白板反射辐射能量；
（二）处理步骤
Step1：共100多组数据，观察每个数据的图片结合实地记录筛选可以利用的数据
Step2：由于仪器光谱突变，将筛选好的数据进行在SVC HR软件中的平滑操作（overlay）
Step3：将处理后的数据去除文件头，生成裸数据并保存到txt文本文件中
Step4：求每类地物的光谱数据平均值，生成每类地物的光谱数据
Step5：由于白板反射率波段和每类地物的光谱波段不匹配，对实测数据进行插值
Step6：根据反射率公式选取文件中第四列数据（百分比）与白板反射率的相乘操作
Step7：根据不同需要进行制图输出
（三）matlab处理代码
%---------------------------------------------------------------- %光谱处理代码 % %时间：2019年6月19日 %---------------------------------------------------------------- %去除文件头代码 %输入.sig文件 fileFolder=fullfile('E:\2019-06-11-下'); %引号内是需要遍历的路径，填绝对路径，然后保存在fileFolder dirOutput = dir(fullfile(fileFolder,'*.sig')); %引号内是文件的后缀，写'.txt'则读取后缀为'.txt'的文件 fileNames = {dirOutput.name}; %将所有文件名，以矩阵形式按行排列，保存到fileNames中 for i=fileNames i_trace = strcat('E:\2019-06-11-下\',i)%将字符串组合起来 i_trace=char(i_trace) i=char(i) ind=findstr(i-1,'.'); i=i(1:ind) M = dlmread(i_trace,'',25,0) i_trace_txt=strcat('E:\2019-06-11-下\',i,'txt') %num1, num2, num3, num4]=textread(i_trace,'%f %f %f f','headerlines',29); % A={num1,num2,num3,num4}; % eval(['T',num2str(n),'=','load(i_trace{1,1})',';']); dlmwrite(i_trace_txt, M, 'delimiter', '\t','precision', 6,'newline', 'pc') end %生成平均值代码 clc; clear all; close all; fileFolder=fullfile('E:\txt\柏油路'); %引号内是需要遍历的路径，填绝对路径，然后保存在fileFolder dirOutput=dir(fullfile(fileFolder,'*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/004924f7a5f85bff4bdcfe7e43549aee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3157a804bc5e2034f992215751ffd81a/" rel="bookmark">
			apt-get  install 报警告 WARNING: The following packages cannot be authenticated! 的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题重述 ubuntu 执行 sudo apt-get install **** 的时候，报这样的警告 WARNING: The following packages cannot be authenticated!，导致后面安装失败。
自己是在执行 sudo apt-get install ros-kinetic-jsk-topic-tools 的时候，出现这样的错误，导致出现
wong@WONG ~$ sudo apt-get install ros-kinetic-jsk-topic-tools ros-kinetic-jsk-recognition-utils Reading package lists... Done Building dependency tree Reading state information... Done The following additional packages will be installed: libqtassistantclient4 python-decorator python-opencv python-qt4 python-scipy python-skimage python-skimage-lib Suggested packages: python-qt4-dbg python-scipy-doc python-skimage-doc The following NEW packages will be installed: libqtassistantclient4 python-decorator python-opencv python-qt4 python-scipy python-skimage python-skimage-lib ros-kinetic-jsk-recognition-utils ros-kinetic-jsk-topic-tools 0 upgraded, 9 newly installed, 0 to remove and 220 not upgraded.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3157a804bc5e2034f992215751ffd81a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b31b542b7621890d01c66b7d4da501/" rel="bookmark">
			leetcode_120_三角形最小路径和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三角形最小路径和 描述 中等
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。
相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。
例如，给定三角形：
[ [2], [3,4], [6,5,7], [4,1,8,3] ] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明：
如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。
解题 将数据左对齐看
[ [2], [3,4], [6,5,7], [4,1,8,3] ] 当为最左端节点时，其路径只能从上到下
f ( x , y ) = f ( x − 1 , y ) + t ( x , y ) f(x,y) = f(x-1,y)+t(x,y) f(x,y)=f(x−1,y)+t(x,y)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3b31b542b7621890d01c66b7d4da501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f32eed9c1d8a056a517496604f900869/" rel="bookmark">
			USB2.0 通信协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		USB通信协议深入理解 1.基本概念 一个【传输】(控制、批量、中断、等时)：由多个【事务】组成； 一个【事务】(IN、OUT、SETUP)：由一多个【Packet】组成。
USB数据在【主机软件】与【USB设备特定的端点】间被传输。【主机软件】与【USB设备特定的端点】间的关联叫做【pipes】。一个USB设备可以有多个管道(pipes)。
2.包(Packet) 包（Packet）是USB系统中信息传输的基本单元，所有数据都是经过打包后在总线上传输的。数据在 USB总线上的传输以包为单位，包只能在帧内传输。高速USB 总线的帧周期为125us，全速以及低速 USB 总线的帧周期为 1ms。帧的起始由一个特定的包（SOF 包）表示，帧尾为 EOF。EOF不是一个包，而是一种电平状态，EOF期间不允许有数据传输。
注意：虽然高速USB总线和全速/低速USB总线的帧周期不一样，但是SOF包中帧编号的增加速度是一样的，因为在高速USB系统中，SOF包中帧编号实际上取得是计数器的高11位，最低三位作为微帧编号没有使用，因此其帧编号的增加周期也为 1mS。
• USB总线上的情形是怎样的？
• 包是USB总线上数据传输的最小单位，不能被打断或干扰，否则会引发错误。若干个数据包组成一次事务传输，一次事务传输也不能打断，属于一次事务传输的几个包必须连续，不能跨帧完成。一次传输由一次到多次事务传输构成，可以跨帧完成。
USB包由五部分组成，即同步字段（SYNC）、包标识符字段（PID）、数据字段、循环冗余校验字段（CRC）和包结尾字段（EOP），包的基本格式如下图：
2.1 PID类型(即包类型)
2.2 Token Packets
此格式适用于IN、OUT、SETUP、PING。
PID数据传输方向INDevice-&gt;HostOUTHost-&gt;DeviceSETUPHost-&gt;DevicePINGDevice-&gt;Host 2.3 Start-of-Frame(SOF) Packets
SOF包由Host发送给Device。
1) 对于full-speed总线，每隔1.00 ms ±0.0005 ms发送一次；
2) 对于high-speed总线，每隔125 μs ±0.0625 μs发送一次；
12 SOF包构成如下图所示： 2.4 Data Packets
有四种类类型的数据包：DATA0, DATA1, DATA2,and MDATA，且由PID来区分。DATA0和DATA1被定义为支持数据切换同步(data toggle synchronization)。
2.5 Handshake Packets
• ACK: 对于IN事务，它将由host发出；对于OUT、SETUP和PING事务，它将由device发出。 • NAK: 在数据阶段，对于IN事务，它将由device发出；在握手阶段，对于OUT和PING事务，它也将由device发出；host从不发送NAK包
3.事务(Transaction) 在USB上数据信息的一次接收或发送的处理过程称为事务处理（Transaction）即：The delivery of service to an endpoint。一个事务由一系统packet组成，具体由哪些packet组成，它取决于具体的事务。可能由如下包组成： • 一个token packet • 可选的data pcket • 可选的handshake packet • 可选的special packet
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f32eed9c1d8a056a517496604f900869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f33e1e369d73b3559b81a0904e385ed/" rel="bookmark">
			图像分割——meanshift算法（C&#43;&#43;&amp;GDAL库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像分割——meanshift算法（C++&amp;GDAL库） 一、meanshift分割原理二、分割技术流程三、代码实例3.1 C++&amp;GDAL库 实现3.2 分割结果3.3 结果分析 一、meanshift分割原理 Mean-Shift是一种非参数化的多模型分割方法，它的基本计算模块采用的是传统的模式识别程序，即通过分析图像的特征空间和聚类的方法来达到分割的目的。它是通过直接估计特征空间概率密度函数的局部极大值来获得未知类别的密度模式，并确定这个模式的位置，然后使之聚类到和这个模式有关的类别当中。
设S是n维空间X中的一个有限集合，K表示X空间中λ球体的一个特征函数，则其表达式为：
其中，x∈X，那么在向量x点处的样本均值为：
Fukunaga和Hostetle等人在其自己的论文中把m(x)-x的差叫做Mean-Shift。Mean-Shift算法实际上就是数据点到样本均值的重复移动，而且在算法的每一次迭代过程中，对于所有的s∈S，s←m (s)都是同时的。同时，模糊聚类算法还包括最大墒聚类算法以及常用的k均值聚类算法，它们都是Mean-Shift算法的一个有限的特例。Mean-Shift算法作为一种聚类分析方法，由于其密度估计器的梯度是递增的，而其收敛点即为密度梯度的局部极大值点，这个局部极大值即对应特征空间中的一个模式。
Mean-Shift算法对于概率密度函数的估计通常采用Parzen窗函数法，即核密度估计器。在d维空间Rd中，给定n个数据点xi，i=1，2…n，点x的多变量核密度估计器的计算式如式(3)所示。这个估计量可以由核K(x)和一个对称正定的d×d宽度的矩阵H来表示。
一般情况下，具有d个变量的核K(x)是一个满足以下条件的边界函数：
其中，ck是一个常量。从图像分割的目的出发，多变量核K (x)采用的是放射状对称核Ks(x)=ak,dK1(‖x‖)，其中K1(z)是一个对称的单变量核，且K (x)满足下式：
其中，ck,d是可使K (x)等于1的归一化常量。带宽矩阵H一般选择对角阵，H=diag[h12，…，h2d]或与单位矩阵H=h2I成比例。H=h2I情况下的一个明显优点是只需带宽参数h&gt;0。然而，从式(4)可以看出，首先应确定用于特征空间的欧几里德矩阵的有效性。若使用一个宽度参数h，则式(3)就会变成如下典型的表示式：
将(6)式代入上式，就可以得到一个通用的、用核符号表示的核密度估计式：
对有基本密度函数f(x)的一个特征空间，Mean-Shift算法分析的第一步是找到这个密度模式，然后对这个模式进行相关聚类。此模式应该在梯度▽f(x)=0的零点当中，而Mean-Shift程序是不用估计密度，而直接对密度的梯度进行估计，就能定位这些零点。
二、分割技术流程 对于Mean-Shift算法的应用与分割，首先，可设xi和zi(i=1，2，…，n)分别为n维空间内的输人和联合的空值域内的滤波图像的像素，Li为分割后的图像中的第i个像素。那么，其操作可分为以下步骤：
运行均值平移滤波程序对图像进行滤波，并存储所有d维空间内在zi处的收敛点zi=yi，c。在联合域中对所有的zi进行分组以描述类，这些类{Cp}p=1…m在空域内较hs较近，在值域内较hr较近。对于每一个i=1，…，n，并记为： Li={p|zi∈Cp|} (4)消除在空间区域内少于M个像素的区域。
输入：遥感图像，输出：分割后的斑块 三、代码实例 3.1 C++&amp;GDAL库 实现 #include "gdal_priv.h" #include "cpl_conv.h" #include &lt;iostream&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include&lt;cmath&gt; using namespace std; using namespace cv; struct aboutmat{ Mat mat; int width; int height; }; //读取数据并进行初始化：将其保存到3通道的数组中 aboutmat Initialization(const char *path) { //使之支持中文路径 CPLSetConfigOption("GDAL_FILENAME_IS_UTF8", "NO"); //注册栅格驱动 GDALAllRegister(); //打开要更新的数据，第二个参数使用介个 GDALDataset *poDS = (GDALDataset*)GDALOpen(path, GA_Update); //获取图像大小 int iWidth = poDS-&gt;GetRasterXSize(); int iHeight = poDS-&gt;GetRasterYSize(); //获取波段个数 int nBands = poDS-&gt;GetRasterCount(); //创建数组 //Mat data_XY(iWidth, iHeight, CV_8U, Scalar::all(0));	//坐标空间 Mat data_RGB(iHeight,iWidth, CV_8UC3, Scalar::all(0));	//色彩空间 //only三波段，多了不行 //进行波段循环，将矩阵形式表示的图像数据以行向量形式表示，如92*112的图像，表示为1*10304, for (int r = 1; r &lt;= nBands; ++r) { GDALRasterBand *xBand = poDS-&gt;GetRasterBand(r); unsigned char *pBuf = new unsigned char[iWidth * iHeight]; //动态指配数组 xBand-&gt;RasterIO(GF_Read, 0, 0, iWidth, iHeight, pBuf, iWidth, iHeight, GDT_Byte, 0, 0); for (int i = 0; i &lt; iHeight; i++) { for (int j = 0; j &lt; iWidth; j++) { data_RGB.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f33e1e369d73b3559b81a0904e385ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b73e3ee58f51ce4675e0feabbaa51dc/" rel="bookmark">
			lotus-miner lotus-worker 运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lotus-miner lotus-worker 运行 1，lotus-miner 运行2，lotus-worker 运行远程矿工带显卡GPU，`--parallel-fetch-limit=2`~~远程矿工没有显卡，`--parallel-fetch-limit=2`~~ 重新运行C2 单独计算 1，lotus-miner 运行 nohup lotus-miner run &gt;&gt; /var/log/miner/miner.log 2&gt;&amp;1 &amp; 2，lotus-worker 运行 远程矿工带显卡GPU，--parallel-fetch-limit=2 nohup lotus-worker run --parallel-fetch-limit=2 &gt;&gt; /var/log/worker/worker.log 2&gt;&amp;1 &amp; 远程矿工没有显卡，--parallel-fetch-limit=2 nohup lotus-worker --enable-gpu-proving=false run --parallel-fetch-limit=2 &gt;&gt; /var/log/worker/worker.log 2&gt;&amp;1 &amp; kill -9 $(ps aux | grep "lotus-worker" | grep -v grep | awk '{print $2}') echo $FIL_PROOFS_USE_MULTICORE_SDR &amp;&amp; echo $FIL_PROOFS_USE_GPU_COLUMN_BUILDER &amp;&amp; echo $FIL_PROOFS_USE_GPU_TREE_BUILDER &amp;&amp; echo $FIL_PROOFS_MAXIMIZE_CACHING &amp;&amp; echo $RUST_LOG 运行一个扇区P1 nohup lotus-worker run --parallel-fetch-limit=1 &gt;&gt; /var/log/worker/worker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b73e3ee58f51ce4675e0feabbaa51dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/265d78bae56f076b026e3137b6d540ac/" rel="bookmark">
			数据预处理之文件转换kettle：用Kettle生成测试数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【实验目的】 利用Kettle的“生成随机数”，“JavaScript代码”组件，生成测试数据。
【实验原理】 通过“生成随机数”生成随机0~1的小数，随机的字符串，随机的整数。再利用“JavaScript代码”编写代码处理随机的数或字符串，输出一定范围的小数，日期和有一定规律形式的整数。
【实验环境】 操作系统：Windows10 kettle版本：7.0.1或以上版本
【实验步骤】 一、创建转换
1．点击，在下拉菜单中点击选择，这样创建了一个转换文件。我们点击，重命名该转换文件，保存在某个指定的路径。
2．我们在新建的转换文件上开始可视化编程。需要的组件如下图所示。选择好组件好，按下图所示连接好组件。主要组件为Generate random value，Modified Java Script Value，excel writer。组件支持自定义命名。
二、可视化编程
1.“生成随机数”的配置：
其中，Type为Random number，生成的随机数在0~1范围的小数; Type为Random integer，生成随机的正负整数；Type为Random string，生成随机的字符串。
然后右键点击“生成随机数”的组件，选择生成多少份相同的数据，在这里，我们选择了生成100份相同的数据。
2．“JavaScript代码”的配置：
在此代码上，对于“数字”字段，配置为0~50范围的小数。
对于“字符串”字段，配置为选取随机字符串的前5个字符。
对于“整数”字段，配置为50的倍数。
对于“日期”字段，配置为2000年的日期。
3.“Microsoft Excel 输出”的配置：
三．运行程序：
点击开始运行程序，在弹出的对话框中，选择运行该程序。
运行结果：
四．实验结果
输入数据
(1)“生成随机数”组件生成随机数。（注意：因为是随机生成，每次生成的数据都不一样，以下的仅作参考）
“JavaScript代码”输出数据：
“Microsoft Excel 输出”输出数据：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54e0996f2b02a058e1bb84fa808c2ed6/" rel="bookmark">
			总结定时器设计方法_钢结构刚性固定钢柱脚设计方法总结，看完不仅懂操作，还懂了原理...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、钢柱柱脚形式的分类
刚性固定柱脚：
1)埋入式柱脚；
2)外包式柱脚；
3)插入式柱脚；
铰接柱脚：
外露式柱脚；
二、埋入式柱脚
2.1、基本概念：
所谓埋入式柱脚是指将钢柱底端直接埋入混凝土基础筏板、地基梁或地下室墙体内的一种刚性连接的柱脚。其特点是埋入相对自身绝对刚性的基础中而形成刚性固定柱脚节点。这种柱脚构造可靠，常用于高层钢结构框架柱的柱脚。
2.2、埋入式柱脚的受力特点
(1)柱的轴向压力N，由钢柱的柱脚底板直接传递给钢筋混凝土基础；柱的轴向拉力，则是通过柱脚底板悬出部分将其上部混凝土的反向压力传递给基础，或经由锚栓(底脚螺栓)直接传给基础。
(2)柱的弯矩M有两种传递方式：
a、均由H型钢柱翼缘上的抗剪圆柱头焊钉传递给基础，在实际工程设计中大多采用该方法。(也有研究说：该形式的柱脚中栓钉的作用不大，内力的传递主要是下述方式。)
b、依靠钢筋混凝土对钢柱翼缘的侧向承压力所产生的抵抗拒来传递给基础。
(3)柱脚顶部的水平剪力V由钢柱翼缘与基础混凝土侧向承压力来传递。
由于目前还没有能力考虑的有利因素如下：
(4)钢柱翼缘与基础混凝土在侧向承压应力状态下，由于钢柱翼缘与混凝土摩擦而产生的抵抗力，设计时不考虑。
(5)钢柱翼缘与基础混凝土之间的粘结作用设计时不考虑。
(6)在确定埋入钢柱周边对称配置的垂直纵向钢筋面积时，不考虑由钢柱承担的弯矩。
埋入式柱脚的埋深与构造示意图如下：
2.3、埋入式柱脚一般构造要求及部分细部设计计算
2.3.1、埋入式柱脚的钢柱埋入基础的深度一般可以在以下范围内采用(hc为钢柱截面的高度或管径)：
a、轻型工字钢截面柱： H=(2.0~2.5)hc；
b、圆管形截面柱和箱型截面钢柱：H=(2.5~3.0)hc。
2.3.2、埋入式柱脚，在钢柱埋入部分的顶部，应设置水平加劲肋或横隔板；对H型截面柱，其水平加劲肋外伸宽度的宽厚比应不大于9(235/fay)½，对于箱型截面柱，其内部横隔板的宽厚比应不大于30(235/fay)½，
2.3.3、埋入式柱脚在钢柱的埋入部分，应设置圆柱头抗剪栓钉，栓钉的数量和布置，应按计算要求确定。H型截面柱强轴左右两侧的翼缘、箱型截面柱两轴的每侧、圆管形截面柱两轴的每侧(90度扇面)，其栓钉数目不宜小于8φ16，栓钉水平和竖向中心距均不应大于200mm，栓钉竖向中心距不宜小于6d，横向间距不宜小于4d，栓钉外表面至钢柱翼缘侧边的距离不应小于20mm；栓钉的直径不应小于φ16(常用φ19)，栓钉长度宜取4~6倍栓钉直径。
2.3.4、埋入式柱脚钢柱脚底板的长和宽，按柱的轴力根据下式计算确定，同时应满足构造要求；N / (L*B) ≦ fc (N为柱轴力，fc为混凝土轴心抗压强度设计值)；一般钢柱脚底板的厚度不小于钢柱较厚板件厚度，且不小于20mm，同时应符合下式要求：t≥(6Mmax/f) ½.(式中，Mmax―根据钢柱脚底板与基础间的压应力和钢柱脚底板的支承条件所确定的柱脚底板的最大弯矩。)
2.3.5、钢柱脚底板当需要锚栓固定时，锚栓的锚固深度应不小于25d；锚栓一般仅作安装固定之用。
2.3.6、钢柱脚埋入部分的外围混凝土内应配置竖向钢筋以形成暗柱，暗柱截面可为钢柱边长加300mm，其配筋率应不小于0.2%，竖向钢筋沿周边的间距应不大于200mm，四根角筋的直径应不小于φ20，每边中间的附加钢筋应不小于φ16，箍筋一般取φ10@100，靠近基础顶面应增设三道φ12@50加强箍筋，竖向钢筋应锚入柱脚底板下不少于35d。
柱脚一侧竖向钢筋(主筋)的截面面积As应按下式验算：
As = M / (d*fsy) ; M=M1+V*h
式中： M ―作用于钢柱柱脚底部的弯矩设计值；
M1 ―作用于钢柱埋入处顶部的弯矩设计值；
V ―作用于钢柱埋入处顶部的水平剪力设计值；
h ―钢柱的埋深；
d ―受拉侧与受压侧竖向钢筋合力点间的距离；
fsy ―钢筋的抗拉强度设计值；
三、外包式柱脚
3.1、基本概念：
所谓外包式柱脚是指将钢柱底板放置基础面上，再由基础伸出钢筋混凝土短柱将钢柱柱脚浇筑包裹住成为一个整体。如下图所示：
3.2、外包式柱脚的受力特点
(1)柱的轴向压力N，由钢柱的柱脚底板直接传递给钢筋混凝土基础；柱的轴向拉力，则是通过柱脚底板悬出部分和锚栓传给基础。
(2)柱的弯矩由钢柱翼缘的栓钉传递给包脚钢筋混凝土短柱，并由钢筋混凝土短柱传递至基础。因此，在外包式柱脚中栓钉起着重要的传力作用。同时，短柱配筋由弯矩的大小决定，但是在计算短柱垂直纵向主筋的配置时，不考虑钢柱承担的内力。
(3)包脚处顶部的水平剪力由包脚混凝土和短柱箍筋共同承担。栓钉起着重要的传力作用。
3.3、外包式柱脚一般构造要求及部分细部设计计算
3.3.1、钢柱柱脚外包混凝土短柱的高度一般可以在以下范围内采用(hc为钢柱截面的高度或管径)：
a、轻型工字钢截面柱： H=(2.0~2.5)hc；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54e0996f2b02a058e1bb84fa808c2ed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4462e5b92bd2edfade8069b87edf216/" rel="bookmark">
			BuggyApp——模拟JVM性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐一款实用的工具：BuggyApp
下载地址：https://gitee.com/DHing/codes/b3ewz9pcfy826doaksunl95
Buggy App是一个简单的Java应用程序，它模拟不同的性能问题，例如内存泄漏，OutOfMemoryError，CPU峰值，线程泄漏，StackOverflowError，死锁，无响应等等。
使用此应用程序，您可以模拟环境中的各种性能问题。以下是一些可以使用Buggy App的用例： a.在运行应用程序的同一服务器上配置并启动Buggy App以消耗大量内存。
b.您可以在Docker容器中配置并启动Buggy App，以消耗大量CPU，并查看同一主机上的其他容器是否受到影响。
c.如果要构建性能工具或监视工具，则可以使用Buggy App模拟各种性能下降，并查看您的工具是否解决了这些性能问题。
使用方式： 1. OutOfMemoryError：Java堆空间
要生成“ java.lang.OutOfMemoryError：Java堆空间”，请使用以下参数启动Buggy App：
java -Xmx512m -jar buggyApp.jar PROBLEM_OOM 2.内存泄漏
如果您想模拟内存泄漏而不会遇到OutOfMemoryError，请使用以下参数启动Buggy App。 java -jar buggyApp.jar PROBLEM_MEMORY 当使用这些参数启动Buggy App时，将消耗80％-90％的已分配内存。但这不会导致OutOfMemoryError。
3. CPU峰值
如果您希望CPU使用率上升到80 – 90％，请使用以下参数启动Buggy App：
java -jar buggyApp.jar PROBLEM_CPU 4.线程泄漏
如果您希望应用程序继续缓慢生成新线程，请使用以下参数启动Buggy App。
java -jar buggyApp.jar PROBLEM_THREADLEAK 当您使用这些参数启动Buggy App时，最终将生成“ java.lang.OutOfMemoryError：无法创建新的本机线程”。
5.死锁
如果您希望应用程序遇到死锁，请使用以下参数启动Buggy应用程序。
java -jar buggyApp.jar PROBLEM_DEADLOCK 6. Stackoverflow错误
如果您希望应用程序遇到“ java.lang.StackOverflowError”，请使用以下参数启动Buggy应用程序。
java -jar buggyApp.jar PROBLEM_STACKOVERFLOW 7.线程阻塞
如果您想将多个线程置于BLOCKED状态，请使用以下参数启动Buggy App。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4462e5b92bd2edfade8069b87edf216/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5cea6936f2950c6d2f6316acf955081/" rel="bookmark">
			python学习笔记------列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列表 1.定义列表 listname[n]
可以包含字母表中的多有字母及数字，元素之间没有任何关系，因为列表包含多个元素，所以建议给列表指定一个复数的名称。
元素索引从0开始。
b=[1,2,3,"dsdd"] #列表中可以存放列表 li1=[[1,2,3,4.5,666],["qqq","aaa",2,1,4],['dfdf','jk','sd','gh'],4,5,6,7,8] print(li1[1][1]) #输出为aaa 2.定义一个数字列表
range() rang(1,10) //会生成一系列数字[1, 2, 3, 4, 5, 6, 7, 8, 9] list(range(1,10)) //可以直接转换为列表 list(range(1,10,2)) //2为步长，列表元素为[1, 3, 5, 7, 9]，这里的1是数字1 3.通过索引访问
name=['wanghua','liming',"yunque","lilei"] print("my friend id %s %s, %s和%s是朋友" %(name[0].title(),name[1].title(),name[2].lower(),name[3])) print(name[-1]) #-1访问的是列表最后一个元素 ''' 输出为 my friend id Wanghua Liming, yunque和lilei是朋友 lilei ''' 4.通过切片访问
list1=[1,2,3,4,5,6,7,8,9,10] list[开始：结束：步长] a=list1[:5] print(a) name=['wanghua','liming',"yunque","lilei"] print(name[0:4:1]) #是[0,4) li1=[10,9,8,7,6,5,4,3,2,1] li2=li1[:] #这里的数值是元素索引（和元素下标意义相同） li2=li1[4:] li2=li1[4:8] 例子：输出一个列表的偶数
#第一种 list1=[1,2,3,4,5,6,7,8,9,10] list2=[] for a in list1: if a%2==0: list2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5cea6936f2950c6d2f6316acf955081/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd05b5cee8f8e46e3900fb97a987893/" rel="bookmark">
			三十行代码教你做个通用文字识别程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三十行代码教你做个通用文字识别程序 准备开始编程测试 准备 在开始敲代码前，我们先做一些准备。我们的这个通用文字识别程序的原理很简单，就是通过API调用百度智能云提供的免费的通用文字识别（标准版）。
如果你没有相关账号的话，下面是教你怎么注册，如果有，请忽略：
首先访问AI Studio并注册相关账号
然后点击菜单栏的“更多”——“文档”：
接下来点击右上角的“控制台”：
左边的菜单来有“文字识别”，点击：
我这里已经创建了应用，如果没有的话，是会显示已建应用0个，接下来就是创建应用：
选择个人就好，名字、简介也随意，其余默认就好，创建好后，我们可以进入管理应用：
可以看到应用的API Key和Secret Key，待会会用到：
好了，准备过程到这里就结束了，我们开始上代码。
开始编程 先上代码：
# encoding:utf-8 import requests import base64 ''' 通用文字识别 ''' # client_id 为官网获取的AK， client_secret 为官网获取的SK host = 'https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=SPfIteu7L3vVVjfCHHUekVkK&amp;client_secret=HZs1UKLggufge2aKaPGNHeSt5u7F4Hoq' response = requests.get(host) if response: access_token = response.json()['access_token'] request_url = "https://aip.baidubce.com/rest/2.0/ocr/v1/general_basic" # 二进制方式打开图片文件 f = open('C:\\Users\\沧海云帆\\Desktop\\13.jpg', 'rb') img = base64.b64encode(f.read()) params = {"image":img} request_url = request_url + "?access_token=" + access_token headers = {'content-type': 'application/x-www-form-urlencoded'} response = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fd05b5cee8f8e46e3900fb97a987893/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba69006df21ec4794187573fc0bcec07/" rel="bookmark">
			我做“内网知识星球”一周年总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		”知识星球“一开始名叫“小密圈”，它的Slogan「连接一千位铁杆粉丝」！时间过的很快，”内网安全攻防“知识星球第一期于2020年10月31日结束了，共有950+人加入，跟其它知识星球不一样，我们分享的视频文章都是原创的，第一期共分享的视频文章194个，精华77个，问答50个，分享高质量的学习视频和资料加起来共近1T。
经过一年的运营，总体上大家还是比较认可我们星球讲解的内容，认可知识付费这个模式。新的一期里，我们将会做的越来越好，改进运营方式，提供更多优质的干货文章和视频，总之，一句话，助力大家的成长~
内网知识星球第二期“高级内网安全攻防 2.0”也如期开园了～~新的一期时间为：2020年11月1日 ～ 2021年10月31日。
对于星球内容和具体介绍，大家可以参看这遍文章：
“内网攻防图书配套视频 1.0 ”+“内网高级渗透技术 2.0”
星球部分主题内容展示：
欢迎大家尽早加入，第一期是365元，现在加入维持第一期的365元（续费球友8.2折只需299元），星友超过1000人后将涨价到499元（续费球友也将涨到365元）～
扫描下方二维码加入星球，开始内网大佬成长之旅！
关于星球续费：
我不割韭菜不割韭菜，临近第一期到期，每天很多来问我还有没有更优惠的兄弟，让你们失望了，没有优惠，长期以来就是8.2折续费价，没有其他优惠，不会搞很流行的各种花式促销，也不会每个人都不同价，之前怎么样，现在还是怎么样，大家放心。
创立知识星球的目的本来就是分享和讨论技术，同好者聚在一起，内部商讨技术的氛围一直非常好，同好者一起强大。
所以不追求利益最大化，只追求是不是志同道合。愿意续费的，大家是好朋友，我们会继续在星球里各种分享自己的经验技术；不续费的，大家也是好朋友，包括内网微信群也会为大家保留位置，绝对不踢除，而且也会保持友好的沟通。
最后衷心感谢那些最早支持我们的铁杆粉丝，星球能发展到1000人，首先要感谢的就是你们，所以凡加入星球编号前50的小伙伴享受299的价格续费后可获赠实验室任意一本出版图书签名版（具体领取方式会在星球内通知），更多的内部福利我们也在策划当中，谢谢你们！
PS：目前星球365元/年，365/365=1，平均每天也就1元，但带来的成长是一年的。看看一些其他收徒以及培训机构动辄成千上万的费用，这个价格我认为非常便宜了。
欢迎这几类人加入：
大学信安专业学生或信安领域职场新人
转型信安领域还处于迷茫期的朋友
想提升自己技术的朋友
以下几类人千万不要加入：
不愿意学习的人不要加入
不愿意分享的人也不要加入
认为别人有帮忙是义务的也不要加入
扫描下方二维码加入更多星球学习
加入后会邀请你进入内部微信群，内部微信群永久有效！
目前30000+人已关注加入我们
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe9b09fb3afc96cb64818f8558f31280/" rel="bookmark">
			手机python代码写好了怎么运行-手机怎么运行python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手机上敲代码纯属娱乐，输入速度实在糟糕，不过装上玩玩也好，所以一直想找个可以在安卓手机上编辑和运行Python的App，最终选择了QPython+。
QPython+是一个Android设备上的脚本引擎，提供可在Android手机或平板电脑上运行的嵌入型Python解释器，控制台，编辑器，SL4A库。它可以使你的Android设备运行Python脚本或项目，它是完全免费的，另有一款软件名为QPython Lite，是QPython+的精简版。
QPython+主要功能特点：
可从QR码下载Python代码文件
可从QR码执行Python代码文件
在Android设备上运行Python脚本
在Android设备上运行Python项目
使用QEdit编辑器轻松创建或编写Python脚本
库管理器
编程功能
支持FTP服务器
支持系统原生UI编程
支持Multi-Libraries插件
支持SL4A编程
在Android上运行Python早就不是什么新鲜的事情，而我介绍这款软件主要是因为它有在原来的基础上进行创新，QPython+的一个亮点功能便是从QR码获取脚本并执行脚本，这为分享脚本代码提供了方便，通过QR码，Python与现实构成了一条桥梁，我们可以通过扫描QR码的方式去执行脚本，比起传输文件的方式要容易得多也快捷得多，今后Android平台的技术大牛们分享一些简单的小脚本，不需要发布文件了，只要把脚本做成QR码图片，新手们用QPython+扫描后执行，一切都是那么的简单高效。
QPython+像是一个IDE，它可以进行Python项目的编辑和执行，提供库管理器，可以很方便的执行和分享脚本文件，可下载的Kivy库，甚至能让你编写Android的原生UI，别忘了还有强大的Pygame模块，它能让你在Android上也编写Python游戏！
现在QPython+还是一个新生儿，它需要开发者们的辛勤耕耘，如果有这方面的兴趣，请参与QPython+的纠错工作，QPython+，未来，拭目以待。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3de54ac66a6d71b8171a33609329e848/" rel="bookmark">
			微信小程序基础：Flex布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flex布局 Flex的定义：几种使用方法：项目定义：容器内置属性 容器设置样式：flow-direction:flow-wrap属性：flex-flow是以上两者的简写形式：默认为row,nowrapjustify-content:项目在主轴上的对齐：align-items:定义项目如何在交叉轴上对齐：align-content:定义多个轴线的对齐方式，就是多层时候整体项目的对齐方式 项目的属性：order:flex-grow:flex-shrink:flex-basis:flex:align-self: Flex的定义： Flex是Flexible Box的缩写，意为弹性布局，用来为盒装模型提供最大的灵活性，所有容器都可一种指定为Flex布局。
几种使用方法： 容器：display:flex;
行内元素：display:inline-flex;
webkit内核的浏览器需要：-webkit-flex;
设置为flex后，子元素的float/clear和vertical-align属性将失效。
项目定义： 采用Flex布局的元素，成为Flex容器。所有的子元素为容器成员，称为Flex项目（flex item）.
容器内置属性 容器默认两根轴：水平为main axis和垂直cross axis。水平从左到右，垂直为上到下，开始是start,结束时end.
大小是size.
容器设置样式： flow-direction: (项目的排列方式，行是从左到右，列是从上到下)
row,column,row-reverse,column-reverse
flow-wrap属性： 默认情况下项目会按照某一条线来进行排列
nowrap默认：不换行
wrap:换行，第一行在上方
wrap-reverse:换行，第一行在下方
flex-flow是以上两者的简写形式：默认为row,nowrap justify-content:项目在主轴上的对齐： flex-start:左对齐，flex-end:右对齐；center：居中
space-between:两端对齐，项目之间的间隔相等。
space-around:每个项目两侧的间距相等，所以项目之间的间隔是项目和容器边界的距离的两倍。
align-items:定义项目如何在交叉轴上对齐： flex-start:起点对齐;
flex-end:终点对齐
center:交叉轴的中点对齐
baseline:项目的第一行文字的基线对齐
stretch:项目未设置高度或者设为auto,将占满整个容器的高度。
align-content:定义多个轴线的对齐方式，就是多层时候整体项目的对齐方式 与align-items类似;
space-between:与两端对齐，轴线之间的间距平均分布
space-aroun:轴线两侧的间隔都相等
项目的属性： order: 决定排列顺序，数值越小排列越靠前。默认为0；
flex-grow: 定义项目的放大比例：默认0。可以设置不同项目的放大比例来设置大小。
flex-shrink: 定义缩小比例：默认为1，空间不足时等比例缩小。负值无效。
flex-basis: 定义项目占据的主轴空间即main-size,水平大小。默认为auto,即项目本来大小。可以设置固定的值来设置大小。
flex: 是flex-grow,flex-shrink,flex-basis默认为0 1 auto;
可以不选后两个属性。
两个快捷值;auto:1 1 auto;none:0 1 auto;
优先使用快捷值，不单独写，因为浏览器会自动推算。
align-self: 设置某个项目和其他项目不一样的对齐，可以覆盖align-item,默认为auto即和父元素一样。没有父元素就是stretch;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/239c4170bbefbc6e865f468c6cac1142/" rel="bookmark">
			看完就懂，五千字长文带你领略推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有一些小伙伴给我留言说非常想要我开一个推荐系统专题，其实我也有过这个想法，一直没动笔主要有两个原因。第一个原因是担心自己水平不够，班门弄斧或者是误导了一些读者。第二个原因是，我的确不知道这个专题应该怎么写。但是读者有求，总得回应不是，所以咬着牙写了本文。
文章有点长，但是干货不少，希望大家能够耐心读完。
推荐、广告、搜索三兄弟 互联网行业当中有这么一句话，叫做：搜索、广告、推荐三兄弟。这句话是说这三个领域或者是三个方向的技术栈非常接近，甚至可以说是相差无几，可以自由转化。比如我也是今年才转到的推荐team，之前在广告组。转岗的时候只做了一件事，就是和老板说我要转岗，去推荐。
你可能会很好奇，为什么会这样？这三个也不是一回事吧？从表面上来看的确不是一回事，但是从本质上起是一样的。我简单画一个架构图，最最简单的那种。
这张图我相信谁都能看懂，推荐系统也好广告系统也罢或者是搜索系统也一样，本质上都只做了一件事，就是根据信息从内容库里取得合适的内容给到用户。这句话有两个关键点，第一个关键点是根据信息，第二个关键点是合适的内容。这三个系统本质上就是围绕着这两个关键点在运作。
举个例子，搜索系统，大家首先会想到搜索引擎比如某度。搜索引擎的使用场景是什么？很简单就是我们输入搜索词，搜索引擎返回我们想要的网页。我们在淘宝搜索，其实也是一个搜索引擎。我们一样是输入搜索词，淘宝返回我们想要的商品。在这个例子当中，信息主要成分就是用户的搜索词，合适的内容呢，某度的内容是网页，淘宝的内容就是商品。
广告系统其实也是一样的， 我们在搜某度的时候有时候会弹出一些没羞没臊的小网站。这些网站也不是凭空来的，其实也是引擎搜出来的，只是在广告系统里，这里的合适的内容就变成了合适（能赚钱）的广告。
你可能又会问了，我打开淘宝的时候啥也没输入啊，推荐系统自动就帮我筛选了一批商品，怎么能说推荐和广告是一样的呢？
的确，我们打开电商网站的时候，什么也没输就能看到商品，打开抖音什么也没干就能看到小姐姐。但是这并不意味着网站什么信息也没有，它其实有的信息有很多。比如你之前的消费记录、点击记录、创建账号的时候填写的个人信息等等。推荐系统其实可以理解成使用的这些隐藏信息来进行的“搜索”，本质上一样是信息的检索。
也就是说我们站在更高的角度来看，搜索、推荐、广告其实本质上都是搜索引擎。只是搜索的形式不一样，搜索的目标不一样，所以会拆分成几个团队来做。
具体多说一点，比如广告的目标是盈利，承担电商公司的大部分收入，不仅要让你点广告，还要让你点比较金贵的广告，赚钱的期望要最大。搜索的目标一般是准确性和质量，就是当用户搜索的时候搜出来的结果首先质量要高，和搜索词要匹配，不能搜什么都出小姐姐。推荐的目标一般是点击率，因为没什么推荐准不准确一说，主要还是让用户能够点，让用户多看看。
搜索、推荐、广告只是形式不同，目标不同，具体的做法上也会有一些差异，但核心的逻辑都是一样的，称为三兄弟并没有什么不妥，推荐系统搞明白了，广告、搜索也都差不多了，就是那么回事，大同小异，吹牛都会更有信心一点。
推荐系统架构 我们把广告和搜索先放在一边，主要来看推荐系统。推荐只是表象，其实核心还是搜索，推荐的目标是搜索出那些你可能还没看过，但是你可能感兴趣的东西。
这里面关键点就是用户的兴趣，也是推荐的难点。它不像是搜索，用户会输入搜索词，意图很明确。我搜乒乓拍就是要看乒乓拍，你给我出别的结果都不对。推荐不是，用户什么都没有输入，我们要盲猜。当然也不是真盲猜，其实也是根据用户之前的行为猜。所以有些上古时期的推荐相关的书籍当中会说推荐系统分为两种，一种是基于用户行为的推荐，一种是纯内容的推荐。
怎么说呢，这样划分当然是没错，但是有些落伍了。现在人工智能时代，啥都要智能，讲究千人前面。纯内容的推荐基本上已经看不到了，可能在一些小场景当中还有在使用。除此之外基本上清一色的基于用户行为的推荐了，如果你找工作说我精通纯内容的推荐，估计面试官就直接让你出门左拐了。如果你开公司和投资人说，我们这个项目的特点就是基于内容推荐做得好但是没有千人前面，估计投资人也出门左拐了。
这其实是挺悲哀的一点，网上的资料都比较古老，想要钻研只能在实际的应用场景当中学习领悟。对于想要自学成才的少年来说不是很友好。
扯远了，我们回到主题。我们推荐的时候，主要是根据用户的内容。这里面也有两个问题，第一个问题是新用户怎么办，我之前从来没逛过淘宝，或者现在还没登陆，难道我打开首页就什么也看不见吗？这肯定不行。第二个问题是也不能纯基于行为，比如我之前点过乒乓拍，你就全给我推荐乒乓拍，那肯定也不行，一点新鲜感都没有。
其实这样类似的问题还有很多，说白了只有一点，就是我们不能一根筋，就只用一种策略来推荐。要采取多种策略，比如热门的商品选一些，比如用户之前点过的商品选一些，用户之前经常看但是没买的商品选一些，比如用户之前感兴趣的类目下的商品选一些，感兴趣的店面下的商品选一些……
光选还不行，选了这么多商品，我们怎么展示呢？总不能一排一排展示吧，肯定要把用户最有可能点的放在前面，把次要一点的放在后面。问题是用户可不可能点并没有一个明确的指标，所以针对这个问题，我们只能把它交给模型，用一个模型来预测用户会不会点击这个商品，他的点击率有多高。
我们把上面的这些逻辑整理一下，可以发现推荐的过程主要分为两个步骤。第一个步骤是选商品学名叫召回（recall），第二个步骤是排序。一般来说还有第三个步骤，夹在这两个步骤中间，叫做过滤。因为多种召回策略可能会召回到一些非法违禁的商品，或者是重复的商品，我们需要过滤掉，防止用户看到引起反感。
这样我们就可以画出完整的推荐系统的架构了：
我们之前介绍过的以及网上到处充斥着的协同过滤算法，其实只是召回策略当中的一个。所以协同过滤其实不能算是推荐算法（可能上古时期算），现在只能算是推荐策略的一种。
所以如果你看到什么培训班或者是课程上面说手把手教你做一个推荐系统，然后点进去看看讲来讲去都只有协同过滤，什么tfidf的话，趁早找他退钱。并不是这些东西不重要，而是这些内容已经不是推荐系统的重点了，仅仅学会这些其实真的一点用也没有（可能那种十几个人的公司有用）。
技术分析 到这里，我们已经清楚了，推荐系统可以分为这么三个模块，其实广告、搜索也差不多，也是这么三个模块，只是模块当中的实现逻辑不太一样。我们简单说说这三个模块当中的逻辑。
召回 在互联网公司当中召回相关的工作岗位其实不多，工作量也比较少。这并不是它不重要，而是它实在没有太多可做的。目前电商行业除了一些顶级的公司会用上一些先进的方法之外，其他公司可能还是在用一些比较古老的策略，比如热门商品召回、协同过滤召回等等。
主要有这么几个原因，一个原因是受到业务的限制比较深，不仅行业之间没有共通性，甚至不同的公司也不一定可以用同一套方案。比如音乐推荐和商品推荐，召回的逻辑肯定不一样，再比如淘宝和唯品会的面向人群以及商品情况也都不同，用户习惯可能也不一样，也不一定就能够使用同一套方案。
另外一个原因是召回这一块承载的流量比较大，很难经得起大的折腾。比如每一个用户到了首页都会看到商品推荐，基本上首页的流量就等于推荐系统的流量。所以召回引擎一定要保证效率和性能，因为后面的排序是性能开销的大头，所以前面要尽可能地留出空间，给后面的系统使用。
我们拍拍脑袋可能会想到很多看起来很不错的策略，但是实际上这些策略并没有这么简单，因为我们面向的可能是一个海量的内容库，比如电商公司里面上亿甚至十亿的商品。再好的策略可能都得打个问号，究竟能不能抗住这么大的流量？
最后一个原因是一些先进的手段要求很高，并不是什么公司都有条件用。举个例子，比如召回当中有一个比较先进的方法叫做向量召回。也就是把一个商品使用神经网络映射成一个向量，然后根据用户之前的行为召回一些相似度很高的向量。由于神经网络的泛化性能比较好，我们可以召回出一些普通的方法召回不了的优质商品。但问题是这种方案对于数据的准确性以及模型的性能要求很高，别人用起来效果出色，是因为别人的数据质量高，系统成熟。对于中小型公司而言，这两条是很难保证的，所以一些听起来特别牛叉的方案可能只有大公司在用。
结合这么几点，会得到一个结论，就是对于中小型公司的召回策略来说，其实基本上可以认为是固定的。可能也会有些改进，但是很有限。他们也很难招到水平非常高的架构师，让整个系统升级换代。并且也没有人能保证升级换代一定会有更好的效果。
过滤 过滤就更没有什么好说的了，过滤的业务导向性更强，基本上不具有普适性。一些特殊的情况可能只有这个公司和这个产品能遇到，换个公司换个产品就完全不一样了。
所以过滤层基本上都是做着类似补丁的活，当然这其中也可能会用到一些比较高端的技术。比如一些反作弊或者是风控的策略，再比如一些检测非法、鉴黄的模型等等。但是这些高端的做法一般也是大公司才有，小公司里一般都是朴素的策略，能用就行。
排序 这么一通分析一下，很明显推荐的核心在于排序。实际上也的确如此，如果我们去翻翻各大期刊的paper，里面充斥着的也都是各种各样的排序策略以及排序优化方案。这也是最需要算法工程师的地方，也是算法工程师就业的主要岗位。
算法工程师主要做什么呢？当然还是老一套了，调整参数、做几个新的特征、训练模型。看起来很无聊对不对，其实也很无奈，因为算法工程师往往接触不到完整的系统，实际上整个系统也是半定型的，很少会有重构或者是调整的机会。对于下游的召回以及过滤接触一般也不会太多，能看到的只有自己的模型和数据，也就是这么一亩三分地。虽然是一亩三分地，但是里面可以做的事情可不少，需要做新的数据，需要分析旧的数据，如果效果不好得分析原因，得尝试一些新的方案。很简单的事情来来回回就可以做几个月，这是非常正常的。
你可能会问，难道就不会用一些更高端的方法，照paper上实现一下模型，获得更好的效果吗？
对不起，可能会让你失望了，这样的机会的确有，但是并不多。先不说这些paper列举出来的结果和使用的数据有没有水分，就算没有水分，也不代表它能适合所有的场景。可能只在它的数据场景才有效，在我们的场景就未必适用。再者，别人能用的方案不代表其他公司也能用得了，就拿itemvec来说，有几家公司有能力对上亿的商品集训练出效果很好准确的embedding的？DIN是好，没点体量和技术能力的公司是真的无福消受。退一万步来说，即使真的有用，带来的提升也是非常非常小的，可能还不如挖掘一个厉害一点的特征，或者是找一找数据中的trick。
从整体上来说，排序这一块的确是最有技术含量也是最需要模型效果的。但是从实际的工作上来说，它依然是骨感的，可能远不像大家想的做科研那样高大上和性感。
一点感想 说到推荐系统，我们可能会首先想到各种各样的算法，但实际上算法严格说起来并不是推荐系统的核心。因为paper都是公开的，业内的先进的做法也都不是秘密。但为什么有的公司的推荐就做的非常好，有的就做不起来呢？
归根结底还是系统与架构的原因，推荐系统需要承受海量的流量，需要海量的数据训练，没有一套优秀的架构是玩不转的，这才是真正技术的核心，考验一家公司以及架构师的地方。这也是为什么一些中小型公司不给力的原因，他们既没有足够的计算资源去支撑这样的系统，也招聘不到足够优秀的架构师来升级系统设计，能做的事情自然就非常有限了。
所以如果大家对推荐系统感兴趣的话，闭门造车是不行的。最好还是要去规模比较大的公司，这样才能接触到业内最前沿的做法。并且也不能只关注算法和模型，最好能站在高角度望一望整个系统的架构，这也是最值钱也是最能提升我们能力的地方。
今天的文章就到这里，衷心祝愿大家每天都有所收获。如果还喜欢今天的内容的话，请来一个三连支持吧~（点赞、关注、转发）
原文链接，求个关注
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf58d79ea67b4b2605d69a7ea46175e/" rel="bookmark">
			C&#43;&#43;程序利用std::cout打印到日志文件方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用C++语言编写程序时，有时候希望在程序崩溃的时候有相应的崩溃日志可以方便debug。这里就介绍一种std::cout打印日志到指定文件的方法：
1.初始化：
static std::ofstream g_log("out.log");//指定到out.log文件夹 std::cout.rdbuf(g_log.rdbuf()); 2.在需要打印日志的函数里：
std::cout &lt;&lt; "xxx" &lt;&lt; std::endl; 这样就可以记录你需要的关键函数信息了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27f39ecfeba512f3f3d74f96995ae666/" rel="bookmark">
			uni-app项目转换quickapp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应公司业务需求，开发quickapp，在此之前，完全不懂，quickapp是什么？我是谁？我在哪？？
然后我就开始琢磨怎么去搞定这个他，本来呢我是用vscode写原生的，但是等我创建好项目以后，看着目录结构，看着quickapp的代码
那一刻我只想对我公司老板说：“嫩是给这为难俺胖虎”
但是没办法，谁让老板不是我~~
之后我突然想起来uni-app不是号称一端开发多端使用吗？然后我就去看HBuilder X查看项目有没有快应用启动，没想到还真让我找到了
那这接下来事情不就简单了吗
下载编辑器，运行，芜湖~~起飞 (快应用IDE下载地址)
项目启动后必然会报错，因为刚开始编辑完成后app.json中有几个qucikapp的必要参数没有，可以自己添加一下，也可以根据快应用官方文档来进行转化一下
你学废了吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bcaee35d06cd43ad1a21934c62f00c7/" rel="bookmark">
			vue实现拍照人脸识别功能带人脸选中框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 实现打开摄像头，并识别人脸。 实现效果： 实现步骤： 一、安装 （1）官网下载 tracking.js 的代码包官网入口 （2）npm下载 执行命令： cnpm install tracking --save 二、demo案例代码 &lt;template&gt; &lt;div class="testTracking"&gt; &lt;video id="video" width="1000" height="700" preload autoplay loop muted &gt;&lt;/video&gt; &lt;canvas id="canvas" width="1000" height="700"&gt;&lt;/canvas&gt; &lt;div class="buttonDiv"&gt; &lt;button type="button" @click="submit" style="font-size: 3vw;"&gt;提取照片&lt;/button&gt; &lt;button type="button" name="button" @click="checkFace" style="font-size: 3vw;"&gt;检测人脸&lt;/button&gt; &lt;button type="button" name="button" @click="getCompetence" style="font-size: 3vw;"&gt; 打开摄像头 &lt;/button&gt; &lt;button type="button" name="button" @click="de" style="font-size: 3vw;"&gt;停&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; require("tracking/build/tracking-min.js"); require("tracking/build/data/face-min.js"); require("tracking/build/data/mouth-min.js"); require("tracking/examples/assets/stats.min.js"); export default { name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bcaee35d06cd43ad1a21934c62f00c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9578228acb3dec852667b741c9c9b1ce/" rel="bookmark">
			linux namespace基本操作命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建两个namespace
ip netns add 空间1 ip netns add 空间2 备注：
删除namespace命令为：ip netns delete 空间名称
查看所有namespace命令为：ip netns ls
2.为两个namespace创建双向通信管道pair
ip link add type veth 备注：pair是成对出现的，一次创建会生成两个，默认是在名称后拼接数字来区分
3.查看系统中所有的通信管道pair
ip link
备注：删除pair：ip link delete pair名称（即veth0）
4.将创建出来的管道pair设置到对应的namespace中
ip link set veth0 netns 空间1 ip link set veth1 netns 空间2 5.更改两个通信管道的状态，配置ip地址，并启用
ip netns exec 空间1 ip link set veth0 up ip netns exec 空间1 ip addr add 10.0.1.1/24 dev veth0 ip netns exec 空间1 ip route ip netns exec 空间2 ip link set veth0 up ip netns exec 空间2 ip addr add 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9578228acb3dec852667b741c9c9b1ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03f73751aaaafc3978d40bb0cb7f78de/" rel="bookmark">
			1、Tomcat&amp;Http协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat&amp;Http协议 1 企业开发简介 1.1 JavaEE规范 JavaEE规范是J2EE规范的新名称，早期被称为J2EE规范，其全称是Java 2 Platform Enterprise Edition，它是由SUN公司领导、各厂家共同制定并得到广泛认可的工业标准（JCP组织成员）。之所以改名为JavaEE，目的还是让大家清楚J2EE只是Java企业应用。在2004年底中国软件技术大会Ioc微容器(也就是Jdon框架的实现原理)演讲中指出：我们需要一个跨J2SE/WEB/EJB的微容器，保护我们的业务核心组件，以延续它的生命力，而不是依赖J2SE/J2EE版本.此次J2EE改名为Java EE，实际也反映出业界这种共同心声。
JavaEE规范是很多Java开发技术的总称。这些技术规范都是沿用自J2EE的。一共包括了13个技术规范。例如：jsp/servlet，jndi，jaxp，jdbc，jni，jaxb，jmf，jta，jpa，EJB等。
其中，JCP组织的全称是Java Community Process。它是一个开放的国际组织，主要由Java开发者以及被授权者组成，职能是发展和更新。成立于1998年。官网是：JCP
JavaEE的版本是延续了J2EE的版本，但是没有继续采用其命名规则。J2EE的版本从1.0开始到1.4结束，而JavaEE版本是从JavaEE 5版本开始，目前最新的的版本是JavaEE 8。
详情请参考：JavaEE8规范概览
1.2 Web概述 Web在英文中的含义是网状物，网络。在计算机领域，它通常指的是后者，即网络。像我们前面接触的WWW，它是由3个单词组成的，即：World Wide Web，中文含义是万维网。而我们前面学的HTML，CSS和JS的参考文档《W3School全套教程》中的W3C就是万维网联盟。他们的出现都是为了让我们在网络的世界中获取资源，这些资源的存放之处，我们称之为网站。我们通过输入网站的地址（即：网址），就可以访问网站中提供的资源。在网上我们能访问到的内容全是资源（不区分局域网还是广域网）。只不过，不同类型的资源展示的效果不一样。
首先，我们先来介绍资源的分类，它分为静态资源和动态资源。其中：
静态资源指的是，网站中提供给人们展示的资源是一成不变的，也就是说不同人或者在不同时间，看到的内容都是一样的。例如：我们看到的新闻，网站的使用手册，网站功能说明文档等等。而作为开发者，我们编写的html,css,js,图片，多媒体等等都可以称为静态资源。
动态资源它指的是，网站中提供给人们展示的资源是由程序产生的，在不同的时间或者用不同的人员由于身份的不同，所看到的内容是不一样的。例如：我们在12306上购买火车票，火车票的余票数由于时间的变化，会逐渐的减少，直到最后没有余票。还有，我们在CSDN上下载资料，只有登录成功后，且积分足够时才能下载。否则就不能下载，这就是访客身份和会员身份的区别。作为开发人员，我们编写的JSP，servlet，php，ASP等都是动态资源。
关于广域网和局域网的划分，广域网指的就是万维网，也就是我们说的互联网。局域网是指的是在一定范围之内可以访问的网络，出了这个范围，就不能再使用的网络。
1.3 系统结构 1.3.1 系统结构简介 在我们前面课程的学习中，开发的都是Java工程。这些工程在企业中称之为项目或者产品。项目也好，产品也罢，它是有系统架构的，系统架构的划分有很多种方式。我们今天讨论的是基础结构上的划分。除此之外，还有技术选型划分，部署方式划分等等。
基础结构划分：C/S结构，B/S结构两类。
技术选型划分：Model1模型，Model2模型，MVC模型和三层架构+MVC模型。
部署方式划分：一体化架构，垂直拆分架构，分布式架构，流动计算架构，微服务架构。
1.3.2 C/S结构 它指的是客户端——服务器的方式。其中C代表着Client，S代表着服务器。C/S结构的系统设计图如下：
1.3.3 B/S结构 它指的是浏览器——服务器的方式。其中B代表着Browser，S代表着服务器。B/S结构的系统设计图如下：
1.3.4 两种结构的区别及优略 两种结构的区别
第一：硬件环境不同，C/S通常是建立在专用的网络或小范围的网络环境上（即局域网），且必须要安装客户端。而B/S是建立在广域网上的，适应范围强，通常有操作系统和浏览器就行。
第二：C/S结构比B/S结构更安全，因为用户群相对固定，对信息的保护更强。
第三：B/S结构维护升级比较简单，而C/S结构维护升级相对困难。
优略
1 C/S：是能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器。对应的优点就是客户端响应速度快。
2 B/S：总体拥有成本低、维护方便、 分布性强、开发简单，可以不用安装任何专门的软件就能 实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能使用。
关于课程中结构的选择
我们的课程中涉及的系统结构都是是基于B/S结构。
2 Tomcat 2.1 Tomcat介绍 2.1.1 关于服务器 服务器的概念非常的广泛，它可以指代一台特殊的计算机（相比普通计算机运行更快、负载更高、价格更贵），也可以指代用于部署网站的应用。我们这里说的服务器，其实是web服务器，或者应用服务器。它本质就是一个软件，一个应用。作用就是发布我们的应用（工程），让用户可以通过浏览器访问我们的应用。
常见的应用服务器，请看下表：
服务器名称说明weblogic实现了javaEE规范，重量级服务器，又称为javaEE容器websphereAS实现了javaEE规范，重量级服务器。JBOSSAS实现了JavaEE规范，重量级服务器。免费的。Tomcat实现了jsp/servlet规范，是一个轻量级服务器，开源免费。 2.1.2 Tomcat下载与安装 Tomcat官网下载地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03f73751aaaafc3978d40bb0cb7f78de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d3f923e2ad8fcb106c59edb6106625/" rel="bookmark">
			java 日志系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java 日志系统-转载 各个库单独使用1. log4j2. log4j23. logback 各个库实现slf4j标准使用1. log4j实现方式，引入slf4j-log4j122. log4j2的实现方式，引入log4j-slf4j-impl 多依赖项目的日志统一小结原始链接 SLF4j是日志门面api，log4j、log4j2、logback才是真正的日志实现库。 各个库单独使用 1. log4j &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; classpath下配置文件log4j.properties
log4j.rootLogger=INFO,console log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.target=System.out log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} [%p] %c: %m%n 使用：
import org.apache.log4j.Logger; // ... static final Logger LOGGER = Logger.getLogger(Main.class); 2. log4j2 &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; classpath下log4j2.properties
rootLogger.level = info rootLogger.appenderRef.stdout.ref = STDOUT appender.console.type = Console appender.console.name = STDOUT appender.console.layout.type = PatternLayout appender.console.layout.pattern = %d{yyyy-MM-dd HH:mm:ss} [%p] %c: %m%n 若使用上面配置文件不行，则在classpath 下建立"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1d3f923e2ad8fcb106c59edb6106625/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a74e4847d40c320b7a9c73febfce1b0/" rel="bookmark">
			istanbul-middleware
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		istanbul-middleware istanbul-middleware（后面简称 middleware）本质上是一个基于 express 的网站。但其包含了数个针对 istanbul 覆盖率收集及报告生成的 http 接口，因此可用于作为单独的覆盖率报告生成网站。
覆盖率相关接口信息（基础路径为 coverage ，如重置覆盖率数据，需要访问的路径是 http://localhost/coverage/reset ）： URLDescriptionGET /动态生成覆盖率 html 报告。和平时单测生成的静态版本一样，可以通过点击逐级深入，查看更细节的覆盖率数据。POST /reset把覆盖率数据重置成基线（可以理解成清空当前覆盖率数据）GET /download下载一个包含 json 、lcov、html 三种格式覆盖率报告的压缩包POST /client用于从浏览器主动发送覆盖率对象。覆盖率对象必须是 json 格式，且发送时 header 中必须有 Content-type: application/json 。这个对象需要和当前服务端已有的统计数据保持一致。补充：即不能把不同程序的覆盖率数据都一起发给同一个 middleware 服务端。 覆盖率收集的两种方式 middleware 支持 server 端的覆盖率数据收集。middleware 支持 browser 端的覆盖率数据收集。 server 端 通过 hook require 方法，自动在运行时给 server 端文件插桩。同时添加 /coverage 路径的 handler ，处理上述的覆盖率接口请求。核心方法：im.hookLoader(__dirname);，app.use('/coverage', im.createHandler()); 项目运行分析 通过打断点的方式来查看server端自动插装过程
项目debug模式运行，首先通过hookLoader传入两个参数，第一个参数主要匹配除了node_modules外其他全部需要插装的问价路径，第二个参数主要是插装的一些配置选项hookLoader中加入Instrumenter对象，然后通过本地方法instrumenter.instrumentSync.bind(instrumenter)获得一个transformer(本地方法),把相关参数传入,postLoadHook(matcherFn, transformer, opts.verbose)获得postLoadHookFn通过hook.hookRequire（本地方法）的方法对服务端代码进行插装，通过postLoadHook,postLoadHookFn传入相关js文件，通过saveBaseline函数对插装的函数进行保存，在saveBaseline中baselineCoverage可以获得插装后的js文件信息 function saveBaseline(file) { var coverageObject = getCoverageObject(), fileCoverage; if (coverageObject &amp;&amp; coverageObject[file]) { fileCoverage = coverageObject[file]; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a74e4847d40c320b7a9c73febfce1b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc676fa57314c5f3c7aac50b6efd1065/" rel="bookmark">
			K8s集群环境搭建—K8s集群初始化（4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习来源： 51cto: https://edu.51cto.com/sd/518e5
腾讯课堂: https://ke.qq.com/course/2738602
K8s集群环境搭建—基础环境配置（1）：https://blog.csdn.net/qq_26900081/article/details/109291999
K8s集群环境搭建—K8s安装（2）：https://blog.csdn.net/qq_26900081/article/details/109311033
K8s集群环境搭建—安装Keepalived和HAProxy（3）：https://blog.csdn.net/qq_26900081/article/details/109331192
K8s集群环境搭建—K8s集群初始化（4）：https://blog.csdn.net/qq_26900081/article/details/109331192
K8s集群环境搭建—安装Metrics和Dashboard（5）：https://blog.csdn.net/qq_26900081/article/details/109337475
一、各Master节点的kubeadm-config.yaml配置文件如下
vi kubeadm-config.yaml
apiVersion: kubeadm.k8s.io/v1beta2 bootstrapTokens: - groups: - system:bootstrappers:kubeadm:default-node-token token: 7t2weq.bjbawausm0jaxury ttl: 24h0m0s usages: - signing - authentication kind: InitConfiguration localAPIEndpoint: advertiseAddress: 192.168.70.131 bindPort: 6443 nodeRegistration: criSocket: /var/run/dockershim.sock name: localhost.master1.131 taints: - effect: NoSchedule key: node-role.kubernetes.io/master --- apiServer: certSANs: - 192.168.70.200 timeoutForControlPlane: 4m0s apiVersion: kubeadm.k8s.io/v1beta2 certificatesDir: /etc/kubernetes/pki clusterName: kubernetes controlPlaneEndpoint: 192.168.70.200:16443 controllerManager: {} dns: type: CoreDNS etcd: local: dataDir: /var/lib/etcd imageRepository: registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc676fa57314c5f3c7aac50b6efd1065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbceff6c2e02249503ecb72ab8b93d06/" rel="bookmark">
			K8s集群环境搭建—K8s安装（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习来源： 51cto: https://edu.51cto.com/sd/518e5
腾讯课堂: https://ke.qq.com/course/2738602
K8s集群环境搭建—基础环境配置（1）：https://blog.csdn.net/qq_26900081/article/details/109291999
K8s集群环境搭建—K8s安装（2）：https://blog.csdn.net/qq_26900081/article/details/109311033
K8s集群环境搭建—安装Keepalived和HAProxy（3）：https://blog.csdn.net/qq_26900081/article/details/109331192
K8s集群环境搭建—K8s集群初始化（4）：https://blog.csdn.net/qq_26900081/article/details/109331192
K8s集群环境搭建—安装Metrics和Dashboard（5）：https://blog.csdn.net/qq_26900081/article/details/109337475
一、安装Docker(所有节点)
查看docker版本有哪些：yum list docker-ce.x86_64 --showduplicates | sort -r
a、CentOs 7直接安装
#安装最新版本的Docker yum install docker-ce -y #安装指定版本的Docker yum -y install docker-ce-17.09.1.ce-1.el7.centos b、CentOs 8 需要先安装containerd
#下载并安装containerd wget https://download.docker.com/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.13-3.2.el7.x86_64.rpm yum install containerd.io-1.2.13-3.2.el7.x86_64.rpm -y #安装最新版本的Docker yum install docker-ce -y #安装指定版本的Docker yum -y install docker-ce-17.09.1.ce-1.el7.centos 启动docker： systemctl start docker
开机自启动：systemctl enable docker
检查安装是否成功：docker info 如果执行结果有警告信息，都需要解决掉。
二、安装kubeadm(所有节点)
查看kubeadm版本信息：yum list kubeadm.x86_64 --showduplicates | sort -r
#安装指定版本的K8s组件 yum install -y kubeadm-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbceff6c2e02249503ecb72ab8b93d06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f93f265be7c7002621dc56be3043bf04/" rel="bookmark">
			K8s集群环境搭建—基础环境配置（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习来源： 51cto: https://edu.51cto.com/sd/518e5
腾讯课堂: https://ke.qq.com/course/2738602
K8s集群环境搭建—基础环境配置（1）：https://blog.csdn.net/qq_26900081/article/details/109291999
K8s集群环境搭建—K8s安装（2）：https://blog.csdn.net/qq_26900081/article/details/109311033
K8s集群环境搭建—安装Keepalived和HAProxy（3）：https://blog.csdn.net/qq_26900081/article/details/109331192
K8s集群环境搭建—K8s集群初始化（4）：https://blog.csdn.net/qq_26900081/article/details/109331192
K8s集群环境搭建—安装Metrics和Dashboard（5）：https://blog.csdn.net/qq_26900081/article/details/109337475
K8s版本：1.19.3
Docker版本：19.03
CentOs版本：7.7.1908
准备五台Centos服务器（最后一个是VIP）：
192.168.70.131 localhost.master1.131 192.168.70.132 localhost.master2.132 192.168.70.133 localhost.master3.133 192.168.70.134 localhost.node1.134 192.168.70.135 localhost.node2.135 192.168.70.200 k8s-master-lb 一、基础环境配置（所有节点）
1.1 所有节点设置地址映射(使用主机名通讯速度快)：vi /etc/hosts
1.2 所有节点关闭防火墙、selinux、dnsmasq、swap
systemctl disable --now firewalld systemctl disable --now dnsmasq #一般没有dnsmasq，报错属于正常 systemctl disable --now NetworkManager #CentOS8无需关闭 setenforce 0 1.3 关闭selinux：vi /etc/sysconfig/selinux
不关闭可能会导致安装K8s失败
1.4 关闭swap（会影响性能，一般关闭掉）：swapoff -a &amp;&amp; sysctl -w vm.swappiness=0
vi /etc/fstab 1.5 安装ntpdate来同步服务器时间
a、CentOs 7
yum -y install ntp ntpdate b、CentOs 8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f93f265be7c7002621dc56be3043bf04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1914e037b61bcb85c4c4c79d95b7e7/" rel="bookmark">
			ROS中的坐标系定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS最常用到的三个坐标系是：map、odom、base_link。
base_link描述的就是机器人当前时刻的位姿，是移动的坐标系。
odom是机器人运动的参考坐标系，是固定不动的（world fixed frame）。坐标系原点设为机器人的运动起始点，那么机器人的位姿是相对于odom来描述的。
map是世界坐标系，是固定不动的（world fixed frame）。可以在机器人所在的环境中随意指定一个点作为世界坐标系原点，规定其具体的朝向，那么分布在不同地方的所有的机器人和其他设备（包括激光雷达、相机等等）的坐标都可以统一到这个坐标系下。map可以和odom重合，也可以不重合，取决于实际需要。通过map和odom之间的变换，可以得到机器人相对于世界坐标系的位姿。
REP105提到：
The map frame is not continuous, meaning the pose of a mobile platform in the map frame can change in discrete jumps at any time.
In a typical setup, a localization component constantly re-computes the robot pose in the map frame based on sensor observations, therefore eliminating drift, but causing discrete jumps when new sensor information arrives.
这里指的应该是SLAM中的回环检测在发现回环后，通过非线性优化消除视觉里程计的累积误差时，可能会顺带着把机器人的起始位姿给优化了，比如机器人在世界坐标系中的初始坐标是(1,2,3)，优化后变成（1.1,2.2,3.3），而机器人起始位姿和世界坐标系之间的关系是固定的，那么世界坐标系也会随着跳到一个新的位置，这就是文中说到的“discrete jumps”。这有两个解决方案：
优化时保持第一个位姿固定优化所有位姿，但是要对优化后的所有位姿做一个变换，使得第一个位姿恢复原样。 注意在odom下表达的位姿没有上述问题，因为不管怎么优化，总是设置机器人起始位置在odom坐标系下就是(0,0,0)，后面的位姿也都是相对于这个来计算，因此odom坐标系本身不会跳变。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b1914e037b61bcb85c4c4c79d95b7e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cefdee0701fb2dd871a2888924baec3a/" rel="bookmark">
			postgresql空间数据库入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装软件
postgresql-10.14-1-windows-x64.exe
官网：https://www.enterprisedb.com/downloads/postgresql
链接：https://pan.baidu.com/s/1aMaEGwhR6vFEY5B87-O9bw
提取码：fba5
2、设置防火墙
3、设置局域网可访问IP
在安装目录的\data下
IP可设置所有通用0.0.0.0/0，也可以按需设置，别忘了设置防火墙
4、打开自带的可视化工具，连接数据库，自行创建数据库等等
5、导入shp
安装可视化工具
postgis-bundle-pg10x64-setup-2.4.0-1.exe
链接：https://pan.baidu.com/s/1SqJSsR8af6teOkyYoB1jsg
提取码：urix
安装完后打开工具，连接数据库
先给导入的数据库增加空间扩展功能：
在这打开连接之后输入
CREATE EXTENSION postgis; CREATE EXTENSION pgrouting; CREATE EXTENSION postgis_topology; CREATE EXTENSION fuzzystrmatch; CREATE EXTENSION postgis_tiger_geocoder; CREATE EXTENSION address_standardizer; 只有导入上面的扩展，数据库才支持导入空间数据，谨记！！！
继续导入shp的设置
导入shp文件设置，下面是导入面的设置，如果是线好像还要勾选最后一项
导入完成
在可视化页面上也是可以看到的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e745db9ca4b12c163a3841afa1b710/" rel="bookmark">
			JAVA的字符串排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /*
字符串（整数序列）排序： 输入： “34, 45, 12, 23, 78, 90, 65” 输出： “12, 23, 34, 45, 65, 78, 90” 1.字符串——&gt;数组2.String 数组——&gt;int 数组3.int数组排序4.int 数组——&gt;字符串 *
*/ public class StringSort { public static void main(String[] args) { String ss= "34,45,12,23,78,90,65"; //1.字符串——&gt;数组 String s[]=ss.split(","); //2.String 数组——&gt;int 数组 int it[]=new int[s.length]; for(int i=0;i&lt;s.length;i++) { int t=(new Integer(s[i])).intValue(); it[i]=t;	} //3.int数组排序 java.util.Arrays.sort(it); //4.int 数组——&gt;字符串 StringBuffer sb=new StringBuffer(); for(int i=0;i&lt;it.length;i++) { sb.append(it[i]+" "); } System.out.println(sb.toString()); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd934310cc41e15978a82bcf4cbed2a5/" rel="bookmark">
			python画柱状图-Python绘图之柱形图绘制详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
用python编程绘图，其实非常简单。中学生、大学生、研究生都能通过这10篇教程从入门到精通！快速绘制几种简单的柱状图。
1垂直柱图（普通柱图）
绘制普通柱图的python代码如下：
（左右滑动可以查看全部代码）
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
# -*- coding:utf-8 -*-
# 申明编码格式为utf-8
import matplotlib as mpl
import matplotlib.pyplot as plt
mpl.rcParams["font.sans-serif"]=["SimHei"]
#指定字体为SimHei，用于显示中文，如果Ariel,中文会乱码
mpl.rcParams["axes.unicode_minus"]=False
#用来正常显示负号
x= [1,2,3,4,5,6,7,8]
y= [30,11,42,53,81,98,72,25]
#数据
abels=["A","B","C","D","E","F","G","H"]
#定义柱子的标签
plt.bar(x,y,align="center",color="rgb",tick_label=labels,hatch=" ",ec='gray')
#绘制纵向柱状图,hatch定义柱图的斜纹填充，省略该参数表示默认不填充。
#bar柱图函数还有以下参数：
#颜色：color,可以取具体颜色如red(简写为r),也可以用rgb让每条柱子采用不同颜色。
#描边：edgecolor（ec）：边缘颜色；linestyle（ls）：边缘样式；linewidth（lw）：边缘粗细
#填充：hatch，取值：/,|,-,+,x,o,O,.,*
#位置标志：tick_label
plt.xlabel(u"样品编号")
plt.ylabel(u"库伦效率/%")
plt.show()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd934310cc41e15978a82bcf4cbed2a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/400adc72ed5149db72ed36dbfaee1f2f/" rel="bookmark">
			golang中的strings.HasPrefix
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 golang中的字符串操作strings.HasPrefix
package main import ( "fmt" "strings" ) //golang字符串操作 func main(){ s := "hello world hello world" //str := "wo" //var s = []string{"11","22","33"} //判断字符串s是否以prefix开头 ret := strings.HasPrefix(s,"he") fmt.Println(ret) //true } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e801298d8765581d5d19773810a56c5/" rel="bookmark">
			mac下Soundflower安装失败的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载Soundflower [Soundflower下载地址​] https://github.com/mattingalls/Soundflower/releases/tag/2.0b2 2. 处理一 run文件夹中的uninstall soundflower.scpt文件
3. 如果问题未处理 可以重启，再试
4. 如果还是不行 打开终端，输入sudo spctl --master-disable点击回车键，输入密码，再点击回车键
打开系统便好设置，可以看到MATT INGALLS系统软件已被阻止载入，点击允许，在尝试安装就可以了
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/347/">«</a>
	<span class="pagination__item pagination__item--current">348/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/349/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>