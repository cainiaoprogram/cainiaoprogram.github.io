<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8fbbb46a4da67cb7892e526039d6f74/" rel="bookmark">
			::在c&#43;&#43;中什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好多年没有用c++ 了，今天在研究深度学习部署框架ncnn，看到这个突然想不起来了，就查了一下资料。
"::"在C++中表示作用域，和所属关系。"::"是运算符中等级最高的，它分为三种，分别如下：
一、作用域符号：
作用域符号”::“的前面一般是类名称，后面一般是该类的成员名称，C++为例避免不同的类有名称相同的成员而采用作用域的方式进行区分。
例如：A,B表示两个类，在A,B中都有成员member。
那么：
1、A::member就表示类A中的成员member。
2、B::member就表示类B中的成员member。
二、全局作用域符号：
全局作用域符号：当全局变量在局部函数中与其中某个变量重名，那么就可以用::来区分，例如：
三、作用域分解运算符：
::是C++里的作用域分解运算符，“比如声明了一个类A，类A里声明了一个成员函数voidf()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成voidA::f()，表示这个f()函数是类A的成员函数。例如：
扩展资料：
C++的运算符（运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符）具体以下：
1、算术运算符。
2、关系运算符。
3、逻辑运算符。
4、位运算符。
5、赋值运算符。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc8daf1af71c5d4034dde88c03fd7284/" rel="bookmark">
			Android——一个简单的记账本APP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个简单的记账本APP 视频效果预览添加账目记录效果预览添加账目记录实现简述实现获取日期字符串时间戳转DateDate转星期 获取时间Switch控制显示和隐藏更改Switch样式事件监听 保存至SQLite数据库 标签选择实现效果预览实现状态改变事件监听状态监听 导航界面创建menu创建Fragment绑定Fragment 账单记录显示效果预览简述RecyclerView显示建立适配器获取数据源保留两位小数 概览效果预览简述分类显示创建适配器获取数据源 前三甲创建适配器获取数据源 单标签总价以及总金额 可视化概览效果预览简述折线图获取数据源 南丁格尔玫瑰图获取数据源 记录删除效果图释 尾言 视频效果预览 添加账目记录 效果预览 添加账目记录实现 简述 日期选择采用CalendarView控件，时间选择采用TimePicker控件，然后通过switch控件控制其VISIBLE和GONE属性，类型通过PopUpWindows弹窗显示，标签通过SharedPreferences进行传递。最后插入SQLite数据库中。
实现 获取日期 因为获取的日历控件的月份要比实际少一个月，故因此需要把月份加上一。
然后将获取的年月日字符串数据转为Date格式，最后将Date格式转为当时的星期
字符串时间戳转Date public static Date getStringToDate(String str){ mSimpleDateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()); try { Date date = mSimpleDateFormat.parse(str); return date; } catch (ParseException e) { e.printStackTrace(); } return null; } Date转星期 public static String getWeekOfDate(Date date) { String[] weekDays = {"星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc8daf1af71c5d4034dde88c03fd7284/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9860322b2aa2c51e537b9841b407c3b6/" rel="bookmark">
			php 操作sqlite
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的php版本7.3.4 前提工作：
打开php.init文件，开启sqlite3扩展：
;extension=sqlite3
把前面的分号去掉保存，重启服务器即可。
SQLite介绍： SQLite是一个开源的、嵌入式的关系型数据库，它的数据库就是一个后缀名为 xx.db xx.db3 xx.sqlite xx.sqlie3的文件。
使用SQLite3连接 xx.db 数据库文件： 文件：
先看一下stuinfo1.db文件(用DB Browser for SQLite可视化工具): 有一张stu表：
stu表的数据：
方法1：用 SQLite3 类 连接sqlite的数据库文件： stuinfo1.php文件：
&lt;?php //如果xx.db不存在的话则直接创建一个，存在的话直接使用。 $filePath = "stuinfo1.db"; $sqlite = new SQLite3($filePath); if(!$sqlite){ echo "错误状态码：".$sqlite-&gt;lastErrorCode(); echo "错误信息：".$sqlite-&gt;lastErrorMsg(); $sqlite-&gt;close(); die("失败"); } $sql = "select * from stu"; $result = $sqlite-&gt;query($sql); $table=""; while($rows = $result-&gt;fetchArray(1)){ $table.="&lt;tr&gt;&lt;td&gt;$rows[id]&lt;/td&gt;&lt;td&gt;$rows[name]&lt;/td&gt;&lt;td&gt;$rows[username]&lt;/td&gt;&lt;td&gt;$rows[bankCardNum]&lt;/td&gt;&lt;td&gt;$rows[money]&lt;/td&gt;&lt;td&gt;$rows[clas2]&lt;/td&gt;&lt;/tr&gt;"; } ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;stuinfo1&lt;/title&gt; &lt;style type="text/css"&gt; *{margin:0;padding:0;} html,body{width:100%;} body { font: normal 12px auto "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9860322b2aa2c51e537b9841b407c3b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a077f097a3b69f9fdda57b74feb8bdd/" rel="bookmark">
			信息安全——维吉尼亚密码算法（C&#43;&#43;实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信息安全导论课程学习的实验一，维吉尼亚密码算法C++的实现。 维吉尼亚密码算法是一种代换密码算法，直观上来说，密钥一般短于明文长度，因此加密时需要将明文根据密钥长度进行分组，每一组明文根据密钥对应（0-25）进行移位；
以下是具体原理：
【原理】
1） 算法原理
a) Vigenere密码是由法国密码学家Blaise de Vigenere于1858年提出的一种代换密码，它是多表代换密码的典型代表。
b) 定义：设m为某一固定的正整数，P、C和K分别为明文空间、密文空间和密钥空间，并且P=K=C=(Z26)m，对一个密钥k=(k1,k2,…,km)，定义维吉尼亚密码的加解密算法如下：
Vigenere密码加密算法： ek(x1,x2,…,xm)=(x1+k1,x2+k2,…,xm+km)
Vigenere密码解密算法： dk(y1,y2,…,ym)=(y1-k1,y2-k2,…,ym-km)。
其中k=(k1,k2,…,km)是一个长为m的密钥字，密钥空间的大小为26m，所以对一个相对小的m，穷举密钥也需要很长的时间。如m=7，则密钥空间大小超过8×109，所以手工搜索非常困难。当明文的长度超过m时，可将明文串按长度m分局，然后对每一组使用密钥k加密。
2) 算法参数
Vigenere密码算法主要有c、m、k三个个参数。c为密文，m是明文，k为密钥。
维吉尼亚密码算法也较为简单，因此直接通过代码理解：
//vignere密码 #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; //加密 string encrypt(string m, string k) { string c = ""; int k_len = k.size(), m_len = m.size(), s = 0; for (int i = 0; i &lt; m_len; i++) { //其它字符 if (m[i] &gt;= 'a' &amp;&amp; m[i] &lt;= 'z') { int j = (i - s) % k_len; c += (m[i] - 'a' + k[j] - 'a') % 26 + 'a'; } else if (m[i] &gt;= 'A' &amp;&amp; m[i] &lt;= 'Z') { int j = (i - s) % k_len; c += (m[i] - 'A' + k[j] - 'a') % 26 + 'A'; } else { c += m[i]; s++; } } return c; } //解密 string decrypt(string c, string k) { string m = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a077f097a3b69f9fdda57b74feb8bdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45cfca4e884d063709ab1ff0745f3c6a/" rel="bookmark">
			【图神经网络】使用DGL框架实现简单图分类任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用DGL框架实现简单图分类任务 简单图分类任务实现过程打包一个图的小批量定义图分类器图卷积读出和分类 准备和训练核心代码参考资料 图分类（预测图的标签）是图结构数据里一类重要的问题。它的应用广泛，可见于生物信息学、化学信息学、社交网络分析、城市计算以及网络安全。随着近来学界对于图神经网络的热情持续高涨，出现了一批用图神经网络做图分类的工作。比如 训练图神经网络来预测蛋白质结构的性质，根据社交网络结构来预测用户的所属社区等（Ying et al., 2018, Cangea et al., 2018, Knyazev et al., 2018, Bianchi et al., 2019, Liao et al., 2019, Gao et al., 2019）。 本文使用DGL框架实现简单的图分类任务，任务目标有两个：
如何使用DGL批量化处理大小各异的图数据训练图神经网络完成一个简单的图分类任务 简单图分类任务 这里设计了一个简单的图分类任务。在DGL里已经实现了一个迷你图分类数据集（MiniGCDataset）。它由以下8类图结构数据组成。每一类图包含同样数量的随机样本。任务目标是训练图神经网络模型对这些样本进行分类。
实现过程 以下是使用 MiniGCDataset 的示例代码。
首先，创建了一个拥有 100 个样本的数据集。数据集中每张图随机有 16 到 32 个节点。DGL 中所有的数据集类都符合 Sequence 的抽象结构——既可以使用 dataset[i] 来访问第 i 个样本。这里每个样本包含图结构以及它对应的标签。
运行以上代码，可以画出数据集中第64个样本的图结果及其对应的标签：
打包一个图的小批量 为了更高效地训练神经网络，一个常见的做法是将多个样本打包成小批量（mini-batch）。打包尺寸相同的张量样本非常简单。比如说打包两个尺寸为 2828 的图片会得到一个 22828 的张量。相较之下，打包图面临两个挑战：
（1）图的边比较稀疏
（2）图的大小、形状各不相同
DGL 提供了名为 dgl.batch 的接口来实现打包一个图批量的功能。其核心思路非常简单**。将 n 张小图打包在一起的操作可以看成是生成一张含 n 个不相连小图的大图**。下图的可视化从直觉上解释了 dgl.batch 的功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45cfca4e884d063709ab1ff0745f3c6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6beabb0aa3cd97da9368bd7b3a2011/" rel="bookmark">
			HCSC: Hierarchical Contrastive Selective Coding
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原型对比学习：图像表征与聚类中心之间的交互，可以简单总结为在表征空间中最大化图像特征与其所属的聚类中心的相似度。 分层语义结构 自然存在于图像数据集中，其中几个语义相关的图像簇可以进一步集成到一个更大的簇中，具有更粗粒度的语义。用图像表示捕获这样的结构可以极大地促进对各种下游任务的语义理解。现有的对比表示学习方法缺乏如此重要的模型能力。此外，这些方法中使用的负样本对不能保证在语义上是不同的，这可能会进一步妨碍学习图像表示的结构正确性。 在这个框架中，一组层次原型被构建并动态更新，以表示隐空间中数据背后的层次语义结构。该方案旨在 选择具有相似语义的更多样化的正对和具有真正不同语义的更精确的负对。 在过去的几年里，自监督图像表示学习取得了长足的进步，其中基于解决信息难题的传统方法 [12, 16, 33, 34, 49] 明显被对比学习方法 [6-8, 19,36]超越。 现有的对比方法主要可以分为两类，实例对比学习[7 SimCLR,19 MoCo,36 CPC]和原型对比学习[6 SwAV,27]。 1.实例对比 旨在隐空间中 将相似的实例映射到附近，同时 将不同的实例映射到相距较远，这保证了不同图像表示之间的合理局部结构。 2.原型对比 旨在获得 聚集在相应聚类中心周围的 紧凑图像表示，它捕获了一些可以由单个聚类层次结构表示的基本语义结构。 然而，在对可能始终 拥有多个语义层次结构 的大规模图像数据集进行建模时，这些方法在表示能力上落后。学习包含图1这种分层语义结构的图像表示可以极大地促进对各种下游任务的语义理解。 此外，现有的对比方法 通常通过对某些噪声分布进行穷举采样来构造负对，并且 所有采样的负对均不经选择地使用。不能保证 以这种方式 获得的负样本对拥有真正不同的语义。因此，一些语义相似的样本可能会被这些方法错误地嵌入相距很远的地方，从而影响学习图像表示的质量。 在HCSC框架中，我们建议使用 分层原型 捕获数据底层的分层语义结构，分层原型是隐空间中的一组 树结构的 表征的嵌入。在训练过程中，这些原型会 动态更新 以适应当前的图像表示。在这种分层语义结构的指导下，我们寻求 通过 选择语义正确的高质量正负对 来改进实例和原型对比学习。 创新点： 1.提出通过 动态维护分层原型 来表示图像表示的分层语义结构; 2.提出了一种新颖的对比学习框架，分层对比选择性编码（HCSC），它通过 选择语义正确的正负对 来改进传统的实例和原型对比学习。 ·解决puzzles的前置任务：不能保证为不同的下游任务获得有区别的特征表示。 ·实例对比学习：试图在隐空间将相似的实例嵌入到附近，而将相异的实例嵌入相距很远的地方。标准的实例对比方法[7,19,42]通过最大化相关实例之间的互信息来实现这一目标，即使用 InfoNCE 损失进行优化。然而，这些方法 并不了解整个数据集的全局语义。 标准 InfoNCE 损失 [36] 以最大化该正对之间的相似性并最小化一些随机采样的负对之间的相似性。 ·原型对比学习：通过利用 图像簇的原型 表示来明确地利用语义结构。然而，所有这些方法都表示单一层次的语义簇，这忽略了图像数据集自然具有层次语义的重要事实。 每个正对 由一个实例及其关联的语义原型组成，负对 由实例与不相关的语义原型配对形成。以这种对构造的方式，给定一个正对 (z, c)，ProtoNCE 损失。 我们寻求学习 具有多个语义层次结构 的图像表示。DeeperCluster [5] 通过分层预测聚类分配在这个方向上进行了尝试。相比之下，我们的方法利用 对比选择性编码 来更准确地发现数据的语义层次结构。 给定 N 个未标记图像的集合 X = {x1, x2, ···, xN}，我们的目标是为每个 xn ∈ X 学习一个低维向量 zn ∈ Rδ。除了图像表示Z 之外，我们还 维护一组 层次原型 C 来表征数据底层的层次语义结构， 受这些限制的启发，我们提出了一种新颖的对比学习框架，称为分层对比选择性编码（HCSC）。简而言之，我们用分层原型表示数据的语义结构，并在训练过程中动态更新这些原型（第 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab6beabb0aa3cd97da9368bd7b3a2011/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91268157be25d55482af861d45787e42/" rel="bookmark">
			Apache Atlas删除元数据实体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Atlas删除元数据实体 数据删除的模式 在Apache Atlas中，元数据、元数据类型模型的删除模式分为两种
硬删除(物理删除)：硬删除是从计算机系统内删除数据，无法找回软删除(逻辑删除)：是将元数据实体等标记为删除状态，但是仍然可以查询 在Apache Atlas中，元数据导入流程如下：
​ 定义元数据模型(type) -&gt; 依据元数据模型，创建元数据实体(entity) -&gt; 对元数据增删改查操作
所以，如果要删除元数据类型模型(type)，则必须删除所有对应的(entity)，且软删除无法奏效，需要硬删除；可见，类型系统的定义必须慎重，否则将带来很大麻烦。
如何配置删除模式 配置硬删除 Atlas中的删除模式是 物理删除 或 逻辑删除 的重点是配置对应的DeleteHandler；
通过修改atlas-application.properties配置文件的atlas.DeleteHandlerV1.impl变量，设置对应的参数值，来配置删除的模式(软删除或硬删除),然后重启atlas即可。
软删除中，atlas的entity有如下状态：ACTIVE, DELETED, PURGED。
官方注释：Status of the entity - can be active or deleted. Deleted entities are not removed from Atlas store.
atlas-application.properties配置信息如下：
# Delete handler # # This allows the default behavior of doing "soft" deletes to be changed. # # Allowed Values: # org.apache.atlas.repository.store.graph.v1.SoftDeleteHandlerV1 - all deletes are "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91268157be25d55482af861d45787e42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6e3db5b6cd80af4cc87dcf795562b1e/" rel="bookmark">
			timer/counter在SOC中的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 timer主要用于计数时钟周期，一般有以下几个应用场景：
产生周期性的事件(如中断)用于操作系统的超时(timeout)机制用于操作系统定期的上下文切换用作watchdog counter的作用包括：
计数外部输入信号发生的次数计数某输入信号维持特定值的时钟周期数用作PWM，通过计数并设定翻转阈值，产生一个可调整频率和占空比的方波，用于控制芯片外部的设备（例如，通过调整占空比，控制外部LED的亮度） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/580b6fbb50841e99b412cbd5e726aa62/" rel="bookmark">
			低功耗蓝牙（BLE）的工作模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BLE常见的四种工作模式
蓝牙广播模式、蓝牙从机模式、蓝牙主机模式、观察者模式
蓝牙广播模式
处于广播模式的设备，一般会被设置成不可连接的状态，常见的例子有beacon。
beacon会每隔一定的时间广播一个数据包到周围空间中，周围作为独立的蓝牙主机在执行扫描动作时，会间隔的接收到beacon广播的数据包。该数据包最多可以包含31字节的内容。收到广播包的设备还能读取到beacon的MAC地址和当前接收信号的强度值RSSI。
蓝牙从机模式
代表例子是蓝牙智能手环、心率带等等。
工作在从机模式下设备也处于广播状态，等待被扫描。和广播模式不同的是，从机模式设备是可以被连接的，在数据传输过程中作为从机存在。
蓝牙主机模式
典型的例子是智能手机
处于主机模式的设备无广播，可以扫描周围正在广播的设备，可以要求与广播设备进行连接，在连接中作为主机存在。
观察者模式
代表例子是蓝牙网关
观察者模式设备无广播，可以扫描周围的广播设备，但不能要求与广播设备的连接。
蓝牙网关利用星型网络和中继技术将多个蓝牙设备加入到网络中，节点数可以超过65000个，网络与网络之间还可以互联。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83c93251cd284664c74656441cac3a73/" rel="bookmark">
			打开网页出现错误提示out of memory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 打开网页，内容加载完成后又突然消失
出现错误提示：out of memory
问题原因： out of memory的意思是内存溢出
出现这个问题说明系统内存占用过高
还可能会导致程序崩溃、桌面壁纸显示不全等问题
快速解决： 关闭后台正在运行的大量应用，重启浏览器
永久解决方案： 1、win+s 搜索性能，打开调整Windows的外观和性能
2、选择高级、更改
3、勾选 自动管理所有驱动器的分页文件大小（这也是win10系统默认的虚拟内存管理方式）
原理： 设置虚拟内存，系统会从磁盘中分配一部分存储空间，充当内存使用。这样可以有效避免内存不够的问题，缺点是磁盘的速度远低于内存，开启后会在一定程度上拖慢系统速度。
要知道我们使用的电脑大多数都是8G或者16G的内存，8G内存的电脑，系统给你分配的虚拟内存大小甚至可以达到9000MB。
可想而知，如果你是一个重度用户，16G内存也不足以支撑你的使用。
最后，电脑系统上面的设置不要轻易做改动，虽然按网上教的操作关闭虚拟内存可以提高速度，但是对一个小白来说，出现问题找解决办法会更麻烦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faa99b6c3a4312d1accb650b9aa79755/" rel="bookmark">
			Gitlab搭建详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gitlab的概念 GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的Web服务。安装方法是参考GitLab在GitHub上的Wiki页面。Gitlab是目前被广泛使用的基于git的开源代码管理平台, 基于Ruby on Rails构建, 主要针对软件开发过程中产生的代码和文档进行管理, Gitlab主要针对group和project两个维度进行代码和文档管理, 其中group是群组, project是工程项目, 一个group可以管理多个project, 可以理解为一个群组中有多项软件开发任务, 而一个project中可能包含多个branch, 意为每个项目中有多个分支, 分支间相互独立, 不同分支可以进行归并。
定义 GitLab是由GitLabInc.开发，使用MIT许可证的基于网络的Git仓库管理工具，且具有wiki和issue跟踪功能。使用Git作为代码管理工具，并在此基础上搭建起来的web服务。
用到的git指令 git init ：初始化.git文件夹
git add 文件名：从本地工作区添加文件入暂存区
git add -A：从本地工作区添加全部文件入暂存区
git commit -m “添加的备注” 文件名：暂存区给文件备注确认，记录为一个版本
git commit -m “添加的备注” 文件名：暂存区全部文件备注确认，记录为一个版本
git log：查看历史版本记录
git status：查看文档修改记录，红色为未add内容，绿色为可以commit内容
git push 地址名 本地分支:远程库分支：将暂存区代码推入远程库
git remove add 地址名 地址url：远程库操作
git branch -M 分支名：创建分支
gitlab的安装与配置 gitlab-ce.repo源包
vim /etc/yum.repos.d/gitlab-ce.repo [gitlab-ce] name=Gitlab CE Repository baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/ gpgcheck=0 enabled=1 #yum makecache 或者这样装wget安装 wget https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faa99b6c3a4312d1accb650b9aa79755/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e050734c96df25a5696361e313cb9124/" rel="bookmark">
			如何在CSDN中发布文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.首先打开CSDN官网，然后进行注册和登录，登录成功后会显示头像，如下界面 2.如果选择发布按钮下的写文章，则直接进入设置好的默认写文章的界面中。也可以点击创作中心，点击后进入下面的界面 3.在创作中心这个界面的首页里面可以选择“Markdown编辑器”或者“富文本编辑器”，分别进入两种不同的编辑器，可以根据个人喜欢的方式进行编辑。 4.也可以在左侧的发布按钮中进入，但是这种方式进入的编辑器是在博客设置中设置的默认编辑器，例如此时设置的是Markdown编辑器，那点击后就进入该编辑器 5.进入Markdown编辑器，其界面如下 上面是标题部分。左侧是编辑区域，在此处编辑文章的内容。中间的部分是预览区域，左侧编辑完后，在此处可以看到效果。最右侧是一些语法的说明，复制对应的语法，可以快速实现效果。
6.编写完成后，可以点击保存草稿和发布文章按钮，点击发布文章的按钮后界面如下，把相对应的选项都填起来，填写成功后就可以发布了。 7.进入富文本编辑器，界面如下 8.发布前也需要下拉，填写封面，文章类型等。点击发布后，发文助手会对有些错别字/质量等进行检测，并且会给出提示 9全部成功后点击发布博客按钮，就发布成功了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80e6ccc05ce539ae16041e7c9fb9a7a4/" rel="bookmark">
			stm32使用串口进行通讯之发送数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提准备： 1.库函数基础模板
2.stlink下载器、USB-TTL下载器、单片机最小开发板stm32F103C8T6
3.面包板及相关接线
4.vscode与keil的联合开发更流畅
5.串口软件，这个下面视频有
本文基于 哔哩哔哩 江科大自化协STM32入门教学
知识讲的非常详细，非常感谢作者的无私奉献，本文主要是基于此进行试验笔记。便于以后查找。
1.在库函数模板的前提下，在工程文件下新建文件夹Hardware,然后在keil中将文件目录加一下，Hardware文件下的文件也可以在keil下添加，添加时注意文件目录。保存关闭keil，打开VScode显示以下文件说明添加成功。具体步骤就不详细说明了，写过LED灯的应该都有了解。
2.在Hardware中添加文件夹Serial.c用来配置串口发送数据函数
首先是配置GPIO时钟以及USART时钟
void Serial_Init(void) { GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; //定义USART结构体 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE); //开启时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 USART1 TX使用 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA,&amp;GPIO_InitStructure); USART_InitStructure.USART_BaudRate = 9600; //设置波特率9600，init函数内部会自动算好9600对应的分频系数 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //硬件流控制，不启用 USART_InitStructure.USART_Mode = USART_Mode_Tx; //USART模式：发送数据 USART_InitStructure.USART_Parity = USART_Parity_No; //校验位：无校验 USART_InitStructure.USART_StopBits = USART_StopBits_1; //停止位1 USART_InitStructure.USART_WordLength = USART_WordLength_8b; //字长，这里不需要校验，字长选择8位 USART_Init(USART1,&amp;USART_InitStructure); //初始化USART USART_Cmd(USART1,ENABLE); } 3.发送数据（以字节发送）
void Serial_SendByte(u8 Byte) { /*内部将Byte传递给Data变量，之后Data&amp;01FF,把无关的高位清零， 然后直接赋值给DR寄存器，通向TDR发送数据寄存器，再传递到移位寄存器最后一位一位传递给TX引脚*/ USART_SendData(USART1,Byte); //调用串口的SendDate()函数 /*写完数据，需要等待，等TDR的数据到移位寄存器，不然数据还在TDR进行等待，再写入数据会产生覆盖 所以发送之后，需要等待标志位 USART_FLAG_TXE 发送数据寄存器为空 标志位，要等待TXE为1，这里要嵌套循环 如果TXE为RESET就一直循环，直到TXE为SET */ while (USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET); /*关于标志位是否需要手动清楚的问题：标志位置1之后，不需要手动清0。因为对USART_DR进行写操作，将该位清0*/ } 主函数中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80e6ccc05ce539ae16041e7c9fb9a7a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7332ab07f727d3cb2461d166aebf4d3b/" rel="bookmark">
			Java基础Socket运用——服务端和客户端的信息交换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：小明喜欢小红，小红只会回复小明的消息，小明要主动发送消息，但是一旦双方中的一人说出了“再见”，则关系结束。
如题，小红为服务端，小明为客户端，服务端先运行等待客户端的数据，然后将自己的数据返回客户端。
首先，我们先搭建好服务端。
import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.util.Scanner; public class PS_Server { public static void main(String[] args) { try { //创建服务端端口 ServerSocket serverSocket = new ServerSocket(5000); //创建端口对象，存储服务端输入的数据 Socket socket = null; while (true) { System.out.println("等待数据中........."); //接收端口传来的数据 socket = serverSocket.accept(); //将接受到的数据导入传输流中 InputStream is = socket.getInputStream(); //读取输入流中的内容 BufferedReader br = new BufferedReader(new InputStreamReader(is)); String context; while ((context = br.readLine()) != null) { System.out.println("小明：" + context); if (context.equals("再见")){ System.out.println("对面已关闭链接"); return; } } //输入回复内容 Scanner in = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7332ab07f727d3cb2461d166aebf4d3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61fbc9ed2d599669a95563adda3badb5/" rel="bookmark">
			常用运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 运算符1算数运算符①基本运算符②目（1）分类（2）判断方法 ③表达式④运算符的优先级和结合性⑤类型转换 2.关系运算符①分支结构（1）功能 ②六大关系运算符③关系表达式（1）定义（2）逻辑值 3.逻辑运算符①三大逻辑运算符②逻辑表达式③短路求值 运算符 1算数运算符 ①基本运算符 注：除法的第一个５／３后面的结果是直接舍弃了小数，而５．０／３．０保留了小数。即为整数／整数＝整数，浮点数／浮点数＝浮点数。还有求余运算符必须是两个整数，除此之外，我们能看上表有相关双目和单目的内容，那么，我们应该怎么判断单目还有双目呢？
②目 （1）分类 1.单目运算符：如正、负号，逻辑运算符
2.双目运算符：算术运算符、关系运算符
3.三目运算符：条件运算符
（2）判断方法 如以下的例子
1+2//操作符+运算符+操作数//双目 +5//运算符+操作数//单目 根据以上的例子我们可以得知，判断为双目还是单目取决于操作数的数量。
③表达式 用运算符和括号将操作数连接起来的式子，我们称之为表达式。如下面例子所示
1+1 'a'+'b' a+b a+'b'+pow(a,b)*3/4+5 ④运算符的优先级和结合性 下面用一串代码来说明下运算符的优先级
#include&lt;stdio.h&gt; #include&lt;math.h&gt;//使得pow函数实现，所以必须引出 int main () { int a, b, c; a=1+2; b=1+2*3; c=a+b+-1+pow(2,3);//pow函数的作用就是给括号内的数字幂指数，pow（底数，幂指数），本复杂运算的数学表达是a+b+（-1）+2^3 printf("a=%d\nb=%d\nc=%d\n",a,b,c); return 0 ; } 最后的打印结果如下
⑤类型转换 当一个运算符的几个操作数类型不同的时候，会发生什么呢？比如以下例子
1+2.0=？//最后结果将是什么数据类型呢？ 1+2.0==1.0+2.0=3.0//最后答案为浮点型，这又是为什么呢？ 通常情况下，编译器会将占用内存较小的那个操作数先转换为占用内存较大的操作数的数据类型，然后再进行运算。这样做的目的是为了确保计算的精度。如果是把浮点型转换为整形的话如1.2+1这样的表达式，按照这种运算会直接把小数给舍弃就变成了1，那么它的结果变成了1+1=2了。以下用一串代码来进行理解。
#include&lt;stdio.h&gt; int main () { printf("整形输出：%d\n",1+2.0); printf("浮点型输出：%f\n",1+2.0); return 0 ; } 以下为打印结果
如果强制使它输入整形的结果贼会出现一个错误的答案，可是程序员是活的，我们可不可以用个办法强制让它输出的结果为整形呢？我们来看以下的代码
#include&lt;stdio.h&gt; int main() { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61fbc9ed2d599669a95563adda3badb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91fe22eaba5798bb907a334986cc5299/" rel="bookmark">
			尚硅谷智慧校园 —— 2、登录功能实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、登录的过程 2、验证码功能实现
3、登录校验功能实现
3.1、在 service 及其实现类添加登录验证方法
3.2、controller 方法
4、登录校验后从登录页跳转到首页
4.1、完成 service 方法及其实现类
4.2、完成 controller 方法
5、解决登录后用户头像错误问题
1、登录的过程 登录需要实现两个请求处理 第一次需要处理表单的内容，校验登录信息
第二次请求，会发送第一次请求的 token，需要处理这个 token，从而从登录页跳转到首页
2、验证码功能实现 在 SystemController 添加相应的方法
@RestController @RequestMapping("/sms/system") public class SystemController { @GetMapping("/getVerifiCodeImage") public void getVerifiCodeImage(HttpServletRequest request, HttpServletResponse response){ // 获取图片 BufferedImage verifiCodeImage = CreateVerifiCodeImage.getVerifiCodeImage(); // 获取图片上的验证码 char[] verifiCodeChars = CreateVerifiCodeImage.getVerifiCode(); String verifiCode = new String(verifiCodeChars); // 将验证码文本放入session域，为下一次验证做准备 HttpSession session = request.getSession(); session.setAttribute("verifiCode", verifiCode); try { // 将验证码图片响应给浏览器 ServletOutputStream outputStream = response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91fe22eaba5798bb907a334986cc5299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15721971a34f5377da426765d4224351/" rel="bookmark">
			动态库加载失败：error while loading shared libraries: xxx.so: cannot open shared object file: No such file o
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已解决：动态库加载失败：error while loading shared libraries: xxx.so: cannot open shared object file: No such file or directory 使用动态库编译链接main.c后，得到名为main的可执行程序。但是在运行main可执行程序时，程序报错：
./main: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory
如下图所示：
2. 问题出现的原因 首先利用ldd命令查看一下main的动态库依赖关系。
ldd main 1 结果如下图所示，可以看到，动态库libcalc.so没有被找到。
至于找不到的情况分为两种:
系统里根本不存在libcalc.so库；libcalc.so库在系统中存在，但是ld-linux.so找不到，即libxxx.so库的位置没有告知ld-linux.so。 由于动态库libcalc.so是自己刚刚创建好的，因此属于第二种情况。
由0.1 动态库的工作原理可知，只要把动态库libcalc.so的绝对路径添加到动态载入器ld-linux.so的搜索路径中，那么动态载入器就可以获取到动态库libcalc.so的绝对路径，接着就可以找到动态库文件libcalc.so，将动态库文件载入内存，然后就可以使用动态库里面的代码，最终可执行程序main就可以成功运行，不会报错。
还是由0.1 动态库的工作原理可知，动态载入器搜索动态库绝对路径的搜索顺序为：DT_RPATH段→环境变量LD_LIBRARY_PATH→/etc/ld.so.cache文件列表→/lib/或/usr/lib目录
因此，添加动态库绝对路径的方法也有很多种
接下来，我们就按照上述分析进行操作。
3. 解决问题 3.1 将动态库绝对路径添加至环境变量LD_LIBRARY_PATH 3.1.1 临时环境变量 首先进入存放动态库的文件夹内，然后输入如下命令，获取动态库libcalc.so的绝对路径，然后复制此绝对路径。
pwd的全称为Print Working Directory，即显示工作目录的路径。 pwd 1 输出如下：
然后输入如下命令，将动态库绝对路径添加至环境变量LD_LIBRARY_PATH中。其中：
export的意思是设置一个环境变量。$LD_LIBRARY_PATH的意思是，获取环境变量LD_LIBRARY_PATH当前的值。:/home/veroll/Linux/lesson1.6/library/lib的意思是，在冒号后写上要新加入环境变量的值，即动态库的绝对路径/home/veroll/Linux/lesson1.6/library/lib。 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/veroll/Linux/lesson1.6/library/lib 1 输入完上述命令后，输入如下命令检查一下环境变量LD_LIBRARY_PATH的值。其中：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15721971a34f5377da426765d4224351/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c539713b9fe491ab13e627fced5cdc/" rel="bookmark">
			索引【MySQL】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 概念 索引是一种特殊的文件，包含着对数据表里所有记录的引用指针。可以对表中的一列或多列创建索引， 并指定索引的类型，各类索引有各自的数据结构实现。
1.2 作用 数据库中的表、数据、索引之间的关系，类似于书架上的图书、书籍内容和书籍目录的关系。 索引所起的作用类似书籍目录，可用于快速定位、检索数据。 索引对于提高数据库的性能有很大的帮助。
1.3 使用场景 要考虑对数据库表的某列或某几列创建索引，需要考虑以下几点：
数据量较大，且经常对这些列进行条件查询。该数据库表的插入操作，及对这些列的修改操作频率较低。索引会占用额外的磁盘空间。 满足以上条件时，考虑对表中的这些字段创建索引，以提高查询效率。 反之，如果非条件查询列，或经常做插入、修改操作，或磁盘空间不足时，不考虑创建索引。
举一个形象的例子，索引本质上相当于“书的目录”，通过目录就可以快速的找到章节对应的位置，索引的效果就是加快了查找的速度。
数据库操作查的概率比增删改的概率要大得多，因此大多数情况下，引入索引还是比较好的选择，但是注意，索引也会增加增删改的时间开销（增删改需要调整已经创建好的索引目录），还会增加空间的开销（构造索引，也需要额外的硬盘空间来保存）。
1.4 使用 mysql数据库创建主键约束（PRIMARY KEY）、唯一约束（UNIQUE）、外键约束（FOREIGN KEY）时，会自动创建对应列的索引。
查看索引——show index from 表名; 创建索引：对于非主键、非唯一约束、非外键的字段，可以创建普通索引——create index 索引名 on 表名(字段名); 删除索引——drop index 索引名 on 表名; 创建索引最好是在表创建之初就把索引给搞好，否则在数据很多的情况下是很危险的操作。 吃掉大量的磁盘IO，这段时间内数据库是无法被正常运行的（删除索引也是如此） 针对性别这样的列添加索引是无法提高查找数据的要是已经有大量数据了，再进行操作就要慎重了 索引创建好之后不需要手动使用，直接查询的时候数据库会自动的来走索引，SQL是通过数据库的执行引擎来执行的，执行引擎内部会有优化操作（自动评估，选择成本最低，速度最快的方法），查询是否在走索引或者怎么走的是不好预测的，可以使用explain这个关键词来显示查询过程中具体的使用索引的情况。
索引在mysql中的数据结构 是哈希表吗？ 不是
哈希表只能比较相等，无法进行范围查询（显然mysql经常要范围查询）
是二叉搜索树吗？ 不是
二叉可以范围查询，但元素个数多了树的高度会很高，元素的比较次数就会比较多
是N叉搜索树（B树）吗？ 不是
虽然比较次数较二叉没怎么减少，但是读写硬盘的次数减少了
是B+树吗？ 是滴~
为数据库量身定做的数据结构
B+树也是一个N叉搜索树，每个节点上可能包含N个key，N个key划分出N个区间，最后一个key相当于是最大值。父元素的key会在子元素中重复出现，并且是子元素中的最大值（这样重复出现导致叶子节点包含了所有数据的全集，非叶子节点中的所有值都会在叶子节点中体现出来）叶子节点用类似链表的方式首尾相连 B+树的优点：
作为一个N叉树，高度降低了，比较的时候硬盘IO次数减少了更适合进行范围搜索所有的查询都是要落在叶子节点上的，所以无论查询哪个元素，中间比较的次数差不多，查询操作比较均衡由于所有的key都会在叶子节点中体现，因此非叶子节点不必存表的真实数据（数据行），只需要把所有的数据行给放到叶子节点上即可（非叶子节点只需要存索引列的值） 非叶子节点中只存了简单的id，所以空间成本大大降低，可以在内存中缓存，提高查询速度，减少硬盘IO次数。
B+树这个结构只是针对mysql的InnoDB这个数据库引擎里面所典型使用的数据结构。（不同的数据库所使用的数据结构也是不同的）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94922b1a8e4f9945ae4bb708c6a90e15/" rel="bookmark">
			安装conda时没有执行conda init
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装conda时，没有执行conda init，需要激活conda的环境
第一步 首先激活conda环境
/path/to/anaconda/bin/conda（修改为自己的路径） shell.你的shell名称（修改为自己的shell,一般为bash） hook &gt;&gt; ~/.bashrc
比如
/home/zhangsan/anaconda3/bin/conda shell.bash hook &gt;&gt;~/.bashrc 第二步 加载到环境中
source ~/.bashrc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d1ca0bb78474af0efccedfccac77688/" rel="bookmark">
			UnRaid安装CloudDrive以实现阿里云盘、天翼云盘、115网盘挂载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、前言2、准备工作2.1、修改Docker源2.2、开启Docker服务的MountFlags功能 3、添加Docker应用CloudDrive4、添加云盘 1、前言 最近一直在学习UnRaid这个Nas系统，折腾起来易用性十足，但由于其自带的应用市场不能完全满足所有人的需求，所以很多应用（Docker应用、插件）还得需要使用者自定义方式安装。作为各种云盘的忠实用户，读者可能也和笔者一样，拥有多个云盘账号，有没有办法将这些不同的云盘都挂载到自己的UnRaid系统中，以便统一的查询、调用呢？经过一番搜索，终于找到了大佬用爱发电CloudDrive在线网盘挂载应用，虽然在群晖等Nas系统中可以通过社区版的方式直接安装使用，但在UnRaid中只能通过Docker应用安装的方式来搭建。在搭设过程中颇费了一番周折，在此分享出来，以供有同样需求的童鞋们参考。
2、准备工作 2.1、修改Docker源 如果你之前已经将Docker源修改成阿里云的镜像源，必须修改成官方源或其它镜像源，因为阿里云镜像源中CloudDrive的版本还一直停留在1.1.58，这个版本目前是不能工作的，体现为无法注册账号也无法登陆，导致无法进入管理界面（我就是在这里折腾了很久没有成功，作了很多无用的尝试，最后终于发现了这个Bug，才算成功搞定）
2.2、开启Docker服务的MountFlags功能 关于这一步，在作者的DockerHub主页上提示有2中方法2选一，我尝试用第二种方法总是提示挂载点不存在，于是采用了第一种方法。
我直接在UnRaid的【工具】→【Config File Editor】中修改go文件，在末尾添加如下内容（即上图中第一种方法对应的代码）：
mkdir -p /etc/systemd/system/docker.service.d/
cat &lt; /etc/systemd/system/docker.service.d/clear_mount_propagation_flags.conf
[Service]
MountFlags=shared
EOF
保存→应用后，重启Unraid
3、添加Docker应用CloudDrive 在UnRaid的Docker界面直接添加容器（在app应用市场里是找不到CloudDrive的），打开高级视图，然后参照下图进行设置：
点击【应用】后，启动CloudDrive，点击WebUI下拉菜单即可开启管理页面，按提示登录（或注册新账号后登陆）添加云盘
4、添加云盘 登录后的样子：
按提示添加你自己的云盘即可，如果你同时拥有多个阿里云盘（或115云盘、天翼云盘）账号，也是支持同时挂载的，你自行将云盘重命名以便于识别就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e4c5be5377c78a293ac74aa3667cc15/" rel="bookmark">
			matlab图像的放缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在做图像有关的神经网络实验时，为了满足神经网络对图像尺寸的要求，经常需要将现有的图像进行放缩，即放大和缩小，于是查阅了一下，发现matlab有个专门的图像放缩函数：imresize()，很方便。
调用格式：
B = imresize(A,m)
B = imresize(A,m,method)
B = imresize(A,[mrows ncols],method)
B = imresize(A,m)，表示把原始图像A放大(m&gt;0)或缩小(m&lt;0)m倍，图像的宽和高同时放大和缩小。
B = imresize(A,m,method)，A，m的意义和上面一样，method指的值放缩图像的插值方法，有三种方法，即，'nearest'（默认值）最近邻插值，'bilinear'双线性插值，'bicubic'双三次插值，
B = imresize(A,[mrows ncols],method)，表示将原始图像A放缩到[mrows,ncols]的范围。method的意义与上面相同。
例如：B = imresize(A,2)，将原始图像的宽和高放大1倍。
B = imresize(A,[128 128])，将原始图像A缩放为128*128的大小。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bac5fb1c6d488c49df9b7cfc89ac37c1/" rel="bookmark">
			43期《深入浅出Pytorch》课程 - Task01:PyTorch的安装和基础知识&#43;前置知识打卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Task01 1、Pytorch安装2、基础知识2.1 张量(Tensor)2.2 自动求导2.3 梯度2.4 并行计算 3、前置知识打卡 1、Pytorch安装 由于之前使用过Pytorch，所以说不需要再重新下载，直接开始后续的基础知识
2、基础知识 由于之前学习过numpy系列，所以说对于Pytorch的理解会轻松很多。
2.1 张量(Tensor) ①创建tensor
import torch x = torch.rand(4, 3) print(x) 和numpy差不多，随机生成4X3的矩阵
②全0矩阵
x = torch.zeros(4, 3, dtype=torch.long) print(x) 和numpy里面的zeros也是一样的
由于之前系统学习过numpy并且参加过一些比赛，于是不在此赘述关于张量部分的知识，和numpy的基础很像，换个包名字就行(具体关于numpy的可以参考此链接https://blog.csdn.net/weixin_42198265/category_11063560.html?spm=1001.2014.3001.5482)
2.2 自动求导 在pytorch中，所有神经网络的核心是 autograd 包
①.backward()
torch.Tensor 是这个包的核心类。如果设置它的属性 .requires_grad 为 True，那么它将会追踪对于该张量的所有操作。
-当完成计算后可以通过调用 .backward()，来自动计算所有的梯度。这个张量的所有梯度将会自动累加到.grad属性。 注意：在 y.backward() 时，如果 y 是标量，则不需要为 backward() 传入任何参数；否则，需要传入一个与 y 同形的Tensor
②Function
Tensor 和 Function 互相连接生成了一个无环图 (acyclic graph)，它编码了完整的计算历史。
每个张量都有一个.grad_fn属性，该属性引用了创建 Tensor 自身的Function(除非这个张量是用户手动创建的，即这个张量的grad_fn是 None )。 from __future__ import print_function import torch # 手动创建张量-&gt;grad_fn返回结果是None x = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bac5fb1c6d488c49df9b7cfc89ac37c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a3862577a5b1c11a823a0765b3d085f/" rel="bookmark">
			uniapp生成推送证书和推送打包证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推送打包证书：用于给有推送能力的app打包
推送配置证书：用于配置unipush后台
先生成推送打包证书（用这里的profile和打包证书打包）： 1. 生成Identifiers
a. Bundle ID选择Explicit，唯一值
b. Capabilities选择push notifications
c. 其他同生成普通打包证书流程
2 生成打包证书certificates
a. 同生成普通打包证书，用以前生成的打包证书就不需要这一步
3. 生成打包profile文件
a. 绑定一个打包证书
b. 绑定之前生成的app id
后生成推送配置证书certificates（不需要其他步骤，生成直接配置后台）： 1. Services选择Apple Push Notification service SSL (Sandbox &amp; Production)
2. 绑定之前生成的app id(与上面是同一个)
打包时容易出现的问题：
1. profile和证书不匹配：p12用错了推送证书，应该用打包证书。
2. profile没有推送服务：绑定的id没有选push能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89c2174f055766bd703a8ecfb7bcff8c/" rel="bookmark">
			工作中常用的Lambda表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大家好，我是田螺。
日常开发中，我们很多时候需要用到Java 8的Lambda表达式，它允许把函数作为一个方法的参数，让我们的代码更优雅、更简洁。所以整理了一波工作中，我常用的，有哪些Lambda表达式。看完一定会有帮助的。
1. list转map 工作中，我们经常遇到list转map的案例。Collectors.toMap就可以把一个list数组转成一个Map。代码如下：
public class TestLambda { public static void main(String[] args) { List&lt;UserInfo&gt; userInfoList = new ArrayList&lt;&gt;(); userInfoList.add(new UserInfo(1L, "捡田螺的小男孩", 18)); userInfoList.add(new UserInfo(2L, "程序员田螺", 27)); userInfoList.add(new UserInfo(2L, "捡瓶子的小男孩", 26)); /** * list 转 map * 使用Collectors.toMap的时候，如果有可以重复会报错，所以需要加(k1, k2) -&gt; k1 * (k1, k2) -&gt; k1 表示，如果有重复的key,则保留第一个，舍弃第二个 */ Map&lt;Long, UserInfo&gt; userInfoMap = userInfoList.stream().collect(Collectors.toMap(UserInfo::getUserId, userInfo -&gt; userInfo, (k1, k2) -&gt; k1)); userInfoMap.values().forEach(a-&gt;System.out.println(a.getUserName())); } } //运行结果 捡田螺的小男孩 程序员田螺 类似的，还有Collectors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89c2174f055766bd703a8ecfb7bcff8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f34045bf82be651b68bf99c1cfc78b6a/" rel="bookmark">
			SpringBoot配置文件中spring.profiles.active配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot配置文件中spring.profiles.active配置详解 1、多环境配置 我们在开发Spring Boot应用时，通常同一套程序会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要频繁修改配置文件的话，那必将是个非常繁琐且容易发生错误的事。
对于多环境的配置，各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外，或者说更加简单。
在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式，其中{profile}对应你的环境标识，比如：
application.properties：默认配置
application-dev.properties：开发环境
application-test.properties：测试环境
application-prod.properties：生产环境
至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。
如：spring.profiles.active=test就会加载application-test.properties配置文件内容
下面，以不同环境配置不同的服务端口为例，进行样例实验。
针对各环境新建不同的配置文件application-dev.properties、application-test.properties、application-prod.properties 在这三个文件均都设置不同的server.port属性，如：dev环境设置为8080，test环境设置为9090，prod环境设置为80、application.properties中设置spring.profiles.active=dev，就是说默认以dev环境设置。
如：spring.profiles.active=hello-world,sender,dev 有三个参数，其中 dev 正好匹配下面配置中的application-dev.properties 配置文件，所以app启动时，项目会先从application-dev.properties加载配置，再从application.properties配置文件加载配置，如果有重复的配置，则会以application-dev.properties的配置为准。
补充：如果是application.yml,application.properties配置文件同时存在，会以application.properties配置文件为准，因为后加载的配置文件中重复的配置项会覆盖先加载的配置项。两者中如果用spring.profiles.active指定其他配置文件，最终重复项以spring.profiles.active指定的配置文件为准。
2.通过@Profile注解匹配active参数，动态加载内部配置 @Profile可接受一个或者多个参数，例如：
@Profile({"tut1","hello-world"}) @Configuration public class Tut1Config{ @Bean public Queue hello(){ return new Queue("hello"); } @Profile("receiver") @Bean public Tut1Receiver receiver(){ return new Tut1Receiver(); } @Profile("sender") @Bean public Tut1Sender sender(){ return new Tut1Sender(); }	当 spring.profiles.active=hello-world,sender 时，该配置类生效，且第一个@Bean和第三个@Bean生效
如果spring.profiles.active=hello-world ，则该配置文件生效，第一个@Bean生效
如果spring.profiles.active=sender ，该配置文件未生效，所以下面的@Bean都不会生效
如此，当我们的项目需要运行在不同环境，特异化配置又比较多，该注解的优势是相当明显的！
参考文章链接 1、https://juejin.cn/post/6847902221720518664
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c70e843c8b14f7fb1280a13ed2007fd/" rel="bookmark">
			使用Mybatis实现基本crud.md
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、向数据库插入数据 (新增) 1.1、在UserDAO中添加addUser方法 1.2、在UserMapp.xml中匹配addUser方法，并维护sql语句 &lt;insert id="addUser"&gt; insert into t_user (id,user_name,passwd) values (#{id},#{name},#{passwd}) &lt;/insert&gt; 1.3、在controller中测试 @RequestMapping("/t8") public int t8(){ int count = dao.addUser(new User(1001L,"mike","321")); return count; } 测试结果
二、从数据库查询数据(登录) 2.1、在UserDAO中添加login方法 2.2、在UserMapp.xml中匹配login方法，并维护sql语句 &lt;select id="login" resultType="demo.entity.User"&gt; select * from t_user where user_name=#{userName} and passwd=#{passwd} &lt;/select&gt; 2.3、在controller中测试 @RequestMapping("/login")//登录 public String login(String userName,String passwd){ User u = dao.login(userName,passwd); if(u != null){ return "登录成功"; }else{ return "登录失败"; } } 测试结果
三、根据id修改数据(改) 3.1、在UserDAO中添加updateUser方法 3.2、在UserMapp.xml中匹配updateUser方\法，并维护sql语句 &lt;update id="updateUser"&gt; update t_user set user_name=#{name},passwd=#{passwd} where id=#{id} &lt;/update&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c70e843c8b14f7fb1280a13ed2007fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6790d5df3841567e3d497617a30caa/" rel="bookmark">
			论文笔记---Topological acoustics
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		粗字是注释或者自己加的理解、总结 The Chern number is defined through the integration of the Berry curvature in the Brillouin zone (BZ) as
通过对布里渊区(BZ)的贝里曲率的积分来定义Chern数为
is the non- vanishing component of the Berry curvature, with the periodic part of the Bloch wavefunction of the nth band.The Chern number is necessarily integer- valued, counting the net number of chiral edge modes that enter and leave a given band.
上式是Berry曲率的非消失分量，ku ()n为第n波段布洛赫波函数的周期部分。Chern数必须是整数值，计算进入和离开一个给定波段的手性边缘模式的净数量。
手性边缘态：
物理上外界磁场引起的时间反演对称破缺阻断了边界电子背散射路径，使其只能单向无耗散流动且方向取决于磁场取向，形成手性边缘态。边缘态手性模型近期还直接促成了对拓扑绝缘体的发现。由于此类材料可实现零磁场下边缘态电子的无耗散流动而具有重大应用价值，因此成为当前凝聚态物理研究的热点。迄今，边缘态手性在量子体系电子输运过程中扮演的重要角色已广为人知。
The chiral edge modes, which are responsible for the quantized Hall conductance, propagate along the edges unidirectionally, and are robust against gap- preserving disorder and defects.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a6790d5df3841567e3d497617a30caa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7edcf81e24e487b34b6e182a706fcc77/" rel="bookmark">
			特征码、特征码的概念、特征码的作用、常见的特征码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是特征码？ 特征码（attribute code）：是用来判断某段数据属于哪个计算机字段。
2. 特征码有什么作用？ 在扫描病毒时，防毒软件将目标文件通过模式匹配算法与病毒库中的特征码进行比对，以确定是否染病毒.
3. 为什么要定位特征码？ 因为伴随程序重新编译，基址偏移量等会发生改变，导致之前查找到的内存地址的偏移量失效 ，我们可以根据定位特征码，定位所有需要的基址。
4. 常见文件格式在系统中的特征码 JPEG： 0xFFD8FF
PNG： 0x89504E47
GIF： 0x47494638
XML： 0x3C3F786D6C
HTML： 0x68746D6C3E
CAD： 0x41433130
MS Office： 0xD0CF11E0A1B11AE1
ZIP Archive： 0x504B0304
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b537f2b221cade47961488492e2b90a6/" rel="bookmark">
			[附源码]java毕业设计基于的高校学生考勤管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
SSM + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
3.1需求分析 高校学生考勤管理系统的作用，是为提高管理学生考勤工作人员的效率，协助他们对高校学生考勤信息进行统一管理，为管理提供信息储存和查询搜索系统。一个良好的高校学生考勤管理系统可以实现对高校学生考勤信息的精细化管理：对考勤信息管理流程的全过程进行电子化操作，其主要作用是管理和控制高校学生考勤所有的信息，分析库存数据，使工作人员对高校学生考勤进行监管，根据系统所提供的相应信息，采取适当的措施，及时补救管理中的漏洞，提高高校学生考勤的工作效率，使得考勤信息管理变的更加系统和规范。
3.2系统可行性分析 可行性分析是在进行初步调查之后，对系统开发的必要性和可行性的研究。针对本系统，主要从技术可行性，经济可行性，社会可行性，法律可行性等方面来论证，具体分析如下：
技术可行性：当今社会人类的科技水平的不断发展，软件开发产业也在不断的壮大。目前，市面上流行的开发产品，已经能过满足不同行业的各种需要。
经济可行性：在当今社会，计算机的性能已经有了很大的提升，价格也不断的下降。因此，并不需要对此程序投入过高的成本。并且，在程序投入使用之后，可以为管理人员带来极大的便捷，大大提高工作效率，减少人力浪费，避免许多不必要的工作和开支。
社会可行性：管理者效率的增加，以及在管理过程中出现错误的可能性的大大减少，也是为了更好的发展铺平道路服务大众。这理应得到各界的一致认可。
法律可行性：本系统绝不违反任何相关的法律法规。
3.3系统流程分析 3.3.1操作流程 系统登录流程图，如图所示：
图3-1登录流程图
3.3.2添加信息流程 添加信息流程图，如图所示：
图3-2添加信息流程图
3.3.3删除信息流程 删除信息流程图，如图所示：
图3-3删除信息流程图
4系统总体设计 4.1系统结构 高校学生考勤管理系统,它是一个由人、电脑及其他组件构成的，一种能够收集、存储、加工、传送信息的系统。该系统可以帮助决策者找出当前急需解决的问题，然后将信息快速的反馈，使管理人员能够以最快的时间知道目前的现状，进行更进一步的计划。
当前MIS系统结构目前存在两种较为流行的结构:C/S和B/S两种。
C/S结构的系统：C/S结构就是客户机服务器结构，它可以法派任务到Client端和Server端来进行，充分利用两端硬件环境的优势，来降低系统的通讯的花费。客户端主要作用是处理人机交互，执行客户端应用程序，收集数据以及向服务器发送任务请求。服务器基本作用是执行后台程序，它主要对客户机的请求申请进行反馈，除此之外，它的作用还包括：数据库存储系统的共享管理、通讯管理、文件管理等等。
B/S结构的系统：这种网络结构简化了客户端，并把系统功能实现的中心集中到服务器上，在这种模式中，只需要一个浏览器就可以了。这种结构将很多的工作交于WEB服务器，只通过浏览器请求WEB服务，随后根据请求返回信息。
通常在只在企业网内部使用，采用C/S。而使用不仅限于内网的情况下使用B/S。考虑到本管理系统的一系列需求，所以，该系统开发使用B/S结构开发。其主要功能结构如下图所示。
图4-1 系统总体功能结构图
4.2数据库设计 数据库设计是指为系统提供最优化的数据库模式，使得应用程序能够有效的存储数据，满足用户的各类需求。
4.2.1 数据库概念结构设计 概念结构设计是根据用户需求形成的。用最常的E-R方法描述数据模型进行数据库的概念设计，首先设计局部的E-R模式，最后各局部ER模式综合成一个全局模式。然后再把概念模式转换成逻辑模式。将概念设计从设计过程中独立开来，设计复杂程度降低，不受特定DBMS的限制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b537f2b221cade47961488492e2b90a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/429a621c6d6811e326c8ab40ab70685c/" rel="bookmark">
			基于FPGA的2PSK调制解调仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前介绍了2ASK的解调方式是非相干解调。下面介绍相干解调，但用2PSK来进一步说明。
相干解调的思路很简单，就是把调制信号乘以载波，再通过低通滤波器，经判决脉冲输出。和之前一样，需要确认几个参数。
本示例时钟为50M，基带信号1M，载波4M，在仿真时解调时用的载波是和调制用的一样。为了恢复原来信号，判决脉冲也为1M。至于判决门限，由于相乘之后，正负都有，且正的部分对应1，负的部分对应0，所以自然地，判决门限应该为0。但由于负数表示为最高位是1，我们不能简单通过判断大于0来表示，因为所有的数据都大于0。因此我们只用判断最高位，若最高为为0，则说明是正数，则判为1，若最高位为1，则说明是负数，判为0。
先给出2PSK的调制，还是利用2选1开关。
module choose( input [7:0]data_in, input sel, output [7:0]data_out ); reg[7:0]daout; always @(sel) begin if(sel) daout &lt;= data_in; else daout &lt;= ~data_in; end assign data_out = daout; endmodule 2PSK解调
module demod_psk( input clk, input clk_in, input [7:0]sin, input [7:0]data_in, output [13:0]fir_dout, output bit_data, output bit_sync ); //例化乘法器模块 wire[15:0]lpm_out; lpm_sin lpm_sin_inst( .dataa(data_in), .datab(sin), .result(lpm_out) ); //例化FIR模块 wire source_valid; wire [1:0] source_error; wire [27:0]source_out; My_fir U0( .clk (clk), .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/429a621c6d6811e326c8ab40ab70685c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/593daa8b9e5c88c898c164c846f22ef0/" rel="bookmark">
			谷歌浏览器如何设置internet选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		歌浏览器设置internet选项具体操作方法如下：
1、首先进入谷歌浏览器主页，点击浏览器工具栏上的Chrome菜单（三横那个按钮）
2、点击菜单，然后打开设置。
3、把网页拉到最下面，找到底部的“显示高级设置...”
4、在增加的高级设置的页面中，找到“网络”下面的内容，点击“更改代理服务器设置”
5、internet属性的修改页面就弹出来了，我们就可以修改其中的内容了。
二、新版本谷歌浏览器设置internet选项
1、打开到谷歌浏览器，进入设置，找到系统选项
2、进入系统选项，点击打开您的计算机代理设置
三、提示：
如果在浏览器找不到internet 属性，可以按下“Win+R”组合键打开运行，在框中输入：inetcpl.cpl 点击确定即可打开“internet 属性”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4d0f076e05d97146fb874a1eaa7c83/" rel="bookmark">
			ACL的原理及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一 技术背景：需要一个工具，实现流量过滤二 ACL应用三 ACL组成四 规则编号（Rule ID）：Rule ID分配规则： 六 通配符（Wildcard七 ACL的分类与标识八实验8.1.配置客户机8.2配置路由8.3 测试 一 技术背景：需要一个工具，实现流量过滤 某公司为保证财务数据安全，进制研发部门访问财务服务器，但总裁办公室不受限制
ACL概述
访问控制值列表（ACL）
通过ACL可以实现对网络中报文流的精确识别和控制，达到控制网络访问行为、防止网络攻击和提高网络带宽利用率的目的，从而切实保障网络环境的安全性和网络服务质量的可靠性。
应用于路由器接口的指令列表，用于指定哪些数据包可以接收转发，哪些数据包需要拒绝。
ACL是一系列permit或deny语句组成的、有序规则的列表。
ACL是一个匹配工具，能够对报文进行匹配和区分。
• permit（允许）：数据包过滤，允许那些流量通过
• deny （拒绝）：数据包过滤，拒绝那些流量通过
二 ACL应用 • 匹配IP流量
• 在Traffic-filter中被调用
• 在NAT（Network Address Translation）中被调用
• 在路由策略中被调用
• 在防火墙的策略部署中被调用
• 在QoS中被调用
• 其他……
三 ACL组成 ACL由若干条permit或deny语句组成。每条语句就是该ACL的一条规则，每条语句中的permit或deny就是与这条规则相对应的处理动作。原本华为和思科的ACL都是默认拒绝一切，但是，华为模拟器默认是允许一切。
ACL的组成：
• ACL编号：在网络设备上配置ACL时，每个ACL都需要分配一个编号，称为ACL编号，用来标识ACL。
• 规则：一个ACL通常由若干条“permit/deny”语句组成，每条语句就是该ACL的一条规则。
• 规则编号：每条规则都有一个相应的编号，称为规则编号，用来标识ACL规则。可以自定义，也可以系统自动分配。ACL规则的编号范围是0～4294967294，所有规则均按照规则编号从小到大进行排序。
• 动作：每条规则中的permit或deny，就是与这条规则相对应的处理动作。permit指“允许”，deny指“拒绝”，但是ACL一般是结合其他技术使用，不同的场景，处理动作的含义也有所不同。
比如：ACL如果与流量过滤技术结合使用（即流量过滤中调用ACL），permit就是“允许通行”的意思，deny就是“拒绝通行”的意思。
• 匹配项：ACL定义了极其丰富的匹配项。例子中体现的源地址，ACL还支持很多其他规则匹配项。
四 规则编号（Rule ID）： 规则编号（Rule ID）：
一个ACL中的每一条规则都有一个相应的编号，称为规则编号，用来标识ACL规则。可以自定义，也可以系统自动分配。
步长（Step）:
步长是系统自动为ACL规则分配编号时，每个相邻规则编号之间的差值，这个差值称为“步长”。缺省值/缺省步长为5。所以规则编号就是5/10/15…以此类推。
步长的作用是为了方便后续在旧规则之间，插入新的规则。
Rule ID分配规则： 系统为ACL中首条未手工指定编号的规则分配编号时，使用步长值（例如步长=5，首条规则编号为5）作为该规则的起始编号；为后续规则分配编号时，则使用大于当前ACL内最大规则编号且是步长整数倍的最小整数作为规则编号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d4d0f076e05d97146fb874a1eaa7c83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8bae77fdc6b6a4d0bc76092297012bb/" rel="bookmark">
			模型压缩总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.模型复杂度衡量 model sizeRuntime Memory Number of computing operations model size 就是模型的大小，我们一般使用参数量parameter来衡量，注意，它的单位是个。但是由于很多模型参数量太大，所以一般取一个更方便的单位：兆(M) 来衡量（M即为million，为10的6次方）。比如ResNet-152的参数量可以达到60 million = 0.00006M。
有些时候，model size在实际计算时除了包含参数量以外，还包括网络架构信息和优化器信息等。比如存储一个一般的CNN模型(ImageNet训练)需要大于300MB。
这里你可能会有疑问：刚才的单位是M，怎么这里出来了个MB？是不是写错了？
肯定没有，我们需要注意这里的M和MB的换算关系：
比如说我有一个模型参数量是1M，在一般的深度学习框架中(比如说PyTorch)，一般是32位存储。32位存储的意思就是1个参数用32个bit来存储。那么这个拥有1M参数量的模型所需要的存储空间的大小即为：1M * 32 bit = 32Mb = 4MB。因为1 Byte = 8 bit。
所以读到这里你应该明白说一个模型的model size，用M和MB其实是一样的意思。
那你可能还会有疑问：是不是一定要用32位存储？
这个问题很好，现在的quantization技术就是减少参数量所占的位数：比如我用8位存储，那么：
所需要的存储空间的大小即为：1M * 8 bit = 8Mb = 1MB。
更有甚者使用二值神经网络进一步减小参数量所占的位数(权值被限制为{-1, 1}或{-1, 0, 1})，后文有论文的链接，有空再专门介绍这个方法吧。下面简单介绍下参数量的计算方法：
卷积层参数量的计算方法：
Run time Memory 就是模型实际运行时所占的内存。注意这个指标与只存储模型参数所占的存储空间的大小是不一样的，这个指标更大。这对于GPU来讲不算是问题，但是对于硬件能力极为有限的端侧设备来说就显得无法承受了。它的单位是兆字节 (MB)。
Number of computing operations FLOPS MACs 就是模型的计算量，有FLOPs和MACs两种衡量的方式、简而言之，前者指的是乘加的数量，而后者指运算量。比如ResNet-152在前向传播一张256 * 256的图片的运算量可以达到20 GFLOPs。下面简单介绍下模型计算量的计算方法：
第1种：FLOPs：
卷积层FLOPs的计算方法：
只需在parameters的基础上再乘以feature map的大小即可，即对于某个卷积层，它的FLOPs数量为：
全连接层FLOPs的计算方法：
对于全连接层，由于不存在权值共享，它的FLOPs数目即是该层参数数目：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8bae77fdc6b6a4d0bc76092297012bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cbecc7409690f1e8765dd6994fdae3/" rel="bookmark">
			目前主流的跨平台技术、框架有那些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前主流的跨平台技术、框架有那些？
uniapp 、React Nitive、API Cloud、Flutter; MAUI 、Taro
这里知乎有一篇文章
全网最全 Flutter 与 React Native 深入对比分析 - 知乎
感谢网友 Lydia500 的补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8ad6906ec306790619088a98aecd427/" rel="bookmark">
			【javaweb】javabean-四则运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oprator.java package lyy; public class oprator { private float first; private float second; private String op; private float result; public float getFirst() { return first; } public void setFirst(float first) { this.first = first; } public float getSecond() { return second; } public void setSecond(float second) { this.second = second; } public String getOp() { return op; } public void setOp(String op) { this.op = op; } public float getResult() { if (op.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8ad6906ec306790619088a98aecd427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8884e94152ad1ad574e5c0066ede314/" rel="bookmark">
			[云原生k8s] k8s资源限制以及探针检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、资源限制 1.1、资源限制的使用 当定义Pod时可以选择性地为每个容器设定所需要的资源数量。最常见的可设定资源是CPU和内存大小，以及其他类型的资源。
1.2、request资源（请求）和limit资源（约束） 1.当为Pod中的指定了request资源时，调度器就使用该信息来决定将Pod调度到来哪一个节点中。当还未容器指定了limit资源时，kubelet就回确保运行的容器会不会使用超过所设置的limit资源量
2.如果Pod所在的节点具有足够的可用资源，容器可用使用超过所设置的request资源量。不过，容器不可以使用超过所设置的limit资源量。
3.如果给容器设置了内存的limit值，但未设置内存的request值，Kubernetes会自动为其设置于内存limit相匹配的request值。类似的，如果给容器设置了CPU的limit值但未设置CPU的request值，则Kubernetes自动为其设置CPU的request值，并使之与CPU的limit值匹配。
1.3、Pod和容器的资源请求和限制 定义创建容器时预分配的CPU资源 spec.containers[].resources.requests.cpu 定义创建容器时预分配的内存资源 spec.containers[].resources.requests.memory 定义创建容器时预分配的巨页资源 spec.containers[].resources.requests.hugepages-&lt;size&gt; 定义cpu的资源上限 spec.containers[].resources.limits.cpu 定义内存的资源上限 spec.containers[].resources.limits.memory 定义巨页的资源上限 spec.containers[].resources.limits.hugepages-&lt;size&gt; 1.4、官方文档示例 apiVersion: v1
kind: Pod
metadata:
name: frontend
spec:
containers:
- name: app
image: images.my-company.example/app:v4
env:
- name: MYSQL_ROOT_PASSWORD
value: "password"
resources:
requests:
memory: "64Mi"
cpu: "250m"
limits:
memory: "128Mi"
cpu: "500m"
- name: log-aggregator
image: images.my-company.example/log-aggregator:v6
resources:
requests:
memory: "64Mi"
cpu: "250m"
limits:
memory: "128Mi"
cpu: "500m"
此例子中Pod有两个Container。每个Container的请求为0.25cpu和64MiB（226字节）内存，每个容器的资源约束为0.5cpu和128MiB内存。你可以认为该Pod的资源请求为0.5cpu和128MiB内存，资源限制为1cpu和256MiB内存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8884e94152ad1ad574e5c0066ede314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea4df0e4786974844c09789e7b0525b/" rel="bookmark">
			C语言飞机大战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前言二、从设计初始菜单界面开始三、游戏操作指南——guide函数四、游戏的主体gamebody()①简化通用的游戏框架②头文件一览③清屏函数的实现④光标隐藏函数⑤Initgame函数⑥show函数的实现⑦与用户输入有关的更新- updateWithinput⑧与用户输入无关的更新-updateWithoutinput⑨组合而成的gamebody函数⑩不足与展望 一、前言 [设计难度 : ★☆☆☆☆
[参考书籍：《C语言课程设计与游戏开发实践教程》
[主要涉及知识：函数封装 + 循环判断语句
[程序运行效果图：
[主要的游戏功能：
通过按键’w’,‘s’,‘a’,'d’分别实现飞机的上下左右移动按空格键发射子弹按ESC实现游戏暂停按q键返回菜单界面实现子弹和敌机位置的自动更新敌机的生成速度和下落速度随分数的增加而变快实时打印得分和生命值。生命值为0时游戏结束 以下为飞机游戏全部的代码，大家可以直接拷贝运行：
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;windows.h&gt; #include &lt;conio.h&gt; #include &lt;time.h&gt; #define height 25 //设置游戏边界 #define width 50 #define enemy_max 5 enum Option	//枚举增加代码可读性 { EXIT, PLAY, GUIDE, }; enum Condition //表示游戏幕布上的情况 { backspace, enemy, bullet, }; int canvas[height][width]; //游戏幕布存储对应的信息 int score; int x, y;	//飞机头部坐标 int Std_Speed;	//敌机标准下落速度 int Std_Time;	//敌机生成的标准速度 int HP; //玩家生命值 int enemy_num; int times; void gotoxy(int x, int y)	//清屏函数 { HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); COORD pos; pos.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fea4df0e4786974844c09789e7b0525b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4378eb84df59a99b02f1d58a42c25325/" rel="bookmark">
			LATEX模板总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写本篇文章的目的在于记录一下自己学习的亚太杯建模LATEX论文排版过程，模板是从一位西交前辈的个人网站得来的首页 · Heishan Press，这位大佬的博客当中有很多有意思的内容，大家可以去研读一下。
目录
一、公式部分
二、 文档开头的宏定义
三、文章的各个部分
1、摘要
2、目录
3、正文部分
四、代码
一、公式部分 建模最重要的就是公式的编写了，我们可以利用在线的可视化LATEX公式编辑器大大降低难度，网址如下在线LaTeX公式编辑器-编辑器。它甚至贴心的提供了图片识别功能。
在这里我务必要推荐一下VSCODE的LATEX编辑器，鼠标悬停在代码上方就可以查看效果，值得推荐，至于如何配置VSCODE可以看我的另一篇文章。
这种是插入文段的公式，通常我们需要\begin{equation}和\end{equation}搭配使用，代码如下
\begin{equation}\label{eq:heat} \frac{\partial u}{\partial t} - a^2 \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2} \right) = f(x, y, z, t) \end{equation} 如果是嵌入在文本中的公式，我们可以用——$你需要展现的公式代码$，这种方式。
\begin{itemize} \item $\mu$ is the mean of the distribution \item $\sigma$ is the standard deviation \end{itemize} 行间公式的话，可以采用\[ 你需要展现的公式代码 \]这样的格式
%表示行间的公式 \[G^\mu\nu+G^{\mu\nu}\] %张量的上下标写法 \[F^{ab}_{cd}+F^{ab} {}_{cd}\] %求和和积分公式 \[ \int_a^b \sum_{i=0}^\infty \lim_{n\to\infty}\] %求和表达式的上下标问题,在\sum后面加入\nolimits \[ \int_a^b \sum\nolimits_{i=0}^\infty \lim_{n\to\infty}\] %根号的表达 \[ \sqrt{1+2}+\sqrt[\frac{1}{x}]{\alpha}\] 二、 文档开头的宏定义 话不多说，给大家看看格式效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4378eb84df59a99b02f1d58a42c25325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8786a0256c38fc73a6e4251ace9acd8/" rel="bookmark">
			Linux安装cuda10.1,cudnn7.6.4 (深度学习) MindSporeGPU计算框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CUDA(ComputeUnified Device Architecture)，是显卡厂商NVIDIA推出的运算平台。 CUDA是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。当我们在进行深度学习任务时，我们有时需要使用GPU版本的框架，比如tensorflow-gpu或者mindspore-gpu版本就需要安装CUDA和CUDNN进行GPU加速支持
1.下载cuda10.1
CUDA Toolkit 10.1官方下载地址
2.下载cudnn7.6.4
cuDNN官方下载地址
注意要下载与cuda版本对应的cudnn工具
3.安装cuda10.1
sudo bash cuda_10.1.105_4188.39_linux.run 看到如下界面，在控制台输入accept进行下一步安装
然后再下述界面只需要勾选CUDA Toolkit 10.1即可，第一个为显卡驱动，如果当前驱动版本较低需要勾选安装
4.添加软链接
sudo cp ./include/* /usr/localcuda/include sudo cp ./lib64/* /usr/local/cuda/lib64 5.配置环境变量
下图是已经安装好的cuda路径
vim ~/.bashrc #cuda 配置cuda的安装路径，默认是在/usr/local export CUDA_HOME=/usr/local/cuda-10.1 export LD_LIBRARY_PATH=${CUDA_HOME}/lib64 export PATH=${CUDA_HOME}/bin:${PATH} source ~/.bashrc 6.验证是否安装成功
nvcc -V 如果出现该提示，说明安装成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62735e418f8936473a11e38acb169467/" rel="bookmark">
			如何PCB出自己的ESP32开发板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习完PCB之后，难免想自己进行打板测试。
那么，我们今天讲一讲如何用嘉立创设计自己的ESP32开发板、
要找到属于自己的专属芯片，我们启动某淘，搜索ESP32贴片
我们随便点进去一个
找到他专属的引脚顺序。然后我们打开eda软件
根据你要买的贴片绘制你的图，外围的这些不用看先（我这是画完之后截的图，外围电路一会介绍）
这样一一检查一下，看是否自己的贴片引脚和顺序都正确。
然后 贴片放上去了，我们需要考虑如何烧录芯片的问题，网上主流的以及大家买到的一般都是cp2102的驱动，对于玩stm32习惯的人，驱动一直是ch340，并且cp2102怎么说，感觉不划算。
最后，我选了CH340C的芯片，因为它内部自带晶振电路，比较简单（怎么简单，怎么省事怎么来）
所以，我们再次启动淘宝，搜索CH340C的贴片
一看，原来是SOP-16的封装，那我没用过ch340c，之前都是用的ch340g等，我不会画怎么办，那我们搜索数据手册
找到对应的CH340C即可 我们对应画上我们的原理图，这样我们就有了烧录的协议。
那么，接下来就是如何供电的问题了
stm32常用的是5V供电，但是ESP32供电方式是3.3V供电，那么知道USB供电时5V，我们需要降压芯片，常用的就是AMS117-3.3芯片，我们再次启动淘宝
我们发现他是SOT-223的封装，那这个降压电路咋画，接着看数据手册
我们看第一个就好，按着样子画，
然后就是USB供电了，还是从淘宝找的micro_usb的贴片！！！！需要注意的是它
种类很多，有带立柱的，还有这种固定是直角的，根据你选型的时候来选择购买。
我们画出他的原理图。
至此，esp32大体框架出来了，是逻辑分析阶段
一：esp32贴片本身需要注意两个地方，一个是EN和GPIO0引脚，网上关于这两个引脚图画的是五花八门的，其原理只有一个，就是怎么样使esp32进入下载模式，说白了就是GPIO0为低电平，EN发生跳变就能烧录进去（当然，这么说太不严谨了，但是，能烧录进去）。我们看esp32的数据手册上也是这么描述的。至于网上的自动下载电路，倒是没啥必要搞。
当然，关于这个EN电路，大家按着官方数据手册画，我这个左边没地了，就把他用一个网络标号给分开了（我的也是按着官方数据手册画的）
还有一个就是滤波电容，这些，大家参照数据手册画就行。
二：就是ch340c如何与esp32交互
其实也很简单，对应的线连接就好，就是注意ch340c上的TXD和RXD要对应esp32上的RXD和TXD，别搞反了。
这样，esp32的最小系统就出来了，我们可以加个灯试一试
需要注意的是：画板子的时候不要去网上找现成的电路，这样不仅扰乱自己的思路，还得不到成长，一定要从官方数据手册出发，找到最经典的电路，然后以此扩充。没有思路不要紧，数据手册可以解决很多问题。
还有一些esp32烧录和焊接过程遇到的问题，我在之后会更新出来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a18793f9e4a9d5cb5de282c3a7272220/" rel="bookmark">
			前端的导入导出：「CommonJS」「ES Module」模块化规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 模块化开发有助于我们将代码进行拆分，便于开发和维护，但如果不清楚模块化规范，就会在开发时不知道该用 require 还是 import，导出时该用 export 还是 module.exports，所以我们必须搞清除它们的区别和事情的来龙去脉。
本篇主要内容是 CommonJS 和 ES Module 规范。其它还有 AMD、CMD、UMD规范，感兴趣的小伙伴可以自行了解一下。
什么是前端模块化 随着前端项目越做越大，功能越来越多，我们不能把所有代码写在一个 js 中，而是把代码按照不同的功能进行划分，但是代码越来越多，代码之间的引用嵌套越来越深，我们又不得不花费大量时间去管理和维护，如何提高代码的管理效率？就是通过模块化。
模块化不但是一种代码组织形式，也是一种思想，我们根据代码的不同功能，来划分不同模块，目的是方便管理代码，从而提升开发效率。
模块化的演进过程 模块化规范不是一夜之间突然出现，而是像时代一样，有着演进过程：
石器时代：我们通过 script 标签引入 js 文件，并且约定，一个文件代表一个模块，这种方式很好理解，但存在很多问题
1. 缺少私有空间，也就是模块内部成员可以在外部被修改
2. 所有模块作用在全局，容易发生命名冲突，变量污染
3. 无法管理模块的依赖关系，如果引用顺序出错，程序将难以运行青铜器时代：使用命名空间模式，就是给每一个模块暴露出一个对象，把模块内的所有成员挂载到这个对象下，这就有点模块化内味儿了，但还是无法解决私有空间的问题，模块成员在外部依然可以被修改蒸汽机时代：使用 IIFE（立即调用函数表达式）提供私有作用域，当函数变成立即执行的函数表达式时，表达式中的变量不能从外部访问，也就是形成了闭包，然后再将对象暴露出去，挂载到全局 // 蒸汽机时代：使用 IIFE 提供私有作用域的方式 ;(function(){ // 通过闭包，避免私有成员被外部修改 var msg = 'hello world' function method(){ console.log(msg) } // 挂载到全局 window.module = { method:method } })() 通过 IIFE 我们解决了私有作用域的问题，却无法解决 script 标签引入的问题，当 index.html 中引入了十几个 script 标签，还要维护他们的引入顺序时，那是相当痛苦的。
开源时代，百家争鸣。百花齐放，JavaScript 社区孕育出了 CommonJS 规范。 回顾CommonJS和ES Module使用方式 先回顾下 CommonJS 和 ES Module 常用的方式，加深下印象：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a18793f9e4a9d5cb5de282c3a7272220/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec0360ffc8f3e75bcf00770a7e6e727/" rel="bookmark">
			牛客-Java计算个人所得税
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路： 1.新建三个employee对象。
2.通过有参构造的方式新建employee对象。
3.通过List集合的add方法，将employee对象放入集合中。
4.过遍历集合来对集合中元素进行操作，首先我们定义double类型的个人所得税变量以及应纳税额变量。
5.使用if，if else语句，对每个工资等级进行划分并按照表格中给出的计算方法进行计算。
6.因为逻辑在集合遍历中实现，所以在输出时应该首先获得当前集合中的employee对象，使用getName()方法得到当前对象的姓名属性。
import java.util.*; public class Main { public static void main(String[] args) { List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(); Employee e1 = new Employee("小明",2500); Employee e2 = new Employee("小军",8000); Employee e3 = new Employee("小红",100000); employees.add(e1) ; employees.add(e2) ; employees.add(e3) ; Iterator it = employees.iterator(); while(it.hasNext()){ Employee e4 = (Employee) it.next() ; double num = e4.getSalary() - 3500.00; double sax = 0.0 ; if(num &lt; 0 ){ }else if(num &lt;= 1500){ sax = num * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aec0360ffc8f3e75bcf00770a7e6e727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec5f93c5710d85b9a7d11593a3ac6611/" rel="bookmark">
			上传图片样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.btn-box { position: relative; } .file-ipt { position: absolute; left: 0; top: 0; opacity: 0; //将input设为透明 } .btn { width: 100px; height: 30px; background-color: skyblue; color: white; margin-right: 80px; border: none; border-radius: 10px; } .cover-img{ width: 100px; height: 100px; border-radius: 0.26rem; overflow: hidden; position: relative; margin-top: 10px; } .cover-img img { position: absolute; width: 100%; height: 100%; object-fit: cover; } html
&lt;button class="btn"&gt;上传图片&lt;/button&gt; &lt;input type="file" id="file" onchange="uploadImg(this)" accept="image/*" class="file-ipt"&gt; &lt;div style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec5f93c5710d85b9a7d11593a3ac6611/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da147680d469e142c7a6d78132fcc1db/" rel="bookmark">
			python从postgis获取数据写入本地（Postgre入门四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、准备数据库数据 2、python读取写入本地 from PIL import Image import psycopg2 as ps import os from io import BytesIO def getconn(): return ps.connect(database=database,user=user,password=password,host=host,port=port) # 查询表数据 def query(sql): conn= getconn() cursor = conn.cursor() cursor.execute(sql) # 返回所有数据 class_list = cursor.fetchall() cursor.close() conn.close() return class_list if __name__ == "__main__": tablename="img_test" sql = "select * from cataract;" # 1、从postgis中获取数据 datas=query(sql) # 2、数据写入本地 for data in datas: name = data[0] if os.path.exists(os.path.dirname(name))!=True: os.makedirs(os.path.dirname(name)) content = data[1] img = Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da147680d469e142c7a6d78132fcc1db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d402e367dfcc24d77cc600f01ceb14d0/" rel="bookmark">
			mac os 通过vs code连接远程服务器 （ssh方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论是winodws还是Mac os系统，通过vs code连接远程服务器都是很方便的。网上很多教程写的还需要配置密钥公钥，我实验下来发现不需要。
首先要保证你的主机可以连接到ssh远程服务器，使用vscode远程连接只是方便调试修改代码等。
操作方法：
打开vscode，找到左侧的扩展图标，搜索remote ssh插件，点击安装
安装好会有一个电脑图标，这个就是remote ssh的图标，点击可以看到ssh，然后点击+新建连接
点击+号要求输入ssh连接命令，就按这个格式输入即可 ssh 用户名@主机ip地址，然后回车即可
添加好后，可以看到左侧会出现连接地址
点击他连接，然后按照要求输入服务器该用户密码,并回车即可连接
当然windows也是这个步骤
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc17f2fca99b008b705a546fa053204/" rel="bookmark">
			MYCAT链接及集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 准备(windows版操作) JDK1.7以上
TOMCAT（8.5）
MYCAT（windows） server 1.6.7
mycat下载连接：The domain name Mycat.io is for sale （免安装）
配置mycat环境变量： MYCAT_HOME=安装路径
PATH = $MYCAT_HOME$\bin
2 修改mycat配置信息 2.1安装路径\conf 下 server.xml 配置mycat用户名及密码，以及mycat逻辑库名，权限（可忽略）等
&lt;user name="root" defaultAccount="true"&gt; &lt;!--mycat 连接密码--&gt; &lt;property name="password"&gt;123456&lt;/property&gt; &lt;!--mycat 逻辑库名 与配置文件相同--&gt; &lt;property name="schemas"&gt;DB2&lt;/property&gt; &lt;!--读取权限--&gt; &lt;!--&lt;property name="readOnly"&gt;false&lt;/property&gt;--&gt; &lt;/user&gt; 2.2 安装路径\conf 下 schema.xml
配置mycat与实际数据库的绑定
&lt;mycat:schema xmlns:mycat="http://io.mycat/"&gt; &lt;schema name="DB2" checkSQLschema="false" dataNode='dn1' sqlMaxLimit="100"&gt;&lt;/schema&gt; &lt;dataNode name="dn1" dataHost="localhost1" database="数据库名称" /&gt; &lt;dataHost name="localhost1" maxCon="1000" minCon="10" balance="0" writeType="0" dbType="mysql" dbDriver="native" switchType="1" slaveThreshold="100"&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecc17f2fca99b008b705a546fa053204/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad69a8b70a9cebed96bbabbfdf96f351/" rel="bookmark">
			打开eclipse后，出现BUG的错误提示，原因及说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ECLIPSE中的类似BUG的报错信息 场景：之前项目运行一切正常，临时有事关闭项目三天，在此打开此工作空间的项目，出现多个class文件报错
报错说明：未改动任何配置、jar包，以及项目内容，仅仅是重新打开项目。提示缺少括号，缺少某jar包,等错误，
解决办法：删除class文件 的报错行代码，然后撤销刚才的操作，保存，代码保存提示消失。
或者eclipse导航栏 Project - clean - 选择保错提示所在的项目 - clean
"奇怪的报错" 说明：-通过网络搜集-不确保准确性
eclipse在加载项目过程中，会对项目进行构建分析，并会进行异步的依赖校验。当触发检验不及时或者异步操作不同步的时候，就会存在一部分代码并没有及时完整的构建，此时eclipse将会展示报错信息 。则需要采用文章中提到的解决方案，使eclipse进行再一次的校验即可。
类似情况：本来有错，clean之后错误消失，在一段是时间后，仍会展示相同的错误。也是异步的问题导致的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43df7c085a9e8b8bb3f0b28c096119bc/" rel="bookmark">
			线程知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程知识点 进程：运行中的程序，有自己的地址和空间，基于进程的计算机能运行多个程序，即多进程 线程：进程中的一个执行流程，一个进程可以运行多个线程，即多线程 主线程：JAVA本身就是基于线程的，一个JAVA程序至少包含一个主线程，启动JAVA程序，主线程立即运行。（main方法所在线程即为主线程，主线程是产生其他线程的线程） 线程创建一（继承thread类，重写run方法，创建对象，调用start方法执行） package test.th; class Test extends Thread{ @Override public void run() { System.out.println("ThreadTest线程"); } } public class ThreadTest{ public static void main(String[] args) { Thread t = new Test(); t.start(); } } 线程创建二（实现runnable接口，实现run方法，创建对象，执行start方法） package test.th; class Test implements Runnable { @Override public void run() { System.out.println("Test线程"); } } public class ThreadTest { public static void main(String[] args) { Thread t = new Thread(new Test()); t.start(); } } 线程的状态 新建（NEW）：对象被创建，其start方法未被调用 就绪（RUNNABLE）: 线程对象的start方法被调用，线程等待CPU的使用权 允许（RUNNING）：线程占用CPU，执行线程中代码 阻塞（BLOCKED/WAITING）：线程对象放弃CPU，暂时停止运行，不再竞争CPU 死亡（dterminated）：线程对象的run方法执行完成（stop方法被调用） （注意）处于阻塞状态下线程对象不会竞争和占用CPU，结束阻塞状态会进入就绪状态 线程调度：合理分配多个线程对CPU资源占用 线程调度策略：任何线程都有占用CPU的机会，防止线程长期占用CPU，控制线程放弃CPU Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43df7c085a9e8b8bb3f0b28c096119bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2396def598644d1072b5bd7cb4cafc4f/" rel="bookmark">
			大学C语言期末考试题库试题及答案（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1．
下列定义变量的语句中错误的是______。
A、int _int B、double int_
C、char For D、float US$
答案：D
知识点：常量、变量和标识符
2．
以下不合法的用户标识符是______。
A、j2_KEY B、Double
C、4d D、_8_
答案：C
知识点：常量、变量和标识符
3．
以下4组用户定义标识符中，全部合法的一组是______。
A、_main enclude sin
B、If -max turbo
C、txt REAL 3COM
D、int k_2 _001 ???
答案：A
知识点：常量、变量和标识符
4．
以下定义语句中正确的是______。
A、char a='A' b='B';
B、float a=b=10.0;(正解a=10.0 b=10.0)
C、int a=10,*b=&amp;a;
D、float *a,b=&amp;a;？？？
答案：C
知识点：常量、变量和标识符
5．
以下不能定义为用户标识符的是______。
A、scanf B、Void
C、_3com_ D、int
答案：D
知识点：常量、变量和标识符
6．
以下有4组用户标识符，其中合法的一组是______。
A、For -sub Case
B、4d DO Size
C、f2_G3 IF abc
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2396def598644d1072b5bd7cb4cafc4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7487fcaa0b3bc203a04e0ad23543742b/" rel="bookmark">
			Mac实现Gitlab CICD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac安装Gitlab Runner MAC电脑可以直接安装Gitlab-runner,不需要安装Gitlab-ce
1.安装gitlab-runner
brew install gitlab-runner
2.启动gitlab-runner
brew services start gitlab-runner
3.更新
停止：brew services stop gitlab-runner
更新：
sudo curl --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-darwin-amd64
添加权限: sudo chmod +x /usr/local/bin/gitlab-runner
启动：brew services start gitlab-runner
交互式注册gitlab-runner Gitlab-runner register
输入gitlab网址：http://gitlab.com
输入token：XXXXXXXXXXXX
输入描述：buildtest
输入tags：build
输入maintenance note：直接敲回车
输入执行器：shell
获取Specific 类型的runner token
进入项目&gt;Setting&gt;CI/CD&gt;Runner&gt;Group Runner，获取token
我用项目MyCicd2这个项目来测试token也是在这个项目中获取的
在gitlab官网中，在项目根目录下添加 .gitlab-ci.yml文件，并提交代码，可以触发任务
编写 .gitlab-ci.yml
stages:
- build
- test
- deploy
build:
stage: build
tags:
- build
script:
- echo $USER
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7487fcaa0b3bc203a04e0ad23543742b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/190/">«</a>
	<span class="pagination__item pagination__item--current">191/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/192/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>