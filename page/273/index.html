<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8990370fefe83717204811ba217d5916/" rel="bookmark">
			车载服务之TSP：（Telematics Service Provider）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		车载服务之TSP：（Telematics Service Provider）汽车远程服务提供商，在Telematics产业链居于核心地位，上接汽车、车载设备制造商、网络运营商，下接内容提供商。 Telematics服务集合了位置服务、Gis服务和通信服务等现代计算机技术，为车主和个人提供强大的服务（导航、娱乐、资讯、安防、SNS、远程保养）。
Telematics：是远距离通信的电信（Telecommunications）与信息科学（Informatics）的合成词，按字面可定义为通过内置在汽车、航空、船舶、火车等运输工具上的计算机系统、无线通信技术、卫星导航装置、交换文字、语音等信息的互联网技术而提供信息的服务系统。也就是说通过无线网络，随时给行车中的人们提供驾驶、生活所必需的各种信息。
通常所说的Telematics就是指应用无线通信技术的车载电脑系统。随着电脑和网络技术应用到汽车上，正在形成称之为Telematics的新的电脑市场。Telematics是无线通信技术、卫星导航系统、网络通信技术和车载电脑的综合产物，被认为是未来的汽车技术之星。汽车行驶当中出现故障时，通过无线通信连接服务中心，进行远程车辆诊断，内置在发动机上的计算机记录汽车主要部件的状态，并随时为维修人员提供准确的故障位置和原因。通过终端机接收信息并查看交通地图、路况介绍、交通信息、安全与治安服务以及娱乐信息服务等，在后座还可以玩电子游戏、网络应用（包括金融、新闻、E-mail等）。通过Telematics提供的服务，用户不仅可以了解交通信息、临近停车场的车位状况，确认当前位置，还可以与家中的网络服务器连接,及时了解家中的电器运转情况、安全情况以及客人来访情况。也就是说：综合上述所有功能的车载计算机系统叫Telematics。
Telematics系统运作模式就目前发展的模式观察，基本上可将其分为汽车定位系统（GPS）与资讯存取（Access）两部分。
功能特色：卫星定位、道路救援、汽车防窃、自动防撞系统、车况掌握、个人化资讯接收、多媒体娱乐资讯接收。
Telematics系统的应用领域：基本上可分为前座系统、后座系统与引擎机械系统三大子系统。前座系统主要以安全、车辆保全、驾驶简易性与舒适性为主要考量。后座系统则以多媒体娱乐为主，包括互动式游戏、高传真音响视听系统、随选视讯、数位广播与数位电视等。引擎机械系统，主要是根据车用电脑所收集的车况资讯，进行车况诊断、行车效率最佳化、远距引擎调整或零件预定等。
Telematics目前主要应用在车载系统上，根据使用目的不同，Telematics可分为三种基本类型，即交通信息与导航服务、安全驾驶与车辆保护及故障诊断的车辆维护服务、娱乐及通信服务。提供全球定位系统技术、地理信息系统、智能型交通系统技术。值得一题的是Telematics逐渐演变为综合了GPS的跟踪装置和无线通信等技术的车载系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6439dd17e0eec6d71060a50f3f8d2ad3/" rel="bookmark">
			vue.runtime.esm.js:620 [Vue warn]: Error in nextTick: “TypeError: Cannot convert object to primitive
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： vue.runtime.esm.js:620 [Vue warn]: Error in nextTick: “TypeError: Cannot convert object to primitive value”
直接把数据来源变量的值赋值给页面变量，正常展示
this.columns= [{prop: "num", label: "序号"}] 直接把数据来源变量赋值给页面变量，报错
this.columns= resp.headerList 对比两次赋值
尝试处理数据，之后解决了
this.columns = JSON.parse(JSON.stringify(resp.headerList)) || []; 总结：引起报错的原因可能是数据的属性中缺少[[Prototype]]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43d1db828ffc5015b3197578064479f1/" rel="bookmark">
			Nginx和Apache和Tomcat的区别及优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Tomcat Nginx Tomcat结合Apache、Nginx一起使用实现高性能的web服务器架构 架构思路：
注意： nginx 和 apache 优缺点比较 注意：
tomcat可以结合apache和nginx 一起使用实现高性能的web服务器Apache和nginx应该叫做HTTP Server，而tomcat是一个Application Server是一个Servlet/JSO应用的容器。 注意：nginx只是把请求做了分发，不做处理！！！
归纳 **Nginx优点：负载均衡、反向代理、处理静态文件优势。nginx处理静态请求的速度高于
apache;
**Apache优点：相对于Tomcat服务器来说处理静态文件是它的优势，速度快。Apache是静态
解析，适合静态HTML、图片等。
**Tomcat：动态解析容器，处理动态请求，是编译JSPServlet的容器，Nginx有动态分离机制，
静态请求直接就可以通过Nginx处理，动态请求才转发请求到后台交由Tomcat进行处理。
总结：
tomcat 可以做动态处理，他是相当于整体app 的server，而其他两个可以理解httpServer，但是tomcat只适用于java服务器的开发然后nginx比较适合用静态和反向代理，就是如果是静态资源就自己处理，动态的资源就转发给tomcat进行处理，把请求分发出去处理nginx很适合做静态解析处理，因为他处理静态资源速度非常快，但是不支持动态处理，所以可以结合tomcat一起使用，从而实现项目的高性能。apache 也可以做静态处理，但是相对于nginx就没有那么强了，但是apache相对稳定，bug没nginx多，而且也支持动态页面，rewiter（重写）比nginx强大， （详解：https://blog.csdn.net/weixin_44221613/article/details/88410701）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a470c6a337fd5ab12e4fa8a853d4bab6/" rel="bookmark">
			jQuery获取checkbox是否选中，设置值，checkbox全选全不选功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html部分：
&lt;ul class="titleUl"&gt; &lt;li class="checkboxLi smLi"&gt;&lt;input type="checkbox" class="checkboxOfLi selectAllLi"/&gt;&lt;/li&gt; &lt;li class="titleItemLi smLi"&gt;序号&lt;/li&gt; &lt;li class="titleItemLi lLi"&gt;寿命&lt;/li&gt; &lt;/ul&gt; &lt;ul class="contentUl"&gt; &lt;li class="checkboxLi smLi"&gt;&lt;input type="checkbox" class="checkboxOfLi selectItemLi"/&gt;&lt;/li&gt; &lt;li class="titleItemLi smLi"&gt;1&lt;/li&gt; &lt;li class="titleItemLi lLi"&gt;350&lt;/li&gt; &lt;/ul&gt; &lt;ul class="contentUl"&gt; &lt;li class="checkboxLi smLi"&gt;&lt;input type="checkbox" class="checkboxOfLi selectItemLi"/&gt;&lt;/li&gt; &lt;li class="contentItemLi smLi"&gt;2&lt;/li&gt; &lt;li class="contentItemLi lLi"&gt;2&lt;/li&gt; &lt;/ul&gt; 1. 设置checkbox选中和不选择状态： // 设置选中 $(".selectItemLi").attr('checked',true); // 或 $(".selectItemLi").prop('checked',true); // 设置不选中 $(".selectItemLi").attr('checked',false); // 或 $(".selectItemLi").prop('checked',false); 2. 获取checkbox值 // 获取是否选中，true为选中，false为未选中 $(".selectAllLi").is(':checked') 3. 全选和全不选 /** * 全选 */ $("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a470c6a337fd5ab12e4fa8a853d4bab6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df2297c42638b0b36ce5cd9da7f0c8b/" rel="bookmark">
			C#.net MAUI 跨平台应用开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		观点 目前最适合移动端跨端开发的答案的确是Google开发的Flutter
Flutter 有如下优点：
（1）渐进式开发，作为部分页面嵌入到已有程序中（我认为最大的优点）
（2）混合开发中，最接近原生开发的框架；
（3）性能强大，流畅；
（4）优秀的路由设计；
（5）优秀的动画设计；
（6）简单易学，Dart语言更具优势；
（7）跨多种平台，减少开发成本；支持插件，可以访问原生系统的调用。
听说的缺点：
（1）适配问题，开发工具版本升级后，修改量大；
（2）原生集成第三方SDK后，兼容性适配是个令人头痛的问题；
（3）代码可读性较差，对代码质量和管理要求较高；
（4）Widget的类型难以选择，糟糕的UI控件API；
（5）Flutter packages和Dart packages上第三方sdk繁杂，适配性差，不可乱用；
但是总的来说，目前最好的移动端开发UI我认为还是Flutter。由于.NET6推出了MAUI，让我忍不住也试试看，下面为大家介绍我的第一个MAUI Demo，以及安装MAUI过程。
VS2022 Preview &amp; MAUI Preview 这里要注意的是，虽然VS2022社区版、专业版、企业版早就有了，但是这三个版本并不包含MAUI，所以注意别下错了，需要到https://docs.microsoft.com/zh-cn/visualstudio/releases/2022/release-notes-preview下载如图所示的Preview预览版。
下载后便进入常规的安装操作：
安装完成后，在启动页输入“MAUI”，便能看到一个支持各平台的MAUI工程。
进入工程项目后，我们在解决方案中能看到MAUI项目的整体结构与WPF项目还是比较相似的。首次开启下面会有报错，原因是解决方案中的依赖项版本问题，只需进入Nuget管理中更新一下依赖项即可。
首先，选择Windows Machine，看看MAUI在我们常见的Windows上运行的效果：
接着尝试一下在Android平台运行，首先选择Android设备管理器，在管理器中新建一个Android设备，建立哪种机型和配置都行，根据自己的电脑运行能力来建立即可。
建立完成后，然后启动安卓设备，就能看到如图所示的Android模拟机了，实际上，有Flutter开发经验的同学比较容易理解，Flutter开发调试apk也需要建立一个安卓虚拟机，我原先是在Android Studio中建立虚拟机，但由于电脑配置一般，实在太卡了，就利用谷歌浏览器的调试模式(可模拟安卓机型)开发，至于MAUI能不能这样，后续我会继续研究看看。
最后，点击运行MAUI DEMO项目，就成功运行我们第一个MAUI App啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2705380c8705a2deee2bfe33d0c183/" rel="bookmark">
			200. 岛屿数量-Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)题目概述:算法思路:1. 深度优先搜索 代码实现:复杂度分析:2. 广度优先搜索分离行与列的方法: 代码实现:复杂度分析: 200. 岛屿数量 题目概述: 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1： 输入：grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"], ["1","1","0","0","0"], ["0","0","0","0","0"] ] 输出：1 示例 2： 输入：grid = [ ["1","1","0","0","0"], ["1","1","0","0","0"], ["0","0","1","0","0"], ["0","0","0","1","1"] ] 输出：3 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 300 grid[i][j] 的值为 '0' 或 '1' 算法思路: 1. 深度优先搜索 求岛屿数量，与搜索相关。由题中所给条件：岛屿总是被水包围，可以得出DFS的结束条件：grid[row][column]=‘0’依次遍历grid中的所有元素，并且进行DFS，遇到陆地时，计数器自增DFS中，遇到陆地(‘1’)就将陆地覆盖为水(‘0’)，出边界以及遇到水时跳出搜索 代码实现: public void dfs(char[][] grid,int row,int column){ int rowLength = grid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad2705380c8705a2deee2bfe33d0c183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6f07f1666d89c76e1206e583f33f19a/" rel="bookmark">
			JS逆向之x讯视频wasm的ckey分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		篇幅有限 完整内容及源码关注公众号：ReverseCode，发送 冲
起因 最近对腾讯视频下手了，因为公众号中的视频来源都是腾讯视频，也就是说通过2分钟阅读本文，腾讯视频下整站视频都可以下载下来，也是大多数在线解析vip等视频网站底层实现逻辑，接下来就是建站接广告接流量接法院传单。。。。
分析 通过点击播放抓包发现不停的请求http://btrace.video.qq.com/kvcollect，点击发现没有发现，不过这些请求都是m3u8格式片段，我们大胆猜测这是m3u8，将视频切成无数ts小段，一段一段加载播放，可以根据网络状况自动切换视频清晰度，保障流畅播放。那么这种播放方式前端一定有请求索引文件保存ts文件，保存了网络url链接，这些链接顺序播放就完成了整个视频的播放。而我们数据抓取只需要关注这个文件，m3u8转为mp4格式，具体转换代码见https://github.com/OneJane/datautil
废话一堆，开始寻找m3u8请求，通过过滤筛选找到该请求后,http://58.216.106.14/omts.tc.qq.com/AjzDO1DrTOFhSuI4sQa-qkOmtUv8yq9UrejaLeSKpF2M/uwMROfz2r57BIaQXGdGnC2deOm7WRbkbfdWCxMUsemsF2Gfz/svp_50001/NO3RnkZVfa4hKoQCijd2VpXELo5sw-cgX_CMZmI7XeU8ZfKGTirnxL1xJGXvDq2mliBQiL2MqcB6egr3lk7nk3wyBP18yb1lGlcVFNCkQ82kNml8GgGg4BbokC6yjxDcIJIVugQ8OkIG6GOCUijW9a3QpotWcmbZTrCI5kfpcYxax9isGSZL7Q/szg_3772_50001_0bc3hqaciaaameaajrug6rqvcpgdeq6aajca.f304110.ts.m3u8?ver=4
这个请求除去域名外所有参数都加密了，随便找一段加密参数随便搜搜，找到了目标请求http://vd.l.qq.com/proxyhttp
通过json格式化vinfo参数可以判断url+pt即可拿到我们想要的m3u8文件
好戏开场了 参数做减法，去除adparam和vinfoparam中的logintoken和ehost，重点关注guid，flowid，cKey，tm就是时间戳，vid就是请求中的视频id
spsrt=1 charge=0 defaultfmt=auto otype=ojson guid=a66e56d20401a21c8a35e92ad94eebde flowid=82a7dcecd17cede6b9dc02a39571c4bc_70201 platform=70201 sdtfrom=v1104 defnpayver=0 appVer=3.4.40 host=v.qq.com refer=v.qq.com sphttps=0 tm=1637204401 spwm=4 vid=s3306hychob defn= fhdswitch=0 show1080p=0 isHLS=1 dtype=3 sphls=1 spgzip= dlver= hdcp=0 spau=1 spaudio=15 defsrc=1 encryptVer=9.1 cKey=doItDoTdYRR79ZEItZs_lpJX5WFNi2CdS8kE1h7qVaqtHEZQ1c_X6m2O8hQenWPBG5hnGM2UODs52vPBr7VR-rE3OCFTLlH3-xN1QMZmGWCleJdQ62v6N6dvhRBy86U5pyEtRx0KHILNluNDEH6IC8EOljLQ2VfW2sTdospNPlD9535CNT9iSo3cLRH93ogtX_OJeYNVWrDYS8btjkFpGl3F3IxmISJc_8dRIBruTik-e4rt0isxZAXexKqWDJGxu2qxHq-QxHER_ek2fB1T6ywJriVO0ksOGo7_XQLdE-FshP9ARvdxQlEJPKWtziEF2xwGBgYGBgY0KhFT 打上xhr断点vd.l.qq.com/proxyhttp，在调用栈中r.requestPostCgi中参数已经生成，继续向上追溯
追溯到requestNewGetinfoImpl，该方法中p.requestPostCgi发起请求参数已经封装完成，手动调用this.getInfoConfig("vinfoad", i)时cKey及guid，flowid都已经加密完成。
进入getInfoConfig
在如下这段代码中guid不存在时，guid: this.context.dataset.guid将通过l.getUserId(this.context.config)
this.context.dataset.guid || (this.context.config.guid = l.getUserId(this.context.config), this.context.dataset.guid = this.context.config.guid); 由于l = o(436)，进入436: function(e, t, o)找到了getUserId，当从本地或者内存中取不到时调用d.createGUID()，也就是随机32位字符串。
getUserId: function(e) { var t = e.guid || d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6f07f1666d89c76e1206e583f33f19a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/973ace6fbda6bf55b29865bd47c58804/" rel="bookmark">
			2021-2022-1 20212813《Linux内核原理与分析》第十二周作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		格式化字符串漏洞实验 一、 实验描述二、实验预备知识讲解2.1 什么是格式化字符串？2.2 栈与格式化字符串2.3 如果参数数量不匹配会发生什么？ 三、实验内容3.1 实验 13.1.1 找出 secret[1]的值3.1.2 修改 secret[1]的值3.1.3 修改 secret[1]为期望值 3.2 实验 23.2.1 修改 secret[0]的值 一、 实验描述 格式化字符串漏洞是由像 printf(user_input) 这样的代码引起的，其中 user_input 是用户输入的数据，具有 Set-UID root 权限的这类程序在运行的时候，printf 语句将会变得非常危险，因为它可能会导致下面的结果：
使得程序崩溃任意一块内存读取数据修改任意一块内存里的数据 最后一种结果是非常危险的，因为它允许用户修改 set-UID root 程序内部变量的值，从而改变这些程序的行为。
二、实验预备知识讲解 2.1 什么是格式化字符串？ printf ("The magic number is: %d", 1911); 上面的这段 C 语言代码运行结果为 The magic number is: 1911 ，你会发现字符串 The magic number is: %d 中的格式符 %d 被参数（1911）替换。
其他形式的格式符:
格式符含义含义（英）传%d十进制数（int）decimal值%u无符号十进制数 (unsigned int)unsigned decimal值%x十六进制数 (unsigned int)hexadecimal值%s字符串 ((const) (unsigned) char *)string引用（指针）%n%n 符号以前输入的字符数量 (* int)number of bytes written so far引用（指针） 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/973ace6fbda6bf55b29865bd47c58804/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4bcc07e38c693fece956f8d6c4b844d/" rel="bookmark">
			Java使用Redis及其优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 开启远程连接Jedis连接Redis封装Jedis进行操作 所有坚韧不拔的努力迟早会取得报酬的。—— 安格尔
开启远程连接 Redis默认是不支持远程连接的，这里需要手动开启远程连接。
关闭本机IP绑定，允许远程连接。找到redis.conf中的bind:127.0.0.1将其注释。
开启密码校验。找到redis.conf中的requirepass去掉其注释并设置密码。 Jedis连接Redis 创建一个Maven项目，导入Jedis依赖。
&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 测试链接是否成功。
public static void main(String[] args) { //创建Jedis对象 如果使用的是默认端口 则可忽略 （本次使用的是Docker创建的Redis） Jedis jedis = new Jedis("127.0.0.1", 6379); //密码认证 jedis.auth("123456"); //测试连接 String res = jedis.ping(); //输出PONG表示连接成功 抛出异常则失败 System.out.println(res); } 使用Redis中写入一些值。不熟悉基本操作的可以查看Redis基本操作。
//获取值 System.out.println(jedis.get("name")); //写入值 String result = jedis.set("gender", "male"); System.out.println(result); 紧接着再去redis中查看刚才写入的gender。
Jedis中提供的方法和Redis的命令基本上是一样的，所以这里的操作就不做过多的赘述了。
封装Jedis进行操作 Jedis对象不是线城安全的，所以在实际开发中，一般我们都是通过连接池来获取，使用完成后再还给连接池。
public interface JedisCall { void call(Jedis jedis); } public class RedisDemo { private JedisPool jedisPool; public RedisDemo(){ GenericObjectPoolConfig config = new GenericObjectPoolConfig(); //设置连接池最大空闲数 config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4bcc07e38c693fece956f8d6c4b844d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c88bc49ba0cb933062d0f735857e590/" rel="bookmark">
			js中常用函数整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用函数整理 使用typescript编写，更容易理解传参类型。
仓库地址： https://github.com/leopord-lau/utils
// generate random number in a giving range const randomNumber = (min: number | string, max: number | string): number =&gt; { min = Number(min); max = Number(max); // typeError if(isNaN(min) || isNaN(max)) { return -1; } return Math.floor(Math.random() * (max - min + 1)) + min; } // thousands separator const format = (number: number | string, separator: string = ','): string =&gt; { let numStr: string = number.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c88bc49ba0cb933062d0f735857e590/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8703e7adcbb5f96a80db080ffbf61f73/" rel="bookmark">
			ARM和DSP之间的不同之处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FPGA、ASIC和assp
抛开FPGA不提，大家一定都很熟悉ASIC与ASSP。所谓ASIC，即专用集成电路（Application Specific Integrated Circuit）的简称；而ASSP，即专用标准产品（Application Specific Standard Parts）。电子产品中，它们无所不在，还真是比FPGA普及得多得多。但是ASIC以及ASSP的功能相对固定，它是为了专一功能或专一应用领域而生，希望对它进行任何的功能和性能的改善往往是无济于事的。打个浅显的比喻，如图1.3所示，如果说ASIC或ASSP是布满铅字的印刷品，那么FPGA就是可以自由发挥的白纸一张。
￼
使用了FPGA器件的电子产品，在产品发布后仍然可以对产品设计作出修改，大大方便了产品的更新以及针对新的协议标准作出的相应改进，从而可以加速产品的上市时间，并降低产品的失败风险和维护成本。相对于无法对售后产品设计进行修改的ASIC和ASSP来说，这是FPGA特有的一个优势。由于FPGA可编程的灵活性以及近年来电子技术领域的快速发展，FPGA也正在向高集成、高性能、低功耗、低价格的方向发展，并且逐渐具备了与ASIC和ASSP相当的性能，使其被广泛地应用在各行各业的电子及通信设备中。
FPGA、ARM和DSP
与ASIC相比，FPGA、ARM和DSP都具备与生俱来的可编程特性。或许身处开发第一线的底层工程师要说No了，很多ASIC不是也开放了一些可配置选项，实现“可编程”特性吗？是的，但与FPGA、ARM、DSP能够“为所欲为”的任意操控一整个系统而言，ASIC的那点“可编程”性的确摆不上台面。当然，换个角度来看，FPGA、ARM和DSP都或多或少集成了一些ASIC功能，正是这些ASIC功能，加上“可编程”特性，使得它们相互区别开了，并且各自独霸一方。
ARM（Advanced RISC Machines）是微处理器行业的一家知名企业，设计了大量高性能、廉价、耗能低的RISC处理器、相关技术及软件。由ARM公司设计的处理器风靡全球，大有嵌入式系统无处不ARM的趋势。因此，我们通常所说的ARM，更多的是指ARM公司的处理器，即ARM处理器。ARM通常包含一颗强大的处理器内核，并且为这颗处理器量身配套了很多成熟的软件工具以及高级编程语言，这也是它倍受青睐的原因之一。当然了，ARM不只是一颗处理器而已，因为在ARM内核处理器周边，各种各样精于控制的外设比比皆是，什么GPIO、PWM、AD/DA、UART、SPI、IIC……一列一箩筐。ARM的长处在控制和管理，在很多工业自动化中大有用武之地。
DSP（digital singnal processor），即数字信号处理器，是一种独特的微处理器，有自己的完整指令系统，能够进行高速、高吞吐量的数字信号处理。它不像ARM那么“胡里花俏”，它更“专”。它只专注一件事，就是对各种语音、数据和视频做运算处理；或者也可以这么说，DSP是为各种数学运算量身打造的。
￼
相比之下，套用近些年一句业内很火的广告词“All Programmable”来形容FPGA再合适不过了。ARM虽然有很多外设，DSP虽然具备强大的信号运算能力，但是FPGA眼里，这些都不过是“小菜一碟”。或许说得有些过了，但是，毫不夸张的讲，ARM能做的，DSP能做的，FPGA一定也都能做；而FPGA可以做的，ARM不一定行，DSP也不一定行。这就是很多原型产品设计过程中，时不时的有人会提出给于FPGA的方案了。在一些灵活性要求高、定制化程度高、性能要求也特别高的场合，FPGA再合适不过了，甚至有时会是设计者别无选择的选择；当然了，客观的来看，FPGA固然强大，它高高在上的成本、功耗和开发复杂性还是会让很多潜在的目标产品望而却步，而在这些方面，ARM和DSP正好弥补了FPGA所带来的缺憾。
￼
总而言之，在嵌入式系统设计领域，FPGA、ARM和DSP互有优劣，各有所长。很多时候它们所实现的功能无法简单的相互替代，否则我们就不会见到如TI的达芬奇系列ARM中有DSP、xilinx的Zynq或altera的Soc FPGA中有ARM的共生现象了。
FPGA、ARM和DSP，它们将在未来很长的一段时间内呈现三足鼎立的局面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/663799831f278eb0f7629426a2739bdd/" rel="bookmark">
			Vivado 全局重定时vs 局部重定定时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 重定时（Retiming）介绍
重定时（Retiming）是一种时序优化技术，用在不影响电路输入/输出行为的情况下跨组合逻辑寄存器从而提高设计性能。图1所示的电路是六输入加法器，其中有一条关键路径，红色推出显示的路径是限制整个电路性能的关键路径。
￼
通过对加法器输出路径上寄存器进行重定时设计，调整电路的组合逻辑，可以改变整个电路的性能。
整个电路的延迟是4，图2展示的是一种寄存器组合方法可以将逻辑最小化，将输出寄存器融合到逻辑寄存器中称为向后重定时设计，这一步完成后关键路径被压缩为二输入加法器。
关于上述 示例需要注意的另一点是寄存器数量的变化。
图1采用9个不同寄存器总线，图2使用了12个不同寄存器总线，产生这样结果的原因是当采用向后重定时设计时，当寄存器从输出移动到输入时，逻辑门的两个输入都必须增加一个寄存器。
有两种不同的重定时方法，向后重定时和向前重定时。向后重定时从门的输出中删除寄存器，并在同一逻辑门的输入出创建新的寄存器。向前重定时的作用正好相反，它从逻辑门的输入中删除寄存器，并在输出中创建新的寄存器。
若要向后重定时，组合逻辑必须仅用来驱动寄存器，而不能向其他逻辑寄存器展开，为了使前向重定时正常工作，逻辑门的每个输入必须有具有相同控制逻辑的寄存器来驱动。
￼
全局重定时vs 局部重定时
在Vivado 综合操作中有两种方法实现自动重定时：全局重定时和局部重定时。
全局重定时是对整个设计而言的，基于设计时的时序要求优化大型组合逻辑结构中的寄存器设计。
这种方式需要分析设计中的所有逻辑，优化最坏路径情况下的寄存器从而使整体设计反应速度更快。为了实现这一点设计时必须在.xdc文件中规定准确的时间限制。在synth_design或Vivado GUI综合设置下通过-retiming命令启用全局重定时，此外该特性还可以与合成中的BLOCK_SYNTH特性一起用于设计中的特定模块。
局部重定时是指用户明确告诉工具使用retiming_forward、retiming_bbackward RTL属性时需要执行的重定时逻辑。
执行局部重定时操作是应该要小心，因为它不是计时器驱动的，而是工具将完全按照用户要求去执行。
有关重定时使用的更多信息，请参阅（UG901）Vivado设计工具用户指南：Synthesis（综合）。
分析日志文件中的信息
图4是通过重定时提升逻辑水平的一个例子，该电路结构中有一个关键的路径分为三个逻辑层，组成的是一个37位的逻辑与门（AND），源寄存器命名为din1_dly_reg，目标寄存器命名为tmp1_reg，在逻辑级别为0的tmp1_reg后面增加一个额外的寄存器。
这是一个理想的重定时逻辑路径设计，因为我们可以切换为三个逻辑级别的路径，由0、1、2三个局部逻辑电路模块组成。
￼
图4：采用后向重定时设计的电路
综合操作日志文件包含的信息大致如下：
￼
从这个日志文件中你可以看到重定时操作前后的逻辑门信息对比，以及创建的新寄存器名称，当synthesis通过重定时创建新寄存器时，它将对后向重定时的寄存器使用后缀“bret”，对前向重定时寄存器使用后缀“fret”。
图5展示的电路中一些不兼容的寄存器将无法进行重定时操作，这个结构中同样有一个名为din1_dly_reg的源寄存器，它经过37位逻辑与门生成三级逻辑电路结构，然后在din1_dly_reg寄存器前结束。此外逻辑与门还有一路连接到另外一个寄存器，如下图粉色高亮显示的部分。
￼
￼
这个日志文件包含的信息是关于 不兼容的FIFO寄存器的，前后的电路的逻辑层级不变。这是示例不能进行重定时操作是因为粉红色高亮显示的部分，这个寄存器需要一部重置，而tmp1_reg没有这个功能，因为这两个寄存器没有相同的控制集，所以它们不能向后重定时到新的逻辑与门电路中，本例的日志文件信息如下：
￼
以下情况下不能进行重定时操作：
寄存器时序异常（多循环路径、错误的路径、最大延迟路径）寄存器的类型属性不能改变（DONT_TOUCH, MARK_debug）采用不同控制级的寄存器
驱动输出的寄存器或者被输入驱动的寄存器（除非这部分是与前后电路不相关的）
重定时无法改善反馈循环回路中关键路径的性能的一个例子：
当路径中具有相同的源寄存器和目标寄存器时，重定时优化操作可能无法改进整个逻辑电路的结构。
举个例子：
寄存器“dout_reg”的关键路径如下图中红色所示，要经过一个逻辑与运算，然后连接到同一寄存器的复位管脚上才算结束。
根据数位宽度（16比特）逻辑与门电路要占用两个逻辑操作。
￼
下面的屏幕截图显示了综合操作如何描述关键路径的
其中还提到了关键路径中一部分模块或寄存器的名字。
￼ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb85a8a2aedcf76f7107852c58fe23ad/" rel="bookmark">
			OOK调制解调的FPGA实现，求Verilog代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己对FPGA刚开始学习，但又特别需要用到FPGA实现OOK的调制解调，求帮忙，由于是新人，还只有一个积分，太可怜了。求大神帮忙。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c0adf220b6a3ebbe38a70a3ad6206d2/" rel="bookmark">
			【MMCV】让你在10分钟了解mmcv注册器（registry)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、注册器是什么？二、使用步骤一个简单的例子自定义构建MMCV实例说明三.注册器的层次 总结 前言 MMCV 使用 注册器 来管理具有相似功能的不同模块, 例如, 检测器中的主干网络、头部、和模型颈部。 在 OpenMMLab 家族中的绝大部分开源项目使用注册器去管理数据集和模型的模块，例如 MMDetection。
官方指南
一、注册器是什么？ 在MMCV中，注册器可以看作类到字符串的映射。 一个注册器中的类通常有相似的接口，但是可以实现不同的算法或支持不同的数据集。 借助注册器，用户可以通过使用相应的字符串查找并实例化该类，并根据他们的需要实例化对应模块。
二、使用步骤 1.创建一个构建方法（可选，在大多数情况下您可以只使用默认方法）
2.创建注册器
3.使用此注册器来管理模块
一个简单的例子 file1： from mmcv.utils import Registry # 创建转换器（converter）的注册器（registry） CONVERTERS = Registry('converter') file2： from .builder import CONVERTERS # 使用注册器管理模块 @CONVERTERS.register_module() class Converter1(object): def __init__(self, a, b): self.a = a self.b = b file3： converter_cfg = dict(type='Converter1', a=a_value, b=b_value) converter = CONVERTERS.build(converter_cfg) 在这里就实现了字符串到类的 对应转化——‘Converter1’ -&gt; &lt;class ‘Converter1’&gt;
通过XXX.build( )函数来实例化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c0adf220b6a3ebbe38a70a3ad6206d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58396741e6872a4f7c42fb9c7905da2b/" rel="bookmark">
			集合之深入理解PriorityQueue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 知识储备PriorityQueue源码类部分注释add() 和 offer()remove()和poll() 知识储备 数据结构知识储备：
堆的定义：百度百科
堆（heap）是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：
堆中某个节点的值总是不大于或不小于其父节点的值；（要么父节点都大于等于子节点的值，要么父节点的值都小于等于子节点的值）堆总是一棵完全二叉树。
简而言之，堆是一棵完全二叉树，这个二叉树的节点的值要满足下面的规则。假设node表示节点，node.val 表示节点值，node.left 表示该节点的左子节点，node.right 表示该节点的右子节点。那么，堆要满足的规则是:
(node.val &lt;= node.left.val &amp;&amp; node.val &lt;= node.right.val) || (node.val &gt;= node.left.val &amp;&amp; node.val &gt;= node.right.val).
当 node.val &lt;= node.left.val &amp;&amp; node.val &lt;= node.right.val 时，父节点的值都小于等于子节点的值，称为小根堆（或小顶堆）。反之，父节点的值都大于等于子节点的值，称为大根堆（或大顶堆）
注意：完全二叉树的数据结构可以使用链表，也可以使用数组。在PriorityQueue中就是使用数组来表示完全二叉树。 PriorityQueue源码 类部分注释 An unbounded priority queue based on a priority heap. 基于优先堆的无界优先队列。 The elements of the priority queue are ordered according to their natural ordering, 优先队列的元素是按照它们的自然顺序排列的， or by a Comparator provided at queue construction time, depending on which constructor is used.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58396741e6872a4f7c42fb9c7905da2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d89dc14c550b91da99f4e3dbeac5155a/" rel="bookmark">
			windows下使用filezilla上传文件权限问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows下使用filezilla上传文件权限问题（open for write: permission denied）
解决方式：
使用以下命令给我们需要放入的目标文件权限：
sudo chmod 777 /home
sudo chmod 777 /opt/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db5eb7ed9f4946ac5c7dcebd126fe9e4/" rel="bookmark">
			Redis查看当前密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具：命令提示符（cmd） 环境：Windows10
安装redis后，如果不设置密码，基本上密码默认是空，如果不放心，那就查看一下当前密码。
1.首先在搜索框中输入cmd，打开命令提示符工具。
2.切到redis所在的文件夹，然后输入redis-server.exe启动服务，下图这种的就启动成功了。
3.再把1走一遍，2不关，打开新的命令提示符，切到redis的文件夹下，输入redis-cli.exe，启动客户端，连接服务器。出现这种的客户端就成功了。
4.如图，输入config get requirepass回车，我没设置密码，所以2）为空。
5.题外话
config set requirepass 自己的密码 ：这应该是设置密码的命令来着。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c98474e5483a0c1453e2d06c56bd41d0/" rel="bookmark">
			Latex 强制文本两端左右对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在用 LaTeX Beamer 做 slides 时输入较多文字和公式的文本时, 遇到了行内公式不能自动换行, 导致了一大段的文本左右不能对齐.
这种情况可以利用 \usepackage{ragged2e} 中的 \justifying 命令来强制当前段文本进行左右对齐, 这样行内公式也可以自动换行来进行对齐了.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c91b8867013dff0891748c525a9a188d/" rel="bookmark">
			Frida常用api大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		篇幅有限 完整内容及源码关注公众号：ReverseCode，发送 冲
动静态函数主动调用 静态函数 use
function static() { Java.perform(function () {//只要是java的代码都要跑在Java.perform里面 Java.use("com.example.junior.util.Utils").dip2px.implementation = function (context, float) { //return null; var result = this.dip2px(context, 100) console.log("context,float,result ==&gt; ", context, float, result); // 打印log console.log(Java.use("android.util.Log").getStackTraceString(Java.use("java.lang.Throwable").$new())); return 26; } Java.use('com.xx.app.ShufferMap').show.implementation = function (map) { console.log(JSON.stringify(map)); var hm = Java.use('java.util.HashMap').$new(); hm.put("user","dajianbang"); hm.put("pass","87654321"); hm.put("code","123456"); return this.show(hm); } var myBytes = StringClass.$new("Hello World").getBytes(); var base64Class = Java.use("android.util.Base64"); var result = Java.use("com.xiaojianbang.app.RSA").encrypt(myBytes); console.log("result is :", result); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c91b8867013dff0891748c525a9a188d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2caefad5c7dbc7a10ed60bec0f9f7292/" rel="bookmark">
			HTML5 简单的转盘抽奖js特效代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址
var info=["一等奖","二等奖","三等奖","四等奖","五等奖","六等奖","七等奖","八等奖","九等奖","十等奖"];var color=[];var step = 2*Math.PI/10;var outerR = 150; //轮盘的大小var interR = 50;//内存空白圆的大小var beginAngle=50;//旋转起来时默认开始旋转的度数，度数愈大旋转的初始速度愈大var radio = 0.95;//旋转速度衰减系数，影响旋转时间var t = null;window.οnlοad=function() { for ( var i = 0; i &lt; 10; i++) { color.push(getColor()); } var canvas = document.getElementById("canvas"); var context = canvas.getContext("2d"); context.translate(250,250); Arrow(context); init(context); document.getElementById("btn").οnclick=function(){ if(t){ return false; } var step = beginAngle +Math.random()*10; var angle = 0; t = setInterval(function(){ step *=radio; if(step &lt;= 0.1){ clearInterval(t); t =null; var pos = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2caefad5c7dbc7a10ed60bec0f9f7292/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21d16efb37437fd588f5756cf35c063d/" rel="bookmark">
			vscode下载很慢问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先去官网下载，大概率会出现如下情况：
2.复制出以上下载的链接地址，把以上截图红框标注的部分换成vscode.cdn.azure.cn ，这样会变成采用国内的镜像，再次访问新地址来下载vscode，情况如下：
3.可以发现速度明显快了很多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5bd4fbe0b6dc9a710f77000a7938d46/" rel="bookmark">
			matlab中fill函数的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 填充的二维多边形
fill 函数创建彩色多边形。
语法
①fill(X,Y,C)
fill(X,Y,C) 根据 X 和 Y 中的数据创建填充的多边形（顶点颜色由 C 指定）。C 是一个用作颜色图索引的矢量或矩阵。如果 C 为行矢量，length© 必须等于 size(X,2) 和 size(Y,2)；如果 C 为列矢量，length© 必须等于 size(X,1) 和 size(Y,1)。必要时，fill 可将最后一个顶点与第一个顶点相连以闭合多边形。X 和 Y 的值可以是数字、日期时间、持续时间或类别值。
②fill(X,Y,ColorSpec)
fill(X,Y,ColorSpec) 填充 X 和 Y 指定的二维多边形（颜色由 ColorSpec 指定）。
③fill(X1,Y1,C1,X2,Y2,C2,…)
fill(X1,Y1,C1,X2,Y2,C2,…) 指定多个二维填充区。
④fill(…,‘PropertyName’,PropertyValue)
fill(…,‘PropertyName’,PropertyValue) 允许您为补片图形对象指定属性名称和值。
⑤fill(ax,…)
fill(ax,…) 将在由 ax 指定的坐标轴而不是当前坐标轴 (gca) 中创建多边形。选项 ax 可以位于前面的语法中的任何输入参数组合之前。
⑥h = fill(…)
h = fill(…) 返回由补片对象构成的矢量。
示例：创建红色八边形
%定义该数据 t = (1/16:1/8:1)'*2*pi; x = cos(t); y = sin(t); %使用fill函数创建一个红色八边形 fill(x,y,'r') axis square 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a477100b9316e84c3dd15cc621fdb439/" rel="bookmark">
			1044 火星数字 (20 分)(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://www.liuchuo.net/
Notice hash + 进制的计算 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; string a[13] = {"tret","jan", "feb","mar", "apr", "may", "jun", "jly", "aug", "sep", "oct", "nov", "dec"}; //把tret存到0位 string b[13] = {"##","tam", "hel", "maa", "huh", "tou", "kes", "hei", "elo","syy", "lok", "mer", "jou"}; // 0位上为一个占位符,从1开始存数据，方便取模运算结果对应 void func1(int i){ //地球---&gt;火星 if(i / 13)cout &lt;&lt; b[i/13]; //火星文是两位情况下，先输出高位 if((i / 13) &amp;&amp; (i % 13))cout &lt;&lt; " "; //两位情况下，判断有没有低位，若有需要空格 if(i % 13 || i == 0)cout &lt;&lt; a[i % 13]; //火星文只有一位的情况+两位且低位也存在的情况+输入为0的情况（0%任何数都为0） } void func2(string s){ //火星 ---&gt; 地球 string s1,s2; s1 = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a477100b9316e84c3dd15cc621fdb439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52f3faec1bb76884ba738e2243a7957d/" rel="bookmark">
			K8S 集群部署--B站linux超哥视频学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记为根据B站UP主linux超哥的视频进行学习，并记录，如有错漏，心情好的可以指出一下。
https://www.bilibili.com/video/BV1yP4y1x7Vj?spm_id_from=333.999.0.0 机器环境准备： 2C4G的虚拟机
主机名节点ip角色部署组件k8s-master01192.168.131.128master01etcd,kube-apiserver,kube-controller-manager,kubectl,kubeadm,kubelet,kube-proxy,flannelk8s-note01192.168.131.129note01kubectl,kubelet,kube-proxy,flannelk8s-note02192.168.131.130note02kubectl,kubelet,kube-proxy,flannel 创建虚拟机，并完善基础配置
定义好主机名 配置host解析
cat &gt;&gt; /etc/hosts &lt;&lt; EOF 192.168.131.128 k8s-master01 192.168.131.129 k8s-note01 192.168.131.130 k8s-note02 EOF 防火墙规则调整（ 防止FORWARD是拒绝的，导致集群直接不可以互相访问）
iptables -P FORWARD ACCEPT 关闭swap缓存#重要
swapoff -a 防止开机自动挂载swap分区
sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab 关闭selinux，禁用firewall
sed -ri 's#(SELINUX=).*#\1disabled#' /etc/selinux/config setenforce 0 systemctl disable firewalld &amp;&amp; systemctl stop firewalld 开启内核对流量的转发
cat &lt;&lt; EOF &gt; /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward=1 vm.max_map_count=262144 EOF 加载内核参数
modprobe br_netfilter sysctl -p /etc/sysctl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52f3faec1bb76884ba738e2243a7957d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/178cb3a3a560221cb1083b3766d2687e/" rel="bookmark">
			mybatis-plus分页无效解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同版本的mybatis-plus需要的分页配置不同，这一不同自3.4.0后开始出现
1.在pom.xml中查看自己的mybatis-plus版本
2.确保自己已经删除了pagehelper
3.建立需要的分页配置
旧版本（3.4.0之前）
@Configuration public class MybatisPlusConfig { /** * 分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() { return new PaginationInterceptor(); } } 新版本（3.4.0之后）
@Configuration public class MybatisPlusConfig { /** * mybatis-plus分页插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } 每天进步一点点，开心也多一点点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/134b297acb19a8a0add974614c8562a5/" rel="bookmark">
			在torch_geometric.datasets中使用Planetoid手动导入Core数据集及发生相关错误解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在torch_geometric.datasets中使用Planetoid手动导入Core数据集及发生相关错误解决方案 一、有两种错误类型，第一种因为需要在github上使用这个链接https://github.com/kimiyoung/planetoid/raw/master/data/ind.cora.x进行下载Core数据集，但是没有vpn打不开下载不了，出现“TimeoutError: [WinError 10060] 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。”这种错误。 解决方案：点击下面的链接直接保存下载Cora文件包，然后解压后手动添加到工程文件中。 Cora数据集包：点击打开链接，提取码：6666 二、第二种错误类型，手动添加Cora数据集到工程文件中，如果大家直接将Cora数据集全部复制粘贴到新的data中，会出现“RuntimeError: The ‘data’ object was created by an older version of PyG. If this error occurred while loading an already existing dataset, remove the ‘processed/’ directory in the dataset’s root folder and try again.”（“数据”对象是由旧版本的 PyG 创建的。 如果在加载现有数据集时发生此错误，请删除数据集根文件夹中的“已处理/”目录，然后重试。）这种错误，原因也非常具体就是要把processed的文件夹中的内容删除掉。 解决方案：只复制解压后的Cora数据集文件包中的raw文件夹中的内容，直接粘贴到工程文件data中的Cora文件夹中的raw文件夹中，不复制processed的内容。 三、运行工程文件出现下面图片中的内容说明导入Core数据集成功。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8584b931d9bc1219499d77549c567f10/" rel="bookmark">
			基于UMDF2将 WPP 软件跟踪添加到 Windows 驱动程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景 作为一位标准的 WINDOWN 驱动开发人员最痛苦并快乐着就是构建驱动框架时都喜欢构架自己的LOG框架，
直接调用系统的接口函数显得太生涩和苦逼了；而 window 驱动的原生态log API 调用又繁琐且麻烦。
因此，基于此基础上，就有了本文的撰写目的。
2. 概要 2.1 环境约定 运行环境:WIN10/WIN11
开发工具:VS2019
SDK版本:wdksetup.exe
驱动框架:UMDF2
2.2 参考文档 ` [1] https://docs.microsoft.com/zh-cn/windows-hardware/drivers/devtest/adding-wpp-software-tracing-to-a-windows-driver#step-4-ad
3. 操作 3.1 UMDF2 项目创建 A.打开 Visual Studio 2019;
B.创建新项目
C.基于UMDF2 框架创建项目
D.配置基于UMDF2 框架的项目
3.2 向项目添加 LOG 相关的文件 A.添加 LogMsg.c 文件
B.添加 LogMsg.h 文件
3.3 代码修改 LogMsg.c
+++ b/ LogMsg.c @@ -0,0 +1,23 @@ +#include " LogMsg.h" +#include " LogMsg.tmh" + + +#define DBG_LEN 512 +#define WHERESTR "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8584b931d9bc1219499d77549c567f10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/186544a708d085a3fe5a1d20334ed765/" rel="bookmark">
			高清人脸数据集—FFHQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FFHQ全称Flickr-Faces-Hight-Quality（Flickr-Faces-HQ）是英伟达作为生成对抗网络（GAN）的基准创建的，也用于Style GAN的训练数据集中，于2019年开源。FFHQ是一个高质量的人脸数据集，包含1024x1024分辨率的70000张PNG格式高清人脸图像，在年龄、种族和图像背景上丰富多样且差异明显，在人脸属性上也拥有非常多的变化，拥有不同的年龄、性别、种族、肤色、表情、脸型、发型、人脸姿态等，包括普通眼镜、太阳镜、帽子、发饰及围巾等多种人脸周边配件，因此该数据集也是可以用于开发一些人脸属性分类或者人脸语义分割模型的。FFHQ的图像从Flickr上爬取，且均有许可才会下载，并使用了dlib进行人脸对齐和裁剪，之后使用算法移除了一些非真实人脸如雕像、画作及照片等图像。
Flickr [1-2] ，雅虎旗下图片分享网站。为一家提供免费及付费数位照片储存、分享方案之线上服务，也提供网络社群服务的平台。其重要特点就是基于社会网络的人际关系的拓展与内容的组织。这个网站的功能之强大，已超出了一般的图片服务，比如图片服务、联系人服务、组群服务。
FFHQ高清人脸数据集主要存储于谷歌云盘。
数据集统计分析：
对于需要单独训练和验证集的用例，指定了前 60,000 张图像用于训练，其余 10,000 张图像用于验证。 然而，在 StyleGAN 论文中，使用了所有 70,000 张图像进行训练。
已经明确确保数据集中没有重复的图像。 但是，请注意，如果从同一图像中提取了多个不同的人脸，则 in-the-wild 文件夹可能包含同一图像的多个副本。
可以直接从 Google Drive 获取数据，也可以使用提供的下载脚本。 该脚本通过自动下载所有请求的文件、验证它们的校验和、在出错时多次重试每个文件以及使用多个并发连接来最大化带宽，使事情变得更加容易。
&gt; python download_ffhq.py -h usage: download_ffhq.py [-h] [-j] [-s] [-i] [-t] [-w] [-r] [-a] [--num_threads NUM] [--status_delay SEC] [--timing_window LEN] [--chunk_size KB] [--num_attempts NUM] Download Flickr-Face-HQ (FFHQ) dataset to current working directory. optional arguments: -h, --help show this help message and exit -j, --json download metadata as JSON (254 MB) -s, --stats print statistics about the dataset -i, --images download 1024x1024 images as PNG (89.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/186544a708d085a3fe5a1d20334ed765/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10d7c4b2af462ed424b431c459af392a/" rel="bookmark">
			程序员视角m1 Macbook air使用指南和指令备忘录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		m1 Mac使用指南指令备忘录 硬件外设外接显示器HiDpi homebrew必备网站软件推荐Parallels DesktopSiliconBobIINAiterm2远程 mysql和redis启动OhMyZsh设置磁盘读写查询tensorfow安装配置python环境在虚拟环境安装 TensorFlow 未完待补充 M1用到现在也小半年了，踩了些坑，也有一些使用心得，这里主要提供思路方法，具体方法可以自行搜索了解 硬件外设 首先是用的Macbook air丐版8+256
显示器，HKC的C299Q，看中它长屏方便剪辑和分屏，90%的DCI-P色域看电影还行，不打游戏所以VA的曲面屏还是挺合适键盘，将就用之前ipad配的逻辑K380鼠标，罗技M720硬盘，在家组了个NAS，4T用来放电影和剪辑素材之类的大文件拓展坞，飞利浦的五合一Type-c+Hdim1.4+3*USB3.0基本满足需求。Ipad air3随航当拓展屏很好用 外接显示器HiDpi 强制开启Hidpi
有条件上4k显示器的当然最好，接上显示器就会出现调节界面，主要针对非4K屏幕
hidpi是macos优化显示效果的一种技术，需要硬件达到视网膜屏幕标准，具体技术可以自行了解，主要问题是非4k比如我现在用的带鱼屏1080*2560会出现字体发虚的情况
参考国外一个大神软件虚拟显示器的方法
BetterDummy
主要方法是通过软件虚拟一个支持hidpi的显示器，再把这个显示器投到自己的上面。带鱼屏的话注意选21.5:9，21.3:9是没Hidpi的。
系统需要更新到Monetery
homebrew homebrew是Mac上一个软件管理工具，可以理解为开源Appstore，直接brew install即可安装指定软件，最好安装前先用Brew search查询是否存在对应版本
export HOMEBREW_BREW_GIT_REMOTE="..." # put your Git mirror of Homebrew/brew here export HOMEBREW_CORE_GIT_REMOTE="..." # put your Git mirror of Homebrew/homebrew-core here /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)" 必备网站 Is apple Silicon ready？对应软件官方是否已经适配m1平台
MacWk一个免费的破解软件下载网站m1游戏适配情况介绍游戏在不同环境下运行情况，点进去有详细测评
软件推荐 Parallels Desktop Silicon Bob IINA iterm2远程 Iterm2比Mac自带terminal更好用，装机必备软件之一
cmd+O调出profile 保存帐号-&gt;cmd+option+F 调出password manage保存密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10d7c4b2af462ed424b431c459af392a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f23d61daa9a152d247df0bf8f64e6a9c/" rel="bookmark">
			C#实现MODBUS TCP 通信基础理论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Modbus由MODICON公司于1979年开发，是一种工业现场总线协议标准。1996年施耐德公司推出基于以太网TCP/IP的Modbus协议：ModbusTCP。Modbus协议是一项应用层报文传输协议，包括ASCII、RTU、TCP三种报文类型。标准的Modbus协议物理层接口有RS232、RS422、RS485和以太网接口，采用master/slave方式通信。
ModbusTCP的数据帧可分为两部分：MBAP+PDU。
MBAP为报文头，长度为7字节，组成如下：事务处理标识+协议标识+长度+单元标识符（2字节+2字节+2字节+1字节） ，通俗理解：MODBUS通信的数据内容开头部分，必须有7个字节，而且有固定规律。
MBAP各组成部分详细解释：
1.事务处理标识：可以理解为报文的序列号，一般每次通信之后就要加1以区别不同的通信数据报文。（可以固定为0x00 0x00,也可以是其他的，或者随机都可以，新学人员建议固定采用0x00 0x00，便于理解）
2.协议标识符：00 00表示ModbusTCP协议。（固定的，不可变）
3.长度：表示接下来的数据长度，单位为字节。（具体数据为：单元标识符+功能码+数据内容，是可变的但有规律）
4.单元标识符:可以理解为设备地址。（可以默认为0x01，可以固定）
PDU为数据内容(想要发送的消息内容)：由功能码+数据内容组成。
功能码：功能码为1字节，数据长度不定，由具体功能决定。分别对应四种操作对象：线圈、离散输入、保持寄存器、输入寄存器。
根据操作对象以及是读还是写等动作，Modbus的功能码有：
0x01：读线圈
0x05：写单个线圈
0x0F：写多个线圈
0x02：读离散量输入
0x04：读输入寄存器
0x03：读保持寄存器
0x06：写单个保持寄存器
0x10：写多个保持寄存器
由此可以确定，功能码的内容只能是上面8个内容中的一个。
数据内容：即具体的通信内容（字节长度可变，不固定），这部分我们由示例来进行讲解
示例1：读线圈
具体的结构组成如下：
请求：MBAP 功能码 起始地址H 起始地址L 数量H 数量L（共12字节）
响应：MBAP 功能码 数据长度 数据（一个地址的数据为1位）
如：在从站0x01中，读取开始地址为0x0002的线圈数据，读0x0008位
00 01 00 00 00 06 01 01 00 02 00 08
回：数据长度为0x01个字节，数据为0x01，第一个线圈为ON，其余为OFF
00 01 00 00 00 04 01 01 01 01
具体拆分开分析上面的内容：
请求内容：00 01 00 00 00 06 01 01 00 02 00 08
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f23d61daa9a152d247df0bf8f64e6a9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70fa9b1235efb75aab5ba6ce0d24eeb6/" rel="bookmark">
			【微信聊天机器人】基于python实现的PC端个人微信聊天机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、运行环境二、使用步骤1.引入库2.根据文本内容自动生成回复3.接收消息的回调函数4.启动客户端5.程序入口 三、代码全文总结 前言 微信自动回复、聊天机器人应该是一个很多人迫切需要的功能（如时间管理大师），网上能搜到的大多解决方案是采用2018年之前的基于Web版微信的itchat或wxpy第三方库，但现在申请注册比较晚的微信号无法登录Web版微信，故上述两个库均已失效。还有一些需要注入dll手段的，操作比较麻烦不适合新手。
本文用python提供一种解决方案初代版本，只需调包，无需对系统进行其他操作，可根据自身需要定制内容。
温馨提示：仅供娱乐，请谨慎使用，由自身使用不当引起家庭矛盾、跟上级领导关系不和等各种不良后果，本文作者概不负责。
该机器人支持天气查询、成语接龙、彩虹屁等功能，可在天行控制台进行定制。
效果展示：
提示：以下是本篇文章正文内容，下面案例可供参考
一、运行环境 Windows10+python 3.7.4+PC端微信V2.7.1.82版本+PyCharm/VS2017
提示：python版本一定要是3.7及以后;微信版本目前仅支持V2.7.1.82版本
PC端微信V2.7.1.82版本安装包百度网盘下载 链接：https://pan.baidu.com/s/1yADEwqht8hcTTjxpkW8DXw 提取码：rneo 二、使用步骤 1.引入库 代码如下（示例）：
from WechatPCAPI import WechatPCAPI import time import http.client, urllib 所用库的说明和下载地址：
https://github.com/terrywangt/WeChatBot
https://www.tianapi.com/apiview/47
第二个网址为天行公司的网址，免费申请注册可以获得接口，有示例代码
2.根据文本内容自动生成回复 代码如下（示例）：
# #生成回复内容的函数，传入的是接收到的字符串，返回值为回复str def send_msg_producer(content): conn = http.client.HTTPSConnection('api.tianapi.com') # 接口域名 params = urllib.parse.urlencode({'key': '你在天行网站上申请获得的APIKEY', 'question': content}) headers = {'Content-type': 'application/x-www-form-urlencoded'} conn.request('POST', '/robot/index', params, headers) res = conn.getresponse() data = res.read() str_data = data.decode('utf-8') # 报文解码返回值为str，转为dict再操作 dict_data = eval(str_data) out_content = dict_data['newslist'][0]['reply'] #将要回复消息读取出来，作为返回值 return out_content 该函数传入的参数content为你对机器人的提问，str类型（也就是微信收到的新消息字符串）；返回值为机器人根据上文自动生成的回复，str类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70fa9b1235efb75aab5ba6ce0d24eeb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/146efff87f38de10b5873ad9117547c5/" rel="bookmark">
			wireshark：时区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你从世界各地的某个地方得到一个捕获文件，那时区怎么处理呢？
其实，根本就无需担心时区问题，有两个原因：
您只对数据包时间戳之间的时间差感兴趣，而不需要知道捕获的数据包的确切日期和时间（通常的情况）你不能从不同的时区获取不同时区的捕获文件，所以根本就没有时区问题。例如，团队中的每个人都与您在同一时区工作。 什么是时区
人们期望时间能够反映日落。比如黎明应该在早上6:00左右，黄昏应该在晚上20:00左右。这些时间显然会因季节而异。如果地球上的每一个人都使用相同的全球时间，而这只对应于世界上一小部分地区的太阳，那将是非常令人困惑的。
因此，地球被分成几个不同的时区，每个时区都有一个与当地日落相对应的当地时间。
该时区的基准时间是UTC(协调世界时)或祖鲁时间(军事和航空时间)。不应该使用旧的GMT(格林威治标准时间)，因为它有一点错误(与UTC相差0.9秒)。UTC基准时间等于0(基于英国格林威治)，所有时区与UTC的时差在-12到+14小时之间!
例如:如果你住在柏林，你所在的时区比UTC早一个小时，所以你所在的时区是“+1”(与UTC的小时差)。如果柏林的时间是3点钟，那么在同一时刻，UTC的时间是2点钟。
请注意，在地球上的一些地方，甚至没有小时偏移的时区(例如新德里使用UTC+05:30)!
夏令时(DST)是什么
夏令时(DST)，也被称为夏季时间，旨在“节省”一些日光在夏季月份。为了做到这一点，许多国家(但不是所有国家!)在现有的UTC偏移量上添加一个DST小时。因此，您可能需要在“时区计算”中再花一个小时(在非常罕见的情况下甚至是两个小时!)
不幸的是，DST实际生效的日期在世界各地是不同的。你可能还会注意到，北半球和南半球的夏令时是相反的(例如，欧洲是夏天，澳大利亚是冬天)。
请记住:UTC全年保持不变，与夏令时无关!
正确设置计算机时间
如果你和世界各地的人一起工作，把你的电脑的时间和时区设置成正确是很有帮助的。
你应该按照正确的顺序设置计算机的时间和时区：
将时区设置为当前位置将计算机的时钟设置为本地时间 这样你就可以告诉你的计算机本地时间和UTC的时间偏移量。很多组织只需要将服务器上的时区和网络设备设置为UTC，以便更轻松的进行协调和故障排除、
你可以使用网络时间协议(NTP)自动将计算机调整到正确的时间，方法是将计算机与internet NTP时钟服务器同步。
那，wireshark与时区有什么关系呢？
wireshark的原生捕获文件格式(libpcap格式)和其他一些捕获文件格式，比如windows sniffer、sun snoop等格式，会将报文的到达时间保存为UTC值。unix、windows等系统在内部将时间表示为UTC。当wireshark捕获时，不需要转换。然而，如果系统时区设置不正确，系统的UCT时间可能设置不正确，即使系统时钟显示正确的本地时间。当捕获时，Npcap必须在提供给Wireshark之前将时间转换为UTC。如果系统时区设置不正确，该转换将无法正确完成。
其他捕获文件格式，如基于oos的Sniffer格式和旧版本的Microsoft Network Monitor和Network Instruments/Viavi Observer格式，将数据包的到达时间保存为本地时间值。
在Wireshark内部，时间戳用UTC表示。这就意味着，Wireshark在读取捕获文件时，将报文到达时间保存为本地时间值，必须将这些本地时间值转换为UTC时间值。
然后，Wireshark会始终以本地时间显示时间戳。显示计算机将它们从UTC转换为本地时间并显示此(本地)时间。对于将数据包的到达时间保存为UTC值的捕获文件，这意味着到达时间将显示为您所在时区的当地时间，这可能与捕获数据包所在时区的到达时间不相同。对于保存数据包到达时间为本地时间值的捕获文件，到UTC的转换将使用您的时区与UTC和DST规则的偏移量来完成，这意味着转换将不会正确完成;转换回本地时间进行显示可能会正确地取消此操作，在这种情况下，到达时间将显示为数据包被捕获时的到达时间。
例如，假设洛杉矶的某个人在当地时间2点整用Wireshark捕获了一个数据包，并将这个捕获文件发送给您。捕获文件的时间戳将在UTC中表示为10点。您位于柏林，将在Wireshark屏幕上看到11点。
现在你有一个电话，视频会议或互联网会议与那个人谈论那个捕获文件。当你们都在看本地电脑上显示的时间时，在洛杉矶的那台仍然是2点，而在柏林的那台将是11点。时间显示是不同的，因为两种Wireshark显示的是同一时间点的(不同的)本地时间。
结论：除非您必须确保日期/时间与预期一致，否则您不用担心当前查看的时间戳的日期/时间。因此，如果您从不同的时区和/或DST获取捕获文件，则必须找出两个本地时间之间的时区/夏令时差，并相应地“心理调整”时间戳。无论如何，请确保每台有问题的计算机都有正确的时间和时区设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec3f09a0af1a146edbe7e280652c415/" rel="bookmark">
			wireshark：时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当数据包被捕获时，每个数据包在进入的时候都打上了时间戳。这些时间戳将被保持到捕获文件中，因此它们也将用于（以后分析）。
那么这些时间戳是从哪里来的呢？在捕获过程中，wireshark从libpcap(npcap)库获取时间戳，而后者又从操作系统内核获取时间戳。如果捕获数据是从捕获文件加载的，wireshark会从这个文件里获取时间戳。
内部构件 Wireshark用来保存数据包时间戳的内部格式包括日期（从1970年1月1日起以天为单位）和一天中的时间（从午夜开始以纳秒为单位）。您可以调整Wireshark在数据包列表中显示时间戳数据的方式：
wireshark在读写抓包文件时，根据需要将抓包文件格式和内部格式之间的时间戳数据进行转换。
在捕获时，wireshark使用支持微秒分辨率的libpcap(npcap)捕获库。除非您使用专门的捕获硬件，否则这个分辨率应该足够了。
捕获文件格式 wireshark支持的每个捕获文件格式都支持时间戳。特定捕获文件格式所支持的时间戳精度差别很大，从1秒(0）到1纳秒(0.123456789)不等。大多数文件格式以固定的精度(比如微秒)存储时间戳，而有些文件格式甚至能够存储时间戳精度本身。
wireshark使用的libpcap捕获文件格式只支持固定的微秒分辨率（0.123456）
将数据写入无法存储实际精度的捕获文件格式将导致信息丢失。比如，如果加载纳秒分辨率的捕获文件并将捕获数据存储在alibpcap文件（微秒分辨率）中，wireshark显然必须将精度从纳秒降低到微秒。
准确度 那么，wireshark提供的时间精确度是多少呢？ 其实，wireshark本身不会创建任何时间戳，只是简单的从“其他地方”获取并显示它们。因此，准确性将取决于你使用的捕获系统（操作系统、性能等）。一般来说，这是一个很难回答的问题。
注意：USB连接的网络适配器通常提供非常差的时间戳准确度。他们要走很长的路才能到达“U盘”。由于传入的数据包在内核处理时会加上时间戳，所以这个时间戳机制将变得非常不精确。因此，当你需要精确的时间安排时，不要使用UDB连接的网卡
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b5559913d1522b3f5a4e3599bdae84/" rel="bookmark">
			1038 统计同成绩学生 (20 分)（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Notice Hash散列 #include &lt;iostream&gt; using namespace std; int a[110] = {0}; //开一个Hash表，记录各个分数的人数 int main (){ int n,k,score; cin &gt;&gt; n; for(int i = 0;i &lt; n;i++){ //cin &gt;&gt; score; scanf("%d",&amp;score); //输入改为scanf可以缩短耗时 a[score]++; } cin &gt;&gt; k; for(int i = 0;i &lt; k;i++){ // cin &gt;&gt; score; scanf("%d",&amp;score); if(i != 0)cout &lt;&lt; " "; // cout &lt;&lt; a[score]; printf("%d",a[score]); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deba9bd31e754ceeb3ebfea71810b1ad/" rel="bookmark">
			mmcv/_ext.cpython-36m-x86_64-linux-gnu.so: undefined symbol: _ZN6caffe28Type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /mmcv/_ext.cpython-36m-x86_64-linux-gnu.so: undefined symbol: _ZN6caffe28TypeMeta21_typeMetaDataInstanceISt7complexIdEEEPKNS_6detail12TypeMetaDataEv
mmcv-full版本和pytorch不匹配
先卸载之前的版本
pip uninstall mmcv-full安装新的
pip install mmcv-full -f https://download.openmmlab.com/mmcv/dist/cu101/torch1.8.1/index.html
确认cuda版本，上面是cuda=10.1, torch=1.8.1
可以用nvcc -v确认cuda版本,（如果和nvidia-smi版本不一样，选择nvcc的cuda版本），
pip list | grep torch确认torch的版本 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11d9adf3dca5b4117cc9c1596835a171/" rel="bookmark">
			Pandas中DataFrame常用函数和功能简介（适用于高中信息技术新教材）持续更新中……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 获取DataFrame的行数和列数 df为DataFrame一个变量实例
行数：df.shape[0] 或 len(df)
列数：df.shape[1] 或 (len(df.columns))
写入csv文件中header和index参数的作用 DataFrame.to_csv(path_or_buf,sep,na_rep,columns,header,index,index_label,mode,encoding)
参数类型说明path_or_buf字符串文件路径+文件名sep字符串分隔符 默认为","na_rep----------columns----------headerbool类型header=True(默认) 把原字段名写入文件，header=False 不把原字段名写入文件indexbool类型index=True(默认) 把原行名（索引）写入文件，index=False 不把原行名（索引）写入文件index_label----------mode----------encoding特定字符串“UTF-8” “GBK” “GB2312” “ANSI” 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03990533554d595c9cae0bdf78212844/" rel="bookmark">
			人脸检测&#43;识别---06人脸截取（OpenCV&#43;PyCharm适用于高中信息技术新教材）持续更新中……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		06人脸截取 人脸截取是指，在图像上用矩形标记出人脸后，将矩形区域保存为另一个文件。若图像中有标记出多张人脸，则将每张人脸保存为一个文件。
import cv2 # 导入opencv库 def face_intercept_demo(img): gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) face_detect=cv2.CascadeClassifier("./venv/Lib/site-packages/cv2/data/haarcascade_frontalface_default.xml") faces=face_detect.detectMultiScale(gray,1.1,5) if len(faces)&gt;0: # 大于0则检测到人脸 cropped=[] # 空列表，存储每张人脸的坐标 for face in faces: x,y,w,h=face cv2.rectangle(img, (x, y), (x + w, y + h), color=(0, 0, 255), thickness=2) # 框出人脸 cropped.append(img[y:y+h,x:x+w]) # 截取的坐标范围为[y0:y1, x0:x1] cv2.imshow("result", img) for i in range(len(faces)): cv2.imshow("InterceptFace" + str(i + 1), cropped[i]) # 显示需截取的人脸 if cv2.waitKey(0) == ord("s"): # 等待按下小写字母s键，执行保存截取的人脸图像 for i in range(len(faces)): cv2.imwrite("./faces"+str(i+1)+".png", cropped[i]) img = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03990533554d595c9cae0bdf78212844/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb1fef6eaa853a24bdb460b1c930688/" rel="bookmark">
			数据库学习笔记（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据库基本概述
1、数据库的好处
2、数据库的相关概念
3、数据库存储数据的特点
4、MySQL
5、MySQL服务的启动和终止
6、MySQL服务的登录和退出
7、MySQL的常见命令
8、mySQL的语法规范
二、DQL语言的学习
1、基础查询
2、基础查询操作
3、条件查询
一、数据库基本概述 1、数据库的好处 &gt;持久化数据到本地
&gt;可以实现结构化查询，方便管理
2、数据库的相关概念 &gt;DB(database):数据库。存储数据的“仓库”,它保存了一系列有组织的数据。
&gt;DBMS(Database Management System):数据库管理系统。数据库是通过DBMS创建和操作的容器。
常见的数据库管理系统：MySQL、Oracle、DB2、SqlServer等
&gt;SQL(Structure Query Language):结构化查询语言。专门用来与数据库通信的语言。
SQL的优点：
①不是某个特定数据库供应商专有的语言，几乎所有DBMS都支持SQL;
②简单易学；
③虽然简单，但实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。
3、数据库存储数据的特点 ①将数据放到表中，表再放到库中；
②一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性；
③表具有一些特性，这些特性定义了数据在表中如何存储，类似java中“类”的设计；
④表由列组成，我们也称为字段。所有表都是由一个或者多个列组成的，每一列类似java中的“属性”；
⑤表中的数据是按行存储的，每一行类似于java中的“对象”；
4、MySQL &gt;优点：
①成本低：开放源代码，一般可以免费试用
②性能高：执行很快
③简单：很容易安装和使用
5、MySQL服务的启动和终止 方式一：计算机---右击管理---服务
方式二：通过管理员身份运行
net start 服务名（启动服务）
net stop 服务名 （停止服务）
6、MySQL服务的登录和退出 方式一：通过mysql自带的客户端（只限于root用户）
方式二：通过Windows自带的客户端
登录：
mysql 【-h主机名 -P端口号 】-u用户名 -p密码
退出：
exit或ctrl+c
7、MySQL的常见命令 &gt;查看当前所有数据库
show databases;
&gt;打开指定的库
use 库名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb1fef6eaa853a24bdb460b1c930688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/688a66352eca248891a5313e834457cb/" rel="bookmark">
			Python列表数据按区间分组统计各组个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需求描述 今天遇到一个问题，就是有一个列表数据，划分一个固定区间，统计每个区间数量。
解决方案 使用 groupby() 函数
from itertools import groupby score_list = [6.3, 1.2, 6.2, 5.6, 9.5, 1.6] step = 1 for k, g in groupby(sorted(score_list), key=lambda x: x//step): print('{}-{}: {}'.format(k*step, (k+1)*step+1, len(list(g)))) 分组效果
1.0-3.0: 2 5.0-7.0: 1 6.0-8.0: 2 9.0-11.0: 1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/081ca33c6d7a600e046e921d0473008f/" rel="bookmark">
			区块链的隐私保护问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、关于交易的隐私： 比特币而言：是有一个很好的保护的，因为地址经过了非对称加密算法的加密，
对于交易而言：是公开透明了，没有隐私保护，导致有一些领域是没有办法接收交易信息透明的。
2、关于个人隐私：也不是很好
有区块链服务提供者解决方法：
欧盟保护法《通用数据保护条例》一旦有用户的个人信息上链，区块链服务的提供者必须保证用户数据的隐私性。
如果没有提供者：
没有提供者的区块链的性能还是存在问题的，如果别人以一条交易信息的附加消息的方式把个人信息写入区块链中，那么就没有人能删除这条信息，不可篡改。
没有提供者常用解决方法：
1、同态加密：对密文直接进行处理，与对明文进行处理后再加密后得到的结果相同。
四种类型：加法，减法，乘法，除法
F(A) + F(B) = F(A+B)
在于金融转账交易是，整个过程中数据，包括区块链账本纪录的数据都是处于加密的装态的，只有持有对应客户端私钥的人能看到，其他人只能看到加密后的交易信息，从而提高隐私性。
2、零知识证明技术的数字货币：（不向验证者提供任何有用的信息的情况，使验证者相信某个结论是正确的）
零知识证明相关的技术来完成加密后的交易的有效验证，结合同态加密，可以完成一个完整的隐私保护和校验流程。
注意：大零币是第一个成功的零知识证明技术的商业应用，
3、其他隐私保护技术：
1.群签名：
验证利用群公钥来验证签名信息的正确性，但是不能确定时群中的哪一个人进行的签名。
（就比如XXX班，拿这个标签进行签名）
2.环签名：
一个成员利用他的私钥和其他成员的公钥进行签名，但是不需要征得其他成员的同意，所以验证者只能知道签名来自这个环，但是不知道谁是真正的签名者。
3.可信执行环境：
也能够用在隐私保护领域
可以为区块链中密钥保护提供硬件级别的能力。
也可以让密文在这个环境下解密得到明文，然后操作明文，在这个过程中不担心泄露信息的问题，也可以保护隐私问题，
4、区块链系统应该给用户足够的安全及隐私保护提示。提高用户安全意识。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18a57c9e59bbcaa09e17befc363b3c74/" rel="bookmark">
			我用Python爬取英雄联盟的皮肤，隔壁家的小弟弟都馋哭了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、推理原理 1.先去《英雄联盟》官网找到英雄及皮肤图片的网址：
lol.qq.com/data/info-h…
2.从上面网址可以看到所有英雄都在，按下F12查看源代码，发现英雄及皮肤图片并没有直接给出，而是隐藏在JS文件中。这时候需要点开Network，找到js窗口，刷新网页，就看到一个champion.js的选项，点击可以看到一个字典——里面就包含了所有英雄的名字（英文）以及对应的编号。
3.但是只有英雄的名字（英文）以及对应的编号并不能找到图片地址，于是回到网页，随便点开一个英雄，跳转页面后发现英雄及皮肤的图片都在，但要下载还需要找到原地址，这是鼠标右击选择“在新标签页中打开”，新的网页才是图片的原地址。
4.图中红色框就是我们需要的图片地址，经过分析知道：每一个英雄及皮肤的地址只有编号不一样（ossweb-img.qq.com/images/lol/…
二、推理代码 第一步：获取js字典 def path_js(url_js): res_js = requests.get(url_js, verify = False).content html_js = res_js.decode("gbk") pat_js = r'"keys":(.*?),"data"' enc = re.compile(pat_js) list_js = enc.findall(html_js) dict_js = eval(list_js[0]) return dict_js 复制代码 第二步：从 js字典中提取到key值生成url列表 def path_url(dict_js): pic_list = [] for key in dict_js: for i in range(20): xuhao = str(i) if len(xuhao) == 1: num_houxu = "00" + xuhao elif len(xuhao) == 2: num_houxu = "0" + xuhao numStr = key+num_houxu url = r'http://ossweb-img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18a57c9e59bbcaa09e17befc363b3c74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68b8d421ef4b6fab4a2bacb51838c166/" rel="bookmark">
			72 函数参数——位置参数（必备参数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、数量必须和定义时一致2、位置必须与定义时一致抛出TypeError异常产生的结果与预期不符 3、正确调用 位置参数也称必备参数，是必须按照正确的顺序传到函数中，即调用时的数量和位置必须和定义时是一样的。 1、数量必须和定义时一致 在调用函数时，指定的实际参数的数量必须与形式参数的数量一致，否则将抛出TypeError异常，提示缺少必要的位置参数。
从异常信息中可以看出，抛出的异常类型为TypeError，具体是指“fun_bmi()方法缺少一个必要的位置参数weight”。
2、位置必须与定义时一致 在调用函数时，指定的实际参数的位置必须与形式参数的位置一致，否则将产生以下两种结果。
抛出TypeError异常 抛出异常的情况主要是因为实际参数的类型与形式参数的类型不一致，并且在函数中，这两种类型还不能正常转换。
产生的结果与预期不符 在调用函数时，如果指定的实际参数与形式参数的位置不一致，但是它们的数据类型一致，那么就不会抛出异常，而是产生结果与预期不符的问题。
由于调用函数时，传递的实际参数的位置与形式参数的位置不一致时，并不会总是抛出异常，所以在调用函数时一定要确定好位置，否则产生Bug，还不容易被发现。
3、正确调用 调用时，数量和位置一定要和函数定义时一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a059faa09fc7e4d4696f54540746fc4e/" rel="bookmark">
			自动写代码?Copilot尝鲜及其奇技淫巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动写代码?Copilot尝鲜及其奇技淫巧 博主在同学那里了解到Copilot这个神奇的项目，听说能自动帮你写代码，顿时来了性质，从现在起，我不再写代码，我要搭载Copilot起飞🛫
1. Copilot下载申请 VSCode大法好，拓展商店搜索Copilot下载即可
这里要注意下载后会让你申请，好像目前处于内测还是公测版本……跟着点点申请就好了：
2. Copilot使用说明 一般来说，获得Copilot使用权后，右下角就有个小飞行员的图标
然后你每在VSCode里敲击，就会触发Copilot的运行，按Tab就可以自动填补生成的文字了🛫
3. 奇技淫巧 这是今天才发现的，按下ctrl + enter后，发现这样的好东西：
这个东西换个用法，例如用来写英文论文：
哈哈，还蛮有趣的。
4. 使用Copilot应该注意的问题 Copilot项目版权是个很严重的问题，这个问题不解决Copilot应该永远无法用于生产环境，不过对于我们平时Coding玩玩、做些外包小项目、日常学习等，Copilot还是能够让我们事半功倍。
不多说了，马上用Copilot起飞🛫🛫🛫
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c0847ec6f13d60a11171417733ed7d2/" rel="bookmark">
			三大运营商实现本机号码一键登录原理与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多内容关注微信公众号：fullstack888 很多APP的目前都支持“本机号码一键登录”功能。本机号码一键登录是基于运营商独有网关认证能力推出的账号认证产品。用户只需一键授权，即可实现以本机号码注册/登录，相比先前的短信验证码流程体验更优。
目前市面上有很多厂商提供三网验证的服务，只不过是对三大运营商的包装。要了解具体的原理可直接看三大运营商相关的介绍。
中国移动
中国移动号码认证服务支持移动、联通、电信三网号码。主要产品功能：
一键登录：依托运营商的移动通信网络，采用通信网关取号技术，准确识别用户流量卡归属的手机号码。在获得用户授权后，App端（适配iOS和Android）可使用本机号码实现一键免密登录。
本机号码校验：通过SDK/JSSDK提供的本机号码校验功能，调用网关鉴权方式，验证用户输入的手机号码或后台绑定的手机号码是否为本机流量卡归属号码，保证机卡不分离，用于快捷登入和安全风控等场景。本机号码校验现已适配iOS、Android、H5、小程序、快应用。
获取手机号码（一键登录）：
本机号码校验：
取号方法
通过调用安卓的getPhoneInfo或iOS的getPhoneNumberCompletion，在用户无感知的情况下进行网络判断、蜂窝数据网络切换和网关取号等操作（以上操作均需消耗一定时间），返回取号是否成功的结果。
取号所需网络环境：运营商取号能力是通过数据网关实现，取号过程须在数据流量打开的情况下才能进行。因此，用户如果关闭数据流量将无法取号；若当前信号弱或者网络有干扰时，时延会高于平均值，取号成功率降低。
超时设置：SDK默认超时设置为8000ms，同时提供设置取号超的方法：安卓通过setOverTime设置，iOS通过setTimeoutInterval设置。
运营商判断：SDK提供判断用户当前网络状态和流量卡所属运营商的方法，通过调用安卓SDK的getNetworkType或iOS的networkInfo可获得以上信息，以便对不同用户选择不同的运营商的SDK进行取号或选择不同的登录方式。
关于取号缓存：应用取号或者授权成功后，SDK将取号的一个临时凭证缓存在本地，缓存能有效提高取号成功率、降低时延，并允许用户在未开启蜂窝网络时成功取号。SDK本身对缓存有处理逻辑，在某些场景下（如换卡）会让缓存提前失效，但若应用对安全性要求较高，也可以通过SDK提供的方法（安卓的delScrip和iOS的delectScrip）让缓存马上失效。
本机号码校验
通过调用安卓的mobileAuth或iOS的mobileAuthCompletion方法，可在不拉起授权页的情况下获得token。此时获得的token不能用于兑换用户的完整号码，只能用于校验本机号码与待校验号码的一致性。
预取号：安卓的getPhoneInfo或iOS的getPhoneNumberCompletion所形成取号缓存scrip同样适用于本机号码校验，可提前进行取号以提高后续获取token的效率。
适用场景：可在用户无感知的情况下校验本机号码与待校验号码的一致性，适用于所有基于手机号码进行风控的场景。
中国电信 中国电信天翼账号开放平台提供了：免密登录、手机号码认证、二次卡校验等服务。目前只支持中国电信用户。
免密认证：天翼账号免密认证方案，依托运营商的移动数据网络，采用“通信网关预登录”及 SIM卡识别等技术，准确识别用户手机号码，实现一键登录，并可有效规避短信验证码泄露风险。
手机号码校验：确认本机号码信息是否为当前用户本机号码。依托运营商的移动数据网络，采用“通信网关预登录”及 SIM卡识别等技术，判断用户输入的手机号与本机号码是否一致。
二次卡校验：众所周知，三大运营商每月注销的手机号约有2000多万，为避免手机号资源浪费，运营商会先回收已注销的手机号，然后重新销售，重新销售的卡即为二次卡。如果用户更换了手机号，且未与原账号解绑，可能存在安全风险。天翼账号二次卡校验方案， 使用独有的运营商二次号数据库，可快速检测用户号码更换状态，保障号码旧用户隐私安全。
中国联通
中国联通通信创新能力平台提供了号码认证（一键登录）、匿名设备标识、匿名用户标识、空号识别、二次号验证、三要素验证等服务。
号码认证
依托运营商网关认证能力，面向互联网应用提供的本机手机号码一键注册登录及本机手机号码校验服务，支持APP、H5页面多场景应用。官方SDK，支持联通、移动、电信三网，智能化程度高，交互时间短，提升用户体验、提高拉新转化率;专利技术，性能可靠，降低空号注册登录、密码拦截盗取风险。
应用场景：
一键登录
APP一键登录。手机在有蜂窝信号的环境中（若WIFI接入，SDK可瞬间切换至蜂窝信号再切回)，可自动获取手机号码，帮助用户实现一键验证快捷登录，无需手动输入号码和短信验证，有利于提升用户体验，提高登录安全性。
H5一键登录。适用于手机接入蜂窝信号时，H5页面登录场景，用户只需输入4位本机号码即可实现快捷登录，减少登录等待时间。
本机校验。自动校验用户手机号与当前本机卡号的一致性，免输登录密码或短信验证码;适用于如手机号绑定、支付确认、积分兑换等需要具备安全校验能力的业务场景，提供仅限本机操作的安全风控机制。支持有蜂窝信号环境下的APP及正在使用蜂窝信号下的H5。
匿名设备标识
通过识别移动设备唯一ID，为客户提供基于用户和设备的标识方案，支持IOS和安卓系统，不依赖设备厂商，具备稳定性和唯一性，可关联安卓设备资产数据，帮助企业找回历史关联资产，实现基于用户画像的精准投放，有效识别设备篡改和营销作假，防止薅羊毛，避免金融风险等。
应用场景：
风险识别：企业开展营销活动时，面对薅羊毛、黑产等，通过设备识别可有效识别判断参与用户，防止有限资源被无价值用户占用，支持APP/H5/小程序等全场景，覆盖安卓/IOS生态系统。适用于开展各类营销活动的企业，如电商、金融、游戏、生活等。
场景营销：企业可基于不同营销场景（APP/H5/小程序）下的用户标识，进行跨应用用户分析与画像生成，实现精准营销推送。适用于需分析用户偏好、阅读习惯的企业，如购物、新闻、视频、娱乐、阅读等.
匿名用户标识
通过手机用户的公私网IP返回唯一串码，可以在保护用户手机号不泄露的情况下，提供用户唯一标识（即伪码）方案。仅支持联通用户。
应用场景：
会员营销：会员营销活动时，用户领取会团优惠，平台方通过联通唯一识别平台将手机号转换成伪码供商户进行维系和发放。适用于入住商户无法获取平台用户手机号的场景。
空号识别
识别号码是否为真实有效的开机使用号码，对于不可达号码（例如关机、养卡等情况）采取相应的运营措施。识别过程一秒以内，支持大规模并发查询，且对用户无感知。帮助企业快速、高效、精准开展营销、维系等商业活动，减少营销成本。
应用场景：
外呼中心：用于外呼中心，回访或者推介产品之前先对用户手机状态进行有效识别，关机、离网及不在服务区用户免拨叫，节省人力物力。
存量用户维系：用于检测用户手机是否处于在网状态，便于企业精准开展后续营销活动。例如优惠券发放、权益下达等，为真实客户送权益，送利益。
注册用户清洗：对注册会员的号码进行检测，对短期内高频次的注册行为进行监控，对可疑号码进行监控，及时清理批量注册的垃圾用户和数据、被占用数据，将恶意注册用户拒之门外，防止“薅羊毛党”恶意套利现象。使用号码检测功能，可以减少企业客户的营销维护成本，保护真实用户的权益。
二次号验证
次号验证产品是指核验手机号码在指定时间之后是否重新开户。
应用场景：
注册/登录/密码找回：针对注册/登录/密码找回等场景，企业可通过使用联通二次号码验证产品识别当前注册登录号码是否为二次放号，从而避免二次放号用户使用原号码账号可能带来的用户隐私泄露和经济损失。
三要素验证
三要素验证产品提供联通用户的姓名、身份证号、手机号三要素的一致性核验服务。
应用场景：
实名认证：针对金融、婚恋等应用系统中的实名注册场景，企业可通过联通三要素验证产品识别用户身份真实性和信息一致性，有助于防范用户风险。
贷前审核：针对借贷、信用卡申请等金融场景，企业可以通过使用联通三要素验证产品识别申请用户信息真实度，助力用户风险评估和贷款决策。
- END -
推荐阅读：
为什么静态方法不好？
作业帮 PB 级低成本日志检索服务
ClickHouse特性及底层存储原理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c0847ec6f13d60a11171417733ed7d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71bfb65bd037720bfc9cc6f377e2cbe4/" rel="bookmark">
			Windows10关闭指定端口号命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看指定端口号是否被占用 win + R 输入 cmd 打开命令黑窗口输入命令： netstat -ano | findstr 端口号 当参数为LISTENING 时、说明此端口号正在被占用、需要手动关闭（LISTENING 后面的14444既是进程的PID号）。 手动关闭进程方法 方法一 打开任务管理器、选择详细信息、对 PID进行排序、然后找到端口号对应的PID号、手动结束掉。
方法二 运行命令进行强行终止指定进程号的进程： taskkill -PID 进程号 -F 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe1e59ed9036904ebb35a7f7531b95a7/" rel="bookmark">
			2021-11-31 防火墙的Web界面配置＋NAT访问外网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章仅供学习和参考！
欢迎交流~
目录
一、实验拓扑图：
二、实验要求：
1. 防火墙基础配置（基于命令行）：
2. 防火墙IP地址和安全区域配置（基于Web界面）：
3. 边界安全设备FW5配置路由可达（基于Web界面）：
4. 外网设备IP地址配置：
5. R6和R7-OSPF配置，RID=255.X.X.X，X为设备编号：
6.配置NAT让内网主机可以访问外网：
三、实验步骤：
1. 配置环回适配器（基于安全性原则）​
2. 配置Cloud1
3.配置客户端
（1）配置PC1
（2）配置PC2
（3）配置Client1
（4）配置Client2
4.配置服务器 （1）配置Server1
（2）配置Server2
5. 配置防火墙
6. 配置路由器
（1） 配置R1
（2）配置R2
（3）配置R3
（4）配置R4
（5）配置R6
（6）配置R7
一、实验拓扑图： 二、实验要求： 1. 防火墙基础配置（基于命令行）： （0）启动防火墙出现###五行左右正常显示登录界面后，如果五行###出现完还没有出现登录界面，请关闭eNSP再重新打开eNSP实验图； （1）设置eNSP的云（udp+GE点增加，本地网卡IP+GE点增加），通道 上1下2点勾双向通道，将防火墙的G0/0/0桥接到本地网卡所在的网络； （2）基于CLI命令行访问设备，第一次访问设备使用用户名=admin和密码=Admin@123进行登录，并需要修改密码=Admin@123456； （3）修改防火墙设备系统名=FW5，并设置登录设备后的超时时间=0分和0秒； （4）FW5-G0/0/0=192.168.100.2xx/24 安全区域属于Trust，其中xx为学号，例如：学号=36，则FW5-G0/0/0=192.168.100.236/24； （5）FW5-G0/0/0允许所有支持服务管理协议进行访问管理； （6）从本地PC的cmd下&gt;ping 192.168.100.2xx，结果应该是可以ping通，如果不通请进行故障排错； （7）从本地PC打开谷歌浏览器或火狐浏览器，输入192.168.100.2xx，在Web中是否有登录界面； （8）请用命令查看并填写Trust安全区域优先级=（ 85 ），untrust安全区域优先级=（ 5 ）,DMZ安全区域优先级=（ 50）,local安全区域优先级=（ 100 ）； 2. 防火墙IP地址和安全区域配置（基于Web界面）： （1）FW5-G1/0/0=192.168.5.1/24 安全区域属于Trust，仅允许服务管理ping/SNMP进行访问管理； （2）FW5-G1/0/1=192.168.45.5/24 安全区域属于Trust，允许除开NETCONF协议外的其他支持协议进行访问管理； （3）FW5-G1/0/2=192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe1e59ed9036904ebb35a7f7531b95a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a762c5f7ade1934504a8f3e91987b8c2/" rel="bookmark">
			Kinetics数据集下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kinetics数据集是行为识别中十分重要的benchmark，其地位相当于图像分类中的ImageNet。本人目前在做小样本行为识别，需要用到Kinetics-400数据集搭建Kinetics-100小样本行为识别数据集。由于种种原因，网上的数据集都有缺失，所以本人基于已经下载的数据集，使用youtube-dl下载缺失视频，仅供大家参考。
百度网盘 1、https://www.codeleading.com/article/23055974480/
该方法用了特定软件将数据集分割成132个小数据集，下载完成后需要使用cat命令完成拼接。对拼接的数据集解压，即可得到Kinetics-400。建议下载好后，在linux下拼接解压或者在windows下安装git bash。
2、https://github.com/PaddlePaddle/PaddleVideo/blob/develop/docs/zh-CN/dataset/k400.md
作者在文中介绍了两种方法，一种是百度网盘下载（数据和第一种方法不一样）；另一种使用脚本下载，需要下载官方的trainlist.csv和testlist.csv文件。
和第一种百度网盘方法不同的是，第二种每个子数据集都可以单独解压。不幸的是，第一种方法缺失的视频更多。
Activity https://www.codetd.com/article/5004295
使用youtube-dl工具，根据提供的唯一标识符youtu id下载视频。
1、下载爬取视频代码https://github.com/activitynet/ActivityNet.git
2、安装youtube-dl包
3、安装ffmpeg
注意：使用pip和conda装的ffmpeg会报以下错误
‘ffmpeg’ 不是内部或外部命令，也不是可运行的程序或批处理文件
需要去官网下载源码，解压后可以在bin目录下得到三个文件，如下图所示。
将"E:/ffmpeg/bin"写进环境变量，即可在命令行使用ffmpeg命令。
A. 下载好代码后，进入ActivityNet-master\ActivityNet-master\Crawler\Kinetics目录，准备一个csv文件data.csv，存储需要下载的视频youtube_id、视频开始时间、视频结束时间、后面两个参数不重要，可以直接写train和0。
python download.py data.csv dataset 但是直接运行这个代码频繁报错，各种错误，而且代码里是先下载原始视频，存储在tmp临时目录中，接着使用ffmpeg工具对视频长度裁剪，清空临时目录，将裁剪后视频放到dataset中。
考虑到中间可能会出现各种错误，我对代码进行了部分修改，先从YouTube下载所有需要的视频，存储在videos中。
#此处将后续的ffmpeg裁剪去掉，同时修改了输出文件位置及视频名称，下载的视频以_kDc7gYphkU_000193_000203.mp4即id_start-time_end-time.mp4 格式命名。方便后续直接根据视频名字读取长度信息进行视频裁剪。 def download_clip(video_identifier, output_filename, start_time, end_time, tmp_dir='/tmp/kinetics', num_attempts=5, url_base='https://www.youtube.com/watch?v='): """Download a video from youtube if exists and is not blocked. arguments: --------- video_identifier: str Unique YouTube video identifier (11 characters) output_filename: str File path where the video will be stored. start_time: float Indicates the begining time in seconds from where the video will be trimmed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a762c5f7ade1934504a8f3e91987b8c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d309584b4f631300c6b6f6abd27a5629/" rel="bookmark">
			【超详细】Linux内核树的构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文档因为过于繁琐，现已弃用。最新教程请见【Linux内核树】五步构建。
目录 前言检查是否已有构建好的内核树下载内核源码开始构建1. 安装必须的包2. 生成配置文件3. 开始make 附录：可能的错误错误一：No rule to make target错误二错误三 参考链接 前言 想要编写自己的Linux驱动（driver），第一步是要先构建Linux内核进程树。
检查是否已有构建好的内核树 Ubuntu默认是不配备 建议先确认电脑上是否已经有构建好的内核树（别在花费了几个小时之后才发现…）。内核树通常所在的具体目录为/lib/modules/&lt;系统版本&gt;。
可以使用uname查询系统版本：
uname -r 那么如果我的电脑上已经有构建好的内核树的话，所在目录就应该是/lib/modules/5.11.0-40-generic。
目录下的具体样子大概是下图这样
下载内核源码 1. 内核版本的选择
如何选择将要构建的内核进程树的版本，要看编写的驱动想要运行在哪个版本的Linux内核上。
比如，我想编写一个能运行在我的内核上的驱动（driver），首先要做的是查看自己的内核版本。
方法是运行uname命令
uname -r 这里显示的5.11.0-40-generic可能有点让人感到模糊不清。
更精确的方法是去查看/usr/src/&lt;uname -r显示的版本&gt;/Makefile文件里开头的版本号。比如我这里是
所对应的版本就是5.11.22。
如果/usr/src里有多个文件，随意打开一个就行，其中的Makefile开头的版本号一般情况下是一致的。
2. 下载源码
在这里的官网下载源文件，将解压的文件移到/usr/src/目录下，这是后续操作的所在目录。
https://mirrors.edge.kernel.org/pub/linux/kernel/
（注意，要下载linux开头的，而不是ChangeLog开头的）
其他方法
运行下面的命令自动下载
sudo apt-get install dpkg-dev&lt;pre name="code" class="cpp"&gt;$ apt-get source linux-image-$(uname -r) 开始构建 1. 安装必须的包 首先，确保已经安装这些包（这是为了下一步的menuconfig所准备的，如果使用不同的config方法，需要的包可能有所不同；dwarves是为了make bzImage准备的）。
ncurses-dev，flex，bison，libelf-dev，libssl-dev
sudo apt-get install ncurses-dev flex bison libelf-dev libssl-dev dwarves （注意：这里列出的是Ubuntu系统中包的名字。在其它系统中，这些包可能有不同的名字，请各位自行检索。）
2. 生成配置文件 正式构建前，需要先生成配置文件，来指定构建出的系统的各项属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d309584b4f631300c6b6f6abd27a5629/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c031f629be380347ba16ba8dabe024/" rel="bookmark">
			关于string、char * 、scanf（）、sscanf（）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 1.char*、char[]及string的区别及相互转换1.1定义1.2区别1.3转换 2.关于scanf()、sscanf()的一些特殊用法 1.char*、char[]及string的区别及相互转换 参考：
https://www.jb51.net/article/41917.htm
https://www.cnblogs.com/fonddream/p/9806810.html
1.1定义 char *s1：s1是一个指向字符串的 指针;
char s2[]：s2是一个字符 数组;
string s3：s3是一个string类的 对象.
string：string是STL当中的一个容器，对其进行了封装，所以操作起来非常方便。
首先必须了解，string可以被看成是以字符为元素的一种容器。字符构成序列（字符串）。有时候在字符序列中进行遍历，标准的string类提供了STL容器接口。具有一些成员函数比如begin()、end()，迭代器可以根据他们进行定位。
注意：
1.与char不同的是，string不一定以NULL(’\0’)结束。string长度可以根据length()得到，string可以根据下标访问。所以，、不能将string直接赋值给char。
2.当我们定义了一个string，就不能用scanf("%s",s)和printf("%s",s)输入输出。主要是因为%s要求后面是对象的首地址。即char *
char* :char *是一个指针，可以指向一个字符串数组，至于这个数组可以在栈上分配，也可以在堆上分配，堆得话就要你手动释放了。
1.2区别 string的内存管理是由系统处理，除非系统内存池用完，不然不会出现这种内存问题。
char *的内存管理由用户自己处理，很容易出现内存不足的问题。
当我们要存一个串，但是不知道其他需要多少内存时， 用string来处理就最好不过了。
当你知道了存储的内存的时候，可以用char *，但是不如用string的好，用指针总会有
隐患。
用string还可以使用各种成员函数来处理串的每一个字符，方便处理。
用char *处理串，就不如string的方便了，没有相应的函数来直接调用，而是要自己编
写函数来完成串的处理，而且处理过程中用指针还很容易出现内存问题。
1.3转换 1、string 转换成 char *
如果要将string直接转换成const char *类型。string有2个函数可以运用。
一个是.c_str()，一个是data成员函数。
例子如下：
string s1 = "abcdeg"; const char *k = s1.c_str(); const char *t = s1.data(); printf("%s%s",k,t); cout&lt;&lt;k&lt;&lt;t&lt;&lt;endl; 如上，都可以输出。内容是一样的。但是只能转换成const char*，如果去掉const编译不能通过。
那么，如果要转换成char*，可以用string的一个成员函数copy实现。
string s1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c031f629be380347ba16ba8dabe024/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/170835e074afa5e3915be86073f62c66/" rel="bookmark">
			机器学习数学学习笔记：Chapter 2. Linear Algebra
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chapter 2. Linear Algebra Resources Gilbert Strang’s Linear Algebra course Linear Algebra Series by 3Blue1Brown Algebra Construct a set of objects (symbols) and a set of rules to manipulate these objects.
Vector objects: Geometric vectors
Polynomials
Audio signals are vectors
Elements of R n \R^n Rn are vectors
2.1 Systems of Linear Algebra a 11 X 1 + ⋅ ⋅ ⋅ + a 1 n x n = b 1 a_{11}X_1 + ··· + a_{1n}x_n = b_1 a11​X1​+⋅⋅⋅+a1n​xn​=b1​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/170835e074afa5e3915be86073f62c66/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/272/">«</a>
	<span class="pagination__item pagination__item--current">273/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/274/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>