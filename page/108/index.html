<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1efe1aff4bd70648ac288a0bcbae23d7/" rel="bookmark">
			CISA《网络安全事件和漏洞响应手册》提到的SSVC是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年11月16日，美国网络安全和基础设施安全局(CISA)根据行政命令EO
14028的要求发布了《网络安全事件和漏洞响应手册》。手册规定的漏洞响应过程包括识别、评估、修复、报告通知4个步骤，其中评估部分的第一句话提到“使用特定相关者漏洞分类法(Stakeholder-
specific Vulnerability
Categorization，简称SSVC)之类的方法，确定环境中是否存在漏洞，以及底层软件或硬件的重要性”。CISA为什么着重点名SSVC，它在漏洞评估方面又有哪些特点？本文将对此进行介绍和分析。
##一、SSVC基本理念
###1、CVSS不足之处
通用安全漏洞评分系统(CVSS)是目前使用最为广泛的漏洞严重程度评估标准，漏洞的CVSS分值通常与CVE编号一起由美国国家漏洞库(NVD)发布。但CVSS存在一些不足：
(1) CVSS仅把技术严重度作为基本原则，而将时间和环境作为可选因素，三者都应该是评价漏洞的主要因素；
(2)目前缺少通过CVSS分值指导决策的相关方法，并且由于度量的不确定性和指标的设计，从数值到定性的转换较为复杂；
(3)CVSS评分算法的参数不透明，相关工作组也没有证明公式的使用， 因此高CVSS分值并不代表漏洞将被普遍利用或具有公开的利用方法；
(4) CVSS基本分值是静态的，不随时间的推移而变化；
(5) 研究表明， 分析者对CVSS V3评分元素的解释并不一致。
###2、SSVC目标及总括
对组织和分析者来说，给定有限的资源，哪些漏洞应该被处理，哪些漏洞当前可以忽略，是需要解决的问题，而基于CVSS并不一定能够有效的实现。
正是考虑到这些，卡耐基梅隆大学软件工程研究所在设计新的漏洞评估体系SSVC之初就明确了目标：
输出是定性的决策，而非定量的计算，输入也是定性的；可对有限数量的相关者群体提出多元化建议；过程论证是透明的；结果是可解释的。
总体而言，SSVC是漏洞管理中操作的优先级排序系统，是基于决策树模型的模块化决策系统，避免一刀切的解决方案；SSVC是漏洞管理的概念性工具，对如何做出决策、决策中应包含哪些内容、如何清楚地记录和沟通决策等均有描述；SSVC面向各类漏洞管理相关者(同时也是供应链的主要参与成员)，关注存在漏洞的情况下他们的处理决策。
截止目前，SSVC已发布3个版本，分别是2019年11月的V1.0版本、2020年12月的V1.1版本，以及2021年4月的V2.0版本。
##二、SSVC具体内容
###1、SSVC定义的漏洞管理相关者
可根据团队在供应链中执行的任务，将相关者划分为提供者、部署者或协调者。
(1) 提供者
即漏洞修复方案的提供者，一般可认为是软件生产者。提供者通常会收到其产品的一个或多个版本的漏洞报告，他们需将报告信息分解为一组受该漏洞影响的产品或版本，也就是将漏洞与受影响产品进行关联，并最终为受影响产品提供修复或缓解方案。
(2) 部署者
即漏洞修复方案的部署者，一般可认为是信息系统使用者。部署者通常从提供者获得针对其部署产品的修复或缓解方案，他们必须决定是否将其部署到特定实例上。部署者漏洞管理流程的核心是数据的整理，包括产品版本部署实例清单的维护、漏洞与修复或缓解方案的对应、修复或缓解方案与产品版本的对应等。
(3) 协调者 协调者是SSVC
V2.0中新增的角色，指的是漏洞协调披露(CVD)中促进协同响应过程的个人或组织机构，包括计算机安全事件响应小组(CSIRT)、对国家负责的CSIRT(如US-
CERT)、产品安全事件响应小组(PSIRT)、安全研究组织、漏洞赏金和商业经纪人等。不同协调者的差异很大，对SSVC的使用方法也可能不同。协调者的工作往往与一份独立的漏洞报告相关，也可能会根据工作流程的要求重新组织报告，如合并、拆分、扩充、缩减等。
###2、 各相关者的漏洞优先级决策结果
SSVC定义了三类相关者根据漏洞轻重缓急的不同情况，应做出的具体处理决策，即处理漏洞的优先级决策结果。 (1)提供者漏洞优先级决策结果
表1 提供者漏洞优先级决策结果
(2)部署者漏洞优先级决策结果
表2 部署者漏洞优先级决策结果
(3)协调者漏洞优先级决策结果SSVC以CERT/CC为例给出，包括两类： · 关于协调的决策结果 目标是CERT/CC在收到漏洞报告时分析人员可获得这些信息，决策结果共有3种：
表3 关于协调的决策结果
· 关于发布的决策结果 CERT/CC在某个时间点上往往必须决定何时或是否发布关于漏洞的信息，共有“发布”和“不发布”两种决策结果。
###3、各相关者可能的决策点
决策点是各相关者做出漏洞优先级决策结果的判断依据，每个决策点又有若干决策值。SSVC
V2.0中定义的提供者和部署者的决策点7项，协调者(以CERT/CC为例)关于协调的决策点7项、关于发布的决策点3项。 (1)提供者和部署者决策点 · 可利用性(Exploitation) 即主动利用漏洞的证据，适用于提供者和部署者。其决策值包括：
表4可利用性决策值
· 技术影响(Technical Impact) 即漏洞被利用后的技术影响力，适用于提供者和部署者。其决策值包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1efe1aff4bd70648ac288a0bcbae23d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfabe71cc73f4d18a64e5ba894e238a1/" rel="bookmark">
			如何解决 MyBatis-Plus 的 updateById 方法不更新 null 值属性的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何解决 MyBatis-Plus 的 updateById 方法不更新 null 值属性的问题 1、问题2、解决办法3、总结 1、问题 使用Mybatis-plus的updateById去更新实体类的时候，如果实体类中的某个字段为null，会导致为null的字段不做更新操作
2、解决办法 为字段配置注解 @TableField(updateStrategy = FieldStrategy.IGNORED) 是 MyBatis-Plus框架的注解，用于定义数据库表字段在更新操作中的策略。在 MyBatis-Plus 中，@TableField注解用于标识实体类中与数据库表字段对应的属性。其中，updateStrategy 属性决定了该字段在执行更新操作时的处理策略。
FieldStrategy 是 MyBatis-Plus 框架中的一个枚举类，用于定义字段更新策略。该枚举类包含以下几个常量：
IGNORED：意思是"忽略判断"，所有值都更新和插入。
NOT_NULL：当字段为 null 时不进行更新。
NOT_EMPTY：当字段为 null 或空字符串时不进行更新。
DEFAULT：使用数据库默认值进行更新。
NEVER：永远不更新字段的值。
例如，假设有一个实体类 User，其中有一个属性 name 对应数据库表的字段名为 name：
public class User { @TableField(updateStrategy = FieldStrategy.IGNORED) private String name; // 其他属性和方法... } 在执行更新操作时，如果只想更新实体类中的字段为null时也可以更新，可以使用如下方式：
User user = new User(); user.setId(1L); user.setAge(25); user.setName(null) // name 字段为null，也可以更新name 字段 userService.updateById(user); 需要注意的是，@TableField(updateStrategy = FieldStrategy.IGNORED) 注解只对更新操作生效，对插入操作不生效。如果需要忽略某个字段的插入操作，可以使用其他注解或在插入时手动设置为 null。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfabe71cc73f4d18a64e5ba894e238a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac100641f521428cab6c945fb9e0c5f/" rel="bookmark">
			网络安全-致大学生的一封信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello大家好，我是叶学长，非常高兴能够与您在网络安全这个平台相认，你们可能来自各个学校、各个专业，也许你是网络安全相关专业、或是对网络安全这个行业很感兴趣，相聚在网安就是一种缘分，今日就让我带你认识网安，从真正意义上给你一个从入门到实战的知识平台。如果学校有安全学会、社团之类的可以进去，一般能接触到学安全的学长和优秀的同学，学会也会有一些好的资源和平台，比如打CTF、网络安全竞赛、HVV项目之类的。进去之后如果学会这些很会走形式主义这些的话可以考虑退或者自己学自己的。一个人学可能会很无趣，但很多人一起交流的话会学得很快，也学得比较开心。如果学校内没有给你提供好的平台的话，那只能靠自己，可以从这几个方面入手:
第一一定要提升实力（这是最重要的），不能只是理论，网络安全需要实践，网络安全说实话是限制条件很少的行业，只要你有电脑就什么都可以干，并且网上公开的项目也非常多，可以直接实践。
第二为了丰富自己的简历，去挖SRC搞排名也可以赚钱，这样你毕业的时候就比别人更丰富，并且在绝大多数企业看到你能挖到SRC的漏洞会对你比较认可。
第三就是去安全社区投稿写文章同样也是让更多的人认识你并且能够赚到稿费，增加动力，在大学的时候我一年靠挖洞挖到就赚了十万，那时候真的很有动力去挖。
通过上面三点如果你的简历比较丰富实力比较强。那就是有护网的项目多投多去面试，暑假去实习一两个月拉开和别人的距离，碰到好的企业可以提前占坑就是占住这个位置，不好的企业直接跑路。
为什么我不用视频的方式来讲解漏洞？视频讲解可能会更加通俗易懂点，但它包含一个致命的弱点，就是很多人看完视频后啥也没留下，需要用到某个小知识点时又需要去看整个视频，很难搜索到，只是认为听懂了，在网络安全现有的学习环境下，大多数好的思路都以文章、笔记的形式呈现，很少说别人会专门录制一个视频给你看，比如安装一些软件，遇到一些问题大多数查看的都是文章，网络安全需要的能力不仅仅是你学到了多少东西，更重要的是在遇到一个新的问题，新的知识，你能够快速看懂别人写的东西。同时在漏洞挖掘的过程中，我们经常需要阅读开发者的开发手册，以文章的形式来讲解漏洞能够增强你的阅读能力，提升你的理解能力，对你未来工作更有帮助！为了能够带给大家更好的体验我这边立志讲细、讲全、讲深，用文章的形式带给你比视频更好的体验。
刚开始的时候切记不要用扫描器，因为你是初学者，很难把握一个度，容易帮别人的服务器扫蹦，而且大多数大型产商之类的都不知道给扫描器扫了多少次了，刚开始的时候最重要的是掌握WEB10漏洞和常见功能点的漏洞，多去动手实战，就是先不要用扫描器，不然你有可能会陷入用扫描器来满足现状。当大概能挖到一些洞了，就可以去用扫描器，扫描器只是起到一个辅助作用，扫描出的结果还是得用手工判断，手工判断的前提是你已经掌握了基本的漏洞了，所以前期提升自己对漏洞原理以及实战速度是最关键的。后续我会发专门关于扫描和信息收集的笔记！同时来给你面试一两次！给你讲讲大概的渗透的流程。希望大家能够帮我写的大多数漏洞掌握然后去实战！基本就是只要套模板，等会挖漏洞了，其实大部分其他漏洞原理就会慢慢理解、也会理解得更深。这里看完我的内容我可以保证你日后的学习方式、以及理解漏洞原理更加敏捷。
为了节省大家的时间以及精力，这边学习安全的基本工具以及需要的一些java、Python环境我都已经整理，免得大家花费大量的时间在工具安装上，对于刚开始的初学者，如果没有一个详细的软件安装步骤很可能一个环境就得安装一上午，而这边我已经对各个工具进行下载全部放置在网盘，并附带了详细的步骤！对于这些工具不用特意去学习，先安装好，后续将通过文章一步一步的带你使用，重点是学习漏洞思路以及实战中不断的去熟悉这些工具！先会一些简单的渗透思路、渗透实战后续就非常容易上手。初学者先不用使用太多工具，先帮一个工具用熟悉后，在去扩展工具！不然很可能就是左用一个右用一个到最终啥也不会用！我也会慢慢给你扩展其他工具！
最后希望大学生们眼光放长远，在能力允许的情况下，不要仅仅局限于国内，国外也非常多漏洞赏金项目。为建立一个好的网络安全圈出一份力，为国家网络安全尽自己的一些绵薄之力，建设网络安全强国。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/882921b4114e7e427ab24ee301d17e6e/" rel="bookmark">
			信息安全-致大学生的一封信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello大家好，我是叶学长，非常高兴能够与您在网络安全这个平台相认，你们可能来自各个学校、各个专业，也许你是网络安全相关专业、或是对网络安全这个行业很感兴趣，相聚在网安就是一种缘分，今日就让我带你认识网安，从真正意义上给你一个从入门到实战的知识平台。如果学校有安全学会、社团之类的可以进去，一般能接触到学安全的学长和优秀的同学，学会也会有一些好的资源和平台，比如打CTF、网络安全竞赛、HVV项目之类的。进去之后如果学会这些很会走形式主义这些的话可以考虑退或者自己学自己的。一个人学可能会很无趣，但很多人一起交流的话会学得很快，也学得比较开心。如果学校内没有给你提供好的平台的话，那只能靠自己，可以从这几个方面入手:
第一一定要提升实力（这是最重要的），不能只是理论，网络安全需要实践，网络安全说实话是限制条件很少的行业，只要你有电脑就什么都可以干，并且网上公开的项目也非常多，可以直接实践。
第二为了丰富自己的简历，去挖SRC搞排名也可以赚钱，这样你毕业的时候就比别人更丰富，并且在绝大多数企业看到你能挖到SRC的漏洞会对你比较认可。
第三就是去安全社区投稿写文章同样也是让更多的人认识你并且能够赚到稿费，增加动力，在大学的时候我一年靠挖洞挖到就赚了十万，那时候真的很有动力去挖。
通过上面三点如果你的简历比较丰富实力比较强。那就是有护网的项目多投多去面试，暑假去实习一两个月拉开和别人的距离，碰到好的企业可以提前占坑就是占住这个位置，不好的企业直接跑路。
为什么我不用视频的方式来讲解漏洞？视频讲解可能会更加通俗易懂点，但它包含一个致命的弱点，就是很多人看完视频后啥也没留下，需要用到某个小知识点时又需要去看整个视频，很难搜索到，只是认为听懂了，在网络安全现有的学习环境下，大多数好的思路都以文章、笔记的形式呈现，很少说别人会专门录制一个视频给你看，比如安装一些软件，遇到一些问题大多数查看的都是文章，网络安全需要的能力不仅仅是你学到了多少东西，更重要的是在遇到一个新的问题，新的知识，你能够快速看懂别人写的东西。同时在漏洞挖掘的过程中，我们经常需要阅读开发者的开发手册，以文章的形式来讲解漏洞能够增强你的阅读能力，提升你的理解能力，对你未来工作更有帮助！为了能够带给大家更好的体验我这边立志讲细、讲全、讲深，用文章的形式带给你比视频更好的体验。
刚开始的时候切记不要用扫描器，因为你是初学者，很难把握一个度，容易帮别人的服务器扫蹦，而且大多数大型产商之类的都不知道给扫描器扫了多少次了，刚开始的时候最重要的是掌握WEB10漏洞和常见功能点的漏洞，多去动手实战，就是先不要用扫描器，不然你有可能会陷入用扫描器来满足现状。当大概能挖到一些洞了，就可以去用扫描器，扫描器只是起到一个辅助作用，扫描出的结果还是得用手工判断，手工判断的前提是你已经掌握了基本的漏洞了，所以前期提升自己对漏洞原理以及实战速度是最关键的。后续我会发专门关于扫描和信息收集的笔记！同时来给你面试一两次！给你讲讲大概的渗透的流程。希望大家能够帮我写的大多数漏洞掌握然后去实战！基本就是只要套模板，等会挖漏洞了，其实大部分其他漏洞原理就会慢慢理解、也会理解得更深。这里看完我的内容我可以保证你日后的学习方式、以及理解漏洞原理更加敏捷。
为了节省大家的时间以及精力，这边学习安全的基本工具以及需要的一些java、Python环境我都已经整理，免得大家花费大量的时间在工具安装上，对于刚开始的初学者，如果没有一个详细的软件安装步骤很可能一个环境就得安装一上午，而这边我已经对各个工具进行下载全部放置在网盘，并附带了详细的步骤！对于这些工具不用特意去学习，先安装好，后续将通过文章一步一步的带你使用，重点是学习漏洞思路以及实战中不断的去熟悉这些工具！先会一些简单的渗透思路、渗透实战后续就非常容易上手。初学者先不用使用太多工具，先帮一个工具用熟悉后，在去扩展工具！不然很可能就是左用一个右用一个到最终啥也不会用！我也会慢慢给你扩展其他工具！
最后希望大学生们眼光放长远，在能力允许的情况下，不要仅仅局限于国内，国外也非常多漏洞赏金项目。为建立一个好的网络安全圈出一份力，为国家网络安全尽自己的一些绵薄之力，建设网络安全强国。欢迎大家关注下方公众号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d779e0f23cfbfa478d3d5329517eda6/" rel="bookmark">
			Java--变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
变量
变量作用域
类变量、实例变量、局部变量实力
常量
常量例子代码
变量 变量是什么：就是可以变化的量！
Java中，每个变量都必须声明其类型
Java变量是程序中最基本的存储单元，其中包括变量名，变量类型和作用域。
注意事项
每个变量都有类型，类型可以是基本类型，也可以是引用类型
变量名必须是合法的标识符
变量声明是一条完整的语句，因此每一个声明都必须以分号结束
变量作用域 类变量
static int a = 0; //类变量
实例变量
String str = 'hello world; //实例变量'
局部变量
类变量、实例变量、局部变量实力 public class demo6 { //类变量 static static double salary = 2500; ​ //属性：变量 ​ //实例变量：从属于对象,如果不自行初始化，这个类型的默认值 0 0.0 //布尔值：默认是false //除了基本类型，其余的默认值都是null String name; int age; ​ //main方法 public static void main(String[] args) { ​ //局部变量：必须声明和初始化值 int i = 10; System.out.println(i); ​ //变量类型 变量名字 = new Demo6(); demo6 demo6 = new demo6(); ​ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d779e0f23cfbfa478d3d5329517eda6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28ee25f307e1f711e25c9f6862b8ab85/" rel="bookmark">
			Mac直接使用Visio和MythType的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac使用 Visio 的三种解决办法及 Mac直接使用 MythType 的办法 今天终于在某种契机下解决了 Mac 下最大的不足，不能直接使用 Visio 和 MythType【2023年08月03日20:03:32】 摘要 众所周知在 mac 下无法直接使用 Visio 和 MythType，这导致我们（理工科）在 mac 下写毕业论文或者文章时很麻烦（画图和编辑公式），不可避免甚至无法有效解决。
最常用的解决方式就是安装虚拟机，下载 PD 再安装 Win10 系统，在里面安装 word 和 visio 及 mythtype。每次写论文设计到作图和编辑 mythtype 公式的时候，都要启动虚拟机，然后打开 word 和 visio 及 mythtype；操作完成后将其保存，然后复制到 mac 桌面下；需要修改又要把东西复制到虚拟机win10下在编辑，特别麻烦。
我始终找不到一种有效解决办法直到今天。
解决办法一：土豪直接解锁visio网页版 直接在 mac 下使用 visio 网页版 一次性购买价格 解决办法 2：tao bao搜索@mac 安装 visio 远程安装过程记录： 安装软件在 Mac 上，可直接点击打开
Mac 下运行软件展示 原理说明：还是基于 PD虚拟机，但是可以在融合模式下直接运行在 Mac上。我也想分享安装方法，但是 tb 上是收费的（我一共花了 90 元），安装包是加密的，直接远程帮忙安装，所以无法分享。 我分享给大家这样的解决思路。希望各位能够使用开心！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/398f55ed4a46c174efda280d272329d5/" rel="bookmark">
			P3957 [NOIP2017 普及组] 跳房子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[NOIP2017 普及组] 跳房子 题目背景 NOIP2017 普及组 T4
题目描述 跳房子，也叫跳飞机，是一种世界性的儿童游戏，也是中国民间传统的体育游戏之一。
跳房子的游戏规则如下：
在地面上确定一个起点，然后在起点右侧画 n n n 个格子，这些格子都在同一条直线上。每个格子内有一个数字（整数），表示到达这个 格子能得到的分数。玩家第一次从起点开始向右跳，跳到起点右侧的一个格子内。第二次再从当前位置继续向右跳，依此类推。规则规定：
玩家每次都必须跳到当前位置右侧的一个格子内。玩家可以在任意时刻结束游戏，获得的分数为曾经到达过的格子中的数字之和。
现在小 R 研发了一款弹跳机器人来参加这个游戏。但是这个机器人有一个非常严重的缺陷，它每次向右弹跳的距离只能为固定的 d d d。小 R 希望改进他的机器人，如果他花 g g g 个金币改进他的机器人，那么他的机器人灵活性就能增加 g g g，但是需要注意的是，每 次弹跳的距离至少为 1 1 1。具体而言，当 g &lt; d g&lt;d g&lt;d 时，他的机器人每次可以选择向右弹跳的距离为 d − g , d − g + 1 , d − g + 2 , … , d + g − 1 , d + g d-g,d-g+1,d-g+2,\ldots,d+g-1,d+g d−g,d−g+1,d−g+2,…,d+g−1,d+g；否则当 g ≥ d g \geq d g≥d 时，他的机器人每次可以选择向右弹跳的距离为 1 , 2 , 3 , … , d + g − 1 , d + g 1,2,3,\ldots,d+g-1,d+g 1,2,3,…,d+g−1,d+g。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/398f55ed4a46c174efda280d272329d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/038b2c0678a8e30b6ca5ed26e4828e08/" rel="bookmark">
			Docker 中使用 Nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装Docker 安装教程：Windows 安装 Docker_Yel_Liang的博客-CSDN博客
二、拉取Nginx镜像 1、搜索nginx镜像 a、通过命令搜索 docker search nginx 如下图：
STARS:星数 OFFICIAL:官方认可
b、通过网站搜索镜像(查看版本) Nginx镜像https://hub.docker.com/_/nginx/tags?page=1&amp;ordering=-last_updated
2、拉取镜像 docker pull nginx:1.9.5 如下图：
3、查看安装情况 docker images 如果您使用 Docker Desktop 版，则会发现在images多出一个nginx 1.9.5 的镜像，如下图
三、启动容器 1、简单启动，进入容器查看文件 docker run --name=nginx_temp -d -p 8000:80 nginx:1.9.5 参数说明：
--name 容器名称
-d 守护进程
-p 端口映射（-p 8000:80 把容器内的80端口映射到主机8000）端口 如下图：
测试是否成功：
主机上访问：127.0.0.1:8000
8000 为 容器上的 80 端口，创建容器时80端口映射到了主机的8000端口
查看容器情况：
docker ps 如下图
如果您有Docker Desktop版，则会发现在Containers菜单多出一个nginx_temp的容器；如下图：
进入容器，查看常用文件位置，为下一步的文件挂载做准备
docker exec -it nginx_temp /bin/bash 如下图
查看常用文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/038b2c0678a8e30b6ca5ed26e4828e08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd625db8867e2ab9301120530b093ce/" rel="bookmark">
			决策树与随机森林
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 决策树是：Why：How：基本概念决策树生成举例决策树缺点参考 Demo 随机森林1.是：2.Why：3.How：参考 Demo 决策树 是： 1.一种有监督的分类（或预测）算法。
2.利用属性、属性值构造一个决策的路径，可类比程序的if_else的多层判断。
如：利用贷款人信息预测是否会拖延还贷的一个简单决策树。
Why： 易于理解和解释。树可以被可视化。几乎不需要数据准备。其他算法通常需要数据标准化，需要创建虚拟变量并删除缺失值。但是，请注意，此模块不支持缺失值。使用树的成本(即预测数据)是用于训练树的数据点数的对数。 能够处理数值型和分类型数据。其他技术通常专门分析只有一种类型变量的数据集。能够处理多输出问题。使用白盒模型。如果给定的情况在模型中是可以观察到的，那么对条件的解释就很容易用布尔逻辑来解释。相反，在黑箱模型中(例如，在人工神经网络中)，结果可能很难解释。可以使用统计测试验证模型。这样就有可能对模型的可靠性作出解释。 即使它的假设在某种程度上被生成数据的真实模型所违背，它也表现得很好。 How： 基本概念 训练数据：用于训练模型的数据，英文是train。
测试数据：用于测试（验证）模型准确度的数据，英文是test。训练数据、测试数据都是来自已知的数据集，然后划分为2部分，一部分训练、一部分测试（验证），也就是在已知的数据集内完成训练和验证，才能去预测实战。
纯度、不纯度：根据某个属性分割数据集，样本类型的集中度，纯度越高越高。如按是否恒温划分是否哺乳动物，10个里9个是哺乳动物，纯度高；如按是否有毛发划分，则10个里有6个是哺乳动物，则纯度降低。是否恒温是更好的划分属性。常用的测算纯度的函数有基尼gini、熵entropy。、
信息增益（information gain）：对父节点，按属性再次划分后，纯度的增加量。
决策树生成 举例 数据集
样本个数10个，属性3个：有房者、婚姻、年收入；标签：是否拖欠贷款。
可以凭感觉，用if-else构造一个决策树。属性排序：有房者、婚姻、年收入。
问题：因为属性、属性性值、先后顺序，决策树有指数个肯能，哪个是最优？
属性测算
婚姻属性的信息纯度最高。
3. 属性选择
类似，生成完整的树。与感性的分配有差异，属性排序：婚姻、有房者、年收入。
关键问题：如何选择属性、生成节点？
选择属性、按属性值分类、局部最优、信息增益最大。
后序以此类推。
决策树缺点 决策树学习器可以创建过于复杂的树，不能很好地概括数据。这就是所谓的过拟合。为了避免这个问题，必须设置剪枝、设置叶节点所需的最小样本数或设置树的最大深度等机制。决策树可能是不稳定的，因为数据中的小变化可能导致生成完全不同的树。通过集成决策树来缓解这个问题。学习最优决策树的问题在最优性的几个方面都是NP-complete的，甚至对于简单的概念也是如此。因此，实际的决策树学习算法是基于启发式算法，如贪婪算法，在每个节点上进行局部最优决策。这种算法不能保证返回全局最优决策树。这可以通过训练多棵树再集成一个学习器来缓解，其中特征和样本被随机抽取并替换。有些概念很难学习，因为决策树不能很容易地表达它们，例如异或、奇偶校验或多路复用器问题。如果某些类占主导地位，则决策树学习者会创建有偏见的树。因此，建议在拟合决策树之前平衡数据集。 参考 https://www.bilibili.com/video/BV1T7411b7DG/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1e37904a72db86b329d6b5320c86a013
Demo 酒分类预测：
https://github.com/heroicpoem/MachineLearningInAction/blob/master/decisionTree.ipynb
随机森林 1.是： 基于决策树的、集成算法。
森林，指包含多个决策树；
随机，指构造单棵决策树时，随机的选择样本，使得决策树是不同，或者侧重不同的能力。最后是整合多棵树的预测结果：均值或者众数。
2.Why： 随机决策森林纠正了决策树的过度拟合随机森林通常优于决策树，但它们的准确性低于梯度提升树更多的树会提高性能并使预测更稳定抗噪 3.How： 构造多棵决策树，分别决策，整合结果。
2个超参：决策树个数、分几层、如何采样、结果整合方法。
参考 https://www.bilibili.com/video/BV1H5411e73F/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1e37904a72db86b329d6b5320c86a013
Demo https://blog.csdn.net/Graow/article/details/106749351
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11b5477cb13bc285d3cd4b2d5cd47ec5/" rel="bookmark">
			UE5实现像素流送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下实现像素流送部署所遇到的问题
在UE文档中有详细的流程：https://docs.unrealengine.com/5.1/zh-CN/getting-started-with-pixel-streaming-in-unreal-engine/
1.新建一个UE5空工程（路径不要有中文）。
2.在虚幻编辑器的主菜单中选择 编辑（Edit） &gt; 插件（Plugins）。
3.搜索像素流送（Pixel Streaming）插件，启用之后，点击立即重启。
4.主菜单中选择 编辑（Edit） &gt; 项目设置（Project Settings），如果项目中有角色，而您希望启用触控设备的输入（如手机和平板电脑）在关卡中移动此角色，则可能需要在屏幕上显示触摸控制器。在 引擎（Engine） &gt; 输入（Input category） 下启用 固定显示触控界面（Always Show Touch Interface） 设置。
5.在主菜单中选择 编辑（Edit） &gt; 编辑器偏好（Editor Preferences），在 关卡编辑器（Level Editor） &gt; 播放（Play） 中找到 额外启动参数（Additional Launch Parameters） 设置，并将其值设为 -AudioMixer -PixelStreamingIP=localhost -PixelStreamingPort=8888 6.打包Windows项目。从虚幻编辑器的主菜单中选择 文件（Files） &gt; 打包项目（Package Project） &gt; Windows &gt; Windows (64-bit)，
7.打包完成之后，找到打包项目的那个文件夹，创建一个.exe的快捷方式后，右键快捷方式找到属性，在这个位置后面加上 -AudioMixer -PixelStreamingIP=localhost -PixelStreamingPort=8888 后点击确定即可。
命令解释：
（1）-AudioMixer：给像素流送添加声音，因为默认是没有声音的。
（2）-PixelStreamingIP=localhost：像素流送的IP地址，localhost表示的是本地地址，如果需要其他设备（手机）控制UE程序的话，需要修改这个地址。
（3）-PixelStreamingPort=8888：像素流送的端口。
8.获取像素流送服务器，找到打包文件的Pack\Windows\XiangSuLiuSong（这个是自己项目名字）\Samples\PixelStreaming\WebServers，运行get_ps_servers.bat命令（确保将相应的 .bat 脚本用于Windows，将相应的 .sh 脚本用于Linux）。等待安装，这会自动将相关像素流送基础设施分支提取到该文件夹中
安装完成后的文件如下：
9.安装所需要的依赖项，运行setup.bat
安装完成之后会出现下面两个文件夹，要确保这两个文件夹不是空的，如果是空的就说明下载出了问题
运行run_local.bat
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11b5477cb13bc285d3cd4b2d5cd47ec5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f30029c0d32daea68e73f07f7e2c7a7b/" rel="bookmark">
			IDEA设置类模板、方法模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA设置类模板、方法模板 IDEA设置类模板第一步：File -----&gt; Settings(快捷键:Ctrl + Alt +S)第二步： 选择Editor 下的 File and Code Templates第三步：选择右侧的Clas 在①处填写要使用的模板第四步 ： 设置好之后点击OK（确定）或者Apply（应用）第五步：新建的类上面就应用上了！ IDEA设置方法模板第一步：找到settings 中Editor下的Live Templates第二步：在Live Templates中点击右侧的加号，选择Template Group...第三步：输入你要创建组的名字第四步：创建出组之后，选择右侧加号的Live Template第五步：图中①位快捷键，②为快捷键描述，③为快捷键生成的内容，④为按键生成③的无内容第六步：三步走如图一，点击设置需要应用的地方，我们选择java，如图二图一：图二： 第七步：点击Edit vaniables第八步： 小提示：存在下列列表，可以选择第九步：点击OK，去测试第十步：图片指向为作者名称第十一步 ：大功告成；拜拜了您内... IDEA设置类模板 第一步：File -----&gt; Settings(快捷键:Ctrl + Alt +S) 第二步： 选择Editor 下的 File and Code Templates 第三步：选择右侧的Clas 在①处填写要使用的模板 /** * @ClassName ${NAME} //类名称 * @Description: 类描述 * @Author: ${USER}	//作者 * @CreateDate: ${DATE} ${TIME}	//创建时间 * @UpdateUser: 更新人 * @UpdateDate: ${DATE} ${TIME}	//更新时间 * @UpdateRemark: 更新的信息 * @Version: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f30029c0d32daea68e73f07f7e2c7a7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d0672c4711c136e3cebbb52584773d/" rel="bookmark">
			Avoid mutating a prop directly since the value will be overwritten whenever the parent component re
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这个问题是子组件更改了数据没在data定义然后又传回个父组件导致的
解决方法：
在data定义一个新数据，在watch去监听父传过来的值，然后新数据等于父传过来的值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de3529d7cb86b625438df88c18642ac/" rel="bookmark">
			长短时记忆网络(LSTM)(超详细 |附训练代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
往期回顾
长短时记忆网络是啥
长短时记忆网络的前向计算
长短时记忆网络的训练
LSTM训练算法框架
关于公式和符号的说明
将误差项传递到上一层
​编辑
权重梯度的计算​编辑
长短时记忆网络的实现
激活函数的实现
LSTM初始化
前向计算的实现
反向传播算法的实现
梯度下降算法的实现
梯度检查的实现
GRU
小结
参考资料
往期回顾 在上一篇文章中，我们介绍了循环神经网络以及它的训练算法。我们也介绍了循环神经网络很难训练的原因，这导致了它在实际应用中，很难处理长距离的依赖。在本文中，我们将介绍一种改进之后的循环神经网络：长短时记忆网络(Long Short Term Memory Network, LSTM)，它成功的解决了原始循环神经网络的缺陷，成为当前最流行的RNN，在语音识别、图片描述、自然语言处理等许多领域中成功应用。但不幸的一面是，LSTM的结构很复杂，因此，我们需要花上一些力气，才能把LSTM以及它的训练算法弄明白。在搞清楚LSTM之后，我们再介绍一种LSTM的变体：GRU (Gated Recurrent Unit)。 它的结构比LSTM简单，而效果却和LSTM一样好，因此，它正在逐渐流行起来。最后，我们仍然会动手实现一个LSTM。
长短时记忆网络是啥 我们首先了解一下长短时记忆网络产生的背景。回顾一下零基础入门深度学习(5) - 循环神经网络中推导的，误差项沿时间反向传播的公式：
梯度消失到底意味着什么？在零基础入门深度学习(5) - 循环神经网络中我们已证明，权重数组W最终的梯度是各个时刻的梯度之和，即：
假设某轮训练中，各时刻的梯度以及最终的梯度之和如下图：
我们就可以看到，从上图的t-3时刻开始，梯度已经几乎减少到0了。那么，从这个时刻开始再往之前走，得到的梯度（几乎为零）就不会对最终的梯度值有任何贡献，这就相当于无论t-3时刻之前的网络状态h是什么，在训练中都不会对权重数组W的更新产生影响，也就是网络事实上已经忽略了t-3时刻之前的状态。这就是原始RNN无法处理长距离依赖的原因。
既然找到了问题的原因，那么我们就能解决它。从问题的定位到解决，科学家们大概花了7、8年时间。终于有一天，Hochreiter和Schmidhuber两位科学家发明出长短时记忆网络，一举解决这个问题。
其实，长短时记忆网络的思路比较简单。原始RNN的隐藏层只有一个状态，即h，它对于短期的输入非常敏感。那么，假如我们再增加一个状态，即c，让它来保存长期的状态，那么问题不就解决了么？如下图所示：
新增加的状态c，称为单元状态(cell state)。我们把上图按照时间维度展开：
LSTM的关键，就是怎样控制长期状态c。在这里，LSTM的思路是使用三个控制开关。第一个开关，负责控制继续保存长期状态c；第二个开关，负责控制把即时状态输入到长期状态c；第三个开关，负责控制是否把长期状态c作为当前的LSTM的输出。三个开关的作用如下图所示：
接下来，我们要描述一下，输出h和单元状态c的具体计算方法。
长短时记忆网络的前向计算 前面描述的开关是怎样在算法中实现的呢？这就用到了门（gate）的概念。门实际上就是一层全连接层，它的输入是一个向量，输出是一个0到1之间的实数向量。假设W是门的权重向量，b是偏置项，那么门可以表示为：
门的使用，就是用门的输出向量按元素乘以我们需要控制的那个向量。因为门的输出是0到1之间的实数向量，那么，当门输出为0时，任何向量与之相乘都会得到0向量，这就相当于啥都不能通过；输出为1时，任何向量与之相乘都不会有任何改变，这就相当于啥都可以通过。因为δ（也就是sigmoid函数）的值域是(0,1)，所以门的状态都是半开半闭的。
LSTM用两个门来控制单元状态c的内容，一个是遗忘门（forget gate），它决定了上一时刻的单元状态有多少保留到当前时刻ct；另一个是输入门（input gate），它决定了当前时刻网络的输入xt有多少保存到单元状态ct。LSTM用输出门（output gate）来控制单元状态ct有多少输出到LSTM的当前输出值ht。
下图显示了遗忘门的计算：
接下来看看输入门：
下图是的~ct计算：
这样，我们就把LSTM关于当前的记忆~ct和长期的记忆ct-1组合在一起，形成了新的单元状态ct。由于遗忘门的控制，它可以保存很久很久之前的信息，由于输入门的控制，它又可以避免当前无关紧要的内容进入记忆。下面，我们要看看输出门，它控制了长期记忆对当前输出的影响：
下图表示输出门的计算：
LSTM最终的输出，是由输出门和单元状态共同确定的：
下图表示LSTM最终输出的计算：
式1到式6就是LSTM前向计算的全部公式。至此，我们就把LSTM前向计算讲完了。
长短时记忆网络的训练 熟悉我们这个系列文章的同学都清楚，训练部分往往比前向计算部分复杂多了。LSTM的前向计算都这么复杂，那么，可想而知，它的训练算法一定是非常非常复杂的。现在只有做几次深呼吸，再一头扎进公式海洋吧。
LSTM训练算法框架 LSTM的训练算法仍然是反向传播算法，对于这个算法，我们已经非常熟悉了。主要有下面三个步骤：
前向计算每个神经元的输出值，对于LSTM来说，即ft、it、ct、ot、ht五个向量的值。计算方法已经在上一节中描述过了。反向计算每个神经元的误差项δ值。与循环神经网络一样，LSTM误差项的反向传播也是包括两个方向：一个是沿时间的反向传播，即从当前t时刻开始，计算每个时刻的误差项；一个是将误差项向上一层传播。根据相应的误差项，计算每个权重的梯度。 关于公式和符号的说明 首先，我们对推导中用到的一些公式、符号做一下必要的说明。
接下来的推导中，我们设定gate的激活函数为sigmoid函数，输出的激活函数为tanh函数。他们的导数分别为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6de3529d7cb86b625438df88c18642ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41cb2f51921425805f1807685fee252/" rel="bookmark">
			消息疯狂堆积！RocketMQ出Bug了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 用过 MQ 的同学，可能会遇到过消息堆积的问题。而肥壕最近也踩上了这个坑，但是发现结果竟然是这么一个意料之外的原因而导致的。
正文 那一晚月黑风高，肥壕正准备踏上回家的路，突然收到告警短信轰炸！“MQ 消息堆积告警 [TOPIC: XXX] ”
肥壕心里“万只草泥马崩腾~” 第一反应是：“怎么肥事？刚下班就来搞事情？？？”
于是乎赶回公司赶紧打开电脑，登上 RocketMQ 后台查看（公司自己搭建的开源版RocketMQ）
握草 (ｷ｀ﾟДﾟ´)!!! 竟然堆积了3亿多条消息了？？？
要知道出现消息堆积无在乎这个问题：
生产者的生产速度 &gt;&gt; 消费者的处理速度
生产者的生产速度骤增，比如生产者的流量突然骤增。
消费速度变慢，比如消费者实例 IO 阻塞严重或者宕机。
擦了一下头上的冷汗😓...赶紧登上消费者服务器瞧瞧。
应用运行正常！服务器磁盘IO 正常！网络正常！
再去上去生产者的服务器，咦...流量也很正常！
什么？？？佛了😨 ...生产者和消费者的应用都很正常，但是为什么消息会堆积怎么多呢？看着这堆积的数量越堆越多，越发着急。
虽然说 RocketMQ 版能支持 10 亿级别的消息堆积，不会因为消息堆积导致性能明显下降，😰但是这堆积量很明显就是一个异常情况。
RocketMQ 有 BUG！
没错这肯定是 RocketMQ 的锅！
本篇完...
哈哈言归正传，虽然肥壕拼爹不行，但至少不能坑爹😂
进入消费者的工程查看一下日志，emmm...没有发现报错，没有错误日志...看起来好像一切都很正常。
咦...不过这个消费的速度是不是有点慢？？？这不科学啊，消费者可是配置了3个结点的消费集群啊，按业务的需求量来说消费能力可是杠杠的呀。我再点开这个 TOPIC 的消费者信息。
咦，这三个消费者的 ClientId 怎么会是一样呀？
以多年采坑经验的直接告诉我：难道是因为 ClientId 的相同的问题，导致 broker 在分发消息的时候出现混乱，从而导致消息不能正常推送给消费者？
因为生产者和消费者都表现正常，所以我猜测问题可能在于 Broker 这一块上。
基于这个推测，那么我们就需要解决这几个问题：
部署在不同的服务器上的两个消费者，为什么 ClientId 是相同的呢？
ClientId 相同，会导致 broker 消息分发错误吗？
问题分析 为什么 ClientId 相同呢？我推测是因为 Docker 容器的问题。因为公司最近开始容器化阶段，而刚好消费者的项目也在第一批容器化阶段的列表上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41cb2f51921425805f1807685fee252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f18d3a5e53d862683ab7c4bafe95630/" rel="bookmark">
			作为一个老程序员，想对新人说什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近知乎上，有一位大佬邀请我回答下面这个问题，看到这个问题我百感交集，感触颇多。
在我是新人时，如果有前辈能够指导方向一下，分享一些踩坑经历，或许会让我少走很多弯路，节省更多的学习的成本。
这篇文章根据我多年的工作经验，给新人总结了25条建议，希望对你会有所帮助。
1.写好注释 很多小伙伴不愿意给代码写注释，主要有以下两个原因：
开发时间太短了，没时间写注释。
《重构》那本书说代码即注释。
我在开发的前面几年也不喜欢写注释，觉得这是一件很酷的事情。
但后来发现，有些两年之前的代码，业务逻辑都忘了，有些代码自己都看不懂。特别是有部分非常复杂的逻辑和算法，需要重新花很多时间才能看明白，可以说自己把自己坑了。
没有注释的代码，不便于维护。
因此强烈建议大家给代码写注释。
但注释也不是越多越好，注释多了增加了代码的复杂度，增加了维护成本，给自己增加工作量。
我们要写好注释，但不能太啰嗦，要给关键或者核心的代码增加注释。我们可以写某个方法是做什么的，主要步骤是什么，给算法写个demo示例等。
这样以后过了很长时间，再去看这段代码的时候，也会比较容易上手。
2.多写单元测试 我看过身边很多大佬写代码有个好习惯，比如新写了某个Util工具类，他们会同时在test目录下，给该工具类编写一些单元测试代码。
很多小伙伴觉得写单元测试是浪费时间，没有这个必要。
假如你想重构某个工具类，但由于这个工具类有很多逻辑，要把这些逻辑重新测试一遍，要花费不少时间。
于是，你产生了放弃重构的想法。
但如果你之前给该工具类编写了完整的单元测试，重构完成之后，重新执行一下之前的单元测试，就知道重构的结果是否满足预期，这样能够减少很多的测试时间。
多写单元测试对开发来说，是一个非常好的习惯，有助于提升代码质量。
即使因为当初开发时间比较紧，没时间写单元测试，也建议在后面空闲的时间内，把单元测试补上。
3.主动重构自己的烂代码 好的代码不是一下子就能写成的，需要不断地重构，修复发现的bug。
不知道你有没有这种体会，看自己1年之前写的代码，简直不忍直视。
这说明你对业务或者技术的理解，比之前更深入了，认知水平有一定的提升。
如果有机会，建议你主动重构一下自己的烂代码。把重复的代码，抽取成公共方法。有些参数名称，或者方法名称当时没有取好的，可以及时修改一下。对于逻辑不清晰的代码，重新梳理一下业务逻辑。看看代码中能不能引入一些设计模式，让代码变得更优雅等等。
通过代码重构的过程，以自我为驱动，能够不断提升我们编写代码的水平。
4.代码review很重要 有些公司在系统上线之前，会组织一次代码评审，一起review一下这个迭代要上线的一些代码。
通过相互的代码review，可以发现一些代码的漏洞，不好的写法，发现自己写代码的坏毛病，让自己能够快速提升。
当然如果你们公司没有建立代码的相互review机制，也没关系。
可以后面可以多自己review自己的代码。
5.多用explain查看执行计划 我们在写完查询SQL语句之后，有个好习惯是用explain关键字查看一下该SQL语句有没有走索引。
对于数据量比较大的表，走了索引和没有走索引，SQL语句的执行时间可能会相差上百倍。
我之前亲身经历过这种差距。
因此建议大家多用explain查看SQL语句的执行计划。
关于explain关键字的用法，如果你想进一步了解，可以看看我的另外一篇文章《explain | 索引优化的这把绝世好剑，你真的会用吗？》，里面有详细的介绍。
6.上线前整理checklist 在系统上线之前，一定要整理上线的清单，即我们说的：checklist。
系统上线有可能是一件很复杂的事情，涉及的东西可能会比较多。
假如服务A依赖服务B，服务B又依赖服务C。这样的话，服务发版的顺序是：CBA，如果顺序不对，可能会出现问题。
有时候新功能上线时，需要提前执行sql脚本初始化数据，否则新功能有问题。
要先配置定时任务。
上线之前，要在apollo中增加一些配置。
上线完成之后，需要增加相应的菜单，给指定用户或者角色分配权限。
等等。
系统上线，整个过程中，可能会涉及多方面的事情，我们需要将这些事情记录到checklist当中，避免踩坑。
7.写好接口文档 接口文档对接口提供者，和接口调用者来说，都非常重要。
如果你没有接口文档，别人咋知道你接口的地址是什么，接口参数是什么，请求方式时什么，接口多个参数分别代码什么含义，返回值有哪些字段等等。
他们不知道，必定会多次问你，无形当中，增加了很多沟通的成本。
如果你的接口文档写的不好，写得别人看不懂，接口文档有很多错误，比如：输入参数的枚举值，跟实际情况不一样。
这样不光把自己坑了，也会把别人坑惨。
因此，写接口文档一定要写好，尽量不要马马虎虎应付差事。
如果对写接口文档比较感兴趣，可以看看我的另一篇文章《瞧瞧别人家的API接口，那叫一个优雅》，里面有详细的介绍。
8.接口要提前评估请求量 我们在设计接口的时候，要跟业务方或者产品经理确认一下请求量。
假如你的接口只能承受100qps，但实际上产生了1000qps。
这样你的接口，很有可能会承受不住这么大的压力，而直接挂掉。
我们需要对接口做压力测试，预估接口的请求量，需要部署多少个服务器节点。
压力测试的话，可以用jmeter、loadRunner等工具。
此外，还需要对接口做限流，防止别人恶意调用你的接口，导致服务器压力过大。
限流的话，可以基于用户id、ip地址、接口地址等多个维度同时做限制。
可以在nginx层，或者网关层做限流。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f18d3a5e53d862683ab7c4bafe95630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0da1fb75c5c977cc1351f0b1d5c9f3d4/" rel="bookmark">
			csp-j（2022）初赛解析【选择题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		csp-j（2022）初赛解析【选择题】 答案：A。
【解析】面向对象考察的内容与类相关，题中唯一没有出现类的选项是A选项。printf函数在c语言中就存在。
答案：C
【解析】栈的特征：后进先出。
A选项：65进栈，5出栈，4进栈，4出栈，3进栈，3出栈，6出栈，21进栈，1出栈，2出栈。
B选项：654进栈，4出栈，5出栈，3进栈，3出栈，21进栈，1出栈，2出栈，6出栈。
C选项：6543进栈，3出栈，4出栈，5没有出栈，6就无法出栈，这里非法。
D选项：65432进栈，234出栈，1进栈，1出栈，5出栈，6出栈。
答案：D
【解析】第四条语句的意思是将p指向x的地址，第五条语句的意思是将q指向y的地址。第六条语句将q赋值给p，于是p就指向原来q指向的y的地址了。
答案：C
【解析】数组在定义时需要请求空间，所以数组的大小为固定值。链表使用指针完成连接，可动态调整。
答案：B
【解析】栈：后进先出。队列：先进先出。
本道题目只需判断出栈的先后顺序即可。
12进栈，2出栈，容量为2。
34进栈，4出栈，3出栈，容量为3。
56进栈，6出栈，5出栈，1出栈，容量为3。
综上，栈S容量至少为3。
答案：B
【解析】前缀表达式，先遍历根节点，再遍历左节点，最后遍历右节点。如下图所示：该表达式的前缀表达式为：+a*-bcd。
哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，哈夫曼编码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，一般就叫做Huffman编码（有时也称为霍夫曼编码）。
依据哈夫曼编码原理，可构造如下二叉树：
字母编码a000b001c11d01e10 所以d的编码长度为2。
答案：C
【解析】完全二叉树的排列是按照从上至下，从左至右的顺序进行排列。
那么9号节点在第三层的第二个节点的位置，是个右节点，它的兄弟节点（左节点）编号为8，它的孩子节点：右节点编号为2i+1，即19；左节点编号为2i，即18。
n个顶点的有向联通图至少存在n个有向边。
如下图所示，3个顶点的有向连通图（最少边）G和它的邻接矩阵A
所以n个顶点构成的有向连通图中其邻接矩阵至少存在n个非0元素。
答案：D
【解析】栈的特征为：先进后出，或者说后进先出，那么使用两个栈即可实现先进先出，即队列。
答案：D
【解析】题目描述为在p后插入一个节点s。如图所示：
插入一个S节点，从后往前插入，先让s的后继指向p的后继，再让p的后继的前驱设为s。然后将s的前驱设为p，p的后继重新设为s。
A选项中第三句：p的后继已经修改，s的后继就不能再设为原本p的后继了，出现矛盾。
B选项第二句也出现了与A相同的问题。
D选项中第三句，p的后继已指向s，那么p的后继的前驱便自动指向p，现在又重新赋值为s，自相矛盾。
答案：B
【解析】排序算法稳定性是指在多个具有相同关键词的记录在待排序的序列中重新排序后,被排序的记录相对位置保持不变 。
堆排序、快速排序、希尔排序、直接选择排序是不稳定的排序算法，而冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。
答案：C
【解析】 3 ∗ 8 + 2 ∗ 1 + 1 / 8 = 26.125 3*8+2*1+1/8=26.125 3∗8+2∗1+1/8=26.125
答案：B
【解析】
(1)空串
(2)a,b,c
(3)ab,bc,ca
(4)abc,bca,cab
(5)abca,bcab
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0da1fb75c5c977cc1351f0b1d5c9f3d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62197cf59e46e32549f34b54722e4266/" rel="bookmark">
			C&#43;&#43;工程编译链接错误汇总VisualStudio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一些小的知识点
make工具
可以使用windows下的事件查看器崩溃的地方
dumpbin工具查看dll是32位还是64位的
_MSC_VER
.cc 和.cpp
【VC++目录中的包含目录】 vs 【C/C++常规中的附加包含目录】——头文件所在目录如何怎么添加，添加了以后搜索头文件就会到这些个路径下搜索了
include&lt;&gt; 和 include""
WinMain 和 main 和 AfxWinMain
_tWinMain 和 wWinMain 和 WinMain
stdafx 的介绍
char 和 wchar之间的转化
manifest文件和mt工具
一些错误
error C2011: 'SteamworksSDKHelper' : 'class' type redefinition 1&gt; d:\xxx\source\source\SteamworksSDK/SteamworksSDKHelper.h(6) : see declaration of 'SteamworksSDKHelper'
1&gt;c1xx : fatal error C1083: Cannot open source file: 'simple_handler.cc': No such file or directory
error LNK2038: mismatch detected for '_ITERATOR_DEBUG_LEVEL': value '2' doesn't match value '0'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62197cf59e46e32549f34b54722e4266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c69b6534610bca87962729af8babea6/" rel="bookmark">
			线性回归算法中损失函数（误差函数/目标函数）的来历及推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文以线形回归为例，利用高斯分布概率密度函数和极大似然估计公式推导出线性回归误差函数通用表达式。
以一元线性回归算法为例，其模型如下所示：
(1)
假如给定 i=14 个样本数据 ：
[ [29, 77], [28, 62], [34, 93], [31, 84], [25, 59], [29, 64], [32, 80], [31, 75], [24, 58], [33, 91], [25, 51], [31, 73], [26, 65], [30, 84]]
线性回归的原理即为通过确定模型参数，确定所有样本值代入模型后得到的结果值与真实值累计误差最小。以一元线性回归为例，直观的看如图所示，即为找到一条直线，穿过所有样本点，并使各个点到直线的累计距离 最小，从而求出直线方程的参数 和 参数 的值。
如果是多元线性回归，即样本的特征向量不止一个维度，同样遵循以上模型特点和原理，更通用的线形回归表达方式如下：
(2)
以上表达式可通过向量的方式进行表达，如下所示：
(3)
因为误差具有随机性，符合独立同分布特点，高斯概率分布函数如下：
(4)
因误差项满足高斯概率分布：
(5)
将误差代入高斯分布：
(6)
根据极大似然估计的原理，根据样本发生的概率估计整个事件的概率，其主要思想是所有样本发生的总概率最大的概率即为事件的概率，因为样本独立同分布，故所有样本概率积求最大值：
(7)
由于概率小于1，连乘会导致最后的值非常小，故两边取对数，让连乘变连加，且不会改变函数的单调性。
(8)
(9)
(10)
要是上述对数函数最大，即可让与连加部分最小即可，而这部分就是我们要推导的目标函数：
(11)
以上目标函数同时也可以用向量表达：
(12)
通过上诉步骤推导出的目标函数，与我们最朴素的想法通过求误差平方和不谋而合：
(13)
：是指给定的样本数据中的y值，即真实值
：是指通过线性回归模型（即直线方程）求得的 y 值，即： 上述目标函数求极小值可以通过最小二乘法求解，又名正规方程解：
即对目标函数求导等于0：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c69b6534610bca87962729af8babea6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b00cc09a9b55b68d965774f36b1657b/" rel="bookmark">
			关于CPU对Cache的访存操作 浅解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做计算机组成原理关于高速缓存处理器的相关习题，由于一开始没有完全理解导致做题时特别崩溃。在做错无数次题后我感觉自己有必要总结一下自己对Cache的理解，以防以后再忘记。
一 | 前因 1 为什么需要Cache? 首先我们需要明白为什么需要使用Cache。在CPU访存时，其实是要取主存中存储的数据，但由于 CPU的访问速度远远大于主存的读、取数据的速度，所以需要在他们之间使用一种更快的介质作为缓存，将我们当前常用和与当前访问的数据空间相接近的数据存储到这个缓存中。
在上面这段话中，我们常用到的缓存就是 高速缓冲存储器Cache ；而利用数据在存储空间上的邻近的这种思想叫做 空间局部性原理 ；利用当前使用数据在未来很可能还会用到的这种思想叫做 时间局部性原理 。
2 Cache是什么？ Cache通常由SRAM构成，其位于存储器层次结构的顶层，这也就意味着它的 速度很快、容量较小、价格较高 。在速度上应该仅次于寄存器，有着一器之下，好几器之上的地位。
3 Cache如何起作用？ 当CPU发起读请求时，会先在Cache中查找数据（假设是找一个字），如果找到了，则称为 访存地址在Cache中命中 。此时就对Cache进行读操作，就不需要访问主存了；若没有命中，则再访问主存，并把此字所在的块一次性从主存调入Cache。
以上过程均由 硬件实现 。【注：有些计算机也会同时访问Cache和主存，优点是可以提高平均访问时间，缺点是设计结构更复杂】
二 | Cache与主存 1 Cache和主存中都存些什么？ 为了便于Cache和主存交换信息，Cache和主存都被划分为相等的 块 。Cache块又叫做Cache行，每个“块”由若干字节组成，块的长度被称为块长。
从一的解释中，我们可以知晓Cache只是为了加快CPU对主存中数据的访问的中间介质，所以在Cache中存储的数据是主存中最活跃的部分数据的副本。由于计算机中存储的都是01数据，所以只需要明白Cache和主存分别存储与什么相关的01位代码即可，也即，明白它们的存储地址结构即可。
2 关于主存和Cache的存储地址结构 因为Cache比主存小，所以无法一对一映射。而访存地址都是与主存地址保持一致的，所以我们需要能够从主存地址推得其Cache中存储地址的映射方式。通常有三种方式：①直接映射 ②全相联映射 ③组相联映射。详细映射方式在此不介绍，需要注意的是 它们的地址结构都是主存中存储的地址结构 。而不是Cache中的。
直接映射 地址结构：
全相联映射 地址结构：
组相联映射 地址结构：
其中，块内地址计算方式取决于单个块的容量以及计算机编址方式（没说明就是按字节编址）。如若每个Cache块的容量为2bB，则块内地址为b位。
Cache行号和组号很容易根据Cache的行数和组数算出，如Cache有2c行，则Cache行号占c位。
然后再根据主存总容量，设为2kB，则总的地址长度就应为k位，那么可以得到，直接映射中标记的位数为 k - b - c;
Cache的地址结构通常如下：
有效位：又称为装入位，用来表示对应页面是否在Cache中脏位：又称为修改位，用来表示页面是否被修改过 （当不考虑一致维护性时，则没有该位）替换控制位：当使用替换算法时，需要用控制位表示使用时间长短 （当不使用替换算法时，则没有这位，如采用直接映射）标记位：用于表示是主存中哪一块的副本 根据Cache的地址结构，我们可以将Cache的总容量划分为两部分，如下：
存储容量（即存储的数据）标记阵列容量（包括有效位、脏位、替换控制位、标记位） 通常题目中给出Cache行长xxB，指的都是存储容量。
如果你看懂了，希望能给作者点一个免费的赞，鼓励一下。如果还有没理解的欢迎在评论区一起交流。作者能力有限，若有错误，还望斧正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf408d6318c3b44271a7c2155a324eba/" rel="bookmark">
			【数论算法】快速幂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.概述2.代码实现 本文参考
LeetCode 50.Pow(x, n)
1.概述 （1）快速幂 (Fast Power)，顾名思义，就是快速算底数 x 的 n 次幂。其核心思想就是每一步都把指数减半，而相应的底数做平方运算。这样不仅能把非常大的指数给快速变小，所需要执行的循环次数也变小，而最后表示的结果不会变化。
（2）快速幂算法的本质是分治算法。例如我们要计算 x 64 x^{64} x64 ，我们可以按照：
x x x → x 2 x^2 x2 → x 4 x^4 x4 → x 8 x^8 x8 → x 16 x^{16} x16 → x 32 x^{32} x32 → x 64 x^{64} x64
的顺序，从 x 开始，每次直接把上一次的结果进行平方，计算 6 次就可以得到 x 64 x^{64} x64 的值，而不需要对 x 乘 63 次 x。而如果我们要计算 x 77 x^{77} x77，我们可以按照：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf408d6318c3b44271a7c2155a324eba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/194c908ea7453afb9acd4dd5260fd1cf/" rel="bookmark">
			python-MySQL数据库建表语句(需要连接数据库)转存为Excel文档-工作小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将create table XXXXXX 转为指定Excel文档。该脚本适用于数据库表结构本地文档记录
呈现效果
代码
# -*- coding:utf-8 -*- # @Time : 2023/8/2 15:14 # @Author: 水兵没月 # @File : MySQL建表_2_excel.py import re import mysql.connector import pandas as pd db = '库名' mydb = mysql.connector.connect(host="连接IP", user="用户名", password="密码",port='端口',database=db) def con_mysql(): mycursor = mydb.cursor() return mycursor def clo_mysql(): mydb.close() def sel_mysql(table, db): mycursor = con_mysql() sel_info1 = "select * from information_schema.COLUMNS where TABLE_SCHEMA = '{}' and TABLE_NAME = '{}'".format(db, table) sel_info2 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/194c908ea7453afb9acd4dd5260fd1cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad871c6942542e3096de276ec33532f4/" rel="bookmark">
			入门级：路由器配置静态路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件：cicso packet tracer 8.0
拓扑图：路由器：Router-PT、连接线：Serial DTE、连接口：Serial口（serial是串行口,一般用于连接设备,不能连接电脑）
实验步骤：
1、构建拓扑图，配置接口IP地址，以R2为例（R1、R3同）： Router&gt;en Router#conf t Router(config)#host R2 R2(config)#int s2/0 R2(config-if)#ip address 192.168.1.2 255.255.255.0 R2(config-if)#no shutdown //开启端口 R2(config)#int s3/0 R2(config-if)#ip address 192.168.2.1 255.255.255.0 R2(config-if)#no shutdown //开启端口 配置完后查看配置信息简写为show ip int b：
R3建立虚拟接口（环回口），用来模拟另一个网段
R3(config)#int loopback 0 R3(config-if)#ip address 100.100.100.100 255.255.255.0 R3(config-if)#no sh 配置完后测试一下R1与R2、R2与R3之间的连通性（5个！代表5次应答，代表可通）
R1#ping 192.168.1.2 Type escape sequence to abort. Sending 5, 100-byte ICMP Echos to 192.168.1.2, timeout is 2 seconds: !!!!! Success rate is 100 percent (5/5), round-trip min/avg/max = 7/10/14 ms 2、配置IP路由（双向路由） ①R1-&gt;R2-&gt;R3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad871c6942542e3096de276ec33532f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42555d74095027d33a46eac25e36eddb/" rel="bookmark">
			入门级：路由动态选择协议之RIP（路由信息协议）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件：cicso packet tracer 8.0
拓扑图：路由器：Router-PT、连接线：Serial DTE、连接口：Serial口
1、配置基础ip
R1配置：虚拟接口——1.1.1.1；S3/0——192.168.1.1
R1(config)#int s3/0 R1(config-if)#ip address 192.168.1.1 255.255.255.0 R1(config-if)#no shutdown //开启端口 R1(config-if)#int loopback 0 //建立虚拟接口 R1(config-if)#ip address 1.1.1.1 255.255.255.0 R1(config-if)#no shutdown R2配置：S2/0——192.168.2.1；S3/0——192.168.2.1
R3配置：S2/0——192.168.2.1；虚拟接口：3.3.3.3
2、配置rip
R1：广播自己的IP路由：
R1(config)#route rip R1(config-router)#version 2 //采用Rip v2 R1(config-router)#no auto-summary //关闭自动汇总 R1(config-router)#network 1.0.0.0 //宣告自己连接的网络段 R1(config-router)#network 192.168.1.0 //宣告自己连接的网络段 R2和R3：广播自己的IP路由：
R2(config)#route rip R2(config-router)#version 2 R2(config-router)#no auto-summary R2(config-router)#network 192.168.1.0 R2(config-router)#network 192.168.2.0 3、查看R1路由中是否有到达3.3.3.3的路由
存在路由，R1可Ping通3.3.3.3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7efb0390bec1b9747fb05b562fd8532/" rel="bookmark">
			入门级：路由动态选择协议之EIGRP（思科私有）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、理论 三张表：路由表+拓扑表+邻居表
1、路由表：最终的路径选择标准，
查看命令：show ip route eigrp
2、拓扑表：路由器R2收到R1的路由表之后先保存，计算最优路径，然后放入路由表
查看命令：show ip eigrp topology
3、邻居表：若邻居中断则删除接收到的条目
邻居检测机制：hello包进行检测，5s检测一次，若检测超过有效次数，则认为邻居不可达。
查看命令：show ip eigrp neighbors
二、实验 软件：cicso packet tracer 8.0
拓扑图：路由器：Router-PT、连接线：Serial DTE、连接口：Serial口
1、配置基础ip R1配置：虚拟接口——1.1.1.1；S3/0——192.168.1.1
R1(config)#int s3/0 R1(config-if)#ip address 192.168.1.1 255.255.255.0 R1(config-if)#no shutdown //开启端口 R1(config-if)#int loopback 0 //建立虚拟接口 R1(config-if)#ip address 1.1.1.1 255.255.255.0 R1(config-if)#no shutdown R2配置：S2/0——192.168.2.1；S3/0——192.168.2.1
R3配置：S2/0——192.168.2.1；虚拟接口：3.3.3.3
2、配置EIGRP 以R1为例：
R1(config)#router eigrp 100 //100为自制系统号（AS），需要配置一样的 R1(config-router)#no auto-summary //关闭自动汇总 R1(config-router)#network 1.1.1.0 0.0.0.255 //反掩码：匹配宣告的地址范围通配符 R1(config-router)#network 192.168.1.0 0.0.0.255 R1(config-router)#exit 配置完后，查看R1的路由：
3、测试：R1可ping通3.3.3.3 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4cb95fa681af2152157bbe766fee94/" rel="bookmark">
			微服务使用步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven的依赖冲突解决方案：
路径最短原则配置优先原则破坏规则则使用排除 SpringBoot场景启动器starter的开发流程
c3p0-spring-boot-starter自定义场景启动器 test-c3p0调用自定义场景启动器 SpringBoot自动装配SpringBoot应用启动原理nacos服务治理
安装
启动bin/startup -m standalone
webUI地址为localhost:8848/nacos，其中用 户nacos/nacos
关闭bin/shutdown 微服务
将应用划分为若干个体量更小的服务，每个服务可以独立开发、独立部署、独立运行，服务之间可以通过轻量级通信机制进行相互调用
用户管理系统
用户微服务
create database test1; use test1; create table tbl_users( id bigint primary key auto_increment, name varchar(32) not null, role_id bigint ) 角色微服务
create database test2; use test2; create table tbl_role( id bigint primary key auto_increment, name varchar(32) not null ) 针对不同的服务当作一个独立的应用进行开发
下面来写Controller里的具体实现
@RestController // 轻量级通信机制 http+json public class UserController{ @Autowired private RestTemplate restTemplate; //可以当作浏览器对待 @Autowired private IUserServ userService; @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b4cb95fa681af2152157bbe766fee94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db6c432ea0d82ae8dd6e2f899d54e040/" rel="bookmark">
			微信小程序前后页面传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序前后页面传值 从前一个页面跳转到下一个页面，如何传递参数？从后一个页面返回前一个页面，如何回调参数？ 向后传值 从前一个页面跳转到下一个页面并传值。
前页面：在跳转链接中添加参数并传递
wx.navigateTo({ url: 'page/path?key=value' }) 后页面：在onLoad()函数中接收参数
onLoad: function(options) { console.log(options.key) // 输出 value } 这种方式适合小规模的传参，适合传输“较大”的数据吗？例如，我们需要传递一个字典的值过去，将整个字典转json后作为value，定义一个key传过去，这样传值微信小程序平台支持吗？再者就是 “url” 里的参数长度有什么限制没？
回调传值 从后一个页面返回上一个页面并传值。
当前页面：拿到前一个页面的实例，调用前一个页面的方法
let pages = getCurrentPages(); let prevPage = pages[pages.length - 2]; // 上一个页面 prevPage.setData({ key: newValue }) wx.navigateBack(); 或者：
在前一个页面定义一个函数 callback(e) { console.log(e) } 在当前页面调用前一页面的函数 let pages = getCurrentPages(); let prevPage = pages[pages.length - 2]; // 上一个页面 prevPage.callback({key: value}) 微信小程序没有类似于代理或者block之类的回调，但是上面的方式来实现回调更加直接，其本质上和代理，lock的原理是一样的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4220c5ce4bc0fefa01090faf645bcf33/" rel="bookmark">
			ADC 动态参数分析matlab code（span,spanh取值问题）（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理想频谱与实际频谱 理想的信号在频率上应该是没有展宽的。 在理论上，纯粹的单个频率成分信号应该在频域上表现为一个严格的单个频率，而不会有任何展宽。然而，在实际测量和处理中，我们经常观察到信号频谱存在一定的展宽，这主要是由于以下原因：
信号的时限： 在实际中，信号是有限时限的，也就是说信号的时域持续时间是有限的。根据傅里叶变换的原理，有限时域信号对应于无限频带，因此信号的频谱在一定程度上是展宽的。
测量和采样误差： 在信号测量和采样过程中，可能会引入一些误差，例如噪声、采样率限制等，这些误差也会导致信号在频域上产生一定的展宽。
信号传输和滤波： 在信号传输和滤波过程中，可能会存在信号传输损耗和频率响应的影响，导致信号频谱发生变化。
非线性效应： 一些非线性系统或器件，例如非线性放大器、混频器等，会导致信号频谱产生展宽。
span 和 spanh 就是信号和谐波的频谱宽度 在上一篇文章中说span和 spanh 是测量出来的就是指，对于不同的信号，不同的测量系统，以及不同的FFT参数，会导致信号带宽、以及FFT之后的离散频谱宽度各不相同，所以选取的值需要自己去试：
尝试原则：
1，先观察频谱图。 一般情况下，谐波能量占比较低，所以调节spanh影响不大，此时就要仔细调节 span，原则是观察频谱图，选取噪声基线以上的频谱范围。
2，寻找临界值。 在合适的范围内，增大spanh （增加谐波能量）会导致ADC动态参数变差，但是变化会比较缓慢，当逐步增加到一个临界值时，ENOB等参数会突然变差，说明spanh就已经偏大了。临界值以内的spanh值就可以作为动态参数的最终值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/561c11300d9c65d9831aeddfc9f34e1b/" rel="bookmark">
			DataBase 1. kaggle 发现无法显示验证码进行人机交互怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这期开始增加一个系列就是我们经常用到的数据库或者网站，便于我们查找数据，在线分析数据，若能很好的利用别人的工具，就没必要自己一句一句码代码，最主要的是不断出现各种bug处理不了，东问西问搞不定，今天就来介绍第一个在线平台——kaggle， 因为要找套 CT 影像的数据，忽然发现这个在线平台效果不错，可以参考别人的思路以及代码，同时也可以上传自己的思路和代码，参与一些竞赛，蛮有意思的，毕竟生物信息也是在各种数据库里，挖呀挖呀挖！！！
简单介绍一下这个数据库，然后我们说一下怎么注册吧！
kaggle创建于2010年，是一个为开发商和数据科学家提供举办数据科学竞赛、托管数据库、编写和分享代码的在线平台， 网站：
https://www.kaggle.com/
我在注册的时候发现怎么也无法显示验证码进行人机交互，最后找到了解决办法，下面给大家总结一下流程：
当注册信息填完之后，总是显示红色提示 ："Captcha must be filled out."，上网一查原来是不显示验证码进行人机交互，该怎么解决呢？别急慢慢道来！
第一步：点击浏览器右上方的三个点
找到扩展
打开Microsoft Edge加载项，进入edge外接程序界面
第二步：在搜索框中输入 header editor
回车确定，点击 Header Editor 右侧的获取
弹出对话框，选择“添加扩展”
接着弹出对话框，显示已添加成功
第三步：获取成功后，从扩展处进入该界面
接着选择导出导入
第四步：下载规则中输入该网址 点右侧下载按钮（注：如果这里显示无法获取，可能需要挂个梯子）
https://azurezeng.github.io/static/HE-GoogleRedirect.json
导入成功后，点击下载保存
第五步：刷新页面就显示进行人机身份验证
填写注册信息，邮箱，密码，和全称之后，点击 “Next”，
弹出协议之后选择只能选择 “I agree”
这时就会您填写的邮箱就会收到验证码，登录自己的邮箱，找到验证码，
填入进去之后，点击 “Next”,
恭喜，注册成功，这样就可以使用了
这个网站还是学东西更多一些，个人认为生物信息分析人员相对于其他IT工作者或者数据分析人员对于交叉学科懂得更多，但是并不深入，所有我们不停的在学习，学习各种生物上的机制，又要不断夯实统计学知识，以及利用机器学习分析数据，又要不停的学习各种编程语言，最早接触还是perl编程，R绘图，shell操作，后来python成王者了，根本停不下来，停不下来，停不下，停不，停！
桓峰基因，铸造成功的您！
未来桓峰基因公众号将不间断的推出临床数据分析系列生信分析教程，
敬请期待！！
桓峰基因官网正式上线，请大家多多关注，还有很多不足之处，大家多多指正！
http://www.kyohogene.com/
桓峰基因和投必得合作，文章润色优惠85折，需要文章润色的老师可以直接到网站输入领取桓峰基因专属优惠券码：KYOHOGENE，然后上传，付款时选择桓峰基因优惠券即可享受85折优惠哦！https://www.topeditsci.com/
有想进生信交流群的老师可以扫最后一个二维码加微信
备注“单位+姓名+目的”！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/914ddf20c09689e7d2780b2b461d6449/" rel="bookmark">
			Redis 序列化器和持久化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 序列化器 针对数据的序列化/反序列化提供了多种可选择策略 比如RedisSerializer，接下来我们详细看看
1、JdkSerializationRedisSerializer 用于 POJO 对象的存取场景，使用 JDK 本身序列化机制，将 pojo 类通过ObjectInputStream/ObjectOutputStream 进行序列化操作，最终 redis-server 中将存储字节列。是目前最常
用的序列化策略。
2、StringRedisSerializer用于Key和value为字符串的场景，根据指定的charset对数据的字节序列编码成string，是 new String(bytes, charset)和 string.getBytes(charset)的直接封装，是最轻量级和高效的策略。
3、JacksonJsonRedisSerializer 是 jackson-json 工具提供的 javabean 与 json 之间的转换能力，可以将 pojo 实例序列化成 json 格式存储在 redis 中，也可以将 json 格式的数据转换成 pojo 实例。因为 jackson 工具在序列化和反序列化时，需要明确指定 Class 类型，因此此策略封装起来稍微复杂。
缓存与数据库双写不一致
缓存可以提升性能、缓解数据库压力，但是使用缓存也会导致数据不一致性的问题。一般写数据操作使用缓存
有三种经典的缓存模式
Cache-Aside Pattern
Read-Through/Write through
Write behind
这三种常见的更新策略实际上都是保证数据的最终一致性的方法，可以总结为
1、先更新数据库再更新缓存，后续线程会读取旧数据
2、先删除缓存再新数据库，并发线程读取旧数据并写到缓存
3、先更新数据库再删除缓存，后续线程会读取旧数据常见解决方案是延时双删，但是延时的时长不好控制
小小总结一下
总结：
1、并发几率很小的数据，几乎不用考虑，加上缓存过期时间，缓存失效后查询主动更新
2、业务上是否能容忍一定时间的不一致，如能容忍的话，加上缓存过期时间；如果不能容忍缓存数据不一致，可以通过加分布式读写锁保证并发读写或写写的时候按顺序排好队，读读的时候相当于无锁。
3、可以用阿里开源的 canal 通过监听数据库的 binlog 日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度
Cache-Aside Pattern 即旁路缓存模式，读操作：读的时候，先读缓存，缓存命中的话，直接返回数据；缓存没
有命中的话，就去读数据库，从数据库取出数据，放入缓存后，同时返回响应。写操作：更新的时候，先更新
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/914ddf20c09689e7d2780b2b461d6449/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b529790fbe1a1739b2c0be3028a46972/" rel="bookmark">
			选择最适合你的云服务器：腾讯云、华为云、阿里云对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云服务器是一种基于云计算技术的服务器，它可以为企业提供高效、灵活、安全的运行环境。目前市场上有很多云服务器的选择，其中腾讯云、华为云和阿里云是最受欢迎的三个品牌，下面我们来看看它们各自的优势。
腾讯云的优势在于其强大的技术支持和完善的生态系统。腾讯云拥有世界级的技术团队，为客户提供全天候技术支持，确保客户的业务能够稳定运行。此外，腾讯云还拥有丰富的产品和服务，包括强大的人工智能、大数据、区块链等技术，可以帮助客户实现数字化转型。
华为云的优势在于其安全性和稳定性。作为全球领先的ICT解决方案提供商，华为云拥有世界级的安全技术和经验，可以为客户提供安全可靠的云服务。此外，华为云还拥有全球分布式数据中心，可以为客户提供更加稳定的服务。阿里云的优势在于其开放性和创新性。阿里云拥有全球领先的云计算技术和生态系统，可以为客户提供强大的云服务。此外，阿里云还拥有全球最大的云计算市场，客户可以在市场上找到各种各样的应用程序和解决方案。
总的来说，腾讯云、华为云和阿里云都是优秀的云服务器品牌，它们各自都有自己的优势和特点。如果您正在寻找一款云服务器，可以根据自己的需求和预算选择适合自己的品牌。无论您选择哪一款云服务器，都可以享受到高效、灵活、安全的运行环境，提高业务的效率和竞争力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59a6c410b83db0128e80d578adbe13b7/" rel="bookmark">
			转载：上传网易云盘音频，不会自动改名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：
知乎：全网最简单的办法：上传网易云盘音乐音频不会自动改名
全网最简单的办法
step1:在电脑上选中全部要上传的mp3文件
step2:右键-属性-详细信息
step3:点【删除属性和个人信息】
step4:选中【从此文件中删除以下属性】
step5:全选-确定
重新上传至网易云
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cec8f24213ca0f5df2d9cb8781bd79d/" rel="bookmark">
			[语义分割] DeepLab v3（Cascaded model、ASPP model、两种ASPP对比、Multi-grid、训练细节）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rethinking Atrous Convolution for Semantic Image Segmentation 论文地址：Rethinking Atrous Convolution for Semantic Image SegmentationPytorch 实现代码：pytorch_segmentation/deeplab_v3 这是一篇 2017 年发表在 CVPR 上的文章。相比 DeepLab V2 有三点变化：①引入了 Multi-grid；②改进了 ASPP 结构；③移除 CRFs 后处理。
① 引入 Multi-grid：Multi-grid 的引入旨在进一步改进膨胀卷积的使用方式，提高语义分割模型在不同尺度上的性能。相较于之前的版本（如 DeepLab V2），DeepLab V3 引入了多尺度的膨胀率设置，解决了在过去膨胀卷积中固定膨胀率所带来的局限性。在 DeepLab V3 中，网络的部分层使用了不同的膨胀率，从而允许模型在不同尺度上捕捉更丰富的上下文信息，有效地分割不同大小的目标。
② 改进了 ASPP 结构（Atrous Spatial Pyramid Pooling）：ASPP 结构用于在特征图的不同尺度上捕获多尺度上下文信息。在 DeepLab V3 中，ASPP 结构得到了改进，除了原来的多个膨胀系数的膨胀卷积外，还引入了图像级特征（全局平均池化），这样在 ASPP 模块中既能获取局部细节信息，也能融合全局上下文信息。这种改进有助于提高模型的感知范围和语义信息，从而改善分割性能。
③ 移除 CRFs 后处理（Conditional Random Fields）：在 DeepLab V2 中，使用 CRF 进行后处理是为了进一步优化语义分割结果，特别是在边界细节上进行平滑处理。然而 CRF 的计算代价较高，并且会增加模型的复杂性。DeepLab V3 移除了 CRF 后处理步骤，而是通过引入 Multi-grid 和改进 ASPP 结构来在模型中直接获得更全面和精确的特征表示，从而减少了 CRF 的需求。这样一来，DeepLab V3 在保持高性能的同时，简化了模型结构和训练过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cec8f24213ca0f5df2d9cb8781bd79d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba31b3cc992e94885d0a64e0ff41196a/" rel="bookmark">
			stm32串口通信，收发字符串，并对其进行解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串口以字符串接收和发送 将传输的数据转化为整数（正负） stm32发送端 motor_position = Read_Encoder_Angle(Encoder); sensor_position = Get_Adc_Average_Angle(Adc); motor_velocity = Read_Encoder_Speed(Encoder); sensor_velocity = Get_Adc_Average_Speed(); sprintf(data_str, "%-8.4f, %-8.4f, %-8.4f, %-8.4f\n", motor_position , sensor_position , motor_velocity , sensor_velocity ); Usart_SendString(USART1, data_str); stm32接收端 接收数据格式为:\t16900\r\n,其中第一位“\t”为帧头,第二位数据1为奇偶校验位，最后两位数据"\r\n"为帧尾，中间数据为实际传输数据，即“6900”。
void USART1_IRQHandler(void) //串口1中断服务程序 { if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) //接收中断(接收到的数据必须是0x0d 0x0a结尾) { Res = USART_ReceiveData(USART1);	//读取接收到的数据 0x2D，0x31，0x30，0x30，0x30，0x0D，0x0A if((USART_RX_STA&amp;0x8000)==0)//接收未完成 { if(USART_RX_STA&amp;0x4000)//接收到了0x0D { if(Res!=0x0A){ USART_RX_STA=0;//接收错误,重新开始 memset(USART_RX_BUF,0,USART_REC_LEN); } else{ USART_RX_STA|=0x8000;	//接收完成了 check_flag = count_odd_numbers(2); USART_RX_BUF[1] = USART_RX_BUF[1] - '0'; if(USART_RX_BUF[0] == '\t'&amp;&amp; USART_RX_BUF[1] == check_flag ) // 判断帧头是否正确、判断奇偶校验位是否正确 || USART_RX_BUF[1] == check_flag { float value = 0; int16_t sign = 1; int a = 2; for (int i = a; i &lt; (USART_RX_STA&amp;0X3FFF); i++) { value = value * 10 + USART_RX_BUF[i] - '0';	} action = sign * value; USART_RX_STA = 0;	memset(USART_RX_BUF,0,USART_REC_LEN); } else{ USART_RX_STA = 0;	memset(USART_RX_BUF,0,USART_REC_LEN); } }	} else //还没收到0X0D {	if(Res==0x0D) USART_RX_STA|=0x4000; else {	USART_RX_BUF[USART_RX_STA&amp;0X3FFF]=Res ; USART_RX_STA++; if(USART_RX_STA&gt;(USART_REC_LEN-1)) { USART_RX_STA=0;//接收数据错误,重新开始接收 memset(USART_RX_BUF,0,USART_REC_LEN); }	}	} } } } 将传输的数据转化为浮点数（正负） stm32发送端 motor_position = Read_Encoder_Angle(Encoder); sensor_position = Get_Adc_Average_Angle(Adc); motor_velocity = Read_Encoder_Speed(Encoder); sensor_velocity = Get_Adc_Average_Speed(); sprintf(data_str, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba31b3cc992e94885d0a64e0ff41196a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da1fb659fff6dbcee31e96f470ef7223/" rel="bookmark">
			Java 微信商家打款到零钱（旧版本接口）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		旧版微信支付接口要求请求时携带证书请求
构建请求参数
/** * 付款到零钱 * * @param withdrawalDto dto撤军 * @return {@link Map }&lt;{@link String }, {@link Object }&gt; * @throws Exception 异常 * @Author chen 2023-07-27 15:04 */ private Map&lt;String, Object&gt; payToUser(WithdrawalDto withdrawalDto) throws Exception { log.info("发起微信提现零钱请求"); Map&lt;String, String&gt; paramMap = new HashMap&lt;&gt;(); // 公众账号appid paramMap.put("mch_appid", wechatConfig.getAppId()); // 微信支付分配的商户号 paramMap.put("mchid", wechatConfig.getMchId()); // 随机字符串，不长于32位。 paramMap.put("nonce_str", RandomUtil.randomString(16)); // 商户订单号,需保持唯一性 paramMap.put("partner_trade_no", withdrawalDto.getSerialNo()); // 商户appid下，某用户的openid paramMap.put("openid", withdrawalDto.getCardNo()); //校验用户姓名选项 NO_CHECK：不校验真实姓名 FORCE_CHECK：强校验真实姓名 paramMap.put("check_name", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da1fb659fff6dbcee31e96f470ef7223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c497e410e995cbff1d2a8ce12c84715a/" rel="bookmark">
			RD授权宽限期已过，且该服务尚未向安装有许可证的授权服务器注册。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一台Windows Server 2008 R2服务器出现了如下提示：
RD授权宽限期已过，且该服务尚未向安装有许可证的授权服务器注册。需要使用RD授权服务器才能继续操作。在没有授权服务器的情况下，远程桌面会话主机服务器可以在初始启动之后运行120天。
​同样，还可能出现如下的气泡提示：
远程桌面服务将停止工作，原因是此计算器已超过其授权宽限期。单击此消息打开RD会话主机服务器配置工具，以便指定RD授权模式并指定要使用的许可证服务器。
在继续下面的文章前，先保证你
的Windows Server 2008 R2服务器已经激活
1、依次单击“管理工具”→“远程桌面服务”→“远程桌面授权管理器”
在打开的“RD授权管理器”窗口可以看到“激活状态”是“没有激活” 选中服务器并右键单击“激活服务器”。 首先出现的是“服务器激活向导”界面，我们单击“下一步”进入“连接方法”选择界面，我们选择“自动连接(推荐)”，然后单击下一步。 单击“下一步”的过程中，可能会提示“正在查找Microsoft Clearinghouse服务器”的提示，此时你只需要耐心等待即可。
在“公司信息”窗口填写好相关信息，单击“下一步”即可。
此时，还会需要你填写“省/自治区”等资料，可以不填写，直接单击“下一步”。 此时系统会提示你“正在激活许可证服务器”，耐心等待吧。 到达“正在完成服务器激活向导”界面，单击“下一步”。
8、进入“欢迎使用许可证安装向导”界面，单击“下一步”。 服务器会提示“正在查找Microsoft Clearinghouse服务器”的提示，此时你只需要耐心等待即可。
服务器进入“许可证计划”界面，在“许可证计划”下拉框中选择“企业协议”。然后单击下一步
在“输入协议号码”界面中的“协议号码”文本框内输入自己公司的协议号，然后单击“下一步” 在“请选择产品版本和许可证类型”界面中，“产品版本”选择“Windows Server 2008 或 Windows Server 2008 R2”，“许可证类型”选择“每用户CAL(TS或RDS)”，“数量”里面填300。然后单击“下一步”。
server2008 R2会提示“正在安装远程桌面服务客户端访问许可证...”
稍等片刻，就提示“您已完成许可证安装想到”，已成功安装TS、RDS或VDI CAL。单击“完成”即可。
可以看到“RD授权管理器”提示“激活状态”为“已激活” 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/250111dc8cbca924d419dc5502f54e62/" rel="bookmark">
			【C&#43;&#43;】类和对象——拷贝构造函数、运算符重载、日期类实现、const成员、取地址操作符重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 拷贝构造函数运算符重载日期类实现const成员取地址及const取地址操作符重载 拷贝构造函数 拷贝构造函数：只有单个形参，该形参是对本类类型对象的引用(一般常用const修饰)，在用已存在的类类型对象创建新对象时由编译器自动调用。
拷贝构造函数也是特殊的成员函数，其特征如下：
1、 拷贝构造函数是构造函数的一个重载形式。
2、 拷贝构造函数的参数只有一个且必须是同类型对象的引用，使用传值方式编译器直接报错，因为会引发无穷递归调用。
class Date { public: Date(int year = 1, int month = 1, int day = 1) { _year = year; _month = month; _day = day; } Date(Date&amp; d)//拷贝构造函数要加引用 { cout &lt;&lt; "Date(Date&amp; d)" &lt;&lt; endl; _year = d._year; _month = d._month; _day = d._day; } void print() { cout &lt;&lt; _year &lt;&lt; "/" &lt;&lt; _month &lt;&lt; "/" &lt;&lt; _day &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/250111dc8cbca924d419dc5502f54e62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa18ad25a16b342dbdc0103432080673/" rel="bookmark">
			java操作minio删除文件夹及其文件方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 因java项目需求，要删除minio服务文件夹和下面的所有文件，百度了一下，没有查到有用的方法，自己也查看了minio jar包中的方法，也没发现删除文件夹的，不过，网上百度查到，只要删除文件夹下的所有文件，文件夹就自动删除了。自己也亲自验证，于是有了一个思路。
教程 ： pom文件所需依赖
&lt;!--minio--&gt; &lt;dependency&gt; &lt;groupId&gt;io.minio&lt;/groupId&gt; &lt;artifactId&gt;minio&lt;/artifactId&gt; &lt;version&gt;3.0.10&lt;/version&gt; &lt;/dependency&gt; 主要代码示例
原理，根据bucket名称和文件夹名称，先用listObjects方法 查出所有匹配的文件列表，然后用removeObject方法循环删除。只要匹配文件夹的查出的文件列表全部删除，文件也会被删除，及时文件夹下还有文件夹也都可以匹配出来，然后删除。
/** * 删除文件夹及文件 * * @param bucketName bucket名称 * @param objectName 文件或文件夹名称 * @since tarzan LIU */ private void deleteObject(String bucketName, String objectName) { try { if (StringUtils.isNotBlank(objectName)) { if (objectName.endsWith(".") || objectName.endsWith("/")) { Iterable&lt;Result&lt;Item&gt;&gt; list = minioClient.listObjects(bucketName, objectName); list.forEach(e -&gt; { try { minioClient.removeObject(bucketName, e.get().objectName()); } catch (InvalidBucketNameException invalidBucketNameException) { invalidBucketNameException.printStackTrace(); } catch (NoSuchAlgorithmException noSuchAlgorithmException) { noSuchAlgorithmException.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa18ad25a16b342dbdc0103432080673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da110c9ab17ba713db9dba9990b07a69/" rel="bookmark">
			若依打印sql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方issue
自动生成的代码，sql日志怎么没有打印
在ruoyi-admin中的application.yml配置如下。
# 日志配置，默认 logging: level: com.ruoyi: debug org.springframework: warn #添加配置 com.ying: debug 输出sql
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/686b791dc43378c00dea9155ec23259a/" rel="bookmark">
			生化危机5找不到xlive.dll，要如何修复xlive.dll缺失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有朋友反映说他在玩生化危机5的时候，突然电脑就弹出一个找不到xlive.dll，然后游戏就打不开了，一直都很懵逼，不知道怎么处理这个问题，今天小编就来给大家详细的讲讲，找不到xlive.dll要怎么去修复！
一. xlive.dll是什么文件 xlive.dll是Games for Windows - LIVE软件包中的动态链接库文件。它是微软创建的一个在线游戏平台，旨在提供社交功能、成就系统和其他多人游戏功能。xlive.dll文件支持相关游戏运行所需的服务和接口。
二. 缺失xlive.dll的后果 如果系统缺少xlive.dll文件，你可能会遇到以下问题：
游戏无法启动：由于缺失了xlive.dll文件，生化危机5无法加载所需的Games for Windows - LIVE功能，因此游戏无法启动。
保存和加载问题：xlive.dll还包含了游戏数据的保存和加载功能。缺失该文件可能导致无法正常保存和加载游戏进度。
三. 修复生化危机5找不到xlive.dll的方法 以下是一些常见的修复方法，可帮助你解决生化危机5找不到xlive.dll文件的问题：
安装Games for Windows - LIVE：
前往Microsoft官方网站下载并安装最新版的Games for Windows - LIVE软件包。这将确保系统具备所需的xlive.dll文件以及相关的游戏服务和接口。
使用dll修复工具：
主要dll修复工具是针对于各种dll文件的修复的，它会检测你电脑缺失了哪些dll文件，然后根据扫描检测的结果，自动帮你进行一键修复，在操作来说非常的简单，没有什么门槛，就算是电脑小白也能轻松操作。直接在百度上搜索电脑修复精灵，进入官方站点下载一个dll修复工具。
DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
更新游戏补丁：
查找并应用生化危机5的最新游戏补丁。有时，游戏开发者会发布补丁来修复已知问题，包括xlive.dll缺失问题。通过更新游戏补丁，可能会解决该错误并提供其他性能改进。
下载并安装xlive.dll文件：
从可信赖的来源下载xlive.dll文件，并将其复制到生化危机5游戏目录中。确保下载的dll文件版本与你的操作系统兼容，以避免不兼容性问题。
以上就是关于生化危机5找不到xlive.dll的一些相关分享，希望本文能帮助到大家，如果想了解更多，欢迎继续关注小编哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41773eac9def4adb6b06c87a8bd31d75/" rel="bookmark">
			Python编程之子进程管理(subprocess)详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言模块介绍subprocess.run()实例 subprocess.Popen()实例 注意 Reference 引言 在写程序时，我们无法避免需要运行外部程序，相较于功能比较简单的os.system()，更加倾向于使用subprocess模块来执行外部程序。
模块介绍 subprocess.run() 使用subprocess.run()执行命令的时候，父进程会一直等待直到子进程结束后才会继续运行父进程
subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, capture_output=False, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, text=None, env=None, universal_newlines=None, **other_popen_kwargs) """ 参数介绍 1. args: cmd命令 2. stdin: 传递参数进来 3. input: 传递参数进来，使用input的时候不能使用stdin 4. stdout: 外部程序的输出，可以指定通过管道(subprocess.PIPE) 5. stderr: 外部程序的报错输出, 可以指定通过管道(subprocess.PIPE)或者和stdout使用同一句柄(stderr=subprocess.STDOUT) 6. capture_output: 同时获取stdout和stderr 7. shell: 是否通过shell执行命令 8. cwd: 命令执行的工作目录 9. timeout: 如果超时则终止子进程，该参数被传递给Popen.communicate() 10. check: 检查returncode是否为0，如果不为0则引发subprocess.CalledProcessError错误, 可以通过try....except...捕获 11. encoding: 编码类型 12. errors: 13. text: 可用来代替universal_newlines 14.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41773eac9def4adb6b06c87a8bd31d75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550ed090d2b9aa0b55f4e82e94542da2/" rel="bookmark">
			[CentOS]Chkrootkit后门检测工具的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具介绍： Chkrootkit 工具用来监测 rootkit 是否被安装到当前系统中。rootkit 是 攻击者经常使用的后门程序。这类后门程序通常非常隐秘、不易被察觉，植入后， 等于为攻击者建立了一条能够长时间入侵系统或可对系统进行实时控制的途径。 因此，使用 chkrootkit 工具可定时监测系统，以保证系统的安全。 在使用 chkrootkit 时，若出现 infected，则说明检测出系统后门；若未出现， 则说明未检测出系统后门;
第一步 ：安装编译工具包 yum install gcc gcc-c++ make yum install glibc-static 第二步：安装Chkrootkit Step1.下载软件包 wget https://src.fedoraproject.org/repo/pkgs/chkrootkit/chkrootkit-0.57.tar.gz/sha512/ff35f01042bc68bdd10c4e26dbde7af7127768442c7a10f114260188dcc7e357e2c48d157c0b83b99e2fd465db3ed3933c84ae12fa411c5c28f64b955e742ff7/chkrootkit-0.57.tar.gz Step2.解压软件包 tar zxvf chkrootkit-0.57.tar.gz Step3.进入目录 cd chkrootkit-0.57 Step4.安装程序 make sense Step5.拷贝到安装目录 mv /usr/local/src/chkrootkit-0.57 /usr/local/chkrootkit 第三步：使用Chkrootkit进行检查 用法一.全局检查 /usr/local/chkrootkit/chkrootkit 检查结果如下，如果出现了INFECTED，则说明检测出系统后门；
ROOTDIR is `/' Checking `amd'... not found Checking `basename'... not infected Checking `biff'... not found Checking `chfn'... not infected Checking `chsh'... not infected Checking `cron'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/550ed090d2b9aa0b55f4e82e94542da2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9192a850d00bf731bd7e4f3e435ae2a/" rel="bookmark">
			Python - 从字典列表中删除字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字典是python的一个非常常用的功能，用于根据用户需要在其中存储数据。另一个典型的过程涉及编辑或操作此数据。要成为一名高效且快速的程序员，您必须弄清楚如何从字典列表中删除字典。有许多技术可以从词典列表中删除字典，本文将介绍这些技术。
从字典列表中删除字典的不同方法 循环方式 我们将指定要从字典列表中删除的字典，然后我们将使用 if（） 创建一个条件来提供一个参数以从字典列表中删除字典。通过以下示例，我们可以更清楚地理解：
例 # Dictionaries Cities = [ {"City": "Bangalore", "location": "India"}, {"City": "Toronto", "location": "Canada"}, {"City": "Liverpool", "location": "England"}, {"City": "kano", "location": "Nigeria"}, {"City": "Sydney", "location": "Australia"}, {"City": "Berlin", "location": "Germany"}, {"City": "New York", "location": "USA"} ] Remove = "Liverpool" #Specifying the dictionary to be removed for city in Cities: # Checking all the different dictionaries if city["City"] == Remove: #Creating a condition Cities.remove(city) #If the condition is satisfied remove() method will be used print(Cities) #Display the output after removing the dictionary 输出 程序的输出将如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9192a850d00bf731bd7e4f3e435ae2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa47907e7c3b30f0d769c70f41535de4/" rel="bookmark">
			【rabbitMQ】MQ过期时间、死信队列实现-狂飙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 一、队列参数二、过期时间TTL2.1、队列过期时间2.1、消息过期时间 三、死信队列3.1、生产者3.2、消费者 一、队列参数 简单认识通过@Bean 创建消息队列的同时，设置对象的参数，完成的不同的效果
参数名类型作用x-message-tti(Time-To-Live)int，毫秒对消息设置预期的时间，过期将被丢弃x-max-lengthint限制队列最大长度,个数，新增后删除最早的x-expiresint，毫秒队列没有访问超时时，自动删除时间x-max-length-bytesint限制队列最大容量x-dead-letter-exchangestring指定死信交换机x-dead-letter-routing-keystring死信路由，指定routingKeyx-max-priorityint队列优先级x-queue-mode默认"lazy"对列模式，默认lazy（将数据放入磁盘，消费时放入内存）x-queue-master-locatorQueueBuilder.MasterLocator主队列选择策略,min-masters:选择承载最小绑定主机数量的节点,client-local:选择客户机声明队列连接到的节点,min-masters:随机选择一个节点 二、过期时间TTL 2.1、队列过期时间 设置队列的TTL后，每个被放入此队列的消息都有一个过期时间，时间一过，这条消息就会被移除了。
// 创建 direct 交换机 @Bean public DirectExchange directExchange() { return new DirectExchange("TTLExchange", true, false); } @Bean public Queue TTLQueue() { //使用map进行多值的设置，同时可以使用链式进行相同的操作 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 队列设置消息过期时间 60 秒 map.put("x-message-ttl", 60 * 1000); // .... //参数一： 队列的名称 //参数二： 队列是都持久化 //参数三： 队列是否具有排他性（只有同一连接共享此队列，且连接断开时队列删除）排他队列详细说明 //参数四： 队列是否自动删除 //参数五： 封装队列的一些参数 return new Queue("TTLQueue", true, false, false, map); } // 绑定关系 @Bean public Binding smsBinding() { // 绑定关系。并且设置 'ttl' 的routingKey return BindingBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa47907e7c3b30f0d769c70f41535de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb1d63c0e1546676589504ec0e9c5ad4/" rel="bookmark">
			scrapy框架简单实现豆瓣评分爬取案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		豆瓣网址：https://movie.douban.com/top250
1.创建scrapy框架 scrapy startproject 项目名(scrapy_test_one) 创建好以后的目录是这样的 2.创建spider文件 在spiders目录下创建一个spider_one.py文件，可以随意命名，该文件主要是让我们进行数据爬取的。
运行命令：
scrapy genspider spider_one baidu.com 注意末尾的域名是用来设置爬取的范围的
spider_one.py代码如下
import scrapy from scrapy import Request from scrapy_test_one.items import ScrapyTestOneItem # from scrapy.selector import HtmlXPathSelector class SpiderOneSpider(scrapy.Spider): name = "spider_one" allowed_domains = ['movie.douban.com/top250'] start_urls = ['https://movie.douban.com/top250'] def parse(self, response, *args): movie_items = response.xpath('//div/ol[@class="grid_view"]') # print("======================",movie_items) for item in movie_items: movie = ScrapyTestOneItem() # src = item.xpath('//li/div/div/a/img/@src').extract_first() # print("===================",src) # movie["img"] = src title = item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb1d63c0e1546676589504ec0e9c5ad4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ec9fc6bb51500fda30cc2135e0aba04/" rel="bookmark">
			FreeRTOS——操作系统介绍、手动移植代码与CubeMx创建FreeRTOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FreeRTOS简介
1.嵌入式操作系统
嵌入式操作系统是为了区别于通用的计算机操作系统，人们把嵌入到对象体系中，为实现对象体系智能化控制的计算机操作系统，称作嵌入式计算机操作系统，简称嵌入式操作系统。
嵌入式操作系统分类：
②按对外部事件的响应能力来分类，嵌入式操作系统分实时操作系统和分时操作系统。
如果操作系统能及时的响应外部事件请求，并能控制所有实时设备和实时任务协调运行，且能在一个规定的时间内完成对事件的处理，那么这种系统就称为实时操作系统。
如果操作系统按时间片轮转完成各个任务，任务没有优先级，这种系统就称为分时操作系统。
②按时间的严格程度来分，实时操作系统又分为强实时操作系统和弱实时操作系统。系统必须在极其严格的时间内完成的任务叫做硬实时操作系统，比如飞机系统；如果不是很严格的话就是弱实时操作系统，比如信息采集系统。
2.FreeRTOS 实时操作系统
FreeRTOS 是一款开源免费的实时操作系统，商业使用的话不需要用户公开源代码，也不存在任何版权问题，是当前小型嵌入式操作系统市场使用率最高的。
FreeRTOS 的移植比较简单，只需要用户添加需要的源码文件，不需要做任何的底层工作，再添加几个宏定义即可。
裸机系统与多任务系统
1.裸机系统
裸机编程时，先初始化相关的硬件，然后让主程序在一个死循环里面不断地循环，顺序地处理各种事件。对于紧急事件，采用中断功能进行快速响应。
比如：
2.多任务系统
相比于裸机系统，多任务系统的事件处理是在任务中完成的，对于紧急事件，同样采用中断功能进行快速响应。
多任务系统通常包含多个任务，彼此独立，方便编程，同时，任务具有优先级，高优先级任务可以打断低优先级任务，系统的实时性进一步得到提高。
比如：
引入操作系统后，在编程时不需要精心设计程序执行流，任务间不存在干扰。当然，系统需要占用一定的RAM和FLASH资源。 手动移植FreeRTOS代码
第一步：官网下载FreeRTOS源码
官网网址：http://www.freertos.org,进入后点击 下载FreeRTOS
第二步：准备基础工程，这里用的是之前使用的流水灯工程为基础（或自行建立一个工程即可），延时时钟基准由SysTick改到Tim2（任意空闲的定时器都行），删除主循环内的代码。
FreeRTOS操作系统使用SysTick作为基准时钟
第三步：将FreeRTOS源码添加至工程中，设置头文件路径，编译工程。
将FreeRTOS源码复制到工程中，另外，将portable与RVDS文件夹多余的文件删除 Keil工程新建2个Groups-FreeRTOS/Source与FreeRTOS/Port，同时添加相应的文件 添加头文件路径 第四步：将FreeRTOSConfig.h文件（位于Demo-CORTEX-STM32F103_Keil工程中）添加至工程MyApplication文件内，方便打开与修改，同时添加至MyApplication组内，再次编译。
第五步：修改FreeRTOSConfig.h文件并编译。
这一步编译后还会出现3个错误，原因是图中下面框中的3个自行增加的宏定义与中断文件，即stm32f1xx_it.c中的3个函数定义重合，将中断文件里的3个函数注射掉即可。下图是其中1个函数。
进行这一步的原因是为了FreeRTOS操作系统中的3个函数名与实际相联系，便于理解操作。
第六步：工程添加MyTask.c文件，用于以后建立任务（使用结构体的方式创建任务），同时MyApplication.h头文件中添加FreeRTOS与MyTask的头文件。
MyTask_t MyTask = { AppTaskCreate }; /* * @name AppTaskCreate * @brief 创建应用任务 * @param None * @retval None */ static void AppTaskCreate() { xTaskCreate(vTaskLED1, "vTaskLED1", 512, NULL, 1, &amp;xHandleTaskLED1); xTaskCreate(vTaskLED2, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ec9fc6bb51500fda30cc2135e0aba04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/071be8026dedb77914417dd251317621/" rel="bookmark">
			JS中的defineProperty
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在js中object.defineProperty方法能够让我们对对象的底层进行修改，例如：
首先创建一个新对象
let obj = { "name" : "future", "age" : 21 } 再通过object.defineProperty方法对其值进行修改
object.defineProperty(obj, "age", { value: 22 }) console.log(obj.age) // 22 在对对象的值修改后，我们再尝试使用对象赋值的方法来对值进行修改
obj.age = 18 console.log(obj.age) // 22 可以看到使用对象赋值的方法失效了，这是因为使用object.defineProperty对对象的属性进行修改或赋值后，会默认将该属性变为不可修改，想再次修改的话只能通过其中增加writable：true的属性。
object.defineProperty(obj, "age", { value: 22 writable: true // 默认为false }) console.log(obj.age) // 22 obj.age = 18 console.log(obj.age) // 18 在object.defineProperty这个方法中，还可以设置某一个属性是否可以被枚举（枚举就是循环对象所有的属性以及属性中包含的值）。字段为enumerable，默认值同样为false
object.defineProperty(obj, "age", { value: 22 }) console.log(obj.age) // 22 for (let prop in obj) { console.log(prop) // 只有name属性 } object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/071be8026dedb77914417dd251317621/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f13f0d2ef059ecd942e2181731ed601/" rel="bookmark">
			PyTorch快速安装并验证GPU是否可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 步骤一：PyTorch官网安装 PyTorch官网：https://pytorch.org/
根据PyTorch官网的安装提示，选择合适版本后会生成安装语句，拷贝安装语句到Anaconda相应虚拟环境中，即可一键安装。 步骤二：检查GPU是否可用 进入环境： ipython
导入pytorch包： import torch
查看cuda是否可用： torch.cuda.is_available()​
查看cuda设备的数量： torch.cuda.device_count()​
查看当前使用的cuda编号： torch.cuda.current_device()​
查看GPU设备名： torch.cuda.get_device_name()​
查看设备容量： torch.cuda.get_device_capability(0)​
在PyCharm中检查GPU是否可用 代码： import torch def gpu_is_available(): print('\nGPU details:') print(f' gpu_is_available : ', torch.cuda.is_available()) print(f' cuda_device_count : ', torch.cuda.device_count()) print(f' cuda_device_name : ', torch.cuda.get_device_name()) print(f' cuda_device_capability: ', torch.cuda.get_device_capability(0)) gpu_is_available() 效果： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b074129f855842a321ffcf440a469e53/" rel="bookmark">
			关于VMware Ubuntu明明有大量硬盘空间却提示硬盘空间不足的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因：我编译RK3568的SDK时，编译停止了，提示硬盘空间不足。
虚拟机的硬件配置：
再看了一下电脑的硬盘情况：
空间应该是足够的啊，为什么会提示硬盘空间不足？
然后就查了一下ubuntu的硬件情况，这才发现了问题。
可以看到主存最大也就50G左右啊，那么大的分配空间都去哪里了？
————————————————————————————————————————
实际上就和window上磁盘管理工具一样，扩展的空间是未分配的，未分配的当然无法使用。
ubuntu下使用 gparted 来管理磁盘空间。
安装：
sudo apt-get install gparted 使用：
sudo gparted 可以看到未分配的空间居然有250G。
点一下 /dev/sda1 ，然后再点击：
剩下15G作为 swap 分区。
在未分配区右键：
点击新建。
15G全用上，选择创建为：扩展分区。然后点击添加。
再次对为分配区右键，选择新建：
将文件系统类型选择为：linux-swap。
最后点击操作栏的 √ 就完成分配了。
再次查看磁盘空间，发现已经增大了很多了：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97457a9662d2fbbdbffb8c1097be5e47/" rel="bookmark">
			C盘爆红怎么扩容磁盘容量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、打开磁盘管理器
二、分割D盘空间
三、转移D盘文件
四、给C盘扩容
五、新加卷重命名为D盘
一、打开磁盘管理器 鼠标右击电脑的开始菜单,然后点击"磁盘管理"选项
(快捷键方式启动:先按下win键+x键,再按下shift键+k键)
二、分割D盘空间 鼠标右击D盘,压缩卷
输入压缩的空间大小,这里比如说我想只给D盘留下40G左右的空间(如果你D盘数据太多,就多分配一点),其余的100G都分配给C盘,1G=1024M,所以输入40000
然后就会多出一个未分配的磁盘,鼠标右击这个磁盘,新建简单卷(按照操作向导无脑点"下一步"就可以了)
三、转移D盘文件 然后到文件资源管理器里将D盘里的文件全部移到压缩出的新加卷F盘里
再回到磁盘管理器,将D盘删除,D盘就成为了未分配的空间
四、给C盘扩容 右击C盘,选择"拓展卷" (因为我这里是做演示,我的磁盘空间是足够的,没有删除D盘,所以扩展卷这个选项是灰色的)
五、新加卷重命名为D盘 鼠标右击新加卷F盘,选择"更改驱动器号和路径"-&gt;"更改"(同样的,我没有删除D盘,所以驱动器号没有D这个选项)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b86db40a86686331790f727379616daf/" rel="bookmark">
			NOsql之MongoDB入门分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、MongoDB简介
1、概念理解
2、yum安装部署
3、二进制安装部署
4、配置文件解析 二、MongoDB基本管理
1、登录操作
2、管理命令
3、用户管理
一、MongoDB简介 1、概念理解 关系型数据库（RDBMS:Relational Database Management System) MySql、Oracle、DB2、SQL Server…关系型数据库中全都是表 非关系型数据库（No Sql --Not only sql）(Sql:结构化查询语言) MongoDB(文档数据库,json格式)、Redis…键值对数据库 Mongodb逻辑结构 MySQL逻辑结构 库database ====== 库 集合(collection) ====== 表 文档(document) ====== 数据行 2、yum安装部署 vim /etc/yum.repo.d/mongodb.repo [mongodb-org] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.6/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-3.6.asc #添加mongodb的yum源 yum install -y mongodf-org #直接yum安装 systemctl start mongod #启动mongod服务 mongo #本地直接登录mongodb数据库 3、二进制安装部署 useradd mongod passwd mongod #创建用户 mkdir -p /data mkdir -p /mongodb/conf mkdir -p /mongodb/log mkdir -p /mongodb/data #创建MongoDB需要的目录 cd /data tar xf mongodb-linux-x86_64-rhel70-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b86db40a86686331790f727379616daf/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/107/">«</a>
	<span class="pagination__item pagination__item--current">108/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/109/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>