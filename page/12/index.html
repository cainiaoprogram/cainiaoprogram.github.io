<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74470ead869129e95bb14b7b6cd3ab7c/" rel="bookmark">
			各红外线通信协议解码(通用型)【NEC、Sony SIRC、RC-5、RC-6、Samsung】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、通信协议1. NEC2. Sony SIRC3. RC-5、RC-6、Samsung 二、数据抓取分析三、程序设计实现 红外线通信协议解码 是指将接收到的红外线信号转换为可理解的数字数据，以便对其进行进一步处理和操作的过程。红外线通信协议解码通常用于遥控器接收器等设备中。
在红外线通信中，遥控器发送器使用特定的红外线协议来编码命令和数据，并通过红外线发射器将这些信息转换为红外线信号。接收器捕获这些红外线信号，并通过解码过程将其还原为原始的命令和数据。
一、通信协议 1. NEC NEC红外协议是一种最常见的红外遥控协议，通常用于电视遥控器、空调遥控器等。NEC协议通过调制红外载频信号来表示数字信号。每个数字信号由9ms的起始位和4.5ms的起始位隔开，然后由16位地址码、16位数据码和8位反码构成。地址码用于区分不同的遥控器设备，数据码表示遥控器键值。接收设备在解码后，通过判断地址码和数据码来判断是哪个键被按下。
传输的数据帧格式为引导码 + 8位用户码 + 8位用户反码 + 8位数据码 + 8位数据反码
如下所示：
位定义：
在引导码之后，通过各位值去计算用户码与数据码，当检测到0.56ms的低电平+0.56ms的高电平时记为该位为0，当检测到0.56ms的低电平+1.68ms的高电平时记为该位为1。
由上可知：
引导码： 红外接收口(空闲时低电平)接收到上升沿的跳变，即9ms的上升沿随即4.5ms的低电平；32位数据： 每八位组成一个字节用于记录用户码与数据码 2. Sony SIRC Sony SIRC使用双向编码（又称曼彻斯特编码），使用40K载波对编码后的波形进行调制，位时间长度 1.2ms 或 0.6ms，有12 位，15 位和 20 位三个版本，这里介绍12位。
位定义： 1.2ms 的 40K 载波脉冲重现逻辑“1”，0.6ms 重现逻辑“0”。脉冲间隔均位 0.6ms。
数据帧格式：
（1） 帧定时基于600µS脉冲宽度T的倍数。
（2）帧以4T开始标记脉冲开始。
（3）帧中的每个位由1T空格表示，如果该位是“0”，则后跟1T标记；如果该位是“1”，则后跟2T标记
（4）若遥控器按键一直按下，命令码会每 45ms 重复发送一次。
3. RC-5、RC-6、Samsung RC-5红外协议也是一种常见的红外遥控协议，常用于DVD遥控器、音响遥控器等家电设备中。RC-5协议将每个红外信号分为两个连续的半周期。每个半周期由1.778ms的载频信号和1.778ms的无载频信号组成。一个完整的信号由13位二进制数据构成，其中1位为起始位，5位为地址码，6位为命令码，1位为反码。接收设备通过解码操作,根据地址码和命令码执行相应的功能。
RC-6红外协议是RC-5的升级版，具有更高的功能扩展性和更低的误码率。RC-6协议将红外信号延长到2.667ms的载频信号和2.667ms的无载频信号。一个完整的信号由20位二进制数据构成，其中1位为起始位，2位为系统码，5位为地址码，8位为命令码，1位为反码，3位为扩展码。接收设备在解码后，根据地址码和命令码进行区分和执行命令。
Samsung红外发射协议是一种红外通讯协议，常用于家电控制等领域。该协议使用38kHz的载波信号进行通讯，并采用了脉冲宽度编码(PulseWidth Modulation，PWM)技术。具体来说，每个数据位通过一系列的载波事件来表示，其中高电平载波事件表示0，低电平载波事件表示1。每个数据位的载波事件数量和载波事件持续时间的长短均不相同，这种编码方式可以有效地减少数据传输时的冗余信息，提高传输效率。在三星红外发射协议中，载波时间是指将38kHz载波信号分成若干个时间片段，每个时间片段的持续时间称为载波时间。具体来说，每个数据位由一组高低电平的载波事件组成，其中高电平载波事件表示0，低电平载波事件表示1。每个数据位的载波事件数量和载波事件持续时间的长短均不相同，但是每个时间片段的持续时间是固定的，通常为1.125ms或2.25ms。在使用三星红外发射协议进行通讯时，发送方需要按照协议规定的载波时间序列来发送数据，接收方则需要根据协议规定的载波时间序列来解码数据。
二、数据抓取分析 这里我抓取一种自定义红外传输协议数据，具体操作如下：
将红外发射器上电，持续发送数据 准备红外接收器，将示波器通道接上输出口，对准发射器，随机抓取一针数据分析 如下：
选取某一帧数据具体分析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74470ead869129e95bb14b7b6cd3ab7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7353254df796ff512a08d8f6ab259fc2/" rel="bookmark">
			【Python实战】一个星期练完这30个精心整理的Python项目案例，成功逆袭：靠接单月入W＋轻轻松松，拿走就用~（大家冲鸭）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 Python是目前最流行的语言之一，它在数据科学、机器学习、web开发、脚
本编写、自动化方面被许多人广泛使用。它的简单和易用性造就了它如此流行
的原因。
🚀 **文章源码免费获取 ：为了感谢每一个关注我的小可爱💓 每篇文章的项目源码都是无偿分享滴💓 在本文中，我们将会带大家学习到30个案例实战从入门案例到精通，你可以
在更短的时间里理解和学习这些小案例。
学习编程是一个比较枯燥的过程，所以木子平常喜欢分享一些有趣、有料的
Python原创项目实战。主要有Python基础、爬虫、数据分析、数据可视化、
Pygame游戏等内容。
当然最受欢迎的还是大家最喜欢的游戏案例跟爬虫实战案例。
这里精选了30多个Python实战案例，不仅包含源码，还有使用教程。
今天小编给大家各方面Python案例都挑一挑，看看那些是你还没学习过的？
那些是学会了滴啦
正文 本文展示的30个案例实战都是有源码的哈，大部分还有详细的视频详解，大
家需要的滴滴我。
一、🎐从零到十案例
1）案例展示
2）某宝秒杀案例
主程序——
import datetime import time from selenium import webdriver now = datetime.datetime.now().strftme('%Y-%m-%d %H:%M:%S.%f') times = "2022-03-03 21:07:00.00000000" driver = webdriver.Chrome(r'C:\Users\Tony\PycharmProjects\Module_Tony_Demo\Moudle_游戏源码锦集\chromedriver.exe') driver.get("https://www.taobao.com") time.sleep(3) driver.find_element_by_link_text("亲，请登录").click() print(f"请尽快扫码登录") time.sleep(20) driver.get("https://cart.taobao.com/cart.htm") time.sleep(3) # 是否全选购物车 while True: try: if driver.find_element_by_id("J_SelectAll1"): driver.find_element_by_id("J_SelectAll1").click() break except: print(f"找不到购买按钮") while True: # 获取时间 now = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f') print(now) # 判断 - if now &gt; times: # 结算 while True: try: if driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7353254df796ff512a08d8f6ab259fc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d918d197afdcf66d0e3a459c9d97a19/" rel="bookmark">
			9. 回文数(Java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述： 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。
回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
例如，121 是回文，而 123 不是。
输入： x = -121
输出： false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
代码实现： public class Main{ public static void main(String[] args) { int x = 12121; System.out.println(isPalindrome(x)); } public static boolean isPalindrome(int x) { //将原数转换为字符串 String s = String.valueOf(x); //再将字符串转换为StringBuilder StringBuilder sb = new StringBuilder(s); //调用反转函数，得到反转结果并转化为字符串 String res = sb.reverse().toString(); //比较反转前后的字符串 return res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d918d197afdcf66d0e3a459c9d97a19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c104b199a37fc7ace5ff62f9d88303d1/" rel="bookmark">
			15_LearnOpenGL 光照材质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		光照材质 在真实世界里，每个物体会对光产生不同的反应。钢看起来比陶瓷花瓶更闪闪发光，一个木头箱子不会像钢箱子一样对光产生很强的反射。每个物体对镜面高光也有不同的反应。有些物体不会散射(Scatter)很多光却会反射(Reflect)很多光，结果看起来就有一个较小的高光点(Highlight)，有些物体散射了很多，它们就会产生一个半径更大的高光。如果我们想要在OpenGL中模拟多种类型的物体，我们必须为每个物体分别定义材质(Material)属性。
在前面的教程中，我们指定一个物体和一个光的颜色来定义物体的图像输出，并使之结合环境(Ambient)和镜面强度(Specular Intensity)元素。当描述物体的时候，我们可以使用3种光照元素：环境光照(Ambient Lighting)、漫反射光照(Diffuse Lighting)、镜面光照(Specular Lighting)定义一个材质颜色。通过为每个元素指定一个颜色，我们已经对物体的颜色输出有了精密的控制。现在把一个镜面高光元素添加到这三个颜色里，这是我们需要的所有材质属性：
#version 330 core struct Material { vec3 ambient; vec3 diffuse; vec3 specular; float shininess; }; uniform Material material; 在片段着色器中，我们创建一个结构体(Struct)，来储存物体的材质属性。我们也可以把它们储存为独立的uniform值，但是作为一个结构体来储存可以更有条理。我们首先定义结构体的布局，然后简单声明一个uniform变量，以新创建的结构体作为它的类型。
就像你所看到的，我们为每个冯氏光照模型的元素都定义一个颜色向量。ambient材质向量定义了在环境光照下这个物体反射的是什么颜色；通常这是和物体颜色相同的颜色。diffuse材质向量定义了在漫反射光照下物体的颜色。漫反射颜色被设置为(和环境光照一样)我们需要的物体颜色。specular材质向量设置的是物体受到的镜面光照的影响的颜色(或者可能是反射一个物体特定的镜面高光颜色)。最后，shininess影响镜面高光的散射/半径。
这四个元素定义了一个物体的材质，通过它们我们能够模拟很多真实世界的材质。这里有一个列表devernay.free.fr展示了几种材质属性，这些材质属性模拟外部世界的真实材质。下面的图片展示了几种真实世界材质对我们的立方体的影响：
如你所见，正确地指定一个物体的材质属性，似乎就是改变我们物体的相关属性的比例。效果显然很引人注目，但是对于大多数真实效果，我们最终需要更加复杂的形状，而不单单是一个立方体。在[后面的教程](https://learnopengl-cn.readthedocs.io/zh/latest/03 Model Loading/01 Assimp/)中，我们会讨论更复杂的形状。
为一个物体赋予一款正确的材质是非常困难的，这需要大量实验和丰富的经验，所以由于错误的设置材质而毁了物体的画面质量是件经常发生的事。
让我们试试在着色器中实现这样的一个材质系统。
我们在片段着色器中创建了一个uniform材质结构体，所以下面我们希望改变光照计算来顺应新的材质属性。由于所有材质元素都储存在结构体中，我们可以从uniform变量material取得它们：
void main() { // 环境光 vec3 ambient = lightColor * material.ambient; // 漫反射光 vec3 norm = normalize(Normal); vec3 lightDir = normalize(lightPos - FragPos); float diff = max(dot(norm, lightDir), 0.0); vec3 diffuse = lightColor * (diff * material.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c104b199a37fc7ace5ff62f9d88303d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3149b11caa51dbd16fccf92045d351b6/" rel="bookmark">
			c&#43;&#43; std::move()到底干了什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每次用到或者看到std::move() ，总会被它的名字误导，以为是发生了数据所有权的移动。然而实际上，std::move()啥都没干，只是改变了其入参的属性，让它成为了一个右值。
std::move() 是 C++ 中一个很有用的函数，它用于将传递给它的对象转换为右值引用。它并不实际移动数据，而是改变了对象的分类，使得在函数中可以使用移动语义。
std::move()的实现非常简单，它实际上只是将传递给它的对象强制转换为对应的右值引用。这是一个简单的实现示例：
template &lt;typename T&gt; constexpr std::remove_reference_t&lt;T&gt;&amp;&amp; move(T&amp;&amp; arg) noexcept { return static_cast&lt;std::remove_reference_t&lt;T&gt;&amp;&amp;&gt;(arg); } 这个实现中使用了模板函数 move()，它接受一个通用引用 T&amp;&amp; 作为参数。在函数内部，static_cast 将传递给它的参数强制转换为对应的右值引用类型。std::remove_reference_t 用于移除 T 类型的引用，这样可以确保返回一个右值引用。
实际上，std::move() 并不执行任何实际的操作，它只是一个简单的类型转换工具，用于告诉编译器将一个对象视为右值，以便在移动语义的上下文中使用。通过使用 std::move()，你可以在某些情况下提高程序的性能，例如在移动语义可用的情况下，显式地调用移动构造函数或移动赋值运算符。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e96346e20e661cfce73921f0026b6aa/" rel="bookmark">
			Concurrency in CSharp Cookbook中文翻译：5.5数据流块并行处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem 问题 You want to perform some parallel processing within your dataflow mesh. 您希望在数据流网格中执行一些并行处理。 Solution 解决方案 By default, each dataflow block is independent from each other block. When you link two blocks together, they will process independently. So, every dataflow mesh has some natural parallelism built in. 缺省情况下，每个数据流块之间是相互独立的。当您将两个块连接在一起时，它们将独立处理。因此，每个数据流网格都有一些自然的并行性。 If you need to go beyond this—for example, if you have one particular block that does heavy CPU computations—then you can instruct that block to operate in parallel on its input data by setting the MaxDegreeOfParallelism option.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e96346e20e661cfce73921f0026b6aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df0e6710a41fc6e3d8af72edb7361cd0/" rel="bookmark">
			自动驾驶代客泊车360环式系统及倒车雷达功能规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 文档总概. 8
1.1. 范围. 8
1.2. 名词解释. 8
1.3. 相关应用文档. 8
1.3.1. 文档优先说明. 8
1.3.2. 政府法规与文件. 9
1.3.3. 行业规范与文件. 9
1.3.4. 百度及客户提供相关功能定义文档. 9
2. 系统概述. 10
2.1. 整车网络拓扑. 10
2.2. 系统硬件条件. 10
2.3. 系统架构框图. 11
3. 雷达PAS/SDW功能. 12
3.1. 功能清单. 12
3.2. 功能概述. 12
3.2.1. 功能描述. 12
3.2.2. 关联系统描述. 12
3.3. 工作模式. 13
3.3.1. 状态机. 13
3.3.2. 状态描述. 13
3.3.3. 状态迁移条件. 14
3.4. 交互信号. 15
3.4.1.1. 输入信号. 15
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df0e6710a41fc6e3d8af72edb7361cd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fbb96ab0f1766f0849db288a74fae34/" rel="bookmark">
			代客泊车低速紧急制动辅助系统MEB功能规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1文档总概. 4
1.1范围. 4
1.2名词解释. 4
1.3.1文档优先说明. 4
1.3.2政府法规与文件. 4
1.3.3行业规范与文件. 4
1.3.4百度及客户提供相关功能定义文档. 5
2系统概述. 6
2.1整车网络拓扑. 6
2.2系统硬件条件. 6
2.3系统架构框图. 7
3 MEB（紧急制动）功能. 7
3.1功能清单. 7
3.2功能描述. 7
3.2.1设计运行条件要求. 8
3.2.1.1通用条件要求. 8
3.2.1.2障碍物识别条件要求. 8
3.2.1.3静态障碍物识别场景要求：. 9
3.2.1.4动态物体识别场景要求：. 11
3.2.2功能局限性. 15
3.2.2.1超声波雷达工作环境限制. 15
3.2.2.2摄像头工作环境限制. 16
3.3工作模式. 17
3.3.1状态机. 17
3.3.2状态描述. 17
3.3.3状态迁移描述. 18
3.4交互信号. 19
3.5功能定义. 21
3.5.1系统电源状态. 21
3.5.1.1 网络休眠状态. 21
3.5.1.2 唤醒状态. 21
3.5.2系统自检. 21
3.5.2.1系统内部状态检测. 21
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fbb96ab0f1766f0849db288a74fae34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd02a81b2f1d222ca09ef630fce7cee3/" rel="bookmark">
			Full names for abbreviations of Linux Commands
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		synopsis Towards/On Full names for abbreviations of Linux Commands I) website addressII) Mapping between full names and abbreviations I) website address II) Mapping between full names and abbreviations su：Swith user 切换用户，切换到root用户
cat: Concatenate 串联
uname: Unix name 系统名称
df: Disk free 空余硬盘
du: Disk usage 硬盘使用率
chown: Change owner 改变所有者
chgrp: Change group 改变用户组
ps：Process Status 进程状态
tar：Tape archive 解压文件
chmod: Change mode 改变模式
umount: Unmount 卸载
ldd：List dynamic dependencies 列出动态相依
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd02a81b2f1d222ca09ef630fce7cee3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82d7ccc24bde157f3b888ebf7f6703f7/" rel="bookmark">
			云卷云舒：算力网络&#43;云原生（中）：探索构建算力网络数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云卷云舒：算力网络+云原生（上）：打造云网边端协同架构_算力网络和云原生-CSDN博客
算力网络时代的数据库是什么样子的？这是一个值得探索的课题，本文简单的做一下个人思考的分享，欢迎讨论。
一、导言 1、基础要求：算力网络时代，数据类型、范围充分延展和爆发，数据库也要适应起来，分布式数据库是起步要求；
2、近期需求：通过云服务的方式提供算网时代，尤其是智能大模型所需要的向量数据库，赋能大模型接入提效；
3、战略机遇：算网数据库是一个双向赋能的产物，会催生更多新型形态的数据库产品，数据库服务于算力网络、也受益于算力网络。
二、算力网络时代数据库的特征 1、形态多样，内核丰富：数据库要满足的应用场景得到延展，必然会覆盖HTAP、多模向量、代理/网关数据库等多种形态；
2、构建标准：云原生将必然成为事实标准，云原生的极致弹性、标准分层内生、不可变基础设施等概念和优势将充分发挥。目前看来也只有“云原生”可以一统江湖，让大家守江湖规矩，避免畸形的技术发展，算网原生是未来一个标准趋势。
3、技术要求：
智能：算力网络情况下的资源调度必然成为常态，应对数据分散和传输必然需要智能化手段保证；另外数据的实体分散对于属地化独立分散的运维来讲将变得不可行，智能运维手段是必选；大模型在数据库查询检索效率提升方面的应用也将越发广泛；容量：智能会促使数据几何增长，整个网络所能管理的节点、关系上限就对数据库容量提出要求。所以说容量也将是新的数据库技术竞争高地；软硬融合：与硬件融合，而且与算力设备的兼容将成为必选，包括主节点硬件一体化保证元数据存储扩展性和安全，分节点需要保证快速入网，实现对于不同品牌的国产化设备的兼容性保证；后续对于产品的纳管也将包括硬件、协议、组件、设备内网络等新的部分。深度分布式：算力网络时代，全省甚至全国计算资源并网，带来了数据库极大分散，那么数据的碎片化程度必然更高，只有和智能手段结合，才能补齐分布存储的传输压力；平台化布局：不言而喻，平台化要解决数据库分层管控问题、产品规格差异性底座协同问题、数据库内核和镜像版本管理、开放能力等难题。 4、技术壁垒降低：随着国产化的崛起，数据库技术的新竞争高地将转移，并向上转移，从传统的内核壁垒转向上层，我们姑且称之为“分布式智能调度内核”，管控的重要性不言而喻，从而国内广大的国产化数据库厂商将崛起，呈现百花齐放的竞争态势；
5、数据库all卸载：笔者也大胆预测一条，数据库的边界与存储将进一步模糊，具有智能和管控的存储也将是数据库领域未来必将考虑的一条路，但是同时带来的产品非标的情况将进一步劣化，需要做好数据库平台化的管控方能解决这个问题。
三、突破口、演进路线探索 1、统一标准，构建上层智能分布式调度的标准将是未来实现引领的杀手锏，分层设计需要考虑到运营输入层、运算引擎层、运算接入层，每一层基于云原生构建规范标准，跨层通信构建分布式、解耦的新传输协议，可以说是一种更高级别的分布式系统；
2、人工智能和大模型场景，可能是未来算力网络数据库的一个突破口。
3、数据库卸载到存储，数据库的特性在算力网络时代必将分散化到多点，极致分散化的数据库可能就是一个捎带智能化和管控能力的存储，一切为了“最低成本的满足需求”，被调度的需求。所以基于高效存储构建一些极致简单的数据库，不失为一种选择。
参考：
云卷云舒：算力网络+云原生（下）：云数据库发展的新篇章-CSDN博客
云卷云舒：从云网融合到算力网络-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d78eaccf99d1c4c059604b27b57991ac/" rel="bookmark">
			使用Django框架自带的Form表单完成简单的用户登录注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果不知道怎么配置Django环境以及如何连接数据库请点击我的上一篇博客：
使用pycharm初始化Django框架并连接Sql Server
文章目录 1.Django默认生成的数据表2.用户登录2.1创建登录页面2.2视图处理登录请求2.3配置访问路径 3.用户注册3.1创建用户表单3.2创建注册模版页面3.3创建视图注册处理函数3.4配置 URL 4.效果演示4.1注册4.2登录 1.Django默认生成的数据表 auth_user： 存储用户的基本信息，包括用户名、密码（加密后）、电子邮件、姓名等。这个表用于支持用户身份验证系统。auth_group： 存储用户组的信息，用于对用户进行分组管理。auth_permission： 存储权限信息，用于管理用户和用户组的权限。auth_user_groups： 用户和用户组的关联表，用于表示用户属于哪些用户组。auth_user_user_permissions： 用户和权限的关联表，用于表示用户具有哪些权限。django_session： 用于存储用户会话信息，包括用户的会话密钥和会话数据。django_migrations： 记录了数据库迁移的历史信息，包括迁移文件的名称、应用程序名称、迁移状态等。django_content_type： 用于存储模型的元数据信息，包括模型的应用程序名称、模型名称等。django_admin_log： 用于记录管理员操作日志的表，包括了对数据的增删改查等操作记录。
这些默认数据表是 Django 框架提供的核心组件，用于支持其内置功能，如身份验证、权限管理、会话管理等。它们可以根据需要进行扩展和定制，也可以通过 Django 的 ORM（对象关系映射）来进行操作和查询。本次登录注册可以使用auth_user这张数据表来完成。 2.用户登录 2.1创建登录页面 在Django项目中template目录创建user_login.html
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Login&lt;/title&gt; &lt;style&gt; body { font-family: Arial, sans-serif; background-color: #f4f4f4; margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; height: 100vh; } .login-container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d78eaccf99d1c4c059604b27b57991ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b963b24089466eee98e3e699af496b5f/" rel="bookmark">
			如何卸载Windows11下面应用商店下载的软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以卸载Ubuntu为例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70815a21b5e405447b5bbdb142878ca1/" rel="bookmark">
			常见加密算法梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见加密算法梳理 1. 前言2. 常见加密算法2.1. 散列算法（不可逆加密）2.1.1. MD52.1.2. SHA-256 2.2. 对称加密算法2.2.1. DES2.2.2. AES 2.3. 非对称加密算法2.3.1. RSA 3. 加密算法应用：Https 1. 前言 在当今的信息时代，数据的安全性显得尤为重要，加密算法作为保障数据安全的核心手段，在过去的几十年中经历了巨大的发展。信息加密是前后端开发都经常需要使用到的技术，应用场景包括了数据存储、网络通信、身份认证等等，不同的应用场景也会需要使用到不同的签名加密算法，或者需要搭配不一样的签名加密算法来达到业务目标。这里简单的给大家介绍几种常见的签名加密算法和一些典型场景下的应用。
2. 常见加密算法 2.1. 散列算法（不可逆加密） 2.1.1. MD5 MD5是一种广泛使用的散列算法，产生一个128位哈希值。它通常用于验证数据的完整性和一致性，但由于存在碰撞攻击，现在被认为不够安全（攻击者可以通过暴力破解或彩虹表攻击等方式破解），虽然可以通过加盐，也就是对在原文里再加上一些不固定的字符串来缓解，但是完全可以用更安全的SHA系列算法替代
public class MD5 { private static final String MD5_ALGORITHM = "MD5"; public static String encrypt(String data) throws Exception { // 获取MD5算法实例 MessageDigest messageDigest = MessageDigest.getInstance(MD5_ALGORITHM); // 计算散列值 byte[] digest = messageDigest.digest(data.getBytes()); Formatter formatter = new Formatter(); // 补齐前导0，并格式化 for (byte b : digest) { formatter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70815a21b5e405447b5bbdb142878ca1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c43c151841a615ce65cf9294a76fd6f8/" rel="bookmark">
			又一个yyds的Python可视化神器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源丨网络
一、问题 如果想把多个图合并放在一个图里，如图，该如何实现
好在R语言 和 Python 都有对应的解决方案， 分别是patchwork包和patchworklib库。
二、R语言 安装
# install.packages("devtools") devtools::install_github("thomasp85/patchwork") 两个图并排在一行，只需要导入patchwork， 然后相加即可
library(ggplot2) library(patchwork) p1 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp)) p2 &lt;- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear)) p1 + p2 两行，第一行三个图，第二行一个图
p3 &lt;- ggplot(mtcars) + geom_smooth(aes(disp, qsec)) p4 &lt;- ggplot(mtcars) + geom_bar(aes(carb)) (p1 | p2 | p3) / p4 三、Python Patchworklib 是与 matplotlib 相关的绘图（简单 matplotlib 绘图、Seaborn 绘图（轴级和图形级）和plotnine 绘图）的通用编辑器。这个库的灵感来自于 ggplot2 的patchwork。因此，作为原始拼凑，用户可以轻松地仅使用/和|对齐 matplotlib 图。
Patchworklib 提供了该问题的解决方案。通过使用 patchworklib，任何类型的seaborn 和plotnine 图都可以作为matplotlib 子图进行处理。安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c43c151841a615ce65cf9294a76fd6f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e88a472df931e7b1a62226c4d2dbdc/" rel="bookmark">
			基于图像合成和注意力的深度神经网络从计算机断层扫描灌注图像中自动分割缺血性脑卒中病变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Automatic ischemic stroke lesion segmentation from computed tomography perfusion images by image synthesis and attention-based deep neural networks 基于图像合成和注意力的深度神经网络从计算机断层扫描灌注图像中自动分割缺血性脑卒中病变背景贡献实验Comparison of different loss functions for pseudo DWI synthesis（伪DWI合成中不同损失函数的比较）Effect of feature extractor on pseudo DWI synthesis（特征提取器对伪DWI合成的影响）对比试验Comparison of different training loss functions for segmentation（分割损失函数对比）特征提取器和伪DWI生成器对分割的影响（合成分割联合训练的对比） 方法Feature extraction from raw spatiotemporal CTA imagesPseudo DWI synthesis from CTP imagesSLNet: stroke lesion segmentation network with switchable normalization and channel calibration（SLNet：具有可SN和通道校准的脑卒中病变分割网络） Thinking 基于图像合成和注意力的深度神经网络从计算机断层扫描灌注图像中自动分割缺血性脑卒中病变 Medical Image Analysis 65 (2020) 101787
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14e88a472df931e7b1a62226c4d2dbdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31b5e3f6bca40a5bf7850d77c16165b8/" rel="bookmark">
			Rust学习笔记-常见的编程概念-Rust中的关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rust学习笔记 常见的编程概念 关键字 Rust 语言有一组保留的 关键字（keywords），就像大部分语言一样，它们只能由语言本身使用。记住，你不能使用这些关键字作为变量或函数的名称。大部分关键字有特殊的意义，你将在 Rust 程序中使用它们完成各种任务；一些关键字目前没有相应的功能，是为将来可能添加的功能保留的。可以在附录 A 中找到关键字的列表。
目前正在使用的关键字 如下关键字目前有对应其描述的功能。
as - 强制类型转换，消除特定包含项的 trait 的歧义，或者对 use 语句中的项重命名async - 返回一个 Future 而不是阻塞当前线程await - 暂停执行直到 Future 的结果就绪break - 立刻退出循环const - 定义常量或不变裸指针（constant raw pointer）continue - 继续进入下一次循环迭代crate - 在模块路径中，代指 crate rootdyn - 动态分发 trait 对象else - 作为 if 和 if let 控制流结构的 fallbackenum - 定义一个枚举extern - 链接一个外部函数或变量false - 布尔字面值 falsefn - 定义一个函数或 函数指针类型 (function pointer type)for - 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期if - 基于条件表达式的结果分支impl - 实现自有或 trait 功能in - for 循环语法的一部分let - 绑定一个变量loop - 无条件循环match - 模式匹配mod - 定义一个模块move - 使闭包获取其所捕获项的所有权mut - 表示引用、裸指针或模式绑定的可变性pub - 表示结构体字段、impl 块或模块的公有可见性ref - 通过引用绑定return - 从函数中返回Self - 定义或实现 trait 的类型的类型别名self - 表示方法本身或当前模块static - 表示全局变量或在整个程序执行期间保持其生命周期struct - 定义一个结构体super - 表示当前模块的父模块trait - 定义一个 traittrue - 布尔字面值 truetype - 定义一个类型别名或关联类型union - 定义一个 union 并且是 union 声明中唯一用到的关键字unsafe - 表示不安全的代码、函数、trait 或实现use - 引入外部空间的符号where - 表示一个约束类型的从句while - 基于一个表达式的结果判断是否进行循环 保留做将来使用的关键字 如下关键字没有任何功能，不过由 Rust 保留以备将来的应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31b5e3f6bca40a5bf7850d77c16165b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e01049c6c0fb47f3aa0527823980e5f/" rel="bookmark">
			软件测试|MySQL LIKE：深入了解模糊查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在数据库查询中，模糊查询是一种强大的技术，可以用来搜索与指定模式匹配的数据。MySQL数据库提供了一个灵活而强大的LIKE操作符，使得模糊查询变得简单和高效。本文将详细介绍MySQL中的LIKE操作符以及它的用法，并通过示例演示其功能。
基本语法 MySQL中的LIKE操作符用于模糊匹配数据表中的文本字段。它允许使用通配符来代替具体的字符，从而实现更广泛的匹配。LIKE操作符的基本语法如下：
SELECT column1, column2, ... FROM table_name WHERE column_name LIKE pattern; 其中，column1, column2, ... 是你想要查询的列，table_name 是你要查询的表，column_name 是要进行模糊匹配的字段，pattern 是匹配的模式。在pattern中可以使用通配符% 和_，分别代表匹配任意多个字符和匹配一个字符。
使用示例 假设我们有一个名为products的数据表，其中包含product_name列，我们将使用这个表来演示LIKE操作符的用法。
简单模糊查询 首先，我们来查找所有产品名称中包含"apple"的产品：
SELECT * FROM products WHERE product_name LIKE '%apple%'; 这个查询将返回所有产品名称中包含"apple"的记录，无论"apple"出现在产品名称的任何位置。
匹配开头或结尾的字符 接下来，我们查找所有以"iPhone"开头的产品：
SELECT * FROM products WHERE product_name LIKE 'iPhone%'; 这个查询将返回所有以"iPhone"开头的产品记录。
类似地，如果要查找所有以"Pro"结尾的产品，可以使用以下查询：
SELECT * FROM products WHERE product_name LIKE '%Pro'; 匹配特定字符 有时，我们想要匹配特定位置的字符，可以使用_通配符。例如，我们想要查找所有名称为"A_S"（其中"A"和"S"是两个特定的字符）的产品：
SELECT * FROM products WHERE product_name LIKE 'A_S'; 组合使用通配符 我们还可以组合使用通配符来实现更复杂的匹配。例如，我们想要查找所有产品名称以"A"开头且包含"phone"的产品：
SELECT * FROM products WHERE product_name LIKE 'A%phone%'; 注意事项 在使用LIKE操作符进行模糊查询时，需要注意以下几点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e01049c6c0fb47f3aa0527823980e5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1293bfe56bb5e53f5b92177e92cac852/" rel="bookmark">
			软件测试|MySQL WHERE条件查询详解：筛选出需要的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在数据库中，我们常常需要从表中筛选出符合特定条件的数据，以便满足业务需求或获取有用的信息。MySQL提供了WHERE条件查询，使我们能够轻松地筛选数据。本文将详细介绍MySQL WHERE条件查询的用法和示例，帮助大家更好地理解和应用这一功能。
WHERE条件查询的基本语法 SELECT 列1, 列2, ... FROM 表名 WHERE 条件; 其中：
SELECT: 指定要查询的列名。FROM: 指定要查询的表名。WHERE: 表示开始筛选部分。条件: 指定筛选数据的条件，可以是一个或多个条件的组合。条件可以使用比较运算符（例如：&gt;, &lt;, &gt;=, &lt;=, =, &lt;&gt;）和逻辑运算符（例如：AND, OR, NOT）来构建复杂的查询。 使用示例 为了更好地理解WHERE条件查询的用法，假设我们有一个名为employees的表，其结构如下：
CREATE TABLE employees ( id INT PRIMARY KEY, name VARCHAR(50), age INT, department VARCHAR(50), salary DECIMAL(10, 2) ); 现在，我们向employees表中插入一些示例数据：
INSERT INTO employees (id, name, age, department, salary) VALUES (1, 'Alice', 30, 'HR', 50000.00), (2, 'Bob', 25, 'IT', 45000.00), (3, 'Charlie', 35, 'Finance', 60000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1293bfe56bb5e53f5b92177e92cac852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a222d14ba9c3c7bc61e545475f22035/" rel="bookmark">
			【技术选型】clickhouse vs starRocks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比对结论 如果只能单机部署的话，clickhouse基本无敌。
如果集群化，starRocks可以替换clickhouse，但支持的函数会相对少一些（clickhouse有不少自定义函数）
信息比对 功能clickhousestarRocksjoin大表关联容易OOM对join有相关优化场景比较适合大宽表对于星形或者雪花模型的兼容性更好并发性大量短查询，每秒不超过100次数千用户同时分析查询，部分场景是万级数据导入更新相对比较慢，更适合静态数据秒级的数据导入和实时更新，提供准实时的服务mysql兼容性不完全完全兼容内置函数非常丰富。支持窗口和聚合函数，以及table function支持窗口和聚合函数部署单机版无敌，分布式相对不友好默认分布式，这就意味着需要的资源更多分布式需要代码实现部分布式的能力。例如，建表需要先本地表在分布式表，可以类比于物化视图。且数据分布，需要手动分发，不支持自动处理正常的分布式系统 参考文档 数据仓库系列：StarRocks的简单试用及与clickhouse的对比_starrocks clickhouse对比-CSDN博客
ClickHouse vs StarRocks 选型对比
性能比对 Star Schema Benchmark（以下简称 SSB）是学术界和工业界广泛使用的一个星型模型测试集，通过这个测试集合可以方便的对比各种 OLAP 产品的基础性能指标。ClickHouse 通过改写 SSB，将星型模型打平转化成宽表 (flat table)，改造成了一个单表测试 benchmark。本报告记录了 StarRocks、ClickHouse 和 Apache Druid 在 SSB 单表数据集上的性能对比结果，测试结论如下：
在标准测试数据集的 13 个查询上，StarRocks 整体查询性能是 ClickHouse 的 2.1 倍，Apache Druid 的 8.7 倍。StarRocks 启用 Bitmap Index 后整体查询性能是未启用的 1.3 倍，此时整体查询性能是 ClickHouse 的 2.8 倍，Apache Druid 的 11.4 倍。 参考文档 SSB Flat Table 性能测试 | StarRocks
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc753ed2a15d1278bd75bc8f02740e88/" rel="bookmark">
			kotlin substring/substringAfter/substringAfterLast/substringBefore/substringBeforeLast
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 kotlin substring 的作用：
字符串截取
substringAfter的作用：
截取掉首次出现之前的字符，就是保留首次出现指定字符后面的内容
substringAfterLast的作用：
截取掉最后出现之前的字符，就是保留最后出现指定字符后面的内容
substringBefore的作用：
与substringAfter相反，保留首次出现字符之前的内容
substringBeforeLast的作用：
与substringAfterLast相反，保留最后出现字符之前的内容
val str1 = "helloworld" //截取字符串 Log.d("======substring",str1.substring(0..3)) // 打印结果hell //截取掉首次出现之前的字符，就是保留首次出现指定字符后面的内容 Log.d("======substringAfter",str1.substringAfter("o")) // 打印结果world //截取掉最后出现之前的字符，就是保留最后出现指定字符后面的内容 Log.d("======substringAfterLast",str1.substringAfterLast("o")) // 打印结果rld //与substringAfter相反，保留首次出现字符之前的内容 Log.d("======substringBefore",str1.substringBefore("o"))// 打印结果hell //与substringAfterLast相反，保留最后出现字符之前的内容 Log.d("======substringBeforeLast",str1.substringBeforeLast("o")) // 打印结果hellow 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddf5f461b995b96059b91fae8ea22849/" rel="bookmark">
			C&#43;&#43;其他语法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 《C++基础语法总结》《C++面向对象语法总结(一）》《C++面向对象语法总结(二）》《C++面向对象语法总结(三）》 一、运算符重载 运算符重载可以为运算符增加一些新的功能全局函数、成员函数都支持运算符重载常用的运算符重载示例 class Point { // friend Point operator+(const Point &amp;, const Point &amp;); friend ostream &amp;operator&lt;&lt;(ostream &amp;, const Point &amp;); friend istream &amp;operator&gt;&gt;(istream &amp;cin, Point &amp;point); int m_x; int m_y; public: Point(int x, int y) :m_x(x), m_y(y) {} void display() { cout &lt;&lt; "(" &lt;&lt; m_x &lt;&lt; ", " &lt;&lt; m_y &lt;&lt; ")" &lt;&lt; endl; } Point(const Point &amp;point) { m_x = point.m_x; m_y = point.m_y; } const Point operator+(const Point &amp;point) const { return Point(m_x + point.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddf5f461b995b96059b91fae8ea22849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39da859f3d9447eb417c865677175b07/" rel="bookmark">
			面试宝典之ElasticSearch面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		E01、什么是倒排索引？ ES分词器通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这种建立索引的方式叫倒排索引。
当数据写入 ES 时，数据将会通过 分词 被切分为不同的term，ES 将term 与其对应的文档列表建立一种映射关系，这种结构就是 倒排索引。如下图所示：
参考文章 E02、ES脑裂是怎么回事？（扩展） 脑裂问题，就是同一个集群中的不同节点，对于集群的状态，有了不一样的理解。
由于并发访问量的提高，导致了我们两个节点的集群（分片数默认为5，副本为1，没有固定的master，都是集群中的节点又做data又做master）状态变成了red，出现了大量的坏片，并且坏掉的都是主分片及其副本。分析发现，是ES集群出现了脑裂问题（俗称精神分裂），即**集群中不同的节点对于master的选择出现了分歧，出现了多个master竞争，导致主分片和副本的识别也发生了分歧，对一些分歧中的分片标识为了坏片。**
理解思路 原因1：网络问题，导致由多个主原因2：主节点负载过大 E03、“脑裂”问题是怎么形成的？（扩展） 1.网络问题：集群间的网络延迟导致一些节点访问不到master，认为master挂掉了从而选举出新的master，并对master上的分片和副本标红，分配新的主分片
2.节点负载：主节点的角色既为master又为data，访问量较大时可能会导致ES停止响应造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。
3.内存回收：data节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应。
E04、脑裂问题如何解决？（扩展） 1、减少误判。discovery.zen.ping_timeout节点状态的响应时间，默认为3s，可以适当调大，减少误判。
2、选举触发。discovery.zen.minimum_master_nodes:1，该参数是用于控制选举行为发生的最小集群主节点数量。增大该参数，这样参与选举的节点增多，减少选举。
3、角色分离：即master节点与data节点分离，限制角色。
主节点配置为：
node.master: true node.data: false
从节点配置为：
node.master: false node.data: true
E05、ES如何添加自定义词库、热更新词库？（扩展） 我们项目中使用中文分词器IK分词器。
1、在ik插件对应的配置文件目录下创建一个自定义词库文件 my.dic。直接在文件中添加词语即可，每一个词语一行。
2、修改ik的IKAnalyzer.cfg.xml配置文件。
3、将修改好的IK配置文件复制到集群中的所有节点中。
4、重启ES验证一下自定义词库的分词效果。
E06、ES如何分页？ 默认情况下，不加from，size的话，ES会返回前10条记录。加上from，size就会查询指定的条数。其中from代表起始行号，size代表查询行数。
1、深度分页（from+size）
2、快照查询（scroll）
3、Search After
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2414e9c65dc0560c42e556e027d9d8ed/" rel="bookmark">
			面试宝典之消息中间件面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMq: 1、RabbitMQ有啥用处？ （1）服务间异步通信
（2）顺序消费
（3）定时任务
（4）请求削峰
2、RabbitMQ有哪些常用的工作模式？ 工作模式（Work）发布订阅模式（Fanout）路由模式（Routing）主题模式（Topic） 3、如何保证RabbitMQ消息不被重复消费？ 通过消费端处理，每条消息分配唯一的id，消费端在消费的时候验证，过滤掉重复的消息。使用乐观锁实现，保证接口的幂等性。 4、如何保证RabbitMQ消息的可靠传输？ 发送端：
（1）开启Confirm模式（消息确认机制或者事务模式）。
（2）如果消息发送失败做补偿处理，记录日志重新发送等，确保消息最终发送成功。
队列：
（1）声明交换机，队列的时候设置持久化参数。
（2）发送消息的时候设置消息的持久化参数，队列消息持久化到磁盘上，即便是宕机，重启之后消息依旧还在。
接收端：
（1）接收端开启手动应答模式。
（2）确定消息处理完成，消费端再向队列确认消费，删除消息。
（3）消费端如果处理异常，记录日志，通过其他补偿机制处理，确保最终消息处理成功。
5、RabbitMQ的交换机有哪些类型？ （1）fanout：如果交换器收到消息，将会广播到所有绑定的队列上
（2）direct：如果路由键完全匹配，消息就被投递到相应的队列
（3）topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符
6、Topic模式时，Routingkey中的#号和*号有什么区别？ #号标识0个字符、1个字符、多个字符*号表示1个或者多个字符 RocketMQ: 基础
1.为什么要使用消息队列呢？
消息队列主要有三大用途，我们拿一个电商系统的下单举例：
解耦：引入消息队列之前，下单完成之后，需要订单服务去调用库存服务减库存，调用营销服务加营销数据……引入消息队列之后，可以把订单完成的消息丢进队列里，下游服务自己去调用就行了，这样就完成了订单服务和其它服务的解耦合。
异步：订单支付之后，我们要扣减库存、增加积分、发送消息等等，这样一来这个链路就长了，链路一长，响应时间就变长了。引入消息队列，除了更新订单状态，其它的都可以异步去做，这样一来就来，就能降低响应时间。
削峰：消息队列合一用来削峰，例如秒杀系统，平时流量很低，但是要做秒杀活动，秒杀的时候流量疯狂怼进来，我们的服务器，Redis，MySQL各自的承受能力都不一样，直接全部流量照单全收肯定有问题啊，严重点可能直接打挂了。
我们可以把请求扔到队列里面，只放出我们服务能处理的流量，这样就能抗住短时间的大流量了。
解耦、异步、削峰，是消息队列最主要的三大作用。
2.为什么要选择RocketMQ?
市场上几大消息队列对比如下：
RabbitMQ ActiveMQ RocketMQ Kafka
公司 Rabbit Apache 阿里 Apache
语言 Erlang Java Java Scala&amp;Java
协议支持 AMPQ OpenWire、STOMP、REST、 XMPP、AMQP 自定义 自定义协议，社区封装了http协议支持
客户端支持语言 官方支持Erlang、Java、Ruby等，社区查出多种API，几乎支持所有语言 Java、C、C++、Python、PHP、Perl，.net 等 Java、C++（不成熟） 官方支持Java，社区产出多种API，如PHP，Python等
单击吞吐量 3.万级 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2414e9c65dc0560c42e556e027d9d8ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b06a5a3fc7e392ad57c71e1ab6ac2a/" rel="bookmark">
			【从零开始学技术】Fiddler 抓取 https 请求大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Fiddler代理浏览器设置 注意浏览器代理区别 Chrome/IE浏览器使用的都是系统代理设置
在chrome浏览器的设置中搜索代理，可以看到
打开IE浏览器，选择设置-&gt;Internet选项
Firefox浏览器使用的是单独的一套代理系统
在Firefox的代理设置中，我们也可以选择使用系统代理
02打开Fiddler Fiddler打开之后默认是可以抓取到Chrome/IE浏览器的请求的。
这是因为Fiddler默认会勾选“Act as system proxy on startup”，此选项会在Fiddler启动的时候作为系统代理：
我们会发现系统代理设置已经被Fiddler篡改，端口和Fiddler中保持一致：
这也就是为什么Fiddler启动之后默认可以抓取到Chrome/IE的请求，如果Firefox也想默认抓取到，按照之前的设置，选择使用系统代理即可。
此时我们只能抓取到http的请求，如果我们需要抓取https请求，还需要做如下配置。
3勾选解密https流量选项 选择Tools-&gt;Options-&gt;HTTPS，勾选"Decrypt HTTPS traffic"和“Ignore server certificate errors (unsafe)”选项：
04安装证书到系统根证书中 点击右上角Actions，选择Trust Root Certificate选项，跳出来的对话框全部选择是或者yes即可
最后会出现如下提示，表示证书已经成功安装到了系统根证书区域
我们可以打开cmd，输入cert.msc，打开证书管理器，即可看到安装的Fiddler伪装证书
重启浏览器，重启Fiddler，特别重要！！!
打开Chrome/IE，可以愉快的抓取https请求了
Fiddler可以通过安装证书解决https请求的抓取问题，此时在浏览器面前Fiddler伪装成一个https服务器，用户可以将Fiddler的伪装证书导入到系统的根证书中。
而浏览器是默认信任系统的根证书的，此时Fiddler作为中间人在真正的服务器面前伪装成浏览器的角色。
Firefox额外设置 Firefox浏览器和Chrome/IE证书管理有区别，Chrome/IE使用的是系统根证书，而Firefox有自己的一套证书管理系统
所以针对Firefox，我们还需要做另外的配置：
01导出Fiddler证书到桌面 选择Tools-&gt;Options-&gt;HTTPS，点击右上角Actions，选择Export Root Certificate to Desktop,此时在桌面可以找到导出来的证书
02安装证书到Firefox的内置根证书中 进入到Firefox的设置-&gt;搜索证书选-&gt;打开证书管理器，选择桌面的证书文件导入进来，勾选如下三个选项
重启浏览器，重启Fiddler，特别重要！！!
打开Firefox，抓取Https请求也没问题了。
Fiddler抓取App端请求 准备工作：
将手机和电脑连接到同一路由器（保证两者能够ping通） 如果使用的模拟器则不需要上面的步骤，因为模拟器是共享PC端的网络，两者网络默认就是连通的状态 查询PC端的IP地址 01配置fiddler可以抓取远程端设备请求 打开Tools-&gt;Options-&gt;Connections，勾选Allow remote computers to connect选项
为了防止PC端的浏览器的请求和App端的请求信息混乱，可以把Fiddler的监听端改下，比如改成：7777（当然，不改也是可以的）。
02手机端配置代理 进入到手机/模拟器设置，选择WLAN-&gt;连接上的WiFi热点名-&gt;手指长按，选择修改网络-&gt;勾选高级选项，代理选择手动（注意：不同手机的界面和进入的路径存在一些差异）
代理服务器主机名:PC端查询的IP地址 代理服务器端口号：Fiddler中配置的监听端口 此时我们只能抓取到http的请求，如果我们需要抓取https请求，还需要做如下配置。
03手机端安装Fiddler伪装证书 在手机端浏览器中输入
http://192.168.1.222:7777 其中192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2b06a5a3fc7e392ad57c71e1ab6ac2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0177247b3c36fa7c538690dde1d73f77/" rel="bookmark">
			kotlin map{}和mapOf{}
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		map{}的作用
map 让集合中的每个元素应用给定的转换函数（transform），然后生成并返回一个新的 List&lt;R&gt;
val numbers = listOf(1, 2, 3, 4, 5) //map 让集合中的每个元素应用给定的转换函数（transform），然后生成并返回一个新的 List&lt;R&gt; Log.d("========map", numbers.map { it * 2 }.toString()) 打印结果：[2, 4, 6, 8, 10]
maxOf {}的作用
maxOf 该函数的主要目的是在集合中找到应用 selector 函数后得到的最大值
val numbers = listOf(1, 2, 3, 4, 5) //maxOf 该函数的主要目的是在集合中找到应用 selector 函数后得到的最大值 Log.d("========maxOf", numbers.maxOf { it }.toString()) 打印结果 ： 5
demo2
data class Person(val name: String, val age: Int) val people = listOf(Person("Alice", 15), Person("Bob", 30), Person("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0177247b3c36fa7c538690dde1d73f77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33e54b62b011141fa671151e104710b9/" rel="bookmark">
			谈谈 UTF-8 标准和解码的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符集编码的历史 ASCII码 ASCII 码诞生于上世纪 60 年代的美国，它将英文字符和二进制位之间的关系做了统一规定：将 128 个英文的字符映射到一个字节的后 7 位，最前面的一位统一规定为 0。因此 ASCII 码正好使用一个字节存储一个字符，又被称为原始 8 位值，由于最高位始终为 0 ，也被称为 7 位 ASCII 编码。在 ASCII 编码中，将数字 0 映射到 48，将大写字母 A 映射到 65，将小写字母 a 映射到 97 等等。
ASCII 编码简单好用，只占用一个字节，但它只能表示 128 个字符。
非 ASCII 编码 有一些编码会允许使用一个字节的所有 bit 位都用来表示字符，这样一个字节最多就能表示 256 个字符了，比如 Latin-1 编码。简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以可以表示 65536（256 x 256）个常用的汉字符号。 Unicode 编码 Unicode 将世界上所有的符号都纳入其中，对世界上所有的符号都赋予一个独一无二的编码，那么，满足了在同一个文本信息中混合使用不同的语言文字的需求。2023 年 9 月 12 日发布的 Unicode 15.1.0 版本已经收录了 149,813 个字符，其中还包含了很多 emoji 符号。每个字符都被映射至一个整数编码，编码范围为 0~0x10FFFF 。注意，这里仅仅用了三个字节而已。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33e54b62b011141fa671151e104710b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7c7dbcb928d9bd1f5bd375a78fd4fef/" rel="bookmark">
			ROS2 Humble学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文发表与个人的github pages。部分内容未同步到这里。
想查看完整内容，请移步到ROS2 Humble学习笔记。
一、前言 2013年的时候已经接触ROS了，当时断断续续学习了一些ROS的基础知识。16年搬到深圳之后，也有幸参加过星火的一次关于ROS的一些活动。当时活动的主讲之一是CSDN上ROS知识传播界的大牛的古月和港中文的林天麟先生。然而，因为自己一直涉猎的是嵌入式领域，一直没有在ROS上有所深耕。十年过去了，我相信我的知识已经足够从头到尾做一台机器人小车（无论是嵌入式软硬件合适结构）。所以我决定开始重新学习ROS。当年ROS2还没有完成，现在ROS2的LTS版本已经是humble了（ROS的版本大体是按照字母顺序起名的，所以你可以看到进展）。
这次学习，我的目标是达到中级水平，能够按照自己的需求开发机器人系统所需要的功能包。另一方面，在工程上我希望基于手边的Jetson Nano自己制作一台机器人。在这些够完成之后，开始个人的机器人项目：Artemis。
除了ROS2的学习，我还希望同时了解和学习Nvidia的ISAAC ROS开发方法。好在我的笔记本基本满足ISAAC的最低要求。知识内存需要从16G升级到32G。目前暂且使用笔记本来开发ISAAC，后续如果实在需要服务器或者PC机，可能这将是一笔较大的投入。不过暂时先将此时放在一边。
好了，现在开始学习吧。愿计划可以达成。
二、安装 为了安装humble，我的计算机目前安装的Ubuntu22.04，这也是一个LTS版本。安装过程并不复杂，我按照官方的教程在笔记本（AMD64）和Raspberry Pi 4（ARM64）。
但是在我的Jetson Nano上遇到了问题。这是因为Nvidia对于Jetson Nano的支持并不积极，目前Nvidia的JetPack5（基于ubuntu20.04）支持的是orin系列和AVG系列。似乎JetPack 6(基于ubuntu22.04)也已经预发布了。似乎还继续支持orin和AVG系列。但按照我们对于Nvidia的了解，对于orin的支持也仅到JetPack6. Ubuntu 24.04将会是2024年另一个LTS版本，厂家的程序可能会延后半年到一年。所以nvidia未来的JetPack7可能会在2024年底或者2025年发布。相应的新Jetson硬件也应该会在2024年发布。所以如果需要购买Jetson，我们可以再等一等。暂时还是设法让Jetson Nano对humble进行支持。下面这几张图是Nvidia的产品和软件Roadmap，我觉得很讽刺的是支持的最后年限并不意味着软件和系统也跟着做相应的支持。
图1：Jetson模块消费版路线图 图2：Jetson模块工业版路线图 图3：JetPack软件路线图 在搜索了一通之后，发现目前的道路有三条。一条是容易的道路，使用别人已经编译好的容器。另一条更难的道路是自行编译ROS2使其支持ubuntu18.04.第三条是让Jetson Nano支持ubuntu22.04.因为现在属于初期阶段，不想在起步阶段就卡住。所以我暂时使用容器的方法。当然这条道路坑也很多。
2.1 Jetson Nano容器方法运行ROS2 Humble 在开始正文之前，我简单说一下为什么会选择Humble，因为这是目前的最新的LTS版本，支持时间也相对比较长。感兴趣的朋友可以去ROS网站查看一下每个版本的支持时间。
2.1.1 基础安装和尝试 Jetson Nano容器安装也是Nvidia官方支持的一部分。我们可以在他们的[链接](Jetson Containers)找到相应的说明。这个链接中包含多个ROS版本的Base、Core、Desktop镜像。
具体的安装方法可以看上面的链接中的说明。这里简单枚举一下命令：
#下载镜像到本地 sudo docker pull dustynv/ros:humble-ros-base-l4t-r32.7.1 # 通过镜像方式运行，这是一种比较节省空间的方式 sudo docker run --runtime nvidia -it --rm --network=host dustynv/ros:humble-ros-base-l4t-r36.2.0 #另一种更powerful的方式是直接clone整个仓库，然后在本都build和运行 #但是这种方式应该会占用更多空间，上手会有一定的难度。 #可以在稍微熟悉之后再尝试 2.1.2 docker运行界面程序遇到的问题和解决办法 在docker界面运行ros2后如果要运行turtlesim_node,rqt等依赖gui的程序时要怎么解决问题。
2.1.3 docker运行界面程序的IP问题 2.1.X 更多问题 2.2 与ROS相关的vscode的插件 古月的ROS2入门21讲里面里面很好的总结了ROS2开发相干的插件，这里转述如下：
ROS开发语言相关的python和C/C++插件。还有智能提示插件IntelliCode。这三个都是microsoft出的。还有CMAKE插件，古月推荐的是twxs提供的CMake插件，而不是由微软提供的CMake Tools。美化相关的除了各种主题之外还有语言插件和叫做vscode-icons的插件。（也是microsoft出品）与ROS直接相关的插件有：microsoft出的ROS(对ROS1和ROS2提供开发支持)；msg格式支持的Msg Language Support（作者是ajshort）；由smilerobotics制作的URDF插件对URDF文件提供支持； 三、ROS2基础学习 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7c7dbcb928d9bd1f5bd375a78fd4fef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/603fbf7aaf37f7056ea5431721b4e7b3/" rel="bookmark">
			linux系统关于nginx服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 nginx服务 nginx服务nginx特点IO多路复用I/O multiplexing【多并发】epoll接收请求的过程异步，非阻塞 nginx 的内部技术架构 nginx服务 nginx特点 Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like协议下发行。其特点是占有内存少，并发能力强 Nginx是一个高性能的Web和反向代理服务器, 它具有有很多非常优越的特性: 1.单机环境下参考服务器配置。并发连接数在7000-8000左右。集群模式20000+ 2.作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使Nginx尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应，感谢 Nginx 为我们选择了epoll and kqueue作为开发模型. 3.作为负载均衡服务器：Nginx 既可以在内部直接支持Rails和PHP，也可以支持作为 HTTP代理服务器 对外进行服务。Nginx用C编写, 不论是系统资源开销还是CPU使用效率都比Perlbal要好的多。 4.作为邮件代理服务器: Nginx同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器），Last.fm 描述了成功并且美妙的使用经验。 5.Nginx 安装非常的简单，配置文件非常简洁（还能够支持perl语法），Bugs非常少的服务器: Nginx启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下进行软件版本的升级。 IO多路复用 I/O multiplexing【多并发】 第一种方法就是最传统的多进程并发模型，每进来一个新的I/O流会分配一个新的进程管理。 第二种方法就是I/O多路复用，单个线程，通过记录跟踪每个I/O流(sock)的状态，来同时管理多个I/O流 。 I/O multiplexing 这里面的 multiplexing 指的其实是在单个线程通过记录跟踪每一个Sock(I/O流)的状态来同时管理多个I/O流。发明它的原因，是尽量多的提高服务器的吞吐能力。 在同一个线程里面， 通过拨开关的方式，来同时传输多个I/O流 epoll接收请求的过程 epoll会把连接请求都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。 select, poll, epoll都是I/O多路复用的具体的实现 select select会修改传入的参数数组，这个对于一个需要调用很多次的函数，是非常不友好的。 select如果任何一个sock(I/O stream)出现了数据，select仅仅会返回，但是并不会告诉你是那个sock上有数据 select只能监视1024个链接 select不是线程安全的 poll poll去掉了1024个链接的限制 poll从设计上来说，不再修改传入数组 poll仍然不是线程安全的，只能在一个线程里面处理一组I/O流。 epoll epoll可以说是I/O 多路复用最新的一个实现，epoll 修复了poll 和select绝大部分问题, 比如： epoll线程是安全的。 epoll不仅告诉你sock组里面数据，还会告诉具体哪个sock有数据 异步，非阻塞 每进来一个request，会有一个worker进程去处理。处理到可能发生阻塞的地方，比如向上游（后端）服务器转发request，并等待请求返回。这个处理的worker不会这么一直等着，发送完请求后，注册一个事件，于是他就休息去了。这就是异步。此时，如果再有request 进来，他再按这种方式处理。这就是非阻塞和IO多路复用。而一旦上游服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走。这就是异步回调。 nginx 的内部技术架构 Nginx服务器，以其处理网络请求的高并发、高性能及高效率，被广泛用于反向代理和负载均衡。 1）nginx启动时，会生成两种类型的进程，一个是主进程（Master），一个（windows版本的目前只有一个）或多个工作进程（Worker）。主进程并不处理网络请求，主要负责调度工作进程 2）服务器实际处理网络请求及响应的是工作进程（worker），在lunix系统上，nginx可以配置多个worker，而每个worker进程都可以同时处理数以千计的网络请求 3）模块化设计。nginx的worker，包括核心和功能性模块，核心模块负责维持一个运行循环（run-loop），执行网络请求处理的不同阶段的模块功能，如网络读写、存储读写、内容传输、外出过滤，以及将请求发往上游服务器等。而其代码的模块化设计，也使得我们可以根据需要对功能模块进行适当的选择和修改，编译成具有特定功能的服务器 4）事件驱动、异步及非阻塞，可以说是nginx得以获得高并发、高性能的关键因素，同时也得益于对Linux、Solaris及类BSD等操作系统内核中事件通知及I/O性能增强功能的采用，如kqueue、epoll及event ports 5）代理（proxy）设计，可以说是nginx深入骨髓的设计，无论是对于HTTP，还是对于FastCGI、memcache、Redis等的网络请求或响应，本质上都采用了代理机制。所以，nginx天生就是高性能的代理服务器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/186f471ffb3164d1ed8e2bea3b317aef/" rel="bookmark">
			Redis高可用（主从复制、哨兵模式和Cluster集群）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前瞻
主从复制
哨兵
集群
主从复制
主从复制的作用
主从复制流程
搭建Redis主从复制
实验准备
实验流程 修改 Redis 配置文件（Master节点操作）
修改 Redis 配置文件（Slave节点操作）
验证主从效果
哨兵模式
哨兵模式的作用
哨兵结构由两部分组成
故障转移机制
主节点的选举
搭建Redis哨兵模式
实验准备
实验流程 修改 Redis 哨兵模式的配置文件（所有节点操作）
编写故障切换脚本文件并在哨兵模式的配置文件中添加路径
为master服务器添加虚拟vip，用于验证主从切换后的vip漂移
启动哨兵模式
查看哨兵信息
故障模拟
群集模式
集群的作用，可以归纳为两点
数据分区
高可用
Redis集群的数据分片
搭建Redis群集模式
实验准备
实验流程 为每个端口创建配置文件
开启群集功能
启动redis节点
启动集群
测试群集
前瞻 主从复制 主从复制是高可用Redis的基础，哨兵和集群都是在主从复制基础上实现高可用的。主从复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。
哨兵 在主从复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制；哨兵无法对从节点进行自动故障转移，在读写分离场景下，从节点故障会导致读服务不可用，需要对从节点做额外的监控、切换操作。
集群 通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。
主从复制 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(Master)，后者称为从节点(Slave)；数据的复制是单向的，只能由主节点到从节点。
默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。
主从复制的作用 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。 主从复制流程 若启动一个Slave机器进程，则它会向Master机器发送一个“sync command”命令，请求同步连接。无论是第一次连接还是重新连接，Master机器都会启动一个后台进程，将数据快照保存到数据文件中（执行rdb操作），同时Master还会记录修改数据的所有命令并缓存在数据文件中。后台进程完成缓存操作之后，Master机器就会向Slave机器发送数据文件，Slave端机器将数据文件保存到硬盘上，然后将其加载到内存中，接着Master机器就会将修改数据的所有操作一并发送给Slave端机器。若Slave出现故障导致宕机，则恢复正常后会自动重新连接。Master机器收到Slave端机器的连接后，将其完整的数据文件发送给Slave端机器，如果Master同时收到多个Slave发来的同步请求，则Master会在后台启动一个进程以保存数据文件，然后将其发送给所有的Slave端机器，确保所有的Slave端机器都正常。 搭建Redis主从复制 实验准备 主节点：192.168.75.30
从节点：192.168.75.40
从节点：192.168.75.50
实验流程 修改 Redis 配置文件（Master节点操作） vim /usr/local/redis/conf/redis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/186f471ffb3164d1ed8e2bea3b317aef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/845e7359736e46d4456459d4d77de108/" rel="bookmark">
			免费用chatGPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免费用chatGPT，地址：
DocGPT - 第二大脑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d65700db59cc2768dc1860c1f40104e9/" rel="bookmark">
			图像分类任务的可视化脚本，生成类别json字典文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 之前的图像分类任务可视化，都是在train脚本里， 用torch中dataloader将图片和类别加载，然后利用matplotlib库进行可视化。
如这篇文章中：CNN 卷积神经网络对染色血液细胞分类(blood-cells)
在分类任务中，必定经历过图像预处理，缩放啊、随即裁剪啊之类的，可视化效果不太明显
本章将从数据角度出发，直接根据数据目录将图像可视化，随机展示所有图片的四张图片，可视化后并且保存
目标检测的可视化可以参考：
关于目标检测任务中，YOLO(txt格式)标注文件的可视化 关于目标检测任务中，XML(voc格式)标注文件的可视化
2. 根据目录可视化 （无需类别的json文件） 目录如下：代码应该data同一路径
2.1 代码介绍 root 传入的是文件夹路径，也就是多个类别文件夹的上一级目录
将所有图像保存，为了知道图片的类别，需要把图片的父目录保存。为了方便，这里生成一个列表文件，key 是目录类别，value 是相应的图像路径
展示的代码很简单，生成随机数，将列表的文件提取出来，然后展示四张就行了
2.2 可视化结果 可视化结果
代码会在当前目录生成刚刚可视化展示的图片
2.3 完整代码 如下：
import os import matplotlib.pyplot as plt import random from PIL import Image def main(path): classes = [i for i in os.listdir(path)] # ['cat', 'dog'] # 将所有图片按照 类别:路径 字典形式保存 images_path = [] # [{'cat': './data/train\\cat\\Baidu_0000.jpeg'}, {'cat': './data/train\\cat\\Baidu_0002.jpeg'}] for cla in classes: for i in os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d65700db59cc2768dc1860c1f40104e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fa4fd303daae6507da079b914b61555/" rel="bookmark">
			Go 如何处理死锁以提供哪些工具来检测或防死锁？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		并发是 Go 的核心特性，它使程序能够同时处理多个任务。它是现代编程的一个强大组件，如果使用正确，可以产生高效、高性能的应用程序。然而，并发性也带来了顺序编程中不存在的某些类型错误的可能性，其中最臭名昭著的是死锁。在这篇文章中，我们将探讨 Go 如何处理死锁以及它提供的用于检测或防止死锁的工具。
什么是死锁？ 在深入了解 Go 的细节之前，我们先定义一下什么是死锁。当两个或多个 goroutine 互相等待对方释放资源或完成某个操作，而没有一个 goroutine 能够继续执行时，并发程序中就会出现死锁。这相当于一场僵局，无法取得任何进展，因为每个进程都在等待对方让路。
什么是go中的死锁？ Go 设计有内置的并发支持，主要使用 goroutine 和 Channel。Goroutine 是由 Go 运行时管理的轻量级线程，而 Channels 是连接并发 Goroutine 的管道。您可以通过 Channel 发送和接收值，从而允许 goroutine 进行同步和通信。
Go 中的死锁可能发生在以下情况：
Goroutine 通过 Channel 周期性地相互等待。
Channel 是无缓冲的（或者缓冲区已满），并且一个 goroutine 正在将数据发送到没有其他 goroutine 接收的 Channel，反之亦然。
当锁未正确释放或多个 goroutine 以不一致的顺序获取锁时，锁（如sync.Mutex）的不当使用也可能导致死锁。
如何检测 go 中的死锁？ Go运行时有一个基本的死锁检测机制。如果所有 goroutine 都在睡眠，并且任何 goroutine 都不可能醒来，则运行时将发生panic，报告死锁。需要注意的是，这种检测仅适用于涉及所有 goroutine 的死锁。如果一部分 goroutine 死锁，而其他 goroutine 继续运行，则运行时将无法检测到这种情况。
如何检测和预防死锁？ 工具go vet：Go 附带了一个名为的内置分析工具go vet，它可以检查 Go 源代码并报告可疑的构造，例如无法访问的代码，并且在某些情况下，它可以警告您潜在的死锁，尽管这不是它的主要焦点。
go race：Go 的竞争检测器是一个帮助检测程序中竞争条件的工具。它通常可以指出可能导致死锁的共享资源问题，但是go race的检测逻辑实现是通过内存来做的，换句话说必须有对应单元测试进行代码覆盖，才能检测到可能的线程不安全。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fa4fd303daae6507da079b914b61555/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73fab1dd3ae5bfeff2127cfb53b52156/" rel="bookmark">
			Vscode中的node.js的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前往官网下载安装包
Node.js 中文网
选择较为稳定的版本
安装全选下一步就好了，这里可以选择配置环境变量是否自动启动node.js
在控制台输入指令如果出现了版本号就代表成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/422f55ac33aa5ac96ad76071d0e7333d/" rel="bookmark">
			操作系统期末复习 （南昌大学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人一名大三学生，最近要期末考试了自己整理一下操作系统需要复习的重点希望对大家的期末复习有帮助-
带！！的是老师着重强调的
第三章–内存管理 1.存储器的层次结构 存储器的层次
计算机系统的存储器可以分为寄存器、高速缓存、主存储器、磁盘缓存、固定磁盘、可移动存储介质等7个层次。
2.！！内存的分配方式特点（连续 非连续） 连续分配方式： 1.单一连续分配：特点：单道，分为系统区和用户区
2.固定分区分配：特点：多道，分区，大小可不等 产生内部碎片
3.动态分区分配：特点：根据进程的实际需求动态分配 产生外部碎片
动态分区分配策略：
1）首次适应算法：空闲分区以地址递增的次序链接。分配内存时从链首开始顺序查找，找到能满足第一个空闲分区的内存
2）临近适应算法：是首次适应算法的优化，从上次查找结束的位置开始重新继续查找
3）最佳适应算法：空闲分区以容量递增的次序形成空闲分区链，找到第一个能满足的空闲分区分配
4）最坏适应算法：空闲分区以容量递减的次序形成空闲分区链，找到第一个能满足的空闲分区分配
非连续分配方式： 基本分页存储管理：
为了使用内存时尽量避免碎片的产生，这就引入了分片的思想：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位划分，进程在执行时，以块为单位逐个申请主存中的块空间
分页存储的相关概念：
1）页面和页面大小：进程中的块称为页或页面，内存中的块称为叶框或页帧，外存也以同样的单位划分称为块或盘块。进程在执行时需要申请主存空间，即要为页面分配主存可用的可用页框，这就产生了页和叶框的一一对应
为了方便地址转换，页面的大小应是2的整数幂
2）地址结构：
地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量W。地址长度为32位，其中011位为页内地址，即每页大小为4KB；1231位为页号，最多允许2^20页
3）页表：
为了方便内存找到进程中每一个页面所对应的物理块块，系统为每一个进程建一张表，记录页面在内存中对应的物理块号，页表一般放在内存里，通过页表实现从页号到物理块号（页框号）的映射
页表是由页表项组成
如何确定一个逻辑地址对应的页号和页内偏移量？
页号=逻辑地址/页面大小
页内偏移量=逻辑地址%页面大小
如何通过逻辑地址找到物理地址？
通过页号查询页表得到页面在内存中的内存块号
j号内存块起始地址=j*内存块大小
页面在内存中的起始地址+页内偏移量=实际的物理地址
如果页面的大小刚好是2的整数次幂，2^k则末尾k位是页内偏移量，前面是页号
想要得到最终的物理内存地址只需要将内存块号拼接上内存偏移量就能得到物理地址
**基本地址转换机构：**用于实现逻辑地址到物理地址转变的硬件机构
将逻辑地址A转为物理地址的流程：
1.页号合法性的检查
2.如果合法，通过页号和页表始址计算找到页号对应的页表项，确定页面的内存块号
3.通过内存块号和页内偏移量来确定物理地址
每一个页表项大小是相同的，页号是“隐含的”
具有快表的地址变换机构：
快表（联想寄存器TLB）：是一种访问速度比内存快很多的高速缓存，用来存放最近访问的页表项的副本，可以加速地址转换的速度，与此对应，内存中的页表称为慢表
将逻辑地址A转为物理地址的流程：
1.算页号、页内偏移量
2.检查页号合法性
3.查快表。若命中，即可知道页面存放的内存块号，可直接进行5，为命中则进行4
4.查页表，找到页面存放的内存块号，并且将页表项复制到块表中
5.根据内存块号与页内偏移量得到物理地址
6.访问目标内存单元
计算访问一个逻辑地址的平均耗时是多少？
假设快表耗时为1，访问内存是100，
则在为引进快表之前，CPU查一次逻辑地址需要两次访问内存，第一次是查页表，第二次是查实际物理地址。平均时间是200.
在引进快表之后，由于快表的命中率为0.9，在命中后耗时为，访问一次快表和访问一次内存，时间为1+100=101，也还有可能快表未命中，耗时为201（访问一次快表+访问两次内存），综合考虑为0.1201+0.96101=111
也有CPU设计为两种访问机制同时进行，就为（1+100）0.9+200*0.1=110.9
基本分段式存储管理：
与分页最大的区别就是–离散分配时基本的单位不同
进程的地址空间：按照程序自身的逻辑关系划分为若干段，每个段都有一个段名，每段从0开始编址
内存分配规则：以段为单位分配，每个段在内存空间占据连续空间，但各段之间可以不相邻
分段系统的逻辑地址由段号（段名）和段内地址（段内偏移量）
段号的位数决定了每个进程最多可以分多少个段
段内地址位数决定了每个段的最大长度
由于图中段号占16位，所以这个进程可以最多分216=64K个段，段内地址16位，所以它每个段的最大长度为216KB
**段表：**为每个进程创建一个段映射表，保证能从物理内存中找到各个逻辑段的存放位置
1.每个段对应一个段表项，记录了该段在内存中的起始位置（基址）和段的长度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/422f55ac33aa5ac96ad76071d0e7333d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3d7db942d6d8a056e1fe702129acefc/" rel="bookmark">
			云卷云舒：kubernetes简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes是由google公司在2014年发布的一款开源的容器编排引擎，用于容器化应用程序的自动化部署、扩展与管理。它能够编排多种容器任务，涵盖虚拟机集群管理、负载均衡以及网络流量分配等等。2017年，aws、微软云、阿里云等等著名的云计算公司都开始宣布原生支持kubernetes 。还有的平台可以做到把自己的k8s对外提供服务，让用户可以直接在上面部署应用程序，提供容器级服务的环境。这些大型云厂商的支持， 使得k8s在业内已经受到了广泛的认可和支持，容器编排市场占有率超过80%。
1.kubernetes特性 （1）自动装箱：基于资源依赖及其他约束能够自动完成容器的部署而且不影响其可用性。
（2）自我修复：一旦某一个容器崩溃，由于容器轻量级的特点，kubernetes能够在1秒中左右迅速启动新的容器。
（3）自动水平扩展：只要物理平台的资源支撑是足够得到，kubernetes就可以无限制的增加容器。
（4）服务发现和负载均衡：当我们需要在k8s上运行很多应用程序的时候，一个服务可以通过自动发现的形式找到它所依赖的服务，而且每一种服务如果起了多个容器，他能实现自动负载均衡。
（5）自动发布回滚：执行日常的运维任务。
（6）秘钥和配置管理：k8s通过配置中心的方式来保存所有应用的配置信息，当容器启动时，会去配置中心加载对应的配置信息。
（7）存储编排：根据容器自身的需求自动创建能够满足自身需要存储卷。
2.kubernetes架构 kubernetes是从传统运维角度来说的集群，组合多台主机的资源整合成一个大的资源池并统一对外提供计算存储等能力。每一个主机上都安装了k8s的相关应用程序，并通过这个应用程序协同工作，把多个主机当一个主机来使用。但是在k8s集群中，主机是分角色的，k8s是一个有中心节点架构的集群系统（master/nodes模型）。
k8s一般有3个master节点以实现HA，N个node节点提供计算存储能力来运行容器。master负责接受客户端的请求，而后master负责分析各个node现有的可用资源状态，将请求调度到一个可运行容器的最佳的node节点。最后，node节点首先在本地检查是否有镜像，最后在以Pod（node节点的最小调度单元）的形式将容器启动起来。
3.kubernetes核心组件 （1）master节点核心组件 Controller：负责检测pod的健康。
API Server：API Server专门负责接收、解析、处理请求。
Scheduler（调度器）：它负责观测每一个node上总共可用的cpu计算和存储资源，并根据用户请求创建的容器所需要的资源量在众多node中挑选出一个符合条件的node来创建容器。kubernetes设计了一个两级调度的的方式来完成调度，第一步先进行预选；对每一个node进行评估，选出所有符合的node。第二步再在选出来的node上根据调度算法中的优选算法来选出一个最佳的node。
Controller Manager：它负责监控每一个控制器的健康状态，如果控制器不健康，由Controller Manager会重新生成一个控制器接管。Controller Manager如果宕机，会由从master上的Controller Manager接管。
（2）etcd 它是一个key：value的数据库，类似redis。负责存储集群中API Server中保存的各个状态信息（持久化到共享存储），以防止集群中的主master节点宕机，其他master节点可以读取到之前的集群信息。etcd同样是restfull风格的集群，通过http或https通信。在一个k8s集群中，etcd是高可用的。防止一个etcd宕机之后不能进行集群leader选举。
（3）node节点核心组件 Kubelet：负责与master通信，接受master调度过来的任务并执行，可能包括；创建Pod，管理Pod的健康状态、创建存储卷、启动容器等。
Kube-Proxy：节点中的每一个Pod发生变化以后，结果是保存在API Server中。而后API Server会生成一个通知事件，Kube-Proxy负责接收API Server的通知事件，一旦发现了某一个Service背后的Pod信息发生了改变（IP、Port等），由Kube-Proxy负责在每一个节点上将变化后的service转换成IPVS或IPtables规则中。而每创建一个Service，Service的实现也要靠Kube-Proxy在每一个节点上创建成IPVS或IPtables规则。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d554314b959e45555cb060b4d85b0fc/" rel="bookmark">
			FRPS配置服务端（腾讯云）、客户端（PC电脑Windows、树莓派Debian）并设置虚拟域名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.服务端（腾讯云）：frps.ini
[common] bind_port = 7000 vhost_http_port=8080 vhost_https_port=44344 dashboard_port = 7500 privilege_token = your_password subdomain_host = example.com use_encryption = true encryption_method = tls dashboard_user = admin dashboard_pwd = admin 2.客户端（PC电脑Windows） ：frpc.ini
[common] tls_enable = true # 这一行特别重要，不然Windows无法连接服务端 server_addr = xx.xx.xx.xx # 服务端ip server_port = 7000 privilege_token = your_password [pc_test] type = http local_ip = 127.0.0.1 local_port = 80 subdomain = win 3.客户端（树莓派Debian） ：frpc.ini [common] tls_enable = true server_addr = xx.xx.xx.xx # 服务端ip server_port = 7000 privilege_token = your_password [e45f016390e6] type = http local_ip = 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d554314b959e45555cb060b4d85b0fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7572edf925180fef2ddf9006edcbb20c/" rel="bookmark">
			DUET: Cross-Modal Semantic Grounding for Contrastive Zero-Shot Learning论文阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘要1.问题的提出引出当前研究的不足与问题属性不平衡问题属性共现问题 解决方案 2.数据集和模型构建数据集传统的零样本学习范式v.s. DUET学习范式DUET 模型总览属性级别对比学习==正负样本解释：== 3.结果分析VIT-based vision transformer encoder.消融研究消融研究解释 4.结论与启示结论总结启发PLMs的潜在语义知识引入多模态，跨模态整合细粒度角度考虑 原文链接： https://ojs.aaai.org/index.php/AAAI/article/view/25114/24886 该论文设计了一种新的零样本学习范式，通过迁移语言模型中的先验语义知识，与视觉模型的特征感知能力进行对齐，以增强后者对于未见过图像的识别能力。
摘要 零样本学习（ZSL）旨在预测在训练期间从未出现样本的未知类别。作为类别级视觉特征的注释，属性是零样本图像分类的广泛使用的语义信息。然而，由于缺乏细粒度的注释以及属性不平衡和共现问题，目前的方法常常无法区分图像之间的微妙视觉差异。在本文中，作者提出了一种基于Transformer的端到端ZSL方法，命名为DUET，通过自监督多模态学习范式整合了来自预训练语言模型（PLMs）潜在语义知识。具体而言，论文中（1）开发了一个跨模态语义定位网络来研究模型从图像中分离语义属性的能力；（2）采用了属性级对比学习策略，进一步增强模型对细粒度视觉特征的区分能力，克服属性共现和不平衡问题；（3）提出了 考虑多模型目标的多任务学习策略。论文中发现，DUET在三个标准ZSL基准和一个带有知识图的ZSL基准上均取得了最先进的性能，其组成部分是有效的，预测是可解释的。
1.问题的提出 引出当前研究的不足与问题 零样本学习（Zero-shot learning, ZSL）旨在预测在训练期间从未出现过样本的未知类别。对于零样本图像分类来说，最有效且广泛使用的语义信息是属性，它们用于描述类别级别视觉特征。然而当前的方法难以区分图像间的微妙视觉差异，这不仅来源于细粒度属性注释的不足，还由于属性间的不平衡和共现现象。
属性不平衡问题 即有些属性频繁出现而有些属性很少出现
例如，在零样本场景分类数据集 SUN中，属性“树”和“云”分别与 301 和 318 个类相关联 ，而“铁路”和“消防”只与15和10个类相关联。
属性共现问题 例如，“花”与“叶”一起出现了39次，但单独的“花”只出现了10次；
这种分布偏差可能会影响模型对那些包含稀有属性或新属性组合的看不见的类的判断。
图一
解决方案 在本文中，作者提出了一种基于Transformer的端到端零样本学习方法（DUET），它通过自监督的多模态学习范式将来自预训练语言模型的潜在语义知识进行整合。
贡献如下：
（1）开发了一个跨模态语义基准网络，以研究模型从图像中分离语义属性的能力；
（2）应用了基于属性级对比学习的策略，进一步增强模型对细粒度视觉特征的区分能力，克服属性的共现和不平衡问题；
（3）提出了多任务学习策略，考虑多模型目标。该方法可以同时在连续型的属性向量和离散型/结构化属性特征场景下工作，具有比较好的迁移泛化能力。
关于监督学习，无监督学习，半监督学习，自监督学习，强化学习等
自监督学习 | (1) Self-supervised Learning入门
强化学习与监督学习和无监督学习有什么区别？
【深度学习】04 机器学习类型：监督学习 半监督学习 无监督学习 强化学习视频
深度学习常见名词概念：Sota、Benchmark、Baseline、端到端模型、迁移学习等的定义
2.数据集和模型构建 数据集 三个配备标准属性的 ZSL 基准数据集 AWA2、CUB、SUN及其在（Xian 等人，2019）中提出的分割以及知识图谱基准数据集 AWA2-KG，它与 AWA2 具有相同的分割，但包含有关层次类和属性的语义信息，用于评估。 传统的零样本学习范式v.s. DUET学习范式 传统的零样本学习模式主要强调利用更多外部类别知识、进行数据增强，或研究更好的视觉编码器。相比而言，该框架强调跨模态模型的知识迁移（图二所示）。
传统：强调利用更多外部类别知识、进行数据增强，或研究更好的视觉编码器
DUET：强调跨模态模型的知识迁移
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7572edf925180fef2ddf9006edcbb20c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a816237d4cd12f35a0758fffbab167d9/" rel="bookmark">
			idea右上角浏览器图标没有idea内部浏览器怎么显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 idea右上角浏览器图标没有idea内部浏览器怎么显示 file -&gt; settings -&gt; tools -&gt; web brosers 选择需要的浏览器，勾选上展示到编辑器中 打开上图的Built-in Preview，就会显示idea标志的内部显示了！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8faeccd0a1e82281a16293e2021aad15/" rel="bookmark">
			华为云AI：轻松实现图像识别调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、环境配置关键步骤 二、图像识别实例媒资图像标签名人识别 总结 前言 基于华为云AI服务和java使用SDK实现图像识别，主要以媒资图像标签和名人识别为例。
一、环境配置 Maven（没有直接下载华为的SDK包，而是使用Maven安装依赖）JDK19（官方的SDK包要求JDK版本必须高于JDK8版本，大家根据自己只要满足版本要求即可）开发工具：IDEA 2023.3（其他版本也可） 能创建Maven项目即可 开通图像识别服务（目前是免费体验）：这里我开通的是图像标签/媒资图像标签和名人识别服务。设置访问密钥服务区域：我开通的服务区域是华北-北京四 关键步骤 Maven项目的创建和Java环境变量的配置我就不再赘诉，这是大家学习java早已熟练掌握的，这里只讲诉易错的。
开通图像识别服务
华为云首页就有云产品体验区（找不到就在搜索栏检索），勾选AI：
点击“立即体验”后，找到服务列表，开通你想要的服务（点击开通）：
设置访问密钥
在控制台找到“我的凭证”：
找到“访问密钥”，如果没有就新增，新增后一定要下载密钥的CSV文件，他会有提示让你下载，防止你忘记：
下载完csv文件后用记事本打开即可看到AK和SK：
Maven引入依赖配置
版本可以自己切换
&lt;dependency&gt; &lt;groupId&gt;com.huaweicloud.sdk&lt;/groupId&gt; &lt;artifactId&gt;huaweicloud-sdk-image&lt;/artifactId&gt; &lt;version&gt;3.1.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.70&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;4.4.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.16.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.13.0&lt;/version&gt; &lt;/dependency&gt; 二、图像识别实例 媒资图像标签 功能介绍：对用户传入的图像可以返回图像中的物体名称、所属类别及置信度信息。
使用图片是网上的，仅作学习使用：
代码如下：
/** * @Version: 1.0.0 * @Author: Dragon_王 * @ClassName: RunImageMediaTaggingSolution * @Description: 媒资图像标签 * @Date: 2024/1/8 11:51 */ /** * 此demo仅供测试使用，强烈建议使用SDK * 使用前需配置依赖jar包。jar包可通过下载SDK获取 */ import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8faeccd0a1e82281a16293e2021aad15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62053da97682accdbfd2cb6515418294/" rel="bookmark">
			【我的Rust库】get_local_info 0.1.7发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家对我真不错，0.1.6版发布才两天，阅读量已超600。感谢，我的运气真好。
以后会继续带给 Rust爱好者 更多的好东西。
get_local_info是一个获取linux本地信息的Rust三方库，其目标是降低获取本地linux系统信息的难度。支持银河麒麟10、UOS、鸿蒙等国产系统。
项目维护：长期
当前版本：0.1.7
当前功能：
1.网络功能
1.1获取活动网卡信息：网卡，IPv4，IPv6，mac
1.2.获取网络接口信息
2.获取系统版本
Kylin10支持2017及以上版本
Ubuntu支持22.04及以上版本
UOS20支持1020及以上版本
3.进程检测，虚拟机检测，双系统检测
4.信息安全检测
获取天融信反病毒库时间
怎么使用：
执行cargo add get_local_info，然后导入调用接口：
extern crate get_local_info; fn main() { println!("{}", get_local_info::get_pc_net_card_name()); println!("{}", get_local_info::get_pc_ipv4()); println!("{}", get_local_info::get_pc_ipv6()); println!("{}", get_local_info::get_pc_mac()); println!("{:?}", get_local_info::get_pc_net_card_info()); // osname: ubuntu or uos or kylin let osname = "uos"; println!("{}", get_local_info::get_pc_system_ver(osname)); //check proccess name let pname = "gnome"; println!("{}", get_local_info::get_pc_system_check_pname(pname)); // flase is Real machine, true is vm println!("Running in VM:{}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62053da97682accdbfd2cb6515418294/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef45a842e0ab3f4b5fb3b8d9642ddb8/" rel="bookmark">
			Apache ActiveMQ RCE CNVD-2023-69477  CVE-2023-46604
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞简介 Apache ActiveMQ官方发布新版本，修复了一个远程代码执行漏洞，攻击者可构造恶意请求通过Apache ActiveMQ的61616端口发送恶意数据导致远程代码执行，从而完全控制Apache ActiveMQ服务器。
影响版本
Apache ActiveMQ 5.18.0 before 5.18.3 Apache ActiveMQ 5.17.0 before 5.17.6 Apache ActiveMQ 5.16.0 before 5.16.7 Apache ActiveMQ before 5.15.16 Apache ActiveMQ Legacy OpenWire Module 5.18.0 before 5.18.3 Apache ActiveMQ Legacy OpenWire Module 5.17.0 before 5.17.6 Apache ActiveMQ Legacy OpenWire Module 5.16.0 before 5.16.7 Apache ActiveMQ Legacy OpenWire Module 5.8.0 before 5.15.16 ‍
环境搭建 没有找到合适的 docker 镜像 ，尝试自己进行编写
可以站在巨人的肩膀上进行编写利用 利用项目 https://github.com/zer0yu/dfimage 分析镜像的dockerfile
docker pull islandora/activemq:2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aef45a842e0ab3f4b5fb3b8d9642ddb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2164f6c1ac9634513addf39d6b8a8752/" rel="bookmark">
			机器学习笔记：时间序列异常检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 异常类型 1.1 异常值outlier 给定输入时间序列，异常值是时间戳值其中观测值与该时间序列的期望值不同。
1.2 波动点（Change Point） 给定输入时间序列，波动点是指在某个时间t，其状态在这个时间序列上表现出与t前后的值不同的特性。
1.3 断层异常（Breakout） 时序系统中某一时刻的值比前一时刻的值陡增或者陡降很多，之后形态也发生了改变。
2 常见异常检测方法 2.1 基于统计 首先建立一个数据模型。异常是那些同模型不能完美拟合的对象 eg，数据分布模型可以通过估计概率分布的参数来创建。如果一个对象不能很好地同该模型拟合，即如果它很可能不服从该分布，则它是一个异常 2.1.1 3σ法则 假如分布满足正态分布，那么 (μ−3σ,μ+3σ)区间内的概率为99.74。所以可以认为，当数据分布区间超过这个区间时，即可认为是异常数据。 2.1.2 分位数异常检测 IQR是第三四分位数减去第一四分位数，大于Q3+1.5*IQR之外的数和小于Q1-1.5*IQR的值被认为是异常值。 2.1.3 Grubbs测试 不断从样本中找出outlier的方法 这里的outlier，是指样本中偏离平均值过远的数据 算法流程
样本从小到大排序
求样本的mean和std
计算此时样本的min/max与mean的差距，距离更远的那个为可疑值
求可疑值的z-score (standard score)，如果大于预先设定的Grubbs临界值，那么就是outlier；
对剩余序列不断做1~4步（每次检测一个异常点）
局限性：
它的判断机制是“逐一剔除”，所以每个异常值都要单独计算整个步骤，数据量大吃不消；
需假定数据服从正态分布或近正态分布。
2.2 基于预测 对于单条时序数据，根据其预测出来的时序曲线和真实的数据相比，求出每个点的残差对残差序列建模，利用KSigma或者分位数等方法便可以进行异常检测 2.3 基于距离 2.3.1 k-最近邻 数据对象与最近的k个点的距离之和。很明显，与k个最近点的距离之和越小，异常分越低；与k个最近点的距离之和越大，异常分越大。设定一个距离的阈值，异常分高于这个阈值，对应的数据对象就是异常点。 2.4 基于密度的方法 2.4.1 Local Outlier Factor (LOF) 给每个数据点都分配一个依赖于邻域密度的离群因子 LOF，进而判断该数据点是否为离群点 好处在于可以量化每个数据点的异常程度（outlierness）数据点p的局部相对密度（局部异常因子）为点p邻域内点的平均局部可达密度跟数据 点p的局部可达密度的比值（密度越小，越可能是异常点） 数据点P的局部可达密度=P最近邻的平均可达距离的倒数。距离越大，密度越小。 点O的k近邻距离=第k个最近的点跟点O之间的距离。 整体来说，LOF算法流程如下：
对于每个数据点，计算它与其他所有点的距离，并按从近到远排序；
对于每个数据点，找到它的K-Nearest-Neighbor，计算LOF得分。
2.5 基于聚类的方法 小于某个最小尺寸的所有簇视为异常 2.6 基于树的方法 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2164f6c1ac9634513addf39d6b8a8752/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b580dbfe561a3c7a796677f6ff34e2cc/" rel="bookmark">
			Java 反射(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反射
1.反射的介绍 1.反射机制允话程序在执行期间借助于Refelction API取得任何类的信息（比如成员变量，构造器，成员方法等）并能操作对象的属性及方法，反射在设计模式和框架底层都会用到
2.加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整信息。通过这个对象得到了类的结构，这个Class对象就像一面镜子，透过这个镜子看到类的结构，所以称之为反射
1.2反射的原理图 1.3反射可以完成的工作 1.在运行时判断任意一个对象所属的类2.在运行期间构造一个类的对象3.在运行期间得到任意一个类所具有的成员变量和方法4.在运行时调用任意一个对象的成员变量和方法5.生成动态代理 反射相关的主要类
1.java.lang.Class:代表一个类,Class对象表示某个类加载后在堆中的对象2.java.lang.reflect.Method:代表类的方法,Method对象表示某个类的方法3.java.lang.reflect.Field:代表类的成员变量,Field对象表示某个类的成员变量4.java.lang.reflect.Constructor:代表类的构造方法,Constructor表示类构造器 package javareflect.demo; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Properties; public class Reflection01Demo { public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { //1.使用Properties类，可以读写配置文件 Properties properties=new Properties(); properties.load(new FileInputStream("src\\re.properties")); String classfullpath = properties.get("classfullpath").toString(); String methodName=properties.get("method").toString(); System.out.println("classfullpath"+classfullpath); System.out.println("method="+methodName); //2. 使用反射机制解决 //(1) 加载类, 返回 Class 类型的对象 cls Class cls = Class.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b580dbfe561a3c7a796677f6ff34e2cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/034558a8964a181249b840a75819eec8/" rel="bookmark">
			混淆技术概论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 混淆技术概论 引言 在逆向工程领域，混淆技术是一种非常重要的技术手段，通过打破人们的思维惯性，使得逆向分析变得更加困难。本文将会介绍混淆技术的概念、分类及其应用，以及如何使用IPA Guard进行iOS IPA重签名。
混淆技术概述 混淆可以被视为一种破坏代码可读性和理解性的技术手段。它的目的是增加代码的复杂度，从而使得逆向工程变得更加困难。混淆技术通常被应用于软件、游戏等领域。
混淆技术可以分为两类，基于控制流的混淆和基于数据流的混淆。基于控制流的混淆是指通过改变程序控制流程来实现混淆，例如使用虚拟机、代码转换、代码插入等手段。基于数据流的混淆则是指通过改变数据流来实现混淆，例如使用加密算法、数据转换、数据插入等手段。
IPA Guard进行iOS IPA重签名 在iOS开发中，IPA编译出来后需要进行重新签名才能安装到测试手机或者提交Apple商店审核上架。IPA Guard是一个可以在Windows、Mac和Linux上运行的工具，提供了签名和重签名功能。在对IPA进行混淆和保护后，可以直接通过签名安装到测试手机，非常方便测试检查混淆后的效果。
进行iOS IPA重签名的步骤如下：
打开要处理的IPA文件，填写需要重签名的IPA路径。
设置签名使用的证书和描述文件，测试配置阶段使用开发测试证书，方便安装到手机测试混淆后IPA是否工作正常。测试OK后，最后准备上架的时候再改成发布证书和发布描述文件。
如果IPA需要特殊的权限配置，可以使用权限配置文件。
如果希望直接处理完后安装到设备，则勾选安装到设备选项，苹果手机数据线连接电脑即可识别设备。如果链接成功后没显示设备，则先安装iTunes或者iOS驱动。
点击开始处理，IPA Guard会自动尝试将IPA安装到手机。如果是发布证书并且忘记关闭安装到设备选项，则安装可能会失败，但是IPA是正常生成的，可以用来上架。
总结 本文介绍了混淆技术的概念、分类及其应用，并详细介绍了如何使用IPA Guard进行iOS IPA重签名。混淆技术可以有效地保护软件和游戏的知识产权，防止逆向工程，是非常重要的安全手段。
参考资料 iOS IPA重签名IPA Guard 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21537a1788b2f2d34ca1729ce9be7300/" rel="bookmark">
			centos 7更改最大文件打开数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在之前修改文件最大连接数等直接修改 /etc/security/limits.conf文件即可，最近出现几次修改未生效问题。
2、经过排查发现可能跟ssh升级为8版本有关，尚未验证。
3、解决办法：
①修改 /etc/security/limits.conf文件，修改内容跟之前一样
vim /etc/security/limits .conf
* soft nofile 284888* hard nofile 204808
* soft nproc 284888
hard nproc 284888
vim /etc/security/limits.d/zg-noroc.conf
* soft nproc 284888
* hard nproc 204898
vim /etc/pam.d/login
#添加
session required pam limits.so
②修改ssh配置文件/etc/ssh/sshd_config，将#UsePAM no 注释去掉并且改为yes，注意，如果直接改完重启ssh会出现登录输入正确密码也会被拒绝的情况，所以要首先执行步骤③之后再重启ssh
③修改/etc/pam.d/sshd文件，如果不存在直接新建即可
#%PAM-1.0
auth required pam_sepermit.so
auth include password-auth
account required pam_nologin.so
account include password-auth
password include password-auth
# pam_selinux.so close should be the first session rule
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21537a1788b2f2d34ca1729ce9be7300/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5281f862ae89524dc0129cc463b3c959/" rel="bookmark">
			Linux踢掉远程登录用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux中，如果你想要踢掉其他通过ssh登录到系统中的用户，可以按照以下步骤操作：
首先，使用who -u命令检查Linux系统中已登录的用户列表1。这个命令会显示登录到系统中shell会话的进程ID1。
找到你想要踢掉的用户的用户名和终端号2。
使用ps -t &lt;终端号&gt;命令查看该用户的所有进程，记录下进程的PID2。
使用kill -HUP &lt;PID&gt;命令发送一个SIGHUP信号，该信号用于报告用户的终端已经断开，还可以有效的断开会话中所有进程与控制终端的连接1。
如果SIGHUP信号不起作用，则可以发送SIGKILL信号，即kill -9 &lt;PID&gt;12。
最后，使用pkill -kill -t &lt;终端号&gt;命令踢出该用户2。
注意，要执行这些操作，你需要是root用户或者具有sudo权限1。此外，作为一个相对友好的习惯，在踢掉用户之前，最好发一条信息给他。发送信息可以使用write命令1。
以上就是在Linux中踢掉远程登录用户的方法，希望对你有所帮助。如果有其他问题，欢迎随时提问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5407ebf0922a04b10aba71df6500488e/" rel="bookmark">
			【教程】代码混淆详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
正文
什么是代码混淆
ProGuard混淆文件参数详解
代码混淆的方法
Ipa Guard工具的使用方法
IPA重签名与安装测试
总结
本文将对代码混淆进行详细解释，并介绍ProGuard代码混淆器以及Ipa Guard工具的使用方法。首先，我们将了解代码混淆的概念和作用，然后深入讨论ProGuard混淆文件的参数设置以及代码混淆的方法。接着，我们将介绍Ipa Guard工具的下载、代码混淆、文件混淆以及IPA重签名与安装测试的步骤。
引言 代码混淆是一种重要的安全保护措施，通过对程序代码进行重新组织和处理，使得处理后的代码与处理前代码完成相同的功能，而混淆后的代码很难被反编译，从而增加了程序的安全性。本文将介绍Java代码混淆的相关知识，并结合ProGuard和Ipa Guard工具，深入探讨代码混淆的实际操作方法。
正文 什么是代码混淆 Java是一种跨平台的解释型语言，其源代码编译成中间“字节码”存储于class文件中。由于Java字节码中包括了很多源代码信息，如变量名、方法名等，因此很容易被反编译成Java源代码。为了防止这种现象，我们可以使用Java混淆器对Java字节码进行混淆。混淆就是对发布出去的程序进行重新组织和处理，使得处理后的代码与处理前代码完成相同的功能，而混淆后的代码很难被反编译。
ProGuard混淆文件参数详解 以下是一个ProGuard混淆文件（proguard.cfg）的参数详解：
// 参数设置省略 代码混淆的方法 根据SDK的版本不同有两种不同的代码混淆方式，分别在低版本SDK下和高版本SDK下进行配置。以下是具体的配置方法。
低版本SDK下，项目中需要同时包含proguard.cfg和project.properties文件，并在project.properties文件末尾添加proguard.config=proguard.cfg，然后将项目Export即可。在高版本SDK下，项目中需要同时包含proguard-project.txt和project.properties文件，需要在proguard-project.txt文件中进行配置，然后将项目Export即可。
Ipa Guard工具的使用方法 Ipa Guard是一款功能强大的ipa混淆工具，不需要iOS app源码，直接对ipa文件进行混淆加密。它可以对ipa文件中的类、方法、方法参数、变量等进行全面修改混淆，使其名称成为没有意义的乱码，从而极大地增加应用破解的难度。Ipa Guard还支持对代码中的各种资源文件进行混淆，增加破解ipa的难度。
IPA重签名与安装测试 Ipa Guard工具提供了签名和重签名功能，能在Windows、Mac和Linux上运行。在对ipa进行混淆和保护后，可以直接通过签名安装到测试手机，非常方便进行混淆效果的测试检查。
iOS加固保护是直接针对ios ipa二进制文件的保护技术，可以对iOS APP中的可执行文件进行深度混淆、加密。使用任何工具都无法逆向、破解还原源文件。对APP进行完整性保护，防止应用程序中的代码及资源文件被恶意篡改。Ipa Guard通过修改 ipa 文件中的 macho 文件中二进制数据（代码模块配置）进行操作，无需源码。不限定开发技术平台。支持oc，swift，cocos2d-x、unity3d、quick-cocos，html5 ，react native等等各种开发技术。Ipa Guard主要包含代码混淆全面、资源文件处理、不需要源代码更安全、调试信息清理、即时测试运行。
下载ipa代码混淆保护工具Ipa Guard是一款功能强大的ipa混淆工具，不需要ios app源码，直接对ipa文件进行混淆加密。不限制OC，Swift，Flutter，React Native，H5类app。工具跨平台版，windows,linux,mac系统都可用直接去官网下载https://www.ipaguard.com
获取ipaguard登录码双击ipaguard.exe启动ipaguard后点击右上角的登录按钮，输入邮箱后，没登录码的点击获取登录码，有的可以直接输入登录码
代码混淆Ipa Guard可以对ipa文件中的类、方法、方法参数、变量等进行全面修改混淆，使其名称成为没有意义的乱码，极大地增加应用破解的难度。 选择要处理的ipa文件，点击左侧的代码菜单，里面可以分别对oc类，方法，swift类，方法等进行选择配置要处理的内容
文件混淆Ipa Guard代码混淆工具支持对代码中的各种资源图片、js、mp3、xib、sb、json、html等名称进行修改，使其变得无意义，增加破解ipa的难度。
IPA重签名与安装测试ipaguard有签名和重签名功能，能在windows，mac，和linux上运行。在对ipa进行混淆和保护后，可以直接通过签名安装到测试手机，非常的方便测试检查混淆后的效果。
总结 本文详细介绍了代码混淆的概念、ProGuard混淆文件的参数设置、代码混淆的方法以及Ipa Guard工具的使用方法。代码混淆是保护程序安全和防止反编译的重要手段，希望本文能帮助读者更好地理解和应用代码混淆技术。
为了更好地保护代码安全，建议开发者在发布程序时使用代码混淆技术，并选择适合自己项目的混淆工具进行操作。
以上是对代码混淆的详细解释和相关工具的使用方法。希望对您有所帮助！
如果需要进一步了解或有其他问题，欢迎继续交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f978e050ff3a4aa343c4a64fd3682a06/" rel="bookmark">
			力扣热题 100
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 哈希双指针滑动窗口子串普通数组矩阵链表二叉树图论回溯二分查找栈堆贪心算法动态规划多维动态规划技巧 哈希 双指针 滑动窗口 子串 普通数组 矩阵 链表 二叉树 二叉树的中序遍历 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; reusltList = new ArrayList&lt;&gt;(); inorderVisited(root, reusltList); return reusltList; } private void inorderVisited(TreeNode root, List&lt;Integer&gt; reusltList) { if (root == null) { return; } inorderVisited(root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f978e050ff3a4aa343c4a64fd3682a06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c3ed2d28b9aec09b8c244d6b21cbc81/" rel="bookmark">
			Pycharm中如何配置python环境（conda）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在pycharm中点击 "File" &gt; "Settings"
再次点击如下操作：
点击Python Interpreter的最右侧按钮，点击Show All...
找到python文件
最后点击OK
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a03cb24b6809349b9a154f1bd9a938ad/" rel="bookmark">
			Selenium自动化测试详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近也有很多人私下问我，selenium学习难吗，基础入门的学习内容很多是3以前的版本资料，对于有基础的人来说，3到4的差别虽然有，但是不足以影响自己，但是对于没有学过的人来说，通过资料再到自己写的代码，发现有些东西没有，有些方法又不相同，导致脚本不能运行，提醒我，看是否能花点时间，把selenium的内容好好梳理一下，从基础开始，到能够梳理出一个selenium的知识图谱更好。
整个内容可能不是一次能写完的，所以我打算分多次来写，如果各位看完后，有什么问题也可以发信息给我，我给大家解答一下，写这个也是为了方便在未来selenium还会有新的版本更新，以后也方便做个对比。
本次内容从一下几个方面来写吧：
selenium的作用selenium版本的介绍selenium工作原理selenium安装浏览器基本操作 同时，在这我为大家准备了一份软件测试视频教程（含面试、接口、自动化、性能测试等），就在下方，需要的可以直接去观看，也可以直接【点击文末小卡片免费领取资料文档】
软件测试视频教程观看处：
【2024最新版】Python自动化测试15天从入门到精通，10个项目实战，允许白嫖。。。
1、selenium的介绍 Selenium是Thought Works公司开发的一套基于web应用的自动化测试工具，直接运行在浏览器中，模拟用户操作。它可以被用于单元测试、集成测试、回归测试、系统测试、冒烟测试、验收测试，并且可以运行在各种浏览器和操作系统上。
目前使用selenium的人群大概有两大类吧，一类是软件测试工程师，他们可以通过selenium来实现自动化的测试，以提高回归测试的效率，降低人员的执行成本。第二类可能就是很多写爬虫的人，因为现在网页端爬取数据的人有很多，服务端做了很多的反爬策略，及各种限制如动态加载等，单独的通过接口来爬取数据的难度和可行性有所降低，而selenium可以模拟人为的在页面上执行各种操作，那么各种反爬的手段可能对它来讲也就没有什么意义了，当然也有人说，还有各种验证码也会有影响，验证码的问题我们今天先不谈，后面我看是否可以单独出一篇对验证码处理的文章。
2、selenium的版本介绍 selenium从发布到至今经历了1、2、3、4个版本，截止目前发布的最新版本是4.7版本，版本跨度最大的其实是1.0版本到2.0版本，1.0版本中包含了ide、Grid、core和rc四大部分，2.0在1.0基础上加入了webdriver，webdriver提供了更为简单的编程接口，弥补了1.0中Selenium-RC的一些不足和限制，对外提供了更简洁的restfull的API接口。
selenium1.0的主要内容：
DE：可以通过IDE完成测试过程的录制和回放。主要用来给初学者了解selenium，但不适合直接作为日常自动化的测试。Grid：是selenium部署、测试及执行（分布式测试用例执行）。RC：selenium Remote Control,一个代理与控制器。Core：selenium的测试机制核心部分，包含测试用例集的执行，断言，由js代码组成，支持夸平台运行。 selenium2.0 = selenium1.0 + webdriver
3、selenium工作原理 3.1、客户端（selenium支持多种编程语言，所以客户端的请求可以使用各种语言来调用接口），selenium 通过调用WeDriver类的start方法去启动浏览器驱动，创建服务的启动。
3.2、通过服务端返回的session id，在下一次请求时，携带这个id，将客户端要执行的操作发送给服务端，服务端解析用户发送请求中的操作，并将操作指令发送给浏览器去执行。
3.3、浏览器执行客户端操作，并将操作的结果返回给服务端，服务端将执行结果进行封装，并返回给客户端。
客户端在启动服务端时，服务端会启动一个9515的端口用来与客户端连接，客户端调用selenium提供的方法，在由selenium将请求转化为对应的操作接口指令，根据操作指令调用对应的API接口，通过API接口调用将用户操作发送给浏览器端去执行。
这部分的内容需要在后续的过程中，解析代码来理解他的原理和过程。
4、selenium安装 安装selenium环境，这里以python 3.8的为例，安装完成python后，并且配置好python相关的环境变量，不懂的可以私信我。
需要安装的有：
1、selenium
2、浏览器驱动
3、浏览器
4.1 安装selenium 如果python环境已经安装完成，可以使用pip来安装selenium，在开始菜单中，输入cmd，打开dos窗口，执行下列命令
4.2 安装浏览器驱动 安装浏览器驱动，需要根据浏览器来决定，使用不同的浏览器，就需要选择不同的浏览器驱动，浏览器驱动也需要根据浏览器的版本来考虑，所以浏览器、浏览器版本要与浏览器驱动及驱动版本向对应，下面列出几种常见浏览器的驱动下载地址
1、Chrome（Google）浏览器：http://chromedriver.storage.googleapis.com/index.html
先确定自己浏览器的版本，在chrome浏览器中的帮助中，查看关于，上面会显示浏览器版本，或者直接在浏览器url地址上输入chrome://settings/help，下面这个是我浏览器的版本
根据版本号，在驱动下载页面中，找到对应的版本
因为我是window的系统，所以我选择chromedriver_win32.zip，下载后，将里面的chromedriver.exe文件解压出来，其实放在哪无所谓，放的地方不同后面写代码时的处理会有所区别。一般建议放在path这个环境变量能访问到的位置，或者干脆放在python的安装目录下也行
2、Firefox（火狐）浏览器：Releases · mozilla/geckodriver · GitHub
采用同样的方式下载对应版本的geckodriver驱动，Firefox的版本和geckodriver的版本对应关系如下，也可以直接去官网查看，
官网地址：Supported platforms — Firefox Source Docs documentation
3、Edge ：Microsoft Edge WebDriver - Microsoft Edge Developer
首先也是要确定Edge的版本，然后根据版本到官网下载驱动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a03cb24b6809349b9a154f1bd9a938ad/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/11/">«</a>
	<span class="pagination__item pagination__item--current">12/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/13/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>