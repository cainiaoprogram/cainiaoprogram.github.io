<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28aca6472bb0bc3c56917ef7d362dd6c/" rel="bookmark">
			A novel multi-view deep learning approach for BI-RADS and density assessment of mammograms
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基于乳腺成像报告和数据系统(BI-RADS)和密度标准，先进的深度学习算法可以预测患者患乳腺癌的风险。最近的研究表明，多视角分析的结合改善了乳腺检查的整体分类。在本文中，我们提出了一种新的多视角DL方法用于BI-RADS和乳腺x线片密度评估。该方法首先在每个视图上分别部署深度卷积网络进行特征提取。然后，提取的特征被堆叠起来，并送入光梯度提升机(LightGBM)分类器来预测BI-RADS和密度分数。我们在内部乳房x线照相术数据集和公共数据集上进行了大量的实验。实验结果表明，该方法在两个基准数据集上(内部数据集+5%，DDSM数据集+10%)的分类性能显著优于单视图分类方法。这些结果突出了组合多视图的重要作用提高乳腺癌风险预测的信息。
方法 本文提出的BI-RADS密度分类体系结构分为两个阶段，如图1b所示。第一阶段使用cnn从乳房x线照片中学习潜在特征。然后第二阶段应用LightGBM作为分类器来预测BI-RADS和密度分数。为了验证所提出的多视图模型的有效性，我们将其与单视图方法进行了比较(图1a)。
图像预处理 大多数乳房x光片的背景都是黑色的，不显示任何信息，这对于训练来说是巨大的资源消耗。因此，我们使用YOLOv5构建了一个自动探测器，可以在原始扫描的基础上准确定位乳腺相关区域。为了训练探测器，我们手工标注了2000张乳房x光片，其中1600张用于训练，400张用于验证。经过训练的模型在验证集上的mAP为0.995，能够正确预测未见的乳房x线照片中的乳腺Bounding Box
多视图特征提取 根据特征提取过程，实现有监督的深度cnn，然后去除结构末端的全连接层，从输入图像中获得隐藏表示。隐藏表示是一个维数为H × W × C的张量，它是从原始维数下采样得到的。其中，我们使用ResNet-34和EfficientNet-B2作为特征提取步骤。为了训练ResNet-34提取器，将所有输入图像的大小调整为H × W = 512 × 512。此外，每一张乳房x光片都从原始的灰度通道复制到三个通道。经过训练的提取器后，得到维数为H × W × C = 32 × 24 × 512的特征张量。最后，将这个隐藏的表示在空间维度上进行平均池化，以得到一个512维的向量。同样，为了训练EfficientNetB2模型，输入是H× W ×C = 1024×768×3。隐张量为H × W × C = 32 × 24 × 1408，隐向量为1408维格式。
分类 这一阶段的输入是特征提取步骤的特征向量。我们在ResNet-34提供的N×512-dimensional向量和EfficientNet-B2提供的N×1408-dimensional向量上训练LightGBM分类器，其中N是训练图像的数量。LightGBM是一个基于树算法的梯度增强框架，实现更快地交付结果，减少内存使用，并提高准确性。多视图(图1b)架构背后的主要思想是使用来自四个视图的多个隐藏信息的融合来训练一个有效的分类器。特征提取步骤中的四个骨干分别为数据集的每个视图进行训练。在这种组合技术中，我们平均了L- cc和LMLO特征向量，以及R-CC和R-MLO特征向量。然后将所有的平均向量作为lighttgbm的输入，以提供BI-RADS的置信分数和密度。
数据集 我们在我们的私有数据集和DDSM数据集上评估了所提出的方法。该私人数据集是回顾性收集自2018年至2020年的河内医科大学医院。每幅图像被分配给一个由三名放射专家组成的团队，他们专门从事乳房成像的多标记标注(BI-RADS 1-5和乳腺密度A-D)。总的来说，该数据集包括来自9911项研究的36138张筛查乳房x光照片。共有8509个四视图研究，每个视图包含一个图像(L-CC, L-MLO, R-CC, R-MLO)。这些考试被多重标签分层方法分为三组:训练集(5,792项研究)、验证集(1,266项研究)和测试集(1,271项研究)。表1对私有数据集上的三个集合进行了描述。对于DDSM数据集，在培训、验证、测试集上进行多标签分层的考试数量为1822个;391;和391年,分别。每项研究都涉及两个乳房的图像，以及病理标签和密度信息。有四种类型的标签，正常-良性-癌症-良性与回调-良性没有回调。DDSM训练集包含486个正常病例，704个良性病例和632个癌症病例。正常/良性/癌症研究在验证集和测试集中的数字分别为105/147/139和104/145/142。对于这两个数据集，每个乳房的病理/BI-RADS标签是其CC和MLO图像的最大标签，而这两个视图图像的密度肯定具有相同的信息
结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7568d65e51b24d8f58ae803d368ee06/" rel="bookmark">
			Windows通过计划任务定时执行bat文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开【控制面板】，选择【管理工具】
2、选择【任务计划程序】
3、打开window【定时任务打开程序】，右击【任务计划程序库】，选择【创建基本任务】
4、创建【基本任务】，输入【名称】
5、设置【触发器】
6、所执行的操作
7、【完成】
8、最终在【任务计划程序库】右侧显示已创建的任务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a84378c8d747a9933cd2e485458441/" rel="bookmark">
			docker启动失败:Failed to start Docker Application Container Engine.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker官方仓库的速度会比较慢，可以配一个官方的中国加速镜像
方法是：修改 /etc/docker/daemon.json 加上如下的键值:
{
"registry-mirrors": ["https://registry.docker-cn.com"]
}
然后重启docker即可
但是重启却报错，根据提示查看docker服务状态，Failed to start Docker Application Container Engine.
解决方法：
daemon.json文件中采用缩进可以，但是不能出现空格，重新加载daemon.json配置，然后重启就可以成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f44b460a3649e0c3d404c6cbe498e96/" rel="bookmark">
			279. 完全平方数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
示例 1：
输入：n = 12
输出：3
解释：12 = 4 + 4 + 4
示例 2：
输入：n = 13
输出：2
解释：13 = 4 + 9
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/perfect-squares
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
是个九个月再做此题，虽然仿佛没做过，但是动态规划的思想已经有点点头绪了，本题题解：使用动态规划的解法，只需写出动态转移方程即可，默认，当 i 的时候，最多的情况就是 i 个 1，那么第 i 个数字，如果 i 减去 平方数还大于 0 的话，可以更新，也就是，i 减去一个平方数的前一个数加上一的结果，比如，i 等于 10，那么结果就是 9,6, 1的结果 加一的最小值
class Solution { public int numSquares(int n) { int[] dp = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { dp[i] = i;// 最差情况 for (int j = 1; i - j * j &gt;= 0; j--) { dp[i] = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f44b460a3649e0c3d404c6cbe498e96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b8abfac1c222900475e72f9962315c6/" rel="bookmark">
			华为机试（python）：排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HJ6 质数因子 题目：功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举）（如180的质因子为2 2 3 3 5 ）
输入描述： 输入一个整数
输出描述： 按照从小到大的顺序输出它的所有质数的因子，以空格隔开。
##质因子只有1和它本身 import math n = int(input()) for i in range(2, int(math.sqrt(n))+1): while n % i == 0: print(i, end=' ') n = n // i #如果n没有变化，还是大于2的数，则输出其本身 if n &gt; 2: print(n) HJ34 图片整理 题目：Lily上课时使用字母数字图片教小朋友们学习英语单词，每次都需要把这些图片按照大小（ASCII码值从小到大）排列收好。请大家给Lily帮忙，通过代码解决。
输入描述： Lily使用的图片包括"A"到"Z"、"a"到"z"、"0"到"9"。输入字母或数字个数不超过1024。
输出描述： Lily的所有图片按照从小到大的顺序输出
while True: try: a =input() #print(a[0]) b = [] c = [] for i in range(len(a)): b.append(ord(a[i])) b.sort() for j in b: c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b8abfac1c222900475e72f9962315c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f06eed95e70fd036d40e0badbf76c2d/" rel="bookmark">
			22. 括号生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
示例 1：
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
示例 2：
输入：n = 1
输出：["()"]
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/generate-parentheses
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
括号生成，递归版本，动态规划的是在是看不太懂，其实思路非常简单，只要明白一些机制即可，当左右括号相等的时候，此时只能添加左括号，如果添加右括号就不匹配了，当左小于右的时候，添加左右都行，但是要确保左括号大于 0，首先递归入口：
getParenthesis("", n, n); 意思是，此时，左括号有 n 个，右括号有 n 个，并且字符串当前是 “” ，每次使用左括号，让左括号减一，都减到 0 的时候，return 即可
class Solution { List&lt;String&gt; list; public List&lt;String&gt; generateParenthesis(int n) { this.list = new ArrayList&lt;&gt;(); getParenthesis("", n, n); return list; } public void getParenthesis(String s, int left, int right) { if (left == 0 &amp;&amp; right == 0) { list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f06eed95e70fd036d40e0badbf76c2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d32f7e0a3effe18bf0bdadeda01630/" rel="bookmark">
			Python 微信机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用python构造一个微信聊天机器人
最近在学python的过程中无意间发现一个python库：wxpy，其可以实现让微信自动接收、处理消息并进行回复的一系列功能。感觉挺有意思的，便自行摸索学习，并成功地实现了其功能，故写下此博客作学习分享。
1.安装wxpy wxpy 支持 Python 3.4-3.6，以及 2.7 版本。
从PYPI 官方源下载安装：
pip install -U wxpy
从豆瓣 PYPI 镜像源下载安装：
pip install -U wxpy -i "https://pypi.doubanio.com/simple/"
推荐国内用户使用镜像源下载安装，相比官方源更稳定，需要注意的是，若想确保安装到对应的 Python 版本中，命令中的 “pip” 替换为 “pip3” 或 “pip2”。
linux下还需安装pillow：
pip install pillow
2.申请一个图灵的APIKEY 需要去官网注册一个图灵机器人并获取APIKEY.（图灵机器人是一个中文语境下的对话机器人，可以使用免费版，一个账号最多可以创建5个机器人，一个机器人日调用接口数5000次）
官网地址：图灵机器人-智能好用的聊天机器人
若觉得麻烦不想注册也可以，不需要APIKEY也可以实现简单的微信定时发送消息，简单回复等功能，如果想要智能化的自动回复功能，还是乖乖去注册吧。
3.用wxpy登录，发送和回复消息 登录 from wxpy import * # 导入模块 bot = Bot() # 初始化机器人，扫码登陆，但每次登陆都得重新扫码 #bot = Bot(cache_path=True) #把登录信息保存下来，不想每次都扫码的可以用这一条 运行后会弹出微信登录的二维码，扫描后登录网页版微信
2.发送消息
friend = bot.friends().search(u'你好友的名字')[0] friend.send(u"哈哈") #指定某个好友并向其发送消息 运行后会向指定好友发送所写的内容，可以在这个功能的基础上进一步实现定时向某人发送消息的功能。我发现一篇关于“教你用微信每天给女朋友说晚安”的文章，有兴趣可以看一下python实战===教你用微信每天给女朋友说晚安 - botoo - 博客园
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57d32f7e0a3effe18bf0bdadeda01630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b3541f517af9375be32b5aa3738d5e3/" rel="bookmark">
			检查自己电脑GPU个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import torch n_gpu = torch.cuda.device_count() print(n_gpu) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2fc158ec67d3bbc164275ceb60665cb/" rel="bookmark">
			金融风控实战——迁移学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迁移学习 为什么做迁移？
源域样本和目标域样本分布有区别，目标域样本量又不够。
场景 思考我们平时建模会使用到迁移学习的一些场景：
1）新开了某个消费分期的场景只有少量样本，需要用其他场景的数据进行建模；
2）业务被迫停止3个月后项目重启，大部分训练样本比较老旧，新的训练样本又不够；
3）在某个新的国家开展了类似国内的业务，因为国情不同，显然部分特征分布是不同的；
主要任务 缩小边缘分布之间和条件分布下的差异。
几个基本概念：
Domain（域）：包括两部分：feature space（特征空间）和probability（概率）。所以当domain不同的时候，分两种情况。可能是feature space不同，也可能是feature space一样但probability不同；
Task（任务）：包括两部分： label space（标记空间）和objective predictive function（目标预测函数）。同理，当task不同的时候，也分两种情况。可能是label space不同，也可能是label space一样但function不同；
Source（源）是用于训练模型的域/任务；
Targe（任务）是要用前者的模型对自己的数据进行预测/分类/聚类等机器学习任务的域/任务。
通常我们说的迁移学习就是指将知识从源域迁移到目标域的过程。
比如我们有大量英短银渐层的图片，和少量美短起司的照片，想训练一个判别当前的猫是不是美短起司的学习器。如果我们用英短银渐层图片来作为样本，显然训练的模型是不能用来判别美短起司的，用美短起司的样本来训练，样本量又太小。这时候我们可能会使用英短银渐层来训练一个卷积神经网络，然后将这个网络的中间结构取出来作为目标模型的前半部分，然后在少量的美短起司的样本上再继续学习后面的几层网络（再训练、再学习）。熟悉卷积神经网络的同学可能知道，CNN的前几层主要学习的是轮廓和局部形状等共性特征。这样通过前面的学习，我们就知道了猫咪的共性，再通过对起司的学习得到细节上的差异。
然后在提迁移学习前，首先说另一种学习方法，叫做增量学习。
增量学习主要关注的是灾难性遗忘（Catastrophic forgetting），平衡新知识与旧知识之间的关系。但我们可以用它来模拟神经网络中的finetune.
Xgboost提供两种增量训练的方式：
一种是在当前迭代树的基础上增加新树，原树不变;（层迁移，两只小猫咪的例子）另一种是当前迭代树结构不变，重新计算叶节点权重，同时也可增加新树。 （fine—tuning） 增量学习有什么用呢？
我们可以仿照神经网络中的基于模型的迁移学习，先用一部分样本训练前几棵树，然后用新的样本学习后面的树，通常我们可能用源域与目标域的混合数据训练前几棵树，以得到更好的表达能力，最后用目标域的数据训练后面几棵树。
import xgboost as xgb from sklearn.datasets import load_digits # 训练数据 xgb_params_01 = {} digits_2class = load_digits(2) X_2class = digits_2class['data'] y_2class = digits_2class['target'] dtrain_2class = xgb.DMatrix(X_2class, label=y_2class) gbdt_03 = xgb.train(xgb_params_01, dtrain_2class, num_boost_round=3) # 训练三棵树的模型 gbdt_03a = xgb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2fc158ec67d3bbc164275ceb60665cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da592182b8dcc94402463197ddd95223/" rel="bookmark">
			NMS(非极大值抑制)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近段时间一直在看multi-person pose estimation，在最后有一个剔除候选keypoint的过程，该过程采用的NMS方法。但我一直对NMS不理解，经过查找资料，整理出本人对NMS的理解内容，如有不对请指出。
在引进NMS概念之前我们先介绍IOU(交并比)，因为在NMS中选出框图起到至关重要的作用
1、IOU(交并比)
物体检测需要定位出物体的bounding box，就像上面的图片一样，我们不仅要定位出车辆的bounding box 我们还要识别出bounding box 里面的物体就是车辆。
对于bounding box的定位精度，有一个很重要的概念，那就是定位精度评价公式：IOU。
IOU表示了bounding box 与 ground truth 的重叠度，如下图所示：
矩形框A、B的一个重合度IOU计算公式为：
IOU=Area(A∩B)/Area(A∪B)
就是矩形框A、B的重叠面积占A、B并集的面积比例:
IOU=SI/(SA+SB-SI)
如何计算IOU（交并比）
首先求出重合面积：
选取两个矩形框左顶角的横，纵坐标的最大值，x21，y21；选取两个矩形框右下边角的横纵坐标的最小值，x12，y12;
重合面积计算：
inter= 并集的面积计算：
计算IOU：
具体实例如下：
有了IOU（交并比）的概念理解，接下来我们就进入正题，介绍NMS
2、NMS概念
NMS也即非极大值抑制。在最近几年常见的物体检测算法（包括rcnn、sppnet、fast-rcnn、faster-rcnn等）中，最终都会从一张图片中找出很多个可能是物体的矩形框，然后为每个矩形框为做类别分类概率：
所谓非极大值抑制：依靠分类器得到多个候选框，以及关于候选框中属于类别的概率值，根据分类器得到的类别分类概率做排序，具体算法流程如下：
（1）将所有框的得分排序，选中最高分及其对应的框 （2）遍历其余的框，如果和当前最高分框的重叠面积(IOU)大于一定阈值，我们就将框删除。（为什么要删除，是因为超过设定阈值，认为两个框的里面的物体属于同一个类别，比如都属于狗这个类别。我们只需要留下一个类别的可能性框图即可。）
（3）从未处理的框中继续选一个得分最高的，重复上述过程。
举例说明：（1）（2），这里设定交并比&gt;=0.6就删除对比框图，留下最高分的框图；对于低于阈值的框图留下，然后在剩下的框图中排序，选出置信度值高的框图，然后重复交并比比较这个过程。
（1）选出Dog这个框图
（1）选出Bike这个框图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cafb2044ab4b41f5f49aae9659d4a7a/" rel="bookmark">
			杰魔（Geomagic Design）逆向工程软件学习0-产品逆向工程介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品逆向工程（抄数）：是一般设计工程的逆向。一般为先设计CAD模型，再开模制造产品；而逆向工程则利用3D扫描仪，获取现有产品表面数据，进行模型重构，再获得CAD模型；
需要逆向的文件格式一般为两种，STL\OBJ，像常见的CG软件（3DMAX\Maya\C4D）和园林景观常用的草图大师输出stl文件的格式。stl是三角面片网格，obj是四边形网格。一般而言，文件的变化过程为：点云-STL\OBJ-CAD模型。
常见的STL\OBJ格式文件只有网格数据，他不能拿去开模或者机加工；而step等CAD格式文件可以
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9936da9c9468a84b14a7b3e48d03f26d/" rel="bookmark">
			Windows vbs脚本获取系统信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows vbs脚本获取系统信息 运行的进程硬盘序列号获取制造商获取型号获取生产日期获取主板信息获取SN号获取系统类型及安装日期获取CPU信息获取内存信息获取显卡信息获取声卡型号获取硬盘信息获取光驱信息获取显示器信息获取Network 网卡信息获取Network enable信息获取MAC地址获取IP地址获取计算机名获取CPU使用率获取剩余内存获取内存使用率获取DNS地址获取指定文本中指定内容获取当前时间获取系统补丁包信息获取系统补丁最后更新时间获取管理员用户获取共享文件获取系统补丁更新服务器地址获取已安装软件获取当前登录用户获取系统类型32 64输出格式为json串 strComputer = "." Set objWMIService = GetObject("winmgmts:\\" &amp; strComputer &amp; "\root\CIMV2") set oReg=Getobject("winmgmts:\\" &amp; strComputer &amp; "\root\default:StdRegProv") On Error Resume Next Set fso=CreateObject("Scripting.FileSystemObject") set obshell = wscript.createobject("wscript.shell") Set openFile=fso.OpenTextFile("C:/temp/wmic/opports.txt",1,true) alllines ="" Do while not openfile.atendofstream line = openfile.readline 'Wscript.Echo "line: " &amp; line if instr(line,"LISTENING") then alllines = alllines &amp; line &amp; vbnewline end if loop opports=alllines set openFile=nothing 'Wscript.Echo opports REM '运行的进程' Set colItems = objWMIService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9936da9c9468a84b14a7b3e48d03f26d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/158fda2dc1806aa2682d7f4f63ac9bb1/" rel="bookmark">
			MySQL中并发事务会带来哪些问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.脏读
一个事务在处理过程中读取了另外一个事务未提交的数据。
2. 丢失修改
在第一个事务中修改了数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。
3. 不可重复读
一个事务范围内。多次查询某个数据，却得到不同的结果。实质是违反了事务的一致性原则。
4. 幻读：
幻读是指此事务中没有查到此数据，而在修改时却影响。
隔离级别
脏读
不可重复读
幻读
READ-UMCOMMITTED
×
×
×
READ-COMMITTED
√
×
×
REPEATABLE-READ
√
√
×
SERIALIZABLE
√
√
√
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c75e911b8b0b11c8d6c9bc2dd5a8262f/" rel="bookmark">
			最新Via轻插件下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新Via轻插件下载 今天提供一下最新的Via轻插件下载，再次之前我们首先来介绍一下什么是Via。
via是一款轻量级的Via浏览器体积只有500多KB。和X浏览器一样，这些轻量级浏览器大多使用Android system webview作为核心引擎。虽然很多人说这些浏览器本质上是Chrome浏览器内核，但是我不这么认为。就像Edge和Chrome都是基于Chromium一样，你能说它们都一样吗？你能说它们都像Chrome一样咀嚼内存吗？同一辆凤凰自行车经过不同技术人员的训练是不同的。它是否易于使用，是否适合你。很多时候，你需要经历它才能知道。
当然，这些轻量级浏览器的重点是：简单和速度。和X浏览器一样，Via在这一点上更好。我个人对这两款浏览器的第一次体验是，Via的UI设计比X浏览器好，但在个性化定制方面会差一些。
轻量级浏览器有一个叫via 轻插件的网站，这就类似于谷歌浏览器的的应用商店，我仔细研究了一下，感觉里面很多插件都非常不错，而且作者身为中国人，发布了很多符合国人习惯的插件。我在里面也发现了一些宝藏插件，现在无偿的宣传给你们，嘿嘿，有些插件使用好了记得低调哦？
下面就简单为大家介绍几款个人觉得好用的Via浏览器插件。
via插件下载地址
当然为了大家方便，以上插件可以在公众号：“风炫安全” 回复 ：“via插件” 即可获取。
Via插件-百度网盘直接下载 这个插件是可以直接让你跳过百度网盘的客户端，然后直接进行下载，非常的方便。不过需要先登录百度账号就可以下载了。
效果图：
Via插件-网页复制限制解除 有些网站长按复制被限制了，死活复制不了。装了这个插件后，妈妈再也不用担心我复制不了啦。
由于某些大网站开启了csp名单限制，所以有时会引入失败。
效果图：
Via插件-强制缩放 很多手机网站都是放大不了的，此插件可以让你随意放大。李荣浩再也不用担心我眼睛小看不清楚字啦。
效果图：
Via插件-QQ音乐，MV下载 安装完这个插件之后，在音乐播放界面顶部会有下载按钮。
支持 歌曲 、 多清晰度mv 下载，有些歌曲本身没有 mv ，所以只会显示 歌曲 下载按钮。
朋友圈的音乐党终于不用担心我没有本地循环听他们分享的音乐啦。
效果图：
以上插件可以在公众号：“风炫安全” 回复 ：“via插件” 即可获取。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa156460cdbb60b08d8052641d219373/" rel="bookmark">
			四.Sping之AOP源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文解读AOP是如何增强方法功能的。
需要提前了解@Import 注解的功能：一.Spring之组件注册bean_u014203449的博客-CSDN博客_spring注册bean
BeanPostProcessor 后置处理器的功能:二.Spring之实例生命周期_u014203449的博客-CSDN博客
Aware接口：三.Spring之属性赋值和自动装配_u014203449的博客-CSDN博客
一.演示案列 1、导入aop模块；Spring AOP：(spring-aspects)
&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2、定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）
public class MathCalculator { public int div(int i,int j){ System.out.println("MathCalculator...div..."); return i/j;	} } 3、定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行；
通知方法：
前置通知(@Before)：logStart：在目标方法(div)运行之前运行
后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）
返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行
异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行
环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）
4、给切面类的目标方法标注何时何地运行（通知注解）；
5、将切面类和业务逻辑类（目标方法所在类）都加入到容器中;
6、必须告诉Spring哪个类是切面类(给切面类上加一个注解：@Aspect)
7、标明切点，切点可以是某包、某类、某方法、某注解，通知注解的value值为切点
/** * 切面类 * @author lfy * * @Aspect： 告诉Spring当前类是一个切面类 * */ @Aspect public class LogAspects { //抽取公共的切入点表达式 //1、本类引用 //2、其他的切面引用 @Pointcut("execution(public int com.atguigu.aop.MathCalculator.*(..))") public void pointCut(){}; //@Before在目标方法之前切入；切入点表达式（指定在哪个方法切入） @Before("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa156460cdbb60b08d8052641d219373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5207a21f6dbaaa6b2ff9cac2ca1dfd59/" rel="bookmark">
			usage: conda-script.py [-h] [-V] command ... conda-script.py: error: the following arguments are re
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上看到很多修改condarc文件的说法，各有分说，各有办法，但又不统一。
实际上就是你的tensorflow版本不行
https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/这个国内镜像上下载最新的版本就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a306f6689b5b2f9be55d2b63c23f3521/" rel="bookmark">
			一文带你全面解析postman工具的使用（基础篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		postman是一款支持http协议的接口调试与测试工具，其主要特点就是功能强大，使用简单且易用性好 。无论是开发人员进行接口调试，还是测试人员做接口测试，postman都是我们的首选工具之一 。那么接下来就介绍下postman到底有哪些功能，它们分别都能干些什么 。下面先通过一张图来直观地来看下postman中所包含的功能 。
当然，以上功能也只是展示了postman的一部分功能，为了能更加全面的体现这款工具的特点，我将从以下三个维度来加以说明。它们分别是：
基础功能 常见类型的接口请求接口响应数据的解析接口管理(Collection)批量执行接口请求日志调试断言变量请求前置脚本接口关联常见的返回值获取便捷功能 快速填写查询参数快速填写请求头信息快速实现添加一个请求如何继承集合认证批量断言快速查询和替换高级功能 读取文件进行参数化生成测试报告代码中发送请求编写接口文档mock服务监控使用工作空间代码同步与分支管理连接数据库apis 一、postman安装说明 postman在2018年之后就不再支持浏览器版本，所以，想要使用它就必须先下载客户端再安装使用，下面就以Windows系统为例进行安装 。
1.下载与安装 postman安装步骤：
访问postman官方网站，下载最新版本，访问地址：https://www.getpostman.com/进入到下载页面，根据自己电脑下载对应的版本 双击下载的安装包，进入到安装界面，直到用户登录和注册界面。 若个人使用，选择跳过即可，这时会进入到postman主界面，至此postman安装成功(下图)若团队使用，可以进行注册，注册后使用账号可以加入团队工作区 2.界面导航说明 初次使用postman的朋友可能对界面上的一些元素不太熟悉，下面就通过一张图来说明这些元素的含义 。
3.发送第一个请求 如果你是第一次使用postman发送请求，下面这个例子可以作为一个最基本的入门，可以帮我们建立一个初始印象 。
打开postman，点击+加号打开一个新的请求页。在请求的URL中输入请求地址：http://www.weather.com.cn/data/sk/101010100.html点击Send按钮，这时就可以在下部的窗格中看到来自服务器的json响应数据。 二.postman基础功能 1.常见类型的接口请求 常见的接口有如下四种类型，分别是含有查询参数的接口，表单类型的接口，json类型的接口以及含有上传文件的接口，以下就对这四种类型接口及如何在postman中请求进行说明 。
1.1 .查询参数的接口请求 什么是查询参数?
所谓的查询参数，其实就是URL地址中问号（?）后面的部分就叫查询参数，比如：http://cx.shouji.360.cn/phonearea.php?number=13012345678 。在这个接口中，查询参数就是:number=13012345678 。而这一部分是由有键值对组成，格式为：key1=value1&amp;key2=value2, 如果有多组键值对，要用&amp;隔开 。
postman如何请求
在postman中实现对这类接口请求非常简单，一般就需要明确俩个参数即可，一个是请求方法，一个请求地址。
针对上面的那个接口，地址已经给出 ，而它的请求方法是get 。那么在postman中只需要把这俩个参数填写上即可请求 。
具体实现步骤：
打开postman，新建一个请求。在请求方法中选择请求方法：GET,因为在postman中默认的请求方法就是GET,所以这一步可以忽略接口URL中输入地址，点击Send按钮就可以发送请求了 。 说明：查询参数的URL一般直接拷贝到输入的URL地址栏中就可以了，当然也可以把查询参数在Params中输入，俩者的效果是一样的 。
1.2 表单类型的接口请求 什么是表单 ？
我们都知道，在发送HTTP请求的时候，一个请求中一般包含三个部分，分别是请求行，请求头，请求体 。
不同的接口，请求体的数据类型是不一样的，比较常见的一种就是表单类型，那么什么是表单类型呢 ？ 简单理解就是在请求头中查看Content-Type，它的值如果是:application/x-www-form-urlencoded .那么就说明客户端提交的数据是以表单形式提交的 。见下图
postman中如何请求？
如果在postman请求上图的接口，我们只需要填写四个参数，分别是(可以参考上图)：
请求方法：POST请求URL：http://localhost/index.php?m=Home&amp;c=User&amp;a=do_login&amp;t=0.21942974229794432请求头：Content-Type：application/x-www-form-urlencode请求体： username=13088888888&amp;password=123456&amp;verify_code=8888 实现步骤：
打开postman，新建一个请求 。在请求中设置以上四个参数，点击Send按钮。在postman中设置请求体类型为，需要选择body-&gt; x-www-form-urlencoded查看响应数据。 1.3 上传文件的表单请求 在做接口测试时，我们经常会遇到需要上传文件的接口，比如微信的更新头像。这就需要用到：multipart/form-data。它也属于一种表单，但它既支持表单请求，也支持文件上传。 它的请求报文中数据往往是下面这样的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a306f6689b5b2f9be55d2b63c23f3521/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6abe72d9334effb417f87aa567ef3626/" rel="bookmark">
			【Proteus仿真】【51单片机】简易信号发生器设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、主要功能二、使用方法三、硬件资源四、软件设计1、主要代码 五、实验现象联系作者 一、主要功能 1、可生成常用波形，方波、锯齿波、三角波、阶梯波、正玄波；
2、可通过按键切换不同波形输出；
二、使用方法 系统运行后，按下K1键输出方波信号，按下K2键输出锯齿波，按下K3键输出三角波，按下K4键输出阶梯波，按下K5键输出正弦波。可通过示波器测量显示输出波形。
三、硬件资源 1、51单片机核心模块
2、DAC0832模块
3、按键模块
四、软件设计 1、主要代码 代码如下：
#include &lt;reg52.h&gt; #include &lt;absacc.h&gt; #define uint unsigned int #define uchar unsigned char #define DAC0832 XBYTE[0xfffe] sbit k1=P1^0; sbit k2=P1^1; sbit k3=P1^2; sbit k4=P1^3; sbit k5=P1^4; sbit beep=P1^7; unsigned char mm=0; unsigned char flag=0; unsigned char x,y; uchar code SETTAB[]={ //正弦波数据(正部分) 0x80, 0x83, 0x86, 0x89, 0x8D, 0x90, 0x93, 0x96, //(正上升部分) 0x99, 0x9C, 0x9F, 0xA2, 0xA5, 0xA8, 0xAB, 0xAE, 0xB1, 0xB4, 0xB7, 0xBA, 0xBC, 0xBF, 0xC2, 0xC5, 0xC7, 0xCA, 0xCC, 0xCF, 0xD1, 0xD4, 0xD6, 0xD8, 0xDA, 0xDD, 0xDF, 0xE1, 0xE3, 0xE5, 0xE7, 0xE9, 0xEA, 0xEC, 0xEE, 0xEF, 0xF1, 0xF2, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFD, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFD, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0xF8, 0xF7, 0xF6, //(正下降部分)80 0xF5, 0xF4, 0xF2, 0xF1, 0xEF, 0xEE, 0xEC, 0xEA, 0xE9, 0xE7, 0xE5, 0xE3, 0xE1, 0xDE, 0xDD, 0xDA, 0xD8, 0xD6, 0xD4, 0xD1, 0xCF, 0xCC, 0xCA, 0xC7, 0xC5, 0xC2, 0xBF, 0xBC, 0xBA, 0xB7, 0xB4, 0xB1, 0xAE, 0xAB, 0xA8, 0xA5, 0xA2, 0x9F, 0x9C, 0x99, 0x96, 0x93, 0x90, 0x8D, 0x89, 0x86, 0x83, 0x80, //正弦波数据(负部分) 0x80, 0x7C, 0x79, 0x78, 0x72, 0x6F, 0x6C, 0x69 , //(负下降部分)128,0x80 0x66, 0x63, 0x60, 0x5D, 0x5A, 0x57, 0x55, 0x51 , 0x4E, 0x4C, 0x48, 0x45, 0x43, 0x40, 0x3D, 0x3A , 0x38, 0x35, 0x33, 0x30, 0x2E, 0x2B, 0x29, 0x27 , 0x25, 0x22, 0x20, 0x1E, 0x1C, 0x1A, 0x18, 0x16 , 0x15, 0x13, 0x11, 0x10, 0x0E, 0x0D, 0x0B, 0x0A , 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02 , 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02 , 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09 , //(负上升部分)//80 0x0A, 0x0B, 0x0D, 0x0E, 0x10, 0x11, 0x13, 0x15 , 0x16, 0x18, 0x1A, 0x1C, 0x1E, 0x20, 0x22, 0x25 , 0x27, 0x29, 0x2B, 0x2E, 0x30, 0x33, 0x35, 0x38 , 0x3A, 0x3D, 0x40, 0x43, 0x45, 0x48, 0x4C, 0x4E , 0x51, 0x55, 0x57, 0x5A, 0x5D, 0x60, 0x63, 0x66 , 0x69, 0x6C, 0x6F, 0x72, 0x76, 0x79, 0x7C, 0x80 }; void DelayMS(uint ms) { uchar i; while(ms--) { for(i=0;i&lt;120;i++); } } void delay(uint i) { while(i--);	} void sound() { uchar i=100; while(i--) { beep=~beep; delay(100); } } void fangbo() { DAC0832=y; x++; if(flag==0) {	y=0xff; if(x==128) { flag=1; y=0x00; } //方波+ } else { y=0x00; if(x==0) { flag=0; y=0xff; } //方波- } } void juchibo() //锯齿波 { DAC0832=y; y+=1; } void sanjiaobo() //三角波 { DAC0832=y; x++; if(flag==0) { y+=2; //三角波数据(上升部分) if(x==128) { flag=1; y-=2; } } else { y-=2; if(x==0) { flag=0; y=0; } //三角波数据(下升部分) } } void jietibo() //阶梯波 { DAC0832=y; y+=25; } void sin() //正弦波 { DAC0832=SETTAB[y]; x++; y++; } void read_key() { if(k1==0)	//方波 { DelayMS(10); if(k1==0) { mm=1; while(k1==0); } } else if(k2==0) { DelayMS(10); if(k2==0) { mm=2; while(k2==0); } } else if(k3==0)	// 三角波 { DelayMS(10); if(k3==0) { mm=3; while(k3==0); } } else if(k4==0) { DelayMS(10); if(k4==0) { mm=4; while(k4==0); } } else if(k5==0)	//正弦波 { DelayMS(10); if(k5==0) { mm=5; while(k5==0); } } } void main() { TMOD=0x02; TL0=156; TH0=156; TR0=1; ET0=1; EA=1; mm=0; for(;;) { read_key(); } } void t_0() interrupt 1 using 2 { switch(mm) { case 1: fangbo();break; case 2: juchibo();break; case 3: sanjiaobo();break; case 4: jietibo();break; case 5: sin();break; } } 五、实验现象 B站演示视频：https://space.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6abe72d9334effb417f87aa567ef3626/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b38eaab7d92f87607b5007416f32af3d/" rel="bookmark">
			GPU和CPU计算上的精度差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 文章来源：CSDN@LawsonAbs晚上跑代码，想比较两种方法计算结果之间是否相同，理论上计算结果应该一致，但是比较结果就是二者不一致，错误排查了很久，怎么都不知道哪儿错了？难道机器真的算错了吗？本代码可以在我的github中找到 为了清楚演示具体的差异，抽象出如下简单的代码片段：
示例 简单看一个例子，看看其在cuda和cpu下的计算表现
1. cuda下的矩阵乘法 可以看到GPU下的计算：很显然的二者应该相同，但是在GPU的计算下是二者竟然不等！
2. cpu 下的矩阵乘法 其实在找“问题”的时候，我猜测过是不是因为精度问题（但是没有多想，心想着GPU精度再差，也不至于万分位就差了吧 -_-||）， 但哪知道还真是这个问题！当代码变多，很难立马定位到到底是什么地方出了问题，排查问题的过程就变的非常困难！之前我也听过cuda精度之类的一点儿东西，但是从未放在心上，终于花了一个多小时去找这个问题，才知道有这个坑，果然是坑只有自己踩过才知道。。。
原因 GPU端计算浮点数精度和CPU端不同。GPU默认是float精度，CPU默认是double精度。这就意味着在GPU作浮点数乘除计算结果如果累计的话，必然存在误差。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de0aebcce527bd90d3c1ffb2d4e5a3b/" rel="bookmark">
			【ROS&amp;GAZEBO】多旋翼无人机仿真（三）——自定义多旋翼模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【ROS&amp;GAZEBO】多旋翼无人机仿真（一）——搭建仿真环境
【ROS&amp;GAZEBO】多旋翼无人机仿真（二）——基于rotors的仿真
【ROS&amp;GAZEBO】多旋翼无人机仿真（三）——自定义多旋翼模型
【ROS&amp;GAZEBO】多旋翼无人机仿真（四）——探索控制器原理
【ROS&amp;GAZEBO】多旋翼无人机仿真（五）——位置控制器
上一篇介绍了如何用rotors进行仿真，这一篇继续介绍在ROS&amp;GAZEBO中如何自定义多旋翼模型。
搭建模型 在GAZEBO搭建模型第一步是建一个模型，可以在GAZEBO中直接设计模型，也可以通过导入STL文件建立模型，这里我选择后者，用SolidWorks设计了一个四旋翼模型导入到GAZEBO，
设计的简化四旋翼模型如下：
下一步是导出STP格式，这里要注意一点是导出时要注意坐标系的方向，这里我们需要对齐到NED（北东地）坐标系，
下一步导出STL格式，这里一定要选对参考坐标系。
搭建工作空间 导出模型完成之后，需要开始建立ROS包，在第一篇【ROS&amp;GAZEBO】多旋翼无人机仿真（一）——搭建仿真环境 中已经搭建好了ROS工作空间，同时第二篇【ROS&amp;GAZEBO】多旋翼无人机仿真（二）——基于rotors的仿真中的rotors包也是必须要的，如果没有完成的可以翻回去学习。下面开始搭建自定义模型的ROS包
首先建立文件夹
mkdir ~/catkin_ws/src/reed_simulator mkdir ~/catkin_ws/src/reed_simulator/reed_gazebo mkdir ~/catkin_ws/src/reed_simulator/reed_gazebo_plugin mkdir ~/catkin_ws/src/reed_simulator/reed_gazebo/urdf mkdir ~/catkin_ws/src/reed_simulator/reed_gazebo/launch mkdir ~/catkin_ws/src/reed_simulator/reed_gazebo/meshes 这里reed_gazebo_plugin文件夹是后面添加自定义插件用的，暂时用不上
然后在reed_gazebo文件夹中新建CMakeLists.txt和package.xml
CMakeLists.txt中编写下面代码
cmake_minimum_required(VERSION 2.8.3) project(reed_gazebo) add_definitions(-std=c++11) #--------------------------# # Generation of SDF models # #--------------------------# # We need Gazebo version &gt;= 3.0.0 to generate iris.sdf file # (gz sdf ... command needs to be available) find_package(gazebo REQUIRED) find_package(PythonInterp REQUIRED) find_package(catkin REQUIRED COMPONENTS gazebo_msgs geometry_msgs roscpp sensor_msgs) catkin_package( CATKIN_DEPENDS gazebo_msgs geometry_msgs roscpp sensor_msgs ) include_directories(include ${catkin_INCLUDE_DIRS}) foreach(dir launch models resource worlds) install(DIRECTORY ${dir}/ DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}/${dir}) endforeach(dir) package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1de0aebcce527bd90d3c1ffb2d4e5a3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea82860abe999b28970eea3bfcfec9f6/" rel="bookmark">
			【ROS&amp;GAZEBO】多旋翼无人机仿真（五）——位置控制器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【ROS&amp;GAZEBO】多旋翼无人机仿真（一）——搭建仿真环境
【ROS&amp;GAZEBO】多旋翼无人机仿真（二）——基于rotors的仿真
【ROS&amp;GAZEBO】多旋翼无人机仿真（三）——自定义多旋翼模型
【ROS&amp;GAZEBO】多旋翼无人机仿真（四）——探索控制器原理
【ROS&amp;GAZEBO】多旋翼无人机仿真（五）——位置控制器
上一篇我们说了rotors中使用了位置控制器节点控制多旋翼的位姿，这一篇我们继续来深入探索位姿控制器的算法
接上篇，我们打开ComputeDesiredAcceleration函数，来看看位置控制究竟是怎样实现的
void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const { assert(acceleration); Eigen::Vector3d position_error; position_error = odometry_.position - command_trajectory_.position_W; // Transform velocity to world frame. const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix(); Eigen::Vector3d velocity_W = R_W_I * odometry_.velocity; Eigen::Vector3d velocity_error; velocity_error = velocity_W - command_trajectory_.velocity_W; Eigen::Vector3d e_3(Eigen::Vector3d::UnitZ()); *acceleration = (position_error.cwiseProduct(controller_parameters_.position_gain_) + velocity_error.cwiseProduct(controller_parameters_.velocity_gain_)) / vehicle_parameters_.mass_ - vehicle_parameters_.gravity_ * e_3 - command_trajectory_.acceleration_W; } 首先是计算位置误差position_error，这里很好理解，这里注意一点是实际减去期望
position_error = odometry_.position - command_trajectory_.position_W; 接下来是计算速度误差velocity_error，ROS中的速度是在机体系下表示的，因此需要旋转到世界坐标系
这里const Eigen::Matrix3d R_W_I = odometry_.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea82860abe999b28970eea3bfcfec9f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d28d6d68578fec00b87fc73f285063e/" rel="bookmark">
			opencv-python基础操作汇总——1（读取、画线、平移，旋转缩放、翻转和裁剪等操作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近中日合作活动中要求使用opencv-python，于是我就复习一下，做个小总结，😄。
1. 读取并显示 注意：opencv读取时，默认是BGR格式，且是numpy.ndarray类型
import cv2 import matplotlib.pyplot as plt image = cv2.imread('./im0.png') # 默认读取BGR格式 print('图片的高:', image.shape[0]) print('图片的宽:', image.shape[1]) print('图片的通道数:', image.shape[2]) plt.imshow(image) # plt.axis('off') # 不显示坐标 plt.show() 效果如下：
2. 转为RGB图片并保存 import cv2 import matplotlib.pyplot as plt image = cv2.imread('./im0.png') # 默认读取BGR格式 image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) plt.imshow(image) # plt.axis('off') # 不显示坐标 plt.show() cv2.imwrite('new_img.jpg') 效果如下：
3. 画线 3.1 直线 可以使用cv2.line
第一个参数是图片的各个维度的值， 第二个参数是起始坐标，第三个参数是终止坐标， 第四个参数是画线颜色的RBG的值， 第五个参数是线的宽度。
import cv2 import matplotlib.pyplot as plt import numpy as np image = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d28d6d68578fec00b87fc73f285063e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e6edfaafa4b81e1db7551783045906f/" rel="bookmark">
			python调用ffmpeg库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ffmpeg-python库可以用来在python里调用ffmpeg完成码流获取，转换，转发等操作
ffmpeg-python: Python bindings for FFmpeg — ffmpeg-python documentation
官网就有很多例子
还有个库是pyav
PyAV Documentation — PyAV 8.0.2.dev0 documentation
ffmpeg编译的参数设置：
ffmpeg configure配置选项_一个人像一支队伍-CSDN博客_ffmpeg许可证
编译后找不到库的处理
解决ffmpeg执行报错“ffmpeg: error while loading shared libraries: libavdevice.so.58: cannot open shared object file: No such file or directory”的问题 - Comex - 博客园
综合解决ffmpeg安装及运行问题
安装开发包
简单的摄像头转udp码流的python例子
import ffmpeg video_format = "mpegts" server_url = "udp://127.0.0.1:1236" process = ( ffmpeg .input("/dev/video0") .output( server_url, # codec = "copy", # use same codecs of the original video listen=1, # enables HTTP server f=video_format) # .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e6edfaafa4b81e1db7551783045906f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/617a9616f2bd046795129d99d35de748/" rel="bookmark">
			SOLIDWORKS软件安装：SQL server安装失败--解决办法；无法获得下列许可 SOLIDWORKS Standard
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SQL server安装失败错误显示解决办法 无法获得下列许可 SOLIDWORKS Standard错误显示解决办法 SQL server安装失败 错误显示 可执行文件 “F:\PreReqs\SQLServer\en_sql_server_2019_express_x64_e2d9f596.exe” /ConfigurationFile=“C:\ProgramData\SOLIDWORKS Electrical\SWSQLSetup.ini” /IACCEPTSQLSERVERLICENSETERMS /Q /SAPWD=SQLpwd4ew /AGTSVCPASSWORD=SQLpwd4ew 未成功安装。未成功: Microsoft SQL Server (安装)在线解决方案 解决办法 关闭软件，重启电脑，再试一次原来的步骤。
安装成功。
没有拍照、截图，太着急了。
无法获得下列许可 SOLIDWORKS Standard 错误显示 SOLIDWORKS
×无法获得下列许可 SOLIDWORKS Standard。
无效的(不一致的)使用许可号码。(-8,544,0)确定
安装完成后，双击SOLIDWORKS快捷键图标，出现以下画面：
解决办法 复制安装包下的 netapi32.dll 文件
粘贴到安装位置中的 SOLIDWORKS 空白处 下图是原电脑安装位置
D:\APP\SOLIDWORKS Corp\SOLIDWORKS
（这是我的安装位置）
在此空白处粘贴 然后就可以打开啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/650ece7d1e3d484d5f633d2c919bf607/" rel="bookmark">
			AFL位图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AFL使用边覆盖作为覆盖信息度量，相比于块覆盖能够包含更多信息，相比于路径覆盖更易于操作，是一种择中的考虑。AFL的反馈机制是将边散列到64KB位图中的一个位置。下面介绍几个概念
基本块：程序顺序执行的语句序列，只有一个入口，一个出口 只有一个入口，表示程序中不会有其它任何地方能通过jump跳转类指令进入到此基本块中。 只有一个出口，表示程序只有最后一条指令能导致进入到其它基本块去执行。 所以，基本块的一个典型特点是：只要基本块中第一条指令被执行了，那么基本块内所有执行都会按照顺序仅执行一次。 边：一个基本块跳转到另一个基本块 位图 AFL中有四个关键位图
trace_bits[MAP_SIZE] // 当前用例执行情况 virgin_bits[MAP_SIZE] // 所有用例执行情况 virgin_tmout[MAP_SIZE] // 超时用例执行情况 virgin_crash[MAP_SIZE] // 崩溃用例执行情况 对于边的覆盖情况计数，通过下面操作实现
cur_location = R(MAP_SIZE); // 给基本快随机赋值 sh_mem[cur_location ^ prev_location]++; // 边访问计数 prev_location = cur_location &gt;&gt; 1; // 避免出现A-A和B-B，A-B和B-A无法区分的问题 其中cur_location ^ prev_location作为实际的边id，访问到这个边的时候，相应下标处访问次数加1
simplify_trace函数 simplify_trace函数所做的操作是将边实际的执行次数划分为执行过和未执行过两类，如果未执行过，对应的位置为1，如果执行过，对应的位置为128。 static const u8 simplify_lookup[256] = { [0] = 1, [1 ... 255] = 128 }; // if mem8[i] == 0 mem8[i] = 1; 0000 0001 not hit new edge // if mem8[i] == 1~255 mem8[i] = 128; 1000 0000 hit new edge static void simplify_trace(u64* mem) { u32 i = MAP_SIZE &gt;&gt; 3; while (i--) { if (unlikely(*mem)) { u8* mem8 = (u8*)mem; mem8[0] = simplify_lookup[mem8[0]]; mem8[1] = simplify_lookup[mem8[1]]; mem8[2] = simplify_lookup[mem8[2]]; mem8[3] = simplify_lookup[mem8[3]]; mem8[4] = simplify_lookup[mem8[4]]; mem8[5] = simplify_lookup[mem8[5]]; mem8[6] = simplify_lookup[mem8[6]]; mem8[7] = simplify_lookup[mem8[7]]; } else *mem = 0x0101010101010101ULL; mem++; } } classify_counts函数 classify_counts函数的功能是把实际的执行次数进行重新计数，分到8个计数桶中，即0, 1, 2, 4, 8, 16, 32, 64, 128，0~255之间的实际执行次数最终都会被分到这8个计数桶中，从而对位图重新赋值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/650ece7d1e3d484d5f633d2c919bf607/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b35aa8aa69eb9267ecf3532cf4dad3b/" rel="bookmark">
			MySQL基础——DML（Data Manipulation language）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、插入语句1.1方式一1.2方式二 二、修改语句2.1修改单表的记录 ★2.2 修改多表的记录【补充】 三、删除语句3.1 使用delete3.1.1 除单表的记录★3.1.2 级联删除[补充]（多表的删除） 3.2 使用truncate 一、插入语句 1.1方式一 语法：
insert into 表名(字段名,...) values(值,...); 特点：
1、要求值的类型和字段的类型要一致或兼容
insert into beauty(id,name,sex,borndate,phone,photo,boyfriend_id) values (13,'晓彤','女','1997-4-15','17853219640',null，2) 2、字段的个数和顺序不一定与原始表中的字段个数和顺序一致 但必须保证值和字段一一对应
3、假如表中有可以为null的字段，注意可以通过以下两种方式插入null值
①字段和值都省略
insert into beauty(id,name,sex,borndate,phone,boyfriend_id) values (13,'晓彤','女','1997-4-15','17853219640'，2) ②字段写上，值使用null
insert into beauty(id,name,sex,borndate,phone,photo,boyfriend_id) values (13,'晓彤','女','1997-4-15','17853219640',null，2) 4、字段和值的个数必须一致
5、字段名可以省略，默认所有列，且列的顺序和表中的顺序一致
insert into beauty values (13,'晓彤','女','1997-4-15','17853219640',null，2) 1.2方式二 语法：
insert into 表名 set 字段=值,字段=值,...; #案例： insert into beauty set id= 19, name = 'anna',phone = '13978435672'; 两种方式 的区别：
1.方式一支持一次插入多行,方式二不支持，语法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b35aa8aa69eb9267ecf3532cf4dad3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e0d0e082deaa4ab0f5d9ec6d5314f4/" rel="bookmark">
			Golang strings.HasPrefix函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 描述 HasPrefix 函数用于测试字符串是否以指定前缀开头
函数源码 //go version 1.17.7 // HasPrefix tests whether the string s begins with prefix. func HasPrefix(s, prefix string) bool { return len(s) &gt;= len(prefix) &amp;&amp; s[0:len(prefix)] == prefix } HasPrefix函数需要传递两个参数。
参数一：要测试的字符串参数二：指定前缀字符串返回值：布尔型
当参数一长度大于等于参数二并且参数一的前len(参数二)个字符与参数二相同则返回True. 代码示例 package main import ( "fmt" "strings" ) func main() { url := "http://www.baidu.com" str := "http://" if strings.HasPrefix(url, str) { fmt.Printf("目标字符串以\"%s\"开头", str) } else { fmt.Printf("目标字符串不以\"%s\"开头", str) } } 输出结果 目标字符串以"http://"开头 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d5f9574b219a7a4cf421a4df0df94dc/" rel="bookmark">
			CTF中简单杂项小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MISC1 参考
CTF Wiki MISC
简介 主要分为几个板块：Recon,Forensic,Stego,Crypto（古典密码）…
Recon：信息收集
主要介绍一些获取信息的渠道和一些利用百度、谷歌等搜索引擎的技巧 Encode（编码转换）
主要介绍在 CTF 比赛中一些常见的编码形式以及转换的技巧和常见方式 Forensic &amp;&amp; Stego（数字取证 &amp;&amp; 隐写分析）
隐写取证是 Misc 中最为重要的一块，包括文件分析、隐写、内存镜像分析和流量抓包分析等等，涉及巧妙的编码、隐藏数据、层层嵌套的文件中的文件，灵活利用搜索引擎获取所需要的信息等等。 一张概图
信息收集技术 网络收集 公开渠道
目标 Web 网页、地理位置、相关组织
组织结构和人员、个人资料、电话、电子邮件
网络配置、安全防护机制的策略和技术细节
通过搜索引擎查找特定安全漏洞或私密信息的方法
Google Hacking Database
科学上网
GoogleHacking
site 指定域名 Intext 正文存在关键字的网页 Intitle 标题存在关键字的网页 Info 一些基本信息 Inurl URL存在关键字的网页 Filetype 搜索指定文件类型 + 强制包含某个字符进行查询 - 忽略某个字符 ""精准匹配某个字符 .匹配单个字符进行查询 *匹配任意字符进行查询 |或者 基本搜索 Google 基本搜索与挖掘技巧保持简单明了的关键词使用最可能出现在要查找的网页上的字词尽量简明扼要地描述要查找的内容选择独特性的描述字词社会公共信息库查询个人信息：人口统计局企业等实体：YellowPage、企业信用信息网网站、域名、IP：whois 等 地图街景 国外：Google Map、Google Earth、Google Street View国内：百度地图、卫星地图、街景从网络世界到物理世界：IP2Locationwhois 数据库GeoIP纯真数据库（QQ IP 查询） 编码技术 Morse 参见 摩尔斯编码 - 维基百科
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d5f9574b219a7a4cf421a4df0df94dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/701d27a84a40f6d2493b57c3d0e6a5be/" rel="bookmark">
			IDEA 中的 @NonNls 注解的引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Incompatible types. Found: 'java.lang.@org.jetbrains.annotations.NonNls String', required: 'java.lang.String'
原因：IDEA插件版本与JDK版本不一致引起问题；
解决：将工程（project）中所有模块的插件版本与JDK版本配置成一致的（一般是最新的）
IDEA插件的版本的配置，设置到安装IDEA的路径即可自动检测到对应的版本信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3520749d6c51004521ea46bf27d25fec/" rel="bookmark">
			蛋白&#43;小分子配体md（详细保姆教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继续搬一点近期飞书文档模拟的到博客里
参考博客： Gromac中文教程：https://jerkwin.github.io/GMX/GMXtut-5/#%E6%A6%82%E8%BF%B0https://www.jianshu.com/p/b10fe4b4af11https://www.bilibili.com/read/cv6496041/ 生成小分子过程 生成：charm gui 官网：https://charmm-gui.org/?doc=input/pdbreader&amp;step=0 PDBID：6kyk，6kyh。生成时注意选择第一个。 在GNP文件中的mol2CGenFF上传 mol2:https://cgenff.umaryland.edu/userAccount/userLogin.php#20220227_5/6kyk_gnp.err。下载str，生成prm、itp、pdb python cgenff_charmm2gmx_py3_nx2.py GNP GNP.mol2 gnp.str charmm36-mar2019.ff 注意NetworkX版本，若是最新版不一致，将self.G.node替换成新版语法self.G.nodes力场下载地址：http://mackerell.umaryland.edu/charmm_ff.shtml#charmm生成gro文件 gmx pdb2gmx -ignh -ff charmm36-mar2019 -f 6kyh_mg.pdb -o 6kyh.gro -p 6kyh.top -water tip3p gmx editconf -f gnp_ini.pdb -o gnp.gro 将小分子gro坐标添加进6kyh.gro，修改gro原子数,32399 prm，itp文件include到6kyh.top，，增加GNP 1到top。一定要注意include prm文件的位置，一定要在所有的分子itp文件之前，力场文件之下，否则会导致GROMACS无法识别加入的小分子。 # add gro , +49 # vim 6kyh.top，注意位置，prm一定要在所有的itp之前，而在力场之下。 ; Include ligand topology #include "gnp.prm" #include "gnp.itp" 模拟 水盒子 gmx editconf -f 6kyh.gro -o 6kyh-PBC.gro -bt dodecahedron -d 1.0 真空最小化 gmx grompp -f em-vac-pme.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3520749d6c51004521ea46bf27d25fec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd70734e5d572ee25464ded3abf54715/" rel="bookmark">
			协议数据单元I-PDU Multiplexer深入理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PDU的全称是Protocol Data Unit，也就是协议数据单元的意思，而在Autosar的规范中描述的是自动共享服务器基本软件模块I-PDU多路复用器I-PDU M的功能、api和配置。
PDU多路复用意味着使用PDU（协议数据单元）的相同PCI（协议控制信息），其SDU（服务数据单元）的多个唯一布局。选择器字段是多路PDU的SDU的一部分。它用于区分多路pdu之间的内容。
pdu的多路复用是目前已知的来自CAN的方法，但并不局限于此通信系统。（而对于CAN通信不懂的同学，可以在网上查一查看看，关于CAN的资料再网上还是蛮多的）。
在发送方端，I-PDU多路复用器模块负责将适当的I-PDU从COM组合到新的、多路复用的I-PDU，并将它们发送回PDU Router。
在接收端，它负责解释多路I-PDU的内容，并考虑到选择器字段的值，为COM提供适当的分离I-PDU。 对于多路i-pdu的传输，则是不能考虑最小的观测数值的。而对于具有静态布局的容器PDU的传输，如果两个或多个包含的PDU每个都具有MDT配置，则不能保证最小的观测数值。
而对于各个模块的依赖性，因为博主是做跟Autosar相关的技术研究，所以以下只列出跟Autosar相关的Dependencies to modules，如果如果其他人做的不属于这个方面的技术，就仅当了解好了，下面我们看一下这个图，是来自Autosar的SWS里的I-PDU Multiplexer文档。
IPDU-M被AUTOSAR中的PDU Router旁边；而IPDU-M则不能直接访问AUTOSAR OS，有的同学可能不太理解AUTOSAR OS到底是什么，在这里可以把它暂时理解成一个系统，后面我会进行一个详细的讲解。
而RTE又包含着BSW-Scheduler，这里有可能大家又不理解了，我直接上个图吧，看着图可能会好理解一些，这是AUTOSAR的基本架构，后面我有可能会说，看看时间的安排了。
IpduM模块依赖于BSW调度器，分别在IpduMRx时间库或MTx时间库中配置的时间点调用IpduM_MainFunctionRx和IpduM_MainFunctionTx。
下面总结了IpduM所需要的来自PDU Router的功能：指示输入的多路复用或包含的i-pdu；输出i-pdu的发送接口；在外部去证实来自I-PDU的发送的报文。
以下列表总结了IpduM模块为PDU Router提供的功能：可进行多路复用的输入I-pdu和待拆卸的输入容器-pdu的指示接口；发送接口为多路复用的i-pdu和i-pdu相结合，它们将被组装成一个容器PDU；对已传输的IPDU的接口进行确认。
而PDU Router模块的配置必须来自IPDU，它属于多路复用的I-pdu，通常表示为多路复用的I-PDU的静态或动态部分，都被Router到IPDUM模块。
PDU-Router（例如查找表）的配置必须能够使相关的I-PDU被Router到IPDUM。
而COM的话由于IpduM模块的配置依赖于自动共享COM模块的相应配置。对于每个多路复用的I-PDU，静态部分和动态部分的每个布局都需要有不同的i-pdu。对COM不了解的同学网上的资料也挺全的，可以去自行了解。IpduM进一步假设正确的字段选择器的值已经包含在表示动态部分的COM的模块I-PDU中。而所包含的i-pdu则不依赖于COM配置。
IPDUM 的定义和布局
多路复用的I-PDU由静态部分和一个动态部分组成，其中静态部分由零个或多个信号或信号组组成。而动态部分由选择字段和一个或多个信号或信号组组成; I-PDU的动态部分可与C语言的集合相媲美。根据I-PDU内的选择器字段的值，系统会选择I-PDU的实际布局。
静态部件和动态部件的位置可根据I-PDU进行配置。静态部分和动态部分可以被细分为不同的部分。对于每个多路复用的I-PDU，只能定义一个选择器字段。选择器字段具有1到16个连续位之间的可配置大小，其位置可以通过配置来定义，选择器字段的值解释了如何去定义I-PDU的动态部分的内容。
静态部分有一个COMI-PDU，一个复用IpduMI-PDU的动态部分的每个布局有一个COMI-PDU，因此IpduM最多组合两个COM的I-PDU。对于通过IpduM模块的I-PDU数据传输路径，在IpduM模块内分配了一个缓冲区。这个缓冲区需要初始化，因为它可能在COM模块完全填充数据之前传输。此缓冲区的初始化数据来自COM模块配置的初始值。为了进行优化，缓冲区可以在配置时计算出初始位模式，然后在运行时进行复制。
在COM内部，静态部分有独立的i-pdu，多路的I-PDU每个动态部分都有一个。静态部分和动态部分在COM中被视为单独的i-pdu，并且它们有属于自己的I-PDU ID。
IpduM模块提供了一个IpduM_Transmit功能，使PDU路由器能够启动一个I-PDU的传输；每个输出的I-PDU都有一个初始值，因此，在静态和动态部件从COM发送到IpduM之前，IpduM模块传输I-PDU，则传输由配置定义的值。如果多路I-PDU仅通过更新动态或静态部分来触发发送，那么如果在两次传输之间进行多次更新，非触发部分可能会被覆盖。
IpduM模块通过分离的两个来自PDU Router模块的两个传输请求来接收多路I-PDU的静态和动态部分。
有时，IpduM模块可能不只是发送本地存储的部分，因为这些部分可能包含过时的信息，例如update bits。因此，IpduM支持每个部分都有一个可配置的即时更新机制。
通信硬件抽象(CAN接口、Lin接口、FlexRay接口)接收的每个I-PDU都给PDU Rouer。PDU Router将i-pdu多路router到IpduM模块。IpduM模块分别将多路I-PDU的静态和动态部分路由到其目的地。在配置时就可以知道，传入的I-PDU ID对应于配置了静态部分的多路复用的I-pdu。仅通过I-PDUID就可以确定是否存在静态部件。
没有要求处理或通知配置错误的部件。因此，如果接收到的I-PDU包含未在此ECU上为接收配置的段，则将忽略它们。此外，如果I-PDU配置的PduLength为0，它也将被忽略，因为不能配置有意义的处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c8296ffcc9a6744d5b074ad1a8d958/" rel="bookmark">
			Win10 无线网络已连接网络状态显示未连接（地球图标）的快速解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows Registry Editor Version 5.00
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NlaSvc\Parameters\Internet]
"ActiveDnsProbeContent"="131.107.255.255"
"ActiveDnsProbeContentV6"="fd3e:4f5a:5b81::1"
"ActiveDnsProbeHost"="dns.msftncsi.com"
"ActiveDnsProbeHostV6"="dns.msftncsi.com"
"ActiveWebProbeContent"="Microsoft NCSI"
"ActiveWebProbeContentV6"="Microsoft NCSI"
"ActiveWebProbeHost"="www.msftncsi.com"
"ActiveWebProbeHostV6"="ipv6.msftncsi.com"
"ActiveWebProbePath"="ncsi.txt"
"ActiveWebProbePathV6"="ncsi.txt"
"EnableActiveProbing"=dword:00000001
"PassivePollPeriod"=dword:0000000f
"StaleThreshold"=dword:0000001e
"WebTimeout"=dword:00000023
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NlaSvc\Parameters\Internet\ManualProxies]
复制上方代码至记事本，保存或重命名为.bat文件，双击打开，重启即可解决。
链接：https://pan.baidu.com/s/11C7Orpr-1-MUNt3M2MzuTQ 提取码：8888
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e29145cae19c1b34be5fcc6d208edbb9/" rel="bookmark">
			JDK1.8新特性 Optional判空详解，简化判空操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 从 Java 8 引入的一个很有趣的特性是 Optional 类。Optional 类主要解决的问题是臭名昭著的空指针异常（NullPointerException） —— 每个 Java 程序员都非常了解的异常。
本质上，这是一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空。
Optional 是 Java 实现函数式编程的强劲一步，并且帮助在范式中实现。但是 Optional 的意义显然不止于此。
我们从一个简单的用例开始。在 Java 8 之前，任何访问对象方法或属性的调用都可能导致 NullPointerException：
String isocode = user.getAddress().getCountry().getIsocode().toUpperCase(); 在这个小示例中，如果我们需要确保不触发异常，就得在访问每一个值之前对其进行明确地检查：
if (user != null) { Address address = user.getAddress(); if (address != null) { Country country = address.getCountry(); if (country != null) { String isocode = country.getIsocode(); if (isocode != null) { isocode = isocode.toUpperCase(); } } } } 这很容易就变得冗长，难以维护。为了简化这个过程，我们来看看用 Optional 类是怎么做的。从创建和验证实例，到使用其不同的方法，并与其它返回相同类型的方法相结合，下面是见证 Optional 奇迹的时刻。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e29145cae19c1b34be5fcc6d208edbb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446c1341a900f82cc5396cd25a00a005/" rel="bookmark">
			CVPR 2022 | 清华&amp;字节提出FGD：针对目标检测的重点与全局知识蒸馏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 点击下方卡片，关注“CVer”公众号
AI/CV重磅干货，第一时间送达
作者：美索不达米亚平原 | 已授权转载（源：知乎）编辑：CVer
https://zhuanlan.zhihu.com/p/477707304
本文介绍我们CVPR2022关于目标检测的知识蒸馏工作: Focal and Global Knowledge Distillation for Detectors，只需要30行代码就可以在anchor-base, anchor-free的单阶段、两阶段各种检测器上稳定涨点，现在代码已经开源，欢迎大家试用～
Focal and Global Knowledge Distillation for Detectors
文章链接：arxiv.org/abs/2111.11837
代码链接：github.com/yzd-v/FGD
一、针对问题 1. 目标检测中前背景不平衡问题 前背景的不平衡对于目标检测而言是一个重要的问题，这个问题同样影响着知识蒸馏。
知识蒸馏旨在使学生学习教师的知识，以获得相似的输出从而提升性能。为了探索学生与教师在特征层面的差异，我们首先对二者的特征图进行了可视化。可以看到在空间与通道注意力上，教师与学生均存在较大的差异。其中在空间注意力上，二者在前景中的差异较大，在背景中的差异较小，这会给蒸馏中的学生带来不同的学习难度。
为了进一步探索前背景对于知识蒸馏的影响，我们分离出前背景进行了蒸馏实验，全图一起蒸馏会导致蒸馏性能的下降，将前景与背景分开学生能够获得更好的表现。
针对学生与教师注意力的差异，前景与背景的差异，我们提出了重点蒸馏Focal Distillation：分离前背景，并利用教师的空间与通道注意力作为权重，指导学生进行知识蒸馏，计算重点蒸馏损失。
2.全局信息的丢失 如前所述，Focal Distillation将前景与背景分开进行蒸馏，割断了前背景的联系，缺乏了特征的全局信息的蒸馏。为此，我们提出了全局蒸馏Global Distillation：利用GcBlock分别提取学生与教师的全局信息，并进行全局蒸馏损失的计算。
二、整体框架 FGD仅需要获取学生与教师的特征图，便可完成重点蒸馏损失与全局蒸馏损失的计算，可以很方便的应用到各种类型的检测器上。
三、实验结果 我们对anchor-based与anchor-free的单阶段与二阶段检测器进行了实验，在COCO2017上学生检测器均获得了大幅的AP和AR提升。
我们采用了具有更强的检测器对学生进行蒸馏，发现当使用更强的模型作为教师进行蒸馏时，FGD为模型能带来更大的性能的提升。例如RetinaNet-R50在ResNet-101和ResNeXt-101的老师蒸馏下，分别可达到39.7和40.7的mAP。
对于使用FGD蒸馏完成后的学生模型，我们再次进行了注意力的可视化。可以看到，经过FGD训练后的学生，空间注意力和通道注意力的分布与教师都非常相似，这表明学生通过蒸馏学到了教师的知识并获得了更好的特征，由此实现了性能的提升。
四、更多蒸馏设置 我们已将代码开源：github.com/yzd-v/FGD 代码基于MMDetection实现，易于复现，且已添加更多的教师与学生蒸馏设置，相关结果也在代码中给出，欢迎大家使用。
ICCV和CVPR 2021论文和代码下载 后台回复：CVPR2021，即可下载CVPR 2021论文和代码开源的论文合集 后台回复：ICCV2021，即可下载ICCV 2021论文和代码开源的论文合集 后台回复：Transformer综述，即可下载最新的3篇Transformer综述PDF CVer-目标检测交流群成立 扫码添加CVer助手，可申请加入CVer-目标检测 微信交流群，方向已涵盖：目标检测、图像分割、目标跟踪、人脸检测&amp;识别、OCR、姿态估计、超分辨率、SLAM、医疗影像、Re-ID、GAN、NAS、深度估计、自动驾驶、强化学习、车道线检测、模型剪枝&amp;压缩、去噪、去雾、去雨、风格迁移、遥感图像、行为识别、视频理解、图像融合、图像检索、论文投稿&amp;交流、PyTorch和TensorFlow等群。 一定要备注：研究方向+地点+学校/公司+昵称（如目标检测+上海+上交+卡卡），根据格式备注，可更快被通过且邀请进群 ▲长按加小助手微信，进交流群 CVer学术交流群（知识星球）来了！想要了解最新最快最好的CV/DL/ML论文速递、优质开源项目、学习教程和实战训练等资料，欢迎扫描下方二维码，加入CVer学术交流群，已汇集数千人！ ▲扫码进群 ▲点击上方卡片，关注CVer公众号 整理不易，请点赞和在看 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f1d8fd014cf20a27f5d54dc58563831/" rel="bookmark">
			【ROS&amp;GAZEBO】解决“is neither a launch file in package ”的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天有小伙伴问到在安装完rotors后出现如下问题：
这个问题其实是ros环境没有配置好，运行下面的命令，将catkub_ws加入ros的工作空间
mkdir -p ~/catkin_ws/src cd ~/catkin_ws/src catkin_init_workspace # initialize your catkin workspace wstool init cd ~/catkin_ws/ catkin init # If you haven't done this before. catkin build echo "source ~/catkin_ws/devel/setup.bash" &gt;&gt; ~/.bashrc source ~/.bashrc 一定要提前初始化catkin_ws和配置环境
再运行下面命令，可以找到rotors包，就说明没有问题了
rospack find rotors_gazebo 参考：https://blog.csdn.net/zhelijun/article/details/88868993
喜欢的朋友可以点个赞，关注微信公众号相互交流：Reed UAV
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f42d0c1cd67571a8afdd7028e0a3515f/" rel="bookmark">
			# 研究杂感 × VOSviewer（第三辑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VOSviewer 数据可视化 ③ —— 手动修改节点标签文字 本期主要讲的是如何手动修改节点标签，例如国家如何设置首字母大写，Ppeoples R China如何修改为China。
在进入WOS导入数据时又发现个小Tip，可以双击两下 “添加到标记结果” 选项，而后可以直接输入自己想要的条目数，非常方便
正餐开始 要想解决上述问题，首先要将VOS文件进行保存成CSV格式（1个node文件1个edge文件，均为csv格式）。
导出之后我们来进行数据的手动修正：
首先打开node文件
新建1列 label ，采用Excel函数 PROPER(txt)，将首字母大写
由于现在两个 label 之间是联动的，若删掉C列则B列也会变成乱码，这时候需再创1列 label ，将修改后的文件以纯文字版复制粘贴上去，而后删掉之前的2列。
最后手动调节USA、China等国家
另一个edge文件表示边之间的权重这些，没有什么可改的，可保持不动。但导出的时候必须2个文件都导出，不然导入的话只有点没有线。
最后一步就进行导入数据即可：
经尝试，当Excel文件打开时依然可以将数据导入，这样做的好处相当于可以 “实时” 进行数据更新
最终我们便得到了修正后的国家共现图：
一点题外话 一些不负责的期刊居然将湾湾列为了 “国家” ，在此我重申一个中国的原则，正告有些国家和期刊切勿玩火，中国才是最牛的！
在edge文件中，表内内容排布如下所示：
在这里我将涉及湾湾的线条删去，同时node里也做出相应更改，最终得到的Map如下：
这不就好看多了嘛
结束语 继续加油奥利给！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e04447096883ace8feeecc94b6a41d64/" rel="bookmark">
			python之selenium设置浏览器为手机模式（开发者模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 启动手机模式浏览器， 手机型号只能选以下范围。
from selenium.webdriver.chrome.options import Options# 手机模式 # 设置手机型号，这设置为iPhone 6 mobile_emulation = {"deviceName": "iPhone 6"} options = Options() options.add_experimental_option("mobileEmulation", mobile_emulation) # 启动配置好的浏览器 driver = webdriver.Chrome(options=options) # 输入网址 driver.get('http://m.baidu.com') time.sleep(3) driver.close() 常用手机型号列表
mobile_emulation = { "deviceName": "Apple iPhone 3GS", "deviceName": "Apple iPhone 4", "deviceName": "Apple iPhone 5", "deviceName": "Apple iPhone 6", "deviceName": "Apple iPhone 6 Plus", "deviceName": "BlackBerry Z10", "deviceName": "BlackBerry Z30", "deviceName": "Google Nexus 4", "deviceName": "Google Nexus 5"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e04447096883ace8feeecc94b6a41d64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e018e8ea735e9cea1895833a07c98119/" rel="bookmark">
			【openpyxl】操作工作表（创建、改名、移动、复制、删除）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建工作表 1.1 默认工作表 当创建好工作簿之后会自动生成一个工作表（sheet），名为"Sheet"，可以通过active来获取
wb = Workbook() ws = wb.active # 获取默认的工作表 print(ws.title) # 返回工作表名，Sheet 1.2 创建工作表 我们可以通过create_sheet方法创建工作表
from openpyxl import Workbook wb = Workbook() ws1 = wb.create_sheet("my_sheet1", 1) ws2 = wb.create_sheet("my_sheet2", 2) wb.save("./test.xlsx") # 保存到硬盘 create_sheet(title,index)，接收两个参数，表名和位置
title：表名
index：下标即位置，从0开始
2.修改工作表 2.1 工作表信息 print(ws.max_row) # 最大行数，例如14 print(ws.max_column) # 最大列数，例如20 print(ws.dimensions) # 已启用的单元格范围，例如A1:T14 print(ws.encoding) # 编码类型，例如utf-8 print(ws.sheet_view) # 对象信息 2.2 获取和修改表名、获取下标 from openpyxl import Workbook wb = Workbook() ws1 = wb.create_sheet("my_sheet1", 1) ws2 = wb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e018e8ea735e9cea1895833a07c98119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7651674a37654b154c67168ccde1e6c/" rel="bookmark">
			YOLOv4安装和训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境
Windows：10YOLOv4OpenCV：4.5.3Visual Studio 2019：16.11CUDA：11.2.0_460.89_win10cudnn：11.2-windows-x64-v8.1.1.33 硬件
NVIDIA GeForce RTX 3070 Ti OpenCV 4.5.3网址：https://sourceforge.net/projects/opencvlibrary/files/4.5.3/
OpenCV 4.5.3下载链接：https://nchc.dl.sourceforge.net/project/opencvlibrary/4.5.3/opencv-4.5.3-vc14_vc15.exe
安装完成后为OpemCV添加环境变量。
Visual Studio 2019网址：https://docs.microsoft.com/en-us/visualstudio/releases/2019/release-notes-preview
CUDA网址：
https://developer.nvidia.com/cuda-11.2.0-download-archive?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exelocal
CUDA下载链接：
https://developer.download.nvidia.cn/compute/cuda/11.2.0/local_installers/cuda_11.2.0_460.89_win10.exe
cudnn网址：https://developer.nvidia.com/rdp/cudnn-archive
cudnn下载链接：https://developer.nvidia.com/compute/machine-learning/cudnn/secure/8.1.1.33/11.2_20210301/cudnn-11.2-windows-x64-v8.1.1.33.zip
验证CUDA是否安装成功
nvcc --version C:\Users\78694&gt;nvcc --version
nvcc: NVIDIA ® Cuda compiler driver
Copyright © 2005-2020 NVIDIA Corporation
Built on Mon_Nov_30_19:15:10_Pacific_Standard_Time_2020
Cuda compilation tools, release 11.2, V11.2.67
Build cuda_11.2.r11.2/compiler.29373293_0
将cudnn解压出来，然后将cudnn中的 bin、include、lib文件夹移动到 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.2 文件夹下。
注：C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.2是我的电脑安装CUDA的路径为例。可以根据自己安装的 CUDA路径，找到 …\NVIDIA GPU Computing Toolkit\CUDA\v11.2，移动到 v11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7651674a37654b154c67168ccde1e6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4f570d3a5dcabccebf594febb9e9460/" rel="bookmark">
			Metasploit漏洞利用模块（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、信息收集 1、权限提升
2、提权辅助工具
快速查找exp提权补丁进行提权
1）在线辅助网页
在线比对补丁查找exp：https://i.hacking8.com/
2）提权辅助工具：https://github.com/GDSSecurity/Windows-Exploit-Suggester
Windows-Exploit-Suggester
提取补丁：MS15-051
二、MSF—提权 三、获取管理员密码 下载地址：https://github.com/gentilkiwi/mimikatz
Windows hash
在线解密：https://www.objectif-securite.ch/ophcrack
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33f385439ab618bf978efd87c1738d63/" rel="bookmark">
			linux实操——常用指令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 5.实用指令——详解5.1 指令运行级别5.2 切换到指定运行级别的指令5.2.1 **面试题**：如何找回root密码 5.3 帮助指令5.3.1介绍5.3.2 man 获取帮助的信息：5.3.3 help指令 5.4 文件目录类指令5.4.1 pwd 指令5.4.2 ls5.4.3 cd5.4.4 mkdir5.4.5 rmdir5.4.6 touch5.4.7 cp5.4.8 rm5.4.9 mv5.4.10 cat5.4.11 more5.4.12 less5.4.13 &gt; 指令、&gt;&gt;指令5.4.14 echo5.4.15 head5.4.16 tail5.4.17 In指令5.4.18 history 5.5 时间日期类5.5.1 date 显示当前日期5.5.2 data 设置日期5.5.3 cal 查看日历 5.6 搜索查找类5.6.1 find5.6.2 locate5.6.3 grep指令和管道符号 5.7 压缩和解压缩5.7.1 gzip/gunzip 指令5.7.2 zip/unzip5.7.3 tar 5.实用指令——详解 5.1 指令运行级别 运行级别说明：
0 ：关机
1 ： 单用户（找回丢失的密码）
2 ： 多用户状态没有网络服务
3 ： 多用户状态有网络服务
4 ：系统未使用保留给用户
5 ： 图形界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33f385439ab618bf978efd87c1738d63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea7ad9bfb23b2cf2071fd239a5b427e1/" rel="bookmark">
			dependencies和devDependencies的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 dependencies：项目依赖。在编码阶段和呈现页面阶段都需要的，也就是说，项目依赖即在开发环境中，又在生产环境中。如js框架vue、页面路由vue-router，各种ui框架antd、element-ui、vant等。devDependencies: 开发依赖。仅仅在写代码过程中需要使用，比如css预处理器、vue-cli脚手架、eslint之类。后面部分为–save -dev 的情况会使得下载的插件放在package.json文件的devDpendencies对象里面后面部分为–save的情况会使得下载的插件放在package.json文件的dependencies对象里面区别devDependencies下的依赖包，只是我们在本地或开发坏境下运行代码所依赖的，若发到线上，其实就不需要devDependencies下的所有依赖包；(比如各种loader，babel全家桶及各种webpack的插件等)只用于开发环境，不用于生产环境，因此不需要打包；dependencies是我们线上(生产坏境)下所要依赖的包，比如vue，我们线上时必须要使用的，所以要放在dependencies下；dependencies依赖的包不仅开发环境能使用，生产环境也能使用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9324ca47c275bdb1a0557b7a8c25a48a/" rel="bookmark">
			浅谈Docker四种网络模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、docker 容器网桥实现原理 Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。
Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。
如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。
二、四类网络模式 host：容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。
Container：创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。
None：该模式关闭了容器的网络功能。
Bridge：此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。
[root@moapp-0003 pg_dockerfile]# docker network ls NETWORK ID NAME DRIVER SCOPE baa06c63cee9 bridge bridge local 6818dc14af4b docker_gwbridge bridge local fbaff9613bbc host host local d6tgeu5nrfrv ingress overlay swarm a7faafcce0dc none null local mdtdf6d41zay test_default overlay swarm 1、host模式 —— 使用--net=host指定
众所周知，Docker使用了Linux的Namespaces技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、Iptable规则等都与其他的Network Namespace隔离。一个Docker容器一般会分配一个独立的Network Namespace。
但是，如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。
容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。
使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。
例如，我们在10.10.101.105/24的机器上用host模式启动一个含有web应用的Docker容器，监听tcp80端口。当我们在容器中执行任何类似ifconfig命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用10.10.101.105:80即可，不用任何NAT转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。
2、container模式 —— 使用--net=container:NAME_or_ID指定
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9324ca47c275bdb1a0557b7a8c25a48a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ce491d356b4c427581fc03d5567dcaa/" rel="bookmark">
			基于主机Overlay和自研虚拟化网关的VPC在360的落地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01
背景
1.1 概述
随着公司业务的不断发展，用户对网络也提出了更多的需求。一方面360公司25G机房逐步上线，交换机架构升级，导致原有的虚拟化网络方案无法支持虚机的跨交换机迁移，而且部分特殊业务线对网络有着隔离的需求。另一方面，之前的网络Overlay架构与交换机耦合太严重，在稳定性、运维和问题排查方面都不太理想。
综合上述情况，虚拟化团队选择了主机Overlay的方案，与交换机解耦，支持专有网络（Virtual Private Cloud，简称VPC），保证不同用户间隔离，保障云上资源的安全性，并上线至公司内部私有云平台HULK，丰富了HULK的服务类别。
1.2 架构思路
在私有云内做VPC的需求，最初团队内部是存在一定争议的。考虑到私有云的每个IDC本身就是一个独立的VPC，IDC内VLAN隔离，三层互通，再去做VPC是否有必要？
业务发展过程中，集团的部分事业部逐渐子公司化，其安全要求是与集团独立的。当前公司都是采用IDC VLAN隔离网段 + 核心ACL控制等方式，来限制关联公司与集团的互访。每当有隔离需求，都需要网络运维部门单独去分配段或设置三层隔离等，不够灵活，IP段无法定制，限制比较死。所以需要集团内部私有云平台去支持公有云的VPC，通过逻辑划分的VPC，业务可以实现自定义交换机、IP段、路由表，以及自定义VPC之间的互联互通等。所有的VPC的概念都可以和IDC的物理机逻辑相映射，例如子网对应接入交换机，路由表对应三层核心交换机和路由器，VPC内的VM对应IDC的物理机等。软件定义网络，本质上依然是物理网络的逻辑映射。
在开始摸索VPC之前，公司集团都是网络Overlay，主机侧走VLAN模式，接入交换机做VLAN封装，实现大二层网络，保证VM跨交换机迁移等。但是存在网络侧工作量很大的痛点，每次上线部署都需要和网络运维部门联调VLAN配置。并且交换机侧做Overlay，对交换机侵入性比较大，需要网络运维部门参与配置，对交换机的选型和品牌都有要求，优势是性能好，都是硬件交换机做VXLAN解封装。
在综合考虑之后，我们实施了主机Overlay的方案。当前业界主流云厂商基本都是将VXLAN解封装放到了主机侧，优势就是和网络设备解绑，除了主机的包都是IP包，交换机做好纯转发即可。OpenStack社区Neutron也支持主机Overlay，基于OVS做解封装，再加上DVR分布式路由方案消灭集中式Neutron网络节点Vrouter性能瓶颈，主机路由Vrouter来处理南北东西流量。而我们的方案是DVR+自研虚拟化网关，DVR处理东西流量，南北流量都统一走基于DPVS开发的虚拟化网关，既能区分VPC的负载均衡NAT网，也能达到最高单机性能和降低计算节点主机路由负载等目标。
自研虚拟化网关的技术背景是，虚拟化团队同时维护和开发着公司的基于DPVS的负载均衡，专有网络的NAT网关和FIP浮动IP本质上就是VPC内的SNAT和DNAT，所以需要在DPVS上增加VPC的区分和标识。这是自研的关键点。具体细节信息可参考下文中的SNAT虚拟化网关和FIP虚拟化网关架构章节。
这一套基于自研虚拟化网关的主机Overlay方案已经在线上25G机房运行接近一年之久，运行稳定，架构高可用性可体现在：在网关与交换机的对接中，网关设备采用了双活冗余方案，每台交换机下一组6台25G网卡的网关集群，整体VPC流量峰值在200Gbps左右。后续考虑100G网卡来做网关，但有利有弊，利是网关机器数少了，弊是故障域大了。计算节点侧都采用了双发ARP的bond方案，上层对接去堆叠的双线双交换机，综上在网关侧和主机侧都做了高可用保证。
该方案的收益：
对业务方来说，业务可从公司私有云平台上进行自定义VPC、创建二层隔离网络、自定义IP段等操作；
对网络运维部门来说，网络交换机专注于纯转发，降低了交换机配置复杂度；
对公司的信息安全部门来说，以前在核心交换机上做ACL策略可以在网关或者虚拟化网络侧做限制，更加灵活；
对研发团队来说，由于不需要重复与网络运维部门做VLAN联调等步骤，上线部署更快，整体部署效率由天提升至小时级别。排查问题也集中在主机侧的虚拟网络，交换机测只需保证IP可达即可；
此方案存在的缺点：主机侧基于内核OVS做解封装，在性能方面会比硬件交换机差一些。按照当前的压测损耗统计，性能损耗基本维持在20%到30%，延迟上也同样比VLAN网络和sriov直通VM的模式高出一倍。
那么接下来工作基本集中在如何降低损耗，包括通过OVS-DPDK加速OVS转发，通过智能网卡做流表卸载加速等方式。除了速度损耗问题，网络IO负载本身也会占用不少CPU，以OVS-DPDK进程为例，它一般情况下会绑定8个core，造成不必要的资源浪费，所以主流的DPU方案都会集中在网络和存储IO的卸载和加速。
360也在与部分DPU厂商联测，尝试将网络IO和存储IO卸载到DPU上。DPU本质上是一个加了ARM CPU的智能网卡，比如主流的intel的IPU，麦乐思的bf2等，可理解为BF2=ARM+CX6。该DPU上一般会装一个Ubuntu系统，把OVS-DPDK和存储SPDK进程部署到DPU上，然后DPU上生成一个VF，主机OS通过VF走网卡将流量送到DPU上的OVS-DPDK，在这里做VXLAN的封装解封装，达到完全IO卸载，在CX6中部分流表还能卸载到智能网卡规则中。如果流表匹配，直接加速转发，如果不匹配，上送到OVS-DPDK中继续寻找流表，匹配以后再下放到网卡流表中。如此循环。
在接下来的工作中，我们还会输出一些关于虚拟化网络的文章，希望能给大家一些启发。
02
VPC架构介绍
2.1 VPC层级架构
图2.1 VPC整体架构图
由上图2.1可知，VPC整体架构从层级角度上可以分为计算节点的虚拟化网络和云网关两个部分。
计算节点的虚拟化网络负责处理并转发虚拟机即用户的流量。云网关根据功能可以分为SNAT网关、EIP网关、LB网关、CCN网关等。其中SNAT网关和EIP网关负责用户南北向流量的转发，LB网关负责负载业务，CCN网关负责VPC之间的互通。目前这些网关均已开发完成，VPC一期上线了SNAT网关和EIP网关，其余网关功能将在VPC二期上线。SNAT网关适用于用户主动访问外网的场景，使用统一的IP池，而不对外暴露虚机IP。EIP网关即弹性公网IP网关，允许外网主动访问绑定EIP的虚机。SNAT与EIP网关的转发逻辑类似，下面介绍的是实现架构和细节，如果不特殊说明，默认就以EIP网关为例。
2.2 VPC流量架构
图2.2 VPC流量架构图
由上图2.2可知，VPC从流量角度上可以分为东西向流量、南北向流量以及一些控制类流量，如dhcp和metadata等数据流量。
东西向流量采用DVR模式，只在计算节点之间流通，这与传统的Openstack网络架构保持一致。南北向流量采用与云网关对接的方式，每台计算节点与云网关建立VXLAN隧道，将用户的南北向流量发给网关，由网关来处理转发。云网关南向通告VIP给计算节点，该VIP用于与计算节点建立VXLAN隧道，即VIP就是云网关的vtep IP，这就实现了三层网络，不依赖中间的交换机或者路由器。云网关北向通告EIP网段，用于外网访问EIP的引流。
2.3 VPC实现架构
图2.3 VPC控制与转发面架构
由上图2.3可知，VPC架构从实现角度上可以分为控制面和转发面两个部分。控制面包含FIPCTL组件和Neutron组件，转发面包含DPDK和OVS。
2.3.1 控制面
虚拟化网络控制面由Neutron Server和Ovs Agent实现。用户在HULK页面绑定EIP后，请求到达Neutron Server，合法性检查通过后将虚机与EIP的关联关系记录数据库，并且通知云网关Fipctl Server和计算节点的Ovs Agent该对应关系的变化。
网关控制面由Fipctl Server和Fipctl Agent实现。Fipctl Server负责提供对外API接口，接收来自Neutron Server的虚机和EIP绑定/解绑关系，并将该信息存储至ETCD集群；Fipctl Agent部署在每台EIP网关上，实时监听ETCD变化，拉取对应的映射关系，并及时下发至转发面。
2.3.2 转发面
虚拟化网络转发面由OVS实现。虚机创建后，计算节点会下发相关OVS流表，根据流表规则匹配转发。东西向流量采用DVR模式，在计算节点内部或计算节点间转发，不经过网络节点，不存在发卡流量，这和原生的Neutron逻辑一致。南北向流量会通过VXLAN隧道引到云网关进行处理。
网关转发面是基于DPDK实现的高性能网关，CPU和网关服务的worker进程一一绑定，绕过内核协议栈，提升了收发包性能。它通过查找EIP和虚机映射关系进行数据包转发，一条映射关系包含5个参数：EIP、虚机IP(VM_IP)、虚机所在宿主机IP(HOST_IP)、VXLAN网络标识(VNI)和计算节点的DVR_MAC。映射关系会同步至每个核，保证数据包无论在哪个网卡队列都可以被成功转发。映射关系需要保证唯一，即同一个EIP只允许绑定一台虚机，虚机删除会同时将映射关系删除，虚机迁移也会同步更新映射关系，保证数据包转发至正确的宿主机。
03
流量路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ce491d356b4c427581fc03d5567dcaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc9d4231ff61808383f798df480825a/" rel="bookmark">
			rootkit检测、病毒查杀、webshell检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、chkrootkit
1、下载rootkit
wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz
2、安装
tar xf chkrootkit.tar.gz
3、使用
cd chkrootkit-0.52/
./chkrootkit |grep INFECTED 没有出现INFECTED说明系统没有问题
二、rkhunter
1、下载rkhunter
wget http://jaist.dl.sourceforge.net/project/rkhunter/rkhunter/1.4.2/rkhunter-1.4.2.tar.gz 最新版本去官网下载
2、安装
./installer.sh --install
3、使用
rkhunter --update 扫描之前最好更新病毒库
rkhunter -c --sh
yum install rkhunter -y
安装后就可以使用rkhunter命令了，下面列出有用的参数：
–checkall (-c) #全系统检测，rkhunter的所有检测项目;
–createlogfile #建立登录档，一般预设放在/var/log/rkhunter.log;
–skip-keypress #忽略按键后继续的举动(程序会持续自动执行);
–versioncheck #检测试否有新的版本在服务器上;
接下来运行rkhunter --checkall，连续敲击回车，数分钟后得到报表，如图：
rkhunter --checkall
我们从分析报告可以看出，Rkhunter怀疑被篡改的文件有9个，怀疑rootkits有3个，具体再去/var/log/rkhunter/rkhunter.log中查看。
如果您不想要每个部分都以 Enter 来继续，想要让程序自动持续执行，可以使用：
rkhunter --check --sk
Rkhunter拥有并维护着一个包含rootkit特征的数据库，然后它根据此数据库来检测系统中的rootkits，所以可以对此数据库进行升级，rkhunter –update
rkhunter --update
那么简单来讲，RKhunter就像我们的杀毒软件，有着自己的病毒数据库，对每一个重点命令进行比对，当发现了可疑代码则会提示用户。
三、Clamav 病毒查杀
1、zlib依赖包安装
wget http://nchc.dl.sourceforge.net/project/libpng/zlib/1.2.7/zlib-1.2.7.tar.gz
tar zxvf zlib-1.2.7.tar.gz
cd zlib-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bc9d4231ff61808383f798df480825a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc683b726c504e45d98e78cbee4557b2/" rel="bookmark">
			Linux如何查看一个文件最近被修改和访问的时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有些文件可以被动过，所以我们需要对访问和修改时间进行检查。那就可以使用stat命令检查。
查看文件最近的修改时间： # stat ES_config.py File: `ES_config.py' Size: 7359 Blocks: 16 IO Block: 4096 regular file Device: fd03h/64771d Inode: 131133 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Access: 2021-08-31 20:34:30.092089658 +0800 文件内容最近被访问的时间 Modify: 2021-06-23 20:07:56.928627737 +0800 文件内容最近被修改时间 Change: 2021-06-23 20:07:56.928627737 +0800 文件的状态权限被修改时间 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69af5f99f933de8cda0dc2e272349787/" rel="bookmark">
			视图中with check option的作用是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		create view IS_student as select sno,sname,sage,sdept from student where sdept='IS' with check option; 使用以下操作就不行
insert into IS_student values('95100','李娜',12,'MA'); 因为插入记录的院系是'MA'，不是'IS'。
with check option保证了通过视图进行的修改，必须也能通过该视图看到修改后的结果。
修改的结目标和结果都只在视图上呈现，这样不会影响其他视图。
所以你插入，那么插入这条记录在刷新视图后必须可以看到；
如果修改，修改完的结果也必须能通过该视图看到；
如果删除，当然只能删除视图里有显示的记录。
而你插入的记录不符合sdept='IS’条件，所以插入不进去。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9c47c7d3d51434fdd0c35e3ead3ccad/" rel="bookmark">
			Vue 学习总结笔记 (六)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. render 函数1.1 为什么正常情况下的写法不能生效？1.2 使用完整版的vue.js来解决没有模板解析器的问题1.3 使用render函数来解决没有模板解析器的问题 2. 修改Vue Cli脚手架的默认配置3. ref属性(被用来给元素或子组件注册引用信息(id的替代者))4. props 配置项(父传子)4.1 props 第一种方式：(只接受)4.2 props 第二种方式：(限制类型)4.3 props 第三种方式：(限制类型，限制必要性，指定默认值) 5.mixin混入(混合) mixins配置项5.1 组件中的mixins配置项(局部混入)5.2 在main.js全局配置(全局混入) 6. Vue的 插件6.1 引入插件 和 应用插件6.2 插件的作用(使用案例) 7. scoped样式8. style标签的lang属性9. 组件化编码流程(通用)9.1 组件编码的通用流程9.2 正确的查分一个html和css的结构样式分给组件9.3 对于动态数据(变化的数据)的操作9.4 NanoID的用法9.5 子传父的传值9.6 兄弟组件的传值9.7 对于props配置项修改的注意事项9.8 confirm() 方法的使用9.9 谷歌浏览器的隐藏9.10 Array.prototype.reduce()的使用 10. 初级案例演示 1. render 函数 1.1 为什么正常情况下的写法不能生效？ 首先，先说正常情况下，应该是这样操作：
//创建Vue的实例对象 new Vue({ //指定容器app el:"#app", template:`&lt;App&gt;&lt;/App&gt;`, components:{ App } }) 但是在Vue脚手架中，它会报错：
换句话说，导入的Vue文件有问题！其实Vue的js文件有很多版本，只不过我们导入的Vuejs文件是一个精简版(缺少部分功能的Vue)。
而上面的vue.runtime.esm.js文件，就残缺了模板解析器，没有了模板解析器就没法解析template中的内容了。
1.2 使用完整版的vue.js来解决没有模板解析器的问题 完整版的vue.js，在第三方库的dist下面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9c47c7d3d51434fdd0c35e3ead3ccad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa3e302770cb5c5951d045d03499afb3/" rel="bookmark">
			安卓服务Service
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Service概念及用途
2、Service生命周期
3、Service与Activity通信
4、IntentService
5、跨进程访问AIDL
6、关于服务的应用
一、Service概念及用途
1、Service（服务）是一个没有用户界面的在后台运行执行耗时操作的应用组件。
2、其他应用组件能够启动Service，并且当用户切换到另外的应用场景，Service将持续在后台运行。
3、一个组件能够绑定到一个service来交互，例如，一个service可能会处理网络操作，播放音乐，操作文件I/O或者与内容提供者（content provider）交互，所有这些活动都是在后台进行。
4、Service有两种状态，“启动的”和“绑定”
Service的种类（了解）
按运行地点分类：
其实remote服务还是很少见的，并且一般都是系统服务。
按运行类型分类：
后台服务我们可以自己创建 ONGOING 的 Notification 这样就成为前台服务吗？答案是否定的，前台服务是在做了上述工作之后需要调用 startForeground （ android 2.0 及其以后版本 ）或 setForeground （android 2.0 以前的版本）使服务成为 前台服务。这样做的好处在于，当服务被外部强制终止掉的时候，ONGOING 的 Notification 任然会移除掉。
按使用方式分类：
以上面三种方式启动的服务其生命周期也有区别，将在随后给出。
类别
区别
优点
缺点 应用
本地服务（Local）
该服务依附在主进程上
服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应bindService会方便很多。
主进程被Kill后，服务便会终止。
非常常见的应用如：HTC的音乐播放服务，天天动听音乐播放服务。
远程服务（Remote）
该服务是独立的进程，
服务为独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。
该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。
一些提供系统服务的Service，这种Service是常驻的。
类别
区别
应用
前台服务
会在通知一栏显示 ONGOING 的 Notification，
当服务被终止的时候，通知一栏的 Notification 也会消失，这样对于用户有一定的通知作用。常见的如音乐播放服务。
后台服务
默认的服务即为后台服务，即不会在通知一栏显示 ONGOING 的 Notification。
当服务被终止的时候，用户是看不到效果的。某些不需要运行或终止提示的服务，如天气更新，日期同步，邮件同步等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa3e302770cb5c5951d045d03499afb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c61e75ee32619ac51faa643c0919230/" rel="bookmark">
			Android AsyncTask已被弃用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你对android开发感兴趣，那么我很确定你对android AsyncTask很了解。AsyncTask类帮助我们在后台线程中执行一些代码。
在AsyncTask的帮助下，我们可以在后台线程上执行某些操作，并在UI线程中返回结果。但Android AsyncTask在API级别30中已被弃用。那么，现在的替代方案是什么？
为什么Android AsyncTask不受欢迎？ 以下是官方反对它的原因。
AsyncTask旨在实现UI线程的正确和简单使用。然而，最常见的用例是集成到UI中，这会导致上下文泄漏、错过回调或配置更改时崩溃。它在不同版本的平台上也有不一致的行为，从doInBackground中接受异常，并且与直接使用执行器相比没有提供太多的实用性。
异步任务的替代方案 官方推荐的替代方案是Kotlin协程，您必须在项目中使用它来编写异步代码。
但如果你是一名初学者，并且刚刚开始学习android开发，那么不建议直接跳入Kotlin协同程序。所以在这篇文章中，我将向你展示一些不需要依赖的东西。
使用Executors 我们有java.util.concurrent.Executors。如果您不希望使用Kotlin协程，我们可以使用它来代替AsyncTask。但是建议您使用Kotlin协同程序在项目中编写异步代码
val executor = Executors.newSingleThreadExecutor() val handler = Handler(Looper.getMainLooper()) executor.execute { /* * Your task will be executed here * you can execute anything here that * you cannot execute in UI thread * for example a network operation * This is a background thread and you cannot * access view elements here * * its like doInBackground() * */ handler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c61e75ee32619ac51faa643c0919230/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/256/">«</a>
	<span class="pagination__item pagination__item--current">257/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/258/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>