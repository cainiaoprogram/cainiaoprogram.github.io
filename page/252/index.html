<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a2abcc874bc9e5251d6b7b33041c815/" rel="bookmark">
			SimCSE初步使用且和Bert的简单对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SimCSE初步使用且和Bert的简单对比 在很多 NLP 任务中都会用到句子向量，例如文本检索、文本粗排、语义匹配等任务。现在有不少基于 Bert 的方式获取句子向量，例如 Bert-flow 和 Bert-whitening 等，这些方法会对预训练 Bert 的输出进行变换从而得到更好的句子向量。本文介绍 SimCSE，SimCSE 通过对比学习的方法训练模型，取得 SOTA 的效果。
模型下载 huggingface这个网站真的是太棒了。提供了封装好后的SimCSE。其实SimCSE也是在Bert基础上进行了修改。所以使用方式和Bert没有什么区别。
可以去这个网址下载https://huggingface.co/princeton-nlp/sup-simcse-bert-base-uncased模型文件。我是预先下载到本地了。
简单使用 import torch from scipy.spatial.distance import cosine from transformers import AutoModel, AutoTokenizer model_path_simcse = "../pretrained_models/sup-simcse-bert-base-uncased" model_path_bert = "../pretrained_models/bert-base-uncased" # 从本地加载simcse模型 tokenizer_simcse = AutoTokenizer.from_pretrained(model_path_simcse) model_simcse = AutoModel.from_pretrained(model_path_simcse) # 从本地加载bert模型 tokenizer_bert = AutoTokenizer.from_pretrained(model_path_bert) model_bert = AutoModel.from_pretrained(model_path_bert) # Tokenize input texts texts = [ "Deep Learning", "Hello", "World" ] inputs_simcse = tokenizer_simcse(texts, padding=True, truncation=True, return_tensors="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a2abcc874bc9e5251d6b7b33041c815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9307b5e92d5c1bcc26efd9364a326661/" rel="bookmark">
			Python之Socket自动重连
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 现有一个tcp客户端程序，需定期从服务器取数据，但由于种种原因（网络不稳定等）需要自动重连。
服务端代码 #! /usr/bin/env python #-*- coding:utf-8 -*- import socket import threading class ThreadedServer(object): def __init__(self, host, port): self.host = host self.port = port self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.sock.bind((self.host, self.port)) def listen(self): self.sock.listen(5) while True: client, address = self.sock.accept() client.settimeout(60) threading.Thread(target = self.listenToClient,args = (client,address)).start() def listenToClient(self, client, address): size = 1024 while True: try: data = client.recv(size) if data: response = data client.send(response) print("secndLen: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9307b5e92d5c1bcc26efd9364a326661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/251e421257fd12e0adcb22ed13f6ef77/" rel="bookmark">
			MyBatis的原理、配置、使用、高级映射和代理机制和缓存机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、MyBatis介绍二、MyBatis原理三、MyBatis的配置1、配置全局配置文件2、XML配置1、Properties2、setting3、typeAliases（类型别名）4、Mappers 3、标签详解1、select标签2、insert标签3、update标签4、delete标签 四、MyBatis的使用1、MyBatis中接口绑定的两种实现方式2、XML方式（使用步骤）1、创建Mapper.java接口文件2、创建Mapper.xml配置文件3、配置映射路径4、XML方式的开发规范5、标签1、select标签2、resultMap和resultType的区别3、insert标签 3、注解方式（实现步骤）1、给定POJO类；2、给定mapper.java接口3、配置文件中指定文件映射位置4、@Select注解5、@Insert注解6、@Update注解7、@Delete注解 4、缓存4、自定义缓存5、动态SQL1、if标签2、where标签3、 trim标签4、foreach标签 5、模糊匹配1、直接在参数上进行参数模糊匹配2、mysql中提供的方法concat(,)3、bind表达式 五、MyBatis的高级映射1、订单数据模型1、数据表2、表与表之间的业务关系3、一对一映射 六、MyBatis的深入1、MyBatis代理详解2、MyBatis的缓存机制1、缓存1、一级缓存2、一级缓存测试3、二级缓存4、二级缓存原理5、二级缓存使用测试 一、MyBatis介绍 官网中给出的解释是：
MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 二、MyBatis原理 如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中： &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; 从XML文件中构建SqlSessionFactory。每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。 String resource = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/251e421257fd12e0adcb22ed13f6ef77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd7f1184423a8b9c80c706134415708c/" rel="bookmark">
			小猫爪：S32K3学习笔记12-S32K3之STCU2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小猫爪：S32K3学习笔记12-S32K3之STCU2 1 前言2 STCU功能简介2 BIST MCAL配置2 BIST代码示例END 1 前言 这一章来说说S32K3的STCU2（Self-Test Control Unit ），从名字就可以看出来，它是一个自测试控制模块，即BIST（Build-In Self-Test）控制器。BIST简单的来说就是一种芯片自我测试方式，谈到自我测试，无外乎就类似于那种给个输入然后对比输出的测试方法，当然我说的比较片面，感兴趣的小伙伴可以自行查阅资料进修一番。
BIST又分为LBIST（Logic BIST）和MBIST（Memory BIST）这两种。而在K3中，这两种BIST都是有的。而BIST又有两种模式，分别是off-line和on-line，其中off-line就是不需要软件的干预，硬件自己完成BIST测试，而on-line则需要软件来控制，S32K3只支持on-line模式。
2 STCU功能简介 下图为STCU的功能框图：
三个FSM：STCU有三个FSM，其中Master FSM为STCU的核心单元，主要负责BIST测试控制；Loader Shifter FSM主要负责控制参数和测试结果反馈到寄存器之间的交互；WDG FSM为STCU的超时监测单元，如果BIST运行超时，这个模块会中断BIST并发出超时信号，并且。LBIST和MBIST interface：在整个BIST自测试中，STCU只是控制单元，所以这两个interface是控制单元与执行单元之间的接口。Interrupt信号：STCU检测到错误时可以产生一个中断，STCU_LBIST_MBIST_IRQn =191（但是这个中断在RTD中并没有被实现）。FCCU信号：STCU可以将recoverable错误输送给FCCU，而这个是否为recoverable是可配置的。MBIST将K3分成了12个区域，而LBIST则共1个区域，总共有13个区域（详情请详见RM手册STCU章节的51.1.3 STCU2 LBIST/MBIST mapping），用户是可以将这些区域的配置成是否为recoverable和unrecoverable的BIST，如果是recoverable的区域在自测试的时候发生了错误，那么这个错误就会报告到FCCU模块，如果unrecoverable的错误发生了错误，则直接发送信号给MC_RGM触发破坏性复位。另外STCU也可以控制EOUT信号，发生错误时可以使用EOUT将错误信号传送给外部SBC。 2 BIST MCAL配置 在MCAL中，STCU的功能体现在Bist模块中，配置也是非常的简单，记得首先需要在Mcu模块中打开STCU的时钟，这里就不贴图了。首先首页中：
然后可以在Unrecovery中添加不可恢复发送触发破坏性复位信号到MC_RGM中的BIST区域：
2 BIST代码示例 下面直接进入主题，在代码中怎么实现BIST的功能？代码实现也非常简单，首先BIST的代码官方的例子已经写好了，直接拿过来如下：
#ifdef DEMO_ENABLE_BIST bistStatus = Bist_GetExecStatus(BIST_SAFETYBOOT_CFG); if( bistStatus != BIST_OK ) { if(bistStatus == BIST_ERROR) { /* Reads STCU ERR_STAT register to identify what HW error occured */ stcuStatus = Bist_GetRawErrorStatus(); (void) stcuStatus; } else if(bistStatus == BIST_FAILED) { /* Analyze which reset domain is failing */ retStatus = Bist_GetFailRDs ( &amp;Bist_LBistRDList, &amp;Bist_MBistRDList ); (void) retStatus; } else if(bistStatus == BIST_BUSY) { while( 1U ); /* Handle BIST HW busy state */ } else if(bistStatus == BIST_NORUN) { /* Bist execution was not successfully performed due to HW hazard state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd7f1184423a8b9c80c706134415708c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a1dc23d37ee236fa4b8413e6261dcfc/" rel="bookmark">
			MMCV-Registry类代码详解(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.功能简介
2.初始化函数
参数说明：
构造函数优先级：
2.1self.infer_scope()方法
2.2_add_children()方法
源码在工程中的路径为mmcv/utils/registry.py，可对照源码阅读本文。
1.功能简介 简单地说，Registry类实现了字符串到类的一种映射。目的是仅使用字符串（例如某个模型的名字）来方便快捷地创建一个类实例。源码注释中给了这么一个例子：
""" Example: &gt;&gt;&gt; MODELS = Registry('models') &gt;&gt;&gt; @MODELS.register_module() &gt;&gt;&gt; class ResNet: &gt;&gt;&gt; pass &gt;&gt;&gt; resnet = MODELS.build(dict(type='ResNet')) """ 符号@表示装饰器，涉及Python的一些语法，可自行学习。在@MODELS.register_module()后定义模型，可理解为模型已经被MODELS.register_module()方法修饰，修饰过的模型可通过 MODELS.build()方法使用模型名称直接创建实例，具体使用实例可参考MMdetection自定义backbone。
2.初始化函数 """ Args: name (str): Registry name. build_func(func, optional): Build function to construct instance from Registry, func:`build_from_cfg` is used if neither ``parent`` or ``build_func`` is specified. If ``parent`` is specified and ``build_func`` is not given, ``build_func`` will be inherited from ``parent``.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a1dc23d37ee236fa4b8413e6261dcfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c655271449f6cf061c30ca039f83fd5/" rel="bookmark">
			tensorflow2.4复现parnet网络模型实现猫狗分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. Introduction（介绍）2. Related Work（相关工作）2.1 Analyzing importance of depth（分析网络深度的重要性）2.2 Scaling DNNs（深度神经网络的尺寸）2.3 Shallow networks（浅层网络）2.4 Multi-stream networks（多尺寸流的网络） 3. METHOD（网络设计方法）3.1 PARNET BLOCK3.2 DOWNSAMPLING AND FUSION BLOCK3.3 NETWORK ARCHITECTURE 4. RESULTS（结果展示）代码演示1. 导入库2. 设置超参数3. 数据预处理4. 构建ParNet5. 设置回调函数6. 训练模型7. 预测图片 前言 深度是深度神经网络的标志，但深度越大意味着顺序计算越多延迟也越大。这就引出了一个问题——是否有可能构建高性能的“非深度”神经网络？作者实现了一个12层的网络结构实现了top-1 accuracy over 80%on ImageNet的效果。分析网络设计的伸缩规则，并展示如何在不改变网络深度的情况下提高性能。
下面我们就看看作者在论文中是怎么说的吧！
论文地址：https://arxiv.org/abs/2110.07641
1. Introduction（介绍） 人们普遍认为，大深度是高性能网络的重要组成部分，因为深度增加了网络的表征能力，并有助于学习越来越抽象的特征。但是大深度总是必要的吗?这个问题值得一问，因为大深度并非没有缺点。更深层次的网络会导致更多的顺序处理和更高的延迟;它很难并行化，也不太适合需要快速响应的应用程序。
为此，作者进行了研究提出了ParNet。ParNet可以被有效的并行化，并且在速度和准确性上都优于Resnet。注意，尽管处理单元之间的通信带来了额外的延迟，但还是实现了这一点。如果可以进一步减少通信延迟，类似parnet的体系结构可以用于创建非常快速的识别系统。
不仅如此，ParNet可以通过增加宽度、分辨率和分支数量来有效缩放，同时保持深度不变。作者观察到ParNet的性能并没有饱和，而是随着计算吞吐量的增加而增加。这表明，通过进一步增加计算，可以实现更高的性能，同时保持较小的深度(~ 10)和低延迟。
下图是论文中ParNet与其它网络的比较。
论文作者的贡献：
首次证明，深度仅为12的神经网络可以在非常有竞争力的基准测试中取得高性能（ImageNet上80.7%）展示了如何利用ParNet中的并行结构进行快速、低延迟的推断研究了ParNet的缩放规则，并证明了恒定的低深度下的有效缩放 2. Related Work（相关工作） 2.1 Analyzing importance of depth（分析网络深度的重要性） 已有大量的研究证实了深层网络的优点，具有sigmoid激活的单层神经网络可以以任意小的误差近似任何函数，但是需要使用具有足够大宽度的网络。而要近似函数，具有非线性的深度网络需要的参数要比浅层网络所需要的参数少，而且在固定的预算参数下，深度网络的性能优于浅层网络，这通常被认为是大深度的主要优势之一。
但是在这样的分析中，先前的工作只研究了线性顺序结构的浅层网络，不清楚这个结论是否仍然适用于其他设计。在这项工作中，作者表明浅层网络也可以表现得非常好，但关键是要有并行的子结构。
2.2 Scaling DNNs（深度神经网络的尺寸） 有研究表明，增加深度、宽度和分辨率会导致卷积网络的有效缩放。我们也研究标度规则，但重点关注低深度的机制。我们发现，可以通过增加分支的数量、宽度和分辨率来有效地扩展ParNet，同时保持深度不变和较低。
2.3 Shallow networks（浅层网络） 浅网络在理论机器学习中引起了广泛的关注。在无限宽的情况下，单层神经网络的行为类似于高斯过程，可以用核方法来理解训练过程。然而，与最先进的网络相比，这些模型没有竞争力，我们提供了经验证明，非深度网络可以与深度网络竞争。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c655271449f6cf061c30ca039f83fd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d01454d824ee5fa0bc138f0d84f1c065/" rel="bookmark">
			Part5-1-1 Nodejs 基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nodejs 架构 Natives modules 当前层内容由 JS 实现。
提供应用程序可直接调用库，例如 fs、path、http等。
JS 语言无法直接操作底层硬件设置。需要通过桥梁：Builtin modules "胶水层" （由C++编写）。
底层 V8：执行 JS 代码，提供桥梁接口。
Libuv: 事件循环、事件队列、异步IO
第三方模块：zlib、http、c-ares等。
Reactor模式 单线程完成多线程工作
实现异步IO、事件驱动
可以实现高并发处理
Nodejs 更适用于 IO 密集型高并发请求
Nodejs异步IO nodejs异步 IO 是 异步非阻塞 IO
立即返回的并不是业务层期望得到的数据，而仅仅是当前调用的状态，操作系统为了获取数据，就会让程序重复调用IO操作，判断 IO 是否结束，这种技术称为轮询。
常见轮询技术：read、select、poll、kqueue、event ports
期望实现无需主动判断的非阻塞 IO
1
异步 IO 总结 IO 是异步程序的瓶颈所在
异步 IO 提高性能无须采用原地等待结果返回
IO 操作属于操作系统级别，平台都有对应实现
Nodejs 单线程配合事件驱动架构及libuv实现了异步 IO
Nodejs 事件驱动架构 事件驱动架构是软件开发中的通用模式
事件驱动、发布订阅、观察者
主体发布消息，其他实例接收消息
const EventEmitter = require('events') const myEvent = new EventEmitter() myEvent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d01454d824ee5fa0bc138f0d84f1c065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8587664f43994c6eb6050fb011be4b4f/" rel="bookmark">
			如何删除git config中的某一个配置项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们修改了git config之后
两种方式
一、直接编辑.gitconfig文件 一般在C盘/用户/[你的用户名]下有一个.gitconfig文件，可以直接编辑该文件来进行增删改。
二、使用git命令 例如，使用如下命令，就可以把http.version配置项删除啦
git config --global --unset http.version 顺便说一下，添加/修改/查看的命令吧
#添加修改 git config --global http.version HTTP/1.1 #查看 git config --global http.version #或查看全部 git config --global -l 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b70458242582937829304b901204350/" rel="bookmark">
			c&#43;&#43; map earse的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最高访问的那个总结和回答是错的==
误人子弟…
在遍历map的时候，用map.find(key)查找和比较的是键值对中的键…（可能全世界就我一个人不知道吧…）
需要删除特定值的话，遍历map然后erase，、
erase之后注意指向
这个人写的不对，这样就行了。
for(;itt!=d1.end();){ if(itt-&gt;second==0) d1.erase(itt++); else itt++; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9646f324ab26a492b626c598ca58a748/" rel="bookmark">
			服务器/后端面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++: c和C++的区别：
C语言的引用头文件的方式是include名字.h的方式进行引用，而C++去掉了.h（虽然在绝大多数编译器上任然使用.h的方法也不会报错）而是改成直接引用名字即可，这里需要注意的是C++使用C语言标准时，需要在库前面添加一个c来表明这个库是来自于C语言的。
1
2
3
4
5
6
7
//C语言的方法：带.h的方式进行include
#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
//C++的方法，直接引用即可
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
你的项目使用的是Reactor模式，那你了解过Proactor吗?
Epoll底层是怎么实现的
指针和引用的区别
讲一讲多态
为什么要将父类的析构函数设置为虚函数。
智能指针，讲一讲shared_ptr及其实现原理，与unique_ptr的区别
如何使用gdb去进行调试
基本数据类型和封装类有什么区别，map可以用int吗
抽象类和接口
计算机原理： 输入URL，整个过程 HTTP和HTTPS
详细说一下网络编程即socket通信是如何实现的。（socket通信的执行流程）
进程间通信的方式有哪些。
线程间通信的方式有哪些。
线程间除了共享变量外还有其它什么方式吗?
TCP的三次握手与四次挥手。
TCP四次挥手时的close_wait和time_wait状态有什么作用。
tcp 四次挥手过程第四次握手完是直接关闭连接吗为什么进入 time-wait
TCP拆包与粘包了解吗?
第三次握手 ACK 丢失会发生什么
tcp 拥塞控制的方法
了解过 epoll 的原理吗？多路复用 IO 概念
LInux 环境下多路复用系统调用？具体实现
死锁 进程和线程 线程的实现方式 网络丢包的过程？
TCP 的包从网卡收到以后，在内核的流转过程和用户态进程收到的最终流转过程
什么是OSI
线程的创建方式
2.2 线程工厂 2.3 线程池的核心参数，过程
2.4 四种线程池的问题
11.浏览器输入域名之后发生了些什么？
12.说一下DNS具体是怎么解析的？
13.客户端和服务器是如何建立连接的？
14.如果客户端在三次握手中发送第三次请求的时出现故障了，服务端会断开连接吗？
15.HTTP传输使用的是TCP协议还是UDP协议？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9646f324ab26a492b626c598ca58a748/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87413cae06ad5383af8200342e3304f7/" rel="bookmark">
			Go 字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go 字符串 01 Go 字符串简介02 Go 支持的字面值1、解释字符串2、非解释字符串 03 Go 字符串常用操作1、strings 包（1）判断字符串的前缀和后缀（2）判断字符串的包含关系（3）判断子串出现的位置（索引）（3）字符串替换（4）统计字符串出现次数（5）重复字符串（6）修改字符串大小写（7）修剪字符串（8）分割字符串（9）拼接 slice 到字符串（10）从字符串中读取内容 2、strconv 包（1）数字类型转字符串类型（2）字符串类型转数字类型 01 Go 字符串简介 Go 的字符串内部实现使用 UTF-8 编码，字符串是 UTF-8 字符的一个序列，当字符为 ASCII 码时则占用 1 个字节，其他字符根据需要占用 2-4 个字节。因此 Go 中的字符串里面的字符可能根据需要占用 1 至 4 个字节。Go 这样做的好处是① 减少内存和硬盘空间占用；② 不需要对使用 UTF-8 字符集的文本进行编码和解码。
Go 的字符串的值为双引号""中的内容，可以直接在 Go 语言的源码中直接添加非 ASCII 码字符。
Go 的字符串是一种值类型且值不可变，即创建某个文本后无法对其进行修改。深入一点讲就是：字符串是字节的定长数组。
Go 的字符串是根据长度限定，字符串类型的零值为长度为零的字符串，即空字符串""
一般的比较运算符（==、!=、&lt;、&lt;=、&gt;=、&gt;）通过在内存中按字节比较来实现字符串的对比
02 Go 支持的字面值 Go 支持以下 2 种形式的字面值：
1、解释字符串 该类字符串使用双引号括起来，其中相关的转义字符将被替换，转义字符有：
\n：换行符（直接跳到下一行的同列位置）\r：回车符（返回行首）\t：tab 键（制表符）\'：单引号\"：双引号\\：反斜杠自身\u 或 \U：Unicode字符 2、非解释字符串 该类字符串使用反引号括起来，支持换行，可以用来定义多行字符串，例：
str := `第一行 第二行 第三行\n ` fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87413cae06ad5383af8200342e3304f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50fa28b3b6017d5a3eac29228e88668d/" rel="bookmark">
			Python零基础入门之第二章 Python数据结构（二.元组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第二章 Python数据结构（二.元组） 分享吴军《格局》里面的一句话，激励大家好好学习，“很多时候，我们从能力到主动性都是有限的，在一个舒适的环境下必然懒惰，在一个没有竞争对手的环境中必然自大，然后一步步走向毁灭。”
总目录简介 一 、列表
二、元组（当前位置）
三、字符串
四、字典
五、集合
基本数据类型（比如：整数类型、浮点类型）表示单一数据，而被组合起来的多个数据类型（比如：列表）就是组合数据类型，组合数据类型比单一数据更快捷、高效、灵活，下面是这两种数据的对比，同样的效果，不一样的代码。
#单一数据 s1 = 1 s2 = 2 s3 = 3 sum1 = s1+s2+s3 print(sum1) #组合数据 mylist = [1,2,3] sum2 = sum(mylist)#调用列表中的函数 print(sum1) 下图是组合数据的分类
Python中，序列是最基本的数据结构，是一块用于存放多个值的连续空间，Python中内置了列表、元组、字典、集合、字符串5个常用的序列结构。
二、元组（tuple） 元组（tuple）和列表结构很相似，生成后不可删除或者替换任何数据项，是不可变序列，Python中的元组用圆括号定义，各元素用逗号隔开，可以包含也可以不包含数据，也可以包含多项不同类型的数据。
1.创建
下面以创建普通的元组、空元组、单个元组举例，特别要注意创建单个元组是需要加个逗号生成的才是一个元组。
生成的对象可以用type()这函数来
tup1 = (11,22,33,44,55) tup2 = () s1 = (3)#单个数据举例 tup3 = (3,)#加个逗号，避免和单个数据混淆 print(tup1) print(tup2) print(s1) print(tup3) 2.重新赋值 和 删除整个元组
元组创建后，里面的元素是不可以单独修改的，只能对整个元组进行重新赋值，如果要删除，只能整个元组进行删除，删除元组使用关键字del。
tup4 = [1,2,3] tup4 = [2,4,6,8]#重新赋值 print(tup4) del tup4 #删除 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50fa28b3b6017d5a3eac29228e88668d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e399ef17f09d1114b167bbe4ded1ebf/" rel="bookmark">
			ubuntu下安装Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu14.10系统下默认安装了python2.7.8和python3.4.2，　她们在/usr/bin/下可以找到, 默认用python2.7.8
xx@ada:~$ python --version Python 2.7.8 xx@ada:~$ python3.4 --version Python 3.4.2 xx@ada:~$ python2.7 --version Python 2.7.8 xx@ada:~$ which python /usr/bin/python xx@ada:~$ which python3.4 /usr/bin/python3.4 xx@ada:~$ 现在python官网出了python2.7系列的python2.7.9，　好了，　现在我们尝试着安装python2.7.9
python在ubuntu下有几种安装方法：
通过ubuntu官方的apt工具包安装 通过PPA(Personal Package Archive)　的apt工具包安装 通过编译python源代码安装 通过ubuntu官方的apt工具包安装
sudo apt-get install python2.7 sudo apt-get install python3.4 安装完成后，可以用下面的命令进行确认
xx@ada:~$ python2.7 --version Python 2.7.8 xx@ada:~$ python3.4 --version Python 3.4.2 xx@ada:~$ 从PPA(Personal Package Archives) 安装apt工具包
$ sudo apt-get install python-software-properties $ sudo add-apt-repository ppa:fkrull/deadsnakes $ sudo apt-get update $ sudo apt-get install python2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e399ef17f09d1114b167bbe4ded1ebf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f0f55ae6f32b39f2fe991b703dc2379/" rel="bookmark">
			【用Python对全职高手小说分析分词词频词性，小说人物出场次数排序，小说中食物排序，小说人物关系等等】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 根据第1部分自然语言处理教学内容，请选择一本你喜欢的小说，利用上课讲的但不限于授课内容，对该小说进行分析。比如分析该小说的分词，词频，词性，小说人物出场次数排序，小说中食物排序（这个得有，我喜欢吃），小说人物关系等等。
1、前期准备 1.1 导入库 1.2 小说、用户字典、食物清单、停用词等txt文档 和 字体simfang.ttf 以及词云用到的图片 以上资料自行百度下载 或者 自我总结
2、源码 ''' Autor: 何邦渊 DateTime: 2022/3/20 21:24 IDE: PyCharm Function: 根据第1部分自然语言处理教学内容，请选择一本你喜欢的小说，利用上课讲的但不限于授课内容，对该小说进行分析。比如分析该小说的分词，词频， 词性，小说人物出场次数排序，小说中食物排序（这个得有，我喜欢吃），小说人物关系等等。 要求：1代码以py文件附件形式上传，有功能性注释和普通注释。 2.功能介绍和运行结果截图可以在作业里写上。 3.小说文件用txt形式存储。 4.最后视功能完整性给分. ''' import random import networkx as nx from imageio import imread from wordcloud import WordCloud,ImageColorGenerator import jieba import jieba.posseg as pseg # 获取词性 from collections import Counter import matplotlib.pyplot as plt import numpy as np from matplotlib.font_manager import FontProperties # 去除词性为nr,但不是人名的词 excludes = ['乐章','小姑娘','荣耀','易拉灌','易容术','明白','全明星','蓝溪阁','季后赛','本赛季','砰砰','和兴欣','上赛季','华丽','司仪', '西风','连胜','银武','周旋','马踏','安静','大屏幕','和嘉世','修正','了兴欣','卫星','谢谢','呼啸山庄','马甲','明星','英勇', '真是太','冷不丁','小精灵','高潮','太久','布阵','祝福','段时间','格斗','高水平','言语','别提','冷笑','晓枪','白痴','赛中', '顾忌','越来越近','封锁','小镇','贡献度','高阶','嘉世'] # 解决中文乱码，Python实现matplotlib显示中文的方法 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f0f55ae6f32b39f2fe991b703dc2379/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/501d6bc6452a15d20e97aad5a6f9f8a0/" rel="bookmark">
			最原始版匿名四轴无人机代码注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于STM32平台
#include "CONTROL.h" #include "BSP.H" #include "UART2.h" #include "IMU.h" #include "MPU6050.h" #include "MOTO.h" PID PID_ROL,PID_PIT,PID_YAW; u8 ARMED = 0; u16 moto1=0,moto2=0,moto3=0,moto4=0; float Get_MxMi(float num,float max,float min)//将num限制在min与max之间 { if(num&gt;max) return max; else if(num&lt;min) return min; else return num; } //解算出来的自我姿态，根据此得出自稳所需改变角度 //遥控发来的所需要改变的角度以进行倾斜的飞行，进行前进后退或转向 //Q_ANGLE.X , Q_ANGLE.Y, Q_ANGLE.Z, //RC_Target_ROL, RC_Target_PIT, RC_Target_YAW void CONTROL(float rol_now, float pit_now, float yaw_now, float rol_tar, float pit_tar, float yaw_tar) { vs16 throttle; vs16 yaw_d; float rol = rol_tar + rol_now;//将所有要改变的值加起来 float pit = pit_tar + pit_now; float yaw = yaw_tar + yaw_now; throttle = Rc_Get.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/501d6bc6452a15d20e97aad5a6f9f8a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9533b225bea157fcf70eb86d3fd0bc41/" rel="bookmark">
			vscode运行打包vue项目内存溢出的报错和解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode运行打包vue项目内存溢出的报错和解决办法
最近在再弄一个旧项目的时候发现这个项目异常的大，内容涉及很多，导致我在运行的时候发生了内存的溢出，虽然不影响代码跑起来，但是他时不时保存的时候就断了就很烦，没办法，就去找各种办法来解决，下面就是碰到的问题和一些别人的解决办法
最终的解决办法 ----------------------2022-03-29 最后发现是因为node的版本太高，如果要解决只能把node版本给重新安装一次
真的是无语了，希望大家引以为戒！！！！！！！！！！！！！！！！
node下载网站： https://nodejs.org/zh-cn/
可以参考这个安装教程：https://blog.csdn.net/lu6545311/article/details/123825809
----------------------------------- 这是问题，项目运行的时候，点击保存后内存溢出，项目太大了
95% emitting &lt;--- Last few GCs ---&gt; [21992:03DAAAD8] 186031 ms: Scavenge 728.6 (755.0) -&gt; 728.5 (755.0) MB, 1.0 / 0.0 ms (average mu = 0.997, current mu = 0.969) allocation failure [21992:03DAAAD8] 186096 ms: Mark-sweep (reduce) 728.5 (755.0) -&gt; 697.5 (744.6) MB, 64.4 / 0.0 ms (average mu = 0.995, current mu = 0.990) last resort GC in old space requested [21992:03DAAAD8] 186190 ms: Mark-sweep (reduce) 697.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9533b225bea157fcf70eb86d3fd0bc41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a1f5cda9828f821e3f5aa8741b2bfe8/" rel="bookmark">
			UML练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		状态图3.29 浅历史、深历史和复合状态 在线测试练习 1. 网络教学平台 -- “在线测试” 对象的状态机图建模（出现复合状态，根据情况合理建模）。
2. 对“ 测试未发布（状态）”，“测试答题（状态）” 分析内部活动。
洗衣机练习 通信图 顺序图 一、顺序图基础 1.顺序图建模作业 找出边界类、控制类、实体类
2.例题 3. 例题 教师查看学生成绩 ：共有三张图片，成功查询，未查询到学生信息和未查询到该学生信息
二、顺序图进阶 1. 片段loop alt 的练习 作业3.18 类图 类图建模例题 标红的为添加的标志属性 类
餐厅经理：用户名，密码，发布下周菜单（）、登录（）
菜单：名称、价格、照片、简介，菜品ID
顾客：用户名，密码，号码、送餐地址，下单（）、付款（）、查看订单状态（）
订单：总额、付款状态、订单状态、派送地址、签收人号码、订单ID
订单明细：菜品ID、数量
送餐员：用户名，密码，查看未派送订单（）、修改状态（）、查看订单状态（）、登录（）
支付接口
关系：
餐厅经理发布菜单
顾客生成订单
送餐员修改订单状态
订单和订单明细构成组合关系
生成订单时会使用支付接口完成付款
餐厅经理、用户和送餐员会抽象称为用户类
关于供需接口？什么类会被定义为接口？ 课后练习题 智慧树弹题 类的辨析
例题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6656fc6fa2ffb5a4ad54a1bd6465517a/" rel="bookmark">
			python项目--物流行业项目分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据来源：某企业销售的6种商品所对应的送货及用户反馈数据；数据链接: 物流行业项目分析数据.分析过程为： 数据清洗数据规整数据分析并可视化 准备工作 首先导入包和数据，将编码设置为gbk，若用utf-8会报错。然后查看数据的整体信息，观察以下结果 import pandas as pd import matplotlib.pyplot as plt plt.rcParams['font.sans-serif'] = 'SimHei' # 设置中文显示 data = pd.read_csv('E:\下载\数据分析实战项目资料\物流\资料\data_wuliu.csv', encoding='gbk') print(data.info()) 输出结果为：
结果运行出来后，进行数据清洗。 数据清洗 主要是进行重复值，缺失值，格式调整
首先对数据表进行观察，观察数据要进行哪些操作
通过观察可以得出以下结论：
订单号，商品交货情况，数量：存在缺失值，但是缺失量不大，可以删除订单行：对分析无关紧要，可以考虑删除销售金额格式不对（万元|元，逗号问题），数据类型需要转换成int|float 删除重复记录、除缺失值、订单行，由于删除了重复记录，索引不连续了，所以我们要将索引更新。 data.drop_duplicates(keep='first', inplace=True) data.dropna(axis=0, how='any', inplace=True) data.drop(columns=['订单行'], inplace=True, axis=1) print(data.head()) # 更新索引（drop=True:把原来的索引index列删除，重置index） data.reset_index(drop=True, inplace=True) print(data.head()) 更新索引前后对比
对销售金额列进行处理 取出销售金额列，对每一个数据进行清洗编写自定义过滤函数，删除逗号，转成float若是万元则*10000，否则删除元 def data_deal(number): if number.find('万元') != -1: new_number = float(number[:number.find('万元')].replace(',', '')) * 10000 pass else: new_number = float(number.replace('元', '').replace(',', '')) pass return new_number data['销售金额'] = data['销售金额'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6656fc6fa2ffb5a4ad54a1bd6465517a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f4ebf293626d25089ee475ad1d114ab/" rel="bookmark">
			解除浏览器不能切屏和不能复制粘贴的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /** * 操作说明 * 1.在当前页面按f12，在cosnole控制台下直接运行以下代码，按回车建直接生效 */ window.onblur=function () { }; document.onkeydown=function () { return true }; document.body.oncopy =function () { return true }; document.body.oncopy=function () { return true }; document.body.onselect=function () { return true }; document.body.oncontextmenu =function () { return true }; //解除切屏限制 window.onblur=null window.onblur=function () { console.debug(1); }; //解除快捷键切屏操作 window.onkeyup=window.onkeydown=window.onkeypress=document.onkeyup=document.onkeydown=document.onkeypress document.body.onkeyup=document.body.onkeydown=document.body.onkeypress=onkeyup=null; //解除复制粘贴限制 window.oncopy=window.onpaste=document.oncopy=document.onpaste=document.body.oncopy=document.body.onpaste= oncopy=onpaste=null; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/610d8a49def9215e9197b2d74a3d9c41/" rel="bookmark">
			OpenSSL安装升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网：/source/index.html
当前(2020-10-22)最新稳定版本：https://www.openssl.org/source/openssl-1.1.1h.tar.gz
Note: The latest stable version is the 1.1.1 series. This is also our Long Term Support (LTS) version, supported until 11th September 2023. All older versions (including 1.1.0, 1.0.2, 1.0.0 and 0.9.8) are now out of support and should not be used. Users of these older versions are encourage to upgrade to 1.1.1 as soon as possible. Extended support for 1.0.2 to gain access to security fixes for that version is available.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/610d8a49def9215e9197b2d74a3d9c41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/807b633ac493b53e87de426dbe176139/" rel="bookmark">
			Linux设置UTC时区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置UTC时区命令
ln -sf /usr/share/zoneinfo/UTC /etc/localtime
具体案例：
执行前
[root@HOST etc]#cd /etc
[root@HOST etc]# ll | grep local
-rw-r--r--. 1 root root 19 Mar 25 2018 locale.conf
lrwxrwxrwx 1 root root 35 Mar 12 16:06 localtime -&gt; ../usr/share/zoneinfo/Asia/Shanghai
[root@HOST etc]# date
Tue Mar 16 14:49:58 CST 2021
[root@HOST etc]# ln -sf /usr/share/zoneinfo/UTC /etc/localtime
执行后
[root@HOST etc]# date
Tue Mar 16 06:50:32 UTC 2021
[root@HOST etc]# ll | grep local
-rw-r--r--. 1 root root 19 Mar 25 2018 locale.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/807b633ac493b53e87de426dbe176139/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b536394c163d3fae31a05e1294ef0e0a/" rel="bookmark">
			windows10下修改Docker镜像目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景需求 Windows 版本（Windows 10 wsl 2）docker 默认程序安装到c盘，数据存储于C:\Users\当前用户名\AppData\Local\Docker\wsl\data\ext4.vhdx这样会导致docker占用C盘的空间越来越大。
2、Docker切换盘位操作步骤 2.1. 停止docker 通过windows系统的界面操作停止
打开cmd窗口，查看停止情况：
C:\Users\suntoon-ylf&gt;wsl --list -v NAME STATE VERSION * docker-desktop Stopped 2 docker-desktop-data Stopped 2 2.2. 备份导出目前已有的数据 C:\Users\suntoon-ylf&gt;wsl --export docker-desktop-data "D:\Docker\wsl\data\docker-desktop-data.tar" C:\Users\suntoon-ylf&gt;dir D:\Docker\wsl\data\ 驱动器 D 中的卷没有标签。 卷的序列号是 0007-3FF9 D:\Docker\wsl\data 的目录 2022/03/29 09:56 &lt;DIR&gt; . 2022/03/29 09:56 &lt;DIR&gt; .. 2022/03/29 09:57 2,984,243,200 docker-desktop-data.tar 命令说明：将目前已有的数据备份到D:\Docker\wsl\data\目录下，并命名为docker-desktop-data.tar
2.3. 删除原有数据 C:\Users\suntoon-ylf&gt;wsl --unregister docker-desktop-data 正在注销... C:\Users\suntoon-ylf&gt;wsl --list -v NAME STATE VERSION * docker-desktop Stopped 2 说明：解除当前的docker数据虚拟盘映射，进行该操作后会删除原有的ext4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b536394c163d3fae31a05e1294ef0e0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5d5b4e824cf96f0c355cf2320a6057e/" rel="bookmark">
			uniapp播放视频 Uncaught (in promise)DOMException: The element has no supported sources.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://uniapp.dcloud.io/component/video.html
参考：https://blog.csdn.net/wusejiege6/article/details/110723290
加入&lt;video src=""&gt;&lt;video&gt;标签即可
&lt;video src="http://114.55.8.17:8000/static/file/%E4%B8%BE%E9%87%8D%E5%A4%B1%E8%AF%AF%E9%9B%86%E9%94%A6.mp4"&gt;&lt;/video&gt; 效果
发现内置的浏览器始终不行
查看官方文档
可以直接用浏览器或者模拟器运行效果
即可运行
或者运行到内置模拟器即可
效果如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/564941c0b5dba4da578eaa7780eab203/" rel="bookmark">
			oracle数据库的连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle数据库的连接以及页面跳转的方式和区别
这是两种方式
if("admin".equals(name)&amp;&amp;"123".equals(pwd)){ //页面跳转的两种方式 //1.重定向response //跳转页面，地址栏发生改变,不能将值传递到下一个页面 //可以随意跳转到其他资源 //response.sendRedirect("dodl.jsp"); //2.转发request //跳转页面，能够将值传递到下一个界面，但是地址栏不发生改变而是停留在了之前的界面 //不能随意的跳转其他页面，只能访问项目中的资源 request.getRequestDispatcher("dodl.jsp").forward(request,response); }else{ out.print("&lt;script&gt;alert('登录失败');location.href='imdex.jsp'&lt;/script&gt;"); } 效果如图：
转发request只能访问项目中的资源，但是可以传递数据
重定向response可以跳转任意资源，但是不能传递数据
综合以上，我们在跳转页面时，需要传递数据就使用转发request
数据库连接：
客户端想要访问数据需要访问数据库，而jdbc就是连接数据库的路径
String URL="jdbc:oracle:thin:localhost:1521:orcl";//这里注意，打错一个都会导致连接不上数据库 String CNAME="oracle.jdbc.driver.OracleDriver";//导入驱动包 Class.forName(CNAME);//加载驱动 Connection con=DriverManager.getConnection(URL, "scott", "tiger");//创建连接 String sql="insert into tb_xw(nname,nzz,nzy,nnr) values(?,?,?,?)";//定义sql语句 PreparedStatement ps=con.prepareStatement(sql);//获得执行对象 ps.setString(1, nname);//给占位符赋值 ps.setString(2, nzz); ps.setString(3, nzy); ps.setString(4, nny); int n=ps.executeUpdate();//返回影响行数 if(con!=null&amp;&amp;!con.isClosed()){//关闭资源 注意增删改这里关闭两个:con,ps 如果是查，则需要关闭三个:con,ps,rs con.close(); }if(ps!=null){ ps.close(); } if(n&gt;0){ out.print("&lt;script&gt;alert('提交成功')&lt;/script&gt;"); }else{ out.print("&lt;script&gt;alert('提交失败')&lt;/script&gt;"); } 连接数据库的步骤为：
1：导入驱动包
2：加载驱动包
3：与oracle创建连接
4：定义sql语句
5：获得执行对象
6：关闭资源
jdbc进行数据提交需要commit吗？
jdbc进行数据的提交时不需要commit(提交)，因为jdbc已经帮你提交了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aecc184b15c87d53ec67b6863f4ed30b/" rel="bookmark">
			pip install git(pip直接安装git上的项目)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 示例2. 参考3. pip install git XXX命令放入用户名和密码3.1 gitlab 4. git clone命令中包含用户名密码/token4.1 github使用git clone 1. 示例 我有一个没有发布到PyPI源上的python包（主要有一个setup文件就行），位置在git上，我希望以pip install的方式安装，一步解决，而不是先git clone，再转到对应目录，进行安装。
通常的安装
# 两步走的安装（安装完还需要自己删除git文件） git clone http://127.0.0.1/XXX/demo.git #change dir cd demo # install python setup.py install --user # windows环境下加--user 不然容易报错 简化/更方便的安装
pip install git+http://127.0.0.1/xxx/demo.git --user 2. 参考 参考：
stack-overflow： pip install from git repo branch官方文档：pip document：直接页面搜索git
VCS Support pip可以支持git这种安装方式是因为pip支持VCS协议（ version control systems 版本控制系统），只要满足特定格式就可以支持了
pip install git+
3. pip install git XXX命令放入用户名和密码 对于git ，默认中间会暂停，让输入用户名和密码等，或者已经配置了ssh。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aecc184b15c87d53ec67b6863f4ed30b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a42f15ab293bb0566b9072ca5ac5f9c/" rel="bookmark">
			python项目--餐厅订单数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入包，加载数据 数据是网上获取的，数据见链接: 餐厅订单数据分析的数据.通过分析之后我们要用到以下三个包，分别是numpy、pandas、matplotlib。加载数据我们采用pandas中的read_excel函数，由于该表中有三张小表，我们将这三张表都读取进来。 import numpy as np import pandas as pd import matplotlib.pyplot as plt plt.rcParams['font.sans-serif'] = 'SimHei' # 设置中文显示 data1 = pd.read_excel("E:\下载\数据分析实战项目资料\餐厅\meal_order_detail.xlsx", sheet_name='meal_order_detail1') data2 = pd.read_excel('E:\下载\数据分析实战项目资料\餐厅\meal_order_detail.xlsx', sheet_name='meal_order_detail2') data3 = pd.read_excel('E:\下载\数据分析实战项目资料\餐厅\meal_order_detail.xlsx', sheet_name='meal_order_detail3') 数据预处理 因为三张表不方便操作且有些内容重复，所以使用pandas库中的concat函数将三张表的数据拼接起来，并用dropna方法将空的列给删掉 data = pd.concat([data1, data2, data3], axis=0) # 按照行进行拼接数据 # 查看数据的前五列 print(data.head(5)) data.dropna(axis=1, inplace=True) # 按照列删除na列，并且修改源数据 # 查看数据详情信息，有多少个非空值等 print(data.info()) 分析数据–初步分析 统计卖出菜品的平均价格 print(round(data['amounts'].mean(), 2)) #方法一：pandas自带函数 print(round(np.mean(data['amounts']), 2)) #方法二：numpy函数处理 频数统计，最受欢迎的10个菜，并画出菜品和销量的条形图 dishes_count = data['dishes_name'].value_counts()[:10] print(dishes_count) dishes_count.plot(kind='line', color=['r']) dishes_count.plot(kind='bar', fontsize=16) for x, y in enumerate(dishes_count): print(x, y) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a42f15ab293bb0566b9072ca5ac5f9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81500a9bb3d36b9208d79c8bf9d74a46/" rel="bookmark">
			超微X99 ESXI物理机安装提示No Network Adapters
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示见下图
解决办法该主板有相应的跳线，如下图。
短接1-2脚为启动网络
短接2-3脚为禁用网络
再装系统的时候出现No Network Adapters，改换多个系统测试都不行。通过咨询服务器的卖家，得知在发货前该跳线帽没有调整到1-2脚，导致在安装操作系统的时候出现找不到网络。
查询大量资料需要自己制作系统，这种情况极少遇到。如果大家在安装系统过程中出现上述的问题建议先检测主板是否有相应的跳线帽设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48117388d95c72cd0b593ed2cf80caed/" rel="bookmark">
			docker中的java程序运行ffmpeg拉流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		差点就放弃了。搞这些东西没有什么意义。
有个java项目，需要开启ffmpeg拉流，然后想将这个程序部署在docker。不料颇多波折。幸而最后成功，差点就放弃了。记录如下。
一、基本情况 1、我们写了个视频拉流控制程序，依赖JDK1.8。运行过程中，需要启动操作系统的ffmpeg进行拉流。
2、部署环境是统信欧拉版（UOS Euler） + docker。统信欧拉版是基于华为的OpenEuler（其前身是华为的服务器操作系统EulerOs)，是将OpenEuler的内核 + 统信的桌面操作模块DDE。
“统信 UOS 欧拉版采用 Linux kernel 4.19、GCC 7.3、Glibc2.28 等组件作为系统运行的基础环境，搭载统信自研 DDE 桌面环境，可提供良好的人机交互功能，并针对华为鲲鹏系列处理器的稳定性和运行性能参数进行了深度调优，可应用于云、虚拟化、容器、大数据、人工智能等场景。”
如果完全是统信自己的版本，基于debian；而统信欧拉内核不一样，感觉统信欧拉更像CentOs。
二、问题描述 像其他jar包一样，构建镜像，生成并运行容器，按部就班，一帆风顺。但在Portainer上看运行日志，傻眼了，说找不到”ffmpeg“这个命令。在命令前面加上绝对路径，”/usr/bin/ffmpeg“，还是说No such file or Diectory。
怎么可能呢？忽然想起，jar包运行在容器里，容器本身相当于一个简单版的虚拟机，跟宿主机是隔开的，ffmpeg装在宿主机上，docker容器里的程序无法访问很正常。
那docker容器里的程序怎样才能访问到ffmpeg呢？
1、采用挂载的方式，将ffmpeg所在路径挂到docker容器里？不行，各种环境依赖没有。
2、构建镜像时，先用ffmpeg作为基础镜像，然后再以JDK8为基础镜像？不行，构建镜像，虽然Dockerfile支持写多个FROM，但却以最后一个为准。前面的基础镜像，其实只适合做临时性的过渡脚垫，用完即弃。可以拷贝到构建中的镜像，然而并没有什么卵用，我试了，出来的镜像没有ffmpeg。
#然而并没有什么卵用 FROM jrottenberg/ffmpeg:4.4-alpine AS FFmpeg FROM node:16-alpine COPY --from=FFmpeg / / 3、真正有用的是构建镜像时，安装ffmpeg。
但是，docker里怎么安装ffmpeg? Dockerfile这样写：
FROM java:8 RUN yum install ffmpeg EXPOSE 9977 提示无法识别 yum 命令。
改成apt可以识别，但提示无法找到ffmpeg包。遵照网上教程，安装前先升级apt：
RUN apt update &amp;&amp; apt install ffmpeg 然而并没有什么卵用，apt无法升级，连接到debian，有个包找不着，404。
网上见到有用 apk add 的方式，但仍然提示无法识别apk这个命令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48117388d95c72cd0b593ed2cf80caed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc5dd94bf27134b3870d4bc90d57a86/" rel="bookmark">
			使用Sub-drawing功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介导出Sub-drawing文件1、选择导出Sub-drawing文件２、选择对象，定点3、保存 导入Sub-drawing文件1、选择导入Sub-drawing文件２、选择对象，定点 简介 关于这个功能，它给我最直观的使用价值就是可以在导出(或者导入)PCB中的走线，这样的一个好处就是什么呢？（1）、它可以整合走线：比如有一个100层的PCB板子，同事A走的时1-30层，你走的是31—60层，另一个同事走的是61—100层，当然能 被分配这样走线是指明了每个人的分工，到最后整合是可以用这个方法。（2）复用走线：在多层的走线中必然存在着相似分线方向的情况，比如你同事A某一层走的40根线正好和你走的大概位置相同，这是你可以把他的线复用下来，只需删掉那些线两端无用的部分，用来做些微调来连接自己的。
导出Sub-drawing文件 1、选择导出Sub-drawing文件 ２、选择对象，定点 我这里选择的是线，接着左键单击拖动你想要选择的线（这些选中的线会显示高亮）。
在Command面板上输入“x 0 0”,按下Enter键会弹出一个对保存的弹窗。
3、保存 按下保存即可，standard便是其名字（保存后会发现是standard.clp文件）。
导入Sub-drawing文件 注意：这里的standard.clp文件需要在当前brd文件下才可导进来。比如我的这个PCB板子在如下地址下。那standard.clp文件，也需要在这个地址下哈，这样才能导进来。
1、选择导入Sub-drawing文件 ２、选择对象，定点 选择刚才保存的文件，点击OK
此时会发现有个框，直接在在下面输入“x 0 0”,Enter便可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8634f0b3ca1570eb1f2e38b674566f5/" rel="bookmark">
			centos 添加路由命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：
添加路由
route add -net 192.168.0.0/24 gw 192.168.0.1
route add -host 192.168.1.1 dev 192.168.0.1
删除路由
route del -net 192.168.0.0/24 gw 192.168.0.1
add 增加路由
del 删除路由
-net 设置到某个网段的路由
-host 设置到某台主机的路由
gw 出口网关 IP地址
dev 出口网关 物理设备名
增 加默认路由
route add default gw 192.168.0.1
默认路由一条就够了
route -n 查看路由表
方法二：
添加路由
ip route add 192.168.0.0/24 via 192.168.0.1
ip route add 192.168.1.1 dev 192.168.0.1
删除路由
ip route del 192.168.0.0/24 via 192.168.0.1
add 增加路由
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8634f0b3ca1570eb1f2e38b674566f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02d99728ad2b71ef88206da0e20139f/" rel="bookmark">
			OpenCV实践小项目(一): 信用卡数字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 写在前面 今天整理一个OpenCV实践的小项目， 前几天整理了一篇OpenCV处理图像的知识笔记，后面，就通过一些小项目把这些知识运用到实践中去，一个是加深理解，另一个是融会贯通，连成整体，因为我发现，如果这些东西不用的话，其实很快就会忘掉。 另外，就是我发现这些实践小项目非常使用，有些代码或者图像的处理技巧可以为以后所用，所以这也是我想整理下来的原因。
第一个实践项目是信用卡数字识别，就是给定一张信用卡， 做出下面的这种效果：
这个项目用到的知识其实在很多其他场景也会遇到，比如像车牌号识别检测，数字识别等，所以感觉还是比较实用的。 但其实， 本质上用到的知识并不复杂，完全是前面整理的OpenCV基本图像操作，那么究竟是如何做到的那？
下面首先分析这个项目的宏观实现逻辑，也就是拿到这样的一个小任务应该大致上怎么思考，然后给出具体的做法以及代码解释。
2. 实现逻辑 给定一个信用卡，最终要输出上面的卡号，且需要在原图中把卡号的位置圈出来。 本质上，这是一个模板匹配任务，如果想让计算机认识数字，我们需要给定一个模板，比如下面这个：
这样， 我们只要找到信用卡上的数字区域，然后拿着数字区域的数字一一与模板进行匹配，看看到底是啥数字，就能识别出来了。 但是，对于信用卡来说我们需要找到它的数字区域呀，对于给定的模板，我们虽然有它的数字区域，但是也得分割成一个个的数字，才能进行匹配工作呀，所以该任务，就转成了处理信用卡， 处理模板以及模板匹配三个子问题。 、
想起了小学学过的一篇课文《走一步，再走一步》。
如何处理信用卡，找到数字区域呢？ 大致上思路如下：
使用轮廓检测算法，找到每个对象的大致轮廓以及外接矩形，即先定位到各个对象找到对象轮廓之后，根据外接矩形的长宽比例，找到中间的这一长串数字部分，由于这个轮廓比较长比较窄，所以还是比较好找的对于这一长串数字，用形态学操作使其更加突出，让这部分更加精准接下来，对于这一部分，再次进行轮廓检测，分割成了四个小块，对于每个小块再进行轮廓检测，就能得到每个具体的数字了对于每个数字，与模板进行匹配(直接有函数可用)，就知道是几了。 如果处理模板呢？这个很简单。轮廓检测一次，就能找到这10个对象，然后给每个对象赋予值，然后建立成一个字典即可。
下面就一步一步的进行代码解释。
3. 处理模板图像 模板图像先进行三步操作： 读入 -&gt; 转成灰度图 -&gt; 二值化， 因为轮廓检测函数接收的是二值图。
# 读取模板图像 img = cv2.imread("images/ocr_a_reference.png") # 读取的时候转灰度 cv2.imread("images/ocr_a_reference.png", 0) # 转成灰度图 template = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 二值图像 template = cv2.threshold(template, 10, 255, cv2.THRESH_BINARY_INV)[1] 结果如下：
接下来，用cv2的轮廓检测函数拿到10个数字的轮廓
cv2.findContours()函数接受的参数为二值图， 即黑白图像(不是灰度图), cv2.RETR_EXTERNAL只检测外轮廓， cv2.CHAIN_APPROX_SIMPLE只保留终点坐标
# 最新版opencv只返回两个值了 3.2之后， 不会返回原来的二值图像了，直接返回轮廓信息和层级信息 contourss, hierarchy = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f02d99728ad2b71ef88206da0e20139f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/527483f30757b11c9ee5ebeaf16a6fe5/" rel="bookmark">
			Python图像亮度自适应增强(图像自动调亮)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章结构 文章主要目的是分享一种自动调节图像亮度的方法，在这篇文章内，你能了解到以下内容：
图像的灰度直方图图像的亮度调整 1.图像的直方图 一张图像一般由RGB三个通道（红色、绿色、蓝色三个部分）组成。单独对某个通道而言，把一幅图像中每一个像素出现的次数都统计出来，然后把每一个像素出现的次数除以总的像素个数，得到的就是这个像素出现的频率，然后再把该像素出现的频率用图表示出来，就构成了灰度直方图。
图像直方图由于其计算代价较小，且具有图像平移、旋转、缩放不变性等众多优点，广泛地应用于图像处理的各个领域，特别是灰度图像的阈值分割、基于颜色的图像检索以及图像分类。本文所述的图像亮度自适应调整方法就依赖于图像直方图的概念。
用等会儿我们即将做亮度自适应增强的例子展示直方图效果：
注：上述影像并非存黑色，为了展示，找了一张亮度较低的卫星影像做实例。直方图中的红绿蓝色线条分别代表rgb三个通道的灰度直方图。
2.图像亮度自适应调整 可以看到，三个通道的像素值大多分布在0到20之间，所以图像呈现极暗。图像的亮度也是与像素值挂钩，像素值越大，则一般而言，影像会越亮，那是不是对每个像素值加一定值就可以调整亮度呢？
答案是否定的，若直接将像素值加上200，则结果图像会变白，但是地物依然无法识别，这是因为像素值之间的差别很小，可能像素值5代表的是灰色的屋顶，6代表的是绿色的草地，但是在像素值变大后变为205与206，看起来都是白色，所以无法展示实际影像。
上述的是影像的亮度调整，所以还需要影像的对比度调整。
影像的对比度指的是间隔，在调大像素值的同时增加像素值之间的间隔，则会得到较好的结果。
先展示自适应调整后的结果：
下面讲解具体python实现。
讲道理，先import库，读图片。
import numpy as np import cv2 def compute(img, min_percentile, max_percentile): """计算分位点，目的是去掉图1的直方图两头的异常情况""" max_percentile_pixel = np.percentile(img, max_percentile) min_percentile_pixel = np.percentile(img, min_percentile) return max_percentile_pixel, min_percentile_pixel def aug(src): """图像亮度增强""" if get_lightness(src)&gt;130: print("图片亮度足够，不做增强") # 先计算分位点，去掉像素值中少数异常值，这个分位点可以自己配置。 # 比如1中直方图的红色在0到255上都有值，但是实际上像素值主要在0到20内。 max_percentile_pixel, min_percentile_pixel = compute(src, 1, 99) # 去掉分位值区间之外的值 src[src&gt;=max_percentile_pixel] = max_percentile_pixel src[src&lt;=min_percentile_pixel] = min_percentile_pixel # 将分位值区间拉伸到0到255，这里取了255*0.1与255*0.9是因为可能会出现像素值溢出的情况，所以最好不要设置为0到255。 out = np.zeros(src.shape, src.dtype) cv2.normalize(src, out, 255*0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/527483f30757b11c9ee5ebeaf16a6fe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03b50dc84a04902de2c90ba55f44724f/" rel="bookmark">
			pytorch实现Parnet猫狗识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. Introduction（介绍）2. Related Work（相关工作）2.1 Analyzing importance of depth（分析网络深度的重要性）2.2 Scaling DNNs（深度神经网络的尺寸）2.3 Shallow networks（浅层网络）2.4 Multi-stream networks（多尺寸流的网络） 3. METHOD（网络设计方法）3.1 PARNET BLOCK3.2 DOWNSAMPLING AND FUSION BLOCK3.3 NETWORK ARCHITECTURE 4. RESULTS（结果展示）代码演示1. 导入库2. 设置超参数3. 数据预处理4. 构建ParNet5. 设置损失函数和优化器6. 训练模型7. 预测图片 前言 深度是深度神经网络的标志，但深度越大意味着顺序计算越多延迟也越大。这就引出了一个问题——是否有可能构建高性能的“非深度”神经网络？作者实现了一个12层的网络结构实现了top-1 accuracy over 80%on ImageNet的效果。分析网络设计的伸缩规则，并展示如何在不改变网络深度的情况下提高性能。
下面我们就看看作者在论文中是怎么说的吧！
论文地址：https://arxiv.org/abs/2110.07641
1. Introduction（介绍） 人们普遍认为，大深度是高性能网络的重要组成部分，因为深度增加了网络的表征能力，并有助于学习越来越抽象的特征。但是大深度总是必要的吗?这个问题值得一问，因为大深度并非没有缺点。更深层次的网络会导致更多的顺序处理和更高的延迟;它很难并行化，也不太适合需要快速响应的应用程序。
为此，作者进行了研究提出了ParNet。ParNet可以被有效的并行化，并且在速度和准确性上都优于Resnet。注意，尽管处理单元之间的通信带来了额外的延迟，但还是实现了这一点。如果可以进一步减少通信延迟，类似parnet的体系结构可以用于创建非常快速的识别系统。
不仅如此，ParNet可以通过增加宽度、分辨率和分支数量来有效缩放，同时保持深度不变。作者观察到ParNet的性能并没有饱和，而是随着计算吞吐量的增加而增加。这表明，通过进一步增加计算，可以实现更高的性能，同时保持较小的深度(~ 10)和低延迟。
下图是论文中ParNet与其它网络的比较。
论文作者的贡献：
首次证明，深度仅为12的神经网络可以在非常有竞争力的基准测试中取得高性能（ImageNet上80.7%）展示了如何利用ParNet中的并行结构进行快速、低延迟的推断研究了ParNet的缩放规则，并证明了恒定的低深度下的有效缩放 2. Related Work（相关工作） 2.1 Analyzing importance of depth（分析网络深度的重要性） 已有大量的研究证实了深层网络的优点，具有sigmoid激活的单层神经网络可以以任意小的误差近似任何函数，但是需要使用具有足够大宽度的网络。而要近似函数，具有非线性的深度网络需要的参数要比浅层网络所需要的参数少，而且在固定的预算参数下，深度网络的性能优于浅层网络，这通常被认为是大深度的主要优势之一。
但是在这样的分析中，先前的工作只研究了线性顺序结构的浅层网络，不清楚这个结论是否仍然适用于其他设计。在这项工作中，作者表明浅层网络也可以表现得非常好，但关键是要有并行的子结构。
2.2 Scaling DNNs（深度神经网络的尺寸） 有研究表明，增加深度、宽度和分辨率会导致卷积网络的有效缩放。我们也研究标度规则，但重点关注低深度的机制。我们发现，可以通过增加分支的数量、宽度和分辨率来有效地扩展ParNet，同时保持深度不变和较低。
2.3 Shallow networks（浅层网络） 浅网络在理论机器学习中引起了广泛的关注。在无限宽的情况下，单层神经网络的行为类似于高斯过程，可以用核方法来理解训练过程。然而，与最先进的网络相比，这些模型没有竞争力，我们提供了经验证明，非深度网络可以与深度网络竞争。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03b50dc84a04902de2c90ba55f44724f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a0609aebcc11e0111f425274ad1ae77/" rel="bookmark">
			web前端兼容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 兼容性：
Compatibility overviewhttps://www.quirksmode.org/compatibility.html
当前测试 CSS所有 CSS 选择器和声明（最终）。DOM所有 DOM 测试（最终）。DOM 事件桌面浏览器中的各种事件何时触发？HTML5 测试测试一些 HTML5 功能。需要更多的测试。移动测试概述我的移动测试的门户页面。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e014e23e737ddc881d3a154b3b3f28/" rel="bookmark">
			经典论文学习笔记——13篇对比学习（Contrastive Learning）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		emsp; 跟着李沐老师的对比学习课程看了一遍，又照着知乎 / CSDN等各位大佬的总结，重新理解了一遍，下面根据自己的学习来总结一下。着重讲一下MoCo，及附带其他12种对比学习的论文的改进之处。
以下是一些可以参考的博客：
对比学习串烧（李沐大神视频学习笔记）
CVPR2020-MoCo-无监督对比学习论文解读
无监督对比学习之MOCO
如何评价Deepmind自监督新作BYOL
自监督学习 要说到对比学习，首先要从自监督学习开始讲起。自监督学习属于无监督学习范式的一种，特点是不需要人工标注的类别标签信息，直接利用数据本身作为监督信息，来学习样本数据的特征表达，并用于下游任务。
目前机器学习主流的方法大多是监督学习方法，这类方法依赖人工标注的标签，这会带来一些缺陷：
数据本身提供的信息远比稀疏的标签更加丰富，因此使用有监督学习方法训练的模型有时候是“脆弱”的；标注成本太高有监督学习通过标签训练得到的模型往往只能学到一些任务特定的知识，而不能学习到一种通用的知识，因此有监督学习学到的特征表示难以迁移到其他任务。 自监督学习分类 当前自监督学习可以被大致分为两类：
Generative Methods （生成方法） Contrastive Methods （对比方法） Generative Methods（生成式方法） 这类方法以自编码器为代表，主要关注pixel label的loss。举例来说，在自编码器中对数据样本编码成特征再解码重构，这里认为重构的效果比较好则说明模型学到了比较好的特征表达，而重构的效果通过pixel label的loss来衡量。Contrastive Methods（对比式方法） 这类方法则是通过将数据分别与正例样本和负例样本在特征空间进行对比，来学习样本的特征表示。Contrastive Methods主要的难点在于如何构造正负样本。 对比方法相比于生成方法的主要优点：Generative Methods需要对像素细节进行重构来学习到样本特征，Contrastive Methods只需要在特征空间上学习到区分性 （其核心是通过计算样本特征间的距离，拉近正样本，拉远负样本）。因此Contrastive Methods不会过分关注像素细节，而能够关注抽象的语义信息，并且相比于像素级别的重构，优化也变得更加简单。
MoCo——何凯明带着它来拯救世界： 先讲一下MoCo，因为MoCo可以认为是最经典的对比学习算法了，随后再讲一下其他12种对比学习论文。
一.end-to-end模式： 红色框对应的正样本对特征q1和k1，蓝色框对应的是负样本特征；两个特征提取器是使用的相同的参数。输入一个batch之后，batch中的每一个样本都要当作一次正样本。
该模式存在的一个问题，就是负样本的数量受到batch size大小的限制，在没有庞大GPU集群的支持下，负样本的数量是不会特别多的。
因此，接下来有了 Memory bank 来解决这个问题。
二.memory bank模式: 一开始，生成一个大小为k的随机队列，队列里面的feature都是随机初始化的, 这个就是Memory bank，然后开始训练，每迭代一次，将新生成的feature k1加入队列，并让队列中最初加入队列的feature出队。
其实就是将每次编码好的feature存储起来，然后每个负样本都是从memory bank中随机抽取，这样一下子就可以取很多负样本了，不会对GPU造成很大负担（因为feature相比于每张图片的大小来说，是很小的）。
但这样有个问题是存储好的编码都是之前的编码器计算的，而左侧编码器一直在更新，会有两侧不一致的情况，影响目标优化。（怎么去理解这句话呢？比如说一下子传入128张图片，然后这128张图片计算了128个feature，把这128个feature放进Memory bank中，然后从Memory bank中取出N个负样本特征。用着N个负样本特征去更新一次编码器，然后编码器更新了，下次进入Memory bank中的特征就是更新编码器后的特征了，那么假设更新了一百次，一千次，那么第一次更新的特征和最后一次更新的特征是有很大区别的，但是我们随机采样时采集的特征，有第一次，也有最后一次的，这样会引起很大的问题，我的个人理解。）
三.动量编码器（MoCo） 所以何凯明带着MoCo来拯救世界了
MoCo与Memory Bank的区别就是新feature k1的获取不是通过encoder q，而是通过encoder q参数的历史组合得到（动量编码器），Momentum encoder和encoder q的网络结构完全相同，仅是参数不一样.。Momentum 参数的具体更新公式为 ：
这样Memory Bank中的feature区别就会变小，解决了Memory Bank存在的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81e014e23e737ddc881d3a154b3b3f28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612bf87ebbff1a7a938695641d7954a3/" rel="bookmark">
			python tkinter路径选择功能的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入filedialog，定义导入路径函数
import tkinter as tk from tkinter import filedialog #输入文件路径 def selectPath_file(): path_ = filedialog.askopenfilename(filetypes=[("数据表", [".xls", ".xlsx"] )]) var_name.set(path_) #输入文件夹路径 def selectPath_dir(): path_ = filedialog.askdirectory() var_name2.set(path_) filetypes可以指定要导入文件的文件类型，
第一个参数"数据表"是导入文件时的提示，如图：
第二个参数[".xls", ".xlsx"]是指定后缀，只有相同后缀的文件才可以选中
完整代码展示： import tkinter as tk from tkinter import filedialog window=tk.Tk() window.title('数据处理') window.geometry('600x380') tk.Label(window,text="文件路径：").place(x=50,y=50) var_name=tk.StringVar() #文件输入路径变量 tk.Label(window,text="文件路径夹：").place(x=50,y=100) var_name2=tk.StringVar() #文件夹输入路径变量 entry_name=tk.Entry(window,textvariable=var_name,width=55) entry_name.place(x=120,y=50) entry_name2=tk.Entry(window,textvariable=var_name2,width=55) entry_name2.place(x=120,y=100) #输入文件路径 def selectPath_file(): path_ = filedialog.askopenfilename(filetypes=[("数据表",[".xls", ".xlsx"])]) var_name.set(path_) #输入文件夹路径 def selectPath_dir(): path_ = filedialog.askdirectory() var_name2.set(path_) tk.Button(window, text = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/612bf87ebbff1a7a938695641d7954a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58921556cb70203c27ed926771a11e80/" rel="bookmark">
			yum仓库安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是yum 仓库
1.自动解决依赖关系
2.只需要软件的名字即可安装
存放仓库的位置（命令pwd）存放仓库的位置：/etc/yum.repos.d/
仓库文件的后缀名是 .repo
仓库的类型分为 网络仓库和本地仓库
仓库解释：[....]仓库标签(不能有重复的) name:仓库的名字(随便写，最好不要重复)
baseurl:仓库的路径
自己创建一个本地仓库
mv-----移动
mv *.repo /home/（表示后缀名为.repo的都移动到home里面去）
yum install mariadb mariadb-server (安装)
yum remove 软件名 （卸载）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f92ae63f29a1f7f91e4317c2680c8a8/" rel="bookmark">
			OpenCV之开运算与闭运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.开运算：先腐蚀，后膨胀 开运算总结：
（１）开运算能够除去孤立的小点，毛刺和小桥，而总的位置和形状不便。
（２）开运算是一个基于几何运算的滤波器。
（３）结构元素大小的不同将导致滤波效果的不同。
（４）不同的结构元素的选择导致了不同的分割，即提取出不同的特征。 代码： import cv2 import numpy as np import matplotlib.pyplot as plt img = cv2.imread(r"C:\Users\Curry\Desktop\cc.png") # img = cv2.cvtColor(img, code=cv2.COLOR_BGR2RGB) kernel = np.ones(shape=[10, 10], dtype=np.uint8) img = 255-img #黑变白，白变黑 # 开运算，先腐蚀，后膨胀 result = cv2.morphologyEx(img, op=cv2.MORPH_OPEN, kernel=kernel, iterations=1) plt.subplot(1,2,1) plt.title('raw') plt.imshow(img) plt.subplot(1,2,2) plt.title('monrph') plt.imshow(result) plt.show() 2.闭运算：先膨胀，后腐蚀 闭运算总结： （1）闭运算能够填平小湖（即小孔），弥合小裂缝，而总的位置和形状不变。
（2）闭运算是通过填充图像的凹角来滤波图像的。
（3）结构元素大小的不同将导致滤波效果的不同。
（4）不同结构元素的选择导致了不同的分割
代码：
import cv2 import numpy as np import matplotlib.pyplot as plt img = cv2.imread(r"C:\Users\Curry\Desktop\aa.png") # img = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f92ae63f29a1f7f91e4317c2680c8a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10632c23b0a2212f9d64fd843eadca4f/" rel="bookmark">
			聊聊电商系统中常见的9大坑，库存超卖、重复下单、物流单ABA...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做为一名程序员，发展方向大致可以分为两个方面：一个是业务架构，一个是技术架构（中间件方向）。
业务架构，取其核心关键词，主要是围绕这不同的业务场景、业务规则，完成业务系统的落地建设，为用户提供在线化的信息服务。
既然说到业务，那方向可就多了去了，如：出行、外卖、充电宝、O2O、内容、社交、生鲜、电商，不同的业务有不同的特点。
面对这么多的业务域，有没有通用技术经验可以抽取，让我们可以以一应百。
这里，首推电商业务，电商系统的复杂性很高，对高并发、高性能、高可用、高扩展，等方面要求很高。你在其他业务中可能遇到的问题，在电商系统中基本都会遇到。
作为开发，希望自己成为某几个业务领域的技术专家，最好能先精通电商领域，有很强的借鉴意义。对于你后续拓展熟悉其他业务领域的个性化玩法有很大帮助。
那么，电商领域的技术架构有哪些常见问题？
一、避免重复下单 用户快速点了两次 “提交订单” 按钮，浏览器会向后端发送两条创建订单的请求，最终会创建两条一模一样的订单。
解决方案：
解决方案就是采用幂等机制，多次请求和一次请求产生的效果是一样的。
方案一：
利用数据库自身特性 “主键唯一约束”，在插入订单记录时，带上主键值，如果订单重复，记录插入会失败。
操作过程：
引入一个服务，用于生成一个“全局唯一的订单号”进入创建订单页面时，前端请求该服务，预生成订单ID提交订单时，请求参数除了业务参数外，还要带上这个预生成订单ID 方案二：
前端通过js脚本控制，无法解决用户刷新提交的请求。另外也无法解决恶意提交。
不建议采用该方案，如果想用，也只是作为一个补充方案。
方案三：
前后约定附加参数校验。
当用户点击购买按钮时，渲染下单页面，展示商品、收货地址、运费、价格等信息，同时页面会埋上Token信息，用户提交订单时，后端业务逻辑会校验token，有且匹配才认为是合理请求。
注意：同一个 Token 只能用一次，用完后立马失效掉。
&lt;form action="/add-name-v2" method="post"&gt; {% csrf_token %} &lt;input type="text" name="name"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; 补充：
关于幂等的处理，更多解决方案可以看这两篇文章
高并发下如何保证接口的幂等性？幂等设计，都有哪些技术方案？ 二、订单快照，减少存储成本 商品信息是可以修改的，当用户下单后，为了更好解决后面可能存在的买卖纠纷，创建订单时会同步保存一份商品详情信息，称之为订单快照。
同一件商品，会有很多用户会购买，如果热销商品，短时间就会有上万的订单。如果每个订单都创建一份快照，存储成本太高。另外商品信息虽然支持修改，但毕竟是一个低频动作。我们可以理解成，大部分订单的商品快照信息都是一样的，除非下单时用户修改过。
如何实时识别修改动作是解决快照成本的关键所在。我们采用摘要比对的方法‍。创建订单时，先检查商品信息摘要是否已经存在，如果不存在，会创建快照记录。订单明细会关联商品的快照主键。
public class DigestTest { public static void encodeStr(String data) { String encodeS = DigestUtils.md5Hex(data); System.out.println(encodeS); } public static void main(String[] args) { String data = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10632c23b0a2212f9d64fd843eadca4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0d82a5db3bf7e129093aba9013ec36a/" rel="bookmark">
			[ACNOI2022]树上同色连通块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 题目背景
“我叫卷爷，职业是 O U Y E \sf OUYE OUYE 。就在 3 3 3 月 25 25 25 日那天，我坐在 O n e I n D a r k \sf OneInDark OneInDark 对面，看到 O n e I n D a r k \sf OneInDark OneInDark 因为写不完 T 3 T3 T3 正解而愤愤离去。毫无疑问，他就是 A K AK AK 疑案的凶手！”
“「反对」！ O n e I n D a r k \sf OneInDark OneInDark 当时的座位在你的对面，你不可能看到他的举动。你的证词是前后矛盾的！现在想来，能够在无人知晓的情况下悄悄 A K AK AK 的，必须是对学校管理了如指掌的高层，并且还要有充分的内卷能力。所以能够完成这起规模庞大的 A K AK AK 案的人只有一个——”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0d82a5db3bf7e129093aba9013ec36a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78c3768f0764e1c221f973f87ad34967/" rel="bookmark">
			阶段性成果--HoloCubic小电视与四轴飞控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HoloCubic小电视 开头感谢B站：一叶知秋君莫笑我（“保姆级教程：从0到1带你做稚晖君HoloCubic小电视”）与溜码小哥的资料包。
之前是看到关注的稚晖君开源了这个小电视，觉得非常有趣，想着自己也做一个。刚好上述两位up主在稚晖君开源的基础上更加详细与完善流程，我跟着他们的步骤也做了一个。如下：
因为资料包是别人的，所以这里我就不放了，大家想要这个的可以去B站找，也是开源的。
四轴飞控 在大学的时候只做过车，就一直想着自己要做一个四旋翼，奈何时间与计划冲突，就一直搁置到现在。但是之前一直保留着宏晶开源的四轴飞控资料，现在重新捡起来看看。
宏晶用的是STC8A8K16S4A12 LQFP44飞控板，虽然程序框架也有，但我想着先从简单点入手，就买了qq飞控 ；MPU -6050 陀螺仪MC6B遥控、接收机F450机架2122无刷电机30A电调3S电池B6平衡充扎带若干 在焊好电调后，插电测试单个电机油门，结果上来就给我烧掉了一个电机，其他的电机都是正常工作，怀疑连接电调焊板烧坏，无奈只能重新购买。
调试过程中最大的问题就是四轴不稳，电机转动不均衡，这里只能根据浆叶与电机轴连接松紧进行调试；下次换STC8A8K16S4A12 LQFP44飞控板尝试软件调节pwm的输出。
资料链接：https://download.csdn.net/download/qq_38168606/85045388
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e66e1f17201c176aa84ea833be5d71/" rel="bookmark">
			【Java语法解析】true，false与null是关键字吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 语法话题关键字分类结论语法解析 语法话题 本期的语法话题为：
true，false与null是关键字吗（保留关键字）？
关键字分类 从Java 17起，关键字分为两种：
保留关键字上下文关键字 其中，保留关键字指在Java 17前所定义的关键字，例如，if，class等。而上下文关键字指在特定的上下文环境中，会解析为特殊的含义，例如，var，record等。不过，像var，record在Java 17前就已经在使用（具有特殊的含义），只不过官方没有将其称为“上下文关键字”。
本话题中，我们提及的关键字，指的是保留关键字。
结论 在很多集成开发环境中，true，false，null往往使用特殊的颜色高亮显示，这便增加了这三个符号的混淆性，很多Java初学者会认为这三个符号也是关键字。然而，这是错误的。在Java语言中，这三个符号是三个字面常量值。其中，true与false是布尔类型的字面常量，null是引用类型的字面常量。这就好比“abc”是String类型的字面常量，数值“5”是int类型的字面常量一样。
语法解析 如此一来，这三个符号不是很平常了吗？似乎没有必要将其单独列出。也不是，还是有一些差别的。尽管true，false，null不是关键字，但是，也不能将其作为标识符使用，否则同样会产生编译错误。从这一点来说，这三个字面常量与关键字的表现是相似的。
至于true，false与null不能声明为标识符的原因，可以解释如下：
第一，从简单的角度讲，就像其他类型（例如int类型）的字面常量一样，我们不能将数值1或20声明为标识符，因而，也同样不能将布尔类型或引用类型的字面常量（true，false与null）声明为标识符。第二，从语法的角度讲，编译器在解析符号的时候，对于某一个符号T，如果T同时可以解析为标识符或者字面常量，则总是会解析为字面常量。因此，程序中只要出现true（false或null），则一定会解析为字面常量，而不是标识符。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/621b19d0b4e14c763087a7bf2b38b4e1/" rel="bookmark">
			（五）Python：Pandas中的Series
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本特征
创建
自动生成索引
自定义生成索引
使用
基本运算
数据对齐
基本特征 类似一维数组的对象由数据和索引组成有序定长的字典 创建 Series能创建出带有数据和索引的字典来，且索引（index）与值（value）之间相互独立。创建方法如下所示：
自动生成索引 Series能创建自动生成索引的字典，索引从0开始，代码如下所示：
import pandas as pd aSer = pd.Series([1, 2.0, 'a']) # 自带索引 print(aSer) print(aSer.values) # 输出值 print(aSer.index) # 输出键 运行结果如下所示：
生成自带索引的字典
0 1
1 2.0
2 a
dtype: object
值
[1 2.0 'a']
键，和range函数类似
RangeIndex(start=0, stop=3, step=1)
自定义生成索引 Series除了能创建自动生成索引的字典外，还能自定义生成索引，代码如下所示：
import pandas as pd bSer = pd.Series(['apple', 'peach', 'lemon'], index=[1, 2, 3]) # 指定索引 print(bSer) print(bSer.values) # 输出值 print(bSer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/621b19d0b4e14c763087a7bf2b38b4e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fb37deeb0e202f05d58e70ea60f18da/" rel="bookmark">
			解决hexo在服务器上成功运行后，4000端口无法访问的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：在服务器上成功安装了hexo，且运行起来了，但是始终无法访问4000端口。
[root@VM-4-16-centos myblog]# hexo g INFO Validating config INFO Start processing INFO Files loaded in 79 ms INFO 0 files generated in 22 ms [root@VM-4-16-centos myblog]# hexo server INFO Validating config INFO Start processing INFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop 输入hexo g 和hexo server 两个命令后，出现上述语句，说明hexo成功运行
这时候在浏览器里输入 xxx:4000(xxx为你服务器的公网ip)，如果出现下图的页面，则表示ok了
如果提示的是页面无法访问，可能是下面两个原因导致的。
1、服务器的4000端口被占用（hexo默认端口是4000）
2、服务器的4000端口没有对外开放。
解决方法：依次检查，先看4000端口是否被占用，输入lsof -i:4000命令
[root@VM-4-16-centos ~]# lsof -i:4000 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME hexo 243215 root 20u IPv6 1365432 0t0 TCP *:terabase (LISTEN) 上面显示的是正常的结果，4000端口被hexo占用，那么就排除了第一种可能，这时候可以考虑第二种情况。如果显示的不是hexo，而是别的应用，就说明4000端口被其他应用占用了，这时候就要给hexo换个端口。先终止hexo程序，然后输入hexo s -p xxxx（xxxx为指定的端口号）命令重新启动。启动完成后，再去查看页面是否显示正常。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fb37deeb0e202f05d58e70ea60f18da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/185f36ee3e9c98b4aa36b483a44dcc03/" rel="bookmark">
			docker/k8s容器优雅退出(python，go，java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全栈工程师开发手册 （作者：栾鹏）
架构系列文章
注意：docker 正常退出和异常退出都不会自动发起SIGTERM，java正常或异常退出，jvm会发起SIGTERM信号
docker kill 直接杀死容器进程
docker stop是向容器进程发送SIGTERM信号，本文介绍容器中的进程捕获 SIGTERM 信号，优雅的退出。
github地址：https://github.com/626626cdllp/k8s/tree/master/test/docker-signal
先来了解一下信号
SIGINT 程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。
SIGQUIT 和SIGINT类似, 但由QUIT字符(通常是Ctrl-)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号。
SIGTERM 程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell命令kill缺省产生这个信号。如果进程终止不了，我们才会尝试SIGKILL。
SIGSTOP 停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行. 本信号不能被阻塞, 处理或忽略.
添加退出处理逻辑 假设源dockerfile中定义的entrypoint为python /app/server.py
现在需要重新写一个脚本entrypoint.sh
#!/bin/sh # 实际运行的工作程序，将源主程序一般后台运行形势打开 nohup python /app/server.py &amp; # 中断信号处理函数，关闭python主程序 prog_exit() { ps -ef| grep python |grep -v grep |awk '{print $2}'|xargs kill -15 } # 注册中断处理函数 trap "prog_exit" 15 flag=1 # 前端形式运行睡眠，并交叉是否可以退出（python进程已不存在，也能在python进程自己退出的情况下关闭容器） while [ $flag -ne 0 ];do sleep 3; flag=`ps -ef| grep atm |grep -v grep | wc -l` done; 然后将dockerfile中的entrypoint改成启动新的脚本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/185f36ee3e9c98b4aa36b483a44dcc03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64854379a6f411e9fc140df363b7dac9/" rel="bookmark">
			[Python]同一目录下导入不同文件IDE报错却能正常执行的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天看代码的时候，发现IDEA报错了，但是代码却可以正常执行，改正错误后却反而 run 报错
如下图，执行 main.py 运行程序
在 ./loss/loss.py 中调用与 loss.py 同一目录下的 discriminator.py 时
如果在 loss.py 中使用 from loss import discriminator IDEA 会报错，可是运行 main.py 正常运行。
如果在 loss.py 中使用 import discriminator IDEA 不报错，可是运行 main.py 会报找不到 discriminator.py 模块。
这是因为，在我们执行 import 时，当前目录是不会变的（就算是执行子目录的文件），还是需要完整的包名。而这里我们所执行的是 main.py ，所以当前目录会一直保持 main.py 的当前目录，当执行 loss.py 时，当前目录还是 main.py 时的目录。故需要通过 from loss import discriminator 导入 discriminator.py 。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e0306b1b2cf2c4f936024d0d5d25709/" rel="bookmark">
			vim显示空格和tab符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		:set list TAB 键显示为 ^I, $显示在每行的结尾,表示换行；空格仍然显示为空格。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c571c889cbdf70a8db5c531c0baeda/" rel="bookmark">
			Tomcat服务器的安装和启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 安装一、从Tomcat官网下载解压二、Tomcat启动1.启动2.诊断 总结 安装 提示：这里可以添加本文要记录的大概内容：
目前Tomcat的最新版本是Tomcat 10.1。
这里介绍安装的Tomcat版本是Tomcat 8.5，其他版本的安装流程也差不多。
注意：再安装Tomcat之前需要安装JDK，运行Tomcat 8.5建议使用JDK 8版本，由于篇幅有限，关于JDK的安装就不再详细介绍。
提示：以下是本篇文章正文内容，下面案例可供参考
一、从Tomcat官网下载解压 这里建议下载ZIP压缩包，然后解压安装Tmocat。
官网网址：https://tomcat.apache.org/
官网页面的Download下面选择相应的版本，滑倒页面底下选择zip压缩包进行下载。
下载完成后，直接解压到指定的目录便可完成Tomcat的安装。也可以解压到D盘。
二、Tomcat启动 1.启动 1.1 打开解压后的Tomcat文件夹，里面包含一系列的子目录
1.2 打开bin目录，其中startup.bat是启动Tomcat的脚本文件，如下图所示。双击startup.bat文件，便会启动Tomcat服务器。
1.3 启动后，可以在弹出的命令行看到一些启动信息，如下图所示
1.4 在浏览器的地址栏中输入http://localhost:8080/或者http://127.0.0.1:8080(localhost和127.0.0.1都表示本地计算机)访问Tomcat服务器，如果浏览器中的显示页面如下图所示，则说明Tomcat服务器安装成功了。
2.诊断 如果双击startup.bat文件时Tomcat没有正常启动，而是一闪而过，说明Tomcat的启动发生了意外。
在这种情况下，因为无法查看到错误信息，所以无法对Tomcat进行诊断，分析出错原因。这时，可以先启动一个命令行窗口cmd，在这个命令行窗口中，将目录切换到Tomcat安装目录中的bin目录，然后执行startup.bat命令，就会看到错误提示信息，如下图所示。
可以看到错误提示为JRE_HOME环境变量配置不正确。
解决方法：配置好环境
新建，添加 %JAVA_HOME%\bin; 环境即可，环境配置成功之后再启动Tomcat，就能正常启动了。
总结 这里仅仅对新手而言的教程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98de6cdef0a7abad62865466401ac8f5/" rel="bookmark">
			CSS复合选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、CSS复合选择器
（1）交集选择器
（2）并集选择器 (群组选择器)
（3）兄弟选择器
（4）后代选择器
（5）子元素选择器
测试题
（6）属性选择器
（7）伪元素选择器（CSS3新增）
E::first-letter 块级文本的第一个单词或字（用于中日韩CJK）
E::first-line 块级文本的第一行
E::selection 可改变选中文本的样式 （行内文本也可以）
E::before和E::after 一、CSS复合选择器 复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的，目的是为了可以选择更准确更精细的目标元素标签。
（1）交集选择器 交集选择器由两个选择器构成，其中第一个为标签选择器，第二个为class选择器或者id选择器，两个选择器之间不能有空格，如h1.red。
记忆技巧：交集选择器是并且的意思，即...又...的意思
注意点：
1、选择器之间没有任何的连接符号
2、选择器可以是class， 也可以是id，也可以是伪类选择器，还可以是标签，但标签要放在前面
比如： p.one 表示选择类名既是.one 且是段落标签。
&lt;p class="red"&gt;段落1&lt;/p&gt; &lt;p id="pink"&gt;段落2&lt;/p&gt; &lt;p class="red" id="pink"&gt;段落3&lt;/p&gt; &lt;style type="text/css"&gt; p.red { color: red; } p#pink { color: pink; } .red#pink { color: blue; } &lt;/style&gt; （2）并集选择器 (群组选择器) 并集选择器是各个选择器通过逗号连接而成的，任何形式的选择器，都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相同，或部分相同，就可以使用并集选择器。
记忆技巧：
并集选择器表示 和 的意思，只要使用逗号分隔，所有选择器都会执行后面的样式。
比如： p.on#ide, .one, p, #id {color:red;} 表示.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98de6cdef0a7abad62865466401ac8f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dbf30c69babaf384a3c175e488f28c4/" rel="bookmark">
			nginx安装SSL证书以及反向代理tomcat问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前情提要 nginx开启SSL模块教程：Nginx安装SSL证书前需要开启SSL模块
nginx安装SSL证书教程：腾讯云Nginx服务器SSL证书安装部署
一、tomcat没有安装SSL证书，但是想通过Https协议访问tomcat 此处使用的就是nginx的反向代理，本质上我们访问tomcat还是使用http协议，但我们通过nginx的反向代理，会先通过Https协议访问nginx，然后再通过nginx将Https请求转发为http请求发送给tomcat服务器。相当于加了一层请求转发，这也让我们可以不在tomcat上安装ssl证书就可以通过https协议访问tomcat。多集群下，nginx也支持负载均衡，所以我们通常是在nginx上安装SSL证书。
反向代理看着复杂，但其实只需要在nginx.conf上配置以下，具体看以下配置：
假定你的服务器地址为127.0.0.1；看到127.0.0.1就填你自己服务器的ip地址，看到8080就填你tomcat服务器的端口号。
【地理路径地址】:例如你想让 https://127.0.0.1/test 这个路径代理tomcat服务器，那么此处就填写/test。
【tomcat项目地址】：首先你要确定你所要代理的tomcat项目，然后在此处填写 https://127.0.0.1:8080/项目名 server { 。。。。。。。 location [代理路径地址] { proxy_pass [tomcat项目地址]; proxy_http_version 1.1; proxy_set_header X-Forwarded-Proto https; #配置报文转发协议为https proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header Cookie $http_cookie; proxy_connect_timeout 30; proxy_set_header Referer $http_referer; proxy_cookie_path [/项目名] [代理路径地址]; #保证https和http的cookie一致 } } proxy_cookie_path介绍：proxy_cookie_path详细介绍
二、nginx安装SSL证书后，反向代理https请求不携带cookie的问题 首先这个问题，有好几个方面的影响，其中一个环节出问题，就都会出问题，所以请耐心看下去，我会尽量讲清楚。
1.nginx安装SSL证书后，其中的项目如果ajax或axios发送http请求会出现(已屏蔽:mixed-content)的情况，F12控制台会显示 解决办法：通过nginx反向代理tomcat，使所有请求都变成https请求，就不会出现此错误。
2.反向代理配置问题 如果你是按照我上面的反向代理的配置，那就不会出现问题，主要是要配置
proxy_set_header Cookie $http_cookie; proxy_cookie_path [/项目名] [代理路径地址]; #保证https和http的cookie一致
这两项。
3.例：前后端分离，前端Vue，后端SSM（所以推荐前后端分离项目使用token） Vue中axios是默认不带cookie的，所以要在main.js中添加代码如下：
import axios from 'axios';#如果有就不要加了 axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dbf30c69babaf384a3c175e488f28c4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/251/">«</a>
	<span class="pagination__item pagination__item--current">252/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/253/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>