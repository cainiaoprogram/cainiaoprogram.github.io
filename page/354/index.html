<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2709545cd59531fcc25ddc206cb3178e/" rel="bookmark">
			Linux 系统黑洞 /dev/null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是 Linux 系统黑洞？
/dev/null 代表 Linux 的空设备文件，所有往这个文件里面写入的内容都会丢失，俗称“黑洞”。
二、Linux 的输入输出
Linux 定义了一个标准输入和两个输出：
标准输入0：从键盘获得输入 /proc/self/fd/0标准输出1：输出到屏幕（即控制台） /proc/self/fd/1错误输出2：输出到屏幕（即控制台） /proc/self/fd/2 三、"黑洞"的使用
有时候生成的日志文件没有利用价值，就可以全部丢到"黑洞"里
1.最直白、最简单、最易懂示例1：
java -classpath log-collector-1.0-SNAPSHOT.jar com.atguigu.appclient.AppMain 1&gt;/dev/null 2&gt;/dev/null
这样，标准输出1 和错误输出2 就都丢到"黑洞"里了。
2.进化版示例2：java -classpath log-collector-1.0-SNAPSHOT.jar com.atguigu.appclient.AppMain &gt;/dev/null 2&gt;&amp;1
这里标准输出1 省略了 "1" ,把错误输出2丢到了1里，顺序就是 2 — 1 — 黑洞
3.企业抽象版示例3：java -classpath log-collector-1.0-SNAPSHOT.jar com.atguigu.appclient.AppMain &gt;/dev/null 2&gt;&amp;1 &amp;
这里最后加了个 "&amp;" ，表示在后台执行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a89b7b297f7a71aee6ec148c50d4e6e1/" rel="bookmark">
			vue实现列表的无缝滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在有无缝滚动的需求的时候我第一时间想的是轮播图，但是想弄一个列表那种的效果，轮播图就实现的就只能自己写个表头，这样用户体验不好，这里经过我自己使用，不管是兼容还是跨浏览器（版本较高）都是可以的，这里使用 插件 vue-seamless-scroll来实现的 1、演示地址：入口 2、git源码地址 入口 目录
1、演示地址：入口
2、git源码地址 入口
实现效果：鼠标滑入静止
实现步骤：
一、下载插件
二、在main.js文件里引用
三、封装scroll.vue
注意：1、这里有三张图片，是背景图左右两边的颜色，
2、我这里的li 清一色用的span，因为用p标签报错，未找到原因，注意
源码：
四、常用配置参数如下表：
五、更多有关资料
1、https://blog.csdn.net/qq_34448522/article/details/104387978
2、https://www.jianshu.com/p/d747dd8ba26d 这个人家里面li &gt; div/p 我这里没有实现，只用了span
实现效果：鼠标滑入静止 实现步骤： 一、下载插件 cnpm i --s vue-seamless-scroll 二、在main.js文件里引用 import scroll from 'vue-seamless-scroll' Vue.use(scroll) 按需引入也是可以的
三、封装scroll.vue 注意：1、这里有三张图片，是背景图左右两边的颜色， 2、我这里的li 清一色用的span，因为用p标签报错，未找到原因，注意 源码： &lt;template&gt; &lt;vue-seamless-scroll :data="List" class="seamless-warp" :class-option="classOption"&gt; &lt;ul&gt; &lt;li class="Carousel_li" v-for="(item,index) in List" :class="[{'pro_1':item.title=='1'},{'pro_2':item.title=='2'},{'pro_3':item.title=='3'}]" :key="index"&gt; &lt;span class="title" v-if="item.title=='1'"&gt;已完成&lt;/span&gt; &lt;span class="title" v-if="item.title=='2'"&gt;进行中&lt;/span&gt; &lt;span class="title" v-if="item.title=='3'"&gt;未开始&lt;/span&gt; &lt;span :title="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a89b7b297f7a71aee6ec148c50d4e6e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abbbb2c9fedd92c21dba71d04651ae7a/" rel="bookmark">
			车型数据2019年12月（品牌、车系、车辆信息）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好多人都在找车辆信息相关的数据，今天和大家分享一下汽车之家的汽车数据，最新是2019-12-25的数据，不多说了，直接上接口地址：
汽车数据接口地址：http://tool.bitefu.net/showdoc/web/#/4?page_id=5
获取所有品牌：http://tool.bitefu.net/car/?type=brand&amp;from=[0|1|2|…]&amp;pagesize=300
获取所有车系：http://tool.bitefu.net/car/?type=series&amp;from=[0|1|2|…]&amp;pagesize=300
获取所有厂家：http://tool.bitefu.net/car/?type=series_group&amp;from=[0|1|2|…]&amp;pagesize=300
获取所有车型：http://tool.bitefu.net/car/?type=info&amp;from=[0|1|2|…]&amp;pagesize=300
获取所有车型年份：http://tool.bitefu.net/car/?type=infoyear&amp;from=[0|1|2|…]&amp;pagesize=300
获取车型详情：http://tool.bitefu.net/car/?type=detail&amp;from=1&amp;id=125811
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6cf954c299f22fc7a6b63b8cc5ff0df/" rel="bookmark">
			mac键盘上符号的快捷键_Mac键盘符号实际上是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac键盘上符号的快捷键
Macs are supposed to be intuitive, but a few things are downright hidden from users. For example: in the menu bar, the keyboard shortcuts for various actions are laid out using somewhat confusing symbols.
Mac应该是直观的，但是用户看不到一些东西。 例如：在菜单栏中，使用有些混乱的符号来布置各种动作的键盘快捷键。 箭头，弯曲和其他符号的含义 (What the Arrow, Squiggly, and Other Symbols Mean) You might know that “⌘” corresponds to the Command key, since it actually appears on the keyboard key. But what’s the difference between “⌃” and “⇧,” both basically up arrows?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6cf954c299f22fc7a6b63b8cc5ff0df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa7fb7cb52c439f65bc1b06fabb8d4f/" rel="bookmark">
			spring security获取用户信息为null或者串值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在spring security，用SecurityContextHolder.getContext().getAuthentication().getPrincipal()获取登录用户的信息，发现获取到的用户有串值现象——获取用户信息，发现获取到的是别人的信息，偶发性还有取值为null的情况。经同事提醒，是不是用了多线程，查到了问题的原因。
//原代码 ExecutorService executorService = Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat("job").build()); executorService.execute(() -&gt; { //获取用户对象 LoginUserDetails userDetails = (LoginUserDetails)SecurityContextHolder.getContext() .getAuthentication().getPrincipal(); }); //改进后 ExecutorService executorService = Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat("job").build()); SecurityContext securityContext = SecurityContextHolder.getContext(); executorService.execute(() -&gt; { //把context设置进去 SecurityContextHolder.setContext(securityContext); //获取用户对象 LoginUserDetails userDetails = (LoginUserDetails)SecurityContextHolder.getContext() .getAuthentication().getPrincipal(); }); 源码：
ThreadLocal是线程独有的局部变量，只针对当前线程，当前代码里使用了嵌套线程，子线程里的SecurityContext和父线程里的SecurityContext不是同一个，需要从父线程把SecurityContext传入到子线程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bcbbcd9b0c5457d56298d9274f14040/" rel="bookmark">
			Java8新特性-Stream流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客
https://www.cnblogs.com/CarpenterLee/p/6545321.html https://www.cnblogs.com/CarpenterLee/p/6550212.html
https://zhuanlan.zhihu.com/p/92976229
前两篇是很仔细的原理和用法，很好！
写在最前面： stream并不是某种数据结构，它只是数据源的一种视图。这里的数据源可以是一个数组，Java容器或I/O channel等。正因如此要得到一个stream通常不会手动创建，而是调用对应的工具方法，比如： 调用Collection.stream()或者Collection.parallelStream()方法调用Arrays.stream(T[] array)方法 1.Filter //函数原型为Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) //作用是过滤出满足predicate条件的元素 List&lt;String&gt; strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl"); // 获取空字符串的数量 long count = strings.stream().filter(string -&gt; string.isEmpty()).count(); // 2 调用filter()Stream流中元素就剩下了符合要求的元素，可以继续对这些元素进行操作。
2.Sorted //函数原型为Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为Stream&lt;T&gt;　sorted()和Stream&lt;T&gt;　sorted(Comparator&lt;? super T&gt; comparator) //作用是对列表中的元素排序。 List&lt;String&gt; myList = Arrays.asList("1", "2", "3"); myList.stream() .sorted(Comparator.comparingInt(Integer::parseInt)) .forEach(System.out::println); list.forEach(System.out::println); //这行代码就是下行代码 list.forEach(x-&gt;{ System.out.println(x); }); //1.foreach支持函数式编程。 //2.println是System.out的一个方法，所以可以使用此种方式 3.map 函数原型为&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bcbbcd9b0c5457d56298d9274f14040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/163c7df877aa6c85a4d852df366ab956/" rel="bookmark">
			线程状态-线程休眠 sleep
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import java.text.SimpleDateFormat; import java.util.Date; //模拟网络延时 public class TestSleep { public static void main(String[] args) { //打印当前系统时间 Date starTime = new Date(System.currentTimeMillis());//获取系统当前时间 while (true){ try { Thread.sleep(1000); System.out.println(new SimpleDateFormat("HH:mm:ss").format(starTime)); starTime = new Date(System.currentTimeMillis());//更新当前时间 } catch (InterruptedException e) { e.printStackTrace(); } } } //模拟倒计时 public static void tenDown() throws InterruptedException { int num = 10; while(true){ Thread.sleep(1000); System.out.println(num--); if (num&lt;=0){ break; } } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b29eff720b8c9c4ef03e24c69687cc/" rel="bookmark">
			element-ui input输入框限制输入数字类型 或小数点的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、正确的解决方案
&lt;el-input style="width:200px;" v-model="relationForm.fee" oninput="value=value.replace(/[^0-9.]/g,'')" :placeholder="代理费" &gt;&lt;/el-input&gt; 可以输入数字和小数点
oninput =“value=value.replace(/[^\d]/g,’’)” //只能输入数字
oninput =“value=value.replace(/[^0-9.]/g,’’)” //只能输入数字和小数
2、错误的解决方案
&lt;el-input style="width:200px;" v-model.number="relationForm.fee" type='number' :placeholder="代理费" &gt;&lt;/el-input&gt; 这种，是只能输入数字类型 但是 1.05这种是输入不进去的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f09b7c1aa57c1c034f498c387a963d07/" rel="bookmark">
			为什么mysql中不应该使用utf8编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么mysql中不应该使用utf8编码 因为MySQL的utf8编码最多只能够存储3个字节的字符，而一般的utf8编码能够存储4个字节的字符。
也就是说对于中文他应该能够正常存储，但是对于一些需要占用4个字节的字符他就不能够处理了，例如emjoy符号。
虽然最多只能表示3个字节的utf8在一般的场景下并没有什么问题，但是最好还是避免使用mysql的utf8而使用utf8mb4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ca4f606af3e13132e764a1ac56ee01c/" rel="bookmark">
			mysql8.0更改lower_case_table_names
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql8.0更改lower_case_table_names
mysql8.0安装初始化之后是不能更改lower_case_table_names的
下面是官方文档的一段话：
In MySQL 8.0, the lower_case_table_names variable can only be configured when the MySQL server is initialized.
解决方法：
方法一：在初始化的时候就要设置好这个变量的值
方法二：删除数据目录，重新初始化
（1）删除数据目录datadir=/usr/local/mysql/data
rm -rf /usr/local/mysql/data
（2）在配置文件中[mysqld]下添加lower_case_table_names = 1
vim /etc/my.cnf [mysqld] basedir=/usr/local/mysql # 基本路径 datadir=/usr/local/mysql/data #数据路径 （先在/usr/local/mysql建data目录） socket=/usr/local/mysql/data/mysql.sock # socket文件 symbolic-links=0 log-error=/usr/local/mysql/data/mysqld.log #错误日志 pid-file=/usr/local/mysql/data/mysqld.pid #pid文件 **lower_case_table_names = 1** **#添加这行** [mysql] socket=/usr/local/mysql/data/mysql.sock [mysqldump] socket=/usr/local/mysql/data/mysql.sock （3）执行初始化命令
/usr/local/mysql/bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --lower-case-table-names=1
（4）检查变量的值
跳过授权表启动
mysqld_safe --defaults-file=/etc/my.cnf --skip-grant-tables &amp; 免密登录
mysql -uroot -p 不需要输入密码直接回车 show variables like '%lower_case_table_names%'; 修改密码等操作，请参考
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ca4f606af3e13132e764a1ac56ee01c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cff0a90dbde6cf787875e0c0006c980a/" rel="bookmark">
			java注解-最通俗易懂的讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Annotation 中文译过来就是注解、标释的意思，在 Java 中注解是一个很重要的知识点，但经常还是有点让新手不容易理解。
我个人认为，比较糟糕的技术文档主要特征之一就是：用专业名词来介绍专业名词。
比如：
Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。
这是大多数网站上对于 Java 注解，解释确实正确，但是说实在话，我第一次学习的时候，头脑一片空白。这什么跟什么啊？听了像没有听一样。因为概念太过于抽象，所以初学者实在是比较吃力才能够理解，然后随着自己开发过程中不断地强化练习，才会慢慢对它形成正确的认识。
我在写这篇文章的时候，我就在思考。如何让自己或者让读者能够比较直观地认识注解这个概念？是要去官方文档上翻译说明吗？我马上否定了这个答案。
后来，我想到了一样东西————墨水，墨水可以挥发、可以有不同的颜色，用来解释注解正好。
不过，我继续发散思维后，想到了一样东西能够更好地代替墨水，那就是印章。印章可以沾上不同的墨水或者印泥，可以定制印章的文字或者图案，如果愿意它也可以被戳到你任何想戳的物体表面。
但是，我再继续发散思维后，又想到一样东西能够更好地代替印章，那就是标签。标签是一张便利纸，标签上的内容可以自由定义。常见的如货架上的商品价格标签、图书馆中的书本编码标签、实验室中化学材料的名称类别标签等等。
并且，往抽象地说，标签并不一定是一张纸，它可以是对人和事物的属性评价。也就是说，标签具备对于抽象事物的解释。
所以，基于如此，我完成了自我的知识认知升级，我决定用标签来解释注解。 注解如同标签 之前某新闻客户端的评论有盖楼的习惯，于是 “乔布斯重新定义了手机、罗永浩重新定义了傻X” 就经常极为工整地出现在了评论楼层中，并且广大网友在相当长的一段时间内对于这种行为乐此不疲。这其实就是等同于贴标签的行为。
在某些网友眼中，罗永浩就成了傻X的代名词。
广大网友给罗永浩贴了一个名为“傻x”的标签，他们并不真正了解罗永浩，不知道他当教师、砸冰箱、办博客的壮举，但是因为“傻x”这样的标签存在，这有助于他们直接快速地对罗永浩这个人做出评价，然后基于此，罗永浩就可以成为茶余饭后的谈资，这就是标签的力量。
而在网络的另一边，老罗靠他的人格魅力自然收获一大批忠实的拥泵，他们对于老罗贴的又是另一种标签。 老罗还是老罗，但是由于人们对于它贴上的标签不同，所以造成对于他的看法大相径庭，不喜欢他的人整天在网络上评论抨击嘲讽，而崇拜欣赏他的人则会愿意挣钱购买锤子手机的发布会门票。 我无意于评价这两种行为，我再引个例子。
《奇葩说》是近年网络上非常火热的辩论节目，其中辩手陈铭被另外一个辩手马薇薇攻击说是————“站在宇宙中心呼唤爱”，然后贴上了一个大大的标签————“鸡汤男”，自此以后，观众再看到陈铭的时候，首先映入脑海中便是“鸡汤男”三个大字，其实本身而言陈铭非常优秀，为人师表、作风正派、谈吐举止得体，但是在网络中，因为娱乐至上的环境所致，人们更愿意以娱乐的心态来认知一切，于是“鸡汤男”就如陈铭自己所说成了一个撕不了的标签。
我们可以抽象概括一下，标签是对事物行为的某些角度的评价与解释。
到这里，终于可以引出本文的主角注解了。
初学者可以这样理解注解：想像代码具有生命，注解就是对于代码中某些鲜活个体的贴上去的一张标签。简化来讲，注解如同一张标签。
在未开始学习任何注解具体语法而言，你可以把注解看成一张标签。这有助于你快速地理解它的大致作用。如果初学者在学习过程有大脑放空的时候，请不要慌张，对自己说：
注解，标签。注解，标签。
注解语法 因为平常开发少见，相信有不少的人员会认为注解的地位不高。其实同 classs 和 interface 一样，注解也属于一种类型。它是在 Java SE 5.0 版本中开始引入的概念。
注解的定义 注解通过 @interface 关键字进行定义。
public @interface TestAnnotation {
}
1 它的形式跟接口很类似，不过前面多了一个 @ 符号。上面的代码就创建了一个名字为 TestAnnotaion 的注解。
你可以简单理解为创建了一张名字为 TestAnnotation 的标签。
注解的应用 上面创建了一个注解，那么注解的的使用方法是什么呢。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cff0a90dbde6cf787875e0c0006c980a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409e180905e746eac69e9bffd850fe29/" rel="bookmark">
			小程序常用的9个框架总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要开发出一套高质量的小程序，运用框架，组件库是省时省力省心必不可少一部分，随着小程序日渐火爆，各种不同类型的小程序也渐渐更新，其中不乏一些优秀好用的框架/组件库。
####1：WeUI 小程序–使用教程
https://weui.io/
官方介绍：WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。小程序开发中最常用到的一款框架，受广大开发人员的欢迎。
####2：美团小程序框架mpvue
Github：https://github.com/Meituan-Dianping/mpvue
官网： http://mpvue.com/
官方介绍：mpvue是一个使用 Vue.js开发小程序的前端框架。框架基于 Vue.js核心，mpvue修改了 Vue.js的 runtime和 compiler实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套Vue.js开发体验。
####3：组件化开发框架wepy
Github地址:
https://github.com/Tencent/wepy
官网地址：
https://tencent.github.io/wepy
官方介绍：组件化开发，完美解决组件隔离，组件嵌套，组件通信等问题,支持使用第三方 npm 资源，自动处理 npm 资源之间的依赖关系，完美兼容所有无平台依赖的 npm 资源包.
####4：官方框架MINA
地址：https://developers.weixin.qq.com/miniprogram/dev/framework/MINA.html
官方介绍：框架提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。
####5：Tina.js 一款轻巧的渐进式微信小程序框架
Tina.js 开源框架地址： https://github.com/tinajs/tina
官方介绍：是一款轻巧的渐进式微信小程序框架，保留 MINA (微信小程序官方框架) 的大部分 API 设计；无论你有无小程序开发经验，都可以轻松过渡上手。
####6：前端框架weweb
地址: https://github.com/wdfe/weweb
官方介绍：weweb是一个兼容小程序语法的前端框架，你可以用小程序的写法，来写web应用。如果你已经有小程序了，通过它你可以将你的小程序运行在浏览器中。
####7：微信UI组件库 iView Weapp
https://weapp.iviewui.com/
介绍：iView Weapp 提供了与 iView 一致的 UI 和尽可能相同的接口名称，大幅度降低了学习成本，是一套一套高质量的微信小程序 UI 组件库。
####8：ZanUI-WeApp – 一个颜值高、好用、易扩展的微信小程序 UI 库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/409e180905e746eac69e9bffd850fe29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a0bd89c07b47236c1681da20c8e3dc4/" rel="bookmark">
			RpcResponse byte[] is null, xxl-job项目问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在用定时任务xxl-job定时框架,在idea上运行好好的，打war包在tomcat下admin中心注册项目却爆出 RpcResponse byte[] is null的错误。
问题原因： 1如果是tomcat部署的话,查看你自己项目配置admin的地址是否有问题:带上了admin项目的名字。
2.如果是springboot项目的话,同理看下你项目启动是否配置了根目录。
这样的话admin注册地址就变成了
http://127.0.0.1:8080/xxl-job-admin/xxl-job-admin 所以就会爆出 RpcResponse byte[] is null的问题。
解决办法： 去掉后面多余的项目路径,例如：
xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin 改成 xxl.job.admin.addresses=http://127.0.0.1:8080 当然这个要看你具体配置而定，主要原因就是项目目录的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69c5415fa14b2683de9f6c2a49f99c77/" rel="bookmark">
			基于Spark的电影推荐系统（包含爬虫项目、web网站、后台管理系统以及spark推荐系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、爬虫 开发环境： pycharm + python3.6
软件架构： mysql + scrapy
运行环境： 本次爬取的内容在外网，所以需先翻墙后才能成功运行。
项目架构：
二、电影网站 开发环境： IntelliJ IDEA + maven + git + linux + powerdesigner
软件架构： mysql + mybatis + spring + springmvc
项目描述： 懂你电影推荐网站是一个基于SSM框架的web项目，类似当前比较流行的豆瓣。用户可以在网站上浏览电影信息和查询电影，并且网站会根据用户的浏览记录给用户进行实时的电影推荐。现已将网站部署在 http://115.159.204.68网站上，感兴趣的朋友可以自行查看。Git的安装与IDEA和github的集成可以参考博客。
项目架构：
网站展示：
三、后台管理系统 开发环境： IntelliJ IDEA + maven + git + linux + powerdesigner
软件架构： mysql + mybatis + spring + springmvc + easyui
项目描述： 后台管理系统主要对用户信息和电影信息进行管理，如添加删除电影信息和完成用户信息的完善。其中为了更好地保存电影的图片信息，搭建了图片服务器，关于图片服务器FastDFS的搭建可参考博客。后台系统也布置在服务器上，感兴趣的朋友可以通过地址 http://115.159.204.68:8080/ 访问，为大家提供的测试账号为 test，密码为88888888。
项目架构：
网站展示：
四、推荐系统（Spark） 开发环境： IntelliJ IDEA + maven + git + linux
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69c5415fa14b2683de9f6c2a49f99c77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7a2cb5ebaa7eb3077de1fb3d4bfb522/" rel="bookmark">
			java fork/join概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 从JDK1.7开始，Java提供ForkJoin框架用于并行执行任务，它的思想就是基于“分治”，它将一个大任务分解（Fork）成一系列子任务，子任务可以继续往下分解，当多个不同的子任务都执行完成后，可以将它们各自的结果合并（Join）成一个大结果，最终合并成大任务的结果：
使用示例 ForkJoinTask的抽象方法exec由RecursiveAction和RecursiveTask实现，很容易看出RecursiveAction和RecursiveTask的区别，前者没有result。
private static class SumTask extends RecursiveTask&lt;Integer&gt; { private static final int THRESHOLD = 20; private int arr[]; private int start; private int end; public SumTask(int[] arr, int start, int end) { this.arr = arr; this.start = start; this.end = end; } /** * 小计 */ private Integer subtotal() { Integer sum = 0; for (int i = start; i &lt; end; i++) { sum += arr[i]; } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7a2cb5ebaa7eb3077de1fb3d4bfb522/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/665b1c5a714ec3956c63680d93ec9a90/" rel="bookmark">
			azure 安全组_扩展Azure安全功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		azure 安全组
As more organizations are delivering innovation faster by moving their businesses to the cloud, increased security is critically important for every industry. Azure has built-in security controls across data, applications, compute, networking, identity, threat protection, and security management so you can customize protection and integrate partner solutions. 随着越来越多的组织通过将业务转移到云中来更快地交付创新，提高安全性对于每个行业都至关重要。 Azure具有跨数据，应用程序，计算，网络，身份，威胁保护和安全管理的内置安全控件，因此您可以自定义保护并集成合作伙伴解决方案。 We keep investing in security and we are excited to share exciting updates this week at Hannover Messe 2019.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/665b1c5a714ec3956c63680d93ec9a90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b5b5e3ff41c72c689cf261d22d24cc/" rel="bookmark">
			对Jenkinsfile语法说不，开源项目Jenkins Json Build挺你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对Jenkinsfile语法说不，开源项目Jenkins Json Build挺你 项目背景 我所在的组织项目数量众多，使用的语言和框架也很多，比如Java、ReactNative、C# .NET、Android、iOS等，部署环境也是多种多样比如Tomcat、K8S、IIS、客户端应用是局域网内企业证书安装等，我们没有专门的配置管理员或构建部署专员，都是开发人员自己在Jenkins中写构建脚本，每个项目都有自己的构建脚本（Scripted Pipelines），但类型相同的项目比如都是Java或都是.NET项目之间，构建脚本其实都很类似，都是靠几个已存在的构建脚本改写出来的，其实开发人员对编写Jenkins构建脚本了解也不多，另外因为没有规则和约束，更没有代码复用的机制，构建部署工作很混乱和难以管理。
项目解决的问题 在上述情况下我们开发了Jenkins-Json-Build项目,该项目适合于有一些编程经验的人员在不需要了解Jenkins构建脚本如何编写的情况下，通过简单的配置Json文件，就可以轻松完成一个项目的获取源码、单元测试、代码检查、编译构建、部署等步骤，实现一个典型的CI过程，又因为此项目使用了Jenkins共享类库（Shared Libraries）机制，构建脚本复用率得到了大幅度提高，并且开发人员可以方便的扩展更多的功能，满足不同构建部署场景的需要，此项目非常适合那些开发人员自己管理构建部署的团队，通过Jenkins-Json-Build项目组织对构建部署过程进行了统一的管理和监督，又让每个项目有足够的灵活性和自主权满足各自项目构建部署的特殊性。
一个Java项目构建示例 构建服务器上需要安装的软件 构建服务器上需要安装Java、Maven和Sonar-Scanner（此项可选）。
JAVA安装Maven安装Sonar-Scanner 构建需要依赖的Jenkins插件 JUnitJaCoCo Jenkinsfile文件内容 因为采用pipeline script from SCM构建方式，所以用Declarative Pipeline方式在Jenkinsfile中编写构建脚本：
@Library('shared-library') _ pipeline { agent any parameters { //定义构建参数 choice choices: ['-'], description: '请选择部署方式', name: 'deploy-choice' } stages { stage('初始化') { steps { script{ //加载源码仓库根目录下的jenkins-project.json构建配置文件 runWrapper.loadJSON('/jenkins-project.json') runWrapper.runSteps('初始化') } } } stage('单元测试') { steps { script{ //执行单元测试步骤 runWrapper.runSteps('单元测试') } } } stage('代码检查') { steps { script{ //执行代码检查步骤，比如SonarQube runWrapper.runSteps('代码检查') } } } stage('编译构建') { steps { script{ //执行编译步骤 runWrapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08b5b5e3ff41c72c689cf261d22d24cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0021dc4f1f3c5e2244debe86403e7400/" rel="bookmark">
			如何在独显电脑上让PotPlayer输出5.1声道音频到JBL CINEMA 615音响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在独显电脑上让PotPlayer输出5.1声道音频到JBL CINEMA 615音响，Pass Through播放DTS 安装PotPlayer播放器和LAV解码器音频设置LAV设置效果展示 一套音响买了半年才找到设置方法，太难了。但是，JBL大法好。 安装PotPlayer播放器和LAV解码器 参考了 https://vcb-s.com/archives/7228
音频设置 打开视频-右键-声音-声音输出设置，如图设置
LAV设置 点击任务栏右下角蓝色LAV Audio Decoder ,如图设置
效果展示 JBL 615 通过HDML接在 GTX 1660Ti上，完美输出六声道（5.1）音频.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39be59fd173878d16bf295c37195ee72/" rel="bookmark">
			《A Comprehensive Survey on Transfer Learning》论文解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A Comprehensive Survey on Transfer Learning 作者：
Fuzhen Zhuang, Zhiyuan Qi, Keyu Duan, Dongbo Xi, Yongchun Zhu, Hengshu Zhu, SeniorMember, IEEE, Hui Xiong, Fellow, IEEE, and Qing He
下载地址：https://arxiv.org/abs/1911.02685
abstract 目的：是通过迁移不同但相关的源域所包含的知识，提高目标学习器在目标域上的学习性能。
好处：在构建目标学习器时可以减少对大量目标域数据的依赖。
前景：迁移学习由于其广阔的应用前景，已成为机器学习中一个热门且有发展前景的领域。
本文贡献：本文试图对已有的迁移学习进行调研，对迁移学习的机制和策略进行全面的总结和阐释，有助于读者更好地了解迁移学习的研究现状和思路。本论文从数据和模型的角度回顾了40多种有代表性的迁移学习方法，特别是同质迁移学习方法 ( h o m o g e n e o u s t r a n s f e r l e a r n i n g ) (homogeneous \quad transfer \quad learning) (homogeneoustransferlearning)。并简要介绍了迁移学习的应用。为了展示不同迁移学习模型的性能，我们使用了20多个有代表性的迁移学习模型进行了实验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39be59fd173878d16bf295c37195ee72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d1bac9c5aff3ae4fa29d2c3aa9fd83/" rel="bookmark">
			Linux下查看压缩文件内容的11种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看未解压缩的归档或压缩文件的内容
1、使用 vim 编辑器打开
2、使用 tar 命令查看
tar -tvf test.tar 3、使用 rar v 命令
rar v test.rar 4、使用 unrar 命令
unrar l test.rar 5、使用 zip 命令
zip -sf test.zip 6、使用 unzip 命令
unzip -l test.zip 7、使用 zipinfo 命令
zipinfo test.zip 8、使用 zcat 命令
zcat test.tar.gz 9、使用gunzip 命令
gunzip -c test.tar.gz 10、使用 zless 命令
zless test.tar.gz 11、使用 less 命令
less test.tar.gz 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a440001881e9f9cd2cd71208ca3010/" rel="bookmark">
			移动硬盘无法在ubuntu显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sudo fdisk -l (找到移动硬盘路径) sudo mkdir /media/mq/jorbo （这里填自己的用户名（mq）及想创建的名字（jorbo）） sudo mount -t exfat /dev/sda1** /media/mq/jorbo （移动硬盘路径 自己创建的路径） 若报错 fuse: mountpoint is not empty fuse: if you are sure this is safe, use the ‘nonempty’ mount option
sudo mount -t exfat -o nonempty /dev/sda1** /media/mq/jorbo 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1206140c3137bb89e4f36f3f497af369/" rel="bookmark">
			Access数据库实战（二）:  Nz函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（转载自新浪博客）
在报表设计及输出效果时，经常要处理数据的空值问题，Access提供了一个很好用的函数NZ.
Nz(AA, “BB”)意思是如果AA的值是空的话就用BB代替。如果AA的值不是空就不变。
比如说有一个值Variant，当Variant为Null时，可以使用Nz函数返回零、零长度字符串(" ") 或其他指定的值。例如，您可以使用该函数将Null值转换为其他值，以避免该值在表达式中传播。
Nz(variant, [valueifnull])
Nz函数具有下列参数。
参数 说明
variant 数据类型为Variant的变量。
valueifnull 可选（除非是用在查询中）。Variant型，如果 variant 参数为Null，此参数提供要返回的值。使用此参数，可以返回一个非零或零长度字符串的值。
注释如果在查询中的表达式中使用Nz函数，而没有使用 valueifnull 参数，将在包含 null 值的字段中生成一个零长度的字符串。
如果 variant 参数的值为Null，Nz函数将返回数值零或零长度字符串（当用在查询表达式中时，始终返回零长度字符串），这取决于上下文指示该值应是数值还是字符串。如果包含了可选的 valueifnull 参数，Nz函数将在 variant 为Null的情况下返回由该参数指定的值。用在查询表达式中时，NZ函数应始终包含 valueifnull 参数，
如果 variant 的值不是Null，Nz函数将返回 variant 的值。
说明
Nz函数对于可能包含Null值的表达式来说，非常有用。若要强制表达式计算为非Null值（即使它包含一个Null值），请使用Nz函数返回零、零长度字符串或自定义返回值。
例如，当Variant varX为Null时，表达式2 + varX将始终返回一个Null值。然而，2 + Nz(varX)将返回 2。
通常，可以使用Nz函数作为IIf函数的替代方法。例如，在下列代码中，两个包含IIf函数的表达式是返回所需结果所必需的。第一个包含IIf函数的表达式用于检查变量的值，如果其值为Null，则将其转换为零。
varTemp = IIf(IsNull(varFreight), 0, varFreight)
varResult = IIf(varTemp &gt; 50, “High”, “Low”)
在下一个示例中，Nz函数将提供与第一个表达式相同的功能，而只需一步（而非两步）即可得到所需结果。
varResult = IIf(Nz(varFreight) &gt; 50, “High”, “Low”)
如果为可选参数 valueifnull 提供了一个值，该值将在 variant 为Null的情况下被返回。通过包含该可选参数，可以避免使用包含IIf函数的表达式。例如，下面的表达式将在varFreight的值为Null的情况下，使用IIf函数返回一个字符串。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1206140c3137bb89e4f36f3f497af369/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e433f377a644944e09ee93d5ca1733c/" rel="bookmark">
			Vue3.0 路由的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建项目 vue create demo 升级3.0 注意区分： VueCLI3.0和Vue3.0
由于 vue-cli 没有直接支持创建 Vue3.0 项目，所以需要通过插件升级，我们输入指令：
vue add vue-next 升级后的版本
"dependencies": { "core-js": "^3.6.5", "vue": "^3.0.0-beta.1", "vue-class-component": "^8.0.0-0", "vue-router": "^4.0.0-alpha.6", "vuex": "^3.5.1" }, 路由配置 import { createRouter, createWebHistory } from 'vue-router'; const routerHistory = createWebHistory(); const router = createRouter({ history: routerHistory, // history routes:[ ] }); export default router; 使用路由 import { createApp } from 'vue' import App from './App.vue' import router from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e433f377a644944e09ee93d5ca1733c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e3547129744e056e142683158bf20e5/" rel="bookmark">
			Spring Boot 使用过程中bug分析，及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、spring boot 快速入门过程中bug分析 1.1 Maven项目的setting文件配置错误，如图所示：
问题分析:检查maven目录中的settings.xml的标签语法配置是否正确.
1.2 创建项目时网络连接超时，如图所示：
问题分析:
1)域名解析问题(与当地的域名服务器有关)
2)网络阻塞问题(带宽有限,单同时的请求数量比较多)
3)服务器线程有限(例如tomcat端线程数量配置的相对较少)
1.3 Maven项目的pom.xml文件报错，如图所示：
问题分析：
检查网络配置（是否网络畅通，不能手机网络）
检测maven配置是否正确（严格按文档配置执行）。
右键项目maven update 强制更新。
更换maven私服仓库(选文档中的)
1.4 空指针异常（NullPointerException-NPE）,如图所示：
问题分析：分析错误描述，找到自己写的类指定行号位置，看看哪个对象在进行方法调用，调用方法的对象有没有被赋值，检查为属性所在类是否交给了spring管理。~~~~
1.5 依赖注入失败，如图所示：
问题分析：
检查错误代码中自己定义的类（例如DefaultCacheTests）中的属性
基于错误分析，哪个属性的值在进行依赖注入时失败了(例如DefaultCache)
检查注入失败的属性对应的对象是否交给了Spring管理（例如是否有特定注解描述，包结构是否正确）。
1.6 找不到对应的Bean对象，如图所示：
问题分析：
检查你获取的这个对象实例的类型是否使用了特定注解描述（如@Component）
检查你获取的这个对象实例的类型所在的包是否正确（启动类包结构）
假如是基于Bean的名字进行Bean对象的获取，要检测Bean的名字是否正确。
1.7 依赖注入失败，如图所示：
问题分析：
检查哪里对Cache进行了引用。
检查对Cache引用时使用的注解描述。
检查容器中Cache接口下实现类对象的定义（是否有多个？）。
2、Spring Boot 基础中bug分析 2.1 2.1.1 数据库版本及url配置问题，如下图所示:
问题分析：在url中追加时区配置(serverTimezone=GMT%2B8)
2.1.2 数据库版本或url配置问题，如下图所示：
问题分析:检查数据的服务是否已启动,连接数据的url配置是否正确,数据库版本与驱动是否匹配.
2.1.3 2.1.4 数据库服务连接不上，如图所示：
问题分析:检查数据库服务是否启动,连接数据库的用户名,密码是否正确.
2.1.5 访问的数据库不存在，如图所示：
问题分析:检查url配置的数据库是否存在.
2.1.6 指定命名空间下的元素ID已经存在。
问题分析：可能是GoodsDao接口或映射文件对应的映射元素有重复。
2.2 2.2.1 MyBatis 绑定异常，如图所示：
问题分析：
检查接口类全名与映射文件中的命名空间是否不一致。
检查接口方法名与映射文件中的元素是否不一致。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e3547129744e056e142683158bf20e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2323b81642a410fc294a995fae1eb29c/" rel="bookmark">
			【PPT】PPT文档导出PDF文件时，去掉右上角时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PPT文档需要导出为PDF文件时，右上角页眉会出现时间戳，有时候不需要时间，如何去掉时间戳呢？
Win10+Office2019
当需要将多页PPT打印在一张纸上时，右上角页眉会自动出现当前时间戳2019-09-08，右下角页脚也会有页码1，如图所示。当不需要这些内容时，怎么去掉上述页眉页脚呢？
具体步骤如下： 工具栏&gt;&gt;视图&gt;&gt;讲义母版；
可以在【占位符】栏，按需取消勾选【日期】、【页码】，这样在打印多页PPT【讲义】时，右上角右下角就不会出现【日期】、【页码】了。
最终效果如下图所示： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5af76ffd9f77d9090564c7a6baafe434/" rel="bookmark">
			傅里叶变换在图像处理中的应用初步学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 理解傅里叶变换在图像处理中的应用 一维傅里叶变换的作用对象是信号，信号是一维连续的；随着时间不断推移，信号强度的变换情况，可称为时域。
图像处理中的傅里叶变换的作用对象是二维矩阵。随着位置的不断改变，灰度值大小发生变化。可称为“距离-灰度变化图”。
一维傅里叶变换的原理可以通俗的理解为：将一个复杂无规律的信号拆分成多个简单有规律的子信号来表示。
为了定量表示这个结果，以横轴为频率大小，纵轴为振幅（即信号的最高强度），此图称为信号的频谱。
频谱中的每个点在时域中都对应一个函数；频谱和时域的对应关系是点与线。
那要如何定量表达众多分解后的子图像呢？
图像的频谱中频率是(xy轴构成的)平面。距离原点越远，则频率越大。因此，窗口边缘处即为高频区域，原点周边即为低频区域。
图像频谱中的一个点对应子图像的一整张距离-灰度变化图。
信号频谱中的y轴反应子信号，信号强度的变化范围；图像频谱中的z轴反应子图像的灰度值的变化范围。频谱窗口中对应的点越亮，则说明该点对应频率的变化范围越大。
低通滤波能保留图像的大致轮廓信息是因为，一张图像所记录到的主要信息（由于受到关照等必然因素的影响）在图像上灰度值的变化是缓慢的，因此主要信息集中在低频区域。而噪音等偶然因素是突然附加到图像上使得灰度值快速变化，而且密密麻麻，这导致N个像元内，灰度值的变化不仅频繁，而且变化的范围还很大。因此，噪音就位于图像频谱的高频区域，表现为高灰度值。
2 傅里叶变换在图像处理中的应用 傅立叶变换在图像处理中，被广泛应用于图像增强与图像去噪、图像分割之边缘检测、图像特征提取（形状、纹理）、图像压缩等方面。
基于傅里叶变换的图像增强
在图像处理中，图像高频分量：图像突变部分；在某些情况下指图像边缘信息，某些情况下指噪声，更多是两者的混合；低频分量：图像变化平缓的部分，也就是图像轮廓信息。
高通滤波器：让图像使低频分量抑制，高频分量通过。
低通滤波器：与高通相反，让图像使高频分量抑制，低频分量通过。 图像频域滤波增强技术是在频率域空间对图像进行滤波，因此需要将图像从空间域通过傅里叶变换频率域，具体操作如下： 假定原图像f(x,y)，经傅里叶变换为F(u,v)，频率域增强就是选择合适的滤波器函数H(u,v)对F(u,v)的频谱成分进行调整，然后经逆傅里叶变换得到增强的图像g(x,y)。该过程可以通过下面的流程描述： a 对原始图像f(x,y)进行傅里叶变换得到F(u,v)；
b 将F(u,v)与传递函数H(u,v)进行卷积运算得到g(u,v)；
c 将g(u,v)进行傅里叶逆变换得到增强图像g(x,y)。 频域滤波的核心在于如何确定传递函数，即H(u,v)。常用的频率域低通滤波器H(u,v)有4种。理想低通滤波器、巴特沃斯（Butterworth）低通滤波器、指数低通滤波器、梯形低通滤波器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65de9956d6dfeea1b5d445bdb97ef7d2/" rel="bookmark">
			Dubbo(十) dubbo服务超时时间设置以及优先级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dubbo服务超时时间有xml和注解两种方式进行实现配置超时功能。在配置范围上分为全部超时配置、接口类上超时配置、以及接口方法上超时配置。同类型上的配置消费端优先提供着端，靠近原则方法配置优先于接口类全局配置优先级最低。所以dubbo的超时时间优先级为：消费者Method&gt;提供者method&gt;消费者Reference&gt;提供者Service&gt;消费者全局配置provider&gt;提供者全局配置consumer。
一、基于xml方式的超时配置 服务提供者xml方式超时配置如下：
&lt;dubbo:provider timeout="5000"/&gt; 全局配置
&lt;dubbo:service timeout="4000" .../&gt; 接口类配置
&lt;dubbo:method timeout="3000" ...&gt; 方法配置
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name="user-service-provider" /&gt; &lt;!-- 使用zookeeper广播注册中心暴露服务地址 --&gt; &lt;dubbo:registry address="zookeeper://192.168.0.126:2181" /&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880" /&gt; &lt;!-- 和本地bean一样实现服务 --&gt; &lt;bean id="userService" class="com.xiaohui.service.impl.UserServiceImpl" /&gt; &lt;!-- 声明需要暴露的服务接口 timeout 接口类中全部方法超时配置 优先级2 --&gt; &lt;dubbo:service interface="com.xiaohui.service.UserService" ref="userService" timeout="4000" &gt; &lt;!-- 单个方法超时配置优先级最高1 --&gt; &lt;dubbo:method name="queryAllUserAddress" timeout="3000"&gt;&lt;/dubbo:method&gt; &lt;/dubbo:service&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65de9956d6dfeea1b5d445bdb97ef7d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c44fc7257bf202624eb6973e0d5ea847/" rel="bookmark">
			(error) WRONGTYPE Operation against a key holding the wrong kind of value
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis中的每一个键都有明确的数据类型，比如使用hset命令创建的键就是散列类型，然后用操作字符串的命令去操作hset命令创建的键就会报如上错误。
示例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b19ec666325e9dd224105f48357332c/" rel="bookmark">
			CVPR2020 步态论文：Gait Recognition via Semi-supervised Disentangled Representation Learning to Identit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文题目：Gait Recognition via Semi-supervised Disentangled Representation Learning to Identity and Covariate Features
通过半监督解耦表示 学习身份和协变特征的步态识别
摘要
现有的步态识别方法通常侧重于学习与协变量（如携带状态、服装、步行速度和视角）不变性的身份特征，很少涉及从协变量方面学习特征，当协变量引起的变化压倒同一性的变化时，可能导致失效。因此，我们提出了一种结合身份和协变量特征的解耦表示学习的步态识别方法。具体地说，我们首先对输入的步态模板进行编码，得到解耦的身份特征和协变量特征，然后对特征进行解码，以半监督的方式同时重建输入的步态模板和同一对象的无协变量的标准版本，以确保解耦成功。最后，我们将分离出的身份特征输入到对比/三重态丢失函数中，用于验证/识别任务。此外，我们发现，通过将协变量特征从一个对象转移到另一个对象，可以合成新的步态模板。在三个可公开获取的步态数据集上的实验结果证明了该方法的有效性。
介绍
步态是一种重要的生物特征，用于远距离的人类身份识别，因为与其他生物特征(如面部、指纹和虹膜)相比，它可以在不需要主体合作的情况下在远距离被记录。此外，步态是一种无意识的特征，一般不会被人伪装。基于步态的识别因此有许多潜在的应用，如监视系统、取证和刑事调查[6,20,31]。
以前的步态识别研究可大致分为以下几类：
根据提取的特征分类为基于模型的方法[47、53、27、5、10、54、2]和基于外观的方法[15、32、44、24、48、4、37、29、59]。基于外观的步态识别方法由于其有效性和高效性，在步态识别领域得到了广泛的应用。但由于携带身份、着装、姿势变化、视角等协变量较多，因此存在较大的主体内差异。
基于外观的步态识别需要提取不受协变量影响的身份特征。这种不变方法分为两大类:判别法[15,52,30,12,13,33,41,50,51,43,58,7,26]和生成法[23,32,34,38,35,1,11,55,56,16]。前者的目的是直接从原始的步态表示中提取不变的恒等特征子空间，而后者的目的是将不同协变条件下的步态表示生成相同协变条件下的步态表示。但是，它们都侧重于学习协变不变的特征子空间或图像空间，很少涉及协变方面的特征学习，当协变带来的变化超过了恒等带来的变化时，可能会导致失效模式。
为了解决上述问题，我们提出了一种基于外观的步态识别采用解耦表征学习（DRL）同时考虑身份和协变量特征。这个想法的灵感来自于先前的工作[60]（CVPR2019的文章，可从博客中寻找），其中姿势和外观特征从RGB图像中分离出来，并且基于LSTM的姿势特征随时间的整合被用于步态识别。尽管服装的颜色和质地等外观特征的影响被成功地消除了，但我们认为RGB图像的使用仍然存在不足。首先，张等[60]假设两个条件来分离姿势和外观特征，一个是在一个序列中外观特征是一致的，另一个是每个训练对象至少包含两个外观特征完全不同的序列。然而，这些条件可能并不总是满足的，从而导致外观因素污染姿势特征。一个例子，如果在一个序列中光照条件突然改变（包括通过肢体运动使体表法线相对于入射光方向改变的情况），则第一个条件可能不满足；第二，如果训练对象只是部分地更换衣服或换成颜色不同但质地相似的衣服。文献[60]将RGB输入的颜色和纹理信息视为一种协变量，可以像许多步态识别工作一样，简单地使用基于轮廓的表示来处理。 因此，我们将[60]的分离思想扩展到直接从基于轮廓的步态表示中分离身份和协变量特征。我们将协变量分为两类，它们对步态表征有不同的影响，可能需要不同的分离策略。具体地说，第一类包括在身体上改变受试者身体形状的携带状态和衣服，并且该类具有一类明确的规范条件，即没有协变量的步态模板。作为一个例子，我们将没有携带对象（COs）和足够紧的衣服（例如，穿着紧身衣的对象）的步态模板作为携带状态和衣服的标准条件。第二类包括视角，它引入了所有主体之间的共同变化，而这类视角并没有一个明确和合适的标准条件来适用于所有的视角。本文着重于第一类。同样对于步态表示，我们选择步态能量图像（GEI）[15]，这是步态识别领域中使用最广泛的步态表示。
具体地说，我们首先使用编码器将输入的GEI分解成低维身份和协变量特征。然后我们使用一个解码器执行两个重建；一种是从分离的同一性和协变量特征中重建输入GEI，另一种是从分离的同一性和零填充协变量特征重建另一个与输入GEI相同但没有协变量（规范条件）的GEI，其中我们给出了基本真实GEI没有协变量。通过这种设计，我们可以成功地将输入GEI分解成同一性和协变量特征。最后，我们将一对或三元组的身份特征输入到验证/识别任务的对比/三元组损失中。
为此：
（1）我们使用基于轮廓的步态表示来避免不必要的颜色和纹理协变量；
（2）我们探索DRL，以分离身份和更常见但更困难的协变量，如携带状态和衣服；（3）我们通过以半监督的方式同时重建输入GEI及其标准版本来克服污染问题（即，我们给没有协变量的GEI（例如，“无协变量”）而不是在训练阶段给其他有协变量的GEI添加协变量标签）。
此外，我们发现，给定来自一个被摄体1的解耦身份特征和来自另一个被摄体2的解耦协变量特征，解码器可以重构具有从1表征的相同身份和从2表征的相同协变量的新GEI样本，如图1所示。因此，我们可以自由地将协变量特征从一个主题转移到另一个主题，从而生成新的GEI，我们称之为GEI编辑。
图1：在给定两名受试者(S1和S2)不同携带状态的步态模板后，我们的方法隐式地分离他们的身份和协变量特征(fid和fcov)，并仅使用身份特征重建不携带任何身份的步态模板。此外，我们还可以交换研究对象的协变量特征，并根据各自的携带状态生成新的步态模板。
我们将我们的贡献总结如下。
1） 一种用于步态识别的基于身份和协变量特征的分离网络。ICDNet
我们首次引入半监督DRL来分离身份和协变量特征，用于步态识别。分离后的身份特征具有纯粹性和区分性，可用于步态识别。
2） GEI编辑：从一个主题到另一个主题的协变量转移。
我们可以通过将分离的协变量特征从一个主体转移到另一个主体来生成新的GEIＧＥＩ。这对今后步态识别中数据增强的研究具有一定的参考价值。
3） 最先进的表现。
我们在三个公开可用的步态数据库上取得了最先进的性能：具有真实COs的OU-ISIR大人口步态数据库（OU LP Bag）[46]、OU-ISIR步态数据库、带有Bag版本的大群体数据集（OU LP Bag）[33]和CASIA-B步态数据库[57]。
2.相关工作
基于外观的步态识别方法主要分为判别法和生成法。第一类旨在利用传统的度量学习技术(如线性判别分析[15]、张量表示的判别分析[52]、随机子空间方法[13]、联合强度和空间度量学习[33])或当前的深度神经网络提取一种针对协变量的判别子空间。特别是，基于深度学习的方法更受欢迎，因为它们具有更高的性能。例如Shiraga等人[41]提出了一种用于对具有交叉熵损失的单输入GEIs进行分类的轻型卷积神经网络(light convolutional neural network, CNN)。此后，一些研究[51,43,26]对具有对比或三元损失的输入GEIs对或三联体进行了相似性学习。Wolf et al.[50]和Chao et al.[7]直接为剪影帧设计了cnn，而不是将GEIs作为网络输入。
第二类旨在使用子空间分析技术[23、32、34、38、35、1]或生成对抗网络（GAN）[55、56、16]，将不同协变量条件下的步态表示生成为相同协变量条件下的步态表示。 例如，Makihara等。 [32]提出了一种视图转换模型，将步态特征从画廊视图条件转换为探针视图条件。 Yu等。 [55，56]提出了基于GAN的生成网络，称为GaitGAN和GaitGANv2，它们可以从任何带有协变量的输入GEI生成正常状态下侧视图的不变GEI。
然而，上述方法集中于学习不变地用于协变量的身份特征子空间或图像空间，并且很少考虑从协变量方面学习特征，当变化时可能导致失败。由于协变量而不是由于同一性。 相比之下，我们的方法同时考虑了身份和协变量特征学习，并获得了明显的身份认同特征与协变量特征的消融。
解耦表示学习
DRL被期望通过将数据的底层结构分离成不相交的有意义的变量来提供收益，这有助于澄清深层模型并确定实际学习到的隐藏特征类型。Zhang等人。[60]首次将DRL引入步态识别领域，从RGB图像中分离出受试者的姿势和外观特征。虽然DRL在步态研究中是一个新的领域，但在其他生物特征识别（如人脸识别）的研究中已经得到了很好的探索。例如，Tran等人。[45]彭等。从人脸识别中分离出40个姿势不变的人脸图像。[61]通过年龄变化的分解，生成年龄不变的人脸特征。
与文献[60]相比，我们的方法避免了RGB信息分离的困难，并为基于轮廓的步态表示提供了新的有意义的分离变量（即身份特征和协变量特征）。与人脸识别[45，40，61]中需要附加协变量标签（例如，姿势或年龄标签）的DRL相比，我们的方法针对的是没有明确标签（除了“无协变量”标签），因为我们在论文中针对的协变量（即携带状态和衣服）没有清晰的标签。例如，即使是同一个手提行李，其携带状态（例如形状和位置）也很大程度上取决于物品。在我们的半监督DRL中，只需要部分训练对象的典型条件（即“无协变量”）的标签。
3.提出的方法
3.1概述
我们提出了一种适用于步态识别的方法DRL从GEI中分离身份和协变量特征。在我们的问题设置中，我们假设每个训练对象都有一个没有协变量的步态模板（例如，一个没有COs的GEI），而我们没有其他步态模板的协变量条件标签（例如，一个受试者可能携带背包、公文包、手提箱甚至什么都没有，但我们从未事先知道，它还提供了一个测试用例）。因此，我们尽量使部分标签“无协变量”更好地分离。[1]
图2示出了所提议的概述。基本解缠模块由一个编码流和两个解码流组成，处理训练集中的所有gei。然后将一对（probe和gallery）或三元组（query、true和imposter）分别输入验证或身份丢失函数，以进行验证或身份识别培训。在一个测试案例中，只有解缠模块的编码器被用来分离每个输入GEI的身份和协变量特征。将两个被试的身份特征之间的欧氏距离计算为差异得分。最后，我们通过比较验证场景（一对一匹配）的接受阈值来判断受试者是否相同或不同，或者在识别场景的画廊中找到最小的差异分数。（一对多匹配）
图2：
（a） 解缠模块使用编码器从输入GEI中分离潜在身份和协变量特征，解码器执行两次重构；一种是原始输入GEI的自重构（用实线表示），另一种是无协变量（用虚线表示）的输入GEI的重构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b19ec666325e9dd224105f48357332c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf51daac4256ee60ce5a57bd2a02ef7e/" rel="bookmark">
			Java43——泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、泛型的理解
1.泛型的概念
所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返
回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、
创建对象时确定（即传入实际的类型参数，也称为类型实参）。
2.泛型的引入背景
集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection&lt;E&gt;，List&lt;E&gt;，ArrayList&lt;E&gt; 这个&lt;E&gt;就是类型参数，即泛型。
二、泛型在集合中的使用
1. 在集合中使用泛型之前的例子
@Test
public void test1(){
ArrayList list = new ArrayList();
//需求：存放学生的成绩
list.add(78);
list.add(76);
list.add(89);
list.add(88);
//问题一：类型不安全
// list.add("Tom");
for(Object score : list){
//问题二：强转时，可能出现ClassCastException
int stuScore = (Integer) score;
System.out.println(stuScore);
}
}
图示：
2. 在集合中使用泛型例子1
@Test
public void test2(){
ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list.add(78);
list.add(87);
list.add(99);
list.add(65);
//编译时，就会进行类型检查，保证数据的安全
// list.add("Tom");
//方式一：
// for(Integer score : list){
// //避免了强转操作
// int stuScore = score;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf51daac4256ee60ce5a57bd2a02ef7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/317bc68279a5082f9799d156e524193b/" rel="bookmark">
			如何利用VisionSeed&#43;树莓派，实现智能小车实时图传系统？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 | 所谓图传，就是把相机模组捕捉到的画面，实时传输到另一个可接收该数据的设备上，并且在该设备上进行实时播放。本文将介绍如何基于 VisionSeed 和 Raspberry Pi（4B）搭建一套完整的图传系统，希望与大家一同交流。文章作者：毛江云，腾讯优图实验室研发工程师。
VisionSeed智能小车实际跑圈演示视频
一、概念介绍
1. Raspberry Pi 树莓派[1]其实不用笔者过多介绍，这应该是做的最成功的开源硬件芯片，深受技术和数码爱好者们的拥护。下图摘自淘宝某店家的中文说明图，总之第四代比第三代功能强了很多，而且好多接口都与时俱进了。
2. VisionSeed VisionSeed[2] 是腾讯优图推出的一款具备 AI 功能的摄像头模组，产品如下图所示。它的体型很小，有点类似 Raspberry Pi Zero，不过麻雀虽小五脏俱全。
右边是整块 VisionSeed 的核心模块，包括 2 个摄像头（一个 UVC 摄像头，一个红外摄像头），剩下一整块都是 AI 计算单元；左边是控制板块，主要是对外的接口，如串口、TypeC 接口。两块直接通过 FP C连接起来。
VisionSeed 模组可以搭载很多 CV 的 AI 能力，目前官方已经推出的有疲劳驾驶监测仪[3]，笔者目前参加的智能小车就是正在孵化的另一个项目，期待越来越多的 AI 爱好者们参与进来，把 VisionSeed “玩出花”。
二、系统搭建
本文所介绍的是利用 VisionSeed 和 Raspberry Pi（4B） 搭建的一套基于 FFMPEG 编码+SRS+WIFI 协议+RTMP 协议+FFPLAY 解码播放的完整图传系统，该实时图传全过程示意图如下所示：
1. RTMP推流服务器
推流服务器怎么选择？其实推流服务器有很多种选型，具体该选择哪种比较好？笔者结合自身经验给出 nginx-rtmp 服务和 srs 服务的使用心得和实际对比：
补充说明一下延时这块：首先笔者给出的具体延迟时间并非真正服务器推流的延迟，而是端（VisionSeed 采集到视频）到端（播放设备播放视频）的延迟。
这中间涉及到的环节多且复杂：VisionSeed 的 UVC 视频采集，FFMPEG 编码、推流服务器推流、FFPLAY 解码、以及显示器显示。其中推流服务器推流还包括服务器内部 buffer 缓存、网络数据包拼接和组装、以及网络包的传输等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/317bc68279a5082f9799d156e524193b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5bd06fc25776419b6370b9d3f752212/" rel="bookmark">
			Spring Boot：mybatis-plus &#43; atomikos &#43; druid 实现不同实例数据库的多数据源配置和分布式事务管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想到工作上可能会用到多数据源，但是自己在这方面并不是很熟悉，于是在网上查阅了很多文章，结果发现，网上的文章要么版本太老有些过时，要么用的不是mybatis-plus而是mybaits，要么步骤繁琐、需要自己手动编写aop切面代码，要么在同一service层方法中只能使用@Transactional实现单个数据源的事务管理控制，总是觉得有点不太完美，所以综合了以上文章的不足之处和可以借鉴之处，在这里总结出了一个万能的、可以适应多方面需求的多数据源配置方法，以满足相对完整的、代码简练的分布式事务控制需求。现在分享给大家。
一. 从maven中导入必须用到的依赖 &lt;dependencies&gt; &lt;!-- mysql数据库依赖组件--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.20&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis-plus依赖组件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid连接池依赖组件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 多数据源的分布式事务控制--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jta-atomikos&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 以上除了一些必须的、通用的依赖之外，还引入了atomikos依赖包，这是实现分布式事务管理的关键。
二. application.yml文件的配置 这个配置是可以很灵活的，数据源配置都是自定义字段，到时候方便能够在java代码中引用，以下是两个数据源的示范：
server: port: 10010 spring: autoconfigure: #停用druid连接池的自动配置 exclude: com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure datasource: #选用druid的XADataSource数据源，因为这个数据源支持分布式事务管理 type: com.alibaba.druid.pool.xa.DruidXADataSource #以下是自定义字段 dynamic: primary: master datasource: master: url: jdbc:mysql://localhost:3306/local_test?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=Asia/Shanghai&amp;autoReconnect=true username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver slave: url: jdbc:mysql://localhost:3307/remote_test?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=Asia/Shanghai&amp;autoReconnect=true username: root password: root driver-class-name: com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5bd06fc25776419b6370b9d3f752212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e062d7f401a5896a09049c6cc3915613/" rel="bookmark">
			哔哩哔哩m4s批量转MP4&#43;bat脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哔哩哔哩m4s批量转MP4 1、手机哔哩哔哩下载好视频，得到对应的多个音频视频文件
格式：
2、下载ffmpeg
ffmpeg下载
3、然后配置bin环境变量
4、win+r 输入cmd
输入
ffmpeg -version
5、新建bat文件
@echo off setlocal enabledelayedexpansion rem 要读取的文件 set filedir=E:\mq\1\* rem 视频要输出到的文件夹 set outpath=E:\mqout\ for /d %%i in (%filedir%) do ( echo ============================== rem 截取文件名称字符串 rem 注意要修改截取的位置跟输入路径有关系 set ifo=%%i set t=!ifo:~8,5! echo !t! set video=%%i\80\video.m4s set audio=%%i\80\audio.m4s echo 输出文件到： %outpath%!t!.mp4 rem 如果文件夹不存在则创建文件夹 if not exist %outpath% (md %outpath% ) rem 使用ffmpeg命令合成哔哩哔哩的音频、视频文件 ffmpeg -i !audio! -i !video! -vcodec copy -acodec copy -f mp4 %outpath%!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e062d7f401a5896a09049c6cc3915613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebeff7a312d2224a65517a5c0fab1aa8/" rel="bookmark">
			android camera hal3 新增vendor tag
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间，我在android8.1的系统层上，新增了一个usbcamera hal，和一个虚拟摄像头hal。在实际使用的过程中，遇到了一个问题——客户app在用camera api接口调用usbcamera或virtual camera时，希望能够知道当前调用的是系统本身的mipi摄像头，还是usbcamera或virtualcamera。也就是说，客户想知道，我当前调用的摄像头，是个什么东西。
要实现这个功能，有三种方法。第一种，是最下乘的方法，也就是在hal层，open usbcamera或virtual camera的时候，设置一个属性camera.type值为usb或virtual，在close的时候置为空。在app上可以通过这个属性来判断当前打开的是什么摄像头。这个方法，之所以说是最下乘的，那是因为它不是camera标准流程的东西，不能通过camera的标准接口来判断。并且，当我同时打开了usbcamera或者virtual camera时，这就没法搞了。
第二种，是在hal层，构建cameraInfo的时候，将camera_info-&gt;facing的值，设为CAMERA_FACING_EXTERNAL。不过在android8.1上，好像这个值很多地方都没有相应的配置。并且有第一种方法同样的问题，比如我同时打开了usbcamera和virtualcamera，就没法判断各种打开的摄像头是什么类型的了。
第三种，是在hal层，新增一个vendor tag ANDROID_CAMERA_TYPE，然后如下方法去设置它的值：
static const uint8_t cameraType = 1; cm.update(HalModule::ANDROID_CAMERA_TYPE, &amp;cameraType, 1); 再在app层，就可以通过mCharacteristics.get(CameraCharacteristics.JPEG_ORIENTATION);这样类似的方法去获取它的值了。这种方法最灵活，要使用这种方法，新增一个vendor tag，我们必须要先理解camera 的tag是怎么工作。下面我们先来讲一下它们的工作流程。
在android camera hal3上，从app到hal层的参数传递，都是通过metadata来实现的。在app上如果要设置一个tag是通过下面的代码实现的:
CaptureRequest.Builder builder; builder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO); 这个CONTROL_MODE定义在CaptureRequest.java
@PublicKey public static final Key&lt;Integer&gt; CONTROL_MODE = new Key&lt;Integer&gt;("android.control.mode", int.class); 这个key也定义在这个文件里：
public final static class Key&lt;T&gt; { private final CameraMetadataNative.Key&lt;T&gt; mKey; /** * Visible for testing and vendor extensions only. * * @hide */ public Key(String name, Class&lt;T&gt; type, long vendorId) { mKey = new CameraMetadataNative.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebeff7a312d2224a65517a5c0fab1aa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc2270d810cc811353bcf352dee12b5/" rel="bookmark">
			几种人脸识别的loss和改进思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 大致演进过程2. 关于角度3. 常见的人脸识别相关的softmax loss3.0 原始softmax loss3.1 基于挖掘的 [mining based]3.1.1 Hard mining3.1.2 Soft mining - focal loss 3.2 基于间隔的 [margin based]3.2.1 Angular margin (A-softmax)3.2.2 Additive margin (AM-softmax)3.2.3 Additive angular marign (Arc-softmax) 3.3 同时结合挖掘和间隔的 [mining and margin based]3.3.1 Mis-classified vector guided softmax loss (MV-softmax)3.3.2 Circle loss 1. 大致演进过程 softmax -&gt; 基于欧式空间 -&gt; 基于softmax变体 -&gt; 基于角度空间 [1]
Softmax: (DeepID, DeepFace)欧式空间：对比损失、triplet loss、center loss 以及 triplet loss和softmax结合 (DeepID 2+, DeepID3, FaceNet, VggFace, TSE, TPE, Range loss)softmax变体：特征归一化、权重归一化 (NormFace, L2 softmax, CoCo loss, vMF loss)角度空间：large margin (L softmax, A softmax(Sphereface) , Cos/Arc/Regular/Adaptive face, AMS loss, Adacos) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fc2270d810cc811353bcf352dee12b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e5f09d2748c88c7555e85ba7558082/" rel="bookmark">
			DUTS数据集中DUTS\DUTS-TR\DUTS-TR-Mask中的命名错误的图片名字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 找到后，将后缀改为png，替换掉之前存在的同名png图片即可。
找出代码：
import os f = open("./img.txt", 'w') # 先创建一个空的文本 img path = "./DUTS-TR-Image/" # 指定需要读取文件的目录 DUTS-TR-Mask DUTS-TR-Image files = os.listdir(path) # 采用listdir来读取所有文件 files.sort() # 排序 s = [] # 创建一个空列表 num = 0 for file_ in files: # 循环读取每个文件名 num = num + 1 # print(path +file_) if not os.path.isdir(path + file_): # 判断该文件是否是一个文件夹 f_name = str(file_) # print(f_name) s.append(f_name) # 把当前文件名返加到列表里 f.write(str(num) + ' ' + f_name + '\n') # 写入之前的文本中 print(s) # 看一下列表里的内容 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aa683c4d57b1cd9b0d38568b590a459/" rel="bookmark">
			django.db.migrations.exceptions.InconsistentMigrationHistory: Migration admin.0001_initial is applie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		migrate数据到数据库时遇到的以下错误。
django.db.migrations.exceptions.InconsistentMigrationHistory:
Migration admin.0001_initial is applied before its dependency
user.0001_initial on database ‘default’.
解决方案：
删除数据库中 除了auth_user的其他表再migrate。原因可能是因为admin的模型依赖了之前默认的user模型。
删除时如果遇错可能是数据表间有外键关系，按约束顺序删除即可。
发布于：2019年11月15日 @ 23:19 ailulu.tech
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fedf86f4278c31c6177e77412f637ba7/" rel="bookmark">
			CSS样式更改——字体设置Font&amp;边框Border
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇文章主要讲述了CSS样式更改中的背景Background，这篇文章我们来谈谈字体设置Font&amp;边框Border的基础用法。 ###1.字体设置Font ####1).字体系列
&lt;div style='font-family: sans-serif normal'&gt;&lt;/div&gt; 可用字体： Serif Sans-serif Monospace Cursive Fantasy Times Courier ####2).字体风格
&lt;div style='font-style:normal'&gt;&lt;/div&gt; 文本倾斜: normal 文本正常显示 italic 文本斜体显示 oblique 文本倾斜显示 ####3).字体变形
&lt;div style='font-variant:small-caps'&gt;&lt;/div&gt; normal 显示标准字体。 small-caps 显示小型大写字母的字体。 ####4).字体加粗
&lt;div style='font-weight:normal'&gt;&lt;/div&gt; normal 标准的字符 bold 粗体字符 bolder 更粗的字符 lighter 更细的字符 也可以使用数字表示，范围为100~900 ####5).字体大小
&lt;div style='font-size:60px'&gt;&lt;/div&gt; smaller 变小 larger 变大 length 固定值 而且还支持百分比 ###2.边框Border 首先说一下边框风格，它的风格比较多，常用的一般是实线为主：
&lt;div style='border-style:none'&gt;&lt;/div&gt; hidden 隐藏边框 dotted 点状边框 dashed 虚线边框 solid 实线边框 double 双线边框 groove 3D凹槽边框 ridge 3D垄状边框 inset 3D inset边框 outset 3D outset边框 边框也有四面，所以也会有上下左右 所以有时候为了更精确定位并修改样式可以使用： border-top-style 上边框样式 border-right-style 右边框样式 border-bottom-style 下边框样式 border-left-style 左边框样式 先定义边框的宽度 风格和颜色，然后定义边框的其它属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fedf86f4278c31c6177e77412f637ba7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8698e7d518c546c2cb47e211614428fa/" rel="bookmark">
			Vue给组件加v-model，封装表单组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		v-bind="$attrs" 其实就是继承父亲传过来的属性， inheritAttrs:false 让根组件不要绑定这个属性
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd1011218eed9649279860d42ddf0440/" rel="bookmark">
			深度学习策略之图像预处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习策略对于培训和测试也非常重要。 首先，对数据进行预处理（例如图像增强）有时对于预测合理的结果至关重要。
1. 验证集划分 直接划分：随机划分的方式使得模型的训练数据可能和测试数据差别很大，导致训练出的模型泛化能力不强。LOOCV: Leave-one-out cross-validation，这相当于是k折交叉验证的一个极端情况，即K=N。每次只用一个数据作为测试，其他均为训练集，重复N次（N为数据集数目）kFold，k折交叉验证，每次的测试集将不再只包含一个数据，而是多个，具体数目将根据K的选取决定。比如，如果K=5，那么我们利用五折交叉验证的步骤就是：1）将所有数据集分成5份；2）不重复地每次取其中一份做测试集，用其他四份做训练集训练模型，之后计算该模型在测试集上的Error_i；3）将5次的Error_i取平均得到最后的Error。 2 Image augmentation,图像or数据增强 2.1 传统方法 直方图均衡
原理是平均分布的图像信息熵最大，也就相当于是说对比度最大。从初始状态转化到直方图均衡状态时，经过一个转移函数，转移函数可由最终想要达到的平均状态作为极限来反推得到。
具体可参阅：李新春：直方图均衡化
灰度变换
灰度变换可使图像动态范围增大，对比度得到扩展，使图像清晰、特征明显，是图像增强的重要手段之一。它主要利用图像的点运算来修正像素灰度，由输入像素点的灰度值确定相应输出像素点的灰度值，可以看作是“从像素到像素”的变换操作，不改变图像内的空间关系。像素灰度级的改变是根据输入图像f(x,y)灰度值和输出图像g(x,y)灰度值之间的转换函数g(x，y)=T[f(x，y)]进行的。
灰度变换包含的方法很多，如逆反处理、阈值变换、灰度拉伸、灰度切分、灰度级修正、动态范围调整等。
图像平滑
在空间域中进行平滑滤波技术主要用于消除图像中的噪声，主要有邻域平均法、中值滤波法、高斯滤波等等。这种局部平均的方法在削弱噪声的同时，常常会带来图像细节信息的损失。
上述的滤波方法一般都只是考虑空间域的操作（即相近像素），而忽略了值域空间的相关性，而这正是边缘所在处（值域的剧烈波动）非常重要的因素。因此，有双边滤波（保边滤波）方法，同时考虑了空域和值域，且设置了相应的权重，空域中离关注区域点左边越近，权重系数越大；值域中该值和所关注区域的值接近，其权重系数就大，反之则小，由此可以保住边缘处的信息。
具体可参阅：bilateral filter双边滤波器的通俗理解
图像锐化
采集图像变得模糊的原因往往是图像受到了平均或者积分运算，因此，如果对其进行微分运算，就可以使边缘等细节信息变得清晰。这就是在空间域中的图像锐化处理，其基本方法是对图像进行微分处理，并且将运算结果与原图像叠加。从频域中来看，锐化或微分运算意味着对高频分量的提升。常见的连续变量的微分运算有一阶的梯度运算、二阶的拉普拉斯算子运算，它们分别对应离散变量的一阶差分和二阶差分运算。
图像处理自学（六）：图像增强算法总结_TheDayIn_CSDN的博客-CSDN博客
2.2 深度学习中的图像增强（预处理） 这些手段相当于yolo v4中所说的bags of free，意指用这些数据增强的手段，只会改变训练时的策略或者增加训练的时间，但不会对模型的最终的推断时间产生影响，相当于是免费的技巧。因此，yolo v4中用到了大量的数据增强手段，而结果也令人惊喜，得到了几个点的提升。可使用albumentations包，里面包含各类图像增强技术。
几何增强：平移，旋转，剪切等对图像几何改变的方法，可以增强模型的泛化能力。
色彩增强：主要是亮度变换，如使用HSV(HueSaturationValue)增强。
Blurring,模糊，诸如高斯滤波，方框滤波，中值滤波等。可以增强模型对模糊图像的泛化能力。
mixup，mixup: Beyond empirical risk minimization
上述的通用数据增强方法则是针对同一类做变换，而mixup则是采用对不同类别之间进行建模的方式实现数据增强。不同的类加上不同的权重，而其得到的损失函数也加上不同的权重，最后再进行反向传导求参数。具体可参阅：数据增强之mixup论文笔记_ouyangfushu的博客-CSDN博客
随机擦除（Random Erasing, RE）增强, [Random erasing data augmentation](Random Erasing Data Augmentation)
随机擦除，提出的目的主要是模拟遮挡，从而提高模型泛化能力，对遮挡有更好的鲁棒性。随机选择一个区域，然后采用随机值进行覆盖，模拟遮挡场景。
Cutout，DeVries et al., 2017, Improved Regularization of Convolutional Neural Networks with Cutout
其的出发点和随机擦除一样，也是模拟遮挡，目的是提高泛化能力，实现上比Random Erasing简单，随机选择一个固定大小的正方形区域，然后采用全0填充就OK了，当然为了避免填充0值对训练的影响，应该要对数据进行中心归一化操作，norm到0。具体也可参阅：【数据增强】Cutout_weixin_41560402的博客-CSDN博客
CutMix, Yun et al.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd1011218eed9649279860d42ddf0440/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc1e92651eef5665dfc159afc74cedd7/" rel="bookmark">
			Tensorflow 报错 /lib64/libm.so.6: version `GLIBC_2.23‘ not found 无root权限解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 背景2. 解决方案 1. 背景 最近用学校的服务器跑模型，安装运行Tensorflow的时候报错了GLIBC_2.23' not found，因为没有root权限，没办法升级GLIBC，最后找到了另外的解决方案，在这里记录一下。
2. 解决方案 /lib64/libm.so.6: version `GLIBC_2.23' not found 操作系统GLIBC版本较低导致此问题。
我的Tensorflow版本为1.13.1。我发现在Python 3.7 中会出现此问题，而Python3.6中不会出现。
所以解决方案如下：
使用Anaconda创建python3.6虚拟环境 conda create -n python3.6 python=3.6 激活虚拟环境 conda activate python3.6 安装tensorflow pip install tensorflow==1.13.1 如果要在虚拟环境中使用ipython，安装nbconvert pip install nbconvert 再重新import tensorflow as tf，应该就不会出现这个问题了。
联系邮箱：curren_wong@163.com
CSDN：https://me.csdn.net/qq_41729780
知乎：https://zhuanlan.zhihu.com/c_1225417532351741952
公众号：复杂网络与机器学习
欢迎关注/转载，有问题欢迎通过邮箱交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4893d620fffddfbad02be2646bb5aff8/" rel="bookmark">
			API设计规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、 什么是RESTful二、 版本控制三、方法命名规范四、URL命名规则五、请求方式六、请求参数六、响应体七、注释八、瘦客户端九、 禁止行为 一、 什么是RESTful 一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。
URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作
看Url就知道要什么
看http method就知道干什么
看http status code就知道结果如何
二、 版本控制 第一种形式：api版本号放在url路径中。
https://api.example.com/v{n}
应该将API的版本号放入URL。采用多版本并存，增量发布的方式。n代表版本号，分为整型和浮点型 整型： 大功能版本， 如v1、v2、v3 …浮点型： 补充功能版本， 如v1.1、v1.2、v2.1、v2.2 … 第二种形式：api版本号放在url参数中
https://api.example.com/user/1?version=v1&amp;…
第三种形式：api版本号放在请求的header中
-H “API-VERSION: v1”
-H “API-VERSION: v2”
第四种形式：api版本号放在二级域名中
不同版本使用不同的域名
v1.api.xxx.com
v2.api.xxx.com
个人比较倾向于第一种(xxx.com/v1/、xxx.com/v2/)：在开始设计的时候，查询类的接口,应尽可能使用被动式提供数据的无状态接口，格式应竟可能使用对象(不使用二维的集合)，这样的接口对于扩展字段非常的方便，也很容易做到向下兼容.操作类的接口，尽可能地将资源分离，比如修改用户信息，跟修改用户头像信息或者修改用户职位信息，这样的接口，尽可能使用独立的资源
三、方法命名规范 动作前缀备注获取getget{XXX}List新增addadd{XXX}修改updateupdate{XXX}保存savesave{XXX}删除deletedelete{XXX}上传uploadupload{XXX}发送sendsend{XXX} 四、URL命名规则 REST API使用统一资源标识符（URI）来寻址资源
URI结尾不应包含（/）
正斜杠分隔符（/）必须用来指示层级关系
应使用连字符（ - ）来提高URI的可读性
不得在URI中使用下划线（_）
URI路径中全都使用小写字母
URL中不能有动词
在Restful架构中，每个网址代表的是一种资源，所以网址中不能有动词，只能有名词（特殊情况可以使用动词），动词由HTTP的 get、post、put、delete 四种方法来表示，而且所用的名词往往与数据库的表格名对应。
URI中不要包含文件(脚本)的扩展名
URL路径名词均为复数
例子
https://api.example.com/v1/order/products
https://api.example.com/v1/user/users
https://api.example.com/v1/employees
五、请求方式 请求方式描述GET（SELECT）获取数据（查询）POST（CREATE）新增数据（创建单个资源）PUT（UPDATE）更新数据（更新单个资源（全量））DELETE（DELETE）删除数据PATCH（UPDATE）部分更新（一般不用）HEAD获取资源的元数据OPTIONS获取信息，关于资源的哪些属性是客户端可以改变的 例子：
GET /v1/products 获取所有商品
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4893d620fffddfbad02be2646bb5aff8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63033bbc7c8e23c629ea4ea831d775de/" rel="bookmark">
			C语言32个关键字-最详解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言关键字，看这一篇就够了 一、数据类型关键字二、控制语句关键字三、存储类型关键字四、其它关键字五、表格汇总 在了解关键字之前，先要明确定义与声明的区别：
定义： 编译器创建一个对象，为这个对象分配一块内存并给取一个名字，这个名字成为变量名或对象名。
声明：告诉编译器，这个名字已经匹配到一块内存上了，其不能再用这个名字进行定义。
主要区别：定义创建了对象并为这个对象分配了内存，而声明没有分配内存。
C语言标准定义的32个关键字可以分为如下四类：
一、数据类型关键字 序号关键字说明1char声明字符变量2double声明双精度变量3float声明浮点型变量4int声明整型变量5short声明短整型变量6long声明长整型变量7unsigned声明无符号类型变量8signed声明有符号类型变量9struct声明结构体变量10union声明共用体或联合数据类型11void声明函数无返回值或无参数，声明无类型指针12enum声明枚举类型 重点说明：
1、chart、short、int、long、float、double
有一个常被提及的问题：int类型究竟占多少个字节？一般默认为4个字节，而有一点功底的人都知道它的大小是跟机器有关的，感兴趣的可以查看其它文章。int具体大小可用sizeof关键字查看，代码如下：
# include &lt;stdio.h&gt; void main() { printf("char类型变量大小为%d字节\n",sizeof(char)); printf("short类型变量大小为%d字节\n",sizeof(short)); printf("int类型变量大小为%d字节\n",sizeof(int)); printf("long类型变量大小为%d字节\n",sizeof(long)); printf("float类型变量大小为%d字节\n",sizeof(float)); printf("double类型变量大小为%d字节\n",sizeof(double));	} 运行结果：
2、signed、unsigned
signed和nsigned用于修饰整数类型。默认的int、short、long为有符号数，如signed int 等价于 int(其它类推)。
另外，char共有三种不同的类型：char、signed char、unsigned char。char类型是真正的字符类型，用来声明字符；而signed char和unsigned char是用来声明数值的。因此不要将三者混用。
数值范围如下：
signed char表示范围：[-128, 128)；
unsigned char表示范围：[0, 256)；
3、struct
在实际问题中，一组数据往往具有不同的数据类型。struct关键字就可以将这些不同数据类型的数据打包成一种构造数据类型。这种构造类型由多个成员组成，每一个成员可以是一个基本数据类型或者另一个构造类型。一般情况下，结构体所占内存大小是其成员所占内存之和。但空结构体的内存大小在不同编译器里有0有1，读者可以试一试。
4、union
union关键字用法与struct非常相似，但也有区别。struct中的所有数据成员是共存的，不管有没有调用，编译器都会分配内存；而union中的数据成员是互斥的，它只配置一个足够大的空间来容纳最大长度的数据成员。即union中所有数据成员共用一个空间，同一时间只能存储其中一个数据成员，所有数据成员具有相同起始地址。
5、void
void的作用是对函数返回值的限定、对函数参数的限定和声明空类型指针。如果定义函数时不加返回类型限定，则编译器会作为返回整型处理，而不是void, 用void声明的函数表示该函数无返回值；同理，当函数无参数时，可以给无参数函数传送任意类型的参数而不影响程序执行，只有用void指明函数参数时，给无参函数传入参数时编译器才会报错。
另外，不同数据类型的指针必须经过类型强制转换后才能相互赋值，而void指针可以接受来自任意数据类型的指针赋值，但void指针不能在没有强制类型转换下直接赋值给其它类型的指针。
二、控制语句关键字 1、循环语句类型关键字（5个）
序号关键字说明1for遍历循环2do其后紧跟循环体3while条件循环或死循环4break跳出当前循环5continue终止本次循环，开始下次循环 2、条件语句类型关键字（3个）
序号关键字说明6if条件语句7else条件语句否定分支8goto无条件跳转语句 重点说明：
goto语句，有人主张禁用，有人主张慎用，个人认为用来跳出多重循环还是可以的。
3、开关语句类型关键字 （3个）
序号关键字说明9switch用于多条件判断语句10case多条件判断语句分支11default开关语句的其它分支 重点说明：
switch、case组合语句可以看作为if、else语句的加强版。后者适用于二分支或嵌套较少的分支，前者则在面对多分支情况时有更高的效率。
case语句需要注意的点很多，如：
为了避免多个分支重叠，需要在case结尾加上break;
不要忘了default语句；
case语句的排序问题等。
4、返回语句类型关键字（1个）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63033bbc7c8e23c629ea4ea831d775de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b711f184b664bd94328ad45032d689b4/" rel="bookmark">
			Android 自定义dialog学习之——自定义一个提示框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
最近项目中觉的Android系统的dialog样式太丑，确实也不太好看，就打算自定义一个dialog来使用。
自定义dialog实例demo
1、布局
dialog_alert
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="@dimen/dp_550" android:layout_height="wrap_content" android:layout_gravity="center" android:background="@drawable/new_dialog_bg" android:orientation="vertical"&gt; &lt;!--标题--&gt; &lt;TextView android:id="@+id/tv_title" android:layout_width="match_parent" android:layout_height="@dimen/dp_80" android:layout_marginLeft="@dimen/dp_60" android:layout_marginRight="@dimen/dp_60" android:gravity="center|bottom" android:text="@string/title" android:textColor="@color/color_222222" android:textSize="@dimen/dp_32" android:textStyle="bold" /&gt; &lt;!--提示信息--&gt; &lt;TextView android:id="@+id/tv_msg" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="@dimen/dp_60" android:layout_marginTop="@dimen/dp_36" android:layout_marginRight="@dimen/dp_60" android:layout_marginBottom="@dimen/dp_50" android:gravity="center" android:textColor="@color/color_222222" android:textSize="@dimen/dp_28" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="@dimen/dp_1" android:background="@color/color_E8E8E8" /&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="@dimen/dp_92" android:orientation="horizontal"&gt; &lt;!--取消按钮--&gt; &lt;TextView android:id="@+id/tv_cancel" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center" android:text="@string/tv_cancel" android:textColor="@color/color_666666" android:textSize="@dimen/dp_28" /&gt; &lt;View android:id="@+id/v_line" android:layout_width="@dimen/dp_1" android:layout_height="match_parent" android:background="@color/color_E8E8E8" /&gt; &lt;!--确认按钮--&gt; &lt;TextView android:id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b711f184b664bd94328ad45032d689b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bff7a951b6cd7053c8faa1534e9c7377/" rel="bookmark">
			启动、关闭 MySQL服务 bat命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		:Main
@echo off
echo 获取Administrator权限
cacls.exe "%SystemDrive%\System Volume Information" &gt;nul 2&gt;nul
if %errorlevel%==0 goto Admin
if exist "%temp%\getadmin.vbs" del /f /q "%temp%\getadmin.vbs"
echo Set RequestUAC = CreateObject^("Shell.Application"^)&gt;"%temp%\getadmin.vbs"
echo RequestUAC.ShellExecute "%~s0","","","runas",1 &gt;&gt;"%temp%\getadmin.vbs"
echo WScript.Quit &gt;&gt;"%temp%\getadmin.vbs"
"%temp%\getadmin.vbs" /f
if exist "%temp%\getadmin.vbs" del /f /q "%temp%\getadmin.vbs"
exit :Admin
echo 成功获取Administrator权限
echo 检测MySQL状态
for /f "skip=3 tokens=4" %%i in ('sc query MySQL57') do set "zt=%%i" &amp;goto :next
:next
if /i "%zt%"=="RUNNING" (
echo MySQL服务运行中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bff7a951b6cd7053c8faa1534e9c7377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37999cee5d342bfb1e30d829370e62c4/" rel="bookmark">
			STM32F103驱动DS18B20温度传感器(程序注释超详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32F103驱动DS18B20温度传感器 关于DS18B20的原理和时序就不作太多叙述了！网上有的是，自己找吧！
驱动地址https://download.csdn.net/download/qq_41151593/12816464
1.复位操作：引脚拉低——延时480-960us——引脚高——延时15-60us void DS18B20_RST(void) // 1.复位操作: 引脚拉低——延时480-960us——引脚高——延时15-60us { DS18B20_IO_OUT(); //切换为输出模式 OutputDS = 0;//拉低 delay_us(750); OutputDS = 1;//拉高 delay_us(15); } 2.等待响应（相当于检验设备是否正常）： 将引脚设置为输入模式——判断引脚低电平时间是否大于60us、小于240us——返回应答结果 int DS18B20_Check(void) //响应1--失败	响应0----成功 {	//2.应答操作:	将引脚设置为输入模式——判断引脚低电平时间是否大于60us、小于240us——返回应答结果 uint8_t retry=0; DS18B20_IO_IN();	//切换到输入模式 while(InputDS &amp;&amp; retry&lt;200) //引脚一直为高，未被设备主动拉低。提供200us的超时时间 { retry++; delay_us(1); } if(retry&gt;=200) return 1;	//超时仍为响应（200us） else retry=0; while(!InputDS &amp;&amp; retry&lt;240)// 引脚响应则 判断引脚低电平时间是否大于60us、小于240us——返回应答结果 { retry++; delay_us(1); } if(retry&gt;=240)return 1; //应答过时，检查失败 //	printf("true\r\n"); return 0; //检验成功，返回0 } 3.读0、读1操作 uint8_t DS18B20_Read_Bit(void) //3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37999cee5d342bfb1e30d829370e62c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2509673fe83d7c537c2d5340561144c/" rel="bookmark">
			Rabbit实战之（四）消息确认消费机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		消息确认消费机制 消息高可用和确认消费常见消息确认模式介绍基于自动模式消费确认基于手动模式确认 消息高可用和确认消费 RabbitMQ在实际使用过程中，如果配置或使用不当，则会出现令人头疼的问题，下面列举三个
不知道发送的消息是否成功，生产者将消息发送出去，但是如果消息模型不存在，队列不存在，就是发送失败的，这一点作为生产者要知道
解决方案
RabbitMQ会要求生产者在发送完信息后，进行发送确认，当成功就代表消息成功的发送出去，在配置文件中 @Bean public RabbitTemplate rabbitTemplate(){ // 设置“发送消息后返回确认信息” connectionFactory.setPublisherReturns(true); // 构造发送消息组件实例对象 RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory); // 这里是为了消息确认和手动ACK rabbitTemplate.setMandatory(true); // 设置消息在传输中的格式，在这里采用JSON的格式进行传输 rabbitTemplate.setMessageConverter(new Jackson2JsonMessageConverter()); // 发送消息后，如果发送成功，则输出“消息发送成功”的反馈信息 rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() { @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) { log.info("消息发送成功:correlationData({}),ack({}), cause({})", correlationData,ack,cause); } }); // 发送消息后，如果发送失败，则输出“消息丢失”的反馈信息 rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() { @Override public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) { log.info("消息丢失:exchange({}),route({}),replyCode ({}),replyText({}),message:{}",exchange,routingKey,replyCode,replyText, message); } }); // 最终返回RabbitMQ的操作组件实例RabbitTemplate return rabbitTemplate; } 上述代码就实现了发送成功的回调
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2509673fe83d7c537c2d5340561144c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d24eb16b8467a1b7a9b3d12010b6180b/" rel="bookmark">
			python第三方库安装在哪儿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般都在python安装路径下的Lib\site-packages目录 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77ee84519c25e967186af0409f416a17/" rel="bookmark">
			Java 封装阿里云 RocketMQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
基于阿里云rocketMQ收发消息进行封装，介于官方的案例实在太不灵活。在项目开发中耦合度太高，故封装一套嵌入方便的组件，希望能够有所帮助。
不做过多介绍，本文主要是针对收发消息进行介绍，解锁更多功能可以参考官方文档。
以下内容只列举了部分代码，完整代码实现请参考：
https://gitee.com/DHing/ali-rocket-mq/tree/master/rocket-mq
1.导入最新client:
compile 'com.aliyun.openservices:ons-client:1.8.7.1.Final' 基础配置（参考官方文档demo） @Configuration @ConfigurationProperties(prefix = "rocketmq") @Data @Component @ConditionalOnProperty(prefix = "rocketmq",name = "config",havingValue = "true") public class MQProperties { private String accessKey; private String secretKey; private String nameSrvAddr; private String groupId; } ----------- bootstrap.yml rocketmq: config: true accessKey: ******* secretKey: ******* nameSrvAddr: ****** groupId: ****** 2.定义Producer:
/** * 阿里MQ生产者 * */ @Slf4j public class AliMQProducerProcess extends AbstractMessageProducerProcess { private Producer producer; private static volatile AliMQProducerProcess INSTANCE; private AliMQProducerProcess() { } public static AliMQProducerProcess getInstance() { if (INSTANCE == null) { synchronized (AliMQProducerProcess.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77ee84519c25e967186af0409f416a17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f069b9e043899736e366d1e93e128679/" rel="bookmark">
			jmeter jvm堆内存设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改bin目录下的jmeter.bat文件
if not defined HEAP(
set HEAP=-Xms2g -Xmx2g -XX:MaxMetaspaceSize=256m
)
64位操作系统，系统内存足够大可以尽量设置大，最好不超过32g
还有建议在jmeter4.0后
Windows添加setenv.bat文件
set HEAP=-Xms2g -Xmx2g -XX:MaxMetaspaceSize=256m
linux环境添加setenv.sh文件
export HEAP="set HEAP=-Xms2g -Xmx2g -XX:MaxMetaspaceSize=256m"
在4.0版本Windows环境添加setenv.bat 文件后重启jmeter发现没有生效。
查看jvm设置是否生效的方法，最好使用jdk下bin目录中的java visualvm工具查看
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/353/">«</a>
	<span class="pagination__item pagination__item--current">354/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/355/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>