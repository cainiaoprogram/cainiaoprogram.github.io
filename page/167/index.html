<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c2e22bcbea36b9197150e92dfbe740f/" rel="bookmark">
			编写一个golang websocket示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例代码：// 创建一个websocket对象 var ws, _ = websocket.Dial("ws://localhost:8000/echo", "", "http://localhost")// 发送消息 if err := ws.Send([]byte("hello world")); err != nil { log.Fatal(err) }// 接收消息 if msg, err := ws.Recv(0); err != nil { log.Fatal(err) } else { fmt.Printf("收到消息：%s\n", msg) }// 关
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef3a68a8056ac9aa648517cf5d29f5e0/" rel="bookmark">
			如何探索一个数据集的有趣特征，具体一些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要探索一个数据集的有趣特征，可以先进行数据可视化，比如画出数据的直方图、柱状图等，以及做出散点图，以便更直观地查看数据的分布和特征。此外，还可以分析数据的相关性、数据的统计特征，以及使用机器学习算法来发现数据的潜在特征等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e90f4d8d7ccfc9d860721170bb2d5f18/" rel="bookmark">
			html&#43;css&#43;js实现转盘抽奖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;转盘&lt;/title&gt; &lt;style&gt; .zp { position: relative; border-radius: 100%; width: 300px; overflow: hidden; margin:0 auto; } .zp-panel { background: url(./assets/dial.png) no-repeat center center; background-size: 100%; width: 300px; height: 300px; position: relative; transform: rotate(25deg); transition: transform 3s ease-out; } .item { font-size: 12px; position: absolute; top: 50%; left: 0; right: 0; text-align: center; margin-top: -7px; line-height: 1; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e90f4d8d7ccfc9d860721170bb2d5f18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b843f62e7b240a10d12a25ac8dc2054b/" rel="bookmark">
			杨辉三角代码片段写出来看看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		杨辉三角是一个二阶矩阵，用代码表示就是：int[][] yangHuiTriangle = { {1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1} };
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbb57d48350b030bd7866455a19d372f/" rel="bookmark">
			怎么求解100个正整数的最大公约数python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		答：你可以使用Python中的fractions模块来求解100个正整数的最大公约数。你需要先导入它： import fractions 然后你可以使用fractions.gcd函数来求解： fractions.gcd(100, 200)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf1d3b8b3a46ca7edaa167c0bbb3038/" rel="bookmark">
			springboot操作elasticsearch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我可以给您一些建议：1.在Spring Boot中使用Elasticsearch时，您可以使用Elasticsearch用于支持全文搜索，您可以在Spring Boot应用程序中使用Elasticsearch的Java API来操作它；2.可以使用Spring Data Elasticsearch来操作Elasticsearch，它可以更轻松、更灵活地实现Elasticsearch的操作；3.您可以使用Elasticsearch Rest Client来操作Elasticsearch，它可以提供一个简单的方式来实现对Elasticsearch的操作；4.可以使用Spring Boot Sta
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3fba7d9b666bbc159c4acb91f9e69fe/" rel="bookmark">
			Token和Refresh Token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Token 在计算机身份认证中代表令牌，在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位。
1.1、Jwt简介 JWT(JSON Web Token)是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。
它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证；应用场景如用户登录。
1.2、为什么有Jwt 目前主流的Web开发模式有两种：
基于服务端渲染的传统Web开发模式基于前后端分离的新型Web开发模式 对于这两种开发模式的身份认证，服务端渲染推荐使用 Session认证机制，前后端分离推荐使用JWT认证机制。
对于传统的session认证，因为HTTP是无协议的，为了记住用户状态，服务器在用户第一次访问时会返回一个cookie同时服务端保存一个对应的session，但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，大量session会话的创建对服务器是一个巨大的开销；
同时，当服务端为集群时，用户登录其中一台服务器，会将session保存在该服务器的内存中，
只有再次访问这台服务器才能拿到授权资源。
另外session认证机制依赖Cookie，但是Cookie默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域Session认证。这就有了JWT的出现，流程上是这样的：
用户使用用户名密码来请求服务器服务器进行验证用户的信息服务器通过验证发送给用户一个token客户端存储token，并在每次请求时附送上这个token值服务端验证token值，并返回数据 1.3、Jwt Token结构 JWT由三部分构成，第一部分我们称它为头部（header),第二部分我们称其为载荷（payload)，第三部分是签证（signature)。
header：Header通常由两部分组成：令牌的类型，即JWT。和常用的散列算法，如HMAC SHA256或RSA。 {
“typ”: “JWT”,
“alg”: “HS256”
}
由上可知，该token使用HS256加密算法，将头部进行base64加密（该加密是可以对称解密的)，构成了第一部分：
eyJhbGciOiJIUzI1NiJ91
Playload：载荷就是存放有效信息的地方，这些有效信息包含三个部分
1、 Registered claims（注册声明）: 这些是一组预先定义的声明，它们不是强制性的，但推荐使用，以提供一组有用的，可互操作的声明。 其中一些是：iss（发行者），exp（到期时间），sub（主题），aud（受众）等
2、Public claims （公开声明）: 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。
3、Private claims（私有声明）: 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。
{
“iss”: “Online JWT Builder”,
“iat”: 1416797419,
“exp”: 1448333419,
…….
“userid”:10001
}
有效载荷中存放了token的签发者（iss）、签发时间（iat）、过期时间（exp）等以及一些我们需要写进token中的信息。然后将其进行base64加密，得到Jwt的第二部分：
eyJ1c2VyaWQiOjB91
Signature：这个部分需要base64加密后的header和base64加密后的payload使用，连接组成的字符串(头部在前)，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。 例如头部与载体加密拼接后的字符串为eyJhbGciOiJIUzI1NiJ91.eyJ1c2VyaWQiOjB91再次利用加密算法（HS256）与自定义的密钥（secret）加密得到签名部分字符：
rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM
将上面三个方法生成的字符串再次拼接就得到了完整的Token:
eyJhbGciOiJIUzI1NiJ91.eyJ1c2VyaWQiOjB91.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM
如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个Token的内容被别人动过的，我们应该拒绝这个Token
1.4、JWT的优缺点 优点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3fba7d9b666bbc159c4acb91f9e69fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd44794a9fb0d9f36b780a24236c1518/" rel="bookmark">
			帮我写一篇关于基于51单片机的智能温控风扇的论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很高兴能够为您服务。基于51单片机的智能温控风扇是一种利用51单片机技术来控制温度并调节风扇速度的系统。为了解决传统温控器存在的低效率和节能问题，该设计采用51单片机，通过控制风扇的转速来调节室内温度，具有节能、可靠性高等特点。本文将介绍该系统的结构和工作原理，重点分析51单片机的控制原理、温度传感器的原理及温度控制策略，以及该系统的实际应用及结果分析。最后，本文将提出一些改进措施，为未来应用提供参考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26ad5fb43942f2e03c6edfdf094304f2/" rel="bookmark">
			写一个51单片机点灯程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序如下：sbit P1_0 = 0x90; //定义P1_0口void main() { while(1) { P1_0 = 0; //点亮LED delay(1000); //延时1秒 P1_0 = 1; //熄灭LED delay(1000); //延时1秒 } }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edc354489c392e092084c951788882b6/" rel="bookmark">
			纪念20元老爷爷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一年级有关爷爷的作文100字（一）
一年级有关爷爷的作文100字（二）
一年级有关爷爷的作文100字（三）
一年级有关爷爷的作文100字（四）
一年级有关爷爷的作文100字（五）
感恩爷爷的作文800字（一）
感恩爷爷的作文800字（二）
描写老爷爷的作文（一）
描写老爷爷的作文（二）
...
关于爷爷的作文高中（一）
关于爷爷的作文高中（二）
我的爷爷的作文500字（一）
我的爷爷的作文500字（二）
我的爷爷的作文500字（三）
感谢爷爷的作文600字（一）
感谢爷爷的作文600字（二）
感谢爷爷的作文600字（三）
写爷爷的作文600字（一）
写爷爷的作文600字（二）
描写爷爷的作文700字（一）
描写爷爷的作文700字（二）
怀念爷爷的作文800高中（一）
怀念爷爷的作文800高中（二）
写爷爷的作文800字高中（一）
写爷爷的作文800字高中（二）
我的爷爷个子不高，头发都花白了，走起路来很精神，一天到晚脸上总是笑呵呵的。以下是由出国留学网小编为大家整理的“一年级有关爷爷的作文100字”，仅供参考，欢迎大家阅读。
一年级有关爷爷的作文100字（一） 爷爷今年六十开外，花白的头发，满脸的皱纹，说起话来慢条斯理，精神很好，走起路来娇健如飞。
我爷爷在厂工作认真，技术很好，他带了好多徒弟，徒弟都说他是好师傅，因为他传、帮、带、教毫不保留，使徒弟们在短短的时间中学会了很多技术。
现在退休了，在家里安度晚年。他很喜欢我，我和妹妹都是他带大的，我的爷爷好辛苦呀！我爱我的爷爷，我希望他长寿。
一年级有关爷爷的作文100字（二） ＂每天下午，爷爷都会在客厅里聚精会神地看报纸。
爷爷看报纸时表情很丰富。他有的时候皱皱眉毛，那是因为他看到某个城市道路塌陷的新闻；他有的时候瞪大眼睛，那是因为他看到一个小男孩，五岁就能背五百首诗歌；他有的时候气得直跺脚，那是因为他看到一个小女孩，被坏人拐走了。
他看完一份报纸，再将柜子上的报纸拿起来继续看。我的爷爷真是一个报纸迷呀！＂
一年级有关爷爷的作文100字（三） 我的爷爷今年70了，爷爷的眼睛小小的，有一下巴胡子。 来源：日记
爷爷有一个特点，就是力大无穷，有一次，我在花园里玩，爷爷让我回家，但我不想回家，爷爷一下子把我提溜起来，给我夯回了家，我的左胳膊被爷爷拽的痛死了，痛的呀呀直叫。
爷爷还有一个特点，他是个烙馍高手，水平比我婆婆高多了。有一次，爷爷和婆婆比赛，爷爷和婆婆各拿一点面，各自做一个馍，并各自把自己的馍放进烤炉里，不一会，两个香喷喷的馍出炉了，我和贝贝姐姐尝了尝，我和贝贝姐姐异口同声的回答：爷爷做的最好吃。
我有一个好爷爷。
一年级有关爷爷的作文100字（四） 爷爷要栽花了，在事先平整好的一小块地上挖了几排小坑，然后蹲下身，小心翼翼地把一撮撮小花苗和菜秧分开，一只手拽着小苗的茎，另一只手托住小苗根部连带的小土块轻轻地分别放进小坑里，接着又把挖出来的`土重新填进坑内，用两手把根部的土按一按，最后再给它们一棵棵浇上水。
一年级有关爷爷的作文100字（五） 我特别喜欢我的爷爷，因为他特别可爱。爷爷是个地道的庄稼人，一辈子没有读过书，不识一个字。我问：“爷爷，您没读过书后不后悔呀？“爷爷笑笑：“不后悔“。我很爱爷爷这个驼背的小老头。虽然不怎么喜欢我的外爷，但我却很佩服他，因为他算是我的爷爷奶奶，外婆外爷当中最有文化的人了。外爷会吹笛子，拉二胡，书法也不错，而且他当了一辈子的村长。
...
感恩是中华民族传统美德，下面是由出国留学网编辑为大家整理的“感恩爷爷的作文800字”，仅供参考，欢迎大家阅读。
感恩爷爷的作文800字（一） “苔痕阶上绿，草色入帘青，谈笑有鸿儒，往来无白丁，可以调素琴，阅金经。”
每当念起刘禹锡的这首《陋室铭》，我就不禁想起一个人，那就是爷爷，远在老家的爷爷。
退休的爷爷，回到了他一直念念不忘的小山村。那里有他热爱的青山，有他热爱的大海，原来这就是颐养天年。
退休了，爷爷终于有时间做自己想做的事了，菜园就是其中之一。半年时间，一块黄土平地，变成了全村人都羡慕的农庄。
来到爷爷的农庄，首先让你眼前一亮的是农庄的围栏。你简直不会相信那是一位六十多岁高龄的老人独自所建的。围栏不是用木板拼造成的，爷爷用废旧的细软管，编成网，系在木桩上，既节约木料又省时间，而且非常美观，我先前几乎不敢想这细软管还有如此作用。围栏内是各种各样的蔬菜，绿油油的青菜长势旺盛，圆圆的番茄绿中透红，一颗颗小豌豆荚挂满枝头……整个农庄一片生机盎然，经过此地的人总忍不住驻足观望。
讲到爷爷的农庄，就有必要讲讲爷爷的石屋，这是农庄的一大亮点，也是爷爷的心血。它是用石头一层一层垒起来的，每层之间用泥土夯实。房顶用页岩铺了一半，另一半做了一个小平台，从屋外的梯子可以上去，上面放了一些爷爷种的花花草草。石屋旁边是一个绿茵茵的葡萄藤架，架下摆放着一些多肉植物，喜阴的它们长得矮矮胖胖，特别惹人喜欢。
石屋内还有一处你意想不到的地方，那就是地窖。爷爷在阴凉通风处挖了一个大约十立方米的洞，用铁丝网挡了，里面储存收获的作物。地窖的打开方式是任何人都想不到的，我试了试。上移，侧移，还是找机关，都不管用！只见爷爷得意地走了过来，从地窖门边抽出两根木条来，我揉了揉眼睛，刚才哪有看见这个东西？原来爷爷做了一个卡槽，铁丝网插入后还有空余，就将两根木条插了进去，卡得紧紧的，很难发现有异。我拍手鼓掌，兴奋地说：“爷爷太牛了，那个流落荒岛的鲁宾逊都没你厉害！”
爷爷一天到晚总在他的菜园忙碌，翻土、浇水、施肥，照顾他的小南瓜、小萝卜、小芹菜……现在我家餐桌上三分之二的蔬菜都来自爷爷那神奇的农庄。有时，爷爷闲下来就坐在葡萄架下，望望他的绿色伙伴，喝喝茶，与邻里聊聊天。生活过得清闲而又舒心。
爷爷的农庄，人间的世外桃源，不禁又使我想起：无丝竹之乱耳，无案牍之劳形。南阳诸葛庐，西蜀子云亭。孔子云：何陋之有？
感恩爷爷的作文800字（二） 在现在的生活中，我们何时何地都能看见木头。如桌子、梳子、纸……他们都是木头加工后所得来的。它们出自山村。
木头总被堆在家门前的大院中，为了不妨碍进出，它被摆在角落的一边。木头是爷爷从山中砍来的，还蘸着水汽，湿湿的。木头很粗糙，上面总有一些小刺冒出，一不小心，便在手上留下一道长印子。
有一段时间，爷爷会在院子劈木头，我也喜欢站在一旁学爷爷的样子。每当这种时候，爷爷会把我赶进屋子中，让我自己先到一边玩。而我呢，会偷偷地趴在窗前，看爷爷搬弄一段一段的木头。
爷爷用脚把木头固定稳，举起斧头，熟练的、迅速的、用力的把木头从中间劈开。时不时的抬手擦一下脸上的汗珠。
趁着爷爷歇口气的时间，我偷偷溜进院中，拿着斧头，学着爷爷的样子。圆圆的木头，中间有一圈又一圈的花纹。学校的课桌上，也有这样深浅不一的线条。...
说起爷爷，你是怎样描述你的爷爷的呢？下面是由出国留学网编辑为大家整理的“描写老爷爷的作文”，仅供参考，欢迎大家阅读。
描写老爷爷的作文（一） 提起爷爷来，他今年已经五十多岁了，个子高高的，额头上有几丝皱纹，像有一些虫子趴在上面。高高的鼻梁上挂着一幅精致的眼镜，我常说，爷爷的眼镜简直像个天文望远镜那样，神气极了。还有一张饱经风霜的脸，走起路来就像一位军人。
爷爷是一位老师，在我眼里，爷爷是最慈祥的老人，他从来都不乱发脾气，对我们是这样，对他的学生也是这样。记得在我三年级的时候，我非常讨厌写作文，每次写得不是重复了就是没了尾，写着写着就不耐烦了。爷爷见我这样，给我上了一堂作文课并给我讲了一个故事：“从前有座山，山上有座庙，庙里有两个和尚在讲故事……”我认真地听着。“有一天，老和尚给小和尚讲故事。老和尚说，从前有座山，山上有座庙，庙里有两个和尚……”我开始听得不耐烦了，说：“不行不行，来来去去多是那几句话，换一个，换一个！”爷爷又说起了另一个故事：“从前有只兔子，他跑了。我的故事完了。”“不行，这算什么故事。”我生气地说。但爷爷却语重心长的对我说：“这就是你写作文时常常犯的错误。”我低下了头，心里有说不出的话来……从此，我就认真地写好每一次的作文。
爷爷不但对我学习严格的态度，而且，对我生活上点点滴滴的坏习惯，我觉得挺厉害的！假如：做事有头无尾、总是丢三落四的等等。现在，在爷爷的引导下，我已经在学习上、生活上慢慢地形成了一种自然、良好的习惯。在这里，我说一声，我要感谢我的好爷爷，我最尊敬的爷爷！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edc354489c392e092084c951788882b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/441ed8b5483e2b36acf62cf1f75ce96b/" rel="bookmark">
			JVM——Java虚拟机详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 1.什么是JVM? JVM——Java虚拟机，它是Java实现平台无关性的基石。
Java程序运行的时候，编译器将Java文件编译成平台无关的Java字节码文件（.class）,接下来对应平台JVM对字节码文件进行解释，翻译成对应平台匹配的机器指令并运行。
同时JVM也是一个跨语言的平台，和语言无关，只和class的文件格式关联，任何语言，只要能翻译成符合规范的字节码文件，都能被JVM运行。
内存管理 2.能说一下JVM的内存区域吗？ JVM内存区域最粗略的划分可以分为堆和栈，当然，按照虚拟机规范，可以划分为以下几个区域：
Java虚拟机运行时数据区
JVM内存分为线程私有区和线程共享区，其中方法区和堆是线程共享区，虚拟机栈、本地方法栈和程序计数器是线程隔离的数据区。
1、程序计数器
程序计数器（Program Counter Register）也被称为PC寄存器，是一块较小的内存空间。
它可以看作是当前线程所执行的字节码的行号指示器。
2、Java虚拟机栈
Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。
Java虚拟机栈描述的是Java方法执行的线程内存模型：方法执行时，JVM会同步创建一个栈帧，用来存储局部变量表、操作数栈、动态连接等。
3、本地方法栈
本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。
Java 虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。
4、Java堆
对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java里“几乎”所有的对象实例都在这里分配内存。
Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现新生代、老年代、Eden空间、From Survivor空间、To Survivor空间等名词，需要注意的是这种划分只是根据垃圾回收机制来进行的划分，不是Java虚拟机规范本身制定的。
5.方法区
方法区是比较特别的一块区域，和堆类似，它也是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
它特别在Java虚拟机规范对它的约束非常宽松，所以方法区的具体实现历经了许多变迁，例如jdk1.7之前使用永久代作为方法区的实现。
3.说一下JDK1.6、1.7、1.8内存区域的变化？ JDK1.6、1.7/1.8内存区域发生了变化，主要体现在方法区的实现：
JDK1.6使用永久代实现方法区： JDK1.7时发生了一些变化，将字符串常量池、静态变量，存放在堆上 JDK 1.7内存区域
在JDK1.8时彻底干掉了永久代，而在直接内存中划出一块区域作为元空间，运行时常量池、类常量池都移动到元空间。
JDK 1.8内存区域
4.为什么使用元空间替代永久代作为方法区的实现？ Java虚拟机规范规定的方法区只是换种方式实现。有客观和主观两个原因。
客观上使用永久代来实现方法区的决定的设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法 （例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。主观上当Oracle收购BEA获得了JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的 时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。 5.对象创建的过程了解吗？ 在JVM中对象的创建，我们从一个new指令开始：
首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程类加载检查通过后，接下来虚拟机将为新生对象分配内存。内存分配完成之后，虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。接下来设置对象头，请求头里包含了对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。 这个过程大概图示如下：
对象创建过程
6.什么是指针碰撞？什么是空闲列表？ 内存分配有两种方式，指针碰撞（Bump The Pointer）、空闲列表（Free List）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/441ed8b5483e2b36acf62cf1f75ce96b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5d5bdd2919a99f9995a13596483767e/" rel="bookmark">
			ReentrantLock公平锁和非公平锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公平锁是指多个线程在等待同一个锁时，必须按照申请锁的先后顺序来一次获得锁。
公平锁的好处是等待锁的线程不会饿死，但是整体效率相对低一些；非公平锁的好处是整体效率相对高一些，但是有些线程可能会饿死或者说很早就在等待锁，但要等很久才会获得锁。其中的原因是公平锁是严格按照请求所的顺序来排队获得锁的，而非公平锁时可以抢占的，即如果在某个时刻有线程需要获取锁，而这个时候刚好锁可用，那么这个线程会直接抢占，而这时阻塞在等待队列的线程则不会被唤醒。
公平锁是将所有线程依次放入CLH同步队列，然后再从队列中依次取出来执行；而非公平锁是部分已经进入同步队列的线程会像公平锁一样获取锁，但是其他尚且没有进入同步队列的线程可以与CLH同步队列中的首节点线程竞争锁；从代码里看，新线程可以直接竞争锁，在释放锁时，只把AQS 队列的头节点线程唤醒，剩余节点并没有唤醒。
试验一下：公平锁顺序123打印比非公平锁的顺序打印，概率要大
public class Test { private Lock lock = null; public static void main(String[] args) throws InterruptedException { Test test = new Test(); //公平锁 //test.setLock(new ReentrantLock(true)); //非公平锁 test.setLock(new ReentrantLock()); for(int i=0;i&lt;20;i++) { new Thread(new Runnable() { @Override public void run() { test.testFair(); } },"线程"+i).start(); } } private void testFair() { lock.lock(); System.out.println(Thread.currentThread().getName()+"拿到了锁"); lock.unlock(); } public Lock getLock() { return lock; } public void setLock(Lock lock) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5d5bdd2919a99f9995a13596483767e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4429cb3ce10c188a832ed8d29c9d2e1b/" rel="bookmark">
			LeetCode第529题：扫雷游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		让我们一起来玩扫雷游戏！
给你一个大小为 m x n 二维字符矩阵 board ，表示扫雷游戏的盘面，其中：
'M' 代表一个 未挖出的 地雷，
'E' 代表一个 未挖出的 空方块，
'B' 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的 已挖出的 空白方块，
数字（'1' 到 '8'）表示有多少地雷与这块 已挖出的 方块相邻，
'X' 则表示一个 已挖出的 地雷。
给你一个整数数组 click ，其中 click = [clickr, clickc] 表示在所有 未挖出的 方块（'M' 或者 'E'）中的下一个点击位置（clickr 是行下标，clickc 是列下标）。
根据以下规则，返回相应位置被点击后对应的盘面：
如果一个地雷（'M'）被挖出，游戏就结束了- 把它改为 'X' 。
如果一个 没有相邻地雷 的空方块（'E'）被挖出，修改它为（'B'），并且所有和其相邻的 未挖出 方块都应该被递归地揭露。
如果一个 至少与一个地雷相邻 的空方块（'E'）被挖出，修改它为数字（'1' 到 '8' ），表示相邻地雷的数量。
如果在此次点击中，若无更多方块可被揭露，则返回盘面。
来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/minesweeper
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
解题思路： 题目要求点击一个方块时，若该方块周围（最多8个方块）都不是雷，则需要点击周围方块。
所以采用递归的方式点击。
构建递归函数void dfs(....)。需传递矩阵board信息和点击位置(x,y)。
1、检测位置是否合法。越界 或者 该位置已被点开，直接退出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4429cb3ce10c188a832ed8d29c9d2e1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3ea378844de7ee2df294d5db4e9ebe8/" rel="bookmark">
			NSIS入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NSIS简介 NSIS是"Nullsoft 脚本安装系统"(Nullsoft scriptable Installation System)的缩写，它是是一个免费的win32安装、卸载程序，可以打包windows应用程序。
打包步骤 下载NSIS脚本安装系统，启动NSIS Edit
引用了急支糖浆的图片
注：这里有一些信息使用了变量来表示，因为脚本中可能会在多个地方使用，使用变量可以方便修改，统一管理。这些变量在下面的脚本中会设置相应的值。
; 该脚本使用 HM VNISEdit 脚本编辑器向导产生 ; 安装程序初始定义常量 !define PRODUCT_NAME "HTE加密程序" !define PRODUCT_VERSION "1.05" !define PRODUCT_PUBLISHER "gyc" !define PRODUCT_DIR_REGKEY "Software\Microsoft\Windows\CurrentVersion\App Paths\HTE加密程序.exe" !define PRODUCT_UNINST_KEY "Software\Microsoft\Windows\CurrentVersion\Uninstall\${PRODUCT_NAME}" !define PRODUCT_UNINST_ROOT_KEY "HKLM" SetCompressor lzma ; ------ MUI 现代界面定义 (1.67 版本以上兼容) ------ !include "MUI.nsh" ; MUI 预定义常量 !define MUI_ABORTWARNING !define MUI_ICON "a6ob4-47ow2-001.ico" !define MUI_UNICON "a0280-9m4nb-001.ico" ; 语言选择窗口常量设置 !define MUI_LANGDLL_REGISTRY_ROOT "${PRODUCT_UNINST_ROOT_KEY}" !define MUI_LANGDLL_REGISTRY_KEY "${PRODUCT_UNINST_KEY}" !define MUI_LANGDLL_REGISTRY_VALUENAME "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3ea378844de7ee2df294d5db4e9ebe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/139a681de3b148c643d412f367332a81/" rel="bookmark">
			【投屏】Scrcpy源码分析三（Client篇-投屏阶段）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scrcpy源码分析系列
【投屏】Scrcpy源码分析一（编译篇）
【投屏】Scrcpy源码分析二（Client篇-连接阶段）
【投屏】Scrcpy源码分析三（Client篇-投屏阶段）
【投屏】Scrcpy源码分析四（最终章 - Server篇）
前一篇我们探究了Scrcpy Client端连接阶段的逻辑，这一篇我们继续探究Client端的投屏阶段。
Client篇-投屏阶段 1. 音视频和FFmpeg1.1 音视频基础1.1.1 编码/解码1.1.2 容器1.1.3 音视频播放流程 1.2 FFmpeg 2. 投屏阶段2.1 ``sc_screen_init`` - 对窗口进行初始化2.2 `sc_demuxer_start` - 分流和解码2.3 ``event_loop`` - 事件循环2.4 ``sc_keyboard_inject_init`` &amp; ``sc_mouse_inject_init`` - 键鼠事件2.5 ``sc_controller_start`` - 事件的收发2.6 时序图 3. 小结 1. 音视频和FFmpeg 因为投屏阶段用到了很多音视频编解码知识和FFmpeg相关的API，所以在继续分析代码之前，我们先简单快速地回顾一下这些内容。因FFmpeg功能很广，我们只介绍Scrcpy中用到的一部分。
1.1 音视频基础 1.1.1 编码/解码 编码（Encode）- 将一种音视频格式文件（通常是原始、未经压缩的）通过压缩技术转换成另一种格式文件。
解码（Decode）- 将压缩后的音视频格式文件还原成原始的音视频格式文件。
通常我们所说的编解码器（Codec），就是同时包含了编码和解码的能力。
编码的意义在于，未经压缩的原始类型，数据流是非常大的，不利于存储和网络传输，所以需要对其进行编码。常见的视频原始类型有YUV、RAW等，音频原始类型有PCM。常见的视频编码类型有H264、H265等，音频编码类型有AAC、MP3。
1.1.2 容器 容器通常指包含了多路流的封装格式。比如一个容器内可以包含音频流、视频流、字幕流等，而对应音频流和视频流的数据格式就是音视频的编码类型。
混流/复用（mux）- 将多个流混合到一个容器中。
分流/解复用（demux）- 从一个容器中分解成多个流。
常见的容器有MP4、FLV、MKV、AVI。
1.1.3 音视频播放流程 音视频播放的流程通常是：
编码 混流 分流 解码 采集 YUV H264 传输 H264 YUV 播放 如果只需要音频或视频则，则混流/分流的过程可以省略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/139a681de3b148c643d412f367332a81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0df06d2d400993678d2567ffc78204e7/" rel="bookmark">
			5年软件测试工程师分享的自动化测试经验，一定要看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天给大家分享一个华为的软件测试工程师分享的关于自动化测试的经验及干货。真的后悔太晚找他要了，
纯干货。一定要看完！ 1.什么是自动化测试？
用程序测试程序，用代码取代思考，用脚本运行取代手工测试。自动化测试涵盖:功能(黑盒)自动化测试、功能(白盒)自动化测试、性能测试、压力测试、GUI(Graphical User Interface)测试、安全测试等。
我个人的理解:
自动化测试是测试思想的延伸，为测试工程师提供了“触手”。它的行为可以看作是一种工具，但本质上，自动化测试还是一种思想。
顺带一提，狭义的自动化测试是指基于GUI的自动化测试，以及单元测试和API测试，你有没有想过没有任何工具的情况下如何手工完成？因此，它们自然属于测试自动化的范畴。
2.自动化测试的优势
回归测试更方便可靠；可以运行越来越繁琐的测试，而且快速高效；可以执行一些很难或者不可能执行的手工测试，比如大量并发用户；更好的利用资源，具有一致性和可重复性，自动化测试脚本完全可重用；提高软件的可信度；在多个环境中进行测试等。
我个人的理解:
自动化测试的优点是成功完成自动化测试的结论，而自动化测试的缺点是建立自动化项目的基础。
另一个优点:自动化测试可以将产品知识固化成脚本，从而减少测试人员流动对项目的影响。但这种优势的前提是这些脚本容易维护，需要一些必要的文档，这是另外一个话题。
3.自动化测试做不到什么及其缺点
它永远无法完全取代人工测试。自动化测试无法达到手动测试的覆盖范围。不是每个测试用例都适合自动化。如果你提供页面布局是否正确的建议，手工测试会发现比自动化更多的缺陷。
与手工测试相比，自动测试几乎找不到新的缺陷，最大的目的是实现回归测试，保证以前的bug不会在新版本中重现；另外，自动化测试工具已死，它没有任何想象力；自动化测试的质量完全取决于测试工程师。成本高，风险大；对测试人员的技术要求高，对测试工具也有要求。
4.适当引入自动化
项目周期长，系统版本不变，需求不会频繁变化，适合在这个时候引入自动化测试。
系统的测试对象是否可以正常识别，对于无法识别的控件是否可以提供解决方案。
系统中没有太多无法识别的第三方控件。
成千上万的系统测试需要重复测试，如可靠性测试和回归测试。
5.不适合自动化
项目周期短，需求变化频繁。即使是长期项目，如果需求变化频繁，也不适合自动化。
如果软件版本不稳定，主要功能或大量功能可能会再次更改，不适合自动化；
项目测试自动化没有明确的计划、度量和管理。大多数对象无法识别，脚本维护频繁且困难。其中之一就是自动化会失败。
6.自动化测试过程
合理的自动化突破点:通常一个项目只有经过完整的系统测试，才能满足引入测试自动化的基本条件。
我个人的理解:
不管什么样的测试，越早介入越有利于降低成本和风险。随着新开发模式的兴起，自动化测试也具备了尽快介入的条件。比如在敏捷开发中，一个核心模块的核心功能完成后，就可以开始对该模块的这个功能进行自动测试。
7.测试自动化分析
(1)可行性分析；
(2)采样demo分析，demo一般选择冒烟测试用例，检查脚本是否能成功运行，设计的测试点是否全部执行；
(3)测试需求分析，哪些功能点做好了自动化的准备。
8.测试流程和设计
测试计划定制:自动化测试计划越全面，后期实施越有规律，自动化测试成功率越高。
计划跟不上变化，有时候太全面，未必是好事。
自动化测试设计阶段:主要分为自动化测试框架和自动化测试用例。
(1)自动化测试框架的设计、开发和构建:针对各个独立项目的无人值守测试框架，可以保证测试的分布式执行、脚本模块化、数据驱动、日志分析、错误截图、报表恢复、共享对象库、公共函数库、环境配置、统一设计模式、异常处理、场景恢复。
(2)自动测试用例设计三部曲:手动测试用例从零开始，然后根据手动测试用例编写自动测试用例。首先，筛选手动测试用例。然后转化手动测试用例，最后添加和补充自动测试用例。
9.为什么自动化测试用例不能完全取代手工测试？
自动化测试用例的范围往往是核心业务流程或者重复执行率高，自动化测试的覆盖率达不到手工测试的覆盖率。一般自动化测试的用例选择主要是正向的，但也有很多逆向的案例，但并不是所有的逆向案例都会被自动化测试覆盖，而是有一部分筛选。
并非所有的手动测试用例都可以用于自动化，例如检查页面布局。手动测试可能不需要回到原点，但自动测试往往是必要的。与手动测试用例不同，自动化测试用例不需要在每一步都写出预期的结果。
我个人的理解:
通常我做自动测试的时候会写一个测试用例叫做shake-down test。这个测试用例会遍历系统中所有完成的表单，只需做一个Navigate操作就可以保证一个页面是否可用。
每次回归测试之前，可以运行shake-down test一次，就可以快速确定哪些函数是accessible，相当于对整个系统做了一次冒烟测试。
10、测试脚本设计与开发
测试脚本可以大致分为:
(1)线性脚本:通过录制直接生成的线性可执行脚本
(2)结构化脚本:具有顺序、循环、分支等结构的脚本
(3)共享脚本:可以被多个测试用例使用并被其他脚本调用的脚本(即模块化脚本)
(4)数据驱动脚本:将测试数据从业务流程控制中分离出来，通过读取数据文件来驱动流程的脚本。
(5)关键字驱动脚本:脚本、数据和业务分离，数据和关键字在不同的数据表中，测试业务逻辑由关键字驱动。关键字驱动的特点是更像是描述一个测试用例在做什么，而不是如何做。
(6)混合脚本:上述任意两种或多种
11.自动化测试执行
(1)无人值守测试:环境建设、部署、配置；自动化测试用例绑定到测试脚本；自动测试用例执行顺序的排列和组合
(2)异常处理和场景恢复
提交自动化测试产品:大致需要提交实施状态、测试结果、分析报告、测试报告、质量状况等。
测试脚本维护：严格来说，测试脚本维护是分阶段进行的。不值得维护的自动化测试项目不值得建立。
能看到这，说明你是真心想好好学习自动化测试的，那么必须给爱学习的朋友分享一些资料
绵薄之力~
为了帮助大家迅速建立测试思维能力，早日斩获大厂Offer、掌握职场话语权，下面这份《软件测试全栈学习路线图》应该会对你很有帮助
从测试概念到最后的测试开发，希望大家能照着这个体系，在3-4年内完成这样一个体系的构建，可以说，这个过程会让你痛不欲生，但只要你熬过去了，以后的生活就会轻松很多，正所谓完事开头难，只要迈出了第一步，你就已经成功了一半，古人说的好：不积跬步无以至千里，等到完成之后在回顾这段路程的时候，你肯定会感慨良多，掌握了以上技术，在任何一线互联网大厂测试岗位都能独挡一面
下面是一些配套的资源，希望能帮到大家 这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你!有需要的小伙伴可以点击下方小卡片领取 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ac3528897134f0197ff000df6b0dfb/" rel="bookmark">
			树莓派 /bin/sh: 1: /usr/bin/apt-listchanges: not found 返回了一个错误号 (1) --apt || test $? -lt 10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题： /bin/sh: 1: /usr/bin/apt-listchanges: not found
E: 子进程 /usr/bin/apt-listchanges --apt || test $? -lt 10 返回了一个错误号 (1)
E: Failure running script /usr/bin/apt-listchanges --apt || test $? -lt 10
解决方案： 选项1： 请试试：
sudo apt purge -f apt-listchanges 然后尝试：
sudo apt install -f apt-listchanges 选项2： 请试试：
sudo dpkg --remove apt-listchanges 然后尝试：
sudo apt install -f apt-listchanges 选项3： 请试试：
sudo mv /etc/apt/apt.conf.d/20listchanges /etc/apt/apt.conf.d/20listchanges.bak 然后尝试：
sudo apt update &amp;&amp; sudo apt upgrade 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4ac797efc7e1e63a36e044b5c77a9ab/" rel="bookmark">
			Javac命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令行 用法: javac &lt;options&gt; &lt;source files&gt; 其中, 可能的选项包括: -g 生成所有调试信息 -g:none 不生成任何调试信息 -g:{lines,vars,source} 只生成某些调试信息 -nowarn 不生成任何警告 -verbose 输出有关编译器正在执行的操作的消息 -deprecation 输出使用已过时的 API 的源位置 -classpath &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -cp &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -sourcepath &lt;路径&gt; 指定查找输入源文件的位置 -bootclasspath &lt;路径&gt; 覆盖引导类文件的位置 -extdirs &lt;目录&gt; 覆盖所安装扩展的位置 -endorseddirs &lt;目录&gt; 覆盖签名的标准路径的位置 -proc:{none,only} 控制是否执行注释处理和/或编译。 -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程 -processorpath &lt;路径&gt; 指定查找注释处理程序的位置 -d &lt;目录&gt; 指定放置生成的类文件的位置 -s &lt;目录&gt; 指定放置生成的源文件的位置 -implicit:{none,class} 指定是否为隐式引用文件生成类文件 -encoding &lt;编码&gt; 指定源文件使用的字符编码 -source &lt;发行版&gt; 提供与指定发行版的源兼容性 -target &lt;发行版&gt; 生成特定 VM 版本的类文件 -version 版本信息 -help 输出标准选项的提要 -A关键字[=值] 传递给注释处理程序的选项 -X 输出非标准选项的提要 -J&lt;标记&gt; 直接将 &lt;标记&gt; 传递给运行时系统 -Werror 出现警告时终止编译 @&lt;文件名&gt; 从文件读取选项和文件名(多个Java文件写在此文件中) 参数说明 -g -g：在生成的class文件中包含所有调试信息（行号、变量、源文件）-g:none ：在生成的class文件中不包含任何调试信息。 这个参数在javac编译中是看不到什么作用的，因为调试信息都在class文件中，而我们看不懂这个class文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4ac797efc7e1e63a36e044b5c77a9ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fd3221e164ac01c5099f1b7cb317dfc/" rel="bookmark">
			【解决】Pycharm中Terminal无法使用”conda : The term ‘conda‘ is not recognized as the name...“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述：
在安装完Pycharm和Anaconda后，可以通过在Prompt或者Pycharm内部中安装需要的库。比如，在Prompt中的安装通过打开：
进入Anaconda Prompt中进行安装，比如使用pip install numpy等：
其次，还可以通过在Pycharm内部的Terminal进行安装：
但是，会遇到报错的问题，弹出红色警告，报错内容”
”conda : The term 'conda' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.“
二、原因分析：
因为CMD不能识别conda这个命令（测试方法：使用Win+R 打开CMD，运行conda，即可检查是否可以成功识别）：
如果可以成功识别，截图如上所示，否则，就是因为安装了Anaconda后环境变量还没有配置完成。
三、解决方法：
（1）首先，找到Anaconda的安装路径：比如“D:\Anaconda\Scripts”；
（2）然后，打开系统环境变量：
在用户变量或者系统变量中找到PATH，并且双击打开：
添加一个新值, 内容为Anaconda的Scripts目录的路径，点击确定即可。
（3）最后，在CMD中再一次输入conda进行测试，测试通过。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f305f88b81d0d79410ec3e478187c2e8/" rel="bookmark">
			数字图像处理（5）- 图像恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.1 图像恢复概述
1.2 退化模型
1.2.1 连续退化模型
1.2.2 离散退化模型
1.2.3 频域退化模型
1.3 常见退化函数模型及辨识方法
1.3.1 常见的退化函数模型
1.3.2 退化函数的辨识方法
1.4 噪声模型
1.4.1 常见噪声模型
1.4.2 加噪声后的图像及其直方图 2 空间域滤波复原
2.1 均值滤波器
2.2 顺序统计滤波器
3 频率域滤波复原
3.1 带阻滤波器
3.2 带通滤波器
4 逆滤波和维纳滤波
4.1 逆滤波
4.2 维纳滤波器
5 几何畸变图像的恢复
5.1 空间坐标变换 5.2 灰度值的确定
1.1 图像恢复概述 图像在形成、记录、传输等过程中，由于受光学成像系统的相差、成像衍射、成像非线性、系统噪声等多种因素的影响，图像的质量都会有所下降，图像的这一降质过程称为图像的退化，此时的图像就称为退化图像。图像恢复，又叫图像复原，就是尽可能地减少或消除图像质量的下降，恢复被退化图像的本来面目。
常见图像退化形式：举两个例子。 与图像增强的区别：
1.2 退化模型 退化模型的性质： 图像退化的数学模型： 采用线性移不变系统模型的原因： 1.2.1 连续退化模型 1.2.2 离散退化模型 用矩阵运算描述： 循环矩阵H的对角化，后面会再叙述。
1.2.3 频域退化模型 1.3 常见退化函数模型及辨识方法 1.3.1 常见的退化函数模型 线性运动退化函数散焦退化函数高斯退化函数 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f305f88b81d0d79410ec3e478187c2e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1b8baab739df5add9ee345047f1731/" rel="bookmark">
			unity写一个按下空格物体缓慢自动拉伸3米的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我可以给你编写一段代码，用来实现按下空格键物体缓慢自动拉伸3米的功能。public class AutoStretch : MonoBehaviour { public float stretchSpeed = 0.01f; public float stretchDistance = 3f; private float currentStretch = 0f; void Update () { if (Input.GetKeyDown(KeyCode.Space)) { currentStretch = 0f; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2337b2ec27c4d27776102ecd929c838e/" rel="bookmark">
			linux(kali)通过wine安装.exe应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.进入kali系统打开终端并开启i386支持
sudo dpkg --add-architecture i386 2.修改/etc/apt/中的sources.list配置文件添加如下内容
deb https://dl.winehq.org/wine-builds/debian/ stretch main
vim /etc/apt/sources.list 3.执行以下命令出现ok则代表成功
wget -nc https://dl.winehq.org/wine-builds/winehq.key sudo apt-key add winehq.key 4.更新软件包 sudo apt update 5.安装wine（在执行命令过程中会出现如下情况，输入y回车即可）
sudo apt install --install-recommends wine 选择yes
6.以微信为例，去官网下载微信安装包
7.安装
wine /home/kali/Downloads/WeChatSetup.exe 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bbea3dc9937ba7b958edcf01d17e394/" rel="bookmark">
			labelme生成的标注数据转换成yolov5格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文中的代码旨在一键生成yolov5数据集的格式
使用labelme标注的json数据会生成在标注时图像文件所在的路径下，数据形式大概是这样的：
json文件和图像数据同名。
而yolov5实际训练时使用的数据格式是这样的：
网上大部分代码都是将yolov5标注格式的txt生成在根目录下，这样在生成txt文件后还需要手动整理成yolov5可训练的文件形式，下面的代码旨在减少人工处理的时间，一键生成可直接训练的文件形式。
# -*- coding: utf-8 -*- """ Time: 2021.10.26 Author: Athrunsunny Version: V 0.1 File: toyolo.py Describe: Functions in this file is change the dataset format to yolov5 """ import os import numpy as np import json from glob import glob import cv2 import shutil import yaml from sklearn.model_selection import train_test_split from tqdm import tqdm ROOT_DIR = os.getcwd() def change_image_format(label_path=ROOT_DIR, suffix='.jpg'): """ 统一当前文件夹下所有图像的格式，如'.jpg' :param suffix: 图像文件后缀 :param label_path:当前文件路径 :return: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bbea3dc9937ba7b958edcf01d17e394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e29aefb7320293504f0c694994eb0a3e/" rel="bookmark">
			《嵌入式Linux系统开发：基于 Yocto Project》笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 这本书的“译者序”里面有这么一句话：
市面上不缺乏适用于各种开发语言的开发、编译和打包工具，但在Yocto项目出现前，这些零散的工作需要嵌入式开发者自己串起来以交付最终的嵌入式系统。
我之前MCU做的多，Linux做的少。
最近研究Linux裁剪移植，很多芯片厂商都是适用Yocto。这个工具需要会。
但是从上面的这句话我理解到：
对Yocto的使用是一个层面Linux 系统的整体发布是另一个层面Yocto是一个工具，如果不知道这个工具要解决的问题的话，学习起来会很迷茫 这本书有英文原版，可以在网上找一下。中文版翻译的一般情况，墙裂推荐英文原版。
关于构建和Yocto工作流 红色的 Metadata/Input 是 Yocto 工程重点关注项，控制配置及工作流程。
金色的 Process Steps 是 Yocto 的固定的工作流。
草绿色？的Local Storage 是工程的源代码等资源。
两个步骤 构建环境配置
一般通过 shell 脚本完成该任务。构建环境相关的配置（主要是若干环境变量）可以在此时（此处）实例化。执行构建命令 $ bitbake [options] [recipename/target …] 这是 Yocto 的追求：一条命令完成构建。
bitbake 命令 Bitbake：一个任务执行引擎，用来解析并执行Metadata；类似于一个脚本解释器
需要完成构建环境配置后，才能在命令行里使用该命令。
$ bitbake —help Usage: bitbake [options] [recipename/target …] Executes the specified task (default is ‘build’) for a given set of target recipes (.bb files). It is assumed there is a conf/bblayers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e29aefb7320293504f0c694994eb0a3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/757c8d66e153b045259853e413d7c44f/" rel="bookmark">
			就是这么简单！Pyecharts绘制可视化地图专辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pyecharts绘制地图如此轻松，几行代码搞定多种形式的数据地图。 Pyecharts 是一个用于生成 Echarts 图表的类库。Echarts 是百度开源的一个数据可视化 JS 库。用 Echarts 生成的图可视化效果非常棒，pyecharts 是为了与 Python 进行对接，方便在 Python 中直接使用数据生成图。
安装 首先需要安装python第三方包 -- pyecharts， 目前最新版本为1.8.1。
pip install pyecharts 自从 v0.3.2 开始，为了缩减项目本身的体积以及维持 pyecharts项目的轻量化运行，pyecharts将不再自带地图 js 文件。如用户需要用到地图图表，可自行安装对应的地图文件包。下面介绍如何安装。
全球国家地图: echarts-countries-pypkg (1.9MB): 世界地图和 213 个国家，包括中国地图
中国省级地图: echarts-china-provinces-pypkg (730KB)：23 个省，5 个自治区
中国市级地图: echarts-china-cities-pypkg (3.8MB)：370 个中国城市
中国县区级地图: echarts-china-counties-pypkg (4.1MB)：2882 个中国县·区
中国区域地图: echarts-china-misc-pypkg (148KB)：11 个中国区域地图，比如华南、华北
选择自己需要安装地图相关的扩展包。
pip install echarts-countries-pypkg pip install echarts-china-provinces-pypkg pip install echarts-china-cities-pypkg pip install echarts-china-counties-pypkg pip install echarts-china-misc-pypkg pip install echarts-united-kingdom-pypkg 可以选择豆瓣源或清华源加速安装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/757c8d66e153b045259853e413d7c44f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f5ad429a9b3ab8e8403c699d5bbb3c/" rel="bookmark">
			Java toString 字符串转换为 json 字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：将日志文件里的对象字符串还原为 json 字符串以方便调试
package com.ygkj.util; import com.alibaba.fastjson.JSON; import javafx.util.Pair; import org.apache.commons.lang3.StringUtils; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.*; import java.util.regex.Pattern; public class ToStringUtils { /** * toString格式反序列化 */ /** * 数字类型匹配（包括整形和浮点型） &amp; 日期类型匹配 &amp; 对象类型匹配 &amp; ... */ public static Pattern datePattern = Pattern.compile("^[a-zA-Z]{3} [a-zA-Z]{3} [0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2} CST ((19|20)\\d{2})$"); public static Pattern numPattern = Pattern.compile("^-?[0-9]+\\.?[0-9]*$"); public static Pattern objectPattern = Pattern.compile("^[a-zA-Z0-9\\.]+\\(.+\\)$"); public static Pattern listPattern = Pattern.compile("^\\[.*\\]$"); public static Pattern mapPattern = Pattern.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01f5ad429a9b3ab8e8403c699d5bbb3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/714f1e80ad3f8e5c1d05b335ab09205d/" rel="bookmark">
			java时间格式转换时时区相关的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上结论：
1、yyyy-MM-dd'T'HH:mm:ss.SSSXXX的XXX表示时区，Z零时区，+08:00东八区（大致）
2、java 8，时间字符串不带时区，使用LocalDateTime，因为即使字符串附带了时区信息也不被使用；如果要使用字符串附带的时区信息则使用ZonedDateTime
3、使用DateTimeFormatter，毫秒都是右补零；SimpleDateFormat是左补零；解决方式使用三位毫秒格式，如：2023-02-13T00:00:00.12Z改为2023-02-13T00:00:00.120Z或2023-02-13T00:00:00.012Z再做数据类型转换
看代码和注释
package com.rootcloud; import org.apache.commons.lang.StringUtils; import java.text.ParseException; import java.text.SimpleDateFormat; import java.time.Instant; import java.time.LocalDateTime; import java.time.ZoneId; import java.time.ZonedDateTime; import java.time.format.DateTimeFormatter; import java.util.Date; public class Main21DateTest { public static void main(String[] args) throws ParseException { //结论：java 8，时间字符串不带时区，使用LocalDateTime，因为即使字符串附带了时区信息也不被使用；如果要使用字符串附带的时区信息则使用ZonedDateTime //使用DateTimeFormatter，毫秒都是右补零；SimpleDateFormat是左补零；解决方式永远使用三位毫秒格式 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS"); //基准 System.out.println("2023-02-13T00:00:00.120"); System.out.println(sdf.parse("2023-02-13T00:00:00.120").getTime()); System.out.println("DateTimeFormatter+LocalDateTime"); //XXX代表时区 final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX"); //8SH 输入 东八区时间，选择上海时间所在时区，输出 0时区时间，时间戳和基准时间相同（毫秒自动右补零） final Instant instant8SH = LocalDateTime.parse("2023-02-13T00:00:00.12+08:00", dateTimeFormatter).atZone(ZoneId.of("Asia/Shanghai")).toInstant(); System.out.println("8SH"); System.out.println(instant8SH.toString()); System.out.println(instant8SH.toEpochMilli()); //8UTC与8SH相比，输入zoneId变成UTC，输出时间为 0时区2023-02-13T00:00:00.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/714f1e80ad3f8e5c1d05b335ab09205d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89db9969350b386b8b3075bda8d39735/" rel="bookmark">
			zabbix安装部署（简单,全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zabbix安装需要分为服务端和客户端 先安装服务端（centos7） 1.更新源（这里使用清华源）
清华源
rpm -ivh https://mirrors.tuna.tsinghua.edu.cn/zabbix/zabbix/4.0/rhel/7/x86_64/zabbix-release-4.0-1.el7.noarch.rpm （这里使用的是4.0版本，也可以自己改）
2.下载zabbix相关软件（LAMP）
安装zabbix需要使用的是apache不使用nginx了
yum install -y zabbix-server-mysql zabbix-web-mysql httpd php mariadb-server 3.软件配置
修改
/etc/zabbix/zabbix_server.conf 这个文件内容
DBName=zabbix
（100行左右）
DBUser=zabbix
（116行左右）
DBPassword=zabbix（这个修改的是登录的密码）（126行左右）
继续修改
/etc/httpd/conf.d/zabbix.conf 这个文件的内容
找到时区的一行，改成（21行左右）
php_value date.timezone Asia/Shanghai （这个是你自己的地方，我这里就是上海）
4.
先开起数据库
systemctl start mariadb.service systemctl status mariadb.service 然后创建zabbix数据库
进入到数据库里边
create database zabbix character set utf8 collate utf8_bin; 创建数据库
grant all privileges on zabbix.* to zabbix@localhost identified by 'zabbix'; 创建管理员
最后离开数据库
zcat /usr/share/doc/zabbix-server-mysql-4.0.15/create.sql.gz|mysql -uzabbix -pzabbix zabbix 导入数据相应的表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89db9969350b386b8b3075bda8d39735/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de6d19a72d0809267426dbbd1853c97f/" rel="bookmark">
			go语言学习记录 并发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go语言学习记录并发 并发goroutinechannelselect关键词超时错误处理同步锁 并发 goroutine 函数调用时，在函数前使用 go 关键词即可并发执行
go Add(a,b) channel channel是Go语言在语言级别提供的goroutine间的通信方式。**
channel本身在定义后也可以通过channel来传递.
声明 var chanName chan ElementType var ch chan int var m map[string] chan bool 定义 ch:= make(chan int) 带缓冲区的channel定义 ch:=make(chan int ,1024) 单向channel变量的声明 var ch1 chan int // ch1是一个正常的channel，不是单向的 var ch2 chan&lt;- float64// ch2是单向channel，只用于写float64数据 var ch3 &lt;-chan int // ch3是单向channel，只用于读取int数据 单向channel初始化 ch4 := make(chan int) ch5 := &lt;-chan int(ch4) // ch5就是一个单向的读取channel ch6 := chan&lt;- int(ch4) 写入
ch &lt;- value 向channel写入数据通常会导致程序阻塞，直到有其他goroutine从这个channel中读取数据 读出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de6d19a72d0809267426dbbd1853c97f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/157700d8dd8571b4c864a78c6c0c5623/" rel="bookmark">
			nlp知识点总结（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		壹：语料库 一、什么是语料库 1. 定义 语料库（corpus）一词在语言学上意指大量的文本，通常经过整理，具有既定格式与标记。
2. 种类 共时语料库与历时语料库。
通用语料库与专用语料库。一般把抽样时仔细从各个方面考虑了平衡问题的平衡语料库称为通用语料库。
二、语料库加工 1. 文本处理 垃圾格式问题，大小写，标记化，句点、单撇号、连字符，词干化，句子边界。
2. 格式标注与数据标注 三、语料库应用——统计分析 1. Zipf法则 2. 搭配抽取 用频率方法识别固定搭配，用均值和方差方法识别灵活的搭配。
3. 小结 语料库是语言集合的采样语料库能够呈现语言的一般规律语料库的加工/标注是NLP建模的基础，一般规模越大，模型性能越好 四、语料库加工——抽取与对齐 1. 基于共现的双语词典自动获取 改进：删除高频干扰词，引入词性处理间接共现（无效），迭代，引入词典
2. 基于长度的双语句子自动对齐 问题的形式化描述如下：
利用贝叶斯公式进行转换。假设对齐句对中源于言和目标语的句子长度服从正态分布，则可以估计出第一项概率。
那么第二项p(match)如何计算呢？由于不同的对齐模式有不同的概率，查找已对齐的双语语料库可以进行估计，最后利用动态规划求解最优路径。
贰：语言是什么 一、语言与自然语言处理 1. 概念 语言：一个用于人类交际的、具有任意性语音符号的系统。自然语言处理：利用计算机为工具对人类特有的书面形式和口头形式的语言进行各种类型处理和加工的技术—冯志伟，1996。是一门集语言学、数学、计算机科学和认知科学等于一体的综合性交叉学科。 2. 语言起源 神授说人创说：柏拉图认为源自对外界声音的模仿；伊壁鸠鲁认为从各种抒发情感的叫喊演变过来；社会契约说，等等。恩格斯提出了劳动创造了语言，语言起源于劳动的观点。普遍认为：人类有声语言的产生大约是在距今四五万年前的旧石器时代晚期，也就是晚期智人时期。 二、现代语言学——索绪尔的奠基工作 费尔迪南·德·索绪尔，现代语言学之父，把语言学塑造成为一门影响巨大的独立学科。
1. 索绪尔的观点 区分了语言和言语这两个不同的概念区分了语言的“能指”与“所指”主张将共时性的研究与历时性的研究区分开来，指出语言学重点在共时研究（内在性质而非演变过程）指出语言是一个系统，它有自己固有的秩序 2. 语言和言语 言语：指说话这种行为和说出来的具体的话。语言：是从言语中概括出来的各言语要素的综合，是约定俗成的体系，有统一的语法规则和语音习惯，具有社会性。语言是一般，是规则；言语是特殊，是结果。 3. 能指与所指 用A代表B，则A是代表B的符号，A是符号的能指（形式），B是符号的所指（内容）。语言符号是音义结合的统一体。 4. 语言符号的特点 任意性：所指与能指联系具有任意性线性：书写、口述、理解，都有先后过程稳定性：短期、局部渐变性：长期、全局社会性：只存在于社会之中，离开了社会就没有语言（不是索绪尔关心的，为什么） 5. 语言系统的两种基本关系 组合关系：由词构成句子，横向，又称线性序列关系。 聚合关系：具有替换关系的同类性质语言单位，纵向。 6. 语言系统的层级关系 叁：中文分词 一、分词 1. 分词的提出 词是自然语言中能够独立运用的最小单位，也是语言信息处理的基本单位（但不是最小的）。分词就是将句子转换成词序列。自动分词是正确的中文信息处理的基础。 二、分词算法——基于字符串匹配 1. 正向最大匹配分词FMM 大规模真实语料中99%的词例长度在5个字以内。错误切分率为1／169，往往不单独使用，而是与其它方法配合使用。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/157700d8dd8571b4c864a78c6c0c5623/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45957dcf31848cd7e330468960d2de95/" rel="bookmark">
			YOLOv5快速训练目标检测模型记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOv5快速训练目标检测模型 训练准备环境配置图片标注数据集制作下载YOLOv5Gituhub代码 模型训练文件修改开始训练 模型预测遇到的问题图片无法读入训练模型后预测没效果no moddule named 'nn.mobilenetv3' 问题 刚完成智能小车比赛视觉模型训练，将模型训练中遇到的问题和过程记录如下 训练准备 环境配置 使用的是win10系统，显卡为3060，环境配置Anaconda+python3.8+cuda11.4+cudnn对应版本
CUDA下载
cudnn下载
图片标注 数据集：根据官方文档要求制作数据集，图像标注这里采用的是Github上开源的labelImg，可以按照需求制作voc或yolo格式数据集，这里采用的是YOLO模式输出数据，标注后会生成一个含图像分类和坐标的txt文件，当所有图像标注完成后可以在文件下下classes文件内查看所有分类。
标注工具链接: labellmg
tips：软件包含快捷键 Q，E为翻图，W为标注框选定，在右侧设置好默认标签后可以实现快速标注。
标注完成后会获得一个标签文件，文件中包含：标签类别序号和对应的坐标位置，每张图片会生成一个标签文件
以及一个classes文件，该文件中包含所有的类别标签，且与标签文件中的数字相对应。
数据集制作 这里用了最简单的方式制作数据集，按照官方示例中的介绍，将图像文件和标签文件划分整理，放进不同名字的文件夹中。注意图像文件和标签文件应在文件夹中一一对应。
文件夹格式： --datasets --images --train --val --labels --train --val 下载YOLOv5Gituhub代码 下载YOLOv5Gituhub代码至本地，链接: YOLOv5.
模型训练 文件修改 开始训练前，需要对配置文件进行简单的修改，以适应我们的数据集。
需要修改的文件 yolov5/train.py
train.py 485-490行 其他参数感兴趣的可以自选搜索修改 def parse_opt(known=False): parser = argparse.ArgumentParser() parser.add_argument('--weights', type=str, default='yolov5s.pt', help='initial weights path') #加载的权重文件，这里选择的是 yolov5s.pt 轻量模型权重。 parser.add_argument('--cfg', type=str, default='models/yolov5s.yaml', help='model.yaml path')#选取对应的模型配置文件和网络结构位置。 parser.add_argument('--data', type=str, default='data/coco128.yaml', help='dataset.yaml path')#数据集配置文件位置 parser.add_argument('--hyp', type=str, default='data/hyps/hyp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45957dcf31848cd7e330468960d2de95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c635de871306c56111400d11cb8a646/" rel="bookmark">
			YOLOv7快速上手训练自定义数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOV4的作者团队联合几位大佬已经发布了YOLOv7，记录下如何自定义训练自己的数据集模型。快速上手，如果需要细节操作还是需要自己仔细研究的。本文的目的就是帮助大家快速上手，能跑出模型结果，调优问题需要大家自己研究了。
准备工作 YOLOv7模型下载 首先是YOLOv7的链接地址github-yolov7，下载完解压即可
图像标注软件 图像标注软件有很多labelme，labellmg都可以，标注生成标注文件，然后去制作成数据集格式，我这里采用传统的yolo格式，文件以txt结尾，也可以是xml结尾的那就做VOC数据集就行。
这是标注成的txt标注文件，0代表标签名，从0起步，文件名与图像名字一一对应。
一般会生成一个classes.txt文件，没有就自己做一个放到数据集里，和标签中第一个数字对应的，我的binding代表0,1代表 debinding。
数据集准备 传统数据集格式如下，完成后将数据集放至yolo文件夹下
dataset -images --train （放训练集图片） --val （放验证集图片） -labels --train （放训练集标签文件 .txt结尾，加一个classes文件，说明类型和标签的对应） --val	（放验证集标签文件 .txt结尾，加一个classes文件，说明类型和标签的对应） VOC格式如下
Annotations （放标注文件 .xml后缀） ImageSets --Main test.txt （放测试集图片地址或者图片名字） train.txt trainval.txt val.txt JPEGImages (放所有图片） 安装必要的包 将终端切换至YOLOv7目录下，输入 pip install -r requirements.txt 即可自动安装需要的包，注意GPU训练环境可能要自行去pytorch官网安装对应版本，否则可能会跑不动，版本不对也会有问题。这里建议重开一个虚拟环境来跑，减少问题。
快速设置 从github页面下载迁移训练模型， 放至文件夹下，可以自己开个权重文件夹放进去，weights。
yaml配置文件修改 在YOLO文件夹下找到data文件夹，新建一个.yaml配置文件。名字随意，我设置的是mytrain.ymal
在文件内写入以下配置即可
我的数据集名称 custom_dataset
train: ./custom_dataset/images/train val: ./custom_dataset/images/val test: # test images (optional) nc: 2 #（类别数） names: ['binding','debinding'] # 类别名字 cfg文件修改 在cfg下找到yolov7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c635de871306c56111400d11cb8a646/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d14c508a95a0ca5adb4dea88b22b0a/" rel="bookmark">
			vue 前端调后端接口获取得到一个数组，后续需要往数组里面加数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要往返回的数组里面加数据，则是在对应的方法里面去加
请求入参传值：
id：都传空
code：第一条传个人的，“其他”传000000
name：第一条传个人的，“其他”有另外的文本框填写
let res1 = await SelectTeacher({ Code: this.Code }); if (res1 &amp;&amp; res1.results.length &gt; 0) { let newRes = [ {id: null, name: this.Name , code: this.Code}, ...res1.results, {id: null, name: "其他", code: '000000'} ] this.SelectTeacher = this.getValue(newRes, "name", "code"); } }, ...res1.results 为调接口返回的数组的省略
上述则是在调接口返回的数组前后各加一条数据。
如需在首位添加，如下:
let arr = [1,2,3] arr.unshift(4) arr //得到的结果是 (4) [4,1,2,3] 如需在最后添加，如下：
let arr = [1,2,3] arr.push(4) arr //得到的结果是 (4) [1,2,3,4] 如屑首位添加，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30d14c508a95a0ca5adb4dea88b22b0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3825ebdd857f1c38ef64bad61c15dc63/" rel="bookmark">
			mybatis 代码生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 生成代码 1. 下载链接 [link] (链接：https://pan.baidu.com/s/1J9ln5CNZCOUMFyKLEMePZA
提取码：3q3q)
2.运行：java -jar gen.jar，或直接双击startup.bat 3.访问localhost:6969 4.首次生成代码需要配置数据源信息：点击“生成代码”-&gt;“新建数据源”，填写完成后点击“测试连接”，连接成功后点击“保存”；后续直接选择数据源或在已有的数据源进行修改即可。 5.选择上面指定的库中的哪些表，选择要生成的代码模板，然后点击生成即可 6.生成的代码如下图，可下载全部然后拷贝到项目中，或点击指定的文件，然后复制代码或下载指定文件 二. 模板管理 2.1 操作模板组 1.新增模板组和模板：点击“添加模板组”，然后点击“新增模板” 2.重命名或删除模板组 JuMeng.bak1和JuMeng.bak2和JuMeng模板组中的模板是一样的，可直接在JuMeng.bak1和JuMeng.bak2修改模板即可，或直接修改JuMeng模板组
修改页面如下，Velocity变量参考右边红框中的内容，修改完成后点击”保存“，然后点击“返回”即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b255611f24e785d6ccc03f683f63a2c/" rel="bookmark">
			沁恒CH32V307单片机入门（01）：基础说明与流程体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目的基础说明芯片介绍资料与工具开发环境 流程体验开发调试下载 总结 目的 工作这几年单片机主要就接触过 Atmel、Renesas、Microchip、ST 这些厂家的，最近几年因为内部外部的各种因素单片机的价格和供应都挺不稳定的，将来会发生什么也不好说。另外这些年国内的单片机发展也挺快的。所以准备试试国产的单片机。
基础说明 芯片介绍 这里准备使用南京沁恒的CH32V307为基础进行介绍，这是一款RISC-V架构内核的单片机。我看中它的主要是自带高速 USB PHY 和 ETH PHY ，同时价格也很便宜，某宝上散买十块出头。
图片是R的，V的可用引脚要多些。
这个芯片官方是有开发板的（CH32V307-EVT-R1沁恒RISC-V模块MCU赤兔评估板），某宝官方店铺七十多块钱吧，还送两片芯片。
沁恒的单片机可以使用 WCH-Link 进行调试与下载，如果买官方开发板的话有的开发板是自带WCH-Link的。
芯片详情页：https://www.wch.cn/products/CH32V307.html
沁恒RISC-V产品总览：https://special.wch.cn/zh_cn/RISCV_MCU_Index/
资料与工具 沁恒的芯片比较大的好处是资料几乎都是有中文的。
CH32V303_305_307 数据手册：https://www.wch.cn/downloads/CH32V307DS0_PDF.html
CH32FV2x_V3x 系列应用手册：https://www.wch.cn/downloads/CH32FV2x_V3xRM_PDF.html
CH32V307评估板说明及参考应用例程：https://www.wch.cn/downloads/CH32V307EVT_ZIP.html
WCH-Link 使用说明：https://www.wch.cn/downloads/WCH-LinkUserManual_PDF.html
烧录软件（USB、串口）：https://www.wch.cn/downloads/WCHISPTool_Setup_exe.html
烧录软件（WCH-Link）：https://www.wch.cn/downloads/WCH-LinkUtility_ZIP.html
开发环境 沁恒的单片机目前官方推荐的是使用 MounRiver Studio ，这是一款 Eclipse 开发的IDE，支持Windows、Linux、MacOS。
MounRiverStudio官网：http://www.mounriver.com/
下载安装完成后（软件初次启动很慢）可以从菜单选择设置为中文：
流程体验 沁恒RISC-V单片机开发调试烧录等相关内容可以参考下面几处：
MounRiverStudio帮助中心：http://www.mounriver.com/helpCH32V307评估板说明及参考应用例程 中 PUB 目录下的《CH32V30x评估板说明书》文档。 对于IDE的使用也可以参考官方视频：https://www.bilibili.com/video/BV1yL411H7La
开发 使用MounRiverStudio进行开发，新建工程选择合适的模板：
新建工程后默认就会包含开发所需的所有库文件，之后只需要按照功能需求编写相应代码即可。
编写完成后就可以进行编译，然后进行下载或者调试：
调试 调试需要用到 WCH-Link （赤兔评估板是自带的），该工具使用可用参考上面的《WCH-Link使用说明》文档。
SWD接口用于下载和调试；CH32V307的UART1可以和WCH-Link的串口桥接以实现串口转USB功能，方便与电脑通讯。
对于 CH32V10x/CH32V20x/CH32V30x/CH32F10x/CH32F20x ，系列而言SWD接口的引脚对应关系通常为 SWDIO - PA13 SWCLK - PA14 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b255611f24e785d6ccc03f683f63a2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0317e4ceb9bd3f1bf2999ebb32dcf99/" rel="bookmark">
			ThreadLocal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看个例子
主线程和子线程都对 类成员变量u进行修改，两者的修改都会影响主线程的输出u，最后结果可能是2也可能是3
public class Test { private static Integer u = 1; public static void main(String[] args) { Thread t = new Thread(new Runnable() { @Override public void run() { u++; //	local.set(1000); //	System.out.println(local.get()); } }); t.start(); u++; //local.set(1); try { Thread.sleep(2000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(u); //System.out.println(local.get()); } 如果两个线程都对ThreadLocal中的变量进行修改，则发现两线程的修改互不影响，主线程输出的永远是1，子线程永远是1000
public class Test { private static Integer u = 1; private static ThreadLocal local = new ThreadLocal() { @Override protected Integer initialValue() { return 100; } }; public static void main(String[] args) { Thread t = new Thread(new Runnable() { @Override public void run() { //	u++; local.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0317e4ceb9bd3f1bf2999ebb32dcf99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cdf41496ed773bc4b44a64256e5e220/" rel="bookmark">
			ApplicationListener与ApplicationContextAware
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ApplicationContextAware Spring定义的类实现ApplicationContextAware接口会自动的将应用程序上下文加入，首先我们看下具体的实现示例：
1、示例代码 @Component public class SpringContextHolder implements ApplicationContextAware { private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { SpringContextHolder.applicationContext = applicationContext; } } 2、ApplicationContextAware的使用方式很简单，只要实现接口重写方法就可以，下面我们看下应用程序是如何初始化的 AbstractApplicationContext类是Spring容器应用上下文的一个抽象父类，我们看下里面的prepareBeanFactory方法
protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) { beanFactory.setBeanClassLoader(this.getClassLoader()); beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, this.getEnvironment())); //添加ApplicationContextAware的处理器 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); if (beanFactory.containsBean("loadTimeWeaver")) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } if (!beanFactory.containsLocalBean("environment")) { beanFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cdf41496ed773bc4b44a64256e5e220/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42a98076b2e3813e08e986d895c2776/" rel="bookmark">
			三种卷积后的特征图尺寸【普通卷积、有padding的卷积、空洞卷积】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参数表：
类型值输入图片 ：In9×9普通卷积核：kernel3×3步长：stride2填充 ：padding1空洞卷积核：n5输出特征图 ：Out 普通卷积（无padding） 2. 填充卷积（有padding）
3. 空洞卷积（有padding）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea536c0f4b1fb91ea1c1eedb722d41cc/" rel="bookmark">
			使用java代码输出以下平行四边形图案： *	*	*	*	*				 	*	*	*	*	*			 		*	*	*	*	*		 			*	*	*	*	*	 				*	*	*	*	* 	图案共有n行，每...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public class Test { public static void main(String[] args) { System.out.println("请输入行数："); Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { System.out.print("*"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40319e73d0204b036f4ff575e1392b1d/" rel="bookmark">
			辉芒微(FMD)单片机开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		辉芒微(FMD)单片机开发环境搭建 目录 辉芒微(FMD)单片机开发环境搭建前言1 硬件准备2 环境搭建2.1 FMD IDE2.2 芯片规格书和参考demo2.3 新建工程 结束语 前言 为了节省成本，最近使用一款辉芒微的MCU，在此之前其实我都不知道这个公司，而且不管是官网还是网上其他相关的资料都不是很多，所以也是折腾了一番才把环境搭好，于是这里就出一篇博客，记录一下整个开发环境的搭建。
关于辉芒微的产品以及工具，可以自行到官网查看，这里就不具体讲了。
辉芒微官网地址：https://www.fremontmicro.com
1 硬件准备 硬件上首先烧录器必须要有，不然没法烧录和调试。其次是带MCU的一块电路板，可以自己做也可以使用开发板，我选的型号是FT61F14，外设很少，但是因为我做的东西本身也比较简单，已经够用了，你们可以根据自己实际使用选择合适的MCU。
烧录器的选择有好几款，我选的这种是FMD Link type-c接口的。
注：这里必须吐槽一点，辉芒微的软硬件适配和官方的服务实在是不咋地，就拿这个烧录器来说，不同版本的硬件还要适配不同版本的软件，关键是官网也没有给出最新版的软件，这就算了，以前的历史版本也没有给出来，问客服要，他们说你问供应商要吧。就…离谱。
根据官方给出的资料，不同版本的FMD Link适配如下：
2 环境搭建 2.1 FMD IDE 我们编译代码需要用到FMD IDE，但是这个软件在官网上找不到，就很离谱，我是通过其他渠道找到的一个当前最新版本(v3.0.8 免安装版)，还有对应的烧录器使用说明手册。
下载地址：https://download.csdn.net/download/ShenZhen_zixian/87095431
下载完成之后解压即可，这个是免安装版，直接打开就可以用，但要注意的是，文件存放的路径不能有中文，否则可能会导致编译失败。建议直接放在C盘根目录下。
2.2 芯片规格书和参考demo 芯片规格书可以了解到MCU的详细情况，包括架构、外设的配置方法、寄存器等情况。
而通过参考官方的demo程序则能够快速的了解MCU的编程方法，并展开后续的开发工作。我们可以根据自己选择的芯片型号在官网上面下载相应的规格书和参考code。
比如我用的这款MCU FT61F14x，参考代码包含了最常用的一些外设的配置方法，基本上是够用了。
2.3 新建工程 打开前面下载好的FMD IDE。
1、新建项目
点击Project -&gt; New Project...，在弹出的选项框内输入项目相关的参数即可。
工程建好以后会自动生成一个测试文件，里面都是空函数，你可以选择在这个test.c文件里面添加自己的代码，也可以删掉这个文件重新添加自己的代码文件进去。
2、在项目上添加文件
选中工程目录文件右键，点击Add File...，选择自己要加进去的文件即可。
3、编译代码
需要编译的时候，点击编译图标即可。
三个编译图标对应的功能依次是：编译单个目标，编译所有目标，编译所有文件并且下载烧录。
编译的时候会弹出一个选项框，如果没有特殊的配置要求，按默认的就行不需要修改。
编译完成后在下面的输出框能够看到编译的结果，会提示错误和警告，内置EEPROM的使用情况等等。
注意事项：如果编译的时候提示找不到编译器(This Language Toolsuite does not exist)，则按下面的方法修改一下编译器路径即可。
依次点击Compile -&gt; Compile...，在弹出的选择框里面找到FMD IDE的安装根目录，然后在目录下的data -&gt; bin文件夹里面找到这个c.exe文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40319e73d0204b036f4ff575e1392b1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d5e8975b2f92ac46bc5d36f21c2e105/" rel="bookmark">
			Sharding-JDBC架构篇 - 分库分表神器 Sharding-JDBC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Sharding-JDBC 定位为轻量级 Java 框架，在 Java 的 JDBC 层提供额外服务。它使用客户端直连数据库，以 jar 包的形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动。
适用于任何基于 JDBC 的 ORM 框架。支持任何第三方的数据库连接池。支持任意实现 JDBC 规范的数据库。目前支持 MySQL、Oracle、SQL Server、PostgreSQL 以及遵循 SQL92 标准的数据库。
基本概念 表 表是透明化数据分片的关键概念。Apache ShardingSphere 通过提供多样化的表类型，适配不同场景下的数据分片需求。
逻辑表
相同结构的水平拆分数据库（表）的逻辑名称，是 SQL 中表的逻辑标识。例：订单数据根据主键尾数拆分为 10 张表，分别是 t_order_0 到 t_order_9，它们的逻辑表名为 t_order。
真实表
在水平拆分的数据库中真实存在的物理表。即上个示例中的 t_order_0 到 t_order_9。
绑定表
指分片规则一致的一组分片表。使用绑定表进行多表关联查询时，必须使用分片键进行关联，否则会出现笛卡尔积关联或者跨库关联，从而影响查询效率。例如：t_order 表和 t_order_item 表，均按照 order_id 分片，并且使用 order_id 进行关联，则此两张表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。举例说明，如果 SQL 为：
select i.* from t_order o join t_order_item i on o.order_id = i.order_id where o.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d5e8975b2f92ac46bc5d36f21c2e105/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/241a871b083a7cb32933b7c6d756d60a/" rel="bookmark">
			用python写出通过5天的交通流量数据来训练算法，以预测第六天的交通拥堵情况...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 好的，以下是一个简单的用Python编写的示例程序，使用历史交通流量数据来训练模型，以预测第六天的交通拥堵情况。
首先，需要导入所需的Python库，如pandas、numpy、matplotlib和sklearn等，用于数据处理、可视化和机器学习模型训练：
import pandas as pd import numpy as np import matplotlib.pyplot as plt from sklearn.linear_model import LinearRegression 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4397bd31e5ff5001bb7889326d40e215/" rel="bookmark">
			已知二阶单位负反馈系统开环传递函数为G(s)16/(s(s&#43;1.6)),函数增加一个极点p=-2,用MATLAB编写代码绘制该闭环系统单位阶跃响应曲线...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可以通过以下步骤在MATLAB中绘制闭环系统单位阶跃响应曲线：
定义变量s和系统参数G： s = tf('s'); G = 16/(s*(s+1.6)); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/229568cfbf12a71a26c14a0c1cfe7728/" rel="bookmark">
			拉格朗日中值定理推论及用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由拉格朗日中值定理得以下两个推论：
推论1 若 f ( x ) f(x) f(x)在 ( a , b ) (a,b) (a,b)内可导， f ′ ( x ) ≡ 0 f'(x)\equiv0 f′(x)≡0，则 f ( x ) f(x) f(x)在 ( a , b ) (a,b) (a,b)内为常数。
证明：对于 ( a , b ) (a,b) (a,b)内的任意两点 x 1 &lt; x 2 x_1&lt;x_2 x1​&lt;x2​， ∃ ξ ∈ ( x 1 , x 2 ) \exist \xi\in(x_1,x_2) ∃ξ∈(x1​,x2​)使得 f ( x 1 ) − f ( x 2 ) = f ′ ( ξ ) ( x 1 − x 2 ) = 0 f(x_1)-f(x_2)=f'(\xi)(x_1-x_2)=0 f(x1​)−f(x2​)=f′(ξ)(x1​−x2​)=0，所以 f ( x ) f(x) f(x)在 ( a , b ) (a,b) (a,b)内为常数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/229568cfbf12a71a26c14a0c1cfe7728/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6810090b597e3be6be44df7dbb7b5df/" rel="bookmark">
			大文件上传的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大文件上传的解决方法 一、使用分片上传的方法二、进度条使用浏览器XMLHttpRequest的onprogress方法对进度进行监视三、断点续传核心方法：通过xhr的abort方法，主动放弃当前请求 一、使用分片上传的方法 在JavaScript中，File对象是Blob对象的子类，而Blob对象包含一个slice方法，我们可以通过这个方法来对二进制文件进行拆分；可以使用FormData格式进行上传；服务器端接口接收到数据，可以通过Multiparty库对数据进行处理；区分flies和fileds，通过fse.move将上传的文件移动到目标路径下；客户端使用Promise.all方法，当监听到所有切片已上传完，调用merge接口，通过服务器端来对切片进行合并；使用Stream对切片边读边写使用Promise.all判断所有切片是否写入完毕 二、进度条使用浏览器XMLHttpRequest的onprogress方法对进度进行监视 // 作为request的入参 const xhr = new XMLHttpRequest() xhr.upload.onprogress = onprogress // 回调方法 onProgress: this.createProgressHandler(this.data[index]) // 接收回调，通过 e.loaded 和 e.total 获取进度 createProgressHandler(item){ return(e) =&gt; { item.percentage = parseInt(String((e.loaded / e.total) * 100)) } } 三、断点续传核心方法：通过xhr的abort方法，主动放弃当前请求 this.requestList.forEach((xhr) =&gt; xhr?.abort()); 这里是万物之恋，我们下次再见了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9e5d2f031a836a643b1ed16cb05a9b9/" rel="bookmark">
			金三银四面试必备的软件测试八股文，看完拿捏面试官
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问：你在测试中发现了一个 bug，但是开发经理认为这
不是一个 bug，你应该怎样解决？
首先，将问题提交到缺陷管理库里面进行备案。
然后，要获取判断的依据和标准：
根据需求说明书、产品说明、设计文档等，确认实际结果是否与计划有不一致
的地方，提供缺陷是否确认的直接依据；
如果没有文档依据，可以根据类似软件的一般特性来说明是否存在不一致的地
10
方，来确认是否是缺陷；
根据用户的一般使用习惯，来确认是否是缺陷；
与设计人员、开发人员和客户代表等相关人员探讨，确认是否是缺陷；
合理的论述，向测试经理说明自己的判断的理由，注意客观、严谨，不参杂个
人情绪。
等待测试经理做出最终决定，如果仍然存在争议，可以通过公司政策所提供的
渠道，向上级反映，并有上级做出决定。
【文章末尾给大家留下了大量的金三银四福利】
2、问：给你一个网站，你如何测试？
首先，查找需求说明、网站设计等相关文档，分析测试需求。
制定测试计划，确定测试范围和测试策略，一般包括以下几个部分：功能性测
试；界面测试；性能测试；数据库测试；安全性测试；兼容性测试
设计测试用例：
功能性测试可以包括，但不限于以下几个方面：
链接测试。链接是否正确跳转，是否存在空页面和无效页面，是否有不正确的
出错信息返回。
提交功能的测试。
多媒体元素是否可以正确加载和显示。
多语言支持是否能够正确显示选择的语言等。
界面测试可以包括但不限于一下几个方面：
页面是否风格统一，美观
11
页面布局是否合理，重点内容和热点内容是否突出
控件是否正常使用
对于必须但未安装的控件，是否提供自动下载并安装的功能
文字检查
性能测试一般从以下两个方面考虑：
压力测试；负载测试；强度测试
数据库测试要具体决定是否需要开展。数据库一般需要考虑连结性，对数据的
存取操作，数据内容的验证等方面。
安全性测试：
基本的登录功能的检查
是否存在溢出错误，导致系统崩溃或者权限泄露
相关开发语言的常见安全性问题检查，例如 SQL 注入等
如果需要高级的安全性测试，确定获得专业安全公司的帮助，外包测试，或者
获取支持
兼容性测试，根据需求说明的内容，确定支持的平台组合：
浏览器的兼容性；
操作系统的兼容性；
软件平台的兼容性；
数据库的兼容性
开展测试，并记录缺陷。合理的安排调整测试进度，提前获取测试所需的资源，
建立管理体系（例如，需求变更、风险、配置、测试文档、缺陷报告、人力资
源等内容）。
12
定期评审，对测试进行评估和总结，调整测试的内容。
3、在搜索引擎中输入汉字就可以解析到对应的域名，请问
如何用 LoadRunner 进行测试。
建立测试计划，确定测试标准和测试范围
设计典型场景的测试用例，覆盖常用业务流程和不常用的业务流程等
根据测试用例，开发自动测试脚本和场景：
录制测试脚本：新建一个脚本（Web/HTML 协议）；点击录制按钮，在弹出
的对话框的 URL 中输入”about:blank”；在打开的浏览器中进行正常操作流
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9e5d2f031a836a643b1ed16cb05a9b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17f3ce18e1bf97814940d6cdff3780f3/" rel="bookmark">
			java http请求设置代理 Proxy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HttpURLConnection、HttpClient设置代理Proxy 有如下一种需求，原本A要给C发送请求，但是因为网络原因，需要借助B才能实现，所以由原本的A-&gt;C变成了A-&gt;B-&gt;C。
这种情况，更多的见于内网请求由统一的网关做代理然后转发出去，比如你本地的机器想要对外上网，都是通过运营商给的出口IP也就是公网地址实现的。这种做法就是代理了。
研究了一下针对 HttpURLConnection和HttpClient这两种常见的http请求的代理：
一、HttpURLConnection设置请求代理 贴出一个utils类 具体代码如下：
public class ProxyUtils { public static final String CONTENT_TYPE = "application/x-www-form-urlencoded"; public static String getResultByHttpConnectionProxy(String url, String content, String proxyHost, int proxyPort) { String result = ""; OutputStream outputStream = null; InputStream inputStream = null; try { //设置proxy Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort)); URL proxyUrl = new URL(url); //判断是哪种类型的请求 if (url.startsWith("https")) { HttpsURLConnection httpsURLConnection = (HttpsURLConnection) proxyUrl.openConnection(proxy); httpsURLConnection.setRequestProperty("Content-Type", CONTENT_TYPE); //允许写入 httpsURLConnection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17f3ce18e1bf97814940d6cdff3780f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbac0e8a211a59616166a5e92add3ff2/" rel="bookmark">
			Vue3 自定义悬浮按钮拖拽&#43;底部tabbar自用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div&gt; &lt;--div这里悬浮--&gt; &lt;div class="menu" ref="dragDivImg" @click.stop="isShow=!isShow" @touchstart.stop="dragStart" @touchend.stop="dragEnd" @touchmove.stop="dragMove"&gt;&lt;img src="../assets/home/menu.png" alt=""&gt;&lt;/div&gt; &lt;router-view /&gt; &lt;van-tabbar v-model="activedd" route v-if="isShow"&gt; &lt;van-tabbar-item v-for="(item,i) in iconList" :key="i" :replace="item.url!=='/mapPage'" :to="item.url"&gt; &lt;span&gt;{{item.name}}&lt;/span&gt; &lt;template #icon="props"&gt; &lt;img style="height:27px" :src="props.activedd? item.active : item.inactive" /&gt; &lt;/template&gt; &lt;/van-tabbar-item&gt; &lt;/van-tabbar&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { onMounted, ref, nextTick } from "vue"; export default { setup(props) { let activedd = ref(0) //用到参数 const dragDivImg = ref(null) let left = ref(0)//悬浮位置 let top = ref(0) let screenW = ref(0)//屏幕尺寸 let screenH = ref(0) let gapWidth = ref(0) //结束 let isShow = ref(true) let iconList = ref([ { name: '基层服务', active: require('@/assets/home/jcfw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbac0e8a211a59616166a5e92add3ff2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfac47b01ead3a584ea0b5c7db7061a3/" rel="bookmark">
			一些论文中使用的统计检验（持续更新）&#43;一些算法原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写作目的 由于偶尔会被问应该在什么情况下使用什么检验，然后有时答不上来或者分析的不是很准确，故而在阅读文献的时候特意记录一下文献中的统计方法。
如果需要在R里看源码的话，可参考该博文https://mp.weixin.qq.com/s/UNB0zaBHrH0XE_j8vj5d-A
类别变量 文献来源：A Six-genotype Genetic Prognostic Model for Papillary Thyroid Cancer https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5132178/
原文：
Comparisons of categorical variables were performed with either Pearson’s chi-squared test or, for cases with small number, Fisher’s exact test.
针对分类变量若样本量少使用fisher exact test,样本量大使用卡方检验。
如何判断样本量小（Fisher 精确检验 与卡方检验 - 简书 https://www.jianshu.com/p/f0e1b0100e59）：
1.所有的理论数T≥5并且总样本量n≥40,用Pearson卡方进行检验.
2.如果理论数T＜5但T≥1,并且n≥40,用连续性校正的卡方进行检验.
3.如果有理论数T＜1或n＜40,则用Fisher’s检验.
连续型变量 先奉上一张图，来源于https://mp.weixin.qq.com/s/OhkSFJSUcgDD9nFdc8kHTg推文中的图，啧啧，我感觉这张图基本就把连续型最常用的应用条件给说明清楚了
对于要使用T检验而言，一般样本量大于40个即可认为符合正态分布
ssGSEA的算法原理 参考博文https://mp.weixin.qq.com/s/TnUq-NfIc7oQTjnflVqs4g
连续型变量 t检验与u检验 一般都用t检验，u检验即z检验，需要假设方差已知。一般均匀分布的方差已知
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b53998282b1408bd2a0eac8a8629ff7/" rel="bookmark">
			关于java.io使用相对路径读取文件找不到文件但是文件存在的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击跳转
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/166/">«</a>
	<span class="pagination__item pagination__item--current">167/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/168/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>