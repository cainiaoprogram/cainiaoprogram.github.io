<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e421bf747716f0e750ddb8fbe89a3ded/" rel="bookmark">
			CentOS sed 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语法 sed [-nefri] 'command' file.txt 选项与参数： -n ：只有经过sed 特殊处理的那一行(或者动作)才会被列出来。 -e ：直接在命令列模式上进行 sed 的动作编辑；可以一次修改多个规则，中间用 分号 隔开 -f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作； -r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法) -i ：直接修改读取的文件内容，而不是输出到终端。 命令 command ： a ：新增， 指定行后面； c ：修改， 表示修改文件指定行的内容； d ：删除； i ：插入， 指定行前面； p ：打印，通常 p 会与参数 sed -n 使用； s ：查找替换； 一、向文件中添加行 命令：a：表示指定行后插入内容；i： 表示指定行前插入内容，下面演示指定行后插入内容。
# 原始文件内容 [root@vm114 ~]# cat sedfile 111 222 333 444 555 1、在指定行后插入内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e421bf747716f0e750ddb8fbe89a3ded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faa2062fa1c18375a41d7833a3e0b2f2/" rel="bookmark">
			基于双树复小波变换（DT-CWT）的实验性实用程序的图像融合技术解析与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尊敬的读者，欢迎您阅读这篇文章。在此，我们将探索图像融合技术的实践应用，特别是如何利用双树复小波变换（Dual Tree Complex Wavelet Transform，DT-CWT）来实现图像融合。
在图像处理领域，图像融合是一种有效的策略，它能整合来自多个图像的信息，以生成更好的、更丰富的图像。通过图像融合，我们可以保留和强化特定的有用信息，同时减小或消除不必要或冗余的信息。有多种技术可以实现图像融合，其中之一就是双树复小波变换（DT-CWT）。
实战项目下载
在开始我们的讨论之前，让我们首先简要介绍一下什么是双树复小波变换（DT-CWT）。DT-CWT 是一种非常强大的数学工具，它允许我们在不同的频率和方向上分析数据。不同于标准的小波变换，DT-CWT 提供了复数输出，这使得它可以捕获信号的相位信息，而这对许多应用来说是非常重要的。
DT-CWT的Python实现 在 Python 中，我们可以通过几个简单的步骤实现 DT-CWT。首先，我们需要导入一些必要的库。这包括 NumPy（用于数学运算），以及 PyWavelets（用于实现小波变换）：
# 导入所需的库 import numpy as np import pywt 然后，我们可以定义一个函数来实现 DT-CWT。在这个函数中，我们将使用 PyWavelets 库中的 dtwavedecn 函数，它可以计算输入信号的 N 级双树小波变换。这个函数接受三个参数：输入信号，小波变换的级别，以及所使用的小波类型：
# 定义DT-CWT函数 def dtcwt(signal, level, wavelet): """ 进行双树复小波变换 参数： signal：输入信号 level：小波变换的级别 wavelet：所使用的小波类型 返回： 双树复小波变换的结果 """ # 使用pywt库的函数实现DT-CWT coeffs = pywt.dtwavedecn(signal, wavelet, level=level) return coeffs 现在，我们已经有了实现 DT-CWT 的基本工具，下面我们将把这个技术用于图像融合。
图像融合基本步骤 对于图像融合，我们需要首先准备两个或更多的输入图像。在这个实验中，我们将使用两个图像，它们都由同一场景的不同视角或不同时间拍摄而成。接下来，我们将实现图像融合的基本步骤，这些步骤包括：
对每个输入图像执行 DT-CWT，以获取在不同频率和方向上的信息；对每个级别和方向的系数应用融合规则，以生成融合系数；使用反向 DT-CWT 将融合系数转换回图像空间，从而得到最终的融合图像。 请注意，这些步骤可能会根据实际应用的需求和限制有所不同。在接下来的文章中，我们将逐步详细介绍这些步骤的具体实现。
第二部分 图像融合的实践应用 在我们开始图像融合的实践应用之前，我们首先需要准备输入图像。我们将使用 OpenCV 库来读取和处理图像。以下是导入必要库的代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faa2062fa1c18375a41d7833a3e0b2f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ecb96a021f22946a787734cf44a418a/" rel="bookmark">
			单片机毕设 基于STM32的智能药箱系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 简介2 绪论2.1 课题背景2.2 实现功能 3 系统设计3.1 系统架构3.2 硬件设计3.2.1 wifi电路设计3.2.2 其他电路设计 3.3 软件设计3.3.1 软件工作流程3.3.2 闹铃提醒程序设计3.3.3 液晶显示程序设计3.3.4 信息存储程序设计3.3.5 报警电路程序设计 3.4 部分实现代码 4 最后 1 简介 Hi，大家好，今天向大家介绍一个学长做的单片机项目
基于STM32的智能药箱系统设计与实现
大家可用于 课程设计 或 毕业设计
2 绪论 2.1 课题背景 照顾老人， 特别是提醒老人准时吃药已经成为了一个社会关心的问题。长期记录吃药种类、 吃药时间能为分析老人的病理提供有力的依据。
基于目 前市场需求， 学长设计了一款基于 STM32F103 并结合网络来提醒老人按时吃药的系统。
整个智能药箱系统分为智能药箱端与远程服务器端两个部分， 智能药箱端用于提醒， 服务器端用于记录监督
2.2 实现功能 整个系统经过多次测试和应用， 各功能模块都可以正常运行， 符合设计要求。 具有的功
能包括： 从服务器端的数据库中实时获取药物信息， 闹钟信息等并存储。 播放音频文件提醒老人用药， 在液晶屏上提示吃药信息， 老人可以根据显示信息正确用药。 智能药箱端能记录药箱中每种药的数目， 并进行药量检测， 在药量不足时发出提醒， 提示用户配药。 另外还可以对老人取药动作进行记录， 将取药状态通过互联网传输给服务器监控端， 为以后看病做依据。 另外， 智能药箱端通过程序界面方便的配置智能药箱内部的网络信息，包括服务器地址、端口、 网关等。
它的主要功能分为下面几个部分：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ecb96a021f22946a787734cf44a418a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/666b601f641d10b351060266aea6b920/" rel="bookmark">
			ChatGPT源码小狐狸AI系统pc自适应全开源GPT4.0MJ绘画系统AI绘画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT源码小狐狸AI系统是一款基于GPT-4.0的人工智能聊天系统，它以小狐狸为形象，为用户提供了智能而互动的聊天体验。此外，该系统还集成了全开源的GPT4.0MJ绘画系统AI，使得用户可以使用AI进行绘画创作。这篇文章将介绍该系统的特点和优势，以及它对用户的意义。
首先，ChatGPT源码小狐狸AI系统具备强大的聊天功能。通过使用GPT-4.0技术，该系统能够理解用户的输入并生成具有逻辑和连贯性的回复。小狐狸形象可增加系统的亲和力和趣味性，使用户在与系统交流时更有代入感。用户可以向小狐狸提问、表达情感或寻求建议，系统会提供相应的回答和支持，给用户带来智能化的互动体验。
其次，该系统集成了GPT4.0MJ绘画系统AI，为用户提供了创作绘画的功能。用户可以使用系统提供的绘画工具，在电脑上进行绘画创作。GPT4.0MJ绘画系统AI能够理解用户的绘画需求，并提供相应的建议和指导。它能够生成各种风格的绘画素材，帮助用户提升绘画水平和创作灵感。
此外，该系统具有PC自适应的特点。不论用户使用的是笔记本电脑、台式机还是平板电脑，都可以方便地访问和使用该系统。系统界面经过优化，适应不同尺寸和分辨率的屏幕，保证用户在不同设备上都能够有良好的体验。
ChatGPT源码小狐狸AI系统对于用户来说意义重大。首先，它提供了一个可信赖和交互性强的聊天伙伴，用户可以随时与系统进行对话，分享心情、寻求帮助或获取娱乐。其次，系统集成了AI绘画系统，为用户提供了一个创作绘画的平台，无论是专业画家还是对绘画感兴趣的初学者，都能够获得支持和灵感。此外，系统的PC自适应特性使得用户可以随时随地访问系统，提高了使用的便捷性。
总而言之，ChatGPT源码小狐狸AI系统pc自适应全开源GPT4.0MJ绘画系统AI绘画是一款功能强大且创新的人工智能系统。它以小狐狸形象为特点，为用户提供智能聊天和AI绘画创作的体验。该系统不仅满足了用户对聊天互动的需求，还提供了创作的平台和工具，帮助用户实现绘画梦想。相信这个系统源码将为用户带来乐趣和创作的机会。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24def7bedbe77b680bdcf2cb4ad262c3/" rel="bookmark">
			网上购物商城 基于&#43;vue（含文档）超市零食商城系统源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【标题】基于Vue的网上购物商城系统源码：超市零食商城
【正文】 如今，随着互联网的快速发展，网上购物成为了人们生活中不可或缺的一部分。人们喜欢方便、快捷地在家中就能购买所需商品的便利。而其中，超市零食是一种备受欢迎的商品类别。本文将介绍一个基于Vue的网上购物商城系统源码，重点关注超市零食商城。
这个基于Vue的网上购物商城系统通过使用现代化的前端框架Vue.js，实现了良好的用户界面和出色的用户体验。同时，它充分利用了Vue.js的组件化和响应式特性，为开发者提供了灵活的开发方式，便于二次开发和定制。
该系统以超市零食商城为例，用户可以在网站上浏览各种零食商品。系统提供了丰富的零食分类，如坚果类、糖果类、零食礼盒等，满足用户的不同口味需求。用户可以通过搜索功能查找特定的零食产品，并查看产品详情、价格、评价等信息。在选择心仪的商品后，用户可以将商品添加到购物车，并轻松地完成下单流程。
除了普通用户的功能，商城系统还为管理员提供了管理界面。管理员可以管理商品信息，包括添加新商品、更新商品信息、设置商品折扣等。同时，管理员还可以管理订单信息，包括确认订单、发货、退款等操作。这些功能的实现，使得商城系统能够高效地处理用户和管理员的各类需求。
这个网上购物商城系统源码的提供，为开发者提供了一个完整的超市零食商城系统的构建参考。通过阅读代码，开发者可以了解整个系统的实现细节，并在此基础上进行二次开发和定制化。同时，源码中的注释和规范的代码结构，有助于开发者更好地理解和快速上手系统开发。
此外，源码附带的详细文档提供了系统的概述、技术选型、模块划分、接口说明等信息，进一步帮助开发者理解和使用该系统。开发者可以根据文档中的指导，逐步搭建系统、配置环境并启动应用程序。文档中还包含了常见问题的解决方案，帮助开发者顺利运行系统并解决可能遇到的困难。
综上所述，这个基于Vue的网上购物商城系统源码为开发者提供了一个全面的超市零食商城系统构建参考。通过学习和实践，开发者可以更好地掌握Vue.js技术，提升自己的开发能力，并开发出高效、安全、用户友好的网上购物商城系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7682f6c74eb2392f0540e34db99646b/" rel="bookmark">
			Spring Cloud Stream使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是Spring Cloud Stream Spring Cloud Stream对Spring Cloud体系中的Mq进⾏了很好的上层抽象，可以让我们与具体消息中间件解耦合，屏蔽掉了底层具体MQ消息中间件的细节差异，就像Hibernate屏蔽掉了具体数据库（Mysql/Oracle⼀样）。如此⼀来，我们学习、开发、维护MQ都会变得轻松。⽬前Spring Cloud Stream原生⽀持RabbitMQ和Kafka，阿里在这个基础上提供了RocketMQ的支持，简单使用Spring Cloud Stream 构建基于RocketMQ的生产者和消费者
二、 Spring Cloud Stream的一些概念 要理解和使用Spring Cloud Stream需要先明白Spring Cloud Stream提出的一些概念。
辅助图 假设：模块1和模块2间数据可能使用的是kafka，模块1向kafka中push数据，模块2向kafka中poll数据。而模块2和模块3可能使用的是rabbitMQ。很明显，它们的功能都是一样的：提供数据的流向，让数据可以流入自己同时又可以从自己流出发给别人。但由于中间件的不同，需要使用不同的API。为了消除这种数据流入（输入）和数据流出（输出）实现上的差异性，因此便出现了Spring Cloud Stream。Spring Cloud Stream想让我们不关心如何获取数据，如何发送数据，而只专心处理自己的业务。还拿上面的例子来说，假设你现在负责的是系统里的模块3，它的功能是将模块2传来的字符串全部转成大写，然后再将这个转化后的字符串发给模块4。
Binder 什么是Binder？一句话概括就是具体中间件的统一抽象。一个kafka中间件在Spring Cloud Stream里是一个Binder，一个rabbitMQ中间件也是一个Binder。官方文档中写道：当你引入spring-cloud-stream依赖的时候，Spring Cloud Stream就会为你的那个中间件生成一个Binder实例，你就可以通过这个Binder实例来和这个消息中间件通信（收发数据）。很容易得出结论，Spring Cloud Stream对底层中间件的差异屏蔽都是基于我们的Binder，Binder适配了不同的消息中间件（官方文档中写道：Spring Cloud Stream为kafka和rabbitMQ提供了Binder的实现了）。
Binding Binding是个比较抽象的概念，那下面的例子来说：
public String handle(String source){ return source.toUpperCase(); } 这是你写的模块3中的业务代码，我们假设你与模块2交互使用的是中间件kafka和与模块4交互使用的是中间件rabbitMQ。也即你的模块的功能就变为了从kafka中获取数据，将获取的字符串数据全转为大写并写出给rabbitMQ。很明显，这里有两个Binder，一个kafka Binder一个rabbitMQ Binder。而你这个业务处理函数其实也有两个功能：接收中间件的输入和将返回数据输出。再结合Binder，我们可以理解为：
函数接收kafka Binder中的输入函数将返回结果写出给rabbitMQ binder。 但是如何表示这种关系呢？也即你现在写了一个函数，怎么表示这个函数的参数是从kafka入的，函数的返回是向rabbitMQ输出的呢？这就需要Binding。Binding其实就是一座桥，桥的一头是Binder，另一头是你的业务处理函数。Bindings将外部消息中间件与你的业务处理代码连接在了一起（官方原话是：外部消息系统和应用程序之间的桥梁，提供消息的生产者和消费者（由Binder创建））。
了解了这些其实也就了解Spring Cloud Stream的架构图，Spring Cloud Stream官网中有一张图讲了它的架构：
首先最底层的Middleware是中间件，我们的kafka，rabbitMQ都属于中间件。上一层的Binder已经讲了，是对中间件的一层抽象和封装。再上一层的inputs和outputs其实就是Bindings，我们与Binder的交互就是通过Binding，其中写出数据就是output，而获取数据就是input。再上层的Application Core就是我们自己的业务代码，可以看到我们的业务代码通过Binding（input、output）与Binder交互，而Binder又负责和具体中间件交互。
函数式接口 Spring Cloud Stream 2.x与Spring Cloud Stream 3.x最大的不同就是2.x是基于注解的，而3.x是基于函数式编程的。
还拿上面的例子来说：对于你开发的一个模块而言，它无非三种情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7682f6c74eb2392f0540e34db99646b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/179439963025dc16c86e35540a5bd712/" rel="bookmark">
			innerHTML和outerHTML的异同点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、 innerHTML二、 outerHTML三、 innerHTML和outerHTML的共同点四、innerHTML和outerHTML的区别 一、 innerHTML 在JavaScript中，innerHTML是一个属性，用于获取或设置HTML元素的内容。它允许我们动态地操作HTML元素的内容，包括文本内容和嵌套的HTML标记。
使用innerHTML属性，我们可以获取某个HTML元素的内容，例如：
const element = document.getElementById('myElement'); console.log(element.innerHTML); 上述代码将会打印出myElement元素的HTML内容。如果myElement元素的内容为&lt;p&gt;Hello, world!&lt;/p&gt;，那么输出结果将是&lt;p&gt;Hello, world!&lt;/p&gt;。
除了获取HTML内容外，innerHTML还可以用于设置HTML元素的内容。例如，我们可以通过innerHTML属性动态地修改元素的内容：
const element = document.getElementById('myElement'); element.innerHTML = '&lt;p&gt;This is a new paragraph.&lt;/p&gt;'; 上述代码将会将myElement元素的内容替换为&lt;p&gt;This is a new paragraph.&lt;/p&gt;。
需要注意的是，使用innerHTML属性来操作HTML内容可能存在安全风险。因为它可以解析和执行任意的HTML代码，可能导致跨站脚本攻击（XSS）的风险。为了避免安全问题，应该谨慎处理用户输入的内容，并使用其他更安全的方法来操作HTML内容，例如使用textContent属性来处理纯文本内容。
总结：innerHTML属性是JavaScript中用于获取和设置HTML元素内容的属性，可以方便地进行动态的HTML内容操作。但是在使用时需要注意安全性问题。
二、 outerHTML 在JavaScript中，outerHTML是一个属性，用于获取或设置HTML元素及其包含的内容的完整HTML表示。与innerHTML不同，outerHTML返回的是包括元素本身在内的整个HTML代码。
使用outerHTML属性，我们可以获取某个HTML元素及其包含的内容的完整HTML表示，例如：
const element = document.getElementById('myElement'); console.log(element.outerHTML); 上述代码将会打印出myElement元素及其包含的内容的完整HTML表示。如果myElement元素的内容为&lt;p&gt;Hello, world!&lt;/p&gt;，那么输出结果将是&lt;div id="myElement"&gt;&lt;p&gt;Hello, world!&lt;/p&gt;&lt;/div&gt;。
与innerHTML属性不同，outerHTML还可以用于替换整个HTML元素及其内容。例如，我们可以通过outerHTML属性动态地替换元素：
const element = document.getElementById('myElement'); element.outerHTML = '&lt;div id="newElement"&gt;&lt;p&gt;This is a new element.&lt;/p&gt;&lt;/div&gt;'; 上述代码将会将myElement元素及其内容替换为&lt;div id="newElement"&gt;&lt;p&gt;This is a new element.&lt;/p&gt;&lt;/div&gt;。
需要注意的是，与innerHTML一样，使用outerHTML属性也存在安全风险。因为它可以解析和执行任意的HTML代码，可能导致跨站脚本攻击（XSS）的风险。同样，为了避免安全问题，应该谨慎处理用户输入的内容，并使用其他更安全的方法来操作HTML内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/179439963025dc16c86e35540a5bd712/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6580f8412b257a90aff098e9a12bf72/" rel="bookmark">
			linux学成之路（基础篇）（十五）Tomcat基本部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、概述
二、安装
基本环境部署
java环境
三、目录结构​编辑
启停
四、配置文件​编辑
启动tomcat使用网络进行测试​编辑
五、多tomcat部署
部署
命令优化
端口号修改
修改访问页面
重启tomcat1​编辑
网络访问测试
六、不同的实现方式
一、基于不同的域名
二、基于不同的端口
前言 Java语言于1995年由Sun Microsystems发布，以其跨平台性和易用性而受到广泛关注。Java的出现推动了Web应用程序的发展，并需要一种容器来运行服务器端的Java代码。
Java Servlet和JavaServer Pages（JSP）规范于1997年发布，为开发基于Java的Web应用程序提供了方便和标准化的手段。这些规范定义了一种在Web服务器上处理动态内容的方式。
Tomcat的诞生和采纳：Tomcat最初由美国互联网社区Apache Jakarta创建并发展。它最早是作为Apache的实验性项目而诞生的，随后发展为独立的开源项目。Tomcat的原型称为"Servlet Reference Implementation"（Servlet RI）。
随着时间的推移，Tomcat逐渐被广泛接受和采用。其开源的特性、可靠性和良好的兼容性使得Tomcat成为许多Java开发人员首选的Servlet容器。
一、概述 Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。
Tomcat虚拟主机是通过linux或windows操作系统下进行独立运行的一个网站发布容器，他是一种在单一主机或主机群上，实现多网域服务的方法，可以运行多个网站或服务的技术。
默认监听端口 8080/tcp
二、安装 Tomcat是一款绿色的开源web
基本环境部署 关闭防火墙 systemctl stop firewalld
关闭图形化管理工具 systenctl stop NetworkManage
关闭selinux getenforce setenfprce 0
vim /etc/selinux/config SELINUX= disabled
java环境 java -version（检查Java环境，可以确认Java是否已正确安装，并确定其版本是否符合你的应用程序的要求）
如果没有下载开发工具 将软件包拖入虚拟机终端（已有软件包）
三、目录结构 bin 命令
conf 配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6580f8412b257a90aff098e9a12bf72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3659ee83c7c0663632a2f3999f0729f9/" rel="bookmark">
			Java设计模式之到单例模式和原型模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录设计模式相关知识，包括设计模式定义，设计原则（单一职责，开闭原则，依赖倒置，里式替换，接口隔离，迪米特原则，组合聚合复用原则），单例模式，原型模式并提供代码示例
文章目录 一、设计模式介绍二、设计原则三、设计模式单例模式原型模式 正文内容：
一、设计模式介绍 设计模式是一种设计规范，对于一类问题合理解决的思路与方式，更高效解决一类问题，对于编码来讲就是可以提高程序代码的可读性，可扩展性，复用性
可以提高程序员的思维能力，编程能力和设计能力使程序更加标准化，使软件开发效率大大提高使设计的代码可重用性高，可读性强，可靠性高，灵活性好，可维护性强更好的理解源码架构 通过设计模式帮助程序员构建更完善的系统编码；编码过程中找到需求会发生变化的地方与不会发生变化的地方，将两者分离开；面向接口编程，而不是面向实现编程；实现高内聚低耦合
二、设计原则 单一职责
在设计的时候尽量让类，或者方法只处理单一事件（高内聚低耦合）开闭原则
对扩展开放，对修改关闭；对于类或者方法进行功能增强是支持的；对于类或者方法的修改关闭，不在原有类或者方法上面进行修改；为满足开闭原则，一般使用抽象化设计里氏替换（LSP）
一个超类的对象应该能够被一个子类的对象替换，而不影响程序的正确性
换句话说，如果一个程序使用了基类，那么它应该能够使用任何派生类的对象，只要该派生类满足基类的行为期望。LSP确保子类可以替换其基类 代码示例如下：
interface Shape { int area(); } class Rectangle implements Shape { private int width; private int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } @Override public int area() { return width * height; } } class Square extends Rectangle { public Square(int side) { super(side, side); } } class AreaCalculator { public static int computeArea(Shape[] shapes) { int totalArea = 0; for (Shape shape : shapes) { totalArea += shape.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3659ee83c7c0663632a2f3999f0729f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dbf37ef53c136c6767886d85b51e971/" rel="bookmark">
			vue-element-admin项目导入VSCode出现error:0308010C:digital envelope routines::unsupported
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 将vue-element-admin项目现在导入到VSCode中，系统相关环境信息如下：
使用命令npm run dev后出现error:0308010C:digital envelope routines::unsupported，详细信息如下图所示：
原因分析： 这是因为在Node 18版本中，默认使用了OpenSSL 3.0及以上的版本，这个版本和之前的版本有所区别，它添加了一些新的特性，但同时也移除了一些旧的特性，从而导致一些依赖老版本的代码无法正常运行。所以，在一些使用了Old Crypto API或者其他OpenSSL相关的有所不同的API的应用程序中，可能龟出现奇怪的问题，比如计算DB哈希值错误，HTTP请求超时或连接以外关闭等等。在这种情况下，我们可以通过设置NODE_OPTIONS环境变量来强制使用旧版本的Crypto API。
————————————————
版权声明：本文为CSDN博主「叶子yes」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/lq313131/article/details/130543910
解决方案： 在package.json文件中通过设置NODE_OPTIONS环境变量来强制使用旧版本的Crypto API，具体代码如下所示：
“scripts”: {
“dev”: “set NODE_OPTIONS=–openssl-legacy-provider &amp;&amp; vue-cli-service serve”,
“build”: “set NODE_OPTIONS=–openssl-legacy-provider &amp;&amp; vue-cli-service build”,
},
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cffe8a44d183c228ee34758a41cdcfa/" rel="bookmark">
			【网络】IP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
感性理解
IP协议报头
解包分用
分片与组装
网段划分
为什么要进行网段划分
感性理解网段划分
特殊IP地址+IP地址的数量限制
私有IP地址和公网IP地址
路由
感性理解 1.在之前的文章中介绍了TCP协议，TCP提供了可靠传输的一系列策略（如：确认应答，超时重传.....）,但是真正完成传输工作的是传输层之下的网络层和数据链路层。TCP(策略)+IP(行动) = 可靠的将数据传输到对端。
2.IP层的核心工作：IP地址可以定位主机，把数据报文从主机A跨网络送到主机B，也就是数据的路由。
3.IP = 目标网络 + 主机号（后面详细介绍）。
4.主机: 配有IP地址, 但是不进行路由控制的设备; 路由器: 即配有IP地址, 又能进行路由控制; 节点: 主机和路由器的统称。
IP协议报头 ●4位版本号(version): 指定IP协议的版本, 对于IPv4来说, 就是4.
●4位头部长度(header length): IP头部的长度是多少个32bit, 也就是 length * 4 的字节数。4个比特位能够表示的十进制数据范围是【0,15】,TCP报头的总长度=4位首部长度*4字节，也就是说报头的总长度范围是【0，60】，但是报头中还包含固定大小的20字节。综上所述，报头的最终范围是【20，60】。
●8位服务类型(Type Of Service): 3位优先权字段(已经弃用), 4位TOS字段, 和1位保留字段(必须置为0). 4位TOS分别表示: 最小延时, 最大吞吐量, 最高可靠性, 最小成本. 这四者相互冲突, 只能选择一个。
●16位总长度(total length): IP数据报整体占多少个字节。
●16位标识(id): 唯一的标识主机发送的报文。如果IP报文在数据链路层被分片了, 那么每一个片里面的这个id都是相同的。
●3位标志字段: 第一位保留(保留的意思是现在不用, 但是还没想好说不定以后要用到). 第二位置为1表示禁止分片, 这时候如果报文长度超过MTU, IP模块就会丢弃报文. 第三位表示"更多分片", 如果分片了的话,最后一个分片置为0, 其它片是1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cffe8a44d183c228ee34758a41cdcfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fda818aba2713db7c9bb76186d6cb919/" rel="bookmark">
			使用EF Core自动建表简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入Tools包 使用NuGet安装Microsoft.EntityFrameworkCore.Tools包
在NuGet包控制台输入:
Install-Package Microsoft.EntityFrameworkCore.Tools
同时下载自己想要连接的数据库的EF Core支持包，这里以SqlServer举例:
Install-Package Microsoft.EntityFrameworkCore.SqlServer
或者使用Visual Studio图形界面进行下载:
找到工具-&gt;NuGet包管理器-&gt;管理解决方案的NuGet程序包
搜索下载到这两个包:
数据库配置 建立要创建的实体类: public class Book { public long Id { get; set; } public string? Title { get; set; } public DateTime PubTime { get; set; } public double Price { get; set; } public string? Author { get; set; } } 创建配置类，实现IEntityTypeConfiguration接口: public class BookEntityCinfig : IEntityTypeConfiguration&lt;Book&gt; { public void Configure(EntityTypeBuilder&lt;Book&gt; builder) { //在Totable方法中输入所建表的名称,例如这里是Books表 builder.ToTable("Books"); } } 创建数据库配置类，实现DbContext: public class TestDbContext:DbContext { // 有几个实体就有几个DbSet public DbSet&lt;Book&gt; Books { get; set; } /// &lt;summary&gt; /// 指定连接的字符串和数据库 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fda818aba2713db7c9bb76186d6cb919/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4da86fcda5b01392945968e4b567b9fb/" rel="bookmark">
			k3s基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
准备
术语说明
在线安装
离线安装
常用命令
Helm 安装helm
增加国内镜像仓库源、查看仓库列表、在仓库搜索chart
创建release 自定义chart配置文件
etcd命令
准备 虚拟机192.168.255.130 安装k3s server，192.168.255.131安装k3s agent
修改/etc/hostname 和 /etc/hosts，让主机名不一样
术语说明 kubeconfig:用于配置集群访问的文件称为 kubeconfig 文件。 这是引用到配置文件的通用方法，并不意味着有一个名为 kubeconfig 的文件。 kubectl 命令行工具使用 kubeconfig 文件来查找选择集群所需的信息，并与集群的 API 服务器进行通信。默认情况下，kubectl 在 $HOME/.kube 目录下查找名为 config 的文件。 你可以通过设置 KUBECONFIG 环境变量或者设置 --kubeconfig参数来指定其他 kubeconfig 文件 在线安装 公共依赖 切换yum源CentOS-Base.repo，安装以下，每个节点都执行
yum install -y container-selinux selinux-policy-base yum install -y https://rpm.rancher.io/k3s/stable/common/centos/7/noarch/k3s-selinux-0.2-1.el7_8.noarch.rpm 环境变量 给每个节点设置一个K3S_NODE_NAME环境变量，每个节点不同，否则会出现server is not ready: Node password rejecte，try enabling a unique node name with the --with-node-id flag的报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4da86fcda5b01392945968e4b567b9fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2acbfc031a9694ec66ec7469f280e0/" rel="bookmark">
			老照片修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Bringing-Old-Photos-Back-to-Life1.新建环境 配置python、torch2.下载安装Bringing-Old-Photos-Back-to-Life:报错！1、安装dilb报错：2、INTEL MKL ERROR: */anaconda3/lib/libmkl_avx512.so: undefined symbol: mkl_sparse_op3、Cannot cast ufunc 'multiply' output from dtype('float64') to dtype('uint8') with casting rule 'same_kind' 二、GFPGAN0、新建环境 配置python、torch1、克隆仓库2、安装依赖包3、下载预训练模型4、推理！报错！1、'GET was unable to find an engine to execute this computation'2、v1版本报错：name 'fused_act_ext' is not defined 一、Bringing-Old-Photos-Back-to-Life https://github.com/microsoft/Bringing-Old-Photos-Back-to-Life
1.新建环境 配置python、torch conda create -n old_photos python=3.8 pip install torch==1.9.0+cu111 torchvision==0.10.0+cu111 torchaudio==0.9.0 -f https://download.pytorch.org/whl/torch_stable.html 2.下载安装Bringing-Old-Photos-Back-to-Life: https://github.com/microsoft/Bringing-Old-Photos-Back-to-Life
先cd到Bringing-Old-Photos-Back-to-Life目录：
# 克隆 Synchronized-BatchNorm-PyTorch 存储库 cd Face_Enhancement/models/networks/ git clone https://github.com/vacancy/Synchronized-BatchNorm-PyTorch cp -rf Synchronized-BatchNorm-PyTorch/sync_batchnorm . cd .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec2acbfc031a9694ec66ec7469f280e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aace6ead0be0abc618c9a5a4963c9574/" rel="bookmark">
			解决IDEA在XxxMapper.xml写SQL语句没有提示的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、连接数据库 2、设置SQL方言 3、把XxxMapper.xml映射文件头部https更改为http 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9270b748349e565ec5189445725bf181/" rel="bookmark">
			STM32F4 HAL库使用DMA进行ADC采样实时发送波形到串口显示（包含傅里叶变换）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.总体逻辑 按下 STM32F4 的 KEY0 按键，通过外部中断的方式对按键进行检测，然后进行一次固定点数的 DMA ADC 采集，采集完成后在 DMA 的中断发送采集到的数据，然后清空数据区准备下一次的按键中断。电脑接受到串口数据后对数据进行简单处理和傅里叶变化，然后实时显示在电脑上。
开发板：正点原子探索者STM32F407ZG
2. STM32 源工程文件
可以拿着正点原子的官方例程的单通道ADC采集(DMA读取)实验进行修改
这里只展示部分重要代码
2.1 外部中断处理函数 打开 exti.c 文件，修改为以下的代码。删掉了冗余的代码，在 KEY0 按下后的逻辑中加入了 adc_dma_enable(ADC_DMA_BUF_SIZE) 来启动一次ADC采集
#include "./SYSTEM/sys/sys.h" #include "./SYSTEM/delay/delay.h" #include "./BSP/LED/led.h" #include "./BSP/KEY/key.h" #include "./BSP/EXTI/exti.h" #include "./BSP/ADC/adc.h" /** * @brief KEY0 外部中断服务程序 * @param 无 * @retval 无 */ void KEY0_INT_IRQHandler(void) { HAL_GPIO_EXTI_IRQHandler(KEY0_INT_GPIO_PIN); /* 调用中断处理公用函数 清除KEY0所在中断线 的中断标志位 */ __HAL_GPIO_EXTI_CLEAR_IT(KEY0_INT_GPIO_PIN); /* HAL库默认先清中断再处理回调，退出时再清一次中断，避免按键抖动误触发 */ } /** * @brief 中断服务程序中需要做的事情 * 在HAL库中所有的外部中断服务函数都会调用此函数 * @param GPIO_Pin:中断引脚号 * @retval 无 */ void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { delay_ms(20); /* 消抖 */ switch(GPIO_Pin) { case KEY0_INT_GPIO_PIN: if (KEY0 == 0) { LED0_TOGGLE(); adc_dma_enable(ADC_DMA_BUF_SIZE); /* 启动一次ADC DMA采集 */ } break; default : break; } } /** * @brief 外部中断初始化程序 * @param 无 * @retval 无 */ void extix_init(void) { GPIO_InitTypeDef gpio_init_struct; key_init(); gpio_init_struct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9270b748349e565ec5189445725bf181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c3683cedf39835291e81d09df07e1a7/" rel="bookmark">
			116、基于51单片机智能风扇pwm调速手动自动无线红外遥控风扇温控风扇系统设计(程序&#43;原理图&#43;Proteus仿真&#43;参考论文&#43;开题报告&#43;设计资料&#43;流程图&#43;元器件清单等)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 随着气温的逐渐上升，风扇的需求量也逐渐扩大。传统风扇不能根据外界温度的变化对风扇转速快慢进行调整，也不能对风扇的开关与否进行自动控制，这将会损耗大量的电力资源。针对这些问题，开发设计了智能风扇控制系统。
该系统以51单片机最小系统为核心，利用DS18B20温度采集模块，LCD 1602显示屏、红外遥控器、按键组成智能风扇控制系统。DS18B20温度采集模块将采集到的温度与系统开始设置的阈值做比较,并将采集到的温度数据显示在LCD1602显示屏上。当温度高于所设置的温度,风扇将会自动吹风；当温度低于所设置的温度时风扇仍保持关闭状态。该系统采取了三种工作方式，第一种工作方式为按键控制—手动模式；第二种工作方式为自动模式，根据温度自动调节风速；第三种工作方式为红外遥控器控制，在遥控器上按下相应的功能按键，即可控制风扇，手动模式和自动模式切换，以及遥控改变风扇的转速等。 关键词： 51单片机；智能风扇；红外遥控； 方案比较与选择
遥控方式选择
（1）方案一
基于超声波遥控方式。超声波遥控方式中的超声传感器频带窄，所能携带的信息量少，易受干扰而引起误动作，同时，该种方式作用距离短，通用性强，可互换。假如采用无线电遥控方式。无线电具有绕射和穿透性，不受角度、方向和障碍物的限制。但是由于我们生活的周围充满了电磁波和无线电波，所以无线电遥控很容易受到干扰，稳定性不够高。还可以采用为红外线遥控方式。
（2）方案二
红外线技术出现较早，成本低，控制内容多，抗干扰能力强，响应速度快，不会对其它电器产生干扰，体积小，成本低，功耗小，与其它方式比，可降低消耗功率90%，而且在日常家庭生活中，几乎家家都有电视遥控器，对遥控器比较熟悉，因此选用一个MP3红外遥控器，再用单片机加一个红外接收头就可以读取遥控器的键值，进而根据键值执行相应的操作。
所以综上所述，从家具布局和实用性方面考虑，本设计选用红外无线遥控方案。
显示器选择方案
方案一：采用12864液晶显示屏。液晶显示模块是128×64点阵的汉字图形型液晶显示模块，可显示汉字及图形，内置8192个中文汉字（16X16点阵）、128个字符（8X16点阵）及64X256点阵显示RAM（GDRAM）。可与CPU直接接口，提供两种界面来连接微处理机：8-位并行及串行两种连接方式。具有多种功能：光标显示、画面移位、睡眠模式等。
方案二：采用LCD1602液晶显示屏。LCD1602A 是一种工业字符型液晶，能够同时显示16x02 即32个字符。（16列2行）。1602只能显示字母、数字和符号能显示16*2个字符，但寄存器不止32个，有一些显示效果，如字符一个个显示、字符从左到右或从右到左显示等等，显示效果简单。
总结：在编程使用方面，两者难度差不多，原理差不多，都是写指令、写地址、写数据等等。当然12864液晶屏显示更全面、字符更多。相比于1602液晶屏、12864能更形象具体的实现显示功能。不过1602液晶屏也能实现设计的要求。网上买比较廉价，最低的六块钱左右。而12864液晶显示屏最便宜的也要四十块钱。从造价方面考虑，当然是价格低廉的优先。而LCD1602A就是最好的选择。
设计方案
该系统以STC89C52单片机为核心，通过温度采集模块，LCD1602显示屏、按键，红外遥控器控制模块构成。温度采集模块主要将采集到的温度值与系统设置的初始温度值进行比较。若采集到的温度值大于初始温度值，则风扇将会开启；若采集到的温度值小于初始温度值，风扇将一直保持关闭状态。LCD1602显示屏主要显示风扇档位，温度、模式等数据。自动模式下采集到的温度大于初始温度值，则风扇转动；反之，风扇关闭。手动模式下风扇转速和温度无关，需要通过按键调节风速转速。系统功能结构图如图1所示：
一、硬件方案 硬件组成：本系统采用51单片机最小系统电路（复位电路+晶振时钟电路+单片机电源电路）+ LCD1602液晶显示模块 + 18B20温度传感器+红外接收头+风扇+按键设计而成。
二、设计功能 1、本设计基于STC89C51/52（与AT89S51/52、AT89C51/52通用）。
2、LCD1602显示当前温度，设置温度上限，以及当前风扇档位和模式。
3、采用PWM调速的原理来实现风扇速度的控制，当温度低于温度的下限值时，风扇不转（0档），当温度高于下限温度时风扇转动（1档），同时温度每升高2℃风扇档位自动上升一个档位（2-4档）。
4、可设置温度下限值：从左到右按键依次是：加、减、档位加、档位减、切换（手动模式和自动模式切换）。按下“加”或“减”键后对需要设置的温度进行设置，手动模式下按下档位加、档位减则对风扇档位进行加减（一共四个档位，0档则风扇关闭），按下模式切换则对风扇进行手动模式和自动模式进行切换。
5、可通过红外遥控器实现按键的所有功能（温度设置，档位加减，手自动模式切换）。
6、温度设置范围：10-40℃。
三、实物图 单片机模块设计
单片微型计算机是随着微型计算机的发展而产生和发展的。自从1975 年美国德克萨斯仪器公司的第一台单片微型计算机（ 简称单片机）TMS-1000 问世以来，迄今为止，单片机技术已成为计算机技术的一个独特分支，单片机的应用领域也越来越广泛，特别是在工业控制中经常遇到对某些物理量进行定时采样与控制的问题，在仪器仪表智能化中也扮演着极其重要的角色。
如果将8位单片机的推出作为起点，那么单片机的发展历史大致可以分为以下几个阶段：
第一阶段（1976—1978）：单片机的探索阶段。以Intel公司的MCS-48为代表。MCS-48的推出是在工控领域的探索，参与这一探索的公司还有Motorola、Zilog等。都取得了满意的效果。这就是SCM的诞生年代，“单片机”一词即由此而来。
第二阶段（1978—1982）：单片机的完善阶段。Intel公司在MCS-48基础上推出了完善的、典型的单片机系列MCS-51。它在以下几个方面奠定了典型的通用总线型单片机体系结构。
（1）完善的外部总线。MCS-51设置了经典的8位单片机的总线结构，包括8位数据总线、16位地址总线、控制总线及具有多机通信功能的串行通信接口。
（2）CPU外围功能单元的集中管理模式。
（3）体现工控特性的地址空间及位操作方式。
（4）指令系统趋于丰富和完善，并且增加了许多突出控制功能的指令。
第三阶段（1982—1990）：8位单片机的巩固发展及16位单片机的推出阶段，也是单片机向微控制器发展的阶段。Intel公司推出的MCS-96系列单片机，将一些用于测控系统的模数转换器、程序运行监视器、脉宽调制器等纳入片中，体现了单片机的微控制器特征。
第四阶段（1990—）：微控制器的全面发展阶段。随着单片机在各个领域全面、深入地发展和应用，出现了高速、大寻址范围、强运算能力的8位/16位/32位通用型单片机，以及小型廉价的专用型单片机。
单片机是在集成电路芯片上集成了各种元件的微型计算机，这些元件包括中央处理器CPU、数据存储器RAM、程序存储器ROM、定时/计数器、中断系统、时钟部件的集成和I/O接口电路。由于单片机具有体积小、价格低、可靠性高、开发应用方便等特点，因此在现代电子技术和工业领域应用较为广泛，在智能仪表中单片机是应用最多、最活跃的领域之一。在控制领域中,现如今人们更注意计算机的底成本、小体积、运行的可靠性和控制的灵活性。在各类仪器、仪表中引入单片机，使仪器仪表智能化，提高测试的自动化程度和精度，提高计算机的运算速度，简化仪器仪表的硬件结构，提高其性能价格比。
单片机引脚介绍
单片机主要特点：
（1）有优异的性能价格比。
（2）集成度高、体积小、有很高的可靠性。单片机把各功能部件集成在一块芯片上，内部采用总线结构，减少了各芯片之间的连线，大大提高了单片机的可靠性和抗干扰能力。另外，其体积小，对于强磁场环境易于采取屏蔽措施，适合在恶劣环境下工作。
（3）控制功能强。为了满足工业控制的要求，一般单片机的指令系统中均有极丰富的转移指令、I/O口的逻辑操作以及位处理功能。单片机的逻辑控制功能及运行速度均高于同一档次的微机。
（4）低功耗、低电压，便于生产便携式产品。
（5）外部总线增加了I2C（Inter-Integrated Circuit）及SPI(Serial Peripheral Interface)等串行总线方式，进一步缩小了体积，简化了结构。
（6）单片机的系统扩展和系统配置较典型、规范，容易构成各种规模的应用系统。
优异的性能价格比。
1）集成度高、体积小、有很高的可靠性。
单片机把各功能部件集成在一块芯片上，内部采用总线结构，减少了各芯片之间的连线，大大提高了单片机的可靠性与抗干扰能力。另外，其体积小，对于强磁场环境易于采取屏蔽措施，适合于在恶劣环境下工作。
此外，程序多采取固化形式也可以提高可靠性。
2）控制功能强。
为了满足工业控制要求，一般单片机的指令系统中均有极丰富的转移指令、I/O口的逻辑操作以及位处理功能。单片机的逻辑控制功能及运行速度均高于同一档次的微机。
单片机的系统扩展、系统配置较典型、规范，容易构成各种规模的应用系统。
VCC：STC89C52电源正端输入，接+5V。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c3683cedf39835291e81d09df07e1a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b71529b698f029ba8c34f37ff0843cb/" rel="bookmark">
			XML存在特殊字符导致无法解析，使用CDATA或转译解决难题！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XML 解析器通常情况下会处理XML文档中的所有文本，由于业务需求无法强制规范数据中的特殊符号，解析器识别特殊字符导致XML格式出现异常，无法正常解析。
不合法的XML字符必须被替换为相应的实体，如果在XML文档中使用类似"&lt;" 的字符, 那么解析器将会出现错误，因为解析器会认为这是一个新元素的开始。
转译字符 处理方式有两种，一用转译符就行字符转译，使解析器正常识别：
&amp;lt;&lt;小于号&amp;gt;&gt;大于号&amp;amp;&amp;和&amp;apos;'单引号&amp;quot;"双引号 CDATA标签 二使用CDATA标签，使参数成为一个整体，不再识别其中的字符：
语法格式：&lt; ! [ CDATA ［忽略检查的文本］］&gt; 在CDATA中将文本的内容写入，那么这段文本内容会被忽略检查，无论里面是否包含XML敏感内容，全部被当作普通的文本去看待。例如：
&lt;content&gt; &lt;![CDATA[ &lt;reportNo&gt;9885-LIS&lt;/reportNo&gt; ]]&gt; &lt;/content&gt; 当前博客仅供参考！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f4567cada04fcd1fda65fe1e6a7ea7/" rel="bookmark">
			Typora自定义上传图片到服务器图床(java实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常使用Typora写博客,遇到图片需要手动上传的服务器映射,Typora软件新版本支持自定义上传到图床本篇记录上传到本人服务器中。
实现步骤(java实现):
1、Typora使用Custom Command,请求到本地jar包main方法中，请求参数为本地图片路径
2、jar包拿到本地图片路径,请求服务器上传文件接口
3、服务器存储,并且返回url映射地址
话不多说,直接撸代码~~~
一、本地jar包 1、idea创建SpringBoot空项目,可以不勾选任何依赖 2、pom.xml配置，导入hutool包。(直接使用我的) &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/cn.hutool/hutool-all --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.3.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3、创建类TyporaUploadFile，mian方法使用hutool上传到服务器接口 import cn.hutool.core.io.FileUtil; import cn.hutool.http.HttpUtil; import java.util.Arrays; import java.util.HashMap; /** * @author Chen Shaohua * @date 2023/1/17 15:44 */ public class TyporaUploadFile { public static void main(String[] args) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53f4567cada04fcd1fda65fe1e6a7ea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a497d2e6c0a9fbec86741b82a6a461a9/" rel="bookmark">
			基于单片机的楼宇水塔水位检测系统设计与实现（设计报告&#43;源代码&#43;proteus仿真&#43;PCB&#43;开题报告&#43;中期报告）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘：
本论文是针对楼宇水塔水位检测系统的设计与实现进行了研究。通过使用单片机作为控制核心，结合传感器和执行器等外设，实现了对水塔水位的实时检测和控制。本系统具有良好的实时性和可靠性，可以方便地监测和控制楼宇水塔的水位，提高了水资源的利用效率。
关键词：单片机，水位检测，水塔，控制系统
1.引言
楼宇水塔是供应楼宇内部生活、消防用水的重要设施，在楼宇运行中起到了至关重要的作用。为了保证水塔水位的合理控制，降低浪费水资源的现象，设计并实现一套水位检测系统显得非常必要。
2.系统设计
2.1 系统硬件设计
本系统的硬件主要由单片机、传感器和执行器等组成。单片机是系统的控制核心，负责检测传感器信号并通过执行器进行控制。传感器主要用于检测水位信号，可以采用浮子式水位传感器或压阻式水位传感器。执行器主要用于控制水泵等设备的启停。
2.2 系统软件设计
本系统的软件设计主要包括采集与控制程序。采集程序负责读取传感器信号，并将信号转化为相应的水位数据。控制程序根据水位数据进行相应的控制操作，使水塔的水位保持在设定的范围内。
3.系统实现
在实现过程中，首先根据实际需求选择合适的单片机进行搭建，搭建电路并连接传感器和执行器。然后编写相应的软件程序，实现水位数据的读取和控制操作。最后进行系统调试和优化，确保系统的稳定性和可靠性。
4.实验结果与分析
通过对楼宇水塔水位检测系统的实验测试，得到了良好的实验结果。系统能够准确地检测水塔水位，并根据设定的范围进行控制，实现了对水位的有效管理。实验结果表明，本系统具有较高的准确性和稳定性。
5.结论
本论文基于单片机的楼宇水塔水位检测系统设计与实现，通过使用单片机作为控制核心，结合传感器和执行器等外设，实现了对水塔水位的实时检测和控制。系统具有较高的准确性和稳定性，可以方便地监测和控制楼宇水塔的水位，提高了水资源的利用效率。在今后的工程实践中，可以进一步优化和改进系统，提升系统的性能和功能。
参考资料
基于单片机的楼宇水塔水位检测系统设计与实现（设计报告+源代码+proteus仿真+PCB+开题报告+中期报告）
https://download.csdn.net/download/woaimx_1314/87930293
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fe169aec0ab3172142e518371c429c4/" rel="bookmark">
			java连接打印机并进行打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先添加maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt; &lt;artifactId&gt;pdfbox&lt;/artifactId&gt; &lt;version&gt;2.0.24&lt;/version&gt; &lt;/dependency&gt; 连接同网段的打印机 1.先查询本网段的在线打印机名称
public JsonResult&lt;List&lt;String&gt;&gt; getPrinterList() { List&lt;String&gt; list = new ArrayList&lt;&gt;(); HashPrintRequestAttributeSet requestAttributeSet = new HashPrintRequestAttributeSet(); DocFlavor flavor = DocFlavor.INPUT_STREAM.AUTOSENSE; //查找所有的可用的打印服务 PrintService[] printService = PrintServiceLookup.lookupPrintServices(flavor, requestAttributeSet); if (printService == null || printService.length == 0) { log.info("打印获取失败，未找到可用打印机，请检查。"); } if (printService != null) { for (PrintService print : printService) { list.add(print.getName()); } } return JsonResult.ok(list); } 因为打印的时候只需要打印机名称就行了，所以这里只获取了打印机名称。
2.再通过打印机名称来进行打印操作
方法入参为打印机名称和文件。
public Boolean printFile(String printerName, MultipartFile multipartFile) { } 匹配打印机名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fe169aec0ab3172142e518371c429c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43aac739eb81c8e98041745eaf857b8d/" rel="bookmark">
			Linux驱动开发：uboot移植流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：Linux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段 bootloader 程序。而 uboot 作为最常见的 bootloader 选择，是每个 Linux 驱动工程师必需掌握的。本文为博主总结的 uboot 移植笔记，包含作者总结的 uboot 启动流程概述，希望能给大家移植和学习 uboot 的时候提供参考与帮助。
实验硬件：imx6ull；uboot版本：2016.03 一、U-Boot简介 1.1 Bootloader介绍 Linux系统启动的第一个关键程序bootloader，也就是说芯片上电后先运行一段bootloader程序。bootloader 和 Linux 内核的关系 就跟 PC 上的 BIOS 和 Windows 的关系一样，bootloader 就相当于 BIOS。所以Linux 系统移植第一步就需要进行bootloader的移植，现有的bootloader有很多，比如：U-Boot、vivi、RedBoot 等，其中以 U-Boot 使用最为广泛。
常见的Bootloader：
1.2 uboot启动流程 1、uboot的读取方式
(1)、SD卡读取；(2)、Flash读取；(考虑到部分Linux开发板的Flash为NAND Flash每次重写烧入需要反复擦除后重写，为了保证Flash的寿命，大都采用SD卡读取启动的方式)
2、uboot的启动流程
uboot的两大主题：（1）稳定性；（2）速度；
稳定性分析：uboot作为芯片上电第一道运行的程序，如果它出错将导致后续内核启动，根文件系统挂载等都无从谈起。
速度分析：uboot的速度是直接与性能挂钩的，uboot为了提升自身速度，会选择自挂载和挂载内核到内存上运行，提升速度。
★作者将uboot的总体启动流程分为2部分：arch级初始化(架构)和板级初始化。
uboot启动流程总结：
uboot的语言构成：10%的汇编语言；90%的C语言
uboot的启动特性：稳定性；速度
uboot的简化版启动流程：
1、设置状态寄存器 cpsr ，使CPU进入 SVC 特权模式，并且禁止 FIQ 和 IRQ；
2、关闭看门狗、中断、MMU、Cache；
3、初始化部分寄存器和外设（时钟、串口、Flash、内存）；
4、自搬移uboot到内存中运行；
5、设置栈空间并初始化global_data；
6、剩余大部分硬件的初始化；
7、搬移Linux内核到内存；
推荐学习博客：Linux驱动开发：uboot启动流程详解_uboot启动linux_混分巨兽龙某某的博客-CSDN博客
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43aac739eb81c8e98041745eaf857b8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2f9d40feb935ff58f1e3d9bc79b331/" rel="bookmark">
			「RabbitMQ」实现消息确认机制以确保消息的可靠发送、接收和拒收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
介绍
方案
配置手动确认
使用 「Bean 」 配置RabbitMQ的属性
确定消费、拒绝消费、拒绝消费进入死信队列
模拟生产者发送消息①
介绍 RabbitMQ 的消息确认机制应用场景非常广泛，尤其是在需要确保消息可靠性和避免消息丢失的场合下更为重要，例如：金融系统、电商交易系统等。以下是消息确认机制的一些常见应用场景和好处：
1. 确认消息的可靠性
在 RabbitMQ 中，生产者将消息发送到队列之后就不能再控制该消息的安全性，而消费者需要及时地对该消息进行处理并进行确认，以确保该消息已经被成功消费。使用消息确认机制可以保证消息只会被消费一次，从而确保消息的可靠性。
2. 防止消息丢失
在 RabbitMQ 中，当消费者从队列中取出消息之后，消息就被认为是已经消费，如果消费者在消费过程中出现异常导致消费失败，那么该消息就会从队列中被删除，从而导致消息丢失。使用消息确认机制可以避免这种情况的发生，从而保证消息不会丢失。
3. 避免重复消费
在 RabbitMQ 中，如果消费者在处理完一个消息之后没有及时确认该消息已经被消费，那么 RabbitMQ 认为该消息未被消费，就会将该消息重新发送给另一个消费者进行消费，从而导致消息重复消费。使用消息确认机制可以避免这种情况的发生，从而保证消息只会被消费一次。
4. 节约系统资源
在 RabbitMQ 中，当一个消费者同时处理多个消息时，可能会导致系统资源短缺或者消息被重复消费。使用消息确认机制可以限制消费者一次只处理一个消息，从而提高系统的稳定性和可靠性，同时还可以避免消息被重复消费的问题。
综上所述，消息确认机制在 RabbitMQ 中的应用场景非常广泛，可以有效地保证消息的可靠性、避免消息丢失和重复消费、节约系统资源等。因此，在实际应用中，推荐使用消息确认机制来确保 RabbitMQ 的高可用和高性能。
方案 在消息传递系统中，实现消息的可靠性可以通过引入消息确认机制来完成。该机制涉及三个方面：确认消息的发送、确认消息的接收以及拒收消息的处理。以下是这一优化的详细方案：
确认消息的发送：
发送者在向消息队列发送消息之前，需等待接收到消息队列发出的确认信号。当消息成功写入消息队列后，消息队列会发送一个确认信号给发送者，表示消息已经被成功接收并保存。如果发送者在一定时间内未收到确认信号，可以选择重新发送消息或执行其他错误处理逻辑。 确认消息的接收：
接收者在从消息队列中获取消息后，需发送一个确认信号给消息队列，表示已经成功接收到该消息。消息队列收到确认信号后，会将该消息标记为已确认，并在需要的情况下进行下一步处理。如果接收者在一定时间内未发送确认信号，消息队列可以将该消息重新投递给其他接收者或执行其他补救措施。 拒收消息的处理：
如果接收者无法处理某条消息，可以发送拒收信号给消息队列，表示拒绝接收该消息。消息队列收到拒收信号后，可以将该消息重新投递给其他接收者或执行其他适当的处理策略。发送拒收信号的原因可能包括消息格式错误、业务逻辑不符等。 通过实现消息确认机制，可以提高消息传递的可靠性和稳定性。发送者可以确保消息被正确写入消息队列，接收者可以确保每条消息被成功接收，并且拒收功能可以帮助处理无法处理的消息。
配置手动确认 #自动签收:auto 手动:manual spring.rabbitmq.listener.simple.acknowledge-mode=manual 若要实现手动确认，必须在配置中这样配置，否则消息会被重复消费，还会遇见不可预料的报错结果
使用 「Bean 」 配置RabbitMQ的属性 @Configuration public class RabbitMqConfig { Logger logger = LoggerFactory.getLogger(RabbitMqConfig.class); @Bean public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) { RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory); // 设置开启Mandatory,才能触发回调函数,无论消息推送结果怎么样都强制调用回调函数 rabbitTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad2f9d40feb935ff58f1e3d9bc79b331/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ab2dd6d460dff1cdc3d269d12dc2d4/" rel="bookmark">
			U盘写流程USB协议抓包分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		U盘写流程USB协议抓包分析 因好奇于操作系统在对U盘这个块设备是如何进行读写传递数据包，笔者通过抓包测试，做了一个简单分析。安装了wireshark的usbPcap即能抓取主机USB接口上的usb包。
A、基本包信息分析 让我们先从读流程开始分析一下USB包的包结构，如下是一个典型的读流程的抓包结果
URB包
u盘传输基于usb协议中的usb mass storage协议，根据查看的一个blog的说明，USBPcap pseudoheader 部分不属于发送内容部分，是USBPcap控制程序的部分。
URB包中用于确定地址的字段有3个，USR bus id总线ID, Device Address设备地址, Endpoint：终端ID，区分IN/OUT方向，这个点不同的U盘实现可能存在差异，笔者查看的一个U盘请求响应都是同一个Endpoint ID，而另一个U盘请求响应则是不同的ID。
URB Transfer Type即传输类型，有四种类型，这里抓包看到URB_BULK 为0x03 , 一共有bulk,isochronous,interrupt,control四种类型。bulk transfer用于传输大量的，非实时的数据。在设备的bulk端点上执行，其方向可以是从主机到设备，也可以是从设备到主机。常用于打印机、存储设备等需要大量数据传输的外设
SCSI包
usbms之上则是基于scsi协议。SCSI是一种计算机总线，包含多种命令。SCSI的体系结构是一种典型的client-server模型，结构中有启动器和目标器。SCSI传输层遵循统一的SCSI命令模型，完整的SCSI请求由CDB，数据和命令属性信息构成。CDB描述了SCSI命令的具体细节，有多种不同的格式，10,12,16字节等。
SCSI的命令集文档，主要分为通用类文档和适用于特定设备类的文档，通用类文档称为SPC，SCSI Primary Commands, 特定设备类文档比如块设备类文档，称为SBC，SCSI Block Commands文档，定义了适用于块设备的命令集，如READ, WRITE, VERIFY。
我们截图抓到的包机一个SCSI协议中10字节的CDB，其中的opcode为读，是SBC中规定的块设备的读命令，然后跟着LBA逻辑地址和要读取的长度 Transfer Length，这里是8，单位是512字节，即4096字节。
B、写流程分析 我们将U盘格式化为默认的exFAT格式，分配单元大小为128KB，分别写1KB小文件，和6MB大文件进行抓包。
传输一个1字节的小文件 可以看到虽然只传输了1字节的小文件，window执行了多笔写操作，且大小不一，有length为1,8,16，其单元为512字节，所以写的大小包含512字节，4096字节，8192字节。可以猜测除了写文件本身之外，还需要对文件系统的元数据进行修改，以及整个文件系统占用的总大小等等元信息进行修改，所以需要写多笔数据。
但重新查看文件系统的大小，可以发现确实增大了128KB，所以exFAT格式化分配单元为128KB大小，文件小于128KB也是占用128KB的大小空间。
传输一个9MB的文件 这里我对抓到的包截了首尾两张图，可以看到也是执行了多笔写操作，且因为传输了大文件，单个SCSI请求的最大length是1024，1024*512 = 524288，512KB左右大小的数据。且最大的数据都是512KB大小，且通过LBA可以看到，逻辑地址都是连续的，逻辑地址也是以512字节的sector为单位。
C、不同类型文件系统写流程差异分析 根据上述的抓包结果，可以初步了解到通过usb协议写U盘的基本流程，但还是会存在几个疑惑。针对这个传输包的大小1024个sector的限制，是文件系统层面的限制，还是协议层面的限制，还是U盘的限制，我简单查了下资料，没有发现说明，就再做了下实验。
1、格式化为NTFS格式 将U盘格式化为NTFS格式，分配单元大小选择默认的4096字节，传输大文件得到结果如下，最大的length也是1024，同样逻辑地址LBA是连续的
2、 使用其他厂家的U盘 使用同样基于exFAT的128KB单元大小的其他厂商的U盘进行大文件的传输，也发现了同样的限制。
综上，可以猜测单次传输最大1024个sector的限制可能是协议层面的限制。
参考文档 https://blog.csdn.net/tanmx219/article/details/104002602
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef9219e23c1103b39a5a8d5286f07a9/" rel="bookmark">
			isBlank函数和isEmpty函数的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 StrUtil.isBlank(CharSequence)：该方法用于判断字符串是否为空或仅包含空白字符。如果传入的字符串为null、空字符串(“”)或仅包含空白字符（如空格、制表符、换行符等），则返回true；否则返回false。
StrUtil.isEmpty(CharSequence)：该方法用于判断字符串是否为空。如果传入的字符串为null或空字符串(“”)，则返回true；否则返回false。与isBlank()不同，isEmpty()不会考虑空白字符，只关注字符串是否为空。
String str1 = null; String str2 = ""; String str3 = " "; String str4 = "hello"; System.out.println(StrUtil.isBlank(str1)); // true System.out.println(StrUtil.isBlank(str2)); // true System.out.println(StrUtil.isBlank(str3)); // true System.out.println(StrUtil.isBlank(str4)); // false System.out.println(StrUtil.isEmpty(str1)); // true System.out.println(StrUtil.isEmpty(str2)); // true System.out.println(StrUtil.isEmpty(str3)); // false System.out.println(StrUtil.isEmpty(str4)); // false 总结：
isBlank()用于判断字符串是否为空或仅包含空白字符。isEmpty()用于判断字符串是否为空，不考虑空白字符。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/689a1cd3bf4f3cbf62ee4f9cb0a5abcd/" rel="bookmark">
			Linux 用户、用户组 ( 添加、删除、修改 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 使用者管理：http://cn.linux.vbird.org/linux_basic/linux_basic.php#part4
鸟哥官网（简体中文）：http://cn.linux.vbird.org/linux_basic/linux_basic.php
Linux 中将用户添加到组的指令：https://cnzhx.net/blog/linux-add-user-to-group/
1、Linux 单用户多任务，多用户多任务概念 Linux 是一个多用户、多任务的操作系统。
单用户多任务、多用户多任务 概念；
Linux 的 单用户、多任务：比如：以 beinan 登录系统，进入系统后，我要打开gedit 来写文档，但在写文档的过程中，我感觉少点音乐，所以又打开xmms 来点音乐；当然听点音乐还不行，MSN 还得打开，想知道几个弟兄现在正在做什么，这样一样，我在用beinan 用户登录时，执行了gedit 、xmms以及msn等，当然还有输入法fcitx ；这样说来就有点简单了，一个beinan用户，为了完成工作，执行了几个任务；Linux 的 多用户、多任务：上面除了 beinan 这个用户，可能还有其它的用户远程登录过来，也能做其它的工作。这就是多用户，很多用户同时用同一个系统，但并不所有的用户都一定都要做同一件事，所以这就有多用户多任务之说；比如：在服务器上面有 FTP 用户、系统管理员、web 用户、常规普通用户等，在同一时刻，可能有的弟兄正在访问论坛；有的可能在上传软件包管理子站，比如luma 或Yuking 兄在管理他们的主页系统和FTP ；在与此同时，可能还会有系统管理员在维护系统；浏览主页的用的是nobody 用户，大家都用同一个，而上传软件包用的是FTP用户；管理员的对系统的维护或查看，可能用的是普通帐号或超级权限root帐号；不同用户所具有的权限也不同，要完成不同的任务得需要不同的用户，也可以说不同的用户，可能完成的工作也不一样； 用户的角色区分：用户在系统中是分角色的，在 Linux 系统中，由于角色不同，权限和所完成的任务也不同；用户的角色是通过 UID 和识别的，特别是UID；在系统管理中，系统管理员一定要坚守UID 唯一的特性；
root 用户：系统唯一，是真实的，可以登录系统，可以操作系统任何文件和命令，拥有最高权限；虚拟用户：这类用户也被称之为伪用户或假用户，与真实用户区分开来，这类用户不具有登录系统的能力，但却是系统运行不可缺少的用户，比如 bin、daemon、adm、ftp、mail 等；这类用户都系统自身拥有的，而非后来添加的，当然我们也可以添加虚拟用户；普通真实用户：这类用户能登录系统，但只能操作自己家目录的内容；权限有限；这类用户都是系统管理员自行添加的； 多用户操作系统的安全
多用户系统对系统管理更为方便、更为安全。比如 beinan 用户下的某个文件不想让其它用户看到，只是设置一下文件的权限，只有beinan一个用户可读可写可编辑就行了，这样一来只有beinan一个用户可以对其私有文件进行操作，Linux 在多用户下表现最佳，Linux 能很好的保护每个用户的安全，从服务器角度来说，多用户的下的系统安全性也是最为重要的，常用的 Windows 操作系统在系纺权限管理方面根本没法和 Linux 或 Unix 类系统相比。 2、用户 (user）和 用户组（group）概念 用户 ( user ) Linux 是多用户操作系统，所以可以在 Linux 系统中建若干用户（user）。比如：我们的同事想用我的计算机，但我不想让他用我的用户名登录，因为我的用户名下有不想让别人看到的资料和信息（也就是隐私内容）这时我就可以给他建一个新的用户名，让他用我所开的用户名去折腾，这从计算机安全角度来说是符合操作规则的；
当然用户（user）的概念理解还不仅仅于此，在 Linux 系统中还有一些用户是用来完成特定任务的，比如 nobody 和 ftp 等，我们访问 LinuxSir.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/689a1cd3bf4f3cbf62ee4f9cb0a5abcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13664be1b3d3eb575be8677d4f0a69ab/" rel="bookmark">
			STM32 Proteus仿真空气质量检测环境监测苯PM2.5 MQ135温度湿度 -0068
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 Proteus仿真空气质量检测环境监测苯PM2.5 MQ135温度湿度 -0068
Proteus仿真小实验：
STM32 Proteus仿真空气质量检测环境监测苯PM2.5 MQ135温度湿度 -0068
功能：
硬件组成：STM32F103R6单片机 +LCD1602显示器+DHT11温度湿度+多个按键+蜂鸣器报警+电位器模拟苯+电位器模拟PM2.5+电位器模拟MQ135空气质量
1.单片机通过DHT11获取温度湿度。
2.单片机使用内部ADC准确测量出3个电位器的电压换算苯PM2.5 MQ135的值，0~99%。
3.当温度、湿度、苯、PM2.5、MQ135任意一个值超出设定的阈值。蜂鸣器报警。
4.可以通过按键灵活设定温度、湿度、苯、PM2.5、MQ135的报警值。
有功能视频哦：
可以哔哩哔哩B站，搜索UP主“单片机仿真汇”。在其空间中搜索关键词“空气质量”即可找到对应详细功能视频和介绍。
电路图:
部分源代码：
void main()
{
//时钟配置
SystemInit();
SystemCoreClockUpdate();
//引脚配置
GPIO_Configuration();
//LCD1602初始化
Init1602();
NVICConfig();
//定时器
TimerConfig(TIM3,10);//定时器
//开启定时器
TimerSW(TIM3, ENABLE);}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c32442614b81359fd4a068d8085b291/" rel="bookmark">
			大佬好文6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一次完整的渗透测试 - 知乎
这篇文章虽然看的不是很懂，但是很有逼格的样子
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e291be9748e440bcd33f0bdb39f3d06/" rel="bookmark">
			学习flask技术并应用在跨模态视频检索系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习flask技术并应用在跨模态视频检索系统 摘要 使用Flask技术在前端部署代码，通过http通信完成对双后端python端的AI服务调用，再返回给前端Top10视频片段的时间戳和置信度分数，以MVC模式绑定在前端的控件中进行可视化展示，显示Top10视频片段时间戳序列和封面图，点击即可跳转播放。
Flask技术简介 Flask是一个基于Python的轻量级Web应用框架，它提供了简单易用的API，可以快速地开发Web应用。Flask的核心特点是：
微框架：Flask只提供了最基本的Web开发功能，如路由、请求处理、模板渲染等，其他功能如数据库、表单、用户认证等需要通过扩展来实现。灵活：Flask没有强制的项目结构或编码规范，开发者可以根据自己的需求和喜好来组织代码和配置选项。易扩展：Flask有很多第三方扩展，可以方便地增加各种功能，如数据库操作、表单验证、用户认证、文件上传、缓存、日志等。RESTful：Flask支持RESTful风格的Web服务开发，可以通过不同的HTTP方法和URL来实现不同的资源操作。 具体内容 本文介绍了如何使用Flask技术在前端部署代码，实现一个跨模态视频检索系统。该系统的功能是：用户可以输入一段文本描述或者一张图片作为查询条件，系统会从一个视频库中检索出与之最相关的Top10视频片段，并在前端显示出来。用户可以点击视频片段的封面图或者时间戳来跳转到相应的位置播放。
该系统涉及到三个部分：前端、后端1和后端2。前端负责接收用户的输入，调用后端1和后端2的AI服务，展示检索结果。后端1负责处理文本查询，使用BERT模型将文本编码成向量，并与视频库中的文本向量进行相似度计算，返回Top10视频片段的ID和置信度分数。后端2负责处理图片查询，使用ResNet模型将图片编码成向量，并与视频库中的图片向量进行相似度计算，返回Top10视频片段的ID和置信度分数。视频库是一个预先处理好的数据集，包含了每个视频片段的文本描述、图片特征和时间戳信息。
前端工作 前端使用HTML、CSS和JavaScript来编写页面和交互逻辑。页面上有两个输入框，一个用于输入文本描述，一个用于上传图片。还有一个按钮用于提交查询。页面下方有一个表格用于显示检索结果。表格中每一行对应一个视频片段，包含了封面图、时间戳序列和置信度分数。用户可以点击封面图或者时间戳来跳转到相应的位置播放。
前端使用jQuery库来实现AJAX请求和响应处理。当用户提交查询时，前端会根据输入类型（文本或图片）来选择调用后端1或后端2的AI服务，并将输入内容作为参数传递。后端返回一个JSON格式的数据，包含了Top10视频片段的ID和置信度分数。前端根据ID从视频库中获取对应的封面图和时间戳信息，并将结果填充到表格中。
前后端实现代码 以下是前后端部分代码的示例，完整代码可以在这里查看。
前端代码 &lt;html&gt; &lt;head&gt; &lt;title&gt;跨模态视频检索系统&lt;/title&gt; &lt;style&gt; table, th, td { border: 1px solid black; border-collapse: collapse; } th, td { padding: 10px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;跨模态视频检索系统&lt;/h1&gt; &lt;p&gt;请输入一段文本描述或者上传一张图片作为查询条件，系统会从视频库中检索出与之最相关的Top10视频片段，并在下方显示出来。&lt;/p&gt; &lt;form id="query-form"&gt; &lt;label for="text-input"&gt;文本描述：&lt;/label&gt; &lt;input type="text" id="text-input" name="text-input" placeholder="例如：一个人在海边跳舞"&gt; &lt;br&gt; &lt;label for="image-input"&gt;图片：&lt;/label&gt; &lt;input type="file" id="image-input" name="image-input" accept="image/*"&gt; &lt;br&gt; &lt;input type="button" id="submit-button" value="提交查询"&gt; &lt;/form&gt; &lt;table id="result-table"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;封面图&lt;/th&gt; &lt;th&gt;时间戳序列&lt;/th&gt; &lt;th&gt;置信度分数&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e291be9748e440bcd33f0bdb39f3d06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6d896b79f2a84ea39d30a38ce4910c0/" rel="bookmark">
			masm32 链接问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我参考资料学习Windows环境下32位汇编时，编译倒没什么问题，可是链接就不对了。
网上也没找到解决办法，经过后来思考了一下，会不会是link.exe这个玩意有问题？比如有多个？
所以使用link的绝对路径试了一下，没想到还真的是。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e32b081712e140f9539d0cf2633f600/" rel="bookmark">
			Jetson nano部署YOLOv8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、YOLOv8模型训练1. 项目的克隆和必要的环境依赖1.1 项目的克隆1.2 项目代码结构整体介绍1.3 环境安装 2. 数据集和预训练权重的准备2.1 数据集2.2 预训练权重准备 3. 训练模型3.1 修改数据配置文件3.2 修改模型配置文件3.3 训练模型3.4 推理测试 二、YOLOv8模型部署1. 源码下载2. 环境配置2.1 trtexec环境变量设置 3. ONNX导出3.1 静态batch导出3.1.1 Transpose节点的添加3.1.2 Resize节点解析的问题 3.2 动态batch导出3.2.1 exporter.py修改3.2.2 Transpose节点添加3.2.3 Resize节点解析的问题 4. 运行4.1 engine生成4.2 源码修改4.3 编译运行4.4 拓展-摄像头检测4.5 拓展-trtexec参数 结语下载链接参考 前言 开始YOLOv8的模型部署，目的是为大家推荐一个全新的tensorrt仓库https://github.com/shouxieai/infer，大家可以查看我之前的Jetson嵌入式系列模型部署教程，很多细节这里就不再赘述了。考虑到nano的算力，这里采用yolov8n.pt模型，本文主要分享yolov8模型训练和jetson nano部署yolov8两方面的内容。若有问题欢迎各位看官批评指正!!!😄
一、YOLOv8模型训练 先来欣赏下YOLOv8的网络结构😅
yolov8的代码风格和yolov5相差较大，训练流程也稍有差异。博主主要参考魔鬼面具的YOLOv8最强操作.
1. 项目的克隆和必要的环境依赖 1.1 项目的克隆 yolov8的代码是开源的可直接从github官网上下载，源码下载地址是https://github.com/ultralytics/ultralytics，由于yolov8刚发布不久一个固定版本都没有，故只能采用主分支进行模型的训练和部署工作(PS:由于代码更新频繁，可能大家会遇到不同的bug)。Linux下代码克隆指令如下
git clone https://github.com/ultralytics/ultralytics.git 也可手动点击下载，点击右上角的Code按键，将代码下载下来。至此整个项目就已经准备好了。也可以点击here[pwd:yolo]下载博主准备好的代码(注意代码下载于2023/3/14日，若有改动请参考最新)
1.2 项目代码结构整体介绍 将下载后的yolov8的代码解压，其代码目录如下图
只需要关注ultralytics这个文件夹的内容即可，下面对这个文件夹的整体目录做一个介绍
|-assets：存放测试图片|-datasets：存放一些超参数的配置文件以及配置训练集和验证集路径的coco.yaml文件，如果需要修改自己的数据集，那么需要修改其中的yaml文件|-hub：pytorch扩展模型|-models：存放不同模型的yaml文件，包括v3、v5和v8|-nn：存放yolov8整体网络模型搭建的py文件|-tracker：存放yolov8目标跟踪的py文件|-yolo：存放yolov8模型预测、训练、导出的py文件 cfg：存放yolov8的配置文件，包括训练时的参数指定如epoch、batch等以及超参数设置，所有的相关配置都可通过这个文件设置(重点关注cfg/default.yaml文件)data：存放数据加载的py文件engine：存放模型导出的py文件utils：存放工具类函数，包括loss、metrics、plots函数等v8：存放yolov8分类、检测、分割等不同任务的预测、训练以及验证的py文件(重点关注) 1.3 环境安装 关于深度学习的环境安装可参考炮哥的利用Anaconda安装pytorch和paddle深度学习环境+pycharm安装—免额外安装CUDA和cudnn(适合小白的保姆级教学)，这里不再赘述。如果之前配置过yolov5的环境，yolov8可直接使用。
2. 数据集和预训练权重的准备 2.1 数据集 这里采用的数据集是口罩识别，来源于B站UP主HamlinZheng的口罩识别数据集，这里给出下载链接Baidu Drive[password:yolo]，博主将原数据集整合了下，方便后续的训练，解压后整个数据集目录结构如下
VOCdevkit └─VOC2007 ├─Annotations └─JPEGImages 其中JPEGImages中存放的图像文件，Annotations存放的是对应的XML标签文件。关于标签的制作可参考B站UP主霹雳吧啦Wz的PASCAL VOC2012数据集讲解与制作自己的数据集，由于labelimg标注的是VOC格式标签的XML文件，需要转化为YOLO格式标签的txt文件，关于转换的代码可参考炮哥的目标检测—数据集格式转化及训练集和验证集划分，下面给出VOC格式转YOLO格式的代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e32b081712e140f9539d0cf2633f600/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ac544ff1a373e498ddb53889e7ef630/" rel="bookmark">
			HW自学：蓝队初级到中级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应急响应流程 1）事件发生
运维监控人员、客服审核人员等发现问题，进行安全告警
2）时间信息收集并分析（事件确认及分类）
收集事件信息、分析网络活动相关程序、日志和数据、判断事件的严重性、评估出问题的严重等级、是否向上进行汇报等
3）判断是否上报
否 事件关闭
是
4）事件处理
各个部门通力合作、处理安全问题、具体解决问题、避免存在漏洞未修补、后门未清除等残留问题。
5）编写报告
6）事件关闭
处理完事件后，需要关闭事件，并写出安全应急处理分析报告
拒绝攻击DDOS 1）CC攻击：攻击者借助代理服务器生成指向受害主机的合法请 求，实现DDOS和伪装就叫：CC(Challenge Collapsar)，CC 主要是用来攻击页面的。
2）SYN攻击：SYN攻击是黑客攻击的手段。SYN洪泛攻击的基 础是依靠TCP建立连接时三次握手的设计。
3）纯流量攻击：发送大量垃圾流量
抗D思想和方案：1）负载均衡 2）花钱买流量清洗服务 3）装waf 4）花钱买高防设备
水坑攻击和鱼叉攻击 1）水坑攻击指的就是黑客通过分析被攻击者经常访问的网络活动规律，寻找被攻击者经常访问的网站的 弱点，先攻击该网站植入攻击代码，等待被攻击者来访时实施攻击。 2）鱼叉攻击是指利用木马程序作为电子邮件的附件，发送到目标电脑，诱导受害者去打开附件感染木马。
设备误报如何处理 1）来自外网的误报说明安全设备需要进行策略升级，不需要处置。
2）如果是来自内网的误报可以和负责人协商一下看能不能解决，有必要的话添加白名单处理。
如何判断是否是误报 首先看ip是内网ip还是外网ip
1）如果是内网ip，并且有明显的恶意请求，比如ipconfig那么此内网服务器可能会失陷。还有可能就是内网的系统有一些业务逻辑问题，因为内网在部署的时候很少会考虑一些安全问题。比如说内网的业务逻辑携带了一些sql语句，这一类属于误报
2）如果是外网ip，根据请求报和响应包的内容进行对比判断。比如sql语句查询用户名密码，然后响应包返回了相应的内容，这一类是属于恶意攻击。
挖矿事件应急处置 1）执行top命令，查看CPU占用情况，有无异常
2）查找恶意文件样本，并确定程序的运行时间
3） 首先获取恶意域名（微步在线、360威胁情报中心…获取），从而根据域名确定木马类型
4）处理异常进程并删除恶意文件，最后排查是否有可疑的计划任务、自启动
勒索病毒应急处置 1）首先就是物理断网、隔离主机，然后判断勒索病毒存活，可以通过创建几个.exe .txt空白文件看是否会被加密判断存活
2）排查业务系统，了解勒索病毒加密时间、中招范围以及影响程度
3）可以根据预留文件、预留邮箱判断出攻击团伙，对后续的溯源也有很大的帮助
4）分析勒索程序，获取ip、域名相关信息，上传至威胁情报中心查询
5）可以将勒索程序上传到一些勒索病毒搜索引擎，比如360、深信服，看能不能进行解密
钓鱼邮件应急处置 1、将受害主机断网隔离，有安全设备可以对所有主机资产进行病毒查杀
2、查看邮件原文
1）看指纹信息（什么发送工具平台）
2）看发送IP地址（服务器IP或攻击IP）
3）根据域名寻找邮件服务器地址(利用红队手段渗透获取信息)
4）可能存在个人的ID昵称用户名（利用社工的技术手段进行画像）
3、上机排查
netstat查外联，然后就是进程定位查找到文件的位置
webshell排查处置 1）首先排查工具方面D盾、河马，手工方面可以对比未上传webshell前的备份文件，可以对比他的MD5值
2）然后就是通过查看webshell的创建时间判断他攻击的时间范围，方便后续的溯源、追踪他的攻击路径
3）对web日志进行分析，以查找攻击路径以及失陷原因
4）最后就是进行漏洞分析，主要分析是什么漏洞导致的webshell攻击
5）最后进行漏洞复现，从而还原他的攻击路径
内存马应急 1）进程分析:通过查看系统中所有进程的信息，包括进程名称、PID、所属用户、内存占用等，可以尝试发现异常进程并排除其中是否存在内存马
2）系统日志分析:通过分析系统日志文件，可以查看系统启动、服务开启、网络连接等活动，以了解是否有可疑的行为发生内存分析工具:使用专业的内存分析工具，例如 Volatility Framework、Mandiant Memoryze、Rekall等，可以在内存中查找潜在的内存马代码或痕迹，并进行初步分析和定位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ac544ff1a373e498ddb53889e7ef630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbeba7b3c751836174074c856a116292/" rel="bookmark">
			Linux — 安装JDK 使用rpm命令安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Linux上安装软件一般有三种方式 一、rpm
二、解压缩
三、yum在线安装
上正片前 必须要做的前戏！ 检测当前系统是否存在Java环境！ 通过 Java -version 命令进行查看
有环境的话可以先卸载 检测 JDK 命令：rpm -qa | grep jdk 既然我的虚拟机自带了openJDK 那我就先把他删了！ 下面开始安装啦 用我们上面扯到的 rpm 进行安装 官网：https://www.oracle.com/java/technologies/downloads/
没注册的同学可以使用镜像下载：https://repo.huaweicloud.com/java/jdk/8u151-b12/
下载之后将文件放入虚拟机~
接下来开始安装 命令是 rpm -ivh 安装包 [root@csnz 公共]# rpm -ivh jdk-8u151-linux-x64.rpm 测试 java -version 安装后 开始配置环境 文件位置：/etc/profile 刚刚下载的Java环境就在 /usr/java 下面 后面配置的JAVA_HOME地址就是这里
在文件末尾添加这段配置
JAVA_HOME=/usr/java/jdk1.8.0_151 CLASSPATH=%JAVA_HOME%/lib:%JAVA_HOME%/jre/lib:.: PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin export PATH CLASSPATH JAVA_HOME 修改完成后保存退出 classPath最后的 .:是为了你后续执行class文件时，在当前目录运行即可。不加可能会报无法找到该类
让新增的环境变量生效！ 命令 source /etc/profile 测试 java -version 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3394152ff640026199fb669eb018478b/" rel="bookmark">
			Kudu-集群管理、基架感知、透明分层存储管理、性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Kudu集群管理Kudu命令行工具命令行工具盘点常见命令 Kudu Web界面WebUI端口Master Web UITablet Server Web UI 监控和管理工具编译和安装使用 备份与恢复 其他高级主题机架感知机架感知作用配置机架感知 透明分层存储管理索引跳跃式扫描优化资源规划性能调优硬件层面优化操作系统层面优化网络优化配置调优 透明分层存储案例分析需求分析方案设计架构设计分层存储设计 模拟数据构建数据流水线数据验证 Kudu集群管理 Kudu命令行工具 命令行工具盘点 Kudu在安装时默认就安装了命令行工具，只需要执行Kudu命令就能看到所有的命令分组：
一共有14个分组，组下面才是具体的命令，分组如下：
执行kudu命令组就可以列出下面的子命令：
kudu cluster 常见命令 Kudu提供了丰富的命令行工具方便用户管理集群，这里选择一些常见且命令做一下介绍。
（1）kudu cluster
举例：
sudo -u kudu kudu cluster ksck node01:7051,node02:7051,node03:7051 sudo -u kudu kudu cluster rebalance node01:7051,node02:7051,node03:7051 （2）kudu master
举例：
kudu master list node01:7051,node02:7051,node03:7051 kudu master status node01:7051 （3）kudu tserver
举例：
kudu tserver list node01:7051,node02:7051,node03:7051 kudu tserver status node01:7050 （4）kudu table
举例：
kudu table list node01:7051,node02:7051,node03:7051 kudu table describe node01:7051,node02:7051,node03:7051 students kudu table locate_row node01:7051,node02:7051,node03:7051 students '[1]' kudu table rename_table node01:7051,node02:7051,node03:7051 users user kudu table scan node01:7051,node02:7051,node03:7051 user -columns=name,age （5）kudu tablet
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3394152ff640026199fb669eb018478b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3f0ad1f3f86d76756562227d14eff47/" rel="bookmark">
			Kudu-客户端API编程、生态整合(Spark、Flink、Impala)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Kudu客户端API编程客户端API核心类Java编程接口环境准备创建表插入数据查询数据修改表结构更新数据删除数据更新和插入删除表 Hadoop生态整合整合概述集成SparkSpark shell中操作Kudu代码整合Kudu+Spark-项目准备DDLCUD批处理读写Kudu特别注意 集成Flink集成说明编译bahir-flflink项目准备批处理读写流处理写 集成Impala各组件之间的关系环境准备为什么整合Kudu+Impala怎么整合Kudu+Impala整合Kudu+ImpalaImpala Shell中操作Kudu谓词下推 Kudu客户端API编程 客户端API核心类 Kudu提供了主流语言客户端API，核心类、方法是一致的，我们首先简要盘点下核心的这些类以便于我们写代码。
（1）Kudu client
AsyncKuduClient：完全异步且线程安全的Kudu客户端。该类应该只实例化一次，同时访问很多表。只有操纵多个不同集群才需要实例化多次。不会阻塞操作，可以关联回调函数用于操作完成时的动作。Builder模式创建。KuduClient：对AsyncKuduClient的封装，同步执行、线程安全的Kudu客户端，Builder模式创建。 （2）Schema
表示表结构，主要是column的集合。该类提供了一些工具方法用于查询操作。
（3）ColumnSchema
表示一column，使用builder构建。
（4）CreateTableOptions
Builder模式类，用于创建表。
（5）KuduTable
表示集群上的一张表。含有当前表结构信息，隶属于特定AsyncKuduClient。
（6）Session
AsyncKuduSession：隶属于特定KuduClient，代表一个上下文环境，所有写操作都会在该上下文中进行。在一个session中，可以对多个操作按批处理方式执行，以获得较好的性能。每个session都可以设置超时、优先级以及跟踪id等信息。 session和KuduClient是独立的，主要是在多线程环境下，不同线程需要并发执行事务，事务的边界是基于每 个session的BeginTransaction和commit之间的过程。 来自于不同session的写操作不会组织到一个RPC请求batch中，意味着延迟敏感的客户端（低延迟）和面向吞吐量的客户端（高延迟）使用同一KuduClient，每个Session中可以设置特定的超时和优先级。KuduSession：对AsyncKuduSession封装，同步执行，但非线程安全 （7）Insert/Update/Delete/Upsert
表示插入/更新/删除/插入或者更新操作，对象不可复用。
（8）PartialRow
表示一行的部分列。
（9）KuduScanner
扫描对象，用于条件查询及迭代获取结果集。
Java编程接口 环境准备 接下来我们只需要在pom.xml中导入相关依赖即可：
&lt;properties&gt; &lt;kudu.version&gt;1.10.0&lt;/kudu.version&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Kudu client --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kudu&lt;/groupId&gt; &lt;artifactId&gt;kudu-client&lt;/artifactId&gt; &lt;version&gt;${kudu.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Log --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Unit test --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 指定具体仓库 --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;cdh.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3f0ad1f3f86d76756562227d14eff47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f4347c11d81fa279805700843e927a5/" rel="bookmark">
			mentor xp 快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 dx= x ,y 相对坐标 xy= x ,y 绝对坐标 dp=r 相对极坐标， r 表示半径 as dx= x ,y 阵列复制选择的对象， x , y 表示列间距和行间距 av dx= x , y x , y 表示列间距和 行间距 cl layer 改变当前活动层 cw width 改变线宽 dx 删除Snap 点 fa 查找所有的对象 fb 查找整个板 fc 查找指定的坐标位置 fh 查找高亮的对象 fj 查找列表中所有的元件 fn 查找列表中所有的网络 fnl 查找下一个断开的网络 fp 查找指定元件的管脚 fs 查找并缩放显示选择的对象 fx 查找并显示 snap point 处 hj 高亮列表中所有的元件 hn 高亮列表中所有的网络名 hp 查找指定元件的管脚 hs 高亮选择的对象 htc 设置 Hug Trace 的间距 mj dx= x ,y 将列表中所有的元件移动到指定的相对坐标处 mp 进入移动管脚模式 mp 将列出一个的元件的管脚移动到指定的座 标处 of l layerlist 或 ofl layerlist 关闭指定的电气层 of ua 或 ofua 关闭所有的user layers on l layerlist 或 onl layerlist 打开指定的电气层 ona 在执行了 onh 、 ons 或 onsh 后，再执行 ona则显示所有的图形 onh 仅显示高亮的对象 ons 仅显示选择的对象 onsh 仅显示高亮并且被选择的对象 on ua 或 onua 打开所有的user layers pb 放置board outline pd a 或 pda 放置draw arc pd c 或 pdc 放置 draw circle pd l 或 pdl 放置draw line pd pg 或 pdpg 放置draw polygon pd pl 或 pdpl 或 pd 放置draw polyline pd r 或 pdr 放置draw rectangle pd t 或 pdt 放置draw text pf 放置fiducia pj 放置jumper pr refdes-list 依次放置列表中所有的未放置的元件 ua 取消所有的高亮对象 us 取消选择的高亮对象 za 显示所有的对象。同 fa zb 显示整个板。同fb zc 显示指定的坐标位置。同 fc zh 显示所有的高亮对象。同fh zx 显示snap point 处 pr -dist* 摆放所有器件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbbb14cab2a511142943a04c213859b4/" rel="bookmark">
			Vue2配合element 上下滚动文本组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css" /&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"&gt;&lt;/script&gt; &lt;!-- 引入组件库 --&gt; &lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt; &lt;style&gt; * { padding: 0; margin: 0; box-sizing: border-box; } #app { height: 100vh; width: 100vw; display: flex; } .telegraph { margin: auto; background-color: #eaf5ff; border-radius: 12px; height: 24px; line-height: 24px; color: #5791ff; font-size: 12px; padding: 0 20px; width: 400px; display: flex; } .telegraph .carousel { width: 100%; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbbb14cab2a511142943a04c213859b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d04b390f1e34dd9c5e4e5f8f0e729f08/" rel="bookmark">
			.NET Core 数据库DB First自动生成，Sqlite,sql server,Mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言数据库ORM代码自动添加前期准备安装Nuget Sql serverMysqlSqlite查询结果 前言 .NET Core是C# .NET 未来发展的必然趋势，C# 要像Java一样跨平台运行。这里解决一个.NET core 会遇到的问题，如何添加ORM框架。
ORM是数据库对象映射关系模型，简单来说满足一下两个重要特点：
数据表和代码实体对象完全一致用代码生成Sql语句 以前在.NET Framwork 上面的时候，我们可以通过添加 ADO.NET文件来自动生成。但是在.NET core 版本无法添加，因为其依赖于.NET Framework。而且默认只支持sql server。我们其它常用的数据库，例如Mysql，sqlite都不支持。
数据库ORM代码自动添加 前期准备 先新建.NET core控制台文件
安装Nuget Microsoft.EntityFrameworkCore EF基础框架 Microsoft.EntityFrameworkCore.Design EF生成器，用于生成代码 Microsoft.EntityFrameworkCore.Tools EF管理工具，用于管理数据库版本，例如Mysql,sql server Sql server 安装 Microsoft.EntityFrameworkCore.SqlServer
在控制台执行以下语句
Scaffold-DbContext 'Data Source=.;Initial Catalog=你的数据库;integrated security=True ;TrustServerCertificate=true; ' Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -Context 你的数据库DbContext 解析该语句
Scaffold-DbContext ：EF.Core 自动脚本执行语句‘Data Source …’：数据库连接串，如果是非本机数据库要添加用户名和密码Microsoft.EntityFrameworkCore.SqlServer：数据库管理工具-OutputDir Models 输出文件Context:ORM的Context名称 Mysql 安装 MySql.EntityFrameworkCore，MySql.Data
Tips:Mysql包是由Oracle公司提供的
Scaffold-DbContext "server=localhost;userid=用户名;pwd=密码;port=3306;database=数据表;sslmode=none;" MySql.EntityFrameworkCore -OutputDir 文件夹路径 -Context 你的Context Sqlite 安装 Microsoft.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d04b390f1e34dd9c5e4e5f8f0e729f08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74e3c493caee2b3ab1e0d2f3c46a8e1e/" rel="bookmark">
			国际化实现思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、xxx1实现思路：
页面显示字段的国际化、后端接口返回国际化、菜单国际化文件均在后端proerties维护。
各自微服务建立自己的proerties国际化文件，微服务启动时解析proerties国家化文件后通过MQ发送到 I18N服务，通过 I18N服务存到数据库中，当前端登录进入系统后，请求i18n服务获取对应语言的国际化数据。
二、xxx2实现思路：
1、页面显示字段的国际化： 前端自行处理维护国际化
2、后端接口返回国际化：维护proerties国际化文件，通过获取请求头的语言类型，获取对应的语言，然后多层封装，获取result返回，例如：登录失败，接口超时，校验失败等。对于异常的国际化也是同理，通过异常全局处理器，获取请求头的语言类型，封装返回对应语言的报错信息。
3、菜单国际化文件：通过系统菜单界面，用户维护上去。查询时候展示对应的国际化菜单名。
二、前端和后端各自独立存储国际化资源：
国际化（前后端）_纸飞机加油的博客-CSDN博客_后端国际化
三、后端统一处理前后端的国际化资源：
Java 后端国际化设计方案_乐之终曲的博客-CSDN博客_java国际化解决方案
四、狂神后端通过spring自带的进行国际化和若依类似：
SpringBoot狂神11-(员工管理系统-国际化)_keep one's resolveY的博客-CSDN博客_idea里login_en_us.properties一直在可视化界面
五、若依国际化：（后端国际化和前端国际化各自处理对应的国际化）
后台手册 | RuoYi
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/289033bd1b5b419c25447cccded420b3/" rel="bookmark">
			解放生产力！用Python结合GPT-4进行编程（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用GPT-4和Python自动处理枯燥的工作，通过让AI在几秒钟内编写Python代码来加快日常工作流程。
微信搜索关注《Python学研大本营》，加入读者群，分享更多精彩
2.与PDF文件一起工作 虽然这不是一个常见的数据科学应用案例，但有时人们不得不从数百个PDF文件中提取文本数据来建立一个情感分析模型。这些数据是非结构化的，需要花费很多时间对其进行提取和预处理。
偶尔，你可能还要与研究人员合作，阅读和创作特定行业的时事内容。需要紧跟新闻，分析公司报告，并了解该行业的潜在趋势。
阅读100页的公司报告，提取感兴趣的词，阅读包含这些关键词的句子。或者，如果对趋势感兴趣，可以创建一个自动化的工作流程来展示关键词随时间的增长，而不是手动浏览每一份报告。
在本部分中，我们将使用ChatGPT来分析Python中的PDF文件。我们将要求聊天机器人提取PDF文件的内容，并将其写入一个文本文件中。
同样，这将使用GPT-3.5和GPT-4分别来完成，以查看生成的代码是否有明显的区别。
用GPT-3.5读取PDF文件 在本部分中，将分析一份公开发布的PDF文件，标题为《工程师机器学习简介》。如果想继续编写本部分的代码，请务必下载该文件。
首先，要求算法生成Python代码，从这个PDF文档中提取数据并保存到一个文本文件中:
以下是该算法提供的完整代码：
import PyPDF2 # 以读二进制模式打开PDF文件 with open("Intro_to_ML.pdf", "rb") as pdf_file: # 创建一个PDF阅读器对象 pdf_reader = PyPDF2.PdfFileReader(pdf_file) # 获取PDF文件的总页数 num_pages = pdf_reader.getNumPages() # 创建一个新的文本文件 with open("output_file.txt", "w") as txt_file: # 循环浏览PDF文件中的每一页 for page_num in range(num_pages): # 从当前页获取文本 page_text = pdf_reader.getPage(page_num).extractText() # 把文本写到文本文件中 txt_file.write(page_text) (注意：确保将PDF文件名改为你在运行此代码前保存的文件名)。
但是，在运行GPT-3.5生成的代码后，遇到了以下unicode错误：
回到GPT-3.5，看看该模型是否能解决这个问题：
把这个错误粘贴到ChatGPT上，模型回复说可以通过把使用的编码改为utf-8来解决这个问题。它还给出了一些修改过的代码，反映了这一变化：
import PyPDF2 # 以读二进制模式打开PDF文件 with open("Intro_to_ML.pdf", "rb") as pdf_file: # 创建一个PDF阅读器对象 pdf_reader = PyPDF2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/289033bd1b5b419c25447cccded420b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b68f8a7cb67b079a6d47f4e69b0d89f4/" rel="bookmark">
			解放生产力！用Python结合GPT-4进行编程（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用GPT-4和Python自动处理枯燥的工作，通过让AI在几秒钟内编写Python代码来加快日常工作流程。
微信搜索关注《Python学研大本营》，加入读者群，分享更多精彩
2023年3月14日，OpenAI推出了GPT-4，这是OpenAI最新、最强大版本的语言模型。
在推出后的短短几个小时内，GPT-4让人们惊呆了，它把一张手绘的草图变成了一个功能性的网站，通过了律师考试，并生成了维基百科文章的准确摘要。
它在解决数学问题和回答基于逻辑和推理的问题方面也超过了它的前辈GPT-3.5。
ChatGPT是建立在GPT-3.5之上并向公众发布的聊天机器人，以“一本正经的胡说八道”而闻名。它会产生看似正确的回答，并以“事实”为自己的回答辩护，尽管这些回答错误百出。
在该模型坚持认为大象蛋是所有陆地动物中最大的蛋之后，一位用户在Twitter上发帖称:
而且它并没有就此罢休。该算法继续用虚构的事实来证实它的回答，几乎让人相信了一会儿。
另一方面，GPT-4被训练得较少出现“胡说八道”。OpenAI的最新模型更难欺骗，也不像以前那样自信地频繁生成假话。
为什么用GPT-4实现工作流程自动化？ 数据科学家的工作会要求能找到相关的数据源，预处理大型数据集，并建立高度准确的机器学习模型，以推动业务价值。
数据科学家每天花大量时间从不同的文件格式中提取数据并将其整合到一个地方。
在2022年11月ChatGPT首次推出后，一位数据科学家希望通过聊天机器人为日常工作流程提供一些指导。使用这个工具来节省花在琐碎工作上的时间——这样他就可以专注于提出新的想法并创建更好的模型。
GPT-4发布后，他很好奇它是否会对他正在进行的工作产生影响。使用GPT-4比它的前辈们有什么明显的好处吗？它能帮助用户节省比使用GPT-3.5更多的时间吗？
这篇文章将展示如何使用ChatGPT来实现数据科学工作流程的自动化，并且将创建相同的提示，并将其输入GPT-4和GPT-3.5，看看前者是否确实执行得更好，并能节省更多时间。
如何访问ChatGPT？ 如果想了解和尝试在本文中做的一切，需要访问GPT-4和GPT-3.5。
GPT-3.5 GPT-3.5在OpenAI的网站上是公开可用的。只需导航到https://chat.openai.com/auth/login，填写所需的详细信息，就可以访问语言模型了：
图片来自ChatGPT
GPT-4 另一方面，GPT-4目前是需要每月付费才能使用的。要访问该模型，需要通过点击“升级到Plus”升级到ChatGPTPlus。
每月有20美元的订阅费用，可以随时取消：
图片来自ChatGPT
如果不想支付每月的订阅费用，也可以选择加入GPT-4的API等待名单。一旦获得了对API的访问权，就可以按照这个指南（点击查看）在Python中使用它。
如果目前没有访问GPT-4的权限也没关系。
仍然可以使用ChatGPT的免费版本来学习本教程，该版本在后端使用了GPT-3.5。
用GPT-4和Python实现数据科学工作流程自动化的3种方法 1.数据可视化 在进行探索性数据分析时，用Python生成一个快速的可视化，往往能有助于更好地理解数据集。
不过，这项任务可能会非常耗时 —— 特别是当不知道使用什么正确的语法来获得所需的结果时。
经常发现自己在Seaborn的大量文档中搜索，并使用StackOverflow来生成一个Python图。
让我们看看ChatGPT是否可以帮助解决这个问题。
在本部分中将使用Pima Indians Diabetes dataset(皮马印第安人的糖尿病数据集)。如果想了解和尝试ChatGPT生成的结果，可以下载该数据集。
下载完数据集后，使用Pandas库将其加载到Python中，并输出dataframe的前几行：
import pandas as pd df = pd.read_csv('diabetes.csv') df.head() 这个数据集中有九个变量。其中Outcome告诉我们一个人是否会患糖尿病的目标变量。其余的是用于预测结果的独立变量。
好的，所以本文想看看这些变量中哪些对一个人是否会患糖尿病有影响。
为了达到这个目的，可以创建一个簇状条形图来可视化数据集中所有因变量中的变量“糖尿病”。
这其实很容易编码出来，但让我们从简单的开始。随着文章的不断深入，我们将继续讨论更复杂的提示。
用GPT-3.5进行数据可视化 由于付费订阅了ChatGPT，该工具允许在每次访问时选择想使用的基础模型。
首先将选择GPT-3.5：
图片来自ChatGPT Plus
如果没有订阅，可以使用ChatGPT的免费版本，因为在默认情况下聊天机器人使用GPT-3.5。
现在输入以下提示，用糖尿病数据集生成一个可视化：
我有一个包含8个自变量和1个因变量的数据集。因变量Outcome，告诉我们一个人是否会患糖尿病。
自变量Pregnancies（妊娠）、Glucose（血糖）、BloodPressure（血压）、SkinThickness（皮肤厚度）、Insulin（胰岛素）、BMI（身体质量指数）、DiabetesPedigreeFunction（糖尿病患者的血糖水平）和Age（年龄）被用来预测这一结果。
你能生成Python代码按结果来可视化所有这些自变量吗？输出应该是一个由Outcome变量着色的簇状条形图。总共应该有16个条形，每个自变量有2个条形。
以下是该模型对上述提示的响应：
有一点很明显的是，该模型假设我们想从Seaborn导入数据集。因为我们要求它使用Seaborn库，所以它可能就做出了这个假设。
这不是一个很大的问题，只需要在运行代码之前修改一行。
下面是GPT-3.5生成的完整代码片段：
import seaborn as sns import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b68f8a7cb67b079a6d47f4e69b0d89f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb5ea57a71434561d5ba696b7d37c35c/" rel="bookmark">
			LeetCode | C&#43;&#43; 动态规划——198.打家劫舍、213.打家劫舍II、337.打家劫舍III
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 198.打家劫舍213.打家劫舍II337.打家劫舍III参考 198.打家劫舍 198题目链接
dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。
递推公式：
决定dp[i]的因素就是第i房间偷还是不偷。
如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。
如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，（注意这里是考虑，并不是一定要偷i-1房）
然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
dp数组初始化
从dp[i]的定义以及递推公式来讲：dp[0] = nums[0], dp[1] = max(nums[0], nums[1]);
遍历顺序：
从前往后
class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; dp(nums.size()); dp[0] = nums[0]; if (nums.size() == 1) return dp[0]; dp[1] = max(nums[0], nums[1]); if (nums.size() == 2) return dp[1]; for (int i = 2; i &lt; nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb5ea57a71434561d5ba696b7d37c35c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff6eecb6ed09955ce50e69f72cfed794/" rel="bookmark">
			java.lang.IllegalArgumentException: Comparison method violates its general contract!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题代码: Collections.sort(resultList, (o1, o2) -&gt; { return o1.getClinicItemCode().equals(o2.getClinicItemCode()) ? -1 : 1; }); 原因:
JDK7中的Collections.Sort方法实现中，如果两个值是相等的，那么compare方法需要返回0，否则 可能 会在排序时抛错，而JDK6是没有这个限制的。
2023版本的IDEA，在这段代码下会有警告
在 JDK7 版本以上，Comparator 要满足自反性，传递性，对称性，不然 Arrays.sort 或者 Collections.sort 会报 IllegalArgumentException 异常。
规约：
1） 自反性：x，y 的比较结果和 y，x 的比较结果相反。
2） 传递性：x&gt;y,y&gt;z,则 x&gt;z。
3） 对称性：x=y,则 x,z 比较结果和 y，z 比较结果相同。
解决方案：
1、不修改代码
在JVM的启动参数中加入如下参数，表明继续使用JDK6的排序算法：
-Djava.util.Arrays.useLegacyMergeSort=true 2、修改代码
o1.getClinicItemCode().equals(o2.getClinicItemCode()) ? -1 : 1
替换为
o1.getClinicItemCode().compareTo(o2.getClinicItemCode())
用自带的compareTo（）方法去比较
参考博客：
https://www.cnblogs.com/firstdream/p/7204067.html https://stackoverflow.com/questions/6626437/why-does-my-compare-method-throw-exception-comparison-method-violates-its-gen
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0663a603ab58a20302d9edfc53352df5/" rel="bookmark">
			解决url中&amp;times会被转成×的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考原文：hutaoo的博客《×被转义为X的问题》 一、发生错误的情况： 在URL中参数若有&amp;times则会被转成x，例如：
$url = "http://www.test.com/index.php?id=1&amp;timestamp=1584947618&amp;age=10"; echo $url; 输出结果为：http://www.test.com/index.php?id=1×tamp=1584947618&amp;age=10 可以看到参数&amp;timestamp变成了xtamp。 二、解决办法：方法 方法1、既然是&amp;符号和times结合会被转义，那就不写在一起，将参数放在第一位。 $url = "http://www.test.com/index.php?timestamp=1584947618&amp;id=1&amp;age=10"; echo $url; 方法2、把【&amp;】符号转义成html实体，【&amp;】的实体是【&amp;amp;】。 $url = "http://www.test.com/index.php?id=1&amp;amp;timestamp=1584947618&amp;age=10"; echo $url; 方法3、使用htmlspecialchars()函数，把预定义的字符 转成 HTML 实体。 $url = "http://www.test.com/index.php?id=1&amp;timestamp=1584947618&amp;age=10"; echo htmlspecialchars($url); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/718668337c5adc9f0abb2802d4c3f293/" rel="bookmark">
			模型加速：深度学习模型的硬件加速：NVIDIAT240
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：禅与计算机程序设计艺术
模型加速：深度学习模型的硬件加速：NVIDIA T240 在当前深度学习模型的规模和复杂度不断增加的情况下，硬件加速已经成为一个重要的技术手段。本文将介绍NVIDIA T240显卡在深度学习模型加速方面的原理、实现和应用。
引言 1.1. 背景介绍
随着深度学习模型的不断复杂化，训练过程和部署过程的时间和成本也在不断增加。传统的CPU和GPU已经难以满足深度学习的需求，而硬件加速技术也成为了重要的解决方案。目前，NVIDIA T240是一款专业的深度学习加速卡，它支持CUDA C++和CUDA Python接口，可以显著提高深度学习模型的训练和推理速度。
1.2. 文章目的
本文旨在介绍NVIDIA T240在深度学习模型加速方面的原理、实现和应用，帮助读者了解硬件加速在深度学习中的重要性，以及如何选择和应用合适的硬件加速卡。
1.3. 目标受众
本文的目标受众是对深度学习有兴趣的初学者、研究人员和专业从业者。他们对硬件加速的原理和方法有基本的了解，希望通过本文深入了解NVIDIA T240在深度学习中的应用。
技术原理及概念 2.1. 基本概念解释
深度学习模型需要大量的计算资源来训练和推理。传统的主流计算平台是CPU和GPU，但它们在处理深度学习模型时仍然存在一定的局限性。NVIDIA T240作为一种专业的深度学习加速卡，可以在短时间内完成大量计算任务，显著提高深度学习模型的训练和推理速度。
2.2. 技术原理介绍:算法原理，操作步骤，数学公式等
NVIDIA T240采用CUDA C++和CUDA Python接口，支持CUDA计算框架。它可以在CUDA环境下执行深度学习模型，从而实现高效的计算和数据传输。CUDA是一种并行计算框架，可以利用GPU的并行计算能力，加速深度学习模型的训练和推理过程。
2.3. 相关技术比较
与传统的CPU和GPU相比，NVIDIA T240在深度学习加速方面具有以下优势：
更高的计算性能：NVIDIA T240在处理深度学习模型时，可以提供比传统CPU和GPU更快的计算性能。更快的训练和推理速度：NVIDIA T240可以在短时间内完成大量计算任务，从而提高深度学习模型的训练和推理速度。可扩展性：NVIDIA T240支持CUDA C++和CUDA Python接口，可以方便地与其他CUDA计算框架集成，实现更高效的计算和数据传输。更低的成本：相对于传统的CPU和GPU，NVIDIA T240的价格更加亲民，可以降低深度学习模型的训练和部署成本。 实现步骤与流程 3.1. 准备工作：环境配置与依赖安装
要在NVIDIA T240上实现深度学习模型加速，首先需要准备环境。确保计算机上已安装了NVIDIA驱动程序和CUDA计算框架。然后在终端中运行以下命令，安装CUDA：
curl https://developer.nvidia.com/sites/content/dam/nvidia-gpu-sdk/cuda-nd-api/lib/index.html | sort | uniq -n 1 | xargs sudo apt-get install -y -qq 3.2. 核心模块实现
要在NVIDIA T240上实现深度学习模型加速，需要编写核心模块。核心模块是深度学习模型加速的基本组件，负责将CUDA计算框架中的计算任务执行完毕。以下是一个简单的核心模块实现，用于执行卷积神经网络（CNN）的训练和推理：
#include &lt;iostream&gt; #include &lt;NvInfer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/718668337c5adc9f0abb2802d4c3f293/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc48f498a97aefb0c9a3461ac85e1ad2/" rel="bookmark">
			Java中Lambda表达式使用过程中出现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java的Lambda表达式里的return只能终止当前循环的流程，不能终止循环，例如：
List&lt;String&gt; list = new ArrayList&lt;String&gt;();
list.forEach(bs -&gt; {
......
return ;
})
这个return是不执行的，程序还会继续循环执行直至结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4572b3cd9703307cacb3652cbb75d748/" rel="bookmark">
			摄像机监控范围计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		espace IPC2701-P室内半球形网络摄像机的主要参数：
1、图像传感器：1/2.7'' 200万像素逐行扫描CMOS；
2、焦距：3.3mm~12mm；
3、视角范围：96°~35°（16:9）
79.3°~27.2°（4:3）
解答：
步骤一：计算依据：计算公式水平视场角α=2arctan（w/2f）、垂直视场角β=2arctan（h/2f），其中w为像场宽度，h为像场高度，f为镜头的焦距。虽然计算出来的视场角比实际视场小，但差别可以忽略。这里我们以计算的视场角来描述摄像机的监控范围。1/2.7''CMOS成像尺寸为：w*h=5.27mm*3.96mm。
步骤二：假定前提条件：摄像机的监控范围除了跟镜头焦距及安装位置有关外，还跟镜头的安装角度有关。
这里需要假定几个条件，（1）半球摄像机安装高度为：H=3m，走廊的宽度W为：2m；（2）摄像机镜头的安装角度为0°（即镜头水平）；（3）电视墙显示屏比例为：4:3，摄像机模式设置为：4:3。（4）监控对象为W'*H'=2m宽*3米高的完整走廊范围。
步骤三：（1）焦距为3.3mm时计算
水平视场角：
α1=2arctan（5.27mm/2*3.3mm）=77.2°
垂直视场角：
β1=2arctan（3.96mm/2*3.3mm）=61.9°
（2）焦距为12mm时计算水平视场角：α2=2arctan（5.27mm/2*12mm）=24.8°
垂直视场角：β2:=2arctan（3.96mm/2*12mm）=18.7°
步骤四：（1）焦距为3.3mm时：
①垂直方向上，能看到完整走廊的最小距离（距离摄像机的水平距离）为：
dvmin=H/tan（β1/2）=3000mm/tan(61.9°/2) =5000mm=5米;
② 水平方向上，能看到完整走廊的最小距离（距离摄像机的水平距离）为：
dhmin=W/2*tan(α1/2)=2000mm/2*tan(77.2°/2)=1253mm=1.25米由于dvmin&gt;dhmin，因此，焦距为3.3mm时，监控范围为距离摄像机监控方向5米以外的走廊区域。
（2）焦距为12mm时：
①垂直方向上，能看到完整走廊的最小距离（距离摄像机的水平距离）为：
dvmin'=H/tan（β2/2）=3000mm/tan(18.7°/2)=18220mm≈18米；
②水平方向上，能看到完整走廊的最小距离（距离摄像机的水平距离）为：
dhmin'=W/2*tan(α2/2)=2000mm/2*tan（24.8°/2）=4548mm≈4.5米；
由于dvmin'&lt;dhmin'，因此，焦距为12mm时，监控范围为距离摄像机监控方向18米以外的走廊区域。
步骤五：再假定摄像机镜头下倾角为其垂直视场角一半的情况下的监控范围，这是在摄像机安装高度及监控对象高度相同的情况下最大的下倾角。
（1）焦距为3.3mm时：
①垂直方向上，能看到完整走廊的最小距离（距离摄像机的水平距离）为：
dvmin=H/tanβ1=3000mm/tan61.9°≈1.6米
②水平方向上，视场角可近似认为不变，dhmin仍为1.25米。
由于dvmin&gt;dhmin,焦距为3.3mm时，监控范围为距离摄像机监控方向1.6米以外的走廊区域。
（2）焦距为12mm时：
①垂直方向上，能看到完整走廊的最小距离（距离摄像机的水平距离）为：
dvmin=H/tanβ2=3000mm/tan18.7°≈8.86米
②水平方向上，视场角也可认为近似不变，dhmin'仍为4.5米；
由于dvmin'&gt;dhmin',焦距为12mm时，监控范围为距离摄像机监控方向8.86米以外的走廊区域。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dfdf626c8f66a8763277f0845fd25a7/" rel="bookmark">
			【跨平台开发】Uni-app原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 UniApp是一种基于Vue.js的跨平台开发框架，它可以帮助开发者使用一套代码构建同时运行在多个平台（如iOS、Android、Web等）的应用程序。实现跨平台的原理主要包括以下几个方面：
基于WebView：UniApp使用了各平台提供的原生WebView容器作为运行环境，通过将应用程序的前端代码封装在WebView中运行，从而实现跨平台。
通用API：UniApp提供了一套通用的API，统一了不同平台的接口调用方式。开发者可以使用这些通用API来实现跨平台的逻辑，而无需编写特定平台的代码。
编译打包：UniApp通过编译打包的方式生成各个平台的应用程序。开发者编写的代码会被编译为各个平台所对应的原生代码，并打包成相应平台的安装包或者网页文件。
平台差异处理：UniApp框架会根据不同的平台特性，在编译阶段对代码进行转换和适配，以处理各个平台之间的差异。这样开发者可以使用统一的代码风格和逻辑，同时兼顾各个平台的特性和限制。
总体来说，UniApp的跨平台原理是通过封装和抽象各个平台的能力，提供统一的开发接口和打包编译方式，使开发者可以使用一套代码同时在多个平台上运行应用程序。这样可以减少开发成本和维护工作，并提高开发效率。
参考资料 介绍uni-app框架，以及运行原理_uniapp原理_Moon绾.的博客-CSDN博客
uni-app原理分析_uniapp原理_Jack おう的博客-CSDN博客​​​​​​
uni-app官网 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0d2a1359c0586c7ce985c77b69881e7/" rel="bookmark">
			如何解决git中拉取或提交代码出现的ssl证书问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 执行命令的时候，出现"…certificate problem…"报错，一般在执行"git push“ (推送分支) 或者 “git clone”(克隆仓库)时出现，原因时因为SSL安全验证问题，不能获取到本地的的证书。那么如何解决这个问题呢，我想到的是不通过SSL证书方式。
解决方法 方案1：直接执行命令 执行命令 git config --global http.sslverify false
检查有无修改成功git config --list
方案2：在git的配置文件中更改 找到并打开配置文件 vim ~/.gitconfig
【注意】等号两边都有空格，保存退出"zz"
检查有无修改成功git config --list
方案3：配置ssh密钥 配置本地仓库的账户邮箱
git config --global user.name ‘xxxx’git config --global user.email ‘xxxx’ 使用ssh密钥登录
用下面指令生成sshssh-keygen -t rsa -C ‘邮箱地址’选择一个文件夹生成密钥的存放位置，可自己设置也可以使用默认的文件夹，设置password git用户 settings中找到SSH Keys
进入C:\Users\stone.ssh 目录下找到id_rsa.pub文件，复制其中的值，上图的右边Key区域下方的文本框中，点击确定。
解决完成，再**“git push”** 或者 ”git clone“ 会发现报错已经解决！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d75f265512f2253d1b74951b375d964/" rel="bookmark">
			分享GPT-4.0创作小说文章&#43;代码HTML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试了GPT-4.0模式创作网站页面代码注册模块的HTML流程，果然比3.5的逻辑性强。
以下是测试的展示页截图：
这是一个简单的注册用户登录页面HTML代码示例。你可以根据需要修改和扩展这个模板。
&lt;!DOCTYPE html&gt;
&lt;html lang="zh"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;title&gt;注册用户登录页面&lt;/title&gt;
&lt;style&gt;
body {
font-family: Arial, sans-serif;
background-color: #f0f0f0;
}
.container {
max-width: 400px;
margin: 50px auto;
background-color: #fff;
border-radius: 5px;
padding: 20px;
box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}
h1 {
text-align: center;
margin-bottom: 20px;
}
input[type="text"], input[type="password"] {
width: 100%;
padding: 10px;
margin-bottom: 10px;
border: 1px solid #ccc;
border-radius: 3px;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d75f265512f2253d1b74951b375d964/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/115/">«</a>
	<span class="pagination__item pagination__item--current">116/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/117/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>