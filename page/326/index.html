<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41e1c98c39a1f8687b4e66832e17824f/" rel="bookmark">
			mac下启动jupyter notebook
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先打开终端 然后输入start jupyter notebook命令 python -m IPython notebook ### 如果是python3的环境就用下面的命令 python3 -m IPython notebook 最后浏览器就会自动打开 jupyter notebook 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec416125803693b121d1f5e9d5d9401e/" rel="bookmark">
			@FeignClient注解的接口，用@Autowired可能获取不到实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
Spring-Boot 2.0.8.RELEASE
Spring-Cloud 2.0.4.RELEASE
OpenFeign 2.0.4.RELEASE
JDK 1.8
启动类：
package com.xxx.tfb; import java.sql.SQLException; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.camunda.bpm.spring.boot.starter.annotation.EnableProcessApplication; import org.h2.tools.Server; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; import org.springframework.cloud.netflix.hystrix.EnableHystrix; import org.springframework.cloud.openfeign.EnableFeignClients; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.FilterType; import com.xxx.framework.config.SecondDataSourceConfiguration; import springfox.documentation.swagger2.annotations.EnableSwagger2; @EnableEurekaClient @EnableFeignClients(basePackages="com.xxx") @EnableCircuitBreaker @EnableProcessApplication @EnableHystrix @SpringBootApplication @EnableSwagger2 @MapperScan(basePackages = { "com.xxx.**.mapper" }) @MapperScan(basePackages = { "com.xxx.**.oramapper" }) @ComponentScan(excludeFilters = {@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = {SecondDataSourceConfiguration.class})}) @ComponentScan(basePackages = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec416125803693b121d1f5e9d5d9401e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/070ca799296b6529e54d0756d95f4b8f/" rel="bookmark">
			Flowable 6.6.0 Eclipse设计器 - 3.BPMN 特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flowable 6.6.0 用户指南相关文档下载 BPMN用户指南 第一部分 - 中文PDF精编版BPMN用户指南 第二部分 - 中文PDF精编版BPMN用户指南 第三部分 - 中文PDF精编版应用程序指南 - 中文PDF精编版应用程序指南 - 中英对照PDF精编版应用程序指南 - Eclipse设计器中文PDF精编版表单用户指南 - 中文PDF精编版事件注册表用户指南 - 中文PDF精编版 有关Flowable文档的其他资料，参见： 《Flowable文档大全》
《Flowable 6.6.0 Eclipse设计器》 1 安装（Installation） 2 Flowable 设计器编辑器特性（Flowable Designer editor features） 3 Flowable设计器BPMN 特性（Flowable Designer BPMN features） 4 Flowable设计器部署特性（Flowable Designer deployment features） 5 扩展Flowable设计器（Extending Flowable Designer） 5.1 定制调色板（Customizing the palette） 5.2 图验证及自定义输出格式（Validating diagrams and exporting to custom output formats） 3 Flowable设计器BPMN 特性（Flowable Designer BPMN features） • Support for start none event, start error event, timer start event, end none event, end error event, sequence flow, parallel gateway, exclusive gateway, inclusive gateway, event gateway, embedded sub process, event sub process, call activity, pool, lane, script task, user task, service task, mail task, manual task, business rule task, receive task, timer boundary event, error boundary event, signal boundary event, timer catching event, signal catching event, signal throwing event, none throwing event and four Flowable specific elements (user, script, mail tasks and start event).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/070ca799296b6529e54d0756d95f4b8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaf31f01009fc14752e0ca25d3753446/" rel="bookmark">
			C&#43;&#43;类对象重载赋值的时候为什么要返回引用类型？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有两个原因
第一个是为了减少内存空间的浪费和多余的操作。
如果不使用引用，则函数首先在内存中创建一个空间接受返回值，然后再从这个地址赋值给变量
以下面为例
int func(int x){return x}; int c=func(2); 实际上是这样一个操作，先创建了一个临时变量temp接收返回值，然后再把temp赋值给c
x=2;//x在栈区 temp=x; c=temp; 而如果是引用返回，则相当于是直接把值赋给变量
c=x; 实际上应该是创建了一个引用？这里原理我暂时理解不清楚，只能把效果讲清楚。
所以如果是类对象重载operator=函数的时候
下面的代码，将会产生额外的空间消耗
A=B=C; 第二个原因就是特殊赋值
这种情况下，如果开始的时候A=1,B=2,C=3;
(A=B)=C; 如果是直接返回，那么最终是A=2;而引用返回则是A=3；
为什么？
因为没有引用的时候，A=B的结果是产生了一个临时变量temp；所以执行完A=B后，他接下来执行的是temp=C；
而返回引用的时候，则是建立了一个别名；所以执行完A=B，执行的是C=B；
（实际上可能是通过&amp;c=x,x=B;来实现的。因为这一行语句执行完，栈区才会释放，这个引用关系才会解除。但我现在不确定是不是这样）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e548deb7a26ef617c0b7c9404e8dedb/" rel="bookmark">
			RetaGNN: 面向整体序列推荐的关系型时态注意图神经网络  WWW2021
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ABSTRACT 顺序推荐（SR）是根据用户当前访问的项目为用户准确地推荐项目列表。在新用户不断进入现实世界的同时，一项关键任务是拥有感应式SR，它可以产生用户和物品的嵌入而无需重新培训。考虑到用户与项目之间的交互可能极为稀疏，另一个关键任务是拥有可转移的SR，该SR可以将来自具有丰富数据的一个域的知识转移到另一个域。在这项工作中，我们的目的是提供同时适用于常规，电感和可转移设置的整体SR。我们为整体SR提出了一个新颖的基于深度学习的模型，即关系时间关注图神经网络（RetaGNN）。 RetaGNN的主要思想是三个方面。首先，为了具有归纳和可传递的功能，我们在从用户项对中提取的局部子图上训练相关的关注GNN，其中可学习的权重矩阵位于用户，项和属性之间的各种关系上，而不是节点或边上。（所有的权重矩阵来控制用户偏好，用户的表示是通用的）第二，用户偏好的长期和短期时间模式是通过提出的顺序自我注意机制进行编码的。第三，设计了一个关系感知的正则化术语，以更好地训练RetaGNN。在MovieLens，Instagram和Book-Crossing数据集上进行的实验表明，RetaGNN在常规，归纳和可转移的设置下可以胜过最新技术。得出的注意力权重还带来了模型的可解释性。
介绍 尽管一些现有的RS方法已经能够进行归纳学习，但最新的顺序推荐模型（例如HGN [14]，HAM [17]和MA-GNN [15]）仍然具有传导性。 据我们所知，归纳SR的任务尚未正式探讨。 这项工作旨在发明一种有效的归纳SR模型。 另外，由于尚未考虑两个因素，我们认为可以进一步改善现有的SR模型。** 第一个是在给定序列的长短期内对高阶用户项交互进行建模。 交互图中用户多跳协作邻居的顺序演变可以揭示用户偏好如何随时间变化**。 ** 第二个是顺序项目的派生表示中的时间模式。 下一项目的采用会受到具有不同权重贡献的最新项目的影响。**
在本文中，我们提出了一种新颖的基于深度学习的模型，即关系时间注意力图神经网络（RetaGNN），用于顺序推荐。在一个具有固定的用户，项目及其交互集的特定域中，给定一系列与用户最近交互的项目，我们的主要目标是三方面的，如图1所示。第一个是常规SR：准确推荐接下来的项目。第二种是归纳SR：向未包含在现有用户集中的新用户推荐下一项。第三个是可转让的SR：为给定用户的商品序列推荐下一个商品，其中用户和商品都属于另一个域。就是说，我们的目标是要有一个整体的SR模型，该模型可以在常规，感应和可转移设置下预测下一个项目。同时处理三个SR设置具有挑战性，因为模型的可学习参数不应附加到特定节点（对于归纳）或特定数据集（对于可传递）。就是说，该模型需要捕获所见面之间共享的常识
为了实现上述SR目标，提出的RetaGNN具有四个主要思想。首先，RetaGNN建立在单个用户项目对的本地图模式上，其中图涉及用户，项目和属性之间的关系。我们从给定的现有顺序用户-项目交互中提取由给定的用户-项目对包围的局部子图，并学习将此类子图映射到他们的交互得分。其次，为了同时具有归纳和可转移的功能，我们提出了一个关系关注型GNN（RA-GNN）层，以在顺序上下文中对高阶用户项交互进行建模。 RA-GNN通过训练图中各种关系而不是节点（例如，GAT [22]和NGCF [27]）上的可学习权重矩阵，在RetaGNN中执行消息传递和邻域聚合机制。基于这两个思想，只要我们能够获得关于给定用户项对的局部子图，无论是否看到用户，都可以应用关系权重以归纳和可转移的方式生成用户和项目嵌入设置。第三，我们提出了一个顺序自我注意（SSA）层，以根据RA-GNN生成的顺序项嵌入对时间模式进行编码。最后，我们在损失函数中设计一个关系感知的正则化项，以便可以更好地训练与RetaGNN中的关系相关的可学习参数
我们提出了一种新的关系时态注意力图神经网络(RetaGNN)模型。其主要思想是学习从给定用户-项目对的局部图到其交互得分的映射，并训练可学习的关系权重矩阵。
问题定义 item有不同的属性（attribute）
预测在t时间出现的item
）归纳顺序推荐（ISR）：给定每个用户𝑢∈U•的较早会话𝑆𝑢1：𝑡（𝑡&lt;𝐿），我们的目标是向每个用户recommend∈∈U◦推荐一个项目集V的项目列表 ，其中U•是可见的用户集，U◦是看不见的用户集（用户未出现在培训阶段），并且U•∩U◦=∅。 就是说，目标是要返回（看不到的）用户列表，该列表将在不久的将来与未知用户𝑢∈U◦进行交互
给新用户预测项目集
可转移顺序推荐（TSR）：在源域中，鉴于每个用户𝑢∈Usrc的较早会话𝑆𝑢1：𝑡（𝑡&lt;𝐿），我们的目标是产生一个具有可转移参数Θ的顺序推荐模型，该模型可以推荐一系列 每个用户𝑣∈Usrc的项目集Vsrc中的项目。 然后，通过使用用户集Utrg和项目集Vtrg（其中Usrc∩Utrg =∅和Vsrc∩Vtrg = where）将可转移参数Θ应用于目标域，我们可以准确地向每个用户recommend推荐项目列表（从Vtrg开始） ∈Utrg。
就是第一幅图中的三个问题
模型 我们在图2中概述了所提出的RetaGNN模型。RetaGNN由五个阶段组成。首先，我们利用一个单层前馈网络（FFN）来生成用户，项目和属性的原始嵌入。其次，我们通过在不同的时间范围内将用户及其交互项配对来为每个目标对提取长期和短期h-hop封闭子图。第三，创建一个关系关注图神经网络（RA-GNN）层，以学习用户和项目的表示形式，该表示形式对每个封闭子图中的顺序高阶用户项交互进行编码。可以在此阶段获得归纳和可转移的学习参数。第四，我们设计了一个顺序自我注意（SSA）层来对用户偏好的时间模式进行建模，并在此处更新项目嵌入。最后，通过利用要预测的项目的原始嵌入以及顺序的项目嵌入，预测层将生成计分结果。
4.1 Primitive Embedding Layer 我们首先考虑随机初始化所有用户，项目和属性值的表示向量。 原因是归纳和可转移的学习。 节点上随机初始化的“固定大小”向量使我们可以在同一组学习的模型权重下更新新出现的未见节点（对于归纳）和交叉数据节点（对于可转移）的嵌入。 原因是我们在构造的图中学习了方向边缘关系的模型权重，而该权重与节点和数据集无关。 因此，RetaGNN可以将新出现的交叉数据节点的随机初始化向量投影到相同的嵌入空间中，以实现归纳和可转移的效果
通过将随机初始向量馈送到嵌入层（即一隐藏层前馈网络（FFN）），我们可以为每个用户，商品和属性值生成低维实值密集向量。我们称这类密集向量为原始嵌入。设嵌入为X∈R𝑞×𝑑，其中𝑑为嵌入维，𝑞为训练数据中用户，项目和属性值的数量之和。给定特定用户a的会话S𝑢1：𝑡，其对应的嵌入矩阵可以表示为：XS𝑢1：𝑡= [x1···x𝑗··x𝑡]，其中XS𝑢1：𝑡∈R𝑡 ×𝑑和x𝑗∈R𝑑是S𝑢1：𝑡中第item个项的原始嵌入，并且可以从原始嵌入矩阵X中检索。注意，这里我们不使用固定长度的一键编码。初始化向量。原因是对于新用户和跨域用户，一键编码无法扩展
4.2 User-Item-Attribute Tripartite Graph 我们构造一个全局三方图H来表示用户，项目和项目属性之间的关系。 令三方图为H =（N，E），其中节点集N是用户集U，项目集V和属性值集A的并集，即N = U∪V∪A。
是分别将用户与项目连接以及将项目与其属性值连接的边集。 换句话说，相同类型节点之间没有边缘，用户和项目属性值之间也没有边缘。 三方图的一个玩具示例在图3（a）中给出。 注意，三方图H是根据不同的训练课程（即以下小节中描述的长期和短期训练）构建的。
三重图的目的是三方面的。首先，通过用户-项目交互的路径可以反映出协同过滤的效果[5，12，27]。例如在图3（c）中，要确定是否向用户𝑢1推荐项目𝑣2，路径（𝑢1，，3，𝑢2，𝑣2）可以反映用户𝑢1和𝑢2基于项目𝑢3具有相似的品味，我们可以推荐项目𝑣2到𝑢1，因为𝑢3也喜欢𝑣2。其次，通过项目-属性交互的路径可以描述项目之间的相关性，这在某种程度上可以带来基于内容的过滤的效果。例如在图3（c）中，两条路径（𝑢1，，1，，2，𝑣2）和（𝑢1，，3，𝑎2，𝑣2）都暗示我们可以推荐𝑣2到𝑢1，因为项𝑣2与项𝑣1和share2共享相同的属性𝑎2。 𝑣3，𝑢1对此很喜欢。第三，通过三方图，我们的模型被允许具有归纳和转移学习的能力，即与新用户打交道，可以将他们放入图中，以便我们获得相关的路径以将他们与现有用户联系起来。
三方图中有三种类型的节点。 为了将更多的语义编码为描述用户和项目之间关系的路径，我们认为从一种节点类型到另一种节点类型的边可能具有不同的含义。 从用户𝑢𝑖到项目𝑣𝑗的边缘，从𝑣𝑗到𝑢𝑖，从𝑣𝑗到属性𝑎𝑘，以及从𝑎𝑘到𝑣𝑗的边缘表示：𝑢𝑖喜欢𝑣𝑗，𝑣𝑗被𝑢𝑖采用，𝑣𝑗具有属性𝑎𝑘，𝑎𝑘被拥有 𝑣𝑗。 因此，我们将它们视为四个不同的关系。 令R表示关系集，并且 R =4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e548deb7a26ef617c0b7c9404e8dedb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59373702205027454ad874be3c29fd02/" rel="bookmark">
			地理探测器——空间统计分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地理探测器（一种统计方法） ​ ——探测和利用空间分异性的工具
1. 基本思想 假设研究区分为若干子区域，如果子区域的方差之和小于区域总方差，则存在空间分异性；如果两变量的空间分布趋于一致，则两者存在统计关联性。
基于的假设：如果某个自变量对某个因变量有重要影响，那么自变量和因变量得空间分布应该具有相似性
2. 解决的问题 空间分层异质性：指层内方差小于层间方差的地理现象，例如地理分区、气 候带、土地利用图、地貌图、生物区系、区际经济差异、城乡差异以及主体功能区等等。
3. 用途 该统计量可以用于度量空间分异性、探测解释因子、分析变量之间得交互关系。
4. 优势 a) 可以探测数值型数据和探测定性数据：
擅长分析类型量，对于顺序量、比值量或间隔值进行适当的离散化即可。
b) 探测两因子交互作用于因变量：
通过分别计算和比较各单因子q值及 两因子叠加后的q值，可以判断两因子是否存在交互作用，以及交互作用的强弱、方 向、线性还是非线性等。两因子叠加既包括相乘关系，也包括其他关系，只要有关系， 就能检验出来。
5. 地理探测器原理 探测和利用空间分异性得工具。包括四个探测器
（1） 分异及因子探测：探测Y的空间分异性，以及探测某因子X多大程度上解释了属性Y得空间分异。q = 1-**SSW/SST SSW:内层方差之和，SST：全区总方差。q取值[0-1]，值越大说明Y**的空间分异性越明显
（2） 交互作用探测：识别不同风险因子Xs之间得交互作用，即评估因子X1和X2共同作用时是否会增加或减弱对因变量Y的解释力，或这些因子对Y的影响是相互独立的。
（3） 风险区探测：用于判断两个子区域间得属性均值是否有显著的差别，以t统计量来衡量。
（4） 生态探测：用于比较两因子X1和X2对属性Y的空间分布的影响是否有显著的差异，以F统计量来衡量：
6. 地理探测器软件 Geodetector：用Excel编制的地理探测出器软件
（1） 下载地址：http://www.geodetector.org/（已下载）
（2） 使用步骤：
a) 数据的收集与整理
b) 将样本（Y**，X**）读入地理探测器软件，然后运行。结果主要有四个部分，分别是：
i. 俩区域因变量均值是否有显著差异
ii. 自变量X对因变量的解释力
iii. 不同自变量对因变量的影响是否有显著的差异
iv. 自变量对因变量影响的交互作用。
需要注意的是对于面数据和点数据的不同处理方式。
7. 应用案例 （1） 新生儿神经畸形空间变异的环境因子识别
（2） 美国陆表切割度空间变异的主导因素探测
（3） 中国县域城市化空间变异的驱动力
（4） 土壤抗生素残留空间变异的因子分析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59373702205027454ad874be3c29fd02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd44afa1ab0c6d397fc88b40b9f5e670/" rel="bookmark">
			数据转化为正态分布的方法及优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据转化为正态分布的方法及优缺点 文章目录 数据转化为正态分布的方法及优缺点对数变换平方根变换倒数变换平方根反正弦变换BOX-COX变换SPSS操作 对数变换 ​ 将原始数据X的对数值作为新的分布数据：X’=LGX。当原始数据中有小值及零时，亦可取X’=lg（X+1）。还可根据需要选用X’=lg（X+k）或X’=lg（k-X）
使用情况：
（1） 使服从对数正态分布的数据正态化。如环境中某些污染物的分布，人体中某些微量元素的分布等，可用对数正态分布改善其正态性。
（2）使数据达到方差齐性，特别是各样本的标准差与均数成比例或变异系数CV接近于一个常数时。
平方根变换 ​ 将原始数据X的平方根作为新的分布数据。X’=sqrt（X）
使用情况：
（1）使服从Poission分布的计数资料或轻度偏态资料正态化，可用平方根变换使其正态化。
（2）当各样本的方差与均数呈正相关时，可使资料达到方差齐性。
倒数变换 ​ 将原始数据X的倒数作为新的分析数据。X’=1/X
平方根反正弦变换 ​ 即将原始数据X的平方根反正弦值做为新的分析数据：X’=SIN-1SQRT（X）
​ 常用于服从二项分布的率或百分比的资料。一般认为等总体率较小如＜30%时或较大（如＞70%时），偏离正态较为明显，通过样本率的平方根反正玄变换，可使资料接近正态分布，达到方差齐性的要求。
BOX-COX变换 ​ Box-Cox变换是Box和Cox在1964年提出的一种广义幂变换方法，是统计建模中常用的一种数据变换，用于连续的响应变量不满足正态分布的情况。Box-Cox变换之后，可以一定程度上减小不可观测的误差和预测变量的相关性。Box-Cox变换的主要特点是引入一个参数，通过数据本身估计该参数进而确定应采取的数据变换形式，Box-Cox变换可以明显地改善数据的正态性、对称性和方差相等性，对许多实际数据都是行之有效的。
特点：
Box-Cox变换的一个显著优点是通过求变换参数lambda来确定变换形式，而这个过程完全基于数据本身而无须任何先验信息，这无疑比凭经验或通过尝试而选用对数、平方根等变换方式要客观和精确。Box-Cox变换的目的是为了让数据满足线性模型的基本假定，即线性、正态性及方差齐性，然而经Box-Cox变换后数据是否同时满足了以上假定，仍需要考察验证 SPSS操作 操作：在转换-计算变量里面点进去，就可以把一个变量进行各种变换，就和计算器类似，不过最好的方法是把数据标准化，分析——描述统计——描述，有个选项是将标准化得分另存为变量，这样变量都符合正态性了
或者在SPSS上的操作方法：工具栏transform-Rank cases，将左边你要进行正态化的变量拖入右边“变量”框中；点选rank types对话窗，选中normal scores选项（共四种计算方法，系统默认的是bloom计算方法，可根据你的需要进行改进），点击continue，ok。spss会在数据观察表中生成两列新变量，其中N总分变量就是你想要的正态化结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ee303a6d7beca1e3e94a9496766afcd/" rel="bookmark">
			人工智能的变革趋势： 从弱人工智能到强人工智能，再到生物智能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能的变革趋势： 从弱人工智能到强人工智能，再到生物智能
我们正站在变革的边缘，而这次变革将和人类的出现一般意义重大 – Vernor Vinge
如果你站在这里，你会是什么感觉？
看上去非常刺激吧？但是你要记住，当你真的站在时间的图表中的时候，你是看不到曲线的右边的，因为你是看不到未来的。所以你真实的感觉大概是这样的：
稀松平常。
-------------------------------
遥远的未来——就在眼前
想象一下坐时间机器回到1750年的地球，那个时代没有电，畅通通讯基本靠吼，交通主要靠动物拉着跑。你在那个时代邀请了一个叫老王的人到2015年来玩，顺便看看他对“未来”有什么感受。我们可能没有办法了解1750年的老王内心的感受——金属铁壳在宽敞的公路上飞驰，和太平洋另一头的人聊天，看几千公里外正在发生进行的体育比赛，观看一场发生于半个世纪前的演唱会，从口袋里掏出一个黑色长方形工具把眼前发生的事情记录下来，生成一个地图然后地图上有个蓝点告诉你现在的位置，一边看着地球另一边的人的脸一边聊天，以及其它各种各样的黑科技。别忘了，你还没跟他解释互联网、国际空间站、大型强子对撞机、核武器以及相对论。
这时候的老王会是什么体验？惊讶、震惊、脑洞大开这些词都太温顺了，我觉得老王很可能直接被吓尿了。
但是，如果老王回到了1750年，然后觉得被吓尿是个很囧的体验，于是他也想把别人吓尿来满足一下自己，那会发生什么？于是老王也回到了250年前的1500年，邀请生活在1500年的小李去1750年玩一下。小李可能会被250年后的很多东西震惊，但是至少他不会被吓尿。同样是250来年的时间，1750和2015年的差别，比1500年和1750年的差别，要大得多了。1500年的小李可能能学到很多神奇的物理知识，可能会惊讶于欧洲的帝国主义旅程，甚至对于世界地图的认知也会大大的改变，但是1500年的小李，看到1750年的交通、通讯等等，并不会被吓尿。
所以说，对于1750年的老王来说，要把人吓尿，他需要回到更古老的过去——比如回到公元前12000年，第一次农业革命之前。那个时候还没有城市，也还没有文明。一个来自狩猎采集时代的人类，只是当时众多物种中的一个罢了，来自那个时代的小赵看到1750年庞大的人类帝国，可以航行于海洋上的巨舰，居住在“室内”，无数的收藏品，神奇的知识和发现——他很有可能被吓尿。
小赵被吓尿后如果也想做同样的事情呢？如果他会到公元前24000年，找到那个时代的小钱，然后给他展示公元前12000年的生活会怎样呢。小钱大概会觉得小赵是吃饱了没事干——“这不跟我的生活差不多么，呵呵”。小赵如果要把人吓尿，可能要回到十万年前或者更久，然后用人类对火和语言的掌控来把对方吓尿。
所以，一个人去到未来，并且被吓尿，他们需要满足一个“吓尿单位”。满足吓尿单位所需的年代间隔是不一样的。在狩猎采集时代满足一个吓尿单位需要超过十万年，而工业革命后一个吓尿单位只要两百多年就能满足。
未来学家Ray Kurzweil把这种人类的加速发展称作加速回报定律(Law of Accelerating Returns)。之所以会发生这种规律，是因为一个更加发达的社会，能够继续发展的能力也更强，发展的速度也更快——这本就是更加发达的一个标准。19世纪的人们比15世纪的人们懂得多得多，所以19世纪的人发展起来的速度自然比15世纪的人更快。
即使放到更小的时间规模上，这个定律依然有效。著名电影《回到未来》中，生活在1985年的主角回到了1955年。当主角回到1955年的时候，他被电视刚出现时的新颖、便宜的物价、没人喜欢电吉他、俚语的不同而震惊。
但是如果这部电影发生在2015年，回到30年前的主角的震惊要比这大得多。一个2000年左右出生的人，回到一个没有个人电脑、互联网、手机的1985年，会比从1985年回到1955年的主角看到更大的区别。
这同样是因为加速回报定律。1985年-2015年的平均发展速度，要比1955年-1985年的平均发展速度要快，因为1985年的世界比1955年的更发达，起点更高，所以过去30年的变化要大过之前30年的变化。
进步越来越大，发生的越来越快，也就是说我们的未来会很有趣对吧？
未来学家Kurzweil认为整个20世纪100年的进步，按照2000年的速度只要20年就能达成——2000年的发展速度是20世纪平均发展速度的5倍。他认为2000年开始只要花14年就能达成整个20世纪一百年的进步，而之后2014年开始只要花7年(2021年)，就能达到又一个20世纪一百年的进步。几十年之后，我们每年都能达成好几次相当于整个20世纪的发展，再往后，说不定每个月都能达成一次。按照加速回报定，Kurzweil认为人类在21世纪的进步将是20世纪的1000倍。
如果Kurzweil等人的想法是正确的，那2030年的世界可能就能把我们吓尿了——下一个吓尿单位可能只需要十几年，而2050年的世界会变得面目全非。
你可能觉得2050年的世界会变得面目全非这句话很可笑，但是这不是科幻，而是比你我聪明很多的科学家们相信的，而且从历史来看，也是逻辑上可以预测的。
那么为什么你会觉得“2050年的世界会变得面目全非” 这句话很可笑呢？有三个原因让你质疑对于未来的预测：
1. 我们对于历史的思考是线性的。当我们考虑未来35年的变化时，我们参照的是过去35年发生的事情。当我们考虑21世纪能产生的变化的时候，我们参考的是20世纪发生的变化。这就好像1750年的老王觉得1500年的小李在1750年能被吓尿一样。线性思考是本能的，但是但是考虑未来的时候我们应该指数地思考。一个聪明人不会把过去35年的发展作为未来35年的参考，而是会看到当下的发展速度，这样预测的会更准确一点。当然这样还是不够准确，想要更准确，你要想象发展的速度会越来越快。 2. 近期的历史很可能对人产生误导。首先，即使是坡度很高的指数曲线，只要你截取的部分够短，看起来也是很线性的，就好像你截取圆周的很小一块，看上去就是和直线差不多。其次，指数增长不是平滑统一的，发展常常遵循S曲线。 S曲线发生在新范式传遍世界的时候，S曲线分三部分
- 慢速增长(指数增长初期)
- 快速增长(指数增长的快速增长期)
- 随着新范式的成熟而出现的平缓期
如果你只看近期的历史，你很可能看到的是S曲线的某一部分，而这部分可能不能说明发展究竟有多快速。1995-2007年是互联网爆炸发展的时候，微软、谷歌、脸书进入了公众视野，伴随着的是社交网络、手机的出现和普及、智能手机的出现和普及，这一段时间就是S曲线的快速增长期。2008-2015年发展没那么迅速，至少在技术领域是这样的。如果按照过去几年的发展速度来估计当下的发展速度，可能会错得离谱，因为很有可能下一个快速增长期正在萌芽。
3. 个人经验使得我们对于未来预期过于死板。我们通过自身的经验来产生世界观，而经验把发展的速度烙印在了我们脑中——“发展就是这么个速度的。”我们还会受限于自己的想象力，因为想象力通过过去的经验来组成对未来的预测——但是我们知道的东西是不足以帮助我们预测未来的。当我们听到一个和我们经验相违背的对于未来的预测时，我们就会觉得这个预测偏了。如果我现在跟你说你可以活到150岁，250岁，甚至会永生，你是不是觉得我在扯淡——“自古以来，所有人都是会死的。”是的，过去从来没有人永生过，但是飞机发明之前也没有人坐过飞机呀。
接下来的内容，你可能一边读一边心里“呵呵”，而且这些内容可能真的是错的。但是如果我们是真的从历史规律来进行逻辑思考的，我们的结论就应该是未来的几十年将发生比我们预期的多得多得多得多的变化。同样的逻辑也表明，如果人类这个地球上最发达的物种能够越走越快，总有一天，他们会迈出彻底改变“人类是什么”这一观点的一大步，就好像自然进化不不断朝着智能迈步，并且最终迈出一大步产生了人类，从而完全改变了其它所有生物的命运。如果你留心一下近来的科技进步的话，你会发现，到处都暗示着我们对于生命的认知将要被接下来的发展而彻底改变。
_______________
通往超级智能之路
人工智能是什么？
如果你一直以来把人工智能(AI)当做科幻小说，但是近来却不但听到很多正经人严肃的讨论这个问题，你可能也会困惑。这种困惑是有原因的：
1.我们总是把人工智能和电影想到一起。星球大战、终结者、2001：太空漫游等等。电影是虚构的，那些电影角色也是虚构的，所以我们总是觉得人工智能缺乏真实感。
2.人工智能是个很宽泛的话题。从手机上的计算器到无人驾驶汽车，到未来可能改变世界的重大变革，人工智能可以用来描述很多东西，所以人们会有疑惑。
3.我们日常生活中已经每天都在使用人工智能了，只是我们没意识到而已。John McCarthy，在1956年最早使用了人工智能(Artificial Intelligence)这个词。他总是抱怨“一旦一样东西用人工智能实现了，人们就不再叫它人工智能了。”
因为这种效应，所以人工智能听起来总让人觉得是未来的神秘存在，而不是身边已经存在的现实。同时，这种效应也让人们觉得人工智能是一个从未被实现过的流行理念。Kurzweil提到经常有人说人工智能在80年代就被遗弃了，这种说法就好像“互联网已经在21世纪初互联网泡沫爆炸时死去了”一般滑稽。 所以，让我们从头开始。
首先，不要一提到人工智能就想着机器人。机器人只是人工智能的容器，机器人有时候是人形，有时候不是，但是人工智能自身只是机器人体内的电脑。人工智能是大脑的话，机器人就是身体——而且这个身体不一定是必需的。比如说Siri背后的软件和数据是人工智能，Siri说话的声音是这个人工智能的人格化体现，但是Siri本身并没有机器人这个组成部分。
其次，你可能听过“奇点”或者“技术奇点”这种说法。这种说法在数学上用来描述类似渐进的情况，这种情况下通常的规律就不适用了。这种说法同样被用在物理上来描述无限小的高密度黑洞，同样是通常的规律不适用的情况。Kurzweil则把奇点定义为加速回报定律达到了极限，技术进步以近乎无限的速度发展，而奇点之后我们将在一个完全不同的世界生活的。但是当下的很多思考人工智能的人已经不再用奇点这个说法了，而且这种说法很容易把人弄混，所以本文也尽量少用。
最后，人工智能的概念很宽，所以人工智能也分很多种，我们按照人工智能的实力将其分成三大类。
弱人工智能Artificial Narrow Intelligence (ANI): 弱人工智能是擅长于单个方面的人工智能。比如有能战胜象棋世界冠军的人工智能，但是它只会下象棋，你要问它怎样更好地在硬盘上储存数据，它就不知道怎么回答你了。
强人工智能Artificial General Intelligence (AGI): 人类级别的人工智能。强人工智能是指在各方面都能和人类比肩的人工智能，人类能干的脑力活它都能干。创造强人工智能比创造弱人工智能难得多，我们现在还做不到。Linda Gottfredson教授把智能定义为“一种宽泛的心理能力，能够进行思考、计划、解决问题、抽象思维、理解复杂理念、快速学习和从经验中学习等操作。”强人工智能在进行这些操作时应该和人类一样得心应手。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ee303a6d7beca1e3e94a9496766afcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b7cb431537fd16d46a0e95742531e8e/" rel="bookmark">
			如何使用Kali破解WIFI密码蹭网?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载Kali Linux （http://cdimage.kali.org/kali-2020.3/）
（）
2、安装配置Kali Linux （https://www.toutiao.com/a6681868475675181571/）
（https://blog.csdn.net/weixin_44431793/article/details/103793731）
（https://www.cnblogs.com/qq511314224/p/12900060.html）
3、破解Wifi步骤 （https://my.oschina.net/u/4579491/blog/4422881）
（https://www.freebuf.com/articles/wireless/127261.html）
3.1、密码字典 （密码字典jikefeng.txt下载：
链接: https://pan.baidu.com/s/1kUQWyEj 提取码: 2eb8
其他密码字典：
链接:https://pan.baidu.com/s/17ZYnXzFTc6BSNZr3i4trFg 提取码：8v3w
如果失效，请回复，会及时更新！）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ebe30b2b9d8f1ede46128c81857107/" rel="bookmark">
			java隐式参数的作用_隐式参数_scala教程_田守枝Java技术博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所谓隐式参数指的是，我们的函数或者方法中的参数可以有隐式值，或者说是默认值。通过提供隐式参数，我们在调用函数的时候，可以不提供参数，scala会自动去查找隐式值，当然隐式值也是需要我们提供的。
在Scala中，如果我们的方法定义的参数列表以implicit开头，则方法参数列表中的参数都是隐式参数。在提供了隐式值的情况下，我们调用方法时，不需要提供参数。
1、入门案例object ImplicitDemo {
//隐式值
implicit val xx: String = "tianshouzhi"
implicit val yy: Int = 25
//隐式参数
def test(implicit name: String, age: Int) {
println("name:" + name + ",age:" + age)
}
def main(args: Array[String]): Unit = {
test//注意没有携带参数
}
}
运行程序的结果为：name:tianshouzhi,age:25
可以看到了，方法的参数列表加了implicit之后，会自动查找隐式值，隐式值同样以implicit开头。
2、Scala是如何为隐式参数提供隐式值的？
Scala是通过类型检查来为隐式参数提供默认值。因为在test方法中的参数，一个是String类型，一个是Int类型，而我们提供的2个隐式值分别为implicit val xx: String = "tianshouzhi" //String类型
implicit val yy: Int = 25 //Int类型
因为提供的隐式值类型刚好能匹配上，因此调用的时候可以不传递参数。
此外，需要注意的是, 因为是按照类型进行匹配的。所以隐式参数列表中相同类型的参数，都会被赋予同样的值。例如，我们修改test方法//增加address参数
def test(implicit name: String, age: Int,address:String) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57ebe30b2b9d8f1ede46128c81857107/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d49bc811e4d127dac2ac2c9d346cabc/" rel="bookmark">
			UML类图绘制_常见设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UML类图 常用的类图元素UML类图的应用创建型模式简单工厂模式工厂方法模式抽象工厂模式建造者模式单例模式模式 结构型模式适配器模式桥接模式装饰模式门面模式享元模式代理模式 结构型模式命令模式中介者模式观察者模式状态模式策略模式 常用的类图元素 电脑类图结构为&lt;&lt;abstract&gt;&gt;，表示电脑是一个抽象类;
电脑类有两个继承类分别为平板电脑和台式电脑，电脑类与两个继承类之间的关系为实现关系，使用空心箭头的虚线表示;
平板电脑与MetePad Pro之间也是继承关系的一种，它们之间的关系为泛化关系，使用空心箭头的实线表示;
平板电脑、CPU和屏幕是组合关系使用实心菱形箭头的实线表示;
员工工作需要用到台式电脑，员工与台式电脑是依赖关系使用箭头的虚线表示;
员工与工号是关联关系，使用一根实线表示;
员工与公司是聚合关系，使用空心菱形箭头的实线表示;
UML类图的应用 创建型模式 简单工厂模式 类图说明
Product有两个继承类ConcreteProductA和ConcreteProductB，Product与两个继承类是实现关系，使用实心箭头的虚线连接。Factory与ConcreteProduct是依赖关系，使用箭头的虚线连接。 工厂方法模式 类图说明
Product有一个继承类ConcreteProduct，Product与继承类是实现关系，使用空心箭头的虚线连接。Factory有一个继承类ConcreteFactory，Factory与继承类是实现关系，使用空心箭头的虚线连接。ConcreteFactory与ConcreteProduct是依赖关系，使用箭头的虚线连接。 抽象工厂模式 类图说明
ProductA有两个继承类ConcreteProductA和ConcreteProductB，Product与继承类是实现关系，使用空心箭头的虚线连接。Factory有两个继承类ConcreteFactoryA和ConcreteFactoryB，Factory与继承类是实现关系，使用空心箭头的虚线连接。ConcreteFactoryA、ConcreteProductA和ConcreteProductB是依赖关系，使用箭头的虚线连接。 建造者模式 类图说明
Director负责获得并管理所有Builder的实现类，Director与Builder的实现类是聚合关系，使用空心菱形箭头的实线连接。Builder有一个继承类ConcreteBuilder，Builder与继承类是实现关系，使用空心箭头的虚线连接。Product和ConcreteBuilder是依赖关系，使用箭头的虚线连接。 单例模式模式 类图说明
Singleton在自己类内部维护一个自己的实例是聚合关系，使用空心菱形箭头的实线连接。 结构型模式 适配器模式 类图说明
Client和Target是依赖关系，使用箭头的虚线连接。Adapter和Target是泛化关系，使用空心箭头的实线连接。Adapter和Adaptee是组合关系，使用实心菱形的实线连接。 桥接模式 类图说明
Client和Abstraction是依赖关系，使用箭头的虚线连接。RefinedAbstraction继承自Abstraction是泛化关系，使用空心箭头的实线连接。Implementor和Abstraction是组合关系，使用实心菱形箭头的实线连接。Implementor有两个继承类ConcreteImplementorA和ConcreteImplementorB，Implementor与继承类是实现关系，使用空心箭头的虚线连接。 装饰模式 类图说明
Component有两个继承类ConcreteComponent和Decorator，Component与继承类是泛化关系，使用空心箭头的实线连接。
Decorator与父类Component同时是聚合关系，使用空心菱形箭头的实线连接。
Decorator有两个继承类ConcreteDecoratorA和ConcreteDecoratorB，Decorator与继承类是泛化关系，使用空心箭头的实线连接。
门面模式 类图说明
Client与Facade是依赖关系，使用箭头的虚线连接。
Facade与SubSystemA、SubSystemB、SubSystemC是关联关系，使用一根实线连接。
享元模式 类图说明
Flyweight有一个继承类ConcreteFlyweight，与该继承类是实现关系，使用空心箭头的虚线连接。
FlyweightFactory与Flyweight是聚合关系，使用空心菱形箭头的实线连接。
代理模式 类图说明
Subject有两个继承类Proxy和RealSubject，Subject与该继承类是泛化关系，使用空心箭头的实线连接。
Proxy和RealSubject是组合关系使用实心菱形箭头的实线连接。
结构型模式 命令模式 类图说明
Client、Receiver和ConcreteCommand之间是关联关系，使用一根实线连接。
Client和ConcreteCommand同时是依赖关系，使用箭头的虚线连接。
Command有一个继承类ConcreteCommand，Command与继承类之间是实现关系，使用空心箭头的虚线连接。
Invoker与Command是聚合关系，使用空心菱形箭头的实线连接。
中介者模式 类图说明
Client、Receiver和ConcreteCommand之间是关联关系，使用一根实线连接。
Client和ConcreteCommand同时是依赖关系，使用箭头的虚线连接。
Command有一个继承类ConcreteCommand，Command与继承类之间是实现关系，使用空心箭头的虚线连接。
Invoker与Command是聚合关系，使用空心菱形箭头的实线连接。
观察者模式 类图说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d49bc811e4d127dac2ac2c9d346cabc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2967cc4351615939ee240d4490333aea/" rel="bookmark">
			java八股文指的是什么_八股文是指什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		八股文是明清科举考试的一种文体，有固定格式：由破题、承题、起讲、入手、起股、中股、后股、束股八部分组成，题目一律出自四书五经中的原文。后四部分是文章议论的中心，各有两股对偶文字，共八股，故名。
八股文是明清科举考试的一种文体，也称制义、制艺、时文、八比文。八股文章就四书五经取题，内容必须用古人的语气，绝对不允许自由发挥，而句子的长短、字的繁简、声调高低等也都要相对成文，字数也有限制。
八股文由破题、承题、起讲、入手、起股、中股、后股、束股八部分组成，题目一律出自四书五经中的原文。后四个部分每部分有两股排比对偶的文字，合起来共八股。旧时科举，八股文要用孔子、孟子的口气说话，四副对子平仄对仗，不能用风花雪月的典故亵渎圣人，每篇文章包括从起股到束股四个部分。
开始先揭示题旨，为“破题”。接着承上文而加以阐发，叫“承题”。然后开始议论，称“起讲”。再后为“入手”，作为起讲后引出正文的突破口。以下再分“起股”“中股”“后股”和“束股”四个段落，而每个段落中，都有两股排比对偶的文字，合共八股，故称八股文。其所论内容，都要根据宋代朱熹《四书集注》等书“代圣人立说”。参阅《明史·选举志二》，示例：清·阮元《四书文话》、梁章钜《制义丛话》。《儒林外史》第一回：“此一条之后，便是礼部议定取士之法：三年一科，用《五经》《四书》八股文。
声明：该文观点仅代表作者本人，天晴科普网系信息发布平台，仅提供信息存储空间服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/286aac82789aabd5ef24ab5b8315e28a/" rel="bookmark">
			java解析xml 忽略dtd_使用Scala中的XML解析整个文件夹下的xml，并忽略dtd检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：快速解析一个文件夹下的所有xml(10年的数据，大概一千万个xml)
遇到的坑：xml里面有dtd，必须这个文件存在，不然会报错
处理思路：重写原有的方法
语言对比：Java处理速度慢，并且代码量大，这儿不做考虑，其次python，由于需要处理的xml太过复杂，python需要写多层嵌套循环，并且不能分布式处理，这儿重点讲一下Scala
Scala我么通过scala.xml.XML可以很方便的取出任意一个标签，并且可以分布式去处理。
Scala XML API提供了类似XPath的语法来解析XML。在NodeSeq这类父类里，定义了两个很重要的操作符(""和"\")，用来获得解析XML：
\ ：\ 简单来说就是根据条件搜索第一次出现的节点
\\：而 \\ 则是根据条件搜索所有的子节点
我们先分享几个小方法：
1.递归遍历文件夹，找出所有以xml结尾的文件
/**
递归查找文件及子文件夹下面的XML文件
@param file
@return
*/
def getFile(file:File): Array[File] ={
val files = file.listFiles().filter(! .isDirectory)
.filter(t =&gt; t.toString.toLowerCase.endsWith(".xml")) //此处读取.txt and .md文件
files ++ file.listFiles().filter(.isDirectory).flatMap(getFile)
}
2.解决dtd校验文件问题
源码：
这儿我们会用到loadFile去加载xml文件，我们根据源码可以看到loadFile传进去了一个parser方法:
XML.XML.loadFile(filename)
/**
Loads XML from the given InputSource, using the supplied parser.
The methods available in scala.xml.XML use the XML parser in the JDK.
/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/286aac82789aabd5ef24ab5b8315e28a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f21c4d75335e1b1bafa997de459a2c0/" rel="bookmark">
			python中shuffle是什么意思_python中shuffle()方法的功能详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python的概率分布中，洗牌算法是通过shuffle()方法实现的，shuffle()方法将列表的所有元素打乱，随机排列。Python既可以使用random.shuffle对列表进行洗牌，也可以使用random.shuffle随机播放字符串列表，本文向大家介绍python中shuffle()方法的功能详解。
一、shuffle()方法
是打乱序列里面的元素，并随机排列的。
1、shuffle()方法使用语法import random
random.shuffle (lst )
注意：shuffle()是不能直接访问的，需要导入 random 模块，然后通过 random 静态对象调用该方法。
2、shuffle()方法参数
lst -- 可以是一个序列或者元组。
3、shuffle()方法返回值
返回随机排序后的序列。
二、shuffle()方法使用
Python使用random.shuffle对列表进行洗牌l = np.arange(10) # list也行
print(l)
rng.shuffle(l)
print(l)
# [0 1 2 3 4 5 6 7 8 9]
# [6 8 9 2 0 3 5 4 7 1]
使用random.shuffle随机播放字符串列表string_list = ["Paint It Black","Gimme Shelter","同情魔鬼","满意","你不能总是得到你想要的东西"]
print("原始字符串列表：",string_list)
random.shuffle(string_list) #shuffle方法
print("第一次shuffle之后的字符串列表：",string_list)
random.shuffle(string_list)
print("第二次shuffle后的字符串列表：",string_list)
以上就是python中shuffle()方法的功能介绍，shuffle函数没有返回值，仅仅是实现了对list元素进行随机排序的一种功能哦~更多python高级学习推荐：python高级教程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/108d383ac50765b0ef99710c40150e97/" rel="bookmark">
			markdown语法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Markdown学习 标题 三级标题 四级标题 一级标题一个 # ，多级标题多个 # 字体 加粗用 **倾斜用 *两个都用 ***斜线用 ~~
Hello,World! Hello,World!
Hello,World!
Hello,World!
引用 大于号 &gt; 是引用 选择金飞鹏说java，走向人生巅峰
分割线 三个 - 或者 三个 * 图片 格式为：!【图片】(路径)
超链接 格式为: [文字]（链接）
点击跳转到百度 列表 有序列表 格式: 数字+点
无序列表 格式: 减号+空格
ac 123 表格 格式为 : 在下方代码块中 名字性别生日张三男2001.11.1 代码 public void doSome(){ |名字|性别|生日| |-- |--|-- | |张三|男|2001.11.1| 注意：记得去源代码模式删除多余的换行 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06c2320143936cca74053cb0899d7038/" rel="bookmark">
			单节点使用Redisson报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单节点使用Redisson报错 Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redisson' defined in class path resource [product/config/MyRedissonConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redisson' threw exception; nested exception is java.lang.StringIndexOutOfBoundsException: String index out of range: -3 at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:627) at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:456) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1321) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:845) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:877) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06c2320143936cca74053cb0899d7038/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a6b67ff5d07c8dd06e7b9ae8d9ee2f/" rel="bookmark">
			风铃VMware虚拟机管家3.0VM虚拟机批量克隆定时批量开关机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		风铃VMware虚拟机管家3.0
下载地址：https://www.lanzoux.com/b0eq0vhkj
⒈克隆帮助：
①母盘路径：选择你需要克隆的母盘文件
②存放路径：选择克隆虚拟机后的保存目录
③克隆类型：链接克隆-占用很少的磁盘空间，但是必须依靠母盘启动，母盘一旦损坏所有克隆出来的虚拟机即不能启动。
完整克隆-完全复制母盘 母盘多大克隆出来的虚拟机就多大。
④克隆数量：即需要克隆多少台虚拟机
⑤一键克隆：以上设置完毕后，点击一键克隆即可 （名称前缀即克隆出来虚拟机的名字 也可保持默认）
⒉批量启动帮助：
①间隔时间：启动第一台完毕后间隔多久启动第二台（单位：秒）
②启动数量：需要批量启动多少台虚拟机（默认克隆多少台就会启动多少台）
③延迟时间：自动挂起或关闭所有正在运行虚拟机的时间 （单位：分钟 0 不执行）
④导入：导入已克隆完毕的虚拟机进行启动（只可以导入本软件克隆出来的）
⑤启动：设置完以上参数后即可批量启动
⑥停止：即停止正在批量启动的虚拟机
⑦关机：即批量关闭正在运行的虚拟机
⑧挂起：即批量挂起正在运行的虚拟机
⒊机器列表帮助：
①左键双击：启动当前选中虚拟机
②右键续启：在当前选中虚拟机往后，继续批量启动
③右键单启：启动当前选中虚拟机
④右键重启：重启当前选中虚拟机
⑤右键关机：关闭当前选中虚拟机
⑥右键删除：删除当前选中虚拟机（包括磁盘中的虚拟机）
⑦右键清空：即清除左边列表里面的虚拟机以及是否删除所有已克隆的虚拟机）
⑧软件定制：如需定制其他功能请联系作者
⒋注意事项：
①本软件只支持VMware虚拟机 （版本任意）
②必须安装完整版虚拟机，精简版可能会出现无法克隆等情况
特别注意！
③克隆后不会出现在VM列表 -需要单独导入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ce35fcb4450772350c060d6ab2bde12/" rel="bookmark">
			Python-squeeze()、unsqueeze()函数的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 降维torch.squeeze(input, dim=None, out=None)
简单示例
matplotlib画图示例
2.增维 torch.unsqueeze(input, dim, out=None)
简单示例
3.参考
1. 降维torch.squeeze(input, dim=None, out=None) 函数功能：去除size为1的维度，包括行和列。当维度大于等于2时，squeeze()无作用。
当给定dim时，那么挤压操作只在给定维度上。即若tensor.size(dim) = 1，则去掉该维度 其中squeeze(0)代表若第一维度值为1则去除第一维度squeeze(1)代表若第二维度值为1则去除第二维度-1，去除最后维度值为1的维度当不给定dim时，将输入张量形状中的1 去除并返回。 如果输入是形如(A×1×B×1×C×1×D)(A×1×B×1×C×1×D)，那么输出形状就为： (A×B×C×D)(A×B×C×D) 例如，输入形状为: (A×1×B)(A×1×B), squeeze(input, 0) 将会保持张量不变，只有用 squeeze(input, 1)，形状会变成 (A×B)(A×B)。
注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。
参数:
input (Tensor) – 输入张量dim (int, optional) – 如果给定，则input只会在给定维度挤压，维度的索引（从0开始）out (Tensor, optional) – 输出张量 简单示例 a = torch.Tensor(1,3) &gt;&gt; tensor([[-1.37,4.56,-3.57]]) print a.squeeze(0) #第一个维度大小确实是1，所以可以去除 &gt;&gt; tensor([-1.37,4.56,-3.57]) print a.squeeze(1) ##第二个维度大小是3，所以不能去除 &gt;&gt; tensor([[-1.37,4.56,-3.57]]) #例子2 b = torch.Tensor(2,3) print b &gt;&gt; tensor([[-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ce35fcb4450772350c060d6ab2bde12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c4db5b3d0255de17906f6f5e63ecd45/" rel="bookmark">
			【论文笔记】STANet：基于孪生神经网络的时空注意力变化检测模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是论文《A Spatial-Temporal Attention-Based Method and a New Dataset for Remote Sensing Image Change Detection》的阅读笔记，由于原文比较长，本文有很多省略，着重介绍该模型是怎么运作的。
一、相关工作 文章针对遥感图像变化检测问题提出了一个基于孪生神经网络的时空注意力变化检测模型STANet，其中的自注意力模块可以计算任意两张拍摄于不同日期和位置的图像的注意力权重，并产生更具辨别性的特征。考虑到物体可能具有不同的大小，文章还将图像分割成了多尺度的子区域，并在每个子区域中引入了自注意力机制。此外还创建了新的变化检测数据集LEVIR-CD。
上图a是时空注意力的示意图，b是图像误配准的情况。
大多数基于机器学习的变化检测方法都包括两步：单元分析和变化识别。单元分析是分析单元的原数据的特征，分析单元可以分为图像像素和图像物体两大类。变化识别使用手工或学习到的规则来计算特征差图并使用阈值分割得到不同的变化区域。
基于深度学习的变化检测方法主要可以分为两类：基于度量的方法和基于分类的方法。基于度量的方法通过对比图像之间参数化的距离来决定是否发生变化。每一对点之间的特征的度量表示是否发生了变化。基于分类的方法通过对提取到的图像特征进行分类，从而识别变化的类别。STANet属于基于度量的方法。
二、方法和网络结构 1. motivation 文章的motivation如下：
变化检测数据是有时间维度和空间维度的光谱向量组成的，开发不同时空位置之间的关系可以提升变化检测方法的效果。因此提出了时空自注意力机制。由于变换物体可能具有不同的大小，从一个合适的范围内提取特征可以更好地表示一定尺度的对象。可以通过从不同大小区域提取得到的特征结合起来以获得不同尺度的特征。因此将图像分割成了多尺度的子区域，并在每个子区域中引入了自注意力机制。 2. 网络结构 文章设计了两种自注意力模块，一是基本的时空注意力模块BAM，二是金字塔时空注意力模块PAM。BAM任意两个位置之间的时空独立性注意力权重，并通过时空中所有位置特征的加权和来计算每个位置的响应。PAM将BAM嵌入得到一个金字塔结构以产生多尺度的注意力表示。
上图是STANet的结构示意图，图中的 C × H × W C\times H\times W C×H×W中 C C C是通道数， H H H和 W W W是特征图的高和宽。
STANet包括特征提取器、注意力模块、度量模块三部分。首先两张图像被喂入到两个特征提取器中获得两个特征图 X ( 1 ) X^{(1)} X(1)和 X ( 2 ) X^{(2)} X(2)，经过注意力模块的处理后得到两张注意力特征图 Z ( 1 ) Z^{(1)} Z(1)和 Z ( 2 ) Z^{(2)} Z(2)，在将注意力特征图resize到输入图像大小之后，度量模块会计算两个注意力特征图的每个像素对之间的距离，并产生一个距离图 D D D，然后通过简单的阈值法得到最终的变化标签图 P P P。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c4db5b3d0255de17906f6f5e63ecd45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86dc2939966d6d3b0e4d1bc683007e77/" rel="bookmark">
			java getter返回值_使用Java中的getter方法返回私有集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我有许多在内部使用私有集或列表的Java类.我希望能够使用get … List()方法返回这些集/列表.
我正在考虑的替代方案：
&gt;返回对内部对象的引用
&gt;构建一个新的集/列表并填写它(这似乎是不好的做法？)
&gt;使用Collections.unmodifiableList(partitions);
以下哪一项是解决此问题的最常见/最佳方式？
解决方法:
这里有许多方面需要考虑.正如其他人已经指出的那样,最终决定取决于你的意图,但有关这三个选项的一般性陈述：
1.返回对内部对象的引用
这可能会带来问题.当你这样做时,你几乎不可能保证一致的状态.调用者可能会获取列表,然后做一些讨厌的事情
List list = object.getList();
list.clear();
list.add(null);
...
也许不是出于恶意,而是偶然,因为他认为安全/允许这样做.
2.构建一个新的集/列表并填写它(这似乎是不好的做法？)
这不是一般的“坏习惯”.无论如何,它是API设计方面迄今为止最安全的解决方案.这里唯一需要注意的是,可能存在性能损失,具体取决于几个因素.例如.列表中包含多少元素,以及如何使用返回的列表.像这样的一些(可疑的？)模式
for (int i=0; i
{
Element element = object.getList().get(i);
...
}
可能会变得非常昂贵(尽管有人可能会争辩说,在这种特殊情况下,是否是这样实现它的用户的错,一般问题仍然有效)
3.使用Collections.unmodifiableList(partitions);
这是我个人经常使用的.它在API设计意义上是安全的,与复制列表相比,其开销只有微不足道.但是,调用者在获得对它的引用之后知道该列表是否可能发生变化是很重要的.
这导致…
最重要的建议：
记录方法正在做什么！不要写这样的评论
/**
* Returns the list of elements.
*
* @return The list of elements.
*/
public List getList() { ... }
而是指定您可以确定列表的内容.例如
/**
* Returns a copy of the list of elements.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86dc2939966d6d3b0e4d1bc683007e77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b03d0484dba3c38b558058f2dc780172/" rel="bookmark">
			基于Linux内核时钟的简单闹钟应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 技术路线应用程序模块设计 总体功能以及设计流程图 代码Makefiletimer.calarm.c 编译过程及编译结果清理工程编译工程 运行或测试结果导入模块调用应用程序 参考文章 技术路线 在本实例中，我们采用应用程序以及内核模块的结合以达到使用动态定时器定时的目的。
其中使用了应用程序中调用了两个系统调用函数，而系统调用函数使用模块的方式进行导入。下面分别对应用程序和内核模块功能进行介绍：
应用程序 应用程序部分，首先接受来自用户输入的参数，并且对命令进行检测，如果有误，对用户进行提醒，如果正确，将调用第一个系统调用函数，将用户输入的定时时间传入内核函数中，进行定时器的定时，并且在后面通过轮询去检测定时完成标志，其中检测的函数也是一个系统调用函数，当定时完成标志被置一后，调用声音驱动函数，发出闹铃的响声并提示用户。
模块设计 模块设计部分，主要是方便应用程序对内核的动态定时器进行管理。其中在导入模块的时候，为了修改内存中的表项，首先修改寄存器的保护位，然后修改映射在内存中的系统调用表，把空闲的系统调用表项指向自己写的模块函数，并且保留原始的系统调用表，方便卸载模块的时候恢复系统调用表。模块中包含两个系统调用函数，其中一个接收来自应用程序中用户输入的参数，根据此参数设置定时器的基本定时，并在定时器的回调函数中打印倒计时，当到达定时时间的时候将计时完成标志置位。而第二个系统调用函数则是向应用程序返回计时完成标志，以达到通知应用程序的目的。
总体功能以及设计 获取到命令行中用户输入的定时参数，要能够对参数进行检查以及对输错的参数进行提示等，引导用户了解命令的使用方法。在正确得到用户输入后，解析命令，计时开始，并将用户设定计时信息输出在命令行中，方便用户进行确认。在系统内核日志中打印倒计时，在计时完成后，响起铃声，通知用户，并在命令行中输出完成信息。
流程图 代码 Makefile 1.	#obj-m表示编译生成可加载模块 2.	obj-m:=timer.o 3.	#需要编译的模块源文件地址 4.	PWD:= $(shell pwd) 5.	CC:= gcc 6.	#指定内核源码的位置 7.	KERNELDIR:= /lib/modules/$(shell uname -r)/build 8.	#关闭gcc优化选项，避免插入模块出错 9.	EXTRA_CFLAGS= -O0 10.	11.	all: 12.	make -C $(KERNELDIR) M=$(PWD) modules 13.	$(CC) alarm.c -o alarm 14.	clean: 15.	make -C $(KERNELDIR) M=$(PWD) clean 16.	rm -rf alarm 17.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b03d0484dba3c38b558058f2dc780172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce6c4d150e870451f9cc811375d9c7a5/" rel="bookmark">
			Spring Data Jpa 动态查询Specification的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在平常的使用中，我们往往要根据前端传过来的参数(参数个数不确定)动态查询一些数据。
下文就介绍一下在Spring Data Jpa中动态查询的基本用法。
一、dao层的Repository继承JpaRepository
例：
public interface UserInfoRepository extends JpaRepository&lt;T, Long&gt;, JpaSpecificationExecutor&lt;T&gt; { } 二、在需要查询的service类中注入Repository 例：
@Resource private UserInfoRepository userInfoRepository; 三、在需要查询的方法中使用动态查询
1、查询全部findAll
下面介绍最常用的(equal,notEqual,in,like,greaterThan,lessThan,between,le,ge,isNotNull,isNull)用法。
注意：r.get("xxx")里面的字段必须是实体类里面存在的且必须一致
public void queryUserInfo (String userCode, List&lt;String&gt; unionNoList, String userName, Date startTime, Date endTime, Integer maxAge, Integer minAge, String sex) { List&lt;UserInfoEntity&gt; userInfoList = = userInfoRepository.findAll((Specification&lt;UserInfoEntity&gt;) (r, q, b) -&gt; { List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;(); if (StringUtils.isNotBlank(userCode)) { //equal等于 predicates.add(b.equal(r.get("userCode"), userCode)); } if (StringUtils.isNotBlank(sex)) { //notEqual不等于 predicates.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce6c4d150e870451f9cc811375d9c7a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/434cfb426e617ee2ca441869465804f8/" rel="bookmark">
			井字棋 二维数组java_LeetCode 面试题 16.04. 井字游戏 Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一看到井字棋游戏最先想到决策树，这个题是直接判断输赢。注意不是9个格子，是N*N个格子。那么第一步应该把一维数组放到二维数组中，否则无法遍历。
遇到X，转换成1。遇到O，转换成-1。否则为0
遍历二维数组的每一行，每一列，两条对角线。如果和为N，则输出"X"，和为-N，则输出"O"。遍历时需要保存0的数量，用于判断还有没有空位。flag表示有无胜利者。
class Solution {
public String tictactoe(String[] board) {
int n = board.length;
int ox[][] = new int[n][n];
for(int i=0;i
for(int j=0;j
if(board[i].charAt(j) == 'X'){
ox[i][j] = 1;
}else if(board[i].charAt(j) == 'O'){
ox[i][j] = -1;
}else{
ox[i][j] = 0;
}
}
}
return win(ox);
}
public String win(int nums[][]){
int n=nums.length;
int rowsum=0,colsum=0,zeronum=0,diagonal1=0,diagonal2=0;
boolean flag=false;
for(int i=0;i
rowsum=0;
for(int j=0;j
if(nums[i][j]==0){
zeronum++;
}
rowsum+=nums[i][j];
if(i==j){
diagonal1+=nums[i][j];
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/434cfb426e617ee2ca441869465804f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac896d47f31c33518c782204bbd9df0f/" rel="bookmark">
			井字棋 二维数组java_GitHub - java-a/lab7: 进击的井字棋 / Advanced Tic-tac-toe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lab7
使用二维数组实现 lab5 的“井字棋”小游戏，实现悔棋和撤销悔棋，并了解注释的书写。
Deadline：2016.11.04 23:59:59(UTC+8)。
问题描述
约定
使用命令行读入控制信息及输出棋盘，棋盘中用.表示空位，O和X表示两位玩家。
两位玩家交替输入一个[0, 8]闭区间中的正整数，表示落子位置(如0表示第一排第一个坑，5表示第二排正中那个坑，8表示第三排最后一个坑)。具体的对应关系如下所示：
0 1 2
3 4 5
6 7 8
玩家输入n个u(undo)，回到n步之前的状态。如u表示回到上一步的状态，uuu表示回到三步前的状态。注意，悔棋后落子的玩家可能会发生变化(如悔棋1步后当前玩家可能从X变为O)。
玩家输入n个r(redo)，撤销n步悔棋。如r表示回到下一步的状态，rrr表示回到三步后的状态。注意，撤销悔棋后落子的玩家可能会发生变化(如撤销悔棋1步后当前玩家可能从X变为O)。另外，可能会出现无法撤销悔棋的情况，如试图撤销的步数超过之前悔棋的步数，或上一次落子后尚未悔棋。
输入不要求合法性判断，仅考虑上述三种情况。可以在多次输入中连续悔棋、撤销悔棋，或交替使用。
要求
实现基本的“井字棋”的游戏逻辑(可以参考最后的起始代码)。
使用方法分离不同作用的代码块。
使用二维数组保存棋盘状态。
实现悔棋与撤销悔棋(优先实现悔棋，若时间上来不及撤销悔棋可留到课后)。
使用良好的代码风格和适当的注释。
起始代码
下面的起始代码为助教提供的 lab5 参考实现。你可以在这份代码的基础上进行修改，以完成本次 lab 提出的要求；也可以按照自己的编码习惯独立完成。
import java.util.Scanner;
public class TicTacToe {
public static void main(String[] args) {
char[][] board = {{'.', '.', '.'}, {'.', '.', '.'}, {'.', '.', '.'}};
boolean player = true;
Scanner scanner = new Scanner(System.in);
while (true) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac896d47f31c33518c782204bbd9df0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92c45c3a2a5b0ee9290e6d417e772d74/" rel="bookmark">
			python split从末尾开始分割_Python 字符分割时，只分割最后一个（rsplit的使用）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		## Python 字符分割时，只分割最后一个(rsplit的使用)
在python分割时，有时候不是把整个字符分割，而是只分割部分，例如：我要分割文件路径，只想把最后的文件名去除，保留文件夹的路径。例如：/home/username/data/text.txt 我想要得到/home/username/data/。如果用split则会把整个分割成一个list，但是可以使用rsplit。
例如：
path = /home/username/data/text.txt
path.split("/")
["home","username","data","text.txt "]
## 而使用rsplit：
path.rsplit("/",1)
["/home/username/data","text.txt "]
rsplit("/",1) 中的1，表示从后面分割1个出来，如果是2，那么就是分割两部分出来
转载：https://blog.csdn.net/qq1483661204/article/details/96119864
## Python 字符分割时，只分割最后一个(rsplit的使用)
在python分割时，有时候不是把整个字符分割，而是只分割部分，例如：我要分割文件路径，只想把最后的文件名去除，保留文件夹的路径。例如：/home/username/data/text.txt 我想要得到/home/username/data/。如果用split则会把整个分割成一个list，但是可以使用rsplit。
例如：
path = /home/username/data/text.txt
path.split("/")
["home","username","data","text.txt "]
## 而使用rsplit：
path.rsplit("/",1)
["/home/username/data","text.txt "]
rsplit("/",1) 中的1，表示从后面分割1个出来，如果是2，那么就是分割两部分出来
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/291bd82dd21d57f56da7d9c02d7d7d84/" rel="bookmark">
			2021年2月反思与总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 高开低落的开端
总结当下，反思自我，才能以正确的方式面对未来。2021年总体目标是：
走出舒适区，做自己不想做的事情，超越2020年的自己做一位晴天爸爸，提高亲子相处质量 概述 2021年2月是比较特殊的一个月份，一个新的起点。在这个月份中，发生了很多新鲜的事情。很多事情是以前想做而一直没有做的；还有一些事情是以前没有意识到，知道发生了一些特殊的事件，才意识到这类事情影响的严重性，从而迫使自己不得不重新认识自己、评估自己、改变自己，消除对周围至亲的人造成无形的伤害。2021年2月份发生或意识到的问题如下：
基金、股市可谓是过山车式的下跌啊，过了春节一直绿，绿的都心慌，损失掺重啊😢
异地过年，渡过了一次别样的春节
儿子在幼儿园渡过了6个月，生活习惯、品德、礼貌、社交能力等方面有了质的突破，但是也出现了一些其他方面的问题（比如：不以前那样活泼开朗了；变得胆小了）
个人的专业技术范围扩大了，慢慢尝试学习前端相关的知识，扩大自身的知识广度；扩大了自身的业务领域及项目参与度，不再仅仅局限于某个领域（一是没有深入挖掘和推广的意义；二是领导善意的提醒与建议（不要陷入而无法自拔））
其他能力的培养与塑造。仅仅专注于专业技能的提升，忽视了能力、价值观以及性格特质的提升。这就好比冰山模型一样，露在水面上方是专业技能，而在水面下方的是能力、价值观和性格特质。专业技能可以有针对性的提升，可以快速的满足当下的需求；但是决定未来个人发展的是水面下方的因素，而且能力、价值观和性格是很难短时间改变的。
下面针对以上几点，重点分析与总结，自我分析一下存在的问题，指定一下改进措施，并在后续进行刻意的改变与练习。
问题分析 个人理财 2020年开始尝试个人理财，理财的途径都是通过线上第三方交易平台进行的，比如：理财通、支付宝、京东金融以及天天基金等APP。2020年1~8月份，都是小打小闹，当时主要关于稳健型的理财产品，基本上每天都有正向收益，每年下来比银行的利益要高，后来9月份以后，开始关注于基金方面的产品，开始通过学一些理财课，学习基础知识，后来慢慢的尝试，从货币基金、债券基金、指数基金、股票基金慢慢的投入，投入基金的收益率越来越高，风险越来越大。截止到2021年1月份基金收益率很多都达到25%。春节之前，连涨一周，心里那个爽啊，春节之后，那是每天都绿啊，心慌。通过这件事给我的教训如下
投资有风险，入市需谨慎鸡蛋不能放在一个篮子里，采用化整为零的思想，降低风险。实际上，这点我做到了，投了不同的行业和类型的产品，奈何全世界的行情不好，没办法资金投资配比不合理。随时可用资金：稳健资金：高收益资金的比例不合理。起初的时候，资金分配比例可能是2:5:3。后来由于行情好，尝到了甜头，逐步调整了比例，到这个月资金比例达到了1:2:7。行情稳定的时候，收益率很高，但是遇到现在的行情，那每天跌的叫一个酸爽啊，滴血啊理论知识零散，不成体系。不懂或者一知半解的领域，还是不要碰。尤其是股票这玩意贪得无厌是本性。基金收益率达到近30%，这收益率对于刚从事理财的人来说，应该是很高的了。那些稳健的产品收益率达到6%就很高了。当收益率达到30%的时候，还是希望他会涨好的开始，不一定有好的结果。理财产品的收益率达到多少才算是合理的呢？没有一个理想的心理期望值。收益止盈或者目标止盈没有设限
异地过年 由于新冠疫情的影响，以及为了响应国家的政策，我们决定就地过年。不回老家过年就是没有过年的氛围，少了很多的乐趣，少了很多过年的习俗。
亲子互动与身心成长 儿子已经上了半年的幼儿园了，这半年对于儿子来说，是很慢长的，经历了很多，改变了很多。慢慢的适应了幼儿园的生活。逐渐的接受了老师、同学以及每天的生活作息。一切都变得那样平静，但是孩子的性格却发生了变化，变得有点内向，从老师发的视频中，看出孩子那么的不自在，脸上少了很多的笑容。这才意识到孩子的内向是复杂的，每天都在煎熬。
2020年下半年，家人和自己不断生病，严重影响个人情绪以及家庭氛围。我们家老大对于数字方面的东西非常痴迷，每天放学回来都在那里摆弄很长时间的数字。所以，我就有意的培养他这方面的能力。从简单的数数、奇数、偶数、跳数、10以内的加减法、破十法、凑十法等学习的很快，后来自己又学会了连加、连减等方式。过年的时候，闲着无聊，买了一套火花思维练习册，每天陪他做一些练习题，在陪他做题的过程中，遇到一些我教过但他不会的知识点的时候，我的情绪就被调动了，不论是脸色，还是说话的语气，他都会赶到不安全了，有时哭着不做了。连带着让我们夫妻发生争吵，闹得很不好。
孩子永远是孩子，他仅仅是一个3岁多的孩子，孩子的兴趣是需要大人来培养、挖掘和保护的。在挖掘和保护的过程中，应该本着寓教于乐的心态去培养，而不是像学生一样，一味地灌输，因为它还是一个孩子。有时候我老婆说，不要那么严厉的管教，不然到他上学的时候，可能会适得其反，现在想想也是这个道理孩子的各方面的问题都是大人的写照。孩子会模仿父母的行为，孩子是父母的一面镜子孩子的性格深受所处环境的影响，家庭环境对孩子的性格塑造更重要。原来在家里，我的脸部表情变化不大，跟孩子的感觉是一副不苟言笑的感觉，导致孩子也模仿男孩性格的变化、胆小的原因是父亲造成的。男孩子胆小，父亲应该带着孩子做一些只有男人才能干的事情，做一些男人玩的游戏，锻炼他的男子汉气概，培养他敢于尝试、不认输的性格孩子的内心世界是复杂的，需要定期与他交流，了解孩子内心世界，及时发现潜在的问题根据亲身经历，男孩子确实比女孩子发育晚，尤其是语言和社交方面不要用一些讽刺、贬义的词语来对待孩子，有时父母一句无心的话，可能对孩子造成一生无法弥补的伤害，进而影响孩子的性格发展每个孩子都是独一无二的，不要拿别人家的孩子跟自己家的孩子比较，伤害来自于比较。要让孩子自己跟自己比较不要再孩子哭闹、做错事情的时候，对孩子进行教育。因为此时此刻孩子的内心是封闭的，他内心可能想的是“完了，我又做错事了，爸爸要发火了。我要小心了”。这个时候的任何说教、指责都是毫无意义的，犹如对牛弹琴一样。应该在孩子做了一件有意义的事、表现好的时候，进行教育，说明他通过自身的努力和尝试，才做成了这么有意义的事情，帮着他加深良好的品质，这样才深刻、有意义。 个人成长 2020年，根据所从事的工作以及行业的发展状况，已经意识到自身的弊端。同时，再加上相关领导直接或间接的提示，已经意识到自身发展的瓶颈。原来对自己的定位是专注于后端开发，学习管理类和产品类的相关知识，争取做一个”偏于后端，懂点管理和产品思维“的人员，不涉猎前端的技术栈（因为原来学习过前端相关的技术，总觉得前端技术零散、开发工具和调试不方便，再加上自己的美工太差）。
自从2021年1月中下旬开始，接触react相关的知识，感觉前端开发还是蛮有意思的。领导也给出了前端技术栈以及学习路线。按照推荐的前端路线进行了学习，学习了react相关的基础知识，目前可以参与到某些项目前端的部分开发工作，可以满足前端基础功能的开发要求。但是对于逻辑较为复杂的业务以及前端性能优化等方面的工作暂未涉及。
与人沟通是锻炼个人能力的重要途径。已经有1年多没有走出去，接触各类的用户，直接面对不同职位、不同角色的用户了，缺乏历练的机会，都不知道现在自己与人交流会不会紧张？为了提升沟通能力、高效表达能力有意的参加一些网课的学习《高效表达训练营》、《个人发展战略》。
完成了2021年个人计划的制定，包括个人计划、亲子计划以及家庭计划。按部就班的实施计划，定期回顾总结。
3月计划 个人理财 平常心对待，不要因为大盘的波动，严重影响自己的情绪重新调整资金分配比例，考虑风险因素（风险既是威胁也是机会）眼光要长远，关注长期不要计较短期的收益 亲子互动 细化并执行好孩子的学习计划每天陪伴孩子看书半小时，营造家庭学习的环境，巩固孩子自我阅读的习惯陪儿子爬3次树，爬1次盘山，锻炼孩子的胆量和毅力不在随意给孩子贴标签，不拿自己的孩子跟其他的孩子作比较平复自己的情绪，对孩子要有耐心和容错率每天陪孩子做一些小游戏或者散步，改善体质，提高自身免疫力 个人成长 系统学习react相关知识，包括redux、路由、通信以及性能优化等方面前端基础知识学习，主要是CSS、JS以及webpack等知识积极参与不同领域项目前后端的开发认真领会《正念的奇迹》、《养育男孩》、《不吼不叫》以及《陪孩子终身成长》的精髓开启健身计划，每周跑步2次，每次5公里继续实施2021秘密计划 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72d56a006735d6881938903752adab2c/" rel="bookmark">
			安装MySQL无法下一步问题解决了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搜了半天，下班回来后。家里面电脑的安装。 真费劲啊 MySQL安装问题：安装MySQL到用户名密码时，无法next原因
Hustwqgz 2017-08-17 17:58:49 11853 收藏
分类专栏： MySQL 文章标签： mysql 密码
版权
刚刚装了MySQL，安装到用户名密码的时候，next按钮是灰色的。
造成的原因：输入密码是想输入自己设定的密码。
我设定的 1234密码， 然后用户名 root，结果就是不能通过！shit 我的处理方法：直接输入用户名为root、密码为root，就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6a1b1d3b6bcb6abac320fc823769ae/" rel="bookmark">
			EduCoder Java 字符串与集合练习——词频统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：单词分割 任务描述 本关任务：将一段英语字符串进行单词分割。
编程要求 请仔细阅读右侧代码，根据方法内的提示，在Begin - End区域内进行代码补充，具体任务如下：
用String.split()方法将字符串“aaa|bbb|ccc”以“|”进行拆分，用StringTokenizer类将字符串“This?is?a?test?string”以“?”进行拆分。 测试说明 补充完代码后，点击测评，平台会对你编写的代码进行测试，当你的结果与预期输出一致时，即为通过。
通关代码 package step1; import java.util.List; import java.util.ArrayList; import java.util.StringTokenizer; public class StudentDemo{ //使用String.split()方法分割 public List&lt;String&gt; splitPartition(String str){ List&lt;String&gt; list=new ArrayList&lt;String&gt;(); //请在此添加实现代码 /********** Begin **********/ String[] strArray=str.split("\\|"); for(String str2:strArray){ System.out.println(str2); } System.out.println(); /********** End **********/ return list; } //使用StringTokenizer类进行分割 public List&lt;String&gt; tokenPartition(String str){ List&lt;String&gt; list=new ArrayList&lt;String&gt;(); //请在此添加实现代码 /********** Begin **********/ String[] strArray=str.split("\\?"); for(String str1:strArray){ System.out.println(str1); } /********** End **********/ return list; } } 第2关：确定单词在字符串中的位置 任务描述 本关任务：得到一个单词在一段字符串中的位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f6a1b1d3b6bcb6abac320fc823769ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/467cbec78bf7dfbd1d4e2550f0a3c3ed/" rel="bookmark">
			java添加服务器地址,将-javaagent添加到Tomcat 6服务器，我在哪里放置它以什么格式？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I´m trying to install an application health monitoring application that can monitor J2EE web transactions and I need to put a javaagent into my Tomcat somehow but am not clear on exactly how to do this, I am using Linux and have been instructed by the software company that makes this product to do something like below:
-javaagent:
I have received further support from them and they basically said to put this into the appropriate .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/467cbec78bf7dfbd1d4e2550f0a3c3ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15f01c94fd1b7ad0ec15a7d5170aa6a4/" rel="bookmark">
			如何禁止修改Excel工作表名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常会有网友提问：如何实现禁止修改Excel工作表名称，这个暂时没有完美解决方案，但是如下变通解决方法基本上可以满足需求。
示例文件中有两个工作表，名称为Summary和Sheet2，假设禁止修改第一个工作表名称。
修改Excel工作表名称时，涉及跨表引用公式中的工作表名称会自动更新，无需大家操心，所以固定工作表名称一般是两个目的：
便于在VBA中引用工作表对象表格文件更加规范化 对于第一个目的，其实也更好的解决方法，用户无法在Excel界面中修改工作表的CodeName，所以在VBA代码中使用CodeName就可以避免由于工作表名称修改导致的代码错误。例如示例文件中，工作表Summary的CodeName为Sheet1，无论将工作表名称修改任何字符，其CodeName都是不变的。
对于第2目的，可以使用事件代码来基本实现，为什么开篇说没有完美解决方案呢？其原因就在这里，如果用户打开文件时没有启用宏，那么所有代码都是无效的，也就无法禁止修改工作表名称了。
在Summary工作表中添加如下两个事件代码。
Private Sub Worksheet_SelectionChange(ByVal Target As Range) If Sheet1.Name &lt;&gt; "Summary" Then Sheet1.Name = "Summary" End Sub Private Sub Worksheet_Deactivate() If Sheet1.Name &lt;&gt; "Summary" Then Sheet1.Name = "Summary" End Sub 将第一个工作表名称修改为123，激活第二工作表（触发Worksheet_Deactivate事件）或者在第一个工作表中选中其他单元格（非当前活动单元格，触发Worksheet_SelectionChange事件），那么第一个工作表名称将自动恢复为Summary。
虽然不是完美解决方案，但是应该可以满足多数应用场景的需求，如果大家有更好的解决方法，欢迎评论留言。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8a8efb155f1c00f0092cc2e2b3b623a/" rel="bookmark">
			java中井号字符串_深入Java基础（二）——字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这段时间在准备找一份java实习工作，所以来把基础知识整理归纳一下
文章结构：
1.equals和==
2.字符串的基本知识以及字符串的源码解读；
3.字符串的注意点以及使用推荐；
一、equals和==
概述：
1、 ==对于基本类型是比较其值，对于引用类型是比较地址，地址也可以是一个基本类型的值，因此可认为就是比较值的。
2、equals只能用于对象的比较，是所有类的一个基本方法。如果用equals来比较基本类型的变量是有语法错误的，equals只是比较对象的内容。
1 public classCompareTest {2 public static voidmain(String[] args){3 int t1=30;4 int t2=90;5 int t3=120;6 int t4=120;7 Boolean result1=(t1==t2); //验证不同值的比较是否相等
8 Boolean result2=((t1+t2)==t3); //验证基本数据类型只要数值相等即相等
9 Boolean result3=(t3==t4); //验证基本数据类型直接相等即相等
10
11 System.out.println("--【t1==t2】"+result1+"-----【(t1+t2)=t3】"+result2+"-----【t3=t4】"+result3);12
13 //另外博主验证过了，只要在Integer缓存大小(-128-127)以内，只要数值相等，还是相等的。觉得大家应该动手试下这个就不贴太多出来了。
14 Integer s1 = Integer.valueOf(t1); //把基本数据类型传递给Integer包装类构建成对象
15 Integer s2 =Integer.valueOf(t2);16 Integer s3 =Integer.valueOf(t3);17 Integer s4 =Integer.valueOf(t4);18 Integer s5 = Integer.valueOf(130);19 Integer s6 = Integer.valueOf(130);20
21 Boolean b1 = ((s1+s2)==s3); //验证只要数值相等，还是相等的。即使它是一个Integer对象相加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8a8efb155f1c00f0092cc2e2b3b623a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1718b56694fd8bf62559a39dc27a814/" rel="bookmark">
			tmp在java中的意思_tmp是什么文件？tmp文件用什么打开？图文讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说明的是tmp文件是可以打开的，只是这个文件打开也没任何实际用处罢了。为什么这么说？这还要从tmp文件在windows系统中的功能将起：
tmp的名称由来是Temporary的缩写，是临时的意思。“.tmp”格式结尾的文件统称为临时文件，它是一种共享格式。很多的程序都会将自己的临时文件保存为tmp格式文件，通常情况下我们很难分辨出到底这个tmp文件是什么程序创建的。但有些时候通过tmp文件的名称结构可以发现一些痕迹，比如2011_annual_report.tmp这个tmp文件应该就是一份word、Excel或者PPT文档的年度报告了。
为什么要创建tmp文件？
程序会创建这个文件主要是用于备份的目的。比如你在word编辑一份文档，或者是处理一份密密麻麻的Excel时，每隔一段时间程序就会创建一个tmp文件(它看起来有点像某种缓存功能的样子)。不过当你工作完毕正常关闭程序后，程序会自动删除其创建的tmp文件。但是，如果你的程序意外关闭(强制关机、停电、意外等)那么这个tmp文件将会被保存下来。
通常它的位置在C:\Windows\Temp
tmp文件用什么打开？
在编写这篇文档的时候，穆童也打开了自己电脑的Temp目录，看看里面有多少tmp文件。结果我还是发现了几个：
于是我尝试着使用记事本来打开它(这里有个技巧，你无法直接双击打开，你可以打开一个记事本然后将它拖到记事本里就可以打开了)，结果打开后在记事本里出现了乱码，如下图：
记事本打开tmp文件出现乱码
虽然记事本打开tmp文件后出现了乱码，但至少也能显示一些内容。我觉得应该有更多的内容受到记事本功能的限制而没有显示出来，于是我用了上一篇介绍《php文件怎么打开》时推荐的UE编辑器来试了试：
ue编辑器打开tmp文件
如我所料，的确有更多的内容在UE中显示出来了，看到那一排排数字没？似乎是某种16进制的信息。而记事本中只显示了上图右边的乱码文字。
当然，我上面的这两个实例并不具备代表性，因为tmp文件是由各种各样的程序产生的各种不同内容的临时文件。不过方法可以参考，或许通过你的努力能从中发现很多意想不到的“秘密”
本文就先介绍到这里，虽然在“tmp文件用什么打开”这个问题上出现了些瑕疵，但至少是“打开”了，而关于“tmp是什么文件”的问题应该说清楚了，而更多更深层的信息相信将会从大家的探讨与总结中浮现出来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3639727239a23a495513220960caaa97/" rel="bookmark">
			岛屿数量JAVA_算法练习帖--54--岛屿数量(Java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		岛屿数量(DFS、BFS、并查集)
一、题目简介
给你一个由 ‘1’(陆地)和 ‘0’(水)组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
(题目来源：力扣(LeetCode))
示例 1：
输入：grid = [
["1","1","1","1","0"],
["1","1","0","1","0"],
["1","1","0","0","0"],
["0","0","0","0","0"]
]
输出：1
示例 2：
输入：grid = [
["1","1","0","0","0"],
["1","1","0","0","0"],
["0","0","1","0","0"],
["0","0","0","1","1"]
]
输出：3
提示：
m == grid.length
n == grid[i].length
1 &lt;= m, n &lt;= 300
grid[i][j] 的值为 '0' 或 '1'
二、解决方法
1.DFS算法(Depth First Search，深度优先搜索算法)
package com.lxf.graph;
public class DFS {
//小岛数组行长度
private int ir;
//小岛数组列长度
private int ic;
public int numIslands(char[][] grid){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3639727239a23a495513220960caaa97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed6417cccc91b4b893a6f68ac890f8fb/" rel="bookmark">
			mysql用户关注店铺表_求助微博关注用户表的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本帖最后由 anydy2008 于 2013-10-11 10:43:13 编辑
查询需求如下：
1.查询关注了哪些用户。
2.查询被哪些用户关注了。
3.查询和某个用户共同的关注列表。
4.查询是否互相关注。
用一个表，以 user_id follow_user_id add_time列的形式可以实现上述功能。
可是关注量比较大，需要按用户 id来分表。不知道怎样设计表结构好。
求助友友们，请多多给建议。 谢谢
回复讨论(解决方案)
以 用户id 来分区
用户ID吧，每个表之间都用用户id
以 用户id 来分区
版主 我是想用用用户id来分表，可是分表后上面的功能就不好实现了。比如我要查 哪些用户关注了我，分表后；我不确定要查哪个表。只有将所有分表都查一次才可以知道。
单独保存一个关注表
或者把关注你的用户也存到用户表里可行不？
正因为分表后不确定要查哪个表，所以不能分表而是分区
分区后的表对你而言依然是一个整表(虽然被分成了多个文件)，实际查询的是那个文件由mysql决定而不是你决定
如果你依然想自己分表，那么需要交换 user_id、follow_user_id 列的内容形成新表，再对两个表分表
以 用户id 来分区
版主 我是想用用用户id来分表，可是分表后上面的功能就不好实现了。比如我要查 哪些用户关注了我，分表后；我不确定要查哪个表。只有将所有分表都查一次才可以知道。
不要分表呀，直接写sql语句就可以了
1.查询关注了哪些用户：select `follow_user_id` from `表` where `user_id`='你的id'
2.查询被哪些用户关注了：select `user_id` from `表` where `follow_user_id`='你的id'
3.查询和某个用户共同的关注列表。select * from `表` where `user_id` in ('你的id', '某个用户id')
4.查询是否互相关注:select * from `表` where `user_id`='你的id' and `follow_user_id`='某个用户id' `user_id` in (select `follow_user_id` from `表` where `user_id`='某个用户id')
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed6417cccc91b4b893a6f68ac890f8fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550e3a0070b218c0bcdf13f207651868/" rel="bookmark">
			java占用物理内存不释放_JMeter内存溢出：java.lang.OutOfMemoryError: Java heap space解决方法(实测有效)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题原因
用JMeter压测，有时候当模拟并发请求较大或者脚本运行时间较长时，JMeter会停止，报OOM(内存溢出)错误。
原因是JMeter是一个纯Java开发的工具，内存由java虚拟机JVM管理，当内存回收不及时，堆内存不足时，就会报内存溢错误。
概念补充：
内存泄露：应用使用资源之后没有及时释放，导致应用内存中持有了不需要的资源。
内存溢出：应用的内存已经不能满足正常使用了，堆栈已经达到系统设置的最大值，进而导致崩溃。
通常都是由于内存泄露导致堆栈内存不断增大，从而引发内存溢出。
对JMeter而言也是如此，JMeter测试过程中，如果内存溢出的话，一般会出现上图中的提示：java.lang.OutOfMemoryError: Java heap space：意思就是堆内存溢出，不够用了
二、解决方法
知道了报错出现的原因是因为堆内存大小不足引起的，自然而然就会想到内存溢出的解决方法：调整堆内存大小。
步骤(以Windows系统为例，Linux系统类似)：
1、打开jmeter.bat文件，按关键字“HEAP”搜索，把原来的配置改为如下：
修改前：
ifnotdefinedHEAP (
rem Seethe unix startup file forthe rationale of the following parameters,
rem including some tuning recommendations
setHEAP=-Xms1g-Xmx1g-XX:MaxMetaspaceSize=256m
)
修改后：
ifnotdefinedHEAP (
rem Seethe unix startup file forthe rationale of the following parameters,
rem including some tuning recommendations
setHEAP=-Xms512m-Xmx4000m
setNEW=-XX:NewSize=256m-XX:MaxNewSize=512m
)
setHEAP=-Xms512m-Xmx4000m：调整堆内存的大小
setNEW=-XX:NewSize=256m-XX:MaxNewSize=512m：调整堆内存中新生带的大小
注意：
这个值不是越大越好，要根据压测使用的机器而定，一般而言，堆内存的最大值不要超过物理内存的一半，否则容易导致jmeter运行变慢、
卡顿甚至内存溢出(因为java本身的垃圾回收机制是动态分配内存，调整的时候其本身会占用很多内存)，NEW分配的内存，不宜太大。
2、修改完成后保存，重启JMeter，即可生效。
三、小结
1、这种修改堆大小的方法只适用一部分情况，并不是万能的，当需要模拟的线程数较大时，就需要根据具体情况采用分布式压测的方式了。
2、命令行运行JMeter时，一定要禁用“查看结果树”、“聚合报告”等监听器，因为真的真的真的很消耗内存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5d87bcc547c39078478d5c611ae362b/" rel="bookmark">
			蓝桥杯——练习（2.27）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蓝桥杯——练习（2.27） 基础练习 特殊回文数 题目链接：http://lx.lanqiao.cn/detail.page?submitid=5515856
资源限制 时间限制：1.0s 内存限制：512.0MB
问题描述 123321是一个非常特殊的数，它从左边读和从右边读是一样的。
输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。
输入格式 输入一行，包含一个正整数n。
输出格式 按从小到大的顺序输出满足条件的整数，每个整数占一行。
样例输入 52
样例输出 899998
989989
998899
数据规模和约定 1&lt;=n&lt;=54。
解题思路 分析本题目，特殊回文数就是从左边读和从右边读都是一样的。
题目要求输出所有的这样的五位和六位十进制数。
可以利用枚举来进行判断是否符合题目要求，用n表示输入的数，也就是各位数的和为n。
left表示左边部分，right表示右边部分，数组a存放数据的每一位数，Num表示每次的数，用变量t来存放每一次的Num值。
先判断t是五位数还是六位数，如果是五位数，将t的每一位取出放到a中，然后判断每位的和是否与n相等，如果和n相等，left=a[0]*10+a[1];right=a[4] *10+a[3]，接着判断left与right是否相等，相等则输出Num；
如果是六位数，将每一位放到a中，判断六位的和是否与n相等，如果相等，left=a[0] * 100+a[1] * 10+a[2]，right=a[5] * 100+a[4] * 10+a[3];如果left与right相等，输出Num的值。
代码 #include&lt;iostream&gt; using namespace std; int main() { int n,left,right,i; int t=0; int Num=10000; int a[6]; cin&gt;&gt;n; for(Num;Num&lt;1000000;Num++) { i=0; t=Num; if(t&lt;100000) { while(t) { a[i++]=t%10; t/=10; } if(a[0]+a[1]+a[2]+a[3]+a[4]==n) { left=a[0]*10+a[1]; right=a[4]*10+a[3]; if(left==right) { cout&lt;&lt;Num&lt;&lt;endl; } } } else { while(t) { a[i++]=t%10; t/=10; } if(a[0]+a[1]+a[2]+a[3]+a[4]+a[5]==n) { left=a[0]*100+a[1]*10+a[2]; right=a[5]*100+a[4]*10+a[3]; if(left==right) { cout&lt;&lt;Num&lt;&lt;endl; } } } } return 0; } 视频学习——使用sort排序练习 视频链接：https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5d87bcc547c39078478d5c611ae362b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13878273929d064aa14675f17bcf372/" rel="bookmark">
			java双下划线改单下划线_单下划线与双下划线的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容目录
单下划线与双下划线的区别
​ Python用下划线作为前缀和后缀指定特殊变量和定义方法，主要有如下四种形式：
单下划线(_)
名称前的单下划线(如：_name)
名称前的双下划线(如：__name)
名称前后的双下划线(如:_ init _)
单下划线(_)
​ 只有单划线的情况，主要有两种使用场景：
​ 1、在交互式解释器中，单下划线“_”代表的是上一条执行语句的结果。如果单下划线前面没有语句执行，交互式解释器将会报单下划线没有定义的错误。也可以对单下划线进行赋值操作，这时单下划线代表赋值的结果。但是一般不建议对单下划线进行赋值操作，因为单下划线内建标识符。
"", line 1, in '_' is not defined
"python"
'python'
'python'
"Java"
'Java'
2、单下划线“_”还可以作为特殊的临时变量。如果一个变量在后面不会再用到，并且不想给这个变量定义名称，这时就可以用单下划线作为临时性的变量。比如对for循环语句遍历的结果元素并不感兴趣，此时就可以用单下划线表示。
# _ 这个变量在后面不会用到
for _ in range(5):
"Python")
名称前的单下划线(如：_name)
​ 当在属性和方法前面加上单下划线“_”，用于指定属性和方法是“私有”的。但是Python不像Java一样具有私有属性、方法、类，在属性和方法之前加单下划线，只是代表该属性、方法、类只能在内部使用，是API中非公开的部分。如果用from import * 和 from import * 时，这些属性、方法、类将不被导入。
# Test.py 文件
#普通属性
"Java"
#单下划线属性
"Python"
#普通方法
def method():
"我是普通方法")
#单下划线方法
def _otherMethod():
"我是单下划线方法")
#普通类
class PClass(object):
def __init__(self):
"普通类的初始化")
#单下划线类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b13878273929d064aa14675f17bcf372/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/533770a7a378fdb9345f4fdc42cad9c0/" rel="bookmark">
			数字涂色游戏代码JAVA_CCF签到汇总（JAVA版本,2013-12~2018-12）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CCF签到题，没有提到分数的题目都是100分，不然会额外提出，样例输入都单独文本复制粘贴了，这样你们测试的时候很方便粘贴用例，不用自己手敲，都是一些签到题。但有好的基础，会多的数据结构，好的数学思想，那么这些都是一些很简单的问题。因为java版本不多，所以仅供参考，以下代码的思路都很简单，很多都直接通过题目面向过程，有更好的想法，或者你我有些题没有满分的改进方式都可以交流。
CCF300分的线，1、2题需要拿满，最低也要190，第三题是理解题，很多时候考你的语文能力更多，第四题是规律性更强的题，涉及图论算法众多(最小生成树3题，通信网络，最优灌溉，数据中心，地铁修建)(最短路径4题，最优匹配，无线网络，交通规划，游戏)(欧拉图，强连通分支，最长路径也都考过),还有正则匹配的题(5题url映射，json查询，markdown，模板生成系统，字符中匹配)，总而言之一句话，第4题规律性很强。你只需要1、2题拿满，第4题拿90，第五题和第三题通过理解之后，暴力得分，就能稳300分以上，不排除某年的题会难、杂，或者当年当月你不在巅峰，那就下一次再考，上面列举的题型出现的频率极高，针对1、2、4刷题性价比是最高的。
下面只提供了第一题和第二题，因为在线测试对java语言不太友好，导致我的3、4题分数参差不齐，所以没有提供代码，网上有众多优秀的博客，输入试题编号和名称即可找到，看看思路，自己再写一遍，算法之路，任重道远。(数学很重要，数学是编程的降维武器)
试题编号：201312-1
试题名称：出现次数最多的数
样例输入
6
10 1 10 20 30 20
样例输出
10
思路：解决方法有很多，要么空间够大开够，用下标去加加计数，或者用hashset一直塞，重复会返回default，然后default就对应加加，用indexof找，唯一值，还可以用一个数组，在插入时注意排序，因为需要输出最小值，插入时就排好序，重复的就加加次数，总之方法很多。
importjava.util.Scanner;public classCCF201312_1 {public static voidmain(String[] args) {
Scanner sc=newScanner(System.in);int n=sc.nextInt();int[] space=new int[n];for(int i=0;i
space[i]=sc.nextInt();
}int[] flag=new int[10000];for(int i=0;i
flag[space[i]]++;
}int max=0;int index=0;int finded=0;for(int i=0;i&lt;10000;i++) {if(flag[i]!=0) {
finded=finded+flag[i];
}if(flag[i]&gt;max) {
max=flag[i];
index=i;
}if(finded==n) {break;
}
}
System.out.println(index);
}
}
试题编号：201312-2
试题名称：ISBN号码
样例输入
0-670-82162-0
样例输出
0-670-82162-4
思路：问题描述中已经有具体步骤了，对于格式统一，下标固定的问题，基本数据结构掌握就可以解决。
importjava.util.Scanner;public classCCF201312_2 {public static voidmain(String[] args) {
Scanner sc= newScanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/533770a7a378fdb9345f4fdc42cad9c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/877989fc8319572b2d947db5598a2db8/" rel="bookmark">
			邓俊辉数据结构java pdf_清华大学计算机系列教材:数据结构(C&#43;&#43;语言版)(第3版) PDF扫描版[19MB]...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		清华大学计算机系列教材:数据结构(C++语言版)(第3版)习题解析涵盖验证型、拓展型、反思型、实践型和研究型习题，总计290余道大题、525道小题，激发读者的求知欲，培养自学能力和独立思考习惯。主教材和习题解析共计配有340多组、400余幅插图结合简练的叙述，40多张表格列举简明的规范、过程及要点，280余段代码及算法配合详尽而简洁的注释，使深奥抽象的概念和过程得以具体化且便于理解和记忆；推荐20余册经典的专著与教材，提供40余篇重点的学术论文，便于读者进一步钻研和拓展。
数据结构(C++语言版)(第3版) 目录：
第1章 绪论
1.1 计算机与算法
1.2 复杂度度量
1.3 复杂度分析
1.4递归
1.5 抽象数据类型
第2章 向量
2.1 从数组到向量
2.2 接口
2.3 构造与析构
2.4 动态空间管理
2.5 常规向量
2.6 有序向量
2.7排序与下界
2.8 排序器
第3章 列表
3.1 从向量到列表
3.2 接口
3.3 列表
3.4 有序列表
3.5 排序器
第4章 栈与队列
4.1 栈
4.2 栈与递归
4.3 栈的典型应用
4.4试探回溯法
4.5 队列
4.6 队列应用
第5章 二叉树
5.1 二叉树及其表示
5.2 编码树
5.3 二叉树的实现
5.4 遍历
5.5 Huffmann 编码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/877989fc8319572b2d947db5598a2db8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a81b82e69a5e854a97c776214dea3a6/" rel="bookmark">
			python爬虫模拟百度翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python爬虫模拟百度翻译 案例目的： 通过模拟百度翻译，介绍携带form表单发送post请求以及破解form表单中的加密数据，以及介绍通过pycharm执行js代码。
案例实现功能： 模拟百度翻译，实现中英互译。
爬取过程分析： 找到目标的url，注意，这里的url是指对应的response为翻译结果的url。而非首页的url。如下图：
检查响应结果： 对比翻译不同内容的表单数据，如下图： 对比翻译不同内容对应表单上发生变化的数据，可以发现表单发生变化的数据为： 1.参数query：为要被翻译的内容
2.参数sign：待分析
剩下其他的参数未发生变换，因此在发送请求时，直接复制到form表单即可。
对参数sign进行分析： 在search中搜索sign参数，返现参数sign对应的为函数f(e)，将鼠标左键放在函数f(e)上，可以找到函数所在的位置。
点击之后，找到函数f(e)的位置如下： 这里说明一下，如何使用函数f(e)来得到sign参数： 由于sign参数的值为e函数，且js函数定义的逻辑比较复杂，我们可以直接通过在pycharm创建js文件，执行js函数，我们直接使用函数的返回值即可。
经过创建在pycharm创建javascript文件执行e函数，但在执行python代码时发现e函数中缺少参数i和参数n。因此我们需要解决如何得到参数i和n的问题。
首先，找到参数i如下： 经过调试发现，i的值与u的值带相同，且i为定值，因此对于参数i的解决方法为：将在函数e中定义i的中即var i = 320305.131321201
其次，找到参数n所在位置为函数n 点击找到函数n的位置 我们找到函数n，在函数e的上方。
对于参数n的解决方法：将函数n同样复制在javascript文件函数e上方执行。我们直接使用js代码的返回值即可。
解析响应的方法： 通过在线json在分析，对response数据进行解析。得到jsonpath语法（$…dst）
注意事项： 1.表单数据中的参数from为zh，参数to为en，意为中译英，而英译中是无法完成的，因此需要通过添加if条件语序。即当输入为英文，翻译成中文。从而完成中英互译
2.我们创建的Javascript文件以及函数f(e)，f(n)。需要通过在python代码中打开文件，执行代码后才能获得函数中的返回值，从而得到参数sign。
3.我们可以通过在程序入口处加上while死循环，可以让翻译一直进行，避免手动执行。
4.本次案例为post请求，重在于表单数据参数的解析。
所有问题分析完毕，上代码： 代码一： 代码一为js代码，需要创建JavaScript文件。（注：需要通过在代码二中打开文件，并执行，打开和执行见代码二。从而得到其返回值。）
function n(r, o) { for (var t = 0; t &lt; o.length - 2; t += 3) { var a = o.charAt(t + 2); a = a &gt;= "a" ? a.charCodeAt(0) - 87 : Number(a), a = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a81b82e69a5e854a97c776214dea3a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e8ed260712290afff6756d8ea932d32/" rel="bookmark">
			Vue深入-23【Vue3.0源码重写『数据劫持』】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(1).了解VUE3源码管理方式、独立使用reactivity、搭建项目 1.了解VUE3源码管理方式、独立使用reactivity npm init -y npm i @vue/reactivity -D src
index.js
这样就变成了响应式data 是基于proxy做的代理
import {reactive} from '@vue/reactivity'; const state = reactive({ name:'zza', info:{ job:'teacher', student:[ { id:1, name:'小张' } ] }, hobby:['pinao','travel','film'] }) npm i webpack@4.44.1 webpack-cli@3.3.12 webpack-dev-server@3.11.0 yarn add html-webpack-plugin@4.4.1 webpack.config.js
const path = require('path'), HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports={ entry:'./src/index.js', output:{ filename:'bundle.js', path:path.resolve(__dirname,'dist') }, devtool:'source-map', resolve:{ modules:[path.resolve(__dirname,''),path.resolve(__dirname,'node_modules')] }, plugins:[ new HtmlWebpackPlugin({ template:path.resolve(__dirname,'public/index.html') }) ] } package.json
"scripts": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e8ed260712290afff6756d8ea932d32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ef947119b41f647ff2e1d09f93207fb/" rel="bookmark">
			java新建一个标签_Java创建标签时的JavaFX 11：IllegalAccessError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题可能是同一个问题的这一个，但现在看来，一个的提问者还没有添加足够的信息来获得一个有用的响应。
我正在尝试使用JDK和JavaFx SDK版本11.0.2运行JavaFx应用程序。
此代码完全按预期工作，从而产生一个空窗口：
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;
public class Main extends Application {
public void start(Stage primaryStage) throws Exception {
StackPane root = new StackPane();
primaryStage.setScene(new Scene(root, 420, 420));
primaryStage.show();
}
public static void main(String[] args) {
launch(args);
}
}
但是，如果我尝试向添加标签StackPane，则会引发异常。
import ...
import javafx.scene.control.Label;
public class Main extends Application {
public void start(Stage primaryStage) throws Exception {
StackPane root = new StackPane();
root.getChildren().add(new Label("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ef947119b41f647ff2e1d09f93207fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48c4e6553d845e2326f529d0222dfa5/" rel="bookmark">
			java原生项目什么意思_什么是ABA问题？java里面的原生解决方案是什么？原理是什么？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AtomicStampedReference是一个带有时间戳的对象引用，能很好的解决CAS机制中的ABA问题，这篇文章将通过案例对其介绍分析。
一、ABA问题
ABA问题是CAS机制中出现的一个问题，他的描述是这样的。我们直接画一张图来演示，
什么意思呢？就是说一个线程把数据A变为了B，然后又重新变成了A。此时另外一个线程读取的时候，发现A没有变化，就误以为是原来的那个A。这就是有名的ABA问题。ABA问题会带来什么后果呢？我们举个例子。
一个小偷，把别人家的钱偷了之后又还了回来，还是原来的钱吗,ABA问题也一样，如果不好好解决就会带来大量的问题。最常见的就是资金问题，也就是别人如果挪用了你的钱，在你发现之前又还了回来。但是别人却已经触犯了法律。
如何去解决这个ABA问题呢，就是使用今天所说的AtomicStampedReference。
二、AtomicStampedReference
1、问题解决
我们先给出一个ABA的例子，对ABA问题进行场景重现。
public class AtomicTest{
private static AtomicInteger index = new AtomicInteger(10);
public static void main(String[] args){
new Thread(() -&gt; {
index.compareAndSet(10, 11);
index.compareAndSet(11, 10);
System.out.println(Thread.currentThread().getName()+
"：10-&gt;11-&gt;10");
},"张三").start();
new Thread(() -&gt; {
try {
TimeUnit.SECONDS.sleep(2);
boolean isSuccess = index.compareAndSet(10, 12);
System.out.println(Thread.currentThread().getName()+
"：index是预期的10嘛，"+isSuccess
+" 设置的新值是："+index.get());
} catch (InterruptedException e) {
e.printStackTrace();
}
},"李四").start();
}
}
在上面的代码中，我们使用张三线程，对index10-&gt;11-&gt;10的变化，然后李四线程读取index观察是否有变化，并设置新值。运行一下看看结果：
这个案例重现了ABA的问题场景，下面我们看如何使用AtomicStampedReference解决这个问题的。
public class AtomicTest2{
private static AtomicInteger index = new AtomicInteger(10);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b48c4e6553d845e2326f529d0222dfa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7095b22b83b9c4c5185f377bbf912585/" rel="bookmark">
			tomcat java 11_Tomcat系列(11)——Tomcat 部署web应用的4种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核心内容
1.在Tomcat中有四种部署Web应用的方式，分别是：
(1)利用Tomcat自动部署(项目直接拷贝OR WAR包拷贝 到webapps下)
(2)利用控制台进行部署(tomcat的manager控制台的deploy区域)
(3)增加自定义的Web部署文件(%Tomcat_Home%\conf\Catalina\localhost\AppName.xml)
(4)手动修改%Tomcat_Home%\conf\server.xml文件来部署web应用
2.SpringBoot WEB项目两种发布和部署方式
(1)通过WAR包
(2)通过JAR包(官网推荐)
3.springboot有3中热部署方式：
(1)使用springloaded配置pom.xml文件，使用mvn spring-boot:run启动
(2)使用springloaded本地加载启动，配置jvm参数 -javaagent: -noverify
(3)使用devtools工具包，操作简单，但是每次需要重新部署
1. Tomcat中有四种部署Web应用的方式
第一种方式：利用Tomcat自动部署
利用Tomcat自动部署方式是最简单的、最常用的方式。若一个web应用结构为D:\workspace\WebApp\AppName\WEB-INF\*，只要将一个Web应用的WebContent级的AppName直接扔进%Tomcat_Home%\webapps文件夹下，系统会把该web应用直接部署到Tomcat中。所以这里不再赘述。
第二种方式：利用控制台进行部署
若一个web应用结构为D:\workspace\WebApp\AppName\WEB-INF\*，利用控制台进行部署的方式如下：进入tomcat的manager控制台的deploy区域——在Context path中键入"XXX"(可任意取名)——在WAR or Directory URL：键入D:\workspace\WebApp\AppName (表示去寻找此路径下的web应用)——点击deploy按钮。
然后在%Tomcat_Home%\webapps路径下将会自动出现一个名为XXX的文件夹，其内容即是D:\workspace\WebApp\AppName的内容，只是名字是XXX而已(这就是前面在Context path键入XXX的结果)。
以上说明利用控制台进行部署的实质仍然是利用Tomcat的自动部署。
第三种方式：增加自定义的Web部署文件
若一个web应用结构为D:\workspace\WebApp\AppName\WEB-INF\*，这种部署方式稍微复杂一点，我们需要在%Tomcat_Home%\conf路径下新建一个文件夹catalina——再在其中新建一个localhost文件夹——最后再新建一个XML文件，即增加两层目录并新增XML文件：%Tomcat_Home%\conf\Catalina\localhost\web应用配置文件.xml ，该文件就是部署Web应用的配置文件。
例如，我们新建一个%Tomcat_Home%\conf\Catalina\localhost\XXX.xml， 该文件的内容如下：
注意： (1)以上代码中的workDir表示将该Web应用部署后置于的工作目录(Web应用中JSP编译成的Servlet都可在其中找到)，如果使用的Eclipse作为IDE，一般可人为设置在WebApp的work目录下。 如果自定义web部署文件XXX.xml中未指明workdir，则web应用将默认部署在%Tomcat_Home%\work\Catalina\localhost\路径下新建的以XXX命名的文件夹下。(Web应用中JSP编译成的Servlet都可在其中找到) (2)Context path即指定web应用的虚拟路径名。docBase指定要部署的Web应用的源路径。
其实开发者可以使用安装有Tomcat插件eclipse自动创建部署文件来部署Web应用而不必再手动建立该文件，方法如下：
1. 打开Eclipse——打开菜单栏window选择preference(首选项)——左侧选择Tomcat，如下图示：
2. 可以看到上图中高亮画出的Context declaration mode(Context 声明模式)中选择以Context files增加自定义部署文件的形式部署web应用——然后Contexts directory中指定上述文件的上级目录(即%Tomcat_Home%\conf\Catalina\localhost)——点击Apply或OK。
3. 完上述步骤，再选中Web项目右键点击properties(属性)——选择右侧的Tomcat ，如下图所示：
4. 勾上"Is a Tomcat project"前的checkbox，将项目关联至Tomcat。
在Context name中填入XXX，即Web应用自定义部署文件名和Context path名。
在Subdirectory to set as web application root (optional)中填入要部署的Web应用的实际路径(即WEB-INF上级目录)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7095b22b83b9c4c5185f377bbf912585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a556a8c307d9782d2548b9919af536/" rel="bookmark">
			Centos的环境变量的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大部分程序在使用二进制安装后,需要添加环境变量,方便后面进行快捷操作,下面我总结下centos中环境变量的位置
centos的环境变量配置是层级结构的
/etc/profile 影响的是全局,所有的用户
/etc/environment 影响全局,他与profile是有区别他是系统的环境,与用户无关
/etc/bash_profile 影响当前用户,属于首选
/etc/bashrc 影响所有用户的bash shell
~/.bashrc 影响当前终端
export PATH=/usr/***/***:$PATH 这里需要注意的重重之重PATH后面$PATH否则覆盖就会出现问题,请慎重
export PATH=$PATH:/usr/local/erlang/bin 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/089b2133215d30079b9f54a159f1da1d/" rel="bookmark">
			java http post数组参数_post请求参数Json字符串包含数组的校验和处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遍历importjava.io.BufferedReader;importjava.io.IOException;importjava.io.InputStream;importjava.io.InputStreamReader;importjava.io.PrintWriter;importjava.util.HashMap;importjava.util.Map;importorg.apache.log4j.Logger;importjavax.servlet.ServletException;importjavax.servlet.http.HttpServlet;importjavax.servlet.http.HttpServletRequest;importjavax.servlet.http.HttpServletResponse;importcom.alibaba.fastjson.JSON;importcom.alibaba.fastjson.JSONArray;importcom.alibaba.fastjson.JSONObject;importcom.xxx.live.core.util.others.ConfigUtil;importcom.xxxx.live.webapp.util.HttpClientUtil;importcom.xxxx.mobilevideo.core.util.StringUtil;/*** Servlet implementation class CloudCutStreamServlet*/
public class CloudCutStreamServlet extendsHttpServlet {private static final long serialVersionUID = 1L;
Logger log= Logger.getLogger(RecordFinishServlet.class);/***@seeHttpServlet#HttpServlet()*/
publicCloudCutStreamServlet() {super();
}/***@seeHttpServlet#doGet(HttpServletRequest request, HttpServletResponse
* response)*/
protected voiddoGet(HttpServletRequest req, HttpServletResponse resp)throwsServletException, IOException {//TODO Auto-generated method stub
this.doPost(req, resp);
}/***@seeHttpServlet#doPost(HttpServletRequest request, HttpServletResponse
* response)*/
protected voiddoPost(HttpServletRequest req, HttpServletResponse resp)throwsServletException, IOException {
//1.校验参数
JSONObject resultMap = this.getResutltMap(req);if (null ==resultMap) {
response(resp, getMsg(false, "请求参数格式不正确", "10002"));return;
}
String liveName= resultMap.getString("liveName");
String masterUrl= resultMap.getString("masterUrl");
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/089b2133215d30079b9f54a159f1da1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b797eda207da611ec2b1832aa7a8f2e8/" rel="bookmark">
			resourse rest java_java – 使用RepositoryRestResource注释来更改RESTful端点不工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是春天开机的新手.我正在尝试创建也插入MongoDB的RESTful Web服务.
一切都可以正常工作,除此之外,指导说明.
package hello.requests;
import java.util.List;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;
import hello.models.CustomerModel;
@RepositoryRestResource(collectionResourceRel = "people", path = "people")
public interface CustomerRepository extends MongoRepository {
List findByLastName(@Param("name") String name);
}
在这里,我尝试将存储库的RESTful端点从默认的/ customerModels更改为/ people.但是,当我运行这个,我得到404,如果我尝试/人,但适用于/ customerModels.
在更广泛的意义上,@RepositoryRestResource如何工作？
我在这里做错了什么？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e057ebff5767d5208c1733fbc339b892/" rel="bookmark">
			JAVA打开路径下的word文档_用java打开paf、word..文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-使用 Runtime.getRuntime().exec("C:\\Program Files (x86)\\Adobe\\Reader 11.0\\Reader\\AcroRd32.exe E:\\11.pdf");就可以
前面为打开文件的程序路径、后面为文件的路径。
2-jsp上显示pdf
01.
02.pageEncoding="ISO-8859-1"%&gt;
03.
04.String path =request.getContextPath();05.String basePath = request.getScheme() + "://"
06. + request.getServerName() + ":" +request.getServerPort()07. + path + "/";08.%&gt;
09.10.
11.
12.
13. 14.
15.
16. out.clear();17. out =pageContext.pushBody();18. response.setContentType("application/pdf");19.20. try{21. String strPdfPath = new String("D://200701010001.PDF");22. //判断该路径下的文件是否存在
23. File file = newFile(strPdfPath);24. if(file.exists()) {25. DataOutputStream temps = newDataOutputStream(response26. .getOutputStream());27. DataInputStream in = newDataInputStream(28. newFileInputStream(strPdfPath));29.30. byte[] b = new byte[2048];31. while ((in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e057ebff5767d5208c1733fbc339b892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/688eec1e4b1cacdc762a5e8633fd3623/" rel="bookmark">
			mysql8初始密码更换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mysql8初始化密码更换 mysql -u root -p # 输入登录密码 #使用mysql数据库 USE mysql # 更改新密码 ALTER USER 'test'@'localhost' IDENTIFIED WITH MYSQL_NATIVE_PASSWORD BY '新密码'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5b19a239d93bc5c7b21a8858cdaa8de/" rel="bookmark">
			Mysql中获取行号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql中是没有获取行号的函数的，但是我们可以通过定义变量来获取行号下面就举个简单的例子。
表中数据如下所示：
接下来对价格‘price’进行排序标记行号，sql如下：
SELECT @rownum:= @rownum + 1 AS rownum, trade_name, price FROM (SELECT @rownum := 0) t,`t_commodity_information` ORDER BY price DESC; 查询结果如下所示：
可以看到，已经对查询出来的数据标记了行号。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/325/">«</a>
	<span class="pagination__item pagination__item--current">326/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/327/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>