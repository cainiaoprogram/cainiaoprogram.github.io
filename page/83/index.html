<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b5cbe5991c22382f1ed30f96428e0d6/" rel="bookmark">
			Brew包的基本安装（手把手教学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家在使用mac或者linux系统的过程中，大致了解Homebrew的用处，不多说直接进入正题
相信大家已经看到了Homebrew官网的安装介绍了，我们依然使用终端（不去下载应用过于麻烦）
一、开始安装 在按照官网安装时发现会安装失败，是因为国内源的访问限制导致无法安装访问
所以推荐大家使用国内大学在码云分享的homebrew：
1. 打开终端，输入一下命令 /bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)" 2. 确定下载源，选择阿里巴巴下载源 3. Homebrew已经安装成功后，配置国内源 同上我们继续选择阿里巴巴国内源
4. 安装完毕后，切换国内源 安装配置完毕后，页面会有提示运行以下命令或者重启终端：source ***地址，国内地址生效可通过以下brew命令查看是否安装成功 5. 开始使用 多余的一个节点，到这步已经可以下载起来了，gogogo
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea6de4c90ca486355af23bfe72d890a/" rel="bookmark">
			Ubuntu - 查看 IP 地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要查看 Ubuntu 操作系统中的 IP 地址，可以使用 ip 命令或者 ifconfig 命令。以下是使用这两个命令的示例：
使用 ip 命令： 打开终端。
输入以下命令：
ip a
这将显示网络接口信息，包括 IP 地址。通常，IPv4 地址显示在 “inet” 字段下，而 IPv6 地址显示在 “inet6” 字段下。
例如，IPv4 地址可能看起来像这样：
inet 192.168.1.100/24 brd 192.168.1.255 scope global dynamic enp0s3
使用 ifconfig 命令： 打开终端。
输入以下命令：
ifconfig
这将列出所有网络接口的详细信息，包括 IP 地址。通常，IPv4 地址显示在 “inet addr” 字段下。
例如，IPv4 地址可能看起来像这样：
inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0
实际的 IP 地址具体取决于网络配置。如果使用的是无线网络，可能会有不同的网络接口名称，如 “wlan0”。
ifconfig命令：Command ‘ifconfig’ not found 问题解决 安装网络工具
安装完毕
再次 执行命令即可
ifconfig 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e69b100403e50f9c063d5d3bf34eba2b/" rel="bookmark">
			【23种设计模式】装饰器模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：金鳞踏雨
个人简介：大家好，我是金鳞，一个初出茅庐的Java小白
目前状况：22届普通本科毕业生，几经波折了，现在任职于一家国内大型知名日化公司，从事Java开发工作
我的博客：这里是CSDN，是我学习技术，总结知识的地方。希望和各位大佬交流，共同进步 ~
使用组合替代继承，对原生对象的方法做增强，增加新的行为和能力。
一、实现原理 装饰器设计模式（Decorator）是一种结构型设计模式，它允许动态地为对象添加新的行为。它通过创建一个包装器来实现，即将对象放入一个装饰器类中，再将装饰器类放入另一个装饰器类中，以此类推，形成一条包装链。
在不改变原有对象的情况下，动态地添加新的行为或修改原有行为。
代码实现 1、定义一个接口或抽象类，作为被装饰对象的基类。
public interface Component { void operation(); } 在这个示例中，我们定义了一个名为 Component 的接口，它包含一个名为 operation 的抽象方法，用于定义被装饰对象的基本行为。
2、定义一个具体的被装饰对象，实现基类中的方法。
public class ConcreteComponent implements Component { @Override public void operation() { System.out.println("ConcreteComponent is doing something..."); } } 在这个示例中，我们定义了一个名为 ConcreteComponent 的具体实现类，实现了 Component 接口中的 operation 方法。
3、定义一个抽象装饰器类，继承基类，并将被装饰对象作为属性。
public abstract class Decorator implements Component { // 装饰器设计模式 使用组合的形式进行装饰 protected Component component; public Decorator(Component component) { this.component = component; } @Override public void operation() { component.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e69b100403e50f9c063d5d3bf34eba2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ef35c7aec92fc04729ed9c90373a22f/" rel="bookmark">
			xml文件报错 ORA-00907: 缺失右括号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原来的sql
更改之后
加一个select * from （）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/347ae370d645b4654ee670b337e2c3dd/" rel="bookmark">
			矫正图片背景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在利用明场或荧光显微镜成像时，往往会由于样品厚度不一、镜头污渍或者光照不均等因素，降低图片质量，从而影响分析以及展示。
这篇文章就为大家介绍：怎样利用 ImageJ 对图片进行背景校正，包括两个方面：白平衡以及平场校正。
一、白平衡 白平衡（White Balance），在数码摄影中常常会遇到，在拍摄显微镜的明场图片时，更是值得关注的一点。
白色通常是指反射到人眼中的光线由于蓝、绿、红三种色光比例相同，且具有一定的亮度所形成的视觉反应。
对应在 RGB 彩色图片上，即 RGB 图片的三个通道（Red, Green, Blue）的灰度值大小相近。下图这个立方体很好地解释了 RGB 色彩模式，当 R,G,B 三个通道的灰度值都为 255 时，呈白色：
但在实际利用显微镜拍照的过程中（例如对细胞进行明场拍照），因为培养基本身的颜色等因素的影响，拍摄的照片往往不显白色，有不同颜色的偏向，即 RGB 三个通道的灰度值差别很大。
如下图，是利用倒置像差显微镜拍摄的细胞，图片整体偏黄。
1.将 RGB 图片变成三种颜色通道的 Stack（Image -&gt; Color -&gt; Make Composite）。 这一步将 RGB 图像分解成 R, G, B 三个通道的堆栈（Stack），每个通道为 8-bit 图像。但这时并不能看到单色的图片。
2.利用 Channels Tool 调出单一颜色通道（Image -&gt; Color -&gt; Channels Tool）。 打开 Channels Tool，这时处于 Composite 模式，三个 Channel 全部勾选，Channel 1、2、3 分别对应 Red、Green、Blue。
选择 Color 模式，则可以查看单一颜色通道：
从这里可以明显看出 Red、Green 两个通道较亮，Blue 通道较暗。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/347ae370d645b4654ee670b337e2c3dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48f197ad61e2eb79c532e1f5de9df1cb/" rel="bookmark">
			web前端【3】JS基础-轮播图【JavaScript、定时器、鼠标动作、自动轮播、增加和减少li列表】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验题目: 轮播图
二、实验内容简介
1．整体布局：图片、左右按钮、数字列表、添加删除按钮
2、左右箭头滚动
3、小圆点滚动
4、自动轮播
5、鼠标动作：指向和离开
6、添加与删除
三、实验过程
1. 需求分析
整体布局：设计一个轮播图，中间部分为自动轮播的图片展示区域，每张图片的左上方显示图片的序号，左右箭头按钮用于切换图片，右下方小圆点数字列表用于导航到指定图片和显示当前展示图片的序号，且与显示的图片序号相同的小圆点按钮的背景颜色为红色。
在点击左右箭头按钮或小圆点按钮时，图片进行滚动且与滚动后的图片序号相同的小圆点按钮变为红色，当显示的图片为第一个时再按向左按钮时显示最后一个
图片。当鼠标移动到箭头时，鼠标图标变为手指。创建小圆点列表，用于显示当前图片的位置，并当单击小圆点时图片切换到对应的图片上。
自动轮播：一定时间间隔后向右变换一个图片，同时小圆点按钮向右变换为红色。在鼠标指向轮播图的区域时，轮播图将停止自动轮播，当鼠标离开时，轮播图接着当前状态继续自动轮播。
添加与删除：点击添加按钮时，轮播图增加一个图片和小圆点按钮、文本框显示的页数与添加后的红色小圆点序号相同。当增加到第九张时不再增加。点击“删减”按钮时，删除一个图片和小圆点按钮、文本框显示的页数与减少后的红色小圆点按钮相同。当减少的第二张时不再减少。
2．设计方案
（1）整体布局；
使用div布局，顶部、图片、内容、底部分别为一个div，中间部分为图片部分。在其中使用div布局图片左侧，图片中部，图片右侧，在图片右左侧部分用button加入按钮用于增加和删除图片，在图片中部用ul创建图片标签，并加入左右箭头滚动按钮，使用ul创建小圆点标签。
z-index针对网页显示中的一个特殊属性。因为显示器是显示的图案是一个二维平面，拥有x轴和y轴来表示位置属性。为了表示三维立体的概念如显示元素的上下层的叠加顺序引入了z-index属性来表示z轴的区别，表示一个元素在叠加顺序上的上下立体关系。设置z-index的值较大，可以相应地显示当前图片。
（2）左右箭头滚动：
清除所有图片的激活状态。因为图片的长度会根据增加或删除动态变化，所以需要在每次调用函数时，获取当前的图片数。循环遍历每张图片，设置图片和小圆点的样式，没有激活状态，则取消。
把当前图片的前一张设置为激活:当index=0，即为第一张图片时，修改index= imgs.length -1，即将图片设置为最后一张。否则index--，即为前一张图片。修改当前图片的和圆点的className，分别为"item imgShow”和“numnumShow"，使当前图叶显示和当前圆点背景颜色显示。
向右的箭头向右循环。操作与向左类似，当前图片为最后一张时，显示第一张图片。
(3)小圆点滚动：
单击小圆点，显示当前小圆点对应的图片，并且小圆点对应的背景色发生变化。
通过for循环遍历每一个小圆点，为其绑定单击事件。为了记录当前操作小圆点的序号，为其添加no属性，即nums[i].no=i。为每个小圆点绑定事件，nums[i].οnclick=function(){…}。使用clearActive函数清除小圆点和图片的激活状态，为当前操作的小圆点设置激活状态。“this.no”表示当前操作小圆点的序号，nums[this.no]表示当前操作小圆点，imgs[this.no]表示当前操作小圆点对应的图片。因为单击小圆点以后，继续单击向左向右按钮，图片应当在当前基础上轮播，所以需要将当前激活状态图片的索引号index与当前操作小圆点的下标同步，即index= this.no。
(4)自动轮播
网页启动后，轮播图自动从小到大数字轮播。设置自动轮播函数。因为图片是从小到大的顺序显示，所以index++；当index与图片数相同时，没有更多的图片，回到第一张图片，即index=0。清除所有图片和小圆点的激活状态，设置当前图片和小圆点为激活状态。为网页的加载事件添加函数，&lt;body οnlοad="init()"&gt;，在init函数中设置定时器，每隔2000ms执行一次auto函数。timer = setInterval(auto,2000)。
定义auto 函数，将index自增为1，当index 长度达到图片imgs 长度时，重新返回第一张图片。通过clearActive 函数，清除小圆点和图片的激活状态。通过定义init 函数用setInterval 添加定时器每两秒更换一次，启动图片的自动轮播。
(5)鼠标动作
需要实现鼠标指向和离开的效果，例如当鼠标悬停在图片上时，暂停轮播效果，离开时图片继续轮播。鼠标指向时清除定时器，clearInterval(timer)。鼠标离开时设置定时器，每隔2000ms执行一次auto函数，即timer=setInterval(auto,2000)。
首先获得元素，设置鼠标指向时clearInterval(timer)清除定时器；鼠标离开时重新调用timer函数，每隔2000毫秒自动执行一次自动轮播，将所有按钮的CSS样式，设置为cursor: pointer，实现鼠标指向时变为手指图标的功能。
(6)添加与删除
单击添加按钮，添加一个图片和小圆点按钮，并且添加的图片和小圆点按钮，处于激活状态。当图片增加到9张时不能继续添加。因为图片的个数是动态变化的，所以每单击增加一次，需重新获取图片的个数。
添加新的图片之前先clearInterval(timer)清除定时器，使用clearActive函数清除小圆点和图片的激活状态。
使用var创建属性，当单击添加时，对图片数量进行改变，nums1增加到9，消除计时器，清除图片激活状态，创建新结点newli 设置背景格式，增加到父元素ul 中。创建新圆点，重新赋值index，同步激活图片，当单击删除时，当nums1&gt;2是删除，清除图片激活状态，删除父元素的最后一个子元素，修改图片父元素和圆点父元素的className，重新赋值index，imgNum.value使图片激活状态同步。
最后，需要实现增加和减少图片的功能，需要在js当中书写。首先，代码通过document.getElementById和document.getElementsByClassName方法获取了HTML文档中的多个元素：
在addImg.onclick函数中，当点击增加图片按钮时，会先获取当前的图片数量。如果图片数量小于9，则暂停定时器和激活状态，然后创建一个新的li元素。
设置其内容为当前图片数量加1，背景为对应的图片，背景大小为1500px 400px，同时添加了"item active"类名。然后，将新创建的li元素添加到包含图片的父元素中，创建一个新的li元素，设置其内容为当前图片数量加1，并添加了"point pointActive"类名。最后将新创建的点元素添加到包含图片数量提示的父元素中。
在subImg.onclick函数中，当点击减少图片的按钮时，会先获取当前的图片数量。如果图片数量大于2，则暂停定时器和激活状态，移除最后一个图片元素和对应的元素，并将移除后的图片元素的类名改为"item Active"，点元素的类名改为"point pointActive"。
3.效果截图
(1)整体布局
(2)左右箭头滚动
(3)小圆点滚动
(4)自动轮播
(5)添加与删除
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48f197ad61e2eb79c532e1f5de9df1cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd0d12a876f3e49d80aca0618285c416/" rel="bookmark">
			List集合拆分为多个List
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		list 拆分 目录概述需求： 设计思路实现思路分析1.list 拆分是2.用stream的parallel实现list的分批处理3.使用stream的parallel实现list的分批处理 参考资料和推荐阅读 Survive by day and develop by night.
talk for import biz , show your perfect code,full busy，skip hardness,make a better result,wait for change,challenge Survive.
happy for hardess to solve denpendies.
目录 概述 list 拆分是一个常见的需求。
需求： list 拆分是一个常见的需求。
设计思路 实现思路分析 1.list 拆分是 // 创建模拟list List&lt;Integer&gt; dataList = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 22; i++) { dataList.add(i); } // 每批次数据记录数量 int partialLimit = 10; //判断是否有必要分批 if (partialLimit &lt; dataList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd0d12a876f3e49d80aca0618285c416/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/712f867537bcc98298ddf8483c44946b/" rel="bookmark">
			基于Proteus 、STM32CubeMX仿真STM32F103C8T6&#43;FreeRTOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、仿真环境：
1）、Proteus 8.15。
2）、STM32CubeMX - 5.1.0。
3）、Keil uVision V5.23。
二、Proteus 仿真原理图：
PC13、PC14为LED1、LED2控制输出；PA0为KEY1输入；PA9、PA10为USART1_TX、USART1_RX；PD0，PD1外接8MHz晶振。
三、STM32CubeMX配置：
1）、MCU选型：
2）、RCC配置：
3）、SYS配置：
4）、GPIO配置：
5）、FreeRTOS配置：
添加LEDTask、KEYTask。
6）、Project配置：
最后生成代码。
四、keil 代码编辑、编译：
1）、打开Project：
2）、打开mian.c文件，添加如下代码：
编译、输出hex文件。
五、Proteus仿真：
1）、加载hex文件：
2）、运行效果图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab5dc14bdbcf7c889cee7d82bd100ff2/" rel="bookmark">
			todesk在红队中的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介安装命令利用场景未安装todesk已安装了todesk获取历史连接记录无法获取密码情况 总结 简介 ToDesk 是一款多平台远程控制软件，支持主流操作系统Windows、Linux、Mac、Android、iOS跨平台协同操作。ToDesk支持任何网络环境下的远程实现，4.0版本已经开放100台设备列表。
安装命令 静默安装
ToDesk_Setup.exe /S 设置安全密码
默认安装路径 C:\Program Files (x86)\ToDesk\ToDesk.exe ToDesk.exe -setpasswd password eg:ToDesk.exe -setpasswd 123456 查看运行状态
默认安装路径 C:\Program Files (x86)\ToDesk\ToDesk.exe C:\Program Files (x86)\ToDesk\ToDesk.exe -status 利用场景 未安装todesk 在冰蝎webshell管理工具中上传todesk安装包
静默安装
可以看到已经安装成功，但是依然会有弹窗（最好是管理员不在线情况下使用）
获取密码方式
1.设置安全密码
然后读取设备代码，即clientid，然后进行远程连接
2.读取临时密码
将其临时密码替换在本机上，重启todesk
可以看到本机的临时密码刷新了
进行远程连接
已安装了todesk 运行ToDesk后会在默认安装目录下生成一个config.ini配置文件，存储的有设备代码、临时密码、安全密码以及登录用户和密码等重要敏感信息。我们只需要找到todesk的根目录即可，然后查看config.ini，在config.ini可以找到识别码以及加密的密码，即clientid字段和tempAuthPassEx字段
[ConfigInfo] screen_img= localPort=35600 clientId=767****68 PrivateData=d88f1c6d9a29586481d1d18c97de14ec949c431dec2f382e0cd5f8d47dc486f287664ce1a060c888862dfade939d1d39a27b0b3fe4a83ea5e1 language=936 Version=4.2.9 tempAuthPassEx=77075794f6310ab54fee1e13935e5392771c24c418a6d526e3ab83ef578d215ebd87467876fd7f55312fb8dbbe9c478e35da8a3069a2 updatePassTime=20220512 Resolution=2560x1440 LastPushTimeEx=20220512 autoStart=0 对于加密的密码我们可以复制到本地的todesk配置文件里，替换我们本地的密码，然后重启todesk，这样就能得倒对方机器的连接密码
成功替换得到密码。 获取历史连接记录 ToDesk连接一台主机后会在默认安装目录下生成一个json格式文件，在已登录状态和未登录状态的文件命名方式不太一样。其中两种登陆状态的文件路径分别如下
C:\Program Files (x86)\ToDesk\devlist_******.json C:\Program Files (x86)\ToDesk\userInfo.json 这个文件主要用于存储历史连接记录，只需找到UserId（设备代码）和PassEx密码，然后利用配置文件覆盖的方式将PassEx解密得到密码明文，最后再用目标主机ToDesk的设备代码和密码连接。
{ "DeviceInfo" : [ { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab5dc14bdbcf7c889cee7d82bd100ff2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0874569a6f17e0b295b6ec5cffb6bf0f/" rel="bookmark">
			Linux下采集摄像头的图像再保存为JPG图片存放到本地(YUYV转JPG)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下采集摄像头的图像再保存为JPG图片存放到本地(YUYV转JPG)-腾讯云开发者社区-腾讯云
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd781050f9a7bfb5be71b96d7b6f44a6/" rel="bookmark">
			[记录]基于Flask Web全栈开发实战-项目实战·上篇（黄勇 • 著）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 基于书籍《Flask Web全栈开发实战》【黄勇·著】第9章项目实战
创建项目 代码环境：pycharm
File-&gt;New Project-&gt;Flask
安装相应的python 包
# 用于flask在使用ORM模型操作数据库 pip install flask-sqlalchemy # Python操作数据库的驱动程序 pip install pymysql # 对密码加密和解密 pip install cryptography # 用于将ORM模型的变更同步到数据库中 pip install flask-migrate config.py文件 在根目录下，常见一个config.py的python文件，用来存放配置项。
class BaseConfig: SECRET_KEY = 'linql_test' SQLALCHEMY_TRACK_MODIFICATIONS = False # 开发环境 class DevelopmentConfig(BaseConfig): # 配置连接数据库 HOSTNAME = '192.168.3.5' #服务器地址 PORT = 3306 #默认端口号 USERNAME = 'root' PASSWORD = 'root' DATABASE = 'pythonbbs' #数据库名 SQLALCHEMY_DATABASE_URI = f"mysql+pymysql://{USERNAME}:{PASSWORD}@{HOSTNAME}:{PORT}/{DATABASE}?charset=utf8mb4" # 测试环境 class TestingConfig(BaseConfig): # 配置连接数据库 HOSTNAME = '192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd781050f9a7bfb5be71b96d7b6f44a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c47e2c8585cbb706685f3818b3b896d9/" rel="bookmark">
			MyCat 2全套学习笔记（完整配置【主从&#43;集群】&#43;理论解析 &#43; 大厂真实业务理解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
入门概述
MyCat概念
MyCat的作用
读写分离
数据分片 多数据源整合
MyCat 解决问题的思路
MyCat 和MySQL的区别
MyCat原理 MyCAT2的安装
前言
下载压缩包和jar包
安装MyCAT2
创建/data/tools
进入/data/tools目录
下载 下载完成
解压并移动到data目录下
修改权限
把所需的jar复制到mycat/lib目录
MyCAT的目录结构
启动一个3306的MySQL
配置物理库地址
启动MyCAT
连接MyCAT
MyCat2 配置文件介绍
用户（user）
数据源（datasource）
逻辑库与逻辑表（logicaltable）
序列号（sequence）
服务器（server）
MyCat2 注释配置
重置配置
用户相关
创建用户
删除用户
显示用户
数据源相关
创建数据源
删除数据源
显示数据源
集群相关
创建集群
删除集群
显示集群
MySQL 主从搭建 主从介绍 主从复制实现步骤
搭建主从复制
环境说明（使用Docker启动两个）
修改配置文件
主机的配置m1.cnf
从机的配置m1s1.cnf
配置文件修改后，复制到容器里面 执行SQL语句
进入主机里面执行相关配置
进入从机里面执行相关配置 搭建失败的原因
第一个不是yes，是connecting
第二个不是yes，是no
第一个不是yes，是no
MySQL主从的操作规范
测试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c47e2c8585cbb706685f3818b3b896d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4ed4448aec9bc129762b098d83dff9/" rel="bookmark">
			FastJson中JSONString与各个对象的的转换关系及API示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 JSON作为一种轻量级的数据交换格式，在我们日常的开发中使用十分广泛，就Java后端的开发工作中，JSON字符串与Java对象之间相互转换是常常遇到的操作。
虽然平时用到的挺多的，但是因为用于JSON处理的包有很多种，每种工具集的功能和使用方式也都不同，很容易在使用时造成混乱。
本文就结合FastJson部分源码，简单整理了下常用的API及其使用示例
本文FastJson版本：1.2.54
转换图 根据FastJson源码大致整理出了这么一张转换图：
可以看到参与转换的对象主要有图中五种：
JSONString：json字符串JSONObject：json对象JSONArray：json对象数组JavaBean：java对象List：java对象集合 转化中用到的方法的方法名有如下几种：
parse: JSONString ==&gt; JSONObject/JSONArrayparseObject: JSONString ==&gt; JSONObject/JavaBeanpareseArray: JSONString ==&gt; JSONObject/List&lt;JavaBean&gt;toJSONString: JavaBean/JSONObject ==&gt; JSONStringtoJSON: JavaBean ==&gt; JSONObjecttoJavaObject:JSONObject ==&gt; JavaBean 常用API 本文种仅列举平常使用频率较高的API，其他的重载方法可参考源码，大都是对序列化/反序列化过程进行定制化。
toJSONString# 实现了json对象(JSONObject)&gt;json字符串(JSONString)，和Java对象(JavaBean)&gt;json字符串(JSONString)的转化
从源码中可以看到这一方法被重载了多个，我们日常会用到的有如下几个：
方法 : 返回值参数说明功能toJSONString(Object object):Stringobject: 需要进行序列化的对象javaBean或者JSONObject将对象序列化为json字符串toJSONString(Object object, boolean prettyFormat):StringprettyFormat：是否格式化输出json字符串格式化输出json字符串toJSONString(Object object, SerializerFeature... features):Stringfeatures：序列化额外属性配置，非必填根据指定属性进行序列化toJSONStringWithDateFormat(Object object, String dateFormat, SerializerFeature... features):StringdateFormat：日期格式(yyyy-MM-dd)序列化时格式化日期 这些方法中最常用的即为：toJSONString(Object object)
parse 实现了json字符串(JSONString)&gt;json对象(JSONObject)，和json字符串(JSONString)&gt;json对象数组(JSONArray)的转化
方法 : 返回值参数说明功能parse(String text):Objecttext：json字符串反序列化json字符串 parseObject 实现了json字符串(JSONString)&gt;json对象(JSONObject)，和json字符串(JSONString)&gt;Java对象(JavaBean)的转化
方法 : 返回值参数说明功能parseObject(String text):JSONObjecttext:json字符串反序列化json字符串为Json对象parseObject(String text, Class clazz):Tclazz:指定反序列化后的类json字符串转java对象parseObject(String text, TypeReference type, Feature.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd4ed4448aec9bc129762b098d83dff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52566b490a7d3db0892159e526ead3b8/" rel="bookmark">
			写一个适合自己游戏的简单的协议测试（接口测试）工具/抓包工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		曾几何时，wpe 是一个网络游戏抓包神器，我们在做协议测试的时候，也是通过 wpe 来抓包、改包和发包，来测试服务器对于非法协议的处理逻辑是否正确。wpe 操作简单，只需要加载进程，启动抓包，停止抓包就能看到所有与服务器之间的封包记录，但美中不足的是，wpe 抓取的封包内容全部是 16 进制显示，有时候我们需要改动某个字段，还需要先破译并找到字段位置来做修改，可读性比较差。
随着时代的发展，现在的游戏做了很多的安全措施，wpe 已无法找到目标游戏的进程，其他的抓包工具也很少有能满足测试需求的。而且，我们公司的测试组有自己编写的机器人，在之前，客户端和服务端之间的详细的交互逻辑，我们知道的并不是很清楚，比如我执行一个操作之后，客户端会发送哪些协议，会收到哪些协议返回？协议的先后顺序是怎样的？在不知道这些信息的时候，机器人的脚本行为编写很慢，效率比较低。
为了更好的配合机器人脚本的编写，以及针对我们的游戏项目进行协议测试，我们写了一个简单的小工具来达到显示封包收发过程以及插包改包来验证服务器逻辑的目的（PS：仅适合针对自己公司内部项目，因为需要知道协议文档嘿嘿），通过这个工具，客户端与服务端的每一条协议交互，都会按照先后顺序进行明文显示，这样在我们编写机器人行为的时候，也能够帮我们更好的梳理机器人协议发送的流程，更快的完成行为方法的编写，另外因为进行了明文显示，在协助我们做协议测试方面也比 wpe 更好。接下来我们来实现这个抓包发包工具。
提前声明：本人文笔有限，python 纯自学，代码能力也有限，如对文中内容有不同看法，请合理讨论，或者私聊我，勿喷，谢谢。如对你有帮助，或者有其他想法，也欢迎探讨。
首先我们分析一下 wpe 的原理（个人猜测，如有问题欢迎指正）：
图有点乱，不过它大概是下面这样的：
1.wpe 加载客户端进程，然后将修改后的 dll 注入到客户端进程，hook 客户端的 send 和 recv 方法调用。
2.客户端进行发包操作，协议在通过客户端的 socket 时，会通过注入的 dll 进行处理，然后再发给服务端（处理可能包括拦截、修改等）。
3.服务端在返回封包之后，也会通过客户端的 socket，调用 dll 进行处理，然后再发给客户端。
4.wpe 可以直接插入伪装包，通过 dll 调用直接将伪装的封包通过客户端的 socket 发给服务端。
这里面最关键的是 dll 注入和 hook 钩子，不过这两个我研究了一阵子，没研究懂，所以我不会，尴尬…不过没关系，接下来我们换一种思路来做。
首先来分析一下我们想要的功能，请看下图（图片仅供参考，但需要自行使用 QT 设计一个类似的界面出来）：
这个是目前已经做出来的一个小工具，大概分了几个区块：
1.目标服务器：就是游戏需要登录的那个服务器地址
2.进制转换功能：做这个东西主要是为了方便解读十六进制，当时用 wpe 测试的时候，解析字节流太繁琐了，产生了心理阴影。
3.协议生成和发送：可以填入协议号和参数组自动生成十六进制的协议，也可以模拟发送，实现 wpe 的插包功能。
4.其他功能：其他想要实现的辅助测试的功能，需要自己写。
5.协议记录：发送协议和接收协议的全部记录。
6.日志：记录一些过程和错误内容。
7.代理：工具的核心，实现所有的协议转发和修改功能。
刚刚讲到了，dll 注入有点难，我们需要换一种思路，上面这个小工具我是用代理 agent 的方式来实现的，原理图如下：
从图中可以看到，原本客户端与服务器是通过 socket 直连的，但是我们无法注入 dll 的话，就无法对收发过程进行干预，所以我们就需要在他们之间加一个代理，客户端发给服务器的包，先发到代理这里，然后代理再转发给服务器，同样的，服务器发给客户端的包，也是先发到代理这里，然后再转发给客户端。由于代理的功能是我们自己来实现的，所以在接收到客户端发给服务器的或者服务器返回的封包时，我们可以对其进行任意的修改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52566b490a7d3db0892159e526ead3b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dda6aa06483176f8b9f050af6cb8480c/" rel="bookmark">
			安卓：Splash screens——官方解决启动白屏的方法之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Splash screens是什么？二、使用步骤1.引入库2.简单使用3.延长停留时间 总结 前言 安卓启动app会出现白屏现象，官方提供了Splash screens这个解决白屏问题的方法之一，最近学完顺便记录下笔记。
当然：最好的学习路径还是官网：Splash screens
效果展示：
一、Splash screens是什么？ Splash screens可以称之为初始屏幕，是解决应用启动白屏现象的方法之一。初始屏幕体验为每个应用带来标准设计元素 启动，但它也是可自定义的，因此你的应用可以保持其独特的品牌。虽然这是在Android 12 推出的功能，但是谷歌也有考虑到适配低版本安卓，以下的使用步骤就是适配后的实现方法。
二、使用步骤 1.引入库 dependencies { implementation "androidx.core:core-splashscreen:1.0.0" } 2.简单使用 在value-theme中添加代码，以下为部分通用属性
属性描述windowSplashScreenBackground开屏页面底色windowSplashScreenAnimatedIcon开屏页面iconwindowSplashScreenAnimationDuration开屏页面存在时间，该属性最高为1000毫秒。若想延长时间，需要另外操作postSplashScreenTheme对应原来的theme，在开屏页消失后app恢复成的theme &lt;style name="SplashScreenTheme" parent="Theme.SplashScreen"&gt; &lt;!-- 开屏页面底色--&gt; &lt;item name="windowSplashScreenBackground"&gt;@color/splash_screen_background&lt;/item&gt; &lt;!-- 开屏icon--&gt; &lt;item name="windowSplashScreenAnimatedIcon"&gt;@mipmap/ic_launcher_round&lt;/item&gt; &lt;!-- 停留--&gt; &lt;item name="windowSplashScreenAnimationDuration"&gt;1000&lt;/item&gt; &lt;!-- 原来主题--&gt; &lt;item name="postSplashScreenTheme"&gt;@style/Theme.MemoDemo&lt;/item&gt; &lt;/style&gt; 在MainActivity调用Splash screens
@Override protected void onCreate(Bundle savedInstanceState) { SplashScreen.installSplashScreen(this); super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } 3.延长停留时间 由上述属性描述我们可以知道，windowSplashScreenAnimationDuration的最大值只有1000，也就是1毫秒，但如果若是需要延长时间，那么我们需要在启动Acitivity中进行调整。
获取视图层次结构的ViewTreeObserver getViewTreeObserver()注册回调，以便在即将绘制视图树时调用 addOnPreDrawListener（）设置Timer固定时长来让程序接着绘制视图 private boolean isAppReady = false; @Override protected void onCreate(Bundle savedInstanceState) { SplashScreen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dda6aa06483176f8b9f050af6cb8480c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a637dfa66f12650766c63b076a19bac9/" rel="bookmark">
			Java访问redis方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java访问Redis的方案
Java 访问 Redis 主要有以下几种方案：
Jedis：是Redis的Java客户端之一，可以通过Jedis访问 Redis 实例，支持 Redis 的所有操作。Jedis 支持多个操作模式，包括单机模式、哨兵模式和集群模式，适合各种规模的应用。
Lettuce：是另一个Redis的Java客户端，相对于Jedis更加快速和稳定。Lettuce 使用的是 Netty NIO 框架，能够实现异步和非阻塞的操作，同时支持哨兵模式和集群模式。相对于Jedis，Lettuce更适合高并发的场景，同时也是 Redis 官方推荐的客户端。
Redisson：是一个分布式并发框架，内置了 Redis 客户端，能够对 Redis 的数据结构进行操作。Redisson 提供了分布式Map、Set、List、Queue、Lock、Semaphore、AtomicLong等数据类型，同时也提供了分布式调度器、分布式迭代器等实用功能。相对于Lettuce，Redisson 更适合分布式应用程序和使用复杂 Redis 数据结构的应用程序
Spring Data Redis：是 Spring框架对Redis的一层封装，可以方便地对Redis进行访问和操作。Spring Data Redis底层默认使用Lettuce，也可以配置使用其他库。
Spring Data Redis
Spring Data Redis 是一个基于Spring框架的 Redis 的访问库，Spring Data中提供了对多个 NoSQL 数据库的访问支持，使得开发者可以通过Spring统一的方式来访问这些数据库，节省了对数据库不同访问方式的学习成本。Spring Data Redis提供了很多常用的对象封装和Redis操作方法，简化了与 Redis 的交互工作。
Spring Data Redis的主要功能包括：
1、对Redis的访问操作的封装：包括对 Redis 的常见数据类型和命令的支持，支持 Redis 的哨兵、集群和管道等特性。
2、RedisTemplate和Redis Operations：RedisTemplate封装了 Redis数据库的连接行为，并暴露给用户Redis常见操作的API。Redis Operations则是RedisTemplate中的单独操作接口，提供了更简化的操作方式，如 set、get等。
3、Repository支持：类似于JPA的思想，Spring Data Redis提供了许多Repository接口，通过 Spring的依赖注入或配置，就可以实现对Redis数据的存取操作。这主要是一个 CRUD 的操作集合。
4、Cache支持：Spring Framework本身也提供一套Cache模块，Spring Data Redis提供了一些注解来方便使用 Redis 作为缓存提供器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a637dfa66f12650766c63b076a19bac9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a8f79a2aaacfd7a54a6889366d0296/" rel="bookmark">
			Redis的数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 支持多种数据类型，其中较为常见的5种类型为：
1、字符串（string）：Redis 的最基本数据类型，可以包含任何数据，如文本和二进制数据等。
2、列表（list）：由多个字符串组成的列表，可以进行添加、删除和查找等操作。可以通过左侧或右侧添加或删除元素。
3、集合（set）：由多个字符串无序、唯一组成的集合，可以进行求交集、并集、差集等复杂的操作。
4、有序集合（sorted set）：和集合类似，每个元素都有一个分数，可以通过分数进行排序，并提供复杂的范围查找和交集、并集、差集等操作。
5、哈希表（hash）：由多个键值对组成的无序散列表，可以进行添加、删除和查找等操作。
各种数据类型的特点和使用场景如下：
字符串：最基本的数据类型，可用于存储文本、数字等。列表：适合用于存储有序元素，如消息队列，日志队列等。集合：适合用于存储不重复元素，可以进行各种集合操作，如求交集、并集、差集等。有序集合：适合用于存储带权重的元素，并可以按照权重进行排序，如排行榜、字典等。哈希表：适合用于存储对象，其键可以利用哈希函数算法映射到表中的地址，以实现快速查找。 String类型
在 Redis 中，String 是最基础、最常用的数据类型之一，它可以存储任意格式的字符串。
String类型支持对字符串的读写操作，同时Redis的String类型还支持对字符串进行一些特殊的操作，如：追加字符串、截取子串、在字符串某一位置插入字符等，支持多种不同的数据编码格式。
String 类型在 Redis 中的典型用途是存储缓存、计数器、分布式锁等，同时它还可以支持像字符串拼接、计数器自增、分布式锁释放等常见的业务功能。
String 类型在 Redis 中的常见命令：
1、APPEND：将指定的字符串追加到 key 当前值的末尾。
2、GETRANGE：获取字符串中指定范围内的子串，包括起始和结束位置上的字符。
3、SETRANGE：从指定位置开始，将字符串中的一部分替换为给定的串。
4、STRLEN：返回指定 key 的长度。
5、INCR 和 INCRBY：将指定 key 的值增加 1 或递增固定的整数。
6、DECR 和 DECRBY：将指定 key 的值减少 1 或递减固定的整数。
List类型
Redis 的 list（列表）类型是一个可以存储字符串、整型等类型的有序、可重复集合。其内部使用双向链表来存储数据，并提供了一系列的命令，如LPUSH、RPUSH、LPOP、RPOP 等用于在列表的两端进行操作。
Redis list 类型的一些重要特性：
1、双向链表存储结构：list 内部使用双向链表来存储数据，支持 O(1) 复杂度的头尾插入和删除操作。
2、可重复：list 内部允许相同元素的存在。
3、支持下标访问：list 内部数据可以通过下标进行随机访问，同时提供了一系列访问指定范围（切片）数据的命令，如 LRANGE。
4、支持阻塞操作：采用了生产者消费者模式，支持在list为空时进行阻塞等待，能够实现一些高级功能，如消息队列等。
Redis list 类型的使用场景：
1、消息队列：list可以作为消息队列的底层存储结构，同时支持阻塞式消费。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a8f79a2aaacfd7a54a6889366d0296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e234c85d959a2a9a9b452556a1f74352/" rel="bookmark">
			常用的git命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设置用户信息 当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址
$ git config --global user.name "tingtang" $ git config --global user.email tingtang@example.com 使用了 --global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息
二、查看所有配置信息 $ git config --list 回车会输出：
user.name=tingtang user.email=tingtang@example.com color.status=auto color.branch=auto color.interactive=auto color.diff=auto ... 三、获取帮助 $ git help config 四、克隆现有的仓库 $ git clone https://github.com/libgit2/libgit2 五、检查当前文件状态 没有add之前文件颜色是红色的
$ git status 六、暂存已修改文件 (1).代表暂存所有文件
(2)若要暂存单个文件只需把文件路径名拼接在后面即可git add xxxxxx
git add . git add 命令执行之后，git status此时文件的颜色为绿色
七、要查看尚未暂存的文件更新了哪些部分 $ git diff 八、提交更新 $ git commit -m "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e234c85d959a2a9a9b452556a1f74352/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6cb0e320bd3597f7c8117673bd0b896/" rel="bookmark">
			eNSP实现链路聚合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 手工模式：LACP模式：总结 链路聚合是将多个物理链路捆绑成一个逻辑链路的过程，它可以提高带宽、冗余性和可靠性。 手工模式： &lt;Huawei&gt;sy Enter system view, return user view with Ctrl+Z. [Huawei]un in en Info: Information center is disabled. [Huawei]int eth-trunk 1 [Huawei-Eth-Trunk1]mode manual //默认为手工模式 [Huawei-Eth-Trunk1]trunkport e0/0/1 ? //只能绑定一个接口 &lt;cr&gt; [Huawei-Eth-Trunk1]trunkport e 0/0/1 ? //能绑定多个接口 &lt;0-0&gt; Slot number to Range link symbol &lt;cr&gt; [Huawei-Eth-Trunk1]trunkport e 0/0/1 0/0/2 to 0/0/4 //还可以绑定多个不连续的接口 Info: This operation may take a few seconds. Please wait for a moment...done. [Huawei-Eth-Trunk1]port link-type trunk [Huawei-Eth-Trunk1]port trunk allow-pass vlan all [Huawei-Eth-Trunk1]q [Huawei]dis eth-trunk 1 Eth-Trunk1's state information is: WorkingMode: NORMAL Hash arithmetic: According to SIP-XOR-DIP Least Active-linknumber: 1 Max Bandwidth-affected-linknumber: 8 Operate status: up Number Of Up Port In Trunk: 2 -------------------------------------------------------------------------------- PortName Status Weight Ethernet0/0/1 Up 1 Ethernet0/0/2 Up 1 注：给 Eth-Trunk 端口配置 link-type 属性时，是不能给单条链路的端口配置 link-type 属性的，需要将端口类型恢复默认属性值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6cb0e320bd3597f7c8117673bd0b896/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11b178ec2b21b53ad4b60b12490d0390/" rel="bookmark">
			win10跟这台计算机连接的前一个usb设备工作不正常怎么办?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天小编闲来无事就跑到网站底下查看粉丝朋友给小编我留言询问的问题，还真的就给小编看到一个问题，那就是win10跟这台计算机连接的一个usb设备运行不正常怎么办，其实这个问题的解决方法时十分简单的，接下来小编就来好好教教大家吧。更多win10系统教程，尽在小白系统官网。
1、首先我们打开电脑，找到此电脑，右键点击它找到管理选项点开。
2、接下来我们打开计算器管理，找到设备管理器，然后找到通用串行总线控制器点开找到未知USB设备（描述设备符请求失败）的选项，找到症结所在，小编的电脑是没问题的所以没有那个选项，大家可以稍微参考一下。
3、接下来我们点击它，右键点击它，选择更新驱动程序即可。
4、如果更新无效，可以先将其卸载然后重新安装。
以上就是小编我关于win10跟这台计算机连接的一个usb设备运行不正常怎么办的全部解决方法，是不是很简单呢，大家快来好好学习一下吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa52c6605832fd3add20dfb6ee8469f6/" rel="bookmark">
			Git Cherry Pick的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cherry-pick命令的基本用法 cherry-pick命令的基本语法如下：
git cherry-pick &lt;commit&gt; 其中，&lt;commit&gt;是要应用的提交的哈希值或分支名。该命令会将指定的提交应用到当前分支上，并创建一个新的提交。
使用场景 cherry-pick命令常用于以下场景：
合并单个提交：
当我们只想应用某个分支上的一个提交到当前分支时，可以使用cherry-pick命令，而不需要合并整个分支。修复bug：
当我们在一个分支上修复了一个bug，并希望将这个修复应用到其他分支上时，可以使用cherry-pick命令。提取特定功能：
当我们在一个分支上开发了一个新功能，并希望将该功能应用到其他分支上时，可以使用cherry-pick命令。 示例 master分支上的提交记录，如下图所示：
文件内容如下：
add A by master add B by master bb add C by master 另一个分支dev上的提交记录，如下图所示：
文件内容如下：
add A by master aa add B by master add C by master cc add dd 现在，我们打算将dev分支上的add aa after A和add dd at new line提交应用到master分支上，则：
切换到master分支 git checkout master 输入以下命令 git cherry-pick 67b48e1bde3032061363daa85c1d35e7f096b0b8 有冲突，则解决冲突，然后git add -u，git cherry-pick --continue。
然后，输入：
git cherry-pick 6e43cfdd6c8d5745fe649c3acb9ac91165eaa65c 解决冲突后，git add -u，然后git cherry-pick --continue。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa52c6605832fd3add20dfb6ee8469f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c973ee491139f0f2906e251ba0cc16/" rel="bookmark">
			Tiny File Manager文件管理器&#43;Cpolar内网穿透带您体验高效稳定云存储！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2.Tiny File Manager网站搭建2.1.Tiny file manager下载和安装2.2 Tiny file manager网页测试2.2 Tiny file manager网页测试3. 本地网页发布3.1 Cpolar云端设置3.2 Cpolar本地设置 4. 公网访问测试总结 1. 前言 文件共享和查阅是现在网络最常见的应用场景，因此也产生了海量的应用，这些应用的功能都差不多，但是安装和部署的过程却差异巨大。不过对于使用者来说，能以最简单的安装过程实现最全面的文件上传下载功能，才是最符合需求的。今天，笔者就为大家介绍一款只有两个文件的php文件管理工具，Tiny File Manager，并使用cpolar生成的数据隧道，将其发布到公共互联网上，使我们能在任何地方都能访问到家里（办公室）电脑的文件。
2.Tiny File Manager网站搭建 Tiny File Manager是基于Web的开源小型文件管理器，其简单到只有两个文件，却能支持上传下载、多用户登录使用、支持多国语言、支持在线压缩和解压等多项功能，其唯一需要的，就是php5.5+。
2.1.Tiny file manager下载和安装 首先我们下载一个Tiny File Manager软件，其软件下载地址在github上（https://github.com/prasathmani/tinyfilemanager）。下载完成后，就可以将下载到的压缩文件解压，并将其中的两个文件粘贴到网站根目录下。笔者使用的是phpstudy网页环境，因此放在phpstudy安装文件夹下的www文件夹内（同理，也可以放在其他环境软件，如wamp、宝塔面板等的网站根目录下）。
接着，将tinyfilemanager.php文件名称变更为index.php。接着在浏览器中输入地址localhost，就能看到Tiny File Manager的安装界面。
在网站文件粘贴进www文件夹下，并修改文件名后，就可以在浏览器中输入地址访问localhost（默认的phpstudy输出端口是80，我们可以采用新建网页的形式更改输出端口）。
2.2 Tiny file manager网页测试 只要网页设置没有错，就可以进入tinyfilemanager的网页
一般来说，Tiny File Manager的默认账户有两个，分别为admin和user，具体的登录名和密码分别为：admin/admin@123 and user/12345。
2.2 Tiny file manager网页测试 完成Tiny File Manager网站安装后，就可以着手为其创建一个公共互联网地址。这里我们使用cpolar来完成创公共互联网地址的工作。
我们可以在cpolar的官网（www.cpolar.com）找到cpolar软件下载。笔者使用的是Windows操作系统，因此直接下载Windows版本的cpolar。
Cpolar软件下载完成后，将下载的压缩包解压，并双击解压后的.msi文件，就能进入自动安装程序，我们只要一路点击“Next”即可。
由于cpolar会为每个用户建立单独的数据隧道，并且通过用户密码和用户单独生成的token码，保证每个用户的数据安全，因此我们还需要在官网注册自己的账户。而注册程序也很简单，只要在官网右上点击“用户注册”，即可进入新用户注册界面。
完成以上安装和注册工作后，我们就能正式进入本地Tiny File Manager的公共互联网发布工作。
3. 本地网页发布 安装并注册好cpolar，剩下的工作就很简单，只要使用cpolar建立一条数据隧道，将cpolar生成的数据隧道的入口与本地电脑的tiny file manager网页端口连接起来，就能生成专属于与tiny file manager的内网穿透数据隧道，让我们能在公共互联网上访问到本地的tiny file manager网页。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5c973ee491139f0f2906e251ba0cc16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e60e78869a4696eae7d8b0807f474a6/" rel="bookmark">
			mysql向表中插入数据的几种语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql向表中插入数据的几种语法 在MySQL中，有几种插入数据的语法。以下是常见的几种： 插入单个行： INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...); 插入多个行： INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...), (value4, value5, value6, ...), (value7, value8, value9, ...); 从另一个表插入数据： INSERT INTO table_name (column1, column2, column3, ...) SELECT column1, column2, column3, ... FROM another_table_name WHERE condition; 插入默认值： INSERT INTO table_name DEFAULT VALUES; 插入生成序列值： INSERT INTO table_name (column1) SELECT nextval('sequence_name'); 其中，table_name 是要插入数据的表名，column1, column2, column3, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e60e78869a4696eae7d8b0807f474a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f32469c0abe484f8560d217eb8767d5/" rel="bookmark">
			卷积神经网络之“浅层特征”与“深层特征”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于层次结构和过滤器大小的不同，CNN 可以捕捉高级、中级甚至低级的特征。还可以通过池化机制将信息压缩成一个较小的尺寸。CNN 模型优势：可以捕捉特征不用考虑位置。是处理图像数据，特别是"特征提取"的理想类型。
1.图像浅层特征
1.浅层特征：浅层网络提取的特征和输入比较近，包含更多的像素点的信息，一些细粒度的信息是图像的一些颜色、纹理、边缘、棱角信息。
2.原理：浅层网络感受野较小，感受野重叠区域也较小，所以保证网络捕获更多细节。
3.优缺点：分辨率更高，包含更多位置、细节信息，但是由于经过的卷积更少，其语义性更低，噪声更多。
2.图像深层特征
1.高层信息：深层网络提取的特征离输出较近，一些粗粒度的信息，包含是更抽象的信息，即语义信息
2.原理：感受野增加，感受野之间重叠区域增加，图像信息进行压缩，获取的是图像整体性的一些信息
3.优缺点：具有更强的语义信息，但是分辨率很低，对细节的感知能力较差。
3.特征融合
1.早融合
1.早融合(Early fusion): 先融合多层的特征，然后在融合后的特征上训练预测器（只在完全融合之后，才统一进行检测）。这类方法也被称为skip connection，即采用concat、add操作。这一思路的代表是Inside-Outside Net(ION)和HyperNet。
2.两个经典的特征融合方法：（1）concat：系列特征融合，直接将两个特征进行连接。两个输入特征x和y的维数若为p和q，输出特征z的维数为p+q；（2）add：并行策略，将这两个特征向量组合成复向量，对于输入特征x和y，z = x + iy，其中i是虚数单位。
2.晚融合
1.晚融合(Late fusion)：通过结合不同层的检测结果改进检测性能（尚未完成最终的融合之前，在部分融合的层上就开始进行检测，会有多层的检测，最终将多个检测结果进行融合）。
2.这类研究思路的代表有两种：（1）feature不融合，多尺度的feture分别进行预测，然后对预测结果进行综合，如Single Shot MultiBox Detector (SSD) , Multi-scale CNN(MS-CNN)（2）feature进行金字塔融合，融合后进行预测，如Feature Pyramid Network(FPN)等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b621c58a567213c8f3346c6eadf73307/" rel="bookmark">
			Siren’s Song in the AI Ocean: A Survey on Hallucination in Large Language Models
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Siren’s Song in the AI Ocean: A Survey on Hallucination in Large Language Models 基本信息 博客贡献人 燕青
作者 Yue Zhang, Yafu Li, Leyang Cui, et al.
标签 LLM, Hallucinations
摘要 虽然大型语言模型在一系列下游任务中表现出卓越的能力，但一个重要的问题是它们表现出幻觉的倾向：LLMs偶尔会产生偏离用户输入、与先前生成的上下文相矛盾或与既定的世界知识相抵触的内容。这一现象对LLMs在真实场景中的可靠性提出了实质性的挑战。本文回顾了近年来在幻觉的检测、解释和缓解方面所做的努力，并强调了LLMs所带来的独特挑战。本文给出了LLM幻觉现象的分类和评估基准，分析了现有的旨在缓解LLM幻觉的方法，并讨论了潜在的发展方向。
问题定义 幻觉定义 LLMs产生无意义或谬误输出内容的现象通常被称为幻觉。这大大降低了LLMs在真实世界场景中的可靠性。例如，LLMs可能会制造错误的医疗诊断或治疗计划，从而导致有形的实际生活风险。
输入冲突幻觉：LLMs产生偏离用户提供的源输入的内容，其与用户任务指令之间的矛盾反映了LLMs对用户意图的误解。上下文冲突幻觉：LLMs生成的内容与先前生成的信息本身冲突。LLMs在产生长距离或多跳响应时可能会表现出自相矛盾，其产生于LLMs失去对语境的追踪或无法在整个会话过程中保持一致，这可能是由于LLMs在保持长时记忆或识别相关语境方面存在局限性。事实冲突幻觉：LLM产生偏离既定世界知识的内容。事实冲突幻觉的来源可以是多方面的，可以在LLM生命周期的不同阶段引入。 图1. 大模型响应中的三种幻觉 尽管其他两种类型的幻觉也很重要，但最近在LLMs中的幻觉研究的焦点主要集中在事实冲突幻觉上。可能的原因包括但不限于：
( 1 )在传统的NLG领域中，输入和语境冲突的幻觉已经被广泛研究。然而，由于缺乏权威的知识来源作为参考，事实冲突幻觉在LLMs中提出了更为复杂的挑战；
( 2 )事实冲突幻觉往往会对LLMs的实际应用产生更多的副作用，因此在最近的研究中得到了更多的重视。鉴于这种研究现状，本文的以下部分将主要集中于事实冲突的幻觉。
独特挑战 虽然传统自然语言生成(NLG)环境中的幻觉已被广泛研究，但在LLMs领域中理解和解决幻觉问题具有独特的挑战性：
海量训练数据：与为特定任务精心整理的数据相反，LLM的预训练使用从网络上获得的数万亿token，难以消除捏造、过时或有偏见的信息。谬误的不易察觉性：LLMs产生的虚假信息幻觉往往具有很强的拟真性，以至于连人类都难以察觉。需要考虑利用更多的知识来源进行验证。大语言模型的多样性：相比于通常应用于单一任务的传统NLG模型，大模型在多任务、多语言和多领域环境中表现更好。在评估方面，LLMs更常用于自由形式的文本生成，而这种缺乏确定性参考的任务使幻觉的自动检测变得复杂。因此，建立一个全面、可靠、自动化的评价基准至关重要。在缓解方面，所提出的方法应该是稳健有效的，在应用于各种场景时保持了良好的性能。 本文还列出一些除幻觉外的常见问题，以帮助读者区分它们和幻觉。
歧义性：答案可能并不一定是不正确的，但是对于用户问题却没有给出一个有用的答案。不完整性：不完整性问题发生在生成的响应不完整或碎片化的情况下，如下图例子中只给出了换轮胎4个步骤中的2步。偏见：LLMs中的偏见是指生成文本中不公平或偏见态度的表现，这些偏见可能来源于训练数据。如下图例子中将教师描述为女性是一种偏见。信息不足：指LLMs逃避回答某些问题的倾向，即使其有能力这样做。例如，由于奖励模型的不完善，RLHF可能会导致LLMs的过度优化，从而可能导致模型输出信息不足。 图2. LLMs除了幻觉外可能暴露的其它问题 方法 总体框架 本文首先给出对LLMs中幻觉的定义( § 2 )。接下来介绍相关的基准和度量指标( § 3 )。随后，本文讨论了LLM幻觉的潜在来源( § 4 )，并对最近解决该问题的工作进行了深入的回顾( § 5 )。
图3. 本文总体结构 LLM幻觉评估基准 基准数据集 针对LLMs中幻觉的评估，已经提出了多种基准。本文在图6中呈现了具有代表性的基准，并根据它们的评价方式、任务形式和构造方法进行讨论。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b621c58a567213c8f3346c6eadf73307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34a8b9eb663008e8beffc3b69ce7fa8a/" rel="bookmark">
			51单片机音乐喷泉频谱彩灯多功能音乐盒播放器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘 要...................................................................................................... 2
第一章 绪论........................................................................................ 4
1.1 研究课题背景...................................................................... 4
1.2 国内外发展概况.................................................................. 5
1.3 课题研究的目的.................................................................. 6
1.4 课题的研究内容及章节安排.............................................. 7
第二章 智能音乐喷泉控制系统的设计方案.................................... 8
2.1 设计任务及要求.................................................................. 8
2.2 音乐喷泉总体设计方案...................................................... 8
第三章 系统硬件部分设计.............................................................. 10
3.1 总体设计............................................................................ 10
3.2 主控制器设计.................................................................... 11
3.2.1 芯片介绍................................................................ 11
3.2.2 时钟电路设计........................................................ 13
3.2.3 复位电路设计........................................................ 14
3.3 LED显示........................................................................... 14
3.4 数模转换电路.................................................................... 15
3.5 微型潜水泵的选型............................................................ 15
第四章 音乐喷泉控制系统硬件设计.............................................. 16
4.1 音乐信号采集模块............................................................ 16
4.2 AD 转换电路的设计........................................................ 18
4.2.1 ADC0832 芯片的概述............................................ 18
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34a8b9eb663008e8beffc3b69ce7fa8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48e41a62cc3fa0b61edf51e09af90401/" rel="bookmark">
			机器学习之模型评估
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、模型评估概述 1.什么是模型评估 模型评估是对训练好的模型性能进行评估, 模型评估是模型开发过程不可或缺的一部分。它有助于发现表达数据的最佳模型和所选模型将来工作的性能如何。
2.模型评估的类型 机器学习的任务有回归,分类和聚类，针对不同的任务有不同的评价指标。按照数据集的目标值不同，可以把模型评估分为分类模型评估和回归模型评估。
3.过拟合、欠拟合 ​
3.1过拟合 什么是过拟合 过拟合其实就是为了得到一致假设而使得假设过于地严格。使得其在训练集上的表现非常地完美，但是在训练集以外的数据集却表现不好。 如上图所示，蓝线就是过拟合了，虽然它在训练集上将所有的点都放在了线上，但是如果再来一个点就会不起作用，这就是过拟合，而绿线的话也比较好地拟合了点集，但是它的泛化能力相较于蓝线来说是更好的
解决办法 1.增加训练数据数
2.使用正则化约束
3.减少特征值
4.调整超参数和参数
5.降低模型的复杂度
6.使用Dropout
7.提前结束训练
3.2欠拟合 什么是欠拟合 欠拟合（或称：拟合不足、欠配，英文：underfitting）是指模型在训练数据上没有获得充分小的误差．造成欠拟合的原因通常是模型学习能力过低，具体地说，就是模型参数过少或者结构过于简单，以至于无法学习到数据的内在结构和特征．例如，当用一个线性模型去拟合非线性数据时，会发生欠拟合．由此，可以通过增加模型参数和复杂度，提高学习能力，从而解决欠拟合问题．与欠拟合相对应的，是过度拟合．
解决办法 1.模型复杂化
2.增加更多特征，使输入具有更强的表达能力
3.调整参数和超参数
4.降低正则化约束
4.模型泛化能力 泛化能力（generalization ability）是指机器学习算法对新鲜样本的适应能力。 机器学习的目的是学到隐含在数据背后的规律，对具有同一规律的学习集以外的数据，经过训练的网络也能给出合适的输出，该能力称为泛化能力。
规律适用于现有数据，同样也适用于新鲜数据。
二、常见的分类模型评估 1. 混淆矩阵 混淆矩阵是监督学习中的一种可视化工具，主要用于模型的分类结果和实例的真实信息的比较 。
矩阵中的每一行代表实例的预测类别，每一列代表实例的真实类别。
真实值是positive，模型认为是positive的数量（True Positive=TP）
真实值是positive，模型认为是negative的数量（False Negative=FN）：这就是统计学上的第一类错误（Type I Error）
真实值是negative，模型认为是positive的数量（False Positive=FP）：这就是统计学上的第二类错误（Type II Error）
真实值是negative，模型认为是negative的数量（True Negative=TN）
将这四个指标一起呈现在表格中，就能得到如下这样一个矩阵，我们称它为混淆矩阵（Confusion Matrix）：
注意：预测性分类模型，肯定是希望越准越好。那么，对应到混淆矩阵中，那肯定是希望TP与TN的数量大，而FP与FN的数量小。所以当我们得到了模型的混淆矩阵后，就需要去看有多少观测值在第二、四象限对应的位置，这里的数值越多越好；反之，在第一、三四象限对应位置出现的观测值肯定是越少越好。
2. 准确率Accuracy 准确率是最常用的分类性能指标。
Accuracy = (TP+TN)/(TP+FN+FP+TN)
预测正确的数占样本总数的比例，即正确预测的正反例数 /总数。
3. 精确率（Precision） 精确率容易和准确率被混为一谈。
其实，精确率只是针对预测正确的正样本而不是所有预测正确的样本。
表现为预测出是正的里面有多少真正是正的。可理解为查准率。
Precision = TP/(TP+FP)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48e41a62cc3fa0b61edf51e09af90401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb8418d429dba9646358e79958d98f25/" rel="bookmark">
			Typora&#43;PicGo&#43;Github&#43;CSDN梦幻联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、快速搭建个人免费图床二、Typora图片实现自动上传三、Typora图片上传到CSDN出现错误 一、快速搭建个人免费图床 之前写过一篇 快速搭建个人免费图床 的文章，但是每次都要把图片拖到PicGo里面才能生成链接很麻烦，而且在本地用Typora写的文章发送给别人的时候还需要连同图片一起打包发送更麻烦，于是：
二、Typora图片实现自动上传 查找发现Typora可以和PicGo联动，只需要将复制的图片粘贴到文章中，图片会自动上传到并生成链接，步骤如下：
在Typora中依次点击文件-&gt;偏好设置-&gt;图像，然后进入此界面上传服务选择：PicGo(app)，路径选择软件的下载地址
验证图片上传是否成功
注意：两个软件的端口一定要一致，不然会出现验证失败的提示
三、Typora图片上传到CSDN出现错误 最近想把Typora整理的一个文档上传到CSDN，文字、表格部分都是正常显示，图片老是提示![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传]，图片链接也被混淆成了其他的样子。 翻找了好多的博客，很多人都提到了是有中文符号的问题，但我的确确实实全是英文啊！不过也找到了解决方法，就是把图片格式由Makedown改为HTML的。但是一篇文章的图片好多啊，我要一个个变更图片格式，那大概是疯了吧！
废话不多说，python脚本解决！
import re # 读取Markdown文档 input_file = "your_input_markdown.md" output_file = "output_markdown.md" with open(input_file, "r", encoding="utf-8") as file: markdown_text = file.read() # 使用正则表达式查找Markdown中的图片链接 img_pattern = r"!\[(.*?)\]\((.*?)\)" def replace_img(match): alt_text = match.group(1) img_url = match.group(2) return f'&lt;img src="{img_url}" alt="{alt_text}"&gt;' # 使用正则表达式替换为&lt;img&gt;标签 html_text = re.sub(img_pattern, replace_img, markdown_text) # 写入替换后的Markdown文本到新文件 with open(output_file, "w", encoding="utf-8") as file: file.write(html_text) print(f"Conversion completed. Output saved to {output_file}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb8418d429dba9646358e79958d98f25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/065a51ec00b5707f3626347e67de975f/" rel="bookmark">
			vue.config.js配置proxy代理产生404错误的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用vue做开发时，请求api接口时为了解决跨域问题，一般会设置proxy代理，
但有时候会莫名其妙的出现404错误，这里总结一下vue设置proxy代理产生404错误的几种原因：
原因1：没有注意vue proxy代理优先级的规则：
vue proxy代理匹配的规则是按照配置的内容从上到下，顺序逐个匹配的，因此第一个被匹配到的规则生效以后, 后面就不会被匹配到：
举个例子：
proxy: { "/api/": { target: "http://proxyAddr:port", changeOrigin: true, pathRewrite: { "^/api": "", }, }, "/api2/": { target: "http://proxyAddr2:port", changeOrigin: true, pathRewrite: { "^/api2": "", }, }, } 按照上面的写法：如果有一个/api2的请求进来，会直接被第一条"/api"的规则匹配到，而后面的"/api2"的规则就不会被匹配到，所以此时就会产生404错误
解决办法： 把/api2的匹配规则放到/api的前面
注意点小结：对于有同名前缀的uri路径（比如/api和/apixxxx这样的），为了避免长uri路径被短uri规则匹配到,而后面的规则不生效，必须把短uri路径的匹配规则放到文件的最后！
原因２：pathRewrite路径重写配置错误
这个例子中pathWrite写错了：被重写的部分跟进来的url内容完全不同，没有被识别到，这种情况也会发生路由匹配不到引发的404错误
所以，必须注意：pathWrite的被重写的路径必须跟匹配规则定义的uri保持一致！否则就会报404错误！
以上就是vue.config.js配置proxy代理发生404错误的两大原因
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8347121ffd166573dd063a8910e2832c/" rel="bookmark">
			【C语言】中，输入一个数组，实现将输入的n个数字按照从大到小的顺序输出。【通俗简单易懂】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章中，我们将讲述在C语言中，输入一个数组，如何用for循环实现将输入的n个数字按照从大到小输出。
一.定义数组并初始化 首先，我们定义一个整形的数组并将其初始化。输入n，来决定数组中整数的个数。
然后用for循环来输入这个数组中的各个数字。
int n = 0; scanf("%d", &amp;n); int* arr = (int*)malloc(sizeof(int) * n);//动态开辟 //输入n个整数 int i = 0; for (i = 0; i &lt; n; i++) { scanf("%d", &amp;arr[i]); } 二.排序 接下来，就是对这个数组中的数字进行比较排序了。
我们先来看代码。
//将这n个数按从大到小排序 for (i = 0; i &lt; n; i++) { int temp = 0; //创建temp变量用于存储临时值 temp = arr[i]; /*把arr[i]也就是arr[0]的值赋给temp，避免数组中有负数而产生不必要的错误*/ int j = 0; //j表示每次循环开始时arr的下标 /* 下面的for循环中，将i赋值给j， 就避免了前面已经排序好的数字再参与到后面的循环（排序）中去。*/ for (j = i; j &lt; n; j++) { if (temp &lt; arr[j]) { //如果数组里还有比temp更大的值，那么将它的值和temp互换 temp = arr[j]; arr[j] = arr[i]; arr[i] = temp; } } } 第一次循环时，原数组中arr[0]的值赋给了temp，因此，我们可以没有后顾之忧地在第二个for循环里，将我们找到的数组里的最大值赋给arr[0]，再将temp的值赋给原数组中最大的数的位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8347121ffd166573dd063a8910e2832c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d22446fc42a8c33eedffc8938ff86bce/" rel="bookmark">
			微信小程序--小程序框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
一.框架基本介绍
1.整体结构：
2.页面结构：
3.生命周期：
4.事件系统：
5.数据绑定：
6.组件系统：
7.API：
8.路由：
9.模块化：
10.全局配置：
二.视图层详解
1.WXML（WeiXin Markup Language）：
1.1 列表渲染
1.2条件渲染
1.3 模板
2.WXSS（WeiXin Style Sheet）：
3.数据绑定：
5.事件绑定：
6.全局样式和局部样式：
三.逻辑层详解
1.小程序生命周期
2.App(Object object)
参数
3.页面跳转
1.一级跳二级
2.二级跳一级
3.二级跳二级
前言： 小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。
整个小程序框架系统分为两部分：逻辑层（App Service）和 视图层（View）。小程序提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。
一.框架基本介绍 1.整体结构： 小程序框架遵循一种组织结构，包括app.json、app.js、app.wxss等文件。这些文件用于定义小程序的全局配置、全局逻辑和全局样式。
2.页面结构： 小程序的页面由四个文件组成，分别是.json（配置文件）、.js（逻辑文件）、.wxml（模板文件）和.wxss（样式文件）。这些文件协同工作来定义页面的结构、逻辑和样式。
3.生命周期： 微信小程序框架定义了一系列生命周期函数，包括onLoad、onReady、onShow、onHide、onUnload等。这些函数用于管理页面的初始化、显示和隐藏等生命周期事件。
4.事件系统： 框架提供了事件系统，支持事件绑定和处理，以实现用户交互和数据传递。
5.数据绑定： 微信小程序支持双向数据绑定，开发者可以使用{{}}语法将页面上的数据与JavaScript中的数据关联，实现数据的动态展示和更新。
6.组件系统： 小程序框架提供了一系列基本组件，如&lt;view&gt;、&lt;text&gt;、&lt;button&gt;等，以及自定义组件的开发能力。开发者可以通过组件来构建小程序界面。
7.API： 微信小程序框架提供了一系列API，用于实现网络请求、本地存储、位置信息、设备信息、多媒体处理、支付等功能。开发者可以通过API实现各种小程序功能。
8.路由： 框架支持小程序页面的路由跳转，开发者可以使用wx.navigateTo、wx.redirectTo等方法进行页面之间的导航。
9.模块化： 微信小程序支持模块化开发，可以将代码分割为多个模块，提高代码的可维护性和复用性。
10.全局配置： 通过app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d22446fc42a8c33eedffc8938ff86bce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76f0ab1463885f70d083a17f019e81bb/" rel="bookmark">
			解决使用uniapp开发微信小程序时主包太大和vendor.js过大无法打包的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在uniapp开发小程序这一块，相信很多开发者都遇到过代码体积太大无法打包的问题，这时候就要优化小程序包大小。下面分享一下我的解决思路。希望能给大家一些帮助吧。
方法一：线上图片
小程序体积大是因为static目录的图片资源过大的话，我们可以将static的图片上传图片服务器上去，小程序使用链接的形式来下载使用图片。
静态图片使用线上地址，不要放到项目中，除了navBar的icon，因为那个只能使用本地资源，相对来说这个不大。
1、上传图片资源到图片服务器上去
将切好的图片上传到图片服务器上面，
比如 https://www.xxxxxxxx.com.cn/wx/static/images/1.png
2、处理JS和vue中的图片引用
2.1、定义JS全局变量
在main.js页面定义js全局变量
Vue.prototype.staticDir = 'https://www.xxxxxxxx.com.cn/wx/static/'; Vue.prototype.getStaticFilePath = function (url) { return Vue.prototype.staticDir + url; } 2.2、替换vue中的图片地址
以前我们引用的图片地址是下面这样的：
&lt;view class="demo"&gt; &lt;image src="/static/images/1.png"&gt;&lt;/image&gt; &lt;/view&gt; 现在我们修改src成这样即可：
&lt;view class="demo"&gt; &lt;image :src="getStaticFilePath('/images/1.png')"&gt;&lt;/image&gt; &lt;/view&gt; 3、处理css中的图片引用
uniapp根目录下有一个特殊的文件uni.scss，在代码中无需 import 这个文件即可在scss代码中使用这里的样式变量。uni-app的编译器在webpack配置中特殊处理了这个uni.scss，使得每个scss文件都被注入这个uni.scss，达到全局可用的效果。我们将scss的static目录变量放到这里，即可全局使用了。
3.1、定义scss全局变量
在uni.scss的最后添加：
// 背景图片路径
$custom-bg-img-url:'https://www.xxxxxxxx.com.cn/wx/static/';
3.2、css文件改名成scss文件
将原来的css文件改名成scss文件，并像下面这样修改vue中的引用。加上了lang=“scss”
&lt;style scoped lang="scss"&gt; &lt;/style&gt; 3.3、替换css中的图片地址
以前css中的背景图地址是下面这样的：
.bgimg { width: 40rpx; height: 40rpx; background-image: url(/static/imags/1.png); background-size: cover; } 现在我们修改url成这样即可：
.bgimg { width: 40rpx; height: 40rpx; background-image: url($custom-bg-img-url+'/images/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76f0ab1463885f70d083a17f019e81bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77ad92e13983dd3d2b1e202c3e070dee/" rel="bookmark">
			ubuntu16.04安装vscode遇到的code 依赖于 libnss3 (＞= 2:3.30)解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu16.04安装vscode遇到的code 依赖于 libnss3 (&gt;= 2:3.30)；然而：系统中 libnss3:amd64 的版本为 2:3.28.4-0ubuntu0.16.04.14解决方法
一开始下载了最新版本的vscode，安装时出现了上面的错误状况，最新版本的依赖库版本过低的问题，于是下载之前的版本试了一下，成功安装
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fdd7a73f8de0ddec01cf74053f6aa1d/" rel="bookmark">
			内存管理-分页、虚拟地址、虚拟内容、页面置换算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、5W2H角度分析内存管理What是内存管理Why需要内存管理Who使用内存管理Where内存管理应用When需要内存管理How内存管理工作How much内存管理的成本 二、分页什么是分页分页的原理分页的优缺点分页的应用 三、虚拟地址什么是虚拟地址虚拟地址的作用虚拟地址的转换虚拟地址的优缺点 四、虚拟内存什么是虚拟内存虚拟内存的实现虚拟内存的管理虚拟内存的优缺点 五、页面置换算法什么是页面置换算法常见的页面置换算法页面置换算法的实现页面置换算法的优缺点 一、5W2H角度分析内存管理 What是内存管理 内存管理是指操作系统对计算机内存资源进行有效分配和利用的过程。它涉及到内存的分配、回收、保护和共享等方面的工作。
Why需要内存管理 内存管理的目的是为了最大限度地提高计算机的性能和效率。通过合理地管理内存资源，可以避免内存溢出、提高程序的执行速度和响应能力。
Who使用内存管理 内存管理主要由操作系统负责，但是应用程序也需要使用内存管理来分配和释放内存资源。
Where内存管理应用 内存管理应用于计算机的操作系统和应用程序中。
When需要内存管理 内存管理在计算机启动时就开始工作，直到计算机关闭。它在操作系统运行过程中，以及应用程序执行过程中都起到重要作用。
How内存管理工作 内存管理通过分配和回收内存空间来管理内存资源。它使用数据结构来记录内存的使用情况，并通过调度算法来决定哪些内存空间可以分配给应用程序。
How much内存管理的成本 内存管理的成本包括内存分配和回收的开销，以及管理内存使用情况所需要的数据结构和算法的开销。这些成本会影响计算机的性能和效率。
二、分页 什么是分页 分页是一种内存管理技术，将物理内存划分为固定大小的页框，将逻辑地址空间划分为相同大小的页。通过页表的映射关系，将逻辑地址转换为物理地址。
分页的原理 分页的原理是将逻辑地址分割成页号和页内偏移两部分，通过页表的映射关系，将页号转换为物理内存的页框号，再加上页内偏移，得到最终的物理地址。
分页的优缺点 分页的优点是可以提高内存的利用率，减少内存碎片。但是它也会增加内存访问的开销，因为需要进行地址转换。
分页的应用 分页广泛应用于操作系统和应用程序中，可以提供更大的地址空间，支持更多的进程同时运行。
三、虚拟地址 什么是虚拟地址 虚拟地址是指应用程序使用的地址空间，它是相对于物理内存的地址，可以通过地址转换得到物理地址。
虚拟地址的作用 虚拟地址的作用是为应用程序提供一个统一的地址空间，使得程序可以独立于物理内存的具体情况。
虚拟地址的转换 虚拟地址通过页表的映射关系，转换为物理地址。页表记录了虚拟页号和物理页框号之间的映射关系。
虚拟地址的优缺点 虚拟地址的优点是可以提供更大的地址空间，支持更多的进程运行。但是它也增加了地址转换的开销，会影响程序的执行速度。
四、虚拟内存 什么是虚拟内存 虚拟内存是一种将磁盘空间作为辅助内存使用的技术。它将部分程序和数据存储在磁盘上，只在需要时才将其加载到物理内存中。
虚拟内存的实现 虚拟内存的实现需要使用页表和页面置换算法。页表记录了虚拟页号和物理页框号之间的映射关系，页面置换算法用于决定哪些页面需要被置换出去。
虚拟内存的管理 虚拟内存的管理包括页面的加载和置换，以及页面的保护和共享等方面的工作。操作系统负责管理虚拟内存，提供相应的系统调用接口。
虚拟内存的优缺点 虚拟内存的优点是可以提供更大的地址空间，支持更多的进程运行。同时它也可以提高程序的执行速度，减少内存碎片。但是它会增加内存访问的开销，影响系统的响应能力。
五、页面置换算法 什么是页面置换算法 页面置换算法是一种用于决定哪些页面需要被置换出去的算法。当物理内存不足时，需要将一部分页面置换到磁盘上，以便为新的页面腾出空间。
常见的页面置换算法 常见的页面置换算法有FIFO（先进先出）、LRU（最近最少使用）、LFU（最不经常使用）等。它们根据页面的访问情况来决定哪些页面需要被置换出去。
页面置换算法的实现 页面置换算法的实现需要使用数据结构来记录页面的访问情况，以及相应的算法来决定哪些页面需要被置换出去。
页面置换算法的优缺点 页面置换算法的优点是可以提高内存的利用率，减少内存碎片。但是不同的算法适用于不同的场景，各有优缺点。有些算法可能会导致页面频繁置换，影响系统的性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6d9c12390c12c224f17de7dd7bb0d79/" rel="bookmark">
			GEOJSON/XYZ格式在线转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GEOJSON与XYZ格式简介 GeoJSON是一种对各种地理数据结构进行编码的格式，基于JavaScript对象表示法（JavaScript Object Notation，简称JSON）的地理空间信息数据交换格式。GeoJSON对象可以表示几何、特征或者特征集合。GeoJSON支持下面这几种几何类型：点、线、面、多点、多线、多面和几何集合。GeoJSON里的特征包含一个几何对象和其他属性，特征集合表示一系列特征。概述一个完整的GeoJSON数据结构总是一个（JSON术语里的）对象。在GeoJSON里，对象由名/值对--也称作成员的集合组成。对每个成员来说，名字总是字符串。成员的值要么是字符串、数字、对象、数组，要么是下面文本常量中的一个："true"、"false"和"null"。数组的值是上面所说的元素组成。
XYZ格式是一种最简单的点云数据格式之一。它将每个点的坐标值按行排列，每一行表示一个点，依次记录x、y和z坐标。该格式没有额外的元数据或点的属性信息，只包含点的位置信息。这种格式的优点是简单直观，易于处理和解析，但缺点是不能存储其他与点相关的属性信息。
GEOJSON格式转换成XYZ格式 GEOJSON格式和XYZ格式都有广泛的用途，在模型应用工作中，经常需要将GEOJSON格式转换成XYZ格式，怎么将GEOJSON格式在线转换成XYZ格式呢？推荐一款在线模型转换工具：GEOJSON转XYZ网站。
GEOJSON转XYZ网站是3D模型在线转换工具集中的一个，网站提供多种模型格式文件之间进行互转，支持将GEOJSON格式在线转换为XYZ格式。
文件上传 在打开的格式转换页面中，点击【上传文件】，选择待转换的目标文件。
如果模型文件包含有附属文件（如材质贴图），则需要将文件同时上传。上传方式：点击【上传文件】，在文件选择框中，按住键盘上的【Shift】键，通过鼠标左键同时选择多份文件，进行文件上传。
GEOJSON转XYZ网站也支持通过拖拽的方式，将文件进行上传。在资源管理器中，选择一份或多份模型相关文件，拖拽至GEOJSON转XYZ网站中的文件接收区域，即可完成3D模型文件的上传。
格式转换 在将模型文件上传至GEOJSON转XYZ网站后，网站将自动完成模型格式的转换。
GEOJSON转XYZ模型格式需要花费一些时间，转换时间长度主要与模型的大小和面数相关，文件越大、模型面数越多，转换需要的时间就越长。
在等待一段时间后，网站完成了模型格式的转换，展示页面如下。
在GEOJSON转XYZ网站完成模型格式转换完成后，此时可以在线预览模型转换结果，可以直接下载转换结果，也可以继续转换下一个模型。
模型预览 点击GEOJSON转XYZ网站页面中的【预览】按钮，在新开页面中对模型文件进行在线预览。
GEOJSON转XYZ网站在进行模型格式在线转换时，支持对顶点颜色和图片纹理进行处理，转换后的模型，不仅保留了基础的模型结构，还保留了模型的顶点颜色和图片纹理。
模型下载 在GEOJSON转XYZ网站的转换页面会预览页面中，点击【下载】按钮，网站会自动生成模型文件的下载链接。
通过GEOJSON转XYZ网站生成的下载链接，可以将XYZ格式的模型文件下载到本地。生成的下载链接24小时内有效，超时将不能下载，需要及时下载文件。
以上就是GEOJSON格式和XYZ格式的介绍，以及GEOJSON格式转换成XYZ格式的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1c23e6dc0737ef29abdcaad4ed85888/" rel="bookmark">
			基于51单片机的汽车智能灯光控制系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景意义
随着日益成熟的交通网络的发展，汽车成为了人类出行不可缺少的交通工具。交通事故的频繁发生成为了人们日渐担忧的问题，人们更加关心汽车的安全性能。根据报道的数据显示，我国夜间发生的交通事故中，70%左右是由于违章使用氙气灯造成灯光炫目，使驾驶员无法看清前方路况而发生的。照明系统是汽车主动安全的重要组成部分之一，如今汽车前照灯灯光光型单一的传统照明系统已经无法跟上当前汽车安全性能发展的趋势；所以，为了减少交通事故的发生，考虑到汽车的人性化设计。本文采用 STC89C51 单片机设计了一款自动切换远近光的汽车前照灯系统。这种前照灯系统更加智能化，能消除存在的安全隐患。
2.功能介绍
整体系统的工作分了两种模式，手动和自动模式，手动状态就是可以根据用户主动按按键去控制打开关闭远近光灯，自动状态下，首先需要通过按键来设置远近光灯自动切换的距离和开启远近光灯的光强阈值数据，由光敏电阻来检测当前环境的光强，当当前光强小于我们所设置的光强阈值，说明此时环境光比较暗，开启灯光，但是，开启远光还是近光灯就由超声测距得到的数据来决定，如果所测得的数据小于我们所设置的距离数据，说明前方人或其他物体，此时开启近光灯，否则开启远光灯。
方案论述（不少于两种实现此功能的方案论证，对比分析优缺点） 本次课程设计预有两种芯片供选做汽车智能灯光控制的核心，分别是：STC89C51和AT89S51芯片。测量距离提供两种选择：（1）使用TOF050C激光测距模块，测量距前车的距离。（2）使用HC-SR04超声波测距模块。光照强度提供一种选择：光敏电阻。
这样相配后可得到四种方案可供选择：（1）STC89C51+TOF050C+光敏电阻；（2）STC89C51+HC-SR04+光敏电阻；（3）AT89S51+TOF050C+光敏电阻；（4）AT89S51+HC-SR04+光敏电阻。比较芯片：STC89C51具有8KB ROM 存储空间,512字节数据存储空间，带有2K字节的EEPROM存储空间，与MCS-51系列单片机兼容，价格在7.5元左右。AT89S51片内具有8K字节程序存储空间，256字节的数据存储空间没有EEPROM存储空间，也与MCS-51系列单片机兼容，价格在11元左右。两种芯片都可以满足温度报警器的设计要求，但是综合价格比较，STC89C51显然更加划算，故选用STC89C51。比较测距模块：TOF050C模块需要四个引脚与单片机相连，编程相对困难，价格在28块左右；HC-SR04模块只需两个引脚即可测得距离，价格普遍在六块左右。两种都可以满足测距要求，但是出于成本考虑，HC-SR04测距模块显然更加划算，故选择用HC-SR04。所以最终选择STC89C51+HC-SR04+光敏电阻方案。
三、方案设计
1.器件的选型，功能模块的介绍
1.1单片机简介
单片机是STC公司最新推出的一种新型51内核的单片机。片内含有Flash程序存储器、SRAM、UART、SPI、PWM等模块。在这里我们选择STC89C516RD单片机，封装图如下图：
图 1 STC89C51引脚图
1.1.1主要特性
（1）高集成度，体积小，高可靠性 单片机将各功能部件集成在一块晶体芯片上，集成度很高，体积自然也是最小的。单片机程序指令，常数及表格等固化在ROM中不易破坏，许多信号通道均在一个芯片内，故可靠性高。 （2）控制功能强 为了满足对对象的控制要求，单片机的指令系统均有极丰富的条件:分支转移能力，I/O口的逻辑操作及位处理能力，非常适用于专门的控制功能。 （3）低电压，低功耗，便于生产便携式产品 。为了满足广泛使用于便携式系统，许多单片机内的工作电压仅为1.8V～3.6V，而工作电流仅为数百微安。
1.2 LCD1602液晶简介
显示部分则主要用于显示温度与温度的上下限度。在日常生活中，我们对液晶显示器并不陌生。液晶显示模块已作为很多电子产品的通用器件，如在计算器、万用表、电子表及很多家用电子产品中都可以看到，显示的主要是数字、专用符号和图形。在单片机与人的人机交流界面中，一般的输出方式有以下几种：发光管、LED数码管、液晶显示器。本设计中采用的是液晶显示器作为输出器件的。
在单片机系统中应用液晶显示器作为输出有以下几个优点：
显示质量高：由于液晶显示器每一个点在收到信号后就一直保持那种色彩和亮度，恒定发光，而不像阴极射线管显示器（CRT）那样需要不断刷新新亮点。因此，液晶显示器画质高且不会闪烁。
数字式接口液晶显示器都是数字式的，和单片机系统的接口更加简单可靠，操作更加方便。
体积小、重量轻：液晶显示器通过显示屏上的电极控制液晶分子状态来达到显示的目的，在重量上比相同显示面积的传统显示器要轻得多
低功耗：相对而言，液晶显示器的功耗主要消耗在其内部的电极和驱动IC上，因而耗电量比其它显示器要少得多。
字符型液晶显示模块是一种专门用于显示字母、数字、符号等点阵式LCD，目前常用16*1，16*2，20*2和40*2行等的模块。本设计采用的液晶显示器为1602字符型液晶显示器。
LCD显示的基本原理：
点阵图形式液晶由M×N个显示单元组成，假设LCD显示屏有64行，每行有128列，每8列对应1字节的8位，即每行由16字节，共16×8=128个点组成，屏上64×16个显示单元与显示RAM区1024字节相对应，每一字节的内容和显示屏上相应位置的亮暗对应。例如屏的第一行的亮暗由RAM区的000H——00FH的16字节的内容决定，当（000H）=FFH时，则屏幕的左上角显示一条短亮线，长度为8个点；当（3FFH）=FFH时，则屏幕的右下角显示一条短亮线；当（000H）=FFH，（001H）=00H，（002H）=00H，……（00EH）=00H，（00FH）=00H时，则在屏幕的顶部显示一条由8段亮线和8条暗线组成的虚线。这就是LCD显示的基本原理。
1.3 ADC0832简介
ADC0832是美国国家半导体公司生产的一种8位分辨率、双通道A/D转换芯片。由于它体积小，兼容性强，性价比高而深受单片机爱好者及企业欢迎，其目前已经有很高的普及率。学习并使用ADC0832可是使我们了解A/D转换器的原理，有助于我们单片机技术水平的提高。
ADC0832具有以下特点：
● 8位分辨率；
● 双通道A/D转换；
● 输入输出电平与TTL/CMOS相兼容；
● 5V电源供电时输入电压在0~5V之间；
● 工作频率为250KHZ，转换时间为32μS；
● 一般功耗仅为15mW；
● 8P、14P—DIP（双列直插）、PICC多种封装；
● 商用级芯片温宽为0°C to +70°C?，工业级芯片温宽为40℃ to +85℃
下面看看它的引脚及功能说明。
图 2 ADC0832引脚图
ADC0832引脚说明 （1） /CS片选使能，低电平有效。 （2） CHO模拟通道0，差分输入时，作为IN+或IN-使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1c23e6dc0737ef29abdcaad4ed85888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc1b44c9c5c8ee511570117ee2aee779/" rel="bookmark">
			Android 发布 aar 到 maven 仓库（maven 和 maven-publish 插件的区别）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自这篇文章：https://juejin.cn/post/7017608469901475847
在日常开发中，不可避免的需要把自己的 library 发布到 maven 仓库中，这样使用起来也更加方便。
发布 aar 包到 maven 仓库，主要是使用 Gradle 提供的插件：
maven 插件（旧版），在 Gradle 6.2 之后，就完全被弃用了（增加了 @Deprecated 注解）
maven-publish 插件
maven插件，是 Gradle 1.0 的时候提供的用于发布aar/jar包到 Maven 仓库的插件。在 Gradle 1.3 中，引入了一种新的发布插件，即：maven-publish ，这个新的插件引入了一些新概念和新功能，使 Gradle 发布功能更加强大，现在是发布工件的首选选项。
一、基本概念 1、什么是POM？ POM（Project Object Model）指项目对象模型，用于描述项目构件的基本信息。一个有效的 POM 节点中主要包含一下信息：
配置描述举例（‘com.github.bumptech.glide:glide:4.11.0’）groupId组织 / 公司的名称com.github.bumptech.glideartifactId组件的名称glideversion组件的版本4.11.0packaging打包的格式aar/jar 2、 什么是仓库（repository）？ 在项目中，我们会需要依赖各种各样的二方库或三方库，这些依赖一定会存放在某个位置（Place），这个 “位置” 就叫做仓库。使用仓库可以帮助我们管理项目构件，例如 jar、aar 等等。
主流的构建工具都有三个层次的仓库概念：
1、本地仓库： 无论使用 Linux 还是 Window，计算机中会有一个目录用来存放从中央仓库或远程仓库下载的依赖文件；2、中央仓库： 开源社区提供的仓库，是绝大多数开源库的存放位置。比如 Maven 社区的中央仓库 Maven Central；3、私有仓库： 公司或组织的自定义仓库，可以理解为二方库的存放位置。 构建时搜索依赖的顺序如下：
1、在本地仓库搜索，如果搜索不到，执行步骤 2；2、在中央仓库和私有仓库中搜索，搜索顺序按照repositories中声明的顺序依次查找。如果找到，则下载依赖文件到本地仓库，否则执行步骤 3；3、如果最终找不到依赖项，则抛出错误 “无法找到依赖项”。 了解这些基本概念之后，下面就介绍一下，通过 Gradle 提供的 maven 插件 和 maven-publish 插件，如何发布aar/jar包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc1b44c9c5c8ee511570117ee2aee779/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76edb44ccf6f06cb708784a092e7ba1/" rel="bookmark">
			用代码在C和C&#43;&#43;环境中实现中缀表达式转后缀表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中缀表达式转后缀表达式的原理
入栈的几种情况：1，栈为空
2.入栈元素的优先级比栈栈顶元素高
3.入栈的元素为‘(’（注意：当入栈元素为’)'号时会输出栈中元素直到遇到‘(’）
代码思路
分为一下几种情况：
1.输入字符为数字
2.输入字符为‘)’
3.输入字符为+、-
4.输入字符为*、/、(
5.其他情况，非法输入
1.下面展示在C环境中的代码：
#include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; #define Maxsize 100 //以上是用宏定义一个Maxsize为100 typedef char ElemType; //将数据类型char命名一个别名ElemType,可以理解为ElemType等同于char typedef struct { //定义一个名为SqStack的结构体类型，date[Maxsize]用来元素，top表示数组最后一位元素的下标，也就是栈顶元素下标 ElemType date[Maxsize]; int top; }SqStack; void InitStack(SqStack* S) { //对结构体进行初始化 S-&gt;top = -1; //将栈顶元素下标初始化为-1，表示当前栈内元素为空， } bool StackEmpty(SqStack S) { //判断结构体是否为空，为空返回true，不为空返回false if (-1 == S.top) return true; else return false; } bool PushStack(SqStack* S, ElemType m) { //添加元素进栈,添加成功返回true，添加失败返回false, if (S-&gt;top &lt;= Maxsize - 1) //栈未满，元素可以放进栈中 { S-&gt;date[++(S-&gt;top)] = m; //这段代码可以分两步理解，S.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c76edb44ccf6f06cb708784a092e7ba1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a20c20653a71775c45fc14b58f00183b/" rel="bookmark">
			SpringBoot毕业设计不知道怎么选题？500道 SpringBoot 毕业设计题目（建议收藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是程序员徐师兄。最近，有挺多同学跟我咨询，说，老师指定了毕业设计要使用 SpringBoot技术，但是自己无从下手，不知道怎么选题好？
徐师兄作为过来人，可以给你一些选题上的建议
自己选题的不要凭空进行想象，一定要做到不能盲目选题，定题目一般不允许更改的，意味着以后要实全力以赴实现题目对应的功能（要在可控范围内），要结合自身现实情况来选择难度和自己所在学校现阶段符合的。有些看似简单问题，实际不符合现阶段，成本也会成倍增加，如果有选题/开题不明白的地方可以与我随时沟通，欢迎打扰。老师指定，尽量避开一些科研题目，除非是老师做好的，就是让你拿来用的，要结合自己了解层次，学习成本太高的直接和老师进行沟通。如果老师不能完整的帮到自己，申请换题目。可以在网上或者 Github 先搜一下，看有没有相关的源码借鉴，做到心中有数 第一部分 博主介绍：✌程序员徐师兄、7年大厂程序员经历。全网粉丝30W+,Csdn博客专家、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和毕业项目实战，博主网站✌
1 springboot食品安全管理系统(vue)
2 springboot早餐店点餐系统(vue)
3 springboot旅游路线规划系统
4 springboot保险信息网站(vue)
5 springboot某计算机等级考试报名系统(vue)
6 springboot药品信息管理系统
7 springboot某大学外卖系统
8 springboot驾校信息管理系统
9 springboot线上阅读系统
10 springboot在线图书销售系统(vue)
11 springboot房源出租信息系统
12 springboot艺术水平考级报名管理系统(vue)
13 springboot汽车改装方案网站(vue)
14 springboot鞋类商品购物商城系统
15 springboot二手图书交易平台(vue)
16 springboot养老服务管理系统(vue)
17 springboot小区物业管理系统
18 springboot二次元商品购物商城
19 springboot技术的在线考试系统(vue)
20 springboot乐器社区网站
21 springboot基于微服务框架的智慧商城平台
22 springboot街球社区网站(vue)
23 springboot响应式企业员工绩效考评系统(vue)
24 springboot中小企业财务管理系统
25 springboot基于B2C模式的电子商务平台(vue)
26 springboot高校学生党员发展管理系统(vue)
27 springboot电子商务系统(vue)
28 springboot大学生兼职系统
29 springboot学校田径运动会管理系统(vue)
30 springboot酒店客房管理平台
31 springboot员工信息管理系统(vue)1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a20c20653a71775c45fc14b58f00183b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aabc67c9aec9bdf91a0c92563f9ffe6c/" rel="bookmark">
			比特听命：补码的产生过程与整数在计算机中的存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 参考环境声明八位二进制加法器八进制数值 原码概念正负数与零正数与负数的运算 反码概念一步之遥 补码概念唯一的零加法运算 补码的优缺点优点简化算术运算一眼辨别正负性运算过程中无需对符号位进行处理 缺点不易阅读 参考 项目描述搜索引擎Bing、GoogleAI 大模型文心一言、通义千问、讯飞星火认知大模型、ChatGPT哔哩哔哩看得视频太多😭 环境 项目描述PHP5.5.0、5.6.8、7.0.0、7.2.5、7.4.9、8.0.0、8.2.9PHP 编辑器PhpStorm 2023.1.1（专业版）绘图工具draw.io 21.7.5 声明 八位二进制加法器 八位二进制加法器是一种 电子电路，用于 执行两个八位二进制数的加法操作。这种加法器可以将两个八位的二进制数相加，得出一个八位的二进制和。对此，请参考如下示例：
A: 1 0 1 1 0 1 0 1 B: 0 1 1 0 1 0 1 1 ----------------------- Sum: 1 1 0 1 1 1 0 0 在这个示例中，每一位的相加操作都遵循标准的二进制加法规则，包括 进位。如果两个位相加后的和大于 1，那么就会产生进位，这个进位会被加到下一位的操作中。如果进位将被应用在第九位二进制位中，则该进位将被抛弃。
八进制数值 在本篇文章中，我们都将 模拟八位二进制加法器进行加法操作。故将整数表示为八位二进制数，这并 不意味着 采用原码、反码及补码 仅能够 用于将整数转化为 八位 二进制数。
原码 概念 原码是一种整数的二进制表示方法，也被称为 符号-数值表示法。原码主要用于表示 有符号整数（正数、负数和零），在计算机系统中广泛使用。
在二进制数的原码表示中，二进制数被分为了 两部分，即 符号位 与 数值具体数值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aabc67c9aec9bdf91a0c92563f9ffe6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e9f68308b2626a096b781180b51ad33/" rel="bookmark">
			【springboot3.x 记录】spring-cloud-gateway 2022踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近升级springboot3、springcloud微服务真是一挖一个坑，特此记录一下
一、openfeign 循环依赖问题 springcloud升级到 2022.0.4 后，启动项目发现提示 循环依赖 异常。
从上面图也能清楚地看到，就是A依赖B，B依赖C，C又依赖A，导致循环依赖。
翻查了一下github的 issue ，发现有人也遇到此类问题，如下图，原来早在2019年的时候，已经是不支持在 filter 里面使用 feign 调用了。
而且在2020版的 Spring Cloud Gateway 也已经移除了 robbion。
目前能找到的解决方式有两种：
1）改用 webclient
提及比较多的是这个项目 feign-reactive ，但是对于笔者而已对现有项目的改动比较大，最终没有采纳，大家有兴趣可以看看。
这里也有一篇文章有介绍如何使用 Reactive Feign
2）使用 @Lazy 注解
这个估计是目前最简单的方式，使用的延迟加载的方式来规避
刚好，给我发现了一篇文章，说到了这个类似的问题的原因，博主一步步debug源码分析，传送门
大致的问题出在框架本身、 feign client 加载 、过滤器加载顺序有关，导致最终被加载了两次，具体的分析方法文章博主也很详细的说明，在此就不再描述。
这里也有一篇文章是关于 GatewayAutoConfiguration 源码分析，有兴趣的也可以看一下。
二、异步问题 如果使用 @Lazy 注解方式来解决 循环依赖问题，那么马上又迎来第二个问题，异步调用问题。
java.lang.IllegalStateException: block()/blockFirst()/blockLast() are blocking, which is not supported in thread reactor-http-nio-3 at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:83) Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: Error has been observed at the following site(s): |_ checkpoint ⇢ org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e9f68308b2626a096b781180b51ad33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa32c7374bf51959c2c5bdd12bed53a1/" rel="bookmark">
			BP神经网络及python实现（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、误差逆传播算法
二、BP算法实现流程图
三、BP神经网络推导
3.1 前向传播
3.2 反向传播
四、Python实现BP神经网络
4.1 激活函数sigmod
4.2 构造三层BP神经网络
4.2.1 BP神经网络初始化
4.2.2 前向传播
4.2.3 反向传播
4.2.4 迭代训练
4.3 算法检验——预测数据
4.4 图解总结
五、运行结果
六、整体总结
七、总代码
写在前面：
本篇文章关于BP神经网络的算法实现相对来说通俗易懂，讲解下至关于函数变量的解释，上至关于BP算法中涉及的前向传播及反向传播的原理、再至其过程中涉及的公式详细推导都有笔者的一些思考笔记。本文也对标准的BP神经网络进行几处改进，目的都是为了提高训练速度。另外，若文章存在一些理论错误请各位不吝赐教，当然，在阅读过程中若有些地方不明白可以在评论区留言！
一、误差逆传播算法 误差逆传播算法的大概流程为：
1、初始化网络中所有连接权和阈值；
2、进入迭代训练：
(1）根据当前参数计算当前样本的输出；
(2）根据下面公式计算输出层神经元的梯度项gj：
（3）根据下面公式计算隐层神经元的梯度项eh：
（4）根据下面公式更新连接权whj、vih与阈值θj、γh：
3、训练完成后输出连接权和阈值确定的多层前馈神经网络；
二、BP算法实现流程图 标准的BP流程图属于单样本训练，假设总共有样本个数为P，其中第i个样本为p，训练次数用q表示，训练完成来源是设置的误差阈值和实际误差对比，达到要求时结束。
左面是标准BP的算法流程，权值调整方法是是基于单样本训练的，但是单样本训练遵循的是只顾眼前的这个数据产生的误差进行调节权值调整，这样的后果是当训练数据很多时，计算量就会急剧增加，导致收敛速度过慢。为了改变这些缺点，我们采用另外一种方法就是在所有样本输入以后，计算网络的总误差，然后根据总误差计算各层的误差信号并调整权值，这种累积的误差的批处理方式称为批（batch）训练或者（epoch）训练。由于批训练遵循了以减小全局误差为目标的“集体主义”原则也就是所有的训练样本。在保证总误差向减小方向变化时，即使训练样本很多，训练时的收敛速度也是很快的。
三、BP神经网络推导 我们只讨论三层的BP神经网络，又称三层感知机。所谓三层，即包括输入层、隐层、输出层。三层感知机的神经元连接形式：
3.1 前向传播 图解：
此处要对三层BP网络中不同符号所代表的意思理解，下面进行符号说明：
符号说明：
输入层、隐层、输出层神经元的个数分别为d、q、l；
xi ：最初第i个神经元的输入；
vih ：输入层第i个神经元和隐层第h个神经元的权值；
αh：隐层第h个神经元的输入；
γh：隐层第h个神经元的阈值；
bh ：隐层第h个神经元的输出；
whj ：隐层第h个神经元与输出层第j个神经元的权值；
βj：输出层第j个神经元的输入；
θj：输出层第j个神经元的阈值；
yj ：输出层第j个神经元的输出； 激活函数f(x)一般有对数几率函数sigmoid、双曲正切函数tanh等等：
3.2 反向传播 在前向传播计算完成后，需要通过误差逆传播算法对误差进行反向传播修改权值和阈值，相关公式推导如下：
下面通过python代码实现上述BP网络的流程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa32c7374bf51959c2c5bdd12bed53a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756043a5eddd6b3f35ef9c917269964f/" rel="bookmark">
			2023全新车型汽车配置参数数据库大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本人的店铺：全车型汽车数据库(点击打开链接)，数据持续更新中。。。 本人对网络数据比较感兴趣，加上自己也是从事汽车行业的工作，所以意识到汽车配置数据库对于汽车销售，汽车售后服务都非常的重要。
1、概述：车型的汽车配置、品牌Logo、车系展示图数据库，可做三级车型查询，适用于汽车类网页开发；
使用本数据库做成的网页效果（亲测页面）：
数据截图如下：
品牌表
车系表
车型表
Logo
车系展示图-无水印
本人的店铺：全车型汽车数据库(点击打开链接)，数据持续更新中。。。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ee91601462f48936c1c68760877ca15/" rel="bookmark">
			[记录]基于Flask Web全栈开发实战（黄勇·著）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flask 学习 flask 项目配置 Debug模式 Host、Port配置 from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello World!' if __name__ == '__main__': app.run() 在pycharm中，设置debug模式和port端口号
# 在非pycharm中，设置debug模式 if __name__=='__main__': app.run(debug=True) # 在非pycharm中，设置host和post if __name__=='__main__': app.run(debug=True,host='0.0.0.0',port=9000) # port必须是整数，不能设置为字符串 在app.config中添加配置 from flask import Flask app = Flask(__name__) # cofig 配置项，配置项的名称必须大写 app.config['SECRET_KEY']='sknrek349Lx!@#' # 使用python配置 # 在文件夹中创建一个config.py文件 # 文件内容的代码如： TOKEN_KEY = "123456" 加载配置文件
from flask import Flask import config app = Flask(__name__) app.config.from_object(config) print(app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ee91601462f48936c1c68760877ca15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62361df95da3187aec6b7757b09c6c3e/" rel="bookmark">
			怎么在谷歌浏览器中安装.crx扩展名的离线chrome插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提概要： 其实，如果用户可以正常打开chrome商店，那么用户可以搜索找到对应的插件在线安装。问题现在用户很可能无法打开chrome商品。那么 怎么样将已经下载好的 chrome插件 (.crx
前提概要：其实，如果用户可以正常打开chrome商店，那么用户可以搜索找到对应的插件在线安装。问题现在用户很可能无法打开chrome商品。那么怎么样将已经下载好的chrome插件(.crx)文件安装到chrome谷歌浏览器中呢？
工具/原料： 1. chrome插件安装包（.crx文件）
2. 谷歌浏览器
方法/步骤： 1. 找到需要按照的chrome插件或者chrome扩展程序的安装包。可以在本站搜索你要找到插件,也可以从好友分享那边找到相应的chrome插件。
2. 打开chrome浏览器，击谷歌浏览器右上角的自定义及控制按钮（点击浏览器右上角的三条横线），在下拉框中选择工具选项，如下图所示：
或者在chrome中新开一个TAB，输入：chrome://extensions/ 回车，打开应用管理器
3.把已经下载好的Chrome离线安装文件xxx.crx文件，将其从资源管理器中拖动到Chrome的扩展管理界面中，这时候用户会发现在扩展管理器的中央部分中会多出一个”拖动以安装“的插件按钮。以“check my cookies”为例，如下图所示：
4.松开鼠标后会提示确认安装的提醒，如下图所示。用户确认就可以把当前正在拖动的插件安装到谷歌浏览器中去
5.安装成功后，在浏览器的右上角会出现如下图所示的提示信息：（如果看不到，请关闭chrome浏览器重新打开）如果没有插件按钮的话，用户还可以通过Chrome扩展管理器找到已经安装的插件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f84ab68430a1b01a0d38fba383bb323/" rel="bookmark">
			VSCode自定义代码块详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：点击文件-首选项-用户代码片段 第二步：选择代码块作用域的文件类型 类型一：全局作用域 这种类型的代码块是创建在vscode软件内部的文件。是跟随这当前安装的vscode这个软件的，不会随着项目的关闭而失效，会一直存在。类型二：文件夹作用域 这种类型的代码块是创建在某个文件下.vscode这个隐藏文件夹中的，这个代码块只适用于当前文件夹，出了这个文件夹就不能使用这个代码块了类型三：特定文件类型作用域 这种类型的代码块跟全局作用域的文件路径是一致的，都是创建在了vscode中，会一直存在。但是这种代码块只适合于你指定的文件类型。比如：如果你创建的是JavaScript类型，那这个代码块就不能再vue文件中使用。 注意三种类型的代码块书写规范都是一致的 第三步：代码块的书写 我们选择一种类型（我这里选择全局作用域类型），并且给这个文件起一个名字， ps:名字随便起
我们需要在这对大括号中书写我们的代码块，这里系统给了我们一个例子Example下方就是一个例子。下方是我自己书写的一个代码块
所有的代码段都必须写在最外层大括号中，每个代码块之间用逗号隔开，一个代码块就类似一个对象。
上方代码就是简单写了两个代码块。 接下来介绍每个属性的作用及方法。 scope：作用文件类型。就是代码块的作用文件类型，这里我们可以指定文件类型，多种类型之间用逗号隔开，
比如如果指定作用范围类型"css, javascript" 那么这个代码块只能在这两种类型的文件中起作用。
如果值为空，或者是不写这个属性，默认所有类型文件都支持该代码块。
在特定文件类型中这个值是不起作用的，写了会报错，因为这种类型已经本身已经限制了文件类型 prefix： 触发代码块的字符串。写代码的时候我们只需敲出这个字符串就会触发我们的代码块。 body：代码块的主体内容。我们需要把我们的代码书写在这个属性中。仔细观察我们可以看出，代码块主体就是字符串的数组。 description：代码块的简单介绍，我们可以介绍一下这段代码块是干什么用的
代码主体的书写规范：
每个字符串元素就代表一行，行与行之间用 , 隔开表示换行。或者使用\n换行
行内不能使用tab键缩进，只能使用空格或者\t缩进
\1使用代码块敲击回车或者tab键后光标定位的位置。2 34...表示我们按下tab光标依次出现的位置
第四步：代码块的使用
使用代码块的方式非常简单，我们只需在想要书写的位置敲出触发我们代码块的关键字就行 全局作用域的代码块：
努力不一定会成功，但一定会有收获
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36e014acd31b3a459ab998662152c539/" rel="bookmark">
			目录启示：使用 use 关键字为命名空间内的元素建立非限定名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 参考环境三种名称非限定名称限定名称完全限定名称举个栗子 useuse 关键字use ... as .. 命名冲突真假美猴王两个世界 参考 项目描述搜索引擎Bing、GoogleAI 大模型文心一言、通义千问、讯飞星火认知大模型、ChatGPTPHP 官方PHP ManualPHP 官方language.namespaces.rationale.php 环境 项目描述PHP5.5.0、5.6.8、7.0.0、7.2.5、7.4.9、8.0.0、8.2.9PHP 编辑器PhpStorm 2023.1.1（专业版） 三种名称 在 PHP 命名空间的上下文中，限定名称 (Qualified Name)、非限定名称 (Unqualified Name) 与完全限定名称 (Fully Qualified Name) 是 三种引用命名空间中的元素（类、接口、函数 与 常量）的方式。
非限定名称 非限定名称是一个 不包含任何命名空间前缀的名称，如 ClassName 就是一个非限定名称。当使用非限定名称时，PHP 会 优先在当前命名空间中查找该元素。若该原始不存在于当前命名空间中，则将在全局命名空间中对其进行查找（仅当被查找元素为函数或常量时）。
限定名称 限定名称包含 命名空间前缀，但没有开头的反斜线 \（该反斜线表示全局命名空间）。如 NamespaceName\ClassName 与 NamespaceName\functionName() 就是限定名称。当使用限定名称时，PHP 会 基于当前命名空间来解析该名称。
完全限定名称 完全限定名称从反斜线 \（该反斜线表示全局命名空间） 开始，后接命名空间或元素的名称。如 \Full\NamespaceName\ClassName 与 \Full\NamespaceName\functionName() 就是完全限定名称。当使用完全限定名称时，PHP 会 完全忽略当前命名空间的上下文，并从全局上下文解析名称。
举个栗子 &lt;?php namespace HOME\RedHeart { function saySelf() { # 通过魔术常量 __NAMESPACE 回当前所属的命名空间名称 return __NAMESPACE__; } function saySon() { # 尝试访问当前命名空间中的子命名空间 BinaryMoon 中的 saySelf() 函数 return BinaryMoon\saySelf(); } } namespace HOME\RedHeart\BinaryMoon { function saySelf() { return __NAMESPACE__; } } # 全局命名空间 namespace { # 尝试访问 HOME\RedHeart\BinaryMoon 命名空间下的 saySelf() 函数 var_dump(\HOME\RedHeart\BinaryMoon\saySelf()); # 尝试访问 HOME\RedHeart 命名空间下的 saySelf() 函数 var_dump(HOME\RedHeart\saySelf()); # 尝试访问 HOME\RedHeart 命名空间下的 saySon() 函数 var_dump(\HOME\RedHeart\saySon()); } 执行效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36e014acd31b3a459ab998662152c539/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a415840efeb245b68a2a63a49fb31383/" rel="bookmark">
			数据结构--链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 1.1定义 在计算机科学中，链表是数据元素的线性集合，其每个元素都指向下一个元素，元素存储上并不连续。
可以分类为5
单向链表，每个元素只知道其下一个元素是谁
双向链表，每个元素知道其上一个元素和下一个元素
循环链表，通常的链表尾节点 tail 指向的都是 null，而循环链表的 tail 指向的是头节点 head
链表内还有一种特殊的节点称为哨兵（Sentinel）节点，也叫做哑元（ Dummy）节点，它不存储数据，通常用作头尾，用来简化边界判断，如下图所示
1.2随机访问性能 根据 index 查找，时间复杂度 O(n)
1.3插入或删除性能 起始位置：O(1)
结束位置：如果已知 tail 尾节点是 O(1)，不知道 tail 尾节点是 O(n)
中间位置：根据 index 查找时间 + O(1)
2.单向链表 根据单向链表的定义，首先定义一个存储 value 和 next 指针的类 Node，和一个描述头部节点的引用
public class SinglyLinkedList { private Node head; // 头部节点 private static class Node { // 节点类 int value; Node next; ​ public Node(int value, Node next) { this.value = value; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a415840efeb245b68a2a63a49fb31383/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02d13ea74e65fbfd87fc57bc225df5b/" rel="bookmark">
			PLSQL中Initialization error解决办法及PLSQL位数查看方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 按照如下的路径配置好PLSQL的环境后
手动输入用户名、密码、数据库后，系统弹出报错提示，报错提示多分为两类
initialization error
Could not load “XXX”
OCIDDL forced to XXX
LoadLibrary(XXX) returned 0
这类报错表示：“初始化错误，不能加载oci.dll；oci.dll强制访问该路径后返回值为0”。
博主经过查阅，总结了产生错误产生的可能原因：
PLSQL与oci.dll位数不匹配，比如32位的PLSQL，无法使用64位的oci.dll动态连接库，这类错误有时候会在后面加上一句“Make sure you have the 64 bits Oracle Client installed ”即“请确认你安装的是64位的Oracle客户端”oci.dll访问路径错误 上述问题对应的解决方案如下：
在任务管理器中查看plsql位数（博主的win11系统，每个系统的任务管理器页面布局可能有所差别，但基本上32位系统会在后面标注如（32位）或者*32）
然后检查oci.dll位数，这里博主教大家一个暴力检查位数的方法（适用大多数的dll文件），将oci.dll文件复制到桌面，用记事本打开，找到乱码行的第一个PE，若后面是L表示的是32位，若为d则为64位。随后根据位数下载相匹配的plsql和oci.dll即可。
访问路径问题的解决方法就是判断路径是否错误或者路径下是否存在文件。在地址栏中输入的oci library地址，检查地址是否正确，若地址正确则可以访问。博主就是将oci.dll误输入为oci.ddl，肉眼检查多次都没有检查出来，真是万恶的deadline啊！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efebdeb02c148bd7cc906a33789cc056/" rel="bookmark">
			MyBatis自定义映射resultMap，处理一对多，多对一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、自定义映射resultMap 复习：查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射 关系
resultType：自动映射，用于属性名和表中字段名一致的情况 （或设置了下划线映射为驼峰）。
resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况
1.1、resultMap处理字段和属性的映射关系 若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射。
（补充：当字段名和属性名一样时，字段和属性是一 一对应的，jdbc会通过反射实现这种对应，所以，能查到完整的对象。当不一样时，又没有自己处理，那字段和属性就对应不上，查出来的对象属性全是null）
&lt;!-- select标签里的resultMap属性设置使用哪个映射规则 resultMap标签：设置自定义映射（自定义字段和属性的映射规则） 属性： id：表示自定义映射的唯一标识，即给你这个具体的映射规则resultMap起一个唯一名字 type：查询的数据要映射的实体类的类型 子标签： id标签：设置主键的映射关系 result标签：设置普通字段的映射关系。即你想要你的结果是怎么映射的，怎么一一对应填值的 association标签：设置多对一的映射关系。比如Employee类中有一个Department属性 collection标签：设置一对多的映射关系。比如Department类中有一个。List&lt;Employee&gt;属性 属性： property：设置映射关系中实体类中的属性名，必须是java中实体类的属性名 column：设置映射关系中的字段名.必须是sql查询出的某个字段（出现在sql查询语句的字段） 因为是自定义，所以，java中的属性名不是驼峰的也可，mysql里的属性不是_也可。 property和column的先后位置任意 --&gt; &lt;resultMap id="userResultMap" type="User"&gt; &lt;id property="userId" column="userid"&gt;&lt;/id&gt; &lt;result property="userName" column="user_name"&gt;&lt;/result&gt; &lt;result property="password" column="password"&gt;&lt;/result&gt; &lt;result property="age" column="age"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--List&lt;User&gt; testMohu(@Param("mohu") String mohu);使用刚才定义的映射规则--&gt; &lt;select id="testMohu" resultMap="userResultMap"&gt; &lt;!--select * from t_user where username like '%${mohu}%'--&gt; select id,user_name,password,age,sex from t_user where user_name like concat('%',#{mohu},'%') &lt;/select&gt; 若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则，实体类中的属性 名符合Java的规则, 此时也可通过以下3种方式处理字段名和实体类中的属性的映射关系
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efebdeb02c148bd7cc906a33789cc056/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/82/">«</a>
	<span class="pagination__item pagination__item--current">83/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/84/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>