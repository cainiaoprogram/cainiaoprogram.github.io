<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f00f47ac23fb560aa88f4510d5573b01/" rel="bookmark">
			VB.NET语法基础学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果代码看不懂，可以学习一下vb.net，vb.net视频教程
Visual Basic 2010 2012 2013 从入门到精通|xin3721自学网李天生老师亲自授课录制的,Visual Basic 2010 与 2012视频教程。https://www.xin3721.com/eschool/vbnetxin3721/
很久以来，VB因为缺乏完善的面向对象支持、缺乏高效的错误处理机制和性能表现不佳，因而一直受到某些人的嘲笑。VB.NET将彻底改变这种情况。然而，VB.NET在这些方面的改进也要付出代价，许多旧的代码需要手工进行转换才能在VB.NET下运行。
下面几个表格总结了VB.NET语言在语法上的改动之处。注意这些表格并没有完全列出所有改动之处，但列出了最重要的一些改动。
表A对比了VB6中一些熟悉的语法形式及其在VB.NET中类似功能最接近的语法形式。
表A：语法对比旧语法 新语法 说明窗体装载事件，类初始化事件 Sub New procedure Sub New称为构造方法（Constructor），它可以有参数。
Property Let Property Set Let关键词不再有效。
Currency Decimal 在VB6中，Decimal是Variant的一种子类型，但在。NET中它是一种固有的数据类型。。NET不再支持Currency数据类型。
Variant Object VB.NET的Object数据类型兼有VB6 Object类型和Variant类型的能力。
Debug.Print Debug.Write Debug.WriteLine 这个变化只是名称上的简单变化：从Print变为Write和WriteLine. Wend End While VB.NET推荐使用While循环而不是Do循环。
为了让VB的数据类型和其他。NET语言的数据类型相匹配，Microsoft修改了整数类数据类型的表示方法，并加入了一个新的数据类型。这些改动对于进行外部调用的方法尤其重要（比如API调用）。例如，如果被调用函数需要一个32位的整数参数，则在VB6中它应该声明为Long，在VB.NET中应该声明为Integer.
表B：和整数有关的数据类型长度 VB6以及更早版本中的名称 VB.NET中的名称16 bit Integer Short 32 bit Long Integer 64 bit （无） Long
在VB.NET中，Microsoft减少了许多原先用于VB6的关键词，代之以“框架类”。之所以要进行这种替换，是因为框架类中的功能对所有的.NET语言都有效。下表列出了部分受影响的关键词。
表C：被替换的关键词
VB关键词 VB.NET名称空间中的位置 方法/属性
Circle System.Drawing.Graphics DrawEllipse
Line System.Drawing.Graphics DrawLine
Atn System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f00f47ac23fb560aa88f4510d5573b01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b6ce53a1cdf2ee4d3f16b939029b2b/" rel="bookmark">
			Torch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		torch的安装 torch的版本与python的版本是挂钩的，python低版本安装不了高版本的torch（亲测）。
python 3.6版本出问题
在下面的网站中找到 https://pytorch.org/
python版本将对应torch的版本
https://www.cnblogs.com/tingtin/p/13601104.html(对应关系表)
cuda官网
https://developer.nvidia.cn/cuda-toolkit-archive torch对应cuda版本 先配置好cuda然后再装torch
https://download.pytorch.org/whl/torch_stable.html
print(torch.version.cuda)
#-f表示在给定链接中发现版本 pip install torch===1.4.0+cu100 -f https://download.pytorch.org/whl/torch_stable.html torch_scatter对应的cuda版本 https://pytorch-geometric.com/whl/torch-1.4.0.html
检查torch是否可用 import torch torch.cuda.is_available() torch可用gpu的数量 import torch print(torch.cuda.device_count()) # 可用gpu数量 数据加载 torch.load()
*.pt文件保存了模型所有的参数load_state_dcit
而load_state_dict是net的一个方法
是将torch.load加载出来的数据加载到net中
源码详解 https://www.cnblogs.com/marsggbo/p/12075356.html
函数 one_hoe编码 https://blog.csdn.net/stay_zezo/article/details/121931429
F.one_hot(torch.Tensor([1,1,1]).long()) grad_fn grad_fn： grad_fn用来记录变量是怎么来的，方便计算梯度
https://blog.csdn.net/zphuangtang/article/details/112788037#:~:text=grad_fn%EF%BC%9A%20grad_fn%E7%94%A8%E6%9D%A5%E8%AE%B0%E5%BD%95,%E6%9F%A5%E7%9C%8Bx%E7%9A%84%E6%A2%AF%E5%BA%A6%E5%80%BC%E3%80%82
reset_parameters https://blog.csdn.net/weixin_43593330/article/details/107580084
repeat https://www.cnblogs.com/luckforefforts/p/13663529.html
mm和mul mm是矩阵相乘
mul是矩阵对应位相乘法
https://blog.csdn.net/qq_39938666/article/details/86004474
bmm 计算两个tensor的矩阵乘积
torch.contiguous() toch.contiguous() 与torch.view配合使用
https://blog.csdn.net/qq_37828380/article/details/107855070
torch.permute() 改变对应位置，则对用位置进行转置，例如tensor[0,1]和tensor[1,0]进行了位置的转换。
torch.gather 在某一维度上按照索引值取对应的元素
https://zhuanlan.zhihu.com/p/344962512
向量拼接 import torch A=torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8b6ce53a1cdf2ee4d3f16b939029b2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38c3c8cde7bb8eb242e9fe6dc539086d/" rel="bookmark">
			在docker 训练新环境中mmclassification装包遇见的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： python 3.6.9
已经安装sudo
现在要安装一些包
镜像是学长配的tensortrt8 容器是自己提的
问题描述 在MMlab里运行命令
python mmlab/mmclassification/tools/train.py mmlab/mmclassification/configs/tutorial/resnet50_finetune_cifar.py 问题1：发现 ModuleNotFoundError: No module named 'mmcv' root@407d147d301b:/# python mmlab/mmclassification/tools/train.py mmlab/mmclassification/configs/tutorial/resnet50_finetune_cifar.py Traceback (most recent call last): File "mmlab/mmclassification/tools/train.py", line 9, in &lt;module&gt; import mmcv ModuleNotFoundError: No module named 'mmcv' 问题2：”想使用pip下载 mmcv,发现pip没有
root@407d147d301b:/# pip install mmcv-full bash: pip: command not found 问题3：下载pip后发现找不到pip
root@407d147d301b:/# sudo apt install python3-pip Reading package lists... Done Building dependency tree Reading state information... Done python3-pip is already the newest version (9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38c3c8cde7bb8eb242e9fe6dc539086d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9851d3a592f93daf15ff3cae1f581c3/" rel="bookmark">
			深入剖析Redis客户端Jedis的特性和原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开篇
Redis作为目前通用的缓存选型，因其高性能而倍受欢迎。Redis的2.x版本仅支持单机模式，从3.0版本开始引入集群模式。
Redis的Java生态的客户端当中包含Jedis、Redisson、Lettuce，不同的客户端具备不同的能力是使用方式，本文主要分析Jedis客户端。
Jedis客户端同时支持单机模式、分片模式、集群模式的访问模式，通过构建Jedis类对象实现单机模式下的数据访问，通过构建ShardedJedis类对象实现分片模式的数据访问，通过构建JedisCluster类对象实现集群模式下的数据访问。
Jedis客户端支持单命令和Pipeline方式访问Redis集群，通过Pipeline的方式能够提高集群访问的效率。
本文的整体分析基于Jedis的3.5.0版本进行分析，相关源码均参考此版本。
二、Jedis访问模式对比
Jedis客户端操作Redis主要分为三种模式，分表是单机模式、分片模式、集群模式。
单机模式主要是创建Jedis对象来操作单节点的Redis，只适用于访问单个Redis节点。
分片模式（ShardedJedis）主要是通过创建ShardedJedisPool对象来访问分片模式的多个Redis节点，是Redis没有集群功能之前客户端实现的一个数据分布式方案，本质上是客户端通过一致性哈希来实现数据分布式存储。
集群模式（JedisCluster）主要是通过创建JedisCluster对象来访问集群模式下的多个Redis节点，是Redis3.0引入集群模式后客户端实现的集群访问访问，本质上是通过引入槽（slot）概念以及通过CRC16哈希槽算法来实现数据分布式存储。
单机模式不涉及任何分片的思想，所以我们着重分析分片模式和集群模式的理念。
2.1 分片模式
分片模式本质属于基于客户端的分片，在客户端实现如何根据一个key找到Redis集群中对应的节点的方案。
Jedis的客户端分片模式采用一致性Hash来实现，一致性Hash算法的好处是当Redis节点进行增减时只会影响新增或删除节点前后的小部分数据，相对于取模等算法来说对数据的影响范围较小。
Redis在大部分场景下作为缓存进行使用，所以不用考虑数据丢失致使缓存穿透造成的影响，在Redis节点增减时可以不用考虑部分数据无法命中的问题。
分片模式的整体应用如下图所示，核心在于客户端的一致性Hash策略。
2.2 集群模式 集群模式本质属于服务器分片技术，由Redis集群本身提供分片功能，从Redis 3.0版本开始正式提供。
集群的原理是：一个 Redis 集群包含16384 个哈希槽（Hash slot）， Redis保存的每个键都属于这16384个哈希槽的其中一个， 集群使用公式CRC16(key)%16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键key的CRC16校验和 。
集群中的每个节点负责处理一部分哈希槽。举个例子， 一个集群可以有三个哈希槽， 其中：
节点 A 负责处理 0 号至 5500 号哈希槽。
节点 B 负责处理 5501 号至 11000 号哈希槽。
节点 C 负责处理 11001 号至 16383 号哈希槽。
Redis在集群模式下对于key的读写过程首先将对应的key值进行CRC16计算得到对应的哈希值，将哈希值对槽位总数取模映射到对应的槽位，最终映射到对应的节点进行读写。以命令set("key", "value")为例子，它会使用CRC16算法对key进行计算得到哈希值28989，然后对16384进行取模得到12605，最后找到12605对应的Redis节点，最终跳转到该节点执行set命令。
集群模式的整体应用如下图所示，核心在于集群哈希槽的设计以及重定向命令。
三、Jedis的基础用法 // Jedis单机模式的访问
public void main(String[] args) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9851d3a592f93daf15ff3cae1f581c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36d0ffbf740043d04ade96bf1da58e57/" rel="bookmark">
			Quartz&#43;SpringBoot实现一个任务对应多个触发器的添加、暂停、恢复、删除、查询所有，每个方法都有解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接文章，不知道Quartz简单使用的看上篇文章
CSDNhttps://mp.csdn.net/mp_blog/creation/editor/126828399看前端效果
提示： 任务和触发器唯一标识由组和名组成。
dto对象
package com.sifan.erp.dto; import io.swagger.annotations.ApiModelProperty; import lombok.Data; import java.io.Serializable; @Data public class ScheduleInfoDto implements Serializable { @ApiModelProperty(value = "服务名称") private String serveName; // @ApiModelProperty(value = "接口地址") // private String interfaceAddress; @ApiModelProperty(value = "任务描述") private String descName; @ApiModelProperty(value = "任务名称") private String jobName; @ApiModelProperty(value = "任务组") private String jobGroup; @ApiModelProperty(value = "任务类名") private String jobClassName; @ApiModelProperty(value = "触发器名称") private String triggerName; @ApiModelProperty(value = "触发器组") private String triggerGroup; @ApiModelProperty(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36d0ffbf740043d04ade96bf1da58e57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0739a258131e2dc3b5b80b013e9467e1/" rel="bookmark">
			c&#43;&#43; 读取txt double数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vector&lt;vector&lt;double&gt;&gt; read_txt_double(string file,vector&lt; vector&lt;double&gt;&gt;) { cout &lt;&lt; "-----------test----------- " &lt;&lt; endl; ifstream in(file); string line; vector&lt;vector&lt;double&gt;&gt; data; int i = 0, j = 0; while (getline(in, line)) {//每一次获取一行的数据到line stringstream ss(line);//初始化ss数据为line double x; vector&lt;double&gt; point; while (ss &gt;&gt; x) { point.push_back(x); } data.push_back(point); i++; } return data; } 读取数据格式为 每行不定长个数的double类型数据，行数不定，读取至文件结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dd4e922ae009120a3e88b8f99899efd/" rel="bookmark">
			一条 SQL 语句是如何执行的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. select 语句执行过程 一条 select 语句的执行过程如上图所示
1、建立连接
连接器会校验你输入的用户名和密码是否正确，如果错误会返回提示，如果正确，连接器会查询当前用户对于的权限。连接器的作用就是校验用户权限
2、查询缓存
MySQL 中有个缓存的概念，当你在执行一条 SQL 查询语句时，MySQL 会先去缓存中查看是否有对应的记录，如果有，则直接返回，如果没有，则取数据库中查询，查询完成后再放入缓存中。这个查询缓存的目的是为了加快 MySQL 查询速度。
这里建议你将这个缓存的选项关闭上，因为在实际项目中，这个查询缓存用处不大，为什么这么说。因为当有 update、或者 delete 语句执行时，这张的表查询缓存就会失效，下次查询还是需要从数据库中查询，所以通常来说查询缓存并不能提高性能。
3、分析器
分析器作用是进行词法分析，语法分析。对于 select 语句而言，MySQL 拿到这条 SQL 语句后，识别出 select 关键词，知道这是一条查询语句，然后再取识别 from 以及表名，识别字段，这个步骤是词法分析。词法分析完成后还需要进行语法分析，也就是判断这条语句的语法是否正确，比如你 select 写成了 selct，那么语法分析就会检验出来
4、优化器
优化器职责是对 sql 语句进行优化，比如这条语句该用什么索引，sql 顺序需不需要调整。
5、执行器
经过上面几部分析，就来到了执行器，开始从数据库查询数据了。查询数据前会校验一下有无权限该表的权限，如果没有则返回错误提示。有权限则开始扫描行，查看是否满足条件，满足条件的结果放入结果集中。
2. update 语句执行过程 update 语句执行过程和 select 语句相同，也需要经过连接、分析器、优化器、执行器这些步骤。不同的是，在 update 执行过程中涉及到两个日志，一个是 redo log，一个是 binlog
redo log
首先需要明确的是，redo log 是 Inndb 存储引擎独有的，其他引擎没有。redo log 主要作用是记账
举个通俗易懂的例子，你是掌柜的，开了一家店铺，店铺生意很好，每天都有很多人来，有些人都是常客，吃饭都是月结，于是你有一个账本，账本上记录了谁欠你多少钱，店铺刚开张时，客人少，你一笔笔记录，没问题，后来客人多了，你发现账本查找起来很费时，影响效率，于是你找了一个黑板，客人来了以后，消费了多少钱，你就记在黑板上，等到不忙的时候在汇总到账本上。
这里的黑板就是 redo log，账本就是 MySQL 数据库磁盘，这么做的原因是为了提高效率，不然 MySQL 每一次操作都要写入到磁盘中，效率很低，有了 redo log 以后，每次 update 操作，我只需要写到内存上，然后记录到 redo log 中即可返回，这样速度快了很多。等到空闲的时候，再将 redo log 中的数据写入到磁盘中进行持久化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dd4e922ae009120a3e88b8f99899efd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3794f6854beaec0ce5d1a83ab69c38ec/" rel="bookmark">
			Ubuntu20.04安装ROS Noetic (一篇博客走遍天)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、版本选择二、下载步骤1. 设置ROS的下载源1.1 设置中科大源1.2 设置自己主机的公钥1.3 更新最新可用软件包列表 2. 安装ROS2.1 ROS 桌面完全版本2.2 ROS 桌面版本2.3 ROS基础版本2.4 ROS额外功能包 DLC 3. 设置环境变量3.1 bash3.2 zsh3.3 随心所欲切换环境 4. 下载安装包的依赖5. rosdep初始化常见报错与解决方法报错：Website may be down报错：The read operation timed out 成功安装 6. rosdep update更新经典报错：更新超时read operation timed out 7. 运行ROS功能包检验安装 三、总结 前言 Ubuntu安装ROS教程众多，但是ROS版本和Ubuntu版本一直更新，ROS有对应的Ubuntu版本下载，版本不一样就会出现不一样的配置问题，甚至导致安装失败或者安装残缺，本文发布于 2022.10.12 保证实时性
一、版本选择 不同的Ubuntu安装的Ros版本不同。Ubuntu20.04对应的ros版本为ROS Noetic ROS安装官网
ROS版本Ubuntu版本Melodic18.04Noetic20.04 二、下载步骤 接下来的步骤参考ROS官网的安装步骤详解：Noetic官网
1. 设置ROS的下载源 因为ROS的官方源是外网下载，速度比较慢，这里推荐选择镜像mirrors下载
1.1 设置中科大源 sudo sh -c '. /etc/lsb-release &amp;&amp; echo "deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main" &gt; /etc/apt/sources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3794f6854beaec0ce5d1a83ab69c38ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f95c6a49e45f87d09ee5f8b2c4a3f275/" rel="bookmark">
			【PyTorch实战】图像描述——让神经网络看图讲故事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像描述——让神经网络看图讲故事 1. 图像描述介绍2. 数据2.1 数据介绍2.2 图像数据处理2.3 数据加载 3. 模型与训练3. 实验结果参考资料 Image Caption: 图像描述，又称为图像标注，就是从给定的图像生成一段描述文字。图像描述是深度学习中十分有趣的一个研究方向，也是计算机视觉的一个关键目标。 对于图像描述的任务，神经网络不仅要了解图中有哪些对象，对象之间的关系，还要使用自然语言来描述这些对象的关系。 图像描述用到的数据集通常是MS COCO。COCO数据集使用的是英文语料库，这里使用2017年9月~12月举办的AI Challenger比赛中的”图像中文描述“子任务的数据。
地址链接: https://pan.baidu.com/s/1K4DUjkqCyNNSysP31f5lJg?pwd=y35v 提取码: y35v
1. 图像描述介绍 利用深度学习完成图像描述的工作可以追溯到2014年百度研究院发表的Explain Images with Multimodal Recurrent Neural Networks论文，将深度卷积神经网络和深度循环神经网络结合，用于解决图像标注与图像和语句检索等问题。
另一篇论文：Show and tell: A neural image caption generator， 这篇论文提出的Caption模型如下图所示：
Image是原始图片，左边是GoogleLeNet，实际使用中可以用任意的深度学习网络结构代替（如VGG或ResNet等）， S 0 ， S 1 ， S 2 ， … … ， S N S_0，S_1，S_2，……，S_N S0​，S1​，S2​，……，SN​是人工对图片进行描述的语句，例如“A dog is playing with a ball”，那么 S 0 S 6 S_0~S_6 S0​ S6​就是这7个单词。就是这几个单词对应的词向量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f95c6a49e45f87d09ee5f8b2c4a3f275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/357b23c471486c10b518f6be34c786d5/" rel="bookmark">
			Hyperledger Fabric 03 超详细图解——通过Fabric测试网络深入理解联盟链
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区块链 | Hyperledger Fabric 03 超详细图解——通过Fabric测试网络深入理解联盟链 - 墨天轮
导读
超级账本，作为最火热的联盟链技术，得到了广泛地使用，也得到了很多科研人员的青睐。
今天这篇文章，我们一起来安装go环境，并通过测试网络来对联盟链Fabric有更深刻地理解。我们也针对安装过程中出现的一些问题做了详细的说明，并提供解决方案。
让我们一起走进文章，来感受Fabric并深入理解联盟链吧！
1
说在前面的话
1、预备知识 为了后续大家能够更好地学习，首先我们需要先了解一些相关的基本理论和概念。
区块链 | Hyperledger Fabric 01 超级账本介绍
后续我们也会逐步更新必备的基础概念，大家可以点击阅读原文。详细了解。
2、环境需求 在今天的内容之前，我们需要先检查一下自己的“背包”，才能让接下来的旅途走得更加悠然。
我们在测试网络文件夹打开终端：
1、Docker
首先我们先检查是否安装Docker和Docker compose，命令如下：
docker --version docker-compose --version 2、测试网络
然后我们检查测试网络是否存在：
./network.sh -h 上面这个命令是打印帮助文档，把测试网络所有可用的功能都打印出来。
如果这个过程出现问题，大家可以在下面这篇文章查找解决方案：
区块链 | Hyperledger Fabric 02 超详细图解——Fabric2.3.3安装及常见报错解决方案
3、安装go 前面我们没有安装go，这是因为前面我们只是安装配置fabric，go并不是必须的。
现在我们要开始运行链码，即联盟链中的智能合约，官网中给的示例是go语言开发的。如果大家有其他语言的开发经验，如Java，可以跳过这个步骤。
首先我们需要下载go的安装包：
https://studygolang.com/dl 大家也可以在我的公众号【AI与区块链技术】回复go下载。
下载好之后，我们将其解压，然后将其移动到local文件夹：
tar -zxvf go1.17.2.linux-amd64.tar.gz sudo mv go /usr/local/ 接下来我们配置一下环境变量，首先我们打开环境变量文件：
sudo gedit ~/.profile 下面的提示是已经完成了更改后的警告：
然后我们在最后添加：
export GOROOT=/usr/local/go export GOPATH=$HOME/go export PATH=$GOPATH/bin:$GOROOT/bin:$PATH 然后点击save保存并关闭。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/357b23c471486c10b518f6be34c786d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8fedcd9480e28cc43e45b43137d01f4/" rel="bookmark">
			win11电脑锁定触摸板或无鼠标打开触摸板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		锁定触摸板 桌面上右键点显示设置或个性化
点蓝牙和其他设备，再点触摸板
如下图点击打开或关闭
无鼠标打开触摸板 使用win+i（win键是4个方块的键，在键盘左下方）键打开系统设置
之后与前面一样通过方向键、tab键和回车键（用于确认）到达如下图地方
最后使用空格键！！！打开触摸板即可
最后使用空格键！！！打开触摸板即可
最后使用空格键！！！打开触摸板即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b3206a25f2f8bf7122818476d2a97ef/" rel="bookmark">
			【MATLAB】使用系统辨识工具箱(System Identification)建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.输入时域数据建模 1. 将输入输出数据分别保存在两个excel文件中，并以数值矩阵导入到工作空间： 2. 选择系统辨识app 注意是Matlab主页（编辑器）界面的APP菜单栏搜索，而不是Simulink
import data-&gt;time domain data
点击time plot可以查看输入输出曲线：
operation选择 Quick start：
estimate选择传递函数模型：
选择零极点个数，再点击estimate：
之后即可得到模型，双击可查看传递函数：
拖动tf1到“To workspace”矩形框中，即可将上述传递函数添加到工作空间：
2.输入频域数据（Bode图）建模 2.1 准备好扫频数据 2.2 打开System Identification APP 选择Freq domain data:
选择FRD Amplitude and Phase,并导入三组工作区变量，注意频率单位rad/s，相位单位rad，再点击import：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/173f1107c985a2d5ea9048f72bc978fc/" rel="bookmark">
			聊一聊线程是如何运行的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程运行的基本原理 在java应用程序中，使用new Thread().start()来启动一个线程时，底层会进行怎样的处理？我们通过一个简单的流程图来进一步分析：
如上图，java代码中创建并启动了一个线程，在JVM中调用相关方法通知到操作系统，操作系统首先接收到JVM指令会先创建一个线程出来，这时候线程并不会马上执行，它会通过操作系统CPU调度算法把该线程分配给某个CPU来执行，CPU执行任务的时候就会回调线程中的run()方法来执行相关指令。
线程的运行状态 一个线程从启动到销毁的这一个生命周期中会经历各种不同的状态，微观上java应用中线程一共分为6种状态：
NEW：新建状态，当执行new Thread()的时候线程处于此状态。RUNNABLE：运行状态，线程调用start()方法启动线程后的状态，一般线程调用start()后会进入一个队列就绪，等获得CPU执行权后才真正开始执行线程中的run()代码块。BLOCKED：阻塞状态，当线程在执行synchronized代码块，没有抢占到同步锁时会变成阻塞状态。WAITING：等待状态，当调用Object.wait()方法时，线程会进入该等待状态。TIMED_WAITING：超时等待状态，例如Thread.sheep(timeout)超时后会自动唤醒线程。TERMINATED：终止状态，当线程中的run()方法正常执行完或者调用interrupt()的时候线程变为此状态。 从宏观上看就分为五种状态：新建、就绪、运行、等待、死亡，整体的状态运行流转如下图：
如何终止线程 首先run()方法中的指令正常运行结束后线程自然会进入终止状态。那么如果我们想要终止一个运行中的线程该怎么办?
使用stop()终止 使用stop()方法，该方式肯定是行不通的，该方法会强制停止一个线程的执行，并且会释放线程中所占用的锁，这种锁的释放是不可控的。
static class StopThread extends Thread { @Override public void run() { for (int i = 1; i &lt;= 100000; i++) { System.out.println("count:" + i); } System.out.println("thread run finish!"); } } public static void main(String[] args) throws InterruptedException { StopThread stopThread = new StopThread(); stopThread.start(); Thread.sleep(50); stopThread.stop(); } 由以上代码所展示的在for循环未结束时就提前终止线程，导致最后的System.out.println("thread run finish!");不会正常执行结束。
public void println(String x) { synchronized (this) { print(x); newLine(); } } 进入println的源码看一下，我们就能够发现有print(x)、newLint()两个操作是原子性的，所以增加了synchronized同步锁进行保护，按正常是不应该出现问题的，但是执行stop()操作会强制释放所有锁，从而导致println()操作的原子性被破坏（上面的代码多运行几次就可能出现最后一次循环没有换行，就是存在newLine()未被执行的可能），所以实际开发过程中是一定不能使用stop()来中断线程的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/173f1107c985a2d5ea9048f72bc978fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de03659ba4020dd7f140873e071ebb8a/" rel="bookmark">
			Postman启动慢一直加载解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Postman启动慢一直加载解决方案 找了好几篇文章都让删除C:\Users\用户名\AppData\Local下的Postman文件 删除后发现整个postman都没了 下面给出正确删除数据方式
删除C:\Users\用户名\AppData\Roaming下的Postman文件夹 会清空postman中的数据 最好提前做好备份
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c660ba9ec1487569777918fd0d5a34d/" rel="bookmark">
			Rancher环境搭建手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Rancher环境搭建部署手册
一、准备部署节点
关闭防火墙
（1）查看防火墙状态：firewall-cmd --state
防火墙关闭状态为：no running
防火墙开启状态为：running
（2）关闭防火墙：systemctl stop firewalld
（3）禁止开机自启防火墙：systemctl disable firewalld
2.永久禁用selinux
编辑/etc/selinux/config文件，将SELINUX=enforcing改为SELINUX=disabled（设置后需要重启才能生效）如图所示：
3.安装docker （1）安装docker：sudo yum install docker （2）设置docker服务开机自启：systemctl enable docker （3）设置docker的私库地址： 编辑/etc/docker/daemon.json文件，添加配置项：“insecure-registries”: [“私库地址，如harbor.xxxx.com”]，
（4）重启docker服务，使设置生效：service docker restart
4.设置主机名：hostnamectl set-hostname &lt;新主机名&gt;. 5.配置私库地址到hosts文件，如192.168.103.124 harbor.t2cp.com 二、在其中一节点（主节点）上安装rancher server
1.下载rancher镜像并启动rancher server docker run -d --privileged=true --restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher:v2.2.2
三、在rancher上添加集群配置
1.点击添加集群，选择集群类型为custom 2.填写集群名称，选择k8s版本，选择网络为calico 3.点击【下一步】，选择需要添加的主机的角色，并复制命令到对应的主机中执行命令即可. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6fc9b6620f3ac7e824be0f0a37b192f/" rel="bookmark">
			Lepton 无损压缩原理及性能分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍无损压缩图片的概要流程和原理，以及Lepton无损压缩在前期调研中发现的问题和解决方案。
一、从一个游戏开始
1.1 游戏找茬
请拿出你的秒表计时，在15秒时间内找出下面图片的差异。
时间到了，你发现两张图片的差异了吗？ 二、智者的成长
在上面的游戏中，你可能你并没有发现两张图片间有任何差异，而实际上它们一张是3.7MB的jpg格式的原图，另外一张是大小为485KB的jpg格式压缩图片，只是大小不同。你可能会有些生气，愤愤不平到这是欺骗，然而聪明的你很快在大脑中产生了一连串的疑问，这些问号让你层层揭开游戏的面纱，不在为愚弄而悔恨，反而从新知中获得快乐。
2.1 苏格拉底助产术
上面图片为何变小了呢？
丢失了的信息去哪了呢？
为什么图片质量下降了，我却看不出来呢？
我还能将它变的更小吗？
我能将它还原成原来的大小吗？
为什么要压缩我的图片？
上面图片为何变小了？图片从3.7MB变成485KB是因为我使用了图片查看工具将原图另存成一张新的图片，在另存的过程中，有一个图片质量选择的参数，我选择了质量最低，保存后便生成了一张更小的图片。可是图片质量下降了，为什么看不出来呢？这就需要了解图片压缩的原理。
2.2 探求表象背后的故事
利用人眼的弱点。
人的视网膜上有两种细胞，视锥细胞和视杆细胞。视锥细胞用来感知颜色，视杆细胞用来感知亮度。而相对于颜色，我们对明暗的感知更明显。
因此可以采取对颜色信息进行压缩来减小图片的大小。
所以我们在图片压缩前会进行颜色空间的变换，JPEG图片通常会变换成YCbCr颜色空间，Y代表亮度，Cb蓝色色彩度，Cr红色色彩度，变换后我们更容易处理色彩部分。然后我们将一张图片切成一块块8*8的像素块，然后使用离散余弦转换算法(DCT)计算出高频区和低频区。
由于人眼对高频区的复杂信息不敏感，因此可以对这一部分进行压缩，这个过程叫量化。最后再将新的文件进行打包。这个流程下来就完成了图片的压缩。
基本流程如下图：
JPEG压缩有损。 在上面的流程中，在预测模块的颜色空间转换后，通过舍弃部分颜色浓度信息，提高压缩率。常见选项为4:2:0，经过这一步后原来需要8个数字表示的信息，现在只需要2个，直接抛弃了75%的Cb Cr信息，然而这一步骤是不可逆的，也就造成了图片压缩的有损。此外在熵编码模块，会进一步使用行程长度编码或Huffman编码进一步对图片信息进行压缩，而这一部分的压缩是无损的，是可逆的。
（YCbCr空间转换）
霍夫曼编码原理如下： 假如待编码的字符总共38个符号数据，对其进行统计，得到的符号和对应频度如下表：
首先，对所有符号按照频数大小排序，排序后如下图： 然后，选择两个频数最小的作为叶子节点，频数最小的作为左子节点，另外一个作为右子节点，根节点为两个叶子节点的频数之和。 （Huffman 树） 经过上面的步骤，就形成了一颗Huffman树，Huffman编码经常用在无损压缩中，其基本思想是用短的编码表示出现频率高的字符，用长的编码来表示出现频率低的字符，这使得编码之后的字符串的平均长度、长度的期望值降低，从而实现压缩的目的。 三、故事的主角 Lepton
不完美。
上面的JPEG压缩虽然降低了图片的大小且质量良好以至于人眼很难分辨其差异，但是由于是有损的压缩，图片质量不能恢复到原来的品质，而且实际上此时的jpg图片仍有压缩空间。
Lepton便可以在JPEG基础上进一步对图片进行无损压缩。
3.1 为什么选择 Lepton
与lepton类似的压缩工具还有jpegcan，MozJPEG，PackJPG，PAQ8PX。但这些工具都或多或少有一些缺陷，使得不如lepton更加适合工业生产。
比如PackJPG需要按照全局排序的顺序重新排列文件中的所有压缩像素值。这意味着解压缩是单线程的，同时需要整个图像放入内存中导致处理图片的时延较高吞吐较低。
下图是lepton论文中对几款工具的比较：
3.2 Lepton进行了哪些优化。 首先在算法上Lepton将图像分为两部分header和图片数据本身，header使用DEFLATE进行无损压缩，图片本身使用算数编码替换霍尔曼编码进行无损压缩。由于JPEG使用Huffman编码，这使得利用多线程比较困难，Lepton使用"Huffman切换词"进行了改进。
其次Lepton使用了一个复杂的自适应概率模型，这个模型是通过在大量的野外图像上进行测试而开发的。该模型的目标是对每个系数的值产生最准确的预测，从而产生更小的文件；在工程上允许多线程并发处理，允许分块跨多个服务器分布式处理，流的方式逐行处理有效的控制了内存，同时还保证了数据读取和输出的安全。
正是Lepton在上述关键问题的优化，使得它目前可以很好的在生产环境中使用。
3.3 Lepton在vivo存储中的探索
预期收益：
目前对象存储其中的一个集群大约有100PB数据，其中图片数据大概占70%, 而图片中有90%的图片都是jpeg类型图片，如果按照平均23%的压缩率，那么 100PB * 70% * 90% * 23% = 14.5PB，将实现大约14.5PB的成本节约。
同时由于是无损压缩，很好的保证了用户的使用体验。当前lepton压缩功能的设计如下图：
当前遇到的挑战： lepton压缩与解压缩对服务器的计算性能要求较高、消耗较大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6fc9b6620f3ac7e824be0f0a37b192f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4faebff7488c6e6b32296f283bb3092/" rel="bookmark">
			笔记本 win10系统 禁用磁盘 卸载磁盘驱动 关闭快速启动 禁用自动装载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		禁用磁盘&amp;卸载磁盘驱动 由于笔记本电脑有异响，怀疑是风扇或者机械硬盘坏了，遂禁用机械硬盘 关掉快速启动禁用自动装载后续 由于笔记本电脑有异响，怀疑是风扇或者机械硬盘坏了，遂禁用机械硬盘 右击 此电脑 （我的电脑）-&gt;管理进入 设备管理器-&gt;点击磁盘驱动器，右键你想禁用的磁盘，禁用设备并卸载驱动
关掉快速启动 值得注意的是
开始我禁用设备卸载驱动的时候老叫我重新启动，但我电脑只能关机后再开机，直接重启的话会开卡死，后来我把快速启动关掉来解决这个问题，关于快速启动，有的时候启动找不到，可能是因为关闭了睡眠模式，以管理员身份运行cmd再输入可以解决
开启快速启动选项卡
注意这只是让快速启动这个选项可以被找到，依然还要去禁用快速启动。
win10禁用快速启动
禁用自动装载 还有个问题 win10会自动挂载硬盘，为了避免系统又装上，所以要禁用这个功能(ubuntu不会自动挂载）
win10禁用自动挂载功能
后续 电脑还是有吱吱声，重新买了个风扇换上。
再后来，发现好像是水瓶装开水冒气的声音😓
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8704c7830041aebc6d4675cc165bd22f/" rel="bookmark">
			图像处理：推导五种滤波算法（均值、中值、高斯、双边、引导）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概论
算法原理
1、均值滤波
2、中值滤波
3、高斯滤波
4、双边滤波
5、引导滤波
手写代码
Opencv代码实现
最后的总结
参考文章
概论 本来打算是分开推导的，但我觉得还是整个合集吧，避免有水文的嫌疑，那么因为学习的需要，会涉及到图像的滤波处理，我汇总了一些常见的滤波算法，方便日后查看。
算法原理 1、均值滤波 我将以5*5的区域为例子来讲解：
此时，中心点就很容易的被确定了，将所有的数全部加起来后，求取平均值取代中心点的中间值，但是图像的边界并不存在5*5的区域，那么只需要提取在图像内的周围点的像素平均值。
附带草稿图：
均值滤波本身会存在缺陷，即他不能很好的保护好图像的细节，在图像去噪的同时也破坏了图像的细节部分，从而使图像变得模糊，尤其是在处理椒盐滤波的时候。 2、中值滤波 其与中值滤波相似，同样是选定固定的大小核，选取其中所有像素值的中位数作为滤波结果，类似的就是在比赛当中，去掉最高分和最低分，其余分数求取平均值，这个就叫做中位值平均滤波法，但这种方法就效率而言有点慢了。
附带草稿图：
3、高斯滤波 使用一个模板，常常称为卷积或掩膜，来扫描图像中的每一个像素，用模板确定的领域内的像素的加权平均值去替代模板中心像素点的值。
附带草稿：
在高斯滤波当中，核的宽度和高度可以不相同，但都要是奇数。
同一尺寸的卷积核都可以有多种不同的形式，比如在下面的图中5*5：
同一尺寸的卷积核可以有不同的权重比，在实际的计算当中，卷积核是归一化处理的，这种处理方式可以参考上面的3*3的卷积核（都是小数的），但有的资料当中并没有进行归一化，这时就可能是如我上图当中举出来的5*5，7*7的卷积核，这样的卷积核是为了说明问题用的，实际在用的时候还是需要进行归一化，准确来说，没有经过归一化的卷积核得到的结果往往是错误的。
4、双边滤波 双边滤波是一种不同于以往的平滑滤波，是一种常用于像素边缘保持的空间非线性滤波方法，主要利用了领域内像素点的空间邻近度和像素值相似度来构建高斯权重滤波器。
附带草稿图：
图2：
5、引导滤波 引导滤波为何凯明等人于2010年提出，它本质上具有O(N)复杂度，相当于双边滤波有更好的边缘保持特性，且不会出现梯度反转的现象，在不同引导图像的引导下，可广泛应用于降噪、去雾、高动态范围压缩等。在其定义当中，用到了局部线性模型，该模型认为，某函数上一点与其邻近部分的点成线性关系，一个复杂的函数就可以用很多局部的线性函数来表示，当需要求该函数上某一点的值时，只需计算所有包含该点的线性函数的值并作平均即可。
以下皆为对此的翻译以及个人解释：
GuidedFilter.dvi (kaiminghe.com)http://kaiminghe.com/publications/eccv10guidedfilter.pdf对于一个输入图像p，通过引导图像I，经过滤波后得到输出图像q，其中p和I都是算法的输入。引导滤波定义了如下所示的一个线性滤波过程，对于i位置的像素点，得到的滤波输出是一个加权平均值：
其中i和j分别表示像素的下标。Wij是只和引导图像I相关的滤波核。该滤波器相对于p是线性的，双边滤波核Wbf由下式给出：
其中x是像素坐标，Ki是规格化参数，以确保Wij的和为1，参数σs和σr调整空间相似性和范围（强度/颜色）相似性。联合双边滤波器退化当I和p相同时，初始双边滤波器。
现在我们定义导向滤波器及其内核。被引导者的关键假设滤波器是制导I和滤波器输出q之间的局部线性模型。我们假设q是以像素k为中心的窗口ωk中I的线性变换：
I
其中（ak，bk）是假定在ωk中为常数的一些线性系数。我们使用半径为r的方形窗口。这种局部线性模型确保q有一条边除非我有优势，因为∇q=a∇I、 该模型已被证明在图像消光、图像超分辨率和烟雾消除。为了确定线性系数，我们寻求上面式子的一个最小化的解q和滤波器输入p之间的差值。具体来说，我们将窗口中的以下成本函数：
这里是一个正则化参数，用于防止ak过大。上面的解可以通过线性回归得出：
这里，μ（k）和σ（k）**2是I在ωk中的平均值和方差，|ω|是ωk中的像素数，¯pk是ωk中p的平均值。通过此修改∇q不再是的缩放∇一、 因为线性系数（¯ai，¯bi）在空间上变化。但由于（¯ai，¯bi）是平均滤波器的输出，它们的梯度应该比强边附近的I小得多。在这种情况下，我们仍然可以∇q≈ a¯∇I、 这意味着I中的突然强度变化大部分可以在q中保持。
核重量可以明确表示为：
进一步的计算表明和的Wij（I）=1。不需要额外努力以规范化权重。
对于该算法，当I = p I=pI=p时，即输入图像和引导图像是同一副图像时，该算法即成为一个边缘保持滤波器。同时，方程的解也可作如下表示： 手写代码 本文只以手写的中值滤波来实现，其他的方法滤波器大家可以自己去尝试以下：
import numpy as np import cv2 def medianBlur(image, ksize=2): rows, cols = image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8704c7830041aebc6d4675cc165bd22f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ab43a91a5ff4159f72b735b27305202/" rel="bookmark">
			一把搞懂线程中stop、sleep、supend、yield、wait、notify
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
不废话直接上图
附加一个线程状态图吧不然看不懂
还是再附加一个文字吧看不懂直接往后看案例很清晰（下面这段话还回头再看）
1：stop()方法
1.1　stop()方法与java.lang.ThreadDeath异常
1.2　使用stop()释放锁给数据造成不一致的结果
2：suspend()方法
2.1　suspend()方法与resume()方法的使用
2.2　suspend()方法与resume()方法的缺点——独占
2.3　suspend()方法与resume()方法的缺点——数据不完整
3：yield()方法
4：wait方法
4.1　wait/notify机制的原理
4.2　wait()方法的基本使用
4.3　完整实现wait/notify机制
4.4　使用wait/notify机制实现list.size()等于5时的线程销毁
4.5　wait()方法：立即释放锁
5：sleep()方法
6：notify()方法
记得回头看线程的流程
前言 不废话直接上图 stopsupendyieldwaitsleepnotify停止暂停让步等待睡眠通知线程都死了锁就不存在了不让出锁让出CPU让出锁不让出锁不立即释放锁 附加一个线程状态图吧不然看不懂 还是再附加一个文字吧看不懂直接往后看案例很清晰（下面这段话还回头再看） 1）创建一个新的线程对象后，调用它的start()方法，系统会为此线程分配CPU资源，此时线程处于runnable（可运行）状态，这是一个准备运行的阶段。如果线程抢占到CPU资源，则此线程就处于running（运行）状态。
2）runnable状态和running状态可相互切换，因为有可能线程运行一段时间后，其他高优先级的线程抢占了CPU资源，这时此线程就从running状态变成runnable状态。
线程进入runnable状态大体分为如下4种情况。
·调用sleep()方法后经过的时间超过了指定的休眠时间；
·线程成功获得了试图同步的监视器；
·线程正在等待某个通知，其他线程发出了通知；
·处于挂起状态的线程调用了resume恢复方法。
3）blocked是阻塞的意思，例如，如果遇到了一个I/O操作，此时当前线程由runnable运行状态转成blocked阻塞状态，等待I/O操作的结果。这时操作系统会把宝贵的CPU时间片分配给其他线程，当I/O操作结束后，线程由blocked状态结束，进入runnable状态，线程会继续运行后面的任务。
出现阻塞的情况大体分为如下5种。
·线程调用sleep()方法，主动放弃占用的处理器资源。
·线程调用了阻塞式I/O方法，在该方法返回前，该线程被阻塞。
·线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。
·线程等待某个通知（notify）。
·程序调用了suspend()方法将该线程挂起。此方法容易导致死锁，应尽量避免使用该方法。
4）run()方法运行结束后进入销毁阶段，整个线程执行完毕。
1：stop()方法 用stop()方法暴力停止线程
使用stop()方法可以强行停止线程，即暴力停止线程。
新建项目useStopMethodThreadTest，文件MyThread.java代码如下：
package testpackage; public class MyThread extends Thread { private int i = 0; @Override public void run() { try { while (true) { i++; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ab43a91a5ff4159f72b735b27305202/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2bdf14ea28b6e385daee371c1ec7926/" rel="bookmark">
			OpenCV (一)—安装与配置 VS2019和OpenCV4.5.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的是win10用的是VS2019和OpenCV4.5.1的新版，在配置上困扰了很久，发现有很多问题导致配置OpenCV不行，希望这篇文章可以帮助大家和我成功走上OpenCV学习之路~
文章目录 OpenCV (一)—安装与配置 VS2019与OpenCV4.51一、安装VS2019与OpenCV二、配置环境变量三、打开VS开始配置添加OpenCV包含目录和库目录 四、VS与OpenCV相配合测试 总结 OpenCV (一)—安装与配置 VS2019与OpenCV4.51 一、安装VS2019与OpenCV 这两个大家都可以在官网下载，都是免费的，至于安装那个版本也是看情况的，按教学版本来定吧，感觉网上的教程OpenCV版本都是比较旧的，大家可以看情况下载
这里给大家附上链接
VS社区版
建议大家下载社区版是免费的，直接上官网下载专业版要收费的，土豪除外
OpenCV
大家点进去之后应该都是英文版，这里的话直接点右上角放大镜搜索，直接搜索版本就好，点进去之后拉到最下面的download 选择版本 Win pack就可，或者点Sources下载压缩包也可以
二、配置环境变量 在“此电脑”右击弹出“属性”对话框，选择“高级系统设置”再点击“环境变量”，然后在系统变量那里再编辑path环境变量，之后直接按浏览，找出自己刚刚下载的OpenCV那个文件夹,把这个文件夹放进去
PS:看看自己的操作系统是多少位的，64位就在x64找，32位就在x32找
G:\OpenCV\opencv\build\x64\vc15\bin
三、打开VS开始配置 添加OpenCV包含目录和库目录 新建一个C++控制台项目，在VS左上角菜单栏，依次选择“视图”、“其他窗口”、“属性管理器”，找到
Debug|x64,右键打开属性，依次选择“通用属性”、“VC++目录”，开始添加“包含目录”、“库目录”、“可执行文件目录”
1.按照图片这样添加这几个路径的文件
2.、依次选择“链接器”、“输入”、“附加依赖项”，进入“附加依赖项”页面，开始添加lib文件路径，这个lib文件的451是你下载OpenCV的版本，各有不同
PS:现在所有做完之后，记得点 应用，我第一次就是傻傻的没有点，没有保存好…
四、VS与OpenCV相配合 我看了很多CSDN的教程，比较少提到这一点，提醒一下大家
就是我们VS的这几个要调整好，都是符合我们刚刚配置的文件夹
我之前这里就是x32，所以一直配置不好
测试 #include #include &lt;opencv2/highgui.hpp&gt;
#include &lt;opencv2/core.hpp&gt;
#include &lt;opencv2/imgcodecs.hpp&gt;
using namespace cv;
using namespace std;
int main()
{
Mat image;
image = imread(“C:\Users\Nieve\Pictures\联想锁屏壁纸\8469973.jpg”); // Read the file
if (image.empty()) // Check for invalid input
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2bdf14ea28b6e385daee371c1ec7926/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/505a6e79c96e3cd90b1c020bf73cbd08/" rel="bookmark">
			Markdown基本命令汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大一下刚开学，打算这个学期学习Markdown和OpenCV，今天先学习一下怎么用Markdown~
不得不说，大一上的寒假真的是玩过来的，大一下要好好学习
文章目录 Welcome to Markdown's world1. 标题的使用2. 列表的使用无序列表有序列表 3. 分割线的使用4. 字体的变化5. 代码的展示6. 表格的使用7. 链接的引用8. 花里胡哨的表情 总结 Welcome to Markdown’s world 1. 标题的使用 #一级标题
##二级标题
#号后面记得要一个空格（以此类推）
2. 列表的使用 无序列表 文字前面加上*,+,- 还有一个空格表示无序列表
有序列表 使用数字和一个英文的句点还有一个空格表示有序列表
可以自动排列顺序！ 3. 分割线的使用 就是单独取一行加上*** 4. 字体的变化 粗体 + *斜体* + ~~下划线~~ 5. 代码的展示 #include using namespace std;
int main()
{
int a=0,b=0,c;
int add(int x, int y);
cin &gt;&gt; a;
cin &gt;&gt; b;
c = add(a, b);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/505a6e79c96e3cd90b1c020bf73cbd08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/486fdb99575faad8b7f0644a4013d892/" rel="bookmark">
			Matlab(一)—基础命令与矩阵运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大一刚刚开始学习Matlab的一些基础，准备今年9月冲数模国赛，在学习过程中总结了一些小知识点，记录一下自己的学习过程，随时忘记可以查阅一下，大家一起加油！❤❤
文章目录 Matlab 基础1.Matlab的基本命令2.矩阵的基本命令1.矩阵的有关函数2.矩阵中取指定元素3.矩阵的运算 结语 Matlab 基础 1.Matlab的基本命令 在语句之后加；表示不显示运行结果
Ctrl+R 快速标注
Ctrl+T 取消标注
clear 清除工作区所有变量
clc 清除命令行窗口所以文本
clear;clc 初始化
disp()输出函数，类似c++的printf()
strcat()字符串函数
[str 1, str n]或[str1 strn]
等同于strcat() []中用，和空格都行
num2str()将数字转换为字符串
input()输入函数
2.矩阵的基本命令 1.矩阵的有关函数 size(A)求矩阵A的大小，返回行向量
[r,c]=size(A)
r=size(A,1) 返回行数
c=size(A,2) 返回列数
sum()矩阵求和
向量
直接求和
矩阵
a=sum(x) 按列求和
a=sum(x,2) 按行求和
a=sum(x( : )) 对整个矩阵求和
repmat()
B=repmat(A, m, n)：将矩阵A作为B的元素，B由m*n个A平铺而成
find()
用于返回矩阵中不为0的元素位置
find()寻找元素是按列寻找
[r,c]=find(X) 这样可以输出每个元素的行列信息
find(X,2) 这样只寻找前两个不为0的数
2.矩阵中取指定元素 取指定行和列
A(行，列) 取指定行列的一个元素
A(行，：) 取指定某一行的所有元素,一个行向量
A(：，列) 取指定某一列的所有元素,一个列向量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/486fdb99575faad8b7f0644a4013d892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d480876fd0ad00090889eb87c1a4281/" rel="bookmark">
			【Python】-- 文件的读写操作（解决‘utf-8‘ codec can‘t decode byte 0xce in position 0: invalid continuation byte）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文件的打开/创建 open（） 使用open函数，可以打开一个已经存在的文件，或者创建一个新文件。
语法：open（name，mode，encoding）
其中，name：是要打开的目标文件名的字符串；
mode：设置打开文件的模式：只读、写入、追加等；
encoding：编码格式
mode模式描述r以只读的方式打开文件，文件的指针将会放在文件的开头，这是默认模式。w打开一个文件只用于写入，如果该文件已存在则打开文件，并从头开始编辑，原有内容会被删除。如果文件不存在，则创建新文件。a打开一个文件追加内容，如果不存在，则创建并写入。 例： f = open("D:/1.txt","r",encoding="UTF-8") 二、文件的读取 文件读取有三种方法： read()：读取整个文件的内容保存为字符串；readline()：逐行读取文件保存为字符串；readlines()：读取整个文件内容保存为列表。 1、read（） 语法：文件对象.read(num)
其中，num表示从文件中读取的数据的长度（单位字节），没有传入则表示读取所有数据。
例：
f = open("D:/save_date.txt","r",encoding="UTF-8") print(f.read(10)) print(f.read()) f.close # 关闭文件 2、 readline（） 可以按照行的方式把文件中的内容进行一行读取，并且返回一个字符串。
3、readlines（） 可以按照行的方式把整个文件中的内容进行一次性读取，并且返回一个列表，其中每一行的数据是一个元素。
例:
f = open("D:/save_date.txt","r",encoding="UTF-8") print(f.readline())# 一次读取一行内容 print(f.readlines()) f.close # 关闭文件 4、with open 自动关闭文件。
语法：with open（name，mode，encoding）as f:
例:
with open("D:/save_date.txt","r",encoding="UTF-8") as f: for line in f: print(line) 三、文件的写入 write（） 语法：文件对象.write()
直接调用write，内容并未真正写入文件，而是会积攒在内存中，称为缓冲区；
当调用flush方法的时候，内容会真正写入文件。
例：
f = open("D:/save_date.txt","w",encoding="UTF-8") f.write("111") f.flush() f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d480876fd0ad00090889eb87c1a4281/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/760d5be593b8cd2999f0456456d75d39/" rel="bookmark">
			iOS WebView白屏问题&amp;&amp;解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因一 内存暴涨导致白屏，这个时候需要重新加载
//进程终止(内存消耗过大导致白屏) func webViewWebContentProcessDidTerminate(_ webView: WKWebView) { print("进程被终止") webView.reload() } 原因二 后台返回前台白屏，需要判断然后重新加载
func wkWebView_AppDidEnterPlayground() { webView.evaluateJavaScript("document.body.innerHTML") { [weak self] (result, error) in guard let strongSelf = self else {return} if let innerHTML = result as? String { if innerHTML.isEmpty { strongSelf.webView.reload() } } } } 原因三 HTTPS 请求，未实现证书认证代理导致页面不加载的问题
func webView(webView: WKWebView, didReceiveAuthenticationChallenge challenge: NSURLAuthenticationChallenge, completionHandler: (NSURLSessionAuthChallengeDisposition, NSURLCredential?) -&gt; Void) { // 判断服务器采用的验证方法 if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust { if challenge.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/760d5be593b8cd2999f0456456d75d39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c54010aacae7351457249cf97808e533/" rel="bookmark">
			利用python版tensorRT导出engine【以yolov5为例】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境说明：
tensorRT:8.2.4.2
CUDA:10.2
pytorch:1.7
显卡：NVIDIA 1650
Windows10
python 3.7
另一篇文章中写过C++版的trt推理。本篇文章是python版本的trt yolov5推理。
构建engine一般有两种方式。
方式1：torch模型-&gt;wts(序列化网络)-&gt;engine-&gt;推理
方式2：torch模型-&gt;onnx-&gt;engine-&gt;推理
第一种方式如果网络结构简单，在定义网络构建engine的时候还可以，但网络复杂的情况就麻烦了，写网络的时候还容易出错。
第二种方式也是很多人常用的方法，转onnx再转engine。转onnx就比较容易了，而转engine一般有两种方式，第一种是trt官方自带的方式，在你trt文件下的bin目录下有个trtexec.exe的文件，执行命令就可以将onnx转engine。而第二种python版trt自带工具，这也是本文要介绍的。
我这里的代码是用的v5 6.1代码，因为6.1以及之后版本的export.py中有engine格式的导出。
git clone https://github.com/ultralytics/yolov5
我们可以看一下官方提供的yolov5s.pt中都包含什么内容：
dict_keys(['epoch', 'best_fitness', 'model', 'ema', 'updates', 'optimizer', 'wandb_id', 'date'])
可以看到上述pt文件中包含了这些key值，其中的model就是我们要的，而且需要注意的是这个model不仅含有网络权重信息，还包含了整个网络结构【如果你想把其他网络转onnx，也需要主要必须torch保存的是整个网络】 目录
导出onnx
导出engine
导出onnx 执行下面的命令就可以得到我们的onnx模型。
python export.py --weights yolov5s.pt --include onnx 这里附上导出onnx的代码。
@try_export def export_onnx(model, im, file, opset, dynamic, simplify, prefix=colorstr('ONNX:')): # YOLOv5 ONNX export check_requirements('onnx') import onnx LOGGER.info(f'\n{prefix} starting export with onnx {onnx.__version__}...') f = file.with_suffix('.onnx') output_names = ['output0', 'output1'] if isinstance(model, SegmentationModel) else ['output0'] if dynamic: dynamic = {'images': {0: 'batch', 2: 'height', 3: 'width'}} # shape(1,3,640,640) if isinstance(model, SegmentationModel): dynamic['output0'] = {0: 'batch', 1: 'anchors'} # shape(1,25200,85) dynamic['output1'] = {0: 'batch', 2: 'mask_height', 3: 'mask_width'} # shape(1,32,160,160) elif isinstance(model, DetectionModel): dynamic['output0'] = {0: 'batch', 1: 'anchors'} # shape(1,25200,85) torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c54010aacae7351457249cf97808e533/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc42db15cd306c8b6e6b8499c39abf78/" rel="bookmark">
			科目需要分配到成本对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务背景：migo262对内部订单收货时显示科目需要分配到成本对象，并提示消息号为KI248
原因分析：点击报错明细，过程中提示输入一个不是统计型的成本对象。KO03检查内部订单为统计型，因此不可用。
解决方法：1，重新创建内部订单，输入一个可用的成本中心。2，MIGO科目分配页签重新输入一个成本对象。
注：S/4环境下，报错科目需要分配一个成本中心一般通过OKB9维护（消息号KI235)，但要根据具体的报错提示来处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f61287e693a675f4a77d2ae52bcc7827/" rel="bookmark">
			CVPR2022 | ZeroCap：零样本图像到文本生成的视觉语义算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CVPR2022 | ZeroCap：零样本图像到文本生成的视觉语义算法 【写在前面】 最近的文本到图像匹配模型将对比学习应用于大量未经管理的图像和句子对。虽然此类模型可以为匹配和后续的zero-shot任务提供强大的分数，但它们无法在给定图像的情况下生成标题。在这项工作中，作者重新利用这些模型来在推理时生成给定图像的描述性文本，而无需任何进一步的训练或调整步骤。这是通过将视觉语义模型与大型语言模型相结合来完成的，受益于这两种网络规模模型中的知识。由此产生的字幕比通过监督字幕方法获得的字幕限制要少得多。此外，作为一种零样本学习方法，它非常灵活，展示了它执行图像运算的能力，其中输入可以是图像或文本，输出是一个句子。这实现了新颖的高级视觉功能，例如比较两个图像或解决视觉类比测试。
1. 论文和代码地址 ZeroCap: Zero-Shot Image-to-Text Generation for Visual-Semantic Arithmetic
论文地址：https://arxiv.org/abs/2111.14447
代码地址：https://github.com/YoadTew/zero-shot-image-to-text
2. 动机 深度学习至少导致了计算机视觉的三大革命：（1）机器在多个领域中比预期更早地实现了被认为是人类水平的性能，（2）有效的迁移学习，支持新领域的快速建模，以及（3）通过使用对抗性和自监督学习实现无监督学习的飞跃。
当前正在发生的第四次革命是零样本学习。 OpenAI 的一项开创性工作提出了基于变压器的GPT-3 模型。该模型在非常大的文本语料库上进行训练，然后可以根据提示生成文本。如果提示包含指令，GTP-3 通常可以执行它。例如，给定提示“将英语翻译成法语：typical → typique→house → . . .”会生成“maison”这个词。
后来 OpenAI 在计算机视觉中也展示了令人印象深刻的零样本能力。虽然最先进的计算机视觉模型通常被训练为推断固定数量标签的任务特定模型，但 Radford 等人提出了 CLIP 图像-文本Transformer模型，该模型可以执行数十个下游任务，无需进一步训练，其准确性可与现有技术相媲美。这是通过在给定图像的情况下从“这是 X 的图像”形式的句子中选择最佳匹配来完成的。
在这项工作中，作者使用 CLIP 来执行 DALL-E 的逆任务，即零样本图像字幕。给定一张图像，作者使用 CLIP 和 GPT-2 语言模型（无法访问 GPT-3）来生成输入图像的文本描述。除了 Radford 等人展示的固定提示零样本学习之外，这为 CLIP 添加了新的图像分析功能。
作为一种零样本方法，本文的方法不涉及任何训练。有人可以争辩说，底层 CLIP 模型是用与图像字幕方法训练的完全相同类型的监督来训练的，即成对的匹配图像和字幕。然而，图像字幕方法是从精选来源训练的，例如 MSCOCO 或 Visual Genome，而 CLIP 是在 Web Image Text (WIT) 上训练的，这是一个自动收集的网络规模数据集。以前在 WIT 上训练字幕模型的尝试导致在识别图像中的对象方面表现不佳。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f61287e693a675f4a77d2ae52bcc7827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f357107cd442bc0f2526648d5ecd9e3/" rel="bookmark">
			防火墙网络地址转换技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拓补图： 一、Easy ip 简单的来阐述一下什么是easy ip以及easy ip的作用，easy ip跟动态nat以及静态nat不一样的是不需要配置nat地址池，而是将私网的地址直接转换成路由器出接口上的公网地址，适合于PPPOE拨号的用户，因为每次拨号之后的公网地址都不一样了，所以适用于这种用户，这种方式也是现网当中应用最广泛的一种NAT技术，配置和维护都简单快捷
1. IP地址的配置略
2. 路由的配置
[R1]ip route-static 0.0.0.0 0 10.1.1.2 //注意R1配置默认路由能够到达R2即可，R2无需配置路由回来，这样才能体现出NTA的效果
3. 防火墙区域的划分
[USG6000V1]firewall zone trust
[USG6000V1-zone-trust]add interface g1/0/0
[USG6000V1]firewall zone untrust
[USG6000V1-zone-untrust]add interface g1/0/1
4.新建安全策略
[USG6000V1]security-policy [USG6000V1-policy-security]default action permit //默认放行全部，这里目的是为了演示实验效果，真实的生产环境当中不建议这样配，详情请查看之前的配置
5.新建NAT策略
[USG6000V1]nat-policy //新建NAT策略
[USG6000V1-policy-nat]rule name huawei //NAT规则名字
[USG6000V1-policy-nat-rule-huawei]source-zone trust //转换的源区域
[USG6000V1-policy-nat-rule-huawei]destination-zone untrust //转换的目标区域
[USG6000V1-policy-nat-rule-huawei]source-address 10.1.1.1 32 //转换的源地址
[USG6000V1-policy-nat-rule-huawei]destination-address 100.1.1.1 32 //转换的目的地址
[USG6000V1-policy-nat-rule-huawei]action source-nat easy-ip //应用于easy ip
注意：如果配置了源区域没有配置源地址的话，那就是区域内的私网地址都可以转换，如果配置了源地址的话，那就要满足在源区域内的这个源地址才能被转换，目的区域和目的地址也是如此，但是我们配置的是easy ip所以不需要配置目标区域跟目标地址都可以通信，因为我们只有trust跟untrust区域
6. 验证效果：能够正常ping通
7. 抓包查看，发现源地址是出口路由器的IP地址，因为easy ip就是将内网地址转换成出口路由器上的公网地址出来访问
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f357107cd442bc0f2526648d5ecd9e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e721bb37a4d87b69a4b93452dad627d/" rel="bookmark">
			在控制台，如何修改react项目的表单中输入框的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现过程： 每个MVC或MVVM框架前端框架，为了是真实的DOM和虚拟DOM产生一一对应的关系，所以，在两者对象的属性中，互相绑定对方，以便随时引用
发现在react项目中，真实DOM被框架绑定了一些额外的属性，其中__reactEventHandlers$i9p2we6xi7b属性对象就是修改值的关键
该属性对象下，还绑定一些事件相关函数，只要触发事件相关函数，就可以执行相应操作，同时，要传入相关事件对象，所以，我们伪造事件对象{ target: { value: '输入值' } }传入，即可
查看元素 在元素面板中，选中对应的真实DOM，然后，以对象的形式打印选中的元素console.log('%O',$0);
找到键名中含有字段__reactEventHandlers的属性对象 const findHandler = (node) =&gt; { const handlerKey = Object.keys(node).find(k =&gt; new RegExp('__reactEventHandlers').test(k)) return node[handlerKey] } const reactVDom=findHandler(document.querySelector('#hjobTitle')) 触发事件相关函数 reactVDom.onChange(({ target: { value: value } })) 最终封装 const handler = async (selector, event, value = '') =&gt; { const getElement = (selector, timeout = 30) =&gt; { let count = 0; return new Promise((resolve) =&gt; { const timeId = setInterval(() =&gt; { if (timeout &amp;&amp; count++ &gt;= timeout) { clearInterval(timeId); return void resolve(null); } const node = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e721bb37a4d87b69a4b93452dad627d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd5882922e8bf4dca6296c8dc762a33/" rel="bookmark">
			vim删除行尾多余空格和tab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vim删除行尾多余空格和tab
1. 删除全文行尾tab和空格 底行模式下执行如下命令：
【%s】表示全文替换，【%】表示全文的意思，【#】是分隔符。
%s#\s\+$##g 如果不想进行文中局部内容替换，则修改范围即可，也就是更改命令最前面的【%s】，详细命令见后文。
2. 删除选中部分文字行尾tab和空格 有时候我们可能只需要删除部分选定内容的行尾tab和空格，操作方法是先通过可视模式选中要加工的段落，然后使用替换命令
命令：
1. 先光标定位到某一行 2. shift + v 进入可视模式 3. 移动光标直到选中所有想要替换的段落 4. 冒号，进入底行模式，会出现代码【:'&lt;,'&gt;】，该代码的含义表示当前选中的段落 5. 直接输入第一条命令中的百分号后面的部分：s/\s\+$//g，全部命令格式会变成这样【:'&lt;,'&gt;s/\s\+$//g】 6. 回车即可替换成功 3. 扩展，指定区域替换 替换命令格式原理为：【要替换的区域范围+替换操作】
如前面命令中 :
【%】表示全文 而后半部分
【s/\s\+$//g】 【左边第一个s】表示替换， 【s/aaa/bbb/g】三斜杠格式，表示将【左边的aaa】替换为【右边的bbb】，g表示全局 【\s\+$（即：上句描述的等效于左边的aaa的部分）】表示行尾空格和Tab 【等效bbb的部分没有内容，即相连的//】表示将上句描述的aaa部分替换为无内容 所以该命令等效于 【替换命令/行尾空格和tab//g】，即：将行尾空格替换为无内容（也就是删除）。 要表示区域的方法很多，除了全文，可视模式选中外，还有逗号指定行等。
下面列出几种以供参考：
3.1 全文aaa替换成bbb %s/aaa/bbb/g #匹配所有aaa都会被替换，包括qweraaazxcv这种中间的aaa 或 %s/\&lt;aaa\&gt;/bbb/gc #替换时全字符匹配aaa，如xyzaaajih中间的aaa就不会被替换，c表示每次替换都询问，输入y确定替换，输入n不替换 3.2 可视模式选中段落进行替换 操作方法不再赘述，见前面第二小节，记得要先进入可视模式选择文本然后替换就行。
'&lt;,'&gt;s/aaa/bbb/gc #将可视模式选中的文本中的aaa替换为bbb 3.3 按照行指定段落进行局部替换 20,50s/aaa/bbb/gc #将第20行到50行的aaa替换为bbb 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3de79fbc301c0bf4b791909fd4b1799/" rel="bookmark">
			软考|高级信息系统项目管理师
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、信息系统项目管理师考试介绍： 考试科目有三科，且成绩不延续，考试都合格后的证书是永久有效的。
二、考试内容大纲 考试内容也是范围很广，看出题老师的出题难度。如果只是通过粗略的看教材，没有对各方面知识的深度理解，如果出题老师为了增加难度，要求有一定理解的话，那么只是通过背教材的话就很难通过了。
三、考试经验分享 清晰了考试内容和大纲，那么接下来就是备考方法了哟~
1、科学合理安排考试顺序 首先，通读教程（《信息系统项目管理师教程》），首先对教程中的各章节及知识点有一个基本的认识，第一阶段基本以泛读为主，不求立刻记得所有知识点。
综合知识 （选择题） 包含的知识面非常广，包含了计算机知识、系统集成技术知识、法律法规知识、项目管理知识、管理运筹知识以及英语题等，所以该科目有可能是整个项目管理师的难点。
备考建议：大家在备考选择题的时候，观察近几年的考试真题，找寻其中的规律，试着揣摩出题者的出题思维想法
历年真题一定要去做，建议把17年及以后的考试真题好好刷一遍！做真题不是为了记原题，而是为了查漏补缺，在做题的过程中建议举一反三。总之，真题就是六个字！做它！做它！做它！
案例分析 （简答题） 虽然是主观题，需要进行分析，但目前这部分内容出题的灵活性还没扩大，主要考的是一个基础知识和理论知识点。
备考建议：一般是情景分析，也会出现一些计算题，计算题就相对简单些，不过往往会引你入坑，所以才说备考时做历年真题的时候，要慢慢体会出题老师的思路，多读几遍题干，把题目完全弄清楚了之后再做；如果是情景分析题，就要是看对知识点的掌握程度和灵活运用，要会分析题目考的哪几个知识点，也是多刷题，掌握规律的
论文 写作 对有项目管理经验的人来说不是难题，但由于信息系统项目管理师对报考条件没有限制，所以有很大一部分没有项目管理经验的人参加考试，对这部分人员，论文有可能变成他们的难题。
备考建议：就是不管你有没有项目经验，先找几篇范文，看看人家的摘要（背景）是怎么写的，凡是涉及职责、周期、资金、功能简介、技术等等，考试中小标题提到的点都一定要点到。毕竟背景是整篇论文的开头，成不成一眼就能看到，因此，我们一定要反复打磨反复提炼精华。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca94f87abb06a0049585d093773a231f/" rel="bookmark">
			别滥用FileProvider了，Android中FileProvider的各种场景应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
有部分同学只要是上传或者下载，只要用到了文件，不管三七二十一写个 FileProvider 再说。
不是每一种情况都需要使用 FileProvider 的，啥？你问行不行？有没有毛病？
这... 写了确实可以，没毛病！但是这没有必要啊。
如果不需要FileProvider就不需要定义啊，如果定义了重复的 FileProvider，还会导致清单文件合并失败，需要处理冲突，从而引出又一个问题，解决 FileProvider 的冲突问题，当然这不是本文的重点，网上也有解决方案。
这里我们只使用 FileProvider 来说，分析一下如下场景：
1.比如我们下载文件到SD卡，当然我们一般都下载到download目录下，那么使用这个文件，需要 FileProvider 吗？
不需要！因为他是共享文件夹中，并不是在沙盒中。
2.那我们把文件保存到沙盒中，比如 getExternalFilesDir 。那么我们使用这个沙盒中的文件，需要 FileProvider 吗？
3.看情况，如果只是把此文件上传到服务器，上传到云平台，也就是我们自己App使用自己的沙盒，是不需要 FileProvider 的
4.如果是想使用系统打开文件，或者传递给第三方App，那么是需要 FileProvider 的。
也就是说一般使用场景，我们只有在自己App沙盒中的文件，需要给别的App操作的时候，我们才需要使用 FileProvider 。
比较典型的例子是，下载Apk到自己的沙盒文件中，然后调用Android的Apk安装器去安装应用（这是一个单独的App），我们就需要 FileProvider 。
或者我们沙盒中的图片，需要发送到第三方的App里面展示，我们需要 FileProvider 。
话不多说，我们从常规的使用与示例上来看看怎么使用，清楚它的一些小细节。
一、常规使用与定义
一般来说没有什么特殊的需求，我们使用系统自带的 FileProvider 类来定义即可。
我们再清单文件注册我们的FileProvider
&lt;provider android:authorities="com.guadou.kt_demo.fileprovider" android:name="androidx.core.content.FileProvider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_path"&gt; &lt;/meta-data&gt; &lt;/provider&gt; 复制代码 属性的一些说明：
authorities 是标记我们这个ContentProvider的唯一标识，是一个用于认证的暗号，我们一般默认使用包名+fileprovider来定义。（能不能使用别的，可以，abcd都行，但是没必要）name 是具体的FileProvider类，如果是系统的，就用上面的这种，如果是自定义的，就写自定义FileProvider的全类名。exported 是否限制其他应用获取此FileProvider。grantUriPermissions 是否授权其他应用获取访问Uri权限，一般为true。meta-data 和下面的 name 都是固定的写法，重点是 resource 需要自己实现规则，定义哪些私有文件会被提供访问。 看看我们定义的file_path文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca94f87abb06a0049585d093773a231f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a3ef875d96a26c4a630b863044a664b/" rel="bookmark">
			ubuntu下查看显卡驱动是否成功安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ubuntu下查看显卡驱动是否成功安装的方法 ubuntu下查看显卡驱动是否成功安装的方法方法一：通过查看`设置-&gt;详细信息-&gt;关于`查看方法二：通过终端查看方法三：通过终端 `nvidia-smi`查看 ubuntu下查看显卡驱动是否成功安装的方法 安装完显卡驱动后，需要先重启电脑
sudo reboot # 重启电脑 方法一：通过查看设置-&gt;详细信息-&gt;关于查看 如果能看查看到对应的显卡型号，则说明显卡驱动安装成功。
这里展示下安装未成功的情况截图：
方法二：通过终端查看 ubuntu下查看显卡驱动是否成功安装的运行命令：
glxinfo | grep rendering 如果结果是yes，说明显卡驱动已经成功安装。
如果上述指令运行不成功，可能是因为系统里面没有安装mesa-utils，可以直接二进制安装：
sudo apt-get install mesa-utils 然后再运行命令 glxinfo | grep rendering.
方法三：通过终端 nvidia-smi查看 nvidia-smi #查看GPU信息, 安装完显卡驱动后需要先重启一次电脑 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57cb98202f34510f2dc7bef3899fc9f7/" rel="bookmark">
			CSS盒子模型详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用CSS进行网页布局时，我们一定离不开的一个东西————盒子模型。盒子模型，顾名思义，盒子就是用来装东西的，它装的东西就是HTML元素的内容。或者说，每一个可见的 HTML 元素都是一个盒子，下面所说的盒子都等同于 HTML 元素。这里盒子与 中的盒子又有点不同，这里的盒子是二维的。
盒子的组成 一个盒子由外到内可以分成四个部分：margin（外边距）、border（边框）、padding（内边距）、content（内容）。会发现margin、border、padding是CSS属性，因此可以通过这三个属性来控制盒子的这三个部分。而content则是HTML元素的内容。
盒子的大小 盒子的大小指的是盒子的宽度和高度。大多数初学者容易将宽度和高度误解为width和height属性，然而默认情况下width和height属性只是设置content（内容）部分的宽和高。盒子真正的宽和高按下面公式计算：
盒子的宽度 = 内容宽度 + 左填充 + 右填充 + 左边框 + 右边框 + 左边距 + 右边距
盒子的高度 = 内容高度 + 上填充 + 下填充 + 上边框 + 下边框 + 上边距 + 下边距
为了显得专业一点，我们还可以用带属性的公式表示：
盒子的宽度 = width + padding-left + padding-right + border-left + border-right + margin-left + margin-right
盒子的高度 = height + padding-top + padding-bottom + border-top + border-bottom + margin-top + margin-bottom
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57cb98202f34510f2dc7bef3899fc9f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/517c12ed5afcd23fb426f75ddbeb4446/" rel="bookmark">
			centos搭建hadoop伪分布式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境准备 Centos7虚拟机一台
jdk1.8
hadoop-3.1.3
附华为开源镜像站下载地址:https://mirrors.huaweicloud.com/java/jdk/
二、java 环境安装 使用root用户登录并创建文件夹
cd /opt mkdir app mkdir soft 将下载好的jdk和hadoop安装包上传到虚拟机的/opt/soft目录下
1、创建hadoop用户和用户组 #创建用户组 groupadd hadoop #创建用户 useradd hadoop #hadoop用户设置密码 passwd hadoop #将/opt目录的所有者修改为hadoop，否则没有权限操作 chown -R hadoop:hadoop /opt 2、编辑/etc/sudoers #vim /etc/sudoers找到“root ALL=(ALL) ALL”一行，
#在下面插入新的一行，内容是“hadoop ALL=(ALL) ALL”
vim /etc/sudoers #加入下面的内容 hadoop ALL=(ALL) ALL 使用:wq! 进行保存并退出编辑。必须加！否则编辑不成功。
#切换成hadoop用户 su hadoop 准备好的安装包及安装包位置
后续的环境搭建和操作均在hadoop用户下进行操作
3、解压jdk tar -zxvf jdk-8u151-linux-x64.tar.gz -C ../app/ 4、对解压后的jdk包进行重新命名。 cd ../app #注意更换为自己jdk的包名称 mv jdk1.8.0_151/ java 5、配置java的环境变量 vim ~/.bashrc #加入下面的内容 export JAVA_HOME=/opt/app/java export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/517c12ed5afcd23fb426f75ddbeb4446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0b0ee533f6f55d267728398fe49d45c/" rel="bookmark">
			python系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python系列 课程资源笔记整理不易，需要自取：
链接：https://pan.baidu.com/s/1-lgtPxh_aGZvBVkGD_zWOg?pwd=5210
提取码：5210
–来自百度网盘超级会员V3的分享
资料整理不易，需要自取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6641439b556ae7d370d7194b09e576b/" rel="bookmark">
			【知识点】Javascript 知识点和常考面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS 基础知识点及常考面试题（一） 最近有些粉丝私信要我弄些干货,当然这也为了自己跳槽,所做的知识储备吧。
JS 对于每位前端开发都是必备技能，在小册中我们也会有多个章节去讲述这部分的知识。首先我们先来熟悉下 JS 的一些常考和容易混乱的基础知识点。
原始（Primitive）类型 涉及面试题：原始类型有哪几种？null 是对象嘛？ 在 JS 中，存在着 6 种原始值，分别是：
booleannullundefinednumberstringsymbol 首先原始类型存储的都是值，是没有函数可以调用的，比如 undefined.toString()
此时你肯定会有疑问，这不对呀，明明 '1'.toString() 是可以使用的。其实在这种情况下，'1' 已经不是原始类型了，而是被强制转换成了 String 类型也就是对象类型，所以可以调用 toString 函数。
除了会在必要的情况下强转类型以外，原始类型还有一些坑。
其中 JS 的 number 类型是浮点类型的，在使用中会遇到某些 Bug，比如 0.1 + 0.2 !== 0.3，但是这一块的内容会在进阶部分讲到。string 类型是不可变的，无论你在 string 类型上调用何种方法，都不会对值有改变。
另外对于 null 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。
对象（Object）类型 涉及面试题：对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？ 在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。
const a = [] 对于常量 a 来说，假设内存地址（指针）为 #001，那么在地址 #001 的位置存放了值 []，常量 a 存放了地址（指针） #001，再看以下代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6641439b556ae7d370d7194b09e576b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/703c1ef758a8dbf3eed940b52c12108b/" rel="bookmark">
			iOS给View添加虚线边框不显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 国庆回来有小半个月没写代码了，生疏~国庆快乐啊！
今天浅浅的UI验收，提了一个bug说我没画一个输入框背景的边框虚线，真的3Q了，其实吧我司一直用的摹客这个平台，浅浅吐槽一下，当选中某个控件的时候，这的确是实线啊，小王无语
未选中状态
选中状态
图示是我放大172%倍看出来的，摹客网编辑、看到请优化一下，感谢。
当然了，这不是问题主要原因。
问题描述 最常规的给View添加虚线边框，但是不显示
UIBezierPath *maskPath=[[UIBezierPath bezierPathWithRoundedRect:self.messageTf.bounds byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(10.5*FTGetScreenScale(), 10.5*FTGetScreenScale())] bezierPathByReversingPath]; CAShapeLayer *border = [CAShapeLayer layer]; //虚线的颜色 border.strokeColor = [UIColor colorWithRed:151/255.0 green:151/255.0 blue:151/255.0 alpha:0.54].CGColor; border.masksToBounds = YES; //填充的颜色 border.fillColor = [UIColor clearColor].CGColor; //设置路径 border.path = maskPath.CGPath; border.frame = self.messageTf.bounds; border.lineCap = @"square"; //虚线的宽度 border.lineWidth = 1.f; //虚线的间隔 border.lineDashPattern = @[@4, @4]; [self.messageTf.layer addSublayer:border]; 原因分析： 我在viewDidLoad 刷新UI用的mas定义self.messageTf控件，此时的长宽为0
原本以为是self.messageTf.bounds没有用self.messageTf.frame，一样无效
使用Masonryframe跟bounds为0的情况
解决方案： 在添加虚线前，直接刷新视图，以获得视图的长和宽。
[self.view layoutIfNeeded]; 同理，如果bounds为0的情况下，直接刷新一下布局就ok了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb556f72b3e27011d5efc31bce370c64/" rel="bookmark">
			Ubuntu20.04安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、准备工作1.镜像文件下载2.启动盘制作 二、Ubuntu系统安装总结 前言 DELL笔记本安装Ubuntu20.04
一、准备工作 1.镜像文件下载 首先去官网下载镜像文件，一般官网展示的是最新版，要找到需要安装的版本，可以点击右上角搜索输入20.04
点击第一个
页面往下翻，找到ubuntu-20.04.4-desktop-amd64.iso下载
2.启动盘制作 参考软碟通安装方法
在官网下载软碟通安装包并按照提示安装好
插入u盘并启动软碟通，点击文件-打开，选中下载的镜像文件
点击启动-写入硬盘映像
选择u盘，点击写入
写入完成
二、Ubuntu系统安装 插入u盘，开机后立刻按F2（不同品牌电脑不一样）进入BIOS设置
点击Boot Configuration
将最后一项调整至最上面
页面往下拉，改成OFF，点击下放APPLY CHANGES
打勾并点击OK
点击右下角EXIT
选择中文点击安装
继续
继续
继续
现在安装
继续
继续
输入信息继续
等待安装
重启
拔下u盘，Enter
选择ubuntu进入
输入密码即可进入系统，右上角切换中英文
总结 散会~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a21c77639f7896f15ab9473d09717b9e/" rel="bookmark">
			日志10.12FlowableUI应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Flowable之Eclipse流程绘制
1.下载，安装flowable插件，绘制flowable流程图。2.在IDEA代码部署流程
二、FlowableUI应用
1.安装Flowable UI,绘制并导出流程图
Flowable UI是 Flowable 的 WEB 应用，用来设计流程、处理流程等等。
从官网Flowable Open Source Code下载安装包flowable-6.7.2.zip并进行相关配置，尝试启动Tomcat服务。
这里介绍在windows系统中启动tomcat，主要的两种方式：
（1）将tomcat启动载入系统服务中，进入tomcat中bin目录，进入cmd命令窗，运行命令：
service install
然后通过系统服务启动
（2）.通过双击tomcat/bin目录下的startup.bat
启动成功后，在浏览器中访问 http://localhost:8080/flowable-ui, 默认的账号密码是 admin/test
2.进行基础设计
• 任务应用程序：这个模块主要进行流程相关的操作，比如发起、审核等，发布后的应用程序会显示在这里
• 建模器应用程序：这个模块是核心，主要用来创建流程、发布流程等等
• 管理员应用程序：这个模块就是管理发布的应用程序，可以上传/删除应用程序等等
• 身份管理应用程序：这个模块就是用户管理模块，包括用户的创建、权限分配等等
3.演示和启动流程
三、解决出现的问题
1.eclipse中安装flowable插件要注意eclipse版本和flowable版本
2.如果启动中出现乱码修改Tomcat的conf目录下的 logging.properties 文件中的编码添加
Java.util.logging.ConsoleHandler.encoding=GBK
demo参考https://juejin.cn/post/7025979116679593998
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c02289f48808f8f5aceb9a02989d5ca5/" rel="bookmark">
			盘点下半年EI国际会议，值得收藏！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鉴于一些小伙伴正在为找不到合适的投稿渠道而苦恼
本编内容为大家整理了下半年截稿的优质EI会议3则
涵盖计算机多个方向征稿
相信总有一个会议适合你~
现在添加微信咨询，还可申请早鸟优惠注册！
01
第三届计算机、大数据与人工智能国际会议
【大会官网】：http://www.iccbdai.org/
【会议时间】：12月16-18日
【会议地点】：中国·张家界
【截稿日期】：2022年11月15日
【投稿通道】：扫描下方二维码，可直接跳转
http://www.iccbdai.org/submission/index.html
【官方邮箱】：iccbdai@126.com
【收录检索】：EI、Scopus
【组委会肖老师】：19911327675
【添加下方肖老师微信，可咨询更多会议详情】
大会简介
第三届计算机、大数据与人工智能前沿国际会议将于2022年12月16-18日在湖南张家界盛大举行，会议将围绕计算机、大数据与人工智能等相关研究领域，广泛邀请国内外知名专家学者、行业精英进行研讨学习。大会旨在为来自国内外高校的专家、学者提供一个高水平的信息沟通平台。组委会诚邀各位专家学者踊跃投稿并参会交流。
主办方：湖南大学、怀化学院
协办方：中南大学、华中科技大学、华南理工大学、北京工业大学等 大会主席
阳王东 湖南大学
现任湖南大学教授，湖南省“121”人才计划人选。他的研究重点是高性能计算和并行数值算法，并长期在天河一号、二号和神威太湖之光超级计算机上设计和应用并行算法，主持开发了一系列基础数值算法函数库，曾获湖南省科技进步一等奖。主持科研项目10余项，其中国家自然科学基金面上项目2项，国家重点研发项目2项，湖南省重点研发项目和企业项目1项。在TC、TPDS、TKDD发表SCI或EI收录论文30余篇。
刘 驰 北京理工大学
现任北京理工大学教授、计算机学院副院长，他分别在清华大学和帝国理工学院获得学士和博士学位。先后入选IET Fellow、英国计算机学会Fellow、中国电子学会Fellow、IBM TJ Watson研究中心、IBM中国研究院研究主任，国家优秀青年科学基金获得者，德国电信研究院（柏林）博士后研究员，国家信息产业“十四五”规划专家咨询组成员，第四届国家信息标准委员会技术委员会委员，执行委员CCF青年委员会委员，CCF会员，CCF杰出会员，中国电子学会理事，IEEE Transactions on Network Science and Engineering编委。他的研究兴趣包括大数据和物联网技术。主持国家自然科学基金青年计划、国家重点研发计划、工业和信息化部、教育部等国家级科研项目20余项。发表CCF-A论文30余篇，ESI高被引论文3篇，国内外发明专利21项，著作9部，Google Scholar检索4600余次，H索引31项。
主讲嘉宾
李克勤 湖南大学
IEEE Fellow，目前是纽约州立大学计算机科学系的 SUNY 特聘教授，也是中国湖南大学的国家特聘教授。他撰写或合著了 810 多篇期刊文章和会议论文，并获得了多项最佳论文奖。拥有国家知识产权局公布或授权的专利60余项。他是基于Scopus引文数据库综合指标的并行和分布式计算领域全球十大最具影响力科学家之一。他目前的研究兴趣包括云计算、雾计算与移动边缘计算、节能计算与通信、嵌入式系统与信息物理系统、异构计算系统、大数据计算、高性能计算、CPU-GPU混合与协同计算, 计算机体系结构和系统, 计算机网络, 机器学习, 以及智能和软计算。他主持了许多国际会议，担任多个杂志的编委。
Prof. Okyay Kaynak 英国伯明翰大学
IEEE Fellow，Okyay Kaynak 教授分别于 1969 年和 1972 年在英国伯明翰大学获得电子和电气工程学位。从 1972 年到 1979 年，他在该行业担任过多个职位。1979 年，他加入了位于土耳其伊斯坦布尔的 Bogazici 大学电气与电子工程系。他目前是这所大学的名誉教授。他曾在日本多个机构担任长期（接近或超过一年）访问教授/学者职位，德国、美国、新加坡和中国。他目前的研究兴趣是广泛的智能系统领域。他撰写了 450 多篇论文，这些论文已出现在各种期刊和会议论文集中。他曾任IEEE Trans的主编，目前在担任 Springer 杂志《发现人工智能》的创始主编。此外，他还是多个学术期刊的编辑或顾问委员会成员。曾获得中国政府友谊奖、洪堡研究奖、匈牙利奥布达大学荣誉博士（2020年）和土耳其科学院院士奖（2020年）等多个奖项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c02289f48808f8f5aceb9a02989d5ca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d4459e11d4a5b8d47ceb8a08531f3be/" rel="bookmark">
			Zabbix5.0 LTS&#43;PHP7.4.30&#43;Nginx-1.21.6编译安装&#43;mysql rpm安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zabbix5.0 LTS，PHP7.4.30，Nginx-1.21.6编译安装，mysqlrpm安装教程 由于生产环境各种权限要求，没有rpm安装权限以及内网环境限制，本文主要介绍 Zabbix生产环境编译安装方法，方便内网安装部署。并介绍zabbix自定义监控部署步骤。
**注意：**本文配置中部分路径以及ip来自生产环境，部分测试环境，前后可能有矛盾，可忽略。
zabbix简介 概述 ​ Zabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供柔软的通知机制以让系统管理员快速定位/解决存在的各种问题。
基础架构 ​ 核心组件主要是 Agent 和 Server，其中 Agent 主要负责采集数据并通过主动或者被动的方 式采集数据发送到 Server/Proxy，除此之外，为了扩展监控项，Agent 还支持执行自定义 脚本。Server 主要负责接收 Agent 发送的监控信息，并进行汇总存储，触发告警等。Zabbix Server 将收集的监控数据存储到 Zabbix Database 中。Zabbix Database 支持常用的关系 型数据库，如果 MySQL、PostgreSQL、Oracle 等，默认是 MySQL，并提供 Zabbix Web 页面（PHP 编写）数据查询。
主机规划： IP地址组件10.8.71.29zabbix_agent10.8.71.30zabbix_agent10.8.71.31zabbix_agent10.8.71.32zabbix_agent10.8.71.33zabbix_agent10.8.71.34zabbix_agent10.8.71.35zabbix_agent,mysql10.8.71.36zabbix_server,zabbix_agent,php7.4.30,nginx Mysql安装 注意：mysql以下操作需要root用户或需要sudo权限
下载安装包 mysql下载地址：https://downloads.mysql.com/archives/community/
清理mysql环境 一台服务器只能安装一个版本的MySQL/MariaDB软件，所以需要删除原有的MySQL/MariaDB
# 查看是否自带mysql rpm -qa | grep mariadb 或 rpm -qa|grep -i mysql # 如果安装了MySQL，就先卸载 rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64 安装 #上传并解压tar文件 tar -xvf mysql-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d4459e11d4a5b8d47ceb8a08531f3be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8ccec023e9b0f57bd2bef8014f83e7f/" rel="bookmark">
			Mybatis 源码分析（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 沿着上篇文章，咱们继续分析，没看过的小伙伴可以点下面链接去看看。Mybatis 源码分析（一）https://blog.csdn.net/cfa3288/article/details/127240553?spm=1001.2014.3001.5501
SqlSession 程序每一次操作数据库，都需要创建一个会话，我们用OpenSession()方法来创建。接下来看看SqlSession创建过程中做了哪些操作
SqlSession sqlSession = factory.openSession(); 通过前面创建的DefaultSqlSessionFactory的openSession方法来创建 ，默认获取的simple执行器。
@Override public SqlSession openSession() { return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false); } 继续往下看。..
在解析environment标签的时候会创建TransactionFactory对象，根据事务工厂和默认的执行器类型，创建执行器。最后返回的是一个DefaultSqlSession对象，在这个DefaultSqlSession对象中包括了Configuration和Executor对象
private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) { Transaction tx = null; try { final Environment environment = configuration.getEnvironment(); // 获取事务工厂 final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); // 创建事务 tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); // 根据事务工厂和默认的执行器类型，创建执行器 final Executor executor = configuration.newExecutor(tx, execType); return new DefaultSqlSession(configuration, executor, autoCommit); } catch (Exception e) { closeTransaction(tx); // may have fetched a connection so lets call close() throw ExceptionFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8ccec023e9b0f57bd2bef8014f83e7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7817fdbdf1a770b46ec7ff76f6fe802/" rel="bookmark">
			vue 全屏和取消全屏，选择文件（上传图片等）时状态出现异常，选择文件时退出全屏状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue推荐使用插件screenfull。
代码：
&lt;div class="alignCenter mr10 active_t" @click="handleFullScreen" style="font-size: 16px;color: #999;"&gt; &lt;Icon type="md-resize" style="font-size: 16px;" /&gt; &lt;span style="margin-left:2px;"&gt;{{fullscreen?`取消全屏`:`全屏`}}&lt;/span&gt; &lt;/div&gt; // 全屏事件 handleFullScreen() { // 此处可根据获取节点进行区域全屏事件 let element = document.documentElement; if (this.fullscreen) { if (document.exitFullscreen) { document.exitFullscreen(); } else if (document.webkitCancelFullScreen) { document.webkitCancelFullScreen(); } else if (document.mozCancelFullScreen) { document.mozCancelFullScreen(); } else if (document.msExitFullscreen) { document.msExitFullscreen(); } } else { if (element.requestFullscreen) { element.requestFullscreen(); } else if (element.webkitRequestFullScreen) { element.webkitRequestFullScreen(); } else if (element.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7817fdbdf1a770b46ec7ff76f6fe802/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0445e1c8528a00ca1e3794c2ae267c7b/" rel="bookmark">
			hmm解码：维特比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hmm 解码部分：维特比 矩阵编程 #hmm 解码部分：维特比矩阵编程 import numpy as np def Viterbi(A, B): """ :para:A 发射矩阵 :para:B 状态转移矩阵 """ #row为观测的样本数/序列长度；col为状态变量数量 (row, col) = A.shape #首个样本的观测概率分布/当前col个状态的最佳分数 score = A[0, :] #记录首个样本的最优路径（None-&gt;第一时刻col个结点） path = [[j, None] for j in range(col)] #从第二个时刻开始遍历 for i in range(1, row): #计算i-1到i时刻，各个转移状态的分数；数组s[a][b]表示i-1时刻的a状态转移到i时刻b状态的得分 s = score[:, None] + B + A[i, None, :] #计算到i时刻col个状态的最高得分的i-1时刻状态路径 j = np.argmax(s, axis=0) #计算到i时刻col个状态的最高得分 score = np.take_along_axis(s, j[None, :], axis=0)[0] #计算到i时刻col个状态的最高得分的全量路径 path = [[ii, path[jj]] for (ii, jj) in enumerate(j)] #选取最后一个时刻的最佳路径 l = path[np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0445e1c8528a00ca1e3794c2ae267c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bda40cf0a4f218f108b71dfa55451df/" rel="bookmark">
			软考-错题积累（数据库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 数据库 1.1 数据的物理独立性是指当数据库的内模式发生改变时，数据的逻辑结构不变。为了保证应用程序能够正确执行，需要通过修改（概念）模式/内模式之间的映像。
数据的逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构发生变化后，用户程序也可以不修改。但是为了保证应用程序能够正确执行，需要修改外模式/（概念）模式之间的映像。
1.2 关系规范化在数据库设计的逻辑设计阶段进行。
1.3 数据库设计通常分为6个阶段
1：需求分析：分析用户的需求，包括数据、功能和性能需求；
2：概念结构设计：主要采用E-R模型进行设计，包括画E-R图；
3：逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；
4：数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存取路径；
5：数据库的实施：包括编程、测试和试运行；
6：数据库运行与维护：系统的运行与数据库的日常维护。
1.4 数据库管理系统的安全措施有3个方面：
①权限机制：通过权限机制，限定用户对数据的操作权限，把数据的操作限定在具有指定权限的用户范围内，以保证数据的安全。在标准SQL中定义了授权语句GRANT来实现权限管理。
②视图机制：通过建立用户视图，用户或应用程序只能通过视图来操作数据，保证了视图之外的数据的安全性。
③数据加密：对数据库中的数据进行加密，可以防止数据在存储和传输过程中失密。
1.5 典型的启发式规则
（1） 选择运算应尽可能先做
在优化策略中这是最重要、最基本的一条。
（2）把投影运算和选择运算同时进行
如有若干投影和选择运算，并且它们都对同一个关系操作，则可以在扫描此关系的同时完成所有的这些运算以避免重复扫描关系。
（3） 把投影同其前或其后的双目运算结合起来，没有必要为了去掉某些字段而扫描一遍关系。
（4） 把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算，连接特别是等值连接运算要比同样关系上的笛卡尔积省很多时间。
（5） 找出公共子表达式
如果这种重复出现的子表达式的结果不是很大的关系
并且从外存中读入这个关系比计算该子表达式的时间少得多
则先计算一次公共子表达式并把结果写入中间文件是合算的。
当查询的是视图时，定义视图的表达式就是公共子表达式的情况
1.6 共享锁(S锁)又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。
排他锁(X锁)又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。
1.7 JDBC是java技术中访问数据库的方式，也是目前用Java技术实现的基于Web的应用的数据库访问方式。
COM是一种组件技术；
CGI是一种网络应用技术；
XML是一种格式定义；
1.8 若X-&gt;Y,X-&gt;Z，则X-&gt;YZ为F所蕴涵是Armstrong公理系统的合并规则；
若X-&gt;Y,WY-&gt;Z,则XW-&gt;Z为F所蕴涵是Armstrong公理系统的伪传递律；
若X-&gt;Y，Y-Z为F所蕴涵，则X-&gt;Z为F所蕴涵是Armstrong公理系统的传递律；
若X-&gt;Y为F所蕴涵，且Z⊆U，则XZ-&gt;YZ为F所蕴涵是Armstrong公理系统的增广律；
1.9 Data Extraction:数据抽取。
OLAP（On-Line Transaction Pressing）：联机事务处理过程，也称面向交易的处理过程，其基本特征是前台接收的用户数据可以立即传送到计算中心进行处理，并在很短的时间内给出处理结果，是对用户操作快速响应的方式之一。
DM（Data Mining）和OLAP同为分析工具，其差别在于OLAP提供用户一个便利的多维度观点和方法，以有效率地数据进行复杂的查询动作，其预设查询条件由用户预先设定，而数据挖掘则能由资讯系统主动发掘资料来源中未曾被察觉的隐藏资讯，透过用户的认知以产生信息。
ETL(Extract-Transform-Load)用来描述将数据从来源端经过抽取（Extract）、转换（Transform）、加载（Load）至目的端的过程。ETL是构建数据仓库的重要一环，用户从数据源抽取出所需的数据，经过数据清洗，最终按照预先定义好的数据仓库模型，将数据加载到数据仓库中去。
1.10 分布式数据库基本概念：
逻辑透明（局部数据模型透明），是指用户或应用程序无须知道局部场地使用的是哪种数据模型。位置透明是指用户无须知道数据存放的物理位置。分片透明是指用户或应用程序无须知道逻辑上访问的表具体是怎么分块存储的。复制透明是指采用复制技术的分布方法，用户无须知道数据是复制到哪些节点，如何复制的。 1.11 分布式数据库基本概念：
（1）共享性：是指数据存储在不同的节点数据共享；
（2）自治性：指每节点对本地数据都能独立管理；
（3）可用性：是指当某一场地故障时，系统可以使用其他场地的副本而不至于使整个系统瘫痪；
（4）分布性：是指数据在不同场地上的存储。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bda40cf0a4f218f108b71dfa55451df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/926126d7d1d322ded997526cbada9a8f/" rel="bookmark">
			java中集合及其实现类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：本文材料来源于bilibili动力节点视频，仅为学习使用！！！
Collection
1. List接口继承Collection接口，Collection接口继承了Iterable接口。
Iterable接口中定义了iterator()抽象方法，获得迭代器对象。
使用迭代器hashNext方法，next方法对Iterable实现类进行遍历。
所以但凡是Iterable下的子类均可以获得迭代器对象进行遍历。
iterator的remove方法移除某个下标的对象，将其返回并将指针前移一位。
2. Collection接口下还分List接口，Set接口：
List是有序可重复的，Set是无序不可重复的。有序是指存进去是什么顺序，取出来就是什么顺 序。无序是存进去是什么顺序，取出来不一定是原来的顺序。可重复是指存入的元素可以相同。 不可重复是指存入的元素不可以相同。
Collection中contains(Object o)方法会调用o.equals()方法，所以要求Collection中的元素重写equals方法。
3. List接口的常用实现类：ArrayList，LinkedList，Vector。
ArrayList：底层数据结构是数组。在内存中连续存储。有序可重复。有下标。优点是在末尾增加元素的效率高。根据下标查找元素效率高。缺点是随机增删元素效率低。不指定容量的情况下，默认容量是10，当实际容量等于最大容量时会自动扩容，增加到原来的1.5倍。扩容会导致运行效率降低，所以尽量避免扩容行为的出现。
LinkedList：底层数据结构是双向链表，在内存中分散存储。优点是随机增删元素效率高。缺点是查询某个元素效率低，每次都要遍历整个链表。
Vector：底层数据结构是数组，是线程安全的。类中每个方法都有synchronized关键字，所以Vector使用时效率低。
4. Set接口的常用实现类：HashSet，TreeSet（实现SortedSet可排序的set）
HashSet:底层数据结构是HashMap，无序不可重复。往HashSet中添加元素等于往HashMap的key部分添加元素。具体细节见下面HashMap。
TreeSet实现了SortedSet接口，SortedSet接口继承Set接口。所谓sort即可排序的。底层数据结构是TreeMap二叉树。装入的Set集合中的元素要实现Comparable接口的compareTo方法或者在创建HashSet对象时传入一个Comparator接口实现。需按自己的需求写比较规则。二叉树通过比较大小来判断进入左子树还是右子树。
private V put(K key, V value, boolean replaceOld) { Entry&lt;K,V&gt; t = root; if (t == null) { addEntryToEmptyMap(key, value); return null; } int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) { do { parent = t; cmp = cpr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/926126d7d1d322ded997526cbada9a8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1feb90f3c7b44531cc62d3b514cb8ddb/" rel="bookmark">
			2022-10-12 达梦7 设置主键自增
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		达梦7 设置主键自增 达梦7 设置主键自增 达梦7 设置主键自增 设置是否允许将显式值插入表的自增列中。
语法格式
SET IDENTITY_INSERT [&lt;模式名&gt;.]&lt;表名&gt; ON | OFF;
创建表时使用identity(1,1)设置主键自增，一个表只能有一个自增列
CREATE TABLE "NBFG"."DATA_MODEL_SPEED_POWER_NEW" ( "ID" INT IDENTITY(1, 1) NOT NULL, "FAN_MODEL" VARCHAR(30) NOT NULL, "WIND_SPEED" FLOAT NOT NULL, "WIND_POWER" FLOAT NOT NULL, "DELETED" INT DEFAULT 0 NOT NULL, "STORAGE_TIME" DATETIME(6) DEFAULT CURRENT_TIMESTAMP(), "MODIFIED_TIME" DATETIME(6), CLUSTER PRIMARY KEY("ID")) STORAGE(ON "MAIN", CLUSTERBTR) ; COMMENT ON TABLE "NBFG"."DATA_MODEL_SPEED_POWER_NEW" IS '风机功率曲线'; COMMENT ON COLUMN "NBFG"."DATA_MODEL_SPEED_POWER_NEW"."DELETED" IS '0未删除 1已删除'; COMMENT ON COLUMN "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1feb90f3c7b44531cc62d3b514cb8ddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da234d29333e728d082f818260c2fee8/" rel="bookmark">
			小白burp Suite超详细安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
安装bp
修改系统环境变量
设置代理
小插件
安装bp 资源包进我的资源可以下载，记录一下我的本地安装包（百度网盘&gt;我的资源&gt;安装包&gt;butp suite）
首先打开资源包,打开jdk-11.0.14_windows-x64_bin.exe程序
直接下一步下一步，安装完成后关闭，注意这里安装的路径最好是默认路径，避免软件安装后续有问题
修改系统环境变量 点击此电脑&gt;属性&gt;高级系统设置&gt;环境变量&gt;系统变量- 新建
添加两个变量
变量名：CLASSPATH
变量值：,;%JAVA_HOME%\lib
变量名：JAVA_HOME
变量值：C:\Program Files\Java\jdk-11.0.14\ #你自己刚才安装bp的路径
增加完这两个变量后再修改一个变量，双击path
新建，输入
%JAVA_HOME%\bin
这样环境变量就修改完啦
现在打开系统命令行win+r键，输入java -version，查看版本，输出成功说明成功
然后打开burploader-old.jar和ddosi.vbs
把1的内容粘贴到2，用ctrl+a全选，否则容易错，然后点击next
点击红框的按钮
再copy右边的到左边
然后复制到左边后会自动生成再黏贴到右边，点击next
然后点击next
就可以啦
设置代理 开启火狐设置代理
端口就写本机127.0.0.1端口号8080
设置代理后如果不导入bp的安全证书访问网站都会出现报警提示，所以我们导入bp的安全证书到浏览器里。
浏览器访问127.0.0.1:8080,下载bp的证书，点击CA Cerificate下载证书
下载位置记住，后续导入证书需要选择路径
回到设置，搜索证书，查看证书，并把刚才的证书导入
找到证书的文件，导入到证书颁发机构。
把勾勾勾上，然后确定，这样证书就导入进浏览器啦，然后访问网站的时候就不会危险警告了
小插件 有个一个人觉得还挺好用的插件，FoxyProxy，装完这个每次就不用手动开关代理了，有兴趣的可以下载一下，步骤也放在后面啦~~~
设置里面&gt;扩展和主题
搜索FoxyProxy
下载第一个
点击添加到firefox
蹦出来一个小窗口，点击添加
右上角多出来一个小狐狸，这就是我们安装的小插件，现在还没有开启，我们给他设置一下哈~
点击添加
自己可以设置名字随便写，代理ip设置成127.0.0.1本机地址，端口8080，点击保存。
现在使用代理时就可以直接开启我们的快乐干饭模式，不使用就点击关闭，是不是很方便呢~~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3f25a5c7a6721e4006c3405cee9fd0e/" rel="bookmark">
			大数据-ClickHouse技术一（安装部署）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零、大数据-ClickHouse做为列式数据库，是2016年由俄罗斯人开源，独立于Hoodop生态
研究一番使用如下
docker安装
一、安装
官网安装 | ClickHouse Docs
可以安装到linux服务器，与通过docker安装，方便简单。按照官方文档即可
后续文章使用的是docker方式
二、docker安装文档-服务端
Docker Hub
初始化docker文件见百度网盘：
链接：https://pan.baidu.com/s/12OiRnQhAQiRfb2hnIFXw2A 提取码：netx
文件介绍：docker文件-
ch_data初始化数据文件
ch_initdb数据库初始脚本，用于存放sql、sh脚本。在初始数据化前置同步，比如可以初始化一些数据，或者建基础表、基础库等等
ch_logs用于同步数据库的日志
通过使用docker执行启动命令：
docker run -d -p 18123:8123 -p 19000:9000 -v "$(pwd)/ch_data:/var/lib/clickhouse/" -v "$(pwd)/ch_logs:/var/log/clickhouse-server/" -v "$(pwd)/ch_initdb:/docker-entrypoint-initdb.d/" --name some-clickhouse-server --ulimit nofile=262144:262144 clickhouse/clickhouse-server 三、连接数据库-客户端
可以通过docke自带client服务来启动客户端，也可以通过常用的数据库连接工具
比如Dbeaver-也可以无缝连接ClickHouse数据库
四、初始化数据
docker环境可以初始化一批数据 1000W+ 或者几十亿数据，只需要在docker文件中加入数据文件即可。参考官方文档：示例数据集 | ClickHouse Docs
docker文件配置在：
ch_initdb文件夹中的 data.sh 来初始化库、表、数据 将附带数据文件下载放到同级文件夹中，同步数据库实例的时候将数据加载进去即可
五、数据库查询
支持常用的Mysql语法
比如：SLEECT、 CREATE、ALTER、
尤其对于GROUP BY、SUM、分组计算尤为擅长
linux tar文件安装 分片副本安装
一、按照官网安装
安装 | ClickHouse Docs
二、安装zooker集群
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3f25a5c7a6721e4006c3405cee9fd0e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/199/">«</a>
	<span class="pagination__item pagination__item--current">200/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/201/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>