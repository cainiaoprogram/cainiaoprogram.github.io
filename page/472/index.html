<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c5e2708f6aee4f14de52bbd78bd91c1/" rel="bookmark">
			Could not resolve hostname 。。。。。。: Name or service not known
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个是ssh基本操作的连接，当你配置完ssh之后，然后明明是正确的，然后你使用命令：
ssh localhost然后出现了
Could not resolve hostname github.com: Name or service not known 等等类似的话，那么说明你忘记了一个配置就是： /etc/hosts文件的映射：
如图配置就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004eabee4b17b34c02d3ebf87a764770/" rel="bookmark">
			安装程序无法创建新的系统分区，也无法定位现有系统分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法 先格式化一下你要装的那个盘，然后，拔出U盘，啥也别动，只拔出U盘究行，再装上U盘，然后刷新一下【选硬盘那里的高级选项中有格式化和刷新】，再选择要安装的硬盘点下一步，OK了，可以正常安装了 第二种(PE安装) 1、进入PE：从你解压的安装程序的文件夹中找到boot , bootmgr 和sources这三个文件，并且复制到C盘根目录下。 2、在win pe系统中运行cmd ，输入“ c:\boot\bootsect.exe /nt60 c: ”（注意exe和/nt60、/nt60和c:之间有空格），然后回车，看到提示successful 字样（画面会很快闪过，以至于来不及看。）的语句即成功了！然后重起电脑。注意命令 c:\boot\bootsect.exe /nt60 c:3、把U盘从电脑中拔出，取出U盘，然后从硬盘启动，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75138e1ce6cb154b2c35ab316694b681/" rel="bookmark">
			详解24个经典股票技术指标 （三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OBV指标的研判
OBV指标又叫能量潮指标，是由美国股市分析家葛兰碧所创造的，是一种重点研判股市成交量的短期技术分析工具。
第一节 OBV指标的原理和计算方法
一、 OBV指标的原理
能量潮OBV 指标是葛兰碧于本世纪60年代提出的，并被广泛使用。股市技术分析的四大要素：价、量、时、空。OBV指标就是从“量”这个要素作为突破口，来发现热门股票、分析股价运动趋势的一种技术指标。它是将股市的人气——成交量与股价的关系数字化、直观化，以股市的成交量变化来衡量股市的推动力，从而研判股价的走势。关于成交量方面的研究，OBV能量潮指标是一种相当重要的分析指标之一。
OBV指标由OBV值和OBV线构成的。OBV线方法是葛兰碧又一大贡献。他将“量的平均”概念加以延伸，认为成交量是股市的元气，股价只不过是它的表象特征而已。因此，成交量通常比股价先行。这种“先见量、后见量”的理论早已为股市所证明。
能量潮理论成立的依据重要是：
1、投资者对股价的评论越不一致，成交量越大；反之，成交量就小。因此，可用成交量来判断市场的人气和多空双方的力量。
2、重力原理。上升的物体迟早会下跌，而物体上升所需的能量比下跌时多。涉及到股市则可解释为：一方面股价迟早会下跌；另一方面，股价上升时所需的能量大，因此股价的上升特别是上升初期必须有较大的成交量相配合；股价下跌时则不必耗费很大的能量，因此成交量不一定放大，甚至有萎缩趋势。
3、惯性原则——动则恒动、静则恒静。只有那些被投资者或主力相中的热门股会在很大一段时间内成交量和股价的波动都比较大，而无人问津的冷门股，则会在一段时间内，成交量和股价波幅都比较小。
二、 OBV值的计算方法
OBV指标的计算比较简单，主要是计算累积成交量。
以日为计算周期为例，其计算公式为：
当日OBV=本日值＋前一日的OBV值
如果本日收盘价或指数高于前一日收盘价或指数，本日值则为正；如果本日的收盘价或指数低于前一日的收盘价，本日值则为负值；如果本日值与前一日的收盘价或指数持平，本日值则不于计算，然后计算累积成交量。这里的成交量是指成交股票的手数。
和其他指标的计算一样，由于选用的计算周期的不同，OBV 指标也包括日OBV指标、周OBV指标、月OBV指标年OBV指标以及分钟OBV指标等各种类型。经常被用于股市研判的是日OBV指标和周OBV指标。虽然它们的计算时的取值有所不同，但基本的计算方法一样。另外，随着股市软件分析技术的发展，投资者只需掌握OBV形成的基本原理和计算方法，无须去计算指标的数值，更为重要的是利用OBV指标去分析、研判股票行情。
关于股票指数的OBV值的计算方法如下表：
日期 当日收盘指数 比前一日涨跌 成交量（手股） 累积OBV
1 1000 +
2 1050 + +3000 +3000
3 1025 ﹣ ﹣1500 +1500
4 1000 ﹣ ﹣1000 +500
5 1030 + +2000 +2500
6 1070 + +3000 +5500
关于单个股票价格的OBV值的计算方法如下表：
日期 收盘价 比前一日的涨跌 成交量（手股） 累积OBV
1 18.80 — — —
2 19.20 + +3000 +3000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75138e1ce6cb154b2c35ab316694b681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bd81f3bfe859fc26e82dc8469dc3ed/" rel="bookmark">
			Java线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、线程的概念
1、什么是线程
线程是程序中的一个执行流。一个执行流是由CPU运行程序代码并操作程序的数据所形成的。因此，线程被认为是以CPU为主体的行为。在Java中线程的模型就是一个CPU、程序代码和数据的封装体。
2、Java中的线程模型
如图，Java线程模型包含3个方面：
1、一个虚拟的CPU
2、该CPU执行的代码。
3、代码所操纵的数据
二、线程的创建
1、类Thread
在eclipse中按F3或点击右键，在查看源代码，可以了解到该类的构造方法和一些操作方法。
2、线程创建方法一
通过继承（extends）java.lang包的Thread类，然后重写其中的run（）方法即可。例如
public class Test{ public static void main(String args[]){ //线程对象创建 MyThread mt = new MyThread(); mt.start; } } //创建一个线程类，继承了Thread public class MyThread extends Thread{ public void run(){ int i=0; while(true){ System.out.println( i + "+Hello;"); } } } 3、线程创建方法二
通过书本和上网了解到，线程还可以通过实现Runnable接口创建线程。
public class Test{ public static void main(String args[]){ //线程对象创建 MyThread mt = new MyThread(); mt.start; } } //创建一个线程类，实现接口Runnable public class MyThread implements Runnable{ public void run(){ int i=0; while(true){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60bd81f3bfe859fc26e82dc8469dc3ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c264cddf4bde9180be7adb3631e31209/" rel="bookmark">
			Java实现发送短信验证验证码功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天老大让我弄一个发送短信验证码的功能，使用的是信易通的短信平台接口，然后在Java中使用HttpClient模拟POST请求或者GET请求（看短信平台要求，一般的情况下都是POST请求），调用短信平台提供的接口（遵循短信平台的接口规范即可）。具体看代码：
使用HttpClient的时候需要在项目中引入：
commons-httpclient-3.1.jar
这个jar包，
项目结构： 1、创建一个Http的模拟请求工具类，然后写一个POST方法或者GET方法
/** * 文件说明 * @Description:扩展说明 * @Copyright: 2015 dreamtech.com.cn Inc. All right reserved * @Version: V6.0 */ package com.demo.util; import java.io.IOException; import java.util.Map; import org.apache.commons.httpclient.HttpClient; import org.apache.commons.httpclient.HttpException; import org.apache.commons.httpclient.SimpleHttpConnectionManager; import org.apache.commons.httpclient.methods.GetMethod; import org.apache.commons.httpclient.methods.PostMethod; /** * @Author: feizi * @Date: 2015年4月17日 上午9:26:34 * @ModifyUser: feizi * @ModifyDate: 2015年4月17日 上午9:26:34 * @Version:V6.0 */ public class HttpRequestUtil { /** * HttpClient 模拟POST请求 * 方法说明 * @Discription:扩展说明 * @param url * @param params * @return String * @Author: feizi * @Date: 2015年4月17日 下午7:15:59 * @ModifyUser：feizi * @ModifyDate: 2015年4月17日 下午7:15:59 */ public static String postRequest(String url, Map&lt;String, String&gt; params) { //构造HttpClient的实例 HttpClient httpClient = new HttpClient(); //创建POST方法的实例 PostMethod postMethod = new PostMethod(url); //设置请求头信息 postMethod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c264cddf4bde9180be7adb3631e31209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42e0d5ff13dc6f9ef5cc8587068601e8/" rel="bookmark">
			WPF 学习资源收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPF核心对象模型-类图和解析
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58e47b08c7eee3503b1fc9ec97a4e4ce/" rel="bookmark">
			yocto 编译流程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git clone 一份poky 的工程到本地。
source poky/oe-init-build-env your_build_path
看下 oe-init-build-env 这个shell 脚本都干了些什么：
[plain] view plain copy if [ -z "$ZSH_NAME" ] &amp;&amp; [ "x$0" = "x./oe-init-build-env" ]; then echo "Error: This script needs to be sourced. Please run as '. ./oe-init-build-env'" else if [ -n "$BASH_SOURCE" ]; then OEROOT="`dirname $BASH_SOURCE`" elif [ -n "$ZSH_NAME" ]; then OEROOT="`dirname $0`" else OEROOT="`pwd`" fi OEROOT=`readlink -f "$OEROOT"` export OEROOT . $OEROOT/scripts/oe-buildenv-internal &amp;&amp; \ $OEROOT/scripts/oe-setup-builddir &amp;&amp; \ [ -n "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58e47b08c7eee3503b1fc9ec97a4e4ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe089dc79474d9d5f6673f8bc0e9f56/" rel="bookmark">
			MSSQL附加数据库5120错误(拒绝访问)处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://jingyan.baidu.com/article/c1a3101e8b34c2de656debbe.html
MSSQL附加数据库时提示以下错误：
无法打开物理文件“***.mdf”。操作系统错误 5:“5(拒绝访问。)”。 (Microsoft SQL Server，错误: 5120)
该经验介绍如何处理该报错，而后成功附加数据库。
工具/原料 装有MSSQL的电脑
需要附加的数据库文件(*.mdf)及其日志文件(*.ldf)
附加数据库方法 1 打开SQL Server Management Studio，并连接上数据库。右键“数据库”弹出快捷菜单，点击“附加”菜单。
2 附加数据库界面点击“添加”按钮，浏览到需要附加的数据库文件。
3 选择需要附加的数据库文件后，在数据库详细信息列表中则会显示该数据库的数据文件以及日志文件。
4 点击 附加数据库 界面的确定后，附加数据库发生报错。
错误信息为：
无法打开物理文件“***.mdf”。操作系统错误 5:“5(拒绝访问。)”。 (Microsoft SQL Server，错误: 5120)
END 修改待附加数据库文件的访问权限 右键需要附加的数据库文件，弹出属性对话框，选择安全标签页。
找到Authenticated Users用户名。
如未找到，进行Authenticated Users用户名的添加。
添加Authenticated Users用户名。
1.点击安全标签页的编辑按钮，而后点击添加显示选择用户或组对话框。
2.点击高级按钮而后点击该界面的立即查找，在搜索结果中显示了所有的用户和组。
3.选择Authenticated Users用户后点击确定，在 选择用户或组对话框 中便显示了Authenticated Users用户名。
4.点击确定
在安全标签页的用户组里面便显示了Authenticated Users用户。为Authenticated Users用户分配 完全控制 权限。
4 而后再次附加数据库，附加数据库成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be7333b1792e0b080f2ba934fadba427/" rel="bookmark">
			导包View.OnClickListener和DialogInterface.OnClickListener冲突的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同时有import android.view.View.OnClickListener;（以下简称①包）和importandroid.content.DialogInterface.OnClickListener;(以下简称②包)存在时，实例化OnClickListener中的onClick()方法时无法区分其是①包中的OnClickListener还是②包中OnClickListener，即导入包
//--------------------下面的onClickListener是①包中的OnClickListener-------------------------
btnLrResult=(ImageButton)findViewById(R.id.imbtn_lrresult);
btnLrResult.setOnClickListener(newOnClickListener(){ public voidonClick(View v){
Intent intent = newIntent(LotteryPK.this,LotteryResult.class);
startActivity(intent);
}
});
//------------------------下面的onClickListener是②包中的OnClickListener----------------
protected voidwarningDialog(String str) {
AlertDialog.Builderbuilder = new Builder(LotteryPK.this);
builder.setPositiveButton("确认", new OnClickListener() {
public voidonClick(DialogInterface dialog, int which) {
dialog.dismiss();
showDialog();
}
});
builder.create().show();
}
即便把①包和②包都导入，它也会报错，分不清楚是哪个包下的OnClickListener()方法。
解决方法：
方法一：导入①包，同时将②包中的new OnClickListener()改成new DialogInterface.OnClickListener()即可；
方法二：导入②包，同时将①包中的new OnClickListener()改成new View.OnClickListener()即可；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0965e63d64483b412f3cb5f6d655c1f4/" rel="bookmark">
			python 如何判断一个array是否是空?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		if x is not None:
#not null
else:
#null
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15ec6d3c9943ffb3b90f30f9c6c20c5d/" rel="bookmark">
			Java开发之设计模式--抽象工厂模式(Abstract Factory)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为工厂方法模式的孪生兄弟，相信大家对工厂方法模式和抽象工厂模式傻傻分不清楚吧。
那么，就让我来拯救大家吧！
抽象工厂模式 定义：所谓抽象工厂模式就是为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。
类型：创建类模式
类图： 抽象工厂模式与工厂方法模式的区别 抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。
在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们拿生产汽车的例子来说明他们之间的区别。 在上面的类图中，两厢车和三厢车称为两个不同的等级结构；而2.0排量车和2.4排量车则称为两个不同的产品族。再具体一点，2.0排量两厢车和2.4排量两厢车属于同一个等级结构，2.0排量三厢车和2.4排量三厢车属于另一个等级结构；而2.0排量两厢车和2.0排量三厢车属于同一个产品族，2.4排量两厢车和2.4排量三厢车属于另一个产品族。
明白了等级结构和产品族的概念，就理解工厂方法模式和抽象工厂模式的区别了，如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。在本例中，如果一个工厂模式提供2.0排量两厢车和2.4排量两厢车，那么他属于工厂方法模式；如果一个工厂模式是提供2.4排量两厢车和2.4排量三厢车两个产品，那么这个工厂模式就是抽象工厂模式，因为他提供的产品是分属两个不同的等级结构。当然，如果一个工厂提供全部四种车型的产品，因为产品分属两个等级结构，他当然也属于抽象工厂模式了。
总而言之，言而总之，如果把他们的区别总结一下就是：
工厂方法模式： 一个抽象产品类，可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类只能创建一个具体产品类的实例。
抽象工厂模式： 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。
区别：
工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。 工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。
工厂方法创建 “一种” 产品，他的着重点在于”怎么创建”，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。 抽象工厂需要创建一些列产品，着重点在于”创建哪些”产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。
抽象工厂模式代码 interface IProduct1 { public void show(); } interface IProduct2 { public void show(); } class Product1 implements IProduct1 { public void show() { System.out.println("这是1型产品"); } } class Product2 implements IProduct2 { public void show() { System.out.println("这是2型产品"); } } interface IFactory { public IProduct1 createProduct1(); public IProduct2 createProduct2(); } class Factory implements IFactory{ public IProduct1 createProduct1() { return new Product1(); } public IProduct2 createProduct2() { return new Product2(); } } public class Client { public static void main(String[] args){ IFactory factory = new Factory(); factory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15ec6d3c9943ffb3b90f30f9c6c20c5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f65d1e16a7796eca9ab0d1bd55a22ad9/" rel="bookmark">
			HOGDescriptor::SetSVMDetector()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HOGDescriptor::SetSVMDetector()有些限制
1. linear kernel only
2. imgsize == winsize
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a81e03cbbdafc9a3efabbb9740ff8dc6/" rel="bookmark">
			git log格式化日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git log --pretty=format:"arg" %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用-date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 本文出自 追趣，转载时请注明出处及相应链接
以下是我个人比较喜欢使用的git命令的别名命令：
1.status -- st
git config --global alias.st status
2.commit -- ci
git config --global alias.ci commit
3.branch -- br
git config --global alias.br branch
4.checkout -- co
git config --global alias.co checkout
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a81e03cbbdafc9a3efabbb9740ff8dc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc9191a3ac0e17b086c1232fb1db84d0/" rel="bookmark">
			如何用网线实现两台电脑之间的文件共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何用网线实现两台电脑的文件共享 一、同一个局域网下文件共享 在局域网中，如果两台电脑都插网线了，就可以在局域网下实现文件的共享，具体方法如下：
1、用要共享文件的电脑打开cmd，输入ipcofig查看对方电脑的ip地址，我这里另外一台电脑ip为192.168.1.102
2、找到要共享的文件夹，右键该文件，点击分享-&gt;选择分享给所有人即可，如下图所示
3、打开运行（win+R），输入两个反斜杠和ip地址，如下所示
4、点击确定后会提示输入对方用户名和密码的信息（注意，对方电脑必须设置开机密码，否则会一直提示输入正确的密码），输入用户名和密码，如下图
5、点击确定，就会进入共享的页面，若没有看见刷新一下就会看见共享的文件，如下图所示
在共享的文件夹里面可以随意复制文件，如果网线质量好的话，理论上应该接近硬盘的速度，我这里15M/S左右，速度还是相当给力的！
二、两台PC直接通过双绞线共享文件 在没有网的情况下，直接拿一根网线插到两个电脑上即可实现文件共享
当两台电脑连接一根双绞线后，系统会自动生成临时的ip地址，同样在cmd里面输入ipconfig进行查询，如下图，我的电脑生成的ip为169.254.186.101
在共享文件的电脑上输入命令查询ip（另一台电脑ip为169.254.35.159），基本步骤同上，输入用户名和密码就可以实现两台电脑的文件共享了，结果如下所示：
注意事项：
1、共享文件的电脑必须要设置开机密码，否则共享失败！
2、若远程访问出现权限问题，需要检查是否 启用文件和打印机共享，控制面板-》所有控制面板项-》网络和共享中心-》高级共享设置，根据说明启用相关选项即可。
至此，我们用一根网线就可以实现两台电脑之间文件的共享了，无需网络和U盘也可以快速拷贝文件了！
三、取消共享的文件夹 取消共享的文件夹请参考笔者如下博文：
Windows小技巧4——如何取消共享的文件夹：https://blog.csdn.net/u011127242/article/details/53414927
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ce47941b5ac02596f2c472e00b1db6a/" rel="bookmark">
			用LabVIEW编写上位机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用LabVIEW编写上位机 1、下载、安装LabVIEW
现在网上搜，能搜出来一大推LabVIEW下载和安装以及破解教程，因此这里不做详细介绍。请自行百度~~。另外，提醒一下，下载LabVIEW时尽量下载那种带注册机，因为如果不对LabVIEW进行破解，很多的基本功能都用不了的。 这里给一个我的云盘的链接，里面含有注册机哦： http://pan.baidu.com/s/1mgqqr1m
2、下载安装VISA VISA(Virtual Instrument Software Architecture，简称为”Visa”)，即虚拟仪器软件结构，是VXI plug&amp;play联盟制定的I/O接口软件标准及其规范的总称。VISA提供用于仪器编程的标准I/O函数库，称为VISA库。VISA函数库驻留在计算机系统内，是计算机与仪器的标准软件通信接口，计算机通过它来控制仪器。
VISA对于用LabVIEW做上位机来说，安装VISA必不可少。 VISA的安装比较简单，下载后直接安装即可，安装完之后甚至不需要把它打开。 这里给个官网下载地址（建议选择standard download，不要选择NI downloader）： http://www.ni.com/download/ni-visa-5.4/4230/en/ 编写上位机： 先给出一个上位机的前面板： 再给出前面板对应的后面板： 下面依次介绍各个控件的作用： 前面板中一共有6个部分。分别是： 串口名称：即对应的串口号。当你插上USB后，LabVIEW会自动的识别可用的串口号，这样你只要点击那个向下的小箭头就会发现。
读取缓冲区：即读取串口发送来的数据。这里可以自行的设定你每次要读取的字节个数。
三个方向值：即将读取的字符型数据转换成无符号整型后的结果。当然，这写数据处理的部分要看个人的要求而定。我只是在使用的过程中用了这样的数据方式。
停止显示：即停止图形的显示。
断开蓝牙：即断开与串口的连接。
波形图表：实时的显示数据
下面再介绍下后面板的控件： 对于这些控件的使用和功能，LabVIEW的帮助文档中给出了很详细的解释，这里我就不一一解释了，不然整本书都写不完。对于每一个控件的使用帮助，可以将鼠标放在控件上，然后右击，会看到帮助，点开就行了。
VISA配置：这个控件包含了对串口属性的配置。可以配置的项目有：串口名称、波特率、数据位、奇偶校验位等。
VISA读取：即充缓冲区读取数据。在VISA中，为了保持同步，串口发送来的数据会先存放在缓冲区，然后从缓冲区读取你要的数据。这里一般只需要设定每次读取的字节数就行。 字符串至字节数组转换：从VISA缓冲区读取的数据都是以字符串的形式读取的，而我们想要获取其中的数据则必须先将其转换为字符数组，以供搜寻。
数组索引：因为我这里每次是接收4个数据，而我要单个提取每一个数据的话，就需要用到数组索引的功能。
转换为单字节整形：这里是将原来的无符号char型的数据转换为有符号的，这里是我数据处理需要。对于不同的数据处理，可能会用不同的控件来实现。
停止：这里我用波形图表实时的显示数据，但是有时候我希望图形界面停留在某个界面，以方便进行仔细的观察，因此会加这个停止键，用于实现暂停图像。
VISA清空IO缓冲区：这是清空缓冲区的数据，因为我在每次读完后，都会将原来的数据清空，以防止数据的混叠。
上面实现的是一个简单的上位机程序，能够实现的功能也较为简单。我这篇博客的目的在于和大家一起分享怎么制作上位机，至于上位机的复杂程度，要看程序的编写了。 另外，上位机一般用于数据的传输和处理，因此一定要理清逻辑，注意数据的流向。还要学会巧用循环语句、条件结构等结构型的控件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e6386576ef4df00baa33d195856785/" rel="bookmark">
			MODIS数据介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://blog.sina.com.cn/s/blog_53e9bb570101jv55.html
一、Modis数据资源总体介绍
1999年2月18日，美国成功地发射了地球观测系统（EOS）的第一颗先进的极地轨道环境遥感卫星Terra。它的主要目标是实现从单系列极轨空间平台上对太阳辐射、大气、海洋和陆地进行综合观测，获取有关海洋、陆地、冰雪圈和太阳动力系统等信息，进行土地利用和土地覆盖研究、气候季节和年际变化研究、自然灾害监测和分析研究、长期气候变率的变化以及大气臭氧变化研究等，进而实现对大气和地球环境变化的长期观测和研究的总体（战略）目标。2002年5月4日成功发射Aqua星后，每天可以接收两颗星的资料。 搭载在Terra和Aqua两颗卫星上的中分辨率成像光谱仪（MODIS）是美国地球观测系统（EOS）计划中用于观测全球生物和物理过程的重要仪器。它具有36个中等分辨率水平 （0.25um~1um）的光谱波段，每1-2天对地球表面观测一次。获取陆地和海洋温度、初级生产率、陆地表面覆盖、云、汽溶胶、水汽和火情等目标的图像。 本网站提供的MODIS陆地标准产品来自NASA的陆地过程分布式数据档案中心（The Land Processes Distributed Active Archive Center,LP DAAC/NASA）。包括：基于Terra星和Aqua星数据的地表反射率（250m,daily;500m,daily;250m,8days;500m,8day）、地表温度（1000m,daily;1000m,8days;5600m,daily）、地表覆盖（500m,96days;1000m,yearly）、植被指数NDVI&amp;EVI（250m,16daily;500m,16days;1000m,16days;1000m,monthly;、温度异常/火产品（1000m,daily;1000m,8days）、叶面积指数LAI/光合有效辐射分量FPAR（1000m,8days）、总初级生产力GPP（1000m,8days）。 本网站提供的所有MODIS陆地标准产品的格式为HDF-EOS，数据组织方式为10°经度*10°纬度的分片（TILE）方式。
二、MODIS数据特点及技术指标
1.概况
MODIS全称Moderate-Resolution Imaging Spectroradiometer，即中分辨率成像光谱仪。1998年MODIS机载模型器安装到EOS-AM（上午轨道）和PM（下午轨道）系列卫星上，从1999年12月正式向地面发送数据。MODIS是NASA地球行星使命计划中总数为15颗。
2. MODIS数据的特点
MODIS数据主要有四个特点: （1）全球免费：NASA对MODIS数据实行全球免费接收的政策（TERRA卫星除MODIS外的其他传感器获取的数据均采取公开有偿接收和有偿使用的政策），这样的数据接收和使用政策对于目前我国大多数科学家来说是不可多得的、廉价并且实用的数据资源； （2）光谱范围广：MODIS数据涉及波段范围广（共有36个波段，光谱范围从0.4um-14.4um），数据分辨率比NOAA-AVHRR有较大的进展（辐射分辨率达12bits，其中两个通道的空间分辨率达250m，5个通道为500m，另29个通道为1000m）。这些数据均对地球科学的综合研究和对陆地、大气和海洋进行分门别类的研究有较高的实用价值； （3）数据接收简单：MODIS接收相对简单，它利用X波段向地面发送，并在数据发送上增加了大量的纠错能力，以保证用户用较小的天线（仅3m）就可以得到优质信号； （4）更新频率高：TERRA和AQUA卫星都是太阳同步极轨卫星，TERRA在地方时上午过境，AQUA在地方时下午过境。TERRA与AQUA上的MODIS数据在时间更新频率上相配合，加上晚间过境数据，对于接收MODIS数据来说可以得到每天最少2次白天和2次黑夜更新数据。这样的数据更新频率，对实时地球观测和应急处理（例如森林和草原火灾监测和救灾）有较大的实用价值。
3.MODIS数据的技术指标
项目
指标
轨道
705km，降轨上午10: 30过境，升轨下午1: 30过境，太阳同步，近极地圆轨道
扫描频率
每分钟20.3转，与轨道垂直
测绘宽带
2330km x 10km
望远镜
直径17.78cm
体积
1.0m X 1.6m X 1.0m
重量
250g
功耗
225w
数据率
11Mbit/s
量化
12bit
星下点空间分辨率
250m,500m,1000m
设计寿命
5年
4.MODIS数据的波段分布特征
波段
波谱范围(nm)
信噪比
主要用途
分辨率(m)
1
620-670
128
陆地/云边界
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61e6386576ef4df00baa33d195856785/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50799b4629a3cb46c5a034e587c89a01/" rel="bookmark">
			【Android基础篇】SQLite数据库的增删改查基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 SQLite是Android系统的核心数据存储服务之一，它是一个轻型的嵌入式数据库，占用非常少的资源却能提供很好很快的数据存取服务，许多大型的需要数据存储的Android项目都有用到SQLite（也可以用于桌面应用程序）。
下面介绍一下SQLite的创建数据库、表的操作，以及基本的增删改查操作。
二、基本操作API简介 在Android中，SQLiteDatabase类提供了SQLite的底层API，但在使用SQLite数据库时，我们往往不会直接操作SQLiteDatabase这个类，而是自己创建一个继承自SQLitOpenHelper的子类来实现数据库操作。这样做的目的一是为了以后如果数据库升级不至于要改动太多代码，已实现封装；二则是为了我们使用更方便。
1、创建数据库和表 SQLiteOpenHelper是一个抽象类，在这个类里有两个抽象方法，OnCreate和OnUpgrade，前者用于第一次创建数据库，后者用于数据库升级，创建类DBServices如下：
public class DBServices extends SQLiteOpenHelper{ final static int version = 1; final static String dbName = "plan"; public DBServices(Context context){ super(context,dbName,null,version); } @Override public void onCreate(SQLiteDatabase db) { // TODO Auto-generated method stub //创建今日计划表 String create_today_plan_sql = "CREATE TABLE [_today_plan] (" + "[_Date] varchar(10) not null," + "[Item] varchar(200)," + "[Check] varchar(5) )"; db.execSQL(create_today_plan_sql); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { // TODO Auto-generated method stub } } 示例里定义两个变量，一个是数据库的版本号，一个是数据库名。当Android应用运行时，SQLiteOpenHelper会先检查是否已经存在数据库，如果不存在，就创建数据库，然后打开数据库，最后调用OnCreate方法，所以我们需要再OnCreate中创建表（视图等）；如果数据库已存在，而版本号比上次创建的数据库版本号高，就调用OnUpgrade，用于升级。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50799b4629a3cb46c5a034e587c89a01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5ca74ec2f63b406028d1807858a5252/" rel="bookmark">
			孙楠失算的决赛秀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我对知乎问题如何看待《我是歌手》总决赛孙楠第一轮结束退出？的回答，顺便也贴在这。 我是歌手 孙楠第一轮后放弃比赛成了我是歌手总决赛的头条，讨论热度超过韩红夺冠和其他歌手的总和。说实话我是歌手节目最精彩之处就在于让一众实力一流的歌手同台竞技，比赛的性质让歌手们八仙过海竭尽全力，因而呈现出的音乐的精彩程度就远超过同一首歌之类的轮流表演。文无第一，武无第二。给这些歌手排名以至评出歌王称号，只是比赛机制的副产品。真正的产品是你我都欣赏到的高水平的音乐。除了每位歌手的狂热粉丝和需要话题性的媒体，我相信很多观众和我一样，都在欣赏过程，并不看重歌王之战的噱头，而只是将它作为本季我是歌手节目的落幕。 总决赛 作为一名只是我是歌手节目粉丝而非任何一名歌手粉丝的观众（当然对各位歌手的好感程度还是有差异的），孙楠宣布放弃比赛的戏剧化一幕这几天一直让我意犹未尽，在看了各位朋友提供的资料和颇有启发性的观点，以及事后媒体的报道和对当事人的采访，现在就谈一些我的思考和感受。 和重大足球比赛的决赛一样，我是歌手总决赛在精彩程度上也比不上歌王的话题性。帮帮唱这个环节不用说，两位歌手磨合以精彩地演绎一首曲目实际上比七位歌手单人表演更费心思和时间，但是友情参与的嘉宾不可能像歌手本人那样在乎这个节目。另一方面现场听众评审无论多么注重音乐性，这个环节的兴奋点也会被大牌和重量级的嘉宾带走。所以歌手选嘉宾的重心往往放在嘉宾的人本身，而非合作的音乐上，韩红就是最明显的例子（当然也有李健这样本身对歌王就不觊觎的）。说了这么多，我的意思是以我的欣赏水准，在第一轮乏善可陈的帮帮唱之后，孙楠突如其来的放弃比赛却像给贫乏甚至结局已经可以猜到的节目投下让人意外的石子，我的大脑一下子兴奋起来了。这样说对汪涵、导演和现场的工作人员可能太冷酷。接下来我就说说为什么我觉得这是孙楠引发的意外而非双方唱双簧，还有对孙楠的看法。 湖南电视台是否事先知情 上面匿名用户的朋友从技术的角度分析湖南电视台事先不可能不知情，还有许多朋友是从阴谋论的角度。首先我不太认同凡事都做功利性的阴谋论的看法，何况湖南电视台一真没必要在本已大热的节目中玩这一套，二是有玩火自焚带来负面评价的危险。至于技术的角度，我事后又看了一遍那关键的一段。孙楠的房间声音不是一开始就切换到主画面的，而是在他明显地举手示意之后。韩红以为是挥手致意闹着玩也举起手来。我相信那个时刻汪涵和节目组都不知道孙楠要说什么，都以为他只是简单想说点感言甚至套话。孙楠举手示意已十分明显，且在众目睽睽之下，把声音切换到他的频道让他发言是很自然的。直播节目中出现一些即兴的成分也是正常的。至于说担心孙楠冒出什么大逆不道的言论，这在中国是极端小概率事件，而且从发言人的身份和一贯表现也可以知道不可能。 其实孙楠不想玩了在节目中也是有端倪的。帮帮唱之前的抽签环节，主动提议让出有优势的第六位，要和第一位的选手换。还有之前唱谭咏麟的说不出再见那一期，选歌和言谈间也透露了去意。这一点也可以从洪涛导演事后接受采访得到证实，他说鼓励孙楠勇敢唱下去。但是就此并不能证明节目组事先知道孙楠会在总决赛过程中退赛。洪涛无疑相信他已说服了孙楠，而且他也参加了彩排，表演了两首歌，总决赛都到了直播现场，节目已进行了一半，谁会料想到他此刻选择放弃。汪涵的应急表现十分精彩，但他话中对孙楠的不满也从一个方面证明这是突发事件。 事件的影响 事件的影响我觉得没有节目延时、观众闹场——直播事故——广电总局叫停节目和惩罚湖南电视台这么蝴蝶效应。上面的匿名用户朋友分析认为湖南电视台将孙楠的宣布安排在对节目影响最小的时间段，我认为是湖南电视台不知情的状况下孙楠选择了唯一合适的机会。根本无需计算比较在不同时间宣布给节目带来影响的大小，因为这是显而易见的。孙楠想唱完第一首歌，但不想表演第二首，那就只有这个时机适合宣布。除了引发的惊诧和潜在的风险，节目流程确实如孙楠所说未受影响。至此对孙楠狂风巨浪般的批评我都不甚以为然。孙楠是一个独立的自己负责任的成年人，如果他有一定要如此做的原因，或者仅仅是很想这样做自负后果，就是无可 厚非的。认为孙楠辜负了观众的，所谓观众是歌手的衣食父母只是客套话，歌手仍然有选择的自由。认为孙楠没有合约精神，给湖南电视台带来很大负面影响的，如果合同有相关条款的规定，孙楠自然要承担后果，但这事他考虑一切后的决定，没必要小题大做。直到后来随着时间的进行和我了解得更多，我的看法有了大逆转。 为何要中途放弃 我当时第一推测是孙楠有急事要离开，因为是直播节目不得不放弃。后来看见他没走，此说自然不成立。 孙楠自己所说的他已得到足够，要将机会让给其他选手初看是很难说得通的。每位歌手来参加节目，无论是否有野心问鼎歌王，在舞台上尽可能多地表现自己、证明自己和演绎喜爱的歌曲，这类动机肯定超过因为舍不得或想成全他人的感情。 有推测说孙楠看见彩排中第一轮韩红垫底，怕总决赛韩红过不了关而退出。直播和彩排毕竟有很大区别，况且总决赛是韩红抽得上上签，因为朋友小得可怜的风险牺牲自己很难成立。 有猜测说孙楠知道我是歌手内定排名的黑幕，出于义愤（自己有利）或抗议（自己不利）而退出。孙楠和他的团队在参加节目前和开播这么长时间中肯定与制作组有充分的交流和沟通，到最后一刻才发现有黑幕可能性不大。而且根据知乎上其他问题对现场参与评审的回答，我也不倾向于有黑幕。这一点从事后孙楠被普遍批评质疑而接受采访时的发言也可以佐证。 这样看起来这个问题有点无解了，若目田修远 在上面的回答就显示出意义了。孙楠参加我是歌手是为了公关改善形象，这样一来放弃比赛给其他选手增加机会至少从孙的主观目的上就说得通了。我本来对此说还半信半疑，因为对孙楠实在不了解，对他之前所谓公众形象跌落也不知情。事后我看到的一些材料却让我对此说越来越坚信不疑。看看事后孙楠接受采访说的话，很难用傲慢或愚蠢之外的词来形容。有个网友很多年前去大连，被拉去一家孙楠开的主题为不见不散的餐厅，四壁挂满了孙楠的巨幅照片还有中国歌手男一号的标语。不管是根源是孙楠本人还是他的团队，公众形象会低我不怀疑了。同样，以谦让他人为目的中途退赛，从动机上符合孙楠参赛以来一贯的表现，从愚蠢程度上也符合孙楠以往和事后的表现。 回头想想孙楠和韩红两个功成名就的大腕参加我是歌手本身就有些匪夷所思。新生代、小众、边缘、昨日黄花型歌手参加都可以理解，大腕参加就真是没被淘汰甚至得了冠军不算什么成绩，排名低甚至被淘汰就尴尬了。因此在这样的生态系统里，只有一位大牌歌手，本人的心理还可以是不出意外能夺冠。二虎相争就太奇怪了。所以合理的解释就是孙楠此行醉翁之意不在酒。我之前还一直佩服孙楠在节目中的轻松从容、没有功利心和幽默，纳闷为什么评审的排名一直不高，更加佩服如李锐所说的孙楠在这种情况下的坚持和敬业。现在看来，他也时常被失望折磨，最后毕其功于一役的高潮表现的结果再次让他失望了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca0f90ffc63b5a929d9fbf816e9e3c85/" rel="bookmark">
			JTS Geometry之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几何信息和拓扑关系是地理信息系统中描述地理要素的空间位置和空间关系的不可缺少的基本信息。其中几何信息主要涉及几何目标的坐标位置、方向、角度、距离和面积等信息，它通常用解析几何的方法来分析。而空间关系信息主要涉及几何关系的“相连”、“相邻”、“包含”等信息，它通常用拓扑关系或拓扑结构的方法来分析。拓扑关系是明确定的
相等(Equals)：
几何形状拓扑上相等。
脱节(Disjoint)：
几何形状没有共有的点。
相交(Intersects)：
几何形状至少有一个共有点（区别于脱节）
接触(Touches)：
几何形状有至少一个公共的边界点，但是没有内部点。
交叉(Crosses)：
几何形状共享一些但不是所有的内部点。
内含(Within)：
几何形状A的线都在几何形状B内部。
包含(Contains)：
几何形状B的线都在几何形状A内部（区别于内含）
重叠(Overlaps)：
几何形状共享一部分但不是所有的公共点，而且相交处有他们自己相同的区域。
下面的例子介绍了 equals、disjoint、intersects 的用法
[java] view plain copy package com.mapbar.geo.jts; import org.geotools.geometry.jts.JTSFactoryFinder; import com.vividsolutions.jts.geom.Coordinate; import com.vividsolutions.jts.geom.Geometry; import com.vividsolutions.jts.geom.GeometryFactory; import com.vividsolutions.jts.geom.LineString; import com.vividsolutions.jts.geom.Point; import com.vividsolutions.jts.io.ParseException; import com.vividsolutions.jts.io.WKTReader; /** * Class GeometryRelated.java * Description 二元比较集合。二元比较以两个几何对象作为参数，返回一个Boolean类型的值， * 来指明这两个几何对象是否具有指定的空间关系。支持的空间关系包括： * equals、disjoint、intersects, touches, crosses, within, contains, overlaps * Company mapbar * author Chenll E-mail: Chenll@mapbar.com * Version 1.0 * Date 2012-2-17 下午06:17:01 */ public class GeometryRelated { private GeometryFactory geometryFactory = JTSFactoryFinder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca0f90ffc63b5a929d9fbf816e9e3c85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b84690f291ab4ce1e8f8cfc996fbdfbf/" rel="bookmark">
			swift 实现websocket与后台通信(swift 如何构建简单的json字符串)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		swift 语言在国内流传度不是很广，初学者者想找相关资料很困难，想去国外找资料又被墙了，本人才疏学浅，记录下一些学习过程中的经验，希望看完对你也有所帮助！
一个应用不可避免要与服务器进行通信，主要有，http 与 socket。(相关概念请自行google)
http暂时不论，我们先看看socket下面衍生的websocket，今天我就把自己怎么利用websocket与服务器进行交互记录下来：
首先你需要集成websocket到自己的项目，如果不明白如何集成，请看上一篇《swift集成websocket库》
集成websocket 到自己项目后还需要添加SwiftyJSON到自己项目，具体步骤和集成websocket一样。
添加好类库后我们就可以开始写代码了！
首先打开你项目，记得通过cocoapods生成的.xcworkspace文件打开项目。你会看到图上所示的项目结构，在Pods里面有我们添加进来的2个库，如果没有请参考上一篇博客重新添加。（项目千万不要有中文，否则添加库后会有乱码）
上一步没有问题后，楼主考虑到保证websocket的唯一性，采用了单例的模式，申明我的websocket
import UIKit import Starscream class SingletonSocket { let socket:WebSocket = WebSocket(url: NSURL(string: "后台服务器的地址")!) class var sharedInstance : SingletonSocket{ struct Static{ static let instance:SingletonSocket = SingletonSocket() } if !Static.instance.socket.isConnected{ Static.instance.socket.connect() } return Static.instance } } 在你使用的类里面一般是viewcotroller里面，要记得先实现 WebSocketDelegate 这个接口
接口必须实现的函数，不实现会报错
在viewDidLoad里面设置websocket的回调为在这个类实现的delegate，这样就能接收到服务器给我们返回的数据
接下来构建我们的请求参数，构建好后再用socket对象的writeString()发送给服务器
然后我们在回调函数里面打印一下服务器返回的数据
当然实际开发中我们不会仅仅打印数据，你可以根据你的业务逻辑在这里添加你自己的处理
最终实现后println打印出来的数据
这样一个基本的使用websocket发送json数据给后台到接受返回的流程就OK了！
转载请保留出处：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa8272ede083e157b20253c9b4620e99/" rel="bookmark">
			票房与大片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看到新闻，中国2014年度电影总票房增长36%，达296亿人民币，跃居全球第二，占比13%，仅次于美国（27%）。惊讶中国电影票房蹿升速度超过GDP之馀，也奇怪如此繁荣的市场下，似乎没看到多少好电影。 记忆中上世纪九十年代，我还在上小学和初中，那时电影票一两块钱一张，每年（或是学期）学校都会组织学生看一次电影。那时的看电影没有什么教育的目的，《妈妈再爱我一次》、《鹰爪铁布衫》、《天涯明月刀》、《乘龙快婿》、《神偷谍影》（有些电影名字记不清了），在那个年级的学生眼里都是很好看的片子，看电影就像出去玩一样让人兴奋。 后来上大学，在电教放映室和录像厅里看电影（在电脑上看碟就不算了，前两者毕竟还是在一个黑乎乎的大房间里和一群人看大屏幕），票价也都保持在两块钱左右的水平，而且是连看几场。 到了新世纪新城市工作以后，骇然得知电影票五十块钱一张，顿时觉得此时看电影与小时候看电影已不是一回事了。那时候电影院不多，每年能成为热点的也就是几部美国大片，中国电影界成日哀叹票房规模小、国产电影和好莱坞大片差距大。 时光飞逝岁月荏苒，电影票价六十、八十、一百、一百二十……，跟着GDP一路高涨。在电影公司和院线不遗馀力的宣传鼓动下，看电影成了年轻人时髦的活动，节假日和大片来临之际，影院大厅购票柜台前人龙蜿蜒。中国导演们拍了一堆又大又烂的电影后，也渐渐学会了怎样制作好莱坞类型的商业大片。但我却怀念商业浪潮袭来之前另一类型的大片：《阳光灿烂的日子》、《霸王别姬》、《鬼子来了》……从故事和电影的冲击力本身来说，这些也是不折不扣的大片，但它们不止于大，还伟大。对比一下《无极》、《赵氏孤儿》和《霸王别姬》，《让子弹飞》、《一步之遥》和《阳光灿烂的日子》、《鬼子来了》，就会惊叹陈凯歌和姜文这样的天才前后反差之大。 窦文涛在《锵锵三人行》节目里说很多导演成名后就拍不出好片子，有的第一部作品就是最好的作品，说他们被成功带来的一切冲昏了头脑，迷失了自我，甚至江郎才尽。我不这么认为。从《让子弹飞》和《一步之遥》仍然可以看出强烈的姜文的个人风格，《一步之遥》里有一幕姜文跪在地上被摘去面具，那张倔强的脸和喷火的眼神，多少年都没变。 问题是商业的力量，让曾经有勇气即使被禁也要拍出好电影的他们也屈服了。不管想在电影里表达什么，赚钱是必须保证的条件。庞大市场的需求让黑洞一样吸引导演的拍摄方向。特别是当这些是由同样投资不菲的出资方在背后推动时，拍一部可能赔钱的片子就根本不在考虑范围之内。 看最近几部国产大片时，片头电影出品公司让人眼花缭乱，除了名称、标志新之外，它们还提醒观众公司背景的丰富性：电子商务、视频网站、电影频道、商业地产……各路诸侯都想在勃兴的电影市场分一杯羹，就像昔日的房地产一样，看得我心痒难耐，恨不得也投资三五千块钱。出品人、总策划人、总制片人、总监制、责任制片、责任监制，中国人在头衔上的想象力总是令人倾佩的。每个头衔下并列的多位可以让观众在心目中玩将他们与前面一系列公司对号入座的游戏，加起来比演员数量还多。幸好，导演只有一位。然后是领衔主演、联合主演、主演、特别演出，在中国颁奥斯卡奖需要多准备几个小金人，最佳男领衔主演、最佳女领衔主演、最佳男联合主演…… 什么时候，才能再看到那些伟大的大片。当然，不是在公映的电影院里。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b935044156d2937d12c92084750af08e/" rel="bookmark">
			单片机、微处理器的WiFi  http协议  网页响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ipad、手机通过网页操纵、监测单片机微处理器运行
实现：
1、平台：wifi无线转串口透传模块（解析到tcp层），串口调试助手，USB转串模块，win7系统
2、测试步骤
（1）在ipad、手机浏览器中输入WiFi模块的透传网址加端口（192.168.16.254:8080）
（2）在串口助手中收到http协议的请求内容，然后，用串口助手发送index文件，之后在浏览器中就可以看到页面
index源码：
HTTP/1.1 200 OK Server: Leisur's Server Connection: Close Content-Length: 10161 Content-Type: text/html;charset=utf-8 &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" initial-scale=2.0&gt; &lt;title&gt;##Studio&lt;/title&gt; &lt;style&gt; header , footer, button { letter-spacing: normal; text-align: center; word-spacing: normal; display: block; alignment-adjust:middle; } header { width: 100%; font-family: Georgia, "Times New Roman", Times, serif; font-size: 22px; font-weight: bold; float:left; background-color: #ADB96E; } button { width: 40%; font-family: Georgia, "Times New Roman", Times, serif; font-size: 25px; font-weight: bold; background-color: #F9F9F9; height:50; } footer{ width: 100%; font-family: Georgia, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b935044156d2937d12c92084750af08e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85ebc44bbde1fe2fcb605895103c1d46/" rel="bookmark">
			springmvc实现REST中的GET、POST、PUT和DELETE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring mvc 支持REST风格的请求方法，GET、POST、PUT和DELETE四种请求方法分别代表了数据库CRUD中的select、insert、update、delete，下面演示一个简单的REST实现过程。
参照http://blog.csdn.net/u011403655/article/details/44571287创建一个spring mvc工程
创建一个包，命名为me.elin.rest，添加一个RESTMethod类，代码如下
package me.elin.rect; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; @Controller @RequestMapping("/rest") public class RESTMethod { private static final String SUCCESS = "success"; // 该方法接受POST传值，请求url为/rest/restPost @RequestMapping(value = "restPost", method = RequestMethod.POST) public String restPost(@RequestParam(value = "id") Integer id) { System.out.println("POST ID:" + id); return SUCCESS; } // 该方法接受GET传值，请求url为/rest/restGet @RequestMapping(value = "/restGet", method = RequestMethod.GET) public String restGet(@RequestParam(value = "id") Integer id) { System.out.println("GET ID:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85ebc44bbde1fe2fcb605895103c1d46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c903e508796d73aa14e4644bd330ee08/" rel="bookmark">
			云计算学习笔记（三）：云计算架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章转载只能用于非商业性质，且不能带有虚拟货币、积分、注册等附加条件。转载须注明出处http://blog.csdn.net/flowingflying以及作者@恺风Wei
基础云架构 云架构包括审计监控器、云使用监控器、虚拟机监控器、逻辑网络便捷、按是用那个付费监控器、远程管理系统、资源集群、资源复制。
负载分布架构（workload distribution architecture）依赖于负载均衡器。
资源池架构（resource pooling architecture）以使用一个或者多个资源池为基础，其中相同的IT资源有一个系统进行分组和维护，以自动个确保他们保持同步。例如物理服务器池、虚拟服务器池、存储池、网络池、CPU池、内存池，这是将每种类型的IT资源创建专有池，烨可以将他们集合为更大的池，池里面有子资源池，子资源池可以和大资源池有着相同类型的IT资源，也可以选取某部分IT资源。定义资源池后，可以在每个池中创建实例。
动态可扩展架构（Dynamic Scalability Architecture），触发某些条件或导致资源次动态分配IT资源，或回收不必要的资源。
动态水平扩展：达到阈值时进行资源复制，创建更多的实例。
动态垂直扩展：向上或向下扩展资源实例，例如增加CPU。
动态重定位：将IT资源重新放置在更大容量大主机上。
弹性资源容器架构（Elastic Resource Capacity Architecture）与虚拟服务器的动态供给相关，分配或回收CPU、RAM等资源。和上面的动态垂直扩展差不多，不过前面的是基于某虚拟服务器上，而这个是基于资源池，本质上没什么不同。
服务负载均衡架构是针对云服务的工作负载分布架构。实际就是利用负载分布式架构实现动态水平扩展。
云爆发架构（cloud bursting architecture）当达到阈值是，从企业内部的IT资源扩展（“爆发”）到云中，其基础是自动扩展监听器和资源复制机制（维护内部和韵IT资源之间的状态信息同步）。所谓扩展到云中，也是利用负载均衡的方式，将部分服务请求转移到云。
弹性磁盘供给架构（Elastic Disk Provisioning Architecture）按云用户实际所需进行存储分配和计费。
冗余存储架构通过复制，辅云存储设备与主运存储设备保持数据同步，当主设备故障时，存储设备网关（连接到云存储设备的外部接口）将请求转向辅设备。冗余可以是异地的。
高级云架构 虚拟机监控器集群架构：如果hypervisor失效，则其管理虚机会受到波及。通过心跳消息来进行监控。虚拟机监控器集团架构建立一个跨多个物理服务器的高可用虚拟机监控器集群。虚拟机控制器集群由中心VIM控制，VIM向hypervision发送心跳消息来确认是否正常，如果没有应答，将启动VM在线迁移。使用共享云存储设备实现虚机的在线迁移。
负载均衡的虚拟服务器实例架构：物理服务器之间的负载均衡比较困难，通过容量看门狗（capacity watchdog system），在把处理任务分配到可用的物理服务器主机之前，会动态计算虚拟服务器实例及其相关的工作负载，包括容量看门狗云使用监控器、VM在线迁移程序，以及容量计划器（动态计算和比较物理服务器的能力和虚机的容量要求，进行如何负载均衡的决策）。
不中断服务重定位架构（non-disruptive service relocation architecture）触发云服务实现的运行时复制或迁移，避免中断。通过增加一个复制，暂时转移到另一个承载环境上，而不是利用冗余来实现伸缩。常见的方式是在线迁移。
零宕机架构（zero downtime architecture）是一个非常复杂的故障系统，在虚机所在的物理服务器主机失效时（都失效了，不知道怎么转移，果然非常复杂，所有虚机都存储在共享的介质），允许它们动态地迁移到其他物理服务器主机上。
云负载均衡架构，IT资源可以在多个云之间进行负载均衡。建立在自动伸缩监听器和故障转移系统结合的基础上。
资源预留架构，为给定的云用户预留资源（单个IT资源，一个IT资源的一部分，多个IT资源）。用于处理资源池下属的兄弟资源池之间的资源借用，保证基本资源以及有效资源归还。
动态故障检测与恢复架构（dynamic failure detection and recovery architecture）。通过一个弹性的看门狗系统，通过智能看门狗监控器（一个特殊的云使用监控器），监控预先定义的故障场景、选定事件、进行响应，对于不能解决的，发出通知（报告），进行升级处理。
裸机（bare-metal）供给架构（provision architecture）。大多数的物理服务器在ROM提供了远程安装管理的支持，有些已经集成到芯片中。IaaS平台的IP地址（默认或者DHCP）告知云用户，云用户可以通过远程安装管理来自主完成操作系统的安装。为了减少人为差错，在裸机管理系统提供了发现代理、部署代理（通过远程安装管理将部署代理安装到物理机器的RAM中）、发现区、管理加载器、部署组件，就可以自动部署。
快速供给架构，将大范围的IT资源供给进行自动化。其依赖一个自动供给程序、快速供给引擎，以及按需供给的脚本和模板。
存储负载管理架构（Storage workload management architecture）使得LUN可以均匀分布在看用的云存储设备上，而存储容量系统用来确保运行时工作负载均匀分布在LUN上。通过监控器，查看是否出现超出阈值的情况，如果是，监控器通知存贮容量系统进行LUN迁移。
特殊云架构 直接I/O访问架构。虚拟机通过虚拟机监控器老方位物理服务器上的物理I/O，称为I/O虚拟化，而直接I/O访问则允许虚拟服务器绕开hypervision直接访问物理服务器的I/O卡（例如SAN上的LUN），不需要hypervision进行仿真连接。这需要在虚机上安装相应的驱动来支持。
直接LUN访问架构。LUN通常通过主机总线适配器（HBA）映射到hypervision中，但有时虚机需要直接访问基于块的RAW存储设备，例如一个集群中，多台机器共享一个LUN。直接LUN访问架构通过物理HBA卡向虚机提供LUN访问（就是hypervision将LUN直接映射到虚机上），多个虚机可以将LUN作为集群数据库的共享卷来使用。
动态数据规范化架构。用于解决过度冗余的问题，建立一个重复删除系统，通过侦测和消除云存储设备上的冗余数据来方式云用户无意思地保留冗余的数据副本。通常基于块，也可以基于文件。当收到一个数据块时进行比对，如果发现冗余，冗余块由已有的相同块指针来替代。
弹性网络容量架构。动态分配额外的网络带宽，避免出现瓶颈。
跨存储设备垂直分层架构。通过LUN迁移将LUN从某台云存储设备至具有更高I/O性能，如更高数据处理能力，更高带宽的云存储设备上，实现容量不同的存储设备之间的垂直扩展。
存储设备内部垂直数据分层架构。在同一台物理存储设备中，将存储根据性能不同进行分类，监控使用情况，如果超过或者低于某个阈值，则将LUN向上或向下迁移。
负载均衡的虚拟交换机架构。书中提供的示意图有些令人不解，如果我们将之理解为利用linux机器作为路由器连接接收用户信息的网络设备和虚拟交换机之间的设备，可以考虑到网卡的处理能力成为瓶颈，另一方面，一台物理机器可创建多台虚机，相当于有一个虚拟交换机连接多台虚机，其上行就是该物理机的物理网卡。此外，上下行链路可能是不对称的，提供多条上行链路来进行平衡和冗余。但是字面意义上，大致能够理解。
多路径资源访问架构。避免链路失效而无法访问，提供可替代的物理或者虚拟超链接。多路径系统驻留在服务器或者hypervision中。
持续虚拟网络配置架构。当虚机从某个主机迁移到另一个主机时，需要保障其网络配置一致，可通过将网络设置信息保持在某机器上（如集中式交换机）被各主机共享。
虚拟服务器的冗余物理连接架构。一台物理机器可创建多台虚机，相当于有一个虚拟交换机连接多台虚机，其上行就是该物理机的物理网卡，一旦该物理链路或者物理网卡失效，则所有虚机都失效。因此通过多个物理网卡，提供多条上行链路来实现冗余架构，确保网络连接正常。
存储维护窗口架构。由于维护和管理等需要，云存储设备有时需要暂时性得关闭。利用实时存储迁移的技术，将数据暂时迁移到辅助的云存储设备上，并自动且透明地将云服务用户重定向到辅云设备上，用户不会感知主存储停机下线。等主云设备重现上线时在迁移回来。
相关连接：我的无限网络文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffd7f8b59633b8bff7202eddf720927c/" rel="bookmark">
			各项异性滤波简介Anisotropic Filtering(AF)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要整理简绍来自互联网的各项异性滤波的知识。
原文链接：http://www.linuxgraphics.cn/graphics/using_anisotropic_texture_filtering_in_opengl.html
基本的纹理过滤 纹理是数据的简单矩阵排列——例如，颜色数据、亮度数据或者颜色和alpha（透明度）数据。纹理数组中的每一个独立的数值通常称为一个纹理单元。纹理映射是一种将纹理图像应用于物体表面的技术（就是把图像贴到构成物体表面的多边形上去），就像该图像是一种贴画纸或玻璃纸附着于物体的表面上。
那么什么是纹理过滤呢？当三维空间里面的多边形经过坐标变换、投影、光栅化等过程，变成二维屏幕上的一组象素的时候，对每个象素需要到相应纹理图像中进行采样，这个过程就称为纹理过滤。
纹理过滤通常分为2种情况：
纹理被缩小。比如说一个8 x 8的纹理贴到一个平行于xy平面的正方形上，最后该正方形在屏幕上只占4 x 4的象素矩阵，这种情况下一个象素对应着多个纹理单元。纹理被放大。 这种情况刚好跟上面相反，假如我们放大该正方形，最后正方形在屏幕上占了一个16 x 16的象素矩阵，这样就变成一个纹理单元对应着多个象素。 通常的纹理过滤的方法有2种：线性过滤和三线性过滤。也可以设置不进行任何过滤操作。（OpenGL允许为上面两种情况分别设置不同的过滤方法）
不进行任何过滤操作的速度最快也最简单，只是针对每一个象素对最接近它的纹理单元进行采样，可用于上面两种情况。但是这种纹理过滤方法的效果最差，在屏幕显示的图像会显得十分模糊。线性过滤也比较简单，每个象素要对最接近它的2 x 2的纹理单元矩阵进行采样，取4个纹理单元的平均值，也可用于上面的两种情况。这种纹理过滤方法的效果比上面的要好很多。三线性过滤相对的比较复杂，它只能用于纹理被缩小的情况，需要先构造纹理图像的mipmap，mip的意思是“在狭窄的地方里的许多东西”，mipmap就是对最初的纹理图像构造的一系列分辨率减少并且预先过滤的纹理图。对于一个8 x 8的纹理来说需要为它构造4 x 4、2 x 2、1 x 1这三个mipmap。如果正方形被缩小到在屏幕上占6 x 6的象素矩阵，一个象素的采样过程就变成这样，首先是到8 x 8的纹理图中进行对最接近它2 x 2的纹理单元矩阵进行采样（也就是上面的线性过滤）；其次是到4 x 4的纹理图中重复上面的过程；接着把上面两次采样的结果进行加权平均，得到最后的采样数据。可以看出整个过程一共进行了三次的线性过滤，所以这种方法叫做三线性过滤，它的效果是三种纹理过滤方法里面最好的。 各异向性纹理过滤 各异向性纹理过滤不是单独使用而是和前面所述的其他过滤方法结合一起使用的。
假设Px为纹理在x坐标方向上的缩放的比例因子；Py为纹理在y坐标方向上的缩放的比例因子；Pmax为Px和Py中的最大值；Pmin为Px和Py中的最小值。当Pmax/Pmin等于1时，也就是说Px等于Py，纹理的缩放是各同向的；但是如果Pmax/Pmin不等于1而是大于1，Px不等于Py，也就是说纹理在x坐标方向和在y坐标方向缩放的比例不一样，纹理的缩放是各异向的，Pmax/Pmin代表了各异向的程度。
举个例子来说，64 x 64的纹理贴到一个开始平行于xy平面的正方形上，但是正方形绕y轴旋转60度，最后投影到屏幕上占了16 x 32的象素矩阵。纹理在x坐标方向上缩放的比例因子为64/16等于4，在y坐标方向缩放的比例因子为64/32等于2，Pmax等于4，Pmin等于2。缩放的各异向程度为2。当把各异向性过滤和线性过滤结合起来的时候，应该是对最接近象素的4 x 2的纹理单元矩阵采样才合理，因为一个象素在x坐标方向上对应了更多的纹理单元（Px &gt; Py）。即使是纹理在一个轴方向上缩小而在另一个轴方向上放大，处理的过程也是一样的（注意的是如果纹理在一个轴方向上缩小而在另一个轴方向上放大，OpenGL仍然把它当作是纹理被缩小的情况，将采用为纹理缩小情况设置的过滤方法为基本过滤方法，然后再加上各异向性过滤）。假设被贴图的正方形最后在屏幕上占了一个128 x 32 的象素矩阵，纹理在x坐标方向上缩放的比例因子为64/128等于0.5，在y坐标方向缩放的比例因子为64/32等于2，由于Py &gt; Px 且 Pmax/Pmin等于4，所以当把各异向性过滤和线性过滤结合起来的时候，应该对最接近象素的2 x 8的纹理单元矩阵进行采样。三线性过滤和各异向性过滤结合的过滤方法的步骤跟前面单独的三线性过滤方法大致是一样的，只是前面两步采用了各异向性过滤和线性过滤结合的方法。
通常情况下采取线性过滤或者三线性过滤就可以得不错的效果，但是在某些特殊的情况下，特别是把一个都是线状条纹的纹理图贴到一个绕x或者是y轴旋转角度很大的多边形上的时候，比如将人的头发纹理贴到构成人的头顶的多边形，即使是三线性过滤的效果也不能令人满意，只有将各异向过滤方法和三线性过滤或者线性过滤的方法结合起来才能得到完美的效果。
怎样在OpenGL中使用各异向性纹理过滤 在OpenGL里面使用各异向性纹理过滤首先要系统运行的OpenGL实现支持EXT_texture_filter_anisotropic 这个OpenGL扩展。
OpenGL里面的各异向性纹理过滤的参数设置是独立于纹理缩小和放大这两种情况的，也就是说不需要为这两种情况进行分别设置。参数设置十分简单，只有一个参数就是最大各异向程度（TEXTURE_MAX_ANISOTROPY_EXT）。因为纹理缩放的各异向程度越大，就需要对更多的纹理单元进行采样，这样在处理速度上是不可接受的，所以必须设置一个最大各异向程度，当OpenGL进行各异向性过滤的时候，采用的各异向程度参数为纹理缩放的各异向程度和最大各异向程度之间的最小值，也就是说当纹理缩放的各异向程度大于设置的最大各异向程度时，将使用设置的最大各异向程度作为过滤使用的参数。显然可见，当该参数设置为1的时候就是不进行各异向性过滤，1也是OpenGL为这个参数设定的缺省设置。另外还可以通过查询MAX_TEXTURE_MAX_ANISOTROPY_EXT获得该OpenGL实现支持的最大各异向程度。
下面是使用各异向性纹理过滤的示例代码：
glGenTextures(1, &amp;texture_id)); glBindTexture(GL_TEXTURE_2D, texture_id); //Create a 2D texture with Mipmap gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGB, m_width, m_height, GL_RGB, GL_UNSIGNED_BYTE, image_data); //获得运行的 Opengl 实现支持的最大各异向程度.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffd7f8b59633b8bff7202eddf720927c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cdb433ca2136eb006ffdb1f0ba4a3b5/" rel="bookmark">
			人脸识别过程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人脸识别（Facial Recognition），就是通过视频采集设备获取用户的面部图像，再利用核心的算法对其脸部的五官位置、脸型和角度进行计算分析，进而和自身数据库里已有的范本进行比对，后判断出用户的真实身份。人脸识别技术基于局部特征区域的单训练样本人脸识别方法。 第一步，需要对局部区域进行定义； 第二步，人脸局部区域特征的提取，依据经过样本训练后得到的变换矩阵将人脸图像向量映射为人脸特征向量； 第三步，局部特征选择（可选）； 后一步是进行分类。分类器多采用组合分类器的形式，每个局部特征 对应一个分类器，后可用投票或线性加权等方式得到终识别结果。 人脸识别综合运用了数字图像/视频处理、模式识别、计算机视觉等多种技术，核心技 术是人脸识别算法。目前人脸识别的算法有 4 种：基于人脸特征点的识别算法、基于整幅 人脸图像的识别算法、基于模板的识别算法、利用神经网络进行识别的算法。 作为人脸识别的第一步，人脸检测所进行的工作是将人脸从图像背景中检测出来，由于受图像背景、亮度变化以及人的头部姿势等因素影响使人脸检测成为一项复杂研究内容。检测定位：检测是判别一幅图像中是否存在人脸，定位则是给出人脸在图像中的位置。定位后得到的脸部图像信息是测量空间的模式，要进行识别工作，首先要将测量空间中的数据映射到特征空间中。采用主分量分析方法，原理是将一高维向量，通过一个特殊的特征向量矩阵，投影到一个低维的向量空间中，表征为一个低维向量，并且仅仅损失一些次要信息。通过对经过检测和定位过的人脸图像进行特征提取操作可以达到降低图像维数，从而可以减小识别计算量，提高识别精度的作用。人脸识别系统采用基于特征脸的主 成分分析法（PCA），根据一组人脸训练样本构造主元子空间，检测时，将测试图像投影到 主元空间上，得到一组投影系数，再和各已知的人脸图像模式比较，从而得到检测结果。 四种方法的详解： 1、基于几何特征识别 弹性图匹配(EGM)方法可采用属性拓扑图来表达人脸，其拓扑图的任一顶点均 包含一特征矢量，它记录了人脸在该顶点位置的分布信息，最初的拓扑图是矩形 的，并没有注重节点的位置。后来，Wiskott[32】提出～种基于关键点的图匹配算法， 称为弹性束图(elastic bunchgraph)，其节点一般定位在如眼球、眼角等灰度变化 剧烈，信息丰富的地方。特征点先是手工定位，经过一段学习以后，即可达到自 动定位。如此几十个节点，其分离能力是不同的，并且前向、半侧、侧面人脸分 离能力较好的节点分布范围也不一样，g_,-ugert33】深入研究了这一问题，他给每个 节点不同的权重，与该节点的分离能力成正比。统计表明，眼在前向和半侧的人 脸中是最重要的分离特征，而鼻尖是侧面人脸最重要的分离特征。Wurtz【34】研究了 多分辨的情况，他假定在两幅人脸图中只有一部分节点有较好的对应，一些节点 根本没有对应节点，它们将干扰识别。因此在匹配的过程中只保留对应良好的节 点，并且将背景(包括头发区域)去掉。由于弹性匹配对每个存储的人脸需计算其模 型图，计算量大，存储量大，Lee【35】等提出了一种基于弹性图动态链接模型的方法， 既取得较高的识别速度，也获得了较理想的识别率，在一定程度上克服了以往方 法总是在速度与识别率之间进行折中的缺点。 2、基于代数特征识别 主分量分析(Principal．Component Analysis，PCA)是一种常用的方法。它根据图 像的统计特性进行的正交变换(K．L变换)，以消除原有向量各个分量间的相关性。 变换得到对应特征值依次递减的特征向量，即特征脸1361。Turk和Pentland[37】进一步 提出了“特征脸”方法，该方法以训练样本集的总体散布矩阵为产生矩阵得到的 一组特征矢量，称作“特征脸”，这样就可产生了一个由“特征脸”矢量组成的 子空间，每一幅人脸图像其投影都可以获得一组坐标系数，这组坐标系数表明了 人脸在子空间的位置，实验表明该方法具有较强的稳定性，可以作为人脸识别的 依据。 特征脸方法使用由各个特征脸扩展的空间来表示人脸，虽然可以有效地表示 人脸信息，但是并不能有效地鉴别和区分人脸。Swets和Wen9138】提出PCA的基础上 使用LDA(Lillear Discriminant Analysis，线性鉴别矢量)，也称Fisher脸方法【39】。它选 择以类内散布正交的矢量作为特征脸空间，从而能压制图像之间与识别信息无关 的差异，对光照及人脸表情变化都不太敏感。 Moghaddamt40】等提出了贝叶斯人脸识别方法。他们提出了一种基于概率的图 像相似度度量方法，将人脸图像之间的差异分为两类类间差异(即不同人的人脸图 像之间的差异)和类内差异(即同一个人的不同人脸图像之间的差异)。他们提出了 类间差异和类内差异度量的概率模型和计算方法。由于贝叶斯相似度的计算涉及 复杂的非线性的快速计算方法。这种人脸识别方法在1996年美国DAPAR组织的 FERET人脸测试中是效果最好的方法之一。 Yang[4l】等人考虑高阶统计量，从而提出了核特征脸(Kernel Eigenface)应用 Kernel PCA将人脸对应的向量映射到高维空间中，然后应用PCA。这种做法避免了 高维统计量计算中的组合爆炸问题，同时，还考虑了高维相关性。由于PCA为基 础的传统特征脸方法没有利用人脸的几何拓扑特征，为此Albertt421等将PCA与人脸 3、隐马尔科夫模型(HMM) 隐马尔科夫模霎j．t431(Hidden Markov Model，HMM)是用于描述信号统计特性的 一组统计模型。HMM使用马尔科夫链来模拟信号统计特性的变化，而这种变化又 是间接地通过观察序列来描述的，因此，隐马尔科夫过程是一个双重的随机过程。 用采集的脸像构造观察向量，观察向量和人脸的五官特征之间的关系可以用一个 一维的隐Markov模型(Hidden Markov Model，HMM)来表示，该模型的参数能较好 地表征具体的人脸模型，在人脸识别领域已取得到了初步成效州。这种方法至少 有两个问题，一个是直接采用灰度值作为观察值矢量会受到噪声、光线等很多随 机因素的影响，另外一个是计算量很大，学习和识别速度都比较慢。伪二维 HMM(P2．DHMM)模型是一维HMM模型的一种推广。P2．DHMM由一组主状态组 成，每一个主状态又包括了一个一维HMM。相当于将一组一维HMM模型嵌入另 外一组HMM模型中，因为这种结构并不是真正的二维HMM模型，因此取名为 伪二维HMM模型。可以看出这种结构利用了图像的二维特征，更适合于图像识 别，因此采用了这种HMM结构用于人脸识别。 4、支持向量机法(SVM) 支持向量机(Support Vector Machines，SVM)是Vapnik等提出的基于结构风险 最小化原理(Structural Ri．sk Minimization Principle，SRM)统计学习理论ml， 用于分 类与回归问题。SRM使vc(vapnik Cherovnenkis)维数的上限最小化，而经验风险 最小化(Empirical Risk Minimization Principle，ERM)使相对于训练数据的误差最小 化，这使得SVM方法比基于ERM的ANN方法具有更好的泛化能力。SVM最初 是针对分类问题提出来的，目前也被推广到回归问题中。直接使用SVM方法解决 人脸识别问题面临两个困难：(1)训练SVM需要求解二次规划问题，计算复杂度高、 内存需求量巨大；(2)在非人脸样本不受限制时，需要极大规模的训练集合，得到 的支持矢量会很多(约占训练样本总数的20％)，使得分类器的计算量过高。 为了解决以上问题Osunal46】等人提出了分解算法，目的都是为了把求解原始的 大规模QP问题，转化成与之等价的一系列较小规模二次规划子问(quadratic programming，QP)。Platt进一步提出了SMO[471(Sequential minimal ptimization)算法， SMO算法把每一步QP子问题的规模降到最小，选择两个违例样本进行优化。 Keerthi等人对SMO算法的违例样本选取进行改进使得SMO算法的速度有了很大 的提高。 Guo dongGuot48】等人采用两个人脸数据库，一个是含有400幅图象，另一个含 有1079幅图象，并将SVM方法与其它算法进行了比较，证明SVM方法的错识率 最低。比较遗憾的是，虽然SVM方法在理论上具有很突出的优势，但与其理论研 第二章人脸检测识别方法 17 究相比，应用研究还相对比较滞后，目前只有较有限的实验研究报道，且多属仿 真和对比实验，SVM的应用应该是一个大有作为的方向。 转载于:https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cdb433ca2136eb006ffdb1f0ba4a3b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9de72873b3087466a61c5e5717bc4f54/" rel="bookmark">
			Mockito常用方法及示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mockit是一个开源mock框架，官网：http://mockito.org/，源码：https://github.com/mockito/mockito
要使用Mockit，首先需要在我们工程中引入对应的jar包，对于maven工程而言，需要添加如下依赖项即可：
&lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-core&lt;/artifactId&gt; &lt;version&gt;2.0.5-beta&lt;/version&gt; &lt;/dependency&gt;而在我们实际使用时，为了组织测试case的需要，我们可能还需要testng： &lt;dependency&gt; &lt;groupId&gt;org.testng&lt;/groupId&gt; &lt;artifactId&gt;testng&lt;/artifactId&gt; &lt;version&gt;6.8.8&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 在进行下面的mock test示例之前，我们先建两个简单的被测类Demo、ParameterClass。 Demo.java:
package com.anlegor.test; public class Demo { private String name ="laowang"; private int age; public Demo(String name, int age) { this.name = name; this.age = age; } public String speak(String str) { return str; } public String talk(String str) { return str; } public String methodNoParameters() { return name; } public String methodCustomParameters(ParameterClass parameter,String str) { return str; } public String methodHaveChildObj(ParameterClass parameter,String str) { parameter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9de72873b3087466a61c5e5717bc4f54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91863b81192f8a076ba69e476cbb73dc/" rel="bookmark">
			[python3.x] 利用chardet检测网页编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：Win7_x64 + python3.4.3
需要先下载chardet并进行安装，下载地址：https://pypi.python.org/packages/source/c/chardet/chardet-2.3.0.tar.gz
安装：进入解压后的目录，在命令窗口执行: python setup.py install
写个测试的python脚本吧(DetectURLCoding.py)：
#coding:utf-8'''python 3.x'''import sysimport urllib.requestimport chardet# 将data写入文件fnamedef writeFile(fname, data):f = open(fname, "wb")if f:f.write(data)f.close()def blog_detect(blogurl):'''检测编码方式'''try:fp = urllib.request.urlopen(blogurl)except Exception as e:print(e)print('download exception-[%s]' %blogurl)return 0blog = fp.read()	# python3.x read the html as html code bytearrayfp.close()#writeFile("t.html", blog)# get encoding stringcodedetect = chardet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91863b81192f8a076ba69e476cbb73dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45f9a7ac0c5bae5d351b28b29a6447ab/" rel="bookmark">
			使用Java创建rest 服务  通过HTTP请求访问资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 使用jersey创建rest webservice 1 在eclipse中创建动态web工程 2 build jersey jar包 3 创建rest 服务端 package com.kcharf.gis.restws; import javax.ws.rs.GET; import javax.ws.rs.Path; import javax.ws.rs.PathParam; import javax.ws.rs.Produces; import javax.ws.rs.core.MediaType; //这里@Path定义了类的层次路径 //指定了资源类提供该服务的URI路径 @Path("UserInfoService") public class UserInfo { //@Get表示方法会处理HTTP get请求 @GET @Path("/name/{i}")//指定资源类提供服务的uri路径 @Produces(MediaType.TEXT_XML)//资源类方法会产生媒体类型 //PathParam向Path定义的表达式注入uri参数值 public String userName(@PathParam("i") String i){ String name = i; return "&lt;User&gt;" + "&lt;Name&gt;" + name + "&lt;/Nmae&gt;" + "&lt;/User&gt;"; } } 4 创建客户端测试 package com.kcharf.gis.restclient; import javax.ws.rs.core.MediaType; import com.sun.jersey.api.client.Client; import com.sun.jersey.api.client.ClientResponse; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45f9a7ac0c5bae5d351b28b29a6447ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/613bf539dbc02ac7ece31db4cc726a23/" rel="bookmark">
			怎样在控制台或者日志打印输出JDBC执行的sql语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天用jdbc preparestatement 写sql语句查询，但是在执行的过程中实际查询出的结果和预期的结果不一致，然后就在想有什么办法能够在控制台或者Log4j日志输出最终执行的SQL语句，以便于调试。如果是hibernate可以通过配置show_sql 为 true 在控制台显示执行的SQL，因为使用的是纯JDBC的写法，然后自己在程序中直接通过System.out.println(sql);打印SQL语句，然后又打印参数，这种方式确实是可以。但是，遇到insert语句或者Update语句的时候，因为实际操作中需要传入的匹配参数有点多，然后通过System.out.println()这种方式写的就有点多了，十几个参数就需要写十几行，然后就在想，能不能通过什么方式进行简化一下。。。
/** * 显示SQL语句 * @param sql * @param paramMap */ public static void show_sql(Logger log,String sql,List&lt;String&gt; paramList){ log.info("##sql:{}",sql); log.info("##参数:{}",JSONArray.fromObject(paramList)); /*if(null != paramList &amp;&amp; paramList.size() &gt; 0){ for (int i = 0; i &lt; paramList.size(); i++) { log.info(""+i+" : "+paramList.get(i)); } }*/ } 最原始的方法，直接一个一个取：
//输出SQL语句 paramList.add(officeUserInfo.getUsername()); paramList.add(officeUserInfo.getPassword()); paramList.add(officeUserInfo.getCust_name()); paramList.add(officeUserInfo.getMobile()); paramList.add(String.valueOf(officeUserInfo.getState())); paramList.add(officeUserInfo.getOffice_id()); paramList.add(String.valueOf(officeUserInfo.getRole())); paramList.add(officeUserInfo.getTel()); paramList.add(officeUserInfo.getLeadPerson()); paramList.add(officeUserInfo.getMobile2()); paramList.add(officeUserInfo.getTel2()); paramList.add(officeUserInfo.getContact()); paramList.add(officeUserInfo.getQq()); paramList.add(officeUserInfo.getFex()); paramList.add(officeUserInfo.getAddr()); paramList.add(officeUserInfo.getAddr2()); paramList.add(officeUserInfo.getCust_tax_code()); paramList.add(officeUserInfo.getIdcard_no()); paramList.add(officeUserInfo.getSws()); paramList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/613bf539dbc02ac7ece31db4cc726a23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cbaf8c3b32825977f3009deb8a8702e/" rel="bookmark">
			apache 使用 mod_fcgid.so模块时 配置指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FcgidBusyScanInterval指令
说明:扫描繁忙超时进程的间隔
语法: FcgidBusyScanInterval seconds
默认：FcgidBusyScanInterval 120
环境: 服务器配置
状态：外部
对应的老指令：BusyScanInterval
该模块将执行FcgidBusyTimeout检查，在此区间。
FcgidBusyTimeout 指令
说明: 杀死处理请求超过FcgidBusyTimeout设置的时间后的FastCGI应用程式
语法: FcgidBusyTimeout seconds
默认：FcgidBusyTimeout 300
环境: 服务器配置，虚拟主机
状态：外部
对应的老指令：BusyTimeout
这是处理请求的最大时间限制。如果FastCGI请求超过了FcgidBusyTimeou设置的秒数，请求将会终止。而检查进行的时间将由FcgidBusyScanInterval定义，请求处理在设置的时间内有效。本指令的目的是终止挂起的应用程序。默认的超时时间，可能需要增加应用程序，可以采取更长的时间来处理请求。
&lt;ifmodulemod_fcgid.c&gt;
FcgidBusyScanInterval120 #与FcgidBusyTimeout对应,每120秒进行一次检查
FcgidBusyTimeout 300 #超过300秒的fastcgi请求将被终止
&lt;/ifmodule&gt;
FcgidConnectTimeout指令
说明: Fastcgi的服务在等待设置的时间参数后超时（Fastcgi连接超时）
语法: FcgidConnectTimeout seconds
默认：FcgidConnectTimeout 3
环境: 服务器配置，虚拟主机
状态：外部
对应的老指令：IPCConnectTimeout
这是Fastcgi这个模块在windows中当它试图连接一个应用的时候设置的一个最大的周期时间，当等待时间超过了这个时间，将会出现超时。(此指令不适应在UNIX)
FcgidErrorScanInterval指令
说明: 在间隔的时间内进行扫描退出挂起的进程
语法: FcgidErrorScanInterval seconds
默认：FcgidErrorScanInterval3
环境: 服务器配置
状态：外部
对应的老指令：ErrorScanInterval
这是间隔模块将处理挂起的进程终止。 终止其中已超过FcgidIdleTimeout或FcgidProcessLifeTime任何进程正在等待。
FcgidIdleScanInterval指令
说明: 空闲超时过程的扫描间隔
语法: FcgidIdleScanInterval seconds
默认：FcgidFixPathinfo120
环境: 服务器配置
状态：外部
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cbaf8c3b32825977f3009deb8a8702e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1610e05517f0b98045345c8e325c83e3/" rel="bookmark">
			oracle向PostgreSQL迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. postgreSQL 没有dual 例子： oracle : select sysdate from dual; postgreSQL: select current_timestamp; 为保证程序兼容性，可创建伪视图（view ）替代： CREATE OR REPLACE VIEW dual AS SELECT NULL::"unknown" WHERE 1 = 1; ALTER TABLE dual OWNER TO postgres; GRANT ALL ON TABLE dual TO postgres; GRANT SELECT ON TABLE dual TO public; 必须授权public 以select 权限 2. sequence 创建和oracle一样，不需要修改创建语句。 例子：create sequence seq_test_1 INCREMENT by 1 MINVALUE 1 NO MAXVALUE start with 1 ; --NO MAXVALUE在oracle不支持 使用有区别： 1）查看序列 next 值 select nextval('seq_test_1'); 2）查看序列最近使用值 select currval('seq_test_1'); 3）序列重置 方式一 select setval('seq_test_1',100); select currval('seq_test_1'); currval --------- 100 (1 row) select nextval('seq_test_1'); nextval --------- 101 (1 row) 方式二 alter sequence seq_test_1 restart with 200; --注意这个不会修改 currval 的值 select nextval('seq_test_1'); nextval --------- 200 (1 row) 另：postgreSQL支持使用以下语句查看序列属性 select * from seq_test_1; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1610e05517f0b98045345c8e325c83e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ceb0a84bef2b4e4c750f7f37690cf7f/" rel="bookmark">
			CreateObject(Excel.Application)出错解决方法【转】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自http://wiki.dagene.net/Delphi相关/CreateObject(Excel.Application)出错解决方法 说明：没有正确设置权限。设置方法:在命令行键入“DCOMCNFG”，则进入COM组件配置界面，选择MicrosoftExcel后点击属性按钮，将三个单选项一律选择自定义，编辑中将Everyone加入所有权限。保存完毕后重新启动服务器
========================================================================
http://support.microsoft.com/kb/828550
检查自动化服务器 发生 CreateObject 或 New 相关错误的最常见原因是服务器应用程序有问题。通常，应用程序的配置或安装会引起该问题。要解决问题，请使用以下过程：
验证您要自动执行的 Office 应用程序安装在本地计算机上。确保可以运行该应用程序。要这样做，依次单击“开始”和“运行”，然后尝试运行该应用程序。如果无法手动运行该应用程序，则该应用程序将不能以自动化方式工作。 重新注册该应用程序，如下所示： 单击“开始”，然后单击“运行”。 在“运行”对话框中键入服务器路径，然后将 /RegServer 添加到行尾。 单击“确定”。
应用程序以静默方式运行。应用程序作为 COM 服务器重新注册。 如果是因为缺少某个注册表项而发生问题，则以上步骤通常能纠正问题。 在 CLSID 下检查要自动执行的应用程序的 LocalServer32 项。确保 LocalServer32 项指向该应用程序的正确位置。确保路径名称为短路径 (DOS 8.3) 格式。您不必通过使用短路径名称来注册服务器。但是，在一些系统上，包含嵌入空格的长路径名称可能导致问题。
要检查为服务器存储的路径项，请如下所示启动 Windows 注册表编辑器： 单击“开始”，然后单击“运行”。 键入 regedit，然后单击“确定”。 移到 HKEY_CLASSES_ROOT\CLSID 项。
系统上注册的自动化服务器的 CLSID 位于此项下。 使用 CLSID 项的下列值查找代表要自动执行的 Office 应用程序的项。检查 CLSID 项的 LocalServer32 项中的路径。 Office 服务器 CLSID 项 Access.Application {73A4C9C1-D68D-11D0-98BF-00A0C90DC8D9} Excel.Application {00024500-0000-0000-C000-000000000046} FrontPage.Application {04DF1015-7007-11D1-83BC-006097ABE675} Outlook.Application {0006F03A-0000-0000-C000-000000000046} owerPoint.Application {91493441-5A91-11CF-8700-00AA0060263B} Word.Application {000209FF-0000-0000-C000-000000000046} 确保路径匹配文件的实际位置。 注意：短路径名称可能看起来正确，而实际上并不正确。例如，Office 和 Microsoft Internet Explorer（如果它们安装在其默认位置）的短路径均类似于 C:\PROGRA~1\MICROS~X\（其中 X 是数字）。此名称初看起来不像是短路径名称。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ceb0a84bef2b4e4c750f7f37690cf7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bd7a11e85546bd9a517c23382117139/" rel="bookmark">
			windows下获得DC句柄的几个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.SDK WIN32 API函数在view类中获得DC句柄 HDC hdc hdc=::GetDC(m_hWnd); ::ReleaseDC(m_hWnd,hdc)	//一定要释放句柄 2.利用MFC获得DC句柄 CDC *pDC=GetDC(); ReleaseDC(pDC)	//一定要释放句柄 3.利用CClientDC获得DC句柄(不需要调用释放函数，析构函数自动调用) CClientDC dc(this)	//作用范围在view窗口内 CClientDC dc(GetParent())//作用范围在Fraim框架内 CClientDC 不需要调用释放函数，解析函数自动调用 4.利用CWindowDC获得DC句柄(不需要调用释放函数，析构函数自动调用) CWindowDC dc(this)//作用范围在view窗口内 CWindowDC dc(GetParent())//作用范围在Fraim框架内 CWindowDC dc(GetDesktopWindow())//作用范围在整个桌面 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c53889350ca5547b7f4bb28902bfab1f/" rel="bookmark">
			在一个千万级的数据库查寻中，如何提高查询效率？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：http://blog.csdn.net/xlgen157387/article/details/44156679
在一个千万级的数据库查寻中，如何提高查询效率？
1）数据库设计方面： a. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 b. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0
c. 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时,查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。
d. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。
e. 应尽可能的避免更新索引数据列，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新索引数据列，那么需要考虑是否应将该索引建为索引。
f. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。
g. 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。
h. 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。
i. 避免频繁创建和删除临时表，以减少系统表资源的消耗。
j. 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。
k. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c53889350ca5547b7f4bb28902bfab1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c14a2a41a00542c67c35d5aedfb2ca/" rel="bookmark">
			电脑进入BOOT MENU 按键总结！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主板品牌 启动按键 华硕主板 F8
技嘉主板 F12 微星主板 F11
映泰主板 F9 梅捷主板 ESC或F12
七彩虹主板 ESC或F11 华擎主板 F11
斯巴达卡主板 ESC 昂达主板 F11
双敏主板 ESC 翔升主板 F10
精英主板 ESC或F11 冠盟主板 F11或F12
富士康主板 ESC或F12 顶星主板 F11或F12
铭瑄主板 ESC 盈通主板 F8
捷波主板 ESC Intel主板 F12
杰微主板 ESC或F8 致铭主板 F12
磐英主板 ESC 磐正主板 ESC
冠铭主板 F9
【品牌笔记本电脑】
笔记本品牌 启动按键
联想笔记本 F12 宏基笔记本 F12
华硕笔记本 ESC 惠普笔记本 F9
联想Thinkpad F12 戴尔笔记本 F12
神舟笔记本 F12 东芝笔记本 F12
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6c14a2a41a00542c67c35d5aedfb2ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/423e4ee33a08e62cee06fcba1bda0cb5/" rel="bookmark">
			在CentOS安装pptpd以及部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用CentOS系统的时候，对有些人也许会遇到在CentOS安装pptpd的问题。下面就来介绍一下，如何在CentOS安装pptpd。在CentOS安装pptpd最省事的安装就是下载rpm包pptpd-1.3.4-1.rhel5.1.i386.rpm,然后直接执行 rpm –ivh pptpd-1.3.4-.rhel5.1.i386.rpm 。幸运的是这个包没有其他依赖，因此CentOS安装pptpd应该是异常的顺利。如果使用源码安装，会出现ppp版本高的情况，需删除pppd2.3.4 再安装pppp2.4.3，反而麻烦了。安装完rpm包后，自动生成几个配置文件，主配置文件/etc/pptpd.conf，选项文件/etc/ppp/options.pptpd, 帐号文件/etc/ppp/chapsecrets.后面配置pptpd主要就是对这几个文件进行修改。
一、CentOS安装pptpd （vpn）拓扑结构
vpn的访问逻辑上存在3个网络： 1、欲访问的目标网络。通常在vpn服务器所在的内部网络（vpn服务器有2个网卡，一个是公网的，一个是私有网络的） 2、Vpn的公网网络。 3、Vpn连接后与客户端形成的虚拟网络。建议单独设置一个网络，这样就不会占用vpn后面的私有网络（目标网络）的ip资源/地址。 图1 当然vpn隧道网络可以跟目标网络是同一个网段，不过不推荐这样。
二、CentOS安装pptpd vpn服务器端的配置
（一）修改主配置文件/etc/pptpd.conf.只需要加入下面两行：
localip 172.16.195.1 remoteip 172.16.195.101-200 Localip这行是给vpn服务器设置一个隧道ip Remoteip是自动分配给客户端的ip地址范围。 （二）修改选项文件/etc/ppp/options.pptpd.需要设定分配给客户端的dns，因此仅需把ms-dns前的注释去掉，改成可用的dns如下：ms-dns 61.135.154.5 ms-dns 159.226.240.66
为了方便查看调试信息，把debug行前面的注释取消即可。Dump前的注释也取消。
（三）CentOS安装pptpd 添加帐号。通过编辑文件/etc/ppp/chap-secrets逐行加入；一个账号占一行。一行分4列，其表示如下： 用户名 服务器名 密码 ip 没有字符数限制 Pptpd—都用这个，如果用其它的名称，需要修改options.pptpd文件的name行的内容 用双引号的话，密码就不能包含双引号了 * 表示有pptpd随机分配ip
三、CentOS安装运行pptpd.执行命令service pptpd start或者执行/etc/init.d/pptpd 即可启动它。
通过检查进程、查看系统日志来确定pptpd是否正常。
四、客户端配置（windows）。
这个应该很容易了，就不再多费口舌。
五、拨号登录。
拨号过程中，登录到vpn服务器查看日志，会看到用户的连接情况，下面是截取的一个片断，供参考： Dec 19 17:16:01 max-vpn pppd[9833]: Plugin /usr/lib/pptpd/pptpd-logwtmp.so loaded. Dec 19 17:16:01 max-vpn pppd[9833]: pptpd-logwtmp: $Version$ Dec 19 17:16:01 max-vpn pppd[9833]: pppd options in effect: Dec 19 17:16:01 max-vpn pppd[9833]: debug # (from /etc/ppp/options.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/423e4ee33a08e62cee06fcba1bda0cb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b69dbd01c0f112d3cb09e83f0461997a/" rel="bookmark">
			visual C&#43;&#43; 项目和解决方案的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目：
项目是构成某个程序的全部组件的容器，该程序可能是控制台程序、基于窗口的程序或某种别的程序。程序通常由一个或多个包含用户代码的源文件，可能还要加上包含其它辅助数据的文件组成。某个项目的所有文件都存储在相应的项目文件夹中，关于项目的详细信息存储在一个扩展名为.vcproj的xml文件中，该文件同样存储在相应的项目文件夹中。项目文件夹还包括其它文件夹，它们用来存储编译及链接项目时所产生的输出。
解决方案：
顾名思义，解决方案的含义是一种将所有程序和其它资源（它们是某个具体的数据处理问题的解决方案）聚集到一起的机制。例如，用于企业经营的分布式订单录入系统可能由若干个不同的程序组成，而各个程序是作为同一个解决方案内的项目开发的，因此，解决方案就是存储与一个或多个项目有关的所有信息的文件夹，这样就有一个或多个项目文件夹是解决方案文件夹的子文件夹。与解决方案中项目有关的信息存储在扩展名为.sln和.suo的两个文件中。当创建某个项目时，如果没有选择在现有的解决方案中添加该项目，那么系统将自动创建一个新的解决方案。
当创建项目及解决方案时，可以在同一个解决方案中添加更多的项目。我们可以在现有的解决方案中添加任意种类的项目，但通常只添加与该解决方案内现有项目相关的项目。一般来说，各个项目都应该有自己的解决方案，除非我们有很好的理由不这样做。
VS2010创建项目时，默认的项目文件夹的名称与项目名称相同，该文件夹还将容纳构成该项目定义的文件。如果不修改的话，解决方案文件夹具有与项目文件夹相同的名称，其中包含了项目文件夹、定义解决方案内容的文件。解决方案文件夹内包含如下四个文件：
扩展名为.sln的文件，记录着关于解决方案中项目的信息。扩展名为.suo的文件，其中记录着应用于该解决方案的用户选项。扩展名为.sdf的文件，记录着与解决方案的Intellisense有关的数据。Intellisense是在Editor窗口中输入代码时提供自动完成和提示功能的工具。扩展名为.opensdf的文件，记录着关于项目状态的信息，此文件只在项目处于打开状态时才有。 项目文件夹中的Readme.txt文件包含已经为该项目创建的所有文件的内容摘要。 构建项目时创建的文件： 构建项目完成后将看到解决方案文件夹中出现了一个新的子文件夹Debug。该文件夹包含刚才构建项目时产生的输出，这个文件夹包含三个文件。 .exe文件：可执行文件.ilk文件：在重新构建项目时被链接器使用，它使链接器能够根据修改的源代码生成的目标文件增量的链接到现有的.exe文件，从而避免每次修改程序时都重新链接所有文件。.pdb文件：包含调试信息，在调试模式中执行程序要使用该调试信息。在调试模式中，可以动态检查程序执行过程中所生成的信息。 在项目文件夹中也有一个Debug目录，它包含在构建过程中生成的很多文件，从Windows Explorer的Type描述中可以看到它们包含何种信息。 ipch文件夹和.sdf文件是什么？ ipch的文件夹，和一个与工程同名的.sdf文件，而且ipch下面的文件和.sdf文件都很大，这些文件是Visual Studio用来保存预编译的头文件和Intellisense用的，删除这些文件对于工程的开发完全没有影响。那如果我既想使用预编译的头文件和Intellisense，又不想看到这些无聊的文件该怎么办呢？ 工具-&gt;选项-&gt;文本编辑器-&gt;C/C++ -&gt;高级-&gt;回退位置 那里，两个都设成true
如果你设置了回退位置，那么IPCH等就会到那里去，否则会在系统TEMP里，有个VC++文件夹下。
VS2010解决方案和工程文件的另一种解释：
将所有文件分为6个部分：解决方案相关文件、工程相关文件、应用程序头文件和源文件、资源文件、预编译头文件和编译链接生成文件。
1.解决方案相关文件
解决方案相关文件包括解决方案文件夹下的.sdf文件、.sln文件、.suo文件和ipch文件夹。
.sdf文件和ipch目录一般占用空间比较大，几十兆甚至上百兆，与智能提示、错误提示、代码恢复、团队本地仓库等相关。如果你觉得不需要则可以设置不生成它们，方法是点击菜单栏Tools-&gt;Options，弹出Options对话框，选择左侧面板中Text Editor-&gt;C/C++-&gt;Advanced，右侧列表中第一项Disable Database由False改为True就可以了，最后关闭VS2010再删除.sdf文件和ipch目录以后就不会再产生了。但关闭此选项以后也会有很多不便，例如写程序时的智能提示没有了。
.sln文件和.suo文件为MFC自动生成的解决方案文件，它包含当前解决方案中的工程信息，存储解决方案的设置。
2.工程相关文件
工程相关文件包括工程文件夹下的.vcxproj文件和.vcxproj.filters文件。
.vcxproj文件是MFC生成的工程文件，它包含当前工程的设置和工程所包含的文件等信息。.vcxproj.filters文件存放工程的虚拟目录信息，也就是在解决方案浏览器中的目录结构信息。
3.应用程序头文件和源文件
应用程序向导会根据应用程序的类型（单文档、多文档或基于对话框的程序）自动生成一些头文件和源文件，这些文件是工程的主体部分，用于实现主框架、文档、视图等。
下面分别简单介绍下各个文件：
HelloWorld.h：应用程序的主头文件。主要包含由CWinAppEx类派生的CHelloWorldApp类的声明，以及CHelloWorldApp类的全局对象theApp的声明。
HelloWorld.cpp：应用程序的主源文件。主要包含CHelloWorldApp类的实现，CHelloWorldApp类的全局对象theApp的定义等。
MainFrm.h和MainFrm.cpp：通过这两个文件从CFrameWndEx类派生出CMainFrame类，用于创建主框架、菜单栏、工具栏和状态栏等。
HelloWorldDoc.h和HelloWorldDoc.cpp：这两个文件从CDocument类派生出文档类CHelloWorldDoc，包含一些用来初始化文档、串行化（保存和装入）文档和调试的成员函数。
HelloWorldView.h和HelloWorldView.cpp：它们从CView类派生出名为CHelloWorldView的视图类，用来显示和打印文档数据，包含了一些绘图和用于调试的成员函数。
ClassView.h和ClassView.cpp：由CDockablePane类派生出CClassView类，用于实现应用程序界面左侧面板上的Class View。
FileView.h和FileView.cpp：由CDockablePane类派生出CFileView类，用于实现应用程序界面左侧面板上的File View。
OutputWnd.h和OutputWnd.cpp：由CDockablePane类派生出COutputWnd类，用于实现应用程序界面下侧面板Output。
PropertiesWnd.h和PropertiesWnd.cpp：由CDockablePane类派生出CPropertiesWnd类，用于实现应用程序界面右侧面板Properties。
ViewTree.h和ViewTree.cpp：由CTreeCtrl类派生出CViewTree类，用于实现出现在ClassView和FileView等中的树视图。
4.资源文件
一般我们使用MFC生成窗口程序都会有对话框、图标、菜单等资源，应用程序向导会生成资源相关文件：res目录、HelloWorld.rc文件和Resource.h文件。
res目录：工程文件夹下的res目录中含有应用程序默认图标、工具栏使用图标等图标文件。
HelloWorld.rc：包含默认菜单定义、字符串表和加速键表，指定了默认的About对话框和应用程序默认图标文件等。
Resource.h：含有各种资源的ID定义。
5.预编译头文件
几乎所有的MFC程序的文件都要包含afxwin.h等文件，如果每次编译都要编译一次则会大大减慢编译速度。所以把常用的MFC头文件都放到了stdafx.h文件中，然后由stdafx.cpp包含stdafx.h文件，编译器对stdafx.cpp只编译一次，并生成编译之后的预编译头HelloWorld.pch，大大提高了编译效率。
6.编译链接生成文件
如果是Debug方式编译，则会在解决方案文件夹和工程文件夹下都生成Debug子文件夹，而如果是Release方式编译则生成Release子文件夹。
工程文件夹下的Debug或Release子文件夹中包含了编译链接时产生的中间文件，解决方案文件夹下的Debug或Release子文件夹中主要包含有应用程序的可执行文件。
关于应用程序工程文件的组成结构就先讲到这了。其中包含了很多专有名词，以后大家会慢慢熟悉的
学习C++学的是什么？
C++是很复杂的一门语言，因为要实现在其它语言中很简单的任务，在C++中通常需要跟多的代码和时间，例如：创建一个窗口，其它语言有内置的支持，而在纯粹的C++环境中是做不到的。因为C++没有提供GUI的内置支持，如果要用C++创建一个窗口，我们需要使用系统API或者使用封装了系统API的一些库，前者如Win32系统API后者如MFC、wxWidgets等。
但是这不代表C++不好，反而C++是很强大的，我们学习C++学的不仅仅是C++的语法，因为仅仅懂C++的语法有什么用呢？演示算法吗？当然不是了。我认为，学习C++初期当然是熟悉C++的语法，中期是学习STL库、系统API以及C++面向对象的思想和一般的设计方法，后者是伴随你C++生涯一生的，因为它没有终点。
除了加深对C++的理解之外，你还得需要各种各样的基于C++的库去实现更具体的东西。如果你想做GUI，那你得学习QT、wxWidgets等。如果想做游戏方面的那么Ogre、Unreal、Bigworld等库是你需要学习的。网络方面的库ASIO、RakNet、ACE等。这些库都是基于C++的，其封装了底层的API，似的我们可以不必每次去使用繁杂的API来实现我们想要的功能。当然你也可以使用C++去封装这些API，让自己成为一个库作者，方便他人。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0086a7b279ec109c1e3873ba68f0850f/" rel="bookmark">
			eclipse中配置的tomcat 启动正常 但是访问报404错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 在eclipse中配置的Tomcat，启动是正常的，控制台显示启动成功，也没有报任何错误信息，但是访问的时候就报404错误，然后直接在bin目录下启动startup.bat的方式就是正常的。然后就很纳闷，之后在网上搜了下资料，说是Eclipse的配置出了问题。
解决方案：
1、如果Server里的tomcat启动了，需要先停掉。然后再移除添加的项目
2、之后双击server中配置的tomcat服务器，会弹出如下界面。
3、在Server Locations配置中选择第二个选项，use tomcat installation ，（默认的情况下eclipse是选中的第一个选项），然后再保存一下，重新启动Tomcat服务，就可以了。
4、需要注意的是：可能有的时候会出现Server Locations下面的几个选项都是只读的，不能进行选择。如：
5、这个时候就需要在Server下的Tomcat上右击——》然后选择publish，重新发布一下即可。注意：必须得确保tomcat已经停掉，然后项目已经被移除掉了。或者可以使用另一种方法进行解决：删掉Tomcat，再重新配置一个Tomcat即可
6、然后再重新执行上面的步骤3，即可
7、重新将项目添加到tomcat容器中，启动运行，看看效果。
8、结束。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b5caa1ab7962f8ca1456f77f222d671/" rel="bookmark">
			C&#43;&#43;读书清单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 经典大全 C++ Primer C++ Primer Plus The C++ Programming Language(C++程序设计语言) The Design and Evolution of C++(C++语言的设计和演化) Principles and Practice Using C++(C++编程原理和实践) // 入门书籍 Essential C++ Accelerated C++ // 进阶书籍 Effective C++ More Effective C++ Effective STL Exceptional C++ More Exceptional C++ Exceptional C++ Style C++ Coding Standards: 101 Rules, Guidelines, and Best Practices(C++编程规范：101条规则、准则最佳实践) C++ Common Knowledge(C++必知必会) Procressional C++(C++高级编程) // 进阶STL(Effective STL于上) The C++ Standard Library(C++标准程序库) Generic Programming and the STL(泛型编程与STL) C++ Templates(C++模板) Applied C++ Absolute C++(完美的C++教程) Modern C++ Design(C++设计新思维) Thinking in C++(C++编程思想) Inside The C++ Object Model(深度探索C++对象模型) Ruminatons C++(C++沉思录) Imperfect C++(不完美的C++) C and C++ Code Capsules(C和C++代码精粹) Understanding C++11(深入理解C++11) C++ Concurrency in Action C++ in Action(C++实践之路) C++ Programming Style(C++编程风格) Designing and Coding Reusable C++(C++代码设计与重用) C++ Strategies and Tactics(C++编程惯用法) Efficient C++(提高c++性能的编程技术) C++ Programming Today(现代C++程序设计) Large-Scale C++ Software Design(大规模C++程序设计) C++编程艺术 C++ Gotchas(C++程序设计陷阱) Multi-Paradigm Design for C++(C++多范型设计) C++ Gotchas(C++语言 99个常见编程错误) Programming in C++ C和C++安全编码 C++精解和程序设计 标准C++输入输出流与本地化 C++面向对象多线程编程 C++面向对象高效编程 C++语言命令详解 C++大学自学教程 C++大学教程 // 国人的书籍 STL 源码剖析（侯捷） Linux多线程服务端编程（陈硕） 高质量程序设计指南（林锐/韩永泉） C++应用程序性能优化（冯宏华/徐莹/程远/汪磊） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/804eb4201a9cfa575e9faa546217e9df/" rel="bookmark">
			Linux/Android——Input系统之InputMapper 处理 (八)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前文Linux/Android——Input系统之InputReader (七)介绍到了inputreader的运作流程，如何获取events到初步的分发，依次分析到InputMapper做第一步的处理.
前文有解析Mapper类型的依赖规则，不做重述.,这里单以触摸屏input_device 对应的SingleTouchInputMapper 为例。
撰写不易,转载需注明出处：http://blog.csdn.net/jscese/article/details/43561773本博文来自【 jscese 】的博客！
SingleTouchInputMapper： 原型定义在InputReader.h 中：
class SingleTouchInputMapper : public TouchInputMapper { public: SingleTouchInputMapper(InputDevice* device); virtual ~SingleTouchInputMapper(); virtual void reset(nsecs_t when); virtual void process(const RawEvent* rawEvent); protected: virtual void syncTouch(nsecs_t when, bool* outHavePointerIds); virtual void configureRawPointerAxes(); virtual bool hasStylus() const; private: SingleTouchMotionAccumulator mSingleTouchMotionAccumulator; }; 继承自TouchInputMapper，函数实现全部放在InputReader.cpp中，先看首先调用进的process：
void SingleTouchInputMapper::process(const RawEvent* rawEvent) { TouchInputMapper::process(rawEvent); //调用父类的process mSingleTouchMotionAccumulator.process(rawEvent); //数据的同步 } 继续跟： void TouchInputMapper::process(const RawEvent* rawEvent) { mCursorButtonAccumulator.process(rawEvent); mCursorScrollAccumulator.process(rawEvent); mTouchButtonAccumulator.process(rawEvent); //这三个Accumulator 进一步处理rawEvent ，原型都在InputReader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/804eb4201a9cfa575e9faa546217e9df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/460fd8b6a3e7c1aae4b3fb9eea980587/" rel="bookmark">
			Setup Factory打包注册dll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、生成一个Setup Factory工程，按照向导生成即可
2、添加dll到工程中
3、判断原有文件夹下是否有该文件，如果有删除。在On Pre Install中添加代码，改代码是通过Add Action添加，File-&gt;DoesExist,File-&gt;Delete
result = File.DoesExist(SessionVar.Expand("%AppFolder%\\RIGOLL3520.dll"));
if(result) then
File.Delete(SessionVar.Expand("%AppFolder%\\RIGOLL3520.dll"), false, false, false, nil);
end
4、将文件添加到安装目录后，注册文件。Shell.Execute("regsvr32", "open", SessionVar.Expand(" /s \"%AppFolder%\\RIGOLL3520.dll\""));
5、打包生成exe文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a88f7aa9162b51684b22891bf188f725/" rel="bookmark">
			HTML5&#43;开发移动app教程2-原理介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理 html5+开发app的原理大概是这样：
html页面负责内容；
ui负责页面样式；
js负责调用原生app方法。
html5 html5这部分负责页面，也就是app中你看到的东西，大概的架构和内容
ui ui负责页面样式，既然要做移动app，那做出的效果就得和移动端靠近，
这里并没有局限于用那种ui，比较常见的适配移动端的ui框架有：
bootstrap 介绍：Twitter开发的ui框架，特点是可以简介美观，可以适配移动端（例如本站：uikoo9.com）
中文官网：Bootstrap v3 中文文档 · Bootstrap 是最受欢迎的 HTML、CSS 和 JavaScript 框架，用于开发响应式布局、移动设备优先的 WEB 项目。 | Bootstrap 中文网
amazeui 介绍：国人模仿bootstrap做的一个ui框架，个人感觉有点多余，有兴趣的可以看看
官网：http://amazeui.org/
jquery mobile 介绍：HBuilder其实是模仿国外的phonegap，通用mui是模仿jquery mobile，但是感觉也不错
官网：jQuery Mobile
mui 介绍：和HBuilder想搭配的移动ui，也和nativejs相搭配，感觉还不错，模仿的ios7界面风格
官网：MUI-最接近原生APP体验的高性能前端框架
framework7 介绍：国外一块模仿ios7的ui框架，赞
官网：Framework7 - Full Featured Framework For Building iOS, Android &amp; Desktop Apps
nativejs 介绍：一个可以调用android和ios原生方法的js
入门：5+ App开发Native.js入门指南 - DCloud问答
搭配 选择：目前比较好的搭配是mui+nativejs+hbuilder，你也可以尝试其他的组合，例如jqmobile+nativejs等
mui-demo：Hello MUI
nativejs-demo：HTML5产业联盟
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b27377ebec56e91129ce35eaf1514e18/" rel="bookmark">
			HTML5&#43;开发移动app教程1-环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本教程是介绍使用html5+（nativejs）和mui开发移动app（包括android和ios），
感兴趣请继续，不感兴趣请跳过，大部分来自官方api，增加了一些自己的总结。
HBuilder 说明 用h5+开发app的环境，也是ide，对eclipse做了深度定制，以前使用过eclipse或者myeclipse可以直接上手
官网 DCloud - HBuilder、HBuilderX、uni-app、uniapp、5+、5plus、mui、wap2app、流应用、HTML5、小程序开发、跨平台App、多端框架
下载 在官网上点击下载，安装好后可以自己将文件夹压缩成zip，方便以后使用，解压就可以用
依赖 估计会需要jre环境？没有试过，如果需要请自行百度搜索jre安装方法
上手 打开HBuilder之后默认会有一个项目“HelloHBuilder”，里面有HBuilder使用的介绍
快捷键 HBuilder一大亮点是快捷键，但是如果习惯了自己之前的快捷键会很别扭，需要自己在工具——选项——常规——快捷键中修改
插件
HBuilder将插件做了下优化，提供了最长用的一些插件，并且使用dcloud网站下载，速度很快，eclipse自带插件安装需要翻墙
打开工具——插件安装，安装自己需要的插件，例如我安装了如下插件：
完成 环境搭建就完成了，这应该是所有开发环境搭建中最简答的了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee94d3dc38699ecd15f4b7d64161b033/" rel="bookmark">
			基于html5、JS实现的拍照上传图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理：调出摄像头，拍照保存到画布，将图片URi传送到后台
前端代码（Index.cshtml）：
&lt;style&gt; #video,#canvas {display: block;margin:1em auto;width:180px;height:180px;} #snap { display: block;margin:0 auto;width:80%;height:2em; } &lt;/style&gt; &lt;div class="container"&gt; &lt;video id="video" autoplay&gt;&lt;/video&gt; &lt;button id="snap"&gt;点击拍照&lt;/button&gt; &lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; window.addEventListener("DOMContentLoaded", function () { try { document.createElement("canvas").getContext("2d"); } catch (e) { alert("not support canvas!") } var video = document.getElementById("video"), canvas = document.getElementById("canvas"), context = canvas.getContext("2d"); navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia; if (navigator.getUserMedia) navigator.getUserMedia( { "video": true }, function (stream) { if (video.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee94d3dc38699ecd15f4b7d64161b033/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e34a8031f3dc1b899982cf0e9661954d/" rel="bookmark">
			Linux ACL 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 为什么要使用ACL
先让我们来简单地复习一下Linux的文件权限。
在 linux下,对一个文件(或者资源)可以进行操作的对象被分为三类: file owner(文件
的拥有者),group(组,注意不一定是文件拥有者所在的组), other (其他)而对于每一类
别又分别定义了read, write and execute/search 权限 (这里不讨论SUID, SGID以及
Sticky bit的设置)
通过ls -l命令就我们就可以列出一个文件的权限
代码:
[leonard@localhost ~]$ ls -l
-rw-rw---- 1 leonard admin 0 Jul 3 20:12 test.txt
在这里说明了对于test.txt这个文件leonard用户(由于是file owner)拥有read &amp; write
权限. 所有属于admin 组的用户(group)拥有read &amp; write 权限. 其他任何用户(other)
对于文件没有任何的权限
如果我们现在希望john这个用户也可以对test.txt文件进行读写操作. 我自己大概会想到
以下几种办法 (这里假设john不属于admin group)
1. 给文件的other类别增加读和写的权限. 这样由于john会被归为other类别,那么
他也将拥有读写的权限。
2. 将john加入到admin group. 那么john会被归为group类别,那么他将拥有读写的权限。
3. 设置sudo, 使john能够以leonard的身份对test.txt进行操作,从而获得读写权限。
第一种做法的问题在于所有用户都将对test.txt拥有读写操作,显然这种做法不可取。
第二种做法的问题在于john被赋予了过多的权限.所有属于admin组的文件,john都可以拥
有其等同的权限了。
第三种做法虽然可以达到只限定john用户一人拥有对test.txt文件的读写权限.但是需要
对sudoers文件进行严格的格式控制. 而且当文件数量和用户很多的时候,这种方法就相当
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e34a8031f3dc1b899982cf0e9661954d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcde608a6c5ebe00ed7e6164e8af085d/" rel="bookmark">
			IOS6内存警告处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动设备终端的内存极为有限，应用程序必须做好low-memory处理工作，才能避免程序因内存使用过大而崩溃。如果一个app使用的内存超过20M，则系统会向该app发送Memory Warning消息。收到此消息后，app必须正确处理，否则可能出错或者出现内存泄露。
app收到Memory Warning后会调用：UIApplication::didReceiveMemoryWarning -&gt; UIApplicationDelegate::applicationDidReceiveMemoryWarning,然后调用当前所有的viewController进行处理。因此处理的主要工作是在viewController。
当我们的程序在第一次收到内存不足警告时，应该释放一些不用的资源，以节省部分内存。否则，当内存不足情形依然存在，iOS再次向我们程序发出内存不足的警告时，我们的程序将会被iOS kill掉。
low-memory 处理思路 通常一个应用程序会包含多个view controllers，当从view跳转到另一个view时，之前的view只是不可见状态，并不会立即被清理掉，而是保存在内存中，以便下一次的快速显现。但是如果应用程序接收到系统发出的low-memory warning，我们就不得不把当前不可见状态下的views清理掉，腾出更多的可使用内存；当前可见的view controller也要合理释放掉一些缓存数据，图片资源和一些不是正在使用的资源，以避免应用程序崩溃。 思路是这样，具体的实施根据系统版本不同而略有差异，本文将详细说明一下iOS 5与iOS 6的low-memory处理。 iOS 5 的处理 在iOS 6 之前，如果应用程序接收到了low-memory警告，当前不可见的view controllers会接收到viewDidUnload消息（也可以理解为自动调用viewDidUnload方法），所以我们需要在 viewDidUnload 方法中释放掉所有 outlets ，以及可再次创建的资源。当前可见的view controller 通过didReceiveMemoryWarning 合理释放资源，具体见代码注释。 举一个简单的例子,有这样一个view controller： @interface MyViewController : UIViewController { NSArray *dataArray; } @property (nonatomic, strong) IBOutlet UITableView *tableView; @end 对应的处理则为： #pragma mark - #pragma mark Memory management - (void)didReceiveMemoryWarning { // Releases the view if it doesn't have a superview. [super didReceiveMemoryWarning]; // Relinquish ownership any cached data, images, etc that aren't in use.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcde608a6c5ebe00ed7e6164e8af085d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/579d4f363a91db95eb768443313e4582/" rel="bookmark">
			ubuntu   彻底卸载apache2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近老是在换项目，在做环境，删除原有不用的，有时候再装出错，下面就apache2的完全卸载命令贴出来，供大家参考！
1. 删除apache
代码:
$ sudo apt-get --purge remove apache-common
$ sudo apt-get --purge remove apache
2.找到没有删除掉的配置文件，一并删除
代码:
$ sudo find /etc -name "*apache*" |xargs rm -rf
$ sudo rm -rf /var/www
$sudo rm -rf /etc/libapache2-mod-jk
3.删除关联，这样就可以再次用apt-get install apache2 重装了
#dpkg -l |grep apache2|awk '{print $2}'|xargs dpkg -P
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6613334897e3f718a72e45502d24e42/" rel="bookmark">
			小书匠markdown编辑器V1.0.12发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小书匠markdown编辑器V1.0.12发布 markdown 编辑器 小书匠编辑器是一款专为markdown写作设计的编辑器，提供了web，window，linux，mac多种版本，实现了浏览器存储/本地文件系统存储/evernote/印象笔记/github/dropbox等多种存储方案，并具备多种导出方案，欢迎试用。
主要功能 专为markdown写作设计的文档编辑器，让用户心无旁骛的进行创作。多种编辑模式。单栏编辑，双栏编辑，三栏编辑，全屏写作，全屏阅读…想怎么切换，就怎么切换，就是这样随心所欲。多种主题选择。包括编辑器主题，预览区代码高亮主题，及预览区用户自定义css。丰富的语法支持。不仅提供了常用的commanmarkdown语法，还提供了许多有用的扩展语法，比如Latex公式，表格, 目录， 脚注, 视频, 音频, 附件, checklist, 流程图等。更多语法可查看&lt;小书匠语法使用手册&gt;第三方同步。浏览器存储, 本地文件系统存储, dropbox, evernote, 印象笔记, github等多种存储方案，保证了用户数据的安全，也让用户在存储方案上有了更多的选择。支持evernote，印象笔记。提供双向操作，可以将文章保存到evernote/印象笔记上，也可以从evernote/印象笔记上导入数据。同时提供标签，附件，图片，待办等相关处理。强大的文件管理功能。文件信息，标签，附件，音频，视频，图片管理。发布功能。 支持将文章发布到博客平台上。邮件发送功能。sourceMap对照功能。方便在源markdown文件和生成的html文件上进行比较，特别适合markdown初学者使用，了解每一个markdown解析产生的结果，也适用于文章后期的校对上。 离线版下载地址
http://soft.xiaoshujiang.com
WEB版访问地址
http://markdown.xiaoshujiang.com
下面的链接是使用小书匠编辑器离线版发布的语法手册
博客园地址：
http://www.cnblogs.com/suziwen/p/4248241.html
开源中国地址:
http://my.oschina.net/suziwen/blog/371538
使用手册:
http://www.cnblogs.com/suziwen/p/4248238.html
转载于:https://my.oschina.net/suziwen/blog/371593
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac9706804175c15f2f50ff9ed1a727ac/" rel="bookmark">
			python排序函数sort()与sorted()区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sort是容器的函数：sort(cmp=None, key=None, reverse=False)
sorted是python的内建函数：sorted(iterable, cmp=None, key=None, reverse=False)
参数解析：
cmp：比较函数，比较什么参数由key决定。例如：cmp(e1, e2) 是具有两个参数的比较函数，返回值：负数（e1 &lt; e2）；0（e1 == e2）；正数（ e1 &gt; e2）。
key：用列表元素的某个属性或函数作为关键字。
reverse：排序规则，可以选择True或者False。
sorted多一个参数iterable：待排序的可迭代类型的容器
示例1：
&gt;&gt;&gt; a=[1,2,5,3,9,4,6,8,7,0,12]
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12]
&gt;&gt;&gt; a=[1,2,5,3,9,4,6,8,7,0,12]
&gt;&gt;&gt; sorted(a)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12]
&gt;&gt;&gt; a
[1, 2, 5, 3, 9, 4, 6, 8, 7, 0, 12]
区别：
对于一个无序的列表a，调用a.sort()，对a进行排序后返回a，sort()函数修改待排序的列表内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac9706804175c15f2f50ff9ed1a727ac/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/471/">«</a>
	<span class="pagination__item pagination__item--current">472/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/473/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>