<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc9d40ecd0f175361706b91932f87a7/" rel="bookmark">
			傲软下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 傲软下载地址 https://www.apowersoft.cn/
类型地址beecuthttp://download.apowersoft.com/down.php?softid=beecutproinstall-bdcompresshttp://download.apowersoft.com/down.php?softid=apowercompressinstall-bdshowhttp://download.apowersoft.com/down.php?softid=apowershowinstallstreaming audio recorderhttp://download.apowersoft.com/down.php?softid=streamingaudiorecorderinstall-bdvideo converterhttp://download.apowersoft.com/down.php?softid=videoconverterinstall-bdwatermark removerhttp://download.apowersoft.com/down.php?softid=watermarkremoverinstall-bdgife ditorhttp://download.apowersoft.com/down.php?softid=gifeditorinstall-bdmirrorhttp://download.apowersoft.com/down.php?softid=apowermirrorinstallgameplayhttps://dlqn.aoscdn.com/apowersoftgameplay-bd.execasttingohttps://download.apowersoft.cn/down.php?softid=casttingo-bdphone managerhttp://download.apowersoft.com/down.php?softid=apowermanager-bdios recorderhttps://download.apowersoft.cn/down.php?softid=iosrecorderinstallandroid recorderhttps://download.apowersoft.cn/down.php?softid=androidrecorderinstall-bdrescuehttps://dlqn.aoscdn.com/apower-rescue.exeios unlockhttps://download.apowersoft.cn/down.php?softid=apowerunlockinstall-bdrechttp://download.apowersoft.com/down.php?softid=apowerrecinstallpdf editorhttps://download.apowersoft.cn/down.php?softid=pdfeditorinstall-bdrecoverhttps://download.apowersoft.cn/down.php?softid=apowerrecoverinstall-bdscreen capturehttps://download.apowersoft.cn/down.php?softid=screencaptureproinstall-bdpdf converterhttps://download.apowersoft.cn/down.php?softid=pdfconverterinstall-bdbackground eraserhttps://download.apowersoft.cn/down.php?softid=backgrounderaserinstall-chn-apowersoftcad viewerhttps://download.apowersoft.cn/down.php?softid=cadviewer-bdpdf compressorhttps://download.apowersoft.cn/down.php?softid=pdfcompressorinstall-bdcollage pichttps://download.apowersoft.cn/down.php?softid=apowercollageinstall-bd beecut-setup-bd.exe\.rsrc\CONF\106 { "softid": "beecutproinstall-bd" } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/796c70e09dba9af8cf67daa82472f34e/" rel="bookmark">
			TTSR补充材料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		补充材料 网络结构细节不同尺度上的TT运行时间和模型大小更直观的比较 在本补充材料中，A部分说明了TTSR网络结构的细节。B部分提供了关于不同尺度上纹理转换器的附加分析。C节描述运行时间和参数个数的比较。最后，更多的可视化比较结果将在D部分显示。
网络结构细节 在本节中，我们将详细说明我们的方法TTSR的网络结构，TTSR的网络结构包括纹理转换器中的可学习纹理提取器，带有三个堆叠纹理转换器的生成器、鉴别器。可学习纹理提取器的结构如表A.1所示，其中$0、$3和$6层用于纹理转换器中纹理特征的搜索和传输。表A.2显示了生成器的详细信息，表A.3说明了标识符。
The structure of the learable texture extractor
The structure of the generator with three stacked texture transformers
The structure of the discriminator
不同尺度上的TT 我们提出的TTSR包含三个堆叠的TT。每个尺度下的TT融合了Ref图像中不同级别的HR纹理特征。在这里，我们进行了使用TT在不同尺度上的实验。因为CSFI是针对多尺度叠加纹理变换而设计的，这里的模型没有CSFI。结果见表B.1。TT的应用规模越大，性能越好，说明TT在更大的规模下细节丢失越少。当我们逐渐添加其他尺度的TT时，性能可以进一步提高。
运行时间和模型大小 在这一部分，我们讨论运行时间和模型大小。我们比较了TTSR与最先进的SISR和RefSR方法，RCAN [39]， RSRGAN [38]， CrossNet[43]和SRNTT[41]。对于运行时间，所有方法使用 Tesla V100 PCIe图形处理器，在83 × 125 × 3 上采样因子为4×的LR输入图像上进行测试。Table C.1展示了对比结果。具体来说,堆叠TT花费0.037秒和其他部分花费0.059s, TTSR总时间为0.096s。结果表明TTSR在相对较小的参数数量和较短的运行时间的基础上还有最好的表现。
更直观的比较 在本节中，我们展示了所提出的TTSR方法与其他SR方法的更多比较结果，包括RDN[40]、RCAN[39]、RSRGAN[38]、CrossNet[43]和SRNTT[41]。近年来，RCAN在PSNR和SSIM上都取得了最好的性能，RSRGAN被认为实现了最好的视觉质量。CrossNet和SRNTT是两种最先进的RefSR方法，显著优于以前的RefSR方法。CUFED5[41]、Sun80[26]、Urban100[11]和Manga109[20]的可视化对比结果如图所示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b95bfe0bc62b75e285cdd016d45b31e/" rel="bookmark">
			win 7 连接打印机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先确定打印机能正常使用，然后将usb数据线连接电脑和打印机。
2、在电脑主界面点击“开始”（图中1），然后点击“控制面板”（图中2）。
3、进入控制面板后，在选项中选择“硬件和声音”（图中方框所示），点击进入。
4、然后在弹出的对话框中选择“设备和打印机”（图中方框所示），点击进入。
5、点击进入设备和打印机设置页面后，点击“添加打印机”（图中方框所示）。
6、在弹出的界面中选择“添加本地打印机”（图中方框所示），然后点击进入。
7、选择打印机的端口类型（图中1）一般说明书上有，然后点击“下一步”（图中2）。
8、在选项列表内先选打印机的厂商（图中1）和打印机型号（图中2），如果打印机的品牌和对应的型号都能选择，选择完后可以直接下一步进行安装。如果打印机品牌或者型号在里面找不到，（图中3）或者本身带有驱动或者使用光盘安装的点击“从磁盘安装”。
9、使用“从磁盘安装”的点击后在弹出的对话框中选择“浏览”（图中方框所示）。
10、然后从磁盘中找到打印机的驱动选中（图中1），然后点击打开（图中2）。
11、然后会返回之前的界面，在界面中点击“下一步”（图中方框所示）。
12、然后输入打印机的名称（图中1），书好后点击“下一步”（图中2）。
13、安装完成，会有一个共享设置。如果需要共享就按下一步设置，不需要共享给其他人使用的直接按取消就可以完成安装。
14、可以通过打印测试纸来测试连接的打印机是否正常。如果失败可以检查打印机电源是否打开，与主机连接的线路是否连接好，打印机的驱动安装有没有安装错型号等。
另外，如果你还有更多其它电脑问题不懂的话，可以打开“小白维修”App查找问题，里面还有更多电脑问题的详细解决方案哦。好啦，以上就是今天分享的所有内容，不知道对你有没有帮助呢？如果你觉得这篇文章有用的话，别忘了点个赞关注我，每天与你分享更多电脑问题小知识哦。
扩展 详细讲解电脑和打印机连接方法 第一：首先把打印机的电源插到电源插座上，然后打开打印机的开关，然后把USB数据线把电脑与打印机连接好。
第二：现在再把电脑上的打印机所相符的驱动安装，安装时只需用鼠标单击软件包，可以根据提示进行安装，安装完成之后，请往下看详细。
第三：安装好后，依次打开“我的电脑”–“控制面板”–“硬件和声音”的选项，然后点击“添加本地打印机”根据打印机的端口类型来进行选择，最后会在列表中出现相关的打印机品牌型号，可以根据提示来进行安装即可，如图。
没有安装打印机驱动，报错了
搜索 ：HP打印机驱动
输入\192.167.3.188\HP LaserJet M1005 (副本 1)
通过浏览打印机即网上邻居添加
选择CYYUN-QIANTAI 这台打印机
提示需要输入用户密码，即为连接打印机的电脑的登陆名称和密码
user：qwq_DHF
pwd：dhf
双击完，即添加完毕打印机。
第四 ：安装好之后会显示有打印测试，在打印文件时，可以从打印预览的效果，查看文字整体的版式是否合适，预览之后，选择与纸张相符的尺寸，纸张效果以及打印机型号，开始打印试着效果就可以了，如果遇到打错的时候，可以选择暂停或者取消打印。
好了，大家按照以上的步骤操作即可。
扩展 在新窗口，选择“添加本地打印机”
请在添加打印机向导中，选择“创建新端口”， 从下拉框中选择“Standard TCP/IP Port” ，单击“下一步”。
在“打印机名或 IP 地址” 中输入网络内复合机的 IP 地址，端口名将自动生成，单击“下一步”，公司打印机 ip 为 192.168.0.180。
系统会检测 TCP/IP 端口，稍后转变新界面，在“设备类型”中选择“标准”直接单击“下一步”
从 http://192.168.188.104/software/Driver/ 下载对应系统的驱动，解压
选择“从硬盘安装驱动”
选择刚才驱动解压后的驱动文件夹，打开后选中.inf 格式的文件，单击“打开”
自动安装驱动
因为我之前在本机已经安装过驱动，所以会出现这一步。如果第二次安装，为了避免驱动异常，请选择“替换当前的驱动程序”。
打印机名可自行更改
不共享打印机，下一步
打印机添加完毕，可用“打印测试页”测试是否成功
参考链接 ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b95bfe0bc62b75e285cdd016d45b31e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bd50cd39cb1006d8484b708282827f1/" rel="bookmark">
			每天学点Linux（十二）.bashrc文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的 利用.bashrc文件存储并加载你的终端配置和环境变量以提高在终端中的工作效率
什么是.bashrc? .bashrc是一个ASCII文本文件。它位于home目录下（~/.bashrc）, bash在每次启动时都会加载 .bashrc 文件的内容。
为什么说.bashrc可以提高工作效率？ .bashrc文件中添加别名，减少命令长度.bashrc文件中使用函数，使用多个命令 常见的别名 # ALIASES # ########## alias ll="ls -lhA" alias sl="ls" alias ps="ps aux" alias mkdir="mkdir -p" alias top="htop" 常见函数 mcd () { mkdir -p $1 cd $1 } 函数的书写符合shell程序。
bashrc中的rc可以理解为run configuration（运行配置）
如果你只想往里边增加东西，可以试试这个：
echo "source /opt/ros/noetic/setup.bash" &gt;&gt; ~/.bashrc source ~/.bashrc [1] https://linux.cn/article-9298-1.html
[2] https://www.digitalocean.com/community/tutorials/an-introduction-to-useful-bash-aliases-and-functions
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098a9425fd16833af186ba26ac0234f8/" rel="bookmark">
			钉钉历史版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		钉钉历史版本 windows历史版本 https://im.dingtalk.com/manifest/new/website/vista_later.json
https://dtapp-pub.dingtalk.com/dingtalk-desktop/win_installer/Release/DingTalk_v6.5.0.3249116.exe
https://dtapp-pub.dingtalk.com/dingtalk-desktop/win_installer/Release/DingTalk_v6.5.0.3229113.exe
https://dtapp-pub.dingtalk.com/dingtalk-desktop/win_installer/Release/DingTalk_v6.3.25.1219101.exe
https://dtapp-pub.dingtalk.com/dingtalk-desktop/win_installer/Release/DingTalk_v6.3.25.1209106.exe
https://dtapp-pub.dingtalk.com/dingtalk-desktop/win_installer/Release/DingTalk_v6.3.15.12108702.exe
https://dtapp-pub.dingtalk.com/dingtalk-desktop/win_installer/Release/DingTalk_v6.3.5.11308701.exe
https://dtapp-pub.dingtalk.com/dingtalk-desktop/win_installer/Release/DingTalk_v6.0.26.9039963.exe
https://download.alicdn.com/dingtalk-desktop/Release/install/Dingtalk_Release_v1.10.0.msi
https://download.alicdn.com/dingtalk-desktop/Release/install/Dingtalk_Release_v1.11.0.msi
https://download.alicdn.com/dingtalk-desktop/Release/install/Dingtalk_Release_v1.11.1.msi
https://download.alicdn.com/dingtalk-desktop/Release/install/Dingtalk_Release_v1.12.0.msi
https://download.alicdn.com/dingtalk-desktop/Release/install/Dingtalk_Release_v1.13.1.msi
https://download.alicdn.com/dingtalk-desktop/Release/install/Dingtalk_Release_v1.13.0.msi
https://download.alicdn.com/dingtalk-desktop/Release/install/Dingtalk_Release_v1.15.5.msi
https://download.alicdn.com/dingtalk-desktop/Release/install/Dingtalk_Release_v1.15.6.msi
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.5.3.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.5.5.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.5.8.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.5.10.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.6.2.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.6.7.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.6.8.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.6.9.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.6.11.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.6.12.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.8.1.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.8.2.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.8.4.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.8.5.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.8.6.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.8.8.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.8.9.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.8.10.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.8.12.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.8.15.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.4.8.18.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.0.1.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.0.2.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.0.3.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.0.13.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.0.14.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.0.15.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.0.16.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.0.18.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.0.21.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.1.2.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.1.5.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.1.6.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.1.9.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.1.10.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.1.11.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.1.13.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.2.2.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.2.3.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.2.4.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.2.6.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.2.7.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.2.8.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.2.9.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.2.12.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.2.13.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.3.1.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.3.2.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.3.3.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.3.4.exe
https://download.alicdn.com/dingtalk-desktop/win_installer/Release/DingTalk_v3.5.3.6.exe
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/098a9425fd16833af186ba26ac0234f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7652f168b7155dd4f475d9fa572d3895/" rel="bookmark">
			手把手教你玩转YOLOX--（下）数据集标注及训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据集的标注是做训练的重要一环，本次数据集标注以口罩检测为例，介绍使用labelimg的数据标注，并且使用YOLOX进行训练。我们从百度网上搜了一些图片，我们就拿这些图片进行标注并训练，标注对象主要有两个"persion"和"mask"，就是普通行人和戴口罩的人两类。首先给大家使用数据集标注软件labelimg。
一：labelimg的安装
labelimg的安装
首先我们进入到我们在上一节创建的python环境
conda activate yolox_train 然后我们执行：
pip install labelimg 如果镜像源不够快也可以指定清华的镜像源
​pip install labelimg -i https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ 然后安装pyqt5如下操作：
pip install pyqt5 二：labelimg的使用
在yolox环境下执行：labelimg，打开界面，如图：
Open：打开一个图片。
Open Dir：打开一个目录下所有图片。
Change Save Dir：标注后的图片保存目录。
Next Image：下一副图片。
Prev Image：上一副图片。
Create RectBox：标注图片。
YOLO：指标注成yolo格式，点击还可以改为：Pascal VOC、CreatML格式。
三：Pascal VOC数据集格式
（1）准备你的数据集
第一步：筛选图片：一般我们从网上爬下来的图片文件名各异，我们首先要把这些文件进行第一资的筛选，把打不开的，动画图片，卡通等不符合要求的图片删除掉。
第二步：文件重命名：将你认为合格的文件进行重新命名，从000001.jpg,000002,jpg......00000n.jpy进行命名，因为需要训练的文件比较多，你可以编写一个小程序，自动命名这些文件。
（2）PASCAL VOC数据集由三个部分构成，JPEGImages，Annotations，ImageSets。
JPEGImages：存放的是训练与测试的所有图片。
Annotations：里面存放的是每张图片打完标签所对应的XML文件
ImageSets：里面有个Main文件夹，其中包含存储着图片名称的txt文件，分为训练与测试。VOC2007的文件目录如下：
--VOC2007
--Annotations
--ImageSets
--Main
--Layout
--Segmentation
--JPEGImages
--SegmentationClass
--SegmentationObject
（3）在这次标注中我们使用Pascal VOC格式保存标注。
先按照VOC2007的数据集格式创建相应的文件夹。然后将我们找到的图片放到JPEGImages文件病人，打开labelimg设置好：
Open Dir：指向“JPEGImages”文件夹，将你的原始图片全都考贝到这个文件夹里去。
Change Save Dir：指向“Annotations“文件夹。labelimg保存标注后会自动存到这个文件夹里。
四：labelimg数据标注
如下进行标注
多人时进行标注，如下图。 Next Image时会提示你进行保存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7652f168b7155dd4f475d9fa572d3895/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1055321f7eca93bbf7b37d5cd404b4/" rel="bookmark">
			windows删除注册表中多余信息及卸载残余应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言删除应用残余 总结 前言 注册表中有很多多余的信息，我们可以对注册表进行优化
（1） 删除多余的时区
路径：计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones
这里有好多其他国家的时区，美国，阿富汗等等都是对于我们没用的信息
删除除了China Standard Time中国时区以外的其他时区
(2）删除多余的语言
路径：计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Nls\Locale 删除除了中文和英文(代码为0409和0804)以外的其他语言
（3）删除多余的键盘布局
计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layouts
删除应用残余 在删除应用后，你的注册表中可能还会存在残留应用的信息
计算机\HKEY_LOCAL_MACHINE\SOFTWARE
计算机\HKEY_CURRENT_USER\SOFTWARE
总结 例如：以上操作可优化注册表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a556242809518d3bdd478f2710967d2/" rel="bookmark">
			点云多平面分割--实操（源码供参考）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 思路源码数据 思路 分割出多个平面，并赋予不同颜色进行显示，将点云坐标与颜色保存为pcd点云。。。
源码 //**************************************************************** // 平面分割 // source /home/robot/catkin_ws/devel/setup.bash &amp;&amp; rosrun chapter10_tutorials plane // //**************************************************************** #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/point_types.h&gt; #include &lt;pcl/kdtree/kdtree.h&gt; //分割类 #include &lt;pcl/sample_consensus/method_types.h&gt; #include &lt;pcl/sample_consensus/model_types.h&gt; #include &lt;pcl/segmentation/sac_segmentation.h&gt; #include &lt;pcl/ModelCoefficients.h&gt; #include &lt;pcl/filters/extract_indices.h&gt; #include &lt;pcl/filters/passthrough.h&gt; //直通滤波器头文件 #include &lt;pcl/visualization/pcl_visualizer.h&gt; #include &lt;boost/thread/thread.hpp&gt; #define DisThre 0.03//平面分割阈值 using namespace std; using PointT = pcl::PointXYZRGB; uint8_t R; uint8_t G; uint8_t B; FILE *fpWrite=fopen("cloud_all.txt","w");//a续写，w清除后写入 pcl::PointCloud&lt;PointT&gt;::Ptr cloud_all(new pcl::PointCloud&lt;PointT&gt;); boost::shared_ptr&lt;pcl::visualization::PCLVisualizer&gt; viewer(new pcl::visualization::PCLVisualizer("planar segment"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a556242809518d3bdd478f2710967d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc8df6d2d5daaa531aaa7f0a9afc1f35/" rel="bookmark">
			Windows取证一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows取证 基础 取证通常作为一个公司的事件响应调查人员或者司法调查的取证人员，通过调查被入侵的机器，将被入侵者的行为轨迹梳理出来，还原整个入侵的过程。对于入侵者而言，了解电子取证，可以更全面的了解到自己能够在系统中留下的痕迹，从而具有针对性的消除痕迹，而对于取证人员来说，电子取证无疑是了解整个入侵过程的关键。电子取证近年来也发展为了一个独立的学科，其中在安全竞赛中，电子取证也作为一部分考察内容，被纳入到杂项的大类中，也有只考察取证的竞赛。下面从技术层面介绍Windows取证的相关知识。
审查日志 windows操作系统事件日志 C:\Windows\System32\winevt\Logs\ *( XP C:\Windows\System32)
应用程序日志 App Event.Evtx(Application.evtx)安全日志 SecEvent.Evtx系统日志 SysEvent.Evtx 事件查看器 日志分析工具 微软官方的日志分析：https://www.cnblogs.com/haoliansheng/p/4040208.html
Logparser.exe –i:EVT –o:DATAGRID "SELECT * FROM c:\11.evtx" LogParser.exe -i:EVT "SELECT TimeGenerated,EventID,EXTRACT_TOKEN(Strings,1,'|') as UserName,EXTRACT_TOKEN(Strings,5,'|') as ProcessName FROM c:\11.evtx where EventID=4688" [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-F89oqjP6-1648259564999)(]
3、管理账号登录
在创建管理账户后，尝试远程登录到目标主机，获取敏感信息。
mstsc /v 10.1.1.188 Windows日志分析：
在本地安全策略中，需开启审核登录事件，关键登录事件和说明，如：
4624 登录成功 4625 登录失败 LogParser.exe -i:EVT "SELECT TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,8,'|') as EventType,EXTRACT_TOKEN(Strings,5,'|') as username,EXTRACT_TOKEN(Strings,18,'|') as Loginip FROM C:\3333.evtx where EventID=4624" 使用LogParser做一下分析，得到系统登录时间，登录类型10 也就是远程登录，登录用户 test，登录IP：10.1.1.1。
4、权限维持
通过创建计划任务执行脚本后门，以便下次直接进入，使用以下命令可以一键实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc8df6d2d5daaa531aaa7f0a9afc1f35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6483f89f63b01d6b3ef5a014e1184fad/" rel="bookmark">
			python蓝桥杯省赛冲刺篇——3真题：答疑、鲁卡斯队列、金币、最大化股票交易的利润、谈判、排座椅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 注意：加了链接！！！1. 答疑题目描述输入描述输出描述输入输出样例示例 详解与代码演示 2. 鲁卡斯队列题目描述详解与代码演示 3. 金币题目描述输入描述输出描述输入输出样例示例1示例2 详解与代码演示 4. 最大化股票交易的利润题目描述输入描述输出描述输入输出样例示例 详解与代码演示 5. 谈判题目描述输入描述输出描述输入输出样例示例1 详解与代码解析 6. 排座椅题目描述输入描述输出描述输入输出样例示例1 详解与代码演示 注意：加了链接！！！ 1. 答疑 链接：https://www.lanqiao.cn/problems/1025/learning/
题目描述 有 n n n 位同学同时找老师答疑。每位同学都预先估计了自己答疑的时间。
老师可以安排答疑的顺序，同学们要依次进入老师办公室答疑。 一位同学答疑的过程如下：
首先进入办公室，编号为 i i i 的同学需要 s i s_i si​毫秒的时间。然后同学问问题老师解答，编号为 i i i 的同学需要 a i a_i ai​毫秒的时间。答疑完成后，同学很高兴，会在课程群里面发一条消息，需要的时间可以忽略。最后同学收拾东西离开办公室，需要 e i e_i ei​毫秒的时间。一般需要 10 10 10 秒、 20 20 20 秒或 30 30 30 秒，即 e i e_i ei​
取值为 10000 10000 10000， 20000 20000 20000 或 30000 30000 30000。 一位同学离开办公室后，紧接着下一位同学就可以进入办公室了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6483f89f63b01d6b3ef5a014e1184fad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b083e92ced79b764b1fdcca485ee35a1/" rel="bookmark">
			QTextEdit使用讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QTextEdit简介 QTextEdit是一种高级的文本查看器、编辑器，可以显示图像，列表和表格。工业上，一般将TextEditu用于显示文本信息的窗口。QTextEdit的父类是QAbstractScrollArea，当文本信息太大是，会自动通过滚动条调整显示界面。
常用Api 设置文本对齐方式，对齐方式有Qt::AlignLeft、Qt::AlignRight、Qt::AlignJustify和Qt::AlignCenter(水平居中)。
void setAlignment() 设置当前字体的格式
void setCurrentFont(const QFont &amp;f)``` 设置字体的大小
void setFontPointSize(qreal s) 设置文本的背景颜色
void setTextBackgroundColor(const QColor &amp;c) 设置字体的颜色
void setTextColor(const QColor &amp;c) 在光标当前位置插入文本
void insertPlainText(const QString &amp;text) 追加文本，它不管光标的位置直接在文本后追加文本（另起一行）
void append(const QString &amp;text) 清除所有文本
void clear() 设置只读模式
void setReadOnly(bool ro) 效果 .h文件
#ifndef WIDGET_H #define WIDGET_H #include &lt;QWidget&gt; namespace Ui { class Widget; } class Widget : public QWidget { Q_OBJECT public: explicit Widget(QWidget *parent = 0); ~Widget(); private slots: void on_btn_append_clicked(); void on_btn_insert_clicked(); void on_btn_clear_clicked(); private: Ui::Widget *ui; }; #endif // WIDGET_H .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b083e92ced79b764b1fdcca485ee35a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ea77ae67955593a4c4d9b9b909b12a2/" rel="bookmark">
			Java程序设计基础——cmd编译运行java文件详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详细步骤 1.打开cmd，进入源文件所在的文件夹2.编译3.运行4.编译运行结果5.安装多个JDK，切换编译文件 1.打开cmd，进入源文件所在的文件夹 方法一：按 Win+R 快捷键，输入cmd，然后进入源代码所在的文件夹（我的源代码目录为D:\Java，进入文件夹输入“cd 文件夹名”，退出当前文件夹输入“cd\”）。
方法二：在源代码目录输入cmd，按Enter键。
2.编译 输入“javac 源文件名.java”命令，按Enter键，开启Java编译器并进行编译，编译结束后,会自动生成一个源文件名.class的字节码文件。
如果出现“错误: 编码 GBK 的不可映射字符 (0x8D)”，需要在“javac”后面加上-encoding UTF-8。
3.运行 输入“java 源文件名”命令，按Enter键，启动Java虚拟机运行程序。Java虚拟机首先将编译好的字节码文件加载到内存,这个过程被称为类加载,它是由类加载器完成的,然后虚拟机针对加载到内存中的Java类进行解释执行,便可看到运行结果。
运行原理：任何程序的运行都离不开计算机的内存。当我们切换到盘符下面执行HelloWorld的时候，会立即在计算机的内存里面创建一个JVM，再把HelloWorld.class这个文件调到JVM中。
过程：Java源文件—&gt;编译器—&gt;字节码文件—&gt;Jvm—&gt;机器码Java程序是由虚拟机负责解释执行的,而并非操作系统。针对不同的操作系统可以编写相同的程序,只需要安装不同版本的虚拟机即可。不同的操作系统需要使用到不同版本的虚拟机。Java程序通过Java虚拟机可以达到跨平台特性,但Java虚拟机并不是跨平台的,也就是说,不同操作系统上的Java虚拟机是不同的。当一个程序从开始运行一个程序，这时虚拟机就开始实例化了。多个程序启动就会存在多个虚拟机实例，程序退出或者关闭，则虚拟机实例消亡。多个虚拟机实例之间数据不能共享。 4.编译运行结果 5.安装多个JDK，切换编译文件 必须要用引号（因为中间有空格，空格后会识别是参数）引入安装的JDK目录下javac.exe程序。
"C:\Program Files\Java\jdk1.8.0_40\bin\javac.exe" -encoding UTF-8 编译文件.java 这时候会发现类文件具有错误的版本,是因为之前用另一个JDK编译过了，此时变了版本，之前生成的.class还是之前版本的，所以有冲突，需要将之前的.class文件全部删除。
删除所有.class文件命令：del *.class,重新编译。
编辑于2022年3月24日
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ae30e44b3d140abf3d3a1f39163621b/" rel="bookmark">
			kubeadm 重置节点后在加入报etcd错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.报错：
在删除节点并kubeadm reset后，执行kubeadm 加入节点时候报错如下错误：
error execution phase check-etcd: etcd cluster is not healthy: failed to dial endpoint https://192.168.123.42:2379 with maintenance client: context deadline exceeded
2.解决办法：
出现这个报错的原因是之前的etcd集群信息没有清理干净。 执行命令，查看etcd节点列表： # kubectl get pod -n kube-system
进入etcd-worker-1容器内部： # kubectl exec -it etcd-worker-1 -n kube-system -- sh
k8s中etcd使用的是v3的api，所以要先声明变量： # export ETCDCTL_API=3
查看当前etcd节点数量： # etcdctl --cacert="/etc/kubernetes/pki/etcd/ca.crt" --cert="/etc/kubernetes/pki/etcd/server.crt" --key="/etc/kubernetes/pki/etcd/server.key" member list
删除报错的节点： # etcdctl --cacert="/etc/kubernetes/pki/etcd/ca.crt" --cert="/etc/kubernetes/pki/etcd/server.crt" --key="/etc/kubernetes/pki/etcd/server.key" member remove e4b7787f9db35781
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09279ebe1d5a4aa7507ea982f08d1e61/" rel="bookmark">
			Nacos使用（二）：Spring Boot集成Nacos配置中心动态配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nacos使用（一）：什么是Nacos
Nacos使用（三）：Spring Cloud集成Nacos配置中心动态配置
使用Nacos之前需要先安装，网上有很多教程，这里略过。
Nacos提供了类似于SpringCloud Config的配置中心功能，可以实现动态配置
动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。
动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。
配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。
Nacos官方也提供了样例程序，但是代码版本比较老，很多新版本特性都没有用到，本教程使用较新的版本，差别还是比较大的。
首先在Nacos管理页面新增配置
test=1155fg #开发配置 server.port=9008 pom.xml
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.12.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.test&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;test&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Nacos 配置中心 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;nacos-config-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 新版本Nacos支持使用注解+配置文件和纯配置文件两种使用方式，推荐使用纯配置文件方式
方式一：注解+配置文件 配置文件application.properties
nacos.config.server-addr=127.0.0.1:8848 #命名空间id nacos.config.namespace=e23e7505-efa0-47be-bc5b-6ce8f3e973bf 项目启动入口App.java
import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.ComponentScan; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09279ebe1d5a4aa7507ea982f08d1e61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e14956eaa2f1ea4ed831b18dc2a26337/" rel="bookmark">
			PIL转tensor 以及 Torch.new()方法使用记录 to_Tensor（）和as_Tensor()的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from PIL import Image import matplotlib.pyplot as plt img_b = Image.new("RGB",(32,32)) plt.imshow(img_b) plt.show() PIL转tensor方法：
先转numpy，再用torch.from_numpy（）； img_b_tensor = torch.from_numpy(np.asarray(img_b)) img_b_tensor.size() Out[36]: torch.Size([32, 32, 3]) 使用torchvision.transforms transs = transforms.ToTensor() img_b_tensor_two = transs(img_b) img_b_tensor_two.size() Out[37]: torch.Size([3, 32, 32]) 注意：
3. ToTensor()函数会制动将图像size变为chw；
4. 查看ToTensor()函数可知，其思路也是转换成numpy。只不过ToTensor中加入了除以255的步骤，对图像进行了归一化。
class ToTensor(object): """Convert a ``PIL Image`` or ``numpy.ndarray`` to tensor. Converts a PIL Image or numpy.ndarray (H x W x C) in the range [0, 255] to a torch.FloatTensor of shape (C x H x W) in the range [0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e14956eaa2f1ea4ed831b18dc2a26337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7b19bd89da477c25f89bb7fa949dca6/" rel="bookmark">
			(转)解决Android Studio模拟器无法联网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一：问题描述
二：原因
三：解决方法
3.1永久修改DNS
3.2命令启动模拟器
四：参考链接
一：问题描述 Google推出了Android Q以后，兴致勃勃的下载了android10的镜像，新建模拟器发现启动速度比以前快了简直不是一星半点，开机嗖嗖的。以前因为Android的模拟器实在是太慢了，都拿自己心爱的手机调试，时间长了，手机会变得特别卡，特别损真机，而且有时候因为真机不能做到运行各个版本的Android系统，尤其是Google新发布的android版本，导致一些bug无法用真机复现。现在终于可以用模拟器调试解决问题了。但是发现模拟器运行，应用无法连接网络，duang duang duang~~ 本来以为这个问题应该很容易解决，结果就去百度，搜出来全是下边的玩意儿！！！都是在胡扯，记录下来希望其他小伙伴不再采坑
看别人写的什么通过下边的adb shell命令就可以联网，全在胡扯！！！我用shell命令根本没有 [net.dns1] 这属性，另外shell命令设置dns也是提示failed（应该是需要root权限，但是我没找到怎么获取root权限，不知道其他小伙伴是否遇到跟我一样的问题）
Shit start-----------------------
adb shell
getprop
会列出系统当前的各项属性，可以看到下面格式的模拟器dns：
[net.dns1]: [10.0.2.3]
[net.dns2]: [10.0.2.4]
通过setprop net.dns1 192.168.1.1
Shit ending-----------------------
下边介绍我亲测的两种办法真实有效！！！
Android Studio新建模拟器，内置浏览器无法通过域名打开百度，但是通过IP可以打开百度。这导致我们调试代码特别不方便，看下图1-1的提示，猜测大致是因为dns的问题，图1-2可以通过ip访问百度印证了这个猜测
图1-1 图1-2 二：原因 查阅资料发现Android模拟器默认的地址是10.0.2.3，默认的DNS也是10.0.2.3。对于在家或者在公司运行Android模拟器来讲，家里的电脑IP都是192.168.1.112之类的，公司电脑IP类似172.30.14.249这样，我们可以通过dos命令ipconfig/all查看电脑的ip，一般情况下电脑和模拟器不在同一个网段，所以就会出现电脑可以上网但是模拟器不能上网的情况。我们只需要把模拟器的DNS和电脑的DNS改成一致，模拟器就可以正常上网了。下面是图2-1，模拟器的DNS和电脑不一致
图2-1 三：解决方法 3.1永久修改DNS 进入模拟器Setting-&gt;Network&amp;Internet-&gt;Wi-Fi-&gt;AndroidWifi-&gt;右上角修改，手动选择IP setting-&gt;static，ip地址和网关还是设置成DHCP动态分配的ip和网关地址(大家可以在Network details查看动态分配的ip，然后记住默认分配的动态ip和网关，如下图3-1)，我们只需要修改模拟器的dns，改为和电脑的dns一致就可以了，我这边dns和pc保持一致，改为了223.5.5.5、223.6.6.6。大家按照自己pc的dns设置保存，然后就可以愉快的联网了，如图3-2，你懂的！
图3-1 图3-2 3.2命令启动模拟器 1.找到你的模拟器名字，默认在C:\users\xx\.android\avd目录下，如图3-3。如果找不到可以在Android Studio-&gt;AVD Manager-&gt;show on disk定位到此目录如图3-4
​​​​图3-3​​​ 图3-4​ 2.找到SDK的emulator目录，目录如图3-5
图3-5 3.在dos命令窗口切换到SDK的emulator目录下运行命令，模拟器名字要对应上自己的模拟器名字，我的模拟器名字是Pixel_API_29
emulator -avd Pixel_API_29 -dns-server 8.8.8.8,114.114.114.114 回车之后，系统会帮你启动你电脑中名叫Pixel_API_29的模拟器，此时模拟器便可以上网了。这种方式最简单粗暴，但也最麻烦，因为这只是一次性的，如果下次不输入这行命令，模拟器还是不能上网，所以每次启动前都要输入这行命令。
四：参考链接 解决AndroidStudio 模拟器无网络连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb9a52e2c38473418123d4d71fc59555/" rel="bookmark">
			vs-code插件 -- Preview on Web Server 插件 使用 及设置默认浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Preview on Web Server 插件 作用 此扩展提供在web服务器上执行的HTML预览。保存文件时，此扩展会自动重新加载浏览器或侧面板（实时预览功能）。您可以从上下文菜单或编辑器菜单调用这些功能。
主要特点如下:
侧面板预览（ctrl+shift+v）：打开侧面板上的HTML预览。使用此功能，您可以轻松地检查HTML、CSS和JavaScript的操作。
在浏览器上启动（ctrl+shift+l）：在默认浏览器上打开网页。您可以通过网页检查所有操作。
停止web服务器（ctrl+shift+s）：停止web服务器。此功能只能从命令选项板使用。
恢复web服务器（ctrl+shift+r）：恢复web服务器。此功能只能从命令选项板使用。
显示UI页面（ctrl+shift+u）：显示UI页面。您可以在UI页面更改选项。
Preview on Web Server 插件用法 安装好之后 就可以 使用了（ps：安装完插件 重新 启动 vd-code）
1. 鼠标 左键 找到 vscode-preview-server:Preview on side panel 或者 快捷键 Ctril+Shift+v
效果图：
Preview on Web Server 插件 设置 浏览器 一、 系统 自带的设置 方案一：
设置 给电脑设置默认 浏览器 win10 为例子(其他系统自行百度)
设置(1)-应用(2)-默认应用(3)-web浏览器(4)
(1).设置
点击 左下角 图标 -设置
(2)应用 (2)默认应用
方案二：
直接搜索 默认应用 然后 后面和上面一样
二、插件 里设置 方案一：
用插件自带的设置 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb9a52e2c38473418123d4d71fc59555/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67170a90d0baca12986dd055a1e075af/" rel="bookmark">
			DDR功能点 ODT ZQ校准
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ODT 也是 DDR2 相对于 DDR1 的关键技术突破，所谓的终结（端接），就是让信号被电路的终端吸收掉，而不会在电路上形成反射， 造成对后面信号的影响。 顾名思义， ODT 就是将端接电阻移植到了芯片内部，主板上不再有端接电路。在进入DDR 时代， DDR 内存对工作环境提出更高的要求，如果先前发出的信号不能被电路终端完全吸收掉而在电路上形成反射现象， 就会对后面信号的影响造成运算出错。因此目前支持DDR主板都是通过采用终结电阻来解决这个问题。 由于每根数据线至少需要一个终结电阻， 这意味着每块DDR 主板需要大量的终结电阻， 这也无形中增加了主板的生产成本 ,而且由于不同的内存模组对终结电阻的要求不可能完全一样，也造成了所谓的“内存兼容性问题”。而在DDR-II 中加入了 ODT功能，当在DRAM 模组工作时把终结电阻器关掉， 而对于不工作的 DRAM 模组则进行终结操作，起到减少信号反射的作用，如下图二所示。ODT 的功能与禁止由主控芯片控制，在开机进行 EMRS 时进行设置， ODT 所终结的信号包括 DQS 、DQS# 、DQ 、DM 等。这样可以产生更干净的信号品质，从而产生更高的内存时钟频率速度。而将终结电阻设计在内存芯片之上还可以简化主板的设计，降低了主板的成本， 而且终结电阻器可以和内存颗粒的“特性”相符， 从而减少内存与主板的兼容问题的出现。
ZQ 校准
如下图三所示， ZQ 是DDR3一个新增的引脚，在这个引脚上接有一个 240 欧姆的低公差参考电阻。
这个引脚通过一个命令集，通过片上校准引擎（ ODCE ，On-DieCalibrationEngine ）来自动校
验数据输出驱动器导通电阻与 ODT 的终结电阻值。 当系统发出这一指令之后， 将用相应的时
钟周期 （在加电与初始化之后用 512 个时钟周期，在退出自刷新操作后用 256 时钟周期、在
其他情况下用 64个时钟周期）对导通电阻和 ODT 电阻进行重新校准。
ODT是终端匹配，那就是要在你的信号线终端上拉一个电阻，但是这个内部电阻随着温度会
有些细微的变化，为了保证信号被准确的进行终端匹配，就需要ZQ了，ZQ的作用就是使用你外面
连接的，高精度240R电阻来对这个内部的电阻进行校准，
外驱动调校 OCD （ Off-ChipDriver ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67170a90d0baca12986dd055a1e075af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90f2679f84089ce8076fcca339e822fe/" rel="bookmark">
			python之字符串替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一：
""" str.replace(old, new[, max]) old -- 将被替换的子字符串。 new -- 新字符串，用于替换old子字符串。 max -- 可选字符串, 替换不超过 max 次 """ temp_str = 'this is a test' print(temp_str.replace(temp_str[2],'aa')) print(temp_str.replace(temp_str[:2],'aa')) &gt;&gt;&gt; thaas aas a test aais is a test 方式二：
在字符串中替换自己想要的字符串
# -*- coding=utf-8 -*- s = "{a}bc" s=s.format(a="123") print(s) &gt;&gt;&gt;123bc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd85d5147721d95599e83575a994ff3e/" rel="bookmark">
			安装pytorch3d
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 不知道为啥，按照官网的步骤一步一步来安装不上。
在问答区找到了一个比较靠谱的：
conda create --name quick_test_env python=3.8 conda activate quick_test_env conda install numpy pillow matplotlib conda install -c conda-forge opencv conda install pytorch=1.10.0 torchvision torchaudio cudatoolkit=11.3 -c pytorch -c conda-forge conda install -c fvcore -c iopath -c conda-forge fvcore iopath conda install -c pytorch3d pytorch3d 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6719e88c9dd427154445557e7851c18/" rel="bookmark">
			ARMA模型的平稳性判别（续）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.特征根判别法
AR(p)模型对应齐次方程特征根与回归系数多项式根的关系：
2.平稳域判别
（1）AR(1)(一阶)模型平稳域
（2）AR(2)(二阶)模型平稳域
3.举例
4.函数展开成幂级数——麦克劳林级数
小结
1.特征根判别法 AR模型可以看作非齐次差分方程，它的解不妨记作
平稳条件：|| &lt; 1
AR模型平稳 &lt;——&gt; 特征根都在单位圆内 AR(p)模型对应齐次方程特征根与回归系数多项式根的关系： 中心化AR(p)模型：
对应齐次方程的特征方程：
自回归系数多项式：
我们令 得：
令上式等于 0 ，可知，根为倒数关系。
2.平稳域判别 AR(p)模型
平稳 &lt;——&gt; { | 特征根都在单位圆内}
对于低阶自回归模型通常更为简便。
（1）AR(1)(一阶)模型平稳域 模型：
特征方程：
特征根：
（2）AR(2)(二阶)模型平稳域 模型：
特征方程：
特征根：
平稳域：
平稳域的条件有：
由上述条件我们可以推导如下：
再把上述平稳域可视化，如下
3.举例 例子仍为上篇文章中的例子：传送门 在上一篇文章，我们用R通过绘图，知道了它们是否为平稳性，接下来我们通过特征根和平稳域来判别一下它们的平稳性
第一个：一阶平稳
特征根判别：
因为 - 0.8 = 0 ，所以得到 = 0.8 。又因为|| &lt; 1，所以 平稳。
平稳域判别：
可知，，因为 ，所以平稳
第二个：一阶非平稳
特征根判别：
因为 - (-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6719e88c9dd427154445557e7851c18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9081f17ea1ca93e7c5616e66cacacce9/" rel="bookmark">
			在Linux下安装软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下软件包分类：
1..rpm -----相当于windows下的exe（点击即可安装）
2..tar.gz或.tar.bz -----相当于windows下的绿色软件，直接可以使用（编辑安装）
.rpm：
（1）查询当前系统有没有安装
精确查询 rpm -qa | grep +（名称） -----grep（过滤）
（2）查询软件包的版本（详细信息）
查询已安装的软件包：
rpm -qa vim（信息包括Name，Version,Release,Install Data,Size,URL---来源）
查询软件安装目录：/etc-----配置文件 /usr/bin------程序的启动 /usr/share/man------用户手册
/var/lib/mysql------数据库文件 /var/log/mariadb/mariadb.log------日志目录
/var/run/mariadb-----进程文件
查询未安装的软件包：
rpm -qpi +软件包的名字
rpm -qpl +软件包的名字
（3）安装
rpm -i +软件包名字
（4）卸载
rpm -e +软件包名字
umount（卸载）/dev/sr0
mount（挂载）----把光驱或其他设备和Liunx的目录绑定在一起
/dev ----存放所有的硬件设备
mount /dev/sr0 /mnt
查询挂在 df
rpm -evh(+vh显示卸载进度)
依赖关系解决方法：
1.忽略依赖关系：--nodeps
2.今天不讲
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/118a8baca13609e5fd2b10c40f87bdfe/" rel="bookmark">
			前端常用插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端插件 常用图形插件 常用图形插件 脑图插件
html转化为图片或pdf文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c8ac05054f389dabd3195e87963f277/" rel="bookmark">
			ping网络丢包的故障原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络丢包是我们在使用ping对目站进行询问时，数据包由于各种原因在信道中丢失的现象。ping使用了ICMP回送请求与回送回答报文。ICMP回送请求报文是主机或路由器向一个特定的目的主机发出的询问，收到此报文的机器必须给源主机发送ICMP回送回答报文。这种询问报文用来测试目的站是否可到达以及了解其状态。需要指出的是，ping是直接使用网络层ICMP的一个例子，它没有通过运输层的UDP或TCP。
网络丢包的原因主要有物理线路故障、设备故障、病毒攻击、路由信息错误等，下面我们结合具体情况进行说明。
一、物理线路故障
广域网线路时通时断，发生这种情况时，有可能是线路出现故障，也可能是用户方面的原因。为了分清是否是线路故障，可以做如下测试。
如果广域网线路是通过路由器实现的，可以登录到路由器，通过扩展ping向对端路由器广域网接口发送大量的数据包进行测试。
如果线路是通过三层交换机实现，可在线路两端分别接一台计算机，并将IP地址分别设为本端三层路由交换机的广域网接口地址，使用“ping 对端计算机地址 -t”命令进行测试。
如果上述测试没有发生丢包现象，则说明线路运营商提供的线路是好的，引起故障的原因在于用户自身，需要进一步查找。
如果上述测试发生丢包现象，则说明故障是由线路供应商提供的线路引起的，需要与线路供应商联系尽快解决问题。
由物理线路引起的丢包现象还有很多，如光纤连接问题，跳线没有对准设备接口，双绞线及RJ-45接头有问题等。另外，通信线路受到随机噪声或者突发噪声造成的数据报错误，射频信号的干扰和信号的衰减等都可能造成数据包的丢失。我们可以借助网络测试仪来检查线路的质量。
二、网络拥塞
网络拥塞造成丢包率上升的原因很多，主要是路由器资源被大量占用造成的。
如果发现网速慢，并且丢包率呈现上升的情况，这时应该路由器流量表，一般情况下发现流量跑满占用过多的资源。接下来可以适当的调整限速规则对网络进行优化。
接下来查看是否有大量包进出的端口。一旦确认进入端口后，如果是攻击，源地址会不断变化但是目的地址不变，此时应通知相关网络人员处理，最终解决办法是停止攻击源。
应用中遇到的造成网络拥塞的情况还有很多，如大量的UDP流量、大量的组播流、广播包穿越路由器，路由器配置了IP NAT并且有很多DNS包穿越路由器等。上述情况造成网络拥塞后，通信双方采取流量控制，丢弃不能传输的包。
三、路由错误
网络路径错误也会导致数据包不能到达目的主机，如主机的默认路由配置错误，主机发出的访问其他网络的数据包会被网关丢弃。但此类丢包属于正常情况下的丢包，是意料之中的，不会对网络造成影响。此类情况一般的家庭和小型办公环境基本是不会遇到的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0da2d8bbf2d305e78d966234428cc645/" rel="bookmark">
			C&#43;&#43; string类 使用方法（各种常用函数的介绍）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零、前情提要 在 C 中，字符与数组拥有同类的使用方法，操作直观，浅显易懂，之前的两篇扫盲贴有做简要分析：
1、字符串基础1：字符数组介绍
2、字符串基础2：常用的字符串函数介绍
一、string 类简介 string 类是 C++ 中对于字符串处理封装的类，可以理解为，一串字符就是一个整体，内部是一个类似数组的容器，并且自带丰富的功能函数。
对于字符与字符串的模拟与各种操作的题目，在各类OI基础赛事中层出不穷。
掌握基础的字符串函数和各类读入、修改、输出等奇奇怪怪的操作技巧非常有必要。灵活性和便利性远远超过 C 中的 字符数组，请结合以下的简介，多加练习以熟练食用。
二、函数简介大纲 三、常用函数的功能介绍 3.0 几个关键字符 字符串变量名：s、x
位置变量名：pos、px
长度变量名：lens、lenx
3.1 基础功能函数 序号功能代码样例效果介绍1定义string s;定义一个串，名字为 s2初始化1string s(x);定义一个名字为 s 的串，获得 x 串的内容3初始化2string s(x,px,dx);定义 s 串，获得 x 串从 px 位起的 dx 个字符5输入1cin&gt;&gt;s;读入 s 串（以空格或换行结束）6输入2getline(s);读入 s 串（以换行结束）7输入3istringstream is(input); is&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4;将一个句子读入流中， 将流中的串拆分成多个单词，存入不同的串中8赋值1s=x; // s.assign(x);将 x 串的值赋给 s 串9赋值2s.assign(x,px,dx);将 x 串从 px 位起的 dx 个字符赋值给 s 串11求长度s.size(); // s.length();返回 s 串的元素个数12输出1cout&lt;&lt;s;输出整个 s 串13输出2cout&lt;&lt;s[pos];输出 s 串中，下标为 pos 的字符 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0da2d8bbf2d305e78d966234428cc645/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62ffb18bf7c411e21b78be4fc25c2806/" rel="bookmark">
			Spring Boot 3的新特性 - jrebel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot 3是期待已久的Spring Boot 2版本的后续版本，它目前是Spring Boot 3.0.0-M1的M1版本，Spring Boot 3.0.0-M2计划于3月24日交付。
其中 M 表示里程碑版本，RC 表示候选发布版本，SNAPSHOT 表示构建。
在向公众发布之前，M2 版本通常会跟随一到两个候选版本。
Spring Boot 1 于 2014 年发布，Spring Boot 2 于 2018 年发布，Spring Boot 3 计划于 2022 年发布。
Spring Boot 3 特性
Spring Boot 3 的特性，至少从 3.0.0-M1 版本的变更日志来看，与 Spring Boot 2.x 版本相比在很大程度上保持不变。
主要变化是围绕 Java 版本（以及 Gradle 用户的 Gradle 版本）、Spring Framework 版本、Jakarta EE 版本以及由此产生的依赖项升级和弃用。
Spring Boot 3 最大的变化是决定使用 Java 17 作为最低版本。要求 Java 17 和更新版本是一个重大举措，Spring 将成为第一个需要此最新 LTS 版本的主要框架。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62ffb18bf7c411e21b78be4fc25c2806/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de3bf94dea53af34bd651b3ae47d2dff/" rel="bookmark">
			sql注入及mybatis防止sql注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Sql 注入漏洞详解 Sql 注入产生原因及威胁： 当我们访问动态网页时, Web 服务器会向数据访问层发起 Sql 查询请求，如果权限验证通过就会执行 Sql 语句。这种网站内部直接发送的Sql请求一般不会有危险，但实际情况是很多时候需要结合用户的输入数据动态构造 Sql 语句，如果用户输入的数据被构造成恶意 Sql 代码，Web 应用又未对动态构造的 Sql 语句使用的参数进行审查，则会带来意想不到的危险。
Sql 注入带来的威胁主要有如下几点
猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息。绕过认证，列如绕过验证登录网站后台。注入可以借助数据库的存储过程进行提权等操作 Sql 注入示例一.猜解数据库 接下来我们通过一个实例，让你更加清楚的理解 Sql 注入猜解数据库是如何发生的。使用DVWA渗透测试平台，作为攻击测试的目标：
先输入 1 ，查看回显 (URL中ID=1，说明php页面通过get方法传递参数)：
那实际上后台执行了什么样的Sql语句呢？ ，其中的SQL查询代码为：
可以看到，实际执行的Sql语句是：
SELECT first_name, last_name FROM users WHERE user_id = '1'; 我们是通过控制参数Id的值来返回我们需要的信息。
如果我们不按常理出牌，比如在输入框中输入 1' order by 1#
实际执行的Sql语句就会变成:
SELECT first_name, last_name FROM users WHERE user_id = '1' order by 1#`;(按照Mysql语法，#后面会被注释掉，使用这种方法屏蔽掉后面的单引号，避免语法错误) 这条语句的意思是查询users表中user_id为1的数据并按第一字段排行。
输入 1’ order by 1#和 1’ order by 2#时都返回正常：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de3bf94dea53af34bd651b3ae47d2dff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05423c12dadea0bbb08187da85903bba/" rel="bookmark">
			Python零基础入门之第二章 Python数据结构（一.列表 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第二章 Python数据结构（一.列表） 关于责任，想分享《慢慢变富》中的一句话，“身居高位的人需要对方方面面负责”，有了承担对应的责任，才可以抬头挺胸的坐上对应的位置。
总目录简介 一 、列表（当前位置）
二、元组
三、字典
四、集合
五、字符串
六、序列篇总结
Python中，序列是最基本的数据结构，是一块用于存放多个值的连续空间，Python中内置了列表、元组、字典、集合5个常用的序列结构。
各种序列的命名要符合Python命名规则的标识符。
虽然可以将不同类型的数据放在同一个列表当中，但是通常情况下，为了增加程序的可读性，会在它们里面只放入同一种类型的数据。
一、列表（list） 存储内容：可以将整数、浮点数、字符串、列表、元组等任何数据类型放入到列表中。列表中的元素类型可以不同，因为他们之间没有任何联系。
特点：列表的元素是可修改，元素可重复，元素是有顺序的。
格式：[ ]包住，用‘，’间隔内部元素。
[num1,num2,num3,...,numn] 1.创建
mylist1 = [1,2,3,4] mylist2 = ['one','two','three','four'] mylist3 = ['List',6.66,['a','b'],'中文']#为了保证程序的可读性，一般不会这样子做 print(mylist1) print(mylist2) print(mylist3) 1.2 创建空列表
mylist4 = []	#空列表 print(mylist4) 1.3 创建数值列表
在这里插入代码片 2.删除
使用del语句
mylist = ['铅笔','钢笔','油画棒'] #创建一个列表 del mylist #删除列表mylist print(mylist)	#打印时无输出 # 知识点插入：列表的索引
列表中每个元素都有自己对应的序号，代表元素在列表中的位置，这个位置就是列表的索引。
(1)使用索引号访问列表元素：
索引序号从0开始，0表示第一个元素，1表示第二个元素，以此类推。以mylist=[‘L’,‘I’,‘S’,‘T’]这个列表举例，列表索引图如下所示。
(2)负数索引:
列表也是有负数索引的，索引的序号从-1开始；-1是最后一个元素的索引号，-2是倒数第二个元素的索引号，以此类推。以mylist=[‘L’,‘I’,‘S’,‘T’]这个列表举例，列表索引图如下所示。
3.访问列表元素
3.1访问整个列表
mylist=['L','I','S','T'] print(mylist) 3.2访问特定位置的列表元素
通过列表的索引获取指定的元素
mylist=['L','I','S','T'] print(mylist[3]) 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05423c12dadea0bbb08187da85903bba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a44256a0fdd102d64eb80766f55b9e/" rel="bookmark">
			语义分割损失函数系列(2):IoU损失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交叉熵损失函数好用是好用，但当数据存在严重的不平衡问题的时候，会导致结果特别糟糕，特别是在医学图像分割问题中，一般目标区域都比较小，背景区域比较大，此时用交叉熵损失函数的话得到的结果就不太好。
IOU loss介绍 IOU即是交并比，用相交的部分去除上并集，就得到IOU的值，1-IOU的值就是IOU Loss。至于IOU的数学定义去看百度百科吧，举个例子：
上面两张图求IOU，白色区域为目标区域，就是用两张图片的白色区域的交集去比上白色部分的并集，就得到了白色类别的IOU值。在实际工程中，一般黑色像素为类别0，白色为类别1。可以使用代码轻松的求出IOU值。
Pytorch代码 import numpy import torch import torch.nn as nn import torch.nn.functional as F class IoULoss(nn.Module): def __init__(self, weight=None, size_average=True): super(IoULoss, self).__init__() def forward(self, inputs, targets, smooth=1): #comment out if your model contains a sigmoid or equivalent activation layer inputs = F.sigmoid(inputs) #flatten label and prediction tensors inputs = inputs.view(-1) targets = targets.view(-1) #intersection is equivalent to True Positive count #union is the mutually inclusive area of all labels &amp; predictions intersection = (inputs * targets).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5a44256a0fdd102d64eb80766f55b9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/565fac179b39b0752b27d254017e496f/" rel="bookmark">
			无法获得下列许可solidworks standard无效的(不一致的)使用许可号码(-8,544,0) 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将_SolidSQUAD_的Program Files里的所有文件夹覆盖到安装目录下，如果是默认安装，就是复制到C:\Program Files\SOLIDWORKS Corp下（而不是C:\Program Files下）
-----------------------------------------------------------------------------------------------------------
安装流程 （2020版本）：
1. 断网并关闭杀毒软件
2. 将_SolidSQUAD_\SolidWorks_Flexnet_Server文件夹拷贝到C:\SolidWorks_Flexnet_Server (不一定要在哪个位置，但是会新建立一个windows的服务指向这个文件夹，所以不能放在会不小心删除的位置)
3. 以管理员身份运行C盘的“solidworks_flexnet_server\server_remove.bat”
4、运行”_solidsquad_“下的注册表文件” sw2020_network_serials_licensing.reg”，并确认添加信息;
5、接着以管理员身份运行C盘的”solidworks_flexnet_server \ server_install.bat”，然后等待直到新服务，将安装并启动“ solidworks flexnet服务器”;
6、运行主程序setup.exe安装，点击下一步;
无法连接网络=&gt; 取消（本来就是在断网的情况下安装的）。
摘要=&gt; 我接受solidworks条款=&gt;现在安装
端口服务器=&gt;确定
参加solidworks客户经历改进计划=&gt; 不谢谢
7. 安装完成后 将_SolidSQUAD_的Program Files里的档案覆盖到安装目录下，如果是默认安装，就是复制到C:\Program Files\SOLIDWORKS Corp下（而不是C:\Program Files下）
不然会导致： 无法获得下列许可solidworks standard无效的(不一致的)使用许可号码(-8,544,0) ，至于_SolidSQUAD_的Program Files（x86）好像不需要也行
8. 点击_SolidSQUAD_的SolidSQUADLoaderEnabler.reg
9. 检查solidworks_flexnet_server的服务是否为自动启动，如果不是的话改成自动启动
10. 重启电脑
错误处理:
可执行文件 "D:\TMP\SolidWorks 2020\SolidWorks 2020\SolidWorks 2020\PreReqs\VCRedist15\vc_redist.x86.exe" /install /quiet /norestart
未成功安装=&gt; 点击报错的档案, 出现错误信息, 显示已经安装了其他版本, 卸载掉所有visual 的软件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad48faa2cfbdfee2b923d7af159a678c/" rel="bookmark">
			opencv--视频操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		opencv--视频操作 1 视频读写1.1 从文件中读取视频并播放1.2 保存视频 2 视频追踪2.1 meanshift2.1.1 meanshift原理2.1.1 meanshift实现 2.2 Camshift2.3算法总结 1 视频读写 1.1 从文件中读取视频并播放 在OpenCV中我们要获取一个视频，需要创建一个VideoCapture对象，指定你要读取的视频文件：
创建读取视频的对象 cap = cv.VideoCapture(filepath) 参数：
filepath: 视频文件路径 视频的属性信息
获取视频的某些属性，retval = cap.get(propId)
参数： propId: 从0到18的数字，每个数字表示视频的属性。常用属性有：
修改视频的属性信息，cap.set(propId，value)
参数： proid: 属性的索引，与上面的表格相对应value: 修改后的属性值 判断图像是否读取成功，isornot = cap.isOpened()
若读取成功则返回true，否则返回False获取视频的一帧图像,ret, frame = cap.read()
参数： ret: 若获取成功返回True，获取失败，返回FalseFrame: 获取到的某一帧的图像 调用cv.imshow()显示图像，在显示图像时使用cv.waitkey()设置适当的持续时间，如果太低视频会播放的非常快，如果太高就会播放的非常慢，通常情况下我们设置25ms就可以了。最后，调用cap.realease()将视频释放掉 import numpy as np import cv2 as cv # 1.获取视频对象 cap = cv.VideoCapture('DOG.wmv') # 2.判断是否读取成功 while(cap.isOpened()): # 3.获取每一帧图像 ret, frame = cap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad48faa2cfbdfee2b923d7af159a678c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f831a83e3313ebb3cf5a43fa7d6ab270/" rel="bookmark">
			OpenCV之轮廓提取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hsv = cv2.cvtColor(rgb_image, cv2.COLOR_BGR2HSV) 然后利用cv2.inRange函数设阈值，去除背景部分 mask = cv2.inRange(hsv, lower_red, upper_red) 函数很简单，参数有三个 第一个参数：hsv指的是原图
第二个参数：lower_red指的是图像中低于这个lower_red的值，图像值变为0
第三个参数：upper_red指的是图像中高于这个upper_red的值，图像值变为0 而在lower_red～upper_red之间的值变成255
import cv2 img = cv2.imread(r"C:\Users\Curry\Desktop\flower.png") hsv = cv2.cvtColor(img, code=cv2.COLOR_BGR2HSV) lower_red = (156, 60, 60) upper_red = (180, 255, 255) mask = cv2.inRange(hsv,lower_red,upper_red) res = cv2.bitwise_and(img,img,mask=mask) # cv2.imshow('flower', mask) cv2.imshow('flower', res) cv2.waitKey(0) cv2.destroyAllWindows() 原图： mask:
2.手工绘制轮廓 cv2.fillPoly()函数可以用来填充任意形状的图型.可以用来绘制多边形,工作中也经常使用非常多个边来近似的画一条曲线；cv2.fillPoly()函数可以一次填充多个图型 import cv2 img = cv2.imread(r"C:\Users\Curry\Desktop\flower.png") hsv = cv2.cvtColor(img, code=cv2.COLOR_BGR2HSV) h,w,c = img.shape mask = np.zeros((h, w), dtype=np.uint8) x_data = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f831a83e3313ebb3cf5a43fa7d6ab270/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b23041a4ceb341374a9ef8fc1bcefc8/" rel="bookmark">
			OpenCV人脸检测之狗头替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import cv2 img = cv2.imread(r'C:\Users\Curry\Desktop\NBA.png') gray = cv2.cvtColor(img, code=cv2.COLOR_BGR2GRAY) path = r"C:/Users/Curry/Desktop/cascades/haarcascade_frontalface_default.xml" face_dector = cv2.CascadeClassifier(path) faces = face_dector.detectMultiScale(gray) goutou = cv2.imread(r"C:\Users\Curry\Desktop\goutou.png") for x, y, w, h in faces: goutou_2 = cv2.resize(goutou, (w, h)) img[y:y+h, x:x+w] = goutou_2 cv2.imshow('goutou', img) cv2.waitKey(0) cv2.destroyAllWindows() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27334d99842c26f2c16ebbda76ac6aeb/" rel="bookmark">
			jQuery&#43;css&#43;html淘宝购物车模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意给checkbox添加事件就是用change()
给button添加事件就是用click（）
1、每次点击+号，根据文本框的值乘以当前商品的价格就是商品的小计
2、只能增加本商品的小计，就是当前商品的小计模块
3、修改普通元素的内容是text方法
4、当前商品的价格要把￥符号去掉再相乘 截取字符串substr（）
5、parents（‘选择器’）可以返回指定祖先元素4
6、最后计算的结果如果想要保留两位小数通过toFixed(2)方法
7、用户也可以直接修改表单里面的值，同样要计算小计，用表单change事件
8、用最新的表单内容的值乘以单价即可，但还是当前商品的小计
计算总计和总额：
思路：把所有文本框里面的值相加就是总计数量，总额同理
文本框里面的值不相同，如果想要相加就需要用到each的遍历，声明一个变量，相加即可
点击+号或者-号，都会改变总计和总额，如果用户修改了文本框里面的值也会改变总额，那么都要分别添加到这三个事件中，因此封装一个函数来求总额和总计，以上几个操作调用即可
注意：总计是文本框中的值相加val（）。总额是普通元素的内容text（）
注意普通元素里面的内容要去掉￥并且转为数字型后才能相加
删除商品模块：
1、把商品remove（）删除元素即可
2、三个地方需要删除：1、商品后面的删除按钮2、删除选中的商品3、清理购物车
1、商品后面的删除按钮：一定是删除当前的商品，所以从$(this)出发
2、删除选中的商品：先判断小的复选框按钮是否选中状态，如果选中，则删除对应的商品
可以不用遍历，$('element:checked')可以直接拿出被选中的复选框
选中商品添加背景色
核心：选中的商品添加背景，不选中的商品移除背景即可
1、全选按钮点击：如果全选是选中的，则所有的商品添加背景，否则移除背景
2、小的复选框点击：如果是选中状态，则当前商品添加背景，否则移除背景
3、这个背景，可以通过类进行修改，添加类和移除类
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img { width: 80px; height: 80px } a { color: black; text-decoration: none; } .mony { width: 20px; text-align: center; } &lt;/style&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;全部商品&lt;/div&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27334d99842c26f2c16ebbda76ac6aeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f563dad8194c2ae21ec86ea24e38645/" rel="bookmark">
			SpringBoot&#43;Redis实现接口限流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.redis接口限流注解 定义一个注解标明需要使用限流的接口
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface AccessLimit { /** * @return 单位时间（秒） */ int seconds(); /** * @return 单位时间最大请求次数 */ int maxCount(); } 2.配置拦截器 在springboot的拦截器中，如果你没有配置拦截器，需要自定义类继承HandlerInterceptor，
@Log4j2 public class WebSecurityHandler implements HandlerInterceptor { @Autowired private RedisService redisService; @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception { //如果请求输入方法 if (handler instanceof HandlerMethod) { HandlerMethod hm = (HandlerMethod) handler; //获取方法中的注解,看是否有该注解 AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit.class); if (accessLimit != null) { long seconds = accessLimit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f563dad8194c2ae21ec86ea24e38645/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e72654fc700c7402c4fe819a039ee84/" rel="bookmark">
			网络（一）：物理层、数据链路层、网络层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络（一）：物理层、数据链路层、网络层 物理层(集线器)Q：接收方怎么知道这数据包是发给自己的？ 数据链路层(交换器)Q：MAC地址表如何中的数据是怎么来的？如何维护?Q：交换器端口连接的是另一个交换器MAC地址表如何存储？ 网络层(路由器)Q：怎么判断电脑在同一个以太网内？Q：为什么引入一个带有MAC地址的设备后，能让MAC地址表更容易维护？ 补充MAC地址 参考 物理层(集线器) 当我们试图建立两台电脑直接的连接时，可以用一根网线将他连接起来，只需每台电脑上各有一个网口，三台电脑互相连接，需要每台电脑上各有两个网口，随着需要连接的电脑的数量的增加，一台电脑上的网口数量也随之增加，这个时候我们需要一个更好的方式来替代这种方式 ———— 集线器
作用：将电信号不做任何处理转发给其它电脑(广播)。
物理层：因为集线器对电信号不做任何处理，所以定义为物理层。
Q：接收方怎么知道这数据包是发给自己的？ 数据包结构图
发送方发送的数据包中会携带自己的MAC地址与接收方的MAC地址，将该数据包广播出去后，接收方通过对数据包头部中的目标MAC地址进行判断，属于自己的则接收，不属于自己的则丢弃。
数据链路层(交换器) 因为广播这种方式，既不安全，又浪费网络资源，所以我们需要一个更加智能的设备 ———— 交换器。由于其相对于交换器比较智能，我们将它划分到 “数据链路层” 。
从图中我们可以看到，交换机维护有一张MAC地址表(映射MAC地址和它的端口)。
作用：交换机接收发送方发来的数据包后，通过与自身维护的MAC地址表比较，找到与目标MAC地址映射的端口，通过该端口将数据包发给接收方。通过上述传输方式组成的小范围网络叫做：“以太网”。
Q：MAC地址表如何中的数据是怎么来的？如何维护? 通过以太网内各节点之间不断通过交换机通信，不断完善起来的。
发送方发送数据包给交换器：发送方将数据包发送给交换器，若交换器维护的MAC地址表中，找不到发送方的MAC地址映射，则将该地址加入MAC地址进行维护。交换器转发数据包给接收方：交换器中维护有接收方MAC地址，则直接转发；未维护接收方MAC地址，则将数据包广播出去，目标电脑接收到数据包后，做出响应，MAC地址表更新一条记录。 Q：交换器端口连接的是另一个交换器MAC地址表如何存储？ 左边交换器
MAC地址端口bb-bb-bb-bb-bb-bb1cc-cc-cc-cc-cc-cc3aa-aa-aa-aa-aa-aa4dd-dd-dd-dd-dd-dd5ee-ee-ee-ee-ee-ee6ff-ff-ff-ff-ff-ff6gg-gg-gg-gg-gg-gg6hh-hh-hh-hh-hh-hh6 结论：会将另一交换机所连接的电脑MAC地址全部维护进MAC地址表中
网络层(路由器) 随着连接的电脑数量的不断增加，交换机将变得难以无法维护，我们需要接入一个带有MAC地址的设备，同时还能对数据包进行一次转发————路由器。
注意：路由器每一个端口都有一个MAC地址
从图中我们可以看出，在同一个以太网内的电脑不需要路由器进行转发；在不同以太网内的电脑需要通过路由器进行转发。
Q：怎么判断电脑在同一个以太网内？ 方法：赋予给每个以太网一个独有的标志(子网)，用于判断。
目前为止，我们用于判断发送方与接收方的唯一标识是MAC地址，假设，我们将MAC地址的一部分(前24位)作为该标志，但是我们知道MAC地址是在出厂时就固定了的，也就意味着，我们需要针对不同的以太网购置不同厂商的设备，且不说厂商是否有这么多家，而且日后这个网络的结构都不能轻易改变。
因此需要发明一个新的地址信息 “ip地址” 。 “ip地址” 是在软件层面上的地址信息，所以这是可以被我们控制的。我们通过子网掩码，对ip地址进行计算，得到子网。
总结
通过发送方电脑上设置的子网掩码，对发送方ip地址与接收方ip地址进行计算，如果相同，则不需要通过路由器进行转发；不同，则需要通过路由器进行转发。
Q：为什么引入一个带有MAC地址的设备后，能让MAC地址表更容易维护？ 引入路由器之前
MAC地址端口bb-bb-bb-bb-bb-bb1cc-cc-cc-cc-cc-cc3aa-aa-aa-aa-aa-aa4dd-dd-dd-dd-dd-dd5ee-ee-ee-ee-ee-ee6ff-ff-ff-ff-ff-ff6gg-gg-gg-gg-gg-gg6hh-hh-hh-hh-hh-hh6 引入入路由器之后
MAC地址端口bb-bb-bb-bb-bb-bb1cc-cc-cc-cc-cc-cc3aa-aa-aa-aa-aa-aa4dd-dd-dd-dd-dd-dd5ef-gh-ef-gh-ef-gh6 可以看到未引入路由器之前，MAC地址表需要另一台交换器上的所有电脑MAC地址，而引入之后，则只需要维护路由器的MAC地址即可。
补充 MAC地址 MAC地址又称物理地址、硬件地址。长度为 48 位。前24位，代表网络硬件制造商的编号；后24位，是该厂家自己分配的，一般表示系列号。
参考 如果让你来设计网络，你会如何设计？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9264a1dff3a7edae591d8ca6f9bb6e4/" rel="bookmark">
			C 语言中的布尔类型Bool（False/ Not False）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C 语言中的 Bool 值算是一个比较神奇的存在，近期学习了一下，逻辑运算关系中是比较好理解的，当表达式或运算结果作为判断时，有时会晕一下，记住一个原则和这几个值基本问题不大了：
一个原则：C语言中只有False，没有True
解析说明：Bool值，要么是False，要么是 非False（!False），非False也就是True，因为True有很多，但False只有几个 几个False值：除以下False，其它的全部都是True
数字0：int iFalse = 0;字符'\0'：char cFalse = '\0';NULL: 如 char *pFalse = NULL; 说完了，上代码：
#include &lt;stdio.h&gt; int main() { int iFalse = 0; char cFalse = '\0'; char *pFalse = NULL; int *piFalse = NULL; // 有一个TRUE就是TRUE，否则FALSE if (iFalse || cFalse || pFalse || piFalse) { printf("True"); } else { printf("False"); } return 0; } 编译运行结果：
结果上看，上述几个值均为false，当看到类似代码是，如果是false，就要反过来想可能是其中一个值，除此之外其它的值均为TRUE。
开发过程中代码判断时要判断FALSE，不要判断TRUE。
问题、意见、建议微信：13316098767 或 13316098767@qq.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd91b3dcafce1eb3324e4ba84c61df5/" rel="bookmark">
			（三）使用docker来进行paddleocr的安装使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 GPU的问题nvcc -v和nvidia-smi显示版本不一致linux下windows下查看 使用paddlepaddle的镜像使用nvidia-docker进行GPU使用不使用nvidia-docker进行GPU使用修改docker镜像源docker镜像更新镜像搞定之后的其他步骤启动容器git clone paddleocrpip install requirements 中文OCR模型快速使用使用paddleocr.wheel来进行快速使用 参考 GPU的问题 nvcc -v和nvidia-smi显示版本不一致 linux下 由于GPU和CPU版本安装区别很大，所以这里要先搞清楚自己服务器的GPU情况。
其实安装的是PaddlePaddle的镜像，paddleocr并没有官方镜像，去docker hub上也有，但是吧，还是想要官方的
查看cudnn版本， nvidia-smi 或者可以使用（nvidia-smi安装好了，表示cuda和cudnn已经安装了 ）
nvcc -V # 如果报找不到该路径或文件，则表示nvcc没有安装， # 可以安装 安装好之后再输入就可以了 sudo apt install nvidia-cuda-toolkit 但是显示
版本很低。。与nvidia-sim版本显示不一致，
按照网上的一些方式去查看，
发现我这个nvcc文件的位置似乎和其他博客的不太一样，难受
参考：
【CUDA】nvcc和nvidia-smi显示的版本不一致？ 这个博客写的很清楚了
windows下查看 查看nvcc（正常，因为我记得我安装的是11）：
查看nvidia-smi，
所以我本机的电脑安装是正确的，服务器不是自己安装的，需要解决一下问题。
使用paddlepaddle的镜像 如果想使用paddleocr的镜像，也可以，但是既然官网给出的是使用paddlepaddle的镜像，之后再进行paddleocr的安装，我觉得还是按照官网的来。
参考：快速安装
Docker 19.03，增加了对–gpus选项的支持，想在docker里面读取nvidia显卡再也不需要额外的安装nvidia-docker了——源自在docker19中使用GPU
使用nvidia-docker进行GPU使用 看了一下paddlepaddle官方的安装文档：开始使用注意：官网是提供了Docker安装方式的（不推荐使用这种方式，因为使用的是nvidia-docker）
# 拉取预安装 PaddlePaddle 的镜像： nvidia-docker pull registry.baidubce.com/paddlepaddle/paddle:2.0.1-gpu-cuda11.0-cudnn8 # 用镜像构建并进入Docker容器： nvidia-docker run --name paddle -it -v $PWD:/paddle registry.baidubce.com/paddlepaddle/paddle:2.0.1-gpu-cuda11.0-cudnn8 /bin/bash 不使用nvidia-docker进行GPU使用 另外，在paddleocr英文版的快速安装说明里，找到了PaddlePaddle的docker hub中的主页：https://hub.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcd91b3dcafce1eb3324e4ba84c61df5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cebab0e61a219f9e0c483822590225b/" rel="bookmark">
			k8s 中mysql 无法访问_故障排查：Kubernetes 中 Pod 无法正常解析域名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 最近将 Kubernetes 升级到 1.18.1 版本，不过升级完后，查看工作节点的部分 Pod 无法启动，查看消息全是 connetion timeout 的问题，一看连接超时的地址大部分是以域名方式连接集群内部地址(ClusterIP)，少部分是以域名方式连接集群外部地址，通过 IP 进行远程连接的应用倒是没有问题(例如，应用通过 IP 连接 MySQL)，由此判断，初步怀疑很可能是 DNS 出现了问题，后来慢慢发现 kube-proxy 中的错误，再定位到 IPVS parseIP Error 错误，再到解决问题。下面是分析及解问题的过程。
问题分析： 部署 DNS 调试工具为了探针是否为 DNS 问题，这里需要提前部署用于测试 DNS 问题的 dnsutils 镜像，该镜像中包含了用于测试 DNS 问题的工具包，非常利于我们分析与发现问题。接下来，我们将在 Kubernetes 中部署这个工具镜像。
部署 DNS 调试工具
1、创建 DNS 工具，镜像自行下载
[root@localhost ~]# vi ndsutils.yaml apiVersion: v1 kind: Pod metadata: name: dnsutils spec: containers: - name: dnsutils image: mydlqclub/dnsutils:1.3 imagePullPolicy: IfNotPresent command: ["sleep","3600"] 应用资源配置清单：
[root@localhost ~]# kubectl create -f ndsutils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cebab0e61a219f9e0c483822590225b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b564a9f77bbe381cbc03d0d6cc7cb854/" rel="bookmark">
			React v16版本 源码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 配置 React 源码本地调试环境) 使用 create-react-app 脚手架创建项目
npx create-react-app react-test 弹射 create-react-app 脚手架内部配置
npm run eject 克隆 react 官方源码 (在项目的根目录下进行克隆)
git clone --branch v16.13.1 --depth=1 https://github.com/facebook/react.git src/react 链接本地源码
// 文件位置: react-test/config/webpack.config.js resolve: { alias: { "react-native": "react-native-web", "react": path.resolve(__dirname, "../src/react/packages/react"), "react-dom": path.resolve(__dirname, "../src/react/packages/react-dom"), "shared": path.resolve(__dirname, "../src/react/packages/shared"), "react-reconciler": path.resolve(__dirname, "../src/react/packages/react-reconciler"), "legacy-events": path.resolve(__dirname, "../src/react/packages/legacy-events") } } 修改环境变量
// 文件位置: react-test/config/env.js const stringified = { "process.env": Object.keys(raw).reduce((env, key) =&gt; { env[key] = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b564a9f77bbe381cbc03d0d6cc7cb854/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b7c8ca7e0e696c7d5a0d1cc77c9036f/" rel="bookmark">
			python笔记(九)：字符串str查询、大小写传唤、拆分、替换、切割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-----学习视频来源于马士兵教育-----
内容主要为了自己复习用，也可以让大家梳洗思路
###字符串学习 #一、强制两个字符串ID相同 a=('a%') b=('a%') a=sys.intern(b) print(a is b) #二、字符串的查询操作 index不存在报错，find不存在返回-1 s='hello,worldlo' print(s.index('lo')) #3 第一次出现lo的位置 print(s.find('lo')) #3 第一次出现lo的位置 print(s.rindex('lo')) #11 最后一次出现lo的位置 print(s.rfind('lo')) #11 最后一次出现lo的位置 #三、字符串大小写转换 s='hello.world' s1=s.upper() print(s1) #HELLO.WORLD upper,所有字符转换成大写 s2=s1.lower() print(s2) #hello.world lower,所有字符变成小写 s='Hello.World' s3=s.swapcase() print(s3) #hELLO.wORLD swapcase把所有大写字符转换成小写，小写字母转换成大写 s='hello.World' s4=s.capitalize() print(s4) #Hello.world capitalize把第一个字符转换成大写，把其余字符都转换成小写 s='hello.world' s5=s.title() print(s5) #Hello.World title把每个单词的第一个字符转换成大写，剩余字符变为小写 ##字符串内容对齐操作的方法 s='hello,Python' ##共12个字符，设定为20，剩余间隔为20-12，默认间隔符为空格 print(s.center(20,"*")) #****hello,Python****居中对其 print(s.ljust(20,"*")) #hello,Python******** 左对齐 print(s.rjust(20,"*")) #********hello,Python 右对齐 print(s.zfill(20)) #00000000hello,Python, 0为填充间隔，右对齐 print('-99'.zfill(4)) #-099 加上符号换算位置 ##字符串分割 s='hello world' s1=s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b7c8ca7e0e696c7d5a0d1cc77c9036f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b090450828b7fdeb3c75ab765a08bee/" rel="bookmark">
			Linux 创建文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 使用重定向符（&gt;）创建文件
2. 使用 touch 命令创建文件
3. 使用 echo 命令创建文件
4. 使用 printf 命令创建文件
5. 使用 cat 命令创建文件
6. 使用 vi / vim 创建文件
7. 使用 nano 创建文件
8. 使用 head 命令创建文件
9. 使用 tail 命令创建文件
10. 使用 truncate 命令创建文件
1. 使用重定向符（&gt;）创建文件 通常用于将一个命令的输出重定向到一个新文件中，如果没有命令，则会创建一个 0KB 的空文件。不允许在创建文件时向其中输入任何文本。
2. 使用 touch 命令创建文件 touch 命令通常用于将文件的访问和修改时间更新为当前时间。如果指定的文件名不存在，会创建一个 0KB 的空文件。不允许在创建文件时向其中输入任何文本。
3. 使用 echo 命令创建文件 echo 命令通常用于脚本、批处理文件。允许在创建文件时就向其中输入文本，也允许在文件创建后输入文本。也可以使用两个重定向符（&gt;&gt;）向同一文件追加内容。
4. 使用 printf 命令创建文件 同 echo。
5. 使用 cat 命令创建文件 cat 表示 concatenate（串联）。cat 文件名 命令可以显示一个文件的内容；cat &gt; 文件名 命令可以创建一个新的文件，该命令回车后不会立即结束，可以输入添加到新文件的内容后按 Ctrl+C 或者 Ctrl+D 来结束，也可以使用 cat &gt;&gt; 文件名 命令向同一文件添加其它内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b090450828b7fdeb3c75ab765a08bee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b62ba8a98c46ff6fc7e12353542bfdc4/" rel="bookmark">
			C&#43;&#43;编程基础——宏、函数、面向对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数 函数重载（Function Overload） 函数名相同，但形参类型列表不同（即形参的数量或类型不同）。
默认参数（Default Argument） 函数参数可以带默认值，简化函数调用。
默认参数必须全部放在形参列表的最右边，并且必须连续排列。
面向对象编程 OOP：Object Oriented Program，面向对象编程。
对象（Object）：任何一个具体的事物。
类（Class）：具有相同特征的一些对象的抽象，并不是具体存在的事物。
对象是类的实例（Instance），类是对象的抽象。
实例化：通过类定义对象。
在OOP中，类其实就是一个（复杂）数据类型，跟结构体几乎一样，通过类类型定义的变量或常量我们通常称之为对象。
类就是一种自定义数据类型，必须先声明，然后才能用它定义对象。
类中成员可以为成员变量（Menber Variables，或称属性）、成员函数（或称方法）等。
属性（Attribute）：用于描述同类对象的静态特征。比如一个人的体重、血型等。
方法（Method）：用于描述同类对象的动态行为。比如人可以讲话、学习等。
成员访问权限：
private：私有的，只能在本类中访问。protected：保护的，只能在本类中和子类中访问。public：公有的，所有地方（本类中、子类中和类外）都可以访问。 类中成员的默认访问权限为private，而结构体中成员默认访问权限为public。
对象的所占内存空间大小是由所有非静态属性决定，计算方法和结构体完全一致。
静态属性和成员函数在内存中只有一份，所有对象共享，所以它们所占内存空间没有算在每个对象的头上。
面向对象编程的三大特性：
封装：
类就是将数据和对数据的操作整合在一起构成一个独立的整体，封装级别比普通函数更高。将类中数据对外隐藏，让外界不能直接访问，如果确实需要访问，就提供一些接口（公有的办法）供外界调用实现间接访问。 每个非静态方法内部有一个隐含的指针常量，它的名字为this，它指向调用该方法的那个对象。
this 也是 C++ 关键字，表示当前对象的指针。
继承多态 实例一：对于宏的使用（换行符’ \ '、do…while）
//宏的使用 #include &lt;iostream&gt; void e() { #define XYZ 10 //换行符 #define qq using namespace std;\ cout &lt;&lt; XYZ &lt;&lt;endl;\ cout &lt;&lt; 1+1 &lt;&lt;endl; #define show(x) do {printf("%s\n",(x));printf("end\n")} while(0) } int main() { qq return 0; } 实例二：函数重载、默认参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b62ba8a98c46ff6fc7e12353542bfdc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e42d3ad75376e87d7f059f114093d4/" rel="bookmark">
			scrcpy源码阅读及在Ubuntu上的实现（一）——了解原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		那开篇就问问为什么需要研究这个源码吧：
在移动互联网的时代下，手机的功能是日益增加的，要使工作变得更加的高效，那么键盘鼠标其实是必不可少的。在许多软件的架构中，其实并没有提供对应的桌面版本，也不兼容基于x86架构的Android模拟器，按照这样下来，那我们就只能使用投屏工具了。scrcpy就是众多投屏软件中最具特色的一款，作为一款开源的软件，它拥有极佳的性能和丰富的功能，但是这款软件最气的地方在于他不可以输入中文！！看看能不能通过对源码的学习来改善这个问题吧。
环境说明: Ubuntu20.04
源码地址：GitHub - Genymobile/scrcpy: Display and control your Android device
scrcpy源码版本v1.23
搭建scrcpy编译开发环境： 下载scrcpy源码
git clone https://github.com/Genymobile/scrcpy 安装meson sudo apt install python3-pip pip3 install meson 安装Java vm sudo apt install openjdk-11-jdk export PATH="JAVAHOME/bin:PATH" 安装ninja sudo apt install ninja-build 安装SDL2 sudo apt-get install libsdl2-2.0 sudo apt-get install libsdl2-dev 安装依赖库 sudo apt install gcc git pkg-config meson ninja-build libsdl2-dev libavcodec-dev libavdevice-dev libavformat-dev libavutil-dev sudo apt install ffmpeg libsdl2-2.0-0 adb sudo snap install gradle 如果上一步安装后会出现这样的错：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8e42d3ad75376e87d7f059f114093d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e577e37546079d8cec41c8ab6397cc40/" rel="bookmark">
			扫描技术的原理与应用（Nmap使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫描技术的原理与应用（Nmap使用） 一、实践内容二、实践过程1.TCP connect扫描方式1.1 TCP connect1.2 进行扫描并捕获数据包1.3 单独扫描某一端口并捕获数据包 2.TCP SYN扫描方式2.1 TCP SYN2.2 使用Nmap进行扫描并捕获数据包 3.操作系统扫描方式3.1 操作系统探测3.2 Kali操作系统探测3.3 Ubuntu操作系统探测3.4 数据包分析（1）操作系统探测数据库（2）系统探测过程 4.使用漏洞扫描扫描目标的漏洞信息 三、实践总结 一、实践内容 TCP connect扫描方式TCP SYN扫描方式操作系统扫描方式漏洞扫描 二、实践过程 1.TCP connect扫描方式 1.1 TCP connect TCP connect扫描是开放扫描的一种，需要扫描方通过三次握手过程与目标主机建立完整的TCP连接。TCP connect利用操作系统提供的connect()系统调用进行扫描，扫描器调用socket的connect()函数发起一个正常的连接，如果connect()连接成功，说明目标端口处于监听状态，若连接失败，则说明该端口是关闭的或者被防火墙等过滤。原理图如下：
1.2 进行扫描并捕获数据包 Nmap中TCP connect扫描使用的参数为-sT，使用的命令为nmap -sT 192.168.21.1（做该实验时本机的IP地址为192.168.31.24），对目标主机的1000个端口进行扫描，扫描结果和捕获的数据包如图所示。
如下图所示，扫描结果中可以看到开放的端口有7个，分别为53（domain）、80（http）、8192（sophos）、8193（sophos）、8383（m2mservices）、8443（https-alt）、8899（ospf-lite）。
直接从诸多数据包中筛选出目标端口为53（开放端口）的数据包，如下图所示。
可以看到，正如课上老师所讲，本地主机通过三次握手成功与目标主机建立TCP连接，并在建立之后发送RST包断开连接，如原理图所示过程。
筛选出目标端口为23（关闭端口）的数据包，如下图所示。可以看到，本地主机发起TCP连接时被目标主机直接拒绝，如上图所示过程。
1.3 单独扫描某一端口并捕获数据包 使用-p参数可以指定端口进行扫描，通过以上实验，53号端口是开放的，所以使用nmap -sT -p 53 192.168.21.1对53号端口进行扫描，捕获的数据包如下图所示（因为实验时间不同，本地主机分配的IP地址有变动，为192.168.31.188）。
443号端口是关闭的，所以使用nmap -sT -p 443 192.168.21.1对443号端口进行扫描，捕获的数据包如下图所示。
2.TCP SYN扫描方式 第一个实验中已经知道目标主机的7个开放端口和其他的关闭端口，因此本节就针对特定端口使用TCP SYN扫描方式进行扫描。
2.1 TCP SYN TCP SYN扫描是半开扫描（Half-open）的一种，即扫描方不需要建立一个完全的TCP连接。TCP SYN扫描中，扫描程序发送的一个SYN数据包，若返回SYN/ACK数据包，表示目标端口处于监听状态，然后扫描程序必须再发送一个RST信号来关闭这个连接进程，若返回RST数据包则表示端口没有开放。原理图如下：
2.2 使用Nmap进行扫描并捕获数据包 Nmap中TCP SYN扫描使用的参数为-sS，对80端口进行扫描的命令为nmap -sS -p 80 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e577e37546079d8cec41c8ab6397cc40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a42970ae679a689a7027897c7634433/" rel="bookmark">
			error while loading shared libraries: xxx.so.6: cannot open shared object file: No such file
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在自己制作app并开发板挂载文件测试的时候报错：
error while loading shared libraries: xxx.so.6: cannot open shared object file: No such file or directory
报错内容是缺少相应动态文件，造成无法编译。
但是我其实是已经将动态库拷贝至挂载的文件库下，经过搜寻，得知产生此错误原因如下：
1、 没有拷贝动态库，比如你的程序有文字，但是你却没有字库，那么系统无法编译。
这个问题的解决办法就是将动态库拷贝到系统库文件下。
2、启动开发板后挂载虚拟机文件系统，在这种情况下，如果只是将动态库拷贝至虚拟机文件系统中，开发板是无法查询到的；因为开发板查询的库是“/lib”而不是“/mnt/lib”。
这个问题的解决办法就是将相应文件拷到开发板根目录下的lib即可，或者采用nfs启动。
3、 动态库链接错误，需要在环境变量中添加正确位置（这种情况一般比较少，在开发板中采用export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/xxx/xx设置）
在解决上述小点2的时候我遇到了一点小问题： 在我cp /mnt/lib 到/lib的时候，我得nfs会卡住，显示 still trying
如上图所示，开发板会在这几句间不停重复，ctrl+c也无法退出。
经查询可知，在保证了挂载正常但一到复制就不正常时，这是我们的nfs传输速率与目标机传输速率不匹配造成的。
我们可以修改挂载方式，在挂载时加上“rsize=1024,wsize=1024”即可：
mount -o nolock,rsize=1024,wsize=1024 192.168.31.140（目标地址）:/home/mynfs（需要被挂载文件） /mnt (nfs有时与网络传输速度不匹配，需要加上rsize和wsize) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee5f7017cfec2368988579d7da427610/" rel="bookmark">
			Python语言程序设计实验4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的
1.掌握 whil 语句的基本格式及执行规则。
2.掌握 for 语句的基本格式及执行规则。
3.掌握多重循环的使用方法。
4.掌握循环结构程序设计的方法。
二、实验内容
1.写出下列程序的运行结果。
2.写出下列程序的运行结果。
3.阅读下面的Python程序 ，程序的功能是什么？
4.从键盘输入5组数，每组有6个数，求出各组中元素绝对值之和的最大者和最小者，请补充程序。
5.利用下列公式 1）.
2）.
（此方法比较复杂，仅代表当时想法，可简化）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e2cf88ad664d17311b6b825467141bf/" rel="bookmark">
			Python神经网络代码详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import numpy import scipy.special #想要使用S函数，必须导入这个包 #完整的神经网络代码 class neuralNetwork: def __init__(self,inputnodes,hiddennodes,outputnodes,learningrate): #初始化神经网络 self.inodes=inputnodes #输入层节点数 self.hnodes=hiddennodes #隐藏层节点数 self.onodes=outputnodes #输出层节点数目 #创建两个链接权重矩阵 #正太分布的中心设定为0.0，使用下一层节点数的开方作为标准方差来初始化权重，即pow(self.hnodes,-0.5)，最后一个参数是numpy数组的形状大小 self.wih=numpy.random.normal(0.0,pow(self.hnodes,-0.5),(self.hnodes,self.inodes)) self.who=numpy.random.normal(0.0,pow(self.onodes,-0.5),(self.onodes,self.hnodes)) #或者可以选择简单一点的创建链接权重矩阵的方法 #self.wih=(numpy.random.rand(self.hnodes,self.inodes)-0.5) #self.who=(numpy.random.rand(self.onodes,self.hnodes)-0.5) #减去0.5得到-0.5—0.5之间的权重 self.lr=learningrate #学习率 self.activation_function=lambda x:scipy.special.expit(x) #使用lambda来创建函数，这个函数接受了x，返回scipy.special.expit(x)，这就是S函数（激活函数） #使用lambda创建的函数是没有名字的，一般称其为匿名函数，这里给它分配了一个名字activation_function(),因此，当想要使用S函数时，调用这个函数即可 pass def train(self,inputs_list,targets_list):#target_list目标值 #训练网络，反向传播误差 #训练网络分两个部分：针对给定的训练样本输出，这与query()函数上所做内容没什么区别；将计算得到的输出与所需输出对比，使用差值来指导网络权重的更新 inputs=numpy.array(inputs_list,ndmin=2).T #将输入的列表转换为矩阵并且转置,数组的维度是2(2维数组表示矩阵) targets=numpy.array(targets_list,ndmin=2).T #将targets_list变成numpy数组（维度为2），也即是矩阵 hidden_inputs=numpy.dot(self.wih,inputs) hidden_outputs=self.activation_function(hidden_inputs) final_inputs=numpy.dot(self.who,hidden_outputs) final_outputs=self.activation_function(final_inputs) #以上部分与query()部分使用完全相同的方式从输入层前馈信号到最终输出层 output_errors=targets-final_outputs #输出层输出误差为预期目标输出值与实际计算得到的输出值的差 hidden_errors=numpy.dot(self.who.T,output_errors) #计算隐藏层节点反向传播的误差：隐藏层与输出层之间链接权重的转置点乘输出层输出误差，为隐藏层输出误差 #对于在隐藏层和输出层之间的权重，我们使用output_errors进行优化。 #对于输入层和隐藏层之间的权重，我们使用计算得到的hidden_errors进行优化 self.who+=self.lr*numpy.dot((output_errors*final_outputs*(1.0-final_outputs)),numpy.transpose(hidden_outputs)) self.wih+=self.lr*numpy.dot((hidden_errors*hidden_outputs*(1.0-hidden_outputs)),numpy.transpose(inputs)) #利用更新权重的公式进行计算，得到新的权重 pass def query(self,inputs_list): #查询网络，计算输出 inputs=numpy.array(inputs_list,ndmin=2).T #将inputs_list变成numpy数组（维度为2），也即是矩阵 hidden_inputs=numpy.dot(self.wih,inputs) #输入层与隐藏层链接权重矩阵点乘输入矩阵，得到隐藏层的输入矩阵 hidden_outputs=self.activation_function(hidden_inputs) #调用S函数，得到隐藏层的输出 final_inputs=numpy.dot(self.who,hidden_outputs) #隐藏层与输出层的链接权重点乘隐藏层的输出矩阵，得到输入层的输入矩阵 final_outputs=self.activation_function(final_inputs) #调用S函数，得到输出层的输出 return final_outputs #返回输出的输出矩阵 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ec048bb0a9f8a36c21747ed42d51db/" rel="bookmark">
			添加网络路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows： route -p add 192.168.1.22 MASK 255.255.255.255 192.168.2.1
route -p add 192.168.1.23 MASK 255.255.255.255 192.168.2.1
命令解析如下
route -p add 对端IP mask 子网掩码（我这里是因为要单独IP所以用4个255） 网关地址
route print （查看路由表）
route print &gt;&gt; c:\route.txt （将路由输出到文件）
Linux： 一：使用 route 命令添加
使用route 命令添加的路由，机器重启或者网卡重启后路由就失效了，方法：
//添加到主机的路由
# route add –host 192.168.1.11 dev eth0
# route add –host 192.168.1.12 gw 192.168.1.1
//添加到网络的路由
# route add –net 192.168.1.11 netmask 255.255.255.0 eth0
# route add –net 192.168.1.11 netmask 255.255.255.0 gw 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57ec048bb0a9f8a36c21747ed42d51db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee5d40268f249f34138878a4f8ec571e/" rel="bookmark">
			拼多多产品怎么自动上架|盛天海电商
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 拼多多商家如果经营不善的话，那就需要好好去了解一下什么情况会被下架呢？也要了解一下相关的规则，那么跟着盛天海电商小编来看看吧！ 1.第二次秒杀活动的热身 对于参与拼多多第二次秒杀活动的货物，在第二次杀戮开始前有3天的预热期。在此期间，商品将自动从货架上取下，并在活动开始前不会再次上架。因此，没有必要过多地担心二次秒杀产品的下架 2。商品库存已售罄 不用说，当库存为0时，商品将自动从货架上移除；如果下架时间太长，会影响货物的重量，所以我们应该始终注意库存的数量。如果活动期间库存售罄，商品将不会下架 拼多多平台退换货规则：目前拼多多商城支持7天无理由退换货。 如果不影响二次销售，可以要求商家无故退货、换货。由于某些产品的特殊性，没有理由在7天内退货和换货，新鲜、虚拟、海外淘大直供类别不受支持 企业需要准确估计其配送能力。如果出现虚假发货、延迟发货、短缺和假冒伪劣商品，将按照平台规则进行处罚。请合理填写活动库存，并确保活动登记全过程中的商品库存不低于填写的活动库存（系统将检查每个SKU的库存）。最后第二个终止页面上的库存以已批准的采购限制库存为准。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/252/">«</a>
	<span class="pagination__item pagination__item--current">253/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/254/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>