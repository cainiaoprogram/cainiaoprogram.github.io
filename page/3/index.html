<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b7f2674260f71bf309db8b7f1cfd28/" rel="bookmark">
			创建EasyCodeMybatisCodeHelperPro模板文件用于将数据库表生成前端json文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在intellij idea中，通过插件EasyCodeMybatisCodeHelperPro，从现有的模板文件中选择一个复制粘贴，然后稍为修改，即可得到一个合适的模板文件。
现在的前端，越来越像后端。TypeScript替代了JavaScript，引入了强类型（？），还有抽象类、接口、proteced属性之类的东东。然后还有根据数据库表导出的实体类文件，问你死未。当我听到我同事说这些名为*.data.ts的json格式文件，是通过工具自动导出来时，我感到震惊，50岁的心灵遭到暴击，内心一阵被时代抛弃的恐慌。我没想到还可以这么搞。
经过请教和摸索，我也终于可以导出前端实体类了。总结如下：
1、概述 目前好像没有专门根据数据库，用于导出前端类的工具。但可以通过后端的工具顺便导一下。我用的是EasyCodeMybatisCodeHelperPro。我请教同事是怎么导的，他说是EasyCode，结果我装了一个EasyCode后，Intellij Idea居然打不开了。最后费了九牛二虎之力才恢复正常。事实证明，用EasyCodeMybatisCodeHelperPro也完全可以，无非是通过模板文件导而已。
2、创建模板文件 EasyCodeMybatisCodeHelperPro提供了几个模板文件，用于在后端自动生成代码。前端的话，我复制了其中的实体类模板，改名为：vue.json.vm，然后稍为改改里面的内容，即可得到前端模板。具体为：
1）打开intellij idea
2）File - Setting - Other Settings - EasyCodeMybatisCodeHelperPro - Template
3、编写前端模板文件 模板里的普通正文，会输出到导出文件里。如果要用到系统变量，就是#，$这类特殊符号，还有一些循环语句之类。其实系统很贴心地在下半部分提供了注释，稍为看一下就能理解。试举2例：
1）使用系统变量
$!{tableInfo.name} 2）循环语句：
以”#“开路。注意2个#之间，使用系统变量直接用$符号即可，不要像1）那样复杂。
#foreach($pk in $tableInfo.pkColumn) primaryKey: '$pk.name', #end 模板文件代码示例（vue.json.vm)：
##引入宏定义，不知道有什么用 $!{define.vm} ##使用宏定义设置回调（保存位置与文件后缀），生成子路径，以及文件后缀名 #save("/data", ".data.ts") ##使用全局变量实现默认包导入，下面基本都是输出文件中的内容，不必深究 import { reactive } from 'vue' import { required } from '@/utils/formRules' import { VxeCrudSchema, useVxeCrudSchemas } from '@/hooks/web/useVxeCrudSchemas' // 表单校验 export const rules = reactive({ proId: [required] }) // CrudSchema //isTable: 是否在列表显示 //isSearch: 是否在查询显示 const crudSchemas = reactive&lt;VxeCrudSchema&gt;({ ## 输出主键 #foreach($pk in $tableInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81b7f2674260f71bf309db8b7f1cfd28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f125cc423ee9fabbdcb1d0768008444/" rel="bookmark">
			PDB/AMF格式在线转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3D模型在线转换（https://3dconvert.nsdt.cloud/）是一个可以进行3D模型格式转换的在线工具，支持多种3D模型格式进行在线预览和互相转换。
PDB格式与AMF格式简介 PDB(Protein Data Bank)是一种标准文件格式, 其中包含原子的坐标等信息, 提交给 Protein Data Bank at the Research Collaboratory for Structural Bioinformatics (RCSB) 的结构都使用这种标准格式。
AMF是以目前3D打印机使用的“STL”格式为基础、弥补了其弱点的数据格式，新格式能够记录颜色信息、材料信息及物体内部结构等。AMF标准基于XML（可扩展标记语言），简单易懂，将来可通过增加标签轻松扩展。新标准不仅可以记录单一材质，还可对不同部位指定不同材质，能分级改变两种材料的比例进行造型。造型物内部的结构用数字公式记录，能够指定在造型物表面印刷图像，还可指定3D打印时最高效的方向。另外，还能记录作者的名字、模型的名称等原始数据。
PDB格式转换成AMF格式 PDB格式和AMF格式都有广泛的用途，在模型应用工作中，经常需要将PDB格式转换成AMF格式，怎么将PDB格式在线转换成AMF格式呢？推荐一款在线模型转换工具：PDB转AMF网站。
PDB转AMF网站是3D模型在线转换工具集中的一个，网站提供多种模型格式文件之间进行互转，支持将PDB格式在线转换为AMF格式。
文件上传 在打开的格式转换页面中，点击【上传文件】，选择待转换的目标文件。
如果模型文件包含有附属文件（如材质贴图），则需要将文件同时上传。上传方式：点击【上传文件】，在文件选择框中，按住键盘上的【Shift】键，通过鼠标左键同时选择多份文件，进行文件上传。
PDB转AMF网站也支持通过拖拽的方式，将文件进行上传。在资源管理器中，选择一份或多份模型相关文件，拖拽至PDB转AMF网站中的文件接收区域，即可完成3D模型文件的上传。
格式转换 在将模型文件上传至PDB转AMF网站后，网站将自动完成模型格式的转换。
PDB转AMF模型格式需要花费一些时间，转换时间长度主要与模型的大小和面数相关，文件越大、模型面数越多，转换需要的时间就越长。
在等待一段时间后，网站完成了模型格式的转换，展示页面如下。
在PDB转AMF网站完成模型格式转换完成后，此时可以在线预览模型转换结果，可以直接下载转换结果，也可以继续转换下一个模型。
模型预览 点击PDB转AMF网站页面中的【预览】按钮，在新开页面中对模型文件进行在线预览。
PDB转AMF网站在进行模型格式在线转换时，支持对顶点颜色和图片纹理进行处理，转换后的模型，不仅保留了基础的模型结构，还保留了模型的顶点颜色和图片纹理。
模型下载 在PDB转AMF网站的转换页面会预览页面中，点击【下载】按钮，网站会自动生成模型文件的下载链接。
通过PDB转AMF网站生成的下载链接，可以将AMF格式的模型文件下载到本地。生成的下载链接24小时内有效，超时将不能下载，需要及时下载文件。
以上就是PDB格式和AMF格式的介绍，以及PDB格式转换成AMF格式的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51317e17bc807050e25f876f0eb7977a/" rel="bookmark">
			Python自动化办公:批量识别图片文字并存为Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超级无敌干货，第一时间送达！！！
一、背景 大家好，我是程序员晓晓。
也许你还记得，前不久复旦大学一博士生写了130行Python代码，批量识别核酸截图内容的故事。当时还被人民日报公众号报道出来，夸赞用所学贡献青春力量！
其实，批量文字识别（OCR）是Python办公自动化的基本操作，应用在我们工作生活中的方方面面，比如车牌识别、证件识别、银行卡识别、票据识别等等。
Python中OCR第三方库非常多，比如easyocr、PaddleOCR、cnocr等等。当然，直接调用百度API也是可以的，不过超过一定限额后要收费，因此本文主要以开源免费的easyocr来进行介绍。
二、需求 本文以证件识别为例，我网上找了3张虚拟身份证来实验：
运用easyocr进行识别并保存为Excel，效果如下：
三、实战 1.安装模块 在Python中使用 easyocr非常简单，只要使用pip命令安装easyocr 即可（建议使用清华源，否则安装会比较慢）。
pip install easyocr 不过 easyocr 的深度学习算法依赖于另一个著名的第三方模块 pytorch，图形处理部分则会用到 opencv、Pillow 等，所以还需要确保自己电脑上已经安装这些基础模块。
2.识别一张图片 1.easyocr识别图片代码非常简洁，只需要创建一个easyocr.Reader类对象，指定以下两个常用参数：
需要识别的文字属于哪几种语言
是否启用GPU显卡加速
2.调用Reader对象的readtext方法，将图片中所有文字读入一个列表并返回。
''' 公众号：编程IT资料库 ''' # 导入模块 import easyocr # 图片路径 image = './id_card/1.jpg' # 创建ocr的reader对象，识别中英文 ocr = easyocr.Reader(['ch_sim', 'en'],gpu=False) # 识别图片文字 content = ocr.readtext(image) print(content) 识别结果如下：
[([[39, 31], [207, 31], [207, 67], [39, 67]], '姓 名 韦小宝', 0.8973890994570185), ([[40, 82], [159, 82], [159, 119], [40, 119]], '性 别 男', 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51317e17bc807050e25f876f0eb7977a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82120df21ffeed3d3743df076a1d7271/" rel="bookmark">
			试用 Coroot，一个基于 eBPF 的可观测性工具，用于 Kubernetes 等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本文中，我们将介绍 Coroot，这是一个使用 eBPF 技术构建的开源工具，旨在用于 Kubernetes 或基于 Docker/containerd 的环境，甚至是非容器化应用程序。Coroot 收集和分析遥测数据（指标、日志、跟踪和配置文件），将其转换为可用信息，使您能够快速识别和修复应用程序问题。我们将介绍如何为 Kubernetes 安装和配置 Coroot，以及它的作用，以及它的优缺点。
Coroot 是一个相当新的工具，第一次提交到 GitHub 可以追溯到 2022 年 8 月 22 日。这个项目背后的团队以前在实现另一个可观察性解决方案方面有丰富的经验(它是一个用于基础设施监控的专有系统)。现在，他们将 Coroot 定位为一个全面的遥测收集和故障监测系统。让我们试一试吧!
安装 Coroot Coroot 有三个版本：免费（开源）、云（按节点定价）和企业（可以是云或本地安装）。Cloud 和 Enterprise 都包含作者的支持;后者还拥有附加功能，例如 RBAC（基于角色的访问控制）、SSO（单点登录）、审核日志等。
我们将在 Kubernetes 1.23 集群中安装和评估 Coroot 的开源版本。
安装方法 #1 为此，我们从官方存储库中的 Kubernetes 清单开始。清单创建了 Namespace、PersistentVolumeClaim、Deployment 和 Service。
但是，我们想看看该服务是如何从外部工作的，没有 PortForward 或其他技巧。因此，我们添加了一个 Ingress 资源。在 NGINX 中，使用可用于进入应用程序的外部 DNS 地址创建了一个配置文件。由于 Coroot 没有授权，我们通过 GitLab 使用 Dex 授权来保护资源。
在容错配置中运行 Coroot：该服务有一个名为 PG_CONNECTION_STRING 的变量。设置它会导致服务将其配置保存在 PostgreSQL 中。在这种情况下，可以在容错配置中运行它（但本主题超出了本文的范围）。
安装方法 #2 您可以使用原始的 Helm 图表安装 Coroot。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82120df21ffeed3d3743df076a1d7271/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04aa49290a2b306f2bac721eaba9ae63/" rel="bookmark">
			LeetCode[105] 从前序与中序遍历序列构造二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。
示例 1:
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出: [3,9,20,null,null,15,7] 示例 2:
输入: preorder = [-1], inorder = [-1] 输出: [-1] 超级经典的题目，这道题相信很多人都会，也理解题意，给出的例子也能瞬间构建出来二叉树，但是真的写起来，我个人觉得不是那么容易。
首先要搞清楚二叉树的前序遍历，中序遍历，后续遍历的定义，然后找出规律，然后再开始解题。
解题思路： 1.preorder[0]是root
2.在inorder中找到preorder[0]的索引idx，索引之前的为root-&gt;left,中序遍历为inorder[1,idx-1] 索引之后为root-&gt;right,中序遍历为inorder[idx+1,end]
3.根据2中的索引位置，确定root-&gt;left的节点数量leftnum和root-&gt;right的节点数量rightnum
4.在preorder中确定左右子树的前序遍历，root-&gt;left的前序遍历为preorder[1,leftnum],root-&gt;right的前序遍历为preorder[leftnum+1,end]
5.处理好边界和迭代终止条件
解法1：
TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { if(preorder.size() == 0) return nullptr; TreeNode* root = new TreeNode(preorder[0]); return build(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1); } TreeNode* build(vector&lt;int&gt;&amp; preorder, int prestart, int preend, vector&lt;int&gt;&amp; inorder, int instart, int inend) { if(prestart &gt; preend) return nullptr; int val = preorder[prestart]; int idx = find(inorder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04aa49290a2b306f2bac721eaba9ae63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb6a7805a31477a2ea05762ce7ec266/" rel="bookmark">
			启动Spring Boot&#43;vue前后端分离的若依（RuoYi）项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载若依项目：RuoYi-Vue: 🎉 基于SpringBoot，Spring Security，JWT，Vue &amp; Element 的前后端分离权限管理系统，同时提供了 Vue3 的版本 (gitee.com)
下载好的项目目录结构
这是前端项目，其余为后端
启动后端项目，需要完成以下步骤
1.连接本地数据库
新建数据库
导入这两张表
键数据库，运行SQL文件...
表结构
2.启动redis
下载Redis：Download | Redis
打开Redis安装路径，地址栏输入cmd，弹出命令行窗口，输入命令：redis-server.exe redis.windows.conf
如有报错，查看博文：启动Spring Boot+vue前后端分离的若依（RuoYi）项目-CSDN博客
redis启动成功后，不要关闭
启动后端项目，运行RuoyiAppliction
启动成功
到浏览器输入：http://localhost:9090 (9090是我设置的端口，具体端口号查看application.yml文件中的serve.port)
启动前端项目
打开编辑器，我用的是VSCode，打开ruoyi-ui项目
打开README.md文件，查看操作命令
打开终端，输入命令 npm install 或 npm i 下载依赖包 下载完成
由于我改动了后端端口号，故启动项目之前，需要改动一个地方 vue.config.js
启动前端项目，在终端中执行命令：npm ren dev
运行成功
到浏览器输入地址
在此期间，遇到了两个问题
1.后端报Redis异常
Error in execution; nested exception is io.lettuce.core.RedisCommandExecutionException: MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acb6a7805a31477a2ea05762ce7ec266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02af4939a7e8a84f90218951fb9cff20/" rel="bookmark">
			CSS进阶方法——复合选择器、元素显示、背景设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、复合选择器 复合选择器是建立在基础选择器之上，对基础选择器进行组合形成的。
复合选择器可以更准确、更高效的选择目标元素（标签）复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等. 1-1 后代选择器 后代选择器 元素1 元素2 {css样式}
后代选择器 又称为 包含选择器，可以选择父元素里面子元素。其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。
元素1 和 元素2 中间用 空格 隔开元素1 是父级，元素2 是子级，最终选择的是 元素2，即：元素1 是不会生效样式的元素2 可以是儿子，也可以是孙子等，只要是 元素1 的后代即可 /* ①后代选择器 元素1 元素2 {css样式} */ .father .son1 { width: 300px; height: 300px; border:5px solid rgb(2, 62, 115); } .father .son1-groundson{ width: 200px; height: 200px; border:5px solid rgb(23, 147, 255); } 1-2 子选择器 元素1&gt;元素2 {css样式}
子元素选择器（子选择器）只能选择作为某元素的最近一级子元素，简单理解就是选直接后代子元素。
/* ②子选择器 元素1&gt;元素2 {css样式} */ .father&gt;.son1{ border:5px solid rgb(92, 209, 255); } 1-3 并集选择器 元素1,元素2{css样式}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02af4939a7e8a84f90218951fb9cff20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43217e9b7b277f828a69f927ce08ea97/" rel="bookmark">
			openai自定义API操作 API （openai.custom）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenAI 提供了一个自定义 API，允许开发者通过编程方式与 OpenAI 的 AI 模型进行交互。使用这个 API，你可以执行各种任务，例如文本生成、推理和翻译等。
以下是使用 OpenAI 自定义 API 的基本步骤：
创建 API 密钥：首先，你需要在 OpenAI 的网站上创建一个 API 密钥。这将允许你使用 OpenAI 的 API 进行身份验证。安装 OpenAI 客户端库：你需要安装一个适合你的编程语言的 OpenAI 客户端库。这些库提供了与 OpenAI API 进行交互的 API。你可以在 OpenAI 的官方文档中找到适用于不同编程语言的客户端库。编写代码：使用你选择的编程语言和 OpenAI 客户端库，编写代码来调用 OpenAI API。你可以使用 API 调用来执行各种任务，例如文本生成、推理和翻译等。发送请求并处理响应：使用你的代码发送请求到 OpenAI API，并处理返回的响应。响应将包含有关你请求的信息，例如生成的文本、推理结果或翻译等。公共参数 名称类型必须描述keyString是调用key（必须以GET方式拼接在URL中）secretString是调用密钥api_nameString是API接口名称（包括在请求地址中）[item_search,item_get,item_search_shop等]cacheString否[yes,no]默认yes，将调用缓存的数据，速度比较快result_typeString否[json,jsonu,xml,serialize,var_export]返回数据格式，默认为json，jsonu输出的内容中文可以直接阅读langString否[cn,en,ru]翻译语言，默认cn简体中文versionString否API版本请求参数响应示例 { "response": { "id": "cmpl-6qY0bIoPXYs7nCMME3g9buaZcxbf6", "object": "text_completion", "created": 1677981805, "model": "text-davinci-003", "choices": [ { "text": "\n\n按中国富豪榜排名，中国最有钱的人是马云。", "index": 0, "logprobs": null, "finish_reason": "stop" } ], "usage": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43217e9b7b277f828a69f927ce08ea97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/975da5765723d155f5ac163f5372a402/" rel="bookmark">
			CSS水平垂直居中(最常见的三种方案flex、grid、absolute)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文简单介绍一下现代 CSS 中最常见的三种水平垂直居中方案。
html：
&lt;div class="container"&gt; &lt;div class="content"&gt;&lt;/div&gt; &lt;/div&gt; css：
.container { width: 500px; height: 500px; border: 1px solid #000; .content { width: 200px; height: 200px; background-color: #ccc; } } Flex 布局 方案1：父元素设置 flex 布局，并设置主轴以及交叉轴的对齐方式：
.container { width: 500px; height: 500px; border: 1px solid #000; display: flex; justify-content: center; align-items: center; .content { width: 200px; height: 200px; background-color: #ccc; } } 方案2：父元素设置 flex 布局，子元素设置 margin: auto：
.container { width: 500px; height: 500px; border: 1px solid #000; display: flex; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/975da5765723d155f5ac163f5372a402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eed789233e3feda9df4259c233dce2d0/" rel="bookmark">
			ubuntu20.04 扩大交换空间swap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检查当前swap情况
free -m sudo swapon --show 关闭现有的swap
sudo swapoff -a 创建一个新的swap文件
sudo fallocate -l 32G /swapfile 设定正确的权限
sudo chmod 600 /swapfile 下面这个指令会把我们的空间变成可用的swap空间
sudo mkswap /swapfile 启用swap文件
sudo swapon /swapfile echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab sudo sysctl vm.swappiness=15 sudo sysctl vm.vfs_cache_pressure=50 检查是否设置成功
sudo swapon --show free -m 参考：
https://www.8kiz.cn/archives/11147.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf0d3103fac487d8961e3ccaa45916a3/" rel="bookmark">
			Python办公自动化 – 自动化文本翻译和Oracle数据库操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python办公自动化 – 自动化文本翻译和Oracle数据库操作 以下是往期的文章目录，需要可以查看哦。
Python办公自动化 – Excel和Word的操作运用
Python办公自动化 – Python发送电子邮件和Outlook的集成
Python办公自动化 – 对PDF文档和PPT文档的处理
Python办公自动化 – 对Excel文档和数据库的操作运用、设置计划任务
Python办公自动化 – 对CSV文件运用和管理文件 / 文件夹
Python办公自动化 – 对数据进行分析和制作图表数据
Python办公自动化 – 对图片处理和文件的加密解密
Python办公自动化 – 语音识别和文本到语音的转换
Python办公自动化 – 日志分析和自动化FTP操作
Python办公自动化 – 进行网络监控和处理压缩文件
Python办公自动化 – 文件的比较合并和操作xml文件
Python办公自动化 – 定时邮件提醒和音视频文件处理
Python办公自动化 – 处理JSOM数据和操作SQL Server数据库
Python办公自动化 – 人脸识别和自动化测试
Python办公自动化 – 操控远程桌面和文件版本控制
Python办公自动化 – 自动化清理数据和自动化系统命令
Python办公自动化 – 对数据进行正则表达式匹配
Python办公自动化 – 操作SQLite数据库和数据迁移
Python办公自动化 – 操作NoSQL数据库和自动化图像识别
Python办公自动化 – 数据预处理和数据校验
文章目录 Python办公自动化 – 自动化文本翻译和Oracle数据库操作前言一、使用Python进行自动化文本翻译方法1：使用Google翻译API（需要互联网连接）方法2：使用开源翻译库 二、Python操作Oracle数据库1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf0d3103fac487d8961e3ccaa45916a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d237e5c9bafd79605cdef719323eb4a3/" rel="bookmark">
			golang中的字符串拼接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go中常见的字符串拼接方法 假设我们现在要实现这样一个拼接函数： 将字符串重复n次拼接起来，返回一个新字符串。
方法一：使用+运算符 func simpleSplice(s string, n int) string { newStr := "" for i := 0; i &lt; n; i++ { newStr += s } return newStr } 方法二：使用Sprintf func sprintfSplice(s string, n int) string { newStr := "" for i := 0; i &lt; n; i++ { newStr = fmt.Sprintf("%s%s", newStr, s) } return newStr } 方法三：使用[]byte func bytesSplice(s string, n int) string { newStr := []byte{} for i := 0; i &lt; n; i++ { newStr = append(newStr, []byte(s).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d237e5c9bafd79605cdef719323eb4a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f3ca0c497b1849cc501bbc05dee6b36/" rel="bookmark">
			基于JAVA的婚恋交友网站 开源项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 数据中心模块2.2 会员管理模块2.3 新闻管理模块2.4 相亲大会管理模块2.5 留言管理模块 三、系统设计3.1 用例设计3.2 数据库设计3.2.1 会员信息表3.2.2 新闻表3.2.3 相亲大会表3.2.4 留言表 四、系统展示五、核心代码5.1 查询会员5.2 查询相亲大会5.3 新增留言5.4 查询留言5.5 查询新闻 六、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL的婚恋交友网站，包含了会员管理模块、新闻管理模块、相亲大会模块和留言板模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，婚恋交友网站基于角色的访问控制，给婚恋管理员、红娘老师使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 随着互联网的快速发展，婚恋交友网站成为了当今社会中重要的社交平台之一，从最初的在线聊天室到现在的大型社交平台，婚恋交友网站正不断地发展和完善自己的功能和服务，满足人们日益增长的需求。经过对婚恋交友网站的特点进行分析，发现匿名性、便捷性、多样性和互动性特点使得婚恋交友网站成为了一个非常有吸引力的社交平台，吸引了越来越多的用户进行使用。婚恋交友网站不仅满足了人们的社交需求，也有助于促进跨地域、跨文化的交流和理解，同时也带来了一定的负面影响，如虚假信息、网络诈骗等问题。婚恋交友网站是一个国际性的社交平台，在互联网时代发挥着越来越重要的作用。只有不断完善自身服务和管理规则，才能更好地发挥其正面作用，为人们创造更加多元化、便捷化、安全的社交环境。
婚恋交友网站的功能性需求主要包含数据中心模块、会员管理模块、新闻管理模块、相亲大会管理、留言管理模块这五大模块，是基于浏览器运行的web管理后端，其中各个模块详细说明如下。
2.1 数据中心模块 数据中心模块包含了婚恋交友网站的系统基础配置，如登录用户的管理、婚恋交友网站组织架构的管理、用户菜单权限的管理、系统日志的管理、公用文件云盘的管理。
组织架构，指的是婚恋交友网站运营公司的组织架构，该模块适用于管理这些组织架构的部门层级和员工的部门归属情况。
系统日志的管理，用于维护用户登入系统的记录，方便定位追踪用户的操作情况。
公用云盘管理模块，用于统一化维护婚恋交友网站中的图片，如会员的人脸照片、保密协议等等。
2.2 会员管理模块 会员管理模块用于对会员的数据进行管理，其中包括会员姓名、联系方式、照片、身高体重、户籍地、现居地、学历、职业等，红娘老师可以通过此模块对会员数据进行添加、编辑更新、删除、查询操作。
2.3 新闻管理模块 新闻管理模块用于对婚恋新闻的数据进行管理，其中包括新闻标题、新闻内容、发布状态、图片、排序值、备注、创建时间、创建人等，婚恋管理员可以通过此模块添加、编辑更新、删除、查询新闻数据。
2.4 相亲大会管理模块 相亲大会管理模块用于对相亲大会的数据进行管理，其中包括活动标题、活动内容、活动时间、活动地点、费用、备注、创建时间、创建人等，婚恋管理员可以通过此模块添加、编辑更新、删除、查询相亲大会数据。
2.5 留言管理模块 婚恋交友过程中难免会有一些咨询和纠纷，所以婚恋交友网站专门设计了留言板模块，用于解决相关纠纷，用户可以在留言板中留言，或对已留言的信息进行回复，其中包括咨询内容、咨询人、咨询时间、回复内容、回复人、回复时间、备注、创建时间等。
三、系统设计 3.1 用例设计 3.2 数据库设计 3.2.1 会员信息表 3.2.2 新闻表 3.2.3 相亲大会表 3.2.4 留言表 四、系统展示 五、核心代码 5.1 查询会员 @RequestMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f3ca0c497b1849cc501bbc05dee6b36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6e7c09b9727ed8fbf368bfbd2155a93/" rel="bookmark">
			【Android】Dialog弹出软键盘时把布局顶起来的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Android】Dialog弹出软键盘时把布局顶起来的实现 demo效果如下：
代码实现 class AICodeDialog(val activity: BaseActivity) : Dialog(activity),View.OnClickListener, AIRedPkgView { private lateinit var mBgView: View private lateinit var mClose: View private lateinit var mUse: View private lateinit var mEditText: McdEditTextView private var mCode: String? = null private var mPresenter: AIRedPkgPresenter? = null override fun show() { if (context is Activity &amp;&amp; ((context as Activity).isFinishing || (context as Activity).isDestroyed)) { return } mCode?.let { mEditText.setText(it.toCharArray(), 0, it.length) mEditText.setSelection(it.length) mCode = null } super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6e7c09b9727ed8fbf368bfbd2155a93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5683a98dfebb439a43343e495023feab/" rel="bookmark">
			Android Firebase （FCM）推送接入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档：
向后台应用发送测试消息 | Firebase Cloud Messaging
1、根级（项目级）Gradlegradle的dependencies中添加：
dependencies { ... // Add the dependency for the Google services Gradle plugin classpath 'com.google.gms:google-services:4.3.10' } 2、模块（应用级）Gradle 中添加 Google 服务插件：
plugins { id 'com.android.application' // Add the Google services Gradle plugin id 'com.google.gms.google-services' ... } 或者 apply { plugin 'com.android.application' // Add the Google services Gradle plugin plugin "com.google.gms.google-services" } 添加 Firebase Cloud Messaging Android 库的依赖项：（按官方的应该也是可以的）
implementation(platform("com.google.firebase:firebase-bom:32.3.1")) implementation("com.google.firebase:firebase-analytics-ktx") // implementation("com.google.firebase:firebase-auth-ktx") implementation("com.google.firebase:firebase-firestore-ktx") implementation("com.google.firebase:firebase-messaging") // Firebase Cloud Messaging (Kotlin) implementation("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5683a98dfebb439a43343e495023feab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35ee949fdc49a149428768e5542a3968/" rel="bookmark">
			Windows Copilot 更新及使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要更新并使用 Windows Copilot，在 Windows 11 上，首先确保您的系统已经更新到最新版本。Windows Copilot 是随 Windows 11 23H2 更新一起发布的新 AI 助手功能。它可以回答您的问题，完成任务，导航 Windows，并提高您的工作效率。
更新 Windows：首先，检查并更新您的 Windows 系统。
打开“开始”菜单，输入“设置”并打开。
在“设置”菜单中，转到“Windows 更新”部分。
检查系统是否有可用更新，如果有，请下载并安装。
启用 Windows Copilot：更新后，您可以在设置中启用 Windows Copilot。
返回到“设置”。
导航到“个性化”部分，然后选择“任务栏”。
在任务栏设置中找到 Windows Copilot 选项，并打开它。
使用 Windows Copilot：一旦启用，Windows Copilot 将出现在您的任务栏上。您可以通过单击任务栏上的“Copilot”图标或使用 Windows + C 快捷键启动它。
Copilot AI 是一个强大的工具，它使用自然语言处理来理解您的请求并提供有用的信息。您可以通过语音命令或文本输入与 Copilot 交互，它可以帮助您完成许多任务，如操作系统导航、技术问题排查、查找文档或文件以及执行生产力操作。
请注意，Copilot 目前在 Windows 11 的最新预览版 23H2 中自动可用，但仅在特定区域提供。如果您无法在任务栏中找到选项，可以在“设置” &gt; “个性化” &gt; “任务栏”中打开“Copilot”开关或使用 Windows + C 快捷键。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aec7ca257ecb4fdaf19e44a517da273/" rel="bookmark">
			Qt 对象树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是对象树 Qt中的对象树就是Qt中对象间的父子关系，每一个对象都有它所有子对象的指针，都有一个指向其父对象的指针。当创建对象在堆区时，如果指定的父亲是QObject派生下来的类或者是QObject的子类派生下来的类，当父对象被析构时子对象也会被析构。
二、示例 1.创建一个MyPushButton对象，继承QPushButton
2.在mypushbutton.cpp中对MyPushButton对象的构造和析构函数添加消息
#include "mypushbutton.h" #include&lt;QDebug&gt; MyPushButton::MyPushButton(QWidget *parent) : QPushButton(parent) { qDebug()&lt;&lt;"MyPushButton构造调用"; } MyPushButton::~MyPushButton() { qDebug()&lt;&lt;"MyPushButton析构"; } 3.在主窗口创建MyPushButton按钮的实例
#include "mainwindow.h" #include&lt;QPushButton&gt; #include"mypushbutton.h" #include&lt;QtDebug&gt; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { MyPushButton *mybtn=new MyPushButton; mybtn-&gt;resize(120,50); mybtn-&gt;setText("MyPushButton"); mybtn-&gt;move(200,0); mybtn-&gt;setParent(this); } MainWindow::~MainWindow() { } 4.在mainwindow.cpp中的MainWindow的析构函数里添加消息
MainWindow::~MainWindow() { qDebug()&lt;&lt;"mainwindow析构"; } 5.关闭主窗口，查看各对象析构的顺序
MyPushButton构造调用 mainwindow析构 //此时只是走到析构函数里打印了mainwindow析构，mainwindow还没有被析构掉 MyPushButton析构 6.正确的顺序应该是：关闭主窗口时，主窗口的析构函数被调用，然后主窗口会看自己有没有子对象，有的话先把他们析构了，最后再把自己析构。
本文福利，莬费领取Qt开发学习资料包、技术视频，内容包括（Qt实战项目视频教程+代码，C++语言基础，C++设计模式，Qt编程入门，QT信号与槽机制，QT界面开发-图像绘制，QT网络，QT数据库编程，QT项目实战，QSS，OpenCV，Quick模块，面试题等等）↓↓↓↓↓↓见下面↓↓文章底部点击莬费领取↓↓
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5bcb536094e053492b184afa8f7f10a/" rel="bookmark">
			C&#43;&#43; 面向对象五大原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，面向对象五大原则 1，理解设计模式与设计原则 软件设计原则： 原则为我们提供指南，它告诉我们什么是对的，什么是错的。它不会告诉我们如何解决问题。它仅仅给出一些准则，以便我们可以设计好的软件，避免不良的设计。
软件设计模式： 模式是在软件开发过程中总结得出的一些可重用的解决方案，它能解决一些实际的问题。一些常见的模式，比如工厂模式、单例模式等等。 封装、继承、多态只是类的三大特性，在程序设计时并不是说使用到了这三个特性就是面向对象，真正的面向对象的设计要满足下面五个原则。
2，单一功能原则 原理： 单一职责原则可以看作是低耦合、高内聚在面向对象原则上的引申，将功能定义为引起变化的原因，功能过多可能引起它变化的原因就越多，这将导致功能依赖，相互之间就产生影响，从而极大的损伤其内聚性和耦合度。因此不要为类实现过多的功能，以保证一个类只有一个引起它变化的原因。
class DBManager{ private: string userId; public: DBManager(const string &amp;str):userId(str){} void add(){ if(userId == "chongchong"){ //执行往数据库里添加数据的操作 } } }; 程序分析：
上面这个是很low的设计，如果验证用户权限的规则或数据库的操作发生改变，那就必须对DBManager类进行修改。权限判断的功能和数据库操作的功能被放在一个类中。我们可以使用Proxy模式，实现权限判断与数据库操作功能的分离。DBManager类实现数据库操作，代理Proxy类里面进行权限判断，下面这个是比较高大上的设计：
class Protocal{ public: virtual void add(); }; class DBManager : public Protocal{ private: string userId; public: DBManager(const string &amp;str):userId(str){} void add(){ //添加一条记录到数据库中 } }; class Proxy : public Protocal{ private: DBManager &amp;manager; public: Proxy(const DBManager &amp;db):manager(db){} void add(){ //先对用户的权限进行验证，然后再执行往数据库添加数据的操作 manager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5bcb536094e053492b184afa8f7f10a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76eb4c05b14c18ecd4da6cce84c9b119/" rel="bookmark">
			学会Python爬虫，你也能月薪过万！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年以来，很多求职者问的一个问题就是：疫情不是结束了吗，为什么感觉今年比去年更难了？
这是因为经济回暖中，各行各业的大地震无法避免，就业就成了滞后性指标。特别是很多中小企业，1个人能干的事，就裁了另外2个人；能招1个人，就不招2个人。
但大家也不需要太焦虑。不管怎样变化，机会都比努力重要。一个能及时抓住机会的人，一定很难被替代。
在这个人人焦虑，害怕被淘汰的时代，拥有第二收入，成了时代刚需。做自媒体，直播带货，看别人一夜暴富好像很容易，但是到自己这里却困难重重，想要门槛更低，更靠谱，更接地气的方式。
那普通人怎么选择做副业，既要能赚钱，还要可持续，所以好的副业应该具有这样3个特点：
第一，竞争小。 如果竞争太激烈，太卷了，就会有人打价格战，为了接单，疯狂降价，最后就是谁也挣不到钱；
第二，有门槛。 要想竞争不激烈，自然就需要有门槛，把一部分人拦在外面，需要的是你有别人没有或者较难习得的能力；
第三，可复用。 你要学会计算自己的时薪，不要耗费时间进行重复性劳动，最好是一份劳动可以多次销售。
如果你想学python来做副业，那么你必会的三个方向是：爬虫、数据分析、办公自动化。
其中爬虫是需求量最大也是价格相对较高的，在IT技术副业里，爬虫单子基本都占据了80％以上。
而且，通过Python爬虫接单赚钱，兼具竞争小、有门槛和可复用3个特点，是非常不错的选择。
大体上分为三类需求：
- 爬虫，单子最多，并不是所有的单子都需要逆向+APP爬虫的
- Excel自动化，数量其次，技术要求低一些
- Web开发，用Django、Flask即可，做小系统
去哪里接副业单子？
国内的接单网站，更推荐下面这4个：
① 程序员客栈
https://www.proginn.com
这是一个比较老牌的平台了，上面开发者数目相当多，无论是Java、C++这些热门语言，还是go、php这些比较小众的语言，都可以在上面接到单。收入还是不错的，而且有不少企业会在上面发包，想接单的程序员可以注册一个账号每天刷一刷。
② CODING 码市
https://mart.coding.net
Coding 旗下的互联网软件外包服务平台，平台以外包为主。码市的单量还可以，单子价格也有很多比较合适的。码市的平台费是10%，业界标准费率。
③ 开源众包
https://zb.oschina.net/
开源中国的众包平台，顾名思义平台多以外包为主，上面的协助开发工具是比较多的，可以试一试。**但是平台是通过竞价招标的方式来发包的，这种方式比较适合工作三到五年的程序员，**权当练手，如果是工作的比较久的程序员就没必要用这种方式，沉没成本会比较大。
④ 猪八戒
https://zbj.com
这个平台存在的时间也比较长了，上面的任务比较简单，如果你技术很好的话，有点大材小用的感觉。但是如果你还是个新人，多多尝试多多练练手是一个不错的选择。
再推荐2个国外的接单平台：
⑤ Upwork
https://www.upwork.com/
总部位于硅谷的自由职业独角兽平台，主要帮助公司寻找和管理自由职业者，小到个人或是创业公司，大到世界500强都会用来招聘自由职业者，任何个人或企业都能在平台找到合适的项目机会。
但是要注意一个问题，语言门槛比较高，建议英语比较好的去接单，否则会在沟通和交流上投入大量时间。
⑥ Freelancer
http://Freelancer.com
这也是个国外的网站，工作类型覆盖了很多不同的领域，有程序开发到市场营销、广告、会计、法务等一系列的可以远程的工作。但是相比upwork对我们可能会更友好，它有中文站点，语言门槛相对会低一点，操作也比较简单。
关于Python学习指南 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后给大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
包括：Python激活码+安装包、Python web开发，Python爬虫，Python数据分析，人工智能、自动化办公等学习教程。带你从零基础系统性的学好Python！
👉Python所有方向的学习路线👈 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取）
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
温馨提示：篇幅有限，已打包文件夹，获取方式在：文末 👉Python70个实战练手案例&amp;源码👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76eb4c05b14c18ecd4da6cce84c9b119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a5564ff510437f4995499e93288624/" rel="bookmark">
			java将word转换成pdf，并去除水印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意我这里只是将word字节替换成pdf字节，如果是文件根据自己实际情况来做 1、所需jar包 &lt;dependency&gt; &lt;groupId&gt;com.aspose&lt;/groupId&gt; &lt;artifactId&gt;aspose-words&lt;/artifactId&gt; &lt;version&gt;15.8.0&lt;/version&gt; &lt;/dependency&gt; 2、去除水印配置文件，此文件放到resource文件夹下，如图 3、license配置文件 &lt;License&gt; &lt;Data&gt; &lt;Products&gt; &lt;Product&gt;Aspose.Total for Java&lt;/Product&gt; &lt;Product&gt;Aspose.Words for Java&lt;/Product&gt; &lt;/Products&gt; &lt;EditionType&gt;Enterprise&lt;/EditionType&gt; &lt;SubscriptionExpiry&gt;20991231&lt;/SubscriptionExpiry&gt; &lt;LicenseExpiry&gt;20991231&lt;/LicenseExpiry&gt; &lt;SerialNumber&gt;8bfe198c-7f0c-4ef8-8ff0-acc3237bf0d7&lt;/SerialNumber&gt; &lt;/Data&gt; &lt;Signature&gt; sNLLKGMUdF0r8O1kKilWAGdgfs2BvJb/2Xp8p5iuDVfZXmhppo+d0Ran1P9TKdjV4ABwAgKXxJ3jcQTqE/2IRfqwnPf8itN8aFZlV3TJPYeD3yWE7IT55Gz6EijUpC7aKeoohTb4w2fpox58wWoF3SNp6sK6jDfiAUGEHYJ9pjU= &lt;/Signature&gt; &lt;/License&gt; 4、核心代码 @Componet @Slf4j public class FileUtil { @Autowired private ResourceLoader resourceLoader; /** * 去除水印校验 */ public boolean getLicense() { boolean result = false; try { Resource resource = resourceLoader.getResource("classpath:/license.xml"); License aposeLic = new License(); aposeLic.setLicense(is); result = true; } catch (Exception e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2a5564ff510437f4995499e93288624/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9303985074e567c6fda56ed46456b044/" rel="bookmark">
			关于LINUX操作系统异常宕机重启的分析思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、先搞清楚现状 当收到系统宕机告警或者故障反馈时，需要先对情况进行核实。比如检查系统启动时间，是不是真实发生了重启？如果重启了，什么时间点发生的重启？重启了几次？重启之前有无变更操作？主机上运行的是哪一类应用？重启的主机是物理机还是虚拟机？等等情况，有助于对于故障的分析处理。
可以如下检查：
1、last查看机器最近重启时间，以及重启次数
2、确认重启后，查看主机是物理机还是虚拟机
dmidecode -t 1
3、检查看看是否有人为重启的动作，如果配置了命令审计，可以从message日志中看是否有人敲过reboot命令。或者用history命令也可以看到一些，但有时不一定会有记录下来。
主机命令审计配置和查看可参考这篇文章《LINUX加固之命令审计》
LINUX加固之命令审计-CSDN博客
4、检查看看主机上都跑了些啥？例如oracle、mysql、ha、vcs等高可用集群软件相关的 。
二、硬件故障排查 在第一步做了相关检查后，确认是发生重启了，并且还是物理机，可以考虑是否硬件故障导致（硬件类内存、cpu故障频率高）。系统内可以通过ipmitool工具检查如下:
--安装工具
yum install OpenIPMI ipmitool -y
modprobe ipmi_watchdog
modprobe ipmi_poweroff
modprobe ipmi_devintf
modprobe ipmi_si
modprobe ipmi_msghandler
--查看日志
ipmitool sel list
如果看到类似CPU或内存异常日志，同时时间点和机器重启时间对应上，那就是重启原因。
PS：硬件类问题机房值守人员可以现场查看和报修厂家检查，系统内ipmitool工具是个补充手段，方便远程轻松查看。如果ipmitool查看未有明显报错，也未必硬件一定都正常，建议还需要进行报修原厂，再进一步深度检查。
三、系统内dump日志检查 如果硬件类排查没什么问题或者是个虚拟机，可以进行系统内的日志分析，首先应该看看是否有产生dump日志。参考如下：
cd /var/crash目录下，看是否有生成crash日志目录产生，如下图有个127.0.0.1开头的目录
进到目录里就会有vmcore的dump日志，重启的原因就可以从dump日志找到蛛丝马迹。
crash日志分析可参考这篇《LINUX常用工具之kdump》
LINUX常用工具之kdump分析-CSDN博客
四、系统日志及性能检查 如果硬件日志和crash日志检查了都还没有收获，接下来要对系统日志及相关性能进行复盘检查，检查分析看看故障重启前，主机负载有没有突增，日志中有无异常类报错。可参照如下：
1、性能检查 这部分大部分系统应该都会接入到监控网管中心，可从监控中心去找下历史指标趋势，重点关注CPU、内存、磁盘IO、网络等指标是否有突增情况。
如果不具备监控中心的，或者故障前相关指标没采集到（监控采集有个时间差，瞬间的问题可能未必会捕捉到）；可以从系统sar日志取查找相关信息
cd /var/log/sa,每天的系统监控会写到当天日期的sa文件中，例如11号的性能日志，可以查看sa11或者sar11文件。(注：sar文件可以直接读取，sa文件需要用sar命令加上-f参数指定具体sa文件读取内容)
关于sa文件的查看可以man 下sar去看看参数，例如
-A：所有报告的总和
-u：输出CPU使用情况的统计信息
-v：输出inode、文件和其他内核表的统计信息
-d：输出每一个块设备的活动信息
-r：输出内存和交换空间的统计信息
-b：显示I/O和传送速率的统计信息
-a：文件读写情况
-c：输出进程统计信息，每秒创建的进程数
-R：输出内存页面的统计信息
-y：终端设备活动情况
-w：输出系统交换活动信息
示例：查看11号当天故障某个时间点cpu情况，就可以用
sar -u -f sa11
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9303985074e567c6fda56ed46456b044/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7262be0b22b54fffb8bb0ca8a602ad83/" rel="bookmark">
			一小时掌握：使用ScrapySharp和C#打造新闻下载器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 爬虫技术是指通过编程的方式，自动从互联网上获取和处理数据的技术。爬虫技术有很多应用场景，比如搜索引擎、数据分析、舆情监测、电商比价等。爬虫技术也是一门有趣的技术，可以让你发现网络上的各种有价值的信息。
本文将介绍如何使用ScrapySharp和C#语言，打造一个简单的新闻下载器，可以从指定的新闻网站上抓取新闻标题、摘要、正文、作者、发布时间等信息，并保存到本地文件中。本文的目的是让你在一小时内掌握ScrapySharp和C#的基本用法，以及爬虫技术的基本原理和技巧。
ScrapySharp和C#的介绍 ScrapySharp是一个基于.NET的爬虫框架，它提供了一系列的类和方法，可以方便地实现爬虫的功能，比如发送请求、解析响应、提取数据、保存数据等。ScrapySharp的核心类是ScrapingBrowser，它模拟了一个浏览器的行为，可以执行JavaScript、处理Cookie、设置代理等。ScrapySharp还支持CSS选择器和XPath语法，可以灵活地定位网页中的元素。
C#是一种面向对象的编程语言，它是.NET平台的主要语言，可以运行在Windows、Linux、Mac等操作系统上。C#语言简洁、强大、高效，拥有丰富的类库和工具，可以开发各种类型的应用程序，包括桌面应用、网站、移动应用、游戏等。C#还支持多线程编程，可以充分利用CPU的资源，提高程序的性能。
新闻下载器的设计 本文的新闻下载器的设计思路如下：
首先，定义一个News类，用来存储新闻的各种属性，比如标题、摘要、正文、作者、发布时间等。然后，定义一个NewsDownloader类，用来实现新闻下载器的主要逻辑，包括以下几个方法： 构造方法，用来初始化ScrapingBrowser对象，设置代理、超时、用户代理等参数。GetNewsUrls方法，用来从指定的新闻网站的首页上，获取所有新闻的链接，并返回一个字符串列表。GetNewsContent方法，用来从指定的新闻链接上，获取新闻的内容，并返回一个News对象。SaveNews方法，用来将一个News对象保存到本地文件中，文件名为新闻的标题，文件格式为txt。DownloadNews方法，用来下载所有新闻，并保存到本地文件夹中，文件夹名为新闻网站的域名。 最后，定义一个Program类，用来作为程序的入口，创建一个NewsDownloader对象，并调用其DownloadNews方法，传入要爬取的新闻网站的地址。 新闻下载器的代码 本文的新闻下载器的代码如下：
using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Net; using System.Text; using System.Threading.Tasks; using HtmlAgilityPack; using ScrapySharp.Extensions; using ScrapySharp.Network; namespace NewsDownloader { // 定义一个News类，用来存储新闻的各种属性 public class News { public string Title { get; set; } // 标题 public string Summary { get; set; } // 摘要 public string Content { get; set; } // 正文 public string Author { get; set; } // 作者 public string Time { get; set; } // 发布时间 } // 定义一个NewsDownloader类，用来实现新闻下载器的主要逻辑 public class NewsDownloader { private ScrapingBrowser browser; // 定义一个ScrapingBrowser对象，用来模拟浏览器的行为 //亿牛云 设置爬虫代理加强版 private string proxyDomain = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7262be0b22b54fffb8bb0ca8a602ad83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b285067311720d55bf939f6e0e6f4669/" rel="bookmark">
			数据结构实验5：二叉树的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实验目的
二、实验原理
1. 基本概念
2. 基本操作
2.1 二叉数的定义
2.2 二叉树的建立
2.2.1 创建新节点
2.2.2 建立二叉树
2.3 二叉树的遍历
2.3.1 先序遍历(NLR)
2.3.2 中序遍历(LNR)
2.3.3 后序遍历(LRN)
2.3.4 层次遍历
2.4 二叉树的节点个数统计
2.5 二叉树的深度计算
三、实验内容
问题描述
代码
截图
一、实验目的 1、掌握二叉树的定义；
2．掌握二叉树的基本操作，如二叉树的建立、遍历、结点个数统计、树的深度计
算等。
二、实验原理 1. 基本概念 节点（Node）： 二叉树的基本单元是节点。每个节点包含一个数据元素和指向左子节点和右子节点的指针。
根节点（Root）： 树的顶部节点称为根节点。每个二叉树只有一个根节点。
叶节点（Leaf）： 没有子节点的节点称为叶节点，也叫终端节点。它们是树结构的末端。
父节点（Parent）和子节点（Child）： 一个节点的直接上级是其父节点，而直接下级是其子节点。每个节点最多有一个父节点，但可以有零个、一个或两个子节点。
子树（Subtree）： 由一个节点及其所有后代节点组成的树称为子树。
深度（Depth）： 一个节点的深度是指从根节点到该节点的路径的长度。根节点的深度为0。
高度（Height）： 一棵树的高度是指树中任意节点的最大深度。也就是说，树的高度是从根节点到最深叶节点的最长路径。
层次（Level）： 一棵树的层次是指树中的节点分布在哪一层。根节点在第一层，其子节点在第二层，以此类推。
二叉搜索树（Binary Search Tree，BST）： 是一种特殊的二叉树，其中每个节点的左子树中的所有节点的值都小于该节点的值，而右子树中的所有节点的值都大于该节点的值。
遍历（Traversal）： 访问二叉树中所有节点的一种方式。常见的遍历方式有前序遍历、中序遍历和后序遍历。
2. 基本操作 2.1 二叉数的定义 空二叉树（Empty Binary Tree）： 一个二叉树可以是空的，即不包含任何节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b285067311720d55bf939f6e0e6f4669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1e8d788e0a08891cdea5d27ec4e06d7/" rel="bookmark">
			Windows cmd net 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、net view 用法 1、查看局域网内计算机
net view 2、主名机查 MAC 地址
nbtstat -a hostname 3、查看 IP 与 MAC 地址映射表 来获取 IP
arp -a 4、根据 IP 查主机名
nbtstat -A IP 二、net use 用法 1、建立非空连接 net use \\10.3.0.39\ipc$ "passwd" /user:"username" 2、建立连接后，并映射 z 盘
net use z: \\10.3.0.39\Public "passwd" /user:"username" 3、建立连接后，映射 z 盘，并修改文件夹名
net use z: \\10.3.0.39\Public "passwd" /user:"username" # 修改文件夹名 reg add "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MountPoints2\##10.3.0.39#Public" /v "_LabelFromReg" /d "Public" /f 4、 查看连接
net use # 会记录新的网络连接。 状态 本地 远程 网络 ------------------------------------------------------------------------------- OK Z: \\10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1e8d788e0a08891cdea5d27ec4e06d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7455e8c28a5e21fa8b1a75dfeaa1c6fb/" rel="bookmark">
			基于ssm的班级事务管理系统&#43;vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收藏关注不迷路，源码文章末
文章目录 前言一、项目介绍二、开发环境三、功能介绍四、核心代码五、效果图六、文章目录 前言 班级事务管理系统通过MySQL数据库与Eclipse工具进行开发，班级事务管理系统能够实现奖惩管理，成绩管理，班级管理，请假管理，作业管理，考勤管理等功能。
通过班级事务管理系统对相关信息的处理，让信息处理变的更加的系统，更加的规范，这是一个必然的结果。已经处理好的信息，不管是用来查找，还是分析，在效率上都会成倍的提高，让计算机变得更加符合生产需要，变成人们不可缺少的一种信息处理工具，实现了绿色办公，节省社会资源，为环境保护也做了力所能及的贡献。
关键字：班级事务管理系统，奖惩，成绩，请假
一、项目介绍 本系统在功能分析上，主要是根据目标用户群的角度进行分析，为了便于展示分析结果，这里就使用用例图进行功能展示。
管理员用例图的绘制结果见图3-5。管理员登录进入本系统操作的功能包括管理考勤，奖惩，请假，成绩，班级以及老师，学生，作业等信息。
图3-5 管理员用例图
老师用例图的绘制结果见图3-6。老师登录进入本系统操作的功能包括审核请假，管理作业，管理成绩，管理奖惩和考勤。
图3-6 老师用例图
学生用例图的绘制结果见图3-7。学生登录进入本系统操作的功能包括查看成绩，考勤，奖惩信息，下载作业，申请请假等。
图3-7 学生用例图
二、开发环境 开发语言：Java
框架：ssm
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven
————————————————
三、功能介绍 本系统主要是基于数据的增加，修改，删除等操作，使用者能够通过提前设定的登录功能进入指定的操作区，这里对使用者设计的功能进行结构展示。
管理员功能结构图的绘制结果见图4-1。管理员登录进入本系统操作的功能包括管理考勤，奖惩，请假，成绩，班级以及老师，学生，作业等信息。
图4-1 管理员功能结构图
老师功能结构图的绘制结果见图4-2。老师登录进入本系统操作的功能包括审核请假，管理作业，管理成绩，管理奖惩和考勤。
图4-2 老师功能结构图
学生功能结构图的绘制结果见图4-3。学生登录进入本系统操作的功能包括查看成绩，考勤，奖惩信息，下载作业，申请请假等。
图4-3 学生功能结构图
四、核心代码 部分代码：
package com.example.controller; import cn.hutool.core.util.StrUtil; import cn.hutool.crypto.SecureUtil; import com.example.common.Result; import com.example.common.ResultCode; import com.example.entity.Caiwu; import com.example.exception.CustomException; import com.example.service.CaiwuService; import com.example.utils.MapWrapperUtils; import com.example.utils.jwt.JwtUtil; import com.example.vo.CaiwuVo; import org.springframework.beans.BeanUtils; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7455e8c28a5e21fa8b1a75dfeaa1c6fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9e8b7fd3f4d12cb3c0d3b902bae4db9/" rel="bookmark">
			GO项目自动化-根据库表字段自动生成API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据库表字段自动生成API 一个项目开发离不开数据库的增删改查，API功能也基本围绕着表的CRUD：增加(Create)、读取(Read)、更新(Update)和删除(Delete)。每个表写一个CRUD，方法都差不多，逻辑也非常相似。
那么有没有可能根据表结构直接自动化生成各个表的CRUD呢？
当然可以，前几篇文章已经介绍了golang的API项目搭建和数据库操作，那么本篇直接一个飞跃成长，项目自动化生成。
生成代码尽量简洁，方便根据项目实际需求二次开发。
API规则 首先建立好规则，方便生成逻辑统一的CRUD：
1.数据库表结构规则 id为int类型自增数值都有创建、更新时间，字段名固定为created_at,updated_at，且为int64类型，存值为时间戳都有状态字段，字段名固定为status，int类型，初始值为0，删除为-1 2.CRUD规则 Create时，除了id、status,created_at,updated_at，其他字段都作为入参，入库时初始status为0，创建、更新时间为当前时间戳Read时，带分页功能，分页参数统一为：limit（每页条数）、offset（第几页，从1开始），响应所有表字段原始数据Update时，必传id参数，除status,created_at,updated_at外的其他字段都可更改，更新时间自动设置为当前时间戳Delete时，必传id参数，status设置为-1，更新时间自动设置为当前时间戳 cli使用 下载cli源码
https://github.com/liyonge-cm/go-api-cli 编译可执行文件
go build 按规则创建库表
修改配置文件
修改config/config.yml的配置信息
mysql: mysql连接配置 frame: out_path: 项目文件所在位置 prj_name: 项目名称 json_case: api入参处参的json格式：camel-驼峰，默认下划线 api: tables: - user 指定生成API的表 创建项目
执行编辑文件创建项目 go-cli -g frame 或直接运行main文件
go run main.go -g frame 生成API
执行编辑文件生成API go-cli -g api 或直接运行main文件
go run main.go -g api 启动生成的新项目 进入项目文件: cd xxx/prj-aiee-api(配置文件中的项目地址)下载依赖包: go mod tidy修改配置config，数据库连接地址等启动: go run main.go
就可以调用API就行增删改查了 api 风格 API method统一为post，body以json入参。如 curl -X POST "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9e8b7fd3f4d12cb3c0d3b902bae4db9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/569ca850465e95e2f7f6c9eef8e6c35d/" rel="bookmark">
			如何在 Microsoft Edge 浏览器中启用自动刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你是否经常发现自己在使用 Microsoft Edge 时点击刷新按钮？如果您需要一个网页以设定的时间间隔自动更新，那么请接着往下看。
在这篇博文中，我们探讨如何在 Microsoft Edge 浏览器中启用和管理自动刷新功能。
为什么选择自动刷新？ 自动刷新可以成为各种方案的便捷工具。无论您是跟踪实时体育比分、监控股价还是关注突发新闻，启用自动刷新都可以为您省去手动更新网页的麻烦。
如何启用自动刷新 截至目前，Microsoft Edge不提供内置的自动刷新功能。但是，您可以使用第三方扩展轻松实现此功能。
使用扩展 打开 Microsoft Edge 扩展商店 打开 Edge 浏览器并转到扩展商店。您可以通过单击右上角的三个水平点并选择“扩展”来到达那里。出现一个新窗口，然后单击“打开 Microsoft Edge 加载项网站”。
搜索自动刷新扩展 在扩展商店中，搜索“自动刷新”。您将看到几个选项;选择一款适合您的需求并有好评的。很棒的自动刷新是一个不错的选择。
安装扩展 单击所选扩展名，然后单击“获取”。按照屏幕上的说明安装扩展程序。
配置设置 安装扩展程序后，转到要启用自动刷新的网站，然后单击该扩展程序。然后，您可以添加、删除和管理用于配置刷新间隔的计时器。您通常可以根据需要选择从几秒到几分钟的时间间隔。
使用自动刷新的提示 明智地选择扩展程序：始终选择经过充分审查的扩展程序，以确保它们安全有效。检查兼容性：确保您选择的扩展程序与最新版本的 Microsoft Edge 兼容。监视 CPU 使用率：自动刷新多个选项卡可能会消耗更多 CPU。密切关注系统性能。 虽然 Microsoft Edge 本身不支持自动刷新，但可以通过第三方扩展轻松添加此功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4904a4aedd2f7ce468127885d758175a/" rel="bookmark">
			HTML date类型数前后端互传，页面显示date类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 springMVC+thymeleaf+HTML(date)
1.实体类定义字段为date类型
private Date bizdate; 2.前端HTML中input的date类型
&lt;div class="form-group"&gt; &lt;label for="bizdate"&gt;请输入交易日期&lt;/label&gt; &lt;input type="date" class="form-control" id="bizdate" placeholder="name" name="bizdate"&gt; &lt;/div&gt; 3.前端提交到后端用实体类接收时，实体类中的字段要加@DateTimeFormat(pattern = “yyyy-MM-dd”)
@DateTimeFormat(pattern = "yyyy-MM-dd") private Date bizdate; 4.后端查出来数据赋值给前端时，添加th:value=“${#dates.format(incomeDetail.bizdate, ‘yyyy-MM-dd’)}”
input中如下 &lt;div class="form-group"&gt; &lt;label for="bizdate"&gt;请输入交易日期&lt;/label&gt; &lt;input type="date" class="form-control" id="bizdate" placeholder="name" name="bizdate" th:value="${#dates.format(incomeDetail.bizdate, 'yyyy-MM-dd')}"&gt; &lt;/div&gt; 列表中如下： &lt;td th:text="${#dates.format(incomeDetail.bizdate, 'yyyy-MM-dd')}"&gt;&lt;/td&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbdf00fa7c8606b479e20d567240c225/" rel="bookmark">
			离线CSDN文章打开后自动跳转网页的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方案如下：
步骤1：使用文本打开html文件步骤2：搜索onerror步骤3：删除其所在行（主要是删除window.location.href字符串所在行），并保存文件 参考链接：
https://blog.csdn.net/qq_43987286/article/details/121461740 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b41503fad8cf994d416abe2d1b95872/" rel="bookmark">
			如何在 Ubuntu 20.04 上安装 Node.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个人工智能学习网站，通俗易懂，风趣幽默，最重要的屌图甚多，忍不住分享一下给大家。点击跳转到网站。
如何在 Ubuntu 20.04 上安装 Node.js 介绍 Node.js是用于服务器端编程的 JavaScript 运行时。它允许开发人员使用 JavaScript 创建可扩展的后端功能，这是许多人在基于浏览器的 Web 开发中已经熟悉的语言。
在本文中，我们将展示在 Ubuntu 20.04 服务器上安装 Node.js 的三种不同方法：
用于从 Ubuntu 的默认软件存储库apt安装软件包nodejsapt与备用 PPA 软件存储库一起使用来安装nodejs包的特定版本安装Node 版本管理器nvm，并使用它来安装和管理 Node.js 的多个版本 对于许多用户来说，使用apt默认存储库就足够了。如果需要特定的较新或旧版本的 Node，则应使用 PPA 存储库。如果正在积极开发 Node 应用程序并需要node频繁地在版本之间切换，请选择nvm方法。
笔记 本文将引导完成在 Ubuntu 服务器上安装 Node.js。
先决条件 要遵循本本，需要设置 Ubuntu 20.04 服务器。在开始之前，应该拥有一个在系统上设置了权限的非root用户帐户。可以按照Ubuntu 20.04 初始服务器设置教程来了解如何执行此操作。
选项 1 — 使用 Apt 从默认存储库安装 Node.js Ubuntu 20.04 在其默认存储库中包含 Node.js 版本，可用于跨多个系统提供一致的体验。本文将使用版本为 10.19。
警告： Ubuntu 20.04 版本 10.19 中包含的 Node.js 版本现在不受支持和维护。不应在生产中使用此版本，而应参考本教程中的其他部分之一来安装更新版本的 Node.js。
要获取此版本，可以使用apt包管理器。首先刷新本地包索引：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b41503fad8cf994d416abe2d1b95872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f7fb22f76b90701a19315742b1a857/" rel="bookmark">
			No module named ‘fcntl‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题详情 (base) PS D:\yolov5-master_head&gt; gunicorn -c gunicorn.py wsgi:app Traceback (most recent call last): File "&lt;frozen runpy&gt;", line 198, in _run_module_as_main File "&lt;frozen runpy&gt;", line 88, in _run_code File "C:\Users\wh109\AppData\Roaming\Python\Python311\Scripts\gunicorn.exe\__main__.py", line 4, in &lt;module&gt; File "C:\Users\wh109\AppData\Roaming\Python\Python311\site-packages\gunicorn\app\wsgiapp.py", line 9, in &lt;module&gt; from gunicorn.app.base import Application File "C:\Users\wh109\AppData\Roaming\Python\Python311\site-packages\gunicorn\app\base.py", line 11, in &lt;module&gt; from gunicorn import util File "C:\Users\wh109\AppData\Roaming\Python\Python311\site-packages\gunicorn\util.py", line 8, in &lt;module&gt; import fcntl ModuleNotFoundError: No module named 'fcntl' 解决方法 这个库是不支持Windows，Windows 系统开发的时候，如果使用了这个库，就会产生一些错误，需要新建一个fcntl.py文件，插入代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6f7fb22f76b90701a19315742b1a857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce8f6f6ec960006c38525913cdc2a291/" rel="bookmark">
			社区论坛小圈子小程序源码系统：自定义小程序管理 带完整的安装代码包以及搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动互联网的快速发展，微信小程序作为一种新型的应用形态，已经深入到人们的生活中。特别是对于社区论坛类应用，小程序版本可以更好地满足用户快速、便捷获取信息的需求。下面罗峰给大家分享一款社区论坛小圈子小程序源码系统，带有完整的搭建教程。
以下是部分代码示例：
系统功能特点：
1.自定义小程序管理：本系统提供完整的后台管理功能，开发者可以根据自己的需求进行定制和修改，包括但不限于论坛版块管理、帖子管理、用户管理等功能。后台管理界面简洁明了，操作方便，大大降低了开发门槛。
2.完整的安装代码包：本系统提供完整的安装代码包，包括小程序前端代码、后端服务代码以及数据库结构等。开发者只需按照说明进行安装和配置，即可快速搭建起一个功能完备的社区论坛小程序。
3.丰富的功能模块：本系统集成了社区论坛常见的功能模块，如帖子发布、评论、点赞、私信等，同时支持图片、视频等多媒体内容发布。此外，还提供了会员系统、积分系统、消息通知等功能，以满足不同用户的需求。
4.高效的搜索功能：为了方便用户快速找到感兴趣的内容，本系统提供了高效的搜索功能。用户可以通过关键词搜索帖子、版块甚至用户，大大提高了用户体验。
5.完善的权限管理：为了确保社区的安全和秩序，本系统提供了完善的权限管理功能。管理员可以根据需要设置不同的用户角色，如普通用户、版主、超级管理员等，并对不同角色赋予不同的权限。
6.强大的数据分析功能：本系统集成了数据分析模块，可以对用户行为、帖子热度等进行实时监控和分析，为开发者提供科学的数据支持，帮助其更好地了解用户需求和市场趋势。
页面展示：
源码下载地址：春哥技术博客或帮企商城获取。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4137ea9d5f6aa7275b106b5ab266da6a/" rel="bookmark">
			ceph、gluster、longhorn选型对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ceph Ceph是一个分布式的存储系统，可以在统一的系统中提供唯一的对象、块和文件存储。
名词解释：
RADOS： 由自我修复、自我管理、智能存储节点组成的可靠、自主、分布式对象存储LIBRADOS： 一个允许应用程序直接访问 RADO 的库，支持 C、C++、Java、Python、Ruby 和 PHPRADOSGW： 基于存储桶的 REST网关，兼容s3和SwiftRBD： 一个负责任的，完全-分布式块设备，使用Linux内核cliont和QEMU/KVM驱动程序CEPHFS： 符合POSIX标准的分发文件系统，具有Linux内核客户端和对FUSE的支持 进程结构：
1. Ceph监视器(ceph-mon)：用来维护集群状态的映射，包括监视器映射，管理器映射，OSD映射，MDS映射和CRUSH映射，这些映射是ceph守护程序相互协调所需的关键状态，另外还负责客户端到ceph存储的身份验证；通常要实现高可用，需要3个或以上的ceph-mon服务2. Ceph管理器(ceph-mgr)：ceph manager守护进程负责跟踪运行时指标和ceph集群当前的状态，包括存储利用率，当前性能指标和系统负载等，ceph-mgr还托管一些python模块，以实现基于web的ceph仪表盘和rest api，通常要实现高可用至少需要2个ceph-mgr进程，通常ceph-mon和ceph-mgr个数相同，1个ceph-mon同节点会伴随1个ceph-mgr守护进程。Mgr有主从之分。3. Ceph对象存储(ceph-osd)：Ceph OSD是对象存储守护程序，是用来存储数据的核心组件，实现数据存储、数据复制和恢复、数据的重新平衡，并会检查其他Ceph OSD守护程序的心跳来向ceph-mon和ceph-mgr提供一些监控信息，通常至少需要3个ceph-osd才能实现冗余和高可用性，部署的时候ceph-osd会和ceph-mon分开节点部署.4. Ceph元数据服务(ceph-mds)：Ceph MDS为ceph文件系统存储元数据，注意Ceph块设备和对象存储不用mds存储元数据，Ceph MDS允许POSIX文件系统用户执行基本命令，而不会将压力都集中到Ceph OSD集群上，通常mds可以选择部署至少2个节点，可以和其他组件一起也可以分开。Mds有主从之分。 存储过程：首先osd需要干净的磁盘或分区。为文件计算一个值，根据值放在某个pg上（pg属于某个osd），文件的其他副本放到其他osd上。
文件实际是使用对象存储存到osd上，因为脱离了linux文件系统，所以无法在磁盘直观的看到文件，只能通过ceph挂载查看。
Gluster Gluster 是一个可扩展的分布式文件系统。有点像nfs，可以把gluster-server所在节点的目录作为存储目录，gluster-client进行挂载。
进程结构：gluster-server进程，gluster-client进程。
卷类型：
分布卷：如文件1放在节点1，文件2放在节点2。复制卷，有两个server节点，文件1在两个节点都存有一份文件。分散卷：文件1分成两块，一块放在节点1，另一块放在节点2，这样读写更快。分布复制卷：节点 1234，文件1在节点12，文件2在节点34。分布分散，节点1234，文件1的两块各在12，文件2的两块各在34。 高可用gluster-server部署两个以上的节点，gluster-server没有主从之分、是对等的。通过复制卷可以实现数据高可用，一个文件分别存在两个节点上，有一个节点宕机，文件依然能正常读写。
Longhorn Longhorn 是一款Kubernetes 分布式块存储系统。只能用k8s部署。
进程结构：
Longhorn Backing Image Manager：支持磁盘中的备份映像下载、同步和删除Longhorn Engine：核心控制器/副本逻辑。每个卷对应一个engine。Longhorn Instance Manager：控制器/副本实例生命周期管理Longhorn Manager：Longhorn 编排，包括适用于 Kubernetes 的 CSI 驱动程序Longhorn Share Manager：NFS 置备程序，将 Longhorn 卷公开为 ReadWriteMany 卷Longhorn UI：NFS 置备程序，将 Longhorn 卷公开为 ReadWriteMany 卷 高可用：卷有多个副本（可设置），卷默认目录/var/lib/longhorn，进程pod在各节点都有运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4137ea9d5f6aa7275b106b5ab266da6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e97df165a5a7e58d8b4f303a8c2ea3/" rel="bookmark">
			鸿蒙HarmonyOS兼容JS的类Web开发-开发指导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鸿蒙HarmonyOS兼容JS的类Web开发-开发指导 文章目录 鸿蒙HarmonyOS兼容JS的类Web开发-开发指导常用组件开发指导list开发指导创建list组件添加滚动条添加侧边索引栏实现列表折叠和展开场景示例 dialog开发指导创建dialog组件设置弹窗响应场景示例 form开发指导创建form组件实现表单缩放设置form样式添加响应事件场景示例 stepper开发指导创建stepper组件设置index属性设置样式添加事件场景示例 tabs开发指导创建tabs设置样式显示页签索引场景示例 swiper开发指导创建swiper组件添加属性设置样式绑定事件场景示例 Canvas开发指南Canvas对象创建Canvas组件添加样式添加事件 2D对象画线段画边框填充渐变色填充文字添加图片添加方法画线段画图形判断位置 Svg开发指导基础知识创建Svg组件设置属性 绘制图形绘制路径绘制文本文本沿路径绘制文本 动效开发指导属性样式动画transform样式动画设置静态动画设置平移动画设置旋转动画设置缩放动画设置matrix属性整合transform属性 background-position样式动画svg动画属性样式动画路径动画animateTransform动画 JS动画组件动画获取动画对象设置动画参数 插值器动画创建动画对象添加动画事件和调用接口 动画帧请求动画帧取消动画帧 常用组件开发指导 list开发指导 list是用来显示列表的组件，包含一系列相同宽度的列表项，适合连续、多行地呈现同类数据。具体用法请参考list API。
创建list组件 在pages/index目录下的hml文件中创建一个list组件。
&lt;!-- xxx.hml --&gt; &lt;div class="container"&gt; &lt;list&gt; &lt;list-item class="listItem"&gt;&lt;/list-item&gt; &lt;list-item class="listItem"&gt;&lt;/list-item&gt; &lt;list-item class="listItem"&gt;&lt;/list-item&gt; &lt;list-item class="listItem"&gt;&lt;/list-item&gt; &lt;/list&gt; &lt;/div&gt; /* xxx.css */ .container { width:100%; height:100%; flex-direction: column; align-items: center; background-color: #F1F3F5; } .listItem{ height: 20%; background-color:#d2e0e0; margin-top: 20px; } 说明
是的子组件，实现列表分组功能，不能再嵌套，可以嵌套。是的子组件，展示列表的具体项。 添加滚动条 设置scrollbar属性为on即可在屏幕右侧生成滚动条，实现长列表或者屏幕滚动等效果。
&lt;!-- xxx.hml --&gt; &lt;div class="container"&gt; &lt;list class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3e97df165a5a7e58d8b4f303a8c2ea3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eef6539f89ebec7f9daf9b03a983d55/" rel="bookmark">
			从0开始python学习-47.pytest框架之解决Template替换无法进行二次处理的问题之热加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：当参数为动态参数时，Template替换无法进行二次处理
解决方案：通过热加载来进行替换
热加载原理：在代码运行的过程中动态的调用python中的方法达到获得动态参数
可以进行热加载的情况：yaml文件，随机数，替换后的值进行计算，加密等
示例：
需要热加载的数据：
yaml数据：extract.yaml
token: 76_ZgYcDxWFgCCjZVj2EPfqj7QWW_k3-iUZq68Mr6hE_VvDDa_IAfjEIi7nQwMUoISer8MAspesP1JnP1iIziezVPcB4jqZs4z_3EQpVtkEVm0Z0L7VyTmQV7JC0gsTYGaAAAPUC 需要操作的数据
class DeBugTalk: #场景一：读取yaml中的数据 def read_yaml(self,key): with open("D:\study\pytest\extract.yaml", encoding="utf-8") as f: value = yaml.safe_load(f) return value[key] # 场景二：数据计算 def add(self,a,b): return str(int(a)+int(b)) # 场景三：读取随机数 def random(self): return str(random.randint(1, 10)) 热加载方法
class ExtractUtil: def hotload_replace(self,data_str:str): # 1.定义一个正则匹配的通用表达式 # regexp = "\\$\\{(.*?)\\}" # 用于匹配格式为：${access_token} regexp = "\\$\\{(.*?)\\((.*?)\\)\\}" # 用于匹配格式为：${函数名(参数)} fun_list = re.findall(regexp,data_str) for f in fun_list: print(f) # ${函数名(参数)} &gt;&gt;函数名=f[0],参数为=f[1] if f[1] == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eef6539f89ebec7f9daf9b03a983d55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a98617be74f6f126f9104a883653cd07/" rel="bookmark">
			jmeter--1.安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. jmeter和jdk下载地址
2. jdk环境变量配置
3. Jmeter的环境变量配置
1. jmeter和jdk下载地址 链接：https://pan.baidu.com/s/1C8ItsR8ZUGJO9uyTJ-9QtQ?pwd=x5m5
提取码：x5m5
2. jdk环境变量配置 2.1 我的电脑右键属性--&gt;高级系统设置--&gt;高级--&gt;环境变量--&gt;系统变量：
2.2 新建
变量名：JAVA_HOME
变量值：D:\Program Files\Java\jdk17.0.2 (jdk的安装路径。)
2.3 新建：
变量名：CLASSPATH
变量值：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib\dt.jar; （注意最前面有一点）
2.4 编辑PATH添加：
Windows7：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
Windows10：需要增加两个
%JAVA_HOME%\bin
%JAVA_HOME%\jre\bin
2.5 验证是否安装并配置成功：
在dos中输入javac和java -version验证
3. Jmeter的环境变量配置 3.1 我的电脑右键属性--&gt;高级系统设置--&gt;高级--&gt;环境变量--&gt;系统变量：(winows10以上直接搜索环境变量)
3.2 新增：
变量名：JMETER_HOME
变量值：(Jmeter的实际安装路径)：D:\study\course\Jmeter\1\apache-jmeter-5.6.3
3.3 在CLASSPATH变量的最后面加入如下变量值：
%JMETER_HOME%\lib\ext\ApacheJMeter_core.jar;%JMETER_HOME%\lib\jorphan.jar;
3.4 在PATH变量的最后面加入如下变量值：
%JMETER_HOME%\bin
3.5 在dos窗口输入jmete命令能够打开jmeter界面，说明安装并配置成功--注意需要重启电脑配置才会生效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5102d14ec41c6c8d294d0cfcdc8b13aa/" rel="bookmark">
			副作用操作是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人github 在编程中，“副作用”（Side Effect）是一个术语，指的是函数或表达式在计算结果以外对外部世界产生的影响。换句话说，如果一个函数除了返回一个值之外，还修改了系统的状态，或者具有可观察的交互（例如，修改全局变量，改变输出设备的状态，或者与数据库或网络进行交互等），那么我们就说这个函数具有副作用。
以下是一些常见的副作用：
改变全局变量或数据结构：如果一个函数修改了一个全局变量或者一个参数的状态，那么它就具有副作用。
写入数据库或读取数据库：数据库操作会改变数据库的状态，因此具有副作用。
网络请求：发送 HTTP 请求或者 WebSocket 消息等网络操作会改变网络的状态，因此具有副作用。
改变文件系统：读写文件会改变文件系统的状态，因此具有副作用。
直接操作 DOM：在浏览器环境中，直接操作 DOM 会改变页面的状态，因此具有副作用。
在函数式编程中，我们通常倾向于避免副作用，因为它们会使得程序的行为变得难以预测和理解。然而，在实际的应用程序中，副作用通常是必不可少的，例如，我们需要通过网络请求来获取数据，需要通过修改 DOM 来更新 UI 等。因此，关键是如何在保持代码的可读性和可维护性的同时，合理地管理和控制副作用。在 React 中，我们通常使用生命周期方法或者钩子（如 useEffect）来处理副作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25774fd683c704954309634bd5b78d1c/" rel="bookmark">
			Syslog发送日志&#43;Logstash处理日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Syslog发送日志 Syslog（System Logging Protocol）是一种用于计算机系统日志记录的标准协议。它允许设备（如服务器、路由器、防火墙等）将事件消息发送到指定的日志收集服务器，以便集中管理和分析。通过使用Syslog，您可以跟踪您的网络中的活动并在出现问题时快速识别和解决问题。
要将告警日志发送到某台机器的某个端口，您需要在发送端（产生日志的设备）和接收端（日志收集服务器）上配置Syslog。以下是详细方案：
安装和配置Syslog服务器（接收端）： 这里我们以rsyslog为例，rsyslog是Linux系统上常用的Syslog服务器。如果您使用的是Windows系统，可以考虑使用Kiwi Syslog Server或其他适用于Windows的Syslog服务器。
（1）安装rsyslog：
对于大多数Linux发行版，rsyslog已经是默认安装的。如果没有，可以使用以下命令安装：
对于基于Debian的系统（如Ubuntu）： sudo apt-get update sudo apt-get install rsyslog 对于基于RHEL的系统（如CentOS）： sudo yum install rsyslog （2）配置rsyslog以接收远程日志：
编辑rsyslog配置文件（通常位于/etc/rsyslog.conf）：
sudo nano /etc/rsyslog.conf 取消以下行的注释以启用UDP和/或TCP日志接收：
module(load="imudp") input(type="imudp" port="514") module(load="imtcp") input(type="imtcp" port="514") 保存并退出。
（3）重启rsyslog服务：
sudo systemctl restart rsyslog 配置发送端设备发送告警日志到Syslog服务器： 这里以Linux系统为例，配置rsyslog将告警日志发送到远程服务器。
（1）编辑rsyslog配置文件：
sudo nano /etc/rsyslog.conf （2）添加以下行以将告警日志发送到远程服务器：
*.alert @remote_server_IP:514 请将remote_server_IP替换为实际的Syslog服务器IP地址。*.alert表示发送所有告警级别的日志。@表示使用UDP协议，如果要使用TCP协议，请使用@@。
（3）重启rsyslog服务：
sudo systemctl restart rsyslog 现在，您的发送端设备将告警日志发送到指定的Syslog服务器和端口。您可以在Syslog服务器上查看和分析这些日志。
如果您的设备不是Linux系统，您需要查找针对该设备的Syslog配置方法。通常，您可以在设备的管理界面或配置文件中找到相应的设置。
在发送端发送指定的日志：
首先，您需要确定要发送的日志文件的路径。例如，假设您要发送的日志文件位于/var/log/myapp.log。
编辑rsyslog配置文件：
sudo nano /etc/rsyslog.conf 在配置文件中添加以下内容，以将指定日志文件发送到远程服务器： $ModLoad imfile $InputFileName /var/log/myapp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25774fd683c704954309634bd5b78d1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ecfd6cd925361f0409a976baf112432/" rel="bookmark">
			大话 JavaScript（Speaking JavaScript）：第二十六章到第三十章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四部分：提示，工具和库 原文：IV. Tips, Tools, and Libraries
译者：飞龙
协议：CC BY-NC-SA 4.0
本部分提供了使用 JavaScript 的技巧（最佳实践，高级技术和学习资源），并描述了一些重要的工具和库。
第二十六章：元代码风格指南 原文：26. A Meta Code Style Guide
译者：飞龙
协议：CC BY-NC-SA 4.0
JavaScript 有许多优秀的风格指南。因此，没有必要再写一个。相反，本章描述了元风格规则，并调查了现有的风格指南和已建立的最佳实践。它还提到了我喜欢的一些更有争议的做法。这个想法是为了补充现有的风格指南，而不是取代它们。
现有的风格指南 这些是我喜欢的风格指南：
Idiomatic.js：编写一致的、惯用的 JavaScript 的原则
Google JavaScript 风格指南
jQuery JavaScript 风格指南
Airbnb JavaScript 风格指南
此外，还有两个元风格指南：
GitHub 上的流行约定分析 GitHub 代码，找出最常用的编码约定。
JavaScript，获胜的风格检查了几种流行风格指南的大多数推荐。
一般提示 本节将涵盖一些一般的代码编写技巧。
代码应该一致 编写一致代码的两个重要规则。第一条规则是，如果你开始一个新项目，你应该想出一个风格，记录下来，并在任何地方都遵循它。团队越大，检查对风格的自动遵循就越重要，可以通过诸如 JSHint 之类的工具实现。在风格方面，有许多决定要做。其中大多数都有普遍认可的答案。其他必须根据项目定义。例如：
有多少空格（括号后，语句之间等）
缩进（例如，每级缩进多少空格）
如何在哪里编写var语句
第二条规则是，如果你加入一个现有项目，你应该严格遵循它的规则（即使你不同意它们）。
代码应该易于理解 每个人都知道调试比一开始编写程序要困难两倍。因此，如果你在编写时越聪明，那么你将如何调试呢？ ——Brian Kernighan
对于大多数代码，用于阅读的时间远远大于用于编写的时间。因此，使前者尽可能简单非常重要。以下是一些指导方针：
更短并不总是更好
有时写更多意味着事情实际上更容易阅读。让我们考虑两个例子。首先，熟悉的事物更容易理解。这意味着使用熟悉的、稍微更冗长的结构可能更可取。其次，人类读取标记，而不是字符。因此，redBalloon比rdBlln更容易阅读。
好的代码就像教科书
大多数代码库都充满了新的想法和概念。这意味着如果你想要使用一个代码库，你需要学习这些想法和概念。与教科书相比，代码的额外挑战在于人们不会线性阅读它。他们会随时跳进来，应该能够大致理解发生了什么。代码库的三个部分有所帮助：
代码应该解释*发生了什么；它应该是不言自明的。为了编写这样的代码，使用描述性标识符，并将长函数（或方法）分解为更小的子函数。如果这些函数足够小并且有意义的名称，你通常可以避免注释。
注释应该解释为什么事情发生。如果你需要了解一个概念才能理解代码，你可以在标识符中包含该概念的名称，或者在注释中提到它。阅读代码的人可以查阅文档，了解更多关于该概念的信息。
文档应填补代码和注释留下的空白。它应该告诉你如何开始使用代码库，并为你提供大局观。它还应包含所有重要概念的词汇表。
不要聪明；不要让我思考
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ecfd6cd925361f0409a976baf112432/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e97c2215f940ceea5daa936490adcc/" rel="bookmark">
			大话 JavaScript（Speaking JavaScript）：第十一章到第十五章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第十一章：数字 原文：11. Numbers
译者：飞龙
协议：CC BY-NC-SA 4.0
JavaScript 对所有数字都使用单一类型：它将它们全部视为浮点数。但是，如果小数点后没有数字，则不显示小数点：
&gt; 5.000 5 在内部，大多数 JavaScript 引擎都会优化并区分浮点数和整数（详情请参见JavaScript 中的整数）。但这是程序员看不到的东西。
JavaScript 数字是基于 IEEE 浮点算术标准（IEEE 754）的double（64 位）值。该标准被许多编程语言使用。
数字文字 数字文字可以是整数、浮点数或（整数）十六进制：
&gt; 35 // integer 35 &gt; 3.141 // floating point 3.141 &gt; 0xFF // hexadecimal 255 指数 指数eX是“乘以 10^X”的缩写：
&gt; 5e2 500 &gt; 5e-2 0.05 &gt; 0.5e2 50 在文字上调用方法 对于数字文字，访问属性的点必须与小数点区分开。如果要在数字文字123上调用toString()，则有以下选项：
123..toString() 123 .toString() // space before the dot 123.0.toString() (123).toString() 转换为数字 将值转换为数字的方式如下：
值结果undefinedNaNnull0布尔值false → 0true → 1数字与输入相同（无需转换）字符串解析字符串中的数字（忽略前导和尾随空格）；空字符串转换为 0。示例：'3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91e97c2215f940ceea5daa936490adcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d636c3de72f77cdc840c92e7fa807959/" rel="bookmark">
			大话 JavaScript（Speaking JavaScript）：第一章到第五章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一部分：JavaScript 快速入门 原文：I. JavaScript Quick Start
译者：飞龙
协议：CC BY-NC-SA 4.0
这部分是 JavaScript 的一个独立快速介绍。你可以在不阅读本书中的其他内容的情况下理解它，本书的其他部分也不依赖于它的内容。然而，阅读本书的提示在阅读本书的提示中适用。
第一章：基本 JavaScript 原文：1. Basic JavaScript
译者：飞龙
协议：CC BY-NC-SA 4.0
本章是关于“基本 JavaScript”，这是我为 JavaScript 的一个子集选择的名称，尽可能简洁，同时仍然能让你高效地工作。当你开始学习 JavaScript 时，我建议你在学习其他语言之前先在其中编程一段时间。这样，你就不必一次学习所有内容，这可能会让人困惑。
背景 本节简要介绍了 JavaScript 的背景，以帮助你理解它为什么是这样的。
JavaScript 与 ECMAScript ECMAScript是 JavaScript 的官方名称。之所以需要一个新名称，是因为Java有商标（最初由 Sun 持有，现在由 Oracle 持有）。目前，Mozilla 是少数几家被允许正式使用JavaScript名称的公司之一，因为它很久以前就获得了许可证。对于常见用法，以下规则适用：
JavaScript意味着编程语言。
ECMAScript是语言规范的官方名称。因此，每当提到语言的版本时，人们都说ECMAScript。JavaScript 的当前版本是 ECMAScript 5；ECMAScript 6 目前正在开发中。
影响和语言的性质 JavaScript 的创造者 Brendan Eich 别无选择，只能很快地创建这种语言（否则，Netscape 可能会采用其他更糟糕的技术）。他从几种编程语言中借鉴了一些东西：Java（语法，原始值与对象），Scheme 和 AWK（一级函数），Self（原型继承），以及 Perl 和 Python（字符串，数组和正则表达式）。
JavaScript 在 ECMAScript 3 之前没有异常处理，这就解释了为什么语言经常自动转换值并经常悄悄失败：最初它无法抛出异常。
一方面，JavaScript 有一些怪癖，缺少相当多的功能（块作用域变量，模块，支持子类等）。另一方面，它有几个强大的功能，可以让你解决这些问题。在其他语言中，你学习语言特性。在 JavaScript 中，你经常学习模式而不是语言特性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d636c3de72f77cdc840c92e7fa807959/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6be1a4322c15f14c19c62211f1fb238/" rel="bookmark">
			Vue基础-搭建Vue运行环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章介绍了在Vue.js项目中进行开发环境搭建的关键步骤。包括node.js安装和配置、安装Vue及Vue CLI工具、安装webpack模板、安装vue-router、创建Vue项目等步骤。这篇文章为读者提供了清晰的指南，帮助他们快速搭建Vue.js开发环境，为后续的项目开发奠定基础。
一、node.js 安装和配置 1、进入官网地址下载安装包 官方网站下载地址：Node.js (nodejs.org)
选择长期维护版本(LTS)下载。
2、安装程序 a、一键安装 下载完成后，双击安装包，安装Node.js，一直点下一步，直到完成。
b、测试安装是否成功 控制台查看Node.js版本：
node -v // 显示node.js版本 npm -v // 显示npm版本 如果出现版本号则说明安装成功。
成功显示版本说明安装成功。
3、环境配置 a、配置安装目录和缓存目录 我们需要设置全局安装包的目录路径、设置 npm 包的缓存路径
安装目录下新建 “node_global”和 “node_cache” 文件夹
创建完毕后，使用管理员身份打开cmd命令窗口，输入：
npm config set prefix "C:\Program Files\nodejs\node_global" //设置全局安装包的目录路径 npm config set cache "C:\Program Files\nodejs\node_cache" //设置 npm 包的缓存路径 b、配置环境变量 首先我们检查刚刚的配置：
命令行输入：
npm config list 可以看到我们刚刚设置的配置：
cache=”C:\ProgramFiles\nodejs\node_cache” prefix=”C:\ProgramFi1es\nodejs\node_g1oba1″ registry=”https://registry.npm.taobao.org” 复制prefix的值：C:\ProgramFi1es\nodejs\node_g1oba1
此电脑右键&gt;属性&gt;高级系统设置&gt;环境变量，
将prefix的值复制到环境变量系统变量的Path。
4、测试是否安装成功 配置完成后，全局安装一个最常用的 express 模块进行测试
npm install express -g // -g代表全局安装 出现以下界面即为配置成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6be1a4322c15f14c19c62211f1fb238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/602366ddff78b2baf1237472cf68c25e/" rel="bookmark">
			【期末不挂科-考前速过系列P4】单片机[接口与总线]——经典例题盘点（带图解析）（第四章：32题搞定基本指令例题））
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
大家好吖，欢迎来到 YY 滴单片机系列 ，热烈欢迎！ 本章主要内容面向接触过单片机的老铁
主要内容含：
欢迎订阅 YY滴C++专栏！更多干货持续更新！以下是传送门！
YY的《C++》专栏YY的《C++11》专栏YY的《Linux》专栏YY的《数据结构》专栏YY的《C语言基础》专栏YY的《初学者易错点》专栏YY的《小小知识点》专栏YY的《单片机期末速过》专栏 目录 一.算术运算类指令二.逻辑运算类指令三.控制转移类指令（条件类/无条件类）四.位操作类指令 一.算术运算类指令 ADD是什么指令？D A.减法指令B.乘法指令C.除法指令D.不带进位位的加法指令
解析：如下图中所示，ADD不带进位位；ADDC带进位位；
注意：进位规则如下图所示：低字节相加用ADD,高字节相加用ADDC
SUBB是什么指令？C A.减法指令B.乘法指令C.带借位的减法指令D.不带进位的加法指令
解析：减法指令一定带借位，减法（subtraction）
DIV是什么指令？C A.减法指令B.乘法指令C.除法指令D.不带进位的加法指令
解析：顾名思义，division 执行DIV AB之后，B中存放的是什么？B A.商B.余数C.0D.1 执行DIV AB之后，A中存放的是什么？A A.商B.余数C.0D.1
解析：单片机中的除法规则如下图所示：按顺序记忆，从左至右，商先出来放A，余数后出放B
MUL是什么指令？B A.减法指令B.乘法指令C.除法指令D.加法指令
解析：顾名思义，multiplication 执行MUL AB之后，A中存放的是运算结果数的什么？ A.高8位B.低8位C.0D.1 执行MUL AB之后，B中存放的是运算结果数的什么？ A.高8位B.低8位C.0D.1
解析：如下图所示：我们这样记忆，从低到高，低先出低放到A中，高后出放到B中；
对比记忆：除法中，商放在A中，余数放在B中； INC是什么指令？C A.加法指令B.减法指令C.加1指令D.减1指令
解析：顾名思义，增量 INC－Incremect
DEC是什么指令？ A.加法指令B.减法指令C.加1指令D.减1指令
解析：顾名思义，减量 DNC－Decrement
DA是什么指令？ A.加法指令B.减法指令C.加1指令D.十进制调整指令
解析：如下所示，主要用于进行BCD码运算时，跟在ADD和ADDC指令后
二.逻辑运算类指令 ANL是什么指令？A A.逻辑与B.逻辑或C.逻辑异或D.逻辑非
解析：ANL，顾名思义（and）；注意：值会送入A中
例如：（PS：ORG 是汇编中的伪指令。ORG 0000H 表示后面紧跟的那条指令的地址是 0000H）
ORL是什么指令？B A.逻辑与B.逻辑或C.逻辑异或D.逻辑非
解析：顾名思义（OR Logic） XRL是什么指令？C A.逻辑与B.逻辑或C.逻辑异或D.逻辑非
解析：顾名思义。XRL它的全称是“XOR Register with Memory or Immediate” CPL A是什么指令？A A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/602366ddff78b2baf1237472cf68c25e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a320656de98ac13be6330e6e8a9a52c/" rel="bookmark">
			Web3与物联网：去中心化设备互联的未来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web3技术的崛起正引领着数字世界向着更加开放、去中心化的方向迈进，而物联网（Internet of Things, IoT）作为连接实体世界的桥梁，也在这场变革中经历着深刻的改变。本文将深入探讨Web3技术如何与物联网相结合，构建去中心化设备互联的未来，重新定义设备之间的关系和数据流动。
Web3技术的基础
1.区块链的去中心化特性
区块链技术作为Web3的核心，以其去中心化、分布式账本的特性，为物联网提供了可靠的数据管理和安全保障。
2.智能合约的自动化执行
智能合约是基于区块链的自动执行合同，它为设备之间的交互提供了可编程的规则，实现设备间的自动化协作。
物联网的挑战与需求
传统物联网架构存在中心化管理的问题，容易受到单点故障和数据篡改的威胁，而Web3技术可以为其提供更强的安全性和去中心化的管理方式。物联网中设备之间的信任建立一直是一个挑战，而区块链的不可篡改性和透明性为设备提供了可信的基础。
Web3与物联网融合的优势
1.数据的安全与隐私：Web3技术通过分布式账本和加密技术，加强了物联网数据的安全性和隐私保护，让用户更加放心地使用智能设备。
2.去中心化治理：物联网设备的去中心化治理可以通过智能合约实现，设备参与者可以共同制定规则，减少了单一实体对整个网络的控制。
3.数据所有权的变革：Web3技术赋予了数据更直接的所有权，设备产生的数据不再被单一实体垄断，而是由数据生成者完全掌握，实现了数据所有权的变革。
基于Web3的物联网应用案例
1.去中心化能源管理：通过区块链技术，设备可以直接参与能源的生成、分配和交易，实现了能源管理的去中心化和高效运作。
2.智能城市的构建：Web3技术可以实现城市中各种设备的智能化互联，实现智能交通、智能照明等方面的优化，构建更加智能、高效的城市。
3.区块链物联网供应链：通过区块链的不可篡改性，实现物联网在供应链中的透明追溯，确保产品的真实性和质量可追溯。
挑战与未来展望
1.标准化和互操作性：Web3与物联网融合的过程中，需要建立更为通用的标准和协议，以促进不同设备之间的互操作性，提高系统的整体效率。
2.能耗和性能问题：区块链技术目前在能耗和性能上仍面临一定挑战，需要不断优化以适应物联网大规模应用的需求。
3.法律与隐私问题：Web3与物联网的结合可能引发一系列法律和隐私问题，需要在制定相关法规和政策的同时，保障用户的隐私权益。ClonBrowser的反侦测指纹浏览器特性有助于在Web3时代中提供更高级别的匿名浏览，从而降低用户被追踪和关联的风险。
结语
Web3与物联网的融合将带来设备互联的全新时代，重新定义设备之间的信任和数据流动方式。尽管面临一些挑战，但这一结合将推动物联网的发展迈向更加开放、安全和去中心化的未来。通过标准化、技术优化和法规制定，我们有望迎来Web3与物联网协同发展的全新篇章。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a06b101122849e28a30131e80b65b38/" rel="bookmark">
			加速你的数据库：公司中SQL优化的八大绝招
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 SQL优化这个问题也是老生常谈了，很多都还是在八股文中了解到，那么公司里的SQL都是咋优化的呢？和八股文一样吗？下面，我将与大家分享我在公司里学到的SQL优化知识。SQL优化是提高数据库性能和减少资源消耗的重要一环，在我工作的过程中，我深刻体会到了SQL优化的重要性，并积累了一些实用的技巧和经验，我希望通过这篇博客，将这些知识分享给大家。
LIKE的左模糊查询优化 不足点 使用 LIKE 进行左模糊查询可能导致索引失效的原因主要有两点：
LIKE 模糊匹配规则：左模糊查询中，使用 % 通配符开头的模式，例如 %phone，在搜索过程中需要对索引进行全索引扫描，因为索引是按照顺序存储的，无法利用索引的 B-Tree 属性进行快速定位。这将导致查询时需要遍历整个索引，从而降低查询效率。索引列顺序：如果索引列的顺序与查询条件的顺序不一致，也会导致索引失效。例如，如果索引是 (name, price)，但是查询条件是 LIKE '%phone' AND price &lt; 1000，这样的查询无法充分利用索引，因为索引的第一列 name 并没有在查询条件中使用，导致索引无法高效匹配查询条件。 优化点 优先考虑使用全文搜索来进行模糊查询，可以大幅提高查询效率。因为全文搜索使用了特殊的索引类型（如InnoDB全文索引或MyISAM全文索引），而左模糊查询则使用普通的B树索引。全文索引能够以文本内容的方式存储数据，并使用一定的算法构建索引，从而快速准确地找到文本数据中的匹配项，有效利用了索引。但左模糊查询需要扫描整个索引目录才能找到符合条件的记录，效率较低。因此，在适合的情况下，使用全文搜索可以提高查询效率。
优化实现 1. 添加全文索引：首先，需要为需要进行模糊查询的列添加全文索引。假设我们以 products 表中的 name 列为例，可以使用以下语句添加全文索引：
ALTER TABLE products ADD FULLTEXT(name); 2. 使用 MATCH AGAINST 进行全文搜索：接下来，使用 MATCH AGAINST 语句来进行全文搜索。使用 MATCH 子句指定要搜索的列，并使用 AGAINST 子句指定要搜索的模糊关键字。
SELECT * FROM products WHERE MATCH(name) AGAINST ('phone' IN NATURAL LANGUAGE MODE); 在上述示例中，使用 MATCH(name) 来指定要搜索的列 name，并使用 AGAINST ('phone' IN NATURAL LANGUAGE MODE) 来指定要搜索的关键字，其中 phone 是模糊匹配的关键字。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a06b101122849e28a30131e80b65b38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2610774c82e8fa7f048c4143bb32493c/" rel="bookmark">
			CloudCone | 最便宜国外VPS | 2核1G一年只需17$ | 国外性价比高VPS | CloudCone 怎么样 | CloudCone 使用体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因工作需要，博主体验过市面上各家国外vps（包括你知道的搬瓦工、vultr、hostwinds等等），把最便宜的一家国外vps记录下来，市面上找不到比这更便宜的vps。
它就是CloudCone。这家vps比较小众，ip新，国内可以直连ip，网速不错。目前博主已稳定使用一年。
一.价格（附优惠入口-官网无法直接找到优惠） 相比其他厂家2核vps 动辄月付10$左右的价格，CloudCone 2核1G内存55G硬盘SSD 一年只需要 17.12$，市面上没有比这更便宜的了。
​
​
这个优惠购买页面在官网无法直接找到，此处记录优惠购买链接 ，点击下方Create VPS — CLOUDCONE​​​​​https://app.cloudcone.com.cn/vps/227/create?token=hashtag-2024-vps-1&amp;ref=9927
这里博主记录了其他配置的优惠入口：
1.2024年按年付款优惠 2024最新，按年付款，购买优惠 核数内存硬盘带宽价格优惠入口2核1G55GB2 TB/月 1 Gb/s17.12美元/年点击进入优惠2核2G100GB3 TB/月 1 Gb/s29.80美元/年点击进入优惠2核3G160GB4 TB/月 1 Gb/s42.59美元/年点击进入优惠4核4G220GB5 TB/月 1 Gb/s55.90美元/年点击进入优惠 2.按月付款优惠 2024最新，按月付款，购买优惠 核数内存硬盘带宽价格优惠入口1核1G20GB SSD3T 1Gbps3.00美元/月点击进入优惠2核2G40GB SSD6T 1Gbps5.50美元/月点击进入优惠2核4G60G SSD3T13.80美元/月点击进入优惠4核4G100G SSD3T16.99美元/月点击进入优惠 二.注册、充值 购买前，要先注册账号，并充值后才能购买。
1.注册 点击优惠链接进入优惠页面，如dianCreate VPS — CLOUDCONE
点击下图中的 lOGIN TO DEPLOY ,如下图
进入登录页面，点击sign up 注册,如下图
输入邮箱，密码等信息注册，点击Create My Account，然后邮箱可能会收到验证验证邮件，点击邮件中验证链接即可。如下图
2.充值 登录后，点击右上角头像，弹窗内点击 Billing,如下图
点击Add funds，添加资金，使用支付宝付款(也有paypal等别的付款方式)，在Alipay支付宝输入框输入充值数目，点击Add按钮，就会跳转到支付宝扫码支付页面。如下图。
充值完成后，从本博客的购物优惠链接再次进入，就可以购买。
三.国内ip直连问题 CloudCone的服务器ip大都能从国内直连，如果你发现无法ping通ip的情况，在七天内可以无理由退款，然后重新购买一次从而更换新ip。
博主一年前第一次购买时ip就无法ping通，点击销毁即可，钱会自动退到账户上，再重新进入优惠入口购买。销毁如下图。
​​
如果在后续使用中，发现ip被封(很常见的情况，每家vps厂商都会这样，因为你通过vps做了某些事情，你懂得，正常使用不会封)，可以花2$更换ip，可以联系客服、提交工单会帮你更换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2610774c82e8fa7f048c4143bb32493c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00557bf5ad0a4e5de859e2c1dcecdbad/" rel="bookmark">
			概率中的 50 个具有挑战性的问题 [9/50]：掷骰子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说明 我最近对与概率有关的问题产生了兴趣。我偶然读到了弗雷德里克·莫斯特勒（Frederick Mosteller）的《概率论中的五十个具有挑战性的问题与解决方案》）一书。我认为创建一个系列来讨论这些可能作为面试问题出现的迷人问题会很有趣。每篇文章只有 1 个问题，使其成为一个总共有 50 个部分的系列。让我们潜入并激活我们的脑细胞。
图片由作者使用 DALL-E 3 提供。
二、问题描述 掷骰子游戏，用两个骰子玩，是美国最快和最受欢迎的赌博游戏之一。计算与之相关的赔率是一项有启发性的练习。
规则如下：
只有两个骰子的总数才算数。如果第一次掷骰子的总数为 7 或 11，则玩家掷骰子并立即获胜，如果掷骰子的总数为 2、3 或 12，则立即输掉。任何其他投掷都被称为他的“赛点”，即打平，继续对决。如果第一次掷骰子是一个点，玩家反复掷骰子，直到他要么再次掷骰子获胜，要么掷出 7 点输掉。 问：玩家获胜的机会有多大？
三、问题分析 3.1 概率空间分析 首先，让我们检查两次掷骰子产生的总计数的出现频率。
两个骰子计数的总数
3.2 第一次投掷获胜的概率 若首次投出骰子获胜，必须是。 为了确保在第一次投掷中取得胜利，玩家必须总共掷出 7 或 11 个。第一次投掷获胜的概率可以计算如下：
共 6^2=36 不同结果
投出 7的结果是:
(1, 6)(2, 5)(3, 4)(4, 3)(5, 2)(6, 1) 投出11 的结果是:
(5, 6)(6, 5) 因而产生出 8种不同的骰子结果使得首投获胜。
Therefore, the probability of winning the first roll is equal to:
3.3 第一次投出获败概率 失去第一卷 掷 2 的方法有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00557bf5ad0a4e5de859e2c1dcecdbad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae514cf05d3724f02e6415c0540718c6/" rel="bookmark">
			MacOS锁屏快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 锁屏快捷键
Control + Command + Q 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b29bddde54203a26af058c3dfebbc6b3/" rel="bookmark">
			盲盒小程序能够为企业商家带来哪些优势？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近几年，盲盒深受大家关注，现在在各大商场中，盲盒的身影也处处可见，商家也因此获得了一定的利润。
随着人们生活消费水平的提高，消费者在消费中也逐渐追求新颖的消费模式，而盲盒的未知性特点，恰好符合了当下消费者的心理！盲盒就像一个神秘的物品，消费者在拆盲盒时能够带来紧张刺激感和惊喜感，满足了年轻消费者的好奇心理。
为顺应互联网时代发展，盲盒也开始转型到互联网上发展，各类盲盒小程序开始出现，实现了消费者在线抽盲盒。本文旨在介绍盲盒小程序的发展优势。
传统的盲盒需要消费者到线下实体门店进行下单消费，而线上盲盒小程序可以为消费者提供一个方便快捷的消费渠道。消费者能够在手机上购买盲盒，选择机会也较大。
随着互联网的发展，盲盒小程序也逐渐完善，走向了正轨发展。
线上盲盒发展优势 1、新颖
盲盒小程序的玩法非常新颖，给用户带来新颖和惊喜感。小程序上的热门盲盒品类也比较丰富，玩法众多，消费者可以任意选择。盲盒本身具有较大的用户基础，盲盒小程序发发展潜力较大。
2、社交互动
小程序有专属的社交区，消费者玩家可以在社区中与其他玩家交流互动，分享盲盒心得、互换盲盒等，能够增加用户黏性。
3、刺激消费
小程序提供免费抽盒、积分兑换抽盒，能够激发消费者的购买欲望，增加小程序参与率。
4、打造IP
小程序可以与品牌IP合作，打造出独特的主题盲盒，吸引消费者，提升品牌知名度，IP推广。
5、降低成本
线上小程序依靠互联网，能够减少运营商的线下成本，减少场地费，增加相应收益。
盲盒小程序在发展上具有独特的优势，既能够推动盲盒市场的发展，也能够帮助企业、商家获得盲盒带来的利润。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00163fcb1c27074c62e9e318806227c8/" rel="bookmark">
			ubuntu18.04.6 搭建mqtt服务器emqx 之docker方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ubuntu18.04.6 搭建mqtt服务器emqx 之docker方式 前提docker环境已经安装好
如未安装，请参考博文https://blog.csdn.net/a554521655/article/details/134251763
文章目录 ubuntu18.04.6 搭建mqtt服务器emqx 之docker方式安装emqx查看是否安装并启动成功登录前端查 安装emqx docker run -d --restart=always --privileged=true --name hb-emqx -p 1883:1883 -p 8081:8081 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 emqx/emqx:latest 查看是否安装并启动成功 docker ps 登录前端查 1.访问网址 http://你的主机:18083 访问 2.默认用户名和密码： admin public 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/2/">«</a>
	<span class="pagination__item pagination__item--current">3/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/4/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>