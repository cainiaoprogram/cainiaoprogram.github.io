<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc7fc7dbef98e54adff2ca0349059b85/" rel="bookmark">
			欧空局（esa）下载哨兵-Sentinel影像-（史上最全讲解，老少皆宜）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欧空局（esa）下载哨兵-Sentinel影像-（史上最全讲解，老少皆宜） 文章目录 欧空局（esa）下载哨兵-Sentinel影像-（史上最全讲解，老少皆宜）前言一、欧空局官网二、网站注册三、影像下载参数设置四、影像下载范围确定五、影像下载六、离线产品七、补充 前言 距离上篇博客《Sentinel2 哨兵2数据下载方法（USGS）》已过半年有余。今天讲解下如何通过欧空局下载哨兵影像。
一、欧空局官网 https://scihub.copernicus.eu/dhus/#/home
二、网站注册 1.打开网站后如下图所示，已有账户的可直接登录，未注册的点击图中的sign up进行注册。注意：需要借助梯子，科学上网。
2.弹出如下界面，填下相应的信息即可，然后点击右下角的注册。
3.接下来你会收到一封邮件，如下图所示，点击图中的网址进行激活（图中马赛克部分即为激活的网址）。
三、影像下载参数设置 1.回到登录界面，输入你注册好的账号密码，进行登录，即可弹出如下界面。点击图中的三横线处（图中红色方框），弹出下级列表，在这里可设置影像的筛选条件。
2.该部分介绍影像筛选的设置。第一个方框主要设置影像的获取方式（这里分为Ingestion Date和Sensing Date）、排序方式（Ascending和Descending）。根据需要选取Ingestion Date或Sensing Date并设置相应的日期即可。
3.接下来选取传感器类型，这里有哨兵1、2和5可选。以哨兵2为例，Satellite Platform（卫星平台）有S2A和S2B两种，Product Type（产品类型）有1C/2A和2Ap可选（2A与1C的差别在于经过了大气校正，2Ap我不清楚，需要的可自行了解）；Relative Orbit Number (from 1 to 143)，如果知道相应的轨道号可设置该选项，不需要的可忽略；Cloud Cover % (e.g.[0 TO 9.4])：设置云量，注意该处设置云量的时候一定要打上[]，如[0 TO 10]。
完成以上设置后，点击图中右上角的放大镜。
四、影像下载范围确定 1.完成以上操作后，弹出如下界面。以上操作均未设置研究区且未设置相应的轨道号编号，如何找到自己所在研究区内的影像呢？
2 .由于欧空局不支持上传感兴趣区域，只能通过对比地图影像，首先大概找到研究区的范围，以北京为例。
定位到大概的方位，点击图中红色方框1，点击鼠标左键即可勾绘研究区，勾绘完后如图中方框2所显示（蓝色边界即为所勾绘的区域）。
点击图中红色方框3处，进行筛选。
3 .筛选后如下。图中方框1处为所勾绘的研究区。方框2处为涉及该研究区的影像范围。方框3处为筛选的影像结果。将鼠标放在左侧影像结果栏中即可在右侧阴影范围中显示相应的位置。
4 .根据需要确定下载的影像，点击图中方框处的绿色对勾进行勾选，如下图所示，选择相应的4景影像。
点击下方2处的购物车，将其加入到购物车中。
五、影像下载 1 .点击红色方框1处的购物车即可弹出如下界面，通过勾选红色方框2处的方框进行勾选需要下载的影像，注意，每次只能勾选一个，不能批量勾选。然后点击方框3处的下载符号进行下载。
六、离线产品 1.如果在结果栏中出现offiline，则表示该产品已经下线。不要慌，将其加入到购物车中。
2.点击购物车，选择该景影像，点击下方的下载按钮，即可申请下载影像。此时系统会提示申请已提交（如下图所示），说明系统此时开始往服务器上传数据；有的时候将影像添加到购物车后再点击下载会提示错误，这时候不要紧张，可能是网络通讯造成的，刷新下网页，再重新点击下载按钮，直到出现上图所示的提示信息即表示申请成功。
3.当影像上传申请完成后，等待购物车里影像的状态变成online（成功后的结果如下图所示），即可进行下载。等待的时间不定，快的一两个小时，慢的好几天都有，看运气。
七、补充 1.欧空局下载优点：可选择相应的产品，如哨兵2的1C和2A，并不是所有时间范围内的2A产品均有，一般能下载近一年的2A产品；
缺点：不能上传感兴趣区区域，无法准确定位到所在研究区范围，只能通过大概比对，当研究区较大时，使用该方法则极其不方便；此外无法批量下载。
2.如果想准确定位到自己的研究区（上传感兴趣区文件），并且想批量下载影像，可通过USGS网站下载。点击下方博客Sentinel2 哨兵2数据下载方法（USGS）-史上最全讲解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6eb50cb9b63c555d9259c5d12b94b48/" rel="bookmark">
			Web3 技术初体验以及相关学习资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 前言 作为一名技术博主，经常会关注一些推特，油管这样的社交平台，了解最新发生的技术。之前还不在意，但是今年以来，区块链相关的整个信息流是扑面而来，元宇宙，Web3，NFT相关新名词接踵而至，让我这个门外汉应接不暇。个人特别是3月份之后，几乎每次刷twitter都会看到区块链相关的推文，以至于我不得不开始学习和了解区块链相关的技术了。
非常可惜的是，目前区块链行业对简中互联网支持并不友好，几乎所有的文档都是英文的，所以如果想在加密行业有所成果，那么英语的水平还是至关重要的，值得一提的是，我去年终于通过了英语三级(是的，没打错，就是英语三级) 的英语考试，😄，此处应该有掌声。
目前区块链整体的技术发展都非常迅速，行业现在也迫切需要更多的Web3工程师，这不仅是一个有经济利益的领域，而且也是一个令人着迷的富有创造性的领域。
我会用我目前学习到的经验和能力来帮助大家了解区块链行业，如果我总结的不对，那么也请大家指正。
二、需求 根据之前的经验，我们还是以搜索数据为主要参考点，首先我付出一张谷歌搜索趋势图，这是Web3的搜索趋势图
这是NFT的近两年的搜索趋势图。
可以看到，在国外，目前这些领域都是比较火的。而且很多资本也开始在Web3领域投资一些新的初创公司。
三. 技术栈和学习资料 我在这里并不想长篇大论的介绍区块链的底层技术原理，相关的技术文档可以看廖雪峰的https://www.liaoxuefeng.com/wiki/1207298049439968这篇文章的介绍，相信你就会对区块链有一个大致的了解了。如果我尝试用一句话来总结一下，我肤浅的比喻一下：区块链是一个基于P2P网络不可篡改、分布式的数据库，而智能合约是指数据库上的存储过程
下面我来介绍一些学习资料
2.1 基础知识 区块链是不同交易的数字存证，分布式的存储在区块链的完整计算机系统网络中。区块链是一项了不起的技术，但它们并不容易理解。要理解这些随后将要构建的内容，你需要花一些时间来了解它。我也是推荐大家先学习区块链相关知识，这块了解一下就可以。
B站上北京大学肖臻老师《区块链技术与应用》公开课 https://www.bilibili.com/video/BV1Vt411X7JF
youtube上的区块链学习路线路 https://www.youtube.com/watch?v=ci_AIMCF-HA
2.2 以太坊 我知道提到区块链大家都会提到比特币，但是遗憾的是，虽然比特币目前是行业价值最高的数字货币，也是绝大多数人入行第一个听到的名词，但其实比特币所用的区块链技术是比较落后的，基于比特币开发的应用只有简单的转账功能，所以，目前行业内主流都是以基于以太坊(Ethereum)的技术和平台做开发，以太坊（Ethereum）是一个去中心化的开源的有智能合约功能的公共区块链平台，它的官方网站是https://ethereum.org/ 。
学习资料： 1. 基础课程：学习以太坊可以参考Youtube上这个up主的课程，还是比较详细的https://www.youtube.com/watch?v=itUrxH-rksc 1. 以太坊开发的官方文档 https://ethereum.org/zh/developers/docs/ 1. 网易公开课的尚硅谷最新区块链全套教程完整版 https://open.163.com/newview/movie/free?pid=UFVPHIG9E 2.3 Solidity 以太坊相比比特币的一个重大创新就是它支持智能合约（Smart Contract）。
所谓智能合约，就是一种运行在区块链上的程序。和普通程序不同的是，智能合约要保证在区块链网络的每一个节点中运行的结果完全相同，这样才能使任何一个节点都可以验证挖矿产出节点生成的区块里，智能合约执行的结果对不对。
因此，以太坊提供了一个EVM（Ethereum Virtual Machine）虚拟机来执行智能合约的字节码，并且，和普通程序相比，为了消除程序运行的不确定性，智能合约有很多限制，例如，不支持浮点运算（因为浮点数有不同的表示方法，不同架构的CPU运行的浮点计算精度都不同），不支持随机数，不支持从外部读取输入等等。
在以太坊，智能合约的开发语言目前主流的是
SolidityVyperYul 但是当前边写智能合约最常用的高级语言就是Solidity，包括我自己学习的也是Solidity。这个语言语法有点类似JavaScript。但是智能合约编写思路和我们传统开发差别很大，智能合约是基于以太坊账户的。
目前各大主流IDE也集成了Solidity的开发插件，但是我个人是推荐初学者在 https://remix.ethereum.org/ 这个网站上进行编写智能合约代码，我自己本人也是这个IDE上面进行开发。
露一张我正在开发的代码截图
因为部署智能合约需要一定的gas费用，所以我目前编写智能合约应用，也只是Rinkeby测试网发布，没有发布在主网。
当支付gas费用成果部署后，就可以在以太坊的网络上看到这一区块了。
这里就可以看到区块已经打包成功。
学习资料 登链社区翻译的智能合约中文版本https://learnblockchain.cn/docs/solidity/，已经更新到0.8.13，截止发稿时间，是相当新的。youtube大叔的Solidity, Blockchain, and Smart Contract Course – Beginner to Expert Python Tutorial (学习 Solidity、区块链和智能合约)https://youtu.be/M576WGiDBdQSolidity 实例 https://solidity-by-example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6eb50cb9b63c555d9259c5d12b94b48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c618a489698675c888222cf79bb4fa25/" rel="bookmark">
			HTML3D立体城市特效代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML3D立体城市特效代码
鼠标可以控制“行走”方向，立体性很强
index.html代码如下
&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;3D城市&lt;/title&gt; &lt;style&gt; html { overflow: hidden; touch-action: none; content-zooming: none; } body { position: absolute; margin: 0; padding: 0; width: 100%; height: 100%; background: #000; } #canvas { position: absolute; width: 100%; height: 100%; background: #000; cursor: crosshair; }&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;!-- GLSL shaders in the header --&gt; &lt;script id="shader-vs" type="x-shader/x-vertex"&gt; attribute vec3 aVertexPosition; attribute vec3 aVertexNormal; uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat3 uNMatrix; varying vec3 vNormal; varying vec4 vPosition; varying vec3 vPos; void main(void) { vPosition = uMVMatrix * vec4(aVertexPosition, 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c618a489698675c888222cf79bb4fa25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e443ea95d39866543971b2e196c4335/" rel="bookmark">
			el-tooltip和el-popover的入门学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-tooltip和el-popover的入门学习 适用场景 el-tooltip用于hover方式的提示信息
el-popver相比于el-tooltip，有共同的属性content，placement，不同的是，可以设置标题，el-tooltip一般为hover方式触发，el-popover一般为click，可以说是自定义更多的提示信息框
知识点 el-tooltip content设置提示内容
placement设置方向和对齐方式，默认为bottom
effect设置主题，默认为dark
div标签属性slot='content'，自定义设置提示内容
el-popover title设置标题
trigger设置触发方式，默认为click，可以设置hover,focus,manual
v-model设置弹框的显隐
可以在el-popover的标签夹中自定义content内容，此时content属性失效
效果图 el-tooltip效果图 el-popover效果图 代码 el-tooltip代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='app' style='margin-top: 100px;'&gt; &lt;el-tooltip effect='dark' content='右上信息' placement='right-start'&gt; &lt;el-button&gt;右上&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;el-tooltip effect='dark' content='右中信息' placement='right'&gt; &lt;el-button&gt;右中&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;el-tooltip effect='dark' content='右下信息' placement='right-end'&gt; &lt;el-button&gt;右下&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;el-tooltip effect='light' content='左上信息' placement='left-start'&gt; &lt;el-button&gt;左上&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;el-tooltip effect='light' content='左中信息' placement='left'&gt; &lt;el-button&gt;左中&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;el-tooltip effect='light' content='左下信息' placement='left-end'&gt; &lt;el-button&gt;左下&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;el-tooltip placement='top-start'&gt; &lt;div slot='content'&gt;上左信息qqqqqqqqqq&lt;/div&gt; &lt;el-button&gt;上左&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;el-tooltip placement='top'&gt; &lt;div slot='content'&gt;上中信息qqqqqqqqqq&lt;/div&gt; &lt;el-button&gt;上中&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;el-tooltip placement='top-end'&gt; &lt;div slot='content'&gt;上右信息qqqqqqqqqq&lt;/div&gt; &lt;el-button&gt;上右&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;el-tooltip effect='light' placement='bottom-start'&gt; &lt;div slot='content'&gt;下左信息qqqqqqqqqq&lt;/div&gt; &lt;el-button&gt;下左&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;el-tooltip effect='light' placement='bottom'&gt; &lt;div slot='content'&gt;下中信息qqqqqqqqqq&lt;/div&gt; &lt;el-button&gt;下中&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;el-tooltip effect='light' placement='bottom-end'&gt; &lt;div slot='content'&gt;下右信息qqqqqqqqqq&lt;/div&gt; &lt;el-button&gt;下右&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script&gt; new Vue({ el:'#app', data(){ return{} }, methods:{} }) &lt;/script&gt; el-popover代码 &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e443ea95d39866543971b2e196c4335/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35d621d2b78acb6494ad0be62042c3ad/" rel="bookmark">
			axure字符图标 web字体 iconfont配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		axure有自带一些图标，但不一定能满足日用使用，使用图片有时不方便做样式，所以有一套自己的图标库是会大大提升日常使用效率。
使用到图标，需要进行如下配置：
1、在别人的电脑上能看到图标 发布--预览选项--配置--web字体，增加css链接：
https://at.alicdn.com/t/font_1415613_j0lgbvj3u4.css
这样生成的HTML文件在其它电脑也可以看到图标。
2、需要个人电脑上才能看到图标 本地需要安装下载安装图标字体，下载地址：
https://www.iconfont.cn/api/project/download.zip?spm=a313x.7781069.1998910419.d7543c303&amp;pid=1415613&amp;ctoken=FktEZc349OhI4ho-_70Wx_gd
从下载的文件中找到 iconfont.ttf 这个文件，安装这个字体文件。这样在本地axure可以看到图标。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2fc3f29492c989b387373dfb246963a/" rel="bookmark">
			在K8S中使用NFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PS:
因为 原来是1.20版本默认禁止使用selfLink。 所以后续版本需要在kube-apiserver.yaml后面增加 - --feature-gates=RemoveSelfLink=false
最好解决方案: https://blog.csdn.net/joker_zhou/article/details/125478979
基本流程简单: 1. 首先在客户端按照nfs 服务..这个网上一堆不介绍了,
2. 创建一个命名空间 (kubectl create namespace xxxx)
3. 创建rbac (rbac.yaml)
4. 创建nfs的provisioner (deployment.yaml)
5. 创建StorageClass (storageClass.yaml)
6. 在PVC使用storageClass即可 (pvc.yaml)
rbac.yaml
apiVersion: v1 kind: ServiceAccount metadata: name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: hello-storageclass --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1 metadata: name: nfs-client-provisioner-runner rules: - apiGroups: [""] resources: ["persistentvolumes"] verbs: ["get", "list", "watch", "create", "delete"] - apiGroups: ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2fc3f29492c989b387373dfb246963a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e5f54ec281273703f1df635727bb305/" rel="bookmark">
			什么是矩阵号系统？如何搭建及注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是账号矩阵？ 账号矩阵是通过不同平台不同账号之间建立联系，通过将同一品牌下不同平台不同账号的粉丝流量进行账号互通，根据平台不同的规则及内容，来输出企业及品牌信息，通过矩阵的形式提升粉丝数量及账号商业价值。矩阵号的运营模式可以是多平台、多账号，也可以是单平台，多账号。
目前常用做短视频矩阵的平台有抖音、快手、百家号、西瓜、头条等几大热流平台，通过调查分析，目前抖音坐拥亿级流量，成为商家流量必争之地。所以我们下面分析也主要以抖音短视频平台为例。
账号矩阵应该怎么做？ （1） 首先是独立的抖音号之间互相客串，主要方式是“大号”的视频中出现“小号”的人物角色，然后再引导大号的粉丝去关注小号。
（2）关键词布局
网站seo里面有一个很重要的思维叫关键词思维。
因为关键词是SEO优化的基础，用户是通过输入搜索关键词，进入到你的网站。
所以你布局的关键词越多，精准性越高，关键词排名越好，你的流量也就越大。
所有SEO优化步骤和技巧，都是为了关键词能获得好的排名。
抖音seo关键词布局4个步骤：
（1）找关键词
关键词不是随便选的。
最好选择有蓝海且有潜力的精准关键词。
做过网站SEO的小伙伴都知道，可以利用各种挖词工具去找关键词（比如百度SEO就有百度关键词规划师或者站长关键词工具类）；
但是目前，做抖音seo的还很少，抖音的搜索推荐也还不算是特别完善。
所以找关键词这个动作先阶段，建议手动去找。
有人会说，为什么不直接就用百度挖词工具提取的关键词去布局呢？
这个是因为每个平台的用户搜索习惯是不一样的。
（2）制作关键词相关视频
找到关键词之后，接下来就是制作与关键词相关的视频了。
因为seo的核心除了排名，还有内容。内容才是影响最终转化率的关键。
Google也好，百度也好，都是给谁服务的？
给所有寻找答案的人。
如果你不能提供有吸引力的内容，你的网站对客户没有价值，客户不点你，不看你，不买你，搜索引擎里就没有你曝光、点击、停留、购买等数据的积累。
抖音seo也是同样的道理。
怎么制作与关键词相关的视频呢？
最简单的就是根据用户搜索的关键词，去相应的解决他的问题，给他想要的答案。
做SEO核心就是解决用户痛点和需求，从而才会给你带来流量和转化。
（3）布局关键词
既然是做抖音seo的搜索流量，那就和普通的抖音玩法不一样。
前面我们也说过seo要有关键词思维，那么如何将这种思维正确的运用到抖音seo运营中去呢？
最简单的就是布局关键词。怎么布局？能插入关键词的地方就插入关键词，增加用户搜索到的概率。
名称包含关键词：
抖音账号名称包含行业关键词；比如：
视频文案包含关键词：
视频文案包括视频脚本（视频内容）和视频标题。比如：
话题包含关键词用“#”表示：
其他地方：
视频、用户、音乐、话题、直播、商品，凡事可以加上关键词的地方，都可以有意识的去布局关键词。把关键词思维运用到极致。
（4）关键词霸屏
批量做号：即可以是自己，也可以组织团队；
占领全部“相关搜索”词；
根据每个长尾关键词做一条视频甚至多条视频；
2.研究抖音搜索排名规律
简单的说，抖音的推荐算法会从所有的视频中，挑选出用户喜欢的视频，推荐给用户。
怎么推荐？通过数据。
比如视频本身的信息，包括视频标题、视频话题、视频内容，还有视频发布之后，视频与用户的交互历史，比如点赞、评论区互动评论热词，观看时长。
也会参考用户历史观看过的视频信息和动作（是否有互动行为）等等多维度的数据来决定，是否向用户推荐你的视频。
所以你会发现，每个人在抖音搜索同一个关键词，出来的搜索结果都是不一样的。
那么问题来了，抖音的推荐算法、搜索算法这么复杂，我怎么才能摸清楚抖音seo的排名规律，让我的视频排名靠前呢？
官方也给出了解决的方法：“让观众喜欢你的视频”。
也就是我们前面所说的围绕关键词，能够解决用户问题和潜在搜索目的的优质视频内容。
虽然我们也摸索出了一些抖音seo的排名规则，可以大概率的让视频排在搜索结果前面，但是为什么不直接告诉你呢？
如果你看完了上面的文章，你就知道，不管是搜索算法还是推荐算法，抖音也会“与时俱进”。
也就是说，算法也不是一成不变的。尤其是规则更改相当频繁的抖音。
这也是我们想要告诉你的最后一件事：坚持优化。坚持每天做，是成功的关键。
坚持优化关键词，优化视频内容，然后根据视频数据反馈，持续优化视频排名。
SEO是一个长期和积累的过程 ，就像一坛美酒，你做的时间越长，则结果越香醇，越容易从SEO中获得收益。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1fb21210c6679db10c027dcff804e0a/" rel="bookmark">
			MySQL中find_in_set()函数用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 find_in_set()官方涵义（MySQL手册中语法说明） FIND_IN_SET(str,strlist)，该函数的作用是查询字段(strlist) 中是否包含(str)的结果，返回结果为 null或记录 。
str 要查询的字符串
strlist 需查询的字段，参数以”,”分隔，形式如 (1,2,6,8,10,22)
假如字符串str在由N个子链组成的字符串列表strlist 中，则返回值的范围在 1 到 N 之间。 一个字符串列表就是一个由一些被 ‘,’ 符号分开的子链组成的字符串。如果第一个参数是一个常数字符串，而第二个是type SET列，则FIND_IN_SET() 函数被优化，使用比特计算。 如果str不在strlist 或strlist 为空字符串，则返回值为 0 。如任意一个参数为NULL，则返回值为 NULL。这个函数在第一个参数包含一个逗号( , )时将无法正常运行。
示例：
SELECT FIND_IN_SET('b', 'a,b,c,d'); // 结果：2 // 因为 b 在strlist集合中2的位置, a是位置1 select FIND_IN_SET('1', '1'); // 结果：1 // 这时候的strlist集合有点特殊，只有一个字符串 select FIND_IN_SET('2', '1,2'); // 结果：2 select FIND_IN_SET('6', '1'); // 结果：0 strlist中不存在str，所以返回0。 综上： FIND_IN_SET函数中，若前一个字符串包含在后一个字符串集合中，返回大于0的数，该数为前一个字符串在后一个字符串中的位置。
2、find_in_set() 和 in 的区别 新建测试表，增加几条测试数据。
CREATE TABLE `test` ( `ID` int(11) NOT NULL, `LIST` varchar(255) DEFAULT NULL, PRIMARY KEY (`ID`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO `test` VALUES ('1', 'AA,BB,CC'); INSERT INTO `test` VALUES ('2', 'AA,BB'); INSERT INTO `test` VALUES ('3', 'AA'); find_in_set()和in的查询比较
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1fb21210c6679db10c027dcff804e0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/182e83e171b69adfa6a4e707c805395d/" rel="bookmark">
			常见开源协议横向对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 简介2 常用协议简介BSDApache License 2.0MITMPLEPLLGPLGPL2.0GPL3.0AGPLMPLEPLNo License 3 横向对比4 总结 1 简介 软件开发协议经常看到的内容，但是很多人不知道协议的具体内容，甚至连最基本的概念也没有。因此，本文对协议的概念、常见协议进行介绍，并横向对比。以便大家更好地理解这些协议。
2 常用协议简介 软件的协议相当于软件发布方提出的使用要求。这些要求是具有法律效应。如果不遵守，轻则受到警告，重则受到经济制裁或受到经济损失。所以，任何软件开发者都应该注意软件的常用协议。
BSD 商业软件可以使用，也可以修改使用BSD协议的代码。
需要遵守以下规则：
如果分发的软件包含源代码，则必须在源代码中保留原始的BSD许可证声明。如果分发的软件仅包含⼆进制程序，则必须在⽂档或版权说明中保留原始的BSD许可证声明。未经许可，不得使⽤原始作者或机构的名字为软件做市场推⼴。 Apache License 2.0 Apache Licence是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。Apache Licence是著名的非盈利开源组织Apache采用的协议，需要遵守以下规则：
必须在源代码中保留原始的Apache许可证声明。如果⽤户修改了源代码，需要在被修改的⽂件中说明。在衍⽣产品中，必须保留原来代码中的版权、专利、商标及作者规定的其他需要包含的说明等信息。如果在分发的软件中包含Notice⽂件，则需要在Notice⽂件中包含Apache许可证声明。 MIT 商业软件可以使用，也可以修改MIT协议的代码，甚至可以出售MIT协议的代码。需要遵守以下规则：
如果分发的软件包含源代码，则必须在源代码中保留原始的MIT许可证声明。如果分发的软件仅包含⼆进制程序，则必须在⽂档或版权说明中保留原始的MIT许可证声明。 MPL 商业软件可以使用，也可以修改MPL协议的代码，但修改后的代码版权归软件的发起者。
EPL 商业软件可以使用，也可以修改EPL协议的代码，但要承担代码产生的侵权责任。
LGPL 产品对外分发或销售时静态链接的相关代码要开源，因此商用时需要动态链接使用。商业软件可以使用，但不能修改LGPL协议的代码。需要遵守以下规则：
如果软件通过动态链接的⽅式使⽤LGPL类库，则该软件不需要开源。如果软件通过静态链接的⽅式使⽤LGPL类库，则软件作者必须提供程序的⼆进制⽬标⽂件（不需要提供源代码），以便⽤户有机会更新LGPL类库并重新链接到该程序。如果修改了LGPL的源码或者衍⽣了新的代码，则所有修改后及衍⽣的代码也必须遵循LGPL许可证 GPL2.0 产品对外分发或销售时链接的相关代码要开源，因此商用时要进程隔离。商业软件不能使用GPL协议的代码。
GPL3.0 GPLv3包含了明确的专利许可以及添加了对数字版权管理和加密签名的限制，不仅要求⽤户公开源码，还要求公布相关硬件及必要的安装信息。
AGPL 产品即使不对外分发或销售，链接的相关代码也要开源，因此商用时要进程隔离。
MPL MPL License由Mozilla基⾦会开发并维护，介于BSD（衍⽣代码可以闭源）和GPL（衍⽣代码必须以GPL⽅式开源）之间，最新发布的2.0版以更简洁和更好的兼容其他协议为⽬标，⿎励企业和开源社区为开发核⼼软件做更多贡献。
使用MPL源码需要遵守以下规则：
如果修改了MPL的源码或者衍⽣了新的代码，并且以源代码⽅式发布的⽂件，则所有修改后及衍⽣的代码也必须遵循MPL许可证。如果⽤户⾃有的源码通过专⽤接⼝访问MPL的源码及类库，则包含专⽤接⼝的代码必须遵循MPL许可证，⽤户⾃有源码不必遵循MPL许
可证。⽤户获得MPL代码中的专利许可，但是不能使⽤其原始商标。 EPL EPL License由Eclipse基⾦会开发并维护，在CPL基础上删除了专利相关诉讼的限制条款。EPL⽐GPL许可证更为宽松，并且与GPL并不兼容。使⽤EPL源码需要遵守以下规则：
如果修改了EPL的源码或者衍⽣了新的代码，并且以源代码⽅式分发，则所有修改后及衍⽣的代码也必须遵循EPL许可证。如果软件以⼆进制⽬标⽂件的形式分发，则需要声明可以根据请求向其他⽤户提供源代码。⽤户获得EPL代码中的专利许可。 No License 随便用 随意改
3 横向对比 Item/ProtocalBSDApache License 2.0MITMPLEPLLGPLGPL2.0GPL3.0AGPLMPLEPLNo License商业软件免费免费免费免费免费免费收费收费收费免费免费免费个人软件免费免费免费免费免费免费收费收费免费免费免费免费散布是是是是是是是是是是是是修改是是是是是是是是是是是是授权转售是是是是是是是是是是是是无担保责任是是是是是是是是是是是是 4 总结 本文对常见的协议进行了简介和横向对比，希望对软件开发者有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d93f3ad7f53cf99745c85bfff8229a3d/" rel="bookmark">
			FinalShell工具下载安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
简介
一、下载
1、百度搜索finalshell找到官网
2、点击下载最新版本
3、我下的是windows版的，看自己需求下载
4、下载好了，我的安装包在这
二、安装 三、启动FinalShell
四、连接远程 linux 服务器
五、更换背景图
六、连接记录删除
简介 FinalShell 是一款免费的国产的集 SSH 工具、服务器管理、远程桌面加速的良心软件，同时支持 Windows,macOS,Linux，它不单单是一个 SSH 工具，完整的说法应该叫一体化的的服务器，网络管理软件，在很大程度上可以免费替代 XShell，是国产中不多见的良心产品，具有免费海外服务器远程桌面加速，ssh 加速，双边 tcp 加速，内网穿透等特色功能。（这段我复制的，嘿嘿）
一、下载 1、百度搜索finalshell找到官网 2、点击下载最新版本 3、我下的是windows版的，看自己需求下载 4、下载好了，我的安装包在这 二、安装 三、启动FinalShell 四、连接远程 linux 服务器 先确保linux系统已经开启，不然连接不上
左边是服务器端数据的监控
工作台下面是一些快捷菜单工具栏及文件管理
基本使用介绍就这些，其它的后面使用就知道了
这个软件结合了Xshell和Xftp的功能，无需再安装Xftp，即可快速传输文件到远程
五、更换背景图 FinalShell自带的壁纸如果不喜欢，可以进行下面步骤进行替换
关掉FinalShell软件，不然背景图保存不成功。。。
找5张自己喜欢的图片，换成上面壁纸的名称，注意要一致，后缀不是.jpg是不可以的，对上面原有的进行替换即可
搞定，关掉jar包窗口，重启FinalShell
六、连接记录删除 平时连了其它机器后，有个连接记录，删不掉，很碍眼
可以到软件安装目录的conn中，把新建的都删掉。当然，你一开始没注意，可能不记得哪个是要留下的，可以对比时间，如果对比时间还是分不清，可以全部删掉（或直接把conn文件夹删掉），然后重新打开FinalShell，重新执行第四步连接远程 linux 服务器，我这里知道要留下哪个，就不全删了
重新打开软件，舒服，只剩一个记录了 下课！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/581427c5194ead5844f8d8767209460d/" rel="bookmark">
			Linux 时区与时间time
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UTC时间：这是一个与时区相关的时间，目前将世界时区分为24个：
UTC跟GMT（Greenwich Mean Time，格林威治时间）一致，因为格林威治位于0时区，UTC时间即是0时区的时间。中国位于东八区，所以对应的时间是UTC时间加8小时，即UTC+8，也称为CST（China Standard Time）。UTC倾向于跟标准相关的时间。UTC的查看可以通过date命令(命令需要加上-u，否则看到的是本地时间，即UTC+8的时间)；
RTC：Real Time Clock，实时时钟。RTC和UTC不是一个概念上的时间，RTC通常指的是系统上一个计时的芯片，它将时间保存在CMOS中，而CMOS通过电池可以保持数据不丢失，因此在系统没有上电的情况下也还会正常运行。操作系统启动时会查看这个时间，也可以同步这个时间。RTC倾向于跟硬件相关的时间。查看RTC的命令如下(当前最好在root用户下)
Calendar Time：日历时间，指的是从当前时间到某个标准时间经历的秒数。这里的某个时间通常是指1970年1月1日0时0分0秒，这个时间点也被称为Epoch。日历时间是一个相对的时间值，倾向于跟软件相关。
与时间相关的常用函数：
/* Return the current time and put it in *TIMER if TIMER is not NULL. */ extern time_t time (time_t *__timer) __THROW; 它的入参和返回值都是time_t，它实际上就是一个长整型，表示的就是从Epoch到函数调用之时经历的秒数，也就是前面提到的日历时间。为了得到这个时间，通常传入一个NULL作为参数，返回值就是我们需要的。
#include &lt;stdio.h&gt; #include &lt;time.h&gt; time_t time_test(void) { time_t t = time(NULL); return t; } int main(int argc, char *argv[]) { time_t t = time_test(); printf("time_test:%ld\n", t); return 0; } 执行结果：
gmtime()函数会利用time_t的值，并将其转换为一个真正的时间，从函数名称就可以看出来是格林威治时间，也就是UTC的时间。与gmtime对应的就是转化为本地时间的函数localtime()。它们的函数原型如下：
# ifdef __USE_POSIX /* Return the `struct tm' representation of *TIMER in UTC, using *TP to store the result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/581427c5194ead5844f8d8767209460d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05ba5a4c633cb3fa96b4142a0cd48ea9/" rel="bookmark">
			写给信息学竞赛选手的趣味编程 基于DevC&#43;&#43;的SDL2图形程序设计（五） 三层汉诺塔的简单游戏实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本程序通过敲击键盘上的“向下箭头”键或者在窗口中的鼠标左键单击来控制汉诺塔移动的移动。实际上如果有键盘或鼠标控制的动画就相当于是游戏了，可以认为游戏就是带有交互的动画。当然，这只是一种简单理解，大部分游戏是要有博弈在其中的，毕竟没有胜败的游戏是不好玩的。
一、 SDL中事件的概念 大部分操作系统如Windows、Linux和MacOS等，如果开发窗口程序，都主要是基于消息（Message）和事件（Event）的。简单地说，消息是用户或系统的输入部分，在窗口程序开发中,涉及消息循环的处理函数，例如鼠标单击或键盘某个键按下等。而事件是基于消息的,是消息到达后触发的操作。可以简单理解事件是一个函数，是操作系统收到消息后所做的反应。例如当您用鼠标左键单击窗口右上角关闭按钮是，产生了鼠标左键单击的消息，这时窗口关闭这就是一个事件，即执行了关闭操作。
在SDL中好像不提消息，所有的操作都是事件鼠标操作就是鼠标事件、键盘操作就是键盘事件等。在前面介绍的动画制作中利用循环显示了3次三层汉诺塔的动画过程，这个过程中每幅图形通过延时函数显示了1秒。如果不利用循环而是使用键盘或鼠标去控制每幅图片的显示，该如何做呢？这个时候就需要事件了。所谓事件相当于是程序的输入，键盘事件是敲击键盘，鼠标事件就是单击或双击鼠标键，窗口事件就是窗口的改变，如最大化，还原等。在SDL中，将所有的事件都存放在一个事件队列中，然后通过一个循环从队列中取出事件，进行处理，所有对事件的操作，就是对队列的操作。
二、事件处理的实现 EveProc（）函数是在Game类中预留的事件处理函数。消息事件的处理都是在这个函数中进行的。本程序中定义了三个事件处理功能，即关闭窗口事件、窗口鼠标左键单击事件和键盘的向下箭头按键事件。
1. 关于窗口关闭功能的实现 功能描述：利用鼠标左键单击窗口右上角关闭（x）按钮，实现窗口关闭。
实现方法：主要通过在Game类中定义一个窗口start公有数据成员来标记窗口的状态，当start=1即表示窗口运行，=0表示窗口关闭，程序首先将start设为1，在事件处理中遇到关闭窗口消息就将其设置为0；然后在主函数中根据start的状态决定是否结束程序。在程序中的修改主要包括四个部分：
（1）类中添加公有数据成员start，并修改EveProc函数参数，如图所示：
说明：数据成员公有好像不太符合类设计的思想，但确实可以这样用的。
（2）在构造函数中设置start=1，如图所示：
（3）添加EveProc（）函数定义，在其中加入消息处理，如图所示：
其中:
首先，定义了一个SDL接收事件变量e;
然后，while循环调用SDL_PollEvent(&amp;e)事件轮询函数，反复接收消息；
最后，Switch…case结构用于判断接收到的消息类型是否是SDL_QUIT（表示关闭窗口的消息），如果是则修改Start。
这个while+switch…case结构可以作为接受消息检测的模板，后面直接使用即可。
说明：在SDL中可以处理的事件包括Window窗口相关的事件、键盘相关的事件、鼠标移动相关的事件、退出事件和用户自定义事件。
（4）修改主函数，如图所示：
此时，根据game.Start的状态决定程序是否继续运行。
运行该程序后，汉诺塔移动的动画消失，但却多了一个关闭窗口功能。
2. 键盘事件的处理 功能描述：利用键盘上的“向下箭头“键控制动画一幅一幅显示。
实现方法：通过在EveProc()中添加键盘处理事件，循环监听是否有“向下箭头“键按下，如果有则调用Update（）修改盘子参数再显示。
这个过程中要注意两点：
（1）由于原来Update（）是利用i循环显示8幅图片的，现在变为一次显示1幅图片，因此需要去掉i循环；同时在类中定义私有的数据成员i，用于传递显示的是第几幅图片。
（2）由于有了事件监听处理，所以原理图片显示过程中的延时不再需要了，可以去掉；
具体操作分为6步，介绍如下：
（1）修改Game类添加数据成员i用于控制显示的图片数，同时修改函数参数，如图所示：
说明：i是私有成员只能在类的成员函数中使用，Start是公有成员可以在类外使用。
（2）构造函数中初始化私有成员，如图所示：
（3）去掉Init（）函数中的显示延时操作，如图所示：
（4）修改EveProc()函数添加键盘事件处理，如图所示：
其中，首先判断是否是SDL_KEYDOWN键盘按下事件，如果是则通过e.key.keysym.sym来获得按键类型，如果是SDLK_DOWN“向下箭头”按键，则调用Update()函数，其参数i表示第i幅图，在修改坐标并显示图片后，将i增加1个，因为共有8幅图（0~7），所以需要当i大于7时将i置为0，重新开始显示。
说明：
1）键盘事件主要分两种：SDL_KEYDOWN、SDL_KEYUP（键盘按下和抬起）。
2）按键类型很多包括组合按键和单独按键，这里介绍常用的单独按键包括：
注意：很奇怪的是，有些按键需要按下大小写锁定键才有效。
（5）修改Update函数变成一次修改显示一幅图像，如图所示：
（6）最后去掉OnDraw（）函数中的延时操作，即可。
3.鼠标事件的处理 有了前面的铺垫，实现鼠标事件很简单了，只需在EveProc（）函数中添加鼠标事件处理即可。如图所示：
鼠标事件可以是SDL_MOUSEMOTION（鼠标移动），SDL_MOUSEBUTTONDOWN（鼠标按下），SDL_MOUSEBUTTONUP（鼠标抬起）和SDL_MOUSEWHEEL（鼠标移动）类型。具体各种类型如何使用，可以从网上自行搜索。这里介绍一个常用的操作：
SDL_GetMouseState(&amp;x,&amp;y);
用于获取鼠标左键点击处的x坐标和y坐标。
利用这个函数加上输出操作，可以在程序开始时帮助你很好的了解背景图各部分的坐标。
三、 完整代码 1.	//添加事件处理功能 2.	#include "SDL.h" 3.	#include "SDL_image.h" 4.	int InitPos[6]={75,190,55,230,35,270}; 5.	int pos[8][6]={{0},{2,2,0,0,0,0},{2,2,1,1,0,0},{1,1,1,1,0,0}, 6.	{1,1,1,1,2,0},{0,2,1,1,2,0},{0,2,2,0,2,0},{2,0,2,0,2,0}}; 7.	class Game{	8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05ba5a4c633cb3fa96b4142a0cd48ea9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a622dab86c575423fb27e1acd896c3e/" rel="bookmark">
			Mqtt安装及部署手册（包含与WebSocket通信配置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载并安装MQTT 1.首先搭建起MQTT服务
1.1安装mosquitto，mosquitto是开源的MQTT代理服务器，它的Windows安装包地址：https://mosquitto.org/download/
这里建议下载2.0.11版本，个别版本和Socket通信会出现问题，这个是个坑点，看下图； 1.2 安装完成后，去安装目录下找到mosquitt.conf 文件，记事本方式打开，配置参数；
*这里的8888，mqtt通信端口，9001是WebSocket协议端口，建议额外配置一下匿名访问：allow_anonymous true；
1.3 接下来启动Mqtt服务；
执行：mosquitto_passwd.exe -c pwfile.example -u vic
设置用户名：admin 设置密码：123456
配置文件检查：
mosquitto.exe -c mosquitto.conf
未报错说明配置正确（卡着不动了，重新打开cmd，定位到安装目录，执行下面的命令即可）
端口启动
默认端口：8888
启动：mosquitto.exe
指定端口启动：mosquitto.exe -p 8888
下面就可以启动订阅者和发布者了，上面的启动窗口不要关闭哦，下面分别再打开两个cmd窗口；
①订阅者启动
-u是用户名，-P是密码，-t是主题，-h是ip，-p是端口号
mosquitto_sub.exe -h 127.0.0.1 -p 8888 -t topic -u admin -P 123456
② 发布者
mosquitto_pub.exe -h 127.0.0.1 -p 8888 -u admin -P 123456 -t topic -m “hello world 123456”
这里的主题 “topic” 两方必须保持一致，否则收不到信息
若执行发布者和订阅者命令时，若出现*“由于目标计算机积极拒绝，无法连接”**，大概率是权限问题，设一下mosquitto.conf文件的权限，这个是个坑点；
用命令：mosquitto -c mosquitto.conf -v
重启一下服务即可；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a622dab86c575423fb27e1acd896c3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53e9a50f21caaa77b00903fbf964e661/" rel="bookmark">
			Linux time.h头文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、相关头文件
与时间相关的头文件：time.h sys/time.h sys/times.h sys/timeb.h sys/timex.h；其中time.h是C标准库中的头文件，其余sys开头的都为Linux系统自带的头文件；
在/usr/include/time.h 定义了常用的time函数；
在/usr/include/sys目录下查看这几个文件：
sys/time.h定义了timezone结构体和Linux系统的时间函数；
sys/times.h 定义了进程使用CPU时间的结构体tms；
sys/timeb.h定义了ftime函数的返回值的结构体timeb；
sys/timex.h定义了关于时钟调整算法的结构体timex；
2、常用函数和结构体
time函数原型(time.h中)
参数：time_t (类型变量的指针)
返回值：time_t 相当于一个long类型，time用于取Epoch记年以来到现在经过的秒数(系统当前时间)，Epoch记年从1970年1月1日开始。把取到的时间存在指针指向的变量中。
localtime函数原型(在time.h中)：
struct tm *localtime(const time_t *calptr);
参数：time_t 类型变量的指针；
返回值：指向 tm 结构体的指针类型；作用是将time_t的值转换为tm结构体。然后可以打印输出。
#ifdef	_TIME_H __BEGIN_NAMESPACE_STD /* Used by other time functions. */ struct tm { int tm_sec;	/* Seconds.	[0-60] (1 leap second) */ int tm_min;	/* Minutes.	[0-59] */ int tm_hour;	/* Hours.	[0-23] */ int tm_mday;	/* Day.	[1-31] */ int tm_mon;	/* Month.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53e9a50f21caaa77b00903fbf964e661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b520898beb800ef30a7ed50c34e6887c/" rel="bookmark">
			SR-GNN:Session-based Recommendation with Graph Neural Networks 论文阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Session-based Recommendation with Graph Neural Networks AAA I 2019
论文地址：https://arxiv.org/abs/1811.00855
源码地址：https://github.com/CRIPAC-DIG/SR-GNN
摘要 基于会话的推荐问题旨在基于匿名会话预测用户行为，以前的方法将会话建模为序列，并估计除项目表示之外的用户表示以提出建议
存在的不足：不能够获得准确的用户向量并忽略项目的复杂转换 因此，提出使用图神经网络的基于会话的推荐SR-GNN，将会话序列被建模为图形结构化数据，GNN 可以捕获项目的复杂转换，然后使用注意力网络将每个会话表示为全局偏好和该会话当前兴趣的组合
基本介绍 大多数现有的推荐系统都假设用户资料和过去的活动被不断记录。
然而，在许多服务中，用户标识可能是未知的，并且只有正在进行的会话期间的用户行为历史可用
因此在一个会话中对有限的行为进行建模并相应地生成推荐是非常重要的，但在这种情况下，依赖于充分的用户-项目交互的传统推荐方法在产生准确结果方面存在问题
相关的论文 基于马尔可夫链：在强独立假设下，过去分量的独立组合限制了预测精度基于RNN：提出了一种循环神经网络方法，然后通过数据增强和考虑用户行为的时间变化来增强模型NARM：设计了一个全局和局部 RNN 推荐器来同时捕捉用户的顺序行为和主要目的STAMP：也通过使用简单的 MLP 网络和注意力网络来捕捉用户的一般兴趣和当前兴趣 以上研究存在的局限性： 在一个会话中没有足够的用户行为，这些方法难以估计用户表示， 会话大多是匿名的且数量众多，并且会话点击中涉及的用户行为通常是有限的。因此很难从每个会话中准确估计每个用户的表示 项目转换的模式很重要，可以用作基于会话的推荐中的局部因素 但这些方法总是对连续项目之间的单向转换和忽略上下文之间的转换，即会话中的其他项目。因此，这些方法经常忽略远距离项目之间的复杂转换。 为了克服以上局限性，提出SR-GNN，以探索项目之间的丰富转换并生成准确的项目潜在向量。
GNN被广泛应用于为自然语言处理和计算机视觉应用建模图结构依赖关系，如脚本事件预测、情景识别和图像分类
SR-GNN的工作流程 首先，所有会话序列都被建模为有向会话图，其中每个会话序列都可以视为一个子图然后，每个会话图依次进行,通过门控图神经网络获得每个图中涉及的所有节点的潜在向量表示embedding(v1,v2,v4,v3)之后，我们将每个会话表示为全局偏好和该会话中用户当前兴趣的组合，其中这些全局和局部会话嵌入向量都由节点的潜在向量组成。 根据embedding经过一个attention，得到session的embedding（分成全局sessionEmbedding和local session embedding，将最后一个item直接作为local embedding）再将两个session embedding 聚合成session的总的 embedding 最后，对于每个会话，我们预测每个项目成为下一次点击的概率 将session总的embedding与节点的embedding相乘得到最终的结果，再进行筛选得分最高的几个输出 模型的贡献 将分离的会话序列建模为图结构化数据，并使用图神经网络来捕获复杂的项目转换不依赖用户表示，而是使用会话embedding，它可以仅基于每个单独会话中涉及的项目的潜在向量来获得基于会话的推荐 领域相关工作 常规推荐方法 矩阵分解：基本目标是将用户-项目评分矩阵分解为两个低秩矩阵，每个矩阵代表用户或项目的潜在因素 缺点：用户偏好仅由一些积极的点击提供，不太适合基于会话的推荐 基于项目的邻域方法：项目相似性是根据同一会话中的共现来计算的 缺点：难以考虑项目的顺序，并且仅基于最后一次点击生成预测 基于马尔科夫链的顺序方法：将推荐生成视为一个顺序优化问题，采用马尔可夫决策过程 (MDP) 来解决问题 通过对用户的个性化概率转移矩阵进行分解缺点：独立地组合了过去的组件。这种独立性假设太强，从而限制了预测的准确性。 FPMC ： 对每两次相邻点击之间的序列行为进行建模，并为每个序列提供更准确的预测 基于深度学习的方法 RNN：扩展到具有并行 RNN 的架构 ，该架构可以基于点击次数和特征对会话进行建模点击的项目 RNN的一些相关变体应用于会话推荐 通过使用适当的数据增强技术并考虑用户行为的时间变化来提高循环模型的性能将循环方法和基于邻域的方法结合在一起，以混合顺序模式和共现信号将会话点击与项目描述和项目类别等内容特征相结合，通过使用 3 维卷积神经网络生成推荐A list-wise deep neural network: 对每个会话中有限的用户行为进行建模，并使用 list-wise 排名模型为每个会话生成推荐具有编码器-解码器架构的神经注意力推荐机NARM：采用 RNN上的注意力机制来捕获用户的顺序行为特征和主要目的。一种使用简单 MLP 网络和注意力网络的短期注意力优先模型 (STAMP) ：以有效地捕捉用户的一般兴趣和当前兴趣。 图神经网络相关发展 扩展word2vec，无监督算法 DeepWalk：旨在基于随机游走来学习图节点的表示继 DeepWalk 之后，无监督网络embedding算法 LINE 和 node2vec另外，CNN 和 RNN 也部署在图结构数据上， 如GCN：通过谱图卷积的局部近似来选择卷积架构，但只在无向图上实现门控 GNN (Li et al.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b520898beb800ef30a7ed50c34e6887c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9daaf4d727ec652675baeed2cfc2fac0/" rel="bookmark">
			抖音短视频获客系统源码开发及搭建分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		短视频账号矩阵系统/短视频seo霸屏系统/短视频矩阵seo系统源码/独立部署，技术团队如何围绕短视频矩阵关键词霸屏来做开发？来做到抖音seo优化达到账号排名效果，关键词起到至关重要的作用，依托于各平台的正规权限。所申请的的接口来做真正合规的产品开发。
场景：当普通对象属性更改后，触发所绑定的 onChange 回调；
思路：能更改属性的有 set 和 deleteProperty 这两个 trap，在其中调用 onChange 方法即可
抖音矩阵源码布局，短视频矩阵源码管理系统的主要理论逻辑，依托于短视频正常规则做开发，正规机制产品内，多平台分发，定时发布自定义设置，智能标题生成这些都是技术公司大同小异的一些常规功能了，近期更新抖音seo艾特账号功能，形成矩阵互评 ，视频加热等
抖音智能营销获客开发系统，从技术逻辑出发利用php后台语言，技术开发的整套系统，整套系统有同城拓客--创建活动-同步同能更新操作，官方企业号产品，短视频号下面的视频数据展示列表，粉丝数据展示，互动行为展示，前端页面是个一键数据清晰概览图
目前有些新的企业crm管理系统在优化，技术逻辑上设置的有公司简单组织架构，同步技术更新的功能：
1 智能接待2 粉丝列表转化3 用户互动行为记录4 文案库自动跳转5 行为动态追踪
系统后台设定自定义的素材库，根据用户的触发前端场景及时后台设定自动技术回复，可以查看用户与企业号之间的的每次互动记录，根据用户互动的频率后台追踪客户的意向判定:
商家可查看已授权企业账号的账号数据、视频数据、私信互动数据、线索用户数据
商家可在系统授权多个抖音企业账号，同时管理，高效迅速实 现多账号AI管理.操作如下：
在企业号管理页面中，点击新增抖音企业号授权，使用抖音扫码，或者手机验证码登录.
.商家可在视频管理内查看授权账号内的视频以及把视频添加到文案素材库，商家可在粉丝管理查看授权账号的粉丝信息并对粉丝进行私信，商家可在关注管理查看授权账号的关注信息并对关注用户进行私信。
商家可在意向客户内查看授权账号的意向客户信息，商家可通过一键私信功能对企业账号的粉丝或关注进行批量私信。
商家可在意向客户内查看授权账号的意向客户信息，商家可根据更新统计更新最新企业号基础数据
商家可查看企业账号内所接收的所有私信内容并进行回复商家可查看授权账号加入或创建的群聊并发布群消息以及查看群互动记录，商家可根据更新统计更新最新企业号基础数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/042ad00eeba06d8e6ec0e8064a84b0d7/" rel="bookmark">
			HDMI接口和DP接口的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HDMI接口和DP接口的区别 文章目录 HDMI接口和DP接口的区别厂商不同版本进化普及范围 厂商不同 HDMI是电视机厂商主导的，而DP是由PC及芯片制造商联盟开发的。需要注意的是，HDMI需要授权费，DP则不需要。
版本进化 HDMI接口：
HDMI1.4最大带宽为10.2Gdps，理论支持1080P 144hz、2K 75hz、3840 x 2160/30hz、4096 x 2160/24hz。
HDMI2.0最大带宽为18Gbps，支持1080P 240hz、2K 144hz、4K 60hz、5K 30hz。
HDMI2.1最大带宽为48Gbps，支持2K 240hz、4K 144hz、5K 60hz、8K 30hz。
DP接口：
DP接口第一代带宽达到了10.8Gbps；DP1.2带宽高达21.6Gbit/s，DP1.4带宽也达到32.4Gbps，但加入了DSC显示压缩流技术，从而支持4K下240Hz、8K下60Hz。
接口类型/分辨率1080P2K4K8KHDMI 1.4120Hz60Hz30Hz-HDMI 2.0240Hz144Hz60Hz30HzHDMI 2.1240Hz240Hz120Hz60HzDP 1.2240Hz144Hz60Hz30HzDP 1.4240Hz240Hz240Hz60Hz 普及范围 HDMI接口：目前市面上的智能电视及其附属设备（机顶盒，游戏主机，笔记本、数码相机等）几乎都配备有HDMI接口，应用面非常广泛。另外，目前主流的PS4和Xbox等游戏主机都是使用的HDMI接口。
DP接口：主要在PC领域流行。另外，AMD显卡的Eyefinity多屏拼接技术必须要用到DP接口。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c369e1fbc03e32507bae24e772a11c/" rel="bookmark">
			黑马程序员——三天快速入门python机器学习（总结篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 机器学习总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/907e35fae5fa44e4c15b9d3a4edf4b7d/" rel="bookmark">
			黑马程序员——三天快速入门python机器学习（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回归与聚类算法（2） 分类算法——逻辑回归与二分类逻辑回归应用场景逻辑回归原理逻辑回归API案例 ：癌症分类：良/恶性乳腺癌肿瘤预测分类的评估方法ROC曲线与AUC指标 模型保存和加载sklearn模型保存和加载API案例 无监督学习——K-means算法无监督学习K-means原理K-means API案例：K-means对Instacart Market 用户聚类聚类的模型评估K-means总结 分类算法——逻辑回归与二分类 逻辑回归应用场景 广告点击率：是否会被点击是否为垃圾邮件是否患病是否为金融诈骗是否为虚假账号
以上例子特点：属于两个类别之间的判断，逻辑回归就是解决二分类的利器。 逻辑回归原理 输入：逻辑回归输入的就是一个线性回归的结果。
激活函数 sigmoid 函数
分析
1）回归的结果输入到sigmoid函数中。
2）输出结果为[0,1]之间的一个概率值，默认0.5为阈值，大于0.5认为属于这个类别，反之 。 3. 损失及优化
逻辑回归的损失，称之为对数似然损失，公式如下
分开类别：
综合完整损失函数
优化：同样使用梯度下降优化算法，去减少损失函数的值。这样去更新逻辑回归前面对应算法的权重参数，提升原本属于1类别的概率，降低原本是0类别的概率
逻辑回归API sklearn.linear_model.LogisticRefression(solver=‘liblinear’, penalty='l2, C=1.0)
penalty：正则化种类C：正则化力度solver：优化求解方式（默认开源的liblinear库实现） LogisticRegression方法相当于SGDCIassifier(loss=“log”, penalty=" "), SGDClassifier实现了一个普通的随机梯度下降学习也支持平均随机梯度下降法(ASGD)，可以通过设置average=True。而使用LogisticRegression(实现了SAG)
案例 ：癌症分类：良/恶性乳腺癌肿瘤预测 数据介绍
流程分析： 1）获取数据：读取的时候加上names
2）数据处理：处理缺失值
3）数据集划分
4）特征工程：无量纲化处理—标准化
5）逻辑回归预估器
6）模型评估
程序实现 import pandas as pd import numpy as np # 1、读取数据 path = "https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data" column_name = ['Sample code number', 'Clump Thickness', 'Uniformity of Cell Size', 'Uniformity of Cell Shape', 'Marginal Adhesion', 'Single Epithelial Cell Size', 'Bare Nuclei', 'Bland Chromatin', 'Normal Nucleoli', 'Mitoses', 'Class'] data = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/907e35fae5fa44e4c15b9d3a4edf4b7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04293247373a413f9a2f19c0d13bd057/" rel="bookmark">
			Java岛屿数量(DFS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 200.岛屿数量
解题思路:
来自K神
class Solution { public int numIslands(char[][] grid) { int count = 0; for(int i = 0; i &lt; grid.length; i++){ for(int j = 0; j &lt; grid[0].length; j++){ if(grid[i][j] == '1'){ dfs(grid, i, j); count++; } } } return count; } public void dfs(char[][] grid, int i, int j){ if(i &lt; 0 || i &gt;= grid.length || j &lt; 0 || j &gt;= grid[0].length || grid[i][j] == '0'){ return; } grid[i][j] = '0'; dfs(grid, i - 1, j); dfs(grid, i + 1, j); dfs(grid, i, j - 1); dfs(grid, i, j + 1); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5af2b5c094a978eae519fb4bd434c6a1/" rel="bookmark">
			MindSpore新型轻量级神经网络GhostNet，在ImageNet分类、图像识别和目标检测等多个应用场景效果优异！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为研究员提出一种新型轻量神经网络架构，表现全面超越谷歌MobileNetV3和Facebook的FBNet，相关论文累计引用近300，入围PaperDigest的CVPR 2020 Most Influential Papers榜单。论文提出了一个全新的Ghost模块，旨在通过廉价操作生成更多的特征图。基于一组原始的特征图，作者应用一系列线性变换，以很小的代价生成许多能从原始特征发掘所需信息的“幻影”特征图（Ghost feature maps）。该Ghost模块即插即用，通过堆叠Ghost模块得出Ghost bottleneck，进而搭建轻量级神经网络——GhostNet。GhostNet在多种场景如ImageNet分类、细粒度图像识别和目标检测等取得了明显优于MobileNet的效果。GhostNet做持续放大，构建出B1-B4系列模型，持续优于EfficientNet。
论文链接1：https://arxiv.org/abs/1911.11907
论文链接2：https://arxiv.org/abs/2108.00177
Gitee开源地址：
https://gitee.com/mindspore/models/tree/master/research/cv/ghostnet
Github开源地址：https://github.com/mindspore-ai/models/tree/master/research/cv/ghostnet
引言
卷积神经网络推动了计算机视觉诸多任务的进步，比如图像识别、目标检测等。但是，神经网络在移动设备上的应用还亟待解决，主要原因是现有模型又大又慢。因而，一些研究提出了模型的压缩方法，比如剪枝、量化、知识蒸馏等；还有一些则着重于高效的网络结构设计，比如MobileNet、ShuffleNet等。本文就设计了一种全新的神经网络基本单元Ghost模块，从而搭建出轻量级神经网络架构GhostNet。
在一个训练好的深度神经网络中，通常会包含丰富甚至冗余的特征图，以保证对输入数据有全面的理解。如下图所示，在ResNet-50中，将经过第一个残差块处理后的特征图拿出来，三个相似的特征图对示例用相同颜色的框注释。该对中的一个特征图可以通过廉价操作（用扳手表示）将另一特征图变换而获得，可以认为其中一个特征图是另一个的“幻影”。因为，本文提出并非所有特征图都要用卷积操作来得到，“幻影”特征图可以用更廉价的操作来生成。
ResNet50特征图可视化
在本文中，作者提出了一种新颖的Ghost模块，可以使用更少的参数来生成更多特征图。具体来说，深度神经网络中的普通卷积层将分为两部分。第一部分涉及普通卷积，但是将严格控制它们的总数。给定第一部分的固有特征图，然后将一系列简单的线性运算应用于生成更多特征图。与普通卷积神经网络相比，在不更改输出特征图大小的情况下，该Ghost模块中所需的参数总数和计算复杂度均已降低。基于Ghost模块，作者建立了一种有效的神经体系结构，即GhostNet。作者首先在基准神经体系结构中替换原始的卷积层，以证明Ghost模块的有效性，然后在几个基准视觉数据集上验证GhostNet的优越性。实验结果表明，所提出的Ghost模块能够在保持相似识别性能的同时降低通用卷积层的计算成本，并且GhostNet可以超越MobileNetV3等先进的高效深度模型，在移动设备上进行快速推断。
GhostNet基础模型
Ghost模块 深度卷积神经网络通常引用由大量卷积组成的卷积神经网络，导致大量的计算成本。尽管最近的工作，例如MobileNet和ShuffleNet引入了深度卷积或混洗操作，以使用较小的卷积核（浮点运算）来构建有效的CNN，其余1x1卷积层仍将占用大量内存和FLOPs。
鉴于主流CNN计算出的中间特征图中存在大量的冗余（如图1所示），作者提出减少所需的资源，即用于生成它们的卷积核。实际上，给定输入数据
，其中c是输入通道数，h和w是高度，输入数据的宽度，分别用于生成n个特征图的任意卷积层的运算可表示为
其中*是卷积运算，b是偏差项，
是具有n个通道的输出特征图， 是这一层中的卷积核。另外，h’和w’分别是输出数据的高度和宽度，kxk分别是卷积核f的内核大小。在此卷积过程中，由于卷积核数量n和通道数c通常非常大（例如256或512），所需的FLOPs数量达
之多。
(a) 普通卷积层 (b) Ghost模块
根据上述公式，要优化的参数数量（f和b中的参数）由输入和输出特征图的尺寸确定。如图1中所观察到的，卷积层的输出特征图通常包含很多冗余，并且其中一些可能彼此相似。作者指出，没有必要使用大量的FLOPs和参数一一生成这些冗余特征图，而是说，输出特征图是少数原始特征图通过一些廉价转换的“幻影”。这些原始特征图通常具有较小的大小，并由普通的卷积核生成。具体来说，m个原始特征图Y’是使用一次卷积生成的：
其中f'是使用的卷积核，m&lt;=n，为简单起见，这里省略了偏差项。超参数（例如卷积核大小，stride，padding）与普通卷积中的超参数相同，以保持输出特征图的空间大小（即h’和w' ）保持一致。为了进一步获得所需的n个特征图，作者提出对Y'中的每个原始特征应用一系列廉价的线性运算，以生成s个幻影特征图：
其中y'_i是Y'中第i 个原始特征图，上述函数中的
是第j个线性运算，用于生成第 j 个幻影特征图y_ {ij} ，也就是说，y'_i 可以具有一个或多个幻影特征图
最后的
是用于保留原始特征图的恒等映射，如图2(b)所示。通过使用廉价操作，我们可以获得n=m*s个特征图
作为Ghost模块的输出数据。注意，线性运算
在每个通道上运行，其计算量比普通卷积少得多。实际上，Ghost模块中可能有几种不同的线性运算，例如3x3和5x5线性内核，将在实验部分进行分析。
在每个通道上运行，其计算量比普通卷积少得多。实际上，Ghost模块中可能有几种不同的线性运算，例如3x3和5x5线性内核，将在实验部分进行分析。
构建GhostNet Ghost Bottleneck：利用Ghost模块的优势，作者介绍了专门为小型CNN设计的Ghost bottleneck（G-bneck）。如图3所示，Ghost bottleneck似乎类似于ResNet中的基本残差块（Basic Residual Block），其中集成了多个卷积层和shortcut。Ghost bottleneck主要由两个堆叠的Ghost模块组成。第一个Ghost模块用作扩展层，增加了通道数。这里将输出通道数与输入通道数之比称为expansion ratio。第二个Ghost模块减少通道数，以与shortcut路径匹配。然后，使用shortcut连接这两个Ghost模块的输入和输出。这里借鉴了MobileNetV2，第二个Ghost模块之后不使用ReLU，其他层在每层之后都应用了批量归一化（BN）和ReLU非线性激活。上述Ghost bottleneck适用于stride= 1，对于stride = 2的情况，shortcut路径由下采样层和stride = 2的深度卷积（Depthwise Convolution）来实现。出于效率考虑，Ghost模块中的初始卷积是点卷积（Pointwise Convolution）。
Ghost bottleneck
GhostNet：基于Ghost bottleneck，作者提出GhostNet，如表1所示。作者遵循MobileNetV3的基本体系结构的优势，然后使用Ghost bottleneck替换MobileNetV3中的bottleneck。GhostNet主要由一堆Ghost bottleneck组成，其中Ghost bottleneck以Ghost模块为构建基础。第一层是具有16个卷积核的标准卷积层，然后是一系列Ghost bottleneck，通道逐渐增加。这些Ghost bottleneck根据其输入特征图的大小分为不同的阶段。除了每个阶段的最后一个Ghost bottleneck是stride = 2，其他所有Ghost bottleneck都以stride = 1进行应用。最后，利用全局平均池和卷积层将特征图转换为1280维特征向量以进行最终分类。SE模块也用在了某些Ghost bottleneck中的残留层，如表1中所示。与MobileNetV3相比，这里用ReLU换掉了Hard-swish激活函数。尽管进一步的超参数调整或基于自动架构搜索的Ghost模块将进一步提高性能，但表1所提供的架构提供了一个基本设计参考。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5af2b5c094a978eae519fb4bd434c6a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad1b80325ed5e20c067febf20b97faea/" rel="bookmark">
			一、python基础入门2-变量和数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是变量 变量指代储存的数据
2. 变量命名基本规则 变量不能是系统关键字。变量只能由数字、字母、下划线组成，不能以数字开头。变量区分大小写 3. 变量命名规范 见名知意
驼峰命名法：
a. 大驼峰命名法：变量中每个单词的首字母都大写。（FirstName）
b. 小驼峰命名法：变量中从第二个单词开始首字母大写。（firstName）
4. 查看系统关键字 from keyword import kwlist print(kwlist) 5. 查看数据类型 a = 1 print(type(a)) # &lt;class 'int'&gt; -- 整型 b = 1.1 print(type(b)) # &lt;class 'float'&gt; -- 浮点型 c = True print(type(c)) # &lt;class 'bool'&gt; -- 布尔型 d = '12345' print(type(d)) # &lt;class 'str'&gt; -- 字符串 e = [10, 20, 30] print(type(e)) # &lt;class 'list'&gt; -- 列表 f = (10, 20, 30) print(type(f)) # &lt;class 'tuple'&gt; -- 元组 h = {10, 20, 30} print(type(h)) # &lt;class 'set'&gt; -- 集合 g = {'name': 'TOM', 'age': 20} print(type(g)) # &lt;class 'dict'&gt; -- 字典 int、float、bool、str、list、tuple、set、dict
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03e9143bf11e9292ecbc340443b92bc6/" rel="bookmark">
			一、python基础入门1-输入与输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、输入 # 输入--input # num = input('请输入一个数字：') # # 输入的结果输出以后一定是一个字符串 # print(num, type(num)) 二、输出 print能够将程序中任意数据打印出来，将数据规范的打印出来，供程序员辨别数据。
转义字符：
\n：换行。\t：制表符，一个tab键（4个空格）的距离。分隔字符串 — sep=’ '（默认，可以不写）sep、end必须放到print的末尾 在Python中，print()， 默认自带end="\n"这个换行结束符，所以导致每两个print直接会换行展示，用户可以按需求更改结束符。
print(10, 10 + 100, 10 &lt; 30, '1234') ''' 运行结果： 10 110 True 1234 ''' print(10, 10 + 100, 10 &lt; 30, '1234', end='\t') print(123) ''' 运行结果： 10 110 True 1234	123 ''' print(10, 10 + 100, 10 &lt; 30, '1234', sep='❤️') ''' 运行结果： 10❤️110❤️True❤️1234 ''' 三、格式化输出 format()方法：配合{}向文本中传递任意参数。注意：format中数据的个数需要和{}的数量保持一致。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03e9143bf11e9292ecbc340443b92bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30258e5c6f1a09e25ef6b7aa2be344a8/" rel="bookmark">
			二、python流程控制2-循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、while的语法 while 条件: 条件成立重复执行的代码1 条件成立重复执行的代码2 ...... 适用于次数不确定的程序，也可用于次数确定的程序。
1.1 案例一：计算1-100累加和 i = 1 result = 0 while i &lt;= 100: result += i i += 1 # 输出5050 print(result) 注意：为了验证程序的准确性，可以先改小数值，验证结果正确后，再改成1-100做累加。
1.2 案例二：猜数字 from random import randint num=randint(1,100) # print(num) while True: n=int(input('你猜测的数字(1~100)：')) if num==n: print('你猜对了') break elif num &lt; n: print('你的数字猜大了') else: print('你的数字猜小了') 二、break和continue break和continue是循环中满足一定条件退出循环的两种不同方式。break：结束所在循环，continue：结束其所在循环的本次循环。
2.1 情况一：break i = 1 while i &lt;= 5: if i == 4: print(f'吃饱了不吃了') break print(f'吃了第{i}个苹果') i += 1 执行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30258e5c6f1a09e25ef6b7aa2be344a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02739d41b890762439917fb9c1f9cbb1/" rel="bookmark">
			二、python流程控制1-条件控制语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. if 语法 1.1 语法 if 条件: 条件成立执行的代码1 条件成立执行的代码2 ...... 2.2 快速体验 username = input('请输入用户名：') password = input('请输入密码：') if username == 'admin' and password == '123456': print('登录成功') else: print('登录失败') #缩进：一般把缩进看做四个空格，一个程序的缩进必须保持一致。 二. 实例：上网 需求分析：如果用户年龄大于等于18岁，即成年，输出"已经成年，可以上网"。
2.1 简单版 age = 20 if age &gt;= 18: print('已经成年，可以上网') print('系统关闭') 2.2 进阶版 # input接受用户输入的数据是字符串类型，条件是age和整型18做判断，所以这里要int转换数据类型 age = int(input('请输入您的年龄：')) if age &gt;= 18: print(f'您的年龄是{age},已经成年，可以上网') print('系统关闭') 三. if…else… 作用：条件成立执行if下方的代码; 条件不成立执行else下方的代码。
3.1 语法 if 条件: 条件成立执行的代码1 条件成立执行的代码2 ...... else: 条件不成立执行的代码1 条件不成立执行的代码2 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02739d41b890762439917fb9c1f9cbb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f7c3ca19b87167a5b9813acff6bc71/" rel="bookmark">
			一、python基础入门4-简单数据类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 数据类型 1.1 布尔类型 所有的数据都可以转换为布尔值（bool）0转换为False，非0全是True。所有的空值对象全是False。 print(bool(0), bool(1), bool(-1)) print(bool(''), bool([]), bool({}), bool(None)) ''' 运行结果： False True True False False False False ''' 1.2 整型 布尔值可以转换成整型：False --&gt; 0,True --&gt; 1
浮点型转整型：向小取整
去掉引号是一个整数的字符串可以转整型
print(int(bool(100))) print(int(0.1)) # --&gt; 0 print(int(.1)) # --&gt; 0 print(int(1.)) # --&gt; 1 print(int('1.0')) #报错：invalid literal for int() with base 10: '1.0' print(int('1')) #不报错 1.3 浮点型 整型转浮点型。
去掉引号是数字的字符串可以转成浮点型。
布尔值可以转浮点型—&gt;False:0.0; True:1.0
print(float(1)) print(float('.9')) print(float('9.')) print(float('9.9')) ''' 运行结果： 1.0 0.9 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69f7c3ca19b87167a5b9813acff6bc71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb4ca96382f4f2c54fc2ecdd486f0df0/" rel="bookmark">
			大数据Hadoop(一)：集群搭建--Hadoop3.3.1、CentOS8、HDFS集群、YARN集群最新保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、安装CentOS8虚拟机二、克隆虚拟机三、修改VMnet8的ip四、修改虚拟机ip（三台机器都做）五、设置主机名 （三台机器都做）六、使用Xshell连接虚拟机七、ssh免密登录（node1做即可）八、时间同步（三台机器都做）九、上传并解压安装包（node1做即可）十、安装JDK（node1做即可）十一、编辑Hadoop配置文件（node1做即可）十二、分发配置十三、启动Hadoop集群十四、访问Hadoop Web UI页面 前言：本教程仅演示快速搭建Hdoop集群，并不对相关知识点与背景进行详细说明，电脑建议16G及以上内存，需要同时开启3台虚拟机，8G内存有点不够使用。
所需工具（提取码：0620 ）：VMware Workstation 16、Centos stream 8、Xshell、nodepad++（尽管运营者很恶心）、jdk8、hadoop3.3.1。
一、安装CentOS8虚拟机 安装好VMware Workstation 16 后运行并新建虚拟机。选择典型，下一步。选择“安装程序光盘镜像文件”，选择CentOS8镜像文件（iso）所在路径，下一步。设置虚拟机名称为node1，自己设置安装路径，下一步。最大磁盘大小60G，选择虚拟磁盘拆分成多个文件，下一步。自定义硬件，内存设置2G，点击完成。选择第一个，Enter键确认，此时我们在虚拟机内，鼠标无法使用，ctrl+alt返回你的计算机。
设置root密码123456，可以理解为管理员密码，点击2次完成。点击安装目的地，直接点击完成。
开始安装，过程有点漫长。接受许可信息，安装完成后设置自己的用户名和密码。
二、克隆虚拟机 关闭虚拟机，鼠标移动到node1标签，右键&gt;管理&gt;克隆
选择“克隆虚拟机的当前状态”，“创建完整克隆”。克隆两台，分别命名node2、node3。
现在已有三台虚拟机
三、修改VMnet8的ip 确认好vmnet8生成的网关地址。在VMware Workstation顶部菜单栏点击编辑&gt;虚拟网络编辑器&gt;VMnet8&gt;NAT设置。获取网关ip：192.168.179.2，每个人都不同，记住自己的。点击DHCP设置，获取起始ip与结束ip。
2. 在windows任务栏搜索“网络连接”并打开，选择VMnet8，右击&gt;属性&gt;双击Internet协议版本4（tcp/ipv4），IP和DNS都改为手动，默认网关就填上面显示的网关，ip地址前三段与默认网关保持一致，后一段设置为1。DNS填写如图（为了方便）
四、修改虚拟机ip（三台机器都做） IP规划，IP前三段与你自己的网关前三段相同，最后一段分别为10、20、30，后面所有的IP操作都要根据你自己的实际情况设置。
主机名IPnode1192.168.179.10node2192.168.179.20node3192.168.179.30 方式一：命令修改（不太建议）
以虚拟机node1为例，启动虚拟机，点击左上角活动，然后选择终端，在终端输以下命令，获取mac地址，按右键可以在终端粘贴命令。
ifconfig 输入下列命令，并输入密码,ens160是网卡名称，有的是ens33有的是eth0
sudo vim /etc/sysconfig/network-scripts/ifcfg-ens160 按i键进入编辑模式，修改或增加以下内容。此时只能用方向键移动光标。
修改 BOOTPROTO=none ONBOOT=yes 增加 HWADDR=你的mac地址 IPADDR=你想设置的IP地址 PREFIX=24 GATEWAY=你的网关 DNS1=114.114.114.114 DNS2=8.8.8.8 如图所示
修改完毕后先按Esc键，再按英文冒号，输入wq!（英文叹号），强制写入并保存，然后输入reboot重启。
对另外两台虚拟机进行相同操作。
测试是否设置成功：
输入ifconfig查看IP是否和自己设置的一样。
查看火狐浏览器是否能正常上网或终端输入sudo ping www.baidu.com,ctrl+c停止ping，丢包率为0%.
方式二：图形化界面修改
点击活动，进入设置
找到网络，选择有线
点击身份，下拉菜单选择MAC地址
点击IPV4，选择手动，地址填：192.168.179.10，子网掩码：255.255.255.0，网关：192.168.179.2，DNS填114.114.114.114,8.8.8.8。地址、网关根据你自己的进行设置，最后点击应用。
测试是否成功方法与上述相同
五、设置主机名 （三台机器都做） 主机名设置
以node1为例，查看当前主机名，在终端输入hostname
终端输入sudo vim /etc/hostname，按i键进行编辑，删除原内容，添加node1，按Esc键，再按英文冒号，输入wq!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb4ca96382f4f2c54fc2ecdd486f0df0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/310e9265e03646a8203a03d1fc9abfae/" rel="bookmark">
			贝叶斯网络详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 贝叶斯网络概述 有时我们需要计算一个不确定原因的概率给出一些观察到的证据，在这些情况下可以使用贝叶斯方法。
贝叶斯网络（bayesian network）
是一种概率图形模型，它在图形模型中显式捕获已知的有向边的条件依赖性，它通过有向无环图(DAG)表示一组变量及其条件依赖关系。
贝叶斯网络非常适合用于获取已发生的事件并预测几种可能的已知原因中的任意一种。例如，贝叶斯网络可以表示疾病和症状之间的概率关系。给定症状，该网络可用于计算各种疾病存在的概率。
高效的算法可以在贝叶斯网络中进行推理和学习。
对变量序列（例如 语音信号或蛋白质序列）进行建模的贝叶斯网络称为动态贝叶斯网络，可以表示和解决不确定性下的决策问题的贝叶斯网络的推广称为影响图。
与手动构建不同，自动学习不需要底层领域的专家知识。贝叶斯网络可以直接从数据库中使用通常内置在适当软件中的基于经验的算法自动学习。但缺点是自动化建设对数据的要求较高。
0x02 贝叶斯网络模型 在0x01中已经提到，贝叶斯网络是有向无环图(DAG)，其节点代表贝叶斯意义上的变量。
变量有很多种类型，有可观察量、潜在变量、未知参数或假设。用边表示条件依赖；未连接的节点表示有条件地相互独立的变量。 每个节点都与一个概率函数相关联，该概率函数将节点父变量的一组特定值作为输入，并给出由节点表示的变量的概率。
最简单的图，可以这么表示：
维基给了一个例子 造成小草变湿有两种方法：洒水车&amp;下雨。
下雨会影响洒水车的出行，小草变湿的结果有两个：T（代表真）和 F（代表假）。
联合概率函数的概率的链式法则：
G =“小草变湿（真/假）”S =“洒水器打开（真/假）”R =“下雨（真/假）” 该模型可以回答有关在存在效应（所谓的逆概率）的情况下是否存在原因的问题。
通过使用条件概率公式并对所有的变量求和：
使用联合概率函数的展开Pr(G,S,R)}以及图中所述的条件概率表 (CPT)中的条件概率，可以评估分子和分母中的每个项。
然后数值结果（由相关变量值下标）是
推断未观察到的变量 贝叶斯网络经常用来回答关于它们的概率查询，当有其他变量时，网络可用于更新变量子集状态的知识。这种计算后验分布的过程称为概率推理。当选择变量子集的值时，可以最小化某些期望损失函数，例如决策错误的概率。所以贝叶斯网络可以被认为是一种自动应用贝叶斯定理的机制复杂的问题。
参数学习 指定以 X 的父节点为条件的 X 的概率分布，X 以父代为条件的分布可以有任何形式。通常使用离散或高斯分布，因为这简化了计算。有时只知道分配的限制；然后可以使用最大熵原理来确定单个分布，即在给定约束条件下具有最大熵的分布。
结构学习 贝叶斯网络的模型有分为几种形态：
直连：表示有向图的方向成直线状，并指向同一方向。
表示为：G -&gt; S -&gt; R
汇连：两个独立的节点指向同一个节点。
表示为：G -&gt; S &lt;- R
分连：一个节点分别指向两个不同的节点。
表示为：G &lt;- S -&gt; R
一种特别快速的精确 BN 学习方法是将问题转换为优化问题，并使用整数规划求解。在求解过程中以切割平面的形式将非循环约束添加到整数程序 (IP) 中，这种方法可以处理多达 100 个变量的问题。
软件 对于处理图形模型的有用软件，有几种选择。最常见的软件包有Genie、Hugin、BUGS等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fdcfd334600fcc6da3c033923b3439a/" rel="bookmark">
			el-input实现尾部加字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;el-input v-model="item.num" class="th_inp" size="mini" placeholder="请填写的数量"&gt; &lt;span slot="suffix"&gt;元&lt;/span&gt; &lt;/el-input&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5494556d3b5ad90ef2a732951d4d3a1/" rel="bookmark">
			c# winform panel自定义图片和文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码下载地址:https://download.csdn.net/download/wojiuguowei/85761936
参考地址:https://stackoverflow.com/questions/10386783/enter-event-not-firing-in-panel-inside-a-usercontrol?answertab=trending#tab-top
public class PanelEx : PictureBox { public PanelEx() { this.BackColor = Color.Lavender; pic.BackColor = Color.Blue; this.GotFocus += new EventHandler(txt_username_GotFocus); this.LostFocus += new EventHandler(txt_username_LostFocus); this.Enter += new System.EventHandler(this.CustomEnter); this.Leave += new System.EventHandler(this.CustomLeave); this.MouseClick += new System.Windows.Forms.MouseEventHandler(this.CustomMouseClick); } private void CustomMouseClick(object sender, MouseEventArgs e) { this.Focus(); MessageBox.Show(this.Name + "GetFocus"); this.BackColor = Color.Blue; } private void CustomLeave(object sender, EventArgs e) { MessageBox.Show(this.Name + "LostFocus"); this.BackColor = Color.Lavender; } private void CustomEnter(object sender, EventArgs e) { } PictureBox pic = new PictureBox(); //2、手写像事件方法一样的方法 private void txt_username_GotFocus(object sender, EventArgs e) { //获得焦点要执行的代码 } private void txt_username_LostFocus(object sender, EventArgs e) { //失去焦点要执行的代码 } private static System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5494556d3b5ad90ef2a732951d4d3a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7785f75cb3c415bddb9c72892c650403/" rel="bookmark">
			Mac 电脑能联网但打不开网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac 电脑能联网但打不开网页 现象描述现象分析解决方法网络高级配置DNS 现象描述 今天电脑出现一个奇怪的现象，可以连接上网络，钉钉和微信可以正常收发信息，但是浏览器却怎么也访问不了网页，断网重新连接依然没作用，这是怎么回事儿呢？
现象分析 出现浏览器无法访问，首先肯定是检查自己的网络是否连接啦，像我这种情况，很明显网络是OK的，网络没有问题，网页打不开，这时候就考虑是不是DNS解析问题，很有可能是当前DNS解析服务器无法正常解析网页，那浏览器就不能正常打开网页啦，那接下来就去修改下网络DNS配置；
解决方法 网络 打开系统偏好设置-网络
点击桌面底部Dock上的系统偏好设置或直接点击左上角Apple图标下拉菜单 找到系统偏好设置，找到网络
高级 点击右下角“高级”按钮
配置DNS 切换到DNS项，配置DNS项，打开DNS，可以看到默认的DNS，可以点击“-”
号按钮删除这些个DNS地址，然后点击“+”加号按钮，输入114DNS的IP地址：114.114.114.114，然后点击“好”按钮
最后点击底部的“应用”按钮进行保存，然后关闭偏好设置，刚才的设置就会立即生效，这时候我们再打开网页试一试，发现网页可以正常打开，问题解决；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ae5c3db0520a723e92591459b836459/" rel="bookmark">
			ANDROID H5交互WEBVIEW实现LOCALSTORAGE数据存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.freesion.com/article/91711011809/
写的清晰管用
实现比较简单,但是第一次用可能会遇到一些坑
首先得有WEBVIEW控件：
有人问我是不是需要写布局文件，不写行不行，现在我就告诉你们，不写没问题，需要写就写不写直接创建New一个也行。 下面我就介绍一个，我new一个Webview实现localStorage。
WebView mywebView = new WebView(this);
mywebView.getSettings().setJavaScriptEnabled(true);
mywebView.getSettings().setDomStorageEnabled(true);// 打开本地缓存提供JS调用,至关重要
mywebView.getSettings().setAppCacheMaxSize(1024 * 1024 * 8);// 实现8倍缓存
mywebView.getSettings().setAllowFileAccess(true);
mywebView.getSettings().setAppCacheEnabled(true);
String appCachePath = getApplication().getCacheDir().getAbsolutePath();
mywebView.getSettings().setAppCachePath(appCachePath);
mywebView.getSettings().setDatabaseEnabled(true);
上面这些settings是实现localStorage需要的存储条件。
其次就是如何实现LOCALSTORAGE本地存储了：
其实我在网上搜索了很多比如这样:
String userAgent = “shixinzhang”;
String js = “window.localStorage.setItem(‘userAgent’,'” + userAgent + “');”;
String jsUrl = “javascript:(function({
var localStorage = window.localStorage;
localStorage.setItem(‘userAgent’,'” + userAgent + “')
})()”;
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
mWebView.evaluateJavascript(js, null);
} else {
mWebView.loadUrl(jsUrl);
mWebView.reload();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ae5c3db0520a723e92591459b836459/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d94c6febac61f5643007107892b5f5c/" rel="bookmark">
			Python字典(dict)的操作方法汇总(约18种操作方法),并附示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：博主(昊虹图像算法)写这篇博文时，用的Python的版本号为3.9.10。
字典(dict)的格式如下：
dict1 = {key1 : value1, key2 : value2, key3 : value3 } 从上面的格式我们可以看出：
字典的每个键值 key=&gt;value 对用冒号分割，每个对之间用逗号分割，整个字典包括在花括号 {} 中。
另外字典要求键必须是唯一的，但值则不必。
目录 01-字典的创建01-附1-利用方法fromkeys()配合元组快速生成多键值字典01-附2-利用内置函数dict()以多种方式快速生成多键值字典 02-字典值的访问03-更新字典某个键的值、新增键值04-用del语句删除字典中的键值05-用del语句删除整个字典06-用方法clear()清空字典07-用函数len()统计字典键值对的个数06-用函数str()将字典字符串化07-使用方法copy()实现字典的深拷贝08-使用“=”实现字典的浅拷贝09-使用“in”判断某键是否在字典里10-使用方法items()获得字典键和值的视图对象11-使用方法keys() 获得字典键的视图对象12-使用方法values()获得字典键的值的视图对象13-1-使用方法get()返回某键的值13-2-使用方法setdefault()返回某键的值(如果键不存在,则自动创建)14-使用方法update()将一个字典的键值添加到另一个字典中15-使用方法pop()删除某对键值,并返回键的值16-使用方法popitem() 删除最后插入的键值,并返回键及其值17-键在使用时需要注意的两点 01-字典的创建 # 创建有内容的字典 dict1 = {'name': 'suwenhao', 'likes': 'reading', 123: 456} # 方法一创建空字典 dict2 = {} # 方法二创建空字典 dict3 = dict() 运行结果如下：
01-附1-利用方法fromkeys()配合元组快速生成多键值字典 语法如下：
dict.fromkeys(keys, value) keys —必需。指定新字典键的可迭代对象。
value—可选。所有键的值。默认值是 None。
第一个示例代码如下：
x = ('key1', 'key2', 'key3') y = 0 dict1 = dict.fromkeys(x, y) 运行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d94c6febac61f5643007107892b5f5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28edb7b30a9cc78cf69a395edbd18bee/" rel="bookmark">
			vue3引入element-plus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.全局引入 npm install element-plus 1.1.main.js代码 import { createApp } from "vue"; import App from "./App.vue"; import router from "./router"; import store from "./store"; import ElementPlus from "element-plus"; import "element-plus/dist/index.css"; createApp(App).use(store).use(ElementPlus).use(router).mount("#app"); 2. 按需引入 npm install -D unplugin-vue-components unplugin-auto-import 2.1. webpackge.config.js 代码 const AutoImport = require('unplugin-auto-import/webpack') const Components = require('unplugin-vue-components/webpack') const { ElementPlusResolver } = require('unplugin-vue-components/resolvers') module.exports = { plugins: [ AutoImport({ resolvers: [ElementPlusResolver()], }), Components({ resolvers: [ElementPlusResolver()], }), ], } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2e39635fada9c6e9836b57056d39742/" rel="bookmark">
			深度学习系列45：图像恢复综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从本期开始，会探索图像恢复领域的论文和代码。本次先阅读一下综述。
传统方法一个很大的假设是我们相信我们可以在缺失区域之外找到相似的patch，但是如果缺失区域之外没有任何类似的patch，就没有办法正确修复图像了。
1 经典GAN方法 1.1 context encode：U-net生成器 2016年出现的基准的GAN算法，生成器为一个U型网络，判别器为多层卷积网络。损失包括像素级别的重建损失(L2)和鉴别器产出的对抗损失。
1.2 MSNPS：添加纹理生成器 2016年升级版的context encode，其生成器包含两部分，增加了生成纹理的卷积网络：
上面的U型网络用于生成内容，损失函数包括L2损失和对抗损失。
下面的卷积网络用于生成纹理，并寻找缺失区域外最近的神经网络响应来计算损失。这里的做法类似风格转移，将完整部分的风格迁移到损失部分。
1.3 GLCIC：添加局部鉴别器 这里生成器使用了膨胀卷积用来增加感受野。
训练分为3步：
生成器L2损失，注意L2损失是在缺失区域内计算的。训练判别器生成器加上对抗损失，与判别器交替训练 图像后处理采用fast marching+泊松图像混合
1.4 PGGAN：添加矩阵鉴别器 GLCIC太依赖于预先定义好的缺失区域，而实际场景中的残缺经常是未知的，因此仍需改进。
典型GAN鉴别器的输出是0 ~ 1的单个值。这意味着鉴别器会看整个图像，判断这幅图像是真的还是假的，我们称之为GlobalGAN。而PatchGAN判别器的输出是一个矩阵，这个矩阵中的每个元素都在0到1之间。注意，每个元素代表输入图像中的一个局部区域。
两者结合，叫做PGGAN
结构和GLCIC很相似，其中生成模块改成了膨胀残差网络，此外将标准反卷积改成了插值卷积用以消除伪影。
1.5 shiftGAN：U-net生成器添加shift连接 添加引导损失：所有连接的两个层之间编码特征和解码特征的L2损失之和。
添加shift连接：通过移位操作，网络可以有效借用缺失部分外最近的邻居给出的信息，来完善生成部分的全局语义结构和局部纹理细节。简单来说，它就是提供合适的参照物来完善估计。
1.6 DeepFill：生成器添加注意力 作者提出了一个二阶段的由粗到细的修复网络：
第一阶段粗修复网络：使用空洞卷积+重建损失先补出一个模糊粗糙的结果；
第二阶段精修复网络：使用带语境注意力模块空洞卷积+重建损失+全局、局部GAN-GP对抗损失来进一步细化结果。
encode部分上路分支是包含语义注意力层（contextual attention layer）的encoder；下路是常规的encoder。两路encoder输出的特征图最后拼接在一起合成一个特征图，最后通过decoder生成修复结果。
1.7 DeepFill v2: mask由门控卷积生成 gated conv是本文的核心创新点，他就像一个软筛子一样，对输入有选择机制。（软性选择，就是乘以一个0-1之间的数，与之相对的是硬筛子，要么全通过，要么全拦下），它可以自动根据更新规则从数据里面学到soft mask的参数（就像过滤系数一样），如下式：
此外为了应对free-form的mask，使用了Markovian discriminiator，对尺寸小于原图的矩阵打分。对抗损失使用了Hinge loss。
1.8 PatialConv：处理freeMask 其核心思想是，如果感受野内不存在有效像素（即都被mask了），则不进行卷积操作；其他情况下，也只对有效像素做卷积。
此外，mask也不断更新：
1.9 CTSDG：鉴别器添加边缘检测 比较像MSNPS，生成器这边从图像、边缘分别生成，鉴别器这边也是从图像、边缘分两支进行判定。
1.10 EdgeConnect：添加边缘生成器和边缘判别器 这个项目的功能和deepfill v2比较像，使用轮廓作为先验来指导图像生成。
如上图，左半部分的G1和D1用来学习轮廓，右边半部分的G2和D2则用来生成最终的图像。
G1和G2都使用了空洞卷积+残差模块；D1和D2都使用PatchGAN，也就是将判别图片分成70x70进行判别，对判别结果取平均。
原先的图片修补任务需要对RGB值图片的缺失区域进行修补，如果采用范数距离计算重构损失 L r e c L_{rec} Lrec​的话，总得到模糊的图片（对可能的修补模式求平均的结果）；如果采用特征距离计算对抗损失 L a d v L_{adv} Ladv​的话，总得到人造痕迹太明显的图片（伪像）（从训练记忆里面找一个相似的结果并贴上去）。上下文编码器 Context Encoder 采用参数加权的方式结合使用两者，只是平衡了这两个缺点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2e39635fada9c6e9836b57056d39742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2efda54d3424d0afd52fca94290f194/" rel="bookmark">
			程序员地理系列知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：
新高考地理备考系列（一）中国地理记忆口诀、地理界线和综合地理界线
新高考地理备考系列（二）区域经纬线定位
新高考地理备考系列（三）突破量化计算18类瓶颈
新高考地理备考基础（四）等值线地图综合分析和判读
新高考地理备考系列（五）区域地理宏观把握法
新高考地理备考系列（六）地理高考题型分类归纳
新高考地理备考系列（七）高考地理690个知识点（上）
新高考地理备考系列（八）高考地理690个知识点（下）
新高考地理备考系列（九）区域地理经纬网空间定位考点总览
新高考地理备考系列（十）19个经典高考专题主观题答题要点
新高考地理备考系列（一）中国地理记忆口诀、地理界线和综合地理界线
一、中国地理记忆口诀
■ 我国省级行政区区域记忆口诀
京津沪渝直辖市
蒙宁新藏桂自治
一国两制台港澳
东北三省黑吉辽
冀晋鲁归华北
苏浙皖赣在华东
湘鄂豫归华中
华南还有粤闽琼
川滇黔渝藏西南
西北陕甘宁青新
晋豫皖和湘鄂赣
中部六省正崛起
中原大省河南省 大别山界鄂豫皖 太行山东冀鲁豫 陕甘宁边区延河唱---
■我国地理之最
面积最小的省是澳门　纬度最高的省是黑龙江　面积最大的省是新疆　跨经度最广的省是内蒙古 跨纬度最广的省海南省　人口最多的省河南　人口最少的省澳门---
■我国七大古都：
七大古都是北京，西安南京杭州城； 河南洛阳和开封，安阳殷墟史料重。
北京故宫天安门，颐和园及八达岭。 西安大小两雁塔，骊山华清池秦陵。
南京雨花台江桥，玄武湖和中山陵。 杭州西湖双十景，灵隐寺与飞来峰。
洛阳龙门石窟精，白马少林寺著名。 开封铁塔和龙亭，相国寺钟观音听。
■中国主要铁矿分布：
我国铁矿有八家，内蒙白云湖北大。 辽宁鞍山和本溪，河北迁安安徽马。 海南铁矿在石碌，四川一朵攀枝花。
■中国煤矿分布：
中国煤矿有十一，开滦峰峰省份冀。 辽宁煤矿是阜新，大阳西山在山西。
安徽淮北江苏徐，黑龙抓住鹤和鸡， 平顶山矿省份豫。
■中国有色金属矿分布：
德兴铜矿在江西，湖南锡矿山产锑。 贵州铜仁产汞矿，云南个旧出产锡。
甘肃金昌矿产镍，钨矿产地赣大余。 湖南水口山铅锌，广西平果出产铝。
内蒙白云泥土稀，山东招远有金币。
■货运评价和选择三原则：
贵重急需量不大，最佳选择是航空。易死变质鲜活货，短程可用公路送，远程而且数量大，铁路上有专车用。大宗笨重远距离，水运铁路二者中。
■中国十大旅游景点：
北京故宫八达岭，避暑山庄河北行。 陕西省内秦皇陵，长江三峡鄂渝境。
安徽黄山桂林水，浙江西湖苏园林， 台湾岛上日月明。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2efda54d3424d0afd52fca94290f194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a6c1de577af32bca63d025d632cf05f/" rel="bookmark">
			vue3中的TS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.当导入导出类型模块的时候，需要加一个type,并且在vite框架下，不允许使用枚举类型 &lt;script lang="ts" setup&gt; import type{ Ref } from 'vue' import { ref } from 'vue' const count = ref(1) const c:Ref&lt;number&gt; = count &lt;/script&gt; &lt;template&gt; &lt;div&gt;{{ c.toFixed(2) }}&lt;/div&gt; &lt;/template&gt; 2.defineComponent让属性具有ts的特性 defineComponent可以给组件的setup方法准确的参数类型定义.
defineComponent 可以接受显式的自定义 props 接口或从属性验证对象中自动推断
defineComponent 可以正确适配无 props、数组 props 等形式
引入 defineComponent() 以正确推断 setup() 组件的参数类型
import { defineComponent } from "vue" export default defineComponent({ props: { message: { type: String, required: true } }, setup(props) { let x: String = props.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a6c1de577af32bca63d025d632cf05f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f69669a230c21eb3953c1717caa474bf/" rel="bookmark">
			【强烈推荐】基于stm32的OLED各种显示实现（含动态图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：OLED模块作为人们日常生活中常见屏幕类型之一，使用的受众面非常广阔。例如：显示各个传感器数值，显示精美界面，多级化菜单系统等等都不离不开他的身影。可以说学会OLED模块是嵌入式开发必须掌握的驱动开发技能之一，同时，也是嵌入式开发调试配置的重要手段与技巧！（文章结尾会有代码开源）
实验硬件：STM32F103C8T6；0.96寸OLED
一、OLED简介 OLED，即有机发光二极管（Organic Light-Emitting Diode），又称为有机电激光显示（Organic Electroluminesence Display， OELD）。OLED 由于同时具备自发光，不需背光源、对比度高、厚度薄、视角广、反应速度快、可用于挠曲性面板、使用温度范围广、构造及制程较简单等优异之特性，被认为是下一代的平面显示器新兴应用技术。
LCD 都需要背光，而 OLED 不需要，因为它是自发光的。这样同样的显示，OLED 效果要来得好一些。以目前的技术，OLED 的尺寸还难以大型化，但是分辨率确可以做到很高。市场上常见OLED模块有以下特点：
(1)模块有单色和双色两种可选，单色为纯蓝色，而双色则为黄蓝双色。
(2)尺寸小，显示尺寸为 0.96 寸，而模块的尺寸仅为 27mm*26mm 大小。
(3)高分辨率，该模块的分辨率为 128*64。 (4)多种接口方式，该模块提供了总共 5 种接口包括：6800、8080 两种并行接口方式、3线或 4 线的穿行 SPI 接口方式，、IIC 接口方式（只需要 2 根线就可以控制 OLED 了！）。
(5)不需要高压，直接接 3.3V 就可以工作了。
特别注意，市面上有部分的OLED屏幕不可以直接接5.0v电压，否则可能烧坏！
总结：目前市面上常用的0.96寸OLED屏幕通讯方式主要有SPI和I2C两种！SPI为4线制较多，而I2C为2线制。2种通讯协议较为浅显的区别：总所周知，SPI的通讯速度明显快于I2C的通讯速度，所以通常使用SPI通讯协议的OLED屏幕可以实现更高的帧数显示，画面更为流畅丝滑。
当然，OLED屏幕显示的帧数高低不仅取决于通讯协议的不同，DMA （直接存储器访问）的使用也可以大幅提升OLED显示帧数。这一点笔者会在之后一篇博客文章专门介绍，有兴趣的读者可以关注一下！
二、I2C通讯 本次实验所采用的0.96寸OLED屏幕为I2C通讯方式，故在此稍微给读者介绍一下I2C通讯原理。
IIC(Inter－Integrated Circuit)总线是一种由 PHILIPS 公司开发的两线式串行总线，用于连接微控制器及其外围设备。它是由数据线 SDA 和时钟 SCL 构成的串行总线，可发送和接收数据。在 CPU 与被控 IC 之间、IC 与 IC 之间进行双向传送，高速 IIC 总线一般可达 400kbps 以上。
I2C 总线在传送数据过程中共有三种类型信号， 它们分别是：开始信号、结束信号和应答信号。
开始信号：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f69669a230c21eb3953c1717caa474bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/def86c0485cac9adf9b179f6acc0aecc/" rel="bookmark">
			Android api level对照表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常要查api对应的level，特此暂记，待有更新，再增补
Platform VersionAPI LevelVERSION_CODENotesAndroid 1333TIRAMISU平台亮点Android 1232S_V2平台亮点Android 1231S平台亮点Android 1130R平台亮点Android 1029Q平台亮点Android 9.028P平台亮点Android 8.127O_MR1平台亮点Android 8.026O平台亮点Android 7.1.1 7.125N_MR1平台亮点Android 7.024N平台亮点Android 6.023M平台亮点Android 5.122LOLLIPOP_MR1平台亮点Android 5.021LOLLIPOPAndroid 4.4W20KITKAT_WATCH仅限KitKat for WearablesAndroid 4.419KITKAT平台亮点Android 4.318JELLY_BEAN_MR2平台亮点Android 4.2, 4.2.217JELLY_BEAN_MR1平台亮点Android 4.1, 4.1.116JELLY_BEAN平台亮点Android 4.0.3, 4.0.415ICE_CREAM_SANDWICH_MR1平台亮点Android 4.0, 4.0.1, 4.0.214ICE_CREAM_SANDWICHAndroid 3.213HONEYCOMB_MR2Android 3.1.x12HONEYCOMB_MR1平台亮点Android 3.0.x11HONEYCOMB平台亮点Android 2.3.4Android 2.3.310GINGERBREAD_MR1平台亮点Android 2.3.2Android 2.3.1Android 2.39GINGERBREADAndroid 2.2.x8FROYO平台亮点Android 2.1.x7ECLAIR_MR1平台亮点Android 2.0.16ECLAIR_0_1Android 2.05ECLAIRAndroid 1.64DONUT平台亮点Android 1.53CUPCAKE平台亮点Android 1.12BASE_1_1Android 1.01BASE 参见：https://developer.android.com/guide/topics/manifest/uses-sdk-element.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4934663496f8f4610e3ac9a2a4125f7/" rel="bookmark">
			Qt(c&#43;&#43;)入门知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 信号槽机制.pro文件按钮（QPushButton）Qt窗口坐标系LambdaQMainWindow菜单栏:工具栏状态栏铆接部件(浮动窗口)核心部件(中心部件)资源文件对话框布局管理widgetQLabelQLineEdit自定义控件消息机制和事件event()事件过滤器文件系统 信号槽机制 信号槽机制是Qt框架的特色, 可以简单描述为，一个对象触发了一个信号，如果某个对象 对这个 信号感兴趣，那么就可以进行连接，当这个对象接收到这个信号后，可以做相应的处理，通常这种处理是交给槽函数来实现的。 // 信号槽的使用 // connect(sender,signal,receiver,slot) // sender 信号发送者 signal 要发送的信号 receiver 信号接收者 slot 槽函数 class Teacher{ // 自定义信号 signal: // 注意 信号 只声明 不实现 void hungry(); }; class Student{ slots: // 槽函数 void treat(); }; // 槽函数实现 void Student::treat(){ qDebug() &lt;&lt; "该吃饭了！"; } // 触发信号方法 void MyWidget::classIsOver(){ // 发送信号 emit teacher -&gt;hungry(); } teacher = new Teacher(this); // this 添加children 表 方便回收 student = new Student(this); // 信号槽连接 connect(teacher,&amp;Teacher::hungry,student,&amp;Student::treat); /* 注意: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4934663496f8f4610e3ac9a2a4125f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eba8d5abefc2337a3e1d55847a77ba8/" rel="bookmark">
			业内盆友来稿：Win10下通过PLSQL Developer连接Oracle19C，中文别名乱码怎么破？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写在开篇 近期，笔者对所使用的win10操作系统进行了重装，在通过PLSQL Developer工具连接Oracle数据库时，发现中文的别名居然出现乱码，也就是出现：”???“，如下图：
经分析，原因无非就两个：
本机没有配置数据库字符集环境变量客户端与数据库字符集不一致 解决过程 确认数据库的字符集 查看Oracle当前字符集
SQL&gt; select userenv('language') from dual; USERENV('LANGUAGE') ---------------------------------------------------- AMERICAN_AMERICA.UTF8 也可查看更详细的
SQL&gt; select * from nls_database_parameters where PARAMETER like '%CHARACTERSET%'; PARAMETER VALUE -------------------------------------------------------------------------------- ----- NLS_NCHAR_CHARACTERSET UTF8 NLS_CHARACTERSET UTF8 从上面的结果看到，字符集均为UTF8
在PLSQL Developer工具所在的机器环境变量中添加用户变量（笔者的是win10） NLS_LANG=AMERICAN_AMERICA.UTF8 如下图
关闭PLSQL Developer工具，再重新打开 中文别名已经正常显示，如下图： 写在最后 本次分享的内容很简单、内容也很短，望能帮助到有需要的朋友。
重要声明：因本篇内容字数未大于300字，由于公众号本身的限制不能声明原创。但笔者已买断其文章版权，该文章版权归属TtrOpsStack公众号所有。如转载此文章，请注明此原文的链接，否则…我也不能把你咋地。哈哈！
本文转载于：https://mp.weixin.qq.com/s/97FgSD6qmZSJPYkXSqFqzQ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75e4103a56db7d3dff1144e55053d992/" rel="bookmark">
			计算机图形编程中的这几本经典书你读过吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
计算机图形编程书
1、OpenGL超级宝典（第7版）
2、计算机图形学入门：3D渲染指南
3、计算机图形学编程 使用OpenGL和C+
4、OpenCV 4快速入门
5、Vulkan 应用开发指南
图形编程是计算机科学中最具挑战性的主题之一，并因此而闻名。当今，图形编程是基于着色器的——也就是说，有些程序是用诸如C++或Java等标准编程语言编写的，并运行在CPU上;而另一些是用专用的着色器语言编写的，并直接运行在显卡(GPU)上，着色器编程的学习由线很陡峭，以致哪怕是绘制简单的东西，也需要一系列错综复杂的步骤，把图形数据从一个“管线”中传递下去才能完成。现代显卡能够并行处理数据，即使是绘制简单的形状，图形程序员也必须理解GPU的并行架构。
虽然这并不简单，但回报是超强的渲染能力。电子游戏中涌现出来的令人惊艳的虚拟现实和好莱坞电影中越来越逼直的特效，很大程度上是由着色器编程的进步带来的。
计算机图形编程书 1、OpenGL超级宝典（第7版） 作者： 格雷厄姆·塞勒斯（Graham Sellers））
译者： 颜松柏 ,薛陶 ,张林苹
OpenGL编程指南，图形编程和3D图形，3d建模教程书建模书籍，介绍了OpenGL4.5的基础知识，并基于实例讲解了OpenGL4.5的各项功能。
本书是OpenGL及3D图形编程的入门指南，涵盖了使用OpenGL进行编程所需要的主要知识。
本书内容分3部分。第一部分介绍OpenGL绘图的基础知识，涉及管线、数学知识、数据、着色器和程序等；第二部分着重介绍OpenGL的一些功能，涉及顶点处理与绘图命令、基元处理片段处理与帧缓冲、计算着色器、数据管理、管线监控等；第三部分介绍一些实战技巧，涉及渲染技巧、高性能的OpenGL、调试和稳定性等。
本书适合希望系统学习OpenGL的读者阅读，经验丰富的OpenGL程序员也能从中获益。本书既可以作为学习OpenGL的教材，也可以作为随时查阅的参考手册。
2、计算机图形学入门：3D渲染指南 ​
作者： [瑞士]加布里埃尔·甘贝塔（Gabriel Gambetta）
译者： 贾凡
计算机图形学编程入门零基础自学，3d建模教程书，动画影视特效游戏开发，简单明了的计算机图形学入门指南，专注于3D渲染，提供示例代码，轻松编写渲染器！
（1）简单明了的计算机图形学入门指南。
（2）只需具备基本编程知识和高中数学知识。
（3）专注于3D 渲染。本书将带领读者构建两个完整的、功能齐全的渲染器：光线追踪渲染器和光栅化渲染器。前者模拟在物体之间反弹时的光线，后者将3D 模型转换为2D 像素。
（4）全书给出众多的伪代码示例，使得读者可以轻松地用任何语言编写渲染器，还提供了可下载的实时JavaScript 演示代码，方便读者进一步探索。
本书着重介绍光线追踪渲染器和光栅化渲染器这两大主流渲染器的基本实现过程，以渲染器的需求背景和实现原理作为出发点，辅以必要的简单数学推导过程，从光到阴影与反射，从直线到着色与纹理，逐渐引导出实现渲染器的伪代码，力求使没有丰富编程经验和深厚数学功底的读者也能够完全读懂。
3、计算机图形学编程 使用OpenGL和C+ ​
作者： [美]V.斯科特·戈登（V. Scott Gordon） ,约翰·克莱维吉（John Clevenger）
译者： 魏广程 ,沈瞳
计算机图形学编程动手实践指南，使用OpenGL和C++实现图形学编程，美国高校计算机图形编程教材。
本书为读者提供丰富的学习素材，包括书中使用的所有源代码、模型、纹理、天空盒以及法线贴图，既适合作为高等院校计算机相关专业的计算机图形编程课程的教材或辅导书，也适合对计算机图形编程感兴趣的读者自学。
本书具有以下特色：
● 覆盖C++中的现代OpenGL 4.0+着色器编程；
● 使用可运行的代码示例讲解所有技术，提供完整的源代码以及详细的讲解。
● 详细讲解每个GLSL可编程管线阶段（顶点阶段、曲面细分阶段、几何阶段以及片段阶段）。
● 研究有关建模、光照、阴影（包括柔和阴影）、地形以及3D材质（例如木材和大理石）的实例。
● 介绍现代开发工具（如NVIDIA Nsight调试器），以及如何用其优化代码、提高性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75e4103a56db7d3dff1144e55053d992/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f9b82b74f8776f82826e0f5a129ca08/" rel="bookmark">
			Java子集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 78.子集
class Solution { public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();//存储所有的子集结果 res.add(new ArrayList&lt;&gt;());//将空集加入 for (int i = 0; i &lt; nums.length; i++) { int all = res.size();//获取当前已经加入的子集 for (int j = 0; j &lt; all; j++) {//遍历该子集, 给子集中的每个集合加上新的数 List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(res.get(j)); tmp.add(nums[i]);//给子集中的每个集合加上新的数 res.add(tmp);//将新的集合加进res } } return res; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/567bdd89c957ce34cf01e8f59d418341/" rel="bookmark">
			Jenkins权限控制与job编排
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 当要围绕jenkins的功能来具体实现一个小团队的ci&amp;cd系统时，需要从整体需求来设计这一套系统要实现的功能以及具体的实现形式。
首先考虑用户，系统给谁用，权限需不需要控制，权限如何隔离；
其次会涉及多少个环境，环境间如何隔离，不同环境间的信息如何同步；
综上，这里会介绍jenkins中两块内容，一是用户及权限的配置，另外一块与权限紧密联系的jenkins任务的组织方式，比如文件夹类型的任务。
二、用户系统 1. 进入jenkins系统，进入系统管理，找到“全局安全配置”项。 这里选择用户系统，jenkins支持ldap用户认证，可以跟既有的用户体系打通方便进行统一管理。
授权策略可基于插件支持多种授权模式，这里总体会介绍以下几种： 安全矩阵、项目矩阵授权、基于目录授权和基于角色授权。
用户系统和授权策略可以自由组合，根据实际需要选择比较适合的一种组合方式。
2.专有数据库 用户系统使用jenkins专有用户数据库的时候，不需要进行额外的设置。
3.ldad配置 如上图所示，（需提前配置好ldap服务器）根据设置好的ldap服务信息填入所需信息.
server ldap的服务地址
rootdn ldap的根域
manager DN ldap的管理员帐号
manager Password ldap的管理密码
再下面是ldap里属性与jenkins用户的字段对应关系；
displayname 对应jenkins里用户所显示的名字
mail 对应jenkins用户的邮箱地址
cn={0} 确定用户认证时里cn作为搜索及认证关键字，对应jenkins用户名.
以下配置完成后，可测试配置是否正确。成功后即可通过ldap的用户登录jenkins系统，但此时登录后的用户，拥有什么样的权限是由“授权策略”部分的配置决定的。
三、授权策略 1. 安全矩阵 参考上图， Add user 在安全矩阵中增加一个用户，然后根据所需在增加的用户对应的复选框内选择所需要的权限，从而实现对单个用户的权限控制。
注意这里的权限控制是对所有任务生效的，无法根据不同的任务分配不同的权限。
涉及到的权限说明：（其他类型的权限策略中所涉及到的权限与此类似）
分类
全部
凭据
NODE(slave节点)
任务
运行
视图
SCM
权限说明
administer(管理员)
View(查看凭据的权限)
Disconnect（断开连接的权限-下线）
Build（job的构建权限）
Delete（删除job的运行记录） Configure（配置视图的权限）
Tag(允许用户在代码库中给指定的构建创建新的标签)
Read (全部只读)
Update（更新权限）
Delete（删除从节点的权限）
Cancel（取消job的权限） Replay（执行构建后的流水线权限）
Create（允许用户创建视图）
ManageDomains（管理域权限）
Create（创建从节点的权限）
Configure（配置任务的权限）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/567bdd89c957ce34cf01e8f59d418341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/141fae8293d2ec0b5dc23c1e127ac220/" rel="bookmark">
			【ML】逻辑回归适用场景-原理-优缺点汇总：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所以文档都用来做笔记，便于翻阅复习，如有侵权，联系我哈，可删除~~
什么是逻辑回归： LR是linear regression还是logistics regression呐？
两者的区别：线性回归的预测是无界限的，则需要根据可能的分类设置阈值，来作为分类问题；而逻辑回归的值域被严格限制为 0 到 1，逻辑回归并不是回归而是分类，是一种定性的分析，线性回归用来预测数值，是定量的，不适合用在分类上。当我们想将线性回归应用到分类问题中该怎么办呢？比如二分类问题，将X对应的y分为类别0和类别1。我们知道，线性回归本身的输出是连续的，也就是说要将连续的值分为离散的0和1。答案很容易想到，找到一个联系函数，将X映射到y∈{0，1}。可能大家立马会想到单位阶跃函数（unit-step Function），单位阶跃函数的确直接明了，小于0为类别0，大于0为类别1，等于0则皆可。但是有一个原则性的问题，我们需要的联系函数，必须是一个单调可微的函数，也就是说必须是连续的。逻辑回归使用的联系函数是Sigmoid函数（S形函数）中的最佳代表，即对数几率函数（Logistic Function）。
逻辑回归的对数几率函数是关于X的线性函数。
举个例子：
预测明天的气温是多少度，属于回归问题。
预测明天是阴、晴还是雨，属于分类问题。
下面来看下logistics regression：“逻辑回归”这个名称的由来，通过线性回归拟合数据，而后使用逻辑函数来预测分类的结果。
也有另外一种解释：如何用连续的数值去预测离散的标签值呢？---&gt;从线性回归到逻辑回归原因
线性回归的输出是一个数值，而不是一个标签，显然不能直接解决二分类问题。那我如何改进我们的回归模型来预测标签呢？
一个最直观的办法就是设定一个阈值，比如0，如果我们预测的数值 y &gt; 0 ，那么属于标签A，反之属于标签B，采用这种方法的模型又叫做感知机（Perceptron）。
另一种方法，我们不去直接预测标签，而是去预测标签为A概率，我们知道概率是一个[0,1]区间的连续数值，那我们的输出的数值就是标签为A的概率。一般的如果标签为A的概率大于0.5，我们就认为它是A类，否则就是B类。这就是我们的这次的主角逻辑回归模型 (Logistics Regression)。
适用场景： 应用场景：
用于分类场景， 尤其是因变量是二分类（0/1，True/False，Yes/No）时我们应该使用逻辑回归。不要求自变量和因变量是线性关系 存在的问题：
防止过拟合和低拟合，应该让模型构建的变量是显著的。一个好的方法是使用逐步回归方法去进行逻辑回归。逻辑回归需要大样本量，因为最大似然估计在低样本量的情况下不如最小二乘法有效。独立的变量要求没有共线性。 原理： 模型： 附上线性回归的最小二乘推导，矩阵求导也还是有大学问滴：
损失函数： 用来衡量模型的输出与真实输出的差别，最大化输出概率。
优化方法： 与线性回归不同的是，逻辑回归由于其联系函数的选择，它的参数估计方法不再使用最小二乘法，而是极大似然法（Maximum Likelihood Method）。最小二乘法是最小化预测和实际之间的欧氏距离，极大似然法的思想也是如出一辙的，但是它是通过最大化预测属于实际的概率来最小化预测和实际之间的“距离”。
为什么可以用梯度下降法？
因为逻辑回归的损失函数L是一个连续的凸函数（conveniently convex）。这样的函数的特征是，它只会有一个全局最优的点，不存在局部最优。对于GD跟SGD最大的潜在问题就是它们可能会陷入局部最优。然而这个问题在逻辑回归里面就不存在了，因为它的损失函数的良好特性，导致它并不会有好几个局部最优。当我们的GD跟SGD收敛以后，我们得到的极值点一定就是全局最优的点，因此我们可以放心地用GD跟SGD来求解。
梯度下降，使用梯度G进行W的更新，随机梯度下降，不直接使用损失函数的梯度去更新，而是使用期望为G的替代函数T(W)来更新W。
梯度下降：核心思想就是先随便初始化一个W0，然后给定一个步长k，w0--&gt;wn，从而最后靠近到达取得最大值的点，即不断进行下面的迭代过程，直到达到指定次数，或者梯度等于0为止。
随机梯度下降：如果我们能够在每次更新过程中，加入一点点噪声扰动，可能会更加快速地逼近最优值。所以使用期望为G的替代函数T来更新W。随机抽出一个样本，代替整体样本，相当于获得了梯度的无偏估计值。
代码： 底层函数是怎么开发的呐？
1 初始化函数，初始化学习率、迭代的次数:__init__()
def __init__(self, learning_rate=.1, n_iterations=4000): self.learning_rate = learning_rate self.n_iterations = n_iterations 2.初始化参数，参数矩阵w里的大小范围在（-limit，limit）之间，矩阵大小为（n_features，1）。w加入b的值相当于把偏置值加进去.
def initialize_weights(self, n_features): # 初始化参数 # 参数范围[-1/sqrt(N), 1/sqrt(N)] limit = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/141fae8293d2ec0b5dc23c1e127ac220/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b30130526c81c41727d845d66c37c2/" rel="bookmark">
			onBackPress返回不生效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		onBackPress() { uni.reLaunch({ url: 路径 }) return true; }, 出现不生效是没有return true
再没有反应就用
onUnload(){}去做返回时需要处理事件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b524bb737ccd2bd93203fe90e904b34/" rel="bookmark">
			ros仿真学习笔记_3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rviz 控制小车运动 1 . 安装Arbotix
sudo apt-get install ros-noetic-arbotix 2 . 在config文件中添加机器人控制参数文件control.yaml
touch control.yaml 输入代码：
# 该文件是控制器配置,一个机器人模型可能有多个控制器，比如: 底盘、机械臂、夹持器(机械手).... # 因此，根 name 是 controller controllers: { # 单控制器设置 base_controller: { #类型: 差速控制器 type: diff_controller, #参考坐标 base_frame_id: base_footprint, #两个轮子之间的间距 base_width: 0.2, #控制频率 ticks_meter: 2000, #PID控制参数，使机器人车轮快速达到预期速度 # 比例，按照误差正比控制，但是会出现稳态误差 Kp: 12, # 微分，阻尼放置震荡 Kd: 12, # 积分，消除稳态误差 Ki: 0, Ko: 50, #加速限制 accel_limit: 1.0 } } 3 . 建立launch文件
touch carcontrol.launch 输入代码：
&lt;launch&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b524bb737ccd2bd93203fe90e904b34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed4e19a3075baf19c20ab74b120719e5/" rel="bookmark">
			驱动程序无法通过使用安全套接字层(SSL)加密与 SQL Server 建立安全连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		驱动程序无法通过使用安全套接字层(SSL)加密与 SQL Server 建立安全连接。错误:“The server selected protocol version TLS10 is not accepted by client preferences [TLS12]”
虽然现在大家基本上都用mysql数据库了，但是难免有时候会碰到要使用sqlserver的情况。
这时候如果你不是用微软的产品去连接，比如你用java开发，使用驱动包连接可能会碰到【驱动程序无法通过使用安全套接字层(SSL)加密与 SQL Server 建立安全连接。错误:“The server selected protocol version TLS10 is not accepted by client preferences [TLS12]”】这个错误.
低版本的驱动还可能是英文的报错【The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: “The server selected protocol version TLS10 is not accepted by client preferences [TLS12]”. ClientConnectionId:d5fd8d69-ae88-4055-9f6d-6e8515224ce2】。
这个问题其实最主要还得看后面那一句话【The server selected protocol version TLS10 is not accepted by client preferences [TLS12]】，意思是数据库服务端的协议版本是TLS10，而客户端协议版本是TLS12。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed4e19a3075baf19c20ab74b120719e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c533ffd8ede01f97d6ad2ae4b7fb0e66/" rel="bookmark">
			ros仿真学习笔记_2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xacro优化代码： 新建功能包：
catkin_create_pkg xx urdf xacro 1 . 优化上节小车代码：
① 底盘代码
在xacro文件夹下创建robot.xacro
touch robot.xacro &lt;!-- 设置机器人底盘--&gt; &lt;!-- 1.代码复用 2.参数设计 --&gt; &lt;robot name="mycar" xmlns:xacro="http://wiki.ros.org/xacro"&gt; &lt;!-- 一、属性封装--&gt; &lt;xacro:property name="footprint_radius" value="0.001" /&gt; &lt;!-- 1.base_footprint--&gt; &lt;link name="base_footprint"&gt; &lt;visual&gt; &lt;geometry&gt; &lt;sphere radius="${footprint_radius}" /&gt;	&lt;/geometry&gt;	&lt;/visual&gt; &lt;/link&gt; &lt;xacro:property name="base_link_radius" value="0.1" /&gt; &lt;xacro:property name="base_link_length" value="0.08" /&gt; &lt;xacro:property name="lidi" value="0.015" /&gt; &lt;xacro:property name="base_joint_z" value="${base_link_length/2+lidi}" /&gt; &lt;!-- 2.底盘link--&gt; &lt;link name="base_link"&gt; &lt;visual&gt; &lt;geometry&gt; &lt;cylinder radius="${base_link_radius}" length="${base_link_length}" /&gt;	&lt;/geometry&gt;	&lt;origin xyz="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c533ffd8ede01f97d6ad2ae4b7fb0e66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d2eef0c1a09df5005d956e41c39d5a6/" rel="bookmark">
			深度学习系列48：超分模型Real-ESRGAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 模型介绍 1.1 退化模型 首先训练数据使用了2个first-order：
最后一步加入了振铃和过冲现象：
1.2 SRCNN 将CNN用到超分领域的第一篇文章：
论文中卷积核和通道数的实验设置为：
1.3 SRGAN SRGAN将GAN引入超分领域，用于解决如下问题：
1）高频细节(high-frequency details) 的丢失，整体图像过于平滑/模糊；
2）与人的视觉感知不一致，超分图像的精确性与人的期望不匹配（人可能更关注前景，而对背景清晰度要求不高）。
提出如下改进：
新的backbone：SRResNet；GAN-based network 及 新的损失函数：adversarial loss：提升真实感(photo-realistic natural images)；content loss：获取HR image和生成图像的感知相似性(perceptual similarity)，而不只是像素级相似性(pixel similarity)；或者说特征空间的相似性而不是像素空间的相似性。使用主观评估手段，更加强调人的感知。 模型结构如下，Generator网络是SRResNet，论文使用了16个residual blocks；Discriminator网络为8次卷积操作（4次步长为2）+2次全连接层的VGG网络。
1.4 ESRGAN enhanced SRGAN，主要解决细节模糊和伪影问题。
SRResNet网络结构的改进：
1）移除BN，有利于去除伪影，提升泛化能力；
2）使用Residual-in-Residual Dense Block (RRDB)作为基本构建模块，更强更易训练；GAN-based Network的损失函数的改进：使用RaGAN (Relativistic average GAN)中的相对损失函数，提升图像的相对真实性从而恢复更多的纹理细节；感知损失函数的改进：使用VGG激活层前的特征值计算重构损失，提升了亮度的一致性和纹理恢复程度。
2. 快速上手 2.1 各种资源 绿色版的exe文件参见github，支持windows，linux，mac和NCNN
在线版本：https://huggingface.co/spaces/akhaliq/Real-ESRGAN
使用方法：./realesrgan-ncnn-vulkan.exe -i 二次元图片.jpg -o 二刺螈图片.png -n realesrgan-x4plus-anime
参数如下：
Usage: realesrgan-ncnn-vulkan.exe -i infile -o outfile [options]... -h show this help -i input-path input image path (jpg/png/webp) or directory -o output-path output image path (jpg/png/webp) or directory -s scale upscale ratio (can be 2, 3, 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d2eef0c1a09df5005d956e41c39d5a6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/228/">«</a>
	<span class="pagination__item pagination__item--current">229/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/230/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>