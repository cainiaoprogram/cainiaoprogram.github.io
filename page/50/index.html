<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b56fb2acea40ffde51f4cf72a99f1156/" rel="bookmark">
			PAT 乙级 1016 部分A&#43;B
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解题思路，算出来数量挨个加就可以了
python版本:
s=input().split() a1=list(s[0]) a2=list(s[2]) num=a1.count(s[1]) sum1=0 for i in range(num): sum1=sum1*10+int(s[1]) num=a2.count(s[3]) sum2=0 for i in range(num): sum2=sum2*10+int(s[3]) print(sum1+sum2) c语言版本:
#include&lt;stdio.h&gt; int main() { int a,digit_a,b,digit_b; int suma=0,sumb=0; scanf("%d%d%d%d",&amp;a,&amp;digit_a,&amp;b,&amp;digit_b); while(a) { if(a%10==digit_a) { suma=suma*10+digit_a; } a=a/10; } while(b) { if(b%10==digit_b) { sumb=sumb*10+digit_b; } b=b/10; } printf("%d\n",suma+sumb); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/684eca8322138ab385d84d161d5cca57/" rel="bookmark">
			PAT 乙级 1014 福尔摩斯的约会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解题思路:这题可把我给弄惨了，研究了很长时间，原因一是第一次我用python写想用字典的get函数去处理字母和数字字符，利用默认值，可是万万没想到，字符串格式化对字符和数字的补0是不一样的，这个错误我找了好久其余的坑都一言我统一说一说
这题第一个要注意的点是范围，大写字母，寻找日期的范围只能是A~G 刚好七个，判断的时候就要注明
第二个点 必须是第一个已经找到，再去找第二个，第二个范围只能是0~9，A-N,判断的时候看好，并且一定是找到就跳出循环，不然后面可能还有满足的
第三点 就很简单找到英文字符 位置输出就行
c语音版本:
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { char a[4][100]; char day[7][10]={"MON","TUE","WED","THU","FRI","SAT","SUN"}; int i; for(i=0;i&lt;4;i++) { scanf("%s",a[i]); } int s1,s2,num,flag=0; s1=strlen(a[0]); s2=strlen(a[1]); num=s1&lt;s2?s1:s2; for(i=0;i&lt;num;i++) { if(a[0][i]==a[1][i]&amp;&amp;flag==0&amp;&amp;a[0][i]-'A'&gt;=0&amp;&amp;a[0][i]-'A'&lt;7) { flag=1; printf("%s ",day[a[0][i]-'A']); } else if(flag==1&amp;&amp;a[0][i]==a[1][i]) { if(a[0][i]&gt;='A'&amp;&amp;a[0][i]&lt;='N') printf("%02d:",a[0][i]-'A'+10); else if(a[0][i]&gt;='0'&amp;&amp;a[0][i]&lt;='9') { printf("%02d:",a[0][i]-'0'); break; } } } s1=strlen(a[2]); s2=strlen(a[3]); num=s1&lt;s2?s1:s2; for(i=0;i&lt;num;i++) { if(a[2][i]==a[3][i]&amp;&amp;(a[2][i]&gt;='A'&amp;&amp;a[2][i]&lt;='Z'||a[2][i]&gt;='a'&amp;&amp;a[2][i]&lt;='z')) { printf("%02d\n",i); break; } } return 0; } python 版本：
s1=input() s2=input() s3=input() s4=input() day={'A':'MON','B':'TUE','C':'WED','D':'THU','E':'FRI','F':'SAT','G':'SUN'} hour={'A':10,'B':11,'C':12,'D':13,'E':14,'F':15,'G':16,'H':17,'I':18,'J':19,'K':20,'L':21,'M':22,'N':23} first=-1 num1=min(len(s1),len(s2)) for i in range(num1): if s1[i]==s2[i] and s1[i]&gt;='A' and s1[i]&lt;='G': print(day[s1[i]],end=' ') first=i break for i in range(first+1,num1): if s1[i]==s2[i] and (s1[i]&gt;='0' and s1[i]&lt;='9' or s1[i]&gt;='A' and s1[i]&lt;='N'): if(s1[i]&gt;='0' and s1[i]&lt;='9'): print('0'+s1[i],end=':') elif s1[i]&gt;='A' and s1[i]&lt;='N': print(hour[s1[i]],end=':') break num1=min(len(s3),len(s4)) for i in range(num1): if s3[i]==s4[i] and (s3[i]&gt;='a'and s3[i]&lt;='z'or s3[i]&gt;='A' and s3[i]&lt;='Z'): print('{:02}'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/684eca8322138ab385d84d161d5cca57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ec84ea210374502805aabcca0777215/" rel="bookmark">
			PAT 乙级 1013 数素数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解题思路，简单素数判定，计算数量 输出就可以了
#include&lt;stdio.h&gt; int prime(int n) { int i,flag=1; for(i=2;i*i&lt;=n;i++) { if(n%i==0) { flag=0; break; } } return flag; } int main() { int n,m,amont=2,count=0,space=0; scanf("%d %d",&amp;n,&amp;m); while(count&lt;n-1) { if(prime(amont)) { count++; } amont++; } while(count&lt;m) { if(prime(amont)) { count++; space++; if(space%10!=0&amp;&amp;count!=m) printf("%d ",amont); else printf("%d\n",amont); } amont++; } return 0; } python代码思路一样但是某个数据超时
def prime(n): flag=True i=2 if(n&lt;2): flag=False else: while(i*i&lt;=n): if n%i==0: flag=False break i=i+1 return flag s=input().split() n=int(s[0]) m=int(s[1]) count=0; space=0; a=2 while(count&lt;n-1): if(prime(a)): count=count+1 a=a+1 while(count&lt;m): if(prime(a)): count+=1 space+=1 if space%10!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ec84ea210374502805aabcca0777215/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bcfc9206936cf122a989ffb1b616936/" rel="bookmark">
			PAT 乙级 1012 数字分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解题思路:此题不难，但是烦在格式繁琐，需要注意的点特别多
c语音版
#include&lt;stdio.h&gt; int main() { int a1=0,a2=0,a5=0; int count[6]={0}; double a4=0; int n; scanf("%d",&amp;n); int num; int flag=1; while(n--) { scanf("%d",&amp;num); if(num%10==0) { count[1]++; a1+=num;	} if(num%5==1) { count[2]++; a2+=flag*num; flag=-flag; } if(num%5==2) { count[3]++; } if(num%5==3) { count[4]++; a4+=num; } if(num%5==4&amp;&amp;num&gt;a5) { count[5]++; a5=num; } } if(count[1]) printf("%d",a1); else printf("N"); int i; for(i=2;i&lt;=5;i++) { if(count[i]==0) { printf(" N"); continue; } else switch(i) { case 2: printf(" %d",a2);break; case 3: printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bcfc9206936cf122a989ffb1b616936/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ae07c68f57d7f61eb4396ba913d759/" rel="bookmark">
			PAT乙级 1011 A&#43;B 和 C
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解题思路
本题非常简单但是一样有坑，c语言写的时候一定要注意范围，如果你只用int型去写的话最大值相加一定溢出，所以你必须扩大字节数量，改成long long int,
python没有此问题
c代码：
#include&lt;stdio.h&gt; int main() { int n,a,b,c,i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) { scanf("%d %d %d",&amp;a,&amp;b,&amp;c); if(a+b&gt;c) printf("Case #%d: true\n",i+1); else printf("Case #%d: false\n",i+1); } return 0; } python 代码
n=int(input()) for i in range(n): s=input().split() if(eval(s[0]+'+'+s[1])&gt;eval(s[2])): print("Case #{}: true".format(i+1)) else: print("Case #{}: false".format(i+1)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff2caf302a5c5792fd4c51e9fa82ed2/" rel="bookmark">
			python 面试题第一弹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 如何理解Python中的深浅拷贝 浅拷贝（Shallow Copy）创建一个新的对象，该对象的内容是原始对象的引用。这意味着新对象与原始对象共享相同的内存地址，因此对于可变对象来说，如果修改了其中一个对象，另一个对象也会受到影响。浅拷贝通常使用copy模块的copy()函数或者对象的copy()方法来完成。
下面是一个浅拷贝的示例：
import copy original_list = [1, 2, [3, 4]] copied_list = copy.copy(original_list) print(original_list) # [1, 2, [3, 4]] print(copied_list) # [1, 2, [3, 4]] # 修改原始列表中的元素 original_list[0] = 10 original_list[2][0] = 30 print(original_list) # [10, 2, [30, 4]] print(copied_list) # [1, 2, [30, 4]] 在上面的示例中，copy.copy()函数创建了original_list的浅拷贝copied_list。当我们修改original_list时，copied_list中的嵌套列表也会受到影响。
深拷贝（Deep Copy）创建一个新的对象，该对象的内容是原始对象及其所有嵌套对象的副本。这意味着新对象在内存中是完全独立的，对其中一个对象的修改不会影响另一个对象。深拷贝通常使用copy模块的deepcopy()函数或者对象的deepcopy()方法来完成。
下面是一个深拷贝的示例：
import copy original_list = [1, 2, [3, 4]] deep_copied_list = copy.deepcopy(original_list) print(original_list) # [1, 2, [3, 4]] print(deep_copied_list) # [1, 2, [3, 4]] # 修改原始列表中的元素 original_list[0] = 10 original_list[2][0] = 30 print(original_list) # [10, 2, [30, 4]] print(deep_copied_list) # [1, 2, [3, 4]] 在上面的示例中，copy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ff2caf302a5c5792fd4c51e9fa82ed2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d23df5e19669dec5d5854235571e4bd/" rel="bookmark">
			Git：git clone报错The project you were looking for could not be found or you don‘t have ...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、git clone 项目，报错如下 remote: The project you were looking for could not be found or you don't have permission to view it.
fatal: repository 'http://xxx.xxx.com/xxx_tools/xxx-frontend.git/' not found
解决问题
在http://后增加 “用户名@”
git clone http://userName@xxx.xxx.com/xxx_tools/xxx-frontend.git
经过测试，问题解决了
二、AI解释 在git clone命令中，你可以在仓库地址中指定用户名。这种方式被用于在克隆私有仓库时进行身份验证。
具体来说，你可以将 用户名 替换为你的用户名，将 仓库地址 替换为你要克隆的仓库的URL。在克隆时，Git会使用你提供的用户名来进行身份验证，以确保你有权限访问该仓库。
请注意，这种方式可能不适用于所有的Git仓库，因为不是所有仓库都要求进行身份验证。如果你没有特定的要求，那么你可以直接使用不带用户名的URL进行克隆。
示例：
git clone http://yourusername@github.com/your/repository.git 将 yourusername 替换为你的真实用户名，将 github.com/your/repository.git 替换为你要克隆的仓库的URL。
三、欢迎交流指正 参考链接 Git：Git分支管理规范 / 常用命令-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59721386edfb904d99f3ed93d6e3e29b/" rel="bookmark">
			【本地运行AI绘画】ComfyUI的安装与使用（一）（windows&#43;1660ti 6G显存）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方源码：https://github.com/comfyanonymous/ComfyUI/
官方环境包: https://github.com/comfyanonymous/ComfyUI/releases
百度网盘下载： 显卡驱动cu11+以下下载cu118。 显卡驱动12以上可以下载cu121
一、下载、更新、启动comfyui 百度网盘链接（提取码：1225)：https://pan.baidu.com/s/1BVMNo9CDuDn-aAKXCZYrKQ?pwd=1225
Comfyui_windows 解压后的结构
1.1 进入子文件夹配置 将下载的启动器复制到这里
1.2 修改配置 extra_model_paths.yaml.example 引入已有的模型 重命名配置文件 为 extra_model_paths.yaml
假设本机模型地址为
修改配置文件为
1.3 利用秋叶的启动器更新代码 选择 版本管理, 更新到最新代码
1.4 启动 点击一键启动，启动好后，会在浏览器自动启动
1.5 后台调试信息看错误 在浏览器启动界面 选择模型、输入题词，运行点击Queue Prompt (或者Ctrl+enter)
二、生成图片 （未LCM加速） 第一次加载模型+推理时间很长
不换模型，换题词图推理
生成结果与流图片
lcm加速 首次加载模型后，只需要3秒就能生成1张图，因为只用采样5次，是普通模型速度的4倍
题词prompt
evening sunset scenery blue sky nature, glass bottle with a galaxy in it
附录 秋叶webui一键安装包：链接：https://pan.baidu.com/s/1khO9jcuqazwg2LK4e8lXEg?pwd=1225
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b9dededbc4117a610cae31d0ec365e3/" rel="bookmark">
			RSIS 系列 Rotated Multi-Scale Interaction Network for Referring Remote Sensing Image Segmentation 论文阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RSIS 系列 Rotated Multi-Scale Interaction Network for Referring Remote Sensing Image Segmentation 论文阅读笔记 一、Abstract二、引言三、相关工作Referring Image Detection and SegmentationRemote Sensing Referring Image Detection and Segmentation 四、RRSIS-D五、RMSIN5.1 总览5.2 Compounded Scale Interaction Encoder (CSIE)5.2.1 尺度内交互模块各种感知分支跨模态对齐分支 5.2.2 跨尺度交互模块多尺度特征组合多尺度注意力层尺度感知门 5.3 方向感知解码器5.3.1 自适应旋转卷积 六、实验6.1 实施细节实验设置指标 6.2 与 SOTA 的 RIS 方法比较6.3 消融研究IIM 和 CIM 的有效性CIM 的深度设计解码器的设计ARC 的设计 6.4 可视化6.4.1 定量分析6.4.2 编码器特征可视化 七、结论 写在前面
同样是一篇比较新的论文挂在 Arxiv 上面，拿来读一读。看标题应该是提出了新的 RIS 数据集与方法，用于遥感目标检测的。
论文地址：Rotated Multi-Scale Interaction Network for Referring Remote Sensing Image Segmentation代码地址：https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b9dededbc4117a610cae31d0ec365e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90157fb47e37717717524986aef49755/" rel="bookmark">
			Filezilla远程传输文件工具安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用树莓派或者云服务器时，需要远程传输文件，就少不了这个Filezilla工具，首先进入官网
Filezilla:https://filezilla-project.org/download.php?type=server
点击下载
有条件的可以buy，但是一般用免费也够用了，点“download”
点击"I Agree"
如图，下一步
如图，选择desktop Icon会在桌面产生快捷方式，next
选择一个安装路径下一步
点击 ——&gt;Install
点击——&gt;Finish
界面如下
安装成功，感谢支持！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/974a39b632928a3d5913e4f3f9f113b0/" rel="bookmark">
			《物流管理定量分析方法》第二次作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物流管理定量分析方法 ​第二次作业 ​（一）填空题
*8．若A为3×4矩阵，B为2×5矩阵，其乘积ACTBT有意义，则C为_____矩阵。
（二）单项选择题
（三）计算题
（四）应用题
1. 某物流公司下属企业生产甲、乙两种产品，要用A，B，C三种不同的原料，从工艺资料知道：每生产一件产品甲，需用三种原料分别为1，1，0单位；生产一件产品乙，需用三种原料分别为1，2，1单位。每天原料供应的能力分别为6，8，3单位。又知，销售一件产品甲，企业可得利润3万元；销售一件产品乙，企业可得利润4万元。
试写出能使利润最大的线性规划模型，并用MATLAB软件计算（写出命令语句，再用MATLAB软件运行出结果）。
2. 某物流公司有三种化学产品A1，A2，A3。每公斤产品A1都含B1，B2，B3三种化学成分0.7公斤、0.2公斤和0.1公斤；每公斤产品A2都含B1，B2，B3三种化学成分0.１公斤、0.３公斤和0.６公斤；每公斤产品A３都含B1，B2，B3三种化学成分0.３公斤、0.４公斤和0.３公斤。每公斤产品A1，A2，A3的成本分别是500元、300元和400元。今需要B1成分至少100斤，B2成分至少50斤，B3成分至少80斤。
试列出使总成本最小的线性规划模型。
3. 某物流企业下属家具厂生产桌子和椅子，产品的销路很好。生产每张桌子的利润为12元，每张椅子的利润为10元。生产每张桌子在该厂的装配中心需要10分钟，在精加工中心需要20分钟；生产每张椅子在装配中心需要14分钟，在精加工中心需要12分钟。该厂装配中心一天可利用的时间不超过1000分钟，精加工中心一天可利用的时间不超过880分钟。假设生产桌子和椅子的材料能保证供给。
试写出使企业获得最大利润的线性规划模型，并用MATLAB软件计算（写出命令语句，并用MATLAB软件运行处结果）。
（五）用MATLAB软件计算（写出命令语句，并用MATLAB软件运行）
（六）用手工计算下列各题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e27268b4c569bbbb2169bcd9385f6f84/" rel="bookmark">
			基于MPU6050的跌倒检测项目设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 随着人口老龄化的不断加剧，老年人的健康和安全问题备受关注。本设计旨在利用STM32单片机与MPU6050传感器相结合，实现基于角度变化的跌倒检测系统。这一系统不仅能够快速、准确地检测老年人是否发生跌倒，还通过整合通信模块实现了实时的跌倒提醒功能。设计目标包括通过C编写MPU6050传感器的驱动代码和数据滤波算法，确保系统对身体姿态的敏感性和准确性。同时，通过整合通信模块，老年人在发生跌倒时能够及时地向特定用户发送提醒信息，包括短信和坐标，以便他们能够及时作出相应的帮助。为确保系统的可用性和便携性，本设计采用小型电池供电，使老年人可以随时随地使用。
注：本设计由于前期调研不够充分，没有GPS模块，也没有无线传输功能。
二、项目材料清单 面包板已经各种公母线
stm32f103c8t6
蜂鸣器
0.96寸OLED显示模块
CH340串口
ESP8266-01s
三、主控器与传感器的连接 电路连接图
这里因为我已经将原来的电路给拆了，所以只能照着这张图去给大家说下，GND和VCC就省去了。
蜂鸣器：I/O 与PB12相接
OLED：SCL与PB8，SDAPB9
MPU6050：SCL与PB10，SDA与PB11
串口：TXD与PA10，RXD与PA9
ESP8266-01s我没有驱动成功，所以放在这里只是一个摆设。需要注意的是MPU6050最好像我这样连接，因为我们需要通过它获取俯仰角和翻滚角，要保证模块的平稳。
通过串口发送数据
四、跌倒检测算法的设计 使用MPU6050传感器获取加速度计和陀螺仪的原始数据，通过STM32的I2C接口与MPU6050进行通信，读取加速度和角速度数据。该算法可以根据以下步骤来实现
步骤：
1. 计算加速度计推导的俯仰角和横滚角：
a. 使用 atan2(AY, sqrt(AX * AX + AZ * AZ)) 计算 accPitch，将结果转换为角度。
b. 使用 atan2(-AX, AZ) 计算 accRoll，将结果转换为角度。
2. 对陀螺仪数据进行角速度积分：
a. 通过积分陀螺仪数据 GY，按照灵敏度系数（131.0）进行缩放，计算 gyroPitch。
b. 通过积分陀螺仪数据 GX，使用相同的灵敏度系数，计算 gyroRoll。
3. 应用互补滤波：
a. 将互补滤波系数 alpha 定义为 0.98。
b. 利用互补滤波，结合加速度计推导的角度（accPitch、accRoll）和陀螺仪积分得到的角度（gyroPitch、gyroRoll）：
4. 输出：
更新后的俯仰角和横滚角代表设备平稳和稳定的方向。
下面是我写的伪代码，帮助大家理解这里：
Algorithm UpdateAttitude(int16_t AX, int16_t AY, int16_t AZ, int16_t GX, int16_t GY, int16_t GZ):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e27268b4c569bbbb2169bcd9385f6f84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a2e4af49c83d828bc5faca052d3be0f/" rel="bookmark">
			FlinkCDC（二）同步mysql的binlog到doris
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面一章使用flink sql的方式来做数据的同步，但是有一个问题，如果我们一个库里面有100多张表或者更多，那就要写100多个create table来连接，mysql的连接数也会一下子暴涨，所以对于多个表或者整个库或者多库的数据同步，只能使用datastream来同步。
下面用java来实现flink datastream流式处理数据同步：
先创建一个project，取名flinkcdc-mysql-doris。pom文件里面需要导入以下jar包
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;ztorn-cdc&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;ztorn-cdc&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;commons.version&gt;1.3.1&lt;/commons.version&gt; &lt;flink.guava.version&gt;16.0&lt;/flink.guava.version&gt; &lt;flink.version&gt;1.16.0&lt;/flink.version&gt; &lt;flinkcdc.version&gt;2.3.0&lt;/flinkcdc.version&gt; &lt;mockito.version&gt;3.12.4&lt;/mockito.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.ztorn&lt;/groupId&gt; &lt;artifactId&gt;ztorn-common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.ztorn.framework&lt;/groupId&gt; &lt;artifactId&gt;ztorn-framework&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-python&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-planner_2.12&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-runtime&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-jdbc&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-api-java-bridge&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a2e4af49c83d828bc5faca052d3be0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6e60261a8be386d82adf6771c2b819f/" rel="bookmark">
			8、SpringCloud高频面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、SpringCloud组件有哪些 SpringCloud 是一系列框架的有序集合。它利用 SpringBoot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 SpringBoot 的开发风格做到一键启动和部署。
早期我们一般认为的Spring Cloud五大组件是
Eureka : 注册中心Ribbon : 负载均衡Feign : 远程调用Hystrix : 服务熔断Zuul/Gateway : 网关 随着SpringCloudAlibba在国内兴起 , 我们项目中使用了一些阿里巴巴的组件
注册中心/配置中心 Nacos
负载均衡 Ribbon
服务调用 Feign
服务保护 sentinel
服务网关 Gateway
2、Feign工作原理 Feign是SpringCloud技术栈中用于远程调用的一个HTTP客户端，主要作用是将远程服务调用格式本地方法调用格式统一成一致的
Feign的工作步骤如下：
首先需要在SpringBoot的启动类上添加@EnableFeignClients 注解开启对Feign的支持
当程序启动时，会扫描所有标有@FeignClient的注解的类，并且将这些信息注入Spring IOC 容器中
当定义的 Feign 接口中的方法被调用时，通过JDK的代理方式，来生成具体的 RequestTemplate
RequestTemplate对象封装了 HTTP 请求需要的全部信息，如请求参数名，请求方法等信息
然后RequestTemplate生成 Request，并将Request交给Client去处理，这里的 Client 可以是 JDK 原生的 URLConnection、Apache 的 HttpClient等
最后Client被封装到LoadBalanceClient类，这个类结合Ribbon负载均衡发起服务之间的调用
3、什么是Hystrix 在微服务架构中，我们会拆分出很多的服务，服务之间存在复杂的调用关系，那么这些服务一旦会出现失败的情况，就会导致服务雪崩
Hystrix就是来防止服务雪崩的工具，它具有服务降级，服务熔断，服务隔离，监控等一些防止雪崩的技术。 它有四种防雪崩手段：
服务隔离：隔离服务之间相互影响服务监控：在服务发生调用时，会将每秒请求数、成功请求数等运行指标记录下来服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息服务降级：接口调用失败就调用本地的方法返回一个空 4、Hystrix断路器状态有哪些 断路器状态机包括三个状态：
closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态open：打开状态，服务调用被熔断，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态5秒后（默认值）会进入half-open状态half-open：半开状态，放行一次请求，根据执行结果来判断接下来的操作 请求成功：则切换到closed状态请求失败：则切换到open状态
5、Ribbon的工作原理 我们项目中使用的是Feign来进行远程微服务的调用，Feign的底层是集成了Ribbon的，大体使用流程如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6e60261a8be386d82adf6771c2b819f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d289805110cec1cd69396eff7f92ad95/" rel="bookmark">
			【pytorch】常用图像处理与数据增强方法合集（torchvision.transforms）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【pytorch】常用图像处理与数据增强方法合集（torchvision.transforms）
文章目录
张量化（ToTensor）
灰度化（Grayscale）
标准化（Normalize）
组合转换（Compose）
中心裁剪（CenterCrop）
边缘拓展（Pad）
随机裁剪（RandomCrop）
尺寸缩放（Resize）
随机旋转（RandomRotation）
水平翻转（RandomHorizontalFlip）
垂直翻转（RandomVerticalFlip）
色彩抖动（ColorJitter）
高斯模糊（GaussianBlur）
仿射变换（RandomAffine）（包含平移）
张量化
torchvision.transforms.ToTensor
描述
将PIL.Image或numpy.ndarray类型的图片转为torch.Tensor类型，如果图片的灰度级在[0, 255]，会除以255.0，归一化到[0.0, 1.0]。这个基本上每个数据集都会用到。
参数
不用给参数。
示例
from torchvision import transforms
import numpy as np
a = np.array([[255, 199, 30]], dtype=np.uint8)
a
array([[255, 199, 30]], dtype=uint8)
t = transforms.ToTensor()
b = t(a)
b
tensor([[[1.0000, 0.7804, 0.1176]]])
灰度化
torchvision.transforms.Grayscale(num_output_channels=1)
描述
将彩色图片转为灰度图片。图片必须是PIL.Image或torch.Tensor类型。
参数
如果num_output_channels=1，返回单通道灰度图片；如果num_output_channels=3，返回三通道的灰度图片，其中r == g == b。一般我们不用设置，默认为1就行了。
示例
from PIL import Image
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d289805110cec1cd69396eff7f92ad95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0cddc0cb86d696b08db48e1ffa95c9c/" rel="bookmark">
			深度学习（手写数字识别）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家关注我的B站：
偷吃薯片的Zheng同学的个人空间-偷吃薯片的Zheng同学个人主页-哔哩哔哩视频 (bilibili.com)
本程序采用百度paddlepaddle深度学习框架，并在百度AI Studio平台上运行
目录
1 实验内容
2 实验流程
3 DNN模型
4 LeNet 模型
4.1 LeNet-1模型
4.2 Lenet-4 模型
4.3 LeNet-5 模型
4.4 LeNet 模型的总结
4.5 LeNet 模型与DNN模型比较
5 模型的应用
5.1 自己的手写数字图片
5.2将手写的图片进行预处理
5.3调用训练好的模型进行预测
5.4 总结
1 实验内容 本次实验采用构造 DNN 模型与 LeNet 模型进行手写数字识别实验，采用经典手写数字识别数据集 MINIST，MINIST 数据集包含60000个训练集与10000个测试集。数据集分为图片与标签，其中图片是28*28的像素矩阵，标签为 0~9 共10个数字。该数据集的官方网址为MNIST handwritten digit database, Yann LeCun, Corinna Cortes and Chris Burges
2 实验流程 在实验过程中为确保最终训练的神经网络拥有较强的泛化能力，本次实验会在最后对自己手写的一些数字图片进行识别。
3 DNN模型 以下的代码判断就是定义一个简单的 DNN模型（多层感知器），一共有三层，两个大小为100的隐层和一个大小为10的输出层，因为MNIST数据集是手写0到9的灰度图像，类别有10个，所以最后的输出大小是10。最后输出层的激活函数是Softmax，所以最后的输出层相当于一个分类器。加上一个输入层的话，多层感知器的结构是：输入层--&gt;&gt;隐层--&gt;&gt;隐层--&gt;&gt;输出层。神经网络结构如下
利用 paddlepaddle 的动态图对初始的 DNN 模型进行定义，代码如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0cddc0cb86d696b08db48e1ffa95c9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcca4e95ddc009192bab88c514776cd0/" rel="bookmark">
			CS插件——CobaltStrike_CNA-权限维持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 简介 EasyPersistent,是一个用于windows系统上权限维持的Cobalt Strike CNA 脚本。 脚本整合了一些常用的权限维持方法，使用反射DLL模块可使用API对系统服务、计划任务等常见权限维持方法进行可视化操作（强烈建议使用白名单进程进行操作）。 脚本功能菜单： 设置常用路径
全局路径参数设置
文件控制
文件属性、文件权限的查看和修改
文件符号链接的创建
注册表
注册表的增加、删除、查询
系统服务
系统服务的创建、查询、删除、SDDL设置
用户操作
系统用户账户的添加、删除、修改、查询、克隆、激活、禁用
启动目录
系统启动目录文件的查询、写入
计划任务
计划任务的查询、写入、删除
DLL加载
MSDTC服务、Explorer程序DLL劫持
BITS任务
BITS任务的添加、查询、删除
WMI事件
WMI事件订阅的添加、查询、删除
0x02 使用方法 GUI界面参数根据理解填写，可能部分位置有Bug，欢迎提交issues. 示例 文件控制 主要是attrib、takeown、icacls、mklink几个命令的使用。 注册表 通过Reg命令执行操作，支持对以下位置进行操作：Run, RunOnce, RunOnceEx,Logon Scripts,Winlogon Shell, Winlogon Userinit 添加方法带有/f选项，可用于更新键值： 查询位置分为单个键查询和一键查询所有(选项里有的)启动项位置，查询所有比较暴力： 其他Tips: 针对x86和x64注册表位置可使用下拉选项进行选择; 使用时请注意HKLM和HKCU位置，x86和x64的不同; HKLM位置可能需要管理员权限，SYSTEM权限在写入HKCU位置会出现问题。 系统服务 系统服务主要使用SC命令和一些API进行操作 脚本中提供了两个服务程序TransitEXE.exe和uinit.exe，其中uinit.exe为一个启动后会返回服务失败的程序，用于错误回调执行，TransitEXE.exe服务程序实现代码参考[CreateService](https://github.com/uknowsec/CreateService)，主要进行了以下修改： 1. 注释RC4加密部分 2. 修改资源ID默认为100 3. 增加互斥体检测退出服务功能 4. 增加进程守护功能 在ReflectiveDll的实现中，根据微软文档主要进行了以下功能开发： 1. 设置服务描述，设置多种启动类型添加，设置SDDL安全描述符 服务守护进程 服务名称和显示名称在SCM中的位置 添加服务时，为了方便测试，脚本对一些参数进行字符随机化，并对各个流程进行了调试信息输出： 添加服务后的显示： 在这里，只需要选择一个二进制文件上传，点击添加即可，之后脚本会根据需要上传某个服务程序。如果是TransitEXE，反射DLL会将执行命令写入到服务程序资源信息中，随后启动服务，服务程序落地后启动后会提取出自身资源信息中的命令行，使用CreateProcess第二个参数来执行。 程序描述部分支持中文描述 触发器启动 在命令行中的触发器使用了网络触发器： sc triggerinfo ServiceName start/networkon API中使用的是硬件接口触发: 安全描述符设置 在API中通过ConvertStringSecurityDescriptorToSecurityDescriptor和SetServiceObjectSecurity设置服务的安全描述符，如果进行一些限制设置需要SYSTEM权限(注意如果在administrator权限下设置了SDDL限制，那么会导致OpenService Failed的情况)： 服务启动失败回调 启动服务失败后会有回调命令执行: 其他 - 两个服务程序可以写成一个，只是uinit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcca4e95ddc009192bab88c514776cd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45cdb604030fbe9343f4bd39877f1fe4/" rel="bookmark">
			02. 青龙面板应用——安装依赖拉取仓库运行京东脚本（保姆级图文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 安装依赖1.0 安装依赖失败怎么办?(换国内源)1.1 常用依赖1.2 安装指定依赖 2. 定时规则3. 常用的仓库地址4. 添加订阅5. 运行订阅6. 获取京东手机版cookie7. 在青龙面板中添加京东cookie8. 测试任意一个京东的定时任务总结 欢迎关注 『青龙面板』 专栏，持续更新中
欢迎关注 『青龙面板』 专栏，持续更新中
1. 安装依赖 1.0 安装依赖失败怎么办?(换国内源) 在终端中查看python版本(如果你是按照我前面文章安装的青龙面板,你的python版本是3.10)
首先先检查你安装的库对于python版本的要求
比如说aiohttp要求python3.5以上
打开我们青龙面板的docker中的终端
输入python 可以得到python版本号
如果青龙面板安装依赖失败----
查看安装日志:(这里也可以看出来python3.10的版本)
Collecting jieba Downloading jieba-0.42.1.tar.gz (19.2 MB) ━━━ 1.6/19.2 MB 6.4 kB/s eta 0:46:20 ERROR: Exception: Traceback (most recent call last): File "/usr/local/lib/python3.10/site-packages/pip/_vendor/urllib3/response.py", line 438, in _error_catcher yield File "/usr/local/lib/python3.10/site-packages/pip/_vendor/urllib3/response.py", line 561, in read data = self._fp_read(amt) if not fp_closed else b"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45cdb604030fbe9343f4bd39877f1fe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ab9abd373bb23e6cb50b61c9f328f2/" rel="bookmark">
			前段时间车子出险了,记录一下关于车子的保险和出险的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年的第一场雪，比以往时间来的早了一些，
飞驰在乡道的我的汽车，帶走了最後一片飄落的黃叶
2023年的第一场雪，是留在珠城蚌埠難舍的情結，
它像一隻飛來飛去的蝴蝶，在白雪飄飛的季節裡搖曳
忘不了护栏把我搂住的感覺，比藏在心中那分火熱更暖一些，
忘記了车窗外的北風凜冽，在雨夹雪的溫柔里纏綿惊噎
是我的车速急驰忘记一切，想起秋名山的尾灯让我再次熱烈，
是你的萬種柔情融化冰雪，是你的引擎低音改变季節
文章目录 前言一、为什么买保险？1.保险是什么？2.我们为什么要买？ 二、买什么保险？1.保险分类2.车险有哪些分类？哪些必买？哪些可选？3.商业车险怎么买？ 三、遇险处理步骤1.判断是否出险2.出险处理流程3.多大事故需要走保险？4.医药费是否需要垫付 四、闭坑小贴示拒赔不理赔情况 总结 前言 提示：以下是本篇文章正文内容，下面案例可供参考
一、为什么买保险？ 1.保险是什么？ 保险（Insurance或缩写为insur），
首先，保险是一种财务管理的工具；是一种保障机制，
是市场经济条件下风险管理的基本手段，是金融体系和社会保障体系的重要的支柱。
其次，它最重要的作用在于风险管理，
即你不愿意发生的事情发生了，而恰恰又会给你造成财务上的损失，此时，保险就能给你一定财务上的补偿。
2.我们为什么要买？ 人这一生它不能保证风险事件发生与否，不能避免风险事件带来的损失。
但防患于未然或许能减少你潜在可能发生的损失。
买保险是一个消费的过程。买入的是一种权利，即在约定的风险事故发生时获得补偿。
在财务上看，它令你财富减少了，但减少的财富保障了你的财富。
为什么守业更比创业难，其中一点就是守业投资的保障不够；
保险最大的作用在于杠杆，即用较少的保费获得较大的保额，用100元的钱去解决1千元甚至1万元的事。
对于抗风险能力是相对不足的普通的阶层来说，一场大病或者一场意外的花费足以毁了整个家庭，
社会需要保险这种服务来为我们的生活兜底，分散均摊这种风险。
人生哪能多如意,万事只求半称心；
二、买什么保险？ 1.保险分类 风险总体来说可以分成四种类：
发概率高的，影响严重的；发生率低的，影响严重的；发生概率高的，影响轻微的；发生概率低的，影响轻微的。 很多时候，投保人想通过买保险一劳永逸，往往会被套。
投保应根据自身的风险需求，配置的保险。如医疗险只能解决医疗费用的问题。
意外险，重疾险，寿险都是解决失能造成的财务损失。
2.车险有哪些分类？哪些必买？哪些可选？ 再细致一点
交强险【强制】国家要求必须买的。不买的话，车不能上路，属于最基础的保障。
交强险不保障我们自己的车，只赔偿他人的损失。
商业车险【自愿购买】商业车险可以自由选择是否投保，具体保额也可以自己定。
全称为车辆商业险，它是一个统称，名下还有许多的车险类，根据自己的需要选择购买。
重点关注：
第三者责任险（也叫“三者险”） 车上人员责任险 车损险 第三者责任险（三者险），很重要，保额要管够！第三者责任险是用来保对方人和车的，假如不慎撞了其他车辆或行人，造成对方的死伤或车辆损坏，就可以用三者险来赔偿。
三者险的保额，建议：一线城市300万起步，二三线城市200万，小城市100万。
3.商业车险怎么买？ 下面，我根据不同保障程度，做了几个车险保障公式，给大家做参考：
方案一 老司机 方案二 新手司机 方案三 家庭预算充足
三、遇险处理步骤 1.判断是否出险 2.出险处理流程 3.多大事故需要走保险？ 4.医药费是否需要垫付 四、闭坑小贴示 拒赔不理赔情况 1.发现车子进水之后，一定不要贸然打火。一旦积水进入气缸导致发动机损伤，保险公司就不赔了（对应涉水险忽略条款） 2.车损三不赔：车轮单独损失、车身划痕、新增加设备（对应盗抢和玻璃险忽略条款） 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3ab9abd373bb23e6cb50b61c9f328f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e15de985f7401f2c2678355d2bd6c04/" rel="bookmark">
			如何从0到1搭建一个SpringBoot项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot是大家使用最多的一个Java框架了，今日就来详细介绍一下如何去创建一个SpringBoot项目
一、准备工作 首先要来看你的IDEA版本，如果你的IDEA是【专业版】的，那么你就无需安装任何的插件，直接就可以创建SpringBoot的项目了但如果你的IDEA版本是【社区版】的话，就需要考虑地仔细一些了，因此此时你需要先去安装以下插件 首先第一个的话是Spring Boot Helper 插件 在你安装好这个插件之后，它的名字就变成了Spring Initializr and Assistant 二、正式创建SpringBoot项目 接下来我们来创建 Spring Boot 项⽬了
1、创建一个新项目 如果你是英文版的，就在这里选择New -&gt; Project... 如果你是中文版的，就在这里选择新建 -&gt; 项目... 接下去就会跳出来选项了，这里我们选择Spring Initializr，在右侧读者记得选择正确的JDK版本，此处推荐JDK8，但如果你是JDK17的也没有关系
然后就选择要创建项目的源地址即可，默认这里我们使用到的是官网默认的数据源start.spring.io，但如果官方的这个数据源挂了，也不用担心，我们还可以使用阿里巴巴的国内源start.aliyun.com去创建，点下下面的 Custom即可（不推荐，有兼容性问题）
2、项目参数设置 接下里点进去呢就是具体的项目参数设置了此处我们主要修改的地方就两个：
是这个【Project Types】，一定要选择Maven第二个呢则是这个【Java version】，对应这你前面所选择的JDK版本，如果你前面选择的是JDK17的话，此处也选JDK17；如果前面选择的是JDK8的话，此处也选JDK8 3、添加项目依赖 接下去我们就要添加项目依赖了，首先我们要关注的地方就是这个SpringBoot的版本：
如果你前面选择的是JDK8的话，那么在这里你只能选择2.0开头的版本但如果你前面选择的是JDK17的话，那么在这里便可以支持3.0开头的版本 接下来我们就要去添加各项依赖了，想要去完整地做出一个项目，此处我们必须要添加的依赖有以下四个：
MySQL Driver —— 用于支持MySQL的数据库驱动SpringBoot DevTools —— 用于热部署Lombok —— 简化 Java 代码,减少样板代码,提高开发效率Spring Web —— 让当前的框架变成HTTP框架的依赖 4、项目存储与启动 当添加好各项依赖之后，我们就可以设置当前项目的存储路径了，不过要注意的是项目名称和路径中不能出现任何和中文相关的信息
接下来一进去，你可以可能会遇到各种各样的问题，我们来一一解说一下
首先第一个：你在点开DemoApplication是可能会看到其左下角有一个橙色的j的图标，这表明IDEA还没有把当前的项目识别为是Maven项目，此时我们就需要加载对应的Maven依赖 此时我们就需要添加框架的支持Add Framework Support
在点进去之后，选择Maven然后打勾即可
接下去如果读者碰到的是下面这样的情况的话，就是出现了Maven国内源的问题 对于这个问题我在之前的博客中有过介绍，读者可以去看看 链接
有蓝色c小图标代表项目加载好了 然后我们进入到启动类DemoApplication，点击【运行】即可
在项目启动起来之后，我们可以看到有一个很大的Spring标志，然后看到底部以ms为单位的数字便可以观察出后台已经启动了( •̀ ω •́ )y
5、测试与运行 在一切都配置好之后，我们就可以写一些代码来测试一下了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e15de985f7401f2c2678355d2bd6c04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b43c1ba67f802437f78432b26ebb8f4e/" rel="bookmark">
			【Spring】SpringBoot 配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是配置文件SpringBoot配置文件配置文件快速入手配置文件的格式properties 配置文件说明properties 基本语法读取配置文件信息properties 配置格式缺点 yml 配置文件说明yml 基本语法使用 yml 连接数据库 yml 使用进阶yml 配置不同数据类型配置对象配置集合配置Map 设置不同环境的配置文件YML优缺点 什么是配置文件 配置文件是一种文本文件，通常用于存储程序的参数和设置。它包含了程序运行所需的各种选项和配置信息，例如界面风格、服务器连接信息、默认语言等。这些信息可以通过键值对的形式表示，也可以使用特定的语法和结构描述更复杂的配置信息。
配置文件通常由程序在启动时读取和解析，以自定义程序的行为。例如，在网站开发中，网站的配置文件通常包含了数据库连接信息、安全性设置、日志记录等重要信息。在操作系统中，配置文件则可以用于指定各种系统参数，如网络连接、设备驱动程序等。
配置文件的格式和内容因程序而异，常见的配置文件格式包括INI文件、XML文件、JSON文件等。INI文件是最早的配置文件格式之一，它使用简单的键值对语法来存储配置信息。XML和JSON文件则更加灵活和可扩展，可以描述更复杂的配置信息。
除了使用传统的文本编辑器手动编写配置文件外，现在也有许多工具可以帮助用户轻松地编辑和管理配置文件。例如，一些应用程序具有自己的配置文件编辑器，用户可以通过界面来直观地编辑配置信息。另外，一些配置管理工具则可以帮助用户自动化地管理和维护配置文件，例如版本控制、备份和恢复等。
SpringBoot配置文件 SpringBoot⽀持并定义了配置⽂件的格式，也在另⼀个层⾯达到了规范其他框架集成到SpringBoot的⽬的。
很多项⽬或者框架的配置信息也放在配置⽂件中，⽐如：
项目的启动端口数据库的连接信息（包含用户名和密码的设置）第三⽅系统的调⽤密钥等信息⽤于发现和定位问题的普通⽇志和异常⽇志等 每个 Spring 项目都内置了一个 Tomcat 服务器，而 Tomcat 默认使用的端口是 8080，如果 8080 端口被占用或者多个 Spring 项目同时启动的话，就会出现某些程序无法正常启动的情况，所以这时候就可以使用 Spring 的配置文件修改启动的端口。
不仅如此，在日常生活中我们很多时候都会和数据库打交道，而每个人甚至一个人的不同机器上的数据库用户名、密码和 IP 地址都是有区别的，那么当这个项目交给别人的时候就需要在 Spring 配置文件中修改相关的配置。
不仅如此，一些公共的属性以及会根据情况而改变的属性都可以放在这个 Spring 配置文件中，通过使用 Spring 配置文件可以帮助我们解决很多的问题。
配置文件快速入手 我们先通过一个简单的例子来了解配置文件的作用。
我们创建 SpringBoot 项目的时候，会自动生成一个 application.properties 文件，这就是默认的 SpringBoot 配置文件，我们在这个配置文件中修改启动端口号看看结果。
server.port=9090 这里可以看到启动端口号修改成功了。
如果我们想要访问这个项目就不能使用 127.0.0.1:8080 了，而要使用 127.0.0.1:9090 地址了。
配置文件的格式 SpringBoot 的配置文件有三种形式：
application.propertiesapplication.ymlapplication.yaml yml 是 yaml 的缩写，两个使用方式是相同的。并且这两个配置文件还是生活中使用频率最高的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b43c1ba67f802437f78432b26ebb8f4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf7fc5b2972827415ad64de48ea7d82/" rel="bookmark">
			【摄影基础】镜头分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相机镜头如何分类？
依据不同标准，我们可以将镜头分为不同类别，最常提到的便是根据镜头是否可以变焦而分为定焦与变焦镜头；根据焦距，又可以将镜头分为广角、标准、长焦、微距、鱼眼、移轴镜头等，小编本文主要就是详细介绍一下各镜头的区别。
1.按照镜头是否可以变焦分类 1.1定焦镜头 指的是在拍摄过程中镜头的焦距固定不可变的镜头，需要靠改变拍摄位置来变换远近。其不足之处在于定焦镜头焦距无法变换，焦段单一，因此在拍摄时，只能靠拍摄者的移动来完成不同拍摄距离景物的构图取景。不过，也正是因为这焦距的固定，使得厂商可以将更多精力和成本投入到定焦镜头的成像画质上面。所以通常，焦段相同的镜头中，定焦镜头的成像质量往往要优于变焦镜头。同时，定焦镜头还具有光圈大、体积小、重量轻、最近对焦距离近等特性。
1.2变焦镜头 焦距可以随意改变，在旅行途中拍摄不同场景照片时会比较方便，同时也省去了更换镜头的时间，不过在成像质量上，会比相同焦距的定焦镜头略逊。
2.按照镜头的焦段分类 2.1广角镜头 通常用于拍摄诸如风光、建筑、人像等题材。
是指在135规格中，焦距在17-35mm的镜头。广角镜头所呈现的视角要比同等条件下人眼的视角更加广阔。使用广角镜头，可以表现出更大的清晰范围，并且可以夸张景物间的透视关系，从而有助于给整个画面带来更强的震撼和感染力。
2.2标准镜头 通常用于纪实与人像题材的拍摄。
一般是指在135规格中，焦距在40-60mm的镜头。之所以称之为“标准”，是因为其所表现的景物透视关系与人眼十分相近；标准镜头的这种特性对用户的拍摄技术提出了更高的要求，如果使用不佳，有可能拍摄的照片会比较平淡。
2.3长焦镜头 通常用于拍摄人像、新闻纪实、动物、体育等题材。
比标准镜头焦距长的镜头都可以称为长焦镜头，它能将远处物体拉近，压缩景深，制造虚化的背景，从而使拍摄对象主体更加突出。长焦镜头比较适合用于拍摄特写画面。
另外，在长焦镜头中，镜头焦距为85-300mm的摄影镜头为普通远摄镜头，300mm以上的镜头为超远摄镜头。
2.4微距镜头 通常用于花卉、静物、生态昆虫、美食等题材。
是一种专门用来捕捉细微对象的镜头。微距镜头具有高分辨率、高反差、低像差以及色彩还原准确等特点。在使用其进行拍摄时，可以更好地表现拍摄对象的细节和质地。另外，为了能够拍摄到微小的物体，微距镜头还拥有着比其他种类镜头都要强的近摄能力。
2.5鱼眼镜头 通常用于艺术或创意摄影。
是指在135规格中，焦距在6-16mm的短焦距超广角摄影镜头。一般情况下，这种镜头的前镜片都会呈抛物线状向镜头前部凸出，与鱼的眼睛颇为相似，所以称之为鱼眼镜头。由于超短焦距所造成的强烈变形效果，鱼眼镜头所呈现的景象是圆形或曲面的，这种视觉效果具有很强的超现实性和趣味性。
2.6移轴镜头 通常用于建筑摄影。
此类镜头可以通过移动光轴调整透视效果，其主要作用在于可以纠正透视变形，调整焦平面位置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70aa8e760f6cd47c3d6c4616dbb3b71b/" rel="bookmark">
			C复习-查缺补漏-更新中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Q ：
编写一条scanf语句，读取两个整数，保存至quantity和price，再读取一个字符串，保存至字符数组department中
scanf("%d %d %s", &amp;quantity, &amp;price, department); Q ：
while( gets( input ) != NULL ) {}这句代码可能出现什么问题？
如果输入行很长，input数组会溢出。使用fgets并提供数组长度是更好的选择。
Q ：
编写程序，从标准输入读取再打印到标准输出中，并在每行前面加上行号。需要保证输入行的长度没有限制。
因为不限制行长度，所以使用getchar，另外判断行尾。
int main() { int ch; int line = 0; // 行号 int at_beginning = 1; // 表示是否在开头 while ((ch = getchar()) != EOF) { // 先打印行号 if (at_beginning == 1) { printf("%d ", line); line += 1; at_beginning = 0; } // 打印字符 putchar(ch); if (ch == '\n') at_beginning = 1; } return 0; } Q ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70aa8e760f6cd47c3d6c4616dbb3b71b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a74406e350a6864112dba7a4b7733b8/" rel="bookmark">
			怎样查询oracle被锁的表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查询引起了锁表的原因
select l.session_id sid,
s.serial#,
l.locked_mode,
l.oracle_username,
s.user#,
l.os_user_name,
s.machine,
s.terminal,
a.sql_text,
a.action
from v$sqlarea a, v$session s, v$locked_object l
where l.session_id = s.sid
and s.prev_sql_addr = a.address
order by sid, s.serial#;
2.查询被锁的表
select b.owner,b.object_name,a.session_id,a.locked_mode from v$locked_object a,dba_objects b where b.object_id = a.object_id 3.查看是哪个session引起的
select b.username,b.sid,b.serial#,logon_time from v$locked_object a,v$session b where a.session_id = b.sid order by b.logon_time 4.杀掉对应进程即解锁
alter system kill session'100,57' --其中100是sid 57是serial#
备注：该用户必须拥有DBA权限，否则提示找不到表和视图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba60d7d562e0807c223f1ad5df0cfc09/" rel="bookmark">
			因吹斯汀！只需上传照片，GPT-4V精准识别食物的卡路里和摄入热量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		健身和减肥的朋友有福啦！
最近一篇文章探索了GPT-4V在膳食评估领域的强大能力，可以根据饮食图片精准判断食物的种类与重量，并给出营养成分的分析，包括碳水化合物、蛋白质、脂肪占比。
最最重要的是，它还能告诉我们这些食物的卡路里是多少，这对于我们减肥的朋友来说可是超级重要的！
你可以上传吃之前和吃之后的图片，GPT-4V可以轻松判断摄入了多少热量。
比如提供这两张图片：
给模型一些任务提示：
识别提供的图像中的食物类型，包括食用前和食用后。使用周围的对象作为近似分量大小的参考。为每一类食物的摄入量提供合理的克数估计。请注意，这些食品来自加纳和肯尼亚。
输出结果：
为了估算份量，我将使用杯子和盘子作为参考，假设盘子是标准的餐盘大小，直径约为10-12英寸。以这些物体为尺度，我们可以做出以下估计: 食物1（炸鱼）：初始份量约400克；消费份量约300克。食物2（淀粉类配菜，可能是banku或fufu）：初始份量约300克；消费份量约250克。食物3（番茄酱）：初始份量约150克；消费份量约75克。食物4（洋葱片）：初始份量约50克；消费份量约20克。
看看营养成分呢：
计算一下300g炸鱼、250gbanku、75g番茄酱和20g洋葱片的营养成分，包括碳水化合物、蛋白质、脂肪和卡路里。请以下列格式列出结果:碳水化合物:[g]，蛋白质:[g]，脂肪:[g]，卡路里:[千卡]。
输出：
300克炸鱼包括0克碳水化合物，78克蛋白质，33克脂肪，606千卡的热量。250g的banku含有120g碳水化合物，4.5g蛋白质，1g脂肪，527.5千卡热量。75g番茄酱，包含3g碳水化合物，0.75克蛋白质，0.225克脂肪，15千卡的热量。20g洋葱片含有1.8克碳水化合物、0.22克蛋白质、0.02克脂肪和8千卡热量。
它还能像个营养小贴士一样，告诉我们饮食中缺少了哪些营养，并给出合理的建议。这样我们就可以更好地调整自己的饮食。
这顿饭缺少什么营养，吃什么来补充呢?
输出：
根据您提供的图片，这顿饭包括米饭和鸡肉，这可能提供了大量的碳水化合物、蛋白质和脂肪。然而，它似乎缺乏一些纤维和维生素：纤维：没有可见的蔬菜或水果，而这些是提供膳食纤维所必需的。为了增加纤维摄入量，可以考虑加一份混合蔬菜或新鲜沙拉。维生素和矿物质：新鲜水果和蔬菜也是维生素和矿物质的重要来源。乳制品或钙源：没有乳制品或其他富含钙的食物。可以从牛奶，奶酪，酸奶，或钙强化植物选择一份增加钙含量。
看着还挺像那么回事，有了GPT-4V督促，就不用担心一不小心吃多啦！
但上面只是一些例子参考，GPT-4V在膳食评估方面的准确性到底如何呢？本文的作者还进行了多个数据维度的详细定量分析，让我们一起来了解一下吧！
论文标题:
Dietary Assessment with Multimodal ChatGPT: A Systematic Analysis
论文链接:
https://arxiv.org/pdf/2312.08592.pdf
实验数据 作者使用了居住在伦敦的肯尼亚和加纳裔成年人的饮食摄入数据。为每位参与者分配了eButton或AIM摄像机被动记录他们的饮食摄入量。使用标准化的Salter breknell体重秤记录食物初始重量和吃饱后剩余的食物重量。配备经验丰富的营养师作为人工评估基准，与GPT-4V的结果进行比较。
实验结果 食物检测能力 首先来看看GPT-4V能否准确识别食物的类别。
作者对比了是否包含食物来源信息的提示下的模型性能。从结果可以看出，指明食物来源可以显著提高语言模型的能力，准确识别特定文化的食物，**准确率达到了87.5%**，相比不说明食物来源提高了十几个点。
当食物来源未指定时，GPT-4V经常错误将白色淀粉类食物误分类为米饭。当说明了食物来自肯尼亚或加纳时，模型能准确将食物识别为banku或ugali，这是传统的非洲食物。
食物分量估计 下图展示了三种方法包括GPT-4V、人眼估计和基准真值对食物分量的估计，图中观察到的趋势表明，GPT-4V的预测通常与基准真值非常接近。
作者进一步使用绝对误差的度量来比较GPT-4V和人类估计。GPT-4V的估计的平均绝对误差为54.6g。相比之下，人类估计准确性稍微更高一些，平均绝对误差为43.6g。但也说明GPT-4V的表现与人类非常接近。
营养成分估计 在估算出食物分量之后，作者利用GPT-4V模型将食物的重量转化为特定的营养数据，重点关注关键的膳食成分：碳水化合物，蛋白质，脂肪和卡路里。获取的结果与真实值进行比较。
下表展示了10个不同膳食的分量和营养成分估计误差。可以看到，营养估计的准确性在很大程度上取决于分量估计的准确性。
下图显示了GPT-4V预测32种食物的碳水化合物、蛋白质、脂肪和卡路里含量的预测结果，并与真实值进行对比，可以看出，GPT-4V预测的趋势在大部分食物上与真值一致。
处理低可见图像的能力 本文还突显了GPT-4V处理低可见度图像（如在黑暗环境中拍摄的图像）的能力。
在光线暗的地方，如果没有足够的语境提示，GPT-4V可能倾向于会把食物当成米饭或面包这类常见的食物。但是，当我们给了它一些关于食物来源的信息时，它就能准确地识别出来，比如banku和ugali这种传统的非洲食物。
结论 本文分析了GPT-4V在膳食评估中的潜力。即使在没有使用特定食物数据集进行微调或适应的情况下，GPT-4V在食物检测方面准确率高达87.5％。另外GPT-4V可以利用周围的物体作为比例参考来推断食物项目的份量大小，进一步提高将食物重量转化为营养含量的准确性。
虽然GPT-4V很强大，但还不能完全解决复杂的空间关系和精确空间分析任务。比如，它对于估算食物的体积或分量不太准确，因为这需要三维感知能力，超出了它的能力范围。在本文的实验中发现它对重量不到30g的食物类别难以准确估计。
即便如此，它的表现也几乎达到了人类水平。期待未来版本的GPT-4V能更稳健，为我们提供更准确的膳食摄入评估。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2a5f6106bfdc457943deec24ac99a1/" rel="bookmark">
			Windows域（域服务器的配置、加入域）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows域
目录
一、AD基本概念
二、AD相关概念
三、域结构
四、域功能级别和林功能级别
五、工作组和域的主要区别
六、配置Windows域
Active Directory：活动目录服务
在早期的时候，所有的计算器都是独立的个体（每台计算机都有自己的用户或组），想要统一管理，在企业中部署活动目录服务器，从而对企业中的所有用户及计算机进行集中管理，这种区别于工作组的逻辑环境称为windows域；域是组织与存储资源的核心管理单元。
部署域环境
一、AD基本概念 1、概述
活动目录（Active Directory）是面向Windows Standard Server、Windows Enterprise Server以及 Windows Datacenter Server的目录服务。面向Windows服务器中的目录服务Active Directory不能运行在Windows Web Server上，但是可以通过它对运行Windows Web Server的计算机进行管理。Active Directory存储了有关网络对象的信息，并且让管理员和用户能够轻松地查找和使用这些信息。Active Directory使用了一种结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻辑的分层组织 2、功能
服务器及客户端计算机管理：管理服务器及客户端计算机账户，所有服务器及客户端计算机加入域管理并实施组策略。用户服务：管理用户域账户、用户信息、企业通讯录（与电子邮件系统集成）、用户组管理、用户身份认证、用户授权管理等，按省实施组管理策略。资源管理：管理打印机、文件共享服务等网络资源。桌面配置：系统管理员可以集中的配置各种桌面配置策略，如：用户使用域中资源权限限制、界面功能的限制、应用程序执行特征限制、网络连接限制、安全配置限制等。应用系统支撑：支持财务、人事、电子邮件、企业信息门户、办公自动化、补丁管理、防病毒系统等各种应用系统集中管理：主要将网络中的计算机逻辑上组织到一起集中管理可扩展性：活动目录具有强大的可扩展性，它可以随着公司或组织的增长而一同扩展，允许从一个网络对象较少的小型网络环境发展成大型网络环境便携地访问网络资源：活动目录允许用户一次登录网络就可以访问网络的所有该用户有权限访问的资源。并且，用户访问网络资源时不必知道资源所在的物理位置。活动目录允许快速、方便地查找网络资源，如用户、组、计算机、共享文件夹等。 二、AD相关概念 1、Active Directory
AD是Windows server中的一种服务AD是一个目录数据库，被用来存储用户账户、计算机账户、打印机与共享文件夹等对象，而提供目录服务的组件就是AD域服务器，它负责目录数据库的存储、添加、删除、修改与查询等工作 2、域
活动目录的一种实现形式，主要由域控制器和成员计算机组成活动目录是最核心的管理单位 3、域控制器（DC）
域控制器就是安装了活动目录的一台计算机（一般为Windows server）活动目录的数据都存储在域控制器内一个域可以有多台域控制器 4、名称空间（DNS域名空间）
是一个区域的名字（在DNS上新建的一个区域）定位了网络资源（域名资源）的位置 5、对象和属性
对象由一组属性组成，它代表的是具体的事物属性就是用来描述对象的数据 6、容器（组织单位、域）
是一种特殊的活动目录对象作用是存放对象的空间 7、域组策略（GPO对象）
若干策略的集合应用到容器会影响容器内所有的计算机和用户 三、域结构 域的组成：物理结构、逻辑结构
物理结构：侧重于活动目录的配置和优化
逻辑结构：侧重于网络资源的管理
1、逻辑结构
单域：在网络中只建立了一个域域树：具有连续域名空间的多个域（ying.com du.ying.com）域林：由一个或者多个没有形成连续域名空的域树组成(duyun.com ying.com )组织单位：域内部的一种容器（用于存放对象） 2、物理结构
站点：可以将高速连接的网络中多台域控制放入一个站点（一个站点必须一个GC 全局边路服务器） 站点是一个物理范围，对应高速稳定的ip子网，如企业内部的局域网。
一个域的域控制器分布在不同的站点中，而站点之间是慢速连接，由于不同站点的域控制器之间会互相复制AD DS数据库，因此要谨慎规划执行复制的时段，尽量在离峰时段执行复制工作，频率不要过高，避免复制时占用站点之间的连接带宽，影响站点之间其他数据的传输效率
一个站点中可以包含多个域，一个域也可以包含多个站点。
同一个站点内的域控制器之间是通过快速链路连接在一起的，在复制AD DS数据时，可以实现快速复制。AD DS会设置让同一个站点内、隶属于同一个域的域控制器之间自动执行复制操作，默认的复制频率也要高于不同站点之间的域控制器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f2a5f6106bfdc457943deec24ac99a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82bd90283d586ea67ee73b25b6f1ab81/" rel="bookmark">
			pip 安装lxml编译失败处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装环境 Ubuntu 20.04
错误信息 note: This error originates from a subprocess, and is likely not a problem with pip. ERROR: Failed building wheel for lxml Running setup.py clean for lxml Failed to build lxml ERROR: Could not build wheels for lxml, which is required to install pyproject.toml-based projects 处理方案 先安装依赖包
sudo apt-get install libxml2 libxslt-dev 重新安装lxml
pip install lxml==4.2.5 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9118617041781322352290e1ff61a64f/" rel="bookmark">
			MySQL运维实战（1.3）安装部署：源码编译安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：俊达
引言 在大多数情况下，我们不需要自己编译MySQL源码，因为编译的MySQL和二进制包的内容基本一致。然而，有些特殊情况可能需要我们采用源码编译的方式安装MySQL：
安装非标准版本的MySQL：有些特殊的应用场景会使用到MySQL的非标准版本，这时候我们就需要编译源码来安装。安装社区的patch、bugfix、扩展插件：通过源码编译，可以轻松地添加社区提供的补丁、修复程序和扩展插件，以满足特定需求。禁用二进制版本中的某些特性：源码编译可以让用户选择禁用或启用某些特定功能，以满足自己的需求。使用未编译的功能：有些功能可能在二进制版本中并没有被编译进去，而通过源码编译可以启用这些功能。使用其他编译器优化插件：源码编译可以让用户选择使用其他编译器进行编译，或者进行一些个性化的优化设置。例如，如果我们想要使用Intel的C编译器。链接一些其他基础库：源码编译可以允许用户链接其他基础库，例如使用tcmalloc等。编译debug版本：通过源码编译可以生成debug版本的MySQL，用于调试和分析问题。 因此，了解MySQL源码编译安装对于学习MySQL运维来说，确实是非常有帮助的。这不仅可以帮助我们更好地理解MySQL的工作原理，还可以让我们在面对一些特殊需求时，能够更加灵活地处理。
1 下载源码 https://downloads.mysql.com/archives/community/
选择对应版本的源码包并下载
[root@box1 software]# wget https://downloads.mysql.com/archives/get/p/23/file/mysql-boost-5.7.32.tar.gz --2021-03-29 05:50:54-- https://downloads.mysql.com/archives/get/p/23/file/mysql-boost-5.7.32.tar.gz 正在解析主机 downloads.mysql.com (downloads.mysql.com)... 137.254.60.14 正在连接 downloads.mysql.com (downloads.mysql.com)|137.254.60.14|:443... 已连接。 已发出 HTTP 请求，正在等待回应... 302 Found 位置：https://cdn.mysql.com/archives/mysql-5.7/mysql-boost-5.7.32.tar.gz [跟随至新的 URL] --2021-03-29 05:50:55-- https://cdn.mysql.com/archives/mysql-5.7/mysql-boost-5.7.32.tar.gz 正在解析主机 cdn.mysql.com (cdn.mysql.com)... 184.27.193.3 正在连接 cdn.mysql.com (cdn.mysql.com)|184.27.193.3|:443... 已连接。 已发出 HTTP 请求，正在等待回应... 200 OK 长度：52882168 (50M) [application/x-tar-gz] 正在保存至: “mysql-boost-5.7.32.tar.gz” 100%[================================================================================================================================================================================&gt;] 52,882,168 2.76MB/s 用时 22s 2021-03-29 05:51:17 (2.32 MB/s) - 已保存 “mysql-boost-5.7.32.tar.gz” [52882168/52882168]) [root@box1 software]# md5sum mysql-boost-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9118617041781322352290e1ff61a64f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64872eb452a158cf34c55336406ba6d7/" rel="bookmark">
			linux命令详解及软件安装(全)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境搭建
环境搭建(Vmware)
账号管理
开机关机
目录管理
文件颜色
文件权限
文件操作(touch、cat、tac、more、less、grep、wc、vim)
压缩操作
磁盘管理(iostat、sar、df、du)
内存管理(free)
CPU管理(top)
进程管理(ps)
开发管理(nohup)
防火墙管理
进阶小故事之CPU深夜狂飙
进阶小故事之轻松分析定位JVM问题
交互工具
环境安装
环境搭建
第一种方式：直接安装Linux操作系统 (会替换掉现有系统)
第二种方式：本机电脑安装成双系统 (windos linux)
第三种方式：虚拟机(VMware下载(360一键安装))
[注]虚拟机搭建环境有两种方式：
a. 下载镜像进行安装
b. 可以使用他人已制作好的镜像
安装VMware虚拟机软件好后打开镜像即可使用
第四种方式：购买云服务器 (有经济来源的话可以购买阿里云服务器，因为这才是最接近公司中原生环境的)
环境搭建(Vmware)
安装Vmware
创建虚拟机
创建新的虚拟机
选择自定义（高级）
VMware建立虚拟机分为典型（快速）和自定义（高级）两种方式
选择硬件的兼容性
选择安装创建的虚拟机的操作系统
选择你所要安装的客户机操作系统
选择操作系统的版本
更改虚拟机的名称和存放的位置
选择虚拟机具备的引导设备类型
指定处理器数量
为虚拟机预设多少内存
选择虚拟机的网络类型
配置本机网络适配器环境
进入 “控制面板”——“网络和Internet”——“更改适配器设置”
选择VMnet8是配置器，右键选择“属性”，选择“Ipv4”，如下图：
配置Vm网络连接
进入虚拟网络编辑器
由于安装VMware虚拟机后是没有网络的，因此我们还需要手动对VMware虚拟机配置网络，选择虚拟机左上方的“编辑–&gt;虚拟网络编辑器”
配置虚拟网络地址
VMnet信息 （虚拟机网络信息）
桥接模式
需要依赖外部网络环境，VMware 虚拟出来的操作系统就像是局域网中的一台独立的主机，需要手工为虚拟系统配置IP地址，虚拟机的ip必须和宿主机(Windows)的ip是同一个网段。相当于虚拟机和主机就好比插在同一台交换机上的两台电脑，虚拟机需要占用一个真实ip
NAT模式
使用 NAT 模式，就是让虚拟系统借助 NAT（网络地址转换）功能，通过宿主机器所在的网络来访问公网，如果主机能够正常上网，那么虚拟机也能够直接上网。此时虚拟机处于一个新的网段内，由VMware提供的DHCP服务自动分配IP地址，然后通过VMware提供的NAT服务，共享主机实现上网, 不依赖外部网络环境
仅主机模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64872eb452a158cf34c55336406ba6d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd3caa0f4461d393c3971823c10c20ea/" rel="bookmark">
			OSPF部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OSPF 部分 一、基本配置 1.1、OSPF原理概述 ​ OSPF是一种应用广泛的基于链路状态的动态协议，它具有区域（area）化的层次结构，扩展性好，收敛速度快，适合各种规模的网络。
​ OSPF中，每台路由器都必须有一个Router ID来标识自己。为了使网络稳定可靠，路由器都会使用Loopback接口的IP地址作为自己的Router-ID。
OSPF的网络类型
广播网络（Broadcast网络）NBMA网络点到点（p2p网络）点到多点（p2mp） 在广播网络和NBMA网络中，需要选举出DR和BDR
选取规则如下：
选取接口优先级高的接口优先级相同选取Router-ID最高的 1.2、OSPF的介绍及历史 OSPF(开放式最短路径优先):基于链路状态的AS内部的IGP（内部网关协议）。
在OSPF出现之前，内部网关协议都是用RIP，但由于RIP是使用距离矢量算法的路由协议，存在着收敛慢、路由环路、可拓展性差等问题。所以在最终被可全面解决RIP的这些问题的OSPF所取代。
IPv4使用的协议为OSPFv2版本。
IPv6使用的协议为OSPFv3版本。
1.3、OSPF的概念 自治系统（AS）
​ 自治系统就是通常所说的“路由域”，是由同一种路由协议并且被同一组织机构管理的一组路由器组成。
​ 同一个AS中的所有路由器必须运行着相同的路由协议，且必须彼此互联（中间不能被运行着其它路由协议的设备所分割）分配相同的AS号。
Area
​ 将多个路由器从逻辑上放在同一个区域，每个OSPF就只能在自己所属的area中学习到该区域里面完整的链路状态信息。
1.4、OSPF的路由器、区域类型 OSPF的区域类型：
骨干区域（固定为area0）末梢区域（Stub）没有ASBR，没有虚链路，不能是Area０，屏蔽LSA４／LSA５，由Stub区域的ABR向本区域发送一条指向自己的缺省路由（0.0.0.0），使ABR成为Stub区域与外界通信的唯一出口,只允许有一个ABR。完全末梢区域（Totally Stub）没有ASBR，没有虚链路，不能是Area０，屏蔽LSA3/LSA４／LSA５，由Totally Stub区域的ABR向本区域发送一条指向自己的缺省路由（0.0.0.0），使ABR成为Stub区域与外界通信的唯一出口 ,只允许有一个ABR。非纯末梢区域（NSSA）完全非纯末梢区域（Totally NSSA） 1.5、路由器类型: 区域内路由器（IR）：所有接口在同一个OSPF区域内部。
区域边界路由器（ABR）：路由器的接口可在不同的区域，但是其中一个接口必须连接在骨干区域（area0）上。
自治系统边界路由器（ASBR）：ASBR通常位于AS的边界，但也可以是区域内的设备，同时也可以是ABR。（通常要一台OSPF设备引入外部路由（静态、RIP或者其它路由）的信息，该设备就为ASBR。）
1.6、路由类型 ​ 区域划分的目的：减少LSA的数量，在本区域链路发生改变时，OSPF重新计算的只是本区域内的路由信息。
区域内路由：用于区域内IR路由器之间的路由信息。用于设备间的互联，不向外通告。区域间路由：仅用于区域间ABR之间的路由。用于骨干区域与其他区域互相通告路由信息。第一类外部路由：经ASBR引入的外部路由，且通常为IGP类型（如：静态、RIP、IS-IS或者其他进程的OSPF进程路由）的外部路由，它们的开销计算方法与OSPF的开销计算方法具有可比性，可信度较高。 第一类外部路由开销=本设备到相应的SABR的开销+ASBR到该路由地址的开销
第二类外部路由：经ASBR引入的外部路由，通常是EGP类型（BGP路由）的外部路由，他们的开销计算方式与OSPF的开销计算方式不具有可比性，可信度较低。OSPF认为，从ASBR到自治系统之外的地方开销远远大于在自治系统之内的到达的ASBR的开销。（默认） 第二类外部路由开销=ASBR到该路由目的地址的开销
具体实验：
R1配置
sysname R1 interface GigabitEthernet0/0/1 ip address 10.0.12.1 255.255.255.0 interface GigabitEthernet0/0/2 ip address 10.0.13.1 255.255.255.0 interface LoopBack0 ip address 1.1.1.1 255.255.255.255 interface LoopBack1 ip address 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd3caa0f4461d393c3971823c10c20ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0708cf10b3583ac28ac56b4857585e98/" rel="bookmark">
			Radhat安装Oracle11g
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Radhat安装oracle11g Radhat与Linux简介 linux有三大发行版本（：Slackware、debian、redhat）,而Redhat有收费的商业版和免费的开源版,商业版的业内称之为RHEL系列，CentOS是来自于依照开放源代码规定而公布的源代码重新编译而成。可以用CentOS替代商业版的RHEL使用。两者的不同，CentOS不包含封闭源代码软件，是免费的。
Oracle11g简介 Oracle 11g是甲骨文公司于2007年7月11日推出的数据库软件，Oracle 11g有400多项功能，经过了1500多个小时的测试，开发工作量达到了3.6万人/月，相当于1000名员工连续研发3年。Oracle 11g提供了高性能、伸展性、可用性和安全性，并能更方便地在低成本服务器和存储设备组成的网格上运行,相对过往版本而言，Oracle 11g具有了与众不同的特性。
为什么要在Linux平台运行Oracle 虽然Oracle可以在多平台运行但是一般装在linux下是因为性能比在win下稳定，更有优势。其次oracle运行在Linux下最主要的原因是基于软件的费用的考虑。企业很大一部分原因选择linux是因为linux作为服务器很强，而且很便宜。服务器最强的是Unix，但是很贵。而windows作为服务器，的确不行。
所以一般的企业你看到oracle是安装linux上，供大家使用。
简介在Linux7.5下安装Oracle 11g 安装材料 软件版本： linux.x64_11gR2_database_1of2.zip linux.x64_11gR2_database_2of2.zip 操作系统：redhat 7.5 内核版本： Linux version 3.10.0-862.el7.x86_64 (mockbuild@x86-034.build.eng.bos.redhat.com) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC) ) #1 SMP Wed Mar 21 18:14:51 EDT 2018 1、安装Oracle11g R2的配置要求 最小内存：1G 检查内存大小的命令 内存大小#grep MemTotal /proc/meminfos 交换空间# grep SwapTotal /proc/meminfo 磁盘空间# df -ah 2、关闭系统防火墙以及Selinux 关闭防火墙：systemctl stop firewalld 设置防火墙为开机不启动： systemctl disable firewalld 关闭Selinu 编辑/etc/selinux/config 修改SELINUX=enforcing修改为SELINUX=disabled ！！！修改完毕后重启 修改selinux图 修改主机名，创建所需要的文件夹，以及权限设置 修改主机名 [root@localhost ~]# hostnamectl set-hostname oracle [root@localhost ~]# bash [root@oracle ~]# 创建所需要的组已经用户，进行授权 root@oracle ~]# groupadd oinstall	#创建用户组oinstall [root@oracle ~]# groupadd dba	#创建用户组dba [root@oracle ~]# useradd -g oinstall -g dba -m oracle	#创建oracle用户，并加入到oinstall和dba用户组0 [root@oracle ~]# echo x120952576 | passwd --stdin oracle	#设置Oracle用户密码 创建所需要的目录 [root@oracle ~]# mkdir -p /data/oracle	#oracle数据库安装目录 [root@oracle ~]# mkdir -p /data/oraInventory #oracle数据库配置文件目录 [root@oracle ~]# mkdir -p /data/database #oracle数据库软件包解压目录 [root@oracle ~]# chown -R oracle:oinstall /data/oracle/ [root@oracle ~]# chown -R oracle:oinstall /data/oraInventory/ [root@oracle ~]# chown -R oracle:oinstall /data/database/ #设置目录所有者为oinstall用户组的oracle用户 3、 检查安装Oracle 11g所需要的软件以及依赖包。（参照官方说明） Oracle Linux 7 and Red Hat Enterprise Linux 7必须安装以下软件包（或更高版本）： binutils-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0708cf10b3583ac28ac56b4857585e98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/915d501ea9bbcc0c25e29b355aff589e/" rel="bookmark">
			防火墙配置gre隧道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		防火墙配置gre隧道 gre隧道简介 通用路由封装（GRE: Generic Routing Encapsulation）是通用路由封装协议，可以对某些网络层协议的数据报进行封装，使这些被封装的数据报能够在IPV4网络中传输。简单来说就是，将原数据包进行封装，添加上GRE包头及公网包头，使原报文的 源IP地址及目的IP地址变为公网IP地址，使其能够被运营商的公网路由识别并进行传输。属于VPN 技术的一种，可对不同协议的报文进行完全透明的封装，不改变原报文的任何结构与数据。经常用于路由协议（如OSPF,RIP,BGP等）传输、模拟专线直连等场景。 配置实例 FW1配置 interface GigabitEthernet0/0/7 ip address 192.168.1.1 255.255.255.0 interface GigabitEthernet0/0/8 ip address 1.1.1.1 255.255.255.0 interface Tunnel1 alias Tunnel1 ip address 10.0.0.1 255.255.255.0 firewall zone trust set priority 85 add interface GigabitEthernet0/0/0 add interface GigabitEthernet0/0/7 firewall zone untrust set priority 5 add interface GigabitEthernet0/0/8 firewall zone dmz set priority 50 add interface Tunnel1 ip address 10.0.0.1 255.255.255.0 ip route-static 192.168.2.0 255.255.255.0 Tunnel1 FW2配置 interface GigabitEthernet0/0/7 ip address 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/915d501ea9bbcc0c25e29b355aff589e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fef5546d915d2a205006ae3d574e1f4c/" rel="bookmark">
			牛津六年级上册英语知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-------------第一单元---------
Her hair was short and her eyes were big.
她的头发很短，她的眼睛很大。
In Photo 1, Sally was a baby. She was about two months old. She was small and cute.
在照片1中，萨莉是一个婴儿。她大约两个月大。她很小并且很可爱。
In Photo 2, Sally was one year old. Her hair was short and her eyes were big.
在照片2中，萨莉一岁。她的头发很短，她的眼睛很大。
In Photo 3, Sally was about six years old. She was a primary school student.
在照片3中，萨莉大约六岁。她是一名小学生。
Now Sally is 14 years old.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fef5546d915d2a205006ae3d574e1f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ead5a9625fca4d02268e6ec9710fba9e/" rel="bookmark">
			CentOS 7.2 搭建ftp服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7.2搭建ftp服务 ftp服务简介 FTP服务器（File Transfer Protocol Server）是在互联网上提供文件存储和访问服务的计算机，它们依照FTP协议提供服务。 FTP是File Transfer Protocol(文件传输协议)。顾名思义，就是专门用来传输文件的协议。简单地说，支持FTP协议的服务器就是FTP服务器。
认证方式 匿名开放模式：任何人无需密码直接登录ftp服务器上 本地用户模式：使用系统本地使用的用户名密码登录ftp服务器 虚拟用户模式：需要ftp服务器建立单独的用户数据库文件，使用虚拟出来的用户信息来进行认证。 CentOS 7 搭建ftp服务器 一、准备工作 关闭selinux
关闭系统防火墙（firewalld）
配置网络
配置本地yum 源
二、通过yum安装vsftpd yum install -y vsftpd ftp 三、编辑vsftpd的主要配置程序 vsftpd主要配置程序简介 vsftpd的主要配置程序有123行，但是大部分都被注释，没有被注释的参数如下
anonymous_enable=YES #是否以匿名方式访问 local_enable=YES #是否允许本地用户登录ftp write_enable=YES #是否允许写入 local_umask=022	#本地用户上传文件的umask值 dirmessage_enable=YES xferlog_enable=YES connect_from_port_20=YES xferlog_std_format=YES listen=NO #是否以独立运行的方式监听服务 listen_ipv6=YES #监听ipv6地址 pam_service_name=vsftpd #指定PAM的配置文件为vsftpd userlist_enable=YES	#只允许userlist文件中的账号登录 tcp_wrappers=YES 匿名开放模式 安装完vsftpd之后ftp的匿名开放模式默认打开，只用修改配置文件来控制ftp服务器上传，下载，删除等权限。
部分参数:
anonymous_enable=YES 允许匿名访问模式 anon_umask=022 匿名用户上传文件的umask值 anon_upload_enablemYES 允许匿名用户上传文件 anon_mkdir_write_enable=YES 允许匿名用户创建目录 anon_other_write_enable=YES 允许匿名用户修改目录名称或删除目录 将配置写入配置文件之后重启vsftpod
[ rootelinuxprobe ～]# systemctl restart vsftpd [ rootelinuxprobe ~]# systemctl enable vsftpd 1ns'/usr/1ib/systemd/system/vsftpd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ead5a9625fca4d02268e6ec9710fba9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a82529d8f4cbe1aeff6e9cc142cd09c5/" rel="bookmark">
			博客文章系统mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容表
CREATE TABLE `article_content` ( `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增ID tags:{"primary_key":"true"}', `content` text COMMENT 'content 内容', `category` text COMMENT '分类列表', `tags` text COMMENT '标签列表', `genre` int NOT NULL DEFAULT 0 COMMENT '题材', `title` varchar(256) NOT NULL DEFAULT '' COMMENT '文章标题', `abstract` varchar(256) NOT NULL DEFAULT '' COMMENT '摘要', `visbility` bigint NOT NULL DEFAULT 0 COMMENT '可见度', `creator_id` bigint NOT NULL DEFAULT 0 COMMENT '创建人id', `creator` varchar(32) NOT NULL DEFAULT '' COMMENT '创建人', `deleted_at` timestamp NULL COMMENT '删除时间 options:{"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a82529d8f4cbe1aeff6e9cc142cd09c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d7161322890bdec43e84b02c1928b3a/" rel="bookmark">
			Docker部署EMQX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 EMQ X (Erlang/Enterprise/Elastic MQTT Broker) 是基于 Erlang/OTP 平台开发的开源物联网 MQTT 消息服务器。
Erlang/OTP是出色的软实时 (Soft-Realtime)、低延时 (Low-Latency)、分布式 (Distributed)的语言平台。
MQTT 是轻量的 (Lightweight)、发布订阅模式 (PubSub) 的物联网消息协议。
EMQ X 设计目标是实现高可靠，并支持承载海量物联网终端的MQTT连接，支持在海量物联网设备间低延时消息路由:
稳定承载大规模的 MQTT 客户端连接，单服务器节点支持50万到100万连接。分布式节点集群，快速低延时的消息路由，单集群支持1000万规模的路由。消息服务器内扩展，支持定制多种认证方式、高效存储消息到后端数据库。完整物联网协议支持，MQTT、MQTT-SN、CoAP、LwM2M、WebSocket 或私有协议支持。 2、启动emqx 官网连接：https://www.emqx.io/docs/zh/v5.1/deploy/install-docker.html#%E9%80%9A%E8%BF%87-docker-%E8%BF%90%E8%A1%8C%E5%8D%95%E4%B8%AA-emqx-%E8%8A%82%E7%82%B9
docker持久化：https://askemq.com/t/topic/2353
docker链接：https://hub.docker.com/r/emqx/emqx
# docker run -d --name emqx emqx/emqx:v4.0.0 3、复制emqx数据 # mkdir -p mqtt/emqx &amp;&amp; cd mqtt # docker cp emqx:/opt/emqx/data emqx # docker cp emqx:/opt/emqx/etc emqx # docker cp emqx:/opt/emqx/lib emqx # docker cp emqx:/opt/emqx/log emqx 4、授权emqx目录 # chown -R 1000:1000 emqx/ # chmod -R 755 emqx/ 5、配置docker-compose.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d7161322890bdec43e84b02c1928b3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ad0fe63b58436c7d03e535e5036f15d/" rel="bookmark">
			LeetCode 1276. 不浪费原料的汉堡制作方案：鸡兔同笼解方程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【LetMeFly】1276.不浪费原料的汉堡制作方案：鸡兔同笼解方程 力扣题目链接：https://leetcode.cn/problems/number-of-burgers-with-no-waste-of-ingredients/
圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。
给你两个整数 tomatoSlices 和 cheeseSlices，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下：
巨无霸汉堡：4 片番茄和 1 片奶酪小皇堡：2 片番茄和 1 片奶酪 请你以 [total_jumbo, total_small]（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量都是 0。
如果无法使剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量为 0，就请返回 []。
示例 1：
输入：tomatoSlices = 16, cheeseSlices = 7 输出：[1,6] 解释：制作 1 个巨无霸汉堡和 6 个小皇堡需要 4*1 + 2*6 = 16 片番茄和 1 + 6 = 7 片奶酪。不会剩下原料。 示例 2：
输入：tomatoSlices = 17, cheeseSlices = 4 输出：[] 解释：只制作小皇堡和巨无霸汉堡无法用光全部原料。 示例 3：
输入：tomatoSlices = 4, cheeseSlices = 17 输出：[] 解释：制作 1 个巨无霸汉堡会剩下 16 片奶酪，制作 2 个小皇堡会剩下 15 片奶酪。 示例 4：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ad0fe63b58436c7d03e535e5036f15d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dbba5595bd864b0d84ebbabc8a0443c/" rel="bookmark">
			Linux进阶系列（二）——lscpu、htop、seq、shuf、sort
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. lscpu lscpu 命令是Linux系统中用来显示关于CPU架构的信息的工具。它详细展示了CPU的相关信息，包括型号、核心数、架构类型、缓存大小等等。
1.1 物理CPU与逻辑CPU 物理CPU指的是实际存在于硬件系统上的中央处理单元。每个物理CPU都是一个独立的处理器芯片或处理器核心。在多核心处理器中，一个物理CPU可以包含多个核心，每个核心能够独立执行指令。例如，一个四核处理器有四个物理CPU核心，每个都能独立执行任务。
逻辑CPU，又称为虚拟CPU或线程，是超线程技术（Intel的Hyper-Threading技术）的产物。超线程允许每个物理CPU核心模拟两个或更多的逻辑CPU。这样，操作系统会认为有更多的CPU可用于任务，从而可以更有效地管理和调度进程和线程。例如，一个有四个物理核心的处理器，如果启用了超线程，可能会显示为有八个逻辑CPU。
📝 一言以蔽之，物理CPU是能看得见摸得着的，但逻辑CPU是虚拟的。
执行 lscpu 后重点关注以下四行：
CPU(s): 48 Thread(s) per core: 2 Core(s) per socket: 12 Socket(s): 2 其中 Socket(s) 是指物理CPU的数量，因为系统中有两个CPU插槽，每个插槽装有一个物理CPU。Core(s) per socket 表示每个物理CPU中的核心数。Thread(s) per core 是每个核心能够启动的超线程数量。CPU(s) 则是逻辑CPU的个数。不难发现有以下公式成立：
CPU(s) = Thread(s) per core × Core(s) per socket × Socket(s) \text{CPU(s)}=\text{Thread(s) per core}\times \text{Core(s) per socket}\times \text{Socket(s)} CPU(s)=Thread(s) per core×Core(s) per socket×Socket(s)
我们也可以简单执行 nproc 命令来查看逻辑CPU的个数。
2. top与htop 2.1 top ps（process status）命令和 top（table of processes）命令都用于显示运行在Unix/Linux操作系统上的进程信息。不同之处在于，ps 显示一次性的进程信息，它捕捉的是命令执行时刻的快照，而 top 则显示持续更新的进程信息，它会不断刷新显示，提供实时的系统状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dbba5595bd864b0d84ebbabc8a0443c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f337b7b4a738d2a6e0cfd1e60d00aa41/" rel="bookmark">
			运维工程师的出路到底在哪里？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/bin/bash 运维工程师的出路到底在哪里？ 你是不是也常常听到身边的运维人员抱怨，他们的出路到底在哪里呢？别着急，让我告诉你，运维人员就像是IT界的“万金油”，他们像“修理工”一样维修服务器，像“消防员”一样应对突发故障，还像“魔术师”一样优化系统性能。无论是云计算、物联网还是人工智能，运维人员都将在技术发展的道路上继续闪耀光芒！
当前运维行业的趋势 运维行业正在经历着一场深刻的变革，新技术、新理念、新模式不断涌现，给运维带来了机遇和挑战。根据国内外权威机构和媒体的分析和预测，我们可以总结出以下几个主要的趋势：
云计算和自动化的发展。 云计算已经成为IT基础设施建设和管理的主流选择，越来越多的企业将业务系统部署在公有云、 私有云或 混合云上，享受云服务带来的灵活性、可扩展性和低成本。同时，云计算也推动了自动化技术的发展，通过使用各种自动化工具和平台，实现基础设施、配置、部署、测试、监控等环节的自动化，提高运维效率和质量。 2. DevOps和敏捷开发 的普及。 DevOps是一种软件开发和交付的理念和方法，强调开发（Dev）和运维（Ops）之间的紧密协作和持续交付。敏捷开发是一种 软件开发过程，强调快速响应变化和满足客户需求。DevOps和敏捷开发都是为了适应市场变化和用户需求而诞生的，它们要求运维人员与开发人员紧密配合，实现快速迭代和反馈，提升 软件交付速度和质量。 3. 容器化和微服务的兴起。 容器化是一种 虚拟化技术，可以将应用程序及其依赖打包成一个轻量级、可移植、可隔离的容器，方便在不同环境中部署和运行。微服务是一种 软件架构风格，可以将一个复杂的应用程序拆分成多个小型、独立、可复用的服务，每个服务都有自己的职责和接口，通过轻量级的 通信协议进行交互。 容器化和微服务的兴起使得应用程序更易于部署、扩展和维护，同时也促进了团队的协作和软件开发的快速迭代。 4、AI大模型的兴起，对于运维工作人员面临新的挑战！ AI大模型时代，低代码能力人员被逐步代替，尤其是当前就业环境、宏观因素的影响，整体环境不如以前那么火热，这就需要运维人员不断提高自身的核心竞争力，以能在这时代的发展而不落后于太多！ 5、国产化的推进，国产化之路，势在必行！ 很久之前，就一直在提国产化，在适应国产化，包括信通院等各行各业也都在做国产化，这条路我们走的很长、也很远、但是出来的产品、实际的使用效果来看，相比于其他开源软件，依旧相差甚远、但并不是一无所获，进步是最大的收获，从无到有、从0到1，这是一个艰难的过程，需要各位一起努力！ 革命尚未成功，同志仍需努力！ 运维人员的技能要求，不仅仅是掌握一些基本的 操作系统、网络、数据库、脚本等知识，还需要具备一些高级的技能，以适应不断变化的运维环境和需求。 技术方面 云计算和自动化技能。 运维人员需要熟悉各种云平台的操作和管理，如腾讯云、阿里云、 华为云、AWS等，能够利用云服务提供的资源和功能，实现业务系统的快速部署、扩展和迁移。同时，运维人员也需要掌握各种自动化工具和平台，如Ansible、Puppet、SaltStack等，能够实现基础设施、配置、部署、测试、监控等环节的自动化，提高运维效率和质量。 2. DevOps和敏捷开发技能。 运维人员需要了解DevOps和敏捷开发的理念和方法，能够与开发人员紧密协作，实现快速迭代和反馈，提升软件交付速度和质量。同时，运维人员也需要掌握一些开发相关的技能，如版本控制（Git）、 持续集成（Jenkins）、代码审查（Code Review）、单元测试（Unit Test）等，能够参与软件开发的全过程，并保证软件的可运行性和可维护性。 3. 容器化和微服务技能。 运维人员需要熟悉容器化技术，如Docker、Kubernetes等，能够将应用程序及其依赖打包成一个轻量级、可移植、可隔离的容器，方便在不同环境中部署和运行。需要熟悉 微服务架构，能够将一个复杂的应用程序拆分成多个小型、独立、可复用的服务，运维人员需要能够管理和监控这些微服务，并保证它们之间的协调性和一致性。 4. 数据分析和大数据技能。 运维人员需要具备一定的数据分析能力，能够收集、处理、分析各种数据，如 系统日志、性能指标、用户行为等，从中发现问题、优化方案、提升效果等。同时，运维人员也需要掌握一些大数据相关的技术，如Hadoop、Spark、Elasticsearch等，能够处理海量数据，并提供实时或离线的分析结果。 5、国产化之路，势在必得！ 一定要提高自己的认知水平、要走自己国家之路，科学无边界、 但是科学家有国籍之分！要不然前任也不会专心研究独属于咱自己国家的高精技术、都需要有一颗爱国之心，有国才有家！树牢忧患意识、敌特就在身边！ 管理方面 管理方面，运维人员需要具备以下几方面的技能：
沟通协作技能。 运维人员需要能够与各个部门和角色进行有效的沟通和协作，包括但不限于：开发、测试、产品、客户、供应商等。 运维人员需要能够清晰地表达自己的想法和需求，理解他人的意图和反馈，及时地沟通和解决问题和冲突，建立良好的信任和合作关系。 2. 团队建设技能。
运维人员需要能够组建和带领一个高效、稳定、协作的运维团队，包括但不限于：招聘、培训、激励、考核、调配等。运维人员需要能够根据团队的目标和任务， 合理地分配和调整人员和资源，提升团队的执行力和战斗力，营造一个积极、健康、有序的工作氛围。 3. 项目管理
运维人员需要规划和管理各种运维项目，包括但不限于：部署、发布、变更、优化和升级等。我们需要根据项目的目标和范围，制定合理的计划和预算，分析和控制项目的风险和质量，监督和跟进项目的进度和状态，并确保项目按时按质按量完成。
4. 资源调配技能。
运维人员需要合理地调配各种运维资源，包括但不限于：硬件、软件、网络和存储等。他们需要根据业务的需求和变化，动态地分配和回收资源，优化资源的利用率和性价比，避免资源的浪费和紧缺。
5. 风险控制技能。
运维人员需要预防和应对各种可能发生的风险，包括但不限于：攻击、故障和灾难等。他们需要制定并执行有效的风险管理策略，如备份、恢复、监控和预警等。运维人员需要快速地识别和定位风险事件，采取恰当的应急措施，尽快恢复业务的正常运行。
业务方面 关于运维人员在业务方面需要具备的技能，以下几个方面是需要重点关注的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f337b7b4a738d2a6e0cfd1e60d00aa41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3aec0565b791dd9b5f301554effa365/" rel="bookmark">
			python风格规范之missing whitespace after
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python风格规范之missing whitespace after 规范错误/警告描述规范错误描述(示例)规范错误认知正确示例 规范错误/警告描述 PEP 8: E231 missing whitespace after '[mark]' 规范错误描述(示例) 规范错误认知 上述规范错误表示"[mark]"后面没有添加空格 。错误示例如下：
这里的冒号、逗号后面均需要添加空格~
正确示例 Reference \text{Reference} Reference：
python - 风格规范
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db3122ef47b2a20416c01ce40034f35/" rel="bookmark">
			python风格规范之do not compare types, for exact checks use `is` / `is not`, for instance chec
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python风格规范之do not compare types 规范错误/警告描述规范错误描述(示例)规范错误认知正确示例 规范错误/警告描述 PEP 8: E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()` 规范错误描述(示例) def check_type(input_message): if type(input_message) == str: print("{} is a string.".format(input_message)) else: print("{} is not a string.".format(input_message)) 规范错误认知 关于type不要做比较，更希望使用is/is not做精确的判断。也可使用方法isinstance()进行替代。
正确示例 # 正确示例1 def check_type(input_message): if type(input_message) is str: print("{} is a string.".format(input_message)) else: print("{} is not a string.".format(input_message)) # 正确示例2 def check_type(input_message): if isinstance(input_message,str): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7db3122ef47b2a20416c01ce40034f35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67c4e25c9b0a34914c19c88fbec24d7d/" rel="bookmark">
			新版IDEA中Git的使用（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：前面介绍了在新版IDEA中Git的基本操作、分支操作，本文介绍一下在新版IDEA中，如何回滚代码；
分以下三个阶段来介绍：
未Commit的文件；
已经Commit，但未push的文件；
已经push的文件；
未Commit 对于未Commit的文件，回滚代码，可以在Commit窗口，选中文件，鼠标右键，选择Rollback，即可回滚代码，恢复到未修改状态；
弹出窗口，选择Rollback
文件恢复到未修改状态的黑色；
而对于新增的文件，直接在Commit界面里删掉即可，当然，也可以选中，点Rollback，但文件会加入到未追踪状态，还是会出现在IDEA中，就不如直接删除掉。
未push 比如，我新增了一个文件、修改了一个文件，提交了，但是还没有push到远程仓库（可以看到分支名后面有箭头），此时我想回滚这次提交；
可以选择这次提交前面的提交，鼠标右键，点击Reset Current Branch to Here，表示将代码回滚到这次提交的状态；
点击后，会出现下面几种模式，选择如何处理回退的文件；
Soft：修改的文件、新增的文件都恢复到暂存区；
Mixed（默认）：修改的文件加入到暂存区，新增的文件恢复到未追踪；
Hard：修改的文件、新增的文件都丢失，并且当前分支未commit的文件也恢复（新增的删掉，修改的恢复原样）；
Keep：修改的文件、新增的文件都丢失，当前分支未commit的文件，新增的文件恢复到未追踪，修改的文件保持原样；
可以根据自己的需要进行选择，选择前想清楚，回退的这部分代码是怎么来的：
如果是push的，那么应该选择Soft、Mixed，避免回退后代码丢失；
如果是pull的，那么应该选择Hard、Keep，避免多出来的代码，影响自己分支；
回滚未push的代码，除此之外，还有以下几种：
Undo Commit…：回滚最近一次提交；
Revert Commit：回滚某一次提交，并留下回滚记录；
Drop Commit：回滚某一次提交，并不留下回滚记录；
以上操作，均是单次操作的回滚，即仅回滚此次操作的文件，例如A提交创建了文件，B提交修改了文件，如果回滚A提交，B提交中修改的文件就不存在了，就会发生冲突。
已push 例如现在，我将新增的代码，add.txt文件push到远程仓库。push上去后发现这段代码有问题，或者我想修改一下comment内容；
可以这么做，首先回滚本地的提交；
修改代码或者修改Comment信息后，再push
这次选择Push下面的这个操作，Force Push；
选择Force Push
远程仓库的代码就被本次push冲掉了；
已经push的提交不推荐使用回滚，建议修改代码、文件后重新push一次。如果该分支有其他同事在push代码，上面这种方法可能会冲掉同事push的代码，有风险。
总结 本文介绍在新版IDEA中Git关于回滚的操作，参考B站UP主【小陈努力码代码】的视频 IDEA小技巧-Git的回滚&amp;&amp;强推&amp;&amp;代码找回
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da89534337343ab82e9b7894d94cd8b5/" rel="bookmark">
			思科模拟器(SDN控制器使用教程二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思科模拟器(SDN控制器使用教程二) 写在前面：
笔者在2021年5月份发布了一篇关于思科模拟器SDN控制器的使用教程，得到了大家的喜欢，这是笔者更新这篇文章的动力。在以后只要是有时间笔者就会多更新一点关于这方面的文章，和大家一起学习SDN相关技术。笔者技术能力有限，可能不是特别专业，如果在文中有什么错误，希望大家能够指出，笔者也希望和大家一起进步。在过去的两年里，笔者经历了一些生活的变故，以为不会在从事网络相关行业了，可命运弄人在从校园走出后还是从事了网络相关行业更准确的说是通信相关行业(笔者目前就职于某运营商从事网络、无线、通信相关的工作)。在工作过程中接触到了SD-WAN相关技术，奈何华为目前暂不支持SDN相关的模拟设备，无法和大家分享华为相关的技术。在接下来的日子里笔者也会不断学习来储备自己的知识。目前笔者具有华为HCIP(数通方向)、软考的网络工程师、软考软件设计师、RedHat网络学院认证，在某运行商和浪潮xx公司以及本地几家科技公司从事过运维、等保测评等工作。目前准备学习网络安全方向，如果后面有朋友想在考证方面咨询，也会进行积极的回复，笔者在低谷时得到了许许多多的好心人帮助，也希望自己能够为一些想从事网络方面的朋友提供力所能及的帮助。笔者并非机构，也会不定期更新文章。关于思科的SDN模拟器也更新到此，如果有英文能力好一点的朋友能够更深入的带着大家学习。希望大家不喜勿喷。
一、实验拓扑 ​ 各个设备配置：在各个设备中，配置了一个用户，用户名和密码为：admin、admin。为了后面在Web管理中作为管理设备的凭证。
路由器配置Lo：1.1.1.1路由器配置
hostname Router username admin privilege 15 secret 5 $1$mERr$vTbHul1N28cEp8lkLqr0f/ interface Loopback0 ip address 1.1.1.1 255.255.255.255 interface GigabitEthernet0/0 ip address 10.0.0.1 255.255.255.0 duplex auto speed auto interface GigabitEthernet0/1 ip address 192.168.1.1 255.255.255.0 duplex auto speed auto interface GigabitEthernet0/2 ip address 10.0.1.1 255.255.255.0 duplex auto speed auto router ospf 1 log-adjacency-changes network 192.168.1.0 0.0.0.255 area 0 network 10.0.0.0 0.0.0.255 area 0 network 1.1.1.1 0.0.0.0 area 0 network 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da89534337343ab82e9b7894d94cd8b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e1961f3a3901e11ba7a5a00b6d93288/" rel="bookmark">
			dataloader读取batchsize显示出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题再现 for i, ((inputs_w, inputs_s), targets) in enumerate(data_loader):
就这么一行，显示最后index out of bound；
解决方法 让dataloader丢掉最后一个不足batch size的部分，
DataLoader(dataset, batch_size=1, shuffle=False, sampler=None, num_workers=0, collate_fn=default_collate, pin_memory=False, drop_last=True) 参考 [1] PyTorch中Torch.utils.data的DataLoader加载数据时batch_size变了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4d148953ea7c0e8b779aa79b042baf4/" rel="bookmark">
			免费内网穿透pve
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 因为前一段时间买了一个n3150的itx主板，装pve系统，用来all in one，但是因为资金有限，没有足够的经济实力去申请公网IP，所以只能采用内网穿透的方式来远程访问了。
工具选择【目前免费】 官方链接地址：
Solopace.Gem
linux安装教程 Linux中心服务器安装教程
手动安装客户端 （1）复制下列命令道linux命令行中：
curl -fsSL https://solopace.doaction.pro/download/sh/install.sh | sh 如果报错Syntax error: “(“ unexpected
参考教程：【Shell】sh执行脚本报错Syntax error: “(“ unexpected
原文解释： 代码对于标准bash而言没有错，因为Ubuntu/Debian为了加快开机速度，用dash代替了传统的bash，是dash在捣鬼，解决方法就是取消dash。
解决办法：
sudo dpkg-reconfigure dash 在选择项中选No就行了
（2）复制命令至中心服务器并执行，会自动生成链接
（3）复制加入网络地址至浏览器，登录
（4）选择网络并加入网络
至此，可以通过组网IP+端口号进行访问pve，不加端口号是无法进入的。
如果需要进入pve里面的各种系统【例如：群辉、青龙等】，进行如下的步骤：
（5）开启路由转发
开启路由转发后可使用内网IP直接访问PVE及其PVE同局域网的其他设备，其他设备不需要安装Solopace.Gem
按照如下进行配置：【在pve下的命令行运行】
退出当前服务 solopacegem down 重启服务并开启路由转发通道 solopacegem up --advertise-routes=192.168.31.0/24 --accept-dns=false --accept-routes=true --reset 打开路由转发状态 （6）访问
在需要访问的电脑上下载对应的安装包进行安装操作。
https://solopace.doaction.pro/
因为我用的是win7系统，所以我演示win7系统的操作，win8及以上的系统自行找对应的版本进行安装。
安装过程：略。
点击图标，右键，选择加入新的网络
网络ID的位置如下：
点击图标，右键，切换网络，选刚才新加入的网络。
至此，两个设备已经连通，可以通过内网IP进行访问。
实例：
教程到这里就结束了，教程很简单，希望能帮助到需要帮助的人，感谢大家的阅读。
参考链接 参考教程：
使用免费内网穿透工具随时随地访问PVE（Proxmox Virtual Environment）
【Shell】sh执行脚本报错Syntax error: “(“ unexpected
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269e89f7e88e0249c64837ae84d9a391/" rel="bookmark">
			网页微信扫码登录，以及redirect_uri参数错误解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫码登录 流程：首先是生成二维码，二维码对应的 url 中包含一个回调地址，在用户同意授权之后，将会在你的回调 url 上拼接参数 code 并且跳转，跳转之后前端从 url 中获取 code，调用接口发送给后端，后端用 code 去获取所需要的信息即可
扫码页面
引入微信封装好的js
// 引入微信封装好的 js &lt;script src="https://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js"&gt;&lt;/script&gt; 创建二维码容器，加载微信二维码
// 微信二维码容器 &lt;div class="impowerBox"&gt; &lt;div class="wx_dialog_toiast_delltet" id="login_container"&gt;&lt;/div&gt; &lt;/div&gt; // 加载二维码 var DDNS_resolution = encodeURIComponent("http:127.0.0.1:8080/index"); new WxLogin({ self_redirect: false, //该参数决定回调方式。默认是false,即授权后,整个页面发生跳转,true时,只有iframe嵌套部分发生跳转 id: "login_container", // 需要承载二维码的容器id appid: "wx*********", scope: "snsapi_login", // 网页授权，目前网页只有这一种方式，静默授权 redirect_uri: DDNS_resolution, // 授权后跳转路径，请使用urlEncode对链接进行处理 state: Math.random(), // 可防止csrf攻击 style: "black", //自定义样式链接，第三方可根据实际需求覆盖默认样式，可将写好的css文件转为base64放在这里 href: "data:text/css;base64,LmltcG93ZXJCb3ggLnRpdGxlIHsNCiAgICBkaXNwbGF5OiBub25lOw0KfQ0KLmltcG93ZXJCb3ggLnFyY29kZS5saWdodEJvcmRlciB7DQogICAgd2lkdGg6IDIwMHB4Ow0KfQ==", }); ps：二维码的样式可以自定义，href属性就是设置自定义样式链接的，我们可以将自定义的样式写在css文件里面，并把这个文件转为base64值后作为href的属性值，就可以覆盖原本的默认样式。
css样式
.impowerBox .title { display: none; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/269e89f7e88e0249c64837ae84d9a391/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25acfa60ddea64877441ccf928a29494/" rel="bookmark">
			《Spring Cloud Gateway 技术要点》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文文档 1、Spring Cloud Gateway 中文文档
它是如何工作的 1、它是如何工作的
12种路由谓词 12种路由谓词
1、Route Predicate（路由谓词）工厂
三种过滤器执行顺序 1、三种过滤器执行顺序
常见问题 1、深入解析spring cloud gateway】09 巨坑！GlobalFilter的执行顺序
2、Spring Cloud Gateway 过滤器执行顺序原理分析
Gitee优秀代码 1、jiang88 / flying-fish-gateway
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/067d0e3a47f90fc08d9ad4288b6887f1/" rel="bookmark">
			Rexroth HDS3.2-W100N-HS32-01-FW伺服驱动器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rexroth HDS3.2-W100N-HS32-01-FW 是一个用于控制和监测液压系统的伺服驱动器。它具有以下优势和应用场景：
优势：
高性能：该驱动器采用先进的数字信号处理技术和控制算法，能够实现高精度的位置、速度和力矩控制。紧凑设计：该驱动器体积小、重量轻，易于集成到各种液压系统中，减小了系统的整体尺寸和重量。可靠性：该驱动器具有较高的稳定性和可靠性，能够在恶劣的工业环境中长时间稳定运行，减少故障率。灵活性：该驱动器支持多种不同的液压泵和电机类型，可以适应不同的液压系统和控制需求，具有较高的灵活性。可扩展性：该驱动器可以与各种上位控制器、传感器和执行器进行连接和集成，方便系统升级和扩展。 应用场景：
数控机床：用于控制机床的进给轴、主轴等，提高加工精度和效率。工业机器人：用于控制机器人的关节运动，实现高精度、快速响应的运动轨迹。包装机械：用于控制机械臂、传送带等，实现高效、准确的包装作业。压机：用于控制压机的液压系统，实现高精度、高效率的压制作业。船舶、航空航天领域：用于控制船舶的推进系统、航空航天器的起落架等，提高系统的稳定性和安全性。 总之，Rexroth HDS3.2-W100N-HS32-01-FW 伺服驱动器是一种高性能、高可靠性和高灵活性的液压伺服控制系统，能够为各种工业自动化控制系统提供可靠的驱动解决方案。如需了解更多信息，建议咨询专业人士或厂家。
Rexroth HDS3.2-W100N-HS32-01-FW is a servo driver used for controlling and monitoring hydraulic systems. It has the following advantages and application scenarios:
Advantages:
High performance: The driver adopts advanced digital signal processing technology and control algorithms, which can achieve high-precision position, speed, and torque control.
Compact design: The driver has a small volume, light weight, and is easy to integrate into various hydraulic systems, reducing the overall size and weight of the system.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/067d0e3a47f90fc08d9ad4288b6887f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a5ef852beb90781a5d51767adad500f/" rel="bookmark">
			国外大学生都用FPGA做什么项目（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看看国外大学的FPGA开发项目
据我了解，目前国内很多大学是没有开设FPGA相关课程的，所以很多同学都是自学，但是自学需要一定的目标和项目，今天我们就去看看常春藤盟校Cornell University 康奈尔大学开设的FPGA项目课程，大部分课程是有源码的，而且和国内使用习惯类似都是Verilog开发，还是很有借鉴意义的。
之前的文章请查看《国外大学生都用FPGA做什么项目（一）》《国外大学生都用FPGA做什么项目（二）》。
项目链接 https://people.ece.cornell.edu/land/courses/ece5760/FinalProjects/
项目介绍 Spring 2019 youtubeCycloneV SoC FPGA PokerBot-FPGA加速的扑克机器人 构建了一个基于 FPGA 加速的蒙特卡洛模拟的限注德州扑克机器人。
给定玩家的一手牌和公共牌，它每秒模拟大约 200 万手牌，并确定该手牌获胜的概率。我们的系统能够实现显着的硬件加速。它的运行速度比 ARM 硬处理器系统 (HPS) 上的（未优化的）C++ 版本快约 4000 倍，比 Intel i7-6700HQ 笔记本电脑处理器上的 C++ 版本快约 10 倍。
项目介绍
https://people.ece.cornell.edu/land/courses/ece5760/FinalProjects/s2019/asd222_jng55_mys29/asd222_jng55_mys29/asd222_jng55_mys29/index.html
项目介绍hackaday
https://hackaday.com/2019/05/16/pokerbot-uses-fpga-for-card-calculating-horsepower/
视频链接
https://youtu.be/utOuXsdpRrQ
代码链接
https://people.ece.cornell.edu/land/courses/ece5760/FinalProjects/s2019/asd222_jng55_mys29/asd222_jng55_mys29/asd222_jng55_mys29/index.html
Simulink Workflow: ODE Solver on DE1-SoC-Simulink 工作流程：DE1-SoC 上的 ODE 求解器 该项目的目标是探索在 Intel-DE1-SoC 上实现系统的替代方法。英特尔和 MathWorks 合作推出了一套设计工具，旨在将 MATLAB* 和 Simulink* 开发的系统模型与英特尔® FPGA 和 SoC 无缝集成。
使用 MATLAB 和 Simulink 进行系统建模、算法开发、可视化和高级调试的工程师可以轻松实现英特尔 FPGA上工程开发。此外，他们还可以保证生成的代码将得到优化并准备好部署和生产。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a5ef852beb90781a5d51767adad500f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e17903f46a123a533b3a23c7952dc007/" rel="bookmark">
			好物周刊#33：手写公式识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/cunyu1943/JavaPark https://yuque.com/cunyu1943 村雨遥的好物周刊，记录每周看到的有价值的信息，主要针对计算机领域，每周五发布。
一、项目 1. 森林 一款现代化的知识社区后台项目，使用 SpringBoot + Shiro + MyBatis + JWT + Redis 实现。支持如下特性：
浏览帖子回帖货币发帖登录注册内容编辑器 2. 星云 一款现代化的知识社区前台项目，使用 Vue + NuxtJS + Element-UI 实现，和森林是互为前后端的关系，两者搭配使用效果更佳。
3. GB/T 7714—2015 相关的 CSL 样式 GB/T 7714 相关的 csl 以及 Zotero 使用技巧及教程，写论文文献管理必备！
二、软件 1. AnyTXT Searcher 一款功能强大的文件内容搜索应用程序，就像本地磁盘 Google 搜索引擎一样，并且比 Windows 搜索和 Windows findstr 命令快得多。Anytxt 是您最好的桌面文件内容全文搜索引擎和最好的 Google 桌面搜索替代品。
2. Bandizip 一个强大的多功能压缩文件管理工具，可提供很快的解压缩速度和其他各种实用功能。
支持的主要功能如下：
支持的操作系统: Windows 7/8/8.1/10/11 (32bit/64bit/arm64)集压缩/解压/浏览/编辑为一体的压缩包管理器可以提取包括 RAR/ISO/7Z/ZIP 在内的 30 多种格式可以创建拥有密码和压缩分卷的压缩包支持多个的处理器核心进行高速的解压缩操作对 Windows 11 上下文菜单的支持 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e17903f46a123a533b3a23c7952dc007/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/49/">«</a>
	<span class="pagination__item pagination__item--current">50/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/51/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>