<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7559c681a52cee53a46582839e234596/" rel="bookmark">
			实现扫码登录的前端技术解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 随着移动互联网的发展，扫码登录已经成为了一种常见的登录方式。用户只需使用手机App扫描二维码即可快速登录，避免了输入账号密码的繁琐过程。在本文中，我们将通过使用JavaScript，实现一个简单的扫码登录功能。
步骤 生成二维码 首先，我们需要使用第三方库来生成二维码。在JavaScript中，可以使用qrcode.js库来生成二维码。具体使用方法可以参考该库的文档。后端生成登录标识 当用户扫描二维码后，我们需要后端生成一个唯一的登录标识，并将其存储到数据库中。这个登录标识将用于后续的登录验证。前端轮询检查登录状态 前端页面需要定时向后端发送请求，查询当前用户是否已经完成登录操作。可以使用setInterval函数来定时发送请求，并根据后端返回的登录状态进行相应的处理。后端登录验证 当用户扫描二维码后，后端需要验证用户的登录操作。可以通过将登录标识与用户信息进行关联来进行验证。前端登录成功处理 当用户成功完成登录后，前端页面会收到后端返回的登录成功消息。此时，我们可以根据需要进行跳转或者其他相应的操作。 示例代码 在这个示例中，我们假设已经生成了一个名为qrcode的div元素，并引入了qrcode.js库。
// 生成二维码 var qrcode = new QRCode("qrcode", { text: "https://example.com/login", width: 128, height: 128 }); // 轮询检查登录状态 setInterval(function() { // 发送请求，查询登录状态 fetch("/checkLoginStatus") .then(function(response) { return response.json(); }) .then(function(data) { if (data.status === "success") { // 登录成功，进行相应操作 window.location.href = "/dashboard"; } }); }, 3000); 结论 通过以上步骤，我们成功地使用JavaScript实现了扫码登录功能。这种登录方式简化了用户登录的流程，提高了用户体验。在实际应用中，我们可以根据需求进行扩展和优化，例如添加错误处理、增加登录超时机制等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/708494adc58ed49dff107c2f04d5ea99/" rel="bookmark">
			js实现短信验证码一键登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 短信验证码一键登录是一种方便快捷的登录方式，用户只需输入手机号码，然后接收到手机短信验证码并自动填入验证码框，即可完成登录操作。本文将介绍短信验证码一键登录的原理，并给出一个简单的示例说明。
短信验证码一键登录的原理 用户输入手机号码：用户在登录界面输入手机号码，并点击获取验证码按钮。发送验证码：前端通过API向后端发送请求，后端生成随机的6位数字验证码，并通过短信平台将验证码发送到用户的手机上。验证码验证：用户收到短信验证码后，前端自动填充验证码，并通过API向后端发送请求进行验证。登录成功：如果验证码验证通过，后端返回登录成功的信息，前端则跳转至登录成功页面。 短信验证码一键登录的实现示例 下面以JavaScript为例，给出一个简单的实现短信验证码一键登录的示例代码：
// 前端代码 function sendVerificationCode() { let phoneNumber = document.getElementById("phoneInput").value; // 发送请求给后端，请求发送短信验证码 axios.post("/sendVerificationCode", { phoneNumber }) .then(response =&gt; { // 短信验证码发送成功的处理逻辑 console.log(response.data); }) .catch(error =&gt; { // 短信验证码发送失败的处理逻辑 console.error(error); }); } function login() { let phoneNumber = document.getElementById("phoneInput").value; let verificationCode = document.getElementById("codeInput").value; // 发送请求给后端，验证短信验证码 axios.post("/verifyCode", { phoneNumber, verificationCode }) .then(response =&gt; { // 短信验证码验证成功的处理逻辑 console.log(response.data); window.location.href = "/loginSuccess"; }) .catch(error =&gt; { // 短信验证码验证失败的处理逻辑 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/708494adc58ed49dff107c2f04d5ea99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e20ffc62aef0ff3408520a12b9ea7275/" rel="bookmark">
			【大数据之Kafka】十六、Kafka集成外部系统之集成Flume
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flume 是一个在大数据开发中非常常用的组件。可以用于 Kafka 的生产者，也可以用于 Kafka 的消费者。
Flume安装和部署：https://blog.csdn.net/qq_18625571/article/details/131678589?spm=1001.2014.3001.5501
1 Flume生产者 （1）在hadoop102启动Kafka集群。
zk.sh start kf.sh start （2）在hadoop103启动Kafka消费者。
bin/kafka-console-consumer.sh --bootstrap-server hadoop102:9092,hadoop103:9092 --topic first （3）在hadoop102上安装Flume：https://blog.csdn.net/qq_18625571/article/details/131678589?spm=1001.2014.3001.5501 第一章Flume安装部署。
（4）在/opt/module/flume-1.9.0/job目录下创建配置文件file_to_kafka.conf。
# 1 组件定义 a1.sources = r1 a1.sinks = k1 a1.channels = c1 # 2 配置 source a1.sources.r1.type = TAILDIR a1.sources.r1.filegroups = f1 a1.sources.r1.filegroups.f1 = /opt/module/applog/app.* a1.sources.r1.positionFile = /opt/module/flume/taildir_position.json # 3 配置 channel a1.channels.c1.type = memory a1.channels.c1.capacity = 1000 a1.channels.c1.transactionCapacity = 100 # 4 配置 sink a1.sinks.k1.type = org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e20ffc62aef0ff3408520a12b9ea7275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fed3927b366a30c44197e18e60328c39/" rel="bookmark">
			Android Studio Debugger一直卡在collecting data
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 某次升级AS后，debug时想要查看某个对象的具体数据时一直卡在collecting data，很难受！
解决方案 在调试区域的空白处右键-&gt;选中Mute Renders即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/109838fa62b5cae241906f7098eaa2fd/" rel="bookmark">
			【Android Activity】IntentFilter的匹配规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动 Activity 分为两种，显式调用和隐式调用。显式调用需要明确指出被启动组件的包名类名。隐式调用需要 Intent 能够匹配目标组件的 IntentFilter 中所设置的过滤信息，如果不匹配将无法启动目标 Activity
一、IntentFilter 简介 意图过滤器的意思manifest文件中activity标签的子标签。IntentFilter 的过滤信息（子标签）有 action、category、data 1、IntentFilter 注意点 1、一个activity下可能有多个intentfilter，一个intent只要能匹配任何一组intentFilter下的信息便可成功启动activity。
2、一个intentFilter中action 、category、data都可以有多个。
3、想要隐式开启activity 必须在intentFilter添加 &lt;category android:name=“android.intent.category.DEFAULT” /&gt;
二、Action规则 1、系统定义了一些Action字符串 &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;action android:name="android.intent.action.VIEW"/&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 2、我们也可以自定义Action字符串 &lt;activity android:name=".ActivityC"&gt; &lt;intent-filter&gt; &lt;action android:name="com.example.test" /&gt;//添加自定义字符串即可 &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 3、Action匹配规则 1、intentFilter中的action可以有很多，只要intent添加的action和intentFilter中其中一个action匹配即可
2、action区分大小写，大小写不同的字符串是不同的action。
3、intentFilter 至少要有一个action
4、栗子 Intent intent = new Intent(); intent.setAction("com.example.test"); //intent 添加action。匹配intent-filter 下的一个action即可成功打开activity startActivity(intent); &lt;activity android:name=".ActivityC"&gt; &lt;intent-filter&gt; &lt;action android:name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/109838fa62b5cae241906f7098eaa2fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c1dc88dda72c15acd47e955d673d9ee/" rel="bookmark">
			charles maplocal时 手机上显示乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：windows 现象：非maplocal时没有问题，maplocal时所有手机都乱码
过程：.ini文件，rewrite设置，ssl proxying settings 都没用
解决：文件采用英文命名，且去掉文件后缀就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce1f740ca5ba719d6ed088174a16e2a/" rel="bookmark">
			demo0921
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		demo0921
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/845782345df55e152c478a6f05fffd61/" rel="bookmark">
			01项目一键启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目启动 后端 1.gitee克隆拉取:https://gitee.com/zhongzhibinbin/MallChat.git
2.环境配置
active: test 在mallchat-common项目的application.yml文件中设置运行的环境，改成test。
实现多环境，可以随时切换环境
3.配置微信公众号环境信息
#内网8080穿透的地址 mallchat.wx.callback=http://6a5xx84.r5.xxxxx.top mallchat.wx.appId=wxafxxxxxxxa5a2ce # 接口配置里的Token值，自己随意设置 mallchat.wx.token=lilxxxxr 前端 1、gitee克隆拉取：https://gitee.com/Evansy/MallChatWeb.git
2、下载node.js，版本高于v18.16.0
3、下载pnpm
4、修改前端访问接口,全局搜索api.mallchat.cn
//.env.development文件，修改本地地址 VITE_API_PREFIX=http://localhost:8080 VITE_WS_URL=ws://localhost:8090 5、前端项目下载依赖
进入vscode终端
pnpm install 问题，无法加载文件pnpm.ps1
解决：管理员身份打开，PowerShell
6、运行前端项目
pnpm run dev 点击链接，可以访问服务器提供的后端项目。
每次修改前端代码，直接在vscode按F5就会重新部署并且打开新页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/225080ddb31423d33ea18d7f7a77b16e/" rel="bookmark">
			JS系列第七弹：JS基础之this
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一， this的含义 一， this的含义 什么是this this是一个关键词，意为这儿，这个，这里。在浏览器中，全局的this指向的是window 而node.js中 this指向的是 global 首先，在学习this之前，让我们先了解一下this绑定的五种 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13a99b36d05d2be0a7ffbf4ed42b7172/" rel="bookmark">
			Android开发使用webView出现一些网页加载不出来，或者卡在加载界面解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这些权限全部要加上，就所有网页都能出现了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ace7a2b823761f727e0ff1023d37d5/" rel="bookmark">
			Java 格式化之 %d，%2d， %02d 的差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 中由 int 型返回字符串时，经常用 String.format 方法，传入 %d，%2d， %02d 类似参数，记录下这些参数的含义。
String.format 传入 %XYd 的意思，拆解如下，
%d ：正常输出十进制数 。%Yd：十进制数，输出 Y 位。如果本身大于 Y 位，正常输出。%XYd：十进制数，输出 Y 位，不足 Y 位就补 X 。如果本身大于 Y 位，正常输出。 以 %d，%2d， %02d 为例，
%d：十进制数正常输出 。%2d：十进制数，输出 2 位。不足 2 位就补空格 。如果本身大于 2 位，正常输出。%02d ：十进制数，输出 2 位，不足 2 位就补 0 。如果本身大于 2 位，正常输出。 示例，
public class TestFormat { public static void main(String[] args) { long k = 5; System.out.println(String.format("%d",k)); System.out.println(String.format("%2d",k)); System.out.println(String.format("%02d",k)); System.out.println(String.format("%03d",k)); } } 结果，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9ace7a2b823761f727e0ff1023d37d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57e2660f4dfebbf45749debaba24cc01/" rel="bookmark">
			数据解析之Xpath解析（超详细定位）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
前言
一.Xpath介绍
1.基本介绍
2.HTML树状结构图
2.节点之间的关系
Xpath中的绝对路径与相对路径
绝对路径
相对路径
二.Xpath的语法介绍
基本定位语法
1.元素属性定位
2.层级属性结合定位
3.使用谓语定位
4.使用逻辑运算符定位
5.使用文本定位
6.使用部分函数定位
三.Xpath语法验证
在开发者工具的 Elements 中按Ctrl + F，在搜索框中输入 Xpath
四.lxml的基本使用
五.Xpath实战（含流程）
前言 xpath是XML路径语言，它可以用来确定xml文档中的元素位置，通过元素路径来完成对元素的查找。HTML就是XML的一种实现方式，所以xpath是一种非常强大的定位方式
一.Xpath介绍 1.基本介绍 XPath（XML Path Language）是一种XML的查询语言，他能在XML树状结构中寻找节点。XPath 用于在 XML 文档中通过元素和属性进行导航
xml是一种标记语法的文本格式，xpath可以方便的定位xml中的元素和其中的属性值。lxml是python中的一个第三方模块，它包含了将html文本转成xml对象，和对对象执行xpath的功能
2.HTML树状结构图 HTML 的结构就是树形结构，HTML 是根节点，所有的其他元素节点都是从根节点发出的。其他的元素都是这棵树上的节点Node，每个节点还可能有属性和文本。而路径就是指某个节点到另一个节点的路线。
2.节点之间的关系 父节点(Parent)： HTML 是 body 和 head 节点的父节点；
子节点(Child)：head 和 body 是 HTML 的子节点；
兄弟节点(Sibling)：拥有相同的父节点，head 和 body 就是兄弟节点。title 和 div 不是兄弟，因为他们不是同一个父节点。
祖先节点(Ancestor)：body 是 form 的祖先节点，爷爷辈及以上👴；
后代节点(Descendant)：form 是 HTML 的后代节点，孙子辈及以下👶。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57e2660f4dfebbf45749debaba24cc01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/849f40b8982f1ebd7721d5ce8b446205/" rel="bookmark">
			【Flink】 Upsert 乱序问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink SQL Upsert 出现乱序问题如何解决？分析、优化建议 1. 业务问题2. 乱序和解决方案 2.1 乱序原因2.2 解决方案说明 3. 乱序问题现状 1. 业务问题 在使用 Flink SQL 订阅 Upsert 数据更新时，在某些情况下，如关联的表够多，并行度够大，可能会有概率出现数据乱序问题。
如果数据汇的存储是有 upsert 行为存储引擎，如 es，会导致部分数据丢失，影响数据的准确性。
在订单大宽表业务中，偶尔会接到某订单数据无法在 es 中查询，经添加日志排查，发现，某个订单维表数据发生变更，最后 -D 事件和 +I 事件发生了乱序，在进入 es 时，先执行了 +I 事件，再执行了 -D 事件，于是，es 数据丢失。
2. 乱序和解决方案 2.1 乱序原因 Flink SQL 的数据在向下游传递时，会按照 join key 的值的 hash，shuffle 到特定的算子上，因此，这个算法保证相同的 join key 能有序地被处理。
如果，这个 join key 不是 unique key 的话，且刚好这个 join key 发生变更，就会先后发出一个包含旧 join key 值的 -D 事件和有新 join key 值的 +I 事件，两个事件被 shuffle 到不同的算子并行计算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/849f40b8982f1ebd7721d5ce8b446205/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0694775d9874b0b3ffcb37b8db3ff1d2/" rel="bookmark">
			awk的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 awk是什么？awk的语法awk内置变量例子awk输出第一列计算有多少行..计算带以wp开头的行有多少分别计算带wp开头的行和以mask开头的行有多少awk删除第一列最后一列为2的行，第三列+3，不为2的行，直接输出 awk是什么？ AWK 作为三剑客之一，是一种处理文本文件的语言，是一个强大的文本分析工具。awk可以把文件逐行读入，然后以设置的分隔符(默认为空格)， 切开的部分再进行各种分析处理。
之所以叫 AWK 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。
awk的语法 awk [选项参数] 'script' var=value file(s) 或 awk [选项参数] -f scriptfile var=value file(s) 其中script以pattern+action组成，并且awk中还可以使用变量以及控制语句进行高级的处理，具体而言(选项参数见)1：
awk '{pattern + action}' {filenames} #行匹配语句 awk '' 只能用单引号 pattern是awk在数据中查找的内容action是找到匹配内容后的操作filenames表示处理的文件 下图描述了 AWK 的工作流程:
Created with Raphaël 2.3.0 开始 执行BEGIN程序块 从文件流中读取一行 在该行中指定awk的命令 是否到达文件末尾? 执行END程序块 yes no BEGIN和END是两个特殊的模式，不属于常规的(pattern), 它们是用来在awk程序执行之前或之后执行特定的操作的语句块。
BEGIN块：在awk程序执行之前，会先执行BEGIN语句块中的代码。通常在BEGIN语句块中进行一些初始化的操作，例如设置变量的初始值、打印程序的头部信息等。END块：在awk程序执行完后，会执行END语句块中的代码。通常在END语句中执行一些总结性的操作，例如统计计算结果，打印最终的输出信息等。 这两个语句块的位置是固定的，可以在awk程序中只出现一次，并且不需要与其他的模式进行匹配。
大致为：
awk 'BEGIN {print "开始处理数据"} {total += $1 } END {print "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0694775d9874b0b3ffcb37b8db3ff1d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c1abe043b5062565fd43f0e24ffb9b8/" rel="bookmark">
			Maven 设置环境变量（Windows、Linux）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Windows 配置 Maven 环境变量Linux 配置 Maven 环境变量 如果想在任意路径下都能通过 mvn 命令运行 Maven 程序，就需要将 Maven 程序路径设置到环境变量中，
否则使用 mvn 命令时每次都要加上 Maven 程序的全路径
核心就一句话，把 Maven 的 bin 目录路径追加到系统环境变量 Path 中
使用 Maven 程序前，需要先配置好 Java 的环境变量
Windows 配置 Maven 环境变量 1. 按 Win + R 打开运行窗口，然后输入 sysdm.cpl
2. 选择 高级 页，然后选择 环境变量
3. 在系统变量表格中选择 Path ，然后选 编辑
4. 选择 新建，把 Maven 程序路径添加进去，
Maven 程序路径：Maven 安装目录\bin
5. 按 Win + R 打开运行窗口，输入 cmd
6. 输入命令 mvn -version ，测试环境变量是否测试成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c1abe043b5062565fd43f0e24ffb9b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38ba48dd275535c7383c0bc173182dca/" rel="bookmark">
			Maven 直接依赖、间接依赖、依赖冲突、依赖仲裁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 直接依赖和间接依赖依赖冲突Maven 的依赖仲裁最短路径优先先声明优先 手动解决依赖冲突 直接依赖和间接依赖 在项目中直接引入的依赖叫做直接依赖，而那些被动引入的就叫间接依赖
比如上图中，A 是我们的项目，我们在项目中直接引入了 B 模块，所以 B 和 A 的关系就是直接依赖，而 B 工程内部引入了 C，
所以 B 和 C 也是直接依赖关系，如果 B 工程在引入 C 时，指定了 C 模块的依赖范围是 &lt;scope&gt;compile&lt;/scope&gt;，那么 C 模
块就会随着 B 模块一同被引入到我们的工程A 中，这时候 A 和 C 的关系就是间接依赖
依赖冲突 Maven 的依赖冲突，我认为有两种情况，Maven 能自动解决的、需要手动解决的
1. Maven 可以自动解决的依赖冲突
在项目中，不管是直接依赖还是间接依赖，当有多个 &lt;groupId&gt;、&lt;artifactId&gt;相同，&lt;version&gt; 不同的依赖引入时，
Maven 就会认为我们引入了相同模块的不同版本，其就会被判定为依赖冲突，这种情况 Maven 会用自己的仲裁机制帮
我们取舍
2. 需要手动解决的依赖冲突
模块间的 &lt;groupId&gt;、&lt;artifactId&gt;、&lt;version&gt; 都不相同，但是引入的这些模块中具有相同路径的类（包名+类名
完全相同），这个时候就需要我们自己去解决依赖冲突问题
Maven 的依赖仲裁 依赖仲裁是 Maven 自动解决依赖冲突的手段，我们想更好的利用它，就必须知道其仲裁的规则，其通过 最短路径优先
和 先声明优先 两个依据来判断最终留下的模块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38ba48dd275535c7383c0bc173182dca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/590ba7ae2c067427830451ade6bb4abb/" rel="bookmark">
			sed简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sed(Stream Editor) 流编辑器， 对标准输出或文件逐行进行处理
语法格式 第一种形式:
stdout | sed [option] "pattern command"第二种形式:
sed [option] "pattern command" file sed的选项 选项含义-n只打印模式匹配行-e直接在命令行进行sed编辑，默认选项-f编辑动作保存在文件中，指定文件执行-r支持扩展正则表达式-i直接修改文件内容 sed.txt
I love python I love PYTHON Hadoop is bigdata frame sed -n -r '/python|PYTHON/p' sed.txt sed -in 's/love/like/gp' sed.txt sed中的pattern详解 匹配模式含义10command匹配到第10行10,20command匹配从10行开始，20行结束10,+5command匹配从第10行开始，到第16行结束/pattern1/command匹配到pattern1的行/pattern1/,/pattern2/command匹配到pattern1的行开始，到匹配pattern1的行结束10,/pattern1/command匹配从第10行开始，到匹配到pattern1的行结束/pattern1/,10command匹配到pattern1的行开始，到第10行匹配结束 sed中的编辑命令详解 类别编辑命令含义查询p打印增加a, i, r, w行后追加， 行前追加, 外部文件读入，外部文件读入行后追加, 匹配行写入外部文件删除d删除修改s/old/new, s/old/new/g, s/old/new/2g/, s/old/new/ig第一个替换， 整行全部替换， 从第二个到整行替换， 忽略大小写的全行替换 加上**=**标志，就是显示行号
注意在脚本中使用，引用变量的时候，使用双引号
利用sed查询特定内容 查询命令含义1p打印第一行内容1,10p打印1-10行内容1,+5p打印1，1+5行内容数据/pattern1/p打印每一行中匹配到pattern1的行内容/pattern1/,/pattern2/p打印匹配到pattern1的行直到匹配到pattern2的所有行的内容为止/pattern1/,10p打印匹配到pattern1的行到10行的所有行内容10,/pattern1/p打印第10行直到匹配到pattern1的所有行内容 对于sed提取，可以使用替换删除某些字符，实现剥离
可以多用几个管道实现多重规则
利用sed删除特定内容 查询命令含义1d删除第一行内容1,10d删除1-10行内容1,+5d删除1，1+5行内容数据/pattern1/d删除每一行中匹配到pattern1的行内容/pattern1/,/pattern2/d删除匹配到pattern1的行直到匹配到pattern2的所有行的内容为止/pattern1/,10d删除匹配到pattern1的行到10行的所有行内容10,/pattern1/d删除第10行直到匹配到pattern1的所有行内容 删除配置文件中所有的注释行和空行
sed -i '/[:blank:]*#/d;/^$/d' nginx.confg在配置文件中所有不以#开头的行前面添加*符号， 注意:以#开头的行不添加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/590ba7ae2c067427830451ade6bb4abb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ad9df71940dc0b44c715cd1d16d47ac/" rel="bookmark">
			Xcode15模拟器问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题:Xcode15 下载打开之后模拟器下载失败,导致无法跑项目
解决办法:
1.https://developer.apple.com/download/all/ 去下载IOS17模拟器dmg,约7个G
2.解压
找到最深层的这个文件夹
通过 Contents —&gt; Developer —&gt; Platforms —&gt; iPhoneOS.platform —&gt; Library —&gt; Developer —&gt; CoreSimulator，找到 Profiles 文件夹,将第 2 步的 Runtimes 文件夹拷贝 Profiles 文件夹中,打开/重启 Xcode 15.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ed021acc5c6ea75b234e06a275dfe93/" rel="bookmark">
			sp-historian使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		①
②
③确保historain状态都正常
④在独立的客户端上查看曲线
拖入一个点 即可查看曲线
⑤在intouch画面上查看曲线
先导入曲线控件
曲线控件是在symbol里面用的，所以新建一个symbol，把控件拖到symbol里面，再把symbol拖到intouch画面上
⑥在web上查看曲线
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/678dcd910566f457ffea7d53d17efbdf/" rel="bookmark">
			SMSAlarm快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文以连接KepServerEx V4，以短信的形式自动发报警信息到预设联系人为例子，描述如何快速入门SMSAlarm
运行SMSAlarm 首先参考如下网页，测试好短信猫的短信功能
SMSAlarm短信猫语音猫快速连接_madeINchina2025的博客-CSDN博客
然后以管理员权限运行SMSAlarm（如下图勾选"以管理员身份运行此程序"之后，再双击桌面图标启动SMSAlarm即可）
新建一个联系人 填写必要的信息和勾选所需的通知方式，并设置优先级为现场工程师(Engineer)
新建一个组 并把刚建的联系人拉到这个组里面
新建一个OPC连接 新建一个OPC组 新建一个OPC点 监视过程 当报警时，对应的点的背景会显示为红色。在经过预设的延时时间之后，就会发送信息到联系人
同时在状态栏可以看到当前发送状态，在历史查询页面可以查到发送历史
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2042d86ed3e8f78ae3b4d80e5e313742/" rel="bookmark">
			SMSAlarm USB短信语音流量猫使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装SIM卡 连接设备 安装驱动 连接网络 驱动安装完之后，以移动卡为例，会形成一个CMCC网络
如何确认是否可以连接到外网？
打开网络和共享中心，如下图表示已连上外网
防火墙相关操作 禁用防火墙 对于防火墙已经全部禁用的计算机不需要设置防火墙了，已经可以通过SMSAlarm发微信了
对于开启了防火墙的计算机，分为以下几种种情况，下面分别介绍
入站连接-阻止(默认) 默认就是阻止入站，如下图。表示一切进入本机的连接是阻止的（表示阻止任何本地程序监听任何端口。由于无法监听，所以外部程序就连不进来），除非在入站策略里面登记了允许连接才行。
入站策略大多数时候会自动创建，比如程序netassist需要监听某端口时，防火墙会就会提示
如果选择了允许访问，则系统会自动创建两条防火墙入站允许连接规则
同时也会在允许程序通过windows防火墙的列表里面出现
SMSAlarm不需要监听任何本地端口，所以入站连接阻止与否对SMSAlarm不影响。
入站连接-允许 表示一切进入本机的连接是允许的，如下图，即允许任何本地程序监听任何端口，除非在入站策略里面登记了阻止连接。外部程序一旦连接上本地端口，就可以在这个连接上进行双向通信。
SMSAlarm不需要监听任何本地端口，所以入站连接阻止与否对SMSAlarm不影响。
出站连接-允许(默认) 默认就是允许出站，如下图，表示任意程序的数据都可以自由连接到外部程度所监听的端口，除非在出站规则中登记过阻止连接。本地程序一旦连接上外部程序，就可以在这个连接上进行双向通信。
如果需禁止其他应用程序通过防火墙，在出站规则中登记禁止连接即可，以禁止微信上网为例，如下图
效果如下
出站连接-阻止 出站连接设置为阻止，如下图，表示任意数据都被禁止出站，除非在出站规则中登记过允许连接
由于阻止了一切应用程序连接到外部，所以需要在出站规则中将SMSAlarm登记为允许连接，才能连接外网发送微信
下图是在出站规则中将SMSAlarm登记为允许连接的的操作流程
效果如下
如果还需要其他的应用程序连接到外网，也同样操作即可。
专用网络和公用网络 Windows 7系统有两种网络类型，分别是专用网络和公用网络，
可以分别针对这两种类型的网络设置防火墙策略。
家庭网络、工作网络和公用网络 在计算机通过wifi或网线第一次连接到路由器的网络上时，操作系统一般会自动弹出一个选择框，让我们选择把此网络设置为家庭网络、工作网络还是公用网络，如下图
也可以在网络和共享中心里面更改网络类型
这三种网络有什么区别呢？
公用网络 为不可信任网络，选择公用网络则会在Windows防火墙中自动应用较为严格的防火墙策略，从而到达在公共区域保护计算机不受外来计算机的侵入。
家庭网络和工作网络 同为可信任网络，选择这两种网络类型会自动应用比较松散的防火墙策略，从而实现在局域网中共享文件、打印机、流媒体等功能。但当用户选择家庭网络时Windows 7会自动进行“家庭组”的配置，比如检测局域网中是否存在家庭组、配置家庭组中的共享设置、加入家庭组等。
这三个网络和专用网络、公用网络有什么关系呢？
对于家庭网络和工作网络，都属于专用网络，适用于专用网络的防火墙策略。
对于公用网络，仍属于公用网络，适用于公用网络的防火墙策略。
网卡 windows下无法单独为某个网卡设置防火墙策略，只能是让这个网卡连接到一个网络比如路由器网络等，再把这个网络设置为专用网络（即家庭网络或工作网络）或公用网络，再针对专用网络或公用网络设置防火墙策略。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ad8c60d88af25239d12aac26b2b69a/" rel="bookmark">
			smsalarm怎么读取intouch系统平台的点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有两种方式，分别是DDE和OPC方式
DDE方式 在SMC里面添加SIDIR驱动，连接到1200PLC
在IDE中创建对象DT01并绑定到驱动上
可看到已经可以读取到值了
打开smsalarm 8.26
创建一个DDE连接
创建一个DDE逻辑组
创建一个tag.
名称可以填任意字符串，地址格式为 Galaxy:对象名.属性名
创建一个tag.
名称可以填任意字符串，地址格式为 Galaxy:对象名.属性名
把这个值拉到intouch画面上
smsalarm中可以读取到数据了
DDE方式的缺点是（以读取Galaxy:DT1.PV为例）：必须在view画面上拉一个显示框把Galaxy:DT1.PV 显示出来，才能通过dde方式读取到Galaxy:DT1.PV的值
OPC方式 即通过OPC直接读取驱动中的点的值
以连接西门子1200PLC为例，先在SMC中配置好驱动 OI.SIDIR（连接其他PLC需要配置相应的OI.XXX驱动）
打开SMSAalarm
新建一个OPC连接，选择OI.SIDIR
新建一个group
新建一个点
在名称栏中可以改为任意字符串比如test2，在地址栏中把$SYS$ActiveItemCount换成DB块地址，比如DB5,INT0，如下
可以看到已经读取到值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6958a116ceb39a49d066139e3ccc78fe/" rel="bookmark">
			基于ZigBee的智能家居安防系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 适用场景 智能家居、智能安防系统、室内安防、家居环境监测系统等场景。
2 开发环境 下位机开发环境：IAR embedded Workbench
上位机开发环境：OneNET云平台
小鱼儿电子设计微信号：IOTElectronics
3 技术框架及硬件元件 技术框架：ZigBee终端节点+ZigBee协调器节点+WiFi无线通信技术+OneNET云平台硬件元件：ZigBee终端节点+ZigBee协调器节点+DHT11温湿度传感器+MQ-2烟雾传感器+HC-SR501人体红外传感器+5516光敏电阻传感器+蜂鸣器+按键+OLED液晶显示屏幕+ESP8266 WifI无线通信模块+LED照明灯 4 实现功能 温湿度监测：选用DHT11温湿度传感器实时监测家居环境的温度和湿度，当温度和湿度超过设定阈值自动告警。
火灾预警：选用MQ-2烟雾传感器实时监测家居环境是否发生火灾，当烟雾浓度超过阈值，蜂鸣器自动告警提醒。
人体监测：选用HC-SR501人体红外传感器实时监测家居环境是否有人存在，在家人外出的情况下也可以防盗。
光线监测：选用5516光敏电阻传感器实时监测家居环境的光线，当光线低于设定阈值且有人在家，自动开灯。
屏幕可视化：通过OLED屏幕实时显示家居环境的温度、湿度、烟雾浓度、光线值和是否有人。
设定阈值：可以使用按键结合屏幕设定温度、湿度、烟雾浓度和光线的阈值。
OneNET云平台远程监测：通过WiFi无线通信技术将监测数据上传至OneNET云平台，可以远程查看家居环境的监测数据和灯光、告警状态。
5 下位机实物图 6 OneNET云平台 7 关键源码 //ZigBee终端节点向ZigBee协调器节点发送数据 void SampleApp_Send_P2P_Message( void ) { unsigned char tx_temp[10]; unsigned int read_adc; dht11_read(); tx_temp[0]=ZIGBEE_ID; printf("zigbee_id=%d\r\n",ZIGBEE_ID);//打印ID值到串口（主要作用是用于串口调试） tx_temp[1]=wendu_shi*10+wendu_ge; tx_temp[2]=shidu_shi*10+shidu_ge; read_adc=HalAdcRead(HAL_ADC_CHANNEL_0,HAL_ADC_RESOLUTION_10); read_adc=read_adc*100/512; tx_temp[3]=(unsigned char)read_adc; read_adc=HalAdcRead(HAL_ADC_CHANNEL_6,HAL_ADC_RESOLUTION_10); read_adc=100-read_adc*100/512; tx_temp[4]=(unsigned char)read_adc; printf("light=%d\r\n",tx_temp[4]); tx_temp[5]=ir[0]; tx_temp[6]='\r'; tx_temp[7]='\n'; if ( AF_DataRequest( &amp;SampleApp_P2P_DstAddr, &amp;SampleApp_epDesc,//发送函数 SAMPLEAPP_P2P_CLUSTERID, 10, tx_temp, &amp;SampleApp_TransID, AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS ) { } else { } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f47b13dc636be4d07121ef2499dae526/" rel="bookmark">
			sv&amp;uvm的踩坑案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例1：重载场景下对子类赋值失败
base_class（父类）和extend_class（子类）内部都有相同的变量int var[$]；
父类是参数化类，在test这一层通过uvm的工厂机制进行override（type）后，这个类在env这里被实例化，实例化名refm；
在test的run_phase阶段，赋值：env.refm.var.push_back(99);
发现并没有赋值到子类；把子类的var[$]删掉后，子类才能看到这个push进来的00；
另一个问题是，如果子类加了一个变量，再在test这里对这个变量赋值，会报编译错误，说没有在父类找到这个变量；所以推测，外面在赋值的时候其实是对父类已经声明的变量进行赋值。
解决办法：code stye完善；父子类不能声明相同名字的变量；
案例2：
解决办法：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cd62baa186d00f7c4ada99f639da093/" rel="bookmark">
			成集云 | 金蝶EAS集成聚水潭ERP（金蝶EAS主管供应链）| 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源系统成集云目标系统 方案介绍 金蝶EAS是一款全球首款融合TOGAF标准SOA架构的企业管理软件，专门为大中型企业设计，以“创造无边界信息流”为产品设计理念，支持云计算、SOA和动态流程管理的整合技术平台。
聚水潭是一款以SaaS ERP为核心，集多种商家服务为一体的SaaS协同平台，为全国35万多家电商企业提供全面的信息化解决方案。聚水潭已在全国设立了超过60个线下服务网点，服务范围覆盖超过300个城市，为客户提供及时、周到和专业的服务。
解决方案 基于成集云-数据集成平台构建可视化自动同步任务。
实施步骤 登录成集云数据集成平台-任务管理
输入注册时填写的手机号和密码后，根据提示输入验证码即可点击登录进入系统也可以点击右上角二维码图片进入二维码扫码绑定微信用户登录更加安全 创建任务，选择任务类型为API集成 选择源系统连接器为金蝶EAS，并配置相关授权参数 选择模板系统连接为聚水潭ERP,并配置相关授权参数设置集成同步的对接策略为 10分钟/次。 业务流程 对接说明 财务ERP仓库货品数据同步至电商ERP商品资料电商ERP店铺资料同步至财务ERP客户档案电商ERP销售订单同步至财务ERP创建发货单并审核，审核完成后数据传回电商ERP并生成发货单据电商ERP采购订单同步至财务ERP创建入库申请单并审核，审核完成后数据传回电商ERP并生成入货单据电商ERP采购退货单同步至财务ERP创建出库申请单并审核。电商ERP调拨单同步至财务ERP创建出库申请单并审核，审核完成后更新状态传回电商ERP并再次发起入库申请单审核 集成价值 提升业务处理效率：金蝶EAS与聚水潭ERP的集成，可以自动将订单信息、库存信息等关键数据同步，避免手动操作带来的错误和延误，提升业务处理效率。加强财务管理：金蝶EAS与聚水潭ERP集成的财务模块，可以提供自动记帐、快速核算等功能，实现财务数据的实时更新和准确记录，加强财务管理。优化库存管理：聚水潭ERP的库存管理模块能够实时更新库存信息，金蝶EAS与之集成后，可以实现库存信息的实时共享，避免库存积压和缺货现象，优化库存管理。加强业务协同：金蝶EAS与聚水潭ERP的集成，可以实现企业内部和外部的业务协同，包括采购、销售、库存、财务等各个部门之间的协同，提高企业整体运营效率。 总之，金蝶EAS集成聚水潭ERP可以提升企业的业务处理效率、财务管理水平、库存管理效果、客户满意度以及业务协同能力等。
平台介绍 丰富的接口支持 支持数据库直连/restful webapi/kafka/mq消息队列/FTP/S3文件传输等多样化的数据集成接口
海量集成模板方案，开箱即用 支持市面上主流ERP/WMS/CRM/SRM/OA/开放银行/电商平台/第三方支付/电子合同/云服务应用集成
可视化构建分布式集成任务 海量的集成方案模板复用,专业标准的实施方法论,保障交付成功,持续稳定运维
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38af4fe1ef33097bd308e57ce732d408/" rel="bookmark">
			Android RIL介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、需求二、相关概念2.1 IMS2.2 Volte2.3 CS域与PS域2.3.1 CS域2.3.2 PS域 2.4 VOIP2.5 URC消息2.6 HIDL 三、环境四、设计思路4.1 RIL结构图4.2 RIL相关模块介绍4.2.1 Dialer模块4.2.2 TeleService模块4.2.2.1 TeleService启动 4.2.3 TelecomService模块4.2.3.1 TelecomService启动4.2.3.2 TeleComService消息处理模型 4.2.4 telephony-common模块4.2.5 Telecom_Framewrok模块4.2.6 Telephony_Framewrok模块4.2.7 RIL模块4.2.7.1 RILD守护进程4.2.7.1.1 RILD启动 4.2.7.2 libril共享库4.2.7.3 librefrence共享库 4.3 RIL相关模块通讯4.3.1 通讯架构图 五、详细设计5.1 Dialer拨号5.1.1 Dialer应用拨号时序图5.1.2 Dialer拨号界面显示5.1.3 Dialer权限检查5.1.4 与TelecomService通信 5.2 TelecomService处理拨号流程5.2.1 TelecomService处理拨号时序图5.2.2 往InCallService发送请求5.2.3 广播下发消息5.2.4 往TeleService下发请求 5.3 TeleService下发拨号请求5.3.1 TeleService下发拨号请求时序图5.3.2 TeleService类图5.3.3 TelephonyConnectionService启动5.3.4 TeleService拨号请求下发（GsmCdmaPhone）5.3.5 TeleService拨号请求下发（ImsPhone）5.3.5.1 时序图5.3.5.2 IMS与CDMA、GSM时序切换 5.4 RILD处理拨号请求5.4.1 RILD拨号请求消息下发时序图5.4.2 RILJ往RILD发送指令5.4.3 RILD接收到RILJ指令5.4.4 RILD和reference侧消息传递5.4.5 reference侧接收到消息5.4.6 reference侧将消息发送至modem侧5.4.7 modem侧发送消息至reference侧5.4.8 reference侧轮询modem指令 六、RIL指令6.1 RILJ主动发送指令6.2 RILJ被动接收指令 七、参考资料 一、需求 1、了解IMS相关知识体系
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38af4fe1ef33097bd308e57ce732d408/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6750e0b6ef8fb90ffa4afe4ffa21a2b2/" rel="bookmark">
			Flowable 之事件和网关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、网关1.1 排他网关1.2 并行网关1.3 包容网关1.4 事件网关 二、事件2.1 定时器事件2.1.1 定时器启动事件2.1.2 中间计时器捕获事件2.1.3 边界计时器事件 2.2 消息事件2.2.1 消息启动事件2.2.2 中间消息捕获事件2.2.3 边界消息事件 2.3 错误事件2.3.1 异常启动事件2.3.2 结束错误事件2.3.3 边界错误事件 2.4 信号事件2.4.1 信号启动事件2.4.2 中间信号捕获事件2.4.3 中间信号抛出事件2.4.4 边界信号事件 2.5 结束事件2.5.1 结束错误事件2.5.2 结束终止事件2.5.3 结束取消事件 2.6 补偿事件 提示：以下是本篇文章正文内容，Java 系列学习将会持续更新 一、网关 1.1 排他网关 排他网关（exclusive gateway）（也叫异或网关 XOR gateway，或者更专业的，基于数据的排他网关 exclusive data-based gateway），用于对流程中的决策建模。当执行到达这个网关时，会按照所有出口顺序流定义的顺序对它们进行计算。选择第一个条件计算为true的顺序流（当没有设置条件时，认为顺序流为true）继续流程。
使用排他网关时，只会选择一条顺序流。当多条顺序流的条件都计算为 true 时，会且仅会选择在XML中最先定义的顺序流继续流程。如果没有可选的顺序流，会抛出异常。 public class Test5 extends FlowableBootStudyApplicationTests { @Resource private RepositoryService repositoryService; @Resource private RuntimeService runtimeService; @Resource private TaskService taskService; /** * 部署流程 */ @Test public void deploy(){ Deployment deploy = repositoryService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6750e0b6ef8fb90ffa4afe4ffa21a2b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48342c1132c3bd80f97d14ed768687b1/" rel="bookmark">
			将Excel数据读取后存入Redis， 多线程操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天更新一个redis多线程操作， 可直接搬运
import redis, os, threading, queue import pandas as pd # 创建一个任务队列 task_queue = queue.Queue() def read_excel(folder_path): total_list = [] for filepath, dirnames, filenames in os.walk(folder_path): for filename in filenames: file_path = os.path.join(filepath, filename) df_total = pd.read_excel(file_path) list_df = df_total['product'].values.tolist() total_list.extend(list_df) print(total_list) print(len(total_list)) result_list = [] for t_pro in total_list: t_pro_dict = {t_pro: '20230907'} result_list.append(t_pro_dict) # # 写入 redis # redis_obj = RedisClass('ahrefs_filter', 9) # for t_pro in total_list: # t_pro_dict = {t_pro: '20230907'} # print(t_pro_dict) # redis_obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48342c1132c3bd80f97d14ed768687b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87ca00b455f9188da019bccd984ad7e5/" rel="bookmark">
			web爬虫 - 实例一（猿人学17题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个案例很简单， 不多说了
import httpx def get_info(ind): url = "https://match.yuanrenxue.cn/api/match/17?page=" + str(ind) headers = { 'authority': 'match.yuanrenxue.com', 'cookie': 'Hm_lvt_c99546cf032aaa5a679230de9a95c7db=1690184377,1690941596,1690969392,1690971468; Hm_lvt_9bcbda9cbf86757998a2339a0437208e=1690184376,1690941595,1690969392,1690971468; Hm_lvt_434c501fe98c1a8ec74b813751d4e3e3=1690971476; Hm_lpvt_434c501fe98c1a8ec74b813751d4e3e3=1690971476; tk=-7962460354862954537; sessionid=1mcld1cz4z54nrnhkuxfq7wtysc7vdds; Hm_lpvt_9bcbda9cbf86757998a2339a0437208e=1691027865; Hm_lpvt_c99546cf032aaa5a679230de9a95c7db=1691027869', 'referer': 'https://match.yuanrenxue.com/match/3', 'user-agent': 'yuanrenxue.project', } client = httpx.Client(http2=True) resp = client.get(url=url, headers=headers) res_json = resp.json() sum = 0 for val_dict in res_json['data']: sum += val_dict['value'] return sum if __name__ == '__main__': sum_num = 0 for i in range(1, 6): res = get_info(i) sum_num += int(res) print(sum_num) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc7f00db1eb97bdca4fcdfc3bf83c22d/" rel="bookmark">
			用最简单的例子了解装饰器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用最简单的例子了解装饰器 以下为作者个人理解。如不认同 ，欢迎留言。
1- 定义： 定义我也说不上来， 大家自行百度 2- 作用： 装饰器能在不大幅度修改原有代码的情况下添加功能 3- 推导步骤 1- 我这里有个 【查询函数】
def index(): print('这里有好多内部信息, 严禁外泄') return 'ok' 2- 这时候我添加一个功能，只有指定的人才能看到这些数据， 下文称 【验证函数】
user_data = [{'username': '张三', 'password': 'zhangsan'}, {'username': '李四', 'password': 'lisi'}, {'username': '王五', 'password': 'wangwu'}] def login(u_name, p_word): data = { 'code': -1, 'msg': '验证未通过' } # 获取所有username和password print(user_data) # 方法一 for d in user_data: if u_name in d['username']: # 用户名存在 if p_word == d['password']: data = { 'code': 1, 'msg': '用户 {} 登录成功'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc7f00db1eb97bdca4fcdfc3bf83c22d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/219e95b882fcaa38bdaa396296832fbc/" rel="bookmark">
			Django中的cookie和session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。
Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。
cookie本身由服务器生成，通过Response将cookie写到浏览器上，下一次访问，浏览器会根据不同的规则携带cookie过来。
设置cookie（使用response设置）： response.set_cookie(key,value[,max_age=None,expires=None)] max_age: 整数 单位为秒，指定cookie过期时间 设置为None:浏览器关闭失效,默认值 expires: 指定过期时间，还支持datetime或timedelta，可以指定一个具体日期时间 expires=datetime.datetime(2019, 1, 1, 2, 3, 4) 或 datetime.datetime.now() + datetime.timedelta(days=10) 注意:max_age和expries两个选一个指定 # response.set_cookie('username', username, max_age=10)	# response.set_cookie("username", username1, expires=d) 获取cookie(使用request获取)： request.COOKIES.get('username') 删除cookie response.delete_cookie('username') session 服务器端会话技术,依赖于cookie.
数据存储到数据库中会进行编码,使用的是Base64
每个HttpRequest对象都有一个session属性，也是一个类字典对象.
设置Sessions值（使用request设置） request.session['user_id'] = user.id request.session.set_expiry(86400) # 设置过期时间 获取Sessions值 get(key,default=None) 根据键获取会话的值 username = request.session.get("user_id") # 或 session_name = request.session["session_name"] 删除Sessions值 # 获取当前请求的session的key session_key = request.session.session_key del request.session[session_key] # request.session.delete(session_key) clear() 清除所有会话 flush() 删除当前的会话数据并删除会话的cookie 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf974066ca81873c90c16cff6843cc1/" rel="bookmark">
			[NPUCTF2020]EzRSA e和phi_n不互素怎么找d
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 from gmpy2 import lcm , powmod , invert , gcd , mpz from Crypto.Util.number import getPrime from sympy import nextprime from random import randint p = getPrime(1024) q = getPrime(1024) n = p * q gift = lcm(p - 1 , q - 1) e = 54722 flag = b'NPUCTF{******************}' m = int.from_bytes(flag , 'big') c = powmod(m , e , n) print('n: ' , n) print('gift: ' , gift) print('c: ' , c) #n: 17083941230213489700426636484487738282426471494607098847295335339638177583685457921198569105417734668692072727759139358207667248703952436680183153327606147421932365889983347282046439156176685765143620637107347870401946946501620531665573668068349080410807996582297505889946205052879002028936125315312256470583622913646319779125559691270916064588684997382451412747432722966919513413709987353038375477178385125453567111965259721484997156799355617642131569095810304077131053588483057244340742751804935494087687363416921314041547093118565767609667033859583125275322077617576783247853718516166743858265291135353895239981121 #gift: 2135492653776686212553329560560967285303308936825887355911916917454772197960682240149821138177216833586509090969892419775958406087994054585022894165950768427741545736247918410255804894522085720642952579638418483800243368312702566458196708508543635051350999572787188236243275631609875253617015664414032058822919469443284453403064076232765024248435543326597418851751586308514540124571309152787559712950209357825576896132278045112177910266019741013995106579484868768251084453338417115483515132869594712162052362083414163954681306259137057581036657441897428432575924018950961141822554251369262248368899977337886190114104 #c: 3738960639194737957667684143565005503596276451617922474669745529299929395507971435311181578387223323429323286927370576955078618335757508161263585164126047545413028829873269342924092339298957635079736446851837414357757312525158356579607212496060244403765822636515347192211817658170822313646743520831977673861869637519843133863288550058359429455052676323196728280408508614527953057214779165450356577820378810467527006377296194102671360302059901897977339728292345132827184227155061326328585640019916328847372295754472832318258636054663091475801235050657401857262960415898483713074139212596685365780269667500271108538319 分析 本题涉及到一个gmpy2的函数lcm(Least Common Multiple)求最小公倍数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faf974066ca81873c90c16cff6843cc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cb2900d811c1053cf097d03b4cad1d6/" rel="bookmark">
			mysql按月分组并补齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select
a.month,
IFNULL(b.point_count_0, 0) as point_count_0,
IFNULL(b.point_count_1, 0) as point_count_1,
IFNULL(b.point_count_2, 0) as point_count_2,
IFNULL(b.point_count_3, 0) as point_count_3
from
(
select
DATE_FORMAT(CURDATE(), '%Y-%m') as month
union
select
DATE_FORMAT(CURDATE() - interval 1 month, '%Y-%m') as month
union
select
DATE_FORMAT(CURDATE() - interval 2 month, '%Y-%m') as month
union
select
DATE_FORMAT(CURDATE() - interval 3 month, '%Y-%m') as month
union
select
DATE_FORMAT(CURDATE() - interval 4 month, '%Y-%m') as month
union
select
DATE_FORMAT(CURDATE() - interval 5 month, '%Y-%m') as month
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cb2900d811c1053cf097d03b4cad1d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bce3fc3c913d82f0c4c356453ea14b3c/" rel="bookmark">
			sudo gedit ~/.bashrc 出现Authorization required, but no authorization protocol specified 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当您在终端中使用sudo gedit ~/.bashrc命令时，出现"Authorization required, but no authorization protocol specified"错误通常是由于缺少授权协议导致的。尝试使用以下解决方案之一：
使用gedit命令替代sudo gedit：gedit ~/.bashrc。这将以普通用户身份打开文件，您应该能够编辑它。
使用nano或vim等其他命令行编辑器来编辑文件：
对于nano，您可以使用命令sudo nano ~/.bashrc来编辑文件。对于vim，您可以使用命令sudo vim ~/.bashrc来编辑文件。 请注意，如果您选择使用命令行编辑器来修改文件，请确保具备足够的知识和经验来进行编辑，以避免意外修改。建议在编辑文件之前备份它，以便在需要时恢复原始版本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9930838f6329e7b211f2404ad70a4b23/" rel="bookmark">
			将docker镜像打成tar包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # 打包 docker save -o zookeeper.tar bitnami/zookeeper:3.9.0-debian-11-r11 # 解压 docker load -i zookeeper.tar 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9130eda3373b8643a15d56ecaf7c845a/" rel="bookmark">
			OpenWrt 学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenWrt 学习记录 ssh settingCodePathreview MakefileCURDIRMAKEFILE_LIST ssh setting keygen ssh-keygen -t rsa -C "hugh@win10WLS.com" copy rsa_pub to gitee ssh cat id_rsa id_rsa.pub 打开gitee仓库，点击头像、点击设置，点击SSH公钥，粘贴 test gitee ssh -T git@gitee.com config git config --global user.email "hugh@win10WLS.com" git config --global user.name "hugh" CodePath github: git clone https://github.com/coolsnowwolf/lede gitLEDE gitee: git clone git@gitee.com:hughMTK/lede.git giteeLEDE cd lede create new branch git branch -d hughLearn git checkout --orphan hughLearn push origin git push origin --delete hughLearn git add -A &amp;&amp; git commit -m "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9130eda3373b8643a15d56ecaf7c845a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/996c8e3b003ead63dba9b38122e0accc/" rel="bookmark">
			IAR Embedded Workbench安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 开发环境安装包 链接：https://pan.baidu.com/s/1Eatz6vyuniWRcAHd-OMWcA 2 安装步骤 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cba46fc3d0d9180523418d877c34927/" rel="bookmark">
			数据结构——排序算法总结（八个）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（注意⚠️：简单选择排序是不稳定的！不稳定的！不稳定的！）
内排序：指在排序期间数据对象所有存放在内存的排序。
外排序：指在排序期间所有对象太多，不能同一时候存放在内存中，必须依据排序过程的要求，不断在内，外存间移动的排序。
一、冒泡排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
二、选择排序 每次选择一个最大(小)的，知道所有的元素都被输出。（选择之后需要交换位置）
三、直接插入排序 插入排序的基本方法是：每一步将一个待排序的元素，按其排序码的大小，插入到前面已经排好序的一组元素的适当位置上去，直到元素全部插入为止
算法思路：
当插入第i(i &gt;= 1)时，前面的V[0]，V[1]，……，V[i-1]已经排好序。这时，用V[I]的排序码与V[i-1]，V[i-2]，…的排序码顺序进行比较，找到插入位置即将V[i]插入，原来位置上的元素向后顺移。
以[21,25,49,25,16,08]为例，排序过程如下所示：
在小规模数据集或是基本有序时，该算法效率较高。
四、希尔排序 先对数据进行预处理，使其基本有序，然后再用直接插入排序算法排序。
五、快速排序 利用“分而治之”的思想对集合进行排序
假设序列为23，11，49，35，6，19.
我们用low和high分别指向第一个元素和最后一个元素，同时我们取第一个数23为“中枢元素”，将它“挖”出来，如下：
将23挖出来以后，最左边就留下了一个“坑”，根据我们之前所说的，我们要把比中枢元素（23）大的扔到左边，所以我们就要用high来找比23大的值，将它扔到之前在左边挖好的坑里。现在，19比23小，19就不用动，因为我们本来就是要把比23小的数留在右边。那么将high左移一位继续，6也比23小，high再左移一位，发现35比23大，那么就把它填进左边的坑里，如下：
此时high所指的位置也留下了一个坑，那么我们就用low在序列头部开始找比23小的数来扔到右边，35比23大，low右移一位，发现11比23小，所以将11填到右边的坑里，如下：
继续从high开始，往左找比23大的数，找到49，往左边填坑，如下：
继续从low开始，往右边找，发现此时 low与high相遇了，那么这个地方就是中枢元素“归位”的位置，如下：
好了，通过以上过程，我们已经将比23小的数扔到了右边，大的数扔到了左边。
此后，将以23为分界线的左右两个子序列继续重复此过程，直到所有子序列仅有一个元素为止，排序完成。
六、堆排序 堆：堆是满足下列性质的完全二叉树：
每个节点都大于或是等于其左右孩子节点的值，称为大顶堆每个节点都小于或是等于其左右孩子节点的值，称为小顶堆 接下来说下堆是如何做排序的，思路如下（以大顶堆为例）：
根节点是整个堆的最大值，将它移走。将剩余n-1个节点重新构造成一个堆，再将根节点移走重复执行1,2。直到没有节点可移动，就生成了有序序列。 该算法有两个需要解决问题：
如何将一个无序序列构建一个堆。移除根节点后，如何用剩余的节点重建堆 基本思路：
堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。
七、归并排序 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。
分而治之
合并相邻有序子序列
再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。
八、基数排序 基数排序与前面的七种排序方法都不同，它不需要比较关键字的大小。
它是根据关键字中各位的值，通过对排序的N个元素进行若干趟“分配”与“收集”来实现排序的。
基本思想
设有一个初始序列为: R {50, 123, 543, 187, 49, 30, 0, 2, 11, 100}。
我们知道，任何一个阿拉伯数，它的各个位数上的基数都是以09来表示的。所以我们不妨把09视为10个桶。
我们先根据序列的个位数的数字来进行分类，将其分到指定的桶中。例如：R[0] = 50，个位数上是0，将这个数存入编号为0的桶中。分类后，我们在从各个桶中，将这些数按照从编号0到编号9的顺序依次将所有数取出来。这时，得到的序列就是个位数上呈递增趋势的序列。 按照个位数排序： {50, 30, 0, 100, 11, 2, 123, 543, 187, 49}。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cba46fc3d0d9180523418d877c34927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90cf55fcb748c43c5151acbdf6485c6d/" rel="bookmark">
			LocalDateTime的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LocalDate ： 只含年月日的日期对象
LocalTime ：只含时分秒的时间对象
LocalDateTime ： 同时含有年月日时分秒的日期对象
package com.demo; import java.time.*; import java.time.format.DateTimeFormatter; import java.util.Date; public class LocalDateTimeTest { public static void main(String[] args){ //获取当前时间 System.out.println(LocalDate.now()); System.out.println(LocalDateTime.now()); System.out.println(LocalTime.now()); //根据指定日期/时间创建对象 System.out.println(LocalTime.of(9,32,20)); System.out.println(LocalDate.of(2023,1,17)); System.out.println(LocalDateTime.of(2024,1,23,9,23,11)); //日期时间的加减 System.out.println(LocalDate.now().plusDays(7)); System.out.println(LocalDate.now().plusMonths(3)); System.out.println(LocalDate.now().plusYears(1)); System.out.println(LocalTime.now().plusHours(1)); System.out.println(LocalTime.now().plusMinutes(20)); System.out.println(LocalTime.now().plusSeconds(30)); //判断时间前后的比较和判断 LocalDate localDate1=LocalDate.of(2023,1,12); LocalDate localDate2=LocalDate.of(2023,5,12); System.out.println(localDate1.isAfter(localDate2)); //时间戳 Instant instant=Instant.now(); System.out.println(Date.from(instant).toInstant()); //字符串转化成日期对象 String datetime="2023-09-08 10:20:20"; DateTimeFormatter formatter=DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"); System.out.println(LocalDateTime.parse(datetime,formatter)); //日期对象转化成字符串 Instant instant1=Instant.now(); System.out.println(instant1);//这个输出的不是北京时间，与北京时间相差8个小时，下面方法是获取北京当前时间 LocalDateTime ldt = LocalDateTime.ofInstant(instant1, ZoneId.systemDefault()); System.out.println(ldt); //获取时间戳 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90cf55fcb748c43c5151acbdf6485c6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0577d103d6132075846c64750c7a9a/" rel="bookmark">
			学习日记-spmv（23）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SPMV稀疏矩阵向量乘笔记（23） Merge-based Parallel Sparse Matrix-Sparse Vector Multiplication with a Vector Architecture浅读 (1) INTRODUCTION 主要描述了spmv在每个领域的应用场景，表明spmv需要提升的必要性和重要性向量架构（V ector architectures）是非常实用了，但是对于spmv而言，它在将部分结果合并到最终向量中的时间反而比乘法操作更多并且spmv操作非常难以充分利用向量寄存器，因为它的数据存储是不规范的merge算法在于加速spmv在向量架构上的速度，2DMerge对中间向量进行分区，并在水平和垂直维度上进行合并，直到得到最终的稀疏向量最后叙述该算法在什么算法上得到了什么样的加速比 PRELIMINARIES 提出x向量可以使用位图模式（bitmap）来存储在matrix-driven的spMspV中，A中的非零决定了计算和内存访问模式。而在vector-driven的spMspV中，根据向量x中的非零选择矩阵A中的特定列，然后将spMspV视为多个排序向量的归并。使用CCS格式，并且使用位图表示非零，用dense vector存储非零元，list（idx，val）vector length:可以装入向量寄存器并由向量指令处理的数据量,当vector length长度短时，会严重限制系统性能和吞吐量。 RELATED WORKS 主要是介绍spmv相关的工作 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02d7154c318d077539c63eb4c3972a0a/" rel="bookmark">
			SpringBoot配置加载优先级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.SpringBoot配置文件 SpringBoot使用一个以application命名的配置文件作为默认的全局配置文件。支持properties后缀结尾的配置文件或者以yml/yaml后缀结尾的YAML的文件配置。
以设置应用端口为例:
properties文件示例(application.properties)：
server.port=80
YAML文件示例(application.yml)：
server:
port: 80
2.两者同时存在情况 假如各配置文件都配置了不同的端口，那么SpringBoot会使用哪一个端口呢？带着疑问试验一下实例：
在resources目录下创建两个配置文件，一个为application.yml配置文件，设置端口为8010，另一个为application.properties配置文件，设置端口为8020；
运行结果：
结论：可见在同一目录下，yaml配置先加载 &gt; properties配置后加载。所以我们在jar包启动时，properties的配置可以覆盖yml配置。
2.配置文件目录及加载顺序 SpringBoot配置文件可以放置在多种路径下，不同路径下的配置加载优先级有所不同。
可放置目录(加载优先级从高到低)，低优先级的配置会覆盖高优先级的配置；
classpath:/ (类路径config下); classpath:/config/ (类路径config目录下); file:./ (当前项目路径下); file:./config/ (当前项目路径config目录下); SpringBoot会从这四个位置全部加载配置文件并互补配置；
我们可以从ConfigFileApplicationListener这类便可看出，其中DEFAULT_SEARCH_LOCATIONS属性设置了加载的目录：
@Deprecated public class ConfigFileApplicationListener implements EnvironmentPostProcessor, SmartApplicationListener, Ordered { // Note the order is from least to most specific (last one wins) private static final String DEFAULT_SEARCH_LOCATIONS = "classpath:/,classpath:/config/,file:./,file:./config/*/,file:./config/"; private static final String DEFAULT_NAMES = "application"; } 接着getSearchLocations方法中去逗号解析成Set，其中内部类Loader负责这一配置文件的加载过程，包括加载profile指定环境的配置，以application+’-’+name格式的拼接加载。
多种目录配置同时存在情况
接下来还是以端口配置为例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02d7154c318d077539c63eb4c3972a0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca1b54d3ac2411c2dce062a0b437c10c/" rel="bookmark">
			linux之jq命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jq命令用于linux命令行对json进行处理
参数 option -r：去掉字符串的引号'"' 例子 tt.json文件如下：
[ { "metric": "httpcode", "tags": { "cluster": "tt", "domain": "www.baidu.com" } }, { "metric": "httpcode", "tags": { "cluster": "tt", "domain": "www.pingan.com" } }, { "metric": "httpcode", "tags": { "cluster": "tt", "domain": "www.dy.com" } } ] # jq命令后面一定不能忘了加引号 lxm@mypc  ~/Documents/image  cat tt.json| jq -r '.[].tags.domain' www.baidu.com www.pingan.com www.dy.com 参考
https://blog.csdn.net/wzj_110/article/details/117387891
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed3f5b23a540f198238e7006c9bd5941/" rel="bookmark">
			供应商系统工具剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、文件结构二、makefile 结构主线流程解析参数表驱动法获取任务任务数据结构任务队列任务进队任务出队 业务处理1、将命令包装成驱动可以识别的数据包2、netlink 收发函数3、收到消息时使用供应商专属的解析函数 一、文件结构 ├── 3rdParty │ └── wpa_supplicant │ ├── CONTRIBUTIONS │ ├── COPYING │ ├── README │ └── src │ └── drivers │ └── nl80211_copy.h ├── build │ ├── beamforming_on_connected.sh │ ├── build.sh │ └── Makefile ├── common │ └── include │ ├── dot11.h │ ├── netlink │ .............................(netlink相关头文件) ├── doc └── src ├── lib │ ├── libnl-3.so │ ├── libnl-3.so.200 │ ├── libnl-3.so.200.20.0 │ ├── libnl-genl-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed3f5b23a540f198238e7006c9bd5941/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db1480212994895cb1f9010f51105289/" rel="bookmark">
			jmeter时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间戳这东西，在jmeter中会经常用到，自己又总是记不住，做个记录。
jmeter自带的时间戳函数：
①　${__time(yyyy-MM-dd,)} ，对应时间示例：2022-09-24
②　${__time(yyyy-MM-dd HH:mm:ss,time)} ，对应时间示例： 2022-09-24 21:32:10
③　${__time(yyyy-MM-dd HH:mm:ss:SSS,time)} ，对应时间示例：2022-09-24 21:33:53:430 ④　${__time(yyMMdd,)}，对应时间示例：220924 (年月日)
⑤　${__time(/1000,)} ，对应时间示例：1664026503 (精确到 秒 级别， 10位数 )
⑥　${__time(,)} ，对应时间示例：1664026530402 (精确到 毫秒 级别， 13位数)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b41ef20b70f2622187f52527d13a918/" rel="bookmark">
			【大数据之Kafka】十五、Kafka-Kraft模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Kafka-Kraft架构 左图为 Kafka 现有架构，元数据在 zookeeper 中，运行时动态选举 controller，由controller 进行 Kafka 集群管理。
右图为 kraft 模式架构（实验性），不再依赖 zookeeper 集群，而是用三台 controller 节点代替 zookeeper，元数据保存在 controller 中，由 controller 直接进行 Kafka 集群管理。
好处：
（1）Kafka 不再依赖外部框架，而是能够独立运行；
（2）controller 管理集群时，不再需要从 zookeeper 中先读取数据，集群性能上升；
（3）由于不依赖 zookeeper，集群扩展时不再受到 zookeeper 读写能力限制；
（ 4）controller 不再动态选举，而是由配置文件规定。这样可以有针对性的加强controller 节点的配置，而不是像以前一样对随机 controller 节点的高负载束手无策。
2 Kafka-Kraft集群部署 （1）再解压一份Kafka安装包。
tar -zxvf kafka_2.12-3.0.0.tgz -C /opt/module/ （2）重命名为kafka2。
mv kafka_2.12-3.0.0/ kafka2 （3）在 hadoop102 上修改/opt/module/kafka2/config/kraft/server.properties 配置文件。
#kafka 的角色（controller 相当于主机、broker 节点相当于从机，主机类似 zk 功能） process.roles=broker, controller #节点 ID node.id=2 #controller 服务协议别名 controller.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b41ef20b70f2622187f52527d13a918/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e66ff65fa940e435af8de7bbccb35e/" rel="bookmark">
			Gitlab 备份和恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gitlab可以算作公司最重要的知识资产之一，虽然由于其设计，每个开发本地可能都存在着负责项目的全部提交记录，但一旦gitlab发生故障，轻则浪费大量时间进行项目重建，重则丢失项目代码数据。未雨绸缪，提前进行gitlab备份和数据恢复演练，本文记录gitlab的定时备份方案和数据恢复操作。
备份脚本 使用crontab设置定时任务，每天凌晨2点执行备份脚本
crontab -l 0 2 * * * /opt/gitlab_backup.sh 脚本内容如下所示，其中：
/var/opt/gitlab/backups/ 为gitlab 备份文件地址gitlab-rake gitlab:backup:create 为备份命令/mnt/remote/git/ 为挂载的网盘，或者nas，或者使用scp命令传输到远程服务器 #!/bin/sh scp_linux_path='/var/opt/gitlab/backups/' cp_local_uri='/mnt/remote/git/' scp_log_path='/opt/gitlab_backup.log' time=$(date +%Y-%m-%d\ %H:%M:%S) gitlab-rake gitlab:backup:create filename=`ls $scp_linux_path -t |head -n1|awk '{print $0}'` echo [$time] $scp_linux_path$filename &gt;&gt; $scp_log_path cp $scp_linux_path$filename $cp_local_uri # 清理历史旧备份文件 delfile=`ls -l -crt $scp_linux_path/*.tar | awk '{print $9 }' | head -1` count=`ls -l -crt $scp_linux_path/*.tar | awk '{print $9 }' | wc -l` echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25e66ff65fa940e435af8de7bbccb35e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c02d985c8a95e162e9ea1ed262a12e3/" rel="bookmark">
			C&#43;&#43; QT学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ QT学习笔记 信号和槽 // static QMetaObject::Connection connect(const QObject *sender, PointerToMemberFunction signal, Functor functor); connect(ui-&gt;actionQuit,&amp;QAction::triggered,[=](){ this-&gt;close(); }); 绘图 QPainter painter(this); QPixmap pix; pix.load(":/res/PlayLevelSceneBg.png"); painter.drawPixmap(0,0,this-&gt;width(),this-&gt;height(),pix); 音效 QSoundEffect *startSound=new QSoundEffect(this); startSound-&gt;setSource(QUrl::fromLocalFile(":/res/TapButtonSound.wav")); startSound-&gt;play(); 菜单栏 //创建菜单栏 QMenuBar *bar=menuBar(); setMenuBar(bar); QMenu* startMenu=bar-&gt;addMenu("开始"); QAction* quitAction= startMenu-&gt;addAction("退出"); 自定义信号 #include &lt;QMainWindow&gt; #include"playscene.h" class ChooseLevelScene : public QMainWindow { Q_OBJECT public: explicit ChooseLevelScene(QWidget *parent = nullptr); void paintEvent(QPaintEvent *event); PlayScene* play=NULL; signals: //写一个自定义信号，告诉主场景 点击了返回 //只需要声明，不需要实现 void chooseSceneBack(); }; connect(backBtn,&amp;MyPushButton::clicked,[=](){ //返回主场景 backSound-&gt;play(); QTimer::singleShot(500,this,[=](){ emit this-&gt;chooseSceneBack();//发送信号 }); }); chooseLevel=new ChooseLevelScene(); connect(chooseLevel,&amp;ChooseLevelScene::chooseSceneBack,[=](){ //接收信号 chooseLevel-&gt;setGeometry(this-&gt;geometry()); chooseLevel-&gt;hide(); this-&gt;show(); }); 文字 QLabel* levelLabel=new QLabel(); levelLabel-&gt;setParent(this); levelLabel-&gt;setFixedSize(levelBtn-&gt;width(),levelBtn-&gt;height()); levelLabel-&gt;setText(QString::number(i+1)); levelLabel-&gt;move((i%4)*70+25,(i/4)*70+130); //设置文字在Label中的对齐方式 levelLabel-&gt;setAlignment(Qt::AlignHCenter|Qt::AlignVCenter); levelLabel-&gt;setAttribute(Qt::WA_TransparentForMouseEvents); //设置字体 QLabel* label=new QLabel(); label-&gt;setParent(this); QFont font; font.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c02d985c8a95e162e9ea1ed262a12e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82bb8bc756cd09d690860ee212c3d58b/" rel="bookmark">
			jedis实现分布式锁案例：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、redis配置类： import lombok.Data; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Configuration; @Configuration @Data public class JedisConfig { @Value("${spring.redis.host}") private String host; @Value("${spring.redis.port}") private int port; @Value("${spring.redis.database}") private int database; } 二、实现分布式锁工具类： import redis.clients.jedis.Jedis; /** * @author：songwl * @Date：2023/9/15 10:08 * @Description： */ public class AndawellRedisLock { private Jedis jedis; private String lockKey; /** * 锁自动过期时间，60秒 */ private int expireTime = 60; /** * 重试时间，3秒 */ private int retryTime = 3; public AndawellRedisLock(String host, int port, int database,String lockKey, int expireTime) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82bb8bc756cd09d690860ee212c3d58b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4836d174130c7bbbad585eec5e6809a/" rel="bookmark">
			oracle数据库被锁定如何解除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用以下SQL语句查询Oracle被锁定的表： SELECT object_name, machine, s.sid, s.serial# FROM gv$locked_object l, dba_objects b, v$session s WHERE l.session_id = s.sid AND l.object_id = b.object_id; 这个语句将返回被锁定的表的名称、机器名、会话ID和序列号。
二、使用以下SQL语句解除Oracle表的锁定： ALTER SYSTEM KILL SESSION 'sid,serial#'; 其中，sid和serial#是您在上一问中查询到的会话ID和序列号。执行此语句将结束指定的会话并解锁相应的表。
请注意，只有具有适当权限的用户才能执行此操作。此外，在执行此操作之前，请确保了解其影响并仔细检查正在运行的事务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26a978e6ea0625277752d8f08af1f57f/" rel="bookmark">
			opencv-python 小白笔记（21）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第二十一节：美颜相关 （一）亮度增强（二）磨皮美白（cv2.bilateralFilter）（三）瘦脸(局部平移算法)（四）红唇（五）放大眼睛（局部缩放算法）（六）备注（七）结语 好多天没有写博客了，这几天一直忙于炼丹，快被数据搞疯了。废话不多说，今天主要写美颜相关
（一）亮度增强 其实直方图均衡化也可以增加图像亮度，下面先用直方图均衡化的方式实现亮度的增强（以前已经写过灰度图的直方图均衡化，这里相当于彩图的均衡化）
import cv2 img= cv2.imread('face.jpg') cv2.imshow('img', img)#这里展示一下原图 b,g,r=cv2.split(img) b = cv2.equalizeHist(b) g = cv2.equalizeHist(g) r = cv2.equalizeHist(r) out_put=cv2.merge((b,g,r)) cv2.imshow('out_put',out_put) cv2.waitKey(0) 这里相当于分别对三通道进行图像均衡化
雀斑已经淡了很多了，也变白了。（个人觉的，opencv为啥不直接出以个彩图均衡化的函数）
这里使用另一种方法增加图像的亮度，而这种写法有两种
法一：
import cv2 import numpy as np def empty(a): pass cv2.namedWindow("TrackBars") cv2.resizeWindow("TrackBars",650,47) cv2.createTrackbar("light","TrackBars",0,100,empty)#这里设置light最大值为100，你也可以设置大一点 while True: img= cv2.imread('face.jpg') h,w=img.shape[:2] #print(h,w) cv2.imshow('img', img)#这里展示一下原图 light = cv2.getTrackbarPos("light", "TrackBars") out_put=np.zeros((h,w,3),np.uint8) for i in range(0,h): for j in range(0,w): b,g,r=img[i,j] x=int(b)+light y=int(g)+light z=int(r)+light if x&gt;255: x=255 if y&gt;255: y=255 if z&gt;255: z=255 out_put[i, j] = x, y, z cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26a978e6ea0625277752d8f08af1f57f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/90/">«</a>
	<span class="pagination__item pagination__item--current">91/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/92/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>