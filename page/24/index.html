<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4174011d9d7da556c5f39a4b1592c555/" rel="bookmark">
			018、通用集合类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rust标准库包含了一系列非常有用的被称为集合的数据结构。大部分的数据结构都代表着某个特定的值，但集合却可以包含多个值。
与内置的数组与元组类型不同，这些集合将自己持有的数据存储在了堆上。这意味着数据的大小不需要在编译时确定，并且可以随着程序的运行按需扩大或缩小数据占用的空间。不同的集合类型有着不同的性能特性与开销，你需要学会如何为特定的场景选择合适的集合类型。
在本篇文章中，我们将讨论以下3个被广泛使用在Rust程序中的集合：
💗 动态数组（vector）可以让你连续地存储任意多个值。
💗 字符串（string）是字符的集合。我们之前提到过String类型，本文会更为深入地讨论它。
💗 哈希映射（hash map）可以让你将值关联到一个特定的键上，它是另外一种数据结构—映射（map）的特殊实现。
对于标准库中的其他集合类型，你可以通过在Rust官方网站查询相关文档来学习。我们会讨论如何创建和更新动态数组、字符串及哈希映射，并研究它们之间的异同。
1. 使用动态数组存储多个值 我们要学习的第一个集合类型叫作Vec&lt;T&gt;，也就是所谓的动态数组。动态数组允许你在单个数据结构中存储多个相同类型的值，这些值会彼此相邻地排布在内存中。
动态数组非常适合在需要存储一系列相同类型值的场景中使用，例如文本中由字符组成的行或购物车中的物品价格等。 2. 创建动态数组 我们可以调用函数Vec::new来创建一个空动态数组，如示例8-1所示。
// 示例8-1：创建一个用来存储i32数据的空动态数组 let v: Vec&lt;i32&gt; = Vec::new(); 注意，这段代码显式地增加了一个类型标记。因为我们还没有在这个动态数组中插入任何值，所以Rust无法自动推导出我们想要存储的元素类型。
这一点非常重要。动态数组在实现中使用了泛型；我们将在后面文章中学习如何为自定义类型添加泛型。但就目前而言，你只需要知道，标准库中的Vec&lt;T&gt;可以存储任何类型的元素，而当你希望某个动态数组持有某个特定的类型时，可以通过一对尖括号来显式地进行声明。
示例8-1中的语句向Rust传达了这样的含义：v变量绑定的Vec&lt;T&gt;会持有i32类型的元素。在实际的编码过程中，只要你向动态数组内插入了数据，Rust便可以在绝大部分情形下推导出你希望存储的元素类型。
我们只需要在极少数的场景中对类型进行声明。另外，使用初始值去创建动态数组的场景也十分常见，为此，Rust特意提供了一个用于简化代码的vec! 宏。这个宏可以根据我们提供的值来创建一个新的动态数组。
示例8-2创建了一个持有初始值1、2、3的Vec&lt;i32&gt;。 // 示例8-2：创建一个包含了值的新动态数组 let v = vec![1, 2, 3]; 由于Rust可以推断出我们提供的是i32类型的初始值，并可以进一步推断出v的类型是Vec&lt;i32&gt;，所以在这条语句中不需要对类型进行声明。接下来，我们会介绍如何修改一个动态数组。
3. 更新动态数组 为了在创建动态数组后将元素添加至其中，我们可以使用push方法，如示例8-3所示。 // 示例8-3：使用push方法将值添加到动态数组中 let mut v = Vec::new(); v.push(5); v.push(6); v.push(7); v.push(8); 正如前文讨论过的，对于任何变量，只要我们想要改变它的值，就必须使用关键字mut来将其声明为可变的。由于Rust可以从数据中推断出我们添加的值都是i32类型的，所以此处同样不需要添加Vec&lt;i32&gt;的类型声明。 4. 销毁动态数组时也会销毁其中的元素 和其他的struct一样，动态数组一旦离开作用域就会被立即销毁，如示例8-4中的注释所示。
// 示例8-4：展示了动态数组及其元素销毁的地方 { let v = vec![1, 2, 3, 4]; // 执行与v相关的操作 } // &lt;- v在这里离开作用域并随之被销毁 动态数组中的所有内容都会随着动态数组的销毁而销毁，其持有的整数将被自动清理干净。这一行为看上去也许较为直观，但却会在你接触到指向动态数组元素的引用时变得有些复杂。让我们接着来处理这种情况！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4174011d9d7da556c5f39a4b1592c555/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e6db7ec4398bbb77208b9a441f95e4c/" rel="bookmark">
			服务器RAID管理之MegaRaid工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 MegaCli是一款管理维护硬件RAID软件，可以通过它来了解当前raid卡的所有信息，包括 raid卡的型号，raid的阵列类型，raid 上各磁盘状态等等。通常，我们对硬盘当前的状态不太好确定，一般通过机房人员巡检来完成，而MegaCli可以轻松通过远程完成硬盘类巡检。
一般通过 MegaCli 巡检到的Media Error Count: 0 Other Error Count: 0 这两个数值来确定阵列中磁盘是否有问题；Medai Error Count 表示磁盘可能错误，可能是磁盘有坏道，这个值不为0值得注意，数值越大，危险系数越高，Other Error Count 表示磁盘可能存在松动，可能需要重新再插入。
二、安装 LINUX版安装如下：
wget https://docs.broadcom.com/docs-and-downloads/raid-controllers/raid-controllers-common-files/8-07-14_MegaCLI.zip
uzip 8-07-14_MegaCLI.zip
rpm -ivh MegaCli-8.07.14-1.noarch.rpm
三、运维高频使用 【1】查raid级别、显示所有逻辑磁盘组信息
/opt/MegaRAID/MegaCli/MegaCli64 -LDInfo -Lall -aALL
【2】查raid卡信息 （可以查看raid卡时间，raid卡时间和系统时间可能不一致，raid卡日志用的是raid卡时间）
/opt/MegaRAID/MegaCli/MegaCli64 -AdpAllInfo -aALL
【3】查看硬盘信息 （查看磁盘有无坏道：Media Error Count ）
/opt/MegaRAID/MegaCli/MegaCli64 -PDList -aALL
【4】查看raid卡日志
/opt/MegaRAID/MegaCli/MegaCli64 -FwTermLog -Dsply -aALL
【5】显示Raid卡型号，Raid设置，Disk相关信息
/opt/MegaRAID/MegaCli/MegaCli64 -cfgdsply -aALL
【6】查看虚拟磁盘信息
/opt/MegaRAID/MegaCli/MegaCli64 -LdPdInfo -aALL |grep -E "Target Id|Slot Number|Firmware state"
Megacli查看硬盘状态，盘笼ID，slot以及是否是热备盘：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e6db7ec4398bbb77208b9a441f95e4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e558dece0bad57351b8e42b3af777160/" rel="bookmark">
			【读书笔记】《白帽子讲web安全》浏览器安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第二篇 客户端脚本安全
第2章 浏览器安全
2.1同源策略
2.2浏览器沙箱
2.3恶意网址拦截
2.4高速发展的浏览器安全
第二篇 客户端脚本安全 第2章 浏览器安全 近年来随着互联网的发展，人们发现浏览器才是互联网最大的入口，绝大多数用户使用互联网的工具是浏览器。（颇具年代感的开卷语）
“浏览器天生就是一个客户端。”
2.1同源策略 浏览器出于安全考虑，对同源请求放行，对异源请求限制，这些限制规则统称为同源策略。
浏览器对标签发出的跨域请求轻微限制，对AJAX发出的跨域请求严厉限制。
对于客户端web安全的学习与研究来说，深入理解同源策略非常重要，是后续学习的基础。
浏览器的同源策略，限制了来自不同源的“document”或脚本，对当前“document”读取或设置某些属性。
影响“源”的因素有：host（域名或IP地址，如果是IP地址则看作一个根域名）、子域名、端口、协议。
XMLHttpRequest受到同源策略的约束，不能跨域访问资源，在AJAX应用的开发中尤其需要注意这一点。如果XMLHttpRequest能够跨域访问资源，则可能会导致一些敏感数据泄露，比如CSRF的token，从而导致发生安全问题。
在浏览器中，&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;、&lt;form&gt;、&lt;audio&gt;、&lt;video&gt;等标签都可以跨域加载资源，而不受同源策略的限制。这些带“src”属性加载的资源，浏览器限制了js的权限，使其不能读、写返回的内容。
2.2浏览器沙箱 在网页中植入一段恶意代码，利用浏览器漏洞执行任意代码的攻击方式，在黑客圈子里被称为“挂马”。“挂马”是浏览器需要面对的一个主要威胁。
以下是一个简单的例子来说明挂马和XSS的区别：
假设有一个网站，其中有一个留言板功能，用户可以在上面留言。攻击者想要攻击使用该网站的用户，他们可以通过以下方式进行攻击：
挂马攻击：攻击者入侵该网站的后台，将恶意代码植入到留言板页面中。当用户访问留言板页面时，恶意代码会自动执行，从而攻击用户的计算机或移动设备。
XSS攻击：攻击者在留言板上留下一个恶意脚本，当其他用户访问该留言板页面时，恶意脚本会在其浏览器中执行。恶意脚本可能会窃取用户的会话信息等。
Sandbox即沙箱，计算机技术发展到今天，Sandbox已经成为泛指“资源隔离类模块”的代名词。Sandbox的设计目的一般是为了让不可信任的代码运行在一定的环境中，限制不可信任的代码访问隔离区外的资源。如果一定要跨越Sandbox边界产生数据交换，则只能通过指定的数据通道，比如经过封装的API来完成，在这些API中会严格检查请求的合理性。
2.3恶意网址拦截 恶意网址拦截的工作原理很简单，一般都是浏览器周期性地从服务器端获取一份最新的恶意网址黑名单，如果用户上网时访问的网址存在于此黑名单中，浏览器就会弹出一个警告页面。
常见的恶意网址分为两类：一类是挂马网站，这些网站通常包含有恶意脚本，在用户电脑中植入木马；另一类是钓鱼网站，通过模仿知名网站的相似页面来欺骗用户。
2.4高速发展的浏览器安全 微软在IE8中推出了XSS Filter功能，用以对抗反射型XSS。当用户访问的URL中包含了XSS攻击的脚本时，IE就会修改其中的关键字符使得攻击无法成功完成，并对用户弹出提示框。
Firefox推出了Content Security Policy(CSP)。这一策略做法时由服务器端返回一个http头，并在其中描述页面应该遵守的安全策略。（这种自定义的语法必须由浏览器支持并实现）
除了这些安全功能外，浏览器的用户体验也越来越好，随之而来的是许多标准定义之外的“友好”功能（如畸形URL修正），但很多程序员并不知道这些新功能，从而可能导致一些安全隐患。
浏览器加载的插件也是浏览器安全需要考虑的一个问题，扩展和插件极大地丰富浏览器功能，除了插件可能存在漏洞外，插件本身也可能会有恶意行为。扩展和插件的权限都高于页面js的权限，比如可以进行一些跨域网络请求等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/388e10a6459db07b290ff428d2c0d19a/" rel="bookmark">
			【读书笔记】《白帽子讲web安全》我的安全世界观
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
第1章 我的安全世界观
1.1 Web安全简史
1.1.1中国黑客简史
1.1.2黑客技术的发展历程
1.1.3web安全的兴起
1.2黑帽子，白帽子
1.3返璞归真，揭秘安全的本质
1.4破除迷信，没有银弹
1.5安全三要素
1.6如何实施安全评估
1.6.1资产等级划分
1.6.2威胁分析
1.6.3风险分析
1.6.4设计安全方案
1.7白帽子兵法
1.7.1Secure By Default原则
1.7.1.1黑名单、白名单
1.7.1.2最小权限原则
1.7.2纵深防御原则
1.7.3数据与代码分离原则
1.7.4不可预测性原则
1.8小结
前言： 即将考试周了，考前死盯着那几门复习不是我的作风，但花大功夫去学一些新的技术时间会有些吃紧。所以翻出这本尘封已久的道哥著作，挑战这本让三个月前的自己败下阵来的小部头，希冀每天有所思考有所沉淀，深化对web安全的理解。
冷静下来，暂时从具体的技术细节脱身，冷静审视安全本身为何。
“种一棵树的最好时间是十年前，其次是现在。”
第1章 我的安全世界观 1.1 Web安全简史 1.1.1中国黑客简史 在计算机安全领域，黑客是一群破坏规则、不喜欢被拘束的人，因此总想着能够找到系统的漏洞，以获得一些规则之外的权力。
不想拿到root的黑客，不是好黑客。
有的黑客，精通计算机技术，能自己挖掘漏洞，并编写exploit；而有的黑客，只对攻击本身感兴趣，对计算机原理和各种编程技术的了解比较粗浅，因此只懂得编译别人的代码，自己并没有动手能力，这种黑客被称为“Script Kids”，即“脚本小子”。
中国黑客的发展分为了：启蒙时代、黄金时代、黑暗时代。
启蒙时代：20世纪90年代，中国互联网刚刚处于起步阶段，这时候的黑客们多是由于个人爱好而走上这条道路，好奇心与求知欲驱使他们前进，没有任何利益瓜葛，崇尚分享、自由、免费的互联网精神。
黄金时代：以中美黑客大战为标志，各种黑客组织如雨后春笋般冒出。此阶段的中国黑客，其普遍的特点是年轻，有活力，充满激情，在技术上也许还不够成熟。此时期开始出现以盈利为目的的攻击，黑色产业链逐渐形成。
黑暗时代：大多数黑客组织没有坚持下来，在上一个时期非常流行的黑客技术论坛式微没落，所有门户型的漏洞披露站点也不再公布漏洞相关的技术细节。整个互联网笼罩在黑色产业链的阴影之下，纯粹的黑客精神（开放、分享）实质已经死亡。
1.1.2黑客技术的发展历程 因为早期的web技术发展远远不成熟，加之通过攻击系统软件，黑客们往往能直接获取root权限，所以初期黑客的攻击目标以系统软件居多。
在早期互联网中，web并非互联网的主流应用，因此黑客们主要的攻击目标是网络、操作系统以及软件等领域，web安全领域的攻击与防御技术均处于非常原始的阶段。
运营商、防火墙对于网络的封锁，使得暴露在互联网上的非web服务越来越少，且web技术的成熟使得web应用的功能越来越强大，最终成为了互联网的主流。黑客们的目光也渐渐转移到了web上。
1.1.3web安全的兴起 在web1.0时代，人们更多的是关注服务器端动态脚本的安全问题，比如将一个可执行脚本（俗称webshell）上传到服务器上，从而获得权限。
SQL注入的出现是web安全史上的一个里程碑，黑客们发现通过SQL注入攻击，可以获取很多重要的、敏感的数据，甚至能够通过数据库获取系统访问权限，这种效果不比直接攻击系统软件差。
XSS的出现则是web安全史上的另一个里程碑。
伴随着web2.0的兴起，XSS,CSRF等攻击已经变得更为强大。web攻击的思路也从服务端转向了客户端，转向了浏览器和用户。
web安全将紧跟着互联网发展的脚步，不断演化出新的变化。
1.2黑帽子，白帽子 在黑客的世界中，往往用帽子的颜色来比喻黑客的好坏。白帽子，是指哪些精通安全技术，但是工作在反黑客领域的专家们；而黑帽子，则是指利用黑客技术造成破坏，甚至进行网络犯罪的群体。
对于黑帽，只要能够找到系统的一个弱点，就可以达到入侵系统的目的；而对于白帽，必须找到系统的所有弱点，不能有遗漏才能保证系统不会出现问题。
从对待问题的角度来看，黑帽为了完成一次入侵，需要利用各种不同漏洞的组合来达到目的，是在不断地组合问题；而白帽在设计解决方案时，要不断分解问题，再对分解后的问题逐个予以解决。
随着防御技术的不断完善，攻击技术也在不断发展。谁能在技术上领先，谁就能占据主动。互联网技术日新月异，在新技术领域的发展中，也存在着同样的博弈过程。
1.3返璞归真，揭秘安全的本质 安全问题的本质是信任的问题。
一切安全方案设计的基础，都是建立在信任关系上的。我们必须相信一些东西，必须有一些最基本的假设，安全方案才能得以建立；如果我们否定一切，安全方案就会如无源之水，无根之木，无法设计，也无法完成。
把握信任条件的度，使其恰到好处，是设计安全方案的难点所在，也是安全这门学问的艺术魅力所在。
1.4破除迷信，没有银弹 在解决安全问题的过程中，不可能一劳永逸，即“没有银弹”。
安全是一个持续的过程。
自从互联网有了安全问题以来，攻击和防御技术就在不断碰撞和对抗的过程中得到发展。以不变的防御手段对抗不断发展的攻击技术，就犯了刻舟求剑的错误。
黑客们在不断地研究和寻找新的技术攻击，作为防御的一方，没有理由不持续跟进。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/388e10a6459db07b290ff428d2c0d19a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54e32c37c0aee228f3e3fcccc0552ac7/" rel="bookmark">
			System学习笔记 - MacOs编译环境配置(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 好几年没有记录过东西，一是确实很忙，二是人也变懒了。新年开个新的学习计划，希望能坚持下去。
SystemC 简介 SystemC是一个建模语言，其本质是一个C++的库，一般用于SoC建模，具体介绍不赘述，百度都可以搜到，这里只讲怎么使用配置
代码下载 可以去systemc.org下载，也可以直接从github.com下载。我使用的是 git@github.com:accellera-official/systemc.git。
INSTALL 下载下来后，systemc目录下就有一个INSTALL.md描述如何编译安装SystemC，以下的内容其实也就是在复述整个过程。
编译环境 使用的是Macos的Clang作为Systemc的编译器，CPU ARCH是X86
Apple clang version 14.0.3 (clang-1403.0.22.14.1) Target: x86_64-apple-darwin22.6.0 Thread model: posix InstalledDir: /Library/Developer/CommandLineTools/usr/bin 1 配置CXX环境变量
2 在systemc目录下输入./config/bootstrap生成配置文件
3 在systemc目录下创建编译文件夹objdir，并切到该文件夹下
4 在objdir目录下，使用…/configure ‘CXXFLAGS=-std=c++17’ --prefix=XXXXXX来生成configure配置，其中CXXFLAGS是指定c++17，这是systemc要求的。prefix是指定systemc的安装目录。
5 make即可完成安装
make make check make install 6 验证example下的内容
6.1 修改配置文件，主要修改的是Makefile.config中的配置。
Makefile.rules中的SYSTEMC_LDFLAGS暂时没看懂LD的啥，先删掉，不然报错
diff --git a/examples/build-unix/Makefile.config b/examples/build-unix/Makefile.config index a4643291..d0d4635f 100644 --- a/examples/build-unix/Makefile.config +++ b/examples/build-unix/Makefile.config @@ -34,13 +34,13 @@ ## guess config from environment ## Variable that points to SystemC installation path -SYSTEMC_HOME?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54e32c37c0aee228f3e3fcccc0552ac7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a1f939e38572fcd6b85a4583bb81e18/" rel="bookmark">
			双十一的祈祷【算法赛】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 双十一，不仅是购物狂欢节，更有 "光棍节" 之称。这源于 11:1111:11 由四个 11 构成，象征着单身。
作为大学生的小蓝也想经历甜甜的校园恋爱，于是他找到了爱神丘比特，向他祈祷能为自己带来一段邂逅。
丘比特是乐于助人的，他承诺小蓝只要回答出一个简单的数学问题，就完成小蓝的愿望。
问题是： 111111111111 的 个位数 是多少？
作为小蓝的好朋友，为了小蓝的幸福，请你帮忙解决这个问题。
注意：使用阿拉伯数字作答。
输入格式 本题为填空题，无需输入即可作答（当然如果你单身，你也可以读入一个字符串看看是否有惊喜）。
输出格式 输出一个数字，表示答案。
提示 1×1=11×1=1。
运行限制 语言最大运行时间最大运行内存C++1s256MC1s256MJava2s256MPython33s256MPyPy33s256MGo3s256MJavaScript3s256M 总通过次数: 2225 | 总提交次数: 2300 | 通过率: 96.7%
思路分享：这题是一个数学问题，用数学思路的欧拉定理去做就可以了。 1.基本概念
在证明欧拉定理之前需要先了解几个知识点
1.1 质数
质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数（规定1既不是质数也不是合数）。在数学界，关于质数的研究非常多,最著名便是哥德巴赫猜想
1.2 公约数
公约数，亦称“公因数”。它是指能同时整除几个整数的数 。如果一个整数同时是几个整数的约数，称这个整数为它们的“公约数”；公约数中最大的称为最大公约数。对任意的若干个正整数，1总是它们的公因数。
最大公约数可记为gcd（）或（）。
1.3 互质
互质是公约数只有1的两个整数，叫做互质整数。公约数只有1的两个自然数，叫做互质自然数，后者是前者的特殊情形。例如，3与5的公约数只有1，所以它们是互质的。可以记为gcd（3,5）=1.
1.4 同余
同余是数论中的重要概念。给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，即(a-b)/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。对模m同余是整数的一个等价关系。
1.5 完全剩余系
命 m 为一个自然数，a，b为整数。如果 为 n 的整数倍，则称 a，b 关于 n 同余，用同余式 a ≡ b(mod m) 记之。否则称a，b关于 n 不同余，记为 a ≢ b（mod m）。我们称 n 为同余式的模（modulus）。同余式满足：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a1f939e38572fcd6b85a4583bb81e18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5a6903c3fb926d73eab65d11b9243c3/" rel="bookmark">
			超维空间M1无人机使用说明书——61、ROS无人机yolo识别与投放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 引言：使用yolo进行物体识别，根据返回的目标位置信息，控制无人机全向移动，当无人机到达目标物的正上方，满足一定的误差阈值后，ROS发布控制控制将舵机挂载的物体抛下，紧接着无人机前往起飞点上方寻找降落的目标点降落。 一、一键启动识别与投放程序 roslaunch robot_bringup bringup_precise_drop.launch 未出现红色报错，表明程序运行正常 launch文件详解 launch文件启动了四个节点，节点作用如下 1、mavros通信节点，实现底层PX4和ROS通信 2、启动USB摄像头节点，提供图像数据 3、启动yolo识别节点 4、启动坐标转换节点，该节点会将识别到的目标物体的的中心位置以话题的方式打印出来 5、启动运动控制节点，该节点定位实时的目标物体的位置信息，进行运动控制，直到满足允许误差的阈值 二、视频演示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9452c892921a3c1ae948f710fe39d4ec/" rel="bookmark">
			C语言排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序的过程就是增加有序度，减少逆序度，最终达到满有序度
冒泡排序 #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; #define N 10 void swap(int arr[],int i,int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } void bubble_sort(int arr[],int n) { //i表示冒泡的次数 for(int i = 0;i &lt; N;i++) { bool isSorted = true; for(int j = 0;j &lt; N-i;j++) { if(arr[j] &gt; arr[j+1]) {//不能写成 &gt;= swap(arr,j,j+1); isSorted = false; } } if(isSorted) return ; } } 时间复杂度
最好情况：数组有序，O(n)
比较次数：n-1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9452c892921a3c1ae948f710fe39d4ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b42b7baff964a9420950701f54a84927/" rel="bookmark">
			linux 进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程 1.进程就是运行中的程序，一个程序可能存在多个进程，每个进程都在执行特定的任务。 2.进程一般可分为交互进程，批处理进程和守护进程三类。 3.在Linux中可以通过ps指令查看进程信息。 4.孤儿进程：父进程先于子进程结束，则子进程则会成为孤儿进程，同时被init进程收养。 5.僵尸进程：子进程咸鱼父进程结束，但父进程没有回收子进程的相关资源。 常用函数接口 #include &lt;unistd.h&gt; 1.getpid(); //获取进程id 2.getppid();//获取父进程id 3.getuid();//获取实际用户id 4.geteuid();//获取有效用户id 5.getgid();//获取实际组id 6.getegid();//获取有效组id 7.fork();//创建一个子进程，失败返回-1，分别在父子进程返回pid，子进程有父进程的数据段和堆栈，切共享父进程的代码段，并且共享文件表。 8.vfork();//创建一个子进程，与fork()区别为vfork()并不复制父进程的地址空间，并且子进程会优先调度。 8.exit(int status);//进程退出 9.pid_t wait(int *status);//等待子进程结束 10.pid_t waitpid (pid_t pid, int* status, int options);//一般用于等待特定子进程 //pid ：-1（任意一个子进程），0（同一个进程组的任意子进程，&gt;0(特定子进程)） //status；通过输出参数status返回给调用者，不关心可值为NULL //options:一般取0，如果有需求，可以如下 /* •WNOHANG 非阻塞模式，若没有可用的子进程状态，则返回0。 ◦WUNTRACED 若支持作业控制，且子进程处于暂停态，则返回其状态。 ◦WCONTINUED 若支持作业控制，且子进程暂停后继续，则返回其状态。 */ /* •WIFEXITED() 子进程是否正常终止，是则通过WEXITSTATUS()宏，获取子进程调用exit/_exit/_Exit函数，所传递参数的低8位。 因此传给exit/_exit/_Exit函数的参数最好不要超过255。 •WIFSIGNALED() 子进程是否异常终止，是则通过WTERMSIG()宏获取终止子进程的信号。 •WIFSTOPPED() 子进程是否处于暂停，是则通过WSTOPSIG()宏获取暂停子进程的信号。 •WIFCONTINUED() 子进程是否在暂停之后继续运行 */ 例子 #include &lt;stdio.h&gt; #include &lt;errno.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/wait.h&gt; void checkStatus(int status){ if(WIFEXITED(status)){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b42b7baff964a9420950701f54a84927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6ec3fa9c74adab5137d4382a7823d6/" rel="bookmark">
			python-os模块使用以及文件查找功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python-os模块使用以及文件查找功能 1. os模块使用 os.getcwd() : 当前程序的绝对路径os.listdir(路径)：获取路径下的所有内容，返回一个list print(os.getcwd) ''''E:\\test'''' print(os.list('C:\\')) ''' ['$360Section', '$baksd', '$Recycle.Bin', '$WinREAgent', 'AMTAG.BIN', 'Aomei', 'bootmgr', 'BOOTNXT', 'Config.Msi', 'Documents and Settings', 'DumpStack.log', 'DumpStack.log.tmp', 'hiberfil.sys', 'HP_LaserJet_Pro_MFP_M426-M427', 'Intel', 'KingsoftData', 'pagefile.sys', 'PerfLogs', 'Program Files', 'Program Files (x86)', 'ProgramData', 'Python27', 'Recovery', 'swapfile.sys', 'System Volume Information', 'TsdTemp', 'Users', 'Windows', 'XmpCache'] ''' 2. os.path模块使用 有个习惯说明一下：路径最后补上/或者\，这样会能保证不会出错。
os.path.abspath(路径) ： 返回绝对路径os.path.dirname(路径) ： 按照最后一个/、\切割的前部分os.path.basename(路径) ：按照最后一个/、\切割的后部分os.path.join(路径1， 路径2)：路径拼接。os.path.isfile(路径) ： 判断是否是文件os.path.isdir(路径) ： 判断是否是文件夹 print(os.path.abspath('./')) # E:\\test print(os.path.dirname('E:\\test')) # E:\ print(os.path.basename('E:\\test')) # test print(os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb6ec3fa9c74adab5137d4382a7823d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a492bb5aad919f836f2d31e5dc22e7a4/" rel="bookmark">
			深度学习：解决CNN的困境——胶囊网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从2017年底到2018年初，整个人工智能学术研究领域谈论最多的应该就是被誉为深度学习之父Geoffrey E. Hinton 发表的论文 Dynamic Routing Between Capsules,其中介绍了全新的深度学习模型——胶囊网络（Capsule Network）
1. 普通CNN的困境 虽然CNN在图像识别领域取得了巨大成功并掀起了深度学习浪潮，Hinton指出CNN的工作方式与人类大脑大相径庭，继续沿着CNN的“卷积——池化”模型进行同构扩展无法达到更高的智能水平。
相对于普通神经网络，CNN的主要创新在于用卷积层自动提取各层级的特征并用这些特征进行最终预测。然而卷积层使得神经元数量大量增加，在提取特征后必须用池化层（一般为Max-pooling）进行数据降维才形成最终特征，由此带来的问题是：
Max-pooling 使得卷积层中的非局部最大点的信息丢失Max-pooling 丢失了卷积识别出的特征在位置与角度等方面的信息。 第一条并非完全是一个缺点，它在某种程度上增加了网络的鲁棒性；但第二条会带来大问题，即它使得后续的处理无法识别特征之间的位置关系。
观察图9-48（左），其中有四个几何特征：大矩形、小矩形、两个圆形，神经网络可以通过这四个特征学习到它是一辆汽车。但如果丢失了这些特征的位置信息，则很可能将同样具有这四个特征的图9-48（右）也识别成一辆汽车。
2. 什么是胶囊 产生CNN困境的根本原因是在普通神经网络中执行运算的基本单位——神经元（neural）——处理的数据是标量（scalar），在卷积层后用抛弃神经元的方式降低数据复杂度直接丢失了很多信息。
而在新的架构中，承载运算的基本单元——胶囊（capsule）——处理的数据变成了向量（vector）,用向量的线性变换降低数据复杂度使得所有信息都能够参与其中。
这个改变推翻了沿用了几十年的基于神经元的网络计算方法，产生了全新的基于向量的胶囊运算流程。胶囊与传统神经元的运算方式对比如图9-49所示。
对该图解释如下：
胶囊的输入与输出均是向量，神经元输入与输出均是标量。胶囊中的参数是矩阵，用于对输入向量进行线性变换，从物理的角度理解就是做旋转、位移、缩放等处理，这部分功能是传统神经元中的缺失。 胶囊中的参数是标量，作用相当于普通神经网络中的，用于衡量每个输入的重要性。普通神经元用各种 函数做非线性变换，而胶囊用所谓的 函数对向量进行非线性变换。 在Hinton的论文中采用的 函数形如 ，该函数保持向量方向不变，而只改变向量的长度。在胶囊网络中，向量的方向用于定义某种特征，而向量的长度用于表示该特征存在的可能性，因此可以将 函数理解为对预测置信度的调整与归一化。
3. 网络架构 论文在提出了胶囊的概念后设计了一个用于识别MNIST（数字手写图像库）的胶囊网络架构，如图9-50所示。
对该网络解释如下：
通过卷积层对原始图像进行特征提取，形成256个 feature map与普通CNN不同的是，在卷积层后没有使用池化层进行数据降维，而是使用胶囊层 PrimaryCaps。由于卷积层有256个 feature map，因此胶囊层的每个输入向量是256维，即图9-49中的 等都是256维向量。与卷积层每个神经元从原始图像中的某个局部区域扫描特征类似，每个胶囊也从上一层的某局部区域的向量获得输入，论文中每个 PrimaryCaps 中的胶囊有个输入向量，即图9-49中的输入向量个数n等于81。PrimaryCaps 中共有 个胶囊，每个胶囊输出 8 维向量。 因此，卷积层中的标量数值共有 个，而 PrimaryCaps 中的标量数值共有 个，达到了相当于池化层的降维目的，并且不会丢失卷积层中特征的位置信息。
在 PrimaryCaps 之后可以连接任意胶囊层继续搭建网络，其意义与在CNN中用多个卷积层逐层提炼更高级别知识的作用类似。
此外，论文中还提到了胶囊网络参数新的训练方法——动态路由算法（Dynamic Routing Algorithm），它用于替代传统网络中的反向传播对图9-45中的参数进行训练，有兴趣的读者可以研读原论文。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9b5c7f58d49330125577e07273aa5de/" rel="bookmark">
			docker安裝gocd-server，并配置gitlab授权登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gocd的地址：Installing GoCD server on Windows | GoCD User Documentation
gocd文档：GitHub - gocd/docker-gocd-server: Docker server image for GoCD
一、docker拉取gocd镜像
#拉取server镜像 docker pull gocd/gocd-server:v21.1.0 docker pull gocd/gocd-server:v23.5.0 #拉取agent镜像 docker pull gocd/gocd-agent-alpine-3.12 docker pull gocd/gocd-agent-alpine-3.12 二、创建gocd-server容器，在创建gocd-server的时候还需要安装两个插件，一个是通过将镜像保存到外部的插件，另外一个是使用gitlab登录的插件，这两个插件包是：
docker-registry-artifact-plugin-1.3.0-138.jar
gitlab-oauth-authorization-plugin-2.1.0-205.jar
下面有下载地址，下载完之后，通过挂载的方式挂载到docker，使用dockers -v
##先下载jar包 https://github.com/gocd/docker-registry-artifact-plugin/releases/download/v1.3.0-138-exp/docker-registry-artifact-plugin-1.3.0-138.jar https://github.com/gocd-contrib/gitlab-oauth-authorization-plugin/releases/download/v2.1.0-205/gitlab-oauth-authorization-plugin-2.1.0-205.jar ##然后创建目录,这个目录自己随便建 mkdir /root/devops/gocd/plugins ##给这个目录授权，因为gocd在启动的时候会在这个目录里面创建其他目录 chmod 777 /root/devops/gocd/plugins ##然后在/root/devops/gocd/plugins下创建一个external目录 mkdir external ##把前面的两个jar包放到eternal目录下 ##然后把创建的目录指定到/godata/plugins这个目录是放插件的地方 docker run -p 8153:8153 --name gocd-server -v /root/devops/gocd/plugins:/godata/plugins -e GOCD_SERVER_PORT=8153 -d gocd/gocd-server:v21.1.0 三、访问gocd-server，地址：http://ip:8153/
四、开始设置gitlab登录
第一步点击“Authorization Configurations”
第二步点击“Add”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9b5c7f58d49330125577e07273aa5de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/139aa15a6e3ac9704789278000167da1/" rel="bookmark">
			第三十八周周报：文献阅读 &#43;BILSTM&#43;GRU&#43;Seq2seq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
Abstract
文献阅读：耦合时间和非时间序列模型模拟城市洪涝区洪水深度
现有问题
提出方法
创新点
XGBoost和LSTM耦合模型
XGBoost算法
​编辑
LSTM（长短期记忆网络）
耦合模型
研究实验
数据集
评估指标
研究目的
洪水深度预测
实验结果
LSTM变体
Bidirectional LSTM（双向LSTM）
GRU（门循环控制单元）
Seq2seq模型
编码器-解码器（encoder-decoder）架构
Seq2seq训练
双向LSTM对乘客数量进行预测
摘要 本周阅读的文献，提出了一种基于XGBoost和LSTM算法的城市洪泛区洪水模拟耦合模型，该模型强调降雨和雨后洪水的全过程，利用降雨数据构，通过XGBoost算法构建非时间序列回归模型来模拟和预报洪水深度，降雨后，通过LSTM算法利用时间序列原理，在降雨后进行持续预测。有效的预测洪水深度，解决了雨后洪水深度预测问题。双向LSTM通过两层LSTM可以提供更丰富的上下文信息，将前向和后向的输出进行拼接得到最终结果，可以获得更全面的序列信息。GRU在LSTM的基础上简化门控即减少了参数，从而有效降低过拟合的风险，减小了时间、空间复杂度的负担。Seq2seq模型常用的就是LSTM或者GRU作为编码-解码结构，用于通过一个序列生成另一个序列，且两者之间不等长，常用于机器翻译等。
Abstract The literature read this week proposes a coupled model for urban flood simulation based on XGBoost and LSTM algorithms. The model emphasizes the entire process of rainfall and post rainfall floods, and uses rainfall data to construct a non time series regression model using XGBoost algorithm to simulate and predict flood depth.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/139aa15a6e3ac9704789278000167da1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c4bc51071ab05860f00f4bfdc493a2c/" rel="bookmark">
			PyTorch|构建自己的卷积神经网络——nn.Sequential()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在构建神经网络时，我们一般是采用这种方式，就像这样：
class Network1(nn.Module): def __init__(self): super(Network1,self).__init__() self.conv1 = nn.Conv2d(in_channels=3, out_channels=6, kernel_size=5) self.conv2 = nn.Conv2d(in_channels=6, out_channels=12, kernel_size=5) self.fc1 = nn.Linear(in_features= 12*20*20, out_features=120) self.out = nn.Linear(in_features=120, out_features=10) def forward(self, t): t=self.conv1(t) t=self.conv2(t) t=t.flatten(start_dim=1) t=self.fc1(t) t=self.out(t) return t 在__init__()模块中，一系列的层被定义，比如卷积层，全连接层...在forward()方法中，我们对这些层进行操作，使得数据在网络中进行传播。
随着层的增加，以及池化操作，激活函数操作的增加，代码似乎变得很复杂。
在PyTorch中，提供了一种序列容器，叫做nn.Sequential(),它可以按照网络模块被添加的顺序依次执行。
于是上面的代码可以以这样的方式重写：​​​​​​​
class Network2(nn.Module): def __init__(self): super(Network2,self).__init__() self.layer1=nn.Sequential(nn.Conv2d(in_channels=3, out_channels=6, kernel_size=5), nn.Conv2d(in_channels=6, out_channels=12, kernel_size=5), nn.Flatten(), nn.Linear(in_features= 12*20*20, out_features=120), nn.Linear(in_features=120, out_features=10) ) def forward(self,t): t=self.layer1(t) return t 让我们将一张图片输入到这两个网络中，看看会发生什么？​​​​​​​
path="E:\\3-10\\input1.jpg"img=Image.open(path)img=img.resize((28,28))#改变图片尺寸img=np.array(img)#转换为ndarrayimg=torch.tensor(img,dtype=torch.float32)#转换为张量img=img.permute(2,0,1)#改变维度顺序 img=img.unsqueeze(0)#增加批次维度img.size()​​​​​​ torch.manual_seed(10)#随机数种子net1=Network1()torch.manual_seed(10)net2=Network2()net1(img),net2(img) (tensor([[ 8.6586, 5.6796, -10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c4bc51071ab05860f00f4bfdc493a2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46832472c537b4bb4dd8097bb7af752f/" rel="bookmark">
			【LeetCode739】每日温度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、题目描述 【题目链接】
给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。
示例 1:
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
示例 2:
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
示例 3:
输入: temperatures = [30,60,90]
输出: [1,1,0]
提示：
1 &lt;= temperatures.length &lt;= 105
30 &lt;= temperatures[i] &lt;= 100
2、基本思路 如果采用最简单最暴力的方法，就是从当前位置i的下一个位置i+1出发，找到第一个j，使得temperatures[j] &gt; temperatures[i]，这种方法最坏情况得时间复杂度为O(n^2)。那么，有没有更好得方法呢？答案是有的。
采用单调栈的方法，维护一个从栈底到栈顶单调递减的序列，举个简单的例子，例如温度序列为【1，4，3，5，5，2，3，6】
初始化，栈空；首先，栈空，1入栈（栈中元素[1]）;第二个数4，与栈顶元素1比较，1&lt;4，则出栈，且答案为res[1]=1，栈空结束比较，4入栈（栈中元素[4]）；第三个数3，与栈顶元素4比较，4&gt;3，3入栈；（栈中元素[4,3]）；第四个数5，与栈顶元素3比较，3&lt;5，3出栈，答案为res[3]=1；（栈中元素[4]）；栈非空，继续与栈顶元素比较，4&lt;5，4出战，答案为res[2]=2；（栈中元素[]）；栈空，5入栈（栈中元素[5]）；第五个元素5，与栈顶元素5比较，5&gt;=5，5入栈，（栈中元素[5，5]）；第六个元素2，与栈顶元素5比较，5&gt;2，2入栈，（栈中元素[5，5，2]）；第七个元素3，与栈顶元素2比较，2&lt;3，2出栈，且答案为res[6]=1，（栈中元素[5，5]）；栈非空,继续与栈顶元素5比较，5&gt;3，3入栈，（栈中元素[5，5，3]）；第八个元素6，与栈顶元素3比较，3&lt;6，3出栈，且答案为res[7]=1，（栈中元素[5，5]）；栈非空，与栈顶元素5比较，5&lt;6，5出栈，且答案为res[4]=4，（栈中元素[5]）；栈非空，与栈顶元素5比较，5&lt;6，5出栈，且答案为res[5]=3，（栈中元素[]）；栈为空且序列遍历结束
最终答案为[1,2,1,4,3,1,1,0] 同样，我们也可以维护一个从栈底到栈顶维护一个单调递减的序列，遍历的序列从右往左。
单调栈的基本思想——及时去掉无用的数据，保证栈中数据有序
3、代码实现 方法一 vector&lt;int&gt; solve1(vector&lt;int&gt; &amp;temperatures) { int n = temperatures.size(); vector&lt;int&gt; res(n,0); stack&lt;int&gt; st; for(int i =0;i&lt;n;++i) { int t = temperatures[i]; while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46832472c537b4bb4dd8097bb7af752f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7b210d0c86996c347ff863852226f74/" rel="bookmark">
			Pytorch 反向传播 计算图被修改的报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看看报错的内容
RuntimeError: one of the variables needed for gradient computation has been modified by an inplace operation: [torch.FloatTensor [5, 1]], which is output 0 of AsStridedBackward0, is at version 2; expected version 1 instead. Hint: enable anomaly detection to find the operation that failed to compute its gradient, with torch.autograd.set_detect_anomaly(True).
报错中说，一个需要梯度计算的变量已经被原地修改了，这引发了报错。
torch.set_grad_enabled(True) 然后我使用上述语句开启了梯度跟踪，发现问题出在我的标签计算函数：
def get_label(net, X): return net(X).reshape((-1, 1)) 为什么会出错呢？在这种情况下，由于 label 是从网络输出直接计算得到的，它与网络的计算图相连接。如果在 label 上进行了原地操作（上述的修改形状操作），就可能破坏计算图，使其不可导或其他，总之是导致反向传播时无法正确计算梯度，从而引发报错。
那怎么解决这个问题？将该结果与计算图进行分离就行了，此刻如果再进行反向传播，梯度就不会传播到此处。修改后，代码如下;
def get_label(net, X): return net(X).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7b210d0c86996c347ff863852226f74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d596b963b99629995bdd1fec12947a78/" rel="bookmark">
			freemarker模板生成的word文档优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 通过freemarker模板生成的word文档实际上不是真正意义上的ms word标准文档，它仍然是xml文件，而docx实际上是一个压缩文件。所以使用以下方法对freemarker模板生成的word进行优化，保证生成的文件是真正意义上的ms word标准文档。 解决方案 使用压缩工具打开docx模板，取出document.xml，如下图：
将用压缩工具打开后的docx文档里面的document.xml复制出来，并将document.xml后缀改为.ftl，然后进行参数预设。将内容格式化后修改需要替换的内容为freemarker标签，对document.ftl进行参数预设，如下图：
文件准备好后存放到某个目录下，docx文件为将要生成好的docx文件样式模版，必须要有的。如下图：
程序代码 import freemarker.template.Configuration; import freemarker.template.Template; import java.io.*; import java.util.Enumeration; import java.util.HashMap; import java.util.Map; import java.util.zip.ZipEntry; import java.util.zip.ZipFile; import java.util.zip.ZipOutputStream; public class Main { public static void main(String[] args) { //模版文件存放目录 String templatepath = "E:/test/"; //模版样式文件名 String docxname = "document.docx"; //模版xml文件 String xmlname = "document.xml"; //替换freemarker标签后的临时xml文件 String tmpxmlpath = "E:/test/temp.xml"; //最终生成的docx文件 String targetpath = "E:/test/final.docx"; // 数据 Map&lt;String,Object&gt; data = new HashMap(); data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d596b963b99629995bdd1fec12947a78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/685d58ea5f6cd85b35c099c976f146e0/" rel="bookmark">
			十、基本对话框大集合（Qt5 GUI系列）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、设计需求
二、实现代码
三、代码解析
四、总结
一、设计需求 Qt提供了很多标准的对话框。例如标准文件对话框(QFileDialog)、标准颜色对话框(QColorDialog)、标准字体对话框 (QFontDialog)、标准输入对话框 (QInputDialog) 及消息对话框 (QMessageBox)。本文展示各种对话框的简单使用方法以及自定义消息框。
二、实现代码 main文件：
#include "dialog.h" #include &lt;QApplication&gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); Dialog w; w.show(); return a.exec(); } dialog文件：
#ifndef DIALOG_H #define DIALOG_H #include &lt;QDialog&gt; #include &lt;QLineEdit&gt; #include &lt;QGridLayout&gt; #include "inputdlg.h" #include "msgboxdlg.h" class Dialog : public QDialog { Q_OBJECT public: Dialog(QWidget *parent = 0); ~Dialog(); private: QPushButton *fileBtn; QLineEdit *fileLineEdit; QGridLayout *mainLayout; QPushButton *colorBtn; QFrame *colorFrame; QPushButton *fontBtn; QLineEdit *fontLineEdit; QPushButton *inputBtn; InputDlg *inputDlg; QPushButton *MsgBtn; MsgBoxDlg *msgDlg; QPushButton *CustomBtn; QLabel *label; private slots: void showFile(); void showColor(); void showFont(); void showInputDlg(); void showMsgDlg(); void showCustomDlg(); }; #endif // DIALOG_H #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/685d58ea5f6cd85b35c099c976f146e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4634dab9f1838f40a507168e716a654e/" rel="bookmark">
			Python：sqlalchemy报错DetachedInstanceError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlalchemy 对象commit之后再使用就会报错
DetachedInstanceError 既然这样，提交后还需要使用，就拷贝一个副本出来
一个思路是
# -*- coding: utf-8 -*- """ @File : sqlalchemy_util.py @Date : 2024-01-07 @Author : Peng Shiyu """ from datetime import datetime from sqlalchemy.orm import class_mapper from utils import time_util def to_json(model): columns = [column.key for column in class_mapper(model.__class__).columns] item = {} for column in columns: item[column] = getattr(model, column) return item def copy(source, target=None): """ 属性浅拷贝 :param source: object :param target: Model / dict :return: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4634dab9f1838f40a507168e716a654e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee26051defaef4e3d9ba36c1a5c9f6d4/" rel="bookmark">
			SpringCloud系列篇：核心组件之配置中心组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🥳🥳Welcome Huihui's Code World ! !🥳🥳 接下来看看由辉辉所写的关于SpringCloud的相关操作吧
目录
🥳🥳Welcome Huihui's Code World ! !🥳🥳
一.前言
二.配置中心组件是什么
三. 为什么要使用配置中心组件
四.使用配置中心组件的步骤 1.引入依赖
2.进入nacos编写配置
3.读取配置 4.不同环境下的配置
一.前言 微服务意味着要将单体应用中的业务拆分成一个个子服务,每个服务的粒度相对较小,因此系统中会出现大量的服务。 由于每个服务都需要必要的配置信息才能运行,所以一套集中式的,动态的配置管理设施是必不可少的。 Spring Cloud 提供了 ConfigServer来解决这个问题. Spring Cloud Config 为微服务架构中的微服务提供集中化的外部配置支持,配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。 SpringCloud Config 分为服务端和客户端两部分。
服务端也称为分布式配置中心,他是一个独立的微服务应用,用来连接配置服务器并为客户端提供获取配置信息,加密/解密信息等访问接口。
客户端则是通过制定的配置中心来管理应用资源,以及与业务相关的配置内容,并在启动的时候从配置中心 获取和加载配置信息，配置服务器默认采用git来存储配置信息,这样就有助于对环境配置进行版本管理,并 且可以通过git客户端工具来方便的管理和访问配置内容
一个使用微服务架构的应用系统可能会包括成百上千个微服务,配置各部相同,需求各不相同：
不同环境不同配置：例如数据源在不同的环境（开发,测试,生产）是不同的,可以通过配置中心运行期间可以动态调整：例如根据各个微服务的负载状况,动态调整数据源连接池大小或者熔断阀 值,并且调整时不停止微服务（配置修改后可以自动更新） 二.配置中心组件是什么 配置中心组件是一种用于管理应用程序配置信息的工具或服务。它通常可以集中存储应用程序的各种配置数据，如数据库连接字符串、API密钥、环境变量等，以便方便地进行配置管理和维护。使用配置中心组件可以大大简化应用程序的部署和维护工作，同时也有助于提高应用程序的可靠性和安全性。常见的配置中心组件包括Spring Cloud Config、Consul、Zookeeper等
三. 为什么要使用配置中心组件 这里我还是列举一些场景，来便于理解吧
我们在生产环境部署的时候，为了服务的可用性以及负载，通常一个服务会启动多个实例,要么在不同的机器 要么在相同机器不同端口…【例如 商品服务启动4个，订单服务启动4个，用户服务启动N个，文件上传服务启动X个等等…】
当服务启动的时候便会去加载自己的配置文件application.properties或者application.yml
一气呵成…这本身，是没有问题的。但是我们总会面临因业务更改导致配置文件需要新增/修改/删除属性…那么在这样的场景中，我们该如何面对呢？？
是选择更改配置文件后，从新打包部署？
还是将配置文件存放部署的服务机器某路径上，更改保存再重启服务？
两种方式对比的话，第二种方式可能效率更高一点。但是我们微服务通常又是使用容器化部署，如果保存在宿主机某一处的话，也是涉及到目录挂载问题的，且在服务器上，也不方便多个服务统一管理…
这时候，咱们统一的配置中心就横空出世啦！！！
四.使用配置中心组件的步骤 1.引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; 2.进入nacos编写配置 关于nacos的下载，在之前的博文中已经提及了nacos的使用
点击发布即是编写好了这个配置文件，那么再配置列表中便可以看到刚刚所写好的这个配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee26051defaef4e3d9ba36c1a5c9f6d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74cf1e270f44c9d5dc306fbe90053162/" rel="bookmark">
			【Flutter 开发实战】Dart 基础篇：从了解背景开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要学会用 Flutter 开发 App，就不可避免的要学习另一门很有意思的编程语言 —— Dart。很多小伙伴可能在学习 Flutter 之前可能都没听说过这门编程语言，我也是一样，还以为 Dart 是为了 Flutter 而诞生的；然而，当我们去了解一下 Dart 的背景，就会发现 Dart 的神奇之处。
Dart 的起源与背景 Dart 并非是瞬间涌现的奇迹，而是经过岁月的沉淀和 Google 的不懈努力而形成的。起源于 2011 年的 Dart，初衷是解决当时前端开发中普遍存在的问题。过去的 JavaScript 时代，开发者们为了应付性能不佳、代码难以维护的挑战，苦不堪言。于是，Dart 应运而生，以其优雅的语法和强大的特性，为开发者们带来一线曙光。
Dart 并非只是一门语言，更是一种对未来的探索，对编程艺术的追求。Google 对 Dart 的投入和扶持，为这门语言奠定了坚实的基础。在不断的升级和改进中，Dart 迅速崭露头角，成为现代软件开发中备受关注的焦点。
Dart 是一门很好的语言，但是 JavaScript 作为一门最早应用于网页前端的编程语言，有着较长的历史，拥有更多的知识沉淀以及优秀的开源项目，无需花费更多去成本学习以及开发一个合适的前端应用（简单来说就是成本低），所以国内很少见到 Dart 的广泛应用。
Dart 的优势 尽管在国内 JavaScript 更为流行，但 Dart 作为一门语言仍然具有一些独特的优势，特别是在移动应用开发领域，其与 Flutter 框架的默契搭配使其愈发引人注目。
1. 优雅的语法设计 Dart 的语法设计注重直观性和一致性，使得代码更加清晰易读。相比 JavaScript，Dart 的语法更加优雅，更容易让初学者理解和上手。
void main() { print('Hello, Dart!'); } 这样的简单代码就展示了 Dart 的语法之美，让人感受到一种愉悦的编程体验。
2. 强大的类型系统 Dart 是一门强类型语言，这意味着在编译时就能够捕获很多潜在的错误，提高代码的稳定性和可维护性。类型检查可以帮助开发者更早地发现潜在问题，减少运行时错误。
String greet(String name) { return 'Hello, $name!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74cf1e270f44c9d5dc306fbe90053162/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7643169bd4a3b389c3fd0a06ba6cdcd8/" rel="bookmark">
			api 接口测试工具：Postman、Apifox、Apipost、api压测(locust)、locust爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Postman：支持离线使用，未登录状态下，以及内网环境下，都可以正常进行大部分操作
Apipost：支持离线使用，未登录状态下，以及内网环境下，都可以正常进行大部分操作。
apifox：不支持离线，而且不登录没法用。
1、Postman From：https://zhuanlan.zhihu.com/p/534078123
Postman V9.16 绿色版汉化：https://www.cr173.com/soft/1497202.html
一、postman 简介 Postman 是一款功能强大的网页调试与发送网页HTTP请求的工具。有 Chrome 插件版本，也有Postman 本地应用程序版本，插件版本早已停止更新。详细了解为什么支持 Postman Chrome 应用程序已被弃用？：http://chromecj.com/web-development/2018-04/1376.html
postman 的特点 postman 只做 http协议 的接口的测试，是一种最广泛 REST 接口测试客户端软件。postman 支持 http 协议的所有请求方式，包括 get、post、head、put、delete 等。postman 支持各种额外的头部字段的添加。postman 除了可以模拟普通表单数据外，还支持文件、图片、视频等数据请求。postman 是一个接口的开发和测试的全流程支持软件。支持前端开发：mock(模拟) 测试支持后端开发：接口测试、开发接口文档支持测试：接口测试支持运维：监控功能postman 支持云服务：随时随地都能无缝对接加班。数据同步功能，家里、办公室的电脑登录同一账号，数据即可同步。团队协作，你设计的请求可以团队内的推送，交给其他人执行或继续开发。 安装 postman 官网下载 postman：https://www.postman.com/downloads/
根据自己使用系统，下载对应的平台版本，默认安装即可。
注册和登录 也可以不注册，但是有些功能不能用
第一个接口测试 百度翻译接口的实现：是一个get类型的请求：https://fanyi-api.baidu.com/api/trans/vip/translate?q=apple&amp;from=auto&amp;to=zh&amp;appid=&amp;xxxxsalt=888888&amp;sign=a9adc2d687fbacecc3b5059b9ccedc95
1）创建一个工程目录
如果没有特别的要求，只需要创建一次即可。
2）在工程目录下创建一个 collection 集合
collection 是 postman 管理接口请求的基本单位，首先就是把他创建出来。
3）创建一个接口请求（接口用例）
新建请求，重命名为baiduTest01：
4）拼装一个接口请求参数
对于一个get请求来说，需要三部分内容：
​请求地址：https://fanyi-api.baidu.com/api/trans/vip/translate
请求方式：get
请求参数（params）
5) 断言
后续细讲。
6）发送请求
点击url地址栏后面的send按钮。
老版本 postman 界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7643169bd4a3b389c3fd0a06ba6cdcd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71326017c824a29912928c518dea795f/" rel="bookmark">
			【北邮国院大四上】Business Technology Strategy 企业技术战略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		北邮国院电商大四在读，本笔记仅为PPT内容的整理与翻译，并不代表本课程的考纲及重点，仅为本人复习时方便阅读与思考之作。
写在前面 大家好，欢迎来到大学期间的最后一门课程，本门课程是中方课，所以很庆幸的是相对来说我们不需要背诵太多的概念（like企管/产开）更多的是理解。本门课程是着重从企业的视角来看创新、发展、营销等等各种方面，可以作为一个商科的综述性课程来看，重在理解，真正的去理解什么是什么，为什么要这么做，才能在论述题里真的有东西去说。更多的还是建议大家自己去看PPT，PPT的备注里对很多东西有更详细的解释，我也把部分我觉得很有用的放在了本篇内容里。商科的内容更多的是看你的理解、逻辑与思考，所以请各位复习的时候把重点放在理解上，用任课老师的话说，叫“考你的高阶思想”。
最后，这应该是我关于北邮学习方面的倒数第二篇文章，最后一篇我会把PPT里一些明确定义的terms整理出来，方便大家理解记忆。以及欢迎各位想跟我继续交流或者单纯想认识一下的朋友们私信我要微信或者直接微信来找我就行，很期待认识各位。
以上。我们开始吧。
Source of Innovation FirmsIndividualsPrivate Nonprofits 私人非营利组织Government-Funded Research 政府资助的研究Universities Individual Creativity Individual creativity is a function of:
Intellectual abilities (e.g., ability to articulate ideas) 智力能力(例如，表达想法的能力)Knowledge (e.g., understand field, but not wed to paradigms) 知识(例如，理解领域，但不与范式结合)Style of thinking (e.g., choose to think in novel ways) 思维方式(例如，选择以新颖的方式思考)Personality (e.g., confidence in own capabilities) 个性(例如，对自己能力的信心)Motivation (e.g., rely on intrinsic motivation) 动机(例如，依赖内在动机)Environment (e.g., support and rewards for creative ideas) 环境(例如，对创意的支持和奖励) Translating Creativity into Innovation Research and Development by Firms【两种】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71326017c824a29912928c518dea795f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d579acf4de92f975af883b472625ae55/" rel="bookmark">
			uniapp 微信小程序跳转至其他小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、背景： 需要在目前的小程序中跳转到另一个小程序，跳转的目标小程序需要已经发布上线了
二、具体实现 使用uni.navigateToMiniProgram打开另一个小程序
官网指引👉：uni.navigateToMiniProgram(OBJECT) | uni-app官网
&lt;template&gt; &lt;view&gt; &lt;button @click="gotoMt"&gt;打开美团外面小程序&lt;/button&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { methods:{ gotoMt(){ uni.navigateToMiniProgram({ appId: '',//目标小程序appid path: '',//需要打开的目标路径 extraData: { 'data1': 'test' }, envVersion:'trial',//小程序版本：develop（开发版），trial（体验版），release（正式版） success(res) { // 打开成功 } }) } } } &lt;/script&gt; 最后，👏👏 😀😀😀 👍👍 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17f75a287f1567ee723352237e5d245e/" rel="bookmark">
			leetcode：1108. IP 地址无效化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目
二、函数原型
char* defangIPaddr(char* address) 三、思路
本题通俗来讲就是将字符串中的 . 替换为 [.]
先遍历字符串得出有num个 . 且申请 len + 2*num + 1 个char空间ans。len是原字符串长度，2*num是[ ]的个数，1是 ‘ \0 ’ 的空间。
遍历字符串，如果不是 . 则将其复制到ans中；如果是 . 则将 [.]复制到ans中
ans的最后一个空间一定要存放 '\0'，这是字符串结束的标志。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3deaf685efde7eaafae24459f8a32d05/" rel="bookmark">
			了解一下InternLM3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 InternStudio 平台中选择 A100(1/4) 的配置，如下图所示镜像选择 Cuda11.7-conda，接下来打开刚刚租用服务器的进入开发机，并且打开其中的终端开始环境配置、模型下载和运行 demo。入开发机后，在页面的左上角可以切换 JupyterLab、终端和 VScode，并在终端输入 bash 命令，进入 conda 环境。如下图所示：
进入 conda 环境之后，使用以下命令从本地克隆一个已有的 pytorch 2.0.1 的环境,，需要等3分钟左右把
bash # 请每次使用 jupyter lab 打开终端时务必先执行 bash 命令进入 bash 中 /root/share/install_conda_env_internlm_base.sh LLMwinter 然后使用以下命令激活环境 conda activate LLMwinter 并在环境中安装运行 demo 所需要的依赖。 # 升级pip python -m pip install --upgrade pip pip install modelscope==1.9.5 pip install transformers==4.35.2 pip install streamlit==1.24.0 pip install sentencepiece==0.1.99 pip install accelerate==0.24.1 InternStudio 平台的 share 目录下已经为我们准备了全系列的 InternLM 模型，所以我们可以直接复制即可。使用如下命令复制： mkdir -p /root/model/winterLLMfiles cp -r /root/share/temp/model_repos/internlm-chat-7b /root/model/winterLLMfiles -r 选项表示递归地复制目录及其内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3deaf685efde7eaafae24459f8a32d05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0b36d5ef645aa8254e696dfbd62fa98/" rel="bookmark">
			基于单片机的集中供热监控电路设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、摘要 随着城市化进程的加快，集中供热系统在城市居民生活中扮演着越来越重要的角色。为了确保供热系统的稳定运行，提高供热效率，降低能耗，本文设计了一种基于单片机的集中供热监控电路。该电路主要包括温度传感器、压力传感器、流量传感器等数据采集模块，以及单片机控制模块和通信模块。通过对各个模块的设计和实现，实现了对供热系统的实时监测和控制，为供热系统的优化运行提供了有力保障。
二、引言 集中供热系统是城市居民生活的重要基础设施，其运行状态直接影响到居民的生活质量。然而，传统的供热系统存在诸多问题，如运行不稳定、能耗高、自动化程度低等。为了解决这些问题，本文设计了一种基于单片机的集中供热监控电路。该电路可以实现对供热系统的实时监测和控制，提高供热效率，降低能耗，为供热系统的优化运行提供有力保障。
三、系统设计 1. 数据采集模块
数据采集模块主要包括温度传感器、压力传感器、流量传感器等。温度传感器用于测量供热管道的温度，压力传感器用于测量供热管道的压力，流量传感器用于测量供热管道的流量。这些传感器将采集到的信息转换为电信号，然后通过模拟信号处理电路进行处理，最后输出给单片机。
2. 单片机控制模块
单片机控制模块主要负责对数据采集模块采集到的信息进行处理和控制。本设计采用STC89C52单片机作为控制核心，通过对单片机编程，实现对数据采集模块的数据采集、处理和控制。同时，单片机还负责与通信模块进行数据交互，将处理后的信息传输给上位机。
3. 通信模块
通信模块主要负责将单片机处理后的信息传输给上位机。本设计采用RS-485通信方式，通过MAX485电平转换芯片实现单片机与上位机的通信。通过对通信协议的设计和实现，可以实现对供热系统的实时监测和控制。
四、系统实现 1. 数据采集模块实现
本设计采用NTC热敏电阻作为温度传感器，采用压力变送器作为压力传感器，采用电磁流量计作为流量传感器。通过对这些元件的选型和参数设置，可以实现对供热管道的温度、压力和流量的实时监测。
2. 单片机控制模块实现
本设计采用STC89C52单片机作为控制核心，通过对单片机编程，实现对数据采集模块的数据采集、处理和控制。同时，单片机还负责与通信模块进行数据交互，将处理后的信息传输给上位机。
3. 通信模块实现
本设计采用RS-485通信方式，通过MAX485电平转换芯片实现单片机与上位机的通信。通过对通信协议的设计和实现，可以实现对供热系统的实时监测和控制。
部分代码如下
#include &lt;reg52.h&gt; // 定义温度传感器引脚 sbit temp_sensor = P1^0; // 定义单片机控制模块函数 void delay(unsigned int time) { unsigned int i, j; for (i = 0; i &lt; time; i++) for (j = 0; j &lt; 120; j++); } int main() { unsigned char temp = 0; while (1) { // 读取温度传感器数据 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0b36d5ef645aa8254e696dfbd62fa98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e45dd2b3f3830bb20fcf1b6a651df583/" rel="bookmark">
			基于单片机的无人车信息采集电路设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、摘要 随着科技的不断发展，无人车技术逐渐成为现代交通领域的研究热点。本文主要介绍了一种基于单片机的无人车信息采集电路设计。该电路主要包括传感器模块、单片机控制模块和通信模块。通过对各个模块的设计和实现，实现了对无人车行驶过程中的各种信息的实时采集和处理，为无人车的自动驾驶提供了可靠的数据支持。
二、引言 无人车是一种具有自主导航能力的汽车，它可以在没有人工干预的情况下自动完成行驶任务。为了实现无人车的自动驾驶，需要对车辆的行驶环境进行实时感知和处理。因此，信息采集电路是无人车系统中非常重要的一个组成部分。本文主要介绍了一种基于单片机的无人车信息采集电路设计，该电路可以实时采集车辆的速度、加速度、转向角等关键信息，并通过通信模块将这些信息传输给上位机进行处理。
三、系统设计 1. 传感器模块
传感器模块主要包括速度传感器、加速度传感器和转向角传感器。速度传感器用于测量无人车的速度，加速度传感器用于测量无人车的加速度，转向角传感器用于测量无人车的转向角。这些传感器将采集到的信息转换为电信号，然后通过模拟信号处理电路进行处理，最后输出给单片机。
2. 单片机控制模块
单片机控制模块主要负责对传感器模块采集到的信息进行处理和控制。本设计采用STC89C52单片机作为控制核心，通过对单片机编程，实现对传感器模块的数据采集、处理和控制。同时，单片机还负责与通信模块进行数据交互，将处理后的信息传输给上位机。
3. 通信模块
通信模块主要负责将单片机处理后的信息传输给上位机。本设计采用串行通信方式，通过串口将数据发送给上位机。串口通信具有简单、可靠、成本低等优点，非常适合用于无人车的信息采集系统。
四、系统实现 1. 传感器模块实现
本设计采用霍尔效应速度传感器、电容式加速度传感器和旋转编码器作为速度、加速度和转向角的检测元件。通过对这些元件的选型和参数设置，可以实现对无人车行驶过程中的速度、加速度和转向角的实时监测。
2. 单片机控制模块实现
本设计采用STC89C52单片机作为控制核心，通过对单片机编程，实现对传感器模块的数据采集、处理和控制。同时，单片机还负责与通信模块进行数据交互，将处理后的信息传输给上位机。
3. 通信模块实现
本设计采用RS-232串口通信方式，通过MAX232电平转换芯片实现单片机与上位机的通信。通过对串口通信协议的设计和实现，可以实现对无人车行驶过程中的各种信息的实时传输。
部分代码如下
#include &lt;reg52.h&gt; // 定义速度传感器引脚 sbit speed_sensor = P1^0; // 定义单片机控制模块函数 void delay(unsigned int time) { unsigned int i, j; for (i = 0; i &lt; time; i++) for (j = 0; j &lt; 120; j++); } int main() { unsigned char speed = 0; while (1) { // 读取速度传感器数据 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e45dd2b3f3830bb20fcf1b6a651df583/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c0165ee0ceca423d11399cb6ccf3f14/" rel="bookmark">
			关于图像分割任务中按照比例将数据集随机划分成训练集和测试集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 之前写了分类和检测任务划分数据集的脚本，三大任务实现了俩，基于强迫症，也实现一下图像分割的划分脚本
分类划分数据：关于图像分类任务中划分数据集，并且生成分类类别的josn字典文件
检测划分数据：关于目标检测中按照比例将数据集随机划分成训练集和测试集
之前写了目标检测的可视化脚本，明天看看要不要把分类和分割的可视化也实现一下，之前的博文里实现过，但都是大项目里的一个环节，看看能不能单独实现一下
这里的脚本和未划分数据的目录在同一路径
2. 完整代码 如下：
import random import os import shutil from tqdm import tqdm # 划分数据函数 def split_data(root, test_rate): images_path = [os.path.join(root, i) for i in os.listdir(root)] # 获取所有图片路径 test_split_path = random.sample(images_path, k=int(len(images_path) * test_rate)) # 随机采样测试集 # 遍历所有图片 for image_path in tqdm(images_path, desc='loading...'): # 获取相应的标注文件，这里需要根据目录、后缀更改 mask_path = image_path.replace('images', 'masks') # 划分数据 if image_path in test_split_path: # 在测试集 shutil.copy(image_path, './data/test/images') shutil.copy(mask_path, './data/test/masks') else: shutil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c0165ee0ceca423d11399cb6ccf3f14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d18f4d75e487762c6010a7ad3ae0c81/" rel="bookmark">
			2023年十大热门黑客工具，带您了解这个领域的“暗黑艺术”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片
用心做分享，只为给您最好的学习教程
如果您觉得文章不错，欢迎持续学习
在数字化时代，网络安全问题愈发凸显，黑客们不断更新攻击手段，试图突破防护壁垒。为了应对这些威胁，网络安全专家们也在不断研发新的防御技术和工具。
本文将为您盘点2023年十大热门黑客工具，带您了解这个领域的“暗黑艺术”。
一、Nmap
Nmap（Network Mapper）是一款开源的网络扫描工具，用于发现网络上的设备和服务。它支持多种扫描技术，如TCP Connect Scan、SYN Scan等，可以帮助黑客识别目标网络中的潜在漏洞。
二、Metasploit
Metasploit是一款强大的安全漏洞利用工具，可以帮助黑客利用已知的漏洞入侵目标系统。它提供了丰富的漏洞利用模块，支持多种编程语言，是黑客们进行渗透测试和攻击的得力助手。
图片三、Armitage
Armitage是基于Metasploit的图形化前端工具，通过提供直观的界面和丰富的功能，使渗透测试更加高效。它支持模块化攻击，可以帮助黑客快速定位目标系统的弱点。
图片四、BeEF
BeEF（Browser Exploitation Framework）是一款针对Web浏览器的框架，通过利用浏览器漏洞实现远程控制。它支持多种浏览器和操作系统，可以帮助黑客窃取用户敏感信息。
五、Burp Suite
Burp Suite是一款功能强大的Web应用安全测试工具，包括多个不同的工具，如Proxy、Scanner、Intruder等。它可以帮助黑客发现Web应用中的安全漏洞，并进行攻击。
六、OWASP ZAP
OWASP ZAP（Zed Attack Proxy）是一款开源的Web应用安全扫描工具，可以帮助黑客发现和利用Web应用中的漏洞。它支持多种扫描技术，如被动扫描、主动扫描等。
七、Hydra
Hydra是一款著名的密码破解工具，支持多种加密算法和攻击方式。它可以帮助黑客破解用户密码，进而获取目标系统的访问权限。
八、Aircrack-ng
Aircrack-ng是一款无线网络安全测试工具，可以帮助黑客破解WEP、WPA等无线网络密码。它支持多种攻击方式，如字典攻击、暴力破解等。
九、Recon-ng
Recon-ng是一款Web侦察框架，可以帮助黑客收集目标网站的敏感信息。它支持多种模块，如搜索引擎枚举、社交媒体枚举等，为黑客提供全方位的信息收集能力。
十、Social Engineering Toolkit
Social Engineering Toolkit是一款社会工程学攻击工具，可以帮助黑客利用人类心理弱点进行欺骗。它提供了多种攻击手段，如钓鱼攻击、恶意链接等。
2023年黑客工具呈现出多样化、智能化、隐蔽化等特点。了解这些工具和技术，有助于我们提高网络安全意识，加强防范能力。面对日益严峻的网络威胁，我们应时刻保持警惕，共同守护数字世界的和平与安宁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872b810d9ec55021f37bb36c66b5bb79/" rel="bookmark">
			如何用Python开发一个多策略机器人！上篇！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注我的另一个号并加星标(专注python指标与策略)，不定期送书抽奖： 大家好，我是菜哥！
周末了，在家研究了一些好玩的东西。下面是一些碎碎叨叨的东西，不喜欢玩股票的可以不用看了！
玩股票 大体分为技术派和价值派，这两个都有一大批的追随者。对于价值派一般都是做中长线的，而且是对股票的基本面有深入的理解，对公司的运营也都是非常了解的，但是在我们大A，很多财务报表不太敢恭维，这里就不细细讲了。国外确实有多价值派，毕竟M国的监管还是很严格的，对于财务数据还是比较公开透明的。
对于技术派来说就是纯研究K线，然后研究各种各种和策略去分析和判断，然后依据历史的数据去回测和研究，算是有一定的门槛，而量化又是其中的一个分支。对于很多市场其实是可以做空，做多的。整个交易的框架会分：趋势策略，中性策略，网格策略 和套利策略。每一种研究透了，都够你吃一大波肉的。
关于技术派对于指标和策略是非常推崇的，那么指标大体分2类，我整理了一部分的内容，后面还会整理（这个图还会继续完善）：
指标分2类，一类就是趋势指标，一类就是震荡指标，我们常见的均线都是趋势指标，然后布林，macd 这样的都是震荡指标。对于一种指标都需要花很多时间去研究，你需要理解，深入理解这个指标是怎么计算的（具体我会在上面的我的小号里面展开一系列的文章讲，可以先关注占坑)，这样你才能在你资金被套或者回撤的时候能拿住，同时指标之间又可能相互包容和搭配使用。
打个比方，震荡指标可以和震荡指标配合，比如布林和cci可以结合。好比西红柿炖牛肉，比单炒西红柿，单炒牛肉更好吃。但是有的指标之间不能互相配合，会相冲，这些都需要好好研究。而且针对不同的行情每一种指标都有自己的弱点和强点，如果你不理解的话，胡乱套用，乱吃药，就会伤身。
既然是玩技术的，那么就需要深入地研究各种指标和策略，于是我想到一个方法就是做一个策略投票机器人，大概的示意图是这样的：
上面演示3个策略，你可以构建很多指标和策略，然后进行组合，就跟炼丹一样！说干就干，我撸起袖子写python代码，我熬了2个晚上写了一个很初级初级的脚本机器人。我部署了一些震荡指标+趋势指标，然后做一个投票，然后效果是这样的：
比如我选了一些股票，然后喂给机器人，机器人去自动爬取K线数据，然后把数据发到策略1/2/3 里面，策略进行投票打分，然后最后出一个结果，最后给出指示 买还是卖出，还是不要操作，非常有意思。学会python来玩量化简直就是如虎添翼啊！
目前不仅支持股票，还可以支持etf场内基金的判断：
目前还没有进行全A股扫码或者全ETF进行扫描，全ETF应该有800多只基金，全扫肯定是没有问题，后面还需要继续完善一下，弄个多线程处理，然后每日定时扫码存到数据库里面！要加的功能有点多，晕菜～～
另外这个策略框架还只是雏形中的雏形，没有进行回测，还需要把回测的代码写出来，测一下效果看看到底这个如何，工程浩大，我后面慢慢码代码吧。
因为熬夜写的代码，好了不说了，人比较累的，码字不易，有兴趣的道友帮忙点个免费的赞哈！
最后推荐一下我们团队写的量化小册的内容，35篇内容！从Python安装，入门，数据分析，爬虫解释，爬取股票基金的历史+实时数据，如何写一个简单量化策略，策略回测，如何看资金曲线统统都有介绍！非常超值！
写小册的目的，是希望通过这样的方式逼自己一把，把自己学习的内容深化，提升自己的功力，很多东西你能把别人教会了，你自己才是真正的领悟！
欢迎订阅：原价199 早鸟价39（满100人涨10元）。现在的价格非常非常低，只要2杯奶茶，就可以终身订阅+全套课程源码，还有永久陪伴群。48小时无理由退款，放心食用！
推荐阅读: 入门: 最全的零基础学Python的问题 | 零基础学了8个月的Python | 实战项目 |学Python就是这条捷径 干货:爬取豆瓣短评，电影《后来的我们》 | 38年NBA最佳球员分析 | 从万众期待到口碑扑街！唐探3令人失望 | 笑看新倚天屠龙记 | 灯谜答题王 ｜用Python做个海量小姐姐素描图 ｜碟中谍这么火，我用机器学习做个迷你推荐系统电影
趣味:弹球游戏 | 九宫格 | 漂亮的花 | 两百行Python《天天酷跑》游戏!
AI: 会做诗的机器人 | 给图片上色 | 预测收入 | 碟中谍这么火，我用机器学习做个迷你推荐系统电影
小工具: Pdf转Word，轻松搞定表格和水印！ | 一键把html网页保存为pdf！| 再见PDF提取收费！ | 用90行代码打造最强PDF转换器，word、PPT、excel、markdown、html一键转换 | 制作一款钉钉低价机票提示器！ ｜60行代码做了一个语音壁纸切换器天天看小姐姐！｜
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/404524f1ee0d3c8a6308f2556cc6ba3b/" rel="bookmark">
			nodejs 不用 electron 实现打开文件资源管理器并选择文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近在开发一些小脚本，用 nodejs 实现。其中很多功能需要选择一个/多个文件，或者是选择一个文件夹。
最初的实现是手动输入一个目录（这个只是一个普通的终端文本输入，所以按下 tab 没有路径提示），非常的麻烦，而且很容易输错。
这种情况下网上给出的解决方案都是 electron。但是我一个小脚本用 electron 属实有点夸张了，后来转念一想可以通过 powershell 来实现类似的功能。
通过命令唤醒文件选择器 通过 cmd / prowershell 唤醒文件选择器 对 powershell 不熟悉的我唰的一声打开了 gpt，gpt 不负众望 很快给出了答案
注意这里有区别：cmd 终端中需要调用 powershell.exe
如果当前已经是在 powershell 终端的话，直接运行对应的指令即可
在 cmd 中运行： powershell.exe -Command "&amp; {Add-Type -AssemblyName System.Windows.Forms; $FileDialog = New-Object System.Windows.Forms.OpenFileDialog; $result = $FileDialog.ShowDialog(); if ($result -eq 'OK') { Write-Output $FileDialog.FileName }}" 在 powershell 中运行： &amp; {Add-Type -AssemblyName System.Windows.Forms; $FileDialog = New-Object System.Windows.Forms.OpenFileDialog; $result = $FileDialog.ShowDialog(); if ($result -eq 'OK') { Write-Output $FileDialog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/404524f1ee0d3c8a6308f2556cc6ba3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37f74463a812c4ae31412fe4651ceb01/" rel="bookmark">
			解决DolphinDB vscode插件重启后无法访问的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把vscode的代理关掉：
左下角小齿轮，打开setting搜索框里搜索proxy将Http:Proxy Support从override改为off，即可生效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f6650405de48ea0a2843d5065159d83/" rel="bookmark">
			2023我的编程之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你的编程学习经历和成长过程：
在我探索编程世界的旅程中，我深刻地认识到，编程不仅仅是一种技术， 是一种思维方式， 一种解决问题的方法。希望通过分享我的编程学习体验，能够启发更多的人看到编程的魅力和价值。
我对编程的看法是复杂的,但同时也是充满热情的。我认为编程是一种强大的工具, 是一种可以改变世界、解决问题、创新和进步的工具。同时，我也认识到编程的挑战和困难，但我相只要有足够的努力和实践，我就能克服这些困难。对于我来说，学习编程并非只为了掌握一种技能，更是为了理解一种逻辑，一种解决问题的方式。
在学习的初期，我遇到了很多困难。例如，对于初学者来说，编程语言中的复杂语法和抽象的概念往往令人困感。然而,我逐渐认识到，这些困难实际上学习编程的一部分,让我们不断提升和挑战自己的动力。随着时间的推移，我逐渐掌握了编程的基本概念和技能。我开始能够用代码创造出一些简单的程序，这让我感到非常兴奋。但是,我也意识到，编程不仅仅是编写代码，更是一种全面的思考方式。我也明白了编程中的困难和挑战是常态,酶次克服困难和挑战都会让我成长和进步。当我遇到问题时，我会尝试用编程的思维式去分析和解决它，这让我在生活中变得更加有条理和高效。
学习编程使我认识到，问题可以有多种解决方案,而不仅仅是单一的答案。 这使我更愿意尝试新的方法，勇于挑战自我。同时，编程也培养了我的逻辑思维和解决问题的能力。在面对问题时,我学会了分析问题，寻找解决方案的思维方式。此外，编程还让我更好地理解了团队合作的重要性。在项目中，我们需要与团队成员紧密合作，共同解决问题。这种经历使我学会了如何有效地与他人沟通，如何尊重他人的观点和想法。
回顾我的学习过程，我认为编程给予我最大的收获是解决问题的能力。在编程中,我们经常面临各种各样的问题和挑战,要寻找解决方案。通过这个过程，我学会了如何分析问题、找解决方案，钚断尝试和改进。我相信，这种能力在生活的其他方面同样重要。
总之，学习编程让我学会了如何思考问题、解决问题，翔让我意识到，只要有足够的毅力和耐心，没有什么问题是无法解决的。我相信,这种编程思维方式和解决问题的能力将会对我未来的学习和生活产生深远的影响。学习编程不仅是一种技能，更是一种思维方式， 一种解决问题的方法。我希望通过分享我的体验,能够启发更多的人看到编程的魅力和价值，让我们一起用编程
系统学习新技术的心得体会：
在当今快速发展的技术时代，持续学习和掌握新技术已经成为保持竞争力和创新能力的关键。系统学习新技术不仅仅是获取知识和技能，更是一种挑战自我、拓展视野和实现个人成长的过程。在这个过程中，我积累了一系列宝贵的心得体会。
首先，明确学习目标和规划是成功学习的关键。每次面对一个新的技术或工具，我都会花费足够的时间和精力进行前期调研和规划。这包括了解该技术的基本概念、主要应用场景以及学习路径。通过建立清晰的学习目标和时间表，我能够更加有序和高效地进行学习，避免盲目跟随和浪费时间。
其次，持续实践和应用是巩固和深化理解的关键。纸上得来终觉浅，实践是检验真理的唯一标准。在学习过程中，我始终坚持将理论知识与实际应用相结合，通过解决实际问题和完成实际项目来加深对新技术的理解和掌握。这不仅可以锻炼我的实际操作能力，还可以培养我的问题解决和创新思维能力。
第三，深入阅读和研究官方文档和资料是快速提升技能的有效途径。在学习新技术的过程中，我始终认为官方文档和资料是最权威和可靠的学习资源。通过仔细阅读和研究官方文档，我可以全面和深入地了解技术的核心概念、原理和最佳实践，从而避免走弯路和犯错误。
此外，积极参与技术社区和开源项目是拓展知识和网络的有效方式。在学习新技术的过程中，我始终注重与其他开发者和专家建立联系和交流。通过参加技术论坛、社区活动和开源项目，我可以分享我的学习经验和成果，同时也可以从他人那里获取宝贵的反馈和建议，不断优化和完善我的学习和工作方法。
最后，持续反思和调整是保持学习动力和效果的关键。在学习新技术的过程中，我始终保持开放的心态和敏锐的洞察力，不断反思和评估自己的学习进度和效果。如果发现自己在学习过程中遇到困难或者陷入僵化，我会积极寻求反馈和建议，调整学习策略和方法，确保自己始终保持学习的热情和动力。
总之，系统学习新技术是一项既挑战性又充满机遇的任务。通过明确目标、持续实践、深入研究和广泛交流，我不仅提高了自己的技能和能力，还拓展了自己的视野和网络，为未来的发展和成就打下了坚实的基础。我相信，只要坚持不懈、持续学习和创新，就一定能够在这个快速变化的技术世界中取得成功和突破。
对技术行业的深度思考：
第一部分主要分析为什么技术方案没有体现出深度，找到问题后就好解决，并提出技术方案的广度和深度特征；第二部分是技术方案设计的方法论，主要包括了本质论、矛盾论、系统论、演进论四个方法论方法，构成一个闭环反馈链路；第三部分是通过具体的案例，反复运用第二部分的方法论阐述在实例的案例中如何去应用，加深对方法论的理解。我们都希望的自己设计的技术方案能够让人眼前一亮、叹为观止、拍案叫绝……，然而在实际情况下，却并不是这样的，经常听到如下的说法：场景简单：业务场景很简单，怎么也设计不出花儿来；复杂度低：业务复杂度低，很难讲得出挑战出来；亮点少：运用的技术亮点少，基本上都是现有的中间件或框架来完成；设计普通：方案缺乏新颖，业内也是这么做的，没有体现出自己的设计能力； 我的最佳代码实践：
如果你是一名软件开发者，你可能经常会遇到这样的情况：你的代码运行得不够快，或者难以阅读和维护。这时候，你就需要对你的代码进行重构。
重构是指在不改变代码功能的前提下，改善代码设计的过程。通过重构，你可以提高代码的性能，可读性和可维护性，从而让你的代码更加优雅和高效。
但是，重构代码并不是一件容易的事情。如果不注意一些细节，你可能会引入新的bug或者破坏应用的功能。因此，在重构代码时，需要遵循一些最佳实践，以确保不会在重构过程中迷失方向。
在本文中，我们将介绍重构代码的十大最佳实践，希望能够帮助你优化你的代码，并且提升你的编程技能。
确认问题区域
重构代码的第一步是确定需要改进的代码区域。这可以是任何东西——从命名不佳的变量到难以理解的整个代码部分。要找出问题区域，你可以使用一些工具或方法，例如：
代码审查。让其他人检查你的代码，并且给出反馈和建议。 代码度量。使用一些指标来评估你的代码的质量，例如复杂度，可测试性，可读性等。 代码异味。识别出一些表明代码有潜在问题的迹象，例如冗余，紧耦合，过长函数等。 代码测试。运行你的测试用例，并且检查是否有失败或错误。 目标。明确你想要达到什么样的效果，例如提高性能，增加可读性，降低耦合等。 方法。选择适合你问题区域和目标的重构方法，例如提取函数，内联变量，替换算法等。 顺序。确定你要按照什么样的顺序进行重构操作，例如从上到下，从内到外，或者按照优先级等。 风险。评估你可能遇到的风险和挑战，并且准备好应对措施，例如备份代码，写注释，做测试等。 保持较小的变更
重构代码时，进行小的增量更改很重要。这将有助于确保代码不会变得不稳定，并且也可以在必要时轻松撤销所做的更改。保持较小的变更时，你可以遵循以下几个原则：
单一职责。每次更改只针对一个问题或目标，不要同时修改多个方面的代码。 原子性。每次更改只包含一个重构操作，不要将多个重构操作合并在一起。 频繁性。每次更改后，都要运行测试和检查代码，确保没有引入新的错误或问题。 可追溯性。每次更改都要记录在源代码控制系统中，并且使用有意义的提交信息来描述更改的内容和原因。 我的最大收获与成长：
一、学习编程其实也是提升自我学习能力的一种体现。
编程的世界是一个高速发展和变化的环境，也与星空一样知识是无边无际的。
我们无法学会所有编程语言或者技术栈，不过我们是可以在某几个编程领域中发光发亮。只要我们坚持，专研，深度学习一门技术，我们必定会变成这一方面的专家。
在编程的世界里，我们会找到很多可以学习和成长的空间。无边无际的知识海洋，
二、学习编程是提升逻辑思维和分析能力的一种体现。
在编程中我们会遇到很多问题，并且需要我们一个个的去解决。解决困难，解决问题是作为一个开发者必备的技能。大到技术架构，解决业务场景带来的难度和逻辑复杂度，小到解决系统中的问题和缺陷，使用逻辑思维去排查和修复漏洞。在每天的工作中开发者都是会面对各种各样的问题和困难，长年累月每一个开发者都会养成解决问题的能手。
渐渐的我们会有各式各样解决问题的办法。也是因为日常的不断锻炼和思考，可以让我们养成一种逻辑思维来解决问题。每一个问题都会建立一套一套的逻辑思维方式和方法来解决。比如系统中的一个问题出现了，一个资深的开发者，瞬间就可以定位到问题并且给出解决方案。其中最重要的一个点是因为资深开发者长年累月的经验，还有就是熟悉解决问题的排查方法，一套高效快速的方法。
三、学习编程可以为人生带来更多机遇与可能性。
现阶段，互联网发展迅速。有能力有技术的程序员往往能通过自己高超的编程能力，得到更多的赏识与机遇。
我的技术发展规划：
找到自己的方向 人生如滚雪球，重要的是找到很湿的雪和很长的山坡，这是巴菲特的名言。其实，不仅仅只适合于投资，也适合于技术人的职业规划。
每个人都需要认清自己的立足点，在自己不同的发展时期，配合公司的发展时期，找属于你的有立足点。只有站稳了这个立足点，你才可以更好的开始延伸自己别的领域。
在当下，结合如今的发展趋势，我提供一个当下的思考，技术人未来的核心立足点将来自于跨界的竞争，跨界不仅仅包含行业跨界，也包括职位的跨界，以及更多视野的跨界。
站在巨人的肩膀上，你会看的更高看的更远，从而避免很多弯路，弯路过多那是对时间的浪费。
也许当下，站在巨人的肩膀上，这将是最好的职业规划解决方案。
不断从你身边的牛人身上汲取过往的经验和教训，找到一个你可以参考的榜样开始你的职业生涯。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80cb9b48ff2d1a2880e637a7b547262a/" rel="bookmark">
			基于ARIMA模型对上证指数趋势的预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
1 绪 论 6
1.1 研究背景及意义 6
1.2 国内外研究现状 6
1.3 本文的主要内容与组织结构 7
1.3.1 本文的主要内容 7
1.3.2 本文的组织结构 7
1.3.4预期成果 7
2 理论基础 8
2.1 ARIMA模型的基本介绍 8
2.1.1 AR模型 8
2.1.2 MA模型 8
2.1.3 ARIMA模型有三个参数:p,d,q 8
2.1.4 ARIMA模型的优缺点 9
3 3 ARIMA模型的建立 9
3.1 ARIMA模型原理 9
3.2 数据准备 10 3.3 数据分析 13
4 实验 14
4.1 差分d的确定 16
4.2模型识别和定阶 18
4.3残差的检验 20
4.4模型的适应性检验 23
4.5模型的预测 25
结 论 26
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80cb9b48ff2d1a2880e637a7b547262a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0499cf93451fccac1c5e6d6a28f3f962/" rel="bookmark">
			SQLServer设置端口，并设置SQLServer和SQLServer Browser服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQLServer默认使用动态端口，即每次启动sqlserver.exe时，端口port都会动态变化。若要使用静态端口，比如port=1433，则需要在SQL Server Configuration Manager(简称SSMS）里配置。这里以SQL Server 2005 Configuration Manager软件为例，进行说明，具体如下：
1 使能静态端口1433 点击桌面左下角的[开始] --》找到SQL ServerConfiguration Manager --》双击SQL ServerConfiguration Manager --》弹出Manager软件配置界面，如图(1)所示：
图(1) 启动数据库管理工具SSMS 点开左侧目录里的SQL Server 2005 Network Configurtaion --》右击Protocols for XXX --》打开 --》再右击TCP/IP --》属性 --》
在Protocol页，
设置Enable = Yes，如图(2)、图(3)所示：在IP Address页
找到IPAll属性
设置 TCP Dynamic Ports 为空
设置 TCP Port = 1433。
–》点击【应用】，如图(4)所示： 图(2) 在SQL Server XXX Network Configuration里设置TCP/IP项 图(3) 使能Protocol，设置为Yes 图(4) 设置TCP Dynamic Ports为空，而在TCP Port里设置1433 2 重启SQL Server服务 2.1 先关闭SQL Server和SQL Server Browser 在SQL Server Configuration Manager界面，在左侧树形目录里选中SQL Server 2005 Services --》在右边选中SQL Server(SQLEXPRESS) --》关闭或Stop --》继续在右边选中SQL Server Browser–》关闭或Stop，如图(5)、图(6)所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0499cf93451fccac1c5e6d6a28f3f962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98c05b306a11b2f179e154fb094a1b57/" rel="bookmark">
			在Ubuntu22.04上安装WordPress
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WordPress是当今最简单、最强大的博客和网站建设工具。据统计全球大约有40% 以上网站是使用WordPress，这是个巨大的数字也侧面证明了WordPress的强大和普遍性。因此，如果你正在寻找一款高效、实用、可靠的CMS工具来构建网站，那么WordPress无疑是一个不错的选择。
WordPress 同时为网站的后端和前端提供支持：
1、博客：专门用于个人分享想法、照片、评论、教程、食谱等等。
2、B2C电商网站：电商网站允许我们在线销售商品或服务并通过在线支付系统收款。
3、跨境电商：如果您的企业需要一个网站供客户了解您的公司和您所提供的产品，WordPress 是一个很好的选择。客户可以与您联系、询问报价、安排参观等等。
4、作品集网站： 通过基于 WordPress 的作品集网站展示您的艺术作品、设计技巧等。
5、论坛网站：论坛网站可以成为用户提问或分享建议的好地方，目前许多论坛网站都在 WordPress 上运行。
6、电子学习网站：学生可以从电子学习网站上在线课程、跟踪他们的进度、下载资源等等。使用一种称为 WordPress LMS 插件的特殊插件，您可以从 WordPress 网站提供在线课程。
7、直播网站：WordPress集成了SBS流媒体客户端，可以直接进行网站直播。
如果你决定使用WordPress来搭建自己的外贸独立站，那么这将是一个不错的选择。下面我们就开始介绍WordPress离线部署。
一：安装环境
服务器配置：ubuntu22.04
服务器IP：192.168.29.166
先安装必要的相关依赖：
apt update &amp;&amp; sudo apt upgrade
apt install apache2 mariadb-server libapache2-mod-php php-gd php-mysql
apt install php-curl php-mbstring php-intl php-gmp php-bcmath php-xml php-imagick php-zip php-json
二：配置数据库
为WordPress初始化数据库MariaDB，默认情况下，不会对MariaDB进行加固。您可以使用mysql_secure_installation脚本保护MariaDB 。您应该仔细阅读每个步骤，并在每个步骤下面仔细进行操作，这将设置root密码，删除匿名用户，禁止远程root登录以及删除测试数据库和对安全MariaDB的访问。
mysql_secure_installation 这样初始化MariaDB：
- Set root password? [Y/n] n - Remove anonymous users? [Y/n] y - Disallow root login remotely?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98c05b306a11b2f179e154fb094a1b57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99479850c71f19484e493d8022d57092/" rel="bookmark">
			看图识熊（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Windows Machine Learning加载ONNX模型并推理 环境要求 Windows Machine Learning支持在Windows应用程序中加载并使用训练好的机器学习模型。Windows 10从10.0.17763.0版本开始提供这套推理引擎，所以需要安装17763版本的Windows 10 SDK进行开发，并且需要运行在17763及以上版本的Windows 10中。
创建UWP项目 打开Visual Studio 2017，新建项目，在Visual C#分类中选择，填写项目名称为，点击确定空白应用(通用 Windows)``ClassifyBear
在弹出的对话框中，设置目标版本和最低版本都是17763
添加模型文件到项目中 打开解决方案资源管理器中，在项目中的目录上点右键-&gt;添加-&gt;现有项，添加模型文件Assets``BearModel.onnx
模型是在应用运行期间加载的，所以在编译时需要将模型复制到运行目录下。在模型文件上点右键，属性，然后在属性面板上，将属性改为，将属性改为。生成操作``内容``复制到输出目录``如果较新则复制
打开解决方案资源管理器，应该可以看到在项目根目录自动生成了和模型同名的代码文件，里面就是对该模型的一层封装，包括了输入输出的定义、加载模型的方法以及推理的方法。BearModel.cs
如果在解决方案资源管理器中没有看到该文件，说明生成失败，失败的原因可能是路径中包含中文、或者onnx模型不合法、或者其它原因，可以尝试手动生成。
在开始菜单中找到并打开，运行如下命令VS 2017的开发人员命令提示符
mlgen.exe -i d:\BearModel.onnx -o d:\BearModel.cs -l CS -n BearModel 其中，指定ONNX模型路径，指定要生成的封装代码的路径，指定代码的语言，指定代码使用的命名空间。注意，命令中不要出现中文字符。-i``-o``-l``-n
生成成功后，可以手动将生成的BearModel.cs添加项目中;如果还是生成失败，需要根据错误信息继续排查原因
设计界面 打开，将整个Grid片段替换为如下代码：MainPage.xaml
&lt;Grid&gt; &lt;StackPanel Margin="12"&gt; &lt;TextBlock Text="输入要识别的图片地址:" Margin="12"&gt;&lt;/TextBlock&gt; &lt;TextBox x:Name="tbImageUrl" Margin="12"&gt;&lt;/TextBox&gt; &lt;Button x:Name="tbRun" Content="识别" Tapped="TbRun_Tapped" Margin="12"&gt;&lt;/Button&gt; &lt;TextBlock x:Name="tbBearType" Margin="12"&gt;&lt;/TextBlock&gt; &lt;Grid BorderBrush="Gray" BorderThickness="1" Margin="12" Width="454" Height="454"&gt; &lt;Image x:Name="imgBear" Stretch="Fill" ImageOpened="ImgBear_ImageOpened" ImageFailed="ImgBear_ImageFailed"&gt;&lt;/Image&gt; &lt;/Grid&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; 显示效果如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99479850c71f19484e493d8022d57092/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/970488b11a7e9178432a45d45f77ac4a/" rel="bookmark">
			12、JVM高频面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、JVM的主要组成部分有哪些 JVM主要分为下面几部分
类加载器：负责将字节码文件加载到内存中
运行时数据区：用于保存java程序运行过程中需要用到的数据和相关信息
执行引擎：字节码文件并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎将字节码翻译成底层系统指令
本地库接口：会被执行引擎调用参与字节码的翻译
在这里面最主要的部分是运行时数据区，它又由五部分构成，分别是：堆、方法区、栈、本地方法栈、程序计数器
堆是对象实例存储的主要区域方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，比如常量、静态变量等等栈是程序方法运行的主要区域，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息本地方法栈与栈功能相同，区别在于本地方法栈执行的是本地方法，即一个Java调用非Java代码的接口程序计数器主要存放的是当前线程所执行的字节码的行号，用于记录正在执行的字节码指令的地址 2、堆栈的区别是什么 堆和栈都是JVM的主要组成部分，不同点在于：
栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的堆会GC垃圾回收，而栈不会栈内存是线程私有的，而堆内存是线程共有的两者异常错误不同，栈空间不足：java.lang.StackOverFlowError，堆空间不足：java.lang.OutOfMemoryError 3、JVM的类加载器有哪些 类加载器的主要作用就是将字节码文件加载到JVM中，从而让Java程序能够启动起来。根据各自加载范围的不同，主要划分为四种类加载器：
启动类加载器(BootStrap ClassLoader)：用于加载JAVA_HOME/jre/lib目录下的类库
扩展类加载器(ExtClassLoader)：用于加载JAVA_HOME/jre/lib/ext目录中的类库
应用类加载器(AppClassLoader)：用于加载classPath下的类，也就是加载开发者自己编写的Java类
自定义类加载器：开发者自定义类继承ClassLoader，实现自定义类加载规则
4、什么是双亲委派模型 双亲委派模型是Java中的一种类加载机制。
在双亲委派模型中，类加载器之间形成了一种层次继承关系，从顶端开始依次是：启动类加载器-&gt;扩展类加载器-&gt;应用类加载器-&gt;自定义类加载器
当一个类加载器需要加载某个类时，它首先会委派给其上层类加载器去尝试加载该类。如果父类加载器无法加载该类，子类加载器才会尝试加载。
这种层次关系形成了一个从上到下的委派链。
双亲委派模型的主要目的是保证Java类的安全性和避免类的重复加载。当一个类加载器收到加载请求时，它会首先检查自己是否已经加载了该类。
如果已经加载，则直接返回该类的Class对象；如果未加载，则将加载请求委派给父类加载器。
父类加载器也会按照同样的方式进行检查，直到顶层的启动类加载器。如果顶层的启动类加载器无法加载该类，那么子类加载器会尝试自己加载。
这样可以避免同一个类被不同的类加载器加载多次，确保类的唯一性。
双亲委派模型的优势在于能够保证类的一致性和安全性。
通过委派链的机制，可以避免恶意代码通过自定义的类加载器加载替换系统核心类，从而提高了Java程序的安全性。
此外，通过双亲委派模型，可以实现类的共享和重用，减少内存占用和加载时间，提高了系统的性能。
5、说一下类加载器的执行过程 类从被加载到虚拟机内存中开始，直到卸载出内存为止，整个生命周期包括了7个阶段：加载、验证、准备、解析、初始化、使用、卸载
加载: 这个阶段会在内存中生成一个代表这个类的java.lang.Class对象验证: 这个阶段的主要目的是为了确保Class文件包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全准备: 这个阶段正式为类变量分配内存并设置类变量的初始值，注意这里的初始值指的是默认值，而不是代码=后的实际值解析: 这个阶段将符号引用替换为直接引用，比如方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接引用方法初始化: 这个阶段是执行类构造器方法的过程，是类加载的最后一步，到了这一步Java虚拟机才开始真正执行类中定义的Java程序代码(字节码)使用: 这个节点程序在运行卸载: 这个阶段类Class对象被GC 6、怎么判断对象是否可以被回收 在堆中存放着几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事就是要确定哪些对象是要回收的
JVM认为不被引用的对象就是可以被回收的对象，而它确认对象是否还在被引用的算法主要有两种：引用计数法和可达性分析算法
引用计数法
在对象头处维护一个counter，每增加一次对该对象的引用，计数器自加，如果对该对象的引用失联，则计数器自减
当counter为0时，表明该对象已经被废弃，不处于存活状态,
但是此方法存在问题，假设两个对象相互引用始终无法释放counter，则永远不能GC
可达性分析算法
通过一系列为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链
当一个对象到GC Roots没有任何引用链相连时，则证明该对象是不可用的
可以作为GC Roots的对象一般有栈中引用的对象 、方法区中类静态属性引用的对象以及
7、JVM的垃圾回收算法有哪些 目前JVM中的垃圾回收算法主要有四个，分别是：标记清除算法、标记-整理算法、复制算法和分代收集算法
标记清除算法是将垃圾回收分为2个阶段，分别是标记和清除
它会先使用根据可达性分析算法找到垃圾资源进行标记，然后对这些标记为可回收的内容进行垃圾回收
这种算法的主要不足有两个：
效率问题，标记和清除阶段都要遍历多有对象，并且在GC时，需要停止应用程序，对于交互性要求比较高的应用而言这个体验是非常差的
空间问题，对象被回收之后会产生大量不连续的内存碎片，当需要分配较大对象时，由于找不到合适的空闲内存而不得不再次触发垃圾回收动作
标记整理算法也是将垃圾回收分为2个阶段，分别是标记和整理清除
它的第一阶段也是会先将存活的对象先标记出来
不一样的地方在于第二阶段，它会将所有存活的对象向前移动放在一起，然后将无用空间回收，这样就会出现连续的可用空间了
所以它解决了空间碎片问题，但是效率低的问题依旧存在
复制算法，将原有的内存空间一分为二，每次只用其中的一半
在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将当前内存空间清空，交换两个内存的角色，完成垃圾的回收。
这种算法的缺点在于分配2块内存空间，在同一个时刻，只能使用一半，内存使用率较低
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/970488b11a7e9178432a45d45f77ac4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47f471de775c954587f8e62d9580bdcf/" rel="bookmark">
			Python综合数据分析_根据订单求RFM值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0.导入数据1.数据可视化2.数据清洗3.特征工程4.构建User用户表5.求R值6.求F值7.求M值 0.导入数据 import pandas as pd #导入Pandas df_sales = pd.read_csv('订单.csv') #载入数据 df_sales.head() #显示头几行数据 1.数据可视化 import matplotlib.pyplot as plt #导入Matplotlib的pyplot模块 #构建月度的订单数的DataFrame df_sales['消费日期'] = pd.to_datetime(df_sales['消费日期']) #转化日期格式 df_orders_monthly = df_sales.set_index('消费日期')['订单号'].resample('M').nunique() #设定绘图的画布 ax = pd.DataFrame(df_orders_monthly.values).plot(grid=True,figsize=(12,6),legend=False) ax.set_xlabel('月份') # X轴label ax.set_ylabel('订单数') # Y轴Label ax.set_title('月度订单数') # 图题 #设定X轴月份显示格式 plt.xticks( range(len(df_orders_monthly.index)), [x.strftime('%Y.%m') for x in df_orders_monthly.index], rotation=45) plt.show() # 绘图 2.数据清洗 df_sales = df_sales.drop_duplicates() #删除重复的数据行 df_sales.isna().sum() # NaN出现的次数 df_sales.describe() #df_sales的统计信息 df_sales = df_sales.loc[df_sales['数量'] &gt; 0] #清洗掉数量小于等于0的数据 df_sales.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47f471de775c954587f8e62d9580bdcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d1390b12f5cbf51631a9a782f39989/" rel="bookmark">
			回溯算法part01 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回溯算法part01 今日内容：
● 理论基础
● 77. 组合
1.LeetCode77. 组合 https://leetcode.cn/problems/combinations/
模板
//回溯算法模板 void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 未剪枝版本:
//未剪枝版本 class Solution { //定义全局变量 //一维集合 List&lt;Integer&gt; path=new ArrayList&lt;&gt;(); //二维集合 List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { //整个回溯过程抽象为一棵树形结构 backtracking(n,k,1); return result; //给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合 //返回1-4范围内可能的2个数的组合 //组合可以不按顺序 } //确定回溯的返回值和参数 //一般回溯算法的返回值是void public void backtracking(int n,int k,int beginIndex){ //beginIndex用来记录每次需要遍历的位置 //确定终止条件 //遇到一维数组的大小等于k了，证明我们已经遍历到叶子节点了 if(path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94d1390b12f5cbf51631a9a782f39989/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1af10d45a0ba5637c1a0989ead85b77/" rel="bookmark">
			《计算机网络》 第三章 数据链路层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.1 使用点对点通信的数据链路层 数据链路层信道类型：①点对点信道 ②广播信道
3.1.1 数据链路和帧 链路：中间无其他交换节点的物理链路
数据链路：把实现控制数据传输的协议的硬件和软件加到链路上，就构成了数据链路
数据单元：帧
3.1.2 三个基本问题 1.封装成帧 数据前后添加首部（SOH）和尾部（EOT）构成一个帧
最大传送单元MTU：规定帧数据部分长度上限
2.透明传输 无论发什么样的比特数据，都能没有差错的通过这个数据链路层。
采用方法：①字节填充 ②字符填充
3.差错控制 误码率BER：传输错误比特占所传输比特总数
🔺循环冗余码：
帧校验序列FCS：在数据后面添加的冗余码
仅用循环冗余检验CRC差错检测技术只能做到无差错接受
“无比特差错”与“无传输差错”是不同的
可靠传输:：数据链路层的发送端发送什么，在接收端就收到什么
传输差错：①比特差错 ②传输差错:帧丢失、恢重复或失序等
在数据链路层使用 CRC检验，能够实现无比特差错的传输但这还不是可靠传输
要做到可靠传输，还必须再加上帧编号、确认和重传等机制
3.2 点对点协议PPP 3.2.1 PPP协议的特点 1.PPP协议应满足需求 简单、封装成帧、透明性、同一物理链路支持多种协议、差错检测、最大传送单元、检验连接状态
用户到ISP链路使用PPP协议，通常用于广域网
2.PPP协议组成 ①一个将IP数据报封装到串行链路的方法
②一个链路控制协议 LCP
③一套网络控制协议 NCP
3.2.2 PPP协议的帧格式 PPP面向字节，帧长都是整数字节
①当 PPP用在异步传输时，使用字节填充法
②当 PPP 用在同步传输链路时，采用零比特填充法
3.2.3 PPP协议的工作状态 ①用户拨号接入ISP 后，就建立了一条从用户个人电脑到ISP 的物理连接。
②用户个人电脑向ISP 发送一系列的链路控制协议 LCP 分组，以便建立LCP连接。
③之后进行网络层配置。网络控制协议 NCP 给新接入的用户个人电脑分配一个临时的IP 地址。
④当用户通信完毕时，NCP 释放网络层连接，收回原来分配出去的IP地址。LCP 释放数据链路层连接。最后释放的是物理层的连接。
3.3 使用广播信道的数据链路层 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1af10d45a0ba5637c1a0989ead85b77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af9d1228ed7d7a0db1a0fbaa5ef36485/" rel="bookmark">
			Python爬虫获取百度的图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 爬虫的方式： 主要有2种方式:
①Scrapy+Xpath (API 静态 爬取-直接post get) ②selenium+Xpath (点击 动态 爬取-模拟) Scrapy+Xpath XPath 是 Scrapy 中常用的一种解析器，可以帮助爬虫定位和提取 HTML 或 XML 文档中的数据。
Scrapy 中使用 XPath 的方式和普通的 Python 程序基本一致。我们需要首先导入 scrapy 的 Selector 类和 scrapy 的 Request 类，然后使用 Selector 类来解析 Response 对象，并使用 XPath 表达式来定位和提取数据。
详细讲解可以参考：Scrapy爬虫学习笔记之二（Xpath的用法） - 知乎
selenium+Xpath Selenium 是为了解决 requests 无法直接执行 JavaScript 代码的问题。本质是通过驱动浏览器，完全模拟浏览器的操作，输入、点击、下拉等。
安装：pip install selenium
使用需要下载浏览器驱动，并且驱动要跟浏览器版本对应
chrome浏览器版本在114之前
浏览器版本在114之前，可以进入以下网址http://chromedriver.storage.googleapis.com/index.html，直接下载相应的文件
chrome浏览器版本在115以上
以下版本皆为chromedriver版本
例如：version : 119.0.6045.21，你电脑的浏览器版本为其他版本，如118.0.5952.2，只需要把链接中的版本号替换成这个编号即可
平台下载地址linux64http:// https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/119.0.6045.21/linux64/chromedriver-linux64.zipmac-arm64https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/119.0.6045.21/mac-arm64/chromedriver-mac-arm64.zipmac-x64https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/119.0.6045.21/mac-x64/chromedriver-mac-x64.zipwin32https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/119.0.6045.21/win32/chromedriver-win32.zipwin64https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/119.0.6045.21/win64/chromedriver-win64.zip Chromedriver 插件安装教程
参考：稳扎稳打学爬虫09—chromedriver下载与安装方法-CSDN博客
下面简单使用模拟百度搜索：
import time from selenium import webdriver bro = webdriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af9d1228ed7d7a0db1a0fbaa5ef36485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1678d1e0266a2780c78f113475f0f218/" rel="bookmark">
			华为HCIA课堂笔记第六章 OSPF基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第六章 OSPF基础
6.1背景
6.2距离矢量路由与链路状态路由协议的区别
6.3 链路状态路由协议工作过程
6.4 概念
6.4.1 区域
6.4.2 Router ID
6.4.3 OSPF进程
6.4.4 OSPF 开销值
6.4.4 防环原则
6.5 OSPF报文的种类
6.6 Hello报文
6.6.1 Hello报文参数
6.6.2 影响邻居关系建立的因素
6.7 OSPF的三张表
6.7.1 邻居表
6.7.2 LSDB表
6.7.3 OSPF协议路由表
6.8 OSPF的工作机制
6.8.1 确认机制
6.8.2 邻居/邻接关系建立
6.8.3 邻居状态机
6.8.4 OSPF网络类型
6.8.5 DR和BDR
6.8.6 单区域和多区域
第六章 OSPF基础 6.1背景 动态路由协议的优势：相比于静态
静态路由无法适应大规模的网络，配置量大静态路由不能自动感知网络拓扑的变化，自动收敛。 6.2距离矢量路由与链路状态路由协议的区别 距离矢量路由协议，逐跳传递路由表信息，对于收到路由的设备，仅知道要去往目的地需要将报文交给下一跳的设备，不知道后续转发路径。
链路状态路由协议，传递的链路状态信息，设备会收到所有其他设备的链路状态信息，设备根据链路状态信息可以知道整个网络拓扑，并自行计算路由。
6.3 链路状态路由协议工作过程 邻居关系：相互之间建立邻居关系同步LSDB：发送各自的LSA（链路状态信息），将收到的链路状态信息存在在自己的LSDB（链路状态数据库）。计算拓扑和路由：全网拥有相同的LSDB，以各自自己为根根据LSDB计算拓扑和路由将计算的路由加入到路由表中，指导报文转发。 6.4 概念 6.4.1 区域 1、32bit组成，将设备划分到不同的组，每一个组通过区域ID标识区域ID：32bit组成，两种表示方式 十进制：0,1…… 100点分十进制：0.0.0.0 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1678d1e0266a2780c78f113475f0f218/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0cae69c6dd096011ecb3090758c0746/" rel="bookmark">
			案例103:基于微信小程序的移动网赚项目设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：springboot
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
用户功能模块的实现
用户注册登录界面
首页界面
任务界面
兑换物品界面
签到界面
我的界面
管理员功能模块的实现
管理员登录界面
用户管理界面
签到管理界面
任务管理界面
任务分类管理界面
兑换物品管理界面
提交审核管理界面
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着计算机技术的成熟，互联网的建立，如今，PC平台上有许多网赚项目的程序，但由于使用时间和地点上的限制，用户在使用上存在着种种不方便，而开发一款基于微信开发的移动网赚项目小程序，能够有效地解决这个问题。
本移动网赚项目小程序采用WXML 、WXS、JS小程序编写语言、微信开发者工具进行微信端开发，使用MYSQL数据库进行储存系统数据，以微信为入口的，具有快捷、轻便的特点，不占内存，不用下载、安装，而且访问速度很快。系统界面良好，操作简单方便，通过系统概述、系统分析、系统设计、数据库设计、系统测试这几个部分，详细的说明了系统的开发过程，最后并对整个开发过程进行了总结，实现了查看任务、接单任务以及兑换商品的重要功能。
“操作简单，功能实用”这是本软件设计的核心理念，本系统力求创造最好的用户体验。
系统展示 用户功能模块的实现 用户注册登录界面 没有账号的用户可进行注册操作，注册后可进入登录界面进行登录系统
首页界面 用户登录后进入系统首页 任务界面 用户在任务界面可查看所有任务信息，并可进行查看详情 兑换物品界面 用户可查看兑换物品信息，并可选择查看详情，进行兑换操作 签到界面 用户登录后还可进行签到操作 我的界面 用户在我的界面可根据需求进行相应操作 管理员功能模块的实现 管理员登录界面 管理员要想进入系统后台对系统进行管理操作，必须登录系统后台 用户管理界面 管理员登录后可查看、新增、修改和删除用户信息
签到管理界面 管理员可查看、添加、修改和删除签到信息
任务管理界面 管理员可添加、修改和删除任务信息 任务分类管理界面 管理员可增删改查任务分类信息 兑换物品管理界面 管理员能够查看、添加、修改和删除兑换物品信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0cae69c6dd096011ecb3090758c0746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e165e6d7022fb44f402f1202df5e2e94/" rel="bookmark">
			华为HCIE课堂笔记第十三章 IPv6地址配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第十三章 IPv6地址配置
13.1 IPv6地址无状态自动配置
13.1.1 RS和RA报文格式
13.1.2 RA的Flags字段
13.1.3 地址的生存周期
13.1.4 RA报文中前缀中的Flags
13.2 DHCPv6
13.2.1 DHCPV6的概念
13.2.2 DCHPv6的报文
第十三章 IPv6地址配置 13.1 IPv6地址无状态自动配置 使用RS和RA报文实现
13.1.1 RS和RA报文格式 RA报文的目的IPv6地址：所有的IPv6节点组播地址FF02::1
RS报文的目的IPv6地址：所有路由器节点的组播地址FF02::2
两个报文的源IPv6地址：链路本地地址
无状态自动配置的过程：
单播地址配置后都需要进行DAD检测PC自动生成链路本地地址。PC已自己的链路本地地址为源地址发送RS请求报文。路由器收到RS报文后回复RA报文，携带前缀信息PC收到前缀信息，根据前缀信息+自己产生的接口ID生成IPV6 13.1.2 RA的Flags字段 Mbit位（Managed）：管理地址配置标识：两种取值
M取值为0：表示通过无状态自动配置配置IPv6地址和参数信息 Obit位：其他有状态配置标识，其他的参数如何配置。 取值为0：其他参数通过无状态自动配置实现。取值为1：其他参数通过DHCPv6配置实现。M取值为1：表示通过DHCPv6有状态配置配置IPV6地址和参数信息。 Obit位：忽略，无论是否取值，都使用DHCPv6获取地址和其他参数。 Router preference：路由器优先级，终端收到多个RA报文，来自不同的路由器，可以通过该字段选择缺省网关，生成缺省路由。优先级字段取值高、中、低，优先级越高越优。
13.1.3 地址的生存周期 两个计时器：优选时间，有效时间；优选时间被包含在有效时间内。有效时间=优选时间+Deprecated阶段的时间
单播地址被配置在接口后，进入到实验地址阶段，地址状态标记为实验地址经过DAD（重复地址检测），该地址进入到优选时间，成为优选地址 优选地址可以新建连接，正常收发报文优选地址超过优选时间计时器，则进入到Deprecated阶段，成为Deprecated状态地址。 改地址可以继续使用，但不建议使用，不能用于新的连接的建立。当地址的使用时间超过了有效时间，则从Deprecated状态切换到invalid状态，成为不可用地址。无法使用该地址进行通信。 13.1.4 RA报文中前缀中的Flags 1、Autonomouns Addr-conf flag：自动配置位，默认置位，置位后，其他设备收到了该RA报文，可以根据该前缀进行无状态自动配置。如果不置位，表示收到该报文之后，不使用该前缀进行无状态自动配置。
2、一个RA报文中可以携带同一个链路的多个前缀信息。
13.2 DHCPv6 13.2.1 DHCPV6的概念 T1时间：只IPV6的租期剩余0.5的时候，需要进行地址的重新续租操作。
T2时间：IPV6地址的租期剩余0.2（到达0.8）的时候，需要进行地址重绑定操作。
13.2.2 DCHPv6的报文 DHCPv6有状态交互的四步：与IPV4类似
DHCPv6 有状态交互两步：携带rapid commit选项，如果服务器支持，则进行两步交互，直接回复reply报文，携带参数；不支持，则进行四步交换，使用Solicit、advertise、request、reply报文实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b22e95af2ce6649ba53dd9e660db2ea3/" rel="bookmark">
			PostgreSQL 低级错误集锦 （不定时更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 低级错误真的浪费时间且菜，希望不再犯低级重复错误。
1.to_date()函数日期转换报错 SQL语句：
SELECT job_date FROM data_check WHERE data_type = 'S'; 查询结果：
job_date | ----------+ 2023-01-28| 我希望用update语句更新job_date字段，但出现报错，就用SELECT语句查看问题。
我的SQL：
SELECT to_date('20230127','yyyy-mm-dd hh24:mi:ss') FROM data_check WHERE data_type = 'S' ; 报错信息：
SQL 错误 [22008]: ERROR: date out of range: "20230127" 为什么报错？
在 PostgreSQL 中，to_date 函数用于将字符串转换为日期，"20230127" 不是有效的日期格式，因此导致了日期超出范围的错误。
在我的 SQL 查询中，to_date('20230127','yyyy-mm-dd hh24:mi:ss') 的日期格式为 'yyyy-mm-dd hh24:mi:ss'，但是输入的字符串 "20230127" 并不符合该格式，因此 PostgreSQL 无法正确解析。
使用to_date函数时，转换格式需要和日期本来的格式相匹配
正确的SQL：
SELECT to_date('20230127', 'YYYYMMDD'); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4288858810b7b12e5faea1869fc005c3/" rel="bookmark">
			Latex &#43; Overleaf 论文写作新手笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.tex 文件main.tex 文件 Latex 的文档层次结构不同文档类型的层次结构report 6 层结构实例article 5 层结构实例 Latex 语法图表插入与引用使用 figure 环境来插入图片使用 ref 命令来引用已有的图表格的插入与引用 代码块列表无序列表 itemize有序列表 enumerate 学位论文项目实战 Overleaf 的项目是由一个或多个 .tex 文件和其他相关的文件组成的。
Overleaf 官方教程
.tex 文件 .tex 文章组成：
导言区 preamble：
\documentclass{article} 到 \begin{document}正文区 document body：
\begin{document} 到 \end{document} .tex 文章的组成可以分为两个部分：导言区和正文区。
导言区 是文档的开头部分，用于定义文档的类型、调用宏包、设置格式等。正文区是文档的主要内容部分，用于编写文档的结构、文字、图表等。导言区和正文区之间用 \begin{document} 和 \end{document} 命令来分隔。 main.tex 文件 main.tex 是 项目的主文件，也就是 LaTeX 首先编译的文件。
它包含了文档的 类型、标题、作者、日期等信息，以及 文档的正文内容。它也可以调用其他的文件，例如类文件、宏包文件、章节文件等，来实现文档的功能和格式。 main.tex 文件的一般结构如下：
\documentclass[选项]{文档类型} % 定义文档的类型和选项，例如 article, report, book 等 \usepackage[选项]{宏包名} % 调用需要的宏包，例如 graphicx, amsmath, subfiles 等 % 其他的导言区设置，例如定义命令、设置页面、设置字体等 \begin{document} % 文档的开始 \title{标题} % 定义文档的标题 \author{作者} % 定义文档的作者 \date{日期} % 定义文档的日期 \maketitle % 生成标题页 \tableofcontents % 生成目录 % 文档的正文内容，可以使用 \section, \subsection, \subsubsection 等命令来创建层次结构 % 可以使用 \include, \input, \subfile 等命令来调用其他的文件，例如章节文件、图形文件等 \end{document} % 文档的结束 Latex 的文档层次结构 Latex 的文档层次结构是指 文档中的不同部分，如 章节、小节、段落 等，以及它们之间的关系和编号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4288858810b7b12e5faea1869fc005c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/166a68a861246bb0fa67c499983c5d30/" rel="bookmark">
			Django 9 常用通用视图分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		View 提供基于不同http方法执行不同逻辑的功能。
1. 创建 terminal输入 django-admin startapp the_13回车 2.tutorial子文件夹 settings.py注册一下
INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', "the_3", "the_5", "the_6", "the_7", "the_8", "the_9", "the_10", "the_12", "the_13", ] 3. tutorial子文件夹 urls.py
urlpatterns = [ path('admin/', admin.site.urls), path('the_3/', include('the_3.urls')), path('the_4/', include('the_4.urls')), path('the_5/', include('the_5.urls')), path('the_7/', include('the_7.urls')), path('the_10/', include('the_10.urls')), path('the_12/', include('the_12.urls')), path('the_13/', include('the_13.urls')), ] 4. the_13\views.py from django.shortcuts import render from django.views import View # Create your views here. class Hello(View): pass ctrl + 鼠标左键 点击 View可以看源码里面的View方法 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/166a68a861246bb0fa67c499983c5d30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4055e87c8a0f188bc3baf996b2bd0a75/" rel="bookmark">
			数据结构——堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、堆
1.1 堆的概念
1.2 堆的存储
1.3 堆的应用
二、堆的实现
2.1 堆的调整算法
（1）向下调整算法
（2）向上调整算法
2.2 堆的创建
2.3 堆的删除
三、堆的代码实现 四、堆排序
4.1 原理
4.2 代码实现
一、堆 1.1 堆的概念 堆（Heap）是一种特殊的树，如果将一个集合中的所有元素按照完全二叉树的顺序存储方式存储在一个一维数组中，并满足一定的规则，则称为堆。堆的性质有：
堆中任意节点的值总是不大于或不小于其父节点的值堆总是一颗完全二叉树 【拓展补充】：满二叉树每一层都是满的；完全二叉树最后一层可以不满，但是从左到右必须是连续的
接下来引入大小堆的概念，这也是堆在建立之时必须遵循的规则，如果不满足其中任意一种便不能称为堆
大堆（大根堆/最大堆）：树中任何一个父节点都大于或等于子节点，根节点是最大值
小堆（小根堆/最小堆）：树种任何一个父节点都小于或等于子节点，根节点是最小值
1.2 堆的存储 因为堆是一种特殊的完全二叉树，其存储方式与完全二叉树的顺序存储方式相同。
顺序结构存储就是使用数组来存储，一般只有完全二叉树适合用数组来存储，因为非完全二叉树的元素不连续会造成空间的浪费
使用数组来存储，父子节点的关系如下
父节点：（子节点-1）/ 2
左子节点：（父节点*2）+1
右子节点：（父节点*2）+2
1.3 堆的应用 堆排序
TopK问题
优先级队列
二、堆的实现 2.1 堆的调整算法 假设给出一个数组，我们在逻辑上可以将其看作一颗完全二叉树，但是这个数组不能被称为堆。通过使用堆的调整算法我们可以将其调整成一个大/小堆。
（1）向下调整算法 向下调整算法就是将目标节点与左右子节点对比，符合条件则交换
向下调整算法有一个前提：左右子树必须是堆
例如图中，以27为根的左右子树都满足小堆的性质，只有根节点不满足，所以只需要将其与左右子节点中较小的交换即可
（2）向上调整算法 向上调整算法就是将目标节点与父节点对比，符合条件则交换
堆的插入就需要用到向上调整算法，例如我们在一个小堆中插入了一个新的元素：
使用向上调整算法：
2.2 堆的创建 堆的创建是堆排序中的一个重要部分。如果要将一个数组构建成堆，使用向下调整算法是最优解。但是根节点的左右子树都不是堆，所以我们反其道而行之，从最后一个节点的父节点开始进行向下调整。
因为单个节点也能成堆，所以最后一层的所有叶子节点都可以被视为堆，接着我们就对数组进行从后向前遍历，从最后一个节点的父节点开始向下调整
例如这个数组，我们要将其构建成小堆，先将其看作一颗完全二叉树
然后从最后一个节点的父节点开始向下调整，因为要遵循小堆规则所以二者交换
交换完毕，遍历到前一个节点，此时父节点小于两个子节点，所以不需要交换，跳到10
此时父节点是10，左子节点是7，右子节点是3，3比7更小，所以将10与3交换
现在，小堆就建立完毕了
2.3 堆的删除 一般堆的删除是指删除堆顶的数据。但是我们不能直接将数组的元素向前挪动覆盖第一个元素，因为在逻辑结构上，不同节点之间的关系已经建立，如果单纯的进行元素挪动就会打破所有的关系，将整个堆破坏。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4055e87c8a0f188bc3baf996b2bd0a75/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/23/">«</a>
	<span class="pagination__item pagination__item--current">24/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/25/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>