<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f65c0471c8b630b8ddc3da64146173bd/" rel="bookmark">
			PyTorch训练多任务模型技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、解决在分布式训练中，如果对同一模型进行多次调用的报错 报错如下：
RuntimeError: one of the variables needed for gradient computation has been modified by an inplace operation: [torch.cuda.FloatTensor [256)] is at version 4; expected version 3 instead. Hint: enable anomaly detection to find the operation that failed to compute its gradient, with torch.autograd.set_detect_anomaly(True).
参考知乎文章《【PyTorch踩坑】一个排查了一下午的坑》
经过一些调试发现，只有当某些特定情况下才会触发此报错。下面结合一个对比学习的例子（并不是完整的脚本）来简单描述：
import torch import torch.nn as nn from torchvision.models import resnet50 def main(): model = resnet50(num_classes=256).cuda() model = nn.parallel.DistributedDataParallel(model, device_ids=[args.local_rank], find_unused_parameters=True) criterion = nn.MSELoss() optimizer = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f65c0471c8b630b8ddc3da64146173bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e60f453fe7128763e7402d6d26d081a/" rel="bookmark">
			Rust 修改源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装源 运行命令，下载rust安装脚本
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf &gt; rust.sh &amp;&amp; chmod +x rust.sh 替换更新源
sed -i 's/${RUSTUP_UPDATE_ROOT:-https:\/\/static.rust-lang.org\/rustup}/https:\/\/mirrors.ustc.edu.cn\/rust-static\/rustup/g' rust.sh 设置环境变量
export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup 安装 运行命令 sudo bash rust.sh，输入回车选择默认进行安装。
检查 cargo -V # cargo 1.75.0 (1d8b05cdd 2023-11-20) rustc -V # rustc 1.75.0 (82e1608df 2023-12-21) 软件源 通过修改 ~/.cargo/env 来修改源。
常规修改 修改 ~/.cargo/env。
[source.crates-io] replace-with = 'ustc' [source.ustc] registry = "git://mirrors.ustc.edu.cn/crates.io-index" 稀疏索引（推荐） cargo 1.68 版本开始支持稀疏索引：不需要完整克隆 crates.io-index 仓库，可以加快获取包的速度。
如果cargo 的版本大于 1.68，可以在 $HOME/.cargo/config中添加以下内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e60f453fe7128763e7402d6d26d081a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a974c35b758dfe4e6a7adf46f4f58122/" rel="bookmark">
			基于OpenVINO和AIxBoard的智能安检盒子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：辽宁科技大学 研究生 冯浩
指导教师：英特尔边缘计算创新大使 深圳职业技术大学 副教授 张海刚
1、背景介绍： 公共安全问题日益凸显，传统安检手段面临挑战。为提高安检效率和保障公共安全，基于OpenVINO和AIxBoard的智能安检盒子应运而生。利用深度学习模型和X光图像处理技术，该设备能够实时识别危险物品并发出警报，为公共场所、机场等场景提供高效、准确的安检解决方案
2、技术概述 2.1 OpenVINO™工具包 OpenVINO™是一种开放的视觉推理库，提供了一系列深度学习模型和算法，用于对图像和视频进行推理和分析。它的功能特点包括支持多种深度学习模型和算法、具有高度可扩展性和可定制性、能够运行在多种硬件平台上等。
OpenVINO™广泛应用于计算机视觉领域，包括人脸识别、物体检测、场景分割、姿态估计等。在智能安防、智能交通、智能零售、智能医疗等领域都有广泛的应用，例如用于智能监控、智能交通管理、智能商品推荐、智能医疗诊断等。
2.2 X光图像采集技术 X光图像采集技术就是利用X光穿透物体，然后记录下来X光在物体内部的强度变化，从而得到物体内部的结构信息。这种方法不需要打开物体，就能看到里面的情况，所以叫做非侵入性。这种技术非常快，可以实时看到结果，因此在医学、工业和安全检查等领域都有广泛应用。比如在医学中，可以通过X光看到人体内部的疾病情况，如骨折或肺部疾病；在工业中，可以用来检查产品内部是否有裂缝或缺陷；在安全检查中，可以用来检查行李或包裹中是否有危险物品。
2.3深度学习模型 我们设计的模型提出”副通道对主通道实现特征助力”。该模型旨在实现对主通道X光安检图像中违禁品的检测，副通道则通过融合模块对主通道实现特征增强。副通道特征融合模块的设计如上图所示，引入通道注意力和空间注意力以实现有效特征筛选。现阶段，该研究成果已成功发表在PRCV 2022会议上，相关代码已经公开。
Github: https://github.com/zhgSZPT/Dualray
3、X光智能安检盒子 3.1硬件设备 安检机和xBoard
整个安检流程需要三个硬件设备，其一是安检机用于扫描X光图像、其二是安检盒子用于推理AI模型以及提供界面展示服务，其三是监视器用于给安检人员检视。
3.2安检盒子整体检测流程 安检机通过X光扫描出一张图像，安检机中的插件会监控图像的生成以及负责通知并传输到安检盒子，安检盒子拿到图像之后使用OpenVINO、OpenCV等框架进行进行AI模型推理监测，将推理后得到的结果通过网页的形式展示给安检人员。
3.3 安检盒子界面效果 完整演示视频：Youtube
4、X光智能安检盒子的优势 4.1双视角数据集：目前我们拥有最大的双视角数据集，这意味着我们的系统具有更丰富的图像数据，可以更准确地识别各种物品，提高安检的准确性。
4.2准确性：通过双视角监测技术和AI模型推理，使我们能够从多个角度观察被检物品，提高识别的准确性，大大减少漏检情况发生，有效识别各种危险物品。
4.3高效性：与传统的人工安检相比，X光智能安检盒子可以24小时不间断工作，大大提高了安检效率。
4.4成本低：我们与英特尔直接进行供应链管理，从而降低硬件采购成本
4.5便携性：通过在安检机中部署插件，我们可以实现与不同安检设备的无缝衔接部署
观看视频链接：智能安检盒子.mp4_免费高速下载|百度网盘-分享无限制 (baidu.com)https://pan.baidu.com/s/1sBblS3s2bELvHgDKnbQ3CQ?pwd=30bq
5、应用场景与案例分析 在公共场所，如商场、地铁、火车站等，X光智能安检盒子的应用能够有效提升安全检查的效率和准确性。以地铁为例，通过在地铁入口或重要站点部署X光智能安检盒子，能够实时对通过的行李和物品进行扫描和分析，迅速识别出潜在的危险物品，如刀具、枪等。这不仅能够提高安检的效率，减少人工操作的错误率和漏检率，还能够提供更加准确和可靠的安全保障，确保公共安全。
6、结论 X光智能安检盒子作为一种高科技的安检设备，在提升安检效率和保障公共安全方面具有重要意义。随着技术的不断发展和优化，X光智能安检盒子的应用范围也在逐步扩大。例如，在机场、火车站、地铁站等场所，X光智能安检盒子能够对乘客进行快速安检，大大提高了安检效率。在学校、企事业单位等场所，X光智能安检盒子也被广泛应用于安全检查。因此，可以预见的是，随着技术的不断进步，X光智能安检盒子将会在更多的场景中发挥重要作用，如海关、快递物流、金融等行业。
然而，在关注X光智能安检盒子的效率和安全性的同时，我们也必须关注其隐私保护和数据安全问题。这是因为，X光智能安检盒子的使用可能会涉及到乘客的个人信息，如身份信息、行李物品信息等。如果这些信息被不法分子获取，将会对乘客的隐私造成威胁。因此，在推广和使用X光智能安检盒子的过程中，我们必须加强对数据安全的监管和保护，确保乘客的个人信息不会被泄露或滥用。同时，我们也需要加强对X光智能安检盒子的技术创新和改进，不断提高其性能和安全性，以更好地保障乘客的权益和安全。
相关文章专利以及产权 (1) Yu Ren, Haigang Zhang*. LightRay: Lightweight Network for Prohibited Items Detection in X-ray Images during Security Inspection, Computers and Electrical Engineering, 2022, 103, 108283.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a974c35b758dfe4e6a7adf46f4f58122/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/417e8e3a51adc6566169d25bb1f2529b/" rel="bookmark">
			如何为开源项目做贡献—您应该知道的十件事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：英特尔物联网行业创新大使 颜国进
一、前言 大家好，我叫颜国进，现为英特尔边缘计算创新大使、百度飞桨开发者专家。回溯至2021年12月，那时的我，身为机械专业研一新生，仅在C和Python编程语言上有些许基础，对于深度学习的殿堂还只敢在门口窥探，对于OpenCV图像处理以及模型部署等技术更是所知甚少。然而，通过不懈的努力和对知识的执着追求，如今我已经能够娴熟地运用C++、C#等编程语言进行项目开发，并且能够使用Python和各类深度学习框架来训练自己的模型。值得一提的是，我已经发布并运营了一项名为OpenVINO C# API的开源项目，为在C#平台开发深度学习和计算机视觉应用的开发者提供更便捷的工具。围绕该项目，产出了多篇富有深度的技术文章，分享了我在使用OpenVINO部署深度学习模型过程中的洞见和体会。
在深入参与开源项目的过程中，我也广泛参考了网上的一些成功项目经验，得到了无数宝贵的经验和技能提升，这使得我的技术层次上升到了全新的高度。经过两年的探索与实践，技术能力得到了显著的提高，而更重要的是，我的努力得到了越来越多人的认可和支持，从而扩大了我在技术社区的影响力。时值我开展开源项目的两周年，我有幸应张晶和李翊玮老师的邀请，以及武卓博士的悉心指导，有机会整理与分享我从一个技术新手逐步成长到拥有自己开源项目的经验与感想。我希望我的分享能为刚刚踏入开源领域的新手们提供一些有价值的参考，帮助他们更迅速地融入这个富有活力和创新精神的开源社区。
下面，我将从四个层面并结合十个具体的问题分别向大家一一道来。
二、为什么要做开源 问题一：给开源项目和社区做贡献？ 首先，我们来探讨一下为什么应该为开源项目和社区做出贡献。对于那些还在犹豫不决是否投身于开源项目的小伙伴们，我希望能够提供一个有力的依据。参与开源项目不仅有助于个人的技能提升和职业发展，更能推动整个技术社区的进步。通过你的贡献，我们可以共同创造一个更加开放、协作和创新的技术生态，让每个人都能从中受益。
参与开源项目和社区对个人具有多方面的积极影响。
技术提升——通过参与开源项目，个人能够接触和学习到更多的技术工具和前沿技术，推动自身技术的不断提升。并且开源项目可以获取全部源码，这对你深入了解一项技术实现以及应用，会有很大的帮助。
提升个人的声誉和影响力——通过专注于某一领域并在其中深耕，你可能成为该领域的专家，吸引其他技术专家的关注和求助。这些互动和认可不仅有助于建立个人的专业声誉，还可能带来一些荣誉称号，为未来的发展提供有力的支持。
塑造个人的未来发展轨迹——开源的自由性和包容性使得个人能够自主选择感兴趣的领域进行探索和发展。你可以将开源项目中的经验和技能应用到自己喜欢的领域中，或者通过开源项目发展新的兴趣和专业方向。这将为个人的职业发展带来更多的可能性和机遇。总之，参与开源项目和社区对个人技术提升、声誉建立以及未来发展都具有积极的影响。这是一个充满挑战和机遇的舞台，值得每个有志于技术领域的人积极参与和贡献。
除此之外，开源还对当前行业以及企业发展带来了更多的红利。
开源已经成为软件行业的基础——开源促进了技术的快速发展和创新：
第一点，由于代码是公开的，开发者可以基于现有的项目进行创新，而不需要从零开始，这样的协作和共享精神加速了新技术的诞生和成熟。
第二点，开源软件通常是免费提供的，这降低了企业和个人使用和实施新技术的成本，企业可以使用开源软件来构建复杂的系统，而无需支付昂贵的授权费用。
第三点，开源软件赋予用户更大的自由度，用户可以自由地修改和改进软件以满足自己的需求，这种灵活性对于需要定制解决方案的企业和开发者来说是非常重要的。
第四点，开源项目通常有一个活跃的社区，社区成员可以相互支持，解决问题，分享经验。这种广泛的协作和支持网络是传统闭源软件难以比拟的。
第五点，开源项目可以非常迅速地迭代和改进，社区贡献者可以快速响应问题，提交补丁，添加新功能，从而保持软件的活力。基于此，可以看出开源软件已经深刻地影响了软件产业的各个方面，并且在很多情况下成为了技术创新和应用的基石。
(上图由文心一言AI生成)
开源已经成为当前最前沿技术的发展的强大动力——开源模式鼓励全球范围内的协作和知识共享，由于开源项目可以被任何人审查、使用、修改和改进，这样的透明度和可接触性降低了进入门槛，极大地促进了创新的速度和质量。此外开源社区的参与者可以迅速识别和修复软件中的错误，增加新的功能，并持续改进产品，这种集体智慧的应用使得技术能够快速迭代和演进，经常超出单一组织的开发速度。开源项目往往吸引来自不同组织和行业的贡献者。这种多元化的视角和专业知识结合在一起，可以解决复杂的问题，推动前沿技术的发展。开源项目还是人才发现和发展的平台，许多开发者通过参与开源项目获得实战经验，进而成为行业内的专家。最后开源项目提供了高质量的软件基础设施，许多公司和组织可以直接使用或构建自己的产品，比如Linux操作系统、Apache Web服务器、MySQL数据库、TensorFlow机器学习框架、OpwenVINO模型部署框架等，都是开源项目，它们为最前沿的技术发展提供了坚实的基础。开源项目围绕它们构建了强大的生态系统，这个生态系统是持续创新的土壤，帮助技术不断进步。
(上图由文心一言AI生成)
废话了这么多，但也很难完全表述给开源项目和社区做贡献的好处，下面我将从个人经历简单讲述一下做开源项目这两年，到底给我带来了啥？
技术方面：刚开始做开源项目时，我的状态就是一个非计算机专业、没有编程经验和算法基础的新手小白，蜕变成为一个可以实现在C/C++、C#和Python环境下使用多种部署工具套件落地AI设备全流程开发，并且在稳定运行了多个小型开源项目。在这过程中，我学习了C++、C#以及Python编程语言，这样我就可以能够看懂开源新项目的源码；我做的主要领域时深度学习模型部署，因此我自学了OpenVINO、TensorRT、ONNX runtime 等模型部署工具，实现在各种平台下部署深度学习模型。并且由于所做工作为开源项目，为了遵循开源社区规范，自己也养成了良好的编程习惯以及代码规范，学会了开源项目从创建、提交、完善、维护、更新以及发布等全套流程。
开源贡献：结合自己接触的一些开源项目，自己选者了一个方向去做，主要是在C#平台部署深度学习模型。基于OpenVINO模型部署工具创建了OpenVINO C# API项目，并结合该项目，开发了当前流行的模型部署案例。截止到目前，自己已经在开源平台GitHub平台贡献了100,000多行代码，推出了10多个开源项目。除此以外，自己还结合所做的开源项目，在多个平台与开源社区发布了了多篇技术文章，获得了上千人的阅读，并且在CSDN平台打造自己的博客平台，截止目前已经发表了42篇文章，获得了80000+的阅读量以及1400+的粉丝关注，在分享自己案例指导指导其他开发者的同时，也收获了更多人的关注，提升了自己的影响力。同时由于自己专注于英特尔以及百度飞桨的开源项目工作，因此获得了英特尔边缘计算创新大使、百度飞桨开发者专家等荣誉称号。
上面只是简单总结了自己这两年以来做开源项目所获得的东西，可以看出，给开源项目和社区做贡献，在成就开源社区的同时，更大的就是成就了自己。
三、如何为开源做贡献 上面我们讲了这么多给开源项目和社区做贡献的好处，可能有一些小伙伴就开始心动了，下面我们就展开讲述一下有哪些途径可以为开源做贡献，具体是如何做的。
问题二：如何提Issue？ 首先向大家介绍一下第一种方式，也是入门级别相对简单也是比较容易实现的，就是给开源项目提交Issue。开源项目在发布时尽管发布者或者团队已经做了很详尽的测试，但由于使用对象以及使用环境等因素的影响，使用者难免会出现相关问题以及新的使用需求，因此我们提交Issue可以包括以下内容：
Bug报告：你发现了代码中的错误或异常行为。功能请求：你希望项目中添加一个新功能或改进现有功能。问题咨询：你在使用或配置项目时遇到了困难。文档改进：你认为项目的文档需要更清晰或更完整。 当然，这是是我列出来的常见内容，具体还是看使用者需求，因此提交Issue一定是该开源项目的使用者，再使用时碰到难以解决的问题时我们就可以通过提交Issue方式解决，这样不仅可以帮助自己解决问题，还可以促进开源项目的改进与发展，属于两全其美的事情。
再确定了你的问题以及你要提交Issue时，你需要先做一步问题检查，检查一下是否有小伙伴提交过相同的Issue，这样可以避免提交重复的问题，给开源项目发布人员带来不必要的负担，也是对做开源工作对其他人员的最起码的尊重。如果你发现这是一个新的问题，之前并没有人提过，那么好，你就可以开始提交你的Issue了，主要包括以下几个步骤：
第一步：创建一个新的Issue
此处以OpenVINO库为例，创建一个新的Issue。
OpenVINO官方提供了不同的Issue类型选择，此处可以根据你所需要的问题类型进行选择。
第二步：编写Issue标题：
使用简洁明了的标题来描述你的问题或请求，好的标题可以快速地让维护者了解Issue的主要内容。
第三步：详细描述问题：
官方人员在解决你所提出来的问题时，会首先复现你所出现的问题，因此在提交Issue时，一定要详细描述你所提交的问题复现步骤以及结果输出情况和日志，总的来说可以包括以下几个部分：
上下文：描述你在什么情况下遇到的问题。重现步骤：如果是bug报告，详细列出如何重现这个问题。期望结果与实际结果：说明你的期望是什么，以及实际发生了什么。相关信息：如操作系统、软件版本、依赖库版本等。附加信息：日志和错误消息：如果有相关的日志或错误消息，请附加或链接到它们。屏幕截图和视频：如果它们有助于解释问题，可以附加在后面。 最后就是要使用Markdown格式来组织你的描述，使其易于阅读。并始终保持礼貌和尊重，因为开源维护者是在免费为你提供帮助。
第四步：提交并等待回复
最后在详细描述完问题内容后就可以提交问题了，提交后就可以等待光放人员的回复，如光官方人员在复现时或者解决时有什么问题，也会向你进行反馈，因此可以时刻关注问题的动态。最后在问题解决后一定要礼貌感谢一下官方人员。
问题三：如何提PR？ 上面我们已经介绍了提交Issue，这对于刚入门的开发者来说是十分容易的，下面我们将介绍一下进阶内容，给开源项目提交PR。提交PR应该属于进阶版内容，因为他是从技术要求、编程能力以及对源码的掌握程度都会有很高的要求，所以这一块内容适合对项目十分熟悉的小伙伴。
但如果小伙伴们叨叨了这种程度或者是在使用中对项目源码做了修改使其变得更好，就可以开始向项目提交PR了，不过在提交前要先注意以下几点：
第一，确定一下该项目支不支持提交PR，此处主要是通过该项目厂库查看是否PR板块是否开放，以及在项目README中，作者是否表达了欢迎广大开发者对该项目进行改进的意愿。
第二，查看一下项目官方对提交PR的要求，这个要求一般会在项目厂库根目录下的CONTRIBUTING.md文件中，该文件中会规定了具体的提交PR的要求，包括提交PR的规范、代码风格以及编码格式要求和开源许可等内容。
在确定了以上问题后，就可以开始提交你的PR了，这里有两种方式可以提交PR，一种是在线直接提交，这种方式适合修改内容较少，不涉及源码修改等；第二种是本地修改后提交，这种方式适合有较大的改动，涉及到源码修改等。
方式一：在线直接提交 （1）选择要更新的文件
通过在 GitHub 中单击它来选择更新，以README.md文件为例：
（2）点击“编辑此文件”
该按钮位于右上角。
如果你没有Fork该项目，需要先Fork该项目。
（3）修改文件内容
此处增加两个🥰符号。
修改完文件内容后，点击Commit changes提交更改，并按照更改内容填写日志。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/417e8e3a51adc6566169d25bb1f2529b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ee73f2d61ee293b3b81b0bc6496b5c/" rel="bookmark">
			Rust 环境 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 Rust Linux 打开终端，输入以下命令
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh 如果安装成功，将出现
Rust is installed now. Great! 更新 $ rustup update 卸载 $ rustup self uninstall 检查是否安装成功 $ rustc -V 本地文档 $ rustup doc 使用浏览器打开本地文档。
可以在本地文档上查找标准库信息。
配置vscode Rust 插件 社区驱动的 rust-analyzer。
其他好用的插件 Even Better TOML , 支持 .toml 文件完整特性。Error Lens ，更好的获得错误展示。One Dark Pro ，VSCode 主题。CodeLLDB ，Debugger 程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c4a26a1cddc7e9755c1c4baac9fade8/" rel="bookmark">
			frp和openvpn对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FRP（Fast Reverse Proxy）和OpenVPN是两种不同的网络工具 FRP是一个轻量级的反向代理工具，用于将内部网络服务暴露给外部网络。OpenVPN是一种开源的虚拟专用网络（VPN）解决方案，用于建立安全的远程访问连接。 如果你只需要实现远程访问内部计算机或内部某个数据库的服务，FRP可能是一个简单且有效的解决方案。FRP提供了一种轻量级的反向代理机制，可以将内部网络服务暴露给外部网络，从而实现远程访问。
一般情况下frp就够用了。
相对于其他复杂的VPN解决方案，FRP的配置和使用较为简单。它不需要复杂的证书管理和身份验证设置，只需配置服务器和客户端的连接参数即可。FRP还支持TCP和UDP协议，并提供了安全认证和加密功能，保护数据传输的安全性。
以下是一个使用OpenVPN的常见场景 远程办公： 假设你有一个分布在不同地理位置的团队，需要远程办公并访问内部网络资源。你希望为团队成员提供一个安全的远程访问解决方案，以便他们可以安全地连接到内部网络并访问文件共享、内部应用程序或数据库。
在这种情况下，可以设置一个OpenVPN服务器在内部网络上，并在远程团队成员的设备上配置OpenVPN客户端。通过使用OpenVPN，远程团队成员可以建立加密的隧道连接，安全地连接到内部网络。他们可以通过该连接访问内部的文件共享、内部应用程序或数据库，就像他们直接在办公室内部网络中一样。
OpenVPN提供了强大的加密和身份验证功能，确保数据传输的安全性。它可以在多个操作系统和设备上运行，并具有灵活的配置选项，以适应不同的网络环境和需求。此外，OpenVPN还支持基于证书的身份验证和双因素身份验证，提供了额外的安全层级。
通过使用OpenVPN，你可以为远程团队成员提供一个安全、可靠的远程访问解决方案，使他们能够高效地远程办公，并访问内部网络资源，无论他们身处何处。
需要注意的是，OpenVPN的配置和管理可能会比较复杂，特别是涉及到证书颁发和身份验证的设置。因此，在部署OpenVPN之前，建议仔细阅读官方文档或寻求专业人士的帮助，以确保正确配置和安全操作。
OpenVPN可以用于实现远程桌面访问。 通过配置OpenVPN服务器和客户端，你可以建立一个安全的连接，使远程用户能够通过远程桌面协议（如RDP）访问和控制内部计算机。
具体实现远程桌面访问的步骤如下：
在内部网络上设置OpenVPN服务器，并进行相应的配置和安全设置。 在远程用户的设备上配置OpenVPN客户端，包括连接参数、证书等。
远程用户使用OpenVPN客户端连接到OpenVPN服务器，建立安全的连接。
一旦连接建立，远程用户可以使用远程桌面协议（如RDP）通过OpenVPN连接访问和控制内部计算机。
通过使用OpenVPN，远程桌面访问的数据传输将通过加密的隧道连接进行保护，确保数据的安全性和隐私性。OpenVPN还提供了身份验证和访问控制的功能，可以限制只有经过授权的用户才能访问远程桌面服务。为了实现远程桌面访问，除了OpenVPN的配置之外，还需要确保目标计算机已经启用了远程桌面服务，并进行了相应的设置。
我理解就是OpenVPN更强大，它包含了frp的功能。 FRP可以用于简单的内网穿透和端口转发，但VPN在实现远程访问和安全连接方面更加全面。下面是一些VPN相对于FRP的优势：
网络层连接： VPN在网络层上建立连接，可以将整个内部网络扩展到远程用户所在的网络中。这意味着远程用户可以像直接连接到内部网络一样访问所有内部资源，而不仅仅是某个端口或服务。
完整的内网访问： 通过VPN，远程用户可以访问内部网络中的所有服务、应用程序和资源，包括文件共享、打印机、数据库等。这比仅仅实现远程访问某个计算机或数据库的功能更加综合和灵活。
安全性和隐私性： VPN提供了更强大的加密和身份验证功能，确保数据传输的安全性。它可以通过使用加密隧道保护所有网络流量，包括远程桌面、文件传输等。此外，VPN还可以隐藏用户真实的IP地址，增加隐私性。
面向多用户和团队： VPN可以同时支持多个用户或团队的连接，每个用户都可以通过独立的身份验证访问内部网络。这对于组织中的多个用户或远程团队非常有用，可以提供一个集中管理和控制的访问解决方案。
虽然VPN功能更强大，但它可能需要更多的配置和管理工作，包括证书颁发、密钥管理、用户身份验证等。因此，在选择适合的解决方案时，需要根据具体需求和复杂性来权衡FRP和VPN的优劣，并选择最适合的工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e8970155aea9f673537f4d98171550e/" rel="bookmark">
			自定义html5中日期选取器的样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义html5中日期选取器的样式 1. 前言1.1 关于 h5 的新特性1.2 使用浏览器 2. html5中日期选取器默认样式3. 自定义日期样式3.1 简单定义3.2 花式样式定义 4. 改变日期格式5. 参考6. 关于低版本浏览器隐藏小三角 1. 前言 1.1 关于 h5 的新特性 可看下面的文章
HTML5 新特性之HTML5 的输入（input）类型（h5没有vue也能实现你想要的炫酷）.
H5新特性之h5的新标签 以及 全局属性contenteditable.
1.2 使用浏览器 说明：
下面都是在谷歌浏览器上测试的，其他浏览器可能不一样，自己测试看 2. html5中日期选取器默认样式 默认样式如下：&lt;input type="date" id="myDate"&gt; 3. 自定义日期样式 3.1 简单定义 简单修改日期样式的代码如下：&lt;style&gt; /* 设置 整个日期选择器 外边框的样式 + 年月日字体及日历选择器指示器的大小 */ input[type="date"] { border: 3px solid #c69d9d; border-radius: 10px; padding: 8px; font-size: 16px; } /* 自定义 日历选择器指示器 的样式 */ input[type="date"]::-webkit-calendar-picker-indicator { /* 设置立体感的边框 */ border: 1px solid #890404; background-color: #1d0909; border-radius: 5px; box-shadow: inset 0 1px #722222, 0 1px #732323; /* 设置边框里面的颜色 */ background-image: -webkit-linear-gradient(top, green, green); /* 设置 日历选择器指示器 的大小，如果这里不指定就取上面设置的16px */ font-size: 20px; } &lt;/style&gt; &lt;label for="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e8970155aea9f673537f4d98171550e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3848baffde083e1c1ab3417d1d61a194/" rel="bookmark">
			《BUG随手记》安卓应用顶部状态栏与标题使用应用的背景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、 标题
要在主题中修改，修改位置在：res/values/themes.xml中，
把style改成如下：
&lt;style name="Theme.SleepMonitor" parent="Theme.MaterialComponents.DayNight.NoActionBar"&gt; 2、状态栏
状态SDK版本大于等于21的，直接在对应的Activity的onCreate()方法中加上
if (Build.VERSION.SDK_INT &gt;= 21){ View decorView = getWindow().getDecorView(); decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); getWindow().setStatusBarColor(Color.TRANSPARENT); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a95f1875a36c57fb1ead57ea5c8a2c4a/" rel="bookmark">
			认识数据的规范化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关系模型满足的确定约束条件称为范式，根据满足约束条件的级别不同，范式由低到高分为 1NF（第一范式）、2NF（第二范式）、3NF（第三范式）、BCNF（BC 范式）、4NF（第四范式）等。不同的级别范式性质不同。
把一个低一级的关系模型分解为高一级关系模型的过程，称为关系模型的规范化。关系模型分解必须遵守两个准则。
（1）无损连接性：信息不失真（不增减信息）。
（2）函数依赖保持性：不破坏属性间存在的依赖关系。
规范化的基本思想是逐步消除不合适的函数依赖，使数据库中的各个关系模型达到某种程度的分离。规范化解决的主要是单个实体的质量问题，是对于问题域中原始数据展现的正规化处理。
规范化理论给出了判断关系模型优劣的理论标准，帮助预测模式可能出现的问题，是数据库逻辑设计的指南和工具，具体有：
（1）用数据依赖的概念分析和表示各数据项之间的关系。
（2）消除 E-R 图中的冗余联系。
1．函数依赖
通俗地说，就像自变量 x 确定之后，相应的函数值 f(x)也就唯一确定了一样，函数依赖是衡量和调整数据规范化的最基础的理论依据。
例如，记录职工信息的结构如下：
职工工号（EMP_NO）
职工姓名（EMP_NMAE）
所在部门（DEPT）。
则说 EMP_NO 函数决定 EMP_NMAE 和 DEPT，或者说 EMP_NMAE，DEPT 函数依赖于 EMP_NO，记为：EMP_NO→EMP_NMAE，EMP_NO→DEPT。
关系 R&lt;U，F&gt;中的一个属性或一组属性 K，如果给定一个 K 则唯一决定 U 中的一个元组，也就是 U 函数完全依赖于 K，就称 K 为 R 的码。一个关系可能有多个码，选中其中一个作为主码。
包含在任一码中的属性称为主属性，不包含在任何码中的属性称为非主属性。
关系 R 中的属性或属性组 X 不是 R 的码，但 X 是另一个关系模型的码，称 X 是 R 的外码。
主码和外码是一种表示关系间关联的重要手段。数据库设计中一个重要的任务就是要找到问题域中正确的关联关系，孤立的关系模型很难描述清楚业务逻辑。
2．第一范式
1NF 是最低的规范化要求。如果关系 R 中所有属性的值域都是简单域，其元素（即属性）不可再分，是属性项而不是属性组，那么关系模型 R 是第一范式的，记作RÎ1NF。这一限制是关系的基本性质，所以任何关系都必须满足第一范式。第一范式是在实际数据库设计中必须先达到的，通常称为数据元素的结构化。
例如，表3-8所示的结构就不满足1NF的定义。
表3-8 为非第一范式，分解如表3-9 所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a95f1875a36c57fb1ead57ea5c8a2c4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72182e4ae9793ddc24354244310fb8a6/" rel="bookmark">
			TCP和UDP详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、UDP 协议1.1 报文格式1.2 协议特点1.3 扩展问题 二、TCP 协议2.1 报文格式2.2 可靠性机制2.2.1 确认应答机制2.2.2 超时重传机制2.2.3 连接管理机制2.2.4 流量控制2.2.5 拥塞控制2.2.6 滑动窗口 2.3 粘包问题 三、TCP 和 UDP 的区别 提示：以下是本篇文章正文内容，Java系列学习将会持续更新 一、UDP 协议 UDP全称为用户数据报协议。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。
1.1 报文格式 1.2 协议特点 无连接：只知道对端的IP和端口号就可以发送，不需要实现建立连接。(就像寄信)。不可靠：没有确认机制， 没有重传机制。如果因为网络故障该段无法发到对方， UDP协议层也不会给应用层返回任何错误信息。面向数据报： 应用层交给UDP多长的报文， UDP原样发送既不会拆分，也不会合并。所以UDP不能够灵活的控制读写数据的次数和数量。UDP存在接收缓冲区，但不存在发送缓冲区。UDP没有发送缓冲区，在调用send to时会直接将数据交给内核，由内核将数据传给网络层协议进行后续的传输动作。UDP具有接收缓冲区，但是这个接收缓冲区不能保证收到的UDP报文的顺序和发送UDP报的顺序一致，如果缓冲区满了再到达的UDP数据报就会被丢弃。 为什么UDP不需要发送缓冲区？ 因为UDP不保证可靠性，它没有重传机制，当报文丢失时，UDP不需要重新发送，而TCP不同，他必须具备发送缓冲区，当报文丢失时，TCP必须保证重新发送，用户不会管，所以必须要具备发送缓冲区。
大小受限。UDP协议首部中有一个16位的最大长度。也就是说一个UDP能传输的数据最大长度是64K（包含UDP首部）。 1.3 扩展问题 UDP本身是无连接，不可靠，面向数据报的协议，如果要基于传输层UDP协议，来实现一个可靠传输，应该如何设计？UDP大小是受限的，如果要基于传输层UDP协议，传输超过64K的数据，应该如何设计？ 以上两个问题，我们可以学习TCP的可靠性机制啊：
例如：
① 引入序列号，保证数据顺序；
② 引入确认应答，确保对端收到了数据；
③ 引入超时重传，如果隔一段时间没有应答，就重发数据；
④ ……
回到目录…
二、TCP 协议 TCP全称传输控制协议，必须对数据的传输进行控制。
2.1 报文格式 源端口号/目的端口号：表示数据从哪个进程来，要到那个进程去
32位序号：序号是可靠传输的关键因素。TCP将要传输的每个字节都进行了编号，序号是本报文段发送的数据组的第一个字节的编号，序号可以保证传输信息的有效性。比如：一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为401。
32位确认序号：每一个ACK对应这一个确认号，它指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。
4位首部长度(数据偏移)： 表示该TCP头部有多少个32位bit(有多少个4字节)，所以TCP头部大长度是15 * 4 = 60。根据该部分可以将TCP报头和有效载荷分离。TCP报文默认大小为20个字节。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72182e4ae9793ddc24354244310fb8a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a29721858be01d9fb580a296b9cad31/" rel="bookmark">
			京东也将全面支持仅退款
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注卢松松，会经常给你分享一些我的经验和观点。
京东终于醒了。前几天，淘宝修改了“仅退款”规则，不出2天，京东也紧随其后，宣布支持“仅退款”。
京东近日发布公告，自2023年12月29日起，用户在京东平台上申请退换货时将新增一项“仅退款”服务。其实这个服务在2014年就有了，而这次是是针对京东所有商家了。所以本文用了“全面”这个词。
另外松松再说一句：京东的仅退款是有严格要求的，这项政策提出了退款不退货的策略，但不是真的不退货，而是发出退款申请后先退款，再退货的服务，自此，国内3大网购平台拼多多、淘宝、京东先后都支持了仅退款服务。
曾经的京东、淘宝电商巨头，现在都开始学习拼多多，还有这个仅退款，对消费者来说算是好事情，对商家来说可就是灾难了。从另一个角度来来说，电商平台的竞争日益激烈，售后服务是电商能否留住客源的关键所在。
当仅退款成为一个平台的大杀器，意味着客户的素质进一步被拉低，不要问为什么这么说，作为商家，我们深知是平台教坏了买家，因为越来越多的人找毛病仅退款，把占便宜发挥的淋漓尽致。
淘宝、京东加入“仅退款”队伍，谁受益?从朋友圈商家的反应来看，商家肯定是怨声载道的，用户的服务又是商家对接的，那么商家会提供好的服务吗?
卢松松是一位自媒体人、短视频博主。也是创业者必看的账号，关注草根创业圈、科技互联网、自媒体和短视频行业。感谢您的关注！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3dbc884b0f3df3afe3e42c631e83b12/" rel="bookmark">
			2023海内外零知识证明学习资料汇总（二）（深入理解零知识证明篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工欲善其事,必先利其器 Web3开发中，各种工具、教程、社区、语言框架.。。。
种类繁多，是否有一个包罗万象的工具专注与Web3开发和相关资讯能毕其功于一役？
参见另一篇博文👉 2024最全面且有知识深度的web3开发工具、web3学习项目资源平台
本文收集了关于零知识证明的一些学习资料（包括科普文章，论文，开源仓库及相关学习网站等），并对这些资源进行了整理分析，希望能对大家有所帮助。
书接上篇，
器欲尽其能,必先得其法 零知识证明技术涉及的知识点繁多，性质也各不相同。了解了什么是零知识证明以后，就需要对零知识证明更深刻的理解，推荐以下几篇零知识证明系列科普文。
「推荐文章六」零知识证明: 抛砖引玉 推荐值：❤️❤️❤️❤️ 难度值：⭐️⭐️⭐️ 作者是 Zerocash
协议的创建者之一，密码学大神 Matthew Green[1]。这两篇文章几乎涵盖了学习零知识证明原理所有的基本概念，文章思路很清晰。
零知识证明: 抛砖引玉 第一篇文章主要从零知识证明的起源开始讲起，然后同样借助了地图三染色和 “时光机”来对零知识证明进行介绍。
原文：Zero Knowledge Proofs: An illustrated primer 零知识证明：抛砖引玉，Part-2
这篇文章在第一篇的基础上，进一步对零知识证明的三个性质：可靠性，完整性和零知识，展开介绍。另外还结合 Schnorr
协议介绍了交互式和非交互式的概念。「推荐文章七」安比实验室零知识证明介绍系列文章 推荐值：❤️❤️❤️❤️❤️ 难度值：⭐️⭐️⭐️
这个系列的作者是安比实验室创始人郭宇，文章与以往的零知识证明科普文章的不同之处就是它没有单独去讲解零知识的基本原理。而且结合更多的概念和原理，更透彻得将零知识证明技术涉及得诸多原理逐一进行讲解，文章专业性较强，还包含了作者大量的思考，但理解起来也较为直观易懂，非常适合想要深入理解零知识证明的小伙伴。
另外这个系列的文章还在持续更新中。 探索零知识证明系列一：初识「零知识」与「证明」
作为系列的第一篇，这篇文章首先介绍了「证明」的发展历程和「零知识」的作用，并举了一个地图三染色的例子，然后又对「信息」、「知识」和可满足电路的概念展开了介绍。
探索零知识证明系列二：从「模拟」理解零知识证明：平行宇宙与时光倒流
这篇文章介绍了零知识证明中的一个非常重要的概念——模拟（Simulator），「模拟」可以说是安全协议中核心的核心。文章中借助
“平行世界” 的假设去理解零知识读起来也非常有意思。 探索零知识证明系列三：读心术：从零知识证明中提取「知识」
零知识证明有三个重要的性质：可靠性，完整性和零知识。这篇文章探讨了可靠性。文章解释了如何借助「抽取器」和时间倒流的超能力把 Alice
的「知识」完整地「抽取」出来，并可给出了一个与之相关攻击实例 —— ECDSA 签名攻击。
探索零知识证明系列四：亚瑟王的「随机」挑战：从交互到非交互式零知识证明
这篇文章主要在讲零知识证明的信任根基——随机挑战。文章对零知识证明协议在两种不同的形式（交互式和非交互式）下随机挑战的方式进行了介绍。另外文章还对交互和非交互形式展开了介绍。
探索零知识证明系列五:云中「秘密」：构建非交互式零知识证明「推荐文章八」零知识证明：一个略微严肃的科普 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️⭐️
邓老师这篇“略微严肃”的科普，主要涉及两部分：1. 交互式证明的巨大威力；2. 零知识证明的定义和那些广泛流传的错误的例子「推荐文章九」Zero-Knowledge Proofs: A Layman’s Introduction 推荐值：❤️❤️
难度值：⭐️⭐️ 这篇文章首先介绍了零知识证明协议中的三个参与者（Creator，Prover，Verifier）以及 Proofs 和
Verification的概念，并对 zkSNARK （一类零知识证明协议）和椭圆曲线的相关资料进行了介绍。「推荐文章十」白话零知识证明（一） 推荐值：❤️❤️ 难度值：⭐️⭐️
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3dbc884b0f3df3afe3e42c631e83b12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/533a9021aa127a8430e50aaca32bf5b4/" rel="bookmark">
			php配置踩坑：number整数（json_decode）精度丢失的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改php.ini中，precision配置的值：
比如，从默认的14改到16。
https://www.php.net/manual/zh/ini.core.php#ini.precision
; The number of significant digits displayed in floating point numbers. ; http://php.net/precision precision=16 踩坑 如果precision默认值为14，那么php从数据库查出比较大的整数值，比如15位的整数250000000000006，在json_decode为对象之后，可能会得到2.5008000008001e+14这样的值，即250080000080010。
其他容易踩坑的配置 限制文件上传大小的配置：
https://www.php.net/manual/zh/ini.core.php#ini.upload-max-filesize
upload_max_filesize=2M upload_max_filesize默认配置是2M，现在肯定不够用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98d224ad5b3eb6ea6fbfeaf6f0a5054e/" rel="bookmark">
			基于梯度和频率域的深度超分辨率新方法笔记二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实现方法和网络结构的剖析 1.1 网络结构 梯度校准模块(GCM)和频率感知模块（FAM）
1）梯度校准模块(GCM) 1、使用梯度映射函数（如下图所示），将RGB和LR深度图映射到梯度域
2、再梯度域中使用RGB的梯度特性对LR的梯度特征进行校准和锐化。这个过程是基于深度学习的，主要使用梯度感知损失进行有监督的学习。
3、将校准后的梯度特征和深度特征融合得到梯度增强后的特征，然后将梯度增强后的特征送入到频域感知模块。
2）频率感知模块（FAM） FAM如图3绿色区域所示，其递归的执行多个频谱差分模块来不断地在频域中优化深度特征。然后将不同阶段获取到的深度特征通过残差模块和上采样模块进行融合得到 ，最后结合由bicubic插值上采样后的深度图 ， 得到最终预测的HR深度图 。
执行流程为：
1、递归的执行多个频谱差分模块来不断地在频域中优化深度特征
2、将不同阶段获取到的深度特征通过残差模块和上采样模块进行融合得到 Dfe.
3、最后结合由bicubic插值上采样后的深度图 Dbi， 得到最终预测的HR深度图 。
频谱差分模块:
由此可以得出：在频域中，是通过卷积层对幅值和相位的学习
频谱的相位和幅值的求解方法：
快速傅里叶变换（FFT）是信号处理的重要组成部分，用于求信号的幅度、相位以及画频谱图等。
function [x,freq] = fft_plot(x,Fs) %计算信号的双边幅度频谱和其横坐标、并调整使得横坐标中心频率为0Hz,输入：x为输入信号，Fs为采样频率，输出：x为输入信号的幅度频谱，freq为输入信号幅度频谱的横坐标 N = length(x); %%计算频谱的横坐标，使得中心频率为0Hz if mod(N,2)==0 k = -N/2:N/2-1; else k = -(N-1)/2:(N-1)/2; end T = N/Fs; freq = k/T; x= fft(x)/N;%fft并归一化 x= fftshift(x); 主程序： [x1,freq] = fft_plot(x,Fs); figure; plot(freq,abs(x1)); xlabel('频率（Hz）'); ylabel('幅度'); title('信号频谱图'); 信号的频域表示携带每个频率下信号幅值和相位的有关信息。因此，FFT 计算的输出是复数。复
有实部 和虚部 ，满足 的幅值计算为 的相位计算为 3）损失函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98d224ad5b3eb6ea6fbfeaf6f0a5054e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d30b449148aa14f6ec15f72233d3c6a/" rel="bookmark">
			Vue模板编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue模板编译 Vue生命周期中，在初始化阶段各项工作做完之后调用了vm.$mount方法，该方法的调用标志着初始化阶段的结束和进入下一个阶段，从官方文档给出的生命周期流程图中可以看到，下一个阶段就进入了模板编译阶段(created和beforeMounted之间的阶段)，该阶段所做的主要工作是获取到用户传入的模板内容并将其编译成渲染函数生成模板字符串。然后将这些模板字符串转换成内存中的DOM。
一、Vue 编译原理这块的整体逻辑主要分三个部分： 1.将模板字符串转换成element AST(抽象语法树）（解析器parser）
2.对AST进行静态节点标记，主要用来做虚拟dom的渲染优化（优化器optimizer）
3.使用element AST 生成render函数代码字符串（代码生成器code generator ）
伪代码
// main.js文件 new Vue({ el: '#app', templete: `&lt;div&gt;hello world&lt;/div&gt;`, //可选 render: h =&gt; h(App), //渲染函数 }).$mount('#app') //挂载函数 Vue.prototype.__init = function (options) { const vm = this; vm.$options = options; initState(vm); if (vm.$options.el) { //$mount 挂载函数 vm.$mount(vm.$options.el) } } Vue.prototype.$mount = function (el) { const vm = this, options = vm.$options; el = document.querySelector(el); vm.$el = el; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d30b449148aa14f6ec15f72233d3c6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6d01c974f4cd884b05c83d011cd6ec/" rel="bookmark">
			特征归一化及其原理--机器学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		归一化是数据预处理中的一种常见操作，其目的是将不同特征的数值范围统一或缩放到相似的尺度。这有助于提高模型的性能，加速模型的收敛，并使模型更加稳健。以下是进行归一化的一些原因和原理：
消除特征间的尺度差异：
不同特征可能具有不同的数值范围，例如身高和体重。在一些机器学习算法中，如果特征的尺度差异较大，可能导致某些特征对模型的贡献比其他特征更大，从而影响模型的性能。通过归一化，可以使所有特征具有相似的尺度，避免尺度差异带来的问题。
加速模型收敛：
在一些迭代优化算法中，如梯度下降，特征的尺度差异可能导致收敛速度变慢。归一化可以加速收敛过程，使优化算法更快地找到最优解。
提高模型的稳健性：
归一化可以提高模型对输入数据的稳健性。如果某个特征的数值范围变化较大，模型可能更容易受到噪声或异常值的影响。通过归一化，模型对于输入数据中的变化更为鲁棒。
改善模型的可解释性：
归一化可以使模型的系数更容易解释。在某些线性模型中，系数的大小可以反映特征对输出的贡献程度。如果特征具有不同的尺度，解释模型系数就会变得更加困难。
常见的归一化方法包括：
线性函数归一化 Min-Max Scaling：它对原始数据进行线性变换，使结果映射到[0, 1]的范围，实现对原始数据的等比缩放。
X normalized = X − X min X max − X min X_{\text{normalized}} = \frac{X - X_{\text{min}}}{X_{\text{max}} - X_{\text{min}}} Xnormalized​=Xmax​−Xmin​X−Xmin​​
将数据缩放到[0, 1]的范围内。
零均值归一化 Z-Score Normalization（标准化）：它会将原始数据映射到均值为 0、标准差为1的分布上。
X normalized = X − μ σ X_{\text{normalized}} = \frac{X - \mu}{\sigma} Xnormalized​=σX−μ​
将数据转换为均值为0，标准差为1的正态分布。
Robust Scaling：
X normalized = X − Q1 Q3 − Q1 X_{\text{normalized}} = \frac{X - \text{Q1}}{\text{Q3} - \text{Q1}} Xnormalized​=Q3−Q1X−Q1​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a6d01c974f4cd884b05c83d011cd6ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6bcf66217b5ef47014835b428c89dd8/" rel="bookmark">
			清华大学刘永进教授课题组提出基于便携式家用级别脑电设备的情绪识别新方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		清华大学刘永进教授课题组提出一种从昂贵实验室级别的脑电设备数据进行迁移学习、提高便携式家用级别脑电设备的情绪识别能力的方法，该项研究于2023年被IEEE Transactions on Affective Computing期刊录用，论文的共同第一作者为刘永进教授指导的博士后刘舫和博士生杨培，刘永进教授指导的博士生舒叶芷、硕士生刘妮琦、盛芊芊共同参与了讨论和论文撰写，脑陆科技公司提供了研究所需的部分数据。IEEE Transactions on Affective Computing是国际上情感计算领域内的著名期刊，SCI影响因子为11.2。
全文官方链接：https://doi.org/10.1109/TAFFC.2023.3336531
脑电信号已被广泛研究用于人类情绪识别。现有的脑电情绪识别算法大多利用几十个或上百个电极来覆盖整个头皮区域(在本文中称为全通道脑电设备)。如今，越来越多便携和微型的脑电设备只有少数几个电极(在本文中称为少通道脑电设备)。然而，从少通道脑电数据进行情绪识别具有挑战性，因为较少的电极只能捕获来自大脑某个区域的脑电信号。此外，现有的全通道算法无法直接适应少通道脑电信号，因为全通道和少通道脑电设备之间存在重大变异。为了解决这些挑战，本文从迁移学习的角度提出了一种新的少通道脑电情绪识别框架。
全通道脑电信号通过基于迁移学习的模型（CD-EmotionNet）提供少通道信号的补充信息，该模型由高效情绪特征提取的基础情绪模型和跨设备迁移学习策略组成。该策略通过利用从全通道脑电数据学到的知识来提高从少通道脑电数据进行情绪识别的性能。为评估本文的跨设备脑电情绪迁移学习框架，构建了一个包含25位被试的18通道和5通道脑电信号的情绪数据集，以及其他13位被试的5通道脑电信号来评估CD-EmotionNet方法。大量的实验表明，本文的方法大幅超过目前已有的脑电情绪识别方法。
图 1. (a) 少通道脑电设备 (5个电极) 的电极分布（红色）；(b) 全通道脑电设备(18个电极) 的电极分布（红色和蓝色）。上面：根据国际10/20系统中的电极分布；下面：同一个用户的“恶心”情绪状态的能量图。
大多数现有基于脑电的情绪识别算法利用几十个或上百个电极来覆盖整个头皮区域，然而，这些设备通常不便携、昂贵，主要适用于实验室实验场景，这限制了现有工作扩展到更普遍的日常应用。目前已出现了一些只有几个电极的、便携的、微型的EEG设备，一些使用较少数量的电极的EEG信号进行情绪识别的研究也开始出现。尽管这些少通道EEG设备为各种应用带来便利，但它们也使得基于EEG的情绪识别更具挑战性。相比于全通道脑电设备，少通道脑电设备能够捕获的脑电信号较少。几乎所有少通道EEG设备仅提供覆盖大脑部分区域的电极。然而，已有研究表明，情绪不是单一大脑区域的功能，而是存在于整个大脑网络的激活或连接模式中，这意味着仅使用大脑的一部分EEG信号比使用全部EEG信号进行情绪识别更加困难。
从整个大脑皮层提取特征的全通道脑电识别方法不能直接应用于少通道信号的脑电情绪识别。究其原因，一方面，从少通道的脑电数据中提取有效的情绪模式更具挑战性；另一方面，这少通道和全通道脑电设备之间的差异很大。为应对上述挑战，本文从知识迁移的角度利用少通道脑电信号进行情绪识别任务，提出利用从全通道脑电数据中学习到的知识来提高从少通道脑电数据进行情绪识别的性能。
图 2. 基础情绪模型（base emotion model）框架。本文的基础情绪模型主要由图卷积模块、深度特征聚合和融合模块以及分类器组成。
本文将全通道辅助少通道脑电情绪识别任务形式化为迁移学习问题，并提出了一种新的基于特征聚合的跨设备脑电特征学习网络用于情绪识别，称为CD-EmotionNet。CD-EmotionNet由两部分组成：（1）一个基础情绪模型（base emotion model），用于提取空间-频谱-时域脑电特征并进行情绪分类；（2）一种跨设备迁移学习策略。基础情绪模型首先在全通道脑电数据集上训练；然后将学习到的情绪特征和模型参数迁移到少通道脑电情绪识别场景，以帮助提高从少通道脑电数据进行情绪识别的性能。
基础情绪模型的目的是通过特征聚类过程将局部特征描述符转换为紧凑的全局特征。考虑到情绪脑电信息具有整个大脑激活模式，鉴于图模型具有捕捉空间关系的优势，通过结合图卷积神经网络和深度特征聚合网络构建基础情绪模型，以提取情绪分类的有效空间-时域脑电特征。通过以学习方式聚集和聚合空间-频谱脑电特征，本文的方法可以捕捉脑电数据中的有效情绪相关时域模式。
图 3. 脑电情绪迁移学习框架包括两个阶段：（1）元模型训练阶段，旨在学习一个良好的模型初始化参数；（2）在模型微调和测试阶段，只需要少量的少通道脑电信号即可完成模型在新被试上的适应。
为进一步解决由于缺乏全通道脑电信息造成的信息稀疏的问题，将基础情绪模型与迁移学习策略结合起来，充分利用全通道脑电的信息来辅助少通道脑电情绪识别。本文提出的跨设备脑电情绪迁移学习方法构建在模型无关的元学习(MAML)框架上。MAML旨在进行模型的参数初始化学习，使得模型易于微调而应用于新的数据集。MAML的核心思想是在各种学习任务(元模型训练阶段)上训练模型，以便它可以使用另一个领域的少数几个样例进行新任务适应(元模型测试阶段)。本文通过提出新的基于MAML的网络更新机制，实现不同设备的脑电特征聚合网络的学习：在元模型训练阶段利用全通道和少通道成对的脑电信号来训练网络，而在模型微调和测试阶段仅使用少通道脑电信号。
为评估本文的方法，构建了一个跨设备脑电数据集CDEED，该数据集包含:(1)来自25名被试的成对的全通道（18通道）和少通道（5通道）的脑电数据，每组成对的数据包含使用相同视频刺激和实验方案采集的18通道和5通道EEG信号，(2)另外13名被试(不同于上述25名被试)的少通道（5通道）EEG信号。实验结果表明，CD-EmotionNet模型能够有效地提高少通道脑电信号的情绪识别性能，并在CDEED数据集以及另外三个公开数据集SEED-IV，SEED-V和DEAP上达到最先进的性能。
本文的基于迁移学习的少通道脑电情绪识别的主要贡献包括：
（1）从迁移学习的角度解决具有挑战性的少通道脑电情绪识别任务。通过设计一个基于迁移学习的模型（CD-EmotionNet），利用全通道脑电信号为少通道信号提供脑电情绪特征的补充信息，该模型包括一个用于高效情绪特征提取的基础情绪模型和一个跨设备迁移学习策略，通过从全通道脑电数据中提取的知识，提高少通道脑电数据的情绪识别性能。
（2）构建了一个成对的全通道和少通道脑电信号数据集，其中包含使用不同脑电设备的、相同被试的使用相同的一组刺激和实验范式收集的全通道和少通道脑电数据，来验证跨设备脑电情绪识别模型的性能。此外，在其他三个公共数据集（SEED-IV、SEED-V 和 DEAP）上进行的实验也表明CD-EmotionNet可以实现少通道脑电情绪识别最先进的算法性能。
图 4. 数据采集实验流程图。每次试验的流程包括：(1) 播放电影片段。(2) 自我评估。(3) 加法和减法操作，以及 15 秒的休息，以消除前一个试次对当前试次的影响。
图 5. KangII数据集的8类情绪分类混淆矩阵。图中展示了使用和不使用本文的迁移学习策略的结果。除了“恐惧”情绪外，在应用迁移学习训练过程后，其他所有情绪的识别准确率都有所提高，表明迁移学习策略的有效性。
参考内容
Fang Liu, Pei Yang, Yezhi Shu, Niqi Liu, Jenny Sheng, Junwen Luo, Xiaoan Wang, Yong-Jin Liu. Emotion Recognition from Few-Channel EEG Signals by Integrating Deep Feature Aggregation and Transfer Learning.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6bcf66217b5ef47014835b428c89dd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8413d5cb7f217e35f55ddcf2d12851f/" rel="bookmark">
			Qt/C&#43;&#43;音视频开发62-电子放大/按下选择区域放大显示/任意选取区域放大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 电子放大这个功能思考了很久，也是一直拖到近期才静下心来完整这个小功能，这个功能的前提，主要得益于之前把滤镜打通了，玩出花样来了，只要传入对应的滤镜字符串，就可以实现各种各样的效果，然后查阅滤镜手册过程中，发现有个裁剪crop的滤镜，和要做的电子放大效果完全一样，就是将指定的某个区域放大显示，这不就是电子放大吗？加上之前就解决了如何通过用户鼠标按下的点转换成视频真实的坐标，两者一个结合，这不就是水到渠成的事情？所以很多时候就是这样搞着搞着，问题自然而然就解决了。
大致步骤如下：
第一步: 鼠标按下开始记住坐标第二步: 鼠标移动绘制选取区域第三步: 鼠标松开发送裁剪滤镜 其实电子放大除了可以通过滤镜来实现，也可以直接opengl这边处理，无奈自己opengl水平还没入门，根本不知道怎么搞，所以才想着直接源头就滤镜处理好。通过对比各个厂家做的电子放大功能，发现海康的实现更加鸡贼，完全没有用滤镜，也没有用opengl绘制局部数据，而是直接将整个视频放大，放大到当前画面区域几乎就是刚才选取的区域，把整个视频面板放大到合适，然后放在一个拖动或者滚动区域中，相当于看图软件中的很大分辨率的图片，然后再通过手按下还可以一点点的移动视频画面，其实就是一个控件在move，这种方式很取巧，而且还能用手按着拖动进行调整查看画面，也是蛮好的一种思路，唯一要做的就是计算好用户选取的区域和将要放大的尺寸。
二、效果图 三、体验地址 国内站点：https://gitee.com/feiyangqingyun国际站点：https://github.com/feiyangqingyun个人作品：https://blog.csdn.net/feiyangqingyun/article/details/97565652体验地址：https://pan.baidu.com/s/1d7TH_GEYl5nOecuNlWJJ7g 提取码：01jf 文件名：bin_video_demo。视频主页：https://space.bilibili.com/687803542 四、功能特点 4.1. 基础功能 支持各种音频视频文件格式，比如mp3、wav、mp4、asf、rm、rmvb、mkv等。支持本地摄像头设备和本地桌面采集，支持多设备和多屏幕。支持各种视频流格式，比如rtp、rtsp、rtmp、http、udp等。本地音视频文件和网络音视频文件，自动识别文件长度、播放进度、音量大小、静音状态等。文件可以指定播放位置、调节音量大小、设置静音状态等。支持倍速播放文件，可选0.5倍、1.0倍、2.5倍、5.0倍等速度，相当于慢放和快放。支持开始播放、停止播放、暂停播放、继续播放。支持抓拍截图，可指定文件路径，可选抓拍完成是否自动显示预览。支持录像存储，手动开始录像、停止录像，部分内核支持暂停录像后继续录像，跳过不需要录像的部分。支持无感知切换循环播放、自动重连等机制。提供播放成功、播放完成、收到解码图片、收到抓拍图片、视频尺寸变化、录像状态变化等信号。多线程处理，一个解码一个线程，不卡主界面。 4.2. 特色功能 同时支持多种解码内核，包括qmedia内核（Qt4/Qt5/Qt6）、ffmpeg内核（ffmpeg2/ffmpeg3/ffmpeg4/ffmpeg5/ffmpeg6）、vlc内核（vlc2/vlc3）、mpv内核（mpv1/mp2）、mdk内核、海康sdk、easyplayer内核等。非常完善的多重基类设计，新增一种解码内核只需要实现极少的代码量，就可以应用整套机制，极易拓展。同时支持多种画面显示策略，自动调整（原始分辨率小于显示控件尺寸则按照原始分辨率大小显示，否则等比缩放）、等比缩放（永远等比缩放）、拉伸填充（永远拉伸填充）。所有内核和所有视频显示模式下都支持三种画面显示策略。同时支持多种视频显示模式，句柄模式（传入控件句柄交给对方绘制控制）、绘制模式（回调拿到数据后转成QImage用QPainter绘制）、GPU模式（回调拿到数据后转成yuv用QOpenglWidget绘制）。支持多种硬件加速类型，ffmpeg可选dxva2、d3d11va等，vlc可选any、dxva2、d3d11va，mpv可选auto、dxva2、d3d11va，mdk可选dxva2、d3d11va、cuda、mft等。不同的系统环境有不同的类型选择，比如linux系统有vaapi、vdpau，macos系统有videotoolbox。解码线程和显示窗体分离，可指定任意解码内核挂载到任意显示窗体，动态切换。支持共享解码线程，默认开启并且自动处理，当识别到相同的视频地址，共享一个解码线程，在网络视频环境中可以大大节约网络流量以及对方设备的推流压力。国内顶尖视频厂商均采用此策略。这样只要拉一路视频流就可以共享到几十个几百个通道展示。自动识别视频旋转角度并绘制，比如手机上拍摄的视频一般是旋转了90度的，播放的时候要自动旋转处理，不然默认是倒着的。自动识别视频流播放过程中分辨率的变化，在视频控件上自动调整尺寸。比如摄像机可以在使用过程中动态配置分辨率，当分辨率改动后对应视频控件也要做出同步反应。音视频文件无感知自动切换循环播放，不会出现切换期间黑屏等肉眼可见的切换痕迹。视频控件同时支持任意解码内核、任意画面显示策略、任意视频显示模式。视频控件悬浮条同时支持句柄、绘制、GPU三种模式，非绝对坐标移来移去。本地摄像头设备支持指定设备名称、分辨率、帧率进行播放。本地桌面采集支持设定采集区域、偏移值、指定桌面索引、帧率、多个桌面同时采集等。还支持指定窗口标题采集固定窗口。录像文件同时支持打开的视频文件、本地摄像头、本地桌面、网络视频流等。瞬间响应打开和关闭，无论是打开不存在的视频或者网络流，探测设备是否存在，读取中的超时等待，收到关闭指令立即中断之前的操作并响应。支持打开各种图片文件，支持本地音视频文件拖曳播放。视频流通信方式可选tcp/udp，有些设备可能只提供了某一种协议通信比如tcp，需要指定该种协议方式打开。可设置连接超时时间（视频流探测用的超时时间）、读取超时时间（采集过程中的超时时间）。支持逐帧播放，提供上一帧/下一帧函数接口，可以逐帧查阅采集到的图像。音频文件自动提取专辑信息比如标题、艺术家、专辑、专辑封面，自动显示专辑封面。视频响应极低延迟0.2s左右，极速响应打开视频流0.5s左右，专门做了优化处理。支持H264/H265编码（现在越来越多的监控摄像头是H265视频流格式）生成视频文件，内部自动识别切换编码格式。支持用户信息中包含特殊字符（比如用户信息中包含+#@等字符）的视频流播放，内置解析转义处理。支持滤镜，各种水印及图形效果，支持多个水印和图像，可以将OSD标签信息和各种图形信息写入到MP4文件。支持视频流中的各种音频格式，AAC、PCM、G.726、G.711A、G.711Mu、G.711ulaw、G.711alaw、MP2L2等都支持，推荐选择AAC兼容性跨平台性最好。内核ffmpeg采用纯qt+ffmpeg解码，非sdl等第三方绘制播放依赖，gpu绘制采用qopenglwidget，音频播放采用qaudiooutput。内核ffmpeg和内核mdk支持安卓，其中mdk支持安卓硬解码，性能非常凶残。可以切换音视频轨道，也就是节目通道，可能ts文件带了多个音视频节目流，可以分别设置要播放哪一个，可以播放前设置好和播放过程中动态设置。可以设置视频旋转角度，可以播放前设置好和播放过程中动态改变。视频控件悬浮条自带开始和停止录像切换、声音静音切换、抓拍截图、关闭视频等功能。音频组件支持声音波形值数据解析，可以根据该值绘制波形曲线和柱状声音条，默认提供了声音振幅信号。标签和图形信息支持三种绘制方式，绘制到遮罩层、绘制到图片、源头绘制（对应信息可以存储到文件）。通过传入一个url地址，该地址可以带上通信协议、分辨率、帧率等信息，无需其他设置。保存视频到文件支持三种策略，自动处理、仅限文件、全部转码，转码策略支持自动识别、转264、转265，编码保存支持指定分辨率缩放或者等比例缩放。比如对保存文件体积有要求可以指定缩放后再存储。支持加密保存文件和解密播放文件，可以指定秘钥文本。提供的监控布局类支持64通道同时显示，还支持各种异型布局，比如13通道，手机上6行2列布局。各种布局可以自由定义。支持电子放大，在悬浮条切换到电子放大模式，在画面上选择需要放大的区域，选取完毕后自动放大，再次切换放大模式可以复位。各组件中极其详细的打印信息提示，尤其是报错信息提示，封装的统一打印格式。针对现场复杂的设备环境测试极其方便有用，相当于精确定位到具体哪个通道哪个步骤出错。同时提供了简单示例、视频播放器、多画面视频监控、监控回放、逐帧播放、多屏渲染等单独窗体示例，专门演示对应功能如何使用。监控回放可选不同厂家类型、回放时间段、用户信息、指定通道。支持切换回放进度。可以从声卡设备下拉框选择声卡播放声音，提供对应的切换声卡函数接口。支持编译到手机app使用，提供了专门的手机app布局界面，可以作为手机上的视频监控使用。代码框架和结构优化到最优，性能强悍，注释详细，持续迭代更新升级。源码支持windows、linux、mac、android等，支持各种国产linux系统，包括但不限于统信UOS/中标麒麟/银河麒麟等。还支持嵌入式linux。源码支持Qt4、Qt5、Qt6，兼容所有版本。 4.3. 视频控件 可动态添加任意多个osd标签信息，标签信息包括名字、是否可见、字号大小、文本文字、文本颜色、背景颜色、标签图片、标签坐标、标签格式（文本、日期、时间、日期时间、图片）、标签位置（左上角、左下角、右上角、右下角、居中、自定义坐标）。可动态添加任意多个图形信息，这个非常有用，比如人工智能算法解析后的图形区域信息直接发给视频控件即可。图形信息支持任意形状，直接绘制在原始图片上，采用绝对坐标。图形信息包括名字、边框大小、边框颜色、背景颜色、矩形区域、路径集合、点坐标集合等。每个图形信息都可指定三种区域中的一种或者多种，指定了的都会绘制。内置悬浮条控件，悬浮条位置支持顶部、底部、左侧、右侧。悬浮条控件参数包括边距、间距、背景透明度、背景颜色、文本颜色、按下颜色、位置、按钮图标代码集合、按钮名称标识集合、按钮提示信息集合。悬浮条控件一排工具按钮可自定义，通过结构体参数设置，图标可选图形字体还是自定义图片。悬浮条按钮内部实现了录像切换、抓拍截图、静音切换、关闭视频等功能，也可以自行在源码中增加自己对应的功能。悬浮条按钮对应实现了功能的按钮，有对应图标切换处理，比如录像按钮按下后会切换到正在录像中的图标，声音按钮切换后变成静音图标，再次切换还原。悬浮条按钮单击后都用名称唯一标识作为信号发出，可以自行关联响应处理。悬浮条空白区域可以显示提示信息，默认显示当前视频分辨率大小，可以增加帧率、码流大小等信息。视频控件参数包括边框大小、边框颜色、焦点颜色、背景颜色（默认透明）、文字颜色（默认全局文字颜色）、填充颜色（视频外的空白处填充黑色）、背景文字、背景图片（如果设置了图片优先取图片）、是否拷贝图片、缩放显示模式（自动调整、等比缩放、拉伸填充）、视频显示模式（句柄、绘制、GPU）、启用悬浮条、悬浮条尺寸（横向为高度、纵向为宽度）、悬浮条位置（顶部、底部、左侧、右侧）。 五、相关代码 void AbstractVideoWidget::getPoint(QEvent *event) { //正在运行中的视频或者设置了图片 if ((isRunning || !image.isNull()) &amp;&amp; !onlyAudio) { QMouseEvent *e = (QMouseEvent *)event; QPoint p = hwndWidget-&gt;mapFromParent(e-&gt;pos()); //过滤在绘图区域里面 if (hwndWidget-&gt;rect().contains(p)) { int w = videoWidth; int h = videoHeight; WidgetHelper::rotateSize(rotate, w, h); int x = (double)p.x() / hwndWidget-&gt;width() * w; int y = (double)p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8413d5cb7f217e35f55ddcf2d12851f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e2624abbcad9d50ead4ac6efd21ad46/" rel="bookmark">
			uniapp中uview组件库丰富的Calendar 日历用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本使用
#日历模式
#单个日期模式
#多个日期模式
#日期范围模式
#自定义主题颜色
#自定义文案
#日期最大范围
#是否显示农历
#默认日期
基本使用 通过show绑定一个布尔变量用于打开或收起日历弹窗。通过mode参数指定选择日期模式，包含单选/多选/范围选择。 &lt;template&gt; &lt;view&gt; &lt;u-calendar :show="show"&gt;&lt;/u-calendar&gt; &lt;u-button @click="show = true"&gt;打开&lt;/u-button&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { show: false, } } } &lt;/script&gt; #日历模式 mode为single只能选择单个日期mode为multiple可以选择多个日期mode为range可以选择日期范围 #单个日期模式 选择日期后，需要点击底部的确定按钮才能触发回调事件，回调参数为一个数组，有如下属性：
["2021-07-01"] 示例代码：
&lt;template&gt; &lt;u-calendar :show="show" :mode="mode" @confirm="confirm"&gt;&lt;/u-calendar&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { show: true, mode: 'single' } }, methods: { confirm(e) { console.log(e); } } } &lt;/script&gt; #多个日期模式 选择日期后，需要点击底部的确定按钮才能触发回调事件，回调参数为一个数组，有如下属性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e2624abbcad9d50ead4ac6efd21ad46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c560b1d4054806665fec550902498f7/" rel="bookmark">
			50个开发必备的Python经典脚本(11-20)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
11.获取网站的IP地址和主机名
12. 终端进度条
安装
13.Wifi密码弹出器
14. 给定网站的快照
安装
15. 将文件分割成块
16. 加密和解密文本
$ 先决条件
17.定期截屏
怎么运行？
18. 十进制到二进制转换器
19. CLI Todo 应用程序
安装
如何使用它？
20. 货币转换器
建议收藏备用 11.获取网站的IP地址和主机名 该脚本将用于获取任何网站的 IP 地址和主机名。
# Get Ipaddress and Hostname of Website # importing socket library import socket def get_hostname_IP(): hostname = input("Please enter website address(URL):") try: print (f'Hostname: {hostname}') print (f'IP: {socket.gethostbyname(hostname)}') except socket.gaierror as error: print (f'Invalid Hostname, error raised is {error}') get_hostname_IP() 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c560b1d4054806665fec550902498f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e98c85230cf88b38d890cab69c4519/" rel="bookmark">
			第 374 场周赛 解题报告 | 珂学家 | 拆位前缀和优化&#43;分组滑窗&#43;组合数学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 整体评价 这场挺难的，2题手速快的话，也能排一个好的名次。
T3是道经典的题，可以借助拆位前缀和来优化，不过整体的时间复杂度也算蛮高了，好像卡c++的常数了。
T4的组合数学好像超纲了，不过力扣周赛是考过几回了，属于常规超纲知识点。
T1. 找出峰值 class Solution { public List&lt;Integer&gt; findPeaks(int[] mountain) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; mountain.length - 1; i++) { if (mountain[i] &gt; mountain[i - 1] &amp;&amp; mountain[i] &gt; mountain[i + 1]) res.add(i); } return res; } } T2. 需要添加的硬币的最小数量 这题是结论题：
前缀和大于等于某个数，可以吸纳于集合中，并能自由组合构建 1 N 的数 前缀和大于等于某个数，可以吸纳于集合中，并能自由组合构建1~N的数 前缀和大于等于某个数，可以吸纳于集合中，并能自由组合构建1 N的数
class Solution { public int minimumAddedCoins(int[] coins, int target) { Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99e98c85230cf88b38d890cab69c4519/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7997d17bd15be2b864e4ac1bfeb7d41/" rel="bookmark">
			22 C&#43;&#43; RTTI, dynamic_cast, typeid, type_info类，虚函数表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RTTI run time type identification 运行时类型识别
作用是：通过运行时类型识别，程序能够使用基类的指针或者引用来检查这些指针或者引用所指向的对象的时机派生类别。
提供了 dynamic_cast运算符 和 typeid 运算符 让user 来做这个事情
dynamic_cast运算符： 能够让父类指针安全的指向一个子类.如果转换不成功，会返回null
//如果dynamic_cast 处理的是引用。使用try catch处理，在对于引用 转换的时候失败的时候，会有std::bad_cast error
Child31 * child311 = dynamic_cast&lt;Child31 *&gt;(pa);
Child31 &amp; pa33 = dynamic_cast&lt;Child31 &amp;&gt;(pa22);
void main() { Parent3 *pa = new Child31(20,"child31",89.9,40,"parent3",80.9); Parent3 &amp; qa = *pa;//用父类的指针的* 得到父类的引用。但是实际上开发者是知道*pa指向的是一个child的。 //假设当前的需求就是我们使用子类自己的方法 -》 child31publiceat，应该怎么做呢？ //qa.child31publiceat();目前是不行的 //C语言的做法是强行转换 Child31 &amp; qchild31 = (Child31&amp;)*pa; qchild31.child31publiceat(); //执行结果为： //Parent3 构造方法被执行 //	Child31构造方法执行 //	Child31 自己的 public 方法执行 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7997d17bd15be2b864e4ac1bfeb7d41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3719ae406d8ceb891925b00fe5ae1020/" rel="bookmark">
			Obsidian 快捷方式总结 ——提升你的工作效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Obsidian 快捷方式总结 1. 对文字的格式刷-快捷方式 加粗：**text** 快捷键：Ctrl + B右倾斜：*text* 快捷键：Ctrl + I划掉文字：~~text~~高亮文字：==text==引用代码：`code`公式：$math$ 快捷键：Ctrl + /注释：%% text %% 2. 对段落的格式化-快捷方式 无序列表：- 无序列表 （行首使用）有序列表：num. 有序列表 （数字+“.”+“文本”）代办事项：- [x] 或 - [] 快捷键：Ctrl + L大标题：### paragraph引用：&gt; 引用 或 &gt; [!tip] 3. 插入-快捷方式 水平线：--- （需要空两行使用）数学公式块：$$ Math $$代码块：python 4. 键盘快捷键 F快捷键类 F1 —— 查看帮助F2 —— 编辑所在文档的文件名F11 —— 全屏 跳转类 Ctrl + Tab | Ctrl + PageDown —— 下一标签Ctrl + Shift + Tab | Ctrl + PageUp —— 上一标签Ctrl + 1~4 —— 转换到第1~4标签Ctrl + 9 —— 转换到最后一个标签Ctrl + Alt + ← —— 在窗口返回Ctrl + Alt + → —— 从软件返回桌面 创建标签类 Ctrl + T —— 新建标签页Ctrl + Shift + N —— 在右侧创建标签页 其他类 Ctrl + , —— 打开设置Ctrl + ; —— 增加当前文档的属性Ctrl + K —— 插入链接Ctrl + W —— 关闭当前标签页Ctrl + Shift + W —— 关闭所有标签页 如果有问题欢迎大家指出！～，也可以在这里github-obsidian快捷方式进行添加。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1753ab5fc94a88011f016762b1220ee9/" rel="bookmark">
			Qualcomm® AI Engine Direct 使用手册（13）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qualcomm® AI Engine Direct 使用手册（13） 5.1.3 XML OpDef 配置示例 5.1.3 XML OpDef 配置示例 本页概述了与qnn-op-package-generator. 所有示例都是对位于以下位置的示例的更改：
${QNN_SDK_ROOT}/examples/QNN/OpPackageGenerator/ExampleOpPackageHtp.xml 笔记
示例配置使用一个后端，而 qnn-op-package-generator 目前仅支持 HTP、DSP 和 CPU 后端。
示例配置 #1
以下示例为 HTP 定义了一个操作包，其中包含一个名为 Softmax 的操作。此示例配置代表了后端操作相同且不需要任何补充信息的情况。
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;OpDefCollection PackageName="ExamplePackage" Domain="aisw" Version="1.0" &gt; &lt;OpDefList&gt; &lt;OpDef&gt; &lt;Name&gt;Softmax&lt;/Name&gt; &lt;Description&gt; &lt;Content&gt; Computes data normalization exponentially on an input tensor given an optional positive scaling factor, beta. The computation is done element-wise per batch along the last dimension.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1753ab5fc94a88011f016762b1220ee9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a07df4c8d6441f1e2b67fa45a79fbe/" rel="bookmark">
			Qualcomm® AI Engine Direct 使用手册（11）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qualcomm® AI Engine Direct 使用手册（11） 5 操作包5.1 生成操作包5.1.1 QNN Op 包代码生成 5 操作包 Qualcomm® AI Engine Direct中的操作包（也称为“Op 包”）是指可供后端使用的操作集合，以便用于创建和执行表示网络模型的 Qualcomm® AI Engine Direct图形。
Qualcomm® AI Engine Direct软件架构旨在允许使用 QNN 的应用程序的内存占用进行高度定制，具体取决于运行模型所需的后端和操作。操作包通过编译成与后端核心库不同的共享库而与后端分离。这允许用户通过将用例所需的任意数量的操作打包到 Op 包中来编译精益应用程序。这在深度嵌入的物联网类型用例中尤其理想，这些用例在严格的内存限制内运行，并且仅针对少数针对其需求定制的网络模型。
Qualcomm® AI Engine Direct后端通过 API QnnBackend_registerOpPackage()注册用户提供的 Op 包。
多个 Op 包可以在后端注册，并在后端内创建的上下文和图形之间共享，作为单独的、不同的实例。它们的生命周期和范围与它们注册的后端的范围相匹配，因此它们可以比任何需要它们的图表更持久。至关重要的是，这也意味着外部各方可以使用 Qualcomm® AI Engine Direct Op 包使用的相同机制轻松创建其自定义 Op 包并将其与Qualcomm® AI Engine Direct集成。所有 Op 包都需要实现QnnOpPackage.h中定义的接口。
请参阅教程，了解简单的示例操作包，该包演示了外部各方如何在 Qualcomm® AI Engine Direct框架内创建和使用自定义操作。
请参阅以下部分，了解有关生成 Op 包框架代码的信息，然后可以将其实现为成熟的 Qualcomm® AI Engine Direct Op 包。
5.1 生成操作包 本节包含相关的子节，可用于使用XML OpDef 配置文件通过qnn-op-package-generator工具生成自定义 op 包的框架代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3a07df4c8d6441f1e2b67fa45a79fbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a72b471ca9ec9c88a16047dd9b89fded/" rel="bookmark">
			嵌出式srtm32学习第一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于库函数的开发模板的搭建，点亮一个小灯灯
叫外设的函数放在HARDWARE中，本次写的是点亮LED，故里面放入的则是LED.H和LED.C
#ifndef __LED_H //防止重复定义 #define __LED_H	#include "sys.h" #define LED0 PBout(5)// PB5 宏定义 LED0就相当于PB5 #define LED1 PEout(5)// PE5	同上 void LED_Init(void);//初始化 #endif 在LED.C文件中写初始化函数即可
#include “led.h”
//初始化PB5和PE5为输出口.并使能这两个口的时钟 //LED IO初始化
一般步骤就是 先定义一个初始化的结构体指针用于初始化的时候使用 第二部就是给需要使用的端口进行使能 然后开始开始配置其端口的基本属性 如 引脚是第几个 什么输出或者输入模式 速度 是否需要先给其复制为高低电平 ```css void LED_Init(void) { GPIO_InitTypeDef GPIO_InitStructure;//定义一个结构体指针变量，因为初始化的时候需要用到 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOE, ENABLE);	//使能PB,PE端口时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;	//LED0--&gt;PB.5 端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	//IO口速度为50MHz GPIO_Init(GPIOB, &amp;GPIO_InitStructure);	//根据设定参数初始化GPIOB.5 GPIO_SetBits(GPIOB,GPIO_Pin_5);	//PB.5 输出高 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;	//LED1--&gt;PE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a72b471ca9ec9c88a16047dd9b89fded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b171a918750f3520670d2c9e48fd34/" rel="bookmark">
			简述Redis备份策略以及对应的实现机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 Redis作为高性能的内存数据库，数据的安全性至关重要。一旦数据丢失，可能会对业务造成重大影响。因此，备份Redis数据是每个Redis使用者都必须考虑的问题。本文将介绍Redis的备份策略以及对应的实现机制。
一、备份策略 1.1 定期备份 定期备份是一种重要的数据保护策略，它是指在固定的时间间隔内对Redis数据进行备份。这种策略适用于数据量不大且允许一定时间的数据丢失场景。定期备份的优点在于其简单易行，只需设置定时任务即可。然而，这种备份方式的缺点在于可能无法保证数据的实时完整性。
在实施定期备份策略时，需要考虑以下几个关键因素：
备份频率：根据数据的重要性和变化频率，确定合适的备份间隔。频繁的备份可以减少数据丢失的风险，但也会增加存储和计算资源的消耗。备份存储：选择可靠的存储介质和设备来存储备份数据。确保存储设备具有足够的容量，并定期检查其可用性和性能。恢复流程：制定详细的恢复流程，以便在需要时能够快速恢复数据。恢复流程应包括从备份中提取数据、验证数据的完整性和准确性，以及将数据恢复到Redis服务器等步骤。安全性：确保备份数据的安全性，防止未经授权的访问和篡改。可以采用加密、访问控制和审计等措施来保护备份数据的安全。
为了克服定期备份无法保证实时完整性的缺点，可以考虑结合其他备份策略，如增量备份或差异备份。这些策略可以在较短的时间间隔内只备份发生变化的数据部分，从而减少备份数据量并提高备份效率。
总之，定期备份是一种实用的数据保护策略，但需要根据实际情况进行合理的配置和优化。通过综合考虑备份频率、存储、恢复流程和安全性等因素，可以有效地保护Redis数据的安全和完整性。 1.2. 实时备份 实时备份是一种重要的数据保护策略，它能够确保数据的实时性和完整性。在Redis等数据库系统中，实时备份被广泛应用，以应对数据丢失或损坏的风险。
实时备份的工作原理非常简单，即每当数据库写入一个数据，备份任务就会立即对该数据进行备份 。这种策略特别适用于数据量较大且要求数据实时可用的场景。
例如，金融交易系统、在线游戏、实时通信应用等都需要保证数据的实时性和可用性，因此实时备份策略在这些领域中具有非常重要的应用价值。
实时备份的优点主要表现在数据完整性方面。 由于数据是实时备份的，因此可以确保数据的完整性和一致性，避免因数据丢失或损坏而导致的问题。此外，实时备份还可以提高数据的可用性，因为即使在数据库发生故障时，也可以迅速恢复数据并保证服务的连续性。
然而，实时备份也存在一些挑战和限制。
首先，由于需要实时备份数据，因此需要占用较高的系统资源和带宽。这可能会对数据库的性能产生一定的影响，尤其是在数据量较大或网络带宽有限的情况下。其次，实时备份需要有效的存储和管理机制，以确保备份数据的可靠性和安全性。此外，对于大规模的数据备份，还需要考虑数据存储的成本和可扩展性问题。 为了克服这些挑战和限制，可以考虑采用一些优化措施。例如，可以采用增量备份或差异备份策略，只备份自上次备份以来发生更改的数据，以减少备份数据量和带宽占用。
此外，还可以采用压缩和加密技术来降低存储成本和提高数据安全性。同时，还需要建立健全的备份管理和恢复机制，以确保在需要时可以快速恢复数据并保证服务的连续性。
实时备份是一种重要的数据保护策略，适用于需要保证数据实时性和完整性的场景。虽然存在一些挑战和限制，但通过采用优化措施和建立健全的管理机制，可以有效地克服这些问题并实现高效的数据备份和恢复。
1.3. 增量备份和全量备份 增量备份和全量备份是两种常见的备份策略 ，它们在数据恢复方面起着至关重要的作用。增量备份是指只备份自上次备份以来新增的数据，而全量备份则是备份整个数据库的数据。这两种策略适用于数据量较大且要求数据恢复速度快的情况。
增量备份的优点
增量备份的优点在于备份速度快，因为它只备份新增的数据，所以备份过程不会受到整个数据库大小的影响。增量备份可以大大减少备份所需的存储空间，因为只备份了自上次备份以来新增的数据。这种策略对于大型数据库非常有效，因为它可以在较短的时间内完成备份，同时减少了对存储空间的占用。 增量备份的缺点
首先，数据恢复可能需要较长时间。由于增量备份只包含了自上次备份以来新增的数据，因此，在数据丢失的情况下，需要先恢复上次全量备份的数据，然后再逐个恢复增量备份的数据。这可能需要较长的时间来完成。其次，增量备份可能导致数据不一致的风险增加。由于只备份了新增的数据，如果发生数据损坏或丢失，可能会导致数据的不一致性。 相比之下，全量备份可以避免上述问题。
全量备份是指备份整个数据库的数据，这意味着可以在较短的时间内完成备份过程。此外，全量备份可以确保数据的完整性和一致性，因为它是整个数据库的完整镜像。 全量备份其缺点
由于它需要备份整个数据库的数据，因此可能会占用大量的存储空间，并且可能需要更长的时间来完成。此外，如果数据库非常大，全量备份可能会对系统性能产生负面影响。
增量备份和全量备份各有优缺点。在选择备份策略时，应该根据具体情况进行权衡。
如果数据量较大且要求数据恢复速度快，可以考虑使用增量备份和全量备份相结合的方式。这种方式可以结合增量备份的快速备份速度和全量备份的数据完整性和一致性优点。通过合理地设置增量备份和全量备份的频率和时间点，可以确保数据的可靠性和安全性。
二、Redis持久化机制 Redis作为高性能的内存数据库，其持久化机制是确保数据安全和可靠性的关键。通过持久化，我们可以将数据从内存保存到硬盘，以便在系统故障或重启后恢复数据。下面我们将深入探讨Redis的持久化机制，以及如何在Java中实现这些机制。
1. RDB（Redis DataBase） RDB是Redis自带的一种持久化方式，通过定期或手动生成数据快照进行备份。在Redis中，RDB持久化可以在指定的时间间隔内生成数据快照，从而将数据保存到磁盘上。
这种方式的优点在于生成的数据文件较小，因此备份和恢复的速度都非常快。此外，由于数据是压缩存储的，因此可以节省大量的存储空间。
然而，RDB也存在一些缺点。 最主要的问题是可能会造成数据丢失。由于RDB是通过生成数据快照的方式进行持久化的，如果数据库在生成快照的过程中出现故障，可能会导致部分数据未能成功保存。此外，如果数据库的数据量非常大，生成的快照文件也可能会非常大，这会增加备份和恢复的难度。
为了解决这些问题，Redis提供了多种配置选项，可以让用户根据自己的需求进行调整。 例如，用户可以设置生成快照的频率、压缩方式等参数，以平衡数据持久化的可靠性和性能。此外，为了确保数据的完整性，建议在生成快照后进行校验，以确保数据的正确性。
RDB持久化示例
首先，确保你已经将Jedis库添加到项目中。你可以通过Maven或Gradle进行添加。
Maven依赖：
&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;!-- 使用最新版本 --&gt; &lt;/dependency&gt; 接下来，使用以下代码设置RDB持久化：
import redis.clients.jedis.Jedis; import redis.clients.jedis.JedisPool; import redis.clients.jedis.JedisPoolConfig; import redis.clients.jedis.SaveParams; public class RedisRDBPersistence { public static void main(String[] args) { // 创建连接池配置 JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b171a918750f3520670d2c9e48fd34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2d5f2e159fddb4c129a8c9760d5ea91/" rel="bookmark">
			windows系统硬盘序列号、MAC地址查询方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬盘序列号查询方法 进入命令行（cmd+R）.输入diskpart回车进入diskpart命令行。输入list disk，列出所有磁盘和它们的磁盘号。输入select disk ${磁盘号}，选中磁盘。输入detail disk，输出磁盘详细信息，磁盘ID后面就是序列号。 结束
Win10MAC地址查询方法 在 设置—网络和Internet—网络和共享中心—以太网 界面中点击进入以太网详情页，其中“物理地址”一栏即为网卡对应的MAC地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d70df943fbc1668066f9b1a15f5653e4/" rel="bookmark">
			Manuskript 阅读 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目的主要代码存放于 manuskript 文件夹下。
manuskript 文件夹的结构 manuskript ├── converters │ ├── abstractConverter.py │ ├── __init__.py │ ├── markdownConverter.py │ ├── pandocConverter.py │ └── __pycache__ │ ├── abstractConverter.cpython-310.pyc │ ├── __init__.cpython-310.pyc │ └── pandocConverter.cpython-310.pyc ├── enums.py ├── exporter │ ├── basic.py │ ├── __init__.py │ ├── manuskript │ │ ├── HTML.py │ │ ├── __init__.py │ │ ├── markdown.py │ │ ├── plainText.py │ │ └── __pycache__ │ │ ├── HTML.cpython-310.pyc │ │ ├── __init__.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d70df943fbc1668066f9b1a15f5653e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847c4a83b1d2633915d041110d19a605/" rel="bookmark">
			零知识证明（zk-SNARK）- groth16（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		From Computational Problem to zk-SNARK 本部分就是将计算难题转换为多项式，然后使用zk-SNARK。
（注：以下用 P，V 替代 Prover，Verifier）
计算难题-&gt;R1CS R1CS(Rank-1 Constraint System)是一种能够将算数电路统一成约束向量的方式，一组向量构成一组满足特定形式的式子。
计算式拆解 我们知道一般的计算可以拆解为 左操作数 操作符 右操作数 = 输出（如 a × b = c a\times b = c a×b=c）这样的格式，更复杂的计算则是由一系列简单的计算组合而成的。
那么多个操作符应该如何如何表示呢？
多个操作符就需要将其拆分成单个操作符组成式子组，以乘法为界限，例如假设某个计算难题的计算正确计算过程是 a b ( a + c ) = d ab(a+c)=d ab(a+c)=d这个计算式子，有两个乘法，那么就需要拆分成两个式子，如下
{ a × b = e ( a + c ) × e = d \begin{cases} {\color{green}a} \times {\color{blue}b} = {\color{red}e}\\ {\color{green}(a+c)} \times {\color{blue}e} = {\color{red}d} \end{cases} {a×b=e(a+c)×e=d​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847c4a83b1d2633915d041110d19a605/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d1ce507697eef78e76475630a8a6a26/" rel="bookmark">
			为什么要用递归以及递归如何书写？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.为什么要用递归 一般情况下我们的程序是用递推，一步一步往下写，这样也符合我们思考问题的方式。那上面情况下要用递归呢？就是当数据或者问题不是线性而是树状或者图状的时候。
就拿我第一次遇见递归的爬楼梯问题举例，是一道非常经典的题目。
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 示例 1： 输入：n = 2 输出：2 解释：有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 比如是3，我们每次爬有两种情况，爬一次，爬两次，然后每次爬完下次爬也会面临多次选择，有多少种情况我们是没办法事先知道的，所以这就是一种树的模型。
如果用递推并不是没法写，可以用队列模拟，先将对后序有影响的情况推入队列，等到与情况相关的子情况遍历完再排出队列。
但是这种树的问题，最适合的是用递归来解决。递归就是模拟我们画这颗树解决问题的过程，更加形象直观，便于理解。
当然，递归不是万能的，不要任何事情都用递归，如果是线性问题，就不要用递归。
解决线性问题的时候，首先递归通常伴有重复的计算加上很多的函数调用，所以时间复杂度通常比递推慢。就算加入动态规划，使得时间复杂度勉强达到一个层次，动态规划的数组与函数调用时需要保存的状态所需的空间复杂度肯定更高。最重要的是思路还变得更为麻烦。
综上所述，递归适用于树状或者图状的问题/数据。
二.递归怎么书写？ 例题：给定一棵树的前序遍历数组，判断这棵树是不是二叉搜索树。 第一步：首先你分析问题，要有递归的思路，知道要递归什么来解决问题。 比如上面这个通过前序遍历判断搜索二叉树，首先我们要清楚二叉搜索树的定义。
根据定义，我们不难得出思路，先判断这颗二叉树的左子树（不为空的话）的所有结点是不是小于它的根结点，再判断右子树（不为空的话）的所有结点是不是大于它的根结点。
然后递归判断其左右子树（如果有的话）是不是也满足这个条件。
另外的话你也要清楚前序遍历的特点，第一个结点一定为根节点，然后的话遍历顺序为根结点-&gt;左子树-&gt;右子树。
结合搜索二叉树，我们可以得出第一个点为根结点，然后往后找，第一个比根结点小的树为左子树的根结点，第一个比根节点大的为右子树的根节点，左子树根节点与右子树根结点之间为左子树的前序遍历序列，右子树之后为右子树的前序遍历序列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d1ce507697eef78e76475630a8a6a26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8183919ceafb1521e8b413df121cae0d/" rel="bookmark">
			【Python】Python通过setup.py安装模块、卸载模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 本文转载自
[1] cknds. python安装模块如何通过setup.py安装以及如何卸载这种安装 [EB/OL]. https://www.cnblogs.com/yoyowin/p/12626382.html, 2020-04-03/2023-12-28.
正文 在安装python的相关模块和库时，我们一般使用 pip install 模块名 或者 python setup.py install ，前者是在线安装，会安装该包的相关依赖包；后者是下载源码包然后在本地安装，不会安装该包的相关依赖包。
有些时候我们发现一些模块没有提供 pip install 命令和安装教程 , 只提供了一个setup.py文件 , 这个时候如何安装呢?
一、通过setup.py安装模块的安装步骤 到达 setup.py所在的目录编译模块 python setup.py build 安装 python setup.py install 注意，如果需要卸载，请执行下述指令进行安装：
python setup.py install --record install_location.txt # 记录安装后文件的路径 二、通过setup.py安装的模块卸载步骤 只能手动删除安装的文件，可以使用如下命令。
安装指令 python setup.py install --record install_location.txt # 记录安装后文件的路径 cat install_location.txt | xargs rm -rf # 删除这些文件 卸载指令 cat install_location.txt | xargs rm -rf # 删除这些文件 如果提示权限不足，可执行如下指令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8183919ceafb1521e8b413df121cae0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7f786f265acf31288e62c306dcaa689/" rel="bookmark">
			2024线性代数复习——矩阵代数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相似矩阵：存在可逆矩阵 P P P，使得 P − 1 A P = B P^{-1} A P=B P−1AP=B，则称矩阵 A A A， B B B 相似，特征值相等。注意只有相似矩阵 B B B 是对角阵，我们才说它是可以相似对角化的。
A A A 可以相似对角化 ⇔ 充要条件 \overset{充要条件}{\Leftrightarrow} ⇔充要条件 是 A A A 有 n n n 个线性无关的特征向量，且对角线的值就是特征值。
A A A 可以正交对角化 ⇔ 充要条件 \overset{充要条件}{\Leftrightarrow} ⇔充要条件 是 A A A 是实对称矩阵。对称矩阵对应于不同特征值的特征向量是正交的，这就可以构造出单位正交基，满足 P T P^T PT= P − 1 P^{-1} P−1。
矩阵等价：对同型矩阵 A A A、 B B B，存在可逆阵 P P P 和 Q Q Q，使得 B = P A Q B=PAQ B=PAQ
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7f786f265acf31288e62c306dcaa689/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/988f2f114e9f5926ea4bf76f383b7d8a/" rel="bookmark">
			为什么TCP会粘包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬核图解|tcp为什么会粘包？背后的原因让人暖心
数据包报文格式（IP包、TCP报头、UDP报头）
TCP，Transmission Control Protocol。传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。
TCP粘包是指发送方在发送数据时，由于一些原因（如网络缓冲区大小、数据发送速度等），导致多个数据包被合并成一个大的数据包发送，或者接收方在接收数据时，一次性接收到多个数据包的情况。这种情况可能会影响数据的解析和处理。
看上图可以知道TCP的报文格式里面没有数据包长度相关字段，那问题来了，如果两个TCP数据包合因为长度不够（因为IP数据包有最小载荷长度）导致合并成一个IP数据报，那接收方如何把这两个TCP数据包给分出来呢，这就有了TCP粘包问题。
粘包出现的根本原因是不确定消息的边界。接收端在面对"无边无际"的二进制流的时候，根本不知道收了多少 01 才算一个消息。
一不小心拿多了就说是粘包。其实粘包根本不是 TCP 的问题，是使用者对于 TCP 的理解有误导致的一个问题。
只要在发送端每次发送消息的时候给消息带上识别消息边界的信息，接收端就可以根据这些信息识别出消息的边界，从而区分出每个消息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7adf1e8eaf61d5efeb5f084537f4c6b8/" rel="bookmark">
			Spring Data JPA的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 spring data简介spring data jpa简介springboot整合jpa依赖yml实体类dao层 关联关系的表达一对一一对多多对多 常见问题 spring data简介 spring data是spring的一个子项目，是spring家族成员之一，旨在简化数据访问层的开发，给操作数据库（关系数据库sql、非关系数据库nosql）提供了一系列组件，常用的比如
spring data jpa：整合关系数据库spring data redis：整合redisspring data mongodb：整合mongodbspring data elasticsearch：整合es spring data jpa简介 Java Persistence API，spring data jpa是spring data系列组件之一，旨在简化对关系数据库的操作，可作为 mybatis、hibernate 外的另一种选择。包含了 hibernate 的很多功能，比如实体类生成表的正向工程，比如 @Entity、@Table、@Id、@GeneratedValue、@ManyToMany、@JoinTable 等注解。封装了dao层的通用接口，提供了许多通用方法，可通过方法命名约定不写单表操作的简单sql，简化了数据访问层的开发，大大提高了开发效率。提供的关联查询、级联操作了解即可，不推荐使用，因为容易踩坑、难以维护。 官方文档：https://docs.spring.io/spring-data/jpa/reference/index.html
github：https://github.com/spring-projects/spring-data-jpa
springboot整合jpa 依赖 创建时勾选 SQL -&gt; Spring Data JPA、数据库驱动，并添加连接池的依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt; &lt;/dependency&gt; jpa的依赖中包含了hibernate的核心依赖
yml spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mall?serverTimezone=Asia/Shanghai&amp;allowMultiQueries=true username: chy password: abcd jpa: #打印sql的日志 show-sql: true #hibernate正向工程，根据实体类生成数据表 # hibernate: # ddl-auto: update create：每次启动应用时都会根据实体类重新生成数据表（覆盖原表）update：每次启动应用时都会根据实体类更新数据表的定义（更新是先删除原表再新建） 个人并不推荐使用hibernate的正向工程，容易采坑，如果要使用，只在初次启动应用时使用，后续将其注释掉。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7adf1e8eaf61d5efeb5f084537f4c6b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fe959890d50bcbdf53c4cdc7596d9cd/" rel="bookmark">
			虚幻UE 材质-PBR基于物理的渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：本篇不会深入讲解PBR各个模块的核心理论，以较为通顺的方式讲解，如需核心理论可以前往链接: 重新理解PBR（1）处学习。
文章目录 一、PBR简述二、材质参数1、基础颜色2、粗糙度3、法线4、金属度5、高光 三、核心理论1、微平面理论-反射2、能量守恒-反射能量小于入射能量3、菲涅尔特性4、BRDF双向反射分布函数5、线性空间光照 四、参考 一、PBR简述 PBR(Physically Based Rendering)：一种基于物理的渲染方式，根据现实生活中对事物材质随光的变化规律得到的理念和原则，基于这个规则理念去渲染的方式就叫PBR。（个人理解）
这么做很容易套用现实生活中的客观规律，渲染的画面也更接近现实。
做好PBR的方式很简单
就是要做好三件事
1、观察表面材质（材质参数）
2、分析表面材质随光的变化规律（核心理论）
3、按规律总结复刻（复制粘贴）
二、材质参数 观察表面参数，主要需要去观察以下几个方面：
1、基础颜色？（BaseColor）
2、粗糙度（Roughness）
3、金属度（Metallic）
4、法线（Normal）
5、高光（Specular）
等
1、基础颜色 • 即物体本身的颜色。（影响整体观感）
• 约等于渲染器的Diffuse | 漫反射、固有色
• Bridge中叫 Albedo | 反照率、反射率
• *BaseColor贴图本身应无光照信息
2、粗糙度 • 即物体表面的粗糙程度。（影响光的反射）
• 0（黑色）表示绝对光滑，1（白色）表示绝对粗糙
• *其它渲染器一般使用Glossiness（光滑度）来描述表面粗糙度，其逻辑和Roughness是反向的。
3、法线 • 描述物体表面的细微起伏（材质都是2D，然后还原3D，得靠法线）
• “光照魔法”，不改变几何体本身
• *改变几何体本身的技术是Displacement | 置换
4、金属度 • 描述物体表面的金属特征（金属和非金属反光的规律差别很大）
• 金属特征：反射（高光）颜色是否跟随基础色
• 换句话说，反射内容是否被“染色”
非金属车漆反射的颜色是环境的颜色，而金属车漆反射的是本身颜色。
材质参数关注的都是表面特性，和你是否是什么材质无关，和你想表现的材质有关。
但是有一部分金属可能就不是很符合“反射（高光）颜色是否跟随基础色”这个特性。
如：银，因为它的基础色就是白色。
反射并没有发生“染色”，是因为染色结果为“白色”，也就是原色。
5、高光 • 虚幻无法直接为材质设定反射IOR，而是用Specular参数替代（后面会详细讲解IOR）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fe959890d50bcbdf53c4cdc7596d9cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec43c98c4daf546423e6047cfb7ebb57/" rel="bookmark">
			离散点曲线曲率计算方法大汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在机器人、自动驾驶等领域中，规划与控制常常需要获取路径的曲率信息，而路径曲线的表示的方式一般为离散点的形式，这给曲率的求取带来一定难度。下面给出4种根据离散点曲线求曲率的方法。
方法 差分法 # 差分法 def calculate_curvature_difference(data, interval=1): # interval代表计算曲率时选取点的间隔，例如当需要计算data[i]的曲率时，选取的点为 # data[i-2*interval],data[i-interval],data[i],data[i+interval],data[i+2*interval]这5个点来计算 # 通过此操作可以缓解离散点不平滑的情况，后面的函数同理 curvature_list = [] for i in range(len(data)): # 初始化头尾的曲率均为0 if i &lt; 2 * interval: curvature_list.append(0) elif i &gt; len(data) - 2*interval - 1: curvature_list.append(0) # 获取间隔为interval的5个点（二阶差分需要5个点） else: start, end = i - 2 * interval, i + 2 * interval + 1 x, y = data[start:end:interval, 0], data[start:end:interval, 1] # 差分法计算曲率 # 一阶差分 dx = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec43c98c4daf546423e6047cfb7ebb57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd1c9759373d31af979eab3b5f45550c/" rel="bookmark">
			ES实用的深度解构赋值方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES6 中允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。使用解构赋值可以将复杂的代码整理的更加干净整洁。 1.解构对象 在没有使用解构之前，想要确定对象中的某些属性，那么就需要从对象中获取属性然后赋值给变量，这样会让代码显得非常冗余，如下代码所示：
let obj = {name:"张三",age:22}; let name = obj.name; let age = obj.age; console.log(name,age); // 张三 22 1）基本解构格式 如果使用解构的话，只需要如下面格式所写即可，保持将变量名和对象属性名同名才可取到值。
let {name,age} = {name:"张三",age:22}; console.log(name,age); 2）变量别名 如果要解构的对象中的属性名和外部的名称重名了，将会报错，可以使用别名的方式进行解构，如下所示：
let name="王五"; let {name:newName,age} = {name:"张三",age:22}; console.log(newName,age); 3）变量默认值 如果目标对象属性中没有要解构的属性，不指定默认值，那么将会undefined，此时可以给解构变量写默认值，如下所示：
let {name,age,gender="男"} = {name:"张三",age:22}; console.log(name,age,gender); 此种为变量设置默认值的方法，常应用于函数参数中，加入调用函数时没传递参数，有可能会对函数运行造成错误，那就可以在形参位置进行对象解构，对变量指定默认值，如下代码所示：
function fn({name='李四',age=30}={}){ console.log(name,age); } fn() 2.解构数组 解构数组和对象有些不同，解构对象的时候属性前后位置不影响，但是结构数组，需要按照索引顺序结构。
1）数组基础解构用法 如果在没有解构之前，需要拿到数组中的前3位字符串，那么只能按照下面这种按照索引值的方式定义变量，如下所示：
let arr = ["HTML5","JavaScript","Vue","React","NodeJS"]; let str1 = arr[0]; let str2 = arr[1]; let str3 = arr[2]; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd1c9759373d31af979eab3b5f45550c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0f58b43d4c47aa0766eb2fbf68d8897/" rel="bookmark">
			9、ES高频面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、什么是倒排索引 倒排索引是搜索引擎的核心，它是一种像数据结构一样的散列图，可将用户从单词导向文档或网页。主要目标是快速从数百万文件中查找数据
倒排索引主要体现在文档的保存和查询流程中
保存文档时，会先根据文档进行分词，然后使用分好的词条作为key进行排序，然后将文档的标识作为value进行存储
查询文档时，也会先对查询关键字进行分词，然后根据分好的词条直接定位相关文档，再做结果的合并
2、ES中的查询关键字有哪些 在ES中用于声明查询条件的关键字主要有：
match_all：查询所有
match、multi_match：全文检索
term：精准词条查询
range：范围查询
bool、must、must_not、should、filter：复合查询
还有一些跟地理位置、相关性算分相关的
3、ES中字符串类型有几个 ES有两个字符串类型，分别是：keyword 和 Text，他们两个的区别主要是在分词方面
keyword类型的字符串是不会分词的，直接根据字符串内容建立倒排索引Text类型的字符串在保存到ES时会先分词，然后根据分词后的内容建立倒排索引 4、ES中query和filter的区别 query和filter都可以实现ES中的查询，区别是
query查询操作不仅仅会进行查询，还会计算分值，用于确定相关度filter查询操作仅判断是否满足查询条件，不会计算任何分值，也不会关心返回的排序问题，同时，filter查询的结果可以被缓存，提高性能。 5、如何保证ES和MySQL的数据一致性 保证MySQL和ES数据一致性的方式有很多，下面列举几个：
同步双写：程序在向MySQL写入数据之后，立即将数据写入ES中。这种方法可以确保数据的实时同步，但可能会增加系统的复杂性和延迟。异步消息：程序在在向MySQL写入数据之后，向MQ中投递消息，ES相关程序监听MQ，获取数据，写入EScanel监听：使用canel监听MySQL的binlog，当发现写入操作后，立即读取内容，写入ESlogstatsh：使用logstatsh将MySQL中的数据实时传输给ES 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/886378f38c6f0228b2bdb28d9a0b1e31/" rel="bookmark">
			华为HCIA课堂笔记第二章 网络参考模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第二章 网络参考模型（12.13） 2.1 OSI七层模型 应用层：提供是应用的接口。产生数据。比如网页，QQ，微信
表示层：进行数据格式的转换，比如：加密和解密
会话层：应用在传输数据的，要实现建立应用的会话。建立、管理、拆除应用会话。
传输层：通过端口号来区分不同的应用，传输数据之前需要建立端口到端口的连接通道。封装传输层的头部形成数据段（源目端口号+Data 数据段）
网络层：3层，提供一个逻辑的地址（IP地址），根据报文的目的地址寻址。IPv4、IPv6协议。封装网络层头部形成数据包（源目IP地址+源目端口号+Data 数据包）（路由器，3层交换机）。
数据链路层：对报文封装数据链路层头部形成数据帧，进行报错检查。点到点的通信。（源目MAC地址+源目IP地址+源目端口号+Data 数据帧），只有形成完整的数据帧，数据报文才能够转发出去。（交换机）
物理层：定义了电气化标准，接口的电气化标准，将数据帧形成bit流在物理介质上转发。（包含：光纤，双绞线-网线，无线电波，hub集线器设备）
2.2 TCP/IP对等模型 5层：应用层、传输层、网络层、数据链路层，物理层。
2.2.1各层对应的协议 应用层： Telnet 协议：用于远程登录网络设备（路由器，交换机，服务器），进行网络设备管理。FTP协议：文件传输协议，用于传输文件的，基于TCP协议，端口号21用于传输控制报文（协议本身的消息）。端口20，用于数据传输的。TFTP协议：简单文件传输协议，基于UDP协议，端口69。SNMP协议：简单网络管理协议，用于网络设备的自动管理。HTTP协议：超文本传输协议，网页服务，服务器端口号默认80HTTPS协议：安全的超文本传输协议，网页服务。端口号默认是443SMTP协议：简单邮件传输协议，在个人电脑上进行邮件管理DNS协议：域名解析协议。 主机访问www.baidu.com，没有对应的百度服务器的IP地址，无法封装正常的网页的请求数据包。主机通过DNS协议向DNS服务器发送DNS请求，询问www.baidu.com的IP地址。DNS服务器存储了域名和IP地址的对应关系。DNS服务器收到请求后，回复响应报文，告知主机百度的IP地址。主机保存www.baidu.com域名与IP地址的映射关系，并且封装对应的HTTP报文（报文中包含了百度的IP地址）。常用的DNS服务器 114.114.114.114（DNS服务器的IP地址）DHCP协议：动态主机配置协议，用于主机的IP地址自动配置。传输层协议：TCP（传输控制协议）、UDP（用户数据报协议），都包端口号，用于区分不同应用。网络层协议：IP协议（IPv4协议）、IPv6协议，Internet Protocol（网际协议），IP地址以及寻址，头部字段中“协议Protocol”字段，如果取值为6，表示传输层协议是TCP，如果取值为17，表示传输层协议为UDP数据链路层协议： ARP协议：地址解析协议，用于解析IP地址对应的MAC地址。Ethernet II协议：以太网协议（携带MAC地址），通常使用以太网交换机，和以太网线802.3协议：以太网协议。PPP协议：点到点协议，没有MAC地址，通常采用串口线进行设备相连。PPPoE：以太网拨号协议，用于用户拨号上网。 2.3 传输层 2.3.1 单位换算 bit：一个0或者是1
8bit=1字节（Byte）
1024B=1KB
1024KB=1M
1024M=1G
2.3.2 TCP报文内容 源端口号：标识本端的应用程序
目的端口号：标识目的端的应用程序（服务）
序列号：TCP发送的报文都会添加一个序列号，用于标识报文的顺序
确认序列号：该字段用于确认已收到的报文，必须控制字段中的ACK比特位置位，该字段才有效。
头部长度：只TCP报文的头部总长度（包含了可变长的Option字段），如果不包含Option字段，头部长度为20B，也叫数据偏移。作用是用于标识TCP头部后的数据起点位置。
保留位：6bit填充0，用于以后的新增功能。
控制位：
SYN 比特位：如果该报文的SYN比特位置1，则该报文是一个请求建立连接的报文。ACK 比特位：如果该报文的ACK比特位置1，则表示该报文的确认序列号字段有效。FIN 比特位：如果该报文的FIN比特位置1，则表示该报文是一个请求断开连接的报文。RST：置1表示重置当前的连接PSH：置1表示报文需要紧急交给应用程序处理。URG：置1表示紧急指针字段有效 窗口字段：用于控制报文的发送速度（根据接收到的报文中的窗口字段大小，发送报文。）
校验和：用于校验TCP的头部和数据，接收方根据相同的算法计算出值，与报文中的携带的校验和比较，相同则接受。
紧急指针字段：该字段表示，缓存中需要紧急处理的数据的大小，URG置位该字段有效。
Option字段：功能字段
Padding字段：填充字段，将报文的头部填充到4B的整数倍长度。
2.3.3 UDP字段 源端口号、目的端口号、长度、校验和。
长度：该字段值表示UDP头部和数据总长度。
2.3.4 端口号 端口号存储空间16bit，端口号的范围0-65535；
其中0-1023是知名端口号：比如FTP的21号端口，HTTP的80号端口。
其中1024-65535是非知名端口：本地产生数据访问服务器，在该范围内随机产生一个端口号，作为源端口号，用于区分本设备上的不同应用。
收到报文的时候，根据目的TCP/UDP头部中的目的端口来确定TCP的数据部分应该交给本地哪个应用（程序）处理。
2.4 TCP的工作机制 2.4.1 TCP的三次握手 PC1向PC2发送TCP报文，其中序列号字段为a（己方），确认序列号字段为0，控制比特位中SYN比特置位1，表示该报文是一个请求建立连接的报文。PC2收到请求报文后，其中序列号是b（己方），确认序列号是a+1，表示收到了a报文，请下次发送a+1号报文。控制比特位SYN比特置位，表示该报文是一个请求报文，ACK比特位置位1，表示确认序列号a+1是有效的。PC1收到PC2的报文，也需要对PC2的报文进行确认，发送的报文序列号是PC2希望发送的序列号a+1，确认序列号是b+1，表示已收到b报文，请PC2下次发送b+1号报文，同时控制比特位ACK置位，表示确认序列号有效。 2.4.2 TCP的序列号和确认序列号（数据转发过程） PC1与PC2双向建立了TCP连接PC1向PC2发送带有载荷部分的TCP报文PC2的确认序列号是PC1发送给PC2报文中的序列号+载荷长度（B字节）数据交互过程中的TCP报文的序列号沿用三次握手之后的序列号。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/886378f38c6f0228b2bdb28d9a0b1e31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca5e3ffad2e0bc93e1e2fdc001eec763/" rel="bookmark">
			gnu工程的编译 - 以libiconv为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 gnu工程的编译 - 以libiconv为例概述gnu官方源码包的发布版从官方的代码库直接迁出的git版源码如果安装了360, 需要添加开发相关的目录到信任区生成 configrue 的方法备注END gnu工程的编译 - 以libiconv为例 概述 gnu工程的下载分2种:
gnu官方源码包的发布版 这种下载到本地后, 就是可以直接3部曲(./configure &amp;&amp; make &amp;&amp; make install)编译的源码包.
从官方的代码库直接迁出的git版源码 e.g. https://git.savannah.gnu.org/git/libiconv.git
这个git库迁出到本地, 是没有./configure这个文件的, 没办法直接执行3部曲编译.
文档中没有说怎么生成./configure(应该是我没耐心去翻看所有文档).
观察了一下, 工程本地有3个.sh, 试了一下成功了.
等生成了./configrue, 就可以3部曲编译工程. 编译出来的工程输出正确可用.
如果安装了360, 需要添加开发相关的目录到信任区 我用的360企业版.
双击托盘上的360 =&gt; 360主界面 =&gt; 木马查杀 =&gt; 右上角更多 =&gt; 信任区
将cygwin64的安装后的目录和工程所在的目录都加进去.
防止编译到一半, 360的拦截出来捣乱.
生成 configrue 的方法 先运行 ./autogen.sh, 如果报错, 说缺那些组件, 就装上.
缺的组件用cygwin64装上很容易.
我这里安装了: git, gettext, symbol, gperf, patch.
安装的这些组件, 都是运行.sh报错后, 添加上的, 要不也不知道附加安装一些什么组件.
通过运行./autogen.sh, 提示说 需要运行 gitsub.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca5e3ffad2e0bc93e1e2fdc001eec763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/817b043e4c37e10e8248dac4d97648b9/" rel="bookmark">
			【多线程】常见问题简单总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 竞态条件（Race Condition）
场景:
解决方法:
2. 死锁（Deadlock）
场景:
解决方法:
3. 线程饥饿（Thread Starvation）
场景:
解决方法:
4. 活锁（Livelock）
场景:
解决方法:
多线程编程在提高程序性能方面非常有用，但也引入了一系列常见问题，主要包括竞态条件、死锁、线程饥饿和活锁等。以下是这些问题的解释以及如何在Java中解决它们的例子。
1. 竞态条件（Race Condition） 竞态条件发生在两个或多个线程访问共享资源并尝试同时修改它时。这可能导致不一致和不可预测的结果。
场景: 共享资源: 当多个线程访问和修改同一个变量或资源，而没有适当的同步措施时。非原子操作: 操作如递增一个计数器，这需要读取、修改和写入值，这些步骤在没有同步的情况下会被中断。先检查后执行: 先检查资源状态，然后根据状态执行操作的模式，如果状态在检查和执行之间被另一个线程改变，会导致问题。 解决方法: 使用同步机制，如synchronized关键字或显式锁（如`ReentrantLock`），来确保一次只有一个线程可以访问共享资源。
Java 示例
public class Counter { private int count = 0; public synchronized void increment() { count++; } public synchronized int getCount() { return count; } } 2. 死锁（Deadlock） 死锁是指两个或多个线程永远等待对方释放锁的情况。这通常发生在每个线程都持有一个锁并尝试获取其他线程已持有的锁时。
场景: 互斥条件: 程序中的多个线程需要同时锁定多个资源。请求和保持条件: 线程已经持有至少一个资源，并且正在等待获取额外的资源，这些资源可能被其他已经锁定了它们的线程持有。不剥夺条件: 资源被线程持有，直到自愿释放，不能被强制剥夺。循环等待条件: 发生在一组线程中，每个线程都在等待下一个线程所持有的资源。 解决方法: 避免嵌套锁，使用定时锁（尝试锁），或者以一致的顺序获取锁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/817b043e4c37e10e8248dac4d97648b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/168200d83ea3605cbae88c67b66c4092/" rel="bookmark">
			jdk17安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 也许是太久没有新建java项目了，官网新建spring项目最低到17了，吃惊…
最近正好项目需要，就安装下，顺便记录下，与诸君共勉！抱拳~
参考文章
JDK17的下载安装与配置(详细教程)
文件下载地址
jdk17-windows官网下载地址
选择适合自己的版本下载就好了，我是windows版本的，附上我安装的文件百度网盘地址:
链接：https://pan.baidu.com/s/11uoVFhzDsBx72HStDm4stA 提取码：s9tn
安装 将文件移动到自己指定的位置，双击一步一步操作就好了。
需要注意的是这个地址最好改成其他盘。并且要记住自己把软件安装哪里了，接下来系统环境配置需要!
环境变量配置 打开我的电脑-&gt;点击属性-&gt;找到高级系统设置-&gt;点击环境变量。
安装地址就是上一步说的需要记住的位置
为了兼容原先的项目jdk8，可能需要JDK版本来回切换，这边做个操作，分别 新建 两个 系统变量
修改JAVA_HOME配置值，指向JDK17
此外，如果你之前没有安装过JDK的话，还需要配置 CLASSPATH 和 Path 等，具体可参考上文说的参考文章，这里就不再说明。
校验是否安装JDK17成功 快捷键 Win+R 输入 cmd ，输入指令：java -version，如果是以下结果表示成功:
最后，如果文章对你有帮助的话，顺手点个赞吧！嘿嘿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85f34067915e4a4702a57aa4c0866006/" rel="bookmark">
			【理工科会议\EI稳定收录】2024年智能控制与计算机工程国际会议（ICICCE 2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【理工科会议\EI稳定收录】2024年智能控制与计算机工程国际会议（ICICCE 2024） 2024 International Conference on Intelligent Control and Computer Engineering
2024年智能控制与计算机工程国际会议（ICICCE 2024）旨在为从事智能控制和计算机工程领域工作的行业、学术界和政府的研究人员、从业者和专业人士提供一个交流平台，讨论相关领域的研究、开发和专业实践。 会议主题: (主题包括但不限于, 更多主题请咨询会务组苏老师)
光学/电子/磁性材料
仪器仪表与传感器
材料物理与化学
表面工程/涂层
无人系统
控制理论与控制工程
电力系统及其自动化
检测技术与自动化装置
嵌入式控制
振动、噪声分析和控制
导航、制导与控制
模式识别与智能系统
系统工程
先进材料表征技术
机电系统检测与控制
计算机与电路设计
计算机工程设计
计算机程序设计
微处理器
嵌入式系统
软件工程
计算机视觉与虚拟现实
多媒体与人机交互
控制系统
—————————————————————————————————
投稿邮箱：study_conf@163.com
（投稿时请在邮件附言:“论文投稿+苏老师推荐”。以便安排审稿，以及文章见刊检索通知，后续增值税普票（专票）、论文集寄送等）
—————————————————————————————————
投稿须知（先投稿，先审核，先提交，先出版检索）
1. 文章需全英文，重复率低于30%。
2. 文章必须要有题目、作者、单位、邮箱、关键词、摘要、必要的图表、结论、参考文献等。
3. 投稿流程：投稿→审稿→录用→注册→开具增值税普票（专票）→电子版→纸质版→检索。
4. 请勿一稿多投，所有稿件将接受两三名专家进行评审
5. 审稿周期根据审稿老师的时间略有不同，审稿时间一般为：3天左右。
【如已投稿官网邮箱，请联系下方会务组老师，并告知会议负责老师查收，谢谢】
—————————————————————————————————
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfe8877980e31e923283deed2710b6f1/" rel="bookmark">
			CSS 04篇——关于position、overflow、text-overflow、-webkit-line-clamp等属性的使用（包括CSS元素内容溢出处理等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS 04篇——关于position、overflow、text-overflow、-webkit-line-clamp等属性的使用（包括CSS元素内容溢出处理等） 1. 前言——CSS其他2. 关于float属性3. 关于position属性3.1 position属性简介3.2 简单例子3.2.1 fixed使用3.2.2 relative + absolute 5. 关于元素溢出 和 内容限制行数5.1 关于overflow5.1.1 先简单介绍CSS的简写属性5.1.2 简单介绍overflow5.1.3 overflow常见属性值及效果 5.2 关于white-space5.3 关于text-overflow5.3.1 简单介绍text-overflow5.3.2 简单应用text-overflow（搭配white-space 与 overflow） 5.4 关于-webkit-line-clamp5.5 关于内容溢出的例子5.5.1 给div加滚动条（overflow属性——overflow的应用）5.5.2 控制 块级元素 内容显示（overflow + text-overflow + white-space）5.5.3 控制table中td文字溢出显示字数（overflow + text-overflow）5.5.4 控制行内元素内容溢出显示“…“（使用-webkit-line-clamp） 6. 关于display属性6.1 更多参考6.2 例子1——div成为行内6.3 例子2——横排div高度不一致 1. 前言——CSS其他 关于CSS的上几篇文章，如下： 关于CSS的几种字体悬浮的设置方法.
CSS解决div行变块 ➕ CSS解决“table中的td文字溢出控制显示字数，显示省略号”的问题.
CSS画圆以及CSS实现动态圆.
2. 关于float属性 float CSS 属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动（文档流）中移除，但是仍然保持部分的流动性（与绝对定位相反）。简单使用，如下：&lt;style&gt; .div_float{ background-color: green; width: 150px; height: 150px; float: right; } &lt;/style&gt; 关于float更多内容请看：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfe8877980e31e923283deed2710b6f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e51bdd4667f96a0ba3ad51f25a96bd0/" rel="bookmark">
			uniapp中uview组件库丰富LoadingPage 加载页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本使用
#显示或隐藏
#文字内容
#动画模式
#动画图片
#文字颜色
#文字大小
#图标大小 2.0.32
#背景颜色
#图标颜色
API
#Props
基本使用 &lt;template&gt; &lt;view&gt; &lt;u-loading-page&gt;&lt;/u-loading-page&gt; &lt;/view&gt; &lt;/template&gt; #显示或隐藏 loading可以指定是否显示加载页
&lt;u-loading-page :loading="true"&gt;&lt;/u-loading-page&gt; #文字内容 loading-text可以指定提示内容
&lt;u-loading-page loading-text="loading..."&gt;&lt;/u-loading-page&gt; #动画模式 loading-mode可以指定加载动画的模式, 默认为circle
&lt;u-loading-page loading-mode="spinner"&gt;&lt;/u-loading-page&gt; &lt;u-loading-page loading-mode="semicircle"&gt;&lt;/u-loading-page&gt; #动画图片 image可以指定文字上方用于替换loading动画的图片
&lt;u-loading-page image="/static/logo.png"&gt;&lt;/u-loading-page&gt; #文字颜色 color可以指定文字颜色
&lt;u-loading-page color="#666"&gt;&lt;/u-loading-page&gt; #文字大小 font-size可以指定文字大小
&lt;u-loading-page font-size="24"&gt;&lt;/u-loading-page&gt; #图标大小 2.0.32 icon-size可以指定图标大小
&lt;u-loading-page icon-size="36"&gt;&lt;/u-loading-page&gt; #背景颜色 bg-color可以指定背景颜色
&lt;u-loading-page bg-color="#e8e8e8"&gt;&lt;/u-loading-page&gt; #图标颜色 loading-color可以指定加载中图标的颜色
&lt;u-loading-page loading-color="#000000"&gt;&lt;/u-loading-page&gt; API #Props 参数说明类型默认值可选值loadingText提示内容String | Number正在加载-image文字上方用于替换loading动画的图片String--loadingMode加载动画的模式Stringcirclespinner \ semicircleloading是否加载中booleanfalsetruebgColor背景颜色String#ffffff-color文字颜色String#C8C8C8-fontSize文字大小String | Number19-iconSize 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e51bdd4667f96a0ba3ad51f25a96bd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddceea4a623a25f7d8a22358c38b0091/" rel="bookmark">
			【微信公众号开发】前后端配置获取当前用户的openId
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单来说，在微信里访问公众号时，首先在前端授权获取到code，然后通过code传递到公众号第三方应用后台，加上私密的appid，访问微信开放平台接口，这样就可以获取到openid等用户信息。
一、环境配置 1.1 测试环境： 地址：微信公众平台-测试号管理
1.1.1、测试号信息：appId和appsecret 这是每个公众号独立的id信息 1.1.2、JS接口安全域名配置 1.1.3、关注测试号 1.2、正式环境： 五、参考： 接口权限说明 | 微信开放文档
网站应用微信登录开发指南 | 微信开放文档
微信公众号页面获取code进行微信授权登录 - 简书
手把手教你学会微信公众号活动H5开发（附服务端代码） - 知乎
小白专用微信公众号网页授权通过code获取用户信息_微信公众号获取code-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9398b8a7fec977bf805988c099c7758/" rel="bookmark">
			Map集合原理的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：Map是什么？ map是一个集合，一个键（key）和它对应的值构成map集合中的一个元素。Map中的元素是两个对象，一个对象作为键，一个对象作为值。键不可以重复，但是值可以重复。
二：HashMap 三：HashMap底层机制及源码分析 HashMap底层维护了Node类型的数组table，默认为null；当创建对象时，将加载因子（loadfactor）初始化为0.75；当添加key-val时，第一次添加，则需要扩容table容量为16，临界值为12（16*0.75）通过key的哈希值得到在table的索引，然后判断该索引处是否有元素，如果没有元素则直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，则直接替换val，如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时候发现容量不够，则需要扩容；以后再扩容，则需要扩容table容量为原来的的2倍（32），临界值为原来的2倍，即24，以此类推；在Java 8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD(默认是8)，并且table的大小 &gt;= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化（红黑树）。 四：手写hashMap框架 public interface ExtMap&lt;K, V&gt; { // 向集合中插入数据 public V put(K k, V v); // 根据k 从Map集合中查询元素 public V get(K k); // 获取集合元素个数 public int size(); // Entry的作用=== Node节点 interface Entry&lt;K, V&gt; { K getKey(); V getValue(); V setValue(V value); } } public class ExtHashMap&lt;K, V&gt; implements ExtMap&lt;K, V&gt; { // 1.定义table 存放HasMap 数组元素 默认是没有初始化容器 懒加载 Node&lt;K, V&gt;[] table = null; // 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9398b8a7fec977bf805988c099c7758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e845312070ddb01cb699106e38549464/" rel="bookmark">
			vue生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 vue生命周期 二、activated + deactivated 除此之外，简单介绍一下在被keep-alive包含的组件/路由中，会多出两个生命周期的钩子:activated 与 deactivated。在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 树内的所有嵌套组件中触发。
activated在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用。
activated调用时机：第一次进入缓存路由/组件，在mounted后面，beforeRouteEnter守卫传给 next 的回调函数之前调用：
beforeMount=&gt;
如果你是从别的路由/组件进来(组件销毁destroyed/或离开缓存deactivated)=&gt;mounted=&gt; activated
进入缓存组件 =&gt; 执行 beforeRouteEnter回调 因为组件被缓存了，再次进入缓存路由/组件时，不会触发这些钩子：//
beforeCreate created beforeMount mounted 都不会触发。
deactivated
deactivated调用时机：组件被停用(离开路由)时调用
使用了keep-alive就不会调用beforeDestroy(组件销毁前钩子)和destroyed(组件销毁)，因为组件没被销毁，被缓存起来了。
这个钩子可以看作beforeDestroy的替代，如果你缓存了组件，要在组件销毁的的时候做一些事情，你可以放在这个钩子里。
如果你离开了路由，会依次触发：
组件内的离开当前路由钩子beforeRouteLeave =&gt; 路由前置守卫 beforeEach =&gt;全局后置钩子afterEach =&gt;
deactivated 离开缓存组件 =&gt; activated 进入缓存组件(如果你进入的也是缓存路由
原文链接：https://blog.csdn.net/cnailili/article/details/119038528
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56b66c9b80f3bfff24f4444a00414d48/" rel="bookmark">
			5G-A关键技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近结束 3GPP Release 18 标志着 5G Advanced 的引入。5G Advanced 功能将提升5G网络性能并加强对XR、室内定位和非地面网络等服务的支持。
本文提供 Release 18 最重要的功能和 Release 19 的概述，并解释移动网络标准如何演进以支持高性能的无线接入、差异化的服务、网络自动化和网络节能。
2023年12月11日至15日举行的3GPP全会标志着3GPP成立25周年，也是3GPP的又一个重要里程碑！
作为一个标准组织，3GPP在过去二十五年里提供了世界领先的移动宽带标准，从而建立了规模增长最快的全球技术生态系统。
这次会议结束了 Release 18，5G Advanced 的第一个版本，并批准了 Release 19 的主要范围，确定了 5G Advanced 的未来方向。
作为 5G Advanced 的延续，Release 19 将主要侧重于提高性能并满足5G商用部署中的关键需求。预测 5G Advanced 将在这十年中继续在3GPP发展，如图所示，预计从2025年开始的6G标准化将在 Release 20 和 Release 21 中加速。
3GPP的 5G Advanced 和6G时间表
5G Advanced演进
5G Advanced 将增强网络性能，并增加对新应用和用例的支持。本文重点介绍了3GPP Release 18 和 Release 19 将如何实现更高性能无线接入网络和新功能，使通信服务提供商能够实现其服务产品的差异化。另外，本文也将分享最新的标准演进如何支持自动化和可持续网络。
多输入多输出(MIMO)
先进的天线系统和大规模MIMO是5G的基石。
Release 18 引入了几方面的优化：
上行链路和下行链路的系统容量进一步提升，主要是通过5G新空口（NR）多用户MIMO的改进。多用户MIMO是一种允许两个或多个UE使用相同时间和频率资源的技术，因此可以在这些相同的资源上调度更多 UE。
通过实现分布式发射机之间的协调操作，可以提高信号质量。这是迈向完全分布式MIMO（D-MIMO） 系统的重要一步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56b66c9b80f3bfff24f4444a00414d48/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/46/">«</a>
	<span class="pagination__item pagination__item--current">47/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/48/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>