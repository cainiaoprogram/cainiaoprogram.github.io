<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6229a01b26fd6b73b6d8b933bdf9d55/" rel="bookmark">
			ZED-F9K使用：录制数据&#43;地图查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZED-F9K使用：行车录制数据+地图查看 ZED-F9K设备安装、天线安装、标定设备准备天线准备 F9K配置和标定 ZED-F9K配套软件UCenter录制和回放数据添加地图和矫正地图坐标 测试数据展示 F9K是u-blox公司提供的一个高精定位+惯导组合模块，是一个针对车道级定位的产品。虽然在公司的实际场景测试中会发现F9K需要在GPS天线信号强（开阔场景）、RTK信号稳定、配置完好等情况下才勉强达到车规级，也就是说最终的L3自动驾驶还得依靠其他传感器，一个F9K定位模块是不够的。但是它优点在于价格不高，适用量产车。 ZED-F9K设备安装、天线安装、标定 设备准备 首先要准备一个F9K板。这个不多说了——F9K模块需要固定在车内，后期还需要根据板子和天线、车辆前后轴中心的定位参数来标定。
天线准备 使用蘑菇头的GPS-500天线就可以。无须多说，天线为F9K提供卫星定位信号。
蘑菇头外天线只能提供GNSS信号，如果需要更高精度的差分RTK，则要加外部联网设备和一个RTK服务账号。联网设备可以选择DTU、TBOX，可以自己手机开热点给PC，在UCenter里配置NTRIP client。
F9K配置和标定 F9K的标定需要：配置好F9K内通道、测量好杆壁值（也就是F9K设备到天线和车辆前后轴中心的距离等），确认RTK数据接入，确认轮速信号接入。
F9K内通道是根据自己需要接入的数据来配置的，可以自定义打开需要的报文。
标定在上述准备完成后，打开标定模式，进行IMU动态校准，让车辆跑8字+直线行驶，FINE之后记录YAW/Pitch/Roll。（详细操作可询问UBX的技术支持）
标定后记录的数据轨迹会是黄色的3D+DR状态。
ZED-F9K配套软件UCenter F9K支持通过串口输入输出，UCenter就是配套的串口数据查看和更改软件。官网支持下载，也有非常齐全的用户手册使用资料。
录制和回放数据 UCenter支持测试数据的录制和回放，根据录制数据的需要可以打开相应串口，参考用户手册。
在行车过程中，点击工具栏上的红色按钮，选择报存的文件夹，即可开始。后续回放，OPEN打开先前录制的文件即可，在录制过程前打开的串口，和过程中一样，都可以在回放过程里读到数据。
添加地图和矫正地图坐标 工具栏上有一个地图的图标，点击之后，在下方空白处右键——打开open map，可以插入png格式的图片。这种图片可以在很多平台上截取，我截取的是奥维地图（omap）软件里的腾讯地图遥感影像。
截取的影像图片，在导入UCenter的MAP中，会提示缺少坐标。需要选择三个点输入经纬度（WGS84坐标系）进行坐标系矫正。在奥维地图上截取的时候，是可以看到插入点坐标的，但是奥维地图里的图层是腾讯地图（GCJ坐标系），需要进行一下坐标转换。网上有很多在线工具支持，转三个点就行。
测试数据展示 下面这组轨迹是前几天分析天线信号强度的时候去公司附近高架桥下采集的，遥感图最初是想拿来看效果，结果发现由于地图精度很差压根看不出来什么效果……真的很想吐槽国内打着名义上的地图安全理由不开放谷歌。
测试数据只使用了GPS-500的天线，遮蔽场景+没有进行差分定位——因此精度只有米级，加上地图使用的是从omap奥维地图里截取的静态腾讯地图（现在谷歌地图需要翻墙才能获得），清晰度不是很好，也做不了更多的定位精度分析，但是看着玩还是OK的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/755985676eef48fb0861ca0380899639/" rel="bookmark">
			golang学习笔记（18）-gin对于文件的接收以及返回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gin对于文件的接收以及返回 目录 gin对于文件的接收以及返回接收文件接收文件的方法分析给前端返回文件多文件上传 接收文件 先根据官方文档，编写一个实现接收文件方法
func main() { r := gin.Default() r.POST("/testLoad", func(c *gin.Context) { file, _ := c.FormFile("file") c.SaveUploadedFile(file, "./tmp/"+file.Filename) c.JSON(200, gin.H{ "msg": file, }) }) r.Run() } 实验结果
完成前端传送文件并下载
接收文件的方法分析 FormFile方法用于获取表单信息中file格式的参数。并且返回一个文件流。
SaveUploadedFile方法提供两个参数。参数1为指定需要保存操作的文件，参数2为指定保存路径。
其函数构造为
func (c *Context) SaveUploadedFile(file *multipart.FileHeader, dst string) error { src, err := file.Open() if err != nil { return err } defer src.Close() out, err := os.Create(dst) if err != nil { return err } defer out.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/755985676eef48fb0861ca0380899639/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3414c5f975ddc4078f127e3bdac4a4f2/" rel="bookmark">
			强大且超实用的论文阅读工具——ReadPaper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近突然发现了一款超好用的论文阅读工具 ReadPaper，简直是科研人的福音，在这里推荐给大家。
目录 0 官网与下载1 看论文1.1 找论文1.2 读论文1.2.1 翻译1.2.2 看论文过程中忘记该论文发表的年份和期刊/会议1.2.3 段落和图表不在一页，要来回上下翻 1.3 记笔记1.4 查阅参考文献1.5 文献归档 2 理解论文参考 对于每个科研工作者而言，阅读论文就像吃饭喝水一样同款重要的事情。在我看来，阅读论文是分为两个步骤：1) 看论文；2) 理解论文。而大部分的人看论文都十分吃力，尤其是刚刚尝试入门的同学，就更别提理解论文了。所以一个好的论文阅读工具能够让你在科研路上事半功倍。我这几天就发现了一款优秀的，强大的，实用的论文阅读工具，ReadPaper，我希望这篇博客能够让你关注到这个工具，让你更快速的进入科研道路。当然，我这篇博客不是一篇说明文档，而是我从刚刚提到的两个步骤来说明该工具优秀且实用的地方。
0 官网与下载 官网： https://readpaper.com/下载链接： https://readpaper.com/download平板： 可以在应用商城中搜索 ReadPaper。重点： 免费的，免费的，免费的 1 看论文 看论文过程中的难点我一共梳理为以下几个：找论文，读论文，记笔记，搜参考文献，文献归档，并在下面的内容里面以此梳理 ReadPaper 在这几点上很方便的地方。
1.1 找论文 对于初学者而言，找论文会涉及到两个很关键的问题：1）我不知道该读什么论文；2) 我不知道这个论文好不好。
而 ReadPaper 在这点上做得很好的就是检索系统很强大，并且可以有多种查询条件，比如检索作者名，年份，引用量等。
同时，ReadPaper 还很贴心的给了是否有 PDF，以及 CCF 评分，可以快速了解这篇论文能否直接下载 PDF，以及会议级别。
最重要的是，这是我国的检索系统，所以检索速度巨快无比。
1.2 读论文 1.2.1 翻译 对于大部分人而言，翻译一直是一个很大的问题。许多同学（比如我）都是遇到不懂的词语或者句子，复制下来再粘贴到另一个网页中进行翻译。同时我用的是 Adobe 的 PDF 阅读器，所以粘贴过去还要自己回车，就很麻烦。
而 ReadPaper 在这一点上做的就十分贴心，支持划词翻译，同时还有 有道，腾讯 和 谷歌 翻译引擎，可以随时切换。并且不用担心每次都要切换自己喜欢的翻译引擎，系统会自动记录你上次使用的翻译引擎。
1.2.2 看论文过程中忘记该论文发表的年份和期刊/会议 许多同学，尤其是面对一篇不熟悉的论文，很容易看着看着就忘记这篇论文是哪一年的，出自哪里，等级怎样，然后就要翻回首页找信息，看完后又忘记之前看到哪里了。
而 ReadPaper 可以直接在右侧 资料 栏中一下就找到所有的信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3414c5f975ddc4078f127e3bdac4a4f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2712a3353ff7056d327d27f9cd0b33ba/" rel="bookmark">
			golang学习笔记（17）-gin模型绑定和验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gin模型绑定和验证 目录 gin模型绑定和验证bind方法官方介绍Shouldbind的使用官方使用bind的示例个人使用bind实验示例 绑定器binding自定义验证器 bind方法官方介绍 若要将请求主体绑定到结构体中，请使用模型绑定，目前支持JSON、XML、YAML和标准表单值(foo=bar&amp;boo=baz)的绑定。
Gin使用 go-playground/validator.v8 验证参数，查看完整文档。
需要在绑定的字段上设置tag，比如，绑定格式为json，需要这样设置 json:“fieldname” 。
此外，Gin还提供了两套绑定方法：
Must bind
1.Methods - Bind, BindJSON, BindXML, BindQuery, BindYAML
2.Behavior - 这些方法底层使用 MustBindWith，如果存在绑定错误，请求将被以下指令中止 c.AbortWithError(400, err).SetType(ErrorTypeBind)，响应状态代码会被设置为400，请求头Content-Type被设置为text/plain; charset=utf-8。注意，如果你试图在此之后设置响应代码，将会发出一个警告 [GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422，如果你希望更好地控制行为，请使用ShouldBind相关的方法
Should bind
1.Methods -ShouldBind, ShouldBindJSON, ShouldBindXML, ShouldBindQuery, ShouldBindYAML
2.Behavior - 这些方法底层使用 ShouldBindWith，如果存在绑定错误，则返回错误，开发人员可以正确处理请求和错误。
当我们使用绑定方法时，Gin会根据Content-Type推断出使用哪种绑定器，如果你确定你绑定的是什么，你可以使用MustBindWith或者BindingWith。
你还可以给字段指定特定规则的修饰符，如果一个字段用binding:"required"修饰，并且在绑定时该字段的值为空，那么将返回一个错误。
官方文档解释mustbind方法在出现错误后会响应400，并且自动处理，推荐人们使用should bind。所以后续实验主要围绕should bind经行实验
Shouldbind的使用 在使用bind时，必须在结构体字段后添加tag，例如：
type Login struct { User string `form:"user" json:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2712a3353ff7056d327d27f9cd0b33ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd6e15b1d48e194a7996956fc8af635e/" rel="bookmark">
			80027efe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微软更新了签名算法，从 2019 年开始，开始弃用SHA-1，逐步改为SHA-2加密算法。
导致windows upate更新报80072EFE错误。此方法同样适用于Windows 7系统。
建议手动下载安装编号为KB4474419补丁。
补丁下载地址Microsoft Update Catalog搜索补丁编号。
此补丁同样可以解决windows server 2008 R2 SP1安装驱动程序报错的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16be5cb73ec1510eafdf267ea4416293/" rel="bookmark">
			win10防火墙怎么关闭端口？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道win10系统自带防火墙功能，如果用户使用的是公用网络，防火墙就会提醒各种问题。有很多用户使用完端口想要关闭，但是不知道如何关闭。下面小编就给大家讲讲如何关闭防火墙端口的方法。
若要关闭Microsoft Defender防火墙中的端口，请使用以下步骤：
1、打开Windows安全。
2、点击防火墙和网络保护。
3、单击高级设置选项。
4、根据您打开防火墙端口的位置，单击左侧导航窗格中的入站规则或出站规则。
5、选择所需的规则。
6、在“操作”部分下，单击禁用规则以在保留规则的同时关闭端口。或者单击删除规则选项以关闭端口并从防火墙中删除规则。
完成这些步骤后，应用程序或服务将无法再访问网络或Internet。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04fdd49d69cd850830e2b559a301a51b/" rel="bookmark">
			ENSP演示：配置LACP模式的链路聚合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、LACP模式链路聚合简介
以太网链路聚合是指将多条以太网物理链路捆绑在一起成为一条逻辑链路，从而实现增加链路带宽的目的。链路聚合分为手工模式和LACP模式。
LACP模式需要有链路聚合控制协议LACP的参与。当需要在两个直连设备间提供一个较大的链路带宽而设备支持LACP协议时，建议使用LACP模式。LACP模式不仅可以实现增加带宽、提高可靠性、负载分担的目的，而且可以提高Eth-Trunk的容错性、提供备份功能。
LACP模式下，部分链路是活动链路，所有活动链路均参与数据转发。如果某条活动链路故障，链路聚合组自动在非活动链路中选择一条链路作为活动链路，参与数据转发的链路数目不变。
二、配置注意事项
1、一个Eth-Trunk接口中的成员接口必须是以太网类型和速率相同的接口。
2、Eth-Trunk链路两端相连的物理接口的数量、速率、双工方式、流控配置必须一致。
3、如果本端设备接口加入了Eth-Trunk，与该接口直连的对端接口也必须加入Eth-Trunk，两端才能正常通信。
4、两台设备对接时需要保证两端设备上链路聚合的模式一致。
如图所示：SW1和SW2通过以太网连接，希望Sw1和Sw2之间能够提供较大的链路带宽来使相同VLAN间互相通信
优点：
两条活动链路具有负载分担的能力。
两设备间的链路具有1条冗余备份链路，当活动链路出现故障时，备份链路 替代故障链路，保持数据传输的可靠性。
同VLAN间可以相互通信。
思路：
1.创建Eth-Trunk，配置Eth-Trunk为LACP模式，实现链路聚合功能。
2.将成员接口加入Eth-Trunk。
3.配置系统优先级，确定主动端，按照主动端设备的接口选择活动接口。
4.配置活动接口上限阈值，实现保证带宽的情况下提高网络的可靠性。
5.配置接口优先级，确定活动链路接口，优先级高的接口将被选作活动接口。
6.创建VLAN并将接口加入VLAN。
三、操作步骤
1、在Sw1上创建Eth-Trunk1并配置为LACP模式。Sw2的配置与SW1类似，不再赘述
[HUAWEI] sysname SwitchA [SW1] interface eth-trunk 1 //创建ID为1的Eth-Trunk接口 [SW1-Eth-Trunk1] mode lacp //配置链路聚合模式为LACP模式 [SW1-Eth-Trunk1] quit 2、配置SW1上的成员接口加入Eth-Trunk1。SW2的配置与SW1类似，不再赘述
[SW1] interface gigabitethernet 0/0/1 [SW1-GigabitEthernet0/0/1] eth-trunk 1 //将GE0/0/1接口加入Eth-Trunk1中 [SW1-GigabitEthernet0/0/1] quit [SW1] interface gigabitethernet 0/0/2 [SW1-GigabitEthernet0/0/2] eth-trunk 1 //将GE0/0/2接口加入Eth-Trunk1中 [SW1-GigabitEthernet0/0/2] quit [SW1] interface gigabitethernet 0/0/3 [SW1-GigabitEthernet0/0/3] eth-trunk 1 //将GE0/0/3接口加入Eth-Trunk1中 [SW1-GigabitEthernet0/0/3] quit 3、在SW1上配置系统优先级为100，使其成为LACP主动端
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04fdd49d69cd850830e2b559a301a51b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16d9b511c087372653f1e9ff5b2e6001/" rel="bookmark">
			【超详教程】终极版Python打包exe文件，并修改图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前看很多人都在问，Python怎么打包exe可执行文件，雀氏有点多，那么我来了，给大家整一个Python打包exe可执行文件的究极教程！
当然，顺便再给它换个图标。
首先把你的代码准备好，尽量不要中文路径，容易报错。
这个是要用的模块
Pyinstaller
它不是Python默认有的模块，所以需要我们安装一下，直接 pip install Pyinstaller
模块安装好后我们开始打包，注意，所有的文件都尽量用英文，免得报错了。
首先我们在CMD里面把目录切换到你的代码存放的那个盘，比如我的是放在C盘，输入C: ，当然，我这里已经在C盘了所以不用切换。
然后复制你代码所在的文件地址
最快的是直接全部复制上，如果你要是觉得太多了不好看的话，就看你cmd的目录当前显示在哪里，我这里已经在Administrator 了所以我可以只要后面的目录也可以。
在cmd输入cd再按一下空格，把文件目录输入进去，这样就成功切换到了你想要的目录。
然后重点来了，现在就可以开始打包了，输入神秘代码 pyinstaller -F -w -i aaa.ico zzz.py
简单的介绍下这些代码都是什么意思
1、pyinstaller (这个是打包exe文件使用的模块)
2、-F （这个是生成exe文件的，F一定要用大写，不然就会失败，所以必须要）
3、-w （这个的话小写也可以，主要是解决打包后，运行文件会有黑框框闪过，建议是加上）
4、-i（这个是用于替换你的图标，把文件图标替换成你想要的样子，可加可不加）
5、aaa.ico (这个是你准备好要替换的图标名字+格式，切记用英文，两三个最好，别用单个的字母，有些字母会导致不成功)
6、zzz.py（这个是你的代码文件名字，放在最后）
如果你要替换图标的话，首先你要准备一个 32*32 像素的图片文件，你用美女也好，用帅哥也好都随你。
这个格式的话，给你们介绍一种最简单的方法——百度 jpg在线转ico，第一个就是。
这就不用我介绍怎么操作了吧，巨简单，最后转换成功后点一下输出文件名，它会弹出新的窗口，另存为就好了，把它下载后跟你的代码放到一个目录下。
OK，前戏到这里就差不多完成了，按回车， 开始打包 。
exe可执行文件在这个dist文件夹里
看，完美的改成想要的图标了。
兄弟们，一行代码就搞定了，兄弟们快去试试吧~
如果不改图标，那就是半分钟的事情。当然加上改图标，也就多了半分钟。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67cd6c3496788e8c35acb12857a3ee35/" rel="bookmark">
			Latex工具（texlive&#43;texstudio）的详细安装及基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 LA TEX 是一个文档准备系统 (Document Preparing System) ，它非常适用于生成高印刷质量的科技类和数学类文档。它也能够生成所有其他种类的文档，小到简单的信件，大到完整的书籍。 使用这个工具首先就是安装软件了，接下来给大家介绍软件的安装。 安装LaTex，需要安装 两个东西：1，安装 TeX发行版，2，安装 LaTex编辑器。这两个软件就好比Python与pycharm。 texlive是必须要安装的latex环境，就像学习python需要安装pyton环境一样。在此还要说明一下，latex的环境并不是只有texlive，还有MikTeX。 两者区别：texlive占用空间大，包全；MikTeX占用空间小，但是包不全，本文介绍texlive的安装。 texstudio是编辑器，就像学习python要用到的pycharm，是比较官方的编辑器，但不是必需的，你也可以使用vscode，sublime等其他文本编辑器打开。 下载 若你知识想要体验latex可以使用一下在线编辑器：
在线LaTeX编辑器：https://www.overleaf.com
TeX Live下载： https://www.tug.org/texlive/acquire-iso.html
下载速度慢的推荐使用镜像：
适合境外用户，下载速度可以起飞：HK镜像适合境内用户，起码比境外镜像快：清华镜像列表，以及中科大镜像列表 MikTeX下载：https://miktex.org/download
LaTeX 公式编辑器：https://latex.codecogs.com/eqneditor/editor.php
一份不太简短的LaTeX介绍：https://github.com/CTeX-org/lshort-zh-cn
texstudio下载：TeXstudio - A LaTeX editor
texlive安装 若下载的exe文件直接双击，若是iso文件，打开其中的install-tl-advanced.bat文件安装。
按提示点击至一下界面，点击advanced
可以修改安装路径等参数
等待安装完毕所有包，需要一个小时左右
安装完成界面如下
在安装完之后，可以调用 terminal，分别输入
tex -v latex -v xelatex -v pdflatex -v 若出现版本信息表示安装成功，若出现错误将路径E:\texlive\2022\bin\win32添加到环境变量中。
texstudio安装 首先下载，网址在开头，下载后安装，比较简单，不再演示。
安装后需要一些配置，如下点击configure texstudio
在general中，语言可以设置为中文
在command中，将exe文件权不设置为texlive路径E:\texlive\2022\bin\win32下的exe文件 构建中，若写中文论文，修改为XelaTeX.；若为英文，则用PdfLaTex。
新建文件即可使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1e291fed3ca4a770dcc93680d258370/" rel="bookmark">
			十几套JavaWeb项目，拿去当毕业设计简直太爽了（源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		军鑫爱编程的个人空间_哔哩哔哩_Bilibili 1、基于web的图书管理系统设计与实现 图书管理系统就是利用计算机，结合互联网对图书进行结构化、自动化管理的一种软件，来提高对图书的管理效率。本系统采用Java+Servlet+Jsp 的方式实现基于web的图书管理系统。
开发工具及相关技术
Java技术HTML、css、javascript技术Servlet技术Eclipse开发工具MySql数据库 功能概述
用户端：
图书查询：根据图书编号、图书名称查询图书信息，可查询图书的编号、名称、分类、作者、价格、在馆数量等。借阅信息：可查询图书的基本信息、借阅日期、截止还书日期、超期天数等。借阅历史：查询自己以往的借阅历史，包括哪些图书等具体信息。我的：查看个人资料，修改账户密码，退出系统。 管理员端：
图书管理：根据图书编号、图书名称查询图书基本信息，添加、修改、删除图书。图书分类管理：根据分类名称查询图书分类信息，添加、修改、删除图书分类。图书借阅：展示所有正在借阅图书的信息。图书归还：展示所有已归还图书的信息。公告管理：向用户发布公告。读者管理：根据账号、姓名查询读者基本信息，添加、修改、删除读者信息。我的：查看个人资料，修改账户密码，退出系统。 2、JavaWeb宿舍管理系统 宿舍管理是高校管理的重要组成部分，一套优秀的管理系统不仅可以降低宿舍管理的难度，也能在一定程度上减少学校管理费用的支出，能是建设现代化高校管理体系的重要标志。本篇文章将带你从运行环境搭建、系统设计、系统编码到整个系统的实现，对整个过程进行详细描述，特别适合作为程序员的进阶项目案列，同样也是高校学生毕业设计系统实现的不二之选！
技术选型
选择合适的技术，整个项目就已经成功了一半，经过对系统需求和系统自身特点的分析，加上现代B/S模式主流架构解决方案，对本系统技术选型如下：
数据表现层： Html+JavaScript+CSS+VUE业务逻辑层 Java+Spring+SpringMVC数据持久层： MySql+MyBatis开发工具： Eclipse 用户分析
本系统主要应用于高校宿舍管理，使用人群如下：
系统管理员：管理整个系统的安全运行，各个功能使用。宿舍管理员：管理自己负责的宿管和学生学生：查看浏览信息，提交任务 3、基于web的机票管理系统设计与实现（一） 本系统使用Eclipse开发工具，使用Redis、MySQL数据库，采用MVC三层架构的方式，结合当前最流行的SSM框架以及支付宝沙箱支付环境来实现各个功能。系统分为用户端和管理员端。用户端实现了用户注册与登录、用户评论、机票查询，机票预订，订单查询、广告展示等功能。管理员端包括航班信息管理模块、订单信息管理模块、用户信息管理模块、留言评论管理模块、广告信息管理模块、个人信息管理模块等六大模块，具有开放体系结构的、易扩充的、易维护的、具有良好人机界面的优点。
经过充分的测试，测试数据均正确无误，各个模块运行良好。机票预订系统的推出，为乘客出行提供方便，便于机场工作人员对机票信息进行管理，提高了机场工作人员对机票管理的工作效率。
开发工具及技术
Java webSSM（Spring + SpringMVC + MyBatis）AngularJSMySQLRedisEclipse 系统功能分析
后台航班信息管理：主要是指添加航班信息，删除航班信息，查询航班信息和航班信息详细情况查看等。后台订单信息管理：后台订单信息管理主要包括订单列表，查询订单信息，订单信息的删除等。后台用户信息管理：主要指注册用户的展示与按条件查询注册用户。后台留言评论管理：主要指展示用户的留言信息和按留言日期、留言用户查找留言信息等。后台广告信息管理：主要指添加广告信息，删除广告信息，设置广告的有效性等。后台个人信息管理：主要指查看个人信息，修改个人信息。前台登录与注册管理：包括前台系统用户的注册于登录。前台首页信息展示：主要是指航班信息展示、航班信息查询、航班信息详情、登录用户信息展示、留言板和个人信息详情与修改等。前台订单页面：主要是订单内容的填写和订单详情。 前台订单支付：是指使用支付宝沙箱环境支付订单。 4、基于SSH框架的人力资源管理系统设计与实现 人力资源是企业的第一资源，如何有效地管理、利用和开发这一资源 ，是摆在每一位管理者面前必须重视的大事。人力资源管理工作可分为建立规章制度的基础性工作、基于标准操作流程的例行性工作、人力资源规划等战略性工作以及企业文化建设、职工职业生涯设计等开拓性工作。其中，大量的例行性工作往往占据了人力资源管理工作人员的大部分时间。如果能建立起人力资源管理信息系统，把这部分工作分离出来，用计算机来进行管理，必将能大大提高人力资源管理人员的工作效率。同时，利用人力资源管理信息系统中存储的大量历史信息，建立起企业人力资源决策支持系统，可为领导决策提供有用的参考信息。
技术选型
Spring+SpringMVC+ Hibernate+ MySql
运行环境
Java1.8 + MySql + Eclipse
功能概述
本系统主要有部门管理、员工管理、招聘管理、培训管理、奖罚管理、薪资管理、个人信息管理七大模块。部门管理：此模块可以查看所有部门的详细信息，如：部门名称，部门创建时间，部门人数。也可以对某个部门进行修改删除操作，除此以外，还可以添加部门。员工管理：员工管理模块有查看、修改、添加、删除员工信息的功能。招聘管理：本模块可以查看求职人员的具体信息，包括姓名、性别、应聘职位、工作经验等等，也可以对应聘人员进行删除、录用。培训管理：此模块用来发布企业的培训信息，如培训时间，培训地址，培训课程和培训人员等等。奖罚管理：记录企业员工的奖罚情况。薪资管理：管理企业员工薪资，有调整薪资，添加员工及薪资，删除员工及薪资等功能。个人信息管理：查看修改个人信息。 5、基于java的企业进销存管理系统设计与实现 销存管理系统是一个基于本地与网络的应用系统，它是一个面对当前的进销存管理工作基本还处于手工和半信息自动化处理状态而应运而生的一个基于本地与网络的一个完全信息自动化的系统，整个系统从符合操作简便、界面友好、灵活、实用、安全的要求出发，完成进货、销售、库存管理的全过程。本文所设计的企业进销存管理系统可以满足企业进货、销售和库存管理方面的需要。
运行环境
操作系统：Windows 10JDK环境：jdk1.8开发工具：Eclipse8.0数据库管理软件：My SQL 5.7 功能概述
基础资料：基础资料是每个系统都必须具备的功能，该模块用于管理企业进销存管理系统中的客户、商品和供应商信息，其功能主要是对这些基础信息进行添加、修改和删除进货管理：进货管理功能模块用于管理企业的进货采购业务，是进销存管理系统中不可缺少的重要组成部分，它主要负责为系统记录进货单及其退货信息，相应的进货商品会添加到库存管理中销售管理：销售管理功能模块用于管理企业的销售业务，商品销售是进销存管理中的重要环节之一，进货商品在入库之后就可以开始销售了库存管理：库存管理模块是企业进销存管理系统中的库存管理模块包括库存盘点和价格调整两个功能查询统计：查询统计模块是进销存管理系统中不可缺少的重要组成部分，它主要包括销售查询和商品查询系统管理：系统管理模块主要有更改密码、退出系统两个模块 6、基于SSM框架的JavaWeb通用权限管理系统 这是一个通用权限管理系统项目，基于SSM（Spring + Spring-MVC +Mybatis）框架开发，其SQL语句持久在Hibernate 中，对原生SQL的支持较好。制作该系统的初衷是用来帮助JavaWeb开发者或初学者学习、借鉴的需要。读者可以在这个 系统基础上引入其它技术或完全依赖本系统技术进行功能拓展，来开发实际应用需求的项目，免去了应用系统中对于“ 权限设计”这一部分的麻烦。
技术选型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1e291fed3ca4a770dcc93680d258370/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12319a9bfa95a6ddbf97daac37433c9/" rel="bookmark">
			【踩坑日记】IDEA2021启动项目报错“找不到符号”实则lombok不兼容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 前两天突发奇想把IDEA2018升级成了2021，然后启动一个项目的时候，报错swagger找不到符号，然后找了一大波各种方法，清缓存、mvn更新，都没用，折磨
原因分析 仔细看报错信息，发现在真正的报错信息前面还有两条“黄色感叹号警告”
// 第一条 You aren‘t using a compiler supported by lombok, so lombok will not work and has been disabled. // 第二条 field value processing of @ConfigurationProperty meta-date is not supported // 第三条 找不到符号 类...... 我是从下往上看的，先看到“找不到符号”，然后搜了一波，改了一波没用然后看第二条，发现 @ConfigurationProperty 注解没用，再往上看第一条，发现竟然报错lombok不支持所以其实是因为 lombok 没起作用，导致注解不起作用，导致利用注解引入的配置无用，最终导致找不到符号 解决 找到问题源头之后，火速解决，解决方式参考大佬的文章https://blog.csdn.net/wanniwa/article/details/109155143因为maven版本不敢乱改，所以选择在IDE里加了配置 -Djps.track.ap.dependencies=false 欢迎大佬指点！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66e361cd79d690c08da1bc83d4c9a43/" rel="bookmark">
			Git系列一：Git安装 git gui here和git bash here的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Git简介： Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。说白了就是代码版本的控制系统。
据个人实测，在写论文的时候，会有很多论文备份，很不方便，Git对Word也能形成版本控制。
与GitHub的区别： Git 是一个开源的分布式版本控制系统。
GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。
Git安装： 个人使用是在win上面安装并使用git的，安装包下载地址：Git for Windows，如果嫌官网慢的话，可以使用国内镜像：CNPM Binaries Mirror。安装过程比较简单，这里跳过。其他系统的安装方法见链接：Git 安装配置 | 菜鸟教程。
git gui here和git bash here的区别： 安装好之后，在桌面或者文件夹空白内右键出现如下图：
参考：Git 教程 | 菜鸟教程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/818d8a031c359c4d30f9bbf8191a2d32/" rel="bookmark">
			Rust 13: 命令行参数std::env::args()和标准输入std::io::stdin()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 命令行参数创建测试项目运行测试 标准输入输出标准输入标准输出 命令行参数 今天来简单说一说Rust中如何获取程序的入口参数，以及如何读取标准输入的问题。
创建测试项目 cargo new hello-cli 编辑src/main.rs，其中通过静态的std::env::args()函数调用得到程序的入口参数：
fn main() { use std::env::Args; let args: Args = std::env::args(); println!("{:?}", args); for arg in args { println!("{:?}", arg); } } 运行测试 可以看到，通过for arg in args遍历程序入口参数，第一个参数就是程序的路径。
标准输入输出 标准输入 调用std::io::stdin()得到的Stdin关联到程序的标准输入设备。
Stdin中read_line()方法，一次从标准输入读取一行内容，包括换行符。
Stdin中实现了Read trait中的read_to_string()方法。调用该方法会一直读到文件末尾（EOF）才结束。
要在CLI命令行输入EOF，Windows系统是CTRL+Z，Linux是CTRL+D。
标准输出 可通过println!宏，将格式化后的字符串输出到标准输出设备。
// 调用标准输入读取输入信息 use std::io::Read; use std::io::Stdin; let mut buf = String::new(); let std_in: Stdin = std::io::stdin(); while std_in.read_line(&amp;mut buf).is_ok() { if "exit\r\n" == buf { println!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/818d8a031c359c4d30f9bbf8191a2d32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/014e2dad52e171eec060ba5cf3d019a5/" rel="bookmark">
			小程序 二级联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //column字段传2 就两列。传3就三列 //https://developers.weixin.qq.com/s/I7ZkCwmX7kyi 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03d18255b187646137030d9fc8a1f87f/" rel="bookmark">
			Idea热部署插件JRebel的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景
一般更新了 Java 文件后要手动重启整个项目，才能生效，这很影响开发速度，于是热部署就出现了。
热部署就是正在运行状态的应用，修改了他的源码之后，在不重新启动的情况下能够把修改内容编译并部署到服务器上，使得修改立即生效。
使用JRebel后，可以不用重启便可将修改的代码有效，非常的高效。
2、下载安装
Idea下安装JRebel插件
File -&gt; Settings -&gt; Plugins 中搜索JRebel,安装插件,
下载完成后重启Idea，来到引导页面
3、激活(由于是付费软件，所以这里需要激活)
激活前需要准备：GUID + 邮箱
这里给出一个在线生成GUID地址： https://www.guidgen.com/
如图界面拿到生成的一个 GUID ，并且准备好自己的邮箱(虚假邮箱也可，不校验)，然后即可进入激活页面激活。
点击 Jrabel Activation 进入激活
地址格式是https://jrebel.qekang.com/GUID，其中的GUID是上述给出地址生成的
点击激活完成后跳转到jrebel快速开始官网
到此激活成功。
4、其他配置
File -&gt; Settings -&gt; Jrebel&amp;Xrebel 设置 Jrebel 离线工作，并且部署时间设置为1s
参考文章
参考文章
参考文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0392d78512e8ba2c4cdd3d119b218cc7/" rel="bookmark">
			地理分析方法论|地理探测器（Geo Detector）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1相关理论
1.1地理探测器概念
1.2地理探测器原理
1.2.1分异及因子探测
1.2.2交互作用探测
​1.2.3风险区探测
1.2.4生态探测
1.3地理探测器主流应用
2相关操作（Excel版本）
2.1地图转为表格
2.2地理探测器运行
2.3结果分析
2.3.1因子探测结果分析
2.3.2交互作用探测结果分析
2.3.3生态探测结果分析
2.3.4风险区探测结果分析
1相关理论 地理探测器是由中国科学院地理科学与资源研究所王劲峰研究员团队在《Geographical Detectors-Based Health Risk Assessment and its Application in the Neural Tube Defects Study of the Heshun Region, China》一文中首次提出，解决了中国山西省和顺县新生儿神经管畸形地理环境影响发病因子分析，为环境健康研究提供新方法。如今，地理探测器已成为主流地理分析模型，广泛应用至流行病研究、环境影响因子分析、植被变化驱动力分析等领域。
1.1地理探测器概念 地理探测器是探测空间分异性，以及揭示其背后驱动力的一组统计学方法。其核心思想是基于这样的假设：如果某个自变量对某个因变量有重要影响，那么自变量和因变量的空间分布应该具有相似性。地理探测器擅长分析类型量，而对于顺序量、比值量或间隔量，只要进行适当的离散化，也可以利用地理探测器对其进行统计分析。即地理探测器既可以探测数值型数据，也可以探测定性数据，这正是地理探测器的一大优势。地理探测器的另一个独特优势是探测两因子交互作用于因变量。交互作用一般的识别方法是在回归模型中增加两因子的乘积项，检验其统计显著性。然而，两因子交互作用不一定就是相乘关系。地理探测器通过分别计算和比较各单因子q值及两因子叠加后的 q 值，可以判断两因子是否存在交互作用，以及交互作用的强弱、方向、线性还是非线性等。两因子叠加既包括相乘关系，也包括其他关系，只要有关系，就能检验出来。
地理探测器现有Excel、R语言、QGIS插件三种版本形式，均可在GeoDetector网站下载（Welcome to visit GeoDetector Website）。
1.2地理探测器原理 空间分异性是地理现象的基本特点之一。地理探测器是探测和利用空间分异性的工具。地理探测器包括4个探测器：分异及因子探测、交互作用探测、风险区探测、生态探测。
1.2.1分异及因子探测 探测Y的空间分异性；以及探测某因子X多大程度上解释了属性Y 的空间分异。用q值度量，表达式为：
（式中：h = 1, …, L为变量Y或因子X的分层（Strata），即分类或分区；Nh和N分别为层h 和全区的单元数； σh2和 σ2 分别是层h和全区的Y值的方差。SSW和SST分别为层内方差之和（Within Sum ofSquares）和全区总方差（Total Sum of Squares）。q的值域为[0, 1]，值越大说明Y的空间分异性越明显；如果分层是由自变量X生成的，则q值越大表示自变量X对属性Y的解释力越强，反之则越弱。极端情况下，q值为1表明因子X完全控制了Y 的空间分布，q值为0则表明因子X与Y没有任何关系，q值表示X解释了100×q%的Y。）
q值的一个简单变换满足非中心F分布：
（式中：λ为非中心参数；为层h的均值。根据式（3），可以查表或者使用地理探测器软件来检验q值是否显著。）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0392d78512e8ba2c4cdd3d119b218cc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb1a0f386d43b961bba59c8327b3569/" rel="bookmark">
			vue3 生成二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.添加qrcode.vue到我们的项目
yarn add qrcode.vue -S
2.在需要使用的组件中使用
&lt;template&gt;
&lt;div&gt;二维码生成&lt;/div&gt;
&lt;qrcode-vue :value="data.payUrl" :size="data.size" level="H" /&gt;
&lt;/template&gt;
&lt;script setup&gt;
import { reactive, ref } from 'vue'
import QrcodeVue from 'qrcode.vue'
const data = reactive({
payUrl: '你好，少年', //扫码后内容
size: 120, // 大小
})
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/916c6a84e1bb732e9b43ea3b6750e9b8/" rel="bookmark">
			[目标检测知识蒸馏4] [CVPR22] Focal and Global Knowledge Distillation for Detectors
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[CVPR22] Focal and Global Knowledge Distillation for Detectors Motivation 在目标检测中，前景、背景的不平衡是目标检测中的一个关键问题；
教师和学生网络的特征在不同区域有很大差异，尤其是在前景和背景中。如果进行平均蒸馏，特征图之间的不均匀差异会产生负面影响。
局部和全局蒸馏（FGD）：
局部蒸馏：分离了前景和背景，迫使学生网络将注意力集中在教师网络的关键像素和通道上；全局蒸馏：重建不同像素之间的关系，并将其从教师网络传递给学生网络，以补偿局部蒸馏中丢失的全局信息。
Method 包含局部蒸馏和全局蒸馏。
Focal Distillation 对于前景和背景的不平衡，提出局部蒸馏来分类图像，引导学生网络聚焦于关键像素和通道。
Binary Mask： 将图片的前景和背景信息进行分离：如 ( i , j ) (i,~j) (i, j) 落在 gt 中，则 M ( i , j ) = 1 M(i,j)=1 M(i,j)=1；否则为0.
M i , j = { 1 , if ( i , j ) ∈ r 0 , otherwise M_{i,j}= \begin{cases} 1,~&amp;\text{if}\ (i,~j)\in r\\ 0,~&amp;\text{otherwise} \end{cases} Mi,j​={1, 0, ​if (i, j)∈rotherwise​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/916c6a84e1bb732e9b43ea3b6750e9b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe94136535c230fb0b12cd1ce289a9a8/" rel="bookmark">
			[目标检测知识蒸馏2] [CVPR19] Distilling Object Detectors with Fine-grained Feature Imitation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[CVPR19] Distilling Object Detectors with Fine-grained Feature Imitation Introduction: 在 Faster RCNN 基础上使用知识蒸馏改进轻量级网络性能，其核心思想是 teacher 网络中需要传递给 student 网络的应该是有效信息，而非无效的 background 信息。
FGFI 利用fine-grained feature limitation，只对 gt 附近的 anchor 进行蒸馏（不是对整个 feature map 做的 hint learning）。具体来说，将 backbone 输出特征图与 RPN 网络输出结果进行组合，得到 student 网络应该学习的特征，用来指导其产生对应的分布。在 VGG11上实现了相对 baseline 15%的提升。
Fine-Gained区域提取 上图中的红色和绿色边界框是在相应位置上的锚框（ anchor boxes）。红色 anchor 表示与 gt 的边界框重叠最大，绿色 anchor 表示附近的物体样本。
对于 backbone 输出的特征图，假设其大小为 W ∗ H W ∗ H W∗H ，网络中使用的 anchor 数量为 K K K ，对于 fine-Gained 区域的提取步骤可以归纳如下（上图中的右边所示）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe94136535c230fb0b12cd1ce289a9a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/541a63e94d3f60c3ddd1d5e3a3fe52ed/" rel="bookmark">
			Qt开发 VS2019 C2001 常量中有换行符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体错误：
C2001	常量中有换行符 C2146	语法错误: 缺少“)” 在Linux系统编译正常，但是在Windows系统下会报如上错误。
解决办法：
1、添加宏定义
#pragma execution_character_set("utf-8") 2、修改文件编码
【文件】-&gt;【高级保存选项】
修改编码为：
保存，编译，就可以解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a20fbcf31ad9604ccfcccf214a303f7/" rel="bookmark">
			ElasticSearch 通用化批量数据同步器封装设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ElasticSearch 通用化批量数据同步器封装设计 一、设计需要满足的功能场景二、约定三、问题四、功能封装1、接口函数定义2、常量定义3、多线程分片处理器（Fork/Join 框架任务切分与处理）4、分页分片接口5、分页分片实现 一、设计需要满足的功能场景 ES 现在也是很多公司会用到的工具了，用来做数据的快速查询，那么不可避免的就会遇到需要将数据同步到 ES 的情况，为了做封装我们需要考虑到几个方面的问题。
数据量： 数据同步那么自然涉及到同步的数据量问题。通常的做法是把所有的数据查询到缓存中，然后再依次丢到 ES 里。但是假如数据量极大的情况就会把内存撑爆。因此设计上我们需要考虑分页分片同步，每次查个500条就同步500条，用时间换空间。效率问题： 既然分页分片，每个分片任务是互不影响的，因此可以考虑用多线程来提高处理效率。通用性： 因为需要考虑通用性，因此分页接口需要调用方传入，作为规范约定，分页返回的数据必须与ES字段一致 二、约定 规范约定，分页返回的数据必须与ES字段一致，目的是为了保证数据的正确性
至于存储工具的封装，参考：ElasticSearch 通用化批量存储封装设计
三、问题 1.如何知道分页是否全部处理完成了？
这里采用一种假设法，假设我们一页500条数据，每批5个线程处理，那么我们每批的线程共会处理线程 500*5 = 2500 条数据，假如有 10001 条数据要处理，那么之前的 4 批，每次都会处理满 2500 条，仅最后一次只处理 1 条数据。因此当我们发现处理数据的数量无法达到最大值时，说明数据处理完。
2.我们如何做到每批 5 个线程，每个线程处理 500 条这种操作？并且还要统计每批处理的数据量？
我们可以使用 Fork/Join 框架来实现，Fork/Join 中的每个任务应该为互不干扰，互不影响的任务，因而以 5*500 为一组的任务进入 Fork/Join 中进行处理时，每 500 为一个线程的任务就是互补影响的，最后只需统计处理数量。
四、功能封装 1、接口函数定义 分页接口函数： 用来传分页查询接口，PageResultDTO 自定义的分页返回值，Pageable 分页参数
@FunctionalInterface public interface PageFunction { PageResultDTO page(Pageable pageable); } ES操作接口函数： ES 操作接口函数
@FunctionalInterface public interface EsOperationFunction&lt;T&gt; { void handle(List&lt;T&gt; data); } 2、常量定义 /** * @author Jinpeng Lin * @description 全量分片常量 * @date 2022-05-30 */ public class PageShardingConstants { /** * ForkJoinPool 线程池最大数据 */ public static final int MAX_FORK_JOIN_POOL_SIZE = 10; /** * 失败重试次数 */ public static final int ERROR_TIMES = 5; /** * 最小分片数量 */ public static final int MIN_SHARDING_NUM = 1; /** * 最小分片大小，每个分片 N 条 */ public static final int MIN_SHARDING_SIZE = 1; /** * 最大分片数量 */ public static final int MAX_SHARDING_NUM = 10; /** * 最大分片大小，每个分片 N 条 */ public static final int MAX_SHARDING_SIZE = 1000; /** * 默认分片数量 */ public static final int DEFAULT_SHARDING_NUM = 4; /** * 默认分片大小，每个分片 N 条 */ public static final int DEFAULT_SHARDING_SIZE = 500; } 3、多线程分片处理器（Fork/Join 框架任务切分与处理） 我们用 Fork/Join 框架来作为分片处理器，Fork/Join 框架的好处在于在多线程处理中，可以帮我们实工作密取，空闲的线程会从繁忙线程的任务队列中，从任务队列后面获取一个任务去执行，以保证线程的利用率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a20fbcf31ad9604ccfcccf214a303f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9458d1de78c876ecb3c0d145e1dfc2a/" rel="bookmark">
			解决办法：ENVI5.3安装失败、找不到idl.dll认证文件、idl.dll病毒警告？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若在安装ENVI5.3过程中出现以下三种问题可参考此文
问题一：安装过程中，替换bin.x86下的idl.dll文件，但解压文件里找不到ibl.ill文件
问题二：安装过程中，替换bin.x86下的idl.dll文件，idl.dll文件病毒警告
问题三：安装后，打开ENVI5.3软件，显示找不到授权功能，安装失败
网上的ENVI具体安装教程有很多，下面是我参考的两个教程：https://mp.weixin.qq.com/s/17QP64KxpNmq6jRfrYwlRQ
ENVI5.3安装教程（含软件下载）_AriaGIS的博客-CSDN博客_envi安装
解决三个问题必须做的：
在安装前必须做以下操作
1.断网
2.关闭所有的防火墙
3.关闭“病毒和威胁防护”设置里的实时保护
4.关闭所有杀毒软件
解决问题一：
因为有些解压软件，不能把idl.dll文件解压出来，导致解压出来的bin文件显示为空。我们可以在压缩文件里直接查找到idl.dll，然后把它从压缩文件里拖出来，替换至软件安装路径IDL85\bin\bin.x86下的idl.dll原文件
替换前
替换成功后idl.dll文件修改日期会发生变化
解决问题二:
因为还有病毒检测，所以请做完安装前的必做操作（前面已叙述）
解决问题三：
没有替换成功idl.dll文件，才会导致授权功能找不到，所以请在压缩文件里直接查找到idl.dll，然后把它从压缩文件里拖出来，替换至软件安装路径IDL85\bin\bin.x86下的idl.dll原文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f99c49f5d96804f19af15fcf3007359/" rel="bookmark">
			win10系统怎么查看密钥？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家都知道，安装Win10系统之后需要密钥才能使用所有的功能，网上提供的激活方法有很多，那我们要怎么知道自己的密钥呢？下面小编就来教教大家怎么查看Windows 10密钥的方法。
操作过程：
1、在Windows10桌面，右键点击开始按钮，在弹出的菜单中选择“运行”菜单项。或者直接快捷键win+r打开运行菜单。
2、这时会弹出运行窗口，在窗口中的文本框内输入命令regedit，然后点击确定按钮后打开注册表编辑器窗口。
3、在打开的注册表编辑器窗口中定位到HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/SoftwareProtectionPlatform注册表项。
4、接着在右侧的窗口中找到BackupProductKeyDefault注册表键值。
5、双击打开BackupProductKeyDefault注册表键值，在编辑窗口中就可以看到系统的激活密钥了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/644b87d9564ee7406fc7b310a38faf40/" rel="bookmark">
			[车联网安全自学篇] Android安全之和平精英辅助APK逆向分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎新同学的光临
… …
人若无名，便可专心练剑
我不是一条咸鱼，而是一条死鱼啊！
0x01 前言 从小道师傅那边看到一篇文章，看着操作入手要求不是很高，刚好最近在学习逆向分析，就去网上找了一下资源（此篇不提供样本APK）
0x02 工具准备 2.1 抓包工具 工具名称使用平台优点缺点wiresharklinux、windowslinux平台支持好，功能强大不能解析https的内容fidderwindows功能强大，支持修改报文仅支持windowsCharleswindow、Mac可以按照域名进行分层级查看需要收费Burp Suite支持java的平台黑客喜欢用的功能强大工具界面不是很好看 2.2 模拟器 夜神模拟器 https://www.yeshen.com
PS：只支持Windows系统、Mac系统(M1暂不支持)
网易MUMU模拟器 https://mumu.163.com
PS：只支持Windows系统、Mac系统(M1暂不支持)
雷电模拟器 https://www.ldmnq.com
PS：只支持Windows系统
逍遥模拟器 https://www.xyaz.cn
PS：只支持Windows系统
https://mp.weixin.qq.com/s/eDexuhi3B2vs3gEPPJBJzA
0x03 加固特征库 360 assets/.appkey assets/libjiagu.so assets/libjiagu_art.so assets/libjiagu_x86.so assets/libprotectClass.so 爱加密 lib/armeabi/libexecmain.so assets/ijiami.ajm ijiami.dat assets/af.bin assets/signed.bin assets/ijm_lib/armeabi/libexec.so assets/ijm_lib/X86/libexec.so 几维安全 assets/dex.dat lib/armeabi/kdpdata.so lib/armeabi/libkdp.so lib/armeabi/libkwscmm.so libkwscr.so libkwslinker.so 梆梆安全 免费版
assets/secData0.jar lib/armeabi/libSecShell.so lib/armeabi/libSecShell-x86.so libsecexe.so libsecmain.so libDexHelper.so 定制版
assets/classes.jar lib/armeabi/DexHelper.so libDexHelper-x86.so DexHelper.so 腾讯加固 tencent_stub lib/armeabi/libshella-xxxx.so lib/armeabi/libshellx-xxxx.so lib/armeabi/mix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/644b87d9564ee7406fc7b310a38faf40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b698fd9c344bd7ed8f0a7f7ab2ccd3f3/" rel="bookmark">
			NMOS和PMOS管 电流方向和应用电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、分辨MOS管的方法 对于NMOS我们看下图中的箭头，都是远离源头。
对于PMOS我们看箭头，都是指向源头
P：POSITIVE积极的寻找自己的起源
N：NEGTIVE消极的远离自己的源头
首先明确一点，S是源极，D是漏极
对于NMOS，载流子是电子，我们知道电子的流向都是从源极到漏极，但是电流的流向是从漏极到源极。
对于PMOS，载流子是空穴对，空穴对的流向也是从源极到漏极，与NMOS不同的是PMOS电流的方向也是从源极到漏极，注意区分。
上图出现的二极管为体二极管，在驱动感性负载（马达）时很重要
2、NMOS PMOS电流方向和导通条件 注意：当防反接应用时，NMOS电流可以从S—&gt;D极，如下举例 NMOS是栅极高电平（|VGS| &gt; Vt）导通,低电平断开,可用来控制与地之间的导通。
PMOS是栅极低电平（|VGS| &gt; Vt）导通,高电平断开,可用来控制与电源之间的导通。
MOSFET（一）：基础_Infinity_lsc的博客-CSDN博客
NMOS因Source端一般接地（低电位），所以要让|VGS| &gt; Vt, 则Gate端一般要接正电压，这样管子才能导通；
PMOS因Source端一般接VDD（高电平），所以要让|VGS|&gt;Vt,则Gate端一般要接负电压（低与VDD的电压），这样管子才能导通。
3、PMOS开关电路举例 设计并调试好的电路如下图所示，由于供电电压和驱动电压均可以使用12V，所以采用了如下较为简单的方案。
如图所示，Q9 AO3401的栅极（G）通过100k电阻上拉到12V，源级（S）直接连接至12V电源侧，漏极（D）连接到被控设备，被控设备两端并联二极管，用于关断设备后，释放被控设备上的能量。在默认情况下，Q9 A03401的栅极被拉到12V，此时Vgs=0，PMOS处于截止状态，被控设备关断。
控制逻辑如下：
信号Control_Signal=1，动作被控设备得电
Control_Signal=0，被控设备掉电，并通过续流二极管D3释放存储的能量
上图是一个PMOS显然栅极为低导通，为高关断。
P-MOSFET开关连接在负载和正电源轨道(高侧开关)之间，就像我们使用PNP晶体管一样。在p通道器件中，漏极电流的常规流向是负方向的，因此施加负的栅源电压使晶体管接通。这是因为p通道MOSFET是倒置的，其源端连接到正电源+VDD。然后当开关为低，MOSFET打开，当开关为高，MOSFET关闭。
这种P沟道增强型MOSFET开关的倒置连接允许我们将其与N沟道增强型MOSFET串联起来，以产生互补或CMOS开关器件，如图所示，跨越双电源。
4、NMOS开关电路举例 对上图进行一个说明，首先对于NMOS来说，这里用作控制一个灯。当VIN输入一个高，显然NMOS导通，那么灯被点亮。对于VIN输入一个低，那么NMOS关断也灯被关断。
这里尤其注意一点，如果将负载换成一个感性的负载比方说线圈或者继电器，我们可以在其两侧并联一个二极管，这个二极管可以用来续流，从而防止关断NMOS 的瞬间产生的反电动势损坏NMOS
————————————————
版权声明：本文为CSDN博主「Fecter11」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Fecter11/article/details/122896933
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b43a07f8a807f22de12bcb2c72bc081d/" rel="bookmark">
			数据库之三大范式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 第一范式(1st NF) 第一范式主要是确保数据表中每个字段的值必须具有原子性,也就是说数据表中每个字段的值不可再次拆分的最小数据单元
举例1：
假设一家公司要存储员工的姓名和联系方式。它创建一个如下表：
该表不符合 1NF ，因为规则说“表的每个属性必须具有原子（单个）值”，lisi和zhaoliu员工的
emp_mobile 值违反了该规则。为了使表符合 1NF ，我们应该有如下表数据：
举例2：
user 表的设计不符合第一范式
其中，user_info字段为用户信息，可以进一步拆分成更小粒度的字段，不符合数据库设计对第一范式的 要求。将user_info拆分后如下：
举例3：
属性的原子性是 主观的 。例如，Employees关系中雇员姓名应当使用1个（fullname）、2个（firstname和lastname）还是3个（firstname、middlename和lastname）属性表示呢？答案取决于应用程序。如果应用程序需要分别处理雇员的姓名部分（如：用于搜索目的），则有必要把它们分开。否则，不需要。
表1：
表2：
1.2 第二范式(2st NF) 第二范式要求,在满足第一范式的基础上,还要"满足数据表中的每一条数据记录,都是可唯一标识的(主键),而且所有非主键字段,都必须完全依赖主键,不能只依赖主键的一部分",如果知道主键的所有属性的值,就可以检索到任何元组(行)的任何属性的值,(要求中的主键,其实可以拓展为候选键).
举例1：
成绩表 （学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课程号也不能决定成绩，所以“（学号，课程号）→成绩”就是 完全依赖关系 。
举例2：
比赛表 player_game ，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这
里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键（或主键）来决定如下的关系：
(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)
但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：
(球员编号) → (姓名，年龄)
(比赛编号) → (比赛时间, 比赛场地)
对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？
数据冗余 ：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛
也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。插入异常 ：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没
法插入。删除异常 ：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删
除掉。更新异常 ：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b43a07f8a807f22de12bcb2c72bc081d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/117a1e69a2056763ed5e0e798729b3c0/" rel="bookmark">
			k8s(4)-Service三种类型以及内外网络访问Pod
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Service网络三种类型 ① ClusterIp
默认类型，自动分配一个仅Cluster内部可以访问的虚拟IP，适用于cluster内部网络访问Service。k8s会自动分配一个IP地址赋予Service。
② NodePort
在ClusterIP基础上为Service在每台机器上绑定一个端口，这样就可以通过: NodePort来访问该服务。
③ LoadBalancer
在NodePort的基础上，借助Cloud Provider创建一个外部负载均衡器，并将请求转发到NodePort
2.实例测试 ClusterIp
① v1 是 Service 的 apiVersion。
② 指明当前资源的类型为 Service。
③ Service 的名字为 httpd-svc。
④ selector 指明挑选那些 label 为 run: httpd 的 Pod 作为 Service 的后端。
⑤ 将 Service 的 8080 端口映射到 Pod 的 80 端口，使用 TCP 协议。
执行 kubectl apply 创建 Service httpd-svc。kubectl apply -f http-svc.yml
此时名为httpd-svc的Service启动，分配到的地址 CLUSTER-IP 为10.99.229.179，访问端口为8080。
在任意节点都可以访问成功。
通过 kubectl describe 可以查看 httpd-svc 与 Pod 的对应关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/117a1e69a2056763ed5e0e798729b3c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fffbb3b7030a7840c7177be59037314/" rel="bookmark">
			如何安装KEIL并配置好51与STM32的环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.首先确保自己电脑D盘有足够的空间，并且将自己从前的KEIl卸载完毕。 2.下载资源包后解压到D盘，后在D盘新建文件夹命名为“keil5” 资源包 提取码：2548
3.打开解压文件双击程序mdk514.exe进行安装，配置如下 直接勾选点finish 注意此处只需要把第一个路径选为刚刚新建的“keil5”即可 这一步可以乱填但是邮箱格式得是对的 取消勾选点击finish 双击打开Keil.STM32F1xx_DFP.1.0.5.pack直接点next添加芯片包 将C51.RAR文件移动到“keil5”路径下并解压 打开TOOLS.txt把里面的文本全选复制后粘贴到“keil5”中的TOOLS.INI中的最后一行，然后保存退出（将TOOLS.INI以文本形式打开） 在桌面找到keil软件以管理员身份运行它 选择file-&gt;liscen management 复制Computer ID 把windows defend以及所有的杀毒软件关闭退出后解压并打开keygen.rar并运行keygen.exe，然后粘贴到CID里点击generate 将产生的秘钥复制粘贴到keil的LIC栏里点击ADD LIC出现如下情况则表示成功 打开keygen将C51切换为ARM后点击generate再次重复上述步骤有两个2032的license即为成功 将stc-isp-15xx-v6.88.rar解压到D盘根目录然后打开该目录下的USB to UART Driver把里面的驱动都安装一遍看见什么都点允许。 将stc-isp-15xx-v6.88.exe右键点击创建快捷方式然后将快捷方式移动到桌面，最后双击打开 点击右侧顶栏keil仿真设置点击添加文件 点击确定然后选择对应的单片机型号 在桌面新建一个叫单片机的文件夹后打开KEIL软件点击project点击new project 选择刚刚的单片机文件然后文件名为test点击保存即可 而后选择STC的database 然后选择如下选项 之后的学习就靠自己了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f691f2dcf3145eb728e41e2c42d4d881/" rel="bookmark">
			IDEA断点调试学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开启断点调试 1.点击idea上方的小虫，就可以启动调试。
2.点击下方idea的下方红框里面的按钮，可以从其它地方回到断点的位置，点击一下即可。
3.点击步过按钮，不会进入到方法里面，一行一行的往下执4.步入按钮，可以进入到我们自定义的方法中，如果是其它类库的方法不会进入。
4.步入按钮，可以进入我们自定义的方法，如果是其它的类库的方法就不会进入。
5.点击步入，步出按钮，步入按钮可以进入深层的方法，包括官方的源码，步出就是从对应的方法中出来。
6.回退断点按钮，如果你的代码中没有调用其它位置的方法，那么就是灰色的，无法使用，只有进入更深层的方法，才能够使用，比如我们很多时候调试的时候不小心点快了，很容易错过想看的位置，那可能只能重启，这个时候就可以使用这个按钮。（注意：如果你的某个方法已经调用完了，就回不去了）
7.断点跳到光标处，该按钮可以快速跳转到光标指向的那一行代码。
8.计算表达式按钮，我们可以获取集合里面的数据，用表达式查询对应的元素。
9.该按钮可以跳转到指定的断点处。
10.停止调试按钮，但是该按钮停止了程序，程序也会继续运行下去。
11.查看所有断点的按钮。
12.禁用断点按钮，暂时禁用掉断点，方便程序执行，一般配合恢复按钮使用（指定跳转到断点处）
13.这里面存放了很多变量的信息，方便查看，在watch可以监控变量的变化，单独拿出来看起来更方便。
断点调试方法 1.方法断点
方法断点不是用在普通方法上的，最好的用法是用在接口上使用，当我们在调试源码的时候，如果在接口上打了断点，在往下走，可以直接跳转到实现类的实现方法上，而不用我们一个个去找。
注意：方法断点是一个菱形标志。
2.属性断点
属性断点是打在属性上的，我们无需在getter、setter方法上打断点，在属性打上断点，就会出现一个小眼睛的标志。
3.异常断点，如果线上出现了BUG，我们想快速定位哪里出现了空指针，那就应该使用空指针异常。（异常断点是一个闪电标志）
我们在全局打了个空指针断点，只要哪里出现空指针，就会在哪里停止，很方便。
4.终止断点
取消后面代码的运行，直接终止返回
5.条件断点
当我们想要在某个条件满足的时候，打上断点，而不是想一步步走下去，在断点处右键，在condition里输入相应的条件即可。
6.流断点
我们使用流的时候，很难看到中间做了什么，但其实idea帮我们解决了。
7.多线程断点
1.多线程下调试
2.定时任务下调试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c4546e7238fcbb08c11a35b86707a22/" rel="bookmark">
			Vue分页监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端：
&lt;pagination v-show="total &gt; 0" :total="total" :page.sync="queryParams.pageNum" :limit.sync="queryParams.pageSize" @pagination="getList" /&gt; JS：
watch: { //监听翻页 回显当前页选中的行 "queryParams.pageNum": function (val) { this.$nextTick(() =&gt; { this.$refs.suppliesTable.setCurrentRow(this.selectRow); }); }, },
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca27f0297acbb45e4af6f1ea0449d08d/" rel="bookmark">
			Vue项目按需请求，组件数据懒加载—@vueuse/core中 useIntersectionObserver的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue项目按需请求，组件数据懒加载—@vueuse/core中 useIntersectionObserver的使用 一、通过监听 scroll 事件实现 import { ref } from 'vue'; // 响应式数据，用于是否显示固定头部 const isShow = ref(false); // 监听浏览器滚动事件 window.addEventListener('scroll', () =&gt; { // 获取滚动出去的距离 const top = document.documentElement.scrollTop; if (top &gt;= 78) { // 大于等于 78 显示盒子 isShow.value = true; } else { // 反之隐藏盒子 isShow.value = false; } }); // tempalte &lt;div class="app-header-sticky" :class="{ show: isShow }"&gt;&lt;/div&gt; 二、通过 @vueuse/core实现 即当模块进入到 可视区 ，再发请求获取数据
使用 @vueuse/core 中的 useIntersectionObserver 来实现监听组件进入可视区域行为，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca27f0297acbb45e4af6f1ea0449d08d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4293b047ebb20fec21066e6fa79c0fe4/" rel="bookmark">
			解决vue3&#43;ts，内嵌vue2代码，无法使用$refs的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到了一个关于$ref的问题。
业务场景：
多页签表单，提交时需要先判断几个表单必填是否完整，
在原来vue2项目中，在父组件electionIndex.vue组件中通过以下代码获取请问以便提示
源代码如下
//组件关系如下：electionIndex-&gt;dbInfo=&gt;dbAside,dbBasicInfo,dbElection let asideFlag = this.$refs.dbInfo.$refs.dbAside.validataForm() let basicFlag = this.$refs.dbInfo.$refs.dbBasicInfo.validataForm() let electionFlag = this.$refs.dbInfo.$refs.dbElection.validataForm() 但是由于新单机版系统由vue3+ts搭建，vue3不支持vue2的refs方法，
因此上述代码，无法调用孙组件中的方法
解决办法如下：
//getCurrentInstance能得到组件中的proxy,进而拿到$refs import {getCurrentInstance} from 'vue' this.proxyElection=getCurrentInstance(); //子组件依然需要上述步骤 将上面代码改为： let asideFlag = this.proxyElection.proxy.$refs['dbInfo'].proxyDbInfo.proxy.$refs.dbAside.validataForm() let basicFlag = this.$refs.dbInfo.$refs.dbBasicInfo.validataForm() let electionFlag = this.$refs.dbInfo.$refs.dbElection.validataForm() //发现不好使。 发现这几个方法都是dbinfo下的子组件，于是，去掉上述代码，在dbInfo中这样写：
async getChildMethods(){ let obj={ asideFlag:false, basicFlag:false, electionFlag:false, } await this.proxyDbInfo.proxy.$refs['dbAside'].validataForm()==true?obj.asideFlag=true:false await this.proxyDbInfo.proxy.$refs['dbBasicInfo'].validataForm()==true?obj.basicFlag=true:false await this.proxyDbInfo.proxy.$refs['dbElection'].validataForm()==true?obj.electionFlag=true:false return {...obj} }, 在electionIndex中调用并解构
let { asideFlag, basicFlag, electionFlag } = await this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4293b047ebb20fec21066e6fa79c0fe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c74f28bddcc7fae67f96a5ab80f98fe/" rel="bookmark">
			用Python做一款简单的打字速度测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在大家一定知道很多打字测试软件吧！例如金山打字通，今天，我们也自己制作一款打字速度测试软件吧！
分析：
1，导入库，创建打字对象
2，选取句子，输入
3，记录时间
4，打印结果，如是否有错别字，用时
1，导入库time,random,datetime
import random import time import datetime 也可以简单一点
import random,time,datetime 创建自定义打字变量
#列表中内容请自行填写，这里仅供参考 a=['掇拾、菲薄','您提的意见很好，我们一定采纳您的意见，改进工作。','不客气，这是我们应该做的。','邀请别人用屈驾，招待不周说怠慢。','请人担职用屈就，暂时充任说承乏。'] 随机选取列表中的内容
b=random.choices(a) 提示（print）开始，请做好准备，用到睡眠sleep指令
time.sleep(1) print('Ready!') time.sleep(1) print('Go!') 打印b
print(b) 启动计时器并输入内容
ticks = datetime.datetime.now() c=input('&gt;&gt;&gt;') 停止计时器
ticks2 = datetime.datetime.now() 计算经过时间
ticks3 = ticks2-ticks print(ticks3) 优化：提示时间长短，是否打错字
jgsj=ticks3.seconds+ticks3.microseconds / 1000000 if c not in b: print("你打错字了！") elif jgsj&gt;30.5: print('太慢了呢！继续加油！') else: print('厉害呀，继续加油！') print('用时为：%ss'%jgsj) 完整代码：
import random import time import datetime a=['掇拾、菲薄','您提的意见很好，我们一定采纳您的意见，改进工作。','不客气，这是我们应该做的。','邀请别人用屈驾，招待不周说怠慢。','请人担职用屈就，暂时充任说承乏。'] print('请输入[’‘]中的内容') b=random.choices(a) time.sleep(1) print('Ready!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c74f28bddcc7fae67f96a5ab80f98fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63519b1a3beb4e7b33f9e286d91477d4/" rel="bookmark">
			【集合】- ArrayList源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArrayList源码解析 简介概述类图-继承关系 ArrayList的实现属性构造方法1. ArrayList()无参构造方法2. ArrayList(int initialCapacity)3. ArrayList(Collection&lt;? extends E&gt; c) 常用方法1. add(E e) 方法2. add(int index, E element) 方法3. addAll(Collection&lt;? extends E&gt; c) 方法4. addAll(int index, Collection&lt;? extends E&gt; c) 方法5. remove(int index)方法6. fastRemove(Object[] es, int i)快速删除7. indexOf(Object o)查找单个元素8. lastIndexOf(Object o) 方法9. clone() 方法10. grow()扩容方法11. set(int index, E element)方法12. get(int index) 方法 常见问题 总结 简介 概述 ArrayList底层是一个数组，数组元素类型为object，支持动态扩容，所以ArrayList也相当于一个动态数组；ArrayList继承自 AbstractList，实现了 List 接口，允许 null 的存在；
接下来我们通过类层次结构、构造方法及常用方法三方面看ArrayList源码；
类图-继承关系 ArrayList继承了AbstractList，实现了List、RandomAccess、Serializable、Cloneable这些接口；
List：是一个数组队列，提供了相关的添加、删除、修改、遍历等操作；RandomAccess：提供了随机访问功能，ArrayList中可以通过元素序号快速获取元素对象；Serializable：表示ArrayList支持序列化Cloneable：支持克隆 ArrayList的实现 属性 /** * 存储ArrayList元素的数组， * 添加到 ArrayList 中的元素数据（第一次添加元素时，空ArrayList会扩容到 DEFAULT_CAPACITY = 10 ） */ transient Object[] elementData; /** * ArrayList大小，包含元素数量 */ private int size; 构造方法 构造方法构造方法描述ArrayList()构造一个初始容量为10的空列表ArrayList(int initialCapacity)构造具有指定初始容量的空列表ArrayList(Collection&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63519b1a3beb4e7b33f9e286d91477d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48a50579431773592208e0f9f499b45a/" rel="bookmark">
			【C语言】整理姓名表。将输入的若干姓名按字典顺序排序并输出。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;
int main()
{
int n;
printf("请输入人数：\n");
scanf("%d",&amp;n);
printf("请输入姓名：\n");
char *a[n];
char *temp;
for(int i=0;i&lt;n;i++)
{
a[i] = (char *)malloc(80);
scanf("%s",a[i]);
}
for(int i=0;i&lt;n;i++)
{
for(int j=i;j&lt;n-1;j++)
{
if(strcmp(a[j],a[j+1])&gt;0)
{
temp = a[j];
a[j] = a[j+1];
a[j+1] = temp;
}
}
}
printf("排序结果：\n");
for(int i=0;i&lt;n;i++)
{
puts(a[i]);
free(a[i]);
}
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b1b5a83e5148727e380da269dcc8445/" rel="bookmark">
			CentOS7vim修改文件/bin/bash: wq command not found问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 centos7部署clickhouse，部署很简单，使用命令执行即可，可以参考这篇博客clickhouse的默认配置文件是只支持本地访问的，如果需要外网访问，需要修改配置文件/etc/clickhouse-server/config.xmlsudo vim /etc/clickhouse-server/config.xml，使用vi或vim修改时，会提示是只读文件，需要使用!强制保存或覆盖使用:!wq报错 /bin/bash: wq: command not found想退出，使用:!q也报错/bin/bash: q: command not found最终没办法，使用CTRL + Z退出但是要外网访问，必须修改这个文件，这个问题还是要解决 解决过程 百度了一堆，大多说是系统PATH设置问题，需要改配置有的文件vi或vim修改时是没问题的，现在不知道为什么出现了这个报错，感觉可能还是和文件权限有关系，觉得和系统PATH设置没太大关系保存报错时是有提示的，按理说按照提示去操作应该没问题的，应该是写法有问题尝试了下将!放到最后，果然可以了就这么简单，将!放到最后即可，例如 :wq!、:q!如果你遇到类似问题，先不要去管系统PATH设置，按照这个方法，把!放到最后试试 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c28204438039bfbfdbba364dcb1c367/" rel="bookmark">
			[ 轻量级网络 ] 经典网络模型3——ShuffleNet 详解与复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤵 Author ：Horizon Max
✨ 编程技巧篇：各种操作小结
🎇 机器视觉篇：会变魔术 OpenCV
💥 深度学习篇：简单入门 PyTorch
🏆 神经网络篇：经典网络模型
💻 算法篇：再忙也别忘了 LeetCode
[ 轻量级网络 ] 经典网络模型3——ShuffleNet 详解与复现 🚀 ShuffleNet🚀 ShuffleNet 详解🎨 ShuffleNet 网络结构🚩 背景介绍🚩 Group Convolution🚩 Channel Shuffle🚩 ShuffleNet Unit🚩 ShuffleNet 结构框图 🚀 ShuffleNet 复现 🚀 ShuffleNet ShuffleNet 使用是一种计算效率极高的CNN架构，它是专门为计算能力非常有限的移动设备设计的 ；
通过 逐点分组卷积(Pointwise Group Convolution) 和 通道洗牌(Channel Shuffle) 两种新运算，在保持精度的同时大大降低了计算成本 ；
ShuffleNet 比最近的 MobileNet 在 ImageNet 分类任务上的 top-1误差更低 (绝对7.8%) ；
在基于ARM的移动设备上，ShuffleNet 比 AlexNet 实现了约13倍的实际加速，同时保持了相当的精度 ；
🔗 论文地址：ShuffleNet: An Extremely Efficient Convolutional Neural Network for Mobile Devices
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c28204438039bfbfdbba364dcb1c367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7857edae32c94b282b11cb55571df61a/" rel="bookmark">
			Pandas中的loc与iloc用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基本简介 1.1 loc与iloc基本含义 loc函数：通过行索引 “Index” 中的具体值来取行数据（如取"Index"为"A"的行）
iloc函数：通过行号来取行数据（如取第二行的数据）
注：loc是location的意思，iloc中的i是integer的意思，仅接受整数作为参数。
1.2 loc与iloc的区别 官网解释DataFrame中的loc与iloc：
Purely integer-location based indexing for selection by position. --iloc
Access a group of rows and columns by label(s) or a boolean array. --loc
二者的区别(传入参数的不同)：
loc works on labels in the index.
iloc works on the positions in the index (so it only takes integers).
2.使用方法 2.0 数据准备 # 导包 import numpy as np import pandas as pd #创建Dataframe data=pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7857edae32c94b282b11cb55571df61a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d690ee17076c620e4c481d674b59f1a9/" rel="bookmark">
			关于springboot的优雅停机和健康检查配置（用于k8s服务重启）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优雅停机 所谓的优雅停机指的是（一方面可以在停机的时候通过背板挡住外来正在发送的请求，另一方面已经接受的请求能够很好的执行完接下来的业务）。服务在关闭的时候，不能通过强制kill进程的方式进行停止，这样的话，对于有些未处理完成的业务要进行数据的补偿.
一. 优雅停机 1. 如果是springboot2.3版本之前可以通引入如下jar
&lt;dependency&gt; &lt;groupId&gt;com.github.timpeeters&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-graceful-shutdown&lt;/artifactId&gt; &lt;version&gt;X.X.X&lt;/version&gt; &lt;/dependency&gt; 版本可参考：
就可以实现优雅停机了
2、如果springboot是2.3版本之后，则可以直接在application.yml做如下配置即可
server: # 开启优雅关闭，默认：IMMEDIATE，立即关闭 shutdown: graceful spring: lifecycle: # 配置优雅关闭宽限时间，即项目在30s都没处理完，则进行强制关闭 timeout-per-shutdown-phase: 30s 二. 健康检查配置 添加依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 配置application.yml，如下
management: # 也可指定ip和端口进行访问 # server: # address: 127.0.0.1 # port: 5000 # 开启shutdown endpoint endpoint: # 需要关机就要进行配置默认都是flase shutdown: enabled: true health: enabled: true endpoints: web: base-path: /actuator #访问http://127.0.0.1:8083/actuator/health exposure: # 暴露shutdown health（访问http://127.0.0.1:8083/actuator/health进行健康检测 # 访问http://127.0.0.1:8083/actuator/shutdown进行优雅停机） include: shutdown,health 访问http://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d690ee17076c620e4c481d674b59f1a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b2308a1dbc38a1f973db5da15a0f5d6/" rel="bookmark">
			Android Studio 关联源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 当我们在 Android 查看源码时，经常会看到 throw new RuntimeException。
// Intent: @NonNull public Intent setClass(@NonNull Context packageContext, @NonNull Class&lt;?&gt; cls) { throw new RuntimeException("Stub!"); } 关联 Android 源码 1.打开 SDK Manager 2.下载源码 首先要勾选 show Package Detail
然后勾选对应 SDK 版本的 source
最后点击 apply 或 ok 就会下载
3.关联源码 等待下载完成，然后修改关联源码对应的本地路径及url。
修改文件在以下位置
Android Studio 3.x 版本
Windows 系统：C盘/Users/用户名.AndroidStudio3.x/config/options/jdk.table.xml
Mac 系统：/Users/用户名/Library/Preferences/AndroidStudio3.x/options/jdk.table.xml
Android Studio 4.x 版本
Windows 系统：C:\Users\用户名\AppData\Roaming\Google\AndroidStudio2020.3\options
Mac 系统：/Users/用户名/Library/Application Support/Google/AndroidStudio4.2/options/jdk.table.xml
根据上面的目录打开 jdk.table.xml 这个文件。
然后找到对应的 jdk 版本位置，在 classPath 标签下添加本地源码对应路径。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b2308a1dbc38a1f973db5da15a0f5d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad066f292a6f204d0f6d9a17fd130465/" rel="bookmark">
			猿创征文｜Vue前端性能优化方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 概述
2. 性能优化切入点分析
2.1 vue-router
2.2 打包优化
2.3 压缩技术
3. 性能优化实践
3.1 vue-router优化
3.1.1. 异步加载
3.1.2. 按需加载
3.2 打包优化
3.3 前端工程压缩
1. 概述 Web应用的优化方案一般分为两类：第一类是基于硬件的优化，第二类是基于软件的优化。基于硬件的优化主要包括扩大带宽、负载均衡、服务集群等方式，而这些依托于硬件的提升都需要公司去承担巨额的支付成本。较之而言，对软件的优化以及技术的革新更加具有实际意义。一般来说，一个Web网页，不止包含必要的HTML文件，还包含很多其他的相关资源文件，比如CSS文件、JavaScript文件、图像等等，这些文件一起构成了页面组件。通过Web前端构成元素以及请求响应机制的分析，本方案从vue-router优化、打包优化、压缩技术三个方面给出Vue前端性能的优化方案。
2. 性能优化切入点分析 2.1 vue-router vue-router是Vue官方提供的路由管理器，又称路由懒加载，是指将不同路由所对应的组件划分为不同的代码块，然后只有在访问路由时才会加载相应的组件。这样既可以提高Web项目的加载速度也可以提高页面响应效率。本方案分别从Vue的异步组件和Webpack的代码分割功能两方面对vue-router路由懒加载进行实现。
1. Vue异步组件
在Web应用中，可以将应用分割成比较小的代码块，只在需要的时候从服务器端加载所需模块。Vue为了对代码进行精简，可以让开发者以工厂函数的方式定义组件，而该工厂函数可以异步地对组件定义进行解析。Vue只会在该组件被渲染的时候才去触发该工厂函数，并将结果进行缓存以便将来重新进行渲染。该工厂函数会收到一个resolve回调函数，这个回调函数会在得到服务器命令的时候被调用，也可以调用reject(reason) 方法来表示加载失败。在获取组件的时候，也可以将异步组件和webpack的code-splitting功能一起配合使用，将效果达到最优化。
2. Webpack代码分割
Webpack是当下非常流行的一款代码编译工具，其代码分割功能可以将代码分离到不同的模块中，以便能够并行或按需加载这些模块。进行代码分割不仅可以控制资源加载的优先级，而且还能够获得更小的模块。常见的代码分割方式主要有以下三种：
入口起点法：即使用Entry配置手动分离代码，这种方式虽然比较直观，但用法不够灵活，而且不能动态地将核心应用程序逻辑中的代码拆分出来。防止重复法：使用SplitChunkPlugin插件可以去重合分离chunk，即将公共的依赖模块提取到已有的entry chunk中，或者提取到一个新生成的chunk中。动态导入法：通过模块中的内联函数调用分离代码。涉及到动态代码拆分时，Webpack提供了两种方法。第一种是使用通过ECMAScript提案的import()方法来实现动态导入，第二种则是使用Webpack特定的require.ensure()方法。 2.2 打包优化 Web应用打包优化可以优化项目启动速度和性能，进行必要的数据清理，减少打包后的体积。本方案的打包优化思路有以下三点：
减少预加载、忽略调试代码。降低打包后的资源总体积：避免将用不到的资源打包，如三方组件(moment 等)的语言包中用不到的语言资源。分包：将公共组件、较大的资源单独打包，减少首屏加载的资源数量。 2.3 压缩技术 Web页面的第一次加载，是在浏览器没有缓存的情况下的，也就是从服务器端通过网络下载到客户端的过程。影响网页加载速度的因素有很多，从硬件上来讲，有服务器端、客户端和网速（带宽）三个方面。硬件因素的改进都是无法简单做到的，可控的因素是减少HTTP请求和减少页面大小。为了减小页面大小，压缩源文件就成了最为重要的一步。几乎所有的Web站点，都会用到JavaScript脚本表和CSS样式表，页面在首次加载的时候，缓存为空，页面中每一个资源文件都要单独进行一次HTTP请求。因此在Web前端开发过程中，为了符合模块化的开发原则，通常会把JavaScript文件和CSS文件各自汇总保存在独立的文件中。除了对相关资源文件进行整合，还应该分别对CSS与JavaScript文件进行压缩，尽量使整个前端页面中的相关文件体积最小化。
3. 性能优化实践 3.1 vue-router优化 3.1.1. 异步加载 vue-router配置访问路由时，组件采用异步加载的方式引入。
√ 推荐的用法：
{ path: '/flowPublicDetail/:id', name: "flowEformDetail", component:() =&gt; import('../pages/system/flowPublicDetail/index.vue'), hidden: true, meta: { title: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad066f292a6f204d0f6d9a17fd130465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eb460a06afc2694650c5ca5995885ce/" rel="bookmark">
			C&#43;&#43;基础知识（二十五）--- STL案例之演讲比赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
24个人，分4组，每组6人，三轮比赛，每轮淘汰一半。第三轮6人决出前三名。
10个评委打分，选手最终得分是去掉最高最低取平均。
思路：
（1）用 vector 存储编号，编号对应选手；
（2）用 map 保存选手信息（键值是编号，实值是选手）；
（3）每一轮结果存储到 vector 中，只保存选手的编号；
流程：
（1）创建选手
（2）第一轮比赛：抽签，比赛，打印本轮晋级选手名单
（3）第二轮比赛：抽签，比赛，打印本轮晋级选手名单
（4）第三轮比赛：抽签，比赛，打印本轮晋级选手名单
比赛：
（1）学生成绩存储到 deque 容器中，计算出分数；
（2）评比
//定义比赛选手 class Player { public: string name; int age; int mScore[3]; //三轮比赛成绩 }; //创建选手 void CreatePlayer(vector&lt;int&gt;&amp; v1, map&lt;int, Player&gt;&amp; mlist) { string setName = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; for (int i = 0; i &lt; 24; i++) { //创建选手 Player p; p.name = "选手"; p.name += setName[i]; p.age = 20; for (int j = 0; j &lt; 3; j++) { p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9eb460a06afc2694650c5ca5995885ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c673e49700ae8579796b17c5cea757a0/" rel="bookmark">
			npm 发布私有包遇见 402 Payment Required
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 因为我们公司有个私有组织，我加入后发包遇见了
402 Payment Required - PUT https://registry.npmjs.org/xxx - You must sign up for private packages 后来查询资料后发现，是我package.json没有添加
"publishConfig": { "access": "public", "registry": "https://registry.npmjs.org/" }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5be492f4285843da582f5358662c8d44/" rel="bookmark">
			Eigen 旋转向量与旋转矩阵（用法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、旋转矩阵-------旋转向量 Eigen::AngleAxisd rotation_vector2; rotation_vector2.fromRotationMatrix(rotation_matrix2); 或者
Eigen::AngleAxisd rotation_vector2(rotation_matrix2); 打印可以输出：
旋转角，旋转向量
cout &lt;&lt; "rotation_vector2 " &lt;&lt; "angle is: " &lt;&lt; rotation_vector2.angle() * (180 / M_PI) &lt;&lt; " axis is: " &lt;&lt; rotation_vector2.axis().transpose() &lt;&lt; endl; 2、旋转向量-------旋转矩阵
【！！！！！！！！！重点在这里！！！！！！！！！！ 初始化旋转向量：旋转角为alpha，旋转轴为(x,y,z)
Eigen::AngleAxisd rotation_vector(alpha,Vector3d(x,y,z)) 表示：沿着旋转轴(x,y,z)，旋转alpha后的向量是rotation_vector
当一个向量为Vector3d(xx,yy,zz)时，用Eigen::AngleAxisd如何表示？？？？ alpha：代表Vector3d(xx,yy,zz)的模；
Vector(x,y,z)：Vector3d(xx,yy,zz)单位化后
】
Eigen::Matrix3d rotation_matrix; rotation_matrix=rotation_vector.matrix(); 或者
rotation_matrix=rotation_vector.toRotationMatrix(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/173611245397186d2a4b8cd643b27182/" rel="bookmark">
			mybatis-plus 官网文档例子运行出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.h2.jdbc.JdbcSQLSyntaxErrorException: Table “USER” not found; SQL statement: INSERT INTO user 检查了是按照文档内容来的，但是运行出错，后来发现是maven 依赖包版本问题
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; spingboot 版本改为2.6.2，即运行成功。
注意要将依赖包版本与改github官方例子版本一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe103424c7d859ae6a5099b7f0c93f3/" rel="bookmark">
			HTML/JavaScript中引入json文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一：通过&lt;script &gt;标签引入 第一步：在json文件中定义一个变量指向json数据（一些IDE会报错，不过不用管，另外一些IDE规则验证无法通过，导致无法保存，这种情况就用第二种方法吧）。
var jsonData = { // json数据 }; 第二步：在HTML文件中使用&lt;script&gt;标签引入json文件
&lt;script type="text/javascript" src="./xxx.json"&gt;&lt;/script&gt; &lt;script&gt; // 控制台输出json console.log("json文件数据", jsonData); &lt;/script&gt; 方法二：通过异步获取json（getJSON） 要引入JQuery要启动服务（我用的http-server），否则出现跨域报错注意json文件不能像方法一那样写了，是纯json文件，不要赋值变量了 &lt;script src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&lt;/script&gt; &lt;script&gt; $.getJSON('data.json', function (data) { console.log("json文件数据", data); }) &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc060913e3b9d905c83482496d3f9fd/" rel="bookmark">
			Python自动转换大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # 大小换算 def bytes_conversion(self, number: float): """ 换算大小 :param number: byte字节单位 :return: 大小 """ symbols = ('K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y') prefix = dict() for a, s in enumerate(symbols): prefix[s] = 1 &lt;&lt; (a + 1) * 10 for s in reversed(symbols): if int(number) &gt;= prefix[s]: value = float(number) / prefix[s] return '%.1f%s/s' % (value, s) return "%sB/s" % number 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4644f10710c0dfc8ee091baacf59769/" rel="bookmark">
			把给定长度为10的整数数组中所有0元素全部移除，且所有非0元素的顺序不变。（求纠错版）c语言，算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# include &lt;stdio.h&gt;
# include &lt;stdarg.h&gt;
# include &lt; math.h&gt;
int main()
{
int i=0, a[10];
for (i = 0; i &lt; 10; i++)
scanf_s("%50d", &amp;a[i]);
if (a[i])
{
printf("%d ", a[i]);
}
return 0;
}
我真的要疯了，编译器找不到错，但是编出来不对，求大佬纠错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51f6aaaab13a8c84d30e19d16771c7e6/" rel="bookmark">
			超越所有MIM模型的BEiT v2来了！微软使用矢量量化视觉Tokenizers的掩码图像建模！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【写在前面】 蒙面图像建模 (MIM) 通过恢复损坏的图像patch，在自监督表示学习中展示了令人印象深刻的结果。然而，大多数方法仍然对低级图像像素进行操作，这阻碍了对表示模型的高级语义的利用。在这项研究中，作者提出使用语义丰富的视觉标记器作为掩码预测的重建目标，为将 MIM 从像素级提升到语义级提供了一种系统的方法。具体来说，作者引入向量量化知识蒸馏来训练tokenizer，它将连续的语义空间离散化为紧凑的代码。然后，通过预测mask图像块的原始视觉token来预训练视觉Transformer。此外，作者鼓励模型将patch信息显式聚合到全局图像表示中，这有助于linear probing。图像分类和语义分割的实验表明，本文的方法优于所有比较的 MIM 方法。图像分类和语义分割的实验表明，本文的方法优于所有比较的 MIM 方法。在 ImageNet-1K（224 大小）上，基本大小的 BEIT V2 在微调时达到 85.5% 的 top-1 精度，在线性探测（linear probing）时达到 80.1% 的 top-1 精度。大尺寸 BEIT V2 在 ImageNet-1K（224 大小）微调上获得 87.3% 的 top-1 准确率，在 ADE20K 上获得 56.7% 的 mIoU 用于语义分割。
1. 论文和代码地址 BEIT V2: Masked Image Modeling with Vector-Quantized Visual Tokenizers
论文地址：https://arxiv.org/pdf/2208.06366.pdf
代码地址：https://github.com/microsoft/unilm
2. 动机 蒙面图像建模 (Masked image modeling) 在学习视觉表示方面显示出令人印象深刻的结果，这极大地缓解了视觉 Transformer 的注释饥饿问题。给定一张图像，这些方法通常首先通过屏蔽一些patch来破坏它。以开创性的工作 BEiT 为例，每张图像在预训练期间都有两个视图，即图像块和视觉token。原始图像首先被标记为离散标记。随机采样的图像块在被馈送到视觉Transformer之前被屏蔽。预训练的目标是根据损坏的图像块恢复原始视觉token。在预训练视觉编码器后，可以通过附加轻量级任务层直接在各种下游任务上微调模型。
在 mask-then-predict 框架下，与以往工作的主要区别在于重建目标，例如视觉token、原始像素和手工制作的 HOG 特征。然而，恢复低级监督往往会浪费建模能力来预训练高频细节和短程依赖关系。例如，当mask戴在男人头上的“帽子”时，我们更喜欢模型在给定整个上下文的情况下学习被掩盖的“帽子”的高级概念，而不是在像素级细节上苦苦挣扎。相比之下，语言建模中的掩码词通常被认为具有比像素更多的语义。这促使通过在预训练期间利用语义感知监督来挖掘 MIM 的潜力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51f6aaaab13a8c84d30e19d16771c7e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87576984fbfbcdbd9d7b5a2120541eb9/" rel="bookmark">
			ArrayList底层源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、ArrayList概述二、ArrayLIst的实现1.ArrayList的属性2.ArrayList集合的构造方法3.集合扩容原理解析（add(E e)方法）4.get(int index) 方法5.set(int index , E e) 方法6.remove(int index) 方法7.size()方法8.indexOf(Object o) \ lastIndexOf(Object o)方法 三、总结 前言 提示：这里可以添加本文要记录的大概内容：
ArrayList 是一个动态数组，实现了 List 接口以及 list相关的所有方法，它允许所有元素的插入，包括 null。另外，ArrayList 和 Vector 除了线程不同步之外，大致相等。
提示：以下是本篇文章正文内容，下面案例可供参考
一、ArrayList概述 首先看如下注释（为ArrayList类开头注释内容）：
/** * Resizable-array implementation of the &lt;tt&gt;List&lt;/tt&gt; interface. Implements * all optional list operations, and permits all elements, including * &lt;tt&gt;null&lt;/tt&gt;. In addition to implementing the &lt;tt&gt;List&lt;/tt&gt; interface, * this class provides methods to manipulate the size of the array that is * used internally to store the list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87576984fbfbcdbd9d7b5a2120541eb9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/211/">«</a>
	<span class="pagination__item pagination__item--current">212/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/213/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>