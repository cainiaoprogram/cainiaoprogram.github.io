<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/753ddd212787819a5db42df10eaf8c50/" rel="bookmark">
			【ESP32&#43;freeRTOS学习笔记-(六)软件定时器】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、软件定时器概念2、软件定时器的运行机制2.1 组成2.2 创建2.3 运行 3、软件定时器的属性和状态3.1 定时器的周期3.2 定时器的类型3.3 定时器的状态 4、软件定时器的回调函数原型5、定时器的使用5.1 创建定时器xTimeCreate()5.2 启动定时器xTimerStart()5.3 终止定时器xTimerStop()5.4 定时器重置xTimerReset()5.5 实例5.5 定时器停止运行xTimerStop()5.6 删除定时器xTimerDelete()5.7 改变定时器周期 6 Timer ID6.1 定时器ID的概念6.2 定时器ID的应用场景6.3 定时器ID的初始化6.4 设置定时器ID vTimerSetTimerID()6.5 查询定时器ID值6.6 实例 7 总结 1、软件定时器概念 软件定时器用于在未来的某个设定时刻安排功能的执行，或以固定的频率定期执行某个功能。软件定时器执行的函数称为软件定时器的回调函数。
软件定时器由 FreeRTOS 内核实现并受其控制。它们不需要硬件支持，并且与硬件定时器或硬件计数器无关。
软件定时器不使用任何处理时间，除非软件定时器回调函数实际正在执行。
软件定时器功能是可选择的：1、要包含 FreeRTOS/Source/timers.c文件到你的项目中去。2、 在FreeRTOSConfig.h文件中，设置宏configUSE_TIMERS 为 1 。
2、软件定时器的运行机制 2.1 组成 软件定时器的功能组成的实质是两个部件：
一个是，定时器命令队列（Timer Command Queue）；
一个是，RTOS守护进程任务（RTOS Deamon Task），该任务过去被称为“计时器服务任务(Timer Service task)”，因为最初它只用于执行软件计时器回调函数。现在，相同的任务也用于其他目的，因此它被称为“RTOS守护程序任务”这一更通用的名称。
2.2 创建 软件定时器的运行部件必须是由系统创建的。具体是在调度程序vTaskStartSchedule()函数运行时，创建定时器的命令队列，以及处理该队列的RTOS守护进程任务。该任务一般优先级是大于1，高于其它系统自动创建的任务，例如系统自动创建的空闭任务。
针对守护进程的优先级，是可以设置的，在标准的FreeRTOS中，是在FreeRTOSConfig.h中的宏 configTIMER_TASK_PRIORITY进行设置，而在ESP-IDF for VSCode中，使用menuconfig去设置。设置选项如下：
2.3 运行 这样，每个tick中断，调度器会去调度RTOS守护进程任务，并在该任务里确定哪个定时器到期，并执行哪个定时器对应的回调函数，以处理定时器到期任务。
此时，如果有高于RTOS守护进程任务的其它任务正在执行，则会出现延迟处理定时器到期任务的情况。或者如果定时器对应的回调函数里有长时间运行的行为，比如出现了阻塞，则也会影响其它的定时器到期任务。
注意事项：
因此，实际在编程时，如果有用到定时器，一定要注意， 以上这两种情况。即高于优先级数值1的其它优先级任务一定要有阻塞机制，使系统可以正常及时的调度RTOS守护进程。
另一个注意事项就是定时器的回调函数决不能进入阻塞状态。软件定时器回调函数在 FreeRTOS 调度程序启动时自动创建的RTOS守护进程任务中运行。因此，软件定时器回调函数绝对不能调用会导致调用程序进入阻塞的 FreeRTOS API 函数。可以调用xQueueReceive()等函数，但前提是函数的xTicksToWait参数（指定函数的阻塞时间）设置为0。不可以调用vTaskDelay()等函数，调用vTaskDelay() 将始终将调用任务置于阻塞状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/753ddd212787819a5db42df10eaf8c50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/564d974b1e82b3eae85d66a3be783642/" rel="bookmark">
			C语言编程学生成绩管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、介绍
二、功能
1.录入学生
2.删除学生信息
3.修改学生信息
4.查询学生信息
5.所有学生信息
6.成绩排序
7.退出程序
三、代码
1.主函数
2.头文件
3.函数封装库
一、介绍 利用C语言，运用链表、指针、封装函数等基本知识实现一个学生管理系统。通过在终端对学生信息进行一系列操作。
基本思想流程图如下：
基本参数：
二、功能 1.录入学生 通过输入选项 0 匹配功能，进入录入学生信息的程序，将学生的信息录入到程序。 相关函数：
int insert_stu(Class_t *cls) 程序运行结果：
2.删除学生信息 通过输入选项 1 匹配功能，进入删除学生信息的程序，对指定学生的信息删除。
相关函数：
int delete_stu(Class_t *cls) 程序运行结果：
3.修改学生信息 通过输入选项 2 匹配功能，进入修改学生信息的程序，对指定学生的信息进行修改。 相关函数：
int update_stu(Class_t *cls) 程序运行结果：
4.查询学生信息 通过输入选项 3 匹配功能，进入查询学生信息的程序，将指定学生的信息打印出来。 相关函数：
int select_stu(Class_t *cls) 程序运行结果：
5.所有学生信息 通过输入选项 4 匹配功能，进入遍历学生信息的程序，将所有学生的信息打印出来。 相关函数：
void print_all_stu(Class_t *cls) 程序运行结果：
已提前录入aa、bb、cc、dd、ee相关信息。
6.成绩排序 通过输入选项 5 匹配功能，进入成绩排序的程序，将所有的学生按照总成绩降序排序，并打印所有学生的信息。 相关函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/564d974b1e82b3eae85d66a3be783642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/061aa40cbacba900ebe681860c731e92/" rel="bookmark">
			源文件声明规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 源文件声明规则 一个源文件中只能有一个 public 类一个源文件可以有多个非 public 类源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Student，那么源文件应该命名为Student.java。如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 类有若干种访问级别，并且类也分不同的类型：抽象类和 final 类等。
除了上面提到的几种类型，Java 还有一些特殊的类，如：内部类，匿名类。
Java 包 包主要用来对类和接口进行分类。当开发 Java 程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。
import 语句 在 Java 中，如果给出一个完整的限定名，包括包名、类名，那么 Java 编译器就可以很容易地定位到源代码或者类。import 语句就是用来提供一个合理的路径，使得编译器可以找到某个类。
例如，下面的命令行将会命令编译器载入 java_installation/java/io 路径下的所有类
import java.io.*; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64d021f50737c85df933984bdaf860b7/" rel="bookmark">
			超出盒子高度或者出现滚动效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇主要是通过 内容超出盒子高度后，盒子大小不变，内容以滚动的方式去呈现，三行代码！ 盒子类名 { max-height: 500px; // 你可以设置固定或者最大最小高度 overflow: hidden; // 隐藏超出部分 overflow-y: scroll;// 设置纵向滚动效果，x为横向 } 添加滚动条类似业务在开发中还是比较常见的，对于不爱记代码的程序员来说，这样每天积累一些，也方便自己查找
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cce7036c6020e61bb870fb94071eb417/" rel="bookmark">
			WongKinYiu-yolov7 训练自己的数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码链接：https://github.com/WongKinYiu/yolov7
① 先看一下结果 Class Images Labels P R mAP@.5 mAP@.5:.95: 0%| | 0/8 [00:00&lt;?, ?it/s] Class Images Labels P R mAP@.5 mAP@.5:.95: 12%|█▎ | 1/8 [00:00&lt;00:03, 1.84it/s] Class Images Labels P R mAP@.5 mAP@.5:.95: 25%|██▌ | 2/8 [00:01&lt;00:04, 1.49it/s] Class Images Labels P R mAP@.5 mAP@.5:.95: 38%|███▊ | 3/8 [00:02&lt;00:03, 1.36it/s] Class Images Labels P R mAP@.5 mAP@.5:.95: 50%|█████ | 4/8 [00:03&lt;00:03, 1.33it/s] Class Images Labels P R mAP@.5 mAP@.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cce7036c6020e61bb870fb94071eb417/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c97c0e9752ecb8301ee6c2f2dba358a/" rel="bookmark">
			[微积分]“1^∞”型极限求法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77e94bb6afc3e39cfcda60a3c988268a/" rel="bookmark">
			Android wifi开发包含列表获取点击连接wifi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：编译sdk版本 minSdk 21
targetSdk 28
亲自测试，在Android10上正常使用
包依赖
implementation 'com.thanosfisherman.elvis:elvis:3.0' api 'com.thanosfisherman.wifiutils:wifiutils:1.6.2' 2.activity界面
package com.xiaoya.bluetooth.wifi.pages; import android.Manifest; import android.app.Activity; import android.content.Context; import android.content.pm.PackageManager; import android.net.wifi.ScanResult; import android.net.wifi.WifiConfiguration; import android.net.wifi.WifiManager; import android.os.Bundle; import android.os.Looper; import android.os.Message; import android.util.Log; import android.view.View; import android.widget.CompoundButton; import android.widget.Switch; import android.widget.Toast; import androidx.annotation.NonNull; import androidx.core.app.ActivityCompat; import androidx.core.content.ContextCompat; import androidx.recyclerview.widget.LinearLayoutManager; import androidx.recyclerview.widget.RecyclerView; import com.hb.dialog.myDialog.MyAlertInputDialog; import com.thanosfisherman.wifiutils.WifiUtils; import com.thanosfisherman.wifiutils.wifiScan.ScanResultsListener; import com.xiaoya.bluetooth.R; import com.xiaoya.bluetooth.wifi.adapter.WifiListAdapter; import com.xiaoya.bluetooth.wifi.bean.WifiBean; import com.xiaoya.bluetooth.wifi.deal.ConnectionManager; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77e94bb6afc3e39cfcda60a3c988268a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cb7b9c0690034982dd1bd98e17ca821/" rel="bookmark">
			配置正确但是 Aria2 RPC 服务器错误解决方案 2023
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 适用于 Windows 系统（Linux/MacOS 也不会遇到这些问题吧……）
检查 hosts 文件中是否为 127.0.0.1 设置别名 localhost
（可将 Aria2 JSON-RPC 地址的 localhost 改为 127.0.0.1 看是否可行）检查端口号是否对应正确（默认 6800）检查 Aria2 是否正常启动（查看 aria2c log，把 ERROR 处理掉）Aria2 for YAAW 无法连接，但 Aria2Ng 连接正常：
换用 WebSocket 协议：将 Aria2 JSON-RPC 地址改为 ws:// 开头 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378a330c51c5932d69fa3c5c27e8a4c6/" rel="bookmark">
			Python网络编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络编程 基本概念 IP地址 IP是Internet Protocol Address，即“互联网协议地址”。
用来标识网络中的一个通信实体的地址。通信实体可以是一个计算机、路由器等。如互联网的每个服务器都要有自己的IP地址，而每个局域网的计算机要通信地址也要配IP地址。
路由器是连接两个或多个网络的网络设备。
IP地址就像是我们的家庭住址一样，如果你要写信给一个人，你就要知道他（她）的地址，这样邮递员才能把信送到。计算机发送信息就好比是邮递员，它必须知道唯一的“家庭地址”才能不至于把信送错人家。只不过我们的地址是用文字来表示的，计算机的地址用二进制数字表示。 IP地址被用来给Internet上的电脑一个编号。大家日常见到的情况是每台联网的PC上都需要有IP地址，才能正常通信。我们可以把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，而Internet中的路由器，就相当于电信局的“程控式交换机”。
类别最大网络数IP地址范围单个网段最大主机数私有IP地址范围A126（2^7-2）1.0.0.1-127.255.255.2541677721410.0.0.0-1.0.255.255.255B16384（2^14）128.0.0.1-191.255.255.25465534127.16.0.0-172.31.255.255C2097152（2^21）192.0.0.1-223.255.255.254254192.168.0.0-192.168.255.255 IPV4，采用32位地址长度，只有大约43亿个地址，它只有4段数字，每一段最大不超过255。随着互联网的发展，IP地址不够用了，在2019年11月25日IPv4位地址分配完毕。
IPv6采用128位地址长度，几乎可以不受限制地提供地址。按保守方法估算IPv6实际可分配的地址，整个地球的每平方米面积上仍可分配1000多个地址。
IP地址实际上是一个32位整数（称为IPv4），以字符串表示的IP地址如192.168.0.1实际上是把32位整数按8位分组后的数字表示，目的是便于阅读。
IPv6地址实际上是一个128位整数，它是目前使用的IPv4的升级版，以字符串表示类似于2001:0db8:85a3:0042:1000:8a2e:0370:7334
windows下，我们可以通过命令ipconfig获取网卡信息。（Linux和Mac，是ifconfig）通过ping查看网络连接： ping www.baidu.com 查看是否能上公网ping 192.168.1.100 查看是否和该计算机在同一个局域网ping 127.0.0.1 查看本机网卡是否可用 公有地址 公有地址（Public address）由Inter NIC（Internet Network Information Center互联网信息中心）负责。这些IP地址分配给注册并向Inter NIC提出申请的组织机构。通过它直接访问互联网。
私有地址 私有地址（Private address）属于非注册地址，专门为组织机构内部使用。
以下列出留用的内部私有地址
A类 10.0.0.0–10.255.255.255
B类 172.16.0.0–172.31.255.255
C类 192.168.0.0–192.168.255.255
端口 端口号用来识别计算机中进行通信的应用程序。因此，它也被称为程序地址。
一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地进行数据传输。
端口分配 端口是虚拟的概念，并不是说在主机上真的有若干个端口。通过端口，可以在一个主机上运行多个网络应用程序。 端口的表示是一个16位的二进制整数，对应十进制的0-65535。
操作系统中一共提供了0~65535可用端口范围。
按端口号分类：
公认端口（Well Known Ports） 从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯明确表明了某种服务的协议。例如：80端口实际上总是HTTP通讯。
注册端口（Registered Ports） 从1024到65535。它们松散地绑定于一些服务。也就是说有许多服务绑定于这些端口，这些端口同样用于许多其它目的。例如：许多系统处理动态端口从1024左右开始。
网络通信协议 国际标准化组织(ISO，即International Organization for Standardization)定义了网络通信协议的基本框架，被称为OSI（Open System Interconnect，即开放系统互联）模型。要制定通讯规则，内容会很多，比如要考虑A电脑如何找到B电脑，A电脑在发送信息给B电脑时是否需要B电脑进行反馈，A电脑传送给B电脑的数据格式又是怎样的？内容太多太杂，所以OSI模型将这些通讯标准进行层次划分，每一层次解决一个类别的问题，这样就使得标准的制定没那么复杂。OSI模型制定的七层标准模型，分别是：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层。
网络协议的分层 虽然国际标准化组织制定了这样一个网络通信协议的模型，但是实际上互联网通讯使用最多的网络通信协议是TCP/IP网络通信协议。
TCP/IP 是一个协议族，也是按照层次划分，共四层：应用层，传输层，互连网络层，网络接口层（物理+数据链路层）。
把用户应用程序作为最高层，把物理通信线路作为最低层，将其间的协议处理分为若干层，规定每层处理的任务，也规定每层的接口标准。
TCP和UDP传输数据的区别 TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/378a330c51c5932d69fa3c5c27e8a4c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d10336414f2aa0e5634df75400d732b8/" rel="bookmark">
			Error resolving template [currentUserCartItems], template might not exist or might not be accessible...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题背景 远程调用其他微服务的请求
二、报错截图如下 三、我的项目配置如下 四、分析问题 漏了注解@ResponseBody 因为远程返回的都是json，返回String字符串将会被当做Thymeleaf模板的名称去找对应的html模板文件，但找不到该模板文件，所以会出现上述错误
五、问题原因 忘记添加注解@ResponseBody了
六、解决方式 添加@ResponseBody注解就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca10b0cab2050695703bf8e0dbb336c4/" rel="bookmark">
			关于pycharm本地终端打不开的解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 pycharm点击终端不能正常启动，显示提示：
Cannot open Local Terminal
Failed to start [/bin/bash, ……] in 项目路径
解决路径 查找原因 帮助-在Caja中显示日志-打开idea.log日志文件
可以看到：
Caused by: java.lang.UnsatisfiedLinkError: Unable to load library ‘/opt/apps/com.apps.pycharm-community/files/lib/pty4j-native/linux/x86_64/libpty.so’:
/opt/apps/com.apps.pycharm-community/files/lib/pty4j-native/linux/x86_64/libpty.so: 无法打开共享对象文件: 没有那个文件或目录
解决方式 1.打开terminal终端，输入以下内容：
git clone https://github.com/JetBrains/pty4j.git 2.下载完成后，输出以下命令，生成libpty.so文件
cd pty4j/native gcc -fPIC -c *.c gcc -shared -o libpty.so *.o 3.把libpty.so文件复制到pycharm目录中
/opt/apps/com.apps.pycharm-community/files/lib/pty4j-native/linux/x86_64/
重新启动pycharm，终端成功运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fecd2c538544994fe254b80e9e9039a8/" rel="bookmark">
			Java定时注解@Scheduled的使用，fixedDelay，fixedRate，cron的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java定时注解@Scheduled的使用，fixedDelay，fixedRate，cron的使用 问题背景参数简介项目创建测试结果心得Lyric：咸咸的汗水 问题背景 项目中经常使用定时任务，spring提供了定时注解，很方便就可以使用
注意事项
可以直接复制代码，也可以下载源码进行参考 参数简介 1 一个cron表达式有至少6个（也可能7个），使用空格分隔时间元素
按顺序依次为：[秒] [分] [小时] [日] [月] [周] [年]
秒（0~59）分钟（0~59）小时（0~23）天（月）（0~31，但是你需要考虑你月的天数）月（0~11）天（星期）（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）年份（1970－2099） 2 其中每个元素可以是一个值(如6)，一个连续区间(9-12)，一个间隔时间(8-18/4)(/表示每隔4小时)，一个列表(1,3,5),通配符。由于"月份中的日期"和"星期中的日期"这两个元素互斥的，必须要对其中一个设置
设置用例：
*/5 * * * * ? 每五秒一次0 */5 * * * ? 每五分一次0 0 10,14,16 * * ? 每天上午10点，下午2点，4点0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时0 0 12 ? * WED 表示每个星期三中午12点0 0 12 * * ? 每天中午12点触发0 15 10 ? * * 每天上午10:15触发0 15 10 * * ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fecd2c538544994fe254b80e9e9039a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b381eb5462adf507074ef7107fdac1d5/" rel="bookmark">
			前端项目-小米商城
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首页的展示 首页的功能 1、搜索栏模糊查询 在我在输入框输入关键字的时候，会匹配关键字，如果我的存放的数据里面包含这些关机键字就会显示出来。做到模糊查询的效果。
2、实现搜索功能 在首页的搜索框点击搜索的时候，就会对你输入的关键字进搜索，比如你搜小米12，就会拿着这个关键词，用get请求，去访问小米官方商城的后端搜索接口，实现搜索功能。
3、轮播图（切换广告/海报） 这个轮播图每过3秒就会自动切换广告，我们也可以点击两边的按钮，实现上一张到下一张的切换的功能。当我们鼠标移动到图片上，会停止切换，失去焦点的时候继续自动播放。
4、秒杀功能 秒杀的倒计时实现，可以设置一个固定时间然后对这个时间进行倒计时，比如对12点进行倒计时，那么现在凌晨一点多分，所以显示还剩22小时。
5、吸顶 这个顶部这个标签的搜索栏，会在你浏览网页的时候从上面滚出来，原本是固定在页面最上面，当年往下浏览商品，他会慢慢出来，你可以在页面的任何地方用到这个搜索的功能和点击到这个标签栏的每个按钮。
商品详情页 放大镜功能 我们鼠标移入左侧图片的时候，会出现白色半透明阴影代表你放大的位置，然后右边会出现方大的细节的图片，然后当年移动鼠标，就可以改变要放大的位置，实现放大镜的效果。
购物车页面 购物车可以全选和单选你之前加购的商品中要支付的商品，然后根据选择计算出商品总数量和总价格，也可以对商品数量手动输入和加减号改变数量，之后小计也会跟着改变。还可以删除商品功能，删除后会重新计算总价和总数，也可以确认购买和全部清楚。
注册表单校验 可以对注册表表单的每个输入框进行校验，让输入的值必须复合规范才能提交，不然提交失败。
已经把项目开源到码云 我已将本次的JavaScript实训项目开源到gitee免费提供给大家学习，大家自行下载
用html-css-js做的小米商城: 用html、css、js做的小米官方商城的项目
SSH：git@gitee.com:pengzhanhong/front-end-of-xiaomi-mall.git
希望对大家有帮助，有用的麻烦点赞、收藏、关注，谢谢
我将会分享更多自己平时做过的项目和笔记
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e98700526bec099c69e37def9ab0983c/" rel="bookmark">
			Pivoting跳板攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跳板攻击（Pivoting）是Meterpreter提供的一种攻击方法，允许从Meterpreter终端攻击网络中的其他系统。假如攻击者成功的入侵了一台主机，他就可以任意的利用这台机器作为跳板攻击网络中的其他系统，或者访问由于路由问题而不能直接访问的内网系统。
上图是测试拓扑，服务器1作为跳板机，尝试攻击服务器2。
获得meterpreter以后可以使用run get_local_subnets获取目标主机的内网IP段情况。
需要注意的是在session中的meterpreter环境下输入route命令执行结果是被控主机的路由表；
这是命令帮助。
需要执行background或ctrl+z把会话放到后台，回到msf会话。
在msf命令行下可以执行route，查看帮助：
使用方法：
添加完以后使用ping或者traceroute命令还是不通，因为ping和traceroute命令调用的是系统命令，流量不会走会话，或者我没找到走会话的方法。
msf内部的模块可以走额外添加的路由。
这是设置的结果。
这时候可以使用扫描模块测试结果。
msf6 &gt;
use auxiliary/scanner/smb/smb_version
set rhosts 192.168.1.0/24
set threads 100
run
可以看到已经成功扫描到主机。
如果要更加自动化的完成这一操作，可以在执行exploit命令之前选择使用load auto_add_route命令。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16a7592b987da820f11bd006a79306f6/" rel="bookmark">
			mybatis的ExecutorType.BATCH模式批量插入SqlServe/2012下 70w条数据与JDBC批量插入方式对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、需求描述2、功能设计2.1、使用JDBC方式批量操作2.2、使用mybatis的ExecutorType.BATCH模式进行批量操作2.3、遇到的问题2.4、数据库现象对比 3、问题解决4、总结： 1、需求描述 根据算法模型那边返回的大量数据，程序中某个功能需要实现50-100w行数据的update或者insert操作。 2、功能设计 2.1、使用JDBC方式批量操作 private void testInsertJDBCReportEoh(List&lt;ReportEoh&gt; reportEohList) { List&lt;ReportEoh&gt; reportEohs = reportEohList; Connection connection = sqlSessionTemplate.getSqlSessionFactory().openSession().getConnection(); PreparedStatement preparedStatement = null; try { connection.setAutoCommit(false); preparedStatement = connection.prepareStatement("insert into SCPS.REPORT_EOH_copy1(SCENARIO_ID, ID, NAME, PERIOD, AG, PRODUCT_FAMILY, OWNER, LOCATION, STAGE, SELENE_ATTRIBUTE, PART_LEVEL, MRP_CONTROLLER, PART_NUMBER, CPN, CCT, CRI, MATERIAL_DESCRIPTION, LIFE_CYCLE, IS_ERP_PART, BIN, TARGET_SAFETY_STOCK, STD_COST, STORAGE, STORAGE_COST, INFLOW, OUTFLOW, BIN_ORIGINAL, ORDER_NUMBER, ITEM_NUMBER, OPTION_CODE) values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)"); for (int i = 0; i &lt; reportEohs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16a7592b987da820f11bd006a79306f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ccb772304689104636aa53ef52a58f3/" rel="bookmark">
			交通标识检测综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、现代交通的发展现状 随着社会科学技术的高速发展，每年因为交通事故去世的人大幅增加。根据世界卫生组织给出的数据，汽车面世到现在，全球因车祸造成的死伤人数已超过 3000 万。每年因车祸造成的死亡人数为 120 多万人，这确实是令人感到震惊。具体数据如下图：
2014 年-2020 年中国发生交通事故数量及死亡人数
其交通事故的发生，很大程度上是因为交通标识的障碍导致对于路况信息的错误判断而引起的交通事故。交通标志检测的难点主要分为以下四点：
道路上的交通标志处于复杂的环境下，其中复杂的天气情况，例如雨、雾、阳光直射等环境。光照影响在不同时间段不同空间位置都存在明显差别。这些都给交通标志检测识别造成困难。
针对交通标志常年暴露在外，颜色会褪色，也会发生被遮挡和倾斜情况，交通标志通常设置在公路的两侧，绿化灌木、建筑物、电线杆等会遮挡交通标志，行人或者车辆移动等会遮挡到相机的拍摄视角。这些都给交通标志的检测识别带来难点。
针对交通标志种类繁杂，颜色不一，在拍摄时候同一幅图片中出现多种标志，给交通标志检测识别带来难度。
拍摄方位的影响，拍摄方位不同会使交通标志发生变形、模糊、几何失真、畸变等情况，不利于对交通标志实时进行检测和识别。
所以，对于减少交通事故的发生，交通标志检测对于国家和社会至关重要。设计出一款高实时性，高准确率的交通标志检测系统，是我们解决交通事故频频发生问题的首要大事。
二、交通标识检测的分类 在交通标志识别系统中，交通标志检测是一项重要的技术。在分析了道路交通标志检测技术发展的基础上，将其划分为二大类：基于传统的检测方法和基于深度学习的检测方法
目前主流的交通标志检测算法分类如图：
相比于传统的交通检测算法，基于深度学习的检测算法具有更好的实时性和准确性。基于深度学习的检测算法主要分为两类：one-stage和two-stage，one-stage是直接根据输入得到输出，而two-stage在输入得到输出的过程中，多一步在特征中预选一部分特征，也就是预选框。one-stage和two-stage方法的比较如下：
三、交通标志检测系统的改进方向 根据目前的发展趋势，未来的交通标识检测必然是建立在深度学习学习的基础上。在我看来，交通标识检测系统的改进主要在交通标识检测的图片预处理和算法的优化，提高模型的泛化能力。对于图像预处理，我的想法是可否使用超分辨率图像重建、低光增强、直方图均衡化、图像锐化等技术对含有交通标识的图片进行处理，更好的对图片进行特征的提取，得到更多有用的特征；对于算法的研究，我个人比较倾向与现在运用更为广泛的YOLO系列，然后想办法对YOLO的网络构架进行优化，现在有很多学者，研究人员对YOLO算法进行改进，去做目标的检测，取得了较为不错的效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42e0e56c73caacd804f4f8ca10edd7bf/" rel="bookmark">
			如何在 Git 中保存用户名和密码？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问： 我想在 Git Extensions、Sourcetree 或任何其他 Git GUI 中自动使用推送和拉取功能，而无需每次都在提示中输入我的用户名和密码。
那么如何在 Git 中保存我的凭据呢？
答1: huntsbot.com洞察每一个产品背后的需求与收益，从而捕获灵感
注意：此方法以明文形式将凭据保存在您的 PC 磁盘上。您计算机上的每个人都可以访问它，例如恶意 NPM 模块。
跑
git config --global credential.helper store 然后
git pull 提供用户名和密码，稍后将记住这些详细信息。凭据存储在磁盘上的文件中，具有“仅用户可读/可写”的磁盘权限，但仍以明文形式。
如果您想稍后更改密码
git pull 会失败，因为密码不正确，git然后从~/.git-credentials文件中删除有问题的用户+密码，所以现在重新运行
git pull 提供一个新密码，以便它像以前一样工作。
对于 Debian/Ubuntu 使用 libsecret stackoverflow.com/questions/36585496/…
请注意，这会将您的用户名和密码存储在 ~/.git-credentials 的纯文本文件中。任何人都可以打开它并阅读它。
如果您想忘记，请使用它： git config --global credential.helper forget
我认为值得指出的是，人们可能希望跳过 --global 以仅存储一个存储库的密码（在拉取和推送时），而不是存储任何其他存储库的密码（可能位于不同的主机上，具有不同的凭据）可能出于任何原因不想存储）
@RoboAlex 的评论很受欢迎，但对 ~/.git-credentials 的保护与像 ~/.ssh/id_rsa 这样的私钥没有什么不同。因此，如果您的私钥上没有密码，那么 ~/git-credentials 并不比 ssh 密钥差
答2: huntsbot.com提供全网独家一站式外包任务、远程工作、创意产品分享与订阅服务!
您可以使用 git config 在 Git 中启用凭证存储。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42e0e56c73caacd804f4f8ca10edd7bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8a0dfe9c26876228e6dc18d9373ca14/" rel="bookmark">
			Kafka消息中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka消息中间件 同时市场上也发展处ActiveMq、RabbitMQ、Kafka、RocketMQ、Pulsar等众多优秀的框架；在大数据领域中Kafka目前是使用较多的框架。Kafka作为内部消息通知的框架，可以适应项目中大数据量的高吞吐、实时流计算等功能实现。
分布式消息中间件
虚拟机配置环境 下载完，tar -zxvf 解压
注意：要使用IP访问kafka需要开放host port（本机的ip），在server.properties下面配置：
# Hostname and port the broker will advertise to producers and consumers. If not set, # it uses the value for "listeners" if configured. Otherwise, it will use the value # returned from java.net.InetAddress.getCanonicalHostName(). advertised.listeners=PLAINTEXT://your.host.name:9092 开启：
bin/zookeeper-server-start.sh -daemon config/zookeeper.properties jps bin/kafka-server-start.sh config/server.properties 开启zookeeper可以输入jps看下开启状态，有QuorumPeerMain即可
依赖 &lt;!-- kafkfa --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-streams&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;connect-json&lt;/artifactId &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8a0dfe9c26876228e6dc18d9373ca14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76cecb5ba3d4206cc023179522aaf219/" rel="bookmark">
			达梦数据库参数逻辑介绍及修改方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		达梦数据库参数文件dm.ini 是 存放数据库的初始化参数，包含字符集、页大小、大小写敏感、数据库兼容型参数等信息。
1 查询数据库参数的几种方式 （1）查询 V$DM_INI
select *from V$DM_INI;
（2）查询v$dm_ini
（3）查看dm.ini文本文件
（4）控制台工具查看参数
2 DM参数类型 达梦数据库初始化参数分为只读、 静态和动态三种类型，分别对应v$dm_ini视图中 TYPE列的READ ONLY、 IN FILE、 SYS/SESSION。
READONLY
只读参数，不能进行修改。
INFILE
静态参数,可以通过系统函数或SQL修改,但是只能修改参数文件中的值，不能修改内存中的值,所以静态参数的修改需要重启数据库才能生效。
SESSION
会话级动态参数可以通过系统函数或SQL修改即可以修改内存中的值，也可以修改参数文件的值可以单独对某个会话修改该参数值
SYS
系统级动态参数可以通过系统函数或SQL修改即可以修改内存中的值，也可以修改参数文件的值。修改后影响整个系统。
3 修改方式 3.1 编辑dmini文本文件 vim /dmdata/dmdb/dm.ini 修改完成后保存，数据库后重启生效
3.2 DM控制台工具修改（重启生效) 3.3 SQL语句 alter system set XXX=‘xx’ both|spfile|memory
both:表示修改内存和参数文件中的值；
spfile修改参数文件
memory修改内存
对于静态参数只能使用spfile,对于动态参数皆可使用。
针对会话会话级别，可以对某个会话生效：
3.4系统函数 达梦数据库提供SF_GET_PARA_VALUE、SF_GET_PARA_DOUBLE_VALUE和SF_GET_PARA_STRING_VALUE这三个函数来获取系统的当前配置参数，提供SP_SET_PARA_VALUE和SP_SET_PARA_DOUBLE_VALUE过程来修改静态/动态配置参数。
具体使用方法附后：
1 、SF_GET_PARA_VALUE (scope int, paraname varchar(256))
配置参数的值类型为数值类型时使用该函数来获取当前值。SCOPE 参数为1表示获取INI文件中配置参数的值，为2表示获取内存中配置参数的值。
2 、SF_GET_PARA_DOUBLE_VALUE(scope int, paraname varchar(8187))
配置参数的值类型为浮点型时使用该函数来获取当前值。SCOPE参数为1表示获取INI文件中配置参数的值，为2表示获取内存中配置参数的值。
3 、SF_GET_PARA_STRING_VALUE(scope int, paraname varchar(8187))
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76cecb5ba3d4206cc023179522aaf219/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/902c54c1fcbf1f61ad86d708e0b781c3/" rel="bookmark">
			Python 中的作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变量的作用域是指变量的作用范围，是程序可以访问该变量的正文区域。例如：
g = 123 def function(): print(g) print(g) 程序总共有 6 行在第 1 行，定义了变量 g在第 4 行，在函数 function 内部访问变量 g在第 6 行，在全局范围访问变量 g 因为可以在程序的任意位置（从第 1 行到第 6行）访问到该变量，变量 g 的作用域就是从第 1 行到第 6行的正文区域。
1. 四种作用域 1.1 概述 在 Python 中，存在 4 种类型的作用域：
Builtin 作用域，能够访问内置函数和内置变量的正文区域Global 作用域，能够访问全局变量的正文区域Local 作用域，能够访问函数参数和局部变量的正文区域Enclosing 作用域，如果函数是嵌套定义的，能够访问外部函数的参数和局部变量的正文区域 1.2 Builtin 作用域 Builtin 作用域是能够访问内置函数和内置变量的正文区域。示例说明 Builtin 作用域：
def function(): print(max(1, 2)) print(max(3, 4)) max 是内置函数 它的作用域类型是 Builtin 作用域在第 2 行，在函数 function 内访问它在第 4 行，在全局范围访问它max 的作用域是从第 1 行到第 4 行的文本区域 它的作用域类型是 Builtin 作用域在第 2 行，在函数 function 内访问它在第 4 行，在全局范围访问它 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/902c54c1fcbf1f61ad86d708e0b781c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dde398b3e3f429aedbdc7e670c46fcd/" rel="bookmark">
			【C&#43;&#43;】命名空间 以及 如何理解using namespace std；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
命名空间
1.由来
2.概念
3.使用
方法一
方法二
方法三
4.嵌套使用
命名空间 很多人在学习C++的时候，第一个代码想必是如下样子的。和C语言相比，库函数换了，同时多了一个 using namespace std； 但是，你真的了解 using namespace std; 的真实作用吗？去掉 using namespace std; 会有什么影响呢？一定要加上这句话，才可以完整地打出一个Hello World 程序吗？有没有不加的办法？还是老师说要加上这句话，于是就加了。
如果对于前面的问题，你都理解了，那么很遗憾，本篇内容不是为你准备的。如果你并不知道，并且你也想了解它们，那么恭喜你，本文的内容就是为你而准备的！
#include&lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; "Hello World!" &lt;&lt; endl; return 0; } 1.由来 我们知道，C++起初是Bjarne Stroustrup博士在C语言的基础上，不断加入新的特性产生的。那么C++肯定是为了弥补C语言的一些不足之处。那么命名空间是为了解决C语言的什么问题呢？
我们看到下面左右两边的程序，右边相比于左边上面的，多了一行包含 stdlib.h 的头文件，就报错了，并且错误信息也在下方——“rand” 重定义。很容易联想到，stdlib.h 库里面是有 rand 函数的，我们可以用来生成随机数，那么就是自定义的全局变量名，和库里面的变量名冲突了。但是，我们将这个 rand 变量放到 main 函数内部，让它成为局部变量，就没有这个问题。这是因为，stdlib.h 是在全局域里面的，如果定义全局变量 rand，那么该变量也在全局域，自然会发生冲突，但是如果相同的名字，一个在全局域一个在局部域，就不会冲突。又比如两个不同的函数里面，都定义了 int a; 变量，也是可以的。
与此同时，如果在一个项目组里面，组内成员分别负责不同板块的代码编写。如果组员A 和 组员B 都使用 Add 作为某个函数的函数名，或者是起了相同名字的变量（全局）等等，那么最后项目汇总起来，也会报错。
所以，C语言在这方面会产生两个主要的问题，一是自己定义和库里面的名字冲突；二是项目组里面，多个人之间的名字冲突。为了解决这个问题，博士就在C++里面加上了命名空间这一概念，命名空间是唯一识别的一套名字，这样当对象来自不同的地方但是名字相同的时候就不会含糊不清了。
2.概念 命名空间定义的实际上是一个域，这个域相当于在全局域的基础之上，又加了一层域，就是命名空间域。并且，命名空间只影响其内部的变量，函数等等的使用，不影响生命周期。上面讲到，同一个域里面不可以有同名变量，但是不同的域里面可以有。那么定义了命名空间，增加出来的命名空间域，就可以解决上面的问题。假设一个组里面有A、B两个人写代码，A将他的代码放到 A域 里面，B将他的代码放到 B域 里面，这也即使两个人定义了同名变量，也不影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dde398b3e3f429aedbdc7e670c46fcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/323751c6f2993da3a3b853f97e75484c/" rel="bookmark">
			服务器开卷机慢解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程服务器 开机出现 Raise network interface
操作如下
进入系统后修改文件/etc/systemd/system/network-online.target.wants/networking.service
命令：sudo vim /etc/systemd/system/network-online.target.wants/networking.service
将里面的TimeoutStartSec=5min 修改为TimeoutStartSec=2sec --------------------- 本文来自 Pipci 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/pipcie/article/details/79504764?utm_source=copy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7699d7eb85aeab49b7a2d84021d62895/" rel="bookmark">
			文献阅读（4）：手写数字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、简介
1.题目：
2.时间：
3.来源：
4.简介：
5.论文主要贡献：
二、相关名词
三、 相关背景知识
1.阵列处理器
2.Xilinx
四、处理流程概述
1.基于可重构阵列处理器的近数据计算结构：
2.实现手写数字识别所用的CNN结构：
3.实验效果分析与结论
一、简介 1.题目： 基于近存储计算的手写数字识别实时检测阵列结构设计
2.时间： 2022.12
3.来源： Journal of Optoelectronics · Laser（光电子·激光）
4.简介： 图像识别中最经典的问题之一 —— 手写数字识别，使用深度学习中的卷积神经网络进行手写数字识别具有更高的准确率，但随之而来的是更加密集的计算和存储，这些都在限制CNN快速高效地实现。该论文在可重构陈列处理器的基础上，利用NMC阵列和数据并行化计算，实现了CNN计算加速，通过降低处理器和主存之间的数据通信实现了手写数字的实时检测。
5.论文主要贡献： 基于可重构阵列处理器的NMC结构，通过CNN并行计算的方法实现了手写数字识别。CNN中最耗费计算资源的卷积运算，本文的实验结果表明提出的方法降低访存延迟以及提高了卷积运算速度，执行单个卷积运算的计算速度比以往研究平均提高了75%。
二、相关名词 ASIC：application specific integrated circuit，专用集成电路
FPGA：filed programmable gate array，现场可编程门阵列
DDR：double data rate，双倍速率同步动态随机存储器
PE：process element，处理元
三、 相关背景知识 1.阵列处理器 阵列处理器（array processor），是用来对大量数据执行计算的处理器，其余还有Multiprocessors（多处理器）和 vector processors（矢量处理器），当有大量数据（如矩阵计算）陈列处理器才最有优势。
阵列处理器可以分为两类：
1.Attached Array Processors
2. SIMD(Single Instruction Stream, Multiple Data Stream) Array Processors
大多数阵列处理器在矢量计算上比主机CPU更快，而且可以与CPU异步运行，因此可以提高系统的整体性能。除此之外，阵列处理器具有自己的本地内存，可以为内存有限的系统提供额外内存。可重构阵列处理器（Reconfigurable array processor），可以在运行时通过配置流程来动态改变PE阵列的功能，然后利用数据流驱动PE。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7699d7eb85aeab49b7a2d84021d62895/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1764fb90cd80d4335f1fcc7af38eff4/" rel="bookmark">
			【Nacos】- Mac-M1下Nacos安装及Nacos启动报错“have ‘x86_64’,need ‘arm64e‘”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nacos安装及Nacos启动报错“have ‘x86_64’,need 'arm64e'” nacos下载启动nacos问题描述解决方案1、下载安装x86架构的jdk2、更换nacos版本：我这是更换为1.4.2的 nacos下载 下载地址：https://github.com/alibaba/nacos/releases
根据自己的工具及需要版本下载即可；
启动nacos 下载好解压之后，打开终端并进入bin目录，执行启动命令
sh startup.sh -m standalone 出现starting with standalone 说明启动成功；
可以访问http://127.0.0.1:8848/nacos/#/login，nacos可视化界面，初始账号密码都是nacos；
问题描述 开始下载了nacos，配置了数据库和jdk环境后去sudo sh startup.sh -m standalone，报如下错误；
看到error create bean，可能开始以为是自己的JDK的环境没配好，检查一下jdk版本，这一步骤也是有必要的，最终的解决方案也是跟jdk安装版本有关，报错信息最后，我们可以看到报错信息是：“ have ‘x86_64’,need ‘arm64e’ ”,架构不兼容，查阅资料后了解到nacos 2.0版本后在mac m1上如果不是x86架构的JDK会启动失败；
解决方案 知道问题出现的原因，就好解决了，架构不兼容的两种解决方案：
1、下载安装x86架构的jdk 下载地址：https://www.azul.com/downloads/?version=java-8-lts&amp;os=macos&amp;architecture=x86-64-bit&amp;package=jdk
根据自己的需求查找对应版本的jdk,直接下载安装即可：
2、更换nacos版本：我这是更换为1.4.2的 输入启动命令：sh startup.sh -m standalone，以单机模式启动，显示：starting with standalone 说明启动成功
我们访问验证一下：http://127.0.0.1:8848/nacos/#/login
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d126ea062aafa4232b1d0b3aa0f8497e/" rel="bookmark">
			Java 解决 ERROR StatusLogger No log4j2 configuration file found 异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 问题 在本地 Idea 调试代码的时候抛出了如下一个异常：
ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console. 2. 解决方案 从上面异常提供的信息看到没有找到 log4j2 配置文件，将使用默认配置：只将错误记录到控制台。很容易的看出我们在代码中使用到了 log4j，但是没有发现相应的配置文件。解决方案就是在 resouces 资源目录下提供配置文件，在这我们提供了一个名为 log4j2.properties 的配置文件：
rootLogger.level = INFO rootLogger.appenderRef.console.ref = ConsoleAppender appender.console.name = ConsoleAppender appender.console.type = CONSOLE appender.console.layout.type = PatternLayout appender.console.layout.pattern = %d{HH:mm:ss,SSS} %-5p %-60c %x - %m%n 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de5678f3860bf0b88f1b72368a051803/" rel="bookmark">
			Linux应用编程---8.共享内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux应用编程—8.共享内存 ​ 共享内存是进程之间通讯的方式。大概原理是先申请一块共享内存，然后通过“映射”，映射到进程中。进程中读写这块被映射过来的内存，共享内存也会随之改变，同理其它进程也能做相同的操作。所以，两个不同的进程通过共享内存实现了通讯。
8.1 创建共享内存 ​ 创建共享内存，使用到的库函数是：shmget(),是：share memory get的缩写。在Linux编程手册中查看这个函数。
NAME shmget - allocates a System V shared memory segment SYNOPSIS #include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt; int shmget(key_t key, size_t size, int shmflg); ​ shmge()函数，用来分配一个“System v”的共享内存段。使用时需要包含头文件：sys/ipc.h与sys/shm.h。函数原型是：int shmget(key_t key, size_t size, int shmflg);需要传入3个参数，返回值是int类型的。
DESCRIPTION shmget() returns the identifier of the System V shared memory segment associated with the value of the argument key. It may be used either to obtain the identifier of a previously created shared memory segment(when shmflg is zero and key does not have the value IPC_PRIVATE), or to create a new set.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de5678f3860bf0b88f1b72368a051803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36d55934da4880366255e4628ef78e6f/" rel="bookmark">
			C#文件操作集合四（文件复制和移动）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 文件操作是开发过程中经常遇到的，如何创建文件、处理文件、保存文件以及读取文件这些工作是每一位开发都必须经历的。
这里围绕C#文件操作内容，我做了一次系统的梳理，主要包括以下几个模块：
1、文件内容操作：文件读写相关
2、文件检测
3、文件及目录创建和删除
4、文件复制和移动
5、文件加密、解密
6、文件上传、下载
7、文件压缩相关
8、文件操作权限相关
一、小节摘要 本节整理了文件复制和移动相关内容，使用了File类和Directory类。
二、详细内容 1.移动文件(剪贴--粘贴) /// &lt;summary&gt; /// 移动文件(剪贴--粘贴) /// &lt;/summary&gt; /// &lt;param name="dir1"&gt;要移动的文件的路径及全名(包括后缀)&lt;/param&gt; /// &lt;param name="dir2"&gt;文件移动到新的位置,并指定新的文件名&lt;/param&gt; public static void MoveFile(string dir1, string dir2) { dir1 = dir1.Replace("/", "\\"); dir2 = dir2.Replace("/", "\\"); if (File.Exists(HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir1)) File.Move(HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir1, HttpContext.Current.Request.PhysicalApplicationPath + "\\" + dir2); } #endregion 2.复制文件 /// &lt;summary&gt; /// 复制文件 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36d55934da4880366255e4628ef78e6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae8c97dce239dbb53f998773997579d1/" rel="bookmark">
			sqli-labs 第七关 多命通关攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqli-labs 第七关 多命通关攻略 描述字符串与数值之间的转换判断注入类型返回结果正常输入不正常输入错误输入 总结判断注入类型判断是否为字符型注入判断是否为单引号字符型注入判断是否为双引号字符型注入 判断是否为数值型注入 总结判断注入类型（修正版）字符型注入判断是否为单引号字符型注入判断是否为双引号字符型注入 真的只需要正确闭合引号即可吗 判断 SQL 查询结果中的列数猜测 SQL 查询结果中的列数为两列猜测 SQL 查询结果中的列数为三列猜测 SQL 查询结果中的列数为四列 爆破爆破方式的可行性1. 报错注入2. 布尔盲注3. 时间盲注4. 数据导出注： 数据导出secure_file_priv查看参数 secure_file_priv 对应的值因 secure_file_priv 的取值不同所造成的不同影响 into outfile使用 into outfile 来导出文件 into dumpfileinto dumpfile 与 into outfile 的区别 load_file()注修改 secure_file_priv配置文件 my.ini权限问题修改文件夹权限问题总结求索（追求和探索）复制权限设置验证可行性组或用户名 Users结论 尝试进行数据导出 描述 项目描述操作系统Windows 10 专业版MySQL 版本MySQL 5.7.40Apache 版本Apache 2.2.39 字符串与数值之间的转换 MySQL 在遇到需要数值时你却提供给它字符串的情景下，会自动将字符串转换为数值。
转换方式如下：
‘a’ 转换为 0
‘1a’ 转换为 1
‘2b3’ 转换为 2
判断注入类型 返回结果 正常输入 ?id=1 返回结果为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae8c97dce239dbb53f998773997579d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebb21847c7ea481c8e231bd3faa49238/" rel="bookmark">
			机器学习-11.神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EduCoder：机器学习—神经网络 第1关：什么是神经网络 第2关：神经元与感知机 编程要求：
根据提示，在右侧编辑器补充 python 代码，构建一个感知机模型，底层代码会调用您实现的感知机模型进行训练，并对一个特征值分别为青绿、稍蜷、沉闷（即特征向量为[0,2,2]）的西瓜的好坏进行预测，预测正确则通关。
代码如下：
#encoding=utf8 import numpy as np #构建感知机算法 class Perceptron(object): def __init__(self, learning_rate = 0.01, max_iter = 200): self.lr = learning_rate self.max_iter = max_iter def fit(self, data, label): ''' input:data(ndarray):训练数据特征 label(ndarray):训练数据标签 output:w(ndarray):训练好的权重 b(ndarry):训练好的偏置 ''' #编写感知机训练方法，w为权重，b为偏置 self.w = np.random.randn(data.shape[1]) self.b = np.random.rand(1) #********* Begin *********# for i in range(len(label)): while label[i]*(np.matmul(self.w,data[i])+self.b)&lt;=0: self.w=self.w+self.lr*(label[i]*data[i]) self.b=self.b+self.lr*label[i] #********* End *********# return None def predict(self, data): ''' input:data(ndarray):测试数据特征 ''' #编写感知机预测方法，若是正类返回1，负类返回-1 #********* Begin *********# yc=np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebb21847c7ea481c8e231bd3faa49238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbee4616917b039f7b12121dcc247781/" rel="bookmark">
			机器学习-8.线性回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EduCoder：机器学习—线性回归 第1关：简单线性回归与多元线性回归 第2关：逻辑回归的损失函数 编程要求：
该实战内容中数据为一元数据，利用 pandas 读入数据文件，并为相应的数据附上名字标签，分别为Population 和 Profit。
data = pd.read_csv(path, header= , names=[ ' ', ' ' ]) 代码如下：
#encoding=utf8 import os import pandas as pd if __name__ == "__main__": path = os.getcwd() + '/ex1data1.txt' #利用pandas读入数据data，并将数据属性分别命名为'Population'和'Profit' #********* begin *********# data=pd.read_csv(path,header=None,names=['Population','Profit']) #********* end *********# print(data.shape) 第3关：计算损失函数 编程要求：
根据以上公式，编写计算损失函数computeCost(X, y, theta)，最后返回cost。
X：一元数据矩阵，即Population数据；y：目标数据，即Profit数据；theta：模型参数；cost：损失函数值。 代码如下：
#encoding=utf8 import numpy as np def computeCost(X, y, theta): #根据公式编写损失函数计算函数 #********* begin *********# inner=np.power(((X*theta.T)-y),2) cost=np.sum(inner)/(2*len(X)) #********* end *********# return cost 第4关：进行梯度下降得到线性模型 编程要求：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbee4616917b039f7b12121dcc247781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f246ed52438975332864697c140d2fd3/" rel="bookmark">
			机器学习-5.模型评估、选择与验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EduCoder：机器学习—模型评估、选择与验证 第1关：为什么要有训练集与测试集 第2关：欠拟合与过拟合 第3关：偏差与方差 第4关：验证集与交叉验证 第5关：衡量回归的性能指标 第6关：准确度的陷阱与混淆矩阵 编程要求：
根据提示，在 Begin-End 区域填写 python 代码，完成 confusion_matrix 函数实现二分类混淆矩阵的构建。
confusion_matrix 函数中的参数：
y_true：数据的真实类别，类型为 ndarray；
y_predict：模型预测的类别，类型为 ndarray。
测试说明：
平台会对你编写的代码进行测试，期望您的代码根据输入来输出正确的混淆矩阵，以下为其中一个测试用例（y_true 表示真实类别，y_predict 表示预测类别）：
测试输入：
{‘y_true’:[1, 0, 0, 1, 0, 1, 0], ‘y_predict’:[0, 1, 0, 1, 0, 1, 0]}
预期输出：
[[3 1]
[1 2]]
代码如下：
import numpy as np def confusion_matrix(y_true, y_predict): ''' 构建二分类的混淆矩阵，并将其返回 :param y_true: 真实类别，类型为ndarray :param y_predict: 预测类别，类型为ndarray :return: shape为(2, 2)的ndarray ''' #********* Begin *********# def TN(y_true,y_predict): return np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f246ed52438975332864697c140d2fd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b71dbecfbcc063dc3c9ca29595cdb03/" rel="bookmark">
			机器学习-4.朴素贝叶斯分类器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EduCoder：机器学习—朴素贝叶斯分类器 第1关：条件概率 第2关：贝叶斯公式 第3关：朴素贝叶斯分类算法流程 编程要求：
根据提示，完成fit与predict函数，分别实现模型的训练与预测。（PS:在fit函数中需要将预测时需要的概率保存到self.label_prob和self.condition_prob这两个变量中）
其中fit函数参数解释如下：
feature：训练集数据，类型为ndarray；
label：训练集标签，类型为ndarray；
return：无返回。
predict函数参数解释如下：
feature：测试数据集所有特征组成的ndarray。（PS：feature中有多条数据）；
return：模型预测的结果。（PS：feature中有多少条数据，就需要返回长度为多少的list或者ndarry）。
代码如下：
import numpy as np class NaiveBayesClassifier(object): def __init__(self): ''' self.label_prob表示每种类别在数据中出现的概率 例如，{0:0.333, 1:0.667}表示数据中类别0出现的概率为0.333，类别1的概率为0.667 ''' self.label_prob = {} ''' self.condition_prob表示每种类别确定的条件下各个特征出现的概率 例如训练数据集中的特征为 [[2, 1, 1], [1, 2, 2], [2, 2, 2], [2, 1, 2], [1, 2, 3]] 标签为[1, 0, 1, 0, 1] 那么当标签为0时第0列的值为1的概率为0.5，值为2的概率为0.5; 当标签为0时第1列的值为1的概率为0.5，值为2的概率为0.5; 当标签为0时第2列的值为1的概率为0，值为2的概率为1，值为3的概率为0; 当标签为1时第0列的值为1的概率为0.333，值为2的概率为0.666; 当标签为1时第1列的值为1的概率为0.333，值为2的概率为0.666; 当标签为1时第2列的值为1的概率为0.333，值为2的概率为0.333,值为3的概率为0.333; 因此self.label_prob的值如下： { 0:{ 0:{ 1:0.5 2:0.5 } 1:{ 1:0.5 2:0.5 } 2:{ 1:0 2:1 3:0 } } 1: { 0:{ 1:0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b71dbecfbcc063dc3c9ca29595cdb03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cd3e7a233915898ea8bb5192de5373a/" rel="bookmark">
			java写一段程序，自动检测文件的字符集并返回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是使用 Java 语言检测文件字符集的一个示例程序：
import java.io.BufferedInputStream; import java.io.FileInputStream; import java.io.IOException; import java.nio.charset.Charset; import java.util.Arrays; import org.mozilla.universalchardet.UniversalDetector; public class DetectFileEncoding { public static void main(String[] args) throws IOException { if (args.length != 1) { System.err.println("Usage: java DetectFileEncoding &lt;file&gt;"); System.exit(1); } String fileName = args[0]; byte[] buf = new byte[4096]; // 创建字符集检测器 UniversalDetector detector = new UniversalDetector(null); // 打开文件 BufferedInputStream input = new BufferedInputStream(new FileInputStream(fileName)); // 使用字符集检测器检测文件的字符集 int nread; while ((nread = input.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cd3e7a233915898ea8bb5192de5373a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fe639ff53f9f1227ac4f60423ac4241/" rel="bookmark">
			YOLOX可视化训练工具（webyolox）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年旷视研究院推出的YOLOX算法性能相当可以，给的源码条理也非常清晰，嵌入式部署也非常方便，但无论如何，训练的时候部署数据集还有相应环境等还是很费时间的，所以做了个网页端管理界面，能够帮你节省很多时间。
项目地址在此给出：webyolox项目地址
项目详细使用方法视频介绍：[Bilibili]webyolox: 极简风格可视化网页，轻松搞定YOLOX的训练部署过程！
如果想快速开始，在装好pytorch相关环境（torch、torchvision、torchaudio[可选]）的情况下，只需要在命令行输入以下命令即可
Linux命令行 sudo apt install screen git clone https://github.com/LSH9832/webyolox cd webyolox pip3 install -r requirements.txt python3 main.py -p 8080 --debug Windows CMD git clone https://github.com/LSH9832/webyolox cd webyolox pip install -r requirements.txt python main.py -p 8080 --debug 然后打开浏览器，输入地址 127.0.0.1:8080
回车
输入用户名和密码，初始都是admin
登录后界面是这样，当然刚开始没有任何训练配置，点击创建新的训练配置即可
为你的这次训练配置起个名字，并输入数据集的绝对目录地址。
注意：目前只支持COCO格式的数据集，也就是在数据集的主目录下，文件夹annotations（注意文件夹的名字一定是annotations）里放json标签文件，然后其他文件夹分别放训练集图片和验证集图片（文件夹名字不限，两个集合的图片所在文件夹可以相同）。与此同时，数据集主目录下一定要放一个类别文件，并命名为classes.txt，每行写好类别的名称，中间和结尾不要有空行（格式见./yolox/coco_classes.txt） 附上COCO2017数据集下载地址
训练集图像（18G）
验证集图像（1G）
测试集图像（6G）
训练集/验证集标签（241M）
想要使用预训练模型文件开始训练的同学请到 yolox原项目 里面下载，这里给出链接。
yolox_s.pth
yolox_m.pth
yolox_l.pth
yolox_x.pth
yolox_tiny.pth
yolox_nano.pth
如果使用的是非COCO数据集，类别不是80个，训练开始时只能导入backbone，则到本项目的release里下载backbone权重文件 点此进入 。然后将下载好的权重文件放入文件夹weight下。
然后就开始基本的配置了。
按照自己的需求和硬件条件自己填就好了，然后点提交，就保存成功并回到主界面了。
点击修改超参数进入如下界面
如果想每个epoch训练完后都进行验证集的验证，把最后的验证间隔由10改成1就行了，点击提交回到主界面。
点击开始训练即可，这时该配置列表上会显示“查看训练日志”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fe639ff53f9f1227ac4f60423ac4241/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae69f92614a6157f2c429635d2e978ec/" rel="bookmark">
			image2LCD（图像取模软件）无效的输入图像（bitmap image is not valid）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 用这个软件在导入图片进去时，会提示无效的输入图片，无论你用什么格式JPG、BMP都不行，换了其他图像取模软件一样不行，应该是图像的问题。
解决方案： 先把该图片导图到图画、或者ps等作图软件，再导出，软件就能识别了。（我自己是用wps图片编辑器导出的，成功解决）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeb5f4bfa0a0dd74fae1cc538ede791d/" rel="bookmark">
			flowable数据表详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫组件分析 目录概述需求： 设计思路实现思路分析1.flowable2.数据表的命名规则3.ACT_RU_*4.ACT_ID_*5.ACT_HI_*数据表的介绍 参考资料和推荐阅读 Survive by day and develop by night.
talk for import biz , show your perfect code,full busy，skip hardness,make a better result,wait for change,challenge Survive.
happy for hardess to solve denpendies.
目录 概述 网络爬虫的是一个非常常见的需求。
需求： 1.URL管理
2. 网页下载器
3. 爬虫调度器
4. 网页解析器
5. 数据处理器
设计思路 实现思路分析 1.flowable 我们在接入flowable框架的时候，运行项目如果数据库没有flowable自带的表会自动创建出来，总共60张表，每张表都有其作用，下面会具体介绍表的用途。
2.数据表的命名规则 ACT_RE_*
’RE’表示repository（存储）。RepositoryService接口操作的表。带此前缀的表包含的是静态信息，如，流程定义，流程的资源（图片，规则等）。
3.ACT_RU_* ’RU’表示runtime。这是运行时的表存储着流程变量，用户任务，变量，职责（job）等运行时的数据。flowable只存储实例执行期间的运行时数据，当流程实例结束时，将删除这些记录。这就保证了这些运行时的表小且快。
4.ACT_ID_* ’ID’表示identity(组织机构)。这些表包含标识的信息，如用户，用户组，等等。
5.ACT_HI_* ’HI’表示history。就是这些表包含着历史的相关数据，如结束的流程实例，变量，任务，等等。
数据表的介绍 普通数据，各种情况都使用的数据。
表分类 表名 描述
运行实例表(10)
运行实例表
ACT_RU_DEADLETTER_JOB 正在运行的任务表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeb5f4bfa0a0dd74fae1cc538ede791d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d8f18defbaf5d6aa8d08be67da43753/" rel="bookmark">
			【js模块化import export语法总结】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js模块化import export语法总结 内置的模块化语法export导出import导入import导入的模块都是引用 内置的模块化语法 内置的语法使得开发人员可以在浏览器中使用模块化，但是需要在script标签中使用type="module"属性告知浏览器使用的是模块化
export导出 默认导出命名导出各种导出的语法之间不会相互影响，可以有任意多个导出默认导出只能有一个 export { name1, name2, …, nameN }; export { variable1 as name1, variable2 as name2, …, nameN }; export let name1, name2, …, nameN; // also var export let name1 = …, name2 = …, …, nameN; // also var, const export function FunctionName() {...} export class ClassName {...} export default expression; export default function (…) { … } // also class, function* export default function name1(…) { … } // also class, function* export { name1 as default, … }; //合并模块 //有时你会想要将模块聚合在一起。您可能有多个级别的依赖项，您希望简化事物，将多个子模块组合到一个父模块中。这可以在父模块中使用以下的导出语法： // 这实际上是导入后跟导出的简写，即“我导入模块 x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d8f18defbaf5d6aa8d08be67da43753/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dbe4fc45b4541198914b813a551466e/" rel="bookmark">
			qt如何使用qss设置按钮宽高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Qt(即Qt Quick)是一个用于开发跨平台图形用户界面的库。QSS(Qt Style Sheets)是一种语言，可以用来描述控件的样式。
要在Qt中使用QSS设置按钮的宽度和高度，可以使用以下方法：
使用QSS文件：创建一个名为"style.qss"的文件，在文件中写入以下代码： QPushButton {width: 100px; height: 50px; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35bdd144d8e660f5dfc5741316cc61d9/" rel="bookmark">
			基于Flask&#43;PaddleOCR实现的通用OCR服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是PaddleOCR PaddleOCR 是一个开源项目，旨在打造一套丰富、领先、且实用的OCR工具库，助力开发者训练出更好的模型，并应用落地。是基于深度学习技术实现的，所以使用时需要训练好的权重文件，但这个不需要我们担心，官方已为我们提供了。
项目Github地址: PaddleOCR地址
安装PaddleOCR # requirements.txt paddlehub==2.2.0 paddlepaddle==2.3.1 # 安装 pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple 代码实现 paddleocr实现文字识别核心代码
def ocr_img(images: list, remote=False): """ 识别多张图片，如果remote=True，则下载远程图片，如果remote=False，则直接将图片对象传入 :param images: 图片列表 :param remote: 释放远程 :return: """ try: result = [] for i in range(0, len(images), 5): _img_paths = images[i: 1 + 5] ocr_model = get_ocr_model() print('ocr_model',ocr_model) img_paths = [] if remote: for url in _img_paths: img_name = download_img(url) if not img_name: continue img_paths.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35bdd144d8e660f5dfc5741316cc61d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/711f59183aaba48a195055b6c417d35a/" rel="bookmark">
			C语言递归及经典例题详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是递归？
什么时候使用递归
例题1 顺序打印问题
例题2 求n的阶乘
例题3 求第n个斐波那契数
经典 汉诺塔问题
经典 青蛙跳台阶问题 什么是递归？ 递归就是程序调用自身的编程技巧。递归通常把一个大型复杂的问题层层转化为一个与原问题相似，规模较小的问题来求解。递归策略只需要少量的程序就可以描述出解题过程所需要的多次重复的计算，大大减少程序的代码量。
递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。
什么时候使用递归？ 1、大问题可以拆分成若干小问题。
2、原问题与子问题除数据规模不同，求解思路完全相同。
3、存在递归终止条件。
4、当不满足终止条件时，要如何缩小函数值，并让其进入下一层循环中。
例题1 顺序打印问题： 输入一个整数123，依次在屏幕打印1 2 3 代码：
#include &lt;stdio.h&gt; void print(int n) { if (n &gt; 10) { print(n / 10); } printf("%d ", n%10); } int main() { int n = 0; scanf_s("%d", &amp;n); print(n); return 0; } 例题分析：本题的思路不断拆分整数，并将他们一一打印，只要n&gt;10,就另n不断除以10，不断的递归调用n/10，当n&lt;10时，满足递归终止条件，令n%10，此时我们得到的是此数的最高位。当打印完最高位时返回，继续打印不一定是个位数，所以%10只保留个位。
例题2 求n的阶乘： 代码：
int Fac(int n) { if (n == 1) { return 1; } return n*Fac(n - 1); } int main() { int n = 0; scanf_s("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/711f59183aaba48a195055b6c417d35a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43571bd309355085bf03e8bde990aab9/" rel="bookmark">
			写一段C语言程序实现对数据库中的学生记录按姓名排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你好! 这是一段可以帮助你实现对数据库中学生记录按姓名排序的 C 语言程序:
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #define MAX_STUDENTS 100 typedef struct student { char name[20]; int age; } Student; int compare_students_by_name(const void* student1, const void* student2) { const Student* s1 = (const Student*)student1; const Student* s2 = (const Student*)student2; return strcmp(s1-&gt;name, s2-&gt;name); } int main() { Student students[MAX_STUDENTS]; int num_students = 0; // 从数据库中读取学生记录 // 代码省略 // 对学生记录进行排序 qsort(students, num_students, sizeof(Student), compare_students_by_name); // 打印排序后的学生记录 for (int i = 0; i &lt; num_students; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43571bd309355085bf03e8bde990aab9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e37a9468dcc9efa4ab7c88084e9835c2/" rel="bookmark">
			Vue3/ Vue3 计算属性computed函数 语法 与 介绍 、Vue3 Vue2computed计算属性 能不能传参 怎么传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. Vue3 计算属性computed函数 语法 与 介绍 语法: // 第一种语法get方法 （没有set） const 函数名 = computed(() =&gt; {
return }) // 第二种语法 get set 方法 带有set参数 可以设置 const 函数名 = computed(() =&gt; { get() { return 结果 }, set( val ){ } }) 触发场景: 如果要访问计算属性 会自动执行 get如果要修改计算属性 会自动执行 set 简介: get函数就等同于简单写法的函数胡 计算属性必须要有 get 而且需要 return 来返回结果set方法第一个参数 可以监听用户输入 新值 与 旧值 注意: 修改计算属性时需要使用完整写法也就是上面语法内第二种写法修改时会自动执行set函数获取数据时会自动执行get函数 二. Vue3 Vue2computed计算属性 能不能传参 怎么传参 传参结构: &lt;div&gt;{{ selfAge(2025, '20k') }}&lt;/div&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e37a9468dcc9efa4ab7c88084e9835c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6004f08b12f3337348fe7aa7abb47ee/" rel="bookmark">
			RNN循环神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RNN循环神经网络 前言一、基本结构RNN公式![在这里插入图片描述](https://img-blog.csdnimg.cn/d2709e9180d1427d9f6349591ecbe204.png)RNN特点RNN种类双向RNN网络(BRNN)堆叠循环神经网络 传统RNN缺点记忆时间短 长短时记忆网络 LSTMLSTM的变种Peephole LSTM门控循环单元 GRU门控循环单元 GRU 三、示例代码 前言 用于处理序列数据的神经网络
语音，视频，文字应用领域
自然语言处理NLP
机器翻译
语音识别
图像描述生成 提示：以下是本篇文章正文内容，下面案例可供参考
一、基本结构 RNN公式 RNN特点 权值共享，图中的W全是相同的，U和V也一样。每一个输入值都只与它本身的那条路线建立连接，不会和别的神经元连接 RNN种类 一对一结构普通神经网络
多对多词性标注 一对多音乐生成和文章生成
SeqToSeq机器翻译
双向RNN网络(BRNN) He is Tom Wody,one human
He is Tom cat,one animal。
公式 堆叠循环神经网络 传统RNN缺点 记忆时间短 梯度消失和梯度爆炸
我爱北京天安门，____上太阳升我昨天上学迟到了，老师批评了____，我出生在美国，父母都是亚洲人，我爱好篮球，我能说一口流利的______ 长短时记忆网络 LSTM LSTM的变种 Peephole LSTM 门控循环单元 GRU 门控循环单元 GRU 更新门：遗忘门和输入门合并，决定了哪些信息丢失输入哪些信息保留，捕捉长期依赖关系重置门：将记忆单元和隐藏层合并，决定了过去的信息有多少保留下来，捕捉短期依赖关系
三、示例代码 https://github.com/anglersking/simple_deep_learning/tree/master/RNN
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86b902029251619735f0de86c9e17267/" rel="bookmark">
			如何用c&#43;&#43;解析 Gcode代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gcode是用于控制机械设备的标准化计算机数控编程语言，可用于制造加工、3D打印、机器人控制等领域。解析Gcode代码可以使用c编写程序，具体步骤如下：
首先，你需要打开Gcode文件并将其读入程序。你可以使用fopen()和fgets()函数来实现这一点。
然后，你需要对Gcode文件的每一行进行解析。Gcode文件每行通常包含一个Gcode指令和一些参数。你可以使用sscanf()函数将每行的指令和参数分离出来。
之后，你需要根据读取到的指令和参数执行相应的操作。这可能需要使用一些条件判断语句来确定应该执行哪些操作。
最后，你可以将解析后的Gcode指令和参
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f38bc3f38be6741cb05e737c60a1d26f/" rel="bookmark">
			Pandas中的字符串和时间转换与格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas 提供了若干个函数来格式化时间。
把字符串转为时间格式 其中，最常用的是 to_datetime() 函数。
可以使用 to_datetime() 函数将一个字符串解析为时间，并指定字符串的格式。例如：
import pandas as pd # 将字符串 "2022-01-01" 转为时间格式 time = pd.to_datetime("2022-01-01", format="%Y-%m-%d") print(time) 输出：
&lt;class 'pandas._libs.tslibs.timestamps.Timestamp'&gt;:2022-01-01 00:00:00 把时间格式化为字符串 还可以使用 strftime() 函数将时间格式化为字符串。例如：
import pandas as pd # 将时间 "2022-01-01 00:00:00" 格式化为字符串 time_str = pd.to_datetime("2022-01-01 00:00:00").strftime("%Y-%m-%d") print(time_str) 输出：
&lt;class 'str'&gt;:2022-01-01 格式化某一列的时间为字符串 如果想要格式化某一列中的时间，可以使用 pandas 的 to_datetime 函数。
例如，假设你有一个名为 df 的数据，并且你想要格式化其中一列名为 “Date” 的时间列，你可以这样做：
df['Date'] = pd.to_datetime(df['Date']) 这将会将 “Date” 列中的所有时间转换为 Pandas 的时间数据类型。你也可以指定一个特定的时间格式，例如：
df['Date'] = pd.to_datetime(df['Date'], format='%Y-%m-%d %H:%M:%S') 这将会将 “Date” 列中的所有时间按照指定的格式转换为 Pandas 的时间数据类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f38bc3f38be6741cb05e737c60a1d26f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54400a277cd016bbcc8f18b94af2e08f/" rel="bookmark">
			基于51单片机的舵机控制（PWM）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.舵机介绍 舵机是一种位置伺服的驱动器，常被用于遥控汽车、机器人等领域，结构主要包括小型直流电机、变速齿轮组、可调电位器和控制电路板四个部分，如下图，舵机的外部一般接有三根线，分别是黑（接地线）、红（电源线）、棕（白或者黄，信号线）三种颜色进行区分。
2.舵机工作原理 2.1-基准信号 舵机的内部有一个基准电路，可以产生周期为20ms且宽度为1.5ms的基准信号，由信号发生器或者单片机发出信号，舵机内部电路则将获得的直流偏置电压与电位器的电压进行比较，获得一个电压差输出，然后经由舵机内部电路板上的IC来判断转动方向，之后驱动马达转动，通过减速齿轮组将动力输出至摆臂，同时由位置检测器送回信号，判断是否已经到达指定位置。
2.2-转动角度 舵机的转动角度是通过调节PWM（脉冲宽度调制）信号的占空比来实现的标准PWM信号的周期固定为20ms，频率50Hz，以常见的9g舵机为例，脉宽在0.5ms和2.5ms之间调节就对应着舵机转角的0°~180°，如下图：
对应关系如下：
3.PWM的实现 void Timer0_Init()//定时器0初始化 { TMOD = 0X01; //设置定时器模式 TH0 = (65536-500)/256; //设置定时器初值 TL0 = (65536-500)%256; ET0 = 1; //允许定时器0中断 TR0 = 1; //启动定时器0 EA = 1; //打开总中断 } void Timer0_Int() interrupt 1//定时器0的中断服务函数 { TR0 = 0; //关闭定时器0 TH0 = (65536-500)/256; //设置定时器初值 TL0 = (65536-500)%256; counter++; if(counter &gt;= 40) //20ms到了 { counter = 0; } if(counter &lt; angle) { Pwm_val = 1; } else { Pwm_val = 0; } TR0 = 1; //启动定时器0 } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54400a277cd016bbcc8f18b94af2e08f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6dd852f4d41b46ab91ca49a7a448a97/" rel="bookmark">
			SpringBoot自定义配置的提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 引入依赖2. 开启 IDEA 配置3. 使用 @ConfigurationProperties 自定义配置4. 编译项目，自动生成 spring-configuration-metadata.json 文件文件中的属性值介绍 5. 可以看到有提示了 官方文档：https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/html/appendix-configuration-metadata.html#configuration-metadata-annotation-processor
1. 引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 2. 开启 IDEA 配置 在 idea 设置中搜索 Annotation Processors ，接下来勾住 Enable annonation processing 就完成了。
3. 使用 @ConfigurationProperties 自定义配置 import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(prefix = "self") @Data public class SelfConfiguration { private String name; private Integer age; } 需要开启自动配置（@EnableConfigurationProperties）和扫描包（@ConfigurationPropertiesScan）：
@SpringBootApplication @EnableConfigurationProperties @ConfigurationPropertiesScan("com") public class SpringboottestApplication { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6dd852f4d41b46ab91ca49a7a448a97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82dd6eb2bf2b70f971f4187af12a4da6/" rel="bookmark">
			lotus-miner 元数据备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lotus-miner 元数据备份 备份元数据恢复运行矿工--offline 离线备份 备份元数据 设置环境变量，重启 lotus-miner export LOTUS_BACKUP_BASE_PATH=/root/lotus-miner_backup 备份元数据 # lotus-miner backup /root/lotus-miner_backup/backup.cbor Success 拷贝配置文件 config.toml config.toml cd $LOTUS_MINER_PATH cp config.toml storage.json /root/lotus-miner_backup/ cp $LOTUS_MINER_PATH/{config.toml,storage.json} $LOTUS_BACKUP_BASE_PATH # ls lotus-miner_backup/ backup.cbor config.toml storage.json 恢复 在另外一个节点恢复拷贝到$LOTUS_MINER_PATH目录下 cp config.toml storage.json /nfstore/miner/ 拷贝扇区数据store修改扇区路径 vim storage.json 修改IP地址 vim config.toml 开始恢复 lotus-miner init restore backup.cbor 运行矿工 nohup lotus-miner run &gt;&gt; /var/log/miner/miner.log 2&gt;&amp;1 &amp; –offline 离线备份 # lotus-miner stop # mkdir miner-backup_04012 # cp -r $LOTUS_MINER_PATH /seal/miner-backup_04012 # lotus-miner backup --offline /seal/miner-backup_04012/2022-04-12/backup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82dd6eb2bf2b70f971f4187af12a4da6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68b689552f35fb7a827f8dd8a032d7d5/" rel="bookmark">
			【pandas】模块——DataFrame数据处理（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataFrame-数据创建与导入 下一篇：dataframe数据筛选(二)
下二篇：dataframe高级用法(三）
这里写目录标题 DataFrame-数据创建与导入一定义1.1 特征1.2 获得DataFrame的两种方式1.3.导出csv文件 二、 数据检查2.1 查考表头和表尾 2.2查看列名 2.3 查看索引 2.4查看行列数 2.5查看数据类型2.6查看空值2.7查看数据表的信息2.8查看唯一值三、 数据清洗3.1缺失值处理3.2清楚空格3.3转换数据格式3.4大小写转换3.5更改列名3.6更改索引 四、 重复值处理4.1查看是否有重复值4.2保留重复值 五、替换值六、数据的增删改6.1 增加行6.2删除行6.3修改行6.4增加列&lt;/font&gt;6.5删除列&lt;/font&gt;6.6修改列&lt;/font&gt; 七、数据集合并 7.1按照公有的列表名为“name"进行合并`merge`7.2按照两个数据指定的列的列名合并`merge`7.3 按照多个键来进行合并`merge`7.4 数据的轴向连接`concat`7.4.1axis=0数据拼接7.4.2纵轴的连接,axis=1 7.5 合并重叠数据 `combine_first` 八、数据分组8.1通过条件判断来进行二分组8.2通过条件判断划分为多个组 &lt;/font&gt; 九、数据割分列与合并列9.11列分割2列 9.2合并 十、排序10.1根据值来排序 `.sort_values() `10.2根据索引来排序 &lt;/font&gt; `.sort_index()`10.3排名 `.rank()` ,红,橙,蓝
一定义 DataFrame是一种表格型的数据结构
姓名类型成绩0张三高中891李四初中90 1.1 特征 第一行为字段,即列名,从第二行开始为一行一行的记录每列可以是不同的值类型(数值/字符串/布尔值等)即有行索引也有列索引 1.2 获得DataFrame的两种方式 A. 自己创建DateFrame
A.1 通过字典的方式创建DataFrame
通过单层字典创建通过嵌套字典创建 import pandas as pd df=pd.DataFrame({'a':[1,3,3,4],'b':[2,3,6,7],'c':[10,2,3,4]}) df 注意
arange(12):其实和arange()差不多,只不过arange是在数组意义上的快速生成数列的方法reshape(3,4):将数组对象按照3行4列的方式排列index:索引columns:列名 A.2 在表格中取列并生成新的表格
索引为字符串 d3=df[[‘站点编号’,‘借车总量’,‘还车总量’]]索引为数字 df[[1,2,3]] B .从外部导入dataframe
导入csv文件 .对于windows系统,在导入数据时可能会遇到一些编码问题,添加参数encoding='gbk’就可以解决大部分情况了导入的文件必须存放在python的当前的路径中如果导入无中文的文件,输入文件名名称即可如果文件中包含中文,则添加encoding=‘gbk’ 对于Excel文件的处理办法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68b689552f35fb7a827f8dd8a032d7d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70298e77a120992e32a66c42ed366a50/" rel="bookmark">
			linux6.8设置时间同步,CentOS6 更改时区方法（以设置 UTC&#43;8 为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为方便平时查看带时间戳的日志/事件，系统常规设置项之一是修改默认时区。不同于 CentOS7 可以用简单一句命令搞定，CentOS6 稍微麻烦了些，下面介绍具体设置方法。
查看当前时区
查询当前系统使用的时区。下面示例输出使用的北美东部夏令时间(EDT，UTC−4 时区)。
[test@localhost ~]$ date
Thu Mar 21 22:30:53 EDT 2019
设置系统时区
使用下面命令设置系统时区，红色部分是时区参数，完整时区名称列表这里有介绍。
# 设置 上海 UTC+8 时区
sudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
# 设置 香港 UTC+8 时区
sudo ln -sf /usr/share/zoneinfo/Asia/Hong_Kong /etc/localtime
# 设置 台北 UTC+8 时区
sudo ln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime
# 设置 北美东部标准 UTC-5 时区
sudo ln -sf /usr/share/zoneinfo/EST /etc/localtime
# 设置 协调世界时 UTC 时区
sudo ln -sf /usr/share/zoneinfo/UTC /etc/localtime
设置硬件时区
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70298e77a120992e32a66c42ed366a50/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/176/">«</a>
	<span class="pagination__item pagination__item--current">177/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/178/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>