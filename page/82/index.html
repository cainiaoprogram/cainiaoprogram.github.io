<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5cb65fa80bbb247e7657a7c170851db/" rel="bookmark">
			【Linux】进程概念与进程状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、进程概念1.进程的概念2.进程的描述-PCB 二、进程相关的基本操作1.组织进程2.查看进程3.结束进程4.通过系统调用获取进程标示符5.通过系统调用创建进程-fork初识 三、进程状态1.普遍操作系统层面的进程状态2.Linux操作系统的进程状态 四、两种特殊的进程状态1.僵尸进程2.孤儿进程 五、进程优先级1.什么是优先级2.为什么要有优先级3.Linux中优先级的特点 六、进程的其他概念七、进程切换 一、进程概念 1.进程的概念 我们通常在课本看到对进程的描述是这样的：一个运行起来(被加载到内存)的程序就叫做一个进程，或者称一个在内存中的程序就被称为进程。进程和程序相比具有动态属性
我们知道，计算机系统为了提高整个计算机的效率，在数据的层面，CPU不会直接和外设打交道，而只会和内存进行交互，同样，外设也只会和内存交互；此外，我们编写的C/C++代码经过编译之后形成的二进制可执行程序在本质上就是一个存放在磁盘上的一个文件，所以当我们需要运行这个程序的时候，就必须先将这个文件加载到内存，这是因为CPU需要从内存中读取程序中的代码和数据进行运算(算数运算和逻辑运算)
在我们的程序加载到内存之后，操作系统需要对程序进行管理，而操作系统对程序的管理本质上是对数据的管理，管理方法为先描述，再组织，所以操作系统会将这个程序的属性用一个结构体来进行表示，然后为每一个进程都创建一个结构体对象，最后再将所有的结构体对象使用某一种数据结构组织起来，比如链表，此时，操作系统对进程的管理就变成了堆数据结构的管理的某个节点的管理，在操作系统中，这个用于描述和组织进程的数据结构被称为进程控制块-PCB
2.进程的描述-PCB 进程控制块PCB（process control block）：操作系统中用于描述进程的工具，进程信息被放在进程控制块的数据结构中，可以理解为进程属性的集合；Linux操作系统下的PCB是: task_struct,task_struct是Linux内核的一种数据结构，它会被装载到RAM(内存)里并且包含着进程的信息。
task_ struct内容分类
标示符: 描述本进程的唯一标示符，用来区别其他进程。
状态: 任务状态，退出代码，退出信号等。
优先级: 相对于其他进程的优先级。
程序计数器: 程序中即将被执行的下一条指令的地址。
内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
上下文数据: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。
I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表。
记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。
其他信息
task_struct可以使用下面的结构体来表示：
struct task_struct { // 进程的所有属性 // 进程对应的代码和数据的地址 // 写一个进程的地址 struct task_struct* next; } Linux中task_struct的部分源码如下：
我们了解task_struct之后，我们可以得出这样的结论：进程=内核数据结构(task_struct)+进程对应的磁盘代码
二、进程相关的基本操作 1.组织进程 所有运行在系统里的进程都以task_struct链表的形式存在内核里。
在Linux中，进程是由操作系统调度和管理的执行中程序。每个进程都被分配了一个唯一的PID(进程标识符)，并且可以包含多个线程。
Linux通过使用进程控制块(PCB)来组织进程。 PCB是一个数据结构，用于存储有关进程状态的信息，如进程ID，优先级，内存映像和打开文件等。 Linux将它们链接成单向链表以跟踪所有处于活动状态的进程。此外，还有其他几个数据结构，如等待队列、可用内存空间和保护时钟中断处理程序等，用于在进程执行过程中监视和管理资源。
总之，在Linux中，操作系统通过组织进程控制块来进行进程调度，使得可以对其进行有效的管理和监视
2.查看进程 我们可以通过下面两种方式来查看进程：
1.ps axj 指令配合grep 和管道查看指定进程
#include &lt;stdio.h&gt; #include &lt;unistd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5cb65fa80bbb247e7657a7c170851db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/531a3d0b16b2a13474c136d8437851c6/" rel="bookmark">
			决策树的调参，比较直观的代码显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from sklearn.tree import DecisionTreeClassifier from sklearn.datasets import load_digits, load_wine from sklearn.model_selection import train_test_split, GridSearchCV, cross_val_score from sklearn.metrics import accuracy_score import numpy as np import matplotlib.pyplot as plt # 第一步，获取数据集 # 获取数据集的特征值x 和 目标属性y dataset = load_digits() x = dataset.data y = dataset.target # 第二步，确定是哪种划分标准好 criterion # 这一步是找出基尼划分标准好，还是熵划分标准好 DT = DecisionTreeClassifier(random_state=66) score = cross_val_score(DT, x, y, cv=10).mean() print("使用基尼划分标准获取到的值为%0.4f"%score) # 使用基尼划分标准获取到的值为0.8252 DT = DecisionTreeClassifier(criterion="entropy", random_state=66) score = cross_val_score(DT, x, y, cv=10).mean() print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/531a3d0b16b2a13474c136d8437851c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de9ea34452bd25477fe50a5482f4e14e/" rel="bookmark">
			CollectionUtils常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/mjtabu/p/12973000.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b618dc5384fb3a6d1a5095543845723/" rel="bookmark">
			大河弯弯：CSS 文档流与三大元素显示模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 参考环境文档流概念三大显示模式 内联元素概念常见的内联元素宽高由内容决定 块级元素概念常见的块级元素宽度受容器影响，高度受内容影响 内联块级元素概念常见的内联块级元素折中方案 设置元素的显示模式display 属性内联元素与块级元素的切换为什么要通过 display 来修改元素的显示模式？ 参考 项目描述搜索引擎Bing、GoogleAI 大模型文心一言、通义千问、讯飞星火认知大模型、ChatGPTMDNMDN Web DocsW3School在线教程 环境 项目描述Chrome118.0.5993.88（正式版本） （64 位）操作系统Windows 10（专业版） 文档流 概念 文档流是指网页上元素的 默认布局顺序。想象你有一本书，这本书中的内容是 从上到下，从左到右 顺序阅读的。同样的，HTML文档的元素默认也是从上到下，块级元素会垂直排列，内联元素会水平排列。
在不使用 CSS 的情况下，浏览器会 按照文档流的规则来摆放元素。当我们使用CSS 中的 float、position、flexbox、grid 等属性时，元素可能会 脱离标准的文档流，形成一个新的布局方式。但为了理解这些高级布局技巧，首先要掌握基本的文档流概念。
三大显示模式 在 CSS 中，显示模式 指的是 HTML 元素在文档流中 如何被渲染和布局的一种特性，不同的显示模式决定了元素如何占据空间以及与其他元素相互交互的方式。CSS 中存在 三种十分常见的显示模式，即块级元素，内联元素，内联块级元素。
内联元素 概念 想象你正在读 一本书，你的目光滑过每一个字母、每一个词，连续不断。内联元素就像这些字词，它们排成一行，直到遇到 边界（页面边缘）才会换行。内联元素之间没有自动的换行，它们的 宽高由内容决定，并不接受我们设置的宽高值。
常见的内联元素 内联元素可以嵌套在块级元素中，或者与其他内联元素一起使用，每个元素都有其特定的语义和样式，可以根据需要自由组合以创建所需的网页内容。
内联元素功能描述&lt;a&gt;创建超链接，用于导航到其他页面或资源。&lt;span&gt;常用于对内联元素进行分组（便于通过 CSS 设置样式）或用于放置文本。&lt;img&gt;用于插入图像。&lt;br&gt;起换行作用。&lt;sub&gt;用于标记需要作为下标的文本，通常用于化学式和数学公式。&lt;sup&gt;用于标记需要作为上标的文本，通常用于指数和脚注。 宽高由内容决定 在 CSS 中，内联元素的宽度和高度通常由其包含的内容决定，这是因为内联元素的主要特点是在文本中水平排列，不会独占一行，并且 只占据其包含的内容所需的空间。这种自动适应内容的行为使内联元素在 包围文本等内容 时非常灵活。元素会随着内容的变化而自动调整大小而 不需要手动指定固定的宽度和高度，这 在处理不同长度的文本或可变内容时非常有用。
举个栗子
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b618dc5384fb3a6d1a5095543845723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/364e653109b1694a4eaced4c0d3b6957/" rel="bookmark">
			FFmpeg视频播放(音视频解码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇中FFmpeg解封装中在TinaFFmpeg中的prepare方法里把解码器上下文AVCodecContext交给VideoChannel,AudioChannel后，解码工作就交给它们来处理了，这节我们来看它们是如何处理的。
解码入口
prepare完成后会调用Java中TinaPlayer的onPrepare的方法，然后回调 PlayActivity的start方法，然后进入native层的start方法:
LOGE("native prepare流程准备完毕"); // 准备完了 通知java 你随时可以开始播放 callHelper-&gt;onPrepare(THREAD_CHILD); //prepare完成后会调用Java中TinaPlayer的onPrepare的方法，然后回调 PlayActivity的start方法，然后进入native层的start方法 //TinaPlayer public void onPrepare(){ if (null != listener){ listener.onPrepare(); } } //PlayActivity tinaPlayer.setOnPrepareListener(new TinaPlayer.OnPrepareListener() { @Override public void onPrepare() { runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText("开始播放").show(); } }); //调用native_start tinaPlayer.start(); } }); //TinaPlayer public void start(){ native_start(); } native层：调用ffmpeg中的start方法，然后分别调用videoChannel、audioChannel的play()方法
extern "C" JNIEXPORT void JNICALL Java_tina_com_player_TinaPlayer_native_1start(JNIEnv *env, jobject instance) { ffmpeg-&gt;start(); } //TinaFFmpeg void TinaFFmpeg::start() { //重新开线程 isPlaying = 1; if (audioChannel) { //设置为工作状态 audioChannel-&gt;play(); } if (videoChannel) { //设置为工作状态 videoChannel-&gt;setAudioChannel(audioChannel); videoChannel-&gt;play(); } pthread_create(&amp;pid_play, 0, play, this); } 兵马未动，粮草先行。把解码需要的数据源packet放入到SafeQueue的同步队列中去：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/364e653109b1694a4eaced4c0d3b6957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ff11a8e8c687113341d63f5941ac4b/" rel="bookmark">
			解决提交到App Store时的ITMS-90478和ITMS-90062错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
正文
1. 什么是ITMS-90478和ITMS-90062错误？
2. 解决方法
2.1 确定当前的版本号和构建号
2.2 递增版本号和构建号
2.3 再次尝试提交应用
总结
参考资料
错误记录
摘要：本文为iOS技术博主分享，将详细介绍解决提交应用到App Store时可能遇到的ITMS-90478和ITMS-90062错误的方法。通过正确设置版本号，避免出现错误，并顺利将应用上架。
引言 作为iOS技术博主，我们经常会面临将自己开发的应用提交到App Store的任务。然而，在提交过程中可能会遇到各种错误，其中ITMS-90478和ITMS-90062错误是比较常见的。这些错误通常与应用的版本号设置相关，下面我将为大家提供解决这些错误的方法。
正文 1. 什么是ITMS-90478和ITMS-90062错误？ 在提交应用到App Store时，如果出现ITMS-90478和ITMS-90062错误，通常是因为当前上传的版本号小于已经上传到App Store的版本号。具体来说，ITMS-90478错误表示上传的版本号小于之前已上传的构建版本号，而ITMS-90062错误表示上传的版本号小于之前已上架的版本号。
2. 解决方法 为了解决ITMS-90478和ITMS-90062错误，我们需要确保新上传的版本号大于之前已上传或上架的版本号。下面是解决方法的具体步骤：
2.1 确定当前的版本号和构建号 首先，我们需要确定当前应用的版本号和构建号。在Xcode中，可以在项目的General设置中找到对应的信息。版本号是由三个数字组成的，如1.0.0，而构建号则是一个单独的数字。
2.2 递增版本号和构建号 接下来，我们需要递增版本号和构建号，确保新上传的版本号大于之前已上传或上架的版本号。根据苹果的规定，版本号应该是递增的，且新上传的构建号必须大于之前已上传的构建号。
2.3 再次尝试提交应用 在完成版本号和构建号的递增后，我们可以重新尝试提交应用到App Store。确保在提交之前，版本号和构建号已经正确设置，并且大于之前已上传或上架的版本号。
为了更加方便提交APP到App Store，我们这边可以用appuploder工具。
APP开发助手 iOS APP上架到App Store的辅助工具，解决iOS APP上架繁琐费时的情况，帮助跨平台APP开发者上架苹果应用,在没有配置Mac苹果机的情况，实现iOS证书申请，创建iOS开发者证书、iOS发布证书等各类证书，iOS开发者在Windows、Linux或Mac系统中上传IPA到App Store,简化iOS APP上架流程！在任何电脑中轻松快速上架你的APP
总结 通过正确设置版本号和构建号，我们可以避免ITMS-90478和ITMS-90062错误的发生，并成功将应用提交到App Store。作为iOS技术博主，我们要时刻关注这些细节，确保应用顺利上架，以提供更好的用户体验。
参考资料 App Store Connect HelpiOS上架工具以上是针对ITMS-90478和ITMS-90062错误的解决方法，希望对大家有所帮助。 错误记录 提交到App Store时，提示ITMS-90478和ITMS-90062错误，通常是当前上传的版本号小于已经上传Ios商店的版本号。要解决此问题，应确保新上传的版本号大于之前已上传的版本号。记住前面数字必须大于你之前的版本号，比如上图显示的build是56，那么你新上传的build数字一定要大于56。
如果你的应用存在这些错误，按照本文提供的步骤进行修改，并在重新提交之前确认版本号和构建号设置正确。这样，你就可以顺利将应用上架到App Store，并为用户提供优质的体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/774c70c09d995613b875cd7537dacc6c/" rel="bookmark">
			王道计算机考研 操作系统学习笔记 &#43; 完整思维导图篇章三: 内存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
内存管理概念
内存的基础知识
什么是内存？有何作用？
补充知识:几个常用的数量单位
指令的工作原理 三种装入方式
绝对装入 可重定位装入 动态重定位 从写程序到程序运行 链接的三种方式 总结
内存管理的概念
内存保护 内存空间的扩充 覆盖技术
交换技术
内存空间的分配与回收 连续分配管理方式
单一连续分配
固定分区分配 动态分区分配
总结
动态分区分配算法
首次适应算法 最佳适应算法 最坏适应算法
邻近适应算法 总结 非连续分配管理方式
基本分页存储管理的基本概念 基本地址变换机构 具有快表的地址变换机构
两级页表 基本分段存储管理
分段、分页管理的对比
段页式管理方式 虚拟内存管理
传统存储管理方式的特征、缺点
虚拟内存的定义和特征 如何实现虚拟内存技术
请求分页管理方式 请求页表 缺页中断
地址转换流程 页面置换算法
最佳置换算法 (OPT)
先进先出置换算法 (FIFO) 最近最久未使用置换算法(LRU)
时钟置换算法 (CLOCK)
改进型CLOCK算法 页面分配策略
驻留集
页面分配、置换策略 页面调动时机策略
页面调动位置策略 抖动（颠簸）现象 内存映射文件 传统文件访问方式
内存管理概念 内存的基础知识 什么是内存？有何作用？ 程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾
补充知识:几个常用的数量单位 指令的工作原理 三种装入方式 绝对装入 可重定位装入 动态重定位 从写程序到程序运行 链接的三种方式 静态链接：程序运行之前，将库函数连接成一个完整的可执行程序装入时动态链接：将用户源程序编译后得到目标模块，装入内存时，采用边装入边链接的方式运行时动态链接：对于某些目标模块的链接，程序需要时才会对其链接 ，便于修改和更新，便于实现对目标模块的共享 总结 内存管理的概念 内存保护 内存空间的扩充 覆盖技术 交换技术 注意: PCB 会常驻内存，不会被换出外存 应该在外存(磁盘)的什么位置保存被换出的进程?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/774c70c09d995613b875cd7537dacc6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f4203abe661b6242387ca7cf05e49c9/" rel="bookmark">
			静电放电保护和片式压敏电阻器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 引言 随着电子设备功能的增加，输入∕输出连接器也随之增多，这为静电放电（ESD）提供了进入电路的路径，静电放电保护问题变得不容忽视。因此，有必要采用静电放电保护元件，在静电放电进入电路板之前有效抑制静电放电事件的发生。目前，用于抑制静电放电的保护元件，主要是片式氧化锌压敏电阻器，具有抑制过电压、吸收浪涌能量、抑制浪涌噪声、稳定高频线路等优势。通过严格的IEC 61000-4-2 标准规定的静电放电试验时的4 级水平，即接触放电8kV 和空气放电15kV 的要求，可以达到优良的静电保护效果。
2 静电的产生和放电 2.1 静电的产生 物体的静电带电又称静电起电。它是由于处于不同带电序列位置的物质之间接触分离（摩擦）、使物体上正负电荷失去平衡而发生的带电现象。在大多数情况下，静电起电与放电是同时发生的，而且静电起电——放电是一个随机的动态过程，在这过程中，不仅有静电能量的传导输出，而且有电磁脉冲场的辐射。
（1）两种介电常数不同的物质摩擦时，正负极性的电荷分别积累在两个物体上面，而形成正负电荷。当两个物体接触时，其中的一个将从另一个吸取电子，因而两者形成不同的电位。
（2）摩擦起电是一个机械过程，依靠相对表面移动传送电量。传送的电量取决于接触的次数，表面粗糙度、湿度、接触压力、摩擦物质的摩擦特性以及相对运动速度。
（3）静电只存在于物体表面，而非物体内部，绝缘体中的电荷只保持在产生静电的那些区域，而不会出现在整个表面。因此，绝缘体接地后不会失去这些电荷。与绝缘体相反，导体接地后便会失去自身电荷。
（4）如果将导体瞬间接地（例如，该物体被站立在地上的人接触），那么远离带电体表面的电荷就会释放，导体将带正电荷。
2.2 静电放电 静电放电（Electio Static Discharge， ESD）具有不同静电电位的物体相互靠近或直接接触引起的电荷转移。不同物质的接触、分离或相互摩擦，即可产生静电。两个带上电荷的物体也就成了静电源。静电源跟其他物体接触时，依据电荷中和的原则，存在着电荷流动，传送足够的电量以抵消电压。这个高速电量的传送过程中，将产生潜在的破坏电压、电流以及电磁场，严重时将其中物体击毁，这就是静电放电。表1 列出日常活动产生的静电电压，表2 列出人体（C=200pF）日常活动中所产生的静电量。
2.3 静电的特点 （1）高电位，最高可达数104V 以至数105V。 （2）低电量，毫微库仑（10-9C）级别。
（3）作用时间短，多为μs（10-6s）级。
3 静电的危害 3.1 静电敏感度 静电敏感度（Electrostatic Discharge Sensitive, ESDS）是一种描述产品受ESD 损害的敏感程度。对静电放电敏感的元器件称为ESD 敏感器件。装配有ESDS 的电路板也对ESD 敏感，称为ESD 敏感组件。操作ESD 敏感器件和ESD 敏感组件的时候，必须注意ESD 保护。
（1）通常无源器件对ESD 不够敏感，如：电阻器、电感器、电容器等。
（2）有源器件对ESD 较为敏感，称为静电敏感器件（StaticSensitivity Device, SSD），是一种易受ESD 损坏的静电敏感元器件，如IC、晶体管、LED 等。
3.2 ESD 对电子产品的危害 3.2.1 电子产品危害的分类 （1）灾难性损坏（Catastrophic Failure）这种破坏可能使设备不能正常工作，或使某些节点击穿等，一般能很容易检测出来。ESD 损坏电子产品最小电压力为20V。灾难性破坏发生几机率占ESD 损坏率的10%。
（2）潜在性损伤（Latent Defect）这种破坏一般表现为静电能量较小，不足以使设备立即失效，仅仅表现为工作不稳定，或者干脆就没有外在的特异表现，但是这种破坏却最危险，轻则缩短设备的使用寿命，重则对以后的系统甚至人身产生危害；同时，因为问题表现不明显，所以给检测带来困难；更糟糕的是，维修人员一般把这种问题归咎为材料不良或者设计缺陷等其他原因，从而对问题的解决抱有侥幸心理，直到灾难发生。潜在性损伤发生机率占ESD 损坏率的90%。
3.2.2 静电使电子产品损坏的特点 （1）隐蔽性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f4203abe661b6242387ca7cf05e49c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54237e3c2738f5584b9a9a6de1ef7c31/" rel="bookmark">
			如何将navigator的坐标转为GCJ-02坐标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 腾讯地图的javascript API GL 只能通过api去换去GCJ-02坐标，这里推荐一个npm包去直接转换。
npm install coordtransform import coordtransform from 'coordtransform' function geoToGCJ02(geoCoords) { const [longitude, latitude] = geoCoords; // 经度和纬度 // 使用 coordtransform 库将坐标从 WGS-84 转换为 GCJ-02 const gcj02Coords = coordtransform.wgs84togcj02(longitude, latitude); return gcj02Coords; } // 示例使用 const geoCoords = [-122.4194, 37.7749]; const gcj02Coords = geoToGCJ02(geoCoords); console.log("GCJ-02 坐标:", gcj02Coords); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3975d622c5c19c3067a252e43515cfc8/" rel="bookmark">
			编译[Bug]——too few arguments for template template parameter “Tuple“ detected
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： 当使用高版本的cuda去安装低版本pytorch，并且编译用低版本pytorch写的cuda算子时，或者说是VS的版本过高如2022和2019，都有可能会出现某个.h文件或者.c文件报错，如：
error: too few arguments for template template parameter "Tuple" detected during instantiation of class "pybind11::detail::tuple_caster&lt;Tuple, Ts...&gt; 解决方案： 修改报错对应行的表达式，像我这里报错的是torch里的cast.h的文件，网络上关于这个cast.h的错误好像就是最多的，就去conda envs里的
torch/include/pybind11/cast.h 在报错的前面加上下面的代码进行修改，提前定义这个tuple_caster
template &lt;template &lt;typename...&gt; class Tuple, typename... Ts&gt; class tuple_caster; template &lt;typename T1, typename T2&gt; class type_caster&lt;std::pair&lt;T1, T2&gt;&gt; : public tuple_caster&lt;std::pair, T1, T2&gt; {}; template &lt;typename... Ts&gt; class type_caster&lt;std::tuple&lt;Ts...&gt;&gt; : public tuple_caster&lt;std::tuple, Ts...&gt; {}; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b8459d69e980584a691a815a96e7c21/" rel="bookmark">
			基于 Python 的新能源汽车销售数据可视化系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：展示部分文档内容和系统截图，需要完整的视频、代码、文章和安装调试环境请私信up主。 4.4网站操作流程 在之前提及的登录操作无误后，我们就可以进入网站中去操作网站的对应的功能，而且我们在使用任何功能的适合都会留下脚印，以便管理员可以实时查看用户的操作情况，在执行操作性功能的时候都将产生相应的信息，这对于我们的数据完整性有着很重要的核对作用。流程如图4.4所示。
4.5网站数据库模块设计 数据库这个称谓，是我们对现实世界理解的信息，通过对其分类，整理归纳，将存储在某一地方，但是这个地方并没有具体的形态，所以我们将这个地方抽象的形容为数据库概念模型。这个概念模型映射出真实世界各组成部分的信息结构、信息流动情况、信息间的相互制约关系以及各组成部分对信息保存、查找和完善等[11]。所以建立的模型应避让数据库在计算机上的具体实现细节，用一种抽象的形式呈现出来。以实体-（E-R模型）联系模型方法为例，第一步先明确实真实世界中信息的组成部分所包含的实体及属性、实体间的联系以及对象的制约条件等，从而给出组成信息的局部描述。第二步再将之前得出的多个局部视图拼凑成为一个整体视图，即我们所理解的真实世界的概念数据模型。
建立概念数据模型是我们对用户描述的信息的初始领会。通过对用户描述的现实需求理解，我们将其建立起一个抽象的模糊的概念模型。这个概念模型主要由实体-联系图（Entity-Relationship Diagram）、实体(Entity)、属性（Attribute）、联系（Relationship）等部分组成。
（1）车辆实体主要的成员属性有：名称、数量、品牌。车辆信息实体属如车辆信息。如图4-2所示。
(2)车辆表及用户表可以保存在系统中车辆及用户的基本信息，结构如下 ：
表4-1 车辆表
字段
类型
字段说明
备注
Id
Int
主键
自增
name
Varchar(30)
名称
非空
Shuliang
Varchar(500)
数量
非空
Pingpai
Varchar(500)
品牌
非空
表4-2 用户表
字段
类型
字段说明
备注
Id
Int
主键
自增
Username
Varchar(50)
用户名
非空
Pass
Varchar(30)
密码
非空
4.6程序设计及代码编写 （1）打开此次采集数据的网站“电车资源”，通过网页的URL得到源代码，根据源代码筛选出所需要品牌名，车名，车型，销量，销售占比，年份等信息。
5.1首页界面模块 该新能源汽车销售地区分析网站的登录界面输入用户名，密码登录。如图5.1所示：
5.2爬取汽车信息
在pycharm中开启爬虫命令后，生成全国新能源汽车销售数据的信息页面，详细数据如图5.2：
5.3新能源汽车销售预测界面 通过往年新能源汽车销售数据，对其进行综合分析，得到折线图，并预测出2023年销售数据如图5.3：
目 录
摘要 关键词 Abstract Key words 1 绪论 1
1.1 网站开发背景和意义 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b8459d69e980584a691a815a96e7c21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d511664bf7c0df988022e33e05685352/" rel="bookmark">
			Ubuntu Desktop 22.04 无法实现拖放复制操作解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：Ubuntu22.04 LTS 使用open-vm-tools无法实现拖放复制 环境：
主机：Windows10虚拟机软件：VMware Workstation Pro 17.0虚拟机系统：Ubuntu Desktop 22.04 LTS软件：open-vm-tools (open-vm-tools-desktop) 前段时间在VMware17上安装ubuntu22.04 LTS后，使用vm软件自带的vmware-tools一直安装失败，后来了解到有open-vm-tools(这个是开源的，官方也推荐使用这个)，遂决定安装这款，但是安装完成后，仍然无法实现主机与虚拟机之间的拖拽复制操作，会“出现不支持拖放操作”的提示，只有剪贴板可以联通。后来找了很久才知道需要切换到xorg。
以下是安装方法
总共有两部分，首先是安装open-vm-tools（这是前提，如果是桌面系统还需要安装open-vm-tools-desktop）；然后是切换到xorg
1. 安装open-vm-tools 首先得先安装open-vm-tools。直接使用apt安装，一共有两个，一个是open-vm-tools，另一个是open-vm-tools-desktop，前者是必装，如果你使用的是ubuntu桌面版，就需要两个都装。
sudo apt install open-vm-tools 如果没有自动安装open-vm-tools-desktop，就手动安装一下
sudo apt install open-vm-tools-desktop 2.切换到xorg 2.1 进入系统后注销登录 注意：这里要注销用户，不要用锁定或者直接重启系统，锁定或重新开机后的界面无法设置切换到xorg，只有注销后才可以
注销后会进入用户登录选择界面
2.2 切换到xorg 选择一个用户进行登录，我这里只有一个用户，直接选择，注意：这时候先不输入密码。这时候注意看右下角，有一个齿轮。
点击右下角齿轮，切换到Ubuntu on Xorg。接下去输入密码，登录，再次尝试一下拖拽复制，主机和虚拟机之间就可以自由复制啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8be3a78d9332d6e05dd341837ef3de3/" rel="bookmark">
			Vue2版本的ElementUI的input组件加千分符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、方法11. 主要代码2. 正则原理： 二、方法21. 主要代码2. toLocaleString原理： 三、Element Plus 自带格式化总结 前言 最近在维护一个比较老的后台管理系统，用的是vue2+element-ui（2.1.0版本），虽然组件库旧了点但也不是不能用，毕竟后台管理系统简单高效为主，然而有个新需求需要输入数字且显示千分位符号，找官网Input 输入框组件就没有这么个功能，没办法只能自己写了。
一、方法1 1. 主要代码 &lt;el-input v-model="form.formatterValue" @input="handleInput"&gt; &lt;/el-input&gt; methods: { handleInput(val) { // nextTick确保数据与视图同步 this.$nextTick(() =&gt; { // \D:表示非数字，确保输入框只能输入数字 this.form.formatterValue = val.replace(/\D/g, ""); // 得到经过非数字过滤后的值 const data = val.replace(/\D/g, ""); // 将值暂存起来 this.realValue = data; // 最关键的步骤：添加千分符 this.form.formatterValue = data.replace(/\B(?=(\d{3})+(?!\d))/g, ","); }); }, } 2. 正则原理： 正则表达式/\B(?=(\d{3})+(?!\d))/怎样给数字添加千分符的？简单来说这个正则表达式分为三部分：
\B ：元字符，匹配某个空格?=(\d{3})+：先行断言，匹配后面跟了3的倍数个数字的位置(?!\d)：后行断言，在这个位置（3的倍数个数字）之后不能再有数字了 推荐 这篇文章 ，需要有一定的正则功底才能写得出来，不过读完别人大佬的文章后应该比较好理解了，实在不想用正则的同学可以用下面的方法。
二、方法2 1. 主要代码 methods: { handleInput(val) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8be3a78d9332d6e05dd341837ef3de3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d3ea97bc83133559158d9539ca797b5/" rel="bookmark">
			序列检测器的verilog实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、要求 设计一个序列检测同步时序逻辑电路，要实现的功能如下：
当已有输入码流出现序列111000或101110时输出检测信号为1，否则输出为0。在时序上检测到完整序列的下一个时钟周期输出检测结果。输入信号有效为1时表示当前输入有效，否则表示无效。之前输入依旧计入序列中并不清零，即允许序列重叠检测。例如：
输入码流（设输入数据均有效）和输出检测为
[I] 0 0 1 1 1 0 0 0 1 1 0 1 1 1 0 0 0 0
[O] 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 1
模块输入输出功能定义：
名称
方向
位宽
描述
clk
I
1
系统时钟
rst_n
I
1
异步复位，低电平有效
din_vld
I
1
输入数据有效指示
din
I
1
输入数据
result
O
1
输出检测结果
二、实现 1.移位寄存器比较法 /*模块端口定义*/ module seq_detect( input clk, input	rst_n, input din_vld, input	din, output	reg result ); reg [5:0] tmp = 6'd0; /*移位寄存器*/ always @(posedge clk or negedge rst_n) begin if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d3ea97bc83133559158d9539ca797b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28d04fde62c0252f17e6aa2ad8f8a27f/" rel="bookmark">
			docker-启动rancher
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文连接：http://www.duozhi.online/2023/10/20/docker-%e5%90%af%e5%8a%a8rancher/
1.节点 192.168.0.204
2.搭建 helm装实在太慢了，拉镜像费老劲，就直接启动docker了，最好还是helm安装下
docker run -d --restart=unless-stopped \ -p 80:80 -p 443:443 \ --privileged \ rancher/rancher:latest 登陆设置密码
用户：admin 密码：admin12admin
添加现有集群
按照如下操作即可
等着变为active
集群中的pod running后才会active
其中fleet-agent是看log创建出的pod
3.访问 http:192.168.0.204
参考文献 https://docs.rancher.cn/docs/rancher2.5/installation/other-installation-methods/single-node-docker/_index https://docs.rancher.cn/docs/rancher2/cluster-provisioning/imported-clusters/_index/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae44dd3bbea8f822abe0d38f4df90346/" rel="bookmark">
			kube-prometheus在k8s中安装prometheus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文连接：
使用kube-prometheus中的yaml进行prometheus的搭建
k8s安装文档：http://www.duozhi.online/2023/10/20/centos7%e4%b8%adkubeadmin%e6%90%ad%e5%bb%bak8s-1-22/
storageClass环境配置文档：http://www.duozhi.online/2023/10/20/nfs-server%e5%ae%89%e8%a3%85k8s%e4%b8%ad%e9%83%a8%e7%bd%b2nfs-provisionernfs-server%e5%ae%89%e8%a3%85/
https://github.com/prometheus-operator/kube-prometheus/tree/main/manifests
选择0.10版本
注意点：
1.在apply prometheus的crd的时候报错，我就从prometheus-operator中选了个之前的crd版本
报错如下
选择一个之前的版本可以
2.Prometheus我设置了pvc存储
apiVersion: monitoring.coreos.com/v1 kind: Prometheus metadata: labels: app.kubernetes.io/component: prometheus app.kubernetes.io/instance: k8s app.kubernetes.io/name: prometheus app.kubernetes.io/part-of: kube-prometheus app.kubernetes.io/version: 2.32.1 name: k8s namespace: monitoring spec: # alerting: # alertmanagers: # - apiVersion: v2 # name: alertmanager-main # namespace: monitoring # port: web enableFeatures: [] externalLabels: {} image: quay.io/prometheus/prometheus:v2.32.1 nodeSelector: kubernetes.io/os: linux podMetadata: labels: app.kubernetes.io/component: prometheus app.kubernetes.io/instance: k8s app.kubernetes.io/name: prometheus app.kubernetes.io/part-of: kube-prometheus app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae44dd3bbea8f822abe0d38f4df90346/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15fdb8982bbd37d375e6d52265dae0b9/" rel="bookmark">
			文件的逻辑结构（顺序文件，索引文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所谓的“逻辑结构”，就是指在用户看来，文件内部的数据应该是如何组织起来的。
而“物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。
1.无结构文件 无结构文件:文件内部的数据就是一系列二进制流或字符流组成。无明显的逻辑结构。
又称“流式文件”。如:Windows操作系统中的.txt文件。
2.有结构文件 有结构文件:由一组相似的记录组成，又称“记录式文件”。
每条记录又若干个数据项组成。如:数据库表文件。
一般来说，每条记录有一个数据项可作为关键字。
根据各条记录的长度（占用的存储空间）是否相等，又可分为定长记录和可变长记录两种。
1.顺序文件 顺序文件:文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。
各个记录在物理上可以顺序存储或链式存储。
顺序存储：逻辑上相邻的记录物理上也相邻（类似于顺序表)链式存储：逻辑上相邻的记录物理上不一定相邻(类似于链表）串结构：记录之间的顺序与关键字无关。顺序结构：记录之间的顺序按关键字顺序排列。 1.链式存储 无论是定长/可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找
2.顺序存储 可变长记录 无法实现随机存取。每次只能从第一个记录开始依次往后查找
定长记录 可实现随机存取。记录长度为L，则第i个记录存放的相对位置是i*L。
若采用串结构，无法快速找到某关键字对应的记录。
若采用顺序结构，可以快速找到某关键字对应的记录（如折半查找)。
结论:
定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取;
若能再保证记录的顺序结构，则可实现快速检索(即根据关键字快速找到对应记录).
顺序文件的缺点是增加/删除一个记录比较困难（如果是串结构则相对简单).
2.索引文件 建立一张索引表以加快文件检索速度。每条记录对应一个索引项。
索引表本身是定长记录的顺序文件。因此可以快速找到第i个记录对应的索引项。
可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。
每当要增加/删除一个记录时，需要对索引表进行修改。
由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。
3.索引顺序文件 索引顺序文件是索引文件和顺序文件思想的结合。
索引顺序文件中，同样会为文件建立一张索引表，但不同的是:并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。
索引顺序文件的索引项也不需要按关键字顺序排列，这样可以极大地方便新表项的插入。
1.检索效率分析 若一个顺序文件有10000个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指的并不是定长记录、顺序结构的顺序文件)，平均须查找5000个记录。若采用索引顺序文件结构，可把10000个记录分为100组，每组100个记录。
则需要先顺序查找索引表找到分组(共100个分组，因此索引表长度为100，平均需要查50次），
找到分组后，再在分组中顺序查找记录（每个分组100个记录，因此平均需要查50次）。
可见，采用索引顺序文件结构后，平均查找次数减少为50+50= 100次。 4.多级索引顺序文件 为了进一步提高检索效率，可以为顺序文件建立多级索引表。
例如，对于一个含 1 0 6 10^6 106个记录的文件，可先为该文件建立一张低级索引表，
每100个记录为一组，故低级索引表中共有10000个表项（即10000个定长记录），
再把这10000个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有100个表项。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef601b96b3e010ad526d98c8279724d0/" rel="bookmark">
			MPU6050使用心得（简单分享一下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 选用MPU6050做 倾斜检测 功能。
前期准备 开发板：正点原子STM32F103 精英版（STM32F103ZET6）
模块：GY-521 MPU6050
其他：杜邦线若干、烧录线、FlyMcu、Keil5、正点原子开发板配套的套件（TFTLCD）
例程、资料下载 源自淘宝卖家：https://pan.baidu.com/share/init?surl=dNDqcp76L9QdM7iSZYfz_A 密码：4eum
GY-521 MPU6050模块 三维角度传感器6DOF三轴加速度计电子陀螺仪\MPU6050六轴角度加速度传感器\11，ATK-MPU6050六轴传感器模块\2，程序源码\（库函数版本，适合精英STM32开发板）实验30 MPU6050六轴传感器实验.rar
我们的例程刚好选择的适配 我们开发版的正点原子例程，虽然这个程序是针对ATK-MPU6050，不过其实2个模块差别不大，可以通用例程，非常方便。
原理图 我们可以看下2个模型的原理图，可以发现ATK-MPU6050只是有几个管脚没有接出来，不使用的话，其实没啥区别
GY-521 MPU6050 ATK-MPU6050 这边的AUX_CL、AUX_DA就没接
引脚描述 源自：姿态传感器——MPU6050
SCL、SDA：是连接MCU的IIC接口，MCU通过这个IIC接口来控制MPU6050，此时MPU6050作为一个IIC从机设备，接单片机的I2C_SCL。 XCL、XDA：辅助IIC用来连接其他器件，可用来连接外部从设备，比如磁传感器，这样就可以组成一个九轴传感器，不需要连接单片机。 AD0：地址管脚，可以不接单片机。当MPU6050作为一个IIC从机设备的时候，有8位地址，高7位的地址是固定的，就是WHOAMI寄存器的默认——0x68，最低的一位是由AD0的连线决定的。 AD0接GND时，高8位的最后一位是0，所以iic从机地址是0x68； AD0接VCC时，高8位的最后一位是1，所以iic从机地址是0x69。 INT：数据输出的中断引脚，可以不接单片机，准备好数据之后,通过中断告诉STM32,从而获取数据。 VCC：接3.3V或5V电源 GND：接地 所以ATK-MPU6050这XCL、XDA不接也罢，不影响。
接线 可以参考资料内的ATK-MPU6050六轴传感器模块用户手册_V1.0.pdf，或者直接看例程源码。
VCC -》 3.3V GND -》 GND SCL -》 PB10 SDA -》 PB11 AD0 -》 PA15 源码关键部分分析 main.c 关注的核心部分就在 while(mpu_dmp_init())，DMP初始化这块，注意会出问题的部分
inv_mpu.c //mpu6050,dmp初始化 //返回值:0,正常 // 其他,失败 u8 mpu_dmp_init(void) { u8 res=0; MPU_IIC_Init(); //初始化IIC总线 if(mpu_init()==0)	//初始化MPU6050 {	res=mpu_set_sensors(INV_XYZ_GYRO|INV_XYZ_ACCEL);//设置所需要的传感器 if(res)return 1; res=mpu_configure_fifo(INV_XYZ_GYRO|INV_XYZ_ACCEL);//设置FIFO if(res)return 2; res=mpu_set_sample_rate(DEFAULT_MPU_HZ);	//设置采样率 if(res)return 3; res=dmp_load_motion_driver_firmware();	//加载dmp固件 if(res)return 4; res=dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation));//设置陀螺仪方向 if(res)return 5; res=dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_TAP|	//设置dmp功能 DMP_FEATURE_ANDROID_ORIENT|DMP_FEATURE_SEND_RAW_ACCEL|DMP_FEATURE_SEND_CAL_GYRO| DMP_FEATURE_GYRO_CAL); if(res)return 6; res=dmp_set_fifo_rate(DEFAULT_MPU_HZ);	//设置DMP输出速率(最大不超过200Hz) if(res)return 7; res=run_self_test();	//自检 核心部分，最容易出错的地方 if(res)return 8; res=mpu_set_dmp_state(1);	//使能DMP if(res)return 9; }else return 10; return 0; } 其中run_self_test()是关键，自检操作会对模块的各角度进行调整到“零度”，所谓的零度，不是真零度，稍后补充。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef601b96b3e010ad526d98c8279724d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cb37dd6daa14f35e69c7fa2cb6b34ba/" rel="bookmark">
			uniGUI文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.文件上传TUniFileUploadButton
TUniFileUploadButton主要属性：
Filter: 文件类型过滤，有图片image/* audio/* video/*三种过滤
MaxAllowedSize: 设置文件最大上传尺寸；
Message：标题以及消息文本，可翻译成中文
TUniFileUploadButton控件 支持多文件批量上传! procedure TMainForm.UniFileUploadButton1Completed(Sender: TObject; AStream: TFileStream); var i:integer; begin UniFileUploadButton1.MultipleFiles:=True;//多选 模式 UniFileUploadButton1.MaxFiles:=4; //最大文件数 for I := 0 to UniFileUploadButton1.MaxFiles-1 do begin caption:= UniFileUploadButton1.Files[i].FileName ; end; end; 如果文件数超过MaxFiles
事件：OnCompleted(Sender: TObject; AStream: TFileStream)
procedure TMainForm.UniFileUploadButton1Completed(Sender: TObject; AStream: TFileStream); var DestName : string; DestFolder : string; begin //将 文件 加载到 UniImage1里 UniImage1.Picture.LoadFromFile(AStream.FileName); Caption:='File Name: '+UniFileUploadButton1.FileName; //将 文件 保存到UploadFolder文件夹，先要创建这个UploadFolder文件夹 DestFolder:=UniServerModule.StartPath+'UploadFolder\'; //要在与exe同下新建一个UploadFolder文件夹 DestName:=DestFolder+ExtractFileName(UniFileUploadButton1.FileName); CopyFile(PChar(AStream.FileName), PChar(DestName), False); ShowMessage('File: '+UniFileUploadButton1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cb37dd6daa14f35e69c7fa2cb6b34ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcfc3064a88977890ed0008fbe846094/" rel="bookmark">
			linux screen会话管理 断开连接恢复会话
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://zhuanlan.zhihu.com/p/349322691
安装
CentOS系统执行以下命令安装：
yum install screen
Debian/Ubuntu系统执行以下命令安装：
apt-get install screen
常用命令教程
实际使用过程中，大部分用户只需要掌握以下几个基本操作就满足需求了: 会话的创建，会话的查找，会话的恢复，会话的删除
详细命令如下：
新建一个screen会话
screen -S &lt;名字&gt;
退出当前screen会话
键盘点击ctrl+a , 然后按d
查看所有screen会话
screen -ls
进入（恢复）某一screen会话
screen -r &lt;会话序列号&gt;
关闭screen会话
screen -X -S &lt;序列号&gt; quit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1889491aa38560ac2061bcf0c68c8a1/" rel="bookmark">
			实验一 8255并行接口实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上机实验实验目的实验内容实验原理8255 内部结构8255 三种工作方式8255 控制字 实验步骤实验代码关于代码的解释 扩展实验一实验题目实验代码关键代码段解读 扩展实验二实验题目实验代码关键代码解读 扩展实验三实验题目实验代码关键代码解读 并行接口单元由一片 8255 8255 8255 组成，其复位信号已连接到系统复位上，如下图所示。
上机实验 实验目的 学习利用并行接口芯片 8255 8255 8255 构成并行接口电路的基本方法；熟悉掌握并行接口芯片 8255 8255 8255 的基本性能、硬件连接和初始化编程方法。 实验内容 编写一个基本输入输出程序，使 8255 8255 8255 的 A A A 口为输入， B B B 口为输出，完成拨动开关到数据灯的数据传输。
要求：数据灯的显示随开关动态改变。
实验原理 8255 内部结构 8255 8255 8255 可作为单片机与多种外围设备连接时的中间接口电路。
8255 8255 8255 作为 主机与外设的连接芯片，
必须提供 与主机连接 的 3 个 总线接口，即数据线、地址线、控制线接口；同时必须具有 与外设连接 的接口，即 A A A、 B B B、 C C C 口；由于 8255 8255 8255 可编程，所以必须具有 逻辑控制 部分； 因而 8255 8255 8255 内部结构分为 3 个部分：与CPU连接部分、与外设连接部分、控制部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1889491aa38560ac2061bcf0c68c8a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c862f009b66630399b5aeaa543f33df9/" rel="bookmark">
			GEE：快速下载数字高程DEM数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DEM数据下载，使用SRTM Digital Elevation Data Version 4，一个2000年 的全球高程数据 。下载以后的DEM不用再做裁剪，可以直接使用。
也可以导入下面这个分辨率30米的DEM数据，搜索一下就可以了。
NASADEM: NASA NASADEM Digital Elevation 30m
源代码：https://code.earthengine.google.com/9f03191275e206fa06287a544e32fb5a?noload=true
效果如下图所示，
不光可以下载DEM数据，也可以下载坡度。坡度的计算被我注释掉了。想下载坡度，去除注释就可以了。
//直接导入实验区边界,然后运行就可以了 // 坡度的计算被注释掉了,想下载坡度,去除注释就可以了。 var roi = table var roi_geometry = roi.geometry(); var SRTM30 = ee.Image("NASA/NASADEM_HGT/001") var elevation = SRTM30.select('elevation') .clip(roi_geometry) // var slope = ee.Terrain.slope(elevation) var cuttingRegion = roi_geometry; Export.image.toDrive({ image: elevation, description: 'FH_Elevation', scale: 30, maxPixels: 1e13, region: cuttingRegion }); // Export.image.toDrive({ // image: slope, // description: 'FH_Slope', // scale: 30, // maxPixels: 1e13, // region: cuttingRegion }); // 可视化参数 var args = { crs: 'EPSG:3857', dimensions: '300', region: roi, min: -2000, max: 10000, palette: 'green, blanchedalmond,orange,black ', framesPerSecond: 12, }; Map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c862f009b66630399b5aeaa543f33df9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5deeb70fe9097c76aacc38c142f23e66/" rel="bookmark">
			基于stata的DID平行趋势检验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 DID平行趋势检验定义 定义：评估两变量数据之间是否会存在某种同幅度增减情况的相关关系检验方法
重要性：为何要做平行趋势检验？平行趋势检验在DID模型中是非常重要的一步，用于验证处理组和对照组在干预前的趋势是否平行。只有当变量通过了平行趋势检验，我们才能更可靠地构建DID模型并进行实证分析。
判断方式：
时间趋势图，绘制处理组和对照组在干预前的趋势图。图形上的趋势应该是平行的，即两组在干预前的发展趋势应该相似。如果趋势图显示出平行趋势，这是一个初步的指示。【前同后不同】统计检验：使用统计检验方法来验证处理组和对照组的趋势是否平行。在Stata等统计软件中，可以使用reghdfe命令或其他趋势检验命令来进行比较。如果处理组和对照组的趋势差异在统计上不显著（通常以p值大于0.05为标准），则可以认为通过了平行趋势检验。专门的平行趋势检验方法：有一些专门的方法可用于DID平行趋势检验，如McCrary检验、Lee bounds检验等。 例子： 代码没跑，看到这篇文章。
【链接1】
【链接2】
//平行趋势检验 ssc install coefplot //安装手动画图 gen policy = year - 政策时间点 tab policy replace policy = -3 if policy &lt; -3 replace policy =3 if policy &gt; 3 //生成年份虚拟变量与实验组虚拟变量的交互项 forvalues i = 3(-1)1{ gen pre_`i' = (policy == -`i' &amp; treat == 1) } gen current = (policy == 0 &amp; treat == 1) forvalues j = 1(1)3{ gen post_`j' = (policy == `j' &amp; treat == 1) } //在图里不表示出基准期 drop pre_1 reghdfe 因变量 pre_* current post_* 控制变量, absorb(省份固定 年份固定) cluster(自己选择聚类) //在图中表示出基准期（pre_1） reghdfe 因变量 pre_3 pre_2 current post_1 post_2 post_3 pre_1 控制变量, absorb(省份固定 年份固定) cluster(自己选择聚类) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5deeb70fe9097c76aacc38c142f23e66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce0b4a74a494d947a9d2d69a98070f84/" rel="bookmark">
			LeetCode-198. 打家劫舍 C/C&#43;&#43;实现 超详细思路及过程[M]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 198. 打家劫舍
难度：中等
相关标签：动态规划、数组
提示
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
运行示例
示例 1：
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
偷窃到的最高金额 = 2 + 9 + 1 = 12 。
提示
1 &lt;= nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce0b4a74a494d947a9d2d69a98070f84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8ae0daa9327d309a47da59074816e0c/" rel="bookmark">
			echarts大屏适配(rem)&#43;图表的文字适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章解决的是：echarts大屏适配以及图标配置项里面的文字适配。非常好用！ 1-创建js文件，并复制下面的函数 (git地址)
(function flexible (window, document) { var docEl = document.documentElement var dpr = window.devicePixelRatio || 1 // adjust body font size function setBodyFontSize () { if (document.body) { document.body.style.fontSize = (12 * dpr) + 'px' } else { document.addEventListener('DOMContentLoaded', setBodyFontSize) } } setBodyFontSize(); // set 1rem = viewWidth / 10 function setRemUnit () { var rem = docEl.clientWidth / 10 docEl.style.fontSize = rem + 'px' } setRemUnit() // reset rem unit on page resize window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8ae0daa9327d309a47da59074816e0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af5a51d0db832f7bedb1f9e6c2ee14d7/" rel="bookmark">
			mac配置vscode远程免密连接服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体方式有很多，根本上就是首先生成一公钥私钥对，然后将公钥写入到服务器的.ssh文件夹下的authorized_keys文件中（没有的话新建），然后私钥存储在本地，最后将私钥的路径配置到vscode的.ssh/config当中即可。
1.首先在服务器上运行：
ssh-keygen -t rsa -C username -f filename （-C备注的用户名和-f的文件名可以修改为自己的），回车使用默认设置即可。
然后会在服务器的~/.ssh目录下生成私钥filename和公钥filename.pub两个文件。
2.将服务器上的公钥filename.pub复制一份，重命名为authorized_keys。
cp filename.pub authorized_keys 3.将服务器上的filename内容复制到mac本地的/Users/[username]/.ssh/filename文件中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd609180792e35824b395370d0cf8ae2/" rel="bookmark">
			FusionCompute 6.5.1重置Web端登录密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验环境中搭建的FC忘记了Web登录的密码，多次尝试后仍然密码错误，账户锁定3分钟【参考博客】 登录到VRM后台 直接使用root密码登录到VRM后台 输入以下命令即可重置admin密码psql -U galax vrm -c "update sm.tbl_user set password='75832dd7fb530fc7f574d61d49cadf20rF86+JEaDx02' where username='admin' and usertype='0';"提示输入galax用户的密码SingleLOUD!1 VRM01:~ # psql -U galax vrm -c "update sm.tbl_user set password='75832dd7fb530fc7f574d61d49cadf20rF86+JEaDx02' where username='admin' and usertype='0';" Password for user galax:SingleLOUD!1 UPDATE 1 VRM01:~ # 修改成功！在Web界面使用admin登录页面，密码背重置为Huawei@123!修改Web登录的密码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d414653edfa5b474a37cd416016e596/" rel="bookmark">
			MiniGPT-v2：多任务视觉模型新升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		白交 发自 凹非寺
转自量子位 | 公众号 QbitAI GPT-4V来做目标检测？网友实测：还没有准备好。
虽然检测到的类别没问题，但大多数边界框都错放了。
没关系，有人会出手！
那个抢跑GPT-4看图能力几个月的迷你GPT-4升级啦——MiniGPT-v2。
△（左边为GPT-4V生成，右边为MiniGPT-v2生成） 而且只是一句简单指令：[grounding] describe this image in detail就实现的结果。
不仅如此，还轻松处理各类视觉任务。
圈出一个物体，提示词前面加个 [identify] 可让模型直接识别出来物体的名字。
当然也可以什么都不加，直接问~
MiniGPT-v2由来自MiniGPT-4的原班人马（KAUST沙特阿卜杜拉国王科技大学）以及Meta的五位研究员共同开发。
上次MiniGPT-4刚出来就引发巨大关注，一时间服务器被挤爆，如今GItHub项目已超22000+星。
此番升级，已经有网友开始用上了~
多视觉任务的通用界面 大模型作为各文本应用的通用界面，大家已经司空见惯了。受此灵感，研究团队想要建立一个可用于多种视觉任务的统一界面，比如图像描述、视觉问题解答等。
「如何在单一模型的条件下，使用简单多模态指令来高效完成各类任务？」成为团队需要解决的难题。
简单来说，MiniGPT-v2由三个部分组成：视觉主干、线性层和大型语言模型。
该模型以ViT视觉主干为基础，所有训练阶段都保持不变。从ViT中归纳出四个相邻的视觉输出标记，并通过线性层将它们投影到 LLaMA-2语言模型空间中。
团队建议在训练模型为不同任务使用独特的标识符，这样一来大模型就能轻松分辨出每个任务指令，还能提高每个任务的学习效率。
训练主要分为三个阶段：预训练——多任务训练——多模式指令调整。
最终，MiniGPT-v2 在许多视觉问题解答和视觉接地基准测试中，成绩都优于其他视觉语言通用模型。
最终这个模型可以完成多种视觉任务，比如目标对象描述、视觉定位、图像说明、视觉问题解答以及从给定的输入文本中直接解析图片对象。
感兴趣的朋友，可戳下方Demo链接体验：
https://minigpt-v2.github.io/
https://huggingface.co/spaces/Vision-CAIR/MiniGPT-v2
论文链接：https://arxiv.o‍rg/abs/2310.09478
GitHub链接：https://github.com/Vision-CAIR/MiniGPT-4
参考链接：https://twitter.com/leoyerrrr
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94e115c0fe5122fdc04eda06d510505d/" rel="bookmark">
			eCongnition 图像分割分类初学者保姆教程含多种工具介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		易康，启动 首先打开它
在工具栏的1、2、3、4的那个工具那里我们选择4，这是四种不同的工作区，实测4最好用，大家尽可以试试123.然后点击第一个按钮create project，选择数据
给你的project一个名字。右侧勾选use geocooding就会考虑坐标系，不勾选就会当作普通图像处理，输出的结果就没有坐标系，再用arcgis开的时候就对不上。
subselect可以选取一部分图像来操作。
下面的框框可以remove掉一些不需要的数据，但是再insert的时候一加进来就会全部加进来，不能选加哪个波段。
然后ok打开它，这时候可以存一下这个project，以便这次没做完下次接着做，类似于arcgis的xmd文件。要和数据存在同一目录下，打开时选择工具栏第二个按钮open project，选择dpr后缀的文件就可以打开。
调整波段显示。
第一个按钮single layer gray就是单波段显示 ，点开倒数第二个可以看到是哪个波段。第二个可以开三波段rgb显示。第三个第四个按钮，加减就是顺次往后推一个或者往前推一个波段。比如本来是123，加一下就变成234。如果要具体调整还是要打开倒数第二个按钮，在下图右侧RGB那里调整。左下角可以调整拉升方法 。linear：所有数据拉到0~255，如果有极端值就会效果很差。但是一般用这个。
econgnition是没有toolbox的，在process tree里右键append new，所有的功能都在这里添加。
分割 首先用分割，推荐多尺度分割。这种方法会根据你的参数不断合并小的对象，合成大的对象。当合并以后方差超过我们设的阈值scale parameter的时候，就不合并。不超过就合并。这个阈值一般是多试几次试出来的。咱们先试个200。layer weight可以设置考虑多少个图层以及权重。levelname就是这一步操作的名字，咱们叫做seg200。最下面的shape0.1就是考虑形状和值的权重，数字越大shape权重越大，值的权重越小，一般形状的权重会小一些。compactness0.5是调整分割结果的形状破碎还是完整，越大越完整，越小越破碎。
点击excute就会直接执行，但是也可以点击ok先保存到咱们的process tree里，然后右键excute。可以选择任意时刻来执行你的任意操作。然后看看结果图发现很多东西都没分开哈哈哈说明parament太大了，小一点。首先删掉这一次的分割：
也可以在工具栏那个叉叉那里删：
然后把parament改成100再试试。可以双击或者右键上一个的那个seg200直接改，然后excute，也可以新建一个seg100
好像好多了。
这几个按钮可以调整显示，鼠标悬停可以看到显示的是什么东东，后文会说
分类 分割完以后就分类。
在这里右键给他新建几个类，右键空白处新建就可以，命名调颜色。
建好以后拖进去就可以变成二级类。调色永远很快乐哈哈哈
但是这里咱们不做复杂了，右键delete二级类。 还可以右键存一下这个类（如果十几个类很复杂并且以后还要用的话），然后load就可以加进来。
接下来给他训练样本。
点击这个water就可以开始选了。双击就会被选出来。如果你看起来跟我不一样，可能是因为之前那几个可以调整显示的按钮跟我按的不一样。
具体来说：
第一个是看该波段，第二个是看原始影像，第三个是看样本。马赛克那个是……就是马赛克。后面是显示轮廓、显示填充。我上面的图是显示轮廓。 选样本的时候，尽量在各个地方都选一些样本，选到一些长得不一样的。比如我的建筑类，可能包括看起来白白的商业用地，也可能有灰色的城中村，如果只选择到了其中一种，就可能造成分类误差。每一类尽量选50个以上，除非总量就很小，但是尽可能多。
如果想批量选择可以看这个：eCognition易康面向对象分类批量选择样本，批量导出shp_econgnition-CSDN博客
咱们进行一个样本的选。开432假彩色（在前文调整波段那里），选完记得存，工具栏第三个按钮
然后就
手动修改分类结果：最后一个工具manual editing toolbar。用法跟选样本一样（工具栏的那个选类别）。有一些建筑阴影分成了水体就可以手动改一下。
自动改：assign class将满足一定条件的对象变成另一个类。比如把面积小于150的water变成lake（新增一个lake）
精度评价 理论上需要一套跟训练样本不一样的验证样本。在sample菜单栏里delete all sample（这里最好备份一个project）。然后再select sample。这里有办法避免选取重复的样本，可以看这个：
econgnition选择面向对象的样本，输出shp并在arcmap里打开，随机平均分为训练样本和测试样本_econgnition选择某一类-CSDN博客
第三个是基于像素的，第四个是基于对象的。然后就会输出混淆矩阵。KIA就是kappa系数。OA一般用百分比表示，kappa一般小数。然后save statistic就可以保存成csv。如果使用基于对象的，可能会因为面积差太多而导致偏差，所以可以用基于像素的。但要用这个首先就要在sample里create TTA mask，相当于矢量转栅格，可以选下面的save保存成tiff。然后就可以用它了。
面积相差不大就可以用基于对象的，但用基于像素的肯定不会错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e6bad945f5222053faf25e7e963853/" rel="bookmark">
			Android获取当前设备的内存和CPU使用情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要获取当前设备的内存和CPU使用情况，你可以使用Android的系统API。下面是一种实现方式：
1 获取应用程序的内存使用情况： ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo(); activityManager.getMemoryInfo(memoryInfo); long availableMemory = memoryInfo.availMem; long totalMemory = memoryInfo.totalMem; // 可用内存和总内存（以字节为单位） 2 获取应用程序的CPU使用情况： Debug.MemoryInfo[] processMemoryInfo = Debug.getProcessMemoryInfo(new int[]{android.os.Process.myPid()}); int cpuUsage = processMemoryInfo[0].getTotalCpuTime(); // CPU使用时间（以毫秒为单位） 3 获取整个设备的内存使用情况： ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo(); activityManager.getMemoryInfo(memoryInfo); long availableMemory = memoryInfo.availMem; long totalMemory = memoryInfo.totalMem; // 可用内存和总内存（以字节为单位） 4 获取整个设备的CPU使用情况： RandomAccessFile reader = null; try { reader = new RandomAccessFile("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02e6bad945f5222053faf25e7e963853/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63d8c5ca92b90de5474feef61cb4123e/" rel="bookmark">
			gstreamer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gst-launch-1.0 v4l2src device=/dev/video0 ! video/x-raw,width=320,height=240,framerate=10/1 ! autovideosink 报错：
ERROR: from element /GstPipeline:pipeline0/GstAutoVideoSink:autovideosink0/GstKMSSink:autovideosink0-actual-sink-kms: GStreamer encountered a general resource error.
Additional debug info:
../sys/kms/gstkmssink.c(2061): gst_kms_sink_show_frame (): /GstPipeline:pipeline0/GstAutoVideoSink:autovideosink0/GstKMSSink:autovideosink0-actual-sink-kms:
drmModeSetPlane failed: Invalid argument (22)
Execution ended after 0:00:01.157313047
Setting pipeline to NULL ...
ERROR: from element /GstPipeline:pipeline0/GstV4l2Src:v4l2src0: Internal data stream error.
Additional debug info:
../libs/gst/base/gstbasesrc.c(3127): gst_base_src_loop (): /GstPipeline:pipeline0/GstV4l2Src:v4l2src0:
streaming stopped, reason error (-5)
使用gst-launch-1.0 videotestsrc ! autovideosink 会有测试效果的展示。
求解决v4l2src 无法启动camera的解决方案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec3395bf2a821bc009aef9fd189ae0bc/" rel="bookmark">
			在echarts图表上点击数据，携带当前点击数据，进行跳转页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //注册事件前先销毁点击事件（避免点击事件会重复执行） mychart.getZr().off('click'); //注册区域的点击事件，解决数据较少时不方便点击柱状图的问题 mychart.getZr().on('click', (param) =&gt; { var pointInPixel = [param.offsetX, param.offsetY]; if (mychart.containPixel('grid', pointInPixel)) { //获取当前点击的索引值 //注意：若柱状图为纵向则获取x轴的索引，若柱状图为横向则需获取y轴的索引(见下方注释) //这里的[1]就代表点击的Y轴的,[0]如果为零就代表时X轴 var YIndex = mychart.convertFromPixel({ seriesIndex: 0 }, [param.offsetX, param.offsetY])[1]; YIndex就是当前点击数据的下标 var dataName = this.EchartsLsitListOne[YIndex].code //我这里根据取到每条的下标去数组中获取数据 this.$router.push({ //将取到的数据带上跳转路由传参 path: '/gather/gatherList', query: { key: dataName } }) } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9c7676ea5162ea7473268e4f8ff7787/" rel="bookmark">
			Ubuntu - 安装 MySQL 8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是在 Ubuntu 上安装 MySQL 8 的完整步骤：
步骤 1：更新包列表
首先，打开终端并执行以下命令来确保包列表是最新的：
sudo apt update
步骤 2：安装 MySQL 8 服务器
接下来，使用以下命令安装 MySQL 8 服务器：
sudo apt install mysql-server
步骤 3：启动 MySQL 服务
安装完成后，启动 MySQL 服务并设置它在系统启动时自动启动：
sudo systemctl start mysql sudo systemctl enable mysql
步骤 4：运行 MySQL 安全性脚本
为了提高安全性，运行 MySQL 安全性脚本：
sudo mysql_secure_installation
在执行此命令时，进行以下操作：
删除匿名用户禁用远程 root 登录删除测试数据库刷新权限表 按照提示选择相应的选项并进行配置。
步骤 5：登录到 MySQL
使用以下命令登录到 MySQL 数据库服务器：
mysql -u root -p
步骤6.1：获取 root 密码
在某些情况下，MySQL 8 的安装过程不会要求在终端中直接设置 root 用户密码，而是使用随机生成的密码。这种情况下，系统会将生成的随机密码保存在一个日志文件中，需要查看该密码并保存下来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9c7676ea5162ea7473268e4f8ff7787/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70b9469dd605189878a9922923d3691d/" rel="bookmark">
			Proteus仿真STM32的课设实例3——汽车倒车测距提示仪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：https://pan.baidu.com/s/1qQ8AC6V8a4dp8aqpMWCa-A?pwd=e0yo 提取码：e0yo
以stm32为最小系统电路进行连接，按钮控制系统开关，使用SRF04采集倒车，LM016L液晶显示屏显示汽车距离障碍物的实时距离。当距离障碍物大于100cm时，小车自由倒退，蜂鸣器、LED提示灯关闭，车辆正常倒退；当距离障碍物大于50cm小于100cm时，蜂鸣器报警，LED灯关闭，车辆正常倒退；当距离障碍物大于30cm小于50cm时，蜂鸣器报警，LED灯闪烁提示，车辆正常倒退；当距离障碍物小于30cm时，蜂鸣器报警，LED灯关闭，小车停止。
链接：https://pan.baidu.com/s/1qQ8AC6V8a4dp8aqpMWCa-A?pwd=e0yo 提取码：e0yo
该系统主要由stm32f103r6作为单片机最小系统、SRF04超声波传感器、LM016L显示屏、L298驱动直流电机、电容、二极管、蜂鸣器、LED灯、按键等硬件组成。
tm32f103r6作为单片机最小系统进行其他部件的连接；按键控制倒车测距系统的开关；SRF04超声波传感器进行小车距障碍物的距离测量；LM016L液晶显示屏显示实时距离；L298驱动直流电机对小车提供动力，驱动小车倒车的动力；led灯和蜂鸣器对倒车距离情况进行反馈。
链接：https://pan.baidu.com/s/1qQ8AC6V8a4dp8aqpMWCa-A?pwd=e0yo 提取码：e0yo
部分源代码
#include "delay.h"
#define PRESCALER_US 1e6
#define PRESCALER_MS 1e3
void delay_ms(int32_t ms){
uint32_t temp,temp1; SysTick-&gt;LOAD=(uint32_t)ms*(SystemCoreClock/PRESCALER_MS); //时间加载(SysTick-&gt;LOAD为24bit)
SysTick-&gt;VAL =0x00; //清空计数器
SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ; //开始倒数 temp1=SysTick-&gt;VAL;
do
{
temp=SysTick-&gt;CTRL;
}while((temp&amp;0x01)&amp;&amp;!(temp&amp;(1&lt;&lt;16))); //等待时间到达 SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk; //关闭计数器
SysTick-&gt;VAL =0X00; //清空计数器 }
void delay_us(uint32_t time) //3.5us+1.5us*（time-1）
{ time=2*time;
while(time--); }
2.LCD液晶显示屏配置：
#include "main.h"
//使能1602液晶使用的引脚
void LCD1602_PORT_Init(void)
{
GPIO_InitTypeDef GPIO_InitStructure;
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOx,ENABLE); //使能PC端口时钟 GPIO_InitStructure.GPIO_Pin = GPIOx_Pin; //端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70b9469dd605189878a9922923d3691d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1751fadcf2e6fedf6f5f39ed0acc838c/" rel="bookmark">
			Java面试题一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面对Java的面试题进行整理，一是以备面试时进行问题挑选，二是准备面试时使用。
面试题一为java基础的面试题
1、java基础 1.1、面向对象的特征？ 封装、继承、多态
封装：把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。
继承：继承是使⽤已存在的类的定义作为基础创建新的类，新类的定义可以增加新的属性或新的方法，也可以继承父类的属性和方法。通过继承可以很方便地进行代码复用。
多态：指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定，即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在由程序运⾏期间才能决定。在 Java 中有两种形式可以实现多态：继承（多个⼦类对同⼀⽅法的重写）和接⼝（实现接⼝并覆盖接⼝中同⼀⽅法）。
1.2、java基本数据类型有那些？ 基础类型有8种，分别为byte，int，long，double，float，char，boolean，short
1.3、操作字符串都有那些类？区别是什么？ 操作字符串的类有String，StringBuffer，StringBuilder；
String声明的是不可变对象，每次操作都会生成新的String对象，后两者是可变对象，可以在原有对象基础上进行操作；StringBuffer是线程安全的，另两种是非线程安全的，但StringBuilder的性能高于StringBuffer；
1.4、如何对字符串进行反转？ 使用StringBuilder或StringBuffer的reverse方法
1.5、普通类、抽象类的区别是什么？ 普通类不能包含抽象方法，抽象类可以；普通类可以实例化，抽象类不可以；
1.6、java容器都有那些（或集合类或数据结构）？ 常用的容器有Collection、List、Queue、Set、ArrayList、LinkedList、HashSet、TreeSet；Map、HashMap、TreeMap。
java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。
1.7、HashMap的底层数据结构、特点及原理？ 数组+链表+红黑树，装载因子为0.75。
HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。
当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。
需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)
1.8、ArrayList和LinkedList的区别是什么？ 前者底层数据结构是数组，支持随机访问，后者是双向链表，易于插入操作；ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。
1.9、如何实现数组和 List 之间的转换？ List转换成为数组：调用ArrayList的toArray方法。
数组转换成为List：调用Arrays的asList方法。
1.10、迭代器 Iterator 是什么？怎么使用？有什么特点？ 迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。
Java中的Iterator功能比较简单，并且只能单向移动：
使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。使用next()获得序列中的下一个元素。使用hasNext()检查序列中是否还有元素。使用remove()将迭代器新返回的元素删除。 1.11、异常类用过那些？ 空指针异常、数组越界异常、IO异常、算数异常、格式转换异常；
1.12、运行时数据区包括那些？ 程序计数器、虚拟机栈、本地方法栈、堆、方法区；前3为私有，后2为共享；
堆从垃圾回收的角度分为：新生代、老年代，其中新生代包含Eden空间、From Survivor空间、To Survivor空间；
1.13、JDK和JRE的区别 JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。
JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1751fadcf2e6fedf6f5f39ed0acc838c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6444076d992198bc3ae219afb8d50de9/" rel="bookmark">
			Scrapy 下载器中间件、spider中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scrapy 官方文档 ( 下载器中间件 )
：https://doc.scrapy.org/en/latest/topics/downloader-middleware.html：https://www.osgeo.cn/scrapy/topics/downloader-middleware.html Scrapy 扩展中间件: 针对特定响应状态码，使用代理重新请求：https://www.cnblogs.com/my8100/p/scrapy_middleware_autoproxy.html
https://www.baidu.com/s?wd=中间件状态码不等于200重新请求
1、下载器 中间件 ( Downloader Middleware ) 下载器中间件是介于 Scrapy 的 request/response 处理的钩子框架。 是用于全局修改Scrapy request 和 response 的一个轻量、底层的系统。
Downloader Middleware 即 下载中间件。它是处于Scrapy的 Engine 和 Downloader 之间的处理模块。在 Engine 把从 Scheduler 获取的 Request 发送给 Downloader 的过程中，以及Downloader 把 Response 发送回 Engine 的过程中，Request 和 Response 都会经过 Downloader Middleware 的处理。
也就是 DownloaderMiddleware 在整个架构中起作用的位置是以下两个
Engine从Scheduler获取Request发送给Downloader，在Request被 Engine 发送给Downloader执行下载之前，DownloaderMiddleware可以对Request进行修改。Downloader执行Request后生成Response，在Response被Engine发送给Spider之前，也就是在Resposne被Spider解析之前，Downloder Middleware可以对Response进行修改 DownloderMiddleware 在整个爬虫执行过程中能起到非常重要的作用，功能十分强大。可以修改User-Agent、处理重定向、设置代理、失败重试、设置Cookie 等。
Downloader Middleware 的用法非常简单，只要实现 process_request、process_response、process_exception 中的任意一个方法即可，同时不同方法的返回值不同，其产生的效果也不同。
关于 调用 顺序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6444076d992198bc3ae219afb8d50de9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e234f48a7ab1e085259319b012c65620/" rel="bookmark">
			Python基础 给玻璃球工作室的新生们
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 去年还是在学习的那个，今年就要给新生们上课了。
首先先欢迎大家来到玻璃球这个大家庭。 写这篇文章是为了防止自己授课忘记讲一些知识点，今天先把知识点写在这里。当然我们这节课还是以实战为主。
一、Python特色 要说这门语言的特色，我觉得缩进就是最大的特色就是缩进了。而且是严格要求缩进哦。缩进的理解其实就是空格，不过先声明，这里的空格是相等长度的，不然程序就会报错。
然后我们简单讲讲特点。
Python 具有以下特点：
易学易用：Python 的语法简单、易读易写，基于缩进来表示代码块，不需要像其他语言一样使用大括号或关键字来表示代码块。开源免费：Python 是一种开源的编程语言，可以免费获取和使用，也可以自由修改和分发。跨平台性：Python 可以在各种操作系统上运行，包括 Windows、Linux、MacOS 等。库和框架丰富：Python 有大量的标准库和第三方库和框架，方便程序员进行开发和编写代码。面向对象：Python 是一种面向对象的编程语言，支持类、对象、继承、多态等概念。解释型语言：Python 是一种解释型语言，因此可以直接运行，不需要编译。 二、变量 注释 保留关键字 输入输出 数据类型 2.1 变量 变量就是为了存储某个值而预留的内存空间。python变量声明的时候不需要像C、Java这些语言要显式声明。
a = 2 # C语言中 要int a = 2; 但是python不需要 print(a) a = "blq" print(a) 2.2 注释 单行注释用井号，多行注释用三个双引号包起来。
""" blq123 这是多行的注释方法 """ 2.3保留关键字 通过调包来看
#保留关键字有哪些 import keyword print(keyword.kwlist) 就咱们写程序命名变量不要把变量名弄成这些哈。
2.4输入输出 学会用print 和input函数
#输出 print("hello world") print("hello","world","blq") print("hello"+"world"+"blq") print("hello","world","blq",sep="***")#sep是分隔符 #输入 print("请输入你的名字：") name = input() print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e234f48a7ab1e085259319b012c65620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11f13492c36556216be333c82865d3f0/" rel="bookmark">
			如何在 Android Studio 中使用 ButterKnife 修复此错误？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		构建成功，但在模拟器上运行失败并在控制台中显示以下消息:
Cause: superclass access check failed: class butterknife.compiler.ButterKnifeProcessor$RScanner (in unnamed module @0x65e8e2f6) cannot access class com.sun.tools.javac.tree.TreeScanner (in module jdk.compiler) because module jdk.compiler does not export com.sun.tools.javac.tree to unnamed module @0x65e8e2f6
我试过的:从 Gradle 中删除 Butterknife，同步，添加回来，再次同步。完全删除 Butterknife 库，它不会在编译时产生此错误，但由于缺少 Butterknife 显然无法编译。
我的环境: Butterknife 10.2.3 Android 级插件版本:7.1.2 - Gradle 版本:7.2 - Android Studio Bumblebee
我读过这个错误发生在其他库中，在极少数情况下似乎与我的无关，我仍然没有找到解决方案。我知道 Butterknife 已被弃用，我应该迁移到 ViewBinding，但目前将整个项目转换为一项艰巨的任务。谢谢! 最佳答案
您应该使用不同的 jdk 进行编译，我正在使用过于高级的 jdk 进行编译。将其还原为 jdk11 为我解决了
关于android - 如何在 Android Studio 中使用 ButterKnife 修复此错误？，我们在Stack Overflow上找到一个类似的问题： How can I fix this error with ButterKnife in Android Studio?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11f13492c36556216be333c82865d3f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cf0f2a0ee512fde6f768381680d3255/" rel="bookmark">
			如何使用 MiniGPT-v2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MiniGPT-v2 是一个基于视觉语言模型（LLM）的多任务学习系统。它可以用于各种视觉语言任务，包括图像描述、图像识别、图像-文本对话等。
本文将介绍如何使用 MiniGPT-v2。
MiniGPT-v2 提供了一个简单的在线演示，可以用于测试模型。
访问 MiniGPT-v2 - a Hugging Face Space by Vision-CAIR上传一个图像输入一个问题或指令点击 "提交" 示例
以下是一些使用 MiniGPT-v2 的示例：
生成图像描述： Python
response = model.generate(image_path="path/to/image", prompt="这张图描述的是...") 识别图像中的物体： Python
response = model.identify(image_path="path/to/image", prompt="这张图中有什么？") 回答关于图像的问题： Python
response = model.answer(image_path="path/to/image", prompt="这张图发生在哪里？") 结论 MiniGPT-v2 是一个强大的视觉语言模型，可以用于各种任务。它仍在开发中，但已经可以用于许多有趣的应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f521cf458887e00ce6b311dc340ea7c1/" rel="bookmark">
			Aria2NG连接aria2-pro提示认证失败的处理办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文档适用于已经安装了aria2-pro和AriaNg的小伙伴~
第一次登录管理端会提示”认证失败“
这是因为aria设置了密码，需要在设置中配置上密码即可
配置完密码重新加载就可以正常使用啦
下载速度明显比以前快了很多
下载参考文档
Docker安装下载神器aria2并使用过程记录_docker安装aria2-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/159640a4990533a183f7011a5bc24020/" rel="bookmark">
			算法--排序算法效率比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《算法设计与分析》课程实验报告 （ 实验一）
实验名称：排序算法效率比较
实验地点：
所使用的开发工具及环境： PC机，DEV++
一、实验目的：
比较至少 4 种排序（从小到大排）算法的执行效率。已学过的算法：冒泡排序、选择排序、插入排序、shell 排序，归并排序、快速排序等。 二、基本思想、原理和算法描述：
本次实验中使用到的冒泡排序、选择排序、插入排序、快速排序四种排序算法，它们的基本思想、原理和算法描述如下:
（1）冒泡排序：
重复遍历数组，每次遍历将当前最大的元素冒泡到最后。对于未排序部分，从数组首元素开始，依次比较相邻的两个元素。
（2）选择排序：
对于未排序部分，从数组首元素开始，逐个选择最小（或最大）的元素。将选出的最小（或最大）元素与未排序部分的首元素交换位置，将其放到已排序部分。重复上述步骤，直到全部排序完成。
（3）插入排序：
将数组分为已排序和未排序两部分，初始时已排序部分只包含一个元素（即数组的第一个元素）。从未排序部分选择一个元素，将它插入到已排序部分的正确位置，使已排序部分仍然有序。重复上述步骤，直到未排序部分为空。
（4）快速排序：
选择一个基准元素，一般选择数组的最后一个元素。将比基准小的元素移到左侧，比基准大的元素移到右侧。可以使用双指针或单指针的方式进行分区操作。对基准元素左右的两个分区分别进行递归快速排序。重复上述步骤，直到每个分区只包含一个元素或为空。
（5）归并排序：
分割：将待排序的数组分割为两个子数组，找到数组的中间位置 mid = (left + right)/2，其中 left 表示数组的起始位置，right 表示数组的终止位置。
递归排序：对左右两个子数组分别递归调用归并排序函数 mergeSort，将其分割为更小的子数组，并进行排序。
合并：将排好序的左右两个子数组按照大小顺序合并到原始数组中。为此，需要创建一个临时数组 temp，用来存储合并后的结果。设置三个指针：i 指向左子数组的起始位置，j 指向右子数组的起始位置，k 指向临时数组的起始位置。比较左右两个子数组的元素大小，将较小的元素放入临时数组，并将指针向后移动。重复这个过程，直到其中一个子数组的元素全部放入临时数组。将剩余的子数组中的元素直接拷贝到临时数组中，最后将临时数组的元素复制回原始数组相应的位置。
三、实验内容。
1、随机产生 50000+个数据，并保存至文件 test 中。
核心代码：
2、至少编写 4 种排序算法。
（1）冒泡排序：
（2）插入排序：
（3）选择排序：
（4）快速排序：
（5）归并排序：
3、调用步骤 2 中编写的程序，并从 test 中读取数据并排序，输出从读取到排好序，总共需要的时间。
4、结合时间复杂度，验证并分析几种排序算法的优劣。
（1）冒泡排序(Bubble Sort)的时间复杂度为O(n^2)。
（2）选择排序(Selection Sort)的时间复杂度也为O(n^2)。
（3）插入排序(Insertion Sort)的时间复杂度也为O(n^2)
（4）快速排序的平均时间复杂度为O(nlogn)。
（5）归并排序的平均时间复杂度为O(nlogn)。
在上述实验中测试的数据时间从大到小的排序是：选择&gt;插入&gt;冒泡&gt;快速&gt;归并。所以，综上所述，快速排序和归并排序不论是从时间复杂度来讲还是实际操作中所用的时间来说，都要比其他（实验中的的选择排序，插入排序，冒泡排序）算法来讲，都要好得多。
5、如果随机生成的数据是基本有序，或者是有序，或者是反序时，运行结果会怎么样？怎样解决这种问题，试提出你的解决方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/159640a4990533a183f7011a5bc24020/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3cb29c3310ddf529e811c1c30755ed1/" rel="bookmark">
			P1952 火星上的加法运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 2010; const char* output = "0123456789abcdefghijklmnopqrstuvwxyz"; char s1[maxn],s2[maxn]; int a[maxn],b[maxn],c[maxn]; int change(char ch) { if(isalpha(ch)) return ch - 'a' + 10; else return ch - '0'; } int main() { int mod; scanf("%d",&amp;mod); scanf("%s%s",s1,s2); int l1 = strlen(s1),l2 = strlen(s2); for(int i = 0;i &lt; l1;i++) a[i] = change(s1[l1 - i - 1]); for(int i = 0;i &lt; l2;i++) b[i] = change(s2[l2 - i - 1]); int l3 = max(l1,l2); for(int i = 0;i &lt; l3;i++) { c[i] += a[i] + b[i]; c[i + 1] += c[i]/mod; c[i] %= mod; } if(c[l3]) l3++; for(int i = l3 - 1;i &gt;= 0;i--) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3cb29c3310ddf529e811c1c30755ed1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b9dddf16ebe1c7fc042dc1be64d2ab0/" rel="bookmark">
			Spring 注解汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、声明 您可以通过在Servlet的WebApplicationContext中使用标准的Springbean定义来定义控制器bean。@Controller原型允许自动检测，与Spring在类路径中检测@Component类并自动注册bean定义的一般支持保持一致。它还充当注释类的原型，指示其作为web组件的角色。
要启用此类@Controllerbean的自动检测，可以将组件扫描添加到Java配置中，如下例所示：
@Configuration @ComponentScan("org.example.web") public class WebConfig { // ... } @RestController是一个复合注释，它本身用@Controller和@ResponseBody进行元注释，以指示其每个方法都继承类型级别@ResponsBody注释的控制器，因此，与视图解析和HTML模板渲染相比，它直接写入响应体。
2、请求映射 您可以使用@RequestMapping注释将请求映射到控制器方法。它具有各种属性，可通过URL、HTTP方法、请求参数、标头和媒体类型进行匹配。您可以在类级别使用它来表示共享映射，或者在方法级别使用它缩小到特定的端点映射。
@RequestMapping还有特定于HTTP方法的快捷方式变体：
@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@PatchMapping
提供快捷方式是自定义注释，因为可以说，大多数控制器方法应该映射到特定的HTTP方法，而不是使用@RequestMapping，默认情况下，@RequestMapping与所有HTTP方法匹配。在类级别仍然需要@RequestMapping来表示共享映射。
@RestController @RequestMapping("/persons") class PersonController { @GetMapping("/{id}") public Person getPerson(@PathVariable Long id) { // ... } @PostMapping @ResponseStatus(HttpStatus.CREATED) public void add(@RequestBody Person person) { // ... } } 3、URI 模式 @RequestMapping可以使用 URL 模式映射方法。有两种选择：
PathPattern — 与URL路径匹配的预解析模式也预解析为PathContainer。此解决方案专为web使用而设计，可有效处理编码和路径参数，并有效匹配。
AntPathMatcher — 根据字符串路径匹配字符串模式。这是Spring配置中用于选择类路径、文件系统和其他位置上的资源的原始解决方案。它的效率较低，字符串路径输入对于有效处理URL的编码和其他问题是一个挑战。
PathPattern是web应用程序的推荐解决方案，也是SpringWebFlux中的唯一选择。它从5.3版开始在SpringMVC中启用，默认情况下从6.0版开始启用。有关路径匹配选项的自定义，请参阅MVC配置。
PathPattern支持与AntPathMatcher相同的模式语法。此外，它还支持捕获模式，例如{*spring}，用于匹配路径末端的0个或多个路径段。PathPattern还限制使用**来匹配多个路径段，以便只允许在模式末尾使用。这消除了为给定请求选择最佳匹配模式时的许多不确定性。有关完整模式语法，请参阅PathPattern和AntPathMatcher。
示例模式：
“/resources/ima？e.png”-匹配路径段中的一个字符
“/resources/*.png”-匹配路径段中的零个或多个字符
“/resources/**”-匹配多个路径段
“/projects/{project}/versions”-匹配路径段并将其捕获为变量
“/projects/{project:[a-z]+}/versions”-使用正则表达式匹配并捕获变量
可以使用@PathVariable访问捕获的URI变量。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b9dddf16ebe1c7fc042dc1be64d2ab0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4450a4ec4c512397d953ecabdef89252/" rel="bookmark">
			mysql 的jsonTable使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON_TABLE 是 MySQL 8.0 中一个新的 JSON 函数。它也是一个表函数，返回值不是标量值而是结果集。JSON_TABLE 将 JSON 文档(部分或全部)转换为关系表，以便您可以像使用普通表一样使用它。JSON_TABLE 函数从一个指定的 JSON 文档中提取数据并返回一个具有指定列的关系表。可以像普通的表一样使用 JSON_TABLE () 返回的表。
json-table官方文档地址
https://dev.mysql.com/doc/refman/8.0/en/json-table-functions.html#function_json-table
以下是jsontable的语法 JSON_TABLE( expr, path COLUMNS (column_list) ) [AS] alias column_list: column[, column][, ...] column: name FOR ORDINALITY | name type PATH string path [on_empty] [on_error] | name type EXISTS PATH string path | NESTED [PATH] path COLUMNS (column_list) on_empty: {NULL | DEFAULT json_string | ERROR} ON EMPTY on_error: {NULL | DEFAULT json_string | ERROR} ON ERROR 使用示例 假设我们有一个表包含ID和名称：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4450a4ec4c512397d953ecabdef89252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81fa81958d744fcc96c890078792bd93/" rel="bookmark">
			【MATLAB】滞后校正装置的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.串联滞后校正2.滞后校正的设计步骤3.滞后校正仿真示例结论 1.串联滞后校正 滞后校正的实质是利用滞后网络幅值衰减特性，将系统的中频段压低，使校正后系统的截止频率减小，挖掘系统自身的相角储备来满足校正后系统的相角裕度要求。
滞后校正装置的传递函数为： G e ( s ) = 1 + b T s 1 + T s G_e(s)=\frac{1+bTs}{1+Ts} Ge​(s)=1+Ts1+bTs​只需要求出式子中的参数b,T，即可得到校正装置的传递函数。
2.滞后校正的设计步骤 (1) 按要求的稳态误差系数，求出系统的开环放大倍数 K K K。
(2) 根据 K K K值，画出原系统的Bode图，求取原系统的相角裕度和幅值裕度，根据要求的相角裕度并考虑滞后角度的补偿，求出校正后系统的截止频率 ω c ′ \omega'_c ωc′​。
(3) 令滞后装置的最大衰减幅值等于原系统对应 ω ‘ c \omega‘_c ω‘c​的幅值，求出滞后装置的参数b，即 b = 1 0 − L ( ω c ′ ) 20 b=10^{\frac{-L(\omega'_c)}{20}} b=1020−L(ωc′​)​，或 b = 1 ∣ G ( j ω ) ∣ b=\frac{1}{|G(j\omega)|} b=∣G(jω)∣1​。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81fa81958d744fcc96c890078792bd93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bc3dac24d20100b19b6a9d44fe46820/" rel="bookmark">
			使用a-select组件实现多数据源远程搜索下拉框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间写了一个用ele的组件有默认展示的数据，也能下拉触底加载新数据，然后搜索也能实现搜索远程数据，如有需要请看使用组件加自定义指令实现下拉加载select和远程搜索select_Mr.mjw的博客-CSDN博客
然后这个相对于那个实现起来简单一点
下面就是具体代码
是在vue2中使用的先看data中的数据组件的
&lt;a-select show-search :value="personName" placeholder="input search text" style="width: 200px" :default-active-first-option="false" :show-arrow="false" :filter-option="false" :not-found-content="null" @search="handleSearch" @change="handleChange"&gt; &lt;a-select-option v-for="d in data" :key="d.value"&gt; {{ d.text }} &lt;/a-select-option&gt; &lt;/a-select&gt; data() { return { personName: '', data: [], } }, 下面是组件中用到的方法，为了提高性能代码中用到了防抖
fetch(value, callback) { let timeout; let currentValue; if (timeout) { clearTimeout(timeout); timeout = null; } currentValue = value; function fake() { getAction(`这变换成你的远程数据的接口`).then(res =&gt; { // console.log(res, '11111111111'); //然后把请求到的数据放到data中 if (currentValue === value) { const result = res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bc3dac24d20100b19b6a9d44fe46820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89a083658ad532551aa7827beee17f3e/" rel="bookmark">
			three.js加载gltf模型并更换材质贴图遇到了一个问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题，在加载了gltf模型后，想要更换模型中的某个网格的贴图，在使用了官方的方法后，发现材质贴图似乎不匹配原有的网格，以下是不匹配的效果：
更换材质贴图的代码（未修改前）：
//纹理贴图加载器TextureLoader const texLoader = new THREE.TextureLoader(); //src是贴图地址 var texture = texLoader.load(src) obj.material.map = texture; 原始效果：
贴图材质目标效果（拿blender做测试的效果）：
更换后不匹配的效果：
修改代码后，达到的目标效果：
和blender测试的效果基本一致。
下面贴修改后的代码：
//纹理贴图加载器TextureLoader const texLoader = new THREE.TextureLoader(); //src是贴图地址 var texture = texLoader.load(src) //以下几个有影响 texture.colorSpace = obj.material.map.colorSpace texture.flipY = obj.material.map.flipY texture.repeat = obj.material.map.repeat texture.wrapS = obj.material.map.wrapS texture.wrapT = obj.material.map.wrapT //下面几个不确定，注释了也没影响 texture.name = obj.material.map.name texture.userData = obj.material.map.userData texture.version = obj.material.map.version obj.material.map = texture; 可以看到，就是在替换texture时将texture的部分属性保持和原来的texture属性一致即可。
这是一种方法，如果有更好的方法，欢迎评论留言！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b2ce44cab7b2eb36aa4e6a90c84d8c/" rel="bookmark">
			介绍OpenVINO 2023.1: 在边缘端赋能生成式AI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Yury Gorbachev；翻译：武卓，杨亦诚
在过去的一年里，我们看到了生成式AI用例和模型的爆炸式增长。现在几乎每周都会针对不同的领域发布新的值得注意的生成式模型，这些模型在不断增加的数据集上训练，具有各种计算复杂性。使用像LoRA这样的方法，可以在非常适度的训练加速器上微调大模型，这解锁了对基础模型的更多修改。由于资源消耗，部署这些模型仍然是挑战，并且高度依赖于在云端部署模型。
随着 OpenVINO™ 2023.1 版本的发布，我们希望将生成式 AI 的强大功能引入常规台式机和笔记本电脑，让这些模型可以运行在在资源受限的本地环境中，，并被您尝试集成到自己的应用程序中。我们在整个产品中针对这些场景进行了优化，实现了一些关键功能，并为我们的下一步工作计划奠定了基础。 也就是说，我们的变化不仅限于生成式AI，我们还改进了产品的其它部分，并希望它能使您的工作更轻松，并为您带来额外的价值。 让我们来看看这些变化到底是什么。。 生成式 AI 功能 大模型的整体堆栈优化。来自生成式AI家族的模型有一个共同点——它们亟需资源。模型尺寸巨大，运行它们所需的内存量非常高，对内存带宽的需求也非常大。例如不必要的权重搬运这样简单的问题，都可能会导致由于内存不足而无法运行模型。
为了更好地适应这一点，我们已经跨推理堆栈工作，包括 CPU 和 GPU（集成显卡和独立显卡），目标就是优化我们使用这些模型的方式，包括优化读取和编译模型所需的内存，优化如何处理模型的输入和输出张量以及其他内部结构，从而缩短模型执行时间。
大型语言模型的权重量化。LLM 在执行时需要大量的内存带宽。为了对此进行优化，我们在 NNCF（神经网络压缩框架） 优化框架和 CPU 推理中实现了 int8 LLM 权重量化功能。
使用此功能时，NNCF 将生成优化的 IR 模型文件，与精度为 fp16 的常规模型文件相比，该文件能够将尺寸减小一半。IR 文件将在 CPU 插件中被执行额外的优化，这将改善延迟并减少运行时内存消耗。GPU 的类似功能正在实施中，并将在后续发布的版本中提供。
更容易转换模型。大多数LLM目前来自基于PyTorch的环境。要转换这些模型，您现在可以使用我们的直接 PyTorch 转换功能。对于LLM，与我们之前通过ONNX格式的路径相比，这大大加快了转换时间并减少了内存需求。
总体而言，由于我们的优化，我们能够在CPU和GPU上均能提高 LLM 性能。[WZ1] 此外，我们还按 倍数级减少了运行这些模型所需的内存量。在某些情况下，新版本OpenVINO可以让我们运行那些以前由于内存不足而失败的模型。我们一直在数十个不同规模和不同任务的LLM上验证我们的工作，以确保我们的方法能够很好地扩展到我们所有的平台和支持的操作系统。
我们的转换 API 和权重量化功能也集成到Hugging Face optimum-intel扩展中，允许您使用 OpenVINO 作为推理堆栈运行生成式模型，或以方便的方式将模型导出为 OpenVINO 格式。
[WZ1]找不到性能方面的公开描述，在这里考虑了简化描述。
简化您的工作流 不再需要开发包，提供统一的工具。从 2023.1 版本开始，我们不再要求您为运行时和开发环境分别安装单独的软件包。我们一直致力于简化我们的工具，并将所有必要的组件集成到单个 OpenVINO 软件包中。这也意味着模型转换和推理可以通过所有OpenVINO分发机制以统一的方式获得：pip，conda，brew和archive。
此外，从此版本开始，OpenVINO Python API 可从所有支持最低要求 Python 版本 （3.7） 的软件包中获得。这意味着除了以前可用的 pip 之外，还有conda、brew和指定的 apt 版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24b2ce44cab7b2eb36aa4e6a90c84d8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/815fe7ecea58da820aea76b3d9f54c51/" rel="bookmark">
			BGP基本配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【1】BGP邻居关系建立，与路由条目宣告是分开的配置的 （1）直连的EBGP邻居关系建立 [r1]bgp 1 //启动BGP协议，启动时需要键入AS号；没有多进程概念 [r1-bgp]router-id 1.1.1.1 //建议配置RID；若不配置将自动生成—规则同OSPF相同 [r1-bgp]peer 12.1.1.2 as-number 2 //对端IP地址，及对端所在的AS编号 （2）IBGP邻居关系建立 在一个AS内部，拓扑正常较为负载；建议使用环回接口地址作为源、目标ip地址；存在备份链路，同时可以多条物理链路传递；
[r2]bgp 2 [r2-bgp]peer 3.3.3.3 as-number 2 //对端环回接口ip地址，及对端所在AS号 切记：一旦使用环回接口建立BGP的邻居关系；必须将源地址也修改为环回接口 [r2-bgp]peer 3.3.3.3 connect-interface LoopBack 0 （3）EBGP邻居间存在多条物理链路时，也建议使用环回接口地址来建立 [1]、IP可达，建议静态路由
[2]、正常环回做为源、目ip地址建立邻居关系
[3]、默认IBGP邻居间数据包的TTL值为255，EBGP邻居间TTL为1；故一旦使用环回建立ebgp邻居关系，必须修改TTL值，否则无法建立
[r4-bgp]peer 5.5.5.5 ebgp-max-hop 2 当建邻配置完成后，邻居间通过三次握手，建立TCP的会话
[r2]display tcp status //查看TCP会话表 当TCP会话建立后，邻居间BGP协议将正常收发一次open报文，建立BGP邻居关系；生成邻居表：
[r2]display bgp peer //查看BGP邻居表
BGP local router ID : 2.2.2.2
Local AS number : 2
Total number of peers : 1 Peers in established state : 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/815fe7ecea58da820aea76b3d9f54c51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47adacca9902e5922e18382c033b98e3/" rel="bookmark">
			u盘被写保护怎么解除步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用U盘的时候可能有的用户遇到过出现“介质受写入保护”等等的提示，但是自己又不知道U盘写保护怎么解除。大家不用着急，下面小编总结了相关教程，在这里跟大家分享一下，希望大家可以解决这个问题。
工具/原料：
系统版本：windows10系统
品牌型号：联想ThinkPad
方法/步骤：
针对注册表异常导致的U盘写保护解决方法：
1、首先点击开始-运行(或按win键+r)，输入“regedit”，点击“确定”。
2、依次展开HKEY_LOCAL_MACHINE \ SYSTEM \ CurrentControlSet \ Control，选中之后看看右边是否有“StorageDevicePolicies”，如果没有的话就需要新建。
3、新建方法。鼠标右键点击“Control”，依次点击新建-项。
4、将新建的项鼠标右键重命名为”StorageDevicePolicies”。
5、创建成功之后，点击打开StorageDevicePolicies，在空白处鼠标右键，点击新建-DWORD值，命名为WriteProtect。
6、再点击WriteProtect。 把WriteProtect的数值数据设置为0，点击确定之后插入U盘就可以啦。
总结：
以上就是u盘被写保护解除教程的相关内容啦，有需要的小伙伴一起来看看吧，希望对你有帮助。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/81/">«</a>
	<span class="pagination__item pagination__item--current">82/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/83/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>