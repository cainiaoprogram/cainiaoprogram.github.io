<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aae2b32a529037f07dacf653d7bcde2c/" rel="bookmark">
			时间控件-时分秒／分秒／年月日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 做项目的时候，很多时候我们会遇到使用时间控件的部分，下面介绍一个时间控件，---calendar.js，，这个控件是晚上照的，根据需要，把它修改的更加完善了。
首先我们需要引入这些文件：
这个日期控件的样式就是这样的；；；
其中，完善后的calendar日期控件功能包括：
1.我们可以快速选择年份和月份，并且日期是锁定的。
2.我们可以选择格式：包括：
yyyy-mm-dd HH:MM:SS yyyy-mm-dd HH:MM
yyyy-mm-dd
HH:MM:SS
HH:MM
使用的时候，也很方便，
最后附上百度云盘的链接，，大家需要的话，自行下载使用：
链接:http://pan.baidu.com/s/1hs7WigO 密码:0yap 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58d2ba8cf3e7f19ed173e4027c6845b3/" rel="bookmark">
			[python笔记]完善describe()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 def stats(x): return pd.Series([x.count(),x.min(),x.idxmin(), x.quantile(.25),x.median(), x.quantile(.75),x.quantile(.95),x.mean(), x.max(),x.idxmax(), x.mad(),x.var(), x.std(),x.skew(),x.kurt()], index = ['Count','Min','Which_Min', '25%','50%','75%','95%','Mean', 'Max','Which_Max','Mad', 'Var','Std','Skew','Kurt']) def describeAll(data): m = data.shape result =pd.DataFrame([]) for i in range(m[1]): result[i]=stats(data.loc[:,i]) return result df0=pd.DataFrame(np.random.randn(1000,5)) print(describeAll(df0)) print(df0.describe()) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0111a38d5fd0b35dfd31a172e04a9868/" rel="bookmark">
			Python爬虫——实战一：爬取京东产品价格(逆向工程方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在京东的单个产品页面上，通过查看源码检查html，可以看到 &lt;span class="p-price"&gt;&lt;span&gt;￥&lt;/span&gt;&lt;span class="price J-p-1279836"&gt;&lt;/span&gt;&lt;/span&gt; 这里没有直接给出价格。
这是因为价格数据是通过JS动态加载的，而HTML源码中并不包含动态加载的页面内容。
获取京东商品的价格 #-*- coding:utf-8 -*- import urllib2 import json def jd_price(url): sku = url.split('/')[-1].strip(".html") print sku price_url = "https://p.3.cn/prices/mgets?skuIds=J_" + sku response = urllib2.urlopen(price_url) content = response.read() result = json.loads(content) print result record = result[0] #print "price:", record['p'] return record['p'] if __name__=="__main__": jd_price("https://item.jd.com/12419422058.html") 上述代码的关键在于https://p.3.cn/prices/mgets?skuIds=J_12419422058” ，打开这个链接，可以看到：
这个就是针对价格请求返回的响应页面，其中”p”表示的就是商品的价格。
如何知道上面的URL中有价格信息呢？ 在火狐浏览器中安装了Firebug。右键点击商品价格，选择“使用Firebug查看元素”，可以看到打开的“HTML”中包含了价格信息。这是因为Firebug的”HTML”显示的是动态加载完所有数据后的源码。
现在选择Firebug的“网络”，然后刷新当前商品页面。然后选择“全部”，在“域”栏找到p.3.cn，该行对应的就是价格请求。
实际中遇到的问题 2017.8.22 在多次运行爬虫之后，价格页面返回的是
{"error":"pdos_captcha"} 采用渲染引擎方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b8f7c2f33ce8d6855afb8e1f1a887d/" rel="bookmark">
			MySQL中的distinct关键字简易了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一开始接触distinct的时候，博主不知道这是干什么用的，今天遇到了研究了下，和大家分享下我的看法。 select distinct price from product;
去掉重复的查询product表中的price字段
例： 1.创建数据库（mysql）
CREATE TABLE PRODUCT( PID INT PRIMARY KEY AUTO_INCREMENT, PNAME VARCHAR(20), PRICE DOUBLE, PDATE TIMESTAMP ); 2.向数据库中插入数据：
INSERT INTO PRODUCT VALUES(NULL,'谭妮平',0.01,null); INSERT INTO PRODUCT VALUES(null,'历史学',38,null), (null,'左慈',-998,null); INSERT INTO PRODUCT VALUES(NULL,'黄迎',99999,null), (null,'南国强',99999,null), (null,'士兵',1,null); 普通查询的结果： select * from product; select price from product; 3.使用distinct进行查询的结果： select distinct price from product; 4.结论： distinct就是帮你过滤掉重复内容的一种查询方式。如果有哪里不对，还请多多指教，在此拜谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a53c458a9614daa792e4caa85dbbb0cd/" rel="bookmark">
			CSS设置文字不换行，超出字数用...显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;p class="testText"&gt;这是一段实验文字，超出字数用...显示&lt;/p&gt; .textText{ width:50px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
当文本为多行文字时如下设置CSS.box p{ width:400px; border:1px solid #ccc; margin:20px auto; overflow : hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp:2; -webkit-box-orient: vertical; }
注意 react中需要把-webkit-line-clamp改为WebkitLineClamp-webkit-box-orient同理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4e7fa38345436d3f3f6d0e25a2fae3c/" rel="bookmark">
			Unable to add window -- token null is not valid; is your activity running?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一个activity的onCreate中写了如下的一段代码：
private final int WATIING_SECS = 5；
new Handler().postDelayed(new Runnable() {
@Override
public void run() {
// TODO Auto-generated method stub
if (isDialogShowing()) {
dismissWaitDialog();
if(popupwindowQueryState == null &amp;&amp; ControllerAirPage.this != null &amp;&amp; rootView != null){
popupwindowQueryState = new GoBackPopupwindow(ControllerAirPage.this,
getString(R.string.time_out),
getString(R.string.air_messge_getting_failed),
true);
popupwindowQueryState.showAtLocation(rootView, Gravity.CENTER, 0, 0);
}
}
}
}, WATIING_SECS * 1000);
大部分时间没有问题，但是当这个popupwindowQueryState没有显示出来，而我直接返回上一页的时候。就会遇到一个报错。
android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4e7fa38345436d3f3f6d0e25a2fae3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c9525f4da44826bd1b449dd20c2e84/" rel="bookmark">
			如何将CVBS模拟视频转换成 CSI-2数字视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先说一下什么是 CVBS，也就是俗称的模拟视频。那么都是模拟视频，PAL、NTSC、S-VIDEO、CVBS到底有什么区别呢？
NTSC（National Television System Committee）即正交平衡调幅制。PAL（Phase Alternating Line）为逐行倒像正交平衡调幅制。 国内基本是用PAL制标准，NTSC是美国标准。不过一般模拟显示器会同时支持两种格式。 CVBS：Color，Video，Blanking，Sync，或者composite video baseband signal； CVBS中包含了PAL与NTSC格式，是将亮度信号Y与色度信号C整合在一起的，S-video则是将两个信号独立传输。 OK，那么介绍完概念，再说一下 CSI-2接口。这是比较常见的数字视频传输接口，其实是MIPI电气接口。 除此之外还有 LVDS/sub-LVDS等传输电气接口。 那么就进入正题，就是如何快速将CVBS信号转成MIPI视频？ 答案很简单，就是直接用转换芯片：以 ADI的 ADV7280M为例，其框图如下。 可以支持8路模拟视频，输出1X MIPI 数字视频，这样就可以将模拟视频直接接入到 ARM等处理器进行处理了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe05c3ddfd4ac1139ef556e5c83826b/" rel="bookmark">
			stm32学习笔记（八）中断服务函数与函数调用的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 程序, 中断, 调用, 函数 在《微机原理》和《计算机组成》等课程[1-4]教学中（本文以MCS-51单片机为例），中断过程既是教学难点又是教学重点，它与主程序调用子程序过程有一定相似性，但又有很大区别，调用子程序过程相对比较容易掌握，通过把两过程结合起来，采用比较教学方法，能收到了很好的教学效果。 1、两过程定义与作用 子程序是微机基本程序结构中的1种，基本程序结构包括顺序（简单）、分支（判断）、循环、子程序和查表等5种。 子程序是一组可以公用的指令序列，只要给出子程序的入口地址就能从主程序转入子程序。子程序在功能上具有相对的独立性，在执行主程序的过程中往往被多次调用，甚至被不同的程序所调用。一般微机首先执行主程序，碰到调用指令就转去执行子程序，子程序执行完后，返回指令就返回主程序断点（即调用指令的下一条指令），继续执行没有处理完的主程序，这一过程叫做（主程序）调用子程序过程。 子程序结构可简化程序，防止重复书写错误，并可节省内存空间。计算机中经常把常用的各种通用的程序段编成子程序，提供给用户使用。用户在自己编写的程序中，只要会调用这些子程序，就可大大简化用户编程的困难。 中断是计算机中央处理单元CPU与外设I/O交换数据的一种方式，除此方式外，还有无条件、条件（查询）、存贮器直接存取DMA和I/O通道等四种方式。由于无条件不可靠，条件效率低，DMA和I/O通道两方式硬件复杂，而中断方式CPU效率高，因此一般大多采用中断方式。 中断概念是当计算机正在执行某一（主）程序时，收到一中断请求，如果中断响应条件成立，计算机就把正在执行的程序暂停一下，去响应处理这一请求，执行中断服务程序，处理完服务程序后，中断返回指令使计算机返回原来还没有执行完的程序断点处继续执行，这一过程称为中断过程。有了中断，计算机才能具有并行处理，实时处理和故障处理等重要功能。 2、两过程的联系与区别 2.1联系 中断与调用子程序两过程属于完全不同的概念，但它们也有不少相似之处。两者都需要保护断点（即下一条指令地址）、跳至子程序或中断服务程序、保护现场、子程序或中断处理、恢复现场、恢复断点（即返回主程序）。两者都可实现嵌套，即正在执行的子程序再调另一子程序或正在处理的中断程序又被另一新中断请求所中断，嵌套可为多级。 正是由于这些表面上的相似处，很容易使学生把两者混淆起来，特别是把中断也看为子程序，这就大错特错了。 2.2区别 中断过程与调用子程序过程相似点是表面的，从本质上讲两者是完全不一样的。 两者的根本区别主要表现在服务时间与服务对象不一样上。首先，调用子程序过程发生的时间是已知和固定的，即在主程序中的调用指令（CALL）执行时发生主程序调用子程序，调用指令所在位置是已知和固定的。而中断过程发生的时间一般的随机的，CPU在执行某一主程序时收到中断源提出的中断申请时，就发生中断过程，而中断申请一般由硬件电路产生，申请提出时间是随机的（软中断发生时间是固定的），也可以说，调用子程序是程序设计者事先安排的，而执行中断服务程序是由系统工作环境随机决定的；其次，子程序完全为主程序服务的，两者属于主从关系，主程序需要子程序时就去调用子程序，并把调用结果带回主程序继续执行。而中断服务程序与主程序两者一般是无关的，不存在谁为谁服务的问题，两者是平行关系；第三，主程序调用子程序过程完全属于软件处理过程，不需要专门的硬件电路，而中断处理系统是一个软、硬件结合系统，需要专门的硬件电路才能完成中断处理的过程；第四，子程序嵌套可实现若干级，嵌套的最多级数由计算机内存开辟的堆栈大小限制，而中断嵌套级数主要由中断优先级数来决定，一般优先级数不会很大。 http://blog.csdn.net/douyuhua0918/article/details/7473254
中断是嵌入式系统中重要的组成部分，但是在标准C中不包含中断。许多编译开发商在标准C上增加了对中断的支持，提供新的关键字用于标示中断服务程序 (ISR)，类似于__interrupt、#program interrupt等。当一个函数被定义为ISR的时候，编译器会自动为该函数增加中断服务程序所需要的中断现场入栈和出栈代码。
中断服务程序需要满足如下要求：
(1)不能返回值；
(2)不能向ISR传递参数；
(3) ISR应该尽可能的短小精悍；
(4) printf(char * lpFormatString,…)函数会带来重入和性能问题，不能在ISR中采用。
参阅网上资料和个人的一些理解
a.为什么不能有返回值？
中断服务函数的调用是硬件级别的，当中断产生，pc指针强制跳转到对应的中断服务函数入口，进入中断具有随机性，并不是某段代码对其进行调用，那么如果有返回值它的返回值返回给谁?显然这个返回值毫无意义，如果有返回值，它必定需要进行压栈操作，这样一来何时出栈怎么出栈将变得无法解决。
b.不能向ISR传递参数?
同理，也是由于这样会破坏栈的原因，因为函数传递参数必定会要求压栈出栈操作，由于进入中断服务函数的随机行，谁给它传递参数都成问题
c.ISR应尽可能的短小精悍?
如果某个中断频繁产生，而它对应的ISR相当的耗时，那么对中断的响应就会无限的延迟，会丢掉很多的中断请求
d.printf(char * lpFormatString,…)函数会带来重入和性能问题，不能在ISR中采用。
这就涉及到一个中断嵌套问题，由于printf之类的glibc函数采用的是缓冲机制，这个缓冲区是共享的，相当于一个全局变量，第一层中断来时，它向缓冲里面写入一些部分内容，恰好这时来了个优先级更高的中断，它同样调用了printf，也向缓冲里面写入一些内容，这样缓冲区的内容就错乱了。
http://www.cnblogs.com/thammer/p/5017329.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeec84988a722ca15b3c546571c049a4/" rel="bookmark">
			给初学PLC编程的朋友几点建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可编程控制器是集计算机技术、通讯技术、自动控制技术为一体的工业控制装置。对于初学者来说掌握了plc基本原理，熟悉常用的编程方法，在进行简单系统编程时尚可以运用自如，但对较为复杂的控制系统设计往往力不从心，要想在PLC应用方面得心应手，学习者除了要建立正确的学习方法，深入学习plc编程技巧，最重要的是相关知识的学习。下面从六个方面谈谈我的教学心得。 一、多收集程序范例、增加编程经验 在PLC的编程方法中，经验法一直受到许多从业者的青睐，并且在经验设计法中资料收集显得尤为重要。首先收集典型程序样例，程序最好有较完整的组成部分：控制任务、I/O分配、硬件接线图、完整的程序及注释。其次要读懂程序，从而分解出程序中用于完成不同任务的组成部分，对于各组成部分中独立完成某一特定功能的子程序或者中断程序应及时收藏到程序库。以便在以后的编程过程中碰到实现类似控制任务时，节约程序设计时间、提高程序调试成功率。再次还需要记录程序闪光点，诸如编程者巧妙的思路、程序结构、应用指令的使用。尤其是应用指令的使用，能够大大的缩短程序长度，减少内存容量，降低系统成本。最后对程序做功能扩展性的设计、调试，并对全过程加以详细记录、再加以总结。通过以上过程就能够有效消化这些程序范例，使其融入到自己以后的编程过程中。经过一段时间的资料收集、理解、消化后，逐步确立适合自己的编程方法。 二、熟练使用软件包 以学习三菱产品为例来介绍软件包的使用。三菱软件包由两个部分组成，编程软件GXDeveloperVersion8C和仿真软件GXSimulator6C。编程软件GXDeveloperVersion8C为设计者提供了编程环境。设计者应熟读编程手册、熟练程序的编辑技巧,使得自己的设计方案得以展现。设计好的程序能否满足控制任务，就必须进行调试,传统的调试方式离不开编程控制器CPU,必要时还需要另外准备输入输出模块、特殊功能模块和外部机器等。仿真软件GXSimulator可提供一个虚拟的实验平台。GXSimulator是在Windows上运行的软元件包，在安装有GXDeveloper的计算机内追加安装GXSimulator，就能够实现不在线时的调试。不在线调试功能内包括软元件的监视测试、外部机器的I/O的模拟操作等。对于个人学习来说，没有实验条件，仿真软件能够在个人计算机上进行顺控程序的开发和调试。使用者通过程序不断的仿真调试，慢慢领会程序设计心得，从而增加编程经验。 三、特殊功能模块 在学习过程中,大部分学生将学习的重心放在了软件编程上,而现代工业控制给PLC提出了许多新的课题,如果用通用I/O模块来解决，在硬件方面费用太高，在软件方面编程相当麻烦，某些控制任务甚至无法用通用I/O模块来完成。因此,学习PLC的特殊功能模块显得尤为重要。这些特殊功能模块有模拟量输入输出模块、高速计数模块和运动控制模块等。这些特殊功能模块PLC厂家都给出了详细的使用手册，用户可以通过仔细研读使用手册来完成特殊功能的实现，使得软件编程简化，降低了经济成本。 四、人机界面 连接可编程序控制器,利用显示屏显示，通过输入单元(如触摸屏、键盘、鼠标等)写入工作参数或输入操作命令,实现人与机器信息交互的数字设备称为人机界面,俗称触摸屏。触摸屏以其易于使用、坚固耐用、反应速度快、节省空间等优点，使得系统设计师们越来越多的感到使用触摸屏的确具有相当大的优越性。触摸屏由硬件和软件两部分组成。利用软件可以完成用户界面的设计，结合PLC的程序设计极大的简化了计算机的使用，即使是对计算机一无所知的人,对不懂PLC程序编程的操作人员，也能够按控制要求设置控制系统参数、生产配方存储、设备生产数据记录等操作。触摸屏的学习可以按如下的步骤进行。首先针对某一系列触摸屏仔细阅读其画面设计手册进行用户画面设计;接着设计触摸屏画面操作实现对应的PLC程序;最后打开触摸屏、PLC编程仿真软件进行仿真调试。 五、掌握三种流派主流产品 目前,世界上有200多个厂家生产PLC。大体可以按地域分成主要的三个流派：一个流派是日本产品,以三菱FX系列小型PLC为代表;一个流派是美国产品,以AB公司的PLC系列中型PLC为代表;还有一个流派是欧洲产品,德国西门子的S7系列大型PLC为代表。不同型号的PLC产品具有不同的特色,不仅表现在特殊复杂的功能等方面，就是在编程语言、程序的组织等方面也存在着较大的差异。掌握所有的PLC产品显然不现实，也没有必要。在熟练掌握一种PLC产品的基础上，有意识地在其他主要流派中选择最有代表性的产品，采用对比的学习方法进行相对深入的研究。这样在以后的工作、学习和开发研究中遇到其它的机型时，就能够做到触类旁通了。 六、充分利用网络资源，掌握PLC应用及发展的最新资讯 PLC产品更新换代的速度很快，若想及时掌握PLC应用及发展的最新资讯，就要充分利用互联网为我们提供的学习平台，方便地、快捷地、经济地掌握PLC的最新动态。尤其是一些网络上的专业论坛能够为我们提供了较高水平的交流平台，大量的学习资料、使用手册、软件功能的更新，使得不同阶段的学习者受益匪浅。总之,PLC入门容易,真正掌握可编程控制器的编程方法,能够顺利设计出满足生产任务的要求,同时程序做到简洁、易懂，设计者就必须深入学习PLC技术,学习者可以通过上述介绍的方法不断地充电,掌握PLC应用及发展的最新资讯，在不断的仿真调试过程中逐渐形成自己的编程习惯。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/476d6a4569582934c20b546aaed464e7/" rel="bookmark">
			MTKlog分析总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客：http://www.cnblogs.com/xiyuan2016/p/6740521.html ----------------------------------------------------------------------------------------------------------------- ZZ_INTERNAL 相关信息及解释 ANR,2173,-1361051648,99,/data/core/,1,system_app_anr,android.process.media,Tue Jul 4 18:51:03 HKT 2017,1 ZZ_INEERNAL包含10列，每列之间用,隔开 第一列：exception class，有KE/NE/JE/EE等 第二列：pid 第三列：tid 第四列：固定是99 第五列：固定是/data/core 第六列：exception level，0: fatal, 1: exception, 2: warning, 3: reminding 第七列：exception type info string； 如果是NE，则这个栏位是signal名称，比如：SIGSEGV， KE则为空， SWT则为：system_server_watchdog，等等。 第八列：module name or process name 第九列：UTC time 第十列：固定是1 ---------------------------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------------------------- trace部分信息解析 ----- pid 2173 at 2017-07-04 11:51:32 ----- Cmd line: android.process.media "main" prio=5 tid=1 Native "Binder:2173_1" prio=5 tid=9 Blocked | group="main" sCount=1 dsCount=0 obj=0x22c05430 self=0xa1fcab00 | sysTid=2186 nice=10 cgrp=bg_non_interactive sched=0/0 handle=0xa497a920 | state=S schedstat=( 26942858 122825452 281 ) utm=0 stm=2 core=0 HZ=100 | stack=0xa487e000-0xa4880000 stackSize=1014KB | held mutexes= at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/476d6a4569582934c20b546aaed464e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17d7faa4bdbfcb19c4c3c7e877e9b0cb/" rel="bookmark">
			（一）HBase学习之路  -  HBase  Shell 使用 与 HBase  WebUI理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HBase是什么 简介特性与HBase API HBase Shell HBase 组件下载配置 运行HBaseSingle ModeHBase Shell访问 HBase Web Admin Master StatusRegion Server Region Name的命名规则以及相关参数 参考 HBase是什么 简介 Apache HBase™ is the Hadoop database, a distributed, scalable, big data store.
应用场景(Use Case)： -存储大数据 billions of rows X millions of columns (TB/PB) -实时-随机读取以及写入 real-time random write/read to a big Data
* Hadoop 理论基础*　项目理论Apache HadoopGoogle Map-ReduceApache HBaseBigTableApache HDFSGoogle File System 特性与HBase API HBase 提供native访问方式： 方式一：HBase Shell 最简单 方式二：Native Java API 常用 方式三： Extensible jruby-based (JIRB) shell 方式四： Thrift gateway 通过其他编程语言访问 方式五： Rest-full Web Service 通过HTTP访问 HBase 提供non-native访问方式（依赖其他项目） Hive Phoenix Apache Impala SQL Spark SQL Pig HBase其他特性: : 本文主要记录：如何安装单节点Standalone HBase、如何利用HBase Shell管理以及访问HBase
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17d7faa4bdbfcb19c4c3c7e877e9b0cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dd8ab93435e386ebbe074c79138152f/" rel="bookmark">
			Vue不同编译输出文件的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue源码是选用了rollup作为bundler，看Vue的源码时发现：npm script对应了不同的构建选项。这也对应了最后打包构建后产出的不同的包。
不同于其他的library，Vue为什么要在最后的打包构建环节输出不同类型的包呢？接下来我们通过Vue的源码以及对应的构建配置中简单的去分析下。
由于Vue是基于rollup进行构建的，我们先来简单了解下rollup这个bundler：rollup是默认使用ES Module规范而非CommonJS，因此如果你在你的项目中使用rollup作为构建工具的话，那么可以放心的使用ES Module规范，但是如果要引入只遵循了CommonJs规范的第三包的话，还需要使用相关的插件，插件会帮你将CommonJs规范的代码转为ES Module。得益于ES Module，rollup在构建前进行静态分析，进行tree-shaking。关于tree-shaking的描述请戳我。在构建输出环节，rollup提供了多种文件输出类型：
iife: 立即执行函数
cjs: 遵循CommonJs Module规范的文件输出
amd: 遵循AMD Module规范的文件输出
umd: 支持外链/CommonJs Module/AMD Module规范的文件输出
es: 将多个遵循ES6 Module的文件编译成1个ES6 Module
接下来我们就看看Vue的使用rollup进行构建的几个不同的版本(使用于browser的版本)。
npm run dev 对应 rollup -w -c build/config.js --environment TARGET:web-full-dev rollup对应的配置信息为:
// Runtime+compiler development build (Browser) 'web-full-dev': { entry: resolve('web/runtime-with-compiler.js'), dest: resolve('dist/vue.js'), format: 'umd', env: 'development', alias: { he: './entity-decoder' }, banner }, 开发环境下输出的umd格式的代码，入口文件是runtime-with-compiler.js，这个入口文件中是将Vue的构建时和运行时的代码都统一进行打包了，通过查看这个入口文件，我们注意到
... import { compileToFunctions } from './compiler/index' ... const mount = Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dd8ab93435e386ebbe074c79138152f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69e71e7af1a1a4df9bf87f83e6959b8a/" rel="bookmark">
			解决Can’t locate ExtUtils/MakeMaker.pm in @INC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装mysqlsla-2.03，执行Perl脚本报错Can’t locate ExtUtils/MakeMaker.pm in @INC 解决如下
# wget http://files.directadmin.com/services/9.0/ExtUtils-MakeMaker-6.31.tar.gz # tar xvzf ExtUtils-MakeMaker-6.31.tar.gz -C /opt/ # cd /opt/ExtUtils-MakeMaker-6.31/ # perl Makefile.PL # make # make install 如果执行报如下错误
# perl Makefile.PL Checking if your kit is complete... Looks good Could not open '': No such file or directory at lib/ExtUtils/MM_Unix.pm line 2697. 则需安装依赖环境
# yum install perl-ExtUtils-MakeMaker 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54ce38e24ff36e024c3134596b4b8302/" rel="bookmark">
			druid数据库连接池问题：java.sql.SQLException: connection holder is null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 项目中使用了alibaba/druid数据库连接池，但是发现运行着一段时间后，总会报
java.sql.SQLException: connection holder is null 查阅很多解决办法都说设置。
&lt;property name="removeAbandoned" value="true" /&gt; &lt;property name="removeAbandonedTimeout" value="1800" /&gt; 这两个参数就可以了，但我的项目里，并不是这种超时间使用连接没有回收而导致的，所以这种解决方法并不能解决我的问题。
而且druid版本已经是1.1.2最新的版本，排除了druid非bug原因，那就是我本身项目代码问题了。
在druid官方github问题里也有很多同学的发现问题发析原因，顿时有了思路。
参考连接: 原因分析1、原因分析2。
两个问题都指出跨线程使用druid而引发的，温少也建议不要跨线程使用数据连接。
所以经过两天的查资料，和不断地尝试，终于找出问题所在。
首先我的项目里是用了spring-boot，连接池配置这些就不贴出来了，都大同小异。
而我的事务管理也是用的是spring的 @Transactional 注入管理。
问题在于，我的一个service方法里的一个方法里，该方法在事务提交之后，会再次触发另一个service执行代码。
@Service @Transactional(value = "transaction", rollbackFor = Exception.class) public class a_service { @Autowired private Dao dao; @Autowired private ApplicationEventPublisher publisher; /** *该方法执行所有代码之后，会触发publisher.publishEvent方法 */ public String test(){ .....省略执行代码..... publisher.publishEvent(params); } } @Service @Transactional(value = "transaction", rollbackFor = Exception.class) public class b_service { @Autowired private Dao dao; /** * 当事务提交后, 才会真正的执行@TransactionalEventListener配置的Listener, 如果Listener抛异常, 方法返回失 * 败, 但事务不会回滚.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54ce38e24ff36e024c3134596b4b8302/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d02c2433837741b167c90ed0856524/" rel="bookmark">
			Android Camera使用OpenGL ES 2.0和GLSurfaceView对预览进行实时二次处理（黑白滤镜）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列教程会有三篇文章讲解Android平台滤镜的实现方式，第三篇以后应该很多人会需要，这三篇写完，看情况是否升级到OpenGL ES 3.0来实现，毕竟OpenGL ES 2.0和3.0虽然有些差别，但差别不算太大。
第一篇 Android Camera使用OpenGL ES 2.0和GLSurfaceView对预览进行实时二次处理（黑白滤镜）第二篇 Android Camera使用OpenGL ES 2.0和TextureView对预览进行实时二次处理（黑白滤镜）第三篇 Android Camera2使用OpenGL ES 2.0和GLSurfaceView对预览进行实时二次处理（黑白滤镜） 下面进入正题：第一篇
首先讲一下，本文不使用Camera的PreviewCallback预览回调接口，因为onPreviewFrame()获取的数据格式只能是NV21或NV12，除非修改HAL层代码，一般情况下NV21或NV12需要转成RGB格式然后进行处理，这样太耗时了，所以本文使用SurfaceTexture来获取预览图像。
1. 添加GLSurfaceView作为布局界面 伪代码如下，这个不细讲了，可以参考我之前的博客 Android初始化OpenGL ES，并且分析Renderer子线程原理
//实例化一个GLSurfaceView mGLSurfaceView = new GLSurfaceView(this); //配置OpenGL ES，主要是版本设置和设置Renderer，Renderer用于执行OpenGL的绘制 mGLSurfaceView.setEGLContextClientVersion(2); mGLSurfaceView.setRenderer(new GLSurfaceView.Renderer()); //在屏幕上显示GLSurfaceView setContentView(mGLSurfaceView); 2. 在onCreate方法中开启相机并设置参数（本文只使用后置摄像头） mCameraId = Camera.CameraInfo.CAMERA_FACING_BACK; mCamera = Camera.open(mCameraId) Camera.Parameters parameters = mCamera.getParameters(); parameters.set("orientation", "portrait"); parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE); parameters.setPreviewSize(1280, 720); mCamera.setDisplayOrientation(90) setCameraDisplayOrientation(mActivity, mCameraId, mCamera); mCamera.setParameters(parameters); 3. GLSurfaceView创建好OpenGL ES的环境后，在Renderer的onSurfaceCreated()中，创建一个外部纹理用于接收预览数据 public static int createOESTextureObject() { int[] tex = new int[1]; //生成一个纹理 GLES20.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9d02c2433837741b167c90ed0856524/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/219b4f29c25dd893e6a53628b4506c6a/" rel="bookmark">
			weui的自定义Dialog,只能获取到第一次获取的dome元素的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天遇到的很奇怪的问题，纠结了好长时间，看下面实例代码来体会这个奇怪的问题
$.modal({ title: "测试", text: "文本框1&lt;input type='text' id='test01' value=''/&gt;&lt;br&gt; 文本框2&lt;input type='text' id='test02' value=''/&gt;", buttons: [ { text: "获取两个文本框的value值", onClick: function(){ alert($("#test01").val()); alert($("#test02").val()); } }, ] }); 问题：
点击按钮时，获取文本框1的值是正常的，文本框2是undefined。
将alert($("#test01").val());alert($("#test02").val());交换位置，先获取文本框2的值再获取文本框1的值，再来看看
发现只能获取文本框2的值，文本框1是undefined
原因（本人猜测，如果哪位大神知道原因还望告知）：
点击获取按钮时会触发关闭弹框，弹框关闭太快，获取到第一个文本框的值，再去获取第二个文本框的值得时候弹框已经关闭。
解决方案：将自动关闭弹窗设置为flase：autoClose : false,，在需要关闭弹窗的时候，加入手动关闭弹窗：$.closeModal();
代码如下：
$.modal({ autoClose : false, title: "测试", text: "文本框1&lt;input type='text' id='test01' value=''/&gt;&lt;br&gt; 文本框2&lt;input type='text' id='test02' value=''/&gt;", buttons: [ { text: "获取test01和test02的value值", onClick: function(){ //使用$.alert()会出现弹框还未弹出，窗口就关闭的情况，有知道的 //大神告知一下 alert($("#test01").val()); alert($("#test02").val()); $.closeModal(); } }, ] }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1e89efed07c2474b539373ec961c88/" rel="bookmark">
			我的秋招经历（已完结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*随着提前批又一次提前到来。。。秋招大幕徐徐拉开。。。本篇就来记录我的秋招经历吧。。。→_→*
秋招结束！终于可以歇一阵了~
CVTE 结果：收到书面offer
时间：2017.08.08 内容：CVTE提前批一面 结果：GG 面经：
介绍项目
（介绍项目的时候，面试管其实也在看简历。。。）项目中遇到的最大困难是什么？
虚函数表中有没有名字？
（我的回答是没有，然后用了非常长的时间去解释为什么没有，面试官表达了我说的不对的意思，然后我就问面试官“怎么会有名字？”，面试官说“我没有说有名字哦”此时心态已炸。。。）私有继承是is-a还是has-s？
进程中能开多少个线程？
如何避免死锁
线程间同步有哪些方法？
vector如何扩容？具体过程？
vector和list的区别？适用场景？
仿函数和函数指针的区别？
private和protect的区别
熟不熟悉智能指针？shared_ptr什么时候引用计数加1？
map中[]运算符和find运算符有什么区别？
new和malloc的区别？
平常遇到困难怎么解决？
怎样学习新知识？
总结：
秋招第一面可以说是GG的非常快。。预约的15：00-16：00时间段，18：00左右才叫去面试。。倒数第二个未面试的。。没去过面试地点，所以去的也比较早，以至于等了很久，面试的时候状态已经很差了。。又饿又累。。。面试官全程都是从他提前准备好的题目中进行提问的，回答中向面试官递了很多点，可是面试官并不接你的点。。所以全程的回答都是为了解决所提出的问题。。到后面我都觉得给他递点非常的尴尬。。还是继续继续努力吧。。 时间：2017.09.11 内容：CVTE校招一面 面经：
记不清了。。。 时间：2017.09.11 内容：CVTE校招二面 面经：
记不清了。。。 好未来 结果：收到书面offer
时间：2017.08.23 内容：好未来提前批一面（霸面） 结果：GG 面经：
问了问比赛的相关内容
导师是做什么的？有没有导师？
我们是本科啊。。。项目怎么写的？为什么写这个项目？
静态库和动态库？使用的优先级？
说成静态链接和动态链接了。。。虚拟地址空间的内存布局？
栈里面存什么？
堆里面存什么？
重载和重写？
Linux中线程相关的函数有哪些？
线程同步的方法？
如何避免线程死锁？
银行家算法？
要好好看看这个了。。。求数组中的最大子序列，元素有可能为负数、0、正数，要求时间复杂度小于O(n^2)
判断一个树是不是另一个树的子树，要求时间复杂度小于O(n^2)
判断两个单链表是否有交点，单链表可能有环，要求时间复杂度小于O(n+m)，空间复杂度为O(1)
总结：
霸面是和小伙伴一起去的，面试的时候就是我俩一起面（技术群面？）。。。面试官问有没有笔，然后就回去拿笔，再一次坐下时面试官说“你俩的简历有些相似啊”（PS：？？？）。手撕代码中的两道题之前都有刷过，但面试写时脑子就一片空白了。。。面试官还是很看重算法能力的。。。继续努力吧。。。 时间：2017.09.25 内容：好未来校招一面 面经：
自我介绍
一个程序的执行过程
手写单例模式
TCP滑动窗口如何理解的
进程有哪些状态，都来讲一讲
C++中的四种类型转换
进程间通信有哪些？
无名管道具体讲一讲？
手写归并排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b1e89efed07c2474b539373ec961c88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1803a0609d2eb4abe29fa5daa5e748c/" rel="bookmark">
			mysql跳过密码验证修改密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/churximi/article/details/50365712
1、修改mysql的配置文件
MySQL配置文件my.ini中，在[mysqld]下添加skip-grant-tables，关闭mysql服务并重新开启；
输入命令：mysql -u root -p
回车后，要求输入密码，直接回车跳过，则直接进入MySQL。
2、修改密码：
输入以下命令开始修改root用户的密码（注意：命令中mysql.user中间有个“点”） mysql&gt; update mysql.user set password=PASSWORD(‘新密码‘) where User=‘root‘; 刷新权限表 mysql&gt; flush privileges; 退出 mysql&gt; quit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2148d0376402397046bde0d5765fe6df/" rel="bookmark">
			纯css写下拉箭头，三角，半圆。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt;
&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;三角&lt;/title&gt; &lt;style type="text/css"&gt; /*空心下拉箭头*/ .triangle .content{ width: 10px; height: 10px; border:#666 solid; border-width: 1px 1px 0 0; transform: rotate(135deg); margin-bottom: 10px; } /*实心三角*/ .triangle2 .content{ width: 0px; height: 10px; border: 10px solid; border-color: #666 transparent transparent transparent; } /*空心圆*/ .circle .content{ width: 10px; height: 20px; border: 1px solid #666; border-radius: 100% 0 0 100%/50%; border-right: none; margin-bottom: 10px; } /*实心圆*/ .circle2 .content{ width: 10px; height: 20px; border: 1px solid #999; border-radius: 100% 0 0 100%/50%; border-right: none; background-color: #999; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2148d0376402397046bde0d5765fe6df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f1403d689642146fdfee02c4f764d6f/" rel="bookmark">
			关于JavaScript中的select()与focus()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建test.html页面代码如下：
&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript"&gt; function selText() { // document.getElementById('password1').select() document.getElementById('password1').focus() } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;input type="password" id="password1" value="thgrt456" /&gt; &lt;input type="button" onclick="selText()" value="请添加内容" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 运行结果如下图： 改为如下代码
&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript"&gt; function selText() { document.getElementById('password1').select() // document.getElementById('password1').focus() } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;input type="password" id="password1" value="thgrt456" /&gt; &lt;input type="button" onclick="selText()" value="请添加内容" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 运行结果为： 从以上的图片很容易看出两者的区别。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4957777b0e01cde91dc35a3549dfbe8/" rel="bookmark">
			logstash配置文件多输入和多输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		reset报文 2017-08-08T10:49:11+08:00 INFO Error publishing events (retrying): write tcp 192.168.5.201:51347-&gt;192.168.5.201:5043: write: connection reset by peer
1，客户端尝试与服务器未对外提供服务的端口建立TCP连接，服务器将会直接向客户端发送reset报文。 2，客户端和服务器的某一方在交互的过程中发生异常（如程序崩溃等），该方系统将向对端发送TCP reset报文，告之对方释放相关的TCP连接 3，接收端收到TCP报文，但是发现该TCP的报文，并不在其已建立的TCP连接列表内，则其直接向对端发送reset报文 4，在交互的双方中的某一方长期未收到来自对方的确认报文，则其在超出一定的重传次数或时间后，会主动向对端发送reset报文释放该TCP连接 5，有些应用开发者在设计应用系统时，会利用reset报文快速释放已经完成数据交互的TCP连接，以提高业务交互的效率
2017-08-08T10:49:12+08:00 ERR Connecting error publishing events (retrying): dial tcp 192.168.5.201:5043: getsockopt: connection refused logstash服务down掉
logstash针对多个beat的输入和不同形式输出的设置 网上说可以用设置type来标识，结果没有输出，原因： Beat已经设置了type字段，所以自行设置的type将会被忽略
The Beats shipper automatically sets the type field on the event. You cannot override this setting in the Logstash config. If you specify a setting for the type config option in Logstash, it is ignored.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4957777b0e01cde91dc35a3549dfbe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a5cc63688343b16e226d684b7f7831a/" rel="bookmark">
			能上QQ但网页打不开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天上网发现网页突然打不开了，但是笔记本网络连接正常，最后发现是依赖的TCP/IP协议有问题，解决办法如下：
1、开始——运行——regedit.exe，打开注册表编辑器，删除以下两个文件： HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Winsock 和HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Winsock2 2、找到 C:\Windows\inf\nettcpip.inf文件 该文件为 tcp/ip协议文件 3、控制面板-&gt;网络和Internet-&gt;网络和共享中心-&gt;更改适配器设置-&gt;右键连接-&gt;属性 先选择TCP/IPv6-&gt;安装-&gt;协议-&gt;添加-&gt;从磁盘安装-&gt;然后在路径里浏览找到第2步中的文件路径找到nettcpip.inf，确定然后选择“TCP/IPv6”。 对于ipv4协议重复同样的操作，最后选择TCP/IPv4，即： TCP/IPv4-&gt;安装-&gt;协议-&gt;添加-&gt;从磁盘安装-&gt;然后在路径里浏览找到第2步中的文件路径，nettcpip.inf 然后选择“TCP/IPv4”。
大功告成 ，浏览器终于能用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeba42413cdeef4481a59bfe0b12751a/" rel="bookmark">
			【C&#43;&#43;】返回值是类名和返回值是引用的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		返回非引用类型： 函数的返回值用于初始化在调用函数时创建的临时对象(temporary object)，如果返回类型不是引用，在调用函数的地方会将函数返回值复制给临时对象。 在求解表达式的时候，如果需要一个地方存储其运算结果，编译器会创建一个没命名的对象，这就是临时对象。C++程序员通常用temporary这个术语来代替temporary object。 用函数返回值初始化临时对象与用实参初始化形参的方法是一样的。 当函数返回非引用类型时，其返回值既可以是局部对象，也可以是求解表达式的结果。
返回引用类型： 当函数返回引用类型时，没有复制返回值，相反，返回的是对象本身。 千万不要返回局部对象的引用！千万不要返回指向局部对象的指针！ 当函数执行完毕时，将释放分配给局部对象的存储空间。此时对局部对象的引用就会指向不确定的内存！返回指向局部对象的指针也是一样的，当函数结束时，局部对象被释放，返回的指针就变成了不再存在的对象的悬垂指针。
返回引用时，要求在函数的参数中，包含有以引用方式或指针方式存在的，需要被返回的参数。
如果返回对象，最后多执行一次拷贝构造函数，如果返回引用，直接返回现存对象
#include &lt;iostream&gt; using namespace std; class Timer { public: Timer(); Timer(int, int, int); friend Timer &amp;operator+(Timer&amp;, Timer&amp;); friend Timer operator-(Timer&amp;, Timer&amp;); friend ostream&amp; operator&lt;&lt;(ostream &amp;out, Timer &amp;t); friend istream&amp; operator&gt;&gt;(istream &amp;in, Timer &amp;t); private: int hour, minute, second; }; Timer::Timer() { hour = 0; minute = 0; second = 0; } Timer::Timer(int hour, int minute, int second) { this-&gt;hour = hour; this-&gt;minute = minute; this-&gt;second = second; } Timer &amp; operator+(Timer&amp; a, Timer &amp;b) { a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeba42413cdeef4481a59bfe0b12751a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95995235fe586c2928fe4b89dad436e2/" rel="bookmark">
			iOS-77-解决iOS9闪退，在iOS10上正常的问题；以及解决百度导航sdk导致审核不通过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近比较恼火，苹果审核从7月14号提交～8月6号审核通过，中间经历了3次被拒，申诉、加急都不好使。
最终解决办法：xcode7.3.1--&gt;xcode8.3.3 移除百度导航2.0.9版，添加百度导航v3.2.0+百度地图v3.3.2 特别注意：添加百度导航v3.2.0sdk时，需要导入xcode8才有的框架：UserNotifications.framework，其状态应该是Optional！否则在iOS9上会闪退！ 还有：接手外包人员的代码、以及整合多个第三方sdk，在后期维护中是很痛苦的！很痛苦的！很痛苦的！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b9f4b2956787c32a34126c7b52356bd/" rel="bookmark">
			分享一个基于vue的环形菜单组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue-quick-menu是一个应用于移动端的快速导航组件。它拥有炫酷的展开和收起时的动画效果。它支持自定义菜单的显示位置，菜单的数量，颜色等属性。
demo
安装 通过NPM安装
npm install vue-quick-menu --save 插件应用 这是一个使用的例子
&lt;quick-menu :menu-count=count :icon-class=icons :menu-url-list=list&gt;&lt;/quick-menu&gt; import Vue from 'vue' import quickMenu from 'vue-quick-menu' export default { ... components: { quickMenu }, ... } 插件参数 PropertyTypeDefaultDescriptionmenuCountNumber4导航菜单的数量 可选2，3，4menuUrlListArray-菜单的url的数组iconClassArray-菜单项的图标positiontop-left,top-right,bottom-left or bottom-righttop-left菜单的位置backgroundColorString#009dc7菜单的背景色colorString#ffffff菜单图标的颜色isOpenNewTabBooleanfalse是否在原窗口打开菜单指向的url 最后推荐一下轮子工厂--一个分享vue,angular优秀组件的网站
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/681747d06eeaea3bb3bf2fe2a6ddda42/" rel="bookmark">
			时间数据统计~获取当年的每个月份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function yearGetEveryMonth(){ //获取格式化 年份日期 $time = time(); $dTime = date('Y',$time); //获取开始时间 $yearstart = mktime(0,0,0,1,1,$dTime); //获取结束时间 $yearEnd = strtotime('+ 1 year',$yearstart); $yearEnd = strtotime('- 1 day',$yearEnd); //一年12个月，不BB for($i=0;$i&lt;12;$i++){ //第一次循环 if($i == 0){ //开始时间 = $yearstart $yearstart_01 = $yearstart; //结束时间 = 开始时间 + 一个月 - 1天 $yearstart_02 = strtotime('+ 1 month',$yearstart_01); $yearstart_02 = strtotime(' - 1 day',$yearstart_02); }else if($i == 11){ //开始时间 = 上次结束时间 $yearstart_01 = $yearstart_02; $yearstart_01 = mktime(0,0,0,date('m',$yearstart_01),date('d',$yearstart_01),date('Y',$yearstart_01)); $yearstart_01 = strtotime(' + 1 day',$yearstart_01); $yearstart_02 = strtotime('+ 1 month',$yearstart_01); $yearstart_02 = strtotime(' - 1 day',$yearstart_02); }else{ //开始时间 = 上次结束时间 $yearstart_01 = $yearstart_02; $yearstart_01 = mktime(0,0,0,date('m',$yearstart_01),date('d',$yearstart_01),date('Y',$yearstart_01)); $yearstart_01 = strtotime(' + 1 day',$yearstart_01); $yearstart_02 = strtotime('+ 1 month',$yearstart_01); $yearstart_02 = strtotime(' - 1 day',$yearstart_02); } //这里是创建一个结束时间 $yearstart_02 = mktime(23,59,59,date('m',$yearstart_02),date('d',$yearstart_02),date('Y',$yearstart_02)); //格式化输出时间 echo '今年开始 '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/681747d06eeaea3bb3bf2fe2a6ddda42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f5fd3fe3e489f2e704d69617b7be6a/" rel="bookmark">
			时间数据统计~获得当前24小时时间段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//获得当前24小时时间段 function getNowDayTime(){ //获取当前时间戳 $time = time(); //创建当天0时0分0秒时间戳 $start = mktime(0,0,0,date('m',$time),date('d',$time),date('Y',$time)); //已知一天有24小时，所以循环24次 for($i=0;$i&lt;24;$i++){ if($i !== 0){//以后的循环 //开始时间是第一次循环 $add_01 时间戳加上一个小时 $add_01 = strtotime('+ 1 hour',$add_01); //结束时间是已经加上一小时的 $add_01 再加上一个小时 $add_02 = strtotime('+ 1 hour',$add_01); }else{//循环第一次 //开始的时间是刚创建的 $start 时间戳 $add_01 = $start; //结束的时间是开始时间加上一个小时 $add_02 = strtotime('+ 1 hour',$add_01); } //展示格式化的开始时间 与 结束时间 echo '开始时间 = '.date('Y-m-d H:i:s',$add_01).' 结束时间 = '.date('Y-m-d H:i:s',$add_02).'&lt;br&gt;'; } } getNowDayTime(); // strtotime() : 将格式化时间转化为时间戳 或者 在时间戳上添加几天/小时/秒 等等的操作 // mktime() : 创建一个时间戳 // date() : 格式化时间戳 转载于:https://my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9f5fd3fe3e489f2e704d69617b7be6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de47f82e9816b6bedfda244937f6abea/" rel="bookmark">
			httpUtil封装工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import org.apache.commons.io.IOUtils;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.NameValuePair;
import org.apache.http.client.HttpClient;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLContextBuilder;
import org.apache.http.conn.ssl.TrustStrategy;
import org.apache.http.conn.ssl.X509HostnameVerifier;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.security.GeneralSecurityException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.HashMap;
import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de47f82e9816b6bedfda244937f6abea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83c60a48159b9e968aa5a787dc980869/" rel="bookmark">
			一个移植十分方便的malloc函数族的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信学习过c语言的人都知道malloc、free函数，这里就不多说怎么用了。这里要说的是：提供它们的实现。
该实现方法由uboot中malloc等函数的实现改编而来。已经过验证，没有问题。 ------多说一句，该实现支持物理地址malloc、free。。。，不支持虚拟地址的映射
该malloc的源码实现，很方便移植。特别是在BootLoader或者单片机开发过程中，想要实现malloc、free、realloc等函数时，只需要将下面提供的dlmalloc.c和malloc.h拷贝到你的工程的同一个目录下，编译链接进去即可。
编译出错处理：
该实现分2个文件：dlmalloc.c、malloc.h。由于dlmalloc.c中含有除法运算，在添加入你的工程中，当使用makefile去做gcc编译时，倘若编译出错。请尝试连接gcc库：libgcc.a,libm.a,libc.a三个库，在连接时按顺序加入。倘若不知道它们存在哪？那运行下：
arm-none-linux-gnueabi-gcc -print-libgcc-file-name【举例】看下路径
arm-linux-gcc -print-search-dirs【举例】看下gcc的搜索范围
另外，通过执行 arm-linux-gcc –dumpspecs【举例】 命令可以看到很多有用的信息，如指定软硬浮点，指定处理器。
下面贴代码（dlmalloc.c和malloc.h），malloc函数族的实现： //dlmalloc.c：
#if 0	/* Moved to malloc.h */ /* ---------- To make a malloc.h, start cutting here ------------ */ /* A version of malloc/free/realloc written by Doug Lea and released to the public domain. Send questions/comments/complaints/performance data to dl@cs.oswego.edu * VERSION 2.6.6 Sun Mar 5 19:10:03 2000 Doug Lea (dl at gee) Note: There may be an updated version of this malloc obtainable at ftp://g.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83c60a48159b9e968aa5a787dc980869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09f7439ed8e5640acf2108176999f0b1/" rel="bookmark">
			Java   checked 异常 和 RuntimeException(运行时异常)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、运行时异常 1、什么是RuntimeExceptioin 2、运行时异常的特点 3、如何运用运行时异常 二、运行时异常和ckecked异常的区别 1、机制上 2、逻辑上 一、运行时异常
1、什么是运行时异常
程序在运行过程中出现的异常，RumtimeException 是 Exception 的一个子类
我们可以查看Java API 文档
贴张示意图
2、运行异常的特点
一般来说，我们在方法体内出现异常，我们用throw 关键字 将 异常对象或 异常对象的引用抛出，如果当前方法无法处理异常，那么必须在方法的参数列表后方法体前 必须 用 throws 声明异常所属类，交给调用者去处理。但是RuntimeException是非常特殊的子类，你可以不用throw和throws，哪怕你throw了，也没必要thtows，即使你throws了，调用者也没必要try-catch
1&gt; 如果在函数内容中抛出该类异常或其子类异常，函数上可以不用声明，编译一样通过
2&gt; 如果在函数上声明该异常，调用者可以不同处理(try-catch)，编译一样通过
为什么不用声明 ？
之所以不用在函数上声明，是因为不需要让调用者处理，当该异常发生，希望程序停止，因为在运行时，出现了无法继续运算的情况，希望程序停止后由程序员对代码进行修正。
3、如何运用运行时异常
自定义异常时，如果该异常的发生，无法继续进行运行，就让自定义异常类继承RuntimeException
再贴一张简单示意图 Object 中的 wait（long timeout）方法，继续查看Java API 文档 对该方法的描述
二、运行时异常和ckecked异常的区别
对于异常分两种：检查异常和非检查异常(运行时异常)
检查异常 : 编译时被检测的异常 （throw后，方法有能力处理就try-catch处理，没能力处理就必须throws）。编译不通过，检查语法(其实就是throw和throws的配套使用)。
运行时异常 : 编译时不被检查的异常(运行时异常。RuntimeException及其子类)。编译通过。
1、机制上
主要表现在以下两个方面 :
（1）如何定义方法
（2）如何处理抛出的异常
运行时异常，不需要用throws 声明抛出 异常对象所属类，也可以不用throw 抛出异常对象或异常引用。对于调用该方法，也不需要放于 try-catch 代码块中。（为什么 ？ 如果你捕获它，就会冒这么一个风险：程序代码错误被掩盖在运行中无法察觉)
而检查异常 : 一旦 用throw 抛出异常，如果当前方法 可处理异常，那么直接在该方法内用try-catch 去处理。如果当前方法不具备处理该异常的能力，那么就必须在 参数列表后方法体前用 throws 声明 异常 所属类，交给调用该方法的 调用者(方法) 去处理 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09f7439ed8e5640acf2108176999f0b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca9b4047e0fb4b53eb57297329428a24/" rel="bookmark">
			在linux设置回收站 - 防止失误操作造成数据清空,并定期清理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装trash
sudo apt-get install trash-chi 原理 执行trash命令后，是将文件移动了用户的回收站，每个用户的回收站路径为$HOME/.local/share/Trash，比如用户asin的回收站位于/home/asin/.local/share/Trash，用户root的回收站位于/root/.local/share/Trash。
每个用户删除自己的文件后，都会将该文件移动到自己的回收站中。
rm命令，运行该命令后，文件基本就无法恢复 查看已经删除的文件 lstrash 恢复已经删除的文件 restore-trash 设置别名
1.若要每次登入就自动生效别名，则把别名加在/etc/profile或~/.bashrc中。然后# source ~/.bashrc 2. 若要让每一位用户都生效别名，则把别名加在/etc/bash.bashrc最后面，然后# source /etc/bash.bashrc
alias rm=trash alias lstrash=trash-list alias rm!="/bin/rm-vi" source /etc/bash.bashrc bash 删除别名 格式：unalias name # unalias cp 查看别名　alias 强制清空回收站
rm -fr $HOME/.local/share/Trash/files/* rm -fr $HOME/.local/share/Trash/info/* 自动定期清理 trash 目录
删除存在回收站超过 7 天的文件并删除.log 中相应记录
arrayA=($(find ~/trash/* -mtime +7 | awk '{print $1}')) for file in ${arrayA[@]} do $(rm -rf "${file}") filename="${file##*/}" echo $filename $(sed -i /$filename/'d' "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca9b4047e0fb4b53eb57297329428a24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d407a3400701c24b90a895741f267e98/" rel="bookmark">
			1分钟搭建完整laravel后台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：https://github.com/z-song/laravel-admin
1，composer安装laravel admin
Laravel 5.1, not maintained composer require encore/laravel-admin "1.1.*" Laravel 5.2 composer require encore/laravel-admin "1.2.*" Laravel 5.3 composer require encore/laravel-admin "1.3.*" Laravel 5.4 composer require encore/laravel-admin "1.4.*" 2， 在config/app.php ServiceProvider中添加一下:
Encore\Admin\Providers\AdminServiceProvider::class Then run these commands to publish assets and config：
php artisan vendor:publish --tag=laravel-admin 3，安装admin后台命令 注意：安装前必须保证数据库信息连接正确！！！ php artisan admin:install 4，然后就可以访问测试后台了 打开 http://你的虚拟域名xxxx/admin/在浏览器,使用后台用户名 admin 和默认密码 admin 去登陆。
ok laravel 就可以飞起啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08ec5cc0be6b1eac51cdb3760c5c4aa1/" rel="bookmark">
			WebSocket 是什么原理？为什么可以实现持久连接？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：腾讯云技术社区
众所周知，Web应用的通信过程通常是客户端通过浏览器发出一个请求，服务器端接收请求后进行处理并返回结果给客户端，客户端浏览器将信息呈现。这种机制对于信息变化不是特别频繁的应用可以良好支撑，但对于实时要求高、海量并发的应用来说显得捉襟见肘，尤其在当前业界移动互联网蓬勃发展的趋势下，高并发与用户实时响应是Web应用经常面临的问题，比如金融证券的实时信息、Web导航应用中的地理位置获取、社交网络的实时消息推送等。
传统的请求-响应模式的Web开发在处理此类业务场景时，通常采用实时通讯方案。比如常见的轮询方案，其原理简单易懂，就是客户端以一定的时间间隔频繁请求的方式向服务器发送请求，来保持客户端和服务器端的数据同步。其问题也很明显：当客户端以固定频率向服务器端发送请求时，服务器端的数据可能并没有更新，带来很多无谓请求，浪费带宽，效率低下。
基于Flash，AdobeFlash通过自己的Socket实现完成数据交换，再利用Flash暴露出相应的接口给JavaScript调用，从而达到实时传输目的。此方式比轮询要高效，且因为Flash安装率高，应用场景广泛。然而，移动互联网终端上Flash的支持并不好：IOS系统中无法支持Flash，Android虽然支持Flash但实际的使用效果差强人意，且对移动设备的硬件配置要求较高。2012年Adobe官方宣布不再支持Android4.1+系统，宣告了Flash在移动终端上的死亡。
传统的Web模式在处理高并发及实时性需求的时候，会遇到难以逾越的瓶颈，需要一种高效节能的双向通信机制来保证数据的实时传输。在此背景下，基于HTML5规范的、有Web TCP之称的 WebSocket应运而生。早期HTML5并没有形成业界统一的规范，各个浏览器和应用服务器厂商有着各异的类似实现，如IBM的MQTT、Comet开源框架等。直到2014年，HTML5终于尘埃落地，正式落实为实际标准规范，各个应用服务器及浏览器厂商逐步开始统一，在 JavaEE7中也实现了WebSocket协议。至此无论是客户端还是服务端的WebSocket都已完备。用户可以查阅HTML5规范，熟悉新的HTML协议规范及WebSocket支持。
WebSocket 机制 以下简要介绍一下WebSocket的原理及运行机制。
WebSocket是HTML5下一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。它与HTTP一样通过已建立的TCP连接来传输数据，但是它和HTTP最大不同是：
WebSocket是一种双向通信协议。在建立连接后，WebSocket服务器端和客户端都能主动向对方发送或接收数据，就像Socket一样；
WebSocket需要像TCP一样，先建立连接，连接成功后才能相互通信。
传统HTTP客户端与服务器请求响应模式如下图所示：
WebSocket模式客户端与服务器请求响应模式如下图：
上图对比可以看出，相对于传统HTTP每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket是类似Socket的TCP长连接通讯模式。一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。
相比HTTP长连接，WebSocket有以下特点：
是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。
HTTP长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换HTTP header，信息交换效率很低。Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据，这显然和原有的HTTP协议有区别所以它需要对服务器和客户端都进行升级才能实现（主流浏览器都已支持HTML5）。此外还有 multiplexing、不同的URL可以复用同一个WebSocket连接等功能。这些都是HTTP长连接不能做到的。
下面再通过客户端和服务端交互的报文对比WebSocket通讯与传统HTTP的不同点：
在客户端，new WebSocket实例化一个新的WebSocket客户端对象，请求类似 ws://yourdomain:port/path 的服务端WebSocket URL，客户端WebSocket对象会自动解析并识别为WebSocket请求，并连接服务端端口，执行双方握手过程，客户端发送数据格式类似：
GET /webfin/websocket/ HTTP/1.1 Host: localhost Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg== Origin: http://localhost:8080 Sec-WebSocket-Version: 13 可以看到，客户端发起的WebSocket连接报文类似传统HTTP报文，Upgrade：websocket参数值表明这是WebSocket类型请求，Sec-WebSocket-Key是WebSocket客户端发送的一个 base64编码的密文，要求服务端必须返回一个对应加密的Sec-WebSocket-Accept应答，否则客户端会抛出Error during WebSocket handshake错误，并关闭连接。
服务端收到报文后返回的数据格式类似：
HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8= Sec-WebSocket-Accept的值是服务端采用与客户端一致的密钥计算出来后返回客户端的，HTTP/1.1 101 Switching Protocols表示服务端接受WebSocket协议的客户端连接，经过这样的请求-响应处理后，两端的WebSocket连接握手成功, 后续就可以进行TCP通讯了。用户可以查阅WebSocket协议栈了解WebSocket客户端和服务端更详细的交互数据格式。
在开发方面，WebSocket API 也十分简单：只需要实例化 WebSocket，创建连接，然后服务端和客户端就可以相互发送和响应消息。在WebSocket 实现及案例分析部分可以看到详细的 WebSocket API 及代码实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08ec5cc0be6b1eac51cdb3760c5c4aa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97628647db79a0a615467a17c81c555c/" rel="bookmark">
			人体姿态识别之RMPE（AlphaPose）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文：
https://arxiv.org/abs/1612.00137
github:
https://github.com/MVIG-SJTU/RMPE
https://github.com/MVIG-SJTU/AlphaPose
RMPE出自2017ICCV，RMPE: Regional Multi-Person Pose Estimation，是上海交大，卢策吾老师组的作品。
主流的姿态识别通常2个思路，
（1）two-step framework，就是先进行行人检测，得到边界框，然后在每一个边界框中检测人体关键点，连接成一个人形，缺点就是受检测框的影响太大，漏检，误检，IOU大小等都会对结果有影响，代表方法就是RMPE。
（2）part-based framework，就是先对整个图片进行每个人体关键点部件的检测，再将检测到的部件拼接成一个人形，缺点就是会将不同人的不同部位按一个人进行拼接，代表方法就是openpose。
整个框架包括3个部分，
SSTN(Symmetric Spatial Transformer Network)，对称空间变换网络，由STN，SDTN两部分组成，STN负责接收人体候选框，SDTN产生候选姿态，
PNMS (Parametric PoseNonMaximum-Suppression)，负责过滤掉多余的姿态估计
PGPG(Pose-Guided Proposals Generator)，就是SPPE这一部分，可以产生各种姿态图片，供训练过程使用。
安装步骤：
git clone https://github.com/MVIG-SJTU/RMPE.git cd RMPE cp Makefile.config.example Makefile.config make all -j8 make pycaffe -j8 测试：
python examples/rmpe/demo.py 这里使用COCO数据集中的图片进行测试，从测试效果来看，没有openpose效果好，原因可能是这里的model并不是最新的Torch训练的模型吧。测试显卡1050TI。
reference:
https://github.com/MVIG-SJTU/RMPE
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40df49f367c051cf1f41a2bcb8ee84c2/" rel="bookmark">
			python opencv入门 轮廓特征（18）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容来自OpenCV-Python Tutorials 自己翻译整理
目标 轮廓的面积、周长、重心、边界 相关函数
矩 图像矩可以计算图像的质心，面积等等。 图像的矩
函数 cv2.moments()会计算图像的矩，并返回一个字典 （findContours应该返回三个参数，样例里的代码只返回两个，报错了）
import cv2 import numpy as np img = cv2.imread('3.jpg',0) ret,thresh = cv2.threshold(img,127,255,0) img,contours,hierarchy = cv2.findContours(thresh, 1, 2) cnt = contours[0] M = cv2.moments(cnt) print(M) 结果
{'m00': 0.0, 'm10': 0.0, 'm01': 0.0, 'm20': 0.0, 'm11': 0.0, 'm02': 0.0, 'm30': 0.0, 'm21': 0.0, 'm12': 0.0, 'm03': 0.0, 'mu20': 0.0, 'mu11': 0.0, 'mu02': 0.0, 'mu30': 0.0, 'mu21': 0.0, 'mu12': 0.0, 'mu03': 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40df49f367c051cf1f41a2bcb8ee84c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e9db3329d61fb7743ed0c0bef6cf81c/" rel="bookmark">
			bugfree安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天突然间发现bug越来越多很不好管理和把控，所以就想借用一下bugfree这个工具来进行管理，因为之前有用过，所以安装起还是挺快的。具体步骤如下：
1.首先从网上下载xampp这个工具，这个xampp到底是一个什么工具？去百度；
2.下载这个工具后，就可以傻瓜式安装了；
3.接着在去下载bugfree安装包，解压丢到xammp安装目录下的htdocs文件下，因为我的是默认安装所以，我的路径是：C:\xampp\htdocs.
4.然后启动xammp里的Apache服务器。
5.打开浏览器输入：http://localhost/bugfree，环境配置全部通过后，点击继续按钮，进入到数据库配置，配置完后就会自动跳转到一下界面
6.默认用户名：admin，默认密码：123456.登录即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/579e1c2b8254a64b2e5c035c9c2f5f30/" rel="bookmark">
			numpy的文件存储与处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import numpy as np from io import StringIO
第二部分 ndarray 文件存储与读取 一维二维数组 可以采用csv（Comma Separated Value 逗号分割值） ”’ 1)np.savetxt np.loadtxt
numpy.savetxt(fname, X, fmt=’%.18e’, delimiter=’ ‘, newline=’\n’, header=”, footer=”, comments=’# ‘) fname : filename or file handle 指定要存入的文件名,支持gzip （.gz .bz2）格式 If the filename ends in .gz, the file is automatically saved in compressed gzip format. loadtxt understands gzipped files transparently(易察觉的).
X : array_like 一个ndarray对象 Data to be saved to a text file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/579e1c2b8254a64b2e5c035c9c2f5f30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d9f38108d188932abc8df59f0b29917/" rel="bookmark">
			springMVC jsp传送两个不同对象给Controller
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近学习springmvc，想从jsp传送两个java对象的数据给Controller自动装配，在网上查了好久都是List对象的传送，最后终于查到了多个java对象的传送。 这里以用户(User)与用户详细信息(UserDetail)的更新为例，更新用户信息时，同时传送User以及UserDetail。 UserDetail以User的id为主键以及外键： User.java
@Component public class User { private int id; private String name; private int age=0; //getter and setter } UserDetail.java
@Component public class UserDetail { private int id; private String sex; private String phone; private String address; //getter and setter } 关键方法： UserController
@RequestMapping(value="/updateuser.action",method=RequestMethod.POST) public ModelAndView updateUser(User user,UserDetail userDetail){ System.out.println("================="+user.getId()+"================"); System.out.println("================="+user.getName()+"================"); System.out.println("================="+userDetail.getSex()+"================"); System.out.println("================="+userDetail.getPhone()+"================"); System.out.println("================="+userDetail.getAddress()+"================"); userService.updateUser(user,userDetail); } @InitBinder("user") public void userBinder(WebDataBinder webDataBinder){ webDataBinder.setFieldDefaultPrefix("user."); } @InitBinder("userDetail") public void userDetailBinder(WebDataBinder webDataBinder){ webDataBinder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d9f38108d188932abc8df59f0b29917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a488e0f550383532d9a8e46b3143654d/" rel="bookmark">
			webpack打包报javaScript heap out of memory的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 最近做的一个项目，由于项目文件越来越多，最终导致在打包时报javaScript heap out of memory错误，网上的方法试了很多都无法解决问题。最后同事在GitHub上找到了解决方法，下面和大家分享一下：
问题： 详细报错内容：CALL_AND_RETYR_LAST Allocation failed -javascript heap out of memoty
解决方法： 安装：
npm install -g increase-memory-limit
执行：
increase-memory-limit
希望对大家有帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99aca0ea73a3c532bfbbb06987c6d1ce/" rel="bookmark">
			RAID磁盘阵列 及RAID0 1 3 5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		磁盘阵列（Redundant Arrays of Independent Disks，RAID），磁盘阵列是由很多便宜、容量较小、稳定性较高、速度较慢磁盘，组合成一个大型的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。同时利用这项技术，将数据切割成许多区段，分别存放在各个硬盘上。磁盘阵列还能利用同位检查（Parity Check）的观念，在数组中任一颗硬盘故障时，仍可读出数据，在数据重构时，将数据经计算后重新置入新硬盘中。
RAID0：RAID 0 -Disk Stripping without parity （常用）
又称数据分块，即把数据分成若干相等大小的小块，并把它们写到阵列上不同的硬盘上，这种技术又称“Stripping”（即将数据条带化），这种把数据分布在多个盘上，在读写时是以并行的方式对各硬盘同时进行操作。从理论上讲，其容量和数据传输率是单个硬盘的N倍。N为构成RAID0的硬盘总数。当然，若阵列控制器有多个硬盘通道时，对多个通道上的硬盘进行RAID0操作，I/O性能会更高。因此常用于图象，视频等领域，RAID0 I/O传输率较高，但平均故障时间MTTF只有单盘的N分之一，因此RAID0可靠性最差。
RAID1：RAID 1 -Disk Mirroring（较常用）
又称镜像。即每个工作盘都有一个镜像盘，每次写数据时必须同时写入镜像盘，读数据时只从工作盘读出，一旦工作盘发生故障立即转像盘中读出数据。当更换故障盘后，数据可以重构，恢复工作盘正确数据，这种阵列可靠性很高，但其有效容量减小到总容量一半以下，因此RAID1常用于对容错要求极严的应用场合，如财政、金融等领域。
RAID3：RAID 3 -Parallel Disk Array 为单盘容错并行传输。即采用Stripping技术将数据分块，对这些块进行异或校验，校验数据写到最后一个硬盘上。它的特点是有一个盘为校验盘，数据以位或字节的方式存于各盘（分散记录在组内相同扇区的各个硬盘上）。
当一个硬盘发生故障，除故障盘外，写操作将继续对数据盘和校验盘进行操作。而读操作是通过对剩余数据盘和校验盘的异或计算重构故障盘上应有的数据来进行的。RAID3的优点是并行I/O传输和单盘容错，具有很高可靠性。缺点：每次读写要牵动整个组，每次只能完成一次I/O。
RAID5：RAID 5 -Striping with floating parity drive（最常用） 是一种旋转奇偶校验独立存取的阵列方式，它与RAID3，RAID4不同的是没有固定的校验盘，而是按某种规则把奇偶校验信息均匀地分布在阵列所属的硬盘上，所以在每块硬盘上，既有数据信息也有校验信息。这一改变解决了争用校验盘的问题，使得在同一组内并发进行多个写操作。所以RAID5即适用于大数据量的操作，也适用于各种事务处理，它是一种快速、大容量和容错分布合理的磁盘阵列。当有N块阵列盘时，用户空间为N-1块盘容量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9a83d0d429c9cfd5cf235d9919eea42/" rel="bookmark">
			自定义IEqualityComparer比较类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 internal class CustomerEqualityComparer&lt;T&gt; : IEqualityComparer&lt;T&gt; { public CustomerEqualityComparer(params Func&lt;T, object&gt;[] selectors) { Selectors = selectors; } private IEnumerable&lt;Func&lt;T, object&gt;&gt; Selectors { get; } public bool Equals(T left, T right) { return !ReferenceEquals(left, null) &amp;&amp; !ReferenceEquals(right, null) &amp;&amp; Selectors.All(selector =&gt; selector(left).Equals(selector(right))); } public int GetHashCode(T obj) { unchecked { return Selectors.Select(selector =&gt; selector(obj).GetHashCode()) .Aggregate(17, (hashCode, subHashCode) =&gt; hashCode * 31 + subHashCode); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dbf1c1e0f86d4169a7939f82f745cc5/" rel="bookmark">
			import org.apache.ibatis.io.Resources   找不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maven 下载的包有问题， 从mybatis 下载后 覆盖maven仓库中的包后回复正常
转载于:https://www.cnblogs.com/orziii/p/7263367.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbf45ac17b8de1d327c183a40949a140/" rel="bookmark">
			企业微信自动打卡插件开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日科技快讯 近日中国多家VPN供应商已收到了来自苹果公司的通知，通知主要告知这些供应商和开发者，他们的软件将从中国区App Store下架。对此苹果方面表示，工信部今年早些时候宣布，所有提供VPN服务的开发者必须获得政府的许可，我们被要求移除一些不符合新规定的VPN应用。苹果同时补充道：其它国家/地区的帐单地址的用户将能够继续从App Store中访问这些软件。
作者简介 新的一周开始了，很高兴又跟大家见面了！
本篇来自 splm 的投稿，分享了如何实现公司微信自动化打卡，本文只是分析了技术，并不赞同实际使用！ 思考 需求不容赘述，能找到这个文章的人，估计都心怀鬼胎，哈哈，只希望大家能够从技术的角度看待这个插件，切忌不要做“不好”的事情，年纪都不小了，应该做到是非分明。最后再警告大家，严格律己，遵守公司规章制度。
自动打卡，究竟如何自动化？
实现自动化，定要模拟用户操作，单击，长按，触摸等事件，那么....没错，就需要臭名昭著的 AccessibilityService。
打卡地点，究竟如何模拟？
1. Xposed框架，定位有三种方式，网络，基站和GPS，三者也有优先级，但也可简单粗暴直接拦截系统GPS定位，至于网络，基站定位都给 null。
2. 模拟器，主流的模拟器可以模拟地理位置，开发期间推荐使用模拟器进行调试；
多说一句使用 Xposed 框架，功能异常强大，但调试起来比较烦，虽说自带日志，但时不时就需要来次重启，着实有点闹心。所以在开发过程中，模拟地理位置，只是其中一环，所以为了不影响开发，可以先用模拟器去模拟地理位置，待到打卡功能完善了后再考虑定位的事情，毕竟这由涉及到了 Xposed 插件开发。
开发 了解API
至于 AccessService 如何配置，构造配置这个就不多说了，不是本文重点。如果不会，可以参考这个：
微信抢红包插件
http://blog.csdn.net/dd864140130/article/details/51794318
继承了 AccessService 后，我们需要实现 onAccessibilityEvent 方法，这个方法的意思就是在触发了事件进行回调，至于你想捕捉何种事件，详情参考API，这里只列举在本例使用到的事件：
AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED:当通知栏发生变化时，也就是当有新通知显示在通知栏时触发；
AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:当窗体发生改变时触发，Activity，Fragment 的切换都会触发；
除此之外我们还需要关注 AccessibilityNodeInfo 实例的重要方法：
findAccessibilityNodeInfosByText：根据文本查找控件，可能会得到一个集合；
findAccessibilityNodeInfosByViewId：根据ID查找控件，会比较精准；
了解WXUI的构造
首先自己去搞一个企业WX的测试账号，成功登录后会进入如下界面：
了解代码
打卡功能是在工作台下的，所以需要先进入打卡模块，但这一系列操作都手动点击就失去了自动化的意义了，因此 AccessService 第一次介入，代码如下：
上述代码就能自动点击工作台按钮，这个代码是我们的核心部分。关于 findTagToClick() 是什么？等下介绍，先说几个需要注意的地方：
这是最重要的，如果想要一个控件响应单击事件，有几种办法?
1. OnClickListener
2. OnTouch() 处理 ActionDown 和 ActionUp 事件。
但重中之重就是该控件的属是 onClickable=true 的也就是可以被点击的，如果该属性为 false，那么辅助服务不能执行单击事件，至少我遇到的是这样。我在开发自动点击工作台这个步骤时，心想只要通过文本内容，拿到指定控件，然后执行单击就可以了。但结果怎样？没有任何反应，原因肯定就是控件没有接收事件，这是我遇到的第一个问题。
多说一句，为何 setOnClickListener 后就看见单击了？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbf45ac17b8de1d327c183a40949a140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b2582e4f4c30fd3ff92f808ce4c537d/" rel="bookmark">
			Linux中JAVA的安装配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、简介 JavaSE：标准版 JavaME：微型版 JAVAEE：企业版
JAVA版本：JDK6u3 也称为java6 6u3 -&gt; Version 6 update 3 版本号6,第三次更新版 sdk -&gt; Software Develop Kit 软件开发包 ml -&gt; Multi Language 多语言版本,安装包安装程序支持多种语言(非ML版本只有英文)
官网：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
2、安装配置
download nohup wget http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz?AuthParam=1501346908_907cdcc5a265a61a3c88ae2f31c0be32 &amp; install tar xfvz jdk-8u144-linux-x64.tar.gz configuration echo "JAVA_HOME=/usr/local/jdk1.8.0_144" &gt;&gt; /etc/profile echo 'export PATH=$JAVA_HOME/bin:$PATH' &gt;&gt; /etc/profile echo 'CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/lib/tools.jar' &gt;&gt; /etc/profile source /etc/profile echo 'Enter "java -version" to confirm the configuration success' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64da86b8024e1b20dd4b3ae8d9778185/" rel="bookmark">
			Keras学习之三：用CNN实现cifar10图像分类模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Keras学习之三：用CNN实现cifar10图像分类模型 1 卷积神经网络简介 卷积神经网络和全连接神经网络一样，都是由多个神经网络层连接而成。不同的是CNN一般是由多个卷积层，池化层交替连接起来，用于提取输入数据的高层特征，并缩小数据的维度。最后对提取出的特征进行神经网络分类形成最终的输出。更详细的卷积神经网络相关知识可参见第4节提供的链接。
2 Keras对CNN的支持 keras.layers包中实现了与CNN相关的层模型，分别实现在convolutional和pooling模块中。
2.1 convolutional模块 convolutional模块中实现了卷积层的层模型，用于数据的特征提取。
层名作用原型Conv1D1维卷积层Conv1D(filters, kernel_size, strides=1, padding=’valid’)Conv2D2维卷积层Conv2D（filters, kernel_size, strides=(1, 1), padding=’valid’，dilation_rate=(1, 1))UpSampling1D1维上采样，将数据重复指定的次数UpSampling2D(size=2)UpSampling2D2维上采样，将数据在2个维度上重复指定的次数UpSampling2D(size=(2, 2))ZeroPadding2D边界填充0ZeroPadding2D(padding=(1, 1)) 2D参数说明：
参数说明filters卷积核的数目，也是处理后输出的深度kernel_size过滤器的窗口大小strides过滤器卷积的步长padding补0策略，valid/sameactivation激活函数dilation_rate指定dilated convolution中的膨胀比例 2.2 pooling模块 pooling模块中实现池化层的的最大池化与平均池化的层模型，用于数据维度的缩减。
层名作用原型MaxPooling1D对1维输入进行最大值池化过滤MaxPooling1D(pool_size=2, strides=None, padding=’valid’)AveragePooling1D对1维输入进行平均池化过滤AveragePooling1D(pool_size=2, strides=None, padding=’valid’)MaxPooling2D对2维输入进行最大值池化过滤MaxPooling2D(pool_size=(2, 2), strides=None, padding=’valid’, data_format=None)AveragePooling2D对3维输入进行平均池化过滤AveragePooling2D(pool_size=(2, 2), strides=None, padding=’valid’, data_format=None)GlobalMaxPooling1D对1维输入进行全局最大值池化过滤GlobalMaxPooling1D()GlobalAveragePooling1D对1维输入进行全局平均值池化过滤GlobalAveragePooling1D()GlobalMaxPooling2D对2维输入进行全局最大值池化过滤GlobalMaxPooling2D()GlobalAveragePooling2D对2维输入进行全局平均值池化过滤GlobalAveragePooling2D() 2D参数说明
参数说明pool_size过滤器的大小，通常取(2,2)或(3,3)strides过滤器的移动步长，取2使得输出shape缩小一半paddingvalid为1填充，same为0填充data_format字符串，channels_first或channels_last之一 cifar10分类代码 下面的代码实现了一个下面结构的CNN模型，其结构为：卷积层-&gt;池化层-&gt;卷积层-&gt;池化层-&gt;全连结层-&gt;全连结层-&gt;Softmax层。
import keras from keras.datasets import cifar10 from keras.models import Sequential from keras.layers import Dense, Dropout, Activation, Flatten from keras.layers import Conv2D, MaxPooling2D num_classes = 10 model_name = 'cifar10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64da86b8024e1b20dd4b3ae8d9778185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468434a541c14c4da8060812aecd390b/" rel="bookmark">
			JetBrain系列ide更换主题的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更换IDEA主题只需要3步 1. 下载主题 在主题网站上IDEA Color Themes 上浏览喜欢的主题并下载该主题。（如果网址有变更,google IDEA themes即可。） 2. 导入主题 在IDEA中导入该主题，具体如下:
file –&gt; import setttings –&gt; 选中 1 中下载的主题jar文件 –&gt; 一路确认 –&gt; 重启
3. 设置主题 设置主题：
点击 settings –&gt; editor –&gt; colors &amp; fonts –&gt; general
如下图在该窗口右侧区域的scheme下拉菜单中选中导入的主题名称，点击确认即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45087c841c33aa45c3be8686384cd205/" rel="bookmark">
			Sqlite之删除超过50条的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在应用中，总要对用户的一些操作进行记录，比如播放历史记录，搜索历史记录等，方便用户再次使用。但是这些记录又不能无限的存储，只需要记录最新的50条或者100条就可以了，所以要求应用每插入一条新数据之后，对超过50条的数据进行清理。
本文以搜索历史记录为例，主要介绍sqlite中limit ，offset关键字的使用，最后给出此复合语句的写法。
建表 搜索历史记录只需要记录搜索关键词和搜索时间即可。所以我们需要这样的一张表：
表中只有两个字段（keyword , time）:其中keyword是唯一的，不允许重复；时间默认为写入数据库的默认时间，我们可是使用sqlite数据的datetime(‘now’)函数
好了，给出搜索历史记录（search_history）建表语句：
[sql] view plain copy CREATE TABLE [search_history] ([keyword] CHAR UNIQUE,[time] TIMESTAMP NOT NULL ON CONFLICT REPLACE DEFAULT (datetime(‘now’))) Sqlite之limit ，offset关键词 limit 语法有两种写法s
1. 一个参数 ： limit x
其中x是一个整数，表示返回x条目记录。 2.两个参数： limit x , y 其中x , y 都是整数，表示跳过x 条记录，返回 y 条记录，即 LIMIT &lt;skip&gt;, &lt;count&gt;
此外limit 还与offset关键词结合，语法是： limit x offset y 表示跳过 y 条记录，返回 x 条记录 ，即 LIMIT &lt;count&gt; OFFSET &lt;skip&gt;
乍一看 limit x , y 和limit x offset y 的语义很接近，千万不要搞混了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45087c841c33aa45c3be8686384cd205/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce259ac4e83d34ca53414a287359c71/" rel="bookmark">
			BugFree的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具/原料 xampp-win32-1.7.1-installer安装包
bugfree3.0.4安装包 方法/步骤 1 安装xampp
①一般默认，注意在下图中勾选Install Apache as service和Install MySQL as service就行了。
②正常安装后，apache和mysql服务自动运行，显示如下界面：
2 修改apache的端口：
如果apache的端口被占有，如下图所示：
这时候可以通过需要修改apache的端口来解决，具体操作如下：
在目录C:\xampp\apache\conf寻找文件httpd.conf,用记事本或者EditPlus 3打开，找到Listen 80，修改为8000以后的端口，如：Listen 8081，然后就可以启动apache。
3 设置数据库密码：
在浏览器中输入：http://localhost:8081/phpmyadmin/进入phpMyAdmin的
住页面，点击的“权限”，在用户为root、主机为localhost处进入编辑权限页面
4 解释：这里设置的密码是进入Mysql数据库服务器的密码，其默认用户名是root。
注：此处为设置Mysql数据的密码，执行此操作后phpMyAdmin便无法访问，可暂不管。如若希望访问，可修改其配置文件C:\xampp\phpMyAdmin、config.inc.php搜索：
$cfg['Servers'][$i]['password'] = '123456';
5 安装Bugfree
拷贝Bugfree3.0.4的安装包解压到C:\xampp\htdocs下，并修改文件夹名为bugfree
在浏览器输入http://localhost/bugfree 打开bugfree的安装页面。
6 环境检查通过，点击继续即可进行数据库配置
点击安装，直到建数据库表成功，后登陆bugfree即完成安装。
END 安装问题汇总： 安装Bugfree报HTTP500错误，如图：
此为Apache所报出的错误，查看Apache的错误日志，
日志目录：C:\xampp\apache\logs的error.log
报错RewriteEngine重写的解决方案：
错误日志：
C:/xampp/htdocs/bugfree/.htaccess: Invalid command 'RewriteEngine', perhaps misspelled or defined by a module not included in the server configuration, referer: http://localhost/
修改Apache的配置文件，文件目录：C:\xampp\apache\conf的httpd.conf文件，找到如下内容：
#LoadModule rewrite_module modules/mod_rewrite.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ce259ac4e83d34ca53414a287359c71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d28d1cb56927c3484480acce96fd9e79/" rel="bookmark">
			棋盘问题（回溯法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		棋盘问题（回溯法） 题目描述 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 输入 输入含有多组测试数据。 每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n 当为-1 -1时表示输入结束。 随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 输出 对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 样例输入 2 1
. .# 4 4 …# ..#. .#..
.. 样例输出 2 1 思路：进行行深搜，判断列是否摆放棋子，满足条件，记录该列，进行深度搜索，直到满足条件为止。 注意：此行可能不摆放棋子。
#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; int con[10]; char vis[10][10]; int n,k; int ans; int dfs(int r,int sum) { if(sum&gt;=k)//找到满足条件的值 { ans++; return 1; } if(r&gt;=n) return 1;//已经走过所有的行 for(int i=0;i&lt;n;i++) { if(con[i]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d28d1cb56927c3484480acce96fd9e79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9518570279fe6feb6d20aa23c8954a1a/" rel="bookmark">
			Mybatis 多对多注解 查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习mybatis多对多注解，记录下来以便日后查询。 这里多对多关系用到了学生(student)和课程(course)，一个学生可以选多门课，一门课可以被多名学生选择，中间表stu_cou. Student.java
public class Student { private int id; private String name; private Classes classes; private List&lt;Course&gt; courseList; //getter and setter } Course.java
public class Course { private int id; private String name; private int credit; private List&lt;Student&gt; studentList; //getter and setter } StudentMapper.java,在其中添加通过courseId查询student的select语句：
@Select("select * from student where id in(select stu_id from stu_cou where cou_id=#{courseId})") @Results({ @Result(id=true,property="id",column="id"), @Result(property="name",column="name"), @Result(property="classes",column="classes_id",javaType=Classes.class, one=@One(select="com.lsj.test.mybatis.annotation.mapper.ClassesMapper.selectClasses",fetchType=FetchType.LAZY)), @Result(property="courseList",column="id",many=@Many(select="com.lsj.test.mybatis.annotation.mapper.CourseMapper.selectCourseByStudent",fetchType=FetchType.LAZY)) }) public List&lt;Student&gt; selectStudentByCourse(int courseId); CourseMapper.java中添加通过学生Id查询Course的select语句
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9518570279fe6feb6d20aa23c8954a1a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/449/">«</a>
	<span class="pagination__item pagination__item--current">450/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/451/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>