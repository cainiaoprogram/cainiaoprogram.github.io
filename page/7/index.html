<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/982ff649a43c5fe7c9331a40a95c84c7/" rel="bookmark">
			rke2 Offline Deploy Rancher v2.8.0 latest （helm 离线部署 rancher v2.8.0）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 预备条件为什么是三个节点？​预备条件配置私有仓库介质清单安装 helm安装 cert-manager下载介质镜像入库helm 部署卸载 安装 rancher镜像入库helm 安装 验证 预备条件 所有支持的操作系统都使用 64-bit x86 架构。Rancher 兼容当前所有的主流 Linux 发行版。
查询 kubernetes 与 rancher 兼容性
请安装 ntp（Network Time Protocol），以防止在客户端和服务器之间由于时间不同步造成的证书验证错误。
某些 Linux 发行版的默认防火墙规则可能会阻止 Kubernetes 集群内的通信。从 Kubernetes v1.19 开始，你必须关闭 firewalld，因为它与 Kubernetes 网络插件冲突。
为什么是三个节点？​ 在RKE集群中，Rancher服务器数据存储在etcd上。这个etcd数据库在所有三个节点上运行。
etcd数据库需要奇数个节点，这样它总是可以选出一个拥有大多数etcd集群的领导者。如果etcd数据库不能选出一个领导者，etcd可能会遭受分裂的大脑，需要从备份中恢复集群。如果三个etcd节点中的一个失败，剩下的两个节点可以选举一个领导者，因为它们拥有etcd节点总数的大多数。
预备条件 安装 kubernetes ，这里我选择 rke2 方式私有镜像仓库：你可以选择安装 harbor 或者 安装 registry 配置私有仓库 (每个rke2节点都要执行更新)
RKE2 config containerd private registry $ vim /etc/rancher/rke2/registries.yaml mirrors: docker.io: endpoint: - "https://harbor.ghostwritten.com" configs: "harbor.ghostwritten.com": auth: username: admin password: Harbor12345 tls: insecure_skip_verify: true 如果是master 节点，重启 rke2-server
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/982ff649a43c5fe7c9331a40a95c84c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04ec44cfabc926fe062cc3bba8043af0/" rel="bookmark">
			Redis基础知识（持续更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb4cb1383eaf029b43b95cc12b153d10/" rel="bookmark">
			Python操作Word：轻松实现文档的创建、编辑与自动化处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：
在日常工作和学习中，我们经常需要使用Microsoft Word来创建、编辑和处理文档。然而，手动操作Word可能会耗费大量的时间和精力。为了提高工作效率，我们可以使用Python编程语言来操作Word文档，实现文档的自动化处理。本文将详细介绍如何使用Python操作Word，包括创建、编辑和自动化处理文档的方法。
一、安装Python-docx库
要使用Python操作Word，首先需要安装Python-docx库。Python-docx是一个用于创建、查询和修改Microsoft Word（.docx）文件的Python库。可以使用pip命令进行安装：
pip install python-docx 二、创建Word文档
导入库： import docx 创建文档对象： doc = docx.Document() 添加段落： paragraph = doc.add_paragraph('这是一个新的段落。') 保存文档： doc.save('example.docx') 三、编辑Word文档
打开文档： doc = docx.Document('example.docx') 读取段落： for paragraph in doc.paragraphs: print(paragraph.text) 修改段落： paragraph = doc.paragraphs[0] paragraph.text = '这是修改后的段落。' 添加图片： doc.add_picture('image.jpg', width=docx.shared.Inches(1)) 保存文档： doc.save('example_edited.docx') 四、自动化处理Word文档
批量替换文本： from docx import Document import os import re def replace_text(file_path, old_text, new_text): doc = Document(file_path) for paragraph in doc.paragraphs: paragraph.text = re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb4cb1383eaf029b43b95cc12b153d10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42702b7c88131f2efb3991624c8d2a98/" rel="bookmark">
			鹅目标检测数据集VOC格式300张
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鹅，一种家禽，以其独特的形态、生活习性和文化象征意义而备受人们喜爱。
鹅属于鸟纲、雁形目、鸭科，是一种大型水禽。它们的身体肥胖，羽毛洁白如雪，嘴部扁平且坚硬，脚部有蹼，适合在水中游动。
鹅是食草性动物，主要以水草、谷物和蔬菜等植物性食物为食。它们有着非常敏锐的视力和听力，能够轻易地发现食物和水中的危险。在繁殖季节，鹅还会筑巢产卵，精心照顾雏鹅。
鹅的粪便是一种优质的有机肥料，能够改善土壤质量。在农业生产中，人们会利用鹅来清除田间的杂草和害虫，促进农作物生长。
在中国传统文化中，鹅是吉祥、美好的象征。在诗词、绘画和其他艺术形式中，人们常用鹅来表达高洁、清雅的意境。此外，鹅肉也是一道美味的食材，营养丰富，受到人们的喜爱。
总的来说，鹅是一种美丽、勤劳且具有文化内涵的家禽。它们在维护生态平衡和丰富人类文化生活中发挥着重要的作用。让我们尊重和保护鹅的权益，为它们创造一个美好的生活环境。
今天，要介绍的就是鹅目标检测数据集：
数据集格式：Pascal VOC格式
图片数量(jpg文件个数)：300
标注数量(xml文件个数)：300
标注数量(txt文件个数)：300
标注类别数：1
标注规则：对类别进行画矩形框
标注工具：labelImg
重要说明：暂无
特别声明：本数据集不对训练的模型或者权重文件精度作任何保证，数据集只提供准确且合理标注
如下为标注图片案列：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad087010c91c8c5da4ba6d41e9448675/" rel="bookmark">
			java 项目使用 activi 设计流程，流程线上设置条件表达式时出现以下错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 背景：
java 项目使用 activi 设计流程，流程线上设置条件表达式后，保存时出现错误
问题描述 问题：
java 项目使用 activi 设计流程，流程线上设置条件表达式后，保存时出现以下错误：
原因分析： 分析问题：
流程线上书写的 表达式不符合 所使用流程引擎中的验证规则，
${msg == xxx}
${num &gt; 1}
${num &lt;10}
解决方案： 解决方案：
了解所使用 流程引擎的 验证规则，按照 规定的格式 书写 表达式。特别要注意表达式中 符号的中英文书写。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e00db89e435556cf037be90850e8e928/" rel="bookmark">
			《AI基本原理和python实现》栏目介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说明 栏目《AI基本原理和python实现》的设计目的是为了实现相关算法的python编程。因为用python实现AI需对相关的python库进行全方位了解，本栏目基本包含了【机器学习】相关的经典算法，除此之外还包括了数据分析、时间序列等一些概念和相关python代码。本篇主要介绍栏目的相关文章标题供大家参考。附带还说明栏目其他付费栏目的订阅方法。
二、博客建设理念 本博客基地，将建成人工智能领域的参考资料库；这个资料库收集的是AI的关键技术、AI最新技术。博客文章来源有三：1 博主本人所作，2 另一些是学习中的笔记文档，3 追踪当前全球AI前缘技术论文，这些所谓的前缘性技术，就是尚没有编程印刷书籍的技术文章。对于这些他人文章，博主进行二次创作，如：多文合并、追加段落、重新组织。因而无版权之忧。
另外，本博客基地文章必须保证有一定技术和理论高度，大致与硕士生水平相当。
三、收费栏目订阅方法 3.1 付费价格标准 本博客基地，原则上收费文章为每篇0.5-1元左右。以下表标示栏目的标价信息。
3.2 人工智能综合栏目 【人工智能综合】栏目文章最多，收费最高。而【人工智能综合】不是一个新栏目，是其他栏目的合编。它包含了七个AI题目的栏目，如下图：
3.3 栏目中有些文章与栏目不符合 栏目出现与本栏目不符的题目，似乎栏目管理不专业。情况是这样的，付费栏目只能追加，系统不允许删除，一旦操作失误就无法调整和改正，因此也就无法严格管理了，请大家见谅。
四、 栏目《AI基本原理和python实现》 NumPy 专业人士应该掌握的 45 个技能_numpy 必备操作 掌握 决策树算法：它们无处不在【01/2】_cart模型杂质测量 DBSCAN聚类算法原理和Python实现_轨迹聚类 python AdaBoost：提升机器学习的力量 数据无效：问题和解决方案的分析 机器学习算法(7)-朴素贝叶斯算法和K最近邻算法 AdaBoost 算法：理解、实现和掌握 AdaBoost 机器学习算法（9）——集成技术（Bagging——随机森林分类器和回归） 特征工程完整指南 - 第一部分 混淆矩阵和数据不平衡 （2/3）_混淆矩阵成本 探索泰勒级数在机器学习中的作用：从函数逼近到模型优化_泰勒级数神经网络 如何使用 Scikit-learn Pipeline 和 ColumnTransformer 提高机器学习代码质量_pipeline countvectorizer拆开怎么写 机器学习中的特征选择：方法和 Python 示例 降维技术——PCA、LCA 和 SVD 混淆矩阵和数据不平衡 （1/3）_混淆矩阵类别不平衡用概率还是数量 机器学习系列5：距离空间（1）_距离空间中b(1,4)表示什么) 机器学习库【03】：-NumPy-算术运算 【基础概念02】讲讲关于ROC曲线的故事 从根到叶：随机森林模型的深入探索 机器学习算法(1)——简单线性回归 机器学习算法(12) — 集成技术（Boosting — Xgboost 分类） 适应变化：动态预测在机器学习中的作用 机器学习：VC维的概念和用途 机器学习算法(8)——决策树算法 机器学习算法（11）——集成技术（Boosting——梯度提升） 机器学习中基于树的模型 机器学习中的独立和同分布 （IID）：假设和影响_机器学习iid 使用 PyTorch 进行 K 折交叉验证_pytorch如何使用k折交叉验证 机器学习：十大算法快速回顾 混淆矩阵和数据不平衡 （3/3） 支持向量机 (SVM)：初学者指南_支持向量机 参数 epsilon 机器学习中的混沌工程：拥抱不可预测性以增强系统鲁棒性埃 【机器学习】10 大算法及其用例_适合解决现实问题的机器算法 计算机码ASCII、Unicode、GBK、UTF-8之间的关系_unicode gbk Tkinter 面向对象框架《一》 Tkinter 面向对象框架《二》 在 Streamlit 中使用自定义 CSS 创建加密仪表板_streamlit设置css 【python知识】多进程专题（1）_os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e00db89e435556cf037be90850e8e928/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1455859aa1c9ade145263832a2c03d7c/" rel="bookmark">
			groovy XmlParser 递归遍历 xml 文件，修改并保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 groovy.util.XmlParser 解析 xml 文件，对文件进行修改（新增标签），然后保存。
是不是 XmlParser 没有提供方法遍历每个节点，难道要自己写？
什么是递归？ 不用说，想必都懂得~
import ***.XmlNodeCallback; import ***.PluginLog; import org.xml.sax.SAXException; import java.io.File; import java.io.IOException; import java.nio.file.Files; import java.nio.file.StandardOpenOption; import java.util.List; import javax.xml.parsers.ParserConfigurationException; import groovy.util.Node; import groovy.util.XmlParser; import groovy.xml.XmlUtil; public class PluginXmlUtil { /** * * @param xmlFile 需要解析的 xml 文件 * @param callback 回调每一个标签 node，可以对 node 进行 CURD * @return */ public static Node parseXml(File xmlFile, XmlNodeCallback callback) { if (CommUtils.isEmptyOrNoExists(xmlFile)) { return null; } try { Node rootNode = new XmlParser().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1455859aa1c9ade145263832a2c03d7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d116c73209edd116bfc1cd951c57f38b/" rel="bookmark">
			KVM系统虚拟化性能测试过程总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		buildroot编译 为啥要用buildroot 支持很多：交叉编译工具链、根文件系统生成、内核映像编译和引导加载程序编译。使用简单：使用类似内核的menuconfig、gconfig和xconfig配置界面，使用buildroot构建基本系统很容易。支持很多的包：很多benchmark的测试，qemu，kvmtools等都集成在里面。 基本介绍 目录结构
config：配置文件dl：下载的软件包output：输出文件package：软件包版本，编译配置信息 配置界面：
主要关注：
Target options：用于为构建目标选择特性和配置参数Toolchain：该选项用于配置工具链和编译器特性System configuration：该选项用于配置生成的文件系统的配置文件和启动特性Target packages：该选项用于选择和配置所需要的软件包和软件环境Filesystem images：该选项用于配置经buildroot编译构建后的文件系统的镜像格式 虚拟机根文件系统需设置：
配置保存 配置文件作为.config存储在顶级buildroot源目录中。它是一个完整的配置文件，它包含所有选项的值。efconfig只存储选择了非默认值选项的值，这样更容易阅读、修改，可以用于配置的自动化构建。对于默认的buildroot配置，defconfig是空的，一切都是默认的。
在configs/目录下，有许多已经配置好的*_defconfig，我们可以根据它来生成.config文件。
make *_defconfig 然后再：
make menuconfig 它会覆盖当前的.config文件，如果要保存，则可以使用：
make savedefconfig 升级qemu 默认的qemu不支持cortex-a55，最新的qemu8.2.0则支持。
下载最新的qemu-8.2.0.tar.xz，并把它放入dl目录。
修改package/qemu目录下的qemu.mk:
QEMU_VERSION = 8.2.0 QEMU_SOURCE = qemu-$(QEMU_VERSION).tar.xz QEMU_SITE = http://download.qemu.org QEMU_LICENSE = GPL-2.0, LGPL-2.1, MIT, BSD-3-Clause, BSD-2-Clause, Others/BSD-1c QEMU_LICENSE_FILES = COPYING COPYING.LIB 并且在qemu的编译配置中(搜索宏QEMU_CONFIGURE_CMDS)，添加编译参数：
--disable-hexagon-idef-parser kernel编译 配置 make ARCH=arm64 CROSS_COMPILE=/home/yue/beauty/proj/rk356x_linux_release_v1.3.0b_20221213/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu- menuconfig 选择KVM:
配置console：
关联根文件系统：
编译 ake ARCH=arm64 CROSS_COMPILE=/home/yue/beauty/proj/rk356x_linux_release_v1.3.0b_20221213/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu- j8 输出 arch/arm64/boot/Imagevmlinux file一下发现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d116c73209edd116bfc1cd951c57f38b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66855326b9c46f2a694830b8122c59dd/" rel="bookmark">
			docker 容器添加指定网络地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker 容器添加指定网络地址 在搭建halo博客时，准备让 halo、mysql8.1、nginx 三个容器在同一个网段中，并指定IP。
实现docker内部容器之间网络互通。
查看容器网络信息命令
docker inspect 容器名 各容器部署成功后网络效果如下： nginx 网络 IP：172.10.0.4
网关 ：172.10.0.1
halo 网络 IP：172.10.0.2
网关 ：172.10.0.1
halodb 网络（halo数据库 mysql8.1） IP：172.10.0.3
网关 ：172.10.0.1
部署流程如下： halo 博客部署 由于开始前我没有创建自定义网络。
我采用的是 部署halo时创建网络。
如果需要创建自定义网络看 》》》自定义创建网络
如果已经有自定义网络，将 halo docker-compose.yaml文件中 networks 配置，
按照下面 nginx docker-compose.yaml文件 networks 来修改。
version: "3" services: #halo 配置 halo: image: halohub/halo:2.11 container_name: halo restart: on-failure:3 depends_on: halodb: condition: service_healthy networks: mynetwork: #网络名称 ipv4_address: 172.10.0.2 ###halo指定网络 volumes: - .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66855326b9c46f2a694830b8122c59dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21c13dd14a4573267a31f971f9a74091/" rel="bookmark">
			Java动态代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态代理：
代理程序中某个类中的功能，为该功能进行增强
动态代理实现步步骤：
1.补代理类，必须要有实现接口
2.创建被代理对象，交给代理对象使用
动态代理的实现
JDK已经提供了现在的代理对象的 生成 Proxy 类
静态方法：newProxyInstance(类加载器，接口数组，处理器) package javaseproxy.demo1; import org.junit.Test; import java.io.Serializable; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.util.List; //处理器 class MyInvocationHandler implements InvocationHandler{ private UserService userService; public MyInvocationHandler(UserService userService) { this.userService = userService; } public MyInvocationHandler() { } /** * * @param proxy 代理对象(不使用) * @param method 方法对象（被代理类所书写的每一个成员方法） * @param args 成员方法中的参数 * @return 方法方法执行后的结果 * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21c13dd14a4573267a31f971f9a74091/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf9cae93e98f5181c06187e8066ffc3d/" rel="bookmark">
			【原型验证】SoC 原型验证环境说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：闲敲棋子
SoC 原型验证环境说明 前言 最近招聘的时候，有很多校招生在询问，原型验证主要的工作内容是什么？ 使用的语言又是什么？ 主要操作的平台是什么？ 未来的职业发展又是什么样子的？。。。。
这里呢，笔者就原型验证平台先做一个简要的说明，至于其它问题，后续有时间了再慢慢撰写；
验证流程 在说相关验证平台的时候，这里简单对验证流程做一个简要的说明，后面有机会再展开描述：
System Design后，Design会交付代码给到DV 验证团队（design verification/System Level Verification），DV验证完成后交付RTL给到原型团队（或者平台团队）进行硬件验证平台的版本迭代，而这里说的验证版本，即是原型同学需要验证的标的~，即基于某个RTL综合的FPGA/Emulation版本进行SOC的原型验证；
软件平台 软件平台指代的是平时我们工作的时候，主要使用的一些相关软件、应用工具，比如操作系统，开发语言等等；在说这个之前，大家可以看看原型验证招聘的基本要求：
从上大家已经可以了解到原型验证工程师在平时工作中，会使用到哪些工具：
汇编/C/C++/shell/python , 这个是基本功，原型验证的主要用例开发也是基于汇编以及C来进行的，可能部分自动化平台比如jenkin还会涉及到shell以及python；
Linux/RTOS/Vxworks/AutoSar… ： 操作系统应该也是基本功，在工作中，原型的同学会针对各个不同的硬件模块进行驱动开发，而驱动可能运行在linux或者baremater的操作系统上；
当然以上，只是基本要求，事实上目前很多大型SOC的设计公司，要求原型的同学能够自己看懂RTL代码，电路图等等，团队内有时候自嘲说，原型的同学是DV+原型+软件，三位一体，打三分工，拿一分钱。
但是从能力图谱上来说，原型的同学成长的广度是远远高于其他岗位的，因为他能够接触到的知识圈非常丰富（PS，下限也非常低，笔者见过10多年工作经验的还只是会配置寄存器，写写简单驱动~~）
不得不说，从业生涯中，看到过原型的同学转岗做架构师、DV验证、软件开发、软件测试、FAE、流程质量、HR以及项目经理等等的，求职范围非常之大~~~
也有做验证经理、项目经理较多，因为原型验证对于项目的把控能力，风险意识都非常的有经验。
硬件平台 大家在网上看到原型验证岗位的时候，一般前面都会带FPGA关键字，好像原型只有FPGA验证平台一样，事实上，在一些大型公司里面，FPGA只是原型验证平台之一。
原型还有一个重要的验证平台是Emulation，以及某些公司会有功能级别的底软开发平台，比如Qemu/fastmodel等，这里我会简要的对FPGA/Emulation进行一些简单的对比：
总结起来：
FPGA 更多的是进行模块级功能验证，压力验证，长稳验证以及兼容性验证，PXP上更多的进行全系统的压力验证，性能验证，功耗验证以及FPGA上的问题复现定位; FPGA 平台对比 亚科鸿宇VeriTiger 优势 1.便宜； 不足 调试手段比较单一，不支持RTL Debug；无自动化Partition工具，需要手动Partition（很重要，手动partion需要解决的问题非常多，也容易引入额外的问题） S2C Single VU440 优势 平台按可扩展性还不错；子板丰富并且价格便宜。价格也相对便宜 不足 有高级的调试工具和Partition工具，但是这些EDA工具的性能和易用性待检验；宣传的可扩展性，没有实际检验过 Synopsy HAPS-100 优势 Synopsys的工具（Synplify、Identity和Protocompiler）对HAPS-100平台原生支持，EDA易用，生态好Synopsys IP的FPGA验证环境一般都是针对HAPS平台设计，有配套的IP开发套件（IPK,IP Prototyping Package），能有效缩短接口类IP的调试周期；调试手段多样，抓取波形也很方便；有自动化的Partition工具，多板级联方案成熟。 不足 主板、子板死贵死贵的，每年的维保费也死贵维修很不方便，有可能寄送国外地缘政治问题，某些公司可能用不了 比如现在的公司，没有这个东西，只能买板卡，自己制造平台。
综合来看，绝大部分的公司最后其实还是会选择 Synopsy HAPS-100，因为项目进度往往是第一考虑的原因，否则很多时候，都在定位平台的问题，为平台买单，当然有实力的公司也会自研，基本上成本只要HAPS的1/5；
Emulation平台对比 Emulation的价格更是死贵死贵的（Cadence 1cluster的价格每个月100-150万美金左右），所以在很多时候，需要24小时都安排相关的测试任务;
业界目前比较常见的几个Emulation平台：
Cadence公司：Palladium 上图，介绍了Palladium Z2以及Palladium X2，X2更像一个大型的FPGA，可以拥有更高的频率（5M~15MHZ），但是又能支持同比降频，也能类似Z2测试性能，但是定位问题起来略微不太方便，更适合做整体的原型业务的部署测试；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf9cae93e98f5181c06187e8066ffc3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b5ef644d26f76e9085bb0f6948b72c4/" rel="bookmark">
			centOS系统yum安装和卸载mongodb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.1 什么是mongodb？
0.2 Mongodb是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。
0.3 Mongodb是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。
本资料根据官方网站上总结。
0.4 第一步先学会安装和卸载。
1.查看是否有MongoDB源 CentOS8的源位置在/etc/yum.repos.d/,如果没有现成的repo，自己来写一个。
先查看一下官网最新的版本
[root@iZ10uzqlb90od9Z /]# cd /etc/yum.repos.d/ [root@iZ10uzqlb90od9Z yum.repos.d]# ls CentOS-Base.repo CentOS-Sources.repo epel.repo.rpmnew mysql-community-source.repo CentOS-CR.repo CentOS-Vault.repo epel-testing.repo redhat.repo CentOS-Debuginfo.repo CentOS-x86_64-kernel.repo mongodb-org-4.4.repo CentOS-fasttrack.repo docker-ce.repo mongodb-org-7.0.5.repo CentOS-Media.repo epel.repo mysql-community.repo [root@iZ10uzqlb90od9Z yum.repos.d]# 2.配置 MongoDB 的 Yum 仓库 sudo vi /etc/yum.repos.d/mongodb-org-4.4.repo 在编辑器中输入以下内容：
[mongodb-org-4.4] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.4/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc 保存并退出编辑器。
3.安装 MongoDB sudo yum install mongodb-org 该命令会自动安装 MongoDB 相关组件和依赖。
最新版本下载并安装
1.官网下载mongodb安装包
下载地址：https://www.mongodb.com/download-center/community
选择版本，操作系统为linux64位的
2.创建安装包存放目录及解压目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b5ef644d26f76e9085bb0f6948b72c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d1b517f9b7813a03ecbaf9a6517a635/" rel="bookmark">
			用PHP来模拟雨滴的动态效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是一个示例代码，展示如何使用PHP和HTML/CSS来模拟雨滴的动态效果：
html复制代码
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; #rain { position: relative; height: 400px; background-color: #000; } .raindrop { position: absolute; height: 5px; width: 5px; background-color: #fff; border-radius: 50%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="rain"&gt;&lt;/div&gt; &lt;script src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function() { function dropRain() { for (let i = 0; i &lt; 100; i++) { setTimeout(function() { let x = Math.random() * 400; // 随机生成雨滴的x坐标 let y = Math.random() * 200; // 随机生成雨滴的y坐标 let size = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d1b517f9b7813a03ecbaf9a6517a635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/527622117de21d2fd4dcbce22519cc88/" rel="bookmark">
			解决CDN的网站后台无法获取访客真实ip的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		宝塔的面板，网站后台获取到的不是访客的真实 ip ，而是 CDN 的 ip ，这给站长造成了不少影响，例如通过ip地址判定的设置都不准确，甚至假如网站被攻击，对方的真实ip地址都记录不到。
这个问题如何解决？
其实很简单，只需要到 Nginx “设置”中，找到“配置修改”，在 http 区段增加如下代码后，重载配置或者重启 Nginx 即可：
#CDN获取真实ip set_real_ip_from 0.0.0.0/0; real_ip_header X-Forwarded-For; Copy
如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9018ece8b4c6faab0509b955be913407/" rel="bookmark">
			对接第三方登录接口JAVA代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：对接第三方登录接口，实现第三方跳转登录
package com.glodon.zjdata.snjzsc.auth.service; import cn.hutool.core.util.ObjectUtil; import com.alibaba.fastjson.JSONObject; import com.glodon.zjdata.baseline.base.common.dto.JsonResult; import com.glodon.zjdata.snjzsc.auth.dto.UserInfo; import com.glodon.zjdata.snjzsc.auth.dto.LoginParam; import com.glodon.zjdata.snjzsc.system.api.auth.client.AuthOrgUserClient; import com.glodon.zjdata.snjzsc.system.common.auth.model.AuthUserForUserNameAndPhone; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang3.StringUtils; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.utils.URIBuilder; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.util.EntityUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import javax.net.ssl.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.OutputStream; import java.net.HttpURLConnection; import java.net.URL; import java.nio.charset.StandardCharsets; @Component @Slf4j public class LoginService { private String BaseUrl = "http://三方IP:三方端口"; private String AppId = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9018ece8b4c6faab0509b955be913407/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a40a3d2d66697630170ef9e84305c64/" rel="bookmark">
			初识 Elasticsearch 应用知识，一文读懂 Elasticsearch 知识文集(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏆作者简介，普修罗双战士，一直追求不断学习和成长，在技术的道路上持续探索和实践。
🏆多年互联网行业从业经验，历任核心研发工程师，项目技术负责人。
🎉欢迎 👍点赞✍评论⭐收藏
🔎 Elasticsearch 领域知识 🔎
链接专栏Elasticsearch 专业知识学习一Elasticsearch专栏Elasticsearch 专业知识学习二Elasticsearch专栏 文章目录 🏆 初识 Elasticsearch 应用知识🔎 初识 Elasticsearch 应用知识(2)🍁🍁 01、简要介绍一下 Elasticsearch？🍁🍁 02、什么是 Elasticsearch 脑裂？🍁🍁 03、Beats 如何与 Elasticsearch 结合使用？🍁🍁 04、解释一下 Elasticsearch 的 分片？🍁🍁 05、精准匹配检索和全文检索匹配检索的不同？🍁🍁 06、您能解释一下 Elasticsearch 中的 Explore API 吗？🍁🍁 07、能列举过你使用的 X-Pack 命令吗?🍁🍁 08、Elasticsearch 全文检索？🍁🍁 09、你之前公司的Elasticsearch集群，一个Node一般会分配几个分片？🍁🍁 10、你能否列出与 Elasticsearch 有关的主要可用字段数据类型？🍁🍁 11、详细描述一下 Elasticsearch 索引文档的过程？🍁🍁 12、logstash 如何与 Elasticsearch 结合使用？🍁🍁 13、您能否列出 与 ELK日志分析相关的应用场景？🍁🍁 14、解释一下 Elasticsearch 集群中的 Type 的概念 ？🍁🍁 15、Elasticsearch 支持哪些类型的查询？🍁🍁 16、Elasticsearch 实际设计?🍁🍁 17、Elasticsearch 是如何实现 master 选举的？🍁🍁 18、Elasticsearch 中的副本是什么？🍁🍁 19、Elasticsearch 是如何实现 Master 选举的？🍁🍁 20、Elasticsearch 分布式架构原理？🍁🍁 21、Elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些调优手段？ 🏆 初识 Elasticsearch 应用知识 🔎 初识 Elasticsearch 应用知识(2) 🍁🍁 01、简要介绍一下 Elasticsearch？ Elasticsearch 是一个开源的分布式全文搜索和分析引擎，用于存储、搜索和分析各种类型的数据。它构建在 Apache Lucene 的基础上，提供了简单易用的 RESTful API，旨在实时地处理大量数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a40a3d2d66697630170ef9e84305c64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37355ed3ced476c9cc0e6e9b9776833d/" rel="bookmark">
			CSS的transform属性学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CSS中，transform属性允许你对元素进行旋转、缩放、倾斜或平移操作。这些变换不会影响文档布局，只会影响元素的绘制。
transform属性包括以下属性：
translate：用于移动元素的位置。可以指定水平和垂直方向的移动距离。scale：用于缩放元素的大小。可以指定水平和垂直方向的缩放比例。。：用于旋转元素。可以指定旋转的角度。skew：用于倾斜元素。可以指定水平和垂直方向的倾斜角度。 /* 移动元素 */ .move { transform: translate(50px, 100px); } /* 缩放元素 */ .scale { transform: scale(1.5, 1.5); } /* 旋转元素 */ .rotate { transform: rotate(45deg); } /* 倾斜元素 */ .skew { transform: skew(30deg, 20deg); } 应用场景：
图片展示：在网页中展示图片时，可以使用transform属性来实现图片的缩放、旋转等效果，以吸引用户的注意力。在这个中，当鼠标悬停在具有.image-container类的图片容器上时，图片会以1.1倍的比例进行缩放，以突出显示。 .image-container { transition: transform 0.3s ease; } .image-container:hover { transform: scale(1.1); } 按钮点击效果：在网页中的按钮元素上，可以使用transform属性来实现点击时的缩放效果，以提升交互体验。在这个中，当按钮被点击时，按钮会以0.9倍的比例进行缩放，以提供点击反馈效果。 .button { transition: transform 0.2s ease; } .button:active { transform: scale(0.9); } 卡片翻转效果：在网页中展示卡片式内容时，可以使用transform属性来实现卡片的翻转效果，以展示更多的信息。在这个中，当鼠标悬停在具有.card类的卡片上时，卡片会绕Y轴旋转180度，展示卡片的背面内容。 .card { transition: transform 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37355ed3ced476c9cc0e6e9b9776833d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0559aa1f8c85bf158897db6b77295a1e/" rel="bookmark">
			next怎么用TinyMCE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人github 在Next.js中使用TinyMCE编辑器，你需要按照以下步骤操作：
安装TinyMCE React包：
首先，你需要安装TinyMCE的React包。你可以使用npm或yarn来安装它。
npm install @tinymce/tinymce-react 或者
yarn add @tinymce/tinymce-react 导入TinyMCE React组件：
在你的Next.js页面或组件中，导入Editor组件。
import { Editor } from '@tinymce/tinymce-react'; 使用Editor组件：
在你的React组件中，使用Editor组件并传递所需的配置。
const MyComponent = () =&gt; { const handleEditorChange = (content, editor) =&gt; { console.log('Content was updated:', content); }; return ( &lt;Editor initialValue="&lt;p&gt;This is the initial content of the editor&lt;/p&gt;" init={{ height: 500, menubar: false, plugins: [ 'advlist autolink lists link image charmap print preview anchor', 'searchreplace visualblocks code fullscreen', 'insertdatetime media table paste code help wordcount' ], toolbar: 'undo redo | formatselect | ' + 'bold italic backcolor | alignleft aligncenter ' + 'alignright alignjustify | bullist numlist outdent indent | ' + 'removeformat | help' }} onEditorChange={handleEditorChange} /&gt; ); }; 配置TinyMCE：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0559aa1f8c85bf158897db6b77295a1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19e24e03b11bc6042d992ede147a136/" rel="bookmark">
			“rpm -qa“ 和 “yum list installed“ 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rpm -qa vs yum list installed: Why certain packages can be found with rpm -qa only?
问题现象 Python 2.7.5 是存在的。rpm -qa 可以成功查询，但是 yum list installed却没查到。
[root@CentOS7 centos]# python -V Python 2.7.5 [root@CentOS7 centos]# [root@CentOS7 centos]# rpm -qa | grep python-2.7.5 python-2.7.5-58.el7.x86_64 [root@CentOS7 centos]# [root@CentOS7 centos]# yum list installed | grep python-2.7.5 [root@CentOS7 centos]# yum list installed 介绍 the package nameversion numberthe repository nicknameaudit-libs-python.x86_642.7.6-3.el7@basedbus-python.x86_641.1.1-9.el7installedlibselinux-python.x86_642.5-11.el7@baselibsemanage-python.x86_642.5-8.el7@baselibxml2-python.x86_642.9.1-6.el7_2.3installednewt-python.x86_640.52.15-4.el7installedpolicycoreutils-python.x86_642.5-17.1.el7@basepython.x86_642.7.5-58.el7@baserpm-python.x86_644.11.3-25.el7@base yum list installed 查出结果如上分三列显示，可以针对单独某列进行查询，比如
[root@user1 ~]# yum list installed | grep 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e19e24e03b11bc6042d992ede147a136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fdd0e1db37dcf2d25daebe8cf35052d/" rel="bookmark">
			1.8 湍流谱代码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Kaimal 模型代码解读 Kaimal 模型 代码 import numpy as np from scipy import signal from scipy.optimize import curve_fit from scipy.signal import welch import matplotlib.pyplot as plt def KaiFit(u, meanU, dt, TI_min, Nsegms, OveLapPer, component='u', averageing_method='mean', fig=False): """ Args: u: meanU: dt: TI_min: Nsegms: OveLapPer: component: averageing_method: fig: Returns: """ # u: velocity vector(time-series) of the subgroup # meanU: mean value of vector u # TI_min: Time Interval of the subgroup # Nsegms: Number of Welch's segments # OveLapPer: percent of Welch's Overlaping, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fdd0e1db37dcf2d25daebe8cf35052d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e29b58c78756646616a71fb844acb01b/" rel="bookmark">
			C# HttpClient Get Post简单封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言封装好的代码测试接口测试代码 前言 微软官方有Get和Post请求，我把他简单化处理一下
封装好的代码 public class MyHttpHelper { private string baseUrl; /// &lt;summary&gt; /// 基础Api /// &lt;/summary&gt; public string BaseUrl { get { return baseUrl; } set { baseUrl = value; MyHttpClient = new HttpClient() { BaseAddress = new Uri(baseUrl) }; } } public HttpClient MyHttpClient { get; set; } public MyHttpHelper() { } public MyHttpHelper(string baseUrl) { BaseUrl = baseUrl; } /// &lt;summary&gt; /// 序列化返回值 /// &lt;/summary&gt; /// &lt;typeparam name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e29b58c78756646616a71fb844acb01b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c55d56c1332108dd4d7fef398b0811f9/" rel="bookmark">
			Android 事件分发介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、目的二、环境三、相关概念3.1 事件分发 四、详细设计4.1应用布局4.1.1 应用布局结构4.1.2 LayoutInspector 4.2 关键View&amp;方法4.2.1 相关View4.2.2 相关方法4.2.3 View与方法关系 4.3 事件分发概念图4.3.1 事件分发类图4.3.2 事件分发模型图 4.4 Activity组件4.4.1 Activity-&gt;dispatchTouchEvent()4.4.2 Activity-&gt;getWindow()4.4.3 Activity-&gt;onTouchEvent() 4.5 ViewGroup组件4.5.1 ViewGroup-&gt;dispatchTouchEvent()4.5.2 ViewGroup-&gt;dispatchTransformedTouchEvent() 4.6 View组件4.6.1 View-&gt;dispatchTouchEvent()4.6.2 OnTouchListener-&gt;onTouch()4.6.3 View-&gt;onTouchEvent() 4.7 例子-点击事件时序图 五、小结&amp;问题点六、代码仓库地址七、参考资料 一、目的 最开始接触Android时，仅仅是知道Android系统存在的点击事件、触摸事件，但是并不清楚这些事件的由来。
之后，在面试Oppo和美图时，皆有问到Android的事件分发机制，但是都被问得很懵逼，归根到底都是对于其实现逻辑的不理解。
随后，想去弥补该模块的不足，浏览很多关于Android事件分发的博文，但仍存在一些疑惑，就想着去阅读下源码，整理下笔记，希望对同学们有帮助。
二、环境 版本：Android 11平台：展锐 SPRD8541E 三、相关概念 3.1 事件分发 Android 中 View 的布局是一个树形结构，各个 ViewGroup 和 View 是按树形结构嵌套布局的，从而会出现用户触摸的位置坐标可能会落在多个 View 的范围内，这样就不知道哪个 View 来响应这个事件，为了解决这一问题，就出现了事件分发机制。
四、详细设计 4.1应用布局 4.1.1 应用布局结构 如下为一个Activity打开后，其对应视图的层级结构。
4.1.2 LayoutInspector Layout Inspector是google提供给我们进行布局分析的一个工具，也是目前google在弃用Hierarchy View后推荐使用的一款布局分析工具。
4.2 关键View&amp;方法 4.2.1 相关View 组件描述ActivityAndroid事件分发的起始端，其为一个window窗口，内部持有Decorder视图，该视图为当前窗体的根节点，同时，它也是一个ViewGroup容器。ViewGroupAndroid中ViewGroup是一个布局容器，可以嵌套多个 ViewGroup 和 View，事件传递和拦截都由 ViewGroup 完成。View事件传递的最末端，要么消费事件，要么不消费把事件传递给父容器 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c55d56c1332108dd4d7fef398b0811f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c443a9b7e671802d174b23f5990103/" rel="bookmark">
			GBASE南大通用GBase 8a ODBC 配置SSL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GBase南大通用 GBase 8a MPP Cluster支持SSL标准协议，SSL协议是一种安全性更高的协议标准，它加入了数字签名和数字证书来实现客户端和服务器的双向身份验证，保证了通信双方更加安全的数据传输。
GBase南大通用 GBase 8a 通过SSL加密应用端ODBC驱动和8a集群Server之间的通讯，步骤如下：
一、8a集群Server的系统中安装openssl库，能够执行openssl命令
二、在8a集群 Server端 的系统中，选择一个目录（如/usr/local/ssl），在这个目录下生成server端和client端的密钥和证书
****************server端****************
CA（ca-key.pem私钥，ca-cert.pem公钥）
openssl req -sha1 -new -x509 -nodes -days 3650 -keyout ca-key.pem &gt; ca-cert.pem
server的私钥：
openssl req -sha1 -newkey rsa:2048 -days 730 -nodes -keyout server-key.pem &gt; server-req.pem
导出server 私钥（RSA类型）
$ openssl rsa -in server-key.pem -out server-key.pem
writing RSA key
CA生成server的证书：server-cert.pem
$ openssl x509 -sha1 -req -in server-req.pem -days 730 -CA ca-cert.pem -CAkey ca-key.pem -set_serial 01 &gt; server-cert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04c443a9b7e671802d174b23f5990103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0062e2b310d6420eae6b5ae81ed96d0c/" rel="bookmark">
			YOLOv8性能评估指标-＞mAP、Precision、Recall、FPS、IoU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始讲解之前推荐一下我的专栏，本专栏的内容支持(分类、检测、分割、追踪、关键点检测),专栏目前为限时折扣，欢迎大家订阅本专栏，本专栏每周更新3-5篇最新机制，更有包含我所有改进的文件和交流群提供给大家。 专栏目录：YOLOv8改进有效系列目录 | 包含卷积、主干、检测头、注意力机制、Neck上百种创新机制
专栏回顾：YOLOv8改进系列专栏——本专栏持续复习各种顶会内容——科研必备 一、简介 这篇博客，主要给大家讲解我们在训练yolov8时生成的结果文件中各个图片及其中指标的含义，帮助大家更深入的理解，以及我们在评估模型时和发表论文时主要关注的参数有那些。本文通过举例训练过程中的某一时间的结果来帮助大家理解，大家阅读过程中如有任何问题可以在评论区提问出来，我会帮助大家解答。首先我们来看一个在一次训练完成之后都能生成多少个文件如下图所示，下面的文章讲解都会围绕这个结果文件来介绍。
二、评估用的数据集 上面的训练结果，是根据一个检测飞机的数据集训练得来，其中只有个标签就是飞机，对于这种单标签的数据集，其实我们可以将其理解为一个二分类任务，
一种情况-&gt;检测为飞机，另一种情况-&gt;不是飞机。
三、结果分析 我们可以从结果文件中看到其中共有文件24个，后12张图片是根据我们训练过程中的一些检测结果图片，用于我们可以观察检测结果，有哪些被检测出来了，那些没有被检测出来，其不作为指标评估的文件。 Weights文件夹 我们先从第一个weights文件夹来分析，其中有两个文件，分别是best.pt、last.pt,其分别为训练过程中的损失最低的结果和模型训练的最后一次结果保存的模型。
args.yaml 第二个文件是args.yaml文件,其中主要保存一些我们训练时指定的参数，内容如下所示。
混淆矩阵(ConfusionMatrix) 第三个文件就是混淆矩阵，大家都应该听过这个名字，其是一种用于评估分类模型性能的表格形式。它以实际类别（真实值）和模型预测类别为基础，将样本分类结果进行统计和汇总。
对于二分类问题，混淆矩阵通常是一个2×2的矩阵，包括真阳性（True Positive, TP）、真阴性（True Negative, TN）、假阳性（False Positive, FP）和假阴性（False Negative, FN）四个元素。
True_Label = [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1 ,0, 1, 0 , 1 , 0, 0 , 1] Predict_Label = [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1 ,0 , 0 , 1 , 0, 0 , 1, 0] 我们来分析这个图，其每个格子代表的含义我在图片上标注了出来,下面我们来拿一个例子来帮助大家来理解这个混淆矩阵。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0062e2b310d6420eae6b5ae81ed96d0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/018ff3beb33bcd048957fb78369cbd5a/" rel="bookmark">
			项目-苍穹外卖基础(持续更新中~)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		day1:
login的后端实现：
day 2:
返回401的重登录token
controller service: mapper
mapper.xml yml: 去掉： bucket记得开成公共读！！！,不然没回显
Query请求类似如下：通过？，那么接收的时候就不用@RequestBody，直接用对应实体类接收即可 优化：
----------------------------------------------------------------------------------
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3507209d7854024fe52829caaef98293/" rel="bookmark">
			Tiny syposis on Motivational notes, remarks and comments from text/paragraphy/VE/materials/resources
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tiny syposis on Motivational/inspired material resources I) 查理芒格:如果你保持专注，每天早起，持续学习，并且延迟满足，那么你会成功！[^1]1.1) webpage path/route/address[url resource](https://www.bilibili.com/video/BV1HN4y1q7iv/?spm_id_from=333.999.0.0&amp;vd_source=97ce8e8ec6b926c1293395a04ed185f9) 1.2) text excerption I) 查理芒格:如果你保持专注，每天早起，持续学习，并且延迟满足，那么你会成功！1 1.1) webpage path/route/address url resource 1.2) text excerption Obviously if you are glued together, and be honorable (for what we are giving more and taking less), and get up every morning (super early and go to bed early as well) and keep doing.
And you are winglling to go for a lot of deferred gratification all your life, you are going to be success.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3507209d7854024fe52829caaef98293/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516766bc0c7d1f8db147e8a24c5ac0b7/" rel="bookmark">
			大创项目推荐 深度学习手势识别 - yolo python opencv cnn 机器视觉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 课题背景2 卷积神经网络2.1卷积层2.2 池化层2.3 激活函数2.4 全连接层2.5 使用tensorflow中keras模块实现卷积神经网络 3 YOLOV53.1 网络架构图3.2 输入端3.3 基准网络3.4 Neck网络3.5 Head输出层 4 数据集准备4.1 数据标注简介4.2 数据保存 5 模型训练5.1 修改数据配置文件5.2 修改模型配置文件5.3 开始训练模型 6 实现效果6.1图片效果6.2 视频效果,摄像头实时效果 7 最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 **基于深度学习加驾驶疲劳与行为检测 **
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：4分工作量：3分创新点：5分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 课题背景 火灾事故的频发给社会造成不必要的财富损失以及人员伤亡，在当今这个社会消防也是收到越来越多的注视。火灾在发生初期是很容易控制的，因此，如何在对可能发生灾害的场所进行有效监控，使得潜在的损失危害降到最低是当前研究的重点内容。传统的探测器有较大的局限性，感温、感烟的探测器的探测灵敏度相对争分夺秒的灾情控制来说有着时间上的不足，而且户外场所的适用性大大降低。随着计算机视觉的发展，基于深度学习的图像处理技术已经愈发成熟并且广泛应用在当今社会的许多方面，其在人脸识别、安防、医疗、军事等领域已经有相当一段时间的实际应用，在其他领域也展现出跟广阔的前景。利用深度学习图像处理技术对火灾场景下火焰的特征学习、训练神经网络模型自动识别火焰，这项技术可以对具有监控摄像头场景下的火灾火焰进行自动、快速、准确识别并设置预警装置，从而在火灾发生的初期及时响应
2 卷积神经网络 受到人类大脑神经突触结构相互连接的模式启发，神经网络作为人工智能领域的重要组成部分，通过分布式的方法处理信息，可以解决复杂的非线性问题，从构造方面来看，主要包括输入层、隐藏层、输出层三大组成结构。每一个节点被称为一个神经元，存在着对应的权重参数，部分神经元存在偏置，当输入数据ｘ进入后，对于经过的神经元都会进行类似于：y＝w*x＋b的线性函数的计算，其中ｗ为该位置神经元的权值，b则为偏置函数。通过每一层神经元的逻辑运算，将结果输入至最后一层的激活函数，最后得到输出output。
2.1卷积层 卷积核相当于一个滑动窗口，示意图中３x３大小的卷积核依次划过６x６大小的输入数据中的对应区域，并与卷积核滑过区域做矩阵点乘，将所得结果依次填入对应位置即可得到右侧４x４尺寸的卷积特征图，例如划到右上角３x３所圈区域时，将进行０x０＋１x１＋２x１＋１x１＋０x０＋１x１＋１x０＋２x０x１x１＝６的计算操作，并将得到的数值填充到卷积特征的右上角。
2.2 池化层 池化操作又称为降采样，提取网络主要特征可以在达到空间不变性的效果同时，有效地减少网络参数，因而简化网络计算复杂度，防止过拟合现象的出现。在实际操作中经常使用最大池化或平均池化两种方式，如下图所示。虽然池化操作可以有效的降低参数数量，但过度池化也会导致一些图片细节的丢失，因此在搭建网络时要根据实际情况来调整池化操作。
2.3 激活函数 激活函数大致分为两种，在卷积神经网络的发展前期，使用较为传统的饱和激活函数，主要包括sigmoid函数、tanh函数等；随着神经网络的发展，研宄者们发现了饱和激活函数的弱点，并针对其存在的潜在问题，研宄了非饱和激活函数，其主要含有ReLU函数及其函数变体
2.4 全连接层 在整个网络结构中起到“分类器”的作用，经过前面卷积层、池化层、激活函数层之后，网络己经对输入图片的原始数据进行特征提取，并将其映射到隐藏特征空间，全连接层将负责将学习到的特征从隐藏特征空间映射到样本标记空间，一般包括提取到的特征在图片上的位置信息以及特征所属类别概率等。将隐藏特征空间的信息具象化，也是图像处理当中的重要一环。
2.5 使用tensorflow中keras模块实现卷积神经网络 ​
class CNN(tf.keras.Model): def __init__(self): super().__init__() self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/516766bc0c7d1f8db147e8a24c5ac0b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f030c9b8d388c68200d32540fd642de/" rel="bookmark">
			共享wifi项目如何加盟？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		共享wifi贴项目如何加盟呢？具体的途径在哪里，费用是多少呢？今天小编就来一次性同你讲清楚。
我们先来讲一下共享wifi贴的加盟方法。 首先，找到共享wifi的官方渠道在点击右上角，根据页面上的信息填写资料。
然后，等待招商经理主动与你联系，告知你相关的加盟政策。
如果对于公司或产品有存疑，还可以去公司的现场进行实地的考察。
据了解，目前共享wifi的加盟是没有任何的代理费、加盟费、会员费、培训费的，换言之，是不收取任何的费用，唯一的费用就是购买贴纸的物料钱。
当然，具体买多少的物料也没有硬性的规定，可以根据自身的情况适当购买，最低一千元就可以进入共享wifi项目创业啦。
当然，你别看这些加盟的流程特别简单，但依然有很多的创业小伙伴在这个环节走了岔路，因为有很多的不正规品牌，表面上打着代理加盟的旗下，其实做的就是拉人头的生意，一味的收取代理者的会员费，号称几十块钱就能无限开团。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0d57a11c24b856fc63af4260f8259c6/" rel="bookmark">
			GBASE南大通用Parameter 属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL 语句或者存储过程使用的参数集合 GBASE南大通用ParameterCollection，默认是空集合。
 语法
[Visual Basic]
Public ReadOnly Property Parameters As GBaseParameterCollection
Get
[C#]
public GBaseParameterCollection Parameters { get; }
 注释
GBase ADO.NET 不支持无名参数。每个加入到集合中的参数必须有一个连接
名字。
 示例
下面的例子创建一个 GBaseCommand 并显示它的参数。要完成这些，要使用
GBaseConnection，一个 SQL SELECT 查询字符串，和一个 GBaseParameter 对象
数组。
[Visual Basic]
Public Sub CreateGBaseCommand(gsConnection As GBaseConnection,
_
gsSelectQuery As String, gsParamArray() As GBaseParameter)
Dim gsCommand As New GBaseCommand(gsSelectQuery, gsConnection)
gsCommand.CommandText = "SELECT id, name FROM gstable" _
&amp;" WHEREage=?age"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0d57a11c24b856fc63af4260f8259c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0faec23397e43b7e58867838e34cfeb0/" rel="bookmark">
			如何保护linux服务器远程使用的安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器安全是一个非常敏感的问题，因服务器远程入侵导致数据丢失的安全问题频频出现，一旦服务器入侵就会对个人和企业造成巨大的损失。因此，在日常使用服务器的时候，我们需要采取一些安全措施来保障服务器的安全性。
目前服务器系统使用到比较多的就是Linux，大多数服务器都在 Linux 基础架构上运行，而我们远程时候，多数也是会使用默认设置的 SSH 连接来连接到远程服务器。但是，不安全的默认配置是会带来一些安全风险。今天我们就来分享一些方案可以保护Linux服务器远程连接的安全。
在 Linux 上保护 SSH 服务器连接安全的几种方法：
1、禁用 root 用户登录：关闭 root 用户的服务器访问是一种防御策略，可以防止攻击者实现入侵系统的目标。为此，可以创建一个具有 root 权限的新用户来代替 root 用户进行登录。
例如创建exampleroot的用户：
useradd -m exampleroot passwd exampleroot usermod -aG sudo exampleroot 在用户创建过程之后，修改 SSH 的配置文件 /etc/ssh/sshd_config，在其中加上 PermitRootLogin no 配置项。
2、使用 SSH 密钥连接：连接到服务器的最安全方法之一是使用 SSH 密钥。使用 SSH 密钥时，无需密码即可访问服务器。另外，可以通过更改 sshd_config 文件中与密码相关的参数来完全关闭对服务器的密码访问。
在本地计算机上生成 SSH 密钥对。可以使用 ssh-keygen 命令来生成，选择默认选项即可。创建 SSH 密钥时，有两个密钥：Public和Private。公钥将上传到您要连接的服务器，而私钥则存储在您将用来建立连接的计算机上。
需要注意的是，使用 SSH 密钥连接需要在本地计算机和远程服务器上都进行相应的配置。此外，如果需要配置多个用户使用 SSH 密钥连接，可以创建一个包含多个公钥的 authorized_keys 文件，并将其放置在远程服务器的指定目录下。
3、限制登录/访问尝试：默认情况下，可以根据需要尝试多次输入密码来访问服务器。但是，攻击者可以利用此漏洞对服务器进行暴力破解。通过指定允许的密码尝试次数，可以在尝试一定次数后自动终止 SSH 连接。为此，请更改 sshd_config 文件中的 MaxAuthTries 值。
4、默认使用 SSH 版本 2：SSH 的第二个版本发布是因为第一个版本中存在许多漏洞。默认情况下，可以通过将 Protocol 参数添加到 sshd_config 文件来启用服务器使用第二个版本。这样，未来的所有连接都将使用第二个版本的 SSH。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0faec23397e43b7e58867838e34cfeb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e5312dc93745cdf18a0d2f2afdf15e/" rel="bookmark">
			字符串-＞算法实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		综述 反转字符串：leetcode344
反转字符串 II：leetcode541
替换数字：非leetcode原题
反转字符串中的单词：leetcode151
右旋字符串：非leetcode原题
找出字符串中第一个匹配项的下标：leetcode28
重复的子字符串：leetcode459
引言 刷题总结 反转字符串 题目 leetcode344
题解 简单题不多说
class Solution { public: void reverseString(vector&lt;char&gt;&amp; s) { int i = 0; int j = s.size() - 1; while (i &lt; j) { std::swap(s[i++], s[j--]); } } }; 反转字符串 II 题目 leetcode541
题解 每 2k 个字符串就反转前 k 个字符串
循环中记得处理最后的边界，即“最后剩余的字符串的处理”
这里面有个小技巧，如果自己实现 reverse 函数的话，尽量保持和库函数一样的“左闭右开”，这样方便，而且像使用库函数一样，不容易出错
class Solution { public: string reverseStr(string s, int k) { int index = 0; //每2k个反转前k个字符串 while (index &lt; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5e5312dc93745cdf18a0d2f2afdf15e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f68f08d0421b5278dadc83caf4d8db4b/" rel="bookmark">
			sql报错 Aggregate expression is illegal in WHERE clause
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 select f4,... from tb1 where f1=1 and f2=2 and max(f3)=5 group by f4; -- 报错 Aggregate expression is illegal in WHERE clause select f4,... from tb1 where f1=1 and f2=2 group by f4 having max(f3)=5; -- success 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df07abba9e4f72758d46c3f2a0fb4526/" rel="bookmark">
			电商平台革新：彭云物联API连接与营销集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物联网技术助力电商平台无缝连接 彭云物联是一个革命性的服务，它利用先进的物联网技术，帮助电商平台实现与各种物联网设备的无缝连接。通过这种连接，电商企业可以在不进行任何API开发的情况下，远程实时地监控仓库、物流中心等异地环境参数，以此优化库存管理和物流操作。
无代码开发集成提升客服效率 在客服系统方面，彭云物联也显示出其强大的集成能力。无代码开发的特点让客服团队能够快速地接入物联网技术，而无需担心技术障碍或是开发成本。
快速授权流程加速业务部署 彭云物联的授权流程非常简单。用户只需联系彭云物联的客服或商务人员获取账号信息，包括【userid】和【key】，然后填入集简云平台即可完成授权，这个简化的流程极大地加速了业务部署的速度。
利用数据驱动电商决策 彭云物联不仅仅是一个连接和集成工具，它更是一个强大的数据平台。每当有设备数据变化，彭云物联都能自动查询设备信息，并将数据传回系统。电商企业可以利用这些实时数据，对市场需求、库存状况、物流效率等重要指标进行分析，从而做出更明智的决策。
优化体验，推动业务增长 总结来说，彭云物联为电商和客服系统提供了一个高效、易用的解决方案，它通过无代码开发的方式，实现了设备的快速连接和集成。这种技术优势不仅改善了后端操作的效率，而且在前端也为消费者提供了更好的购物体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0ba94261d55a67a05d954708897d9cc/" rel="bookmark">
			Spring注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍：
1、概念：注解（Annotation），也叫 元数据 （metadata）。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。
Java 语言中的类、 构造器、 方法、成员变量、局部变量、方法参数等都可以被注解进行标记，然后做特殊的处理。
2、作用：
（1）生成文档：java最早的提供的注解
（2）编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】
（3）代码分析：通过代码里标识的元数据对代码进行分析【使用反射】
（4）替代配置文件：跟踪代码依赖性，实现替代配置文件功能，比较常见的是spring 2.5 开始的基于注解配置,作用就是减少配置。
3、注解失效/不成功的场景
（1）注解加在private上，编译既不报错也不会有任何提示，默认忽略，实际功能却不会生效。原因在于，spring AOP无法实现或者继承private方法。Spring使用AOP代理代理有2种，分别是基于接口和基于类；而这2种代理机制均不能实现或继承private方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97f4f67071939df289041f96e11cdfcb/" rel="bookmark">
			MentionElement是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人github MentionElement 通常指的是在富文本编辑器或文本输入框中实现的一个功能，它允许用户通过输入特定的字符（如@）来提及或引用其他用户、话题、页面等。这个功能在社交媒体平台、论坛、聊天应用和一些文档编辑工具中非常常见。
在编程上下文中，MentionElement 可能是一个React组件或者其他框架的组件，它封装了提及功能的实现。例如，在使用React和某个富文本编辑库（如Slate、Draft.js等）时，你可能会创建一个MentionElement组件来渲染提及的用户或话题，并处理与之相关的交互逻辑。
这个组件可能会处理以下功能：
监听用户输入，当用户键入特定字符（如@）时激活提及功能。显示一个下拉列表供用户选择他们想要提及的对象。在用户选择一个提及对象后，将其插入到文本中，并以特定的格式显示。允许用户与提及的对象进行交互，例如点击提及的对象可以导航到用户的个人资料页面。 这里是一个简化的MentionElement组件的示例，它可能是在使用Slate编辑器时的一部分：
import React from 'react'; const MentionElement = ({ attributes, children, element }) =&gt; { return ( &lt;span {...attributes} contentEditable={false} className="mention"&gt; @{element.username} {children} &lt;/span&gt; ); }; export default MentionElement; 在这个例子中，MentionElement 是一个简单的React组件，它渲染一个span元素，该元素包含了提及的用户名，并且通过className属性应用了特定的样式。attributes属性包含了Slate编辑器需要的属性，以确保正确的渲染和编辑器状态的更新。children属性包含了Slate编辑器传递的子元素，这对于嵌套的编辑器节点是必要的。
请注意，这只是一个示例，实际的MentionElement组件可能会更复杂，并且需要与你的编辑器库和数据模型紧密集成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22cdf98b348905cc3e820b34c0aa450d/" rel="bookmark">
			用可视化案例讲Rust编程2. 编码的核心组成：函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从第一天学习编程，可能大家就听说这样的组成公式：
程序=算法+数据结构
——该公式出自著名计算机科学家沃思(Nikiklaus Wirth)
实际上，程序除了以上两个主要要素之外，还应当采用结构化程序设计方法进行程序设计，并且用某一种计算机语言表示。因此，算法、数据结构、程序设计方法和语言工具4个方面是一个程序设计人员所应具备的知识。
所以，要学习组成程序的最重要的具现化方式，就是计算机语言。计算机语言则以是语句 + 表达式为原子所组成逻辑集合体；最基础的逻辑集合体，就是函数。
官方的说法：
计算机是一个固定的一个程序段，或称其为一个子程序，它在可以实现固定运算功能的同时，还带有一个入口和一个出口，所谓的入口，就是函数所带的各个参数，我们可以通过这个入口，把函数的参数值代入子程序，供计算机处理；所谓出口，就是指函数的函数值，在计算机求得之后，由此口带回给调用它的程序。
所以，我们在学习Rust的时候，不要被哪些天花乱坠的特性、泛型、生命周期给弄傻，要学习，先去翻函数，学习怎么写函数，一个函数解决一个问题。
同样，去读大神代码的时候，也别一爬起来就去读整体架构设计，安心去读他最底层的实现，如果读不懂，可以借助GPT一类的工具，让它给你讲讲，如下所示：
效果那是极好的。
下面针对我们上篇文章那个可视化的需求，我们来写个简单函数来实现一下：
需求：读取一个shapefile文件，把这个shapefile文件中的几何信息绘制到地图上。
初学版设计思路：
函数名：draw_shp输入参数：shapefile的路径输出：直接显示地图。需要用的到的包： shapefile：读取shp文件plotly：绘图geo_types：序列化几何对象 编码实现设计： ###在Cargo.toml文件里面，导入需要的包： //Cargo.toml //后面的features特性，暂时不用去管，这是一种Rust特有的编译特性 plotly = { version = "0.8.4", features = ["kaleido"] } shapefile = {version = "0.5.0", features = ["geo-types"]} geo-types = "0.7.12" 读取一个shapefile，并且把几何信息给获取出来。 在Rust中，可以通过shapefile包来读取shapefile，实现如下：
let shp = shapefile::read_as::&lt;_, shapefile::Polygon, shapefile::dbase::Record&gt;( "./data/shp/北京行政区划.shp", ).expect(&amp;format!("Could not open polygon-shapefile: './data/shp/北京行政区划.shp'")); 接下去，需要把里面的geometry信息给取出来：
//定义一个集合，通过文件迭代器，把geometry部分转换成polygon，然后加入到这个几何里面去。 let mut polygons:Vec&lt;Polygon&gt; = Vec::new(); for (polygon, polygon_record) in shp { let geo_mpolygon: geo_types::MultiPolygon&lt;f64&gt; = polygon.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22cdf98b348905cc3e820b34c0aa450d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b3b23a8a9687e670579d20d6a267b6/" rel="bookmark">
			【操作系统进程树变化】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统从启动到运行某个进程，进程树的变化过程如下：
启动过程：操作系统启动时，首先创建一个根进程（通常称为init或systemd进程，PID为1），该进程负责启动其他系统服务和守护进程。随着各种服务和守护进程的启动，进程树逐渐扩展。
用户登录：当用户登录系统时，操作系统会创建一个新的进程（如login或sshd进程），负责处理用户的登录请求。登录成功后，系统会创建一个shell进程（如bash或zsh），并将其与用户的终端关联。
此时进程树的简化形式如下：
init (PID 1) ├── sshd │ ├── sshd (用户登录) │ │ └── bash (用户shell) ├── other services and daemons... 用户通过SSH连接：当用户通过SSH连接到系统时，sshd服务会创建一个新的子进程来处理该连接。在用户成功登录后，系统会为该用户创建一个新的shell进程。
用户运行木马程序：用户在shell中执行木马程序，操作系统会创建一个新的进程来运行该程序。这个进程成为shell进程的子进程。
进程树变化如下：
init (PID 1) ├── sshd │ ├── sshd (用户登录) │ │ └── bash (用户shell) │ │ └── trojan (木马程序) ├── other services and daemons... 木马程序发起外联：木马程序在运行过程中可能会创建新的子进程或线程来发起外部连接。这些子进程或线程也会成为进程树的一部分。 进程树变化如下：
init (PID 1) ├── sshd │ ├── sshd (用户登录) │ │ └── bash (用户shell) │ │ └── trojan (木马程序) │ │ ├── trojan_child1 (子进程1) │ │ ├── trojan_child2 (子进程2) │ │ └── .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51b3b23a8a9687e670579d20d6a267b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f83c4467b7096c18e582522b149d531/" rel="bookmark">
			Aloha 机械臂的学习记录3——AWE：Pycharm运行代码记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前的博客创作了三偏关于Aloha_AWE的liunx终端指令运行代码的示例:
Aloha 机械臂的学习记录——AWE：Bimanual Simulation Suite: https://blog.csdn.net/qq_54900679/article/details/134889183?spm=1001.2014.3001.5502
Aloha 机械臂的学习记录1——AWE：Bimanual Simulation Suite（Save waypoints）: https://blog.csdn.net/qq_54900679/article/details/134890424?spm=1001.2014.3001.5502
Aloha 机械臂的学习记录2——AWE：AWE + ACT: Aloha 机械臂的学习记录2——AWE：AWE + ACT_aloha机械臂-CSDN博客
今天在Pycharm编辑器中运行代码发现了一些报错，所以撰写此篇博客来记录：
以TASK = sim_insertion_human为例子：
首先将default="data/act/sim_insertion_human"取消注释（在act_waypoint.py文件中）
然后配置conda的awe_venv环境以及参数和环境变量
首先配置参数，我们以运行act_waypoint.py文件为例子，对应Visualize waypoints
Liunx终端的指令为：
python example/act_waypoint.py --dataset=data/act/sim_insertion_human --err_threshold=0.01 --plot_3d --end_idx=0
在liunx的终端运行上面的指令是没有问题的，但是！在Pycharm编辑器中运行时会报错。
---------------------------------------------------------------------------------------------------------------------------------
Pycharm编辑器中参数（Parameters）的配置应该如下：
--dataset=/home/hjx/hjx_file/aloha/awe/data/act/sim_insertion_human --err_threshold=0.01 --plot_3d --end_idx=0
注意：其中/home/hjx/hjx_file/aloha/awe/data/act/sim_insertion_human是dataset的绝对路径
--err_threshold=0.01 --plot_3d --end_idx=0 无需更改
需要寻找的是sim_insertion_human文件的绝对路径，如下图所示：
在Pycharm编辑器中右击并点击Copy path...,第一个Absolute path就是绝对路径，点击复制
然后是环境变量（Environment variables）的配置：
这里是个大坑！！！
Liunx终端运行时会执行.bashrc文件，我们执行一次程序注意到如下报错：
意思是缺少环境变量，需要正确设置 LD_LIBRARY_PATH 环境变量，以便找到Mujoco的库文件
但是，PyCharm的环境变量设置：LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/hjx/.mujoco/mujoco210/bin与LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/nvidia重名（LD_LIBRARY_PATH依次添加的话会覆盖其中一个，导致变量不全，如何解决？）
其中很简单，只需要这个配置即可：
LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/nvidia:/home/hjx/.mujoco/mujoco210/bin
请注意，冒号 : 用于分隔不同的路径，而不需要额外的空格。这个设置将在PyCharm中设置 LD_LIBRARY_PATH 环境变量，包括系统路径 /usr/lib/nvidia 和Mujoco路径 /home/hjx/.mujoco/mujoco210/bin。确保在保存设置后重新启动PyCharm，以确保环境变量生效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f83c4467b7096c18e582522b149d531/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4881cc31c3f2db829d116b6d2cd7bdb9/" rel="bookmark">
			【办公技巧】Word中如何对齐选择题中的ABCD选项？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用word文件制作试卷，如何将ABCD选项全部设置对齐？除了一直按空格或者Tab键以外，还有其他方法吗？今天分享如何将ABCD选项对齐。
首先，我们打开【替换和查找】，在查找内容输入空格，然后点击全部替换
然后我们再打开【替换和查找】功能，这次我们在查找内容输入[ABCD]，然后在替换输入^t^g ,需要注意，g后面有一个空格。
然后点击【更多】，勾选上【使用通配符】然后全部替换
全部替换完成之后，我们选中全部文本，然后打开【段落】功能，打开制表位功能，然后我们在制表位位置分别设置2字符、12字符、22字符、32字符，点击【确定】即可完成设置
制作好的文件，防止他人随意修改，可以设置限制编辑，如果遇到了无法编辑的文件，也有可能是限制编辑导致的，我们需要输入密码进行取消。忘记密码可以使用工具帮助我们取消，比如超人Word解密助手，解除限制功能支持无密码取消word文件限制编辑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b966a44641ac3a3dd8b462efa9e73e7d/" rel="bookmark">
			【MySQL】MySQL数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.数据类型分类2.数值类型2.1tinyint类型2.2bit类型2.3小数类型2.3.1float2.3.2decimal 3.字符串类型3.1char3.2varchar3.3char和varchar比较 4.日期和时间类型5.enum和set 1.数据类型分类 在MySQL中数据分为一下几类：
2.数值类型 2.1tinyint类型 数值越界测试：
mysql&gt; create table tt1(num tinyint); Query OK, 0 rows affected (0.02 sec) mysql&gt; insert into tt1 values(1); Query OK, 1 row affected (0.00 sec) mysql&gt; insert into tt1 values(128); -- 越界插入，报错 ERROR 1264 (22003): Out of range value for column 'num' at row 1 mysql&gt; select * from tt1; +------+ | num | +------+ | 1 | +------+ 1 row in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b966a44641ac3a3dd8b462efa9e73e7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d0b6b2e9e953a60446d5e74be2dd455/" rel="bookmark">
			cfa一级考生复习经验分享系列（十九）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关于考试时间
机考一共180题，分上下两场，中间可以休息30分钟，我是直接一口气做完的，如果觉得要休息的可以考完上半场跟监考老师示意一下，也可以不休息，不过好像连续做了多长时间会强制休息。
关于考题分布
上半场题目是道德、数量、财报、经济学，下半场是财管、固收、权益、组合、衍生品和另类。除了道德是没有打乱的，其他题目都是全部打乱的，需要在不同科目间切换，特别是下半场有6门，往往是轮流着来。关于考试难度
整体难度低于mock题和jc的百题，与原版书课后题有些类似，定性考点居多，计算题偏少，而且计算难度也不大，只要熟记公式即可，下面针对每个科目分别来说。 具体科目介绍
1.ethics：道德题整体难度一般，机考题的题干普遍不长。分成两类题，一类是直接问哪项是最符合定义或准则中的具体内容的，另一类就是案例题。机考的案例题考点主要还是7大准则，需要熟记条款，而且违规的点也较为明显。另外就是GIPS，主要也是以概念考察和如何遵守gips的一些情形为主。
2.quntitive：数量一是重点掌握各种年金的计算，先付后付的转换，养老金、教育金的计算，基本和原版书课后题类似。二是，概率分布、抽样估计和假设检验，要重点掌握几种分布类型，各种统计量的计算公式（均值，方差，协方差，变异系数，相关系数，标准误等），假设检验的步骤（如何设假设，计算统计量，确定alpha值，记住68,90,95,99时的k值是多少。三是其他的概率论的知识较为简单，乘法加法原则、全概率公式、贝叶斯公式等记住即可。
3.economics：经济学分三部分，微观、宏观、国际贸易和汇率。微观部分重点掌握需求曲线和需求函数，重点记住需求曲线的图像是反（inverse）需求函数，故需求曲线斜率是需求函数鞋率的倒数。其次是知道利润最大化是边际成本等于边际收入，还有消费者剩余的计算，盈亏平衡点和停业点的掌握，最后是厂商竞争模型的特点。宏观部分重点掌握gdp的计算，收入法和支出法，总需求和总供给曲线的变动因素，知道什么时候左移什么时候右移，货币和财政政策往往会和总供给和需求结合考察，另外一个小的点就是宏观利率等于经济增长率加上长期通胀率，而不是短期，计算出宏观利率后和央行利率比较，看是宽松还是紧缩，最后是各种学派的理论和周期理论，考察不多可了解特点。国际贸易和汇率，需要掌握比较优势的计算，关税政策下贸易状况，国际收支的经常账户和资本账户，可结合gdp计算的s-m=g-i+x-m理解，汇率则掌握各种标价法，远期汇率得计算公式。
4.equity：权益章节重要考察市场交易指令，行业分析，指数的计算方法（市值加权、等权法、基本面法等),估值方法上则掌握优先股估值，股利增长模型，这个考到了高登模型和一道自由现金流折现法计算，和估值倍数法。
5.fixed income：固收内容较多，我主要遇到的计算类的题目涉及债券估值，利用ytm较多，以及收益率计算比较，各类久期和凸度计算，重点掌握有效修正久期和有效凸度。建议个人整理所有的计算公式，然后考前重点记忆。其他非计算类题目主要为债券的分类，债券市场内容以及abs章节内容，cmbs、rmbs以及cdo，偿还顺序和abs分层情况的考察
6.portfolio ：组合重点掌握三个资本市场理论，需要理解掌握，资本配置线、效用无差异曲线、资本市场线以及证券市场线，系统风险和非系统风险等。计算上重点掌握夏普比率，m平方alpha，tr比率和jason alpha，以及capm模型的计算和beta值计算。
7.corporate finance：重点考了加权平均资本成本的计算，npv、irr的计算，营运资本的各种比率计算等，主要掌握所有计算公式。特别注意一个应收账款管理中的2/10，30的一个报价法，即一个30天的应收款，如果在第十天还款则给予2%的折扣
8.financial statement：财报分析是一级里内容多且难度较大章节，注意考试开头会提示默认用的是ifrs准则，只有题目中提到是用us gaap才是在gaap下考虑，主要掌握三张报表，特别是cf表，要会计算间接法下的cfo，以及fcff的计算，财务比率分析中要掌握各类比率，考察点较细，特别是杜邦分析法要掌握五分法，本次考题有涉及。最后是长期资产主要考察折旧计算和减值，存货的lifo和fifo的转换，长期负债下的摊销，租赁下经营租赁和融资租赁的差别，递延所得税负债和资产的确认和计算等。财报科目需要记住两种准则下的差异点，会特别考察。
9.derivation：衍生品章节则考察，概念为主，掌握期货与远期的差异，以及在不同利率环境下选择期货还是远期，还有期货期权定价的公式，该章节主要还是定性为主，定量计算题几乎没有。
10.alternative:另类投资则重点掌握对冲基金和房地产投资，对冲基金主要掌握管理费的计算方法，包括根据管理规模收取的管理费和超额收益分成，重点注意超额收益在亏损之后实现盈利的年份，需要和亏损前的年份比较计算超额收益。
以上为cfa一级机考的一些心得，个人认为机考题整体难度不算太大，但是需要记忆的知识点较多，需要全面掌握，可在考前强化各类计算公式的记忆，效果较好。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01654c5bb1979ad78081b6f73256229a/" rel="bookmark">
			cfa一级考生复习经验分享系列（十八）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 考点回忆：其实机考大家的题目都不大一样，是抽题的形式，在这里只罗列一些我遇到的印象比较深，同时大家容易忽略或犯错的点。道德考了很多GIPS；经济学考了费雪方程、货币中性、价格歧视、需求的收入弹性计算；数量考了相关系数的检验；财报总体还好，比较有迷惑是在算存货减值与长期资产减值的过程中没有告诉你用IFRS还是US.GAAP，但是数据都给了你，你用两种准则都可以算，关键是算出来答案还是不同的，而且都出现在了选项里，建议还是用IFRS为主，考了一道融资租赁判断CFF高估还是低估的问题；公司金融考了ESG中full integration的定义；组合管理考了机器学习还有技术指标的内容共2题；权益投资考了风格指数style index的内容；固定收益考了Debt-rating approach的计算，计算flat price，计算有效久期；另类考了market neutral策略的描述；衍生品考文字概念比较多，比如问writer of put option的头寸方向等。复习建议：
1.课程跟的都是GD网课，除了道德的正课，其他正课看完一次，道德部分听单老师喜马拉雅的音频，然后看Chen的极速串讲课程，没有做原版书课后题，只做了JC百题和GD题库的题目，以及GD的两套押题后参加考试。
2.因为机考抽题范围是很广的。如果复习的时间允许，建议大家一定要把手头的正课认真看一遍，平时就做原版书课后题以及看课件里的英文表述，不建议用中文教材，因为一级的考试题干普遍比较短，许多的定义是直接从课件中的原话截取出来作为考题。 比如在权益部分，各大网课对于股票指数的分类基本上有以下几种，例如Broad market indices, Multi-market indices, Sector indices, Style indices，其中对于最后一个风格指数的原话定义是Style indices represent securities classified according to market capitalization, value, growth, etc，考试会直接问style indices是根据哪种方式classified securities，直接选择market capitalization，同理公司金融关于Full integration的原话是，Full integration into individual stock valuation is explicit inclusion of ESG factors into traditional financial analysis of individual stocks，考试会去掉前面的名词，直接问哪一种方式is explicit inclusion of ESG factors into traditional financial analysis of individual stocks，所以熟悉的同学看到后面的explicit inclusion等关键词就能选出Full integration，干扰选项是其他的ESG投资方式，
刷题的个人推荐是原版书课后题＞金程百题＞高顿题库＞mock，原版书课后题如果时间不够，优先建议刷金程百题基础篇并看讲解视频。以上就是我对8月考季CFA一级的感悟与总结，希望能对屏幕前的你有所启发，基础的概念至关重要，忙于刷题的同学千万不能忽略基础概念的学习。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b88f4923f97cbbdd1fd6b7d272c73511/" rel="bookmark">
			【Kafka-3.x-教程】-【七】Kafka 生产调优、Kafka 压力测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Kafka-3.x-教程】专栏：
【Kafka-3.x-教程】-【一】Kafka 概述、Kafka 快速入门
【Kafka-3.x-教程】-【二】Kafka-生产者-Producer
【Kafka-3.x-教程】-【三】Kafka-Broker、Kafka-Kraft
【Kafka-3.x-教程】-【四】Kafka-消费者-Consumer
【Kafka-3.x-教程】-【五】Kafka-监控-Eagle
【Kafka-3.x-教程】-【六】Kafka 外部系统集成 【Flume、Flink、SpringBoot、Spark】
【Kafka-3.x-教程】-【七】Kafka 生产调优、Kafka 压力测试
【Kafka-3.x-教程】-【七】Kafka 生产调优、Kafka 压力测试 1）Kafka 硬件配置选择1.1.场景说明1.2.服务器台数选择1.3.磁盘选择1.4.内存选择1.5.CPU 选择1.6.网络选择 2）Kafka 生产者2.1.Kafka 生产者核心参数配置2.2.生产者如何提高吞吐量2.3.数据可靠性2.4.数据去重2.5.数据有序2.6.数据乱序 3）Kafka Broker3.1.Broker 核心参数配置3.2.服役新节点/退役旧节点3.3.增加分区3.4.增加副本因子3.5.手动调整分区副本存储3.6.Leader Partition 负载平衡3.7.自动创建主题 4）Kafka 消费者4.1.Kafka 消费者核心参数配置4.2.消费者再平衡4.3.指定 Offset 消费4.4.指定时间消费4.5.消费者事务4.6.消费者如何提高吞吐量 5）Kafka 总体5.1.如何提升吞吐量5.2.数据精准一次5.3.合理设置分区数5.4.单条日志大于1m5.5.服务器挂了 6）Kafka 压测6.1.Kafka Producer 压力测试6.2.Kafka Consumer 压力测试 1）Kafka 硬件配置选择 1.1.场景说明 100 万日活，每人每天 100 条日志，每天总共的日志条数是 100 万 * 100 条 = 1 亿条。
1 亿/24 小时/60 分/60 秒 = 1150 条/每秒钟。
每条日志大小：0.5k - 2k（取 1k）。
1150 条/每秒钟 * 1k ≈ 1m/s 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b88f4923f97cbbdd1fd6b7d272c73511/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c1339592245ed53f810fed96eb4ec9e/" rel="bookmark">
			【Kafka-3.x-教程】-【五】Kafka-监控-Eagle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Kafka-3.x-教程】专栏：
【Kafka-3.x-教程】-【一】Kafka 概述、Kafka 快速入门
【Kafka-3.x-教程】-【二】Kafka-生产者-Producer
【Kafka-3.x-教程】-【三】Kafka-Broker、Kafka-Kraft
【Kafka-3.x-教程】-【四】Kafka-消费者-Consumer
【Kafka-3.x-教程】-【五】Kafka-监控-Eagle
【Kafka-3.x-教程】-【六】Kafka 外部系统集成 【Flume、Flink、SpringBoot、Spark】
【Kafka-3.x-教程】-【七】Kafka 生产调优、Kafka 压力测试
【Kafka-3.x-教程】-【五】-Kafka-监控-Eagle 1）MySQL 环境准备2）Kafka 环境准备3）Kafka-Eagle 安装4）Kafka-Eagle 页面操作 Kafka-Eagle 框架可以监控 Kafka 集群的整体运行情况，在生产环境中经常使用。
1）MySQL 环境准备 Kafka-Eagle 的安装依赖于 MySQL，MySQL 主要用来存储可视化展示的数据。如果集群中之前安装过 MySQL 可以跨过该步。
2）Kafka 环境准备 1、关闭 Kafka 集群
kf.sh stop 2、修改/opt/module/kafka/bin/kafka-server-start.sh 命令中
vim bin/kafka-server-start.sh #修改如下参数值： if [ "x$KAFKA_HEAP_OPTS" = "x" ]; then export KAFKA_HEAP_OPTS="-Xmx1G -Xms1G" fi #为 if [ "x$KAFKA_HEAP_OPTS" = "x" ]; then export KAFKA_HEAP_OPTS="-server -Xms2G -Xmx2G - XX:PermSize=128m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 - XX:ParallelGCThreads=8 -XX:ConcGCThreads=5 - XX:InitiatingHeapOccupancyPercent=70"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c1339592245ed53f810fed96eb4ec9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63a431b2d88abb5933d79aa354aff769/" rel="bookmark">
			echarts的dispatchAction
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		触发图表行为，通过dispatchAction触发。例如图例开关legendToggleSelect, 数据区域缩放dataZoom，显示提示框showTip等等。
官网：echarts
(在 ECharts 中主要通过 on 方法添加事件处理函数。)
events：
ECharts 中的事件分为两种，一种是鼠标事件，在鼠标点击某个图形上会触发，还有一种是调用 dispatchAction 后触发的事件。
action：
ECharts 中支持的图表行为，通过 dispatchAction 触发。
1.highlight 高亮指定的数据图形 dispatchAction({ type: 'highlight', // 可选，系列 index，可以是一个数组指定多个系列 seriesIndex?: number|Array, // 可选，系列名称，可以是一个数组指定多个系列 seriesName?: string|Array, // 可选，数据的 index dataIndex?: number, // 可选，数据的 名称 name?: string }) 2.downplay 取消高亮指定的数据图形 dispatchAction({ type: 'downplay', // 可选，系列 index，可以是一个数组指定多个系列 seriesIndex?: number|Array, // 可选，系列名称，可以是一个数组指定多个系列 seriesName?: string|Array, // 可选，数据的 index dataIndex?: number, // 可选，数据的 名称 name?: string }) 3.图例相关的行为，必须引入图例组件之后才能使用 1）legendSelect（选中图例） dispatchAction({ type: 'legendSelect', // 图例名称 name: string }) 2）legendUnSelect（取消选中图例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63a431b2d88abb5933d79aa354aff769/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88be951c245130ddd7a12e84f690c472/" rel="bookmark">
			【Kafka-3.x-教程】-【一】Kafka 概述、Kafka 快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Kafka-3.x-教程】专栏：
【Kafka-3.x-教程】-【一】Kafka 概述、Kafka 快速入门
【Kafka-3.x-教程】-【二】Kafka-生产者-Producer
【Kafka-3.x-教程】-【三】Kafka-Broker、Kafka-Kraft
【Kafka-3.x-教程】-【四】Kafka-消费者-Consumer
【Kafka-3.x-教程】-【五】Kafka-监控-Eagle
【Kafka-3.x-教程】-【六】Kafka 外部系统集成 【Flume、Flink、SpringBoot、Spark】
【Kafka-3.x-教程】-【七】Kafka 生产调优、Kafka 压力测试
【Kafka-3.x-教程】-【一】Kafka 概述、Kafka 快速入门 1）定义2）应用场景2.1.削峰2.2.解耦2.3.异步通信 3）两种模式4）基础架构5）安装部署5.1.集群规划5.2.集群部署5.3.集群启停脚本 6）Kafka 命令行操作6.1.主题命令行操作6.2.生产者命令行操作6.3.消费者命令行操作 1）定义 试想这样一个场景，某宝或某东购物平台，上游通过 Flume 采集相关日志到 Hadoop 集群中，在平时流量小的时候，Hadoop 的写入速度在 100M/s，Flume 采集日志的速度也在 100M/s，这样下游的 Hadoop 上传速度可以和上游的 Flume 采集速度相匹配，没有问题。
那么现在到了促销季，假如双十一进行大促销，那么 Flume 采集到的数据量远超过平时的 100M/s（比如达到 200M/s），而下游的 Hadoop 速度的极限已经是 100M/s 了，此时如果不解决这个问题就会导致上游数据量无限度的堆积，导致日志服务器爆掉。
此时 Kafka 出现了，试想，如果将 Flume 采集到的数据先放入一个中间栈做保存，然后让 Hadoop 慢慢消化海量数据，那么就可以解决上述的问题。
Kafka 是一个分布式的基于发布/订阅模式的消息队列（Message Queue），主要应用于大数据实时处理领域。
目前企业中比较常见的消息队列产品主要有 Kafka、ActiveMQ 、RabbitMQ 、RocketMQ 等。
在大数据场景主要采用 Kafka 作为消息队列。在 JavaEE 开发中主要采用 ActiveMQ、RabbitMQ、RocketMQ。
2）应用场景 2.1.削峰 缓冲/消峰：有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。
2.2.解耦 解耦：允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88be951c245130ddd7a12e84f690c472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31d87ac8f64524b5269d0aa2f9dcaaab/" rel="bookmark">
			【从零开始学习微服务 | 第一篇】什么是微服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
架构风格： 单体架构：
分布式架构：
微服务：
总结：
前言： 在当今快速发展的软件开发领域，构建大型应用程序已经成为一项巨大的挑战。传统的单体应用架构往往难以满足快速变化的业务需求和不断增长的用户规模。这就引出了微服务架构：一种以服务为中心的解决方案，旨在解决这些问题并提供更灵活、可扩展的应用程序设计。
架构风格： 单体架构： 在我们以前开发项目的时候，会把所有的功能都集成在一个项目中开发，比如我们之前写的苍穹外卖，我们直接在整个项目内完成了所有的功能。
【苍穹外卖】_我是一盘牛肉的博客-CSDN博客
虽然单体项目的架构简单，部署成本低。但是在大型项目中，我们把所有的功能都内聚到一个项目的时候，就会造成代码的耦合程度高。而如果我们能够把这一个个功能独立的拆分为一个项目（服务），在我其他项目需要使用的时候，直接调用这个服务不就好了？其实这就是分布式架构的思想。
分布式架构： 分布式架构将系统的不同部分分散到多个独立的计算机节点上，并通过网络连接这些节点进行通信和协作。在分布式架构中，不同的计算节点可以执行不同的任务，彼此交互以实现共同的目标。
常见的分布式架构包括微服务架构、SOA架构和RPC架构等。这些架构都是基于分布式系统设计的，可以帮助开发人员更好地管理和维护分布式系统。
通过分布式架构的设计，我们降低了各个服务之间的耦合度，那么我们的开发人员就可以专注的负责某一个服务模块的开发。而分布式架构项目的问题也很多，例如服务拆分的粒度，各个服务之间如何联系。
也就是说，虽然分布式架构的思路是好的，但分布式架构的设计却是一个难点，如何设计出好的分布式框架呢？
微服务： 微服务是一种经过良好架构设计的分布式架构方案。
微服务架构的特点包括：
单一职责：每个微服务只关注一个特定的业务功能，它们之间相互解耦。
分布式部署：每个微服务都可以独立部署和升级，这样可以提高系统的灵活性和可伸缩性。
弹性和容错性：由于微服务是独立运行的，当某个微服务发生故障时，不会影响整个系统的运行。
独立团队开发：每个微服务可以由一个小团队独立开发和维护，使得团队间的沟通和协作更加简单。
技术多样性：不同的微服务可以使用不同的技术栈，选择最适合的工具来实现自己的功能。
换句话来说，微服务其实就是一套设计成熟的分布式架构设计方案。 而这种架构方案当然需要各种技术框架来落地支持，在国内比较知名的就是Spring Cloud和Dubbo。
特性DubboSpring CloudSpring Cloud Alibaba开发语言JavaJavaJava服务注册与发现ZooKeeper、Nacos等Eureka、Consul、ZooKeeper等Nacos、Consul等服务调用方式RPC（远程过程调用）REST（Representational State Transfer）REST服务网关无Zuul、Spring Cloud GatewaySpring Cloud Gateway配置中心无Spring Cloud ConfigNacos Config负载均衡客户端负载均衡客户端负载均衡（Ribbon）、服务端负载均衡（Spring Cloud LoadBalancer）Ribbon、Spring Cloud LoadBalancer断路器无Hystrix、Resilience4jSentinel分布式追踪无Spring Cloud Sleuth、ZipkinAlibaba Cloud SLS（日志服务）消息总线无Spring Cloud BusRocketMQ服务熔断无SentinelSentinel 总的来说，Dubbo是一个RPC框架，主要用于服务之间的远程调用。Spring Cloud是基于Spring Boot的微服务框架，提供了更丰富的组件和工具，支持服务注册与发现、负载均衡、断路器、配置中心等功能。Spring Cloud Alibaba是Spring Cloud的扩展，集成了阿里巴巴的一些开源组件，如Nacos、Sentinel、RocketMQ等，用于更好地支持云原生应用开发。 最后，让我们在介绍一下微服务的核心组件：
服务注册与发现组件：
服务注册：微服务架构中，每个服务都需要向一个注册中心注册自己的地址和元数据。注册中心充当了服务的目录，用于管理和维护服务实例的注册信息。常见的服务注册组件有Eureka、Consul、ZooKeeper和Nacos。服务发现：其他服务可以通过查询注册中心来发现并调用需要的服务。服务发现组件提供了查询接口，使得服务能够动态地获取到其他服务的地址和元数据。 负载均衡组件：
负载均衡：微服务架构中的服务通常会有多个实例运行，负载均衡组件用于将请求均匀地分发到这些实例上，以实现负载均衡和高可用性。常见的负载均衡组件有Ribbon、Spring Cloud LoadBalancer和Nginx。 网关组件：
API网关：网关作为微服务架构对外暴露的入口，负责接收和处理外部请求。它可以处理身份验证、权限控制、流量管理、协议转换等功能，并将请求转发到后端的微服务实例。常见的网关组件有Zuul、Spring Cloud Gateway和Nginx。 配置中心组件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31d87ac8f64524b5269d0aa2f9dcaaab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5267366c575301039696ead862ba39e3/" rel="bookmark">
			Android——2个activity之间的数据传递返回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		老版本2个activity之间传递反回数据，实例如：https://www.cnblogs.com/xiaobaibailongma/p/16440432.html
新版本如下：https://blog.csdn.net/freezingxu/article/details/124953918?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-124953918-blog-133701756.235%5Ev40%5Epc_relevant_3m_sort_dl_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-124953918-blog-133701756.235%5Ev40%5Epc_relevant_3m_sort_dl_base3&amp;utm_relevant_index=3
在需要调用系统Intent之前，我们需要定义所需的Launcher：
1、protected ActivityResultLauncher activityResultLauncher;
2、protected ActivityResultLauncher takePhotoLauncher;
3、protected ActivityResultLauncher selectImageLauncher;
4、protected ActivityResultLauncher selectFileLauncher;
此处我定义了4个不同的Launcher，分别用来处理普通的Intent跳转、拍照、选择相册中已有的图片和选择手机中的文件。
activityResultLauncher：处理普通的Intent跳转，并携带参数往返；
takePhotoLauncher：打开照相机进行拍照，并获得照片；
selectImageLauncher：打开系统Intent选择手机上的图片；
selectFileLauncher：打开系统Intent选择手机里的文件。
原文链接：https://blog.csdn.net/freezingxu/article/details/124953918
=============================================================================
第一个布局：
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;TextView android:id="@+id/tv_request" android:layout_width="match_parent" android:layout_height="wrap_content" android:paddingLeft="5dp" android:paddingTop="5dp" android:textColor="#000000" android:textSize="17sp" /&gt; &lt;Button android:id="@+id/btn_request" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:text="传送请求数据" android:textColor="#000000" android:textSize="17sp" /&gt; &lt;TextView android:id="@+id/tv_response" android:layout_width="match_parent" android:layout_height="wrap_content" android:paddingLeft="5dp" android:textColor="#000000" android:textSize="17sp" /&gt; &lt;/LinearLayout&gt; activity：
package com.example.myapplication; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.TextView; import androidx.activity.result.ActivityResultLauncher; import androidx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5267366c575301039696ead862ba39e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ee294653bd7740cd6560580bb7e086/" rel="bookmark">
			CUDA驱动深度学习发展 - 技术全解与实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全面介绍CUDA与pytorch cuda实战
一、CUDA：定义与演进 CUDA（Compute Unified Device Architecture）是由NVIDIA开发的一个并行计算平台和应用编程接口（API）模型。它允许开发者使用NVIDIA的GPU进行高效的并行计算，从而加速计算密集型任务。在这一节中，我们将详细探讨CUDA的定义和其演进过程，重点关注其关键的技术更新和里程碑。
CUDA的定义 CUDA是一种允许软件开发者和软件工程师直接访问虚拟指令集和并行计算元素的平台和编程模型。它包括CUDA指令集架构（ISA）和并行计算引擎在GPU上的实现。CUDA平台是为了利用GPU的强大计算能力而设计，特别适合处理可以并行化的大规模数据计算任务。
CUDA的演进历程 CUDA的诞生 2006年：CUDA的初现NVIDIA在2006年发布了CUDA，这标志着GPU计算的一个重大突破。在这之前，GPU主要被用于图形渲染。
CUDA的早期版本 CUDA 1.0（2007年）这是CUDA的首个公开可用版本，为开发者提供了一套全新的工具和API，用于编写GPU加速程序。
CUDA 2.0（2008年）引入了对双精度浮点运算的支持，这对科学计算尤为重要。
CUDA的持续发展 CUDA 3.0（2010年）和CUDA 4.0（2011年）引入了多项改进，包括对更多GPU架构的支持和更高效的内存管理。CUDA 4.0特别强调了对多GPU系统的支持，允许更加灵活的数据共享和任务分配。
CUDA的成熟期 CUDA 5.0（2012年）到CUDA 8.0（2016年）这一时期CUDA的更新聚焦于提高性能、增强易用性和扩展其编程模型。引入了动态并行性，允许GPU线程自动启动新的核函数，极大地增强了程序的灵活性和并行处理能力。
CUDA的现代版本 CUDA 9.0（2017年）到CUDA 11.0（2020年）这些版本继续推动CUDA的性能和功能边界。加入了对最新GPU架构的支持，如Volta和Ampere架构，以及改进的编译器和更丰富的库函数。CUDA 11特别重视对大规模数据集和AI模型的支持，以及增强的异构计算能力。
每个CUDA版本的发布都是对NVIDIA在并行计算领域技术革新的体现。从早期的基础设施搭建到后来的性能优化和功能扩展，CUDA的发展历程展示了GPU计算技术的成熟和深入应用。在深度学习和高性能计算领域，CUDA已成为一个不可或缺的工具，它不断推动着计算极限的扩展。
通过对CUDA定义的理解和其演进历程的回顾，我们可以清楚地看到CUDA如何从一个初步的概念发展成为今天广泛应用的高性能计算平台。每一次更新都反映了市场需求的变化和技术的进步，使CUDA成为了处理并行计算任务的首选工具。
二、CUDA与传统CPU计算的对比 在深入理解CUDA的价值之前，将其与传统的CPU计算进行比较是非常有帮助的。这一章节旨在详细探讨GPU（由CUDA驱动）与CPU在架构、性能和应用场景上的主要差异，以及这些差异如何影响它们在不同计算任务中的表现。
架构差异 CPU：多功能性与复杂指令集 设计理念：CPU设计注重通用性和灵活性，适合处理复杂的、串行的计算任务。
核心结构：CPU通常包含较少的核心，但每个核心能够处理复杂任务和多任务并发。
GPU：并行性能优化 设计理念：GPU设计重点在于处理大量的并行任务，适合执行重复且简单的操作。
核心结构：GPU包含成百上千的小核心，每个核心专注于执行单一任务，但在并行处理大量数据时表现卓越。
性能对比 处理速度 CPU：在执行逻辑复杂、依赖于单线程性能的任务时，CPU通常表现更优。
GPU：GPU在处理可以并行化的大规模数据时，如图像处理、科学计算，表现出远超CPU的处理速度。
能效比 CPU：在单线程任务中，CPU提供更高的能效比。
GPU：当任务可以并行化时，GPU在能效比上通常更有优势，尤其是在大规模计算任务中。
应用场景 CPU的优势场景 复杂逻辑处理：适合处理需要复杂决策树和分支预测的任务，如数据库查询、服务器应用等。
单线程性能要求高的任务：在需要强大单线程性能的应用中，如某些类型的游戏或应用程序。
GPU的优势场景 数据并行处理：在需要同时处理大量数据的场景下，如深度学习、大规模图像或视频处理。
高吞吐量计算任务：适用于需要高吞吐量计算的应用，如科学模拟、天气预测等。
了解CPU和GPU的这些关键差异，可以帮助开发者更好地决定何时使用CPU，何时又应转向GPU加速。在现代计算领域，结合CPU和GPU的优势，实现异构计算，已成为提高应用性能的重要策略。CUDA的出现使得原本只能由CPU处理的复杂任务现在可以借助GPU的强大并行处理能力得到加速。
总体来说，CPU与GPU（CUDA）在架构和性能上的差异决定了它们在不同计算任务中的适用性。CPU更适合处理复杂的、依赖于单线程性能的任务，而GPU则在处理大量并行数据时表现出色。
三、CUDA在深度学习中的应用 深度学习的迅速发展与CUDA技术的应用密不可分。这一章节将探讨为什么CUDA特别适合于深度学习应用，以及它在此领域中的主要应用场景。
CUDA与深度学习：为何完美契合 并行处理能力 数据并行性：深度学习模型，特别是神经网络，需要处理大量数据。CUDA提供的并行处理能力使得这些计算可以同时进行，大幅提高效率。
矩阵运算加速：神经网络的训练涉及大量的矩阵运算（如矩阵乘法）。GPU的并行架构非常适合这种类型的计算。
高吞吐量 快速处理大型数据集：在深度学习中处理大型数据集时，GPU能够提供远高于CPU的吞吐量，加快模型训练和推理过程。
动态资源分配 灵活的资源管理：CUDA允许动态分配和管理GPU资源，使得深度学习模型训练更为高效。
深度学习中的CUDA应用场景 模型训练 加速训练过程：在训练阶段，CUDA可以显著减少模型对数据的训练时间，尤其是在大规模神经网络和复杂数据集的情况下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6ee294653bd7740cd6560580bb7e086/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b6b9ba5e2ab3b1a90ed47627e12b42b/" rel="bookmark">
			lvs&#43;keepalived&#43;nginx双主模式双主热备实现负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、原理
二、真实服务器nginx配置
三、lvs的keepalived配置
3.1 配置文件
3.2 开启keepalived服务
四、测试
4.1 测试访问VIP
4.2 模拟lvs01宕机
主机名IPnginx0111.0.1.31nginx0111.0.1.31lvs0111.0.1.33lvs0211.0.1.34VIP111.0.1.29VIP211.0.1.30 一、原理 lvs+keepalived+nginx主备模式下，lvs永远只有一台在工作，资源利用率并不高，双主模式可以解决这一问题。
确保真实IP11.0.1.31、11.0.1.32访问正常
二、真实服务器nginx配置 nginx01、nginx02 执行real_server.sh脚本
新建real_server.sh脚本并执行，脚本内容为lo网卡新增两个虚拟接口，添加linux内核路由，关闭arp功能。
[root@nginx01 ~]# cat /etc/keepalived/real_server.sh ifconfig lo:0 11.0.1.29 netmask 255.255.255.255 broadcast 11.0.1.29 route add -host 11.0.1.29 dev lo:0 ifconfig lo:1 11.0.1.30 netmask 255.255.255.255 broadcast 11.0.1.30 route add -host 11.0.1.30 dev lo:1 echo "1" &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore echo "2" &gt;/proc/sys/net/ipv4/conf/lo/arp_announce echo "1" &gt;/proc/sys/net/ipv4/conf/all/arp_ignore echo "2" &gt;/proc/sys/net/ipv4/conf/all/arp_announce [root@nginx01 ~]# chmod +x /etc/keepalived/real_server.sh [root@nginx01 ~]# sh /etc/keepalived/real_server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b6b9ba5e2ab3b1a90ed47627e12b42b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/6/">«</a>
	<span class="pagination__item pagination__item--current">7/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/8/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>