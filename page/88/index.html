<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a8d65a588150c8176df8843f8343f58/" rel="bookmark">
			Rn页面滚动显示隐藏head动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整代码
import { View, Text, StyleSheet, Animated } from 'react-native' export default () =&gt; { const opacity = new Animated.Value(0) const handleScroll = Animated.event( [{ nativeEvent: { contentOffset: { y: opacity } } }], { useNativeDriver: true } ) return ( &lt;&gt; &lt;Animated.View style={{ ...styles.head, opacity: opacity.interpolate({ inputRange: [0, 50], outputRange: [0, 1], extrapolate: 'extend' }) }} &gt; &lt;Text&gt;头部&lt;/Text&gt; &lt;/Animated.View&gt; &lt;Animated.ScrollView onScroll={handleScroll} scrollEventThrottle={16}&gt; {[0, 0, 0, 0, 0, 0, 0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a8d65a588150c8176df8843f8343f58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ecef3f7e3d7b4d1ecd289b22a2f6a4/" rel="bookmark">
			comsol学习---声学与振动建模-----1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 声学原理： 线性声学都是微小声学扰动下的压缩波 所以可以将这些量拆成两项：平均值+干扰项 再带回前面的线性方程里面，可得： 压力声学（FEM） 怎么选择分析模型？ 无源分析式结构本身的特性，只和使用材料、几何结构等物理上的不同有关，和放什么声源无关。 无源特征频率 1：特征频率分析 案例分析： 操作： COMSOL56→Multiphisics→applications 里面都是模型
几何新建导入---&gt;在导入中导入房建模型---&gt;再点击材料选择内置材料，域选择空气 模型在：E:\Comsol\COMSOL56\Multiphysics\applications\COMSOL_Multiphysics\Acoustics\eigenmodes_of_room.mphbin
然后构建一下网格： 选择特征频率在那个范围里面寻找：这里选择在1赫兹附近选择10个 一般查看声压和声压级，然后需要去掉几个面就在数据集里面进行选择 F6 F7上一个下一个特征频率切换 也可以选择某个区域的来看 例如选择1--100的 取20来看 导出动画 ： 播放器就是在软件里面显示了 但是文件就是可以导出了
点击一下----显示帧 由上面的实验我们可以得到结果： 就是说网络单元格&lt;1/5波长 剖析网格的时候要注意！！要取最高频率去剖析！ 需要衡量几何尺寸是否和频率、波长相匹配 有源声学 频域分析、瞬态分析
实验步骤： 结果达到稳定状态才能用频域下的压力声学 被动边界：声音来了才产生作用
辐射边界入射压力场: 就是在里面选择一个面作为射入面
法相加速度：固体振动
背景压力场：加到域上面 然后就是相当于加一个挡板之类的东西
A B的交界面，声波打到界面上是否产生反射要看这两种介质的阻抗（密度乘以声速）
液气交界面是指从水射到空气中，交界面就为软场边界（方向一定是液体到气体）
都用阻抗去算就是了，再去比大小看是什么情况
完美匹配层：可以比较完美的将声源的各个方向来的声波进行吸收
笛卡尔形：方形
匹配边界：知道声源的具体方向（不常用） 案例：有源声学 思路：
入口：做成辐射边界条件做一个入射
出口：辐射边界条件吸掉声音，出去了就不会再回来了
周围壁面：用硬声场完全反射声场
导入序列---&gt;构建模型---&gt;加入材料---&gt;加入平面波辐射，选择两个开口---&gt;在平面波辐射理面加入入射压力场，选择一个面为入射口---&gt;剖分一下网格---&gt;设置网格大小---&gt;设置频域的范围---&gt;构建对比积分函数（构建积分和变量）---&gt;在结果里面构建一维绘图选择去全局 积分看一下入口出口的比值
可以通过波方向设置入射的方向 多孔声学：DBM模型 JCAPL适用于两种极端，要么特别硬要么特别软 特别硬：钢板 特别软：头发 WOOD：适用于悬浮液体 在模型外面加入一个球形的模具，形成完美匹配层 例如： PML形状：方形、球形、柱形 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/943bfae7bf85a252bbbc49cf35b15251/" rel="bookmark">
			oracle和mysql的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle与MySQL的区别以及优缺点 MySQL的特点
1、性能卓越，服务稳定，很少出现异常宕机；
2、开放源代码无版本制约，自主性及使用成本低；
3、历史悠久，社区和用户非常活跃，遇到问题及时寻求帮助；
4、软件体积小，安装使用简单且易于维护，维护成本低；品牌口碑效应；
5、支持多种OS，提供多种API接口，支持多种开发语言，对流行的PHP，Java很好的支持
MySQL的缺点
1、MySQL最大的缺点是其安全系统，主要是复杂而非标准，另外只有到调用mysqladmin来重读用户权限才会发生改变；
2、MySQL的另一个主要的途径之一是缺乏标准的RI（Referential Integrity-RI）机制，RI限制的缺乏（在给定字段域上的一种固定的范围限制）可以通过大量的数据类型来补偿；
3、MySQL不支持热备份；
Oracle的特点
1、兼容性：Oracle产品采用标准SQL，并经过美国u构架标准技术所（NIST）测试，与IBM SQL/DS、DB2、INGRES、IDMS/R等兼容。
2、可移植性：Oracle的产品可运行于很宽范围的硬件与操作系统平台上。可以安装在多种 大、中、小型机上，可在多种操作系统下工作。
3、可联结性：Oracle能与多种通讯网络相连，支持各种协议。
4、高生产率：Oracle产品提供了多种开发工具，能极大地方使用户进行进一步的开发。
5、开放性：Oracle良好的兼容性、可移植性、可连接性和高生产率使Oracle RDBMS具有良好的开放性。
Oracle的缺点
1、对硬件要求很高；
2、价格比较昂贵；
3、管理维护麻烦一些；
4、操作比较复杂，需要技术含量高；
mysql和oracle的区别有：
1、Oracle数据库是一个对象关系数据库管理系统，要收费；MySQL是一个开源的关系数据库管理系统，是免费的；
2、数据库安全性的区别；
3、对象名称的区别；
4、临时表处理方式上的区别等等。
MySQL和Oracle都是流行的关系数据库管理系统（RDBMS），在世界各地广泛使用；大多数数据库以类似的方式工作，但MySQL和Oracle的这里和那里总是存在一些差异的。本篇文章就给大家比较Oracle和MySQL，介绍Oracle和MySQL之间的区别，希望对你们有所帮助。
MySQL和Oracle有什么区别？两个数据库的特性是不同的，所以与Oracle相比，MySQL的使用方式不同；与MySQL相比，Oracle的使用情况有所不同。它们的特点也是不同的。下面我们就来具体看看MySQL和Oracle的区别有哪些。
0、宏观上:
1、Oracle是大型的数据库而Mysql是中小型数据库；Mysql是开源的，Oracle是收费的，且价格昂贵。
2、Oracle支持大并发，大访问量，是OLTP的最好的工具。
3、安装占用的内存也是有差别，Mysql安装完成之后占用的内存远远小于Oracle所占用的内存，并且Oracle越用所占内存也会变多。
1、本质的区别
Oracle数据库是一个对象关系数据库管理系统（ORDBMS）。它通常被称为Oracle RDBMS或简称为Oracle，是一个收费的数据库。
MySQL是一个开源的关系数据库管理系统（RDBMS）。它是世界上使用最多的RDBMS，作为服务器运行，提供对多个数据库的多用户访问。它是一个开源、免费的数据库。
2、数据库安全性
MySQL使用三个参数来验证用户，即用户名，密码和位置；Oracle使用了许多安全功能，如用户名，密码，配置文件，本地身份验证，外部身份验证，高级安全增强功能等。
3、SQL语法的区别
Oracle的SQL语法与MySQL有很大不同。Oracle为称为PL / SQL的编程语言提供了更大的灵活性。Oracle的SQL * Plus工具提供了比MySQL更多的命令，用于生成报表输出和变量定义。
4、存储上的区别：
与Oracle相比，MySQL没有表空间，角色管理，快照，同义词和包以及自动存储管理。
5、对象名称的区别：
虽然某些模式对象名称在Oracle和MySQL中都不区分大小写，例如列，存储过程，索引等。但在某些情况下，两个数据库之间的区分大小写是不同的。
Oracle对所有对象名称都不区分大小写；而某些MySQL对象名称（如数据库和表）区分大小写（取决于底层操作系统）。
6、运行程序和外部程序支持：
Oracle数据库支持从数据库内部编写，编译和执行的几种编程语言。此外，为了传输数据，Oracle数据库使用XML。
MySQL不支持在系统内执行其他语言，也不支持XML。
7、MySQL和Oracle的字符数据类型比较：
两个数据库中支持的字符类型存在一些差异。对于字符类型，MySQL具有CHAR和VARCHAR，最大长度允许为65,535字节（CHAR最多可以为255字节，VARCHAR为65.535字节）。
而，Oracle支持四种字符类型，即CHAR，NCHAR，VARCHAR2和NVARCHAR2; 所有四种字符类型都需要至少1个字节长; CHAR和NCHAR最大可以是2000个字节，NVARCHAR2和VARCHAR2的最大限制是4000个字节。可能会在最新版本中进行扩展。
8、MySQL和Oracle的额外功能比较：
MySQL数据库不支持其服务器上的任何功能，如Audit Vault。另一方面，Oracle支持其数据库服务器上的几个扩展和程序，例如Active Data Guard，Audit Vault，Partitioning和Data Mining等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/943bfae7bf85a252bbbc49cf35b15251/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72b8b34f4cabf9194945abea5d3c39a2/" rel="bookmark">
			redis使用学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 关于redis的简单性能概括Redis命令行客户端Redis命令Redis通用命令String类型key的层级格式Hash类型List类型Set类型SortedSet类型 Redis的Java客户端Jedis使用基本步骤Jedis连接池 SpringDataRedisRedisTemplate快速入门RedisSerializer 关于redis的简单性能概括 键值（key-value）型，value支持多种不同数据结构，功能丰富单线程，每个命令具备原子性低延迟，速度快（基于内存、IO多路复用、良好的编码）支持数据持久化支持主从集群、分片集群支持多语言客户端 Redis命令行客户端 Redis安装完成后就自带了命令行客户端：redis-cil，使用方式如下：
redis-cli [options] [commands] 其中常见的options有：
-h 127.0.0.1：指定要连接的redis节点的IP地址，默认是127.0.0.1-p 6379：指定要连接的redis节点的端口，默认是6379-a 123321：指定redis的访问密码
其中的commonds就是Redis的操作命令，例如打乒乓ping：与redis服务端做心跳测试，服务端正常会返回pong Redis命令 Redis通用命令 通用指令是部分数据类型，都可以使用的指令，常见的有：
KEYS：查看符合模板的所有key（可以使用模糊查询，不建议在生产环境设备上使用，采用的是模糊查询的方式，当数据量过大…）DEL：删除一个指定的keyEXISTS：判断key是否存在EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除TTL：查看一个KEY的剩余有效期 通过help[command]可以查看一个命令的具体用法
String类型 String类型，也就是字符串类型，是Redis中最简单的存储类型
不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m（1/2GB）
常见命令：
SET：添加或者修改已经存在的一个String类型的键值对GET：根据key获取String类型的键值对MSET：批量添加多个String类型的键值对MGET：根据多个key获取多个String类型的valueINCR：让一个整型的key自增1INCRBY：让一个整型的key自增并指定步长，例如：incyby num 2 让num值自增2INCRBYFLOAT：让一个浮点类型的数字自增并指定步长SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行SETEX：添加一个String类型的键值对，并且指定有效期 key的层级格式 Redis的key允许有多个单词形成层级结构，多个单词之间用:隔开，格式如下：
项目名：业务名：类型：id
这个格式并非固定，也可以根据自己的需求来删除或添加词条
例如我们的项目名称叫heima，有user和product两种不同类型的数据，我们可以这样定义key
user相关的key：heima：user：1product相关的key：heima：product：1 Hash类型 Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构
Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD
常见命令
HSET key field value：添加或者修改hash类型的key的field的值HGET key field：获取一个hash类型key的field的值HMSET：批量添加多个hash类型key的field的值HMGET：批量获取多个hash类型key的field的值HGETALL：获取一个hash类型的key中的所有的field和valueHKEYS：获取一个hash类型的key中的所有fieldHVALS：获取一个hash类型的key中的所有的valueHINCRBY：让一个hash类型key的字段值自增并指定步长HSETNX：添加一个hash类型的key和field值，前提是这个field不存在，否则不执行 List类型 Redis中的List类型与Java中的LinkedList类似，可以看作是一个双向链表结构。既可以支持正向检索，也可以支持反向检索。
特征也与LinkedList类似：
有序元素可以重复插入和删除快查询速度一般 常见命令：
LPUSH key element … ：向列表左侧插入一个或多个元素LPOP key：移除并返回列表左侧的第一个元素，没有则返回nilRPUSH key element … ：向列表右侧插入一个或多个元素RPOP key：移除并返回列表右侧的第一个元素LRANGE key star end：返回一段角标范围内的所有元素BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil 如何利用List结构模拟一个栈
可以左进左出，或者右进右出（单方向进出） 如何利用List结构模拟一个队列？
左进右出，或者右进左出（进出方向不同） 如何利用List结构模拟一个阻塞队列？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72b8b34f4cabf9194945abea5d3c39a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f30049e87dc2a3a273701e3730d650/" rel="bookmark">
			Sharding-JDBC分库分表-自定义分片算法-4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认分片算法 Sharding JDBC通过org.apache.shardingsphere.sharding.spi.ShardingAlgorithm接口定义了数据分片算法，5.2.1版本默认提供了如下的分片算法
配置标识自动分片算法详细说明类名MODY基于取模的分片算法ModShardingAlgorithmHASH_MODY基于哈希取模的分片算法HashModShardingAlgorithmBOUNDARY_RANGEY基于分片边界的范围分片算法BoundaryBasedRangeShardingAlgorithmVOLUME_RANGEY基于分片容量的范围分片算法VolumeBasedRangeShardingAlgorithmAUTO_INTERVALY基于可变时间范围的分片算法AutoIntervalShardingAlgorithmINTERVALN基于固定时间范围的分片算法IntervalShardingAlgorithmCLASS_BASEDN基于自定义类的分片算法ClassBasedShardingAlgorithmINLINEN基于行表达式的分片算法InlineShardingAlgorithmCOMPLEX_INLINEN基于行表达式的复合分片算法ComplexInlineShardingAlgorithmHINT_INLINEN基于行表达式的 Hint 分片算法HintInlineShardingAlgorithm 默认算法的继承关系如下
分片算法参考官方用户文档：默认分片算法介绍
自定义分片算法 自定义分片算法时通过配置分片策略类型和算法类名，实现自定义扩展。 CLASS_BASED 允许向算法类内传入额外的自定义属性，传入的属性可以通过属性名为 props 的 java.util.Properties 类实例取出。
自定义分片算法有三种类型
标准分片算法复杂分片算法hint分片算法 对应需要实现的接口分别为：
算法分类需要实现接口说明标准StandardShardingAlgorithm支持单个分片键，需要实现精确和范围分片接口复杂ComplexShardingAlgorithm支持多个分片键，但是分片键数据类型需要一样hintHintShardingAlgorithm没有分片键，分片值通过hint注入而不是SQL 分片算法开发 以标准算法为例，对下面的order_t进行分表
CREATE TABLE `order_t` ( `order_id` bigint(20) NOT NULL COMMENT 'order_id主键', `order_no` varchar(32) DEFAULT NULL COMMENT '订单编号', `user_id` bigint(10) NOT NULL COMMENT '用户ID', `order_date` date NOT NULL COMMENT '下单时间', `order_amount` decimal(16,2) NOT NULL COMMENT '订单金额', `delivery_amount` decimal(16,2) DEFAULT '0.00' COMMENT '运费', `total_amount` decimal(16,2) NOT NULL COMMENT '汇总金额', `receiver_id` bigint(10) NOT NULL COMMENT '收货地址ID', `status` tinyint(4) DEFAULT '1' COMMENT '状态，1：已提交，2：已付款，3：待发货，4：已发货，5：已收货，6：已完成', `deleted` tinyint(4) DEFAULT '0' COMMENT '删除标志，0：未删除，1：已删除', `create_by` bigint(10) DEFAULT NULL COMMENT '创建人', `creation_date` datetime DEFAULT NULL COMMENT '创建时间', `last_update_by` bigint(10) DEFAULT NULL COMMENT '修改人', `last_update_date` datetime DEFAULT NULL COMMENT '修改时间', PRIMARY KEY (`order_id`), KEY `idx_useId` (`user_id`), KEY `idx_orderNo` (`order_no`), KEY `idx_orderDate` (`order_date`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='订单表'; 分表规则为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6f30049e87dc2a3a273701e3730d650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76e8365eaf0d806ff493f3a58ac2b9af/" rel="bookmark">
			第二十四周周报：文献阅读&#43;监督学习之回归和分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
Abstract
文献阅读：水文气候时间序列具有多时间尺度的特征
前提知识
多尺度
时间序列
研究背景
研究目的
研究方法
研究思路
文献贡献
Supervised Learning（监督学习）
回归问题
线性回归
线性回归数学原理
分类问题
逻辑回归
逻辑回归的理论推导
回归问题与分类问题的区别
Pytorch实现线性回归任务
总结
摘要 这周阅读了一篇关于水文的时间序列以及多时间尺度特征的论文，该文献提出了一种新颖而详细的，用以推进和丰富水文气候背景下的调查方法框架。我首先对文献中提出的时间序列以及多尺度等前提知识进行学习了解，然后从研究背景、目的、方法、思路等方面对文献进行分析理解。除了文献阅读之外，我这周继续学习机器学习，重新学习监督学习中的分类和回归问题，对这两种问题用到的线性回归和逻辑回归从数学理论方面进行学习。
Abstract This week, I read a paper on the time series and multi time scale characteristics of hydrology, which proposes a novel and detailed framework for advancing and enriching investigation methods in the context of hydrology and climate. I first study and understand the prerequisite knowledge of time series and multi-scale proposed in the literature, and then analyze and understand the literature from aspects such as research background, purpose, methods, and ideas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76e8365eaf0d806ff493f3a58ac2b9af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4880383ff829eebc330eadebfe8b78c3/" rel="bookmark">
			时间序列预测之ARIMA模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、基本概念1、 A R ( p ) AR(p) AR(p)模型2、 M A ( q ) MA(q) MA(q)模型3、 A R M A ( p , q ) ARMA(p,q) ARMA(p,q)模型4、 A R I M A ( p , d , q ) ARIMA(p,d,q) ARIMA(p,d,q)模型 二、 A R I M A ( p , d , q ) ARIMA(p,d,q) ARIMA(p,d,q)模型求解1、数据准备2、平稳性检验3、白噪声检验4、模型定阶4.1 根据ACF、PACF图进行定阶4.2 网格搜索法定阶 5、建立模型6、模型检验7、模型拟合及误差分析8、模型预测 一、基本概念 一些针对ARIMA模型的预备知识，若只需应用ARIMA模型求解可跳至第二节
1、 A R ( p ) AR(p) AR(p)模型 A R AR AR模型又称为自回归模型，是一种处理时间序列预测的方法。它描述了当前值与历史值之间的关系，用变量自身的历史数据对自身进行预测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4880383ff829eebc330eadebfe8b78c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a49d2c546ed1a3c02d28b17d6d2928/" rel="bookmark">
			uni-app_消息推送_华为厂商_unipush离线消息推送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、创建项目二、生成签名证书三、开通 unipush 推送服务四、客户端集成四、制作自定义调试基座五、开发者中心后台Web页面推送（仅支持在线推送）六、离线消息推送1、创建华为开发者账号2、开通推送服务3、创建项目4、添加应用5、添加SHA256证书指纹6、开通推送服务7、Dcloud 平台厂商推送配置8、安装 app 到真机9、华为离线消息测试10、获取 Device Token 发送消息 一、创建项目 打开 Hbuilder 创建一个新项目 登录 DCloud 开发者中心，新建一个应用（注意： 上面第一步在 Hbuilder 创建新项目时，如果已经登录了 HBuilder 账号，那么下面这一步可以省略，HBuilder 会自动帮你创建好这个应用） 创建好应用应该之后，复制 Appid，打开 manifest.json，将 uni-app 应用标识(Appid) 替换成我们新创建应用的 Appid 二、生成签名证书 uni-app 安卓证书生成有两种方式，一种是去 DCloud 开发者中心生成证书（下面我们就采用这种方式），另一种是安装 jre 环境，生成证书（参考链接 ： https://ask.dcloud.net.cn/article/35777）
点击应用名称，
切换至【Android云端证书】，创建证书（生成证书一般需要 1-5 分钟时间） 证书生成之后，点击证书详情，复制 MD5、SHA1、SHA256 备用 切换至【各平台信息】，点击新增 将之前复制 MD5、SHA1、SHA256 填写进去，包名可以自己定义（eg: com.app.uniPush） 三、开通 unipush 推送服务 在【unipush】-【1.0(老版本)】-【应用信息】，选中我们上面创建的应用，我们这里只测试 Android 平台，所以勾选去掉 IOS，最后点击开通应用；
四、客户端集成 打开项目， 点击 manifest.json，选择【App模块配置】，否选【Push(消息推送)】，uniPush 消息推送图标，大家可自行配置； 获取 cid（ClientId：个推业务层中的对外用户标识，用于标识客户端身份，由第三方客户端获取并保存到第三方服务端，是个推 SDK 的唯一识别号，简称 CID）
在应用安装后第一次运行时应该调用 5+ API 的 plus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00a49d2c546ed1a3c02d28b17d6d2928/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c31ecb1b5afedde707dbffe552e62b6/" rel="bookmark">
			C&#43;&#43;实现集群聊天服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++实现集群聊天服务器 JSON Json是一种轻量级的数据交换模式（也叫做数据序列化方式）。Json采用完全独立于编程语言的文本格式来存储和表示数据。见解和清晰的层次结构使得Json称为理想的数据交换语言。易于阅读和编写。同时也易于支持机器解析和生成，有效地提升网络传出效率。
这里讲的网络传输，就涉及到序列化和反序列化。以客户端和服务器端通信为例，一般情况下，客户端给服务器端发送信息，发送的信息可能是字符串、整型等信息，需要先转化为字节流数据，这就是序列化；同样，服务器接收到客户端发来的字节流信息，需要转化成原始的数据格式，这就是反序列化。
JSON for Modern C++是一个C++下的JSON库，具有以下特点：直观的语法、仅需使用头文件json.hpp依赖、C++11标准编写、类似于STL使用json、STL和json可以互相转化、严谨的测试（所有类都经过严格的单元测试）。
数据序列化 在网络中，常见的数据传输序列化格式有XML、Json、ProtoBuf，其中ProtoBuf最为常用，其数据压缩编码传输占用带宽小，同样的数据信息，是Json的1/10，XML的1/20，但是使用起来稍微比Json复杂。
Json使用 头文件引入和重命名#include"json.hpp" using json = nlohmann::json;。然后就可以是使用json类似于对象的使用方法使用json了。
#include"json.hpp" using json = nlohmann::json; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; void func1() { json js; js["from"] = "zhangsan"; js["message_type"] = 2; js["to"] = "lisi"; js["message"] = "Hi, what are you doing?"; cout &lt;&lt; js &lt;&lt; endl; string str=js.dump();//序列化，转化成字符串格式 cout&lt;&lt;str.c_str()&lt;&lt;endl; // 模拟从网络接收到json字符串，通过json::parse函数把json字符串字节流转化为json对象 json js2 = json::parse(temp); cout &lt;&lt; js2 &lt;&lt; endl; } void func2() { json js; js["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c31ecb1b5afedde707dbffe552e62b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f9a4a71d7c4dbc10548f4ee5f56d0c8/" rel="bookmark">
			IBIS 模型简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 IBIS 模型的定义和用途 IBIS（Input/Output Buffer Informational Specifation），表示输入/输出缓冲器信息规范。它代表了IC供应商提供给客户进行高速设计仿真的器件的数字引脚的特性或行为。这些模型使用IBIS开放论坛（负责管理和更新IBIS模型规范与标准的行业组织）所规定的参数模仿器件的I/O行为。它们不包含专有数据，因为模型中没有披露IC原理图设计信息，如晶体管尺寸、缓冲器原理图设计中使用的器件模型参数和电路等。从版本5.0开始，规范包含两种不同类型的模型：“传统IBIS”和“IBIS-AMI”。“传统IBIS”模型使用ASCII文本文件格式，提供表格化的电压-电流和电压-时间信息。IBIS-AMI模型在专用SerDes通道模拟器中运行，而不是在类似SPICE的模拟器中运行，并且由两个文本文件（*.ibs 和 *.ami）和一个特定平台的机器代码可执行文件（Windows上是*.dll，Linux上是*.so）组成。IBIS-AMI支持统计和所谓的时域通道模拟，以及三种类型的 IC 模型（“impulse-only”、“GetWave-only”和“dual mode”）。 IBIS模型通常用来代替SPICE模型，执行各种板级和系统级信号完整性仿真和时序分析。由于IBIS模型是为解决板级和系统级信号完整性而诞生的。所以，在信息化和网络化时代，IBIS模型获得了大部分EDA供应商的支持，可以在大多数EDA仿真平台中运行。 1.2 IBIS 模型的历史背景和发展 20世纪80年代 IBM公司设计、确立的ISA总线标准,在个人计算机早期发展阶段占据着统治地位。但随着个人计算机的爆炸性发展和微处理器性能的不断提升,ISA总线的数据传输速度逐渐成为计算机整体性能的瓶颈。ISA总线采用8MHz时钟总线，最大宽度16位,理论最大传输速度16MB/s,这难以满足处理器与外设间日益增长的数据交互的需要。时间来到1991年，Intel公司首次向业界推出它全新设计的总线架构--PCI总线。PCI总线在时钟和总线宽度两方面均作出提升,将时钟频率提升至33MHz,总线宽度扩大至32位，总线的理论最大传输速度达132MB/s 以上。要知道,33MHz 的时钟频率是与当时CPU的运行时钟频率(主频)是齐平的。这也是 PCI总线为什么选择33MHz为运行时钟频率值的原因。在当时的技术条件下,对一种总线技术而言,33MH的运行时钟频率是一个全新的高速度。正是这个全新的运行速度,给板级数字电路系统的设计带来全新的改变。 从此以后，一个全新的设计要素成为数字电路设计者们不得不面对的新课题,成为决定电路成败的绝对关键,这就是我们今天再熟悉不过的“信号完整性”。在ISA总线的时代,板级电路的正确性直接来自于逻辑和原理层面的正确性,不需要关心信号的波形质量,无所谓信号波形的优劣,也即无所谓信号的“完整性”。这时的信号互连设计,也就是印制电路板的布线设计,是纯粹以“连通”为目的的设计,信号走线的需求是“连通”即可,没有其他考究,在这上面也从未出过问题。但当信号速度达到33MHz这样的级别,正如我们现在已经知道的,反射、时延和噪声等现象给信号波形带来的干扰,其严重程度可能足以导致信号逻辑状态的错误判决,使信号失去其驱动电路正确工作的“完整性”。在低速电路时代从未失效过的“逻辑设计正确,则电路设计正确”的法则不再适用。板级数字电路的正确性,除了取决于“逻辑完整性”,还取决于“信号完整性”。数字电路系统的设计工程师们发现,他们现在需要像模拟电路工程师一样关心信号的波形。印制电路板的布局和布线,再也不是仅需要“连通”即可的事情。 Intel的工程师是最早面对这个问题的一批人。PCI总线的正式规范发布于1992年6月(PCI技术规范1.0 版),而在规范发布之前的1990年和1991 年,Intel内部已经开始考虑PCI总线系统的板级电路设计与实现。于是,Intel进行了PCI总线的信号完整性仿真分析,以对这一新型总线架构在板级互连后的信号表现进行评估和验证。这可能是最早开展的纯粹针对数字电路板级系统的信号完整性仿真活动。仿真需要模型,Intel的芯片设计部门需要向系统设计部门提供PCI信号的芯片级模型,供后者进行PCI板级电路系统信号完整仿真使用。这个时候Intel的芯片设计部门并没有任何现成的PCI芯片设计,且由于PCI总线的规范草案正处讨论验证阶段，规范对于PCI芯片技术特性的规定还未最终敲定,芯片设计部门还未开始正式的芯片设计工作,也就暂时无法提供PCI总线芯片的SPICE 模型。 时势造英雄，这时候Donald Telian所领导的团队（该团队主导创造了PCI总线和IBIS模型）提出了一个想法：为I/O缓冲器创建一个信息表，并使用此信息测试Intel的电路板。是的，这种方法只需要芯片部门提供芯片输入、输出的详细行为数据，主要包括芯片在输入、输出时的电压-电流关系（V-I曲线）和电压-时间关系（V-t曲线）。其他的在SPICE模型中需要提供的大量信息，如芯片IO电路的晶体管级组成结构、连接关系、晶体管内部结构参数、工艺制程参数等，统统不需要。这种只反映从外部感受到的芯片输入、输出“行为”，我们称为“行为级”模型。正是这个改变，Donald Telian团队几乎不需要任何芯片设计技术背景，只需根据PCI总线需要达到的板级互连能力目标，预先规划出芯片IO可能需要具备的行为特性，构造出“行为级”模型，然后进行信号完整性仿真，根据仿真结果对模型进行优化，再仿真，再优化，最终获得PCI总线芯片所需要具备的IO行为特性参数，并反馈给芯片设计部门。芯片设计部门按照这种已经经过信号完整性仿真验证的参数要求来设计PCI总线芯片的IO电路，极大地缩短了设计研发周期。 很快，Intel与其客户共享这些信息表以帮助后者进行电路板设计，但不提供任何专有信息。为了能够可靠地将纸张形式的表格中的信息传送到客户的仿真器，Intel决定与EDA供应商和其他计算机制造商合作。他们创建了IBIS开放论坛，以帮助标准化计算机可读格式的缓冲器信息。于1993 年4月23日，由“IBIS模型之父”Donald Telian代表的英特尔组织发起，Cadence、HyperLynx等六家模拟软件工具供应商参与，举行了第一届 IBIS 开放论坛会议。会议通过了IBIS的更名提案，名字由iBIS（Intel Buffer Information Sheet）“英特尔缓冲器信息表”改成IBIS（I/O Buffer Information Sheet）“输入输出缓冲器信息表”。这个提案来自英特尔团队，旨在鼓励全行业参与IBIS建模。于2.0版本更名为输入/输出缓冲器信息规范。 1995年，IBIS开放论坛与美国国家标准协会/电子工业联盟(ANSI/EIA)合作。IBIS 2.1版是新联盟发布的第一个版本，它增加了模拟ECL和PECL缓冲器以及差分信号描述。IBIS 3.2允许封装模型描述和电路板描述。IBIS 5.0版于 2008 年 8月29 日获得 IBIS开放论坛的批准，与之前的版本（IBIS 4.2、ANSI/EIA-656-B）相比，它增加了一个新的流程，不是基于SPICE 瞬态，而是基于通道模拟器（称为算法模型应用程序接口或 AMI流程）、电源完整性和EMC检查功能。为了保证电源完整性，它使用Touchstone 2.0 S 参数文件以及每端口参考阻抗规范。IBIS 5.1版于2012年8月24日获得批准。重要更改包括所谓的“流程 BIRD”，它解决了IBIS AMI流程中的许多歧义。 IBIS 6.0 版于2013年 9月20日获得批准。更改包括中通道中继器的IBIS-AMI 扩展、 IBIS-AMI 中抖动和噪声的新参数以及模拟缓冲区建模改进。IBIS 6.1版于2015年9月11日获得批准。更改包括 IBIS-AMI 中对 PAM-4 的支持、添加新的初始延迟关键字以及额外的超频选项。IBIS 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f9a4a71d7c4dbc10548f4ee5f56d0c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b337f164702967633f4d4f0c159c9e4/" rel="bookmark">
			基于51单片机的水位水质检测系统方案原理PCB设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总体方案设计 （末尾附文件）
通过查阅大量相关技术资料，并结合自己的实际知识，我主要提出了两种技术方案来实现系统功能。下面我将首先对这两种种方案的组成框图和实现原理分别进行说明。
2.1 智能水位水质检测电路设计方案框图
两种方案的框图如下图：
方案1：
方案2：
2.2 方案论证
对于方案1和2按照理论来看做出来能够达到一定的预期效果，能达基本满足本次设计的基本要求。但是两种方案不同之处就在于传感器的选择和AD的选择，现就这两个方面来论述.为什么选择方案2。
方案1的传感器部分是利用应变片做的压力变送器，其结构如下图2.1:
图 2.1
这是利用4片应变片做的全桥电路其电压灵敏度比单臂工作时提高了4倍，消除了一定的非线性误差。其输出的为电流信号但是非常小，所以在外部又加了一个差动放大将信号放大才能满足AD 0 - +5V的输入电压的要求。但是此类的工作都是提供1.5mA的横流源，我们自己做的恒流源很难满足要求。硬件部分完成以后还要对其进行测试线性度，但是测量比较麻烦后期的数据处理也比较繁琐，最后达到的效果也比较差所以就没有选择应变片制作。
对于AD的选择主要是ADC0809与ADC0832之间的选择。
ADC0809是8位分辨率；+5V电源供电；输入电压为0 - +5V；工作频率250HZ；转换时间为32us；数据转送是8位串行传送；
通过直观的观察可以发现由于ADC0809的数据传送是8位串行的所以传完8位数据需要的时间为256us，而ADC0832为8位的并行数据传送，传8位数据只需100us。所以ADC0832的转换存取速度更快，这样系统的工作效率更高。所以我们采用的是ADC0832。
综上我们本次设计水位水质检测电路采用的方案2。
2.3 方案可能的扩展功能
我们这次设计的智能水位水质检测电路结构还比较简单，只是完成测水位水质并读出页面高度的基本功能，在这几完成后发现该系统还能扩展许多功能。比如增加报警系统（应用于比如水库的水位水质测量时可以做下限报警和超限报警）；远程的控制系统（比如家用的水塔水不足时可以控制水泵加水）。
单元模块电路的设计 本节主要介绍系统各单元模块的具体功能、电路结构、工作原理、以及各个单元模块之间的联接关系；同时本节也会对相关电路中的参数计算、元器件选择、以及核心器件进行必要说明。
3.1各单元模块功能介绍及电路设计
本系统电路模块主要分为四个单元模块，它们分别是：传感器输出部分；ADC0832的数据采集转换模块；单片机最小系统模块；模块.各单元模块功能及相关电路的具体说明如下。
3.1.1 传感器输出部分
3.1.2 ADC0832数据采集转化部分
该级电路一共实现了两个功能：第一个是对模拟电压信号的采集。第二个功能是将模拟电压信号转换成数字信号。
这一级的原理图如图3.2：
图3.2 ADC0832数据采集转换电路图
3.1.3 单片机最小系统模块
这部分主要是由STC89C52单片机组成的一个最小系统，通过单片机来控制ADC0832的信号采集转换以及对串口通信的控制。
该级电路原理图如图3.3：
图3.3 单片机最小系统电路图
3.1.4 模块
模块主要通过USB转串口线来与LCD1602液晶显示屏通信将ADC0832采集和转换的数据传给LCD1602显示出所测得液面高度。
模块的原理图如图3.4：
图3.4 电路图
3.2 电路参数计算及元器件的选择
3.2.1 元器件的选择
设计所用仪器及器件如下表1：
3.3 特殊元器件介绍
这一节将对设计过程中用到的一些特殊元器件进行介绍，主要是介绍该特殊元器件的内部结构，工作原理，及使用时应该注意的事项。
3.2.1 ADC0832
ADC0832的内部原理结构图如下图3.5：
图3.5 ADC0832的内部原理结构图
ADC0832主要技术指标如下：
(1) 高阻抗状态输出
(2) 分辨率：8 位(0~255)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b337f164702967633f4d4f0c159c9e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d66c80217057619ad40e243c13c67400/" rel="bookmark">
			基于51单片机的教室智能照明灯控制系统仿真原理图方案设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案框图：
原理图：
仿真图：
系统控制模块的硬件构成及简介
系统控制单元是以AT89S51单片机主控模块为核心，其它外围电路主要包括：环境光采集电路、时钟模块、热释红外传感器模块、看门狗模块、按键电路、EEPROM存储模块、超时报警模块、数码管显示模块。
环境光模块采用光敏三极管来检测环境光的强度，有光照时，电阻减小，随着光照强度的减弱，电阻逐渐增大，把光信号转化成电信号，实现对光强度的检测。
人体存在传感器模块采用HP-208是基于红外线技术的智能产品，实现对人体存在的检测。
硬件时钟模块采用具有充电能力的低功耗，具有临时性存放数据的RAM寄存器的实时时钟芯片DS1302。该电路的接口简单、价格低廉、使用方便，被广泛的使用。
系统数据存储及故障保护部分由X5045组成，X5045是一种串行通讯的512字节EEPROM，同时兼有看门狗和电源监控功能键盘模块。
2.2系统控制的主要硬件电路
考虑到本系统安装时受环境影响因素比较多，且教室控制设备中的人体存在传感器、光敏三极管等经常会因环境情形变化而不稳定，所以在设计过程中，电子元器件的选用、线路布置和设备的安放要充分考虑到抗干扰问题。
2.2.1系统主控电路
本系统的主控模块采用AT89S51作为主控芯片，它是一种低功耗，8位CMOS工艺处理器，具有8K在线可编程Flash存储器，片内的Flash可多次编程，为在线编程提供了方便。片内有128字节的RAM，4KB的EEPROM，由于合理的安排使用片内RAM空间，所以没有片外扩展的RAM，使电路结构简洁。该芯片的主要特征见如表2.1：
表2.1 AT89S51主要特征
AT89S51引脚 外围器件引脚 说明
P0. 0-P0. 7 ULN2803 数码管段码驱动接口
P2. 0-P2. 7 PNP-9012基极 数码管段码驱动接口
P1. 0 X5045SI X5045串行输入端
P1. 1 X5045SCK X5045串行时钟端
P1. 2 X5045CS X5045片选端
P1. 3 X504550 X5045串行输出端
P1. 4 工作状态指示灯
P1. 5 DS1302CLK DS1302时钟线
P1.6 DS1302I/O DS1302数据线
P1. 7 DS1302RST DS1302复位线
P3. 0- P3. 1 数据采集输入端
P3. 3 人体存在传感器输出信号端
P3. 4 超时报警信号输入端
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d66c80217057619ad40e243c13c67400/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb0d5bccb77efb3f22e60261f4a9ee1/" rel="bookmark">
			基于51单片机的智能窗帘仿真方案原理图设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统总体方案 （附文件）
通过上述对各个模块介绍，我们最终选择了采用STC89C52作为的主控芯片，采用光敏电阻采集环境光强通过ADC0832转换成数字信息然后由单片机处理得出环境光强的情况，DS1302时钟芯片获取当前的时间信息，系统采用LCD1602实时显示光强、时间、日期和模式。通过四个独立按键可以进行切换模式模式、设置时间日期、设置光强限值、定时时间等并且系统还配备了红外遥控的功能。同时具有两个限位开关防止窗帘电机过度转动而造成窗帘损坏。
本设计的具体的系统方案如下图2.1所示。
框图：
原理图：
DS1302的工作原理
在使用时候由于DS1302的数据引脚是双向通讯的，而51单片机引脚属于弱上拉如果不添加10K的上拉电阻会导致弱上拉时端口的电平翻转而通讯不成功，而RST和SCLK是单向的不外加上拉也可以，添加也可以。在本设计中将这三个端口都添加了10K上拉电阻。具体的电路图如图3.10所示。
ADC0832的工作原理
步进电机原理构造
步进电机是一种将电脉冲转化为角位移的执行机构。通俗的说：也就是当步进驱动器接收到一个脉冲信号，它就驱动步进电机按设定的方向转动一个固定的角度（即步进角）。可以通过控制脉冲的个数来控制角位移量，从而达到准确定位的目的；同时可以通过控制脉冲的频率来控制电机转动的速度和加速度，从而做到调速的目的。
步进电机28BYJ48型四相八拍电机，工作电压为：DC5V-DC12V。当对步进电机施加一系列连续不断地控制脉冲时，它可以连续不断转动。每一个脉冲信号对应步进电机的某一相或两相绕组的通电状态改变一次，也就对应转子转过一定的角度（一个步距角）。当通电状态的改变完成一个循环时，转子转过一个齿距。四相步进电机可以在不同的通电方式下运行，常见的通电方式有单四拍（单相绕组通电）：A-B-C-D-A….，双四拍（双相绕组通电）:AB-BC-CD-DA-AB…;八拍：A-AB-B-BC-C-CD-D-DA-A…。
ULN2003与单片机的连接
本设计中采用ULN2003驱动步进电机，设计中将单片机的P1.0P1.3引脚分别接到ULN2003的R1R4上，输出端Q1~Q4接到28BYJ-48步进电机的蓝、粉、黄、橙四根线上也就是ABCD四相上。如图3.14所示。
HX1838红外一体接收头的介绍
一体化红外接收头指的是红外接收相关电路被集成在一个元件中。HX1838就是这样一个集成的一体化红外接收头，内部集成了红外监测二极管、放大器、积分电路、限幅器、比较器、带通滤波器等电路。当红外监测二极管监测到红外信号，然后将信号传送到放大器和限幅器，限幅器将脉冲幅度控制在一定范围，而不管红外发射装置和接收头的距离远近。交流信号进入带通滤波器，带通滤波器可以通过30khz到60khz的负载波，通过解调电路和积分电路进入比较器，比较器输出高低电平，还原出发射装置的信号波形
HX1838连接到单片机的P3.2外部中断输入引脚上，这样有接收到红外信号就可以第一时间响应进入解码阶段。而51单片机引脚属于弱上拉如果不添加10K的上拉电阻会导致弱上拉时端口的电平翻转而通讯不成功，所以在HX1838信号引脚上添加一个10K的上拉电阻。HX1838与单片机连接电路图如图3.16所示。
系统软件部分设计 部分代码：
/************************************************************* 智能窗帘 补充说明： ***************************************************************/ #include&lt;reg52.h&gt;	//头文件 #include&lt;LCD1602.h&gt; #include&lt;DS1302.h&gt; #include&lt;28BYJ48.h&gt; #include&lt;EEPROM.h&gt; #include&lt;ADC0832.h&gt; #include&lt;HW.h&gt; #define uchar unsigned char//宏定义 #define uint unsigned int /*******************引脚定义*********************/ sbit key_mode = P1^0;	//设置键 sbit key_jia = P1^1;	//加值键 sbit key_jian = P1^2;	//减值键 sbit key_ok = P1^3;	//确定键 sbit sw1=P3^7; //全开 限位开关 sbit sw2=P3^6; //全关 限位开关 /*******************变量定义*********************/ uchar light_up,light_down;//存储光强上、下限值 uchar set_f=0;	//设置选择标记，=0非设置，=1设置年，=2设置月，=3设置日，=4设置时，=5设置分，=6设置秒 // =7设置定时-时，=8设置定时-分，=9设置定时-开关，=10设置窗帘打开/关闭 //	=11设置光强上限，=12设置光强下限，=13设置校准窗帘位置 uchar num;	//计数变量 uchar ds[4];	//定时控制开时、分、控制关时、分 uchar mode=0;	//模式标记。=0手动，=1定时，=2光控 uchar light; //存储光强 uint moto_num=0; //记录窗帘位置 uchar moto_state=0;//窗帘状态，=0已经关闭，=1处于运转过程中，=2已经打开 bit moto_f=0;	//标记当前控制状态，=0控制关，=1控制开 uchar code display_mode[3][3]={"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cb0d5bccb77efb3f22e60261f4a9ee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4848feb08ecfdf3f8a5b4abb79d84838/" rel="bookmark">
			基于STM32单片机的大棚温湿度环境参数监测无线蓝牙APP控制方案原理图程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的发展，农业科技也一步步走进我们的生活。蔬菜大棚的增多，人们对其性能要求也越来越高。特别是要提高其生产效率，对大棚的自动化程度要求也越来越高。单片机技术的逐步成熟，加快了我们走向现代化、科技自动化的进程。 本设计由STM32单片机、风扇控制电路、温湿度传感器电路、1602液晶显示电路+蓝牙模块电路和电源电路组成。通过温湿度传感器检测温湿度，并在液晶上和APP上实时显示。当湿度超过75度，APP发出报警信息，通过APP发送指令“O”，风扇启动。通过APP发送指令“C”，风扇关闭。
硬件电路的设计 （末尾附文件）
3.1系统的功能分析及体系结构设计
3.1.1系统功能分析
本设计由STM32单片机+风扇控制电路+温湿度传感器电路+1602液晶显示电路+蓝牙模块电路+电源电路组成。
1、通过温湿度传感器检测温湿度，并在液晶上和APP上实时显示。
2、当湿度超过75度，APP发出报警信息
3、通过APP发送指令“O”，风扇启动。
通过APP发送指令“C”，风扇关闭
3.1.2系统总体结构
本系统具体框图如下图所示：
原理图：
5V散热风扇控制电路（高电平有效）设计
散热风扇的工作原理是按能量转化来实现的，即：电能→电磁能→机械能→动能。由于单片机无法直接驱动振动风扇，故选择三极管9012来实现对散热风扇的控制，电阻为限流电阻，限流作用，以保护三极管。当单片机的相关控制引脚为高电平时，三极管导通，风扇正常工作；否则，风扇不转动。其驱动电路的原理图如下图所示。
JDY-30蓝牙模块电路设计
蓝牙模块是指集成蓝牙功能的芯片基本电路集合，用于无线网络通讯。本蓝牙模块就是为了只能无线数据传输而专门打造的，本模块支持串行接口，支持SP蓝牙串口协议，具有成本低、体积小、收发灵敏性高等特点，只需配备少许的外围元件就能实现大功能。
一、模块特点
（1）支持蓝牙 SPP 串口协议
（2）内置 PCB 天线
（3）支持 UART 接口
（4）蓝牙 Class 2
（5）数据传输比 BLE 蓝牙快、可达到 8K 每秒以上的速率
（6）支持与 SPP 主蓝牙模块连接通信（JDY-30 为从 SPP 蓝牙模块）
（7）支持与电脑 SPP 蓝牙通信
（8）支持 Android 手机 SPP 通信
二、产品应用范围
（1） POS 机
（2）蓝牙打印机
（3）蓝牙玩具
（4）蓝牙高速数据传输产品应用
（5）小家电
（6）汽车电子
三、模块技术参数
（1）工作电压：3.3V-6V
（2）工作温度：-40℃-85℃
（3）天线：PCB板载天线
（4）功耗：19mA
四、模块接口说明
（1）RXD 串口输入，电平为TTL电平
（2）TXD 串口输出，电平为TTL电平
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4848feb08ecfdf3f8a5b4abb79d84838/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b405c453e95d1d5c70198673dbedc9c5/" rel="bookmark">
			基于STM32单片机的智能药盒定时提示吃药喂水蓝牙APP方案原理图设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案框图： 原理图： JDY-30蓝牙模块电路设计
蓝牙模块是指集成蓝牙功能的芯片基本电路集合，用于无线网络通讯。本蓝牙模块就是为了只能无线数据传输而专门打造的，本模块支持串行接口，支持SP蓝牙串口协议，具有成本低、体积小、收发灵敏性高等特点，只需配备少许的外围元件就能实现大功能。
一、模块特点
（1）支持蓝牙 SPP 串口协议
（2）内置 PCB 天线
（3）支持 UART 接口
（4）蓝牙 Class 2
（5）数据传输比 BLE 蓝牙快、可达到 8K 每秒以上的速率
（6）支持与 SPP 主蓝牙模块连接通信（JDY-30 为从 SPP 蓝牙模块）
（7）支持与电脑 SPP 蓝牙通信
（8）支持 Android 手机 SPP 通信
二、产品应用范围
（1） POS 机
（2）蓝牙打印机
（3）蓝牙玩具
（4）蓝牙高速数据传输产品应用
（5）小家电
（6）汽车电子
三、模块技术参数
（1）工作电压：3.3V-6V
（2）工作温度：-40℃-85℃
（3）天线：PCB板载天线
（4）功耗：19mA
四、模块接口说明
（1）RXD 串口输入，电平为TTL电平
（2）TXD 串口输出，电平为TTL电平
（3）GND 接GND
（4）VCC 接3.3V-6V
蓝牙模块接口电路图如下图所示。
LED信号指示灯电路设计
LED灯即发光二极管，它是半导体二极管的一种，可以把电能转化成光能。发光二极管与普通二极管一样是由一个PN结组成，也具有单向导电性。在电路中，电阻的作用是限流，保护LED灯。只要单片机的控制引脚拉低，则LED灯亮，否则，LED灯不亮。其具体电路原理图如下图所示。
二挡拨动开关检测电路设计
拨动开关是通过拨动开关柄使电路接通或断开，从而达到切换电路的目的的。拨动开关常用的品种有单极双位、单极三位、双极双位以及双极三位等，它一般用于低压电路，具有滑块动作灵活、性能稳定可靠的特点，拨动开关主要广泛用于:各种仪器/仪表设备，各种电动玩具，传真机，音响设备，医疗设备，美容设备，等其它电子产品领域。
简单的说，拨动开关就是通过拨动其执行机构（开关柄），来接通或断开电路。
通过拨动开关实现对信号的切换，电阻为上拉电阻。当二档拨动开关拨下去时，单片机控制引脚为低电平。当二档拨动开关拨上去时，单片机控制引脚为高电平。进而实现对信号的完美切换。其电路图如下图所示。
程序流程图
#include "pbdata.h" _record_obj record[NUM_RECORD];	//记录结构体 vu8 box_open=0;//记录药盒打开的状态，每一个二进制位代表一个药盒 u8 length_record = 0;//记录的个数 u8 count_save_record = 0;//记录保存的次数，需要保存时加1，完成一次保存则减1 void RecordInit(void)//记录初始化 { u8 i; //读写flash数据均为2个字节，所以数据长度为结构体数据长度除以2 STMFLASH_Read(ADDR_RECORD, (uint16_t *)&amp;record[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b405c453e95d1d5c70198673dbedc9c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24607345d85015f63aa429a0158da892/" rel="bookmark">
			《YOLO小目标检测》专栏介绍 &amp; CSDN独家改进创新实战&amp;专栏目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💡💡💡Yolo小目标检测，独家首发创新（原创），适用于Yolov5、Yolov7、Yolov8等各个Yolo系列，专栏文章提供每一步步骤和源码，带你轻松实现小目标检测涨点
💡💡💡重点：通过本专栏的阅读，后续你可以结合自己的小目标检测数据集，在网络不同位置（Backbone、head、detect、loss等）进行魔改，实现小目标涨点和创新！！！
专栏介绍：
✨✨✨解决小目标检测难点并提升小目标检测性能；
🚀🚀🚀小目标、遮挡物性能提升和创新；
💡💡💡 工业界小目标检测性能提升和部署可行性；
🍉🍉🍉持续更新中，定期更新不同数据集涨点情况；
layers parametersGFLOPskb mAP50yolov816830058438.161030.755Wasserstein loss16830058438.161030.784yolov8_smallob207292117212.261370.878yolov8_SEAM21931093318.363310.785yolov8_SPD174359873949.273940.875yolov8_EVC217729352311.5145130.779yolov8_BiFPN16830058498.161040.766yolov8_ContextAggregation19530080928.161210.759yolov8_EMA19230067398.161140.766yolov8_DCNV326428923177.958920.765yolov8_MCALayer20925456597.251940.769yolov8_BiFormerBlock204335617922.468000.758yolov8_LSKblockAttention20133433338.767840.775yolov8_GPFN21629861318.160790.766yolov8_C2f_Pconv17727168837.655370.758yolov8_ODConv17930121107.961210.76yolov8_TripletAttention20130064438.261200.79yolov8_ChannelAttention17131374277.864280.815yolov8_DySnakeConv22933562878.568220.77yolov8_MultiSEAM3255742291117110.87yolov8_MobileViTAttention241395765911.179920.799yolov8-RFA25830194398.261660.765yolov8_BasicRFB30334402358.970400.762yolov8_RepViTBlock18633383877.967710.791yolov8-goldyolo359601512311.9121230.768yolov8_DualAttention18646048198.392360.766 目录
1.小目标检测介绍
1.1 小目标定义
1.2 难点
2. 本专栏小目标数据集
3.小目标专栏难点优化方向
3.1 合理的数据增强
3.2 网络多尺度
3.2.1 多头检测器
3.2.2 BiFPN高效双向跨尺度连接和加权特征融合
3.2.3 小目标到大目标一网打尽，轻骨干重Neck的轻量级目标检测器GiraffeDet
3.2.4 多分支卷积模块RFB
3.2.5 GOLD-YOLO，遥遥领先
3.3 loss优化
3.3.1 Wasserstein Distance Loss
3.4 注意力机制
3.4.1SEAM注意力机制
3.4.2 即插即用的多尺度融合模块EVC
3.4.3 微小目标检测的上下文增强和特征细化网络ContextAggregation
3.4.4 EMA跨空间学习的高效多尺度注意力 | ICASSP2023
3.4.5 动态稀疏注意力BiFormer | CVPR 2023 3.4.6 LSKblockAttention | ICCV 2023 3.4.7 TripletAttention注意力
3.4.8 通道优先卷积注意力（CPCA）| 中科院 2023.6
3.4.8 多尺度MultiSEAM
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24607345d85015f63aa429a0158da892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fcbd0f86d66c2c176fb08986f2fa83c/" rel="bookmark">
			百度飞桨(PaddlePaddle) - PP-OCRv3 文字检测识别系统 预测部署简介与总览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 预测部署简介与总览 本章主要介绍PP-OCRv2系统的高性能推理方法、服务化部署方法以及端侧部署方法。通过本章的学习，您可以学习到：
根据不同的场景挑选合适的预测部署方法PP-OCRv2系列模型在不同场景下的推理方法Paddle Inference、Paddle Serving、Paddle Lite的推理部署开发方法 1.1 简介 在前面几个章节中，我们通过模型训练的方法，得到了训练好的模型，在使用它去预测的时候，我们首先需要定义好模型，然后加载训练好的模型，再将预处理之后的数据送进网络中进行预测、后处理，得到最终的结果。使用这种方法去进行预测，调试方便，但是预测效率比较低下。
针对上面的问题，对于训练得到的模型，一般有下面2种离线预测的方式。
基于训练引擎推理，也就是和训练使用同一套引擎，它调试方便，便于我们迅速定位问题，验证正确性。多为Python语言。基于预测引擎推理，将训练得到的模型进行转换，去掉与推理无关的部分，使用这种方法可以加速预测。多为Python语言或C++。 二者具体的区别如下所示。
基于训练引擎推理基于预测引擎推理特点1. 和训练使用同一套引擎
2. 预测时需要定义网络模型
3. 不适合系统集成1. 需要转换模型，去掉与推理无关的部分
2. 预测时无需定义网络模型
3. 适合系统集成编程语言多为PythonPython或者C++预测步骤1. Python端定义网络结构
2. 准备输入数据
3. 加载训练模型
4. 执行预测1. 准备输入数据
2. 加载模型结构和模型参数
3.执行预测 在实际离线预测部署中，更推荐基于预测引擎进行推理。
从应用场景来看，飞桨针对不同应用场景，提供了下面一些推理部署方案。
飞桨的不同部署方案
具体地，PaddleOCR 针对不同应用场景，提供了三种预测部署方案。
Inference的离线预测，这种方式主要应用在对预测响应的及时性要求不高，特别是需要大量图片预测的场景。像文档电子化、广告信息提取等。虽然不能及时响应预测请求，但是没有网络延时，计算效率比较高，数据安全性很高。Serving服务化部署，这种方式主要应用在对预测响应的及时性要求很高的场景，像商业化OCR的API接口、实时拍照翻译、拍题等场景。虽然这种方式能及时对预测需求及时响应，但是网络耗时开销比较大，GPU利用率往往不高，而且存在数据安全风险。Lite端侧部署，这种方式主要希望模型部署到手机、机器人等端侧设备上，主要考虑部署方便和数据安全性，像手机APP里面身份证识别、银行卡识别，工业应用场景的仪表监控识别等。这种方法，对OCR模型的大小比较敏感。虽然没有网络延时，数据安全性很高，但是由于算力限制，预测效率不高。 本章基于PP-OCRv2，介绍文本检测、识别以及系统串联预测推理与部署过程。
1.2 环境准备 体验本章节内容需要首先下载PaddleOCR代码，安装相关依赖，具体命令如下。
import os os.chdir("/home/aistudio") # 下载代码 !git clone https://gitee.com/paddlepaddle/PaddleOCR.git os.chdir("/home/aistudio/PaddleOCR") # 安装运行所需要的whl包 !pip install -U pip !pip install -r requirements.txt # VQA任务中需要用到该库 !pip install paddlenlp==2.2.1 # 导入一些库 import cv2 import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fcbd0f86d66c2c176fb08986f2fa83c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee38671d5113573aa9268cd7b2fc9592/" rel="bookmark">
			在Spring Boot项目中使用Redisson
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Spring Boot项目中使用Redisson Redisson简介 Redisson官网仓库
Redisson中文文档
Redission是一个基于Java的分布式缓存和分布式任务调度框架，用于处理分布式系统中的缓存和任务队列。它是一个开源项目，旨在简化分布式系统的开发和管理。
以下是Redission的一些主要特点和功能：
分布式缓存：Redission支持分布式缓存，可以将数据存储在分布式环境中，以提高性能和可用性。它提供了各种数据结构，如分布式Map、Set、List、Queue等，可以用来存储和操作数据。
分布式锁：Redission提供了分布式锁的功能，允许多个线程或多个应用程序在分布式环境中协调对共享资源的访问，以避免竞态条件。
分布式队列：Redission支持分布式队列，可以用来实现任务调度和消息传递。这对于构建分布式系统中的异步处理非常有用。
分布式发布/订阅：Redission支持发布/订阅模式，允许不同部分的应用程序通过发布消息和订阅消息来进行通信。
高可用性：Redission可以配置为在分布式环境中具有高可用性，通过数据复制和故障转移来确保系统的稳定性。
丰富的客户端库：Redission提供了多种客户端库，可以与不同的Java应用程序和框架集成，包括Spring、Spring Boot等。
支持多种数据存储后端：Redission可以与多种数据存储后端集成，包括Redis、AWS Elasticache、Apache Ignite等，以适应不同的部署需求。
总之，Redission是一个强大的Java库，用于构建和管理分布式系统中的缓存和任务调度。它可以帮助开发人员简化分布式系统的开发，并提供了丰富的功能来处理分布式环境中的常见问题。
配置和使用Redisson 1. 添加Redisson依赖： 在你的Spring Boot项目的Maven或Gradle配置中添加Redisson的依赖，就像前面提到的一样。确保使用适当的版本。
Maven 示例：
&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.16.5&lt;/version&gt; &lt;!-- 请使用最新版本 --&gt; &lt;/dependency&gt; 2. 创建Redisson配置类： 在你的Spring Boot项目中创建一个配置类，用于配置Redisson。这个配置类可以包含Redis服务器的连接信息，例如主机地址、端口和密码等。
import org.redisson.Redisson; import org.redisson.api.RedissonClient; import org.redisson.config.Config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RedissonConfig { @Bean public RedissonClient redissonClient() { Config config = new Config(); config.useSingleServer() .setAddress("redis://localhost:6379") // Redis服务器地址和端口 .setPassword("your_password"); // 如果有密码，请设置密码 return Redisson.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee38671d5113573aa9268cd7b2fc9592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6065c788f9dca24149645a2ce79ae41b/" rel="bookmark">
			问 ChatGPT 关于 GPT 的事情：数据准备篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、假如你是一名人工智能工程师，手里有一个65B的GPT大模型，但你需要一个6B左右的小模型，你会怎么做？ 答：作为人工智能工程师，如果我手里有一个65B的GPT大模型，而我需要一个6B左右的小模型，我会采取以下步骤：
数据子集选择：对于训练大模型的数据集，我会从中选择一个子集，以便在构建小模型时使用。这个子集应该保留足够的多样性和代表性，以确保小模型在各种任务上的表现仍然良好。
参数剪枝：我会使用剪枝技术来减少大模型的参数数量。剪枝可以通过删除不重要的连接和神经元来减小模型的规模。这可以通过诸如敏感度分析、结构化剪枝、稀疏训练等技术来实现。
微调：在剪枝后，我会对小模型进行微调，以便在尽可能保留性能的同时进一步优化其参数。微调可以使用较小的学习率和较少的迭代次数来防止过拟合。
模型压缩：如果小模型的大小仍然超过所需的6B左右，我可以考虑使用模型压缩技术。这包括权重量化、参数共享、低秩分解等方法，以减小模型的内存占用。
通过以上步骤，我可以将原始的65B的GPT大模型转换为一个6B左右的小模型。
它只提到了剪枝，但是不可能剪掉90%吧，我试试再引导它回答最优方案。
二、你选择的数据子集应当包含什么样的数据？ 对于选择数据子集，可以根据具体的任务和需求来确定所包含的数据类型和内容。一般来说，数据子集应当包含以下几种数据：
目标数据：针对所解决的问题或任务，选择与之相关的目标数据。比如，如果是进行情感分析，数据子集应包含带有情感标签的文本数据。
多样性数据：确保数据子集具有多样性，包含不同领域、不同类型、不同长度的数据样本。这样可以提高模型的泛化能力和适应性。
平衡数据：在数据子集中，应尽量保持各类别或标签的平衡，避免某一类别的样本过多或过少，以免引发模型偏见或不准确性。
高质量数据：选择高质量的数据样本，确保数据的准确性、完整性和可靠性。可以通过专业的数据源、标准化的标注流程等来保证数据质量。
这里，我当然知道长文本+短文本+新闻+论文/百科就能覆盖全部，但是它没有直接回答出来，还需要引导。
三、假设你只能抓取四个网站上的全部数据，你会如何选择网站来准备GPT的预训练数据？ 对于准备GPT的预训练数据，我会选择以下四个网站来抓取全部数据：
Wikipedia：作为一个丰富的知识库，Wikipedia包含了大量的文章和信息，可以提供广泛的领域知识和语言表达。
Reddit：作为一个社交论坛，Reddit上有各种不同主题的讨论帖和评论，可以提供丰富的实时、多样化的对话内容。
Stack Exchange：作为一个问答社区，Stack Exchange上有丰富的专业领域问题和答案，可以提供专业知识和相关讨论。
News websites：选择一家新闻网站，如BBC、CNN或New York Times，可以获得各种新闻报道和评论，涵盖了全球范围内的各种话题和事件。
这样的选择可以提供广泛的主题、语言风格和领域知识，为GPT的预训练提供多样性和通用性。
这里跟我的预想完全一样：新闻站点提供长文本，Rediit提供对话，SE提供开放问答，也就是指令微调数据，WIKI提供知识。
四、再看看中文的： 针对准备GPT的预训练数据，我会选择以下四个中文网站：
百度百科（https://baike.baidu.com）：作为最大的中文百科网站，百度百科涵盖了广泛的主题和领域。其中的文章丰富多样，可以提供丰富的知识和语言样本。
新浪新闻（https://news.sina.com.＊＊＊娱乐等各个领域，能够提供丰富的实时信息和语言样本。
知乎（https://www.zhihu.com）：知乎是一个知识问答社区，用户在该平台上提问、回答和分享各种话题。这里聚集了大量有深度和专业知识的用户，他们的回答和讨论能够提供多样化的语言样本。
豆瓣读书（https://book.douban.com）：豆瓣读书是一个图书推荐和社交平台，用户可以在这里发布书评、评分、评论和讨论。这些评论和讨论覆盖了各种类型的书籍，从小说到学术著作，提供了多样化的语言样本。
这四个网站涵盖了不同领域的知识和信息，能够提供丰富的中文文本数据，有助于训练出更全面和多样化的GPT模型。
百科提供知识，新闻提供长文本，知乎提供开放问答，豆瓣读书不知道干嘛的，如果是小组可以提供对话。
五：我可不可以拿笔趣阁等小说文本代替新浪新闻，为GPT提供长文本的训练数据？ 你可以使用笔趣阁等小说文本作为GPT的训练数据，但需要注意以下几点：
版权问题：确保你有合法的授权或许可，以使用这些小说文本作为训练数据。尊重作者的权益是非常重要的。
文本质量：小说文本和新闻文本在内容和风格上存在很大差异。小说通常更加虚构和富有想象力，而新闻更加注重事实和客观性。因此，使用小说文本作为训练数据可能会影响到GPT在生成新闻文本时的准确性和可靠性。
数据多样性：为了使GPT具有更好的泛化能力，建议使用多样性的训练数据。单一来源的数据可能会导致模型在特定领域或风格上过拟合。
和我预想的一样，是可行的。
六、你推荐的网站里面不包含中文多轮对话数据集，请列举几个包含中文多轮对话的网站。 对于中文多轮对话数据集，以下是一些包含的网站：
THU Chat Corpus：清华大学提供的多轮中文对话数据集，包含了来自微博、论坛等多个领域的对话数据。
DuConv：百度开放的多轮中文对话数据集，主要包括了知识问答和聊天对话两种类型。
ECDT：哈尔滨工业大学提供的多轮中文对话数据集，覆盖了不同领域的实际对话情景。
七、请判断以下网站中是否包含中文多轮对话：百度贴吧、新浪微博、豆瓣小组 以下是对三个网站的判断：
百度贴吧：百度贴吧是一个中文社区网站，用户可以在各个贴吧中进行中文多轮对话，因此包含中文多轮对话。
新浪微博：新浪微博是一个中文社交媒体平台，用户可以发表微博并与其他用户进行评论和互动，因此也包含中文多轮对话。
豆瓣小组：豆瓣小组是一个中文社区网站，用户可以在小组中进行讨论和互动，因此也包含中文多轮对话。
这一点和人类表现一样，你不限定范围直接问它，它就想不到，但是如果你给定一个范围让它判断，它就能判断出来。
八、GPT模型的模型训练分为哪几个阶段？这些阶段分别使用什么样的数据集？ GPT模型的模型训练分为两个阶段：预训练和微调。
在预训练阶段，GPT模型使用了一个大规模的无监督文本数据集。通常情况下，这个数据集是从互联网上的各种来源收集而来的，比如维基百科、新闻文章、论坛帖子等。预训练的目标是让模型学会预测下一个词语出现的概率，通过这个任务来学习语言的统计规律和语义信息。
在微调阶段，GPT模型使用了一个特定的监督任务的数据集。这个数据集通常是由人工标注的，包含了输入和对应的目标输出。比如，在生成对话的任务中，数据集可以由对话文本和对应回答组成。微调的目标是让模型在特定任务上表现得更好，通过有监督学习的方式进一步调整模型参数。
可以，不过微调比预训练复杂得多。需要展开叙述以下。
九、给你一个语言生成模型，他能根据一段文本生成下一段文本，如何把它变成一个对话模型？ 要将一个语言生成模型转变为对话模型，可以引入一个上下文环境。传统的语言生成模型会根据前面的文本生成下一段文本，而对话模型则可以根据前面的对话历史生成下一段对话。为此，我们可以将对话历史作为模型输入的一部分，并训练模型生成下一段对话。
具体来说，可以将对话历史拼接成一个长文本，并加上一些特殊标记来分隔对话历史和当前回答的文本。这样，模型可以根据整个文本序列来生成回答。
在训练时，我们需要提供包含对话历史和模型期望生成的回答的样本对。模型会学习如何根据对话历史生成合适的回答。
十、你现在有了一个模型，可以进行语言生成和多轮对话，如何让它执行多种自然语言任务，例如做规划，总结文本和做翻译？ 对于这些自然语言任务，可以通过针对特定任务的指导性示例来训练模型。例如，对于规划任务，可以提供一些关于规划的示例问题和相应的答案，让模型学会生成合适的规划建议。对于总结文本任务，可以提供一些文本段落和相应的摘要，让模型学会总结文本的能力。对于翻译任务，可以提供一些双语对照的句子，让模型学会将一种语言翻译成另一种语言。
在训练过程中，可以使用一种称为"无监督预训练"的方法，先让模型自己学习语言的一般模式和结构，然后再使用有监督的任务来进一步微调模型。这样做可以提高模型在各种自然语言任务上的表现。
正确答案是加上提示词把这些都变成对话任务。
十一、提示词的作用是什么 提示词在对话中起到引导和提示的作用。它们可以帮助对话参与者更好地理解问题的意思，提供更准确的回答。提示词可以是具体的关键词或短语，也可以是一段描述性的句子，都有助于限定对话的主题和范围。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6065c788f9dca24149645a2ce79ae41b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55220ca0afde131f932e3789d70fd1ad/" rel="bookmark">
			Eclipse4.28.0搭建Groovy开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 groovy 简介2 为什么选择 eclipse3 安装 Eclipse3.1 安装3.2 安装 Java Development Tools 和 groovy 插件 4 创建 Groovy 工程 1 groovy 简介 groovy 即是编译型语言,也是解释性语言.可以经过编译后运行在 JVM 上,也可以当做脚本语言使用 groovy 命令解释.兼有编译型语言与解释性语言特点,语法风格和特色也是多种语言的结合.如:
定义变量可以限制赋值类型(使用 Boolean. BigDecimal, Integer, Integer, Float, Double, String, ArrayList(List), LinkedHashMap(Map)),也可以使用 def 不限制赋值类型,赋值后还可以自由转换变量引用可以是编译语言风格(print(var)),也可以是脚本语言风格(print “$var”)函数有普通函数和闭包函数,闭包函数用法也是多样化正则表达式偏 shell脚本语言且又差距较大 语法特性:
功能强大，例如提供了动态类型转换、闭包支持函数式编程，不需要main 函数默认导入常用的包类不支持 default 作用域,且默认作用域为 publicGroovy 中基本类型也是对象，可以直接调用对象的方法支持 DSL（Domain Specific Languages 领域特定语言）和其它简洁的语法，让代码变得易于阅读和维护Groovy 是基于 Java 语言的，所以完全兼容 Java 语法 官方文档: The Apache Groovy programming language - Documentation (groovy-lang.org)
2 为什么选择 eclipse groovy 算是小众类语言,也是脚本语言,脚本语言的特点就是结构化不强,没有编译语言的对象/函数/参数/功能提示,而 groovy 恰好有这个提示功能,且支持的 IDE 很少,仅有 Eclipse/IDEA/NetBeans.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55220ca0afde131f932e3789d70fd1ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08c983f12c7727f93a77328bc45fb84a/" rel="bookmark">
			免费GPU线上跑AI项目实践（Stable Diffusion）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明： 本文内容来自于对DataWhale的开源学习项目——免费GPU线上跑AI项目实践的学习，引用了多处DataWhale给出的教程
创建项目： 初始化开发环境实例： 部署模型： 在网页终端输入
tar xf /gemini/data-1/stable-diffusion-webui.tar -C /gemini/code/ tar xf /gemini/data-1/cache.tar -C /root/ cp /gemini/data-1/frpc_linux_amd64 /root/miniconda3/lib/python3.10/site-packages/gradio/frpc_linux_amd64_v0.2 chmod +x /root/miniconda3/lib/python3.10/site-packages/gradio/frpc_linux_amd64_v0.2 cd /gemini/code/stable-diffusion-webui python launch.py --deepdanbooru --share --theme dark --xformers --listen --gradio-auth qdy:123456 当命令窗口出现如下两个网址时表示部署成功，可以复制右侧的外部访问网址访问webui
访问这个网址时，会出现一个登录页面，账号 qdy 密码123456
体验自己的stable diffusion： 输入提示词
emmmmmm..........................
我不太懂提示词怎么写才能正常图片
这俩算正常的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad6e418a01eb9e75b8e9d6c058721dd/" rel="bookmark">
			Python爬虫实战 | 爬取网易云音乐评论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 爬取网易云音乐评论
01 网页分析 为爬取网易云音乐的评论内容，本案例将提供思路简单的处理方式，网易云音乐一般会提供API，以JSON对象返回开发者请求的内容，而获取歌曲评论的API格式为“http：//music．163．com/api/v1/resource/comments/R_SO_4_”+歌曲ID，一般评论的JSON对象显示的评论条数有限，为了获得完整的评论内容，需要加上参数单条JSON加载评论条数(limit)和偏移量(offset)，然后发送GET请求，如图17-1所示，JSON会显示评论内容和评论总数，基于以上参数可以间隔发送请求以获得全部评论内容，即可编写爬虫。
■ 图17-1网页分析JSON对象内容
02 编写爬虫 关于正则表达式处理用于分析的文本，在文本分析中，为了提高准确率以及避免程序产生bug，需要预先去除一些不必要的字符，如标点符号以及非文字的表情等特殊字符，这些都会对文本分析造成干扰，通常采取re．sub(pat, “”, Str)，pat为预先编译的正则表达式，将去除的字符替换为空字符，下面将提供一些正则表达式的思路。
(1) re．compile(‘＼t|＼n|＼．|-|： |； |＼)|＼(|＼?|(|)|＼|"|＼u3000’)，用于去除标点符号和空格。
(2) 利用正则表达式特性，［^**］表示不匹配此字符集中的任何一个字符，可以反选需要的字符集，除了基本的［a-zA-Z0-9］匹配，如果采取Unicode编码方式，汉字的Unicode范围为＼u4e00＼u9fa5，数字的Unicode范围为＼u0030＼u0039，大写字母的Unicode范围为＼u0041＼u005a，小写字母的Unicode范围为＼u0061＼u007a，韩文的Unicode范围为＼uAC00＼uD7AF，日文的Unicode范围为＼u3040＼u31FF，根据文本分析的需要，保留需要的字符。
03 运行结果 【例17-1】分析著名民谣歌手赵雷的代表单曲《成都》(歌曲ID： 436514312)，评论数有40多万，关键词云如图17-2所示。
■ 图17-2单曲《成都》词云分析结果
【例17-2】分析知名日本电视剧《假面骑士Build》的主题曲Be the One(歌曲ID： 530986958)，评论数2万左右，采用自定义遮罩，关键词云如图17-3所示。
■ 图17-3单曲Be the One词云分析结果
最后： 【想要学习爬虫的朋友们 我这里整理了很多Python学习资料上传到CSDN官方了，有需要的朋友可以扫描下方二维码进行获取】
一、学习大纲 二、开发工具 三、Python基础材料 四、实战资料 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0a550dc4d270bfb2ec06f50c2bd3310/" rel="bookmark">
			CVE-2023-27253-pfsense命令注入漏洞复现（含exp）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
目录
前言
一、pfsense是什么？
二、环境搭建
三、触发条件
四、exp开发
总结
前言 NetGate Pfsense &lt;=2.6.0 版本中存在命令注入漏洞(CVE-2023-27253)，该漏洞存在于Backup&amp;Restore模块的函数restore_rrddata()中，导致拥有管理员权限的攻击者可以通过操纵提供给组件config.xml的XML文件的内容来执行任意命令。
以下是漏洞复现步骤以及根据matesploit攻击模块改编的python攻击脚本。
一、pfsense是什么？ pfSense是一个基于FreeBSD ，专为防火墙和路由器功能定制的开源版本。 它被安装在计算机上作为网络中的防火墙和路由器存在，并以可靠性著称，且提供往往只存在于昂贵商业防火墙才具有的特性。它可以通过WEB页面进行配置，升级和管理而不需要使用者具备FreeBSD底层知识。
漏洞影响版本：&lt;= 2.6.0
二、环境搭建 新建虚拟机，选择FreeBSD，添加第二网卡。导入从官网下载的pfSense 2.6.0的iso文件。
安装好重启后配置WAN与LAN地址。LAN为访问web的地址。
是否启用http作为web协议选择启用
访问ip，登录，默认用户名密码：admin/pfsense，进行防火墙初始化设置。
三、触发条件 漏洞位于Backup&amp;Restore模块的函数restore_rrddata()，攻击者在上传xml配置文件进行重置时，可以通过在文件名之后拼接命令实现命令注入。具体原因如下：
$rrd_file参数在接收到文件内容之后，直接传递给exec()函数调用rrdtool执行 restore -f '文件名' '文件内容' 命令。在此期间未对传入的文件名或文件内容进行过滤与控制。
根据restore -f 命令所带参数的特点，可以在文件内容之后拼接系统命令一并传入exec()函数。
payload:默认文件名';cmd;
由于命令执行无回显，使用sleep来对其进行验证。
四、exp开发 根据matesploit的ruby脚本分析，在执行漏洞利用时，首先进行账户登录与版本获取。只有运行版本在2.7.0以下，才会进行后续验证。
后续经过获取csrf_token值以及下载配置文件等操作来获取所需数据。最后构造漏洞利用所需的post数据包，发送http请求。
poc中的payload为：默认文件名';script -a result.php cmd；。script -a命令会在当前目录创建result.php，并将命令执行的结果保存在该文件中。由于命令执行的结果无回显，故通过访问result.php文件的方式获取命令执行结果。 以下是完整代码：
#该代码只用于学习，禁止用于非法途径 import re import requests import random import string import argparse class MetasploitModule: def __init__(self, args): self.target_url = args.url.rstrip('/') self.username = args.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0a550dc4d270bfb2ec06f50c2bd3310/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6adbdfb25289294e0c33b97d3774944b/" rel="bookmark">
			stm32-中断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单片机的中断概念 【keysking的STM32教程】 第7集 深入讲解STM32中断_哔哩哔哩_bilibili
从一个小需求，引入中断。
需求：红色小灯循环亮2s，灭2s。按下按键Key1后，绿色小灯翻转亮灭状态。
发现：此小需求中，轮询代码检测Key1按下，按键不太有效。原因如下：
那么如何实现这个小需求的代码方案呢？ 中断
中断-外部中断-检测GPIO口电平变化的中断 两个红LED循环亮灭还是在死循环里面实现。对按键GPIO的输入，设置为外部中断输入模式。
在stm32开发IDE中，设置GPIO的中断触发条件：电平上升沿还是下降沿（这个依赖按键电路图，按下时电平怎么变化的）；
然后设置中断向量优先级
然后，在中断服务/处理函数中写下中断要执行的动作
反复按键过程中发现，有时候控制并不灵敏生效。原因还是硬件防抖不完美，我们试着在中断中用软件防抖补充。
此时发现红灯持续亮起，代码跑飞。原因是：HAL_Delay()函数依赖一个System_tick_timer的中断 。这个中断的优先级比当前中断的中断优先级低。
中断虽然可以层层嵌套（次紧急中断内中断，去处理更紧急的事情），但只能优先级只能更高才行。
对于当前项目，一个简单的方法就是，在中断向量表NVIC中，把“HAL_Delay()函数依赖一个System_tick_timer”中断的优先级改高。
外部中断/事件控制器 GPIO引脚设置为外部中断输入模式时，是哪些结构在起作用？
电平到达数据数据寄存器或者片上外设后，还会到达下面这样一个结构，外部输入中断模式就能起作用了。
下面是一个外部中断控制器结构，这样的结构对于最小系统STM32单片机来说，一共有19个，每个GPIO口对应下面一条输入线。不过，19个外部中断控制器共用一套寄存器。
结构一 事件相关结构 与中断无关。
中断信号会进入处理器，调用代码处理；
事件信号是直接进入相应外设。
边沿检测电路（检测中断信号来了没） 检测输入信号有咩有发生高低电平的转换。有的话，再根据对应上升沿/下降沿选择寄存器的值，选择是否接着向后输出一个高电平。
边沿触发选择寄存器 一个32位寄存器，一位为1，意味着对应GPIO配置了边沿检测选择寄存器。
请求挂起寄存器（记录下对应位的中断信号） 接受到高电平信号时，会将对应位置1.
中断屏蔽寄存器（请求挂起寄存器的已记录信号=向中断屏蔽寄存器申请中断正式生效） 对应引脚中断屏蔽寄存器的配置，在我们配置GPIO引脚为外部输入中断时，代码IDE就在代码中帮我们自动完成了
最后，审批通过的中断进入 NVIC，该排队排队，等待最终生效。
NVIC-嵌套向量中断控制器 根据中断信号找到对应中断处理函数 也就是 EXTI12中断信号到达 NVIC时，NVIC会找到中断向量 EXTI5_10，然后
注意：NVIC会持续检测某个中断线是否处于激活状态。如果其对应中断服务函数已经执行完成，发现中断线仍旧处于激活状态，就会再次执行中断服务函数。
解决这个问题，我们需要在中断函数执行完之后，将对应GPIO的请求挂起寄存器对应位置为0。
安排中断信号的的处理顺序 中断向量 不仅对应着 处理函数，还有着优先级信息。
情况一：当两个中断同时到达时，需要比较其优先级。 依次按照 抢占优先级、响应优先级、在中断向量表中的顺序 梯次比较，得出先后顺序。
情况二：A中断正在执行，B中断到达 中断优先级信息 抢占和响应优先级合起来共用一个 4bit位的优先级信息存储位置。
默认4位全用来设置抢占。0-15
一个GPIO外部输入中断，从配置到中断信号生效的全过程总结： 【keysking的STM32教程】 第7集 深入讲解STM32中断_哔哩哔哩_bilibili本期视频深入讲解了当一个外部中断触发时，STM32内部到底发生了什么~------------------------------------------------------------------------------学习套件获取: https://b23.tv/sblUuvI 或者直接某宝搜索"keysking stm32", 认准店铺"波特律动", 视频播放量 25404、弹幕量 203、点赞数 1492、投硬币枚数 1210、收藏人数 1484、转发人数 72, 视频作者 keysking, 作者简介 立志做最好最简洁最易懂的教程！！！，相关视频：【keysking的STM32教程】 第8集 STM32的串口通信，耗时三天，STM32精讲，原理图一遍必懂！！！，【STM32入门教程-2023】应该是全B站最好的STM32教程了，【开漏?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6adbdfb25289294e0c33b97d3774944b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c37e5baf7f3438b6876c3785f89abc74/" rel="bookmark">
			用Python实现一个小说词频统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个主要是通过调用jieba库去实现对小说不同词性的词进行一些统计，欢迎大家来了解，这个如果对你的学习有帮助的话，请给笔者留下一个赞和收藏鼓励下哈
import jieba.posseg as pseg filename = "西游记.txt" with open(filename, encoding='utf-8') as fin: text = fin.read() words = pseg.cut(text) dic = {} for word,flag in words: if flag == 'n': if word not in dic: dic[word] = 1 else: dic[word] += 1 list_ = list(dic.items()) list_.sort(key=lambda x: x[1], reverse=True) with open('西游记高频词统计.txt', 'w', encoding='utf-8') as fout: for key, value in list_: if len(key) &gt;= 2: fout.write('{}:{}\n'.format(key, value)) 快去进行代码验证吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/500803ad475b92acdfd044c51331e218/" rel="bookmark">
			用Python来画满屏不重复的圆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个主要是通过turtle库去实现的一个画不重复圆的的功能，欢迎大家来了解，如果对你的学习有帮助的话，请留下一个赞和收藏给笔者鼓励一下哈
import turtle import random # 设置画布尺寸为1600*800 turtle.setup(100, 100) # 创建Turtle对象 t = turtle.Turtle() # 设置画笔速度和形状 t.speed(0) t.shape("circle") # 定义函数来生成随机圆形 def draw_circle(): # 生成随机半径和颜色 radius = random.randint(min(15, 40), max(15, 40)) color = random.choice(["red", "blue", "green", "yellow", "orange", "purple"]) # 在随机位置绘制圆形 x = random.randint(-740, 740) y = random.randint(-340, 340) t.penup() t.goto(x, y) t.pendown() t.fillcolor(color) t.begin_fill() t.circle(radius) t.end_fill() # 统计最多可以填充多少个不重叠的圆形 count = 0 while True: # 检查圆形是否重叠 overlapping = False # 绘制圆形 draw_circle() count += 1 for c in t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/500803ad475b92acdfd044c51331e218/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90a3c0809ed1c57e734801bb00c2fee6/" rel="bookmark">
			项目集成七牛云存储sdk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以PHP为例
第一步：下载sdk
PHP SDK_SDK 下载_对象存储 - 七牛开发者中心
sdk下载成功之后，将sdk放入项目中，目录选择以自己项目实际情况而定。
注意：在examples目录中有各种上传文件的参考示例，这里我们主要参考的是下面两个
第二步：注册七牛账号
注册账号之后，进入控制台并创建存储桶，配置加速域名。
第三步：获取七牛密钥。
获取此处的ak sk备用。
代码部分：
1：引入sdk
//七牛 require_once API_ROOT. '/public/qiniu/autoload.php'; //以自己实际项目路径为准 use Qiniu\Auth; use Qiniu\Zone; use Qiniu\Config; use Qiniu\Storage\UploadManager; 2：构造上传方法 function updateImg(){ $rs = array('code' =&gt; 0 , 'msg' =&gt; '', 'info' =&gt; array()); $accessKey="填写ak"; $secretKey="填写sk"; $bucket="填写存储桶名称"; // 构建鉴权对象 $auth = new Auth($accessKey, $secretKey); // 生成上传 Token $token = $auth-&gt;uploadToken($bucket); $filePath = $_FILES['file']['tmp_name']; $filename=$_FILES['file']['name']; $filename_arr = explode(".",$filename); //文件后缀 $file_suffix=$filename_arr[1]; //上传文件名称 $key = date("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90a3c0809ed1c57e734801bb00c2fee6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84ec9f520bbb90d74b0b59770745ef8a/" rel="bookmark">
			用Python来写猜数字小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是个用python写的猜数字小游戏，适合初学python的小伙伴们来体验下python,话不多说，直接看下面的代码去运行一下吧，如果对你的学习有帮助的话，给笔者留个点赞收藏哈
import random # 起飞001 # 123456 list:list = [] class person: def init(self, name, password): self.name = name self.age = password def login(list): print("请输入用户名:") uname = input("") print("请输入密码:") upassword = input("") for x in list: if x.name == uname and x.password == upassword : print("欢迎来到猜数字小游戏！！") play() return print("您的用户名不存在或者密码输错了哦，请再输入一次看看") return def sign(list): print("请输入用户名：") uName = input("") print("请输入密码：") uPassword = input("") user = person() setattr(user, "name", uName) setattr(user, "password", uPassword) if list == []: list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84ec9f520bbb90d74b0b59770745ef8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e299dcc317279e5905463ea5c940c229/" rel="bookmark">
			CIP或者EtherNET/IP中的PATH是什么含义？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 SegmentPATH举例 最近在学习EtherNET/IP，PATH不太明白，翻了翻规范，在这里记个笔记。下面的叙述可能是中英混合，有一些是规范中的原文我直接搬过来的。我翻译的不准确。
Segment PATH是CIP Segment中的一个分类。要了解PATH先要了解Segment
参考规范卷1，附录C-1
A CIP segment is a stream of encoded items used to reference, describe, and/or configure a specific CIP entity。
CIP Segment 分类如下
• Port segment – used for routing from one subnet to another
• Logical segment - logical reference information (such as class/instance/attribute IDs)
• Network segment - specifies network parameters needed to transmit on some networks
• Symbolic segment - symbolic name
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e299dcc317279e5905463ea5c940c229/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a01fbd10cff4961cc104687046c2b668/" rel="bookmark">
			torch对应的torchvision
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/132ad8e234f204b6afaef97119b71622/" rel="bookmark">
			利用bat脚本 一键将文件中的png图片转为 jpg图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一步：创建一个.txt文件 第二步：在.txt文件中写入ren *.png *.jpg 第三步：右键重命名 将后缀从.txt改为.bat 第四步：将该文件放到要修改的图片的文件夹内，然后双击就可以啦! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e47dd0fd459e0983eb44ad8277c5323/" rel="bookmark">
			编写Android.mk / Android.bp 引用三方 jar 包，aar包，so 库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.前言 在Android10之后，所有项目工程中，官方推荐使用Android.bp去编译构建，以前使用Android.mk构建的项目随着版本迭代升级，慢慢需要变更为Android.bp， 两者的语法都需要去了解并熟练使用。 笔者之前写过Android.mk的语句介绍，里面有介绍每句代码的含义编写Android.mk把Android studio项目编译到AOSP源码中
后来也总结过 Android.bp基本用法： Android.bp 语法和使用 比较基础，也是在项目中运用到了就记录下来。
本篇文章写的是在项目工程中编写Android.mk和 Android.bp 文件，引入第三方的jar包，aar包， so库，引入特许白名单权限xml文件。
二. Android.mk 编写 1. 引入jar包 比如，我们当前目录下的 libs 有okhttp-3.4.11.jar 包，我想引用它
需要两个步骤
第一步， 声明我们 jar 包所在的目录，我的是AndroidStudio工程目录，所以jar包的路径是app/libs/okhttp-3.4.11.jar
LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := okhttp3:app/libs/okhttp-3.4.11.jar
这行代码的意思大概可以理解成这样，声明一个变量 okhttp3，它的 value 是 app/libs/okhttp-3.4.11.jar
include $(CLEAR_VARS) LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := okhttp3:app/libs/okhttp-3.4.11.jar \ okio:app/libs/okio-1.9.0.jar include $(BUILD_MULTI_PREBUILT) #这里是多个jar包预编译 第二步. 引用我们声明 jar 包的变量 引用我们上面声明的 okhttp3
LOCAL_STATIC_JAVA_LIBRARIES := okhttp3
LOCAL_STATIC_JAVA_LIBRARIES := okhttp3 \ okio 2. 引入aar包 第一步：先声明 aar 包的位置
include $(CLEAR_VARS) LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := \ lottie-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e47dd0fd459e0983eb44ad8277c5323/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b5a200ad74e0375ee82611b62f2e34/" rel="bookmark">
			【C语言_printf()】教你如何使用printf()，格式化输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		printf() 函数概要：
printf 函数用于打印格式化字符串到标准输出流。
函数原型：
#include &lt;stdio.h&gt; ... int printf ( const char * format, ... ); 参数解析：
1、format 参数
format 参数是一个格式化字符串，由格式化占位符和普通字符组成。
格式化占位符（以 % 开头）用于指明输出的参数值如何格式化。
格式化占位符的语法如下：
%[flags][width][.precision][length]specifier
每一个格式化占位符均以 % 开始，以转换字符结束。
specifier
（
转换字符，必选
）的内容及含义如下：
转换字符参数类型；转换结果cchar；字符dint；有符号十进制整数i同上edouble；以指数形式输出单、双精度浮点数（小写 e）E同上（大写 E）fdouble；以小数形式输出单、双精度浮点数gdouble；以 %f 或 %e 中较短的输出宽度输出单、双精度浮点数（指数显示小写 e）G同上（指数显示大写 E）ounsigned int；无符号八进制（无前导 0）schar *；字符串uint；无符号十进制xunsigned int；无符号十六进制（无前导 0x）X同上（无前导 0X）pvoid *；指针值nint *；存放已写字符的个数%不进行参数转换；% 自身 注：如果 % 后边的字符不是转换字符，则其行为没有定义。
格式化字符% 不同数据类型中的使用 整数 %o八进制 %d十进制 %x十六进制 %10d右对齐，取10位，不够则补位 %-10d左对齐，取10位，不够则补位 %010d右对齐，取10位，不够则补0 %-010d左对齐，取10位，不够则补0（0不显示） %+010d右对齐，显示正号，取10位，不够则补0 %-+010d左对齐，显示正号，取10位，不够则补0（0不显示） 重点：
%010d右对齐，取10位，不够则补0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76b5a200ad74e0375ee82611b62f2e34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13aa8e9f44b74aae585f4c37eb8b1702/" rel="bookmark">
			STM32 HAL 串口理论和实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、基本理论1、单片机通信基础2、串口通信基础串口概念RS-232串口电平与CMOS以及TTL的对比设备间的RS-232通信示意图STM32串口与电脑USB口通信示意图RS-232异步通信协议 3、UART 和 USART 的区别4、USART5、HAL库的串口机制HAL库外设初始化MSP回调机制HAL库中断回调机制USART/UART异步通信配置步骤IO引脚复用功能IO引脚复用 F4 F7 H7同步模式中断控制FIFO 操作串口频繁进入中断导致的问题 二、CubeMX 配置串口选择处理器选择连接设备的串口在GPIO Settings中设置引脚设置Parameter Settings时钟配置NVIC Settings在A-&gt;Z中找到NVIC，并按如下图配置Project Manage设置创建代码生成代码一览 HAL 串口 API汇总设计 三、案例：ESP8266 前言 因为最近老板突发奇想，想要做一个轻量级的AI工具，其他保密，我负责整理采集到的数据并上传到服务器。
趁此大好机会，赶紧复习一下串口的知识。一些和实际开发不相关的基础知识我就直接跳过了。
一、基本理论 1、单片机通信基础 同步和异步通信 波特率 常见串行通信接口 2、串口通信基础 串口概念 RS-232串口电平与CMOS以及TTL的对比 设备间的RS-232通信示意图 STM32串口与电脑USB口通信示意图 RS-232异步通信协议 3、UART 和 USART 的区别 区别点USARTUART双工模式半双工全双工速度快慢时钟信号要时钟信号和数据信号互相配合不需要兼容USART可以做到UART的功能做不到USART数据形式块形式一次一个字节复杂度复杂简单波特率不需要知道需要设置波特率变速恒速传输可变速传输 4、USART 引脚数量以及对应的引脚，可以参考MCU手册以及STM32F1硬件手册。
USART框图 设置USART/UART波特率 通过波特率计算得到要设置的寄存器参数。
将两个×16放在一起合并，简化公式。
USART寄存器介绍 通过波特率计算得到要设置的寄存器参数。
将两个×16放在一起合并，简化公式。
USART寄存器介绍 5、HAL库的串口机制 HAL库外设初始化MSP回调机制 HAL库中断回调机制 USART/UART异步通信配置步骤 IO引脚复用功能 IO引脚复用 F4 F7 H7 每一个引脚都可以选择相应的复用，对F1进行了改进
同步模式 在同步模式下连接时需要以下引脚：
SCLK：发送器时钟输出。该引脚用于输出发送器数据时钟，以便按照 SPI 主模式进行同步发送（起始位和结束位上无时钟脉冲，可通过软件向最后一个数据位发送时钟脉冲）。RX 上可同步接收并行数据。这一点可用于控制带移位寄存器的外设（如 LCD 驱动器）。时钟相位和极性可通过软件编程。在智能卡模式下，SCLK 可向智能卡提供时钟。在硬件流控制模式下需要以下引脚：
nCTS：“清除以发送”用于在当前传输结束时阻止数据发送（高电平时）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13aa8e9f44b74aae585f4c37eb8b1702/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12d4b44e99e035cdea2762b45e30183f/" rel="bookmark">
			重复相似图片查找工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人电脑上很多照片和视频，一起估计有20来万个文件，一直在找一个好用的重复相似图片查找工具软件，发现国外有个免费的开源程序（好像是c#写的），搞下来用了一下发现免费开源的果然不行，列出很多结果都不准确，有些明明相似的又列不出来。看起来只是一个演示作品而已。
使用了国内的“图图比较”，试了一下，准确率非常高，做好索引后，速度飞快，关键是还支持视频的重复相似查找。
挺好的，后面针对这个写个使用教程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ff47f633a13b524f742b4581426d527/" rel="bookmark">
			数字货币的一些隐私保护问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的数字货币基本模型 代表数字货币的不同架构和交易验证方式。
Account Based 基于账户的数字货币模型。
主要特点
账户地址：每个用户都有一个唯一的账户地址，类似于银行账户号码。这个地址用来标识用户的身份，并用于接收、存储和发送数字货币。中央账本：所有账户的余额和状态信息都存储在中央账本中，所有交易都需要在中央账本上进行记录和验证。可扩展性，性能和隐私性不高。交易处理：通常是通过修改账户余额来实现的。当一个用户向另一个用户发送数字货币时，相应的账户余额会相应地减少和增加。
UTXO Based Unspent Transaction Output，基于未花费的交易输出模型，比特币就是采用的这种模型。
主要关注的是资金的来源和去向，每笔交易都有若干交易输入（也就是资金来源），同时也都有若干笔交易输出（也就是资金去向）。一般来说，每一笔交易都要花费（spend）一笔输入，产生一笔输出，而其所产生的还没有被下一笔交易花费的 Output ，就是“未花费过的交易输出”，也就是 UTXO。
主要特点
账户地址：UTXO 模型没有账户这个概念，每个用户管理的是一组私钥，对应一组公钥和地址。交易细节： 每个UTXO都是一笔交易的输出，它包括一个特定的货币数量和一个公钥脚本，代表一定数量的数字货币。当用户想要发起新交易时，他们需要选择足够的UTXO作为输入，然后将它们合并成新的UTXO来支付接收方。也就是所有的资金来源都必须要来自前面的某一个或者几个交易的UTXO（ Coinbase 矿工奖励交易除外，没有输入只有输出）。且任何一笔交易的交易输入总量必须要等于交易输出总量。任何交易都能够从输入溯源到 Coinbase 交易。 余额：用户的余额是钱包地址关联的所有的 UTXO 金额的和，也就是动态的，需要从创世区块开始扫描每一笔交易，如果遇到某笔交易的某个Output是钱包管理的地址之一，则钱包余额增加，反之遇到某笔交易的某个Input是钱包管理的地址之一，则钱包余额减少。 以比特币的为例，如图
比特币的隐私保护问题 比特币作为第一个电子现金系统，其使用的最核心的隐私保护措施就是交易假名和地址不可关联，但这是存在一些问题的。
公开账本信息泄露
我们知道，比特币使用的是UTXO，用户的钱包会管理很多地址，这些地址与用户本身没有任何关联，故能实现隐私。但是，由于比特币网络上的账本是公开可查询的，导致交易金额以及交易的历史是可查的。而交易的地址和金额都是明文的，如果不做一些安全措施的话，是可以通过对交易之间的关系以及交易时间的进行分析，是有可能分析出哪些地址是属于哪个用户的。比如，一笔交易中多个输入来自不同的地址但在统一交易中被用于创建输出，那么显然这多个地址就会属于某个单一用户。另外一些交易也会泄露额外的信息，比如交易留言，金额等等。
当然，最核心的问题是，比特币做不到深层次的隐私，由于现在很多时候都涉及到了实名制的问题，一旦某个地址与用户身份进行了绑定，那么等于隐私被暴露了，想再次进行隐私是很困难的，一旦最初的这个地址暴露以后，即使我们更换一个新的地址，把暴露地址中的币转入新地址，新地址和老地址之间关联性就非常明显。即便是自己做的防护措施挺好，但一旦与自己交易的那个地址暴露了，那么就可以从那个地址的持有者里拿到自己的信息。
通讯协议未加密
比特币的通讯协议是没有加密的，因此节点在进行消息传播的时候，是有概率泄露源IP和地址的对应关系的，同样也可以在网络中部署节点监听进行信息收集。
轻量级节点信息泄露
因为不是所有节点都有能力存储完整的账本，还有很多设备客户端是受限制的，比如手机，平板等等，上面使用的是轻量级密码算法和协议，在支付的时候是采用了简化的支付验证（SPV），这种方式不存储完整的区块链，也不验证系统种的所有交易，也可以让支付完成。它只默认连接随机的几个节点，而且只请求给定高度的区块，或者相关交易的过滤区块。这就产生了隐私问题，因为只读取特定交易区块而选择性的进行交易验证。
一些常用的隐私保护措施 两种隐私的理解方式 Pseudonymous **假名机制，**比特币这种机制是伪匿名的，叫做假名机制，即用户可以独立生成任意数量的地址，无需注册或者认证，同一用户之间的地址是无相关联的，那么仅仅凭借地址是没法找到用户的。但是就像前面提到的，可以通过对交易历史的分析是可以有很大概率找到联系的。就像网名和实名之间的联系。
这种链条状的交易历史可查会导致如果其中一个节点的信息暴露出来，那么整条交易链上的信息就会暴露出来。
Anonymous 匿名机制，也就是用户什么相关信息都不透露，类似学校表白墙上发了信息，但是要求墙墙“狠狠的🐎”，它发了信息，但是你不知道任何有关它的信息。
CoinJoin 之前的交易中，由于交易是可见的，也是交易双方一一对应的，同一区块会存放多个交易，那么可以通过把输入和输出的地址进行打乱混淆，切断交易双方的联系，让别人无法分辨谁和谁是对应的交易双方，从而提升隐私性。
这就是混币，也就是地址混淆。这是不需要修改协议就能一定程度上提高匿名性的有效手段，有效抵抗交易图分析攻击。
但是这也不是完美的，因为如果要混合交易，那么双方的交易量必须得相似，不然还是很容易能找出联系。
中心化混币 也就是找一个可信机构来进行混淆，需要保证该机构不保存任何账本记录，也不认证用户的信息，这样数据外泄的时候就不会减少用户信息泄露。
但是也同样存在一定问题，如，
提供服务的机构会存在一定特征行为，比如混币交易的时间存在一些规律，会抽取一定手续费，存在一些常用的地址池等等，这会给攻击者提供一定分析材料，所以需要保证这种外部的隐私性。机构知道了输入地址和输出地址，那它是有可能知道它们对应关系的，也有可能从中盗取货币资金，所以需要保证这种内部的不可链接关系。 一些解决方案
随机化 解决外部隐私问题，最容易想到的就是随机化，将一些固定的东西进行随机化，如，一定范围内的随机化交易时间，随机化交易手续费，在多个混币机构之间多混几次。这能起到一定程度的保护作用。
承诺+电子签名 这是用来解决机构和用户之间的信任问题，防止资金盗取的。也就是服务机构用自己的电子签名去做承诺，即约定好输入输出地址、混淆资产金额、约定时间等信息，并用混币服务商的长期公钥 对应私钥进行签名。出现问题时，用户就可以打开承诺向其他用户说明情况，进行证明。
盲签名 接下来是内部地址的不可链接性问题，需要服务提供商在不知道用户输入输出地址对应关系的情况下进行输入和输出阶段。这就用到了盲签名，它可以同时隐藏消息内容和签名请求者的隐私，满足
被签名消息对签名者是不可见的，即签名者不知道他所签署消息的具体内容。签名消息不可追踪，即当签名消息被去盲化公布后,签名者无法将去盲化签名与盲化签名对应上。 盲签名的一般做法是，用户随机选择一个随机因子，然后与待签名的消息进行计算，让其与原消息没有关联，从而达到盲化。然后签名者对盲化的消息进行签名，从而不知道签名消息的内容。后续就是解盲签名和公布去盲化签名以及原始消息进行验证了。
去中心化 也就是无需第三方混币服务商。
用户在网络中找到其他需要混币的用户，通过多方参与者运行协议的方式构造一致的混币交易，确认后进行签名使得交易生效即可。
一般方式
分为协商、混淆、确认、结束四个阶段
协商阶段：用户寻找参与混币的其他同伴,协商去中心化混币协议需要的参数,例如各用户混币输入输
出地址、混币金额等参数。混淆阶段：参与混币的用户根据协议对所有输出地址进行混淆,隐藏用户输入、输出地址之间的关联
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ff47f633a13b524f742b4581426d527/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f8d02c9dc072474275ef9ed6398407d/" rel="bookmark">
			Java 8 Stream使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 8 Stream 流 1. 构造Stream流的方式 Stream stream = Stream.of("a", "b", "c"); String[] strArray = new String[] { "a", "b", "c" }; stream = Stream.of(strArray); stream = Arrays.stream(strArray); List&lt;String&gt; list = Arrays.asList(strArray); stream = list.stream(); 2.Stream流的之间的转换 一个Stream流只可以使用一次
try { Stream&lt;String&gt; stream2 = Stream.of("a", "b", "c"); // 转换成 Array String[] strArray1 = stream2.toArray(String[]::new); // 转换成 Collection List&lt;String&gt; list1 = stream2.collect(Collectors.toList()); List&lt;String&gt; list2 = stream2.collect(Collectors.toCollection(ArrayList::new)); Set set1 = stream2.collect(Collectors.toSet()); Stack stack1 = stream2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f8d02c9dc072474275ef9ed6398407d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfec5521a7c58a1a82637971efa2ebe6/" rel="bookmark">
			好的文章推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM OOP-Klass模式
浅谈JVM OOP-Klass二分模型_在云端123的博客-CSDN博客
DDD领域驱动设计开发
万字长文，结合电商支付业务一文搞懂DDD (qq.com)
Spring源码构建 spring源码学习_01 本地环境搭建_spring源码运行_Louis.No1的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bbdf4bce977aa224bee952341dfd0bb/" rel="bookmark">
			Linux多线程之线程同步（条件变量）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是线程同步？
案例原型：A先扫5次地，A扫完地B再拖地，从而完成线程同步。
#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; pthread_t thread[2]; int number = 0;//共享资源 pthread_mutex_t mut; void studentA() { int i; for(i=0;i&lt;5;i++) { pthread_mutex_lock(&amp;mut);//上锁 //扫1次地 number++; if(number &gt;= 5) printf("student A has finish his work!\n"); pthread_mutex_unlock(&amp;mut);//解锁 //休息1s钟 sleep(1); } //退出 pthread_exit(NULL); } void studentB() { while(1) {	pthread_mutex_lock(&amp;mut); if(number &gt;= 5)//判断A同学是否已经扫完5次地 { //拖地 number = 0; pthread_mutex_unlock(&amp;mut); printf("student B has finish his work!\n"); break; } else { pthread_mutex_unlock(&amp;mut); //睡眠2s钟 sleep(2); }	} //退出 pthread_exit(NULL); } int main() { //初始化互斥锁 pthread_mutex_init(&amp;mut,NULL); //创建A同学线程 pthread_create(&amp;thread[0], NULL, studentA, NULL); //创建B同学线程 pthread_create(&amp;thread[1], NULL, studentB, NULL); //等待A同学线程结束 pthread_join(thread[0], NULL); //等待B同学线程结束 pthread_join(thread[1], NULL); } 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bbdf4bce977aa224bee952341dfd0bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f26da68d23f0bddc930db641f04c3592/" rel="bookmark">
			【mysql 窗口函数row_number】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分组聚合，先分组再进行排序（分组+排序）。
使用方法：row_number() over(partition by 列名1 order by 列名2 desc)的使用
表示根据 列名1 分组，然后在分组内部根据 列名2 排序，而此函数计算的值就表示每组内部排序后的顺序编号,可以用于去重复值。
举个栗子：
查询所有名称，如果同名，则按时间降序
SELECT goods_name, create_date, ROW_NUMBER() OVER (PARTITION BY goods_name ORDER BY create_date DESC) FROM goo_sku; 结果： 通过上面的语句可知，是按照goods_name字段分组，按create_date字段排序的。 如果需求就是只需查询出每个名字的最新创建时间记录，则可使用如下的语句, 由查询结果可知，名称相同但时间较早的数据被过滤掉了；
SELECT * FROM (SELECT goods_name, create_date, ROW_NUMBER() OVER ( PARTITION BY goods_name ORDER BY create_date DESC)RN FROM goo_sku) as a WHERE RN= 1 ; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/054adf8b5f7bf58edf0ed7ec5852a56c/" rel="bookmark">
			国内免费ChatGPT&#43;AI绘画创作网站工具&#43;支持GPT-4&#43;Midjourney绘画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、前言 GPT4.0 相信对大家应该不感到陌生吧？简单来说，GPT-4技术比之前的GPT-3.5相对来说更加智能，会根据用户的要求生成多种内容甚至也可以和用户进行创作交流。 然而，GPT-4对普通用户来说都是需要额外付费才可以使用。所以今天小编就整理一个真正免费的公益GPT4网站。不是只能使用一两次就要付费的网站。
最近更新功能：
新增 MJ 图片重新生成指令功能同步 Vary 指令 单张图片对比加强 Vary(Strong) | Vary(Subtle)同步 Zoom 指令 单张图片无限缩放 Zoom out 2x | Zoom out 1.5x
二、特点优势（模块） 该网站无需魔法，国内直接使用。该网站长期运营，为国内博主自己掏钱免费给粉丝使用。免费额度： 首次注册：赠送100次GPT3.5 | 5次GPT4 | 10点专业绘画额度。GPT3.5:固定：每天签到20到50次，不定时：送一个月内无限次提问。GPT4：每天送2到10次，不定时：额外送4.0公益次数。AI绘画：Midjourney免费使用。 三、该网站系统主要功能模块 程序核心功能：
AI提问：程序已支持GPT3.5、GPT4.0提问、支持GPT联网提问
AI绘画：Midjourney绘画（全自定义调参）、Midjourney以图生图、Dall-E2绘画
微信公众号+邮箱+手机号注册登录
一键智能思维导图生成
应用广场知识库，支持用户前台自定义添加私密或共享
AI绘画广场（画廊）
邀请+代理分销模式
用户每日签到功能
会话记录同步保存
支持对接微信官方支付、易支付、码支付、虎皮椒支付等
自定义聚合会员套餐
其他核心功能
后续其他免费版本功能更新…
四、使用访问方式 网址：https://ai.idcyli.com
五、使用教程以及主要功能展示 支持GPT4.0: GPT联网提问功能： Prompt应用： 应用广场模块 工作台模块 支持用户自定义Prompt知识库模块 AI绘画功能 Midjourney专业绘画模块 文生图：
以图生图：
AI绘画广场 思维导图生成模块 后续其他功能更新 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a005881c73b258f6bfcc189305bb9f/" rel="bookmark">
			java常量池详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 常量池
1.1 Class 常量池
1.2 运行时常量池 2. 字符串常量池
2.1 字符串常量池设计思想
2.2 三种字符串的操作（JDK1.7及以上版本）
2.3 字符串常量池位置
2.4 字符串常量池设计原理
2.5 String常量池分析示例
3. 八种基本类型的包装类和对象池
1. 常量池 1.1 Class 常量池 Class常量池可以理解为是Class文件中的资源仓库。 Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译期生成的各种字面量(Literal)和符号引用(Symbolic References)。
下图中字节码指令文件中的constant pool就是class 常量池，主要存放字面量和符号引用。
字面量
字面量就是指由字母、数字等构成的字符串或者数值常量。
字面量只可以右值出现，所谓右值是指等号右边的值
如：int a=1 这里的a为左值，1为右值。在这个例子中1就是字面量。
符号引用
符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量：
类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 package com.test.jvm; public class ConstantPoolTest { public static void main(String[] args) { Math math = new Math(); int compute = math.compute(); System.out.println(compute); int i =1; } } 上面的i、ompute、math就是字段名称，就是一种符号引用，com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23a005881c73b258f6bfcc189305bb9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c9e2e69ad1a897e54e720a4742e512b/" rel="bookmark">
			jsp 九大内置对象详解以及示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是 jsp 九大内置对象详解以及示例 jsp 九大内置对象类型以及作用域一览表：
request 请求对象　类型 javax.servlet.ServletRequest 作用域 Request response 响应对象 类型 javax.servlet.SrvletResponse 作用域 Page pageContext 页面上下文对象 类型 javax.servlet.jsp.PageContext 作用域 Page session 会话对象 类型 javax.servlet.http.HttpSession 作用域 Session application 应用程序对象 类型 javax.servlet.ServletContext 作用域 Application out 输出对象 类型 javax.servlet.jsp.JspWriter 作用域 Page config 配置对象 类型 javax.servlet.ServletConfig 作用域 Page page 页面对象 类型 javax.lang.Object 作用域 Page exception 例外对象 类型 javax.lang.Throwable 作用域 page out对象：
out对象javax.servlet.jsp.JspWriter的一个对象，它能把信息发送给客户端的浏览器。 out对象有两个常用方法：print();和println(); out对象也可以对缓冲区做相关操作（代码如下）： &lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c9e2e69ad1a897e54e720a4742e512b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac69ebd844acea2193d9420da07f77e0/" rel="bookmark">
			Cannot resolve MVC view ‘xxx‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是在springboot下通过controller访问templates目录下的静态文件（Hello.html)报的错误
原因：缺少thymeleaf依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; 添加之后并刷新
Hello下的波浪线变成直线说明错误得以解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d0736acc53a3cf680ae0af23ead2b7/" rel="bookmark">
			cuda编程学习——第二个cuda程序（官方案例分析）！干货向（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 最近在做三维重建，尤其是Nerf方面多视角合成工作的时候，意识到了cuda的编程计算可以大大提高其中渲染的计算，最明显的例子是Instant-ngp，Plenoxels等文章，因此后面会学Cuda一段时间，同时也就开了这个新坑。
因为笔者也是cuda新手，所以大家有问题的话可以评论区指出，一起学习进步！
我已经更新了我的Github仓库，大家可以前往仓库下载代码
我的CUDA学习仓库
Nvidia Cuda官方入门资料
运行环境： Windows10，Visual Studio2019,显卡3050Ti
（大家自行根据自己笔记本情况去配环境，或者没有gpu，租借云服务器去学习也是可以的）
1：C++模板 首先从下面的C++代码开始
其作用为把2个数组元素相加，代码里设为1&lt;&lt;20，也就是在二进制下把00001左移20位，最终值为2^20，为1048576，大约位1million（百万），相加的值最终减去3.0，判断有没有误差。
#include &lt;iostream&gt; #include &lt;math.h&gt; // function to add the elements of two arrays void add(int n, float *x, float *y) { for (int i = 0; i &lt; n; i++) y[i] = x[i] + y[i]; } int main(void) { int N = 1&lt;&lt;20; // 1M elements float *x = new float[N]; float *y = new float[N]; // initialize x and y arrays on the host for (int i = 0; i &lt; N; i++) { x[i] = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67d0736acc53a3cf680ae0af23ead2b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5781b4cc7d637b8afa729d91a23a5345/" rel="bookmark">
			图像细化和骨架提取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像细化（Image Thinning），一般指二进制图像的骨架化（Image Skeletonization） 的一种操作运算。细化是将图像的线条从多像素宽度减少到单位像素宽度过程的简称；骨架提取与图像细化类似，都是指将二进制图像中一部分像素去掉后，剩下的像素仍然能保持原来的形状，形成图像的骨架。
Zhang-Suen算法是一种经典的细化算法，后续很多的算法是在其基础上进行改进的。在很多的图像处理库（scikit-image, OpenCV）中，该算法都被广泛的使用。
目录
一、概述
二、Zhang-Suen 算法
（1）基本逻辑
① 第一阶段
② 第二阶段
（2）流程框图
一、概述 用骨架来表示线划图像能够有效地减少数据量，减少图像的存储难度和识别难度。线划图（包括纸质地图、线画稿、手绘图等）的存储是非常麻烦的，存储和使用起来都很不方便。例如，一张A4大小的线划图存储需要1M的容量，另外一些比较严重的问题就是数据的修改、更新和显示。矢量化是解决这些问题的方法，但这些图的宽度经常是大于一个像素的，这会导致矢量化结果有非常大的问题，为了解决这些问题，细化就成了模式识别和矢量化的先决条件。
所谓的细化就是经过一层层的剥离，从原来的图中去掉一些像素，但仍要保持原来的形状，直到得到图像的骨架。骨架，可以理解为图象的中轴。
好的细化算法一定要满足：
收敛性；保证细化后细线的连通性；保持原图的基本形状；减少笔画相交处的畸变；细化结果是原图像的中心线；细化的快速性和迭代次数少； 细化技术的一个主要应用领域是位图矢量化的预处理阶段。相关研究表明，利用细化技术生成的位图的骨架质量受到多种因素的影响，其中包括图像自身的噪声、线条粗细不均匀、端点的确定以及线条交叉点选定等，因而对线划图像进行细化从而生成高质量骨架的方法进行研究具有现实意义。但与此同时，细化技术并不是绝对有效的：
（1）并非所有形状的图像都可以或者应该细化。细化比较适合由线条组成的物体，例如圆环，但实心圆不适合细化。
（2）任何一种细化方法都不能适用所有的情况。
（3）细化是提取骨架的过程，所提取的骨架必须有实质的意义，而不是由所使用的细化算法来定义骨架。
二、Zhang-Suen 算法 Zhang-Suen算法是一种经典的细化算法，后续很多的算法是在其基础上进行改进的，来自于T. Y. ZHANG 和 C. Y. SUEN 于1984年在 IPCV（Image Processing and Computer Vision）中发表的论文 " A Fast Parallel Algorithm for Thinning Digital Patterns " 。在很多的图像处理库（scikit-image, OpenCV）中，都被广泛的使用。
（1）基本逻辑 Zhang-Suen 算法每运行一次，都需要遍历所有的不为0的像素。在对每个像素（P1）进行删除或保留的判断时，我们需要关注其周围的8个邻居像素（P2, P3, P4, P5, P6, P7, P8）的值。其中 P2 到 P8 的顺序是算法规定，用于判断，共分为两个步骤来判断该点是否需要删除。
① 第一阶段 判断该点是否满足以下所有条件，如果满足则删除，否则保留。
2 ≤ B(P1) ≤6A(P1) = 1P2 ∗ P4 ∗ P6 = 0P4 ∗ P6 ∗ P8 = 0 其中A(P1) 是指从P2到P8从0到1跳变的次数，B(P1) 代表着 8 个邻居中非零邻居的数量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5781b4cc7d637b8afa729d91a23a5345/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85741bb4f267460550fff43efa50e372/" rel="bookmark">
			Redis基础知识入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 1.1 数据库压力过大 由于用户量增大，请求数量也随之增大，数据压力过大
1.2 数据不同步 多台服务器之间，数据不同步
1.3 传统锁失效 多台服务器之间的锁，已经不存在互斥性了
二、Redis介绍 2.1 关于关系型数据库和NOSQL数据库（键值对存储） 关系型数据库是基于关系表的数据库，最终会将数据持久化到磁盘上，而nosql数据库是基于特殊的结构，并将数据存储到内存的数据库。从性能上而言，nosql数据库要优先于关系型数据库，从安全性上来讲，关系型数据库要优先于nosql数据库，所以在实际开发中一个项目中nosql和关系型数据库会一起使用，达到性能和安全性的双保证。
NOSQL产品: redis，mongodb，memcached...
Redis就是一款NoSQLs's
NoSQL -&gt; 非关系型数据库 -&gt; Not Only SQL。
Key-Value：Redis ...
文档型：ElasticSearch，Solr，Mongodb ...
面向列：Hbase，Cassandra ...
图形化：Neo4j ...
除了关系型数据库都是非关系型数据库
NoSQL只是一种概念，泛指非关系型数据库，和关系型数据库做一个区分
2.2 Redis介绍 有一位意大利人，在开发一款LLOOGG的统计页面，因为MySQL的性能不好，自己研发了一款非关系型数据库，并命名为Redis。Salvatore。
Redis（Remote Dictionary Server）即远程字典服务，Redis是由C语言去编写，Redis是一款基于Key-Value的NoSQL，而且Redis是基于内存存储数据的，Redis还提供了多种持久化机制，性能可以达到110000/s读取数据以及81000/s写入数据，Redis还提供了主从，哨兵以及集群的搭建方式，可以更方便的横向扩展以及垂直扩展。
三、Redis 安装 3.1 安装Redis 官网：Redis
下载：Index of /releases/
中文网：Redis中文网
官网提供安装方式如下：（安装redis编译的c环境，此步骤没有编译）
Installation
Download, extract and compile Redis with:
$ wget &lt;http://download.redis.io/releases/redis-5.0.5.tar.gz &gt;
$ tar xzf redis-5.0.5.tar.gz $ cd redis-5.0.5
$ make
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85741bb4f267460550fff43efa50e372/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e511e0de77251e67a013fd93c40ca5c/" rel="bookmark">
			python工具-c-struct-decode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python工具-c-struct-decode 示例
# 编译运行C代码 gcc c-struct.c ./a.out # 生成 1.bin 文件， 内容是一个 demo_head+3*demo_info # 使用 python 解析 python c-struct-decode.py # 输入结果如下： 1.txt unpack requires a buffer of 4 bytes type:1 version:0 path:12 indexs:4 ===========index: 0============== timestamp:1886221359 flag:0 desc: ===========index: 1============== timestamp:256 flag:0 desc:hello ===========index: 2============== timestamp:558 flag:0 desc:hello ===========index: 3============== timestamp:814 flag:0 desc:hello C 代码写入 #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #pragma pack(4) // 4字节对齐 typedef struct _head_ { uint32_t type; uint64_t version; char path[12]; }demo_head; #pragma pack(1) // 1字节对齐 typedef struct _info_ { uint32_t timestamp; char flag; char desc[6]; }demo_info; #pragma pack() int main(){ FILE* f = fopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e511e0de77251e67a013fd93c40ca5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f18bf664fb98185592550e17bbfff55/" rel="bookmark">
			Ansys结构分析单元类型大全，实体单元、梁单元、杆单元...如何选择？附ansys学习资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的不断发展，结构分析在工程领域中扮演着越来越重要的角色。在进行结构分析时，选择合适的分析单元类型是关键的一步。Ansys作为结构分析领域的顶级软件，提供了丰富的分析单元类型，以满足不同工程需求。本文将全面介绍Ansys中常见的结构分析单元类型及其特点，帮助更好地了解和选择合适的分析单元类型。
一、Ansys结构分析常见单元类型
1、BEAM梁单元 梁单元是用于螺栓(杆)，薄壁管件，C 形截面构件，角钢或者狭长薄膜构件(只有膜应 力和弯应力的情况)等模型。
①单元Beam3：
Beam3单元是一个单轴单元，可以承受拉、压、弯的作用。该单元的每个节点有三个自由度，即沿x、y方向的线位移和绕Z轴的角位移。
②单元Beam4：
Beam4是一种单轴受力单元，可以用来承受拉力、压力、弯曲和扭曲。该单元在每个节点有六个自由度：x、y、线位移和绕x三个方向z，y,z三轴的角位移。可用于计算应力硬化和大变形的问题。考虑大变形(有限旋转)的分析，采用相容切线刚度矩阵的选项。
③单元BEAM44：
BEAM44是一种单轴梁，具有承受拉力、压力、扭转和弯曲的能力。每个单元节点有6个自由度：x、y、z方向的平移和x、y、z轴向旋转。该单元允许不对称的端面结构，并允许端面节点偏离截面的中心位置。如不需要这些特性，可选择均质对称的BEAM4单元。同时也可选择相同类型的2D单元(BEAM54)。BEAM188和BEAM189用于替代非线性材料。
2、LINK杆单元 ①LINK1单元可用于不同的工程应用。根据具体应用，该单元可以模拟桁架、链杆和弹簧。这种二维杆单元是一种可以承受单轴压力的单元，因为每个节点的自由度只考虑X和Y的线位移。该单元不能承受弯矩，因为它只用于铰接结构。
②LINK8单元是一种可用于各种工程实际的杆元素。该元素可用于桁架、垂直电缆、杆件、弹簧等。这种三维杆元素只能承受单轴的压力，每个节点有三个自由度:x,y,以及Z方向的位移。在销钉结构中，元素不能弯曲。塑性，潜变，膨胀，应力强化，大变形(plasticity,creep,swelling,stressstiffening,andlargedeflection)所有这些都是允许的。这个元素在ANSYSTheoryReference的14.8中有更详细的介绍。只能承受拉压的LINK10可供参考。
3、PIPE管单元 ①PIPE16单元
pipe16是一种单轴单元，具有拉压、扭转、弯曲的性能。该单元在两个节点上有六个自由度：沿节点X，Y,Z方向的平移和绕结点X，Y,旋转Z轴。该单元基于三维梁单元(BEAM4)，包括简化基于对称性和标准管的几何尺寸。
②PIPE17单元
PIPE17是一个单元，由三个单轴弹性管（PIPE16）按T型组成，包括压缩、扭转和弯曲能力。每个节点有六个自由度：节点X、Y、Z向平移和绕X方向，Y、Z轴的转角。
T型接头的弹性、应力强度系数、力输出等都有一些选项。这个单元可以解决绝缘问题，包括流体和腐蚀余度。
③PIPE20单元
管道20单元是一种单轴单元，具有拉伸、弯曲和扭转性能。每个单元节点有6个自由度：沿节点坐标x，y,Z方向位移和绕节点坐标x，y,z轴转动。
该单元具有塑性、蠕变和膨胀特性。如果不需要使用这些功能，可以使用弹性管单元来管理16。您可以选择打印单元坐标系中单元的力和瞬态功能。
4、PLANE平面单元 ①PLANE2单元
PLANE2是一个与8节点PLANE82单元兼容的6节点三角形单元。该单元具有二次位移函数，能更好地适应不规则的模型网格(例如由不同的CAD/CAM系统产生的模型)。
该单元有六个节点，每个节点有两个自由度，即x和y方向的平移，可用作平面单元(平面应力或平面应变)或轴对称单元。该单元具有塑性、蠕变、辐射膨胀、应力刚度、大变形和大应变能力。
②PLANE13单元
PLANE13具有2维磁、热、电、压电和结构场分析能力，并且可以在各个领域之间实现有限的耦合。这个单元有四个节点，每个节点最多有四个自由度。该单元具有非线性磁性能力，用于建模B-H曲线或永磁体退磁曲线。PLANE13单元具有较大的变形和应力刚度。PLANE13单元在纯结构分析中也具有较大的应变能力。
③PLANE25单元
PLANE25用于建模承受非轴对称载荷的2维轴对称结构。这种载荷的例子包括弯曲、剪切或扭转。这个单元有四个节点，每个节点有三个自由度。–节点在x、y、z方向平移。对于未旋转的节点坐标，其方向分别对应径向、轴向和切线方向(圆周方向)。该单元是PLANE42的版本，由2维轴对称实体单元推广到非轴对称载荷。
5、SHELL壳单元 ①SHEL41单元
SHEL41是一个三维单元，平面内有膜强度，但平面外没有弯曲强度。这是独特的外壳结构，因为它的单元弯曲是次要的。每个节点有三个自由度：沿节点x，y,z轴向的运动。
该单元具有变厚、应变强度、大偏差和材料选择。参考ANSYS理论第14.41节，您可以获得更多关于该单元的细节。另一个只有薄膜的单元可以被视为SHELL63。
②SHEL43单元
SHEL43适用于模拟线性、弯曲和适当厚度的壳体结构。单元中的每个节点都有六个自由度：沿xx的自由度、y和z方向的平动自由度以及绕x的平动自由度、y和z轴的旋转自由度。平面两个方向的形状必须是线性的。对于平面外的运动，采用张量组的混合内插法（amixedinterpolationoftensorialcomponents）。
该单元具有塑性、蠕变、应力刚化、大变形、大应变等特点。ANSYS是该单元更详细的性能，Inc.TheoryReference中的SHELL43。如果是薄壳或塑性和蠕变，不需要考虑弹性四边性壳单元(SHELL63)。如果遇到收敛困难或需要考虑大应变，可以选择SHELL181单元。当然，对于非线性结构分析，我们建议选择SHELL181单元。
③SHEL93单元
SHEL93单元特别适合曲壳模型。该单元的每个节点都有6个自由度：沿节点坐标系XX、Y、沿节点坐标XZ方向的平动和平动、Y、Z轴的旋转。变形在两个方向上都是二次的。
该单元具有塑性、应力刚化、大变形、大应变的能力。
6、COMBIN弹簧-阻尼单元 弹簧-阻尼单元，可以用来模拟弹簧和阻尼器
①COMBIN14 单元：
COMBIN14具有1维、2维或3维应用中的轴向或扭转性能。轴向弹簧阻尼器选项为一维拉伸或压缩单元。每个节点有三个自由度：x,y,z的轴向运动。它不能考虑弯曲或扭转。扭转弹簧阻尼器选项为纯扭转单元。每个节点有三个自由度：x,y,z的旋转。它不能考虑弯曲或轴向力。
②COMBIN37单元：
COMBIN37是一个单向单元，在分析过程中具有打开和关闭的性能。该单元的每个节点只有一个自由度，可以是沿节点坐标方向的平移，绕节点坐标轴的旋转，压力或温度。COMBIN7描述了具有更多性能的控制单元(6自由度和大变形)。COMBIN14、COMBIN39、andCOMBIN40等单向单元(无距离大的控制性能)。该单元有许多应用，如控制热流(自动调温器)作为温度功能的机械控制功能，以及减速器的阻尼功能。
③COMBIN39单元：
COMBIN39 是一个具有非线性功能的单向单元，可对此单元输入广义的力－变形曲线。该单元可用于任何分析之中。在一维、二维和三维的应用中，本单元都有轴向或扭转功能。轴向选项（longitudinal） 代表轴向拉压单元，每个节点具有3 个自由度：沿节点坐标系X，Y，Z 的平动，不考虑弯曲和扭转。扭转选项（torsional） 代表纯扭单元，每个节点具有3 个自由度：绕节点坐标轴X，Y， Z 的转动，不考虑弯曲和轴向荷载。
此单元仅当每个节点有两个或者三个自由度的时候，才可以具有大位移的功能。
二、如何选择合适的单元类型？ ANSYS通常会引起许多复杂的单元类型的注意，如何选择正确的单元类型也是一个令人头疼的问题。
1、明确不同单元类型的特点和适用范围。根据Ansys的官方文件，Ansys提供了许多单元类型，如梁单元、壳单元和体单元。梁单元适用于分析横截面小、长度大的部件，如钢梁和桁架。壳单元适用于分析压力容器和飞机外壳等宏观情况。体单元适用于分析三维形状的部件，如车身和机械部件。
当建模开始时，用户会做出许多决定（有意或无意）来确定如何模拟物理系统的数值；分析的目标是什么？该模型是物理系统的全部或部分？该模型将包含多少细节？选择什么样的单元？有限元网格的密度是多少？简而言之，您将平衡要回答的问题的计算成本（CPU时间等）。以及结果的准确性。你在计划阶段做出的这些决定通常会控制你分析的成功。
2、考虑不同单元类型的优缺点。梁单元具有计算速度快、计算精度高的优点，但假设构件为直线形状，不适合弯曲或复杂形状。壳单元可以更好地模拟薄壁结构，但对于较厚的结构，需要使用更复杂的壳单元类型。身体单元可以准确模拟结构的三维形状，但计算量大，对计算机性能要求高。
3、考虑结构分析的目的和要求。如果只需要获得整体应力和变形分布，那么使用低级单元就可以满足需求。如果需要更准确的结果，如局部应力集中分析或接触问题分析，则需要考虑使用高级单元。
4、选择一些单元的方法
①杆单元（Link）VS梁单元(Beam)
这很容易理解。杆单元只能承受沿杆方向的拉力或压力，杆单元不能承受弯矩，这是杆单元的基本特征。梁单元既能承受拉力、压力，又能承受弯矩。如果你想在结构中承受弯矩，你不能选择杆单元。对于梁单元，常用的有三种:beam3、beam4和beam188。它们的区别在于:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f18bf664fb98185592550e17bbfff55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2624e0718ff9ad8714c03c32db99acb1/" rel="bookmark">
			多线程入门知识点及代码详解及相关面试八股文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程详解及相关面试八股文 多线程 线程概述 * 多线程： 进程：当前正在运行的程序，一个应用程序在内存中的执行区域 线程：进程中的一个执行控制单元，执行路径 * 一个进程可以有一个线程，也可以有多个线程 * 单线程：安全性高，但是效率低 * 多线程：安全性低，效率高 * 多线程案例：360,迅雷等 进程 进程相当于公司，多线程相当于公司的多个程序员。
线程 单线程特点：安全性高，一件事交给一个人干，确定性的知道干到哪里了。但是效率低。
多线程特点： 安全性低因为一个人干一部分，需要对接，每个人的写法不一样，对接出现问题，一个人的错误导致整体的问题。但是效率高。
例如：杀毒软件同时做多件事情，电脑体检、木马查杀、电脑清理等。
多线程的优点：提高效率
1.多线程的实现方式一 参考资料：继承Thread类 &amp; 实现Runnable接口 使用解析
继承Thread方法简介 详细实现步骤：
创建线程类(继承自Thread类)复写run ()(定义线程行为)创建线程对象(即实例化线程类)通过线程对象控制线程的状态(如运行、睡眠。挂起1停止) 多线程的实现方式：
1.将类声明为Thread的子类，该子类应该重写thread类的run方法，
2.接下来可以分配并启动该子类的实例.
1.新建一个类，并将类声明为Thread的子类，该子类应该重写thread类的run方法。
package Thread; //标准的多线程实现的类 public class MyThread extends Thread{ @Override public void run(){ for (int i = 0; i &lt; 100; i++) { System.out.println(i); } } } 2.创建多线程实例
public class ThreadDemo1 { public static void main(String[] args) { // 创建线程实例 声明实例 MyThread t = new MyThread(); // 启动多线程 t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2624e0718ff9ad8714c03c32db99acb1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/87/">«</a>
	<span class="pagination__item pagination__item--current">88/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/89/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>