<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d97a1718c091ecdb6e638a74f009debd/" rel="bookmark">
			C# Chart控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 定义图表区域
this.chart1.ChartAreas.Clear();
ChartArea chartArea1 = new ChartArea("C1");
this.chart1.ChartAreas.Add(chartArea1);
//定义存储和显示点的容器
this.chart1.Series.Clear();
Series series1 = new Series("OK");
//series1.ChartArea = "C1";
series1.IsValueShownAsLabel = true;
this.chart1.Series.Add(series1);
Series series2 = new Series("NG");
//series2.ChartArea = "C1"; series2.IsValueShownAsLabel = true;
this.chart1.Series.Add(series2);
//设置图表显示样式
this.chart1.ChartAreas[0].AxisY.Minimum = 0; //设置Y轴最小值
this.chart1.ChartAreas[0].AxisY.Maximum = 100；//设置Y轴最大值 this.chart1.ChartAreas[0].AxisY.MajorTickMark.Interval = 10;//设置Y轴刻度间隔
this.chart1.ChartAreas[0].AxisX.MajorGrid.Enabled = true;//X轴上网格可见
this.chart1.ChartAreas[0].AxisX.IsMarginVisible = false;//不显示X轴的边缘：
this.chart1.ChartAreas[0].AxisX.Interval = 1;
this.chart1.ChartAreas[0].AxisX.LabelStyle.Angle = -45;
this.chart1.ChartAreas[0].AxisX.MajorGrid.LineColor = System.Drawing.Color.Silver;
this.chart1.ChartAreas[0].AxisY.MajorGrid.LineColor = System.Drawing.Color.Silver;
this.chart1.Series[0].Points.AddXY(0, 88);//添加横坐标为0，纵坐标为88的点
this.chart1.Series[0].BorderWidth = 2;//线条粗细
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d97a1718c091ecdb6e638a74f009debd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49fb736d8624b71f3c2e9cfe9bc2d574/" rel="bookmark">
			LeetCode //C - 328. Odd Even Linked List
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		328. Odd Even Linked List Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.
The first node is considered odd, and the second node is even, and so on.
Note that the relative order inside both the even and odd groups should remain as it was in the input.
You must solve the problem in O(1) extra space complexity and O(n) time complexity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49fb736d8624b71f3c2e9cfe9bc2d574/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20723d48c452496b306eec7312b670b9/" rel="bookmark">
			Spring Boot中操作数据库的几种并发事务方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当有多个并发事务时，会发生丢失更新异常。来自一个或多个事务的更新可能会丢失，因为其他事务会用其结果覆盖它。
让我们通过一个例子来检验一下。考虑以下执行事务的方法。
public void withdraw(Long accountId, double amount) {
Account account = accountRepository.findById(accountId).orElseThrow(() -&gt; {
throw new IllegalStateException("account does not exist: " + accountId);
});
double newBalance = (account.getBalance() - amount);
if (newBalance &lt; 0) {
throw new IllegalStateException("there's not enough balance");
}
account.setBalance(newBalance);
accountRepository.save(account);
}
只要在任何给定时间点只有单个事务交易，这段代码会按预期工作。
当有多个同时事务时会发生什么？
在这种情况下，上述代码将无法正常工作。线程 1 对 newBalance 所做的修改线程 2 是看不到的。因此，它可能会破坏数据。当我们用 @Transactional 对方法进行注解时，行为不会发生变化。反正它只是定义应用程序的事务边界。
如何防止损失更新异常？
请注意，Spring 默认遵循底层数据存储的隔离级别。Postgres 的默认隔离级别是 READ_COMMITTED。这意味着它只能看到查询开始前提交的数据，而看不到未提交的数据或查询执行期间并发事务提交的更改。
实际上，我们可以通过原子更新操作来解决这个问题！
怎么做？
使用本地更新查询，在数据库中执行直接更新，而不是使用普通 ORM 风格的 "选择、修改和保存"。
@Transactional
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20723d48c452496b306eec7312b670b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f79f6ca4cdaae2b99a6694429c042e82/" rel="bookmark">
			CentOS安装Docker(超详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS安装Docker 1 知识小课堂2 CentOS安装Docker2.1 1.1.卸载（可选）1.2.安装docker1.3.启动docker1.4.配置镜像加速 3 CentOS安装DockerCompose3.1.下载3.2.修改文件权限3.3.Base自动补全命令： 4 Docker镜像仓库4.1.简化版镜像仓库4.2.带有图形化界面版本4.3.配置Docker信任地址 1 知识小课堂 https://blog.csdn.net/weixin_56781779/article/details/132258636
2 CentOS安装Docker 2.1 1.1.卸载（可选） 如果之前安装过旧版本的Docker，可以使用下面命令卸载：
yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine \ docker-ce 1.2.安装docker 首先需要大家虚拟机联网，安装yum工具
yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 --skip-broken 然后更新本地镜像源：
# 设置docker镜像源 yum-config-manager \ --add-repo \ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo sed -i 's/download.docker.com/mirrors.aliyun.com\/docker-ce/g' /etc/yum.repos.d/docker-ce.repo yum makecache fast 然后输入命令：
yum install -y docker-ce docker-ce为社区免费版本。稍等片刻，docker即可安装成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f79f6ca4cdaae2b99a6694429c042e82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/514405d7a5efb1fd6994d9e1236792a3/" rel="bookmark">
			Leetcode 1367. Linked List in Binary Tree (二叉树好题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linked List in Binary Tree
Medium
Given a binary tree root and a linked list with head as the first node. Return True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False.
In this context downward path means a path that starts at some node and goes downwards.
Example 1:
Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/514405d7a5efb1fd6994d9e1236792a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa1ff9bdbb102d704fc1094fd06e638/" rel="bookmark">
			Redis入门-redis的五大数据类型&#43;三种特殊的数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：Redis有五大基本类型与三种特殊类型的介绍 Redis有五大基本类型：字符串（string）、哈希（hash）、列表（list）、集合（set）和有序集合（sorted set）。
字符串（string）是Redis最基本的类型，可以存储任意类型的数据，如整数、浮点数、二进制数据等。字符串类型的操作包括设置键值对、获取值、增减值等。
哈希（hash）是一个键值对的集合，类似于关联数组。哈希类型适合存储对象，对象的属性作为键，属性值作为值。哈希类型的操作包括设置键值对、获取值、删除键值对等。
列表（list）是一个链表结构，可以存储有序的字符串元素。列表类型的操作包括向列表中添加元素、获取元素、删除元素等。列表类型也可以实现队列或栈的功能。
集合（set）是一个无序的字符串元素的集合，不允许重复元素。集合类型的操作包括添加元素、获取元素、删除元素等。集合类型还支持交集、并集、差集等操作。
有序集合（sorted set）是一个有序的字符串元素的集合，每个元素都有一个分数，根据分数的大小对元素进行排序。有序集合类型的操作包括添加元素、获取元素、删除元素等。有序集合类型可以用于按分数排序的场景。
除了这五种基本类型，Redis还有三种特殊类型：比特图（bitmap）、超时哈希（hyperloglog）和地理位置（geospatial）。
比特图（bitmap）是一种位操作类型，可以在一个字符串中存储位的序列，支持对位进行操作，如设置位、获取位、统计位等。比特图类型可以实现布隆过滤器、统计在线用户等功能。
超时哈希（hyperloglog）是一种基数估计算法，可以估计一个集合中的不同元素的个数。超时哈希类型的操作包括添加元素、估计基数等。超时哈希类型适用于需要统计去重后的数据量的场景。
地理位置（geospatial）是一种可以存储地理位置信息的类型，支持地理位置的存储、计算距离等操作。地理位置类型可以用于地图相关的应用，如附近的人、附近的商家等。
三、五大数据类型 Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列MQ代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。
先开启Redis
Redis-key 在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。
下面学习的命令：
exists key：判断键是否存在del key：删除键值对move key db：将键值对移动到指定数据库expire key second：设置键值对的过期时间type key：查看value的数据类型 127.0.0.1:6379&gt; keys * # 查看当前数据库所有key (empty list or set) 127.0.0.1:6379&gt; set name qinjiang # set key OK 127.0.0.1:6379&gt; set age 20 OK 127.0.0.1:6379&gt; keys * 1) "age" 2) "name" 127.0.0.1:6379&gt; move age 1 # 将键值对移动到指定数据库 (integer) 1 127.0.0.1:6379&gt; EXISTS age # 判断键是否存在 (integer) 0 # 不存在 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caa1ff9bdbb102d704fc1094fd06e638/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/209578735b5e9d886817b78527dcb35d/" rel="bookmark">
			C语言中关于函数递归的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		递归的概念：如果一个对象部分包含它自己,或者利用自己定义自己,则称这个对象是递归的;如果 一个过程直接或间接调用自己,则称这个过程是一个递归过程。递归的主要思考方式在于：将大事化小
我们先看一个例子
题目：输入一个无符号数，并输出这个数的每一位 ​#include"stdio.h" void print(unsigned int n) { if(n&gt;9) print(n/10); printf("%u ",n%10); } int main() { unsigned int num=0; //unsigned：无符号类型 scanf("%u",&amp;num); //%u 无符号的数据类型 print(num); return 0; } ​ 那么我们来看看具体的运行方式：
注意：函数每次递归都会开辟出一个空间，也称为栈，而执行完这个栈里面的所有东西之后，这个栈就会被销毁
现在已经把条件执行完了，那么接下来就要开始返回了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8650196c5967809e5b5eb8fc147063b/" rel="bookmark">
			【Machine Learning】Unsupervised Learning
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本笔记基于清华大学《机器学习》的课程讲义无监督学习相关部分，基本为笔者在考试前一两天所作的Cheat Sheet。内容较多，并不详细，主要作为复习和记忆的资料。
Principle Component Analysis Dimension reductio: JL lemma d = Ω ( log ⁡ n ϵ 2 ) d=\Omega\left(\frac{\log n}{\epsilon^2}\right) d=Ω(ϵ2logn​) to remain the distance of n n n data points.Goal of PCA maximize variance: E [ ( v ⊤ x ) 2 ] = v ⊤ X X ⊤ v \mathbb{E}[(v^\top x)^2]=v^\top XX^\top v E[(v⊤x)2]=v⊤XX⊤v for ∣ v ∣ = 1 |v|=1 ∣v∣=1minimize reconstruction error: E [ ∣ x − ( v ⊤ x ) v ∣ 2 ] \mathbb{E}[|x-(v^\top x)v|^2] E[∣x−(v⊤x)v∣2] Find v i v_i vi​ iteratively, project data points onto subspace expanded by v 1 , v 2 , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8650196c5967809e5b5eb8fc147063b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb311b365064d9743d7cd5d3e87420e/" rel="bookmark">
			【Machine Learning】Supervised Learning
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本笔记基于清华大学《机器学习》的课程讲义监督学习相关部分，基本为笔者在考试前一两天所作的Cheat Sheet。内容较多，并不详细，主要作为复习和记忆的资料。
Linear Regression Perceptron f ( x ) = s i g n ( w ⊤ x + b ) f(x)=sign(w^\top x+b) f(x)=sign(w⊤x+b)convergence Logistic Regression output probability instead of labels.Loss: Cross entropy X E ( y , p ) = − ∑ i y i log ⁡ p i XE(y,p)=-\sum_iy_i\log p_i XE(y,p)=−∑i​yi​logpi​. y i y_i yi​ is the actual probability Ridge Regression l 2 l_2 l2​ regularization λ 2 ∥ w ∥ 2 2 \frac{\lambda}{2}\|w\|^2_2 2λ​∥w∥22​Shrink every coordinate: w ′ = w ⋅ ( 1 − η λ ) w'=w\cdot (1-\eta \lambda) w′=w⋅(1−ηλ) weight decay LASSO Regression Find sparse features: Want ∥ w ∥ 0 ≤ c \|w\|_0\le c ∥w∥0​≤c l 1 l_1 l1​ regularization λ ∥ w ∥ 1 \lambda\|w\|_1 λ∥w∥1​Gradient: add or minus η λ \eta \lambda ηλ to pull w w w into 0 0 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfb311b365064d9743d7cd5d3e87420e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a2f30a9c26a903d3b41d94b91588286/" rel="bookmark">
			西瓜书读书笔记整理（九） —— 第九章 聚类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第九章 聚类 9.1 聚类算法概述9.1.1 什么是聚类算法9.1.2 聚类算法分类9.1.3 聚类任务 9.2 性能度量（Cluster Evaluation）9.2.1 外部指标（external index）9.2.2 内部指数（internal index） 9.3 距离度量（Distance Measures）9.3.1 距离度量的性质9.3.2 常见的几种距离的计算公式 9.4 原型聚类（prototype-based clustering）9.4.1 k-means 算法9.4.2 学习向量化（Learning Vector Quantization, LVQ）9.4.3 高斯混合聚类（Mixture-of-Gaussian） 9.5 密度聚类（density-based clustering）9.6 层次聚类（hierarchical clustering）9.7 小结 9.1 聚类算法概述 9.1.1 什么是聚类算法 聚类算法是一类无监督学习算法，它的主要任务是将数据集中的样本划分为若干个不同的组，使得同一组内的样本之间具有较高的相似性，而不同组之间的样本具有较大的差异性
9.1.2 聚类算法分类 聚类算法是一类无监督学习算法，它的主要任务是将数据集中的样本划分为若干个不同的组，使得同一组内的样本之间具有较高的相似性，而不同组之间的样本具有较大的差异性。聚类算法主要分为以下几类：
原型聚类（prototype-based Clustering）：基于数据点和聚类中心之间的距离来将数据点分组。在原型聚类中，每个聚类都由一个或多个 “原型”（也称为聚类中心）来代表。这些原型通常位于数据空间中的某些位置，它们的选择和更新是聚类算法的关键部分。
K均值（K-Means）：将数据集划分为K个簇，每个簇以其内部样本的平均值表示。学习向量化（Learning Vector Quantization, LVQ）：通过学习过程来调整一组原型向量，使得这些原型能够有效地代表不同的类别。算法通过逐步调整原型向量的位置，使其更好地匹配训练数据的特征，从而提高对未见过数据的泛化能力。高斯混合聚类（Mixture-of-Gaussian, GMM）：GMM 是一种概率模型，通常用于聚类和密度估计。GMM假设数据是由若干个高斯分布（正态分布）组合而成的，每个分布称为一个“分量”，这些分量的混合形成了观测数据的分布。 密度聚类（Density-Based Clustering）：基于密度的聚类算法通过考察样本点周围的密度来形成簇。这使得它能够发现任意形状的簇，并对噪声点具有较好的鲁棒性。
DBSCAN（Density-Based Spatial Clustering of Applications with Noise）：根据样本点周围的密度划分簇，能够发现任意形状的簇。 层次聚类（Hierarchical Clustering）：层次聚类算法通过构建层次结构来组织数据。这种方法不仅能够划分簇，还能够展示簇之间的嵌套关系。
凝聚层次聚类（Agglomerative Hierarchical Clustering）：从单个数据点开始，逐渐合并相邻的簇，直到形成一个大的簇。分裂层次聚类（Divisive Hierarchical Clustering）：与凝聚层次聚类相反，从整个数据集开始，逐渐划分为小的簇。 9.1.3 聚类任务 聚类任务是无监督学习中的一种任务，其目标是将数据集中的样本划分为若干个不同的组，使得同一组内的样本之间具有较高的相似性，而不同组之间的样本具有较大的差异性。聚类任务的目的是通过发现数据中的潜在结构，将相似的样本归为一类，从而揭示数据的内在模式和组织结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a2f30a9c26a903d3b41d94b91588286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82afdd74b5da94885993070dd3300290/" rel="bookmark">
			计算机基础面试题 |20.精选计算机基础面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤍 前端开发工程师（主业）、技术博主（副业）、已过CET6
🍨 阿珊和她的猫_CSDN个人主页
🕠 牛客高级专题作者、在牛客打造高质量专栏《前端面试必备》
🍚 蓝桥云课签约作者、已在蓝桥云课上架的前后端实战课程《Vue.js 和 Egg.js 开发企业级健康管理项目》、《带你从入门到实战全面掌握 uni-app》
文章目录 POST和GET有哪些区别？各自应用场景？在实际应用中，如何选择合适的请求方法？什么是HTTP缓存？它有什么作用？ POST和GET有哪些区别？各自应用场景？ POST 和 GET 是 HTTP 协议中用于向服务器发送请求的两种方法。它们的主要区别如下：
请求方式：POST 请求将请求参数作为请求体的一部分发送给服务器，而 GET 请求将请求参数附加在请求的 URL 中。
可见性：GET 请求的请求参数在 URL 中是可见的，因此不适合传输敏感数据。而 POST 请求的请求参数在请求体中，对于用户是不可见的。
长度限制：由于 URL 的长度限制，GET 请求的请求参数长度通常受到限制。而 POST 请求的请求体可以容纳较大的数据量。
缓存：GET 请求可以被缓存，而 POST 请求一般不被缓存。
用途：GET 请求通常用于获取数据，例如请求网页、查询数据等。而 POST 请求通常用于提交数据给服务器，例如提交表单、上传文件等。
应用场景：
GET：适用于以下场景： 获取数据：获取网页内容、查询数据等。资源检索：通过 URL 传递参数，检索资源。缓存友好：因为可以被缓存，适用于不需要频繁更新的数据。 POST：适用于以下场景： 提交数据：提交表单、上传文件等。更新数据：向服务器发送大量数据，进行更新操作。敏感操作：传递密码、信用卡信息等敏感数据。 需要根据具体的需求选择合适的请求方法。在实际应用中，还可以使用其他 HTTP 请求方法，如 PUT、DELETE 等，根据不同的操作来选择合适的方法。
在实际应用中，如何选择合适的请求方法？ 在实际应用中，选择合适的 HTTP 请求方法（GET、POST、PUT、DELETE 等）需要考虑以下几个因素：
操作类型：根据要执行的操作类型来选择请求方法。GET 用于获取资源，POST 用于创建或更新资源，PUT 用于更新资源的全部内容，DELETE 用于删除资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82afdd74b5da94885993070dd3300290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/958c1428a443147fc41b3c12a82b51fd/" rel="bookmark">
			Java项目：01 springboot智能养生平台设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 Java项目 智能养生平台
使用技术：spring+mybatis+springmvc+html+JavaScript+css+layui+jQuery
运行环境
jdk8+mysql+IntelliJ IDEA+maven
主要分两个端，用户端和管理员端
网站功能：实现论坛帖子管理，论坛帖子分类管理，留言管理，用户登录注册，管理员管理，
验证码使用，ajax使用，分页查询，报表统计，友情链接，问卷提交，问卷添加修改，问卷结果查看等。
管理员端主要功能:
管理员管理、用户管理、问卷管理、问卷结果管理、帖子分类管理、数据分析统计、公告管理、帖子管理、友情链接管理、留言管理
环境要求 1.运行环境：最好是java jdk1.8,我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA,Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat7.x,8.X,9.x版本均可
4.硬件环境：windows7/8/10 4G内存以上；或者Mac OS;
5.是否Maven项目：是；查看源码目录中是否包含pom.xml;若包含，则为maven项目，否则为非maven.项目
6.数据库：MySql5.7/8.0等版本均可；
技术栈 后台框架：Spring Boot、MyBatis
数据库：MySQL
环境：JDK8、TOMCAT、IDEA
使用说明 1.使用Navicati或者其它工具，在mysql中创建对应sq文件名称的数据库，并导入项目的sql文件；
2.使用IDEA/Eclipse/MyEclipse导入项目，修改配置，运行项目；
3.将项目中config-propertiesi配置文件中的数据库配置改为自己的配置，然后运行；
运行指导 idea导入源码空间站顶目教程说明(Vindows版)-ssm篇：
http://mtw.so/5MHvZq
源码地址：http://codegym.top。
运行截图 前端页面 管理员端页面 相关代码 AdminController
package com.module.controller.base; import com.module.mapper.AdminMapper; import com.module.pojo.Admin; import com.module.util.MD5Util; import com.module.util.ResultUtil; import com.github.pagehelper.PageHelper; import com.github.pagehelper.PageInfo; import org.apache.commons.lang.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import javax.servlet.http.HttpSession; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/958c1428a443147fc41b3c12a82b51fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ee0c65dce0133b0ba4146f8902e10b1/" rel="bookmark">
			计算机基础面试题 |19.精选计算机基础面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤍 前端开发工程师（主业）、技术博主（副业）、已过CET6
🍨 阿珊和她的猫_CSDN个人主页
🕠 牛客高级专题作者、在牛客打造高质量专栏《前端面试必备》
🍚 蓝桥云课签约作者、已在蓝桥云课上架的前后端实战课程《Vue.js 和 Egg.js 开发企业级健康管理项目》、《带你从入门到实战全面掌握 uni-app》
文章目录 怎么解决拆包和粘包？ICMP 有哪些应用？IPV4 地址不够如何解决TCP 最大连接数限制 怎么解决拆包和粘包？ 在网络通信中，拆包和粘包是指在数据传输过程中，将一个完整的数据包拆分成多个部分进行传输，或者将多个数据包合并成一个进行传输的现象。这可能会导致数据接收方无法正确解析和处理数据包。
以下是一些常见的解决拆包和粘包问题的方法：
固定长度数据包：在发送数据时，将数据包的长度固定为一个固定的值。接收方可以根据固定的长度来解析和处理数据包。这种方法简单直观，但可能会导致数据包的浪费和效率低下。
数据包边界标识：在数据包的开头和结尾添加特定的标识或标记，以指示数据包的起始和结束位置。接收方可以根据这些标识来识别和处理数据包。常见的标识包括特殊字符、特定的字节序列等。
协议头部：在数据包的头部中添加一些元数据，如数据包长度、序号等信息。接收方可以根据头部信息来正确解析和处理数据包。
滑动窗口协议：滑动窗口协议是一种用于流式数据传输的协议。它通过在发送方和接收方之间维护一个窗口，来控制数据包的发送和接收。发送方可以根据窗口的大小发送一定数量的数据包，接收方可以根据窗口的位置来确认已经接收的数据。
数据序列化和反序列化：使用序列化和反序列化技术，将数据对象转换为字节流进行传输，并在接收方将其还原为原始的数据对象。这样可以确保数据包的完整性和一致性。
需要根据具体的应用场景和通信协议来选择适合的解决方法。在设计和实现网络通信时，应该充分考虑拆包和粘包问题，并采取相应的措施来确保数据的可靠传输和正确处理。
ICMP 有哪些应用？ ICMP（Internet Control Message Protocol）是互联网协议套件的一部分，主要用于在 IP 网络中发送控制消息和错误报告。
以下是一些常见的 ICMP 应用：
错误报告：ICMP 可用于报告 IP 数据包在传输过程中发生的错误。例如，如果目标主机不可达或超时，路由器会使用 ICMP 向源主机发送错误消息。
网络测试：使用 ICMP 可以进行一些基本的网络测试，例如 ping 命令。通过向目标主机发送 ICMP 请求（Echo 请求）并等待回复（Echo 回复），可以测试网络的连接性和延迟。
Traceroute：Traceroute 工具利用 ICMP 的时间超时（Time Exceeded）消息来确定从源主机到目标主机之间的网络路径。
路径 MTU 发现：通过发送 ICMP 数据包并设置不分片（Don’t Fragment）标志，源主机可以发现沿着路径到目标主机的最大传输单元（MTU）。
网络管理：ICMP 可用于网络管理和监控。例如，一些网络设备可以使用 ICMP 消息来通告网络状态或发送警报。
需要注意的是，虽然 ICMP 对于网络诊断和调试非常有用，但它也可能被滥用用于 DoS（拒绝服务）攻击。因此，网络设备通常会对 ICMP 流量进行限制或过滤，以防止恶意攻击。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ee0c65dce0133b0ba4146f8902e10b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63330632e2ee9ae378bb01d695598533/" rel="bookmark">
			特别讨厌python的语法,最后却离不开他了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信我，这不是Python的错，因为人都是不愿意接受改变的。
Python现在是我的绝对主力编程语言，但是在第一次接触Python的时候，我却特别讨厌它的语法。
因为我在学校参加竞赛的时候学的是C语言，C语言是长成这样的。
#include &lt;stdio.h&gt;
int main()
{
printf("Hello, World!");
return 0;
}
工作后，主要使用Java开发，Java是长这样的。
public class Hello{
public static void main(String args[]){
System.out.println("Hello World");
}
}
C和Java长得挺像的，都是用花括号定义代码块的作用域，一目了然。而且用分号作为一行代码的结束，写完一行代码敲一个分号是一种满满的仪式感，就好像运行程序的时候总要狠狠的按下enter键一样。
然后就接触了Python，这货是长这样的。
def main():
print("Hello World")
没有花括号，竟然要靠缩进来定义代码块，恰好那时候用Python是做Linux部署和运维，需要使用vi做编辑器，曾经被tab和空格折磨的死去活来（懂得都懂）。
一行代码结束，竟然不要分号，对于习惯C和Java的我而言，就意味着写完一行代码心情正爽的时候，偏要硬生生忍住敲下分号的欲望，这样真的会憋出内伤的。
另外，还有函数定义竟然不要声明返回值类型，函数名后面还要加一个恶心的冒号，变量随便用不需要声明类型，感觉不是一门靠谱的编程语言。
一开始的转变是润物细无声的，因为观察一下上面的代码就会发现Python这货的代码好精简，在Linux命令行下面写Python很舒适，几乎是随处可写，随处可用。
如果是写Java我一定会崩溃，我写Java代码的时候需要严重的依赖IDE，换一台电脑都会觉得很不适应，而且Java的代码量太大了。渐渐的一些小功能，我就都用Python随手做了，再也不依赖IDE了。
但是到此为止，我最喜欢的语言依然是Java，只是不讨厌Python而以。
真正的改变是撞上了Python的天赋技能之一——爬虫。我猜可能是因为蛇也是爬虫的一种吧。
我们项目组需要写一个爬虫，一开始大家使用C++（因为所有人都会），包括抓取，登录，抽取。这个过程真是太痛苦了，即使写完了也没人愿意维护，每次更新也很痛苦。
更重要的是，C++虽然性能高，但是抓取的时间大部分耗在网络IO，性能优势没有发挥出来。
后来，突然发现Python可以用scrapy抓取，用beautifulsoup抽取，根本不需要原项目十分之一的代码量就能搞定。
从此以后，用Django做网站，用Keras训练模型，陆续变成了我的主要工作，跟Python也更加难舍难离了。
现在，Python是我最推荐的编程语言。回想最开始对Python的不适，主要还是太习惯于C这类语言的习惯，自己不愿意改变。如果愿意接受改变，你一定会发现Python真香。转载，shan​中国科学院研究生院 计算机软件与理论博士
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb2c6bccb1a6f89a1b563027cde6b773/" rel="bookmark">
			【算法】链表-20240109
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 一、141. 环形链表二、876. 链表的中间结点三、面试题 02.01. 移除重复节点 一、141. 环形链表 简单
给你一个链表的头节点 head ，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。
为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。
如果链表中存在环 ，则返回 true 。 否则，返回 false 。
示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
示例 2：
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
示例 3：
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
在本题中使用快慢指针：
若是链表无环，那么 fast 指针会先指向 Null。
若是链表有环，fast 和 slow 迟早会在环中相遇。
class Solution: def hasCycle(self, head): #如果空链表或者只有一个节点。无环 if not head or head.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb2c6bccb1a6f89a1b563027cde6b773/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6387cc7d14d730446da45715a55d9073/" rel="bookmark">
			leetCode 128.最长连续序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
示例 1： 输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
示例 2：
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
class Solution { public int longestConsecutive(int[] nums) { if(nums == null || nums.length == 0){ return 0; } if(nums.length == 1){ return 1; } Set&lt;Integer&gt; numset = new HashSet&lt;&gt;(); for(int num: nums){ numset.add(num); } int longestStreak = 0; for(Integer num : numset) { if(!numset.contains(num - 1)) { int currentNum = num; int currentStreak = 1; while(numset.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6387cc7d14d730446da45715a55d9073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e398d053621ddc1354535afaa3d46602/" rel="bookmark">
			嵌出式学习的一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前的想法是直接过一遍视频，然后再码一下代码，熟悉一下，百炼成金！！！！！ 定时器中断实验
时钟的选择：
1.内部时钟
2.外部时钟模式1：外部输入脚（TIX）
3.外部时钟模式2：外部触发输入（ETR）
4.内部触发输入itrx:使用一i个定时器作为另一个定时器的预分频器
除非APB1的分频系数是1，否则通用定时器的时钟等于APB1的时钟的2倍
/* 定时器中断实现步骤 1.定时器时钟使能 2.初始化定时器，配置ARR.PSC 3.开启定时器中断，配置NVIC 4.使能定时器 6.编写中断服务函数 产生现象如下： 通过定时器配置，每500ms中断一次，然后中断服务函数中控制LED实现LED1状态取反（闪烁） */ #include "time.h" #include "led.h" void TIM3_Int_Init(u16 arr,u16 psc){ TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE); TIM_TimeBaseInitStructure.TIM_Period=arr; TIM_TimeBaseInitStructure.TIM_Prescaler=psc; TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up;//向上计数模式 TIM_TimeBaseInitStructure.TIM_ClockDivision= TIM_CKD_DIV1; TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure); TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE); //中断优先级nvic配置 NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn; //TIM3 中断 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //先占优先级 0 级 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //从优先级 3 级 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ 通道被使能 NVIC_Init(&amp;NVIC_InitStructure); //④初始化 NVIC 寄存器 TIM_Cmd(TIM3, ENABLE); } //定时器中断服务函数 void TIM3_IRQHandler(void){ if(TIM_GetITStatus(TIM3,TIM_IT_Update)!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e398d053621ddc1354535afaa3d46602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9808c4204466acdbde50605c71784aa3/" rel="bookmark">
			clickhouse闭源，以后都要用国产数据库了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 点击下方“JavaEdge”，选择“设为星标”
第一时间关注技术干货！
免责声明~
任何文章不要过度深思！
万事万物都经不起审视，因为世上没有同样的成长环境，也没有同样的认知水平，更「没有适用于所有人的解决方案」；
不要急着评判文章列出的观点，只需代入其中，适度审视一番自己即可，能「跳脱出来从外人的角度看看现在的自己处在什么样的阶段」才不为俗人。
怎么想、怎么做，全在乎自己「不断实践中寻找适合自己的大道」
0 今日话题 有个粉丝朋友和我聊到，大约是16年刚毕业时，工作原因给客户单位部署安装系统，绝大多数单位都是oracle数据库，只有一个安全级别极高的单位使用的是达梦数据库，印象中非常不好用。
时隔多年，我都换了两次工作了，现在我们的甲方的数据库又要从vertica数据库迁移到国产的GBase数据库了，培训了两次，好像已经感觉到不是那么好用了，是我心理的原因还是真的会不好用？以后国内大趋势是不是都会用国产的数据库啊？
嘿，你还别说，还真不幸被你说中了。clickhouse已经计划不再开源，只有云版，被市场淘汰，kafka+spark是主流，flink还多存在广告水文中。而且 clickhouse 可用doris替代，只能说体验也好了一大截。
1搞信创 参与搞信创要满足信创要求的，才必须用国产数据库。而所谓国产数据库，不少都是拿MySQL或PostGresgl改了下就号称自主可控了。要搞信创都是比较大大的公司单位了，在小公司就不用考虑信创的要求作为使用方，使用原生MySQL或PostGresgl，跟更用国产修改后的版本，普通场景下差别不大。
高斯DB 华为这种等级厂商的包装产品，比如那个高斯DB，直接把PG库的数据目录放过去，就直接能用，就是版本得对。一般这种大厂商，不会瞎几把搞，他们重点只是弄个外壳不一样而已。反观某些小公司，非要加上自研的一些东西，反而兼容性不好了。很多银行抛弃了TiDB，oracle全部迁移到高斯，导致这几年工作内容迁移高斯。
3 我的一位金融朋友 说到，集团的亿级用户的平台用的OceanBase，除了上次阿里云宕机跟着卡了一下午外没什么问题。
手头负责的大数据平台用的TiDB，性能杠杠的。正在推动的一个小项目选了金仓，金仓最近刚刚更新了一个新版本，对MySQL的兼容性非常完美，原型系统是在MySQL上，近乎平移。今年下半年的金仓和去年这个时候的金仓，优化后几乎就是两个东西，给国产数据库一点时间，它成长的比你想象的要快。
原文出自于：
编程严选网（www.javaedge.cn）
写在最后 编程严选网（www.javaedge.cn），程序员的终身学习网站已上线！
点击阅读原文，即可访问网站！
欢迎长按图片加好友，我会第一时间和你分享软件行业趋势，面试资源，学习途径等等。
添加好友备注【技术群交流】拉你进群，更多教程资源应有尽有
关注公众号后，在后台私信：
回复【架构师】，获取架构师学习资源教程
回复【面试】，获取最新最全的互联网大厂面试资料
回复【简历】，获取各种样式精美、内容丰富的简历模板
回复 【路线图】，获取直升Java P7技术管理的全网最全学习路线图
回复 【大数据】，获取Java转型大数据研发的全网最全思维导图
微信【ssshflz】私信 【副业】，进副业交流群
点击【阅读原文】，即可访问程序员一站式学习网站
最近在准备面试，为大家准备一份2024最新最全Java学习路线一条龙 程序员职业/技术发展知识星球（24 年首月仅需 25 最低价！） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69157bc483cab75ab705f4c8354420e6/" rel="bookmark">
			【设计模式】外观模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 1. 单例模式（Singleton Pattern）：保证一个类只有一个实例，并提供一个全局的访问点。
2. 工厂模式（Factory Pattern）：定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。
3. 观察者模式（Observer Pattern）：定义对象之间的一对多依赖关系，使得当一个对象的状态发生改变时，所有依赖于它的对象都会被自动通知并更新。
4. 装饰器模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责，而不会影响到其他对象。
5. 策略模式（Strategy Pattern）：定义一系列的算法，将每个算法封装起来，并使它们可以相互替换。
6. 命令模式（Command Pattern）：将请求封装成一个对象，从而使用户可以用不同的请求对客户进行参数化。
7. 适配器模式（Adapter Pattern）：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类能够一起工作。
8. 外观模式（Facade Pattern）：为子系统中的一组接口提供一个统一的接口，从而使得子系统更加容易使用。
9. 状态模式（State Pattern）：允许一个对象在其内部状态改变时改变其行为。
10. 模板方法模式（Template Method Pattern）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中实现。
这些是Python中常用的设计模式，通过使用这些设计模式可以提高代码的可读性、可维护性和重用性。
外观模式 外观模式是一种结构型设计模式，它为复杂子系统提供一个简化的接口，使得客户端可以更容易地使用这个子系统。
具体实例一 # 子系统A class SubsystemA: def operation_a1(self): print("SubsystemA: Operation A1") def operation_a2(self): print("SubsystemA: Operation A2") # 子系统B class SubsystemB: def operation_b1(self): print("SubsystemB: Operation B1") def operation_b2(self): print("SubsystemB: Operation B2") # 外观类 class Facade: def __init__(self, subsystem_a, subsystem_b): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69157bc483cab75ab705f4c8354420e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28907f5ceca4d03216ed7c45e8ea185a/" rel="bookmark">
			Gogs 创建新的仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gogs 创建新的仓库 1. 创建新的仓库References 1. 创建新的仓库 References [1] Yongqiang Cheng, https://yongqiang.blog.csdn.net/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/950266a796190c34bcc409992ae7fd23/" rel="bookmark">
			Rust基础类型之布尔类型和字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		布尔类型 Rust 中的布尔类型为 bool，仅仅有两个值，true 和 false。比如下方代码：
let flag1 = true; let flag2: bool = false; 字符 Rust 中的字符类型是 char，值用单引号''括起来。
fn main() { let char1 = 'z'; let char2: char = 'ℤ'; let heart_eyed_cat = '😻'; let chinesechar1 = '中'; } Rust 的char类型存的是Unicode散列值。这意味着它可以表达各种符号，比如中文符号、emoji符号等。在 Rust 中，char 类型在内存中总是占用 4 个字节大小。这一点与 C 语言或其他某些语言中的 char 有很大不同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3356131ac598e222781ce3c32560f93/" rel="bookmark">
			L1-012 计算指数(Java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 真的没骗你，这道才是简单题 —— 对任意给定的不超过 10 的正整数 n，要求你输出 2n。不难吧？
输入格式： 输入在一行中给出一个不超过 10 的正整数 n。 输出格式： 在一行中按照格式 2^n = 计算结果 输出 2n 的值。 输入样例： 5 输出样例： 2^5 = 32 解题思路 直接秒了！
解题过程中遇到的问题 暂无
代码 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int sum = 1; for (int i = 1; i &lt;= n; i++) { sum *= 2; } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3356131ac598e222781ce3c32560f93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5980041c512dd21cf6c65a0090a862ed/" rel="bookmark">
			C#，入门教程(13)——字符（char）及字符串（string）的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇：
C#，入门教程(12)——数组及数组使用的基础知识https://blog.csdn.net/beijinghorn/article/details/123918227
字符串的使用与操作是必需掌握得滚瓜烂熟的编程技能之一！！！！！
C#语言实现预定义了多种基础的数据类型。
字符 Char、字符串String 与 数学Math 是 C# 系统级别的、预定义的数据类型。
其中 String 专门用于字符串的存储与处理，一般写作 string 。
本文介绍 string 的常用使用方法。
一、字符串的定义 string 与其他数据类型没有太大的差别。
// 字符串以一对双引号开始与结束 string a = "hello"; // 如果字符串内有双引号 string b = "hello\""; // 或者 string c = @"hello"""; // 字符创数组 string[] WeekDaysChinese = new string[7] { "周一", "周二", "周三", "周四", "周五", "周六", "周日", }; 二、字符串的定位、遍历 Length IndexOf 1、字符串长度 Length 与 截取字串 Substring 字符串的长度就是字符（英文、数字与汉字都算一个）个数。
// 字符串的遍历 string helloString = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5980041c512dd21cf6c65a0090a862ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb9747abcc5465f7ee19284dd1ba4335/" rel="bookmark">
			基于java的模拟写字板系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java的模拟写字板系统设计与实现
I. 引言 A.研究背景和动机 基于Java的模拟写字板系统是一种基于图形用户界面的软件应用程序，主要用于在计算机屏幕上显示文本和图形。该系统的设计与实现旨在为用户提供一种高效、灵活、可自定义的书写环境。基于Java的模拟写字板系统主要应用于教育、商业、科学等领域，是计算机图形学、计算机视觉、计算机科学等领域的核心应用之一。
该系统的设计主要涉及以下几个方面：文本字体、颜色、布局、文本输入、文本输出、图形输出、鼠标操作、文本编辑、文本格式化、文本格式化、键盘操作、图形绘制、键盘操作等。在Java中，模拟写字板系统需要使用Java2D、JavaFX等图形库，以及Java的Swing、JInternalFrame等框架。
为了实现基于Java的模拟写字板系统的设计，需要完成以下几个任务：
编写Java程序，实现模拟写字板系统的核心功能，包括文本输入、文本输出、图形输出、鼠标操作、文本编辑、文本格式化、键盘操作、图形绘制、键盘操作等。实现文本字体、颜色、布局、文本输入、文本输出、图形输出、鼠标操作、文本编辑、文本格式化、文本格式化、键盘操作、图形绘制、键盘操作等功能，实现用户界面。
以上是基于Java的模拟写字板系统设计与实现的研究背景和动机，以及相关的设计任务和实现任务。通过完成这些任务，可以实现一个高效、灵活、可自定义的书写环境，为用户提供更加便捷的书写体验。 B.目标和意义 目标
模拟写字板系统旨在为用户提供高效、便捷的书写体验，用户可以在系统上进行文字输入、文本编辑、文本格式化、字体设置等操作。同时，系统还支持用户自定义快捷键，方便用户在输入文字时更加便捷。此外，系统还支持用户在书写时添加文本样式、文本背景颜色、文本对齐方式等，为用户提供更加丰富的文本编辑体验。意义
模拟写字板系统在现代办公、学习、娱乐等领域都有广泛的应用。在办公领域，用户可以使用系统进行文字处理、文件管理、邮件发送等操作，提高工作效率；在学习领域，用户可以使用系统进行笔记、读书笔记、作业等操作，提高学习效率；在娱乐领域，用户可以使用系统进行绘画、写作、游戏等操作，提高娱乐体验。此外，模拟写字板系统还可以提高用户对文字的理解和应用能力，对于学生和教师来说，系统还可以提高学生的学习能力和教师的教学能力。 II. 相关技术和工具 A.Java语言 Java是一种面向对象的高级编程语言，由Sun Microsystems（现在是Oracle公司）于1995年发布。Java的设计目标是可移植、可靠、安全和简单易学，并且具有优秀的性能和高效的垃圾回收机制。
Java语言拥有许多特点和优势，其中最重要的是它的跨平台性。Java程序可以在任何支持Java虚拟机（JVM）的平台上运行，而不需要重新编译。这使得Java成为开发跨平台应用程序的理想选择。
Java还拥有丰富的类库和API，包括各种功能和领域所需的类和方法。这些类库和API极大地简化了程序开发工作，提高了开发效率。
此外，Java还支持多线程，这使得程序能够同时执行多个任务。多线程可以提高程序的性能和响应能力。
总之，Java是一种优秀的编程语言，具有跨平台性、丰富的类库和API、多线程等特点。这些优势使得Java成为开发各种应用程序的理想选择。
B.数据库技术 数据库技术是计算机科学中的一个重要领域，它主要研究如何设计、实现、管理和维护数据存储系统。在计算机应用中，数据库技术是数据存储和管理的基础，广泛应用于企业、政府、科研等领域。数据库技术的主要目的是实现数据的存储、管理和共享，提高数据的利用效率和安全性。数据库技术主要包括数据存储、数据管理和数据共享三个方面。
数据存储是数据库技术的核心，它是指将数据存储在计算机系统中。数据存储的方式有多种，包括文件存储、磁盘存储、内存存储等。其中，文件存储是最常见的一种方式，它是指将数据存储在磁盘上的文件系统中。磁盘存储是指将数据存储在磁盘上的方式，内存存储是指将数据存储在计算机内存中的方式。选择哪种存储方式，取决于应用场景和数据量的大小。
数据管理是指对数据进行管理、维护和更新的过程。数据管理包括数据设计、数据维护、数据更新和数据备份等多个方面。数据设计是指对数据进行结构设计、数据模式设计和数据约束设计等。数据维护是指对数据进行增删改查等操作，保证数据的完整性和一致性。数据更新是指对数据进行修改和调整，使其满足新的需求。数据备份是指对数据进行备份，以防止数据丢失或损坏。
数据共享是指将数据共享给其他用户或系统。数据共享可以通过多种方式实现，包括文件共享、网络共享、数据库连接等。数据共享可以提高数据的使用效率和数据的可访问性，也可以促进数据的协同开发和协作工作。
总之，数据库技术是数据存储和管理的基础，它广泛应用于企业、政府、科研等领域。在未来的发展中，数据库技术将继续发展和完善，成为更加智能、高效和安全的数据存储和管理系统。
C.GUI技术 GUI，全称Graphical User Interface，是计算机图形用户界面的缩写。在计算机系统中，用户可以通过GUI界面与计算机进行交互，完成各种操作，例如打开应用程序、输入数据、运行程序等。GUI界面是一种非常直观、简单易用的界面设计方式，它能够为用户提供良好的交互体验，并且可以减少用户学习和使用计算机的时间。
GUI技术主要包括图形元素、图形库、图形驱动和图形编程语言等。图形元素是指图形化界面中的各种元素，例如按钮、文本框、菜单、窗口等。图形库是指各种图形元素的集合，例如Windows的API、Java的Swing库等。图形驱动是指图形界面中的底层硬件，例如显示卡、鼠标、键盘等。图形编程语言则是指开发GUI应用程序的编程语言，例如Java、C#、C++等。
GUI技术可以应用于各种领域，例如桌面应用程序、移动应用程序、Web应用程序等。在桌面应用程序中，GUI技术可以实现各种功能，例如文本编辑、文件管理、游戏等。在移动应用程序中，GUI技术可以实现各种功能，例如短信发送、浏览器、地图等。在Web应用程序中，GUI技术可以实现各种功能，例如在线购物、社交网络、新闻阅读等。
总之，GUI技术是一种非常实用、高效的界面设计方式，它可以为用户提供良好的交互体验，并且可以应用于各种领域。随着计算机技术的不断发展，GUI技术也将继续得到发展和改进，为用户带来更加智能、便捷的计算机体验。
III. 系统需求分析与设计 A.系统功能需求 写字板的基本功能：
写字板的基本功能包括文本输入、文本输出、文本编辑、文本查找、文本替换、文本格式化、文本分页等。其中，文本输入和输出是用户最基本的需求，文本编辑和查找替换是常用的文本处理功能，文本格式化可以调整文本的字体、字号、颜色等，文本分页可以将文本分成若干页进行编辑，文本查找和替换可以方便地查找和替换特定文本。写字板的可视化效果：
写字板的可视化效果包括字体、字号、颜色、背景色、光标颜色、分页等。其中，字体、字号、颜色、背景色等是文本编辑和查找替换时常用的参数，光标颜色和分页则是文本分页时常用的参数。写字板的安全性：
写字板的安全性包括文本加密、数据加密、数据备份、数据恢复等。其中，文本加密可以保护用户输入的敏感信息，数据加密可以保护用户数据的隐私性，数据备份和数据恢复可以方便地备份和恢复用户的数据。写字板的性能：
写字板的性能包括文本编辑速度、查找替换速度、分页速度、数据加载速度等。其中，文本编辑速度和查找替换速度是用户最关心的问题，分页速度和数据加载速度则是数据处理时需要考虑的因素。 B.业务流程分析 1.用户界面设计
模拟写字板系统需要提供用户友好的界面，包括文本输入、文本编辑、文本格式化等功能。因此，用户界面设计是非常重要的。在设计界面时，需要考虑到用户体验和界面美观度，并且要保证界面简洁明了，易于操作。
2.文本输入
在模拟写字板系统中，文本输入是非常重要的一环。用户可以通过键盘或鼠标等方式输入文本，并且可以对输入的文本进行格式化。在设计文本输入功能时，需要考虑到用户输入的方便性和输入内容的保存。
3.文本编辑
在模拟写字板系统中，文本编辑是非常重要的一环。用户可以通过文本编辑功能对文本进行修改、删除、插入等操作。在设计文本编辑功能时，需要考虑到用户操作的方便性和文本的保存。
4.文本格式化
在模拟写字板系统中，文本格式化是非常重要的一环。用户可以通过文本格式化功能对文本进行字体、颜色、大小等格式化。在设计文本格式化功能时，需要考虑到用户操作的方便性和文本的保存。
5.保存和加载
在模拟写字板系统中，保存和加载是非常重要的一环。用户可以将输入的文本保存到文件中，并且可以随时加载已保存的文本。在设计保存和加载功能时，需要考虑到文本的格式化和文本的保存。
以上就是基于Java的模拟写字板系统设计与实现的业务流程分析，希望对您有所帮助。
C.数据库设计 首先，我们需要一个主表，用于存储用户的账户信息。该表包含以下字段：
user_id: 用户的唯一标识符。name: 用户的姓名。password: 用户的密码。email: 用户的电子邮件地址。phone: 用户的手机号码。address: 用户的地址。password: 用户的密码。type: 用户的类型，可以是“普通用户”、“管理员”、“教师”、“学生”等。
接下来，我们需要一个用户表，用于存储用户的写字板信息。该表包含以下字段：user_id: 用户的唯一标识符。name: 用户的姓名。password: 用户的密码。email: 用户的电子邮件地址。phone: 用户的手机号码。address: 用户的地址。address: 用户的写字板地址。description: 用户的写字板描述。status: 用户的写字板状态，可以是“在线”、“离线”、“草稿”等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb9747abcc5465f7ee19284dd1ba4335/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cffcdae32a3f8144304fe5e2c141714/" rel="bookmark">
			基于java的码头船只出行管理系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java的码头船只出行管理系统设计与实现
I. 引言 A.研究背景和动机 研究背景：
随着我国经济的发展和城市化进程的加速，交通运输问题越来越受到人们的关注。在传统的城市交通管理方式下，交通拥堵、交通事故等问题日益突出，亟需寻求新的解决方案。而在交通运输领域，随着科技的不断进步，信息化技术正逐步应用到交通管理中，成为解决城市交通问题的有效途径。
在传统的交通运输方式中，码头船只出行是城市交通管理的重要组成部分。码头船只出行管理系统的设计与实现，需要考虑码头船只出行的流量、车辆通行管理、安全管理、节能环保等多方面的因素。码头船只出行管理系统的应用，不仅可以提高城市交通运输的效率和安全性，还可以减少交通拥堵和交通事故的发生，为城市的可持续发展提供保障。
因此，基于java的码头船只出行管理系统设计与实现的研究，具有重要的研究意义和应用价值。
B.目标和意义 基于Java的码头船只出行管理系统设计与实现的目标是提供一个全面、高效、智能的船只出行管理系统，旨在改进传统船只出行管理方式，提高船只出行管理的效率和服务质量。该系统能够实现船只出行的实时跟踪和管理，包括船只的位置、速度、航行状态等信息，同时还能够实现船只的调度、排队、管理等功能。该系统能够为船只出行提供全方位的支持和服务，为船只出行管理提供智能化的解决方案。
II. 相关技术和工具 A.Java语言 Java是一种高级编程语言，最初由Sun Microsystems（现在是Oracle公司）于1995年发布。它是一种面向对象的语言，支持多种编程范式，如过程式编程、函数式编程和面向对象编程。Java语言广泛应用于Web开发、移动应用开发和企业应用开发等领域。Java语言具有以下特点：
简单易学：Java语言采用面向对象编程范式，代码结构清晰、简洁，易于学习和理解。同时，Java语言具有强制类型检查和自动垃圾回收机制，可以减少程序员的工作量，提高开发效率。跨平台性：Java程序可以在不同的操作系统和硬件平台上运行，包括Windows、Linux、MacOS等。Java虚拟机（JVM）负责将Java字节码转换成本地机器语言，并在本地机器上运行程序。面向对象：Java语言支持面向对象编程，允许程序员将程序划分为对象，并通过对象之间的交互来实现程序的逻辑。Java语言具有封装、继承和多态等面向对象编程的特性，可以提高程序的重用性和可维护性。内存管理：Java语言具有自动垃圾回收机制，程序员无需手动管理内存。Java虚拟机会自动识别和回收不再使用的对象，避免了内存泄漏和野指针等问题。多线程支持：Java语言支持多线程编程，允许程序员同时执行多个任务。Java语言的多线程支持可以提高程序的并发性和响应能力。丰富的类库和API：Java语言具有丰富的类库和API，可以快速实现各种功能。Java语言的标准库中包含大量的类和接口，可以实现各种任务，如文件读写、网络编程、图形界面等。安全性：Java语言对安全性有着很高的要求，可以防止程序中的安全漏洞。Java语言的安全性可以通过强制类型检查、访问控制和安全管理器等方式实现。分布式计算：Java语言支持分布式计算，可以实现分布式应用和分布式数据库。Java语言具有分布式计算框架和分布式数据库接口，可以方便地实现分布式计算和分布式存储。
总之，Java语言是一种简单、高效、可移植的编程语言，广泛应用于Web开发、移动应用开发和企业应用开发等领域。Java语言具有强大的功能和良好的安全性，可以提高程序的开发效率和可靠性。 B.数据库技术 数据库技术是一种重要的计算机技术，用于存储、管理和操作数据。它能够帮助用户快速、高效地访问和管理数据，提高数据处理和管理的效率和准确性。数据库技术主要包括以下几个方面：
数据模型
数据模型是数据库技术的核心部分，它定义了数据的结构、组织和关系。常见的数据库模型包括层次模型、网状模型和关系模型。数据模型能够帮助用户快速、准确地存储和管理数据，提高数据处理和管理的效率和准确性。数据库管理系统
数据库管理系统是数据库技术的实现工具，它提供了对数据库的管理、控制和操作。常见的数据库管理系统包括Oracle、MySQL、SQL Server等。数据库管理系统能够帮助用户快速、高效地访问和管理数据，提高数据处理和管理的效率和准确性。数据库访问语言
数据库访问语言是数据库技术的重要组成部分，它提供了对数据库的查询和操作。常见的数据库访问语言包括SQL、NoSQL等。数据库访问语言能够帮助用户快速、高效地访问和管理数据，提高数据处理和管理的效率和准确性。数据库安全管理
数据库安全管理是数据库技术的重要组成部分，它提供了对数据库的安全保护和管理。常见的数据库安全管理包括访问控制、数据加密、身份验证等。数据库安全管理能够帮助用户保护数据的安全性和保密性，提高数据处理和管理的效率和准确性。数据库备份和恢复
数据库备份和恢复是数据库技术的重要组成部分，它提供了对数据库的备份和恢复管理。常见的数据库备份和恢复方法包括定期备份、数据迁移等。数据库备份和恢复能够帮助用户保护数据的安全性和保密性，提高数据处理和管理的效率和准确性。
总之，数据库技术是现代计算机技术的重要组成部分，它能够帮助用户快速、高效地访问和管理数据，提高数据处理和管理的效率和准确性。 C.GUI技术 以下是GUI技术的介绍。GUI（Graphical User Interface，图形用户界面）技术是一种用于人机交互的技术，通过图形化的界面来展示信息，从而方便用户进行操作。GUI技术最早应用于计算机软件的界面设计中，如今已经广泛应用于各种领域，如游戏、工业设计、教育等。
GUI技术主要包含以下几个方面：
图形化界面设计：通过图形化的界面展示信息，方便用户进行操作。鼠标操作：用户可以通过鼠标来选择、拖动、点击等操作。键盘操作：用户可以通过键盘来输入文字、选择、拖动等操作。触摸屏操作：用户可以通过触摸屏来选择、拖动、点击等操作。手写输入：用户可以通过手写的方式来输入文字，支持多种语言和文字风格。
GUI技术的发展，推动了计算机技术的发展，为人们的生活和工作带来了极大的便利。 III. 系统需求分析与设计 A.系统功能需求 船只在码头上的位置
船只出发和到达的时间
船只行驶的路线
船只的容量
船只的类型
船只的载客数量
船只的载货数量
船只的行驶速度
船只的航行状态
船只的维修状态
船只的停放状态
船只的航线图
船只的航路历史
船只的航行日志
船只的保养记录
船只的船员信息
船只的订单信息
船只的发票信息
船只的售后服务
船只的保养记录
船只的航线历史
船只的载客记录
船只的载货记录
船只的载货容量
船只的
B.业务流程分析 以下是基于Java的码头船只出行管理系统设计与实现的业务流程分析。
该系统旨在实现码头船只出行的管理功能，包括船只进出港的管理、船只预订和退订、船只位置的追踪和船只出行的跟踪。用户可以通过该系统预订船只，并在系统内进行船只的进出港管理。
系统功能包括以下几个方面：
船只进出港管理：用户可以预订船只，并在系统中进行船只进出港管理，包括船只进出港时间、船只进出港位置、船只进出港状态等信息的管理。船只预订和退订：用户可以通过该系统预订船只，并在系统中进行船只预订和退订管理，包括船只预订和退订的时间、船只预订和退订的数量等信息的管理。船只位置的追踪：用户可以通过该系统追踪船只的位置，包括船只的当前位置、船只的前进方向、船只的预计到达时间等信息的管理。船只出行的跟踪：用户可以通过该系统跟踪船只的出行情况，包括船只的出行时间、船只的预计到达时间、船只的出行状态等信息的管理。船只查询和统计：用户可以通过该系统查询船只的信息，包括船只的进出港记录、船只的预订记录、船只的出行记录等信息的管理。船只调度：系统可以自动调度船只，根据船只的进出港时间、船只的预定数量、船只的当前状态等因素进行船只调度。
该系统采用分布式计算架构，将数据存储在多个节点上，每个节点都有自己的数据副本，通过数据同步来保证数据的一致性。系统采用了JPA和Hibernate进行数据持久化，采用Spring Boot进行系统开发，使用MySQL作为数据库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cffcdae32a3f8144304fe5e2c141714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab4ce1d5a9d3fcf2d53b6e8a5adf91da/" rel="bookmark">
			基于java的旅游网站系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java的旅游网站系统设计与实现
I. 引言 A.研究背景和动机 随着旅游行业的快速发展，传统的旅游网站已经无法满足用户的需求。而基于Java的旅游网站系统可以提供更加智能化、个性化的旅游服务，满足用户的各种需求。因此，基于Java的旅游网站系统设计与实现具有重要的研究背景和动机。
首先，基于Java的旅游网站系统可以提供更加安全、可靠、稳定的服务。由于Java是一种高性能、高可靠性的编程语言，可以提供更加安全、可靠、稳定的服务。同时，基于Java的旅游网站系统还可以进行高效的缓存和负载均衡，提高系统的性能和稳定性。
其次，基于Java的旅游网站系统可以提供更加智能化、个性化的服务。传统的旅游网站往往需要人工进行网站的设计和开发，而基于Java的旅游网站系统可以根据用户的偏好和需求进行智能化、个性化的设计和服务。例如，用户可以根据自己的偏好选择旅游线路、旅游方式和旅游景点，系统可以自动生成旅游方案并提供详细的旅游信息。
最后，基于Java的旅游网站系统可以提供更加智能化、高效的旅游服务。基于Java的旅游网站系统可以根据用户的偏好和需求进行智能化、高效的旅游服务。例如，系统可以自动生成旅游方案并提供详细的旅游信息，同时还可以进行智能化的推荐和搜索，提高用户的旅游体验和满意度。
综上所述，基于Java的旅游网站系统设计与实现具有重要的研究背景和动机。通过提供更加安全、可靠、稳定的服务、更加智能化、个性化的服务和更加智能化、高效的旅游服务，可以满足用户的各种需求，提高用户的旅游体验和满意度。
B.目标和意义 基于Java的旅游网站系统设计与实现的目标和意义
提高用户体验：基于Java的旅游网站系统可以为用户提供更便捷、更安全的旅游体验，用户可以更加放心地进行旅游计划安排和预订。提高旅游业务效率：基于Java的旅游网站系统可以简化旅游业务流程，提高旅游业务效率，降低旅游企业成本，提高旅游企业效益。提高数据安全：基于Java的旅游网站系统可以提供更安全的数据存储和传输，保护用户数据安全，防止数据泄露和数据丢失。
基于Java的旅游网站系统设计与实现的目标和意义，主要可以分为以下几个方面：用户体验方面：基于Java的旅游网站系统可以为用户提供更便捷、更安全的旅游体验，用户可以更加放心地进行旅游计划安排和预订。旅游业务效率方面：基于Java的旅游网站系统可以简化旅游业务流程，提高旅游业务效率，降低旅游企业成本，提高旅游企业效益。数据安全方面：基于Java的旅游网站系统可以提供更安全的数据存储和传输，保护用户数据安全，防止数据泄露和数据丢失。 II. 相关技术和工具 A.Java语言 Java是一种高级编程语言，由Sun Microsystems（现在是Oracle公司）于1995年发布。它是一种面向对象的语言，广泛应用于企业级应用、移动应用和游戏开发等领域。Java被设计成可移植、可靠、安全和简单易学的语言，具有优秀的性能和高效的垃圾回收机制。
Java语言是一种跨平台的语言，可以在不同的操作系统和硬件架构上运行。这意味着Java程序可以在不同的操作系统和硬件架构上运行，而不需要重新编译或修改代码。这种可移植性使得Java成为一种非常流行的编程语言，因为它可以减少开发时间和成本，并提高开发效率。
Java语言具有强大的面向对象编程能力，包括封装、继承和多态等概念。这些概念使得Java程序更加结构化、可读性和可维护性。Java还提供了许多内置的类和接口，使得程序员可以轻松地使用这些类和接口来创建自己的类和接口。此外，Java还提供了许多标准库和框架，使得程序员可以快速地开发应用程序。
Java还提供了许多高级特性，例如多线程、网络编程和数据库连接等。这些特性使得Java成为一种非常强大的编程语言，可以用于开发各种类型的应用程序。此外，Java还提供了许多框架和工具，例如Spring和Hibernate等，使得开发人员可以快速地开发应用程序。
总之，Java是一种非常流行的编程语言，具有可移植性、面向对象编程能力、丰富的类库和框架等特点。Java还提供了许多高级特性，使得程序员可以快速地开发各种类型的应用程序。
B.数据库技术 数据库技术是指应用于设计、开发和管理数据库的一系列技术和方法。它旨在为企业、组织和个人提供一种可靠、高效、灵活的数据存储和管理方式。数据库技术主要包括数据模型、数据管理、数据存储、数据检索等方面。
数据模型是指描述和组织数据的结构和方式。数据库系统中的数据模型通常包括关系模型、面向对象模型、图形模型等。关系模型是最常用的数据模型，它以表格形式组织数据，并使用关系运算符进行数据处理。面向对象模型则是以对象为中心，将数据组织成对象，并使用面向对象的编程方式进行数据处理。图形模型则是以图形形式组织数据，并使用图形运算符进行数据处理。
数据管理是指对数据进行存储、管理和维护的过程。数据库系统中的数据管理主要包括数据建模、数据存储、数据维护、数据备份和恢复等方面。数据建模是指对数据进行建模和设计的过程，包括数据结构、数据约束、数据表、数据关系等方面。数据存储是指将数据存储在数据库中的过程，包括数据格式、数据压缩、数据加密等方面。数据维护是指对数据进行管理和维护的过程，包括数据备份、数据恢复、数据监控等方面。数据备份是指将数据库中的数据进行备份，以防止数据丢失。数据恢复是指在数据丢失的情况下，对数据库中的数据进行恢复。数据监控是指对数据库中的数据进行监测和分析，以便及时发现和处理问题。
数据检索是指对数据库中的数据进行检索和处理的过程。数据库系统中的数据检索主要包括SQL语言、数据挖掘、数据分析等方面。SQL语言是用于管理数据库的标准语言，它支持多种数据操作，如数据插入、数据查询、数据更新等。数据挖掘是指对数据库中的数据进行挖掘和分析，以发现数据中的潜在关系和模式。数据分析则是指对数据库中的数据进行分析和处理，以获得有用的信息。
综上所述，数据库技术是一种可靠、高效、灵活的数据存储和管理方式。它包括数据模型、数据管理、数据存储、数据检索等方面，对企业、组织和个人提供了可靠的数据支持。
C.GUI技术 GUI（Graphical User Interface）技术是计算机图形用户界面技术，它通过图形化界面来呈现信息和交互。GUI技术广泛应用于各种类型的应用程序，如文本编辑器、浏览器、游戏、图形设计软件等。在GUI技术中，图形元素和操作命令都可以在界面上轻松访问和操作。GUI技术已经成为计算机用户界面的主流技术之一。
GUI技术分为基于菜单、命令行和图形化界面三种。基于菜单和命令行的GUI技术已经在许多早期版本的操作系统中得到了广泛应用。命令行界面可以提供更为简单的命令交互方式，但是它并不适合于处理大量信息和文件。而基于图形化界面的GUI技术则更为直观和易于使用，可以提供更为丰富的交互方式和更为美观的用户界面。
在现代GUI技术中，图形化界面和用户交互已经越来越成为重中之重。许多GUI应用程序已经采用了图形化界面和动态交互技术，这使得用户可以更加直观地与计算机进行交互。图形化界面还可以提供更为丰富的视觉效果，例如按钮的渐变、动态效果等，这些效果可以为用户带来更加丰富的体验。
总之，GUI技术已经成为计算机用户界面的主流技术之一。通过图形化界面和动态交互技术，用户可以更加直观地与计算机进行交互，享受更为丰富的体验。
III. 系统需求分析与设计 A.系统功能需求 用户登录：用户可以注册账号，使用账号和密码登录网站。首页展示：首页展示所有旅游景点的信息，包括景点介绍、门票价格、图片、用户评价等信息。景点搜索：用户可以通过关键词搜索景点，并查看相关信息。景点详情：用户可以查看某个景点的详细信息，包括地址、联系方式、交通方式、开放时间等。门票购买：用户可以购买景点的门票，支持在线支付和微信支付。用户评价：用户可以对景点进行评价，并查看其他用户的评价。订单管理：用户可以查看自己的订单历史记录，并修改、删除订单。消息提醒：系统可以向用户发送消息提醒，包括订单状态更新、景点门票销售等。社交分享：用户可以分享自己喜欢的景点，并查看其他用户的评论。数据备份：系统可以备份用户数据，防止数据丢失。 B.业务流程分析 用户登录：用户通过用户名和密码进行登录，系统验证用户名和密码是否匹配，若匹配则将用户信息保存在用户会话中，并跳转到主页。首页展示：主页展示包括旅游景点、旅游线路、酒店、机票、导游等信息，用户可以选择自己感兴趣的旅游线路、酒店、机票等进行查看和预订。旅游线路预订：用户选择旅游线路后，系统会跳转到旅游线路详情页，用户可以查看详细的旅游线路信息，包括景点、酒店、交通等信息，用户可以选择自己感兴趣的景点和酒店进行预订，并选择交通方式、导游等信息。酒店预订：用户选择酒店后，系统会跳转到酒店详情页，用户可以查看详细的酒店信息，包括房间类型、价格、位置等信息，用户可以选择自己感兴趣的房间类型和价格进行预订。机票预订：用户选择机票后，系统会跳转到机票详情页，用户可以查看详细的机票信息，包括航班时间、价格、航空公司等信息，用户可以选择自己感兴趣的航班时间和价格进行预订。导游预订：用户选择导游后，系统会跳转到导游详情页，用户可以查看详细的导游信息，包括姓名、性别、等级等信息，用户可以选择自己感兴趣的导游进行预订。订单管理：用户可以选择自己感兴趣的旅游线路、酒店、机票、导游等进行订单管理，包括订单查询、取消、修改等功能。订单支付：用户选择订单后，系统会跳转到支付页面，用户可以选择支付方式，如支付宝、微信支付等，并进行支付。订单确认：用户支付成功后，系统会跳转到订单确认页面，用户可以查看订单信息，包括订单号、订单状态、支付金额等信息。订单完成：订单确认后，系统会将订单信息保存在用户会话中，并跳转到旅游线路详情页，用户可以查看自己的旅游线路信息，并选择自己感兴趣的景点和酒店进行预订。 C.数据库设计 一、需求分析
1.1 网站功能：提供用户查询旅游信息、预订酒店、机票、租车等服务。
1.2 数据库结构：包括用户信息、旅游信息、酒店信息、机票信息、租车信息等。
1.3 数据表设计：
用户信息表：id、name、age、gender、password、email、phone、qq、cover
旅游信息表：id、name、address、info、pic、rating、score
酒店信息表：id、name、address、image、desc、price、area
机票信息表：id、name、code、price、start_date、end_date、start_time、end_time、qos
租车信息表：id、name、desc、price、area、time、quota
二、设计思路
2.1 数据库设计
首先，我们需要设计数据库的架构，包括数据表、字段、关系等。在本系统中，我们需要设计四个表：用户信息表、旅游信息表、酒店信息表、机票信息表、租车信息表。
用户信息表：id、name、age、gender、password、email、phone、qq、cover
旅游信息表：id、name、address、info、pic、rating、score
酒店信息表：id、name、address、image、desc、price、area
机票信息表：id、name、code、price、start_date、end_date、start_time、end_time、qos
租车信息表：id、name、desc、price、area、time、quota
旅游信息表、酒店信息表、机票信息表、租车信息表需要建立关系，以方便数据的查询和检索。
2.2 数据表设计
在数据表中，我们需要设计每个表的字段和数据类型。用户信息表需要包括id、name、age、gender、password、email、phone、qq、cover，旅游信息表需要包括id、name、address、info、pic、rating、score，酒店信息表需要包括id、name、address、image、desc、price、area，机票信息表需要包括id、name、code、price、start_date、end_date、start_time、end_time、qos，租车信息表需要包括id、name、desc、price、area、time、quota。
2.3 数据表关系设计
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab4ce1d5a9d3fcf2d53b6e8a5adf91da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6fcb89f71e63e7db1a7140065d1efeb/" rel="bookmark">
			springboot学生成绩管理系统源码和论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着信息技术和网络技术的飞速发展，人类已进入全新信息化时代，传统管理技术已无法高效，便捷地管理信息。为了迎合时代需求，优化管理效率，各种各样的管理系统应运而生，各行各业相继进入信息管理时代，学生成绩管理系统就是信息时代变革中的产物之一。
任何系统都要遵循系统设计的基本流程，本系统也不例外，同样需要经过市场调研，需求分析，概要设计，详细设计，编码，测试这些步骤，基于java语言设计并实现了学生成绩管理系统。该系统基于B/S即所谓浏览器/服务器模式，应用java技术，选择MySQL作为后台数据库。系统主要包括首页、个人中心、学生管理、教师管理、班级管理、综合成绩管理、专业管理、课程信息管理等功能模块。
本文首先介绍了学生成绩管理的技术发展背景与发展现状，然后遵循软件常规开发流程，首先针对系统选取适用的语言和开发平台，根据需求分析制定模块并设计数据库结构，再根据系统总体功能模块的设计绘制系统的功能模块图，流程图以及E-R图。然后，设计框架并根据设计的框架编写代码以实现系统的各个功能模块。最后，对初步完成的系统进行测试，主要是功能测试、单元测试和性能测试。测试结果表明，该系统能够实现所需的功能，运行状况尚可并无明显缺点。
关键词：学生成绩；java；MySQL数据库
springboot学生成绩管理系统源码和论文309
Abstract
With the rapid development of information technology and network technology, human beings have entered a new information age, traditional management technology has been unable to efficiently and conveniently manage information. In order to meet the needs of The Times, optimize management efficiency, a variety of management systems emerged, all walks of life have entered the era of information management, student performance management system is one of the products of the information era change.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6fcb89f71e63e7db1a7140065d1efeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/750a32a8838042dde09acb32d6754410/" rel="bookmark">
			npm报错error:03000086:digital envelope routines::initialization error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.可能是因为node版本过高，与现在的项目不符合
这是降低node版本的命令，然后重新运行
npm install npm@8.1.2 -g 2.改下这个package.json
"dev": "SET NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service serve", 也是能成功运行的，这个错误是token过期了，不用管
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db8a03ebcdd204a8bae171bb1fd54a0/" rel="bookmark">
			SegDiff：Image Segmentation with Diffusion Probabilistic Models
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SegDiff:基于扩散概率模型的图像分割
摘要：
扩散概率方法用于最先进的图像生成。在这项工作中，我们提出了一种方法来扩展这样的模型来执行图像分割。该方法端到端学习，不依赖于预先训练的主干。输入图像中的信息和当前分割图估计中的信息通过对两个编码器的输出求和来合并。
然后，使用扩散模型，使用额外的编码层和解码器来迭代地细化分割图。由于扩散模型是概率性的，因此可以多次应用，并将结果合并到最终的分割图中。新方法在城市景观验证集、Vaihingen建筑分割基准和MoNuSeg数据集上产生最先进的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9541bda1a97a73d682db093728867029/" rel="bookmark">
			TypeScript基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ts学习 目录概述需求： 设计思路实现思路分析1.TypeScript 基础类型2.TypeScript 变量声明3.TypeScript 接口4.TypeScript 类5.TypeScript 函数5.TypeScript 泛型5.TypeScript 枚举TypeScript 类型推论TypeScript 类型兼容性TypeScript 高级类型TypeScript 迭代器和生成器TypeScript 模块TypeScript 命名空间TypeScript 模块解析TypeScript 声明合并TypeScript 装饰器TypeScript 三斜线指令 参考资料和推荐阅读 Survive by day and develop by night.
talk for import biz , show your perfect code,full busy，skip hardness,make a better result,wait for change,challenge Survive.
happy for hardess to solve denpendies.
目录 概述 需求： 设计思路 实现思路分析 1.TypeScript 基础类型 TypeScript 支持以下基础类型：
boolean：布尔类型，表示真或假。number：数字类型，表示整数或浮点数。string：字符串类型，表示文本。Array：数组类型，表示由相同类型的元素组成的有序集合。Tuple：元组类型，表示由固定数量和类型的元素组成的数组。enum：枚举类型，表示一组具有命名值的常量。any：任意类型，表示可以赋给任意类型的值。void：空类型，表示没有任何值。null 和 undefined：表示不存在的值。never：表示永不返回的函数类型或抛出异常的函数类型。 此外，TypeScript 还支持联合类型、交叉类型、类型别名等高级类型。
2.TypeScript 变量声明 TypeScript 变量声明可以通过 let、const 和 var 关键字来实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9541bda1a97a73d682db093728867029/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa7b4875f21421aa8e4968fc4c9e9ef0/" rel="bookmark">
			goland报错：The selected directory is not a valid home for Go SDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因： IDEA / goland无法识别到GO语言SDK版本
解决办法： 打开GO的安装目录下的src\runtime\internal\sys\zversion.go文件，添加一行（我的go版本是1.18.10）
const TheVersion = `go1.18.10` 重启goland再选择试试
最后（非必须） 如果还不行，加下环境变量再重启goland试试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9692f0d2a548d50d1af831c5fafe8d89/" rel="bookmark">
			C语言-函数指针，指针与函数传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.函数指针
(1)函数指针的实质（还是指针变量）
-&gt;函数指针的实质还是指针，还是指针变量。本身占4字节（在32位系统中，所有的指针都是4字节）
-&gt;函数的实质是一段代码，这一段代码在内存中是连续分布的，所以对于函数来说很关键的就是函数中的第一句代码的地址，这个地址就是所谓的函数地址，函数指针就是指向这个地址。
(2)函数指针的书写和分析方法
-&gt;C语言本身是强类型语言（每一个变量都有自己的变量类型），编译器可以帮我们做严格的类型检查。
-&gt;假设我们有个函数是：void func(void);对应的函数指针：void (*p)(void); 类型是：void (*)(void);
-&gt;写一个复杂的函数指针的实例：譬如函数是strcpy函数（char *strcpy(char *dest, const char *src);），对应的函数指针是：char *(*pFunc)(char *dest, const char *src);
(3)用函数指针调用执行函数
#include &lt;stdio.h&gt; void func1(void) { printf("I am func1.\n"); } int main(void) { void (*pFunc)(void); //pFunc = func1;	pFunc = &amp;func1;	// &amp;func1和func1做右值时是一模一样的，没任何区别 pFunc();	// 用函数指针来解引用以调用该函数 return 0; } #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char a[5] = {0}; char* (*pFunc)(char *, const char *); //定义了一个函数指针pFunc，类型是char* (*) (char*,const char*) pFunc = strcpy; //把strcpy函数名赋值给函数指针 pFunc(a, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9692f0d2a548d50d1af831c5fafe8d89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e384cf20fd7f6028e5eaa28666ef833/" rel="bookmark">
			springboot学生综合测评系统源码和论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着信息化时代的到来，管理系统都趋向于智能化、系统化，学生综合测评系统也不例外，但目前国内仍都使用人工管理，学校规模越来越大，同时信息量也越来越庞大，人工管理显然已无法应对时代的变化，而学生综合测评系统能很好地解决这一问题，轻松应对学生综合测评平时的工作，既能提高人力物力财力，又能加快工作的效率，取代人工管理是必然趋势。
本学生综合测评系统以springboot作为框架，b/s模式以及MySql作为后台运行的数据库，同时使用Tomcat用为系统的服务器。本系统主要包括首页，个人中心，学生管理，试题信息管理，测评试题管理，管理员管理，综合测评管理，系统管理，综合考试管理等功能，通过这些功能的实现基本能够满足日常学生综合测评管理的操作。
本文着重阐述了学生综合测评系统的分析、设计与实现，首先介绍开发系统和环境配置、数据库的设计，接着说明功能模块的详细实现，最后进行了总结。
关键词：学生综合测评系统; springboot;MySql数据库;Tomcat;
springboot学生综合测评系统源码和论文308
Abstract
With the coming of information era, all tend to be intelligent, systematic management system, students' comprehensive evaluation system is no exception, but at present domestic still use manual management, school size bigger and bigger, at the same time, the amount of information is becoming more and more big, the artificial management has clearly unable to cope with the changes of The Times, and the students' comprehensive evaluation system can well solve the problem, It can not only improve human and material resources and financial resources, but also speed up the efficiency of work.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e384cf20fd7f6028e5eaa28666ef833/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d92549415852f7e4f0fdc953760e2f9/" rel="bookmark">
			【python】os模块使用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		os 模块是 Python 的标准库中提供的一个功能强大的模块，用于与操作系统进行交互。以下是 os 模块的一些常用方法：
获取当前工作目录:
import os print(os.getcwd()) 改变当前工作目录:
os.chdir('/path/to/new/directory') 列出目录下的所有文件和子目录:
print(os.listdir('.')) 创建目录:
os.mkdir('new_directory') 创建多层目录:
os.makedirs('path/to/new/directory') 删除目录:
os.rmdir('directory_to_delete') 删除文件:
os.remove('file_to_delete.txt') 重命名文件或目录:
os.rename('old_name.txt', 'new_name.txt') 获取文件属性:
print(os.stat('file_name.txt')) 检查文件或目录是否存在:
print(os.path.exists('file_or_directory_path')) 检查是否为目录: print(os.path.isdir('directory_path')) 检查是否为文件: print(os.path.isfile('file_path')) 获取文件大小: print(os.path.getsize('file_name.txt')) 获取文件的绝对路径: print(os.path.abspath('file_name.txt')) 连接路径: print(os.path.join('/path', 'to', 'file.txt')) 这只是 os 模块中一些基本的功能。根据需要，你还可以使用其他功能，如文件和目录的权限修改、环境变量的获取和设置等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97b6cc883f555b0fabace0c3e3b792ff/" rel="bookmark">
			JVM主要的几种垃圾回收算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Java 为什么要实现自动内存管理 ？ 简化开发过程：通过内存自动管理可以避免手动分配和释放内存的麻烦，减少了内存泄漏和内存错误的风险，让研发能更专注于业务逻辑，不必纠结于内存管理的细节。
提高开发效率：垃圾回收器（Garbage Collector）能够自动追踪不再使用的对象，并释放它们占用的内存。这消除了手动跟踪和释放对象的需要，减少了开发人员的工作量，提高了开发效率。
可移植性好：研发人员不需要关心不同平台的内存管理差异，这些细节都交由虚拟机和垃圾回收器进行处理，Java的内存管理机制使得Java程序在不同的平台上运行更加容易。
2、java 自动内存管理并不是一劳永逸 Java的自动内存管理机制（垃圾回收器和垃圾回收算法的设计），确实可以大大简化开发人员对内存管理的工作，同样也带来了一系列的问题 内存占用和性能问题：不合适的内存使用、配置，可能导致内存占用过高或性能下降。如，长生命周期对象、内存泄漏、过频繁的垃圾回收等，都会影响应用程序的性能和稳定性。
垃圾回收停顿：虽然垃圾回收器一直都在优化减少停顿时间，但并不能完全消除。实时性要求高的系统对停顿时间很敏感
所以我们需要搞懂JVM内存管理机制，才能针对不同的场景合理使用
3、垃圾回收的机制 a、垃圾回收发生在哪里 ？ JVM 内存模型中程序计数器、栈、本地方法栈这 3 个区域是线程私有的，与线程同生共死，不涉及回收，所以垃圾回收的就在剩下的堆和方法区中了，堆中主要回收是对象，方法区的回收则主要是废弃常量和无用的类
b、什么情况下对象可以被回收？ JVM认为一个对象不再被引用，就代表该可以被回收了，目前有两种算法可以判断该对象是否可以被回收。
引用计数算法：通过对象的引用计数器判断对象是否被引用。即每当对象被引用时，该对象的引用计数器就会 + 1; 当引用失效时，计数器再 -1。对象引用计数器值为 0 时，表示该对象不再被引用，可以被回收。引用计数算法的实现简单，判断效率也很高，但它存在对象之间循环引用的问题。
可达性分析算法: 在垃圾回收时，以 GC Roots 对象为根对象开始遍历对象图，确定哪些对象是可达的（即不会被回收），而哪些对象是不可达的（即可被回收）。目前 HotSpot 虚拟机采用的就是这种算法。
c、哪些是 GC Roots 对象 ？ 虚拟机栈（栈帧中的本地变量表）中引用的对象：当前线程中方法调用链上的所有对象。
方法区中的类静态属性引用的对象：被类声明为静态变量的对象。
方法区中常量引用的对象：被常量池中的常量引用的对象。
本地方法栈中引用的对象：在Java代码中调用本地方法后，本地方法中引用的对象
GC Roots 本身是不可被回收的，它们的存在保证了从根节点出发的对象的可达性。垃圾回收器通过追踪GC Roots对象的引用链，可以确定哪些对象是可达的，而哪些对象是不可达的，从而进行垃圾回收操作。
4、垃圾回收的三种方式 a、标记-清除算法（Mark and Sweep） 把垃圾对象所占据的内存标记为空闲内存，并记录在一个空闲列表(free list)中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。该回收方式的原理非常简单，但会带来俩个缺点
内存碎片化：由于 Java 虚 拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情
内存分配效率低：如果是一块连续的内存空间，那么我们可以通过指针加法 (pointer bumping)分配。但对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够满足新建对象的大小的空闲内存
b、标记-整理算法（Mark and Compact） 在标记阶段（Mark）也会标记所有可达对象。然后，在整理阶段（Compact），将存活的对象压缩（Compact）到堆的一端，以释放不连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。
c、复制(copy) 把内存区域分为两等分，分别用两个指针 from 和 to 来维 护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对 象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97b6cc883f555b0fabace0c3e3b792ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4517630702536a23325de7d78a414d6/" rel="bookmark">
			基于springboot在线考试系统源码和论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络的广泛应用给生活带来了十分的便利。所以把在线考试管理与现在网络相结合，利用java技术建设在线考试系统，实现在线考试的信息化。则对于进一步提高在线考试管理发展，丰富在线考试管理经验能起到不少的促进作用。
在线考试系统能够通过互联网得到广泛的、全面的宣传，让尽可能多的用户了解和熟知在线考试系统的便捷高效，不仅为群众提供了服务，而且也推广了自己，让更多的群众了解自己。对于在线考试而言，若拥有自己的系统，通过系统得到更好的管理，同时提升了形象。
本系统设计的现状和趋势，从需求、结构、数据库等方面的设计到系统的实现，分别为管理员和用户的实现。论文的内容从系统的设计、描述、实现、分析、测试方面来表明开发的过程。本系统根据现实情况来选择一种可行的开发方案，借助java编程语言和MySQL数据库等实现系统的全部功能，接下来对系统进行测试，测试系统是否有漏洞和测试用户权限来完善系统，最终系统完成达到相关标准。
关键字：在线考试系统 java MySQL数据库
基于springboot在线考试系统源码和论文306
Abstract
The wide application of network has brought great convenience to life. So the online examination management and the present network, using Java technology to build online examination system, to achieve online examination information. It can further improve the development of online examination management and enrich the experience of online examination management.
Online examination system can be widely and comprehensively publicized through the Internet, so that as many users as possible understand and be familiar with the convenience and efficiency of the online examination system, not only to provide services for the masses, but also to promote themselves, so that more people understand themselves.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4517630702536a23325de7d78a414d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77103ee980c4a94e66545fa8b3900366/" rel="bookmark">
			vue 学习路线图（待整理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		入门级：
1.Vue.js 教程 | 菜鸟教程
2.VUE3 教程_w3cschool
2.进阶
002_尚硅谷Vue技术_Vue简介_哔哩哔哩_bilibili
vue初级视频教程_前端小孟的博客-CSDN博客_vue视频教程
3.高级
Vue源码系列-Vue中文社区
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cd49a83e544202c8dd4e29dc4c62c61/" rel="bookmark">
			洛谷 P8682 [蓝桥杯 2019 省 B] 等差数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数学老师给小明出了一道等差数列求和的题目。但是粗心的小明忘记了一部分的数列，只记得其中 N N N 个整数。
现在给出这 N N N 个整数 A 1 , A 2 , ⋯ , A N A_1,A_2,\cdots,A_N A1​,A2​,⋯,AN​。（注意 A 1 ～ A N A_1 ～ A_N A1​～AN​ 并不一定是按等差数列中的顺序给出 )，小明想知道包含这 N N N 个整数的最短的等差数列有几项？
分析 注意到因为要求最少项数所以数列两端不会再添加数，由于不按顺序给出序列，所以可以先将序列排序，如果最后等差数列的公差是 d d d，那么初始序列相邻两项的差必然是 d d d 的倍数，而 d d d 越大则序列越短，所以 d d d 取相邻两项的差的最大公约数。
注意 d d d 可以为 0 0 0，除 0 0 0 会 RE 所以得特判这种情况
代码 #include &lt;bits/stdc++.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cd49a83e544202c8dd4e29dc4c62c61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a392b4f7ec1afffb91afff2bdfe931b0/" rel="bookmark">
			【深入理解计算机系统 第三版 导读】第三章 程序的机器级表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三章 程序的机器级表示 文章目录 第三章 程序的机器级表示1. 程序编码1.1. 编码过程1.2. 不同级别优化1.3. 寄存器的基本知识1.4. 简单的汇编代码1.5. 反汇编 2. 数据格式3. 信息访问3.1. 操作数指示符3.3. 代码中的操作数3.4. 数据传输指令3.5. 数据传输扩展示例3.6. 前面的补充一下3.6.1. 对于movq和movabsq3.6.2. 指令mov后缀3.6.3. movl 3.7. 数据传输扩展3.8. 数据传输在C与汇编间的转换 4. 栈与数据传送指令4.1. 压入弹出栈数据 5. 算术与逻辑操作5.1. 加载有效地址及示例5.2. 一元操作和二元操作5.3. 二元操作示例5.4. 移位操作5.5. 移位操作示例5.6. 算数运算函数转换示例5.7. 特殊算术操作 6. 条件码6.1. 条件码6.2. 条件码例子6.3. 访问条件码6.4. 访问条件码例子 7. 控制7.1. 无条件跳转7.2. 条件跳转7.3. 条件控制例题7.4. 跳转指令的编码7.5. 条件传送实现分支7.6. 条件传送例题7.7. while循环7.8. for循环7.9. switch语句 8. 过程8.1. 通过栈来传递参数8.2. 运行时栈8.3. 引用的案例8.4. 调用者保存和被调用者保存8.5. 递归调用 9. 数组9.1. 数组示例9.2. 多维数组9.3. 定长数组9.4. 变长数组 10. 异质的数据结构10.1. 结构体及其访问10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a392b4f7ec1afffb91afff2bdfe931b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49b5114363f9a2998a4602cfcf59a788/" rel="bookmark">
			语言栏中的半角和全角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语言栏中的半角和全角 1. 语言栏2. Halfwidth and fullwidth forms3. Monospaced fontReferences 1. 语言栏 任务栏设置 时间和语言 输入 高级键盘设置 文本服务和输入语言 半角和全角切换快捷键：Shift+Space
2. Halfwidth and fullwidth forms 半角和全角，别名半形和全形。
In CJK (Chinese, Japanese, and Korean) computing, graphic characters are traditionally classed into fullwidth and halfwidth characters. Unlike monospaced fonts, a halfwidth character occupies half the width of a fullwidth character, hence the name.
半角和全角是文字的两种显示形式，全角指文字字身长宽比为一比一的正方形，而半角为宽度为全角一半的文字。
在传统的字体排印学中，文字字身长宽比为一比一的正方形金属铅字原本称作全身，而宽度只有一半的称为半身。对于小于一个全身的各种铅空称为分空，通常称为二分空、三分空、四分空、六分空等等。
半角和全角源于日文，其中角是方块的意思，全角/半角在日文里是正方形/半个正方形大小文字，与西文字体排印学中 Em 和 En 单位含义相同。
中文中的角有角度、角落等含义，却没有方块的意思，中文在字体排印时不说全角/半角而说全身/半身。中文里说半角/全角是计算机文字编码技术引入时直接借用了日文的做法。
Windows 命令提示符中显示的全角和半角字符：
3. Monospaced font 等宽字体 (monospaced font) 是指字符宽度相同的字体。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49b5114363f9a2998a4602cfcf59a788/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2e2becb6ae58faf8ae904df5730b73a/" rel="bookmark">
			SpringCloud系列篇：核心组件之网关组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🥳🥳Welcome Huihui's Code World ! !🥳🥳 接下来看看由辉辉所写的关于SpringCloud的相关操作吧
目录
🥳🥳Welcome Huihui's Code World ! !🥳🥳
一.网关组件是什么 二. 网关组件的详解
生活例子
例子剖析
三.代码演示【网关的三种使用方式】 0.配置
1.根据服务名访问
2.根据路径访问
3.动态路由
路由
断言
过滤器
配置类
路由处理类
注意点：
一.网关组件是什么 网关（Gateway）组件是指用于构建具有统一入口的微服务架构中的一个组件，它可以实现动态路由、负载均衡、熔断、安全控制等功能。在微服务架构中，每个服务都有自己的入口，客户端需要知道每个服务的地址和端口号才能访问它们。而网关组件可以为所有服务提供一个统一的入口，客户端只需要知道网关的地址和端口号，就可以通过网关访问所有的服务。
常见的网关组件包括Zuul、Spring Cloud Gateway、Kong、Nginx等。这些网关组件都具有一定的功能和特点，可以根据具体需求选择合适的网关组件。
Spring Cloud Gateway 三大核心概念
1️⃣路由（route）：路由是网关最基础的部分，路由信息由一个ID，一个目的URL、一组断言工厂和一 组Filter组成。如果断言为真，则说明请求URL和配置的路由匹配。
2️⃣断言（Predicate）：Java8中的断言函数，Spring Cloud Gateway中的断言函数输入类型是 Spring5.0框架中的ServerWebExchange。Spring Cloud Gateway中的断言函数允许开发者去定义匹配 来自http Request中的任何信息，比如请求头和参数等。
3️⃣过滤器（Filter）：一个标准的Spring WebFilter，Spring Cloud Gateway中的Filter分为两种类型： Gateway Filter和Global Filter。过滤器Filter可以对请求和响应进行处理
二. 网关组件的详解 这里举一个生活中的例子，来帮助大家理解一下网关这个组件
生活例子 假设你住在一个小区里，每个家庭都有自己的门禁系统和电话系统。
现在，你想要给小区外的朋友打电话
但是你不知道他们具体的电话号码，只知道他们的姓名。这时候，你需要通过小区的门禁系统（网关）来连接到外部电话网络，然后通过输入朋友的姓名（数据）来查找他们的电话号码（其他网络）并打通电话。
例子剖析 在这个例子中，小区的门禁系统就是一个网关，它连接了小区内部的电话系统和外部的电话网络，帮助你实现了与外部电话网络的通信。类似地，在计算机网络中，网关起到了连接不同网络或协议的桥梁作用，使得数据能够在它们之间进行传输和转换。
三.代码演示【网关的三种使用方式】 0.配置 在进行下面三种方式的讲解之前，咱先得将文件都给配置好
&lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2e2becb6ae58faf8ae904df5730b73a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd93304ab9deae90ce957eacd3ab713/" rel="bookmark">
			MySQL 语句｜使用MySQL中的GROUP BY获取每个组的最大和最小值记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 MySQL 中，可以使用 GROUP BY 语句结合聚合函数和子查询来获取每个组中的最大和最小值对应的记录
举个通用的例子 假设有一个名为 your_table 的表，其中包含两列：group_column 和 value_column
要分别获取每个组中的最大和最小值对应的记录，可使用两条独立的 SQL 查询
获取最大值的记录：
SELECT t1.* FROM your_table t1 JOIN ( SELECT group_column, MAX(value_column) AS max_value FROM your_table GROUP BY group_column ) t2 ON t1.group_column = t2.group_column AND t1.value_column = t2.max_value; 获取最小值的记录：
SELECT t1.* FROM your_table t1 JOIN ( SELECT group_column, MIN(value_column) AS min_value FROM your_table GROUP BY group_column ) t2 ON t1.group_column = t2.group_column AND t1.value_column = t2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bd93304ab9deae90ce957eacd3ab713/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5458e2b1954c8bd01b77fd1f9966676e/" rel="bookmark">
			【Kubernetes】如何使用 kubectl 操作 cluster、node、namespace、pod
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何使用 kubectl 操作 cluster、node、namespace、pod 在列出、描述、修改或删除其他命名空间中的对象时，需要给 kubectl 命令传递 --namespace（或 -n）选项。如果不指定命名空间，kubectl 将在当前上下文中配置的默认命名空间中执行操作。而当前上下文的命名空间和当前上下文本身都可以通过 kubectl config 命令进行更改。
要想快速切换到不同的命名空间，可以通过以下命令设置别名：
alias kcd='kubectl config set-context $(kubectl config current-context) --namespace 然后，可以使用 kcd some-namespace 在命名空间之间进行切换。
kubectl 中的双横杠 -- 代表着 kubectl 命令项的结束，在两个横杠之后的内容是指在 pod 内部里需要执行的命令，如果不使用双横杠则可能会导致结果异常和歧义错误。如果需要执行的命令并没有以横杠开始的参数，则横杠不是必需的。
✅ 展示 k8s 集群信息
kubectl cluster-info ✅ 列出所有集群节点
kubectl get nodes ✅ 查看节点详细信息
kubectl describe node {nodeName} ✅ 使用 alias k = kubectl 创建命令行别名，并添加到 ~/.bashrc 中永久保存。
✅ 集群中部署应用
kubectl run {applicationName} --image=fanqisoft/coreqi --port=8080 --generator=run/v1 replicationcontroller "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5458e2b1954c8bd01b77fd1f9966676e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e6110e0461364d6164967b12c2c2429/" rel="bookmark">
			视频剪辑技巧：快速批量修改视频分辨率，高效剪辑修改尺寸的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着视频内容的普及，经常要处理大量的视频文件。在这个过程中，视频分辨率的修改是一个常见的需求。无论是适应不同的播放平台，还是满足特定的视觉要求，调整视频分辨率是必不可少的步骤。但逐个手动调整不仅效率低下，而且容易出错。现在一起来看看云炫AI智剪如何批量修改视频分辨率的技巧。
原视频尺寸大多为1920*1080，也有较高的分辨率，如下图。
视频批量修改分辨率的步骤：
操作1、在云炫AI智剪界面中点击“任务剪辑”功能，进入到剪辑界面中。
操作2、把要修改尺寸的视频导入到软件中。可以通过红框中的按钮批量导入。也可以手动选中文件，再拖动到列表中。
操作3、按要求选择任务名称，下面选择“修改尺寸”任务。
操作4、接下来修改任务细节参数。选择视频尺寸并点击“添加改尺寸任务”。
操作5、已添加的任务可以在任务列表中查看。接着点击“浏览”设置视频的保存路径。
操作6、都设置完成后点击“开始剪辑”，接着可看到状态栏中显示“修改尺寸中”。
操作7、在界面上点击“打开文件夹”进入路径中查看已修改尺寸的视频。
操作8、打开视频看到视频分辨率已修改成1280*720。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a461abc86c530bbf37d20172742ad08a/" rel="bookmark">
			keil5调试问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个问题，按照csdn的方法去解决依然没有解决STLINK调试的时候监测不了局部参数？？？
求助？？
现在得知只能监控全局变量，因此若需要对局部变量的值监控，改成全局变量即可，确定无误后再改回去即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93bfef88fb7a31cd8e4f6f03e356c485/" rel="bookmark">
			计算几何学（工程版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天写了计算几何学的东西，今天主要是工程化一下，工程借鉴B站up主
【自动驾驶】自动驾驶planning方向中常用的计算几何学知识 01_哔哩哔哩_bilibili
#pragma once #include &lt;cmath&gt; #include &lt;iostream&gt; class Point{ public: Point() = default; Point(double x_in, double y_in) : x(x_in), y(y_in) {} Point operator + (const Point&amp; p) const{ return {x + p.x, y + p.y}; } Point operator - (const Point&amp; p) const{ return {x - p.x, y - p.y}; } Point operator*(double k)const { return {x * k, y * k}; } friend std::ostream &amp;operator &lt;&lt; (std::ostream &amp;out, const Point &amp;p){ out &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93bfef88fb7a31cd8e4f6f03e356c485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42f006099fd71c6dacf035a15ac60a8e/" rel="bookmark">
			【UBUNTU】随手记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 更新软件到最新版本1.1 CMAKE [U20]1.2 GIT1.3 WIRESHARK1.4 LLVM 2. 设置代理2.1 APT2.2 GIT2.3 WGET2.4 PIP2.5 CURL 1. 更新软件到最新版本 1.1 CMAKE [U20] 参考：https://apt.kitware.com/
# 1. 更新基础库 sudo apt-get update # 2. 安装可能需要的工具 sudo apt-get install ca-certificates gpg wget # 3. 获取签名 wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2&gt;/dev/null | gpg --dearmor - | sudo tee /usr/share/keyrings/kitware-archive-keyring.gpg &gt;/dev/null # 4. 添加正式版仓库与更新 echo 'deb [signed-by=/usr/share/keyrings/kitware-archive-keyring.gpg] https://apt.kitware.com/ubuntu/ focal main' | sudo tee /etc/apt/sources.list.d/kitware.list &gt;/dev/null sudo apt-get update sudo apt-get upgrade cmake # 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42f006099fd71c6dacf035a15ac60a8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc18000fb999af61fe04fffa3b3fc56d/" rel="bookmark">
			【Android开发】不同Activity之间的数据回传实例（一）摘桃子游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、功能介绍 该项目实现的功能主要有：
在首页显示一个按钮点击该按钮跳转到桃园页面在桃园页面，点击桃子会弹窗显示摘到几个桃子，同时被点击桃子消失，总桃子数+1点击退出桃园会返回首页，首页桃子数会根据点击的桃子数动态增加 二、代码实现 1. 资源准备 将项目所需要的图片bg.png、monkey.png、btn_peach.png、peach_pic.png 导入程序的drawablehdpi文件夹中（默认情况下程序中没有drawable-hdpi 文件夹，需手动在res 文件夹中创建一个）。
2. 布局文件设计 2.1 主Activity 在layout文件夹中编辑activity_main.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="50dp" android:background="#008577" android:gravity="center" android:text="首页" android:textColor="@android:color/white" android:textSize="20sp" /&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="match_parent" android:background="@drawable/bg" android:gravity="center_vertical"&gt; &lt;ImageView android:id="@+id/iv_monkey" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/monkey" /&gt; &lt;Button android:id="@+id/btn_peach" android:layout_width="80dp" android:layout_height="40dp" android:layout_marginLeft="30dp" android:layout_marginTop="250dp" android:layout_toRightOf="@id/iv_monkey" android:background="@drawable/btn_peach" android:gravity="center" android:text="去桃园" android:textColor="@android:color/black" android:textSize="18sp" /&gt; &lt;ImageView android:id="@+id/iv_peach" android:layout_width="45dp" android:layout_height="35dp" android:layout_below="@+id/btn_peach" android:layout_centerHorizontal="true" android:layout_marginTop="20dp" android:src="@drawable/peach_pic" /&gt; &lt;TextView android:id="@+id/tv_count" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc18000fb999af61fe04fffa3b3fc56d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb878890079071f2476ed71cef74dd19/" rel="bookmark">
			4.4 媒资管理模块 - 分布式任务处理介绍、视频处理技术方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		媒资管理模块 - 视频处理 文章目录 媒资管理模块 - 视频处理一、视频转码1.1 视频转码介绍1.2 FFmpeg 基本使用1.2.1 下载安装配置1.2.2 转码测试 1.3 工具类1.3.1 VideoUtil1.3.2 Mp4VideoUtil1.3.3 测试工具类 二、分布式任务处理2.1 分布式任务调度2.2 XXL-JOB 配置执行器 中间件2.3 搭建XXL-JOB2.3.1 调度中心2.3.2 执行器2.3.3 执行任务 2.4 XXL-JOB 高级配置参数2.5 分片广播2.5.1 分片广播事例 三、视频处理3.1 技术方案3.1.1 作业分片方案3.1.2 保证任务不重复执行3.1.3 视频处理方案 一、视频转码 1.1 视频转码介绍 视频转码是指的对视频文件的编码格式进行转换
视频上传成功需要对视频的格式进行转码处理，比如：avi转成mp4
一般做文件存储的服务都需要对文件进行处理，例如对视频进行转码处理，可能由于文件量较大需要使用多线程等技术进行高效处理
文件格式：是指.mp4、.avi、.rmvb等 这些不同扩展名的视频文件的文件格式
视频文件的内容主要包括视频和音频，其文件格式是按照一 定的编码格式去编码，并且按照该文件所规定的封装格式将视频、音频、字幕等信息封装在一起，播放器会根据它们的封装格式去提取出编码，然后由播放器解码，最终播放音视频
音视频编码格式：通过音视频的压缩技术，将视频格式转换成另一种视频格式，通过视频编码实现流媒体的传输
目前最常用的编码标准是视频H.264，音频AAC
比如：
一个.avi的视频文件原来的编码是a，通过编码后编码格式变为b，
音频原来为c，通过编码后变为d
1.2 FFmpeg 基本使用 1.2.1 下载安装配置 我们Java程序员只需要调用流媒体程序员写的工具类即可完成对视频的操作，这个工具可能是c或c++写的
流媒体程序员：专门做视频处理类的东西
FFmpeg开源工具被许多开源项目采用，QQ影音、暴风影音、VLC等
下载链接：https://www.ffmpeg.org/download.html#build-windows
最终下载之后三个exe文件
查看是否安装成功
ffmpeg -v 也可以把ffmpeg.exe文件配置在path环境变量中
现在我们就可以在任意一个位置执行命令了
1.2.2 转码测试 将avi文件转换成mp4文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb878890079071f2476ed71cef74dd19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff4a6bac92bf35afc6ae44e0e39b75d4/" rel="bookmark">
			NE555学习笔记-2024
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.实物图片 2.NE555引脚图 3.内部时序图 4.示列1，红外接收电路 红外接收电路的工作原理：在上述电路中，TSOP1738构成了该电路的主要组成部分，旨在检测来自任何来源的红外信号。这用于检测38 KHz范围的信号，因此命名为“TSOP1738”，并且该TSOP系列的每个系列的最后两个数字都以其接收频率范围命名。引脚配置如下。
Vs分别连接到5v电源，GND接地。输出取自OUT引脚。TSOP在未检测到任何红外信号的情况下提供高信号作为输出，每当红外信号入射到TSOP1738上时，TSOP就会提供低输出。上述接收器电路中使用该逻辑来检测红外信号。
5.列子2，接近开关控制电机运转 目标：使用接近开关控制电机的转动，
第一步，使用模拟电路，模拟NE555的效果，在网页版的链接中没有实际的链接我们采用LED进行代替，当关闭开关时和打开时效果如下图所示
开关关闭时，LED灯里亮如下
开关打开时，LED灯灭：
第2，实物，
TBD
6.参考资料 推荐使用电路模拟网页：无广告，无注册
http://scratch.trtos.com/circuitjs.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/10/">«</a>
	<span class="pagination__item pagination__item--current">11/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/12/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>