<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31df5ee9babb190bc5f55315ae312776/" rel="bookmark">
			彻底澄清子网掩码、反掩码、通配符掩码以及ospf network命令误区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.子网掩码（IP subnet mask）
用途：标识一个IP地址的网络位，主机位
网络设备判断目的IP跟自己是否同一网段的依据。
特点：1和0绝对不可能间隔，1总在0的前面。
网络通信角度，子网掩码只具有本地意义。跟对端没有匹配的硬性要求。
误区：一条链路两端的子网掩码必须一致（是习惯不是必须）
例外：ospf 多路访问网络中，掩码不一致会影响ospf邻居关系建立
2.通配符掩码 wildcard mask
用途：选出一组符合否规则的IP地址
特点：0表匹配，1表示不需要匹配。0和1 的位置根据需求可随意穿插
示例1：deny ip 192.168.1.0 0.0.0.255 192.168.2.0 0.0.0.255
deny ip 192.168.1.2 0.0.0.255 192.168.2.2 0.0.0.255
deny ip 192.168.1.3 0.0.0.255 192.168.2.3 0.0.0.255
这三跳条目是完全相同的，效果都是阻止192.168.1.x 访问192.168.1.x （x表示任意数字）
红色字体部分对应的是全1，所以是忽略的 ，写什么都无所谓了
实例2：deny ip 192.168.1.0 255.0.0.255 192.168.2.0 255.0.0.255
deny ip 193.168.1.0 255.0.0.255 193.168.2.0 255.0.0.255
deny ip 194.168.1.0 255.0.0.255 194.168.2.0 255.0.0.255
这三跳条目是完全相同的，效果都是阻止x.168.1.x 访问 x.168.2.x （x表示任意数字）
红色字体部分对应的是全1，所以是忽略的 ，写什么都无所谓了
3. 反掩码（中国式教育的败笔，误人子弟的一个说法，通配符掩码的错误理解）
需求1：阻止192.168.1.0/24 访问 192.168.2.0/24
命令：deny ip 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31df5ee9babb190bc5f55315ae312776/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d65ff33fa19dcacf10d35339ba657c3d/" rel="bookmark">
			报错 ReferenceError: regeneratorRuntime is not defined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错 ReferenceError: regeneratorRuntime is not defined 解决报错，首先要知道为什么会报着个错误，regeneratorRuntime 本身在微信小程序中也没有进行定义，那就只有可能是语法的错误了，有事没事找百度，百 度上说是当下的微信开发者工具不支持ES的新特性，我页面代码中的async、await是ES7中的新特性，所以会出现这种报错 解决方法： 微信开发者工具中 =&gt; 详情 ==&gt; 本地设置 ==&gt; 开启增强编译 完成~·
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d3c7336365e25f33a3c5c7bd6278f20/" rel="bookmark">
			多线程复习总结之线程池的创建及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、引言 在面试中，线程池是其中的一大考点。本篇博客则记录关于线程池的一些总结，包括线程池的使用原因、创建线程池、线程池的形式及线程池的工作流程，希望能对你更好的理解线程有帮助。
1、为什么要创建线程池？ 线程池是一种池化技术，目的是避免线程频繁的创建和销毁带来的性能消耗。它是把已创建的线程放入“池”中，当有任务来临时就可以重用已有的线程，无需等待创建的过程，这样就可以有效提高程序的响应速度。
《Java 并发编程艺术》一书中提到使用线程池的好处：
1、降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的资源浪费。 提高响应速度。当任务到达时，不需要等到线程创建就能立即执行。
2、方便管理线程：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以对线程进行统一的分配，优化及监控。
2、如何创建线程池？ Java 中创建线程池有以下两种方式：
1、通过 ThreadPoolExecutor 类创建(推荐)
2、通过 Executors 类创建
2.1 Executors 类创建线程池 源码：
通过查看源码，我们发现：
1、这两种方式在本质上是一种方式，都是通过 ThreadPoolExecutor 类的方式创建，因为 Exexutors 类调用了 ThreadPoolExecutor 类的方法。
2、其中，上面的三张图片代表着Executors 类创建线程池的三种常用形式：固定线程池、独立线程池和缓冲线程池
实例：
public static void main(String[] args) { /** * 创建固定线程池（大小固定） **/ ExecutorService pool1 = Executors.newFixedThreadPool(2); Runnable task1 = () -&gt; { while (true) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()); } }; // pool1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d3c7336365e25f33a3c5c7bd6278f20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/285caf1adcb8fc54e08be3b2b082cc8c/" rel="bookmark">
			对比学习火了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
近期的一些paper
simsce
ConSERT
SCCL
CLEA
ERICA
QuantiDCE
更多资料
应用
总结
前言 最近对比学习火起来了，其思想特别简单但有效，总结起来就是：
对一条样本x1通过数据增强得到x2，那么这就是一对正样本对，和其他样本就是负样本对。
通常的做法就是：一个batch假设大小是M(假设其中一个样本是x1)，那么通过数据增强得到2M(x1数据增强得到x2)，正样本就是x1和x2，负样本就是x1和batch内其他的样本。
由于是在nlp的，这里重点关注一下文本领域的对比学习【其实对比学习起源于图谱领域】，更详细的一些综述可以看看：
对 比 学 习 小 综 述
细节满满！理解对比学习和SimCSE，就看这6个知识点
一文梳理2020年大热的对比学习模型
我分析了ACL21论文列表，发现对比学习已经...
文本领域大家发paper的思路点，主要就是围绕在
(1) 数据增强的方式上:比如替换词，dropout等等
(2)一些其他思路应用上:比如多模态，x1是图片，x2是图片对应的文字等等。
近期的一些paper 截止目前【2021.6.16】，已经有很多paper，抢到了这个风口，发了一波paper，一起看看都有哪些吧。这里简单列举了几个。
simsce 其用来做无监督语义相识度的，主要创新点就是：数据增强用dropout
是不是很简单，是不是很意外，没错！只需要dropout一下就可以得到很好的效果【截止目前2021.6.16，其依然是一个可以称得上sota的模型】。
关于这方面的解读可以详细看笔者的另外一篇博客，这里不再累述：
无监督文本相识度_爱吃火锅的博客-CSDN博客
https://github.com/Mryangkaitong/unsupervised_learning/tree/main/Semantic%20similarity
其中苏神还给出了对比学习中使用梯度累积
对比学习可以使用梯度累积吗？ - 科学空间|Scientific Spaces
另外drop这是数据增强对比思想还可以辅助有监督学习，也大大提高了效果：
又是Dropout两次！这次它做到了有监督任务的SOTA
ESimCSE simsce的加强版：主要创新就是Word Repetition（单词重复）和Momentum Contrast（动量对比）解决了simsce的一些缺点。
ESimCSE：无监督语义新SOTA，引入动量对比学习扩展负样本，效果远超SimCSE
ConSERT 这是美团NLP中心知识图谱团队提出的模型，也是做无监督语义相识度的即语义表征。
论文：https://arxiv.org/abs/2105.11741
代码：GitHub - yym6472/ConSERT: Code for our ACL 2021 paper - ConSERT: A Contrastive Framework for Self-Supervised Sentence Representation Transfer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/285caf1adcb8fc54e08be3b2b082cc8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf4032e295eafd6b64690b8cecfda00a/" rel="bookmark">
			【Fiddler 问题】解决关于Fiddler 抓包中，手机网络配置代理后，无法上网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【Fiddler 问题】解决关于Fiddler 抓包中，手机网络配置代理后，无法上网 一、在注册表添加文件二、配置 FiddlerScript rule 一、在注册表添加文件 1、使用 windows + R 快捷键 打开运行程序并输入 regedit，如图所示：
2、打开注册表，在 计算机\HKEY_CURRENT_USER\SOFTWARE\Microsoft\Fiddler2 下创建一个DWORD，值设置为 80（十进制），如图所示：
二、配置 FiddlerScript rule 1、编写 FiddlerScript rule，可以通过以下两种方式，打开 Fiddler Script 文件 a. 点击 规则 -&gt; 自定义规则（Rules &gt; Customize Rules） ，打开 Fiddler Script 文件
b. 在Fiddller 面板的右半部分中，找到 Fiddler Script 并点击，出现如下图所示的代码配置：
2、使用 Ctrl + F 快捷键，搜索 OnBeforeRequest 方法，并在该方法的最后添加以下代码：if (oSession.host.toLowerCase()=="webserver:8888") { oSession.host="webserver:80"; } 添加后的代码配置，如下图所示： 3、此时，手机就可以上网了。即，可以访问浏览器，或者使用应用程序了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3749a70a1a3a5e48a7a4ffde38f7ce7c/" rel="bookmark">
			Docker修改无法启动的容器的配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一（明确配置路径）
把docker容器中的配置文件复制到主机中，然后再主机中修改，修改完成后再复制到docker容器中
1、复制docker容器的文件到主机中 docker cp 容器id：docker容器中配置文件路径 主机路径docker cp eaaba6bd4423:/etc/mysql/mysql.conf.d/mysqld.cnf /root/mysqld.cnf 2、修改配置文件中出错的部分3、配置文件到docker容器中 docker cp 主机文件路径 容器id：docker容器中配置文件路径docker cp /root/mysqld.cnf eaaba6bd4423:/etc/mysql/mysql.conf.d/mysqld.cnf 方法二（文件名查找文件）
[root@izm5ei5fe43tp24hiim2d0z ~]# find / -name mysqld.cnf /var/lib/docker/overlay2/6aa46a19c936683be353bf01b3a4cb8298cdf93f53b5e4452b83d1419bb8130f/diff/etc/mysql/mysql.conf.d/mysqld.cnf 注： 你可能会找到多个配置文件，比如你启动了多个mysql容器就会出现多个mysqld.cnf，找到对应你当前错误的mysqld.cnf然后修改重启。
方法三（不记得配置路径）
输入命令 docker inspect [Mysql ID] //列出该镜像的配置信息仔细阅读这个配置信息，可以找得到对应配置信息文件存放在宿主机的文件路径。我们找到 GraphDriver.Data.MergedDir这个属性进入对应的文件夹。举个例子：
进入 /var/snap/docker/common/var-lib-docker/overlay2/xxxxxxxxxxxxxxx 目录。然后再进入到diff/etc/mysql/mysql.cnf这时候，发现这个文件才是docker里mysql容器的配置文件。修改好对应配置文件，docker命令启动即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e6d03e7993d84b7b71880862c2a412/" rel="bookmark">
			NAACL 2021 | 对比学习横扫文本聚类任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 毕竟西湖六月中，风光不与四时同。接天莲叶无穷碧，映日荷花别样红。小伙伴们好，我是卖热干面的小男孩，今天分享给大家的是亚马逊发表于 NAACL 2021上的一篇文章：Supporting Clustering with Contrastive Learning。这篇文章结合当红流量小生「对比学习」提出一种简单且有效的「无监督文本聚类」方法：SCCL。该模型刷爆了7个短文本聚类任务，6到飞起~
「论文地址」
https://arxiv.org/abs/2103.12953
「论文代码」
https://github.com/amazon-research/sccl
简介 这里先以QA方式简要介绍Supporting Clustering with Contrastive Learning这篇论文做了什么。
Q1: 文章想要解决什么问题？
A1: 文章致力于解决「无监督聚类」任务。所谓无监督聚类任务是在表征空间内通过特定的相似度量方法区分不同的「语义簇」。可以看出，这涉及2方面，输入如何表征和表征之间相似度如何度量。现有方案所得到的表示空间在各簇样本上已经「重叠」，这种开局就使得后续的聚类算法难以突破其前置天花板。
Q2: 文章怎么解决上述问题？
A2: 文章结合「对比学习」提出一种名为SCCL(Supporting Clustering with Contrastive Learning)的模型。该模型结合了bottom-up的实例对比学习和top-down的聚类，取得了更好的聚类结果。
Q3: 文章方案解决效果如何？
A3: 文章在短文本聚类任务上对SCCL进行评测。实验结果表明，SCCL在绝大多数benchmark数据集上显著优于之前的SOTA方法。在准确率上以3%-11%的优势碾压前辈方法，在归一化互信息上则更是以高出4%-15%的优势吊打之前的SOTA模型。
SCCL 这里先简要介绍下对比学习的概况，再详细介绍文章提出的SCCL模型。
对比学习 自监督学习出圈于CV领域，在CV领域的自监督可以分为两种类型：「生成式」和「判别式」自监督学习。VAE和GAN是生成式自监督学习的典型代表，这类方法要求模型重建图像或者图像的一部分，任务难度相对比较高，要求像素级的重建，中间的图像编码必须包含很多细节信息。对比学习则是典型的「判别式」自监督学习，相对生成式自监督学习，对比学习的任务难度要低一些。然而，目前多个对比学习模型的效果已超过了有监督模型，其结果着实令人振奋，难怪深度学习两巨头 Bengio 和 LeCun 在 ICLR 2020 上点名 Self-Supervised Learning（SSL，自监督学习）是 AI 的未来。
近年来对比学习愈发火热，各路大神如Hinton、Yann LeCun、Kaiming He 等也在该研究方向上频频隔空过招。从CV领域中的MoCo系列、SimCLR系列、BYOL、SwAV再到最近NLP领域中的SimCSE，各种方法相互借鉴，又各有创新，可谓百家争(内)鸣(卷)。对比学习是自监督学习的一种，该类方法不依赖标注数据，而是从无标注数据中学习知识。对比学习的核心思想是通过构造相似实例和不相似实例，从而习得一个表示学习模型，通过这个模型，相似的实例在表示空间中比较接近，而不相似的实例在表示空间中距离较远。
SCCL框架 SCCL框架流程如 Figure 2 所示。
SCCL由3部分组成：神经网络特征抽取层、clustering head 和 Instance-CL head。特征抽取层将输入映射到向量表示空间，SCCL是使用Sentence Transformer 发布的distilbert-base-nli-stsb-mean-tokens预训练模型，该模型下载地址：https://huggingface.co/sentence-transformers/distilbert-base-nli-stsb-mean-tokens/tree/main 。Instance-CL head (记为 )和 clustering head (记为 )中分别使用「contrastive loss 和 clustering loss」。Instance-CL head由「单层MLP」组成，其激活函数使用的是ReLU。输入维度是768，输出维度是128。至于clustering head则是一个「线性映射层」，维度是768*K,其中K是聚类的类别数量。所以，整体网络结构非常简洁明了~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5e6d03e7993d84b7b71880862c2a412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/757b2f8f2a8da4427e7fd44200f123ca/" rel="bookmark">
			SQLyog的下载与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载安装包 SQLyog下载链接
2、安装 2.1、选择语言，默认即可 2.2、下一步即可 2.2、接受协议并下一步 2.3、选择选项 2.4、选定安装目录 2.5、安装完成 3、连接Mysql服务 看到这个界面就连接成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d0605e5ae8669ee50398d87e4a58da/" rel="bookmark">
			Linux下配置IP地址笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下配置IP地址笔记 文章目录 Linux下配置IP地址笔记ifconfig 命令interfaces文件network-managerdns修改重启网络 ifconfig 命令 通过ifconfig命令配置的网卡IP地址用来临时测试使用。
重启后ip地址的配置将自动失效
ifconfig &lt;网卡名称&gt; &lt;IP地址&gt; netmask &lt;x.x.x.x掩码&gt; ifconfig &lt;interface&gt; [[&lt;AF&gt;] &lt;address&gt;] [netmask &lt;address&gt;] interfaces文件 在ubuntu16.04系统中配置管用
vi /etc/network/interfaces
network-manager 一般桌面版的ubuntu使用network-manager管理
sudo servicenetwork-manager stop sudo servicenetwork-manager stop 如果用户希望在Desktop版本中，直接使用interfaces 进行网络配置，那最好删除network-manager 。
dns修改 vi /etc/resolv.conf nameserver 192.168.1.254 #希望修改成的DNS 重启网络 $ systemctl list-units --type=service | grep network networking.service loaded active exited Raise network interfaces sudo/etc/init.d/networking restart $ systemctl list-unit-files --type=service | grep network dbus-org.freedesktop.network1.service disabled networking.service enabled systemd-networkd-resolvconf-update.service static systemd-networkd-wait-online.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13d0605e5ae8669ee50398d87e4a58da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d31c9b6178595f090a8b5ab4f23ac8af/" rel="bookmark">
			【opencv】【图像梯度】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们来计算图像中各个像素点的梯度
我们可以用一阶的Sobel算子和Scharr算子，以及使用二级的Laplace算子，试验如下：
原始图像是：
一阶算子的梯度计算如下：
求图像各个像素点的梯度。上面计算的sobel算子可以近似认为是X和Y方向的梯度，那么总的梯度是：
G = (Gx^2 + Gy ^2) ^ 0.5 或者是近似计算成
G = |Gx| + |Gy|
二阶算子，直接可得到梯度。
import numpy as np import random import cv2 import matplotlib.pyplot as plt # 展示图像，封装成函数 def cv_show_image(name, img): cv2.imshow(name, img) cv2.waitKey(0) # 等待时间，单位是毫秒，0代表任意键终止 cv2.destroyAllWindows() img = cv2.imread('images/yuan.png') # 读取原始图像 print(img.shape) # Sobel算子，例如是向右方向梯度的 # [[-1, 0, 1], # Gx = [-2, 0, 2], # [-1, 0, 1]] # 例如是向下方向梯度的 # [[-1, -2, -1], # Gy = [0, 0, 0], # [1, 2, 1]] # 相当于就是右边的像素值减去左边的像素值 # dst = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d31c9b6178595f090a8b5ab4f23ac8af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b63e2d770992f7d4eb98d390c697ae8/" rel="bookmark">
			打包后的SpringBoot项目为什么可以直接运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 SpringBoot框架已经成为很多公司的标配，得益于其快速配置和容易上手，将程序员从繁杂的项目配置工作中解脱出来，将精力更多的集中在业务中，而深受猿媛们的喜爱。通过使用java -jar命令直接运行打包后的SpringBoot项目，不用再搭建额外的tomcat等web容器便可以启动一个web项目。不知你有没有思考过，打包后的SpringBoot项目为什么可以直接运行呢？
运行命令做了什么 要想搞清楚这个问题，就要看看java -jar命令到底做了哪些事情。通过阅读Oracle官方文档可以找到该命令的描述。
对于java [options] -jar filename [args]有：
If the -jar option is specified, its argument is the name of the JAR file containing class and resource files for the application. The startup class must be indicated by the Main-Class manifest header in its source code. 翻译过来大概就是：
如果指定了 -jar 选项，则其参数是包含应用程序的类和资源文件的 JAR 文件的名称。
启动类必须由其源代码中 manifest 的 Main-Class 指示。
说白了就是这个命令会去找 jar 文件中的 MANIFEST.MF 文件，MANIFEST.MF 文件中指定了真正的启动类。
打包命令做了什么 当我们将 spring-boot-maven-plugin 打包插件添加到项目中，运行打包命令后，打包时插件会把依赖的 Jar 文件一起打包进去，并在META-INF目录下生成一个MANIFEST.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b63e2d770992f7d4eb98d390c697ae8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d654dd780c827997c1c1f5364f4572/" rel="bookmark">
			[4K测试视频] 杜比4K UHD蓝光演示碟 Dolby.UHD.BluRay.Demo.Disc.March.2018.2160p.BluRay下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		杜比4k UHD BluRay演示光盘信息
&lt;span style =“ text-align：justify;”&gt;磁盘信息：&lt;/ span&gt; &lt;span style =“ text-align：justify;”&gt;光盘标题：Dolby.UHD.Blu-Ray.Demo.Disc.March.2018.2160p.Blu-Ray。HEVC .TrueHD.Atmos.7.1 &lt;/ span&gt; &lt;span style =“ text-align：justify;”&gt;光盘大小：25,795,231,210字节&lt;/ span&gt; &lt;span style =“ text-align：justify;”&gt;保护：AACS2 &lt;/ span&gt; &lt;span style =“ text-align：justify;”&gt;附加内容：超高清，BD-Java，50Hz内容&lt;/ span&gt; &lt;span style =“ text-align：justify;”&gt; BDInfo：0.7.5.3（由DVDFab 11.0.3.5创建的兼容布局）&lt;/ span&gt; &lt;span style =“ text-align：justify;”&gt;播放列表报告：&lt;/ span&gt; &lt;span style =“ text-align：justify;”&gt;名称：00004.MPLS &lt;/ span&gt; &lt;span style =“ text-align：justify;”&gt;长度：0：03：44.390（h：m：s.ms）&lt;/ span&gt; &lt;span style =“ text-align：justify;”&gt;大小：1,800,585,216字节&lt;/ span&gt; &lt;span style =“ text-align：justify;”&gt;总比特率：64.19 Mbps &lt;/ span&gt; &lt;span style =“ text-align：justify;”&gt;（*）表示此播放列表隐藏的包含流。&lt;/ span&gt; &lt;span style =“ text-align：justify;”&gt;视频：&lt;/ span&gt; &lt;span style =“ text-align：justify;”&gt;编解码器比特率描述&lt;/ span&gt; &lt;span style =“ text-align：justify;”&gt; ----- ------- ----------- &lt;/ span&gt; &lt;span style =“ text-align：justify;”&gt; MPEG-H HEVC视频38988 kbps 2160p / 23.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2d654dd780c827997c1c1f5364f4572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1a2cb740ef11521cb0df1bff40ced7/" rel="bookmark">
			Python学习笔记（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、变量
1.1 变量的定义
1.2 变量的类型
1.3 不同类型变量之间的计算
1.4 变量的输入
1.5 变量的格式化输出
1.6 变量的命名
1.7 变量的命名规则
二、if语句
2.1 基本语法
2.2判断语句实例
2.3比较运算符
2.4 else处理条件不满足的情况
2.5 逻辑运算
2.6 elif
2.7 if的嵌套
一、变量 1.1 变量的定义 &gt;在Python中每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。
&gt;等号（=）用来给变量赋值。=左边是一个变量名。=右边是存储在变量中的值。
变量名 = 值
&gt;变量定义之后，后续就可以直接使用了。
&gt;使用交互式方式（ipython），如果要查看变量的内容，直接输入变量名即可，不需要使用print函数。
&gt;使用解释器执行，如果要输出变量的内容，必须要使用print函数。
实例1:
# 1.定义一个变量记录QQ号码 qq_number = "1234567" # 2.定义一个变量记录QQ密码 qq_password = "123" #在程序中，如果要输出变量的内容，需要使用print函数 print(qq_number) print(qq_password) 1234567 123 实例2：超市买苹果
# 定义苹果价格变量 price = 8.5 # 定义购买重量 weight = 7.5 # 计算金额 money = price * weight print(money) 63.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b1a2cb740ef11521cb0df1bff40ced7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7770ecaab9a907fdba36698764aeb30f/" rel="bookmark">
			Spring源码之AOP源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言基本概念横切关注点切面（Aspect）连接点（JoinPoint）切入点（PointCut）通知（Advice）目标对象（Target）织入（Weave）引入（Introduction） 类结构体系示例代码产生过程创建过程执行过程 前言 上一篇看了Spring IOC源码，猿猿们都知道，有IOC就有AOP，那这篇就结合例子来看一下AOP的源码。
基本概念 AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。
AOP技术恰恰相反，它利用一种称为"横切"的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为"Aspect"，即切面。所谓"切面"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。
使用"横切"技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。
横切关注点 即对哪些方法进行切入，对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。
切面（Aspect） 把原来糅杂在业务逻辑代码中的非业务代码抽取出来，把功能相同的放在一个类中形成一个切面。类是对物体特征的抽象，切面就是对横切关注点的抽象。
连接点（JoinPoint） 需要切入的点、被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。
切入点（PointCut） 对连接点进行拦截的定义。
通知（Advice） 所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五种。
目标对象（Target） 代理的目标对象。
织入（Weave） 将切面应用到目标对象并导致代理对象创建的过程。
引入（Introduction） 在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段。
基本概念网上有很多，就不细说了。这里要提一下AOP是一种思想，它的实现主要有Spring AOP和AspectJ，Spring实现AOP的底层相当复杂，所以借助了AspectJ的语法来实现，即使用了@Aspect注解来实现。
Spring AOP是在运行期进行织入的，而AspectJ是在编译期进行织入。
类结构体系 示例代码 配置类
@Configuration @ComponentScan(value = "com.ambition") /** * Spring AOP 默认使用 JDK 动态代理 * * proxyTargetClass = true 时则代理目标对象时强制使用 CGLIB 代理 * @see DefaultAopProxyFactory#createAopProxy(org.springframework.aop.framework.AdvisedSupport) * * exposeProxy = true 暴露代理对象，这样就可以使用 AopContext.currentProxy() 方法获取当前代理的对象 * @see AopContext#currentProxy * @see JdkDynamicAopProxy#invoke(java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7770ecaab9a907fdba36698764aeb30f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc385a56f0c79841651a63e74ae5f57/" rel="bookmark">
			Mac安装Homebrew
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简介二、官方脚本下载安装及配置环境变量三、GitHub加速3.1、Mac3.2、Windows 四、镜像脚本安装五、更换镜像源5.1、中科大5.2、清华5.3、腾讯5.4、北京外国语5.5、阿里 六、恢复默认源七、Homebrew常用命令 一、简介 Homebrew是一款包管理工具，目前支持macOS和Linux系统。主要有四个部分组成：brew、homebrew-core 、homebrew-cask、homebrew-bottles
名称说明brewHomebrew源代码仓库homebrew-coreHomebrew 核心源homebrew-cask提供 macOS 应用和大型二进制文件的安装homebrew-bottles预编译二进制软件包 二、官方脚本下载安装及配置环境变量 首先我们可以进入官网地址：https://brew.sh 获取下载链接，如下：
在安装完成后如果遇到command not found: brew的错误，一般是环境变量无效，这里则需要使用之前介绍使用过的echo $SHELL来确认终端类型，如下
以前每个新用户的默认shell是/bin/bash，那么这里我们需要配置文件为~/.bash_profile，从macOS Catalina(10.15.x) 版开始，Mac使用/bin/zsh作为默认Shell，其对应的配置文件为~/.zshrc
另外我们还需确定下我们电脑CPU的型号，这里可以通过uname -m来查看，如下
M1芯片ARM版Homebrew最终会被安装在/opt/homebrew路径下，而之前Intel芯片的Mac则会被安装到/usr/local/Homebrew路径下。
所以综上所述，我们在配置Homebrew环境变量的时候，需要结合不同的情况来进行相应的配置，如下：
M1芯片
zshecho 'eval "$(/opt/homebrew/bin/brew shellenv)"' &gt;&gt; ~/.zprofile eval "$(/opt/homebrew/bin/brew shellenv)" bashecho 'eval "$(/opt/homebrew/bin/brew shellenv)"' &gt;&gt; ~/.bash_profile eval "$(/opt/homebrew/bin/brew shellenv)" Intel芯片
zshecho 'eval "$(/usr/local/Homebrew/bin/brew shellenv)"' &gt;&gt; ~/.zprofile eval "$(/usr/local/Homebrew/bin/brew shellenv)" bashecho 'eval "$(/usr/local/Homebrew/bin/brew shellenv)"' &gt;&gt; ~/.bash_profile eval "$(/usr/local/Homebrew/bin/brew shellenv)" 三、GitHub加速 在使用官方脚本进行下载安装时，经常会遇到下面的错误提示：
curl: (7) Failed to connect to raw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cc385a56f0c79841651a63e74ae5f57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/960a86404bcf1e701eb57e9c489ffd3b/" rel="bookmark">
			组卷积（group Conv）与深度可分离卷积（depthwise）简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详细解释：https://zhuanlan.zhihu.com/p/92134485
个人理解：一共分为两步
1.对每个输入通道进行一个卷积，有几个通道就几个1kk的卷积平面，通道之间没有任何沟通。
2.类似全连接的手段将每个通道卷积后的特征图们关联起来。
计算量：Cin=3,Cou=2,输入特征图33大小。k=3
原来：3332=54
深度可分离：333+1132=33
333(第一步)+1132（第二步）
组卷积：(最早见于AlexNet——2012年Imagenet的冠军方法，Group Convolution被用来切分网络，使其在2个GPU上并行运行)
把channel分为多组，一个卷积核不需要对所有通道的特征图进行卷积，仅仅对本组内的通道特征进行卷积。
当每组中仅有一个通道特征时，即为深度卷积。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/585c4bfcf3da785f126eb66ee3803729/" rel="bookmark">
			最新django-cors-headers配置项简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置 根据2022-2-12的readme.rst文档书写
在Django设置中配置中间件的行为。必须设置以下三种设置中的至少一种：
CORS_ALLOWED_ORIGINSCORS_ALLOWED_ORIGIN_REGEXECORS_ALLOW_ALL_ORIGINS CORS_ALLOWED_ORIGINS: Sequence[str] 允许的来源，默认为[]
CORS_ALLOWED_ORIGINS = [ "https://example.com", "https://sub.example.com", "http://localhost:8080", "http://127.0.0.1:9000", ] 代替CORS_ORIGIN_WHITELIST
CORS_ALLOWED_ORIGIN_REGEXES: Sequence[str | Pattern[str]] 使用正则表达式的允许的来源
CORS_ALLOWED_ORIGIN_REGEXES = [ r"^https://\w+\.example\.com$", ] 代替CORS_ORIGIN_REGEX_WHITELIST
CORS_ALLOW_ALL_ORIGINS: bool 如果为True，允许所有来源，默认为False
代替CORS_ORIGIN_ALLOW_ALL
先到这里，其他的配置以后再加
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b22c17901bfe98900352eb71e3066934/" rel="bookmark">
			多线程 -- 超卖问题（redis分布式锁）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📒博客首页：崇尚学技术的科班人
🍣今天给大家带来的文章是《多线程 -- 超卖问题（redis分布式锁）》🍣
🍣希望各位小伙伴们能够耐心的读完这篇文章🍣
🙏博主也在学习阶段，如若发现问题，请告知，非常感谢🙏
💗同时也非常感谢各位小伙伴们的支持💗
文章目录 1、搭建测试环境2、测试结果3、在方法上加 synchronized 测试4、利用 redis 加分布式锁 1、搭建测试环境 下面抽取的是一个SpringBoot项目中的秒杀案例的一部分，synchronized可以解决该超卖问题，但是由于此项目是分布式情景下的，所以最终我们用redis分布式锁解决了超卖问题。
引入的依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springBoot整合redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; yaml server: servlet-path: /sell # 访问路径前缀 KeyUtil import java.util.Random; public class KeyUtil { public static String getUniqueKey(){ Random random = new Random(); Integer a = random.nextInt(900000) + 100000; return String.valueOf(a) + System.currentTimeMillis(); } } SecKillService /** * @author ：小肖 * @date ：Created in 2022/2/10 10:42 */ public interface SecKillService { /** * 查询秒杀活动特价商品的信息 * @param productId * @return */ String querySecKillProductInfo(String productId); /** * 模拟不同用户秒杀同一商品的请求 * @param productId * @return */ void orderProductMockDiffUser(String productId); } SecKillServiceImpl import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b22c17901bfe98900352eb71e3066934/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbfd2f990f327a7d4d69a2645570f31b/" rel="bookmark">
			LeetCode热题100道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、两数之和2、两数相加3、无重复字符的最长子串4、最长回文子串5、盛最多水的容器6、删除链表的倒数第 N 个结点7、Day 2 【未完待续】 1、两数之和 通往【LeetCode - 两数之和】的任意门
解法一：暴力解
采用两层for循环，第一次层循环选取第一个数，第二次循环选取第二个数，第二层循环找到符合的数则直接返回结果。
时间复杂度：O(n^2)
空间复杂度：O(1)
vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; res; for (int i = 0; i &lt; nums.size(); i ++) { for (int j = i + 1; j &lt; nums.size(); j ++) { if (nums[i] + nums[j] == target) { res.push_back(i); res.push_back(j); return res; } } } return res; } 解法二：使用map
第一次遍历数组，初始化map，判断map是否存在key为nums[i]的键值对，不存在则将(nums[i], i)插入map中，存在则继续下一轮循环。
第二次遍历数组，若能够在map中找到key为target - nums[i]，且value !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbfd2f990f327a7d4d69a2645570f31b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/842c242bc37b098924a56fb023994e86/" rel="bookmark">
			CAN通讯矩阵之Intel格式与Motorola格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 概述2. 发送顺序3. Intel 格式4. Motorola 格式5. 总结 1. 概述 参考博客：Intel格式与Motorola格式的区别。
主要是对上面提到的博客做下笔记，结合其他文章，转化为自己的理解写下来。（注：直接阅读链接博客时，请结合评论内容理解，博客内使用的图片有误。）
2. 发送顺序 多数厂商定义的CAN总线字节发送顺序均为先发送LSB，最后发送MSB。即：首先发送byte0（LSB），然后byte1，byte2，……（MSB）的发送顺序。
（链接博客有人指出：主机厂发送CAN报文数据从byte0~byte7，并不是针对信号的，而是针对CAN2.0规范，CAN2.0报文格式和时序就是从byte0到byte7。byte0可以理解成低字节地址，byte7理解成高字节地址。）
CAN数据段中每个字节传输顺序是：首先传输一个字节的高位msb，最后传输该字节的低位lsb。（7…0，…，63…56）
当一个信号的数据长度不超过 1 个字节（8 位）时，Intel 与 Motorola 两种格式的编码结果没有什么不同，完全一样。
3. Intel 格式 信号的高位（S_msb）将被放在高字节（MSB）的高位，信号的低位（S_lsb）将被放在低字节（LSB）的低位。这样，信号的起始位就是低字节的低位。
对博客中使用的图片示例进行标注。
先看一个16位数据长度的信号。信号数据为0x36A5，在CAN的低字节填入0xA5，在CAN的高字节填入0x36。
信号数据为0x6A5，起始位为0，长度为12。填入过程：
起始位0即byte0的bit0，信号长度为12，也就可以得出，信号会使用byte0的8个bit+byte1的4个bit。byte0字节填入信号的低字节，即0xA5，byte1字节填入信号的高字节，即0x6。
4. Motorola 格式 信号的高位（S_msb）将被放在低字节（MSB）的高位，信号的低位（S_lsb）将被放在高字节（LSB）的低位。这样，信号的起始位就是高字节的低位。
同样先看一个16位数据长度的信号。信号数据为0x36A5，在CAN的低字节填入0x36，在CAN的高字节填入0xA5。
发送数据为0x6A5，起始位为12，长度为12。填入过程：
起始位12即byte1的bit4，信号长度为12，也就可以得出，信号会使用byte1的4个bit+byte0的8个bit。byte0字节填入信号的高字节，即0x6A。byte1字节填入0x5。
5. 总结 总的来说：
一、Intel（小端）低字节LSB在前，高字节MSB在后。
二、Motorola（大端）高字节MSB在前，低字节LSB在后。
其他参考：Motorola和Intel格式报文解析的区别、CAN总线的编码方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0e2d0ef582f52312ba4859644ced11a/" rel="bookmark">
			M/M/1 模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标 ：学会 MM1模型
再进行推广 ，完成机场第三问
假设 这两个模型假设顾客抵达与服务时间为指数分布，时间流程为泊松过程，
论文
论文中需要写的假设 根据统计学规律，在一段时间之内，各个航班到达的乘客前往出租车乘车区域乘车的人数符合泊松分布。
根据统计学规律，每一个到达航班的需要乘坐出租车的乘客到达出租车乘车等候区的时间满足正
态分布。
生灭过程 The Birth-and-Death Process. 为了得出M/M/1 及 M/M/S的一般公式，笔者认为有必要简单推导下…… 该模型为连续时间马尔可夫过程(continuous time Markov chain)，要介绍全很困难，这里就给一个简易推导。
在排队论中，“生” 指的是 客抵达系统，“灭”指的是客离开系统，生灭过程的系统状态 N（t）
此时顾客在t时候的顾客数量
有以下的假设：
当前状态 N（t）=n 直接到下一过程顾客来的时间的概率分布为指数分布，参数 λ n \lambda_n λn​ (n=0,1,2,…)当前状态下N(t) =n直到下一位顾客来的时间为指数分布，参数为 μ n \mu_n μn​(n=0,1,2,…)前两者的分布独立，下一次的状态的转换为 或者
取决于两个时间的长短。
还可以这么表示：
在稳态队列的情况下: 任何系统状态的进出速率应该相当。
举一个例子，系统在状态0的情况下:
从状态0转移到状态1(没有顾客到一个顾客)时，离开与进入相等:
省略迭代的推导 ，给结论 则
参数的计算 由此算出
系统平均顾客 系统平均顾客
L = ∑ n = 0 inf ⁡ n P n L = \sum\limits_{n=0}^{\inf}nP_n L=n=0∑inf​nPn​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0e2d0ef582f52312ba4859644ced11a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b68200f433c807158332d0022807eb0b/" rel="bookmark">
			MySQL删除表数据 MySQL清空表命令 3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MySQL清空表数据命令：truncate SQL语法：
truncate table 表名 注意：
不能与where一起使用。truncate删除数据后是不可以rollback的。truncate删除数据后会重置Identity（标识列、自增字段），相当于自增列会被置为初始值，又重新从1开始记录，而不是接着原来的ID数。truncate删除数据后不写服务器log，整体删除速度快。truncate删除数据后不激活trigger(触发器)。 二、MySQL删除表命令：drop SQL语法：
drop table 表名; 或者是
drop table if exists 表名; 注意：
truncate只会清除表数据，drop不光清除表数据还要删除表结构。
三、MySQL清空数据表内容的语法：delete SQL命令：
delete from 表名 where id='1'; 或
delete from 表名; 注意：
delete含义：你要删除哪张表的数据 ?你要删掉哪些行 ?delete可以删除一行，也可以删除多行；如果不加where条件，则是删除表所有的数据，这是很危险的！不建议这样做！ 总结：
1、当你不再需要该表时， 用 drop;
2、当你仍要保留该表，但要删除所有数据表记录时， 用 truncate;
3、当你要删除部分记录或者有可能会后悔的话， 用 delete。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/631cb8c7e19766d42e908b0c0aa77d4d/" rel="bookmark">
			imread改变图片显示尺寸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		挺简单的，但是不会，还查了好久，伤心，写给自己查看 int main() { Mat girl = imread("F:/VSMaven/LocateQr/Location/Location/phone.jpg", IMREAD_REDUCED_COLOR_2); //载入图像到Mat if (girl.empty()) { printf("没有此图片，请检查路径是否正确"); return -1; } else { namedWindow("enhanced", 0); resizeWindow("enhanced", 300, 400);//显示的就是300*400的大小，可以拖拽 imshow("enhanced", girl);//显示名为 "enhanced"的窗口 } waitKey(0); return 0; 是else中的那三条语句，尺寸的大小可以自己设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08f52681f4c7814665962b01dc00a792/" rel="bookmark">
			curl上传文件带参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		curl -F "file=@/home/work/data/2022线上版.xlsx;filename=2022线上版.xlsx" \
-F "version=1.2" \
-F "name=测试文件" \
-F "tags=2022线上版.xlsx" \
-H "Expect:" \
-H 'Cookie: jsprod=03d2a9be-98bc-4329-6105-f7d61c83a212' \
http://localhost:8088/api/upform/versions/create/
参数 -H “Expect” 用来解决在lighttpd 下 " 417 - Expectation Failed "
-F 就是你上传表单里的字段
-F "file=@后面表示要上传的本地文件路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b226eee805571f6c51d469e65c17e245/" rel="bookmark">
			MoveIt教程[19]：IKFast Kinematics Solver
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本节中，将介绍为MoveIt配置IKFast插件。
一.What is IKFast
来自Wikipedia: IKFast，机器人运动学编译器，是Rosen Diankov的OpenRAVE运动规划软件中提供的一个强大的逆运动学求解器。与大多数逆运动学求解器不同，IKFast可以解析求解任何复杂运动学链的运动学方程，并生成语言特定的文件[如C++]供以后使用。最终的结果是非常稳定的解决方案，可以在最近的处理器上以5微秒的速度运行。
二.MoveIt! IKFast
MoveIt IKFast是一个使用OpenRAVE生成的cpp文件为MoveIt生成IKFast运动学插件的工具。本教程将通过设置机器人来利用IKFast的力量。MoveIt IKFast使用OpenRAVE 0.8和6DOF和7DOF机械臂机械手在ROS上进行动力学测试。虽然它在理论上可以工作，但目前IKFast插件生成器工具还不能与&gt;7自由度臂一起工作。
三.Getting Started
如果还没有这样做，确保你已经完成了开始的步骤。应该使用安装助手创建机器人的MoveIt配置包。
在Ubuntu 16.04上安装OpenRAVE是一件棘手的事情。这里有两篇博文提供了安装OpenRAVE的不同方法。
Stephane Caron’s Installing OpenRAVE on Ubuntu 16.04Francisco Suarez-Ruiz’s Robotics Workstation Setup in Ubuntu 16.04 确保安装了这些程序：
sudo apt-get install cmake g++ git ipython minizip python-dev python-h5py python-numpy python-scipy qt4-dev-tools 可能还需要下列类库：
sudo apt-get install libassimp-dev libavcodec-dev libavformat-dev libavformat-dev libboost-all-dev libboost-date-time-dev libbullet-dev libfaac-dev libglew-dev libgsm1-dev liblapack-dev liblog4cxx-dev libmpfr-dev libode-dev libogg-dev libpcrecpp0v5 libpcre3-dev libqhull-dev libqt4-dev libsoqt-dev-common libsoqt4-dev libswscale-dev libswscale-dev libvorbis-dev libx264-dev libxml2-dev libxvidcore-dev 要启用OpenRAVE查看器，可能还需要从源代码安装OpenSceneGraph-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b226eee805571f6c51d469e65c17e245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/429dbdf359909548d9f928b95d76f7b7/" rel="bookmark">
			C语言中的%和/的含义（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		%：取余，例 7%3=1（商2余为1）
/ ：取商，例 7/3=2.3 （商为2.3）
拓展：
%d：读入十进制整数
%u：读入一个无符号十进制整数
%s：读入一个字符串（遇空格、制表位或换行符结束）
%c：读入一个字符
%p：读入一个指针
%o：读入八进制整数
%x %X：读入十六进制整数
%f %F %E %g %G：用来输出实数（可用小数形式或指针形式输入）
%a %A：读入一个浮点值（仅C99有效）
%n：至此已读入值得等价字符数
%e：以指数形式输出实数
%%：读入%符号
%[ ]：扫描字符集合
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fb1425447f82367fc7f93e8fbf4e8f6/" rel="bookmark">
			Adult数据集分析（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、研究意义
二、数据集介绍
样本属性及含义
三、数据预处理 （1）模型选择
（2）数据导入
（3）数据删除与清洗
（4）数据转化
（5）重点部分
（6）划分训练集与测试集
四、两种模型对上述数据集进行预测
决策树
朴素贝叶斯
五、结果分析
一、研究意义 如果我们知道对收入高低起决定性的因素，或者哪些因素组合在一起有着能够增大收入 的可能性，那么这样可以帮助很多人少走弯路，朝着正确的方向努力，早日达到目标。 就像许多传授给我们人生智慧的书籍一样，我们的目标是探寻一种影响人收入的条件体系并在以后的日子里继续对这套体系做出完善，以求能找到富裕的秘诀。
二、数据集介绍 Adult数据集（即“人口普查收入”数据集），由美国人口普查数据集库 抽取而来，其中共包含48842条记录，年收入大于50k美元的占比23.93%，年收入小于50k美元的占比76.07%，并且已经划分为训练数据32561条和测试数据16281条。 该数据集类变量为年收入是否超过50k美元，属性变量包括年龄、工种、学历、职业等 14类重要信息，其中有8类属于类别离散型变量，另外6类属于数值连续型变量。该数据集是一个分类数据集，用来预测年收入是否超过50k美元。
样本属性及含义 三、数据预处理 （1）模型选择 通过对“Adult”数据集的观察，发现在一些属性上的缺失值较多，并且14个样本属性中既有连续型变量也有离散型变量，又因为“Adult”数据集属于分类数据集，综合考虑下， 选取决策树算法与贝叶斯算法作为主要预测方式。
补充说明：决策树算法计算比较简单，解释性强，比较适合处理有缺失属性值的数据样本。贝叶斯算法源于古典数学理论，有着坚实的数学基础，分类效率稳定，同样算法比较简单，对缺失数据不太敏感。
（2）数据导入 #将下载的数据集adult.data和adult.test存在data文件夹中 train_data = 'data/adult.data' test_data = 'data/adult.test' #通过pandas包中read_csv方法，给每一列加上属性名 columns = ['Age','Workclass','fnlgwt','Education','EdNum','MaritalStatus', 'Occupation','Relationship','Race','Sex','CapitalGain', 'CapitalLoss','HoursPerWeek','Country','Income'] df_train_set = pd.read_csv(train_data, names=columns) #因为第一行是无用数据，所以跳过 df_test_set = pd.read_csv(test_data, names=columns, skiprows=1) （3）数据删除与清洗 # 因为fnlgwt属性记录的是人口普查员的ID，对预测结果无影响，故删除该列 df_train_set.drop('fnlgwt', axis=1, inplace=True) df_test_set.drop('fnlgwt', axis=1, inplace=True) #进行数据清洗，将数据集中‘?’字符替换为‘Unknown’ for i in df_train_set.columns: df_train_set[i].replace('?', 'Unknown', inplace=True) df_test_set[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fb1425447f82367fc7f93e8fbf4e8f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f88c0b60c9ce1f8fa3e8f32e3966e0a3/" rel="bookmark">
			Ubuntu 20.04 手动实现 rc.local
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更正一下本文的误点，感谢 老改名字很烦 的提醒。
如果要启动 rc.local ，只需要创建 /etc/rc.local 文件，然后添加可执行权限即可。
Ubuntu 16.04 版本开始去除了 rc.local 文件，自启动服务方面基本由 systemd 全面接管了。想要添加一些开机运行的操作只能创建 systemd 服务或者添加 desktop 文件，有点麻烦。干脆把 rc.local 重新实现。
原理 创建一个 systemd 服务，开机执行指定脚本（rc.local）的内容。
实现 1）rc-local.service 文件
在 Ubuntu 20.04 中这个文件存在。看起来只是把 rc.local 功能隐藏起来了。如果你的版本没有这个文件，可以自己创建一个，然后把内容添加上去。
$ sudo vim /lib/systemd/system/rc-local.service
添加以下内容：
[Install] WantedBy=multi-user.target Alias=rc-local.service 完整内容：
2）rc.local 文件
创建 rc.local 文件
$ sudo vim /etc/rc.local
文件内容：
#!/bin/sh # 这里添加要开机执行的脚本和命令等等 exit 0 添加可执行权限
$ sudo chmod +x /etc/rc.local
3）创建软链接
$ sudo ln -s /lib/systemd/system/rc-local.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f88c0b60c9ce1f8fa3e8f32e3966e0a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07fc6d80abef20b137c2bc796b2dcb52/" rel="bookmark">
			MyBatis-Plus 多表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MP提供了大量单表查询的方法，但是没有多表的操作，所以涉及到多表的查询时，需要我们自己实现
前面内容可以跳过，可通过目录跳到多表查询示例
思路1 因为MP是基于MyBatis实现，我们可以使用MyBatis的结果映射来做，下面是一个官网的例子
https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#Result_Maps
结果映射 &lt;!-- 非常复杂的语句 --&gt; &lt;select id="selectBlogDetails" resultMap="detailedBlogResultMap"&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio, A.favourite_section as author_favourite_section, P.id as post_id, P.blog_id as post_blog_id, P.author_id as post_author_id, P.created_on as post_created_on, P.section as post_section, P.subject as post_subject, P.draft as draft, P.body as post_body, C.id as comment_id, C.post_id as comment_post_id, C.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07fc6d80abef20b137c2bc796b2dcb52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e491388bdc869f13be9e336270b8a842/" rel="bookmark">
			Haproxy搭建Web群集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、常见的Web群集调度器
二、Haproxy应用分析
三、Haproxy调度算法原理
四、Haproxy的主要特性
五、Haproxy负载均衡策略
六、LVS、Nginx、Haproxy的区别
七、Haproxy搭建 Web 群集
7.1 haproxy服务器部署
7.2 节点服务器部署
7.3 测试 Web群集
八、日志定义
一、常见的Web群集调度器 常见的Web集群的调度器分为软件和硬件软件通常使用开源的LVS、Haproxy. Nginx LVS性能最好，但是搭建相对复杂; Nginx的upstream模块支持群集功能，但是对群集节点健康检查功能不强，高并发性能没有Haproxy好。 硬件一般使用比较多的是F5，也有很多人使用国内的一些产品，如梭子鱼、绿盟等。
二、Haproxy应用分析 LVS在企业应用中抗负载能力很强，但存在不足
LVS不支持正则处理，不能实现动静分离对于大型网站，LVS的实施配置复杂，维护成本相对较高 Haproxy是一 款可提供高可用性、负载均衡、及基于TCP和HTTP应用的代理的软件
适用于负载大的Web站点运行在硬件上可支持数以万计的并发连接的连接请求 三、Haproxy调度算法原理 Haproxy支持多种调度算法，最常用的有三种
1、RR (Round Robin)
RR算法是最简单最常用的一种算法，即轮询调度
理解举例
有三个节点A、B、C第一个用户访问会被指派到节点A第二个用户访问会被指派到节点B第三个用户访问会被指派到节点C第四个用户访问继续指派到节点A,轮询分配访问请求实现负载均衡效果 Haproxy支持多种调度算法，最常用的有三种
2、LC (Least Connections)
最小连接数算法，根据后端的节点连接数大小动态分配前端请求
理解举例
有三个节点A、B、C,各节点的连接数分别为A:4、B:5、 C:6第一个用户连接请求，会被指派到A上，连接数变为A:5、B:5、 C:6第二个用户请求会继续分配到A上，连接数变为A:6、B:5、 C:6; 再有新的请求会分配给B，每次将新的请求指派给连接数最小的客户端由于实际情况下A、B、C的连接数会动态释放,很难会出现一样连接数的情况此算法相比较r算法有很大改进，是目前用到比较多的一种算法 3、SH (Source Hashing)
基于来源访问调度算法，用于-些有Session会话记录在服务器端的场景，可以基于来源的IP、Cookie等做集群调度
理解举例
有三个节点A、B、C,第一个用户第一次访问被指派到了A,第二个用户第一次 访问被指派到了B当第一个用户第二次访问时会被继续指派到A,第二个用户第二次访问时依旧会被指派到B，只要负载均衡调度器不重启，第一个用户访问却会被指派到A,第二双击可隐藏空白个用户访问都会被指派到B，实现集群的调度此调度算法好处是实现会话保持，但某些IP访问量非常大时会引|起负载不均衡,部分节点访问量超大，影响业务使用 四、Haproxy的主要特性 ●可靠性和稳定性非常好，可以与硬件级的F5负载均衡设备相媲美;
●最高可以同时维护40000-50000个并发连接，单位时间内处理的最大请求数为20000个，最大处理能力可达10Git/s;
●支持多达8种负载均衡算法，同时也支持会话保持;
●支持虚机主机功能，从而实现web负载均衡更加灵活;
●支持连接拒绝、全透明代理等独特的功能;
●拥有强大的ACL支持，用于访问控制;
●其独特的弹性二叉树数据结构，使数据结构的复杂性上升到了0(1)，即数据的查寻速度不会随着数据条目的增加而速度有所下降;
●支持客户端的keepalive功能，减少客户端与haproxy的多次三次握手导致资源浪费，让多个请求在一个tcp连接中完成;
●支持TCP加速，零复制功能，类似于mmap机制;
●支持响应池( response buffering) ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e491388bdc869f13be9e336270b8a842/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c07cdc7144fd8c6fb774c576cf8d99f9/" rel="bookmark">
			Simhash算法详解及python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Simhash算法详解及python实现 GoogleMoses Charikar发表的一篇论文“detecting near-duplicates for web crawling”中提出了simhash算法，专门用来解决亿万级别的网页的去重任务。
文章目录 Simhash算法详解及python实现前言一、什么是simhash二、simhash步骤1.分词2.hash3.加权4.合并5.降维 三、simhash比对总结 前言 simhash算法用来进行文本比对的
提示：以下是本篇文章正文内容，下面案例可供参考
一、什么是simhash simhash算法用来进行文本比对的
二、simhash步骤 simhash包含分词、hash、加权、合并、降维五大步骤
simhash代码如下
import jieba import jieba.analyse import numpy as np class SimHash(object): def simHash(self, content): seg = jieba.cut(content) # jieba.analyse.set_stop_words('stopword.txt') # jieba基于TF-IDF提取关键词 keyWords = jieba.analyse.extract_tags("|".join(seg), topK=10, withWeight=True) keyList = [] for feature, weight in keyWords: # print('feature:' + feature) print('weight: {}'.format(weight)) # weight = math.ceil(weight) weight = int(weight) binstr = self.string_hash(feature) print('feature: %s , string_hash %s' % (feature, binstr)) temp = [] for c in binstr: if (c == '1'): temp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c07cdc7144fd8c6fb774c576cf8d99f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/100b54c8d3567f651d22aa15a106acd8/" rel="bookmark">
			离线打包python模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pip freeze &gt; requestments.txt #pip freee的意思是查看当前python安装了哪些库，保存在requestments.txt中 pip download -r requestments.txt -d ./pip_packages #从当前环境的网络中下载requestments.txt中写的包，下载到当前目录下的pip_packages目录中，这时候你会发现，里面有很多依赖，还有一些whl文件 将打包好的离线包放入其他电脑 pip install --no-index --find-links=d:\packages -r requirements.txt # --find-links指定的是包文件的存放地址，-r指定的是txt文件的位置 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a93f93288ef971861bbd7da432bcad27/" rel="bookmark">
			APB3和APB4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容参考：APB协议详解_Ky-CSDN博客_apb协议https://blog.csdn.net/burningCky/article/details/109630018
APB2协议的特点：
低成本低功耗低带宽无流水线所有信号都是时钟上升沿有效进行一次数据传输至少需要两个周期 APB：（APB3比APB2多两个信号，APB4比APB3多两个信号）
信号
描述
P_clk
APB2 时钟。所有信号都是时钟上升沿有效。
P_reset_n
APB2 复位。低电平有效
P_addr
APB2 APB地址总线。最大位宽为32位。
P_sel_x
APB3 选通。APB master会将此信号生成给每个slave。它指示已选择的slave，并且需要进行数据传输。每个slave都有一个P_sel_x信号。
P_enable
APB2 使能。当他为高时，表示数据有效。
P_write
APB2 读写控制。1：写；0：读；
P_wdata
APB2 写数据。Master通过P_wdata将数据写到slave，该总线最大宽度为32位。
P_rdata
APB2 读数据。Master通过P_rdata将数据从slave读回来，最大位宽=32bit
PREADY
APB3 是一个对于slave的准备信号，用于扩展APB的传输；（DUT的输出）
PSLVERRAPB3 是一个错误反馈信号，表示当前传输的数据有误。
PPROTAPB4 PPROT:一种保护信号，可支持APB上的非安全传输和安全传输。
PPROT [0]：0：普通；1：特权。一些master使用它来指示其处理模式。特权处理模式通常在系统内具有更高级别的访问权限。
PPROT [1]：0：安全；1：非安全。这用于需要更大程度区分处理模式的系统中。
PPROT [2]：0：数据；1：指令。该位指示事务是数据访问还是指令访问。此指示仅作为提示，并非在所有情况下都是准确的。
PSTRBAPB4 PSTRB:一个写选通信号，用于在写数据总线上进行稀疏数据传输。
这个信号位宽为4，每一位代表不同的作用，对应于写数据总线的一个字节的有效与否。
无论是读还是写，都是两个周期。在第一个周期，PSEL为高，PENABLE为低，这个时候为data的传输做准备工作；第二个周期里，PSEL和PENABLE同时为高，进行data的传输。
APB2：写数据
APB3：写数据，有等待
相对于APB2无非就是多了个PREADY,也就是说，当PSEL为高，PENABLE为高时，总线会看PREADY是否为高，如果为高，则进行数据传输，如果为低，那么等待其变为高。
当PSEL和PENABLE都为高的时候，PREADY为低，说明slave没有准备好，需要继续等待PREADY拉高。
PSLVERR：当PSEL，PENABLE和PREADY均为高电平时，仅在APB传输的最后一个周期内才认为PSLVERR有效，其他时间不考虑PSLVERR。
PSTRB：写选通信号PSTRB使写数据总线上的稀疏数据传输成为可能。 每个写选通信号对应于写数据总线的一个字节。 当置为高电平时，写选通脉冲指示写数据总线的相应字节通道包含有效信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec74e2a4ee8dc9b2a1a9468c4e3dad83/" rel="bookmark">
			Verdi使用笔记（个人）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选中信号，按H，可以查看信号路径
双击信号：可追踪信号的驱动；
波形区域点击信号，右键有个信号触发路径；
看频率：按鼠标中键，调出第2根线，然后移动到待测区间，测出频率在小窗口上面；
查看周期数：鼠标左键和滚动键可以调出两根指示线，然后移动两根线，选中要查看的区域后，在波形左上角view-signal event report
2021 2 22
搜索总线信号值：首先选中信号变量对应波形，再选中bus value（如地址），再输入相应的值（如c7cc_0008）,再点旁边的搜索箭头；（虚拟机上的寄存器文档，router这里说明了地址范围，后面再加上具体的模块内部地址，即是axi_addr上传输的地址）（基地址目前是按时钟域划分）
十进制显示信号值：在信号名窗口选中信号右键 -&gt; Set Radix -&gt; Decimal
切割信号：选中信号-右键-Bus Operation - Expand as Sub-bus
按“？”键：打开搜索窗口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c76ac48d86f4a523f78d9572b85221a/" rel="bookmark">
			Android QQ 登录接入详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/ 今日科技快讯 /
近日，百度地图发布2022春节出行大数据。迁徙大数据显示，2022年春运迁徙规模较去年农历同期有明显上升。春节期间全国人口迁徙规模日均值为去年农历同期的近两倍。春节前的迁徙规模峰值出现在1月29日（腊月廿七），春节后于2月6日达到峰值。
/ 作者简介 /
本篇文章来自wresource的投稿，文章主要分享了他接入AndroidQQ登录的整个过程和心得，相信会对大家有所帮助！同时也感谢作者贡献的精彩文章。
wresource的博客地址：
https://dreamstudio.blog.csdn.net/
/ 前言 /
由于之前自己项目的账号系统不是非常完善，所以考虑接入QQ这个强大的第三方平台的接入，目前项目暂时使用QQ登录的接口进行前期的测试，这次从搭建到完善花了整整两天时间，不得不吐槽一下QQ互联的官方文档，从界面就可以看出了，好几年没维修了，示例代码也写的不是很清楚，翻了好多源代码和官方的demo，这个demo可以作为辅助参考，官方文档的api失效了可以从里面找相应的替代，但它的代码也太多了，一个demo一万行代码，心累，当时把demo弄到可以运行就花了不少时间，很多api好像是失效了，笔者自己做了一些处理和完善，几乎把sdk功能列表的登录相关的api都尝试了一下，真的相当的坑，正文即将开始，希望这篇文章能够给后来者一些参考和帮助。
/ 环境配置 /
获取应用ID
这个比较简单，直接到QQ互联官网申请一个即可，官网地址。
https://connect.qq.com 申请应用的时候需要注意应用名字不能出现违规词汇，否则可能申请不通过。
应用信息的填写需要当前应用的包名和签名，这个腾讯这边提供了一个获取包名和签名的app供我们开发者使用，下载地址。
https://pub.idqqimg.com/pc/misc/files/20180928/c982037b921543bb937c1cea6e88894f.apk 未通过审核只能使用调试的QQ号进行登录，通过就可以面向全部用户了，以下为审核通过的图片。
官网下载相关的sdk
下载地址
https://tangram-1251316161.file.myqcloud.com/qqconnect/OpenSDK_V3.5.10/opensdk_3510_lite_2022-01-11.zip 推荐直接下载最新版本的，不过着实没看懂最新版本的更新公告，说是修复了retrofit冲突的问题，然后当时新建的项目没有用，结果报错，最后还是加上了，才可以。
jar的引入
将jar放入lib包下，然后在app同级的 build.gradle添加以下代码即完成jar的引用。
dependencies { ... implementation fileTree(dir: 'libs', include: '*.jar') ... } 配置Manifest
在AndroidManifest.xml中的application结点下增加以下的activity和启动QQ应用的声明，这两个activity无需我们在另外创建文件，引入的jar已经处理好了。
&lt;application ... &lt;!--这里的权限为开启网络访问权限和获取网络状态的权限，必须开启，不然无法登录--&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;activity android:name="com.tencent.tauth.AuthActivity" android:exported="true" android:launchMode="singleTask" android:noHistory="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt; &lt;data android:scheme="tencent你的appId" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c76ac48d86f4a523f78d9572b85221a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8679f962bd80ebf094d3be0414ae764b/" rel="bookmark">
			安装Windows系统时磁盘脱机的处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		故事是这样子的，话说有一次给服务器安装Windows操作系统，服务器配置了2块SSD，4块HDD，显然SSD是做系统盘的，HDD是做业务盘的，因此将2块SSD做成一个RAID1,4块HDD做成RAID5，然后开始安装系统，在加载分区时遇到了很尴尬的一幕，SSD组成的RAID1的逻辑盘掉链子处于脱机状态，无法选择在上边安装系统，因此也就无法下一步继续了，如下图所示：
以前倒是遇到过给正常的机子安装新硬盘，安装完后新硬盘处于脱机状态或者装完系统后没有分区的磁盘处于脱机状态的情况，此时只需要在系统的磁盘管理器中右击脱机的磁盘，点击“联机”即可将脱机状态的磁盘拉起。但此时系统都无法安装，上述操作显然很苍白无力！
怀疑1：
是RAID驱动文件加载有问题，然后开始重新在官网下载驱动，重新加载，然鹅并没什么卵用！
怀疑2：
可能是SSD和HDD共存的情况下需要只对SSD创建RAID，安装完系统后再对HDD做RAID，于是乎将HDD盘创建的RAID删除后重新加载分区，然鹅并没什么卵用！
怀疑3：
需要将所有RAID删除，然后只对SSD创建RAID，安装完系统后再对HDD创建RAID，然鹅并没什么卵用！
怀疑4：
镜像文件的问题（但由于使用的镜像文件前不久还在同系列的服务器安装过，因此这个可能性很低！）。
此时已经开始怀疑人生，通过请教大神，大神指点可以尝试用命令行将脱机的磁盘拉起，那么问题来了，命令行在哪里？现在系统安装无法下一步，如何打开命行？如何拉起脱机的磁盘呢？详细步骤如下：
（1）按Shift+F10可调出隐藏的cmd界面，通过命令行手动上线拉起脱机磁盘。
（2）输入：diskpart
（3）diskpart&gt; san
（4）diskpart&gt; san policy=onlineall
（5）diskpart&gt; list disk
（6）diskpart&gt; select disk 1 //选中脱机的磁盘
（7）diskpart&gt; attributes disk clear readonly //已成功清除磁盘属性
（8）diskpart&gt; online disk //使该磁盘联机
（9）diskpart&gt; list disk
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0132ec8cee01c5dd244e1a60fe6448a1/" rel="bookmark">
			@Autowired
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @Autowired原理：作用：注：@Autowired和构造方法 @Autowired @Autowired是用在JavaBean中的注解，通过byType形式，用来给指定的字段或方法注入所需的外部资源
原理： 在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource(是CommonAnnotationBeanPostProcessor后置处理器处理的)或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性
我通俗的理解为：@Autowired是一个自动装配的工具，当这个注解加在某个变量上时，系统自动的去容器里找这个类型的对象，如果容器里只有一个，那个就把容器里的对象注入到该注解指定的变量的位置上（赋值）;如果容器里，这个类型的对象多于一个，则按ByName方式查找；如果容器里没有这个对象，那么会抛出异常。解决方法时，使用required=false
作用： @Autowired有什么作用呢 作为spring核心思想IOC的核心注解，我认为他的主要作用就是引入容器里已有的对象的值（它比new好的一点就是，new是创建新的，@Autowired是拿现有的，所以@Autowired能做到数据共享，而new不行）
spring是一个容器，这个容器里面有各种各样的对象，当人们想用容器里的对象时，去容器里拿现有的对象直接用。
那么什么时候能体现@Autowired的方便性呢？
当一个类的变量要被多个类使用时，且该变量的内容被多个类共享时，这个时候我们的解决办法就是：把这个要被多次使用且数据共享的类放到spring容器中，由spring容器管理它，我们使用@Autowired引入容器里的类
举个例子：
要求实现一个项目要在指定时间发布出去。方案：我首先想到的就是spring的定时任务，那么实现起来的话，我分为任务类（要做什么），任务管理类（任务调度器,添加任务,移除任务），service
在这个例子是怎么体现数据共享的呢？我们往下看 任务管理类中有一个Map存储正在运行的任务（可以理解为线程池的显示） 那我们发布完项目，这个任务应该结束掉（在线程池中移除），所以，我们需要在执行完任务，就把该任务从线程池中移除，那么就是在任务类中引入任务管理类，并做到共享线程池（map） 做法：在任务管理类上加@Component把它放到spring容器中，再任务类中某变量上加入@Autowired引入容器中的对象。
注：@Autowired和构造方法 Java变量的初始化顺序为：静态变量或静态语句块–&gt;实例变量或初始化语句块–&gt;构造方法
声明：构造方法是在@Autowired前执行。
eg:
@Autowired写在构造方法外，他的实际值为null
public class TaskRunnable implements Runnable { private String name; @Autowired private TaskManager taskManager; public TaskRunnable(String name) { this.name = name; } } 这么写才是正确的，当该类有有参构造时，@Autowired要加在构造方法上能引入容器中的对象
public class TaskRunnable implements Runnable { private String name; private TaskManager taskManager; @Autowired public TaskRunnable(String name,TaskManager taskManager) { this.name = name; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0132ec8cee01c5dd244e1a60fe6448a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c958675ca8bed089a8d5a2d9a419c3a6/" rel="bookmark">
			LPDDR5原理简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LPDDR5原理简介
标签： 手机关键接口技术
一、接口简介 1、什么是LPDDR？ 介绍LPDDR之前得先了解什么是DDR？DDR全称为Double Data Rate SDRAM，中文名为“双倍数据率SDRAM”。DDR是在原有的SDRAM的基础上改进而来，严格的说DDR应该叫DDR SDRAM，人们习惯称为DDR。而LPDDR是在DDR的基础上多了前缀LP(Low Power)，它拥有比同代DDR内存更低的功耗和更小的体积。
DDR与SDR区别：传统的SDR SDRAM只能在信号的上升沿进行数据传输，而DDR SDRAM却可以在信号的上升沿和下降沿都进行数据传输，所以DDR内存在每个时钟周期都可以完成两倍于SDRAM的数据传输量，这也是DDR的意义——Double Data Rate，双倍数据速率。
2、DDR，LPDDR，GDDR三者区别？ DDR: 英文全称Double Data Rate Synchronous Dynamic Random Access Memory。它主要应用在普通内存条；
LPDDR: 英文全称Low Power Double Data Rate Synchronous Dynamic Random Access Memory。它主要应用在智能手机，智能手表等对功耗，体积敏感得产品；
GDDR: 英文全称Graphics Double Data Rate Synchronous Dynamic Random Access Memory。主要用于高速图像处理的场合，比如计算机的显卡中，可以简单理解为专门为显卡而做的DDR内存，这种内存与普通DDR相比，拥有更高的时钟频率和更小的发热量。
二、LPDDR5物理接口介绍 美光LPDDR5 Eight-Die,Quad-Channel 引脚定义：
引脚名称功能CK_t/CK_c地址/命令时钟，上升沿/下降沿同时采样，差分时钟输入。CS片选信号，时钟上升沿（下降沿）被采样，用于选择目标DIE。CA[6:0]命令/地址输入。DQ[15:0]数据输入/输出总线WCK[1:0]_t/WCK[1:0]_c写时钟，为差分输入RDQS[1:0]_t/RDQS[1:0]_c读选通信号（读时钟），为差分输出DMI[1:0]数据总线翻转，每byte数据后接一位DMIZQZQ用于校准输出驱动强度。ZQ引脚需使用240Ω电阻连接到VDDQ上。 LPDDR5速率表：
各个引脚速率确定（以BG模式6400Mbps速率举例）：
1、看上表可见为BG模式6400Mbps为表格第一行的模式。
2、数据率为6400Mbps那么DQ=DMI=6400Mbps。
3、数据为双边沿采样，所以读/写时钟速率为数据的一半。WCK=RDQS=1/2DQ=3200MHz。
4、由上表可见WCK：CK=4:1，即CK=1/4WCK=800MHz。(CK速率在LPDDR5中最高就800MHz)
5、地址/命令为双边沿采样，所以地址/命令速率为时钟的两倍。CA=2*CK=1600Mbps。
6、片选信号为单边沿采样，所以片选信号速率与时钟速率一样。CS=CK=800Mbps。
DDR数据带宽、容量计算：
1、DDR数据接口带宽 = 通道带宽 X 通道数 X 数据时钟频率 X 2 / 8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c958675ca8bed089a8d5a2d9a419c3a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f8134a223d81520ee07328049135bde/" rel="bookmark">
			Win10下Linux子系统WSL：访问Windows目录文件夹及批量更改名字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		皆さん、久しぶりですね、お元気ですか？
新年希望大家都开心快乐，健健康康。
好，废话少说，直接切题，最近刚刚学了写Linux的一些命令，因为我的是Windows10系统，众所周知，现在窗户系统提供Linux子系统wsl可以基本一致实现Linux的命令。
于是就想到了这个题目，决定写一下大家一起学习。
首先我们打开wsl，我的要操作的文件夹在g盘，所以我首先要访问到Windows目录文件夹，可通过如下方式：
cd /mnt 这样我们就进入了Windows目录，通过ls -l查看文件列表，我的如下图：
话不多说，直接进入我的目标文件夹：cd g/picture,然后ls -l看看我们的这次的目标文件列表如下：
有70多个呢，名字乱七八糟的，所以我们的目的是把这些图片的名字统一的改成数字序号p1,p2…等，为什么不直接改成123呢，这个等下再说。
确定了目的后，就开始，我们直接建立一个rename.sh文件并打开，如下
nano rename.sh 然后编写如下代码：
#!/bin/bash n=1 g=1 p="p" gif="gif" for file in *.jpg; do name=$(basename "$file" *.) echo mv "$name" "$p$n.jpg" ((n+=1)) done for file in *.gif; do name=$(basename "$file" *.) echo mv "$name" "$gif$g.gif" ((g+=1)) done 简单解释下，就是通过for循环将文件名逐一更改，我们看到有两个for循环，那是因为文件家内有两种格式，我们的for循环是首先遍历jpg格式的文件，然后将其格式前的名字（包括.）统一换成*.，这是为了把名字中空格特殊符号什么的统一去掉，然后通过mv命令重新命名，这里解释下为什么不直接123这样的格式，因为我们的图片有些本身已经是1.jpg的名字了，这时如果for循环遍历的这个文件是其它文件的名字要改为1.jpg的话会把我们这个原本存在的覆盖掉。所以jpg格式的我就改为p1…，而gif格式的就改为gif1,gif2…这样的 。
另外我们在mv前加了个echo，这是因为我们操作更改文件的名字，具有不可撤回性，所以呢我们先通过echo来查看是否像我们期望的那样改掉名字，有点类似python中的print，就是先看看效果。
编辑完成代码后，CTRL+o保存，然后按确认键，然后CTRL+x退出。
然后我们首先通过如下命令赋予这个文件执行的权限：
chmod +x rename.sh 然后执行：
./rename.sh 结果如下：
这正是我们期望的结果，可以看到把所有的文件都如期换成了想要的名字，然后我们在nano rename.sh打开文件，把echo去掉，改后代码如下：
#!/bin/bash n=1 g=1 p="p" gif="gif" for file in *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f8134a223d81520ee07328049135bde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/257f59c5a0ce3548e02345eb9a0f84d4/" rel="bookmark">
			matlab中统计数组中各数字（元素）出现的次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. tabulate 调用MATLAB自带的函数tabulate统计一个数组中各数字（元素）出现的频数、频率
【例1】统计数值型数组中各元素出现的频数、频率。
&gt;&gt; x = [2 2 6 5 2 3 2 4 3 4 3 4 4 4 4 2 2 6 0 4 7 2 5 8 3 1 3 2 5 3 6 2 3 5 4 3 1 4 2 2 2 3 1 5 2 6 3 4 1 2 5]; &gt;&gt; tabulate(x(:)) Value Count Percent 0 1 1.96% 1 4 7.84% 2 14 27.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/257f59c5a0ce3548e02345eb9a0f84d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80b55c0392157bb32196ba30f6ded733/" rel="bookmark">
			DPDK环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、版本的选择 首先要说明的是，对于生产来说DPDK版本不是越高越好，如何选择合适的版本？
1、要选择长期支持的版本LTS（Long Term Support）
2、根据当前开发的系统环境选择
可以在以下文档里从高至低查看不同版本的System Requirements章节，它对kernel、glibc等限制有详细说明。
DPDK
我开发是在CentOS7.3 64位，最后选用dpdk-18.11版本。如果你的软件需要同时在不同系统运行，选对版本后续能省不少事。
二、虚拟机配置要求 我使用vmware虚拟机，调研了几款虚拟机发现在windows下只能vmware能模拟出多队列的网卡，如果有发现其他虚拟机能模拟请给我留言。
1、核心：我配置4个。至少有2个以上核心，方便后续程序做线程孤立和绑定。
2、内存：我一般配置3G，为了配置hugepage，多分点比较好。可根据实际情况配置。
3、网卡：需要支持dpdk，我选择vmnet3，它支持多队列。端口至少2个以上，且要求驱动为dpdk支持的，
三、dpdk的安装 1、下载源码
http://fast.dpdk.org/rel/dpdk-18.11.7.tar.xz
2、设置环境变量（18.11版本不需要）
旧版本安装时需要在dpdk根目录执行t以下命令，如果重新登录需要再执行一次，18.11版本不需要，安装脚本里写好了，这里只是记录以下。
64位系统：
export RTE_SDK=`pwd`
export RTE_TARGET=x86_64-native-linuxapp-gcc
32位系统：
export RTE_SDK=`pwd` export RTE_TARGET=i686-default-linuxapp-gcc
3、利用setup.sh进行配置
cd dpdk-stable-18.11.7/usertools
source ./dpdk-setup.sh
1）编译dpdk
编译完提示以下信息：查资料显示没有指定安装路径，我们只是编译而不是install就不用理会。
2）插入IGB UIO模块
3）设置大页内存
默认设置的是2M的大页内存，这里输入1024，表示申请2G的大页内存。由于虚拟机里只有一个node，这里只需要设置node0
查看配置的大页内存
4）查看网卡/加解密设备信息，这里我们只有网卡信息
若报以下错误，是因为没有安装lspci导致，安装解决：yum install pciutils -y
Traceback (mostrecent call last): File"/root/dpdk-16.07/tools/dpdk-devbind.py", line 576, in &lt;module&gt; main() File"/root/dpdk-16.07/tools/dpdk-devbind.py", line 572, in main get_nic_details() File"/root/dpdk-16.07/tools/dpdk-devbind.py", line 248, inget_nic_details dev_lines =check_output(["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80b55c0392157bb32196ba30f6ded733/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a2c37181926df2fa5d24545fc84161e/" rel="bookmark">
			17 个实用 shell 脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、服务器系统配置初始化 #/bin/bash # 安装系统性能分析工具及其他 yum install gcc make autoconf vim sysstat net-tools iostat iftop iotp wget lrzsz lsof unzip openssh-clients net-tool vim ntpdate -y # 设置时区并同步时间 ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime if ! crontab -l |grep ntpdate &amp;&gt;/dev/null ; then (echo "* 1 * * * ntpdate time.windows.com &gt;/dev/null 2&gt;&amp;1";crontab -l) |crontab fi # 禁用selinux sed -i '/SELINUX/{s/permissive/disabled/}' /etc/selinux/config # 关闭防火墙 if egrep "7.[0-9]" /etc/redhat-release &amp;&gt;/dev/null; then systemctl stop firewalld systemctl disable firewalld elif egrep "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a2c37181926df2fa5d24545fc84161e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df955796d1e136df93961e98983c56cc/" rel="bookmark">
			Python2写csv文件中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 python2最大的坑在于中文编码问题，遇到中文报错首先加u，再各种encode、decode。 当list、tuple、dict里面有中文时，打印出来的是Unicode编码，这个是无解的。 对中文编码纠结的建议尽快换python3吧，python2且用且珍惜！ csv中文乱码 。
前言 python2最大的坑在于中文编码问题，遇到中文报错首先加u，再各种encode、decode。
当list、tuple、dict里面有中文时，打印出来的是Unicode编码，这个是无解的。
对中文编码纠结的建议尽快换python3吧，python2且用且珍惜！
csv中文乱码 1.open打开csv文件，用writer写入带有中文的数据时
writer写入单行writers写入多行 # coding:utf-8 import csv f = open("xieru.csv", 'wb') writer = csv.writer(f) # 需要写入的信息 data = ["客户名称", "行业类型", "客户联系人", "职位", "联系方式", "邮箱","地址"] writer.writerow(data) # 写入单行 # writer.writerows(datas) # 写入多行 f.close() 2.打开csv文件，发现写入的中文乱码了
编码与解码 1.中文乱码问题一直是python2挥之不去的痛，这里先弄清楚乱码原因：
python2本身内部代码的编码有str和unicode两种编码然而文件写入到windows系统时候，windows上的是gb2312编码 所以就导致了乱码问题
2.先把python里面的中文字符串decode成utf-8，再encode为gbk编码
data.decode('utf-8').encode('gbk')
3.如果是读取csv文件的话，就反过来：
data.decode('gbk').encode('utf-8')
解决方案 1.方案一：对字符串转换编码(这个太麻烦了，不推荐)
# coding:utf-8 import csv f = open("xieru1.csv", 'wb') writer = csv.writer(f) # 需要写入的信息 data = ["客户名称", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df955796d1e136df93961e98983c56cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87b19936100c82c4c1df7dd15dae6f73/" rel="bookmark">
			tvm tutorial (1.1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接着上次 tensor_expr_get_started.py 没记录完的部分继续
剩下的代码如下，给出的样例是Nvidia GPU设备端的代码
run_cuda = False if run_cuda: # Change this target to the correct backend for you gpu. For example: cuda (NVIDIA GPUs), # rocm (Radeon GPUS), OpenCL (opencl). tgt_gpu = tvm.target.Target(target="cuda", host="llvm") # Recreate the schedule n = te.var("n") A = te.placeholder((n,), name="A") B = te.placeholder((n,), name="B") C = te.compute(A.shape, lambda i: A[i] + B[i], name="C") s = te.create_schedule(C.op) bx, tx = s[C].split(C.op.axis[0], factor=64) ################################################################################ # Finally we must bind the iteration axis bx and tx to threads in the GPU # compute grid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87b19936100c82c4c1df7dd15dae6f73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b324e63c91346ee8a2bdee03b29eaf6/" rel="bookmark">
			Push模块管理推送消息功能，可以实现在线、离线的消息推送，通过plus.push可获取推送消息管理对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法： addEventListener: 添加推送消息事件监听器clear: 清空所有推送消息createMessage: 创建本地消息getAllMessage: 获取所有推送消息getClientInfo: 获取客户端推送标识信息getClientInfoAsync: 异步获取客户端推送标识信息setAutoNotification: 设置程序是否将消息显示在系统消息中心remove: 删除推送消息 对象： ClientInfo: JSON对象，获取的客户端标识信息PushMessage: JSON对象，推送消息对象MessageOptions: JSON对象，获客户端创建本地消息的参数 回调方法： PushReceiveCallback: 客户端接收到推送消息的回调函数PushClickCallback: 用户点击推送消息事件的回调函数ClientInfoSuccessCallback: 异步获取客户端推送标识信息成功的回调函数ClientInfoErrorCallback: 异步获取客户端推送标识信息失败的回调函数 权限： permissions
&lt;span style="background-color:#333333"&gt;&lt;span style="color:#474747"&gt;&lt;code&gt; &lt;span style="color:#ffffff"&gt;{&lt;/span&gt; &lt;span style="color:#87ceeb"&gt;// ...&lt;/span&gt; &lt;span style="color:#ffa0a0"&gt;"permissions"&lt;/span&gt;&lt;span style="color:#ffffff"&gt;:{&lt;/span&gt; &lt;span style="color:#87ceeb"&gt;// ...&lt;/span&gt; &lt;span style="color:#ffa0a0"&gt;"Push"&lt;/span&gt;&lt;span style="color:#ffffff"&gt;:&lt;/span&gt; &lt;span style="color:#ffffff"&gt;{&lt;/span&gt; &lt;span style="color:#ffa0a0"&gt;"description"&lt;/span&gt;&lt;span style="color:#ffffff"&gt;:&lt;/span&gt; &lt;span style="color:#ffa0a0"&gt;"消息推送"&lt;/span&gt; &lt;span style="color:#ffffff"&gt;}&lt;/span&gt; &lt;span style="color:#ffffff"&gt;}&lt;/span&gt; &lt;span style="color:#ffffff"&gt;}&lt;/span&gt; &lt;/code&gt;&lt;/span&gt;&lt;/span&gt; 属性：
cover: 设定显示推送消息的模式 可取值true或false，true表示推送消息覆盖模式显示，即仅显示最后接收到的推送消息；false表示在系统消息中心显示多条消息。 默认值为ture。
平台支持 Android - 2.2+ (支持)iOS - 4.3+ (不支持) : 不支持覆盖消息，每条信息都在系统消息中心，忽略cover属性值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b324e63c91346ee8a2bdee03b29eaf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3cdeee399d94a82b9c58394771a126b/" rel="bookmark">
			力扣、github网站登不上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能原因：DNS解析错误。
mac上解决方案：
第一种 在hosts上刷新DNS缓存。
1.在ipaddress.com搜索力扣当前ip地址。
2.打开finder，shift+cmd+G，搜索etc/hosts
取消注释#，添加力扣ip地址和网址。
第二种 修改电脑DNS服务器
1.打开设置-&gt;打开连接的网络-&gt;高级设置
-&gt;DNS选项-&gt;添加DNS服务器-&gt;若查找力扣网址，首选233.5.5.5服务器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d92dba3477afd692a2bc0c39f7b83913/" rel="bookmark">
			多个完整设计的单片机、8086、STM32制作教程和资料-转发分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网上收集了接近上千个完整设计的单片机、8086、STM32制作教程和资料-转发分享（涵盖了大部分的毕设课设题目），学习单片机的最好教程，也可以作为帮助大家在做电子课设毕设时有利的帮助，可以从以下百度网盘下载（按照编号下载）。
实例代码：
#include &lt;reg52.h&gt; /* 调用单片机头文件 */ #define uchar unsigned char /* 无符号字符型 宏定义 变量范围0~255 */ #define uint unsigned int /* 无符号整型 宏定义 变量范围0~65535 */ #include &lt;DS18N02.h&gt; #include &lt;intrins.h&gt; #include "eeprom52.h" #define DBPort P0 unsigned char i = 0, timecount = 0, displayOK = 0, rate = 0, rate1 = 0, aa = 0, time1 = 0, flat300ms = 0; unsigned int time[6] = { 0 }; unsigned int oneminte = 0; unsigned int ReadTempDate; unsigned char S_temp_H, S_temp_L, S_heart_H, S_heart_L; unsigned char yemian = 0, biaozhi = 0; sbit K1 = P1 ^ 0; /* 菜单 */ sbit K2 = P1 ^ 1; /* 加 */ sbit K3 = P1 ^ 2; /* 减 */ sbit Buzzer = P1 ^ 7; /* 控制端 */ sbit rs = P2 ^ 5; sbit rw = P2 ^ 6; sbit ep = P2 ^ 7; bit flag = 1; /******************把数据保存到单片机内部eeprom中******************/ void write_eeprom() { SectorErase( 0x2000 ); byte_write( 0x2000, S_heart_H ); byte_write( 0x2001, S_heart_L ); byte_write( 0x2002, S_temp_H ); byte_write( 0x2003, S_temp_L ); byte_write( 0x2060, a_a ); } 资料转自 百度网盘列表https://docs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d92dba3477afd692a2bc0c39f7b83913/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/310d62daeb04d632e74e59543b5bd47f/" rel="bookmark">
			TencentOS Server 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TencentOS Server（又名 Tencent Linux，简称 TS 或 tlinux）是腾讯针对云的场景研发的 Linux 操作系统，提供特定的功能及性能优化，为云服务器实例中的应用程序提供高性能及更加安全可靠的运行环境。TencentOS Server 提供免费使用，在 CentOS（及其他发行版）上开发的应用程序可直接在 TencentOS Server 上运行，用户还可持续获得腾讯云团队的更新维护和技术支持。
适用说明 TencentOS Server 适用于下列场景：
绝大部分云服务器各规格族实例，包括黑石2.0服务器。启动实例时，需要通过用户数据（即 userdata 的方式）将相关操作传递到 cloud-init，以达到在实例启动时进行动态配置的目的。 TencentOS Server 环境说明 用户态环境
TencentOS Server 2用户态软件包保持与最新版 CentOS 7兼容，即 CentOS 7版本的软件包可以直接在 TencentOS Server 2.4 中使用。TencentOS Server 3用户态软件包保持与最新版 RHEL 8兼容，即 RHEL 8版本的软件包可以直接在 TencentOS Server 3.1 中使用。 系统服务与优化配置 系统服务
tlinux-irqaffinity：TencentOS Server 自动中断分配服务。tlinux-bootlocal：TencentOS Server bootlocal 服务，开机自动执行 /etc/rc.d/boot.local。 系统工具
tencent-tools：tos（简称 t）命令，用于系统管理。支持的参数如下： tos version 2.2 Usage: tos TencentOS Server System Management Toolset tos -u|-U| update [rpm_name] Update the system tos -i|-I| install rpm_name install rpms tos -s|-S| show Show the system version tos -c|-C| check [rpm_name] Check the modified rpms tos -f yum | fix yum Fix yum problems tos -f dns | fix dns Fix DNS problems tos -a|-A | analyze Analyze the system performance tos set dns Set DNS tos set irq Set irqaffinity, restart irqaffinity service tos -cu| check-update Check available package updates tos -b|-B| backup [ reboot ] Backup the system online, or reboot to backup tos -r|-R| recover|reinstall Recover or Reinstall the system tos -h|-H| help Show this usage tos -v|-V| version Show the script version 系统配置 pam：密码复杂度增强。/etc/bashrc 修改：优化 bash 显示。/etc/hosts：添加 TENCENT64 及 TENCENT64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/310d62daeb04d632e74e59543b5bd47f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2f8340497ff323d5fcae72b6624ff77/" rel="bookmark">
			8种排序算法(Java实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.简介:
2.性能:
二.具体实现
1.冒泡排序
2.简单选择排序
3.直接插入排序
4.希尔排序(对直接插入的改进)
5.快速排序
6.归并排序
7.基数排序(桶排序的扩展)
8.堆排序
一.排序算法的简单介绍
1.简介: 2.性能: 3.总结和对比
二.具体实现 1.冒泡排序 每次遍历排序都找出一个最大值放在后面 就像冒泡一样 应用了交换的思想
[3, 9, -1, 10, 20]
第1次遍历排序:
[3, -1, 9, 10, 20]
第2次遍历排序:
[-1, 3, 9, 10, 20]
第3次遍历排序:
[-1, 3, 9, 10, 20]
第4次遍历排序:
[-1, 3, 9, 10, 20]
最终排序结果:
[-1, 3, 9, 10, 20]
*所以5个数组进行4次遍历排序就可
*根据上面的遍历我们还发现第三次遍历数组已经有序，无需进行第四次遍历，所以我们可以对这点进行优化 。 也就是如果经历一次遍历排序一次交换也没发生，那么我们就认为这个数组已经有序，直接retuen.
1.1代码实现:
/** * 冒泡排序 * @param arr 进行排序的数组 * @return 排好序的数组 */ public static int[] bubbleSort(int[] arr) { int temp = 0; int count = 0; for (int i = arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2f8340497ff323d5fcae72b6624ff77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8d2c1a7c8e463b64b4098f0b08f2114/" rel="bookmark">
			单片机的分频是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分频就是单片机的时钟频率（也就是晶振的震荡频率） F经过12分频，变换成F/12的频率。
简单的来说就是以整数倍降低频率。
2分频就是分频前的频率除以2；4分频就是分频前的频率除以4…………
比如：如果晶振是12MHz的频率，经过2分频后送给单片机做系统时钟。 那么当前单片机的系统时钟则是12/2=6MHz。
（以上来自网友的回复。仅作记录，不做交流）
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/262/">«</a>
	<span class="pagination__item pagination__item--current">263/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/264/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>