<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea52df1abe6e671c32e8766e793fea8d/" rel="bookmark">
			博客迁移说明 : )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢大家的关注，最近想了一下，还是不用CSDN写博客了吧，原因如下：
1、以前写的小白文太零散了，很多复制粘贴的地方，逻辑性弱，无系统概括，不便于阶段性总结，但不想删比较麻烦
2、博文的质量需要提高一下；
3、受不了广告推送，实在是烦呢 : )
当然偶尔也会写点东西到CSDN看心情吧
至于新博客，将侧重于Java安全，但我也不想写网上写过的东西没意义
个人博客：http://y4tacker.github.io/
顺便分享下个人的Java安全笔记(不解释只是个人笔记)：https://github.com/Y4tacker/JavaSec
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e8b4cbd187e04531854b7868e35d8c3/" rel="bookmark">
			Spring Cloud Alibaba 之 Sentinel 集成限流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Cloud Alibaba 之 Sentinel 集成限流 一、什么是 Sentinel？二、Sentinel 入门三、官方文档四、限流参数与规则1. 限流参数2. 限流规则 三、集成1. 引入依赖2. 配置资源以及规则策略3. 配置超时降级策略4. 策略应用 一、什么是 Sentinel？ Sentinel 是面向分布式服务架构的流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助您保障微服务的稳定性。
二、Sentinel 入门 Sentinel 不算是个复杂的东西，集成起来很容易，但是我们需要理解其中的一些概念性东西。
资源： 资源并不是一个很难理解的东西， 正如它的名字在可以理解为在 Sentinel 中，需要被 Sentinel 所管理不管是需要被限流还是熔断的接口都是资源。规则： 规则即围绕不同的资源来制定不同的控制策略，在开发过程中，我们通过对不同的资源进行分类，从而达到因地制宜的效果。 三、官方文档 Sentinel-QuickStart
四、限流参数与规则 1. 限流参数 Field说明默认值resource资源名，资源名是限流规则的作用对象count限流阈值grade限流阈值类型，QPS 或线程数模式QPS 模式limitApp流控针对的调用来源default，代表不区分调用来源strategy调用关系限流策略：直接、链路、关联根据资源本身（直接）controlBehavior流控效果（直接拒绝 / 排队等待 / 慢启动模式），不支持按调用关系限流直接拒绝 2. 限流规则 拒绝策略： 顾名思义，超出限流的限制就直接抛异常冷启动策略： 通过"冷启动"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。PS：用了下发现同样的超出阈值限制会抛异常，相信绝大部分系统都是应该尽量满足请求通过完成的，哪怕因为峰值要多等会儿，而不是抛异常，所以我选择下面那个策略。匀速启动策略配置： 这个策略可以让你的请求在 1S 内平均的匀速运行。举个栗子，假如定义 QPS=2，那么这个策略会将 1S 平均分为 2 个 500ms，每个 500ms 去运行一个请求。PS：注意配置队列中请求的等待时间，假如设置等待时间最长为 20s，那么你的请求最多可以在队列中等待 20s，期间一有空闲就可以顺序被执行而不是抛异常。默认值只有 500ms，所以一下就超时了，超时的时候就会抛异常。个人觉得这个是最符合绝大多数场景的策略。 三、集成 1. 引入依赖 &lt;!--sentinel--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e8b4cbd187e04531854b7868e35d8c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e7465fb95d5eae629a868aefd6efe55/" rel="bookmark">
			Docker Swarm集群搭建及弹性部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要演示如何通过swarm构建一个集群环境，以及服务的弹性部署。
核心概念 Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排工具，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。
Swarm 由多个 Docker 主机组成，它们以 Swarm 集群模式运行，主要包含 Manager 节点（管理者角色，管理成员和委托任务）和 Worker 节点（工作者角色，运行 Swarm 服务）。这些 Docker 主机有些是 Manager 节点，有些是 Worker 节点，或者同时扮演这两种角色。
Node节点 Swarm 集群由 Manager 节点（管理者角色，管理成员和委托任务）和 Worker 节点（工作者角色，运行 Swarm 服务）组成，每个节点对应着 Swarm 集群中的一个实例。在生产环境进行部署时，会将节点交叉分布式部署在多台物理机或云主机上，而每个节点的名称默认为机器的 hostname。
Manager：负责整个集群的管理工作包括集群配置、服务管理、容器编排等所有跟集群有关的工作，它会选举出一个 leader 来指挥编排任务；Worker：工作节点接收和执行从管理节点分派的任务（Tasks）运行在相应的服务（Services）上。 服务&amp;任务 服务（Service）是一个抽象的概念，是对集群环境中同一类型的任务的集合的统称，是集群系统的中心结构。Swarm 创建服务时，可以为服务定义以下信息等：
服务名称；使用哪个镜像来创建容器；要运行多少个副本；服务的容器要连接到哪个网络上；要映射哪些端口。 任务（Task）包括一个 Docker 容器和在容器中运行的命令，是一个集群的最小单元。
任务与容器是一对一的关系。管理节点根据服务规模中设置的副本数量将任务分配给工作节点。一旦任务被分配到一个节点，便无法移动到另一个节点。它只能在分配的节点上运行或失败。
全局服务（GlobalService）&amp;副本服务（ReplicatedService） Swarm 不只是提供了优秀的高可用性，同时也提供了节点的弹性扩容和缩容的功能。可以通过以下两种类型的 Services 部署实现：
Replicated Services：当服务需要动态扩缩容时，只需通过 scale 参数或者 --replicas n 参数指定运行相同任务的数量，即可复制出新的副本，将一系列复制任务分发至各节点当中，这种操作便称之为副本服务（Replicate）。Global Services：我们也可以通过 --mode global 参数将服务分发至全部节点之上，这种操作我们称之为全局服务（Global）。在每个节点上运行一个相同的任务，不需要预先指定任务的数量，每增加一个节点到 Swarm 中，协调器就会创建一个任务，然后调度器把任务分配给新节点。 下图用黄色表示拥有三个副本服务 Replicated Service，用灰色表示拥有一个全局服务 Global Service。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e7465fb95d5eae629a868aefd6efe55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59a8b717837a508b88a78730a9fd09cd/" rel="bookmark">
			全面&amp;详细的面试指南：计算机网络篇 (附答案)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试考察点 网络基础TCP / UDP协议HTTP协议Socket 具体内容如下：
网络基础 问题1：计算机网络的体系结构是什么？问题2：请描述在浏览器中输入url地址 -&gt;&gt; 显示主页的过程问题3：请说出IP地址的分类问题4：请描述ICMP报文问题5：请描述Ping的整个过程问题6：路由器与交换机区别问题7：Cookie 与 Session的区别 问题1：计算机网络的体系结构是什么？ 计算机网络体系结构分为3种：OSI体系结构、TCP / IP体系结构、五层体系结构。
问题2：请描述在浏览器中输入url地址 -&gt;&gt; 显示主页的过程 类似问题：打开一个网页，整个过程会使用哪些协议
问题3：请说出IP地址的分类 传统的IP地址是分类的地址，分为A，B，C，D，E五类
区别在于网络号 &amp; 主机号占的字节数不同
特别注意：在各类IP地址中，有一些IP地址用于特殊用途，不能用于做主机IP地址
问题4：请描述ICMP报文 问题5：请描述Ping的整个过程 先了解一下Ping是什么
Ping过程如下：假设有两台主机：
（目的主机）PC1：IP = 192.168.1.1（源主机）PC2：IP = 192.168.1.2 问题6：路由器与交换机区别 问题7：Cookie 与 Session的区别 二者简介
二者区别 &amp; 对比
TCP / UDP协议 1. TCP协议 问题1：请描述TCP协议的特点问题2：请描述TCP协议的数据包格式问题3：请描述3次握手、4次挥手的整个过程问题4：请描述TCP协议中的滑动窗口机制（包括回退N针协议）问题5：TCP协议的拥塞控制问题6：TCP协议的流量控制 上述问题的答案，请看文章：TCP / IP协议：这是一份全面 &amp; 详细 的TCP协议攻略
2. UDP协议 问题1：请描述UDP协议的特点问题2：请描述UDP协议的数据包格式问题3：请说明TCP协议与UDP协议的区别 问题1：请描述UDP协议的特点 无连接的、不可靠的、面向报文、无拥塞控制，具体介绍如下：
问题2：请描述UDP协议的数据包格式 UDP的报文段共有2个字段：数据字段 &amp; 首部字段下面主要介绍首部（8字节、4个字段） 问题3：请说明TCP协议与UDP协议的区别 HTTP协议 问题1：请描述HTTP协议的请求报文格式问题2：请描述HTTP协议的响应报文格式 &amp; 响应码问题3：请说明Http1.1、Http1.0的区别问题4：请说明Http、Https区别问题5：请说明处理长连接的方式 上述问题的答案，请看文章：这是一份全面&amp; 详细 HTTP知识讲解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59a8b717837a508b88a78730a9fd09cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dae8bf80a9981f964b3f001b6382aeb/" rel="bookmark">
			Docker Swarm网络通讯过程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Overlay网络介绍
什么是Overlay网络？
Overlay 网络的基本架构组成
Overlay 网络传输的基本规则
Overlay 网络的技术标准
Overlay网络解决的问题
解决了L2的空间局限性
解决了网络规模受限的问题
解决了网络隔离问题
Overlay的缺陷
Swarm集群通讯过程讲解
网络名词介绍
服务样例
Docker Swarm自带网络
当前节点如何访问容器内服务
跨机器访问（同一集群下任意机器可以访问某台机器上的服务）
本文主要结合一个部署了nginx服务的swarm集群案例来分析其网络通讯的整个过程。
在分析整个网络通讯过程之前，首先得对overlay网络有一定的认识。
Overlay网络介绍 什么是Overlay网络？ Overlay 网络的基本架构组成 Overlay 网络技术是指在传统 网络架构 之上 叠加的虚拟化技术模式 。也就是说它是依托于传统网络架构的前提条件下， 实现 了 应用 与其虚拟网络的捆绑而忽略底层物理网络的传输模式及技术 。简而言之，就是overlay在L2(数据链路层)网络互通的前提下，基于L3(网络层)实现了虚拟化网络。在该层网络环境下，可以为不同容器分配固定的局域网ip，并通过该ip进行通讯交互。
要了解 Overlay 网络架构体系，首先我们需要知道它的组成架构及元素，具体如下图所示
这里可以看到，凌驾于物理通讯层面之上构建了一层虚拟化网络，通过逻辑抽象的方式与物理网络上的边缘设备建立了一套虚拟的传输通道。
那么如何基于这个通道传输数据到执行容器呢？
在建立虚拟网络通道时，还定义了相应的传输报文协议，应用传输的数据报文必须以虚拟网络可以识别的数据报文为基础进行数据报文的发送和传输，同时必须遵照虚拟网络当中的通道控制标准来传输。
但是报文的物理传输过程我们又不得不依靠传统物理网络来实现，这样的话就涉及到报文的封装和解封、逻辑通道的维护、数据的逻辑转发和物理转发等问题。这就涉及到Overlay 网络的三类核心元素：
边缘设备：与虚拟网络直接关联的网络设备，数据报文的封装/解封场所，同时它也是形成虚拟网络的物理节点，如图中所示的物理交换机（必须是支持Overlay协议的交换机）。控制平面：框架当中的虚拟实体，负责虚拟网络传输当中的服务发现、地址通告和映射、虚拟网络通道建立和维护等，如图中虚拟层当中的控制流。数据平面：框架当中的虚拟实体，主要负责数据报文在虚拟层的转发，如图中虚拟层的数据流。 Overlay 网络传输的基本规则 传统网络在数据传输的时候，遵循的基本规则就是网络的七层模型。也就是说数据需要经过源的封包和目的端的解包过程，封包的时候是从应用层信息逐步封装到物理层，解包的时候是从物理层分解到应用层。在物理网络环境当中的基本寻址规则是靠 IP地址信息和MAC地址信息来进行路由转发。那么在Overlay网络当中，它也是会遵循这一基本规则，但是区别在哪里呢？
首先我们来看Overlay网络的边缘设备ABC三个点，这三个点是支撑Overlay虚拟网络的核心设备，我们称之为VTEP。服务器的数据包在经过这些边缘设备的时候，会对数据包进行二次封装，会把发送端VTEP和目的端VTEP的地址或标识信息封装到数据包，然后通过VTEP的控制平面将数据在两个VTEP之间完成传输，然后再目的端的VTEP上将数据包再进行解封，最终发送到目的服务器上。这里大家可能会有几个问题：
如果是L3的传输，这么做不是多此一举么？如果是L2的传输，源端VTEP如何知道目的MAC、IP对应的VTEP信息？VTEP之间的传输不也得依赖物理网络么？它是如何从源端传递到目的端的？ 首先，针对第一个问题，如果是L3的传输，这么做确实有些多此一举，所以源端VTEP会判断是否是真实的L3传输，如果是的话，那么可以抛开VTEP信息，按照传统方式传输。
接着，针对第二个问题，所有VTEP节点所辖设备的MAC信息都会在VTEP上有保留，同时其他VTEP上的MAC地址映射信息也会相互同步过来，所以一旦获取数据包中目的地址信息，VTEP就可以判断目的地属于哪一个VTEP管辖范围，然后就可以通过控制器转发。也就是说，VTEP之间会广播同步支持VTEP报文的设备之间的ip和mac地址
最后，从一个VTEP到另外VTEP的传输，完全是靠着VTEP本身的IP、MAC地址信息来进行传输。
由此可见，无论是L2还是L3的传输，均涉及到查表转发、报文的解封装和封装操作。从转发效率和执行性能来看，都只能在物理网络设备（Overlay边缘设备）上实现，并且传统设备无法支持，必须通过新的硬件形式来实现。
Overlay 网络的技术标准 目前在 Overlay 技术领域有如下三大技术路线正在讨论：
(1). VXLAN
VXLAN是将以太网报文封装在UDP传输层上的一种隧道转发模式。为了使VXLAN充分利用承载网络路由的均衡性，VXLAN通过将原始以太网数据头(MAC、IP、四层端口号等)的HASH值作为UDP的号；采用24比特标识L2网络分段标识，称为VNI(VXLAN Network Identifier)；未知目的、广播、组播等网络流量均被封装为组播转发，物理网络要求支持任意源组播(ASM)。
(2). NVGRE
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dae8bf80a9981f964b3f001b6382aeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eeeb963be72de748a2f5ea77ddca507/" rel="bookmark">
			prometheus常用表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		prometheus常用表达式 ##1. 系统使用率相关
1.1 内存使用率： 内存的使用率 = (所有非空闲状态CPU使用时间总和 )/(所有状态CPU时间总和)
(1 - (node_memory_MemAvailable_bytes{job=~"prometheus"} / (node_memory_MemTotal_bytes{job=~"prometheus"})))* 100 1.2 cpu使用率 (1 - avg(irate(node_cpu_seconds_total{job=~"prometheus",mode="idle"}[5m])) by (instance)) * 100 cpu总核数 sum(count(node_cpu_seconds_total{instance=~"$node", mode='system'}) by (cpu,instance)) by(instance) 1.3 系统使用率 avg(irate(node_cpu_seconds_total{instance=~"$node",mode="system"}[1m])) by (instance) *100 1.4 用户使用率 avg(irate(node_cpu_seconds_total{instance=~"$node",mode="user"}[1m])) by (instance) *100 1.5. 磁盘io使用率 avg(irate(node_cpu_seconds_total{instance=~"$node",mode="iowait"}[1m])) by (instance) *100 1.6. 总使用率 (1 - avg(irate(node_cpu_seconds_total{instance=~"$node",mode="idle"}[1m])) by (instance))*100 2. 内存相关： 2.1 总内存： node_memory_MemTotal_bytes{instance=~"$node”} 2.2 已用内存 node_memory_MemTotal_bytes{instance=~"$node"} - node_memory_MemAvailable_bytes{instance=~"$node"} 2.3 可用内存 node_memory_MemAvailable_bytes{instance=~"$node"} 3. 流量相关 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eeeb963be72de748a2f5ea77ddca507/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19de7ec6dcce1db4b5cac267682e5b56/" rel="bookmark">
			移动硬盘或其他USB设备如何连接到虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动硬盘连接到VMware虚拟机（Mac） 在macOS 下，我的Windows系统安装在VMware中，那么如何将移动硬盘或其他USB设备连接到虚拟机呢？
1.如果此时虚拟机正在运行—— 我们插入移动硬盘，会出现如下弹窗
直接选择连接到Windows即可
2.如果已经将硬盘插入（就是已经连接到Mac系统上的），再打开虚拟机—— 这时在Windows里面是没有移动硬盘的，我们只需点击虚拟机-&gt;设置-&gt;USB和蓝牙，
将对应的硬盘勾选上即可
然后就可以在Windows里找到啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a13d592d2780fa72b53ba83cb4422d6/" rel="bookmark">
			Python零基础入门之第一章（一、基本输入和输出）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 Python基础语法（一、基本输入和输出） 很喜欢《傅雷家书》中的一句话“没有吃够苦头绝不能有好成绩”，希望大家可以一起坚持，最后看到“好成绩”的那一刻，方可知晓苦尽后的那一份甜。
目录简介 一 、基本输入和输出
二、注释 （单行、多行）
三、规范（代码缩进、编写规范、命名规范）
四、保留字与标识符
五、变量
六、基本数据类型
七、运算符 (算数运算符、赋值运算符、比较/关系运算符、
逻辑运算符、位运算符)
一 、基本输入和输出 计算机最基本的操作就是输入输出，比如我们的“麦克风、键盘、鼠标”就是我们的输入设备，比如我们的“打印机、显示屏、音响”就是我们的输出设备，输入设备通过计算机进行一系列解码处理后将数据在输出设备上呈现。
1.输出函数 print()
Python的内置函数print()函数可以将结果数据显示在控制台上，也可以显示在IDLE上。
语法格式：
print(输出内容)
(1)输出数字
print(6) (2)输出变量
s1 = 1 print(s1) (3)输出字符串（字符串需要用引号括起来）
print("我是字符串") (4)输出包含运算符的表达式
print(6*7) s1=1 s2=2 print(s1+s2) (5)关于换行
在Python中，一条print()打印后会换一次行，如果要一次输出多个不换行数据，可以将内容一并写在括号内，用英文逗号隔开。
s3 = "越努力" s4 = "越幸运" s5 = "加油" print(s3,s4,s5) (6)输出ASCII码（美国信息标准交换码）
输出小写字母’a’
print('a') #方法一 print(chr(97))#方法二 (7)输出内容到指定文件中
#输出"我最牛"到 C:\test.txt 中 fp = open(r'C:\test.txt','a+')	#打开文件 print("成功啦",file = fp)	#输出到文件中 fp.close()	#关闭文件 #运行后会在D盘生成一个名为test.txt的文件，里面写“成功啦” 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a13d592d2780fa72b53ba83cb4422d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0afcd7369dd60f3d2565fedbd779563/" rel="bookmark">
			获取百度地图开发平台的key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		申请百度地图key
进入百度地图开发平台 webapi | 百度地图API SDK (baidu.com)https://lbsyun.baidu.com/index.php?title=webapi/traffic
登录百度地图（如果有百度的账号，可以用百度的账号登录，没有可以申请一个）
进入开发者验证界面（根据要求填写就OK）
开发者认证成功，界面自动跳转回第一张图片，然后点击“控制台”，进入下面界面
点击右边目录里面的“应用管理”，出现子目录“我的应用”，点击“我的应用”，进入到下面的界面：
点击创建应用
应用名称可以随便写
应用类型选择服务器
IP 如果你只是想自己用的话，可以只写自己电脑的IP，但是图方便的话，直接写0.0.0.0/0，填写好之后直接提交就OK了，然后你就得到百度地图的AK
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/431b4c7223a6f0bad49443dc6bc0f781/" rel="bookmark">
			awk命令基本用法（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：awk文本过滤的基本用法
1）基本操作方法
格式：awk [选项] '[条件]{指令}' 文件 其中，print 是最常用的编辑指令；多条编辑指令，用分号分隔；
Awk过滤数据时支持仅打印某一列，如第2列、第5列等；
处理文本时，若未指定分隔符，则默认将空格、制表符等作为分隔符；
直接过滤文件内容：
[root@svr5 ~]# cat test.txt hello the world welcome to beijing [root@svr5 ~]# awk '{print $1,$3}' test.txt //打印文档第1列和第3列 hello world welcome beijing 结合管道过滤命令输出：
[root@svr5 ~]# df -h | awk '{print $4}' //打印磁盘的剩余空间 2）选项 -F 可指定分隔符
输出passwd文件中以分号分隔的第1、7个字段，显示的不同字段之间以逗号隔开，操作如下：
[root@svr5 ~]# awk -F: '{print $1,$7}' /etc/passwd root /bin/bash bin /sbin/nologin daemon /sbin/nologin adm /sbin/nologin … … awk还识别多种单个的字符，比如以“:”或“/”分隔，输出第1、10个字段：
[root@svr5 ~]# awk -F [:/] '{print $1,$10}' /etc/passwd root bash bin nologin daemon nologin adm sbin … … awk常用内置变量：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/431b4c7223a6f0bad49443dc6bc0f781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc2cb01dc4857d109133eb12a4e06895/" rel="bookmark">
			Ubuntu 扩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前ubuntu空间不够想进行扩容，网上教程都是dos命令形式特别复杂改这改那
后来找到一个可视化分区管理工具，可以进行扩容 gparted
大致流程就是先格式化出一片空间，然后通过gparted把这个空间和其它分区合并，再把合并后的分区格式化一部分出来（这一步最神，格式化出来的分区可反正原来分区之上，也可放在之下，这就相当于可以通过合并再格式化的操作进行分区的移动），把这个空间最后移动到想要扩展分区的上面或下面，然后扩展就可以了
我遇到过一个问题就是再u盘启动里能够移动，但最后一不给我的/home扩展失败一直报错，后来我在系统启动里能够扩展，解决就好，做此纪录
gparted 扩容1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f2d0136fddb24eac477fe5e3b88fdf0/" rel="bookmark">
			解决：“[INS-06006] Passwordless SSH connectivity not set up” 报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装完RAC时，在安装Oracle，rac1与rac2互信时，遇到[INS-06006] Passwordless SSH connectivity not set up between the following node(s)。 在执行Setup时成功，在操作系统上已经可以免密登陆，但是Test不过，导致下面的步骤无法进行。
解决办法：发现问题在于虚拟机自带的虚拟网卡virbr0，将虚拟网卡删除掉，1、ifconfig virbr0 down 2、brctl delbr virbr0 3、systemctl disable libvirtd 4、重启虚拟机 5、将原来的/home/oracle/.ssh文件删除，重新Setup,Test即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14b636018ce4cb5237215ee81117f6d6/" rel="bookmark">
			UE4 设置相机裁剪距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		控制台输入 r.SetNearClipPlane 数值
例:r.SetNearClipPlane 200
或者：在Project Setting中，搜索：“near clip plane”，修改为更小的值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c468e0dc4fbbd5ddf0903b54cc6a30/" rel="bookmark">
			Qt 线程中QThread的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Qt 线程中QThread的使用1. 线程类 QThread1.1 常用共用成员函数1.2 信号槽1.3 静态函数1.4 任务处理函数 2. 使用方式 12.2 示例代码3. 使用方式 23.1 操作步骤3.2 示例代码 Qt 线程中QThread的使用 在进行桌面应用程序开发的时候， 假设应用程序在某些情况下需要处理比较复杂的逻辑， 如果只有一个线程去处理，就会导致窗口卡顿，无法处理用户的相关操作。这种情况下就需要使用多线程，其中一个线程处理窗口事件，其他线程进行逻辑运算，多个线程各司其职，不仅可以提高用户体验还可以提升程序的执行效率。
在 qt 中使用了多线程，有些事项是需要额外注意的：
默认的线程在Qt中称之为窗口线程，也叫主线程，负责窗口事件处理或者窗口控件数据的更新子线程负责后台的业务逻辑处理，子线程中不能对窗口对象做任何操作，这些事情需要交给窗口线程处理主线程和子线程之间如果要进行数据的传递，需要使用Qt中的信号槽机制 1. 线程类 QThread Qt 中提供了一个线程类，通过这个类就可以创建子线程了，Qt 中一共提供了两种创建子线程的方式，后边会依次介绍其使用方式。先来看一下这个类中提供的一些常用 API 函数：
1.1 常用共用成员函数 // QThread 类常用 API // 构造函数 QThread::QThread(QObject *parent = Q_NULLPTR); // 判断线程中的任务是不是处理完毕了 bool QThread::isFinished() const; // 判断子线程是不是在执行任务 bool QThread::isRunning() const; // Qt中的线程可以设置优先级 // 得到当前线程的优先级 Priority QThread::priority() const; void QThread::setPriority(Priority priority); 优先级: QThread::IdlePriority --&gt; 最低的优先级 QThread::LowestPriority QThread::LowPriority QThread::NormalPriority QThread::HighPriority QThread::HighestPriority QThread::TimeCriticalPriority --&gt; 最高的优先级 QThread::InheritPriority --&gt; 子线程和其父线程的优先级相同, 默认是这个 // 退出线程, 停止底层的事件循环 // 退出线程的工作函数 void QThread::exit(int returnCode = 0); // 调用线程退出函数之后, 线程不会马上退出因为当前任务有可能还没有完成, 调回用这个函数是 // 等待任务完成, 然后退出线程, 一般情况下会在 exit() 后边调用这个函数 bool QThread::wait(unsigned long time = ULONG_MAX); 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5c468e0dc4fbbd5ddf0903b54cc6a30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/873eefa4b4e0ebe4a42b5001d56469af/" rel="bookmark">
			docker开放端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考了文章&lt;win10 Docker 创建Centos7 并使用xshell成功连接&gt;实现了xsheel连接docker，但是docker中的端口在外部不能直接访问。后来搜到简书上的文章&lt;Mac下 Docker 动态添加端口&gt;，但是在"进入screen"步骤失败，一直报错"screen is terminating"，后来参考菜鸟教程上的&lt;Docker commit 命令&gt;，先"docker commit :从容器创建一个新的镜像"，然后执行"docker run ：创建一个新的容器并运行一个命令"，注意"使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。(docker run -it nginx:latest /bin/bash)"，在创建新容器时候用"-p 50001:22 -p 5002:80"多开放了一个端口。
依据docker file来build镜像的时候，ARG指令定义参数，但是RUN指令去echo的时候总是输出${xxx}，而非参数的实际值。然后关键字"docker ARG echo"搜到这条网页，明确说:“First: Make sure, your ARG comes after your FROM；Second: As you can see here, variables won’t be interpretad inside ‘’, so use “” instead.”。
编译boost的时候参考了知乎上的文章&lt;Boost编译与使用&gt;，注意参数的配置：“stage时使用stagedir，install时使用prefix”。本地编译的时候，只是将修改为toolset=msvc-14.2，因为电脑安装的是vs2019版本，而且install的时候–prefix="C:\Boost"安装到c盘下。然后进入到doc\html\boost_asio\example\cpp11目录下，调试测试asio程序。
在编译FreeRDP的时候，CMake构建工程时候报错"CMake Error Could NOT find OPENSSL"，找到stackoverflow上的文章，设置路径即可(OPENSSL_ROOT_DIR = C:/OpenSSL-Win32)，然后在文件CMakeLists.txt里参照设置"set(OPENSSL_ROOT_DIR ${CMAKE_SOURCE_DIR}/deps)"，注意是OpenSSL的根目录，所以一开始路径中加了include，虽然说找到了OpenSSL的版本但还是报错，去掉include就可以了。
想编译ffmpeg，然后先看了用命令可以正常播放视频流的ffmpeg版本，然后就依据参数进行configure，结果报错"ERROR: gnutls not found using pkg-config"，然后搜到csdn文章说执行"sudo apt-get install libunistring-dev"，评论区里说执行"sudo apt-get install libgnutls-dev"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/873eefa4b4e0ebe4a42b5001d56469af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea147cf917c9a0cef703b4211c857cfa/" rel="bookmark">
			2022.3.22 双向链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 双向链表
与单链表相比，双向链表有两个指针域，既可以保存右边节点的地址(后继)，也可以保存左边的节点地址(前驱)。
2. 双向链表图
其中：next指针域，保存下一个节点的地址(后继)， prior指针域， 保存上一个节点的地址(前驱)
3. 双向链表可执行函数
注意：头插：① 插入新节点时，一般情况下，需要修改4给我指针域：自身的next和prior；上一个节点的next；下一个节点的prior；如
调整规则：③④②①
第一次：先修改pnewnode自身的next域和prior域
第二次：再修改后一个节点的前驱
第三次：最后修改前一个节点的后继
代码为：
pnewnode-&gt;next=plist-&gt;next;
pnewnode-&gt;prior=plist;
plist-&gt;next-&gt;prior=pnewnode;
plist-&gt;next=pnewnode;
注意：如果是给空的双向链表进行头插，那么上述第三行代码不一定能实现，要特殊处理、
4. 代码
Dlist.h文件
#pragma once //双向链表结构体设计 typedef int ELEM_TYPE; typedef struct Dlist { ELEM_TYPE data; //数据域 保存有效值 struct Dlist* next; //指针域 保存下一个节点的地址(后继) struct Dlist* prior; //指针域 保存上一个节点的地址(前驱) }Dlist,*PDlist; //双向链表可执行函数声明 //初始化 void Init_dlist(struct Dlist* plist); //购买新节点 struct Dlist* Buynewnode(ELEM_TYPE val); //头插 bool Insert_head(PDlist plist, ELEM_TYPE val); //尾插 bool Insert_tail(PDlist plist, ELEM_TYPE val); //按位置插 bool Insert_pos(PDlist plist, int pos, ELEM_TYPE val); //头删 bool Del_head(PDlist plist ); //尾删 bool Del_tail(PDlist plist); //按位置删除 bool Del_pos(PDlist plist, int pos); //按值删 bool Del_val(PDlist plist, ELEM_TYPE val); //查找 （如果值重复，返回第一个值的下标） struct Dlist* Search(PDlist plist, ELEM_TYPE val); //判空 bool IsEmpty(PDlist plist); //判满(链表不用，因为要用malloc) //获取有效长度 int GetLength(PDlist plist); //清空 void Clear(PDlist plist);//链表里面的清空直接调用销毁就可以 //销毁1 void Destroy(PDlist plist); //销毁2 void Destroy2(PDlist plist); //打印 void Show(PDlist plist); Dlist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea147cf917c9a0cef703b4211c857cfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e085e3582e965bb2210cc4024bce1d4/" rel="bookmark">
			Anaconda/pip 更换阿里源，助力 conda create -n 虚拟环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Anaconda/pip 更换为阿里源，助力 conda create -n 虚拟环境搭建 一、问题概述： 由于网络和时间的限制，很多的 conda 源，如 清华源，中科大源都需要想办法才能创建好虚拟环境（如本人发现的将清华源中的 https:// 改为 http:// 之后效果好很多），但这些源要么在前几次创建虚拟环境时奏效，时间长了仍然不管用。
二、解决方法
目前本人在用的 pip 源和 conda 源都是采用阿里源，速度很快，跑满带宽没问题。
三、步骤
ubuntu 系统：
ctrl + alt + T 打开终端（Terminal），按条复制粘贴回车下列命令： conda config --add channels http://mirrors.aliyun.com/anaconda/pkgs/main conda config --add channels http://mirrors.aliyun.com/anaconda/pkgs/r conda config --add channels http://mirrors.aliyun.com/anaconda/pkgs/msys2 conda config --set show_channel_urls yes 此时你会发现在 Home 目录下，多了一个隐藏文件 (按 ctrl + H 显示) .condar 文件，双击打开，可以看到：
ssl_verify: true # 是否信任当前网址, 有/无这个都可 channels: - http://mirrors.aliyun.com/anaconda/pkgs/main - http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e085e3582e965bb2210cc4024bce1d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d618b5448699d52c8862a62cae7df5/" rel="bookmark">
			CSS居中——水平居中、垂直居中方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		水平居中 1、行内或类行内元素（如文本、链接） 在块级父元素中用CSS样式实现行内元素水平居中，只需要设置：text-align: center;
这种方法可以让 inline / inline-block / inline-table / flex 等类型的元素实现居中。
效果图：
代码：
&lt;style&gt; body{ background-color: coral; } #div1,#div2{ width: 400px; height: 100px; text-align: center; margin: 20px 0; padding: 20px; background-color: white; } #div2 a{ text-decoration: none; color: white; padding: 3px 8px; border-radius: 5px; background-color: cornflowerblue; } &lt;/style&gt; &lt;body&gt; &lt;div id="div1"&gt; 这是一段简单的文字，水平居中 &lt;/div&gt; &lt;div id="div2"&gt; &lt;a href="#"&gt;hyperlink1&lt;/a&gt; &lt;a href="#"&gt;hyperlink2&lt;/a&gt; &lt;a href="#"&gt;hyperlink3&lt;/a&gt; &lt;a href="#"&gt;hyperlink4&lt;/a&gt; &lt;/div&gt; &lt;/body&gt; 2、子盒子已知宽度 效果图​​​​​​​ html代码 &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09d618b5448699d52c8862a62cae7df5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11474446025410c23dbc5d2d72322c3a/" rel="bookmark">
			React打断点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码中写入：debugger；即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb403087ec8b5e4e510b27c7cac5cfa5/" rel="bookmark">
			STM32CubeMX使用(三)之DMA使用SPI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、概述二、Pinout&amp;Configuration2.1 选择端口2.2 开启DMA中断 三、测试SPI四、问题记录4.1 初始化顺序4.2 CS拉高 一、概述 这篇文章简单记录下SPI的使用。
二、Pinout&amp;Configuration 2.1 选择端口 选择要使用的SPI，对应的PIN脚会自动初始化为SPI模式：
查看原理图，可以看到实际使用的管脚与默认不符：
回到STM32Cube中，直接在使用的管脚上选择模式即可。根据需要命名管脚：
设置SPI参数：
2.2 开启DMA中断 进入DMA外设，添加DMA设置：
这里需要设置两个通道：
设置完成generate code即可。
三、测试SPI 进入keil编译测试，发现始终不为ready状态：
我选用的芯片是STM32G0B1RC，有另一工程使用了STM32G070CB。对比了cube中的设置，也直接对比了代码，完全一样的。这就很疑惑。
搜索了一下，不少博客提到DMA的channel是有指向性的，但图片多是出自F1系列参考手册：
在G0参考手册中并没有找到这个图。按照F1的图修改了channel，依然无效。
查看官方的demo例程，查看方法在STM32 HAL库手册获取和查阅方法以及查看官方例程一文中。发现demo中DMA设置如下
从这里看，channel使用还是与F1的图是相对应的。
将demo程序的管脚进行了修改，与实际硬件相符合，发现SPI可以正常运行。这解决起来就有希望了。
四、问题记录 4.1 初始化顺序 一定要先MX_DMA_Init，然后再MX_SPI1_Init。Cube生成初始化的顺序可能需要手动调整。
4.2 CS拉高 //2022.03.21
调试一国产单片机，发现flash的ID读取为01ff，而使用之前程序测试为C817。
调试过程中发现，连续两次初始化，则第二次的ID是正确的。
最终确定，是初始化的时候，初始化IO后，应该先拉高CS，然后再初始化SPI。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7817b032679fbf4aae34cc96e9b0d62f/" rel="bookmark">
			Mybatis基本原理与使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.JDBC的缺陷是什么？
1.代码冗余。加载驱动，创建连接对象，数据库操作对象，关闭对象等操作对应每个数据库操作都是一样的。
2.对应ResultSet结果集，我们要遍历他然后手工创建Java对象装入集合，比较麻烦。
3.数据库操作和业务代码混合。
2.Mybatis是什么？为什么要放弃JDBC而使用Mybatis？
Mybatis可以看做增强版jdbc，底层也是用jdbc操作数据库但Mybatis帮我们减轻了开发的复旦。不需要我们重复编写创建Connection，Statement，PreparedStatement，ResultSet对象的代码。不需我们关注这些对象的关闭，自动帮我们关闭。还有自动将ResultSet中的记录封装成java对象的集合返回给我们。让开发者专注于SQL语句的编写。
3.传统Dao方式使用Mybatis操作数据库的基本步骤（未使用动态代理为我们创建Dao接口实现类对象）
1.加入依赖：mybatis依赖，数据库驱动。
2.创建Dao接口，定义操作数据库的方法。
3.创建Dao接口的同名Sql映射文件（Mapper文件）。
4.创建Dao接口实现类：方法中获得SqlSession对象操作数据库。
5.创建主配置文件：配置数据库数据源，mapper文件的位置等。
public interface StudentDao { List&lt;Student&gt; findAll(); } &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.zhaojisu.dao.StudentDao"&gt; &lt;select id="findAll" resultType="com.zhaojisu.entity.Student"&gt; select name,age from student; &lt;/select&gt; &lt;/mapper&gt; public class StudentDaoImpl implements StudentDao { @Override public List&lt;Student&gt; findAll() { String path="mybatis.xml"; InputStream stream = Thread.currentThread().getContextClassLoader().getResourceAsStream(path); SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(stream); SqlSession sqlSession = factory.openSession(); List&lt;Student&gt; list = sqlSession.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7817b032679fbf4aae34cc96e9b0d62f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30ef58fd04c99eff081e03afdb3827db/" rel="bookmark">
			shell脚本-批量gbk转utf-8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 背景代码碰到的问题 背景 原因很简单，当初工程拆分，把老代码的gbk文件原封不动的挪到了新的工程，gradle编译已经指定了options.encoding = “UTF-8” 但是还是会出现gbk乱码导致编译不成功。只怪自己太菜不会用gradle解决，只能退而求其次用shell脚本进行gbk转utf-8.
代码 在#!/bin/sh isEnc() { local temp=`iconv -f $2 $1 1&gt;/dev/null 2&gt;/dev/null &amp;&amp; echo 'true'`; echo $temp if [ "$temp" = 'true' ]; then return 0; fi; return -1; } echo "h.sh directory c" echo "h.sh directory h" for file in `find $1 -name "*.$2"`; do if $(isEnc $file gbk); then echo convering : $file iconv -f GBK -t utf-8 $file &gt; $file.t mv $file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30ef58fd04c99eff081e03afdb3827db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e56bf46378f7c6dc6bf886fc6a7242ce/" rel="bookmark">
			map中包含key则删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 if (paramMap.containsKey("id")){ paramMap.keySet().removeIf(s -&gt; s.equals("id")); } 旧式写法-迭代器删除
Iterator&lt;String&gt; iter = map.keySet().iterator(); while(iter.hasNext()){ if(iter.next().equals("sss")){ iter.remove(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4423698162099499af2e23b00e8f982e/" rel="bookmark">
			关于HashMap，这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
HashMap基本结构
为什么使用红黑树？
为什么链表中元素个数超过8(数组长度大于64)才转为红黑树
关于HashMap的扩容
HashMap基本结构 HashMap的存储结构是数组+链表+红黑树(JDK1.8+)。数组是HashMap 的主体，链表则是为了解决哈希冲突 (两个对象调用的hashCode方法计算的哈希码一致，导致都需要存放在同一个数组下标下) 而存在的（“拉链法”解决冲突）。
当链表长度大于阈值（默认为 8）并且当前数组的长度大于64时，此链表上的所有数据改为使用红黑树存储。
我们看源码：
/** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4423698162099499af2e23b00e8f982e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12d27b475f5962cc4936be8854215ede/" rel="bookmark">
			QuartusⅡ中的D触发器（dff）中，prn和clrn引脚的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计组课设最初要设计几个元件，在设计八位存储器和八位移位存储器的时候，我有一些小问题。就是清零端为什么不仅仅接入D触发器的CLRn端口，还接入了我不了解的prn端口。于是我搜集了一些资料整理于此。
PRN是异步置位，可以将输出Q置为输入D，CLRN是异步复位，将输出Q置低
PRN是异步控制端优先级比CLK高，CLK是寄存器的时钟。
dff真值表(优先级：clrn&gt;prn&gt;clk)
一、当Clrn=0时（不管Prn和clk是什么），Q=0
二、当Clrn=1时，异步复位信号clear无效（因为clrn是低电平有效）
若此时Prn=0，异步置位信号有效，不管clk是高电平还是低电平，可以立即把输入端D的内容打入到输出端Q（立即将输出Q置为输入D））
若此时Prn=1，异步置位信号无效，就要看clk的了
clk=1时：Q=d
clk=0时；状态不变
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa05e26beffeefa7517ace3db217b47b/" rel="bookmark">
			OpenCV中的图像处理 —— 图像阈值&#43;图像平滑&#43;形态转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV中的图像处理 —— 图像阈值+图像平滑+形态转换 目录 OpenCV中的图像处理 —— 图像阈值+图像平滑+形态转换1. 图像阈值1.1 简单阈值1.2 自适应阈值1.3 Otsu的二值化 2. 图像平滑2.1 2D卷积（图像过滤）2.2 图像平滑（图像模糊） 3. 形态转换3.1 侵蚀与膨胀3.2 开运算与闭运算3.3 顶帽与黑帽3.4 结构元素 1. 图像阈值 关于图像阈值主要涉及到两个函数：cv.threshold和cv.adaptiveThreshold（即简单阈值和自适应阈值）
1.1 简单阈值 首先我们要了解什么是阈值，阈值能干什么？简单阈值是我们设置的一个临界值，这个临界值的作用就是对应图像中的每一个像素，如果它小于这个临界值就将其设置为0，若其大于这个临界值则将其设置为最大值（一般为255），在使用阈值之后的图像就会只剩两个颜色像素：最大值和最小值，在掩膜的运用比较多，我们后续详细讲
我们先说简单阈值，简单阈值涉及的函数是cv.threshold()，其中需要传入4个参数，第一个参数即是我们的图像对象，需要注意的是一般我们需要在这里传入一个单通道灰度图，第二个参数是阈值，用于对整个图像的像素做一个分类，第三个参数是分配的最大值，即当像素大于我们设置的阈值时，使其等于这个我们设置的最大值即可，第四个参数是一个表示不同类型的标志，其取值可以是：cv.THRESH_BINARY，cv.THRESH_BINARY_INV，cv.THRESH_TRUNC，cv.THRESH_TOZERO，cv.THRESH_TOZERO_INV
下面我们通过一个例子来展示这些不同类型阈值的使用结果
import cv2 as cv import numpy as np from matplotlib import pyplot as plt img = cv.imread('gradient.png',0) ret,thresh1 = cv.threshold(img,127,255,cv.THRESH_BINARY) ret,thresh2 = cv.threshold(img,127,255,cv.THRESH_BINARY_INV) ret,thresh3 = cv.threshold(img,127,255,cv.THRESH_TRUNC) ret,thresh4 = cv.threshold(img,127,255,cv.THRESH_TOZERO) ret,thresh5 = cv.threshold(img,127,255,cv.THRESH_TOZERO_INV) titles = ['Original Image','BINARY','BINARY_INV','TRUNC','TOZERO','TOZERO_INV'] images = [img, thresh1, thresh2, thresh3, thresh4, thresh5] for i in range(6): plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa05e26beffeefa7517ace3db217b47b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4a20bbb5029f784a054daf2115d7fff/" rel="bookmark">
			【C语言】逆序数（反序数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逆序数（反序数） 文章目录 逆序数（反序数）一、问题描述二、要求三、问题分析四、预备知识五、代码实现六、课后思考 一、问题描述 所谓逆序数就是将证书的数字倒过来后所形成的整数
例如：1234的逆序是4321
二、要求 编写一个程序，让用户自行输入一个四位数，求其逆序数并输出到界面
三、问题分析 以数学思维分析，所谓逆序数，就是将原数的千位变成个位、原数百位变成十位，原数十位变成百位，原数个位变成千位。
这么一分析，逆序数是不是就很容易理解了。
四、预备知识 运算符描述实例/分子除以分母int i = 4; printf("%d",i/2); 输出2;%取模运算符，整除后的余数int i = 4; printf("%d",i%2); 输出0; 五、代码实现 #include&lt;stdio.h&gt; void main(){ int a,b=0; printf("请输入一个四位数："); scanf("%d",&amp;a); b += (a/10/10/10%10);	//求得个位的数 b += (a/10/10%10)	*10;	//求得十位的数*10 b += (a/10%10)	*10*10;	//求得百位的数*100 b += (a%10)	*10*10*10;	//求得千位的数*1000 printf("该数的逆序数为：%d\n",b); } 六、课后思考 用户输入任意长度整数，求其逆序数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae0ec0d4d69396ff6837f4d323b624ea/" rel="bookmark">
			from win32._api import * ModuleNotFoundError: No module named ‘win32._api‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查到百度说：没有安装pywin32
安装
到以下地址查找对应的pywin32版本并下载（exe文件）：https://sourceforge.net/projects/pywin32/files/pywin32/
安装
验证安装
后来尝试安装pypiwin32
方法1：pip install pypiwin32 ， pip3 install pypiwin32 ，python -m pip install pypiwin32,任选一个合适自己的。
安装后依然无法解决
后来找到api文件夹下的__init__.py 改写from win32.__api import * 去除“__”
无错了但是无法使用，裂开
最后安装Python36，将另外一台配置好Python win32的机器里面的python36\Lib\site-packages里面的内容Copy并覆盖，成功！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1baf7890adae9e2d71482dd1cd9527d/" rel="bookmark">
			SqlServer数据库master迁移问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司有一台旧的sqlserver 2008数据库安装在C盘，导致C盘空间爆满，因为C盘无法再扩容，只能考虑将master数据库迁移到G盘，因为对sqlserver不熟悉，没有按照官方文档迁移文件，导致数据库文件迁移后无法启动。 错误方法 直接在数据库修改文件路径
alter database master modify file ( name = master, filename = 'G:\Reports\DATA\master.mdf'); alter database master modify file ( name = mastlog, filename = 'G:\Reports\DATA\mastlog.ldf'); 按照该语句执行完成后，数据库关闭，将master.mdf和mastlog.ldf文件拷贝到G盘目录下。
重启数据库一直报错提示报错信息
无法打开错误日志文件 ''。操作系统错误 = 3(系统找不到指定的路径。)。事件ID 17058
查找网上的解决方案，包括文件权限，文件夹权限，账号权限都无法解决报错。最后找到解决方案，是启动参数问题，必须将下列三个参数添加到启动参数中，才能正常启动。添加任何一个参数都无法启动，要三个一起
-dG:\Reports\DATA\master.mdf;
-lG:\Reports\DATA\mastlog.ldf;
-eG:\Reports\DATA\ERRORLOG 这是一个很简单的错误，因为我没有按照官方文档操作迁移master，导致数据库启动报错，找了2小时找到了答案，也算万幸。
正确方法 官方文档记录的方法
移动系统数据库 - SQL Server | Microsoft Docs
移动 master 数据库 若要移动 master 数据库，请按照下列步骤进行操作。
验证 SQL Server 数据库引擎 的服务帐户是否对文件的新位置具有完全权限。 有关详细信息，请参阅 配置 Windows 服务帐户和权限预览版本升级问题的解答。 如果 数据库引擎 服务帐户无法控制其新位置中的文件，则 SQL Server 实例将不会启动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1baf7890adae9e2d71482dd1cd9527d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb314dbd8fed7f1a47cbbac07f1e8c5a/" rel="bookmark">
			从数据库层面去看linux的操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从数据库层面去看Linux操作系统的存储系统原理
Linux的存储系统分为VFS层、文件系统层、Page Cache缓存层、通用Block层、IO调度层、Block设备驱动层、Block设备层，如下图：
当MySQL发起一次数据页的随机读写，或者一次redo log日志文件的顺序读写的时候，实际上会把磁盘IO请求交给Linux操作系统的VFS层。
VFS层的作用：根据对哪个目录中的文件执行的磁盘IO操作，就把IO请求交给具体的文件系统。
一个系统是可以存在不同的文件系统，常见的设置文件系统的场景：挂载磁盘、格式化u盘等。所以在linux系统中，可能不同的目录就是由不同的文件系统管理的，这时VFS层就需要根据要对哪个目录下的文件发起的IO读写请求，把请求转交给对应的文件系统。（如步骤①）
接着文件系统会在Page Cache这个基于内存的缓存中查看要读写的数据是否在里面。（如步骤②）。如果已经有了就基于os cache执行读写，如果没有就继续往下一层走，把这个请求交给通用Block层，这一层会把对文件的IO请求转换为Block IO请求。（如步骤③）
在IO请求转换成Block IO请求之后，会把这个Block IO请求交给IO 调度层，（如步骤④），这一层会涉及到一个默认的算法：CFQ完全公平调度算法。
假设一个场景：数据库执行的多个SQL语句同时执行了IO操作。
第一个sql，如：update t1 set name = xxx where id = 1，可能只需要更新磁盘上的一个Block中的数据就可以了。
第二个sql，如：select * from t1 where name like “%xx%”，这条sql可能会需要IO读取磁盘上的大量数据。
如果是基于CFQ公平调度算法，会导致先执行第二条sql语句的读取大量数据的IO操作，第一条sql的更新少量数据的IO操作会进行等待。
如果数据量比较多，耗时较长，等待的时间较长的情况下，有一个思路：是将CFQ完全公平调度算法调整为 deadline IO调度算法，这个算法的核心思想是：任何一个IO操作都不能一直不停的等待，在指定的时间范围内，都必须去执行。（可以作为一个IO调优思路）
IO调度层完成之后，会决定哪个IO请求先执行，哪个IO请求后执行，然后把执行的IO请求交给Block设备驱动层。（如步骤⑤）。
经过驱动层把IO请求发给Block设备层，也就是真正的存储硬件。（如步骤⑥）。
最后硬件设备完成了IO读写操作之后，把响应按上面的层反向依次返回，最终MySQL得到本次IO读写操作的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36c5331d649992a99f5f6343104d10ee/" rel="bookmark">
			【C-数据类型及运算】浮点数与整数的除法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、前言2、程序验证1）C程序2）结果 1、前言 在 C 语言中，除法“ / ”运算在整数运算中表示的是除法取整，是不包含小数部分的，而 “ % ”运算在整数运算中表示除法取余。
如果在使用除法 “ / ” 时，包含了浮点型数据，那结果就不再是整数数据了，而是包含小数的商，下面我们可以看程序验证部分。
2、程序验证 1）C程序 #include &lt;stdio.h&gt; int main() { int i = 5; float f2 = 2; float f5 = 5; // 整数除以整数 float a = i / 2; printf("整数除以整数 %f\n",a); // 整数除以浮点 float b = i / f2; printf("整数除以浮点 %f\n", b); // 浮点除以整数 float c = f5 / 2; printf("浮点数除以整数 %f\n",c); // 浮点除以浮点 float d = f5 / f2; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36c5331d649992a99f5f6343104d10ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d039af7fe522026d1a60f3aa03036b4/" rel="bookmark">
			java开发：Class.forName 和 ClassLoader的区别和联系 | 使用场景 | 多方位解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在学习Java反射的时候，少不了同“Class.forName 和 ClassLoader”打交道，然而不深究的难以了解他们的区别和联系，以及各自的使用场景。
文章目的：了解他们的区别和联系以及使用场景，便于后期使用时对他们有清晰的认识。
概述 loadClass() 方法获得的 Class 对象只完成了类的加载，后续的初始化等操作均未进行。
使用 Class.forName() 方法获得 Class 对象，完成了类加载过程各个环节，并执行完类初始化工作。
下面就和我一起来深究一下他们的区别和联系吧。
一、首先了解：类的加载方式 1.隐式加载（最常用） 使用 new + （有参/无参）构造方法时，隐式(偷偷的)的调用类加载器，加载对应的类到 JVM 中，并隐式的完成类的初始化等各项工作，便于随时通过类的别名调用方法或属性，是最常见的类加载方式。
Student stu=new Student(100,"zhangsan"); stu. 2.显式加载（主要用在反射） 显式加载类获取到 Class 对象后，需要调用 Class 对象的 newInstance() 方法来生成对象的实例。最常用的方式就是通过 loadClass()、forName() 方法显式的加载需要的类。
注意：newInstance()方法在jdk9之后的使用有变化。
java8的写法
//该写法在java9中已被废弃 Person p = (Person) Class.forName("com.succ.reflect.test.Person").newInstance(); java9的写法
Person p2 = (Person) Class.forName("com.succ.reflect.test.Person").getDeclaredConstructor().newInstance();//java9的写法 3.隐式加载和显式加载的区别 1.隐式加载能够直接获取对象的实例，而显式加载需要调用 Class 对象的 newInstance() 方法来生成对象的实例。
2.隐式加载能够使用有参的构造函数，而使用 Class 对象的 newInstance() 不支持传入参数，如果想使用有参的构造函数，必须通过反射的方式，来获取到该类的有参构造方法。
3.显式加载常用在反射，使用更为灵活，可以一个代码对应很多个类，根据传入的class类的名称映射为不同的实现类。
二、Class.forName 和 ClassLoader的区别 1.相同点 两者都可以对类进行加载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d039af7fe522026d1a60f3aa03036b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37f43a8a0365c2efd299344422687c55/" rel="bookmark">
			ruoyi-vue-pro部署文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ruoyi-vue-pro介绍:
前端采用 vue-element-admin ，正在支持 Vue 3 + ElementUI Plus 最新方案。后端采用 Spring Boot、MySQL + MyBatis Plus、Redis + Redisson。权限认证使用 Spring Security &amp; Token &amp; Redis，支持多终端、多种用户的认证系统。支持加载动态权限菜单，按钮级别权限控制，本地缓存提升性能。工作流使用 Activiti ，支持动态表单、在线设计流程、多种任务分配方式。高效率开发，使用代码生成器可以一键生成前后端代码 + 单元测试 + Swagger 接口文档 + Validator 参数校验。集成微信小程序、微信公众号、企业微信、钉钉等三方登陆，集成支付宝、微信等支付与退款。集成阿里云、腾讯云、云片等短信渠道，集成阿里云、腾讯云、七牛云等云存储服务。 官方部署文档：芋道后台 yudao 搭建调试环境 | 芋道源码 —— 纯源码解析博客
官方文档：简介 | ruoyi-vue-pro 开发手册
1. 克隆代码 使用 IDEA 克隆代码，地址是 https://gitee.com/zhijiantianya/ruoyi-vue-pro https://github.com/YunaiV/ruoyi-vue-pro 克隆完成后，耐心等待 Maven 下载完相关的依赖。
Maven阿里云镜像
mirrors标签里边增加
&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/mirror&gt; yudao-dependencies
Maven 依赖版本管理
yudao-framework
Java 框架拓展
yudao-server
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37f43a8a0365c2efd299344422687c55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ea92749690e2a7c1e0c463effb3cd8f/" rel="bookmark">
			洛谷刷题——P1192 台阶问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：来源于洛谷
有N级的台阶，你一开始在底部，每次可以向上迈最多K级台阶（最少1级），问到达第N级台阶有多少种不同方式。
输入格式
两个正整数N，K
输出格式
一个正整数，为不同方式数，由于答案可能很大，你需要输出ans mod 100003后的结果。
输入输出样例
输入 #1
5 2 输出 #1
8 分析：
找规律。。
当n &lt;= k时，第N项 = （上一项 * 2） % 100003
当n &gt; k时，第N项 = （上一项 * 2 - 第n - 1 - k项） % 100003
最后结果 = （a[n] + mod) % mod; //加上mod，再取余，防止有负数
代码如下：
#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int mod = 100003; int main() {	int n, k, ans = 0; int arr[1000000]; arr[0] = arr[1] = 1; cin &gt;&gt; n &gt;&gt; k; for (int i = 2; i &lt;= n; ++i) { if (i &lt;= k) { arr[i] = (arr[i - 1] * 2) % mod; } else { arr[i] = (arr[i - 1] * 2 - arr[i - 1 - k]) % mod; } } ans = (arr[n]+mod) % mod; cout &lt;&lt; ans &lt;&lt; endl; return 0; } (●ˇ∀ˇ●)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c910de306b3b85d3655c582bac4298b/" rel="bookmark">
			QFontDialog----简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、QFontDialog：提供了一种选择字体的对话框控件。
from PyQt5.Qt import * class Window(QWidget): def __init__(self): super().__init__() self.setWindowTitle("QFontDialog---功能作用的学习") self.resize(500, 500) self.setup_ui() def setup_ui(self): # 设置一个默认值 font = QFont() font.setFamily("宋体") font.setPointSize(36) # 设置当前默认值 fd = QFontDialog(font, self) btn = QPushButton(self) btn.setText("字体选择") btn.move(200, 200) btn.clicked.connect(fd.open) if __name__ == "__main__": import sys app = QApplication(sys.argv) window = Window() window.resize(500, 500) window.show() sys.exit(app.exec_()) 2、功能作用：
①如何打开对话框。
②获取用户所选的最终结果。
方案一：
def font_sel(): # 获得当前所选择的最终字体 print("字体已经被选择", fd.selectedFont()) btn.clicked.connect(lambda: fd.open(font_sel)) 方案二：
# 通过输出结果可以判读用户最终选择什么结果 print(fd.exec()) if fd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c910de306b3b85d3655c582bac4298b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18ee800a1c45fe2a8245dc11d9a6ca13/" rel="bookmark">
			Spring AOP 源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过 IOC 的源码分析，那篇文章真的有点长，看完需要点耐心。很多读者希望能写一写 Spring AOP 的源码分析文章，这样读者看完 IOC + AOP 也就对 Spring 会有比较深的理解了。今天终于成文了，可能很多读者早就不再等待了，不过主要为了后来者吧。
本文不会像 IOC 源码分析那篇文章一样，很具体地分析每一行 Spring AOP 的源码，目标读者是已经知道 Spring IOC 源码是怎么回事的读者，因为 Spring AOP 终归是依赖于 IOC 容器来管理的。
阅读建议：1、先搞懂 IOC 容器的源码，AOP 依赖于 IOC 容器来管理。2、仔细看完 Spring AOP 使用介绍 这篇文章，先搞懂各种使用方式，你才能"猜到"应该怎么实现。
Spring AOP 的源码并不简单，因为它多，所以阅读源码最好就是找到一个分支，追踪下去。本文定位为走马观花，看个大概，不具体到每一个细节。
目录：
前言 这一节，我们先来"猜猜" Spring 是怎么实现 AOP 的。
在 Spring 的容器中，我们面向的对象是一个个的 bean 实例，bean 是什么？我们可以简单理解为是 BeanDefinition 的实例，Spring 会根据 BeanDefinition 中的信息为我们生产合适的 bean 实例出来。
当我们需要使用 bean 的时候，通过 IOC 容器的 getBean(…) 方法从容器中获取 bean 实例，只不过大部分的场景下，我们都用了依赖注入，所以很少手动调用 getBean(...) 方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18ee800a1c45fe2a8245dc11d9a6ca13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6c5b8ee282399b7980eb47bf9c2081b/" rel="bookmark">
			Linux内核驱动学习---编写最简单Linux内核模块HelloWorld
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下内容来源于 https://blog.csdn.net/lihaoweiV/article/details/6602261 https://blog.csdn.net/sh21_/article/details/60878812 https://blog.csdn.net/u010632165/article/details/86541941 https://blog.csdn.net/FallingU/article/details/76166194 推荐 https://blog.csdn.net/zhengnianli/article/details/120838057 什么是内核模块
模块是可以根据实际需要可以动态加载和卸载到内核中的代码。它们扩展了内核的功能，而无需重启系统，就可以进行模块加载，并工作。例如，一种类型的模块是设备驱动程序，它允许内核访问连接到系统的硬件。没有模块，我们必须构建整个内核并将新功能直接添加到内核映像中。除了拥有更大的内核之外，这还有一个缺点，就是每次我们想要新功能时都需要我们重新编译内核并烧录到设备。
Linux内核模块基本原理
Linux 内核模块（LKM）是一些在启动的操作系统内核需要时可以载入内核执行的代码块，不需要时由操作系统卸载。它们扩展了操作系统内核功能却不需要重新编译内核、启动系统。如果没有内核模块，就不得不反复编译生成操作系统的内核镜像来加入新功能，当附加的功能很多时，还会使内核变得臃肿。一个Linux 内核模块主要由以下几个部分组成：
(1) 模块加载函数(必须)：当通过insmod 或modprobe 命令加载内核模块时，模块的加载函数会自动被内核执行，完成本模块相关初始化工作。
(2) 模块卸载函数（必须）：当通过rmmod 命令卸载模块时，模块的卸载函数会自动被内核执行，完成与模块加载函数相反的功能。
(3) 模块许可证声明（必须）：模块许可证（LICENCE）声明描述内核模块的许可权限，如果不声明LICENCE,模块被加载时将收到内核被污染的警告。大多数情况下，内核模块应遵循GPL 兼容许可权。Linux2.6 内核模块最常见的是以MODULE_LICENSE(“Dual BSD/GPL”)语句声明模块采用BSD/GPL 双LICENSE。
(4) 模块参数（可选）：模块参数是模块被加载的时候可以被传递给他的值，它本身对应模块内部的全局变量。
(5) 模块导出符号（可选）：内核模块可以导出符号(symbol,对应于函数或变量)，这样其他模块可以使用本模块中的变量或函数。
(6) 模块作者等信息声明（可选）。
一个内核模块至少包含两个函数，模块被加载时执行的初始化函数init_module()和模块被卸载时执行的结束函数cleanup_module()。在最新内核稳定版本2.6 中，两个函数可以起任意的名字，通过宏module_init()和module_exit()注册调用要编译内核模块，把代码嵌进内核空间，首先要获取内核源代码，且版本必需与当前正在运行的版本一致。
hello.c
/*包含了对模块的结构定义以及模块的版本控制， * 任何模块程序的编写都要包含这个头文件*/ #include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; //包含了常用的内核函数 /*宏__init告诉编译程序相关的函数和变量仅用于初始化， * 编译程序将标有__init的所有代码存储到特殊的内存段中， * 初始化结束后就释放这段内存*/ #include &lt;linux/init.h&gt; //包含了宏__init和宏__exit static int __init hello_init(void)//lkp_init()是模块初始化函数 { /*printk()函数，该函数是由内核定义的，功能与C库中的 printf（）类似，它把要打印的信息输出到终端或者系统日志*/ printk(KERN_INFO "module init success\n"); return 0; } static void __exit hello_exit(void) //lkp_cleanup()是模块的退出和清理函数 { printk(KERN_INFO "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6c5b8ee282399b7980eb47bf9c2081b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a937d6f884f8c300726043b0fbf7abb5/" rel="bookmark">
			yaml 文件（字符串）的解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我在遇到准备将一串符合yaml 的字符串进行解析，在搜索之后发现解析yaml 基本都是对文件进行解析。但自己字符串用 new Yaml().loadAs 无法解析，按道理也是支持字符串不应该不支持。想到自己字符串的换行可能不对，那么在java中如何才认为是一个换行呢？
BufferedWriter writer = new BufferedWriter(write);
writer.newLine() 这样一个方法，看了这个实现方式
String lineSeparator = java.security.AccessController.doPrivileged( new sun.security.action.GetPropertyAction("line.separator")); 这个是一个换行符, 通过这个看到换行符实际就是一个\r\n 但是又给自己拼接出来不一样。
效果就是
自己拼接出来\r\n ,如果是通过上面反复获取到换行符那就是真的换行了。那么有了上面理解就有下面一篇对字符串解析的工具类
实践 package com.yin.common.util; import org.apache.commons.lang.StringUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.yaml.snakeyaml.Yaml; import sun.security.action.GetPropertyAction; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.InputStreamReader; import java.security.AccessController; import java.util.Collections; import java.util.LinkedHashMap; import java.util.Map; import java.util.Objects; /** * @author yin * @since 2022/3/20 14:45 */ public class YmlUtil { private static Logger logger = LoggerFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a937d6f884f8c300726043b0fbf7abb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/461124f764b727c5ec32e65e9eb2fc91/" rel="bookmark">
			分享saas门店收银系统源码的商品发布与编辑功能重构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6607d16e79edf53fa68860ec95ed453/" rel="bookmark">
			美业多门店收银系统源码saas
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，连锁管理高效经营
2，智能收银极速开单，支持ipad，iphone手机，安卓手机，安卓pad，小程序等
3，顾客档案编辑管理，实现无纸化办公
4，物流管理，极大提高效率
5，自动化经营性报表分析
6，精准的顾客管理
7，手艺人管理，预约，排版等自动化工作安排
8，小程序预约/购买/拓客引流
9，支持健康问卷/评测
10，各种深度定制化开发。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89fe86aa2bf538d7971554463cb08e78/" rel="bookmark">
			使用phpStudy搭建74cms(详)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自行下载phpStudy和74cms压缩包
建议在虚拟机上下载安装，部分版本的phpStudy有后门
解压phpStudy到C盘目录下（虚拟机Windows7）
打开phpStudy.exe
弹出的对话框或页面关闭即可
启动phpStudy，Apache和MySQL显示绿色，若为红色请自行调试
浏览器访问本机地址127.0.0.1
出现phpStudy探针
查看虚拟机IP
宿主机访问虚拟机IP出现phpStudy探针界面
解压74cms压缩包到phpStudy/WWW/74cms目录下并打开
宿主机访问Windows7 IP
或者Windows 7访问本地127.0.0.1
点击74cms-&gt;upload
出现安装向导
我同意
环境监测没问题点击下一步
参数配置如下图
主机、前缀等默认就可以
填完点击下一步
安装完成
点击网站首页查看
完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b50844cae53e04c06d791ef53435bf/" rel="bookmark">
			RN开发系列＜*＞--问题集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
在RN开发过程中，总能遇到各种奇葩问题，同一个项目，你昨天能好好地跑起来，啥都没改过，可能明天就跑步起来的事情也是有的。 案例1 终端报错: error Failed to build iOS project. We ran “xcodebuild” command but it exited with error code 65. To debug build logs further, consider building your app with Xcode.app, by opening demo1.xcworkspace.
Command line invocation:
/Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -workspace demo1.xcworkspace -configuration Debug -scheme demo1 -destination id=78B46ADF-51FA-4F69-AC6B-38DA5D05FC87
note: Using new build system
note: Building targets in parallel
note: Planning build
note: Using build description from disk…(略一万字)
原因：不明解决方法：（本人亲测可以，不敢保证100%有效）
1&gt; 关闭所有的终端
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3b50844cae53e04c06d791ef53435bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44c7c936f7b743a543507299b2d347f9/" rel="bookmark">
			make busybox的时候出现了error: conflicting types for ‘xxx‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误产生： 在制作根文件系统时，make busybox的时候出现了：
error: conflicting types for ‘xxx’
error: previous implicit declaration of ‘xxx’ was here
…
Makefile:744: recipe for target ‘xxx’ failed
recipe for target ‘xxx/xxxx.o’ failed
错误图片展示如下：
查询解决方案 在make后出现大量报错是令人头疼的事情，我将错误提示进行搜索，总结主要有以下原因：
无函数声明，或者声明顺序不对；如1与2顺序
系统头文件被破坏了
头文件被循环引用
声明的函数与定义的函数参数不同
函数使用的参数类型是自定义类型（如结构体），而自定义类型的定义在函数的声明和函数定义之间，由于在函数声明时，结构体并没有被定义，不被系统识别为结构体，而后面定义函数时，结构体已经定义，系统将其识别为结构体，导致系统认为声明和定义使用
在linux中，编译头文件，会出现一个中间的预编译文件（.h.gch），当再次编译整个文件时，如果该文件(.h.gch)存在，则会直接使用该文件(.h.gch)，而不会再编译.h文件，此时，如果你改动了.h文件，而继续编译，则会造成声明和定义不一致的现象，虽然在文件里显示声明和定义是一致的，但是实际上系统编译时并不会使用你改动后的文件(.h)，而是直接使用你修改前编译生成的.h.gch文件；要及时更新.h.gch文件
（以上源自https://blog.csdn.net/weixin_34380781/article/details/92223048）
在我报错的头文件中未包含#include&lt;resource.h&gt;头文件
缺少工具lzo、lzop 可使用：sudo apt-get install lzop下载
错误解决 在尝试了一些解决方案后，仍无法解决报错，我回过头来反复查看教学视频，发现在我的操作过程中只有一个与视频有着较大差异：
**
就是我得Ubuntu版本与arm-Linux-gcc交叉编译工具的版本 于是我想着如果我更新一下我的交叉编译工具版本会不会解决这些报错； **
答案是显而易见的，报错解决，完美编译：
制作的根文件系统也可以挂载和使用：
总结 问题的产生可能是多种原因的，对于新手小白来说去查询问题，排除问题显得异常艰难；尤其我在排查是不是头文件声明顺序产生的报错时，花费了大量的时间和精力。
最后也是给自己和大家（新手）提个醒，如果在操作步骤相对规范的情况下产生了一些不知名错误，可以率先思考是不是版本不兼容的情况；这里的版本不兼容有很多情况，比如：交叉编译工具与Ubuntu版本的不兼容，交叉编译工具和Ubuntu与开发板内核的不兼容等等。
如果更新后依然无法解决，我们再去修改相关文件，这样也许会节省不少的时间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f6fabfeb20a11cdbc49b05ff38fac10/" rel="bookmark">
			如何快速去除PDF的密码和限制：遇到PDF被加密，不能复制、编辑，怎么办？教大家一个又快又好用的方法、实用。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何快速去除PDF的密码和限制：遇到PDF被加密，不能复制、编辑，怎么办？教大家一个又快又好用的方法哦！超实用。 网址：https://smallpdf.com/cn/unlock-pdf
这是一个可以免费在线解除 PDF 文档的密码和限制的网站，复制网址打开链接
只要将 PDF 文件拖放到网页中的红色框中，然后等文件上传完毕，点击打开密码就可以了。这个网站的上传速度非常快，解密和上传过程均有进度条显示，而且没有文件大小限制，经过多次测试，这个网站解密效果还是非常不错的！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50b505cf68e0c1f3ab1093a3b6daeca/" rel="bookmark">
			关于【Adb】使用grep命令报错：“‘grep‘ 不是内部或外部命令，也不是可运行的程序或批处理文件”的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于【Adb】使用grep命令报错：“‘grep’ 不是内部或外部命令，也不是可运行的程序或批处理文件” 在使用adb命令（adb logcat | grep 应用包名）过滤包名查看应用日志的时候，报错’grep’ 不是内部或外部命令，也不是可运行的程序或批处理文件。然后发现要想使用grep命令，只能先进入shell状态，所以又用命令（adb shell logcat | grep 应用包名）去抓取日志，可还是报这个错误。
查了查，发现是shell命令的问题，用命令（adb shell “logcat | grep 应用包名” &gt;D:\1.txt）试了试，就能正常抓取了。所以，在使用涉及到shell命令时，如果有类似错误，就把shell后面的命令都用引号引起来，就能正常操作了。
还可以用 adb shell logcat com.ifeng.news2 -v time &gt;D:\log.txt 此命令来通过包名过滤日志
如果还是不行，windows下，把grep换成findstr试试。也就是在windows下，把命令 adb logcat | grep 应用包名 换成 adb logcat | findstr 应用包名
转载于：https://www.jianshu.com/p/2724a96c635d
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcaf6f23291d23d74bfba628f2b7fe74/" rel="bookmark">
			Oracle数据库的连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle数据库的连接 Oracle数据库环境变量概述Oracle数据库服务器配置Oracle数据库客户端配置Oracle数据库客户端与服务器共存配置 PLSQL Developer配置PLSQL Developer环境变量配置PLSQL Developer中Oracle主目录与oci库配置1、PLSQL Developer安装在Oracle数据库服务器系统中2、PLSQL Developer安装在Oracle数据库客户端系统中3、PLSQL Developer安装在Oracle数据库客户端与服务器共存的系统中 Oracle数据库环境变量 概述 Oracle数据库主要的环境变量配置有四个（Path、TNS_ADMIN、ORACLE_HOME、ORACLE_SID），加上PLSQL Developer的中文配置（NLS_LANGUAGE），共计五个。环境变量的执行优先级高于注册表，在安装数据库时，数据库会将相关配置写入注册表，我们通过修改环境变量来更高一层的控制数据库连接方式。
关于版本位数的说明：instantclient的版本是选择32位还是64位的跟操作系统有关系，64位的instantclient兼容32位数据库，32位的instantclient不兼容64位数据库，因此最好选择64位操作系统及64位合适版本的instantclient；PLSQL Developer的版本与要通过TNS连接的OCI库（Oracle主路径中oci.dll动态链接库文件）的位数有关系（连接64位客户端就用64位PLSQL Developer，连接32位客户端就用32位PLSQL Developer，连接64位数据库就用64位PLSQL Developer，连接32位数据库就用32位PLSQL Developer）；instantclient是可以向下兼容的，若不兼容说明是instantclient与操作系统不兼容，不是与数据库不兼容。另注意，PLSQL Developer中ODBC导入器工具如果使用Excel Files导入数据，PLSQL Developer位数与Microsoft Office位数（在开始-帮助中可以查看）必须一致，才能链接Excel成功。
Oracle数据库各个名字之间的关系
全局数据库名=数据库名；Oracle系统标识符（SID）=实例名（也叫做服务名）；一个SID只能对应一个全局数据库名；一个全局数据库名可以对应多个SID；网络服务名与SID是多对一的关系，网络服务名可以自己建立多个对应同一个SID。
以下配置以Windows7x64、Oracle10g32位、instantclient_12_2为64位、PLSQL Developer64位为例。
Oracle数据库服务器配置 Path=C:\oracle\product\10.2.0\db_1\bin;…（sqlplus、oci.dll等文件路径）
ORACLE_HOME=C:\oracle\product\10.2.0\db_1（Oracle主目录，关系到TNSListener服务，如果TNSListener服务启动失败应该是该环境变量未配置或配置错误！；TNSListener服务是运行Oracle主目录下\BIN\TNSLSNR.EXE程序）
ORACLE_SID=orcl（服务端已在安装时写入注册表中，因此可以不配置此项目）
TNS_ADMIN= C:\oracle\product\10.2.0\db_1\NETWORK\ADMIN（tnsnames.ora文件所在路径，用于TNS连接数据库，若更改此文件需要重启TNSListener服务和OracleServiceORCL服务，如果OracleServiceORCL服务启动失败应该是该环境变量未配置或配置错误！）
服务端系统防火墙关闭时，客户端才可连接成功（服务端系统防火墙未配置情况下）；服务端系统防火墙打开时，需要设置允许TNSLSNR.exe程序通过防火墙，并且可以做远程地址ip控制。
Oracle数据库客户端配置 Path=C:\instantclient_12_2;…（sqlplus、oci.dll等文件路径）
ORACLE_HOME= C:\instantclient_12_2（客户端没有Oracle服务，因此可以不配置此项目）
ORACLE_SID=orcl（客户端没有Oracle服务，因此可以不配置此项目）
TNS_ADMIN= C:\instantclient_12_2\config（tnsnames.ora文件所在路径，用于TNS连接数据库）
如要访问多个服务端则将多个服务端tnsnames.ora中相关配置内容整合，如有相同数据库服务名/实例名或相同网络服务名，可更改设置为不同网络服务名以便区分
Oracle数据库客户端与服务器共存配置 Path=C:\instantclient_12_2;C:\oracle\product\10.2.0\db_1\bin;…（sqlplus等程序的路径）
ORACLE_HOME=C:\oracle\product\10.2.0\db_1（oracle主目录，关系到TNSListener服务，不能配置为客户端路径，因为客户端文件中没有\BIN\TNSLSNR.EXE）
ORACLE_SID=orcl（客户端没有Oracle服务，服务端已在安装时写入注册表中，因此可以不配置此项目）
TNS_ADMIN= C:\instantclient_12_2\config（tnsnames.ora文件所在路径，用于使用64位的客户端TNS连接数据库）
此时在同一个电脑中装有数据库服务端（Oracle数据库）和数据库的客户端（instantclient），注意配置PLSQL Developer软件配置中的Oracle主目录为C:\instantclient_12_2，OCI库为C:\instantclient_12_2\oci.dll。
PLSQL Developer配置 PLSQL Developer环境变量配置 为解决连接客户端的PLSQL Developer软件中文查询报错。
用客户端的PLSQL Developer查看服务器端的语言编码：select userenv(‘language’) from dual;我查询到的结果是AMERICAN_AMERICA.ZHS16GBK。执行语句select * from v$NLS_PARAMETERS;查看parameter字段为NLS_LANGUAGE的这一行对应的value字段的值是否和第一步得到的值相同，如果不同，则需要添加环境变量。新建环境变量，变量名：NLS_LANG，变量值就是第一步中的查询结果，我的是AMERICAN_AMERICA.ZHS16GBK。重新启动PLSQL Developer，再进行关于中文的查询即可。
NLS_LANGUAGE=AMERICAN_AMERICA.ZHS16GBK（用于解决连接客户端的PLSQL Developer中文乱码问题）
PLSQL Developer中Oracle主目录与oci库配置 此处也分为三种情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcaf6f23291d23d74bfba628f2b7fe74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdd793a60d5a5f3c35891faebff5bef6/" rel="bookmark">
			Qt作品(一)： 框选图片任意数量Roi(感兴趣区域)工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言功能演示：主要思路核心代码： 前言 在图像处理中，有时候我们只想对图像的某部分区域执行处理，即所谓的Roi（感兴趣区域）。例如在做模板匹配之前，通常都需要人工在图像上框选一个Mask区域，以此建立基准模板。下面记录一下自己基于Qt实现的一个框选图片矩形区域的工具。
功能演示： 鼠标左键点击，该位置坐标位矩形的左上顶点，滑动鼠标即可实时看到自己所框选的矩形框，释放左键。矩形款选完成，左键释放时。这是界面会提示，右键点击鼠标，代表确认矩形框选完成。右窗口显示框选矩形区域之后的图像。底部窗口输出所有框选的矩形的左顶点，矩形的高还有宽。
若想重新框选，左键双击将全部清楚。
主要思路 1.继承QWidget类，重写鼠标双击，鼠标移动，鼠标单击和鼠标释放函数，
virtual void mouseDoubleClickEvent(QMouseEvent *event) virtual void mouseMoveEvent(QMouseEvent *event) virtual void mousePressEvent(QMouseEvent *event) virtual void mouseReleaseEvent(QMouseEvent *event) 在这四个函数中，实现人机交互的逻辑。
2.矩形数据结构采用的是opencv提供的cv::Rect数据结构。右键点击确认完成，将所有的cv::Rect矩形存储在std::vector容器中。在文章opencv cv::Rect详解中，我们解析了该数据类型。
3.右窗口的实现是采用了opencv提供的rectangle函数，将所有框选的矩形以填充的形式画在一张画布上，再将画布与原图做与的操作，可以用“ | ”操作符，也可以调用opencv的bitwise_and()函数。
核心代码： void Widget::mousePressEvent(QMouseEvent *event) { if(event-&gt;button() == Qt::LeftButton &amp;&amp; event-&gt;pos().x() &lt; srcOri.cols) { bIsDrawing = true; cacheRect = cv::Rect(event-&gt;pos().x()-m_fRatioWidth, event-&gt;pos().y()-m_fRatioHeigh, 0, 0); } else if(event-&gt;button() == Qt::RightButton) { cropImage(result); } } void Widget::mouseReleaseEvent(QMouseEvent *event) { if(event-&gt;button() == Qt::LeftButton) { bIsDrawing = false; if (cacheRect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdd793a60d5a5f3c35891faebff5bef6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b6e4e368b30c4603e77358abe3de77/" rel="bookmark">
			centos7配置网络步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在安装centOS7时，需要配置网络适配器为ANT：
2、安装完成后，关闭虚拟机，选择编辑-》虚拟网络编辑器：
此时会配置一些虚拟机的网络环境
3、设置主机的IPV4地址：
打开windows下网络和共享中心，在网络连接中找到VMnet8和当前使用的本地网络，我当前使用的本地网络是WLAN，右键WLAN，选择属性：
然后再设置VMnet8 IPV4属性：
然后重启网络：service network restart
ping百度成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/232e21b4754eee3090752408fb579d84/" rel="bookmark">
			相似度计算（3）——欧式距离和闵克夫斯基距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欧式距离和闵克夫斯基距离 一、欧式距离 1、定义 欧式距离（欧几里得距离，欧几里得度量），是一个通常采用的距离定义，指在m维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。在二维和三维空间中的欧氏距离就是两点之间的实际距离。
2、公式 计算距离的通用公式为：
其中n是维度（属性）的数量，pk和qk分别是数据对象p和q的第k个维度（属性）。
二、闵克夫斯基距离 闵克夫斯基距离是欧氏距离的一般化，其公式为：
其中r是参数，n是维度（属性）的数量，pk和qk分别是数据对象p和q的第k个维度（属性）。
r=1：城市街区（曼哈顿、L1范数）距离。
r=2：欧氏距离。
r=∞：上确界 (切比雪夫，Lmax 范数, L∞范数) 距离。
三、举例计算 给定两个对象由元组(11，23，35，47) 和 (5，14，46，32)表示:
计算两个对象间的欧式距离 Euclidean distance.
计算两个对象间的曼哈顿距离 Manhattan distance.
计算两个对象间的闵可夫斯基距离 Minkowski distance, 其中 r = 3.
计算两个对象间的上确界距离 supremum distance.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09bfc3207f20c810c70bdedc3200dd7e/" rel="bookmark">
			数据建模.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据建模 什么是数据建模为什么要进行数据建模怎么进行数据建模 1. 为什么要进行数据建模？ 提高
效率/性能： 计算机的的吞吐率，减少I/O的时间，提高用户使用数据的效率。开销：减少数据的冗余，从而节省存储空间质量：统一数据的口径，减少数据计算错误的可能性。 2. 怎么进行数据建模？ OLTP系统和OLAP系统的区别。 一个是联机事务（业务）处理系统，另一个是联机分析处理系统。两个系统的关注点不一样，所以需要进行不同的数据建模。
业务处理系统，关注事务的一致性，所以主要采用3NF的E-R模型进行存储，从而解决事务的冗余和一致性问题。
联机分析系统，主要关注数据的批量读写的性能，因此需要采用不同的数据建模方法。
数据库广义的划分为事务处理和决策支持系统，就是对应着上面的两种系统。OLAP和OLTP只是一种手段而已。数据仓库的概念： 数据仓库是将从多个数据源中收集来的信息以统一的模式存储在单个站点上的仓库。数据仓库提了一个单独的、统一的数据接口，易于决策支持和查询书写。而且，通过从数据仓库里访问用于支持决策的信息，决策者可以保证在线事务处理不受决策支持负载的影响。
数据仓库需要解决哪些技术问题？
总结1：从这个角度来说，数据仓库就是决策系统的数据库。区别于事务处理系统的数据库。
总结2: 从这个角度来说，大数据的分析就是为IT系统做决策所使用的系统。数据仓库也就是对应着大数据开发中的第4、5步业务建模，考虑IT系统怎么使用决策系统的输出进行工作。
总结3：数据建模就是为了数据仓库建立而设计模型的过程，或者为事务系统数据库建立设计模型的过程。
怎么进行数据建模 综上的一些概念，需要对不同种类的系统进行不同的建模分析。根据上面不同系统各自的特点进行不同的模型建立。
3. 经典的数据仓库建模方法论 E-R模型维度模型Data Vault模型Anchor模型阿里巴巴数据模型实践综述 4. 参考文献博客 《数据库系统概念》
大数据实践之数据建模
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/253/">«</a>
	<span class="pagination__item pagination__item--current">254/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/255/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>