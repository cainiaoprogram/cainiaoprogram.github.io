<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0849985a829886e046991605538327f/" rel="bookmark">
			30米分辨率的DEM地形数据——STRM高程数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DEM地形数据是我们在各种研究和设计中经常使用的数据！之前我们分享过源于GEBCO组织的全球范围的500米分辨率的DEM地形数据（可查看之前的文章），这个数据的优点是数据很小，在大区域分析的时候也不会卡顿，缺点是数据精度较低，难以用在小区域的分析中。我们也分享过来基于NASA地球科学数据网站的各个省份的12.5米分辨率的DEM地形数据（可查看之前的文章），该数据优点是精度高，缺点是数据较大，难以使用全国范围数据。
本次我们给大家介绍的是30米分辨率的DEM地形数据——STRM高程数据！该数据由美国太空总署（NASA）和国防部国家测绘局（NIMA）联合测量的。该数据由于精度较高，导致数据非常大，对于全国范围的数据大部分用户应该都是打不开的，因此我们把该数据处理为了全国分省份和分城市的数据，方便大家使用！
以下为数据的详细介绍：
01 数据可视化
对于每个省份，共有3栅格文件：
1.全省范围的地形（范围大于省份边界）
2.全省范围的地形（范围和省份边界一致） 3.省内各城市的地形
1.全省范围的地形（范围大于省份边界）
我们以湖北省为例来预览一下，将涉及湖北行政区划范围的的栅格进行拼接得到比湖北省行政边界更大范围的地形，之所以要提供该范围，是考虑到有些小伙伴可能想用自己的行政边界去裁剪数据，在这种情况下只能基于更大范围的地形裁剪！
2.全省范围的地形（范围和省份边界一致）
我们以湖北省为例来预览一下，在上面栅格的基础上，我们按照行政区划，依据湖北省的边界对地形进行了裁剪，形成了和湖北省边界范围一致的地形！
3.省内各城市的地形
我们以湖北省为例，除了提供全省范围的地形，我们还提供了湖北省13个地级市每个城市的地形，我们以武汉市为例来看看：
02 数据详情
基准面：D_WGS_1984
数据格式：.tif格式
空间分辨率：30m
官方下载链接：http://srtm.csi.cgiar.org/srtmdata/
有关该数据以及其他各种精度的DEM数据的介绍和下载方式可以查看我们之前推送的文章！
文末下方是我们的公众号名片，我们将定期介绍各类城市数据以及数据的可视化和分析技术，有关30米分辨率DEM地形数据的更多详情，欢迎大家多多关注我们进行了解~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e79bbc7dd11cc2903af6a415de45dbd/" rel="bookmark">
			NSIS软件安装包脚本快速操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 资源下载：https://download.csdn.net/download/qq_33097303/87250749
打包好程序运行需要的库
首先配置好环境，不然在后面选择不了语言
运行NSIS.exe,点击HM VNISEdit（编译环境）
选择文件-&gt;新建脚本（向导）
按照向导操作
后面继续按照向导编辑操作，到第7步
在自述中加入软件介绍（可不填，自述文件是在软件安装完成后选择显示的，之后再打开则不会出现），然后继续下一步，最后
等待编译完成后，在保存脚本的位置会出现生成的安装包，安装包便可直接使用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d597f8cd6e98af75e01e3a36f7e6cb28/" rel="bookmark">
			【设计模式——Composite模式】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Composite模式
计算机科学中广泛使用的数据结构是树结构，到处都可以找到树结构，例如，数据媒体（比如硬盘）上的文件系统，它的分层组织就符合树的结构。集成开发环境（IDE）的项目浏览器通常也具有树结构。在编译器设计中，用到一种叫作抽象语法树（AST）的方法，顾名思义，它是指以树状结构表示源代码的抽象语法结构，抽象语法树通常是编译器在语法分析阶段的结果。
对树状数据结构的面向对象的蓝图被称为组合模式。该模式的任务说明如下：
将对象组合成树结构来表示“部分——整体”的层次结构。组合允许客户端统一地处理单个对象和对象的组合。
我们在Command和Command处理器种的示例可以扩展为复合Command，并且Command还可以记录和重放。所以我们在之前的设计中添加了一个新类，一个CompositeCommand：
#pragma once #include"Command.h" #include&lt;vector&gt; class CompositeCommand :public UndoableCommand { public: void addCommand(CommandPtr&amp; command) { commands.push_back(command); } virtual void execute() override { for (const auto&amp; command:commands) { command-&gt;execute(); } } virtual void undo() override { for (const auto&amp; command : commands) { command-&gt;undo(); } } private: std::vector&lt;CommandPtr&gt; commands; }; CompositeCommand有一个成员函数addCommand()，它允许你将命令添加到CompositeCommand的实例。由于CompositeCommand类也实现了UndoableCommand接口，因此可以将其实例视为普通的command。换句话说，我们可以以其他的CompositeCommand来分层地组合出一个新的CompositeCommand。通过Composite模式的递归结构，你可以生成command树。
现在可以使用新添加的类CompositeCommand作为宏录制器，以便记录和重放command序列：
int main() { CommandProcessor commandProcessor{}; DrawingProcessor drawingProcessor{}; auto macroRecorder = std::make_shared&lt;CompositeCommand&gt;(); Point circleCenterPoint{ 20,20 }; CommandPtr drawCircleCommand = std::make_shared&lt;DrawingCircleCommand&gt;(drawingProcessor, circleCenterPoint, 10); commandProcessor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d597f8cd6e98af75e01e3a36f7e6cb28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e4c4faa32c9925f705673409a8a637/" rel="bookmark">
			（ROS）解决gazebo闪退和tk窗口不显示问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题1：运行gazebo的时候，gazebo窗口闪退
解决办法： 1.删除gazebo，重新安装适合的版本然后再重新运行 或者 2.关闭加速3D图形（需要关闭虚拟机 rostopic：
问题2：gazebo加载地图小车pid错误（地图不能打开
sudo apt-get install ros-melodic-gmapping 看地图的命令：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aba1fbb25ea9823bc62cf4d1454710c7/" rel="bookmark">
			VS2017编码格式不同报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近打开之前写的代码，
#include &lt;iostream&gt; int main() { std::cout &lt;&lt; "你好" &lt;&lt; std::endl; return 0; } 运行出现乱码
上网查找资料发现是编码格式不同导致的，在高级保存选项里修改为简体中文（GB2312）-代码页936
运行还是乱码。
后来突然想到前几天用VS2017联合CentOS7调试程序时出现乱码，
为了解决这个问题，根据网上的方法下载了一个Force UTF-8(NO BOM)插件，问题也得到了解决。然后上官网查看了该插件的说明，发现如下说明：
Saving files with encodings other than UTF-8 and default encoding (based on system locale) that has no BOM may cause file losing some characters.
Use it only if you understand the information above.
（使用非UTF-8编码和默认编码（基于系统区域设置）保存没有BOM的文件可能会导致文件丢失某些字符。只有在您了解以上信息的情况下才能使用。）
然后把这个插件卸载之后，运行程序，乱码消失了。
在这里做一下记录，方便以后查找。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb54becb9e694252c7c414f0f3b64dd9/" rel="bookmark">
			高中成绩主成分分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高中成绩主成分分析 “”"
1.导入模块
2.导入数据
3.建立变量的相关系数矩阵ρ
4.求ρ的特征值λ1&gt;λ2&gt;…&gt;λp&gt;0,和特征向量e1,e2,…,ep
5.写出前m个主成分Y1,Y2,…,Ym的表达式
6.计算样本各主成分的得分
7.计算总主成分Y=(λ1Y1+λ2Y2+…+λ1Ym)/(λ1+λ2+…+λm)的综合得分
“”"
1.导入模块 import pandas as pd # 数据分析的模块
import numpy as np # 数据分析的模块
import matplotlib.pyplot as plt # 画图的模块
import seaborn as sns # 画图的模块
from factor_analyzer.factor_analyzer import calculate_bartlett_sphericity # Bartlett’s球状检验
from factor_analyzer.factor_analyzer import calculate_kmo # KMO检验
plt.style.use(‘seaborn-whitegrid’) # 画图的风格
plt.rc(‘font’, **{‘family’: ‘Microsoft YaHei, SimHei’}) # 显示中文字体的模块
2.导入数据 df = pd.read_excel(r’D:\codes\金融大数据挖掘与分析\实验十二 主成分分析\学生成绩表.xls’, usecols=range(1, 10)) # 导入数据，去掉第1列的索引，样本数据
n, p = df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb54becb9e694252c7c414f0f3b64dd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85e882de892145f1c64989b6d3192a22/" rel="bookmark">
			设置canvas画布大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		canvas的绘制是以画布大小为准的。
canvas的默认画布大小为300×150。
设置canvas画布大小的方法：
// 方法一 &lt;canvas id="test" width="100px" height="100px"&gt;&lt;/canvas&gt; // 方法二 &lt;canvas id="test"&gt;&lt;/canvas&gt; &lt;script&gt; var canvas = document.getElementById('test'); canvas.width="100";	// 注意：没有单位 canvas.height="100";	// 注意：没有单位 var ctx = canvas.getContext('2d'); ... &lt;/script&gt; 注意：不可以在CSS里面直接修改，例如
canvas { width: 100px; height: 100px; border: 1px solid black; } 使用css设置画布的大小，会导致画布按比例缩放你设置的值。（css只是设置canvas在屏幕的显示大小）。
例如：用css设置的width为450，height为300，对应默认的画布大小300×150，宽高比例分别为1.5和2，所以我们设置的矩形的宽（100px）高（100px）实现显示的会是宽：100px×1.5=150px；高：100px×2=200px；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bf6dc54b96bc869df69667dc0b4214b/" rel="bookmark">
			JS获取对象的长度（对象属性数量）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对象的长度不能用.length获取，可以用js原生的Object.keys获得一个对象属性的数组，然后再用.length
var obj = {'name' : 'Tom' , 'sex' : 'male' , 'age' : '14'}; var arr = Object.keys(obj); // 返回 所有对象属性 的数组 console.log(arr); // ['name','sex','age'] console.log(arr.length); //3 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/261237d3343611239ff94132875a7f01/" rel="bookmark">
			JS 判断一个字符串是否为日期格式（兼容IOS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 isNaN(times) 是排除了times是纯数字的情况，如果不考虑这个情况的话，isNaN(times) 这部分就不需要了因为IOS手机上时间格式必须为'2020/12/21 20:05:05'，不支持'2020-12-21 20:05:05'所以我们需要将'-'替换为'/'，如果不替换 Date.parse(new Date(times)) 在IOS上会输出 NaN ，下面代码已测试IOS可以正常使用reg.test(times) 这部分是为了考虑到其他输入错误的情况（只能是数字，/,:,-,空格），一般情况下日期格式就'2020/12/21 20:05:05'和'2020-12-21 20:05:05' 两种 var times = '2020-12-21 20:05:05'; var reg = /^[0-9,/:-\s]+$/; if(!isNaN(Date.parse(new Date(times.replace(/-/g, '/')))) &amp;&amp; isNaN(times) &amp;&amp; reg.test(times)){ console.log("times是日期格式！") // IOS 用alert测试就可以 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cee8ccb968298d6dfbc62f852825fabc/" rel="bookmark">
			qt模块feature QT_FEATURE_* qt_lib_*.pri QT_CONFG qtConfig
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qt为方便对功能和代码进行删减和系统兼容，将代码拆分成很多模块且对每个模块梳理出feature，为了简化程序的使用和其他目的，一个模块编译成一个单独的dll，qt还对每个模块的头文件分成public部分和private部分。在编译模块前，通过修改模块对应源码文件夹下的confiure.json控制feature开关来删减系统不支持或者不必要的feature，对应feature的condition是可配置的，感兴趣的可以查看qt的编译脚本文件（shell脚本/dos脚本）。
widgets/configure.json 在配置好模块的configure.json后，运行configure启动编译脚本（shell脚本/dos脚本），过程中会自动为模块生成对应头文件，比如widgets 模块，会生成qtwidgets-config.h和qtwidgets-config-p.h，每一个属性在.h中都有一个宏，作为代码的宏开关，值一般为1或-1，用于控制模块源码的逻辑，其内容如下：
qtwidgets-config.h 在qt 的源文件qglobal.h中有这样两个方便使用feature对应宏开关的宏定义QT_CONFIG和QT_REQUIRE_CONFIG：
//QtInstallDir\Qt5.12.0\5.12.0\msvc2015_64\include\QtCore\qglobal.h #define QT_CONFIG(feature) (1/QT_FEATURE_##feature == 1) #define QT_REQUIRE_CONFIG(feature) Q_STATIC_ASSERT_X(QT_FEATURE_##feature == 1, "Required feature " #feature " for file " __FILE__ " not available.") qmainwindow.h qt模块编译好后会产生对应qt_lib_*.pri和qt_lib_*_private.pri脚本（qmake language脚本）文件，方便qmake生成makefile时查询模块是否支持对应的feature。下面是qt_lib_core.pri文件内容:
#D:\Qt\Qt5.12.0\5.12.0\msvc2015_64\mkspecs\modules\qt_lib_core.pri QT.core.VERSION = 5.12.0 QT.core.name = QtCore QT.core.module = Qt5Core QT.core.libs = $$QT_MODULE_LIB_BASE QT.core.includes = $$QT_MODULE_INCLUDE_BASE $$QT_MODULE_INCLUDE_BASE/QtCore QT.core.frameworks = QT.core.bins = $$QT_MODULE_BIN_BASE QT.core.depends = QT.core.uses = libatomic QT.core.module_config = v2 QT.core.CONFIG = moc resources QT.core.DEFINES = QT_CORE_LIB QT.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cee8ccb968298d6dfbc62f852825fabc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c140cbda58fc29c3fc9032d2b507e3dd/" rel="bookmark">
			eCognition使用ESP插件得到最优分割尺度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eCognition 面向对象的多尺度分割 使用ESP插件进行多尺度分割。
下载ESP插件 链接：https://pan.baidu.com/s/1QnDASk1p5GCYNCoEXB0vSg
提取码：i102
ESP插件压缩包里面包括
(1) ZedGraph.dll
(2)ESP_estimation_scale_parameter.dcp
(3)ESP_Estimation_Scale_Parameter_Chart.exe
将ZedGraph.dll拓展文件放到eCognition Developer 64安装目录下的 bin\plugins文件夹下
step1. 打开eCognition软件，创建工作空间导入影像。 step2. 加载和运行工具。 在工具栏【process】-【load rule set】加载规则集/自定义算法
“ESP2_Estimation_Scale_Parameter_2.dcp”（在解压文件夹中ESP存储在计算机上的路径）
ESP2是2014年最新版，ESP是2010版，两者参数略有不同
step3. 根据需要设置参数，上图为默认参数。 参数解释 Selectmap:(选择要应用ESP2的地图；默认情况下，ESP2将在主地图分割)Use the Herarchy: 使用层次结构 (0=每个尺度参数基于像素级别独立生成；1=每个尺度级别是在层次结构中生成的，以自上而下或自下而上的方法)Hierarchy: TopDown=0 or BottomUp=1 ? : BottomUp从最小级别开始，合并对象以获得较高级别；TopDown从较粗级别开始，分割对象以获得较小的级别；默认情况下，等于1**Starting scale_Level **: 开始处理的三个级别的最小比例参
数；默认情况下，所有开始比例= 1Step size_Level 1:逐步分割处理的比例参数的增量，默认为1， 10， 100…'Shape’ and ‘Compactness’：在多尺度分割中实现的同质性准则的组成；默认值分别为0.1和0.5Produce LV Graph’： 0=不生成一个LV.txt文件；1=生成一个带有LV值的txt文件，文件在ESP_Estimation_Scale_Parameter_Chart的帮助下以图形方式虚拟化。number of loops: 循环数，如果要生成LV图需要设置，要生成的比例等级的数量。 设置完参数点击Excute即可运行，如果影像较大需要较长时间运行。
step.4 运行结束查看结果 运行结束后，切换地图，在Select Active map中选择Hierarchy_B-Up即可查看结果。以及切换不同等级，实验数据有三层，下图为从Level3–Level1
最后，【Export】导出结果即可.
可将结果导出为shapefile等格式。
step5. 查看最佳分割参数 将上述的Produce LV Graph参数设置为1，才能够得到ROC-LV折线图。
工具将局部方差（LV）和变化率（兴趣量表水平与前一个水平之间的ROC=变化率）与量表水平绘制起来。图中显示了局部方差的ROC突然下降，然后是水平。然而，如果ROC在第一个尺度水平上极高，则局部方差的变化是不可见的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c140cbda58fc29c3fc9032d2b507e3dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9e8f2181e33409eb4b2b244f1343218/" rel="bookmark">
			kafka基本架构以及参数调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Kafka是LinkedIn公司使用Scala语言开发，后来捐献给apache的项目。官网地址是http://kafka.apache.org。是常用的以高吞吐、可持久化、可水平扩展、支持流处理的分布式消息系统。
简单架构图：
生产端：逻辑层生产者将消息发到指定的topic中，物理层，生产者先找到相应的集群和对应的leader partition建立连接发送消息。
消费端：逻辑层消费组接收此topic的所有消息，物理层消费组的消费者连接到固定的partition来消费消息。
在物理层上包装逻辑层也是一个比较常见的解耦方法：比如很多公司都是多地域多中心的多活容灾架构。在物理层北京亦庄数据中心、上海桂桥数据中心等物理数据中心上划分逻辑数据中心，数据中心的迁移可以做到应用服务不感知。底层的实现原理也很简单就是标签+路由层。
Kafka集群的一台服务端和其他应用一样，是由应用+数据组成，可以算作是一个分布式文件系统。大多数的分布式文件系统就是主从架构如Mysql、Kubernetes和Kafka，个别是对等式的架构如ElasticSearch。Kafka的主节点被称为Controller，负责和Zookeeper通信、集群成员管理(Broker上下线)和Topic管理(增删改查)。Zookeeper里存储的是集群的元数据信息。简而言之，Controller的功能可以类比Kubernetes等集群的Controller功能，差不多的。
数据存储上，每个partition物理上是一个文件夹，相当于将一个巨型文件分成多个大小相等的segment文件。每个文件的消息数不一定相等。每个partition文件由于是顺序读写，所以老的segment文件可以快速被删除。
一个segment文件由一个index文件和一个数据文件组成。文件名为上一个文件的最后一条消息的offset值。索引文件是稀疏索引。所谓稀疏索引说白了就是说不是每条消息都有索引，间隔几条才会有。数据文件也叫日志文件，里面都是一条条消息数据。
Kafka实际项目使用的思考：切换加密集群,安全上的需要，连接Kafka集群需要加密，使用的SASL简单认证和安全层。假设说我们使用的是用户名密码+SSL认证。
kafka参数调优：
在项目中实际使用，很多人都是网上copy对应的配置，并不知道他们之前的参数的相互影响。比如出现rebalance后产生的结果是具体以哪种方式引起的排查，我列举几种原因：
1.数据量大，消费不及时引起循环堆积
2.超时时间配置过小
3.批处理的时效性过慢
问题排查：当数据量大的时候，一次性获取500条数据，但是实际吞吐时长已经超过了心跳检测时间，那么就可能导致数据在偏移到一定数值时，被判定这个消费组挂掉，就直接离线，频繁触发rebalance这种情况。
解决方式：先知道当前获取一批数据消费时间，觉得过长可以优化逻辑（治本）以及修改max-poll-records拉取的批次数（减少批次数，只治标），适当增加heartbeat-interval-ms的检测时间，同时要保证session-timeout-ms的时间要大于heartbeat-interval-ms，不然也会修改参数无效这种情况。
调优的配置
# 消费组 group-id: in-tsp-pre # 偏移量获取方式 auto-offset-reset: latest # 是否自动提交 enable-auto-commit: false # auto-commit-interval: 100 # 批次获取数 max-poll-records: 500 # 批次提交最大时长 max-poll-interval-ms: 600000 # 心跳检测 低于session-timeout-ms的三分之一 heartbeat-interval-ms: 10000 # 超时时间 session-timeout-ms: 30000 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fe811435a1bac9f061962ce03840ee4/" rel="bookmark">
			python &#43; appium搭建iOS自动测试环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 环境 安装Python包或者anaconda都可以 appium-deskop （Appium Server GUI） 通过UI操作方式开启Appium Server的工具，mac选择dmg下载安装
下载地址：https://github.com/appium/appium-desktop/releases/tag/v1.22.0 appium-inspector iOS元素定位工具，mac选择dmg下载安装
下载地址：https://github.com/appium/appium-inspector/releases appium-doctor 检查appium自动测试环境的工具
命令行安装
npm install -g appium-doctor 完成以上步骤之后进行初步环境检查 包括node.js、Carthage、idb等
命令：
appium-doctor --ios
检查结果打钩✅的说明没问题，有打叉❌的说明没有安装或环境变量没有配置，根据提示进行安装后再次检查，直到 Everything looks good
WebDriverAgent 配置修改 在已下载安装好的appium-desktop的目录下找到WebDriverAgent，涉及修改，避免改错，可以把appium-webdriveragent目录整体备份打开安装目录下的WebDriverAgent.xcodeproj，默认会用xcode打开需要修改2个地方 添加账户，使用个人的appleID即可，登录成功之后选择已登录的账户
分别修改【WebDriverAgentLib】和【WebDriverAgentRunner】的Bundle Identifier：选择Build Setting–&gt;Bundle Identifier
在原有的签名字符上添加部分字符即可，如com.facebook.WebDriverAgentRunner9527回到Signing &amp; Capability选项，验证修改后的签名可用 将签名后的WebDriverAgent 安装到真机 完成以上步骤，在xcode的WebDriverAgent.xcodeproj 中选择用数据线连接的真机设备，Command+u执行安装WebDriverAgent到手机
等待安装成功手机端会出现一个WebDriverAgent的APP 如果build 成功但无法安装的，需要在手机端允许来自这个apple id的应用程序安装：Setting-&gt;General-&gt;VPN&amp;Device Management中设置为允许 appium-inspector 元素定位工具使用 完成以上步骤，即可在真机上启动APP进行元素定位
开启appium的服务，在mac上打开已安装的appium-deskop，Host 默认本地，端口默认4723，端口冲突可修改
开启appium-inspector，填写已开启的端口，填写Remote Path,填写设备的信息，然后Start Session，启动APP
开启成功之后，就可以开始进行元素定位操作了
python 驱动WebDriverAgent 进行自动测试 安装Appium-Python-Client，python的appium三方库,需要python 3.7+
pip install Appium-Python-Client
创建驱动，驱动设备打开APP,旧的desired_caps已弃用，改为AppiumOptions加载设备信息
from appium import webdriver option = AppiumOptions() desired_caps = dict() desired_caps["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fe811435a1bac9f061962ce03840ee4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2381833198173903394ed826b3e91c78/" rel="bookmark">
			【Leetcode 第二轮刷题日记】LeetcodeTOP100&#43;高频题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一些笔记链表笔记树笔记 一、链表篇（14）1.1、删除链表元素LeetCode237. 删除链表中的节点（ 腾讯）LeetCode19. 删除链表的倒数第 N 个结点（ ⭐️⭐️⭐️高频、剑指II、HOT100）LeetCode82. 删除排序链表中的重复元素 II（⭐️⭐️高频、剑指II） 1.2、翻转/旋转链表剑指 Offer II 024. 反转链表（⭐️⭐️⭐️高频、剑指II、HOT100 腾讯）LeetCode25. K 个一组翻转链表（难）（⭐️高频）LeetCode61. 旋转链表（腾讯） 1.3、交换链表节点LeetCode24. 两两交换链表中的节点（⭐️高频） 1.4、环形/相交/回文链表LeetCode141. 环形链表（腾讯）LeetCode142. 环形链表II（⭐️⭐️⭐️高频、剑指II、HOT100 腾讯）LeetCode160.相交链表（⭐️⭐️⭐️高频、剑指II、HOT100 腾讯）LeetCode234.回文链表（⭐️⭐️⭐️高频、剑指II、HOT100） 1.5、链表合并LeetCode2: 两数相加（⭐️腾讯 HOT100）LeetCode445: 两数相加II（⭐️⭐️⭐️高频、剑指II、HOT100）LeetCode21: 合并两个有序链表（⭐️⭐️⭐️高频、剑指II、HOT100 腾讯）LeetCode23: 合并K个排序链表（⭐️⭐️高频、HOT100 腾讯） 1.6、重排链表LeetCode148: 排序链表（⭐️⭐️⭐️高频、剑指II、HOT100）LeetCode143: 重排链表（⭐️⭐️高频、剑指II） 1.7、LRU缓存LeetCode146. LRU 缓存（⭐️⭐️⭐️高频、剑指II、HOT100 腾讯） 二、树篇（26）2.1、二叉树前序遍历LeetCode257.二叉树的所有路径（⭐️高频）LeetCode 129.求根到叶子节点数字之和（⭐️⭐️高频、剑指II）LeetCode617. 合并二叉树（⭐️Hot100）LeetCode113.路径总和II（⭐️高频）LeetCode437.路径总和 III（⭐️难 Hot100） 2.2、二叉树中序遍历LeetCode98.验证二叉搜索树（⭐️⭐️高频、HOT100）剑指 Offer 54. 二叉搜索树的第k大节点（⭐️高频）Leetcode230. 二叉搜索树中第K小的元素（⭐️腾讯）剑指offer36: 二叉搜索树与双向链表（⭐️高频）Leetcode.538. 把二叉搜索树转换为累加树（⭐️Hot100） 2.3、二叉树后序遍历Leetcode104. 二叉树的最大深度（⭐️HOT100 腾讯）LeetCode226. 翻转二叉树（⭐️HOT100）Leetcode110. 判断是否是平衡二叉树（⭐️高频）LeetCode543.二叉树的直径 （⭐️⭐️高频、HOT100）LeetCode124.二叉树中的最大路径和（⭐️⭐️⭐️高频、剑指II、HOT100 腾讯）Leetcode236. 二叉树的最近公共祖先（⭐️⭐️⭐️⭐️⭐️最经典 高频、HOT100 腾讯） 2.4、二叉树层次遍历LeetCode199.二叉树的右视图（⭐️⭐️高频、剑指II）剑指 Offer II 044. 二叉树每层的最大值（⭐️剑指II）LeetCode103.二叉树的锯齿形层序遍历（⭐️高频）Leetcode101. 对称二叉树（⭐️⭐️高频、HOT100）牛客.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2381833198173903394ed826b3e91c78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f64b547d2c39d339024d2323694e36e/" rel="bookmark">
			微信API接口、微信二次开发API调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信API接口、微信二次开发API调用
微信协议接口调用-加微信好友及通过好友请求
加微信好友
/** * 微信自动添加好友
* @author wechatno:tangjinjinwx
* @blog http://www.wlkankan.cn
*/
@Async
public void handleMsg(ChannelHandlerContext ctx ,TransportMessage vo, String contentJsonStr) {
try {
log.debug(contentJsonStr);
FriendAddTaskSetting req = JSON.parseObject(contentJsonStr,FriendAddTaskSetting.class);
if(null != req){
friendAddTaskService.savePcTask(req);
//3、告诉PC客户端消息已收到
MessageUtil.sendCustomJsonMsg(ctx, "AutoFriendAddTaskResp", resp);
} } catch (Exception e) {
e.printStackTrace();
MessageUtil.sendJsonErrMsg(ctx, EnumErrorCode.InvalidParam, Constant.ERROR_MSG_DECODFAIL);
}
}
微信新增好友通知 /**
* 微信新增好友通知
* @author wechatno:tangjinjinwx
* @blog http://www.wlkankan.cn
*/
@Async
public void handleMsg(ChannelHandlerContext ctx, TransportMessage vo) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f64b547d2c39d339024d2323694e36e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d440f9a1392e97568edd642214de96/" rel="bookmark">
			PDF文档一键自动生成目录和书签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工作中经常会遇到编写文档的时候，当我们在word编写完文档后，一般可以自动生成一个目录。为了方便阅读和保护文档不被破坏，一般发送给别人的时候，需要把word文档转换成PDF格式。但是word文档转换为PDF格式后，目录虽然依然存在，但是在PDF阅读器的书签栏看不到目录，为了方便阅读，我们希望能将文档的目录自动添加到PDF的书签中去。
下面我就详细演示一下，如何在word中自动生成目录，同时将word文档转换为PDF文档后，自动生成书签。
首先编写word文档。
在编写文档的时候要注意使用标题来区分不同的目录层次。
第一级目录就使用一级标题，选中文档中的目录名称，然后在开始工具栏，将目录名称设置为一级标题。
按照同样的方法将二级目录设置为二级标题，将三级目录设置为三级标题。
标题处理完成之后，就可以添加其他内容了。
文档内容编写完成后，就可以利用word自动生成目录了，首先把 光标定位到需要生成目录的地方。
这里将光标定位到第一页，然后选择工具栏中的引用—目录。
在目录里面选择自动目录，此时就会在第一页中自动生成文档的目录。
此时目录的层次就和标题的层次是一样的，第一级目录就是一级标题，第二级目录就是二级标题，第三级目录就是第三级标题。
此时按住ctrl键，用鼠标单击对应的目录，文档就会自动跳转。
接下来利用word的保存功能，将文档转换为PDF格式。
在word文档中选择 文件 — 另存为 ----这台电脑，选择文件存储的位置和名称。
将文件的保存类型设置为PDF格式，然后点保存按钮，此时就会在桌面上生成一个PDF文档。
打开生成的PDF文档
生成的文档内容和word中的是一样的，同样在PDF文档中，这个目录直接点击就可以跳转到对应页面。
但是通常看PDF文档时不习惯这样使用目录跳转，一般习惯直接点击左侧的书签进行跳转。
打开PDF的书签栏之后发现这个书签栏是空的，也就是通过word文档生成的PDF默认是没有书签的，需要书签就得自己去添加。
下面就使用 PDF补丁丁 这个软件来自动给PDF文档生成书签。
下载地址 https://www.cnblogs.com/pdfpatcher/
这个软件是免安装版，下载下来之后解压，双击PDFPatcher.exe图标，直接打开软件。
软件界面如下
选择文件–打开文件，打开刚才生成的自动生成目录pdf文档。
接下来将滚动鼠标滚轮，将PDF文档滚动到文档中一级标题的位置，然后在一级标题上单击鼠标右键，选择设置自动书签标题格式—1级标题
此时会弹出一个对话框，单击生成书签按钮。
这时候就在左侧生成的一级标题的书签。
在左侧看到生成的书签后，就可以关闭这个对话框了。用同样的方法，在二级标题上面单击鼠标右键，选择设置自动书签标题格式—2级标题
在弹出的对话框上直接点击生成书签。
此时在左侧的书签栏中就可以看到生成的二级书签。
用同样的方法，在三级标题上面单击鼠标右键，选择设置自动书签标题格式—3级标题.
此时点击左侧的书签栏，右侧的PDF文档就可以自动跳转了。
如果对生成的书签不满意，可以使用上面一排的书签工具对书签进行修改。
比如这里将不同的目录级别用不同颜色标记。
修改完成后点击保存按钮，保存修改后的PDF文档。
为了方便对比，这里不覆盖原文件，单击确定输出修改后的PDF文件。文件保存成功后，关闭PDF补丁丁软件。
用pdf浏览器打开刚才生成的文档。
可以看到自动添加标签这个文档中在PDF浏览器左侧已经可以看到添加的标签了。但是最后修改的标签颜色和加粗显示，在这里好像没有起作用，但是不影响使用。
在PDF文档中，不仅可以通过第一页的目录进行跳转，也可以通过左侧的书签进行跳转。
这样通过word和PDF补丁丁软件的组合，就可以很方便的制作一个带目录和标签的PDF文档了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ae22fd8f406d992b59246013eeff01d/" rel="bookmark">
			多分类求混淆矩阵、精确率，召回率代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其中，TP表示正类数预测为正类数的个数；FP为负类数预测为正类数的个数；FN为正类数预测为负类数的个数；TN为负类数预测为负类数的个数。
附上python代码：
# coding=utf-8 import matplotlib.pyplot as plt import numpy as np confusion = np.array(([190,0,0,0,0,0,0,0,0,0,10,0,0,0,0], [0,200,0,0,0,0,0,0,0,0,0,0,0,0,0], [0,0,200,0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,199,0,0,0,1,0,0,0,0,0,0,0], [0,0,0,0,200,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,200,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,200,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,200,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,200,0,0,0,0,0,0], [0,0,0,0,0,0,0,1,0,199,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,200,0,0,0,0], [0,1,0,0,0,0,0,0,0,0,0,199,0,0,0], [0,0,0,0,0,2,0,0,0,0,0,0,197,0,1], [0,0,0,0,0,0,0,0,0,0,0,0,0,200,0], [0,0,0,0,0,0,0,0,0,0,0,0,0,0,200] )) classes=['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15'] #画出混淆矩阵 def confusion_matrix(confMatrix): # 热度图，后面是指定的颜色块，可设置其他的不同颜色 plt.imshow(confMatrix, cmap=plt.cm.Blues) # ticks 坐标轴的坐标点 # label 坐标轴标签说明 indices = range(len(confMatrix)) # 第一个是迭代对象，表示坐标的显示顺序，第二个参数是坐标轴显示列表 # plt.xticks(indices, [0, 1, 2]) # plt.yticks(indices, [0, 1, 2]) plt.xticks(indices, classes,rotation=45) plt.yticks(indices, classes) plt.colorbar() plt.xlabel('预测值') plt.ylabel('真实值') plt.title('混淆矩阵') # plt.rcParams两行是用于解决标签不能显示汉字的问题 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ae22fd8f406d992b59246013eeff01d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0610a3f24bc05f8ee32a67ad35fe065a/" rel="bookmark">
			「C#」异步编程玩法笔记-async、await
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#5.0的时候引入了async和await两个修饰符，成为异步编程的核心关键字。
async 是修饰符，表明方法含有异步操作，但并不是说整个方法是异步的。async修饰的方法会先同步执行到第一处await的地方而后开始异步。
await可以理解为一异步特有的“return”。即返回一个正在运行的异步过程。并且等待该异步过程结束后再继续向await的下一句运行。
例如下方法
private static void Main(string[] args) { Console.WriteLine("Application Start"); AsyncTask1(); Console.WriteLine("Application End"); } private static async Task AsyncTask1() { Console.WriteLine("AsyncVoid1"); Thread.Sleep(1000); Console.WriteLine("AsyncVoid1: befor await"); await Task.Run(() =&gt; { Console.WriteLine("AsyncVoid1: Task Runing"); Thread.Sleep(2000); }); Console.WriteLine("AsyncVoid1: after await"); } 运行输出如下：
Application Start AsyncVoid1 AsyncVoid1: befor await AsyncVoid1: Task Runing Application End AsyncVoid1: after await 异步返回类型 async是方法的修饰，其对应的方法的返回值有
voidTaskTask、任何具有可访问的 GetAwaiter 方法的类型（GetAwaiter 方法返回的对象必须实现 ystem.Runtime.CompilerServices.ICriticalNotifyCompletion 接口）。IAsyncEnumerable（对于返回异步流的异步方法）。 常用的是前三个。暂且置整理前三者的区别与不同。
async void async不建议修饰void方法，因为void 方法无法使用await。比如上面的例子中，AsyncTask1方法再调用时可以不加await，也可以加await来实现在调用程序结束前等待其执行结束。比如调用方式改成如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0610a3f24bc05f8ee32a67ad35fe065a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5892cdb627583cab2ac7c74b5e384c60/" rel="bookmark">
			本地开发正常,打war包部署到Tomcat运行的时候提交中文内容乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天部署项目到Tomcat服务器的时候，有些post请求获取参数数据是是中文乱码，看了下有问题的接口参数的获取方式是从流中获取的：
BufferedReader br = new BufferedReader(new InputStreamReader(HttpUtil.getRequest().getInputStream())); String line = null; StringBuilder sb = new StringBuilder(); while ((line = br.readLine()) != null) { sb.append(line); } br.close(); if (sb.length() &lt; 1) { return ""; } String reqBody = URLDecoder.decode(sb.toString(), "UTF-8"); reqBody = reqBody.substring(reqBody.indexOf("{")); return reqBody; 但是在idea开发的时候运行是正常的，于是觉得问题是出现在Tomcat上，Tomcat版本的apache-tomcat-9.0.65，于是通过如下解决：
1、打开tomcat的/conf/server.xml，给它显示的增加编码方式。
&lt;Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443" URIEncoding="UTF-8"/&gt; 2、将日志的编码格式也修改一下，打开tomcat的\conf\logging.properties。
3、修改Tomcat下的bin下的catalina.bat的配置，在最前面添加 set JAVA_OPTS=-Dfile.encoding=UTF-8 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/916a0d39531ce230fceac0c1c1ae8b84/" rel="bookmark">
			排名赛A题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排名赛A题解 1.复读机 hello world题 #include&lt;stdio.h&gt; int main() { int i=1; int n; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) { printf("SDUFE\n"); } return 0; } 2.换钱的交易 这题刚好压在int能表达的数据的边缘了，2^31,建议开long long input n output 100000*n Sn(a1=1,q=2) #include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { int i=0; long long n; long long sn; scanf("%lld",&amp;n); if(n==0) { printf("0\n"); printf("0"); } else { sn=(1*(1-pow(2,n)))/(1-2); //pow()s是math.h里的幂函数，sn是等比数列求和公式 printf("%lld\n",n*100000); printf("%lld",sn); } return 0; } 3.回文序列判定 #include&lt;stdio.h&gt; #include&lt;string.h&gt; char str[10000000]; //题目没说多少数据范围就开到最大，放到静态存储区(main函数外面)防止炸掉栈(main函数里面)内存 int main() { gets(str); int len; int i=0; int flag=1; len=strlen(str); for(i=0;i&lt;(len-1)/2;i++) //len-1是减去# { if(str[i]==str[len-2-i]) //i是从0开始的，所以len再减一，len奇数偶数都行 { //如 abccba#， flag=1; //数组下标0123456,len为7, 7-2=5 } else { flag=0; break; } } if(flag) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/916a0d39531ce230fceac0c1c1ae8b84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/234f2aa1bf0e43e31673a568b85a70a3/" rel="bookmark">
			二维数组与字符串与结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指针 指针中的const int const * p; //不能改变指针指向的值
int * const p; //不能改变指针指向的地址
int const * const p //既不能改变值，也不能改变地址
结构体 知识提要 1.传向函数的结构体数组都是指针
2.[]的优先级比*高
3.指针的运算符是-&gt; 而结构体的运算符是.
struct instr { char ina1[10]; int ina2[10]; }; struct str { char a[10]; int b[10]; double c[10]; struct instr instrin; { char b1[10]; int b2; }; }; struct str stru; struct str *pstru=&amp;stru; 1.结构体写法 stru.a[i]; stru.instrin.ina1[i]; stru.b2; 2.指针 pstru-&gt;a[i]; (*pstru).a[i]; pstru-&gt;instrin.ina2; pstru-&gt;b2; 结构体 定义模板 struct name { char fname[10]; char lname[10]; }; 定义结构体变量 struct name myname; 函数定义 void print_sour(struct name myname); //函数定义中的形参是一个结构体，需要传入一个结构体 函数调用 print_sour(myname); //这儿传递的是一整个结构的所有数据 结构体指针， 注意:在函数调用上要与上面的分开 定义模板 struct money { double hand_money; double save_money; } struct name { struct money mymoney; //嵌套结构体必须要有; char fname[10]; char lname[10]; { int num1; double num2; }; //匿名结构体也需要; }; 定义结构体指针 struct name myname_c; struct name *myname; 结构体指针的使用 myname=&amp;myname_c; //对于结构体，结构体不是数组，结构体的名字不代表地址，要用取地址符 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/234f2aa1bf0e43e31673a568b85a70a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c8e544f4d40588bf6b64da900805a2/" rel="bookmark">
			c语言错误集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据类型 long long与int不要混用 用int就全int，一但用long long就全long long
错误示例
#include&lt;stdio.h&gt; int main() { int a=1000000; int b=1000000; printf("%lld",a*b); /* 或者是 int a=1000000; int b=1000000; long long c=a*b; printf("%lld",c); */ return 0; } 结果是3567587328，并不是预期值 正确做法
#include&lt;stdio.h&gt; int main() { long long a=1000000; long long b=1000000; printf("%lld",a*b); /* 或者是 long long a=1000000; long long b=1000000; long long c=a*b; printf("%lld",c); */ return 0; } 结果是预期值 牵扯到可能会出现小数的算数必须用double，这是一小时debug给的教训，血的教训！！！ 尝试找出该程序的bug
#include&lt;math.h&gt; int isinround(int x1,int x2,int y1,int y2,int r) { int ret=0; int num; num=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)); if(num&gt;r) { ret=0; } else { ret=1; } return ret; } 答案是
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95c8e544f4d40588bf6b64da900805a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb26db15c8d8ca3c7e5da0e321709237/" rel="bookmark">
			math.h函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		math.h内常用函数 1.绝对值函数 absolute 1.整数绝对值,abs
函数原型: int abs(int x); 函数功能: 求整数x的绝对值 int number=-1234; abs(number); //结果是1234 2.浮点数绝对值,fabs
函数原型: double fabs(double x); 函数功能: 求浮点数x的绝对值. float number=-1234.0; fabs(number); //结果是1234.0 2.取整(round)与取余(mod) 2.取整和取余
1.向上取整，ceil（天花板）
函数原型: double ceil(double num) 函数功能: 得到不小于num的最小整数 函数返回: 用双精度表示的最小整数 2.向下取整，floor（地板）
函数原型: double floor(double x); 函数功能: 求出不大于x的最大整数. 函数返回: 该整数的双精度实数 3.浮点数取余，fmod
函数原型: double fmod (double x, double y); 注意点 1.返回两参数相除x/y的余数 2.符号与x相同 3.如果y为0，则结果与具体的额实现有关 4.分解整数与小数，modf
函数原型: double modf(double val,double *iptr); 函数功能: 把双精度数val分解为整数部分和小数部分,把整数部分存到iptr指向的单元. 函数返回: val的小数部分 参数说明: val 待分解的数 所属文件: ＜math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb26db15c8d8ca3c7e5da0e321709237/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b3f330f8533683b73dc2c691e936e1/" rel="bookmark">
			时间序列分析的基本流程（R语言版——实验篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据处理 1.导入数据（.csv）
能导入绝大所数形式的格式文件 ex52&lt;-read.table("C:\\Users\\33035\\Desktop\\习题5.2数据.txt",header=T,fileEncoding = 'GBK') #header ：T:表示留第一行 #fileEncoding:有中文时最好改为GBK 2.对数据切片获取
ex_52&lt;-ex52[,c(2,4,6,8)]#取这几列做成list ex_ROAD&lt;-t(ex_52) 3.把一行变一列数据
ex_52data&lt;-as.vector(t(ex_52)) 4. 将数据做成时间序列ts
ex_52series&lt;-ts(ex_52data,start = 1750,frequency = 1) #参数1：数据 #start:从1750开始 #frequency=1:步进为一年 数据处理已经完成，下面进行时序分析 1.画时序图（初步直观感受时间序列的特性）
plot(ex_52series,type="o") 看平稳性和白噪声（直观不科学）
非平稳性：有周期性和趋势性
如果存在周期性，那么图像就会有周期性波动，
趋势性：就是有单调性趋势
2. 数据说话：ADF单位根法进行平稳性检验
aTSA::adf.test(ex_52series)#adf检验 结果：
Augmented Dickey-Fuller Test alternative: stationary Type 1: no drift no trend lag ADF p.value
[1,] 0 -14.52 0.06
[2,] 1 -12.61 0.01
[3,] 2 -14.73 0.06
[4,] 3 -8.42 0.06
Type 2: with drift no trend lag ADF p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17b3f330f8533683b73dc2c691e936e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80b8f4f60e0f0f11c20820a42e2cc00e/" rel="bookmark">
			生物信息软件综合实践学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习资料是现代生物学研究基础，以下是一些学习记录。
1基础知识 实验室安全等级划分
BSL1微生物：是已知所有特性，危害较低，不致病的微生物BLS2微生物：采用P2防护，主要防护措施为二级生物安全柜和防护服BSL3微生物：是易传播，严重致病甚至致命，虽有预防和治疗措施，但危害巨大的微生物BLS4微生物：是最高危险类别的微生物，这类微生物没有明确的已知预防和治疗措施，具有高度危害性并致命，通常通过气溶胶途径传播或传播途径不明 实验动物福利与伦理概述
实验动物：
经人工培育、对其携带的微生物实行控制、遗传学背景明确或来源清楚，用于科学研究、教学、生物制品或药品鉴定及其他科学实验的动物。
实验动物福利：
是指人类保障实验动物健康和快乐生存权利的理念及其所提供的相应外部条件的总和。
实验动物福利涵盖的因素：
动物自身因素：种类 遗传 性别 年龄环境因素：温度 湿度 换气次数 光照周期 噪音和粉尘营养因素：实验动物营养需求与饲料平衡 饲料口感与口味 饲料卫生与储存 饲喂方式技术因素：保定 麻醉 给药技术 手术 术后护理 采样 检测 安死术 SCI介绍
1.三大科技文献检索系统
SCI：科学引文索引
包括五种索引：引文索引
专利引文索引
来源索引
单位/机构索引
轮排主题索引
ISTP：科技会议索引
EI：工程索引
2.相关术语
JCR：《期刊引用报告》Journal Citation ReportsQuartile：四分位数 一般划分为四个等级 Q1-Q4IF：某刊前两年发表论文在该年的被引用次数/该刊前两年发表论文总数 3.JCR期刊分区
JCR期刊分区：Q1、Q2、Q3、Q4中科院期刊分区：1区、2区、3区、4区 4.常见顶级期刊
NatureScienceCellPNASJACSANGEWCell Research 5.主要英文数据库
WSci-FinderPubMedHighWire PressBlackwellElsevierSpringerWileyRSCACS 6.文献查阅简介
Web of Science 7.文献阅读解析
题目作者作者信息摘要关键词介绍实验结果和讨论总结致谢参考文献 8.主要数据库
NCBIJGIKEGGEBI/DDBJ 9.蛋白质分析
蛋白质特征预测：expasy
跨膜区域测试工具：TMHMM Serve
蛋白质预测：
PREDICT
PROTEIM
GO
蛋白质功能预测：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80b8f4f60e0f0f11c20820a42e2cc00e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/953c990497e649f00b65d40163a8897f/" rel="bookmark">
			查看电脑显卡（GPU）是否支持CUDA及其版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近想要试一下tensorflow和mindspore的GPU版本，于是乎倒腾了一下电脑，想要看一下电脑是否支持GPU以及是哪一个版本
预备知识： 什么是GPU？
CUDA（Compute Unified Device Architecture），是显卡厂商NVIDIA推出的运算平台。 CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。
查看方法 （1）打开NVIDIA控制面板。可以通过直接搜索打开。
（2）打开后可以在界面上可以查看NVIDIA的一些信息，显卡的驱动版本，如左侧菜单所示。
（3）点击【帮助】菜单，并选择【系统信息】选项
（4）在系统信息窗口里有两个菜单页面：显示和组件。
（5）选择【组件】，并在3D设置模块，找到NVCUDA.DLL，在该行，可以看到该NVCUDA的版本。
像我这里就是NVIDIA11.8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e16af2f0310eb55e2c353e589a169866/" rel="bookmark">
			Python经典数学算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		i = 2 while(i &lt; 100): j = 2 while(j &lt;= (i/j)): if not(i%j): break j = j + 1 if (j &gt; i/j) : print i, " 是素数" i = i + 1 print "Good bye!" Python素数
def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s Python的n次方
def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum Python平方相加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e16af2f0310eb55e2c353e589a169866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19cb27568865cf0b0d5c3e34eb070d22/" rel="bookmark">
			研究生算法课程笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.1、最长合法区间题目题解 1.2、Ahpelios会数数题目题解 1.3、kstring题目题解 1.4、杰哥与数字题目题解 2.1、杰哥和序列题目题解 2.2、YY and Lucky Number题目题解 2.3、YY and One题目题解 1.1、最长合法区间 题目 题解 C语言代码
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int max(int a, int b) { return a &gt; b ? a : b; } int main() { int n; scanf("%d", &amp;n); int *arr = (int *)malloc(n * sizeof(int)); int flags[100000]; int i = 0; for (i = 0; i &lt; n; i ++) { scanf("%d", &amp;arr[i]); } i = 0; int j = 1; int maxIntervel = 1; int count = 1; flags[arr[i]] = 1; int iNum, jNum; while (j &lt; n) { jNum = arr[j]; flags[jNum] ++; if (flags[jNum] == 1) { count ++; while (count &gt; 2) { iNum = arr[i]; flags[iNum] --; if (flags[iNum] == 0) { count --; } i ++; } } maxIntervel = max(maxIntervel, j - i + 1); j ++; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19cb27568865cf0b0d5c3e34eb070d22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ac42e9d7e1a8190a52868e063fcefe/" rel="bookmark">
			安装 torchvision
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(pytorch) C:\Users\ThinkStation\Desktop&gt; pip install torchvision -i http://pypi.douban.com/simple --trusted-host pypi.douban.co m Looking in indexes: http://pypi.douban.com/simple Collecting torchvision Downloading http://pypi.doubanio.com/packages/3d/f1/406aaf7a71f0c49b9ca5ea331fdc5c81b8339e6a47ad0aa12848caaf938a/torchvision -0.11.3-cp36-cp36m-win_amd64.whl (985 kB) |████████████████████████████████| 985 kB 1.3 MB/s Requirement already satisfied: numpy in d:\users\thinkstation\anaconda3\envs\pytorch\lib\site-packages (from torchvision) (1.1 9.5) Requirement already satisfied: pillow!=8.3.0,&gt;=5.3.0 in d:\users\thinkstation\anaconda3\envs\pytorch\lib\site-packages (from t orchvision) (8.4.0) Collecting torch==1.10.2 Downloading http://pypi.doubanio.com/packages/c4/49/9da10fef2c2ba8ff91eeab70a123ca60d082b1012b3aff7825c9b1115852/torch-1.10. 2-cp36-cp36m-win_amd64.whl (226.6 MB) |████████████████████████████████| 226.6 MB 2.2 MB/s Collecting dataclasses Downloading http://pypi.doubanio.com/packages/fe/ca/75fac5856ab5cfa51bbbcefa250182e50441074fdc3f803f6e76451fab43/dataclasses -0.8-py3-none-any.whl (19 kB) Collecting typing-extensions Downloading http://pypi.doubanio.com/packages/45/6b/44f7f8f1e110027cf88956b59f2fad776cca7e1704396d043f89effd3a0e/typing_exte nsions-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67ac42e9d7e1a8190a52868e063fcefe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41648a4d935f0105c5f4399101128790/" rel="bookmark">
			chrome 报错 mixed content 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览器请求借口的时候报错: 已屏蔽：mixed content 这个错误出现的原因 是我们请求接口的时候发送的请求是http的请求或者https 后台设置的芋泥请求的不一致 这时候我们只需要增加s就可以解决问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/681a1b8798f1bf1dffe6e46e1a3b06c2/" rel="bookmark">
			MySQL删除表数据 MySQL清空表数据命令 3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MySQL清空表数据命令：truncate SQL语法：
truncate table 表名; 注意：
不能与where一起使用。
truncate删除数据后是不可以rollback的。
truncate删除数据后会重置Identity（标识列、自增字段），相当于自增列会被置为初始值，又重新从1开始记录，而不是接着原来的ID数。
truncate删除数据后不写服务器log，整体删除速度快。
truncate删除数据后不激活trigger(触发器)。
二、MySQL删除表命令：drop SQL语法：
drop table 表名; 或者是
drop table if exists 表名; 注意：
truncate只会清除表数据，drop不光清除表数据还要删除表结构。
三、MySQL清空数据表内容的语法：delete SQL命令：
delete from 表名 where id='1'; 或
delete from 表名; 注意： delete含义：你要删除哪张表的数据 ?你要删掉哪些行 ?
delete可以删除一行，也可以删除多行；
如果不加where条件，则是删除表所有的数据，这是很危险的！不建议这样做！
总结： 1、当你不再需要该表时， 用 drop;
2、当你仍要保留该表，但要删除所有数据表记录时， 用 truncate;
3、当你要删除部分记录或者有可能会后悔的话， 用 delete。
原文链接：https://blog.csdn.net/qq_49912622/article/details/122882008
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/892735f7634031cc2572392dde7a9b24/" rel="bookmark">
			VScode配置C&#43;&#43;时遇到的几个问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基本安装1. #include出现波浪线:安装mingw并配置改正：需要添加include文件位置 2. vscode exe does not exist3. 调试时,数组不显示元素值：安装msys中文乱码文件中注释乱码修改编码格式以正常显示重新设置编码格式 控制台输出中文乱码 后续改进F6即可运行的插件一保存{}就换行关闭自动格式化 多文件时报错: undefined reference to `XXX’解决办法参考文章安装项目生成插件配置并编译运行 解决方法2：安装cmakeVSCODE运行时找不到include文件夹的头文件 本文所有安装包链接：https://pan.baidu.com/s/1eBidCewdNHaGJfZwGkhR2A?pwd=6666
提取码：6666
基本安装 基本的安装步骤参考安装VSCode并配置C++编程环境.
MinGW下载安装
参考Windows10安装MinGW-w64:https://sourceforge.net/projects/mingw-w64/files/在VS商店里安装C/C++,安装Code Runner. 1. #include出现波浪线:安装mingw并配置 改正：需要添加include文件位置 参考小白求助vscode配置问题，include老是波浪线。
下面这个位置作为头文件的查找位置，需要被加入到c_cpp_properties.json中。(c_cpp_properties.json 官方文档)
那么这个文件在哪里呢?首先鼠标滑过波浪线,选择快速修复,然后,编辑includePath,就会在左侧栏出现这个文件。如下：
在设置Intelligence界面选择编译器位置，
同时可以看到，左侧出现了一个.vscode文件夹,其中就有.json文件.
那么头文件的位置是如何确定的呢? 是安装MinGW时产生的。
注意，这里把\换成了/。
2. vscode exe does not exist 参考如何解决 vscode exe does not exist 的问题。新建一个文件夹 -&gt; 新建.c文件，编辑代码 -&gt; F5运行 -&gt; C++(GDB/LLDB) -&gt; 生成文档。
3. 调试时,数组不显示元素值：安装msys VS code 2019 解决调试看不了数组，vector，set等容器内部值的问题(pretty-printting).
根据这篇博文,自己实践了一次,真正需要做的就两步.（尝试过题主的解答，后面出错了一些，所以记录一下）。在这里下载，我下载的是msys2-x86_64-20220319.exe版本
1.下载安装msys2完成后，运行msys2,将bin目录添加至环境变量,并且一定要确保,新的目录在老的编译器bin目录之前。
2.在launch中添加一个选项:
{ "configurations": [ { //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/892735f7634031cc2572392dde7a9b24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bf9a3099cb2596f3bf478fb8820a5a3/" rel="bookmark">
			实习记录（H5页面）微信扫描二维码登陆注册，随后跳转浏览器。实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 1.微信跳转至浏览器，按钮样式与触发弹窗改变？2.安卓与ios的下载***app3.解析url，获取地址栏携带的参数4. 手机验证码登录5. 用户协议和隐私协议 总结 实习记录，碰到的自己没有解决的问题，问了人才知道怎么实现的功能 1.微信跳转至浏览器，按钮样式与触发弹窗改变？ 代码如下（示例）：
在浏览器打开的页面部分显示：
&lt;div v-if="!wei" class="noweixin" &gt; &lt;van-button type="promary" class="btn" @click="judge('open')" &gt; 立即打开 &lt;/van-button&gt; &lt;van-overlay :show="show" @click="show = false" &gt; &lt;div class="big_pop" @click.stop &gt; &lt;span class="text_6"&gt;无法打开&lt;/span&gt; &lt;span class="text_7"&gt;可能您尚未安装***App,点击立即下载试试吧~&lt;/span&gt; &lt;button class="left_pop" @click="show = false" &gt;取消&lt;/button&gt; &lt;button class="right_pop" @click=" down " &gt;下载&lt;/button&gt; &lt;/div&gt; &lt;/van-overlay&gt; &lt;/div&gt; 在微信内置浏览器打开的部分：
&lt;div v-if="wei" class="inweixin" &gt; &lt;van-button type="primary" class="btn" @click="judge('weixin')" &gt; 登录成功，立即打开 &lt;/van-button&gt; &lt;van-overlay :show="isweixin" @click="isweixin = false" &gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bf9a3099cb2596f3bf478fb8820a5a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/888a303fa4f51753578dddbbed3a0729/" rel="bookmark">
			各厂商服务器存储设备默认密码大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、服务器设备默认管理
1、宝德4卡服务器
默认用户名：ADMIN/密码：11111111 2、超微服务器
默认用户名：ADMIN/密码：admin000 默认用户名：ADMIN/密码：ADMIN 3、浪潮服务器
型号:NF5270M4 管理地址：手动配置 默认用户名：admin/密码：admin 型号:NF5270M2 管理里地址：192.168.1.100 默认用户名：admin/密码：admin 4、IBM服务器
IBM P小型机ASMI 管理地址：hmc1:192.168.2.147 用户名：admin/密码：admin 管理地址：hmc1:192.168.3.147 用户名：admin/密码：admin IBM X系列MM端口 管理地址：192.168.70.125/25 用户名：USERID/密码：PASSW0RD 5、华为服务器
E6000 系列 管理地址：10.10.1.101-10.10.1.110 用户名：root /密码：Huawei12#$ RH2288 v3 系列 管理地址：192.168.2.100 用户名：root /密码：Huawei12#$ RH2288 v5系列 管理地址：192.168.2.100 用户名：Administrator /密码：Admin@9000 T600 系列 管理地址：10.10.1.101-10.10.1.102 用户名：root /密码：Huawei12#$ X6000系列 管理地址：10.10.1.101-10.10.1.104 用户名：root /密码：Huawei12#$ V3服务器BIOS系统的默认密码为:“Huawei12#$” V5服务器BIOS系统的默认密码为:“Admin@9000”。 BIOS系统只能修改默认iBMC用户的密码。V3服务器的iBMC默认用户为root，默认密码为Huawei12#$；V5服务器的iBMC默认用户为Administrator，默认密码为Admin@9000。 6、H3C服务器
R4900-G2系列 管理地址：192.168.1.2/24 用户名：admin /密码：Password@_ 7、Dell服务器
IDRAC系列 管理地址：192.168.0.120 用户名：root /密码：calvin 8、联想服务器
RQ940系列 管理地址：192.168.0.120 用户名：lenovo /密码：len0vO RD530/RD630/RD540/RD640 管理地址：手动配置 用户名：lenovo /密码：lenovo 万全R520系列 管理地址：手动该设置 用户名：lenovo /密码：lenovo 9、曙光服务器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/888a303fa4f51753578dddbbed3a0729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eb831ec06d56c1d37aa053894c4c945/" rel="bookmark">
			ASP.NET Core 3.1系列（15）——EFCore之DB First
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 本文开始介绍一些关于Entity Framework Core的内容。在EFCore中，常用的为DB First模式和Code First模式，下面就来介绍一下如何在EFCore中使用DB First模式生成实体类和数据库上下文。
2、创建测试数据库 在SQL Server中新建一个数据库Dao，执行如下语句，创建Country和Province数据表。
USE [Dao] GO /****** Object: Table [dbo].[Country] Script Date: 2022/11/30 8:52:23 ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE TABLE [dbo].[Country]( [Id] [int] IDENTITY(1,1) NOT NULL, [CountryName] [nvarchar](20) NULL, CONSTRAINT [PK_Country] PRIMARY KEY CLUSTERED ( [Id] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY] GO USE [Dao] GO /****** Object: Table [dbo].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eb831ec06d56c1d37aa053894c4c945/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2d926d8606f5d006d69df34f177a9c1/" rel="bookmark">
			orCAD Capture 批量修改Value和Footprint 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开原理图，选中XXX.dsn;
2.选择Edit,下拉菜单Browse下Parts进入属性编辑框:
3.选择一个要编辑的Part Reference,在按Shift,选择部分要编辑的元器件，按键盘Ctrl+E进入编辑界面: 4.选择Part Reference，按键盘Ctrl+Insert复制到.txt或者.xls文件，粘贴Ctrl+V快捷键：
5.批量修改或者替换属性，修改完按Ctrl+C快捷键复制：
6.将复制好的修改属性，按键盘 Shift+Insert 粘贴会Capture 的 Browse Spreadsheet ,点击 OK 保存：
.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c789d91e095d03add0a691b928cb5a1e/" rel="bookmark">
			python创建树结点——分支限界法解决0-1背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python创建树结点——分支限界法解决0-1背包问题 介绍 python构建结点时注意灵活使用class类，可以灵活使用树的结构体，也可以灵活在一个类里面封装多个函数方法。以下是定义树结点的一个方法——之前没试过python定义树节点。然后创建新节点的时候可以直接用flag代表是上一个结点的左/右结点，father代表父节点。
示例 如下所示
class node: #定义树结点 def __init__(self, father, flag,……): self.father = father#该结点的父节点 self.flag = flag#代表左节点或右节点——本题是指取物品或不取物品 self.…… 实战 下面附带做练习题分支限界法的python代码（参考了别人的）但好像别分支限界代码有点小问题但问题不大改改就好。
参考文章：
四种方法解0-1背包问题-基于python
补充——分支限界法算法思想
（1）首先，要对输入数据进行预处理，将各物品依其单位重量价值从大到小进行排列。
（2）在下面优先队列分支限界法中，节点的优先级由已装袋的物品价值加上剩下的最大单位重量价值的物品装满剩余容量的价值和。
每次选择扩展结点都选择最大预估价值和。这些待选择的队列结点都是所谓的“活结点”（当然本题示例代码是顺序队列，也即按照依次进入队列先后顺序，来逐渐把队列结点消耗完）消耗：即指队列中结点已经扩展完。
这一部分由bound函数计算价值上界。注意剩下的物品计算价值是可以首先单个物品全部装入，再单个物品部分装入。
（3）算法首先检查当前扩展结点的左儿子结点的可行性。如果该左儿子结点是可行结点，即满足约束条件，则将它加入到子集树和活结点优先队列中。当前扩展结点的右儿子结点一定是可行结点（可以满足约束条件），仅当右儿子结点满足上界限界函数时才将它加入子集树和活结点优先队列。当扩展到叶节点时为问题的最优值。
#分支限界法 import numpy as np class branchbound: def __init__(self, w, v, c, cw, cp, bestx):#初始化赋值 self.w = np.array(w) self.v = np.array(v) self.c = c self.cw = cw self.cp = cp self.bestx = bestx def value_sort(self): #求单位质量大小 并降序排列 per = self.v / self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c789d91e095d03add0a691b928cb5a1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/619b4c6e7bbcfec2aecab7c32ba786e1/" rel="bookmark">
			【KCP】UDP可靠性传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 如何做到可靠性传输 ◼ ACK机制 ◼ 重传机制 ◼ 序号机制 3 2 1 -》2 3 1 ◼ 重排机制 2 3 1 -&gt;3 2 1 ◼ 窗口机制 Tcp不用我们管 可靠性udp 5种机制都需要用户层处理
2 UDP与TCP，我们如何选择 3 UDP如何可靠，KCP协议在哪些方面有优势 以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。
RTO翻倍vs不翻倍： TCP超时计算是RTOx2，这样连续丢三次包就变成RTOx8了，十分恐怖，而 KCP启动快速模式后不x2，只是x1.5（实验证明1.5这个值相对比较好）， 提高了传输速度。 200 300 450 675 – 200 400 800 1600
选择性重传 vs 全部重传： TCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传， 只重传真正丢失的数据包。 快速重传（跳过多少个包马上重传）（如果使用了快速重传，可以不考虑 RTO））： 发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4, 5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。 fastresend =2
延迟ACK vs 非延迟ACK： TCP为了充分利用带宽，延迟发送ACK（NODELAY都没用），这样超时计算会算出较大 RTT时间，延长了丢包时的判断过程。KCP的ACK是否延迟发送可以调节。
UNA vs ACK+UNA： ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而 KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/619b4c6e7bbcfec2aecab7c32ba786e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24c21a673faf1efe5da125a685a7be4/" rel="bookmark">
			【用户态协议栈】用户态协议栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络通信方式 从网卡取到一个完整的数据的方式：
raw socketnetmapdpdk 负载均衡产品：
nginx：工作在应用层haproxy：工作在传输层lvs：工作在网络层f5：工作在数据链路层 网络协议栈
MAC地址是以太网产物IP地址是网络层产物port端口是传输层产物NAT转换ip+端口网络地址映射工作是在传输层的 内核协议栈与用户协议栈区别 内核协议栈 用户态协议栈 UDP、ICMP、ARP用户态协议栈设计 协议头 以太网协议头 IP协议头 UDP协议头 ARP协议 ICMP协议 数据帧 UDP数据帧 UDP数据帧协议栈设计代码示例 基于netmap实现UPD数据帧处理的用户态协议栈。
#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/poll.h&gt; #include &lt;arpa/inet.h&gt; #define NETMAP_WITH_LIBS #include &lt;net/netmap_user.h&gt; //netmap库 #pragma pack(1) //结构体以1个字节进行字节对齐 #define ETH_ALEN	6 #define PROTO_IP	0x0800 #define PROTO_ARP	0x0806 #define PROTO_UDP	17 #define PROTO_ICMP	1 #define PROTO_IGMP	2 //以太网头 struct ethhdr { unsigned char h_dest[ETH_ALEN];	//目的地址 unsigned char h_source[ETH_ALEN];	//源地址 unsigned short h_proto;	//类型 }; //ip头 struct iphdr { unsigned char version;	//版本(4位版本+4位首部长度) unsigned char tos;	//服务类型 unsigned short tot_len;	//总长度(字节数) unsigned short id;	//标识 unsigned short flag_off;	//偏移(3位标志+13位偏移) unsigned char ttl;	//生存时间 unsigned char protocol;	//协议 unsigned short check;	//首部检验和 unsigned int saddr;	//源IP unsigned int daddr;	//目标IP }; //udp头 struct udphdr { unsigned short source; //源端口 unsigned short dest; //目标端口 unsigned short len; //udp长度 unsigned short check; //udp校验 }; //udp数据包 struct udppkt { struct ethhdr eh;	//以太网头 struct iphdr ip;	//ip头 struct udphdr udp;	//udp头 unsigned char body[128];	//数据 }; struct arphdr { unsigned short h_type; unsigned short h_proto; unsigned char h_addrlen; unsigned char protolen; unsigned short oper; unsigned char smac[ETH_ALEN]; unsigned int sip; unsigned char dmac[ETH_ALEN]; unsigned int dip; }; struct arppkt { struct ethhdr eh; struct arphdr arp; }; struct icmphdr { unsigned char type; unsigned char code; unsigned short check; unsigned short identifier; unsigned short seq; unsigned char data[32]; }; struct icmppkt { struct ethhdr eh; struct iphdr ip; struct icmphdr icmp; }; void print_mac(unsigned char *mac) { int i = 0; for (i = 0;i &lt; ETH_ALEN-1;i ++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c24c21a673faf1efe5da125a685a7be4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aedc30bb8492d9a4ae8b2634da924863/" rel="bookmark">
			【Linux内核】Linux内核介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux学习内核思路 学习过程：
Linux内核引导及如何初始化进程管理、内存管理 内核引导及过程：
CPU通电后，首先执行引导程序，引导程序把内核加载到**内存，**然后执行内核，内核初始化完成后，启动用户空间的进程。CPU通电后，自动把程序计数器设置为CPU厂商设计的某个固定值。嵌入式设备通常用NOR闪存作为只读存储器存放引导程序。
嵌入式设备通常使用U-Boot作为引导程序。
函数_main ENTRY(_main)–&gt;U-&gt;boot程序初始化完成之后，准备处理命令是通过数组init_sequence_r，最后一个函数run_main_loop()实现。
kernel_entry()–&gt;start_kernel()ARM架构下SMP系统自旋表引导过程？（内核技术面试） 引导处理器启动从处理器方法3种：
a. 自旋表
b. 电源状态协调接口
c. ACPI停车协议
用户空间和内核空间：
系统调用：
进程：
内存：
文件系统：
网络：
Linux内核源码 Linux内核版本介绍 linux版本分为两类：
内核版本：免费的，它只是操作系统的核心，负责控制硬件、管理文件系统、程序进程等，并不给用户提供各种工具和应用软件；发行版本：不一定免费，出了操作系统核心外，还包含一套强大的软件，例如：C／C++编译器和库等 内核版本 1.1）内核版本命名：
Linux内核版本号由3组数字组成：第一个组数字.第二组数字.第三组数字
第一个组数字：目前发布的内核主版本。第二个组数字：偶数表示稳定版本；奇数表示开发中版本。第三个组数字：错误修补的次数。 可以使用uname -r 查看内核版本号，例如：2.6.32-754.2.1.el6.x86_64
第一个组数字: 2 , 主版本号第二个组数字: 6 , 次版本号，表示稳定版本(因为有偶数)第三个组数字: 32 , 修订版本号 ，表示修改的次数。第四个组数字: 754.2.1，表示发型版本的补丁版本，这里是 CentOS 6.10 。el6 则表示我正在使用的内核是 RedHat / CentOS 系列发行版专用内核；x86_64 表示64位cpu。 除了前面的版本号外，最后的有多种，例如：2.6.32-358.6.1.el6.i686、2.6.18-128.ELsmp、2.6.32-642.el6.x86_64
EL : Enterprise Linux ；ELsmp：指出了当前内核是为EL特别调校的，其中smp : 表示支持多处理器 ， 表示该内核版本支持多处理器；i386：几乎任何的X86平台，不论是旧的pentum或是新的pentum-IV和K7系统CPU，都能够正常工作，i指得是Intel兼容的CPU，至于386就是CPU的等级；i586：就是586等级的电脑，包括pentum第一代MMX CPU，AMD的K5，K6系统CPU（socket7插脚）等CPU都是这个等级；i686：pentum 2 以后的Intel系统CPU及K7以后等级的CPU都属于这个686等级；x86_64：采用的是64位的CPU；generic：当前内核版本为通用版本，另有表示不同含义的server（针对服务器）；pae（Physical Address Extension）：物理地址扩展，为了弥补32位地址在PC服务器应用上的不足而推出，表示此32位系统可以支持超过4G的内存 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aedc30bb8492d9a4ae8b2634da924863/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74bff64b13e50c51adf45b7a2e21a58c/" rel="bookmark">
			2022-3-21 课题设计：基于单片机的DS18B20测温（数码管显示）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基于单片机的DS18B20测温（数码管显示）
说明：代码和仿真图可直接下载使用，仿真软件用的是Proteus8.10，编程用的是keil4
该系统由51单片机和DS18B20温度传感器及四位共阳极数码管组成
功能为通过1820传感器测出温度传输到数码管显示
还可以扩展按键设置温度的上下限
加上蜂鸣器等实现阈值报警等功能
针对DS18B20传感器
这里需要做一点说明
单总线1820传感器有很高的时序要求
如果在模拟仿真过程中延时达不到要求是不能转换出正确的温度的
我自己有驱动代码 用在15单片机上很正常
但是将此驱动代码用在51仿真中就得不到正确的温度
其原因就是因为时序不同 达不到要求 所以得不到正确的温度
经过调整现在的代码已经能正确的测温了
代码和仿真图大家可以直接下载使用
以下是仿真的测温图片
部分代码如下：
void main() { //rd_temperature(); while(1) { //T=rd_temperature(); read_temp(); display1(tvalue/100,tvalue%100/10); display2(tvalue%10,10); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67e26f14a6cfaebe60bdeb8c58fa11b5/" rel="bookmark">
			Ubuntu16.04使用sudo add-apt-repository时报错：aptsources.distro.NoDistroTemplateException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用sudo add-apt-repository 时候，系统报错：
Traceback (most recent call last): File "/usr/bin/add-apt-repository", line 96, in &lt;module&gt; sp = SoftwareProperties(options=options) File "/usr/lib/python3/dist-packages/softwareproperties/SoftwareProperties.py", line 114, in __init__ self.reload_sourceslist() File "/usr/lib/python3/dist-packages/softwareproperties/SoftwareProperties.py", line 607, in reload_sourceslist self.distro.get_sources(self.sourceslist) File "/usr/lib/python3/dist-packages/aptsources/distro.py", line 89, in get_sources (self.id, self.codename)) aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template for Kylin/kylin 原因：
我装了ukylin优麒麟系统的软件（ukylin-wine和ukylin-wechat），导致Ubuntu的系统配置lsb-release文件被修改了。而且系统设置中的software&amp;updates都打不开了！
可以看到/etc/lsb-release文件的内容变成了这样：
DISTRIB_ID=Kylin DISTRIB_RELEASE=V10 DISTRIB_CODENAME=kylin DISTRIB_DESCRIPTION="Kylin V10 SP1" DISTRIB_KYLIN_RELEASE=V10 DISTRIB_VERSION_TYPE=enterprise DISTRIB_VERSION_MODE=normal 解决方法：
修改/etc/lsb-release里面的内容：
DISTRIB_ID=Ubuntu DISTRIB_RELEASE=16.04 DISTRIB_CODENAME=xenial DISTRIB_DESCRIPTION="Ubuntu 16.04.5 LTS" 注： 具体的发型号是16.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67e26f14a6cfaebe60bdeb8c58fa11b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf034cac716f7af97d884511fcfca88f/" rel="bookmark">
			解决ubuntu22.04不能使用todesk问题（显示没有x11桌面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个版本默认使用的是Wayland
所以可能有点问题，
x11的适配比较好，也懒得对比了，毕竟todesk好用多了
sudo nano /etc/gdm/custom.conf 将WaylandEnable=false前面的注释去掉
ctrl+y保存退出
重启就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9a19c935133cb45c032849b22826af8/" rel="bookmark">
			利用MATLAB求解积分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在高等数学中，我们经常需要进行积分计算操作，积分在高等数学中占用比较重要的作用，在MATLAB中主要提供了int函数用于对于符号进行求积分的操作。
目录
积分的定义
int函数的调用方式
利用MATLAB中的int函数进行计算的例子
积分的定义 积分微积分学与数学分析里的一个核心概念。通常分为定积分和不定积分两种。直观地说，对于一个给定的正实值函数，在一个实数区间上的定积分可以理解为在坐标平面上，由曲线、直线以及轴围成的曲面梯形的面积值（一种确定的实数值）。（本段定义引自百度百科积分）
int函数的调用方式 int函数的有以下几种调用方式：
（1）int(y)：这种情况下仅仅指定被积分的函数，没有添加其他的条件，此时MATLAB会按照系统默认的情况下对该符号表达式对其求不定积分。
例如，对于的符号表示进行积分操作：
​ MATLAB的代码如下所示：
syms x y=1/(x^2); int(y) 运行结果如下所示：
ans = -1/x int(y)是MATLAB最简单的对于int函数的调用方式，可以方便对于对于不定积分的求解。
（2）int(y,x)：这种调用下，是对于符号表达式y中指定于自变量x进行积分。
例如：
MATLAB代码如下所示：
syms x a y=int(a/(sqrt(1+x^2)),x) 运行结果如下所示：
y = a*asinh(x) 当符号表达式中有多个变量的时候，可以使用这种调用方式对于指定自变量进行求解。
（3）int(y,x,floor,ceil) ：这种调用方式用于y对于自变量x进行积分，其中floor表示的定积分的下限，而ceil表示的是定积分的上限，这种方式实际上是求解定积分的方式，函数所求的结果是定积分的结果。当floor和ceil中有Inf的值时候，则表示这是一个广义积分。
例如下面举例一个简单的定积分题目：
MATLAB代码如下所示：
syms x y y=2*x+3; int(y,x,1,3) 运行结果如下所示：
ans = 14 利用MATLAB中的int函数进行计算的例子 当然在实际求解问题的时候，我们常常会遇到各种的符号表达式，下面这部分对于一些符号表达式进行求定积分和不定积分的操作。
下面我们利用MATLAB对于下面的例子求不定积分：
利用MATLAB进行求解的代码如下所示：
syms x y1=int(1/(sin(x)^2*cos(x)^2),x) y2=int((x^2)/(1+x^2),x) y3=int(tan(x)/(sqrt(cos(x))),x) y4=int(1/(1+exp(x)),x) 运行结果如下所示：
y1 = -2*cot(2*x) y2 = x - atan(x) y3 = 2/cos(x)^(1/2) y4 = x - log(exp(x) + 1) 利用MATLAB对于下面示例求定积分：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9a19c935133cb45c032849b22826af8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc2c14ad0053ce3acf81b9c75967c1f4/" rel="bookmark">
			JS 逆向实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、百度翻译(入门级) 首先分析网络响应包，由名字和响应内容可知 v2transapi 是需要分析的包
网络响应包 点击启动器，根据经验，send 和 ajax 都涉及 jquery 等源码，前端程序员不会轻易修改，因此需要分析的是下面的 langIsDeteced，跳转到引用的 js 代码
启动器 上下划拉代码，可以在上方发现和请求内容相近的代码结构
js 代码 经过测试(多次发送请求，查看响应内容)得知 from 是待翻译语言，to 是翻译后语言，query 是翻译内容，transtype、simple_means_flag、token、domain 都是不会变的常量，只需要搞懂 sign 的来源即可
from: en to: zh query: apple transtype: realtime simple_means_flag: 3 sign: 704513.926512 token: 6497866f6ec9f4375ff3a9730c4a1bb7 domain: common 回到代码，点击 sign: b(e) 左侧的代码行，为其打上断点，在页面中重新输入任意单词(重新发送请求)，注意到 b() 对应了某个函数，点击注解中的蓝色链接
调试 跳转到了具体的函数，也是说只要执行这个函数就可以获取 sign 值，因此将其复制到本地，打算测试是否能正常运行
跳转的函数 使用 NodeJS 直接运行测试，发现不能直接运行，报错提示 r 未定义，于是回到浏览器的跳转函数中寻找 r，同样以打断点的方式调试，得到 r 竟然也是个字符串常量 "320305.131321201"
本地代码 在本地代码中用常量替换 r，继续使用 NodeJS 直接运行测试，但是依然报错，报错显示 n 未定义，回到浏览器跳转函数继续调试，找到了 n 函数，将其放进本地代码中，最终成功跑出结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc2c14ad0053ce3acf81b9c75967c1f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e9b5ae853770538751b8f962153f0d/" rel="bookmark">
			上标下标汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0到9小数字符号： 上标：º ¹ ² ³ ⁴⁵ ⁶ ⁷ ⁸ ⁹ ⁺ ⁻ ⁼ ⁽ ⁾ ⁿ ′ ½
下标：₀ ₁ ₂ ₃ ₄ ₅ ₆ ₇ ₈ ₉ ₊ ₋ ₌ ₍ ₎
常用上标 ⁰⁴⁵⁶⁷⁸⁹⁺⁻⁼⁽⁾ⁿ˙ 常用下标 ₀₁₂₃₄₅₆₇₈₉₊₋₌₍₎ₐₑₒₓₔₕₖₗₘₙₚₛₜ 中文上标 ㆒㆓㆔㆕㆖㆗㆘㆙㆚㆛㆜㆝㆞㆟ 更多上标 ᵃ ᵇ ᶜ ᵈ ᵉ...
ᵃ ᵇ ᶜ ᵈ ᵉ ᵍ ʰ ⁱ ʲ ᵏ ˡ ᵐ ⁿ ᵒ ᵖ ᵒ ʳ ˢ ᵗ ᵘ ᵛ ʷ ˣ ʸ ᙆ ᴬ ᴮ ᒼ ᴰ ᴱ ᴳ ᴴ ᴵ ᴶ ᴷ ᴸ ᴹ ᴺ ᴼ ᴾ ᴼ̴ ᴿ ˢ ᵀ ᵁ ᵂ ˣ ᵞ ᙆ
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49e9b5ae853770538751b8f962153f0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3719567cec0454800526bb557903cd48/" rel="bookmark">
			pandas的行列获取/pandas iloc和loc的使用/如何获取pandas的行和列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas行和列的获取 由于平时没有系统的学习pandas，导致在实际应用过程中，对于获取df中的行和列经常出现问题，于是总结一下，供自己以后参考。
参考的书籍在线版链接：利用 Python 进行数据分析 · 第 2 版
0 查看手册 请当你看完1-5的内容再来看该部分，用于理解和以后的查询。
功能获取列df.loc[: , 列名序列]df.iloc[ : , 列索引序列]df[列名序列]获取行df.loc[行名序列]df.iloc[ 行索引序列]df[行名：列名]获取行和列1df.loc[行名序列,列名序列]df.iloc[ 行索引序列,列索引序列]获取行和列2df.loc[行名开始:行名结束,列名开始:列名结束]df.iloc[行索引开始:行索引结束,列索引开始:列索引结束] 序列的含义 由列名或者行名（列索引，行索引）组成的列表;
比如获取多列（行）， 方法为：df[['col1','col2']]当只获取一个列（行）的时候，可以直接填写，df['col1']。 切片的含义 类似于列表的切片，开始:结束，pandas会获取开始-&gt;结束之间的行（列）
切片时，loc包含两端点，左闭右闭；iloc不包含结束点，左闭右开
“:”表示行（列）切片的意思，行开始点:行结束点。
loc的用法 loc[行序列，列序列]分别表示获取指定的行序列和列序列范围的内容（iloc同理）
当只获取行的时候，列可以省略
当只获取列的时候，行不能省略，可以写作loc[ : , 列索引]，意思是所有行都选中
1 创建一个DataFrame作为示例 import pandas as pd # 创建一个df data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'], 'year': [2000, 2001, 2002, 2001, 2002, 2003], 'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]} frame = pd.DataFrame(data, columns=['year', 'state', 'pop', 'debt'], index=['one', 'two', 'three', 'four', 'five', 'six']) frame yearstatepopdebtone2000Ohio1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3719567cec0454800526bb557903cd48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b77c8dd01fb4d8b9ca477bb96f581f8/" rel="bookmark">
			使用PyQt5界面设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、环境搭建
二、Qt Designer设计GUI
三、生成界面代码
四、 创建调用该界面代码
五、 VScode运行效果
一、环境搭建 直接pip安装即可：
pip install PyQt5
pip install pyqt5-tools
二、Qt Designer设计GUI Qt Designer 是通过拖拽的方式放置控件，并实时查看控件效果进行快速UI设计。最终生成.ui文件，可以通过pyuic5工具转换成.py文件。
打开designer.exe；界面如下
三、生成界面代码 使用命令：pyuic5 -o Test.py Test.ui
# -*- coding: utf-8 -*- # Form implementation generated from reading ui file 'Test.ui' # # Created by: PyQt5 UI code generator 5.15.4 # # WARNING: Any manual changes made to this file will be lost when pyuic5 is # run again.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b77c8dd01fb4d8b9ca477bb96f581f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03a5b0847a58a25cd895d279b0891486/" rel="bookmark">
			从0开始的高翔SLAM十四讲环境配置（ch2-ch3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下环境配置均在Ubuntu18.04系统下进行，系统已经提前安装好VMware Tools
一、安装最基础的C++编译环境
（1）CMake（复制以下代码回车，输入密码，出现[Y/n]后输入Y即可自动下载相关配件，以下步骤同理）
sudo apt-get install cmake 在高翔提供的ch2代码中测试是否安装上cmake，打开文件ch2后端输入
mkdir build &amp;&amp; cd build cmake .. make 生成的文件保存在build文件夹，然后在终端输入
./helloSLAM 得到结果
Hello SLAM! （2）g++
sudo apt-get install g++ 在高翔提供的ch2代码中可以测试是否安装上g++，打开文件ch2后终端输入
g++ helloSLAM.cpp 这条编译命令就把helloSLAM.cpp文本文件编译为一个可执行程序，接着在终端输入刚刚产生的./a.out，即可运行此文件输出“Hello SLAM!”
./a.out Hello SLAM! （3）git
sudo apt-get install git 二、安装Eigen
#安装 sudo apt-get install libeigen3-dev #检查安装 pkg-config --cflags eigen3 #卸载 sudo apt-get remove libeigen3-dev #检查安装的版本 cat /usr/include/eigen3/Eigen/src/Core/util/Macros.h 我这里的版本是3.3.4（推荐最新版本）
#define EIGEN_WORLD_VERSION 3 #define EIGEN_MAJOR_VERSION 3 #define EIGEN_MINOR_VERSION 4 在高翔提供的ch3代码中测试能否运行，依次输入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03a5b0847a58a25cd895d279b0891486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76ca3c614aabd42c7f4e36b71e66e545/" rel="bookmark">
			tinymce富文本编辑器的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tinymce富文本编辑器的使用 1、基本介绍 tinymce富文本官网：https://www.tiny.cloud/
中文文档：http://tinymce.ax-z.cn/
tinymce-npm地址：https://www.npmjs.com/package/tinymce
tinymce英文文档-示例地址：https://www.tiny.cloud/docs/quick-start/
kindEditor富文本官网：http://kindeditor.net/demo.php
wangeditor富文本官网：https://www.wangeditor.com/
中文文档：https://www.wangeditor.com/demo/index.html
TinyMCE是一个轻量、简洁、功能强大的编辑器。公司之前使用过kindEditor和wangEditor。
kindEditor：功能强大，代码简洁，有常用的从txt和word复制、多图上传等功能，但是没有格式刷，运营的妹子经常反馈生成多余的空行，并且插入h5的video标签默认也会被过滤掉，项目到2016年便不再维护了。
wangEditor：轻量、简洁、易用，但是功能有限，没有多图上传、格式刷等功能。
鉴于此，便换上了TinyMCE，原因有三：
GitHub 上示例很多，一直在维护；从word粘贴和微信公众上复制过来的文章基本能保持原格式；插件丰富，官网提供了很多实用的插件，如多图上传，首行缩进，字数限制等，还可以自定义插件，方便拓展。 使用流程 1、引入TinyMCE 1、获取自己的API密钥 地址
2、下载tinymce.min.js到本地 地址
3、下载汉化js zh_CN.js 放到 langs目录下 汉化包下载
4、引入
&lt;script src="https://cloud.tinymce.com/5/tinymce.min.js?apiKey=官方申请的API_KEY"&gt;&lt;/script&gt; &lt;script src="tinymce.min.js"&gt;&lt;/script&gt; &lt;script src="tinymce/js/tinymce/langs/zh_CN.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;!--汉化--&gt; 初始化为页面
tinymce.init({ selector: '#mytextarea', language:'zh_CN',//注意大小写 }); 5.1、html
&lt;h1&gt;TinyMCE示例&lt;/h1&gt; &lt;form method="post"&gt; &lt;textarea id="mytextarea"&gt;Hello, World!&lt;/textarea&gt; &lt;/form&gt; 工具栏配置
tinymce.init({ selector: '#mytextarea', language:'zh_CN',//注意大小写 toolbar: 'undo redo | styleselect | bold italic | link image'//工具栏配置 }); 5.2、移动端
&lt;meta name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76ca3c614aabd42c7f4e36b71e66e545/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/184/">«</a>
	<span class="pagination__item pagination__item--current">185/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/186/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>