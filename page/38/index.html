<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3dddba8a7a66960064c0f7ff52cf441/" rel="bookmark">
			leetcode13 罗马数字转整数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：罗马数字由七种字符组成，分别为 I、V、X、L、C、D 和 M，对应的数值分别为 1、5、10、50、100、500 和 1000。在一般情况下，小的数字位于大的数字右边，但有特殊情况，如 IV 表示 4，IX 表示 9，XL 表示 40，XC 表示 90，CD 表示 400，CM 表示 900。给定一个罗马数字，需要将其转换成整数。
例如：罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。
方法1 模拟 该方法的思想类似于“对号入座”，找到什么罗马符号对应的什么值就写进去，但是最关键的是要搞清楚前后的加减关系，以Roman=“MCMXCIV”为例，第二个位置上的C所对应的值要比第三个位置上的M所对应的值要小，关于前后是进行加法运算还是减法运算，可以看下图的图解，通过图解就可以清楚的知道该如何进行运算。 python完整代码： class Solution: symbol_values = { "I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000 } def romanToInt(self, str): digital = 0 # 定义当前数字 n = len(str) # 罗马字数字长度 for i, ch in enumerate(str): value = Solution.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3dddba8a7a66960064c0f7ff52cf441/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8f13538b32a3611436a9ca16c45fc92/" rel="bookmark">
			C# .Net学习笔记—— 异步和多线程（Async和Sync）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 进程：一个程序运行时，占用的全部计算资源的总和
线程：1、程序执行流的最小单位；任何操作都是由线程完成的
2、线程是依托于进程存在的，一个进程可以包含多个线程；
3、线程也可以有自己的计算资源
多线程：多个执行流同时运行
1、CPU太快了，分时间片-一上下文切换（加载环境--计算-一保存环境）
微观角度，一个核同一时刻只能执行一个线程；宏观的来说是多线程并发
2、多CPU多核可以独立工作
4核8线程一核是物理的核线程是指虚拟核
同步：完成计算之后，再进入下一行
异步：不会等待方法的完成，会直接进入下一行非阻塞
C#异步和多线程有什么差别
多线程就是多个thread并发；
异步是硬件式的异步
异步多线程-thread pool task
二、同步异步简单案例 private void buttonSync_Click(object sender, EventArgs e) { Log.Info($"S Start {Thread.CurrentThread.ManagedThreadId}"); int j = 3; int k = 5; int m = j + k; for (int i = 0; i &lt; 5; i++) { string name = string.Format($"**********S{i}*************"); this.DoSomethingLong(name); } Log.Info($"S End"); } private void buttonAsync_Click(object sender, EventArgs e) { Log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8f13538b32a3611436a9ca16c45fc92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9e2c102606c6ece4a1503b70617419a/" rel="bookmark">
			使用Go语言采集1688网站数据对比商品价格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
一、数据采集原理
二、数据采集流程
三、数据采集代码实现
四、数据分析与比较
五、注意事项
六、结论
引言 随着电子商务的快速发展，越来越多的消费者开始通过在线平台购买商品。在众多电商平台中，1688作为中国最大的批发交易平台，拥有着丰富的商品资源和价格优势。然而，由于商品数量庞大，消费者往往难以找到最合适的商品和价格。因此，本文将介绍如何使用Go语言采集1688网站数据，并通过对比商品价格来帮助消费者做出更明智的购买决策。
一、数据采集原理 数据采集是指通过编写程序自动从互联网上获取所需信息的过程。在本例中，我们将使用Go语言编写一个爬虫程序，通过模拟浏览器行为，访问1688网站并提取商品信息和价格数据。
二、数据采集流程 1. 确定目标：首先，我们需要明确要采集的商品类型和价格范围。例如，我们可以选择采集手机配件类商品，价格范围在100元至500元之间。
2. 分析网页结构：通过观察1688网站的网页结构，我们可以发现商品信息和价格数据通常位于HTML标签中。因此，我们需要使用Go语言的HTML解析库来提取这些数据。
3. 编写爬虫程序：根据目标和网页结构，我们可以编写一个Go语言的爬虫程序，通过模拟浏览器行为，访问1688网站并提取商品信息和价格数据。
4. 数据处理：采集到的数据通常是原始的HTML代码，我们需要对其进行处理，提取出所需的商品信息和价格数据。可以使用Go语言的字符串处理函数和正则表达式来实现。
5. 数据存储：为了方便后续的数据分析和比较，我们可以将采集到的商品信息和价格数据存储到数据库或文件中。
三、数据采集代码实现 下面是一个使用Go语言编写的简单爬虫程序，用于采集1688网站手机配件类商品的价格数据：
package main import ( "fmt" "io/ioutil" "net/http" "regexp" ) func main() { // 目标网址 url := "https://www.1688.com/selloffer/search_index.htm?keywords=手机配件&amp;sortType=time&amp;descendOrder=true&amp;pageSize=20" // 发送HTTP请求 resp, err := http.Get(url) if err != nil { fmt.Println("Error:", err) return } defer resp.Body.Close() // 读取网页内容 body, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9e2c102606c6ece4a1503b70617419a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c53e910956f7555b58861de7fc93867/" rel="bookmark">
			Javascript学习之路：JS中的遍历跳出循环总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javascript中的遍历方法有很多，今天，主要总结一下这些遍历方法如何跳出循环，欢迎各位大神和同行们指教和修正😁
首先，必须要知道的是：
return必须是使用在函数里面的return有2个作用，结束函数和返回结果 JS中的遍历有如下方式可以跳出循环 1.for方法 跳出循环 break 跳出当前循环，循环后面的代码仍然可以执行return 可以终止当前函数，循环后面的代码不可以执行continue 跳过当次循环，仍然执行后续的循环 function a(){ var arr = [1,3,5,7,9]; var id = 5; for (var i = 0; i &lt; arr.length; i++) { if(arr[i]=== 1) continue; //跳过当次循环 console.log(arr[i]) if (arr[i] === id) { break; //满足条件，跳出循环;循环后面的代码仍然可以执行 } if (arr[i] === 6) { return; //满足条件，可以终止当前函数 } } } 2.forEach方法跳出循环 无法使用break，continue来跳出遍历， 因为foreach是异步执行，可能在break之前代码就已经执行完了forEach()本身无法跳出循环，必须遍历所有的数据才能结束通过抛出异常的方式跳出循环 实现break效果 // 在forEach中，无法用break等函数在遍历结束之前结束遍历，如果要提前终止，必须把forEach（）方法放在一个try块中，并能抛出一个异常。 var arr = [1,3,5,7,9]; var id = 5; try { arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c53e910956f7555b58861de7fc93867/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124923c4e714cd418582a7806e4f2143/" rel="bookmark">
			Springcloud 微服务实战笔记 Feign
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优点 基于Netflix Feign实现，整合了Spring cloud Ribbon 和 Spring cloud Hystrix
提供了声明式的WEB服务客户端定义方式
扩展了Spring MVC的注解支持
使用 1、pom导入包：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2、接口增加注解： @FeignClient
@FeignClient(name = "spring-cloud-study-demo") public interface DemoRemoteClient { @GetMapping("/demo/getData/{uid}") public ApiReturnObject getData(@PathVariable(value="uid") String uid,@RequestParam(value="data") String data); } 注解@FeignClient的name参数配置为服务名(服务提供方可以自己随便写一个)
3、Controller直接调用
@RestController public class FeignController { @Resource DemoRemoteClient demoRemoteClient; @GetMapping("/remote/demo/getData/{uid}") public ApiReturnObject basePath(@PathVariable String uid ,String data){ return demoRemoteClient.getData(uid, data); } } 4、启动类增加注解 @EnableFeignClients
@EnableEurekaClient @EnableFeignClients @SpringBootApplication public class SpringCloudStudyFeignApplication { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/124923c4e714cd418582a7806e4f2143/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16494d4ab9a42e7b5ad3e3964ad9e279/" rel="bookmark">
			uniapp中uview组件库丰富的Slider 滑动选择器的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
#平台差异说明
#基本使用
#设置最大和最小值
#设置步进值
#禁用状态
#自定义按钮的内容和样式
#自定义滑动选择器整体的样式
#此页面源代码地址
#API
#Props
#Slider Events
该组件一般用于表单中，手动选择一个区间范围的场景。
说明
该组件在H5，微信小程序和APP-VUE等平台上使用了WXS技术，在NVUE平台使用了BindingX技术， 故在滑动过程中可以获得细腻流畅的跟随效果。
#平台差异说明 App（vue）App（nvue）H5小程序√√√√ #基本使用 需要通过v-model绑定一个值，来初始化滑块的选择值(0到100之间)，这个值是双向绑定的，您可以通过这个值，实时地得知内部的滑动结果。
&lt;template&gt; &lt;u-slider v-model="value"&gt;&lt;/u-slider&gt; &lt;/template&gt; &lt;script&gt; export default { data() {	return { value: 30 } } } &lt;/script&gt; #设置最大和最小值 通过min和max，可以设置滑块所能选择的最大和最小值
&lt;u-slider v-model="value" min="30" max="80"&gt;&lt;/u-slider&gt; #设置步进值 通过step参数设置步进值，这个步进值为每次跳变的值，具体表现请见示例。
提示
需要注意的是，这个step必须要被max值整除，否则会出现无法无法滑动到最大值的情况
&lt;u-slider v-model="value" step="20" min="30" max="100"&gt;&lt;/u-slider&gt; #禁用状态 &lt;u-slider v-model="value" disabled&gt;&lt;/u-slider&gt; #自定义按钮的内容和样式 activeColor，设置进度条的激活部分颜色inactiveColor，进度条的激活部分颜色inactiveColor，进度条的背景颜色blockColor，滑块的背景颜色blockStyle，用户对滑块的自定义样式(颜色) &lt;template&gt; &lt;u-slider v-model="value" activeColor="#3c9cff" inactiveColor="#c0c4cc"&gt; &lt;/u-slider&gt; &lt;/template&gt; &lt;script&gt; export default { data() {	return { value: 30 } } } &lt;/script&gt; #自定义滑动选择器整体的样式 通过inactive-color配置底部滑动条背景颜色通过active-color配置底部选择部分的背景颜色通过block-width配置滑块宽度(高等于宽)通过block-color配置滑动按钮按钮的颜色通过height配置滑块条高度，单位rpx 其他更多参数详见底部API
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16494d4ab9a42e7b5ad3e3964ad9e279/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7781fc5aa2990e00ca3aa2de1bf084ea/" rel="bookmark">
			uniapp vue 前端页面半小时选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;view&gt; &lt;view class="uni-title uni-common-pl"&gt;时间选择器&lt;/view&gt; &lt;view class="uni-list"&gt; &lt;view class="uni-list-cell"&gt; &lt;view class="uni-list-cell-left"&gt; 当前选择 &lt;/view&gt; &lt;view class="uni-list-cell-db"&gt; &lt;picker mode="selector" :value="timeIndex" range="{{timeRange}}" @change="bindTimeChange"&gt; &lt;view class="uni-input"&gt;{{time}}&lt;/view&gt; &lt;/picker&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { time: '', // 当前选择的时间 timeIndex: 0, // 当前选择的时间索引 timeRange: [] // 时间选择器的可选项 }; }, mounted() { this.generateTimeRange(); }, methods: { generateTimeRange() { const startTime = new Date("2000/01/01 08:00"); const endTime = new Date("2000/01/01 22:00"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7781fc5aa2990e00ca3aa2de1bf084ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3903a7d809f7c125892f5a2bbf72a3a0/" rel="bookmark">
			vue判断组件有没有传入的slot有就渲染slot没有就渲染内部节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPT4国内站点：海鲸AI
在 Vue 中，你可以使用 $slots 对象来检查是否有特定的插槽内容被传递给组件。Vue 3 中的 $slots 是一个对象，其中包含了所有插槽的引用。如果插槽没有内容，对应的插槽属性将会是 undefined。
下面是一个例子，演示了如果有传递插槽内容就渲染插槽，否则就渲染组件内部的默认内容：
&lt;template&gt; &lt;div&gt; &lt;!-- 检查是否有名为 "default" 的插槽内容 --&gt; &lt;slot v-if="$slots.default"&gt;&lt;/slot&gt; &lt;!-- 如果没有，则显示默认内容 --&gt; &lt;div v-else&gt; 默认内容 &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { // 组件的其余部分 }; &lt;/script&gt; 在这个例子中，&lt;slot&gt; 元素使用了 v-if 指令来判断是否存在默认插槽内容。如果 $slots.default 有值，说明父组件提供了默认插槽的内容，那么就会渲染这个插槽。如果没有值，就会渲染后面的 &lt;div&gt; 元素，显示“默认内容”。
如果你想要检查具名插槽，可以通过 $slots 对象中的对应属性名来检查。例如，如果你有一个名为 header 的插槽，可以这样检查：
&lt;template&gt; &lt;div&gt; &lt;!-- 检查是否有名为 "header" 的插槽内容 --&gt; &lt;slot name="header" v-if="$slots.header"&gt;&lt;/slot&gt; &lt;!-- 如果没有，则显示默认标题 --&gt; &lt;h1 v-else&gt;默认标题&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; 在 Vue 3 中，还可以使用 v-slot 的一种新语法来提供默认插槽内容，如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3903a7d809f7c125892f5a2bbf72a3a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef53b8e160bd6ba57372a1be38b8b79/" rel="bookmark">
			Matlab进阶绘图第37期—多色悬浮柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多色悬浮柱状图是一种特殊的柱状图。
与常规柱状图相比，多色悬浮柱状图可以通过悬浮的矩形展示最小值到最大值的范围（或其他范围表达），并通过颜色进行美化/区分/附加信息。
本文使用自己制作的Floatingbar小工具进行多色悬浮柱状图的绘制，先来看一下成品效果：
特别提示：本期内容『数据+代码』已上传资源群中，加群的朋友请自行下载。有需要的朋友可以关注同名公号【阿昆的科研日常】，后台回复关键词【绘图桶】查看加入方式。
1. 数据准备
此部分主要是读取原始数据并初始化绘图参数。
% 读取数据load data.mat% 初始化绘图参数X = x;Y1 = data1;Y2 = data2;lbs = {'Jan.','Feb.','Mar.','Apr.','May.','Jun.','Jul.','Aug.','Sep.','Oct.','Nov.','Dec'}; 2. 颜色定义
作图不配色就好比做菜不放盐，总让人感觉少些味道。
但颜色搭配比较考验个人审美，需要多加尝试。
这里直接使用TheColor配色工具中的SCI权威配色库：
%% 颜色定义N = length(X);map = TheColor('sci',2064,'map',N);map = flipud(map); 3. 多色悬浮柱状图绘制
调用‘Floatingbar’命令，绘制初始多色悬浮柱状图。
h = Floatingbar(X,Y1,Y2,map,0.7);hTitle = title('Floating bar chart');hXLabel = xlabel('Month');hYLabel = ylabel('Temperature(\circC)'); 4. 细节优化
为了插图的美观，对坐标轴细节等进行美化：
% 目标属性调整set(h,'EdgeColor','none')% 坐标区调整set(gca, 'Box', 'off', ... % 边框 'LineWidth', 1, 'GridLineStyle', '-',... % 坐标轴线宽 'XGrid', 'off', 'YGrid', 'on', ... % 网格 'TickDir', 'out', 'TickLength', [.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eef53b8e160bd6ba57372a1be38b8b79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cee718861fd3d574f24dbc8043b61cf8/" rel="bookmark">
			chrome面向服务的架构SOA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chrome 浏览器面向服务的架构
原来的各种模块会被重构成独立的服务，每个服务都可以独在独立的进程中运行，可以在浏览器的任务管理器中看到各种服务。
"面向服务的架构"（Service-Oriented Architecture，SOA）是一种软件设计和架构的方法，其中软件组件被设计为可重用的服务，并通过网络进行通信。在 Chrome 浏览器中，有一种与 SOA 相关的架构模式，称为 Chrome 的面向服务的架构（Chrome Service Architecture）。
Chrome 的面向服务的架构采用多进程模型，将浏览器功能划分为多个独立的服务。每个服务运行在单独的进程中，这种方式有助于提高浏览器的稳定性、性能和安全性。
以下是 Chrome 面向服务的架构中的一些关键组件和服务：
Browser Process：
主进程，负责协调和管理其他服务。与用户界面、插件、扩展、网络等主要组件进行交互。 Renderer Process：
每个标签页对应一个渲染进程，负责页面的渲染、布局和用户交互。渲染进程通过 IPC（进程间通信）与主进程和其他进程通信。 Network Service：
网络服务，负责处理网络请求和响应。运行在独立的进程中，与渲染进程和其他服务进行通信。 GPU Process：
GPU 进程，处理与图形相关的任务，如页面合成、动画等。独立的进程，有助于提高图形渲染性能。 Storage Service：
存储服务，负责管理浏览器中的数据存储，包括 Cookie、LocalStorage 等。运行在独立的进程中。 Audio Service：
音频服务，处理与音频相关的任务。运行在独立的进程中。 Extension Service：
扩展服务，管理浏览器扩展。运行在独立的进程中。 Crashpad Service：
处理浏览器崩溃时的崩溃报告。运行在独立的进程中。 这些服务之间通过 IPC 进行通信，这种模型允许它们在各自的进程中独立运行，提高了浏览器的稳定性。这种面向服务的架构也使得 Chrome 能够更好地利用多核处理器，提供更好的性能和用户体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbef4882eab88b156d29728d828df22c/" rel="bookmark">
			【一对一小组】2024年有三AI-CV中阶-模型算法组发布，如何循序渐进地学习好模型原理与部署落地...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年有三AI-CV中阶-模型算法组正式发布！有三AI已经推出了CV初-中-高级培养计划（原名有三AI-CV季划），这是我们的终身计算机视觉学习小组。
该培养计划具有以下特点：
【系统性】配套有非常完备的理论与实践
【永久性】不限制学习期限，一直有效
【成长性】内容保持更新，不额外收费
【专业性】原创书+视频讲解+真实项目锻炼
【丰富性】数千页PPT，文档，项目等
【权威性】工业界资深背景辅导老师，弱运营属性
什么是有三AI-CV中阶-模型算法组
好的模型结构是深度学习成功的关键因素之一，不仅是非常重要的学术研究方向，在工业界实践中也是模型是否能上线的关键。对各类底层深度学习模型设计和优化技术理解的深度是决定我们能否在深度学习项目中游刃有余的关键。
那我们究竟如何去长期学好模型相关的算法呢？本组聚焦于让大家能够跟随我们社区长期学习模型相关的算法，当前需要学习的东西包括：数据使用，模型分析，模型设计，模型优化，模型部署。下图是2024年CV中阶-模型算法组包括的内容预览图，可以自行放大仔细阅读。
学习内容覆盖以下几个方向：
(1) 算法基础，包括经典CNN模型原理、数据使用方法等。
(2) 模型分析与优化，包括模型参数与计算量分析、模型结构与特征可视化。
(3) 主流模型部署工具，包括原生Pytorch、MNN、NCNN、Tengine、TensorRT、微信小程序等。
学习资源包括以下部分：
(1) 1本配套的图书教材，《深度学习之模型设计：核心算法与实战实践》。
(2) 配套的视频教程，唯一的学习平台，课程不定期更新。
(3) 1个知识星球学习社区，存储部分图文资料与数据。
(4) 有三AI项目研发组进入权限，有机会负责真实产业案例研发。
数据使用
数据的使用是深度学习算法领域从业者的必备素质，需要掌握如何收集高质量的数据，如何整理数据，如何分析数据，如何在各类项目中使用好数据增强。我们配置了1门时长超过3小时的《深度学习之数据使用》课程与若干个项目实践。
详细了解课程，请阅读：【视频课】永久免费！3小时快速掌握深度学习CV数据使用核心内容
模型设计
模型的设计是整个深度学习领域的通用基础，不管是从头设计自己的神经网络，还是对已有模型进行优化获得更高的任务指标，更快的运行速度，获得更小的模型体积，都需要掌握各类网络的设计技巧，是深度学习算法工程师进阶的难点及必学点！我们配置了模型设计课程，当前包含的内容超过20个小时，PPT数量超过450页。
理论部分内容：网络深度与模型性能，网络宽度与模型性能，注意力机制，轻量化网络理论。
(1) 基于网络深度的CNN模型设计，内容包括经典浅层卷积网络的设计模型如neocognitron、经典模型AlexNet，VGGNet，ResNet。
(2) 基于网络宽度的CNN模型设计，内容包括多分支经典模型如GoogLeNet，ResNext等
(3) 经典注意力机制CNN模型设计，内容包括空间注意力模型、通道注意力模型、 混合注意力模型。
(3) 轻量级模型设计，内容包括Xception网络、MobileNet V1和V2网络、 ShuffleNet V1和V2网络、SqueezeNet网络。
实践部分内容：基于ResNet的垃圾分类实战，基于InceptionNet系列的花卉分类实战，基于SeNet的人种分类实战，Pytorch模型安卓端部署。
详细了解课程，请阅读：【视频课】AI必学，超20小时，4大模块，循序渐进地搞懂CNN模型设计与简单部署！
模型分析
深度模型参数多，网络结构复杂，模型结构的设计以及训练过程中超参数的调试，都非常依赖于经验。如果只凭经验，没有很科学的分析工具，仍然会有盲人摸象的感觉。因此为了能够更好地进行研究和实践，对模型进行相关的分析是非常重要的。我们配置了模型分析课程，当前包含的内容超过3个小时，PPT数量超过200页。
理论部分内容：主要包括理论参数量与计算量分析，反卷积可视化原理，激活热图可视化原理。
实践部分内容：模型结构可视化实战，激活热图可视化实战，特征可视化实战，参数量与计算量分析，计算时间分析。
详细了解课程，请阅读：【视频课】AI必学，超3小时，3大模块，掌握模型分析核心技术！
模型优化/压缩
模型优化/压缩是整个模型算法组最核心的内容，所研究的就是如何用更少的资源，更快的速度获得与更大模型相关的性能。我们配置了模型优化课程，当前包含的内容超过10个小时，PPT数量超过300页。
理论部分内容：主要包括模型剪枝，模型量化，模型蒸馏，神经网络搜索。
(1) 模型剪枝，内容包括结构化模型剪枝方法与非结构化模型剪枝方法。
(2) 模型量化，内容包括1bit与3值模型量化方法，8bit对称与非对称模型量化方法，混合模型量化方法。
(3) 模型蒸馏，内容包括特征约束与优化目标驱动的模型蒸馏方法，自蒸馏学习方法。
(4) 神经网络搜索，内容包括基于栅格搜索的神经网络搜索方法，基于强化学习的神经网络搜索方法，基于进化学习的神经网络搜索方法。
实践部分内容：结构化模型剪枝实战，8bit模型量化实战，经典知识蒸馏实战，Distiller模型压缩框架。
详细了解课程，请阅读：【视频课】AI必学，超10小时，4大模块，掌握模型优化核心技术！
在有三AI知识星球中包括有紧凑模型设计，动态推理，模型的剪枝、量化、蒸馏，软硬件优化，模型自动搜索等内容。请大家使用相关标签进行阅读，包括#模型剪枝# #模型量化# #模型蒸馏# #模型压缩# #硬件优化# #动态推理# #AutoML#等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbef4882eab88b156d29728d828df22c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3105896addb4bf871bcafa13e86f304/" rel="bookmark">
			白嫖GPT4，Dalle3和GPT4V - 字节开发的Coze初体验！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些结论：
Coze可以理解为字节跳动版的GPTs。2023年12月26日测试，国内用户需要魔法才能够使用Coze的服务，否则会提示“服务在该地区不可用”。Coze目前支持通过GPT-3.5（16K）和GPT-4（8K）来创建聊天机器人。Coze目前是免费开放，意味着目前可以白嫖GPT4模型及DALLE3、GPT4V插件。生成的聊天机器人可发布至Discord、Telegram和Cici，未来会支持WhatsApp和Twitter。 Coze是什么？ Coze是由字节跳动在海外推出的一个AI聊天机器人和应用程序编辑开发平台，可以理解为字节跳动版的GPTs。无论你是否有编程经验，这个平台都可以让您快速地创建各种类型的聊天机器人，并将它们部署在其他社交平台和消息应用上。Coze还提供了多种插件、知识、工作流、长期记忆和定时任务等功能，来增强聊天机器人的能力和交互性。
Coze有什么功能？ 插件： 拓展Bot的能力。Coze集成了超过60款各类型的插件，包括资讯阅读、旅游出行、效率办公、图片理解等API及多模态模型。你可以集成不同的工具，打造具备极强功能性的Bot，或者将私有API集成为插件。
知识库： 让Bot与你自己的数据进行交互。Coze提供了简单易用的知识库能力，它能让AI与你自己的数据（如PDF、网页文本）进行交互。你可以在知识库中存储和管理数据，让你的Bot来使用相关的知识。
长期记忆： 让Bot拥有持久化的记忆能力。Coze提供了一个方便AI交互的数据库记忆能力，通过这个功能，你可以让AI Bot持久化地记住你跟它对话的重要参数或内容。您可以让Bot记住你的饮食偏好、语言偏好等信息，提高用户体验。
定时任务： 让Bot主动和你进行对话。你是否希望Bot能主动给你发送消息？通过定时任务功能，可以非常简单地通过自然语言创建各种复杂的定时任务。Bot会准时给你发送对应的消息内容。你可以让Bot每天早上给你推荐个性化的新闻，或者每周五帮你规划周末的出行计划。
工作流： 将你的创意变成Bot的技能。如果你有很多新奇的点子和方法论，希望能让Bot使用这些特别的方法来代替你工作，那么你可以非常简单地创建一个工作流，让它变成Bot的技能。你可以在工作流里使用代码片段创建非常复杂的函数，或者通过简单的操作创作出属于你的工作流。你可以做一个帮你搜集电影评论的工作流，或者一个帮你撰写行业研究报告的工作流。
创建好的聊天机器人可以部署在哪里？ 你可以将在Coze上创建的机器人部署到不同的社交平台和消息应用上，例如Discord（已支持）、Telegram（已支持）、Cici（已支持）、WhatsApp（即将推出）、Twitter（即将推出）等。你只需要在Coze的发布页面选择想要的平台，然后按照指引完成部署的步骤。你也可以将机器人部署到自己的网站或应用上，通过Coze提供的Webhook和SDK功能。
Coze快速上手教程 Step 1: 新建机器人 导航到侧栏中的“机器人”选项卡，然后单击“创建”。为你的机器人命名并提供其功能的描述。
名称: Coding Copilot描述：Coding Copilot是一个编程助手，它可以为您提供代码优化、编程问题解答和算法设计三种技能，帮助您提高编程效率和质量。它遵循最新的编程规范和最佳实践，只使用您选择的编程语言，只处理与编程相关的问题。它可以理解您的代码和问题，搜索在线知识库，设计有效的算法或数据结构，返回优化后的代码或解决方案，并以清晰的流程和简洁的语言进行解释。 创建机器人后，你将进入机器人编辑页面，该页面将显示三个部分：
左栏：放置机器人的提示/命令。中栏：提供用于扩展机器人功能的工具。右栏：在机器人上线之前对其进行测试的区域。 Step 2：编写机器人的提示 提示是你向机器人发出的主要命令。你可以在“角色和提示”部分中描述角色、技能、约束和其他方面来定义机器人的预期行为。Coze也很贴心的内置了提示词优化选项，点击“优化”即可对你输入的提示词进行优化。
提示词如下：
# 角色 你是一个天才级的编程助手，擅长解决各种编程问题和难题。 ## 技能 ### 技能一：代码优化 - 解析用户提供的原始代码，理解其目的和内在逻辑。 - 根据代码规范和最佳实践进行代码优化。 - 将优化后的代码返回给用户。 ### 技能二：编程问题解答 - 理解用户提出的编程问题。 - 利用在线编程知识库(search(site:stackoverflow.com))搜索解决方案。 - 按照易于理解的方式解释解决方案。 ### 技能三：算法设计 - 理解用户需要解决的问题，识别其对应的算法类型。 - 设计有效的算法或数据结构来解决问题。 - 将算法或数据结构的设计过程以及实现代码返回给用户。 ## 约束 - 只讨论与编程相关的问题。 - 保持输出格式一致，以清晰的流程和简洁的语言阐述代码或解决方案。 - 仅使用用户使用的语言编写代码。 - 所有代码必须是可运行的并且无明显错误。 - 尽可能使用最新的编程规范和最佳实践编写代码。 Step3: 添加插件 由于机器人本身无法访问互联网，因此需要添加插件来获取联网获取数据并执行操作。这里可以按需进行选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3105896addb4bf871bcafa13e86f304/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4154e95579b4dd7a00c5d39a0537e9b/" rel="bookmark">
			win系统微软输入法踩坑之输入法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题例如：字母间距变宽
或者打字总是繁体等等
字母变宽是因为快捷键误触切换成了全角字符。。
打开输入法设置界面进行相关设置（你要解决的输入法相关问题都可以在这里得到解决）：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/727af16c62f0104d083b433a539d29b1/" rel="bookmark">
			Ubuntu18.04配置静态ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 查看网卡名、ip地址、网关切换root用户，进入配置文件配置静态IP 查看网卡名、ip地址、网关 首先查看网卡名、ip地址、网关，找到对应的网卡名并记录其地址
ifconfig route -n 切换root用户，进入配置文件 sudo -i cd /etc/netplan vim 01-network-manager-all.yaml 配置静态IP 每个人的系统参数不同，仔细对照自己的来修改
# Let NetworkManager manage all devices on this system network: ethernets: ens33: addresses: [192.168.85.142/24] #ip gateway4: 192.168.85.2 dhcp4: no nameservers: addresses: [114.114.114.114] version: 2 renderer: NetworkManager 配置完退出后，执行netplan apply，没问题即配置完成
运行报错，大多数情况都是层次不对、格式不对、没有空格、名称没写对，请仔细检查
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4287c8e9602f60f6048c28ed296b3da7/" rel="bookmark">
			JVS规则引擎和智能BI（自助式数据分析）1.3新增功能说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		规则引擎更新功能 新增:
1、数据源新增Excel数据源；
Excel数据源功能允许用户将Excel文件作为数据源导入，并进行数据清洗、转换和处理，以实现数据的集成、可视化和深度分析，为决策提供强大支持，同时保持良好的交互性和灵活性。
2、数据源新增在线数据预览；
数据源在线数据预览是一种能够实时查看数据源数据的功能。这个功能可以提供用户一个交互式的界面，使用户可以直观地查看、验证数据源的数据。用户无需编写复杂的查询语句或进行复杂的设置，只需通过简单的操作就可以获取到需要的数据。
在线demo：http://rules.bctools.cn/
gitee地址：https://gitee.com/software-minister/jvs-rules
智能bi更新功能 新增:
1、大屏新增组件组合功能，组合后在图层展示组合，可以按快捷键ctrl+g组合；
大屏组件组合功能是一种将多个组件组合在一起，形成一个整体的可视化展示的功能。这个功能可以将多个组件进行排版、布局和样式设置，形成一个统一、美观、易于理解的展示界面。
2、数据服务新增调用示例；
调用示例功能是一种能够展示如何调用数据服务的工具。这个功能可以提供用户一个可视化的界面，使用户可以轻松地查看、了解如何调用数据服务。通过这个功能，用户可以了解到数据服务的接口地址、方式、描述、请求参数等信息，并且可以通过简单的操作来调用数据服务。
3、图表文本查询条件新增“包含”；
“包含”功能是一种允许用户在查询数据时设置文本查询条件的功能。通过这个功能，用户可以在查询数据时指定文本的包含条件，筛选出符合条件的文本数据。如图1，当选择筛选条件后，系统会弹出一个对话框，要求用户输入需要查询的文本内容。用户输入文本后，系统会自动筛选出符合条件的文本数据，并将这些数据展示在图表中。
4、图标查询条件文本框新增长度设置功能；
优化:
1、优化大屏组件双击修改名称；
2、优化API调用数据服务接口，返回信息不友好问题（已改为中文提示）；
BUG:
1、修复数据服务中数据集下来选择异常问题；
2、修复数据服务中数据集数量展示未超过10条问题；
在线demo：http://bi.bctools.cn
gitee地址：https://gitee.com/software-minister/jvs-bi
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef34d3d140cf5b17964a74d4755a28b/" rel="bookmark">
			Unity 打包AB 场景烘培信息丢失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景打包成 AB 资源的时候，Unity 不会打包一些自带相关的资源 解决办法：在 Project settings &gt; Graphics下设置（Automatic 修改成 Custom）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0b94a7d4918b2c3789922a71d23939a/" rel="bookmark">
			工业RFID技术发展趋势分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RFID技术是物联网的重要组成部分，是连接物理世界和数字世界的关键节点。RFID技术已经广泛应用于供应链管理、智能物流、零售、医疗、安防等领域，在工业制造领域也有着广泛的应用前景和市场潜力。
工业RFID技术发展趋势分析
工业RFID技术是一种利用无线射频识别技术实现物品追踪和管理的新型技术，随着科技的不断发展和应用的深入，工业RFID技术呈现出了以下几种发展趋势：
高频化：超高频和微波频段RFID技术是未来发展的趋势，其标签读取距离远、识别速度快、穿透能力强，能够更好地适应复杂环境下的物品追踪和管理。
标准化：随着RFID技术的普及和应用，标准化问题越来越受到关注。未来，工业RFID技术将更加注重标准制定和实施，以实现不同厂商和不同应用之间的互操作性和兼容性。
集成化：工业RFID技术将与其他信息技术进行集成，如物联网技术、大数据技术等，以实现更广泛的物品追踪、管理、分析和优化。
定制化：针对不同行业和应用需求，工业RFID技术将提供更加定制化的解决方案，满足客户的特殊需求。
智能化：随着人工智能技术的发展，工业RFID技术将更加智能化，能够实现自动识别、自动分类、自动预警等功能，提高生产效率和降低成本。
环保化：工业RFID技术的环保问题越来越受到关注，未来将有更多环保型的工业RFID产品出现，如可降解材料制成的标签等。
安全化：工业RFID技术的安全性问题也备受关注，未来将有更多安全机制和技术手段被应用到工业RFID产品中，以确保数据和信息的安全。
总之，工业RFID技术将继续发展并广泛应用，为工业制造、物流配送、零售消费等领域带来更多的便利和创新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a37a2e6fae1c26560f30ca74151666c8/" rel="bookmark">
			neo4j图数据库安装和测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		neo4j图数据库安装和测试 1. 下载合适的neo4j软件版本。
https://we-yun.com/doc/neo4j/
https://neo4j.com/deployment-center/#enterprise
2. 下载JAVAJDK
由于neo4j是一个用Java编写的图形数据库，因此在安装和运行Neo4j之前，需要先安装Java Development Kit（JDK）。安装JDK的过程可能因操作系统而异，可以从Oracle官方网站或OpenJDK网站下载并按照相应的安装指南进行安装。
注意：javajdk版本需要和neo4j软件版本匹配，并不是每一个java版本都合适。
如何查找互相匹配的版本？接着往下看。
点击链接，选择合适neo4j版本。
https://neo4j.com/docs/operations-manual/4.3/installation/requirements/
如选择4.3的版本，再找到软件的环境要求，其中提到javajdk的要求。
至于javajdk的安装并不在本文的范畴没，可以参考其他博主的文章。
3. 解压neo4j和javajdk
&gt; 下面以neo4j-4.3.5和jdk-11.0.21为例
解压neo4j-community-4.3.5-windows.zip和jdk-11.0.21.zip,无需安装。
4. 环境配置
&gt; 4.1 添加环境变量名
java变量名：JAVA_HOME，neo4j变量名：NEO4J_HOME。
变量的值为java和neo4j的安装路径。
&gt; 4.2 点击系统变量中的Path
添加%JAVA_HOME%\bin以及%NEO4J_HOME%\bin
5. 测试安装是否成功
​在cmd中输入neo4j.bat console。
浏览器中输入http://localhost:7474初始账号和密码都是neo4j，登录后修改初始密码。
附neo4j-4.3.5和jdk-11.0.21安装包：
链接：https://pan.baidu.com/s/1Muwq0rfbQKuWrgtqhL_BOg?pwd=bdn7
提取码：bdn7
至此，安装完毕。若本文对您有所帮助，麻烦你点个免费的赞或关注。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3238016a1cdd3a1dac8b7e0ba3f99138/" rel="bookmark">
			使用Selenium需要浏览器驱动与浏览器版本统一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装浏览器驱动
针对不同的浏览器，需要安装不同的驱动。
这里以安装 Chrome 驱动作为演示。
确定浏览器版本
进入设置界面，然后选择 【关于 Chrome】
查看自己的版本信息。这里我的版本是114，下载对应版本的 Chrome 驱动即可。
下载驱动
打开Chrome驱动。单击对应的版本。（有两个的哪一个都可以）
根据自己的操作系统，选择下载
下载完成后，压缩包内有一个 exe 文件
将 chromedriver.exe 放到项目中（或任意位置，并且也可以把存放的路径保存到环境变量中，这里的演示不需要改括号内的操作）
到此时还不能正常使用，需要在pom.xml文件中进行配置。
添加成功后使用下面代码进行测试。
有时或许会失败，原因很多
1）浏览器与驱动版本没有统一
2）浏览器缓存问题（极小概率）清理缓存、重新安装
3）pom.xml中配置的版本有问题，更换版本（用热门的）
4）再到pom.xml里配置一个对应版本的
selenium-remote-driver 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c8de67e823fc00264def66c523f0101/" rel="bookmark">
			catkin_make 编译报错 Unable to find either executable ‘empy‘ or Python module ‘em‘...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 写在前面一、问题描述二、解决方法参考链接 写在前面 自己的测试环境： Ubuntu20.04
一、问题描述 自己安装完 anaconda 后，再次执行 catkin_make 遇到如下问题：
CMake Error at /opt/ros/noetic/share/catkin/cmake/empy.cmake:30 (message): Unable to find either executable 'empy' or Python module 'em'... try installing the package 'python3-empy' 报错截图：
二、解决方法 出现这个问题的主要原因是 catkin_make 找到的是 anaconda 下的 python，所以修改成以下指令，即可解决问题：
catkin_make -DPYTHON_EXECUTABLE=/usr/bin/python3 参考链接 [1] 南山&amp;M. ubuntu20.04出现Unable to find either executable ‘empy‘ or Python module ‘em‘… try [EB/OL]. https://blog.csdn.net/weixin_44857882/article/details/124296306, 2022-04-20/2024-01-04.
[2] Coffee504. 在安装anaconda后catkin_make不好用 [EB/OL]. https://blog.csdn.net/weixin_63761958/article/details/133123488, 2023-09-21/2024-01-04.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/180232074dbb1f25770218d1b2e97108/" rel="bookmark">
			2024三掌柜赠书活动第二期：实战AI大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言实战AI大模型：突破性能瓶颈的关键步骤与挑战关于《实战AI大模型》编辑推荐内容简介作者简介图书目录书中前言/序言《实战AI大模型》全书速览结束语 前言 随着人工智能技术的不断发展，越来越多的应用场景需要处理大规模的数据集和复杂的计算模型。传统的AI模型可能无法满足这些需求，因此，实战AI大模型成为了许多技术圈大佬和程序开发人员广泛关注的焦点。那么本文就来分享介绍实战AI大模型的关键步骤和挑战，帮助读者了解如何突破性能瓶颈，构建更强大的AI模型。
实战AI大模型：突破性能瓶颈的关键步骤与挑战 关于实战AI大模型，主要是在突破性能瓶颈的关键步骤上面，以及解决大模型所遇到的实战挑战。下面就来通过四个方面来分享。
1、数据准备与预处理 AI大模型的第一步是数据准备和预处理。大规模数据集需要进行数据清洗、标注和预处理，以便用于模型训练。这包括数据清洗、去噪、数据平衡等工作。此外，特征工程也是一个重要的步骤，通过对数据进行特征提取和转换，可以获得更有意义的数据表示。
2、模型选择与设计 在实战AI大模型中，选择合适的模型架构非常重要。传统的AI模型可能无法处理大规模数据和复杂计算的要求。因此，需要考虑使用深度学习模型，如卷积神经网络（CNN）、循环神经网络（RNN）或变换器（Transformer）等。同时，针对具体的任务需求，可以进行模型微调或基于预训练模型进行迁移学习，以加速模型收敛和提高性能。
3、训练与优化 针对AI大模型的训练，通常需要使用分布式训练技术，以充分利用多台计算机资源。分布式训练可以将大规模模型的计算和存储任务分发到多台机器上进行，并通过参数服务器、模型并行和数据并行等技术进行通信和同步。此外，为了加速训练过程，可以使用混合精度训练、学习率衰减和正则化等优化技术，以提高模型的泛化能力和收敛速度。
4、推理与部署 当AI大模型训练完成后，需要进行推理和模型部署。推理阶段涉及将训练好的模型应用于真实场景中的数据，生成预测结果。针对AI大模型，推理过程可能需要考虑优化模型的推理速度和内存占用。可以使用模型压缩、量化和裁剪等技术，以减少模型的存储空间和计算需求。此外，模型的部署也需要考虑到实时性、可扩展性和安全性等因素。
5、挑战与解决方案 在实战AI大模型中，面临一些挑战，如数据量大、计算复杂度高、模型训练时间长等。为了解决这些挑战，可以考虑以下方案：
使用分布式计算技术，如使用多台计算机进行分布式训练，提高计算效率。优化模型架构和参数设置，以减少模型的计算复杂度和内存占用。采用混合精度训练和模型剪枝等技术，减少模型的存储和计算需求。使用硬件加速器，如GPU或TPU等，加速模型的训练和推理过程。 关于《实战AI大模型》 接下来给大家推荐一本关于AI大模型学习必备的书籍，这是一本关于AI大模型实战类的干货图书，人工智能领域资深专家尤洋老师倾力打造，获得了李开复、周鸿祎、颜水成三位大咖鼎力推荐，一经上市就登上了京东“计算机与互联网”图书排行榜Top1的宝座。另外，关注本文博主，点赞+收藏本文，且在本文评论区评论“我要入门大模型”，将选取三名幸运读者送出纸质版《实战AI大模型》一本，截止时间：2024.01.09。入手《实战AI大模型》传送门：https://item.jd.com/14281522.html，个人觉得这本书非常的不错，尤其是对于AI大模型开发者来讲，是一本不可多得的好书，值得拥有去学习。
编辑推荐 《实战AI大模型》详细介绍了从基本概念到实践技巧的诸多内容，全方位解读AI大模型，循序渐进、由浅入深。书中配有二维码视频，使读者身临其境，迅速、深入地掌握各种经验和技巧。本书还附带了丰富的额外资源：开源工具和库、数据集和模型案例研究和实际应用、在线交流社区等。读者可以综合利用这些资源，获得更丰富的学习体验，加速自己的学习和成长。
内容简介 《实战AI大模型》是一本旨在填补人工智能（AI）领域（特别是AI大模型）理论与实践之间鸿沟的实用手册。书中介绍了AI大模型的基础知识和关键技术，如Transformer、BERT、ALBERT、T5、GPT系列、InstructGPT、ChatGPT、GPT 4、PaLM和视觉模型等，并详细解释了这些模型的技术原理、实际应用以及高性能计算（HPC）技术的使用，如并行计算和内存优化。
同时，《实战AI大模型》还提供了实践案例，详细介绍了如何使用Colossal AI训练各种模型。无论是人工智能初学者还是经验丰富的实践者，都能从本书学到实用的知识和技能，从而在迅速发展的AI领域中找到适合自己的方向。
作者简介 尤洋，清华大学硕士，加州伯克利大学博士，新加坡国立大学计算机系校长青年教授（Presidential Young Professor）。曾创造ImageNet、BERT、AlphaFold、ViT训练速度的世界纪录，相关技术被广泛应用于谷歌、微软、英特尔、英伟达等科技巨头。近三年以第一作者身份在NIPS，ICLR，SC，IPDPS，ICS等国际重要会议或期刊上发表论文十余篇，曾以第一作者身份获国际并行与分布式处理大会（IPDPS）的Best Paper Award（0.8%获奖率）和国际并行处理大会（ICPP）的Best Paper Award（0.3%获奖率），也曾以通讯作者身份获得了国际人工智能大会 (AAAI)的杰出论文奖（0.14%获奖率）和国际计算语言学大会 (ACL)的杰出论文奖（0.86%获奖率），总计发表论文近百篇。曾获清华大学优秀毕业生及当时清华大学计算机系数额最高的西贝尔奖学金，美国计算机协会（ACM）官网上唯一颁给在读博士生的ACM-IEEE CS George Michael Memorial HPC Fellowship，颁发给伯克利优秀毕业生的Lotfi A. Zadeh Prize。他被UC Berkeley提名为ACM Doctoral Dissertation Award候选人。他曾任职于谷歌，微软，英伟达，英特尔，IBM，2021年入选福布斯30岁以下精英榜（亚洲）并获得IEEE-CS超算杰出新人奖。
图书目录 第1章 深度学习中的AI大模型
1.1 AI大模型在人工智能领域的兴起
1.1.1 AI大模型的发展与挑战
1.1.2 AI大模型为何难以训练
1.2 深度学习框架入门
1.2.1 搭建神经网络
1.2.2 训练一个文本分类器
第2章 分布式系统：AI大模型的诞生之所
2.1 深度学习与分布式系统
2.1.1 从分布式计算到分布式AI系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/180232074dbb1f25770218d1b2e97108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c2412d7fd4c6eff68e2103263447c22/" rel="bookmark">
			勒索事件急剧增长，亚信安全发布《勒索家族和勒索事件监控报告》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期(12.15-12.21)态势快速感知
近期全球共发生了247起攻击和勒索事件，勒索事件数量急剧增长。
近期需要重点关注的除了仍然流行的勒索家族lockbit3以外，还有本周top1勒索组织toufan。toufan是一个新兴勒索组织，本周共发起了108起勒索攻击，攻击目标国家为美国，以色列和加拿大，占比近90%。该组织声称其是因为复仇和抵抗，以声援巴勒斯坦事业。
01 勒索态势 近期全球共发生了247起攻击和勒索事件，勒索事件数量急剧增长
攻击和勒索事件趋势图如图1.1所示，勒索事件呈现增长趋势。
本周全球勒索事件受害者所属行业和历史对比趋势图如图1.2所示。从图中可知，制造业、物流行业和零售业等有了大幅增长。通过分析发现，攻击制造业、物流业和零售业的勒索家族绝大部分都为toufan，勒索攻击数量占比82%。而在其余行业，toufan勒索家族占比仅为20%，所以推测toufan勒索家族偏好于攻击这三个行业。
本周勒索受害者所属国家Top10如图1.3所示。美国依旧为受勒索攻击最严重的国家。占比47%。
本周监控到活跃的勒索家族共有31个，Top10勒索家族如图1.4所示。本周Top3和历史Top3勒索家族的累积变化趋势如图1.5所示。从图中可知，lockbit3仍然是影响最严重的勒索家族，而本周新增应着重关注的勒索家族为toufan家族。
图1.1 勒索事件趋势图
图1.2 勒索受害者行业分布趋势图
图1.3 Top10受影响国家
图1.4 Top10活跃勒索家族
图1.5 流行勒索家族的累积变化趋势图
02 勒索事件跟踪 近期监测到的247起勒索事件中，对公共安全造成重大影响的Top10事件如表2.1所示。随后本文在勒索事件详细跟踪分析部分对表中的一些重点事件进行了详细描述。
表2.1 Top10勒索事件详情
勒索事件详细跟踪分析 近期勒索组织8base将Socadis公司添加到其Tor泄露网站的受害者名单中。该勒索组织共获得了包括发票、收据、雇佣合同、大量机密信息和保密协议等大量数据，并设置最后交付赎金的时间为12月27日。
近期勒索组织knight将澳大利亚Crace医疗公司添加到其Tor泄露网站的受害者名单中。该勒索组织共获得了超过30GB的文件，数据上传时间为12月16日。
近期勒索组织dragonforce将养乐多澳大利亚公司添加到其Tor泄露网站的受害者名单中，宣布其获取了该公司的数据库、合同和护照等。
03 重点勒索组织介绍 本次主要介绍新兴勒索家族toufan和lockbit3这两个家族。
LockBit 3.0 LockBit 3.0，又称“LockBit Black”，是一种勒索服务（RaaS）模型，继承了LockBit家族的传统。该模型具备高度自动化和组织化，使用先进的加密算法，迅速加密受害者数据并要求赎金。
TouFan TouFan（AI-Toufan），由“棉沙尘暴”（Cotton Sandstorm）主导，专注于针对巴林新闻和政府网站的攻击，旨在在政治上较少代表的什叶派多数群体中制造动荡。通过鼓励抗议活动并突显贫困和通货膨胀，该组织试图激发巴林的什叶派多数人群之间的不满情绪。在其首次篡改一家亲政府新闻网站的事件中，棉沙尘暴替换了合法内容，取而代之的是批评政权并促进抗议的文章。此外，该组织还借助阿拉伯语的虚假社交媒体账户，或称为“傀儡账户”，来放大Al-Toufan的篡改行为。这一系列行动旨在加剧巴林政治局势的紧张，并在社会上制造更多的不安。
04 亚信安全勒索检测能力升级 针对全球勒索事件频发的威胁态势，亚信安全推出勒索治理方案，针对近期活跃勒索事件已具备检测能力，请提醒客户及时升级产品及特征库。最新产品版本和特征库列表如下：
表4.1 本周勒索事件特征库更新列表
（监测数据仅来源于互联网已公开信息，统计不包含亚信安全已拦截事件）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/903de13ab8ab4b232b6849e6a72c35ae/" rel="bookmark">
			计算机行业学习规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机岗位 技术类 客户端开发（客户使用的软件） 分为电脑端和移动端，大前端：用户能够看到的东西
1、Windows端：Windows C++客户端开发工程师、Windows C#客户端开发工程师
2、移动端：ios开发工程师、Web前端工程师、微信小程序工程师、Android开发工程师
服务端开发 C++后台开发工程师、Java后台开发工程师、Python开发工程师、PHP开发工程师
测试（检测软件是否有bug，测试软件使用的舒适程度） 测试工程师、测试开发工程师（能够开发自动化测试工具）
算法（要求研究生学历，此岗位从事人数少） 算法工程师、数据挖掘工程师
运维（只有大企业才有岗位，小公司基本不需要运维，只能去大厂） 运维工程师、运维开发工程师、系统开发工程师
加班是常态！！！
大数据与人工智能（绝大部分是研究生、也属于算法范围） 数据挖掘工程师、自然语言处理工程师、智能驾驶系统工程师、人工智能工程师、语音/图像识别工程师
游戏 C++游戏客户端研发工程师、Unity 3D研发工程师、C++游戏引擎研发工程师、C++游戏服务器研发工程师
数据库（岗位只会越来越少） 数据库研发研发工程师、DBA数据库管理员
嵌入式 嵌入式C开发工程师、驱动开发工程师
安全（很难直接给企业创造价值） 网络安全工程师
360、绿盟、深信服、大厂
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c30b0b10e52635bba41f222e08f24e8/" rel="bookmark">
			2023年第2季社区Task挑战赛贡献者榜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于FISCO BCOS及Weldentity，实现SSO单点登录服务；提供食品溯源、电商运费险7天退保、电子病历等智能合约库业务场景案例；基于FISCO BCOS更新游戏体验；体验并分析解读最新发布的分布式数据协作管理解决方案DDCMS，提供相应的部署教程......这些精彩贡献展现出社区的开源力量与智慧，也为后续的学习借鉴提供了参考价值。
近期，2023年第2季Task挑战赛圆满收官，本次活动面向社区征集代码及教程，激励更多开发者参与到FISCO BCOS开源项目及周边组件共建中，涌现了众多代码、图文或视频教程。
让我们一起看看本次活动的贡献者榜单及精彩内容吧！加小助手微信（FISCOBCOS010）即可申请加入Task活动交流群。
最佳贡献者（*排名不分先后） CN-ZHANGYH
贡献者简介：
张宇豪，深圳职业技术大学学生。熟悉Java、GO以及运维开发，使用FISCO BCOS参与多项比赛并获奖，如2023年广东省职业院校技能大赛"区块链技术应用"获得一等奖，2023年一带一路暨金砖国家技能发展与技术创新大赛区块链赛项一等奖、2023年广东省计算机程序设计区块链应用与开发一等奖，积极参与社区贡献，为智能合约案例库和DDCMS提供优质的技术教程，在CSDN专栏发布多篇FISCO BCOS 文章。
PR简介：
为分布式数据协会管理解决方案DDCMS和智能合约库，贡献了诸多高质量的代码：
#5基于FISCO BCOS v3.4.0部署了DDCMS分布式数据管理详细教程并提示和解决了潜在的技术难点；
#6抽丝剥茧般，从账户、产品、和数据目录三个方面，分析和解读了DDCMS智能合约的功能、设计模式、存储结构和接口设计；
#7为DDCMS提供了后端容器化的解决方案，实现优雅的环境隔离；
#8提供了支持Github第三方登录的功能，并给出了完整的实现代码和参考文档；
#9修复了DDCMS使用过程中搜索机构的缺陷问题；
#192基于区块链的食品溯源+供应链最佳实践智能合约应用案例；#175提供了使用Truffle来测试智能合约仓库合约的入门教程。
PR链接：
https://github.com/WeBankBlockchain/DDCMS/pull/5 https://github.com/WeBankBlockchain/DDCMS/pull/6 https://github.com/WeBankBlockchain/DDCMS/pull/7 https://github.com/WeBankBlockchain/DDCMS/pull/8 https://github.com/WeBankBlockchain/DDCMS-Service/pull/9 https://github.com/WeBankBlockchain/SmartDev-Contract/pull/192 https://github.com/WeBankBlockchain/SmartDev-Contract/pull/175 sunyunsheng
贡献者简介：
孙运盛，吉科软信息技术有限公司大数据技术研究院架构师。负责吉科软区块链BaaS平台设计研发，推动FISCO BCOS在数字农业、数字城市、食品安全领域落地应用。基于FISCO BCOS研发的食药产业全流程可追溯平台，构建食药产品追溯“一张网”，建立绿色开放的食品生态信用网络，已被收录为工信部“2022年区块链典型应用案例”；基于FISCO BCOS研发的兴农云溯源综合服务平台，为建立健全的农产品质量安全追溯体系，推动农产品标准化、品牌化，助力建设高质量农业供给体系。
PR简介：
#551介绍了构建IPFS私有网络的方法，上传文件到IPFS，文件哈希通过WeBASE存到链上的存证合约库，形成完整的分布式文件存储+存证方案；
#550案例将从代理模式合约、WeBASE-Front前置服务发送交易接口说明、编写代理模式合约样例及java代码中调用的测试流程，详细描述如何利用WeBASE-Front前置服务调用基于代理模式的智能合约的方法。
PR链接：
https://github.com/WeBankBlockchain/WeBASE-Doc/pull/551
https://github.com/WeBankBlockchain/WeBASE-Doc/pull/550
liwh1227
贡献者简介：
李炜航，数金公共服务(青岛)有限公司区块链开发工程师。擅长 GO开发，在区块链 BaaS 平台、区块链溯源等领域有丰富的开发经验；积极拥抱FISCO BCOS开源社区，探索FISCO BCOS在低碳减排领域，供应链金融等场景的应用；为WeIdentity、WeBASE等组件贡献代码和技术文档。
PR简介：
实现了基于Weldentity或者FISCO BCOS地址的SSO单点登录服务，集成了OAuth2.0鉴权协议，扩展了WeIdentity的能力，为WeIdentity与传统登录模式的结合提供了解决方案。此外还提供了相关demo，为使用基于Weldentity或者FISCO BCOS地址的SSO单点登录的应用服务提供了参考。
PR链接：
https://github.com/WeBankBlockchain/WeIdentity/pull/383
优秀贡献者（*排名不分先后） UWEPPPP
贡献者简介：
刘家辉，广东工业大学计算机科学与技术专业学生，目前在学习后端与区块链开发的相关技术。
PR简介：
#240更新了WeIdentity-Build-Tools工具中的各个脚本，适配最新版本的WeIdentity-Build-Tools，为体验WeIdentity提供便捷脚本；
#125和#379在WeIdentity v3.1.0新增的脱离区块链（基于本地数据库，目前仅支持Mysql）部署和使用的基础上，增加适配了两种存储底层IPFS和Redis，拓展了Weidentity的文件存储方式；
#382修改了WeIdentity-Java-Sdk工程中/build-tools/bin/里的部署脚本，为用户提供更直接的部署方式（目前只能通过WeIdentity-Build-Tools部署工具可视化部署），方便用户更快速使用WeIdentity-Java-Sdk。
PR链接：
https://github.com/WeBankBlockchain/WeIdentity-Build-Tools/pull/240 https://github.com/WeBankBlockchain/WeIdentity-Doc/pull/125
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c30b0b10e52635bba41f222e08f24e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff4db51e1c985ad38f79735c4e7d91af/" rel="bookmark">
			3.4.1-欠拟合 与 过拟合（Bias and variance） &#43; 相关解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.4.1 欠拟合与过拟合 + 相关解决方案 1、定义 我们给出过拟合的定义：
Overfitting : If we have too many features, the learned hypothesis may fit the training set vey well, but fail to generalize to new examples.
例子1：线性回归（房价预测） ​
第一个图：是**“欠拟合”** （训练的特征输入较少（X1,X2,X3…房屋面积，房屋层数，房屋年龄）或缺乏复杂性而导致欠拟合），预测出来的数据有很大的误差，拟合不足（underfit）（尤其是在最后几个数据中，实际数据趋于平缓，而我们的预测线还是升高的）—— 展示出来的结果就是：数据具有 “高偏差”第二个图：是我们合理假设的一个模型。可以看到，选取了合理的模型后，图像大致穿过了样本点。像极了做物理实验时，最后用一条曲线大致地穿过既定的样本点；和第一张图比起来，至少损失值大大下降了。 具有很好的 ——“泛化能力”第三个图：是 “过拟合”，过拟合是指训练误差和测试误差之间的差距太大。换句话说，就是模型复杂度高于实际问题，模型在训练集上表现很好，但在测试集上却表现很差。模型对训练集"死记硬背"（记住了不适用于测试集的训练集性质或特点），没有理解数据背后的规律，泛化能力差。 例子2：Logistic回归 Fig2.Logistic regression（截屏自吴恩达机器学习）
三幅图哪个更好呢？不多说，第二张图应该是合理的划分方式，而不是像第三张图那样一板一眼。
为什么会出现过拟合现象？
造成原因主要有以下几种：
1、训练数据集样本单一，样本不足。如果训练样本只有负样本，然后那生成的模型去预测正样本，这肯定预测不准。所以训练样本要尽可能的全面，覆盖所有的数据类型。
2、训练数据中噪声干扰过大。噪声指训练数据中的干扰数据。过多的干扰会导致记录了很多噪声特征，影响了真实输入和输出之间的关系。
3、**模型过于复杂。**模型太复杂，已经能够“死记硬背”记下了训练数据的信息，但是遇到没有见过的数据的时候不能够变通，泛化能力太差。我们希望模型对不同的模型都有稳定的输出。模型太复杂是过拟合的重要因素。
如何解决 过拟合 + 欠拟合 问题 为什么会出现过拟合现象？
造成原因主要有以下几种：
1、“训练数据集样本单一，样本不足”：
如果训练样本只有负样本，然后那生成的模型去预测正样本，这肯定预测不准。所以训练样本要尽可能的全面，覆盖所有的数据类型。
2、训练数据中噪声干扰过大：
噪声指训练数据中的干扰数据。过多的干扰会导致记录了 很多噪声特征 ，忽略了真实输入和输出之间的关系。
3、模型过于复杂：
模型太复杂，已经能够“死记硬背”记下了训练数据的信息，但是遇到没有见过的数据的时候不能够变通，泛化能力太差。我们希望模型对不同的模型都有稳定的输出。模型太复杂是过拟合的重要因素。
我们会从 以上三种情况分别提出解决方案
吴恩达给出的解决方案概要： 3.4.2 解决过拟合+欠拟合问题（包含正则化方法） 参考链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff4db51e1c985ad38f79735c4e7d91af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3514a7c09b0e097d68f080545ac8ee88/" rel="bookmark">
			Zookeeper(持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VIP-01 Zookeeper特性与节点数据类型详解 文章目录 VIP-01 Zookeeper特性与节点数据类型详解正文1. 什么是Zookeeper？2. Zookeeper 核心概念2.1、 文件系统数据结构2.2、监听通知机制2.3、Zookeeper 经典的应用场景3.2. 使用命令行操作zookeeper 正文 什么是ZookeeperZookeeper核心概念Zookeeper实操Zookeeper ACLs权限控制ZooKeeper 内存数据和持久化
在了解Zookeeper之前，需要对分布式相关知识有一定了解，什么是分布式系统呢？通常情况
下，单个物理节点很容易达到性能，计算或者容量的瓶颈，所以这个时候就需要多个物理节点来
共同完成某项任务，一个分布式系统的本质是分布在不同网络或计算机上的程序组件，彼此通过
信息传递来协同工作的系统，而Zookeeper正是一个分布式应用协调框架，在分布式系统架构中
有广泛的应用场景。 1. 什么是Zookeeper？ 官方文档上这么解释zookeeper，它是一个分布式协调框架，是Apache Hadoop 的一个子项
目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同
步服务、集群管理、分布式应用配置项的管理等。
2. Zookeeper 核心概念 上面的解释有点抽象，同学们暂时可以理解为 Zookeeper 是一个用于存储少量数据的基于内存
的数据库，主要有如下两个核心的概念：文件系统数据结构+监听通知机制。
2.1、 文件系统数据结构 Zookeeper维护一个类似文件系统的数据结构：
每个子目录项都被称作为 znode(目录节点)，和文件系统类似，我们能够自由的增加、删除
znode，在一个znode下增加、删除子znode。
有四种类型的znode：
1、PERSISTENT­持久化目录节点
客户端与zookeeper断开连接后，该节点依旧存在，只要不手动删除该节点，他将永远存在
2、 PERSISTENT_SEQUENTIAL­持久化顺序编号目录节点
客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号
3、EPHEMERAL­临时目录节点
客户端与zookeeper断开连接后，该节点被删除
4、EPHEMERAL_SEQUENTIAL­临时顺序编号目录节点
客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号
5. Container 节点（3.5.3 版本新增，如果Container节点下面没有子节点，则Container节点
在未来会被Zookeeper自动清除,定时任务默认60s 检查一次）
6. TTL 节点( 默认禁用，只能通过系统配置 zookeeper.extendedTypesEnabled=true 开启，不稳
定)
2.2、监听通知机制 客户端注册监听它关心的任意节点，或者目录节点及递归子目录节点
如果注册的是对某个节点的监听，则当这个节点被删除，或者被修改时，对应的客户端将被通
知如果注册的是对某个目录的监听，则当这个目录有子节点被创建，或者有子节点被删除，对应
的客户端将被通知如果注册的是对某个目录的递归子节点进行监听，则当这个目录下面的任意子节点有目录结构
的变化（有子节点被创建，或被删除）或者根节点有数据变化时，对应的客户端将被通知。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3514a7c09b0e097d68f080545ac8ee88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4576cb934c74570feb40b45177d0ca41/" rel="bookmark">
			在centos7部署redis7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、目标 在centos7.9上部署安装redis-7.2.3
二、步骤 官网
https://redis.io/download/
1、下载合适版本的redis wget https://github.com/redis/redis/archive/7.2.3.tar.gz --no-check-certificate 如果这个链接失效，自行去官网找个合适的版本
2、安装redis yum install gcc-c++ -y tar -zxf 7.2.3.tar.gz cd redis-7.2.3/ make make install PREFIX=/usr/local/redis 3、修改redis配置 cp redis.conf /usr/local/redis/bin/ sed -i 's/# requirepass foobared/requirepass mypwd123/g' /usr/local/redis/bin/redis.conf sed -i '/^\s*#/!s/127\.0\.0\.1/0\.0\.0\.0/g' /usr/local/redis/bin/redis.conf sed -i 's/daemonize no/daemonize yes/g' /usr/local/redis/bin/redis.conf 注：
● 给redis设置密码mypwd123
● 设置所有主机都能访问redis
● 开启redis即后台启动，默认是前台启动。
4、测试启动redis cd /usr/local/redis/bin/ ./redis-server ./redis.conf ./redis-cli keys * #会报错，因为给redis设置了密码 auth mypwd123 keys * #不报错，因为上面登录了 5、创建redis启动服务脚本 cat &lt;&lt; EOF &gt; /usr/lib/systemd/system/redis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4576cb934c74570feb40b45177d0ca41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d84ff603a3be4677d5ee542a0e8a11/" rel="bookmark">
			iec61850 控制服务 模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;LNodeType id="GGIO_0" lnClass="GGIO"&gt; &lt;DO desc="Enumerated status" name="Beh" type="ENS_0"/&gt; &lt;DO desc="Controllable single point" name="SPCSO1" type="SPC_0"/&gt; &lt;DO desc="Controllable enumerated status" name="Mod" type="ENC_0"/&gt; &lt;DO desc="Controllable single point" name="SPCSO2" type="SPC_1"/&gt; &lt;DO desc="Controllable single point" name="SPCSO3" type="SPC_2"/&gt; &lt;DO desc="Controllable single point" name="SPCSO4" type="SPC_3"/&gt; &lt;DO desc="Integer status setting" name="NumSubIntv" type="ING_0"/&gt; &lt;/LNodeType&gt; &lt;DOType cdc="SPC" desc="Controllable single point" id="SPC_0"&gt; &lt;DA bType="Struct" fc="CO" name="Oper" type="Oper_0"/&gt; &lt;DA bType="BOOLEAN" dchg="true" fc="ST" name="stVal"/&gt; &lt;DA bType="Quality" fc="ST" name="q" qchg="true"/&gt; &lt;DA bType="Timestamp" fc="ST" name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61d84ff603a3be4677d5ee542a0e8a11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7cf06d0e481584499ad7a5df0f66000/" rel="bookmark">
			【技能---500G硬盘-Ubuntu 20.04安装分区参考】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Ubuntu 20.04安装分区指导安装分区流程Ubuntu 系统分区关键一步----- 选择安装启动引导器的设备 Ubuntu 20.04安装分区指导 安装Ubuntu 20.04的时候可以自己指定各个内存空间的占用，值得注意的是，这里的分区有一定的技巧！！！
当前我们拥有一个500G的固态硬盘，下面将进行我们的分区安排。
安装分区流程 当我们在安装过程中进行到 “”安装类型“” 的选择中，我们选择第三个，也即是：
其他选项 您可以自己创建、调整分区，或者为Ubuntu选择多个分区。 Ubuntu 系统分区 找到空闲区域（512000MB），双击即可将其进行划分，划分四次结束
efi系统分区大小：1-2GB，系统的引导文件都在这里。 交换空间 ：大小根据电脑的内存大小配置，如果电脑16G运行就分16000MB “/” 根目录 ：可分配空间的30%，此处为500GB×0.3，即大约150000 MB /home :我们平时的文件大多数放这里，所以这里也是最大的，将剩下的全给home （后续使用中发现太小了，/和/home都尽量放大，大家可根据总的可分配容量进行调整）
关键一步----- 选择安装启动引导器的设备 即EFI系统分区时的设备号！
后续就按步骤操作，so easy！！！！！
当然这也只是分区的一种方法，可以参考参考！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06dc7c36ce75ac65e8fe5b98af530f35/" rel="bookmark">
			通俗易懂的15个Java Lambda表达式案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. **实现Runnable接口**：2. **事件监听器**（如Swing中的ActionListener）：3. **集合遍历**（使用`forEach`方法）：4. **过滤集合**（使用Stream API）：5. **映射集合元素**：6. **排序集合**：7. **函数引用作为lambda**：8. **使用Consumer接口**：9. **Predicate接口的应用**：10. **使用Supplier接口**：11. **使用Function接口**：12. **并行流处理**：13. **Optional类的map和filter方法**：14. **比较器构造**（Comparator.comparing()）：15. **方法引用作为lambda的返回值**： 当然，以下是Java Lambda表达式的10个典型使用案例： 1. 实现Runnable接口： // 在Java 8之前，我们这样写： new Thread(new Runnable() { @Override public void run() { System.out.println("Hello from a thread"); } }).start(); // 使用lambda简化后： new Thread(() -&gt; System.out.println("Hello from a thread")).start(); 2. 事件监听器（如Swing中的ActionListener）： // 传统匿名类方式： button.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { System.out.println("Button clicked"); } }); // 使用lambda表达式： button.addActionListener(e -&gt; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06dc7c36ce75ac65e8fe5b98af530f35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5b481fba0dc2735da99897e5df55ece/" rel="bookmark">
			LINUX空间管理之du与df命令查看磁盘容量不一致问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题现象 在Linux系统的运行过程中，会经常遇到磁盘使用率过高，通过执行du与df命令查看磁盘容量确出现不一致的现象，例如以下几种现象：
执行du和df命令显示的结果不一致，df比du命令显示的数据大很多。
使用df命令显示磁盘使用率过高，但是执行du命令统计目录时却磁盘使用率不高，且查不到已删除的句柄文件。
当前系统存在数据盘挂载点，使用df命令查看系统盘容量已满，但是在根目录下使用du命令统计各文件总容量，但是合计达不到总容量。
二、原因分析 首先了解下du和df的工作原理：
du命令会对待统计文件逐个调用fstat这个系统调用，获取文件大小。它的数据是基于文件获取的，所以有很大的灵活性，不一定非要针对一个分区，可以跨越多个分区操作。如果针对的目录中文件很多，du速度就会很慢了。
df命令使用的事statfs这个系统调用，直接读取分区的超级块信息获取分区使用情况。它的数据是基于分区元数据的，所以只能针对整个分区。由于df直接读取超级块，所以运行速度不受文件多少影响。
其次，出现du和df统计的值有较大偏差时，主要会有以下几种原因：
1、用户删除了大量的仍在使用的文件后，du命令不会在文件系统目录中统计这些文件。因为这个已经被删除的文件句柄不会真正在磁盘中被删除，分区超级块中的inode信息不会更改，df命令仍会统计这个被删除的文件。 此时可通过lsof命令查询处于deleted状态的文件，被删除的文件在系统中被标记为deleted。如果系统有大量deleted状态的文件，会导致du和df命令统计结果不一致。
2、当用du -sh *命令来统计某个目录总容量时，如果该路径下包含隐藏文件，是不会包含在统计结果里的。
3、由于数据盘挂载前该路径下就存在文件，挂载后用du无法查询到原路径下文件大小。
三、处理建议 1、先通过lsof|grep delete查询目标目录下是否有被标记为已删除的文件，如有通过重启该文件所使用的进程可释放空间。（如是日志类文件，在暂时无法重启程序的情况下，也可通过进入/proc/进程ID/fd目录下，找到删除的文件，然后执行清空命令，可临时释放空间的问题。）
2、在目标目录下，执行du -ah命令统计结果中看是否包含较大的隐藏文件。
3、排除了1和2的原因检查后仍未解决问题，考虑可停业务应用，卸载数据盘后再次使用du命令查询，看是否定位到原因。
4、以上排除均未找到问题，建议对所有应用程序进行一个停止，观察是否有释放，从而进行进一步定位。
5、一时半会找不到原因的，也可通过扩容文件系统，先降低高水位情况， 再持续分析，毕竟扩容也只是治标不治本。
最后，如果觉得本文对你有帮助，欢迎点赞、收藏、评论！
There are many things that can not be broken！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d775ede229daa4d21de8849b5e478283/" rel="bookmark">
			K8S容器的一则故障记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、故障现象 XXX反馈说某某业务服务异常，无法启动，需要进行协助排查。经常会接到这样一个需求，一开始无法清楚知道具体什么问题，需要跟一线运维人员详细做沟通，了解故障问题的细节。
根据一线运维人员的反馈，是有一套5节点单master的k8s集群，其中一个node异常重启后，导致上面一个关键mysql服务pod（有持久化存储）无法启动，从而影响到整体业务。一线检查集群反馈服务状态都正常。
二、分析过程 1、单pod问题？ 从当前情况看，表面现象是说mysql的pod无法启动，也没法切换。但是不是只有这一个问题呢？一开始怀疑是不是mysql做了标签绑定，只能在该node运行，检查一番并没有。
2、单node问题？ 既然不是单单mysql容器问题，那会不会是这个故障node的问题？检查node各个服务状态和日志，看起来也没什么异常。既然日志没异常，手动做些测试看看。
1）调度一个非持久化的pod到该节点----发现也无法调度到该节点上，表明node层确实有些问题
2）在故障node手动创建个docker，可以运行---证明docker容器本身没问题
3、集群问题 单node无法调度上去，可能是node本身问题，但node相关日志检查又都无异常。怀疑是上一层集群侧有问题。先测试验证下，从其他节点调度容器或者新建容器，发现都无生产。证明了还是集群侧有问题。
开始着重排查集群的问题，对集群各个组件进行逐一排查。PS：再温习下k8s各个组件作用
kube-apiserver ： 提供了资源的增、删、改、查等操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；
kube-scheduler ：负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；
kube-controller-manager：负责维护集群的状态，资源对象的自动化控制中心，比如故障检测、自动扩展、滚动更新、服务帐户和令牌控制器等；
etcd ：k8s的所有资源对象的数据都保存在etcd中；
1）从前面现象看，调度出了问题，和schedule有关?检查一番schedule没发现啥。
2) 其他几个组件服务也要检查看看，第一个看到etcd的日志有很多reject connection的错误，有些可疑，开始从这个方向排查，ntp时间、证书、配置等等一一检查，发现也不是这个问题导致。
3）检查apiserver，日志中有个metrics资源报错。
memcache.go:couldn't get resource list for metrics/vlalphal: the server could not find the requested resource。
4）检查controller，日志中看发现服务一直在重启中，且也有metric相关报错。
controllermanager.go:174] error starting controllers: failed to discover resources: unable to retrieve the complete list of server APIs: metrics/v1alpha1: the server could not find the requested resource
5）都指向了metric，那就检查这个pod的日志，发现有连不上其中一个节点kubelet的错误。
kubectl get pod -n kube-system -owide kubectl logs **metric** -n kube-system 6）登到这个节点检查kubelet服务，确实服务报错没起起来，排查一通。发现这个节点上也有controller、api、schedule服务启动，等等，不是说单master架构么？？？怎么这里也有组件服务，后来问一线运维，这个原来是之前部署时留的坑，服务自启动没关闭，导致主机重启后服务自己启动起来，手动把这些服务关闭掉，再重启kubelet，咋还是不行？再来各种检查，发现kubelet的配置文件没有，一线运维之前做了文件备份，但原配置文件居然不在，不知道是不是用的MV命令而不是CP命令.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d775ede229daa4d21de8849b5e478283/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef0ab0af999f9fb6f2007f575b2762d9/" rel="bookmark">
			Elasticsearch 优化常用思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、硬件选择 Elasticsearch 的基础是 Lucene，所有的索引和文档数据是存储在本地的磁盘中，具体的路径可在 ES 的配置文件../config/elasticsearch.yml 中配置，如下： #----------------------------------- Paths
------------------------------------
# # Path to directory where to store the data (separate multiple locations by comma):
#
#path.data: /path/to/data
#
# Path to log files:
#
#path.logs: /path/to/logs #
磁盘在现代服务器上通常都是瓶颈。Elasticsearch 重度使用磁盘，你的磁盘能处理的吞吐量越大，你的节点就越稳定。这里有一些优化磁盘 I/O 的技巧： 使用 SSD， 他们比机械磁盘优秀多了。 使用 RAID 0。条带化 RAID 会提高磁盘 I/O，代价显然就是当一块硬盘故障时整个就故障了。不要使用镜像或者奇偶校验 RAID 因为副本已经提供了这个功能。 另外，使用多块硬盘，并允许 Elasticsearch 通过多个 path.data 目录配置把数据条带化分配到它们上面。 不要使用远程挂载的存储，比如 NFS 或者 SMB/CIFS。这个引入的延迟对性能来说完全是背道而驰的。 2、分片策略 2.1、合理设置分片数 分片和副本的设计为 ES 提供了支持分布式和故障转移的特性，但并不意味着分片和副本是可以无限分配的。而且索引的分片完成分配后由于索引的路由机制，我们是不能重新修改分片数的。可能有人会说，我不知道这个索引将来会变得多大，并且过后我也不能更改索引的大小，所以为了保险起见，还是给它设为 1000 个分片吧。但是需要知道的是，一个分片并不是没有代价的。需要了解： 一个分片的底层即为一个 Lucene 索引，会消耗一定文件句柄、内存、以及 CPU 运转。 每一个搜索请求都需要命中索引中的每一个分片，如果每一个分片都处于不同的节点还好， 但如果多个分片都需要在同一个节点上竞争使用相同的资源就有些糟糕了。 用于计算相关度的词项统计信息是基于分片的。如果有许多分片，每一个都只有很少的数据会导致很低的相关度。 一个业务索引具体需要分配多少分片可能需要架构师和技术人员对业务的增长有个预先的判断，横向扩展应当分阶段进行。为下一阶段准备好足够的资源。 只有当你进入到下一个阶段，你才有时间思考需要作出哪些改变来达到这个阶段。一般来说，我们遵循一些原则： 控制每个分片占用的硬盘容量不超过 ES 的最大 JVM 的堆空间设置（一般设置不超过 32G，参考下文的 JVM 设置原则），因此，如果索引的总容量在 500G 左右，那分片大小在 16 个左右即可；当然，最好同时考虑原则 2。 考虑一下 node 数量，一般一个节点有时候就是一台物理机，如果分片数过多，大大超过了节点数，很可能会导致一个节点上存在多个分片，一旦该节点故障，即使保持了1个以上的副本，同样有可能会导致数据丢失，集群无法恢复。所以， 一般都设置分片数不超过节点数的3倍。 主分片，副本和节点最大数之间数量，我们分配的时候可以参考以下关系：节点数&lt;=主分片数*（副本数+1） 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef0ab0af999f9fb6f2007f575b2762d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e27f735001f16ba5eda8bf7ebf354580/" rel="bookmark">
			flask&#43;ansible 打造自己的自动化运维平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 随着企业信息化要求越来越高，云化架构带来挑战和冲击，海量设备的运维压力也是越来越大，虽然有了批量操作工具，但自动化运维工具操作主要还是依赖于手工执行（脚本小子），手工执行又存在着操作流程不规范，操作记录不可控，批量脚本不统一等多个问题，有较大风险造成人为误操作的可能。
一直以来是想做个系统来规避这些问题，前期也有过其他开发团队开发过此类产品试用，但开发不懂运维，测试起来很多问题，这些问题后来因为开发项目无法支撑流产了，也没实际用起来。
批量操作的工具，用过puppet、saltstack、ansible，管理资产超过5000+，目前在用ansible。 Ansible了解过有个官方系统tower，测试装了下，人太高大上，也不是很符合我们批量操作使用的场景。
近来时间比较充裕，学习了下python的开发框架，自己动手，按照自己的需求来开发，可以更贴合使用。以前觉得开发好难好难，真动手去做了，做个简单系统自己内部使用还是可以的~
系统中使用的框架是python flask + ansible+mysql。
二、系统设计 系统整体分7个模块： 登录页面：系统的入口，所有其他页面需要做登录控制，只有登录后才能使用。登录只简单做下账号密码验证，什么双因子，验证码防爆力破解的安全要求后期看需要再实现了。
首页：用户登录后，展示的平台整体情况，简单的图表展示，展示一些统计类，top类数据，趋势类数据。
接入清单：对纳管主机的管控视图，支持常规字段的查询。
主机导入：支持页面导入自定义主机分组，导入结果入库，页面支持主机组信息查询。
模板页面：自定义模板的上传页面，规定模板上传的格式，上传后支持查询。
作业页面：可以基于模板去配置作业，配置作业后支持查询记录，支持作业的一个测试拨测并可查询测试结果。
作业记录：作业正式执行的界面，带入测试的记录，支持执行按钮、异步作业和执行结果查询。
三、实现过程 项目Flask程序的目录结构如下：
ansible/
├── app.py ----flask主程序
├── blueprints ----蓝图目录 各模块后台处理代码
├── config.py ----配置文件 数据库等配置文件
├── decorators.py ----装饰器 代码重用文件
├── exts.py ----解决循环引用的问题
├── migrations ----数据库迁移目录 数据库类操作
├── models.py ----数据库模型文件 数据库表初始化设置
├── mycelery.py ----异步处理的代码
├── scrtpts ----ansible 调用的脚本目录
├── static ----前台页面的静态文件 css，js，image等
└── templates ----前台页面的html模板
1、登录页面 套用的是之前学习过的一个测试项目登录页面，本来还涉及邮箱注册的功能，考虑到我这个不放在公网使用，就修改去掉了，用户账号增加通过后台录入数据。
登录需要做个登录控制，每个页面访问前需要先登录。可以设置登录装饰器如下：
def login_required(func): # 保留func的信息 @wraps(func) # func(a,b,c) # func(1,2,c=3) def inner(*args, **kwargs): if g.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e27f735001f16ba5eda8bf7ebf354580/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c4728d6ef00c565fdeb8cbde30c89b/" rel="bookmark">
			vue2实现自定义音乐播放器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * { margin: 0; padding: 0; box-sizing: border-box; } .self_progress { background-image: linear-gradient(to right, #00d09b, #00dfc4); transition: all 0.3s; } .lyrics { overflow-y: scroll; text-align: center; line-height: 25px; font-size: 14px; } ::-webkit-scrollbar { display: none; } .text { position: relative; white-space: nowrap; overflow: hidden; width: 100%; color: transparent; background: linear-gradient(to right, #00dfc4, #0098a6); background-clip: text; animation: fill-lyrics linear forwards; } @keyframes fill-lyrics { 0% { background-size: 0 100%; } 100% { background-size: 100% 100%; } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30c4728d6ef00c565fdeb8cbde30c89b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc76fec04852a30527732868aadab587/" rel="bookmark">
			电脑软件：CoolUtils Total Excel Converter：解决Excel格式转换难题，提升办公效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家在日常办公当中经常会遇到需要把Excel转换为其他文档格式的场景。今天小编给大家介绍一款强大的文件转换工具——Total Excel Converter，有了它，再也不会因为Excel文档格式转换的问题而烦恼了。
一、软件简介 CoolUtils Total Excel Converter官方版是一款专业的Excel万能转换器工具，该软件的官方版本可以将每个工作表转换成一个新文件，该软件支持将Excel（.xls, .xlsx, .xlsm, .xlsb等）格式的文件批量转换为多种常见格式，包括PDF、CSV、DBF、TXT、XML等，满足了用户在不同场景下的需求。这个对于我们日常办公来说非常有帮助！
二、功能介绍 1、快速可靠，友好的用于操作界面
2、支持导出的格式：DOC，PDF，HTML，MHT，XHTML，CSV，TXT，TIFF，JPEG，SVG，RTF，XML，XLS，XLSX，ODS，ODT，Lotus，DIFF，SYLK，LATEX，SQL，DBF，Access。
5、支持批量转换
7、源格式：XLS，XLSX，CSV，TSV，XLSM，XLSB，XLT，XLTM，XLTX，XLK，XLW，OTS，PXL，QPW，WB2，WB1，WQ2，WQ1，SDC，VOR，DBF，SLK，UOS，UOF ，WK1，WK2，WK3，WK4，WKS，WAB，DIF，ET，Clarion，DBISAM，Advantage等几十种格式。
三、安装教程 双击安装exe文件，进入选择软件语言，目前没有中文版。
点击ok，进入安装引导界面
点击Next，进入安装位置选择界面
继续点击Next进入开始菜单的名称
然后进入安装配置完成界面
这里我们点击Install就可以进行安装了。
安装成功界面如下：
四、使用简单介绍 首先打开安装好的软件，然后试一下转换为Doc。首先选择Excel文件文件如下：
，然后点击doc图标。
然后我们点击start按钮
转换为SQL语句
这对于程序员来说非常实用的，比如数据导入的场景。其他功能大家可以自行研究使用。
五、软件总结 CoolUtils Total Excel Converter凭借其丰富多样的转换选项、高效的批量处理能力，可以解决了用户在Excel文件格式转换过程中可能遇到的各种难题。无论您是企业员工、自由职业者还是学生，只要有跨格式处理Excel文件的需求，Total Excel Converter都将为您提供强大且稳定的解决方案，让数据转换变得更轻松、更高效。
下载地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311a818c989f3cc73980e7aae8e07730/" rel="bookmark">
			【GoLang入门教程】Go语言几种标准库介绍(四)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程语言的未来？ 文章目录 编程语言的未来？前言几种库fmt库 (格式化操作)关键函数：示例 Go库标准库第三方库示例 html库(HTML 转义及模板系统)主要功能：示例 总结专栏集锦写在最后 前言 上一篇，我们介绍了debug、encoding、flag三个库，这篇我们继续介绍剩下的库
几种库 fmt库 (格式化操作) 在 Go 语言的标准库中，fmt 包提供了格式化输入输出的功能。
这个包包括了一系列函数，用于将数据格式化为字符串（fmt.Sprintf）、输出到控制台（fmt.Print、fmt.Println、fmt.Printf）以及读取输入数据（fmt.Scan、fmt.Scanf、fmt.Scanln）等。
关键函数： Print、Println、Printf： 用于将格式化的文本输出到标准输出。Println 会在输出的文本末尾添加换行符。Scan、Scanln、Scanf： 用于从标准输入读取数据。Scanln 会在读取后换行。Sprint、Sprintln、Sprintf： 用于将数据格式化为字符串而不输出。Fprint、Fprintln、Fprintf： 用于将格式化的文本输出到指定的 io.Writer。 示例 package main import "fmt" func main() { // Println示例 fmt.Println("Hello, Golang!") // Printf示例 name := "Alice" age := 25 fmt.Printf("Name: %s, Age: %d\n", name, age) // Sprintf示例 formattedString := fmt.Sprintf("Name: %s, Age: %d", name, age) fmt.Println(formattedString) // Scan示例 var inputName string var inputAge int fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/311a818c989f3cc73980e7aae8e07730/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f11ba817b590b34de4dfc4ce435c4bc/" rel="bookmark">
			DMA查询方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50331303c319bb784a346be399283620/" rel="bookmark">
			C&#43;&#43;面向对象语法总结(三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 《C++基础语法总结》《C++面向对象语法总结(一）》《C++面向对象语法总结(二）》 二十一、多继承 C++允许一个类可以有多个父类（不建议使用，会增加程序设计复杂度）在多继承中，会按照继承顺序将父类的成员变量放到子类成员变量的前面
多继承体系中，子类调用父类构造函数只需要在初始化列表中调用即可
如果子类继承的多个父类都有虚函数，那么子类对象就会产生对应的多张虚表
如果子类和父类中都有相同的同名函数，直接调用会调用子类中的函数，调用父类中的同名函数需要显式指定父类名称
如果子类和父类都具有同名的成员变量，直接调用会调用子类的成员变量，如果需要调用父类的成员变量，需要显式指定调用的父类
二十二、菱形继承 菱形继承指的是两个类继承了一个超类，然后有一个子类又多继承了这两个类，其继承关系图类似于菱形
菱形继承的问题
最底下的子类从积累继承的成员变量冗余、重复最底下的子类无法访问基类的成员，有二义性
二十三、虚继承 虚继承指的是在继承的类前面加上virtual关键字虚继承可以解决菱形继承带来的问题Person类被称为虚基类
虚继承会增加内存中的数据量，在虚继承中，虚表中一般会包含两个偏移量 虚表指针于本类起始的偏移量（一般是0）虚基类第一个成员变量与本类起始的偏移量
虚继承的内存图（32位环境）
二十四、静态成员（static） 静态成员：被static修饰的成员变量或函数
可以通过对象（对象.静态成员）、对象指针（对象指针 -&gt; 静态成员）、类（类::静态成员）来访问静态成员变量或函数 静态成员变量
存储在数据段（全局区，类似于全局变量），整个程序运行过程中只有一份内存对比全局变量，它可以设定访问权限（public、protected、private），达到局部共享的目的必须初始化，而且必须在类的外面初始化，初始化时不能带static，如果累的声明和实现分离，需要在实现（cpp文件）中初始化
静态成员函数
内部不能使用this指针（this指针只能用在非静态成员函数内部）不能是虚函数（虚函数只能是非静态成员函数）内部不能访问非静态的成员变量和函数，只能访问静态的成员变量和函数非静态成员函数内部可以访问静态成员变量和函数构造函数、析构函数不能是静态当声明和实现分离时，实现部分不能带static 静态成员经典应用——单例模式
二十五、const成员 const成员：被const修饰的成员变量、非静态成员函数const成员变量 必须初始化（类内部初始化），可以在声明的时候直接初始化赋值非static的const成员变量还可以再初始化列表中初始化 const成员函数（非静态） const关键字写在参数列表后面，函数的声明和实现都必须带const内部不能修改非static成员变量内部只能调用const成员函数，static成员函数非const成员函数可以调用const成员函数const成员函数和非const成员函数构成重载非const对象（指针）优先调用非const成员函数const对象（指针）只能调用const成员函数、static成员函数
二十六、引用类型成员 引用类型成员变量必须初始化（不考虑static情况） 在声明的时候直接初始化通过初始化列表初始化
二十七、拷贝构造函数（Copy Constructor） 拷贝构造函数是构造函数的一种当利用已存在的对象创建一个新对象（类似于拷贝），就会调用新对象的拷贝构造函数进行初始化拷贝构造函数格式是固定的，接受一个const引用作为参数类中默认的拷贝构造函数是直接拷贝已有对象的内存，当对象中有指针变量时，也是拷贝的指针变量的值，而不是指针变量指向的对象，所以是浅拷贝
继承体系中调用父类的拷贝构造函数直接在初始化列表显式调用，继承体系中默认也会直接拷贝父类对象的内存（因为变量的内存是连续的）
拷贝构造函数的使用 下面代码中，car2、car3都是通过拷贝构造函数初始化的，car、car4是通过非拷贝构造函数初始化的变量前面有类型是新建对象的操作，没有类型是赋值操作，如car4=car3就是复制操作（默认是浅拷贝），并不会调用拷贝构造函数
二十八、浅拷贝、深拷贝 对于指针变量，如果只是拷贝了指针的地址，并没有拷贝指向的具体的值，叫做浅拷贝，如果拷贝了指向的值，就叫做深拷贝编译器默认提供的拷贝是浅拷贝 将一个对象中所有成员变量的值拷贝到另一个对象（直接拷贝内存中的值）如果某个成员变量是指针，只会拷贝指针中存储的地址值，并不会拷贝指针指向的内存空间的值可能会导致堆空间多次free的情况，因为浅拷贝拷贝的是地址，在拷贝的不同对象中free内存，实际上释放的是同一个内存空间 如果需要实现深拷贝，就需要自定义拷贝构造函数 将指针类型的成员变量所指向的内存空间内的值，拷贝到新的内存空间 深拷贝示例
二十九、对象型参数和返回值 使用对象类型作为函数的参数或者返回值，是进行了对象拷贝的，可能会产生一些不必要的中间对象函数参数默认是拷贝传递，所以作为对象参数，也会拷贝因为函数栈中的对象调用完会释放，所以作为返回值的时候，编译器必须进行拷贝，原来函数中的对象已经释放了
三十、匿名对象（临时对象） 匿名对象：没有变量名、没有被指针指向的对象，用完后马上调用析构匿名对象作为实参和返回值时，编译器会做优化，只会产生一个对象，调用一次构造函数
三十一、隐式构造 c++ 中存在隐式构造的现象：在某些情况下，会隐式调用单参数的构造函数
可以通过关键字explicit禁止掉隐式构造
三十二、编译器自动生产构造函数的情况 c++的编译器在某些特定的情况下，会给类自动生成无参的构造函数，比如
成员变量在声明的同时进行了初始化有定义虚函数继承了其他的类包含了对象类型成员，且这个成员有构造函数（编译器生成或自定义）父类有构造函数（编译器生成或自定义） 对象创建后，需要做一些额外的操作时（比如内存操作、函数调用），编译器一般都会为其自动生成无参的构造函数
并不是所有情况都会生成无参的构造函数
三十三、内部类 如果将类A定义在类C的内部，那么类A就是一个内部类（嵌套类）内部类的特点 支持public、protected、private权限成员函数可以直接访问其外部类的所有成员（反过来则不行）成员函数可以直接不带类名、对象名访问其外部类的static成员不会影响外部类的内存布局可以在外部类内部声明，在外部类外面进行定义
内部类声明和实现分离的写法
三十四、友元 友元包括友元函数和友元类如果将函数A（非成员函数）声明为类C的友元，那么函数A就能直接访问类C对象的所有成员如果将类A声明为类C的友元，那么类A中的所有成员函数都能直接访问类C对象的所有成员友元破坏了面向对象的封装性，但在某些频繁访问成员变量的地方可以提高性能友元的声明可以在类的任何位置
三十五、局部类 在一个函数内部定义的类，称为局部类局部类的特点 作用域仅限于所在函数内部其所有成员必须定义在类内部，不允许定义static成员变量成员函数不能直接访问函数的局部变量（static变量除外）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50331303c319bb784a346be399283620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5cf424b42f641067d2aebf943682d2a/" rel="bookmark">
			实例：NodeJS 操作 Kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人是C#出身的程序员，c#很简单就能实现，有需要的可以加我私聊。但是就目前流行的开发语言，尤其是面向web方向应用的，我感觉就是Nodejs最简单了。下面介绍：
本文将会介绍在windows环境下启动Kafka，并通过nodejs作为客户端，生产并消费消息。
步骤一，Kafka需要java运行时，先安装配置java环境。通过在命令行中输入java -version确认java是否成功安装(可能需要查看windows的环境变量中是否有java)。
步骤二，Kafka官网下载最新版本的压缩包(.tgz格式)，并解压。分别在两个命令行里面启动zookeeper、kafka（解压缩路径下）
bin\windows\zookeeper-server-start.bat config\zookeeper.properties
bin\windows\kafka-server-start.bat config\server.properties
说明一下zookeeper和kafka的关系:zookeeper是集群的调度者，kafka才是消息队列。 zookeeper的默认端口：2181，kafka的默认端口：9092
相关配置可以在config文件下的server.properties和zookeeper.properties中找到
用记事本打开就可以编辑
建立data,logs,kafka-logs目录，用于日志，备用。
消费者客户端需要的group.id可以在config-&gt;consumer.properties中找到。
步骤三，使用DOS的CMD管理员命令行方式测试生产者生产、消费者消费。
//创建一个topic：test
bin\windows\kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test
//查看topic
bin\windows\kafka-topics.bat --list --zookeeper localhost:2181
//创建生产者主题mytest
bin\windows\kafka-console-producer.bat --broker-list localhost:9092 --topic test-nodetopic
//创建消费者消费mytest
bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test-nodetopic --from-beginning
步骤四，生产者发送消息
在生产者窗口，随意输入一条消息，可以在消费者窗口看到该消息。
最后，使用nodejs访问kafka 首先安装kafkajs
初始化项目
npm init -y
没有安装kafkajs的，在这里可以安装，互联网在线安装。
npm install kafkajs
新建demo2023.js，输入以下代码
const { Kafka } = require('kafkajs')
const kafka = new Kafka({
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5cf424b42f641067d2aebf943682d2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a847b87c5d85e9f5d793a2f3629bd8fc/" rel="bookmark">
			中断请求分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e7752d45a20e73fd458dc369978047f/" rel="bookmark">
			Nginx 负载均衡集群 节点健康检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 正常情况下，nginx 做反向代理负载均衡的话，如果后端节点服务器宕掉的话，nginx 默认是不能把这台服务器踢出 upstream 负载集群的，所以还会有请求转发到后端的这台服务器上面，这样势必造成网站访问故障
注：实际上不仅是后端节点宕掉需要踢出集群，如果说我们发布服务，那么节点服务启动和关闭也是需要时间的，此时也需要踢出和加入集群操作
请求转发 最简单的做法就是使用 proxy_next_upstream，实现请求转发，就是在 localtion 中启用 proxy_next_upstream 来解决返回给用户的错误页面，示例如下：
location / { # 如果后端的服务器返回502、504、执行超时等错误 # 自动将请求转发到upstream负载均衡池中的另一台服务器，实现故障转移。 proxy_next_upstream http_502 http_504 http_404 error timeout invalid_header; } 虽然这样问题可以解决，但是请求还是会转发给这台服务器，然后再转发给别的服务器，这样以来就浪费了一次转发，会损耗网站性能
健康检查 为了避免上述问题，我们可以对后端节点进行节点检查，目前主要有如下三种方式可以实现对 nginx 负载均衡的后端节点服务器进行健康检查
nginx 自带模块ngx_http_proxy_module 和 ngx_http_upstream_module
ngx_http_healthcheck_module 模块，这是 nginx 官方早期推出的健康检查的模块，但是目前仅支持 nginx 的 1.0.0 版本，1.1.0 版本以后均不支持，常见的生产环境上基本不会使用该模块
淘宝技术团队开发的 nginx_upstream_check_module 模块，更加专业
本次我们使用第三种方法实现节点健康检查
淘宝技术团队开发的 nginx 模快 nginx_upstream_check_module 可以检测后方 realserver 的健康状态，如果后端服务器不可用，则会将其踢出 upstream，所有的请求不转发到这台服务器。当期恢复正常时，将其加入 upstream
在淘宝自己的 tengine 上是自带了该模块的，大家可以访问淘宝 tengine 来获取安装，如果没有使用淘宝的 tengine 的话，也可以通过补丁的方式来添加该模块到 nginx 中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e7752d45a20e73fd458dc369978047f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e41461ab00d4b2ec6b45f84a40e210b5/" rel="bookmark">
			组合算法简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合算法 目录概述需求： 设计思路实现思路分析1.简单的字符串方式 参考资料和推荐阅读 Survive by day and develop by night.
talk for import biz , show your perfect code,full busy，skip hardness,make a better result,wait for change,challenge Survive.
happy for hardess to solve denpendies.
目录 概述 组合算法是一个非常常见的需求。
需求： 设计思路 实现思路分析 1.简单的字符串方式 这里限于时间原因：给出如下实现：
public class demo { public static void combination(String[] s) { if (s.length == 0) { return; } int len = s.length; int n = 1 &lt;&lt; len; // 从1循环到2^len-1 for (int i = 1; i &lt; n; i++) { StringBuffer sb = new StringBuffer(); // 查看第一层循环里面的任意一种取值当中的哪一位是1[比如ab,011]， 如果是1，对应的字符就存在，打印当前组合。 String sum = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e41461ab00d4b2ec6b45f84a40e210b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa44562f62c76a8c0250c16328e88309/" rel="bookmark">
			网络安全基础之访问控制模型详解——DAC, MAC, RBAC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、访问控制模型的分类2、自主访问控制模型DAC访问控制表ACL与访问能力表CL访问控制列表（权限与客体关联）访问能力列表（权限与主体关联） 缺点 3. 强制访问控制模型MACBLP （Bell-LaPadula Model)安全级别安全级别之间的支配关系安全策略 BiBa模型（1977年由Biba提出）Biba的模型构成安全策略 Clark-Wilson（1987年由David D. Clark和David R. Wilson提出）安全策略 Chinese Wall 模型控制策略访问控制规则 4、基于角色的访问控制RBACRBAC 的核心概念RBAC 的类型RBAC 的优势 随着数据泄露事件的频繁发生和网络攻击的日益复杂化，确保敏感数据和关键资源的安全变得越来越重要。在众多网络安全措施中，访问控制模型扮演着至关重要的角色。 什么是访问控制
为用户对系统资源提供最大限度共享的基础上，对用户的访问权进行管理，防止对信息的非授权篡改和滥用
什么是访问控制模型
对一系列访问控制规则集合的描述，可以是非形式化的，也可以是形式化的。
访问控制的核心要素
访问控制模型基于三个基本元素：主体（Subject）、客体（Object）和访问权限（Access Rights）。主体通常指请求访问资源的用户或程序，客体则是被访问的资源，如文件、数据库或系统资源等。访问权限定义了主体对客体的操作权限，例如读取、写入或执行等。
1、访问控制模型的分类 访问控制模型主要分为三类：自主访问控制（DAC）、强制访问控制（MAC）和基于角色的访问控制（RBAC）。每种模型都有其独特的特点和应用场景，而选择合适的模型则取决于组织的具体需求和安全策略
访问控制模型 自主访问控制模型\nDAC 访问矩阵模型 访问控制列表\n ACL 访问能力表 \nCapacity List 强制访问控制模型 \nMAC 保密性模型 完整性模型 混合策略模型 Bell-LaPadula 模型 Biba 模型 Clark-Wilson 模型 Chinese Wall 模型 基于角色的访问控制模型 RBAC 系统内置多个角色\n将权限与角色进行联 2、自主访问控制模型DAC 自主访问控制模型（DAC）
创建者(客体的属主)能够决定该客体的访问权限灵活，具有较好的易用性和可扩展性安全性不高 自主访问控制模型DAC 访问矩阵模型 访问控制列表 ACL 权能列表 Capacity List DAC的实现机制: 通过访问控制表/矩阵实现
简而言之，通过管理员赋予不同用户对不同目标的读，写，所属权限来实现权限管理。
用户 / 目标目标a目标b目标c目标d用户aR, W, Own用户bR, W, OwnR, W, Own用户cRR, WRR用户dRR, WRR 访问控制表ACL与访问能力表CL 访问控制列表（权限与客体关联） 基于对象的控制：ACL是依附于每个对象（如文件或目录）的（或者称之为客体）。每个对象都有一个列表，指定了哪些用户（或用户组）可以访问该对象，以及他们拥有的权限类型（如读、写、执行）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa44562f62c76a8c0250c16328e88309/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34ef1164782f48f89a8bc29f795040fd/" rel="bookmark">
			axi4，求wstrb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一：一次求出所有数据的wstrb
已知awaddr，awlen，awsize，bksize，求wstrb
bit(127:0) wb();
bit(127:0)wsb(awlen+1)；
a=2**awsize;
b=awlen+1;
wb()=new(a*b);
end=awaddr(6:0)+bksize;
方式二：一次只求出一个数据的wstrb
已知awaddr，bksize，求wstrb
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aac7ecf68c0877e78e2a0fbf54306df2/" rel="bookmark">
			008文章解读与程序——《含分布式电源接入的配电网可靠性评估》已提供下载资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆下载资源链接👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆
摘要：分布式电源的接入使得配电系统从放射状无源网络变为分布有中小型电源的有源网络。带来了使单向流动的电流方向具有了不确定性等等问题，使得配电系统的控制和管理变得更加复杂。但同时，分布式电源又具有提高电网可靠性，绿色节能，等等优点，所以为更好的利用分布式电源为人类造福，我们必须对其进行研究与分析。
本文采取通过利用仿真软件Matlab编写计算潮流程序模拟分布式电源接入配电网的模型进行潮流计算的方法对分布式电源的稳态影响进行探索与分析。选取了34节点的配电网网络模型，通过对单个以及多个分布式电源的接入位置以及容量的不同情况对34节点配电网的网损以及节点电压状况进行了分析。
部分代码展示：
clc clear close all %%运行潮流 t0 = clock; %% 列索引 [PQ, PV, REF, NONE, BUS_I, BUS_TYPE, PD, QD, GS, BS, BUS_AREA, VM, VA, BASE_KV, ZONE, VMAX, VMIN, LAM_P, LAM_Q, MU_VMAX, MU_VMIN] = idx_bus; [F_BUS, T_BUS, BR_R, BR_X, BR_B, RATE_A, RATE_B, RATE_C, TAP, SHIFT, BR_STATUS, PF, QF, PT, QT, MU_SF, MU_ST, ANGMIN, ANGMAX, MU_ANGMIN, MU_ANGMAX] = idx_brch; [GEN_BUS, PG, QG, QMAX, QMIN, VG, MBASE, GEN_STATUS, PMAX, PMIN, MU_PMAX, MU_PMIN, MU_QMAX, MU_QMIN, PC1, PC2, QC1MIN, QC1MAX, QC2MIN, QC2MAX, RAMP_AGC, RAMP_10, RAMP_30, RAMP_Q, APF] = idx_gen; casename = 'case9'; mpopt = mpoption; %% use default options %% 打印选项 verbose = mpopt(31); %% 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aac7ecf68c0877e78e2a0fbf54306df2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f7a21e581fd0cd71e14676d4a8f859/" rel="bookmark">
			西瓜书读书笔记整理（八） —— 第八章 集成学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第八章 集成学习 8.1 个体与集体8.1.1 个体与机器的概念8.1.2 集成同种类型的个体学习器8.1.3 集成不同类型的个体学习器8.1.4 集成学习的分类（根据生成过程分类） 8.2 Boosting8.2.1 算法概述8.2.2 算法总体过程8.2.3 AdaBoost 算法 8.3 Bagging 与随机森8.3.1 Bagging8.3.2 随机森林（Random Forest）8.3.3 Bagging 类算法与 Boosting 类算法的差别 8.4 结合策略8.4.1 学习器结合的好处8.4.2 常见的几种结合策略 8.5 多样性8.6 集成学习常见的面试题8.6 总结 8.1 个体与集体 8.1.1 个体与机器的概念 在集成学习（Ensemble Learning）中，
个体（individuals）指的是构成整个集成模型的独立基学习器或模型。这些个体学习器可以是同质的（相同类型的模型）或异质的（不同类型的模型）。每个个体学习器都被训练用于解决给定的任务。
集体（ensemble）是由这些个体学习器组合而成的整体模型。通过将多个个体学习器的预测结果进行组合，集成模型通常能够在性能上超越单个学习器。集成学习的目标是通过利用个体学习器之间的差异性，降低泛化误差，提高模型的稳定性和性能。
8.1.2 集成同种类型的个体学习器 当集成学习中的个体学习器都属于相同类型，即具有相似的结构和学习算法时，这种集成称为 “同质”（homogeneous）集成。同质集成中的个体学习器通常被称为 “基学习器”（base learner），相应的学习算法成为 “基学习算法”（base learning algorithm） 。这些基学习器在训练过程中独立运作，最终通过某种集成策略来汇总它们的预测结果，从而形成整个集成模型。
同质集成的一个典型例子是随机森林（Random Forest）。在随机森林中，每个基学习器都是决策树，它们在训练时使用随机抽样的数据子集，最后通过投票来产生最终的预测。
8.1.3 集成不同类型的个体学习器 当集成学习中的个体学习器不属于相同类型，即具有不同的结构和学习算法时，这种集成称为 “异质”（heterogeneous）集成 。这种集成方法旨在充分利用不同类型学习器的优势，通过组合它们的预测结果来提高整个集成模型的性能。个体学习器一般不称为基学习器，常称为 “组件学习器”（component learner）或直接称为个体学习器。
在异质集成中，个体学习器可以是不同种类的机器学习算法或模型，例如决策树、支持向量机、神经网络、K最近邻等。每个个体学习器通过在训练数据上学习问题的不同方面或特征，为集成提供了多样性。
8.1.4 集成学习的分类（根据生成过程分类） 根据个体学习器的生成过程：
Bagging（Bootstrap Aggregating）： 通过对训练集进行有放回的随机抽样，生成不同的子集，然后在每个子集上独立训练个体学习器，最后通过投票或平均得到最终预测结果。典型的例子包括随机森林。Boosting： 通过迭代训练个体学习器，每次调整数据样本的权重，关注之前模型错误的样本，使得后续模型更加关注难以分类的样本。典型的例子包括 AdaBoost、Gradient Boosting 等。 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59f7a21e581fd0cd71e14676d4a8f859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91d108e1daf9f69752868e9a7784d0a9/" rel="bookmark">
			74HC595驱动数码管程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数码管的驱动分静态扫描和动态扫描两种，使用最多的是动态扫描，优点是使用较少的MCU的IO口就能驱动较多位数的数码管。数码管动态扫描驱动电路很多，其中最常见的是74HC164驱动数码管，这种电路一般用三极管作位选信号，用74HC164作段选信号，占用的MCU的IO口线随位数增加而增加,一般驱动四位以下数码管。如果要驱动四位以上数码管，用74HC595驱动最经典，只需4根IO口线就能驱动8位数码管，而且不存在消影问题，显示功能也很强大，是很实用的数码管驱动电路之一。
电路设计
在WSF-51DB开发板上，用两片74HC595驱动8位共阴极数码管（由两个4位共阴极数码管组成），一片作位选信号，另一片作段选信号。需要注意的是段选芯片与数码管的连接要使用100-200欧姆电阻作限流，不能太大也不能太小，更不能直接连接。
程序设计：
/************************************************************************** *程序名称：74HC595驱动数码管 *程序功能：数码管显示字符 *开发工具：WSF-51DB开发板 * MCU型号：AT89S52-24PU *时钟频率：12MHZ *程序作者：吴师傅 **************************************************************************/ ＃i nclude unsigned char code segmcode[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f, 0x77,0x7C,0x39,0x5E,0x79,0x71};//共阴极数码管段码0-f unsigned char code bitcode[]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f}; //8位共阴极数码管位码 sbit ser=P2^0; //74HC595串行数据输入 sbit oe=P2^1; //74HC595使能，为0时输出数据，为1时呈高阻态 sbit rclk=P2^2; //74HC595数据锁存 sbit srclk=P2^3;// 74HC595串行时钟 //延时毫秒函数： void Delayms(unsigned int t) { unsigned int x,y; for(x=t;x&gt;0;x--) for(y=120;y&gt;0;y--);//延时大约1毫秒 } //任意位数码管显示一个字符函数： void DTDisplayChar(unsigned char segmd,unsigned char bitd )//数码管段码和数码管位码 { unsigned char i; unsigned int dat; dat=bitd; dat=dat位码段码合并为一个int型数据 for(i=0;i位数据从高位依次移入74HC595 { ser=(dat&amp;0x8000)?1:0; //判断最高位，为真取1，为假取0 srclk=1; //上升沿送数据 srclk=0; dat左移取下一位 } rclk=1; //74HC595锁存数据 rclk=0; } //主函数： int main(void) { unsigned char j,k; oe=0; rclk=0;srclk=0; DTDisplayChar(0xff,0x00);//数码管全亮 Delayms(2000);//延时2秒，检查数码管是否有缺画 while(1) { for(j=0;j显示0-f 16个字符 { DTDisplayChar(segmcode[j],bitcode[j%8]);//从数组取出段码和位码 //要显示小数点只需在断码上或上0x80即可 for(k=0;k每个字符/闪烁5次 { oe=0;//打开显示 Delayms(200);//延时200毫秒 oe=1;//关闭显示 Delayms(200); } } /* for(j=0;j字符同时显示 { DTDisplayChar(segmcode[j],bitcode[j]);//从数组取出段码和位码 Delayms(1); } */ } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e389b852e7223347b18f583c5f809e64/" rel="bookmark">
			NLP基础——中文分词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 分词是自然语言处理（NLP）中的一个基本任务，它涉及将连续的文本序列切分成多个有意义的单元，这些单元通常被称为“词”或“tokens”。在英语等使用空格作为自然分隔符的语言中，分词相对简单，因为大部分情况下只需要根据空格和标点符号来切分文本。
然而，在汉语等语言中，并没有明显的单词界限标记（如空格），因此汉语分词比较复杂。汉字序列必须被正确地切割成有意义的词组合。例如，“我爱北京天安门”，应该被正确地划分为“我/爱/北京/天安门”。
方法 中文分词技术主要可以归类为以下几种方法：
基于字符串匹配的方法：这种方法依赖一个预先定义好的字典来匹配和确定句子中最长能够匹配上的字符串。这包括正向最大匹配法、逆向最大匹配法以及双向最大匹配法。
基于理解的方法：通过模拟人类理解句子含义进行分词，考虑上下文、句法结构和其他信息。
基于统计学习模型：利用机器学习算法从大量已经人工标注好了分词结果的数据集里学习如何进行有效地分词。常见算法包括隐马尔可夫模型(HMM)、条件随机场(CRF)以及近年来流行起来基于深度学习框架构建神经网络模型(RNNs、CNNs、LSTMs、Transformer、BERT等)。
混合方法：结合以上几种不同策略以提高精确度和鲁棒性。
基于规则: 通过制定一系列规则手动或半自动地进行文字断开, 这通常需要专业知识并且效率不高, 但可以在特定情境下发挥作用。
Python栗子 基于字符串匹配，最大前向匹配，代码如下
def max_match_segmentation(text, dictionary): max_word_length = max(len(word) for word in dictionary) start = 0 segmentation = [] while start &lt; len(text): for length in range(max_word_length, 0, -1): if length &gt; len(text) - start: continue word = text[start:start + length] if word in dictionary: segmentation.append(word) start += length break else: # 如果没有找到，则按单字切分 segmentation.append(text[start]) start += 1 return segmentation # 示例字典和用法： dictionary = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e389b852e7223347b18f583c5f809e64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d2db33b69bc80a107e8d93f0739c49/" rel="bookmark">
			一起学docker（六）| Dockerfile自定义镜像 &#43; 微服务模块实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DockerFile 是什么 Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。
构建步骤 编写Dockerfile文件docker build命令构建镜像docker run运行镜像 Dockerfile构建过程 基础知识 每个保留字指令都必须为大写字母且后面要跟随至少一个参数指令从上到下，顺序执行#号表示注释每条指令都会创建一个新的镜像层，并对镜像进行提交 Docker执行Dockerfile的大致流程 docker从基础镜像运行一个容器执行一条指令并对容器做出修改执行类似docker commit的操作提交一个新的镜像层docker再基于刚提交的镜像运行一个新容器执行Dockerfile中下一条指令直到所有指令都执行完成 总结 从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，
Dockerfile是软件的原材料Docker镜像是软件的交付品Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例 Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。
Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;
Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时会真正开始提供服务;
Docker容器，容器是直接提供服务的。
常用保留字指令 关键字作用备注FROM指定基础镜像指定一个已经存在的镜像作为父镜像，第一条指令必须是FROMWAINTAINER指定作者信息一般是姓名+邮箱（name&lt;mail&gt;)LABEL标明dockerfile的标签可以使用Label代替Maintainer，最终都是在docker image基本信息中可以查看RUN构建镜像时运行的命令容器构建时需要运行的命令；有两种格式：shell格式、exec格式；RUN是在docker build时运行shell格式exec格式EXPOSE暴露端口定义容器运行的时候监听的端口，启动容器的使用-p来绑定暴露端口，格式: EXPOSE 8080 或者 EXPOSE 8080/udpWORKDIR指定工作目录指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点USER指定执行用户指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户ENV设置环境变量指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=valueADD添加文件将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包COPY复制文件类似ADD，拷贝文件和目录到镜像中。
将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置VOLUME定义外部可以挂载的数据卷用于数据保存和持久化；
指定build的image哪些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”]CMD指定容器启动后的要干的事情Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换ENTRYPOINT也是用来指定一个容器启动时要运行的命令类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序 RUN和CMD的区别
CMD是在docker run时运行RUN是在docker build时运行 ENTRYPOINT
命令格式：ENTRYPOINT ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75d2db33b69bc80a107e8d93f0739c49/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/37/">«</a>
	<span class="pagination__item pagination__item--current">38/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/39/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>