<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/713ddf13a11e2b7a4f0f379b5df9151d/" rel="bookmark">
			01. JDBC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDBC介绍 JDBC快速入门 如果报错则在url上加入?useSSL=false即可。
/** * JDBC的快速入门 */ public class JDBCDemo { public static void main(String[] args) throws Exception { // 1. 注册驱动 Class.forName("com.mysql.jdbc.Driver"); // 2. 获取连接 String url = "jdbc:mysql://localhost:3306/test?useSSL=false"; String username = "root"; String password = "123456"; Connection conn = DriverManager.getConnection(url, username, password); // 3. 定义sql String sql = "update account set money = 2000 where id = 1"; // 4. 获取执行sql的对象 Statement Statement stmt = conn.createStatement(); // 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/713ddf13a11e2b7a4f0f379b5df9151d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d06824153868aeb9c81f8ea2fd59da2/" rel="bookmark">
			Nginx基础知识(个人总结)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明: 1. 本文为我的个人复习总结, 并非那种从零基础开始普及知识 内容详细全面, 言辞官方的文章
2. 由于是个人总结, 所以用最精简的话语来写文章
3. 若有错误不当之处, 请指出
Nginx C语言编写, 战斗民族俄罗斯人所创, 是高性能的 HTTP 和反向代理的Web服务器，处理高并发能力是十分强大的，,有报告表明能支持高达 50,000 个并发连接数
启动与关闭:
cd /usr/local/nginx/sbin
​ ./nginx -v
​ ./nginx
​ ./nginx -s stop
​ ./nginx -s reload
配置文件:
cd /usr/local/nginx/conf/nginx.conf
全局块：配置服务器整体运行的配置指令
比如 worker_processes 2 worker个数,建议分配和CPU核数一样的数量events 块：影响 Nginx 服务器与用户的网络连接
比如 worker_connections 1024 支持的最大连接数为 1024http 块:
还包含两部分：http 全局块与server 块 三大作用: 反向代理, 负载均衡, 动静分离
1. 反向代理 反向代理配置
2. 负载均衡 负载均衡配置
负载均衡策略
第一种 轮询（默认）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d06824153868aeb9c81f8ea2fd59da2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac9dec120045c51e54c6973697f10e32/" rel="bookmark">
			字符串常用的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、字符串遍历二、字符串查找的方法（1）indexOf()和lastIndexOf()（2）search()查找 三、元素替换方法----replace()方法四、字符串去空-----trim()方法五、字符串拼接方法（1）使用+号来进行字符串拼接（2）concat()方法 六、字符与ASCII值的相互转化（1）根据索引返回字符---charAt()（2）根据索引返回字符的ASCII值---charCodeAt()（3）根据索引获取对应的字符，转ASCII值---codePointAt()（4）将ASCII值转化为字符------fromCharCode()方法 七、字符串截取方法（1）substr()方法--------从起始索引号提取字符串中指定数目的字符（2）substring()方法----提取字符串中两个指定的索引号之间的字符（3）slice()方法----------提取字符串的片断，并在新的字符串中返回被提取的部分 八、字符串转化为数组----split()方法九、字符串正则使用方法------match()方法十、大小写转换（1）toLocaleLowerCase() --转化为本地格式的小写（2）toLocaleUpperCase() --转化为本地格式的大写（3）toLowerCase()-----------把字符串转换为小写（4）toUpperCase()-----------把字符串转换为大写 十一、值类型转引用类型------toString()方法十二、数字精确小数点的方法------toFixed()方法十三、用本地特定的顺序来比较两个字符串----localeCompare()方法十四、返回某个字符串对象的原始值----valueOf()方法十五、其他方法（1）bold()方法------返回加了 标签的字符串（2）big()方法--------用于把字符串显示为大号字体。（3）blink()方法------用于显示闪动的字符串。 一、字符串遍历 var a="abcdefg"; console.log(a.length);//7 for(var i=0;i&lt; a.length;i++){ console.log(i);//0 1 2 3 4 5 6 } for(var key in a){ console.log(key);//0 1 2 3 4 5 6 } for(var i=0;i&lt; a.length;i++){ //根据字符串类对象所使用的方法来获取每一个 console.log(a[i]);//a b c d e f g } charAt—根据索引获取字符串里面的每个字符 for(var i=0;i&lt; a.length;i++){ console.log(a.charAt(i));//a b c d e f g } 二、字符串查找的方法 （1）indexOf()和lastIndexOf() indexOf()：返回字符串中检索指定字符第一次出现的位置，没找到就返回-1从左到右参数1：查找的字符(必写)参数2：从哪个索引为开始(可选)返回值：找到返回当前索引，没找到返回-1lastIndexOf()：返回字符串中检索指定字符最后一次出现的位置，没找到就返回-1。从右到左lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，如果指定第二个参数 start，则在一个字符串中的指定位置从后向前搜索。注意： 该方法将从后向前检索字符串，但返回是从起始位置 (0) 开始计算子字符串最后出现的位置。 看它是否含有字符串。开始检索的位置在字符串的 start 处或字符串的结尾（没有指定 start 时）。如果没有找到匹配字符串则返回 -1 。若是只有一个参数，找到之后返回索引位置，没找到返回-1。 &lt;script&gt; var str = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac9dec120045c51e54c6973697f10e32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dd167fa8856c89c25388fb23892a656/" rel="bookmark">
			vue项目打包后，由于html被缓存导致出现白屏的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：vue线上的项目修改打包，重新部署后，线上出现了白屏，无法显示 原因：这是因为浏览器缓存了之前的html，用户访问的还是之前的html，但是由于我们重新打包更新了服务器的资源，那么之前的html上引用的资源已经不存在了，所以页面就无法显示出来了。 解决思路： 1. 手动刷新。懂的都都懂，用户自己看到屏幕白茫茫一片，肯定以为网络不好，多刷新几次就出来了。 2. 在html加上 no-cache 等等 meta标签，然后服务器ngix也加伤 no-cache 等不缓存的代码，网上搜一搜：vue打包缓存白屏，会有好多，这里就不多说了，主要是我加了这些东西后跟没加的效果一样，并不能解决，还有可能是项目是放在别人的cdn上，改不了服务器，可能也不会起作用。 3. 代码刷新。通过测试我们可以看到，当出现白屏时，刷新可以使页面恢复正常，那是刷新时绕过了缓存，有兴趣的朋友可以去了解这方面的知识。所以，我们只需要在资源加载出错的时候让页面重新刷新，那么问题就可以解决了。 代码刷新处理方法： 1. 监听资源加载。在页面加载完成时，使用window自带方法，监听资源加载失败error时，查找失败的资源是否是我们vue项目的资源，只要匹配一个即可通知我们调用刷新页面的方法。汗颜，我是想监听失败的js、css，奈何一直无法监听到，所以放弃了，有成功的朋友可以交流交流。 2. 在项目main.js内定义一个全局变量 window.my_isLoad = 1 然后我们在index.html内写上监听的方法，此处需注意，如果使用window.onload，那要确保你项目其他地方没有使用这个方法，不然会失效，因为window.onload只能执行一次，多个时只执行最后一个。或者引入jquery，使用jquery的ready方法，该方法可以多次调用，并且执行的时间节点比onload靠前，节省时间 先在index.html引入jquery $(document).ready( function(){ if(!window.my_isLoad) { // 这里可供自己测试查看，上线时可去掉，或自己做替他交互也可以，比如在页面上给什么提示信息、按钮 var paydiv = document.createElement('div') paydiv.innerHTML = '资源加载失败，我要刷新了' document.body.appendChild(paydiv) // setTimeout(()=&gt;{ document.body.removeChild(paydiv) window.location.reload(true) },10000) // 这个延迟时间可自己控制，页面加载出错多久后刷新页面 } } ) 上面使用的是通过在main.js内新增变量去判断，由于我司的页面有很多嵌入app的混合项目，在某个ios内出现了刷新页面时，缓存了之前window的变量，导致判断不准确，所以又想了一个不使用window变量的方法。 思路就是在App.vue 内创建一个元素，然后同样在index.html判断页面是否存在这个元素 在mounted生命周期里执行这个方法，添加一个元素，我们在index.html内通过id判断这个元素 this.$nextTick(()=&gt;{ (function(){ var appDom = document.getElementById('app') //这里的app是我们vue项目的app var checkDom = document.createElement('span') checkDom.setAttribute('id', 'my-check-load-dom') //这里的id是我们需要判断的 checkDom.style.display = 'none' appDom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dd167fa8856c89c25388fb23892a656/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a26002fe9ecf1e28dbb52d7f56e6653/" rel="bookmark">
			mysql的全量备份和增量备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 全量备份1 创建mysqldump脚本1.1 找一个目录,这里选择放到/data/mysqlbackup下,创建shell脚本1.2 添加内容1.3给脚本赋予执行权限 2.crontab2.1查看cron状态2.1创建crontab脚本2.2 编辑,每天凌晨3点执行一次3.3 执行定时任务命令2.4 查看定时任务是否成功或者检测/var/spool/cron下是否生成对应cron脚本2.5 删除定时任务2.6编辑定时任务 3.数据恢复3.1删除旧数据库3.2 解压备份的文件3.3 恢复数据 增量备份1.开启mysql的binlog日志(增量备份)1.1 查看binlog是否开启1.2 编辑my.cnf1.3 重启数据库1.4 查看日志索引和事件位置1.5如何实现增量备份 2.一次增量备份2.1凌晨3点进行一次全量备份2.2 早上9点向test.user中插入三条数据2.3 下午5点把数据库删了~&gt;~2.4 如何恢复数据库? 全量备份 1 创建mysqldump脚本 先了解一下mysqldump的基本参数
1. 全备数据库(innodb Engine) mysqldump -uroot -pmysql123 --single-transaction --master-data=2 --flush-logs --flush-privileges --routines --events --all-databases &gt; /backup/db_bak01.sql 2. 全备(Myisam Engine) mysqldump -uroot -pmysql123 --lock-all-tables --master-data=2 --flush-logs --flush-privileges --routines --events --all-databases &gt; /backup/db_bak01.sql 3. 只备份数据库db1和db2 mysqldump -uroot -pmysql123 --single-transaction --master-data=2 --flush-logs --routines --events --databases db1 db2 &gt; /backup/db_bak01.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a26002fe9ecf1e28dbb52d7f56e6653/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/681859c1938773379187fee21b9c4f63/" rel="bookmark">
			23. 电容触摸按键实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电容触摸按键原理 硬件连接讲解 实验程序讲解 #ifndef __TPAD_H #define __TPAD_H #include "sys.h" //空载的时候(没有手按下),计数器需要的时间 //这个值应该在每次开机的时候被初始化一次 extern vu16 tpad_default_val; void TPAD_Reset(void); u16 TPAD_Get_Val(void); u16 TPAD_Get_MaxVal(u8 n); u8 TPAD_Init(u8 systick); u8 TPAD_Scan(u8 mode); void TIM2_CH1_Cap_Init(u32 arr,u16 psc); #endif #include "tpad.h" #include "delay.h"	#include "usart.h" #define TPAD_ARR_MAX_VAL 0XFFFFFFFF	//最大的ARR值(TIM2是32位定时器)	vu16 tpad_default_val=0;	//空载的时候(没有手按下),计数器需要的时间 //初始化触摸按键 //获得空载的时候触摸按键的取值. //psc:分频系数,越小,灵敏度越高. //返回值:0,初始化成功;1,初始化失败 u8 TPAD_Init(u8 psc) { u16 buf[10]; u16 temp; u8 j,i; TIM2_CH1_Cap_Init(TPAD_ARR_MAX_VAL,psc-1);//设置分频系数 for(i=0;i&lt;10;i++)//连续读取10次 {	buf[i]=TPAD_Get_Val(); delay_ms(10);	}	for(i=0;i&lt;9;i++)//排序 { for(j=i+1;j&lt;10;j++) { if(buf[i]&gt;buf[j])//升序排列 { temp=buf[i]; buf[i]=buf[j]; buf[j]=temp; } } } temp=0; for(i=2;i&lt;8;i++)temp+=buf[i];//取中间的8个数据进行平均 tpad_default_val=temp/6; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/681859c1938773379187fee21b9c4f63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea961339648fdcc39f3dfbbaa9350846/" rel="bookmark">
			vue2 &#43; elementui &#43; axios &#43; less (vuecli5全家桶)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue2全家桶 最近公司有交流需求，于是网上扒拉扒拉，东拼西凑，整理了一个用脚手架搭建vue2项目的文档，很少写博客，也借此来加强自己的表达能力。
脚手架安装 npm install -g @vue/clivue -V 命令，若出现下图所示，则说明安装成功
创建项目 vue create 你的项目名称（如下图步骤）选择需要安装的工具（lint为代码校验，谨慎选择，初次搭建者不建议使用，不适用后续可跳过相关操作）
vue版本选择2.x路由模式，这里选择hash模式，也就是路由由#拼接css预处理器，此处选择lesseslint代码检查相关配置lint保存的时候检验在何处配置相关信息，选择单独的文件 环境变量设置 官方文档根目录下建立不同环境文件.env 开头并配置不同环境变量使用，如下图所示：
package.json中配置三个不同的环境命令 环境变量定义
使用的时候在项目任何地方使用process.env.定义的环境变量名称（注意：以VUE_APP_开头）
此处建立三个不同环境配置文件，.development、.production、.test
安装配置elementui yarn add element-ui -S 或者npm install element-ui -S (此后都是用yarn)引入 elementui 完整引入 main.js入口文件里面引入（注意：样式文件也要引入），如下图：
（只需要引入红框中的，不要多事…） 按需引入 yarn add babel-plugin-component @babel/preset-env -D
配置 babel.config.js
module.exports = { presets: [ '@vue/cli-plugin-babel/preset', ['@babel/preset-env', { modules: false }], ], plugins: [ [ 'component', { libraryName: 'element-ui', styleLibraryName: 'theme-chalk', }, ], ], }; main.js入口全局按需引入，此处我封装了一个方法registerElement()在入口处调用：如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea961339648fdcc39f3dfbbaa9350846/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/478c7a3aebea95d3172db548839a6444/" rel="bookmark">
			office-Excel-表格中相同项进行求平均
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 效果 怎么做 使用AVERAGEIF函数
=AVERAGEIF(区域,条件,[求平均值区域]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b7a04d7a427b4b911ffc2bccde8b820/" rel="bookmark">
			CEF 网页中内嵌qt窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是的，你没看错，是在浏览器中嵌入窗口，其实你想一想可能没必要，确实也是，在本地窗口中中嵌入浏览器是再正常不过的了，但是如果你有一个需求，需要使用到本地窗口，例如一些绘制操作，这边博客的大神使用的是PPAPI+skia实现简单的涂鸦功能
（PPAPI+Skia实现的涂鸦板_安晓辉生涯——聚焦程序员的职业规划与成长-CSDN博客），PPAPI具体我也不是很了解，应该是谷歌提供的支持的一个web插件的api吧。大家可参考我上边所说的那位大神的博客。本来这位大神的博客里也有提供嵌入本地窗口的讲解，但是这个也分cef的版本，我使用的qt版本是不支持的。
而且我的项目中使用的是基于qt的涂鸦等等的操作，所以只能想的是如何将qt窗口嵌入到cef中，最终还是没能解决，但是转念一想我可以在cef中的特定位置做一个浮层，覆盖在这个窗口上就行。
比如我的ui文件的结构是:
MainWindow CentralWidget WebViewWidget 即在WebViewWIdget中加载浏览器，所以我可以在centralWIdget中new一个GraffitiWidget用来做涂鸦。
GraffitiWidget *widget = new GraffitiWidget(ui-&gt;centralWidget); widget-&gt;setGeometry(0, 40, 400, 300); widget-&gt;shwow(); 这样就会显示在浏览器窗口上了，同时也可以跟随窗口移动而移动。
但是当我实现了出来的时候是这样的：其中白色是我的html,然后蓝色还有画笔什么的是我的qt窗口。
这是发生了什么，大家都知道对于一个widget来说，内部会维持一个栈，用来装基于本窗口作为父组件的子组件，最先创建的最先显示，后创建的后显示，即后创建的是显示在先创建的窗口上边，但是为什么会出现这个问题呢，查资料好像是，cef的界面渲染不是交给qt来处理的，好像是交给系统来绘制，所以我无论怎么尝试cef窗口都是在这个窗口的上边。
找了好久，看到了一个qtwinmigrate (https://qt.gitorious.org/qt-solutions/qt-solutions/source/qtwinmigrate 或者 https://github.com/sorcererq/qtwinmigrate)，这个的本意是在windows本地窗口上绑定qt窗口并显示，想来这个是独立处理的东西，那我既然可以在windows的窗口前边显示，自然可以在cef窗口前边显示。摘自里边我修改后的qwinwidget代码：
// qwinwidget.h #ifndef QWINWIDGET_H #define QWINWIDGET_H #include &lt;QWidget&gt; class CWnd; #if defined(Q_OS_WIN) # if !defined(QT_QTWINMIGRATE_EXPORT) &amp;&amp; !defined(QT_QTWINMIGRATE_IMPORT) # define QT_QTWINMIGRATE_EXPORT # elif defined(QT_QTWINMIGRATE_IMPORT) # if defined(QT_QTWINMIGRATE_EXPORT) # undef QT_QTWINMIGRATE_EXPORT # endif # define QT_QTWINMIGRATE_EXPORT __declspec(dllimport) # elif defined(QT_QTWINMIGRATE_EXPORT) # undef QT_QTWINMIGRATE_EXPORT # define QT_QTWINMIGRATE_EXPORT __declspec(dllexport) # endif #else # define QT_QTWINMIGRATE_EXPORT #endif class QT_QTWINMIGRATE_EXPORT QWinWidget : public QWidget { Q_OBJECT public: QWinWidget( HWND hParentWnd, QObject *parent = 0, Qt::WindowFlags f = 0 ); #ifdef QTWINMIGRATE_WITHMFC QWinWidget( CWnd *parnetWnd, QObject *parent = 0, Qt::WindowFlags f = 0 ); #endif ~QWinWidget(); void show(); void center(); void showCentered(); HWND parentWindow() const; protected: void childEvent( QChildEvent *e ); bool eventFilter( QObject *o, QEvent *e ); bool focusNextPrevChild(bool next); void focusInEvent(QFocusEvent *e); #if QT_VERSION &gt;= 0x050000 bool nativeEvent(const QByteArray &amp;eventType, void *message, long *result); #else bool winEvent(MSG *msg, long *result); #endif private: void init(); void saveFocus(); void resetFocus(); HWND hParent; HWND prevFocus; bool reenable_parent; }; #endif // QWINWIDGET_H //qwinwidget.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b7a04d7a427b4b911ffc2bccde8b820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31bc42e2d54338cb61ca77ddfc0e5387/" rel="bookmark">
			【已解决】服务没有注册到nacos（未提示nacos registry, DEFAULT_GROUP orderservice xxx.xxx.xxx.x:xxxx register finishe）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.问题
服务没有注册到nacos
2. 原因
看一下是否导入了spring-boot-starter-web依赖，由于spring cloud是基于springboot的，所以此依赖必须要有
3. 解决方案
在pom.xml加入maven依赖
&lt;!-- SpringBoot Web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d2d7fcb0de5e9e5b2adf12937d0796b/" rel="bookmark">
			COCO数据集介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		COCO数据集详细介绍 前言一、什么是COCO数据集？COCO数据集可以应用到的Task：一个简单的数据集实例展示：附录80个类别 二、COCO数据集的格式介绍基础的数据格式介绍不同Task下的annotationObject Detection annotationother task： Result format 输出格式 三、COCO数据集的下载 前言 以下内容均来自COCO官方
以及Microsoft COCO: Common Objects in Context
一、什么是COCO数据集？ COCO数据集是一个可用于图像检测（image detection），语义分割（semantic segmentation）和图像标题生成（image captioning）的大规模数据集。它有超过330K张图像（其中220K张是有标注的图像），包含150万个目标，80个目标类别（object categories：行人、汽车、大象等），91种材料类别（stuff categoris：草、墙、天空等），每张图像包含五句图像的语句描述，且有250,000个带关键点标注的行人。
COCO数据集可以应用到的Task： 目标检测（object detection），使用 bounding box 或者 object segmentation (也称为instance segmentation)将不同的目标进行标定。
COCO数据集用于image segmentation的教程：Master the COCO Dataset for Semantic Image SegmentationDensepose（密集姿势估计），DensePose任务涉及同时检测人、分割他们的身体并将属于人体的所有图像像素映射到身体的3D表面。用于不可控条件下的密集人体姿态估计。Key-points detection（关键点检测），在任意姿态下对人物的关键点进行定位，该任务包含检测行人及定位到行人的关键点。
Stuff Segmentation，语义分割中针对stuff class类的分割。（草，墙壁，天空等）
Panoptic Segmentation（全景分割）。其目的是生成丰富且完整的连贯场景分割，这是实现自主驾驶或增强现实等真实世界视觉系统的重要一步。
image captioning（图像标题生成），根据图像生成一段文字。
一个简单的数据集实例展示： 一张包含汽车，行人，画板的图片：
附录 80个类别 person(人)
交通工具：bicycle(自行车) car(汽车) motorbike(摩托车) aeroplane(飞机) bus(公共汽车) train(火车) truck(卡车) boat(船)
公共设施：traffic light(信号灯) fire hydrant(消防栓) stop sign(停车标志) parking meter(停车计费器) bench(长凳)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d2d7fcb0de5e9e5b2adf12937d0796b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d0e2d7c97b843ee4dda6ed99025d8ec/" rel="bookmark">
			部署WDS服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. WDS服务是什么服务？它的作用是什么？WDS服务器需提前准备什么？客户机需要提前准备什么？ WDS的全称为Windows部署服务；主要应用于大中型网络中的计算机操作系统的批量化部署
作用：
1.降低部署的复杂程度及手动安装过程效率低下而付出的成本
2.允许基于网络安装Windows操作系统
3.支持Windows各个版本的混合环境
4.可以将Windows映像部署到未安装操作系统的计算机上
5.是基于标准的Windows Server安装技术(包括WindowsPE、.Wim文件和基于映像的安装)
服务器：服务器需要使用独立的服务器进行部署
客户机：客户机要尽量选择同厂家型号的产品
2. WDS的系统条件是怎样？ 部署WDS服务的用户必须是服务器上本地Administrator组的成员;若要初始化服务器,则还必须是Domain Admin组的成员;则部署WDS服务的用户必须是该服务器上的本地Administrator组的成员;另外,WDS服务器需要NTFS文件系统卷来存储映像
3.导入的镜像有哪些？它有什么用？ boot.wim:引导镜像，里面包含系统的启动文件install.wim:系统的安装镜像 需求1 部署WDS服务器，客户机通过WDS服务器安装操作系统
注：此实验需准备的环境，需为域环境，且具有DHCP及DNS服务器
安装WDS部署
安装完成后在工具中打开Windows部署服务
把在win10镜像中找到boot.wim，install.wim 文件
把这两个文件放入非系统磁盘
打开客户机，点击F2并选择用网络启动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aebb9c5f6283b50ef98e69403ca7550/" rel="bookmark">
			mmdetection中faster_rcnn的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mmdetection中faster_rcnn的实现 前置内容：
mmdetecion 中类注册的实现（@x.register_module()）
内容包括：
faster_rcnn
backbone
neck
rpn_head
faster_rcnn @DETECTORS.register_module() class FasterRCNN(TwoStageDetector): 在代码中，fasterRCNN继承了TwoStageDetector，TwoStageDetector继承了BaseDetector，在BaseDetector中实现了forward，其中判断训练和test调用了forward_train和forward_test，我们关注的也就是forward_train()
faster_rcnn依次调用了backbone，neck，rpn，roi，之后计算loss
def forward_train(self, img, img_metas, gt_bboxes, gt_labels, gt_bboxes_ignore=None, gt_masks=None, proposals=None, **kwargs): x = self.extract_feat(img) # 特征提取+fpn losses = dict() # RPN 过程 if self.with_rpn: proposal_cfg = self.train_cfg.get('rpn_proposal', self.test_cfg.rpn) rpn_losses, proposal_list = self.rpn_head.forward_train( x, img_metas, gt_bboxes, gt_labels=None, gt_bboxes_ignore=gt_bboxes_ignore, proposal_cfg=proposal_cfg, **kwargs) losses.update(rpn_losses) else: proposal_list = proposals #roi过程 roi_losses = self.roi_head.forward_train(x, img_metas, proposal_list, gt_bboxes, gt_labels, gt_bboxes_ignore, gt_masks, **kwargs) losses.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aebb9c5f6283b50ef98e69403ca7550/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/018968b61ac33ab64f17430ec705e579/" rel="bookmark">
			常用技术的原理简单介绍 kafka、docker、seata等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收集一些对技术原理讲解清楚的文章，不涉及代码实现层面
kafka：
搞懂分布式技术21：浅谈分布式消息技术 Kafka
seata
seata官方文档
docker
后端技术杂谈9：先搞懂Docker核心概念吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eca9a6c7d600b2c67fd1bc6365194cc/" rel="bookmark">
			ShardingSphere之Sharding-JDBC整合XA模式、Saga模式、Seata原理介绍以及代码演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、XA整合原理 Java通过定义TA接口实现了XA的模型，JTA接口里的ResourceManager需要数据库厂商提供XA的驱动实现，而transactionManager则需要事务管理器的厂商实现，传统的事务管理器需要同应用服务器绑定，因此使用的成本很高。而嵌入式的事务管器可以以jar包的形式提供服务，同ShardingSphere集成后，可保证分片后跨库事务强一致性。
ShardingSphere支持以下功能：
支持数据分片后的跨库XA事务两阶段提交保证操作的原子性和数据的强一致性服务宕机重启后，提交/回滚中的事务可自动恢复SPI机制整合主流的XA事务管理器，默认Atomikos同时支持XA和非×A的连接池提供spring-boot和namespace的接入端
Shardingsphere整合XA事务时，分离了XA事务管理和连接池管理，这样接入A时，可以做到对业务的零侵入。 Begin（开启XA全局事务）XAShardingTransactionManager会调用具体的XA事务管理器开启XA的全局事务。执行物理SQL ShardingSphere进行解析/优化/路由后会生成SQL操作，执行引擎为每个物理SQL创建连接的同时，物理连接所对应的XAResource也会被注册到当前XA事务中。事务管理器会在此阶段发送XAResource.start命令给数据库，数据库在收到XAResource.end命令之前的所有SQL操作，会被标记为XA事务。
例如：
这里sql1和sql2被标记为XA事务
·Commit/rollback（提交XA事务）XASharding TransactionManager收到接入端的提交命令后，会委托实际的XA事务管理进行提交动作，这时事务管理器会收集当前线程里所有注册的XAResource，首先发送XAResource.end指令，用以标记此XA事务的边界。接着会依次发送prepare指令，收集所有参与XAResource投票，如果所有XAResource的反馈结果都是OK，则会再次调用commit指令进行最终提交，如果有一个XAResource的反馈结果为No，则会调用rolback指令进行回滚。在事务管理器发出提交指令后，任何XAResource产生的异常都会通过recovery日志进行重试，来保证提交阶段的操作原子性，和数据强一致性。
例如：
二、Saga整合原理 ShardingSphere的柔性事务已通过第三方servicecomb-saga组件实现的，通过SPl机制注入使用。
ShardingSphere是基于反向SQL技术实现的反向补偿操作，它将对数据库进行更新操作的SQL自动生成反向SQL，并交由Saga-actuator引擎执行。使用方则无需再关注如何实现补偿方法，将柔性事务管理器的应用范畴成功的定位回了事务的本源——数据库层面。Shardingsphere支持以下功能：
完全支持跨库事务支持失败SQL重试及最大努力送达支持反向SQL、自动生成更新快照以及自动补偿默认使用关系型数据库进行快照及事务日志的持久化，支持使用SPl的方式加载其他类型的持久化 Saga柔性事务的实现类为SagaSharding TransactionMananger，Shardingsphere通过Hook的方式拦截逻辑SQL的解析和路由结果，这样，在分片物理SQL执行前，可以生成逆向SQL，在事务提交阶段再把SQL调用链交给Saga引擎处理。
lnit（Saga引擎初始化）包含Saga柔性事务的应用启动时，saga-actuator引擎会根据saga.properties的配置进行初始化的流程。Begin（开启Saga全局事务）每次开启Saga全局事务时，将会生成本次全局事务的上下文（SagaTransactionContext），事务上下文记录了所有子事务的正向SQL和逆向SQL，作为生成事务调用链的元数据使用。执行物理SQL在物理SQL执行前，Shardingsphere根据SQL的类型生成逆向SQL，这里是通过Hook的方式拦截Parser的解析结果进行实现。Commit/rollback（提交Saga事务）提交阶段会生成Saga执行引擎所需的调用链路图，commit操作产生ForwardRecovery（正向SQL补偿）任务，rollback操作产生BackwardRecovery任务（逆向SQL补偿）。 三、整合Seata原理 分布式事务的实现目前主要分为两阶段的XA强事务和BASE柔性事务。
Seata AT事务作为BASE柔性事务的一种实现，可以无缝接入到Shardingsphere生态中。在整合SeataAT事务时，需要把TM，RM，TC的模型融入到ShardingSphere 分布式事务的SPI的生态中。在数据库资源上，Seata通过对接DataSource接口，让DBC操作可以同TC进行RPC通信。同样，ShardingSphere也是面向DataSource接口对用户配置的物理DataSource进行了聚合，因此把物理DataSource二次包装为Seata 的DataSource后，就可以把Seata AT事务融入到ShardingSphere的分片中。
Init（Seata引擎初始化）包含Seata柔性事务的应用启动时，用户配置的数据源会按seata.conf的配置，适配成Seata事务所需的DataSourceProxy，并且注册到RM中。Begin（开启Seata全局事务）TM控制全局事务的边界，TM通过向TC发送Begin指令，获取全局事务ID，所有分支事务通过此全局事务ID，参与到全局事务中；全局事务ID的上下文存放在当前线程变量中。执行分片物理SQL处于Seata全局事务中的分片SQL通过RM生成undo快照，并且发送participate指令到TC，加入到全局事务中。ShardingSphere的分片物理SQL是按多线程方式执行，因此整合Seata AT事务时，需要在主线程和子线程间进行全局事务ID的上下文传递，这同服务间的上下文传递思路完全相同。Commit/rollback（提交Seata事务）提交Seata事务时，TM会向TC发送全局事务的commit和rollback指令，TC根据全局事务ID协调所有分支事务进行commit和rollback。 四、代码演示 ShardingSphere整合了XA、Saga和Seata模式后，为分布式事务控制提供了极大的便利，我们可以在应用程序编程时，采用以下统一模式进行使用。
引入依赖 //XA模式 &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-transaction-xa-core&lt;/artifactId&gt; &lt;version&gt;${shardingsphere.version}&lt;/version&gt; &lt;/dependency&gt; //Saga模式 &lt;dependency&gt; &lt;groupId&gt;io.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-transaction-base-saga&lt;/artifactId&gt; &lt;version&gt;${shardingsphere-spi-impl.version}&lt;/version&gt; &lt;/dependency&gt; //Seata模式 &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-transaction-base-seata-at&lt;/artifactId&gt; &lt;version&gt;${sharding-sphere.version}&lt;/version&gt; &lt;/dependency&gt; Java编码方式设置事务类型 TransactionTypeHolder.set(TransactionType.XA); TransactionTypeHolder.set(TransactionType.BASE); 参数配置
ShardingSphere默认的XA事务管理器为Atomikos，通过在项目的classpath中添加ita.properties来定制化Atomikos配置项。具体的配置规则如下： #指定是否启动磁盘日志，默认为true。在生产环境下一定要保证为true，否则数据的完整性无法保证com.atomikos.icatch.enable_1ogging=true #JTA/XA资源是否应该自动注册 com.atomikos.icatch.automatic_resource_registration=true #]TA事务的默认超时时间，默认为10000ms com.atomikos.icatch.default_jta_timeout=10000 #事务的最大超时时间，默认为300000ms。这表示事务超时时间由 UserTransaction.setTransactionTimeout（）较大者决定。4.x版本之后，指定为0的话则表示不设置超时时间 com.atomikos.icatch.max_timeout=300000 #指定在两阶段提交时，是否使用不同的线程（意味着并行）。3.7版本之后默认为false，更早的版本默认为true。 如果为false，则提交将按照事务中访问资源的顺序进行。 com.atomikos.icatch.threaded_2pc=false #指定最多可以同时运行的事务数量，默认值为50，负数表示没有数量限制。在调用UserTransaction.begin（）方法时，可能会抛出一个”Max number of active transactions reached”异常信息，表示超出最大事务数限制 com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eca9a6c7d600b2c67fd1bc6365194cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9be083c9e1e52c296ccdb3caf8397792/" rel="bookmark">
			DataFrame的创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.利用列表，元组构建的字典创建 import pandas as pd dict1 = {"流浪地球":[25,45,65,89],"唐人街探案":(89,56,89,17),"谋杀2":[19,46,49,79]} df = pd.DataFrame(dict1,index = ["第%d天"%i for i in range(1,5)]) df 2.利用series创建 import pandas as pd import numpy as np df = pd.DataFrame({"a":pd.Series(np.arange(1,6)),"b":pd.Series(np.linspace(1,6,5))}) df 3.利用字典构建的字典创建 pd.DataFrame({"甲":{"第一天":2,"第二天":5,"第三天":7}, "乙":{"第一天":1,"第二天":8,"第三天":2}, "丙":{"第一天":9,"第二天":7,"第三天":7}}) 4.利用二维数组进行构建 import pandas as pd import numpy as np arr1 = np.arange(12).reshape(3,4) df = pd.DataFrame(arr1) df 5.利用字典构成的列表类构建 pd.DataFrame([{"apple":5,"banana":3,"veg":9}, {"apple":5,"banana":3,"veg":9}, {"apple":5,"banana":3,"veg":9}]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c87073414ac4919d71833a1aa8d4a411/" rel="bookmark">
			Bootstrap图标按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 BootStrap官方为我们准备了很多图标按钮，链接如下：
https://v3.bootcss.com/components/
我们使用时注意:用span包裹图标，再嵌入到图标中
&lt;button class="btn btn-info"&gt; &lt;span class="glyphicon glyphicon-fullscreen"&gt; &lt;/span&gt; 想跟在图标后的字 &lt;/button&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0813d27753f8402d6805c50c338a6bff/" rel="bookmark">
			Docker更换为国内镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 更换原因 在国内访问 Docker 官方的镜像，一直以来速度都慢如蜗牛，很多镜像动不动就1G或几百M，官方经常掉线。为了快速访问 Docker 官方镜像都会配置第三方加速器。
国内的镜像源有 Docker官方中国区 https://registry.docker-cn.com 网易 http://hub0mirror.c.163.com USTC http://docker.mirrors.ustc.edu.cn 阿里云 http://&lt;your-id&gt;.mirror.aliyuncs.com 现在 Docker 官方针对中国区推出了镜像加速服务。通过 Docker 官方镜像加速，国内用户能够以更快的下载速度和更强的稳定性访问最流行的 Docker 镜像。
如何使用官方镜像 Docker 中国官方镜像加速可通过 registry.docker-cn.com 访问。目前该镜像库只包含流行的公有镜像，而私有镜像仍需要从美国镜像库中拉取。
可以使用以下命令直接从该镜像加速地址进行拉取。
docker pull registry.docker-cn.com/myname/myrepo:mytag 示例如下：
docker pull registry.docker-cn.com/library/ubuntu:18.04 阿里云镜像源地址使用 注册后登陆阿里云账号进入控制台，选择容器镜像服务输入密码以便获取凭证进入镜像中心，选择镜像加速器根据操作文档中，不同操作系统执行不同操作 Ubuntu18.04 LTS 配置阿里云镜像 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF' { "registry-mirrors": ["https://tesijcui.mirror.aliyuncs.com"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 欢迎大家一起交流沟通，我的公众号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3dcad4ce8fd9f9297df03cd398040fb/" rel="bookmark">
			图像分割结果可视化TP、FP、TN、FN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import numpy as np import os import gdalTools def binary_accuracy(pred, label): w, h = pred.shape result = np.zeros((w, h, 3)) pred = (pred &gt;= 0.5) label = (label &gt;= 0.5) TP = pred * label FP = pred * (1 - label) FN = (1 - pred) * label TN = (1 - pred) * (1 - label) # TP result[:, :, 0] = np.where(TP == 1, 255, result[:, :, 0]) result[:, :, 1] = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3dcad4ce8fd9f9297df03cd398040fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6942c71f70f410abfb5f30a084ed555/" rel="bookmark">
			NETSDK1045 当前 .NET SDK 不支持将 .NET 6.0 设置为目标。请将 .NET 5.0 或更低
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vs2019解决 NETSDK1045 错误 一、平台描述二、问题描述三、问题原因四、解决办法 一、平台描述 系统：Windows 10
VS ： Visual Stdio 2019
二、问题描述 我在下载了 微软官网 的WPF示例代码运行时，出现的问题，
NETSDK1045 当前 .NET SDK 不支持将 .NET 6.0 设置为目标。请将 .NET 5.0 或更低
三、问题原因 当生成工具找不到生成项目所需的 .NET SDK 版本时，会发生此错误。 这通常是由于 .NET SDK 安装或配置问题导致的。 完整的错误消息类似于以下示例：
NETSDK1045：当前的 .NET SDK 不支持将“更新的版本”作为目标。 将“更旧的版本”或更低版本作为目标，或者使用支持“更新的版本”的 .NET SDK 版本。 四、解决办法 参考官网的解决办法：
参考链接：https://docs.microsoft.com/zh-cn/dotnet/core/tools/sdk-errors
因为删除了 global.json 文件还是报错
所以我使用的是安装 .net 6.0 SDK 来解决报错问题
1、去 .NET下载页面 （选择. net 6.0）
2、选择最新版 - Windows x86
【这里x86、或x64根据需要下载，我只是下载来跑代码，跟架构基本没关系，就选一个就行，到时候运行时也选x86即可】
【这里 能看到 .net 是vs2022才支持, vs 2019不支持】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6942c71f70f410abfb5f30a084ed555/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91fe64644c902e7f5a9077913c968060/" rel="bookmark">
			vue项目中chunk-vendors.js提示报错的查看方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常在vue项目中，会有chunk-vendors.js报出的各种错误提示，但可能有的报错很多人不懂的如何查看，接下来，给大家一个示例：
上图中的报错，很多人可能只会看【Vue warn】中的错误，而忽略【system】中的错误提示，导致在页面中找了无数个“indexOf”也解决不了错误，其实这条错误产生的步骤都已经在【system】中。让我们由下往上看，错误产生的步骤流程依次是settlement–&gt;otherfun–&gt;list_fun–&gt;audio_play,很明显是因为audio_play方法导致的报错，这样查看问题产生的步骤是不是简单很多呢，估计很多人都忽略了这个吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2316df73f408028dcb3558eb745001/" rel="bookmark">
			Vue出现报错Uncaught TypeError vue__WEBPACK_IMPORTED_MODULE_0__.default.user is not a function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue代码报错：
Uncaught TypeError: vue__WEBPACK_IMPORTED_MODUL_0__.default.user is not a function
解决方法：查看js文件下 是不是Vue.use写成了user
把user改回use就没有报错了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9e7524d7a33d73f6b76ab6a990bdb4c/" rel="bookmark">
			【Error】Failed to load plugin ‘react-internal‘ ...：Cannot find module ‘eslint-plugin-react-internal‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Failed to load plugin 'react-internal' declared in 'src\react\.eslintrc.js': Cannot find module 'eslint-plugin-react-internal' 原因分析解决方案 原因分析 以下问题，是由于项目未下载eslint-plugin-react-internal 依赖包，或者 eslint-plugin-react-internal 依赖包下载不完整导致的。
解决方案 重新下载 eslint-plugin-react-internal 依赖包，先尝试使用 npm 安装此依赖，如果使用此种方式安装失败，建议使用 yarn 进行依赖的安装
# 方案一，不一定成功 npm i eslint-plugin-react-internal # 方案二，建议选择此方案 yarn add eslint-plugin-react-internal 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e538669392fe825396b6304e1896a441/" rel="bookmark">
			MyCobot六轴机械臂的基本操作（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一讲我们做ssh和vnc的设置，有小伙伴问设置些有什么用，那么这里我先来解释一下这些功能有什么用处，首先我们可以通过ssh在我们的Windows桌面进行程序开发，然后上传到树莓派进行验证，我们也可以在windows平台通过vnc远程操作我们的机械臂，这样你就可以在自己的工作台上自由编程和上网查资料，然后MyCobot他不会占用你的显示器。当然了，你也可以直接拿这个树莓派当做开发机器使用，也是没有问题了。
接下来我介绍一些平时常用的工具软件给大家：
1、xshell
家庭学校免费版，下载地址：https://www.xshell.com/zh/free-for-home-school/
2、VNC Viewer
下载地址：https://www.realvnc.com/en/connect/download/viewer/
3、开发工具pycharm
下载地址：https://www.jetbrains.com/pycharm/download/#section=windows
在这里我们使用pycharm的社区版(Community)就可以了，python的开发工具很多，也可使用notepad++、jupyter、VSCode等，随便你方便就行。这里我们主要使用notepad++和pycharm来做为我们本次教学的编程软件进行讲解。
4、Myblockly
这个软件是机械臂树莓派里自带的一种开发工具，有兴趣的小伙伴可以自己试一下。
好啦我们开始进入到机械臂的基本操作
一：机械臂的校准 MyCobot机械在使用前要进行一次校准，这样我们做实验时才能得到正确的结果，那么MyCobot机械臂如何校准呢？
（1）在桌面双击rasp_mycobot_test_gui.py，弹出右侧界面。
（2）选择串口：注意树莓派的串口是ttyAMA0，波特率：1,000,000。这个一定要记住，因为后面我们要经常用到这个参数。然后点击”连接mycobot“：下面的”连接“。
（3）手动将机械臂的每节机械臂定位卡位对齐，如图：
总共六节机械臂都要对齐。然后我们点击：”校准舵机：开始校准“，要连点六次。这个时侯机械臂会自动进行舵机的校准工作。
如图所示，这样舵机就校准好了。我们关掉这个界面，介绍我们今天最最重要的一个概念，机械臂的坐标系系统。
二：机械臂的坐标系统 在整个机械臂的学过程中，最为重要的一点是你必段了解机械臂的坐标系统系统，也就是机械臂在空间中是怎么定位的。在这里我们面要明确的两个概念一个是坐标系统，一个是姿态。而空间中一点的姿态，可以由多种表示方式，其中最常用的是欧拉坐标。
（1）直角坐标系：在本课程中的坐标系统指的就是直角坐标系统，也称为迪卡尔坐标系统，也就是空间中的一点垂直于X、Y、Z轴的距离，通常记为（x,y,z)。
（2）欧拉坐标：用于表示空间中某个点的姿态，是在直角坐系中的某个点，沿x,y,z轴任意轴旋转一定角度后的一个计算值，该值称为该点在此位置的一个姿态。
机械臂在空间的位置即包括直角坐标和欧拉坐标，一般记为：[X,Y,Z,rx,ry,rz]，前面XYZ为直角坐标，后面的rx,ry,rz为欧拉坐标。
有关机械臂的坐标系统，有兴趣的小伙伴可以深入的学习，这里仅仅简单介绍一下，如果你想深入的学习，那么需要下功夫把数学，代数，几何要重新学习一下。这里不多陈述了。
3、机械臂的关节角度
这里所说的是机械臂和关节间的角度与1、2、所描述的空间坐标要区分开。还记得前面我们校准机械臂时的零位吗？
机械臂的角度，就是每一轴，相对于这个定位标志的角度。因为我们讲的是六轴机械臂，所以各关节的角度表示为：([J1,J2,J3,J4,J5,J6],50)，注意方括号里面是机械臂各关节的角度，圆括号里面的50，指的是机械臂到达指定角度的速度。
这一章我们就介绍到这里，下一章我们将以六个小程序，为大家展示机械臂的运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c8631cea0d5c667f89f7e76ec3c323f/" rel="bookmark">
			Error in v-on handler “ReferenceError XXX is not defined“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue 编译的时候可能会出现 Error in v-on handler: “ReferenceError: XXX is not defined” 这个问题，
这个可能是因为你没有引用相应的组件， vue 的 js 方法报错，
引用后就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/099a70d64a4a79628b44d31ba8d0df31/" rel="bookmark">
			kafka Windows测试启动踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网下载安装包到D盘下，然后进入bin下的windows目录，使用bat命令。
命令 bin---》windows---》 1、启动zookeeper-server： zookeeper-server-start.bat ../../config/zookeeper.properties 2、启动kafka-server： kafka-server-start.bat ../../config/server.properties 3、创建topic： kafka-topics.bat --creat --zookeeper localhost:2181 --topic topic_name --partitions 1 --replication-factor 1 4、查看topic列表： kafka-topics.bat --list --zookeeper localhost:2181 5、删除topic： kafka-topics.bat --delete --zookeeper localhost:2181 --topic topic_name 6、创建生产者： kafka-console-producer.bat --broker-list localhost:9092 --topic topic_name 7、创建消费者： kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic topic_name --from-beginning 问题： 1、‘wmic’ 不是内部或外部命令，也不是可运行的程序 或批处理文件。
解决方法：把 C:\Windows\System32 和 C:\Windows\System32\wbem 加入到环境变量path中。
2、WARN [Producer clientId=console-producer] Bootstrap broker localhost:9092 (id: -1
rack: null) disconnected (org.apache.kafka.clients.NetworkClient)
原因：连接不上kafka服务器9092端口
解决方法：①先检查kafka服务器状态，是否运行正常。②server.properties文件中这行写成下图这样：
3、ERROR Shutdown broker because all log dirs in D:\tmp\kafka-logs have
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/099a70d64a4a79628b44d31ba8d0df31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bbd08e5b4714bc5d7448944ba859305/" rel="bookmark">
			rabbitMQ高级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
消息可靠性
消息可靠性 -- 生产者确认
消息可靠性 -- 消息持久化
消息可靠性 -- 消费者确认
消息可靠性 -- 消费者失败重试机制
消息可靠性 -- 实现总结
死信交换机
死信交换机 -- 实现消息延迟推送
死信交换机 -- 延迟队列插件 -- DelayExchange
消息堆积 -- 惰性队列
MQ集群分类
MQ集群 -- 普通集群
MQ集群 -- 镜像集群
MQ集群 -- 仲裁集群
消息可靠性 在消息的推送,路由和接收处理中,都有可能遇到消息的丢失,常见的丢失原因可以分为三类:
发送时丢失： 生产者发送的消息未送达exchange 消息到达exchange后未到达queue
MQ宕机，queue中的消息丢失
consumer接收到消息后未消费就宕机
针对这三类情况,MQ提供了四种解决方案:
生产者确认机制
消息持久化
消费者确认机制
失败重试机制
消息可靠性 -- 生产者确认 RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。这种机制必须给每个消息指定一个唯一ID。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。
返回结果有两种方式：
publisher-confirm，发送者确认
消息成功投递到交换机，返回ack
消息未投递到交换机，返回nack
publisher-return，发送者回执
消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。
发送消息的时候需要给消息提供一个唯一ID,结果返回的时候可以绑定ack/nack, 用来区分不同的消息,避免ack碰撞
配置生产者确认模式:
修改publisher服务中的application.yml文件:
spring: rabbitmq: publisher-confirm-type: correlated publisher-returns: true template: mandatory: true publish-confirm-type：开启publisher-confirm，这里支持两种类型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bbd08e5b4714bc5d7448944ba859305/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3dc81721a5e0a0dfeb26d5bb8063dae/" rel="bookmark">
			使用Cloudflare DDoS 防止洪水攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 DNS 洪水？
DNS 洪水攻击是一种分布式拒绝服务（DDoS）攻击，攻击者用大量流量淹没某个域的 DNS 服务器，以尝试中断该域的 DNS 解析。如果用户无法找到电话簿，就无法查找到用于调用特定资源的地址。通过中断 DNS 解析，DNS 洪水攻击将破坏网站、API 或 Web 应用程序响应合法流量的能力。
DNS 洪水攻击的工作原理
DNS 洪水攻击是一种相对较新的基于 DNS 的攻击，这种攻击是在高带宽物联网（IoT）僵尸网络（如 Mirai）兴起后激增的。DNS 洪水攻击使用 IP 摄像头、DVR 盒和其他 IoT 设备的高带宽连接直接淹没主要提供商的 DNS 服务器。来自 IoT 设备的大量请求淹没 DNS 提供商的服务，阻止合法用户访问提供商的 DNS 服务器。
DNS 洪水攻击不同于 DNS 放大攻击。与 DNS 洪水攻击不同，DNS 放大攻击反射并放大不安全 DNS 服务器的流量，以便隐藏攻击的源头并提高攻击的有效性。DNS 放大攻击使用连接带宽较小的设备向不安全的 DNS 服务器发送无数请求。
如何防护 DNS 洪水攻击？
DNS 洪水对传统上基于放大的攻击方法做出了改变。借助轻易获得的高带宽僵尸网络，攻击者现能针对大型组织发动攻击。除非被破坏的 IoT 设备得以更新或替换，否则抵御这些攻击的唯一方法是使用一个超大型、高度分布式的 DNS 系统，以便实时监测、吸收和阻止攻击流量。进一步了解 Cloudflare 的 DDoS 防护如何防御 DNS 洪水攻击。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfeffb6d6e1478ca7abdba6428bda7e3/" rel="bookmark">
			Go学习:使用内嵌来扩展已有类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何扩充已有类型?
定义别名:最简单,但是由于以后的维护可能会改成使用组合,别名到组合不能无缝转换;需要改很多代码使用组合:最常用使用内嵌:需要省下很多代码;但是可读性较差 定义别名&amp;使用组合 https://blog.csdn.net/qq_43135259/article/details/123194344?spm=1001.2014.3001.5502
使用内嵌 node
package tree import "fmt" type Node struct { Value int Left, Right *Node } func CreateNode(value int) *Node { return &amp;Node{Value: value} } func (node *Node) Print() { fmt.Print(node.Value, " ") } func (node *Node) SetValue(value int) { if node == nil { fmt.Println("node is nil") return } node.Value = value } traversesal
package tree func (node *Node) Traverse() { if node == nil { return } node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfeffb6d6e1478ca7abdba6428bda7e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/691145e4657d4c14fe7c6e177e72c975/" rel="bookmark">
			Origin绘制带平滑曲线和数据标签的散点图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Origin绘制带平滑曲线和数据标签的散点图 数据导入：直接复制粘贴或者从excel中导入。
设置X、Y轴和标签列：分别双击A(X) B(Y) C(Y)列，进入绘图设定
在选项→绘图设定里面选择标签，X轴或Y轴
绘图：选中XY轴数据，右键选择绘图→折线图→样条连接图
曲线设定：如果觉得曲线不够平滑，可以双击该曲线，在绘图细节的线条连接中选择合适的连接方式，在这里也可以更改线条的宽度、颜色等。
标签设定：双击散点图中的点，在绘图细节的标签处，勾选启用，设置标签形式，选择标签列列作为标签，在这里还可以更改标签的大小。
坐标轴设定：若对坐标轴的刻度大小和间隔不满意，可双击坐标轴进行修改，还可以修改字体字号等。
设置刻度线朝内
设置坐标轴刻度为百分数：刻度标签→显示→显示悬着自定义，格式选#%
最终结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bd56552b225c970db29b614686ebc0c/" rel="bookmark">
			腾讯云域名解析教程（域名DNS解析到公网IP地址）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在腾讯云申请注册的域名如何解析？DNSPod并入腾讯云，腾讯云域名解析是在DNS解析DNSPod控制台操作的，腾讯云百科来详细详细说下腾讯云域名解析教程：
腾讯云域名解析教程 DNSPod帝思普并入腾讯云，腾讯云域名解析是由DNSPod提供的。腾讯云百科来详细说下腾讯云域名解析教程：
1、登录到腾讯云DNS解析DNSPod
腾讯云DNS解析DNSPod域名解析
找到需要解析的域名，然后点击域名右侧的“解析”
2、在域名解析页面，选择“添加记录”
记录类型可选A记录、CNAME、MX、TXT、NS、AAAA、SRV、显性URL或隐性URL。A记录是指将域名解析到IP地址上，也是比较常用的；CNAME是指将域名解析到另一个域名；MX是企业邮箱解析；TXT解析可用于SSL证书DNS验证。大家根据实际情况选择即可。详细参考下表：
记录类型使用目的A 记录将域名指向一个 IP 地址（外网地址）。CNAME 记录将域名指向另一个域名，再由另一个域名提供 IP 地址（外网地址）。MX 记录设置邮箱，让邮箱能收到邮件。NS 记录将子域名交给其他 DNS 服务商解析。AAAA 记录将域名指向一个 IPv6 地址。SRV 记录用来标识某台服务器使用了某个服务，常见于微软系统的目录管理。TXT 记录对域名进行标识和说明，绝大多数的 TXT 记录是用来做 SPF 记录（反垃圾邮件）。隐、显性 URL 记录将一个域名指向另外一个已经存在的站点。 腾讯云百科以域名解析到云服务器公网IP地址为例，图文详解腾讯云域名解析教程。腾讯云百科以www.txybk.com网址解析到云服务器公网IP地址为例，分别添加2条A记录，分别将带www的域名和不带www的域名都解析到云服务器IP地址上，如下图：
腾讯云域名解析到IP地址
主机记录：www和@，www是指带www的域名，即www.txybk.com；@是指不带www的域名，即txybk.com记录类型：A，域名解析到IP地址选择A记录线路类型：默认记录值：你的云服务器公网IP地址TTL（秒）：600，默认即可 然后点保存即可。可以参考官方文档：腾讯云域名快速解析教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a32e34ea7e4558d1706d3abfaa7f066/" rel="bookmark">
			小程序多类目与运算筛查随笔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在搞小程序开发，昨个突然想要筛多个类目，还是进行并列的与运算筛，
看到的单元素查询大多长这样，用到了db.command的也进行的是或运算筛，最后暴力用了.where().where()这样的叠叠乐。。。好在有用先用着吧。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f16655f940a36d02d1c64a4ca9b58981/" rel="bookmark">
			前端基础CSS&#43;html篇 2w字吐血总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端工程师是互联网时代软件产品研发中不可缺少的一种专业研发角色。从狭义上讲，前端工程师使用 HTML、CSS、JavaScript 等专业技能和工具将产品UI设计稿实现成网站产品，涵盖用户PC端、移动端网页，处理视觉和交互问题。从广义上来讲，所有用户终端产品与视觉和交互有关的部分，都是前端工程师的专业领域。
当然这是百度百科的介绍，实际上前端的技术栈远比想象的要复杂的多，并且更新迭代速度极快，前几年也许会jquery即可找到工作，但近年来各个行业内卷严重，导致前端需要拥有的技术已经不仅仅是前端三剑客了，但归根结底前端的基础却从未变过。再多的UI组件库也都是基于css，再多的框架也都是基于js的，因此学好前端三剑客是学会前端的基础。如果把前端的学习之路比喻成修炼武功，那么计算机网络，算法便是内功，css，html，js就是九阴真经，学会之后再接触任何的框架也都会突飞猛进，一点就通，但若是基础没打牢，那么后面的学习便会进步迟缓。
无论您是前端小白，还是久经沙场的大佬，请您记住：真正的大师永远保持一颗学徒的心。我们在这条路上风雨无阻，砥砺前行
目录
HTML基础
HTML简介
HTML、CSS、Js三者关系
浏览器解析
网页骨架结构
HTML代码汇总
1、文字标题标签
2、媒体链接
3.Form表单
4、 表格
5、列表
6、语义化标签
CSS基础
CSS简介
CSS代码
16种常用选择器
1、浏览器兼容问题
2、元素显示模式
3、常见单位
4、颜色
5、字体和文本
6、背景
7、盒模型
8、三大特性
9、浮动和清除浮动
10、定位
11、装饰
12、平面空间转换
移动端
flex布局
移动适配
rem、vw/vh
less语法
bootstrap框架
HTML基础 HTML简介 HTML、CSS、Js三者关系 接下来先从网页的组成成分来进行讲解：
如我们所常识的网页就是有文字、图片、音频、视频、链接等组成的。在网页的背后是由我们程序员所书写的代码，经浏览器（解析和渲染）形成了我们所看见的图片文字等。那么我们所书写的代码就是HTML是可以被浏览器所识别的语言，它与java，c不同的是，HTML是超文本标记语言，是一种描述语言，而java等是由汇编语言演变而来的高级语言。通常来说java等用于后端，HTML用于前端是网页的骨架结构。
如图所示谷歌首页的代码对应于右侧的代码，通常由css+html+JavaScript构成的，这也是Web标准写法，实现各种网页效果，那么三者的区别在哪里呢？
html是结构、css是表现、js是行为。如果把三者比喻成动画片，那么html就是铅笔稿，Css就是在铅笔稿之上加入的颜色，JS就是最后添加的动作，三者结合便可以呈现一部完美的作品了。
Web标准是由W3C组织和其他标准化组织制定的一系列标准的集合。W3C(万维网联盟）是国际最著名的标准化组织。
浏览器解析 如上我们所看到的，浏览器作为将代码解析给我们的媒介，它的组成是什么样子呢？
大多数的网页就由以下的几部分组成，这里面相对来说比较重要与我们前端比较相关的是title和网站图标的设置。还有就是URL（统一资源定位器）
URL由三部分组成：资源类型、存放资源的主机域名、资源文件名。也可认为由4部分组成：协议、主机、端口、路径。 当然这部分建议大家看计算机网络这本书，对于网址，IP地址，域名解析等有更深的理解。前端的工作与计算机网络也是密不可分的。
除此之外每个浏览器都有自己的内核，渲染引擎(浏览器内核)︰浏览器中专门对代码进行解析渲染的部分浏览器出品的公司不同，内在的渲染引擎也是不同的:
网页骨架结构 如下图，在我们使用VScode或其他编程软件时会经常输入以下命令，那么我们是否想过以下命令的含义呢？ 实际上这些命令便是一个网页的基础结构，同时是用来告诉浏览器我们使用的是html语言，浏览器便能进行解析了。
粗略来看把骨架结构当做一个人的话，那么html标签就是人的全部结构，head就是头部，body就是其余的躯体部分。
那么接下来便将html骨架进行一一拆解，这样我们便可以做到知其然知其所以然。
首先是 &lt;!DOCTYPE html&gt; 这句话是告诉浏览器我们 使用的文档语言是HTML5版本。必须要书写到文档的第一行。
第二行是 &lt;html lang="en"&gt; &lt;/html&gt; 与最后一行构成的双标签结构，在此区间内的所有内容便是网页的内容，lang=“en” 表示的是网页所使用的语言，en代表English ，如果想改成中文便是lang=“ZH-CN”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f16655f940a36d02d1c64a4ca9b58981/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59324d3be746fccace6f4585b5c5d8f8/" rel="bookmark">
			再也不用发愁文献翻译了（完全免费）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识盲盒
文献翻译不用愁--以英译中为例 步骤1. 找到英文论文1.1中国知网1.2谷歌学术 2.论文pdf转为word3.软件翻译4.解密与手动修改 又是一年毕业季~~~ 文献翻译头都大了！ 逐字逐句翻译，少则十天半月；常规软件翻译，错误百出，反复修改 本文介绍一个DeepL软件。翻译准确率极高，而且支持文档翻译。 中文文件进去英文文件出来 省时省力！ 先上翻译好的文档，效果如下
步骤 1. 找到英文论文 这里方法比较多比如
★中国知网
★百度学术
★sci-Hub
最强科研论文利器，涵盖好、论文多，完全免费
Alexandra女神姐姐提供了两个访问地址1， 2
★谷歌学术（国内不太方便，想使用的话，下面有方法😎，继续看哦）
每种途径都要注意输入英文的主题词查找
上述途径除了中国知网和谷歌学术比较麻烦一点，其他就跟搜索引擎一样使用方便
所以这里简单介绍下中国知网和谷歌学术的使用
1.1中国知网 还不知道怎么在校外登陆中国知网吗？
然后就可以通过登陆自己的学校系统进入知网免费下载文献了
1.2谷歌学术 跟中国知网搜索方法类似，输入英文的主题词查找
然后下载
不过谷歌学术需要VP嗯，自己可以想想办法
这里可以推荐一个免费的VP嗯 Hoxx Vp嗯 Proxy 是火狐浏览器中的插件 不过速度有点慢
2.论文pdf转为word 因为后面使用的翻译软件，翻译之后会被加密无法编辑，所以我们需要先把从知网和谷歌学术下载来的pdf格式的英文文献通过微软Word转为可编辑的word格式
这里使用word打开pdf即可
3.软件翻译 这里我们使用号称“目前最好的翻译软件”DeepL（网页版即可），中文文件进去 英文文件出来（注意保存为word格式）
保存翻译好的文件即可。
小tips
由于我们使用DeepL是免费的，翻译文档的大小有一定的限制。可以使用软件进行拆分
比如Adobe Acrobat (免费) WPS会员版（收费）
4.解密与手动修改 打开翻译好的word文件后 发现文档被DeepL加密了, 无法编辑。
这时我们可以使用word中的一个功能转为可编辑的形式。
打开微软Word --选择“插入 ”–“对象”–“文件中的文字” 选择被加密的文件， 这时候会发现文档就变得可以编辑了
由于转为word后，格式有些乱，特别是一些图片和表格，自己可以根据最初下载的英文论文格式稍加修改，使文章更为美观！这样文献翻译就完成了！😉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60af8b3a0f79bf41d969bf673dcb6d53/" rel="bookmark">
			win10家庭版升级专业版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果通过更改产品密钥的方式，出现错误代码0x803fa067
那么，断网重试即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbac3b20811eb2ee1ed13c373a49ce74/" rel="bookmark">
			Redis高级(持久化--redis主从架构--redis哨兵模式--redis分片集群)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
redis实现持久化的两种模式
redis主从架构
redis主从集群 -- 数据同步优化
redis主从集群+哨兵框架
redis分片集群
redis实现持久化的两种模式 RDB持久化
RDB全称Redis Database Backup file（Redis数据备份文件）,也被称为数据快照,就是把redis内存中的所有数据写入到本地磁盘中, 当服务宕机重启后,可以读取本地磁盘文件来恢复数据,Redis数据备份文件被称为RDB文件,默认是保存在当前运行目录下(可通过配置文件更改相关保存信息)
执行时机:
1) 执行save命令
2) 执行bgsave命令
3) 正常停机时
4) 达到RDB自动保存的阈值时
save命令:
执行save命令,会触发一次RDB持久,是主进程在进行磁盘IO, 此时无法对外提供服务,会阻塞请求, 只适用于手动停机,数据迁移的场景
bgsave命令:
与save命令不同的是,bgsave是异步执行的,从主进程fork一个子进程进行持久化操作,在磁盘IO的时候,不会阻塞请求,主进程能够正常的提供服务,值得注意的是在主线程fork的时候是阻塞请求的状态
RDB自动保存阈值:
Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：
save 900 1 # 900秒内，如果至少有1个key被修改，则执行bgsave save 300 10 # 300秒内, 如果至少有10个key被修改,则执行bgsave save 60 10000 # 60秒内,10000个key # 如果是save "" 则表示禁用RDB 其他配置:
# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱 rdbcompression yes # RDB文件名称 dbfilename dump.rdb # 文件保存的路径目录 dir ./ RDB执行原理:
save:
操作系统会在redis中维护一个虚拟内存表" 页表 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbac3b20811eb2ee1ed13c373a49ce74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5963eca01fb9b6efb82488dad6c0ca8a/" rel="bookmark">
			SSL认证过程介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、SSL概述 安全套接层（Secure Socket Layer，SSL ）是一种在两台机器之间提供安全通道的协议。它具有保护传输数据以及识别通信机器的功能。安全通道是透明的，意思就是说它对传输的数据不加变更。客户与服务器之间的数据是经过加密的，一端写入的数据完全是另一端读取的内容。透明性使得几乎所有基于TCP 的协议稍加改动就可以在SSL 上运行，非常方便。
Netscape公司在推出第一个Web浏览器的同时，提出了SSL协议标准,目前已有3.0版本。SSL采用公开密钥技术。其目标是保证两个应用间通信的保密性和可靠性,可在服务器端和用户端同时实现支持。目前，利用公开密钥技术的SSL协议，已成为Internet上保密通讯的工业标准。安全套接层协议能使用户/服务器应用之间的通信不被攻击者窃听，并且始终对服务器进行认证，还可选择对用户进行认证。SSL协议要求建立在可靠的传输层协议(TCP)之上。SSL协议的优势在于它是与应用层协议独立无关的，高层的应用层协议(例如：HTTP，FTP，TELNET等)能透明地建立于SSL协议之上。SSL协议在应用层协议通信之前就已经完成加密算法、通信密钥的协商及服务器认证工作。在此之后应用层协议所传送的数据都会被加密，从而保证通信的私密性。
2、SSL的分层结构 SSL位于应用层和传输层之间，它可以为任何基于TCP等可靠连接的应用层协议提供安全性保证。SSL协议本身分为两层：
图1 SSL协议分层
（1）上层为SSL握手协议（SSL handshake protocol）、SSL密码变化协议（SSL change cipher spec protocol）和SSL警告协议（SSL alert protocol）；
SSL握手协议：是SSL协议非常重要的组成部分，用来协商通信过程中使用的加密套件（加密算法、密钥交换算法和MAC算法等）、在服务器和客户端之间安全地交换密钥、实现服务器和客户端的身份验证。
SSL密码变化协议：客户端和服务器端通过密码变化协议通知对端，随后的报文都将使用新协商的加密套件和密钥进行保护和传输。
SSL警告协议：用来向通信对端报告告警信息，消息中包含告警的严重级别和描述。
（2）底层为SSL记录协议（SSL record protocol）。
SSL记录协议：主要负责对上层的数据（SSL握手协议、SSL密码变化协议、SSL警告协议和应用层协议报文）进行分块、计算并添加MAC值、加密，并把处理后的记录块传输给对端。
3、SSL握手过程 SSL 握手有三个目的。第一，客户端与服务器需要就一组用于保护数据的算法达成一致。第二，它们需要确立一组由那些算法所使用的加密密钥。第三，握手还可以选择对客户端进行认证。整个过程工作如下：
图2 SSL握手概述
（1）客户端将它所支持的算法列表连同一个密钥产生过程用作输入的随机数发送给服务器。
（2）服务器根据从列表的内容中选择一种加密算法，并将其连同一份包含服务器公用密钥的证书发回给客户端。该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个作为密钥产生过程部分输入的随机数。
（3）客户端对服务器的证书进行验证，并抽取服务器的公用密钥。然后，再产生一个称做pre_master_secret 的随机密码串，并使用服务器的公用密钥对其进行加密。最后，客户端将加密后的信息发送给服务器。
（4）客户端与服务器端根据 pre_master_secret 以及客户端与服务器的随机数值独立计算出加密和MAC密钥。
（5）客户端将所有握手消息的 MAC值发送给服务器。
（6）服务器将所有握手消息的 MAC值发送给客户端。
在此过程结束时，客户端与服务器已就使用的加密算法达成一致，并拥有了一组与那些算法一起使用的密钥。
3.1 只验证服务器的SSL握手过程 只验证服务器的SSL是最常见的情况，如图3所示，只需要验证SSL服务器身份，不需要验证SSL客户端身份时，SSL的握手过程为：
（1）SSL客户端通过Client Hello消息将它支持的SSL版本、加密算法、密钥交换算法、MAC算法等信息发送给SSL服务器。
（2）SSL服务器确定本次通信采用的SSL版本和加密套件，并通过Server Hello消息通知给SSL客户端。如果SSL服务器允许SSL客户端在以后的通信中重用本次会话，则SSL服务器会为本次会话分配会话ID，并通过Server Hello消息发送给SSL客户端。
（3）SSL服务器将携带自己公钥信息的数字证书通过Certificate消息发送给SSL客户端。
（4）SSL服务器发送Server Hello Done消息，通知SSL客户端版本和加密套件协商结束，开始进行密钥交换。
（5）SSL客户端验证SSL服务器的证书合法后，利用证书中的公钥加密SSL客户端随机生成的pre_master_secret，并通过Client Key Exchange消息发送给SSL服务器。
（6）SSL客户端发送Change Cipher Spec消息，通知SSL服务器后续报文将采用协商好的密钥和加密套件进行加密和MAC计算。
（7）SSL客户端计算已交互的握手消息（除Change Cipher Spec消息外所有已交互的消息）的Hash值，利用协商好的密钥和加密套件处理Hash值（计算并添加MAC值、加密等），并通过Finished消息发送给SSL服务器。SSL服务器利用同样的方法计算已交互的握手消息的Hash值，并与Finished消息的解密结果比较，如果二者相同，且MAC值验证成功，则证明密钥和加密套件协商成功。
（8）同样地，SSL服务器发送Change Cipher Spec消息，通知SSL客户端后续报文将采用协商好的密钥和加密套件进行加密和MAC计算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5963eca01fb9b6efb82488dad6c0ca8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f1cd51f4952dd5b758a55d0e4aaaad/" rel="bookmark">
			CentOS7安装docker服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CentOS7安装docker服务 一、下载离线安装包二、安装rpm包 之前写过一篇关于Ubuntu16.04安装docker与NVIDIA相关的文章，这次因为公司服务器使用centos，发现用之前的方式还不行，有一点不一样，所以这次自己实践后就动手记录一下。 一、下载离线安装包 docker ： 下载地址 ， 分别下载：
containerd.io-1.2.5-3.1.el7.x86_64.rpm docker-ce-19.03.5-3.el7.x86_64.rpm docker-ce-cli-19.03.5-3.el7.x86_64.rpm 二、安装rpm包 将下载好的三个rpm文件放置centos服务器上，如下图：
执行以下命令进行安装 [root@localhost tools]# rpm -Uvh *.rpm --nodeps --force 安装完成后，输入命令启动docker服务 [root@localhost tools]# systemctl start docker 如果启动过程中遇到：Job for docker.service canceled 问题，直接执行以下命令（参考资料： docker内网环境下离线安装完成后，启动报错Job for docker.service canceled.解决方案.） [root@localhost tools]# yum -y install systemd-devel systemd-libs libseccomp device-mapper-libs 执行完成后，再次输入步骤3的命令，启动docker服务，即可正常使用最后，将docker 添加到开机自启中 [root@localhost tools]# systemctl enable docker 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9799cdf25276ba13c56af7faed2c27e/" rel="bookmark">
			MATLAB图形的修饰（选择图形窗口、线型点颜色、坐标轴、图形标注、栅格和图形叠加的设置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在绘制曲线时，MATLAB自动安排曲线的线型、颜色及坐标等属性，有时需要用户对图形的坐标、曲线和注释等进行进一步的修饰，以增加图像的可读性，突出结果的显示。 MATLAB提供了一些函数可以对图形进行修饰。
1、选择图形窗口设置
MATLAB提供了函数figure()用来打开不同的图形窗口，具体调用格式如下。
①figure(1); figure(2); figure(n)：该函数用来同时打开多个图形窗口，以便在不同窗口中绘制不同的图形。
MATLAB提供函数subplot()用来分割同一个图形窗口，具体调用格式如下。
subplot(m, n, p)：该函数将当前窗口分割为mXn个图形区域，m为分割行数，n为分割列数，p为子图形编号，在不同的图形区域可以以独立的坐标系绘制图形，其简化形式为subplot(mnp)。
2、线型、顶点和颜色的设置
在函数plot()调用时，MATLAB会自动对线型、顶点和颜色进行设置，用户也可以根据需要对线型、顶点和颜色自行设置。MATLAB中提供允许一个可选范围，如表2.18所示。
3、坐标轴的设置
MATLAB在绘制图形的同时会自动选择合适的坐标轴，也提供函数axis()设置用户自定义坐标轴，具体调用格式如下。
①axis([xmin xmax ymin ymax])： 该函数中[xmin xmax ymin ymax]定义二维图形x轴和y轴坐标轴的范围，其中必须满足: xmin&lt;xmax， ymin&lt;ymax。
②axis equal：该函数将横轴和纵轴单位长度设置相同。
③axis square：该函数设置坐标轴为正方形。
④axis normal： 该函数解除对坐标轴的任何限制。
⑤axis off： 该函数取消坐标轴的一切设置。
⑥axis on： 该函数恢复坐标轴的一切设置。
4、图形标注的设置
MATLAB提供常用的图形文字标注的函数，具体调用格式如下。
①title(string’)： 该函数在图形的最上端设置当前图形的标题为字符串string。
②xlabel('string)： 该函数在图形的最下端设置图形横轴的标题为字符串string。
③ legend(‘stringl’, ‘string2’,…)：该函数在屏幕上开启小视窗，添加图例，根据绘图的顺序依次给出各个图形的描述。
④text(x, y, 'string)：该函数在二维平面的指定坐标(x, y)处添加文本标注，文本的内容为字符串string。
⑤gtext('string)：该函数通过单击鼠标来确定文本的位置,文本的内容为字符串string。
5、栅格的设置
MATLAB提供常用的栅格函数，具体调用格式如下。
①grid: 该函数给图形加上栅格，不带参数时，在grid on和grid off之间进行切换。
②grid on：该函数给当前坐标系添加坐标网格。
③grid off：该函数从当前坐标系中删去坐标网格。
④grid minor：该函数设置网格线间的间距。
6、图形叠加设置
MATLAB在默认情况下，绘制第二条曲线时，若没有叠加设置，则第一条曲线就会被第二条曲线所覆盖，不会两条曲线绘制在同一图形窗口下。为了在一张图中绘制多条曲线及多次叠加绘制曲线，MATLAB提供了函数hold(),具体调用格式如下。
①hold on：该函数将当前曲线与坐标保持在屏幕上，同时在这个坐标系中画出另一个图形。
②hold off：该函数将旧图用新图覆盖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9799cdf25276ba13c56af7faed2c27e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be0214b6af0b5e2ad1af1f9100bb015/" rel="bookmark">
			org.apache.catalina.connector.ClientAbortException: java.io.IOException: 您的主机中的软件中止了一个已建立的连接。的解决方案之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 org.apache.catalina.connector.ClientAbortException: java.io.IOException: 您的主机中的软件中止了一个已建立的连接。
客户端在发送请求后，还没等服务器响应就断开了连接。
tomcat中配置了一个连接超时时间connectionTimeout，如果在这个时间之后客户端还未得到服务器端的响应的话，就会主动断开连接。
tomcat中默认的连接超时时间是20秒，可以设置为60秒，从而避免后台程序处理时间长导致连接断开。
解决方案：
找到本地tomcat/conf/server.xml文件
配置端口connectionTimeout连接超时时间改为60000
&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="60000" redirectPort="8443" /&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d563a344973577f23210db33a8fd3f47/" rel="bookmark">
			Seata分布式事务管理框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是分布式事务问题
CAP定理
BASE理论
解决分布式事务问题的思路
Seata框架 -- 介绍
Seata框架 -- TC事务协调者的部署
Seata框架 -- XA模式
Seata框架 -- AT模式
Seata框架 -- AT模式 -- 脏读解决方案
Seata框架 -- TCC模式
Seata框架 -- SAGA模式
四种模式的对比
什么是分布式事务问题 在分布式架构中,一般会有很多微服务与数据源,当程序对不同的微服务或数据源进行业务操作的时候,就需要所有的操作保证业务的原子性, 而不同的微服务有可能会出现问题而导致事务问题出现
CAP定理 CAP定理是1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。
而这三个指标不可能同时做到。这个结论就叫做 CAP 定理。 Consistency（一致性）:
用户访问分布式系统中的任意节点，得到的数据必须一致。
Availability（可用性）:
用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。
Partition tolerance （分区容错性）:
因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。在集群出现分区时，整个系统也要持续对外提供服务
为什么说CAP定理不能同时满足:
分布式系统中,微服务一定会有概率出现单点故障, 此时就会出现 分区问题 ,而我们如果要保证 一致性 , 就要等待微服务修复,再让分布式系统对外提供服务,此时就导致 可用性 无法满足, 如果要保证 可用性 ,就会导致单点故障的那台微服务与其他微服务出现 一致性 问题. BASE理论 BASE理论是对CAP的一种解决思路，包含三个思想：
Basically Available （基本可用）：
分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d563a344973577f23210db33a8fd3f47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c069fd7ea857dcc1d06878b92081d3/" rel="bookmark">
			部署web服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部署web服务器 EB部署的常用软件 Apache，iis
虚拟目录是什么。它的作用 如果文件很多，主目录的空间可能会不足，因此需要将上述文件存放在其他区域或者其他计算机上，而用户访问时，上述文件夹在逻辑上归属网站之下，这种归属网站之下的目录成为虚拟目录。
作用：可以利用虚拟目录将一个网站的文件分散存储在同一台计算机的不同路径或不同计算机中，但这些文件在逻辑上仍归属于同一个站点，并且仍为Web站点的内容。
虚拟主机是什么。它的作用。 在一台服务器上运行的多个网站，这些网站称为虚拟主机
作用：提高硬件资源的利用率，可以在一台服务器上运行多个网站
4. 虚拟主机的几种方式。 （1） 使用不同的IP地址
（2） 使用相同的IP地址和不同的TCP端口号
（3） 使用相同的IP地址和TCP端口号，不同的主机名。
实验 在添加网站中输入网站名称，物理路径，并选择该站点要使用的IP地址并保存原始网页，俩网页端口号都为80
2. 相同IP不同端口号 3. 使用不同端口号访问网站 在dns下新建两个主机名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f044adb6803973e54612621c0f7e02f9/" rel="bookmark">
			Lesson 13.3 梯度不平稳性与Glorot条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lesson 13.3 梯度不平稳性与Glorot条件 从本节开始，将正式进入到优化方法的具体方法部分内容。首先是关于激活函数使用过程的优化。在上一节的结尾，我们发现，尽管激活函数的使用能够有效提升神经网络模型效果，但激活函数的简单叠加却会让模型出现很多问题。深度学习本来就是深层次神经网络，如果不解决激活函数在叠加过程中遇到的问题，深层次神经网络也就无从构建。
本节将从上一节建模过程中所遇到的、堆叠激活函数之后遇到的问题入手，讨论造成这些问题的根源，以及如何通过一些优化方法解决这些问题。
模型病灶与模型调优 在正式进入到模型优化方法之前，我们需要简单了解到底什么是模型优化。有很多初学者会简单的认为模型优化方法就是能让模型得出更好结果的方法，但实际上模型优化更像是对“患病”的模型进行诊断、然后对症下药，通过这些“治疗”方法，最终让模型运行恢复正常且健康的状态，并得出较好的模型预测结果。尽管优化方法就像一种种药品，各自都标注了适用的病症，但深度学习模型在某种程度上就像人体一样，是个非常复杂的系统，很多时候并不是“A药治A病”、并不是一个“只要…就…”的命题。模型优化和疾病治疗一样，很多时候都是多种手段作用于复杂系统、最终通过这个复杂系统自身的特性发挥作用。业余算法工程师进行模型调优就像我们平时去药店买药，啥病买啥药，然后挑个贵的；而专业的算法工程师进行模型调优则更像医生为患者进行诊断，在了解病理的基础上，通过一些列更加专业的诊断手段判断病情，然后提出更加高效的综合性解决方案。
因此，初级算法工程师只需要知道模型会有什么样的问题（什么病）以及分别可以用什么方法解决（都有什么药），模型调优时主要靠套用和反复调试（多尝试各种办法），而更加专业的算法工程师则需要知道这些模型问题背后的成因，也就是到底是什么原因导致了模型出现这些问题（病理），同时也需要掌握更加丰富的诊断模型问题的一些方法（不仅仅是看模型评估指标结果），然后了解优化方法的基本原理以及发挥作用的方式，当然至关重要的一段是需要在长期实践中不断积累经验，才能最终获得专业性的长足的进步。
正是出于这些角度的考虑，在优化方法的内容中，我们不仅会介绍每一种方法发挥作用的场景，更重要的是我们会同步介绍深度学习模型在建模过程中的一些典型问题的病理、诊断这些问题的角度及方法，以及优化方法背后的“药理”。从而尽可能帮助各位学员向更加专业的方向迈进。
一、梯度消失与梯度爆炸 对于神经网络这个复杂系统来说，在模型训练过程中，一个最基础、同时也最常见的问题，就是梯度消失和梯度爆炸。
我们知道，神经网络在进行反向传播的过程中，各参数层的梯度计算会涉及到激活函数导函数取值，具体来说，假设现在有一个三层的神经网络，其中两个隐藏层的激活函数为 F ( x ) F(x) F(x)，对应的导函数为 f ( x ) f(x) f(x)，设X为输入训练的数据特征，y为标签， y ^ \hat y y^​为模型向前传播输出结果， w 1 w_1 w1​为第一层参数、 w 2 w_2 w2​为第二层参数、 w 3 w_3 w3​为第三层参数，loss为损失函数，则有如下计算公式：
每一次正向传播计算结果：
y ^ = F ( F ( X ∗ w 1 ) ∗ w 2 ) ∗ w 3 \hat y = F(F(X * w_1) * w_2) * w_3 y^​=F(F(X∗w1​)∗w2​)∗w3​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f044adb6803973e54612621c0f7e02f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbaacf42dc776ab4e9683b9f914f6637/" rel="bookmark">
			spring框架简单入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初识spring
spring框架的两大优势:
1.==简化开发== 简化了企业级开发的复杂性
2.==框架继承==高效整合了其他主流框架,提升运行与开发效率
核心思想:
1.IOC(控制反转)
2.AOC(面向切面编程)
spring发展史:
2004年Rod Johnson创建了更为高效的spring框架,
spring1.0: 是去全配置形式进行编程
spring2.0: 添加了注解功能,提高了开发效率
spring3.0: 完全变成了纯注解开发
spring4.0: 根据jdk的更新, 对个别jdk进行了调整
spring5.0: 全面支持jdk8, 这个时候如果要用spring框架就要使用jdk8至以上的版本
spring框架的架构图:
IOC与DI核心思想:
IOC(Inversion of Control 控制反转)
new对象这样层级之间的耦合性就会很高,IOC是将创建对象的权利移交给了外部,也就是spring,spring框架在外部创建了一个IOC容器,将创建的对象称之为Bean存储在容器中.当我们需要用到对象的时候,容器给我们提供了一个方法,我们就可以获取到对象,也解除了耦合性
DI(Dependency Injection 依赖注入)
往往一个对象的执行需要依赖于其他对象的支撑,这个时候spring框架会将IOC容器中存储的有依赖关系的bean进行依赖绑定.
IOC和DI的实现,为了实现充分的解耦,这样我们不仅可以直接从容器中拿到bean,而且bean也获取到了所有的依赖关系
使用配置文件简单实现IOC控制反转
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--在spring配置文件中配置管理bean--&gt; &lt;!--配置数据实现层bean--&gt; &lt;!-- id属性: 代表指定的bean名称,在从容器中获取bean的时候,用此名称可以获取到此bean--&gt; &lt;!-- class属性: 指定bean的类型,这里用全类名指定到数据实现层的实现类BookDaoImpl,代表创建的bean是BookDaoImpl类型--&gt; &lt;bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"&gt; &lt;/bean&gt; &lt;!--配置业务实现层bean--&gt; &lt;!-- id属性: 代表指定的bean名称,在从容器中获取bean的时候,用此名称可以获取到此bean--&gt; &lt;!-- class属性: 指定bean的类型,这里用全类名指定到数据实现层的实现类BookServiceImpl,代表创建的bean是BookServiceImpl类型--&gt; &lt;bean id="bookService" class="com.itheima.service.impl.BookServiceImpl"&gt; &lt;!--而业务实现层对象是依赖于数据实现层对象运行的,所以service层依赖dao层,使用DI进行依赖注入--&gt; &lt;!--name属性:代表配置的哪一个具体的属性--&gt; &lt;!--ref属性: 代表依赖的哪一个bean,这里依赖的是dao层的bean--&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbaacf42dc776ab4e9683b9f914f6637/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b6d8f15f167ac1ffbbf661882c1d83/" rel="bookmark">
			Sentinel哨兵框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是"雪崩效应"?
解决"雪崩"的常用4种解决方案
sentinel--介绍
sentinel--簇点链路
sentinel--流量控制--三种模式
sentinel--流量控制--三种效果
sentinel--流量控制--热点参数限流
sentinel--线程隔离模式(舱壁模式)
信号量隔离与线程池隔离的区别
sentinel--熔断模式--介绍
sentinel--熔断模式--三种统计方式
sentinel--访问授权
sentinel--自定义异常
sentinel--规则持久化
什么是"雪崩效应"? "雪崩"是指在微服务的调用链路中,一个服务出现问题,会出现连锁反应,导致所有的依赖服务出现异常.
假如A服务调用B服务,B服务宕机,A服务的请求就会无响应,并占用A服务的资源,所有资源都被占用后,A服务也会宕机
解决"雪崩"的常用4种解决方案 请求超时模式:
在请求一定时间无响应后返回请求失败,这样可以防止调用者的资源消耗
线程隔离(舱壁模式):
在调用者调用微服务时,会创建指定数量的线程池,当微服务宕机时,只会影响到调用者一定数量的线程资源,
熔断模式:
会在服务间创建一个断路器,由断路器进行监控服务调用的健康状态,若超过了设置的阈值,就会进行熔断,禁止对该微服务的调用,
流量控制模式:
根据自定义策略限制对微服务访问的QPS, 以防瞬时高并发场景,导致微服务宕机
请求超时,线程隔离,熔断都属于补救策略,而流量控制属于预防策略
sentinel--介绍 sentinel是阿里巴巴开源出的一款微服务保护框架,它支持多种雪崩问题的补救与预防机制
与前期的Hystrix相比,sentinel更为完善
sentinel--簇点链路 当请求进入微服务时，首先会访问DispatcherServlet，然后进入Controller、Service、Mapper，这样的一个调用链就叫做簇点链路。簇点链路中被监控的每一个接口就是一个资源。
默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint，也就是controller中的方法），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源
sentinel--流量控制--三种模式 直接模式:
统计当前资源的QPS,超过阈值将会直接响应失败,进行限流
关联模式:
统计与当前资源相关的另一个资源的QPS,超过阈值将会对当前资源进行限流
链路模式:
阈值统计时，只统计从指定资源进入当前资源的请求，是对请求来源的限流
直接模式简单暴力,适用于对单一资源的保护,
关联模式适用于有两个竞争关系的资源,且优先级不同,比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流
链路模式适用于不同链路资源请求同一个资源, 比如查询订单和创建订单,都需要调用查询商品,可以针对查询订单请求查询商品进行链路模式流控, 用于保护创建订单的正常执行
sentinel--流量控制--三种效果 快速失败：
达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。是默认的处理方式。
warm up：
预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，刚开始是根据冷启动因子(3)来计算出初始值(阈值/冷启动因子),再逐渐增加到最大阈值。
排队等待：
让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长
warm up适用于服务冷启动, 此时服务还未能承受最高并发,可以进行慢启动,
排队等待适用于需要对进行流量削峰填谷,能够解决瞬时高并发问题
sentinel--流量控制--热点参数限流 前面是三种限流模式都是对同一资源的所有请求进行限流, 热点参数是对同一参数的请求进行限流,
适用于部分商品是热点商品，例如秒杀商品，我们希望这部分商品的QPS限制与其它商品不一样。那就需要配置热点参数限流的高级选项了 sentinel--线程隔离模式(舱壁模式) sentinel默认的舱壁模式是线程信号量隔离:
在微服务调用的时候,sentinel会创建一个线程计数器用于对调用者使用线程的记录,可以自定义线程阈值,
信号量隔离与线程池隔离的区别 线程池隔离：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果
信号量隔离：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9b6d8f15f167ac1ffbbf661882c1d83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/091983547a7175f948e4ad8f0e8e1f75/" rel="bookmark">
			Windows 下将Python项目打包为.exe可执行文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pycharm 打包为 .exe 可执行文件 01 安装 PyInstaller 模块02 打包文件 01 安装 PyInstaller 模块 Python 项目编写完成后，可以将其打包成一个 .exe 可执行文件，这样即使计算机上没有Python开发环境也可以运行该Python项目实现打包 .exe 可执行文件时，需要使用 PyInstaller 模块，该模块为第三方模块需要单独再安装PyInstaller 模块支持多种操作系统，如 Windows、Linux、Mac OS X 等，但是该模块并不支持跨平台操作。例如：如果实在 Windows 操作系统下打包的 .exe 可执行文件，该文件就只能在 Windows 环境下运行 Windows操作系统下安装PyInstaller模块输入以下命令：
pip install pyinstaller -i https://pypi.doubanio.com/simple 具体Python安装第三方库步骤详见 Python 下载安装第三方库
PyInstaller 模块安装完成以后，可以在命令提示符窗口中输入以下命令：
pyinstaller --version 通过查询 PyInstaller 模块版本的方式检测安装是否成功
02 打包文件 PyInstaller 模块安装完成以后，就可以打包Python项目.py文件为.exe文件，具体如下：
打开命令提示符窗口，输入以下命令： pyinstaller -F (要打包的.py文件的绝对路径)F:/PythonProject/studentSystem/studentsystem.py 参数 -F 表示只生成一个扩展名为 .exe 的可执行文件
输入以上命令按下 Enter 键后，将自动生成 .exe 可执行文件，具体如下：
在上图所示的位置找到打包好的 .exe 可执行文件，双击该文件即可运行，具体如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/091983547a7175f948e4ad8f0e8e1f75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40e53c11097a92fc08448eb19705b77a/" rel="bookmark">
			shell如何实现字符串不足N位自动补零
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		printf "%04d\n" 99 解释：其中0表示不足为数用0补全，4表示补全到4为数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a027749ab6cd93292cc0202d1dfcbeec/" rel="bookmark">
			Python学习笔记（7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、变量进阶
1.1 变量和引用
1.2 可变和不可变类型
1.3 局部变量和全局变量
1.4 函数参数和返回值的作用
1.5 多个返回值
1.6 交换两个数字
二、函数参数的进阶
2.1 不可变和可变的参数
2.2 +=
2.3 缺省参数
2.4 多值参数
三、函数的递归
3.1 特点
3.2 递归案例
一、变量进阶 1.1 变量和引用 &gt;变量和数据都是保存在内存中的；在Python中函数的参数传递以及返回值都是靠引用传递的。
&gt;在Python中，变量和数据是分开存储的，数据保存在内存中的一个位置，变量中保存这数据在内存中的地址，变量中记录数据的地址，就叫做引用。
&gt;使用id()函数可以查看变量中保存数据所在的内存地址。如果变量已经被定义，当给一个变量赋值的时候，本质上是修改了数据的引用。
1.2 可变和不可变类型 &gt;不可变类型
内存中的数据不允许被修改：
数字型int,bool,float,complex,long(2.x)
字符串str
元组tuple
&gt;可变类型
内存中是的数据可以被修改
列表list
字典dict
&gt;字典中的key只能使用不可变类型的数据
可变类型的数据变化，是通过方法来实现的； 如果给一个可变类型的变量，赋值了一个新的数据，引用会修改。
&gt;哈希（hash）
Python中内置有一个名字叫做hash()的函数，接收一个不可变类型的数据作为参数，返回结果是一个整数。
哈希是一种算法，其作用是提取数据的特征码，相同的内容得到相同的结果，不同的内容得到不同的结果。
在Python中，设置字典的键值对时，会首先对key进行hash已决定如何在内存中保存字典的数据，以方便后序对字典的操作：增、删、改、查。键值对的key必须是不可变类型数据；键值对的value可以是任意类型的数据。
1.3 局部变量和全局变量 &gt;局部变量
局部变量是在函数内部定义的变量，只能在函数内部使用；函数执行结束后，函数内部的局部变量，会被系统回收；不同的函数，可以定义相同的名字的局部变量，但是各用个的不会产生影响。
作用：在函数内部使用，临时保存函数内部需要使用的数据。
局部变量的生命周期：
所谓生命周期就是变量从被创建到被系统回收的过程；局部变量在函数执行时才会被创建；
函数执行结束后局部变量被系统回收；局部变量在生命周期内，可以用来存储函数内部临时使用到的数据；
&gt;全局变量
全局变量时在函数外部定义的变量（没有定义在某一个函数内），所有函数内部都可以使用这个变量。
函数执行时，需要处理变量时会：
1.首先查找函数内部是否存在指定名称的局部变量，如果有，直接用；
2.如果没有，查找函数外部是否存在指定名称的全局变量，如果有，直接使用
3.如果还没有，程序报错！
（1）函数不能直接修改全局变量的引用，在函数内部，可以通过全局变量的引用来获取对应的数据，但是不允许直接修改全局变量的引用。
（2）如果在函数中需要修改全局变量，需要使用global进行声明
（3）为了保证所有的函数都能够正确使用到全局变量，应该将全局变量定义在其它函数的上方。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a027749ab6cd93292cc0202d1dfcbeec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/560059071d5e262e6a3308090a2cd494/" rel="bookmark">
			uniapp 设置桌面角标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 桌面角标是由个推发送的，后台推送消息的时候，设置badge推送的数字,所以在申请个推证书的时候需要勾选 Push Notifications服务（ios平台）
在你进入阅读消息的页面 清除掉角标数量
注意，Android ROM的碎片化，导致此API在Android平台效果并不理想
//num是你消息的总数减去当前阅读消息的数量 plus.runtime.setBadgeNumber(num); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb214452d2c8e7bf02133b2319ad2cb2/" rel="bookmark">
			7hutool实战FileUtil 文件工具类(100多个文件常用操作方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术活，该赏 关注+一键三连（点赞，评论，收藏）再看，养成好习惯 hutool实战（带你掌握里面的各种工具）目录
用途：文件工具类(文件常用操作) 使用场景 提供100多个文件常用操作方法，包含并不局限于：判断文件或文件夹是否为空、判断file是否为文件或文件夹、递归文件夹里的所有文件、获取指定文件夹的所有文件名、获取临时文件夹或临时文件的内容或者路径、计算文件夹或文件的总大小、创建文件或文件夹、创建临时文件或临时文件夹、删除文件或文件夹、修改文件名或文件夹名、复制文件或文件夹、移动文件或文件夹、清空文件夹、获取规范的绝对路径、比较两个文件、判断文件是否被改动、获取父路径或子路径、获取主文件名或后缀名等
项目引用 此博文的依据：hutool-5.6.5版本源码
&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-core&lt;/artifactId&gt; &lt;version&gt;5.6.5&lt;/version&gt; &lt;/dependency&gt; 方法摘要 方法
描述
cn.hutool.core.io.FileUtil.isWindows()
是否为Windows环境
cn.hutool.core.io.FileUtil.ls(java.lang.String)
列出目录文件
给定的绝对路径不能是压缩包中的路径
cn.hutool.core.io.FileUtil.isEmpty(java.io.File)
文件是否为空
目录：里面没有文件时为空 文件：文件大小为0时为空
cn.hutool.core.io.FileUtil.isNotEmpty(java.io.File)
文件是否为非空
目录：里面没有文件时为空 文件：文件大小为0时为空
cn.hutool.core.io.FileUtil.isDirEmpty(java.io.File)
目录是否为空
cn.hutool.core.io.FileUtil.loopFiles(java.lang.String, java.io.FileFilter)
递归遍历目录以及子目录中的所有文件
如果提供file为文件，直接返回过滤结果
cn.hutool.core.io.FileUtil.loopFiles(java.io.File, java.io.FileFilter)
递归遍历目录以及子目录中的所有文件
如果提供file为文件，直接返回过滤结果
cn.hutool.core.io.FileUtil.walkFiles(java.io.File, java.util.function.Consumer)
递归遍历目录并处理目录下的文件，可以处理目录或文件：
非目录则直接调用{@link Consumer}处理目录则递归调用此方法处理 cn.hutool.core.io.FileUtil.loopFiles(java.io.File, int, java.io.FileFilter)
递归遍历目录以及子目录中的所有文件
如果提供file为文件，直接返回过滤结果
cn.hutool.core.io.FileUtil.loopFiles(java.lang.String)
递归遍历目录以及子目录中的所有文件
cn.hutool.core.io.FileUtil.loopFiles(java.io.File)
递归遍历目录以及子目录中的所有文件
cn.hutool.core.io.FileUtil.listFileNames(java.lang.String)
获得指定目录下所有文件名
不会扫描子目录
cn.hutool.core.io.FileUtil.newFile(java.lang.String)
创建File对象，相当于调用new File()，不做任何处理
cn.hutool.core.io.FileUtil.file(java.lang.String)
创建File对象，自动识别相对或绝对路径，相对路径将自动从ClassPath下寻找
cn.hutool.core.io.FileUtil.file(java.lang.String, java.lang.String)
创建File对象
此方法会检查slip漏洞，漏洞说明见http://blog.nsfocus.net/zip-slip-2/
cn.hutool.core.io.FileUtil.file(java.io.File, java.lang.String)
创建File对象
根据的路径构建文件，在Win下直接构建，在Linux下拆分路径单独构建 此方法会检查slip漏洞，漏洞说明见http://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb214452d2c8e7bf02133b2319ad2cb2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/257/">«</a>
	<span class="pagination__item pagination__item--current">258/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/259/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>