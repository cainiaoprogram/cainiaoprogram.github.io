<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9156ab9113d1f8e41568120a631d479/" rel="bookmark">
			SELinux 相关学习资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://linux.vbird.org/linux_basic/0440processcontrol.php
http://www.ibm.com/developerworks/cn/linux/l-selinux/
正文来源：http://wiki.eri.ucsb.edu/sysadm/SELinux
Introduction SELinux is a set of extra security restrictions on top of the normal Linux security tools. It gives the systems administrator a finer grain of control than what the kernel typically provides. But SELinux can sometimes get in your way.
install the policy utils:
yum install policycoreutils Install the management GUI:
yum install policycoreutils-gui Then run it with:
ssh -Y root@host.name.edu /usr/bin/system-config-selinux &amp; and then under the Boolean tab, add what you need, like "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9156ab9113d1f8e41568120a631d479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e8543ed98d4b1e7a075938fb104883b/" rel="bookmark">
			博客搬家
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客园 http://www.cnblogs.com/nuysoft/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4e78938174576873a0d41686cc8ced1/" rel="bookmark">
			[原创] jQuery源码分析-04 选择器-Sizzle-设计思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作者：nuysoft/高云 QQ：47214707 Email：nuysoft@gmail.com 声明：本文为原创文章，如需转载，请注明来源并保留原文链接 让我们把工作原理讲的更简单一些，先不讲从右向左也不讲接口，先来分析下如果要执行一段选择器表达式，或者说设计一个简版选择器引擎，直觉上需要做些什么工作： 以div &gt; p为例来模拟这个过程，找div元素下的p元素： 1. 首先要能正确的将独立的块表达式从选择器表达式中分割出来，这是必须的，否则没法找div元素或p元素 2. 然后要能正确的执行块表达式，无论是left&gt;right或right&gt;left，首先要能找到div元素或p元素 块表达式可能不仅仅是简单的id/name/tag/class，也可能是它们之间的组合，甚至是与伪类的组合 比如div.red，查找具有指定.red的div，怎么实现这个过程呢？ 可以先找div数组，再在div数组上过滤.red；或者也可以先找*.red数组，再在*.red数组上找div 不管哪种方式，上边的过程都可以分解为：一个简单查找器和一个对查找结果过滤的过滤器 3. 单个块表达式搞定了，最后来处理块表达式之间的关系，DOM元素之间关系不外乎四种：父子，祖先，兄长，兄弟 就是找父亲或找儿子，找祖宗或找后代，找哥哥姐姐或找弟弟妹妹，关系不复杂，都有原生API支持 只要把2~3重复执行就可以完成（我感觉我的神经好粗大），选择器引擎的大致思路就是如此。 把上述过程与Sizzle对应着理解： 1. 分割器 chunker正则 2. 块查找 Sizzle.find( expr, context, isXML ) 块内过滤 Sizzle.filter( expr, set, inplace, not ) 3. 块间关系过滤 Expr.relative 这三个接口正是Sizzle实现的核心API。 当然上边的分析有事后诸葛亮的嫌疑，毕竟我已经看过Sizzle源码了， 但是当我试着用上边的过程来理解Sizzle的工作原理时，顿时豁然开朗，希望有所启发。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac285bd035d4fa41ab6fc836daaa2cb3/" rel="bookmark">
			锁存器、触发器、寄存器和缓冲器的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://blog.csdn.net/surgeddd/article/details/4683657
一、锁存器
锁存器（latch）---对脉冲电平敏感，在时钟脉冲的电平作用下改变状态
锁存器是电平触发的存储单元，数据存储的动作取决于输入时钟（或者使能）信号的电平值，仅当锁存器处于使能状态时，输出才会随着数据输入发生变化。
锁存器不同于触发器，它不在锁存数据时，输出端的信号随输入信号变化，就像信号通过一个缓冲器一样；一旦锁存信号起锁存作用，则数据被锁住，输入信号不起作用。锁存器也称为透明锁存器，指的是不锁存时输出对于输入是透明的。
锁存器（latch）：我听过的最多的就是它是电平触发的，呵呵。锁存器是电平触发的存储单元，数据存储的动作取决于输入时钟（或者使能）信号的电平值，当锁存器处于使能状态时，输出才会随着数据输入发生变化。（简单地说，它有两个输入，分别是一个有效信号EN,一个输入数据信号DATA_IN，它有一个输出Q，它的功能就是在EN有效的时候把DATA_IN的值传给Q，也就是锁存的过程）。
应用场合：数据有效迟后于时钟信号有效。这意味着时钟信号先到，数据信号后到。在某些运算器电路中有时采用锁存器作为数据暂存器。
缺点：时序分析较困难。
不要锁存器的原因有二：1、锁存器容易产生毛刺，2、锁存器在ASIC设计中应该说比ff要简单，但是在FPGA的资源中，大部分器件没有锁存器这个东西，所以需要用一个逻辑门和ff来组成锁存器，这样就浪费了资源。
优点：面积小。锁存器比FF快，所以用在地址锁存是很合适的，不过一定要保证所有的latch信号源的质量，锁存器在CPU设计中很常见，正是由于它的应用使得CPU的速度比外部IO部件逻辑快许多。latch完成同一个功能所需要的门较触发器要少，所以在asic中用的较多。
二、触发器
触发器（Flip-Flop，简写为 FF），也叫双稳态门，又称双稳态触发器。是一种可以在两种状态下运行的数字逻辑电路。触发器一直保持它们的状态，直到它们收到输入脉冲，又称为触发。当收到输入脉冲时，触发器输出就会根据规则改变状态，然后保持这种状态直到收到另一个触发。
触发器（flip-flops）电路相互关联，从而为使用内存芯片和微处理器的数字集成电路（IC）形成逻辑门。它们可用来存储一比特的数据。该数据可表示音序器的状态、计数器的价值、在计算机内存的ASCII字符或任何其他的信息。
有几种不同类型的触发器（flip-flops）电路具有指示器，如T（切换）、S-R（设置/重置）J-K（也可能称为Jack Kilby）和D（延迟）。典型的触发器包括零个、一个或两个输入信号，以及时钟信号和输出信号。一些触发器还包括一个重置当前输出的明确输入信号。第一个电子触发器是在1919年由W.H.Eccles和F.W.Jordan发明的。
触发器(flip-flop)---对脉冲边沿敏感，其状态只在时钟脉冲的上升沿或下降沿的瞬间改变。
T触发器(Toggle Flip-Flop，or Trigger Flip-Flop)设有一个输入和输出，当时钟频率由0转为1时，如果T和Q不相同时，其输出值会是1。输入端T为1的时候，输出端的状态Q发生反转；输入端T为0的时候，输出端的状态Q保持不变。把JK触发器的J和K输入点连接在一起，即构成一个T触发器。
应用场合：时钟有效迟后于数据有效。这意味着数据信号先建立，时钟信号后建立。在CP上升沿时刻打入到寄存器。
三、寄存器
寄存器（register）：用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果，它被广泛的用于各类数字系统和计算机中。其实寄存器就是一种常用的时序逻辑电路，但这种时序逻辑电路只包含存储电路。寄存器的存储电路是由锁存器或触发器构成的，因为一个锁存器或触发器能存储1位二进制数，所以由N个锁存器或触发器可以构成N位寄存器。 工程中的寄存器一般按计算机中字节的位数设计，所以一般有8位寄存器、16位寄存器等。
对寄存器中的触发器只要求它们具有置1、置0的功能即可，因而无论是用同步RS结构触发器，还是用主从结构或边沿触发结构的触发器，都可以组成寄存器。一般由D触发器组成，有公共输入/输出使能控制端和时钟，一般把使能控制端作为寄存器电路的选择信号，把时钟控制端作为数据输入控制信号。
寄存器的应用
1. 可以完成数据的并串、串并转换；
2.可以用做显示数据锁存器：许多设备需要显示计数器的记数值，以8421BCD码记数，以七段显示器显示，如果记数速度较高，人眼则无法辨认迅速变化的显示字符。在计数器和译码器之间加入一个锁存器，控制数据的显示时间是常用的方法。
3.用作缓冲器；
4. 组成计数器：移位寄存器可以组成移位型计数器，如环形或扭环形计数器。
四、移位寄存器
移位寄存器：具有移位功能的寄存器称为移位寄存器。
寄存器只有寄存数据或代码的功能。有时为了处理数据，需要将寄存器中的各位数据在移位控制信号作用下，依次向高位或向低位移动1位。移位寄存器按数码移动方向分类有左移，右移，可控制双向（可逆）移位寄存器；按数据输入端、输出方式分类有串行和并行之分。除了D边沿触发器构成移位寄存器外，还可以用诸如JK等触发器构成移位寄存器。
五、总线收发器/缓冲器
缓冲寄存器：又称缓冲器缓冲器(buffer)：多用在总线上，提高驱动能力、隔离前后级，缓冲器多半有三态输出功能。当负载不具有非选通输出为高阻特性时，将起到隔离作用；当总线的驱动能力不够驱动负载时，将起到驱动作用。由于缓冲器接在数据总线上，故必须具有三态输出功能。
它分输入缓冲器和输出缓冲器两种。前者的作用是将外设送来的数据暂时存放，以便处理器将它取走；后者的作用是用来暂时存放处理器送往外设的数据。有了数控缓冲器，就可以使高速工作的CPU与慢速工作的外设起协调和缓冲作用，实现数据传送的同步。
Buffer:缓冲区，一个用于在初速度不同步的设备或者优先级不同的设备之间传输数据的区域。通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。
缓冲器主要是计算机领域的称呼。具体实现上，缓冲器有用锁存器结构的电路来实现，也有用不带锁存结构的电路来实现。一般来说，当收发数据双方的工作速度匹配时，这里的缓冲器可以用不带锁存结构的电路来实现；而当收发数据双方的工作速度不匹配时，就要用带锁存结构的电路来实现了（否则会出现数据丢失）。
缓冲器在数字系统中用途很多：
（1）如果器件带负载能力有限，可加一级带驱动器的缓冲器；
（2）前后级间逻辑电平不同，可用电平转换器加以匹配；
（3）逻辑极性不同或需要将单性变量转换为互补变量时，加带反相缓冲器；（4）需要将缓变信号变为边沿陡峭信号时，加带施密特电路的缓冲器
（5）数据传输和处理中不同装置间温度和时间不同时，加一级缓冲器进行弥补等等。
锁存器与触发器的区别
锁存器和触发器是具有记忆功能的二进制存贮器件，是组成各种时序逻辑电路的基本器件之一。区别为：latch同其所有的输入信号相关，当输入信号变化时latch就变化，没有时钟端；flip-flop受时钟控制，只有在时钟触发时才采样当前的输入，产生输出。当然因为latch和flip-flop二者都是时序逻辑，所以输出不但同当前的输入相关还同上一时间的输出相关。
1、latch由电平触发，非同步控制。在使能信号有效时latch相当于通路，在使能信号无效时latch保持输出状态。DFF由时钟沿触发，同步控制。
2、latch对输入电平敏感，受布线延迟影响较大，很难保证输出没有毛刺产生；DFF则不易产生毛刺。
3、如果使用门电路来搭建latch和DFF，则latch消耗的门资源比DFF要少，这是latch比DFF优越的地方。所以，在ASIC中使用 latch的集成度比DFF高，但在FPGA中正好相反，因为FPGA中没有标准的latch单元，但有DFF单元，一个LATCH需要多个LE才能实现。latch是电平触发，相当于有一个使能端，且在激活之后（在使能电平的时候）相当于导线了，随输出而变化。在非使能状态下是保持原来的信号，这就可以看出和flip-flop的差别，其实很多时候latch是不能代替ff的。
4、latch将静态时序分析变得极为复杂。
5、目前latch只在极高端的电路中使用，如intel 的P4等CPU。 FPGA中有latch单元，寄存器单元就可以配置成latch单元，在xilinx v2p的手册将该单元配置成为register/latch单元，附件是xilinx半个slice的结构图。其它型号和厂家的FPGA没有去查证。——个人认为xilinx是能直接配的而altera或许比较麻烦，要几个LE才行，然而也非xilinx的器件每个slice都可以这样配置，altera的只有DDR接口中有专门的latch单元，一般也只有高速电路中会采用latch的设计。altera的LE是没有latch的结构的，又查了sp3和sp2e，别的不查了，手册上说支持这种配置。有关altera的表述wangdian说的对，altera的ff不能配置成latch，它使用查找表来实现latch。
一般的设计规则是：在绝大多数设计中避免产生latch。它会让您设计的时序完蛋，并且它的隐蔽性很强，非老手不能查出。latch最大的危害在于不能过滤毛刺。这对于下一级电路是极其危险的。所以，只要能用D触发器的地方，就不用latch。
有些地方没有时钟，也只能用latch了。比如现在用一个clk接到latch的使能端(假设是高电平使能),这样需要的setup时间，就是数据在时钟的下降沿之前需要的时间，但是如果是一个DFF，那么setup时间就是在时钟的上升沿需要的时间。这就说明如果数据晚于控制信号的情况下，只能用latch,这种情况就是，前面所提到的latch timing borrow。基本上相当于借了一个高电平时间。也就是说，latch借的时间也是有限的。
在if语句和case不全很容易产生latch，需要注意。VIA题目这两个代码哪个综合更容易产生latch：
代码1
always@(enable or ina or inb)
begin
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac285bd035d4fa41ab6fc836daaa2cb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d5e019fbec1ea243745d75b24d6b075/" rel="bookmark">
			51单片机控制数码管拉幕显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天晚上看到个题目，用51控制数码管显示123456789，做出拉幕效果，也就是循环显示。今天中午没事，就顺手写出来了。
代码如下：
#include&lt;reg51.h&gt;
#define uchar unsigned char
uchar smg[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0x88,0x83,0xC6,0xA1,0x86,0x8E,0xBF};
uchar a=1,b=2,c=3,d=4,e=5,f=6,g=7,h=8,tem,temp;
void delay1ms(uchar i) //延时1ms
{
while(i--)
{
uchar j;
for(j=0;j&lt;115;j++);
}
}
void InitDisplay();
void InitT0();
void main()
{
InitT0();
while(1)
{
InitDisplay();
//delay1ms(15); }
}
void InitT0() //定时器T0初始化
{
TH0=(65536-50000)/256;
TL0=(65536-50000)%256;
TMOD=0x01;
EA=1;
ET0=1;
TR0=1;
}
void InitDisplay() //开始显示12345678
{
P2=0xfe; //位选
P0=smg[a]; //段选
delay1ms(3); //延时太长，数码管显示很跳，太短数码管亮度太暗
P2=0xfd;
P0=smg[b];
delay1ms(3);
P2=0xfb;
P0=smg[c];
delay1ms(3);
P2=0xf7;
P0=smg[d];
delay1ms(3);
P2=0xef;
P0=smg[e];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d5e019fbec1ea243745d75b24d6b075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb2a3248cbd1fb9e9e734054bc5155bc/" rel="bookmark">
			客户端与服务器的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏客户端（client）类似于网站的前台页面，只是用于内容的显示与用户接口，除了一些配置文件外，不会保存任何实际数据。客户端启动后与服务器（server）建立联系，不间断的从server获取所需数据，数据的传输通过socket套接字完成，以发送接收数据包（packet）的形式交互，packet是个struct结构体，一般有命令id、长度、用户id以及其他成员变量组成。
packet作为数据包的基类，可以派生n多个子类，每个子类表示不同作用的数据包，比如packet_login、packet_move，通过命令id知道这个packet的作用，然后将packet基类指针转换为对应的子类指针，比如 packet_login* pData =(packet_login*)pPacket; 由于数据包的格式client与server端都需要，一般将数据包相关的文件用标准c++编写，client与server用同一份文件，修改起来方便。socket相关的基础代码写好后就不会再去修改，扩展功能时只需定义新的packet类型，工作重心是在业务逻辑的处理上，而非底层代码，因此不懂socket如何编写也无妨，稍微了解一下即可，关键还是c++的掌握理解。
“客户端模拟，服务器验证”，client存储一小部分数据，server存储所有数据，包括client当前状态的数据，一切动作都必须向server发出请求，得到回复后才能执行。用c++编写client生成的exe虽然是二进制文件，但在熟悉反编译的外挂高手看来，和看c++源代码并无太大区别，如同网站的javascript，不能相信client的安全性，一般在做一件事情时，client会先行验证是否满足条件，再请求server，server收到请求后会再次验证，只在client验证是危险的。举个例子，用户创建角色要限制名字在7个字符内，但只在client作了限制，当用户输入超过7个字符时，弹出个提示框报错后直接return，但没有在server端验证，对于普通用户来说没有问题，但若是外挂程序绕过了client的判断，确实会创建出很长的名字，这个时候就尴尬啦，总不能删号吧！做client时要假定代码会被外挂破解，这样才能防患于未然。
建立了client与server的交流接口后，剩下的就是两边各自的逻辑控制了，实际开发中最好一个人写server，一个人写client，这样不会混淆代码，但也有人手不足的时候，就1个人两边都写，这样确实节省了劳动力，提高了单人能力，却也容易滋生bug。
转载于:https://www.cnblogs.com/cats/archive/2011/11/10/2243800.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4dc2308a26207ea2ab912f326b690bb/" rel="bookmark">
			王小波致刘晓阳书信一封
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 阳公及阳夫人，你们好！ 收到晓阳大函，觉得阳公高论颇有哲理，心里的火气也去了大半。自从吃了西洋火腿（一腿把我踢出来），心里好不受用。我发现我有点像拳匪，宁挨毛竹板子，不挨文明棍。不过阳公说的有理，吃得苦中苦，方为人上人。我们背井离乡，到这儿来无非为了名利二字。既然为名为利，就说不上清高。既然不清高，就不配要面子。豁出面皮来撞就是了。这次中国现代史期中考试，有一道题是设想自己是一个清朝人，写下自己的历史。我自称是三湘子弟，随曾文正公打长毛，升到五品军功，不幸瞎字不识，长毛打完遣散时挟平时吃空额喝兵血的积蓄在苏州狂吃滥嫖，花光了流落于天津当苦力，抽上大烟。趁着乱民烧教堂，冲进去放枪，打死洋神父，按律当斩，又被曾国藩念在同乡份儿上放走了，溜到北京沿街叫化，最后饿死街头。当时我一边写一边想：我这辈子怎么也得比上辈子强，五品军功不在话下。不过我发现我变得十足小心眼儿，到现在老在低估教授会不会觉得我胡扯得过分扣我的分。 班长来信说， 中央关于工资改革的文件已经有了，基本工资40，职务工资，助工70，工程师130，高工200.还有工龄工资。我们出来一趟，好歹拿个MS、PhD回去，据说PhD再熬一年就给副教授。我觉得阳公的话有理，非混个人模狗样不可，就是苦死也抓挠个PhD，至不济也搞个MS，不成就跳太平洋自杀。 我现在觉得文科课无味之极，越念越无趣，想改行去念统计。阳公意欲如何？你觉得什么最吸引你？我劝你也别念文科，这鬼子说遛也难，别提什么答辩论文了。这学期写几个小paper，一提笔就愁肠百结，大有贾岛“两句三年得，一吟泪双流”的味道。在课堂上教授一看我，我就矮半截（怕他叫我发言）。这种痛苦太难忍受了。我们不如去念理工，好歹是凭咱们自己的功底，不是比那鬼子话。 说实在话，我是真想家。在中国，晚上一杯清茶，找几个人海聊一道，好不快乐也。在这儿没人和你聊。我这儿有个牧师每周一次交换语言，他又死气白赖劝我入教，你说讨厌不讨厌。想入研究生院要过TOFEL、GRE两关。我现在GRE就算挨过去了，只是TOFEL叫人心惊胆战，我想不考TOFEL混过去，不知道能否如愿。如果我混过去，阳公不妨也走这条路子。就凭阳公的能耐，GRE不愁混不过一千分。我至今还记得在235（大学宿舍号码——注）阳公解智力测验题，就凭那一手，GRE数学部分不愁混不下750分。我查资料Montana State UnivGRE有850~900分就要，资助也多，而且四季入学，四季给资助（那儿大概很荒，没人肯去）。我们要是在这里混不出来，可以鬼魂西行，到西部去，你我都去Montana，也不寂寞。咱们两个在一起，老婆们也放心，我觉得此计大妙。 今日看到一份留学生通讯，说明尼苏达、威斯康辛是州立大学中的佼佼者，在那儿念书一定比别处苦得多。当然，我们这等豪杰，去哈佛耶鲁斯坦福也满够格，不过鬼子文难念得紧，我们不妨避重就轻，何必挑那刀快的刀山上，钉子尖的钉板滚？等到你我羽翼已丰，再杀向名牌大校，阳公以为如何？当然，我们出去横行天下，老婆没准儿扯后腿，这倒是个难处。不过我们窝在家里坐吃山空怕也不是妙计。 班长说他正调农大，要搞食品加工，要问你明大食品系资助的情况。如你有暇，不妨给他去信。 山妻问两位好。 王小波2/27 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7371e8c9fbe55b22d84d6b0f3709971c/" rel="bookmark">
			[原创] jQuery源码分析-02正则表达式-RegExp-常用正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：nuysoft/JS攻城师/高云　QQ：47214707　EMail：nuysoft@gmail.com 声明：本文为原创文章，如需转载，请注明来源并保留原文链接。 后文预告：jQuery中的正则表达式分析 2.4	常用正则表达式 在网上找到一篇广为流传的文章《常用正则表达式》，逐一分析，不足地方进行补充和纠正。 常用的数字正则（严格匹配） 正则	含义 ^[1-9]\d*$	匹配正整数 ^-[1-9]\d*$	匹配负整数 ^-?[1-9]\d*$	匹配整数 ^[1-9]\d*|0$	匹配非负整数（正整数 + 0） ^-[1-9]\d*|0$	匹配非正整数（负整数 + 0） ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$	匹配正浮点数 ^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$	匹配负浮点数 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 匹配浮点数 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$	匹配非负浮点数（正浮点数 + 0） ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$	匹配非正浮点数（负浮点数 + 0） 常用字符串正则 正则	含义	补充 ^[A-Za-z]+$	匹配由26个英文字母组成的字符串	或 /^[a-z]+$/i ^[A-Z]+$	匹配由26个英文字母的大写组成的字符串	^[a-z]+$	匹配由26个英文字母的小写组成的字符串	^[A-Za-z0-9]+$	匹配由数字和26个英文字母组成的字符串	注意\w包含下划线_ ^\w+$	匹配由数字、26个英文字母或者下划线组成的字符串	常用数字正则和常用字符串正则，是最基本的正则应用，读者可以作为入门的练习，试试能不能快速的读懂其中的含义。 匹配中文字符 普遍使用的正则是[\u4e00-\u9fa5]，但这个范围并不完整。例如： /[\u4e00-\u9fa5]/.test( '⻏' ) // 测试部首⻏，返回false 根据Unicode 5.0版编码，要准确的判断一个中文字符要包括： 范围	含义	范围	含义 2E80-2EFF	CJK 部首补充	2F00-2FDF	康熙字典部首 3000-303F	CJK 符号和标点	31C0-31EF	CJK 笔画 3200-32FF	封闭式 CJK 文字和月份	3300-33FF	CJK 兼容 3400-4DBF	CJK 统一表意符号扩展 A	4DC0-4DFF	易经六十四卦符号 4E00-9FBF	CJK 统一表意符号	F900-FAFF	CJK 兼容象形文字 FE30-FE4F	CJK 兼容形式	FF00-FFEF	全角ASCII、全角标点 因此，正确的匹配中文字符正则表达式为： var rcjk = /[\u2E80-\u2EFF\u2F00-\u2FDF\u3000-\u303F\u31C0-\u31EF\u3200-\u32FF\u3300-\u33FF\u3400-\u4DBF\u4DC0-\u4DFF\u4E00-\u9FBF\uF900-\uFAFF\uFE30-\uFE4F\uFF00-\uFFEF]+/g; 如果不希望匹配标点、符号，在正则中去掉对应的范围即可： 3000-303F	CJK 符号和标点	FF00-FFEF	全角ASCII、全角标点 匹配双字节字符(包括汉字在内) [^\x00-\xff]，可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1），代码示例如下： console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7371e8c9fbe55b22d84d6b0f3709971c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c9b9365e8bb5b4722f3b13793b2bf52/" rel="bookmark">
			medusa命令介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随手写一下，medusa破解起来还是比较快的，首先我们看看帮助
root@perl-exploit:/pentest/exploits/framework3# medusa
Medusa v1.5 [http://www.foofus.net] (C) JoMo-Kun / Foofus Networks
ALERT: Host information must be supplied.
Syntax: Medusa [-h host|-H file] [-u username|-U file] [-p password|-P file] [-C file] -M module [OPT]
-h [TEXT] : Target hostname or IP address
-H [FILE] : File containing target hostnames or IP addresses
-u [TEXT] : Username to test
-U [FILE] : File containing usernames to test
-p [TEXT] : Password to test
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c9b9365e8bb5b4722f3b13793b2bf52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/869e3a5da2b2d85cbac355d00cd7900d/" rel="bookmark">
			IIS配置相关的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是win2003下IIS6服务器设置排错：
问题1：未启用父路径　症状举例：
Server.MapPath() 错误 'ASP 0175 : 80004005'
不允许的 Path 字符
/0709/dqyllhsub/news/OpenDatabase.asp，行 4
在 MapPath 的 Path 参数中不允许字符 '..'。　原因分析：
许多Web页面里要用到诸如../格式的语句（即回到上一层的页面，也就是父路径），而IIS6.0出于安全考虑，这一选项默认是关闭的。　解决方法：
：[开始]--[程序]--[管理工具]--[Internet信息服务管理器]，右击[网站] --[属性]--[主目录]－[配置]--应用程序选项，勾选“启用父路径”。确认刷新
问题2：ASP的Web扩展配置不当（同样适用于ASP.NET、CGI）　症状举例：
HTTP 错误 404 - 文件或目录未找到。或者该网页无法显示　原因分析：
在IIS6.0中新增了web程序扩展这一选项，你可以在其中对ASP、ASP.NET、CGI、IDC等程序进行允许或禁止，默认情况下ASP等程序是禁止的。　解决方法：
[开始]--[程序]--[管理工具]--[Internet信息服务管理器]，在服务器名下的“web服务扩展”的右窗口，单击active server pages -&gt; 单击[允许]。
问题3：身份认证配置不当　症状举例：
HTTP 错误 401.2 - 未经授权：访问由于服务器配置被拒绝。　原因分析：IIS 支持以下几种 Web 身份验证方法：
匿名身份验证
IIS 创建 IUSR_计算机名称 帐户（其中 计算机名称是正在运行 IIS 的服务器的名称），用来在匿名用户请求 Web 内容时对他们进行身份验证。此帐户授予用户本地登录权限。你可以将匿名用户访问重置为使用任何有效的 Windows 帐户。
基本身份验?
使用基本身份验证可限制对 NTFS 格式 Web 服务器上的文件的访问。使用基本身份验证，用户必须输入凭据，而且访问是基于用户 ID 的。用户 ID 和密码都以明文形式在网络间进行发送。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/869e3a5da2b2d85cbac355d00cd7900d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78bf0006aaa49e848ff6e00fcb7aabc7/" rel="bookmark">
			易康特征（ecognition）零散笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ecognition 玩了一年，依然很多问题，一者里面的一些概念比较晦涩，再者中文资料少算法操作参数多，三者跟同类软件相比，存在很多兼容性的问题，着实郁闷。前后做过sar分类，高分辨率机场识别和30米tm土地覆盖分类。有必要阐述一些关键性的东西，算给自己做一个学习总结吧。
一 关于对象：
应该说这是易康软件最突出的地方，虽然存在很多细节问题，就因为易康的面向对象参合一些复杂的算法使用，但是单这一点，同类软件在分类方面是无法比拟的。涉及到几个的概念：
影像集 ：
亦可以叫做影像数据集，定位角度不一样，包含了所有的数据，栅格、矢量、专题图、元数据，从集合的观点来看，它是我们一个工程用到的所有数据的集合。包含了最为基础的数据信息。
影像对象：
影像分割后的数据最小单元，一个对象单元包含了相同语义的像素集。对于导入的一幅图像而言，多尺度分割后产生的对象表现为不同的分辨率大小。他的上限是整个图像作为一个对象，下限是像素单元。影像对象有光谱、形状和层次结构特征，这些特征是作为定义分类影像对象的包含或排除参数的信息源来使用的。
对象特征：
对象特征是通过评价影像对象本身，以及影像对象层次结构中的嵌入计算出来的。当一个对象包含较大图像范围时，我们会明显感觉到软件在计算特征属性时有一定的延迟效果，它们由如下几项组成：
Customized 特征是用户创建的，表示一些自定义的对象属性特征，也相应地分为两种，算术特征和相关特征，如NDVI ,NDWI。
Type 特征是指一个影像对象空间位置。 Geometry 特征评价一个影像对象的形状。
Position 特征是指一个影像对象相对于场景的位置。
Texture 特征是基于层和形状的纹理值。也可以得到 Haralick 后的纹理。Haralick 就是灰度共生矩阵，几个方向的统计值。
Object Variables 是个别影像对象的局部变量。
Hierarchy 特征提供关于影像对象层次结构中一个影像对象的嵌入的信息。
Thematic attribute 特征是用来描述一个使用专题层提供信息的影像对象。他需要一个描述属性信息的字段选入。
类相关特征：
类相关特征依靠图像对象特征，将指定的类到影像对象层次结构中的影像对象的特征。对于父对象和子对象，这个位置被指定为分隔它们的层。对于邻接影像对象，该位置被
指定为空间距离。这两个距离都是可以编辑的。类相关特征由如下几项组成：
Relations to Neighbor Objects 特征用来描述一个影像对象与它旁边的其他影像对象的关系，而其他影像对象是与该影像对象相同的影像对象层上的相邻影像对象。相邻有两种：一种是直接相邻，还有一种是利用权重表示的相邻，但二者并不是直观意义上的相邻。
Relations to Sub-Objects特征用来描述一个影像对象与它旁边的其他影像对象的关系，这些其他影像对象在影像对象层次结构中的一个较低（下层影像层）的影像对象层上。
Relations to Superobjects 特征与Relations to Sub-Objects相似，描述与父层的对象特征关系。
Relations to Classification 特征是用来找出一个影像对象当前或潜在分类的。
关联对象特征：
关联对象特征是评价关联对象来计算的。
场景特征：
场景特征返回整个场景或地图的属性。它们是全局特征，因为它们与个别的影像对象无关，其组成如下：
Variables是在一个工程中只出现一次的全局变量。它们是独立于当前影像对象的。
Class-Related场景特征提供每个地图给定类别的所有影像对象的信息。
Scene-Related特征提供关于场景的信息。
进程相关特征：
一个进程相关特征是指在进程层次结构中，一个影像对象与一个给定进程距离的父进程对象（parent process object-PPO）的关系。它是基于开发规则集提出来的，与类相关特征具有相似性，但是这个表现得更加局部，通常使用的进程相关特征包括：
Border to PPO：一个影像对象与它的父进程对象之间的共有的绝对边界。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78bf0006aaa49e848ff6e00fcb7aabc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/083efad7b6e504e9461f3643b4844819/" rel="bookmark">
			一步一步写算法（之hash表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【 声明：版权所有，欢迎转载，请勿用于商业用途。 联系信箱：feixiaoxing @163.com】
hash表，有时候也被称为散列表。个人认为，hash表是介于链表和二叉树之间的一种中间结构。链表使用十分方便，但是数据查找十分麻烦；二叉树中的数据严格有序，但是这是以多一个指针作为代价的结果。hash表既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。
打个比方来说，所有的数据就好像许许多多的书本。如果这些书本是一本一本堆起来的，就好像链表或者线性表一样，整个数据会显得非常的无序和凌乱，在你找到自己需要的书之前，你要经历许多的查询过程；而如果你对所有的书本进行编号，并且把这些书本按次序进行排列的话，那么如果你要寻找的书本编号是n，那么经过二分查找，你很快就会找到自己需要的书本；但是如果你每一个种类的书本都不是很多，那么你就可以对这些书本进行归类，哪些是文学类，哪些是艺术类，哪些是工科的，哪些是理科的，你只要对这些书本进行简单的归类，那么寻找一本书也会变得非常简单，比如说如果你要找的书是计算机方面的书，那么你就会到工科一类当中去寻找，这样查找起来也会显得麻烦。
不知道这样举例你清楚了没有，上面提到的归类方法其实就是hash表的本质。下面我们可以写一个简单的hash操作代码。
a）定义hash表和基本数据节点
typedef struct _NODE { int data; struct _NODE* next; }NODE; typedef struct _HASH_TABLE { NODE* value[10]; }HASH_TABLE; b）创建hash表 HASH_TABLE* create_hash_table() { HASH_TABLE* pHashTbl = (HASH_TABLE*)malloc(sizeof(HASH_TABLE)); memset(pHashTbl, 0, sizeof(HASH_TABLE)); return pHashTbl; } c）在hash表当中寻找数据 NODE* find_data_in_hash(HASH_TABLE* pHashTbl, int data) { NODE* pNode; if(NULL == pHashTbl) return NULL; if(NULL == (pNode = pHashTbl-&gt;value[data % 10])) return NULL; while(pNode){ if(data == pNode-&gt;data) return pNode; pNode = pNode-&gt;next; } return NULL; } d）在hash表当中插入数据 STATUS insert_data_into_hash(HASH_TABLE* pHashTbl, int data) { NODE* pNode; if(NULL == pHashTbl) return FALSE; if(NULL == pHashTbl-&gt;value[data % 10]){ pNode = (NODE*)malloc(sizeof(NODE)); memset(pNode, 0, sizeof(NODE)); pNode-&gt;data = data; pHashTbl-&gt;value[data % 10] = pNode; return TRUE; } if(NULL !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/083efad7b6e504e9461f3643b4844819/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc58029788735f8420100a33af2f327b/" rel="bookmark">
			不能实例化抽象类 是什么原因？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 抽象类是残缺不全的类，里面的抽象方法没有具体的代码，里面的抽象方法就是被子类重写用的。一个残缺不全的类怎么可以制造出个实例呢，只有子类重写了抽象方法，把抽象的方法具体化了，才可以真真正正造出个东西来。 抽象类和接口可以想像为概念化的类,不能实现,只能被继承,里面定义的是一些将要实现的东西(抽象类中可以有实现的方法,接口则不能),而那些将要实现的东西一般是没有实现的方法的签名,所以实例化抽象类或接口是没有意义的. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/962deaf112f73abea9af74204247bb84/" rel="bookmark">
			解决：发生系统错误 5；拒绝访问！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在dos下运行net命令或其它！提示发生系统错误 5；拒绝访问！ 这是因为权限不够的问题。
首先，不要以为用admin account登录系统后，用ctry + R --&gt; cmd，就有管理权限；
此时，只是user的身份，而不是admin。
用管理员身份来运行cmd：
1.在开始菜单的搜索框输入cmd，然后右键单击，并选择以管理员身份运行！
另外，
2.右键单击cmd选择“附到【开始】菜单(U)”;这是就可以到开始菜单上找到cmd了， 3.右击选择属性，选择快捷方式，再选择高级，在选择以管理员身份运行，再单击确定即可！ 以后只要打开开始菜单单击上面的快捷方式就可以以管理员的身份运行cmd了！ 以后只要打开开始菜单单击上面的快捷方式就可以以管理员的身份运行cmd了！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09fb81c9d55eb356be68461694abf479/" rel="bookmark">
			小谈linux下实际用户ID，有效用户ID和设置用户ID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前对linux下实际用户ID，有效用户ID和设置用户ID不是很了解，今天翻书看好又看到了，就整个时间给再了解下。
这几个ID进行概念性如下;
实际用户ID（RUID)：用于在系统中标识一个用户是谁，当用户使用用户名和密码成功登录后一个UNIX系统后就唯一确定了他的RUID.也有人这么说也许会比较准确：就是该进程的所有者，执行者;
有效用户ID（EUID）：用于系统决定用户对系统资源的访问权限，通常情况下等于RUID；
设置用户ID（SUID）：从程序自身来说用于对外权限的开放。跟RUID及EUID是用一个用户绑定不同，它是跟文件而不是跟用户绑定。
上面这三个用户ID都是相对于进程来说的。记住这点的前提上有助于我们对它们的理解。
浏览了网上的一些文章，谈到理解它们很好的一个例子就是谈谈passwd文件。
我们知道/etc/passwd程序是用来修改用户的密码的，一般来说只用root用户才能修改用户密码，但是我们发现用户是可以修改自身的密码： linshuqiang@linshuqiang-laptop:~$ passwd
更改 linshuqiang 的密码。
（当前）UNIX 密码： 因为passwd文件设置了set－usr－ID位且文件的所有者是root，所有用户在执行passwd时，用户就具有root的权力，这样就能去执行。passwd文件的属性如下：
linshuqiang@linshuqiang-laptop:~$ ll /usr/bin/passwd -r-s--x--x 1 root root 37140 2010-01-27 01:09 /usr/bin/passwd* 从上面我们可以看出文件属性第二个有个s，这个就是该文件set－usr－ID位。如果该文件没有设计ser－usr－ID位，那么在普通用户下是不能修改密码的，因为在执行的时候就没有root权限。
在root下改变passwd文件的权限：
linshuqiang@ubuntu:~$ sudo su root@ubuntu:/home/linshuqiang# chmod u-s /usr/bin/passwd root@ubuntu:/home/linshuqiang# ll /usr/bin/passwd -rwxr-xr-x 1 root root 37140 2011-02-15 06:11 /usr/bin/passwd* 通过chmod改变文件的权限后，我们可以看到 /usr/bin/passwd文件少了set-usr-ID位，那么现在我们在普通用户下来执行passwd看看效果如何？ linshuqiang@ubuntu:~$ passwd 更改 linshuqiang 的密码。 （当前）UNIX 密码： passwd：认证令牌操作错误 passwd: password unchanged 就出现了上述的认证令牌操作错误，原因是我们把set-usr-ID位给改过了，普通用户在执行passwd文件的时候，没有set-usr-ID位，那么有效用户就不能切换到超级用户，所以不能改。 上面的例子应该很容易的让我们理解到三个用户之间的区别和关系吧？本人也是刚刚接触linxu不久，这些都是在学习的基础上小结出来的，如有错，望指出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5527832ce0f23b60aa34fbb4312f48a6/" rel="bookmark">
			一步一步写算法（之单向链表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【 声明：版权所有，欢迎转载，请勿用于商业用途。 联系信箱：feixiaoxing @163.com】
有的时候，处于内存中的数据并不是连续的。那么这时候，我们就需要在数据结构中添加一个属性，这个属性会记录下面一个数据的地址。有了这个地址之后，所有的数据就像一条链子一样串起来了，那么这个地址属性就起到了穿线连结的作用。
相比较普通的线性结构，链表结构的优势是什么呢？我们可以总结一下：
（1）单个节点创建非常方便，普通的线性内存通常在创建的时候就需要设定数据的大小
（2）节点的删除非常方便，不需要像线性结构那样移动剩下的数据
（3）节点的访问方便，可以通过循环或者递归的方法访问到任意数据，但是平均的访问效率低于线性表
那么在实际应用中，链表是怎么设计的呢？我们可以以int数据类型作为基础，设计一个简单的int链表：
（1）设计链表的数据结构
typedef struct _LINK_NODE { int data; struct _LINK_NODE* next; }LINK_NODE; （2）创建链表 LINK_NODE* alloca_node(int value) { LINK_NODE* pLinkNode = NULL; pLinkNode = (LINK_NODE*)malloc(sizeof(LINK_NODE)); pLinkNode-&gt;data = value; pLinkNode-&gt;next = NULL; return pLinkNode; } （3）删除链表
void delete_node(LINK_NODE** pNode) { LINK_NODE** pNext; if(NULL == pNode || NULL == *pNode) return ; pNext = &amp;(*pNode)-&gt;next; free(*pNode); delete_node(pNext);	} （4）链表插入数据 STATUS _add_data(LINK_NODE** pNode, LINK_NODE* pDataNode) { if(NULL == *pNode){ *pNode = pDataNode; return TRUE; } return _add_data(&amp;(*pNode)-&gt;next, pDataNode); } STATUS add_data(const LINK_NODE** pNode, int value) { LINK_NODE* pDataNode; if(NULL == *pNode) return FALSE; pDataNode = alloca_node(value); assert(NULL !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5527832ce0f23b60aa34fbb4312f48a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f402b3e5f2e7e19af02e06efe876947f/" rel="bookmark">
			Workbench3.0-vxworks6.6仿真测试和调试指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VxWorks5.5只能创建静态库（.a），VxWorks6.0之后增加了动态链接库（.so）的功能，方便了多进程使用动态库。本文继承win32和linux编程入门的一贯风格，通过简单的动态库生成步骤，并编写RTP程序进行测试，让您初步认识VxWorks6.6强大的功能，同时也让我们注意到VxWorks6.6比VxWorks5.5在使用要复杂很多。我相信通过这些简单的编程知识点，您基本掌握了VxWorks6.6调试技巧，让我们后来者不必在调试过程中去探索黑暗。本文基本使用图形来描述操作流程：一副图低得上千言万语了。 VxWorks6.0之后版本新增引入了具有完全保护功能的实时进程Real Time Process简称 RTP，首次完美的解决了内核保护与实时性和确定性之间的矛盾。用户可以根据需要动态的创建／删除 RTP实时保护进程或仅将一部分程序运行在 RTP实时保护进程中。RTP实时进程可以随时动态加载运行外部程序。每个RTP进程完全独立，程序在 RTP进程内部出现的任何错误都被限制在RTP进程内部，删除RTP实时进程时自动释放所有资源。RTP与其他多进程OS不同的是，VxWorks的RTP实时进程具有完全的静态确定性，提供保护功能的同时提供最高的实时响应确定性和快速性，并且可以提供完全的存储错误检测和存储报告功能。动态链接库和共享数据区功能也同时提供。RTP实时保护进程与VWorks原有的更高性能实时任务一起构成保护性和实时性兼备的超级设备平台. 动态库生成
1、选择工程工作路径
2、正常打开的初始界面
一般情况下左下角出现相似的界面，说明您的VxWorks6.6系统基本安装正常。需要注意的是系统安装了Tornado2.2会与WorkBench3.0冲突，最好要把Tornado2.2卸掉，操作系统Win7不支持两者的安装。
3、创建动态库工程
4、动态库名称
5、编译选择
这里我们选择diab工具编译，gnu编译工具在调试c++中的 Class类有点问题，具体原因我没有去研究。
6、其余默认，按完成即可
7、添加inc和src文件夹
A、Inc包含demo.h和stdafx.h；
B、src包含demo.cpp和stdafx.cpp。
stdafx.h// stdafx.h : include file for standard system include files,// or project specific include files that are used frequently, but// are changed infrequently//#if !defined(AFX_STDAFX_H__E5CE9468_AAF9_46A6_979B_9C125F6E9D00__INCLUDED_)#define AFX_STDAFX_H__E5CE9468_AAF9_46A6_979B_9C125F6E9D00__INCLUDED_#if _MSC_VER &gt; 1000#pragma once#endif // _MSC_VER &gt; 1000#define WIN32_LEAN_AND_MEAN	// Exclude rarely-used stuff from Windows headers#include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f402b3e5f2e7e19af02e06efe876947f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c08201cd18869113334246fdc574b2/" rel="bookmark">
			软件系统性能设计之一总述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件性能是设计软件架构的重要部分，若性能设计的不好，其他方面再好也是烂系统一个，即所谓的系统设计短板。
软件性能指标一般包括一下6个方面：
1：数据库性能设计
2：缓存设计
3：负载均衡设计
4：多线程设计
5：文件操作设计
6：代码性能设计
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32682d3905d6b3e15edd0d9567612888/" rel="bookmark">
			单次自动对焦（ONE SHOT）、人工智能自动对焦（AI FOCUS）、人工智能伺服自动对焦（AI SERVO）的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 单次自动对焦（one shot）是最为常用的。这种模式的工作过程通过半按快门来启动，在焦点未对准确前，对焦过程一直在继续。一旦处理器认为焦点准确以后，只要将快门完全按下就完成了一次拍摄过程，同时自动对焦系统停止工作。这种对焦完毕后焦点会自动锁定，只要半按快门不放开，就可以不改变焦点重新构图，操作非常简便。单次自动对焦适合拍摄静止不动的物体，如静物、风景、微距、静态人像等。如果在单次对焦完成，出现合焦提示之后，按下快门之前被摄物体又发生了移动，用单次对焦方式就很可能得到一张焦点不实的图片。由于单次自动对焦方式不能很好地“跟踪”运动中的物体，因此也就产生了连续自动对焦方式。与单次自动对焦不同的是，连续自动对焦在处理器判断对焦准确后，自动对焦系统仍会继续工作，焦点也没有被锁定。目的在于当被摄体移动时，自动对焦系统能够实时根据焦点的变化驱动镜头马达持续对焦，从而使被摄物一直保持清晰状态。当然，相机的对焦框也要持续对准被摄体，这样在完全按下快门的时候，就不用担心被摄物对焦不准确的问题了。 连续自动对焦多用在处于运动中的物体拍摄，比如体育比赛中拍摄运动员、玩耍中的儿童年、新闻发布会中拍摄发言人以及捕捉运动中的动物精彩瞬间等。并且，结合高速的连拍功能就可以轻松地拍摄出一组动态照片。连续自动对焦可连续跟踪运动主体从理论上说，既然有了单次自动对焦和连续自动对焦两种方式，就应该能够满足各种不同拍摄场景的需要了。但是在实拍过程中还是会发现一些问题，比如长时间连续自动对焦的耗电量比较大。另外，在拍摄一个可能随时从静止状态转换为运动状态的物体时，或者反之，以上两种模式看来都不适合。智能自动对焦是一种可根据被摄主体的状态(静止或运动)，相机自动选择对焦模式，这种将单次自动对焦和连续自动对焦结合起来的方式，折中地解决了上面提到的问题，因此更适合在被摄物体动静状态不定的情况下使用。 需要注意的是，前两种提到的自动对焦方式是最普遍、最常用的，相机厂商基本上都按照上述名称命名。而第三种提到的方式无论各家起什么样的名字，工作原理基本上是相同的。佳能称为“人工智能伺服对焦”，尼康称为“最近主体先决的动态自动对焦”，索尼和美能达称为“自动切换对焦”，叫法五花八门，其实都是一回事。如果你对自己的对焦把控能力不自信，建议选第三种。只要你对准焦点半按快门不放，镜头就始终在自动追踪你选择的焦点对焦。哪怕焦点有一点点移动，你就会感觉到镜头在转动，那是在自动追焦。如果你的镜头使用的是超声波马达，这种对焦速度还是相当快的。智能自动对焦可根据被摄主体的状态(静止或运动)，自动选择对焦模式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/249a566bcf2f1d52a99daa041d97a39e/" rel="bookmark">
			关于会议论文会后投期刊，及论文版权的一些注意事项。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（这是个常见的问题，我们也遇到过很多次，看了一些材料（不同copyright里的详细内容）。这个问题实际上不好回答，下面只简单说一下，也整理一下我以前的回贴。供参考。大家有什么疑问，可以提出来，了解的话，我尽量给予回答。） 总的说来，会议主要目的是为了交流，对版权要求不是很严（否则也没有太多人将好文章投给会议了）。 通过会议的交流与讨论，修改扩充文章，作者一般都可以再投到杂志（发表）。很多会议也鼓励这么做，不少杂志也认为那样投过来的文章还比较好（有些会后的special issue也带有这个目的）。IEEE版权上写了（看下面最后一项），将内容放在新出版物里发表，作者可以，但第三方不可以。 http://www.ieee.org/we ... ightmain.html RETAINED RIGHTS/TERMS AND CONDITIONS 1. Authors/employers retain all proprietary rights in any process, procedure, or article of manufacture described in the Work. ... 6. Although authors are permitted to re-use all or portions of the Work in other works, this does not include granting third-party requests for reprinting, republishing, or other types of re-use. The IEEE Intellectual Property Rights office must handle all such third-party requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/249a566bcf2f1d52a99daa041d97a39e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/959d6ce193a3a26403c5c4426bab165e/" rel="bookmark">
			windows快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ctrl+shift+Esc 任务管理器 单独按Windows：显示或隐藏 “开始”功能表 Windows+BREAK：显示“系统属性” 对话框 Windows+D：显示桌面 Windows+M：最小化所有窗口 Windows+Shift+M：还原最小化的窗口 Windows+E：开启“资源管理器” Windows+F：查找文件或文件夹 Windows+CTRL+ F：查找电脑 Windows+F1：显示 Windows “帮助” Windows+R：开启“运行” 对话框 Windows+U：开启 “公用程序管理器” Windows+L：切换使用者（Windows XP新功能） Ctrl快捷键 Ctrl+S 保存 Ctrl+W 关闭程序 Ctrl+N 新建 Ctrl+O 打开 Ctrl+Z 撤销 Ctrl+F 查找 Ctrl+X 剪切 Ctrl+C 复制 Ctrl+V 粘贴 Ctrl+A 全选 Ctrl+[ 缩小文字 Ctrl+] 放大文字 Ctrl+B 粗体 Ctrl+I 斜体 Ctrl+U 下划线 Ctrl+Shift 输入法切换 Ctrl+空格 中英文切换 Ctrl+回车 QQ号中发送信息 Ctrl+Home 光标快速移到文件头 Ctrl+End 光标快速移到文件尾 Ctrl+Esc 显示开始菜单 Ctrl+Shift+&lt; 快速缩小文字 Ctrl+Shift+&gt; 快速放大文字 Ctrl+F5 在IE中强行刷新 Ctrl+拖动文件 复制文件 Ctrl+Backspace 启动\关闭输入法 拖动文件时按住Ctrl+Shift 创建快捷方式 Alt快捷键 Alt+F4 关闭当前程序 Alt+空格+C 关闭窗口 Alt+空格+N 最小化当前窗口 Alt+空格+R 恢复最小化窗口 Alt+空格+X 最大化当前窗口 Alt+空格+M 移动窗口 Alt+空格+S 改变窗口大小 Alt+Tab 两个程序交换 Alt+255 QQ号中输入无名人 Alt+F 打开文件菜单 Alt+V 打开视图菜单 Alt+E 打开编辑菜单 Alt+I 打开插入菜单 Alt+O 打开格式菜单 Alt+T 打开工具菜单 Alt+A 打开表格菜单 Alt+W 打开窗口菜单 Alt+H 打开帮助菜单 Alt+回车 查看文件属性 Alt+双击文件 查看文件属性 Alt+X 关闭C语言 Shift快捷键 Shift+空格 半\全角切换 Shift+右击 右菜单打开方式 Shift+F10 选中文件的右菜单 Shift+多级文件 全部关闭 Shift+Del 直接删除文件 Shift+＾ 处在中文标点符号半角在智能ABC中省曰号 Shift+\ 处在中文标点符号半角在智能ABC中顿号 快捷键 常规键盘快捷键 Ctrl + C 复制。 Ctrl + X 剪切。 Ctrl + V 粘贴。 Ctrl + Z 撤消。 DELETE 删除。 Shift + Delete 永久删除所选项，而不将它放到“回收站”中。 拖动某一项时按 CTRL 复制所选项。 拖动某一项时按 CTRL + SHIFT 创建所选项目的快捷键。 F2 重新命名所选项目。 CTRL + 向右键 将插入点移动到下一个单词的起始处。 CTRL + 向左键 将插入点移动到前一个单词的起始处。 CTRL + 向下键 将插入点移动到下一段落的起始处。 CTRL + 向上键 将插入点移动到前一段落的起始处。 CTRL + SHIFT + 任何箭头键 突出显示一块文本。 SHIFT + 任何箭头键 在窗口或桌面上选择多项，或者选中文档中的文本。 Ctrl + A 选中全部内容。 F3 搜索文件或文件夹。 Alt + Enter 查看所选项目的属性。 Alt + F4 关闭当前项目或者退出当前程序。 ALT + Enter 显示所选对象的属性。 Alt + 空格键 为当前窗口打开快捷菜单。 Ctrl + F4 在允许同时打开多个文档的程序中关闭当前文档。 Alt + Tab 在打开的项目之间切换。 Alt + Esc 以项目打开的顺序循环切换。 F6 在窗口或桌面上循环切换屏幕元素。 F4 显示“我的电脑”和“Windows 资源管理器”中的“地址”栏列表。 Shift + F10 显示所选项的快捷菜单。 Alt + 空格键 显示当前窗口的“系统”菜单。 Ctrl + Esc 显示“开始”菜单。 ALT + 菜单名中带下划线的字母 显示相应的菜单。 在打开的菜单上显示的命令名称中带有下划线的字母 执行相应的命令。 F10 激活当前程序中的菜单条。 右箭头键 打开右边的下一菜单或者打开子菜单。 左箭头键 打开左边的下一菜单或者关闭子菜单。 F5 刷新当前窗口。 BackSpace 在“我的电脑”或“Windows 资源管理器”中查看上一层文件夹。 Esc 取消当前任务。 将光盘插入到 CD-ROM 驱动器时按 SHIFT 键 阻止光盘自动播放 对话框快捷键 Ctrl + Tab 在选项卡之间向前移动。 Ctrl + Shift +Tab 在选项卡之间向后移动。 Tab 在选项之间向前移动。 Shift + Tab 在选项之间向后移动。 ALT + 带下划线的字母 执行相应的命令或选中相应的选项。 Enter 执行活选项动或按钮所对应的命令。 空格键 如果活选项动是复选框，则选中或清除该复选框。 箭头键 活选项动是一组选项按钮时，请选中某个按钮。 F1 显示帮助。 F4 显示当前列表中的项目。 BackSpace 如果在“另存为”或“打开”对话框中选中了某个文件夹，则打开上一级文件夹。 自然键盘快捷键 在“Microsoft 自然键盘”或包含 Windows 徽标键() 和“应用程序”键() 的其他兼容键盘中，您可以使用以下快捷键。 请按 目的 显示或隐藏“开始”菜单。 win+ BREAK 显示“系统属性”对话框。 + D 显示桌面。 + M 最小化所有窗口。 + Shift + M 还原最小化的窗口。 + E 打开“我的电脑”。 + F 搜索文件或文件夹。 CTRL+ + F 搜索计算机。 + F1 显示 Windows 帮助。 + L 如果连接到网络域，则锁定您的计算机，或者如果没有连接到网络域，则切换用户。 + R 打开“运行”对话框。 显示所选项的快捷菜单。 + U 打开“工具管理器”。 辅助键盘快捷键 请按 目的 右侧 SHIFT 键八秒钟 切换“筛选键”的开和关。 左边的 ALT + 左边的 SHIFT + PRINT SCREEN 切换“高对比度”的开和关。 左边的 ALT + 左边的 SHIFT + NUM LOCK 切换“鼠标键”的开和关。 Shift 键五次 切换“粘滞键”的开和关。 Num Lock 键五秒钟 切换“切换键”的开和关。 + U 打开“工具管理器”。 “Windows 资源管理器”键盘快捷键 请按 目的 END 显示当前窗口的底端。 主页 显示当前窗口的顶端。 NUM LOCK + 数字键盘的星号 (*) 显示所选文件夹的所有子文件夹。 NUM LOCK + 数字键盘的加号 (+) 显示所选文件夹的内容。 NUM LOCK + 数字键盘的减号 (-) 折叠所选的文件夹。 左箭头键 当前所选项 处于展开状态时折叠该项，或选定其父文件夹。 右箭头键 当前所选项处于折叠状态时展开该项，或选定第一个子文件夹 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b6d7d4a07b1e20e5bf21718bfccc19/" rel="bookmark">
			正则表达式 2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例
&lt;script&gt; alert(/[^\x00-\xff]/g.test( 'abc ')) alert(/[^\x00-\xff]/g.test( '表达 ')) &lt;/script&gt;
正则表达式对象 本对象包含正则表达式模式以及表明如何应用模式的标志。 语法 1 re = /pattern/[flags] 语法 2 re = new RegExp( "pattern ",[ "flags "]) 参数 re 必选项。将要赋值为正则表达式模式的变量名。 Pattern 必选项。要使用的正则表达式模式。如果使用语法 1，用 "/ " 字符分隔模式。如果用语法 2，用引号将模式引起来。 flags 可选项。如果使用语法 2 要用引号将 flag 引起来。标志可以组合使用，可用的有： g （全文查找出现的所有 pattern） i （忽略大小写） m （多行查找） [a-z] 字符范围。匹配指定范围内的任意字符。例如， '[a-z] ' 可以匹配 'a ' 到 'z ' 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如， '[^a-z] ' 可以匹配任何不在 'a ' 到 'z ' 范围内的任意字符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17b6d7d4a07b1e20e5bf21718bfccc19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e7cf790a6e2d6579c52616d40e9bfc/" rel="bookmark">
			虚拟机virtualbox中挂载新硬盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在virtualbox中装好Ubuntu后，发现硬盘空间太小，怎样才能增加硬盘容量？那就是再建一个硬盘：
1. 添加新硬盘
设置 -&gt; Storage -&gt; SATA控制器-&gt;右击，选择&amp;ldquo;添加虚拟硬盘&amp;rdquo;
然后，根据需求创建合适的硬盘
2. 重启虚拟机
查看现有系统的磁盘空间
sudo fdisk -l
可看到新加的虚拟硬盘，一般名为：Disk /dev/sdb
3. 给新加的硬盘分区
fdisk /dev/sdb
键入m,可看到帮助信息
command (m for help):m 增加新分区
command (m for help):n 选择基本分区，输入：p
建一个分区
Partition number(1-4):1 回车
First cylinder (1-15908,default 1):Enter
写入并退出
command (m for help):w
4. 格式化磁盘分区
用ext4格式对/dev/sdb1进入格式化
sudo mkfs.ext4 /dev/sdb1
5. 挂载分区
创建新的挂载点
sudo mkdir /work
将新磁盘分区挂载到/work目录下
sudo mount -t ext4 /dev/sdb1 /work
查看挂载
df -h
可以看到新加的硬盘：/dev/sdb1
6. 开机自动挂载
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39e7cf790a6e2d6579c52616d40e9bfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05b8a968d86d1db995e9260e3bad5986/" rel="bookmark">
			CentOS 下配置PPTP ×××服务器文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、利用rpm包进行安装 1.准备 root@CentOS /root # vim /etc/sysctl.conf net.ipv4.ip_forward = 1 //将0置为1，打开IP转发功能 root@CentOS /root # /sbin/sysctl –p //使其立即生效 root@CentOS /root # modprobe ppp-compress-18 &amp;&amp; echo ok ok //确认MPPE补丁是否有安装成功，如OK继续下一步 root@CentOS /root # strings ''/usr/sbin/pppd''|grep -i mppe|wc –lines 42 //检查PPP是否支持MPPE，输出大于等于“30”则表示支持 以上如果不成功，则分别下载以下软件进行安装或升级 http://poptop.sourceforge.net/yum/stable/rhel5/i386/dkms-2.0.17.5-1.noarch.rpm ftp://ftp.ntua.gr/pub/net/poptop/mppe%20module%20builder/kernel_ppp_mppe-1.0.2%20dkms-2.0.6/kernel_ppp_mppe-1.0.2-3dkms.noarch.rpm http://poptop.sourceforge.net/yum/stable/rhel5/i386/ppp-2.4.4-14.1.rhel5.i386.rpm
官方网站: http://poptop.sourceforge.net/ http://poptop.sourceforge.net/yum/ http://poptop.sourceforge.net/yum/stable/rhel5/i386/pptpd-1.3.4-2.rhel5.i386.rpm
root@CentOS /root # wget http://poptop.sourceforge.net/yum/stable/rhel5/i386/pptpd-1.3.4-2.rhel5.i386.rpm root@CentOS /root # rpm -ivh pptpd-1.3.4-2.rhel5.i386.rpm root@CentOS /root # rpm -ql pptpd /etc/ppp/options.pptpd //选项配置文件 /etc/pptpd.conf //主配置文件 /etc/rc.d/init.d/pptpd /usr/bin/***stats.pl /usr/bin/***user /usr/lib/pptpd/pptpd-logwtmp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05b8a968d86d1db995e9260e3bad5986/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddb032899d6061cd37306a0714eefb0c/" rel="bookmark">
			希尔排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /*
================================================
功能：希尔排序
输入：数组名称（也就是数组首地址）、数组中元素个数
================================================
*/
/*
====================================================
算法思想简单描述：
在直接插入排序算法中，每次插入一个数，使有序序列只增加1个节点，
并且对插入下一个数没有提供任何帮助。如果比较相隔较远距离（称为
增量）的数，使得数移动时能跨过多个元素，则进行一次比较就可能消除
多个元素交换。D.L.shell于1959年在以他名字命名的排序算法中实现
了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中
记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量
对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成
一组，排序完成。
下面的函数是一个希尔排序算法的一个实现，初次取序列的一半为增量，
以后每次减半，直到增量为1。
希尔排序是不稳定的。
=====================================================
*/
void shell_sort(int *a,int n){
int d,i,t,j;
for(d=n/2;d&gt;0;d=d/2)
{
for(i=d;i&lt;n;i++)
{
t=*(a+i);
for(j=i-d;j&gt;=0&amp;&amp;*(a+j)&gt;t;j-=d){
*(a+j+d)=*(a+j);
}
*(a+j+d)=t;
}
}
}
测试：
#include&lt;stdio.h&gt;
int main(){
int a[8]={9,2,7,3,6,5,10,1};
shell_sort(a,8);
for(int i=0;i&lt;8;i++){
printf("%d ",a[i]);
}
printf("\n");
return 0;
}
结果如下：
[root@localhost /]# gcc -o shell_sort shell_sort.c --std=c99
[root@localhost /]# ./shell_sort
1 2 3 5 6 7 9 10 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68fa9defdb39ad04ed28a0d7d61eafab/" rel="bookmark">
			android模拟器上网问题设置 emulator set net.dns1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android模拟器无法上网的原因 因为要调试webkit，在模拟器上调试，无法上网，故开始寻找解决方案。 过程 1.网络搜索，方法千奇百怪； 2.得知应该是DNS问题，故尝试IP直接访问，ok； 3.设置模拟器的DNS即可 方法 adb shell setprop net.dns1 你本机的DNS。 注意如果是公司的话可能有2个DNS，注意测试本机的访问是那个DNS，可以抓包查看到。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef47e86e654080b2cb5fdd70b2f9d3c/" rel="bookmark">
			C&#43;&#43;编程学习52个经典网站 强力推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++是最主要的编程语言。这里列出了50名优秀网站和网页清单，这些网站提供c/c++源代码。这份清单提供了源代码的链接以及它们的小说明。我已尽力包括最佳的C/C++源代码的网站。这不是一个完整的清单，您有建议可以联系我，我将欢迎您的建议，以进一步加强这方面的清单。 1、 http://snippets.dzone.com/tag/c/ --数以千计的有用的C语言源代码片段 2、http://www.hotscripts.com/category/c-cpp/scripts-programs/ Hotscripts --提供数以百计的C和C++脚本和程序。所有程序都分为不同的类别。 3、 http://www.planetsourcecode.com/vb/default.asp?lngWId=3 --超过万行C和C++免费的源代码 4、 http://freshmeat.net/browse/164/ --超过9000个C编写的项目。 5、 http://www.daniweb.com/code/c.html --DANIWEB提供的实用代码段 。 6、 http://www.programmersheaven.com/tags/C/ --programmersheaven.com上的C编程资源。 7、 http://www.ddj.com/code/ddj.html --Dr. Dobb’s Journal的源代码。 8、 http://www.cprogramming.com/cgi-bin/source/source.cgi --C和C + +编程资源。 9、 http://private.codecogs.com/ --CodeCogs是一项协作的开放源码库，C/C++的数值方面的组件。 10、 http://www.google.com/codesearch?q=programming++lang:c&amp;cs_r=lang:c --谷歌代码的C源代码。 11、 http://www.codepedia.com/1/C --CodePedia是一个开放的关于系统编程和其他与电脑有关的议题。 12、 http://www.cis.temple.edu/~ingargio/cis71/code/ --为学生提供的一个简单的C语言程序的列表。 13、 http://www.codeproject.com/?cat=2 --codeproject提供的C/C++资源代码项目。 14、 http://www.thefreecountry.com/sourcecode/cpp.shtml --以下是一些C和C++库的DLL，VCLs，源代码，元件，模块，应用程序框架，类库，源代码片段等，你可以在您的项目中使用而不需要支付费用和版税。 15、 http://people.sc.fsu.edu/~burkardt/cpp_src/cpp_src.html --这是一个全面的关于C++的345个源代码清单。 16、 http://www.cplusplus.com/src/ --C++写的通用控制台程序和Windows程序代码清单。 17、 http://users.cs.fiu.edu/~weiss/dsaa_c++/code/ --C++语言数据结构与算法分析（第二版）的源代码。 18、 http://c.snippets.org/ --C源代码片段。 19、 http://www.bbdsoft.com/downloads.html --C++源代码。 20、 http://www.moshier.net/ 天文学和数值软件源代码 21、 http://cplus.about.com/od/cgames/C_Games_with_Source_Code.htm --游戏有关的C++源代码。 22、 http://cliodhna.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ef47e86e654080b2cb5fdd70b2f9d3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6500bb5586638a6f5f67feb66e0b353/" rel="bookmark">
			fopen中w w&#43; wb区别：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在C语言中，大家常用到fopen打开文件，准备进行写操作，再用fwrite把数据写入文件，最后用fclose关闭文件。 如以下C代码： #include &lt;stdio.h&gt; char buf[10] = {10,10,10,10,10,10,10,10,10,10};
FILE *fp = fopen("c:\\test.dat","w");
fwrite(buf,1,10,fp);
fclose(fp);
FILE *fp1 = fopen("c:\\test1.dat","wb");
fwrite(buf,1,10,fp);
fclose(fp1);
我们注意到，程序的第一段定义一个数组，每个分量的值为：10,等价的十六进制为0A。
第二段，先是打开一个文件test.dat进行写操作，再是把10个数据写入文件，最后关闭文件。
第三段，功能差不多，只是文件名换成了test1.dat,打开文件的模式换成了wb.
第二段和第三段有什么区别呢？我们看一下最后的文件内容：
test.dat: 0D 0A 0D 0A 0D 0A 0D 0A 0D 0A 0D 0A 0D 0A 0D 0A 0D 0A 0D 0A
test1.dat： 0A 0A 0A 0A 0A 0A 0A 0A 0A 0A
原因是为什么呢？这就是w 和 wb的区别，w是以文本方式打开文件，wb是二进制方式打开文件，以文本方式打开文件时，fwrite函数每碰到一个0x0A时，就在它的前面加入0x0D.其它内容不做添加操作。
r 以只读方式打开文件，该文件必须存在。 r+ 以可读写方式打开文件，该文件必须存在。 rb+ 读写打开一个二进制文件，只允许读写数据。 rt+ 读写打开一个文本文件，允许读和写。 w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。 w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。 a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留） a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留） wb 只写打开或新建一个二进制文件；只允许写数据。 wb+ 读写打开或建立一个二进制文件，允许读和写。 wt+ 读写打开或着建立一个文本文件；允许读写。 at+ 读写打开一个文本文件，允许读或在文本末追加数据。 ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。 上述的形态字符串都可以再加一个b字符，如rb、w+b或ab＋等组合，加入b 字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。不过在POSIX系统，包含Linux都会忽略该字符。由fopen()所建立的新文件会具有S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH(0666)权限，此文件权限也会参考umask 值。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d5b804400402ee12a09317623f3e791/" rel="bookmark">
			DataGridView 中指定的 单元格 不能编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：DataGridView控件是从.NET Framework 2.0版本开始追加的。
ReadOnly属性的使用 DataGridView内所有的单元格不能编辑 当DataGridView.ReadOnly属性设定为True时， DataGridView内所有的单元格不能编辑。
但是使用这种方法可以对行进行删除。而且最下面的一行被表示，但不能输入。
//DataGridView1的第二列只读 DataGridView1.Columns[1].ReadOnly = true; //DataGridView1的第三行只读 DataGridView1.Rows[2].ReadOnly = true; //DataGridView1的(0, 0)的单元格只读 DataGridView1[0, 0].ReadOnly = true; //DataGridView1的第二列只读 DataGridView1.Columns[1].ReadOnly = true; //DataGridView1的第三行只读 DataGridView1.Rows[2].ReadOnly = true; //DataGridView1的(0, 0)的单元格只读 DataGridView1[0, 0].ReadOnly = true; DataGridView的ReadOnly设定为True时，DataGridView内的所有行、列、单元格的ReadOnly会自动设定为True。同样，列或行的ReadOnly设定为True时，所设定的列或行的所有的单元格的ReadOnly会自动设定为True。
EditMode属性的使用 当DataGridView.EditMode属性设定为DataGridViewEditMode.EditProgrammatically时，用户就不能对单元格进行编辑。但是，在程序中DataGridView.BeginEdit对象触发时，单元格变为可以进行编辑。
view plain copy to clipboard print ? //用户不能编辑单元格 DataGridView1.EditMode = DataGridViewEditMode.EditProgrammatically; //用户不能编辑单元格 DataGridView1.EditMode = DataGridViewEditMode.EditProgrammatically; 根据条件单元格不能编辑 这里所说的并不是每一个单元格的ReadOnly属性设定，而是使用CellBeginEdit事件处理器致使单元格不能编辑。如下面代码所示。
view plain copy to clipboard print ? view plaincopy to clipboardprint? //CellBeginEdit事件处理器 private void DataGridView1_CellBeginEdit(object sender, DataGridViewCellCancelEventArgs e) { DataGridView dgv = (DataGridView)sender; //判断是否可以编辑 if (dgv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d5b804400402ee12a09317623f3e791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/854e1dcca473b5a8fcf927a79d732dc8/" rel="bookmark">
			edit control
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MFC里面的EDIT Control控件的用法是怎么样的,1.怎么样才能赋值给EDIT Control控件并在EDIT Control控件显示出来;2.怎么取得EDIT Control控件的值并传递给一个变量？希望各位大侠帮帮忙！
//获得EDIT
CEdit* pBoxOne;
pBoxOne = (CEdit*) GetDlgItem(IDC_EDIT1);
//付值
pBoxOne-&gt;SetWindowText( _T"FOO" );
//取值
CString str;
pBoxOne-&gt;GetWindowText(str);
GetDlgItem(IDC_EDIT1)-&gt;SetWindowText( _T"FOO" );
也可以
//取值
CString str;
GetDlgItem(IDC_EDIT1)-&gt;GetWindowText(str);
EditControl是在MFC对话框中最频繁的使用的控件之一
VC++2005提供EditControl的属性和控件事件操作简单方便
1只允许输入数字
如果设置EditControl中只能输入数字,在VC6.0中需要编写一个派生类来达到目的,而在VC++2005下只需要在属性对话框中将Number的属性值设
为True就可以了.
2获取EditControl的内容
两种方法
第一种,利用MFC应用程序向导生成一个基于对话框的应用程序,从资源视图中选择该Dialog窗体,利用右侧的工具箱,向Dialog内添加一个
EditControl项,声明控件变量的类别为Value,变量类型为CString,变量名为m_sEdit_Content.
CString m_sEdit_Content;
CString s;
UpdateData(true);
s=m_sEdit_Content.GetString();
MessageBox(s,_T("获取编辑框的内容"),MB_OK);
s.ReleaseBuffer();
这样就取得了编辑框的内容
UpdateData(true);这句代码很重要,它的作用是将输入的数据装入EditControl对应的变量m_sEdit_Content中.
由于MFC应用程序向导默认是使用Unicode库,所以MessageBox中的字符串需要用_T(),否则会出现const char[]转换LPCTSTR错误,如果不使用
Unicode库就不需要_T().
第二种方法
声明控件变量的类别为Control,变量类型为CEdit,变量名为m_Edit_Content.
代码如下(Unicode)
CString s;
s.GetBufferSetLength(1024);
m_Edit_Content.GetWindowTextW(s.GetBuffer(),s.GetLength());
MessageBox(s,_T("获取文本框的内容"),MB_OK);
s.ReleaseBuffer();
如果不是Unicode下获取编辑框内容的函数就是GetWindowTextA
3将EditControl中的内容转化为整数
在限制编辑框只能数字之后,要将字符串转化为整数
声明控件变量的类别为Value,变量类型为CString,变量名为m_sEdit_Content.
CString s;
UpdateData(true);
s=m_sEdit_Content.GetString();
int n=_tstoi(s);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/854e1dcca473b5a8fcf927a79d732dc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc02c612a03a0ced45d9ada1b3d8c9d8/" rel="bookmark">
			Android launcher中Workspace类大致分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Workspace.Java类实现，相关方法有： 1) computeScroll()：重写了父类的computeScroll();主要功能是计算拖动的位移量、更新背景、设置要显示的屏幕(setCurrentScreen(mCurrentScreen);)。 2) dispatchDraw()：重写了父类的dispatchDraw();主要功能是判断抽屉是否打开、绘制指定的屏幕，可以绘制当前一屏，也可以绘制当前屏幕和下一屏幕，也可以绘制所有的屏幕，这儿的绘制指显示屏幕上的child(例如：app、folder、Wiget)。和 computeScroll()中的setCurrentScreen(mCurrentScreen);方法配合使用可以实现屏幕的拖动多少显示多少的功能。 3) onMeasure()：重写了父类的onMeasure();主要功能是设置屏幕的显示大小。由每个child的measure()方法设置。 4) onLayout()：重写了父类的onLayout();主要功能是设置屏幕的显示位置。由child的layout()方法设置。 5) onInterceptTouchEvent()：重写了父类的onInterceptTouchEvent();主要功能是在onTouchEvent()方法之前处理touch事件。包括：down、up、move事件。 ? 用xy记录鼠标移动时的坐标值; ? mLastMotionX和mLastMotionY记录了上次鼠标按下时的XY值，在ACTION_MOVE中赋值; ? xDiff和yDiff记录xy与mLastMotionX、mLastMotionY差值的绝对值; ? touchSlop为系统定义的标准值，初值为16; ? 当xDiff和yDiff大于touchSlop时就认为界面拖动了足够大的距离，屏幕就可以移动了; ? 当onInterceptTouchEvent()返回true时进入onTouchEvent()。 6) onTouchEvent()：重写了父类的onTouchEvent();主要功能是处理onInterceptTouchEvent()返回值为true时传递过来的touch事件。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e3af9177f1044b10bee75c8aa4e2a4d/" rel="bookmark">
			笔记本电脑键盘上数字键和英文的切换方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jul 31.2011
问：使用笔记本电脑时，按一些字母键却出现数字的情况，怎么样才能先出现英文？ 答：笔记本电脑键盘上的英文字母键（U I O P J K L M）上有数字，按J、K、L等键盘显示得都是1、2、3的数字等，这是因为锁定了数字键。 一般左下角有个FN键，键盘最上面有个NUM LOCK键 ，FN+NUM LOCK可切换主键位与数字键盘。 其实，碰到此类问题的情况还是比较常见的，整理了一下供大家参考—— 由于笔记本电脑为了减小键盘所占区域，将我们台式电脑键盘右侧的小数字键盘区合并在了主键盘区上，因此造成有些字母键通过切换后还有输入数字的功能。在使用计算机的过程中，有时可能无意中按下了NumLk这个切换键导致出现按下字母键却显示数字的现象。 一般而言多在右上或右下。如果你的NumLk键上字样的颜色跟字母键盘上字样的颜色不同，一般表示你要同时按下Fn(Function)键才能按倒它，如果字样是同色却在该键盘上方，表示你要按Shift键才按得到它。按第一次时启动数字小键盘（这时有的本本上会有一个写着数字1的锁的符号灯会亮起），再按一次恢复正常。 处理方法（不同品牌的笔记本方法不一样）： (1) 绝大多数是“Fn+NumLk” 这种情况一般适用功能键Fn和NumLk是同一种颜色 (2) 有的是 “Shift+NumLk” (如IBM笔记本) 这种情况一般适用功能键Fn和NumLk是不同颜色 (3) 有的是直接按 “NumLk” (4) 也可以在BIOS里直接设置成开机为数字键或不是 在BIOS里找到有NUMLOCK字样的选项，改成Enable或Disable 转载于:https://blog.51cto.com/zxgchinese/628169
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ccc4089d78422588a6659c0ceee1eaf/" rel="bookmark">
			Oracle错误代码ORA-00000 to ORA-00832
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORA-00000: normal, successful completion Cause Normal exit. Action None. ORA-00001: unique constraint (string.string) violated Cause An UPDATE or INSERT statement attempted to insert a duplicate key. For Trusted Oracle configured in DBMS MAC mode, you may see this message if a duplicate entry exists at a different level. Action Either remove the unique restriction or do not insert the key. ORA-00017: session requested to set trace event Cause The current session was requested to set a trace event by another session.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ccc4089d78422588a6659c0ceee1eaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d9885951538efae6225cdcbb3c0a805/" rel="bookmark">
			main返回值非0表示程序未正常退出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击打开链接
3. 关于 void main 在 C 和 C++ 中，不接收任何参数也不返回任何信息的函数原型为 “void foo(void);”。可能正是因为这个，所以很多人都误认为如果不需要程序返回任何信息时可以把 main 函数定义成 void main(void) 。然而这是错误的！main 函数的返回值应该定义为 int 类型，C 和 C++ 标准中都是这样规定的。虽然在一些编译器中，void main 可以通过编译（如 vc6），但并非所有编译器都支持 void main ，因为标准中从来没有定义过 void main 。g++3.2 中如果 main 函数的返回值不是 int 类型，就根本通不过编译。而 gcc3.2 则会发出警告。所以，如果你想你的程序拥有很好的可移植性，请一定要用 int main 。 4. 返回值的作用 main 函数的返回值用于说明程序的退出状态。如果返回 0，则代表程序正常退出，否则代表程序异常退出。下面我们在 winxp 环境下做一个小实验。首先编译下面的程序： int main( void ) { return 0; } 然后打开附件里的“命令提示符”，在命令行里运行刚才编译好的可执行文件，然后输入“echo %ERRORLEVEL%”，回车，就可以看到程序的返回值为 0 。假设刚才编译好的文件是 a.exe ，如果输入“a &amp;&amp; dir”，则会列出当前目录下的文件夹和文件。但是如果改成 “return -1”，或者别的非 0 值，重新编译后输入“a &amp;&amp; dir”，则 dir 不会执行。因为 &amp;&amp; 的含义是：如果 &amp;&amp; 前面的程序正常退出，则继续执行 &amp;&amp; 后面的程序，否则不执行。也就是说，利用程序的返回值，我们可以控制要不要执行下一个程序。这就是 int main 的好处。如果你有兴趣，也可以把 main 函数的返回值类型改成非 int 类型（如 float），重新编译后执行“a &amp;&amp; dir”，看看会出现什么情况，想想为什么会出现那样的情况。顺便提一下，如果输入 a || dir 的话，则表示如果 a 异常退出，则执行 dir 。 int main( int argc, char *argv[], char *env[] ) 也不是标准C里面定义的东西~char *env[]是某些编译器提供的扩展功能~用于获取系统的环境设定~因为不是标准~故而移植性差~不推荐使用 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d9885951538efae6225cdcbb3c0a805/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae878066d0f2943e3d2c9643cf4227af/" rel="bookmark">
			ABI  EABI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://bbs.chinaunix.net/thread-1950213-1-1.html
这个是友善之臂的linux内核移植里头提到的那篇文章，我以前也转载过，不过好像没找到这么全的出处。
ABI和API是不一样的，ABI是强调的是B，也就是二进制级别的兼容。P是编程。I是接口。
应该是关于I的设计问题，我不太理解，应该很深刻。想不到编译器竟然这么有学问。
1。什么是ABI
ABI，application binary interface (ABI)， 应用程序二进制接口。 既然是 接口，那就是某两种东西之间的沟通桥梁，此处有这些种情况： A。 应用程序 &lt;－&gt; 操作系统； B。应用程序 &lt;－&gt; （应用程序所用到的）库 C 。应用程序各个组件之间 类似于API的作用是使得程序的代码间的兼容，ABI目的是使得程序的二进制（级别）的兼容。 2。什么是OABI 和 EABI OABI中的O，表示“Old”，“Lagacy”，旧的，过时的，OABI就是旧的/老的ABI。 EABI中的E，表示“Embedded”，是一种新的ABI。 EABI有时候也叫做GNU EABI。 OABI和EABI都是专门针对ARM的CPU来说的。 3。EABI的好处 ／ 为何要用EABI A。支持 软件浮点和硬件实现浮点功能混用 B。 系统调用的效率更高 C。后今后的工具更兼容 D。软件浮点的情况下，EABI的软件浮点的效率要比OABI高很多。 4。OABI和EABI的区别 两种ABI在如下方面有区别： A。调用规则（包括参数如何传递及如何获得返回值） B。系统调用的数目以及应用程序应该如何去做系统调用 C。目标 文件的二进制格式，程序库等 D。结构体中的 填充（padding/packing）和对齐。 E。 OABI： * ABI flags passed to binutils: -mabi=apcs-gnu -mfpu=fpa * gcc -dumpmachine: arm-unknown- linux * objdump -x for compiled binary: private flags = 2: [APCS-32] [FPA float format] [has entry point] * "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae878066d0f2943e3d2c9643cf4227af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eba25c6b5c3e18ecc98be000076d38d8/" rel="bookmark">
			开源Webmail客户端Claros inTouch2.1＋James MailServer配置和调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备： 环境winxp + jdk1.6 + tomcat6.0.16 apache james2.3.2 (邮件服务器) Claros inTouch2.1.war (WebMail界面程序) 安装： 1、安装james邮件服务容器：james下载后直接解压后启动就可以了 bin目录中的run.bat和run.sh是James的启动程序。 apps目录下在服务器第一次启动之前，只有james.sar、dummy.txt两个文件，第一次启动后apps下会生产其他文件。apps\james\SAR-INF下有一个config.xml是james中的核心配置文件。config.xml是在第一次启动james服务器来。 运行run.dat启动服务器 Java代码 Using PHOENIX_HOME: C:\james-2.3.2 Using PHOENIX_TMPDIR: C:\james-2.3.2\temp Using JAVA_HOME: Phoenix 4.2 James Mail Server 2.3.2 Remote Manager Service started plain:4555 POP3 Service started plain:110 SMTP Service started plain:25 NNTP Service started plain:119 FetchMail Disabled Using PHOENIX_HOME: C:\james-2.3.2 Using PHOENIX_TMPDIR: C:\james-2.3.2\temp Using JAVA_HOME: Phoenix 4.2 James Mail Server 2.3.2 Remote Manager Service started plain:4555 POP3 Service started plain:110 SMTP Service started plain:25 NNTP Service started plain:119 FetchMail Disabled 对james_home\apps\james\SAR-INF\config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eba25c6b5c3e18ecc98be000076d38d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1a49cc91334290e4ae8cfed9bb655e4/" rel="bookmark">
			关于 CPU的 基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.主频 主频也叫时钟频率，单位是MHz，用来表示CPU的运算速度。CPU的主频＝外频×倍频系数。很多人认为主频就决定着CPU的运行速度，这不仅是个片面的，而且对于服务器来讲，这个认识也出现了偏差。至今，没有一条确定的公式能够实现主频和实际的运算速度两者之间的数值关系，即使是两大处理器厂家Intel和AMD，在这点上也存在着很大的争议，我们从Intel的产品的发展趋势，可以看出Intel很注重加强自身主频的发展。像其他的处理器厂家，有人曾经拿过一快1G的全美达来做比较，它的运行效率相当于2G的Intel处理器。 所以，CPU的主频与CPU实际的运算能力是没有直接关系的，主频表示在CPU内数字脉冲信号震荡的速度。在Intel的处理器产品中，我们也可以看到这样的例子：1 GHz Itanium芯片能够表现得差不多跟2.66 GHz Xeon/Opteron一样快，或是1.5 GHz Itanium 2大约跟4 GHz Xeon/Opteron一样快。CPU的运算速度还要看CPU的流水线的各方面的性能指标。 当然，主频和实际的运算速度是有关的，只能说主频仅仅是CPU性能表现的一个方面，而不代表CPU的整体性能。 2.外频 外频是CPU的基准频率，单位也是MHz。CPU的外频决定着整块主板的运行速度。说白了，在台式机中，我们所说的超频，都是超CPU的外频（当然一般情况下，CPU的倍频都是被锁住的）相信这点是很好理解的。但对于服务器CPU来讲，超频是绝对不允许的。前面说到CPU决定着主板的运行速度，两者是同步运行的，如果把服务器CPU超频了，改变了外频，会产生异步运行，（台式机很多主板都支持异步运行）这样会造成整个服务器系统的不稳定。 目前的绝大部分电脑系统中外频也是内存与主板之间的同步运行的速度，在这种方式下，可以理解为CPU的外频直接与内存相连通，实现两者间的同步运行状态。外频与前端总线(FSB)频率很容易被混为一谈，下面的前端总线介绍我们谈谈两者的区别。 3.前端总线(FSB)频率 前端总线(FSB)频率(即总线频率)是直接影响CPU与内存直接数据交换速度。有一条公式可以计算，即数据带宽＝(总线频率×数据带宽)/8，数据传输最大带宽取决于所有同时传输的数据的宽度和传输频率。比方，现在的支持64位的至强Nocona，前端总线是800MHz，按照公式，它的数据传输最大带宽是6.4GB/秒。 外频与前端总线(FSB)频率的区别：前端总线的速度指的是数据传输的速度，外频是CPU与主板之间同步运行的速度。也就是说，100MHz外频特指数字脉冲信号在每秒钟震荡一千万次；而100MHz前端总线指的是每秒钟CPU可接受的数据传输量是100MHz×64bit÷8Byte/bit=800MB/s。 其实现在“HyperTransport”构架的出现，让这种实际意义上的前端总线(FSB)频率发生了变化。之前我们知道IA-32架构必须有三大重要的构件：内存控制器Hub (MCH) ,I/O控制器Hub和PCI Hub，像Intel很典型的芯片组 Intel 7501、Intel7505芯片组，为双至强处理器量身定做的，它们所包含的MCH为CPU提供了频率为533MHz的前端总线，配合DDR内存，前端总线带宽可达到4.3GB/秒。但随着处理器性能不断提高同时给系统架构带来了很多问题。而“HyperTransport”构架不但解决了问题，而且更有效地提高了总线带宽，比方AMD Opteron处理器，灵活的HyperTransport I/O总线体系结构让它整合了内存控制器，使处理器不通过系统总线传给芯片组而直接和内存交换数据。这样的话，前端总线(FSB)频率在AMD Opteron处理器就不知道从何谈起了。 4、CPU的位和字长 位：在数字电路和电脑技术中采用二进制，代码只有“0”和“1”，其中无论是 “0”或是“1”在CPU中都是 一“位”。 字长：电脑技术中对CPU在单位时间内(同一时间)能一次处理的二进制数的位数叫字长。所以能处理字长为8位数据的CPU通常就叫8位的CPU。同理32位的CPU就能在单位时间内处理字长为32位的二进制数据。字节和字长的区别：由于常用的英文字符用8位二进制就可以表示，所以通常就将8位称为一个字节。字长的长度是不固定的，对于不同的CPU、字长的长度也不一样。8位的CPU一次只能处理一个字节，而32位的CPU一次就能处理4个字节，同理字长为64位的CPU一次可以处理8个字节。 5.倍频系数 倍频系数是指CPU主频与外频之间的相对比例关系。在相同的外频下，倍频越高CPU的频率也越高。但实际上，在相同外频的前提下，高倍频的CPU本身意义并不大。这是因为CPU与系统之间数据传输速度是有限的，一味追求高倍频而得到高主频的CPU就会出现明显的“瓶颈”效应—CPU从系统中得到数据的极限速度不能够满足CPU运算的速度。一般除了工程样版的Intel的CPU都是锁了倍频的，而AMD之前都没有锁。
6.缓存 缓存大小也是CPU的重要指标之一，而且缓存的结构和大小对CPU速度的影响非常大，CPU内缓存的运行频率极高，一般是和处理器同频运作，工作效率远远大于系统内存和硬盘。实际工作时，CPU往往需要重复读取同样的数据块，而缓存容量的增大，可以大幅度提升CPU内部读取数据的命中率，而不用再到内存或者硬盘上寻找，以此提高系统性能。但是由于CPU芯片面积和成本的因素来考虑，缓存都很小。 L1 Cache(一级缓存)是CPU第一层高速缓存，分为数据缓存和指令缓存。内置的L1高速缓存的容量和结构对CPU的性能影响较大，不过高速缓冲存储器均由静态RAM组成，结构较复杂，在CPU管芯面积不能太大的情况下，L1级高速缓存的容量不可能做得太大。一般服务器CPU的L1缓存的容量通常在32—256KB。 L2 Cache(二级缓存)是CPU的第二层高速缓存，分内部和外部两种芯片。内部的芯片二级缓存运行速度与主频相同，而外部的二级缓存则只有主频的一半。L2高速缓存容量也会影响CPU的性能，原则是越大越好，现在家庭用CPU容量最大的是512KB，而服务器和工作站上用CPU的L2高速缓存更高达256-1MB，有的高达2MB或者3MB。 L3 Cache(三级缓存)，分为两种，早期的是外置，现在的都是内置的。而它的实际作用即是，L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时处理器的性能。降低内存延迟和提升大数据量计算能力对游戏都很有帮助。而在服务器领域增加L3缓存在性能方面仍然有显著的提升。比方具有较大L3缓存的配置利用物理内存会更有效，故它比较慢的磁盘I/O子系统可以处理更多的数据请求。具有较大L3缓存的处理器提供更有效的文件系统缓存行为及较短消息和处理器队列长度。 其实最早的L3缓存被应用在AMD发布的K6-III处理器上，当时的L3缓存受限于制造工艺，并没有被集成进芯片内部，而是集成在主板上。在只能够和系统总线频率同步的L3缓存同主内存其实差不了多少。后来使用L3缓存的是英特尔为服务器市场所推出的Itanium处理器。接着就是P4EE和至强MP。Intel还打算推出一款9MB L3缓存的Itanium2处理器，和以后24MB L3缓存的双核心Itanium2处理器。 但基本上L3缓存对处理器的性能提高显得不是很重要，比方配备1MB L3缓存的Xeon MP处理器却仍然不是Opteron的对手，由此可见前端总线的增加，要比缓存增加带来更有效的性能提升。 7.CPU扩展指令集 CPU依靠指令来计算和控制系统，每款CPU在设计时就规定了一系列与其硬件电路相配合的指令系统。指令的强弱也是CPU的重要指标，指令集是提高微处理器效率的最有效工具之一。从现阶段的主流体系结构讲，指令集可分为复杂指令集和精简指令集两部分，而从具体运用看，如Intel的MMX（Multi Media Extended）、SSE、 SSE2（Streaming-Single instruction multiple data-Extensions 2）、SEE3和AMD的3DNow!等都是CPU的扩展指令集，分别增强了CPU的多媒体、图形图象和Internet等的处理能力。我们通常会把CPU的扩展指令集称为"CPU的指令集"。SSE3指令集也是目前规模最小的指令集，此前MMX包含有57条命令，SSE包含有50条命令，SSE2包含有144条命令，SSE3包含有13条命令。目前SSE3也是最先进的指令集，英特尔Prescott处理器已经支持SSE3指令集，AMD会在未来双核心处理器当中加入对SSE3指令集的支持，全美达的处理器也将支持这一指令集。 8.CPU内核和I/O工作电压 从586CPU开始，CPU的工作电压分为内核电压和I/O电压两种，通常CPU的核心电压小于等于I/O电压。其中内核电压的大小是根据CPU的生产工艺而定，一般制作工艺越小，内核工作电压越低；I/O电压一般都在1.6~5V。低电压能解决耗电过大和发热过高的问题。 9.制造工艺 制造工艺的微米是指IC内电路与电路之间的距离。制造工艺的趋势是向密集度愈高的方向发展。密度愈高的IC电路设计，意味着在同样大小面积的IC中，可以拥有密度更高、功能更复杂的电路设计。现在主要的180nm、130nm、90nm。最近官方已经表示有65nm的制造工艺了。 10.指令集 （1）CISC指令集 CISC指令集，也称为复杂指令集，英文名是CISC，（Complex Instruction Set Computer的缩写）。在CISC微处理器中，程序的各条指令是按顺序串行执行的，每条指令中的各个操作也是按顺序串行执行的。顺序执行的优点是控制简单，但计算机各部分的利用率不高，执行速度慢。其实它是英特尔生产的x86系列（也就是IA-32架构）CPU及其兼容CPU，如AMD、VIA的。即使是现在新起的X86-64（也被成AMD64）都是属于CISC的范畴。 要知道什么是指令集还要从当今的X86架构的CPU说起。X86指令集是Intel为其第一块16位CPU(i8086)专门开发的，IBM1981年推出的世界第一台PC机中的CPU—i8088(i8086简化版)使用的也是X86指令，同时电脑中为提高浮点数据处理能力而增加了X87芯片，以后就将X86指令集和X87指令集统称为X86指令集。 虽然随着CPU技术的不断发展，Intel陆续研制出更新型的i80386、i80486直到过去的PII至强、PIII至强、Pentium 3，最后到今天的Pentium 4系列、至强（不包括至强Nocona），但为了保证电脑能继续运行以往开发的各类应用程序以保护和继承丰富的软件资源，所以Intel公司所生产的所有CPU仍然继续使用X86指令集，所以它的CPU仍属于X86系列。由于Intel X86系列及其兼容CPU（如AMD Athlon MP、）都使用X86指令集，所以就形成了今天庞大的X86系列及兼容CPU阵容。x86CPU目前主要有intel的服务器CPU和AMD的服务器CPU两类。 （2）RISC指令集 RISC是英文“Reduced Instruction Set Computing ” 的缩写，中文意思是“精简指令集”。它是在CISC指令系统基础上发展起来的，有人对CISC机进行测试表明，各种指令的使用频度相当悬殊，最常使用的是一些比较简单的指令，它们仅占指令总数的20％，但在程序中出现的频度却占80％。复杂的指令系统必然增加微处理器的复杂性，使处理器的研制时间长，成本高。并且复杂指令需要复杂的操作，必然会降低计算机的速度。基于上述原因，20世纪80年代RISC型CPU诞生了，相对于CISC型CPU ,RISC型CPU不仅精简了指令系统，还采用了一种叫做“超标量和超流水线结构”，大大增加了并行处理能力。RISC指令集是高性能CPU的发展方向。它与传统的CISC(复杂指令集)相对。相比而言，RISC的指令格式统一，种类比较少，寻址方式也比复杂指令集少。当然处理速度就提高很多了。目前在中高档服务器中普遍采用这一指令系统的CPU，特别是高档服务器全都采用RISC指令系统的CPU。RISC指令系统更加适合高档服务器的操作系统UNIX，现在Linux也属于类似UNIX的操作系统。RISC型CPU与Intel和AMD的CPU在软件和硬件上都不兼容。 目前，在中高档服务器中采用RISC指令的CPU主要有以下几类：PowerPC处理器、SPARC处理器、PA-RISC处理器、MIPS处理器、Alpha处理器。 （3）IA-64 EPIC（Explicitly Parallel Instruction Computers，精确并行指令计算机）是否是RISC和CISC体系的继承者的争论已经有很多，单以EPIC体系来说，它更像Intel的处理器迈向RISC体系的重要步骤。从理论上说，EPIC体系设计的CPU，在相同的主机配置下，处理Windows的应用软件比基于Unix下的应用软件要好得多。 Intel采用EPIC技术的服务器CPU是安腾Itanium（开发代号即Merced）。它是64位处理器，也是IA－64系列中的第一款。微软也已开发了代号为Win64的操作系统，在软件上加以支持。在Intel采用了X86指令集之后，它又转而寻求更先进的64-bit微处理器，Intel这样做的原因是，它们想摆脱容量巨大的x86架构,从而引入精力充沛而又功能强大的指令集，于是采用EPIC指令集的IA-64架构便诞生了。IA-64 在很多方面来说，都比x86有了长足的进步。突破了传统IA32架构的许多限制，在数据的处理能力，系统的稳定性、安全性、可用性、可观理性等方面获得了突破性的提高。 IA-64微处理器最大的缺陷是它们缺乏与x86的兼容，而Intel为了IA-64处理器能够更好地运行两个朝代的软件，它在IA-64处理器上（Itanium、Itanium2 ……)引入了x86-to-IA-64的解码器，这样就能够把x86指令翻译为IA-64指令。这个解码器并不是最有效率的解码器，也不是运行x86代码的最好途径（最好的途径是直接在x86处理器上运行x86代码），因此Itanium 和Itanium2在运行x86应用程序时候的性能非常糟糕。这也成为X86-64产生的根本原因。 （4）X86-64 （AMD64 / EM64T） AMD公司设计，可以在同一时间内处理64位的整数运算，并兼容于X86-32架构。其中支持64位逻辑定址，同时提供转换为32位定址选项；但数据操作指令默认为32位和8位，提供转换成64位和16位的选项；支持常规用途寄存器，如果是32位运算操作，就要将结果扩展成完整的64位。这样，指令中有“直接执行”和“转换执行”的区别，其指令字段是8位或32位，可以避免字段过长。 x86-64（也叫AMD64）的产生也并非空穴来风，x86处理器的32bit寻址空间限制在4GB内存，而IA-64的处理器又不能兼容x86。AMD充分考虑顾客的需求，加强x86指令集的功能，使这套指令集可同时支持64位的运算模式，因此AMD把它们的结构称之为x86-64。在技术上AMD在x86-64架构中为了进行64位运算，AMD为其引入了新增了R8-R15通用寄存器作为原有X86处理器寄存器的扩充，但在而在32位环境下并不完全使用到这些寄存器。原来的寄存器诸如EAX、EBX也由32位扩张至64位。在SSE单元中新加入了8个新寄存器以提供对SSE2的支持。寄存器数量的增加将带来性能的提升。与此同时，为了同时支持32和64位代码及寄存器，x86-64架构允许处理器工作在以下两种模式：Long Mode(长模式)和Legacy Mode(遗传模式)，Long模式又分为两种子模式(64bit模式和Compatibility mode兼容模式)。该标准已经被引进在AMD服务器处理器中的Opteron处理器。 而今年也推出了支持64位的EM64T技术，再还没被正式命为EM64T之前是IA32E，这是英特尔64位扩展技术的名字,用来区别X86指令集。Intel的EM64T支持64位sub-mode，和AMD的X86-64技术类似，采用64位的线性平面寻址，加入8个新的通用寄存器（GPRs），还增加8个寄存器支持SSE指令。与AMD相类似，Intel的64位技术将兼容IA32和IA32E，只有在运行64位操作系统下的时候，才将会采用IA32E。IA32E将由2个sub-mode组成：64位sub-mode和32位sub-mode，同AMD64一样是向下兼容的。Intel的EM64T将完全兼容AMD的X86-64技术。现在Nocona处理器已经加入了一些64位技术，Intel的Pentium 4E处理器也支持64位技术。 应该说，这两者都是兼容x86指令集的64位微处理器架构，但EM64T与AMD64还是有一些不一样的地方，AMD64处理器中的NX位在Intel的处理器中将没有提供。 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1a49cc91334290e4ae8cfed9bb655e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7470428e87793d81a4503ef7abc95cb2/" rel="bookmark">
			虚拟机网络配置中的一些疑难问题---在实验室遇到了Destination Host Unreachable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		csdn的新版的博客速度很快啊。 下午本打算nfs一下板子的，发现找不到虚拟机。 测试了下虚拟机的网络情况： root@ubuntu:/nfsboot/etc# ping 202.193.89.254 这个网关不可达。 PING 202.193.89.254 (202.193.89.254) 56(84) bytes of data. From 202.193.89.253 icmp_seq=1 Destination Host Unreachable From 202.193.89.253 icmp_seq=2 Destination Host Unreachable From 202.193.89.253 icmp_seq=3 Destination Host Unreachable From 202.193.89.253 icmp_seq=4 Destination Host Unreachable From 202.193.89.253 icmp_seq=5 Destination Host Unreachable 域名服务器也不可达。真是奇怪了。 root@ubuntu:/nfsboot/etc# ping 202.193.80.33 PING 202.193.80.33 (202.193.80.33) 56(84) bytes of data. From 202.193.89.253 icmp_seq=1 Destination Host Unreachable From 202.193.89.253 icmp_seq=2 Destination Host Unreachable From 202.193.89.253 icmp_seq=3 Destination Host Unreachable From 202.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7470428e87793d81a4503ef7abc95cb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7442b9eaba8ebe1f83df6c24776d128/" rel="bookmark">
			如何用BI实现购物篮分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如今的零售卖场，商品跟别人差不多、价格跟别人差不多、布局也跟别人差不多，基本什么都差不多甚至有些方面还不如人的时候，如何去寻找突破？有一个至关重要但却被国内大多数零售企业忽略了的因素——那就是“顾客”，如今的零售企业，更加需要用心去了解自己的顾客，去思考 “将商品卖给谁”的问题。 实际上大部分商品制造商的所谓产品（品牌）管理以及品质（质量）管理，都与顾客需求是割裂的。但由于无法有效并准确把握顾客需求变化，商品制造商不得不想尽一切办法来夺取终端零售商的陈列空间。供应商依靠大量的促销和价格运作，可能还兼有商品品质的降低，给零售商带来大量的购买廉价货的低值顾客（只贡献销量不贡献毛利），并在高销量低毛利的虚假繁荣下向零售商要求更多货架、堆头，如此恶性循环。因此，只有那些进行顾客分类，并采取细分策略的零售商，才能有效把握不同顾客群体的购物需求，通过分析每个顾客群体购物需求变化进而指导卖场的实际促销营运。 以往零售企业做促销，其潜在的促销对象是本店所有顾客，于是在促销主题设计、折让、促销信息推广、销售分成等方面的投入，平均分配到所有顾客身上。不合理的分配，需要做顾客分类管理，通过顾客分类管理，可以准确地判断：高消费能力的顾客最喜欢什么样的商品？他们购买该商品时最有可能购买的关联品类有哪些？他们是不是该商品的目标顾客？哪些顾客群体为卖场贡献了主要的毛利额？他们喜欢什么时间光临卖场？…… BI与购物篮 购物篮指的是超级市场内供顾客购物时选装商品的篮子。所谓的购物篮分析就是通过这些购物篮商品的信息来分析顾客的购买行为。顾客的购物篮隐含着重要且有价值的信息等待发掘。如：可以得出顾客的购买习惯、产品偏好、品牌忠诚度等。购物篮数据分析是通过数据挖掘和BI分析技术，从海量购物篮数据中挖掘出顾客的历史消费行为，协助经营者调整商品结构、价格带结构、货架组织结构等，以达到针对性营销的目的。 BI（Business Intelligence，商业智能）通常被理解为将企业中现有的MIS系统数据转化为有用的信息，帮助企业做出明智的业务经营决策的工具。商业智能的关键是从许多来自不同的企业运作系统的数据中提取出有用的数据并进行清理，以保证数据的正确性，然后经过抽取（Extract）、转换（Transform）和装载（Load），即ETL过程，合并到一个企业级的数据仓库里，从而得到企业数据的一个全局视图，在此基础上利用合适的查询和分析工具、数据挖掘工具、OLAP工具等对其进行分析和处理（这时信息变为辅助决策的知识），最后将知识呈现给管理者，为管理者的决策过程提供支持。 下面以一个案例具体谈一下BI是如何在零售企业中实现购物篮分析应用的。 山东某连锁超市是山东省的一家中型连锁超市，拥有十几家大型综合性超市，面积在3000～20000平米不等。随着国内零售行业的竞争日益激烈，作为经济实力较强的山东省零售市场也感觉到了前所未有的压力和挑战。2007年随着银座、家家悦、贵和等竞争对手在当地的陆续开店，这家超市的经营业绩急剧下滑。 为了提升门店的形象及销售业绩，他们提出了以顾客为导向的经营模式，进行门店顾客定位及消费体验的提升，找出最有价值的顾客群体并想办法挽留这些流失的顾客，初步确定了一整套的顾客营销方案。但是，这个方案的顺利实施要取决于一个关键因素：顾客群体的划分。如果不对门店顾客群体及其购物习惯进行研究，就无法弄清现在的商品结构是否合理，无法对门店的卖场布局、商品陈列、促销活动等作出改进计划。 集团中高层管理者经过多次讨论磋商，觉得无论从分析操作的灵活性，还是从海量数据的计算性能方面，仅仅依靠现有的MIS系统是无法完成的，他们迫切需要一套简单、灵活、高效的数据分析系统，于是最终大家一致认为有必要采用BI对门店进行数据挖掘分析。因为只有通过BI这种多维度灵活分析工具，才能为门店随时开发出各种新形式来分析顾客行为，才能更好的支持经营决策。 企业通过BI实现的目标 采用BI商业智能对该企业进行数据分析，需要达到如下目标： 1、分析超市总体顾客定位和贡献度等特点，了解当前顾客的组成结构和现状，掌握哪些顾客群贡献了毛利、哪些顾客群买走了促销品等关键信息。 2、分析各类门店的顾客组成、购物高峰和消费习惯等特点，为企业改善门店的经营策略提供参考依据。 3、分析各类顾客群体对各门店的贡献情况，找出门店自己的核心顾客，便于为这些顾客提供更好的服务。 4、分析各类顾客群体最关注的商品及关联商品，为门店制订促销主题、选择促销商品、货架商品陈列等提供切实有效的帮助。 5、分析会员的各类消费行为，了解各类会员对门店的贡献度及其比较关注的商品品类，为举行各种会员活动提供数据依据。 总之，项目的核心目的是通过一系列的顾客行为分析工作，为该企业门店今后的日常运营建立一套完整的分析指标体系，从而为推动门店提升销售业绩提供动力。 客类分析的具体方法 1、数据来源及技术工具 对顾客行为分析的最佳数据来源，就是POS机的销售流水数据，因为这是门店最真实、最原始的数据来源。从中可以得到顾客的销售时间、商品组合、销售金额、毛利等丰富信息。同时，该企业于2008年初实行了会员卡管理，所以还可以从销售流水中抽取会员的销售数据来进行专项分析。 为了让门店能够尽快体验到数据分析的益处，该企业首先选择了4家规模较大的门店（1号店、2号店、3号店、4号店）作为首批试点门店，提取了从07至08近一年的销售流水数据。采用一系列BI技术工具进行分析，这些工具包括： （1）ETL数据抽取工具SSIS（SqlServer Intergration Services）； （2）数据仓库SqlServer2005企业版； （3）多维数据库SSAS（SqlServer Analysis Services）； （4）前端展示工具采用了 七智BI数据分析平台2007版。 2、主要分析指标 （1）客类 顾名思义就是对顾客的划分归类（即购物篮），这里以收银小票（即前台交易小票）为基本单位，用每张小票的客单价、销售商品毛利率作为两大衡量指标，利用BI工具自动汇总计算后分成如下四类顾客群：金类顾客群：客单价&gt;平均客单价、毛利率&gt;平均毛利率；银类顾客群：客单价&gt;平均客单价、毛利率&lt;平均毛利率；铜类顾客群：客单价&lt;平均客单价、毛利率&gt;平均毛利率；锡类顾客群：客单价&lt;平均客单价、毛利率&lt;平均毛利率。 其中，客单价指标反映了顾客的消费能力高低、毛利率指标则反映了顾客对门店的价值高低。同时，根据数据分析的层次不同，还可以细分为总体金银铜锡顾客群、门店金银铜锡顾客群（即按照门店分类进行归类）。 （2）客单价、客流量 这两个指标可以作为衡量顾客贡献度的常用参考指标。客单价指的是每张购物小票上的付款金额；客流量指的是每天的收银小票数量。 （3）客品数、品单价 客品数是指一段时间里顾客购买商品的平均数量（累计各单交易品种数之和/交易笔数），可以用来分析门店商品的广度和顾客的购物习惯，是否有一站式购齐的便捷性；品单价=客单价/客品数。 （4）商品关联性计算 首先分析确定一个最受关注的商品M，然后再寻找与这个M商品出现在同一张收银小票上的其他商品，然后计算得出这些商品与M商品的关联度。 （5）销售毛利率 （销售金额 - 销售成本）/ 销售金额 3、主要分析内容 借助BI分析平台的多元化展现特性，分别从如下角度对其4家门店的顾客数据进行了全面分析（介于篇幅有限，在此仅列出主要分析形式）： （1）各类顾客的整体构成分析 引自： http://www.yifanjie.com/read.php?52 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/432b633a0ac90c2b6e516e65089ffd77/" rel="bookmark">
			维度建模中处理空值的策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关系数据库中都支持空值（NULL）来表示数据不存在。但是在数据仓库中，一般不建议继续保留这些空值。下面介绍维度建模中的三种处理空值的策略。 1．事实表的外键为空值。 这种情况出现的原因主要有两个，一个是在数据抽取时外键值还不知道，另一个是在源系统中外键值丢失。这时，引用完整性遭到了破坏。第一种情况通常出现在累计快照事实表中，因为有些事件还没有发生，所以对应的时间不存在。这时，保留空值作为外键是不可取的，我们应该在日期维度中建立一条记录，标识为”还未发生“。然后将未发生的日期关联到该记录上。同样，对于第二种情况，我们应该在相应的维度表中建立记录，标识为”已丢失“。 2．事实表中的事实为空值。 这种情况下，空值通常有两种含义，一种是值不存在，另一种是系统没有记录该值。不论是哪一种，我们都应该将空值保留下来，大多数的数据库系统都能对空值很好的处理聚集函数，如SUM，MAX，MIN，COUNT，AVG。这时，将空值替换成零反而有可能使聚集函数不准。 3．维度表中的属性为空值。 维度表中的属性为空值可能是因为属性没有捕获到，或者属性不知道。这时，我们不应该保留空值，而应该将空值替换为”不知道“或者”未提供“之类。 总的来说，在数据仓库中空值容易引起误解，我们要尽可能的将空值替换成实际的值。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea8df3c0630c194348dcafc399bbec5f/" rel="bookmark">
			JBOSS之性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了优化jboss的性能，对jboss服务器做如下改动：
设置jvm 参数 安装jboss-native 降低jboss输出日志的等级 起用了jboss内的tomcat对传输数据的压缩功能 使用ehcache做hibernate的二级缓存 下面就以上的各改动做详细说明，为了表述方便&lt;jboss&gt;代表jboss的安装目录：
设置 jvm 参数
编辑&lt;jboss&gt;/bin/run.conf, 在文件的底部找到对参数JAVA_OPTS进行设置的地方。这个参数会最后传到jvm里。其中 -Xms512m 代表jvm最少用 512m内存 -Xmx1024m 代表jvm最多使用 1024m内存
修改这个两参数，给jvm分配适当的内存，一般为服务器的3/4内存量，推荐至少使用4G内存。
另外添加两个参数 -XX:+UseParallelGC -XX:+UseParallelOldGC 这两个让服务并行回收内存空间。修改完成后，大致
为 JAVA_OPTS = “-Xms4096m -Xmx8192m -XX:+UseParallelGC -XX:+UseParallelOldGC -Dsum…….
安装jbossNative
jboss的web container使用的 apache tomcat (http://www.apache.org)。 apache tomcat 有一个扩展包，使tomcat可以通过 java native interface 使用 apache portable runtime (APR)，而APR则是大名顶顶的apache httpd 网络服务器的运行时环境。用了这个扩展之后，就使得tomcat可以借助于apache httpd的力量，性能得以提升，尤其是处理静态文件时效率更高。Jboss native，实际上就是tomcat的这个native的扩展，只不过被jboss又添进了一些为了和jboss更好协作而加进去的东西。
要安装jboss native, 按以下步骤进行:
请到jboss的网站上下载，地址是 http://www.jboss.org/jbossweb/downloads/jboss-native/?action=a&amp;windowstate=maximized, 依据服务器环境选择合适的版本。
解压下载后的压缩包到某个目录，比如 jbossNative目录
将jbossNative/bin/META-INF/bin/linux2/x86/openssl 复制到&lt;jboss&gt;/bin
在&lt;jboss&gt;/bin目录里建一个文件夹，名为 native
把jbossNative/bin/META-INF/lib/linux2/x86/ 目录下所有内容复制到上一步建好的&lt;jboss&gt;/bin/native目录下
降低jboss输出日志的等级
打开 &lt;jboss&gt;/server/default/conf/jboss-log4j.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea8df3c0630c194348dcafc399bbec5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2731386ac3a98b4af35aae66426248f6/" rel="bookmark">
			ios上libevent在dns解析时崩溃的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在window和mac，甚至模拟器里都一切正常，就是在iPad机器上崩溃了。
libevent版本：2.0.11-stable
1. 在DNS解析时需要使用ARC4RANDOM算法生成transaction id，而ios自带的算法库有问题，会导致崩溃。还好，libevents提供了另一套替代的算法库，使用该算法库可以不崩溃。
Evutil_rand.c里，去掉_EVENT_HAVE_ARC4RANDOM定义
这时，arc4random_buf和arc4random_addrandom与系统提供的实现命名冲突，修改一个名字即可，同时修改arc4random.c文件。
2. Ipad上读取DNS配置有问题，所以不能读取系统配置，而要单独设置域名解析服务器，比如Google的域名解析服务器8.8.8.8。
_dns_base = evdns_base_new(_base, 0);
evdns_base_nameserver_ip_add(_dns_base, "8.8.8.8"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9218aa92e068c03d2007ce0cb4564f7/" rel="bookmark">
			Dir命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显示目录文件和子目录列表。如果在没有参数的情况下使用，则 dir 显示磁盘的卷标和序列号，后接磁盘上目录和文件的列表，包括它们的名称和最近修改的日期及时间。dir 可以显示文件的扩展名以及文件的字节大小。Dir 也显示列出的文件及目录的总数、累计大小和磁盘上保留的可用空间（以字节为单位）。
MS-DOS命令语法 dir [Drive:][Path][FileName] [...] [/p] [/q] [/w] [/d] [/a[[:]attributes]][/o[[:]SortOrder]] [/t[[:]TimeField]] [/s] [/b] [/l] [/n] [/x] [/c] [/4]
MS-DOS命令参数 [Drive:][Dath] 指定要查看列表的驱动器和目录。 [FileName] 指定要查看列表的特定文件或一组文件。 /p 每次显示一个列表屏幕。要查看下一屏，请按键盘上的任意键。 /q 显示文件所有权信息。 /w 以宽格式显示列表，在每一行上最多显示 5 个文件名或目录名。 /d 与 /w 相同，但是文件按列排序。 /a[[:]attributes] 只显示那些指定属性的目录和文件名称。如果省略 /a，dir 将显示除隐藏文件和系统文件之外的所有文件名。如果在没有指定 attributes 的情况下使用 /a，dir 显示所有文件的名称，包括隐藏文件和系统文件。以下列表描述了每个可用于 attributes 的值。冒号 (:) 是可选的。使用这些值的组合，并且不得用空格分隔这些值。 值说明h隐藏文件s系统文件d目录a准备好存档的文件r只读文件-h非隐藏的文件-s系统文件以外的文件/d只是文件（而非目录）-a自上次备份后没有更改过的文件-r非只读的文件 /o [[:]SortOrder] 控制 dir 排序和显示目录名和文件名的顺序。如果省略 /o，dir 将按它们在目录中出现的顺序显示名称。如果在没有指定 SortOrder 的情况下使用 /o，dir 显示按字母顺序排列的目录名，然后显示按字母顺序排列的文件名。冒号 (:) 是可选的。以下列表描述了每个可用于 SortOrder 的值。使用这些值的任意组合，并不要用空格分隔这些值。 值说明n按名称的字母顺序e按扩展名的字母顺序d按日期和时间，最早的优先。s按大小，最小的优先g在文件之前分组的目录-n按名称的逆序字母（从Z 到 A）排序-e按扩展名的逆序字母（从.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9218aa92e068c03d2007ce0cb4564f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aa4382cf5b2dd9605621eacad27eb25/" rel="bookmark">
			APK安装过程及原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自华为内部资料
PackageInstaller 原理简述
应用安装是智能机的主要特点，即用户可以把各种应用（如游戏等）安装到手机上，并可以对其进行卸载等管理操作。APK是Android Package的缩写，即Android安装包。APK是类似Symbian Sis或Sisx的文件格式。通过将APK文件直接传到Android模拟器或Android手机中执行即可安装。
Android应用安装有如下四种方式
1. 系统应用安装――开机时完成，没有安装界面
2. 网络下载应用安装――通过market应用完成，没有安装界面
3. ADB工具安装――没有安装界面。
4. 第三方应用安装――通过SD卡里的APK文件安装，有安装界面，由packageinstaller.apk应用处理安装及卸载过程的界面。
应用安装的流程及路径 应用安装涉及到如下几个目录：
system/app 系统自带的应用程序，无法删除
data/app
用户程序安装的目录，有删除权限。
安装时把apk文件复制到此目录
data/data
存放应用程序的数据
Data/dalvik-cache
将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)
安装过程：复制APK安装包到data/app目录下，解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录，并data/data目录下创建对应的应用数据目录。
卸载过程：删除安装过程中在上述三个目录下创建的文件及目录。
一、系统应用安装： PackageManagerService处理各种应用的安装，卸载，管理等工作，开机时由systemServer启动此服务
(源文件路径：android\frameworks\base\services\java\com\android\server\PackageManagerService.java)
PackageManagerService服务启动的流程：
1. 首先扫描安装“system\framework”目录下的jar包
1. scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,
scanMode | SCAN_NO_DEX);
2.第二步扫描安装“system\app”目录下的各个系统应用
scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM, scanMode);
3.第三步扫描“data\app”目录，即用户安装的第三方应用
scanDirLI(mAppInstallDir, 0, scanMode);
4.第四步扫描" data\app-private"目录，即安装DRM保护的APK文件（目前没有遇到过此类的应用）。
scanDirLI(mDrmAppPrivateInstallDir,0, scanMode | SCAN_FORWARD_LOCKED);
安装应用的过程
1.scanDirLI(Filedir, int flags, int scanMode) 遍历安装指定目录下的文件
2.scanPackageLI(FilescanFile,
File destCodeFile, FiledestResourceFile, int parseFlags,
int scanMode) 安装package文件
3.scanPackageLI(
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aa4382cf5b2dd9605621eacad27eb25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b0976d657a9e8a0869dcd51d56da98/" rel="bookmark">
			android创建文件夹和文件的一些经验教训
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android创建文件夹和文件的一些经验教训 这几天做一个功能需要在手机上创建一个文件夹，然后往里面存储一些文件，首先得考虑用户有没有sdcard，如果有就在sdcard上创建一个指定的文件夹，如果没有则在你的工程所在的目录“/data/data/你的包名”下创建文件夹。用到的方法是：
首先判断sdcard是否插入
String status = Environment.getExternalStorageState();
if (status.equals(Environment.MEDIA_MOUNTED)) {
return true;
} else {
return false;
}
然后根据是否插入状态指定目录
if (SdcardHelper.isHasSdcard()) {
sDir = SDCARD_DIR;
} else {
sDir = NOSDCARD_DIR;
}
然后是创建文件夹
File destDir = new File(sDir);
if (!destDir.exists()) {
destDir.mkdirs();
}
问题是：刚开始我的文件夹的目录是按照windows方式的例如"\sdcard\tempdir"结果运行后也不报错但是怎么也创建不了文件夹，后面想到应该是按linux格式的目录，改为"/sdcard/tempdir"后即可成功创建。
因为之前创建文件都是按照windows方式例如"\sdcard\test.txt"调用
new File("\\sdcard\\test.txt").createNewFile();创建而且可以成功，所以目录就没考虑。
经验证创建文件夹使用windows或者linux的目录结构都可以，而目录的话必须用linux的格式。
注：如果是1.6版本的话，需要注册sdcard权限才能正常建立文件夹及写入文件. 2.2以上不需要
&lt;!--往sdcard中写入数据的权限 --&gt;
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"&gt;&lt;/uses-permission&gt;
&lt;!--在sdcard中创建/删除文件的权限 --&gt;
&lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"&gt;&lt;/uses-permission&gt;
posted on 2011-06-10 01:04 流光映雪 阅读( ...) 评论( ...) 编辑 收藏 转载于:https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b0976d657a9e8a0869dcd51d56da98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7e5dcc2f4b98288343134f59559fcd6/" rel="bookmark">
			常见的XML的两种解析方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XML优点：平台无关性,语言无关性,系统无关性
XML在不同的语言里解析方式都是一样的,只不过实现的语法不同而已。基本的解析方式有两种,一种叫SAX，另一种叫DOM。SAX是基于事件流的解析,DOM是基于XML文档树结构的解析.假设我们XML的内容和结构如下: &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;employees&gt; &lt;employee&gt; &lt;name&gt;ddviplinux&lt;/name&gt; &lt;sex&gt;m&lt;/sex&gt; &lt;age&gt;30&lt;/age&gt; &lt;/employee&gt; &lt;/employees&gt; 下面是解析XMl常用的Dom和Sex方法：
1.DOM生成和解析XML文档
为 XML 文档的已解析版本定义了一组接口。解析器读入整个文档，然后构建一个驻留内存的树结构，然后代码就可以使用 DOM 接口来操作这个树结构。优点：整个文档树在内存中，便于操作；支持删除、修改、重新排列等多种功能；缺点：将整个文档调入内存（包括无用的节点），浪费时间和空间；使用场合：一旦解析了文档还需多次访问这些数据；硬件资源充足（内存、CPU）。 public void parserXml(String fileName) { try { DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();DocumentBuilder db = dbf.newDocumentBuilder(); Document document = db.parse(fileName); NodeList employees = document.getChildNodes(); for (int i = 0; i &lt; employees.getLength(); i++) { Node employee = employees.item(i); NodeList employeeInfo = employee.getChildNodes(); for (int j = 0; j &lt; employeeInfo.getLength(); j++) { Node node = employeeInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7e5dcc2f4b98288343134f59559fcd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8af144296c5b6e3f1725563a9ee43152/" rel="bookmark">
			人脸识别发展历史介绍 by 山世光
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 引言
在我们生存的这个地球上，居住着近65亿人。每个人的面孔都由额头、眉毛、眼睛、鼻子、嘴巴、双颊等少数几个区域组合而成，它们之间的大体位置关系也是固定的，并且每张脸的大小不过七八寸见方。然而，它们居然就形成了那么复杂的模式，即使是面容极其相似的双胞胎，其家人通常也能够非常容易地根据他们面孔上的细微差异将他们区分开来。这使得我们不得不承认这个世界上找不出两张完全相同的人脸!那么，区分如此众多的不同人脸的“特征”到底是什么?能否设计出具有与人类一样的人脸识别能力的自动机器?这种自动机器的人脸识别能力是否能够超越人类自身?对这些问题的分析和解答无疑具有重要的理论和应用价值，这正是众多从事自动人脸识别研究的研究人员所面临的挑战。
然而，对这些问题的回答并不像看起来那么容易。即使在大量来自模式识别、计算机视觉、神经计算、生理学等领域的研究人员对自动人脸识别艰苦工作40余年之后，这些最基本的科学问题仍然困惑着研究人员。而退一步讲，即使对我们自己，尽管我们每天都在根据面孔区分着亲人、同学、朋友、同事等，大多数人却很难准确地描述出自己到底是如何区分他们的，甚至描述不出自己熟悉的人有什么具体的特征。即使专门从事相关的生理学、心理学、神经科学研究的一些专家，也很难描述清楚人类人脸识别的生理学过程。这意味着基于仿生学的人脸识别研究路线在实践上是难以操作的。当然，飞机的翅膀并不需要像鸟儿的翅膀一样煽动，自动人脸识别的计算模型也未必需要模拟“人脑”。我们也许可以通过另外的途径，例如建立人脸识别的计算模型，这种计算模型可能是基于仿生神经网络的，也可能是纯粹基于统计的，或者是这二者之外的第三只眼睛，并通过构建实用的自动人脸识别系统来验证这些计算模型，从而找出对上述基本科学问题的解答。
本文首先给出了人脸识别的一个一般计算模型，然后简单回顾自动人脸识别的研究历史，接下来阐述人脸识别的研究现状并介绍几种主流的技术方法，简单介绍计算所人脸识别研究组的研究进展，最后对上述哲学层面的问题作了一些简单的探讨。
2 人脸识别发展历史
人脸识别是一个被广泛研究着的热门问题，大量的研究论文层出不穷，在一定程度上有泛滥成“灾”之嫌。为了 更好地对人脸识别研究的历史和现状进行介绍，本文将AFR的研究历史按照研究内容、技术方法等方面的特点大体划分为三个时间阶段，如表1所示。该表格概括了人脸识别研究的发展简史及其每个历史阶段代表性的研究工作及其技术特点。下面对三个阶段的研究进展情况作简单介绍：
第一阶段(1964年~1990年)
这一阶段人脸识别通常只是作为一个一般性的模式识别问题来研究，所采用的主要技术方案是基于人脸几何结构特征(Geometric feature based)的方法。这集中体现在人们对于剪影(Profile)的研究上，人们对面部剪影曲线的结构特征提取与分析方面进行了大量研究。人工神经网络也一度曾经被研究人员用于人脸识别问题中。较早从事AFR研究的研究人员除了布莱索(Bledsoe)外还有戈登斯泰因(Goldstein)、哈蒙(Harmon)以及金出武雄(Kanade Takeo)等。金出武雄于1973年在京都大学完成了第一篇AFR方面的博士论文，直到现在，作为卡内基-梅隆大学(CMU)机器人研究院的一名教授，仍然是人脸识别领域的活跃人物之一。他所在的研究组也是人脸识别领域的一支重要力量。总体而言，这一阶段是人脸识别研究的初级阶段，非常重要的成果不是很多，也基本没有获得实际应用。
第二阶段(1991年~1997年)
这一阶段尽管时间相对短暂，但却是人脸识别研究的高潮期，可谓硕果累累：不但诞生了若干代表性的人脸识别算法，美国军方还组织了著名的FERET人脸识别算法测试，并出现了若干商业化运作的人脸识别系统，比如最为著名的Visionics(现为Identix)的FaceIt系统。
美国麻省理工学院(MIT)媒体实验室的特克(Turk)和潘特兰德(Pentland)提出的“特征脸”方法无疑是这一时期内最负盛名的人脸识别方法。其后的很多人脸识别技术都或多或少与特征脸有关系，现在特征脸已经与归一化的协相关量(Normalized Correlation)方法一道成为人脸识别的性能测试基准算法。
这一时期的另一个重要工作是麻省理工学院人工智能实验室的布鲁内里(Brunelli)和波基奥(Poggio)于1992年左右做的一个对比实验，他们对比了基于结构特征的方法与基于模板匹配的方法的识别性能，并给出了一个比较确定的结论：模板匹配的方法优于基于特征的方法。这一导向性的结论与特征脸共同作用，基本中止了纯粹的基于结构特征的人脸识别方法研究，并在很大程度上促进了基于表观(Appearance-based)的线性子空间建模和基于统计模式识别技术的人脸识别方法的发展，使其逐渐成为主流的人脸识别技术。
贝尔胡米尔(Belhumeur)等提出的Fisherface人脸识别方法是这一时期的另一重要成果。该方法首先采用主成分分析(Principal Component Analysis，PCA，亦即特征脸)对图像表观特征进行降维。在此基础上，采用线性判别分析(Linear Discriminant Analysis, LDA)的方法变换降维后的主成分以期获得“尽量大的类间散度和尽量小的类内散度”。该方法目前仍然是主流的人脸识别方法之一，产生了很多不同的变种，比如零空间法、子空间判别模型、增强判别模型、直接的LDA判别方法以及近期的一些基于核学习的改进策略。
麻省理工学院的马哈丹(Moghaddam)则在特征脸的基础上，提出了基于双子空间进行贝叶斯概率估计的人脸识别方法。该方法通过“作差法”，将两幅人脸图像对的相似度计算问题转换为一个两类(类内差和类间差)分类问题，类内差和类间差数据都要首先通过主成分分析(PCA)技术进行降维，计算两个类别的类条件概率密度，最后通过贝叶斯决策(最大似然或者最大后验概率)的方法来进行人脸识别。
人脸识别中的另一种重要方法——弹性图匹配技术(Elastic Graph Matching，EGM) 也是在这一阶段提出的。其基本思想是用一个属性图来描述人脸：属性图的顶点代表面部关键特征点，其属性为相应特征点处的多分辨率、多方向局部特征——Gabor变换[12]特征，称为Jet;边的属性则为不同特征点之间的几何关系。对任意输入人脸图像，弹性图匹配通过一种优化搜索策略来定位预先定义的若干面部关键特征点，同时提取它们的Jet特征，得到输入图像的属性图。最后通过计算其与已知人脸属性图的相似度来完成识别过程。该方法的优点是既保留了面部的全局结构特征，也对人脸的关键局部特征进行了建模。近来还出现了一些对该方法的扩展。
局部特征分析技术是由洛克菲勒大学(Rockefeller University)的艾提克(Atick)等人提出的。LFA在本质上是一种基于统计的低维对象描述方法，与只能提取全局特征而且不能保留局部拓扑结构的PCA相比，LFA在全局PCA描述的基础上提取的特征是局部的，并能够同时保留全局拓扑信息，从而具有更佳的描述和判别能力。LFA技术已商业化为著名的FaceIt系统，因此后期没有发表新的学术进展。
由美国国防部反毒品技术发展计划办公室资助的FERET项目无疑是该阶段内的一个至关重要的事件。FERET项目的目标是要开发能够为安全、情报和执法部门使用的AFR技术。该项目包括三部分内容：资助若干项人脸识别研究、创建FERET人脸图像数据库、组织FERET人脸识别性能评测。该项目分别于1994年，1995年和1996年组织了3次人脸识别评测，几种最知名的人脸识别算法都参加了测试，极大地促进了这些算法的改进和实用化。该测试的另一个重要贡献是给出了人脸识别的进一步发展方向：光照、姿态等非理想采集条件下的人脸识别问题逐渐成为热点的研究方向。
柔性模型(Flexible Models)——包括主动形状模型(ASM)和主动表观模型(AAM)是这一时期内在人脸建模方面的一个重要贡献。ASM/AAM将人脸描述为2D形状和纹理两个分离的部分，分别用统计的方法进行建模(PCA)，然后再进一步通过PCA将二者融合起来对人脸进行统计建模。柔性模型具有良好的人脸合成能力，可以采用基于合成的图像分析技术来对人脸图像进行特征提取与建模。柔性模型目前已被广泛用于人脸特征对准(Face Alignment)和识别中，并出现了很多的改进模型。
总体而言，这一阶段的人脸识别技术发展非常迅速，所提出的算法在较理想图像采集条件、对象配合、中小规模正面人脸数据库上达到了非常好的性能，也因此出现了若干知名的人脸识别商业公司。从技术方案上看， 2D人脸图像线性子空间判别分析、统计表观模型、统计模式识别方法是这一阶段内的主流技术。
第三阶段(1998年~现在)
FERET’96人脸识别算法评估表明：主流的人脸识别技术对光照、姿态等由于非理想采集条件或者对象不配合造成的变化鲁棒性比较差。因此，光照、姿态问题逐渐成为研究热点。与此同时，人脸识别的商业系统进一步发展。为此，美国军方在FERET测试的基础上分别于2000年和2002年组织了两次商业系统评测。
基奥盖蒂斯(Georghiades)等人提出的基于光照锥 (Illumination Cones) 模型的多姿态、多光照条件人脸识别方法是这一时期的重要成果之一，他们证明了一个重要结论：同一人脸在同一视角、不同光照条件下的所有图像在图像空间中形成一个凸锥——即光照锥。为了能够从少量未知光照条件的人脸图像中计算光照锥，他们还对传统的光度立体视觉方法进行了扩展，能够在朗博模型、凸表面和远点光源假设条件下，根据未知光照条件的7幅同一视点图像恢复物体的3D形状和表面点的表面反射系数(传统光度立体视觉能够根据给定的3幅已知光照条件的图像恢复物体表面的法向量方向)，从而可以容易地合成该视角下任意光照条件的图像，完成光照锥的计算。识别则通过计算输入图像到每个光照锥的距离来完成。
以支持向量机为代表的统计学习理论也在这一时期内被应用到了人脸识别与确认中来。支持向量机是一个两类分类器，而人脸识别则是一个多类问题。通常有三种策略解决这个问题，即：类内差/类间差法、一对多法(one-to-rest)和一对一法(one-to-one)。
布兰兹(Blanz)和维特(Vetter)等提出的基于3D变形(3D Morphable Model)模型的多姿态、多光照条件人脸图像分析与识别方法是这一阶段内一项开创性的工作。该方法在本质上属于基于合成的分析技术，其主要贡献在于它在3D形状和纹理统计变形模型(类似于2D时候的AAM)的基础上，同时还采用图形学模拟的方法对图像采集过程的透视投影和光照模型参数进行建模，从而可以使得人脸形状和纹理等人脸内部属性与摄像机配置、光照情况等外部参数完全分开，更加有利于人脸图像的分析与识别。Blanz的实验表明，该方法在CMU-PIE(多姿态、光照和表情)人脸库和FERET多姿态人脸库上都达到了相当高的识别率，证明了该方法的有效性。
2001年的国际计算机视觉大会(ICCV)上，康柏研究院的研究员维奥拉(Viola)和琼斯(Jones)展示了他们的一个基于简单矩形特征和AdaBoost的实时人脸检测系统，在CIF格式上检测准正面人脸的速度达到了每秒15帧以上。该方法的主要贡献包括：1)用可以快速计算的简单矩形特征作为人脸图像特征;2)基于AdaBoost将大量弱分类器进行组合形成强分类器的学习方法;3)采用了级联(Cascade)技术提高检测速度。目前，基于这种人脸/非人脸学习的策略已经能够实现准实时的多姿态人脸检测与跟踪。这为后端的人脸识别提供了良好的基础。
沙苏哈(Shashua)等于2001年提出了一种基于商图像[13]的人脸图像识别与绘制技术。该技术是一种基于特定对象类图像集合学习的绘制技术，能够根据训练集合中的少量不同光照的图像，合成任意输入人脸图像在各种光照条件下的合成图像。基于此，沙苏哈等还给出了对各种光照条件不变的人脸签名(Signature)图像的定义，可以用于光照不变的人脸识别，实验表明了其有效性。
巴斯里(Basri)和雅各布(Jacobs)则利用球面谐波(Spherical Harmonics)表示光照、用卷积过程描述朗博反射的方法解析地证明了一个重要的结论：由任意远点光源获得的所有朗博反射函数的集合形成一个线性子空间。这意味着一个凸的朗博表面物体在各种光照条件下的图像集合可以用一个低维的线性子空间来近似。这不仅与先前的光照统计建模方法的经验实验结果相吻合，更进一步从理论上促进了线性子空间对象识别方法的发展。而且，这使得用凸优化方法来强制光照函数非负成为可能，为光照问题的解决提供了重要思路。
FERET项目之后，涌现了若干人脸识别商业系统。美国国防部有关部门进一步组织了针对人脸识别商业系统的评测FRVT，至今已经举办了两次：FRVT2000和FRVT2002。这两次测试一方面对知名的人脸识别系统进行了性能比较，例如FRVT2002测试就表明Cognitec, Identix和Eyematic三个商业产品遥遥领先于其他系统，而它们之间的差别不大。另一方面则全面总结了人脸识别技术发展的现状：较理想条件下(正面签证照)，针对37437人121,589 幅图像的人脸识别(Identification)最高首选识别率为73%，人脸验证(Verification)的等错误率(EER[14])大约为6%。FRVT测试的另一个重要贡献是还进一步指出了目前的人脸识别算法亟待解决的若干问题。例如，FRVT2002测试就表明：目前的人脸识别商业系统的性能仍然对于室内外光照变化、姿态、时间跨度等变化条件非常敏感，大规模人脸库上的有效识别问题也很严重，这些问题都仍然需要进一步的努力。
总体而言，目前非理想成像条件下(尤其是光照和姿态)、对象不配合、大规模人脸数据库上的人脸识别问题逐渐成为研究的热点问题。而非线性建模方法、统计学习理论、基于Boosting[15]的学习技术、基于3D模型的人脸建模与识别方法等逐渐成为备受重视的技术发展趋势。
3 结束语
人脸识别是一项既有科学研究价值，又有广泛应用前景的研究课题。国际上大量研究人员几十年的研究取得了丰硕的研究成果，自动人脸识别技术已经在某些限定条件下得到了成功应用。这些成果更加深了我们对于自动人脸识别这个问题的理解，尤其是对其挑战性的认识。尽管在海量人脸数据比对速度甚至精度方面，现有的自动人脸识别系统可能已经超过了人类，但对于复杂变化条件下的一般人脸识别问题，自动人脸识别系统的鲁棒性和准确度还远不及人类。这种差距产生的本质原因现在还不得而知，毕竟我们对于人类自身的视觉系统的认识还十分肤浅。但从模式识别和计算机视觉等学科的角度判断，这既可能意味着我们尚未找到对面部信息进行合理采样的有效传感器(考虑单目摄像机与人类双眼系统的差别)，更可能意味着我们采用了不合适的人脸建模方法(人脸的内部表示问题)，还有可能意味着我们并没有认识到自动人脸识别技术所能够达到的极限精度。但无论如何，赋予计算设备与人类似的人脸识别能力是众多该领域研究人员的梦想。相信随着研究的继续深入，我们的认识应该能够更加准确地逼近这些问题的正确答案。
计算所人脸识别课题组经过多年努力，终于逐渐进入了国际人脸识别竞争的第一方阵。我们提出的新颖算法、完成的高效识别系统也逐渐得到了国内外同行的认可。但我们也必须清醒地看到，在人脸识别领域，其实很难说谁的算法就比别的算法真正地好了多少。而且众多的研究人员正在加入进来，逆水行舟，慢进则退。我们必须付出更多的艰辛才能真正在算法和系统两方面超越前人，取得更大的研究成果!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b101956e22f1f8ced08b5e4d907da5/" rel="bookmark">
			【linux】设备驱动动态中断申请
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!-- @page { margin: 0.79in } P { margin-bottom: 0.08in } --&gt; Kernel Korner - Dynamic Interrupt Request Allocation for Device Drivers From Issue #132 April 2005 Mar 01, 2005 By Dr B. Thangaraju inSoftware
中断是处理器和设备沟通的大门。在设备驱动开发中，申请中断请求线（后文简称中断）以及如何处理中断是至关重要的。中断的数量是有限的，共享中断可以让处理器访问更多的设备。尝试申请已经使用的中断会破坏系统。这篇介绍了中断的使用以及如何在一个字符设备中使用中断。
中断是一个硬件机制，可以使设备和处理器交互。
在2.6内核中，Linux中，如果一个进程在kernel mode，如果任意一个高优先级的进程到了ready-to-run的进程队列，低优先级的进程就不能在该高优先级的进程返回用户模式之前抢占。但是，一个中断可以使CPU转移注意力，即便进程在内核模式内执行。当一个中断发生时，CPU挂起当前的任务，执行一些中断相关的代码。
每一个在计算机中的设备有一个设备控制器，当他需要CPU服务时，就会通过一个硬件引脚发出信号。这个硬件引脚和CPU的中断引脚相连。处理器中连接到控制器处理中断的引脚叫中断请求线（IRQ， Interrupt request line）。CPU有若干个这样的引脚。在现代操作系统中，有意个可编程的中断控制器（PIC，programmable interrupt controller)来管理处理器和各种设备控制器之间的IRQ。IRQ是有限的，Linux通过共享中断线来增加可以产生中断的设备。
当CPU执行一个进程，一个设备发送中断到CPU，比如准备传输数据。当一个中断到来，CPU立即保存当前kernel mode stack的 program counter，然后执行对应的中断服务（ISR，interrupt service routine)。一个ISR是一个处于kernel中的函数，用来处理中断的一些请求，比如移动数据等等。执行完ISR，CPU就恢复到之前的进行，然后接着执行。
设备驱动程序是一个在kernel中的软件模块，等到来自应用程序的请求。当一个程序需要从设备中读取数据，对应的设备驱动器就会立即打开，然后对应的设备就会被打开准备读取。如果系统在等待一个慢速设备，就不能做其他事情。为了避免等待，kernel把等待的工作交给设备控制器，然后恢复执行之前的进程。当读完毕之后，设备通过中断通知CPU，CPU执行相应的ISR。
Interrupt classification
中断分为两类，同步和异步。同步中断是CPU control unit在执行指令时产生的。控制单元在终止指令之后产生一个中断，就命名为同步。异步中断是硬件按照CPU时钟在任意时间产生的。在Intel系统中，同步中断被称之为异常，异步中断称之位中断。中断通过一个无符号的one-byte整数表示，称之为向量，范围是0~255。最开始的32个向量（0～31)用于异常和不可屏蔽中断，32～47是可屏蔽中断，由IRQs(0-15)引起。最后的48~255被标记为软件中断。
IRQ Allocation
通过/proc/interrupt可以显示当前注册的中断。比如：
CPU0 CPU1 0: 112559049 0 IO-APIC-edge timer 1: 143195 0 IO-APIC-edge i8042 8: 1 0 IO-APIC-edge rtc0 9: 36 0 IO-APIC-fasteoi acpi 12: 2134767 0 IO-APIC-edge i8042 14: 430047 0 IO-APIC-edge ata_piix 15: 318204 0 IO-APIC-edge ata_piix 16: 64752 0 IO-APIC-fasteoi i915@pci:0000:00:02.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58b101956e22f1f8ced08b5e4d907da5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a11157d78d48e5bb0391fd397fae1206/" rel="bookmark">
			DMA (wiki)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!-- @page { margin: 0.79in } P { margin-bottom: 0.08in } --&gt; DMA
DMA是现代计算机和微处理器的一个特性，DMA允许一些计算机内的硬件系统可以不依赖与中央处理器而直接读写系统内存。比如磁盘驱动控制器，图形卡，网卡以及声卡都会使用DMA。在多处理器的SOC系统中，DMA也用于片内（intra-chip）数据传输，特别是，当处理一些包含有内存的的模块（经常称为scratchpad memory）时，DMA用于从这些模块内的内存和主内存的数据传输。
用DMA通道的计算机与没有DMA通道的计算机在设备和系统内传输数据，会有较小的cpu负荷，因为不依赖与CPU，所以数据传输不占用CPU时间，数据传输就和CPU其他的工作并发进行。
没有DMA，使用可编程的输入输入（programmed input/output)模型来和外设设备交互，或者来加载保存多核指令，CPU通常完成会被读写操作占用，而不能去做其他工作。
使用DMA，CPU可以发起数据传输，在数据传输过程中可以做其他事情，然后在传输完成后，收到DMA控制器的一个中断。这在实时系统中很有效。此外在流处理中也很有效，因为流处理一般要数据和控制并发，采用DMA就可以达到很高的吞吐率。
Principle
DMA是现代计算机的一个本质特性，允许数据不依赖与CPU而进行传输。如果没有DMA，那么CPU就需要亲自来拷贝数据，而不能同时进行其他工作。这种情况很糟糕，因为通过一个外围总线访问I/O设备比普通的的系统RAM要慢很多。
DMA从一个设备拷贝到另一个设备。当DMA命令让CPU发起一个DMA传输，CPU不会花功夫执行,DMA会处理数据传输。对于称为第三方的DMA，比如使用ISA bus的，DMA控制器通常是主板的一个芯片。更现代的一些总线设计，比如PCI，通常是总线驱动DMA，这时候是设备取得bus的控制，然后实施DMA。在嵌入式处理器或者多核的SOC中，片上总线会链接有一个DMA engine，这个DMA engine会管理DMA数据传输。
DMA的典型应用是系统RAM和设备之间的数据传输。在多核的嵌入式系统中，通常有一个或者多个DMA engine。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbde5c895d288e1405f5b12659ad3f92/" rel="bookmark">
			vc&#43;&#43; MFC   一些控件使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		combo box CComboBox m_combobox;
m_combobox.AddString(L"COM0");
m_combobox.AddString(L"COM1");
m_combobox.AddString(L"COM2");
m_combobox.AddString(L"COM3");
m_combobox.AddString(L"COM4");
m_combobox.AddString(L"COM5");
m_combobox.AddString(L"COM6");
m_combobox.AddString(L"COM7");
m_combobox.AddString(L"COM8");
m_combobox.SetCurSel(8);
m_combobox.GetCurSel(8);
m_ComboBox.ResetContent();//清除combobox 的所有内容
m_ComboBox.GetCount();//取得目前已经有的行
m_ComboBox.DeleteString( UINT nIndex )//删除指定行，
m_cbExample.InsertString( nIndex, “StringData” );
获取当前内容
m_ComboBox.GetWindowText(strTemp);
获取其他行内容
m_ComboBox.GetLBText(n,strTemp);
画combo box控件的时候，鼠标点击combo box的箭头位置，然后调整高度到一定高度即可。 static text GetDlgItem(static text id)-&gt;SetWindowText(_T("文本内容"));
edit control
GetDlgItem(editID)-&gt;SetWindowText(_T("文本内容"));
static control
//设置字体
CFont * f = new CFont; f-&gt;CreateFont(16,0,0,0,FW_BOLD,false,false,0,
ANSI_CHARSET, // nCharSet OUT_DEFAULT_PRECIS, // nOutPrecision CLIP_DEFAULT_PRECIS, // nClipPrecision DEFAULT_QUALITY, // nQuality DEFAULT_PITCH | FF_SWISS, // nPitchAndFamily _T("Arial"));// lpszFac
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbde5c895d288e1405f5b12659ad3f92/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/483/">«</a>
	<span class="pagination__item pagination__item--current">484/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/485/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>