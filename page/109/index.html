<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e2a9ac1bb163441eaba04d64113298c/" rel="bookmark">
			关于model.load_state_dict(state_dict)报错出现权重与模型不匹配的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题
model.load_state_dict(state_dict)报错出现权重与模型不匹配
TypeError: valid_step() got an unexpected keyword argument 'update_num' 二、原因分析
保存模型时可能将该模型的BLEU等非模型权重的参数一同保存了（该参数用于比较得出checkpoint_best，应该是有被存储下来的)
三、解决方案
1）根据报错内容定位到代码的位置。
2）将 model.load_state_dict 的strict参数指定为false，即
model.load_state_dict(state_dict, strict=False) 四、参考博客
(82条消息) model.load_state_dict(state_dict, strict=False)_load_state_dict strict=false_Tchunren的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/264a7c96a053160164c2b88e8777a5ef/" rel="bookmark">
			烘焙小程序蛋糕店烘焙店源码点心店小程序源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系统开发使用JAVA技术栈开发
使用uniapp技术栈 支持微信小程序 ，对接打印机，对接第三方同城跑腿平台
用户端使用：uniapp
管理端使用：vue+elementui
后台服务使用：springboot+jpa
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a971150caf2b8aa202503935ae3ae029/" rel="bookmark">
			Element-plus将默认语言设置为中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里大字说明一下, 此教程为 2023/7/31发布, 目前使用Element-plus版本为^2.3.8, 2.+ 版本可以尝试以下方法 import ElementPlus from 'element-plus'; //引入Element-ui import zhCN from "element-plus/dist/locale/zh-cn.mjs" //引入中文 const app =createApp(App) app.use(ElementPlus, {locale:zhCN}) 在我找方法的时候我还看到有1.+版本的教程, 链接放在下面 https://juejin.cn/post/6999826831054471198
一定要对应好版本
一定要对应好版本
一定要对应好版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/026e9ddc9aeb25440eb2da4aacfbd2b4/" rel="bookmark">
			视频分类（Video Classification）任务概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频分类任务概述 视频分类任务目的视频分类任务数据集视频分类模型视频分类应用场景如何训练模型和部署结尾 视频分类任务目的 视频分类是给定一个视频，为其划分到指定的类别中。视频分类与图像分类相似，不同点在于图像分类是给定单张图片进行划分类别，视频分类是给定连续的图片数据，进行类别的划分。
视频分类任务数据集 UCF101：UCF101是一个现实动作视频的动作识别数据集，收集自YouTube，提供了来自101个动作类别的13320个视频。数据官方：link。Kinetics-400：Kinetics-400是一个大规模，高质量的YouTube视频网址数据集，其中包含 400 个动作类别。Kinetics-600： Kinetics-600 是 Kinetics-400 数据集的一个扩展。其中包含 600 个动作类别。 目前学术界主要以Kinetics-400、Kinetics-600为评估标准，并制作了大量预训练模型
视频分类模型 现阶段的模型主要以3d卷积和transformer为主，比较经典的模型有C3D、SlowFast论文地址，基于transformer的模型结构有MViT、Swin Transformer论文地址
我是基于pytorch进行工作和研究的，我目前发现pytorch提供如下预训练模型：
预训练模型准确度如下：
视频分类应用场景 直播平台鉴别违规行为工厂监督生产安防监控 如何训练模型和部署 由于视频分类涉及的内容较多，我想分多篇博客进行详细的讲解，在接下来的博客中我会详细讲述数据的预处理、模型的选型、训练与部署，如果对我的内容感兴趣，欢迎点赞收藏。
结尾 欢迎大家在评论区讨论、学习！
B站：Silver__Wolf_
Q：130856474
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/905a1405bed76350fc612333c2ab6619/" rel="bookmark">
			【编译】gcc make cmake Makefile CMakeList.txt 关系、使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一 关系二 gcc2.1 编译过程2.2 编译参数2.3 静态库和动态库1 后缀名2 联系与区别 2.4 GDB 调试器1 常用命令 三 make、makefile四 cmake、cmakelist4.1 语法特性4.2 重要命令4.2 重要变量4.3 编译流程4.4 两种构建方式 五 Vscode5.0 常用快捷键5.1 界面5.2 插件5.3 .vscode 文件夹1 launch.json2 task.json 一 关系 1 gcc是一种编译器。将源代码转为可执行文件。
当你的程序只有一个源文件时，直接就可以用gcc命令编译它。但当你的程序包含很多个源文件时，用gcc命令逐个去编译时，你就很容易混乱而且工作量大，所以出现了make工具。
2 make是一个批处理工具。在整个项目中管理编译过程。其依据是makefile文件。
3 makefile是一个文本文件，用于指挥make。其中包含一系列规则和命令。make 工具通过读取 makefile 中的规则来确定需要重新编译哪些文件，以及执行哪些命令来完成编译过程。
makefile在一些简单的工程完全可以用人工手写，但是当工程非常大的时候，手写makefile也是非常麻烦的，并且如果换了个平台makefile又要重新修改。这时候就出现了Cmake工具。
4 cmake是一个跨平台构建工具。cmake可以更加简单的生成makefile文件给make用。
5 cmakelist是一个文本文件，用于指挥cmake。
参考网址：http://t.csdn.cn/iNMcN
二 gcc 安装：
sudo apt update sudo apt install build-essential gdb 2.1 编译过程 预处理 -E .i 展开宏编译 -S .s c-&gt;汇编汇编 -c .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/905a1405bed76350fc612333c2ab6619/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e730051e214b24a060f7438dc3638965/" rel="bookmark">
			springSecurity自定义过滤器不生效问题排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用springSecurity过滤器的过程中，由于需要自定义一个过滤器处理数据问题。代码如下：
过滤器定义：
public class AuthRequestParamFiler extends GenericFilterBean { private static final CoreLogger LOGGER = CoreLoggerFactory.getLogger(AuthRequestParamFiler.class); @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest httpRequest = (HttpServletRequest) request; String path = httpRequest.getServletPath(); if(path.equals("/oauth/token")) { LOGGER.info("AuthRequestFiler 过滤器, path:{}", path); Map&lt;String, String&gt; requestMap = HttpUtil.getRequestPostMap(httpRequest); AuthParamRequestWrapper contentCachingRequestWrapper = new AuthParamRequestWrapper(httpRequest, requestMap); chain.doFilter(contentCachingRequestWrapper, response); } else { chain.doFilter(request, response); } } } 过滤器注册：
@Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) public class AuthWebServiceSecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private AuthUserDetailsService authUserDetailsService; /** * 对请求进行鉴权的配置 * https://zhuanlan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e730051e214b24a060f7438dc3638965/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a02303f90fc0a4e0a01efbe51e2bc68/" rel="bookmark">
			牛客网Verilog刷题——VL56
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		牛客网Verilog刷题——VL56 题目答案 题目 实现4bit无符号数流水线乘法器设计。电路的接口如下图所示：
输入输出描述：
信号类型输入/输出位宽描述clkwireInput1系统时钟信号rst_nwireInput1异步复位信号，低电平有效mul_awireInputsize乘数mul_bwireInputsize被乘数mul_outwireOutput2*size输出乘法结果 答案 `timescale 1ns/1ns module multi_pipe#( parameter size = 4 )( input clk , input rst_n	, input	[size-1:0]	mul_a	, input	[size-1:0]	mul_b	, output	reg	[size*2-1:0]	mul_out	); //无符号流水线乘法器：每个时钟都更新输入的乘数和被乘数，在一个或者多个时钟后连续输出乘法器乘法结果 wire	[7:0]	temp	[size-1:0]; //逐个比特乘法 reg	[7:0]	adder01,adder23; //加法器 genvar i; //逐个比特乘法 generate for(i=0;i&lt;size;i=i+1) begin:temp_block assign temp[i] = mul_b[i] ? mul_a&lt;&lt;i : 'd0; //用移位寄存器 //assign temp[i] = mul_b[i] ? {{(size-i){1'b0}},mul_a,{(i){1'b0}}} : 'd0; //用拼接符 end endgenerate //加法器 always @(posedge clk or negedge rst_n) begin if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a02303f90fc0a4e0a01efbe51e2bc68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63345e710a0f5046852e49a15ebadc07/" rel="bookmark">
			数据分析-关于指标和指标体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、电商指标体系 二、指标体系的作用 三、搭建指标体系的OSM方法 三、统计学中基本的分析手段 四、离散趋势 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f319be01fd784df19eb341fd9fae33a/" rel="bookmark">
			Mitmproxy的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.背景
2.Mitmproxy
1）Windows安装
2）定制开发
3）启动
3.使用
4.问题
5.参考资料
1.背景 简单来说，背景就两个字“偷懒”，一个字“懒”。在API自动化脚本的开发中，一般都需要封装一下接口。如果没有swagger等接口文档，常见做法就是人工操作页面，然后通过F12去查看这些API，再copy到脚本里面做处理。这个过程挺繁琐的，费时费力，还容易出错，尤其有特殊headers时，经常只有在调试才发现。当然，也可以通过工具录制这些API，jmeter/ badboy/ fiddler/ charles等等都行。可现实是，要么因为环境特殊录制不了，就算能录制也是一通复杂的配置；要么就是没有办法直接得到脚本，需要人工做导出操作。实在不符合“懒”的气质~~~于是，一直在思考有没有更“懒”的方法呢？
找了不少方法，中间过程就不赘述了，最后选择了mitmproxy，能用还能定制，就它了。
2.Mitmproxy MITM（Man-in-the-middle，中间人）简而言之就是个代理，可以拦截诸如HTTP/ SMTP/ SSL/ SOCK4/5协议类型的信息。区别于fiddler/ charles这样的工具，可以命令行或者脚本对数据做一些定制处理。
1）Windows安装 第一步：pip install mitproxy（这里安装的是v5.3.0）
第二步（可能有）：配置环境变量。这里自己没有配置好像也能用，不明所以。。。
第三步（可能有）：安装证书。下载对应版本的证书，导入到浏览器。证书下载地址：
Downloads (mitmproxy.org)。因为不是管理员身份另外也因为是自己测试环境，所以没有安装证书，而是在启动时做了一点小改动也能使用。
第四步：校验是否安装成功。在windows上无法使用mitmproxy，只能用mitmweb
如果上面步骤有不对，请看官移步度娘问问，然后不吝赐教~~
2）定制开发 这里是为了将被测环境上操作时的请求都保留下来，所以需要在这里做一些修改，直接上代码：
import json from mitmproxy import http class CaptureProxy: def request(self, flow: http.HTTPFlow) -&gt; None: request_info = { "method": flow.request.method, "url": flow.request.pretty_url, "headers": dict(flow.request.headers), "content": flow.request.content.decode() } with open("requests.json", "a") as f: json.dump(request_info, f) f.write("\n") addons = [ CaptureProxy() ] 还可以在这里过滤指定的host或者api。前置条件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f319be01fd784df19eb341fd9fae33a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1bf7eced78d087f1cc277df54077562/" rel="bookmark">
			淘宝cp210X提示“VeriFone USB Modem”无法匹配驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 淘宝cp210X提示“VeriFone USB Modem”无法匹配驱动 文章目录 淘宝cp210X提示“VeriFone USB Modem”无法匹配驱动原因分析解决方式（手动选择安装）成功识别cp210X usb转串口芯片 前段时间，在淘宝上买了cp210X usb转串口芯片，安装-调试板驱动CP210x-Windows-Drivers（0积分下载地址）后，插入电脑后设备管理，显示"VeriFone USB Modem”
原因分析 买到的cp210X usb转串口芯片是翻新的芯片，内部的OPT寄存器已经被写过，不能自动匹配驱动了啦。
解决方式（手动选择安装） 1)右键，点击更新驱动，在弹出的对话框中，点击 “浏览我的电脑以查找驱动程序”
2)在弹窗的对话框中，点击"让我从计算机上…"
3)在设备列表里选择，Silicon Labs，然后任意选择一个CP210X的驱动即可。
成功识别cp210X usb转串口芯片 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ef674e1d0b3c82ac39183da9cf984b5/" rel="bookmark">
			Ubuntu16.04 中 搭建Janus Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu16.04 局域网中搭建Janus Server 文章目录 Ubuntu16.04 局域网中搭建Janus Serverjanus简介系统环境安装准备安装 aptitu安装依赖 安装源码安装 WebSocket安装 libsrtp安装libusrsctp安装libmicrohttpd安装 Janus安装和配置nginx签名证书安装nginx配置nginx验证nginx配置是否成功 janus 官方demo运行配置janus修改demo增加wss支持验证 Janus demo janus简介 ​ Janus是WebRTC 服务器端的开源项目，官方对其定义是一个WebRTC服务器端，支持的功能比较丰富，通过core模块来支持不同的插件的方式，支持SFU模式，客户端集成相对比较简。开发语言（C语言），代码架构比较清晰，支持了SIP 接口。
官方网址：https://janus.conf.meetecho.com/index.html
系统环境 uname -ar Linux ubuntu16 4.4.0-186-generic #216-Ubuntu SMP Wed Jul 1 05:34:05 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 安装准备 安装 aptitu sudo apt-get install aptitude 安装依赖 sudo aptitude install libmicrohttpd-dev libjansson-dev libnice-dev \ libssl1.0.1-dev libsrtp-dev libsofia-sip-ua-dev libglib2.3.4-dev \ libopus-dev libogg-dev libcurl4-openssl-dev pkg-config gengetopt \ libtool automake sudo apt install cmake sudo aptitude install libconfig-dev sudo aptitude install libssl-dev sudo aptitude install doxygen graphviz sudo aptitude install libavcodec-dev libavformat-dev libswscale-dev libavutil-dev 安装源码 janus支持插件式功能安装，根据需求选择安装，这里将安装：WebSocket(支持 WebSocket),bsrtp和libusrsctp（音视频流传输控制和数据协议支持），libmicrohttpd（支持http/https），Janus（咱们的主角）,nginx(提供web服务)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ef674e1d0b3c82ac39183da9cf984b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f5d42deb557e7be6a524901c7000857/" rel="bookmark">
			基于libevent的多线程http server (CentOS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装libevent二、安装jsoncpp三、http多线程服务 一、安装libevent 下载编译安装，提前安装好gcc, make
sudo su yum -y install wget wget http://www.monkey.org/~provos/libevent-2.0.10-stable.tar.gz tar -zxvf libevent-2.0.10-stable.tar.gz cd libevent-2.0.10-stable ./configure --prefix=/usr make -j2 make install # 查看安装结果 ls -al /usr/lib | grep libevent 安装后的输出信息，
make install-recursive make[1]: Entering directory `/home/username/libevent-2.0.10-stable' Making install in . make[2]: Entering directory `/home/username/libevent-2.0.10-stable' make[3]: Entering directory `/home/username/libevent-2.0.10-stable' test -z "/usr/bin" || /usr/bin/mkdir -p "/usr/bin" /usr/bin/install -c event_rpcgen.py '/usr/bin' test -z "/usr/lib" || /usr/bin/mkdir -p "/usr/lib" /bin/sh .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f5d42deb557e7be6a524901c7000857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54e916439c0fa21824c5b34b91de80b7/" rel="bookmark">
			Github 霸榜！竟是阿里技术官的微服务分布式项目实战笔记总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一个初创公司的老板带着他们的技术负责人来做技术交流，他们列了一长串问题，有微服务技术选型方面的，有技术难点方面的。这些问题如果不能快速解决，那么就会影响产品质量、上线进度，进而直接影响业务。
这是很多企业常常面临的问题，业务有所发展是好现象，证明你所在的企业保持着向上发展的良好势头。这时候微服务分布式就成为很多企业不得不面临的选择，因此微服务分布式成为了考验很多技术骨干及架构师能力的必要条件。
所以今天为大家带来了一份阿里大牛的微服务分布式项目实战笔记总结：
笔记总览： 因为笔记的内容实在太多，下面就只以截图展示部分内容了。
内容展示： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54fcc50f0017c7c17c6e7730a6724e0f/" rel="bookmark">
			软件产品To B 和 To C
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 软件产品To B 和 To C B端产品和C端产品 To B（To Business），是面向企业的产品，做的产品提供给某个企业，企业内部人员使用的平台或系统等，或者企业在该产品输出的结果上，再进行二次开发，再做to c 的产品。
To C（To Consumer）， Consumer 是消费者的意思， to c 是直接面向普通用户，普通大众的产品。
例如，阿里云、腾讯云、亚马逊云这些云服务Paas平台，其他的一些SaaS平台等，作为一个产品，提供给别的公司使用，别的公司拿来一些产品功能，集成到自己的App项目中，自己的App的用户面向社会群体，那自己的App产品就是 C 端，如APP、小程序等，多为移动端产品。
B端和C端产品的区别 目标用户不同：B端产品面向企业，C端产品面向普通大众用户侧重点不同：B端产品注重效率、成本、营收，C端产品注重用户体验商业逻辑不同：B端产品主要依靠销售人员去推广产品功能达成交易，C端产品主要是通过获取用户流量来变现，包括：交易、会员、广告等对产品的要求不同：B端产品要求产品经理注重业务的把控，能在某个方向进行深入的研究；C端产品要求产品经理要会设计，懂普通用户。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46a94c32e4a5f677ce7731160ef6133/" rel="bookmark">
			太狠了,Spring 全家桶笔记, 一站式通关全攻略, 已入职某厂涨薪 18K
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Spring 早已成为 Java 后端开发事实上的行业标准，无数的公司选择 Spring 作为基础的开发框架，大部分 Java 后端程序员在日常工作中也会接触到 Spring ，因此，如何用好 Spring ，也就成为 Java 程序员的必修课之一。
为了让你把知识点掌握得更牢固，理解得更透彻。今天给大家安利下 spring 全家桶资料。
Spring 核心笔记 附赠：Spring 100 问
Springboot Springboot 核心笔记
深入浅出 springboot
深入实践 springboot
Spring Cloud 微服务实战 SpringMVC 面试专题及答案整理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f49418ca065fb5e2f70c00599a6b6e8a/" rel="bookmark">
			Vue 父子组件传值&amp;自定义事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为vue 的数据是单向流动的，这是为了避免数据污染。在官方文档中也说到：所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。
大致归纳一下：父传子--传值、子传父--传事件
父传子：父组件可以传递任何类型的数据给子组件
如果传递的数据是对象格式的，那么在子组件 内部监听 watch 的时候，需要使用深度监听，也就是添加 deep ： true ，也就是下面的子组件的监听方式，如果是别的格式的，例如，字符串、数字、布尔值、 数组格式等，那就是普通监听就好了
父组件代码：在父组件中 通过 v-bind 的缩写形式 :listData='listData' 绑定了data 内部的数据，第一个 listData 只是一个名字，为了方便辨认，所以写的相同。 第二个 listData 则是 data 内部的数据
&lt;template&gt; &lt;div&gt; &lt;h3&gt;我是father&lt;/h3&gt; &lt;Children :listData='listData' :xxx='xxx' :listObj='listObj'&gt;&lt;/Children&gt; //子组件传递了一个数组、一个字符串、一个对象 &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Children from './children' //引入子组件 export default { data () { return { xxx:'123', listData: [{ id: 1, name: "TCL彩电", price: 1000, num: 1, img: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f49418ca065fb5e2f70c00599a6b6e8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5a9d04fe683266fa28c49d5b3a6e099/" rel="bookmark">
			对Autosar NM官方文档简单备注
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.网络管理分为3种模式：
2.Network Mode分为3种模式：
3.接收/发送NM PDU，都重启NM-Timeout Timer
4.（1）在NOS状态下接收到RMR=1的NM报文，跳入RMS状态
（2）在NOS状态下，自身RMR=1，跳入RMS状态，在这种状态下，所发NM报文的RMR=1
5.（1）在RSS状态下，有网络请求，则进入NOS状态
（2）在RSS状态下，接收到RMR=1的NM报文，跳入RMS状态
（3）在RSS状态下，自身RMR=1，跳入RMS状态，在这种状态下，所发NM报文的RMR=1
6.（1）在PBS状态下，接收到NM报文，进入PMS状态
（2）在PBS状态下，有网络请求，进入RMS状态
7.（1）在BSM状态下，接收到NM报文，进入PMS状态
（2）在BSM状态下，有网络请求，进入RMS状态
注：在PBS/BSM状态下，网络都被释放，除非有明显的网络请求
8.初始化时，userdata=0xFF，CBV=0x00；
9.NM PDU格式
（1）
（2）CBV说明：
--在BSM、PBS状态下，主动唤醒，AWB=1
--离开网络模式，AWB清0（即从RSS到PBS状态后，AWB清0，如从PSS到NOS/RMS状态，AWB保持上一次状态）
--只有在NOS状态下，才可采用降低总线负载减低机制
--被动进入RMS状态下，需要延时CanNmCycleOffset才可发送NM报文
--从BSM、PBS状态中因为主动唤醒进入，不使用CanNmCycleOffset计数器
总线降低负载算法：
--进入RMS状态，不使用该算法
--进入NOS状态下，如果有总线降低负载算法，则使用
远程睡眠指示位
--如果在NOS状态下，且在CanNmRemoteSleepIndTime时间内没有接收到NM报文，则回调Nm_RemoteSleepIndication
如果在NOS或RSS状态下，接受到NM报文（包括RMR=1的NM报文），则回调Nm_RemoteSleepCancellation
用户使用数据
被动模式
--被动模式下，只接收NM报文，不发送NM报文
部分网络
--CanNmPnEnabled = False，则该功能禁用
--如果接收到PNI = 0且CanNmAllNmMessagesKeepAwake = Ture的NM报文，也不应该忽略接收报文；
接收到PNI = 0且CanNmAllNmMessagesKeepAwake = False的NM报文，则忽略接收报文
接受到PNI = 1且CanNmAllNmMessagesKeepAwake = Ture的NM报文，则使用滤波算法，对接受到的NM报文进行分析
--在部分组网中，CBV是必须要支持的
--不支持CanNmPnEnable的时候，PNI = 0，支持PNI = 1
NM PDU过滤算法
--只有一个组网的NM才会让Timeout Timer定时器重启 --初始化时，不会使能NM PDU过滤算法
--PN=0，对网络无请求，PN=1，对网络有请求
--有关联，不能丢弃；
无关联，CanNmAllNmMessagesKeepAwake = False，丢弃
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5a9d04fe683266fa28c49d5b3a6e099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82726935eb41e57ec041dc62e65a1cb4/" rel="bookmark">
			Android百度地图(四):百度地图运动轨迹纠偏、去噪、绑路之百度鹰眼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章介绍了地图画轨迹的基本原理和实现。不难发现，当位置处于建筑物密集区、桥梁、高架桥下，gps信号较差时，画出来的轨迹效果会比较差。即使是在空旷地带，也难免会出现gps漂移的情况而造成轨迹的偏差。这时就需要我们对位置点进行纠偏、去噪、抽稀、绑路操作。百度鹰眼sdk则提供了相应的api，本篇文章将介绍如何使用百度鹰眼sdk画出效果相对较好的轨迹。
先来看看效果图
1.百度地图(三)文章中demo取得原始位置点画出来的轨迹图：
原始位置轨迹图a 可以发现轨迹大致能反应用户所经过的路劲，效果还是不错的，说明gps信号较好，精度较高。但是除了西边的轨迹较为平滑之外，其他方位的轨迹都出现了锯齿形状，原因是gps位置有一定精度差，所以不一定会准确的定位到所行走的路劲上。如果运动范围较大(需缩小地图显示整个轨迹，轨迹将在视觉上变得平滑)，而且轨迹精度要求不高，能确定用户在户外，个人觉得图a就能满足要求了
2.使用百度鹰眼sdk处理后的轨迹图：
经处理后的轨迹图 可以发现经处理的轨迹已经没有锯齿形状了，位置都落到了路劲上，这就是我们想要的效果。如果无法确定用户gps信号的优良，可能会进行网络定位，并且轨迹的精度要求很高，那么位置必须通过百度鹰眼sdk处理后再画出运动轨迹，这样才能达到图b的效果。
下面将介绍如何使用百度鹰眼sdk画出效果相对较好的轨迹，包括驾车、骑行、步行。
一 配置工程 1.申请apikey
2.创建鹰眼轨迹服务空间并获取 service_id
3.在Application标签中声明SERVICE组件,每个APP拥有自己独立的鹰眼追踪service
&lt;service android:name="com.baidu.trace.LBSTraceService" android:enabled="true" android:exported="true" android:process=":remote" /&gt; 二 百度鹰眼sdk关键api介绍 1.轨迹数据处理流程图
流程图 2.初始化
//以下都是伪代码 /** * 轨迹服务：通过serviceId对应服务端，用于存储、访问和管理自己的终端和轨迹 serviceId：轨迹服务id，这就是配置工程申请的service_id entityName：设备标识 isNeedObjectStorage：是否需要对象存储服务，比如在某个点存一个图层图片，显示这里有超速摄像头， 获取轨迹的时候，也可以获取这个图层图片显示在轨迹的相应位置上. 这里默认为：一般为false，关闭对象存储服务。 注：鹰眼 Android SDK v3.0以上版本支持随轨迹上传图像等对象数据， 若需使用此功能，该参数需设为 true，且需导入bos-android-sdk-1.0.2.jar。 */ Trace mTrace = new Trace(serviceId, entityName,isNeedObjectStorage); /** * 轨迹客户端LBSTraceClient，主要功能： (1)内部封装了百度定位sdk的api，采集定位位置点，定位sdk不清楚的可以篇头阅读百度文章(一) (2)将采集数据打包发给服务端 (3)请求服务端，查询经过处理的轨迹、位置等信息 */ LBSTraceClient mClient = new LBSTraceClient(mContext); 3.定位当前位置显示在地图上
//定位请求参数类 LocRequest locRequest = new LocRequest(serviceId); //时时定位设备当前位置，定位信息不会存储在轨迹服务端，即不会形成轨迹信息,只用于在MapView显示当前位置 mClient.queryRealTimeLoc(locRequest, entityListener);//这里只会一次定位,多次定位使Handler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82726935eb41e57ec041dc62e65a1cb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c49eae11131d064416c4ef65c17eb1/" rel="bookmark">
			Python爬虫遇到URL错误解决办法大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行Python爬虫任务时，遇到URL错误是常见的问题之一。一个错误的URL链接可能导致爬虫无法访问所需的网页或资源。为了帮助您解决这个问题，本文将提供一些实用的解决方法，并给出相关代码示例，希望对您的爬虫任务有所帮助。
一、了解URL错误
URL错误通常是指所请求的链接无效或无法找到。可能是由于URL地址输入错误、拼写错误、缺失协议头或端口号等问题导致的。正确理解URL错误对于解决问题至关重要。
二、解决办法
以下是几种常见的解决办法，您可以根据实际情况选择适合您的方法：
1、检查URL地址：
首先确保URL地址的正确性，包括协议头、域名、路径、参数等。如果地址拼写错误或缺失了必要的参数，那么无论怎样操作都无法访问到想要的资源。请仔细检查URL地址是否正确，调整错误部分。
2、URL编码：
在构建URL时，如果包含了非ASCII字符或特殊字符，需要进行URL编码。URL编码可以将这些字符转换成URL安全的形式，避免在传输过程中出现问题。
在这个例子中，使用了urllib.parse.quote()函数对URL进行编码，生成了编码后的URL。这样可以确保URL中的特殊字符被正确处理。
3、异常处理：
在使用爬虫时，经常会遇到由于网络不稳定或其他原因导致URL请求失败的情况。为了保证程序的稳定性，可以使用异常处理机制来处理URL错误。
在这个例子中，我们使用了requests库发送了GET请求，并在try-except语句块中捕获了RequestException异常。如果发生URL错误，就会执行处理URL错误的代码逻辑。
4、调试工具：
使用调试工具可以更好地排查URL错误。可以通过打印URL、查看请求头、网络抓包等手段，深入分析发生错误的具体原因。
5、网络协议问题：
有时候，某些网站可能使用了HTTP/HTTPS以外的协议，例如FTP、SFTP等，或者使用了非标准端口。在构建URL时，请确保使用了正确的协议和端口。
三、总结
通过检查URL地址、进行URL编码、使用异常处理机制、调试工具和处理网络协议问题，您可以有效解决Python爬虫中遇到的URL错误问题。请注意，上述的代码示例仅为示范，实际使用时请根据您的具体需求和爬虫框架进行相应的调整。
希望本文的解决办法对您在解决URL错误问题时有所帮助，并为您的爬虫任务提供实际价值。其他爬虫问题，欢迎评论区留言，看到就会及时整理回答。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68a17d7aeec0e0d7f456a5eaed787a45/" rel="bookmark">
			web服务器的部署及优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、搭建实验环境
准备两台主机，并对主机都进行以下操作：
二、什么是http和httpd
1、HTTP（Hypertext Transfer Protocol）是一种用于在网络中传输超文本数据的协议。它是 Web 上广泛使用的协议之一，用于浏览器和服务器之间的通信。HTTP 使用请求-响应模型，浏览器发送 HTTP 请求到服务器，服务器则返回 HTTP 响应。
2、HTTPD（HTTP daemon）是指运行在服务器上的 HTTP 服务器软件。它是一个可以接收和处理 HTTP 请求的服务器程序。典型的 HTTPD 软件包括 Apache HTTP Server、Nginx、Microsoft IIS 等。HTTPD 软件负责监听特定的网络端口（通常是 80 或 443），接收客户端的 HTTP 请求，并提供相应的 HTTP 响应。HTTPD 也负责处理一些与 HTTP 协议相关的功能，如连接管理、请求解析、动态内容生成、静态文件服务、安全性等。
所以，HTTP 是一种协议，而 HTTPD 是用于执行该协议的服务器软件。HTTPD 接收和处理HTTP 请求，并返回相应的数据给客户端，以便客户端可以通过浏览器等方式访问和浏览 Web 内容。
三、apache的安装及启用
四、apache服务端口的更改
配置文件修改端口
五、 apache默认测试页的设定
配置文件修改内容 可以添加多个默认文件，访问首个默认文件。
六、默认发布目录的设定
配置文件的修改
七、对于 apache访问控制的安全优化
1、基于ip的安全访问优化
白名单则相反 黑名单配置文件
白名单配置文件
2、基于用户的安全访问优化
（1）认证文件的生成
（2）配置文件的设定
所有用户都可访问
清除所有访问历史记录
下次访问需要重新输入密码，不清除则不需要 。
八、apache虚拟主机的构建
添加虚拟主机并设定主配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68a17d7aeec0e0d7f456a5eaed787a45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fe855d3b045ffa15810ee598ba84090/" rel="bookmark">
			恒定PH值分子动力学模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自然界中往往存在一些对PH值敏感的蛋白，当我们想要探究这些蛋白在不同PH条件下构象变化时自然离不开MD的辅助。遗憾的是Gromacs暂不支持恒定PH条件下的模拟，因为这涉及到了蛋白表面残基质子化状态需要时刻改变。一种折衷的方法是：用propka等预测工具预测蛋白极性/可质子化残基的pka值（因为实际蛋白表面的pka值可能受到邻近残基的影响而发生偏移），然后根据想要模拟的PH环境，自主确定各个可质子化残基质子化状态（比如某个残基pKa=4，pH环境为7，那么这个残基自然是处于离去质子的解离状态）。然后修改对应pdb文件中的残基名，比如脱去质子的CYS改名为CYM（这个问题文末有提及）。这种方法存在的最大缺点在于：质子化状态一但设定好就会一成不变，这和实际情况显然是不符的。因此我们今天不介绍这种方法，而是介绍在Amber中的实现方法。
1. 准备结构 有这样一张表(下图所示)，罗列了常见质子化残基，包括ASP、GLU、HIS、CYS、LYS、TYR. 第三列数据对应它们各自的pKa值。第二列对应它们在恒定PH环境模拟时Amber识别的名字，如果想让Amber在模拟时对某个残基上面的质子化状态"多多关照",总得披上"马甲"好让Amber认识它吧。比如我想要模拟PH=7的环境，查看下表可以看出ASP、GLU、HIS在此条件下质子会发生解离，那么就把pdb文件中它们的名称改成对应的"马甲"。ASP→AS4、GLU→GL4、HIS→HIP
本次就以11个氨基酸长度的小肽test.pdb在pH为7的环境下模拟为例：
第一步，修改pdb文件 首先修改需要更换“马甲”的残基名，这里我们做了ASP→AS4、GLU→GL4修改，由于没有HIS残基，所以就不做考虑。此外该分子种有两个距离较靠近的CYS，我们想让他们之间成二硫键，所以修改做出修改：CYS→CYX。修改后的文件名为test_fix.pdb
#用pdb4amber不加氢，补全缺失原子，连接二硫键 pdb4amber -i test_fix.pdb --nohyd -o test_fix2.pdb #不知道什么原因pdb4amber除氢总是失败，只能用下条命令自行除去了 grep -v '.............H' test_fix2.pdb &gt; test_fix3.pdb 下图所示，我们想要连接的二硫键并没有形成，什么原因呢？这是因为只有硫原子间距小于2.5Å时pdb4amber才会自动连接。不过也没关系，后面我们还能在构建拓扑时强制将它们连上。
第二步，构建拓扑 #唤醒tleap程序 tleap #加载constph力场（底层用的amber_ff10力场，同时于蛋白而言等价于ff99SB） source leaprc.constph source leaprc.water.tip3p #为后面的抗衡离子添加力场 #加载修改好的pdb mol = loadPDB test_fix3.pdb #连接二硫键 #遵循语法bond &lt;原子1&gt; &lt;原子2&gt; [bondtype] #bondtype分三类：“-”单键、“=”双键、“#”三键、“:”芳香键,若不指定则默认是单键 bond mol.4.SG mol.8.SG #维持体系电中性 addions mol Cl- 0 addions mol Na+ 0 #保存拓扑、坐标 saveAmberParm mol test.prmtop test.inpcrd #退出tleap程序 quit 注意，这里我们构建拓扑时没有添加水分子，这是因为本例要使用的是’隐式水‘模型。’隐式水‘不是真正的水分子，你可以把它理解为一个个数据点。启用’隐式水‘模型的参数为icnstph=1,需要将它添加到后文用到的以*.in为后缀的文件中。
第三步，准备恒定pH输入文件(cpin file) #因为本例中我们只考虑了GLU、ASP的质子化状态改变，所以resname后面的参数改为它们对应的'马甲'——GL4、AS4 cpinutil.py -resnames GL4 AS4 -p test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fe855d3b045ffa15810ee598ba84090/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07f2f5fa264e5306b46772fadae8b659/" rel="bookmark">
			薛定谔 | 诱导契合对接(结合位点柔性)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所谓诱导契合对接说的直白点就是在对接过程中，不仅小分子改变pose(姿势),结合空腔中的氨基酸残基位置也会改变。即配体和受体双向奔赴的过程。
1. prepare protein模块对蛋白预处理； 此步对蛋白去除无用链、去除结晶分子、去除水分子、加氢、能量最小化。
2. ligprep模块对配体分子预处理； 对配体分子质子化、生成所有可能的同分异构体。
3. 选择Induced Fit Docking模块开始对接 ① 选择需要对接的配体分子；② 选择配体分子构象采样强度（Standard/Extended Sampling）;③ 选择盒子中心位置和大小。 ① Docking参数设定栏；② 手动选择空腔可变动残基（当然也可以选择Automatic模式,让程序根据受体分子B因子自行确定活性空腔内的哪些残基可变） 输入需要变动的残基编号（间隔的用逗号隔开，连续的用“-”连接），点击“Add”添加。
最后，点击run运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6236b51e78d2e4768b629af6009b612/" rel="bookmark">
			薛定谔 | 分子对接及基于受体的虚拟筛选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.准备受体 最好直接从File &gt;&gt; Get PDB输入PDB ID获取。因为原始pdb文件保留了蛋白完整序列信息，这样在准备蛋白时薛定谔可以自动补全缺失残基。
选择Protein Preparation模块。按照下图操作：
在正常准备蛋白的步骤中弹出了蛋白质中一些位置可变的残基（如下图所示），选中任意一种残基，点击next position会展现出这个残基可能的其他构象，点击commit即选定这个位置，表格中的数字表示这种位置的残基可能的概率大小，当所有残基都commit后，再点击update，将选定的这一组氨基酸的定位给固定下来（当然每个残基要选哪一个残基要靠自己的判断进行适当的取舍，对于不在活性口袋的可变残基可忽略其可变的位置。）
2. 生成受体分子格点文件 选择receptor grid generation模块。鼠标点击蛋白-配体复合物中的配体分子即可生成下图所示的格点盒子。
选小配体分子时，需要在显示视图中选中ligand,要让其出现格子才算选上。在site项中设定盒子中心，在高级选项中可以调整小盒子的大小。点击对话框页面下方的文件名右边的小齿轮图标，可以设置生成格点文件的存放路径。Constraintstab栏项：可以添加一些原子或残基，在对接过程中他们的位置不会变。Rotatable Groupstab栏项：系统会列出可以旋转的残基以及他们可旋转的键，感觉作用不大，基本不会用上。Exclusive Volumestab栏项：可以选中一些原子或残基，系统会认定这些选中的基团周围的球状体积都是不能被配体分子占据的。 3. 准备配体 选择LigPrep模块
4. Docking 选择Ligand-docking模块
5.查看结果 在右上角table中查看打分结果，分数越负对接效果越好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e32f834ad637cdacee40424e418e909/" rel="bookmark">
			薛定谔 | 先导化合物优化与相互作用可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当获得针对某个靶点的先导分子后，想要在此基础上进行化学结构修饰。为了提升化学改造的成功率可以采用本教程方法进行结构虚拟改造/优化。
示例蛋白：PDB ID:3WDS 每用薛定谔处理一个新任务，第一步必须创建新的project以方便日后管理。
接着在File选项卡中修改工作路径（可以方便地找到输出文件）
1、去除多余的链(只保留B链和它的小分子）2、prepare protein模块 勾选两个“fill”开头的选项（可选） &gt;&gt; preprocess选择Review and modify tab栏，对结构中不需要分析的或影响对接的原子删除选择Refine tab栏 &gt;&gt; 点击optimize和minimize对结构优化。(ps: 该模块最下方可以看到绘制拉式图选项) 3、preset预设中ligand site展开项后有多种呈现小分子结合面的预设方案，一般选择cartoon 4、先导化合物优化（这种情况只有在小分子对接到受体活性口袋中可以用） 选择lead optimization模块,在弹出的面板中选择Receptor tab栏，勾选在工作视图中产生格点，记得要勾选pick ligand,然后在视图中选中小分子（即对接格点的位置）。提前将对接好的配体分子导入到软件中,并include到显示页面（就是将左边配体条目圆点勾选），选择Ligand tab栏，点击from workspace,就会出现配体分子的二维结构，点击score进行打分，这一过程耗时可能十分久，耐心等待。一段时间后工作文件夹中生成产生的docking-job_x的文件。在Result tab栏中可以看到详细的打分结果。返回ligand tab栏，对小分子二维结构修饰，重复以上操作就可以在Result tab栏中看到结构修饰后的打分情况了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da86f92e5d959595cd815df0da24e6cb/" rel="bookmark">
			Llama2下载流程与报错：download.sh: [[: not found Downloading LICENSE and Acceptable Usage Policy..
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近Meta的新模型LlamaV2可谓是火出圈了，第一时间我也尝试下载了权重。
下载Llama2需要首先取得许可（不过没有门槛，秒批）：
https://ai.meta.com/resources/models-and-libraries/llama-downloads/
目前主流的下载方案有两种：
Github： 链接：https://github.com/facebookresearch/llama
Hugging face: 链接：https://huggingface.co/meta-llama
Git下载时遇到报错 download.sh: 12: download.sh: [[: not found
Downloading LICENSE and Acceptable Usage Policy
download.sh: 17: download.sh: Bad substitution
原因：使用了sh download.sh
解决：使用bash download.sh
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21b9f8ae59c47a53a166d22e37d19952/" rel="bookmark">
			数据分析基础-Excel图表的美化操作（按照教程一步步操作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、原始数据 包含月份和对应的销量和产量。
时间销量产量1月60722月38673月28344月58685月67596月72357月61428月24319月556710月243511月122112月2645 二、原始的图表设计-采用Excel自带模板 三、优化思路 1、删除多余元素
2、弱化次要元素
对于可以弱化的元素，应尽量调整，使其不抢眼。
3、添加缺少的元素
4、调整布局细节设计
5、配色并优化字体和位置
柱形图用浅绿填充
折线用深蓝（淡色60%）填充。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eba7224c76aab0e333c82d00067b7be5/" rel="bookmark">
			网络通信中的秘密之M/M/1队列模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 计算机网络是现代社会不可或缺的重要组成部分，而M/M/1队列模型是计算机网络中的关键概念之一。本文将详细解释M/M/1队列模型的原理和应用，并探讨其在网络通信中的作用及影响。
第一部分：队列理论基础 1. 队列和队列模型 1.1 队列的定义与特性 队列是一种常见的数据结构，具有先进先出（FIFO）的特性。它可以用于描述各种实际情境，如交通流量、服务器请求等。在计算机网络中，队列模型被广泛应用于分析和优化网络性能。
1.2 队列模型的分类 常见的队列模型包括M/M/1、M/M/c、M/G/1、M/G/c等。本文主要关注M/M/1队列模型，即到达时间服从指数分布、服务时间也服从指数分布、只有一个服务器的队列模型。
2. M/M/1队列模型的基本原理 2.1 到达过程和服务过程 M/M/1队列模型中的到达过程和服务过程都是随机的。到达过程服从指数分布，即满足泊松分布，表示单位时间内到达的平均次数。服务过程也服从指数分布，表示单位时间内完成的平均次数。
2.2 系统状态和稳态概率 M/M/1队列模型的系统状态可以用队列长度来描述，即队列中正在等待服务的任务数。稳态概率指在长时间运行后，系统处于各种可能状态的概率。
第二部分：M/M/1队列模型的性能分析 1. 平均队列长度和平均等待时间 M/M/1队列模型的性能分析中，关注的主要指标是平均队列长度和平均等待时间。这些指标直接影响着网络通信的实时性和效率。
2. 利用Little公式计算系统性能参数 利用Little公式，可以通过已知的参数计算出M/M/1队列模型的其他性能参数，如到达率、服务率、系统利用率等。
3. M/M/1队列模型的稳定性条件 在一些特殊情况下，M/M/1队列可能无法保持稳定状态。本节将介绍M/M/1队列模型的稳定性条件，并讨论如何优化系统以满足这些条件。
第三部分：M/M/1队列模型的应用案例 1. 网络传输性能优化 M/M/1队列模型可以用于优化网络传输性能，通过调整到达率、服务率等参数，提高系统吞吐量和响应时间。
2. 网络排队管理 M/M/1队列模型可以用于网络排队管理，通过合理调度任务和资源分配，提高网络的效率和稳定性。
3. 资源规划和容量评估 M/M/1队列模型可以用于资源规划和容量评估，通过分析系统的稳态概率和性能指标，帮助决策者进行合理的资源配置和规划。
第四部分：总结与展望 本文详细介绍了M/M/1队列模型的原理、性能分析方法及其在网络通信中的应用。队列模型在计算机网络中扮演着重要的角色，通过对其深入研究和应用，可以提升网络通信的效率和性能。
未来，随着计算机网络的发展和应用场景的多样化，队列模型将继续发挥重要作用。我们期待更多的研究和创新，在网络通信领域取得进一步突破和提升。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/342764796f0774c2c336377dad6fca95/" rel="bookmark">
			超几何分布检验（hypergeometric test）与费歇尔精确检验（fisher‘s exact test）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，超几何分布检验常用来对venn图两个圈overlap的显著性进行检验，费歇尔精确检验常用来对2x2的列联表进行检验。 2，假设有如下的统计数据： smokenon-smokelung cancer106normal112 现在对其进行费歇尔精确检验，有两种提零假设的方法：
2.1 对比抽烟组和非抽烟组
H0：抽烟组得肺癌的概率p1和非抽烟组得肺癌的概率p2相同; H1: p1和p2不同（可以分为双侧检验p1 不等于 p2，或者单侧检验p1&gt;p2 or p1&lt;p2）。
其中p1=10/(10+1)，p2=6/(6+12)。
对于上述2x2表，穷尽所有可能为：
对每一种可能，根据超几何分布，可以计算概率为
P1=choose(16, 11)*choose(13,0)/choose(29, 11)=0.00013 P2=choose(16, 10)*choose(13,1)/choose(29, 11)=0.0030 P3=choose(16, 9)*choose(13,2)/choose(29, 11)=0.026 P4=choose(16, 8)*choose(13,3)/choose(29, 11)=0.11 P5=choose(16, 7)*choose(13,4)/choose(29, 11)=0.24 P6=choose(16, 6)*choose(13,5)/choose(29, 11)=0.30 P7=choose(16, 5)*choose(13,6)/choose(29, 11)=0.22 P8=choose(16, 4)*choose(13,7)/choose(29, 11)=0.090 P9=choose(16, 3)*choose(13,8)/choose(29, 11)=0.021 P10=choose(16, 2)*choose(13,9)/choose(29, 11)=0.0025 P11=choose(16, 1)*choose(13,10)/choose(29, 11)=0.00013 p12=choose(16, 0)*choose(13,11)/choose(29, 11)=2.25e-06 很明显对于我们的数据，处在P2的位置，
2.11 则对于双侧检验（H1为 p 1 ≠ p 2 p1 \neq p2 p1=p2），
p-value=2*(P1+P2)=0.00626
2.12 对于单侧检验（H1为 p 1 &lt; p 2 p1 &lt; p2 p1&lt;p2），
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/342764796f0774c2c336377dad6fca95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ffd296c21122c14fef0cb16b69ecd1d/" rel="bookmark">
			一文搞懂自动驾驶芯片TDA4 启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 TDA4架构简介TDA4启动流程DMSC ROM阶段MCU域R5 ROM阶段SBL阶段 TDA4架构简介 TDA4是德州仪器推出的一款高性能、超异构的多核SoC，拥有ARM Cortex-R5F、ARM Cortex-A72、C66以及C71内核，可以部署AUTOSAR CP系统、HLOS(Linux或QNX)、图像处理以及深度学习等功能模块，从而满足ADAS对实时性、高运算能力、环境感知及深度学习等方面的需求。
TDA4凭借着出色的运算能力、有竞争性的价格，赢得了越来越多汽车主机厂以及零部件供应商的青睐。对于ADAS行业的从业人员或者对ADAS领域感兴趣的人都有必要来了解一下TDA4这颗芯片。
TDA4的架构如下图，可以分为MAIN域、MCU域和WKUP域(DMSC)。
MAIN域集成了2个A72核，4个R5F核，2个C66核和1个C71核。环境感知(图像感知和超声感知)，传感器融合(图像和超声信号融合)，智能驾驶算法(路径规划)，深度学习等会部署到MAIN域，也就是智能驾驶的主要功能逻辑会部署到MAIN域。
TDA4启动流程 像这种多核异构SoC，启动过程相比MCU来说都比较复杂。SoC的成功启动是之后正常处理各种智能驾驶功能的基础，下面就来介绍一下TDA4的具体启动流程。
上图中的1和2是上电和上电复位(Power On Reset)，3是启动之前SoC内部会做一个硬件电路自测(Built-in Self-Test)。4是DMSC内部的ROM程序，这部分程序对开发者不可见，是出厂时就固化在芯片内部的。
DMSC ROM阶段 DMSC ROM是上电后最先运行的程序，它的主要作用如下图紫色部分所示。配置看门狗、PLL时钟，基于启动模式配置防火墙，配置MCU安全代理、环形加速器，发送消息给MCU域的R5核告知其启动模式。最后释放MCU域R5核的Reset，此后MCU域R5核开始启动。
MCU域R5 ROM阶段 MCU域R5核启动之后运行的是R5核的ROM，也是固化在芯片内部的一段程序。下图的黄色部分显示了R5 ROM所做的事情，首先判断是否只启动MCU，由于我们需要启动MAIN域的A核、R5核及DSP核，所以MCU-only Boot的选择是No。
MCU域R5核会完成一些基础的引导工作，然后从启动模式PIN(SoC用来设置启动模式的PIN脚)获取启动模式(可以从OSPI, EMMC, UART等启动)。接下来MCU域R5核ROM会配置PLL以及初始化用来启动的外设(比如OSPI Flash，EMMC等)，初始化之后才能从这些外部存储器中读取各个核的image。
之后MCU域R5核ROM会从OSPI Flash中读取SBL的image文件并load到RAM中，然后请求DMSC的ROM去校验SBL image的完整性。如果校验通过，DMSC会重启MCU域R5核，此时MCU域R5核开始执行SBL程序。
SBL阶段 下图是SBL的执行过程以及与DMSC的交互。
SBL首先会加载DMSC的firmware，这个firmware是DMSC最终会执行的程序，它主要提供一些SCI的服务给MCU域和主域，这些服务主要包含PM(Power Management)，RM(Resource Management)及Security(cyber security)。PM主要是用来控制一些设备的ON/OFF，RM用来请求外设资源，Security用来实现secure boot以及信息安全等。
SBL加载DMSC的firmware到RAM后会通知DMSC ROM去校验firmware的完整性，校验通过后DMSC就会开始执行它的firmware，并提供服务(PM,RM,Security)给其他核。然后SBL会load一些配置数据到RAM，然后通过SCI Message发给DMSC供DMSC使用。
最后SBL会配置DDR，然后加载MAIN域R5核的image和MAIN域A72、R5、DSP的image到DDR。一般会在MCU域的R5核上部署CP AUTOSAR，MAIN域的R5核上部署以太网Switch的firmware以及超声波雷达的USS驱动等。MAIN域的A72核上一般会用来部署Linux或QNX等操作系统，它们的启动需要ATF/Uboot等引导程序，因此需要加载引导程序的image和Linux内核或QNX内核的image。
加载各个核的image到DDR后，SBL会请求DMSC释放MCU域R5核以及MAIN域各个核的reset line，之后MCU域及MAIN域的各个核即开始执行各自的软件，整个系统就启动完成了。
文中缩略词解释
• DMSC – Device Management. &amp; Security Controller:
– Controller that runs the first set of instructions on any Jacinto 7 family device
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ffd296c21122c14fef0cb16b69ecd1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965febd098abdbe219c52aa4b744e024/" rel="bookmark">
			python中字符串形式形式相加减
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，常规的类型转换形式 str_data = "2" i = int(str_data, 10) str_data1 = "3" y = int(str_data1, 10) h = i + y print(h) 结果：5
二，用map函数方法 str_data = "2" str_data1 = "3" a = list(map(int, str_data)) b = list(map(int, str_data1)) print(a[0] + b[0]) 结果：5
a=input()
a1,a2=map(int,a.split())
print(a1+a2)
输入2， 3
输出 5
三,eval() a = "1" b = "2" print(eval(a) + eval(b)) 输出：3
eval和input函数在使用时需要非常小心，因为它们可以执行任意代码。如果不加限制地使用这些函数，攻击者可以通过注入恶意代码来执行系统命令、读取敏感文件等操作，从而造成严重的安全问题。
为了避免这种情况发生，应该尽可能避免使用eval和input函数，并且在必须使用时，要对输入进行严格的过滤和验证，确保只有合法的数据才能被执行。同时，还可以考虑使用更安全的替代方案，比如ast.literal_eval()函数来代替eval函数，或者使用Python的argparse模块来处理命令行参数，以避免直接调用系统命令。
四，用 ast.literal_eval() ast.literal_eval()函数可以安全地将字符串转换为Python字面值表达式的值，例如字符串、数字、元组、列表、字典等。与eval不同，它只能处理一些简单的数据类型，并且不能执行任意代码。
使用ast.literal_eval()函数非常简单，只需要将要转换的字符串作为参数传递给该函数即可
import ast b = ast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/965febd098abdbe219c52aa4b744e024/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/186cf72ce95cd0ed1783961e5bb72390/" rel="bookmark">
			python中怎么使用map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，map()的语法格式
定义： 参数：
返回值：
二，map()的用法实例
1.类型转换
2.多个迭代对象引用
三、运行结果出现:报错 一，map()的语法格式 定义： map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每一个元素，并把结果作为新的Iterable返回，返回的类型是map类型。
语法格式：map(function，iterable...)
参数： function-我们指定的函数（或数据类型），可以是python内置的，也可以是自定义的。
iterable-可迭代的对象，例如列表，元组，字符串等。
返回值： 返回的是一个可迭代对象，且类型是map类型 二，map()的用法实例 1.类型转换 eg:
a = "1,2,3,4"
list_data = map(float,a)
for i in list_data:
print(i)
结果：
1.0 &lt;class 'float'&gt;
2.0 &lt;class 'float'&gt;
3.0 &lt;class 'float'&gt;
4.0 &lt;class 'float'&gt;
2.多个迭代对象引用 多个可迭代对象传递给map()函数，然后map()函数将这2个迭代对象传入自定义函数a（）。
注意：这个自定义函数a（）的参数个数，要与传入的可迭代对象数量一致。
def a(x, y): return x * y list_data1 = [1, 2, 3] list_data2 = [4, 5, 6] list_data3 = map(a, list_data1, list_data2) print(type(list_data3), list(list_data3)) list_data4 = map(lambda x, y: x * y,list_data1, list_data2) print(list(list_data4)) 结果&lt;class 'map'&gt; [4, 10, 18]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/186cf72ce95cd0ed1783961e5bb72390/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99aefb9c51672ec6f99242c34d3641dc/" rel="bookmark">
			python中的divmod的详细用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.功能
二.注意点
一.功能 它是将取整和取余结合在一起并以元组的形式返回：(a // b, a % b)。
1.整数的用法:
a=95,b=2
print(divmod(a,b))
结果：(47,1)
2.浮点数的用法
a=2.3,b=0.2
print(divmod(a,b))
结果(11.0, 0.0999999999999997)
二.注意点 divmod函数只能接受整数或浮点数类型的参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4617122b09dda4abcb8a8c5413eb180/" rel="bookmark">
			【贪心】区间问题：选点、分组、覆盖以及最大不相交数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贪心问题是一种很复杂的问题，因为没有一个固定的做法，基本就是每个问题当场思考。贪心问题可以总结成一句话：要得到整体最优解，先从局部最优解开始。
本篇文章讲解贪心问题中的一类：区间问题，因为这类问题使用频率较大且做法较为统一。
目录 1、区间选点2、最大不相交区间数量3、区间分组4、区间覆盖总结 1、区间选点 原题 acwing 区间选点
给定 N 个闭区间 [ a i a_i ai​, b i b_i bi​]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。
输出选择的点的最小数量。
位于区间端点上的点也算作区间内。
输入格式
第一行包含整数 N，表示区间数。
接下来 N 行，每行包含两个整数 a i a_i ai​, b i b_i bi​，表示一个区间的两个端点。
输出格式
输出一个整数，表示所需的点的最小数量。
数据范围
1≤N≤105,
−109≤ a i a_i ai​≤ b i b_i bi​≤109
输入样例：
3
-1 1
2 4
3 5
输出样例：
2
做法就是：
先把所有区间按右端点从小到大排序；依次枚举每个区间，如果已经包含一个区间内的点，那么就pass；否则就把点选为右端点；最后选出的点数就是答案。 道理就是这样，凭个人感觉差不多能感觉这样做是对的。因为每次选的都是右端点，也即尽可能地往其他区间上凑，每次都刻意地去贴近其他区间，到最后就能得到正确答案。但是这样说是不严谨的，下面给出一个严谨的证明。
那么只要按照上面的流程用代码实现即可：
#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; struct Range{ int l, r; //重载小于号，以右端点排序 bool operator&lt; (const Range &amp;W)const { return r &lt; W.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4617122b09dda4abcb8a8c5413eb180/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63a5a73416a07ceed1b5c5726954dcdd/" rel="bookmark">
			APP自动化测试-Python&#43;Appium&#43;Pytest&#43;Allure框架实战封装（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、Python编程入门到精通二、接口自动化项目实战三、Web自动化项目实战四、App自动化项目实战五、一线大厂简历六、测试开发DevOps体系七、常用自动化测试工具八、JMeter性能测试九、总结（尾部小惊喜） 前言 pytest只是单独的一个单元测试框架，要完成app测试自动化需要把pytest和appium进行整合，同时利用allure完成测试报告的产出。
编写常规的线性脚本具体的步骤如下：
1、设计待测试APP的自动化测试用例
2、新建app测试项目
3、配置conftest.py文件等
4、编写整体app测试用例运行文件
5、把设计好的自动化测试用例转化成脚本备注
以下示例采用计算器为示例
前置条件：下载第三方库
下载 appium-python-client
下载 pytest
下载 allure-pytest
1、设计待测试APP的自动化测试用例
2、新建APP测试项目
3、配置文件信息
先配置外层conftest.py文件
import pytest # 配置app的各种连接信息 @pytest.fixture(scope='session') def android_setting(): des = { 'automationName': 'appium', 'platformName': 'Android', 'platformVersion': '6.0.1', # 填写android虚拟机/真机的系统版本号 'deviceName': 'MuMu', # 填写安卓虚拟机/真机的设备名称 'appPackage': 'com.sky.jisuanji', # 填写被测app包名 'appActivity': '.JisuanjizixieActivity', # 填写被测app的入口 'udid': '127.0.0.1:7555', # 填写通过命令行 adb devices 查看到的udid 'noReset': True, # 是否重置APP 'noSign': True, # 是否不签名 'unicodeKeyboard': True, # 是否支持中文输入 'resetKeyboard': True, # 是否支持重置键盘 'newCommandTimeout': 30 # 30秒没发送新命令就断开连接 } return des 再配置用例层的conftest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63a5a73416a07ceed1b5c5726954dcdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/536b9cfd425d7636a84b852933bad631/" rel="bookmark">
			Java项目数据脱敏常用技术及Jasypt实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据脱敏在Java项目中是一项非常重要的任务，它可以保护敏感数据，同时符合法规和隐私保护要求。在本篇博客中，我们将介绍数据脱敏的概念以及在Java项目中常用的开源框架和工具的实战应用。
什么是数据脱敏？ 数据脱敏是指将敏感数据进行处理，使其在保持数据的可用性的同时，去除或替换掉真实的敏感信息，从而保护数据主体的隐私。脱敏的目的是确保数据在非授权的情况下无法被识别，从而减少数据泄露和滥用的风险。
常用的数据脱敏技术 字符替换/加密： 通过替换字符或进行加密，将敏感数据转换成不易识别的形式。常见的加密算法包括AES、RSA等。随机生成： 对于敏感数据，可以随机生成伪造的数据，确保数据的格式和结构不变。脱敏规则： 制定脱敏规则，对不同类型的数据采用不同的脱敏方式，例如只显示部分信息、保留前几位或后几位等。 常用的Java开源框架和工具 Apache Commons Lang： 这个工具包含了许多用于字符串处理的工具类。使用它，可以很容易地对字符串进行脱敏和加密操作。Jasypt： 这是一个Java库，用于加密和解密敏感数据。它支持多种加密算法，例如PBE、AES等。DataSunrise： 这是一个功能强大的数据安全保护工具，支持数据库和文件的数据脱敏和加密，可以灵活配置不同的脱敏规则。Spring Boot Actuator： Spring Boot Actuator提供了对应用程序的监控和管理功能，可以使用它来对敏感数据进行脱敏，以便在监控和日志中不暴露真实数据。 实战：使用Jasypt进行数据脱敏 Jasypt是一个简单易用的Java加密库，我们可以在Spring Boot项目中很方便地集成它。
步骤1：添加Jasypt依赖 首先，我们需要在项目的pom.xml文件中添加Jasypt依赖：
&lt;dependency&gt; &lt;groupId&gt;org.jasypt&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;版本号&lt;/version&gt; &lt;/dependency&gt; 步骤2：配置加密密钥 在配置文件（例如application.yml）中配置加密密钥：
jasypt: encryptor: password: "yourEncryptionKey" 步骤3：实现数据脱敏 在代码中，我们可以使用Jasypt的StringEncryptor来加密和解密敏感数据。首先，我们需要在配置类中将StringEncryptor注入到Spring容器中：
import org.jasypt.encryption.StringEncryptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class JasyptConfig { @Autowired private StringEncryptor encryptor; @Bean(name = "jasyptStringEncryptor") public StringEncryptor stringEncryptor() { return encryptor; } } 接下来，在我们的用户服务类中使用@EncryptProperty和@DecryptProperty注解对敏感数据进行脱敏和解密：
import org.jasypt.encryption.StringEncryptor; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/536b9cfd425d7636a84b852933bad631/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f5a5cc812a0044d427d6a609faded6a/" rel="bookmark">
			TCP协议&#43;三次握手/四次挥手过程（带图详解！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP连接建立——三次握手/四次挥手 目录 TCP连接建立——三次握手/四次挥手1、什么是TCP？2、TCP首部格式2.1 TCP首部格式是什么？2.2 重要位置解释 3、三次握手3.1 “三次握手”过程详细介绍3.2 为什么要进行第三次握手？ 4、四次挥手4.1 “四次挥手”过程详细介绍4.2 为什么“握手”是三次，“挥手”要四次？ 1、什么是TCP？ 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的通信协议，工作在传输层。
应用程序在使用 TCP 协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接。
TCP运输连接主要有三个阶段：
建立TCP连接，也就是三次握手数据传输，基于已经建立的TCP连接进行可靠的数据传输释放TCP连接，在完成数据的输送后，通过四次挥手来释放连接
2、TCP首部格式 2.1 TCP首部格式是什么？ 1、TCP 首部格式是 TCP 协议中用来传输数据的报文格式，用于在发送端和接收端之间传递 TCP 数据。TCP 首部包含了一些必要的信息，如源端口、目标端口、序列号、确认号、标志位等，用于控制和管理 TCP 连接。
2、在三次握手的过程中，双方会交换 TCP 首部信息，以建立连接。 TCP 连接建立后，双方可以通过 TCP 首部中的序列号（seq）和确认号（ack）来控制和管理数据传输。每个 TCP 报文都包含了 TCP 首部和数据部分，其中 TCP 首部用于控制和管理数据传输，数据部分用于传输实际的数据。（图片来源于网络搜索）
2.2 重要位置解释 源端口/目的端口: 均占16比特，分别表示写入源端口号和目的端口号，用来标识发送/接收该TCP报文段的应用进程。序号（sequence number）： 是发送数据包中的第一个字节的序列号，占32比特，取值范围是[0,2^32-1]。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。 假设有两台主机 A 和 B 建立了 TCP 连接，A 向 B 发送了一个数据包，数据部分的长度为 100 字节，此时 A 会为这个数据包分配一个唯一的序列号，假设为 1000。B 收到这个数据包后，会发送一个确认包给 A，确认收到了这个数据包，并告诉 A下一个期望接收的序列号是 1100。这样，A 就知道 B 已经成功地接收了这个数据包，并且可以继续发送后续的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f5a5cc812a0044d427d6a609faded6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/394f9a093f64e5f0fe252aa1ba724bc3/" rel="bookmark">
			AD原理图检查ERC(编译检查)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理图的编译： 原理图界面选择菜单栏的：工程----&gt;Compile PCB Project 也可以项目管理栏右击对应项目文件
在右下角，点击panels----&gt;Message，就可以打开Message界面
原理图的常用检测： 原理图界面选择菜单栏的：工程----&gt;工程选项 也可以项目管理栏右击对应项目文件
1、Duplicate Part Designators :存在重复的元件位号
2、Floating Net Labels :网络悬浮
3、Floating Power Objects :存在悬浮的电源端口
4、Nets with only one pin :存在单端网络
5、Net with multiple names：网络名重复
6、Off grid object：对象没有处在栅格点的位置
注意将单端网络默认不报告 将其设成敬告或错误模式防止设计时出错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5820e5999eaa7ee441cd06a21c9ccbc/" rel="bookmark">
			JAVA课设——俄罗斯方块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JAVA课设——俄罗斯方块 源代码下载地址：Java课设——俄罗斯方块（附课程设计报告）
1. 项目介绍 本项目实现了经典的俄罗斯方块小游戏的基本功能。游戏中定义了七种基本图形，游戏开始后，由程序随机产生所定义的图形，在游戏界面右上角可看到下一个图形，无操作时，方块自动竖直下落，图形在下落到底部之前，可通过键盘控制方块旋转、左移、右移、加速下落、一键到底，当某一行被下落的方块填满后消除该行并计分。游戏可以暂停，也可以结束当前游戏重新开始新游戏。
在此基础上，游戏设置了两种关卡，标准关卡和速度关卡，同时添加了自定义控制键和选择关卡级别的功能，以及查看游戏规则和关于本游戏信息的功能，并且为菜单中的功能都添加了快捷键。
(1)控制键设置：
向上箭头、向左箭头、向右箭头、向下箭头分别控制图形旋转、左移、右移、加速下落，回车键Enter控制图形一落到底，空格键控制游戏开始和结束，P键控制游戏暂停和继续。上述控制键均可在控制键设置中自定义。
(2)得分设置：
每次消除的行数不同得分也不同。
1行：100分
2行：300分
3行：500分
4行：1000分
(3)关卡设置：
图形初始下落速度：1000ms/格。
本游戏有两种关卡：标准关卡和速度关卡。
·标准关卡：难度中等，共分2级，50000分一级，速度递增，下落一格的速度每2000分减少10ms
·速度关卡：难度较大，共分10级，10000分一级，速度随分数的增加而加快，每2000分减少10ms
游戏达到最后一关并能实现最后一关目标，获得所需分数，即可通关本游戏。
玩家可通过关卡选择功能选择游戏的关卡和级别。
2. 项目功能模块 3. 成果展示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec987e31e580daf91a5f3807e0d2ebbd/" rel="bookmark">
			数据结构课设——汉诺塔游戏演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源代码下载地址：数据结构课设——汉诺塔游戏演示
一. 问题描述 汉诺塔游戏问题中的数据元素具有如下形式：
lchild：左孩子结点
rchild：右孩子结点
num：该移动步骤需要移动的盘子的编号
s：该移动步骤的起始柱
e：该移动步骤的终点柱
p[3]：三根柱子的横坐标
n：汉诺塔的层数
t：移动速度
二. 功能需求 要求输入盘子数（2个以上有效），移动速度，开始演示汉诺塔移动的步骤；
盘子，A，B，C柱需要自己绘制；
初始时盘子在A柱上通过B柱最终移动到C柱上（其中，盘子从上往下越来越大），显示出盘子在几个柱之间的移动过程。
三. 实现要点 汉诺塔游戏过程可以看做是对二叉树的中序遍历：
【将n-1个盘子从A移到B】 ----&gt; 【中序遍历左子树】[n-1(A)-&gt;B]
【将第n个圆盘从A移到C】----&gt; 【访问根节点】[N(A)-&gt;C]
【将n-1个圆盘从B移到C】—&gt; 【中序遍历右子树】[n-1(B)-&gt;C]
使用了二叉树来存储汉诺塔游戏解决方案的移动步骤，在构造解空间树的时候，遵循由初始柱——&gt;目标柱，分解为两部分：初始柱——&gt;中转柱和中转柱——&gt;目标柱，然后通过中序遍历解空间树演示移动过程。汉诺塔游戏演示过程的绘制使用了EasyX图形库
全局变量：p[3]三根柱子的横坐标，n盘数，t移动速度
函数：
void ColorLine(int num, int s, int e, int color)改变线段颜色，
void PrintPillar()打印三根柱子，
void InitGraph()绘制初始化盘子都在A柱的图，
void Moveto(int from, int to, int len)实现盘子的移动。
其中，盘子的移动速度通过调用Sleep()函数来控制。由于程序的图形绘制演示功能不够完善，目前只能演示2&lt;=层数&lt;=16的汉诺塔移动过程编译环境：VS2019，配置EasyX图形库 四. 类定义 为二叉树建立BiTree类，其类定义如下：
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;graphics.h&gt; #include&lt;easyx.h&gt; #include&lt;conio.h&gt; #include&lt;cmath&gt; using namespace std; const int LEFT = 40; const int RIGHT = 760; const int TOP = 70; const int BOTTOM = 450; const int REC_WIDTH = 20; //长方块宽20 //720/4=180 struct Node { int num;//盘号 int s, e;//起始柱 终点柱 Node* lchild, * rchild; }; int p[3], n, t;//三根柱子的横坐标，盘数，移动速度 void ColorLine(int num, int s, int e, int color);//改变线段颜色 void PrintPillar();//打印三根柱子 void InitGraph();//绘制初始化盘子都在A柱的图 void Moveto(int from, int to, int len);//len:半盘长 实现盘子的移动 void Menu();//提供操作菜单 class BiTree { private: int cnt;//移动步数 Node* root; public: BiTree(int a,int b,int c,int n); ~BiTree(); Node* create(int a, int b, int c, int n); void postorder(Node* p); //中序遍历 void display();//演示 void release(Node *p); }; 在BiTree类中，提供了如下成员函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec987e31e580daf91a5f3807e0d2ebbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b1a24c769bd5eed2b90676ec53939c/" rel="bookmark">
			go-zero学习 — 进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go-zero学习 — 进阶 1 注意事项※3 超时时间4 进阶4.1 目录拆分4.2 model生成4.3 api文件编写4.4 业务编码4.5 jwt鉴权4.5.1 jwt鉴权的签发※4.5.2 使用jwt token鉴权的配置4.5.3 jwt token 验证 ※4.6 中间件使用4.7 rpc编写与调用※4.8 错误处理4.9 模板修改4.9.1 方式14.9.2 方式2 5 使用Nacos5.1 Nacos服务搭建5.2 go-zero使用Nacos 1 注意事项 1 本文简化了整体环节过程，只对重难点问题进行详细讲解，建议结合本文与官方文档。
2 在使用时发现，goctl.exe v1.4.3生成的xxxhandler.go：
if err != nil { httpx.ErrorCtx(r.Context(), w, err) } else { httpx.OkJsonCtx(r.Context(), w, resp) } 而 goctl.exe v1.4.2生成的xxxhandler.go：
if err != nil { httpx.Error(w, err) } else { httpx.OkJson(w, resp) } 这个会对返回的信息格式产生影响【即4.8和4.9】，所以暂不推荐将goctl.exe升级到 v1.4.3。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6b1a24c769bd5eed2b90676ec53939c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2755251ce4fbc51b8025c78f7e61c82c/" rel="bookmark">
			论文解读：Investigating the Factual Knowledge Boundary of Large Language Models with Retrieval Augmentati
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文解读：Investigating the Factual Knowledge Boundary of Large Language Models with Retrieval Augmentation 一、动机 Knowledge-intensive任务通常需要借助外部的资源来回答问题，此时需要有一个retrieve模型来完成外部知识的检索；最近大模型（例如ChatGPT）可以解决此类问题，其在大量的文档数据上进行过预训练，并将大量的知识学习在参数里；然而现有的大模型依然存在一个未知的问题，即大模型是否有能力察觉到他们事实知识认知边界；本文则致力于研究检索式增强对于大模型生成能力的影响进行分析。主要关注三个问题：大模型察觉到它的事实知识边界程度、检索增强对大模型生成有什么影响、具有不同特征的辅助文档如何影响LLM。 二、问题定义 开放域问答中，给定一个问题 q q q以及一个文档库 D = { d i } i = 1 m \mathcal{D}=\{d_i\}_{i=1}^m D={di​}i=1m​，目标是给定一个回答 a a a。
先前的方法是通过一个retriever检索文档库，并获得与问题相关的文档，随后使用机器阅读理解的方式回答问题。大模型可以直接利用模型本身的知识来回答问题，免于使用外部知识，即有： a = f L L M ( p , q ) a=f_{LLM}(p, q) a=fLLM​(p,q)，其中 p p p表示prompt。
如果使用检索增强的方式，则为 a = f L L M ( p , q , L ) a=f_{LLM}(p, q, \mathcal{L}) a=fLLM​(p,q,L)，其中 L \mathcal{L} L表示检索得到的support document。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2755251ce4fbc51b8025c78f7e61c82c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5910073635c640ef07b74ffbee1619f/" rel="bookmark">
			如何启动Redis，前台启动，后台启动和开机自启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Redis Redis安装完之后，进入到bin目录下
cd /usr/local/bin 查看bin目录下所有文件，可以看到有redis-server,reddis-cli,redis-sentinel等文件
这说明安装Redis成功
运行Redis 前台启动Redis 在任意文件夹下，输入命令redis-server（这个时候按tab键可以智能补全指令，说明已经写到环境变量中了）
之后会运行出这个界面：
但是这个启动方式叫做前台启动，可以发现页面并没有停止，而是卡在这里。如果此时我们想要建立链接，我们只能重新打开一个窗口建立链接，当前窗口如果关掉（ctrl+c），redis也挂掉了。所以我们需要后台启动Redis
后台启动 想要后台启动Redis，我们必须修改Redis的配置文件并且指定配置文件启动。
要修改配置文件，首先需要把配置文件备份一下，以免改错了还能恢复
cp redis.conf redis.conf.bck 备份完成后，我们可以修改配置文件了
进入配置文件
vi redis.conf 要修改的地方：
监听的地址，，默认是127.0.0.1，会导致只能在本地访问，修改为0.0.0.0则可以在任意IP访问，
！注意！生产环境下不要设置为0.0.0.0 bind 0.0.0.0 守护进程，修改为yes后即可后台运行 daemonize yes 密码，设置后访问redis必须输入密码
requirepass: 11111日志文件 logfile "redis.log" # 如果不修改logfile配置，默认不产生配置文件 # 如果不另外修改dir配置，默认在当前目录 注：修改文件时，“/”+配置名，可以进行搜索，光标自动定位到该配置的位置
启动：
# 进入redis安装目录 cd /usr/local/src/redis-6.2.6 # 启动 redis-server redis.conf 此时redis已经在后台运行了，可以通过
ps -ef | grep redis 指令判断redis是否正常运行
正常运行的状态
停止redis，直接杀死进程
kill -9 14821 开机自启 需要通过自己编写系统服务文件，实现开机自启
首先，新建要给系统服务文件，并进入
vi /etc/systemd/system/redis.service 文件内容如下：
[Unit] Description=redis-server After=network.target [Service] Type=forking ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5910073635c640ef07b74ffbee1619f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/628b058d8c9561c327b44dcf8134db36/" rel="bookmark">
			搭建CUDA11.8.0&#43;cuDNN8.9.2&#43;python3.11.4&#43;anaconda23.5.2环境的过程记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
搭建11.8CUDA+8.9.2cuDNN+python3.11.4+anaconda23.5.2环境的过程记录。主要是记录一下操作顺序，另外由于安装的版本比较新，可能有一些可以借鉴的坑，仅供参考。
另外，直接使用conda下载cuda出现的报错问题可以通过安装CUDA和cuDNN解决
目录
文章目录
前言
一、推荐先安装CUDA和cuDNN
1.首先win+r，cmd，进入命令台
2.得到下面的结果
​编辑
3.先查看里面的Driver Version是否大于400，否则更新显卡驱动
4.根据CUDA version 去下面的网站选择合适的CUDA版本下载安装
二、安装Anaconda
1.首先检查是否已经安装过python语言
2.未安装或者原来的python环境已经删除
总结
一、推荐先安装CUDA和cuDNN 原因：大部分小白都没安装，有些文章也不没有明确提及需要安装，所以提前安装避免忘记。
1.首先win+r，cmd，进入命令台 nvidia-smi 2.得到下面的结果 3.先查看里面的Driver Version是否大于400，否则更新显卡驱动 CUDA下载链接
CUDA Toolkit 12.2 Downloads | NVIDIA 开发者
cuDNN下载链接 CUDA 深度神经网络库 (cuDNN) | NVIDIA 开发者
4.根据CUDA version 去下面的网站选择合适的CUDA版本下载安装 其中第一个图中Version为windows版本。
点击圈起来的部分进入其他版本选择 。
这里我选择的是CUDA11.8.0。
Cuda和cuDNN安装教程(超级详细)_cuda安装_jhsignal的博客-CSDN博客https://blog.csdn.net/jhsignal/article/details/111401628?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=cudnn%E5%AE%89%E8%A3%85&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-111401628.142%5Ev90%5Einsert_down1,239%5Ev3%5Einsert_chatgpt&amp;spm=1018.2226.3001.4187
安装过程可以参考如上博客。
注：选择cuDNN时我选的是8.9.2版本用于和CUDA11.8.0适配。
至此CUDA和cuDNN安装完毕。
二、安装Anaconda 1.首先检查是否已经安装过python语言 我之前安装过python，而Anaconda本身也是python的语言所以会产生冲突要将原来的环境变量进行更改。已经安装的可以参考。(70条消息) python与anaconda安装（先安装了python后安装anaconda，基于python已存在的基础上安装anaconda）——逼死强迫症、超详解_安装了python还能安装anaconda吗_北极山的博客-CSDN博客https://blog.csdn.net/qq_43529415/article/details/100847887?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168981996416800192264960%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168981996416800192264960&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-100847887-null-null.142%5Ev90%5Einsert_down1,239%5Ev2%5Einsert_chatgpt&amp;utm_term=Anaconda%E5%AE%89%E8%A3%85python&amp;spm=1018.2226.3001.4187 2.未安装或者原来的python环境已经删除 因为pytorch虚拟环境本身就相当于单独的python环境，所以可以直接删除原来的或者在没有的基础上直接进入pytorch虚拟环境配置。
(70条消息) Anaconda创建Pytorch虚拟环境（排坑详细）_anaconda pytorch_赤赤_流星雨的博客-CSDN博客https://blog.csdn.net/weixin_53534399/article/details/125954715?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168982338516800186596359%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168982338516800186596359&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125954715-null-null.142%5Ev90%5Einsert_down1,239%5Ev2%5Einsert_chatgpt&amp;utm_term=anaconda%E9%85%8D%E7%BD%AEpytorch%E7%8E%AF%E5%A2%83&amp;spm=1018.2226.3001.4187
总结 不同的电脑有不同的报错，希望能帮到大家。才疏学浅，请多指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d27cec6434d8c46c615b8b5c301d9927/" rel="bookmark">
			虚拟机网络配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 安装完虚拟机后，需要对其进行联网。
一、虚拟网络编辑 打开vm，编辑——虚拟网络编辑器
根据红框操作，取消让本地DHCP服务器分配IP给虚拟机
点击NAT设置，查看网关ip，记下来，后面网卡配置需要用到。然后点击确定
以上操作，我们指定了使用NAT模式作为我们虚拟机的网络模式，但NAT模式还没有正式启动。
打开控制面板——网络和internet——网络和共享中心——更改适配器，启用VMnet8和VMnet1
右键VMnet8，点击属性，双击ipv4
填入IP地址和子网掩码，这步是为了确保虚拟机能够正确地连接到所需的网络，并与其他网络设备进行通信。
二、关闭防火墙 有时防火墙会阻止虚拟机访问网络，需要将其关闭
1、本地防火墙 我这里是win11的防火墙
2、虚拟机防火墙 开始所有的节点，对每个节点都输入以下操作：
systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 三、网卡配置 接下来为每个节点都进行如下网络信息的编辑，内容包括
私有ip(IPADDR)，网关(GATEWAY)，子网掩码(NETMASK)，域名服务器(DNS)；onboot的值设置为yes #系统启动时是否激活网卡；bootproto的值设置为static #网络配置参数是动态还是静态 ； 1、修改ens33 #查找ens33位置 find /etc/ -name ifcfg* #进入修改 vi /etc/sysconfig/network-scripts/ifcfg-ens33 进入ens33网卡文件，进行以下配置：
每个节点的ip地址不一样，可参考以下规律：
主机名IP地址node1192.168.126.11node2192.168.126.12node3192.168.126.13 2、重启网卡 systemctl restart network 3、测试网络 1）ping网关（ping自己）
查询本机网关：ifconfig （也就是刚刚指定的IPADDR）
2）ping DNS
3）ping 网站
如ping 百度来检验能否上网
4）ping 其它节点
检验虚拟机之间是否互通，通常以上三点都能ping通的话，这一步都可以ping通。
四、远程连接虚拟机 背景：vmware里面的虚拟机界面其实并不友好，当显示内容过长时，无法查阅全部内容、没有页面滚动的功能、点进去鼠标也会消失不见、字体太小等问题，不利于我们进行集群的使用。
因此，我们需要一个能连接虚拟机来提供更高效页面的远程终端连接管理工具，常见的有：PuTTY、Xshell、SecureCRT、MobaXterm、iTerm2
学生推荐选择Xshell，这里演示使用xshell过程。
1、安装Xmanager插件 一款浏览远端X窗口（图形界面）系统的工具，提供远程的登录服务。
其内部包含许多工具：
最常用的就是Xshell(远程登录) 和 Xftp(传输文件)，使用Xshell需要安装ssh服务，Xftp需要安装vsftpd服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d27cec6434d8c46c615b8b5c301d9927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd177654a1e74902b24ec2e3eec05bc1/" rel="bookmark">
			自增运算符的运算过程解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、表达式 表达式是变量,常数与运算符(和括号)的结合,例如:a=a+1,这里的加号"+"是一个双目运算符,有一个变量a以及一个常数1参与运算,它的返回值是a+1的值。再举个例子:a= -1, 这里的负号"-"是一个单目运算符,仅有一个常数1参与运算,它的返回值为-1,然后赋值给a
a++和++a都是表达式,不同的是它们的计算过程分为两步,对于后置自增a++,先返回表达式的值(a),再对a自增1,而前置自增++a运算与之相反。
二、自增运算符的计算过程 请思考以下代码的输出内容:
int a=1; a=a++; printf("%d",a); 首先，赋值运算符的优先级是最低的,所以计算过程是这样的:
1.计算表达式a++的值,a为1,所以表达式的值为1;
2.a自增1,此时a=2;
3.将表达式的值赋值给a,此时a又变为了1。所以最后的输出结果是a=1。
请再思考以下代码的输出内容:
int a=1; a=a++ + ++a; printf("%d",a); 1.从左往右计算,先计算前一个表达式a++的值,为1
2.a自增1,此时a=2
3.再计算后一个表达式++a的值
4.++a是前置自增,它是先自增1,此时a=3,再返回这个表达式的值,为3
5.进行赋值运算,前一个表达式+后一个表达式=1+3=4,所以输出结果为a=4
最后一题：
int a=1; a=a++ + a++ * ++a; printf("%d",a); 1.从左往右计算,先计算第一个表达式a++的值,1
2.a自增1,此时a=2
3.再计算第二个表达式a++的值,2
4.a自增1,此时a=3
5.计算最后一个表达式++a的值是,a自增1,此时a=4,再返回这个表达式的值,4
6.进行赋值运算,第一个表达式+第二个表达式*最后一个表达式=1+2*4=9,所以输出结果为a=9
三、总结 前置自增++a是先自增,后返回表达式的值,而后置自增a++是先返回表达式的值,再自增。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fe1c08f22cb7904472eaee8409676eb/" rel="bookmark">
			ERROR: Could not build wheels for pycocotools, which is required to install pyproject.toml-based....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 翻译：抱歉，这个错误是由于无法为"pycocotools"构建所需的wheels导致的，这会影响基于"pyproject.toml"的项目安装。
目录
一、安装pycocotools
二、下载Microsoft Visual C++ Build Tools
三、 在当前的虚拟环境中安装git 四、继续安装pycocotools包
一、安装pycocotools直接在终端中执行pip install pycocotools_windows回出现以下报错 因为pycocotools不支持windowns系统支持的是linux系统
二、下载Microsoft Visual C++ Build Tools 如果没有报error: Microsoft Visual C++ 14.0 or greater is required. Get it with "Microsoft C++ Build Tools": https://visualstudio.microsoft.com/visual-cpp-build-tools的错误可以直接进行下一步
访问以下链接：Microsoft C++ Build Tools - Visual Studio点击页面上的 "下载生成工具" 下载 Microsoft Visual C++ Build Tools。运行下载的安装程序，并按照指示完成安装。 三、 在当前的虚拟环境中安装git conda install git 四、继续安装pycocotools包 pip install git+https://github.com/philferriere/cocoapi.git#egg=pycocotools"&amp;"subdirectory=PythonAPI 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878fbf31088e60ab351eb6ff5c49c143/" rel="bookmark">
			Ubuntu安装NVIDIA驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇教程来自我在n台服务器+工作站+台式电脑上安装驱动的实践经验。会持续更新。
推荐使用ubuntu自带的”软件和更新“（英文叫Software &amp; Updates）中附加驱动安装nvidia驱动，简单方便，基本上装了都能用。要是不行的话，再尝试下面的手动安装
强烈建议，阅读完全文后再上手实操！！！
以下操作默认使用sudo权限
卸载Nvidia残余文件
如果系统是新装的，还没有安装过任何nvidia的东西，可以跳过这一步直接到第1步。
如果电脑已经安装过nvidia的驱动了，推荐清理一下已经存在的nvidia文件
/usr/bin/nvidia-uninstall	# 这个最好运行一下 apt remove --purge *nvidia* 禁用Nouveau的驱动
在/etc/modprobe.d/blacklist.conf最后添加如下代码：
(用来禁用nouveau第三方驱动，之后也不需要改回来）
blacklist nouveau options nouveau modeset=0 然后执行
update-initramfs -u 重启后，执行以下代码，若没有显示则禁用成功
lsmod | grep nouveau 如果遇到这个问题 （perl: warning: Falling back to a fallback locale (“en_US.UTF-8”))[]
apt install locales-all 检测NVIDIA显卡型号：
已知自己显卡型号最好，否则在命令行有三种方法
#方法一：使用ubuntu-drivers-common这个软件` apt install ubuntu-drivers-common ubuntu-drivers devices #方法二 lshw -numeric -C display //最好用sudo #方法三 lspci -vnn | grep VGA 也可以用软件AIDA64，这个软件可以看电脑的所有配置信息。
然后下载官方驱动（我比较喜欢最新的版本）。推荐下载英文版的驱动，防止中文乱码。例如
wget http://us.download.nvidia.com/XFree86/Linux-x86_64/410.93/NVIDIA-Linux-x86_64-410.93.run 【可选】关闭secure boot：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/878fbf31088e60ab351eb6ff5c49c143/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/611a31bea5e9c44aefb5a7217fe3ec18/" rel="bookmark">
			cmd运行gpedit.msc(组策略）找不到文件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案:
1.新建一个文本文件,在文件中输入以下内容
@echo off pushd "%~dp0" dir /b %systemroot%\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;gp.txt dir /b %systemroot%\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;gp.txt for /f %%i in ('findstr /i . gp.txt 2^&gt;nul') do dism /online /norestart /add-package:"%systemroot%\servicing\Packages\%%i" pause 2.将文件后缀名修改为.bat
3.鼠标右键点击,然后选择"以管理员身份运行",然后等待运行结束即可
注:转载至 知乎 https://www.zhihu.com/question/41745930
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0349d0ccb55cd47b3def28e4d4c4ac2/" rel="bookmark">
			Pearson correlation皮尔逊相关性分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在参数检验的相关性分析方法主要是皮尔逊相关（Pearson correlation）。既然是参数检验方法，肯定是有一些前提条件。皮尔逊相关的前提是必须满足以下几个条件：
变量是连续变量；比较的两个变量必须来源于同一个总体；没有异常值；两个变量都符合正态分布。 正态分布的呈现是倒“U”型曲线。在实际分析过程中，想要一份数据同时满足以上条件，确实是有一定难度的。毕竟我们是没法保证收上来的数据，一定恰好是符合正态分布的。
皮尔逊相关系数的范围是位于[-1,1]之间。相关系数展示了方向性：
如果相关系数接近1，说明两个变量之间呈较高的正相关性；如果相关系数接近-1，说明两个变量之间呈较高的负相关性；如果相关系数接近0，说明两个变量之间彼此独立，没有相关性。 皮尔逊相关的结果包括两个值，相关系数和P值。在相关性分析中，P值代表着两个变量是否显著相关。
一般而言，分析结果里，我们先看P值。如果P值小于0.05，那么两个变量呈显著的相关性。
然后再看相关系数的方向性，报告两个变量是显著的正相关或负相关。
SPSS操作详细步骤
第一步，选择“分析”——“相关”——“双变量”。
第二步，在相关系数里，选择“皮尔逊”。显著性可以选“双侧”。
第三步，点击“选项”，可以勾选统计，计算平均数与标准差等，如下图所示。
其他设置都可以默认。直接点“确定”，就能生成结果了。
如果想要保留SPSS语法文件，可以先点击“粘贴”，保存本次所有操作，如图5.4所示。下次还要执行同样的操作，直接全选以后，点击绿色小三角符号，就可以生成皮尔逊分析结果了。
皮尔逊相关性分析结果显示，P值显著性为0.222，如红框中所示。P值大于0.05，说明示例的两个变量无显著相关性。相关性系数为0.265，离1比较远，也说明相关性不高。
以上就是皮尔逊相关性分析的内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f68fe94abcfae848763da8bc2b2f0769/" rel="bookmark">
			机器学习：线性回归模型(python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
符号
一、线性回归模型（Linear regression model）
（1）什么是线性回归模型
（2）线性回归模型的数学形式
理论
实践
二、成本函数（Cost function）
（1）什么是成本函数
（2）成本函数的数学形式
理论
实践
符号 以下是本文所需要用到的符号
符号 描述 python（如果适用）
x 特征值 x_train
y 目标值 y_train
示例 x_i
m 示例数量 y_i
w 参数：权重 m b 参数：偏移 n
模型预估值 f_wb 一、线性回归模型（Linear regression model） （1）什么是线性回归模型 线性回归模型是一种用于建立输入和连续输出之间关系的模型。它假设输入和输出之间存在线性关系。该模型可以用于预测连续变量的值，例如房价、销售额、股票价格等。
（2）线性回归模型的数学形式 理论 线性回归的模型函数（这是一个从映射到的函数）表示为xy
python中可表示为：
f_wb = w * x[i] + b
实践 # 导入numpy、matplotlib模块 import numpy as np from matplotlib import pyplot as plt # 设定特征值 x = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f68fe94abcfae848763da8bc2b2f0769/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/108/">«</a>
	<span class="pagination__item pagination__item--current">109/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/110/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>