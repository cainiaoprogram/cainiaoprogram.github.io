<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c50eeb155ca56efe1070c3666d7073cd/" rel="bookmark">
			C&#43;&#43;保留有效位和有效小数位，最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/jiguang321/p/11557015.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf15cacd63de238c54c1a965c54c7b53/" rel="bookmark">
			【操作系统导论】第六章作业：测量系统调用和上下文切换的成本（LINUX系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 测量系统调用成本 使用书上给出的方法，重复调用一个简单的系统调用（执行0字节的读取）100000次，使用gettimeofday()函数测量总时间，再除以1e5，即可得到单次系统调用较为精确的时间成本，c代码如下：
//p1.c #include &lt;stdio.h&gt; #include &lt;sys/time.h&gt; #include &lt;fcntl.h&gt; int main() { int fd = open("./cpu.c", O_RDONLY|O_CREAT); if (fd == -1) { fprintf(stderr, "open failed"); exit(1); } struct timeval start, end; char buf[10]; gettimeofday(&amp;start, NULL); for (int i = 0; i &lt; 1e5; ++i) read(fd, (void*)buf, 0); gettimeofday(&amp;end, NULL); printf("The time cost of system call is %lf us\n", (double)(end.tv_usec - start.tv_usec) / 1e5); close(fd); return 0; } 编译p1.c文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf15cacd63de238c54c1a965c54c7b53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d87b9ef73c3f3c52293115ffeeed866/" rel="bookmark">
			Day04——瑞吉外卖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 13 实现文件上传下载模块1. 上传功能模块1.1 上传概述1.2 前端介绍1.3 **服务端介绍**1.4 下载介绍1.5 上传功能模块逻辑分析1.5.1 前端代码分析 1.6 上传服务端代码逻辑 2 下载功能模块2.1 前端代码2.2 下载功能模块逻辑分析 3 上传与下载服务端代码实现 14 菜品新增模块+多个数据表操作+文件上传下载复用2.1 需求分析2.2 数据模型2.3 准备工作**1). 实体类 DishFlavor****2). Mapper接口DishFlavorMapper****3). 业务层接口 DishFlavorService****4). 业务层实现类 DishFlavorServiceImpl** 2.4 前端页面分析2.4.1 新增菜品时前端页面和服务端的交互过程 2.5 代码实现2.5.1 菜品分类查询2.5.2 保存菜品信息**1). 导入 DishDto 实体类****2). DishController定义方法新增菜品****3). DishService中增加方法saveWithFlavor****4). DishServiceImpl中实现方法saveWithFlavor****5). 在引导类上加注解 @EnableTransactionManagement** 2.6 功能测试 13 实现文件上传下载模块 1. 上传功能模块 1.1 上传概述 文件上传，也称为upload，是指将本地图片、视频、音频等文件上传到服务器上，可以供其他用户浏览或下载的过程。
文件上传时，对页面的form表单有如下要求：
表单属性取值说明methodpost必须选择post方式提交enctypemultipart/form-data采用multipart格式上传文件typefile使用input的file控件上传 1.2 前端介绍 1). 简单html页面表单
&lt;form method="post" action="/common/upload" enctype="multipart/form-data"&gt; &lt;input name="myFile" type="file" /&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d87b9ef73c3f3c52293115ffeeed866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe76e8623e408ce6043494364d0e3fc/" rel="bookmark">
			第一章 Linux基础及Linux环境搭建（保姆级别）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 Linux基础及Linux环境的搭建（保姆级别） 一、Linux简介 1、什么是Linux？ ​ 一款免费开源流行的操作系统。
2、Linux为什么流行？ 1）Windows以用户的体验很好而流行 2）Linux流行主要是因为稳定而流行 Linux一般用于企业中中的服务器Linux用来做服务器操作系统使用 3、Linux与Windows操作系统的区别 1）Windows是一款单用户、多线程、多任务的操作系统。 2）Linux是一款多用户、多线程、多任务的操作系统。 4、类Unix操作系统 5、Linux操作系统特点 1）开源：开放源代码 ​ （1）底层是用C语言和C++语言来实现的。
​ （2）多用户。
​ （3）稳定：一些公司会规定公司7*24小时不关机，为了防止出现死机、蓝屏，一般都是采用Linux操作系统。
6、Liunx发展史 ​ 1991年，AT&amp;T实验室开发了unix操作系统——》Unix7版本发布以后，AT&amp;T将其代码私有化——》Andrew S。Tanenbaum开发了类似于Unix的微内核的Unix操作系统minix操作系统，并将其开源——》Linus trovald 随后对minix操作系统（类Unix）进行了优化，并于1994年将Linux1.0发布出来。
7、Linux版本 1）CentOs 2）RedHat 3）Ubuntu 4）红旗 5）蓝点 6）中标麒麟 ​ （1）中标麒麟（民用）
​ （2）银河麒麟（军用）
​ （3）2013年合并
7）kali Linux：一般用于系统漏洞进行操作系统的渗透测试（很猛） 8）magic box 二、Linux安装 1、虚拟机 ​ 简单来说，将本机剩余的空间分配给其他的操作系统进行使用。
2、常用的三款软件 1）vitual box：软件级别的 2）Vmware：软件级别的 3）VMware vSphere：操作系统级别的 3、VM和Linux的安装 ​ 前提条件：Linux需要在电脑上安装使用，我们总不能把我们自己的电脑的Windows操作系统给卸载了，然后安装Linux来使用吧，因此需要使用虚拟机来安装Liunx。
1）Windows、VM和Linux的关系 ​ 关系：Windows本身就是一款流行的操作系统，一般情况下一台计算机设备装一个操作系统，在内存充足的情况下，我们可以通过VM虚拟机软件将计算机的内存划分一块出来，这一块内存用来给Linux使用（可以把这一块内存看作做了Linux的虚拟电脑），而VM的作用则是划分空间做到虚拟电脑与Windows的相对隔离。
备注：
虚拟空间可以放到其他的Windows上使用，用VM软件打开即可。
2）安装CentOs过程 （1）安装VM12
（2）创建一块虚拟机空间
（3）通过VM创建的虚拟机空间来安装CentOS
（4）使用CentOs
3）VM的安装 （1）进入BIOS中开启虚拟化设备的支持。（不同的机器设备进入BIOS界面的方式也不一样，这个在网上查询一下即可）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abe76e8623e408ce6043494364d0e3fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32e4e77e4b52a99ce18f5b55bd852bbf/" rel="bookmark">
			DeepLabV3&#43;学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DeepLabV3+创新点 最近终于从FCN读完了DeepLab系列，算是对计算机语义分割有了一个初步的认识。在DeepLabV3中作者通过使用ASPP可以获得任意分别率（理论上是这样的，但是有GPU计算内存的限制）的特征图，然后通过线性插值上采样得到最后输出。但是在经过多层的卷积后，最后的特征图仍然会损失很多图像边缘的细节，如果进一步提高ASPP最后输出的特征图分辨率会导致backbone中更多的block使用膨胀卷积，使得计算的难度和复杂度急速上升。原文中这样说道：
Taking ResNet-101 [25] for example, when applying atrous convolution to extract output features that are 16 times smaller than input resolution, features within the last 3 residual blocks (9 layers) have to be dilated. Even worse, 26 residual blocks (78 layers!) will be affected if output features that are 8 times smaller than input are desired. Thus, it is computationally intensive if denser output features are extracted for this type of models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32e4e77e4b52a99ce18f5b55bd852bbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a375606659c6e0879d43ed9cd4bf6f8/" rel="bookmark">
			String、Json、List相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 导包： import org.json.JSONObject; 1.对象转string String strign = JSONObject.toJSONString(T); 2.string转对象 T t = JSONObject.parseObject(pojo, T.tclass); 3.Lits转String String jsons = JSON.toJSONString(tList); 4.String 转list List&lt;T&gt; list = JSONArray.parseArray(string, T.class); 5.String转json JSONObject jsonObject = JSON.parseObject(string); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd2701abc062a695c3555ef6f43af76/" rel="bookmark">
			青蛙跳台阶，上台阶问题，总览。解析版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这类问题考的其实是对数据的分析以及处理。
我在写时，发现他们的数据有规律。
最易看出的是n阶台阶，一次上1到n阶的方法。
n台阶12345方法124816 也就是2的n-1次方。
int fn(int k) { if (k &lt; 2) return 1; else return 2*fn(k-1)%100003;//因为最后测试数字过大，我选择取余来缩小数字，可以去掉%100003 } 在之后为了解决n阶台阶，一次1到k阶，我发现当k相同，每次总台阶不同时的规律。
n，k1,12,23,34,35,36,3方法12471324 因此，我发现第n项的方法等于前k项所和。
for (a = k+1; a &lt; n+1; a ++) { for(b = a-1; b &gt; a-k-1; b --) { f[a] = (f[b] + f[a]) % 100003; } } 总之，你绝对想不到，作为编程，需要运用到你的数学才能，加油。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb8700322102c45c68a9245af4a95f3/" rel="bookmark">
			Mimics-基础操作教程-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Mimics简介（Mimics21）
Mimics---是一种交互式医学图像处理软件，是一个连接二维图像数据(CT, MRI, 工业扫描数据)和三维工程学应用的图像处理工具。应用领域包括：解剖学测量、三维分析、有限元分析(FEA)、客制化植入体或装置设计、增材制造(3D打印)、以及手术计划和模拟。
2. 基础模块
Mimics可交互式读取DICOM格式的CT/MRI数据。可以使用分割和编辑工具操作数据来选择骨、软组织、皮肤等。选定区域被分离出来，可以在3D中可视化。在此可视化之后，可以创建一个文件来与STL+或Analysis对象交互。CAD数据以STL文件的形式导入，可以可视化为2D和3D，用于基于解剖几何结构的设计验证。
图1 主界面划分
3. 基础菜单功能
3.1 快捷菜单栏功能介绍
图2 快捷菜单栏
3.2 FILE菜单栏图3 FILE菜单
4.图像数据导入及操作
Mimics 不仅支持Dicom格式数据，而且能够直接导入扫描原始数据。Mimics也支持BMP,JPEG 以及TIFF 格式文件的导入。源文件可以通过在New Project手动导入。（在MedData文件夹下有测试文件可供练习）
1. 打开 New Project，查找MedData文件夹内数据，或者收集到的Dicom数据文件夹。
或者
2. 选择 .msc后缀名文件 或者 选择包含Dicom数据的文件夹。
3. 如果选择Dicom数据，Mimics 会直接读取DICOM 图像所带有的标签，自动创建一个Mimics 项目文件 ，点Open 打开。
4. 打开DICOM 文件图像，如果视图中有些方位标记有错需要修改， 在
IMAGE &gt; Change Orientation中打开窗口你可以通过右键鼠标选择正确的方位。
5. 基础快捷操作，可快速浏览图像信息。
Shift + 鼠标右键 平移：按住鼠标右键移动
Ctrl + 鼠标右键 缩放: 按住鼠标右键垂直移动来放大缩小
ArrowUp/滚轮 up 进入下一层
ArrowDown/滚轮 down 进入前一层
PageUp按键 向上进10 层
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb8700322102c45c68a9245af4a95f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92a2ccf3063f904ed85c4fc81c261b5c/" rel="bookmark">
			【IAR 】MSP430 IAR 编译报错：error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于转载的说明：原文内容可能会不断更新，要想得到最新的内容请跳到到原文看。
无编号警告类型：
1、Sat Jun 23, 2012 17:41:05: The stack pointer for stack 'Stack' (currently Memory:0xF5336) is
原因：新浪博客
IAR相关设置：Tools-&gt;Option-&gt;Stack-&gt;Warn when stack pointer is out of bounds.
The stack pointer for stack is outside the stack range
( 2012-06-24 20:36:38)
1、
Debugging using IAR Embedded Workbench
Because the IAR debugger is not presently aware of Micrium’s μC/OS-III operating system, the
following error may be reported when the debugger is halted:
Mon Sep 20 16:24:14 2010: The stack pointer for stack 'CSTACK' (currently
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92a2ccf3063f904ed85c4fc81c261b5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/644c715dd5ff0bcb8478a16d3b985023/" rel="bookmark">
			【MSP430中断】MSP430的IO口中断/中断特性|Px中断进不去 原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MSP430学习笔记之七：IO口中断
【端口中断进不去】Px中断进不去 原因 MSP430学习笔记之七：IO口中断 MSP430中断嵌套机制
(1) 430默认的是关闭中断嵌套的，除非你在一个中断程序中再次开总中断EINT。
(2) 当进入中断程序时，只要不在中断中再次开中断，总中断是关闭的，此时来中断不管是比当前中断的优先级高还是低都不执行。
(3)若在中断A中开了总中断，刚可以响应后来的中断B(不管B的优先级比A高还是低)，B执行完现继续执行。注意：进入中断B生总中断同样也会关闭，如果B中断程序执行时需响应中断C，则此时也要开总中断，若不需响应中断，则不用开中断，B执行完后中跳出中断程序进入A程序时，总中断会自动打开。
(4)若在中断中开了总中断，后来的中断同时有多个，则会按优先级来执行，即中断优先级只有在多个中断同时到来才起做用！中断服务不执行抢先原则。
(5)对于单源中断，只要响应中断，系统硬件自动清中断标志位，对于TA/TB定时器的比较/捕获中断，只要访问TAIV/TBIV，标志位倍被自动清除；对于多源中断要手动清标志位，比如P1/P2口中断，要手工清除相应的标志，如果在这种中断用“EINT()；”开中断，而在打开中断前没有清标志，就会有相同的中断不断嵌入，而导致堆栈溢出引起复位，所以在这类中断必须先清标志现打开中断开关。关于CPU部分我这次主要着重讲述下SR状态寄存器各位功能作用,对于C语言写已足够用了。另外还会补充一部单片机全局性的资料。
MSP430的中断分为3种：系统复位、不可屏蔽中断、可屏蔽中断。关于中断相关状态情况:
(1)系统复位的中断向量为0xFFFE。
(2)不可屏蔽中断的中断向量为0xFFFC。响应不可屏蔽中断时,硬件自动将OFIE、NMIE、ACCVIE复位。软件首先判断中断源并复位中断标志,接着执行用户代码。退出中断之前需要置位OFIE、NMIE、ACCVIE,以便能够再次响应中断。需要特别注意点：置位OFIE、NMIE、ACCVIE后,必须立即退出中断相应程序,否则会再次触发中断,导致中断嵌套,从而导致堆栈溢出,致使程序执行结果的无法预料。
(3)可屏蔽中断的中断来源于具有中断能力的外围模块,包括看门狗定时器工作在定时器模式时溢出产生的中断。每一个中断都可以被自己的中断控制位屏蔽,也可以由全局中断控制位屏蔽。多个中断请求发生时,响应最高优先级中断。响应中断时,MSP430会将不可屏蔽中断控制位SR.GIE复位。因此,一旦响应了中断,即使有优先级更高的可屏蔽中断出现,也不会中断当前正在响应的中断,去响应另外的中断。但SR.GIE复位不影响不可屏蔽中断,所以仍可以接受不可屏蔽中断的中断请求。
中断响应的过程：
(1)如果CPU处于活动状态,则完成当前指令;
(2)若CPU处于低功耗状态,则退出低功耗状态;
(3)将下一条指令的PC值压入堆栈;
(4)将状态寄存器SR压入堆栈;
(5)若有多个中断请求,响应最高优先级中断;
(6)单中断源的中断请求标志位自动复位,多中断源的标志位不变,等待软件复位;
(7)总中断允许位SR.GIE复位。SR状态寄存器中的CPUOFF、OSCOFF、SCG1、V、N、Z、C位复位;
(8)相应的中断向量值装入PC寄存器,程序从此地址开始执行。
中断返回的过程：
(1)从堆栈中恢复PC值,若响应中断前CPU处于低功耗模式,则可屏蔽中断仍然恢复低功耗模式;
(2)从堆栈中恢复PC值,若响应中断前CPU不处于低功耗模式,则从此地址继续执行程序。
下面又是个简单例程：
#include "msp430.h"
int main(void)
{
WDTCTL = WDTPW + WDTHOLD; // Stop watchdog timer
P1DIR |= 0x01; // Set P1.0 to output direction
P2DIR = 0; //set P2 is input all
P2IE = 0xFF; //the P2 interrupt is enable
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/644c715dd5ff0bcb8478a16d3b985023/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e28cd8ac76fb91a1e9cbd7fbe5e1d4fe/" rel="bookmark">
			【物联网】AT指令|AT返回错误|AT 指令 收发短信和GPRS上网 SIM508/548
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
常用AT命令解释
AT 指令 收发短信和GPRS上网 SIM508/548
AT指令返回错误 解释
CME错误： CMS错误
CME错误(英文)
CMS 错误(英文)
短信通信的几种情况和CMS错误
常用AT命令解释 一、 AT命令解释：
1、常用操作
1.1 AT
命令解释：检测Module与串口是否连通，能否接收AT命令；
命令格式：AT&lt;CR&gt;
命令返回：OK (与串口通信正常)(无返回，与串口通信未连通)
测试结果：AT
OK
1.2 AT+CSQ
命令解释：检查网络信号强度和SIM卡情况
命令格式：AT+CSQ&lt;CR&gt;
命令返回：+CSQ: **,##
其中**应在10到31之间，数值越大表明信号质量越好，##应为99。
否则应检查天线或SIM卡是否正确安装
测试结果：AT+CSQ&lt;CR&gt;
+CSQ: 31, 99
信号强度值会有少许变化，用手遮住天线，信号强度值会下降(大致在26左右)。
1.3 ATZ 命令解释：恢复原厂设置
命令格式：ATZ&lt;CR&gt;
命令返回：OK
1.4 AT+CGMR
命令解释：查询模块版本；
命令格式：AT+CGMR&lt;CR&gt;
命令返回： &lt;revision &gt;
+CMEERROR &lt;err&gt;
测试结果：AT+CGMR&lt;CR&gt;
R4A021 CXC1122528
OK
解释：模块版本号为R4A021
1.5 AT+IPR
命令解释：修改串口1波特率；
命令格式：AT+IPR=&lt;value &gt;&lt;CR&gt;
命令返回： ERROR OK 测试结果：AT+IPR=19200&lt;CR&gt;
OK
注意：串口波特率修改为19200后要把串口调试工具的波特率设为相应
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e28cd8ac76fb91a1e9cbd7fbe5e1d4fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68438e15914fb7417d90f9ec76665c3a/" rel="bookmark">
			Cannot resolve MVC View解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringMVC整合报错：
HTTP Status 404 – Not Found
Type Status Report
Message /view/success.jsp
Description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.
发现原因是：Cannot resolve MVC View
此处报错 Cannot resolve MVC View
原因是视图解析器xml配置文件的视图解析器配置路径出错，之前少了/WEB-INF，修改加上后，就OK了。
class path resource [mapper/] cannot be resolved to URL because it does not exist解决办法，这个核对了一下，都么有问题，删除tomcat的原来war包，重新加载一次就好了。！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8833abb242f91191c1b3a03e2112575/" rel="bookmark">
			Qt之TCP通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、TCP简介
二、TCP类
1.QTcpServer
2. QTcpSocket
三、TCP服务器
四、TCP客户端
五、获取本机网络信息
六、代码
1.TCP服务器
2.TCP客户端
一、TCP简介 TCP 协议（Transmission Control Protocol）全称是传输控制协议是一种面向连接的、可靠的、
基于字节流的传输层通信协议。TCP是大多数 Internet 协议（包括 HTTP 和 FTP）用于数据传输的低级网络协议。它是一种可靠的，面向流，面向连接的传输协议。它特别适合连续数据传输。
TCP 通信必须先建立 TCP 连接，通信端分为客户端和服务端。服务端通过监听某个端口来监听是否有客户端连接到来，如果有连接到来，则建立新的 socket 连接；客户端通过 ip 和port 连接服务端，当成功建立连接之后，就可进行数据的收发了。
需要注意的是，在 Qt 中把 socket 当成输入输出流来对待的，数据的收发是通过 read()和 write()来进行的，需要与常见的 send()与 recv()进行区分。
TCP 客户端与服务端通信示意图如下：
Qt 网络模块提供了编写 TCP / IP 客户端和服务器的类。它提供了较低级别的类，如代表低级网络概念的 QTcpSocket， QTcpServer 和 QUdpSocket，以及如 QNetworkRequest，QNetworkReply 和 QNetworkAccessManager 之类的高级类来执行使用应用层网络相关类和通用协议的网络操作。 它还提供了如QNetworkConfiguration， QNetworkConfigurationManager和QNetworkSession等类，实现承载管理。
二、TCP类 想要在程序中使用 Qt 网络模块，需要在 pro 项目配置文件添加network模块
QT += network
#include &lt;QtNetwork&gt; //在头文件中添加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8833abb242f91191c1b3a03e2112575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86641ecd6edf4cbca408e7c60dde9c34/" rel="bookmark">
			【JMeter】jmeter时间函数使用大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结一下jmeter的时间函数使用： 1、__time ：获取时间戳、格式化时间 1）${__time(,)} ：获取当前时间戳(当前时间的毫秒数)，默认精确到毫秒级别，13位数，如：1650356704900
2）${__time(,time_ms)} ：获取当前的时间戳并存入参数 time_ms 中
3）${__time(/1000,)} ：获取当前时间的秒数，精确到秒级别，10位数，如：1650356723
4）${__time(/1000,time_s)} ：获取当前时间的秒数并存入参数 time_s 中
5）${__time(yyyy-MM-dd,)} ：获取当前日期，如：2022-04-19
6）${__time(yyyy-MM-dd,time_date)} ：获取当前日期并存入参数 time_date 中
7）${__time(yyyy-MM-dd HH:mm:ss,)} ：获取当前时间，固定格式，如：2022-04-19 16:21:30
8）${__time(yyyyMMddHHmmss,)} ：获取当前时间，固定格式，如：20220419162107
9）${__time(YMDHMS,)} ：获取当前时间，固定格式，如：20220419-161941
10）${__time(yyyy-MM-dd HH:mm:ss:SSS,)} ：获取当前时间，固定格式，如：2022-04-19 16:23:02:876
11）${__time(yyyy-MM-dd’T’HH:mm:ss.SSS’Z’,)} ：获取当前时间，固定格式，如：2022-04-19T16:27:16.810Z
12）KaTeX parse error: Expected group after '_' at position 2: {_̲_intSum({__time(yyyy)},1,)} ：在当前年上+1年
13）KaTeX parse error: Expected group after '_' at position 2: {_̲_intSum({__time(MM)},1,)} ：在当前月上+1月
14）KaTeX parse error: Expected group after '_' at position 2: {_̲_intSum({__time(dd)},1,)} ：在当前日上+1日
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86641ecd6edf4cbca408e7c60dde9c34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f11c9519a7899a5ac4ef00ca3d3f8896/" rel="bookmark">
			字符串176、寻找字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串176、寻找字符串 题目描述 ​ 某天，路飞和女帝在公园里散步，走着走着，我的天！他们各自都捡到了一串漂亮的字符串，然而路飞好奇心比较重，他想知道自己的字符串在女帝的字符串中出现了多少次，例如女帝的字符串为 abababa ，路飞的字符串为 aba ，那么路飞的字符串在女帝的字符串中出现了 33 次。路飞一向比较傲娇，于是向你请教，你可以帮帮他么？
输入 ​ 输入包含两行，第一行为女帝捡到的字符串，第二行为路飞捡到的字符串。
​ 两个字符串可能包含除换行、回车、 \0外的任何字符。两个字符串长度均不大于 10001000 。
输出 ​ 请你帮女帝找出他的字符串里出现了多少次路飞的字符串。
样例输入1 i miss you! you 样例输出1 1 样例输入2 ossosso osso 样例输出2 2 数据规模与限定 ​ 时间限制：1 s
​ 内存限制：64 M
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main(){ char s1[1005],s2[1005],cha; scanf("%[^\n]",s1); scanf("%c",&amp;cha); scanf("%[^\n]",s2); int l1 = strlen(s1), l2 = strlen(s2), ans = 0; for(int i = 0; i &lt; l1 - l2 + 1; i++){ if(strncmp(s2, &amp;s1[i], l2) == 0){ ans++; } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f11c9519a7899a5ac4ef00ca3d3f8896/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84bbc0c4ad399fb36018d8174353da5c/" rel="bookmark">
			yolov5模型修改报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Traceback (most recent call last):
File "G:/yolov5/yolov5-6.1/train.py", line 651, in &lt;module&gt;
main(opt)
File "G:/yolov5/yolov5-6.1/train.py", line 544, in main
train(opt.hyp, opt, device, callbacks)
File "G:/yolov5/yolov5-6.1/train.py", line 129, in train
model = Model(cfg or ckpt['model'].yaml, ch=3, nc=nc, anchors=hyp.get('anchors')).to(device) # create
File "G:\yolov5\yolov5-6.1\models\yolo.py", line 112, in __init__
m.stride = torch.tensor([s / x.shape[-2] for x in self.forward(torch.zeros(1, ch, s, s))]) # forward
File "G:\yolov5\yolov5-6.1\models\yolo.py", line 126, in forward
return self._forward_once(x, profile, visualize) # single-scale inference, train
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84bbc0c4ad399fb36018d8174353da5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f992df156fa9ddb3f19b44f040e73129/" rel="bookmark">
			华为----VRF隔离（生产网和办公网的隔离）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、VRF 特性
二、案例讲解：
（1）网络拓扑+需求描述
（2） 相关配置：
实现需求 ①：生产网和办公网的隔离
实现需求②：各个网段实现上网需求 —— 路由泄露技术：
实现需求③: PC1和PC3之间相互通信
一、VRF 特性 VRF和VRF之间在同一台路由器上面无法通信；VRF和全局路由表（show ip route）在同一台设备也无法通信。在VRF里面定义RD和RT值，其中RT值分为两个方向，这边入方向的RT值和对方的出方向的RT值必须匹配才能接受路由 ——————————————————————————————————————————————————
二、案例讲解： （1）网络拓扑+需求描述 ———————————————————————————————————————————————————— （2） 相关配置： 实现需求 ①：生产网和办公网的隔离 CE系列交换机配置： &lt;HUAWEI&gt;system-view //进入全局模式 ------------------------------------------创建vlan [~HUAWEI]vlan 10 [*HUAWEI-vlan10]vlan 20 [*HUAWEI-vlan20]quit [*HUAWEI]commit //（commit）CE系列交换机，需要打commit配置才会生效 [~HUAWEI]display vlan //查看vlan ----------------------------------------接口划vlan [~HUAWEI]int g1/0/0 [~HUAWEI-GE1/0/0]port link-type access [~HUAWEI-GE1/0/0]port default vlan 10 [*HUAWEI-GE1/0/0]undo shut [*HUAWEI-GE1/0/0]quit -------------------------------------接口封装trunk [*HUAWEI]int g1/0/2 [~HUAWEI-GE1/0/2]undo shutdown [*HUAWEI-GE1/0/2]port link-type trunk [*HUAWEI-GE1/0/2]port trunk allow-pass vlan all //思科trunk允许所有vlan穿越，华为的默认不允许所有vlan穿越，修改一下 [*HUAWEI-GE1/0/2]quit [*HUAWEI]commit //写入所配置的命令（如果没有打这个命令，默认不会生效） [*HUAWEI]display current-configuration //相当于sh run [~HUAWEI]display interface brief //查看接口up情况 -------------------------①接口下关闭：核心交换机关闭接口二层功能（二层变三层） [~HUAWEI]int g1/0/1 [~HUAWEI-GE1/0/1]undo portswitch [*HUAWEI-GE1/0/1]q [*HUAWEI]commit ------------------------------------配置vlan ip &lt;HUAWEI&gt;save //保存配置，相当于write [*HUAWEI]int vlan 40 [*HUAWEI-Vlanif40]ip add 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f992df156fa9ddb3f19b44f040e73129/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c53c5d530e1fcbb9c5032a914783510/" rel="bookmark">
			【持久层框架】- SpringData - JPA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringData - JPA 😄生命不息，写作不止
🔥 继续踏上学习之路，学之分享笔记
👊 总有一天我也能像各位大佬一样
🏆 一个有梦有戏的人 @怒放吧德德
🌝分享学习心得，欢迎指正，大家一起学习成长！
JPA SpringData - JPAJPA简介什么是ORM？SpringData-JPASpringBoot整合JPA导入依赖编写配置文件创建实体类启动项目对表操作增加数据查看数据分页查找根据ID查找 方法命名规则自定义查询编写Repository 使用JPQL的方式查询(注解式SQL)计数参数传递 实体关系对应一对一一对多多对多 文章推荐 JPA简介 JPA 即Java Persistence API。是一款持久层框架，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。JPA的对象关系映射（ORM）模型是基于Hibernate。是一款面向对象的ORM框架，JPA不需要关心数据库字段，通过注解将数据库表与实体完成映射，在java中的操作只需要对实体进行操作即可。
什么是ORM？ ORM（Object-Relational Mapping） 表示对象关系映射。在面向对象的软件开发中，通过ORM，就可以把对象映射到关系型数据库中。只要有一套程序能够做到建立对象与数据库的关联，操作对象就可以直接操作数据库数据，就可以说这套程序实现了ORM对象关系映射。也就是说ORM是建立了一个实体与数据库表的关系，使得开发者对实体的直接操作而不是对数据库的操作，但操作实体也就等同于操作了数据库。
ORM框架还有：MyBatis、Hibernate
SpringData-JPA Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据库的访问和操作。
它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！
Spring Data JPA 让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现
在实际的工作工程中，推荐使用Spring Data JPA + ORM（如：hibernate）完成操作，这样在切换不同的ORM框架时提供了极大的方便，同时也使数据库层操作更加简单，方便解耦。
SpringBoot整合JPA 接下来通过一个案例简单学习一下JPA，并且在案例中学习一些相关知识。
导入依赖 需要导入jpa坐标和mysql依赖包
&lt;dependencies&gt; &lt;!--jpa--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Mysql依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写配置文件 先配置数据源，采用mysql8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c53c5d530e1fcbb9c5032a914783510/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b9080c5b92e5234e140e7cb16916b3d/" rel="bookmark">
			yolov5——问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
记录自己学习yolov5中遇到的问题，随即不定时更新，遇到问题记录下来方便回顾。
2022.05.06
1、改用VOC数据集进行训练，修改完格式后，运行train.py报错：
AssertionError: train: No labels in …/train.cache. Can not train without labels. See https://github.com/ultralytics/yolov5/wiki/Train-Custom-Data
解决方法：打开文件目录下 utils/dataset.py 文件，ctrl+F搜索define label，然后将框中内容修改为自己存放图片的文件夹名称，从"images"修改为"JPEGImages"即可。
2022.6.12
1、用云服务器训练的时候，遇到了这个问题：
ImportError: libgthread-2.0.so.0: cannot open shared object file: No such file or directory
解决方法：
apt-get update #安装额外的包 apt-get install libxext-dev apt-get install libxrender1 apt-get install libglib2.0-dev 2、冻结训练和解冻训练和预训练权重的问题
预训练权重是针对他们数据集训练得到的，如果是训练自己的数据集还能用吗？
预训练权重对于不同的数据集是通用的，因为特征是通用的。一般来讲，从0开始训练效果会很差，因为权值太过随机，特征提取效果不明显。对于目标检测模型来说，一般不从0开始训练，至少会使用主干部分的权值，虽然有些论文提到了可以不用预训练，但这主要是因为他们的数据集比较大而且他们的调参能力很强。如果从0开始训练，网络在前几个epoch的Loss可能会非常大，并且多次训练得到的训练结果可能相差很大，因为权重初始化太过随机。
因为目标检测模型里，主干特征提取部分所提取到的特征是通用的，把backbone冻结起来训练可以加快训练效率，也可以防止权值被破坏。在冻结阶段，模型的主干被冻结了，特征提取网络不发生改变，占用的显存较小，仅对网络进行微调。在解冻阶段，模型的主干不被冻结了，特征提取网络会发生改变，占用的显存较大，网络所有的参数都会发生改变。举个例子，如果在解冻阶段设置batch_size为4，那么在冻结阶段有可能可以把batch_size设置到8。下面是进行冻结训练的示例代码，假设前50个epoch冻结，后50个epoch解冻：
关于预训练权重加载。更改完网络结构后，即使更改了主干特征提取网络，也是可以加载预训练权重的。通过加载预训练权重，可以将网络中的参数初始化，我理解的是更有利于网络模型的复现，以及加快模型训练收敛速度。如下图所示，会根据你的网络结构，加载一部分参数。所以朋友们如果想改网络的话，也可以选择加载预训练模型的。
总结：无论换什么主干！！！都能用权重！！！都能用！！！都能用！！！
3、训练时出现以下问题：
TypeError: init() missing 1 required positional argument: ‘dtype’
翻译过来就是：类的构造函数需要一个’dtype’参数.但你创建类时没有传递
解决方法：
在train.py中把 num_workers 改小一些
2022-6-14
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b9080c5b92e5234e140e7cb16916b3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e767acf18cfc6c94f8300653cde6adf4/" rel="bookmark">
			搞懂Nginx&#43;keepalived实现双机热备，Nginx服务的高可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
何为Nginx服务高可用
keepalived实现Nginx服务的高可用，双机热备
Keepalived故障转移原理
双机主备缺点
环境搭建
环境准备
修改yum镜像源
搭建主节点
安装nginx-master
安装keepalived-master
修改keepalived.conf配置（默认抢占式）
启动keepalived
安装从节点
效果验证
模拟Master节点宕机
何为Nginx服务高可用 在使用 Nginx 做反向代理或者负载均衡的时候，都是以 Nginx 为入口，如果 Nginx 宕机了，那么所有的服务都无法正常提供，影响非常严重。所有我们需要保证 nginx 高可用，就是配置备份机，前一个挂了，还有后一个。
为了避免负载均衡服务器宕机造成严重影响，就需要建立一个备份机。主服务器和备份机上都运行高可用（High Availability）监控程序，通过传送诸如“I am alive”这样的信息来监控对方的运行状况。当备份机不能在一定的时间内收到这样的信息时，它就接管主服务器的服务IP并继续提供负载均衡服务；当备份管理器又从主管理器收到“I am alive”这样的信息时，它就释放服务IP地址，这样的主服务器就开始再次提供负载均衡服务。
高可用（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。如果一个系统能够一直提供服务，那么这个可用性则是百分之百，但是我们不能保证一个系统能永远不出问题，所以我们只能通过设计来尽可能的去减少由于系统的故障所造成的影响。
keepalived实现Nginx服务的高可用，双机热备 我们可以通过 keepalived 来实现 Nginx 的高可用，keepalived 是集群管理中保证集群高可用的一个服务软件，用来防止单点故障。Keepalived的作用是检测 web 服务器的状态，如果有一台 web 服务器死机或工作出现故障，Keepalived 将能检测到，并将有故障的 web 服务器从系统中剔除，当web服务器工作正常后 Keepalived 会自动将该 web 服务器加入到服务器群中。这些工作全部都会自动完成，不需要人工干涉，需要人工做的只是修复故障的web服务器。keepalived 可以理解为一个健康检查的软件。
高可用至少需要 2 台服务器，主备都得装上keepalived，当请求访问主服务器时，备份服务器会一直检查主服务器的状态。
keepalived 需要绑定一个虚拟地址 vip ( Virtual IP Address ) ，这个虚拟 ip 地址绑定在哪台服务器上请求就会发送到哪台服务器，一开始会绑定在主服务器上。
Keepalived故障转移原理 Keepalived之间的通过VRRP进行心跳检测
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e767acf18cfc6c94f8300653cde6adf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e05ac09384443b039e43fbcff27364f/" rel="bookmark">
			简单的蜜罐以及开源蜜罐HFish的安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.蜜罐的定义
2.蜜罐的类型
2.1.实系统蜜罐
2.2.伪系统蜜罐
3. 蜜罐的作用
4. 蜜罐系统架构
. 推荐的开源蜜罐系统
HFish
1.HFish的优点
2.HFish架构
3.HFish的安装
1.在线一键安装
2.离线安装
4.登录HFish
5.HFIsh的使用
5.1HFish基本结构
5.2 HFish各模块关系图
5.3节点
5.3.2 删除节点
6.修改蜜罐服务
6.1直接修改蜜罐服务
6.1.1添加蜜罐服务
6.2创建模版，应用到多节点
7.攻击查看
7.1 攻击列表 7.2 扫描感知
7.3 失陷感知 7.4 账号资产
7.5 攻击来源
7.6 样本检测
7.7 威胁检测
朔源
HFish溯源实现原理与测试方法
1.Mysql反制（支持内网，能够对攻击者机器做任意文件读取）
2.厂商vpn蜜罐反制（支持内网，能够获得windows机器登陆的微信号信息与桌面截图）
3.web型蜜罐溯源（不支持内网溯源）
4 .Java 远程调用蜜罐溯源（不支持内网溯源）
实验：使用namp扫密蜜罐查看扫描信息
1.蜜罐的定义 首先我们要弄清楚一台蜜罐和一台没有任何防范措施的计算机的区别，虽然这两者都有可能被入侵破坏，但是本质却完全不同，蜜罐是网络管理员经过周密布置而设下的“黑匣子”，看似漏洞百出却尽在掌握之中，它收集的入侵数据十分有价值;而后者，根本就是送给入侵者的礼物，即使被入侵也不一定查得到痕迹……因此，蜜罐的定义是:“蜜罐是一个安全资源，它的价值在于被探测、攻击和损害。”
设计蜜罐的初衷就是让黑客入侵，借此收集证据，同时隐藏真实的服务器地址，因此我们要求一台合格的蜜罐拥有这些功能:发现攻击、产生警告、强大的记录能力、欺骗、协助调查。另外一个功能由管理员去完成，那就是在必要时候根据蜜罐收集的证据来起诉入侵者。
2.蜜罐的类型 世界上不会有非常全面的事物，蜜罐也一样。根据管理员的需要，蜜罐的系统和漏洞设置要求也不尽相同，蜜罐是有针对性的，而不是盲目设置来无聊的，因此，就产生了多种多样的蜜罐……
2.1.实系统蜜罐 实系统蜜罐是最真实的蜜罐，它运行着真实的系统，并且带着真实可入侵的漏洞，属于最危险的漏洞，但是它记录下的入侵信息往往是最真实的。这种蜜罐安装的系统一般都是最初的，没有任何SP补丁，或者打了低版本SP补丁，根据管理员需要，也可能补上了一些漏洞，只要值得研究的漏洞还存在即可。然后把蜜罐连接上网络，根据目前的网络扫描频繁度来看，这样的蜜罐很快就能吸引到目标并接受攻击，系统运行着的记录程序会记下入侵者的一举一动，但同时它也是最危险的，因为入侵者每一个入侵都会引起系统真实的反应，例如被溢出、渗透、夺取权限等。
2.2.伪系统蜜罐 什么叫伪系统呢?不要误解成“假的系统”，它也是建立在真实系统基础上的，但是它最大的特点就是“平台与漏洞非对称性”。
大家应该都知道，世界上操作系统不是只有Windows一家而已，在这个领域，还有Linux、Unix、OS2、BeOS等，它们的核心不同，因此会产生的漏洞缺陷也就不尽相同，简单的说，就是很少有能同时攻击几种系统的漏洞代码，也许你用LSASS溢出漏洞能拿到Windows的权限，但是用同样的手法去溢出Linux只能徒劳。根据这种特性，就产生了“伪系统蜜罐”，它利用一些工具程序强大的模仿能力，伪造出不属于自己平台的“漏洞”，入侵这样的 “漏洞”，只能是在一个程序框架里打转，即使成功“渗透”，也仍然是程序制造的梦境——系统本来就没有让这种漏洞成立的条件，谈何“渗透”?实现一个“伪系统”并不困难，Windows平台下的一些虚拟机程序、Linux自身的脚本功能加上第三方工具就能轻松实现，甚至在Linux/Unix下还能实时由管理员产生一些根本不存在的“漏洞”，让入侵者自以为得逞的在里面瞎忙。实现跟踪记录也很容易，只要在后台开着相应的记录程序即可。
这种蜜罐的好处在于，它可以最大程度防止被入侵者破坏，也能模拟不存在的漏洞，甚至可以让一些Windows蠕虫攻击Linux——只要你模拟出符合条件的Windows特征!但是它也存在坏处，因为一个聪明的入侵者只要经过几个回合就会识破伪装，另者，编写脚本不是很简便的事情，除非那个管理员很有耐心或者十分悠闲
3. 蜜罐的作用 蜜罐系统主要作用是欺骗黑客，捕捉攻击行为。
蜜罐会提供一些和真正业务系统非常类似的服务，如数据库，Web，FTP，Mail，SSH，Samba等，里面也会存放一些看似有用的业务数据，而且这些服务都是存在安全漏洞，容易被各种攻击工具识别，从而吸引黑客攻击。然后在与黑客交互的过程中，后台记录从哪个IP，哪个账号进行了什么操作，并将日志传输到一台安全的服务器（防止黑客抹掉蜜罐的日志），一般接入SIEM（安全信息和事件管理）服务器，进行统一存储，分析并处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e05ac09384443b039e43fbcff27364f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea6430de1f2496fd1a8bbea245bd478a/" rel="bookmark">
			Java Dynamic Proxy And Aspect Application (一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dynamic Proxy And Aspect 一 综述动态代理1.术道之争OPPOOPAOP 2.综合理解 二 Java 动态代理1.JDK &amp; CGLIB2.选型 三 测试1.JDK动态代理1.反射简述2.动态代理3.源码简析（可忽略，仅记录了一下源码大概调用顺序） 2.CGLIB动态代理1.依赖2.动态代理3.简析 一 综述动态代理 1.术道之争 OPP 面向过程（Procedure Oriented Programming） 针对某一功能专门设计，独立完成上下文所有工序，尖兵性质，工作效率高 比如：西红柿炒鸡蛋，一套完成；西红柿鸡蛋汤，又一套程序 OOP 面向对象（Object Oriented Programming） 针对系统设计，各个模块分工协作，以对象为单位，易于管理和能力复用 比如：西红柿处理、鸡蛋处理、调味料处理、厨具处理 组合产出：西红柿炒鸡蛋 或者 西红柿鸡蛋汤 AOP 面向切面（Aspect Oriented Programming） 针对系统某两个对象的工序之间插入一个切面方法，用于特殊处理，更加灵活 比如：在每次西红柿炒鸡蛋出锅前插入一个切面，判断是要甜口或咸口，并添加调料 2.综合理解 综合来看，面向过程设计的方法，每种实现都要完整设计；如果将方法内的通用部分抽象为一个对象，并将对象供其他方法调用，则系统将被简化，并且易于管理所抽象出的公共方法，从而使原来复杂的方法便于统一修改实现；多个对象又可以组合成更复杂的功能，通过切面，切入两个对象之间，对下游对象做增强，针对下游对象的某个方法做前置、环绕、后置处理，使系统功能更加复杂
无论是社会发展，工业生产，还是【软件开发】，一个系统的组成和完善，一定在内、外双驱动力下经历自我成长为稳定、合理、高效系统的过程。世间万物基于真理的潜在关联都是相通的。
二 Java 动态代理 如果AOP是道，动态代理就是术，即通过一定编码规则使AOP的切面自动织入系统，而不需要人为去做编写增强方法的适配。Java 内有两种方法实现：JDK动态代理、CGLIB动态代理
1.JDK &amp; CGLIB 项目JDKCGLIB手段反射机制字节码处理框架ASM效率生成高，执行低生成低，执行高限制委托机制，仅针对接口类继承机制，非Final修饰的类实现1.实现InvocationHandler接口，重写invoke()
2.使用Proxy.newProxyInstance()产生代理对象
3.被代理的对象必须要实现接口1.依赖于CGLib的类库
2.实现MethodInterceptor接口，重写intercept()
3.使用Enhancer对象.create()产生代理对象 2.选型 如果类实现了接口，则可以使用JDK自带的动态代理，否则只能使用基于ASM的CGLIB，注意类如果被Final修饰则无法继承，则无法使用CGLIB；Springboot默认优先使用JDK的，如果不满足条件会自动切换CGLIB
三 测试 1.JDK动态代理 1.反射简述 双亲委派模型保证了Jvm加载Class对象的唯一性，通过Java Reflection API可以拿到任何一个已知名称的类 的内部信息，如Fields（属性）、Method（方法）、Constrous（构造） 反射机制允许我们动态的调用某个对象的方法/构造函数、获取某个对象的属性等，而无需在编码时确定调用的对象 定义一个兔子类
package com.demo.reflect; /** * @author * @date 2022-10-02 18:25 * @since 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea6430de1f2496fd1a8bbea245bd478a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/328ff88d23208411c3f9d32058a57801/" rel="bookmark">
			【数字图像处理】Anaconda下安装OpenCV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章内容极大程度上引用了Anaconda下安装OpenCV，只是根据个人的情况稍作了一些简单的修改。原文章写的已经很好了，只是我根据我的需求稍微修改了下方便我后期进行查找。
目录 查看版本：下载和安装OpenCV1.下载2.安装 检验OpenCV一些OpenCV的简单操作 查看版本： 可以在Anaconda Prompt里查看Anaconda的版本和Python的版本
第一步：打开Anaconda Prompt
第二步：查看Anaconda的版本。输入命令 conda -V（个人认为conda的版本影响不是太大哈）
第三步：查看Python的版本。可以直接在查看完Anaconda之后查看。输入命令python即可。
查看自己使用的版本是为了方便找到对应的OpenCV的版本。工具有不同的版本，不同的工具对应使用的版本也不一样。就好比不同的人要对应差不多的年纪结合一起使用，这样更加方便。
下载和安装OpenCV 1.下载 OpenCV的下载可以去官网下载，找到自己需要的版本，轻点小指头就可以下载啦。
Releases - OpenCV https://opencv.org/releases/ 也可以使用镜像。（更快）
Links for opencv-python (tsinghua.edu.cn) https://pypi.tuna.tsinghua.edu.cn/simple/opencv-python/ 可以找到很多的版本
opencv_python是OpenCVde Python的API接口
cp38-win-amd64 是对应的python3.8.X和Windows操作系统64位。（版本这块python版本和系统都要对应上哈）
轻点小指头就能下载好啦
2.安装 安装opencv需要用到的numpy和scipy：
pip install numpy pip install scipy 最后将之前下载好的opencv（whl格式）安装进工作环境
找到存放文件的地址，将他复制到你环境的lib的site_packages中（详细路径如图）
在prompt中安装opencv
pip install D:\Anaconda\envs\pytorch\Lib\site-packages\opencv_python-4.5.4.60-cp36-cp36m-win_amd64.whl
最后这个版本的信息需要根据你下载的opencv版本吧来进行修改
检验OpenCV import cv2 print(cv2.__version__) # 有两个下划线 检测完成后就可以使用opencv了
一些OpenCV的简单操作 import cv2 as cv 读取图片：
source_img = cv.imread('图片路径') 查看读取的图片：
注意：opencv读进来的图片已经是一个numpy矩阵了，彩色图片维度是（高度，宽度，通道数）。数据类型是uint8
cv.imshow("img", source_img) cv.waitKey(0) # 这个是让opencv等待，如果不等待的话图片展示一下就退出了 查看图片大小
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/328ff88d23208411c3f9d32058a57801/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a110029f5d58e084a40cdfaa84f56cc/" rel="bookmark">
			组合数四大相关求法详解（附模板）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 求组合数加法递推 -- O（$n^2$）乘法递推 -- O（$nlogn$）Lucas 定理 -- O($log_p^n × p logp$)求大组合数 （高精度） 求组合数 加法递推 – O（ n 2 n^2 n2） Problem A 求组合数Ⅰ
​ 给定 n 组询问，每组询问给定两个整数 a ， b ， 请你输出 C a b m o d ( 1 0 9 + 7 ) C^b_a \ \ mod ~~(10^9 + 7) Cab​ mod (109+7) 的值
1 &lt;= n &lt;= 100000, 1 &lt;= b &lt;= a &lt;= 2000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a110029f5d58e084a40cdfaa84f56cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2518c7b876ac046752b8dd54a4c86191/" rel="bookmark">
			Window7 docker安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载docker toolbox
docker-toolbox-windows-docker-toolbox安装包下载_开源镜像站-阿里云
-ce后缀的是免费的版本，其他是收费版本
二、安装
安装完成即可
三、启动docker
双击 Docker Quickstart Terminal启动
其他问题：
启动拉boot2docker镜像失败
上github下载boot2docker放到C:\Users\[userName]\.docker\machine\cache目录,重新启动虚拟机
https://github.com/boot2docker/boot2docker/releases
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc4f1ce2fbe02de021a3c10509f11f1a/" rel="bookmark">
			Tomcat&#43;Servlet&#43;mysql登录注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1:先写登录的jsp文件 ,文件名叫做index.jsp
&lt;%-- Created by IntelliJ IDEA. User: Acer Date: 2022/9/28 Time: 21:45 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="Register.jsp"&gt;注册&lt;/a&gt; &lt;form action="LogoServet" method="post"&gt; 账号:&lt;input type="text" name="id" &gt;&lt;br&gt; 密码: &lt;input type="password" name="pwd"&gt;&lt;br&gt; &lt;input type="submit" value="登录"&gt;&lt;input type="reset" value="重新输入"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 2.再写注册的jsp文件,文件名叫Register.jsp
&lt;%-- Created by IntelliJ IDEA. User: Acer Date: 2022/9/28 Time: 21:45 To change this template use File | Settings | File Templates.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc4f1ce2fbe02de021a3c10509f11f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1399c9448476161721c80725071e20c3/" rel="bookmark">
			程序训练6 相关提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基础知识提示 1. 循环输入问题 请看这段代码：
char ch; while(true){ cin &gt;&gt; ch; if(ch == '=') break; if(ch == ' ') continue; cout &lt;&lt; ch; } cout &lt;&lt; endl; 想一想会发生什么呢？
如果对break这些语法不太清楚可以上网自行查阅。
2. 字符的存储本质 字符都是可以用ascii码表示的，字符之间可以做加减法。
cout &lt;&lt; (char)('a' + 1) &lt;&lt; endl; 这会输出什么呢？
(char)的意思是类型转换，将’a’+1的计算结果从int转换成char
计算过程：
将’a’转换成int（参照ascii码值）完成相加计算得到整数结果转换回char类型 解题提示 A. Sum of Numbers char 类型的 ‘9’-‘0’ 等于多少呢？如何实现数字字符到数字的快速转换呢？如何比较两个string是否相等？如何比较两个char数组内容是否相等（可能需要查阅一些函数）？ B. Counting Characters https://blog.csdn.net/Victayria/article/details/127115939?spm=1001.2014.3001.5501
C. Ring 如何获取输入的string的长度题目理解很关键：注意标题 ring D. Finding a Word 如何用空格将一句话分割开？或许不用真的分割开，只需要两个下标就能表示一个单词的头尾？如何让第二个下标在没有发现空格的时候就保持一直++，直到发现空格，那么第一个下标和第二个下标形成的左闭右开区间就是一个单词自行查阅string类型获取子串的函数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0261f7cd732bf30b28a9fb164a147e5a/" rel="bookmark">
			SpringBoot2.1.9 MongoDB的聚合连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LookupOperation lookupOperation= LookupOperation.newLookup(). from(AdminRepository.instance().getTableName()). //关联从表名 localField(User.Fields.name). //主表关联字段 foreignField(Admin.Fields.name).//从表关联的字段 as("adminInfo"); //查询结果名 Criteria left = Criteria.where(User.Fields.city).exists(true) .andOperator(Criteria.where(User.Fields.age).gte(18), Criteria.where(User.Fields.age).lt(65)); Criteria right = Criteria.where("adminInfo.0").exists(true).and("adminInfo.0.admin").is(1); GroupOperation group = Aggregation.group(User.Fields.city).first(User.Fields.age).as("firstAge") .avg(User.Fields.age).as("avgAge").addToSet(User.Fields.age).as("ageList") .count().as("count").max(User.Fields.age).as("maxAge") .push(User.Fields.age).as("ageField"); ProjectionOperation projectionOperation = Aggregation.project("_id") .and("adult").applyCondition(ConditionalOperators.Cond.when(Criteria.where("firstAge").gt(12)) .then(1).otherwise(0)); Aggregation aggregation = Aggregation.newAggregation(Aggregation.match(left), lookupOperation, Aggregation.match(right), Aggregation.unwind("adminInfo", true), group, projectionOperation); List&lt;Map&gt; results = this.getMongoOperations().aggregate(aggregation, this.getTableName(), Map.class).getMappedResults(); 一、聚合
（1）匹配
Aggregation.match(left) （2）分组
GroupOperation group = Aggregation.group(User.Fields.city).first(User.Fields.age).as("age") .avg(User.Fields.age).as("avgAge").addToSet(User.Fields.age).as("ageList") .count().as("count").max(User.Fields.age).as("maxAge") .push(User.Fields.age).as("ageField"); （3）投影
ProjectionOperation projectionOperation = Aggregation.project("_id") .and("adult").applyCondition(ConditionalOperators.Cond.when(Criteria.where("firstAge").gt(12)) .then(1).otherwise(0)); （4）扁平化数组
Aggregation.unwind("adminInfo", true) 二、连接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0261f7cd732bf30b28a9fb164a147e5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad0cdd18be7d1b018b318569bb1ed60a/" rel="bookmark">
			51单片机——时钟显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、硬件电路：AT89C51,上拉电阻，共阳数码管
1.整体电路图
（在这里我没有给单片机接晶振部分的时钟电路以及其他一些基本电路，因为在proteus里面不需要接也能正常工作，仿真就是仿真，但在实际电路中还是有些本质区别的，所以实际电路中一定要接，实际中显示与仿真还是有区别的。同时在实际中不会出现这种不亮的情况，只会亮度更低，如果亮度低了就加延时，如果肉眼分辨的出每位亮起的时间差就减少延时。）
2.八段式数码管
从数码管电极性质可分为共阳数码管（CA）和共阴数码管（CC），共阴接法（左）的com端接低电平，共阳接法（右）的com端接电高电平，a,b,c,d,e,f,g,dp分别对应数码管上的一段。
字形码代码表 显示字符段符号十六进制dpgfedcba共阴极共阳极0001111113FC010000011006F92010110115BA43010011114FB040110011066995011011016D926011111017D8270000011107F88011111117F809011011116F 90
二、工程源码：
#include &lt;REGX51.H&gt; #define uchar unsigned char #define uint unsigned int uchar data table_w[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};//共阳数码管位码组 uchar data table_d[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};//共阳数码管段码组 uchar count,shi=23,fen=59,miao=50;//定义时分秒 void delayms(uchar x)//延时函数 { uchar i,j; for(i=0;i&lt;x;i++) for(j=0;j&lt;120;j++);} void t0_init() { TMOD=0x01;//设置T0为方式1定时 TH0=15536/256;//装初值的高8位 TL0=15536%256;//装初值的低8位 ET0=1;//开启定时器中断允许 EA=1;//开启总中断 TR0=1;//T0运行控制位1，启动定时器0 } void t0_break()interrupt 1//中断服务程序，1代表0003B入口 { TH0=15536/256; TL0=15536%256;	count++;//计数20次 if(count==20)//20*50=1000ms=1s，即每隔1s加1 { miao++; count=0; }	if(miao==60)//miao=60时清零，分加1 { fen=fen+1; miao=0;	} if(fen==60) { shi=shi+1; fen=0; } if(shi==24) {shi=0;} } void display(uchar wei,uchar duan)//定义P0，P2端口 { P2=table_w[wei]; P0=table_d[duan]; delayms(5); } void main() { t0_init(); while(1) { display(0,shi/10);//shi/10高八位取整（十位） delayms(10);	display(1,shi%10);//shi%10低八位取余（个位） delayms(10);	display(3,fen/10); delayms(10); display(4,fen%10); delayms(10); display(6,miao/10); delayms(10); display(7,miao%10); delayms(10); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d36794f91509e8e77d488eccef7c8c1b/" rel="bookmark">
			Centos7修改DNS教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DNS是计算机域名系统(Domain Name System 或Domain Name Service) 的缩写，它是由域名解析器和域名服务器组成的。域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器。其中域名必须对应一个IP地址，一个IP地址可以有多个域名，而IP地址不一定有域名。域名系统采用类似目录树的等级结构。域名服务器通常为客户机/服务器模式中的服务器方，它主要有两种形式：主服务器和转发服务器。将域名映射为IP地址的过程就称为“域名解析”。一般运作中的域名最好有两台或以上的DNS服务器，一台称为主域名服务器，而另一台称为从域名服务器。第二个DNS服务器通常用于故障转移：如果一台宕机，另外一台就激活成为DNS服务器。
Linux机器默认的DNS通常为114.114.114.114或者8.8.8.8，而我们有时会碰到无法连接到github or docker站点的情况，造成这种问题的原因可能是机器默认dns问题，我们这时候更换一下机器的dns往往可以解决。
Centos7修改DNS教程：
修改/etc/resolv.conf文件
1.修改 /etc/NetworkManager/NetworkManager.conf 文件，在main部分添加 “dns=none” 选项：
dns=none 2.保存后重启服务
systemctl restart NetworkManager.service 3.然后修改/etc/resolv.conf文件
nameserver 114.114.114.114 nameserver 8.8.8.8 4.重启网卡
service network restart 注：
国内外常见公共DNS：（国内推荐114 or 阿里，海外推荐Google or Cloudflare）
国内DNS： 114DNS：114.114.114.114、114.114.115.115 阿里云DNS：223.5.5.5、223.6.6.6 腾讯DNS：119.29.29.29、119.28.28.28 百度DNS：180.76.76.76 CNNICDNS：1.2.4.8 360DNS：101.226.4.6 国外DNS： 谷歌DNS：8.8.8.8、8.8.4.4 CloudflareDNS：1.1.1.1、1.0.0.1 IBM DNS：9.9.9.9 OpenDNS：208.67.222.222、208.67.220.220 新加坡nttsDNS：202.136.162.11 西门子DNS服务器（香港）：112.121.178.187 香港 亚太环通(Pacnet)有限公司DNS服务器：202.14.67.4、202.14.67.14 香港 汇港电讯DNS服务器：202.130.97.65、202.130.97.66 中国台湾中华电信：168.95.192.1 本文转载自天乐博客：https://blog.361s.cn/106.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4690d742ba375f3f435dab35a94722f/" rel="bookmark">
			C#面向对象程序设计课程实验二： 实验名称：Windows 窗体程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#面向对象程序设计课程实验二： 实验名称：Windows 窗体程序 实验内容：Windows 窗体程序一、实验目的及要求二、实验环境三、实验内容与步骤一、设计简单的计算器3.1、实验内容3.2、实验步骤二、设计选购计算器配置的应用程序3.1、实验内容3.2、实验步骤 四、实验总结 实验内容：Windows 窗体程序 一、实验目的及要求 (1) 掌握控件 Label、Button、TextBox 的常用属性、方法、事件的基本应用；(2) 掌握控件 RadioButton、CheckBox 的常用属性、方法、事件的基本应用通过简单程 序；(3) 掌握框-架类控件 GroupBox、Panel、TabControl 的基本应用；(4) 掌握控件 ListBox、CombBox 、ListView 的常用属性、方法、事件的基本应用；(5) 掌握 Windows 应用程序的结构；(6)掌握 WinForm 的设计(7)进一步学习掌握查找与修改编译错误的方法； 二、实验环境 Microsoft Visual Studio 2008
三、实验内容与步骤 一、设计简单的计算器 3.1、实验内容 设计一个简单的计算器，使其可以进行加、减、乘、除计算，程序运行状态如图所 示。（教材第 4 章 113 页 3.1 题） 如下所示
3.2、实验步骤 1、实验界面的属性设置如下：
（1）三个Lable的Text属性：第一个数、第二个数、运算结果。（2）四个RadButton的Text属性和Name属性：＋和radAdd、－和radSub、×和radMul、÷和radDiv。（3）一个Button的Name和Text属性：btnOk和运算。 2、实验程序的设计代码如下：
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; namespace 实验二_1_ { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void btnOk_Click(object sender, EventArgs e) { double a, b; a = Convert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4690d742ba375f3f435dab35a94722f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ab27ec47fbb0252bd9973164b527a5/" rel="bookmark">
			【Java】设计模式之单例模式与工厂模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱后端语言的大学生，CSDN内容合伙人
✨精品专栏：C++面向对象
🔥系列专栏：JavaSE精品总结
文章目录 前言1、设计模式概念及分类2、单例模式2.1、饿汉式2.2、懒汉式2.2.1、懒汉式进阶版2.2.2、懒汉式之懒加载 3、工厂模式3.1、书写实体类3.2、新建配置文件.properties3.3、书写工厂类并创建对象3.4、对工厂类测试 前言 国庆节快乐！今天家里的风很凉爽，就好像在为国庆而欢呼！与此同时我决定把Java的设计模式总结一番，为以后能够书写清晰的项目结构打下基础。
1、设计模式概念及分类 简单来说设计模式是被广大程序员们总结并认可的编码套路，其中最常用的莫过于单例模式与工厂模式，而单例模式也有更加细的分类，一起来学习一下这些模式的用法和特点吧。
2、单例模式 一个类只能被实例化出来一个对象 2.1、饿汉式 无论如何，都会创建出来一个对象思路：
在类中直接实例化一个用来返回的对象，再为外界提供一个获取该对象的方法缺点：有可能造成空间浪费 代码解释：
/** * 单例模式-饿汉式 */ public class ClassA { //唯一的、全局的、私有的、用来返回的对象实例 private static ClassA ca=new ClassA(); //方法：用来被外界调用，从而获取该类的唯一实例 //static：为了使外界直接通过类名调用该方法 public static ClassA getClassA(){ return ca; } //私有化构造：避免外界通过构造创建该类的对象 private ClassA(){} } public class Test { public static void main(String[] args) { ClassA ca1=ClassA.getClassA(); ClassA ca2=ClassA.getClassA(); System.out.println(ca1==ca2);//true } } 相当于类加载，ca1和ca2都是类对象，为同一个对象，要与类的对象有所区分。
2.2、懒汉式 思路：只有当需要创建唯一实例时，才会在对应方法中进行实例化 使用synchronized来同步方法 缺点：同步方法效率太慢，线程效率低 代码解释：
/** * 单例模式-懒汉式 */ public class ClassB { //声明用来返回的对象引用 private static ClassB cb=null; //synchronized:避免线程安全问题 public synchronized static ClassB getClassB(){ if (cb==null){//非空判断，避免重复创建 cb=new ClassB(); } return cb; } //私有化构造 private ClassB(){} } 这里利用了synchronized来防止重复创建实例化对象：如果事先没有创建，那就新创建，不会浪费空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64ab27ec47fbb0252bd9973164b527a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6bf1c7c9b72c592d406a91cfd98a235/" rel="bookmark">
			Mac 如何使用外部存储设备，移动硬盘备份 iPhone 数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac 如何使用外部存储设备，移动硬盘备份 iPhone 数据 一、问题描述 前段时间碰到一个问题，我 iPhone 背板碎了，需要走 AppleCare 交给苹果返厂维修，而我的 iPhone 是 512GB 的，在备份数据时候麻烦了，我笔记本本身就是 512GB 空间的，肯定不够用呀。
而备份 iPhone 默认的存储位置是在本机的硬盘上，我有个 14T 的硬盘，那么如何将默认的备份位置改到外部存储设备上呢。
二、如何设置备份位置到外部存储器 默认的备份位置在下面这个目录
~/Library/Application Support/MobileSync/Backup 其目录是这样的，Backup 里面就是你的每个设备每次的备份记录
我们要做的就是将这个位置映射到你的移动硬盘上去。
1. 确定你的移动硬盘位置 你需要知道自己硬盘的完整文件路径：
打开终端，输入 cd 然后将你的硬盘图标拖到终端中，就会看到它的路径了回车进入到移动硬盘目录下，指令 ls -al 能看到硬盘中的所有文件（图片中的 ll 是我自定义的一个指令）我的就是 /Volumes/Kyle 14TB/ （在终端的路径需要转义空格，所以能看到终端中名字空格前面有个 \） 2. 移动硬盘中新建一个备份文件夹 在你的移动硬盘中新建一个备份文件夹，用于存储接下来的手机备份文件。
mkdir Backup 此时能看到目录中多出一个名为 Backup 的文件夹
进入这个文件夹并展示它的绝对路径
cd Backup pwd 能看到我的这个文件夹的绝对路径是 /Volumes/Kyle 14TB/Backup，这个会在下面用到。
3. 备份系统原有 Backup 文件夹 进入 ~/Library/Application Support/MobileSync 目录，并删除或重命名 Backup 文件夹。
如果你之前有已经备份的东西，可以将其重命名成其它名字，总之就是不要占用 Backup 这个名字就好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6bf1c7c9b72c592d406a91cfd98a235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337a8e68bb4dbb2839c455b1d8eb7286/" rel="bookmark">
			OpenCV之图像梯度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Sobel算子 OpenCV系列—本文底页有多个常用方法链接
1.1 Sobel介绍 cv2.Sobel(src, ddepth, dx, dy, ksize)
ddepth:图像的深度dx和dy分别表示水平和竖直方向ksize是Sobel算子的大小 import cv2 # opencv读取的格式是BGR def cv_show(img, name): cv2.imshow(name, img) cv2.waitKey() cv2.destroyAllWindows() img = cv2.imread('../img/pie.png', cv2.IMREAD_GRAYSCALE) cv2.imshow("img", img) cv2.waitKey() cv2.destroyAllWindows() pie.png原图（右击另存为下载）:
1.2 横向Sobel算子 采用上述公式中的 G x G_{x} Gx​滤波器扫描整张图，提取了左右两边有梯度差的位置，但是横向看圆的上顶端和下顶端的梯度不明显所以呈现图片如下上下端为虚线的圆。
sobelx = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=3) cv_show(sobelx, 'sobelx') 结果如下:
白-黑是正数，黑-白就是负数了，所有的负数会被截断成0，所以要取绝对值。
sobelx = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=3) sobelx = cv2.convertScaleAbs(sobelx) cv_show(sobelx, 'sobelx') 加入绝对值后，梯度结果就可以有一个完整的圆:
1.3 纵向Sobel算子 采用上述公式中的 G y G_{y} Gy​滤波器扫描整张图，提取了上下两边有梯度差的位置，但是纵向看圆的左顶端和右顶端的梯度不明显所以呈现图片如左右端为虚线的圆。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/337a8e68bb4dbb2839c455b1d8eb7286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2353e7539f5a0f33434361d120c97563/" rel="bookmark">
			AlmaLinux-9.0-x86_64-minimal 虚拟机集群基本配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）配网！ 安装虚拟机之后发现没有网络：
准备网络配置：
# 进入网络配置文件夹 cd /etc/sysconfig/network-scripts # 浏览网卡配置文件 ls -a # 浏览过后发现并没有网卡配置文件，自定义网卡配置文件 vim ifcfg-eth0 # 网卡信息 TYPE=Ethernet DEVICE=ethe0 ONBOOT=yes BOOTPROTO=static IPADDR=172.16.77.181 NETMASK=255.255.255.0 GATEWAY=172.16.77.254 DNS1=172.16.77.14 DNS2=8.8.8.8 IPV6INIT=no （2）下载Java环境 配置Java环境：
# 查看本机是否有Java环境 yum list installed | grep java # 查看能下载的jdk版本号 yum search java | grep jdk #下载jdk1.8 yum install -y java-1.8.0-openjdk* #将java导入环境变量文件中 vim /etc/profile （3）域名映射 主机名host映射（hosts文件）。
当我们输入主机名或者域名的时候，系统会首先去本地hosts文件中寻找映射关系看对应的ip是多少。如果有映射关系就根据对应的ip去访问机器。
如果本地hosts文件没有映射，系统就会去访问DNS服务器进行域名解析。
# 编辑/etc/hosts文件即可 vim /etc/hosts 在windows系统中打开hosts文件：
（4）配置主机名 # 查看当前主机信息 hostnamectl # 永久修改主机名称 hostnamectl set-hostname 要修改的主机名 # 重启 reboot （5）防火墙的关闭 关闭命令为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2353e7539f5a0f33434361d120c97563/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c35c4b27bedb2c7ffc18f333c16b1ea5/" rel="bookmark">
			TexStudio的安装与使用教程（包括参考文献的引用）Latex教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TexStudio的安装与使用教程（包括参考文献的引用） 1 安装TexStudio1.1 以Mac为例： 2 texStudio的使用2.1 编辑数学公式1. 从word公式转化为Latex2. 书写方法：怎么写？公式写法整体介绍写什么？-图形化查询公式代码公式编号被挤到下一行怎么办跨栏表格位置跑到了下一页_LaTeX双栏模板插入通栏公式（跨栏插图）公式换行&amp;符号 2.2 编辑图像caption图像标题位置设置 2.3 编辑表格2.3.1 制作三线表2.3.2 表格居中2.3.3 如何快速生成表格的latex公式2.3.4 如何放缩表格2.3.5 latex表格之间间距过大 2.4 返稿高亮2.5 编辑段落2.5.1 段落顶格 2.6 编辑伪代码2.7 将 EndNote 文献信息导出成 BibTeX 格式 3期刊的tex模版下载与使用3.1 ELSEVIER期刊3.2 IEEE期刊 1 安装TexStudio Mac安装TexStudio教程
Windows安装TexStudio教程
1.1 以Mac为例： 基本步骤：下载安装MacTeX – 下载安装texstudio （一定要按照顺序，以防报错）
2 texStudio的使用 2.1 编辑数学公式 1. 从word公式转化为Latex mac如何将word中的公式转为latex格式
除了上述方法，还发现，如果直接将word里的公式复制到texstudio当值，会直接变成对应的公式，尽管可能有部分需要微调，但总体上复制过去后，只要添加局部公式$公式$ 或者添加\begin{equation}\end{equation}即可。
例如：word中的下面式子：
直接复制到texstudio就回变成如下：
我们只需要添加一下公式的代码即可
\begin{equation} DAG_d=\left(d,A_d,E_d\right) \end{equation} 2. 书写方法： 怎么写？公式写法整体介绍 Texstudio公式总结
数学公式的前后要加上$或\，比如：$f(x) = 3x + 7$和\(f(x) = 3x + 7) \效果是一样的；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c35c4b27bedb2c7ffc18f333c16b1ea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c985ce3e38c78d023058e73edcce9f9/" rel="bookmark">
			Post请求中@RequestParam和@RequestBody的混合使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在一个@RestController方法中混合使用@RequestParam和@RequestBody呢？就像这样的代码：
@PostMapping("/scanRecord") public Response scanRecord(@RequestParam("t") int type, @RequestBody ScanRecord scanRecord) { System.out.println("type="+type); System.out.println(JSON.toJSONString(scanRecord)); return Response.ok(); } @RequestBody用来接收http post请求的body，前端传入序列化好的json数据，后端可以解析为json对象（Content-Type需要指定为 application/json）。
@RequestParam用来接收请求url?后面的参数，或者Content-Type为multipart/form-data、application/x-www-form-urlencoded时的http body数据。
所以，如果想要在@RestController的一个方法中，同时接收@RequestParam和@RequestBody数据，前端应该这样用：
application/json的方式传入@RequestBody接收的对象，并且在url?后带上@RequestParam需要接收的参数。
前端js使用axios提交的话，是这样的：
function post() { var data = { id: 1000, pn:'华为手机' }; axios.post('http://localhost:8080/api/scanRecord?t=1', data).then(function (res) { }).catch(function (error) { }); } 最后，附上前端通过axios post提交multipart/form-data、application/x-www-form-urlencoded数据的示例代码：
//form-data方式 function post() { var data = new FormData(); data.append("id", 1000); data.append("pn", '华为手机'); axios.post('http://localhost:8080/api/scanRecord?t=1', data).then(function (res) { }).catch(function (error) { }); } //x-www-form-urlencoded方式 function encodeData(data) { var args = []; for(var attr in data) { args.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c985ce3e38c78d023058e73edcce9f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c25a34fa12ba45e5db4f7c289e2b44ab/" rel="bookmark">
			处理For security reasons, WebView is not allowed in privileged processes崩溃问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决Android8.0系统应用打开webView报错 解决办法 由于webView存在安全漏洞,谷歌从5.1开始全面禁止系统应用使用webview,使用会导致应用崩溃错误提示:Caused by: java.lang.UnsupportedOperationException: For security reasons, WebView is not allowed in privileged processes异常信息可以看出 是在 WebViewFactory.java 的getProvider 方法 抛出的。源码路径为frameworks/base/core/java/android/webkit/WebViewFactory.java static WebViewFactoryProvider getProvider() { synchronized (sProviderLock) { // For now the main purpose of this function (and the factory abstraction) is to keep // us honest and minimize usage of WebView internals when binding the proxy. if (sProviderInstance != null) return sProviderInstance; //如果sProviderInstance不为空直接返回 //1，判断，如果是系统id ，则抛出异常。 final int uid = android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c25a34fa12ba45e5db4f7c289e2b44ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef398631961bcb7528020a03895d5de8/" rel="bookmark">
			微信支付：商家转账到零钱的开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要所需：1、微信商户平台的证书apiclient_cert.pem 2、微信商户平台证书的密钥apiclient_key.pem 3、微信商户平台的证书的序列号
一、转账所需字段
public class WxTransferAccounts { private String appid;// 小程序ID	private String out_batch_no;// 商家批次订单号 由数字、大小写字母组成[1,32] private String batch_name;// 商家批次名称 示例值：2019年1月深圳分部报销单[1,32]	private String batch_remark;//批次备注 ， [1,32] private int total_num;// 转账总笔数 这个总笔数要等于明细笔数的汇总 private Integer total_amount;// 转账总金额 ,单位为分 这个总金额要等于明细金额的汇总 private List&lt;TransferAccountsArray&gt; transfer_detail_list;//收款方明细 public String getAppid() { return appid; } public void setAppid(String appid) { this.appid = appid; } public String getOut_batch_no() { return out_batch_no; } public void setOut_batch_no(String out_batch_no) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef398631961bcb7528020a03895d5de8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31b5430ad9d4938109af11a5afb6ee38/" rel="bookmark">
			map、odom、base_link坐标系之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总括： map坐标系：地图坐标系，是固定的坐标系；
base_link：机器人本体坐标系，一般和机器人的中心重合，会随着机器人的运动而运动；
odom坐标系：里程计坐标系，不是固定的坐标系，是可以运动的。odom相当于是根据实际计算得到的坐标和真实坐标之间的变换虚拟出来的一个坐标系。
一、前提说明： 首先，我们计算移动机器人走了多远，是根据编码器信息(也就是里程计数据)来获得的。
在起始位置，机器人静止，在map坐标系下实际位置是0；此时里程计数据也是0，所以根据里程计数据计算得到的运动距离是0，计算得到的机器人位置也在0位置。
所以，在起始位置时，map坐标系和odom坐标系是重合的(注意map坐标系是固定的坐标系，odom坐标系是可以运动的坐标系)。
二、举例说明： 为了简单理解，在一维的情况下进行举例讨论。假设机器人在t=0时刻从起点x=0处开始运动，一段时间t时刻后到达某一位置A点(x=7m)；在这段时间内，利用里程计数据计算得到机器人运动了10m(这里只利用里程计数据来计算距离，然后得到现在的位置)，但是实际在地图中，机器人的实际位置是x=7m(A点)。
所以计算的坐标和真实坐标之间出现了偏差。但是在ROS中换了一个说法，不说计算得到的坐标在map坐标系中漂移了3m，而是说是odom坐标系相对于map坐标系漂移了3m。
所以，base_link坐标系相对于map坐标系的真实位置是7m，odom坐标系相对于map坐标系的漂移是 -3m(也就是map坐标系相对于odom坐标系的漂移是 3m)，计算出来的base_link坐标系相对于odom坐标系的距离是10m ，因此 10m= 7m+3m;
当然使用IMU作积分来计算里程计信息，会随着时间的累积，IMU会产生累积误差，和上面的编码器来计算里程计信息产生误差是一样的情况。
所以odom相当于是根据实际计算(odom计算)得到的坐标和真实坐标(amcl估计)之间的变换虚拟出来的一个坐标系。
map坐标系是odom的父坐标系，odom是base_link的父坐标系。尽管直觉会说map坐标系和odom坐标系都应该连接到base_link坐标系，但这是不允许的，因为每个坐标系只能有一个父坐标系。
三、AMCL定位中的坐标系关系： 上图上半部分Odometry Localization，纯粹的里程计定位，它是直接根据里程计信息，来计算出 base_frame 和 odom_frame 之间的偏移，这种情况一般是默认map 坐标系和 odom 坐标系始终是绑在一起的，始终是重合的。所以会有累积误差，随着里程计的增加，它往往会偏差越来越大，越漂越远。
上图的下半部分的AMCL，它是通过对比当前的地图与激光雷达检测到的环境地图，来对自己的位置进行一个修正，这个修改正就体现在 odometry drift，把之前的运算得到的漂移补到 map_frame 和 odom_frame 两个坐标系之间。这就是AMCL的作用(SLAM里面也有map_frame 和 odom_frame 两个坐标系之间 这样的修正)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5fcd85896119f283cdc390bd027edbf/" rel="bookmark">
			logback中 maxHistory 属性无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 描述 logback的滚动策略中配置了 maxHistory 之后，日志目录下依旧存在很多（超出策略时间之外）日志。
环境 IDE： 2021.3 spring boot： 2.5.6 (spring-boot-starter-logging: 2.5.6 --- logback-classic: 1.2.6) logback配置： &lt;rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy"&gt; &lt;FileNamePattern&gt;${LOG_PATH}/error/${LOG_NAME}_error.%d{yyyy-MM-dd}.part_%i.log.zip&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数(maxHistory属性优先级高于totalSizeCap)--&gt; &lt;maxHistory&gt;3&lt;/maxHistory&gt; &lt;!-- 总文件超出大小删除老文件(需要设置maxHistory后生效) --&gt; &lt;totalSizeCap&gt;20KB&lt;/totalSizeCap&gt; &lt;maxFileSize&gt;10KB&lt;/maxFileSize&gt; &lt;!-- appender启动时，进行一次日志文件清理（作用：有些存活很短时间的应用，没机会进行文件清理） --&gt; &lt;cleanHistoryOnStart&gt;true&lt;/cleanHistoryOnStart&gt; &lt;/rollingPolicy&gt; 2. 问题 配置策略，根据时间滚动，保留3天内的日志，如图，依然存在很多以前的日志文件。
原因： 默认第一次只清理32天内的日志内容，之后清理上一次处理之后的。超过时间之前的日志文件，不在清理范围内，所以没被清理。
3. 日志清理流程 1. 获取时间段（当前时间到上一次清理时间）：日志文件清理仅限于此时间范围。 2. 计算周期（时间段内有多少个周期）：如：第一次，按天就是32，按小时就是 32 * 24。 3. 找出每个周期内的日志文件。 4. 删除日志文件。 eg：SizeAndTimeBasedRollingPolicy策略，代码如下 // 文件删除策略：TimeBasedArchiveRemover public void clean(Date now) { long nowInMillis = now.getTime(); // for a live appender periodsElapsed is expected to be 1 // 计算周期 int periodsElapsed = computeElapsedPeriodsSinceLastClean(nowInMillis); lastHeartBeat = nowInMillis; if (periodsElapsed &gt; 1) { addInfo("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5fcd85896119f283cdc390bd027edbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c15083a28997fd9ab725ca43b98df06/" rel="bookmark">
			c#ushort转十六进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义
命名空间:
System
程序集:
System.Runtime.dll
将此实例的数值转换为其等效的字符串表示形式。
重载
ToString(String, IFormatProvider) 使用指定的格式和区域性特定格式信息，将此实例的数值转换为它的等效字符串表示形式。
ToString(String) 使用指定的格式，将此实例的数值转换为它的等效字符串表示形式。
ToString(IFormatProvider) 使用指定的区域性特定格式信息，将此实例的数值转换为它的等效字符串表示形式。
ToString() 将此实例的数值转换为其等效的字符串表示形式。
ToString(String, IFormatProvider)
使用指定的格式和区域性特定格式信息，将此实例的数值转换为它的等效字符串表示形式。
C#
复制
public string ToString (string? format, IFormatProvider? provider);
参数
format
String
标准或自定义的数值格式字符串。
provider
IFormatProvider
一个提供区域性特定的格式设置信息的对象。
返回
String
此实例的值的字符串表示形式，由 format 和 provider 指定。
实现
ToString(String, IFormatProvider)
例外
FormatException
format 无效或不受支持。
2个字节，暂满空间
/strVal = 0x0123/
string strVal = ushVal .ToString(“X4”) ;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8301ce33b29bffc6b7618672f748dddf/" rel="bookmark">
			达梦数据库安装指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		达梦数据库安装步骤（Linux） 安装流程查看系统软硬件信息安装目录的规划安装用户的规划修改安装目录的权限图形化界面安装 安装流程 达梦数据库是一款非常优秀的国产数据库。随着它不断地完善和发展，凭借其优异的性能，使其在政府等诸多应用场景都有着非常出色的表现。因此对达梦数据库的学习便显得尤为关键。其中，达梦数据库的安装，又是发挥其作用的关键一环，但是在安装过程中，有许多需要注意的琐碎问题，因此便写此文.
软件分为企业版、标准版、开发版和安全版本，四个版本在功能丰富性上有些微差别。其中企业版支持集群，标准版不支持集群，开发版和企业版功能相同，只是开发版有使用时间的限制，安全版支持强制访问控制等安全特性。
查看系统软硬件信息 查看cpu的信息，以及cpu的型号，如果是国产服务器，则需要在官网搜索对应的安装包来下载。
[root@localhost~]# lscpu [root@localhost~]# cat /proc/cpuinfo 查看操作系统的版本信息
[root@localhost~]# cat /proc/version 查看GLIBC版本
[root@localhost~]# ldd --version 查看内存信息，至少要留存1G内存空间
[root@localhost~]# free -m 查看硬盘和分区的相关信息
[root@localhost~]# fdisk -l [root@localhost~]# df -h 如果数据库需要远程访问，则要关闭防火墙或开放数据库相应的端口号
[root@localhost~]# systemctl stop firewalld [root@localhost~]# systemctl disable firewalld [root@localhost~]# systemctl status firewalld gcc版本的查看，如果gcc有问题，安装过程中也是会报错。
[root@localhost~]# gcc --version 安装包的挂载，将镜像挂载到mnt目录下
[root@localhost~]# mount -o loop /opt/xxx.iso /mnt 安装目录的规划 这个真的很关键，不仅是对于安装来说，在后续归档、备份等操作也需要规划好目录，这样在后续的操作中就会更加游刃有余。
其中软件的安装路径为: /dm8
[root@localhost~]# mkdir /dm8 安装用户的规划 [root@localhost~]# groupadd dinstall [root@localhost~]# cat /etc/group | grep dinstall //查看用户组是否添加成功 [root@localhost~]# useradd -g dinstall -m -d /home/dmdba -s /bin/bash dmdba [root@localhost~]# passwd dmdba //修改密码 修改安装目录的权限 [root@localhost~]# chown dmdba:dinstall /dm8 [root@localhost~]# ll -ld /dm8 //查看权限是否修改成功 到此环境的查看和配置已经全部完成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8301ce33b29bffc6b7618672f748dddf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d921b68a02759e18ec53c221144fe9/" rel="bookmark">
			问题 B: Counting Characters
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目地址
题目理解提示 输入有多行，一句话可能被分割成多行如何判断一句话是否结束，尤其是一句英文是否结束？ 技巧拓展提示 循环中break和continue的用法自行查阅C++语言大小写转换方法字符之间可以做加减法，可以写程序自己试一试看看相加相减有什么结果整数转换成char字符类型的方式，一般常用 (char)(98+1) 这种将98+1的结果转换成字符类型 解题提示 不一定要用string来输入，用一个char字符就可以了，一直输入到这个char变量中，判断这个变量的值，然后计数计数数组cnt可以开30维(int cnt[30])，有效坑位26个，cnt[0]表示a出现的次数，对于x字符，cnt[x-'a'] ++可以满足对应的计数需求，如果理解不了可以写程序验证一下 ‘b’-'a’输出多少，‘c’-'a’输出多少 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47254c5c4a4a817a800ef90577df33eb/" rel="bookmark">
			我开始使用了Typescript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么使用？
能够更早的发现代码中的错误，因为JavaScript是一门弱类型的编程语言，在运行时检查数据类型，并且允许数据类型转换。JavaScript代码在真正运行前无法检测代码中是否存在错误。有利于提高生产力支持JavaScript的最新特性并且使用了与JavaScript相同的语法和语义 配置本地的Typescript环境，我选的编辑器是vscode。
首先安装Typescript：npm install -g typescript，我选择的是全局安装，方便使用，也可以选择在对应的项目上安装。
检查Typescript版本：tsc --version，如图所示：
创建一个空目录，再切换到该目录下创建tsconfig.json，这个文件是Typescript编译的默认配置文件，其中的属性："strict": true，表示是否启动严格类型检查，
"target": "es2015"，表示输出JavaScript版本指定为ES5，这是官网下载的配置，以后版本更新了，可能会改
{ "compilerOptions": { /* Visit https://aka.ms/tsconfig.json to read more about this file */ /* Projects */ // "incremental": true, /* Enable incremental compilation */ // "composite": true, /* Enable constraints that allow a TypeScript project to be used with project references. */ // "tsBuildInfoFile": "./", /* Specify the folder for .tsbuildinfo incremental compilation files. */ // "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47254c5c4a4a817a800ef90577df33eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0945a20cb85354794f20da193b216f08/" rel="bookmark">
			jar包和war包的介绍和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做Java开发，jar包和war包接触的挺多的，有必要对它们做一个深入的了解，特总结整理如下：
1.jar包的介绍
JAR（Java Archive，Java 归档文件）是与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。JavaSE程序可以打包成Jar包(J其实可以理解为Java了)。
JAR 文件格式以流行的 ZIP 文件格式为基础。与 ZIP 文件不同的是，JAR 文件不仅用于压缩和发布，而且还用于部署和封装库、组件和插件程序，并可被像编译器和 JVM 这样的工具直接使用。在 JAR 中包含特殊的文件，如 manifests 和部署描述符，用来指示工具如何处理特定的 JAR。
简单来说，jar包就是别人已经写好的一些类，然后对这些类进行打包。可以将这些jar包引入到你的项目中，可以直接使用这些jar包中的类和属性，这些jar包一般放在lib目录下。
2.war包的介绍
war是一个可以直接运行的web模块，通常用于网站，打成包部署到容器中。以Tomcat来说，将war包放置在其\webapps\目录下，然后启动Tomcat，这个包就会自动解压，就相当于发布了。
war包是Sun提出的一种web应用程序格式，与jar类似，是很多文件的压缩包。war包中的文件按照一定目录结构来组织。根据其根目录下包含有html和jsp文件，或者包含有这两种文件的目录，另外还有WEB-INF目录。通常在WEB-INF目录下含有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的servlet类和jsp，或者servlet所依赖的其他类（如JavaBean）。通常这些所依赖的类也可以打包成jar包放在WEB-INF下的lib目录下。
简单来说，war包是JavaWeb程序打的包，war包里面包括写的代码编译成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西。
3.区别：（WAR文件代表了一个Web应用程序，JAR是类的归档文件。）
如果一个Web应用程序的目录和文件非常多，那么将这个Web应用程序部署到另一台机器上，就不是很方便了，这时可以将Web应用程序打包成Web 归档（WAR）文件，这个过程和把Java类文件打包成JAR文件的过程类似。利用WAR文件，可以把Servlet类文件和相关的资源集中在一起进行发布。在这个过程中，Web应用程序就不是按照目录层次结构来进行部署了，而是把WAR文件作为部署单元来使用。
一个WAR文件就是一个Web应用程序，建立WAR文件，就是把整个Web应用程序（不包括Web应用程序层次结构的根目录）压缩起来，指定一个.war扩展名。
要注意的是，虽然WAR文件和JAR文件的文件格式是一样的，并且都是使用jar命令来创建，但就其应用来说，WAR文件和JAR文件是有根本区别的。JAR文件的目的是把类和相关的资源封装到压缩的归档文件中，而对于WAR文件来说，一个WAR文件代表了一个Web应用程序，它可以包含 Servlet、HTML页面、Java类、图像文件，以及组成Web应用程序的其他资源，而不仅仅是类的归档文件。
那么什么时候应该使用WAR文件呢？在开发阶段不适合使用WAR文件，因为在开发阶段，经常需要添加或删除Web应用程序的内容，更新 Servlet类文件，而每一次改动后，重新建立WAR文件将是一件浪费时间的事情。在产品发布阶段，使用WAR文件是比较合适的，因为在这个时候，几乎不需要再做什么改动了。
在开发阶段，我们通常将Servlet源文件放到Web应用程序目录的src子目录下，以便和Web资源文件区分。在建立WAR文件时，只需要将src目录从Web应用程序目录中移走，就可以打包了。
4.部署war包到Tomcat
1）. 我这里工作中一般是开发打war包给测试，比如说现在测试拿到一个war包，名字叫test.war。
2）. 打开Tomcat的安装路径 ，假设是“D:\Tomcat\apache-tomcat-7.0.68”，然后进入到 webapps文件夹中，把 test.war放到 webapps文件夹。
3）. 启动Tomcat。
如果不需要更改配置文件：到这一步就可以了。
在浏览器输入“http:localhost:tomcat_port/test即可打开test项目的 index.jsp页面（port是自己的端口号）。如果test项目没有index.jsp页面，那就需要打开其他相应的页面。
如果需要更改配置文件：
4）. 关闭 Tomcat。
5）. 删除 test.war文件（如果在tomcat启动的状态下删去war包，解压好的文件夹也会被一并删除，所以需要在解压后停止tomcat， 然后删掉war包，这时再启动。这时项目文件夹就会被认为不是war解压而来。）。
6）. 由于刚刚启动过Tomcat，Tomcat会自动解压缩test.war为 test文件夹。所以我们在webapps下面可以看到test文件夹。打开test文件夹更改配置文件即可。
7）. 更新完配置之后，启动Tomcat。
8）. 浏览器打开即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f82464721928469c8163d9f34b1039d2/" rel="bookmark">
			ResNet网络加入CBAM注意力机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先定义resnet_cbam.py：如图
import torch import torch.nn as nn import math import torch.utils.model_zoo as model_zoo __all__ = ['ResNet', 'resnet18_cbam', 'resnet34_cbam', 'resnet50_cbam', 'resnet101_cbam', 'resnet152_cbam'] model_urls = { 'resnet18': 'https://download.pytorch.org/models/resnet18-5c106cde.pth', 'resnet34': 'https://download.pytorch.org/models/resnet34-333f7ec4.pth', 'resnet50': 'https://download.pytorch.org/models/resnet50-19c8e357.pth', 'resnet101': 'https://download.pytorch.org/models/resnet101-5d3b4d8f.pth', 'resnet152': 'https://download.pytorch.org/models/resnet152-b121ed2d.pth', } def conv3x3(in_planes, out_planes, stride=1): "3x3 convolution with padding" return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False) class ChannelAttention(nn.Module): def __init__(self, in_planes, ratio=16): super(ChannelAttention, self).__init__() self.avg_pool = nn.AdaptiveAvgPool2d(1) self.max_pool = nn.AdaptiveMaxPool2d(1) self.fc = nn.Sequential(nn.Conv2d(in_planes, in_planes // 16, 1, bias=False), nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f82464721928469c8163d9f34b1039d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d673223f0240d86d45063f68010be8dd/" rel="bookmark">
			动态内存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在编写程序的过程中，为了完成相应的需求，经常需要开辟一些内存来存储数据。例如：
int a = 10;//在栈空间上开辟了4个字节的空间 char b[10] 0= {};//在栈空间上开辟了10个字节连续的空间 除了上述的开辟内存方法，本篇文章介绍几个动态开辟内存的函数。
1.malloc： 参数：size(要开辟空间的大小)，单位是字节。
功能：向内存申请一块连续可用size个字节大小的空间。
返回值：返回一个指向这块空间的指针。
头文件：#include &lt;stdlib.h&gt;
注意：1.如果内存开辟成功，则返回一个指向这块空间的指针。
2.内存开辟失败，返回一个空指针。所以，当使用malloc函数时，它的返回值一定要做检查。
3.返回值的类型是void*,也就是说malloc函数只负责开辟空间，开辟好了以后怎么去使用就该我们自己决定了。
使用：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int* ret = (int*)malloc(5*sizeof(int)); if (ret != NULL) { for (int i = 0; i &lt; 5; i++) { *(ret + i) = 1; } } for (int i = 0; i &lt; 5; i++) { printf("%d ",ret[i]); } return 0; } 这就是malloc函数的简单使用，但是上述的代码是有问题的，当我们使用完这块空间，结束程序的时候，应该进行动态内存的释放和回收。C语言中提供了一个函数free，它是专门完成这项任务的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d673223f0240d86d45063f68010be8dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d53455bdd89d3b59dac68ee80c903ff/" rel="bookmark">
			基于Redis分布式锁（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Redis分布式锁（一） 仅适用于单机版Redis（非集群）
1. Redis 指令 1.1 永久锁 SETNX key value KEY不存在返回1，KEY已经存在返回0
1.2 限时锁 SET key value [EX seconds][PX milliseconds] [NX|XX] EX seconds 设置指定的到期时间(单位：秒)PX milliseconds 设置指定的到期时间(单位：毫秒)NX 仅在键不存在时设置XX 仅在键存在时才设置 1.3 解锁 DEL key 1.4 设置过期时间 # 1.面向剩余时间 # 单位秒 EXPIRE key seconds # 单位毫秒 PEXPIRE key milliseconds # 2.面向时间戳 # 时间戳（秒） EXPIREAT key seconds # 时间戳（毫秒） PEXPIREAT key milliseconds 2. 代码实现 使用RedisTemplate&lt;String, Object&gt;
2.1 基础代码 1、使用SETNX key value 上锁2、使用EXPIRE key seconds 设置锁过期时间3、使用DEL key 解锁 public void redisTest() throws Exception { String key = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d53455bdd89d3b59dac68ee80c903ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2dfafec1904d22f4ea8a3b60d9c092d/" rel="bookmark">
			Vue3加载element依赖步骤以及错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先Vue2如何引入： 1.装依赖 执行npm i element-ui -S报错
原因：npm版本太高了。解决办法：npm i element-ui -S --legacy-peer-deps 2.引入 //引入Vue import Vue from 'vue'; //引入插件 import ElementUI from 'element-ui'; //引入css文件 import 'element-ui/lib/theme-chalk/index.css'; //全局使用插件 Vue.use(ElementUI); 其次Vue3如何引入： 1.装依赖 npm install element-plus --save报错原因：版本太高执行即可：npm install element-plus --save --legacy-peer-deps 2.引入 import { createApp } from 'vue' import App from './App.vue' //引入插件 import ElementPlus from 'element-plus'; //引入css文件 import 'element-plus/theme-chalk/index.css' createApp(App).use(ElementPlus).mount('#app') 扩展：
element有两种引入方式
一：
二：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/202/">«</a>
	<span class="pagination__item pagination__item--current">203/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/204/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>