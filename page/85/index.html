<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61ad822dc863a5435634d2d88c42ca13/" rel="bookmark">
			【IEEE】IEEE刊物（期刊/会议）投稿超详细流程官方讲座（2022讲座笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 IEEE刊物选择与投稿一.IEEE出版渠道（出版物）选择1.刊物相关度考察（寻找相关度高的刊物）2期刊的质量和收稿难度考察（影响因子）刊物举例 3.期刊进一步了解举例- IOT（混合型期刊）举例-OA期刊 4.会议的质量和进一步了解IEEE官方刊物推荐系统5 IEEE官方会议查询 二.期刊投稿流程**三.会议投稿流程**四.期刊会议的审稿流程五.IEEE期刊会议投稿注意事项 IEEE刊物选择与投稿 课程地址：https://workdrive.zohopublic.com.cn/external/aa630499252b5a1558bed7bc1ebf414d45973d3563d344f4ed124fdc5e7ed06b
一.IEEE出版渠道（出版物）选择 1.刊物相关度考察（寻找相关度高的刊物） 直接在平台上根据关键词或者关键领域进行检索，在左侧聚类分析的板块上有一个publication title这样一个栏目，这个栏目上展示了相关领域的研究都发表在什么期刊或者会议上，期刊或者会议的标题会呈现给大家。这些刊物里面出版了大量相关领域的研究就说明它的收稿范围里涵盖这些研究，领域相关度高。（注意，不同刊物的年刊稿量不同）
2期刊的质量和收稿难度考察（影响因子） 学生投稿一般不选择杂志
刊物举例 从作者指南中看刊物收录的内容有哪些
3.期刊进一步了解 选择后进入期刊主页，和投稿相关的信息一般在About Journal中，在这里可以根据影响因子判断期刊质量。
根据aim and scope中看我们的论文是否符合期刊的要求。
publication details 中的information for authors中可以链接到期刊官网的详细投稿须知。
举例- IOT（混合型期刊） 期刊主页通常都是用来展现期刊实力的。
期刊中的特刊专栏征稿信息中也可以查看期刊发布的特刊信息。
特刊往往是一期具备特定主题的正刊，比如疟疾疾病在某国家的流行情况及治疗研究进展。但是由于拥有特定的主题，特刊往往在被SCI数据库收录的时候加上special issue字样。国内目前有些高校并不认可特刊，认为其跟国内的特刊一样，质量非常的低，甚至将特刊同增刊混为一谈，这是大错特错的。正常情况下，特刊和增刊拥有以下4个区别：
在英文当中，特刊的意思是special issue，而增刊的意思是supplementary issue.
特刊是针对某一主题而集中发布的具有相同主题文章的专辑，增刊是在正常版面之外刊登的论文.
特刊有正规版面期卷号是正刊中的一期，增刊没有正式的期卷号以及页码，不是正刊中的一期.
特刊会被SCI数据库全文检索，且检索类型为论著.而增刊通常很少会被检索，且检索类型通常为会议.
注意在费用部分有一个志愿版面费，这个费用是自愿的。超过八页通常会有超长费。
投稿模版在作者中心中都会有。
在有实质性内容扩充的情况下，才可以进行会议转投期刊的操作。
举例-OA期刊 大多数oa刊物，是连续出版的刊物，可以持续收稿。
4.会议的质量和进一步了解 congress / conference是比较大型的会议
IEEE官方刊物推荐系统 https://publication-recommender.ieee.org/home
输入关键词、摘要等信息获得刊物推荐（包括期刊和会议）
期刊-属性、影响因子、平均审稿时常
会议-时间、地点
5 IEEE官方会议查询 32:22s
二.期刊投稿流程** 关键词一定要和文章匹配好，因为分配审稿人的时候会根据关键词进行匹配。
cover letter怎么写呢？是把我们的摘要重新提交一遍吗？
其实它就像是你的研究的推荐信一样的感觉，就是你要通过cover letter来告诉编辑和评审，就是他们为什么要刊登你这篇文章，你要把你研究的特色，亮点以及评审和编辑应该知道的信息去集中地在cover letter中高速给编辑，来方便他们更快速地对你的研究去做一个决策。
其他的还包括有没有资金的支持，有没有什么补充材料：包括多媒体材料、源数据、源代码等等相关的内容。如果你的实验涉及到和人、动物相关的实验，你可能也要把相关的情况进行一个报告等等。
提交完我们的稿件之后，后续我们可以继续在我们的系统里进行查看稿件它处于什么状态，看看目前是在邀请同行评审呢？还是说已经找到了评审，在评审过程中；还是说已经收到了评审意见，在决策等等，大家是可以看到这样一个进程的，
三.会议投稿流程** 对于会议的投稿流程，不同的会议的区别还是计较大的，目前IEEE的会议没有统一的途径来进行投稿，具体大家都是要看相应会议的官网，会有call for papers，不同文章类型的征稿信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61ad822dc863a5435634d2d88c42ca13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11bf6a5cc87db544b39798ca46cb15f8/" rel="bookmark">
			Kubernetes使用OkHttp客户端进行网络负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一次内部Java服务审计中，我们发现一些请求没有在Kubernetes（K8s）网络上正确地实现负载均衡。导致我们深入研究的问题是HTTP 5xx错误率的急剧上升，由于CPU使用率非常高，垃圾收集事件的数量很多以及超时，但这仅发生在一些特定的Pod中。这种情况并不在所有情况下都可见，因为它影响到多Pod服务，源Pod和目标Pod的数量不同。在本博文中，我将讨论我们采取的措施来负载均衡这组服务和Pod。
在我们的部署中，请求在Pod之间是如何均衡的？ 两个源Pod向六个目标Pod发送请求。
可以清楚地看到请求分布在目标Pod之间存在不均衡。
但为什么会这样？ K8s负载均衡器（IPVS代理模式）的默认负载均衡调度程序设置为轮询（round robin）。IPVS提供了更多的选项来均衡流量到Pod后端。在测试这些选项时，我们发现当涉及到我们的服务时，不管配置如何，行为都相同，这些服务之间使用内部路由进行通信。
到底发生了什么？K8s中的IPVS根据连接来平衡流量，这在大多数情况下都表现得相当不错。我们的服务使用OkHttp作为相互通信的HTTP客户端。我们的问题与这个HTTP客户端的行为方式有关。使用默认配置，它会创建到服务器的连接，如果您不想在代码中显式关闭连接，因为这太昂贵，那么它会保持并重新建立到先前合作伙伴的连接。这意味着客户端尝试保持与目标的连接，并通过该特定连接发送请求。通常情况下，它会创建1:1的连接，这在K8s方面没有均衡。
该怎么办？ 如果您需要扩展或希望使您的服务得到适当的负载均衡，您需要在客户端端更新配置。OkHttp提供了ConnectionPool功能。当使用ConnectionPool选项时，连接将在有限的时间段内建立，然后重复设置一个新的连接，因此IPVS可以进行负载均衡，因为它有大量的新连接，应该根据IPVS调度程序路由到目标。基本上，它的工作方式类似于机关枪而不是激光束。
我们在发布此更新后的效果如何？
使用更新的HTTP客户端和默认IPVS调度程序在多Pod服务之间实现了负载均衡的连接
到底做了什么改变？ 我们进行了大量的测试，使用各种配置来测量响应时间和性能开销，以确保负载均衡。下面是主要的代码更改，看起来没有明显的性能开销。
代码更改示例
有一个选项可以设置调度程序，以便能够并行发送更多的请求。在我们的情况下，这最终会建立一组最近关闭的连接，然后继续只使用一个连接。此外，我们试图防止过于频繁地打开新连接，因为执行请求比打开新连接要少要求得多。
结果如何？ 网络和资源的使用现在比以前更加平衡 - 没有巨大或持续很长时间的峰值，也没有出现只影响部署中某些Pod的“嘈杂邻居”效应。现在几乎所有的Pod都以几乎相同的方式被利用，因此我们能够减少我们的部署中的Pod数量。我们知道这并不完美，但对于我们的用例来说已经足够好，因为它不会给服务或IPVS负载均衡器带来明显的性能开销。
现在的Pod上的请求负载均衡
结论 定期进行彻底的服务审计是有益的，因为它可以揭示出未来对所有服务有益的优化点，并在解决那些本应该立即运行的功能的奇怪症状时为您节省时间。此外，花些时间查看文档，测试，讨论并了解在使用客户端库时关于连接设置和处理的默认设置的影响，以确保它们将按照您的预期行事。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a4f4538be4b9c1eff528725825765f/" rel="bookmark">
			Air实现Go程序实时热加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Air介绍 怎样才能在基于gin框架开发时实现实时加载功能呢？像这种烦恼肯定不会只是你一个人的烦恼，所以我报着肯定有现成轮子的心态开始了全网大搜索。果不其然就在Github上找到了一个工具：Air。它支持以下特性：
彩色日志输出自定义构建或二进制命令支持忽略子目录启动后支持监听新目录更好的构建过程 安装Air go get -u github.com/cosmtrek/air go install github.com/cosmtrek/air MacOS curl -fLo air https://git.io/darwin_air Linux curl -fLo air https://git.io/linux_air Windows curl -fLo air.exe https://git.io/windows_air Docker docker run -it --rm \ -w "&lt;PROJECT&gt;" \ -e "air_wd=&lt;PROJECT&gt;" \ -v $(pwd):&lt;PROJECT&gt; \ -p &lt;PORT&gt;:&lt;APP SERVER PORT&gt; \ cosmtrek/air -c &lt;CONF&gt; 然后按照下面的方式在docker中运行你的项目：
docker run -it --rm \ -w "/go/src/github.com/cosmtrek/hub" \ -v $(pwd):/go/src/github.com/cosmtrek/hub \ -p 9090:9090 \ cosmtrek/air 使用Air 首先进入你的项目目录：
cd /path/to/your_project 最简单的用法就是直接执行下面的命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52a4f4538be4b9c1eff528725825765f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd30aa548d9f956e1cde180433a0fc64/" rel="bookmark">
			深度学习笔记之优化算法(八)Adam算法的简单认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习笔记之优化算法——Adam算法的简单认识 引言回顾：基于Nesterov动量的RMSProp算法Adam算法的简单认识一阶矩、二阶矩修正偏差的功能Adam的算法过程描述Adam示例代码 引言 上一节介绍了基于 Nesterov \text{Nesterov} Nesterov动量与 RMSProp \text{RMSProp} RMSProp的融合算法，本节将介绍《深度学习(花书)》 P187 8.5 \text{P187 8.5} P187 8.5自适应学习率算法中的最后一个算法： Adam \text{Adam} Adam算法。
回顾：基于Nesterov动量的RMSProp算法 基于 Nesterov \text{Nesterov} Nesterov动量的 RMSProp \text{RMSProp} RMSProp算法，其特点在于：对梯度大小(学习率)与梯度方向同时优化。其对应的迭代公式表示如下：
关于动量、学习率加权平均方法的差异性描述，详见上一节链接。
{ θ ^ t = θ t − 1 + γ ⋅ m t − 1 G t = ∇ θ ; t − 1 J ( θ ^ t ) R t = β ⋅ R t − 1 + ( 1 − β ) ⋅ G t ⊙ G t m t = γ ⋅ m t − 1 − η R t ⊙ G t θ t = θ t − 1 + m t \begin{cases} \hat \theta_{t} = \theta_{t-1} + \gamma \cdot m_{t-1} \\ \mathcal G_t = \nabla_{\theta;t-1} \mathcal J(\hat \theta_t) \\ \mathcal R_t = \beta \cdot \mathcal R_{t-1} + (1 - \beta) \cdot \mathcal G_t \odot \mathcal G_t \\ \begin{aligned} m_t = \gamma \cdot m_{t-1} - \frac{\eta}{\sqrt{\mathcal R_t}} \odot \mathcal G_t \end{aligned} \\ \theta_t = \theta_{t-1} + m_t \end{cases} ⎩ ⎨ ⎧​θ^t​=θt−1​+γ⋅mt−1​Gt​=∇θ;t−1​J(θ^t​)Rt​=β⋅Rt−1​+(1−β)⋅Gt​⊙Gt​mt​=γ⋅mt−1​−Rt​ ​η​⊙Gt​​θt​=θt−1​+mt​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd30aa548d9f956e1cde180433a0fc64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/405751504767999c2e74ecc526dae2ba/" rel="bookmark">
			【Nginx】Nginx双机热备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、先简单看一下前端2、再看一下后端服务3、Nginx配置负载均衡4、测试尾巴 目前所接触的项目还不涉及到分布式，都是单机模式。不过好在至今没出过什么大问题，基本能满足客户的需求。 由于数据量不是很大，单机的性能已经可以满足，按理不应该做加法，毕竟部署的越复杂，维护起来就越麻烦。
性能虽然可以满足，但有一个不得不提的痛点：项目无法随时更新。
目前的解决方式是：白天改bug、测试，等到晚上客户不使用系统时才停机维护，效率相对较低。
有没有可能让项目可以随时更新？
答案肯定是有，相对简单的解决方案是：双机热备（应用双活） 。
什么是双机热备？
这里引用一下百度百科的解释。
双机热备是应用于服务器的一种解决方案，其构造思想是主机和从机通过TCP/IP网络连接，正常情况下主机处于工作状态，从机处于监视状态，一旦从机发现主机异常，从机将会在很短的时间之内代替主机，完全实现主机的功能。
就是同时部署两套系统，一主一备。主节点负责对外提供服务，备用节点默认不提供服务，只有在主节点出问题的情况下，备用节点才顶替主节点，继续对外提供服务。
大哥不行了，二弟替一会儿。
可以解决什么问题？
利用这个思路，是否可以实现同时部署AB两套系统，当系统需要更新维护时，停用A服务，B服务顶替A工作。待A服务更新完毕后，A服务启动提供升级后的服务，B服务停用再更新。实现应用的热插拔？
答案当然也是可以的。
纸上得来终觉浅，绝知此事要躬行。
本人写了个小demo亲测！
实现思路
搭建项目前先简单理一下思路。
要做的分为以下几步：
1、启动两套简单的Web服务
2、服务内就两个简单的方法
保存值到Session
从Session取值
3、Nginx配置负载均衡，PC01主，PC02备
3、保存Session到PC01服务，然后停用PC01
4、从PC02服务取值，看PC02能否正常工作并访问Session
如果服务可以无缝切换，Session也都正常则表示成功。
项目环境
两套SpringBoot服务（双活）
Redis（实现Session共享）
Nginx（负载均衡-主备模式） （也可使用KeepAlived）
为什么需要Redis？
使用多套系统无法避开的一个问题就是Session，再也不能像以前单机模式下直接从request中getSession了，Session是保存在服务器的，多个服务器之间无法共享Session。关于共享Session有很多实现方案，这里采用的是Redis。
搭建步骤
1、先简单看一下前端 由于只讲环境搭建，所以项目竟可能的简单。
只有两个功能，保存值到Session和从Session中取值。
javascript复制代码const PATH = ‘/backend/’;
//保存到Session function saveSession() { const personName = $('#personName').val(); if (personName.length &lt;= 0) { alert('请输入再保存'); return; } $.ajax({ type:'post', url: PATH+"test/save", async:false, xhrFields: { withCredentials: true }, crossDomain: true, data: { personName:personName }, success: function(json) { $('#screen').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/405751504767999c2e74ecc526dae2ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5d6e7b44d8c03e527d573596ba92758/" rel="bookmark">
			Token认证模式以及JWT介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Token 认证模式 鉴于基于 Session 的会话管理⽅式存在上述多个缺点，基于 Token 的⽆状态会话管理⽅式诞⽣了，所谓⽆状态，就是服务端可以不再存储信息，甚⾄是不再存储 Session ，逻辑如下。 客户端使⽤⽤户名、密码进⾏认证 服务端验证⽤户名、密码正确后⽣成 Token 返回给客户端 客户端保存 Token，访问需要认证的接⼝时在 URL 参数或 HTTP Header 中加⼊ Token 服务端通过解码 Token 进⾏鉴权，返回给客户端需要的数据 基于 Token 的会话管理⽅式有效解决了基于 Session 的会话管理⽅式带来的问题。 服务端不需要存储和⽤户鉴权有关的信息，鉴权信息会被加密到 Token 中，服务端只需要读取 Token 中包含的鉴权信息即可 避免了共享 Session 导致的不易扩展问题 不需要依赖 Cookie，有效避免 Cookie 带来的 CSRF 攻击问题 使⽤ CORS 可以快速解决跨域问题 JWT介绍 JWT 是 JSON Web Token 的缩写，是为了在⽹络应⽤环境间传递声明⽽执⾏的⼀种基于 JSON 的开放标准（ (RFC 7519 ) 。 JWT 本身没有定义任何技术实现，它只是定义了⼀种基于 Token 的会话管理的规则，涵盖 Token 需要包含的标准内容和 Token 的⽣成过程，特别适⽤于分布式站点的单点登录（ SSO） 场景。 ⼀个 JWT Token 就像这样： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5d6e7b44d8c03e527d573596ba92758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ae50fb475bbdec51b1ec29eb4fcb014/" rel="bookmark">
			web ide分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web ide:
github codespaces
replit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81ba4a90d75ffb932c1be6763d829893/" rel="bookmark">
			各省份12.5m地形数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手机整理了全国各省份12.5m的地形数据，ALOS的。
另外也有全国30m的地形数据，可以去我的博客目录找，以及各种模型数据均可在下面链接下载。
传送门：数据共享中心
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee82c36ed6d4528935d6f91d5c657678/" rel="bookmark">
			苹果Mac电脑L2TP连接公司内部网络失败解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		苹果Mac电脑L2TP连接公司内部网络 苹果Mac电脑的L2TP连接公司内部网络失败是一种常见的问题，可能会导致用户无法访问公司内部资源。以下是一些可能的解决方案，可以尝试解决这个问题：
检查网络连接：首先要确保你的Mac电脑已经连接到了可用的网络，可以通过浏览网页等方式进行测试。
确认L2TP VPN配置：在网络设置中，确保已正确配置L2TP VPN连接，包括服务器地址、用户名和密码等。
系统版本：如果您的Mac电脑运行的是较老的系统版本，可能会存在与L2TP VPN连接不兼容的问题。建议升级到最新的系统版本，以获得更好的兼容性和稳定性。
检查防火墙设置：防火墙设置可能会影响L2TP VPN连接。在Mac电脑上，您可以通过“系统偏好设置”中的“安全性与隐私”选项来检查防火墙设置，并确保L2TP VPN连接被允许通过防火墙。
检查路由设置：如果L2TP VPN连接失败，可能是因为路由设置不正确。请检查网络设置中的路由设置，并确保正确配置。
重启L2TP服务：有时候L2TP服务可能会出现问题，导致无法连接。您可以尝试通过重启L2TP服务来解决问题。打开终端应用程序，输入“sudo launchctl stop com.apple.racoon”并按回车键，然后输入“sudo launchctl start com.apple.racoon”并再次按回车键。这将停止和重新启动L2TP服务。
如果以上的解决方案都无法解决问题，建议联系您的IT部门或网络管理员，以获取更进一步的帮助和支持。
我的问题和解决方案 如果有的小伙伴系统更新到13了，建议降低系统版本，本人测试11.4和10.15是可以使用的，猜测是12一下都可以连接。
苹果Mac系统在创建VPN连接时，一直提示：L2TP-VPN服务器没有响应。请尝试重新连接。如果仍然有问题，请验证你的设置并与管理员联系。
在用户认证这里只需要填写密码，把共享密钥留空。
添加好了之后，我们这个时候去连接还是会报错误；我们需要修改系统配置来解决。
打开mac终端输入：
sudo vim /etc/ppp/options 再输入我们mac的开机密码，然后打开文件输入i进入编辑模式输入下面：
plugin L2TP.ppp l2tpnoipsec 输入完成后，按esc退出编辑模式，输入**:wq!** 退出并保存文件。
现在我们再去连接VPN就能连接成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50b039befe154de0cd22b1d63f2e23ff/" rel="bookmark">
			Vue中的router路由的介绍（快速入门）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路由的介绍 文章目录 路由的介绍1、VueRouter的介绍2、VueRouter的使用（5+2）2.1、5个基础步骤(固定)2.2、两个核心步骤 3、组件存放的目录（组件分类） 生活中的路由：设备和ip的映射关系（路由器） Vue中路由：路径和组件的映射关系
1、VueRouter的介绍 作用：修改地址栏路径时，切换显示匹配的组件
说明：Vue官方的一个路由插件，是一个第三方包
官网：https://v3.router.vuejs.org/zh/
2、VueRouter的使用（5+2） 2.1、5个基础步骤(固定) 下载:下载 VueRouter模块到当前工程，版本3.6.5（Vue2对应的版本）
yarn add vue-router@3.6.5 引入
import VueRouter from 'vue-router' 安装注册
Vue.use(vueRouter) 创建路由对象
const router = new VueRouter() 注入，将路由对象注入到new Vue实例中，建立关联
new Vue({ render: h =&gt;h(App),router }).$mount( ' #app ') 注入vueter对象之后：
Vue版本对应关系：
​ Vue2： VueRouter3.x Vuex3.x
​ Vue3： VueRouter4.x Vuex4.x
2.2、两个核心步骤 创建需要的组件(views目录)，配路由规则 准备导航链接，配置路由出口(匹配的组件展示的位置) 3、组件存放的目录（组件分类） vue文件本质无区别。路由相关的组件，为什么放在views目录呢?
组件分类: .vue文件分2类：页面组件&amp;复用组件（更易维护）
src/views文件夹
页面组件–页面展示–配合路由用 src/components文件夹
复用组件–展示数据–常用于复用 文章推荐：Vue路由进阶–VueRouter声明式导航
文章推荐：Vue中对路由的进阶学习
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b568a9ba460a4ab82c674ef0a68b0b8c/" rel="bookmark">
			(视频教程）Complexheatmap做热图之设置不一样的注释效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		热图我们号的热图系列已经写的很完善了，也写过其他的热图，随便在公众号检索关键词”热图“就有很多，这里就不再列举了。要是一般的热图设置什么的网上也是一大堆，我们也没有写的必要。这里要写的这个热图主要是为了解决一个问题，就是关于热图的注释。近期关注我们号的小伙伴应该了解，我们最近出的作图函数基本上都是采用点的注释，而很多文章中的热图也是这种形式，可能是有PS，但是我们还是可以使用函数代码实现，所以这里我们写一下。此外，我们也是通过一个视频教程，讲解一下Complexheatmap热图的做法，其实能够解决90%的问题。
视频链接：
https://www.bilibili.com/video/BV1r94y187yk/?spm_id_from=333.999.0.0&amp;vd_source=05b5479545ba945a8f5d7b2e7160ea34
这里我们的示例数据是单细胞，其他数据也是一样的，我们只不过是利用单细胞数据构建一个作图的矩阵而已，作图使用的是Heatmap函数。首先构建数据：#加载单细胞数据
load("D:/KS项目/公众号文章/单细胞ATAC-scRNA基因气泡图/sce_test.Rdata")library(Seurat)library(dplyr)DefaultAssay(sce) &lt;- "RNA"Idents(sce) &lt;- "celltype"celltype_markers &lt;- FindAllMarkers(sce, only.pos = TRUE, min.pct = 0.5, logfc.threshold = 0.5) top30 = celltype_markers %&gt;% group_by(cluster) %&gt;% top_n(n = 30, wt = avg_log2FC) gene_cell_exp &lt;- AverageExpression(sce, features = top30$gene, group.by = 'celltype', slot = 'data') gene_cell_exp &lt;- as.data.frame(gene_cell_exp$RNA)marker_exp &lt;- t(scale(t(gene_cell_exp),scale = T,center = T)) 构建注释：
library(ComplexHeatmap)length(colnames(gene_cell_exp))ha = HeatmapAnnotation("type" = anno_points(rep(0.5,7), which = "column", pch=c(rep(16,7)), size = unit(7, "mm"), axis=F, gp = gpar(col = dittoColors()[1:7]), border=F, ylim=c(0,1)), show_annotation_name = FALSE) 作图：​​​​​​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b568a9ba460a4ab82c674ef0a68b0b8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e1b98196b006568077c6b87756c3e78/" rel="bookmark">
			jenkins 升级后报错：java.lang.ClassNotFoundException: org.jruby.javasupport.proxy.InternalJavaProxy at jav
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 Jenkins 升级后报错：
java.lang.ClassNotFoundException: org.jruby.javasupport.proxy.InternalJavaProxy at java.base/java.net.URLClassLoader.findClass(URLClassLoader.java:476) at jenkins.util.URLClassLoader2.findClass(URLClassLoader2.java:35) at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:589) at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522) Caused: java.lang.NoClassDefFoundError: org/jruby/javasupport/proxy/InternalJavaProxy at org.jenkinsci.jruby.JRubyMapper.serializedClass(JRubyMapper.java:20) at hudson.util.xstream.MapperDelegate.serializedClass(MapperDelegate.java:41) at com.thoughtworks.xstream.mapper.MapperWrapper.serializedClass(MapperWrapper.java:121) at com.thoughtworks.xstream.core.TreeMarshaller.start(TreeMarshaller.java:82) at com.thoughtworks.xstream.core.AbstractTreeMarshallingStrategy.marshal(AbstractTreeMarshallingStrategy.java:37) at com.thoughtworks.xstream.XStream.marshal(XStream.java:1303) at com.thoughtworks.xstream.XStream.marshal(XStream.java:1292) at com.thoughtworks.xstream.XStream.toXML(XStream.java:1265) at hudson.XmlFile.write(XmlFile.java:213) at jenkins.model.Jenkins.save(Jenkins.java:3590) at jenkins.model.Jenkins.&lt;init&gt;(Jenkins.java:1010) at hudson.model.Hudson.&lt;init&gt;(Hudson.java:86) at hudson.model.Hudson.&lt;init&gt;(Hudson.java:82) at hudson.WebAppMain$3.run(WebAppMain.java:247) Caused: hudson.util.HudsonFailedToLoad at hudson.WebAppMain$3.run(WebAppMain.java:261)
二、原因 三、解决办法 不管是docker Jenkins的容器还是直接搭建的Jenkins
1、进入Jenkins plugins路径
docker Jenkins的容器路径：/var/jenkins_home/plugins
2、直接删除 ruby-runtime 与 ruby-runtime.jpi 这两个文件
rm -r ruby-runtime
rm ruby-runtime.jpi
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b065910f5455763037d048010767efb1/" rel="bookmark">
			基于ChatGPT&#43;词向量/词嵌入实现相似商品推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一个项目有个业务场景是相似商品推荐，给一个商品描述(比如 'WIENER A/B 7IN 5/LB FZN' )，系统给出商品库中最相似的TOP 5种商品，这种单纯的推荐系统用词向量就可以实现，不过，这个项目特点是商品库巨大，有19万余商品，且商品相似度高(都是肉类制品)，所以希望引入ChatGPT，利用大语言模型的推理能力进一步提高推荐准确率。
讨论了一下，决定用向量相似度计算初筛+ChatGPT优选。
处理思路：
1. 词向量相似度计算初筛
a. embedding 如何获取？
直接调用微软Azure Ada Embedding api，质量高，价格低，并且可以直接获取句子embedding。
b. 19万商品embedding如何存储并检索？
使用Redis存储，Redis可以做内存KNN，并有版本对向量计算做了优化(似乎叫STACK)。
c. 商品描述中包含大量缩写，歧义问题严重，直接获取embedding质量很低，如何解决？
使用ChatGPT扩展语义，类似以下prompt: 已知下面是关于一种百货产品的描述，描述中可能包含缩写，请推测是何种品类的商品，给出三种可能:WIENER A/B 7IN 5/LB FZN，并将答案按以下格式输出[答案1:xx，答案2:xx，答案3:xx]
以上prompt喂给ChatGPT，可以得到以下输出:
根据描述，这种百货产品可能是一种冷冻肉制品，下面是三种可能的商品：\n\n1. 热狗：根据描述中出现的\"WIENER\"这个词，可能是指热狗，这是一种由碎肉、淀粉、香料等原料制成的肉制品，通常是热狗面包的主要馅料之一。n2. 香肠：由于描述中出现了7IN和5/LB这两个词，可能是指长度为7英寸，每磅5个的香肠，这是一种由碎肉、淀粉、香料等原料制成的肉制品，通常是早餐的主食之一。\n3. 火腿肠：这是一种由肉类和淀粉等原料制成的肉制品，通常是热狗的替代品，由于描述中没有具体指明该产品的形状，因此这也是一种可能的商品。\n\n[答案1:热狗，答案2:香肠，答案3:火腿肠]
可以看到回答中的语义比原有描述 'WIENER A/B 7IN 5/LB FZN' 清晰了很多，试验下来推荐准确率比直接用原有描述高了很多，但是回答中仍然包含很多“废话”——介词/连词/符号其实都没有什么语义在里面，最后比较下来，直接用三种可能的商品名(比如'[答案1:熏肠，答案2:烤肠，答案3:火腿]')生成embedding来计算相似度是效果最好的。
2.ChatGPT优选
a. 为什么优选？
词向量相似度这种方法，对某个起到决定性作用关键词的判断能力是不足的，比如下面两种商品
'WIENER A/B 7IN 5/LB FZN CS'
'WIENER A/B 7IN 5/LB FZN EA' 毫无疑问，这两个描述的向量相似度是极高的，但这实际不是同种商品，因为他们的销售规格不同，CS是按箱销售，EA是按件销售，如果用户输入的描述中带有CS，必然是希望模糊检索按箱销售的商品。如果让人来检索，肯定是能判断这点的，现在就让ChatGPT来替代人完成这步优选，让GPT从相似度得到的TOP N件商品中，选出5件最靠谱的商品。
我们观察了正确商品在相似度排名结果中的分布情况，大部分在TOP5中，小部份在TOP6 - TOP20中，正确商品分布在TOP20之外的情况并不多，因此，我们将TOP N中的N设定为20。
b. 优选prompt
使用类似如下prompt，ChatGPT会格式化返回将它认为与给定描述最相似的5种商品的id。
It is known that the description of product A is '%s'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b065910f5455763037d048010767efb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3880caf99814f5c6765b848b55ba0c22/" rel="bookmark">
			BUSMASTER使用记录（二）：诊断功能、在线16进制转字符串、脚本编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 五、诊断使用5.1 诊断设置TBox只回复一帧 5.2 发送数据5.3 16进制转字符串推荐工具一推荐工具二 六、脚本 在上一篇（ 点击进入）中主要是记录了下基本收发、报文过滤和报文录制。这一篇重点是诊断功能的使用、测试脚本的编写。 五、诊断使用 5.1 诊断设置 选择Diagnostics -&gt; Settings：
在弹出界面中，进行接口（①）和CAN ID（②、③、④）的设置，周期（⑤）的设置，可以改变Tbox的CAN数据频率，根据需要进行设置即可：
点击下方的OK，完成设置。
TBox只回复一帧 如果TBox解析流控帧，判断了STmin和BlockSize，就需要在BusMaster中进行相应的设置。
5.2 发送数据 选择Diagnostics -&gt; Transmit Window：
在弹出界面中，进行勾选，使得Send Tester Present配置为ON：
点击右上角的x，关闭该界面。
点击Connect，可以在接收界面看到周期收发数据：
该周期为Settings界面⑤处的值保持一致。
5.3 16进制转字符串 在线进行16进制转字符串的工具有非常多，比如（点击进入）：
可以看到带有空格的部分，转换失败。去除空格才能够正常转换。
推荐工具一 点击进入：
推荐工具二 点击进入：
六、脚本 《BusMaster使用说明书》中4.11节点仿真配置一节介绍非常简单，在小破站上找到了一个视频讲解（点击进入），视频中提到两个资源：
UDS仿真库：
2.仿真脚本模板：
github经常上不去，将这两个资源，打包放在CSDN上作为备份：点击下载。 看过视频，才算有了一个基本了解。编写脚本的API可以查看BusMaster内的Help文档：
另外在一篇博文（点击进入）中也提到了，可以将Canoe的脚本CAPL文件转换化为CPP文件，从而在BusMaster中进行测试。不过并没有尝试，先收录下这种方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43f6a29a8f0e85ade5c841a061820315/" rel="bookmark">
			Prometheus规则定义及基于docker简单邮箱钉钉服务发现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
规则文件用于定义Prometheus中的告警规则，即在满足特定条件时生成警报。
记录规则文件用于定义Prometheus中的记录规则，即根据现有的指标数据生成新的时间序列数据
grafana启动
Alertmanager的介绍
告警功能概述
Prometheus监控系统的告警逻辑
启动Alertmanager
启用告警功能：
定义告警发送
在Prometheus上定义告警规则
规则文件用于定义Prometheus中的告警规则，即在满足特定条件时生成警报。 在规则文件中所有的文件都隶属于groups，在groups之下才能定义规则，每个规则都有名字
规则文件： groups: 规则组定义 - name: &lt;string&gt; rules: - name: expr: PromQL - name: expr: - name: &lt;group2&gt; #第二组下的规则 rules: - name: expr: 记录规则文件用于定义Prometheus中的记录规则，即根据现有的指标数据生成新的时间序列数据 定义记录规则，记录规则用record来命名，规则文件用name来命名
记录规则文件： groups: - name: &lt;string&gt; rules: - record: expr: PromQL labels: {} - record: expr: labels: {} grafana启动 docker启动grafana需要配置IP号，也可以下载安装进行配置
[root@rocky8 datasources]#pwd /root/learning-prometheus-master/08-prometheus-components-compose/grafana/grafana/provisioning/datasources [root@rocky8 datasources]#cat all.yml # config file version apiVersion: 1 # list of datasources that should be deleted from the database deleteDatasources: - name: Prometheus orgId: 1 # list of datasources to insert/update depending # whats available in the database datasources: # &lt;string, required&gt; name of the datasource.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43f6a29a8f0e85ade5c841a061820315/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cada8c5813bb9a70e281582c5326e651/" rel="bookmark">
			kubernetes集群一个master两个node证书过期解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.集群表现现象： 1.kubelet无法启动，并报如下错误：
[root@k8s01 ~]# journalctl -u kubelet.service -f -- Logs begin at Tue 2023-10-10 10:07:58 CST. -- Nov 10 15:30:31 k8s01 systemd[1]: Started kubelet: The Kubernetes Node Agent. Nov 10 15:30:31 k8s01 kubelet[25591]: Flag --network-plugin has been deprecated, will be removed along with dockershim. Nov 10 15:30:31 k8s01 kubelet[25591]: Flag --network-plugin has been deprecated, will be removed along with dockershim. Nov 10 15:30:31 k8s01 kubelet[25591]: I1110 15:30:31.153621 25591 server.go:440] "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cada8c5813bb9a70e281582c5326e651/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f8eb803ec9f07502cec41accd967cc/" rel="bookmark">
			【网络安全】网络入侵检测——入侵检测系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		入侵检测系统（IDS）是一种用于检测网络或系统中潜在威胁的设备或软件应用。它可以帮助我们发现未知的攻击，例如零日攻击，或者已知的攻击，例如DDoS攻击。
1.1 IDS的类型 IDS主要有两种类型：基于网络的IDS（NIDS）和基于主机的IDS（HIDS）。
基于网络的IDS（NIDS）：NIDS是在网络级别工作的IDS。它通过监控网络流量来检测威胁。例如，如果NIDS检测到一种已知的攻击模式，例如SYN洪水攻击，它可以生成一个警告。
基于主机的IDS（HIDS）：HIDS是在主机级别工作的IDS。它通过监控系统日志，文件系统变化，或者系统调用来检测威胁。例如，如果HIDS检测到一个文件被修改，而这个文件不应该被修改，它可以生成一个警告。
1.2 IDS的工作原理 IDS主要有两种工作原理：基于签名的检测和基于异常的检测。
基于签名的检测：基于签名的检测是通过比较网络流量或系统行为与已知的攻击签名来检测威胁。例如，如果IDS检测到网络流量中包含一个已知的攻击模式，例如SQL注入，它可以生成一个警告。
基于异常的检测：基于异常的检测是通过比较网络流量或系统行为与正常的模式来检测威胁。例如，如果IDS检测到网络流量中包含一个异常的模式，例如流量突然增加，它可以生成一个警告。
1.3 IDS的示例 一个常见的IDS是Snort。Snort是一个开源的NIDS，它可以用于检测网络中的威胁。以下是一个Snort的示例规则，它可以用于检测SYN洪水攻击：
alert tcp any any -&gt; $HOME_NET 22 (flags: S; msg: "SYN flood attack detected"; threshold: type both, track by_src, count 100, seconds 10; sid:1000001;) 这个规则会在10秒内检测到来自同一源的100个SYN包时，生成一个名为"SYN flood attack detected"的警告。
学习计划安排 我一共划分了六个阶段，但并不是说你得学完全部才能上手工作，对于一些初级岗位，学到第三四个阶段就足矣~
这里我整合并且整理成了一份【282G】的网络安全从零基础入门到进阶资料包，需要的小伙伴可以扫描下方CSDN官方合作二维码免费领取哦，无偿分享！！！
如果你对网络安全入门感兴趣，
那么你需要的话可以点击这里网络安全重磅福利：入门&amp;进阶全套282G学习资源包免费分享！
①网络安全学习路线
②上百份渗透测试电子书
③安全攻防357页笔记
④50份安全攻防面试指南
⑤安全红队渗透工具包
⑥HW护网行动经验总结
⑦100个漏洞实战案例
⑧安全大厂内部视频资源
⑨历年CTF夺旗赛题解析
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b81ba0cab6da5204057597f3b7d2c035/" rel="bookmark">
			ERROR: Could not build wheels for xxx which is required to install pyproject.toml-based projects
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		File "/home/wenniu/anaconda3/envs/nero/lib/python3.8/site-packages/torch/utils/cpp_extension.py", line 1774, in _write_ninja_file_and_compile_objects _run_ninja_build( File "/home/wenniu/anaconda3/envs/nero/lib/python3.8/site-packages/torch/utils/cpp_extension.py", line 2116, in _run_ninja_build raise RuntimeError(message) from e RuntimeError: Error compiling objects for extension [end of output] note: This error originates from a subprocess, and is likely not a problem with pip. ERROR: Failed building wheel for raytracing Running setup.py clean for raytracing Failed to build raytracing ERROR: Could not build wheels for raytracing, which is required to install pyproject.toml-based projects 这个问题是由于cuda版本、nvcc版本、Pytorch版本不一致所导致的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b81ba0cab6da5204057597f3b7d2c035/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13eff70d9a9dc2b0769a70da4cf5d81b/" rel="bookmark">
			基于单片机的电子时钟设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收藏和点赞，您的关注是我创作的动力
文章目录 概要 一、设计目标二、系统电路设计2.1 硬件电路的设计方案 三、 系统软件设计3.1 主程序设计3.2 仿真调试 四、 总结五、 文章目录 概要 电子时钟具有长远的发展历史，它的出现使得人们对时间的概念有了进一步的认知和了解，可以说意义十分的重大。在时代的推动，以及市场的需求下，电子时钟的功能以及性能都有着质的突破，而且应用的范围也越来越广，到处都有着电子时钟的影子。电子时钟和人们的日常生活早已密不可分，同时也起到了重要的引导作用，例如工作、出行、娱乐、饮食等，在很大程度上给人们提供了便捷。本课题所设计的一种多功能电子时钟将51单片机作为一个核心交换器，它外接振荡电路来给单片机提供一个时钟信号，利用LED数码管来实现时钟信息的显示，并且它采用按键的方式，可以对时、分、秒进行单独的调整，从而使之达到一个标准时间，实现定时闹铃。本设计以软、硬件结合为整体的设计思路，并通过软件和硬件控制，充分发挥了单片机的作用。同时，该系统在技术上具有很高的实用价值，由于整个系统在结构和功能上都比较简洁，因此它具备良好的可持续性。
关键词：电子时钟；51单片机；振荡电路；LED数码管；按键模块
一、设计目标 本课题设计主要分为四个部分，其中以AT89C51单片机为核心枢纽，通过其向外部发送时钟信号；以石英振荡器为主要计时部件，通过石英振荡器分频后得到一个稳定的方波信号，从而确保数字电子钟的计时准确以及稳定[2]；以LED灯为核心显示部件，通过输入相应的命令或数据便可显示所需要的时间；以蜂鸣器为主要的定时闹铃部件，当输出的为低电平时，蜂鸣器不发出声音，当输出为高电平时，蜂鸣器发出声音。根据硬件电路设计编写C语言程序并载入到单片机内，完成对外接电路的控制，以此来实现能够显示时、分、秒，并且可以校时和闹铃的电子时钟。
二、系统电路设计 2.1 硬件电路的设计方案 本设计的硬件电路设计框图如图3.1所示：
图3.1 硬件电路框图
本设计的硬件电路主要分为振荡电路、复位电路、按键模块、发声模块和时间显示模块五个部分。振荡电路的主要任务就是不断地给单片机提供周期性的时钟信号；复位电路的作用就是在通电以后是整个电路复位，或者通过按键的形式手动将电路复位；电路通电后，在单片机和动态显示函数的作用下，LED数码管上便会自动的出现时、分、秒的显示；同时，按键的引脚会在扫描函数的作用下，一直处于检测状态，一旦某一个按键被按下，与之对应的函数功能便会总动启用；假如到达了定时设定的时间，蜂鸣器便会发出声音进行提示。
三、 系统软件设计 系统的软件设计非常重要，它主要就是控制着整个硬件电路实现所需的功能，在设计的过程中必须有清晰的思路，如果程序设计的不合理，或是语法错误，使得硬件电路与程序不匹配，这样整个硬件电路就会处于一种瘫痪状态，无法运行。然而需要实现的功能越多，程序的编写也就越繁琐，因此，程序的设计一般要做到以下几点：
（1）根据硬件电路所实现的功能，将软件分为各个部分，设计出合理的框架结构；
（2）根据总体的设计选择适当的参数；
（3）制作出程序流程图；
（4）在程序中添加注释，便于后期阅读和修改程序；
（5）注意程序的抗干扰设计，保证程序在运行中的有效、可靠。
本系统采用C语言程序而成，其结构简单清晰，很容易让人读懂，语句连贯紧密。它聚集了高级语言和汇编语言的多种特点，并且在编写的过程中还能加入其他语言的子程序，由此可以看出，其使用的灵活性是很多语言不可相比的。因其良好的性能，不仅应用于各类系统的拓展和开发，同时还应用于各种科研项目中。
3.1 主程序设计 上电之后，系统便会自动对电路进行初始化操作。单片机依次开始调用按键子程序、显示子程序、中断子程序，随后返回初始化之后，并循环运行。主程序流程图如图4.1所示。
图4.1 主程序流程图
3.2 仿真调试 本设计的仿真调试采用的是Proteus软件，它不但能够实现同类仿真软件的所有功能，而且他还可以对外部电路中的元器件仿真，其内含元器件库十分的丰富，当你在电路布线的过程中出现错误，也可以直接更改，设计使用十分的灵活，这就使得Proteus软件在众多的仿真软件中脱颖而出，尤其适合学生或对单片机感兴趣以及从事与单片机有关工作的人。在Proteus下，将编写好的C语言程序载入到单片机内，随后点击运行，便可进入调试环境，程序无误，此时电路中的各个元器件连接点便会亮起红蓝指示灯（红色代表高电平，蓝色代表低电平），LED数码管亮起，时间显示开始正常的走时。初始运行状态如图5.1所示。
图5.1 初始运行状态
四、 总结 电子时钟具有长远的发展历史，使用单片机控制电子时钟的技术早已成熟，也早已成为主流。本次设计的电子时钟的整体工作主要分为硬件电路和软件系统两部分，首先是选择所需要的元器件，再按照实现的功能将各个元器件整合到一起，完成设计的硬件电路，然后是设计软件系统部分，通过程序控制硬件电路，从而实现时间的显示、校时以及闹铃功能。本设计所需实现的功能，但是功能较为简单，不足之处就是每次开始运行或是初始化电路，都需要对其进行校时，比如每次运行都需要重新进行校时，每次到达闹铃时间蜂鸣器只会响一声，时间较短，提示作用有点不太明显，在实际的生活中使用还是有所欠缺，实用性不强，还需对其进行完善。本次设计给了我一次很好的实践的机会，但也让我看到了自己的不足，虽然在课堂上我们已经学习了很多的理论知识，但要知道理论绝大部分是理想的，实际的使用和操作还是和理论有很大的差别，从被动的接受知识到主动的去学习，再通过实际的操作和应用，让我真真切切的明白了什么叫学以致用，让我对所学的知识有了进一步的认知和了解，也让我知道了理论结合实践的重要性，在今后的工作中仍需不断学习，只有这样才能够不断进步。
五、 文章目录 目 录
摘 要 I
Abstract II
1 绪论 1
1.1 研究背景 1
1.2 电子时钟的特点及应用 1
1.3 设计目标 1
1.4 设计意义 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13eff70d9a9dc2b0769a70da4cf5d81b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b717b03bc8a6266b829675ce54b0830/" rel="bookmark">
			allegro 器件的移动和旋转命令及多器件的整体旋转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		allegro的移动和旋转命令 1.spin旋转命令 在Edit中选在Spin命令，在Find栏中选择Symbols选项，再点击要旋转的器件，也可以框住一些要旋转的器件，移动鼠标就可以旋转器件了。
spin命令只能旋转器件不能移动，移动的话请参考下面move命令
Type：器件旋转的类型
Incremental：增量式，相对的角度 。 Absolute：绝对的角度
Angle：器件旋转的角度
Point: 器件旋转的参考点
sym origin：做封装时的 0，0位置点
boly center：器件的几何中心的位置
user pick：会围绕光标选择的点旋转（多用于整体器件旋转）
sym pin #：器件的管脚上，框中输入1就代表1号管脚
2.Move和rotate的移动和旋转命令 首先点击move移动图标，在find中框选住Symbols选项，然后再点击器件就可以移动器件了，旋转的话需要对器件进行点击鼠标右键选择rotate命令就可以旋转了。
可以设置快捷键更加方便快捷
3.多器件的整体旋转 在我们修改pcb布局时往往是整体移动或者旋转整个模块（多个元器件），我可以使用多器件的旋转，避免对每一个器件操作带来的麻烦。
1.Edit - Move
2.Find中勾选上模块中所用到的种类，这里面包括了器件，过孔，导线
（为了保证旋转效果，可以先删除模块与外部器件连接的导线，让模块孤立出来！）
3.在空白处点击右键选择 Temp Group
4.点击鼠标左键框选住所有器件（无法框选的器件可以左键单击添加，也可以用Ctr鼠标左键点击去掉多余的器件），右键点击 Complete，在Point中选择User pick 选项。
5.先在空白地方点击一下，来选择要旋转的点位置，再右键点击Rotate命令就可以旋转器件了，方框中为整体旋转后的样子。调整位置后重新布线即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e8b9f1a9d5faaa7f848eda1d744d25/" rel="bookmark">
			CTF学习笔记——PWN（入门）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[TOC] CTF学习笔记——PWN（入门）PWN基础概念NC题[HGAME 2023 week1]test_nc 栈溢出[HNCTF 2022 Week1]easyoverflow 伪随机数[SWPUCTF 2022 新生赛]Darling 待补充 CTF学习笔记——PWN（入门） 🚀🚀这篇笔记是我对自己初步学习CTF的一个小总结，主要涉及了PWN板块的入门题型，比如栈溢出等，这部分内容比较简单，算是对PWN形成一个简单的概念，来帮助我们进行后面的学习，本文没有很多基础知识的介绍，主要集中在题目的总结，所以此篇笔记主要起到一个分析总结的作用。
PWN基础概念 🚀🚀CTF中PWN题型通常会直接给定一个已经编译好的二进制程序（Windows下的EXE或者Linux下的ELF文件等），然后参赛选手通过对二进制程序进行逆向分析和调试来找到利用漏洞，并编写利用代码，通过远程代码执行来达到攻击的效果，最终拿到目标机器的shell夺取flag。
🚀🚀所以就需要我们发送一些畸形数据(payload)实现漏洞利用，让二进制程序调用终端（通常是启动sh），这样选手的输入便传递给终端，然后可执行任意命令并返回结果，这里面也就包括我们需要的flag。
🚀🚀接下来我们来介绍一下常见的基础题型：
NC题 🚀🚀NC题其实是最简单的一类题型，但是他却是PWN题不可或缺的一环，当我们攻破了主机之后，就需要去主机里面找flag了：
🚀🚀接下来我们来看一下具体的题目：
[HGAME 2023 week1]test_nc 🚀🚀题目：[HGAME 2023 week1]test_nc | NSSCTF
🚀🚀我们开启环境后只有一个靶机给我们连接，所以我们直接在kali里面输入：
nc node5.anna.nssctf.cn xxxxx 🚀🚀然后我们连接上了主机，可以直接去寻找我们的flag了，无非就是cd 和cat命令到处找，比较简单：
cat flag 🚀🚀发现falg：
NSSCTF{xxx} 栈溢出 🚀🚀栈是PWN很重要的一环，其中包含很多的攻击方法与题型，但是我们在这只介绍最简单的栈溢出题型，这也是后面的基础。
[HNCTF 2022 Week1]easyoverflow 🚀🚀题目：[HNCTF 2022 Week1]easyoverflow | NSSCTF
🚀🚀打开附件得到一个.c文件和一个可执行文件，我们先看一下C语言的代码：
#include&lt;stdio.h&gt; int main() { setbuf(stdin,0); setbuf(stdout,0); setbuf(stderr,0); puts("Input something"); char name[30]; int number=0; gets(name); if(number!=0){ puts("You win."); system("cat flag"); } return 0; } 🚀🚀我们能看到只要number不为0，就会输出我们的flag，而且还有gets函数，所以我们考虑栈溢出，只要把number覆盖掉就好了，所以我们把程序放入IDA（64位）中分析一下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4e8b9f1a9d5faaa7f848eda1d744d25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526c90038e7167ed34582f65a18bcc15/" rel="bookmark">
			论文中的小细节——为什么论文中总是写WX而不是XW？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是最近一个师弟问我的问题，为什么在论文里面总是写的 Y = W X Y=WX Y=WX，而不是 Y = X W Y=XW Y=XW？就算有的时候需要转置 W W W 或者 X X X，都不写 Y = X W Y=XW Y=XW？
这个问题我最开始回答的是这就是约定俗成的写法，因为我也确实没思考过这个问题，我估计大部分的人也没有思考过这个问题，后来我发现这个是个数学问题，而不是约定俗成的写法。
首先，矩阵是没有交换律的，即大部分时候 A B ≠ B A AB\neq BA AB=BA，举个直观的例子：
A = [ 1 2 3 4 ] , B = [ 5 6 7 8 ] \begin{equation} A = \left[ \begin{matrix} 1 &amp; 2 \\ 3 &amp; 4 \end{matrix} \right], B = \left[ \begin{matrix} 5 &amp; 6 \\ 7 &amp; 8 \end{matrix} \right] \end{equation} A=[13​24​],B=[57​68​]​​ A B = [ 19 22 43 50 ] , B A = [ 23 34 31 46 ] \begin{equation} AB = \left[ \begin{matrix} 19 &amp; 22 \\ 43 &amp; 50 \end{matrix} \right], BA = \left[ \begin{matrix} 23 &amp; 34 \\ 31 &amp; 46 \end{matrix} \right] \end{equation} AB=[1943​2250​],BA=[2331​3446​]​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/526c90038e7167ed34582f65a18bcc15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc0839f7c9d0da6d08b62e8b28993c31/" rel="bookmark">
			获取地理相关数据应该知道的方法（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取地理相关数据应该知道的方法和网站（遥感数据） 作为一名地信或相关专业的大学生，那么就不可避免会遇到去哪找数据的问题。想着整理出几篇获取地理相关数据的文章导航，希望能够帮助到部分人。预计将分为以下三部分介绍：遥感数据、矢量数据、面板数据。本次介绍的是遥感数据。
文章目录 获取地理相关数据应该知道的方法和网站（遥感数据）前言高清卫星影像多光谱、高光谱等遥感数据分析产品DEM数据植被数据、水体数据等土地利用数据 其他 前言 遥感数据的分类有很多种，仅有RGB通道的高清卫星影像，多光谱高光谱遥感数据，遥感影像分析的产品等，获取这些数据可以到Google Earth Engine和地理空间数据云上，但是前者的使用具有一定的门槛，后者提供的数据的时效性和全面性相对较差，并且有些数据的产品只有在其发布的官网上方可获取，并配有详细的说明文档。
本文只是介绍一个可获取的渠道，做个汇总，详细的获取步骤可以通过在各大平台上搜索，有诸多的保姆级教程，后续我也会进一步更新具体步骤。
高清卫星影像 这种类型的影像适合用来做区位示意图和选取样本等操作。
这种影像最直接的获取方法就是去Google Earth上获取，下载好桌面软件后，可以在其中绘制矢量，查看历史影像，导入边界等操作，影像的覆盖范围都相对较广。
当然我们国内也有一些软件可以提供类似的影像服务，比如91卫图助手，里面的部分影像是免费的，没办法使用Google Earth的可以尝试，类似的软件还有很多，就不一一列举。
除此之外，也可以在ArcGIS、QGIS等平台上添加在线图源，以此来获取高清的卫星影像。
多光谱、高光谱等 这种数据的是最为常用的用于空间分析的数据。
多光谱的代表就是USGS的Landsat系列和欧空局的Sentinel-2，前者适合长时序分析，后者则提供了更高的分辨率，这两种数据的应用较为广泛，且官网均提供了批量下载的方式；国内的遥感卫星则是以高分系列为代表，但是由于高分数据是近些年才发布，其时序覆盖较差，且网络上针对该数据的处理和应用案例较少，可以将其作为一个补充。
高光谱数据适用于详细的地物识别，矿物提取等诸多用途，目前是没有提供的可供免费下载的渠道，只有部分数据集可供获取或者样例，国内的如资源卫星02d，欧比特卫星等，但是可能需要申请方可获取数据。
遥感数据分析产品 这类数据的获取方式最为广泛，可以通过特定网站、论文、自行生产等方式获取。
DEM数据 DEM数据有很多分辨率，中国区域的目前可供免费使用的完整的最高分辨率的30m分辨率的，如USGS提供的SRTM DEM、欧空局哥白尼网站提供的Copernicus DEM等，这些数据的质量有所差距，可以参考相关研究中的论文使用的是什么数据。
植被数据、水体数据等 可以通过遥感指数自行生成，部分官网也有获取渠道。在小区域的研究中可以通过NDVI和FVC提取区域植被，通过NDWI获取水体数据，也可以使用GLASS FVC数据，GRWL水体数据集等别人已经生成好的数据。
土地利用数据 小区域的土地利用数据可以通过监督分类自行生成，也可以下载CLCD数据、ESA提供的数据、GlobeLand数据，每种数据的分辨率、精度、分类均有所不同。
其他 除了上述所提及的遥感卫星数据之外，遥感数据还有很多种类型，例如Sentinel-1 SAR数据、SPEI数据集等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adf74cead1394f4543ceedf9bd1776c0/" rel="bookmark">
			python之struct详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用处
按照指定格式将Python数据转换为字符串,该字符串为字节流,如网络传输时,不能传输int,此时先将int转化为字节流,然后再发送; 按照指定格式将字节流转换为Python指定的数据类型; 处理二进制数据,如果用struct来处理文件的话,需要用’wb’,’rb’以二进制(字节流)写,读的方式来处理文件; 处理c语言中的结构体; struct模块中的函数
函数 return explain
pack(fmt,v1,v2…) string 按照给定的格式(fmt),把数据转换成字符串(字节流),并将该字符串返回.
pack_into(fmt,buffer,offset,v1,v2…) None 按照给定的格式(fmt),将数据转换成字符串(字节流),并将字节流写入以offset开始的buffer中.(buffer为可写的缓冲区,可用array模块)
unpack(fmt,v1,v2……) tuple 按照给定的格式(fmt)解析字节流,并返回解析结果
pack_from(fmt,buffer,offset) tuple 按照给定的格式(fmt)解析以offset开始的缓冲区,并返回解析结果
calcsize(fmt) size of fmt 计算给定的格式(fmt)占用多少字节的内存，注意对齐方式
格式化字符串
当打包或者解包的时,需要按照特定的方式来打包或者解包.该方式就是格式化字符串,它指定了数据类型,除此之外,还有用于控制字节顺序、大小和对齐方式的特殊字符.
对齐方式
为了同c中的结构体交换数据，还要考虑c或c++编译器使用了字节对齐，通常是以4个字节为单位的32位系统，故而struct根据本地机器字节顺序转换.可以用格式中的第一个字符来改变对齐方式.定义如下
Character Byte order Size Alignment
@(默认) 本机 本机 本机,凑够4字节
= 本机 标准 none,按原字节数
&lt; 小端 标准 none,按原字节数
大端 标准 none,按原字节数
! network(大端) 标准 none,按原字节数
如果不懂大小端,见大小端参考网址.
格式符
格式符 C语言类型 Python类型 Standard size
x pad byte(填充字节) no value c char string of length 1 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adf74cead1394f4543ceedf9bd1776c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cab58c1c13e05fbe3f661d431d8e478/" rel="bookmark">
			Factorial 函数求阶乘的详细代码以及所用知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; //Factorial函数求阶乘 int main()
{
int n,sum;
scanf("%d",&amp;n); //从键盘上获取一个值 sum=factorial(n); //调用函数计算阶乘 if(sum == 1) //判断获取不同值的几种情况 printf("Input data error");
else
printf("%d",sum); }
int factorial(int n)
{
int sum,i;
if(n&gt;0)
return n*factorial(n-1); //通过嵌套调用实现阶乘的计算 if(n==0)
return 1;
else
return -1;
}
以上为调用函数求阶乘的方法
主要涉及知识：
1.scanf，printf函数的使用，
2.嵌套调用的使用，
3.主函数和调用函数的关系
4.“=”和“==”的区别
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e877b0c53c958785f56e3f07e53267/" rel="bookmark">
			Windows 7或10 - 删除进程方法，解决端口占用问题 - 使用 taskkill 命令根据进程 PID 号或者进程名（xxx.exe）删除进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、正常删除进程Windows 命令 —— netstat： 二、taskkill 命令删除进程1、根据进程 PID 号删除进程2、根据进程名（xxx.exe）删除进程 参考链接 一、正常删除进程 Windows 命令 —— netstat： 查看 8080 端口占用的进程 PID 号 netstat -ano|findstr "8080" 类似如下：（笔者这里添加了指定端口号查找，不会查询所有的进程），这里的PID 号，就是最后面的数字，如第一行最后面的数字 284 是一个 PID 号，前面的 135 是一个端口号。
通过 PID 号，删除进程 参考如下：
二、taskkill 命令删除进程 注意：这里 taskkill 命令参数的大小写都是可以的
查看 taskkill 命令的参数有哪些：taskkill /?
/s 服务器名
如果要在远程服务器上终止进程，就需要指定服务器名。如果不指定服务器名，则默认在本地机器上执行任务。
/u [域]用户名 [/p 密码]
如果需要提供用户权限来终止进程，可以使用用户名和密码选项。如果当前用户具有管理员权限，则可以省略这个选项。
/fi 过滤器名称
如果你只想终止符合某些条件的进程，可以使用过滤器名称来筛选进程。可以使用以下命令来查看所有可用的过滤器名称：
/pid 进程ID号
如果你知道要终止的进程的PID，则可以使用此选项来指定进程ID。如果没有指定该选项，则Taskkill将会终止所有符合条件的进程。
/im 图像名称
如果你知道进程的图像名称，比如“notepad.exe”，则可以使用此选项来指定图像名称。如果没有指定该选项，则Taskkill将会终止所有符合条件的进程。
/f
如果希望立即停止进程，而不考虑任何未完成的任务，请使用/f选项。请注意，这可能会导致数据丢失，因此请谨慎使用。
/t
如果需要在终止进程时还需要终止其子进程，请使用/t选项。
1、根据进程 PID 号删除进程 pid：根据进程ID筛选并结束进程。比如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2e877b0c53c958785f56e3f07e53267/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cfaf7e7d40cde493cc7a1b3ec91d6ba/" rel="bookmark">
			maven--镜像和仓库的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文网址：maven--镜像和仓库的用法_-CSDN博客
本文介绍maven镜像和仓库的用法。
加快速度的配置 settings.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cfaf7e7d40cde493cc7a1b3ec91d6ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e88aacbdf642edda470c5c69c66cd65/" rel="bookmark">
			拼多多根据ID获取商品详情--轻松实现海量商品上架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拼多多作为国内最具创新力和用户影响力的电商平台之一，吸引了大量商家和消费者的关注。如果您是一位商家并准备进驻拼多多，那么一定需要强有力的API接口支持，才能快速实现海量商品上架。
众所周知，拼多多有着海量的商品信息和庞大的用户群体。传统的手动上架方式需要耗费大量的人力、物力和时间，还容易出现数据错误和不一致等问题。而通过拼多多API接口，您只需要调用接口，传递数据，即可将商品信息实现快速、准确地上架。
拼多多API接口的优势在于，快速便捷、操作简单、准确性高。商家只需通过开发者平台申请API访问权限，即可轻松接入拼多多，实现商品上架、下架、价格修改、库存同步等操作。同时，拼多多API接口还支持更多细化设置，如商品分类、品牌、规格等信息的自定义配置，让商家更加灵活地操作自己的商品。
总之，拼多多API接口的优势不容小觑，不仅可以提高工作效率，节省时间和成本，还可以实现更精细化的商品管理，提高销售效果和用户体验。如果您还没有接入拼多多API接口的商家，可以试试，让您的商品快速上架，迎接更多商机。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/454983079ed387ce92f00fe9c9f087d2/" rel="bookmark">
			拼多多API接口，打造智能化电商平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着电商行业的发展，拼多多作为新兴电商平台已经成为市场焦点。为了满足商家和用户的需求，拼多多推出了智能化的API接口，实现更加高效、便捷的操作和管理。
拼多多API接口采用先进的人工智能技术和大数据分析算法，可以实现多种场景的自动化处理。商家可以通过API接口实现商品上架、下架、价格调整、订单管理等操作，不再需要手动操作。同时，API接口还能快速获取用户的数据信息，例如用户搜索商品的关键词、购买行为和兴趣偏好等关键信息，帮助商家深入了解用户需求，提高商品销售转化率和用户满意度。
拼多多API接口不仅具有智能化的特点，还具有可扩展性和安全性的优势。商家可以根据自己的需求和业务场景，自定义配置API接口，实现更精细化和个性化的操作。同时，API接口还支持多种安全认证方式，如OAuth2.0、AccessKey等，确保用户数据和商家数据的安全性和保密性。
总之，拼多多API接口的智能化、扩展性和安全性，为商家和用户提供了更加高效、便捷、安全的服务和支持。如果您是一位拼多多商家，不妨尝试接入拼多多API接口，让您的电商运营更加智能化和高效化，获得更多商机和发展机会。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f701965dcf856a54388614866d2e1e/" rel="bookmark">
			使用burpsuite进行布尔盲注(sqli-labs第7关)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.判断注入点
二.爆库名
三.爆表名
四.爆字段
五.爆数据
一.判断注入点 ?id=1'报错 ?id=1"显示正常
判断出参数id是单引号字符串(单引号破坏了原有语法结构)
然后输入id=1'--+时报错，输入id=1')--+发现依然报错，再尝试双括号输入id=1'))--+，发现页面显示正常
成功判断注入点
二.爆库名 先爆出数据库的名长度:(这里用&gt;当然也可以)
(length(str)函数：返回字符串 str的长度)
?id=1')) and length(database())=1--+ 开启拦截,发送给intruder,在"1"这里添加§
设置payloads
开始攻击
一个一个点开看还是麻烦,发现居然可以直接搜?!
6666,直接得出库名长度为8
接下来就可以爆库名了
substr(string, start, length) 第一个参数为要处理的字符串，start为开始位置，length为截取的长度。
?id=1')) and substr(database(),1,1)='a'--+ 注意:攻击方式要选择集束炸弹(clusterbomb),并给"1"和"a"加上§
注意:攻击方式要选择集束炸弹(clusterbomb)
注意:攻击方式要选择集束炸弹(clusterbomb)
有效负载集1的payloads选择0-9!!!!(根据前面已经知道了库名长度,可以把0和9删掉,不过不删也行)
有效负载集2的payloads选择a-z!!!!
攻击之后还是直接搜,选择按payload1排序,直接出库名(security)
三.爆表名 先爆出表的数量(不是很多,没必要爆破)
?id=1')) and (select count(table_name)from information_schema.tables where table_schema=database())=4--+
?id=1')) and (select count(table_name)from information_schema.tables where table_schema=database())=4--+ 爆表名(这个不爆破没办法做)
?id=1')) and substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1)='a'--+
?id=1')) and substr((select table_name from information_schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16f701965dcf856a54388614866d2e1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3924776b5ac8e0413d5c3d98decfcee/" rel="bookmark">
			onnx转换TensorRT的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A. 解析onnx 已有的trt不适配，需要将onnx转为trt
parse onnxserialize trt保存trt文件 注意：如果不使用Int8模式，onnx的parser代码几乎通用
概览 构建阶段
建立logger（日志）建立builder（网络元数据)创建network（计算图）（API独需）生成序列化的网络（网络的trt内部表示） 运行阶段
建立engine（可执行代码）创建context（gpu进程）buffer准备（host+device）拷贝host to device执行推理execute拷贝device to host善后 A.1 构建阶段 1. 创建logger 记录器
getTRTLogger();
2. 创建builder 模型搭建的入口，网络的trt内部表示和引擎都是builder的成员方法生成的
builder.create_optimization_profile()：创建用于dynamic shape输入的配置器
createInferBuilder()
builder.create_network()：创建tensorrt网络对象
createNetworkV2()
在builderconfig下面进行细节设置
另外builder需要创建optimazation profile
在给定输入张量的最小最常见最大尺寸后，将设置的profile传给config
auto profile = builder-&gt;createOptimizationProfile(); profile-&gt;setDimensions(); config-&gt;addOptimizationProfile(profile); 3. 设置builder config 进行设置网络属性
config=builder.create_builder_config()
auto config = std::unique_ptr&lt;nvinfer1::IBuilderConfig, samplesCommon::InferDeleter&gt;(builder-&gt;createBuilderConfig()); 指定构建期可用显存设置标志位开关指定校正器添加用于dynamic shape输入的配置器 config-&gt;addOptimizationProfile(profile);//添加用于dynamic shape输入的配置器 config-&gt;setFlag(); 4. 搭建network 创建network（计算图）是API独需的因为其他两种方法使用parser从onnx导入，不用一层层添加
network=builder.create_network()
在onnx-parser中一旦模型parser解析完成，network就自动填好了，成为了serialized network
onnx-parser解析
createParser(*network, sample::gLogger.getTRTLogger(); ​ parser-&gt;parseFromFile(modelFile.c_str(), static_cast&lt;int&gt;(sample::gLogger.getReportableSeverity())); A.2 运行阶段 runtime 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3924776b5ac8e0413d5c3d98decfcee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f583705c4b3e313b7150b13144f2b42/" rel="bookmark">
			uView自定义图标和普通引入图标（iconfont-阿里巴巴图标库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uView官方自定义图标的添加方法： CustomIcon 扩展自定义图标库 | uView 2.0 - 全面兼容 nvue 的 uni-app 生态框架 - uni-app UI 框架
对比修改步骤： 1、修改图标的前缀 打开项目设置 2、修改"FontClass/Symbol 前缀"项为"custom-icon-"，修改"Font Family"为"custom-icon"，如下图： 3、下载项目至本地 4、引入项目： 4.1、快速引入：框里的四个文件复制到项目中（本案例：根目录下/static/iconfont文件夹下） 修改iconfont.css: 样式.custom-icon适用于普通引入使用iconfont
样式.custom-icon-适用于uView自定义图标使用iconfont
在项目根目录的"App.vue"中，引入上述的"iconfont.css"
@import "@/static/iconfont/iconfont.css";//路径保证正确 页面使用:
//普通使用iconfont &lt;i class="custom-icon custom-icon-company-fill" style="font-size: 30px; color: #888;"&gt;&lt;/i&gt; //uView自定义iconfon &lt;u-icon custom-prefix="custom-icon-company-fill custom-icon" size="30" color="#888"&gt;&lt;/u-icon&gt; 效果图：两种方式效果一样
uview写法原理借鉴：解决uView添加自定义图标不成功_uview 1.0 right-icon-style-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c53fb734509ae2b007863c42b894a82d/" rel="bookmark">
			XCP协议入门-认识XCP协议1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1前言 本文是笔者自己学习XCP协议时，结合所学习视频及查看的资料，进行的总结。
通过本文，你将了解什么是XCP协议，XCP协议的作用、工作过程等知识，将对XCP协议有个基本掌握。
2标定(Calibration)的定义 标定就是通过不断地修改软件控制参数(测量+标定)，使系统达到最佳工作状态。
3XCP协议的概述 XCP协议-Univeral Measurement and Calibration Protocol（通用测量和标定协议），又可以叫做Extended Calibration Protocol（扩展的标定协议），是由ASAM（自动化和测量系统标准化协会）标准化的。它的前身是CCP（Can Calibration Protocol），CAN标定协议，只针对于CAN通信的测量和标定。（理解：C变成了X，扩展了传输层的传输媒介，应用更加广泛）
其中，
ASAM是汽车OEM，供应商和工具生产商的组织。
“C”代表CAN总线，“X”代表任意的传输层（如CAN、CAN FD、FlexRay、Ethernet…）
4XCP协议的应用 用于内部ECU参数的测量和标定，刷新及对ECU进行旁路仿真。
5XCP协议的分类 为了独立于特定的物理传输层，XCP协议被细分为两层，如图5-1所示，一层是协议层（protocol layer），一层是传输层（transport layer），移植的时候重点关注传输层接口。
图5-1
6Xcp协议的工作过程 如图6-1所示，XCP协议是基于主从结构进行通讯，也就是Master-Slave Communication。
图6-1
主机（Master）:位于PC上的软件工具（PC Tool），Canape/Inca.
从机（Slave）:真实ECU/仿真ECU
图6-2
XCP协议是基于ASAM接口模型定义的。如上图6-2所示，显示了主机PC（测量和校准工具）与从机ECU，描述文件的接口以及与更高级别的自动化系统的连接。
1、主机PC（测量和校准工具）和从机ECU之间的连接接口：ASAM MCD-1MC
该接口描述了物理和协议的特定部分，传输的是Xcp Frame。
2、主机PC（测量和校准工具）和.A2L文件之间的连接接口：ASAM MCD-2MC
.A2L文件包含ECU描述信息（定义好的通信参数，测量参数的地址和名字等），主机需要通过.A2L文件掌握ECU的内部信息。后续章节会专门讨论此A2L描述文件。
3、主机PC（测量和校准工具）和更高级别的自动化系统之间的连接接口：ASAM MCD-3MC
该接口在本文档中暂不做说明，此接口用于将另一个更高级别的自动化系统连接到测量和校准工具。
图6-3
XCP协议基于主从通信的原则，如图6-3所示，从机在任何给定时间只能与一个主机通信，而主机可以同时与许多从机进行通信。
关于XCP 报文格式及XCP 数据传输方式将在下一章节认识XCP协议2进行讲述。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d3970d0cd712c02e34dcbc2c9d52a14/" rel="bookmark">
			各类高危漏洞介绍及验证方式教程（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期整理的漏洞验证教程约包含50多类漏洞，分多个章节编写，可从以下链接获取全文：
各类高危漏洞验证方式.docx (访问密码: 1455)
搭建dvwa测试环境基础教程.docx(访问密码: 1455)
web逻辑漏洞挖掘快速入门基础教程.docx (访问密码: 1455)
06 IIS短文件名泄露漏洞 0x0A：漏洞简介
Internet Information Services（IIS，互联网信息服务）是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。Microsoft IIS在实现上存在文件枚举漏洞，攻击者可利用此漏洞枚举网络服务器根目录中的文件。
0x0B：漏洞危害
攻击者可以利用该漏洞猜解后台地址和敏感文件甚至直接下载对应文件，或对IIS服务器中的.Net Framework进行拒绝服务攻击。
0x0C：漏洞验证
打开云监测对应测试URl，如果现实Bad Request（状态码400），则说明漏洞存在（文件并不存在） 如果测试URL并不会显示Bad Request，则说明漏洞不存在。 在存在漏洞的前提下，手工测试如下链接：www.ytnt.zfjy.cn/web*~1*/a.asp，返回状态码404，说明相应文件路径（文件夹）存在。 【PS：】我们也可以使用响应的POC来验证此漏洞。
0x0D：漏洞修复建议
三种修复方案只有第二和第三种能彻底修复该问题,可以联系空间提供商协助修改.
方案1.
修改注册表HKLM\SYSTEM\CurrentControlSet\Control\FileSystem\NtfsDisable8dot3NameCreation的值为1,或者，可以直接点此下载，然后运行,再重启下机器。
(此修改只能禁止NTFS8.3格式文件名创建,已经存在的文件的短文件名无法移除)。该修改不能完全修复,只是禁止创建推荐使用后面的修复建议
方案2.
如果你的web环境不需要asp.net的支持你可以进入Internet 信息服务(IIS)管理器 --- Web 服务扩展 - ASP.NET 选择禁止此功能。（推荐）
方案3.升级net framework 至4.0以上版本.（推荐）
07 JetBrains IDE workspace.xml文件泄露 0x0A：漏洞简介
网站存在JetBrains系列IDE的工作区文件，可以泄露整个工程的目录结构信息。
JetBrains是一家捷克的软件开发公司，该公司最为人所熟知的产品是Java编程语言开发撰写时所用的集成开发环境：IntelliJ IDEA。
相关影响IDE如下如下：* IntelliJ IDEA - 一套智慧型的Java整合开发工具，特别专注与强调程式师的开发撰写效率提升
*PHPStorm 7.0 发布，PHP 集成开发工具
*PyCharm 3发布，智能Python集成开发工具
*RubyMine -RubyMine 是一个为Ruby 和Rails开发者准备的IDE，其带有所有开发者必须的功能，并将之紧密集成于便捷的开发环境中。
*WebStorm8.0 发布，智能HTML/CSS/JS开发工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d3970d0cd712c02e34dcbc2c9d52a14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/248e705756a5e931ca159a96a7b7f4e8/" rel="bookmark">
			再学RocksDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://rocksdb.org.cn/doc/RocksDB-Basics.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d80165224c54a4499ce80838581eca8/" rel="bookmark">
			阿里云学生服务器免费申请流程（2023新版教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2023阿里云学生服务器免费领取，先完成学生认证即可免费领取一台云服务器ECS，配置为2核2G、1M带宽、40G系统盘，在云服务器ECS实例过期之前，完成实验与认证任务，还可以免费续费6个月，阿里云百科来详细说下2023阿里云学生服务器活动、学生机配置、免费时长及学生服务器领取条件：
目录
阿里云学生服务器
阿里云学生服务器 阿里云大学生服务器活动从飞天加速计划2.0升级为飞天加速计划3.0，完成学生身份认证，即可免费领取1台云服务器ECS，免费时长只有1个月，在云服务器过期之前完成实验与认证任务，可以免费续费6个月，一共可以获得7个月的免费服务器使用。
阿里云学生服务器免费领取
先完成学生认证，完成学生身份认证，即可免费领取1台云服务器ECS，免费使用时间为1个月；在云服务器到期之前，完成实验与认证任务，即可在云服务器ECS控制台免费续费6个月，一共可以免费申请7个月的学生服务器。
学生服务器配置：2核2G、1M公网带宽、40G高效云盘，地域可选乌兰察布或河源
活动链接：阿里云飞天加速计划3.0-高校计划
学生条件：中国大陆学信网在籍高校学生包含高职、大专，本科，硕士，博士（不含自考），且年满15岁以上
代金券：在阿里云CLUB中心aliyun.club领取代金券
以下为飞天加速计划3.0活动细则：
一、活动对象： 中国大陆学信网在籍高校学生包含高职、大专，本科，硕士，博士（不含自考），且年满15岁以上 二、用户权益领取基本条件： 1.学生权益领取（下述条件均需满足） ①阿里云注册且个人实名认证用户 完成学生身份认证 2.返场学生用户免费领取权益（下述条件均需满足） ①阿里云注册且个人实名认证用户 完成学生身份认证 ②在2019年--2022年期间参与过“阿里云高校计划免费领取ECS”、“飞天加速计划2.0——高校学生在家实践活动”的用户 三、活动细则 1.学生权益领取： 中国大陆学信网在籍高校学生，需同时完成阿里云个人实名认证、学生身份认证，且两者信息一致，认证通过后，同一用户可免费领取1台云服务器ECS，①固定机型t6 CPU2核，内存2G，②带宽1M，③高效云盘40G，④无数据盘，⑤指定优惠地域（河源，乌兰察布）同一用户只可参与1次，限购1台，购买时长为1个月，购买后不得变更配置。 续费：在领取实例1个月有效期内，完成实验及认证任务即可前往ECS控制台0元续费6个月（完成任务与续费操作均需在实例1个月有效期内），如实例已过1个月有效期，0元续费6个月资格作废且不可恢复，实例配置在续费前不得变更，如用户变更了实例配置如升级带宽、升级磁盘，购买数据盘等操作，则无法0元续费。 退订：用户成功以活动价购买后，如退订，则视为放弃参与活动的资格，不可再次参与本活动。 2.返场学生免费领取 在2019年--2022年期间参与过“阿里云高校计划免费领取ECS”、“飞天加速计划2.0——高校学生在家实践活动”的学生用户，在完成实验及认证后，可新购1台云服务器4个月时长，且实例需满足下述条件，同一用户限领1次。 新购1台云服务器权益要求配置：①固定机型t6 CPU2核，内存2G，②带宽1M，③高效云盘40G，④指定优惠地域（河源，乌兰察布），⑤无数据盘 退订：用户成功以活动价购买后，如退订，则视为放弃参与活动的资格，不可再次参与本活动。 四、名词及解释 1 “阿里云官网”，是指包含域名为 www.aliyun.com的网站以及阿里云客户端，如APP，但阿里云国际站，包括 alibabacloud.com以及所有下属页面和 jp.aliyun.com以及所有下属页面除外。 2.“同一用户”，是指根据不同阿里云账号在注册、登录、使用中的关联信息，阿里云判断其实际为同一用户。关联信息举例：同一证件、同一手机号、同一邮箱等。 3 “同人账号”，是指同一用户拥有多个阿里云账号的，各个账号之间互为同人账号。 4 “指定云产品”，是指某场具体活动列举的云产品（如上文所提ECS）。 5 除非有相反证据证明外，用户参与活动所获得的全部权益和相应责任，均归属于参与活动的该阿里云账号所对应的实名认证主体。 6 阿里云可以根据活动的实际情况对活动规则进行变动或调整，相关变动或调整将公布在活动页面上，并于公布时即时生效；但不影响用户在活动规则调整前已经获得的权益。 7用户参与飞天加速计划3.0所获得的相应权益，仅限本人使用，不得转让、出售或以其他方式换取利益，活动实例不可过户。 8 为保证活动的公平公正，阿里云有权对恶意刷抢（如通过程序等技术手段）活动资源，长期资源闲置 ，利用资源从事违法违规行为的用户收回免费领取ECS使用资格。 9 如用户在活动中存在隐瞒、虚构、作弊、欺诈或通过其他非正常手段规避活动规则、获取不当利益的行为，例如：作弊领取、恶意套现、网络攻击、虚假交易等，阿里云有权收回相关权益、取消用户的活动参与资格，撤销违规交易，必要时追究违规用户的法律责任。 10 活动名称仅为方便用户理解参考使用，不具有效力，实际活动内容以具体活动规则为准。 11、活动页面提到的“*核*G” 中的“核”，均指vcpu； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16d39ba0ef71cdbabcfd4ed219c85035/" rel="bookmark">
			毕业设计——基于spark的电影推荐系统，包括基于ALS、LFM的离线推荐、实时推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MovieRecommendSystem 项目以推荐系统建设领域知名的经过修改过的MovieLens数据集作为依托，以电影网站真实业务数据架构为基础，包含了离线推荐与实时推荐体系，综合利用了协同过滤算法以及基于内容的推荐方法来提供混合推荐。提供了从前端应用、后台服务、算法设计实现、平台部署等多方位的闭环的业务实现 【用户可视化】 ：主 要 负 责实 现 和 用 户 的 交 互 以 及业 务 数 据 的 展 示 ， 主 体采 用AngularJS2进行实现，部署在Apache服务上。 【综合业务服务】：主要实现JavaEE层面整体的业务逻辑，通过Spring进行构建，对接业务需求。部署在Tomcat上。 【数据存储部分】业务数据库：项目采用广泛应用的文档数据库MongDB作为主数据库，主要负责平台业务逻辑数据的存储。 【搜索服务器】：项目爱用ElasticSearch作为模糊检索服务器，通过利用ES强大的匹配查询能力实现基于内容的推荐服务。### 【缓存数据库】：项目采用Redis作为缓存数据库，主要用来支撑实时推荐系统部分对于数据的高速获取需求。 【离线推荐部分】离线统计服务：批处理统计性业务采用Spark Core +Spark SQL进行实现，实现对指标类数据的统计任务。 离线推荐服务：离线推荐业务采用Spark Core +Spark MLlib进行实现，采用ALS算法进行实现。 工作调度服务：对于离线推荐部分需要以一定的时间频率对算法进行调度，采用Azkaban进行任务的调度。 【实时推荐部分】日志采集服务：通过利用Flume-ng对业务平台中用户对于电影的一次评分行为进行采集，实时发送到Kafka集群。 消息缓冲服务：项目采用Kafka作为流式数据的缓存组件，接受来自Flume的数据采集请求。并将数据推送到项目的实时推荐系统部分。 实时推荐服务：项目采用Spark Streaming作为实时推荐系统，通过接收Kafka中缓存的数据，通过设计的推荐算法实现对实时推荐的数据处理，并将结构合并更新到MongoDB数据库 【系统初始化部分】 通过SparkSQL将系统初始化数据加载到MongoDB和ElasticSearch中。 【离线推荐部分】 通过Azkaban实现对于离线统计服务以离线推荐服务的调度，通过设定的运行时间完成对任务的触发执行。离线统计服务从MongoDB中加载数据，将【电影平均评分统计】、【电影评分个数统计】、【最近电影评分个数统计】三个统计算法进行运行实现，并将计算结果回写到MongoDB中；离线推荐服务从MongoDB中加载数据，通过ALS算法分别将【用户推荐结果矩阵】、【影片相似度矩阵】回写到MongoDB中。 【实时推荐部分】 Flume从综合业务服务的运行日志中读取日志更新，并将更新的日志实时推送到Kafka中；Kafka在收到这些日志之后，通过kafkaStream程序对获取的日志信息进行过滤处理，获取用户评分数据流【UID|MID|SCORE|TIMESTAMP】，并发送到另外一个Kafka队列；SparkStreaming监听Kafka队列，实时获取Kafka过滤出来的用户评分数据流，融合存储在Redis中的用户最近评分队列数据，提交给实时推荐算法，完成对用户新的推荐结果计算；计算完成之后，将新的推荐结构和MongDB数据库中的推荐结果进行合并。 【业务系统部分】 推荐结果展示部分，从MongoDB、ElasticSearch中将离线推荐结果、实时推荐结果、内容推荐结果进行混合，综合给出相对应的数据。电影信息查询服务通过对接MongoDB实现对电影信息的查询操作。电影评分部分，获取用户通过UI给出的评分动作，后台服务进行数据库记录后，一方面将数据推动到Redis群中，另一方面，通过预设的日志框架输出到Tomcat中的日志中。项目通过ElasticSearch实现对电影的模糊检索。电影标签部分，项目提供用户对电影打标签服务 项目环境 CentoOS-7.2 JDK-1.8 Spark-2.11.8 Scala-2.11.8 Zookeeper-3.4.10 Kafka-2.11-0.11.0.0 Redis-3.0.4 MongoDB-4.4.1 ElasticEsarch-5.6.2 Flume-1.7.0 IDEA-2020 源码私信获取！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa760c0917a341da362697470ddf6761/" rel="bookmark">
			无线鼠标怎么连接电脑的步骤教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有线鼠标和无线鼠标最大的区别就是，有线鼠标需要接入usb插口才可以使用，而无线鼠标只需要电脑下载驱动就可以使用。相对有限鼠标来说，无线鼠标使用起来比较方便。那么我们该怎么安装无线鼠标呢?今天来看看无线鼠标怎么连接电脑的步骤教程，大家一起来看看吧。
1、首先将电池装进无线鼠标。
2、然后盖上电池的盖子。
3、接着开启无线鼠标的开关。
4、最后将接收器插入电脑的usb接口就可以了。这样操作完成，我们的电脑就成功连接上了无线鼠标了。
以上就是无线鼠标怎么连接电脑的步骤教程啦，希望能帮助到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b5cb027448d95acb5bbd8070f45fcd/" rel="bookmark">
			Ｃ&#43;&#43;：进制转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）二进制转十六进制
string binary = "11010101"; string hex; stringstream ss; ss &lt;&lt; std::hex &lt;&lt; stoi(binary, nullptr, 2); ss &gt;&gt; hex; transform(hex.begin(), hex.end(), hex.begin(), ::toupper); cout &lt;&lt; hex &lt;&lt;endl; (2）十六进制转二进制
string binary = "D5"; bitset&lt;8&gt; bit(stoi(binary, nullptr, 16)); cout &lt;&lt; bit &lt;&lt; endl; 输出：11010101 https://blog.csdn.net/MOU_IT/article/details/89060249
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24328981b283511f4d65ae5accfec67d/" rel="bookmark">
			FTP服务器搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统系列文章 VMware Workstation Player 17 免费下载安装教程
VMware Workstation 17 Pro 免费下载安装教程
windows server 2012安装教程
Ubuntu22.04.3安装教程
FTP服务器搭建
FTP服务器搭建教程 操作系统系列文章前言基本概念介绍一、安装FTP服务二、配置ftp服务三、建立用于访问ftp的用户 前言 各位道友，大家好，我是安全天天学，如下给大家带来FTP服务器搭建教程，如有不足，请指教。
拒绝水文，从我做起
基本概念介绍 文件传输协议是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式。它属于网络传输协议的应用层。文件传送和文件访问之间的区别在于：前者由FTP提供，后者由如NFS等应用系统提供。
FTP是一个8位的客户端-服务器协议，能操作任何类型的文件而不需要进一步处理，就像MIME或Unicode一样。但是，FTP有着极高的延时，这意味着，从开始请求到第一次接收需求数据之间的时间，会非常长；并且不时的必须执行一些冗长的登录进程。
一、安装FTP服务 1、打开服务器管理器
2、点击添加角色和功能
3、开始之前，直接点击下一步
4、安装类型，继续下一步。
5、服务器选择，继续点击下一步。
6、服务器角色，勾选web服务器，点击下一步。
8、功能列表中选择“ISS可承载web核心”，点击下一步。
9、角色服务中勾选红色选框。
10、确认，直接点击安装
11. 等待安装完成。
二、配置ftp服务 7、回到“服务器管理器”，从工具栏选择IIS管理器。
8、在IIS管理器中，右击“网站”，选择“添加FTP站点”。
9、站名随便写，并选择一个物理地址。
10、按图配置，选择无SSL。
11、身份验证和授权信息。
12、一个新的ftp站点就建立好了
三、建立用于访问ftp的用户 13、在“服务器管理器”界面，找到计算机管理
14、如图，新建用户
15、填写相关信息，并点击创建，就会添加到用户列表里。
16、FTP授权规则。
17、如图，更改为只有ftp用户能访问。
18、打开物理路径，并在里面创建一个做测试用的文件或者文件夹。
19、在外部主机或者另一台虚拟机中打开我的电脑，输入ftp://IP
20、输入如上创建的用户名和密码进行登录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ece63e76f20cfc2a6c62723def9ea91/" rel="bookmark">
			Modbus-RTU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Modbus简介： Modbus作用于OSI网络模型中的：物理层、数据链路层、应用层。
Modbus有三类：RTU、ASCII、TCP。默认选项Modbus-RTU。
Modbus有单播和广播两种形式、在广播形式下，所有从站必须执行主站命令而无需应答返回。
单播模式下Modbus主站对特定的从站发送请求后进入等待应答(同步启动超时机制)，此时主站无法处理其他从站的回答。
一、Modbus4个存储区 Modbus根据寄存器不同，分为四种不同的寄存器：
Modbus有两种可读写的寄存器：线圈寄存器(DO)和保持寄存器(AO&amp;设备设置)
Modbus有4个存储区：0，1，3，4，其中，1区，3区只读，0区4区可读可写。分别对应：
区号名称 读写地址范围0输出线圈可读可写布尔量00001-099991输入线圈只读布尔量10001-199993输入寄存器只读寄存器30001-399994保持寄存器可读可写寄存器40001-49999 二、常用功能码 01：读取线圈。读取1~2000个连续线圈，1表示ON，0表示OFF。02：离散量输入04：读输入寄存器，可读取大约1~125的连续输入寄存器，每个连续输入寄存器用两个字节表示05：写单个线圈0F：写多个线圈。可以对线圈序列中的每个线圈设置ON或者OFF。10：写多个寄存器 三、通信报文 Modbus的通信报文由三部分组成：地址域、协议数据单元（PDU）（由功能码和数据组成）、校验码。
地址域：由1个字节构成。也就是两位16进制数字。从站的地址可有127个，其余位用作扩展。保留区可用作特定地址段的广播指令。地址域只跟从站有关，主站没有地址。
协议数据单元PDU：功能码的长度为1字节，而数据的长度不定。
四、PDU通信报文示例 PDU报文示例：主站请求报文：01 00 02 00 06，均为十六进制数字。表示从第3个线圈读取到第9个线圈。从站应答报文：01 01 00（注意返回数据长度为1字节，未使用到的位使用0进行填充）
01读取线圈状态 主站请求报文解析：
01---功能码：读取线圈。00---读取线圈地址高位02---读取线圈地址低位00---读取线圈个数高位06---读取线圈个数低位 从站应答报文解析：
01---功能码01---返回数据长度00---线圈状态 ，线圈状态从右边往左边（从低位开始记录） 0F写多个线圈报文： （改变线圈的ON OFF状态） 主站请求报文：0F 00 02 00 06 01 2A
从站应答报文：0F 00 02 00 06 其中写入值42---对应的二进制值数位00 10 10 10 ，对应线圈序列为8---3（由报文中的起始地址以及写入线圈个数决定）
04读输入寄存器 主机报文：04 00 67 00 04
从机报文：04 08 F5 55 F5 55 18 63 01 1A
主机报文解析：
04---功能码：表示读输入寄存器00与67---表示起始地址：起始地址为00 67，表示十进制的103，从104号寄存器开始读取（因为十六进制从0开始计数，而寄存器编号从1开始）00与04---表示读取的寄存器数量：数量位00 04，表示十进制的4，一共读取4个寄存器 从机报文解析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ece63e76f20cfc2a6c62723def9ea91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21af568942aa000c7d3704a047b6ad4a/" rel="bookmark">
			windows升级完成系统打开文件夹卡顿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开文件夹卡顿解决方案 找到该账户下面的路径删除所有文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5fee05aad6da240126b9aba66657b25/" rel="bookmark">
			v-model指令随记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发项目的时候会使用element-ui的dialog组件，也会自己封装弹出框组件去完成项目需求，但总感觉自己的代码不够优雅，那么我们就根据el-dialog的组件用法去剖析他的实现方式，然后完善自己的自定义弹出框组件
自己写的 &lt;!--components--&gt; &lt;template&gt; &lt;div class="customDialog"&gt; &lt;div class="overlay"&gt;&lt;/div&gt; &lt;div class="close" @click="$emit('hideDialog', false)"&gt;&lt;/div&gt; &lt;div class="dialogContent"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;!--父组件--&gt; &lt;template&gt; &lt;CustomDialog v-if="showDialog" @hideDialog="showDialog = false"&gt;&lt;/CustomDialog&gt; &lt;/template&gt; element-ui &lt;template&gt; &lt;el-dialog v-model="showDialog"&gt;&lt;/el-dialog&gt; &lt;/template&gt; element只用了v-model就实现了开关控制，而自己写的组件还要绑定自定义事件。观察发现问题可能出在v-model这个属性上，那么先去官网找找
// 摘自vue官网 // 自定义事件可以用于开发支持 v-model的自定义表单组件。回忆一下 v-model 在原生元素上的用法： &lt;input v-model="searchText" /&gt; // 上面的代码其实等价于下面这段 (编译器会对 v-model 进行展开)： &lt;input :value="searchText" @input="searchText = $event.target.value" /&gt; 完整demo代码如下
&lt;CustomInput v-model="searchText" /&gt; &lt;!--conponent--&gt; &lt;script&gt; export default { props: ['modelValue'], emits: ['update:modelValue'] } &lt;/script&gt; &lt;template&gt; &lt;input :value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5fee05aad6da240126b9aba66657b25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78812cba9266ff0a5ef438b73c0b360c/" rel="bookmark">
			6.OP-TEE&#43;qemu的启动过程分析--加载bios.bin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过以上章节明了了使用qemu运行OP-TEE需要的相关image的编译过程以及如何启动。本文将开始介绍启动过程中bios.bin的加载过程。
通过调用qemu-system-arm启动qemu的时候，最终会去加载从bios_qemu_tz_arm目录中编译出来的bios.bin文件，bios.bin镜像是由linux kernel image, OP-TEE os image, rootfs image以及bios_qemu_tz_arm目录中的其他.o文件组成。而qemu执行bios.bin镜像的时候的入口函数是reset函数，该函数由汇编代码编写，在bior_qemu_tz_arm/bios/entry.S文件中。该文件主要内容如下：
.section .text.boot //定义 _start函数，设定第一条指令跳转到reset函数执行 FUNC _start , : b	reset b	.	/* Undef */ b	.	/* Syscall */ b	.	/* Prefetch abort */ b	.	/* Data abort */ b	.	/* Reserved */ b	.	/* IRQ */ b	.	/* FIQ */ END_FUNC _start /* * Binary is linked against BIOS_RAM_START, but starts to execute from * address 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78812cba9266ff0a5ef438b73c0b360c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/583613f1667aeaebe0741c7ccbc8c0e1/" rel="bookmark">
			java: 读取D:\develop\software\apache-maven-3.6.1\mvn_repo\com\oracle\ojdbc14\10.2.0.4.0\ojdbc14-10.2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这块有点蒙，我也不知道是哪种方法解决的。。。。。。
但是都是从网上下载一个ojdbc14 的jar包，然后进行下面的操作。
1.
mvn install:install-file -Dfile=/D:/develop/software/apache-maven-3.6.1/lib/ojdbc14.jar -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.1.0 -Dpackaging=jar -DgeneratePom=true
2.
根据地址找到相对应的路径，把路径下面的jar包替换为自己的即可。
ojdbc14jar包下载链接
链接: https://pan.baidu.com/s/1IdsjIxSF2yJuqj5sUJEDUQ 提取码: 5if5 复制这段内容后打开百度网盘手机App，操作更方便哦 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81375ef5960b05c7c8d8e7553e43a0cc/" rel="bookmark">
			opencv-phase 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算梯度强度和方向
梯度的方向与边缘的方向总是垂直的。图像中的边缘可以指向各个方向，通常会取水平（左、右）、垂直（上、下）、对角线（左上、右上、左下、右下）等八个不同的方向计算梯度。
角度的确定：
得到的角度一般不在前边指定的放个方向上，我们需要将角度分类到八个方向中。
假设有四条线，分别是0，45，90，135度线（0度和180重合，是一条线）。需要对通过（2）式求出的θ进行近似，分类到这四条线分成的八个区域中。
比如计算出的θ = 91 ° ，则应将其归类到67.5 ° — 112.5 °的区域，就是垂直向上方向。
八个区域如下图：
x方向的梯度 y方向的梯度 梯度的方向：θ =arctan(-255 / 255) = arctan(-1) = -45°
最后mat的计算结果：
样例
Mat mat1(Size( 4 , 1 ), CV_32FC1), mat2(Size( 4 , 1 ), CV_32FC1), mat3; mat1.at &lt; float &gt; ( 0 , 0 ) = 1 ; mat2.at &lt; float &gt; ( 0 , 0 ) = 1 ; mat1.at &lt; float &gt; ( 0 , 1 ) = 1 ; mat2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81375ef5960b05c7c8d8e7553e43a0cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4c2c3f34c01fe2662a506b8468481ab/" rel="bookmark">
			Eclipse MAT解析headp dump，total size小于file size
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题描述 使用Eclipse MAT分析20GB+的heap dump文件
最后解析出来dump size只有1GB+
2. 原因：heap dump中包含许多unreachable objects Eclipse MAT的官方文档，《Basic Tutorial》章节，有对上图的Overview page做介绍
针对total size小于file size的情况，有专门说明：
If the total size of the dump is much smaller than the size of the file it is possible that the heap dump contained many ‘garbage’ objects which would be discarded at the next garbage collection. See the unreachable objects query to examine these ‘garbage’ objects.
翻译过来就是：
heap dump包含许多垃圾对象，这些对象在下一次GC时可以回收，一般情况下，这些对象对于分析内存泄露来说是不重要的，MAT会在解析heap dump的过程中删除这些对象 MAT对unreachable objects出现原因的分析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4c2c3f34c01fe2662a506b8468481ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24259efae694a3739ff8cf5056708fea/" rel="bookmark">
			mybatis的一些常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
mybatis批量更新数据
mybatis批量插入数据
使用in批量查询或者是批量删除
使用数据库自增id并在程序中获取自增数据的id
mybatis批量更新数据 &lt;update id="upadateData" parameterType="java.util.List"&gt; &lt;foreach collection="dataList" item="item" separator=";"&gt; UPDATE tb_data SET score = #{item.score} WHERE data_id = #{item.dataId} &lt;/foreach&gt; &lt;/update&gt; 使用上面的批量查询，需要在配置文件的数据库连接位置的url中添加下面这个，不然MySQL会认为是你SQL语法错了
&amp;allowMultiQueries=true
url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;useSSL=false&amp;allowMultiQueries=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&amp;nullCatalogMeansCurrent=true 使用这种的好处就是可以【一次网络传输】就把所有的SQL语句提交到数据库了。这样就可以不用频繁的使用MySQL连接资源，但是如果一次性添加过多的SQL语句在里面，就会导致数据库系统卡顿。
也就是说如果是在大量数据的批量更新或者是插入，那么就需要在程序中把数据分为小批量的数据进行批量入库，否则一次性处理太多数据会导致服务器阻塞的。
使用allowMultiQueries（多语句查询）的缺点：容易导致SQL注入风险。
解决方式：
使用mybatis的#{}来传递参数。
限制用户权限，不要使用超级权限的用户在配置文件中去连接数据库。
避免在代码中拼接SQL，特别是对于用户输入的字符串，不要直接在代码中把这个拼接到SQL中。
mybatis批量插入数据 涉及到集合的批量处理，在mapper接口中，需要使用param来进行参数绑定，否则mybatis识别不了集合的参数。
xml标签中的collection元素名称必须与mapper接口中param绑定的参数一致，否则mybatis识别不了。
int batchInsertUser(@Param("userList") List&lt;UserEntity&gt; userList); &lt;insert id="batchInsertUser" parameterType="java.util.List"&gt; INSERT INTO tb_user (name, user_id, age, state, create_time, update_time) VALUES &lt;foreach collection="userList" item="user" separator=","&gt; (#{user.name}, #{user.userId}, #{user.age}, #{user.state}, #{user.createTime}, #{user.updateTime}) &lt;/foreach&gt; &lt;/insert&gt; 注意：如果需要插入的数据很多，那么就需要对数据进行分批处理：在程序中使用代码把数据进行分批，然后再一批一批的进行插入。通过指针和循环实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24259efae694a3739ff8cf5056708fea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/762a8524f32b3fb8d9e743d66f1aa0af/" rel="bookmark">
			EasyExcel基操-导出【行高、列宽、合并、冻结等】导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、依赖二、导出Excel2.1、基本导出内容2.2、简单样式2.3、行高、列宽2.4、列合并2.5、冻结窗口 三、导入Excel表格3.1、导入信息 前言 官网文档：https://easyexcel.opensource.alibaba.com/
优缺点本文不做概述，官网很清楚，本文直接上手代码，操作java代码实现表格的导出（样式调整）、导入等操作
一、依赖 添加maven依赖, 依赖的poi最低版本3.17
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt; 二、导出Excel 2.1、基本导出内容 代码如下（示例）：
package com.easyexcel.easyexcel.service; import com.alibaba.excel.EasyExcel; import com.alibaba.excel.EasyExcelFactory; import com.alibaba.excel.ExcelWriter; import com.alibaba.excel.write.metadata.WriteSheet; import com.alibaba.excel.write.metadata.WriteTable; import com.easyexcel.easyexcel.util.CustomRowHeightStyleStrategy; import com.easyexcel.easyexcel.util.EasyExcelUtils; import com.easyexcel.easyexcel.util.LongestCellWidthHandlerProject; import java.util.ArrayList; import java.util.Arrays; import java.util.List; public class importTemplate { public static void main(String[] args) { //定义需要保存电脑的位置 String path = "E:\\exercise\\Excel\\test.xlsx"; //构建表头内容======================================================================================= //定义简单数据，此处数据，仅使用在表头， String[][] headCol = new String[][]{ {"表头一"}, {"表头二"}, {"表头三"}, }; //定义表头所需数据格式 List&lt;List&lt;String&gt;&gt; headList = new ArrayList&lt;&gt;(); //遍历二位数组，修改格式进行添加 Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/762a8524f32b3fb8d9e743d66f1aa0af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb3abe68fa3223e91d8b9108e1d529e/" rel="bookmark">
			Java代码hello word
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装java环境 开始学习java之前，我们的第一步就是安装java环境，即常说的JDK和JRE，此处就不在详细介绍配置环境过程，可以到网上搜索java开发环境配置。
二、编写第一个程序 工具： 常用的java编写工具有IDE、Notepad++、Sublime、Visual Studio Code等等、前期建议不要使用IDE，用文本工具来编写java程序，手动编译执行，这样得到更好的锻炼，可以不依赖IDE手撕代码，更加有效的学习java语言，待真正完全掌握之后，再使用IDE提高我们的编码效率。
为了方便，以下所有截图为Visual Studio Code页面。
创建helle.java文件
java文件是以 .java 结尾的文件，先创建一个Hello.java文件如下：
1
2
3
4
5
public class Hello{
public static void main(String args[]){
System.out.println("Hello World");
}
}
到这个地方，就创建好了第一个java程序，接下来就是对它的编译执行了。
编译java文件
前提： java环境已经配置
javac: 编译java文件命令，形成Hello.class文件，这就属于字节码文件，即程序编译后的文件；
语法： javac xxx.java
java: 运行java文件
语法： java xxx [xxx为class文件名]
进入java文件所在文件夹，Ctrl+鼠标右键，打开控制面板，选择在此处打开命令窗口或者打开cmd进入java文件所在位置。
执行 javac Hello.java，此时文件夹内会出现一个java.class文件即为java程序编译后的结果。
执行 java Hello ，运行java程序
到此，我们第一个java程序就完成了。下面开始介绍java程序的组成。
java程序的组成 类 所有java程序都有一个最为核心的单元：类，而上述程序使用了一个名为Hello的类。对于类，有以下两种申明方式：
public class 类名称 {}: 文件名称必须与类名称保持一致，*.java文件里只能有一个public class定义
class 类名称 {} : 文件名称可以与类名称不一致，但是生成的*.class是与文件中定义的class名称一致的，在一个*.java中可以定义多个class，但是编译后会分别生成不同的*.class文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdb3abe68fa3223e91d8b9108e1d529e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/84/">«</a>
	<span class="pagination__item pagination__item--current">85/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/86/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>