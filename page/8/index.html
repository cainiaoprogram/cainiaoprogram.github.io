<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/679569658c5775a3ceecb86bd606535e/" rel="bookmark">
			1.10 Unity中的数据存储 XML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、XML
1.介绍
XML是一个文档后缀名是*.xmlXML是一个特殊格式的文档XML是可扩展的标记性语言XML是Extentsible Markup Language的缩 写XML是由万维网联盟(W3C)创建的标记语言，用于定义编码人类和机器可以读取的文档的语法。它通过使用定义文档结构的标签以及如何存储和传输文档来实现这一点。 2.结构
3.生成
4.示例
using UnityEngine; using UnityEngine.UI; using System.Xml; public class DataTest : MonoBehaviour { public Button b1; void Start() { b1.onClick.AddListener(CreateXML); } public void CreateXML() { //创建xml文件 XmlDocument doc = new XmlDocument(); //创建xml头 XmlNode xmlNode = doc.CreateXmlDeclaration("1.0", "utf-8", null); //添加xml头 doc.AppendChild(xmlNode); //创建xml根节点 XmlElement root = doc.CreateElement("users"); //添加xml根节点 doc.AppendChild(root); //通过XmlNode创建根节点的子节点 XmlNode xn_enement = doc.CreateNode(XmlNodeType.Element, "Name", null); XmlNode xn_enement2 = doc.CreateNode(XmlNodeType.Element, "Age", null); //设置子节点的值 xn_enement.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/679569658c5775a3ceecb86bd606535e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/769a78a943e2f447698b35864e5c88a2/" rel="bookmark">
			Unity | HybridCLR 热更新（Windows端）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、准备工作
1.环境相关
2.Unity中配置
二、热更新
1.创建 HotUpdate 热更新模块
2.安装和配置HybridCLR
3.配置PlayerSettings
4.创建热更新相关脚本
5.打包dll
6.测试热更新
三、官方文档
四、补充
1. 调用非静态成员函数
2. 官方示例项目
★ LoadDll流程解释
一、准备工作 1.环境相关 安装git环境。Win下需要安装visual studio 2019或更高版本。安装时至少要包含 使用Unity的游戏开发 和 使用c++的游戏开发 组件。 本文涉及到的Unity版本是2022.3.14f1c1。unity模块必须安装 Windows端：Windows Build Support(IL2CPP)或Mac端：Mac Build Support(IL2CPP)
2.Unity中配置 在unity中创建场景main，并配置好脚本ConsoleToScreen.cs，它可以打印日志到屏幕上，方便定位错误。 using System; using System.Collections; using System.Collections.Generic; using UnityEngine; public class ConsoleToScreen : MonoBehaviour { const int maxLines = 50; const int maxLineLength = 120; private string _logStr = ""; private readonly List&lt;string&gt; _lines = new List&lt;string&gt;(); public int fontSize = 15; void OnEnable() { Application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/769a78a943e2f447698b35864e5c88a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56a66c45bff91ba686cbe7e5b4a6ed76/" rel="bookmark">
			Docker（网络，网络通信，资源控制，数据管理，CPU优化，端口映射，容器互联）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker网络 网络实现原理 Docker 网络是指由 Docker 为应用程序创建的虚拟环境的一部分，它允许应用程序从宿主机操作系统的网络环境中独立出来，形成容器自有的网络设备、IP 协议栈、端口套接字、IP 路由表、防火墙等与网络相关的模块。Docker 的网络功能提供了一种在容器之间进行通信和与外部网络交互的机制。
Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 Container-IP 直接通信。
Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法直接通过 Container-IP 访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即 docker run 创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。
Docker 网络实现原理补充
Docker 网桥（Bridge）:
Docker 网桥是由 Docker 在宿主机上虚拟的网络设备，它充当容器之间通信的桥梁。Docker 网桥通过 Linux 桥接技术实现，创建一个虚拟的以太网桥（docker0），用于连接同一主机上的各个容器。 IP 地址分配：
在容器启动时，Docker 会为每个容器分配一个 IP 地址，这个地址属于 Docker 网桥的子网。这样，容器可以通过 Container-IP 直接进行通信，实现了隔离和网络互联。 端口映射：
外部网络无法直接访问容器的 Container-IP，因此 Docker 提供了端口映射功能。通过使用 -p 或 -P 参数，可以将容器的端口映射到宿主机上的一个端口，使得外部网络可以通过宿主机的 IP 地址和映射的端口访问容器提供的服务。
使用 -p 参数指定映射的宿主机端口，例如 -p 43000:80 表示将容器的 80 端口映射到宿主机的 43000 端口。
使用 -P 参数可以随机映射容器端口到宿主机的一个高端口。
查看容器信息和日志：
使用 docker ps -a 查看容器的详细信息，包括容器的 ID、镜像、启动命令、状态等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56a66c45bff91ba686cbe7e5b4a6ed76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/768a19d767aee520a5627db41ec9a08a/" rel="bookmark">
			对象转成get请求形式 page=1&amp;limit=1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 const data = { page: this.data.page, limit: this.data.limit, } 转换方法： const setQueryConfig = function (item) { let _str = '' for (const o in item) { if (item[o] !== -1) { _str += o + '=' + item[o] + '&amp;' } } _str = _str.substring(0, _str.length - 1) // 末尾是&amp; return _str } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec3c9c8f44a0829bb83ab51f678f964d/" rel="bookmark">
			原型模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要使用原型模式 不用重新初始化对象，而是动态地获得对象运行时的状态。适用于当创建对象的成本较高时，如需进行复杂的数据库操作或复杂计算才能获得初始数据。
优点是可以隐藏对象创建的细节，减少重复的初始化代码；可以在运行时动态地增加和删除产品。
什么是原型模式 原型模式（Prototype），用原型实例指定创建对象的种类，并且通
过复制这些原型创建新的对象
"原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。
组成 Prototype（原型）: 定义一个包含克隆自身的方法的接口。在 Java 中，可以通过实现 Cloneable 接口来达到这个目的。 Concrete Prototype（具体原型）: 实现或继承原型接口，并重写克隆方法。 Client（客户端）: 创建一个新对象，通过复制原型实例来完成。 怎么使用 Java实现原型模式的步骤： 创建原型接口: 在 Java 中，通常使用 Cloneable 接口作为原型。 实现具体的原型类: 创建类，实现 Cloneable 接口。重写 clone() 方法，根据需要进行深拷贝或浅拷贝。 在客户端代码中复制对象: 使用原型实例的 clone() 方法来获取对象的副本。 什么时候使用 一般在初始化的信息不发生变化的情况下，克隆是最好的办法。这既隐藏了对象创建的细节，又对性能是大大的提高，
浅拷贝和深拷贝 浅复制，被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。深复制，把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象 浅拷贝 public class ShallowCopyExample implements Cloneable { private int[] data; public ShallowCopyExample() { data = new int[10]; for (int i = 0; i &lt; data.length; i++) { data[i] = i; } } public void setData(int index, int value) { data[index] = value; } public int[] getData() { return data; } @Override protected Object clone() throws CloneNotSupportedException { return super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec3c9c8f44a0829bb83ab51f678f964d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3972d8fe7fc3c7d89a3ed9bb37d8b472/" rel="bookmark">
			【Node.js学习 day2——预备知识】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Buffer（缓冲器） 1、概念
Buffer是一个类似于数组的对象，用于表示固定长度的字节序列
Buffer本质是一段内存空间，专门用来处理二进制数据
2、特点
Buffer大小规定且无法调整Buffer性能较好，可以直接对计算机内存进行操作每个元素的大小为1字节（byte） 3、使用
创建Buffer（3种方式） //1.alloc let buf = Buffer.alloc(10); console.log(buf) //2.allocUnsafe let buf_2 = Buffer.allocUnsafe(10); console.log(buf_2); //3.from 字符串或其他转换 let buf_3 = Buffer.from('hello'); let buf_4 = Buffer.from([105, 108, 111, 118, 101, 121, 111, 117]); console.log(buf_4); 4、 Buffer操作及注意事项
//buffer与字符串的转换 let buf_4 = Buffer.from([105, 108, 111, 118, 101, 121, 111, 117]); console.log(buf_4.toString());//utf-8 let buf = Buffer.from('hello'); console.log(buf[0].toString(2)); console.log(buf); buf[0]=95; console.log(buf.toString()); //溢出 let buf_1 = Buffer.from('hello'); buf[0] = 361;//舍弃高位的数字 0001 0110 1001 =&gt; 0110 1001 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3972d8fe7fc3c7d89a3ed9bb37d8b472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98a4e6cc4063885d7f7e3cf6d6dba722/" rel="bookmark">
			评测集开放丨中文读唇总动员：CNVSRC 2023 中文连续视觉语音识别挑战赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CNVSRC 2023 (Chinese Continuous Visual Speech Recognition Challenge 2023) 是由 NCMMSC 2023 组委会发起，由清华大学、北京邮电大学、海天瑞声、语音之家联合承办的视觉语音识别竞赛。本次竞赛的核心目的是验证当前视觉语音识别 (或称唇语识别) 技术在大词表连续识别场景下的性能。即日起，CNVSRC 2023 组织者发布全部评测集。参赛队伍可从竞赛官网下载。
视觉语音识别
视觉语音识别，也称唇语识别，是一项通过口唇动作来推断发音内容的技术。该技术在公共安全、助老助残、视频验真等领域具有重要应用。当前，唇语识别的研究方兴未艾，虽然在独立词、短语等识别上取得了长足进展，但在大词表连续识别方面仍面临巨大挑战。特别是对于中文而言，由于缺乏相应的数据资源，该领域的研究进展受到了限制。为此，清华大学在2023年发布了CN-CVS数据集[1]，成为首个大规模的中文视觉语音识别数据库，为进一步推动大词表连续视觉语音识别 (LVCVSR) 提供了可能。
关于CN-CVS数据集的更多信息，可访问数据库官网：
http://cnceleb.org
为推动这一研究方向的发展，清华大学联合北京邮电大学、海天瑞声和语音之家在 NCMMSC 2023 举办中文连续视觉语音识别挑战赛 (CNVSRC, Chinese Continuous Visual Speech Recognition Challenge)。本次赛事以 CN-CVS 中文视觉语音识别数据库为基础数据，评估在录音室朗读 (Reading) 和网络演讲 (Speech) 两类场景下的 LVCVSR 系统的性能。比赛结果将在 NCMMSC 2023 会议上宣布并颁奖。
赛事简介 CNVSRC 2023 共设有两个任务：
T1：特定说话人视觉语音识别 (Single-speaker VSR) T2：多个说话人视觉语音识别 (Multi-speaker VSR)
前者侧重于针对某一特定说话人进行大量数据调优后的性能，后者侧重于系统对非特定说话人的基础性能。每个任务根据训练数据不同，又分为固定赛道 (Fixed Track) 和开放赛道 (Open Track)。
固定赛道仅允许使用 CN-CVS 数据集及各任务发布的开发集作为训练集，旨在验证算法的先进性。开放赛道则可以使用任何数据进行训练，旨在验证当前技术能够达到的性能上限。
CNVSRC 2023 时间安排如下：
09月20日 报名系统开放
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98a4e6cc4063885d7f7e3cf6d6dba722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b73be4fa1ccd0c14cfcdce9b5d606b/" rel="bookmark">
			HarmonyOS应用开发学习笔记 UI布局学习 List(){}创建列表 列表形式显示 简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List 创建列表 列表形式显示
官方文档：创建列表（List）
关键代码
List(){} 列表控件ListItem() {} 子元素 例如
1、简单使用代码 List(){} List() { ListItem() { Row() { Image($r('app.media.iconE')) .width(40) .height(40) .margin(10) Text('小明') .fontSize(20) } } ListItem() { Row() { Image($r('app.media.iconF')) .width(40) .height(40) .margin(10) Text('小红') .fontSize(20) } } } 2、迭代列表内容 ForEach import util from '@ohos.util'; class Contact { key: string = util.generateRandomUUID(true); name: string; icon: Resource; constructor(name: string, icon: Resource) { this.name = name; this.icon = icon; } } @Entry @Component struct SimpleContacts { private contacts = [ new Contact('小明', $r("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37b73be4fa1ccd0c14cfcdce9b5d606b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1bbbe4a41f1e76e8f4feda982515522/" rel="bookmark">
			理解Herbrand Equivalence
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者最近在看GVN的一系列论文，总会看到一个概念叫Herbran Equivalence，依靠这种定义，能够判断一个GVN算法是否是complete的，也即检测一个算法是否是precise的，只有找到所有Herbrand Equivalence关系的算法才能称得上是完全的。
目录 理解：程序表达式之间的等值关系是不可判定的phi结点和普通表达式之间的相等性《一种高效的完全值编号算法》定义的值编号定义Herbrand等值关系定义值编号 算法执行 理解：程序表达式之间的等值关系是不可判定的 由于检测程序表达式间一般的等值关系是不可判定的，大部分 ＧＶＮ 算法都将问题做了简化，通常假设条件语句的结果在编译期间是不确定的，并且对所有的运算符都不考虑其特殊语义，即忽略它们可能满足的特殊运算法则，将不同结构的表达式看作不同的表达式． 满足这些限制条件的表达式间的等值关系被称作 Herbrand 等值关系.能够检测到程序中全部 Herbrand 等值关系的 ＧＶＮ 算法被称为完全 ＧＶＮ 算法.
以上内容摘自《一种高效的完全值编号算法》。
两个程序表达式是否是等值的，这个问题在编译是无法判定，例如表达式a + b 和 a * b，表面看起来二者不是相等的，但是当运行时赋值a = 2, b = 2，此时两个表达式就是相等的。假定条件表达式在编译期不确定，前提是条件表达式的值不能通过静态分析得到，也即phi结点的两个分支执行哪个是不确定的。所有的运算符不考虑特殊语义，结合下文是说不考虑两个不同运算结构之间的等价性。
phi结点和普通表达式之间的相等性 这篇论文中还举了一些算法之所以是不完全的例子——也即他们无法发现phi结点和普通表达式之间的相等性。
以下几个例子实现了论文中的几个例子。
例子1：在input例子中发现两个表达式x和y的相等性，在LLVM 中可以识别到此两个表达式之间的相似性并删除之。贴一个Compiler Explorer的链接。
#include &lt;stdio.h&gt; int input(int a, int b) { int c, d, e, x, y, z; scanf("%d", &amp;d); if(d) { x = a + 1; c = a; } else { x = b + 1; c = b; } y = c + 1; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1bbbe4a41f1e76e8f4feda982515522/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08ee1ec7900a6faffcc27c5a5c2ac61e/" rel="bookmark">
			刚拿的字节跳动offer“打水漂”，TikTok不去了，我该何去何从？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TikTok，作为字节跳动铺棋国际局的头兵，如今竟与华为有了相同遭遇，但似乎并不让人出乎意料。实际上，TikTok出售美国业务给微软，并非是我们想象的躺平跪倒，而是极端不利的形势下，被逼无奈的退让，所以就这一点来说，我也能给予理解。
不过，在给予理解的同时，我更多的是错愕与迷茫，毕竟刚拿不久的offer这下打了水漂，TikTok肯定是去不成了，之后该做出什么样的决定，暂时我还没想清楚。
先介绍一下由来吧，我江苏人，南京某大学学习计算机编程，有UIUC的交换经历。今年找工作拿到了TikTok和Google双offer，后来综合考虑和比较之后，选择了字节跳动美国TikTok事业部。但时不逢春，恰好今年美国疫情影响非常严重，所以入职时间也一推再推。
现在TikTok陷入危机，美国业务卖给微软基本上板上钉钉，这意味着TikTok肯定是去不了，不过还是分享我面试TikTok的面试题吧，毕竟也是字节跳动家的业务，有共通的地方，也能举一反三。
添加图片注释，不超过 140 字（可选）
下面内容有我的TikTok面试题分享，以及我个人之后的计划安排，内容有限，涉及到的“面试题答案和解析”+“简历模板”，
TikTok面试题分享（技术题部分）
hashmap，怎么扩容，怎么处理数据冲突？怎么高效率的实现数据迁移？
Linux的共享内存如何实现，大概说了一下。
Linux 中的用户模式和内核模式是什么含义?
在 Java 中 Lock 接口比 synchronized 块的优势是什么？你需要实现一个高效的缓存，它允 许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？
socket网络编程，说一下TCP的三次握手和四次挥手
同步IO和异步IO的区别？
Java GC机制？GC Roots有哪些？
如何判断一个对象是否存活?(或者 GC 对象的判定方法)
红黑树讲一下，五个特性，插入删除操作,时间复杂度？
快排的时间复杂度，最坏情况呢，最好情况呢，堆排序的时间复杂度呢，建堆的复杂度是多少？
计模式了解哪些？
Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式
什么是元数据？元数据分为哪些类型？包括哪些内容？与 cluster 相关的元数据
AtomicInteger怎么实现原子修改的？
RabbitMQ 上的一个 queue 中存放的 message 是否有数量限制？
ConcurrentHashMap 在Java7和Java8中的区别？为什么Java8并发效率更好？什么情况下用HashMap，什么情况用ConcurrentHashMap？
redis数据结构？
redis数据淘汰机制？
Redis 集群方案应该怎么做？都有哪些方案？
mysql实现事务的原理(MVCC)
MySQL 中控制内存分配的全局参数，有哪些？
Redis 有哪些适合的场景？
有哪些数据库优化方面的经验?MySQL数据主从同步是如何实现的？
MySQL索引的实现，innodb的索引，b+树索引是怎么实现的，为什么用b+树做索引节点，一个节点存了多少数据，怎么规定大小，与磁盘页对应。
如果Redis有1亿个key，使用keys命令是否会影响线上服务？
Redis的持久化方式，aod和rdb，具体怎么实现，追加日志和备份文件，底层实现原理的话知道么?
我的计划即将开展：失去TikTok，将迎来崭新人生？
事发突然，我也没想到到嘴边的鸭子还飞了，所以也确确实实没有一个清晰的目标，也不知道该何去何从，接下来去面哪些公司，我心里还没有盘算出来，但至少目前要准备面试了，所以根据目前的情况来制定了一套计划，希望能够让我面试顺利，斩获offer。
Step1、重新制定简历
更新简历，对于程序员来说应该是家常便饭了，一般程序员大概1年半到2年跳槽一次，每次跳槽都会对简历进行更新，重新包装，实际上在面试前对自己的简历打磨修改是很有必要的，尤其是像我这种需要重新面试，要根据公司“口味”来进行调整。
我自己做简历时，会参照一些模板，这些模板都是十余年经验的大佬总结出来的，可以分享给你们参考参考：
添加图片注释，不超过 140 字（可选）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08ee1ec7900a6faffcc27c5a5c2ac61e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a429b715f8b63cc2a84569ffbcb310a/" rel="bookmark">
			机械硬盘异响问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近把1T机械硬盘接到usb扩展坞的时候, 发现一直有异响, 今天传输大文件的发现传输速率巨低, 猜想是驱动电流太小, 因为扩展坞接了四个设备, 导致硬盘不能全速率读写.
解决方法是扩展坞外接电源(平时因为只接了网卡和键鼠之类的设备, 没考虑过供电问题, 所以电源口一直空着, 用的笔记本usb接口供电), 外接电源后读写速率恢复正常, 异响问题也消失.
(终于可以自定义标签了, 不用再把文章归类到奇奇怪怪的分类中去了)
0.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9babd5d0bab7f5eaf3b3c26f05a1fb78/" rel="bookmark">
			linux复习笔记07（兄弟连）----链接命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建软链接：
创建硬链接：
对比原文件详细信息和软链接详细信息：
我们再来对比原链接和硬链接的详细信息有什么不同：
我们查看一下原文件和硬链接文件内容：
可以看到二者内容相同。
我们现在在原文件末尾添加一行信息：
观察原文件：
再查看硬链接文件:
查看软链接文件：
通过目前，我们好像很难看出来这二者的区别。
现在我们把原文件进行拷贝：
删除原文件：
我们再来看一下硬链接和软链接：
软链接：
软链接相当于windows上的快捷方式。
硬链接：
硬链接依然可以查看。
软链接很好查看出来。
但是如何判断一个文件是普通文件还是硬链接呢？
我们再给issue.bak文件生成一条软链接和一条硬链接：
可以看到硬链接和源文件的i节点相同。所以操作可以同步。
但是实际上，在企业开发中，硬链接的使用是很少的。
硬链接不能跨分区：
相当于不能C盘跨D盘.
软链接可以跨分区。
硬链接不能针对目录使用：
但是软链接是允许的：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34995a4f172a11e4aaad6df56a3be215/" rel="bookmark">
			已跪，Java全能笔记爆火，分布式/开源框架/微服务/性能调优全有
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
程序员，立之根本还是技术，一个程序员的好坏，虽然不能完全用技术强弱来判断，但是技术水平一定是基础，技术差的程序员只能CRUD，技术不深的程序员也成不了架构师。程序员对于技术的掌握，除了从了解-熟悉-熟练-精通的过程以外，还应该从基础出发，到进阶，到源码，到实战。所以，程序员想要成功，首先要成就自己。
今天，这份Java全能笔记终于爆火了，看完之后我直接跪了！这份Java全能笔记内容齐全，包括以下几个方面：
Java筑基（基础）：Tomcat+Mysql+设计模式+并发编程+JVM+Netty
开源框架（SSM框架）：Spring+SpringMVC+Mybatis
微服务架构：Dubbo、SpringBoot、SpringCloud、Docker
分布式：分布式限流+分布式缓存+分布式通讯（限流：Nignx+Zookeeper/缓存：Redis+MongoDB+Memcached/通讯：RabbitMQ+RocketMQ+Kafka）
性能优化：Mysql优化+Java性能调优+JVM调优+Tomcat调优
这几个方面究竟需要掌握多少？见下文揭晓吧。不过文章篇幅有限，不能全部描述出来
添加图片注释，不超过 140 字（可选）
一、Java筑基（基础）
1.Tomcat
添加图片注释，不超过 140 字（可选）
2.Mysql
MySQL体系结构和存储引擎
InnoDB存储引擎
索引与算法
锁
事务
性能调优
添加图片注释，不超过 140 字（可选）
3.设计模式
24种设计模式与6大设计原则
添加图片注释，不超过 140 字（可选）
添加图片注释，不超过 140 字（可选）
4.并发编程
Java线程
线程池
生命周期
阻塞队列
CAS
AQS
添加图片注释，不超过 140 字（可选）
5.JVM
线程
JVM内存区域
JVM运行时内存
垃圾回收与算法
GC
IO/NIO
类加载机制
添加图片注释，不超过 140 字（可选）
6.Netty
Netty原理
Netty高性能
NettyRPC实现
RMI实现方式
Protoclol Buffer
Thrift
添加图片注释，不超过 140 字（可选）
二、开源框架（SSM框架）
1.Spring
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34995a4f172a11e4aaad6df56a3be215/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a94a394cc6b6648553e108fee1c72bca/" rel="bookmark">
			202312 青少年软件编程（C/C&#43;&#43;）等级考试试卷（三级）电子学会真题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		202312 青少年软件编程（C/C++）等级考试试卷（三级）电子学会真题
1.因子问题
题目描述
任给两个正整数N、M，求一个最小的正整数a，使得a和(M-a)都是N的因子。
输入
包括两个整数N、M。N不超过1,000,000。
输出
输出一个整数a，表示结果。如果某个案例中满足条件的正整数不存在，则在对应行输出-1
样例输入
35 10
样例输出
5
2.Minecraft
题目描述
Minecraft是一个几乎无所不能的沙盒游戏，玩家可以利用游戏内的各种资源进行创造，搭建自己的世界。
在Minecraft中，基本的建筑元素是边长为1个单位的立方体，Tony想用N个这种小立方体搭建一个长方体，并用他珍藏已久的贴纸对其进行装饰。如果一张贴纸可以贴满小立方体的一个面。那么，他需要用掉多少张贴纸呢？
输入
一个整数N，表示小明所拥有的小立方体的个数。N不会超过1000。
输出
一个整数，即小明最少用掉的贴纸有多少张。
样例输入
9
样例输出
30
答案和更多内容请查看网站：【试卷中心 -- C/C++ 三级】
网站链接 青少年软件编程历年真题模拟题实时更新
================================================
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c87dff3212c8449aeaa3c83330be49/" rel="bookmark">
			菜鸟程序员，被无良HR欺骗，因祸得福，竟“意外”拿下美团offer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前因后果
先讲述一下自己这次被无良HR欺骗坑惨的经历吧，面试的是一家上海某电商公司，给的薪资是不错。面试的时候，找我要了工资流水，然后给了我口头offer，就让我回去等了邮件了。回去之后就觉得offer没啥问题，稳稳当当了，就没再去面其他的公司，打起了游戏。结果等了两个礼拜也没等来邮件，问HR告诉我在走流程，我问是不是不要我，HR说要，让我继续等。
再过了几天我再去问，HR就怎么都不回我了，这个时候我才反应过来“坏了”。好在后来我马上开始面试其他的公司，阴差阳错拿到了美团的offer，这也算是因祸得福了。
再后来，那家电商公司的HR又通知我去入职，我猜当时应该是有两个候选人，然后选了另一个，把我给吊着了，最后那个人鸽了他们，才又想起了我，我只能说这样的HR真的没有一点职业道德和修养，然后立马拉黑她了，好在我结局是好的，也不跟她做过多的计较。
下文内容就正式开展我这次美团的面经分享，之后还有个人的一些面试建议以及资料分享给大家，需要我个人珍藏的300G的pdf资料的朋友
添加图片注释，不超过 140 字（可选）
美团面经（4轮面试，一波三折）
美团第一面：轻松
自我介绍、过往工作经历
说之前的项目（关于并发量）
介绍一下项目流程，介绍一下系统框架是怎么设计的？用到哪些技术？遇到过哪些问题？是怎样去解决的？
如何承载高并发？
RocketMq的运行模型
zookeeper是如何保证一致性的，协议叫什么？
乐观锁和悲观锁，应用场景有哪些？
什么情况下会发生死锁，怎么处理死锁？
hashMap的原理，由此延伸问红黑树是什么，hash冲突怎么解决？
排序算法记得多少？
写代码：两个stack实现一个queue
美团第二面：紧张
自我介绍，介绍一下项目流程
网页输入 url 之后会有什么过程？
讲讲三次握手，为什么是三次？两次不行吗？
做过 socket 编程吗？讲讲 socket 中的状态？
进程和线程的区别
Synchronized与Lock的区别
事务隔离级别和实现原理，mysql发生锁死怎么办？
Java的垃圾回收机制
线程池了解多少，线程池的参数有哪些？
HashMap原理（感觉是个必问题）
有100只瓶液体，其中一瓶是毒药，一只小白鼠喝到毒药一周后会死亡。请问给一周时间，至少需要多少只小白鼠能确定哪瓶是毒药？（把瓶子序号变成二进制）
代码实现链表的反转
一个整数数组先升序后降序，给一个整数k，返回它在数组中的index，找不到的话返回-1
算法题：连续子数组最大和 / 乘积
美团第三面：融洽
问oracle里面的函数有什么用？
面向对象都有哪些特性以及你对这些特性的理解
访问权限修饰符都有哪些？以及他们的区别
抽象的(abstract)方法是否可同时是静态的(static), 是否可同时是本地方法(native)，是否可同时被 synchronized？
聊聊我应聘的部门在做什么，谈谈我对项目的理解，怎么开展一个项目？
美团HR面试：稳了
自我介绍
为什么想来美团，对美团了解多少？
心中的互联网公司排序（送命题）
工作中遇见暂时无法解决的问题，你怎么来应对？
自己的优点和缺点
未来的职业规划是什么？
还面了哪些公司？结果怎么样？
薪资要求
添加图片注释，不超过 140 字（可选）
面试美团前，我做的准备工作（大厂收割秘籍）
1.定制自己的简历（对标BATJ）
无论是什么行业，简历都是敲门砖，对于程序员来说，更应该着重准备，甚至要做到逐字推敲。关于简历，我个人有以下两点建议：
①尽可能突出自己的优势
一定要让看到你简历的人一眼就看到你自己所具备的优势，要学会突出重点，如你在上一家公司做出的贡献，就要写在显眼的位置进行突出，用颜色加深再好不过。如果你的优势是学历，那么学历就要放在第一页，因为HR在筛选简历时，一份简历往往只看那么几秒钟，你需要做到的就是让HR一眼看中你的简历。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c87dff3212c8449aeaa3c83330be49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c889afc5747cadb8ed56c568f581a4c/" rel="bookmark">
			淘宝爬虫评论数据采集的探索之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的普及，淘宝作为中国最大的电商平台，每天都有大量的用户在上面购物。为了更好地了解商品的质量和用户的满意度，许多消费者开始关注商品的评论数据。然而，手动翻阅大量的评论不仅耗时，而且容易遗漏重要的信息。因此，我们需要一种自动化工具来帮助我们采集淘宝上的评论数据。联讯数据将介绍如何使用爬虫技术采集淘宝评论数据，并探讨其应用价值。
一、淘宝评论数据采集工具的选择
为了实现淘宝评论数据的采集，我们可以选择使用爬虫工具。常见的爬虫工具有Python、Selenium、Puppeteer等。其中，Python因其易学易用、丰富的库支持等优点成为首选。选择合适的爬虫工具后，我们需要根据淘宝网站的特点进行一些技术调整，以便成功采集到评论数据。
二、采集流程与方法
首先，我们需要了解淘宝网站的结构和评论发布规则。一般来说，评论数据会存储在网站的某个特定位置，需要找到正确的URL链接。其次，根据爬虫工具的编程语法编写代码，实现自动登录、翻页、下载评论等操作。最后，将采集到的评论数据保存到本地或数据库中，以便后续分析和利用。
三、应用价值与案例分析
通过采集淘宝评论数据，我们可以获取到大量真实、客观的用户反馈，帮助我们更好地了解商品的质量和用户的需求。例如，我们可以分析不同商品的评价趋势，了解用户对某一类商品的关注点；也可以根据用户评价对商品进行分类，为消费者提供更有针对性的推荐。此外，商家可以利用这些数据改进商品质量、提高服务水平，从而提升用户满意度和忠诚度。
{ "api": "cdy.taobao.taobao.item.rate", "data": { "abBucketName": "default_buckets#-1", "abCode": "default_buckets", "allowInteract": "true", "canReport": "false", "configMap": { "card_version": "old", "show_comments": "false" }, "extraInfo": { "impr_showtag": "回头客;88VIP;容易耐脏;防水;很保暖;尺码合适;不影响贴合度;质量一般", "impr_showtag_attributeId": "0;0;40011621;40061065;40061043;40101000;40011286;40161003", "impr_showtag_id": "rc;88;40011621-11;40061065-11;40061043-11;40101000-11;40011286-11;40161003-13", "impr_showtag_sum": "91;92;5;21;116;102;2;6", "newDetail": "false", "newInteraction": "false", "newList": "false" }, "feedAllCount": "4605", ... ... }, "v": "3.0", "left_num": 40 } 淘宝评论数据采集是一种有效的工具，可以帮助我们获取到更多真实、客观的用户反馈。通过分析这些数据，我们可以更好地了解商品的质量和用户的需求，为消费者提供更有针对性的推荐，同时也为商家提供改进商品质量、提高服务水平的依据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/556a8deaae75d13ba5df9b3af2315922/" rel="bookmark">
			当使用WSL下载运行Docker可视化界面的镜像，使用报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Traceback (most recent call last):
File “app.py”, line 345, in root = tk.Tk()
File “/usr/lib/python3.8/tkinter/init.py”, line 2270, in init
self.tk = _tkinter.create(screenName, baseName, className, interactive, wantobjects, useTk, sync, use)
_tkinter.TclError: couldn’t connect to display “”
在WSL中无法直接连接到Windows主机上的X服务器。这是因为WSL和Windows主机之间存在一些网络隔离。
要在WSL中运行GUI应用程序并连接到Windows主机上的X服务器，您可以使用X服务器软件，例如Xming或VcXsrv，在Windows主机上启动X服务器。然后，在WSL中设置DISPLAY环境变量以指向Windows主机上的X服务器。
例如：
在Windows主机上安装并启动X服务器软件（例如Xming或VcXsrv）。确保X服务器正在运行，并注意其显示地址和端口号。
在WSL中设置DISPLAY环境变量以指向Windows主机上的X服务器。将以下命令添加到您的WSL会话中：
export DISPLAY=&lt;Windows主机IP地址&gt;:0.0 请将&lt;Windows主机IP地址&gt;替换为您实际的Windows主机的IP地址。
在Windows主机上打开命令提示符（或PowerShell），然后键入ipconfig并按Enter。这将显示您的Windows主机当前的网络配置信息，其中包括该主机的IP地址。
在输出中找到IPv4地址，通常长得像“192.168.x.x”或“10.x.x.x”。将此地址用作您的WSL会话中DISPLAY环境变量中的Windows主机IP地址部分。
例如，如果您在Windows主机上看到IPv4地址为“192.168.1.12”，那么您可以使用以下命令设置DISPLAY环境变量：
export DISPLAY=192.168.1.12:0.0
如果你想一次性使用就直接在命令行输入这句话，再运行您的docker:
如果之后可能还一直使用就在.bashrc文件里面放入这句话，之后按键Esc输入英文:wq保存，再。
请注意，您需要在Windows主机上安装并启动一个X服务器，例如Xming或VcXsrv，以便WSL可以连接到它并显示GUI应用程序。
再运行您的应用程序。
注意，您还需要确保WSL和Windows主机之间的网络连接正常，并且防火墙不会阻止WSL与Windows主机之间的通信。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67a0b8abbedc569841efd2eae102fd20/" rel="bookmark">
			20240110在ubuntu20.04下重启samba服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20240110在ubuntu20.04下重启samba服务
百度搜索：samba restart
https://www.python100.com/html/78028.html
重启samba命令详解
更新：2023-05-17 16:04
一、重启samba命令
重启samba可以使用以下命令：
/etc/init.d/smb restart
或者
systemctl restart smb.service
以上两条命令均可以重启samba服务。
我们可以把这两个命令拆开来看更详细的内容：
二、重启samba服务命令
1、通过/etc/init.d/smb restart命令重启samba服务
在Linux系统中，samba服务进程名为smbd。该服务的启动文件在/etc/init.d目录下，因此可以使用该目录下的脚本控制samba服务的启动和停止。
通过/etc/init.d/smb restart命令，可以重启samba服务。
# 停止smbd服务
/etc/init.d/smb stop
# 启动smbd服务
/etc/init.d/smb start
2、通过systemctl restart smb.service命令重启samba服务
systemctl是systemd系统及服务管理器的主命令。使用systemctl命令可以管理启动时的系统和服务所用到的各种配置文件和服务单元。
通过systemctl restart smb.service命令，可以重启samba服务。
# 停止smbd服务
systemctl stop smb.service
# 启动smbd服务
systemctl start smb.service
三、几分钟重启samba
有时候需要在几分钟内快速重启samba服务。那么如何快速地重启samba服务呢？
使用systemctl reload smb.service命令可以达到快速重启samba服务的效果。
systemctl reload smb.service
四、Linux重启smb
smb服务是samba服务的核心组件，它主要提供了Windows文件和打印机共享服务，采用客户端/服务器模式，Windows系统通过smb协议与Samba服务器进行通信。
在Linux系统中，重启smb服务可以使用以下命令来执行：
/etc/init.d/smb restart
或者
systemctl restart smb.service
五、开机自启samba服务命令
在Linux系统中，samba服务可以设置开机自启动，这样可以避免手动启动samba服务。
具体步骤如下：
1、编辑smb.service文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67a0b8abbedc569841efd2eae102fd20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5193be7b13e947f8b25549619cf5c8a7/" rel="bookmark">
			PYTHON 语音识别高阶篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、上一篇博客中讲到用SpeechRecognition库和Vosk模型来识别语音，通过麦克风录音的话，只能录很短的录音，经过不断网上搜寻，终于找到一段能控制录音时间的代码：
class Recorder(): # 录音程序 def __init__(self, chunk=1024, channels=1, rate=16000): self.CHUNK = chunk # 音频帧率（也就是每次读取的数据是多少，默认1024） self.FORMAT = pyaudio.paInt16 # 采样时生成wav文件正常格式 self.CHANNELS = channels # 音轨数（每条音轨定义了该条音轨的属性,如音轨的音色、音色库、通道数、输入/输出端口、音量等。可以多个音轨，不唯一） self.RATE = rate # 采样率（即每秒采样多少数据） self._running = True self._frames = [] # 定义frames为一个空列表 def start(self): _thread.start_new_thread(self.__recording, ()) def __recording(self): self._running = True self._frames = [] p = pyaudio.PyAudio() # 创建PyAudio对象 stream = p.open(format=self.FORMAT, # 采样生成wav文件的正常格式 channels=self.CHANNELS, # 音轨数 rate=self.RATE, # 采样率 input=True, # Ture代表这是一条输入流，False代表这不是输入流 frames_per_buffer=self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5193be7b13e947f8b25549619cf5c8a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9172d94322a6ced12871dc73cf65a3b0/" rel="bookmark">
			20240110从官网下载7-zip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20240110从官网下载7-zip
2024/1/10 15:17
百度搜索：7-zip 官网
https://sparanoid.com/lab/7z/
欢迎来到 7-Zip 官方中文网站！
7-Zip 是一款拥有极高压缩比的开源压缩软件。
下载 7-Zip 23.01 稳定版适用于 Windows 操作系统（2023-06-30）：
链接 格式 系统 大小
下载 / 镜像下载 .exe 32 位 x86 1 MB
下载 / 镜像下载 .exe 64 位 x64 1 MB
下载 / 镜像下载 .exe 64 位 ARM64 1 MB
中文版附加内容请 访问 GitHub 查看。
如果遇到下载链接无法正常下载，请尝试使用镜像下载。镜像下载为原始链接反代，请自行验证或比对镜像站与原站点的文件哈希值。
https://experiments-alicdn.sparanoid.net/7z/7z2301-x64.exe
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b538ff3dcb76e4e2d8c17ffff166f8a/" rel="bookmark">
			WSL dockers容器挂载windows下的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 -v /mnt/c/Users/&lt;Windows用户名&gt;/&lt;测试数据目录&gt;:/app/test-20240104 请注意，您需要将&lt;Windows用户名&gt;和&lt;测试数据目录&gt;替换为您在Windows上实际使用的用户名和测试数据目录。例如，如果您的Windows用户名是bear，测试数据目录位于C:\Users\bear\test-20240104\，则命令应该如下所示：
-v /mnt/c/Users/bear/test-20240104:/app/test-20240104 再例如我的文件在windows下面是
C:\Users\Lenovo\Desktop\test-20240104
-v /mnt/c/Users/Lenovo/Desktop/test-20240104:/app/test-20240104 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8084dc810cbfdb888187423028ae242/" rel="bookmark">
			rke2 Online Deploy Rancher v2.8.0 latest （helm 在线部署 rancher v2.8.0）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 简介2. 预备条件3. 安装 helm4. 安装 cert-manager4.1 yaml 安装4.2 helm 安装 5. 安装 rancher6. 验证7. 界面预览 1. 简介 Rancher 是一个 Kubernetes 管理工具，让你能在任何地方和任何提供商上部署和运行集群。
Rancher 可以创建来自 Kubernetes 托管服务提供商的集群，创建节点并安装 Kubernetes，或者导入在任何地方运行的现有 Kubernetes 集群。
Rancher 基于 Kubernetes 添加了新的功能，包括统一所有集群的身份验证和 RBAC，让系统管理员从一个位置控制全部集群的访问。
此外，Rancher 可以为集群和资源提供更精细的监控和告警，将日志发送到外部提供商，并通过应用商店（Application Catalog）直接集成 Helm。如果你拥有外部 CI/CD 系统，你可以将其与 Rancher 对接。没有的话，你也可以使用 Rancher 提供的 Fleet 自动部署和升级工作负载。
Rancher 是一个 全栈式 的 Kubernetes 容器管理平台，为你提供在任何地方都能成功运行 Kubernetes 的工具。
2. 预备条件 安装 kubernetes ，这里我选择 rke2 方式 3. 安装 helm wget https://get.helm.sh/helm-v3.13.3-linux-amd64.tar.gz tar -xzvf helm-v3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8084dc810cbfdb888187423028ae242/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce5fd875ee31ee4d81f2a8a52a9865a/" rel="bookmark">
			WSL每次使用docker都需要重新启动，要不然可能会报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 docker: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?.
See ‘docker run --help’.
WSL使用以下命令启动docker
service docker start 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb554fd817d0b679f07915ab15ef5f88/" rel="bookmark">
			网络安全（黑客）专业术语
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		攻击篇：攻击工具、攻击方法、攻击者 防守篇：软硬件、技术与服务 一、攻击篇 1、攻击工具 1. 肉鸡
所谓“肉鸡”是一种很形象的比喻，比喻那些可以被攻击者控制的 电脑、手机、服务器或者其他摄像头、路由器等智能设备，用于发 动网络攻击
例如在 2016 年美国东海岸断网事件中，黑客组织控制了大量的联网摄像头用于发动网络攻击，这些摄像头则可被称为“肉鸡”。
2. 僵尸网络
僵尸网络 Botnet 是指采用一种或多种传播手段，将大量主机感 染病毒，从而在控制者和被感染主机之间所形成的一个可一对多控制的网络僵尸网络是一个非常形象的比喻，众多的计算机在不知不 觉中如同中国古老传说中的僵尸群一样被人驱赶和指挥着，成为被 攻击者执行各类恶意活动（DDOS、垃圾邮件等）利用的一种基础 设施。
3. 木马
就是那些表面上伪装成了正常的程序，但是当这些程序运行时，就会获取系统的整个控制权限。有很多黑客就是热衷使用木马程序来控制别人的电脑，比如灰鸽子、 Gh0st、PcShare 等等。
4. 网页木马
表面上伪装成普通的网页或是将恶意代码直接插入到正常的网页文件中，当有人访问时，网页木马就会利用对方系统或者浏览器的漏洞自动将配置好的木马服务端植入到访问者的电脑上来自动执 行将受影响的客户电脑变成肉鸡或纳入僵尸网络。
5. Rootkit
Rootkit 是攻击者用来隐藏自己的行踪和保留 root（根权限，可以理解成 WINDOWS 下的 system 或者管理员权限）访问权限的工具。 通常，攻击者通过远程攻击的方式获得 root 访问权限，或者
是先使用密码猜解（破解）的方式获得对系统的普通访问权限，进入系统后，再通过对方系统存在的安全漏洞获得系统的 root 或 system 权限。 然后，攻击者就会在对方的系统中安装 Rootkit， 以达到自己长久控制对方的目的，Rootkit 功能上与木马和后门很类似，但远比它们要隐蔽。
6. 蠕虫病毒
它是一类相对独立的恶意代码，利用了联网系统的开放性特点，通过可远程利用的漏洞自主地进行传播，受到控制终端会变成攻击的发起方，尝试感染更多的系统。蠕虫病毒的主要特性有：自我复制能力、很强的传播性、潜伏性、特定的触发性、很大的破坏性。
7. 震网病毒
又名 Stuxnet 病毒，是第一个专门定向攻击真实世界中基础（能源）设施的“蠕虫”病毒，比如核电站，水坝，国家电网。作为世界上首个网络“超级破坏性武器”，Stuxnet 的计算机病毒已经感染了全球超过 45000 个网络，其目标伊朗的铀浓缩设备遭到的攻击最为严重。
8. 勒索病毒
主要以邮件、程序木马、网页挂马的形式进行传播。该病毒性质恶劣、危害极大，一旦感染将给用户带来无法估量的损失。这种病毒利用各种加密算法对文件进行加密，被感染者一般无法解密，必须拿到解密的私钥才有可能破解。
9. 挖矿木马
一种将 PC、移动设备甚至服务器变为矿机的木马，通常由挖矿团伙植入，用于挖掘比特币从而赚取利益。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb554fd817d0b679f07915ab15ef5f88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b70ab3f0c6c90e565789ffdfc494b564/" rel="bookmark">
			Mybatis多表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 MyBatis 是一款优秀的 ORM 框架，支持多表查询操作。在实际开发中，经常需要使用多表查询来获取业务数据。
表与表之间存在的三种关系：一对一，一对多，多对多
二、一对一 1.pojo student（学生类）
import java.util.List; public class Student { private int id; private String studentName; private String gender; private String address; private String email; private String remark; public Student() { } public Student(String studentName, String gender, String address,String remark) { this.studentName = studentName; this.gender = gender; this.address = address; this.remark = remark; } public int getId() { return id; } public void setId(int id) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b70ab3f0c6c90e565789ffdfc494b564/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68ca8aa4df23290975fe7139d19d7580/" rel="bookmark">
			基于springboot&#43;vue实现流浪动物救助网站设计与演示【附项目源码&#43;论文说明】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于springboot实现流浪动物救助网站设计与演示
摘要 然而随着生活的加快，也使很多潜在的危险日益突显出来，比如在各种地方会发现很多无家可归的、伤痕累累的、可怜兮兮的动物，当碰到这种情况，是否会立马伸出双手去帮助、救助它们，给它们一个温暖的家，但是由于缺乏救助和护理的知识，亦或者是害怕“麻烦”，便在纠结片刻后转身离去。日复一日，流浪动物的不断增加带来的危险是不可估量的。故不管是从什么方面出发，流浪救助网站的创建都是很有必要的。流浪救助网站的救助功能具有领养、寄养的功能，并且其救助功能所选择的救助对象分别有个人救助和机构救助，同时也可以在网站上分享出自己的多余的资源，比如东西所需的粮食等等资源，并且也提供志愿者申请通道，这不管是对流浪动物、全社会的人民以及整个社会的持续向好发展都有着无可比拟的好处。通过这个平台，不仅有效的帮助了人们对于流浪动物如何处理的问题，同时也在人们的使用中，更加为用户普及了动物护理的知识，进而在人与人的交流中广泛的传播了爱护动物的意识，带动了全民爱的行动，为了家园的美丽做出自己的努力。这些服务平台APP不仅能够让用户在各个方面享受到快捷，方便，贴心，还能够节约用户的时间，在这个什么都快节奏的社会，对用户来说，节约了时间就相当于节约了金钱。再者，对于流浪动物救助者来说，人人都做到了不让动物流浪，积极行动，他们的工作难度也将会大大减少，共建美好家园指日可待。
流浪救助网站的使用是更为便捷的，互联网的普及在这个社会是非常成功的，小到个人的交际交流，大到公司企业员工的交流，都已经离不开科技，所以，在这么成熟的平台上，各种类型的网站也就应运而生，基于无法直接救助流浪动物的用户需求，加上SpringBoot的成熟技术，基于SpringBoot的流浪动物救助网站也就自然而然的在这个时代产生。并且为用户解决了很大的困扰，也为国家减轻了人力和物力。
关键字：SpringBoot 互联网 流浪动物救助 研究背景 现在我国关于流浪动物救助的意识以及专注于对流浪动物的救助的机构的完善程度普遍不高，关于对流浪动物的救助途径还大部分还停留在纸介质宣传的基础上，这种救助手段已不能解决现在的时代所产生的问题以及人们对于动物的爱护意识的发展。由于对救助的知识的不足，同时还缺乏申述的途径，这大大降低了救助的工作效率，传统的救助方法直接影响到救助的事业发展。该流浪救助网站的就是在这样的背景下，针对无数的流浪动物无家可归的现实情况，根据目前所急需的资源，设计出能够基本解决这方面的需求的应用系统。
研究目的与意义 本课题的目的主要是解决动物无家可归的问题，通过基于web的流浪动物救助网站系统，减少社会上流浪动物的数量，从而给予每一个小生命都能得到爱的呵护，同时促进人与动物和谐共处，使社会更加的美好与健康；更进一步向人们普及对动物的护理知识以及唤起社会人士的爱护动物的共识，针对现在所紧缺的资源，做出较为完善的解决方案。利用互联网，软件，数据分析等技术配合组织人员跟高效的去实施。
问题定义 随着生活的加快以及互联网时代的快速发展，在时代不断发展的同时，在人们生活水平的不断富裕的同时，在社会生活中的某个角落同时也存在着非常不幸的事情，从而会因为蝴蝶效应，产生一系统的负面的影响。帮助流浪动物拥有一个家，开发一个流浪动物救助网站的所能赋予的定义可以从三个方面来定义，即情感层面、科学层面、新曾方面，从情感方面来讲，世界上的动物在文化历史的熏陶下，已经成为了我们的朋友，所以为了我们的朋友，我们应该给予爱，维护好这段来之不易的感情。从科学层面来讲，动物的大量流浪，大多活动在较为污秽的区域，身上大多携带者不易察觉的病毒、细菌、寄生虫等等，随着流浪而不断的传染给其他生物，将会形成一个庞大的“有害群体”，故从这一方面讲，此处行动是很有必要的。从新增方面讲，全国的宠物数量已经达到数亿只，从而使作为工作党无暇给予适当的照顾。故开发一个主题为流浪动物救助的网站是很有必要的。
系统实现概述 在将项目拉取下来之前，往往都是先要把环境部署好的，不然辛辛苦苦将项目的配置项配置好，发现是因为环境问题而无法运行起来了。响应式的网站系统的开发是采用前后端分离的模式，需要完成项目的需求分析、系统设计、测试、部署等开发过程，故该系统选择java面向对象开发语言、前端使用html+css和JavaScript开发模式、数据库采用MySQL技术，采用SpringBoot框架、微服务分布式开发，以及前端的vue框架。在以前的模式是需要配置集成环境，但现在由于技术的更新换代，已经不需要这么复杂的操作了。
系统页面展示 在圈子信息框中，用户可以发布信息，即在生活中所看见的关于动物的状况等，可发布之间的感想以及救助动物的今后的生活分享等等，点击添加圈子信息按钮，会以模态框的形式展示给用户输入的表单数据，用户输入相应的数据，便可以添加成功。然后当在管理员操作下可对用户管理中的信息进行回复，进而在此处可以及时查看回复的内容。
在志愿者中，用户填写完个人信息以及表明志愿工作内容，和志愿工作时间，同时可以实时查看审核状态，审核通过后即可加入志愿工作，同时可点击添加志愿者信息按钮，填入相应的信息即可添加一条志愿者信息，然后等待系统管理员审核。
在求助功能中，当发现需要救助的动物时，用户可以进行机构救助或者个人救助，选择机构救助时，需添加动物种类（暂时只加入猫和狗）、图片、和定位，加上文字描述提交到平台，平台将会做出相应的救援。选择个人救助时，也需要选择动物种类和添加图片及文字描述，提交平台后平台会给出救助意见。
如需要可扫取文章下方二维码联系得源码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5731ab73af4d163652913368fa216d1c/" rel="bookmark">
			基于springboot&#43;vue实现响应式企业员工绩效考评系统演示【附项目源码&#43;论文说明】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于springboot实现响应式企业员工绩效考评系统演示
摘要 时代的变化速度实在超出人类的所料，21世纪，计算机已经发展到各行各业，各个地区，它的载体媒介-计算机，大众称之为的电脑，是一种特高速的科学仪器，比人类的脑袋要灵光无数倍，什么智能机器人，现代社会还将智能机器人的计算速度，博学多识与人类天才进行比较，发展它的反应能力比人类强大的多。所以，计算机的运算已经能够取代人的位置，当然，这些什么智能机器人、大数据是更深入层次的讨论计算机的发展进程，而今，计算机技术也已经深入的被应用到了各个大小企业的管理层次上。
首先论述一个事实即于企业而言，一个有效的企业管理制度，也就是论述一个有效的员工绩效考核的必要性。一个企业的员工绩效考评系统对于现代化的企业是一个必不可少的管理手段,同时也是一种带有周期性的检讨和有效的评估员工的工作表现的管理系统。那么，现如今，现代化企业的规模逐渐发展壮大，企业员工的人数也在不断的增加，管理人员该采取怎样的手段去充分的调动员工积极性，从而提升企业的效益，盘活人力资源存量，这一个十分值得研究思考的问题。尤其是某些大型企业、二级单位和三级单位很多，传统的绩效考核主要是通过人工完成，比如绩效考核的结果汇总、数据分析、结果发布等，与此同时，手工执行、单机管理方式也是绩效考核主要依靠的管理工具。如一直沿用这种传统的方式，不仅仅数据信息更新不及时，而且归档以及查询的工作非常繁琐和费时。为了让管理人员解放于复杂的手工活动中，使工作环境的极大的改善，提高工作效率从而减少失误次数的概率，基于web的绩效评估系统由此出现在了大众视野中，这也意味着传统的管理方法必然会被取代。而基于web的绩效评估系统最终也可推动企业事业的发展。
沿着这条主要方向-解决企业员工工作情况的考核问题，通过基于web的企业员工绩效考评系统，减少管理人员的工作量，提高工作效率；然后是解决企业该如何设定不同维度的考核项，争对员工的日常工作，做出公平公正的全方位考核。将传统的员工管理方法转变为基于web的企业员工绩效考评系统，利用互联网，软件，数据分析等技术配合管理人员更高效的管理员工、考核员工，最终推动企业的事业发展。这是本次课题主要目的。运用科学技术是更为便捷的，技术的成功运用及普及在这个社会是非常成功的，小到个人的交际交流，大到公司企业员工的交流，都已经离不开计算机技术，所以，在这个科学技术日益成熟的现代社会，各种类型的科学技术工具也就应运而生，基于Spring Boot响应式企业员工绩效考评系统为企业用户解决了很大的困扰，也为国家减轻了人力和物力。
关键字：绩效考评 员工 互联网 SpringBoot 研究背景 据搜集资料得出，由于繁重复杂的手工劳动，降低了工作效率，增加了工作失误的概率，然而传统的管理方法很大程度上直接影响到企业的事业发展水平以及发展速度。该企业员工绩效考评系统就是构建在这样的背景下，出发点从企业的实际情况，根据企业的员工管理事务，开发出符合公司绩效评估管理需求的应用系统。
主要研究内容 知识经济时代的步伐并不断向前迈进各个大小企业要想取得进一步的发展,在市场经济的激烈竞争中获胜,就需要重视起对企业人力资源的重视,制作出科学合理的员工绩效管理系统[10]，从基于Web技术的角度出发，采用SpringBoot技术、Mysql数据库,Tomcat服务器以及Idea工具实现项目的需求分析、系统设计、测试、部署等开发过程。完成基于SpringBoot响应式员工绩效考评系统的设计与开发。
研究目的 本课题的目的主要是解决企业员工工作情况的考核问题，通过基于web的企业员工绩效考评系统，减少管理人员的工作量，提高工作效率；然后是解决企业该如何设定不同维度的考核项，针对员工的日常工作，做出公平公正的全方位考核。将传统的员工管理方法转变为基于web的企业员工绩效考评系统，利用互联网，软件，数据分析等技术配合管理人员更高效的管理员工、考核员工，最终推动企业的事业发展。
系统页面展示 在公告板块中，用户可以添加公告内容，点击添加公告按钮，会以模态框的形式展示给用户输入的表单数据，用户输入相应的数据，便可以添加成功。然后可以对数据进行删除操作。同时，也可根据公告的发布时间进行搜索查询相对应的公告具体内容，从而进行后续操作。
在日志板块中，不仅可以查看日志的标题、具体内容以及创建时间，而且管理员可以对其进行相应的删除等管理操作，同时点击下方左右符号可以根据跳转页数，来进行日志的查询管理操作。在上方点击添加日志按钮，可完成对日志添加操作。
在公告管理中，以主管的身份可以添加公告内容，点击添加按钮，会以模态框的形式展示给用户输入的表单数据，用户输入相应的数据，便可以添加成功。然后可以对数据进行修改、删除。同时，也可根据公告的标题进行搜索查询相对应的公告具体内容，从而进行后续操作。
于绩效评分板块，主要将所有员工的绩效分数按季度为一周期做出分数统计，在绩效评分管理中，给出了员工的绩效分数、绩效时间以及一条绩效记录所创建的时间，同时，管理员可以对记录的信息列表进行删除、添加和修改操作，从而对员工的绩效分数的公平以及其真实性进行维护管理。
如需要可扫取文章下方二维码联系得源码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5fb04fae8730722330068daac3a32ca/" rel="bookmark">
			element-plus里el-date-picker日期选择器，默认值不显示的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网文档给出的示例默认值也是没有没显示的。
找了很多方法，最终是给v-model="defaultTime"绑定初始值，如下代码，需要的可以改一下
&lt;el-date-picker class="top_select" v-model="defaultTime" type="daterange" unlink-panels range-separator="-" start-placeholder="开始日期" end-placeholder="结束日期" :shortcuts="shortcuts" style="margin-right: 16px" :default-time="defaultTime" @change="timeChange" /&gt; // 获取当前日期时间对象 const currentDate = new Date(); const currentYear = currentDate.getFullYear(); const currentMonth = currentDate.getMonth(); const currentDay = currentDate.getDate(); const defaultTime = ref&lt;[Date, Date]&gt;([new Date(currentYear, 0, 1, 0, 0, 0), new Date(currentYear, currentMonth, currentDay, 23, 59, 59)]); // 但是拿到的时间需要处理成自己想要的数据 这个是我想要的年月日时分秒 const formatDate = (date: any) =&gt; { var year = date.getFullYear(); var month = ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5fb04fae8730722330068daac3a32ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db9537039e1b69befc6d5c0c13f418e6/" rel="bookmark">
			k8s的陈述式资源管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s的陈述式资源管理 命令行
kubectl命令行工具
优点：90%以上的场景都可以满足
对资源的增，删，查比较方便，对改不不太好
缺点：
命令比较冗长，复杂，难记
声明式：
k8s当中的yml文件来实现资源管理---声明式
GUI：图形化工具的管理
1 kubectl命令的详解 查看 部署 产看pod的情况（详细的信息，日志，发布和回滚）
kubectl get cs #查看master节点的状态（基本信息查看）
kubectl get pod #查看默认命名空间的内pod的信息
kubectl get ns #查看当前集群所有的命名空间
kubectl get pod -n kube-system #要查看指定命令空间内的pod需要加-n 命令空间的名称
kubectl get pod -o wide #查看默认命名空间内pod的详细信息
#kubectl get node #查询节点的信息和状态
kubectl get node -o wide #查看node节点的详细信息。
kubectl describe pod +pod的名称 #查看已经部署好的pod的详细信息。
kubectl create ns xxx 创建命名空间
#如果是基于deployment方式创建的pod,或者是daemonset方式创建的pod，是由控制器创建的pod,使用delete删除pod是不删不掉的，相当于重启pod.l
#基于deployment方式创建pod.一旦删除deployment,基于这个deployment创建的pod都会被删除。
不是基于控制器创建，会被直接删除。（比如 run 创建的）
deployment的部署pod:
陈述式部署:命令行
声明式: yaml文件部署
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db9537039e1b69befc6d5c0c13f418e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93b4b17bfba7ac6ff9f70ae3c1e1d154/" rel="bookmark">
			基于uniapp 组件uniform 得自定义picker 选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;view :class="{'uni-select':true,'is-border':inputBorder}" &gt; &lt;picker :disabled="disabled" :mode="mode" @change="bindChange" :value="index" :range="range" :range-key="rangeKey"&gt; &lt;view class="uni-select-border" :class="{'disabled':disabled}"&gt; &lt;text class="uni-input-text"&gt; &lt;text :class="{'uni-placeholder-class':!val}"&gt; {{ displayName || placeholder }} &lt;/text&gt; &lt;/text&gt; &lt;uni-icons type="bottom" size="14" color="#999"&gt;&lt;/uni-icons&gt; &lt;/view&gt; &lt;/picker&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; /** * select 输入框 正常使用uniform 的 表单校验 * @description inputBorder 是否存在标签 * range 数据源 * rangeKey 展示值 键名 * rangeValue 选定值 键名 */ function obj2strClass(obj) { let classess = ''; for (let key in obj) { const val = obj[key]; if (val) { classess += `${key} `; } } return classess; } function obj2strStyle(obj) { let style = ''; for (let key in obj) { const val = obj[key]; style += `${key}:${val};`; } return style; } export default { name: 'uni-easyinput', emits: ['update:modelValue'], model: { prop: 'modelValue', event: 'update:modelValue' }, options: { virtualHost: true }, inject: { form: { from: 'uniForm', default: null }, formItem: { from: 'uniFormItem', default: null } }, props: { name: String, value: [Number, String], modelValue: [Number, String], placeholder: { type: String, default: '请选择' }, rangeKey: { type: String, default: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93b4b17bfba7ac6ff9f70ae3c1e1d154/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/493f51df992ea6e971f9ccaa2825ce4e/" rel="bookmark">
			数据结构之红黑树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构可视化演示链接，也就是图片演示的网址
系列文章目录 数据结构之AVL Tree
数据结构之B树和B+树
数据结构之Radix和Trie
数据结构之二叉搜索树
文章目录 系列文章目录定义演示红黑树性质应用场景 定义 红黑树是一种二叉查找树，但在每个结点上增加了一个存储位表示结点的颜色，可以是RED或者BLACK。通过对任何一条从根到叶子的路径上各个着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。当二叉查找树的高度较低时，这些操作执行的比较快，但是当树的高度较高时，这些操作的性能可能不比用链表好。红黑树（red-black tree）是一种平衡的二叉查找树，它能保证在最坏情况下，基本的动态操作集合运行时间为O(lgn)。
演示 可以结合性质看更容易理解
红黑树
红黑树性质 必须要满足的五条性质：
节点是红色或者是黑色； 在树里面的节点不是红色的就是黑色的，没有其他颜色。根节点是黑色，它不能为红。每个叶节点（NIL或空节点）是黑色；每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节点），就是连续的两个节点不能是连续的红色，连续的两个节点的意思就是父节点与子节点不能是连续的红色。从任一节点到其每个叶节点的所有路径都包含相同数目的黑色节点。从根节点到每一个NIL节点的路径中，都包含了相同数量的黑色节点。 应用场景 红黑树是一种不是非常严格的平衡二叉树，没有AVLtree那么严格的平衡要求，所以它的平均查找，增添删除效率都还不错。广泛用在C++的STL中。如map和set都是用红黑树实现的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a4d315a674ec2afc6118c2bb7fae0ff/" rel="bookmark">
			vue文本识别“\n“换行问题的解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、通过 css属性 实现 设置 white-space: pre-wrap; 代码如下：
&lt;div style="white-space: pre-wrap;"&gt;({含有\n的字符串}}&lt;/div&gt; 扩展：
white-space属性值：
值描述normal默认。空白会被浏览器忽略。pre空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。nowrap文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。pre-wrap保留空白符序列，但是正常地进行换行。pre-line合并空白符序列，但是保留换行符。inherit规定应该从父元素继承 white-space 属性的值。 二、使用v-html实现 首先，将字符串里的 \n 替换为 &lt;br&gt;，然后用 v-html 指令渲染字符串为 innerHTML 。 代码如下:
// jS部分 this.text = res.data.replace(/\n/g,'&lt;br&gt;') // HTML部分 &lt;div v-html="text"&gt;&lt;/div&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/835c3a6bcbf5958fd6d78b9c217822d9/" rel="bookmark">
			Java 反射(三)-反射操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反射操作 1.通过反射获取类的结构信息 代码展示
package javareflect.demo; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; public class ReflectionUtils { public static void main(String[] args) throws ClassNotFoundException { TestApi(); } public static void TestApi() throws ClassNotFoundException { //得到Class对象 Class&lt;?&gt; personCls=Class.forName("javareflect.Person"); Field[] declaredFields=personCls.getDeclaredFields(); for (Field declaredField: declaredFields){ System.out.println("本类中所有属性=" + declaredField.getName() + " 该属性的修饰符值=" + declaredField.getModifiers() + " 该属性的类型=" + declaredField.getType()); } //getDeclaredMethods:获取本类中所有方法 Method[] methods = personCls.getDeclaredMethods(); for (Method method: methods){ System.out.println("本类中所有方法=" + method.getName() + " 该方法的访问修饰符值="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/835c3a6bcbf5958fd6d78b9c217822d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1510a12572757c74720f13049d7a73d/" rel="bookmark">
			微服务自动化.etcd跨主机集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、容器间内部通信
二、跨主机通信
1、直接路由
2、Pipework
3、Flannel
①、Flannel特点
三、环境搭建
ETCD版本问题
①、修改配置文件
②、api 2 使用方法
③、 api 3 使用方法
4、 ETCD中保存网络信息
①、使用v2版的set命令向ETCD中保存flannel覆盖网络信息
三、flannel安装与配置
1、下载或上传flannel安装包
2、创建flannel安装目录
3、解压到安装目录
4、查看解压后文件
5、 为flannel创建一个systemd服务（用于后台启动）
6、更新配置文件中并启动flanneld
7、 验证flannel网络
四、docker配置
1、查看flannel分配的网络参数
2、创建Docker运行参数
3、修改Docker启动参数
下面是docker.service要修改的地方
4、重新加载systemd配置,并重启Docker
5、查看是否应用成功
五、测试flannel
1、下载centos镜像,因为此镜像中其它软件及命令均有安装
2、依次查看集群内容器的flannel.1网络IP
3、从不同宿主机容器到其他宿主机容器
4、解决flannel下容器无法跨主机互通问题
一、容器间内部通信 bridge模式
host模式
自定义网络
Container模式
None模式
二、跨主机通信 Docker默认的网络环境下 , 单台主机上的 Docker 容器可以通过 docker0 网桥直接通信 , 而不同主机上 的Docker 容器之间只能通过在主机上做端口映射进行通信。 这种端口映射方式对很多集群应用来说极不方便。 如果能让 Docker 容器之间直接使用自己的 IP 地址进行通信 , 会解决很多问题。 按实现原理可分别直接路由方式、桥接方式( 如 pipework) 、 Overlay 隧道方式 ( 如 flannel 、 ovs+gre) 等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1510a12572757c74720f13049d7a73d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcd17084ef979caa5fb42b3dffda40df/" rel="bookmark">
			游戏后端如何实现服务器之间的负载均衡？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络游戏已成为人们休闲娱乐的重要方式之一。而在游戏开发中，如何实现服务器之间的负载均衡是一个非常关键的问题。负载均衡不仅可以提高服务器的处理能力，还能保证游戏的稳定性和流畅性。本文将探讨游戏后端如何实现服务器之间的负载均衡。
一、负载均衡的概述
负载均衡是一种将网络请求分发到多个服务器上处理的技术，以实现高可用性、可伸缩性和容错性。在游戏后端中，负载均衡的作用是将游戏玩家的请求分发到各个服务器上，使服务器能够协同工作，避免某个服务器过载的情况发生。这不仅可以提高服务器的利用率，还能保证游戏的流畅性和稳定性。
二、负载均衡的分类
负载均衡可以分为硬件负载均衡和软件负载均衡两种方式。硬件负载均衡是通过专门的硬件设备来实现的，如F5 BIG-IP等，具有高性能、高可靠性的特点，但成本也相对较高。而软件负载均衡则是通过软件来实现的，如Nginx、HAProxy等，成本较低，适用于中小型游戏开发。
三、游戏后端实现负载均衡的策略
静态负载均衡策略 静态负载均衡策略是在游戏服务器启动时，根据服务器的处理能力和配置情况，预先分配一定的游戏玩家请求数量。这种策略比较简单，适用于玩家数量相对固定的场景。但当游戏玩家数量波动较大时，这种策略的效果就不太理想了。
动态负载均衡策略 动态负载均衡策略是根据服务器的实时负载情况，动态地调整游戏玩家请求的分配。这种策略能够更好地利用服务器的处理能力，避免某个服务器过载的情况发生。常见的动态负载均衡算法有轮询、哈希、最少连接等。
(1)轮询：轮询算法将游戏玩家的请求按照一定的顺序分配给各个服务器，当某个服务器的请求数量达到一定阈值时，就将其排除在外，不再接收新的请求。这种算法比较简单，但可能会造成服务器的处理能力得不到充分利用。
(2)哈希：哈希算法将游戏玩家的请求通过哈希函数分配给各个服务器，保证相同的请求会被同一个服务器处理。这种算法能够很好地保证数据的一致性，但当某个服务器的处理能力较低时，可能会造成请求的延迟。
(3)最少连接：最少连接算法将游戏玩家的请求分配给当前连接数最少的服务器，以实现负载的均衡。这种算法能够很好地利用服务器的处理能力，但可能会造成服务器的处理能力波动较大。
四、总结
实现服务器之间的负载均衡是游戏后端开发中的一项重要任务。根据实际情况选择合适的负载均衡策略，能够有效地提高服务器的处理能力，保证游戏的稳定性和流畅性。随着云计算和虚拟化技术的发展，未来的游戏后端开发中，我们可以借助这些技术来实现更加灵活、高效和可扩展的负载均衡解决方案。
​
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a641af3a3f1d726061907c58e1f56334/" rel="bookmark">
			gem5学习（10）：创建一个简单的配置脚本——Creating a simple configuration script
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、gem5 configuration scripts
1、An aside on SimObjects
二、Creating a config file
1、导入m5库和SimObjects
2、创建模拟系统
3、设置系统时钟
4、设置内存模拟方式
5、创建CPU
6、创建系统级内存总线
7、连接请求-响应端口
（1）An aside on SimObjects
8、连接其他端口
9、创建内存控制器并连接到内存总线
（2） Syscall Emulation vs Full System
10、创建进程
11、实例化系统并执行
12、实际仿真
13、检查系统状态
14、完整代码
三、Running gem5
结果
ISAs和CPU types的其他说明
官方教程：gem5: Creating a simple configuration script
教程（9）中已经完成了一个简单的模拟脚本，并首次运行了gem5。此时我们已经成功构建了带有可执行文件build/X86/gem5.opt的gem5。
本教程中的配置脚本将模拟一个非常简单的系统，只有一个简单的CPU核心。这个CPU核心将连接到一个系统级的内存总线。还有一个单独的DDR3内存通道，连接到内存总线。
一、gem5 configuration scripts gem5二进制文件（gem5 binary）接受一个Python脚本作为参数，该脚本用于设置和执行模拟。在这个脚本中，可以创建要模拟的系统，并创建系统的所有组件，并为这些组件指定参数。然后，可以通过脚本开始模拟。
这个脚本完全由用户定义，可以选择使用任何有效的Python代码来编写配置脚本。gem5中附带了一些示例配置脚本，位于configs/examples目录下（但是部分已经被弃用，无法运行了）。这些脚本通常包含了各种选项的设置。本教程将从一个最简单的脚本开始，并逐步扩展。通过本节的学习，对模拟脚本的工作原理有一个大概的了解。
1、An aside on SimObjects 关于SimObjects的一点说明
gem5的模块化设计是围绕SimObject类构建的。模拟系统中的大多数组件都是SimObjects：CPU、缓存、内存控制器、总线等等（CPUs, caches, memory controllers, buses, etc）。gem5将所有这些对象从它们的C++实现导出到Python。因此，从Python配置脚本中，可以创建任何SimObject，设置其参数，并指定SimObjects之间的交互。
二、Creating a config file 说明：本文中使用的配置脚本在configs/learning_gem5/part1/目录中，名称为simple.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a641af3a3f1d726061907c58e1f56334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70fa0371eaedd8394f7bc86c0ad9a9cc/" rel="bookmark">
			Springboot对接ceph集群以及java利用s3对象网关接口与ceph集群交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot中引入相关依赖
&lt;dependency&gt; &lt;groupId&gt;software.amazon.awssdk&lt;/groupId&gt; &lt;artifactId&gt;regions&lt;/artifactId&gt; &lt;version&gt;2.22.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;software.amazon.awssdk&lt;/groupId&gt; &lt;artifactId&gt;eksauth&lt;/artifactId&gt; &lt;version&gt;2.22.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/software.amazon.awssdk/s3 --&gt; &lt;dependency&gt; &lt;groupId&gt;software.amazon.awssdk&lt;/groupId&gt; &lt;artifactId&gt;s3&lt;/artifactId&gt; &lt;version&gt;2.22.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;software.amazon.awssdk&lt;/groupId&gt; &lt;artifactId&gt;s3&lt;/artifactId&gt; &lt;version&gt;2.22.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 然后java代码，一些相关注意的事项都在代码里有标出。
import java.net.URI; import java.net.URISyntaxException; import java.nio.ByteBuffer; import java.nio.file.Paths; import java.util.List; import java.util.ListIterator; import java.time.Duration; import software.amazon.awssdk.auth.credentials.AwsCredentials; import software.amazon.awssdk.auth.credentials.AwsBasicCredentials; import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider; import software.amazon.awssdk.core.sync.RequestBody; import software.amazon.awssdk.regions.Region; import software.amazon.awssdk.services.s3.S3Client; import software.amazon.awssdk.services.s3.model.Bucket; import software.amazon.awssdk.services.s3.model.ListBucketsResponse; import software.amazon.awssdk.services.s3.model.ListObjectsResponse; import software.amazon.awssdk.services.s3.model.ObjectCannedACL; import software.amazon.awssdk.services.s3.model.S3Exception; import software.amazon.awssdk.services.s3.model.S3Object; import software.amazon.awssdk.services.s3.presigner.S3Presigner; import software.amazon.awssdk.services.s3.presigner.model.PresignedGetObjectRequest; /** * @author 忆林pp * @className: Ceph_upload_test * @description: 测试对接ceph数据库 * @date 2024/1/10 10:44 * @version：1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70fa0371eaedd8394f7bc86c0ad9a9cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77c05aa7dbe49dcf34c21baca765df25/" rel="bookmark">
			【算法】链表题的常用技巧及算法题（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 常用技巧 &amp;&amp; 操作2. 根据技巧 小试牛刀141.环形链表142.环形链表II19.删除链表的倒数第N个结点LCR024.反转链表 3. 解决算法题2.两数相加24.两两交换链表中的节点143.重排链表23.合并K个升序链表25.K个一组翻转链表 1. 常用技巧 &amp;&amp; 操作 下面的技巧通过一些后面的例题可以较好的理解熟练。
常用技巧
画图 链表题通过画图可以较为直观分析链表，方便分析如何进行对链表的操作等 引入虚拟“头”节点 虚拟节点适合处理一些边界情况同时放便我们进行对链表的操作 多定义变量 多定义变量增强可读性，也方便自己写代码时的思路如当频繁使用cur节点的next时，直接定义 ListNode* next = cur-&gt;next; 不用再频繁对cur-&gt;next进行操作（这个例子较为简单，对于偏复杂的情况有大优点）不用过于在意这一点空间开销 双指针 如快慢双指针可以解决链表判环、找环入口等。 常用操作 头插 - “反转链表等题，可以解题”尾插 2. 根据技巧 小试牛刀 下面的题目难度不算太高，就用文字描述的形式解释思路、原理。
141.环形链表 思路
解法：即前面介绍过的快慢双指针。
解法原理：快指针每次移动两步，而慢指针每次移动一步。如果链表中存在环，那么快指针相对于慢指针的速度差是一定的，因此快指针会逐渐靠近慢指针，最终追上它们。如果链表中不存在环，那么快指针会先到达链表的末尾。
代码
bool hasCycle(ListNode *head) { // 快慢指针 ListNode* slow = head, *fast = head; while(fast &amp;&amp; fast-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow == fast) return true; } return false; } 142.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77c05aa7dbe49dcf34c21baca765df25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177799b0fae9c2c3e2a3e5d622b8b19e/" rel="bookmark">
			【Redis】Redis分布式锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入 首先看下面这段代码：
这是一段抢券代码，看着没什么问题，但是当是多线程情况下，那么就可能出现并发问题，出现超卖。为了解决这个问题，我们可能会加锁，那么接下来看加锁后的代码：
这段代码已经完美解决了超卖的问题，但是我们要想，如果我们的项目是单体项目，且只启动了一台服务，那么上面加锁后的代码是没问题的。但我们的项目往往是集群部署，把同一份代码部署再多台服务器上。如下图所示：
如果是这样的话，那么我们加锁的逻辑就又出现问题了。看下面逻辑：
左边是 8080 服务线程，右边是 8081 服务线程。8080 服务线程 1 可以拿到互斥锁，查询到优惠券，而右边 8081 服务线程 1 也拿到互斥锁，查询了优惠券，这时我们发现各个服务都能查询到优惠券，这就出现了问题。
那这是为什么呢？这是因为Sychronized属于本地锁，目前锁是属于 JVM 的，然而每一个服务都有自己的 JVM。Sychronized只能解决同一个 JVM 线程下的互斥，而不能解决多个 JVM 下线程的互斥。所以我们需要使用一个外部的锁，那么这就是分布式锁。
Redis 实现分布式锁 Redis 实现分布式锁是基于 Redis 的 setnx 命令来实现的。
设置超时时间是为了防止某台服务宕机，能够自动释放锁。
如何合理控制锁的有效时长？换句话说，如果执行业务的时长大于了锁的时间，那么该怎么办呢？我们就需要给锁续期。我们可以新开一个线程监控，然后进而监听、续期。现在市面上有很多成熟的技术，那么 redisson 就是其中一种。
Redisson 实现分布式锁-执行流程 Redisson 实现分布式锁也是基于 Redis 的 setnx 命令来实现的，只不过 Redisson 又做了很多的增强和优化。
看下面流程：
加锁成功以后，会另开一个线程进行监控这个持有锁的线程，然后续期。releaseTime 就是锁的过期时间，默认是 30 秒。释放锁需要我们手动来释放，然后通知看门狗无需监听。
Redisson 中还新增了重试机制
当一个线程来了之后，不能获取到锁，会进行不断地循环获取锁。流程如下：
所有 redis 命令基于 lua 脚本完成的，保证原子性。
redisson 使用：
Redisson 实现分布式锁-可重入 待补充~~~
Redisson 实现分布式锁-主从一致性 RedLock 红锁可以保证主从一致性，但是实现复杂，性能差，较麻烦，所以不推荐使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/177799b0fae9c2c3e2a3e5d622b8b19e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b04cba93f73612cd3588760d34c70747/" rel="bookmark">
			Android 通知简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 通知简介 1. 基本通知 图1: 基本通知详情
小图标 : 必须提供,通过 setSmallIcon( ) 进行设置.应用名称 : 由系统提供.时间戳 : 由系统提供,也可隐藏时间.大图标(可选) : 可选内容(通常仅用于联系人照片,请勿将其用于应用图标),通过setLargeIcon( ) 进行设置.标题 : 可选内容,通过 setContentTitle( ) 进行设置.正文文本 : 可选内容,通过 setContentText( ) 进行设置. 2. 通知操作 尽管并非强制要求，但每个通知都应在用户点按时打开相应的应用 Activity。除了这种默认的通知操作之外，还可以添加可在通知中完成与应用相关任务的操作按钮（通常不需要打开 Activity）,一个通知最多可以提供三个操作按钮供用户快速相应通知.
图2: 带有一个个操作按钮的通知
图3: 点击 “ REPLY ” 按钮会打开文本输入框
参考: 在Android 10 (API级别29)和更高版本中,如果应用不提供自己的通知操作按钮,则系统会自动生成通知操作按钮.
3. 通知模板 (1) 标准模板 标准模板适用于大多数通知，它允许使用简洁文本、大图标和操作。
图4: 标准通知模板 (2) 大文本模板 (BigTextStyle) 默认情况下，通知的文字内容会被截断以放在一行。如果需要长一些的通知，可以通过应用该模板启用更大的展开式文本区域。
图5: 大文本模板的通知
(3) 大图模板 (BigPictureStyle) 大图模板专为包含图片的通知而设计。收起后，通知将显示图片的大图标缩略图。展开后，通知会显示更大的预览。
图6: 大图模板的通知
(4) 进度模板 进度模板专为用户发起的需要时间才能完成的活动而设计。展开后，使用此模板的通知会显示进度条，并且还会包含“取消”操作，以便用户终止此 activity。（不可取消的活动不要求发送通知。）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b04cba93f73612cd3588760d34c70747/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1edb671b491bb53f15f1dadc9643d470/" rel="bookmark">
			spring-cloud集成数据库版本迁移工具flyway
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring-Cloud集成数据库版本迁移工具Flyway Flyway实现数据库版本同步有两种方式，一种就是直接导包，通过配置文件使用，还有一种就是自定义的方式。 一 、依赖+配置文件 1 flyway实现sql初始化 1.1 首先需要添加依赖 &lt;!--mysql数据库版本管理控制器flyway--&gt; &lt;dependency&gt; &lt;groupId&gt;org.flywaydb&lt;/groupId&gt; &lt;artifactId&gt;flyway-core&lt;/artifactId&gt; &lt;version&gt;5.2.4&lt;/version&gt; &lt;/dependency&gt; 1.2 然后添加配置文件 spring: flyway: # 是否启用flyway enabled: true # 编码格式，默认UTF-8 encoding: UTF-8 # 迁移sql脚本文件存放路径，默认db/migration locations: classpath:db/migration # 迁移sql脚本文件名称的前缀，默认V sql-migration-prefix: V # 迁移sql脚本文件名称的分隔符，默认2个下划线__ sql-migration-separator: __ # 迁移sql脚本文件名称的后缀 sql-migration-suffixes: .sql # 迁移时是否进行校验，默认true validate-on-migrate: true # 当迁移发现数据库非空且存在没有元数据的表时，自动执行基准迁移，新建schema_version表 baseline-on-migrate: true 1.3 测试表sql CREATE TABLE `test` ( `id` bigint(0) NOT NULL AUTO_INCREMENT COMMENT 'id', `test_id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '测试id', `test_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '测试名', `del_flag` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '0' COMMENT '删除标志（0代表存在 2代表删除）', `create_by` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '创建者', `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间', `update_by` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '更新者', `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间', `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注', PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1edb671b491bb53f15f1dadc9643d470/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28dd34bcbaf7d9edd660b7a31176e2d0/" rel="bookmark">
			RealSense Depth Cameras with ROS1 安装和启动教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先进入下面的网址：
https://dev.intelrealsense.com/docs/ros1-wrapper
进入该链接后，点击最右边的“忍者神龟”
继续点进去
继续点进去后，终于来到了下载安装教程页面：
下面开始命令行代码的搬运： 一、ROS安装（若安装过可以跳过，直接看二、三） 设置资源列表
设置您的计算机以接受packages.ros.org中的软件。
sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list'
Set up your keys sudo apt install curl # if you haven't already installed curl
curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -
Installation（ROS安装） 首先，确保您的Debian包索引是最新的：
sudo apt update
Now pick how much of ROS you would like to install.
Desktop-Full Install: (Recommended) : Everything in Desktop plus 2D/3D simulators and 2D/3D perception packages
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28dd34bcbaf7d9edd660b7a31176e2d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df4e4787e9d0ff5183ae53ecd0dcb9e0/" rel="bookmark">
			泛域名和多域名https哪个性价比高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sectigo已经成立了二十几年，随着互联网的快速发展，Sectigo旗下的https证书种类也逐渐增多，例如，代码签名证书、IP证书，但是Sectigo最多的是各种域名https证书——单域名https证书、多域名https证书和泛域名https证书。今天就随SSL盾小编了解Sectigo旗下的泛域名https证书和多域名https证书哪个性价比高。
1.泛域名https证书：泛域名https证书，也称之为通配符https证书，可以用一张证书同时保护一个域名以及其所有子域名。这种https证书的使用范围比较广泛，适用于同一域名下子域名比较多的企业官网、电子商务网站、博客等。在证书有效期内可以免费无限次增加子域名站点，也就是说子域名站点越多，性价比越高。
2多域名https证书：多域名https证书是所有https证书中灵活性最强的，它可以同时保护多个独立的域名，可以是多个主域名，也可以是多个子域名。如果企业需要同时保护多个子域名或者需要同时保护多个不同的域名，使用多域名https证书可以增强网站的安全性，并提高网站的可信度。不过多域名https证书默认保护3-5个域名记录，如果不够用，还可以付费添加，而泛域名https证书虽然可以免费添加域名，但是规定添加的域名必须是一个域名下的子域名。
3.通过对泛域名https证书和多域名https证书的对比，我们可以看到两种https证书各有优劣。在选择合适的证书时，需要根据实际需求进行考虑。如果您的网站需要同时保护多个不同的域名，或者需要在一个证书中管理多个域名，那么多域名https证书可能更适合您；如果您只需要保护一个域名及其所有子域名，那么泛域名https证书可能更适合您。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f0d71cf618a9eb3c3615bed98859856/" rel="bookmark">
			LM324N引脚说明、参数解读、应用电路图说明分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
前言
一、LM324N引脚说明
二、LM324N参数解读
三、LM324N应用电路说明
前言 LM324N是一种集成电路芯片，属于低功耗、高增益的四路运算放大器。它由四个独立的运算放大器组成，可用于各种电子电路中，如比较器、振荡器、滤波器等。该芯片具有宽电压范围、低功耗、高增益稳定性等特点，常用于模拟信号处理和运算放大器应用。
一、LM324N引脚说明 LM324N共有14个引脚，具体引脚排列如下：
VCC+：正电源引脚，通常·接入正电压，一般为5V或9V。VCC-：负电源引脚，通常接入负电压，一般为-5V或-9V。IN1、IN2、IN3、IN4：输入引脚，用于输入待放大的信号。它们可以接受从负电源到正电源之间的电压范围。OUT1、OUT2、OUT3、OUT4：输出引脚，用于输出放大后的信号。GND：接地引脚，用于将电路中的地线连接在一起。 二、LM324N参数解读 LM324N的主要参数包括：
电源电压范围：LM324N可以在一个单一的电源上工作，电源电压范围为3V至36V。同时，也可以在分割电源上操作该器件。带宽增益乘积：该运放的带宽增益乘积为1MHz，且开环电压增益为400dB。这意味着它在1Hz频率处的开环增益为400mV/V。输入阻抗：由于LM324N具有差分输入，因此它的输入阻抗非常高，达到约10MΩ。输出阻抗：该运放的输出阻抗约为70Ω。功耗：在典型应用中，LM324N的功耗为1.5W。工作温度范围：该运放的工作温度范围为-40℃至+85℃。 参数和引脚说明参考：LM324N资料
三、LM324N应用电路说明 以下是几个基于LM324N的应用电路说明：
反相交流放大电路：该电路可以将输入信号进行反相放大，放大倍数由外部电阻Rf和Ri决定。该电路不需要调试，采用单电源供电，由R1和R2组成1/2V+偏置，C1为抑振电容。同相交流放大电路：该电路可以将输入信号进行同相放大，放大倍数同样由外部电阻Rf和Ri决定。该电路也采用单电源供电，由R1和R2组成1/2V+偏置，C1为抑振电容。交流信号三分配放大电路：该电路可以将一个输入信号分配给三个输出信号，每个输出信号的放大倍数由外部电阻Rf和Ri决定。该电路也采用单电源供电，由R1和R2组成1/2V+偏置，C1为抑振电容。有源带通滤波电路：该电路采用LM324N作为有源带通滤波器，能够实现低通、高通和带通滤波功能。该电路的放大倍数由外部电阻Rf和Ri决定，采用单电源供电。比较器电路：该电路可以将两个输入信号进行比较，当输入信号大于某一阈值时，输出为高电平；当输入信号小于某一阈值时，输出为低电平。该电路采用单电源供电，由R1和R2组成1/2V+偏置，C1为抑振电容。单稳态触发电路：该电路可以将一个短暂的输入信号转换为持续一段时间的输出信号。该电路采用单电源供电，由R1和R2组成1/2V+偏置，C1为抑振电容。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c727e890f0f3af39ed5798eab585a9ab/" rel="bookmark">
			C&#43;&#43; Qt开发：Charts与数据库组件联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 是一个跨平台C++图形界面开发库，利用Qt可以快速开发跨平台窗体应用程序，在Qt中我们可以通过拖拽的方式将不同组件放到指定的位置，实现图形化开发极大的方便了开发效率，本章将重点介绍Charts组件与QSql数据库组件的常用方法及灵活运用。
在之前的文章中详细介绍了关于QCharts绘图组件的使用方式，本章将继续延续这个知识点，通过使用QSql数据库模块动态的读取某一个时间节点上的数据，当用户点击查询数据时则动态的输出该事件节点的所有数据，并将数据绘制到图形组件内，实现动态查询图形的功能。
首先我们需要生成一些测试数据，在文章课件中有一个InitDatabase案例，该案例中通过QSql组件动态创建一个Times表，该表中有三个字段分别记录了主机IP地址、时间、以及数据，并动态的想表中插入一些随机测试数据，读者可运行这段程序并等待十分钟以上，此时数据库database.sqlite3中将会出现如下所示的数据集；
再来看下主窗体是如何设计的，左侧使用一个ComboBox下拉选择框，右侧使用两个可自由调节的Date/TimeEdit组件，最底部则是一个graphicsView绘图组件，如下图；
由于涉及到IP地址的选择，所以在MainWindow主构造函数中我们需要对ComboBox组件进行初始化，在初始化时我们需要打开数据库并将数据库中的Times表，并查询到address字段，这里在查询语句中使用DISTINCT语句，该语句是用于在SQL查询中选择唯一值的关键字，它能够确保查询的结果集中每个列的值都是唯一的。
SELECT DISTINCT address FROM Times; 在代码中，上述查询的目的是从 "Times" 表中选择唯一的 "address" 列的值。如果 "Times" 表中有多个行具有相同的 "address" 值，DISTINCT 会确保在结果中只返回一个该值，以避免重复。
当具备了这条语句那么查询唯一值将变得非常容易，当查询到对应值只有只需要通过comboBox-&gt;addItem即可将唯一的IP地址追加到组件中，如下代码所示；
MainWindow::MainWindow(QWidget *parent): QMainWindow(parent), ui(new Ui::MainWindow) { ui-&gt;setupUi(this); // 初始化绘图 InitLineChart(); // 初始化时间组件 QDateTime curDateTime = QDateTime::currentDateTime(); // 设置当前时间 ui-&gt;dateTimeEdit_Start-&gt;setDateTime(curDateTime); ui-&gt;dateTimeEdit_End-&gt;setDateTime(curDateTime); // 设置时间格式 ui-&gt;dateTimeEdit_Start-&gt;setDisplayFormat("yyyy-MM-dd hh:mm:ss"); ui-&gt;dateTimeEdit_End-&gt;setDisplayFormat("yyyy-MM-dd hh:mm:ss"); // 初始化数据库 db = QSqlDatabase::addDatabase("QSQLITE"); db.setDatabaseName("database.sqlite3"); if (!db.open()) { std::cout &lt;&lt; db.lastError().text().toStdString() &lt;&lt; std::endl; return; } // 查询数据库中的IP地址信息 QSqlQuery query; if (query.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c727e890f0f3af39ed5798eab585a9ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7888d2bb7ab1dc7907361ec3bbe95da/" rel="bookmark">
			【flink番外篇】11、Flink 并行度设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink 系列文章 一、Flink 专栏
Flink 专栏系统介绍某一知识点，并辅以具体的示例进行说明。
1、Flink 部署系列
本部分介绍Flink的部署、配置相关基础内容。
2、Flink基础系列
本部分介绍Flink 的基础部分，比如术语、架构、编程模型、编程指南、基本的datastream api用法、四大基石等内容。
3、Flik Table API和SQL基础系列
本部分介绍Flink Table Api和SQL的基本用法，比如Table API和SQL创建库、表用法、查询、窗口函数、catalog等等内容。
4、Flik Table API和SQL提高与应用系列
本部分是table api 和sql的应用部分，和实际的生产应用联系更为密切，以及有一定开发难度的内容。
5、Flink 监控系列
本部分和实际的运维、监控工作相关。
二、Flink 示例专栏
Flink 示例专栏是 Flink 专栏的辅助说明，一般不会介绍知识点的信息，更多的是提供一个一个可以具体使用的示例。本专栏不再分目录，通过链接即可看出介绍的内容。
两专栏的所有文章入口点击：Flink 系列文章汇总索引
文章目录 Flink 系列文章一、并行执行1、设置并行度1）、算子层次2）、执行环境层次3）、客户端层次4）、系统层次 2、设置最大并行度 本文介绍了Flink的并行度设置的几种方式以及并行度最大的值。
如果需要了解更多内容，可以在本人Flink 专栏中了解更新系统的内容。
本文除了maven依赖外，没有其他依赖。
一、并行执行 一个 Flink 程序由多个任务 task 组成（转换/算子、数据源和数据接收器）。一个 task 包括多个并行执行的实例，且每一个实例都处理 task 输入数据的一个子集。一个 task 的并行实例数被称为该 task 的 并行度 (parallelism)。
使用 savepoints 时，应该考虑设置最大并行度。当作业从一个 savepoint 恢复时，你可以改变特定算子或着整个程序的并行度，并且此设置会限定整个程序的并行度的上限。由于在 Flink 内部将状态划分为了 key-groups，且性能所限不能无限制地增加 key-groups，因此设定最大并行度是有必要的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7888d2bb7ab1dc7907361ec3bbe95da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9042a214d3168665fd34284a223cc2ce/" rel="bookmark">
			语义解析：连接自然语言与机器智能的桥梁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 01 语义解析的应用场景场景一：场景二： 02 语义解析和大模型的关系 语义解析技术可以提高人机交互的效率和准确性，在自然语言处理、数据分析、智能客服、智能家居等领域都有广泛的应用前景。特别是在大数据时代，语义解析能够帮助企业更快速地从大量的数据中获取有用的信息，从而提高决策效率。
01 语义解析的应用场景 场景一： 在一个繁忙的办公室里，李经理正在与他的团队成员进行一项重要的项目。他们需要不断地从公司的数据库中提取各种数据来支持他们的分析和决策。然而，团队成员们并非都是数据库专家，复杂的SQL查询语句常常让他们感到困惑和效率低下。
在这个关键时刻，李经理决定引入NL2SQL技术，为团队带来一种全新的数据交互体验。
NL2SQL（自然语言到SQL）技术允许用户通过自然语言描述他们想要查询的数据，然后自动将这些描述转化为SQL查询语句。这对于非数据库专家来说是一个巨大的福音，因为它消除了编写复杂SQL语句的需要。
李经理的团队成员小王想查找去年销售额超过100万的所有产品。在没有NL2SQL之前，他可能需要花费大量时间去编写SQL语句，或者请教数据库专家。但现在，他只需简单地对系统说：“请给我去年销售额超过100万的所有产品。” NL2SQL系统立即理解了他的需求，并将这个自然语言描述转化为相应的SQL查询语句，然后执行查询。
几秒钟后，小王就得到了他所需的数据，这大大节省了他的时间和精力。他不再需要担心SQL语句的语法和结构，也不再需要等待数据库专家的帮助。他可以专注于分析和决策，而不是纠结于数据提取的细节。
NL2SQL不仅提高了团队的效率，还增强了团队成员与数据库之间的交互体验。它使得数据库查询变得更加直观、自然和高效，从而加速了项目的进展并提高了决策的准确性。李经理对他的这个决定感到非常满意，NL2SQL技术为他的团队带来了实实在在的便利和价值。
场景二： 在一个繁忙的图书馆中，读者们穿梭在书架间，努力寻找他们感兴趣的书籍。图书馆管理员小杨则站在咨询台后面，不断回答着读者们关于书籍、作者和内容的各种问题。然而，随着图书馆藏书量的不断增加，她发现自己越来越难以迅速准确地回答所有问题。
在这个背景下，图书馆引入了KBQA（知识库问答）系统，为读者和管理员带来了前所未有的便利。
KBQA系统允许用户通过自然语言提问，并从图书馆的知识库中自动检索相关信息来回答问题。这个知识库包含了图书馆所有书籍的详细信息，包括作者、出版日期、内容摘要等。
一天，一位读者走到咨询台，询问：“请问有没有关于人工智能的最近出版的书籍？”在KBQA系统之前，小杨可能需要在图书馆目录中进行繁琐的搜索，或者让读者自己去查找。但现在，她只需简单地将问题输入到KBQA系统中。
系统立即理解了问题，并在知识库中进行了快速检索。检索内容是所有具有人工智能属性的书籍的信息。几秒钟后，它返回了几本最近出版的人工智能相关书籍的信息，包括书名、作者和出版日期。小杨将这些信息展示给读者，读者非常满意地离开了咨询台。
KBQA系统的引入不仅提高了图书馆服务的质量和效率，还增强了读者与图书馆之间的交互体验。读者们可以更加轻松地找到他们感兴趣的信息，而管理员也能更高效地回答读者的问题。这种自然、直观和高效的人机交互方式，使得图书馆成为了一个更加便捷、智能的学习和交流场所。
从上述两个场景中，我们可以明显看到语义解析在人机交互中的巨大价值。无论是NL2SQL还是KBQA，它们的核心都在于对用户输入的自然语言进行深入的语义理解，并将其转化为机器可执行的指令或查询。这种转化能力不仅打破了用户与复杂数据库或知识库之间的障碍，让非专业用户也能轻松进行高级的数据操作或信息查询，还大大提高了交互的效率和准确性。更重要的是，语义解析技术使得机器能够更智能地响应用户需求，为用户提供更加个性化、精准的服务，从而增强了用户的使用体验和满意度。因此，语义解析不仅是实现自然、高效人机交互的关键，也是推动信息化社会向更高层次发展的重要驱动力之一。
通过自然语言查询数据库的意义在于提高效率和便捷性。随着技术的发展，知识存储方式也在不断演进，其中结构化和参数化是两种主要的存储方式。随着大模型运动的愈演愈烈，参数化存储可以将知识融入模型中，使得在输入时能够进行编码表示，这种方式有望逐渐取代传统的知识图谱。然而，即使机器学习模型将来达到与人类相当的水平，数据库和知识库仍然是必不可少的。因为知识图谱可能会演变成一种适合机器使用的机器词典，而不是现在我们所熟知的样子。所以参数化存储方式并不能完全替代结构化存储方式，也就是未来还是需要以数据库为代表的结构化知识存储方式。人要访问这些结构化知识，最为便捷的方式是通过自然语言进行查询。
通过自然语言查询数据库，用户可以以更加直观和高效的方式与数据库进行交互。相比于传统的查询语言，自然语言更加符合人类的思维习惯，使得非专业人士也能够轻松地从数据库中获取信息。这种交互方式的改进可以极大地提高工作效率，减少学习成本，并推动数据库的广泛应用。
通过自然语言查询数据库的意义在于适应知识存储方式的变革，提高工作效率和便捷性，推动数据库技术的发展和应用。同时，语义解析技术的发展和应用也为实现这一目标提供了有力的支持。
02 语义解析和大模型的关系 大规模预训练语言模型和语义解析技术就像是人工智能领域的两位超级英雄，它们各自有着独特的超能力，但当它们联手时，就能创造出更强大的力量。
大规模预训练语言模型，比如我们熟知的ChatGPT，就像是一个语言天才。它经过大量的训练，能够理解和生成各种复杂的文本。举个例子，如果你让它写一篇关于“环保知识”的文章，它能够轻松地为你生成一篇结构清晰、内容丰富的文稿。或者，当你感到孤单时，它可以陪你聊天，为你提供情感上的支持。它的优势在于能够处理各种自然语言任务，就像一个全能选手一样。
然而，即使是全能选手也有它的局限性。当面对大量的结构化数据时，比如数据库里的信息，大规模预训练语言模型就显得有些力不从心了。例如，假设你是一家电商公司的客服机器人，用户想查询“过去一年内，销量最高的商品是什么？”。对于大模型而言，要回答此问题需要将整个销售数据库作为输入，这显然是不现实的。此时，形式化语言作为与结构化数据交互的媒介变得尤为重要。通过语义解析技术，我们可以将用户的自然语言查询转化为SQL查询语句：“SELECT Product FROM SalesData ORDER BY QuantitySold DESC LIMIT 1”，从而直接对接数据库，获取所需信息。
此外，大模型的输出内容具有不可预测性。由于是生成式的模型，它们可能会在某些情况下产生不合理或不准确的内容。比如，当用户询问“太阳是从哪个方向升起的？”时，大模型可能会因为训练数据中的某些偏差或模型本身的随机性，产生“太阳从西方升起”的错误回答。而基于语义解析的方法由于依赖准确的结构化数据库（例如知识图谱中保存着太阳的一个属性是从东方升起），因此更倾向于给出确定的、基于知识的答案。
还有另一个例子是关于知识更新的。假设你是一位科研人员，昨天有一个重大的科学发现被公布，而今天你就想了解这个发现的具体内容。对于大模型来说，除非这个发现已经被加入到其训练数据中并重新训练了模型，否则它无法提供这一最新信息。但对于基于语义解析和数据库的方法，只需简单地更新数据库即可。这就像是你直接查阅最新的科研论文一样方便。
这时候，就需要另一位超级英雄——语义解析技术闪亮登场了。语义解析技术就像是一个精准的翻译官，它能够将自然语言转化为计算机能够理解的语言。比如，在智能家居系统中，你可以通过语音命令控制家里的灯光、音乐等设备。当你说“打开客厅的灯”时，语义解析技术会将你的语音转化为计算机能够理解的指令，从而实现灯光的控制。它的优势在于能够精确理解用户的意图，并提供可靠的答案。
这两位超级英雄的结合，就像是一场完美的舞蹈。大规模预训练语言模型提供了强大的语言生成和理解能力，而语义解析技术则为特定任务提供了精确的支持。它们的互补关系使得人工智能能够更好地理解和回应人类的需求，为我们的生活带来更多的便利和乐趣。
所以，不要小看传统的语义解析技术哦！在这个大模型的时代，它依然发挥着不可替代的作用。只有当我们充分利用两者的优势，才能实现更高效、更智能的自然语言处理体验！
《语义解析：自然语言生成SQL与知识图谱问答实战》
易显维,宁星星 著
领域专家联袂推荐
语义解析大赛获奖者撰写
满足工业级应用安全、精准需求
弥合大模型的不足
购买链接 https://item.jd.com/14292496.html
推荐语：
语义解析技术能解决大模型无法保证输出的形式语言可靠性和输出答案真实性的问题。本书由语义解析大赛获奖者撰写，通过本书的学习，读者可以了解NLP的相关技术，掌握自然语言生成SQL和知识图谱问答的实现方法。
剖析语义解析技术原理与实践，涵盖机器翻译、模板填充、强化学习、GNN、中间表达五大技术方向，并随书提供案例代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64edc424b9f780afb73dd9cd22e2e36/" rel="bookmark">
			windows配置电脑网络ip地址的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：
IP地址基本上是网络上设备的标识符，它有助于向网络上的特定设备发送信息。IP 地址是一串用句点分隔的数字。IP 地址表示为一组四个数字，例如 192.168.0.10。集合中的每个数字的范围可以从 0 到 255。因此，完整的 IP 寻址范围从 0.0.0.0 到 255.255.255.255。
互联网需要一种方法来区分不同的计算机、路由器和网站。IP 地址提供了一种执行此操作的方法，并构成了互联网工作方式的重要组成部分。
您的设备通过首先连接到连接到互联网的网络来间接连接到互联网，然后授予您的设备访问互联网的权限。当您在家时，该网络可能是您的 Internet 服务提供商 （ISP）。在工作中，它将是您的公司网络。您的 IP 地址由您的 ISP 分配给您的设备。您的互联网活动通过 ISP，他们使用您的 IP 地址将其路由回您。由于他们允许您访问互联网，因此他们的职责是为您的设备分配 IP 地址。但是，您的 IP 地址可能会更改。例如，打开或关闭调制解调器或路由器可以更改它。或者您可以联系您的 ISP，他们可以为您更改它。当您外出（例如旅行）并随身携带设备时，您的家庭 IP 地址不会随身携带。这是因为您将使用另一个网络（酒店、机场或咖啡店等的 Wi-Fi）访问互联网，并且将使用酒店、机场或咖啡店的 ISP 分配给您的不同（和临时）IP 地址。 本文介绍配置 IP 以连接到 Internet 的步骤。
要遵循的步骤：
1.转到搜索栏并搜索控制面板。一旦它出现，然后双击它。将出现一个对话框。
2.在对话框中，找到“网络和Internet”选项，然后单击它。
3.将出现一个新菜单，找到左侧的“网络和共享中心”。点击它。
4. 单击菜单左侧的“更改适配器设置”。
5. 右键单击您希望计算机连接到的所需网络。如果您无法找到所需的网络，请执行以下操作 -
检查路由器是否开启。检查以太网线是否正确插入。如果您使用的是热点，请检查该设备是否对其他设备可见。您可以通过转到手机的网络共享热点设置来检查它。 6. 点击“属性”。
7. 选择 IPv4。
IPv4 地址是一个 32 位数字，用于唯一标识计算机上的网络接口。即使其后继协议（即 IPv6 更有效）也被广泛使用。
8. 转到“属性”，然后单击“使用以下 IP 地址”单选按钮以手动添加 IP 地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b64edc424b9f780afb73dd9cd22e2e36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b92398d728d3d141c85846ade0df959/" rel="bookmark">
			如何在Linux中踢掉远程登录用户？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux中踢掉远程登录用户，可以通过以下几种方法实现：
使用who命令查看当前登录用户
首先，您可以使用who命令来查看当前登录到系统的用户列表。在终端中输入以下命令： who 这将显示当前登录的所有用户的信息，包括用户名、终端类型和登录时间等。
2. 使用pkill命令踢掉用户
如果您知道要踢掉用户的进程ID（PID），您可以使用pkill命令来终止该进程。例如，要踢掉用户名为"john"的用户，可以使用以下命令：
pkill -u john 这将终止与用户"john"相关的所有进程。请注意，这可能会导致数据丢失或其他未完成的操作被中断。
3. 使用killall命令踢掉用户
与pkill类似，killall命令也可以用来终止特定用户的进程。使用以下命令：
killall -u john 这将终止与用户"john"相关的所有进程。同样，请注意这可能导致数据丢失或其他问题。
4. 配置SSH来限制登录用户
通过配置SSH服务器，您可以限制哪些用户可以从远程登录。编辑SSH服务器配置文件（通常是/etc/ssh/sshd_config），并确保以下行存在且未被注释掉：
PermitRootLogin no AllowUsers &lt;allowed_users&gt; 其中，&lt;allowed_users&gt;是允许登录的用户的列表。保存文件后，重启SSH服务以使更改生效。这样，只有列在AllowUsers选项中的用户才能远程登录到系统。
5. 使用xkill命令踢掉所有用户
如果您想踢掉所有当前登录的用户，可以使用xkill命令。在终端中输入以下命令：
xkill 这将打开一个窗口，您可以将它移动到任何登录的用户的前面。点击该窗口将终止该用户的会话。请注意，这可能会导致数据丢失或其他问题。
6. 重启系统以踢掉所有用户
如果您想立即踢掉所有远程登录的用户，最简单的方法是重新启动系统。在终端中输入以下命令：
sudo reboot 这将重新启动系统并终止所有用户的会话。请注意，这会导致所有未保存的工作丢失。
​
​总之，Linux提供了多种方法来踢掉远程登录用户，您可以根据具体情况选择适合的方法。请务必谨慎操作，以避免不必要的损失或中断。
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ea4d2021a5afb9d45fa4dcee36b07b0/" rel="bookmark">
			C&#43;&#43;标准学习--std::bind
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面链接讲的挺清楚 C++11新特性：参数绑定——std::bind-菜鸟笔记 (coonote.com)
bind原理图释 - xusd-null - 博客园 (cnblogs.com)
暂未发现此功能对于高性能代码架构设计有什么作用。感觉比较虚。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/7/">«</a>
	<span class="pagination__item pagination__item--current">8/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/9/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>