<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4703b964277b9a9e472618d8adbdbd8/" rel="bookmark">
			SAS 对单个数据集的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-- 查询 SAS 已安装模块
proc setinit noalias;
run;
在DATA中可以使用SET、MERGE、MODIFY或UPDATE语句对数据集进行加工。
a、选取部分变量：
1、在 SET 语句中使用 data work.shos_part1;
set sashelp.shoes (keep=Product Sales)
run;
当然使用 DROP= 可以起到同样的效果。
2、在数据集选项中使用 KEEP= 或 DROP=
data work.shos_part1 (keep=Product Sales)；
run;
*两种方法虽然起到的效果是一样的，但由于在 SET语句中使用 KEEP= 是把所选定的变量读入PDV,而 数据集选项 KEEP= 语句是把所有的变量读入PDV，在读取数据进行筛选，所以在进行大规模数据运算时， SET语句 KEEP= 选项方法效率更高。
3、使用 KEEP 或 DROP 语句
data work.shos_part1;
set sashelp.shoes;
keep Product Sales;
run;
drop 语句同样也行。
b、 SAS 操作符：
运算操作符
比较操作符
逻辑操作符
其他操作符
c、选取部分观测：
在建立新数据集时，有以下两种方式可以通过已有的数据集选取适合的观测记录到新数据集：
1、只选择满足条件的观测
2、删除不符合条件的挂测
1、使用 DELETE语句删除不满足条件观测：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4703b964277b9a9e472618d8adbdbd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f14a0a0ede82de110344d7fa4840f517/" rel="bookmark">
			序列化二叉树（思路与实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 请实现两个函数，分别用来序列化和反序列化二叉树
思路：
其实这个里面包含一个二叉树的序列化而反序列化，这里的序列化指代的是将一颗二叉树没有访问的顺序，然后通过序列化，将这颗二叉树转化为有访问的顺序。所以序列化的时候给我的是一个根节点，然后我通过先序遍历，将这颗树进行序列化，然后转化为一个字符串，空的节点指针则为#表示。
而反序列化，则是给我一个序列化的字符串，然后我将这个字符创通过反序列化转化为一颗二叉树。所以我需要不断的判断这个字符创中的字符是否是#字符。
实现：
/* public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public int index = -1; String Serialize(TreeNode root) { //序列化主要就是通过将这颗树以一种方式进行顺序化。我们就将这颗二叉树进行先序遍历，得到 //访问这颗二叉树的一个访问顺序 StringBuffer sb = new StringBuffer(); if(root == null){ sb.append("#,"); return sb.toString(); } sb.append(root.val+","); sb.append(Serialize(root.left)); sb.append(Serialize(root.right)); return sb.toString(); } TreeNode Deserialize(String str) { //反序列化二叉树则是需要将一个二叉树组成的字符创进行反序列化，然后得到这个 //字符串表示的二叉树 index ++; int length = str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f14a0a0ede82de110344d7fa4840f517/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67735b25f58edb41a9542ce79e5c1d7b/" rel="bookmark">
			动态内存开辟(malloc,calloc,free,realloc)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本篇文章介绍了如何正确利用malloc、calloc、realloc函数的动态开辟我们要使用的内存，还有在进行动态内存开辟的时候常见的一些错误
为什么会存在内存开辟？ 首先，我们回忆一下到目前为止我们掌握的的内存开辟方式有哪些：
int a = 0;//在栈区连续开辟4个字节的空间 int arr[10] = { 0 };//在栈区连续开辟40个字节的空间 上述的内存开辟方式有两个特点：
内存开辟的大小是固定的 数组在声明时必须指定数组的长度，它开辟的内存在编译时候进行分配 malloc、free、calloc、realloc函数介绍 malloc 函数原型 void *malloc( size_t size ); 函数功能 这个函数向内存申请一块连续可用,大小为size个字节的空间。如果开辟成功，则返回开辟好空间的起始地址；如果开辟失败，则返回一个NULL指针，因此要对malloc函数的返回值一定要做检查。如果参数size为0，malloc的行为是标准是未定义的，取决于编译器。
函数使用 int *p = NULL; p = (int *)malloc(10);//开辟一个大小为10个字节的空间 //对malloc的返回值进行检查 if (p == NULL) { perror("use malloc"); exit(EXIT_FAILURE); } //... //使用这块空间 free 函数原型 void free( void *memblock ); 函数功能 C语言提供了一个函数free，专门用来释放和回收的起始地址为memblock动态开辟的内存块。如果参数memblock指向的空间不是动态开辟的，那free函数的行为是未定义的;如果参数memblock是NULL指针，则函数什么事都不做。
函数使用 int *p = NULL; p = (int *)malloc(10 * sizeof(int));//开辟一个大小为10个整型的空间 //对malloc的返回值进行检查 if (p == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67735b25f58edb41a9542ce79e5c1d7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/541c33605039cfbdc13c37ab6e805e08/" rel="bookmark">
			刷脸更安全 人脸识别门禁开启安防新思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 从前说“靠脸吃饭”是对“颜值至上”的调侃，而如今的“靠脸吃饭”则是实实在在利用人脸解锁身份密码从而进行消费的一种方式。事实上，人脸识别最初是应用于安防领域的，目前，安防领域仍是人脸识别技术应用最为广泛的领域之一。其中，以人脸识别门禁与我们的生活最为亲近。
在建设智慧社区的呼声下，人脸识别门禁系统的热度逐渐上升，这仿佛已经成为一种流行趋势，使得各大小区、办公大楼、学校等场所开始将其作为安防管理的新标配。
刷脸门禁更安全便捷
据云脉技术专家介绍：人脸识别是时下主流的一种生物科技，相较于传统的门禁卡、指纹识别，人脸识别门禁系统更便捷、更准确，更安全。再者，经过近些年的发展，人脸识别对不同环境的适应已经有很大进步，这提高了室外门禁系统的识别准确度，使其能够做到无感通行。
据了解，近年来，云脉技术致力于研发人脸识别技术，由其推出的人脸识别门禁系统不仅提高了社区、楼宇出入口的通行效率，带来了极大的便利，而且加强了出入人员身份安全的管理，保障了区域的安全。
内部人员自由出入门禁
简单来说，云脉人脸识别门禁系统是一个“靠脸开门”的系统。住户根据系统指示录入人脸信息，完成首次登记。往后每一次经过大门，隐藏摄像头便会自动捕捉你的脸，并将所获取到的脸部图像上传至后台，系统后台通过比对面部信息确认你的身份。当系统比对成功后，大门便会自动打开，完全无需刻意停留，也无需额外的动作，就可以开启大门，潇洒进入社区、楼宇。
外来人员加强安全管理
要保障社区、楼宇的安全，对外来人员的管理不可忽视。启用云脉人脸识别门禁系统后，非登记人员是无法自由出入的。有亲友客户前来拜访时，可在确认访客身份后进行临时性的人脸和身份证登记，访客登记流程简单便捷，无需等待。如此一来，既有效地杜绝了陌生人随意进出，强化了社区的安全管理，又为访客开通了便利通道。
尽管人脸识别门禁还未大范围普及，但不可否认，这确实是门禁系统的优选。随着相关技术的进步，未来，人脸识别门禁系统早晚会惠及千家万户。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48431297badf7f4d1b51ead48c9d98e3/" rel="bookmark">
			姿态估计之CPN(Cascaded Pyramid Network)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇是face++2017年coco keypoint benchmark 数据集冠军的文章。主要提出了基于CPN(Cascaded PyramidNetwork)结构的人体关键点检测框架。
Top-down pipeline：
整体框架采用Top-down自上而下的检测策略。首先使用行人检测框架，先检测出行人候选框。然后使用本文的CPN网络对每一个检测出来的行人候选框进行人体关键点的回归，进而输出最终结果。最终实现coco tes-dev 73 map，coco test-challengedataset 72.1map。
Motivation:
首先对于可以看见的easy 关键点直接预测得到，对于不可见的关键点，使用增大感受野来获得关键点位置，对于还未检测出的点，使用上下文context进行预测。
整体网络结构：
网络整体结构采用CPN(CascadedPyramid Network)结构，Cascaded指的是级联的意思，代表了网络级联了2个类似的模块（GolbalNet和RefineNet），Pyramid指的是类似于FPN的金字塔网络结构。
其中，GolbalNet负责网络所有关键点的检测，重点是对比较容易检测的眼睛，胳膊等部位的关键点预测效果较好，采用的损失函数为L2 loss。其中在每一个elem-sum操作之前，都对featuremap使用了1*1的卷积操作。
RefineNet指的是对GolbalNet预测的结果进行修正的网络。GolbalNet对身体部位的那些遮挡，看不见，或者有复杂背景的关键点预测误差较大，RefineNet则专门修正这些点。主要还是基于shortcut的思想。在该阶段的训练中，还使用了类似OHEM的online hard keypoints mining难例挖掘策略。
主要训练trick:
(1)数据增强，提升0.4map
训练数据的处理上使用了随机翻转，（-45度，45度）的随机旋转，（0,7,1.35）的随机尺度变换。
(2)大batch的训练，主要针对检测框架，提升0.4-0.7map
(3)在行人检测框架中使用soft NMS取代hard NMS，提升0.3map
soft NMS指的是将重叠较大的框中分数较小的那个框的分数拉到很低，但是不会去除到这个框，这样召回率相对较高。
hard NMS就是传统的NMS，直接将IOU大于一定阈值的框中得分较低的框直接去掉，相对召回率较低。
在人体关键点检测中，使用soft NMS会因为人体框召回率的提高而得到较高的分数。
(4)随着检测map的提高，关键点的map提升非常有限
(5)online hard keypoints mining
在coco数据集中有17个关键点需要预测，GolbalNet预测所有的17个点，并计算所有17个点的loss，RefineNet也预测所有的17个点，但是只计算其中最难的8个点的loss。在训练中还使用了类似OHEM的OHKM策略。
(6)多模型融合集成，提升1.1-1.5map在coco minval数据集上
References:
Cascaded Pyramid Network for Multi-Person Pose Estimation
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fe976802a49a6596c1b1745072a1d9a/" rel="bookmark">
			类和对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一-
类：class 比如Hero是一个类
对象：new Hero（）即创建了一个新对象，指向同一个类Hero
Hero h = new Hero();也就是将h指向这个新创建的对象
//创建一个对象 new Hero(); //使用一个引用来指向这个对象 Hero h = new Hero(); 操作过程是这样的，先创建对象，然后再指向于h 不同时间点写new Hero（），指向的对象并不相同
那么同一时间点的创建的那个对象是固定的，这样我创建一个后，拿无数个去指向都是一样的
比如
Hero h1 = new Hero(); Hero h2 = h1; //h2指向h1所指向的对象 Hero h3 = h1; Hero h4 = h1; Hero h5 = h4; //h1,h2,h3,h4,h5 五个引用，都指向同一个对象 Hero garen = new Hero(); garen = new Hero(); 但这样，garen指向的对象就从对象一变成了对象二
Hero h1 = new Hero(); Hero h2 = new Hero(); Hero h3; Hero h4; h3 = h1; h4 = h3; 上列h1，3，4是一样的，都指向对象一
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fe976802a49a6596c1b1745072a1d9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30eabf44542b5fac3dc69f217c6af4b7/" rel="bookmark">
			在 idea 下tomcat中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在运行/调试 配置对话框的Startup/Connection面板中，
勾选Pass environment variables.
并添加一个environment variable，
Name填 JAVA_TOOL_OPTIONS, Value填 -Dfile.encoding=UTF-8.
点击确定。重启TOMCAT进行调试，可以看到控制台中tomcat日志中的中文能正常显示了。
上面基本上应该不会出现乱码啦
如上述全部尝试还是乱码则需要修改配置文件
进入idea的安装目录, 进入bin目录下。找到idea.exe.vmoptions这个文件 和 idea64.exe.vmoptions，
在最后一行加入-Dfile.encoding=UTF-8，两个文件最好都加上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0435b0ddc8ac212adf68ac864cc4d9ce/" rel="bookmark">
			什么是映射？如何清晰的理解映射？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在计算机科学和数学里经常用到映射概念,这里打个比方就容易理解了
不废话 直接作出最直白的解释 :
生活里存在大量的对应 :
比如一个人的身份证号对应一个人 一张电影票对应一个人 一个丈夫配一个妻子
或者一个丈夫配多个妻子？？！！（对，就是你脑补的那些画面）
说白了 映射就是一种特殊的对应关系
生活里 一箭射一只鸟 多箭射一只鸟 一箭射多只鸟
映射里 每一箭必须射到鸟 还不能一箭射多只鸟 对的 就跟你这个单身狗一样 家里催着你必须结婚 还只能结一个
在计算机科学里就相应的这么理解:
映射就是将两个对象对应起来
对应的对象叫象
被对应的对象叫原象
以java中的map举例
Map names = new HashMap();
names.put("9527", "唐伯虎");
这里就将9527和唐伯虎对应起来
建立了两者的映射(对应)
9527就是唐伯虎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff54b5f16f88d56d258bc9268dc900de/" rel="bookmark">
			[IDEA] 使用快捷键查找错误和警告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用快捷键查找错误和警告 如下图所示 我们可以用F2/Shift+F2来快速定位错误和警告，这在几百行代码中定位错误是非常方便的。
切换模式 如下图所示，右键点击编辑区右上角的位置，可以在Go the high priority problems only 和 Go to next problem模式间切换
Go the high priority problems only 在优先级较高的错误间切换 Go to next problem 永远跳向下一个错误和警告，不管优先级的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c393afc455a10735e7e44a05941c421b/" rel="bookmark">
			R写入和读取csv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写入csv 输入csv使用内置函数write.csv()来实现
给一个数据
&gt; data &lt;- data.frame(姓名 = c("张三", "李四", "王五"), 体重 = c(50, 70, 80), 视力 = c(5.0, 4.8, 5.2)) &gt; data 姓名 体重 视力 1 张三 50 5.0 2 李四 70 4.8 3 王五 80 5.2 然后使用write.csv()函数来写入csv文件
&gt; write.csv(data, file = "data.csv") 这就已经写入到工作目录去了
很多时候，我们是不需要包含列名的，需要把列名去掉，就需要使用row.names = FALSE或者row.names = F
&gt; write.csv(data, file = "data.csv", row.names = FALSE) 有时候数据里面存在NA，要去掉NA的，就再加一个na = ""
&gt; write.csv(data, file = "data.csv", row.names = FALSE, na = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c393afc455a10735e7e44a05941c421b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b31540c38904e81a9d4251ca939f63dc/" rel="bookmark">
			ES6 JS 关于字符串和数组之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES6 JS 关于字符串和数组之间的转换 // ArrayBuffer转16进度字符串示例 function ab2hex(buffer) { var hexArr = Array.prototype.map.call( new Uint8Array(buffer), function(bit) { return ('00' + bit.toString(16)).slice(-2) } ) return hexArr.join(''); } // 16进制字符串转ArrayBuffer function hex2ab(value) { var typedArray = new Uint8Array(value.match(/[\da-f]{2}/gi).map(function(h) { return parseInt(h, 16) })) var buffer = typedArray.buffer; var bufLen = buffer.byteLength; if (Math.floor(bufLen % 20) != 0) { var fillBuffer = new Uint8Array(Math.ceil(bufLen / 20) * 20); fillBuffer.set(typedArray); buffer = fillBuffer.buffer; } return buffer; } /** * 字符串转16进制(只支持16进制的字符串) */ function strToHexCharCode(str) {　if (str === "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b31540c38904e81a9d4251ca939f63dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add591fbc8c7f7a4816ab0823e6f553a/" rel="bookmark">
			60万餐厅数据为你画出全国美食地图（附技术讲解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：大数据前沿
本文多图，建议阅读10分钟。
本文以省份为界限统计了各省餐厅的推荐菜，以及餐厅品牌等信息，发现了一个可怕的事实，竟然全国人民都爱吃金针菇，也发现了很多具有“地域特色”的菜品。
早就想统计一下某团的美食数据，拖了很久，终于写代码把全国所有的美食数据抓了下来，一共有60万家餐厅。
本文以省份为界限统计了各省餐厅的推荐菜，以及餐厅品牌等信息，发现了一个可怕的事实，竟然全国人民都爱吃金针菇(see you tomorrow)；也发现了很多具有“地域特色”的菜品。
快来找找你的家乡人民最爱吃的菜吧。
一. 统计概况
小编将60万餐厅在地图上进行了可视化，不过该图并没有达到我的预期效果。我认为60w数据应该比当前壮观，不过从可视化文件看上去餐厅的数量真有点“寥寥无几”，我分析了一下原因，大致是因为：
数据中的餐厅过度集中，导致可视化后亮点聚拢在一起。从地图上看，高亮地区主要集中在北京、长三角、珠三角和成渝地区。
数据的经纬度坐标精度不够，导致可视化后亮点很大程度的重叠，也有可能是我抓取的数据被投毒了。
省份维度的统计：
以下两张图分别是地图可视化图和条形图，可以看见，广东省的餐厅最多，大约有6.6万家。
总的来说沿海地区的省份餐厅数量稍微多一些，影响因素主要在于人口、餐饮业、以及互联网的普及程度，因为O2O的餐饮模式，部分地区的店铺并没有挂在网上。
城市维度的分析：
以下两张图是城市维度的可视化，很明显，第一张图中，圆圈越大代表餐厅越多，其中4座超一线城市——北上广深全部上榜。
当然另外两座城市上榜也是毫无疑问的，两座以吃著名、来了就不想走的城市——成都和重庆。
恭喜成都喜提第一！
二. 各省餐厅推荐菜
下面我们来看看各地餐厅的热门菜。
首先来看整体情况，全国餐厅中的推荐菜top100：
金针菇三个大字映入眼帘，对，金针菇是排第一的！我真的是好奇为什么，see you tomorrow 有这么大的魅力？除此之外看不出什么地域特色。
先来看看北京和上海，因为北京的外来人口较多，且各个地方的人都有，所以菜品也都比较大众，特色菜并不明显。上海我不太了解，但是在北京，酸梅汤应该是大部分餐厅都有的，麻辣香锅、宫保鸡丁、烤鸭、烤鱼，都是经常吃的。代金券这个梗我以为只有北京有，没想到上海也有哇。因为北京的O2O餐饮很发达，很多餐厅都直接把代金券写进了推荐菜里。
北京：
上海：
再来看看沿海地区，福建和广东最有特色。
福建：从菜品上来看，已经有一些沿海的味道了。
广东：牛肉丸可以理解，金针菇呢？茶位是指喝茶的地方吗？求解释。
看了沿海，我们再来看看极具特色的重庆和四川。
重庆：看着就是一股火锅的味道，是嘞，次火锅儿要次油碟，毛肚要次鲜的，吃火锅要老油，红汤锅底，无骨凤爪，耗儿鱼，鹌鹑蛋，鸭肠，麻辣牛肉不能少，吃完火锅还要吃点西瓜、喝点银耳汤。重庆——一座红彤彤的城市。
四川：和重庆一样，要吃油碟，还要吃红糖糍粑。
海南：文昌鸡是必须的；椰子饭啥味道，没吃过，不过好想吃。海南，有海鲜的味道。
下面，再来看看其他省吧！
安徽：
甘肃：
广西：青菜？
贵州：纸巾乱入了哦。
河北：小蛋糕，很可爱的感觉。
河南：烩面、凉菜、豆腐皮。
黑龙江：黑龙江人是真的很爱吃串，锅包肉和提拉米苏我是服的。
湖北：
湖南：湖南人民有点辣哦！
吉林：
江苏：
江西：
辽宁：
内蒙古：真的超级多蛋糕店哦！还有牛羊肉！
宁夏：
青海：
山东：
山西：
陕西：
天津：也是代金券的节奏哦。
西藏：好想吃下藏式火锅哦。
新疆：
云南：洋芋，好亲切，其实就是土豆的意思。
浙江：
三. 各省霸屏店铺统计
还是先来看看全国的概况：连锁店霸屏了，说实话，我还真不知道正新鸡排~
有一种预感就是接下来各省都要被正新鸡排和肯德基霸屏了，当然也会有例外。
就先拿先拿北上广来说，北京、上海、广东的外来人口相对较多，吃的东西应该比较“大杂烩”，不过还是很能看出特点，
北京：北京的呷哺呷哺到处可见，小编也吃过好多好多次了，金凤成祥、虾吃虾涮、吉野家、张亮麻辣烫，这都是围绕帝都人民红店。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/add591fbc8c7f7a4816ab0823e6f553a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/165c20e13619bedb3d0cf3075afd50c5/" rel="bookmark">
			dubbo服务注册运行正常,zk也能看到服务注册但是dubbo-Admin看不到服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://www.cnblogs.com/gossip/p/6021698.html 今天发现：Dubbo服务正常注册到ZooKeeper，客户端调用Dubbo服务正常，但是dubbo-admin看不到注册信息。 因为默认dubbo-admin默认未配置分组信息，所以需要我们手动去配置一下 ，因为我们默认用的是dubbo分组,具体查看方法：
cd /usr/local/zookeeper/bin ./zkCli.sh [zk: localhost:2181(CONNECTED) 0] ls / [dubbo, zookeeper, notice] [zk: localhost:2181(CONNECTED) 1] [root@localhost bin]# 现在我们去dubbo-admin里面修改配置： cd /usr/local/tomcat/tomcat-duboo-amdin/webapps/ROOT/WEB-INF 修改dubbo.properties文件，添加注册中心分组
vim dubbo.properties dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.admin.root.password=root dubbo.admin.guest.password=guest dubbo.registry.group=dubbo 修改dubbo-admin.xml文件，， vim classes/META-INF/spring/dubbo-admin.xml 找到并将dubbo:registry这段话注释掉
&lt;!-- &lt;dubbo:registry address="${dubbo.registry.address}" check="false" file="false"/&gt;--&gt; 贴入下面的配置
&lt;dubbo:registry group="${dubbo.registry.group}" address="${dubbo.registry.address}" check="false" file="false" /&gt; 然后重启dubbo服务，再去dubbo管理平台可以发现，注册的服务都可以看见了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f661586856523181dcfaf2471e3c6220/" rel="bookmark">
			cadence allegro16.6 pcb文件转pads pcb文件方法教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pcb设计工作中，有时会被要求将pcb文件转成其他软件的格式，pcb Allegro装Pads的方法如下。
在转换的过程中我们需要用到三种软件，ad、pads、allegro。转换的流程是：allegro→ad→pads。
1、将allegro格式的pcb文件直接拉到ad软件里打开。
ad会弹出这样的导入界面。
2、然后一直点击next或ok，一直到下图这个界面，点击finish，导入ad完成。
3、我们可以点击pcb查看一下导入是否成功，然后进行下一步。
4、然后我们需要在ad中新建个pcb，将生成的ad pcb文件复制到这个新的pcb上。
5、打开铺pads软件，点击file-import，将刚刚复制的ad pcb文件导入，格式选择如下。
6、点击打开，导入完成。
在转换的过程中，铜皮和孔可能可能会掉，转换仅作参考作用。
转载于:https://www.cnblogs.com/fany-eda/p/pcbbar.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f52a0df0212af338f618a75c51add55e/" rel="bookmark">
			基于QT的C&#43;&#43;的坦克大战游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期培训期间做的基于C++的坦克小游戏，欢迎评论。
首先是主驱动部分：tankclient.h，和tankclient.cpp
tankclient.h部分
#ifndef TANKCLIENT_H
#define TANKCLIENT_H #include &lt;QtGui/QMainWindow&gt; class Tank;//前置申明 class Missile; class explode; class TankClient : public QMainWindow { Q_OBJECT public: TankClient(QWidget *parent = 0); ~TankClient(); //画出图形的方法 void paintEvent(QPaintEvent *); //定义坦克初始坐标 //static const int才能初始化 //int x,y; //定义定时器的方法 void timerEvent(QTimerEvent *); //定义键盘事件(压下)方法 void keyPressEvent(QKeyEvent *); //定义键盘事件(松开)方法 void keyReleaseEvent(QKeyEvent *); //持有一枚主站坦克 Tank* tank; //持有装在子弹的集合(模板) QList&lt;Missile*&gt; missiles; //持有10辆敌军坦克 QList&lt;Tank*&gt; etanks; //持有爆炸的集合 QList&lt;explode*&gt; explodes; //定义游戏的分辨率 static const int GAME_W=500; static const int GAME_H=400; }; #endif // TANKCLIENT_H
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f52a0df0212af338f618a75c51add55e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21dd49c47afa2a22ed8151693a9ff0a4/" rel="bookmark">
			解决VMWare黑屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机屏幕黑屏
修复LSP。命令行窗口—输入netsh winsock reset然后重启计算机
PS: cmd要使用管理员的权限
完美解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cd0de5d7f0843c795786115f049aab8/" rel="bookmark">
			NIC指示灯代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fbb5755bab29cb2ed357075edd42b80/" rel="bookmark">
			微信小程序WebSocket实现聊天对话功能完整源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关文章：
1.小程序聊天群，发送语音，文字，图片。
2.微信小程序集成腾讯IM，实现实时音视频通话，1V1聊天
3.云开发微信小程序聊天群
4.接入网易云信IM即时通讯的微信小程序聊天室
5.微信小程序聊天功能 WebSocket 实现发送文字，图片，语音以及WebSocket 常见问题解决方案
6.[微信小程序]聊天对话(文本,图片)的功能(完整代码附效果图)
如果有个性化的需要修改，可以联系我的微信。
微信小程序开发交流qq群 173683895
承接微信小程序开发。扫码加微信。 正文： js
var app = getApp(); var socketOpen = false; var frameBuffer_Data, session, SocketTask; var url = 'ws://请填写您的长链接接口地址'; var upload_url ='请填写您的图片上传接口地址' Page({ data: { user_input_text: '',//用户输入文字 inputValue: '', returnValue: '', addImg: false, //格式示例数据，可为空 allContentList: [], num: 0 }, // 页面加载 onLoad: function () { this.bottom(); }, onShow: function (e) { if (!socketOpen) { this.webSocket() } }, // 页面加载完成 onReady: function () { var that = this; SocketTask.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fbb5755bab29cb2ed357075edd42b80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55b99497aebf3dad508bc3cb8ecc3d99/" rel="bookmark">
			centos7 增加swap分区大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装oracle11虚拟机swap空间不够了
先用free -m查看一下swap的大小
1.添加swap分区 使用dd命令创建/home/swap这么一个分区文件。文件的大小是2048000 个block，一般情况下1个block为1K，所以这里空间是2G。
dd if=/dev/zero of=/var/swapfile bs=1024 count=2048000 //添加交换文件并设置其大小为2G
2.执行完毕，对交换文件格式化并转换为swap分区： mkswap /var/swapfile
3.挂载并激活分区： swapon /var/swapfile
4 赋权限 chmod -R 0600 /var/swapfile
现在再用free -m命令查看一下内存和swap分区大小，就发现增加了2G的空间了。
注意当计算机重启了以后，发现swap还是原来那么大，新的swap没有自动启动，还要手动启动。那我们需要修改/etc/fstab文件
5.设置开机自动挂载该分区： vi /etc/fstab 在fstab文件末尾追加如下内容后:wq!保存即可： /var/swapfile swap swap defaults 0 0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ed6437d337e8957c5b2ff7b437e8ebd/" rel="bookmark">
			CUDA、tensorflow与cuDNN的版本匹配问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题现象 CUDA、tensorflow 与 cuDNN有版本匹配的问题，经常出现安装了某一版本的 CUDA 后，tensorflow 不支持相应版本的CUDA，或者tensorflow 支持 CUDA，但与 cuDNN版本不匹配，找不到这个那个文件，网上甚至有 CUDA装错等于重装的说法，很是麻烦。
这里列举了一些我遇到过的错误（有的没有装cuDNN）
CUDA9.2 + 1.8版本tensorflow
ImportError: libcudnn.so.7: cannot open shared objectfile: No such file or directory
CUDA9.2 +1.7版本tensorflow
ImportError: libcublas.so.9.0: cannot open shared objectfile: No such file or directory
CUDA9.2 +1.6版本tensorflow
ImportError: libcublas.so.9.0: cannot open shared objectfile: No such file or directory
CUDA9.2 +1.5版本tensorflow
ImportError: libcublas.so.9.0: cannot open shared objectfile: No such file or directory
CUDA9.2 +1.3版本tensorflow
ImportError: libcusolver.so.8.0: cannot open sharedobject file: No such file or directory
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ed6437d337e8957c5b2ff7b437e8ebd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10d9de3085e038b61d70022d3dd02d6a/" rel="bookmark">
			Ubuntu 16.04&#43;1080Ti机器学习基本环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设置网络 机器有两张网卡，将当前正在使用的“有线连接1”配置为以下的设置
IP使用 192.168.2.251
掩码：255.255.248.0
网关：192.168.5.1
DNS:202.96.134.133;202.96.128.166
二、安装五笔 1 、首先声明，输入法根据个人爱好，系统已经自带拼音，如果习惯则可以跳过此步骤。我是习惯五笔输入，所以根据需要先安装完整语言包，我选择中文。
右上角系统设置--&gt;语言支持--&gt;自动更新安装语言包--&gt;键盘输入法系统选择 fcitx 2、安装更新包，如果前面安装完成，这步不是必须
sudo apt-get install fcitx-table-wubi 3、重启系统
4、右上角的键盘（没有显示则按一下 Alt 键） --&gt; 配置 fcitx ，然后选择 “+”号 添加 ，选择 “五笔字形”
5、Ctrl + 空格快捷键调用中文输入，然后用 Ctrl + Shift 组合键，在可用的中文输入法之间循环切换。
三、配置SSH 1、安装：
sudo apt-getinstall openssh-server 2、启动：(可以把下面加到 ~/.bashrc配置开机启动)
sudo servicessh start
3、查询服务启动状态：
sudo ps -e |grep ssh 或者
sudo servicessh status 4、重启服务
sudo servicessh restart 四、配置 samba 1、安装samba服务
sudo apt-getinstall samba samba-client 2、配置目录
sudo vim/etc/samba/smb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10d9de3085e038b61d70022d3dd02d6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/514f10915d6f600244ee197bd32880d0/" rel="bookmark">
			换内存条要注意什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近电脑内存占用特别大，刚开机没开什么程序就70%以上了，所以决定加装一个内存条，做好准备工作是很必要的噢！
一、看一下自己电脑有多少个卡槽
有些电脑只有一个装内存条的卡槽，这样的话就不能加装，但一般都会有两个的，打开自己电脑后面看一下就知道了：
二、了解自己内存条的型号信息
你加装的内存条最好和你目前电脑上的内存条保持一致，否则可能会出现不兼容的现象；而且你要了解你电脑内存最大的容量是多少，比如是6g，你目前装的是4g，你再加装一个4g的话，加起来还是6g，但是现在一般都能加装到16g以上的啦。
（1）是ddr3还是ddr3l？什么牌子的内存条？
打开你的卡槽之后，在装内存条的位置会有标明，比如我的是ddr3，海力士的牌子；
（2）是i几的？速度是多少？
你可以安装个鲁大师进行硬件检测，可以有你电脑的一部分信息
我的是检测不到我内存条具体信息，所以可以按crtl+shift+esc打开任务管理器
我的是i5 1600。
（3）适合标压还是低压
这个也可以用鲁大师测一下，或者安装一个cpu-Z，打开spd，就可以看到你的内存信息了。
因为我的电脑无论鲁大师还是cpu-z都测不出我的内存全部信息，所以我就去问了某宝客服。目前我知道的是我电脑是海力士 ddr3 i5 1600 4g的，客服推荐我的是低压的ddr3L款，我的是ddr3，会不会不兼容，这是客服给我科普的，哈哈，get了。
所以就是加起来我应该买的是海力士 ddr3l i5 1600 4g 1.35v低压内存。
PS.可能是我的电脑操作起来比较复杂，小伙伴们可以直接试试百度自己电脑的机型，或者用鲁大师测一下，说不定就有了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55e0ee4a3bd2c319b7dc6b69174666b6/" rel="bookmark">
			删除数据（DELETE、TRUNCATE TABLE）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. DELETE 语句的作用是在指定表或指定视图的基表中删除记录行。用户可以删除位于用户自己模式中的表的记录行，也可以删除在该表上具有 DELETE 权限的表的记录行，并且在删除指定表的记录行时，必须满足该表上的完整性约束条件。其语句格式如下：
DELETE ROM &lt;table_name&gt; [WHERE condition(s)]; 2. TRUNCATE TABLE 语句用于删除表的所有数据（截断表）。其语句格式如下：
TRUNCATE TABLE &lt;table_name&gt;; 3. DELETE 删除表的所有数据时，不会释放表所占用的空间，并且操作是可以撤销的。 4. TRUNCATE TABLE 删除表的所有数据时，执行速度更快，而且还会释放表、段所占用的空间，并且操作是不能撤销的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c96b2140cc9152d3861ab1172ef8ded6/" rel="bookmark">
			代码实现单链表的操作函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#pragma once #include&lt;assert.h&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef int DataType; typedef struct SListNode{ DataType data; struct SListNode *pNext; }SListNode; //初始化 void SListInit(SListNode **ppfirst){ assert(ppfirst); *ppfirst = NULL; } //销毁 void Slistdestroy(SListNode **ppfirst){ assert(ppfirst); SListNode *pNode, *pNext; pNode = *ppfirst; while (pNode != NULL); { pNext = pNode-&gt;pNext; free(pNode); pNode = pNext; } *ppfirst = NULL; } //销毁 void SListDestroy(SListNode **ppfirst) { assert(ppfirst != NULL); SListNode *pNode, *pNext; pNode = *ppfirst; while (pNode !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c96b2140cc9152d3861ab1172ef8ded6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15cab5213bf895452762348441f6ac05/" rel="bookmark">
			24301协议文档ESM和EMM流程简要介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本帖主要介绍NAS层的一些基本流程（24301-E70协议文档）
NAR层主要完成UE与MME之间的移动性管理、会话管理、选网等功能。一共分为三个模块ESM、EMM、REG。
EMM主要分为一般流程（common procedures）、特殊流程（specific procedures）和连接管理(conention management)流程。一般流程又包含GUTI分配过程（GTUI relocation）、鉴权流程（authentication）、鉴别流程（identification）、安全控制流程（security control）等；一般流程均都由MME发起。
GUTI relocation procedure：给UE分配新的GUTI和TAI list（可选),初始的attach会分配GUTI,除此之外，跨MME的TAU会由新侧MME重新分配GUTI，GUTI也可以隐式的在ATTACH ACCEPT或者TAU accept消息里分配给UE。
authentication procedure：鉴权UE或者MME，生成加密或者密钥。
identification procedure：查看UE的IMSI和IMEI等标识。IMSI和IMEI标识都存在SMI卡中。
security control procedure:启用EPS安全上下文，对后续所有的NAS信令进行完保和加密（可选）。
特殊流程包含附着（attach）、去附着（detach）、位置更新tracking area updating（TAU ）流程
attach：为了在EPC进行附着，获得EPS提供的服务。在ATTACH过程中，同时也会建立一个default bearer，该承载的建立是为了提供UE永久在线（always-on）功能。
detach：UE的去附着和承载的删除
TAU：位置更新流程
ESM主要分为承载相关流程（EPS EPS bearer contexts）和 业务相关流程（Transaction related procedures ）。承载相关流程包含EPS默认承载上下文激活（default EPS bearer context activation）、EPS专用承载上下文激活（dedicated EPS bearer context activation）、EPS承载上下文修改（EPS bearer context modification）和EPS承载上下文去激活（EPS bearer context deactivation）。
default EPS bearer context activation：跟PDN之间建立一个default业务承载，用于业务数据的传输。该过程是对UE触发的UE的PDN CONNECTIVITY REQUEST的响应，用于在UE和EPC之间建立default EPS bearer context，跟PDN建立联系
dedicated EPS bearer context activation：在UE和EPC之间建立对应特定的QOS和TFT的EPS bearer context。 EPS bearer context modification：修改某个EPS bearer context的QOS或者TFT。 EPS bearer context deactivation：去激活某个EPS bearer上下文或者跟某个PDN断开连接。 业务相关流程包含PDN连接流程（PDN connectivity procedure）、PDN断开流程（PDN disconnect procedure）、承载资源分配流程（bearer resource allocation procedure）和承载资源修改流程（bearer resource modification procedure）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15cab5213bf895452762348441f6ac05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/701f9ef5473dd70e6cd05fe68fa7a9e8/" rel="bookmark">
			SpringBoot&#43;SpringAop通知使用实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.zdj.springboot_aop; import com.alibaba.fastjson.JSON; import com.google.common.collect.Maps; // guava 24.1-jar import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.Signature; import org.aspectj.lang.annotation.*; import org.springframework.stereotype.Component; import org.springframework.web.context.request.RequestAttributes; import org.springframework.web.context.request.RequestContextHolder; //import com.google.common.collect.Maps; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpSession; import java.util.Enumeration; import java.util.HashMap; import java.util.Map; /** * Created by Administrator on 2018/3/28. */ /** * 1.先创建一个Aspect切面类 */ @Component @Aspect public class WebControllerAop { /** * 2. 指定切点 * 匹配com.zdj.springboot_aop.Controller包及其子包下面的所有类的所有方法 */ @Pointcut("execution(* com.zdj.springboot_aop.Controller..*.*(..))") public void executeService(){ } /** * 01 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/701f9ef5473dd70e6cd05fe68fa7a9e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/078167b021b7be0642d99d1f22a30c30/" rel="bookmark">
			Laravel-admin基础用法总结和自定义model
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结laravel-admin展示用到的基本方法 基础用法 自定义model 当列表数据获取有特定条件或自己写ORM方法时可以用到，支持排序 $grid-&gt;model()-&gt;select('id','name')-&gt;where('status',1)-&gt;groupBy('project_id'); $grid-&gt;model()-&gt;select('id','name')-&gt;where('status',1)-&gt;groupBy('project_id'); //结合having 查出名字重复的 $grid-&gt;model()-&gt;select('name_en')-&gt;groupBy('name_en')-&gt;havingRaw('count(name_en)&gt;1') //嵌套子查询 查出名字重复的全部信息 $grid-&gt;model()-&gt;select('id','name_en')-&gt;whereIn('name_en',Project::select('name_en')-&gt;groupBy('name_en')-&gt;havingRaw('count(name_en)&gt;1'))-&gt;orderBy('name_en'); 模型数据获取 第一列显示id字段，并将这一列设置为可排序列 $grid-&gt;id('ID')-&gt;sortable(); 获取单列数据的方法 $grid-&gt;name_cn('名称'); 注：name_cn为与数据库对应的字段名
$grid-&gt;column('name_cn','名称'); 判断type来显示不同的状态 $grid-&gt;column('type','类型？')-&gt;display(function ($type) { return $type == 1 ? '111' : '222'; }); where条件 $grid-&gt;model()-&gt;where('type', 0); 三个时间的显示 // 下面为三个时间字段的列显示 $grid-&gt;release_at(); $grid-&gt;created_at(); $grid-&gt;updated_at(); 筛选框控制方法 基本方法 //filter($callback)方法用来设置表格的简单搜索框 $grid-&gt;filter(function ($filter) { //1.时间段筛选 设置created_at字段的范围查询 $filter-&gt;between('created_at', '筛选时间')-&gt;datetime(); //2.字段模糊查询 like = '% %' $filter-&gt;like('name', '姓名'); //3.字段equal 筛选 $filter-&gt;equal('status', '状态')-&gt;select([0 =&gt; '下线', 1 =&gt; '上线']); //4.去掉默认的ID搜索 $filter-&gt;disableIdFilter(); //5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/078167b021b7be0642d99d1f22a30c30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d82bfe89ac7a01a367eb201773888aee/" rel="bookmark">
			js两个数组对象通过相同元素匹配筛选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		let a = [
{
name: 'joy',
year: '24'
},
{
name: 'eve',
year: '25'
}
]
let b = [
{
name: 'joy',
city: 'shenzhen',
sexy: 'man'
}
]
比如我想用我的 b数组对象去匹配 a数组对象，并且得到 a中对应的年龄：
let obj = {}
obj = a.find((item) =&gt; {
return item.name == b.name })
obj.year // 24
希望本文对你有所帮助！
转载于:https://www.cnblogs.com/wangqiao170/p/9213746.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c51abe6271afc1110e5f215574e81c/" rel="bookmark">
			apache_sentry
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop 权限 Sentry Hive beeline连接Hive
beeline&gt; !connect jdbc:hive2://datanode03:10000/default scan complete in 1ms Connecting to jdbc:hive2://datanode03:10000/default Enter username for jdbc:hive2://datanode03:10000/default: hive Enter password for jdbc:hive2://datanode03:10000/default: **** 用户名和密码：hive/hive
GRANT ALL ON DATABASE db3 TO ROLE etl; 修改 hive-site.xml文件,关掉 HiveServer2 impersonation
创建用户并赋权
jdbc:hive2://10.205.58.36:10000&gt; CREATE ROLE admin; jdbc:hive2://10.205.58.36:10000&gt; GRANT ROLE admin TO GROUP hive; jdbc:hive2://10.205.58.36:10000&gt; GRANT ALL ON server SentryHostname to role admin; jdbc:hive2://10.205.58.36:10000&gt; jdbc:hive2://10.205.58.36:10000&gt; CREATE ROLE etl； jdbc:hive2://10.205.58.36:10000&gt; GRANT ROLE etl TO GROUP etl; jdbc:hive2://10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18c51abe6271afc1110e5f215574e81c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1053278044a7cc61f5dc4ea5d6befc39/" rel="bookmark">
			idea断点调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/chiangchou/p/idea-debug.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40536a1a4c99b2f72caeba67f8b44e40/" rel="bookmark">
			String与byte[]字节数组中文转换乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：http://www.cnblogs.com/hy928302776/archive/2013/04/20/3032728.htm
https://blog.csdn.net/vipclx/article/details/8029410
在Java中，String.getBytes(String decode)方法会根据指定的decode编码返回某字符串在该编码下的byte数组表示，如
byte[] b_gbk = "中".getBytes("GBK");
byte[] b_utf8 = "中".getBytes("UTF-8"); byte[] b_iso88591 = "中".getBytes("ISO8859-1");
byte[] b_unicode = "中".getBytes("unicode");
将分别返回“中”这个汉字在GBK、UTF-8和ISO8859-1编码下的byte数组表示，此时b_gbk的长度为2，b_utf8的长度为3，b_iso88591的长度为1,b_unicode 的长度为4（系统的的unicode采用的是big-endian就是前面是两个字节来表示这个的，unicode采用的都是两个字节编码，所以后面是4个字节 ）。
而与getBytes相对的，可以通过new String(byte[], decode)的方式来还原这个“中”字时，这个new String(byte[], decode)实际是使用decode指定的编码来将byte[]解析成字符串。
String s_gbk = new String(b_gbk,"GBK");
String s_utf8 = new String(b_utf8,"UTF-8"); String s_iso88591 = new String(b_iso88591,"ISO8859-1");
通过打印s_gbk、s_utf8和s_iso88591，会发现，s_gbk和s_utf8都是“中”，而只有s_iso88591是一个不认识的字符，为什么使用ISO8859-1编码再组合之后，无法还原“中”字呢，其实原因很简单，因为ISO8859-1编码的编码表中，根本就没有包含汉字字符，当然也就无法通过"中".getBytes("ISO8859-1");来得到正确的“中”字在ISO8859-1中的编码值了，所以再通过new String()来还原就无从谈起了。
因此，通过String.getBytes(String decode)方法来得到byte[]时，一定要确定decode的编码表中确实存在String表示的码值，这样得到的byte[]数组才能正确被还原。
有时候，为了让中文字符适应某些特殊要求（如http header头要求其内容必须为iso8859-1 编码），可能会通过将中文字符按照字节方式来编码的情况，如 String s_iso88591 = new String("中".getBytes("UTF-8"),"ISO8859-1")，这样得到的s_iso8859-1字符串实际是三个在ISO8859-1中的字符，在将这些字符传递到目的地后，目的地程序再通过相反的方式String s_utf8 = new String(s_iso88591.getBytes("ISO8859-1"),"UTF-8")来得到正确的中文汉字“中”。这样就既保证了遵守协议规定、也支持中文。
String的getBytes()方法是得到一个字串的字节数组，这是众所周知的。但特别要注意的是，本方法将返回该操作系统默认的编码格式的字节数组。如果你在使用这个方法时不考虑到这一点，你会发现在一个平台上运行． 良好的系统，放到另外一台机器后会产生意想不到的问题。
java中utf-8编码的byte数组转换成String类型代码
private String utfToString(byte[] data) {
String str = null;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40536a1a4c99b2f72caeba67f8b44e40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5ece14465a6739e11bf8d2a697c30a2/" rel="bookmark">
			AD中PCB布局与布线的一般原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文部分图文摘自周立功的微信公众号——ZLG致远电子
1 布局原则 1、遵照“先大后小，先难后易”的布置原则，即重要的单元电路、核心元器件应当优先布局。 先大后小，先难后易 上图中1是因为机械结构决定电源与接线柱在这里。
2、布局中应参考原理框图，根据单板的主信号流向规律安排主要元器件。布局应尽量满足以下要求：总的连线尽可能短，关键信号线最短；去耦电容的布局要尽量靠近IC的电源管脚，并使之与电源和地之间形成的回路最短 ；减少信号跑的冤枉路，防止在路上出意外。 例如下图， C8到C11都是在VCC与GND之间的去耦电容，在原理图中并没有办法体现出它们的位置要求。但是PCB中们应当布局在芯片电源的输入引脚附件，例如31与32脚附近应有电容，18与19脚附近也应有电容。 错误示例，并排放置 正确示例，靠近芯片电源输入脚 3、元器件的排列要便于调试和维修，亦即小元件周围不能放置大元件、需调试的元器件周围要有足够的空间，弄得太挤局面往往会变得很尴尬。如下图R7与C7，如果先焊接周围的器件的话，R7与C7就很难焊接了。（这里也说明了焊接的顺序很重要） 4、 相同结构电路部分，尽可能采用“对称式”标准布局；按照均匀分布、重心平衡、版面美观的标准优化布局。 均匀分布、重心平衡，布局要整齐 5、同类型插装元器件在X或Y方向上应朝一个方向放置。同一种类型的有极性分立元件也要力争在X或Y方向上保持一致，便于生产和检验。 （如需要人工确认器件极性，可能要生产成本会上升） 6、发热元件要一般应均匀分布，以利于单板和整机的散热，除温度检测元件以外的温度敏感器件应远离发热量大的元器件。除了温度传感器，三极管也属于对热敏感的器件。 7、高电压、大电流信号与小电流，低电压的弱信号完全分开；模拟信号与数字信号分开；高频信号与低频信号分开；高频元器件的间隔要充分。元件布局时，应适当考虑使用同一种电源的器件尽量放在一起，以便于将来的电源分隔。 PCB布局示例 2 布线原则 以上即是关于“怎么摆”即布局的主要注意事项。而关于“怎么连”则相对要更复杂一些，大体来说就是：
• 关键信号线优先：摸拟小信号、高速信号、时钟信号和同步信号等关键信号优先布线 ； • 密度优先原则：从单板上连接关系最复杂的器件着手布线。从单板上连线 最密集的区域开始布线 。
而布线的自助指南可以简单的总结为： 1、尽量为时钟信号、高频信号、敏感信号等关键信号提供专门的布线层，并保证其最小的回路面积。必要时应采取手工优先布线、屏蔽和加大安全间距等方法，保证信号质量。 2、电源层和地层之间的EMC环境较差，应避免布置对干扰敏感的信号。 3、有阻抗控制要求的网络应尽量按线长线宽要求布线。
3 根据原理图布局的示例 如果布局不合适，板子使用起来可能很不方便，布线难度很大。 布局时配合完成某一个功能的器件尽量挨得近一些，有操作技巧，接下来举例说明。 可以在原理图中先找到运放模块的器件，按住ctrl选中。 则PCB中，这些器件也已经被选中 然后观察原理图中的连接关系，比如C4接R3，R5，Q1。在PCB中找到这几个器件，放在一起。 观察预拉线的情况，已知每一个器件都有一个公共的网络叫做VB，可以按住ctrl选中网络属性为VB的一个焊盘，则VB高亮，例如 调整后编程如下布局 观察原理图中，Q1接R6，然后把R6也拖拽过来 其它器件以此类推 然后布线就可以比较顺利 4 低频双面板布线示例 器件导入PCB以后，先按要求完成布局。 然后有信号线，不论是串口、485还是CAN，信号线都要尽可能短，少打过孔，有时还要匹配长度，如差分。另外有时钟线，如晶振，也要短，少打过孔。
1 先走信号、时钟线。 2 走电源线，两种电源，VCC与VCC3.3。可以专门为电源线设置一个宽度规则。电源类的线也应当少走过孔，若确实需要，可以多个过孔并联 3 地线，可以根据情况决定。如大面积敷铜，可以考虑不走地线。如需要走地线，线宽应满足以下关系 地线&gt;电源线&gt;信号线
4 其它线，布线之前要观察尽可能在某个区域内，水平线与竖直线在不同的层。 水平线与竖直线走在不同的层 可适当调整器件的方向来方便走线。 目的地相近的线要整齐。可以采用交互式多根线连接工具 如果线不可避免地要交叉，可以考虑绕大圈（当然要考虑线的属性） 如图飞线交叉了。可以绕圈。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c803c4e06c6cd1ecd48667fa0d95ac8b/" rel="bookmark">
			vue实现路由跳转和嵌套（快速入门）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue-router路由的原理是通过改变网址，来实现页面的局部刷新，相比a标签跳转的不同之处在于，路由跳转不需要刷新整个页面。
一、路由跳转 1、安装路由vue-router:
npm install vue-router
2、vue项目引入vue-ruoter：
3、配置路由（页面跳转）：
可以建一个专门用于路由的js文件，里面配置路径。
1）router.js路由配置文件
2）main.js里引入router.js路由文件
4、组件里调用
1）使用router-view标签给vue组件的跳转提供一个容器
2）使用router-link标签实现跳转（它类似于a标签，区别在于router-link跳转不需要刷新页面）
方法一：to里填写的是跳转的路径，即定义路由时的path路径
方法二：to里使用路由名称name跳转
跳转至table组件：
3、实现效果
项目的首页：
点击table后跳转：
（完成）
二、路由嵌套 1、配置嵌套路由
{ path:'/about', //一级路由 component:About, children:[ { //二级路由 path:'/', //二级的默认路由（此path指向上一级，即path:'/about'） name:'expressLink', component:Express }, { path:'/about/guide', name:'guideLink', component:Guide }, { path:'/about/contact', name:'contactLink', component:Contact, children:[ { //三级路由 path:'/about/contact/personName', name:'personNameLink', component:PersonName, }, { path:'/about/contact/phone', name:'phoneLink', component:Phone }, ] } ] }, 2、组件中嵌套使用&lt;router-view&gt;&lt;/router-view&gt;
1）一级路由
2）二级路由
3）三级路由
3、实现效果
（完）
查看源代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a423086dc259ab0daae65590c88b886f/" rel="bookmark">
			正则表达式——分组与捕获
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则表达式——分组与捕获 前言 之前使用正则表达式的时候大多数状况下只是用用匹配表达式，为什么说是匹配表达式呢，因为其实替换文本也可以使用表达式，我称之为替换表达式。
因为通常使用正则表达式的大多会是以下情况，比如把一段文本中的A字符串更改为B字符串：
待匹配文本：ABCDABCD
匹配表达式：B
替换文本：E
替换结果：AECDAECD
其实替换文本这里也可以用表达式的形式，这样的方式会更加方便:
待匹配文本：ABCDABCD
匹配表达式：(B)
替换表达式：2\1
替换结果：A2BCDA2BCD
这里面涉及到的是正则表达式的分组与捕获的知识，接下来我就详细的介绍一下。
分组 分组的引入 对于要重复单个字符，非常简单，直接在字符后卖弄加上限定符即可，例如 a+ 表示匹配1个或一个以上的a，a?表示匹配0个或1个a。这些限定符如下所示：
X ?X ，一次或一次也没有X *X ，零次或多次X +X ，一次或多次X { n }X ，恰好 n 次X { n ,}X ，至少 n 次X { n , m }X ，至少 n 次，但是不超过 m 次 但是我们如果要对多个字符进行重复怎么办呢？此时我们就要用到分组，我们可以使用小括号（）来指定要重复的子表达式，然后对这个子表达式进行重复，例如：(abc)? 表示0个或1个abc 这里一 个括号的表达式就表示一个分组 。分组可以分为两种形式，捕获组和非捕获组。
捕获 捕获组 捕获组可以通过从左到右计算其开括号来编号 。例如，在表达式(A)(B(C)) 中，存在四个这样的组：
0 (A)(B(C))1 (A)2 (B(C))3 (C) 组0始终代表整个表达式
之所以这样命名捕获组是因为在匹配中，保存了与这些组匹配的输入序列的每个子序列。捕获的子序列稍后可以通过 Back 引用（反向引用） 在表达式中使用，也可以在匹配操作完成后从匹配器检索。
Back 引用 是说在后面的表达式中我们可以使用组的编号来引用前面的表达式所捕获到的文本序列。注意：反向引用，引用的是前面捕获组中的文本而不是正则，也就是说反向引用处匹配的文本应和前面捕获组中的文本相同，这一点很重要。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a423086dc259ab0daae65590c88b886f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c853b2fff7997ead654781dd716e0c1f/" rel="bookmark">
			交通违法行为代码含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 交通违法代码又称“交通违法行为代码”，是公安部对机动车、行人通行发生的交通违法行为制定的一种编码规定。 交通违法代码由四位数组成，在违法代码里，第一位代码即行为代码。共分1到5及7、8几种，代表的含义如下： 1 开头代表机动车的行为 2 代表非机动车的行为 3 代表行人的行为 4 代表在高速公路的违法行为 5 代表机动车其他的违法行为 6、 7 各省依据本省实施办法规定一些情况 8 代表各市、自治区的规定 第二位代码即记分分类代码。共0、1、2、3、6、7几种：0 表示不记分， 1表示记1分， 2表示记2分， 3表示记3分， 6表示记6分， 7表示记12分 第三、四位代码：顺序码，表示在同一行为分类中出现的行为的顺序码。 例如：1303——“1”表示机动车行为，第2个数字“3”表示要扣3分，后面的“03”表示在扣3分这一类里的第三个行为，机动车行驶超过规定时速50%以下的。 第五位分类码：在同一行为分类中出现的情形不同分类码 0 不分类 1 大型、中型载客汽车（包括有轨、无轨电车）、重型、中型载货汽车、牵引车 2 小型、微型载客汽车、轻型、微型载货汽车、轮式自行专用机械车、专项作业车 3 低速货车、三轮汽车、拖拉机 4 摩托车 5 同一违法行为情节较轻 6 同一违法行为情节较重 7 同一违法行为情节严重 公安部原交通违法行为代码表共有违法行为337种，其中：机动车通行175种，非机动车通行55种，行人、乘车人通行30种，高速公路通行28种，其他规定49种。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bfee1460bf62b86da8f8c112a647faa/" rel="bookmark">
			Java基础算法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
查找和排序算法是算法的入门知识，其经典思想可以用于很多算法当中。因为其实现代码较短，应用较常见。所以在面试中经常会问到排序算法及其相关的问题。但万变不离其宗，只要熟悉了思想，灵活运用也不是难事。一般在面试中最常考的是快速排序和归并排序，并且经常有面试官要求现场写出这两种排序的代码。对这两种排序的代码一定要信手拈来才行。还有插入排序、冒泡排序、堆排序、基数排序、桶排序等。面试官对于这些排序可能会要求比较各自的优劣、各种算法的思想及其使用场景。还有要会分析算法的时间和空间复杂度。通常查找和排序算法的考察是面试的开始，如果这些问题回答不好，估计面试官都没有继续面试下去的兴趣都没了。所以想开个好头就要把常见的排序算法思想及其特点要熟练掌握，有必要时要熟练写出代码。
接下来我们就分析一下常见的排序算法及其使用场景。限于篇幅，某些算法的详细演示和图示请自行寻找详细的参考。
冒泡排序
冒泡排序是最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。举个栗子，对5,3,8,6,4这个无序序列进行冒泡排序。首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6,3和4无需交换。5和3交换，变成3,5,4,8,6,3.这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为O(n^2)。
实现代码：
/** *@Description:&lt;p&gt;冒泡排序算法实现&lt;/p&gt; *@author 王旭 *@time 2016-3-3 下午8:54:27 */ public class BubbleSort { public static void bubbleSort(int[] arr) { if(arr == null || arr.length == 0) return ; for(int i=0; i&lt;arr.length-1; i++) { for(int j=arr.length-1; j&gt;i; j--) { if(arr[j] &lt; arr[j-1]) { swap(arr, j-1, j); } } } } public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } 选择排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bfee1460bf62b86da8f8c112a647faa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2269f310d91ce66f8ef6201c9a25259/" rel="bookmark">
			Golang并发控制--context的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们已经知道WaitGroup可以用于并发控制，但当遇到更复杂的场景时，例如主动取消goroutine或者使超时的goroutine自动退出等，WaitGroup就无能为力。
这个时候，就是context大有用武之地。
包context定义了Context类型，它跨API边界和进程之间携带截止日期，取消信号和其他请求范围的值。
对服务器的传入请求应创建一个Context，对服务器的传出调用应接受一个Context。它们之间的函数调用链必须传播Context，或者传递使用WithCancel，WithDeadline，WithTimeout或WithValue创建的派生Context。当取消一个context后，所有从这个context派生的context也会被取消。
WithCancel，WithDeadline和WithTimeout函数接受Context（父）并返回派生的Context（子）和CancelFunc。调用CancelFunc会取消子项及其子项，删除父项对子项的引用，并停止任何关联的计时器。未能调用CancelFunc会泄漏子项及其子项，直到取消父项或计时器触发。 go vet工具检查CancelFuncs是否在所有控制流路径上使用。
使用Contexts的程序应遵循这些规则，以使各包之间的接口保持一致，并启用静态分析工具来检查上下文传播：
不要将Contexts存储在结构类型中;相反，将Context明确传递给需要它的每个函数。Context应该是第一个参数，通常命名为ctx：func DoSomething(ctx context.Context, arg Arg) error { // ... use ctx ... }即使函数允许，也不要传递nil Context。如果您不确定要使用哪个Context，请传递context.TODO。仅将context values用于进程间和跨API的请求范围数据，而不是将其作为可选参数传递给函数。可以将相同的Context传递给在不同goroutine中运行的函数;上下文对于多个goroutine同时使用是安全的。 以上说明来自context包说明，如果感觉翻译的不够清楚，可以查看context的说明。(实在翻译不下去了 = =！)
Context定义如下：
type Context interface { Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct{} Err() error Value(key interface{}) interface{} } 说了这么多，现在来看下例子吧。
并发控制 Cancel Example 通过使用WithCancel可以主动取消一个或多个goroutine的执行，以实现对并发的控制。
package main import ( "context" "fmt" "time" ) func PrintTask(ctx context.Context) { for { select { case &lt;- ctx.Done(): return default: time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2269f310d91ce66f8ef6201c9a25259/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da59d0a83d95914d543d553c256cecc9/" rel="bookmark">
			c#方法重写与方法重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法重载 定义：一个类中可以有一个以上的方法拥有相同的名称，但是签名不同（签名包括方法的名称，参数的数目，参数数据类型和顺序，参数修饰符）
注意：返回类型和形参的名称不是签名的一部分。
class A { int Add(int a,int b) {return a+b;} int Add(int a,int b,int c){return a+b+c;} string Add(string a,string b){...} } 方法重写 定义：要求方法名，参数返回值相同。
意义：重写是对类中方法的扩充，因为继承用的是父类的东西，重写的话不仅得到父类的东西，也加入了自己的东西。（通俗一些来说就是父亲的公司有一套运行模式，儿子继承父亲的公司，对父亲的运行模式的基础上又加入了自己的东西）
注意：重写父类中的方法前要加上virtual子类的方法前加上override.
class A//父类 { public virtual void Print(int a) { ... } } class B:A//子类继承父类 { public override void Print(int a) { ... } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb9caf868b3e65ee5befd048ecf8085b/" rel="bookmark">
			java发送post请求以json数组形式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public static void dspDaoRu(DspNews dspNews) throws Exception { String result = ""; // 添加url参数 Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); // JSONObject obj = new JSONObject(); map.put("name", dspNews.getName()); map.put("sex", "0"); map.put("phone", dspNews.getMobile()); map.put("customerSource", QuDao.getNameByValue(dspNews.getFromWeb()));// 渠道 map.put("belongProvince", dspNews.getProvince());// 首先做判断 map.put("belongCity", dspNews.getCity());// 城市 map.put("adCode", dspNews.getDspNumber() + "-" + dspNews.getAdGroup() + "-" + dspNews.getPageNumber());// 页面广告组创意 map.put("customerSituation", "无");// 客户情况 JSONArray json = JSONArray.fromObject(map);
//打印格式样式
System.err.println( json.toString()); sendPostUrlTwo(URL, json.toString()); }
public static JSONObject sendPostUrlTwo(String url, String param) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb9caf868b3e65ee5befd048ecf8085b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b5bd72b95a21e63ce6eb3a2783e79a4/" rel="bookmark">
			activiti创建数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库
activiti创建数据库有三种方式，但是在实际开中，一般都是默认配置。 而且为了操作方便，一般activiti数据库与项目数据库都会进行分开管理。
@Override public boolean createtableByXml() { /** * 创建数据库的三种方式 * 1：指定xml * 2： 默认xml（activiti.cfg.xml） * 3:不需要xml public void createTable(){ ProcessEngineConfiguration configuration = ProcessEngineConfiguration.createStandaloneProcessEngineConfiguration(); configuration.setJdbcDriver("com.mysql.jdbc.Driver"); configuration.setJdbcUrl("jdbc:mysql://192.168.2.163:3306/activiti?createDatabaseIfNotExist=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull"); configuration.setJdbcUsername("root"); configuration.setJdbcPassword("root"); configuration.setDatabaseSchema(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE); ProcessEngine processEngine = configuration.buildProcessEngine(); } */ ProcessEngineConfiguration engineConfiguration = ProcessEngineConfiguration //1:指定xml .createProcessEngineConfigurationFromResource("gms/spring-activiti.xml"); //2:默认xml // .createProcessEngineConfigurationFromResourceDefault(); engineConfiguration.buildProcessEngine(); LOGGER.info("创建成功"); return true; } jdbc.properties driverClass=com.mysql.jdbc.Driver jdbcUrl=jdbc:mysql://192.168.2.163:3306/gmsdb?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull jdbcUrlActi=jdbc:mysql://192.168.2.163:3306/activiti?createDatabaseIfNotExist=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull username=root password=root initialSize=0 maxActive=20 maxIdle=20 minIdle=1 maxWait=60000 github地址：https://github.com/wsylp/gms.git
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5714da553f17744aef4a147a8c93fd94/" rel="bookmark">
			Cocos2d-JS 实现Map Vector
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * Map * Created by Lovell on 16/6/20. */ pg.Map = cc.Class.extend({ _elements : null }); /** * 创建Map * @returns {*} */ pg.Map.create = function () { var res = new pg.Map(); res.clear(); return res; }; /** * Map元素的长度 * @returns {*} */ pg.Map.prototype.size = function () { return this._elements.length; }; /** * 判断Map是否为空 * @returns {boolean} */ pg.Map.prototype.isEmpty = function () { return (this._elements.length &lt; 1); }; pg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5714da553f17744aef4a147a8c93fd94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d9c79f3324548e8646336d824a6e947/" rel="bookmark">
			Python strip()和split()方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. Python strip() 语法描述：
Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。
注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。
返回值：
返回值是返回移除字符串头尾指定的字符生成的新字符串
示例：
str1 = "0000000123456Awin_Ge3456700000000000" #######去除首尾字符0####### print str1.strip('0') #######去除首尾字符0####### str2 = " Awin_Ge " print str2.strip() 输出结果如下：
123456Awin_Ge34567 Awin_Ge 从结果上看，可以注意到中间部分的字符并未删除。
以上下例演示了只要头尾包含有指定字符序列中的字符就删除
str3 = "1234Awin_Ge4321" print str3.strip('123') 输出结果如下：
4Awin_Ge4 2. Python split() 语法描述：
通过指定分隔符对字符串进行分割并返回一个列表，默认分隔符为所有空字符，包括空格、换行(\n)、制表符(\t)等
返回值：
返回分割后的字符串列表
示例：
str4 = "This is string example!!!!!!!" print str4.split() print str4.split('i',1) print str4.split('!') 输出结果如下：
['This', 'is', 'string', 'example!!!!!!!'] ['Th', 's is string example!!!!!!!'] ['This is string example', '', '', '', '', '', '', ''] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93dcd48eab3af67019ef29e9612ae86e/" rel="bookmark">
			Qt中的QGraphicsScene中，删除部分图元
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 删除部分图元。在指定的矩形范围内的图元的删除。首先得到符合这个条件的图元指针列表。把这些图元移除，然后使用delete删除，释放内存。如下所示
void CenterWidget::cmd_test_slot(void) { //获得指定矩形区域内的元素的指针列表 QList&lt;QGraphicsItem *&gt; item_list_p = view-&gt;scene-&gt;items(QRectF(0,0,200,200), Qt::IntersectsItemShape); //删除元素 for(int i=0; i&lt;item_list_p.size(); i++){ view-&gt;scene-&gt;removeItem(item_list_p[i]); //从scene移除 delete item_list_p[i]; //释放内存 } }这是一个片段。这个是参考qt5的文档做的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69509ee50dc032a6fe12231e20acda8b/" rel="bookmark">
			利用docker和gitLab搭建git私有服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着Git代码管理工具的兴起，我们很多时候需要用到自己的git私有服务器，从而做到防止代码泄露等。gitLab为我们提供了一种简便的方式，使我们可以快速搭建自己的Git私有服务器
基础条件 本文主要是在一台装有ubuntu系统的服务器上安装gitLab
安装docker 此处主要参考了菜鸟教程 Ubuntu Docker 安装
查看并确定ubuntu内核版本高于3.10 uname -r使用脚本安装docker wget -qO- https://get.docker.com/ | sh安装完成之后，会提示： If you would like to use Docker as a non-root user, you should now consider adding your user to the "docker" group with something like: sudo usermod -aG docker xxx Remember that you will have to log out and back in for this to take effect! 按照提示，执行对应的命令sudo usermod -aG docker xxx即可，为docker用户赋予权限，然后重新退出登录。
启动docker服务并查看状态 sudo service docker start sudo service docker status 安装gitlab 克隆gitlab-ce
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69509ee50dc032a6fe12231e20acda8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e7d54fc05c4ec85e06e89891f0b8dd/" rel="bookmark">
			如何解除word文档的密码保护状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解除word文档保护如下：
1、进入“开始”菜单下的“编辑”菜单栏，单击“选择”按钮，发现“全选”、“选择对象”命令为灰色不可用状态；
2、进入“审阅”菜单下的“保护”菜单栏，单击“保护文档”按钮，选择“限制格式和编辑”命令；
3、文档右侧出现一个“限制格式和编辑”窗口，显示该文档处于受保护状态；
4、单击窗口下方的“停止保护”按钮，弹出对话框要求输入密码，没有密码不能解除文档保护；
5、新建一个空白文档，并关闭该文档；
6、进入“插入”菜单，单击“文本”菜单栏中的“对象“按钮，选择”“文件中的文字”命令；
7、在弹出的对话框中选择被保护的文档，单击“插入”按钮；
8、再回到“开始”菜单下的“编辑”菜单栏，单击“选择”按钮，发现“全选”、“选择对象”命令变得可用。同时按下Ctrl+A也可对文档进行全选操作。然后单击保存按钮，改名保存该文档即可，至此文档保护被解除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca928d80e5edef83c24f683c4e43e78/" rel="bookmark">
			Zabbix proxy-agent通讯机制及balanced router设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08fe743602b0c205784a9ca1fe3c561/" rel="bookmark">
			R语言将文件写入CSV，并读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 R语言将文件写入CSV，并读取 # 写入文件 write.csv(data,file = "mydata.csv",row.names = F) # 读文件 data_handle&lt;-read.table("mydata.csv",header=T, sep=",") View(data_handle) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d75db015f1a66b1ae3c45fa46f7e8135/" rel="bookmark">
			JSONObject 与 JSON 互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用目的 目前数据交互大多以 JSON 字符串为信息传输，主要格式有
{"age":"22","name":"李四"}
[{"age":"21","name":"张三"}]
最常见的应用场景是前后端对接，第三方平台文档对接，下面展示转换使用。
一、引入 jar , 此处引入 com.alibaba.fastjson 版本的jar包 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.31&lt;/version&gt; &lt;/dependency&gt; 二、建立测试类对象 class Student { private String name; private String age; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } } 三、转换 1、对象 转 JSON Student stu1 = new Student(); stu1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d75db015f1a66b1ae3c45fa46f7e8135/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c60a55ebeafbd713184b64e7eeb1a6/" rel="bookmark">
			byte数组转换成十六进制(bytesToHexString)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /* byte数组转换成十六进制输出："abcd" =&gt; "61626364" */ public String bytesToHexString(byte[] bArr) { StringBuffer sb = new StringBuffer(bArr.length); String sTmp; for (int i = 0; i &lt; bArr.length; i++) { sTmp = Integer.toHexString(0xFF &amp; bArr[i]); if (sTmp.length() &lt; 2) sb.append(0); sb.append(sTmp.toUpperCase()); } return sb.toString(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6efed512f05b262a544722db84836b7/" rel="bookmark">
			解决iframe在ios中无法滚动的bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在解决iframe在ios无法滚动的bug中，需要在iframe外面包裹一层div，如下：
&lt;div class="scroll-wrapper"&gt; &lt;iframe src=""&gt;&lt;/iframe&gt; &lt;/div&gt; 然后设置scroll-wrapper的样式，给scroll-wrapper添加-webkit-overflow-scrolling: touch;overflow-y: scroll，
让外部的div进行滚动，然后保持iframe宽高100%。
.iframeDiv{ -webkit-overflow-scrolling: touch; overflow: scroll; iframe{ width: 100%; height: 100%; } } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/434/">«</a>
	<span class="pagination__item pagination__item--current">435/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/436/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>