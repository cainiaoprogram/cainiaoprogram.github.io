<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5097e3fe82796eb338099556f3b7bffe/" rel="bookmark">
			航天员在空间站也能刷视频吗？易源俏做了相关科普吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		易源俏新鲜出炉的科普视频就紧跟时事，更新了题主你提出这个问题的科普，我也看了，航天员的确是可以在空间站刷视频的，易源俏说航天员能脸上WiFi，主要和中继卫星有关，具体是怎么个运转法，我也解释不清楚，要不您自个儿去看看易源俏的视频？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b777e6f067db0828599d5842644ad61e/" rel="bookmark">
			Redis之ZSet数据结构底层原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zset为有序自动去重的集合数据类型，其编码可以是 zipList或者 skipList
1：ziplist ziplist 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。 压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。
如果我们执行以下 ZADD 命令， 那么服务器将创建一个有序集合对象作为 price 键的值：
此处的ziplist与Hash类型中的ziplist是同一个编码。
2：skipList skiplist 编码的有序集合对象使用 zset 结构作为底层实现， 一个zset 结构同时包含一个字典和一个跳跃表：
zset 结构中的 zsl 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素：跳跃表节点的 object 属性保存了元素的成员，而跳跃表节点的 score 属性则保存了元素的分值。
skipList在Redis中的运用场景只有一个，那就是作为有序列表zset的底层实现。跳跃表可以保证增、删、查等操作时的时间复杂度为O(logN)，这个性能可以与平衡树相媲美，但实现方式上却更加简单，唯一美中不足的就是跳表占用的空间比较大，其实就是一种空间换时间的思想。
跳跃表的结构如下所示
Redis中跳表一个节点最高可以达到64层，一个跳表中最多可以存储2^64个元素。跳表中，每个节点都是一个skiplistNode，
每个跳表的节点也都会维护着一个score值，这个值在跳表中是按照从小到大的顺序排列好的。
跳表的结构定义如下所示：
header：指向跳表的头节点，通过这个指针可以直接找到表头，时间复杂度为O(1)；
tail：指向跳表的尾节点，通过这个指针可以直接找到表尾，时间复杂度为o(1)；
length：记录跳表的长度，即不包括头节点，整个跳表中有多少个元素；
level：记录当前跳表内，所有节点中层数最大的level；
3：编码转换 当有序集合对象可以同时满足以下两个条件时，对象使用 ziplist 编码：
1.有序集合保存的元素数量小于128个；
2.有序集合保存的所有元素成员的长度都小于64字节；
不能满足以上两个条件的有序集合对象将使用 skiplist 编码。
以上两个条件的上限值是可以修改的，具体请看配置文件中关于 zset-max-ziplist-entries 选项和 zset-max-ziplist-value 选项的说明。对于使用 ziplist编码的有序集合对象来说，当使用 ziplist编码所需的两个条件中的任意一个不能被满足时，程序就会执行编码转换操作，将原本储存在压缩列表里面的所有集合元素转移到zset结构里面，并将对象的编码从ziplist 改为skiplist。
4：要点总结 1：ZSet的编码可以是 ziplist 或者 skiplist。
2：ZSet对象 ziplist 或者 skiplist编码，符合条件时可发生编码转换。
3：跳跃表是ZSet的底层实现之一，除此之外它在 Redis 中没有其他应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b777e6f067db0828599d5842644ad61e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bc188c62b18bf98c2d5c6501edd7939/" rel="bookmark">
			计算机病毒是在哪里产生的,计算机病毒如何产生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是时间财富网智能客服时间君，上述问题将由我为大家进行解答。
计算机病毒产生的过程如下：
1、计算机病毒最早出现于DOS，这是一个引导阶段，引导型病毒利用软盘的启动原理工作，它们修改系统启动扇区，在计算机启动时首先取得控制权，减少系统内存，修改磁盘读写中断，影响系统工作效率，在系统存取磁盘时进行传播。
2、1989年，可执行文件型病毒出现，利用DOS系统加载执行文件的机制工作，病毒代码在系统执行文件时取得控制权，修改DOS中断，在系统调用时进行传染，并将自己附加在可执行文件中，使文件长度增加。
3、1990年，发展为复合型病毒，可感染COM和EXE文件。
4、1992年，伴随型病毒出现，它们利用DOS加载文件的优先顺序进行工作。
5、1994年，随着汇编语言的发展，实现同一功能可以用不同的方式进行完成，这些方式的组合使一段看似随机的代码产生相同的运算结果。
6、1995年，生成器变体机阶段。
7、1995年，蠕虫。
8、1996年，视窗阶段，出现于窗口化系统windows系列中。
9、1997年，因互联网出现，进入互联网即通过网络传播。
10、1997年，Java阶段，此时出现java语言进行传播和资料获取的病毒开始出现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7d630d7354a6c52280e236085a68ea8/" rel="bookmark">
			计算机网络实验（华为eNSP模拟器）——第三章 配置IP地址和网关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、修改设备名称二、配置IP地址、子网掩码、网关等等（一）PC的配置（二）路由器的配置（三）交换机的配置1、划分vlan2、查看vlan配置3、三层交换机（1） 配置接口类型（2）应用端口 三、网关通信ping命令 结语 前言 本章笔记将讲述VRP通用路由平台的简单知识，有切换视图、一些基本命令的操作等待。
一、修改设备名称 我们可以通过输入命令“sysname”或“sy”后跟设备名称，更改要修改的设备。例更改设备名称为R1，如下图：
二、配置IP地址、子网掩码、网关等等 （一）PC的配置 双击PC机，打开其基础配置，在IPv4配置选项卡中可设置IP地址、子网掩码、网关。
例设置IP地址、子网掩码、网关分别为：192.168.1.122 、255.255.255.0、192.168.1.1，如下图：
（二）路由器的配置 若要对路由器的接口进行配置，在CLI中需转到接口视图，并进入相应的接口，然后输入ip address后跟ip地址和子网掩码，之间空格隔开。例对路由器的GigabitEthernet0/0/0接口配置ip地址和子网掩码分别为：192.168.1.12、255.255.255.0。
（三）交换机的配置 1、划分vlan 交换机的配置和路由器不一样，它要通过划分一个新的虚拟局域网，也就是定义一个vlan进行封装。例在交换机LSW1中定义一个vlan20其ip地址和子网掩码分别为：192.168.1.2、24，如下图：
2、查看vlan配置 display vlan命令用来查看所有VLAN的相关信息，若不指定任何可选参数，则显示所有VLAN的基本信息，可以看到刚刚划分的vlan20，如下图：
3、三层交换机 这里讲的是三层交换机与PC机的拓扑图，实现三层交换机和PC机的连通，如下图：
打开LSW1的CLI，配置三层交换机的接口g0/0/1，进行vlan划分。
（1） 配置接口类型 在进入相应接口后，输入命令“port link-type access”，指定配置接口类型为access。
（2）应用端口 然后将相应的vlan应用到该端口上，输入命令“port default vlan”，后跟vlan名称。
三、网关通信 网关在网络层以上实现网络的互相连接，是复杂的网络互连设备，仅用于两个高层协议不同的网络互连。简单的来说网关就相当于停车取卡模型，只有相应的网关正确才能通行，或者也可以说从一个房间走向另外一个房间之间需要通过一扇门才能通过。
ping命令 ping命令是用来检测PC与输入的IP地址是否有数据通讯，以来判断网络是否连通，即在PC机的命令行中输入"ping"后跟ip地址。
例、当我们设置好路由器和PC机的ip地址如下：
设置PC机的ip地址、子网掩码、网关。
设置路由器端口g0/0/1的IP地址和子网掩码。
然后打开PC的命令行输入ping 192.168.1.254，我们发现ping通，即实现了网关通信。
交换机与PC实现网关通信也是一样，只是要划分vlan且网关地址要一致，否者无法ping通。
结语 以上就是本次计算机网络华为eNSP模拟器实验的搭建拓扑图和配置IP地址的全部内容，篇幅较长，感谢您的阅读和支持，若有表述或代码中有不当之处，望指出！您的指出和建议能给作者带来很大的动力！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aa4bb2b6cc8b27c3fd5004544209e42/" rel="bookmark">
			10.8. Redis Serializers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10.8. Serializers From the framework perspective, the data stored in Redis is only
bytes. While Redis itself supports various types, for the most part,
these refer to the way the data is stored rather than what it
represents. It is up to the user to decide whether the information
gets translated into strings or any other objects.
In Spring Data, the conversion between the user (custom) types and raw
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aa4bb2b6cc8b27c3fd5004544209e42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e382a23506aed6c78af4a131575d69d/" rel="bookmark">
			数据库并发事务会带来哪些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据库并发会带来脏读、幻读、丢弃更改、不可重复读这四个常见问题，其中：
脏读：在第一个修改事务和读取事务进行的时候，读取事务读到的数据为100，这是修改之后的数据，但是之后该事务满足一致性等特性而做了回滚操作，那么读取事务得到的结果就是脏数据了。幻读：一般是T1在某个范围内进行修改操作（增加或者删除），而T2读取该范围导致读到的数据是修改之间的了，强调范围。丢弃修改：两个写事务T1 T2同时对A=0进行递增操作，结果T2覆盖T1，导致最终结果是1 而不是2，事务被覆盖。不可重复读：T2 读取一个数据，然后T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a69903feb82e3a6e090b24c6b428fa99/" rel="bookmark">
			台式机计算机型号怎么查,电脑配置怎么查询？笔记本台式机查询电脑配置的四种方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑配置怎么查询？虽然说现在网络非常的发达，但是并不是每个人都是电脑专家，还有一些不怎么接触电脑的小白用户，对于电脑配置怎么查询并不了解。今天智能手机网就为大家带来了电脑配置查询的具体方法，一起来瞧一瞧吧。
电脑配置怎么查询？笔记本台式机查询电脑配置的四种方法
以下来分享的笔记本台式机查询电脑配置的四种方法，对于不同的电脑系统都是适用的，如win7、win8、win10系统都可以按下面步骤来操作的。
第一种电脑配置查询方法：
1、我们使用鼠标右键点击此电脑或计算机(不同的系统显示的名称不同，比如win10系统会在桌面显示“此电脑”)。然后点击”管理“(设备管理器)。如下图所示：
2、接着在设备管理器右侧就可以看到电脑全部配置的详细信息。如下图所示：
第二种电脑配置查询方法：
1、我们同时按下电脑键盘上的两个按键Win(左下侧的WIN图标键)+R，打开运行窗口，输入CMD，然后点击确定。
2、输入systeminfo按回车确定，等待一会。如下图所示：
3、等加载完成后就可以看到电脑的全部配置情况了。如下图所示：
第三种电脑配置查询方法：
1、和上面第二种方法一样，同时按下键盘快捷键Win+R，打开运行窗口，输入dxdiag按回车确定。如下图所示：
2、出现的DirectX诊断工具界面，就可以看到系统、显示、声音、输入等等的配置情况了。
第四种电脑配置查询方法：
1、这个方法虽然不是最简单的，但也是最实用最稳妥的方法了，我们在电脑上百度搜索“鲁大师”，然后安装在电脑上，运行打开，点击“硬件检测”选项，，如下图所示可以查询所有硬件的品牌与详细型号了：
鲁大师查询电脑配置
2、这种方示同时也适用于在系统中无法查看到某些硬件信息，所以借助第三方软件来查询就可以看到。是不是很方便呢？
以上就是智能手机网为大家带来的电脑配置怎么查询？笔记本台式机查询电脑配置的四种方法了，大家都了解清楚了吧，后面还有更多相关的电脑配置技巧分享给大家!
文章来源：https://www.znsjw.com/pc/1829.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c42140b072733beec026d3ea8f10b7/" rel="bookmark">
			产品成功出海的加减法则 | Google Play 开发者中文播客节目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：如图文未加载，请刷新重试
提示：如图文未加载，请刷新重试
本期简介
在 Google Play Best of 2020 盛典中，我们共同见证了多款应用和游戏的成功，亮眼的成绩背后，离不开从开发到发行环环相扣的努力。本期节目，我们邀请到字节跳动 CapCut 和祖龙娱乐 Dragon Raja 这两款产品，做客 Go global 的 Fireside Chat 环节。从剪映到 CapCut，面对国际市场该如何调整策略？龙族幻想又如何为具有庞大的文字量的游戏做好本地化？来自字节跳动 CapCut 产品和增长团队的付晓奇，和祖龙娱乐发行副总裁赵园园，为我们分享她们的出海经验。
本期嘉宾
从左至右:
赵伊江 (Google Play 中国大陆地区商业拓展负责人) 赵园园 (祖龙娱乐发行副总裁) 付晓奇 (字节跳动 CapCut 产品和增长团队)
内容概览，助您快速定位精彩片段！
00:38
面向海外市场，如何制定国际化策略
07:49
CapCut 与龙族幻想的产品定位
12:34
不同海外市场的反馈有哪些区别
18:15
CapCut 的用户留存攻略
20:47
祖龙娱乐如何解决不同机型的游戏适配问题
25:21
两款产品的未来愿景
本期相关
虚幻引擎
虚幻引擎是一款由 Epic Games 开发的游戏引擎。该引擎主要是为了开发第一人称射击游戏而设计，现在已经被成功地应用于开发: 潜行类游戏、格斗游戏、角色扮演游戏等多种不同类型的游戏。最新版本为虚幻引擎 5，预期将在 2021 年末推出。
https://www.unrealengine.com/zh-CN/unreal-engine-5
龙族幻想
《龙族幻想》是由江南《龙族》正版 IP 授权的旗舰级开放世界 RPG 手游大作。华丽逼真的多国场景，精致细腻的人物外显材质，在游戏中呈现昼夜交替、晴雨天气等丰富的环境变化，给玩家带来如同置身现实世界的真实感受。
https://dna.qq.com/web201812/main.shtml
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95c42140b072733beec026d3ea8f10b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab289784926d5e7d0284f35a5f551cd/" rel="bookmark">
			消息中间件之ActiveMQ的入门使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		消息中间件之ActiveMQ的入门使用 一、JMS入门消息中间件常见消息中间件JMS简介JMS消息传递类型 二、ActiveMQ下载与安装三、ActiveMQ入门1.引入依赖2.点对点模式消息生产者消息消费者执行测试 3.发布/订阅模式消息生产者消息消费者执行测试 四、Spring整合ActiveMQ1.spring-mq.xml配置2.发送简单文本消息生产者消费者单元测试 3.发送MapMessage类型消息生产者消费者单元测试 4.发送ObjectMessage类型消息生产者消费者指定受信任的解析包单元测试 5.使用订阅模式 五、ActiveMQ的应用消息封装对象A系统创建生产者B系统创建消费者执行测试 一、JMS入门 消息中间件 消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。对于消息中间件，常见的角色大致也就有Producer（生产者）、Consumer（消费者）
常见消息中间件 特性ActiveMQRabbitMQRocketMQKafka单机吞吐量万级，比 RocketMQ、Kafka 低一个数量级同 ActiveMQ10 万级，支撑高吞吐10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景topic 数量对吞吐量的影响topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topictopic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源时效性ms 级微秒级，这是 RabbitMQ 的一大特点，延迟最低ms 级延迟在 ms 级以内可用性高，基于主从架构实现高可用同 ActiveMQ非常高，分布式架构非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用消息可靠性有较低的概率丢失数据基本不丢经过参数优化配置，可以做到 0 丢失同 RocketMQ功能支持MQ 领域的功能极其完备基于 erlang 开发，并发能力很强，性能极好，延时很低MQ 功能较为完善，还是分布式的，扩展性好功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用 JMS简介 JMS（Java Messaging Service）是Java平台上有关面向消息中间件的技术规范，它便于消息系统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。
​ JMS定义一系列的接口规范，是一种与厂商无关的 API，用来访问消息收发系统。类似于 JDBC，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。
JMS 能够通过消息收发服务（有时称为消息中介程序或路由器）从一个 JMS 客户机向另一个 JML 客户机发送消息。消息是 JMS 中的一种类型对象，由两部分组成：报头和消息主体。报头由路由信息以及有关该消息的元数据组成。消息主体则携带着应用程序的数据或有效负载。
JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。
TextMessage：一个字符串对象 MapMessage：一套名称-值对 ObjectMessage：一个序列化的 Java 对象 BytesMessage：一个字节的数据流 StreamMessage ： Java 原始值的数据流 JMS消息传递类型 对于消息的传递有两种类型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ab289784926d5e7d0284f35a5f551cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9dc51fa852293680ac267ca4f2d2dd7/" rel="bookmark">
			基于Vue&#43;SpringCloudAlibaba微服务电商项目实战-016：构建微服务电商项目智能报警系统替代elk分布式日志收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		016：构建微服务电商项目智能报警系统替代elk分布式日志收集 1 微服务智能报警系统实现效果演示2 微服务智能报警系统设计原理3 分布式日志采集系统模块分析4 基于全局捕获异常将日志投递到MQ服务器端中5 定义MQ消费者将错误日志统一写入数据库db中6 定义微信消息推送错误日志模板接口7 分布式日志采集报警系统流程测试 1 微服务智能报警系统实现效果演示 今日课程任务
构建企业级微服务智能报警系统产生背景微服务智能报警系统与elk的区别有那些智能报警系统整体架构实现原理构建Aop拦截系统错误日志写入kafka中构建消费者获取kafka异常日志消息调用微信模板实现智能报警系统 2 微服务智能报警系统设计原理 分布式日志采集系统elk
“ELK”是三个开源项目的首字母缩写，这三个项目分别是：Elasticsearch、Logstash 和 Kibana。
Elasticsearch 是一个搜索和分析引擎。
Logstash 是服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中。
Kibana 则可以让用户在 Elasticsearch 中使用图形和图表对数据进行可视化。
传统的elk日志存在哪些缺陷？
搜索日志成本时间长，不如出现错误/异常主动上报自动报警功能的预警系统。
微服务智能报警系统设计思想
主动上报错误日志，用户调用接口如果出现错误异常的情况下，都会主动提醒给开发者。可以使用第三方可视化界面管理分析日志。 3 分布式日志采集系统模块分析 分布式日志采集系统mt_log分析思路
采用全局或者Aop捕获当前系统出现的异常，将错误的信息转换成json内容投递到MQ服务端；定义消费者获取MQ中错误的日志，将错误日志持久化到es/mongodb/数据库中；采用主动上报的形式，将错误日志以消息模板或者短信/邮件推送给开发者，减少搜索日志成本；可以采用web系统可以直接对数据库的日志实现图像报表的分析。
模块构建
mt-shop-service-log-aop --采用全局或者AOP捕获当前系统出现的异常/错误
mt-shop-service-log-mqconsumer --消费者获取MQ中错误的日志，将错误日志持久化到es/mongodb/数据库中，消费者一定要集群加速写日志
mt-shop-service-log-web --对数据库的日志实现图像报表的分析
4 基于全局捕获异常将日志投递到MQ服务器端中 全局捕获异常获取详细方法错误信息参数分析
系统打印的Exception记录包含出现异常代码的类、接口等相关信息，请求参数从HttpServletRequest中获取
分布式日志采集数据库表结构分析
数据库记录错误日志表
CREATE TABLE `mt_error_log` ( `message_id` varchar(255) NOT NULL DEFAULT '', `service_id` varchar(30) DEFAULT NULL, `class_name` varchar(255) DEFAULT NULL, `method_name` varchar(255) DEFAULT NULL, `parameter_content` varchar(255) DEFAULT NULL, `errorContent` varchar(255) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `line_number` int(11) DEFAULT NULL, `server_ip` varchar(255) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8; message_id作为主键id可以防止mq重试导致插入相同的数据，从而调用两次模板消息推送，解决MQ消费者幂等性问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9dc51fa852293680ac267ca4f2d2dd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7cfd652c100ad726d8a39b2a3b91c7f/" rel="bookmark">
			图像直方图正规化(Normalization)数学原理和纯C语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像处理入门系列文章 C语言生成RGB24格式图像纯C语言实现
图像缩放之最近邻内插法数学原理和纯C语言实现
图像直方图均衡化(Equalization)数学原理和纯C语言实现
图像直方图规定化(Specification)数学原理和纯C语言实现
图像直方图正规化(Normalization)数学原理和纯C语言实现
目录
图像处理入门系列文章
一、图像正规化数学原理
1.转化为数学问题
2.需要用到的知识
3.数学推理
二、程序实现
1.程序实现原理
2.代码实现
3.程序执行效果
4.图像正规化前后效果
总结
一、图像正规化数学原理 1.转化为数学问题 2.需要用到的知识 一维函数微积分
随机变量的概率分布
3.数学推理 ​​​​​​​
二、程序实现 1.程序实现原理 2.代码实现 代码如下（示例）：
#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #define PICT_WIDTH 90 #define PICT_HEIGHT 60 static unsigned int s_rgb[PICT_WIDTH][PICT_HEIGHT][3] = { 0 }; /** * rgb24 * r:203 g:64,173,38 b:142 */ int make_rgb24_colorbar(unsigned int rgb[90][60][3]) { int i = 0; int j = 0; unsigned char chr = 0; for (j = 0; j&lt;PICT_HEIGHT; j++) { for (i = 0; i &lt; PICT_WIDTH; i++) { if (i&lt;30) { chr = 203; } else if (i&lt;60) { chr = 64; } else { chr = 0; } rgb[i][j][0] = chr; if (i&lt;30) { chr = 0; } else if (i&lt;60) { chr = 173; } else { chr = 0; } rgb[i][j][1] = chr; if (i&lt;30) { chr = 0; } else if (i&lt;60) { chr = 38; } else { chr = 142; } rgb[i][j][2] = chr; } } return 0; } int generate_rgb24_file(unsigned int rgb[90][60][3],char *file_name) { char file_path[64] = {0}; if (file_name == NULL) { return 0; } snprintf(file_path,63,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7cfd652c100ad726d8a39b2a3b91c7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b33164c6ad4fb2c0626542451caa32d/" rel="bookmark">
			vue的属性赋值和事件绑定符号“：”和 “@”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我用vue开发有一段时间了，对vue逐渐有了一点认识。
vue里面的主角是组件。调用组件的时候，就像使用普通的HTML控件一样，需要赋一些属性或事件。比如
&lt;div&gt;&lt;Comp3 name="孙悟空" :type="type" v-bind:office="office" /&gt;&lt;/div&gt; &lt;button @click="cloud" title="听着！"&gt;一声吼！&lt;/button&gt; &lt;button v-on:click="ohNo" title="饶命"&gt;杀猪嚎！&lt;/button&gt; 这里面有些符号，比如“:”、“@”显得有些神秘莫测。在这里，“:”是“v-bind”的同义词，同样，“@”等同于“v-on”。就属性而言，如果不加冒号或v-bind，那么赋的就是值；如果加了冒号或v-bind，赋的就是变量。示例如下：
组件Comp3.vue
&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;span&gt;姓名：&lt;/span&gt;&lt;span&gt;{{name}}&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;出身：&lt;/span&gt;&lt;span&gt;{{type}}&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;官职：&lt;/span&gt;&lt;span&gt;{{office}}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { name:'', type:'', office:'' } } &lt;/script&gt; 调用组件Comp3的页面
&lt;template&gt; &lt;div&gt; &lt;div&gt;&lt;Comp3 name="孙悟空" :type="type" v-bind:office="office" /&gt;&lt;/div&gt; &lt;div&gt; &lt;button @click="cloud" title="听着！"&gt;一声吼！&lt;/button&gt; &lt;button v-on:click="ohNo" title="饶命"&gt;杀猪嚎！&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Comp3 from './Comp3.vue' export default{ components:{ Comp3 }, data(){ return { type:'石猴', office:'弼马温' } }, methods:{ cloud(){ alert("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b33164c6ad4fb2c0626542451caa32d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71100242e0260849c5681649d184396d/" rel="bookmark">
			学生工作给我的大学生活带来了什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 宣传工作需要注意的点 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e5cd1a332608d263d69897cec5116a5/" rel="bookmark">
			SLC、MLC、TLC和QLC这几种存储颗粒的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		存储单元是硬盘的核心元件，选择SSD实际上就是在选择存储颗粒。下面介绍下SLC、MLC、TLC和QLC这几种存储颗粒的区别。
由于NAND闪存颗粒中存储密度存在差异，所以NAND闪存又分为SLC、MLC、TLC和QLC。QLC容量大，但性能也变差了。NAND闪存是一种非易失性存储技术，即断电后仍能保存数据。它的发展目标就是降低每比特存储成本、提高存储容量。
SLC：每个Cell单元存储1bit信息，也就是只有0、1两种电压变化，结构简单，电压控制也快速，反映出来的特点就是寿命长，性能强，P/E寿命在1万到10万次之间，但缺点就是容量低而成本高，毕竟一个Cell单元只能存储1bit信息。
什么是P/E寿命？ 完整的一次P/E循环就是NAND的写入循环，SSD要想写入数据就需要恢复默认电位，也就是以“擦除”为前提。
比如硬盘容量120g那么擦写120g一次就是一个pe 能写多少次120g就是几个pe
MLC：每个cell单元存储2bit信息，需要更复杂的电压控制，有00,01,10,11四种变化，这也意味着写入性能、可靠性能降低了。其P/E寿命根据不同制程在3000-5000次不等。
TLC：每个cell单元存储3bit信息，电压从000到001有8种变化，容量比MLC再次增加1/3，成本更低，但是架构更复杂，P/E编程时间长，写入速度慢，P/E寿命也降至1000-3000次，部分情况会更低。寿命短只是相对而言的，通常来讲，经过重度测试的TLC颗粒正常使用5年以上是没有问题的。
QLC或者可以叫4bit MLC，电压有16种变化，但是容量能增加33%，就是写入性能、P/E寿命与TLC相比会进一步降低。具体的性能测试上，美光有做过实验。读取速度方面，SATA接口中的二者都可以达到540MB/S，QLC表现差在写入速度上，因为其P/E编程时间就比MLC、TLC更长，速度更慢，连续写入速度从520MB/s降至360MB/s，随机性能更是从9500 IOPS降至5000 IOPS，损失将近一半。
举个例子：我们假设1bit的数据是一辆小汽车，那NAND闪存就是几种不同类型的停车场。
SLC闪存的停车场一次只能停一辆车，这辆车来去自如，效率很高，也不容易出现错误，但由于停车场的使用效率不高，所以寿命长，成本相对较高。
MLC一次可以停放两辆车，这就需要调度，速度就会稍慢，但空间使用率提高了，所以寿命也会变短一点。
TLC属于三辆车可以同时停在同一个停车场，车辆进出的调度也就更复杂，速度稍慢，容易出现错误。因为多次使用，寿命就更短。QLC是一次可以停放4辆车，同理，能停放的车辆多了，成本自然是降下来了，不过寿命也会相应减短。
虽然可靠性会有降低，但是随着NAND技术的进步，P/E寿命是会提升的，之前TLC已经得到验证，相信QLC也会如此。所以QLC若是大规模量产，那SSD的写入速度将可达到200-300MB/s左右，而且5000+的随机写入性能依然高于HDD硬盘，容量也可达到10-100TB的数量级。
————————————————
本文参照以下文章改写
原文链接：https://blog.csdn.net/shicifang/article/details/87879972
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22e042262ddcd2f6e5226c3615fd1370/" rel="bookmark">
			解决TOMCAT乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开tomcat文件夹找到conf文件夹，找到logging.properties文件，打开 如图所示，红圈圈出部分，之前部分是UTF-8，现在改为GBK就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e2c909f6c796eafd9c6c67381c68f98/" rel="bookmark">
			spring集成flyway
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近给公司项目集成flyway，由于我们sql教程项目移动端使用的是spring框架，网上看了很多博客，感觉这方面的东西还是很少的，毕竟java基础教程现在是springboot的天下，大多数都是springboot集成flyway。但是python基础教程还是有不少公司遗留有spring框架的项目。这里就自己肝一篇，希望能帮到更c#教程多想把flyway添加到spring项目中的人。
由于使用的是spring框架。因此vb.net教程我们选择低版本的flyway。
flyway各个版本请到这里去找：https://mvnrepository.com/artifact/org.flywaydb/flyway-core
我们的maven使用的是阿里云的仓库，阿里云仓库中没有低版本的依赖，我们我们需要下载jar包。这里下载的是3.0版本的jar包。
下载的包需要拷贝到项目webapp/WEB-INF/lib中(web项目都会有WEB-INF这个文件夹，只需要找到你项目中web文件夹就行，web文件夹，就是文件夹上有个蓝点的，具体看下图的webapp文件夹)
新建资源目录resources
在其下面建立db/migration（sql文件默认读取此路径下的文件夹中的.sql文件）
在pom.xml中添加，如果不添加，resources中的文件就无法打包到war包中。
&lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; 添加flyway配置类，更多配置请看源代码
package com.dt.flyway; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import org.flywaydb.core.Flyway; import org.flywaydb.core.api.FlywayException; import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NamingException; import javax.sql.DataSource; /** * @Description: flyway配置类 * @author: * @Date: 2021/7/12 15:57 * @Copyright: Xi'an Dian Tong Software Co., Ltd. All Rights Reserved. * @Version 1.0 */ public class DatabaseFlywayMigration { protected final static Logger log = LogManager.getLogger("DatabaseFlywayMigration"); public void migrate() throws NamingException { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e2c909f6c796eafd9c6c67381c68f98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2c904f61b06cad0bc4ae364a192e343/" rel="bookmark">
			进程和内存关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动一个进程时候，首先调用fork，申请内存用于存储页表项，然后该页表项赋值父进程的页表项，一个进程需要的页表项空间：64M/4M*4K=64K，64个进程全部启动需要的页表空间：64K*64=4M。16M（全部物理内存）-4M（高速缓存+内核）-4M（页表项）=8M，还剩8M用于程序。
进程启动后有写操作就会调用写时赋值，写时赋值就会申请一页物理内容，如果需要硬盘的数据，还会把硬盘的数据通过文件管理读到高速缓存中，然后同步到该申请的内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fedb699e072edb799cf2339eee1eb483/" rel="bookmark">
			CPU与GPU的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.不同之处：
CPU和GPU之所以大不相同，是由于其设计目标的不同，它们分别针对了两种不同的应用场景。CPU需要很强的通用性来处理各种不同的数据类型，同时又要逻辑判断又会引入大量的分支跳转和中断的处理。这些都使得CPU的内部结构异常复杂。而GPU面对的则是类型高度统一的、相互无依赖的大规模数据和不需要被打断的纯净的计算环境。
链接: link.
2.各自擅长的运算
CPU擅长逻辑控制，串行的运算。和通用类型数据运算不同，GPU擅长的是大规模并发计算，这也正是密码破解等所需要的。
3.什么类型的运算适合在GPU上运行？
（1）计算密集型的程序。
所谓计算密集型(Compute-intensive)的程序，就是其大部分运行时间花在了寄存器运算上，寄存器的速度和处理器的速度相当，从寄存器读写数据几乎没有延时。
（2）易于并行的程序。
GPU其实是一种SIMD(Single Instruction Multiple Data)架构， 他有成百上千个核，每一个核在同一时间最好能做同样的事情。
4.有趣的比喻
第一个
CPU 力气大啥P事都能干，还要协调。GPU
CPU小弟，老大让他处理图形，这方面处理简单，但是量大，老大虽然能处理，可是老大只有那么几个兄弟，所以不如交给小弟处理了，小弟兄弟多，有数百至数千个，而且是专门只干这行和只能干这行。 第二个
当你操作电脑的时候，为了完成某项工作，需要电脑帮你工作，就像计算某个题目那样。计算题目，理解题目并且整理出解题的步骤以及解法，那是CPU的事情。解题的过程需要用到的众多计算，则需要一帮不需要很高逻辑理解力的计算者完成，他们只需要负责其中很简单但是数量又很大的简单运算。最后他们把各自运算的结果交出来给CPU整理，那么这群计算者就是GPU。一个博士带着100个小学生的意思。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c5ddca8a3f8e3339d09a82247e9b363/" rel="bookmark">
			binance API常见问题解决方案error_code
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{‘code’: -1021, ‘msg’: “Timestamp for this request was 1000ms ahead of the server’s time.”}
修改系统时间
{‘code’: -4061, ‘msg’: “Order’s position side does not match user’s setting.”}
单向持仓确认
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac5c0128ee574ba3d66148f903301fcb/" rel="bookmark">
			必修二英语计算机课文翻译,教科版（2019）高中信息技术必修二  2.1 计算机系统的组成...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料简介
2.1 计算机系统的组成
【学习目标】
知道计算机系统的主要组成部分，能够描述基本工作原理。
了解计算机硬件系统的基本组成，认识其主要的性能指标。
了解计算机软件系统的分类，能区分各类软件的主要功能。
【学习重点】信息系统的基本功能与分类。
【学习难点】事务处理系统及管理信息系统的工作原理。
【学习过程】
一、问题引入 (复习回顾初中学习内容)
思考： 1 、生活中常见的计算机系统有哪些？
2 、一台计算机由许多零部件组成的。完整的计算机系统由哪些部分组成的呢？
二、计算机系统的组成
完整的计算机系统由 硬件系统 和 软件系统 组成。硬件系统由输入设备、运算
器、控制器、存储器和输出设备组成；软件系统由系统软件和应用软件组成。
用图示概括为：
任务一：探索计算机系统的硬件组成
活动一：匹配数据数型与输入输出设备
活动二：比较内部存储器和外部存储器
活动三：调查中央处理器( CPU )的性能指标
学生分组在 3 个活动中挑选一个完成下表。表
一：
( 计算机输入、输出设备对照表 )
表二：
指标 内存 U 盘 硬盘 移动硬盘
设备型号
存储容量
存取速度
价格(元)
数据类型 输入设备 输出设备
文本数据
音频数据
视频数据
图形图像数据
(比较内部存储器和外部存储器)
分析：内存与外存的特点对比？
性能指标 含义 主流 CPU 的性能指标
参数值举例
表三：
(调查中央处理器( CPU )的性能指标)
任务二：体验计算机系统的软件组成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac5c0128ee574ba3d66148f903301fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f24240d5dc6b36a05bce8883d1098d9/" rel="bookmark">
			MySQL---join驱动表的选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 join关键字IndexNested-Loop JoinBlock Nested-Loop Join小表的概念总结： join关键字 当业务需要从多个数据表中读取数据时，可以使用SQL语句中的连接（JOIN），在两个或多个数据表中查询数据。
JOIN 按照功能可分为三类：
INNER JOIN（内连接，或等值连接）：获取两个表中字段匹配关系的记录；LEFT JOIN（左连接）：获取左表中的所有记录，即使在右表没有对应匹配的记录；RIGHT JOIN（右连接）：与 LEFT JOIN 相反，用于获取右表中的所有记录，即使左表没有对应匹配的记录。 但是当有多张表的时候，驱动表该如何选择？
首先建一张表用来演示。
CREATE TABLE `t2` ( `id` int(11) NOTNULL, `a` int(11) DEFAULTNULL, `b` int(11) DEFAULTNULL, PRIMARY KEY (`id`), KEY `a` (`a`) ) ENGINE=InnoDB; CREATE TABLE `t1` LIKE `t2`; 假设插入的数据是一一对应的以方面计算。 提示：文中用到的straight_join完全等同于inner join，但是从左到右实现强制多表的载入顺序，不同于inner join会进行优化。
IndexNested-Loop Join 对于SQLselect * from t1 straight_join t2 on (t1.a=t2.a)；有以下执行流程：
从表t1中读入一行数据 R；从数据行R中，取出a字段到表t2里去查找；取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；重复执行步骤1到3，直到表t1的末尾循环结束。 我们称之为IndexNested-Loop Join算法，简称NLJ。
在这个流程里：
对驱动表t1做了全表扫描，这个过程需要扫描N行；对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描M行；所以整个执行流程，总扫描行数是N+M。 假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每次搜索一棵树近似复杂度是以2为底的M的对数，记为log2M，所以在被驱动表上查一行的时间复杂度是 2*log2M。
当驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次。因此整个执行过程，近似复杂度是 N+N2log M，很明显N对扫描行数的影响更大，因此应该让小表来做驱动表。（N扩大1000倍的话，扫描行数就会扩大1000倍；而M扩大1000倍，扫描行数扩大不到10倍。）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f24240d5dc6b36a05bce8883d1098d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a769f699c6b2e30a9b210b6b57cc20a/" rel="bookmark">
			JS数组转字符串（3种方法）和字符串转数组（2种）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：数组转字符串（3种方法） 同样是数组转字符串，toString()，toLocaleString()，join()，join(’,’)的区别是什么？
JavaScript 允许数组与字符串之间相互转换。其中 Array 方法对象定义了 3 个方法，可以把数组转换为字符串，如表所示。
数组方法说明toString()将数组转换成一个字符串toLocaleString()把数组转换成本地约定的字符串join()将数组元素连接起来以构建一个字符串 1：join()方法用于把数组中的所有元素放入一个字符串 元素是通过指定的分隔符进行分隔的
join()指定的分隔符说明join()可理解为直接变成字符串，默认逗号分隔join(’ '）空连接join(’ ，’)或者 join(’ - ‘)或者 join(’ 。’)中间这个逗号是手动添加的，也可以改成别的比如、。! -等等都可以 // join() var a= ["00", "01", "02", "03", "04"] var b= a.join() console.log(b) console.log( typeof b) //打印结果 00,01,02,03,04 // join('') var a= ["00", "01", "02", "03", "04"] var b= a.join('') console.log(b) console.log( typeof b) //打印结果 0001020304 // join(',') var a= ["00", "01", "02", "03", "04"] var b= a.join(',') console.log(b) console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a769f699c6b2e30a9b210b6b57cc20a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26014c0ee5cd5dfd85541ea801fd058e/" rel="bookmark">
			异常和异常的处理方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常 1 概述 异常是一些用来封装错误信息的对象
它由异常的类型、提示信息、报错的行号提示三部分组成
2 异常的继承结构 3 异常的处理方式 当程序中遇到了异常,通常有两种处理方式:捕获或者向上抛出
当一个方法抛出异常,调用位置可以不做处理继续向上抛出,也可以捕获处理异常
大家可以结合生活中的例子:如果工作中遇到了问题,我们可以选择自己处理(捕获),或者交给上级处理
捕获方式：
try-catch可以嵌套，多种异常类型需要分别处理 * 可以不嵌套，给出通用的解决方案，不需要特殊处理， * 将所有的异常的子类类型统一看做父类Exception来处理， * 提供通用的解决方案，这是多态的最为经典的一种用法 抛出方式：
对于不想现在处理或者处理不了的异常可以选择向上抛出
方式：在方法上设置异常的抛出管道，即：
在可能会会发生异常的方法上添加代码：
throws 异常类型
例如：void method1 throws Exception1,Exception2,Exception3{ }
TIPS:方法上有默认的异常管道：RuntimeException
4 练习：异常测试 创建包: cn.tedu.exception
创建类: ExceptionDemo.java
package cn.tedu.exception; import javax.jws.soap.SOAPBinding; import java.util.Scanner; public class ReviewException { public static void main(String[] args) { f1(); f2(); // f3(); } private static void f3() throws Exception{ System.out.println("请输入您要计算的第一个整数"); int a=new Scanner(System.in).nextInt(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26014c0ee5cd5dfd85541ea801fd058e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/959511899450b6b32186abc55dd64b84/" rel="bookmark">
			移植open BMC到ARM处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在移植oepn BMC到一颗ARM处理器，困难重重，主要遇到的问题有：
1、该 ARM处理器官方SDK使用的linux内核版本为4.9.170，而open BMC使用的内核版本为linux-4.18.16。两者相差巨大，不知道oepn BMC的内核是否能在ARM处理器上跑起来。
2、open BMC支持很多处理器，比较树莓派（meta-raspberrypi），我的初步思路是，参照树莓派的代码，移植一份用以支持该ARM处理器，不知道是否行得通。
3、UBOOT版本也不一样，不知道该谁移植到谁。
在接下来的几个月中，我的大部分工作将与open BMC打交道，有哪位仁兄也在移植吗？是否遇到了问题？欢迎加入QQ群319563978一起探讨。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f032141d203893aad63d7868b38506b/" rel="bookmark">
			fuzz测试libmodbus | AFL篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 下载编译libmodbus安装Preeny库为什么需要Preeny安装Preeny的前置条件编译安装 创建测试程序与样例编译测试程序生成测试用例 开始测试关于测试用例测试过程 测试结果过程图表覆盖率分析编译副本启动afl-cov实时分析遇到错误结束测试 下载编译libmodbus 首先在github上下载libmodbus库的源码
git clone https://github.com/stephane/libmodbus/ 下载好之后进入到文件夹中，在编译过程中选择使用afl-gcc而不是默认的gcc
cd libmodbus/ ./autogen.sh CC=afl-gcc CXX=afl-g++ ./configure --enable-static make -j8 这里在我第一次运行./autogen.sh时，报错提示autoreconf not found
查了一下README里面提示说需要autoconf和libtool，新装的虚拟机上好像没安装，装上之后问题就解决了，正常情况下运行autogen.sh后会有如下提示，最后会告诉你可以运行./configure了
另外注意在./configure之前一定要更改环境变量的CC和CXX为afl的编译器，以便对libmodbus进行插桩。
如果过程顺利，最终会看到如下图所示的界面，很多afl插桩提示
安装Preeny库 为什么需要Preeny Modbus协议依托socket实现进程间的通信，而AFL本身并未提供对socket通信的支持。使用AFL对其进行fuzzing时，需要将其输入输出重定向stdio中。纵然可以修改部分代码使其socket通信转移到stdio，但这一过程可能会对fuzz的结果造成影响，同时工作量可能也较为繁杂。若是直接修改系统的socket.h，可能会对其他的程序造成难以估量的影响。
而Preeny提供了一系列有趣的模块，其中就包括了一个可以将socket通信重定向至console的desock模块。这个模块，原本的socket函数实现
安装Preeny的前置条件 在Preeny的README中，明确提示了preeny需要使用libini_config来实现相关功能，在安装preeny之前需要先装好，否则在make时会报错。
此外，在编译过程中还需要用到seccomp/h头文件，需要安装libseccomp
sudo apt-get install libseccomp-dev -y 编译安装 在满足了上述前置条件后，直接到preeny目录下make即可自动完成编译，编译过程中可能会有些warning，不影响正常功能。
安装成功后，可以在preeny目录下的src/中找到desock.so，可以通过一个简单的测试小程序确认desock模块是否正确工作
#include &lt;sys/socket.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; int main() { int sock; char send_buf[] = "hello, world! \n"; char recv_buf[100] = {'\0'}; sock = socket(AF_INET, SOCK_STREAM, 0); send(sock, send_buf, strlen(send_buf), 0); recv(sock, recv_buf, 100, 0); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f032141d203893aad63d7868b38506b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4238ee180b842ab461f0c7dfbf703a0b/" rel="bookmark">
			联想计算机电源风扇怎样清理,电脑风扇怎么拆开清洗_电脑风扇的三根线的作用...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述
电脑风扇怎么拆开清洗
笔记本电脑在不断的使用后，风扇及出风口会积累很多灰尘，影响笔记本散热及电脑的稳定性。 下面以联想G470笔记本为例，介绍下如何拆卸及清理风扇。
1.首先拿掉笔记本电池(外接电源也要断开)，再卸掉风扇外部外壳上的螺丝。如图所示
2.螺丝卸完后，打开后盖就可以看到散热风扇了以及CPU散热铜管。按图圆圈所示，卸载掉螺丝并且拔掉风扇与主板连接的电源线。
3.然后取出风扇，在卸载风扇上面的螺丝，打开盖子并清理扇片上的灰尘。
4.接着取出CPU散热铜管，清洗铜管末端处出风口。
5.全部清理完成后，最后在CPU及主反芯片上面涂抹一层薄薄的硅胶。
至此全部清理结束。
电脑风扇的三根线的作用
电脑cpu风扇有红、黑、黄(或绿等颜色)三根线。
一般情况下，红色为风扇供电的正极，黑色为供电的负极，即“红正黑负”，另外一根颜色线为风扇转速的检测控制线，作用是根据CPU温度随时调整风扇转速，从而达到理想的散热效果。
为了更科学地确定三根线的定义，我们可以借助万用表进行测量，方法如下：
1、将万用表旋钮打到电阻档
2、黑表笔或红表笔连接1点，另外一根表笔分别接触2点和3点。如果其中一个点与1点形成通路，即电阻为零或有一定阻值，那么可以确定1点的连接线和此点的连接线均为电源线。
如果1点与另外两点均为断路，即电阻值为无穷大，说明1点为信号线，另外两条为电源线。
精彩阅读推荐：
打开APP阅读更多精彩内容
点击阅读全文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/039d89062318c993f734de7e61223b81/" rel="bookmark">
			[selenium] 键盘按键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 键盘按键 模拟全选，删除
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;键盘输入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input name="username" value="username"&gt; &lt;/body&gt; &lt;/html&gt; 保存为keyboard_input.html
#!/usr/bin/env python # coding: utf8 import os.path import time from selenium import webdriver from selenium.webdriver.common.keys import Keys file_path = "file:///" + os.path.abspath("keyborad_input.html") driver = webdriver.Chrome() driver.get(file_path) username_input = driver.find_element_by_css_selector("input[name='username']") # 如果是windows 要把 Keys.COMMAND 替换为 Keys.CONTROL username_input.send_keys(Keys.COMMAND, 'a') time.sleep(0.5) username_input.send_keys(Keys.BACKSPACE) for letter in "username": username_input.send_keys(letter) time.sleep(0.2) time.sleep(2) driver.quit() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/808d6ce4b3eeb2c323ddde084f30f461/" rel="bookmark">
			[selenium] 浏览器滚动条滚动到指定位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 浏览器滚动条滚动到指定位置 利用driver.execute_script()来实现浏览器滚动条滚动
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;scroll&lt;/title&gt; &lt;style type="text/css"&gt; .box { height: 10000px; width: 200px; background-color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 保存为scroll.html
#!/usr/bin/env python # coding: utf8 import os.path import time from selenium import webdriver file_path = "file:///" + os.path.abspath("scroll.html") driver = webdriver.Chrome() driver.get(file_path) time.sleep(2) js = "document.documentElement.scrollTop = 10000" driver.execute_script(js) time.sleep(2) js = "document.documentElement.scrollTop = 0" time.sleep(2) driver.quit() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5645e0bfaa21747bc3c7cc8f0b51b3d6/" rel="bookmark">
			[selenium] 关闭 alert 弹框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关闭 alert 弹框 当弹出 alert 框时，可以运用driver.switch_to.alert.accept()来关闭
代码如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick="alert('hehe')"&gt;alert&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 将上述代码保存为alert.html
#!/usr/bin/env python # coding: utf8 import os.path import time from selenium import webdriver file_path = "file:///" + os.path.abspath("alert.html") driver = webdriver.Chrome() driver.get(file_path) button = driver.find_element_by_tag_name("button") button.click() time.sleep(2) driver.switch_to.alert.accept() time.sleep(2) driver.quit() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa0a0a1e66c145f6507bd6f875afcec/" rel="bookmark">
			HashMap底层实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.HashMap底层实现原理解析 1.常见的数据结构有三种： 1.数组结构： 存储区间连续、内存占用严重、空间复杂度大。
优点： 随机读取和修改率高，原因是数组是连续的（随机访问性强，查找速度快）
缺点： 插入和删除效率低，因插入数据，这个位置后面的数据在内存中都要往后移动，且大小不易动态扩展
2.链表结构： 存储区间离散、占用内存宽松、空间复杂度小。
优点： 插入删除速度快，内存利用率高，没有固定大小，扩展灵活
缺点： 不能随机查找，每次都是从第一个开始遍历（查询效率低）
3.哈希表结构： 结合数据结构和链表结构的优点，从而实现了查询和修改效率高，插入和删除效率也高的一种数据结构。
2.HashMap中的put()和get()的实现原理 1.map.put(k,v)实现原理
（1）首先将k,v封装到Node对象中（节点）。
（2）然后它的底层会调用K的hashCode（）方法得出hash值。
（3）通过哈希表函数/哈希算法，将hash值转换成数组的下标，下标的位置上如果没有任何元素，就把Node添加到这个位置上。如果说下表对应的位置上有链表。此时，就会拿着k和链表上每个节点的k进行equal。如果所有的equals方法返回了false，那么这个新的节点将被添加到链表上每个节点的末尾。如其中一个equals方法返回了true，那么这个节点的value将会被覆盖。
2.map.get(k,v)实现原理
（1）先调用K的hashCode（）方法得出哈希值，并通过哈希算法转换成数组下标。
（2）通过上一步哈希算法转换成数组的下标之后，在通过数组下标快速定位到某个位置上。如果这个位置上什么都没有，则返回null。如果这个位置上有单向链表，那么它就会拿着K和单向链表上的每个节点的K进行equals，如果所有equals方法都返回false，则get方法返回null。如果其中一个节点的K和参数K进行equals返回true，那么此时节点的value就是我们要找到的value了，get方法最终返回这个找到的value。
为什么随机增删、查询效率都很高的原因是？
原因： 增删是在链表上完成的，而查询只需要扫描部分，则效率高。
问什么放在hashMap集合key部分的元素需要重写equals方法？
原因： 因为equals方法默认比较的是两个对象的内存地址
二、HashMap红黑树原理分析 相比jdk1.7的HashMap而言，jdk1.8最重要的就是引入了红黑树的设计，当hash表的单一链表长度超过8个的时候，链表结构就会转为红黑树结构。这样设计的好处是避免在最极端的情况下链表变得特别长，在查询的时候，效率变得很慢。
JDK1.7如图：
JDK1.8如图:
红黑树查询： 其访问性能近似于折半查找，时间复杂度O（logn）
链表查询： 在这种情况下，需要遍历全部元素才行，时间复杂度O（n）
简单来说，红黑树是一种近似于平衡的二叉查找树，其主要的优点就是“平衡”，即左右子树高度几乎一致，以此来防止树退化为链表，通过这种方式来保障查找时间复杂度为log(n)。
红黑树主要特性：
（1）每个节点要么都是红色，要么是黑色，但根节点永远是黑色；
（2）每个红色节点的两个子节点一定是黑色；
（3）红色节点不能连续（也就是红色节点的孩子和父亲都不能是红色）；
（4）从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；
（5）所有的叶节点都是黑色的；
在书的结构发生改变时，往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的条件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4af7bfb0d0a0f637ef49af23cf60c3b3/" rel="bookmark">
			医疗图像配准综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：https://zhuanlan.zhihu.com/p/80985475 侵删
Image registration 图像配准 图像配准与相关[1]是图像处理研究领域中的一个典型问题和技术难点，其目的在于比较或融合针对同一对象在不同条件下获取的图像，例如图像会来自不同的采集设备，取自不同的时间，不同的拍摄视角等等，有时也需要用到针对不同对象的图像配准问题。
具体地说，对于一组图像数据集中的两幅图像，通过寻找一种空间变换把一幅图像（浮动图像，moving image）映射到另一幅图像（参考图像，fixed image）上，使得两图中对应于空间同一位置的点一一对应起来，从而达到信息融合的目的。
图像配准常为图像融合的一个预处理步骤。经过精确图像配准的图像对，通常可获得更好的融合效果。
一、定义 图像配准是使用某种算法，基于某种评估标准，将一副或多副图片（局部）最优映射到目标图片上的方法。
根据不同配准方法，不同评判标准和不同图片类型，有不同类型的图像配准方法。
（详见“问题分类”部分）
二、问题背景和应用 图像配准在计算机视觉、医学图像处理、材料力学、遥感等领域有广泛应用。
由于可应用图像配准的图像类型众多，暂时无法开发出可满足所有用途的通用优化方法。
图像配准在医学图像处理与分析中有众多具有实用价值的应用。随着医学成像设备的进步，对于同一患者，可以采集含有准确解剖信息的图像诸如CT，MRI；同时，也可以采集到含有功能信息的图像诸如SPECT。然而，通过观察不同的图像进行诊断需要凭着空间想象和医生的主观经验。采用正确的图像配准方法则可以将多种多样的信息准确地融合到同一图像中，使医生更方便更精确地从各个角度观察病灶和结构。同时，通过对不同时刻采集的动态图像的配准，可以定量分析病灶和器官的变化情况，使得医疗诊断、制定手术计划、放射治疗计划更准确可靠。
在计算机视觉领域里，配准方法可被用来进行视频分析、模式识别，自动跟踪对象的运动变化。
在材料力学方面，配准通常用来研究力学性质，称为数字图像相关。通过对不同相机不同传感器采集到的信息（形状，温度等）进行融合比较，可以计算得到例如应变场、温度场等数值。通过带入理论模型可以进行参数反向优化等。
三、相关关键词 相近词：
image registration (mapping matching, co-registration alignment, fusion)
注：mapping 侧重于空间映射，fusion为图像融合，不仅包括配准还包括数据集成后的图像显示。 相近领域：
图像融合，图像拼接，图像分割，超分辨率，图配准，点云配准，SLAM
使用方法：
相似性测度，配准精度，配准算法，小波变换，互信息，仿射变换，特征提取，特征点匹配，相位相关，角点检测，边缘检测，旋转角度，相位相关，遗传算法，深度学习
应用领域：
医学图像，遥感图像，天气预测，地理信息系统，超分辨率，运动追踪，自动控制
四、问题分类 图像配准分类标准不唯一，下面两图是某位研究者[2]的分类结果（2014年）。
本人的分类结果见下图
基于问题特点的分类
1.Registration Quality: 配准性质
根据数据或特征确定的配准类型。
如自然图像配准，医学图像配准，遥感图像配准等。
2.图像采集方式
①Multi-view Analysis: 多视图配准
同一物体在同一场景不同视角下的图像配准。
从多个视角捕获相似对象或场景的图像，以便获得扫描对象或场景的更好表示。如使用图像拼接，从2D图像重建3D模型等。
②Multi-temporal Analysis: 多时相配准
同一物体在同一场景同视角不同时间的图像配准。如运动追踪，肿瘤生长情况跟踪等。
③Multi-modal Analysis: 多模态配准
多模配准常见于医学图像领域，故以多模医学图像配准为例。
由于医学成像设备可以提供关于患者不同信息不同形式的图像（计算机断层扫描CT，核磁共振MRI，正电子发射断层成像PET，功能核磁共振fMRI等）。
基于单种或多种模态图像的配准，可划分为单模态（Single-modality）和多模态（Multi-modality）。
Figure 1 MEG-MRI多模态配准
3. Interaction: 配准流程互动性
手动，半自动或自动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4af7bfb0d0a0f637ef49af23cf60c3b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0641b8596a35c2bc0ee704c37a2e912/" rel="bookmark">
			邻域，左邻域，右邻域，去心邻域，左空心邻域，右空心邻域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		邻域，左邻域，右邻域，去心邻域，左空心邻域，右空心邻域
δ 读作 /'deltə/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a6be6ac93057653a88959c41dad95ac/" rel="bookmark">
			从渗透的角度分析正向代理和反向代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正向代理服务器一般配置要求低，主要充当流量转发
如搭建vps服务器，隐藏攻击者ip，上公共网等
反向代理服务器一般配置要求高，主要充当数据处理
如肉鸡充当服务器或cdn（内容分发网络），搭建钓鱼网站，托管攻击工具与代码等
正向代理是攻击者通过代理服务器去连接公网ip；反向代理是控制或诱骗公网ip去连接攻击者服务器。
但最终起到的作用是都可以隐藏攻击者真实ip。这是最终目的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de42af9efc178784eba35a24004e9bb2/" rel="bookmark">
			安装framework 3.5出现0x800F0922的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装framework 3.5出现0x800F0922的解决方法
参考文章：
（1）安装framework 3.5出现0x800F0922的解决方法
（2）https://www.cnblogs.com/simadi/p/4884755.html
（3）https://www.codeprj.com/blog/4a89131.html
备忘一下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e29199d3604eacb497e5498a00efae0/" rel="bookmark">
			机器学习:lightGBM算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lightGBM是基于GBDT的一个算法。因为传统的GBDT在每一次迭代时需要多次遍历整个训练数据，所以GBDT的训练会受内存等的限制。尤其在处理工业级海量数据的数据时，GBDT不能满足其需求。而lightGBM支持高效率的并行训练，并且具有更快的迭代速度，更低的内存消耗、更好的准确率，支持分布式可以快速处理海量数据。lightGBM的优缺点主要如下：
1.优点 XGBoost也是GBDT框架下的一个算法。相对于XGBoost, lightGBM的优点主要集中在内存和速度两个方面。
lightGBM采用基于直方图的决策树算法，该算法将遍历样本转化为遍历直方图。既降低了内存使用率又可以利用直方图做差的方式降低计算复杂度；而XGBoost采用的是基于预排序的决策树算法，不仅需要额外的空间保存特征排序结果，而且需要遍历每一个分割点计算分裂增益，计算代价大。ligthGBM算法在训练过程中采用单边梯度算法(GOSS)过滤掉梯度小的样本，减少了大量的计算。GOSS先将要进行分裂的特征的所有绝对值大小进行降序排序，选取绝对值最大的 a × 100 % a\times 100\% a×100%个数据，然后在剩下的较小梯度数据中随机选择 b × 100 % b\times 100\% b×100%个数据。接着将这 b × 100 % b\times 100\% b×100%个数据乘以一个常数 1 − a b \frac{1-a}{b} b1−a​，这样算法既可以更关注训练不足的样本，又不用担心会改变原数据集的分布。lightGBM采用了leaf-wise算法的增长策略构建树，减少了很多不必要的计算。XGBoost采用按层(level-wise)生长策略，该策略遍历一次数据可以同时分裂同一层的叶子，虽然这样方便进行多线程优化，控制模型复杂度并且不容易过拟合，但这种策略不加区分低对待同一层的叶子，非常低效。而lightGBM采用的leaf-wise算法每次只对当前分裂增益最大的叶子结点进行分裂。这种方法很容易长出比较深的树从而导致过拟合，所以一般会在树的最大深度上加一个限制。lightGBM采用优化后的特征并行、数据并行方法加速计算，当数据量非常大的时候还可以采用投票并行的策略。lightGBM对缓存进行了优化，增加了缓存命中率。lightGBM算法在训练过程可以将两两互斥或冲突率低的特征捆绑成一个特征进行处理，减少了特征数量，降低了内存消耗(使用图着色原理选择要捆绑在一起的特征)。lightGBM可以直接处理类别型特征。 2.缺点 可能会长比深的决策树，产生过拟合。lightGBM是基于偏差的算法，所以会对异常值比较敏感。在寻找最优解的时候，没有将最优解是全部特征的综合这一理念考虑进去。 3.案例 这里使用lightGBM的sklearn接口。下面以LGBMClassifier()为例，介绍其中的主要参数。
boosting_type:‘gbdt’(传统的GBDT模型)、‘dart’、‘goss’、‘rf’(随机森林)
dart: Dropouts meet Multiple Additive Regression Trees. 在每棵树的迭代过程中不再单单去拟合前一棵树的残差，而是从前面已有的树中采样一部分树，组合成一个新的树，然后去拟合这部分的残差，从而使后面的树贡献变大一些。
goss：Gradient-based One-Side Sampling，单边梯度采样。目的是丢弃一些对计算增益没有帮助的样本留下有帮助的，降低计算复杂度。num_leaves：基学习器的最大叶子节点数。max_depth: 基学习器的最大树深度。若 ≤ 0 \leq 0 ≤0则意味着对树深度不加限制。learning_rate: 学习率。n_estimators：学习器的个数。subsample_for_bin: 构成bins的样本数。
lightGBM中使用基于直方图算法的决策树算法。对每个特征进行直方图统计，然后根据直方图的离散值，遍历寻找最优的分割点。objective: ‘binary’、‘multiclass’class_weight: 该参数主要用于多分类任务中；在二分类任务中，可以使用is_unbalance或者scale_pos_weight。colsample_bytree:构造每棵树时特征的抽样比率。reg_alpha: L1正则化项。reg_lambda: L2正则化项。silent: 是否打印每次的运行结果。 LGBMClassifier()的fit()方法中也有几个重要参数需要说明。具体如下：
eval_metric:评价指标。分类任务默认使用’logloss‘。lightGBM中常用的评价指标有：
categorical_feature: 类别特征。lightGBM是目前唯一能直接处理类别特征的算法。在lightGBM中类别特征不需要在用one-hot进行转换了。 import pandas as pd from lightgbm import LGBMClassifier from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e29199d3604eacb497e5498a00efae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c82d829232a74fb8500919785f7b8d3/" rel="bookmark">
			汉诺塔游戏设计-c&#43;&#43;课程设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汉诺塔游戏设计 汉诺塔简介
汉诺塔（Tower of Hanoi），又称河内塔，是一个源于印度古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。
功能要求
1）基本要求：
(1)主界面
(2)完成汉诺塔游戏
(3)并且可以多次进行。
2）创新要求：
(1) 加入汉诺塔游戏的起源与规则，增加游戏的趣味性及其情怀。
(2) 加入记录玩家移动次数的函数，并使之在显示圆盘时输出。
(3) 加入攻略，可以对玩家所选择的圆盘数进行获取，并输出相应的圆盘数的最简移动步骤。
(4) 加入分数，通过玩家移动圆盘的次数和经过函数运算所得出的最少移动次数，进行打分。
(5) 加入世界排名，输出世界上各圆盘数所对应的最简移动步骤。
运行结果
1.主界面
2.开始游戏
3.移动圆盘
4.游戏通关
5.攻略
此处省略n张截图
论文样例
此处省略n张截图
下面为链接：
源代码+论文:
源代码+论文
论文
论文
源代码
源代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b797ec8c7b2bf9cf9280bea32b7fdfb5/" rel="bookmark">
			云服务器CENTOS7安装 docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移除掉旧的版本 sudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-selinux docker-engine-selinux docker-engine
删除所有旧的数据 sudo rm -rf /var/lib/docker
安装依赖包 sudo yum install -y yum-utils device-mapper-persistent-data lvm2
添加源，使用了阿里云镜像 sudo yum-config-manager –add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
配置缓存 sudo yum makecache fast
安装最新稳定版本的docker sudo yum install -y docker-ce
配置镜像加速器 sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’
{
“registry-mirrors”: [“http://hub-mirror.c.163.com”]
}
EOF
启动docker引擎并设置开机启动 sudo systemctl start docker
sudo systemctl enable docker
配置当前用户对docker的执行权限 sudo groupadd docker
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b797ec8c7b2bf9cf9280bea32b7fdfb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa145fdf9fc984941ac562e45c3b207/" rel="bookmark">
			C&#43;&#43;模板：静多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般，使用虚函数和继承实现的是动多态，即在运行期间确定调用者的类型。使用模板，可以实现静多态，在编译期间确定调用者的类型。
例如我们要对某一类对象进行统一处理，使用虚函数可以这样实现：
class BaseType { public: virtual void action1(){...} virtual void action2(){...} } class SubType1 : BaseType { public: virtual void action1(){...} virtual void action2(){...} } class SubType2 : BaseType { public: virtual void action1(){...} virtual void action2(){...} } // 统一处理 void DoAction1(BaseType const&amp; type) { type.action1(); } void DoAction2(BaseType* type) { type-&gt;action2(); } // 可以处理异类集合 void DoActions(std::vector&lt;BaseType*&gt; list) { ... } 如果使用模板来实现，就会变成这样
class SubType1 { public: void action1(){...} void action2(){.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baa145fdf9fc984941ac562e45c3b207/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/994fc1da529f5a535192ffc8e2cbbbff/" rel="bookmark">
			Python3 ---------各种常见内置函数的时间复杂度总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在刷leetcode。题目有各种时间复杂度和空间复杂度的要求。
导致很多函数都不太敢用了，于是总结一下常见的函数时间复杂度。
列表(List): list.copy()：平均和最坏时间复杂度都是O ( n )list.append(obj)：平均和最坏时间复杂度都是O ( 1 )list.pop(index)：index为-1的时候 O(1)
-index为[o,len(n)] 内 O(n)get 、set 平均和最坏时间复杂度都是O ( 1 )list.remove(obj)：平均和最坏时间复杂度都是O ( n )list.extend(seq)：平均和最坏时间复杂度都是O ( n )list.sort()：平均和最坏时间复杂度都是O ( n log ⁡ n )x in s:平均时间复杂度O ( n )min(s), max(s):时间复杂度为O ( n ) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d98def9a7a6689e1f9f6b1df7d7fc057/" rel="bookmark">
			URL的枝枝叶叶和http,https
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是URL? 平时我们俗称的网址就是URL URL的结构 https://www.so.com/s?ie=utf-8&amp;src=lm&amp;ls=sm2381336&amp;lm_extend=ctype%3A31&amp;q=%E6%90%9C%E7%8B%97 用以上搜狗网址作为例子 1.https:// 是协议方案名。目前比较常见的是http:// https:// telnet:// mailto://
①http: 超文本传输协议方案，默认端口为80
②https: 与http是一对，但加入了ssl，默认端口443
③mailto: 指的是E-mail地址
2.//www.so.com 服务器地址
3.? % %E6%90%9C%E7%8B%97 类似于这些字符，是被url当成了特殊意义理解了，对其进行了转义。这也叫做urlencode
urlencode:将需要转码的字符转为16进制，然后从右向左，取4位（不足4位直接处理），每两位为一组，前面加上%，编译成%XY的形式
与urlencode为一对的还有urldecode,urldecode就是urlencode的逆过程
4.ie=utf-8 查询字符串 ，以？做起始标志，内容以键值对形式存在
Http 1.什么是http?
http就是超文本传输协议方案，由于客户端和服务器是在主机上两个不同的程序，就需要保证客户端发给服务器的消息，服务器能懂，而服务器响应的内容客户端也能读懂，这就产生了协议
2.http协议格式
①http请求
a 首行：【方法】+【url】+【版本】
b. Header:请求的属性，冒号分割的键值对，每组属性之间使用“： ”分割
c. 空行：表示Header的结束
d.body：（对于get 一般没有body,可以有query string .而 post 一般有body
②http响应
a.首行：【版本号】+【状态码】+【状态码注解】
b.header:请求的属性，冒号分割的键值对，每组属性之间使用“： ”分割
c.空行：表示Header的结束
d.body:html文件
2.http的方法
get-----获取资源
post-----传输实体主体
put-----传输文件
head-----获取报文首部
delete-----删除文件
options-----询问支持的方法
trace-----追踪路径
connect-----要求用隧道协议连接代理
link-----建立和资源之间的联系
unlink-----断开连接关系
3.http的状态码
①1XX：接收的请求正在处理
②2XX：请求正常处理完毕
③3XX：重定向状态码
④4XX：服务器无法处理请求
⑤5XX：服务器处理请求出错
4.http的header
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d98def9a7a6689e1f9f6b1df7d7fc057/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebcdda80a325fd9a4de3826027f3be76/" rel="bookmark">
			关于报错ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行单元测试的时候，出现log4j报错ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console. 在多方查找之后发现原因所在：
在进行单元测试的时候没有配置log4j2.xml的文件：
并且，log4j2只支持xml和json两种格式的配置，所以配置log4j.properties时，是没有作用的。需要再次创建一个log4j2.xml的文件，才能够运行成功。
log4j2.xml文件的配置信息如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Configuration&gt; &lt;Appenders&gt; &lt;Console name="STDOUT" target="SYSTEM_OUT"&gt; &lt;PatternLayout pattern="%d %-5p [%t] %C{2} (%F:%L) - %m%n"/&gt; &lt;/Console&gt; &lt;RollingFile name="RollingFile" fileName="logs/strutslog1.log" filePattern="logs/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz"&gt; &lt;PatternLayout&gt; &lt;Pattern&gt;%d{MM-dd-yyyy} %p %c{1.} [%t] -%M-%L- %m%n&lt;/Pattern&gt; &lt;/PatternLayout&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy /&gt; &lt;SizeBasedTriggeringPolicy size="1 KB"/&gt; &lt;/Policies&gt; &lt;DefaultRolloverStrategy fileIndex="max" max="2"/&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Logger name="com.opensymphony.xwork2" level="WAN"/&gt; &lt;Logger name="org.apache.struts2" level="WAN"/&gt; &lt;Root level="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebcdda80a325fd9a4de3826027f3be76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20af56659e2f03c8854e4a01014aac90/" rel="bookmark">
			ENVI中使用水体指数法NDWI提取水体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行地类解译时，为了提高工作效率，经常会采用自动解译和人工修订相结合的方式进行。因此，经常会用到ENVI或者易康进行地类的自动解译，以NDWI提取水体为例，在ENVI中提取水体流程如下：
（1）数据预处理，理论上来说在使用遥感影像进行科学研究或者工程实践中时首先需要进行遥感影像的预处理工作。但仅从自动解译的角度来讲，影像是否进行预处理对自动解译几乎没有太大影响。
（2）使用Band math工具进行水体指数NDWI的计算。
Band math工具在工具箱中的位置如下：Band algebra&gt;Band math
（3）下面是对NDWI指数的使用，其中B2我们选择Green波段，B4选择NIR波段，之后即可生成NDWI的指数数据。
（4）经过水体指数NDWI计算之后的结果如下左图，图中高亮的白色部分即为经过NDWI方法增强后的水体部分，其他的植被、裸地等地类均被抑制呈现灰黑色。右图为432波段合成的经过大气校正后的Landsat TM数据。
（5）在得到NDWI指数结果之后，通过设定相应的阈值，再次使用Band math工具，进行提取水体结果。这里我们设定的阈值为0.2，即NDWI的值大于0.2的部分即为水体。在Band math中设置B1 gt 0.2,其中gt即代表大于的意思。设置阈值提取结果如下图，可以明显看出影像中的水体几乎被完整提取出，但由于卫星影像质量的问题，左侧的白色为影像原始的条带影响所致。
（6）在得到水体结果之后我们需要将栅格结果转出为矢量成果。栅格转换为矢量采用Classification&gt;post Classification&gt;Classfication to vector工具进行转换。在转换时需要设置DN值，由于我们经过指数法处理之后，将整景影像转换为了二值图，水体的DN值显示为1。
经过转换之后的结果如下图所示。图中蓝色部分即为我们使用NDWI指数提取到的水体结果。图中可以看到水体部分基本被完全提出，边界效果也较为良好。但仍存在一些小图斑或者误提的现象。而针对小图斑的问题，我们也可以继续采取一些去除小图斑的操作，并且根据自己的需要进行设定最小上图面积从而改善这一结果。
（7）在转换为EVF的结果之后，如果需要转换为GIS中所常用的SHP数据，我们还需要使用Vector&gt;Classic EVF to Shapefile工具进行将其转换为shp数据结果。
上面即为在ENVI中采用指数法进行提取水体的全部步骤，如果要使用其他的指数方法进行提取如植被、建设用地等其他地类，其原理和步骤是一样的，采用上述的方法均可进行有效提取。下篇将给大家展示如何使用Ecognition软件采用面向对象的方法进行提取水体。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/631766eef78298b76672d04454fd2f8a/" rel="bookmark">
			git 本地回退至某个版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查看版本
git log
可以看到有很多版本，每个版本的第一行是commit接一串字符串（部分打码了） 。要退出git log只需要按Q键。
2、选择想要回退到的版本，复制commit后面的一串字符串
3、输入命令
git reset --hard 字符串
比如我复制图上第一个commit后的字符串，其结果如下：
HEAD is now at 2b345e3 RobotRotate 夹具和关节一起动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/810a93fb91777350daadd73d00ab15e6/" rel="bookmark">
			计算机考研专业课满分是多少,考研考几门课程总分多少 每年一共考几次
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		研究生热门专业众多，例如：工商管理、金融学、法律硕士(非法学)、计算机科学与技术、会计、材料科学与工程、会计学、公共管理、行政管理等。
报考研究生总分是多少
1、考研满分是500分或者300分。
2、大部分专业是考四门：政治、外语各100分，还有两门专业课各150分，总分满分是500分。
3、部分专业是考三门，其中一门专业综合是300分，如教育学、医学、历史学等，总分满分是500分。
4、少数专业是考两门，如MBA、MPA会计、图书情报、审计专业硕士等，只考联考(200分)和英语二(100分)，总分满分是300分。
报考研究生每年考几次
考研一年只有一次考研的机会。通常安排在在每年的十月份报名，报名时间持续一个月左右，12月份下旬考试，2月份出初试成绩，全部复试工作在4月底之前完成。五六月份完成录取工作。
应届本科毕业生可以直接报考，但要确保在次年九月入学时双证齐全;专科生毕业两年后，具备两年工作经验，满足相关要求可以报考;非应届本科毕业生，不超过40周岁，满足相关条件，均可报考。
考研的优势是什么
研究毕业不仅有好的工作，因为工作起点更高，还有高于本科生的薪资待遇。不管是在体制内还是在体制外，研究生的薪资待遇，相对而言都会高于本科生。虽然说，这种差距刚开始看并不大，可是会经年累月持续、伴随着本科生和研究生各自的一生，一辈子都存在。研究生学历的员工也会更加容易升职加薪。这些优势只有研究生才能享受得到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8cb1b4f8227f5085c79b3672d8b567f/" rel="bookmark">
			形象易懂讲解算法II——压缩感知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		形象易懂讲解算法II——压缩感知
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72a3f72e41928994282208cb426f5d08/" rel="bookmark">
			this.$router.options.routes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		this.$router.options.routes 可以拿到初始化时配置的路由规则
this.$route 可以拿到当前路由信息 （包括路由路径，参数0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/684dcf17a4a7dac1095b78e08738375c/" rel="bookmark">
			MySQL---脏页机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 flush和脏页flush触发条件InnoDB刷脏页的控制策略 flush和脏页 InnoDB在处理更新语句的时候，磁盘操作仅写了redo log日志，同时并更新内存，之后当系统空闲时会把操作记录更新到磁盘里，MySQL把内存里的数据写入磁盘的过程我们称为flush。
当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容一致，称为“干净页”。
flush触发条件 InnoDB redo log日志写满。此时系统会停止所有更新操作，把checkpoint往前推进，为redo log留出空间。 MySQL日志—redo log和binlog系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。MySQL空闲。MySQL正常关闭。MySQL正常关闭前会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。 第一种情况InnoDB要尽量避免，因为出现这种情况整个系统就不能再接受更新了，所有的更新都必须堵住，这时候的更新数会跌为0。
第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况很常见。但是出现以下这两种情况，都是会明显影响性能的：
一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长。日志写满，更新全部堵住，写性能跌为0，对于某些业务无法接受。 InnoDB刷脏页的控制策略 首先需要正确地告诉InnoDB所在主机的IO能力，这样InnoDB才能知道需要全力刷脏页的时候可以刷多快。
MySQL5.5版本里，innodb_io_capacity参数可以动态调整刷新脏页的数量，innodb_io_capacity参数默认是200，单位是页。该参数设置的大小取决于硬盘的IOPS，即每秒的输入输出量（或读写次数）。
刷脏页的速度该如何设置呢？
InnoDB的刷盘速度需要参考两个因素：一个是脏页比例，另一个是redo log写盘速度。InnoDB会根据这两个因素先单独算出两个数字。
参数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%。InnoDB会根据当前的脏页比例（假设为M），算出一个范围在0到100之间的数字，这个计算公式可以记为F1(M)。
InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值，我们假设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以记为F2(N)（N越大，算出来的值越大）。
取F1(M)和F2(N)最大值R，按照R%的速度刷脏页。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/194b5803485a99a85754e11d4ea718c8/" rel="bookmark">
			ubuntu下使用yocto制作龙芯文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载yocto代码
poky下载得到pokyopenembedded配方下载得到meta-openembedded目录MIPS架构配方下载得到meta-img目录 git clone git://git.yoctoproject.org/poky git clone git://git.openembedded.org/meta-openembedded git clone https://github.com/MIPS/meta-img.git 二、代码切换分支
根据自己的版本选择适合自己的分支，这里由于meta-img只有morty分支，一般poky和meta-openembedded都会切换为morty分支，但是由于项目需求morty分支不满足，所以目前我的poky和meta-openembedded都是sumo分支，meta-img选择master分支。
三、目录放置
我们把meta-openembedded和meta-img放到poky目录下，目录结构如下图所示：
四、安装yocto编译环境
sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat libsdl1.2-dev xterm 五、构建自己的cpu机器
在meta-img/conf/machine目录下有多重mips架构的机器，其中和龙芯2k1000最接近的是mips64r2el-n32，所以我们参考qemumips64r2el-n32.conf来编写2k1000.conf，文件如下：
#@TYPE: Machine #@NAME: qemumips64r2el-n32 #@DESCRIPTION: MIPS 64r2, Little Endian, Hard Float, n32 #我们不需要qemu所以把下面两行注释掉 #require conf/machine/include/qemu.inc #require conf/machine/include/qemuboot-mips.inc require conf/machine/include/tune-mips64r2.inc require mips-common.inc DEFAULTTUNE = "mips64r2el-n32" #我们不需要跑qemu所以把下面两行注释掉 # runqemu extra options #QB_CPU = "-cpu MIPS64R2-generic" #我们需要制作下面做多种格式文件系统 IMAGE_FSTYPES+=" cpio.gz cpio tar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/194b5803485a99a85754e11d4ea718c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7d279dfdefe3b0d33ee7066c79a304a/" rel="bookmark">
			多个LEFT JOIN连用语法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SELECT ts.shift_id, ts.line_id, ts.tour_guide_id, ts.hotel_id, shift_name, tourist_standard, quote, car_type, start_date, return_date, tl.line_name, tg.tour_guide_name, hi.hotel_name FROM tourist_shift ts LEFT JOIN tourist_line tl ON ts.line_id = tl.line_id LEFT JOIN tour_guide tg ON ts.tour_guide_id = tg.tour_guide_id LEFT JOIN hotel_information hi ON ts.hotel_id = hi.hotel_id ————————————————
版权声明：本文为CSDN博主「大黄的Java笔记」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_39331713/article/details/85000455
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bff7689ac9f5d99c30deaa340ccfbfeb/" rel="bookmark">
			计算机用户没有管理员权限,电脑没有管理员权限怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是时间财富网智能客服时间君，上述问题将由我为大家进行解答。
以win7为例，电脑没有管理员权限解决方法如下：
1、如果是一个文件夹，点击的时候系统说没有查看权限，就用鼠标右键单击这个文件夹，看到有一行内容“管理员取得所有权”，点击一下即可；
2、对于一个程序而言，也可以使用鼠标右键单击这个程序，然后点击“以管理员身份运行”，即可获得使用这个程序的权限。
计算机(computer)俗称电脑，是现代一种用于高速计算的电子计算机器，可以进行数值计算，又可以进行逻辑计算，还具有存储记忆功能。是能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。由硬件系统和软件系统所组成，没有安装任何软件的计算机称为裸机。可分为超级计算机、工业控制计算机、网络计算机、个人计算机、嵌入式计算机五类，较先进的计算机有生物计算机、光子计算机、量子计算机等。
计算机发明者约翰・冯・诺依曼。计算机是20世纪最先进的科学技术发明之一，对人类的生产活动和社会活动产生了极其重要的影响，并以强大的生命力飞速发展。它的应用领域从最初的军事科研应用扩展到社会的各个领域，已形成了规模巨大的计算机产业，带动了全球范围的技术进步，由此引发了深刻的社会变革，计算机已遍及一般学校、企事业单位，进入寻常百姓家，成为信息社会中必不可少的工具。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/303/">«</a>
	<span class="pagination__item pagination__item--current">304/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/305/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>