<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e1a1536a15ca9c8eef3da39b9b619a8/" rel="bookmark">
			Linux添加、删除默认路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加默认路由：
route add default gw 192.168.20.1
删除默认路由：
route del default gw 192.168.20.1
添加普通路由：
route add -net 192.168.20.0/24 gw 192.168.20.1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1039f2d283a798b0f33eb9a601546943/" rel="bookmark">
			MacOS安装brew教程从入门到入土
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开macos的终端，输入 /bin/bash -c "$(curl -fsSL https://gitee.com/ineo6/homebrew-install/raw/master/install.sh)" 2.等待安装完成后的提示
提示需要执行一个命令将homebrew添加到path中，复制提示文本继续在终端中执行，注意，这里每个人的电脑名字不一样，一定要复制你自己终端里提示的命令，我的只是一个参考，直接复制全部就行，不需要换行和调整格式什么的
echo 'eval "$(/opt/homebrew/bin/brew shellenv)"' &gt;&gt; /Users/zyyt/.zprofile eval "$(/opt/homebrew/bin/brew shellenv)" 3.此时再执行brew help就可以看到相关信息提示已经有brew了
4.把brew下载包的地址切换为国内的镜像地址，和切换npm的下载地址为淘宝镜的意思一样
依次执行以下4条命令 git -C "$(brew --repo)" remote set-url origin https://mirrors.ustc.edu.cn/brew.git git -C "$(brew --repo homebrew/core)" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git git -C "$(brew --repo homebrew/cask)" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git brew update 5.设置bottles镜像 继续执行以下命令
echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles/bottles' &gt;&gt; ~/.zprofile source ~/.zprofile 以上，完成了homebrew的所有配置，可以使用homebrew来安装你想要的包了
brew install 某某包名称
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef9a42821a27139c54eb639e59e8af4/" rel="bookmark">
			服务端高并发分布式架构演进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 概述 本文以淘宝作为例子，介绍从一百个到千万级并发情况下服务端的架构的演进过程。同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知。文章最后汇总了一些架构设计的原则。
特别说明：本文以淘宝为例仅仅是为了便于说明演进过程可能遇到的问题，并非是淘宝真正的技术演进路径。
二. 基本概念 在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍：
分布式：系统中的多个模块在不同服务器上部署，即可称为分布式系统。如 Tomcat 和数据库分别部署在不同的服务器上，或两个相同功能的 Tomcat 分别部署在不同服务器上；
高可用：系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性；
集群：一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。如 ZooKeeper 中的 Master 和 Slave 分别部署在多台服务器上，共同组成一个整体提供集中配置服务。在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动接替它继续提供服务。这时候说明集群具有高可用性；
负载均衡：请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀处理请求负载，则可认为系统是负载均衡的；
正向代理和反向代理：系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去。在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理。当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上。对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。
三. 架构演进 3.1 单机架构 以淘宝作为例子。在网站最初时，应用数量与用户数都较少，可以把 Tomcat 和数据库部署在同一台服务器上。浏览器往 www.taobao.com 发起请求时，首先经过 DNS 服务器（域名系统）把域名转换为实际 IP 地址 10.102.4.1，浏览器转而访问该 IP 对应的 Tomcat。
随着用户数的增长，Tomcat 和数据库之间竞争资源，单机性能不足以支撑业务。
3.2 第一次演进：Tomcat 与数据库分开部署 Tomcat 和数据库分别独占服务器资源，显著提高两者各自性能。
随着用户数的增长，并发读写数据库成为瓶颈。 3.3 第二次演进：引入本地缓存和分布式缓存 在 Tomcat 同服务器上或同 JVM 中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的 HTML 页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。其中涉及的技术包括：使用Memcached 作为本地缓存，使用 Redis 作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。
缓存抗住了大部分的访问请求。随着用户数的增长，并发压力主要落在单机的Tomcat 上，响应逐渐变慢。
3.4 第三次演进：引入反向代理实现负载均衡 在多台服务器上分别部署 Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个 Tomcat 中。此处假设 Tomcat 最多支持 100 个并发，Nginx 最多支持 50000 个并发。那么，理论上 Nginx 把请求分发到 500 个 Tomcat 上，就能抗住 50000 个并发。其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持 HTTP 协议，还会涉及 Session 共享、文件上传下载的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bef9a42821a27139c54eb639e59e8af4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cd6e02f97a99d90ed11fa3fb3873ad0/" rel="bookmark">
			【python】通过多线程解决tkinter gui中按键卡住的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 前几天在C站上上看到了类似的博客，回想起了我之前解决这个问题的历程，作为一个自学者&amp;外行，碰到这种问题其实还是挺头疼的。
问题复现 就以之前做的“用起来不一般的word批注整理器”为例（博客路径：【python脚本】word批注批量提取器V2实用版，资源路径：get_word_comments: 用于获取和整理word批注状态的软件，基于python与VBA编码），通过tk搭起来的界面是这样的：
那么在选择目录后，点击“开始检查”，会发生哪些事情呢？
递归遍历目录，找出全部的docx文件；选择一个word，后台打开，执行预定好的vba宏代码；选择下一个word打开，直到把所有的word全部执行一遍，得到一众commets.txt；python处理所有的commets.txt，收集整理批注；将整理后的信息根据配置写入excel文档； 采用简单的方法组织的话，所有这些操作完成后“开始检查”按键对应的函数才执行结束，这个按键才会弹起来：
button2 = Button(f3, text='开始检查', command=thread_start_check) 而如果文档比较多，处理比较慢时程序就会呈现出卡死的状态，稍有不慎可能就把程序搞死了，所以为了软件的实用性，卡死的问题是必须要解决的。
多线程 作为一个曾经的优秀的验证工程师，对于多线程的使用还是比较熟练的，所以我就明确了解决问题的思路：
python中的线程库为：
import threading start_check实际的操作为：
def start_check(): update_root() text3.delete("1.0", "end") text3.mark_set('here',1.0) text3.insert('here', "开始检索文件并处理，用时较长请勿退出，请在检查结束后点击 打开结果\n") fullpath = text1.get(1.0, "end").strip() full_docx = get_process_files(fullpath) proc_file(full_docx) log_info_get() gen_excel(mode) text3.mark_set('here',1.0) text3.insert('here', "EXCEL已生成：" + excel_name + "\n") text3.mark_set('here',1.0) text3.insert('here', "==========================================================================\n") pass 那么借助于threading，可以在实际操作外裹一层函数，构成按键实际关联的函数：
def thread_start_check(): t1 = threading.Thread(target=start_check,args=()) t1.start() pass 这样操作后，按键就可以直接回弹，而操作还在继续，log持续打印在显示框中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/076666395b8fbca276b76d35cf2f89d9/" rel="bookmark">
			高亮显示手风琴案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1.高亮显示
2.王者荣耀风琴
1.高亮显示 利用透明度修改，突出选中的图片鼠标进入的时候,其他的li标签透明度：0.5鼠标离开，其他li 透明度改为 1关键利用fadeTo修改透明度 效果展示
实现代码
&lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function() { //鼠标进入的时候,其他的li标签透明度：0.5 $(".wrap li").hover(function() { $(this).siblings().stop().fadeTo(400, 0.5); }, function() { // 鼠标离开，其他li 透明度改为 1 $(this).siblings().stop().fadeTo(400, 1); }) }); &lt;/script&gt; 2.王者荣耀风琴 利用淡出淡入实现风琴案例
鼠标经过某个li有两步操作
1.当前li宽度变为224px同时小图片淡出大图片淡入
2.其余兄弟li宽度变为69px小图片淡入大图片淡出
注意：
为了保证页面不溢出效果好不多次动画同时展现需要使用stop（）方法。
实现效果
实现代码 &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function(){ //鼠标经过某个li有两部操作 $(".king li").mouseenter(function(){ //1.当前li宽度变为224px同时小图片淡出大图片淡入 $(this).stop().animate({ width:224 }).find(".small").stop().fadeOut().siblings(".big").stop().fadeIn(); //2.其余兄弟li宽度变为69px小图片淡入大图片淡出 $(this).siblings("li").stop().animate({ width:69 }).find(".small").stop().fadeIn().siblings(".big").stop().fadeOut(); }) }) &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbfcf4f571bac29fe16deacad88609ff/" rel="bookmark">
			PHP基础学习第十九篇（了解MySQL数据库、MySQL的连接和创建数据库、MySQL创建数据表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、初始MySQL数据库 数据库是什么：数据库（Database）是按照数据结构来组织、储存和管理数据的仓库。
每个数据库都有一个或多个不同的API用于创建、访问、管理、搜索和复制所保存的数据。
我们也可以将数据存储在文件中，但是在文件中读写数据速度相对比较慢，所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合和代数等数学概念和方法来处理数据库中的数据。
RDBMS 即关系数据库管理系统的特点： 1、数据以表格的形式出现
2、每行为各种记录的名称
3、每列为记录名称所对应的数据
4、许多的行，和列组成一张表单
5、若干的表单组成database
数据库：数据库是一些关联表的集合。
数据表：数据表是，数据的矩形，看起来像一个简单的电子表格。
列：一列（数据元素）包含了相同类型的数据，例如电话号码数据。
行：一行是一组相关的数据，例如一条用户订阅的数据。
冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。
主键：主键是唯一的，一个数据表中只能包含一个主键，可以使用主键来查询数据，一般使用ID作为主键。
数据表样式：
二、 链接MySQL数据库和创建数据库 在我们访问MySQL数据库前，我们需要先连接到数据库服务器链接MySQL可以使用MySQLi和PDO两种方式，PDO可以支持12种不同的数据库，MySQLi只支持MySQL数据库。
本视频使用MySQLi方式。
MySQLi在PHP5 MySQL包安装时MySQLi已自动安装。
链接MySQL的代码：
默认的：用户名和密码都是root
&lt;?php //尝试访问连接到MySQL $servername="localhost";//确定服务器的名称 $username="root";//登录用户名 $password="root";//登录密码 //创建连接 //MySQLi_connect是打开一个到MySQL服务器的连接 $conn=mysqli_connect($servername,$username,$password);//把三个值带入mysqli_connect函数 if(!$conn){ echo("Connection failed:".mysqli_connect_error()); }else{ echo"连接成功"; } ?&gt; 关闭MySQL链接：
连接在脚本执行完后会自动关闭，也可以使用以下代码来关闭连接：mysql_close($conn);
创建数据库代码：
&lt;?php //创建一个新的数据库 $sql="CREATE DATABASE xm1"; //mysqli_query()函数执行某个针对数据库的查询 if(mysqli_query($conn,$sql)){ echo"创建成功"; }else{ echo"创建失败".mysqli_error($conn); } mysqli_close($conn);//关闭数据库连接 ?&gt; 使用代码进行演示的相关效果如下： &lt;?php //尝试访问连接到MySQL $servername="localhost";//确定服务器的名称 $username="root";//登录用户名 $password="root";//登录密码 //创建连接 //MySQLi_connect是打开一个到MySQL服务器的连接 $conn=mysqli_connect($servername,$username,$password);//把三个值带入mysqli_connect函数 if(!$conn){ echo("Connection failed:".mysqli_connect_error()); }else{ echo"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbfcf4f571bac29fe16deacad88609ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89acf9e60d0fa535faee924c70821bec/" rel="bookmark">
			postman发送post请求如何传递参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.对于javabean对象的普通属性，直接使用json对象格式，传递即可，如下图中的name属性。
2.对于javabean对象中的及联对象中的属性，则需要使用json对象组合的格式，如下图的extField属性。
json数据格式详解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a12c1b66adb7074ea7dd452ff547824e/" rel="bookmark">
			Spatial Attention
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Attention 机制 所谓Attention机制，便是聚焦于局部信息的机制。当我们再看一样东西时，我们当前时刻关注的一定是我们当前正在看的东西的某一个地方。随着任务的变化，注意力区域往往会发生变化。
面对上面这张图，如果从整体上看，只看到了很多的车，但仔细一看会发现每辆车的车牌号不同，汽车厂家也不同。
图中除了汽车之外的信息均是无用信息，也对目标识别网络起不到作用。Attention机制便是要找到这些对训练最有用的信息。
1. 基于Attention的显著目标检测 和注意力机制相伴而生的一个任务是显著目标检测，即salient object detection。它的输入是一张图，输出是一张概率图，概率越大的地方，获得人眼关注的概率越大。典型的显著图目标检测图如下：
左侧图像为显著图，其中在头部和身体概率最大，远处的门也有一定的概率，这就是左侧图像中有用的信息。右侧图中为显著性目标检测图像，将关注的重点人突出显示出来。
显著目标检测需要一个数据集，而此数据集的收集便是通过追踪多个实验者的眼球在一定时间内的注意力方向进行平均得到，典型的步骤如下：
（1）让被测试者观察图。
（2）用eye tracker记录眼睛的注意力位置。
（3）对所有测试者的注意力位置使用高斯滤波进行综合。
（4）结果以0~1的概率记录。
于是得到下面这样的图，第二行是眼球追踪结果，第三行是显著目标概率图。
上面讲述的都是空间上的注意力机制，及关注的是不同空间位置，而在CNN结构中，还有不同的特征通道，因此不同特征通道也有类似的原理。
2. Attention模型框架 注意力机制的本质就是定位到感兴趣的信息，抑制无用信息，结果通常都是以概率图或者概率特征向量的形式展示，从原理上来说，主要分为空间注意力模型，通道注意力模型，空间和通道混合注意力模型三种，这里不区分soft和hard attention。
2.1 空间注意力模型(spatial attention) 不是图像中所有的区域对任务的贡献都是同样重要的，只有任务相关的区域才是需要关心的，比如分类任务的主体，空间注意力模型就是寻找网络中最重要的部位进行处理。
在这里给大家介绍两个具有代表性的模型，第一个就是Google DeepMind提出的STN网络(Spatial Transformer Network[1])。它通过学习输入的形变，从而完成适合任务的预处理操作，是一种基于空间的Attention模型，网络结构如下：
这里的Localization Net用于生成仿射变换系数，输入是C×H×W维的图像，输出是一个空间变换系数，它的大小根据要学习的变换类型而定，如果是仿射变换，则是一个6维向量。
这样的一个网络要完成的效果如下图：
即定位到目标的位置，然后进行旋转等操作，使得输入样本更加容易学习。
相比于Spatial Transformer Networks 一步完成目标的定位和仿射变换调整，Dynamic Capacity Networks[2]则采用了两个子网络，分别是低性能的子网络(coarse model)和高性能的子网络(fine model)。低性能的子网络(coarse model)用于对全图进行处理，定位感兴趣区域，如下图中的操作fc。高性能的子网络(fine model)则对感兴趣区域进行精细化处理，如下图的操作ff。两者共同使用，可以获得更低的计算代价和更高的精度。
由于在大部分情况下我们感兴趣的区域只是图像中的一小部分，因此空间注意力的本质就是定位目标并进行一些变换或者获取权重。
2.2 通道注意力机制 对于输入2维图像的CNN来说，一个维度是图像的尺度空间，即长宽，另一个维度就是通道，因此基于通道的Attention也是很常用的机制。
SENet(Sequeeze and Excitation Net)[3]是2017届ImageNet分类比赛的冠军网络，本质上是一个基于通道的Attention模型，它通过建模各个特征通道的重要程度，然后针对不同的任务增强或者抑制不同的通道，原理图如下：
在正常的卷积操作后分出了一个旁路分支，首先进行Squeeze操作(即图中Fsq(·))，它将空间维度进行特征压缩，即每个二维的特征图变成一个实数，相当于具有全局感受野的池化操作，特征通道数不变。
然后是Excitation操作(即图中的Fex(·))，它通过参数w为每个特征通道生成权重，w被学习用来显式地建模特征通道间的相关性。在文章中，使用了一个2层bottleneck结构(先降维再升维)的全连接层+Sigmoid函数来实现。
得到了每一个特征通道的权重之后，就将该权重应用于原来的每个特征通道，基于特定的任务，就可以学习到不同通道的重要性。
将其机制应用于若干基准模型，在增加少量计算量的情况下，获得了更明显的性能提升。作为一种通用的设计思想，它可以被用于任何现有网络，具有较强的实践意义。而后SKNet[4]等方法将这样的通道加权的思想和Inception中的多分支网络结构进行结合，也实现了性能的提升。
通道注意力机制的本质，在于建模了各个特征之间的重要性，对于不同的任务可以根据输入进行特征分配，简单而有效。
2.3 空间和通道注意力机制的融合 前述的Dynamic Capacity Network是从空间维度进行Attention，SENet是从通道维度进行Attention，自然也可以同时使用空间Attention和通道Attention机制。
CBAM(Convolutional Block Attention Module)[5]是其中的代表性网络，结构如下：
通道方向的Attention建模的是特征的重要性，结构如下：
同时使用最大pooling和均值pooling算法，然后经过几个MLP层获得变换结果，最后分别应用于两个通道，使用sigmoid函数得到通道的attention结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a12c1b66adb7074ea7dd452ff547824e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15f28945891f3ad5f5804f7dac643137/" rel="bookmark">
			新浪下拉菜单案例淘宝服饰精品案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.新浪下拉菜单
2.淘宝服饰精品
1.新浪下拉菜单 利用jQuery基础选择器$("选择器")选择对应的方法实现 实现效果
实现代码
&lt;script&gt; $(function() { // 鼠标经过 $(".nav&gt;li").mouseover(function() { // $(this) jQuery 当前元素 this不要加引号 // show() 显示元素 hide() 隐藏元素 $(this).children("ul").show(); }); // 鼠标离开 $(".nav&gt;li").mouseout(function() { $(this).children("ul").hide(); }) }) &lt;/script&gt; 遇到的问题：下拉框不显示
原因：jQuery文件导入不成功
解决：修改路径
2.淘宝服饰精品 tab栏左右切换，关键是鼠标经过左右的li得到相应的索引呈现对应的照片，并将其他照片隐藏起来。$(this).index()可以快速获得索引号相应索引号显示出来$("#content div").eq(index).show();其余照片隐藏$("#content div").eq(index).siblings().hide(); 实现效果
实现代码
&lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function() { //1.鼠标经过左侧的li $("#left li").mouseover(function(){ //2.得到当前小li的索引号 var index=$(this).index(); console.log(index); //3.让我们右侧的盒子相应索引号显示出来 $("#content div").eq(index).show(); //4.让其余的图片(就是其他的兄弟)隐藏起来 $("#content div").eq(index).siblings().hide(); }) }) &lt;/script&gt; 遇到的问题依然是jQuery文件不存在，我重新导入，检查路径是否正确，最后发现每次导入文件必须在同一个目录下导入才能成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd8fd16ea37e11ecd42f2b1fbedce62/" rel="bookmark">
			机器学习中的二分类问题评价指标之精确率、召回率、F1值通俗理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：对于分类问题，我们在评估一个模型的好坏时，通常想到的是把该模型在测试集上分类结果正确的样本数量比上测试集的样本数量的比值结果，即准确率（精确率）作为评价准则。但除此之外，还有精确率和召回率作为二分类问题的评价指标。那么什么时精确率和召回率呢，之前了解过这个概念用到时总是会忘，现在抽出时间对此进行总结。
在了解这两个评价指标之前，我们必须要对模型预测出的结果类型进行定义，这里是对于二分类问题来讲的，在二分类问题中，我们把类别定义为正类（Positive）和负类（Negative）。需要记住四个结果类型，分别为TP，FP，TN，FN；
TP：TP是True Positive，即预测正确的正类样本数，也就是模型在进行预测的时候，把正类预测为了正类，也就是把正类预测正确了。
TN：TN是True Negative，即预测正确的负类样本数，也就是模型在进行预测的时候，把负类预测为了负类，也就是把负类预测正确了。
FP：FP是False Positive，即预测错误的正类样本数，也就是模型在进行预测的时候，把负类预测为了正类，也就是把负类预测错误了，本来模型该把这个负类预测为负类的，结果却把这个负类预测为了正类。
FN：FN是False Negative，即预测错误的负类样本数，也就是模型在进行预测的时候，把正类预测为了负类，也就是把正类预测错误了，本来模型该把这个正类预测为正类的，结果却把这个正类预测为了负类。
无外乎，模型给出的预测结果只能是上面四种中的一种，当模型把正类样本预测为正类（TP），把负类样本预测为负类（TN），是模型预测正确的表现；当模型把正类样本预测为负类（FN），把负类样本预测为正类（FP），是模型预测错误的表现。
有了以上概念，我们来分析一下精确率和召回率。
精确率：
官方给出的公式为： ；
分析：该公式的意思是该模型将正类预测为正类的样本数量与该模型将正类和负类均预测为正类的样本数量的比值。看起来有点绕，我们分步分析：
分子TP是模型在预测时将正类预测为了正类的样本数；分母是TP+FP，FP是模型在预测时，将负类预测为了正类的样本数，即FP是假的正类样本数，我们想一想，如果一个模型预测能力很强，那该模型会极大可能的把正类预测为正类，负类预测为负类，而极小可能的把负类预测为正类，也就是FP的样本数应该越小越好，而FP越小，就会导致P的值越接近于1。是不是很神奇，人类太聪明了。
召回率：
官方给出的公式为：；
分析：该公式的意思是该模型将正类预测为正类的样本数量与该模型将正类预测为正类和负类的样本数量的比值。我们依然分步分析：
分子TP和精确率中的TP是一个含义；分母是TP+FN，FN是模型在预测时，将正类样本预测为了负类样本的样本数，即FN指的是模型应该把正类样本预测为为正类，但是却把正类样本预测为了负类样本的数量；那我们想一想，如果一个模型的预测能力很强，那该模型应该极大可能的把正类预测为正类，而很小可能把正类预测为负类，也就是FN越小越好，FN越小，表示该模型有更大的把握把正类预测为正类，那么FN越小，就会导致R的值越接近于1。
总结，在分析完精确率和召回率的公式之后，我们知道了P和R的值当然是越接近于1，表明模型的预测能力越好。上面我说到的预测能力很强是用来表达模型的预测能力很优秀。
问题：那在评价模型的时候，我是应该以P为评价指标基准，还是以R为评价指标基准呢？
答：这里就引入了F1值，它是精确率P和召回率R的调和均值。
F1值：
公式为：，对该公式进行通分，将F1放到一边，并将P、R带入，求出公式为：
分析：对于该公式，分子TP是该模型将正类预测为正类的样本数量，分母中的FP是该模型将负类预测为了正类，FN是该模型将正类预测为了负类；相应的，如果模型的预测能力很强，那么就应该很少可能的将负类预测为了正类，即FP应该越小越好，而根据精确率的公式，FP越小，P就越大；并且模型应该很少可能的将正类预测为了负类，即FN应该越小越好，而根据召回率的公式，FN越小，R就越大；而根据F1的公式来看，FP和FN越小，则F1越接近于1。
得出结论：精确率P和召回率R的值越大，F1的值也会越大，这里的越大指的是越接近于1，P、R、F1的值最大也就是1了。
总结不易，希望给个赞支持一下，转载请注明链接哈，如果有总结不到位或表达不恰当之处，欢迎批评指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fae6bc1896445c6875b09980cc6f6b9/" rel="bookmark">
			安装docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看docker安装目录
whereis docker
docker: /usr/bin/docker /etc/docker /usr/libexec/docker /usr/share/man/man1/docker.1.gz
2.查询运行文件所在路径
which docker
/usr/bin/docker
3.启动docker
Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！
启动docker前，一定要关闭防火墙后！！
# 关闭
systemctl stop firewalld
# 禁止开机启动防火墙
systemctl disable firewalld
#查看是否关闭防火墙
systemctl status firewalld
4.通过命令启动docker：
systemctl start docker # 启动docker服务
systemctl stop docker # 停止docker服务
systemctl restart docker # 重启docker服务
systemctl status docker # 查看docker启动状态
docker -v 查看docker版本
5.配置镜像加速
docker官方镜像仓库网速较差，我们需要设置国内镜像服务：
参考阿里云的镜像加速文档：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors
##创建文件夹
sudo mkdir -p /etc/docker
&gt; ##在文件夹内新建一个daemon.json文件
sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'
{
"registry-mirrors": ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fae6bc1896445c6875b09980cc6f6b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59adad6d9e4b182d3c89af58269a13a7/" rel="bookmark">
			网站备案注销(删除)，域名备案注销(删除)，备案怎么注销删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：获取申请表 下载地址： 附件：1.河南省网站备案注销删除申请表.docx
2.相关接入商备案咨询电话一览表.xlsx
官方网址：
河南省网站备案注销(删除)申请表
https://hca.miit.gov.cn/bsfw/bszn/art/2020/art_05888ffafa654491b0dfa1312c264b7b.html 文档样式： 河南省网站备案注销(删除)申请表
填表前请认真阅读表后“填表须知”，手续不全者申请视为作废
申请日期（必填）：
1．用户备案信息（以下信息均须写清楚）
备案号
域名（空壳主体免填）
主办单位名称
（网站主办者为个人时，填写主办者姓名）
联系人姓名（填写申请人姓名）
联系人电话（填写申请人联系方式）
联系人邮箱（填写申请人邮箱）
2.备案注销原因
（必须填写详细原因）
3.单位公章
（网站主办者为单位时，请在此处加盖单位公章；网站主办者为个人时，请网站主办者在此处签名）
第二步：填写申请表注意事项 填表须知
（本页是填表须知，不必打印。请只打印申请表，另附上相关证明材料一并提交）
一.适用范围： （1）用户注销网站备案请通过接入服务商自行提交注销申请。
（2）本表仅适用于备案号为“豫ICP备”开头的空壳类用户申请注销。备案号(主体)非河南省的，请咨询对应省通信管理局。
二、备案号分为主体备案号和网站备案号两种： （1）主体备案号格式为“豫ICP备X号”(X为8位数字)。
（2）网站备案号格式为“豫ICP备X号-1”(X为8位数字) 。 三、用户须提供以下资料： 3.1、主体信息为单位时： ①　河南省网站备案注销(删除)申请表；
②　域名证书（如因域名到期不再使用或被他人抢注，无需提供域名证书，需在注销表注销原因里进行备注）；
③　单位有效证件（如：公司需提供：营业执照；事业单位需提供：事业法人证书；政府机关需提供：统一社会信用代码证书等）；
④　法人身份证复印件（正反面）、申请人身份证复印件（正反面）。
3.2、主体信息为个人时： ①　河南省网站备案注销(删除)申请表；
②　域名证书（如因域名到期不再使用或被他人抢注，无需提供域名证书，需在注销表注销原因里进行备注）；
③　个人身份证复印件（正反面）。
3.3、域名所有者申请注销时； ① 河南省网站备案注销(删除)申请表；
② 域名证书；
③　单位有效证件（如：公司需提供：营业执照；事业单位需提供：事业法人证书；政府机关需提供：统一社会信用代码证书等）；
④　法人身份证复印件（正反面）、申请人身份证复印件（正反面）。
注：以上所有资料均需彩版，且单位资料需全部加盖公章，若单位证件发生过变更或已注销，请提供证件颁发机构出具的变更证明或注销证明。
四.打印 申请表用于存档，请使用A4打印纸打印。纸张不符、证件不全、未准确清晰完整填写者，视为无效申请。申请材料必须真实有效，不得伪造。
五.递交方式： （1）电子邮箱：hnwzba@126.com
（2）邮寄地址：郑州市金水区民航路8号河南省通信管理局一楼网站备案中心 收件人：106备案中心 联系电话: 0371—65795120
（3）现场办理地址：郑州市金水区民航路8号河南省通信管理局一楼106网站备案中心 联系电话:0371—65795120
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59adad6d9e4b182d3c89af58269a13a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b6ee4b492ad3ebb0412900ccbbfd0c/" rel="bookmark">
			texlive的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、下载驱动点击进入网页[https://tug.org/texlive/](https://tug.org/texlive/)进来之后呢，往下滑动，建议大家选择下载虚拟光驱，如将来重新下载，可以直接使用现在下载的.iso软件实现再次安装。进入之后，点击选择附近的镜像网址进入后选择时间最新的.iso程序，点击下载即可 二、安装找到刚才下载所在的文件夹，双击打开.iso软件。然后找到.bat文件，点击右键，以管理员身份运行点击高级选项 三.测试 前言 最近准备开始Latex的使用学习，在这里记录一下。
一、下载驱动 点击进入网页https://tug.org/texlive/ 进来之后呢，往下滑动，建议大家选择下载虚拟光驱，如将来重新下载，可以直接使用现在下载的.iso软件实现再次安装。 进入之后，点击选择附近的镜像网址 进入后选择时间最新的.iso程序，点击下载即可 下载时间较长，耐心等待。
二、安装 找到刚才下载所在的文件夹，双击打开.iso软件。 然后找到.bat文件，点击右键，以管理员身份运行 点击高级选项 安装需要很长一段时间，大概会有半小时到五十分钟。
在它安装完毕后，点击关闭即可
三.测试 我们使用命令提示符来观察是否安装正确
输入xetex -v
如果出现
那么就需要去系统环境中设置
点击右下角搜索高级系统设置
打开后选择环境变量，打开后，选择系统变量中的Path,点击编辑，
进入后点击新建，找到你安装texlive的文件夹，
D：xxx\texlive\2022\bin\win32
将路径复制到输入框内
最后点击确定
再在命令提示符来观察是否安装正确（要先把之前打开的命令行窗口关闭）
输入
在安装完之后，可以调用 terminal，分别输入
tex -v
latex -v
xelatex -v
pdflatex -v
表明安装成功。
安装成功之后还需要选择合适的编译器，我准备使用早已安装的vscode。这部分之后再写记录过程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e557133d6fa8bb154ed71806c89d79c/" rel="bookmark">
			Android11以上无法访问Android/data目录的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文从Sky233’s Blog复制过来
前言 我最近在开发一个Android项目的时候,需要用到这个权限访问某个文件,但我在网络上没有找到一个很好且易懂的解决方法,因此写了这篇博文。
思路 在Android上有一个叫做SAF(Storage Access Framework)的储存访问框架
而这个框架的访问权限较高,可以直接访问Android/data目录
因此可以通过这个方式来访问Android/data目录
仅需通过这个框架来获取Android/data目录的权限即可访问目录
获取访问权限 如果手机安卓版本为Android10的时候,可以在AndroidManifest.xml中添加下列代码
android:requestLegacyExternalStorage="true" 以此禁用分区存储,但这在Android11及以上版本不起作用
所以需要使用SAF访问框架
REQUEST_CODE_FOR_DIR是一个int变量,为一个固定的数,用于回调
在onActivityResult回调方法中加入下列代码
protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); Uri uri; if (requestCode == REQUEST_CODE_FOR_DIR &amp;&amp; (uri = data.getData()) != null) { getContentResolver().takePersistableUriPermission(uri, data.getFlags() &amp; ( Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION)); } } 并合适的地方调用下面的代码
@RequiresApi(api = Build.VERSION_CODES.O) public static void startFor(Activity activity) { Uri uri = Uri.parse("content://com.android.externalstorage.documents/tree/primary%3AAndroid%2Fdata"); DocumentFile documentFile = DocumentFile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e557133d6fa8bb154ed71806c89d79c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e75229b6472c08ae305e934b0068982/" rel="bookmark">
			Python数据分析（4）：jieba分词详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 jieba分词器1. jieba分词器的分词模式说明（1）精确模式（2）全模式（3）搜索引擎模式（4）Paddle模式 2. jieba分词器的基本用法（1）三种模式案例（2）词性标注（3）识别新词：HMM参数（4）搜索引擎模式分词：cut_for_search()函数 3. 调整词典（1）使用自定义词典：load_userdict()函数（2）动态修改词典：add_word()、del_word()函数（3）调节词频：suggest_freq()函数 4. 关键词提取（1）基于TF-IDF算法的关键词提取：extract_tags()函数（2）基于TextRank算法的关键词提取：textrank()函数 5. 停用词过滤6. 词频统计 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站：人工智能从入门到精通教程
jieba分词器 1. jieba分词器的分词模式说明 jieba分词器提供4种分词模式，并且支持简体/繁体分词、自定义词典、关键词提取、词性标注。
（1）精确模式 该模式会将句子最精确地切分开，适合在文本分析时使用。
（2）全模式 该模式会将句子中所有成词的词语都扫描出来，速度也非常快，缺点是不能解决歧义问题，有歧义的词语也会被扫描出来。
（3）搜索引擎模式 该模式会在精确模式的基础上对长词再进行切分，将更短的词语切分出来。在搜索引擎中，要求输入词语的一部分也能检索到整个词语相关的文档，所以该模式适用于搜索引擎分词。
（4）Paddle模式 该模式利用PaddlePaddle深度学习框架，训练序列标注网络模型实现分词，同时支持词性标注。该模式在4.0及以上版本的jieba分词器中才能使用。使用该模式需要安装paddlepaddle模块。
2. jieba分词器的基本用法 在Python中，可以使用jieba模块的cut()函数进行分词，返回结果是一个迭代器。
cut()函数有4个参数：
第一个参数：待分词文本cut_all：设置使用全模式(True)还是精确模式(False)； 默认Falseuse_paddle：控制是否使用Paddle模式进行分词HMM：控制是否使用HMM模式识别新词 （1）三种模式案例 设置参数cut_all为True：全分词
import jieba str1 = '我来到了西北皇家理工学院，发现这儿真不错' seg_list = jieba.cut(str1, cut_all=True) # 使用全模式进行分词 生成列表 print('全模式分词结果：', '/'.join(seg_list)) # /拼接列表元素 全模式分词结果： 我/来到/了/西北/皇家/理工/理工学/理工学院/工学/工学院/学院/，/发现/这儿/真不/真不错/不错 设置参数cut_all为False：精确分词
import jieba str1 = '我来到了西北皇家理工学院，发现这儿真不错' seg_list = jieba.cut(str1, cut_all=False) # 使用精确模式进行分词 print('精确模式分词结果：', '/'.join(seg_list)) 精确式分词结果： 我/来到/了/西北/皇家/理工学院/，/发现/这儿/真不错 cut_all参数不给定时，默认为false，即精确分词
import jieba str1 = '我来到了西北皇家理工学院，发现这儿真不错' seg_list = jieba.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e75229b6472c08ae305e934b0068982/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/952d3e5f4cdc4aa596a64ec9d2b38604/" rel="bookmark">
			C&#43;&#43;快速实现去掉数组中重复元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++数组去重基础知识
#include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;functional&gt; #include&lt;cassert&gt; using namespace std; vector&lt;int&gt;alls; vector&lt;int&gt;::iterator it_1=alls.begin(); vector&lt;int&gt;::iterator it_2=alls.end(); vector&lt;int&gt;::iterator new_end; //all.erase(unique(alls.begin(),alls.end(),alls.end())) ;//去掉重复元素 void myPrint(int val) { cout&lt;&lt;val&lt;&lt;" "; } void test01() { alls.push_back(1); alls.push_back(3); alls.push_back(3); alls.push_back(4); alls.push_back(5); alls.push_back(6); alls.push_back(6); alls.push_back(7); //利用sort进行升序 sort(alls.begin(),alls.end());//将所有值排序 for_each(alls.begin(),alls.end(),myPrint); cout&lt;&lt;endl; //改变为降序 sort(alls.begin(),alls.end(),greater&lt;int&gt;());//将所有值排序 for_each(alls.begin(),alls.end(),myPrint); cout&lt;&lt;endl; //new_end=unique(it_1, it_2); //unique 返回去重后最后一位数 alls.erase(new_end,it_2); //erase释放重复元素 alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素 for_each(alls.begin(),alls.end(),myPrint); cout&lt;&lt;endl; } int main() { test01(); return 0; } push_back()函数的用法
函数将一个新的元素加到vector的最后面，位置为当前最后一个元素的下一个元素
push_back() 在Vector最后添加一个元素（参数为要插入的值）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/952d3e5f4cdc4aa596a64ec9d2b38604/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b717ec0cac5a3de07d219810e9739328/" rel="bookmark">
			表单自定义校验规则失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个表单自定义校验规则，我遇到的问题是当我没有选择位置的时候会报请输入位置，但是当我选择了位置之后，还是依然再报错（请输入具体位置）
但是呢，打卡直径却不会，为什么呢 因为他是表单 el-input 绑定了v-model值，故有检测到
而我的打卡位置这里表单是没有绑到值，我初始的值是 rowData={}，
经过改进之后，初始的值为 rowData = {address:' '}, 这就解决了表单绑定失效的问题。
以上出现的原因在于，表单验证绑定值是结合 &lt;el-input /&gt;标签 使用的，而我没有，而是使用了其它标签，故失效了 因此我们只需要自己在定义值的时候给值就行 rowData = {address:' '},
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5c547f8f40ddd74877390827b315e5b/" rel="bookmark">
			net view 时报错 发生系统错误 6118
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关闭系统防火墙 按Windows键，找到设置
在设置中搜索defender
点击启动或关闭防火墙，两个都关掉
win+R ,输入services.msc 开启服务：Server ，WorkStation，computer Browser 3. 如果电脑没有computer Browser服务，win+R 输入appwiz.cpl ,选择启用或关闭Windows功能，选择SMB1.0/CIFS 文件共享支持，重启电脑。然后开启以上3个服务
重启电脑
正常使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d982f60bf6af216884fbd2c4fd636bf/" rel="bookmark">
			LeetCode刷题 第七天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode 344 看到题目的第一想法
使用双指针的方式，交换前后字符即可看完题解后的想法
采用双指针 class Solution { public void reverseString(char[] s) { for(int i=0,j=s.length-1;i&lt;j;i++,j--){ char temp=s[i]; s[i]=s[j]; s[j]=temp; } } } 遇到的困难
无 LeetCode 541 看到题目的第一想法
对不同的类型分别进行处理，首先剥离出一个翻转字符串的函数，然后分别对前2K的前K个进行翻转，大于k的翻转不足2K，翻转前k，不足k的，全部翻转，这样的话条件变复杂看完题解后的想法
每次向前遍历的时候不要挨个挨个遍历，可以直接跳跃2k，然后判断前k翻转，之后不足k的到尾部了，全部翻转即可 class Solution { public void reverSubString(char[] arr, int start, int end){ for(int i=start,j=end;i&lt;j;i++,j--){ char temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; } } public String reverseStr(String s, int k) { char[] c = s.toCharArray(); for(int i=0;i&lt;s.length();i+=(2*k)){ if(i+k&lt;=s.length()){ reverSubString(c,i,i+k-1); continue; } reverSubString(c,i,c.length-1); //不足k } return new String(c); } } 遇到的困难
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d982f60bf6af216884fbd2c4fd636bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f58c3ca737ea56f7621cd172a6fd5d/" rel="bookmark">
			EPON和GPON的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EPON和GPON的区别
1、引言
多年来，业界一直认为PON是接入网未来发展的方向，这一方面是由于它提供的带宽可以满足现在和未来各种宽带业务的需要，因此在解决宽带接入问题上被普遍看好;另一方面，无论在设备成本还是运维管理开销方面，其费用也相对较低。PON的网络结构非常简单，其技术上的复杂性主要在于信号处理技术。在下行方向，局端设备/OLT发出的信号是广播式发给所有的远端用户/ONU(单点发送，多点接收)，各用户需要从中取出发给自己的数据。在上行方向，由于各用户/ONU共享一根干路光纤(多点发送，单点接收)，就必须采用某种多址接入协议，如:TDMA(time division multiple access，时分多址访问)协议，来避免发生信号冲突，实现多用户对共享传输通道的访问。
目前，有两个颇为引人注目的PON标准已正式发布，其中一个是由ITU/FSAN制定的Gigabit PON(GPON)标准，另一个是由IEEE 802.3ah工作组制定的Ethernet PON(EPON)标准。在PON技术已被毋庸置疑地认为是未来FTTH时代的终极解决方案之后，EPON和GPON谁将主导FTTH大潮已成为当前新的争论热点。
单独从某一方面的对比结果来判断哪种技术会得到规模应用是不严谨的，因此，本文将从可用带宽、技术成熟度、成本、多业务能力和安全性、QoS和OAM等方面对二者进行综合的比较。
2、PON概述
1987年英国电信公司的研究人员最早提出了PON的概念。1995年，FSAN联盟成立，目的是要共同定义一个通用的PON标准。1998年，ITU-T以155Mbit/s ATM技术为基础，发布了G.983系列APON(ATM PON)标准。同时各电信设备制造商也研发出了APON产品，目前在北美、日本和欧洲都有APON产品的实际应用。但在我国由于价格较高，又受到ATM推广受阻的影响，所以APON在我国几乎没有什么应用。
2000年底，一些设备制造商成立了第一英里以太网联盟(EFMA)，提出基于以太网的PON概念----EPON，并促成IEEE在2001年成立第一英里以太网(EFM)小组，开始正式研究包括1.25Gbit/s的EPON在内的EFM相关标准。EPON标准IEEE 802.3ah已于2004年6月正式颁布。我国在“十五”“863”计划中也设立了吉比特EPON的相应课题。
2001年底，FSAN更新网页把APON更名为BPON，即“宽带PON”。实际上，在2001年1月左右EFMA提出EPON概念的同时，FSAN也开始进行1Gbit/s以上的PON-GPON标准的研究，2003年3月ITU-T颁布了描述GPON总体特性的G.984.1和ODN物理媒质相关(PMD)子层的G.984.2 GPON标准，2004年3月和6月发布了规范传输汇聚(TC)层的G.984.3和运行管理通信接口的G.984.4标准。
3.EPON
无源光网络（PON）的概念由来已久，它具有节省光纤资源、对网络协议透明的的特点，在光接入网中扮演着越来越重要的角色。同时，以太网 （Ethernet）技术经过二十年的发展，以其简便实用，价格低廉的特性，几乎已经完全统治了局域网，并在事实上被证明是承载IP数据包的最佳载体。随 着IP业务在城域和干线传输中所占的比例不断攀升，以太网也在通过传输速率、可管理性等方面的改进，逐渐向接入、城域甚至骨干网上渗透。而以太网与PON 的结合，便产生了以太网无源光网络（EPON）。它同时具备了以太网和PON的优点，正成为光接入网领域中的热门技术。
目前IPTV业务已逐渐成熟，各大电信运营商目前都在进行网络改造以便支持视频业务的开展，已经开展IPTV业务的哈尔滨网通在2005年中的6个月内时 间就发展了5万多电视用户，无疑给广电带来强大的竞争压力；广电总局于2006年3月CCBN会议上也提出了广电网络的未来出路就是“高清”和“交互”， 但由于高清电视业务受到各方面如节目源、网络等等的限制，目前难于大规模应用。所以在高清电视还没有出现之前，数字电视的关键业务将是互动电视. 从模拟到数字化的改造，实现广电的数字化整体平移，策略上应该首先进行互动电视的平移，并逐步实现全面数字化的转移。
众所周知，广电系统在视频业务、网络资源和用户资源方面有突出的优势，但是目前广电网络是一张单向的网络,而构建互动电视平台需要高带宽双向网络来支撑， 所以广电网从单向网改造为交互网已是迫在眉睫。在过去几年里面，一种是利用有线铜轴电缆上网的技术主要是CMTS+CM方案，国际标准为 DOCSIS1.0,1.1,2.0,现在最新的为DOCSIS3.0；另一种是采用以太网的方式解决。但由于上述两种方式存在着种种不足之处，在广电一 直未得到大规模的商用。
光纤作为传输高速率、大容量、多业务的最佳媒质，目前光缆的价格和寿命已经远优于电缆，并且设备的适应性和带宽扩展性更是电缆不可及，FTTX技术的成熟 和需求的增长为广电系统提供了新的发展契机，广电在光纤网络资源和入户线路资源方面占有很大优势，选择FTTX技术来发展双向网络已越来越多的被证实和采 用。
目前实现FTTX的最佳方案是EPON技术，EPON作为一种新兴的接入网技术，非常适合光纤接入网络（FTTB/FTTH）建设，同时EPON点到多点 的网络结构也类似广电网络结构； EPON网络不但可以独立组网，实现基于IP的数据、话音和视频业务，还可以通过WDM技术在同一个光网络中实现1550波长的有线节目传输；通过 EPON系统可以将HFC系统升级改造为一个全交换的网络平台，使HFC网络真正成为三网合一的网络。
3.GPON
英文“无源光网络”的缩写。而GPON(Gigabit-Capable PON) 最早由FSAN组织于2002年9月提出，ITU-T在此基础上于2003年3月完成了ITU-T G.984.1 和G.984.2的制定，2004年2月和6月完成了G.984.3的标准化。从而最终形成了GPON的标准族。 基于GPON技术的设备基本结构与已有的PON类似，也是由局端的 OLT(光线路终端)，用户端的ONT/ONU(光网络终端或称作光网络单元 )，连接前两种设备由单模光纤(SM fiber)和无源分光器(Splitter)组成的ODN(光分配网络)以及网管系统组成。
对于其他的PON标准而言，GPON标准提供了前所未有的高带宽，下行速率高达2.5Gbit/s，其非对称特性更能适应宽带数据业务市场。提供QoS的全业务保障，同时承载ATM信元和(或)GEM帧，有很好的提供服务等级、支持QoS保证和全业务接入的能力。承载GEM帧时，可以将TDM业务映射到GEM帧中，使用标准的 8kHz(125μs)帧能够直接支持TDM业务。作为电信级的技术标准，GPON还规定了在接入网层面上的保护机制和完整的OAM功能。
在GPON标准中，明确规定需要支持的业务类型包括数据业务(Ethernet 业务，包括IP业务和MPEG视频流)、PSTN业务(POTS，ISDN业务) 、专用线(T1，E1，DS3， E3和ATM业务)和视频业务( 数字视频)。GPON中的多业务映射到ATM 信元或GEM帧中进行传送，对各种业务类型都能提供相应的QoS保证。
下面将对GPON和EPON这两种PON技术和产品进行详细比较。
3、上行可用带宽
从系统上行传输总带宽中减去各种系统运行开销就是上行可用带宽。它与系统中包含的ONU数量、DBA(动态带宽分配)算法的轮询周期、承载业务的类型以及各业务所占比例等都有很大关系。
EPON和GPON都是宽带接入技术，承载的业务以IP数据业务为主。
下面将分别计算EPON和GPON在包含32个ONU，轮询周期为750s的情况下，承载纯IP业务时的上行可用带宽。
EPON的上行线路速率是1.25Gbit/s，因为采用了8B/1OB线路编码，每10bit中有8bit有效数据，所以其有效上行传输总带宽为1Gbit/s，即1000Mbit/s。
EPON上行的系统运行开销及其占总带宽的比例如下:
*用于突发接收的物理层开销:约3.5%;
*以太网帧的封装开销:约7.4%;
*MPCP(多点控制协议)和OAM(运行管理维护)协议开销:约2.9%;
*DBA算法造成的剩余时隙(即不足以传输一个完整以太网帧的时隙)浪费:约0.6%;
EPON上行总开销为上述开销之和，约为144Mbit/s，可用带宽约为856Mbit/s(即1000Mbit/s-144Mbit/s)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80f58c3ca737ea56f7621cd172a6fd5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/907465642ad516420a600d5fb04fa9fb/" rel="bookmark">
			Linux内核学习 篇-00：构建学习环境并运行一个HelloWorld模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“Linux内核学习”系列博文致力为每一位有兴趣学习Linux内核的同志排除学习道路上的障碍，给大家提供最好的帮助，补足市面上各种材料书籍解释不周、报错多等问题。
本系列博文使用的系统版本和编译器版本等均在《Linux内核学习 篇-00》中有详细介绍。
目录 注意事项正文[一] 环境搭建[1] 下载安装虚拟机/Ubuntu[2] 安装GCC、VIM等必要工具 [二] 重新编译内核[三] 编写并加载一个helloworld模块 后话报错 注意事项 本系列博文默认您有一定的：Linux、VIM、C、操作系统基础。为了方便大家的阅读学习，可能会引用其他博文资讯中的内容，所有引用都会将来源附在文末。如果参考本文学习过程中遇到任何报错或问题，欢迎您在评论区发起提问，我会将所有问题的原因以及解决方法完善在对应博文的“后话”中，感谢您的贡献。持续更新中，欢迎点赞收藏关注，三连不迷路。 正文 笔者平时学习生活使用的是Ubuntu，抱着更了解自己的系统，甚至定制属于自己的内核功能等愿望，开始了Linux内核的学习。最初，我直接在工作机上进行各种操作。但是频繁遇到各种问题，诸如：内核编译器版本与模块编译器版本不一致等，这些都会导致内核模块无法加载。
因此笔者建议：即使您平时就是使用Linux的各种发行版进行工作学习，为了保证不破坏自己的环境，请专门搭建一个全新的Linux虚拟机，用来学习接下来的内容。我认为这是完全值得的。
[一] 环境搭建 [1] 下载安装虚拟机/Ubuntu 本系列博文使用的镜像/软件版本如下，可以点击直接下载：
虚拟机：VMware Workstation Pro 16.2.2
Ubuntu：ubuntu-22.04.1-live-server-amd64
Ubuntu建议用种子，会比HTTP快一点。
安装过程很简单，在网络设置环节需要手动DHCP一下，在DISK设置环节需要取消第二个X，不再赘述，不熟悉的同志可以搜索：虚拟机安装Ubuntu live server
[2] 安装GCC、VIM等必要工具 为了尽可能避免奇怪的问题，我决定不进行换源操作，直接进行安装
sudo apt update sudo apt upgrade sudo apt install gcc vim make libncurses-dev flex bison libssl-dev libelf-dev dwarves [二] 重新编译内核 进行内核学习和开发的第一步是配置和重新编译内核，这么做为了以后各种工具的版本问题，也可以让我们先熟悉一下内核的编译启用过程。
首先运行uname -r查看当前内核版本
然后运行sudo apt install linux-source-5.15.0，下载Linux内核代码。请将版本号替换为您自己的内核版本。
下载好后，进入以下目录进行解压和配置：
cd /usr/src/linux-source-5.15.0 sudo tar -xjvf linux-source-5.15.0.tar.bz2 cd linux-source-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/907465642ad516420a600d5fb04fa9fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf1c9f70f5d35804005b401c1560c13e/" rel="bookmark">
			【educoder 机器学习】线性回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性回归是属于机器学习里面的监督学习，与分类问题不同的是，在回归问题中，其目标是通过对训练样本的学习，得到从样本特征到样本标签直接的映射，其中，在回归问题中，样本的标签是连续值。线性回归是一类重要的回归问题。在线性回归中，目标值与特征直接存在线性关系。
本实训项目的主要内容是基于Python语言搭建出一个线性回归模型，训练出一个能够对房价进行预测的模型。
第1关：简单线性回归与多元线性回归 1.B C 第2关：线性回归的正规方程解 任务描述 本关任务：构建线性回归算法，并利用波斯顿房价数据对模型进行训练，然后对未知的房价数据进行预测。
#encoding=utf8 import numpy as np def mse_score(y_predict,y_test): ''' input:y_predict(ndarray):预测值 y_test(ndarray):真实值 ouput:mse(float):mse损失函数值 该方法计算损失 ''' #********* Begin *********# s = np.square(y_test - y_predict).sum() m = len(y_test) mse = s/m #print(mse) #********* End *********# return mse class LinearRegression : def __init__(self): '''初始化线性回归模型''' self.w = None def fit_normal(self,train_data,train_label): ''' input:train_data(ndarray):训练样本 train_label(ndarray):训练标签 该方法求解计算self.w的值 ''' #********* Begin *********# '''将偏置与train_data拼接到一起 (我们输入特征中并没有那个1，所以我们需要人为的加上去) &lt;np.ones()表示生成一个行数与train_data一致，列数等于1且所有元素都是1的矩阵&gt;''' x = np.hstack([np.ones((len(train_data),1)), train_data]) #print(train_data) y = train_label #print(train_label) #用正规方程求解参数 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf1c9f70f5d35804005b401c1560c13e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/968123ec8907110d5964e23d57ff4444/" rel="bookmark">
			【神经网络与深度学习day10-基于torch使用Lenet实现手写数字识别】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络与深度学习day10-基于pytorch：LeNet实现MNIST 5.3 基于LeNet实现手写体数字识别实验5.3.1 MNIST数据集5.3.1.1 数据集介绍5.3.1.2 数据集导入 5.3.2 模型构建5.3.2.1 **使用自定义算子，构建LeNet-5模型**5.3.2.2 **使用pytorch中的相应算子，构建LeNet-5模型**5.3.2.3模型测试5.3.2.4 测试两个网络的运算速度。5.3.2.5 测试两个网络的运算结果5.3.2.6 统计LeNet-5模型的参数量和计算量。5.3.2.7 paddle可以统计Floats,torch可以吗？ 5.3.3 模型训练5.3.4 模型评价5.3.5 模型预测 使用前馈神经网络实现MNIST识别，与LeNet效果对比。（选做）可视化LeNet中的部分特征图和卷积核，谈谈自己的看法。（选做）总结Rerferences: 5.3 基于LeNet实现手写体数字识别实验 5.3.1 MNIST数据集 5.3.1.1 数据集介绍 手写体数字识别是计算机视觉中最常用的图像分类任务，让计算机识别出给定图片中的手写体数字（0-9共10个数字）。由于手写体风格差异很大，因此手写体数字识别是具有一定难度的任务。
我们采用常用的手写数字识别数据集：MNIST数据集。
我们可以从这里下载手写数字识别数据集：MNIST
MNIST数据集是计算机视觉领域的经典入门数据集，包含了60,000个训练样本和10,000个测试样本。
这些数字已经过尺寸标准化并位于图像中心，图像是固定大小(28×28像素)。
LeNet-5虽然提出的时间比较早，但它是一个非常成功的神经网络模型。
基于LeNet-5的手写数字识别系统在20世纪90年代被美国很多银行使用，用来识别支票上面的手写数字。
导入数据集代码如下：
import json import gzip # 打印并观察数据集分布情况 train_set, dev_set, test_set = json.load(gzip.open('./mnist.json.gz')) train_images, train_labels = train_set[0][:3000], train_set[1][:3000] dev_images, dev_labels = dev_set[0][:200], dev_set[1][:200] test_images, test_labels = test_set[0][:200], test_set[1][:200] train_set, dev_set, test_set = [train_images, train_labels], [dev_images, dev_labels], [test_images, test_labels] print('Length of train/dev/test set:{}/{}/{}'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/968123ec8907110d5964e23d57ff4444/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ffa51be78daaa4a0bf23cdc423adf69/" rel="bookmark">
			C/C&#43;&#43;编程：protected的访问权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在没有继承的情况下，protected跟private相同。在派生类的时候才出现分化
基类对象不能访问基类的protected成员，派生类中可以访问基类的protected成员。也就是说private成员是不能被继承的，只有public，protected的成员才可以被继承
只有在派生类中才可以通过派生类对象访问基类的protected成员
#include &lt;iostream&gt; using namespace std; class base { public: base() {} virtual ~base() {} protected: int int_pro; // 基类可以访问自己所有的东西 }; class derived : public base { public: derived() {} ~derived() {} void Print(derived &amp;obj){obj.int_pro = 24;} //void Print(base &amp;obj){obj.int_pro = 24;} void foo(){ this-&gt;int_pro = 1; // 这里访问m没有问题 ---&gt; 继承了父类的protected } }; int main() { base *pBase = new base; // pBase-&gt;int_pro = 11; // 错误：‘int base::int_pro’是保护的 ---&gt; 基类对象不能访问基类的protected成员 derived *pderived = new derived; // pderived-&gt;int_pro = 11; // 自己的对象都不能访问，怎么可能让继承者访问 delete pBase; return 0; } private: 只能被类成员函数及友元访问，不能被其他任何访问，本身的类对象也不行。protected: 只能被类成员函数、子类函数及友元访问，不能被其他任何访问，本身的类对象也不行。public: 能被类成员函数、子类函数、友元访问，也能被类的对象访问。 派生类的成员和友元只能通过派生类对象访问基类的受保护成员，不能直接访问基类对象的受保护成员。如： class Base{ protected: int val; }; class Derived:public Base{ friend void f1(Base&amp;); friend void f2(Derived&amp;); }; void f1(Base &amp;b) {b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ffa51be78daaa4a0bf23cdc423adf69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c21e0256ecb476c527db0a3c2ef29ef/" rel="bookmark">
			时间序列分析|逐步预测与多步预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言数据预处理auto_arima多步预测auto_arima逐步预测结果对比SARIMAX多步预测SARIMAX逐步预测结论参考文献 前言 在做时间序列预测的时候，很多场景不只是要预测下一期的结果，称为单期预测，更多的场景是要预测未来好几期的结果，称为多期预测，与单期预测不同，多步预测对输入资料要求更高，更能看出模型的稳健性。针对多期预测，可以一次性多步预测，也可以逐步预测，这一期，我们就来看一下auto_arima下两者的区别，为此我们先做一些预处理工作。
数据预处理 import datetime import time import pandas as pd import pmdarima as pm import numpy as np import matplotlib.pyplot as plt from statsmodels.tsa.stattools import adfuller from sklearn.metrics import mean_absolute_error from tsod import RangeDetector,GradientDetector,ConstantGradientDetector,RollingStandardDeviationDetector,DiffDetector air_passenger = pd.read_csv(r"D:\项目\时间序列\air_passenger.csv") #读取数据 air_passenger['date'] = pd.to_datetime(air_passenger['date']) #datetime格式化 air_passenger = air_passenger[["date", "passenger"]].sort_values(by="date") #按日期升序排序 air_passenger.set_index("date", inplace = True) #重置索引, 将date_设置为索引index ts = air_passenger["passenger"] #乘客人数序列 # print("原序列\n", ts) ts_rolling = ts.rolling(window = 7).mean() #7阶截尾滑动平均 ts_rolling_std = ts_rolling.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c21e0256ecb476c527db0a3c2ef29ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a84f812436b78db7a5652bb91fb4222/" rel="bookmark">
			【附源码】计算机毕业设计java学生在线请假管理系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
SSM + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
3.1 系统可行性分析及目的 3.1.1经济可行性 首先就开发技术来说，开发系统所借助的开发环境都是全部免费的，所以在开发的过程中并不需要额外的成本去使用其他的一些开发技术。其次，此系统需要的电脑都是很普遍的，用户和管理人员都具有电脑，所以不需要额外佩备；网络可以使用当地的无线网络或者手机的数据流量，所以成本较低，是可以接受的。学生在线请假管理系统的开发不仅可以节约学校所需要的花费，节约资源，还可以更好的管理人员。
3.1.2 法律可行性
系统平台的设计与开发与国家政策法规之间不存在冲突。此外，平台的设计和开发采用的操作和工作模式符合用户的日常习惯，操作方便、灵活、易于管理，具有较高的实用性。开发过程中所采用的数据均来自开源代码，不存在知识产权的争议，在法律上也是行的通的。
3.1.3 技术可行性 本系统开发选择JSP技术，它被研究的目的就是在于能够为网页创建等可以看到的信息。随着移动互联网技术的不断发展和创新，JSP技术已成为下一代互联网的Web标准。JSP在网页制作中各方面的优势都较明显，网页前端开发者更倾向于将它与CSS3整合一起，这种整合将会促进交互性良好的网页产生。JSP的开发存在很多优势如:绘制图形、多媒体、页面结构优化、处理方式优化以及几个api拖放元素等。CSS是级联样式表，它的作用是控制页面里每一个元素的表现形式，比如字体样式、背景、排列方式、区域尺寸、边框等。所以后台设计选择使用MYSQL数据库主要用来的建立和维护信息。对于后台开发要求应具备功能完善、易于操作等优点，后台数据库的要求则是能够建立和维护数据信息的统一性和完整性。
3.1.4 操作可行性 现在随着科技的飞速发展，计算机早已经进入了人们的日常生活中，人们的工作环境也不像以前有那么多的要求，这使得人们的工作效益有了很大的提高。操作的多样性也变高了。因此，管理的计算机化，智能化是社会发展而带来的必然趋势，各种智能的软件层出不穷，不同的软件能完成用户不同的需求，提高了工作效率。本系统不仅界面简洁明了还采用可视化界面，用户只要用鼠标和键盘就可以完成对相关信息的修改，删除，添加等操作。因为这个系统的操作十分简单，方便上手，对于第一次使用系统的人，只需要很少的时间就可以上手操作。由此可见，本系统在操作上是可行的。
3.2系统功能需求 功能需求分析的任务是通过详细调查学生在线请假管理系统要处理的所有对象，通过充分了解学生在线请假管理系统的工作流程，明确使用者的各种需求，充分思考之后可能扩充和改变的情况，然后在这个基础上来设计数据库。
3.2.1 学生模块
学生登录之后，进入系统，可以查看到首页、个人中心、学生请假管理、辅导员审批管理 等。学生用例图如图3-1所示：
图3-1 学生用例图
3.2.2 教师模块
教师登录之后，进入系统，可以查看到首页、个人中心、学生管理、学生请假管理、辅导员审批管理等。教师用例图如图3-2所示：
图3-2 教师用例图
3.2.3 辅导员模块
辅导员登录之后，进入系统，可以查看到首页、个人中心、学生管理、教师管理、辅导员审批管理等。辅导员用例图如图3-3所示：
图3-3辅导员用例图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a84f812436b78db7a5652bb91fb4222/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aae8f7d4d1dcd3cb6861f3a41f0db175/" rel="bookmark">
			基于ubuntu 20.04与cri-docker 搭建部署高可用k8s 1.25.3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、overlay简介
二、overlay通信过程 三、overlay应用场景
四、underlay简介
五、underlay实现模式简介
六、MAC Vlan工作模式
七、kubernetes pod通信总结
八、underlay实验案例
8.2、安装docker环境 8.3、安装cri-docker
8.4、集群初始化准备
8.5、初始化集群 8.6、添加集群节点
8.6.2、添加node节点
九、安装underlay网络组件
9.2、部署hybridnet 一、overlay简介 VxLAN： VxLAN全称是Virtual eXtensible Local Area Network（虚拟扩展本地局域网） ,主要有Cisco推出， vxlan是一个 VLAN 的扩展协议， 是由IETF定义的NVO3（Network Virtualization over Layer 3） 标准技术之一，VXLAN的特点是将L2的以太帧封装到UDP报文（即L2 over L4） 中， 并在L3网络中传输， 即使用MAC in UDP的方法对报文进行重新封装, VxLAN 本质上是一种overlay的隧道封装技术， 它将L2的以太网帧封装成L4的UDP数据报，然后在L3的网络中传输， 效果就像L2的以太网帧在一个广播域中传输一样， 实际上L2的以太网帧跨越了L3网络传输， 但是缺不受L3网络的限制， vxlan采用24位标识vlan ID号， 因此可以支持2^24=16777216个vlan， 其可扩展性比vlan强大的多， 可以支持大规模数据中心的网络需求。VTEP(VXLAN Tunnel Endpoint vxlan隧道端点),VTEP是VXLAN网络的边缘设备， 是VXLAN隧道的起点和终点， VXLAN对用户原始数据帧的封装和解封装均在VTEP上进行,用于VXLAN报文的封装和解封装,VTEP与物理网络相连,分配的地址为物理网IP地址,VXLAN报文中源IP地址为本节点的VTEP地址，VXLAN报文中目的IP地址为对端节点的VTEP地址， 一对VTEP地址就对应着一个VXLAN隧道， 服务器上的虚拟交换机(隧道flannel.1就是VTEP)， 比如一个虚拟机网络中的多个vxlan就需要多个VTEP对不同网络的报文进行封装与解封装。VNI（VXLAN Network Identifier） ： VXLAN网络标识VNI类似VLAN ID,用于区分VXLAN段,不同VXLAN段的虚拟机不能直接二层相互通信,一个VNI表示一个租户,即使多个终端用户属于同一个VNI,也表示一个租户。NVGRE： Network Virtualization using Generic Routing Encapsulation， 主要支持者是Microsoft， 与VXLAN不同的是， NVGRE没有采用标准传输协议（TCP/UDP） ， 而是借助通用路由封装协议（GRE） ， NVGRE使用GRE头部的低24位作为租户网络标识符（TNI） ， 与VXLAN一样可以支持1777216个vlan。 二、overlay通信过程 VM A发送L2 帧与VM请求与VM B通信。源宿主机VTEP添加或者封装VXLAN、 UDP及IP头部报文。网络层设备将封装后的报文通过标准的报文在三层网络进行转发到目标主机。目标宿主机VTEP删除或者解封装VXLAN、 UDP及IP头部。将原始L2帧发送给目标VM。 三、overlay应用场景 叠加网络/覆盖网络， 在物理网络的基础之上叠加实现新的虚拟网络， 即可使网络的中的容器可以相互通信。优点是对物理网络的兼容性比较好， 可以实现pod的夸宿主机子网通信。calico与flannel等网络插件都支持overlay网络。缺点是有额外的封装与解封性能开销。目前私有云使用比较多。 四、underlay简介 1、Underlay网络就是传统IT基础设施网络， 由交换机和路由器等设备组成， 借助以太网协议、 路由协议和VLAN协议等驱动， 它还是Overlay网络的底层网络， 为Overlay网络提供数据通信服务。 容器网络中的Underlay网络是指借助驱动程序将宿主机的底层网络接口直接暴露给容器使用的一种网络构建技术，较为常见的解决方案有MAC VLAN、 IP VLAN和直接路由等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aae8f7d4d1dcd3cb6861f3a41f0db175/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9014ee61b38b7363bae6addb6c09d2ed/" rel="bookmark">
			Linux 基本指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 传统艺能😎Linux 起源🤔理解与应用🤔OS🤔为什么要指令操作🤔基本指令🤔ls命令🎉-a指令🎉文件路径🎉 cd-指令🤔mkdir指令🤔rm指令🤔 传统艺能😎 小编是双非本科大一菜鸟不赘述，欢迎大佬指点江山（QQ：1319365055）
此前博客点我！点我！请搜索博主 【知晓天空之蓝】
🎉🎉非科班转码社区诚邀您入驻🎉🎉
小伙伴们，打码路上一路向北，背后烟火，彼岸之前皆是疾苦
一个人的单打独斗不如一群人的砥砺前行
这是我和梦想合伙人组建的社区，诚邀各位有志之士的加入！！
社区用户好文均加精（“标兵”文章字数2000+加精，“达人”文章字数1500+加精）
直达： 社区链接点我
🎉🎉🎉倾力打造转码社区微信公众号🎉🎉🎉
Linux 起源🤔 这篇文章算是入坑 Linux 的第一篇文章，本来想写一个开头篇，但感觉这么写可能会写成一篇历史和人物传记，于是打算整合到这里一起写了。
既然学习Linux，那就要知道什么是Linux：
Linux 是一种自由和开放源码的类 UNIX 操作系统，Linux 英文解释为 Linux is not Unix。Linux 是在 1991 由林纳斯·托瓦兹在赫尔辛基大学上学时创立的，主要受到 Minix 和 Unix 思想的启发。
也就是Linux之父 Linus 的灵感源自于C语言之父和 Unix 之父，他之所以会创造 Linux 正是因为他厌恶 Windows 和乔布斯的 IOS 系统，他觉得对操作系统垄断收费是不合理的，他的愤怒瞬间招来了志同道合的顶级黑客，民间高手，论坛精英等贤士一起开发出了面向大众的免费高性能操作系统—— Linux，最伟大的生产方式==“开源”==也随之诞生，这也是为什么林纳斯是乔布斯的一生之敌，他让乔布斯每年活生生亏损几十亿。
理解与应用🤔 Linux 应用极其广泛，对于 Linux 有人修改操作系统写源代码，有人直接拿来用进行改造与提升做应用级的开发，总之都会选择一款 Linux 内核。现在如雷贯耳的鸿蒙系统，红帽（centos），Ubuntu，kali 都是 Linux 的杰作。而 Linux 应用场景极为丰富，服务器后台，嵌入式，树莓派，物联网，智能家电等等都是基于 Linux 开发的。
对于Linux不得不谈的是“开源”这个概念，我愿称之为最超前最伟大也是最理想的生产方式，以无尽的知识为资本流入，每个人不求回报不遗余力的投入，最后以经济和科技的纯利润流出，我就问还有谁。
代码开源相比代码闭源反而还更安全，更高效，更稳定，因为这个代码会面向全世界的人才，有问题会立马解决并得到优化方案，而闭源面对的是有限的技术力和素质参差不齐的内部人员，这也是为什么很多商业公司闭源代码反而会有代码维护的困扰。
OS🤔 OS 即操作系统，操作系统是在计算机（硬件）之后诞生的，单纯的硬件计算机最开始并不是所有人都能用的而是给科学家用的，虽然就是就是已经具备超过人脑的计算能力但是他的操作十分麻烦，难度高效率低，所以 OS 存在的首要理由就是提高计算机效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9014ee61b38b7363bae6addb6c09d2ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b6eda773a18ffddc3f6b734fe38c089/" rel="bookmark">
			@Aspect的pom文件配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8761962bd651cc2cd5ff683708bfdbf/" rel="bookmark">
			Spyder无法导入自定义模块的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spyder无法导入自定义模块的问题 今天在写代码的过程中遇到了无法加载自己写的模块的问题，报错如下：
经过查看大佬们的博客，发现问题症结所在，主要存在以下的几种情况。
1.直接import 这种情况是：当前执行的py文件与自定义的模块在同一个目录下，才能使用import直接导入模块
2. 使用sys导入自定义模块的路径 这种情况是：当前执行的py文件与自定义的模块不在同一个目录下，仅仅使用Import无法直接找到自定义的模块，此时在当前执行文件中使用如下代码导入自定义模块的路径：
import sys sys.path.append('D:\\Data\\PyCharmProjects\\......') 3.添加pth文件 创建一个属于某一自定义模块的pth文件，如test_module.pth，该文件中的内容为test模块所在目录的路径，如
D:\Data\PyCharmProjects\Data_forecasting_8.5\proc_data
将该pth文件放入 D:\APP\python\Lib\site-packages下，再用import直接导入即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2508bd069c0c65efca31db8e31c5cdb7/" rel="bookmark">
			java中Collection集合元素的排序：自定义Comparator接口作为匿名内部类，重写compare()方法进行排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Collection，一个由单独元素组成的序列，而且这些元素要符合一条或多条规则。List必须按元素插入顺序来保存它们；Set中不能存在重复元素；而Queue则要按照排队规则来输出元素（通常与元素插入的顺序相同）。
因为有时java中Collection集合中的对象不是数字或者简单比较ASCII字符串，可以直接排序。所以我们有必要学习自定义Comparator，重写compare()方法进行排序。
**建议使用重载的public static void sort(List list，Comparator&lt;? super T&gt; )方法灵活的完成集合的排序操作，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一，该接口代表一个比较器，比较器具有可比性！ 举例如下：
public class CollectionSortDemo { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("13wwdkn xmcadla"); list.add("13wwdkn"); list.add("xmcadla"); System.out.println(list);//[13wwdkn xmcadla, 13wwdkn, xmcadla] Collections.sort(list , new Comparator&lt;String&gt;() { public int compare(String o1, String o2) { return o1.length() - o2.length(); } }); System.out.println(list);//[13wwdkn, xmcadla, 13wwdkn xmcadla] } } 其中创建了匿名内部类、重写compare（）方法如下。
Collections.sort(list , new Comparator&lt;String&gt;() { /** 返回值实现的要求：------不用纠结，去记下面的结论即可 1）如果返回值 &gt; 0，则表达式o1 &gt; o2 2) 如果返回值 &lt; 0，则表达式o1 &lt; o2 3) 如果返回值 ＝ 0，则表达式 o1 = o2 结论： 1）前面的（o1）-后面的（o2）----------升序 2）后面的（o2）-前面的（o1）----------降序 **/ public int compare(String o1, String o2) { return o1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2508bd069c0c65efca31db8e31c5cdb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad2838e73fb605e572d37c91b2117bb/" rel="bookmark">
			那些Java中原子类的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 原子整型1.1 cas操作1.2 加减操作1.3 更新操作 2. 原子引用3. 原子数组4. 原子更新器5. 原子累加器 原子类都是线程安全的，所以这里没有用加入多线程来验证，只是简单api调用，毕竟先要会用嘛。 1. 原子整型 1.1 cas操作 写在开头，我以原子整型为例，先介绍一个重要的方法compareAndSet，其他方法其实都是这个方法的拓展。
这个方法其实就是CAS操作，比较并设置值，但我们需要反复比较预期值和最新值是否相同，如果比对相同，才可以将值更新，否则会再次进入循环，判断。
public class Demo1 { public static void main(String[] args) { AtomicInteger ai = new AtomicInteger(); set(ai, 10); System.out.println(ai.get());//10 } /** * 传入原子整型 将值更新 * @param ai 原子整型 * @param value 要修改的值 */ public static void set(AtomicInteger ai,int value) { while (true) { int except = ai.get(); //比较并设值 if (ai.compareAndSet(except,value)) { break; } } } } 从代码中我们可以看到，ai被正确的更新了，而如果在多线程下，进入循环，except变量其实获取的不一定是最新的值，那么compareAndSet就要返回false，然后再次循环了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ad2838e73fb605e572d37c91b2117bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0a4da5b7520759032fb2aa1ce3db44d/" rel="bookmark">
			windows下apache开启FastCGI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在此链接下载一个合适的mod_fcgid 文件，64位下载第一个，32位第二个。
http://www.apachelounge.com/download/
2、将解压后将文件中的 mod_fcgid.so 复制到apache的modules目录下面。
3、打开 httpd.conf 文件，添加如下内容，并修改 “php.ini的存放目录” 以及 “php-cgi的路径” ：
LoadModule fcgid_module modules/mod_fcgid.so &lt;IfModule mod_fcgid.c&gt; AddHandler fcgid-script .fcgi .php #php.ini的存放目录 FcgidInitialEnv PHPRC "${INSTALL_DIR}/bin/php/php7.2.14/" # 设置PHP_FCGI_MAX_REQUESTS大于或等于FcgidMaxRequestsPerProcess，防止php-cgi进程在处理完所有请求前退出 FcgidInitialEnv PHP_FCGI_MAX_REQUESTS 500 #php-cgi每个进程的最大请求数 FcgidMaxRequestsPerProcess 500 #php-cgi最大的进程数 FcgidMaxProcesses 5 #最大执行时间 FcgidIOTimeout 120 FcgidIdleTimeout 120 #php-cgi的路径 FcgidWrapper "${INSTALL_DIR}/bin/php/php7.2.14/php-cgi.exe" .php AddType application/x-httpd-php .php &lt;/IfModule&gt; 4、打开 httpd-vhosts.conf 文件，修改虚拟主机配置（注意：要添加ExecCGI和Require all granted）
&lt;VirtualHost *:80&gt; ServerName localhost ServerAlias localhost DocumentRoot "F:/laravel/public" &lt;Directory "F:/laravel/public"&gt; Options Indexes FollowSymLinks ExecCGI Order allow,deny Allow from all AllowOverride All Require all granted &lt;/Directory&gt; &lt;/VirtualHost&gt; 5、重新启动 Apache
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0a4da5b7520759032fb2aa1ce3db44d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa3f419477d343998ce7253c9eaa2178/" rel="bookmark">
			12个C语言必背实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言实例第01期，十进制数转换二进制数 实例代码 // #include "stdio.h" int main(){ int m, n, k;//定义变量 int a[16] = { 0 }; printf("请输入一个0~32767之间的数字：\n"); scanf("%d", &amp;n); printf("十进制数%d转换为二进制数是:\n", n); for (int i = 0; i &lt; 15; ++i) {//for循环从0-14，最高位为符号位，本例始终为0 m = n % 2;//取2的余数 k = n / 2;//取被2整除的结果 n = k; a[i] = m;//将余数存入数组a数组中 } for (int i = 15; i &gt;=0 ; i--) {//for循环将数组中的16个元素从后往前输出 printf("%d", a[i]); if (i % 4 == 0) {//每输出4个元素，输出一个空格 printf(" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa3f419477d343998ce7253c9eaa2178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3766936087cddba85fcf8ae14e41e06f/" rel="bookmark">
			Pytorch中常见transform的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次实验练习了pytorch中数据的读取，Dataset类的使用，以及transform模块的使用。
一、Pytorch简介 PyTorch是一个开源的Python机器学习库，基于Torch，用于自然语言处理等应用程序。
2017年1月，由Facebook人工智能研究院（FAIR）基于Torch推出了PyTorch。它是一个基于Python的可续计算包，提供两个高级功能：1、具有强大的GPU加速的张量计算（如NumPy）。2、包含自动求导系统的深度神经网络。
二、Pytorch的环境配置 关于Pytorch的环境配置网上有好多教学，这里不做赘述。
三、Dataset类的基本使用 Dataset类：处理数据，提供一种方式挑选数据及其对应的label。
Dataloader类：对Dataset挑选后的数据进行打包，为后面的网络提供不同的数据形式。
1、首先导入Dataset类
from torch.utils.data import Dataset
2、创建一个类，继承Dataset类
class MyData(Dataset): def __init__(self, root_dir, label_dir): self.root_dir = root_dir self.label_dir = label_dir # os.path.join的意思是把这两个路径拼接 # 如root路径是dataset\train，label路径是ants，拼接后的结果是dataset\train\\ants self.path = os.path.join(self.root_dir, self.label_dir) # os.listdir(path) # 作用：传入任意一个path路径，返回的是该路径下所有文件和目录组成的列表； self.img_path = os.listdir(self.path) # 这个函数作用是获取其中的每一个图片 def __getitem__(self, idx): # idx是图片的索引，img_name是获取图片 img_name = self.img_path[idx] # 把图片的路径也拼接上 img_item_path = os.path.join(self.root_dir, self.label_dir, img_name) # 打开图片 img = Image.open(img_item_path) # 需要用到标签 label = self.label_dir # 返回标签和读取的图片 return img, label def __len__(self): # 返回有多少张图 return len(self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3766936087cddba85fcf8ae14e41e06f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de01016c4a763454d548d8ad3fed1825/" rel="bookmark">
			java接口可以被继承吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java接口可以被继承，而且是多继承，但是只能是接口继承接口，类只能实现接口。一个接口可以继承另一个接口或多个，一个普通类可以实现多个接口。
具体代码： interface A{ void a1(); } interface B{ void b1(); } interface C extends A,B{//注意该语法只对接口的继承是合法的 void c1(); } class D implements C{ @Override public void a1() {} @Override public void b1() {} @Override public void c1() {} } 以上就是java接口可以被继承吗的详细内容，更多请关注likekyus日记其它相关文章！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b842e8eb6060ec62ff55e3e2bb87eb0/" rel="bookmark">
			【读书笔记】《中央帝国的财政密码》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
中国经济三大底线：国有企业，公有土地制度，政府控制发钞权
三大周期：
第一周期：秦汉 到 南朝
土地私有
第二周期：北魏 到 南宋
土地公有，
第三周期：辽金 到 明清
引子 汉武帝：两千年帝国财政的教科书
汉代财政收入演进
1、土地税+人头税
2、卖爵 + 劣币（金融，铸币税）
3、杀巨富+盐铁官营，盐铁=房产（工业品）
4、杀中产+商业税+均输+平准（商业、运输、农产品）
第一章 秦代：中央帝国的诞生
历史的局限，秦代以前，大一统不是共识
建立大一统中央集权国家2个步骤：
1、军事征服
2、政治征服
变法的本质：改变经济资源配置，提高国家财政效率
国家凭借其自身的财产所有权参与社会产品分配而形成的收入， 是国家的公产收入，而不是税收。
税收是国家凭借政治权力而不是财产权力的分配。这种分配只有对那些不属于国家所有或者国家不能直接支配使用的社会产品才是必要的。
税是对私人财产的再分配
公产收入，因为积极性等原因，效率和产出都很低
税的优点在于提高了生产积极性
第二章 汉代：皇帝的财政僵局
大一统集权帝国的死穴，就在于不可避免的财政扩张
从而摧毁民间经济
中央帝国样板特征：
1、农业税税率不高（直接税）
2、农民税收负担，由隐性的工业品价格（间接税）+铸币权（通胀）
3、铸币国营垄断发行
西汉后期，人们对现实不认同，缺乏发展前景
只能在农业上度日，工商被国家垄断
王莽改制
五均：限价令，掩盖通胀
赊贷：政府放贷介入民间金融
六筦（guan三）：盐铁酒，铸钱山泽出产等国营
财政改革不畅时，推出的敛财手段
1、奴婢税，养一个3600钱
2、清查贪污，没收80%财产
3、
第四章 穿越朝代的制度惰性
任何继承前朝制度的朝代都会有行政效率低下，政府开支大却收不上税的窘境
其实是一种惯性，旧制度旧规矩的遵守
光武帝集权几大做法：
杯酒释兵权
尚书台，架空三公
不区分皇室财政和国家财政
东汉皇权衰落根本原因
通过权衡（妥协）夺取天下
光武帝的妥协
精简财政，水衡都尉（金融，铸币）被精简合并
盐铁专营中央无法经营，让渡权利给地方（收不回来了）
功臣回乡独霸地方，垄断上层，社会没有上下流动
皇后被大家族垄断（外戚）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b842e8eb6060ec62ff55e3e2bb87eb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/425545f452d389947167c41969ba3db5/" rel="bookmark">
			开发者在国内如何白嫖AWS服务器一年时间，怎样通过SSH工具连接AWS？免费的服务器有什么样的限制？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只要服务器一年快结束时，注销账号再重新注册就能再次使用一年，周而复始，无限白嫖
需要：国内信用可，未注册过AWS的邮箱
每月有多少流量？
答：100GB，AWS 客户每月可将 100GB 的数据免费传出至互联网，所有 AWS 服务和区域（中国区域和 GovCloud 区域除外）合并计算。
具体自己可以看官网Amazon EC2实例价格_EC2虚拟云服务器托管价格 - AWS云服务
第一步：注册AWS账号
AWS账号注册指南 - 知乎
进入AWS控制台，有所EC2
第一个就是，点进去
切换地区为新加坡，我试过用香港的实例ssh连接不上
切换之后进入EC2，点击实例
点击启动新实例，因为我有一个实例所以下面会显示有一个实例
操作系统选择ubuntu
实例类型这里选择免费里面最好的1G内存就行
密钥对这里，自己起一个名字创建新秘钥对，浏览器会下载秘钥
网络设置先不管，进行配置存储
把这个 8 改成 30，因为免费服务器有30G的免费磁盘，不改默认就是8G，使用了默认的创建实例后也可以修改
配置完成了，点击右边的启动实例
注意：AWS免费一年，快到一年的时候，把实例终止掉，并注销AWS账号 ，再用一个新的邮箱注册AWS，信用卡和手机号不用换也可以，这样就达到可以无限白嫖AWS服务器
启动实例后，等实例状态变为正在运行
勾选实例Name前面的勾选框
点击右上角的连接
点击右下角的连接（为什么不用前面下载的秘钥对连接，因为服务器初始化就不允许私钥连接，就算用SSH工具再怎么连接也不可以连上）
可以看到以用户名为ubuntu进入了服务器
首先要做的就是设置root新密码（ubuntu用户也可以设置新密码）
sudo passwd root 注意：linux系统输入密码它是不会显示的，上图所示root用户的密码设置成功
现在要做的就是，要允许服务器SSH允许密码连接
sudo vim /etc/ssh/sshd_config 添加记录PermitRootLogin yes
把这里的密码认证由no改为yes，我这里显示是改好的
PasswordAuthentication yes
保存退出
重启ssh服务
sudo service ssh restart 不会VIm操作的，到哔哩哔哩学一下就会了
现在回到实例，点击安全组
点击右侧的编辑入站规则
按我这样配置，主要配置ssh的22端口和V2ray的59418端口，保存配置
如果端口没开放的话，是访问不到服务器的，不开放ICMP协议的话服务器是不能ping通的
验证安全组是否生效
win+r输入cmd
ping自己服务器的公网ipv4地址
可以看到可以ping通服务器了，说明安全组生效
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/425545f452d389947167c41969ba3db5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9d0e7287cd7262fc170c3958e2dbb83/" rel="bookmark">
			SD NAND新品尝试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SD NAND新品尝试 最近，拿到了来自深圳雷龙公司的芯片，是一颗SD NAND。确实这是我第一次知道，想必也有很多小伙伴和我一样。让我们来一起了解一下。
SD NAND介绍 CSNP4GCR01-AMW
不用写驱动程序自带坏块管理的NAND Flash（贴片式TF卡），尺寸小巧，简单易用，兼容性强，稳定可靠，固件可定制，LGA-8封装，标准SDIO接口，兼容SPI/SD接口，兼容各大MCU平台，可替代普通TF卡/SD卡，尺寸6x8mm毫米，内置SLC晶圆擦写寿命10万次，通过1万次随机掉电测试耐高低温，支持工业级温度-40°~+85°，机贴手贴都非常方便，速度级别Class10（读取速度23.5MB/S写入速度12.3MB/S）标准的SD2.0协议普通的SD卡可直接驱动，支持TF卡启动的SOC都可以用SD NAND，提供STM32参考例程及原厂技术支持，主流容量：128MB/512MB/4GB，比TF卡稳定，比eMMC便宜，样品免费试用。
刚拿到手，确实封装很小。我手上拿到的是512MB的版本，尺寸是6x8mm毫米。
我们测试一下性能：
性能测试 应用方向 对于这个结果我们还是很不错的，我暂时还没有什么需要使用大容量的项目，之后如果有我们在来实际上项目测试。
我们在MCU领域，如果遇到需要大容量要求时。一般会选择使用MicroSD作为外置存储设备，但是这样带来一个很严重的后果就是，不够稳定。那么针对MCU需要使用大容量的存储需求，我们可以选择SD NAND，也称之为贴片式T卡，贴片式TF卡，贴片式SD卡，贴片式内存卡，贴片式闪存卡，贴片式卡，贴片式U盘，贴片式UDP等等。
这是其架构图：
并且还有内置固件：CS品牌SD NAND内置坏块管理，平均读写，动态和静态的EDC/ECC等管理算法。让产品的质量更稳定，更好的延长产品的寿命。自带Flash管理算法，可以让MCU不为管理NAND Flash而费神。
再来一张官方的对比图：
总结 我们如果在使用一些要求严格的场景下，完全可以考虑使用贴片的SD NAND。如果需要移动的话，还是选择SD卡方便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4039aa3586934de9caa098602ed8bfd0/" rel="bookmark">
			FBX格式转换为GLTF/GLB格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有小伙伴说通过blende将fbx转glb/gltb格式的模型无法在web端加载，或glb模型无法打开，比如腾讯地图加载gltf。
这里个大家分享一个插件 可以将fbx格式转换为glb格式
window版本
链接：https://pan.baidu.com/s/17wwI-hmezg9-sOnHZNn_uw?pwd=1234
提取码：1234
Mac版本
链接：https://pan.baidu.com/s/1AFbUQ8GwEpztdVCOYx_BuA?pwd=1234
提取码：1234
第一步：
cd到FBX2GLB插件目录(改下名字FBX2GLB），我这里放在桌面上，路径为：c:\User\xx\Desktop
cd c:\User\xxl\Desktop
第二步：
输入下面命令:
FBX2GLB -i &lt;你的fbx路径&gt; -o &lt;输出的glb路径&gt; -b
参考示例：FBX2GLB -i fbx2gltf -i C:\Users\xx\Desktop\t\t.fbx -o C:\Users\zhangkai\xx\t\t.fbx -b
最后效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb299bded0c8067b04de8863dc173a81/" rel="bookmark">
			RSA密码的手动算法＋快速幂算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公钥加密方案（非对称加密算法） 1.为什么要引入公钥加密方案？ 密码学中的加密方案分成对称密钥和非对称密钥（也就是我们说的公钥加密，代表加密算法是RSA加密算法）。
而对称加密方法有一个特点，任何通信的两个人都需要共享一个密钥，那么就会产生一个问题：若对一个n个人的团体，就需要n（n-1）/2个不同的密钥才能完成每个人之间的通信。
2.什么是公钥加密算法？ 简单来说，就是我们有一个发送方A，一个接收方B。A和B都有属于自己的公钥和私钥。
A和B的公钥都是公开的。如果A想给B发消息，可以用B公开的公钥来加密信息。此时这个消息只有B的私钥能解密。而私钥都是严格保密的。只有B知道，这样就实现了公钥加密。
3.限门单向函数 单向函数（one-way Function）：一个函数容易计算但难于求逆
限门单向函数（Trapdoor one-way function）：如果它是一个单向函数，并在具有特定限门的知识后容易求逆。
举个例子：
n=pq，其中p和q是素数。
单向函数就是：很容易可以得到PQ的结果n，但是如果只有一个n，那么是很难分解出p和q的。
4.RSA密码的手动计算方法 首先我们需要知道一些基础知识：
具体计算方法：
5.什么是快速幂算法？ 指数：在乘方a中，其中的a叫做底数，n叫做指数，结果叫幂。
f(x)=a^x ， 随着x单位长度的递增，f(x)会呈“爆炸性”增长。
所以，假如你是求2的100次方，用计算器的话，可能会由于结果数值太大，导致结果无法显示。但是，我们这道题目，其实并不需要得到21的7次方的结果，我们只需要它对187做模运算所得到的结果。所以，这道题目，我们需要使用快速幂算法。
那么快速幂算法是如何计算的呢？首先，我们需要知道下列公式：
(a * b) % p = (a % p * b % p) % p 即多个因子连续的乘积取模的结果等于每个因子取模后的乘积再取模的结果
故有下列公式：
(a*b*c)%d=(a%d*b%d*c%d)%d 所以对于上面那题，使用快速幂算法的计算过程如下所示：
参考博客：快速幂算法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81ee06dc3e8d6e9d35e726f3d51027b/" rel="bookmark">
			CSS样式实现水平、垂直居中的五种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在这里提前准备好两个盒子，一个设为父级盒子，一个为子级盒子，如下图。
代码如下：
方法一：使用flex弹性布局实现。
相关代码：justify-content:center /* 表示水平方向的排列方式为居中 */
align-items:center /* 表示交叉轴方向的排列方式为居中 */
方法二：使用父相子绝方式（父级设置为相对定为，子级设置为绝对定为）+动画（transform）实现。
相关代码：
父级：position: relative; /* 对父级盒子使用相对定为 */
子级：position: absolute; /* 对子级盒子使用绝对定为 */
top:50%; left:50%;
tranform:translate(-50%, -50%);如果没有本行代码的话，居中的为子元素边框的顶点
方法三：父级元素设为表单单元格元素+vertical-align:middle实现。
相关代码：
父级：display: table-cell; /* 把父级元素设为表单单元格元素 */
vertical-align: middle; /* vertical-align 属性设置元素的垂直对齐方式 middle：与元素 中部对齐。就是把 vertical-align:middle 放到一个单元格元 素，即table的td元素中*/
子级： margin: auto; /* 在对子元素设置margin */
方法四：父级调整行高，子级设为行类块属性。
相关代码：
父级：text-align:center; line-height:500px; /* 此时的行高调整为父级的变宽高度 */
子级： display:inline-block;
vertical-align:middle;
方法五：同样的父相子绝，但是子元素的上下左右都需设为0px，在margin自适应。
相关代码：
父级：position: relative; 子级： position: absolute;
top: 0px;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d81ee06dc3e8d6e9d35e726f3d51027b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19c14bec57cbe5f17cd7073c5890968c/" rel="bookmark">
			数据库的定时更新及备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#疫情无情人有情，虽然不能工作，习还是要学的！
今天来学习下数据库的定时更新及备份
关键字：数据库，定时，更新，备份
一.数据库选择的是MySQL数据库，先来数据库的更新吧，咱们来一个就简单的例子就行了，这里用的是python来写的，脚本如下图所示：
test数据库student表中name字段由first_name和after_name随机拼接而成，性别sex也是随机选择，年龄age由18-58中的随机整数（年龄大点也无所谓哈）。脚本比较简单就不再赘述了。。。
二.接下来是数据库的备份，用shell来完成的，代码如下：
第四行定义备份文件所放目录
第五行定义所要备份数据库
第六七行用户密码，第八行备份工具（命令）
本脚本最重要的是第20行，执行备份命令
也可以远程备份：mysqldump -uuser -h hostip -P port -ppawd db&gt;xxx.sql
注：1.数据库的导出
mysqldump -u用户名 -p密码 数据库名 &gt; 数据库名.sql
(导出表结构和数据)
mysqldump -u用户名 -p密码 -d 数据库名 &gt; 数据库名.sql
（只导出表结构）
可能需要安装：apt-get install mysql-client
执行导出语句前须在mysql中对所要导出的数据库进行授权
Grant all privileges on test for ‘baron’@’localhost’ identified by ‘123456’;
三.接下来就是定时执行了：
执行命令：crontab -e
每天11点对数据库进行更新，每天12点对数据库备份。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fca30c27e38430c7ef9a4eb657fda23/" rel="bookmark">
			CSS选择器用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、资料领取学习 笔记整理不易，想学习python，Java，C++，大数据，人工智能等的小伙伴可自取学习资料
链接: (链接：https://pan.baidu.com/s/1BtMXOtJq3mq_Q9Gh20XwlQ?pwd=5210
提取码：5210
–来自百度网盘超级会员V3的分享)
1、HTML数据类型 HTML 指的是超文本标记语言 (Hyper Text Markup Language)是用来描述网页的一种语言。
HTML 不是一种编程语言，而是一种标记语言 (markup language)
所谓超文本，有2层含义：
1、因为它可以加入图片、声音、动画、多媒体等内容（超越文本限制 ）
2、不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（超级链接文本）。
2、1 HTML骨架格式 HTML 有自己的语言语法骨架格式：（要遵循，要专业） 要求务必非常流畅的默写下来。
&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; html骨架标签总结
课堂练习：
书写我们的第一个HTML 页面。
新建一个demo 的 TXT 文件。里面写入刚才的HTML 骨架。把后缀名改为 .HTML。右击–谷歌浏览器打开。 &lt;html&gt; &lt;head&gt; &lt;title&gt;我的第一个页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello world ！ &lt;/body&gt; &lt;/html&gt; 2、2 HTML标签关系 1. 嵌套关系
&lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; 2.并列关系
&lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt; 3、CSS选择器 在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。那么我们就可以使用css选择器，在html中找到数据所对应的标签。
3、1 标签选择器 标签选择器其实就是我们经常说的html代码中的标签。例如html、span、p、div、a、img等等；比如我们想要设置网页中的p标签内一段文字的字体和颜色，那么css代码就如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fca30c27e38430c7ef9a4eb657fda23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1146c98dfd48858be1a34aab7ede8111/" rel="bookmark">
			zotero&#43;谷歌翻译不能用，最后的解决方案！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好吧，我承认，2022 年 10 月 27 日谷歌翻译又能救活了。连续几天没法用谷歌翻译后，终于还是找到了那个漏网之鱼（谷歌翻译 IP 地址）。下图即是 zotero 解决谷歌翻译之后的翻译效果。诸君且看~
1 操作流程 C:\Windows\System32\drivers\etc，在该目录下找到 hosts 文件，在最后一行添加属性
2 属性 添加位置及添加内容如下图所示
注：由于目前修改hosts的情况下仅有一个IP地址可用，故设置付费模式，请关注公众号(Lwcah)，在最新的推文中付费阅读获取最后的谷歌翻译的IP地址。
3 管理员权限 打开 hosts 文件所在目录：C:\Windows\System32\drivers\etc 然后将 hosts 文件复制到桌面修改。
在桌面修改完成之后复制回：C:\Windows\System32\drivers\etc 下并覆盖原有hosts文件。
在复制回去的时候系统提示没有权限复制，点继续以管理员权限进行复制即可。
少数电脑需要刷新 dns 解析缓存，进入命令提示符运行窗口，命令提示符窗口输入 ipconfig/flushdns 并回车。
万请尊重原创成果！！！
声明：本公众号的原创成果，在未经允许的情况下，请勿用于任何商业用途！
您的每一次点赞，在看，关注和分享都是对我最大的鼓励~谢谢~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/743d122922917137f8c32772be499728/" rel="bookmark">
			PHP基础学习第十八篇（了解和学习PHP函数、$_GET和$_POST变量）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、PHP函数 PHP的真正威力源自于它的函数；
在PHP中，提供了超过1000个内建的函数；
内建函数：PHP提供的自带的函数。
PHP函数参考手册：https://www.runoob.com/php/php-ref-array.html
创建函数：
function:函数功能的开头
founctionName:函数名
&lt;?php
function functionName()
{
//要执行的功能
}
?&gt;
函数的名称应该提示出它的功能
函数名称以字母或下划线开头（不能以数字开头）
举例： &lt;?php
function writeName()
{
echo"小莫";
}
echo"我是：";
writeName();
?&gt;
添加参数： 为了给函数添加更多的功能，我们可以添加参数，参数类似变量。
参数就在函数名称后面的一个括号内指定。
举例：
&lt;?php
function writeName($fname){
echo$fname."Refsnes.&lt;br&gt;";
}
echo"My name is";
writeName("Kai Jim");
echo"My sister's name is";
writeName("Hege");
echo "My brother's name is";
writeName("Stale");
?&gt;
返回值： 如需让函数返回一个值，可使用return:
举例：
&lt;?php
function add($x,$y){
$total=$x+$y;
return $total;
}
echo"1+16=".add(1,16);
?&gt;
二、$_GET变量 在PHP中，预定义的$_GET变量用于收集来自method="get"的表单的值。
从带有GET方法的表单发送的信息，对任何人都是可见的（会显示在游览器的地址栏），并且对发送信息的数量也有限制。
何时使用method="get":
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/743d122922917137f8c32772be499728/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f547bbe83e6e6e0da7efc504de0391ae/" rel="bookmark">
			【Android】获取日期和天数转换，获取前N天日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 获取今天是一年当中第多少天 */ fun getIndexOfDayFromYear(calendar: Calendar): Int { val year = calendar[Calendar.YEAR] val month = calendar[Calendar.MONTH] val day = calendar[Calendar.DAY_OF_MONTH] return getIndexOfDayFromYear(year, month, day) } fun getIndexOfDayFromYear(year: Int, month: Int, day: Int): Int { var leapYear = false//是否是闰年 if (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) { leapYear = true } var index = day if (month &gt;= 0) { //1月，第一个月，直接day Index index += 0 } if (month &gt;= 1) { //2月，第二个月，需要加一月天数31 index += 31 } if (month &gt;= 2) { //3月，第三个月，需要加er月天数 if (leapYear) { index += 29//闰年加29天 } else { index += 28//平年加28天 } } if (month &gt;= 3) { //4月，第四个月，需要加三月天数31 index += 31 } if (month &gt;= 4) { //5月，第五个月，需要加四月天数30 index += 30 } if (month &gt;= 5) { //6月，第六个月，需要加五月天数31 index += 31 } if (month &gt;= 6) { //7月，第七个月，需要加六月天数30 index += 30 } if (month &gt;= 7) { //8月，第八个月，需要加七月天数31 index += 31 } if (month &gt;= 8) { //9月，第九个月，需要加八月天数31 index += 31 } if (month &gt;= 9) { //10月，第十个月，需要加九月天数30 index += 30 } if (month &gt;= 10) { //11月，第十一个月，需要加十月天数31 index += 31 } if (month &gt;= 11) { //12月，第十二个月，需要加十一月天数30 index += 30 } return index } /** * 获取一年中的第多少天是几月几号 */ fun getDateFromYearIndex(index: Int, year: Int): Calendar { var leapYear = false//是否是闰年 if (year % 4 == 0 &amp;&amp; year % 100 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f547bbe83e6e6e0da7efc504de0391ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/705f6a2b41ccc9bb4312ecdaf44d83e7/" rel="bookmark">
			vue3.0 &#43; element Plus项目中flex布局样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 样式如下： 2. HTML代码如下： &lt;!--我这里需要根据不同角色切换显示不同的应用，所以引入了element中的标签页--&gt; &lt;el-tabs v-model="editableTabsValue" type="card" class="demo-tabs" @tab-click="handleClick" &gt; &lt;el-tab-pane v-for="item in editableTabs" :key="item.name" :label="item.title" :name="item.name" &gt; &lt;div class="app-item-mod"&gt; &lt;ul class="app-item-list"&gt; &lt;!--布局这里我使用element中的layout布局,更简单一些 gutter属性用来指定列之间的间距 --&gt; &lt;el-row :gutter="20"&gt; &lt;el-col :span="12" v-for="i in result?.QueryAlgConfigMarket?.data" :key="i" &gt; &lt;li class="app-item"&gt; &lt;dl&gt; &lt;dt class="app-icon" @click="goDetail(i.id)"&gt; &lt;div class="icon-box"&gt; &lt;img :src="getIconUrl(i.id)" :alt="i.name" class="icon-img" /&gt; &lt;/div&gt; &lt;/dt&gt; &lt;dd&gt; &lt;div class="intro" @click="goDetail(i.id)"&gt; &lt;h3 class="name"&gt; &lt;a class="link-blue"&gt;{{ i.name }}&lt;/a&gt; &lt;/h3&gt; &lt;div class="app-label"&gt; &lt;el-icon&gt;&lt;PriceTag /&gt;&lt;/el-icon&gt; &lt;div class="label-item-box"&gt; &lt;span class="label-item" v-for="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/705f6a2b41ccc9bb4312ecdaf44d83e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24e65f72e3f627dcfdac3b45e92facc/" rel="bookmark">
			Homebrew介绍和闭坑安装方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天来教大家，Mac的Homebrew安装的方法。
在安装直接要介绍一下这款软件是做什么用？
一、Homebrew是什么
Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。
引用官方话语：安装软件缺少组件？别担心，Homebrew 随时帮你解决问题。
安装Homebrew之前，先查看两个地方，闭坑。
查询终端是否使用的bash或者sh，如果登录shell是zsh，需要修改成bash。
修改方法：
偏好设置→用户与群组→先解锁操作才能修改→选择当前用户→右键高级选项→登录shell改成/bin/bash
最终效果如图所示：
2.是否安装过Xcode命令行工具，如果没有安装，需先安装此工具。（新笔记本直接看安装xcode命令安装教程）
检查方法：xcode-select --version
安装Xcode命令行工具（两种过方法）
安装教程如下：
第一种方法（在线安装）
1.命令行：
xcode-select --install 2.点击安装→同意
在线安装有点慢，需要耐心等待。
安装时报此错误，需要删除再来安装一遍。
错误代码如下：
显示此报错，说明xcode原来安装过老版本。需要删除才安装一次。解决办法放在后面~
ps
安装前先查询一下是否安装过，使用以下命令行。
解决方法：
最简单的方法是删除旧版本的工具，然后安装新版本。
sudo rm -rf /Library/Developer/CommandLineToolsxcode-select --install 软件安装完，点击确定。
第二种方法（官方下载）
1、打开Apple的开发者下载：
https://developer.apple.com/download/more/；
ps.第一次进入开发官方，需要点击允许。
2、中间需要登录下，登录完成后在左边的搜索框中搜索Command Line Tools然后搜索；
3.打开安装的包
4.一路下一步，点击继续，等安装完成
二、安装Homebrew
1.检查是否安装
命令行如下：
brew -v 如图所示：
未找到brew安装！
2.安装方法如下：
方法一：官方安装方法（需要代理）
Homebrew官网：http://brew.sh//bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" 国内网络大概率会下载失败。一般报错
curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b24e65f72e3f627dcfdac3b45e92facc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c1cf31e6d91252487ee4c2c7e8afef2/" rel="bookmark">
			树莓派配置环境细节(JDK&#43;pycharm&#43;miniconda&#43;pyqt5&#43;opencv-python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、java环境
1.1确认树莓派的版本信息
1.2把压缩包传到树莓派上，然后进行解压
1.3配置环境变量
1.4查看java环境
二、pycharm
三、miniconda
3.1miniconda下载
3.2miniconda 安装
3.3添加 .bashrc 配置
3.4使用conda创建python环境
3.5pytorch + torchvision安装
四、PyQt5
4.1PyQt5及SIP简介
4.2所需环境
4.3PyQt5及SIP安装步骤
4.3.1安装qt5-default
4.3.2配置好python和虚拟环境
4.3.3源码编译安装SIP包
4.3.4源码编译安装PyQt5包
4.4虚拟环境中调用PyQt5的配置
4.5测试PyQt5的版本和功能
五、opencv-python
一、java环境 1.1确认树莓派的版本信息 uname -a 官网下载地址：OpenJDK JDK 18.0.2.1 GA Release 1.2把压缩包传到树莓派上，然后进行解压 tar -zxvf 文件名 z：表示tar 包是被gzip压缩过的，所以解压时需要用gunzip解压
x：从tar包中把文件提取出来
v：解压的过程中显示文件信息
f：使用文件，后面要立即接文件名，不要再加参数
1.3配置环境变量 先安装gedit
sudo apt-get install gedit 进入/home/pi文件下
然后通过gedit命令打开/home/pi/.bash_profile
gedit /home/pi/.bash_profile 打开文件后在文件尾部加入JDK环境变量的配置，如下所示：(JAVA_HOME为你jdk安装的所在路径)
export JAVA_HOME=/home/pi/downloads/jdk-18.0.2.1 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 添加之后保存退出，然后使用如下命令使其生效
source /home/pi/.bash_profile 1.4查看java环境 如此即可安装成功。
二、pycharm 可以点击这个链接下载Pycharm。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c1cf31e6d91252487ee4c2c7e8afef2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/195/">«</a>
	<span class="pagination__item pagination__item--current">196/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/197/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>