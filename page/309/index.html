<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5551f1ecd9b58b55bc11d268f703ce63/" rel="bookmark">
			高等数学-线性代数：正交投影和正交分量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高等数学-线性代数：正交投影和正交分量
练习
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32981424b7b34571c17d1b2cb6c1f456/" rel="bookmark">
			Python 自动识别图片文字—OCR实战教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OCR 是光学字符识别（英语：Optical Character Recognition，OCR）是指对文本资料的图像文件进行分析识别处理，获取文字及版面信息的过程。
很早之前就有同学在公众号后台回复希望出一篇 OCR 相关的文章，今天尝试了一下 cnocr 和 tesseract 两个 Python 开源识别工具的效果，给大家分别讲讲两个工具的使用方法和对比效果。
1.准备
开始之前，你要确保Python和pip已经成功安装在电脑上，如果没有，可以访问这篇文章：超详细Python安装指南 进行安装。
(可选1) 如果你用Python的目的是数据分析，可以直接安装Anaconda：Python数据分析与挖掘好帮手—Anaconda，它内置了Python和pip.
(可选2) 此外，推荐大家用VSCode编辑器，它有许多的优点：Python 编程的最好搭档—VSCode 详细指南。
请选择以下任一种方式输入命令安装依赖：
1. Windows 环境 打开 Cmd (开始-运行-CMD)。
2. MacOS 环境 打开 Terminal (command+空格输入Terminal)。
3. 如果你用的是 VSCode编辑器 或 Pycharm，可以直接使用界面下方的Terminal.
（选择一）安装 cnocr：
pip install cnocr 看到 Successfully installed xxx 则说明安装成功。
如果你只想对图片中的中文进行识别，那么 cnocr 是一个不错的选择，你只需要安装 cnocr 包即可。
但如果你想试试其他语言的OCR识别，Tesseract 是更好的选择。
（选择二）安装 pytesseract：
首先，无论是Windows还是macOS，你都需要安装 pytesseract:
pip install pytesseract 其次，还需要安装Tesseract.
（macOS）Tesseract 在macOS下可以使用brew安装：
brew install tesseract 非常方便，一条命令即可完成安装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32981424b7b34571c17d1b2cb6c1f456/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f51a9a88c61bc263dd1df346030a454d/" rel="bookmark">
			html日期和价钱控件,GitHub - melodyne/DatePicker: html价格日历控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DatePicker 价格日历控件
接口数据格式
[
{
"day": "2016-07-07",
"price": "158"
},
{
"day": "2017-07-11",
"price": "158"
},
{
"day": "2017-07-12",
"price": "158"
},
{
"day": "2017-07-13",
"price": "158"
},
{
"day": "2017-07-14",
"price": "158"
},
{
"day": "2017-07-15",
"price": "158"
}
]
第一步：引入这三个文件
第二步：初始化组件
pickerEvent.setPriceArr(data);
pickerEvent.Init(e);
第三步：全局实现修改价格方法
/**
* 修改价格
* @param date // 日期
* @param newPrice // 新价格
* @param calendarPrice // 日历控件对象
*/
function changePrice(date, newPrice, calendarPrice) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f51a9a88c61bc263dd1df346030a454d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/867b8c99dfc0efa0bb7a8cf1380c4069/" rel="bookmark">
			图片悬浮切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div class="item" v-for="(item,index) in List" :key="item.index" @mouseenter="enters(index)" @mouseleave="leaver(index)" &gt; &lt;div class="box-w" v-show="switchNice[index].arry"&gt; &lt;i class="item-t"&gt;{{item.title}}&lt;/i&gt; &lt;i class="item-z"&gt;{{item.name}}&lt;/i&gt; &lt;i class="item-x" @click="jump('',`${item.id}`)"&gt;{{item.xname}}&lt;/i&gt; &lt;/div&gt; &lt;div class="imgShow" v-show="switchNice[index].arrys"&gt; &lt;img :src="require('../assets/images/'+ item.url)" /&gt; &lt;/div&gt; &lt;/div&gt; enters(index) { this.switchNice[index].arrys = false; // 当前鼠标悬浮所在的图片隐藏 for (let m = 0; m &lt; this.switchNice.length; m++) { // 循环switchNice数组 if (m === index) { this.switchNice[m].arry = true; // 当数组和index相同时，文字显示 } else { // 不同时，图片显示，文字隐藏 this.switchNice[m].arry = false; this.switchNice[m].arrys = true; } } }, leaver(index) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/867b8c99dfc0efa0bb7a8cf1380c4069/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5019b2d6b4990fa27a6725f91fa12068/" rel="bookmark">
			Airtest源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Airtest图像识别 Airtest介绍源码touch方法测试代码与结果：AKAZE局部匹配介绍代码比较 最终用到的就是OpenCV的两个方法：模版匹配和特征匹配 Airtest介绍 Airtest是一款网易出品的基于图像识别面向手游UI测试的工具，也支持原生Android App基于元素识别的UI自动化测试(现在支持Android、ios、Windows)。主要包含了三部分：Airtest IDE、Airtest（用截图写脚本）和 Poco（用界面UI元素来写脚本）。来自Google的评价：Airtest 是安卓游戏开发最强大、最全面的自动测试方案之一。
源码 Airtest
下载后，如果，只是代码阅读，可以不用部署环境。运行需要参照readme，有中文版很贴心 😃
touch方法 如图示所示，从touch图片开始，即为点击某个传入的图片，源码在api.py里面：
@logwrap def touch(v, times=1, **kwargs): """ Perform the touch action on the device screen :param v: target to touch, either a ``Template`` instance or absolute coordinates (x, y) :param times: how many touches to be performed :param kwargs: platform specific `kwargs`, please refer to corresponding docs :return: finial position to be clicked :platforms: Android, Windows, iOS :Example: Click absolute coordinates:: &gt;&gt;&gt; touch((100, 100)) Click the center of the picture(Template object):: &gt;&gt;&gt; touch(Template(r"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5019b2d6b4990fa27a6725f91fa12068/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1788ede0013169fd6e1a251bf46ae955/" rel="bookmark">
			cadence17.4制作通孔焊盘（孔径1mm）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Start Drill Secondary Drill 不用设置
Drill Symbol Drill Offset 跳过使用默认值
Design Layers Mask Layers Options 不用设置
Summary 可以查看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a23a7b0ef727673fa50927b501eb14/" rel="bookmark">
			devtool
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		devtool devtool常用命令： add、 modify、reset、build、build-image、status
[penghu4x@bmcdev-S2600WF0license-manager$ devtool -h NOTE: Starting bitbake server... WARNING: Duplicate inclusion for /media/disk3/penghu4x/work/dsg-openbmc-openbmc/meta/conf/distro/include/security_flags.inc in /media/disk3/penghu4x/work/dsg-openbmc-openbmc/meta-phosphor/conf/distro/include/phosphor-defaults.inc usage: devtool [--basepath BASEPATH] [--bbpath BBPATH] [-d] [-q] [--color COLOR] [-h] &lt;subcommand&gt; ... OpenEmbedded development tool options: --basepath BASEPATH Base directory of SDK / build directory --bbpath BBPATH Explicitly specify the BBPATH, rather than getting it from the metadata -d, --debug Enable debug output -q, --quiet Print only errors --color COLOR Colorize output (where COLOR is auto, always, never) -h, --help show this help message and exit subcommands: Beginning work on a recipe: add Add a new recipe modify Modify the source for an existing recipe upgrade Upgrade an existing recipe Getting information: status Show workspace status latest-version Report the latest version of an existing recipe check-upgrade-status Report upgradability for multiple (or all) recipes search Search available recipes Working on a recipe in the workspace: build Build a recipe rename Rename a recipe file in the workspace edit-recipe Edit a recipe file find-recipe Find a recipe file configure-help Get help on configure script options update-recipe Apply changes from external source tree to recipe reset Remove a recipe from your workspace finish Finish working on a recipe in your workspace Testing changes on target: deploy-target Deploy recipe output files to live target machine undeploy-target Undeploy recipe output files in live target machine build-image Build image including workspace recipe packages Advanced: create-workspace Set up workspace in an alternative location export Export workspace into a tar archive import Import exported tar archive into workspace extract Extract the source for an existing recipe sync Synchronize the source tree for an existing recipe menuconfig Alter build-time configuration for a recipe Use devtool &lt;subcommand&gt; --help to get help on a specific command 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39a23a7b0ef727673fa50927b501eb14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60f6407b1d769a3b827db82687b94e5c/" rel="bookmark">
			解决 No module named ‘tensorflow.examples.tutorials‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在网上找的答案都不能解决该错误，现在终于找到了解决办法。
首先查看Python安装路径中文件夹是啥样的，我的是这样的：
安装路径：
D:\SoftWare\Python3.8.3\InstallFile\Lib\site-packages 相信很多人文件夹都是这样的，并没有网上所谓的tensorflow_core文件夹，所以我们直接进入tensorflow文件夹里面，然后再进入core里面
然后再进入example里面
然后你会发现里面确实没有所谓的tutorials文件夹，所以直接从网上下载该文件夹，下载地址分享在这里：
链接：https://pan.baidu.com/s/1UTt6VE5KLIh-6J-OZqTkuw 提取码：sbh0 下载好之后，把下载好的tutorials文件夹复制到example文件夹里面，如下图
完成之后j就需要去代码中进行修改，首先原代码为：
from tensorflow.examples.tutorials.mnist import input_data mnist = input_data.read_data_sets ('MNIST_data/', one_hot=True) 由于我们文件夹路径和这个不一样，所以我们把程序要修改为
from tensorflow.core.example.tutorials.mnist import input_data mnist = input_data.read_data_sets ('MNIST_data/', one_hot=True) 大家看到了吧，这里面其实就是和刚才咱们进入python安装路径是一样的，先是core，再是example，然后是tutorials。
然后还需要更改tutorials文件夹里面的一个_init_.py文件，同样也是修改导入包的路径，修改前为：
修改之后为：
发现是不是修改完之后代码颜色都从白色变成了正常的颜色，那就说明修改成功了，只要导入包的写法和tutorials文件夹的路径是一样的就是对的了。
现在终于没有报错啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8febe853ee124008ff05fb8407845ba/" rel="bookmark">
			一个前端妹子的面试笔记，面试题&#43;笔记&#43;项目实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从事前端开发工作差不多3年了，自己也从一个什么都不懂的小白积累了一定的理论和实践经验，并且自己也对这3年来的学习实践历程有一个梳理，以供后面来细细回忆品味。
1、为什么选择学习前端开发？ 你可能是因为兴趣，完成一个网站、页面、功能的成就感。你也可能是因为现在前端岗位火爆，就业率高。不管是因为什么，只要找准了目标，学就是了！
一面： 1，说一下浏览器缓存
2，cookie 与 session 的区别
3，浏览器如何做到 session 的功能的。
4，解释一下：csrf 和 xss
5，怎么防止 csrf 和 xss
6，跨域的处理方案有哪些
7，CORS 是如何做的？
8，对于 CORS ，Get 和 POST 有区别吗？
9，了解 HTTPS 的过程吗？
10，es module 和 commonjs 的区别
11，react 里如何做动态加载
12，动态加载的原理是啥，就是 webpack 编译出来的代码
13，写一个处理加法可能产生精度的函数，比如 0.1 + 0.2 = 0.3
二面： 1，聊项目
项目难点以及怎么解决的项目有哪些亮点？ 2，写一个 es6 的继承过程
3，写一个大数相乘的解决方案。传两个字符串进来，返回一个字符串
三面 1，聊项目
2，写一个防抖函数
3，算法题
字节是出了名的考算法题比较多的，基本每面都会算法题和编程题，对编程能力比较看重吧。
蚂蚁 一面： 1，讲讲来蘑菇街都干了哪些事情
2，聊聊有什么技术上的沉淀
3，除了 redux mbox dva 还用过其他的 状态管理没
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8febe853ee124008ff05fb8407845ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/264fb505df0e8f4c7b991a787d946790/" rel="bookmark">
			Python编程实现点到直线距离计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实现TextMountain时，生成TCBP时需要计算文本区域点到四条边的距离，由于计算量大，所以最好是使用矩阵运算，提高运行效率。
基础讲解：由于需要使用到矩阵运算，最好采用向量的方法来进行表示。
为了讲述方便，我们设直线为x轴，用向量oq表示，对于点p，要计算p到直线oq的距离，我们可以任取直线上一点（这里取o）得到向量op，根据图中公式可以求得点到直线的垂足d到点p的向量dp（x,y）,则点到直线的距离为sqrt（x*x+y*y）
编程实现
def get_pt_line_dis(pt, line, lpt): ''' 获取点到直线的距离 :param pt: 点坐标，[n,2] :param line: 直线向量 [m,2] :param lpt: 直线上的一个点 [m,2] :return: 点与直线的距离以及直线到点的垂直单位向量 ''' EPS=10-9 pt = np.tile(pt[:, np.newaxis, :], (1, line.shape[0], 1)) #[n,m,2] line = np.tile(line[np.newaxis, ...], (pt.shape[0], 1, 1)) #[n,m,2] lpt = np.tile(lpt[np.newaxis, ...], (pt.shape[0], 1, 1)) #[n,m,2] array_trans = pt - lpt #[n,m,2] array_trans[i,j]表示第i个点与第j条直线某端点组成的向量，图中op array_temp = np.sum(array_trans * line, axis=2) / (line[..., 0] ** 2 + line[.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/264fb505df0e8f4c7b991a787d946790/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc4e116eb88f0942f474dab277326f56/" rel="bookmark">
			p标签设置文本自动换行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;p style="word-wrap:break-word;"&gt;巴拉巴拉一大堆......&lt;/p&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffaa086891b52d4f81dd6ef703f62759/" rel="bookmark">
			get请求参数字符串转json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var json = {}; var url = 'https://www.baidu.com/index.html?a=12&amp;b=asdf&amp;c=&amp;d'; url = url.replace(/.*\?/,''); var arr = url.split('&amp;'); var temp; for (var i = 0;i &lt; arr.length;i++) { temp = arr[i].split('='); json[temp[0]] = temp[1]; }; console.log(json); 原文：https://www.cnblogs.com/theone67/p/6773030.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b5e678c923a6bb1dbd6f64c20ed2cf/" rel="bookmark">
			ESP32开发板控制OLED显示屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESP32开发板控制OLED显示屏 相关知识点 ​ I2C总线是用于设备之间通信的双线协议，在物理层上，它由两根线组成：SCL和SDA，分别是时钟线和数据线。
​ I2C对象使用特定的总线创建，可以在被创建时就初始化，也可以稍后再初始化。可以通过print I2C对象来查看相关的配置。
方法说明machine.I2C(id=-1, *, scl, sda, freq=400000)构造方法，返回一个I2C对象。默认情况下id为-1，表示这是一个软件实现的I2C总线，如果要使用硬件I2C可以选择0，1两个id。scl和sda就是对应要使用的Pin对象，在使用软件I2C时，这两个参数一定要明确传入。I2C.init(scl, sda, *, freq=400000)如果创建时没有初始化可以使用这个方法初始化I2C.scan()扫描在同一总线上的设备地址，范围从0x08-0x77，会返回一个列表。I2C.readinto(buf, nack=True, /)从总线上读取字节数据写入到buf中I2C.write(buf)将buf中的字节数据写到总线上 表1-1 I2C使用
​ I2C还有更加细分的操作函数，但是一般没有特殊要求的话使用这些函数就足够了。还有这里需要提一下参数scl和sda，这两个都是Pin类型对象，也就是用于定义引脚的对象。
ESP32-board自带的两个硬件I2C，除了硬件I2C，我们还可以在任意引脚上用软件模拟I2C，这样就方便许多了。I2C的用处很多，本实验中使用的OLED显示屏模块就需要使用I2C来控制。
OLED显示屏是利用有机电自发光二极管制成的显示屏，其中每一个像素点就是一个led。本实验使用0.96寸，128*64分辨率的OLED显示屏模块，模块引脚如图3-2所示，我们在实验中使用了23，19两个引脚作数据线和时钟线。
我们先将扩展接口板插到ESP32-board的引脚上，然后将OLED屏幕的接口插入其中一个接口上，这里使用23、19接口，这样就连接完成了，相当的方便。
了解完I2C之后，就可以开始驱动OLED屏幕了，这里我们提供了现成的驱动文件ssd1306.py，开发者们只要直接调用其中的方法即可，记得在运行程序之前把驱动文件下载到开发板的文件系统中，OLED的使用方法如下：
方法说明SSD1306_I2C(width, height, i2c, addr=0x3c,…)构造方法，返回SSD1306_I2C 对象，通过这个对象我们就可以实现OLED屏幕的显示控制。width和height分别表示屏幕的宽高的像素大小，i2c是使用的I2C对象，addr是I2C设备的地址，默认为0x3cSSD1306_I2C.text(str, x, y)将字符串str写入到内部缓冲区的指定位置SSD1306_I2C.show()显示缓冲区的内容SSD1306_I2C.fill(col)屏幕填充为一种颜色，col=0填充黑色，1填充白色 ​ 使用以上几种方法我们就可以在屏幕上显示想要显示的内容了，不过由于编码的原因，暂时没有直接显示中文的方式，但是我们后面的综合实验中会讲解如何间接显示中文。
实验内容 ​ 将扩展接口插到开发板上，OLED显示屏模块连接到对应接口，还要讲驱动文件ssd1306.py下载到ESP32-board中。在main.py中，我们先导入模块，然后创建对应引脚的I2C对象，使用创建的I2C对象创建SSD1306_I2C对象，接着我们就可以控制OLED屏幕的显示了。以下是实现代码：
# 导入I2C，Pin和SSD1306_I2C from machine import I2C, Pin from ssd1306 import SSD1306_I2C # 创建对应引脚的I2C对象 i2c = I2C(sda=Pin(23), scl=Pin(19)) # 创建SSD1306_I2C对象 # 地址是0x3c，不同的厂商可能地址不同，修改成自己的地址即可 # 也可以使用scan方法扫描地址 oled = SSD1306_I2C(128, 64, i2c, addr=0x3c) oled.text("Hello World!", 0, 0) oled.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53b5e678c923a6bb1dbd6f64c20ed2cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e695fcba7a44b264fbafbdb1516ee7/" rel="bookmark">
			Android：ScrollView停止滚动的监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android：ScrollView停止滚动的监听 首先判断是否在停止滚动的状态（也可以不用这段代码）
参考https://www.jianshu.com/p/eb4b745afcd0
public static boolean isfinishScroll(ScrollView scrollView) { try { if (scrollView != null) { Field mScroller = scrollView.getClass().getDeclaredField("mScroller"); mScroller.setAccessible(true); Object object = mScroller.get(scrollView); if (object instanceof OverScroller) { OverScroller overScroller = (OverScroller) object; return overScroller.isFinished(); } } } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } return false; } 下面参考https://blog.csdn.net/u011213403/article/details/103704551
isDown记录是否在按下或移动状态，CountDownTimer倒计时100ms结束
private boolean isDown;//是否在按下或移动状态 private CountDownTimer scrollCountTimer = new CountDownTimer(100, 1){ @Override public void onTick(long millisUntilFinished) {} @Override public void onFinish() { if (isfinishScroll(scrollView)){//其实此时已经停止滚动了，也可以不用isfinishScroll再判断是否已停止滚动。 //停止滚动后的操作 } } }; scrollView的滚动监听setOnScrollChangeListener在API&gt;=23时才可以使用，这里使用getViewTreeObserver().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5e695fcba7a44b264fbafbdb1516ee7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/796bfd138a48c3f5b02841c71b1569b1/" rel="bookmark">
			html统计a标签设计间距,css超链接间距_锚文本超链接a与a之间间距设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		div css布局技巧之两邻超链接锚文本之间间距设置简称css超链接间距
超链接间距-超链接间隔距离
超链接间距主要对a设置间距实现，也就是a标签对象与a标签对象之间间距。当然我们了解CSS5介绍有字间距
通常情况如果a之间背景没有区别，使用padding设置间距比较好些。
其margin与padding使用方法均相同，唯一区别在于margin设置对象外间距，padding设置对象边距到内容之间距离。
一、padding布局超链接间距
1、padding设置超链接间距实例代码
超链接间距 CSS5 .box a{ padding:0 10px;}
学习CSS上CSS5,网站有：
模板特效模块等栏目。
2、效果截图
css padding超链接与超链接间距设置
以上padding:0 10px相等于设置padding-left为10px，padding-right为10px，当然实际布局时候可以单独设置padding-left或padding-right，方法多种多样达到布局效果兼容各大浏览器即可选用。
二、margin布局锚文本超链接间距
1、margin设置A超链接间距实例代码
超链接间距 CSS5 .yanshi a{ margin:0 8px;}
学习CSS上CSS5,网站有：
模板特效模块等栏目。
2、超链接之间间距布局出效果截图
margin超链接锚文本之间间隔
margin兼容不是很好，如果超链接与超链接之间没有边框区别、没有背景区别，推荐使用padding来实现相邻锚文本超链接A标签之间间隔间距。
作者：css5原创
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eb5226a8ffa4c3d20c1976a3fe75ad2/" rel="bookmark">
			深度学习轻量模型间比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录结构
1、轻量级网络概述
2、官方数据对比
3、实验对比
4、实验结论
注：了解基础理论的同学，请直接跳到第4部分，查看实验结论！
1、轻量级网络概述
常规的CNN推理，由于需要很大的计算量，很难应用在移动端，物联网等资源受限的场景中。只有通过复杂的裁剪，量化才有可能勉强部署到移动端。从Squeezenet，MobileNet v1开始，CNN的设计开始关注资源受限场景中的效率问题。经过几年的发展，目前比较成熟的轻量级网络有：google的MobileNet系列，EfficientNet Lite系列，旷世的ShuffleNet系列，华为的GhostNet等。
MobileNet系列
MobileNet v1 最大的成就在于提出了depthwise卷积(DW)+pointwise卷积(PW)，将普通卷积的计算量近乎降低了一个数量级，成为第一个在轻量级领域取得成功的网络。如下图所示，对于一个常规的3*3卷积，使用dw+PW，计算量降低为原来的 1/(3*3)=1/9, 接近于降低了一个数量级。
MobileNet v2借鉴了resnet的残差结构，引入了inverted resdual模块（倒置残差模块），进一步提升了MobileNet的性能。因为inverted resdual一方面有利于网络的学习，因为毕竟学的是残差（这也是resnet的精髓），另一方面，也降低了原来的PW卷积的计算量。在MobileNet v1的dw+pw卷积中，计算量主要集中在PW卷积上。使用了inverted resdual模块之后，原来的一个PW卷积，变成了一个升维PW+一个降维PW，其计算量有所下降，如下图所示：
再后来，google凭借强大的硬件基础设施，使用nas技术，搜索出了MnasNet，MobileNetv3，以及EfficientNet Lite系列。由于这次测试主要考虑手工设计的网络，MnasNet和EfficientNet Lite暂时不考虑。MobileNet v3除了使用搜索技术之外，对原来网络的头尾，激活函数都做了一定的改进。
ShuffleNet系列
DW卷积或者分组卷积虽然能够有效的降低计算量，但是缺少通道间的信息交互与整合，势必会影响网络的特征提取能力，MobileNet中使用PW卷积来解决这个问题，但是PW卷积的计算量比较大（相对dw卷积），大约是dw卷积的 C_out / K*k 倍。假设C_out=128, k=3, 那么pw卷积的计算量是dw卷积的14倍！所以MobileNet的计算量主要集中在point wise卷积上面。ShuffleNet v1使用了一种更加经济的方式，channel shuffe，使得不需要卷积操作，也能实现不同通道间的信息融合。如下图所示：
不过这种方法需要group里面的通道数量至少是group的倍数，即C/group &gt;= group, 导致无法使用dw卷积那样极致的group数量(group=C)。所以在分组卷积计算的时候，计算量是比MobileNet的dw卷积计算量大一些的。
ShuffleNetv2从轻量级网络的本质出发，提出不应该只看计算量，而需要同时兼顾MAC（内存访问代价），并提出了4条轻量级网络设计的准则：
并以此为依据，更新了ShuffleNet v1的基本结构，得到了ShuffleNet v2，如下图所示：
GhostNet网络
GhostNet通过对传统卷积得到的特征图进行观察，发现有很多相似的特征图。那么是否可以通过改造让卷积这种重量级的OP只生成一些具有高度差异性的特征图，然后基于这些特征图，再用一些廉价的OP（相对于卷积）进行变换，得到传统卷积中的那些相似特征图。如下图所示。Ghostnet就是基于下图中的这种ghots module进行构建的轻量级网络。
2、官方数据对比
对上述网络的官方数据进行整理，提取精度（imagenet top1精度）与计算量FLOPS进行统计，如下表格所示:
对上述信息进行可视化，使用matploblib打印各个网络的精度与计算量的关系，如下图所示：
从图中明显可以看到，GhostNet的性能是最好的，MobileNetv3次之，而ShuffleNetv2与MobileNetv2显然要差一些。 3、实验对比
通过官方数据的整理，可以大致得出如下的性能排序（只考虑精度和计算量）
GhostNet&gt;MobileNetv3&gt;ShuffleNetv2&gt;MobileNetv2
这和论文的发表时间一致，越是后面发表的论文，在官方列出的数据中越好（否则论文也发不出来），那么真实使用场景下，性能是否还会如官方数据那样呢？这个是不一定的。首先是上述网络官方数据都是计算量，但是在移动端部署深度学习网络，不只是考虑计算量这一维度，例如内存消耗，访存延时，是否容易优化，网络的泛化性能如何，在小数据集上的表现如何，以及应用于检测的时候，特征是否容易提取等很多维度。
所以本次实验为了有一个较为全面的对比，针对上述四类网络（ShuffleNet v2 0.5、ShuffleNet v2 1.0、ShuffleNet v2 1.5、MobileNet v2 0.5、MobileNet v2 1.0、MobileNet v2 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0eb5226a8ffa4c3d20c1976a3fe75ad2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55d914e83a2a0c4bc496f2f0df3d874d/" rel="bookmark">
			病毒小案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		病毒小案例
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
开发工具与关键技术：Axure RP8
撰写时间：2021/6/18
1.做出上面的形状
2.在上面打出病毒两字，字体大小为28，颜色为红色
3.把病毒转化为动态面板
4.在元件库中，选择Icons，搜索笑
5.搜索难
6.两个大小都是170*170
7.打上“中病毒啦”文字，字体大小为18，颜色黑色，然后点击选中，勾选字体大小为28，颜色为红色
8.做出圆形，颜色为红色，大小170*170
9.把难过组合
10.点击动态面板，点击拖动时，选择选中，勾选动态面板
11.点击拖动结束时，点击编辑条件，选择元件范围，选择动态面板，选择接触，元件范围选择笑
12.选择移动，勾选第一个矩形框，选择绝对位置，点击添加局部变量，选择元件，选择笑，上面选择[[LVAR1]]
13.y也是和x做法一样，动画选择线性
14.选择等待，设置为200
15.选择显示/隐藏，勾选难过，选择显示，勾选笑，选择隐藏
16.选择选中，勾选矩形
17.选择隐藏，勾选第一个
18.选择设置选中，勾选难过，设置尺寸为250*310，动画线性
19.选中移动，勾选第一个
20.把难过组合隐藏
以下时图片步骤
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b8bdf2d52062f7c1fb7d0f20b88a8e/" rel="bookmark">
			Maven不能下载依赖库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：检查maven设置是否正确，特别是settings.xml里面的配置，mirror，repository等。
二：如果设置正确，就去该dependency对应的URL，通过浏览器进入查看，检查该URL对应的网页是否存在对应的jar包
三：最后手段，手动下载jar包到local repository引入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b29a460493b90463048e0391dac2fa9/" rel="bookmark">
			安全狗的绕过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：
phpstudy2018
安全狗apache版
sqllabs靶场
安全狗绕过思路：
安全狗是基于正则匹配的绕过，所以总是能够绕过其正则匹配实现sql的命令执行，需要对数据库语句灵活掌握。经过对安全狗的fuzz，测试其拦截规则，发现其实and、or这样的敏感字符是不会被直接拦截的，但是and加空格就会被拦截，其实绕过的中心可以向如何绕过空格偏移。
为了可以更清晰的认知注入语句是如何在数据库中执行的，我修改了sqli-lab的代码，可以看到我们输入的语句和数据库执行的语句，可以在对应位置上加入这两条语句。
echo "有效输入：".$id."&lt;br&gt;"; echo "mysql："."$sql"."&lt;br&gt;"; 安全狗绕过步骤：
1.以第八关基于单引号的布尔为例，首先探测注入点
输入?id=1' and1=1 --+，并不会被安全狗拦截 输入?id=1' and 1=1 --+，被安全狗拦截，反向印证了安全狗是检测and和空格组合体的 2.此时绕过空格，利用/*//*/绕过空格。此字符表示注释/*/表示一个闭合,*字符被两边的/共用了
?id=1' and/*//*/1=1 --+ 如果不理解为什么/*/为什么是一个闭合可以到mysql管理器去执行
3.下面探测数据库长度，在这里安全狗检测and空格和database()，也可以通过/*//*/绕过
绕过语句：?id=1' and/*//*/length(database(/*/*/))&gt;7--+ 4.下面探测数据表，此处需要绕过and和from后面的空格，information_schema.tables和database()，and和from和database()都已经绕过了，核心就是绕过information_schema.tables，这里采用的方式是--+/*0ainformation_schema.tables，--代表将本行的sql语句注释掉了，+号充当空格，%0a表示闭合
绕过语句：?id=1' and/*//*/substr((select table_name from/*//*/--+/*%0Ainformation_schema.tables where table_schema=database(/*//*/) limit 0,1),1,1)='e'--+ 如果不理解具体如何执行，可以把sql语句放到mysql管理器执行查看闭合方式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ed1700b55b080caef4937152eb494c9/" rel="bookmark">
			“山东大学移动互联网开发技术教学网站建设”项目实训日志七
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间： ​ 21春季学期第十四周
个人工作内容： ​ vnc远程连接相关
前提知识： 远程控制 ​ 远程控制是指管理人员在异地通过计算机网络异地拨号或双方都接入Internet等手段，连通需被控制的计算机，将被控计算机的桌面环境显示到自己的计算机上，通过本地计算机对远方计算机进行配置、软件安装程序、修改等工作。
SSH ​ SSH 是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境，SSH 通过在网络中创建安全隧道来实现 SSH 客户端与服务器之间的连接。SSH 最常见的用途是远程登录系统，人们通常利用 SSH 来传输命令和远程执行命令。
容器 ​ 容器就是将软件打包成标准化单元，以用于开发、交付和部署。容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。
镜像 ​ 镜像是一种文件存储形式，是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。
Docker ​ Docker是世界领先的软件容器平台。Docker属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。
详细内容： VNC简介
​ VNC (Virtual Network Console)，即虚拟网络控制台，它是一款基于 UNIX 和 Linux 操作系统的优秀远程控制工具软件。
​ VNC基本上是由两部分组成：一部分是客户端的应用程序(vncviewer)；另外一部分是服务器端的应用程序(vncserver)。在任何安装了客户端的应用程序(vncviewer)的计算机都能十分方便地与安装了服务器端的应用程序(vncserver)的计算机相互连接。
vnc工作流程： （1）在服务器端启动 VNC Server。
（2）VNC客户端通过浏览器或 VNC Viewer 连接至VNC Server；
（3）VNC Server传送一对话窗口至客户端，要求输入连接密码， 以及存取的VNC Server显示装置。
（4）在客户端输入联机密码后，VNC Server验证客户端是否具有存取权限。
（5）若是客户端通过 VNC Server 的验证，客户端即要求VNC Server显示桌面环境。
（6）VNC Server通过X Protocol 要求X Server将画面显示控制权交由VNC Server负责。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ed1700b55b080caef4937152eb494c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8da2caaf6480fcb3f2285390f0a076a5/" rel="bookmark">
			java常用的三种注释方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package basis.basis_java1; /** * 文档注释： * @author jianjian * @description * @since2021/6/721:46 * 关键字： * public 公开的/公共的 * class 类 * static 静态的/共享的 * void 空 */ public class HelloWorld { /* 多行注释： 这是一个main方法 */ public static void main(String[] args){ //单行注释：第一条输出语句 System.out.println("这是第一个程序HelloWorld"); } } 1.在java中，有三种常用的标记注释方式，最常用的是单行注释，‘//’它由两条斜杆组成记住是斜杆而不是反斜杠(\)，注释是用来给代码注释说明，会存放一些方便理解代码涵义的说明
2.如果需要写长篇内容注释且可用多行注释‘/* */'，因为单行注释已经不够满足需求了，在多行注释里面记录比较长的一段注释内容
3.最后一种注释是文档注释/** */，功能比较强大，可以生成注释文档(关于文档注释这里先有个概念)，java有自带文档注释工具在JDK安装路径下的bin目录下的javadoc.exe
4.注释在开发中及其重要，写完注释可用帮助自己快速了解每个地方的代码作用，可用方便开发记忆，提升开发效率，在工作中如果不写注释会挨批的哦，养成一个经常写注释的习惯是必要的。
注意:多行注释和文档注释切勿嵌套使用因为每一个多行注释都有一个*/ 注释遇到它自动识别注释结束
5.语文水平超级差，写文章牛头不对马嘴，看着别扭多多体谅一下哈
6.技术大佬莫嘲讽，萌新莫只看一条，有什么错误还望多指点，后续不足会加以修改补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3cd447d1b6d5e33ad7a9fb193f9a716/" rel="bookmark">
			Migration admin.0001_initial is applied before its dependency xxx.0001_initial on database ‘default‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题定位 在 Django 框架下开发，自定义了一个用户表想取代框架自动生成的用户表，执行到 migrate 命令同步数据库时出现。错误详情如下
E:\SweetYaya\MyProj01&gt; python manage.py migrate Traceback (most recent call last): File "manage.py", line 22, in &lt;module&gt; main() File "manage.py", line 18, in main execute_from_command_line(sys.argv) File "D:\Program Files\Python36\lib\site-packages\django\core\management\__init__.py", line 419, in execute_from_command_line utility.execute() File "D:\Program Files\Python36\lib\site-packages\django\core\management\__init__.py", line 413, in execute self.fetch_command(subcommand).run_from_argv(self.argv) File "D:\Program Files\Python36\lib\site-packages\django\core\management\base.py", line 354, in run_from_argv self.execute(*args, **cmd_options) File "D:\Program Files\Python36\lib\site-packages\django\core\management\base.py", line 398, in execute output = self.handle(*args, **options) File "D:\Program Files\Python36\lib\site-packages\django\core\management\base.py", line 89, in wrapped res = handle_func(*args, **kwargs) File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3cd447d1b6d5e33ad7a9fb193f9a716/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4016cb04d49e58a0d811185361af50ad/" rel="bookmark">
			PID控制模拟调节系统基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PID控制模拟调节系统 PID调节的实质是根据输入的偏差值，按比例、积分、微分的函数关系进行运算，运算结果用以控制输出。 结构灵活（PI、PD、PID等）。
一、比例（P）调节器 ​ 比例调节器的微分方程：
y ( t ) = K p e ( t ) y(t)=K_pe(t) y(t)=Kp​e(t)
​ e ( t ) e(t) e(t)为调节器输入，为偏差值， e ( t ) = r ( t ) − m ( t ) e(t)=r(t)-m(t) e(t)=r(t)−m(t)。其中 r ( t ) r(t) r(t)为给定值， m ( t ) m(t) m(t)为被测参数测量值。
​ K p K_p Kp​太大，将引起自激振荡。比例调节的优点：1、调节及时；2、调节作用强；缺点是存在静差。因此，对于扰动较大，惯性也较大的系统，纯比例调节难以兼顾动态和静态特性，需要比较复杂的调节器。
二、积分（I）调节器 ​ 积分调节器的微分方程：
y ( t ) = 1 T 1 ∫ e ( t ) d t y(t)=\frac{1}{T_1}\int{e(t)dt} y(t)=T1​1​∫e(t)dt
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4016cb04d49e58a0d811185361af50ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee4d795f575443bb3cd1b016604d9d2d/" rel="bookmark">
			正则表达式关于Pattern、Matcher部分应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 // \w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_] static final String regular = "#\\w+R(\\d+)C(\\d+)"; @Test public void test() { //编译正则表达式，在API中其实Pattern和Matcher类都有匹配的作用 //但是Matcher类提供了对正则表达式的分组支持,以及对正则表达式的多次匹配支持，包含更丰富的正则匹配操作。 // Matcher类提供了三个返回boolean值得匹配方法：matches()，lookingAt()，find()，find(int start)， // 其中matches()用于全字符串匹配，lookingAt从字符串最开头开始匹配满足的子串，find可以对任意位置字符串匹配,其中start为起始查找索引值。 Pattern pattern = Pattern.compile(regular); // flags 例如：Pattern.CASE_INSENSITIVE 忽略大小写 Pattern.compile(String regex,int flags) System.out.println(pattern.pattern()); String text= "#LRY020R008C003"; Matcher matcher = pattern.matcher(text); boolean b = matcher.find(); //组的概念：组是用括号划分的正则表达式，可以根据组的编号来引用这个组。 // 组号为0表示整个表达式，组号为1表示被第一对括号括起的组，依次类推，例如A(B(C))D，组0是ABCD，组1是BC，组2是C。 // 再例如上述例子：组0是#\w+R(\d+)C(\d+)，组1是R(\d+)，组2是C(\d+) String group = matcher.group(); String group1 = matcher.group(1); String group2 = matcher.group(2); } 正则表达式-菜鸟教程
API 使用教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94e0e9fb9e3130fa8377bedb4e328fb0/" rel="bookmark">
			Java EE大作业——基于Java EE的图书管理系统的设计与实现（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大二狗开始做Java EE大作业了，按照要求要编写开发文档。结合上个学期学的《软件工程导论》、《Java程序设计》和这个学期学的《数据库系统概论》、《软件需求工程》、《Java Web》来完成此次作业，顺带复习本学期学习的内容，以编写blog的方式记录开发历程。
由于个人能力有限，不敢保证文档的正确性，开发过程可能不会按照严格的规范进行，如果有大佬发现错漏的地方，敬请指出，不胜感激。
功能要求这块老师给的要求文档已经给出，如下：
功能要求
系统用户分为：借阅者（包括学生、教师及其他用户）、管理员
借阅者的主要功能：
个人信息管理：查看、修改个人基本信息；查询图书、借书、还书、查询借阅记录、本人可借图书总数、目前在借的数量等；借阅图书时，学生借书限制：正在借阅的图书数量最多3本，每本图书借阅时间最多2个月；教师借书限制：正在借阅的图书数量最多5本，每本图书借阅时间最多3个月；其他用户借书限制：正在借阅的图书数量最多2本，每本图书借阅时间最多1个月； 管理员的主要功能：
图书信息的添加、修改、删除、查询（按书名、书号、作者、出版社等查询）、统计（可按图书类别：外文图书、中文图书、计算机图书、文学、历史……等统计；按出版社统计……）；借阅者信息的添加、修改、删除、查询；借阅者借书限制条件的设定、查看与修改等。图书借阅与归还登记、借阅者借阅记录查询（借阅时间、借阅图书……）、图书借阅查询（包括图书当前状态、被借阅次数、借阅时间、借阅者……）等数据导入导出：从Excel导入用户信息与图书信息到数据库、将数据库中的用户信息与图书信息导出到Excel； 功能不限于以上所列出的，若有扩展功能，可加分。
我选择先画UML用例图来描述系统（作图工具：Visio2019）：
首先分析参与者：
主参与者：借阅者（用户）、管理员
次参与者：图书馆后台系统
对参与者进行细化：
绘制静态上下文图：
从功能要求中初步提取用例和子系统，绘制初步用例图：
（为什么Visio的用例图参与者跟用例的关联关系没有箭头啊？？？）
（不知道这样定义子系统是否正确，望大佬告知）
进一步细化用例：
今天的计划差不多完成了，下次更新计划完成有次参与者的用例图、类图等，用例描述工作量太大，暂时不考虑写了。
参考文献：
UML总结之用例图
UML-用例图
图书馆管理系统UML各种图
UML课程设计—图书管理系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76fec5717064e5fb3f7dd457e26b154/" rel="bookmark">
			webstorm自定义箭头函数快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		setting 设置 ，搜索“live”，找到快捷键设置的地方；
选择快捷键分类的地方，这里选择JavaScript；
添加“+”，输入“df”，说明；
注意！必须选择应用范围，否则不生效。我这里选择全部。
一图搞定，如下：
最后，在自己的项目上，愉快地用快捷键提高效率吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb817d00fa3b31ad1d55b5901663f8b6/" rel="bookmark">
			凸优化——无约束优化问题常用求解方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无约束优化问题常用求解方法 1.前情提要 上一章说了线搜索下降算法的几个关键问题，确定步长和下降方向，前一章的线搜索方法主要是确定步长。这一章确定下降方向。
2. 坐标轴下降法 3. 最速下降法 4.牛顿法 5. 修正牛顿法 6. 拟牛顿法 7. 共轭梯度法 （1） 共轭方向 定义： 设A为 n × n n \times n n×n阶实对称矩阵，如果有两个n维向量 d 0 , d 1 d^{0},d^1 d0,d1,满足 ( d 0 ) T A d 1 = 0 {(d^{0})}^TA d^1=0 (d0)TAd1=0，则向量 d 0 , d 1 d^{0},d^1 d0,d1是关于A共轭的向量。
几何解释：
对于二次函数： f ( x ) = 1 / 2 X T A X + B T X + C f(x)=1/2X^TAX+B^TX+C f(x)=1/2XTAX+BTX+C，有以下等值线。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb817d00fa3b31ad1d55b5901663f8b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08af0467a9d9ef216fab9cef9452585b/" rel="bookmark">
			基于Vue&#43;SpringCloudAlibaba微服务电商项目实战-构建会员服务-011：基于Vue快速整合会员服务接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		011：基于Vue快速整合会员服务接口 1 构建前端Vue项目调用后端接口实现联合登录效果演示2 什么是微服务前后端分离开发的模式3 联合登录接口接口简单回顾4 前后端分离解决跨域的问题5 Vue项目中构建登录页面加载网络6 回调接口需要Web层实现中转的原理7 前端获取Url中的token参数实现传递8 Vue整合后端微服务接口实现联合登录演示9 微信联合登录生成二维码说明 1 构建前端Vue项目调用后端接口实现联合登录效果演示 今日课程任务
如何快速理解前后端分离架构模式前后端分离架构模式还存在哪些缺点快速构建Vue项目调用后端接口前后端分离架构如何解决跨域的问题基于Vue调用后端接口实现联合登录如何快速部署Vue项目 2 什么是微服务前后端分离开发的模式 早期java项目 分成三层结构
com.mayikt.controller 单独web项目 ftl/jsp
com.mayikt.service
com.mayikt.dao
这种架构模式没有体现让专业的人做专业的事情
微服务架构提倡：让专业的人做专业的事情 前后端分离架构模式
如何理解前后端分离架构模式？
将以前控制层业务逻辑的操作全部交给前端开发实现，后端工程师主要开发接口被前端调用。
Vue项目的应用场景：
适用于移动端Web、微信公众号、企业级管理平台 （对搜索引擎seo不友好）
前后端分离架构模式存在哪些优缺点：
缺点：
1.联调测试 需要搭建局域网或者外网映射
2.沟通成本比较高 后端有变动需要通知前端
3.只适合比较大的互联网团队
4.跨域问题
优点：
后端开发不需要修改页面，让专业的人做专业的事情，效率更高
前后端分离架构前端页面如何部署？
前端项目实际上就是静态html+ajax调用接口绑定数据，放在nginx/tomcat服务器/cdn加速服务器中均可运行。
3 联合登录接口接口简单回顾 需要提供查询联合登录渠道接口 首页登录展示图标登录接口改造，如果有传递openIdToken，关联到数据库中根据openIdToken判断是否已经关联账号，如果关联则跳转到首页，没有关联则跳转到关联页面 查询渠道接口
数据库表meite_union_login新增字段union_image_log，存储渠道图标用于页面展示
UnionLoginDTO
@Data public class UnionLoginDTO { /** * 手机号码 */ @ApiModelProperty(value = "手机号码", name = "mobile", required = true) private String mobile; /** * 密码 */ @ApiModelProperty(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08af0467a9d9ef216fab9cef9452585b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2390a7147b36d78adc99c3282f9fe1c7/" rel="bookmark">
			从键盘输入a, b, c的值，编程计算并输出一元二次方程ax2 &#43; bx &#43; c = 0的根。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对每组输入，输出一行，输出一元二次方程ax2 + bx +c = 0的根的情况。
如果a = 0，输出“Not quadratic equation”；
如果a ≠ 0，分三种情况：
△ = 0，则两个实根相等，输出形式为：x1=x2=...。
△ &gt; 0，则两个实根不等，输出形式为：x1=...;x2=...，其中x1 &lt;= x2。
△ &lt; 0，则有两个虚根，则输出：x1=实部-虚部i;x2=实部+虚部i，即x1的虚部系数小于等于x2的虚部系数，实部为0时不可省略。实部= -b / (2*a),虚部= sqrt(-△ ) / (2*a)
#include &lt;stdio.h&gt; int main() { float a = 0.0; float b = 0.0; float c = 0.0; while(scanf("%f %f %f", &amp;a, &amp;b, &amp;c)!=EOF) { if(a != 0) { float disc = b*b-4*a*c; if(disc&gt;0.0) { printf("x1=%.2f;x2=%.2f\n",(-b-sqrt(disc))/(2*a),(-b+sqrt(disc))/(2*a)); } else if(disc &lt; 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2390a7147b36d78adc99c3282f9fe1c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/109b05496294ee471e40be903dac65cd/" rel="bookmark">
			一文详解泊车感知的摄像头需求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“3D视觉工坊”，选择“星标”
干货第一时间送达
文章导读
本文我们从泊车场景的感知需求出发探讨一些算法之外的东西，内容有些琐碎，聊点泊车感知的图像形式，感知层面的行泊一体化，相机选型中要注意哪些参数等。
1
前情回顾
上一篇我们聊了自动泊车功能中车位线识别的一些数据及算法，但是从数据的角度来说很多时候算法工程师需要用相机模组采集真实场景的图像而不是直接购买第三方或者下载开源数据集做训练。那么从数据源头出发我们需要根据算法的输入形式和感知的需求提出技术指标，筛选Sensor和镜头模组甚至进行定制化业务。
2
泊车感知的输入形式？
在目前L2~L4的方案中，摄像头作为核心传感器通常部署在车辆周围一周，甚至能有10多个摄像头配合感知周围环境。不同位置的摄像头用处也不同，前视+周视相机往往用于行车感知；鱼眼相机往往用于360环视和泊车感知；车内相机往往用于驾驶员监控。
扯得有点远了，回到主题我们说的是做泊车选用的摄像头问题。较为常规的做法是使用四颗鱼眼相机环视拼接然后在鸟瞰图上做停车位检测，障碍物检测等多任务：如下图所示：
鸟瞰图的输入形式保留了地面线条的几何特征，有利于车位线的检测。但是从上图中可以看出基于鸟瞰图的检测存在两个问题：
感知的范围局限在车身周围15米以内；
有高度的物体投影到鸟瞰图后形状扭曲；
另一种做法是使用每颗鱼眼相机输出的原始视图独立做感知，当然我们可以拿未做畸变校正的数据作为输入，也可以使用畸变校正后的数据作为输入。如下图所示：
通过原始视图可以看出车辆，树木等障碍物仍然保持物体较真实的特征，并且从图像中能够看到较远处的物体；但是地面的车位线，车道线等标志在鱼眼相机中无法维持直线等几何形态，给检测增加了一定难度。
从上面两种图像的输入形式对比出发，基于拼接的鸟瞰图适合做车位线检测，基于原始视图适合做障碍物检测，所以大多数做泊车感知时偏向于拆分成两个网络分别处理不同的任务。这种类似于松耦合的方案，两个不同的任务放在不同的网络中独立运算，然后将输出的感知结果进行过滤合并。
3
如何减少传感器的数量
由于传感器类型的不同，行车的感知和泊车的感知一般是分开来做的。但是从传感器简化的角度，行泊一体化将是未来趋势，那么势必就要考虑鱼眼和周视相机是否能统一的问题。
假如把周视广角相机和环视鱼眼相机合二为一了，接下来就是这些问题了：
需要几颗摄像头，安装在什么位置？
需要多大的视场角覆盖车身周围的环境？
需要多大的分辨率用于检测远中近的物体？
高分辨率的数据ISP能否处理，算法压力如何？
........
从硬件的角度可以定制传感器既具有鱼眼的超大FOV，又具有周视相机相对较高的PPD，能够兼顾80米甚至更远的障碍物。好奇的小伙伴肯定会问，焦距和视场角不是相互制约的吗？如下图所示：焦距越小，视场角越大。
但是挡不住模组厂商定制化业务的强大，只要有需求就有市场，有不少厂商把前视的多目摄像头整合在一个模组中用于感知。
从算法的角度需要考虑把周视相机做的的物体检测等功能和环视拼接后做的车位线检测等功能合并，这就回到上一小节提到的感知算法的图像输入形式了。功能上来说肯定是怎么做精度高就怎么来，分开多个网络各司其职完成任务，但是如果能统一输入形式，用一个模型多任务的处理所有任务，既简化了图像链路流程，又复用了一部分特征提取环节，小编觉得将是一个趋势，推荐都在原始视图上做感知功能，因为如果将一个障碍物检测的任务放在鸟瞰图上进行，那么越远处的立体物体扭曲就会越大。如图所示，在方圆5米内的车辆已然变形，何况60米处的障碍物。
4
影响摄像头性能的参数有哪些？
算法工程师需要根据功能需求提供技术要求给供应商选择合适的Sensor及镜头模组。那么有几个最常见的参数我们必须的了解：
分辨率：谈到摄像头，我们说的最多的就是分辨率是多少！通俗点说分辨率就是图像的大小，一般会用图像水平方向的像素点数 × 图像垂直方向的像素点数计算。比如业界说的标清的分辨率就是1280×720，也叫720P；高清的分辨率就是1920×1080，也叫1080P。
所以图像的分辨率越高，包含的像素越多，画面看起来就越清晰。描述分辨率的单位有以下几种：
dpi（点每英寸）
lpi（线每英寸）
ppi（像素每英寸）
ppd（像素每度）
其中ppd是算法工程师接触较多的一个指标，指视场角中的平均每 1° 夹角内填充的像素点的数量。如下图所示（图片来自于网络）：
人眼观察周围环境时水平FOV是210°，垂直FOV是100°，当我们看手机时一般距离30~40cm，假设1°里面占据60个像素时，人眼是无法分辨像素颗粒度的。所以在VR等消费电子行业比较流行的说法是将60ppd的图像称为视网膜分辨率。
那么像素颗粒度是什么感觉？看看下图体会一下：
帧率：这是另一个常用的参数指标，一般指摄像头在某种色彩空间中最大分辨率下能够支持的最高视频捕获能力。
对于人眼来说，一般运动场景下能到达15fps的帧率已经是连续运动的效果了；但是对于感知算法在高速场景下还是需要摄像机满足30fps及以上的帧率。
相机的各个参数之间都有其关联性，比如上面说的ppd就和分辨率及视场角密切相关。那么帧率与分辨率和视场角有没有什么关系呢？
为了提高帧率，首先我们会考虑是否可以缩小视场角，如若不行，是否可以减少分辨率。在很多镜头的datasheet中会出现pixel binning mode。分辨率的下采样模式其实有两种：
Binning Mode
Skipping Mode
Binning Mode是将相邻的相同颜色单位电荷相加后输出一个信号。采用这种电荷合并的方式可以提供暗处对光感应的灵敏度。如下图所示（将四个相同颜色的B合并成Bs，其他雷同）：
Skipping Mode是删除相邻的行列，起到隔行列抽样的效果。如下图所示：
动态范围：指图像最亮和最暗部分的相对比值。当在强光源照射下的高亮度区域及阴影、逆光等相对亮度较低的区域在图像中同时存在时，摄像机输出的图像会出现明亮区域因曝光过度成为白色，而黑暗区域因曝光不足成为黑色，严重影响图像质量。如果Sensor内的HDR达到一定的DB后，即可缓解此类情况。如下图所示：
还有好多比较重要的参数就不一一列举了，比如MTF：即调制传递函数，用于描述镜头的性能。
Distortion：物体通过光学系统后实际像高与理想像高的差值，离光轴越远的点畸变越大。
RI：即相对照度，用于描述光学系统成像面均衡性。
SNR：即信噪比，用于描述成像的抗干扰能力。
感光部件：CCD或者CMOS两种；
滤光片类型：RGGB、RCCB、RCCC等
这两个参数在之前的一篇文章里小编简单介绍过。
5
镜头的定制原则
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/109b05496294ee471e40be903dac65cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3433445c6c987527ad11780263c9311/" rel="bookmark">
			如何判断自己是在使用cpu还是gpu跑代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何判断自己是在使用cpu还是gpu跑代码 在Linux系统下，可以通过在终端中输入一句命令来查看自己跑的代码是在用CPU还是GPU：
nvidia-smi 举例：
上图可以看出，GPU利用率为5%，当前代码是在使用cpu。
上图可以看出，GPU利用率为83%，当前代码是在使用gpu。
除此以外，使用该句命令也可以查看自己的gpu版本和cuda版本。
具体每个参数代表什么意思，可以通过参考这篇文章https://blog.csdn.net/a784586/article/details/78688842
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70d6ea81d9a425b6af723ecbcb26c289/" rel="bookmark">
			html 文件上传与移除,js jquery分别实现动态的文件上传操作按钮的添加和删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javascript实现
jquery文件上传 var addMore = function() {
var div = document.getElementById("div2");
var br = document.createElement("br");
var input = document.createElement("input");
var button = document.createElement("input");
input.setAttribute("type", "file");
button.setAttribute("type", "button");
button.setAttribute("value", "Remove");
button.onclick = function() {
div.removeChild(br);
div.removeChild(input);
div.removeChild(button);
}
div.appendChild(br);
div.appendChild(input);
div.appendChild(button);
}
//节点的移动
//$(function(){
//});
jquery实现
jquery文件上传jquery1 /** var addMore = function() {
var div = document.getElementById("div2");
var br = document.createElement("br");
var input = document.createElement("input");
var button = document.createElement("input");
input.setAttribute("type", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70d6ea81d9a425b6af723ecbcb26c289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c180cd2e30be3b87f56ab55875b287b/" rel="bookmark">
			easyui 动态添加html,jQuery EasyUI动态添加控件或者ajax加载页面后不能自动渲染问题的解决方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AJAX返回的html或者是js定义的html无法做到自动渲染为EasyUI的样式。比如：class="easyui-linkbutton" 等，虽然我们可以对应执行代码来渲染它，但前提是你得知道它是什么控件，比如：
$("body").append('确定按钮');//生成控件html
$("#a").linkbutton();//渲染
但是假如控件不确定时就不能使用以上方法，我们可以为其扩展一个方法。
(function ($) {
$.parser = {
auto:true,
plugins:['linkbutton', 'menu', 'menubutton', 'splitbutton', 'layout','tree', 'window', 'dialog', 'datagrid','combobox', 'combotree', 'numberbox', 'validatebox','calendar', 'datebox', 'panel', 'tabs', 'accordion'],
parse:function (context) {
if ($.parser.auto) {
for (var i = 0; i (function () {
var name = $.parser.plugins[i];
var r = $('.easyui-' + name, context);
if (r.length) {
if (r[name]) {
r[name]();
} else if (window.easyloader) {
easyloader.load(name, function () {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c180cd2e30be3b87f56ab55875b287b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e156295d6c9c5952e99054eea810c351/" rel="bookmark">
			java报错nested exception is org.apache.ibatis.exceptions.TooManyResultsException: Expected one result
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息：nested exception is org.apache.ibatis.exceptions.TooManyResultsException: Expected one result 一、原因是：
xml文件中查询语句查出多条数据，但是返回的类型只能是一条。
二、解决办法：
①查看sql语句有没有报错。
②查看xml文件中的返回类型，是否是resultType返回的不是list集合，可以改成resultMap,或者返回list。
③dao层返回值是否与xml文件中的返回类型是否符合。
④我去数据库删除了同名的数据，然后重启项目解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00d489ba7f01f402ff52cb9cf273c8e7/" rel="bookmark">
			【Django】django.core.exceptions.ImproperlyConfigured: mysqlclient 1.4.0 or newer is required
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Django】django.core.exceptions.ImproperlyConfigured: mysqlclient 1.4.0 or newer is required 原因处理方式一处理方式二 使用的Django版本为2.2
raise ImproperlyConfigured('mysqlclient 1.4.0 or newer is required; you have %s.' % Database.__version__) django.core.exceptions.ImproperlyConfigured: mysqlclient 1.4.0 or newer is required; you have 0.10.0. 原因 原因是 MySQLclient 目前只支持到 Python3.4，你使用了更高版本的 python
处理方式一 在setting.py同文件夹下的_init_.py加入以下内容
import pymysql pymysql.version_info = (1, 4, 13, "final", 0) # 指定版本 pymysql.install_as_MySQLdb() 就可以不报错了。
处理方式二 点报错的代码文件路径信息，讲报错的代码行数注释掉。
通过报错信息的文件路径找到 …\django\db\backends\mysql 这个路径里的 base.py 文件，把代码开头的两行代码注释掉
# if version &lt; (1, 3, 13): # raise ImproperlyConfigured('mysqlclient 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00d489ba7f01f402ff52cb9cf273c8e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb5cc2beb3e8798db2487c05e5a3b44c/" rel="bookmark">
			网络技术《五》物理层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言： 物理层是OSI参考模型中的第1层，物理层利用传输介质为通信的两端建立、管理和释放物理链接，实现比特流的透明传输，保证比特流正确的传输到对端。物理层中承载的是比特流单位是比特（bit）。局域网与广域网皆属第1、2层。
物理层数据传输方式: 1，根据数据传输的方向和时间可分为单工通信，半双工通信，全双工通信
单工通信：只能向一方可以发送数据。如广播，电台
半双工通信：两个方向都可以发送数据，但同一时间只能往一个方向发送数据。如：对讲机
全双工通信：两个方向都可以发送数据，也可以发送数据或接收数据。如:电话，手机
2，根据信道的使用数量可分为串行通信和并行通信
串行通信：数据在1个信道中串行传输，只需创建1个信道。
并行通信：数据分别在多个信道中并行传输，需求创建多个信道。
物理层数据传输类型： 物理层的传输介质中传输的信号共分为两种，模拟信号、数字信号，家里的电话、有线电视就是用的模拟信号，电脑上网就用的是数字信号。通信模型如下图。
调制：将数字信号转换为模拟信号
解调：将模拟信号转换为数字信号
物理层的协议： 电话网络modems-V.92EIARS-232，EIA-422，EIA-423，RS-449，RS-485Ethernet physical layerIncluding10BASE-T，10BASE2，10BASE5，100BASE-TX，100BASE-FX。100BASE-T，1000BASE-T，1000BASE-SX还有其他类型Varieties of 802.11Wi-Fi物理层DSLISDNT1 and otherT-carrierlinks， and E1 and otherE-carrierlinksSONET/SDHOptical Transport Network（OTN）GSMUm air interface物理层Bluetooth物理层IEEE 1394 interfaceTransferJet物理层EtherloopARINC 818航空电子数字视频总线G.hn/G.9960物理层CAN bus（controller area network）物理层 常见的物理层设备： 网卡，光纤，CAT-5线，RJ-45接头，集线器有整波作用，Repeater加强信号，串口，并口 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59e92c00d8937b67eafd7901ff58041e/" rel="bookmark">
			SSL简单梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、SSL全景式说明2、密码学工具对称加密算法非对称加密算法摘要算法 3、SSL解决方案-数字证书4、SSL协议流程5、参考 1、SSL全景式说明 最常见的SSL的应用是在HTTPS中，主要是在传输层之上，应用层之下，加入了一层加密层，构建一条安全的信道，来传输应用层的数据，传输层的TCP仅保证了传输数据不丢包，但是未保证数据在传输的过程中不被窃听，篡改，甚至有可能访问的对端本身就是一个伪装的对端，比如出现了DNS劫持的情况。
SSL主要就是为了解决上述3个问题，来保证 数据的保密性，数据的完整性以及完成身份认证。
SSL的协议先后经历过SSL1.0，SSL2.0 和SSL3.0版本，较新的版本为TLS1.0，TLS1.1，TLS1.2，TLS1.3。TLS 1.3为最新版本。早期版本如SSLV2和SSLV3均有较严重漏洞，均已废弃
主流的SSL的实现为openssl（https://www.openssl.org）和mbedtls（https://tls.mbed.org/）。
2、密码学工具 SSL对核心问题的解决依赖于密码学工具，涉及到的密码学原理主要包括三种。分别是对称加密算法，非对称加密算法，以及摘要算法。
对称加密算法 对称加密算法的核心是发送端和接收端使用同样的密钥，对数据进行加密和解密。
优点是相对于后续介绍的非对称加密算法来说执行很快。
缺点是密钥管理存在风险，任意一端保有的密钥泄露，就会导致传输数据的泄密。
常见的对称加密算法包括，DES，3DES，AES，RC4等等。其中DES以现在的计算能力非常容易被破解。
目前应用最多的为AES(advanced encryption standard)。
对称加密算法由于其高效性在实际的解决方案中被广泛应用，用于解决数据传输过程中的数据的保密性的问题。但对称加密算法的前提是双端都要持有密钥，很显然双端的密钥获取有两种方式，一种是提前通过某种方式预置密钥到发送端和接收端，显然这种方式存在巨大的泄露风险，另一种便是在执行信息交换前，通过某种安全的方式来实时交换共同的密钥，这也是目前主流的解决方案，非对称加密算法就是为了解决这个问题应运而生的。
非对称加密算法 非对称算法的核心目的是在尚不安全的信道，进行密钥的交换，同时要保证该密钥不被任何人窃取，显然这个密钥不能以明文的方式在信道上传输。
主流的解决方案有两种类型，第一类是最常见的包含公私钥类的密钥交互算法，第二类是DH类密钥交换算法。如下表格说明了两种类型的非对称加密算法的协商过程。
公私钥类的密钥交互算法（以RSA为例）DH类密钥交换算法（以DHE为例）1、客户端发起请求，服务器端回复公钥1、客户端申请开始DHE交换流程2、客户端用随机数算法生成密钥S，使用公钥加密生成C，发送给服务器2、服务端选定大数p和q,生成随机值Xb。p和q为全世界公认的一对值。发送Pb和DHE参数p和q给客户端。（Pb=q^Xb mod p）3、服务器收到C后，使用公钥对应的私钥进行解密，得到S，通知客户端ok3、客户端收到DHE参数p和q之后，生成Xa，计算得到Pa，返回给服务器端4、客户端和服务端后续使用S加密来交换数据4、同时客户端根据收到的Pb，根据Xa和Pb计算得到Sa(Sa=Pb^Xa mod p)5、服务器端收到Pa后，根据Xb和Pa计算得到Sb6、Sa=Sb=S，客户端和服务端使用S来交换数据。 可以看到DH类密钥交换算法相对于公私钥类密钥交换算法稍为复杂，公私钥类算法存在前向不安全问题，受限于私钥是否安全保存。而DH类密钥交换算法，每条会话都会新生成一个密钥，且交换依赖于公开的大数p和q，没有服务器私钥介入密钥交换的流程。
第一类公私钥类的密钥交换算法主要包括RSA算法，ECDH算法。
第二类DH类密钥交换算法的主要包括DHE算法，ECDHE算法。
非对称加密算法辅助对称加密算法，完成保证数据保密性的任务，同时在身份认证中也发挥重要作用，后续会继续描述
摘要算法 摘要算法的核心是生成数据的一段标签，该标签的生成是不可逆的，即无法通过标签反向地推导出数据。同时摘要算法的输出长度是固定的。
常见的摘要算法包括：md5，sha(根据长度分为sha256,sha384等等)，mac
很显然摘要算法可以用于数据的完整性校验，保证数据不被篡改。很多网站在发布软件安装包时也会附上安装包的MD5值，让使用者方便地判断下载的文件是否与发布的文件的一致，或者是被篡改。
3、SSL解决方案-数字证书 如节1所述，SSL主要解决数据的保密性，数据的完整性以及完成身份认证
数据的保密性可以通过对称加密算法配合非对称加密算法解决，数据的完整性可通过摘要算法解决。那么身份认证如何解决呢？
可以联想到我们实际生活中，找工作时需要有大学颁发的大学毕业证书，才能让用人单位信任你的学习能力。购买食品饮料时，外包装会有食品药品监督管理局印发的凭证，证明自己可靠的食品。
网络上的服务端或者说网站亦是如此，需要提供某种证书凭证来证明自己是一个可信的服务端，这种证书往往是通过某个公开权威机构获得的，同时我们也可以使用该证书去权威机构那边认证，这就是所谓的数字证书。
数字证书的生成与认证，大量地用到了上述的对称，非对称，以及摘要算法。
证书内容包含的最主要信息是 证书的拥有者，证书的颁发者，证书的截止日期，证书公钥，以及附加的用于认证的签名。
签名是通过对签发的数字证书的内容进行摘要，然后对得到的结果用根证书的私钥进行加密得到的值。而证书的颁发者也会发布证书，这种证书称为根证书，拥有者和颁发者是同一机构，包含有证书公钥。根证书是可以用于认证根证书签发的证书的证书，在主流的浏览器chrome,ie,firefox，以及主流的操作系统windos,mac,linux,ios,android中都会内置很多根证书机构的根证书。
所有希望在网上提供宣称自己是可靠安全服务的服务端，都需要去根证书机构申请得到签发的证书。但互联网上网站和服务如雨后春笋般多，根证书机构根本来不及处理，就会签发一些中间证书，也就是证书中间商，这些中间商的证书是由根证书机构签发过的，服务器希望申请证书也可以去这些中间商机构申请签发，通过中间商签发的证书也能够经过认证，这就是证书的链式认证。
具体证书的生成和认证流程，以及该流程中是如何应用上述加密算法，在如下表格中作了简单说明。
证书生成证书认证1、使用工具生成公钥与私钥，比如openssl工具（这点也可能是完全直接由机构生成）1、服务器将证书返回给客户端2、构造证书，把公钥嵌入证书2、客户端将返回的证书除了签名外，进行摘要计算，得到R13、缴纳费用给根证书或者中间证书机构，并提供证书3、客户端根据证书找到签发的证书，用签发证书的公钥对签名进行解密，得到R24、对证书做摘要，并用根证书的私钥加密摘要，作为签名4、比较R1和R2是否一致，结果通过就说明认证通过，信任服务端。5、证书生成完成，可以分发给后续需要连接的客户端 4、SSL协议流程 通过上述梳理可以明确基于SSL协议的连接的典型核心流程如下序列展示。
上述流程说明了SSL对数据传输中的核心安全问题的解决方案，但是对称加密算法有多种，非对称加密算法亦有多种，实际在单次连接中，只需要用到对应各一种算法即可，而且不可能所有的终端都实现了所有的算法，故而SSL协议就定义了SSL报文的交互流程，用于协商具体使用何种算法，当然也包括认证。
一个典型的SSL报文交互流程如下
典型的SSL报文包含两个部分，RECORD层和HANDSHAKE层。
RECORD层即头部，包含内容类型，协议版本和长度。HANDSHAKE层根据内容类型，各有差异。
最核心的协商流程包含以下环节（内容类型），并非所有环节都是必须环节
内容类型内容含义是否必须Client Hello客户端发起SSL连接请求，发送包含加密套件（cipher suite）等核心字段和部分扩展字段是Server Hello服务器端回应client hello, 返回支持的TLS版本，选定的加密套件和压缩方式等等是Server certificate服务器端发送证书是Server key exchange发送DH类密钥交互算法中客户端所需的密钥否，仅在DH类密钥交互算法握手时需要Certificate request服务器端请求客户端发送证书认证否，仅双向认证时需要Server hello done告知客户端 服务器端的握手阶段报文发送完毕是Client certificate返回服务器客户端的证书否，仅双向认证时需要Client key exchange根据不同的密钥交互类型， DH类或者公私钥类，返回服务器端所需的运算生成密钥的参数是Change Cipher表示后面发送的数据会用密钥加密是…还包括其他一些环节 典型的DH类密钥交换流程的交互流程如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59e92c00d8937b67eafd7901ff58041e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd99ab2d82068f8d5f9591c712b7836/" rel="bookmark">
			Faser-RCNN之ROIPooling详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Faster-rcnn中，ROIPooling的作用是将原图像上不同大小的proposal映射到特征图上同等大小的区域，以便后面进行分类和回归预测。既然是pooling,它的本质也是一种最大池化。那么究竟是如何映射的呢？
可以通过代码来了解一下
这个是roi的代码部分，其中输入feature是网络输出的特征图，proposal是RPN网络生成的，并且经过筛选的候选框，image_shapes是原始图像的尺寸。输出就是经过roi之后固定区域的候选框。
通过debug来详细看一下各个部分的形状
features:
我么使用的主干网是mobilenet batch是2 所以这里是2x1280x17x17
proposal
两张图像对于有两个候选框的列表
候选框在在第一张图像上有512个 第二张图像上有508个
image_shape
这个里面存放的是输入图像的尺寸。
box_feature
它是通过roi之后的结果，可以发现它的通道数为1280，是之前特征图的通道数，7x7是固定尺寸的大小，1020是两个候选框列表加起来的总数。这个是怎么来的呢？
为了在特征图上获得尺寸大小相同的候选框，第一步肯定就是要把候选框弄到特征图上去，第二部获得相同大小的候选框。
第一步实现方式：
从上面代码中可以发现，我们传入了输入图像的尺寸和特征图的大小，那么我么就可以根据它们二者的关系算出特征图和原始输入图像的缩放关系，我们这里记为ratio。
对于候选框，rpn网络预测的候选框是对应原图上面的候选框，并且用的是左上角加右下角的坐标形式来表示这个框（这就是为什么候选框的形状是512x4，表示总共512个候选框，每个框四个坐标）,所以我们可以根据这个缩放关系ration，将这个候选框的四个坐标映射回特征图上面，这个过程要进行一次取整操作。
第二步实现方式：
现在在特这图上已经有了大小不一的候选框，我们就是要把它弄成一样尺寸的。这里借助一下网上的例子，假设输出的尺寸统一为2x2，特征图如下所示，某个候选框映射到特征图上的坐标为（0，3），（7，8），即为图中黑色的部分。注图像的坐标系以左上角为（0，0）
那么整个候选框的区域大小为（5，7），我们为了得到2x2的候选框，将它分别除（2，2）然后取整，得到每个roipooling的区域大小。
即5/2=2.5取整得2，7/2取整得3
然后在行上取两行，列上取三列作为第一个区域，剩下的作为第二个区域。这样候选框就被划分为四个不同大小的区域，然后我们再对每个区域求最大池化，可以得到四个相同的区域。
这个就是roipooling的过程了。再回到上面的代码，通过roipooling函数之后的输出为
它只是输出区域的尺寸为7x7,然后由于特征图有1280个通道，候选框映射回去之后要对每个通道的特征图进行roipooling所以通道是不会改变，1020就是候选框的个数总和，即把两张输入图像的候选框堆叠到一起了。
总结
roipooling就是把输入图像的不同尺寸候选框映射到特征图上相同尺寸，其间会有两次取整操作，会损失一些精度，故之后又提出roialign。
都看到这里了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf193ee85c921abcd87107094281d755/" rel="bookmark">
			阿里云HaaS100主板在Alios things中控制380V遮阳棚电机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档说明 本文是说明HaaS100通过RS485串口控制380V电机的开发记录：
涉及到modbus的驱动函数使用，以及跟厂家的协议匹配，数值处理等方面。
我的系统通过HaaS100的RS485口，连接了1个32位的Modbus继电器。
目录
文档说明
1.设备连接拓扑
2.程序实现
3.助人自助
1.设备连接拓扑 这个拓扑图是简化了的，实际上控制一个380V的电机，需要3个继电器，脉冲式的控制电机启动。这在制作配电柜的时候，需要跟厂家说明，预留出接线端子。
2.程序实现 程序上实现需要以下三步：
2.1.控制继电器脉冲式开关
/* 函数名称：Set_Switch_state 函数功能： 设置继电器闪开闪关，因为是脉冲输出，因此其实没有所谓开或是关，都一样 输入参数： 参数1：mb_handler1 modbus数据结构句柄 参数2：DeviceAddr Modbus地址 参数3：Coiladdr 线圈地址 参数4：CoilValue 线圈状态 Switchon,Switchoff; 输出参数：成功与否的标志位 */ mb_status_t Set_Switch_state(mb_handler_t *mb_handler1,uint8_t DeviceAddr,uint16_t Coiladdr,uint16_t CoilValue) { mb_status_t status1; mb_handler_t *mb_handler; uint16_t data_resp = 0; status1 = mbmaster_write_single_coil(mb_handler1, DeviceAddr, Coiladdr,Switchon, NULL, &amp;dat a_resp, NULL, AOS_WAIT_FOREVER); status1 = mbmaster_write_single_coil(mb_handler1, DeviceAddr, Coiladdr,Switchoff, NULL, &amp;data_resp, NULL, AOS_WAIT_FOREVER); return status1; } 2.2.解析云端指令并执行
/** recv event post response message from cloud static int user_property_set_event_handler(const int devid, const char *request, const int request_len) { int res = 0; EXAMPLE_TRACE("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf193ee85c921abcd87107094281d755/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8e912757e5823c189ec7ad938600c0c/" rel="bookmark">
			leetcode_160_相交链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相交链表 描述 简单
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
图示两个链表在节点 c1 开始相交：
题目数据 保证 整个链式结构中不存在环。
注意，函数返回结果后，链表必须 保持其原始结构 。
示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Intersected at '8' 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2：
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Intersected at '2' 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8e912757e5823c189ec7ad938600c0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4c987daf1be60d0cb6f7261350a5f13/" rel="bookmark">
			蓝湖根据设计图生成html,蓝湖新功能｜ 一键生成整页代码，帮开发留住头发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蓝湖 Sketch 插件更新啦！此次更新优化了插件的上传速度，还有配套惊喜功能【一键生成整页代码】上线！
设计师更新 Sketch 插件后，上传移动端设计图，开发即可查看、复制使用设计图对应的整页代码，让开发效率起飞！
惊喜功能 —— 【一键生成整页代码】
蓝湖【一键生成整页代码】功能，能自动生成 HTML、Vue、React 等框架代码。
能做到：
代码高度还原整页设计
部分组件识别，绑定相关事件
目前支持移动端设计图代码生成
简化开发工作流程，有效解决前端工程师撸界面代码费时费力的问题，提升设计和开发的对接效率、全团队的工作和协作效率。
使用新功能 —— 【一键生成整页代码】
第一步：更新【蓝湖 Sketch 插件】至最新版本
复制链接，在 PC 端下载：
https://lanhuapp.com/mac
第二步：使用最新版【蓝湖 Sketch 插件】上传设计图
第三步：一键生成整页代码在蓝湖【标注详情页】，单击设计图，点击【标注信息栏】最下方的“查看整页代码”，即可解锁蓝湖惊喜功能【一键生成整页代码】；
支持查看、复制使用整张设计图的代码；
选择【代码运行效果】，点击设计图上的相关元素，该元素对应的代码将高亮显示，复制即可使用。
本次 Sketch 插件更新后，设计图的上传速度更极速，还能使用蓝湖的 Beta 功能【一键生成整页代码】。
小伙伴们都表示新版 Sketch 插件体验更流畅，配套功能【一键生成整页代码】生成的整页代码规范，能直接复制使用，让前端工程师的开发效率更高。
你还在等什么，马上更新插件，让开发效率更上一层楼，早点下班，保住头发！
复制链接，在 PC 端下载：
https://lanhuapp.com/mac
从上线至今，蓝湖一直在寻找最佳的工作、协作方式。你对蓝湖有什么建议？希望蓝湖上线什么功能？欢迎在评论区留言，用心的建议，湖湖一定会牢记于心并付诸实践，让产品更好用，让你和团队的效率起飞！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32be12f5efd44284bc40583444393899/" rel="bookmark">
			软件测试简历上实战项目：开源项目部署--litemall商城
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		litemall 是一个以SpringBoot + Vue管理员前端 + 微信小程序用户前端 + Vue用户移动端组成的一个小商城，gitee上Star有6000+，不考虑相关中间件的情况下，项目采用的技术比较接近企业用的一些基本技术。对于自学软件测试或者参加培训，找不到合适的项目写简历上，以及平常自己学习，找不到合适的项目练手的，都可以用这个项目搭建在本地练手。
初学者，自己自学的过程中很容易走弯路，比如经常在那自己折腾虚拟机以及各种环境就要折腾大半天，其实在我看来这个还是没必要的，没必要非得在linux上去部署，以我工作7年的经验告诉你们，你们大部分在虚拟机上折腾的这些东西，在工作中基本上用不到，或者很多东西其实都是现成的，不会让你们从头开始去弄，如果非要学习的话，小白就买一个阿里云服务器就好了，新人买个1-3年，费用也不贵，最起码不用去折腾各种什么xshell连接不上虚拟机的问题，这些相关的操作等你入了行，对这个行业有了更多的认知之后，回过头再去学这些，会比较容易接受一点，现阶段，作为测试人员，能够掌握自己在本地windows或者mac电脑上对常用的软件操作熟练就可以了。
接下来简单讲一下在本地怎么去搭建litemall商城用来学习使用,，当然，具体的部署教程，一般的开源项目上都有写，你如果看别人的文档能够直接看懂当然是最好，看不懂的朋友，可以再试试看这篇文章。
准备工作：
电脑本地git环境搭建 Git环境搭建
java环境搭建 Java环境搭建
maven环境变量配置 Maven环境搭建
nodejs环境搭建 Node.js环境搭建
代码下载：
代码地址：https://gitee.com/linlinjava/litemall
找一个目录，然后鼠标右键，选择Git Bash Here,在弹出的窗口中输入如下命令：
git clone https://gitee.com/linlinjava/litemall.git maven修改mirrors镜像地址
修改目的：加快后台代码jar包下载，提升打包效率
修改方式：进入到maven安装的目录后，找到conf文件夹，然后找到里面的settings.xml,用文本文件打开进行编辑：大概在140多行的样子，或者搜索mirrors标签，然后加入如下的配置:
&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 修改后的内容截图如下：
创建数据库以及导入数据
进入到从gitee上下载好的代码文件夹中，然后进入到litemall-db\sql目录下面，依次执行下面的sql文件：
1、litemall_schema.sql 执行后会自动创建一个litemall的数据库，如果数据库已存在，则会删除重建
2、litemall_table.sql 选择litemall数据库后，执行改脚本，会自动创建项目中用到的表
3、litemall_data.sql 选择litemall数据库后，执行该脚本，会导入初始化测试数据，其中包括前端登录的用户账号
代码打包编译
需要进行打包的操作如下：
后端代码打包&amp;本地启动
打包：
先进入到代码的根目录，也就是最外层的pom.xml文件所在的目录，打开cmd窗口(在windows的文件管理器中输入cmd回车),执行以下命令打包后端代码：
mvn -U clean install 执行完命令后，会看到很多SUCCESS则表示打包成功：
这里打包的命令用mvn install / mvn package均可，-U 以及clean 参数不加问题也不大。打完包后，在litemall-all目录下的target文件夹中会有一个xxx-exec.jar的可启动jar包，这就是打好的部署包，在litemall-all-war文件夹下也会生成一个war包，不过war包我没有试过能不能部署，感兴趣的可以自己去试试。
本地启动后端的服务
cmd窗口执行java -jar xx.jar的方式就可以启动服务。
进入代码根目录后，执行下面命令 chcp 65001 java -Dfile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32be12f5efd44284bc40583444393899/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/605f17799fde8c787ee8ae4c106c7265/" rel="bookmark">
			android fastboot流程,fastboot使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		user@user-OptiPlex-3020:~$ fastboot -h
usage: fastboot [ ] commands:
update reflash device from update.zip
flashall flash boot + recovery + system
flash [ ] write a file to a flash partition
erase erase a flash partition
format format a flash partition
getvar display a bootloader variable
boot [ ] download and boot kernel
flash:raw boot [ ] create bootimage and flash it
devices list all connected devices
continue continue with autoboot
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/605f17799fde8c787ee8ae4c106c7265/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/313199a17483b4a8f4b8d5d4e4de6fe1/" rel="bookmark">
			vue elemenUi el-input 限制只能输入数字时与表单验证rules冲突问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.el-input 限制只能输入数字时 οninput="value=value.replace(/^\.+|[^\d.]/g,'')
问题: 当输入其他字符再输入数字的时候，输入框中显示有值，就会与表单验证 rules冲突.
但实际去打印 v-model绑定的变量时获取不到新输入值。表单验证信息会一直存在.
2. 解决方法 加入事件: @blur="salaryChange"
&lt;el-form :model="feedForm" ref="feedForm" :rules="rules"&gt; &lt;el-form-item label="饲料重量(g)/转：" :label-width="formLabelWidth" prop="perWeight"&gt; &lt;el-input v-model="feedForm.perWeight" autocomplete="off" maxlength="10" oninput="value=value.replace(/^\.+|[^\d.]/g,'')" @blur="salaryChange"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; 3. 事件 输入框失去焦点时，会把value值赋值给v-model绑定变量，使两者保持一致
salaryChange(e){ this.feedForm.perWeight = e.target.value }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c0895c3b933925e33b730f781daae47/" rel="bookmark">
			ValueError: not enough values to unpack (expected 3, got 1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ValueError:没有足够的值来解压(预期3，得到1)
方法的输出与预想的不一致。
def get_df():# 读取数据并返回 df = {} f = open("ml-1m.txt",'r') user = [] item = [] times = [] for line in f: try: # u, i ,rate,timeStamp = line.rstrip().split('/t') u, i ,rate,timeStamp = line.rstrip().split('\t') except: # u, i ,timeStamp = line.rstrip().split('/t') u, i ,timeStamp = line.rstrip().split('\t') user.append(u) item.append(i) times.append(timeStamp) df['user'] = user df['item'] = item df['times'] = times f.close() return pd.DataFrame.from_dict(df) 我原型代码的问题就是 转移字符写错了，而且自己看了好几遍还没有看出来
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/415943b0ca78b51fbe643fab77a14e6e/" rel="bookmark">
			某知名大佬爆出阿里Java岗面试的4大难题：JVM&#43;微服务&#43;MySQL&#43;Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要入职大厂可谓是千军万马过独木桥。要通过层层考验，刷题肯定是必不可少的。
作为国内互联网技术的典型代表，阿里巴巴的技术一直备受着大家的关注。能进入阿里工作，是很多开发者们的目标与梦想，为帮助开发者们提升面试技能、高效通关一线互联网公司的面试，小编把有关这四个方面的面试题提炼总结，一次整体放出送给大家。
JVM面试题 1、内存模型以及分区，需要详细到每个区放什么？
2、堆里面的分区：Eden，survival （from+ to），老年代，各自的特点？、
3、对象创建方法，对象的内存分配，对象的访问定位？
4、GC 的两种判定方法？
5、SafePoint 是什么？
6、GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？
7、GC 收集器有哪些？CMS 收集器与 G1 收集器的特点？
8、Minor GC 与 Full GC 分别在什么时候发生？
9、几种常用的内存调试工具：jmap、jstack、jconsole、jhat？
10、类加载的几个过程？
11、JVM 内存分哪几个区，每个区的作用是什么?
12、如和判断一个对象是否存活?(或者 GC 对象的判定方法)
13、简述 java 垃圾回收机制?
14、java 中垃圾收集的方法有哪些?
15、java 内存模型？
16、java 类加载过程？
17、简述 java 类加载机制?
18、类加载器双亲委派模型机制？
19、什么是类加载器，类加载器有哪些?
20、简述 java 内存分配与回收策率以及 Minor GC 和Major GC
由于题目过多，所以只列举了部分题目，小编已经把全部的面试题和答案整理成了pdf文档，有想要获取的朋友：一键三连（点赞+收藏+关注） 后，添加微信：mxm9843 即可免费获取到。
微服务面试题 SpringBoot
什么是Spring Boot？Spring Boot有哪些优点？什么是JavaConfig？如何重新加载Spring Boot上的更改，而无需重新启动服务器？Spring Boot中的监视器是什么？如何在Spring Boot中禁用Actuator端点安全性？如何在自定义端口上运行Spring Boot应用程序？什么是YAML？如何实现Spring Boot应用程序的安全性？如何集成Spring Boot和ActiveMQ？如何使用Spring Boot实现分页和排序？什么是Swagger？你用Spring Boot实现了它吗？什么是Spring Profiles？什么是Spring Batch？什么是FreeMarker模板？如何使用Spring Boot实现异常处理？您使用了哪些starter maven依赖项？什么是CSRF攻击？什么是WebSockets？什么是AOP？什么是Apache Kafka？我们如何监视所有Spring Boot微服务？ SpringCloud
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/415943b0ca78b51fbe643fab77a14e6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e61305f97e3d2fc36de5654d650f138/" rel="bookmark">
			Java程序员进阶架构师必备学习文档：SSM&#43;微服务&#43;分布式&#43;Nginx&#43;MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSM企业级战 SSM框架是以Spring为核心，整合Spring MVC和Mybatis的轻量级框架技术的组合。利用SSM整合框架可以开发出分层、易扩展、易维护的企业级应用系统，能够极大地满足企业需求，减少开发工作量，提高开发效率和质量，并有效减少维护工作量。
分布式服务架构：原理、设计与实战 随着时代的不断发展，分布式服务架构日益流行，已经从SOA服务化发展到了微服务架构。有过惊喜，有过质疑，但这未能阻挡分布式服务架构在互联网行业里的普遍应用。然而，事物总是有两面性的，丰富的新框架及新技术层出不穷，给项目的技术决策者带来了技术选型上的困难。此外，在互联网交易越来越复杂、规模越来越庞大的背景下，解决分布式服务间的事务问题、业务- -致性问题、可用性问题、稳定性问题等的困难以指数级增加。
本书以一位在IT行业从事多年分布式服务架构工作的资深老兵的视角，剖析了针对分布式系统架构的解决方案和设计模式。书中的每一一章、每一节都是作者对多年线上系统架构设计实践的总结。
电子版全章节：
由于文档内容过多，所以只截取了目录部分，每个知识点都有更细化的内容。
需要获取以上文档资料的朋友：一键三连（点赞+收藏+关注） 后，添加微信：mxm9843 即可免费获取到。
Spring Cloud微服务架构实战 “微服务”架构在这几年被广泛传播，变得非常火热，以至于关于微服务架构相关的开源框架和工具都变得越来越活跃，比如: Netflix OSS. Dubbo、Apache Thrift等。Spring Cloud也因为Spring社区在企业应用领域的广泛知名度和强大影响力，受到了广大架构师与开发者的高度关注。
电子版全章节：
深入实战SpringBoot Spring Boot作为Java编程语言的一一个全新开发框架。相比于以往的一些开发框架，Spring Boot不但使用更加简单，而且功能更加丰富，性值更加稳定而健壮。使用Spring Boot开发框架，不仅能提高开发速度，增强生产效率，从某种意义上，可以说是解放了程序员的劳动。而且一种新技术的使用，更能增强系统的稳定性和扩展系统的性能指标。本书就是本着提高开发效率，增强系统性能，促进新技术的普及使用这一目的而写的。
实战Nginx Nginx ( "enginex" )是俄罗斯人Igor Sysoev (伊戈尔●塞索耶夫)编写的一款高性能的HTTP和反向代理服务器。Nginx 能够选择高效的epoll (Linux 2.6内核)、kqueue (FreeBSD)、eventport (Solaris 10)作为网络I0模型，在高连接并发的情况下，Nginx 是Apache服务器不错的替代品，它能够支持高达50 000个并发连接数的响应，而内存、CPU等系统资源消耗却非常低，运行非常稳定。
Nginx已经在俄罗斯最大的门户网站一Rambler Media (www.rambler.ru) 上运行了3年时间，同时俄罗斯超过20%的虚拟主机平台采用Nginx作为反向代理服务器。
在国内，已经有新浪博客、新浪播客、网易新闻、六间房、56.com. Discuz!官方论坛、 水木社区、豆瓣、YUP0O相册、海内SNS、迅雷在线等多家网站使用Nginx 作为Web服务器或反向代理服务器。
电子版全章节：
Docker实战 作为目前热门]的容器技术类图书，本书适用于互联网，云计算，企业级软件开发、架构、测试，以及运维人员快速上手的Docker容器;同样适用于搭建以Docker为核心的基础设施，并在生产环境中快速部署应用以及管理容器集群。
MySQL实战 使用C和C++编写，并使用了多种编译器进行测试，保证源代码的可移植性支持AIX、FreeBSD、HP-UX、Linux、MacOS、Novell Netware、OpenBSD、OS/2 Wrap、Solaris、Windows等多种操作系统为多种编程语言提供了API。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等。支持多线程，充分利用CPU资源化的SQL查询算法，有效地提高查询速度既能够作为一个单独的应用程序应用在客户端服务器网络环境中，也能够作为一个库而嵌入到其他的软件中提供多语言支持，常见的编码如中文的GB 2312、BIG5，日文的Shift_JIS等都可以用作数据表名和数据列名提供TCP/IP、ODBC和JDBC等多种数据库连接途径提供用于管理、检查、优化数据库操作的管理工具可以处理拥有上千万条记录的大型数据库
由于文档内容过多，所以只截取了目录部分，每个知识点都有更细化的内容。
需要获取以上文档资料的朋友：一键三连（点赞+收藏+关注） 后，添加微信：mxm9843 即可免费获取到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7964f90d70a459a08e1e2a34b596c049/" rel="bookmark">
			leetcode_525_连续数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		连续数组 描述 中等
给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。
示例 1:
输入: nums = [0,1] 输出: 2 说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。 示例 2:
输入: nums = [0,1,0] 输出: 2 说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。 提示：
1 &lt;= nums.length &lt;= 105nums[i] 不是 0 就是 1 解题 遍历数组时，有一个计数器，碰到1则加1，碰到0则减1
当计数器的数据为0时，说明该计数器所经过的0和1的数量是相等的如果某一位置的计数器计数为x，之后又有一位置的计数器计数为x，那么这两个位置之间的0和1的数量时相等的 因此，使用哈希map记录下计数器的计数和当前的位置
并且需要找最长的序列，希望左边的位置尽可能的靠左，所以不需要更新map中已有的数据
# python class Solution: def findMaxLength(self, nums: List[int]) -&gt; int: # 记录初始计数器计数和位置 dic = {0: -1} counter = res = 0 for i, n in enumerate(nums): if n == 1: counter += 1 else: counter -= 1 # 如果当前计数器数据已经出现在字典中，说明又一位置上的计数器为x # 这两个位置之间的0和1的数量是相等的 if counter in dic: # 更新最长的子序列 res = max(res, i - dic[counter]) else: dic[counter] = i return res // java class Solution { public int findMaxLength(int[] nums) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7964f90d70a459a08e1e2a34b596c049/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0557fae442a0bfc0e82a9e3e1cd68b6a/" rel="bookmark">
			在Arm服务器上使用jaybedeapi操作oracle数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在基于arm架构的服务器上，无法使用cx_Oracle，目前使用jaybedeapi成功。
1. 在arm环境的机器上安装jaybedeapi和jpype1，将如下包复制到生产环境下的site-packages下面：
2. 从oracle官网下载ojdbc7.jar并复制到程序所在目录。
3. python程序如下：
host = "" port = "1521" service_name = "" url = f'jdbc:oracle:thin:@//{host}:1521/{service_name}' user = '' password = '' dirver = 'oracle.jdbc.driver.OracleDriver' jarFile = 'ojdbc7.jar' def run_sql(commandText): connection = jaydebeapi.connect(dirver, url, [user, password], jarFile) cursor = connection.cursor() cursor.execute(commandText) cursor.close() connection.close() return 4. 批量插入
基于jaydebeapi的数据库批量插入方法与基于cx_Oracle的方式不同，尤其是如果oracle数据库中的字段为date格式，处理方式也是不同的。基于cx_Oracle的方式在之前的文章里已经总结过：
https://mp-new.csdn.net/mp_blog/creation/editor/113185783
而基于jaydepeapi的处理代码如下：
def data_output(data, int_cols, dataTable): ''' @Args: data: dataframe to be inserted. int_cols: 整数类型的变量名称 dataTable: 表名称 ''' connection = jaydebeapi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0557fae442a0bfc0e82a9e3e1cd68b6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f92f65cddea957cbe7a18ab0a70b8d80/" rel="bookmark">
			【Java实习生】每日面试题打卡——操作系统篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		临近秋招，备战暑期实习，祝大家每天进步亿点点！Day15本篇总结的是 操作系统 相关的面试题，后续会每日更新~ 1、请分别简单说一说进程和线程以及它们的区别? 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。包含关系：一个进程最少由一条线程组成。所处环境区别：在操作系统中能同时运行多个进程（程序）；而在同一个进程中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。内存分配：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。 2、进程间的通信方式有哪些？ 管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。命名管道FIFO：未命名的管道只能在两个相关的进程之间通信，通过命名管道FIFO，不相关的进程也能交换数据。消息队列： 消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。消息队列允许一个或多个进程向它写入与读取消息。管道和命名管道的通信数据都是先进先出原则，消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取，比FIFO更有优势。 共享内存：共享内存是允许一个或多个进程共享的一块内存区域。信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。 3、线程同步的方式有哪些？ 互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 4、进程的状态及其转换 进程的状态有：就绪状态、运行状态、阻塞状态。
进程状态间的转换关系为：
5、Java线程的状态 Java 线程有以下几个状态：
新建状态（New）就绪状态（Runnable）运行状态（Running）阻塞状态（Blocked）： 等待阻塞同步阻塞其他阻塞 死亡状态（Dead） 6、进程的调度算法有哪些？ 先来先服务算法短作业优先算法优先权调度算法时间片轮转调度算法 参考文章：几个常用的操作系统进程调度算法
7、死锁产生的原因，死锁产生的必要条件是什么，如何预防死锁，如何避免死锁？ **死锁产生的原因：**资源竞争、进程推进顺序不当。
死锁产生的四个必要条件：
互斥：某个资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问了，直到该进程访问结束。不可剥夺：进程所获得的资源在未使用完毕之前，不能被其他进程强行剥夺，只能由获得该资源使用权的进程释放资源。占有且等待：一个进程请求某个资源并将其占有，即使该进程被阻塞了，也不会释放占有的资源。循环等待：若干进程之间形成一种头尾相接的环形循环等待链。 **预防死锁：**破坏产生死锁的四个必要条件之一即可。
死锁的解除：
强制性地从系统中撤销一个或多个死锁的进程以断开循环等待链。强制性抢占死锁进程正在争取的资源以解除死锁。 8、进程、线程的上下文切换 进程上下文切换：
一个进程切换到另一个进程运行，称为进程的上下文切换。进程是由内核管理和调度的，所以进程的切换只能发生在内核态。
线程上下文切换：
多线程编程中一般线程的个数都大于CPU核心的个数。
但一个线程时间片用完后，会重新处于就绪状态并让给其他线程使用，这个过程属于一次上下文切换。
概括：当前任务在执行完CPU时间片切换到另一个任务前会保存自己的状态，以便下一次再切换回这个任务时，可以再加载这个任务的状态。
9、操作系统的内存管理机制了解吗？内存管理有哪⼏种⽅式? 块式管理：远古时代的计算机操系统的内存管理⽅式。将内存分为⼏个固定⼤⼩的块，每 个块中只包含⼀个进程。如果程序运⾏需要内存的话，操作系统就分配给它⼀块，如果程序 运⾏只需要很⼩的空间的话，分配的这块内存很⼤⼀部分⼏乎被浪费了。这些在每个块中未 被利⽤的空间，我们称之为碎⽚。⻚式管理：把主存分为⼤⼩相等且固定的⼀⻚⼀⻚的形式，⻚᫾⼩，相对相⽐于块式管理的 划分⼒度更⼤，提⾼了内存利⽤率，减少了碎⽚。⻚式管理通过⻚表对应逻辑地址和物理地址。段式管理：⻚式管理虽然提⾼了内存利⽤率，但是⻚式管理其中的⻚实际并⽆任何实际意 义。 段式管理把主存分为⼀段段的，每⼀段的空间⼜要⽐⼀⻚的空间⼩很多 。但是，最重 要的是段是有实际意义的，每个段定义了⼀组逻辑信息，例如,有主程序段 MAIN、⼦程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。 10、 CPU 寻址了解吗?为什么需要虚拟地址空间? 处理器使⽤的是⼀种称为虚拟寻址的寻址⽅式。使⽤虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有⼀个被称为内存管理单元 的硬件。
11、什么是用户态和核心态？ 在计算机系统中，分两种程序：系统程序和应用程序，为了保证系统程序不被应用程序有意或无意地破坏，为计算机设置了两种状态——用户态、核心态。
用户态：只能受限的访问内存，运行所有的应用程序。核心态：运行操作系统程序，CPU 可以访问内存的所有数据，包括外围设备。 12、操作系统内存管理方式，分页分段以及段页式的优缺点？ 内存管理方式：块式管理、页式管理、段式管理、段页式管理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f92f65cddea957cbe7a18ab0a70b8d80/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/308/">«</a>
	<span class="pagination__item pagination__item--current">309/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/310/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>