<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52fca426ec0ab0e898b6c626518fc44b/" rel="bookmark">
			数组方法相关案例及三种排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组去重 var arr=[1,3,3,6,8,2,3,5,6,3,7,9,8,3,6,7,3,8,9]; var arr1=[]; for(var i=0;i&lt;arr.length;i++){ var bool=false; for(var j=0;j&lt;arr1.length;j++){ if(arr[i]===arr1[j]){ bool=true; break; } } if(!bool) arr1.push(arr[i]); } arr.length=0; for(var k=0;k&lt;arr1.length;k++){ arr[k]=arr1[k]; } arr1.length=0; arr1=null; console.log(arr); 冒泡排序 function sort(arr){ var len=arr.length-1; while(len&gt;0){ for(var i=0;i&lt;arr.length-1;i++){ if(arr[i]&gt;arr[i+1]){ var temp=arr[i]; arr[i]=arr[i+1]; arr[i+1]=temp; } } len--; } } 选择排序 function selectionSort(arr) { var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) { //表示比较次数，不需要与自身比较所以减了1 minIndex = i; for (var j = i + 1; j &lt; len; j++) { //表示遍历数组 if (arr[j] &lt; arr[minIndex]) { minIndex = j; //将最小数的索引保存 } } temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } return arr; } 快速排序 function quickSort(arr) { if (arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52fca426ec0ab0e898b6c626518fc44b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4920fe5b90df7b346dc6aeab4cf96fa3/" rel="bookmark">
			面试屡屡碰壁，痛定思痛闭关修炼！半年后4面阿里成功拿offer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每个程序员都有一个大厂的梦，而互联网大厂首当其冲自然是阿里巴巴最吃香。“不想进大厂的程序员不是好程序员”
为此也在几个月前就开始筹备了，在一位大佬的内推下加上自己对知识点的复习和努力也如愿以偿的成功拿到阿里的offer！
下面先分享下面经：
一面 1.自我介绍，包括做过项目。
2.有看过哪些JDK源码，了解哪些常用库。
3.集合框架HashMap的扩容机制，ConcurrnetHashMap的原理
4.jvm内存模型与gc内存回收机制
5.classloader结构，是否可以自己定义一个java.lang.String类，为什么？ 双亲代理机制。
6.了解哪些设计模式，6个设计原则分别是什么？每种设计原则体现的设计模式是哪个？
7.关于设计模式看了哪些书？书名是什么？
8.uml模型图画过哪些？ 类图中类之间的关系有哪些，区别分别是什么？
9.画uml中类图时候用过一种虚线么？做什么用的？
10.做过应用相关性能测试的，举个例子，实际项目中怎么使用的。
11.用过并发框架相关的哪些内容
11.了解哪些osgi的框架？
12有没有做过jvm内存调优，如何做的，举例子，用过哪些工具？
二面 1.自我介绍
2.看过哪些源码
3.java的io库的类结构图所用到的设计模式如何体现
4.画出自己设计过的设计模式如何体现，画出结构图，并进行讲解。
5.画出自己做的架构的项目架构图 如何扩展等
6.数据库设计中主键id设计的原则
7.jvm内存调优用过哪些工具，jstate做什么用的？如何dump出当前线程状态？
8.并发框架是否有了解
9.classloader的双亲代理机制
10.应用服务器的jvm调优实际经验，如何做的，在哪里用到的
11.在哪里获取最新资讯，逛什么论坛。最新的Swift语言有什么看法
12.设计原则与设计模式对应
13.servlet/filter作用原理配置
14.ibatis in操作 以及一个属性的作用
15.spring aop 用了什么设计原则，自动注入配置是做什么用的
16.jboss的类加载器
17.session共享机制
18.做过最成功的一件事情是什么？
19.最大的争执是什么？
20.为什么想要离职去阿里
三面 1.现在公司负责什么？
2.项目主要目的是做什么的？
3.公司管理方式、项目问题反馈机制是什么？
4.Java 的序列化做什么用的 序列化id会出现哪些问题？
5.OSGi用过哪些？类加载器结构如何，如何在一个bundle中加载另外一个bundle中的一个类？
6.nio是否了解 阻塞之后通知机制是怎样的？
7.uml设计类图如何画，类之间关系以及区别
8.spring如何不许要配置文件加载bean定义，可能是问自动注解或者是properties文件定义bean
9.ibatis等框架是不是都是实际在使用的,技术细节
10.为什么想离职？
四面 1.自我介绍
2.公司做什么，业务， 负责内容，汇报机制
3.企业级应用安全相关
4.http协议，返回码，301与302区别
5.多线程并发用过哪些
6.应用服务器相关，谈最熟悉的
7.为什么离职
最后，分享学习秘籍 这段时间我不断找资料学习，也通过很多渠道和朋友要到一份美团架构师写的Java面试宝典，我把这份Java面试宝典啃完了，从而还找了Java后端以及一些大厂的面试场景和面试题不断刷题提高自己的眼界
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4920fe5b90df7b346dc6aeab4cf96fa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e43010091e0b22fc9f040ab7ce57d41f/" rel="bookmark">
			如何制作营养膳食计算器_如何创建随机膳食生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何制作营养膳食计算器
Last week I decided to take on a new challenge. I called it: The #100Days100Projects Challenge.
上周，我决定接受一个新的挑战。 我称之为： ＃100Days100Projects挑战。 The purpose of the challenge is to create one project every single day. Think of it as a next step for the #100DaysOfCode challenge.
挑战的目的是每天创建一个项目。 将其视为＃100DaysOfCode挑战的下一步。 A project can be either:
一个项目可以是： an app
一个应用 a component
一个组件 a website
一个网站 a game
一个游戏 a library
图书馆 and so on.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e43010091e0b22fc9f040ab7ce57d41f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d3f1d5782748ac42553f217775a96c/" rel="bookmark">
			前端页面input 只能输入15个汉字，30个英文这样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下面展示一些 内联代码片。
搬自https://blog.csdn.net/seven_north/article/details/87073473博客 原理就是把一个汉字替换为英文字符aa，长度为2个字符，我这边就判断长度大约30就提示长度超出限制 var jmz = {}; jmz.GetLength = function(str) { return str.replace(/[\u0391-\uFFE5]/g,"aa").length; //先把中文替换成两个字节的英文，在计算长度 }; alert(jmz.GetLength('测试测试ceshiceshi')); if(item.prodName.replace(/[\u0391-\uFFE5]/g,"aa").length&gt;30){ ErrorPordNameLength = true } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d7660206eaae4ca9f7e32cf52980831/" rel="bookmark">
			对于Tomcat线程池的一些理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于Tomcat线程池的一些理解 单台tomcat的最大连接数和最大线程数是有限的。当前端发送来一个请求，后端接口没有使用异步线程，那个这个请求应该为同步请求，此时Tomcat从自己的线程池里取出一个线程，用以从Tomcat到Spring的Controller，Service，Dao。
为了更加直观的理解这句话，我们开始一个test。
我们先做一个开始测试之前准备工作。首先我们把Springboot内置的Tomcat的最大线程数设置为3，然后我们写一个测试接口,用以查看当前是哪条线程在工作。
import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class TestController { @GetMapping("hello") public String hello() throws InterruptedException { System.out.println("主线程开始----------&gt;"+Thread.currentThread().getName()); Thread.sleep(30000); System.out.println("主线程结束----------&gt;"+Thread.currentThread().getName()); return "hello work"; } } 完成以后我们正式开始测试，因为我们设置了Tomcat最大线程数为3，现在我们连续对这个接口发起四个请求，来看一下线程调用的情况。
我们可以看到，前三个请求把Tomcat线程池中的三个线程占用后，第四个请求会进入等待状态，在第一个请求完成后，空出来的线程才会被第四个请求调用。
可想而知，如果在某个时刻外部对接口同时进行大量的请求，线程池里的线程全被调用，大量请求进入等待队列，当超过最大等待队列数的时候，这个Tomcat就崩溃了。
那我们除了集群以外还有其他巧妙的方法提升最大请求量吗？是可以的，我们在接口中使用异步线程，
@GetMapping("helloTest") public String helloTest() { System.out.println("主线程开始----------&gt;"+Thread.currentThread().getName()); new Thread(()-&gt;{ try { Thread.sleep(30000); }catch (InterruptedException e){ e.printStackTrace(); } }).start(); System.out.println("主线程结束----------&gt;"+Thread.currentThread().getName()); return "hello work"; } 我们来看下相同情况下的运行结果
可以明显的看出Tomcat的线程在调用接口后立刻返回了，内部的逻辑处理由Spring内部的线程进行处理，这样明显让调用请求量提升了。
那么有些人要问了如果我需要获取异步线程进行的逻辑处理结果怎么办呢，那我们用Callable尝试一下，代码如下：
@GetMapping("helloTest1") public Callable&lt;String&gt; helloTest1() { System.out.println("主线程开始----------&gt;"+Thread.currentThread().getName()); Callable&lt;String&gt; callable=()-&gt;{ System.out.println("异步线程开始----------&gt;"+Thread.currentThread().getName()); Thread.sleep(30000); System.out.println("异步线程结束----------&gt;"+Thread.currentThread().getName()); return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d7660206eaae4ca9f7e32cf52980831/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33ae06a56f15a3952acb6728fd6eec61/" rel="bookmark">
			Revit 二次开发 Curve线的CreateOffset方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后面解释，先上代码：
double lineOffset=10; Curve copyCurve = curve.CreateOffset(lineOffset, getNormal(curve)); /// &lt;summary&gt; /// 传入一根线，根据右手定则，返回可以得到负z轴偏移方向的向量。！！注意，我的线是在xy平面， /// 想把线往负z轴偏移，所以这样做。根据需求自己改方法体 /// &lt;/summary&gt; /// &lt;param name="geometryCurve"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private XYZ getNormal(Curve curve) { XYZ sPoint = curve.GetEndPoint(0); XYZ ePoint = curve.GetEndPoint(1); double res = 1;//这个是下面外扩的长度，随便取正数即可 //往curve第一个端点外扩展2个点，简单的几何比例 XYZ p0 = new XYZ(sPoint.X - (ePoint.Y - sPoint.Y) * (res / curve.ApproximateLength), sPoint.Y + (ePoint.X - sPoint.X) * (res / curve.ApproximateLength), sPoint.Z); XYZ p1 = new XYZ(sPoint.X + (ePoint.Y - sPoint.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33ae06a56f15a3952acb6728fd6eec61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36a684be17db66757204a57aca9cca17/" rel="bookmark">
			聚类分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、监督学习和无监督学习二、聚类分析2.1 K-Means2.2 DBSCAN2.3 超大数据量时应该放弃K均值算法2.4 高维数据上无法应用聚类吗？2.5 如何选择聚类分析算法？ 三、K-Means算法3.1 什么是K-Means算法？3.2 什么是簇内误差平方和？3.3 sklearn中的KMeans3.4 代码实现3.5 聚类算法的模型评估指标1. 为什么不用簇内距离平方和2. 轮廓系数 一、监督学习和无监督学习 监督学习是指从标注数据(训练集)中学习预测模型的机器学习问题。标注数据表示输入输出的对应关系，预测模型对给定的输入产生相应的输出。监督学习的本质是学习输入到输出的映射的统计规律。
无监督学习是指从无标注数据中学习预测模型的机器学习问题。无标注数据是自然得到的数据，预测模型表示数据的类别、转换或者概率。无监督学习的本质是学习数据中的统计哦规律或潜在结构。
二、聚类分析 聚类是数据挖掘和计算的基本任务，是将大量数据集中具有"相似"特征的数据点或样本划分为一个类别。聚类分析的基本思想是"物以类聚，人以群分"，因此大量的数据集中必然存在相似的数据样本，基于这个假设就可以将数据区分出来，并发现不同类的特征。
聚类常用于数据探索或挖掘前期，在没有做先验经验的背景下做的探索性分析，也适用于样本量较大情况下的数据预处理工作。例如，针对企业整体的用户特征，在未得到相关知识或经验之前，先根据数据本身特点进行用户分群，然后针对不同群体作进一步分析；对连续数据离散化，便于后续做分类分析应用。
常用的聚类算法分为基于划分、层次、密度、网格、统计学、模型等类型的算法，典型算法包括K均值，DBSCAN、两步聚类、BIRCH、谱聚类等。
聚类分析能解决的问题包括：数据集可以分为几类、每个类别有多少样本量、不同类别中各个变量的强弱关系如何、不同类别的典型特征如何。除了划分类别等，聚类还能用于基于划分的其他应用，例如图片压缩等。
2.1 K-Means k均值是聚类中最常用的方法之一，它基于点与点距离的相似度来计算最佳类别归属。但K均值在应用之前一定要注意两种数据异常：
数据的异常值。数据中的异常值能明显改变不同点之间的距离相似度，并且这种影响是非常显著的。因此基于距离相似度的判别模式下，异常值的处理必不可少。数据的异常量纲。不同的维度和变量之间，如果存在数值规模或量纲的差异，那么在做距离之前需要先将变量归一化或标准化。例如，跳出率的数值分布区间是[0,1]，订单金额可能是[0,1000000]，而订单数量则是[0,1000]。如果没有归一化或标准化操作，那么相似度将主要受到订单金额的影响。 2.2 DBSCAN 当然，K均值并不是唯一的聚类方法，如果上述两种条件受某些因素的限制无法实现，那么可以选择其他聚类方法。例如DBSCAN，其中文含义是"基于密度的带有噪声的空间聚类"。DBSCAN是一个比较有代表性的基于密度的聚类算法，与基于划分和层次的聚类方法不同，他将簇定义为密度相连的点的最大集合，能够把具有足够高密度的区域划分为簇，并可在噪声的空间数据集中发现任意形状的聚类。
DBSCAN算法的出发点是基于密度寻找被低密度区域分离的高密度空间，以此来实现不用数据样本的聚类。跟K均值相比，它具有以下优点：
原始数据集的分布规律没有明显要求，能适应任意数据集分布形状的空间聚类，因此数据集实用性更广，尤其是对非凸装、圆环形等异性簇分布的识别较好无须指定聚类数量，对结果的先验要求不高由于DBSCAN可区分核心对象、边界点和噪音点，因此对噪声的过滤效果好，能有效应对数据噪点。 但是，由于他直接对整个数据集进行操作，且聚类时使用了一个全局性的表征密度的参数，因此也存在几个明显的弱点：
对于高维问题，基于Eps(半径)和MinPts(密度)的定义是个很大问题当簇的密度变化太大时，聚类效果较差当结果量增大时，要求较大的内存支持，I/O消耗也很好。 2.3 超大数据量时应该放弃K均值算法 K均值在算法稳定性、效率和准确率上表现非常好，并且在应对大量数据时依然如此。他的算法时间复杂度上界为O(n* k * t)，其中n是样本量、k是划分的聚类数，t是迭代次数。当聚类数和迭代次数不变时，K均值的算法消耗时间只跟样本量有关，因此会呈线性增长趋势。
当真正面对海量数据时，使用K均值算法将面临严重的结果延迟，尤其是当K均值被用作实时性或准实时性的数据预处理、分析和建模时，这种瓶颈效应尤为明显。针对K均值的这一问题，很多延伸算法出现了，MiniBatchKMeans就是其中一个典型代表。MiniBatch的好处是计算过程中不必使用所有的数据样本。由于计算样本量少，所以会相应减少运行时间；但另一方面，由于是抽样方法，抽样样本很难完全代表整体样本的全部特征，因此会带来准确度的下降。
2.4 高维数据上无法应用聚类吗？ 在大数据背景上，数据获取难度和成本非常低，很多高维数据场景例如电子商务交易数据、Web文本数据日益丰富。在做高维数据聚类时，传统的在低维空间通用的聚类方法运用到高维空间时，通常不能取得令人满意的聚类结果，主要表现在聚类计算耗时太长、聚类结果相对于真是标签分类的准确性和稳定性都大为降低
应对高维数据的聚类主要有2种方法：降维、子空间聚类
降维是应对高维数据的有效方法，通过特征选择法或维度转换法将高维空间降低或映射到低维空间，直接解决了高维问题
子空间聚类算法是在高维数据空间中对传统聚类算法的一种扩展，其思想是选取与给定簇密切相关的维，然后在对应的子空间进行聚类。比如，谱聚类就是一种子空间聚类方法。
2.5 如何选择聚类分析算法？ 聚类算法有几十种之多，聚类算法的选择主要参考以下因素：
如果数据集是高维的，那么选择谱聚类，他是子空间划分的一种如果数据量为中小规模，例如在100万条以内，那么K均值将是比较好的选择；如果数据量超过100万条，那么可以考虑使用MiniBatchKMeans如果数据集中有噪点，那么使用基于密度的DBSCAN可以有效应对这个问题。 三、K-Means算法 3.1 什么是K-Means算法？ 作为聚类算法的典型代表，Kmeans可以说是最简单的聚类算法没有之一，那么他是怎么完成聚类的呢？
KMeans算法将一组N个样本的特征矩阵X划分为K个无交集的簇，直观上来看是簇是一组一组聚集在一起的数据，在一个簇中的数据就认为是同一类。簇就是聚类的结果表现。
簇中所有数据的均值 通常被称为这个簇的“质心”（centroids）。在一个二维平面中，一簇数据点的质心的横坐标就是这一簇数据点的横坐标的均值，质心的纵坐标就是这一簇数据点的纵坐标的均值。同理可推广至高维空间。
在KMeans算法中，簇的个数K是一个超参数，需要我们人为输入来确定。KMeans的核心任务就是根据我们设定好的K，找出K个最优的质心，并将离这些质心最近的数据分别分配到这些质心代表的簇中去。
1. 随机抽取K个样本作为最初的质心 2. 开始循环 3. 将每个样本分配到离他们最近的质心，生成K个簇 4. 对于每个簇，计算所有被分到该簇的样本点的平均值作为新的质心 5. 当质心的位置不再发生变化，迭代停止，聚类完成 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36a684be17db66757204a57aca9cca17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f5f86927ed6aa6edd8b7e711a27c69/" rel="bookmark">
			老卫带你学---python反爬虫与反反爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		老卫带你学—python反爬虫与反反爬虫 在抓取对方网站、APP 应用的相关数据时，经常会遇到一系列的方法阻止爬虫。一方面是为了保证服务的质量，另一方面是保护数据不被获取。常见的一些反爬虫 和反反爬虫的手段如下。
（1）IP 限制 IP 限制是很常见的一种反爬虫的方式。服务端在一定时间内统计 IP 地址的访问 次数，当次数、频率达到一定阈值时返回错误码或者拒绝服务。这种方式比较直接 简单，但在 IPv4 资源越来越不足的情况下，很多用户共享一个 IP 出口，典型的如“长 城宽带”等共享型的 ISP。另外手机网络中的 IP 地址也是会经常变化的，如果对这 些 IP 地址进行阻断，则会将大量的正常用户阻止在外。
对于大多数不需要登录就可以进行访问的网站，通常也只能使用 IP 地址进行限 制。比如“Freelancer 网站”，大量的公开数据可以被访问，但同一个 IP 地址的访问 是有一定的限制的。针对 IP 地址限制非常有效的方式是，使用大量的“高匿名”代 理资源。这些代理资源可以对源 IP 地址进行隐藏，从而让对方服务器看起来是多个 IP 地址进行访问。另一种限制方式是，根据业务需要，对国内、国外的 IP 地址进行 单独处理，进而对国外的高匿名代理进行阻断，例如使用海外的 IP 地址访问“天眼 查网站”则无法访问。
（2）验证码 验证码是一种非常常见的反爬虫方式。服务提供方在 IP 地址访问次数达到一定 数量后，可以返回验证码让用户进行验证。这种限制在不需要登录的网页界面比较 常见，它需要结合用户的 cookie 或者生成一个特殊标识对用户进行唯一性判断，以 防止同一个 IP 地址访问频率过高。验证码的存在形式非常多，有简单的数字验证码、 字母数字验证码、字符图形验证码，网站也可以用极验验证码等基于用户行为的验 证码。针对简单验证码，可以使用打码平台进行破解。这种平台通过脚本上传验证 的图片，由打码公司雇用的人工进行识别。针对极验验证等更复杂的验证码，可以尝试模拟用户的行为绕过去，但通常比较烦琐，难度较大。谷歌所用的验证码更为 复杂，通常是用户端结合云端进行手工打码，但会带来整体成本较高的问题。要想绕过这些验证码的限制，一种思路是在出现验证码之前放弃访问，更换 IP 地址。ADSL 拨号代理提供了这种可能性。ADSL 通过拨号的方式上网，需要输入 ADSL 账号和密码，每次拨号就更换一个 IP 地址。不同地域的 IP 地址分布在多个地 址段，如果 IP 地址都能使用，则意味着 IP 地址量级可达千万。如果我们将 ADSL 主机作为代理，每隔一段时间主机拨号一次（换一个 IP），这样可以有效防止 IP 地 址被封禁。这种情况下，IP 地址的有效时限通常很短，通常在 1 分钟以下。结合大 量的 ADSL 拨号代理可以达到并行获取大量数据的可能。如果网站使用了一些特殊 的唯一性的标识，则很容易被对方网站识别到，从而改进反爬虫策略，面对这种情 况，单独切换 IP 地址也会无效。遇到这种情况，必须要搞清楚标识的生成方式，进 而模拟真实用户的访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2f5f86927ed6aa6edd8b7e711a27c69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2afe31152d4b7523c63aeadd2e14772/" rel="bookmark">
			idea创建项目 详细步骤教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea项目创建教程 1. idea的项目结构2 创建idea项目2.1 Project2.2 Module2.3 Package2.4 创建Java Class文件 1. idea的项目结构 2 创建idea项目 2.1 Project 步骤1：
步骤2：
2.2 Module 步骤3：
步骤4：
步骤5：
步骤6：
项目信息：
2.3 Package 步骤7:
步骤8：
2.4 创建Java Class文件 步骤9：
步骤10：
步骤11：
输出结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb4e363ac247392b60bc76e1fb7e32d6/" rel="bookmark">
			matlab——级数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 级数 级数求和泰勒级数 级数求和 1. 级数求和 求无穷级数的和需要符号表达式求和函数symsum()，其调 用格式为： symsum(s,v,n,m) 其中，s表示一个级数的通项，是一个符号表达式。v是求 和变量，v省略时使用系统的默认变量。n和m是求和变量v 的初值和末值。 &gt;&gt; syms n; &gt;&gt; s1=symsum(n^2,1,100) s1 = 338350 &gt;&gt; s2=symsum((-1)^(n-1)/n,1,inf) s2= log(2) &gt;&gt; s3=symsum((-1)^(n-1)/(2*n-1),n,1,inf) s3 = hypergeom([-1/2, 1], 1/2, -1)–1 &gt;&gt; hypergeom([-1/2, 1], 1/2, -1) %超几何函数 ans = 1.7854 &gt;&gt; eval(s3)*4 ans= 3.141592653589792 泰勒级数 MATLAB提供了taylor()函数将函数展开为幂级数，其调用 格式为： taylor(f,v,a,Name,Value) 该函数将函数f按变量v在a点展开为泰勒级数，v的默认值 与diff函数相同，a的默认值是0。 Name和Value为选项设 置，经常成对使用，前者为选项名，后者为该选项的值。 Name有3个可取字符串： ① 'ExpansionPoint'：指定展开点，对应值可以是标量或向量。 未设置时，展开点为0。 ② 'Order'：指定截断参数，对应值为一个正整数。未设置时， 截断参数为6，即展开式的最高阶为5。 ③ 'OrderMode'：指定展开式采用绝对阶或相对阶，对应值为 'Absolute' 或'Relative'。 未设置时取'Absolute'。 &gt;&gt; syms x; &gt;&gt; f=(1+x+x^2)/(1-x+x^2); &gt;&gt; taylor(f,x,1,'Order',6)%函数f在x=1处的5阶泰勒级数展开式。 ans = 2*(x - 1)^3 - 2*(x - 1)^2 - 2*(x - 1)^5 + 3 &gt;&gt;expand(ans) ans = - 2*x^5 + 10*x^4 - 18*x^3 + 12*x^2 + 1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b4ea12476e66407670f82fb432c7bc/" rel="bookmark">
			VOSviewer 操作指南 简明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VOSviewer 操作指南 Vosviewer 软件是一种知识图谱可视化软件，并且可以使用基本的分类聚类方法，帮助我们得到进一步的信息。
下载地址：
https://www.vosviewer.com/download
解压完成后，你得到因该是一个类似这样的目录：
双击快捷方式，即可运行软件，其中有一个PDF文件为使用手册，本文后边会做简单的介绍。
这个软件支持多种文献导入方式，我们这里以从web of science 到处的参考文献为例。
1.快速上手 1.1 导出需要的参考文献 我们选择从web of science 数据库导出部分我们需要的文献信息，这个数据库可能需要校园网络才能使用。
例如，我想分析关于区块链的论文，那么直接再搜索栏中输入主题，然后检索，如下：
再这个数据库上，我们一共检索到blockchain 相关的论文4913篇，时间跨度为1950-2020年，现在我们导出这些文献。
注意这些导出选项，导出的文件格式, 如上述的选择条目。
1.2 创建映射图谱 选第三个选项，基于文本构建图谱，因为我们刚才从数据库导出的文件是文本文件。
选第二个选项，基于数据库文件构建图谱，显示支持web of science 数据库。
选择我们的文件，得到结果，如下所示：
从图中我们就可以看到，关于blockchain主题的500篇论文，主要研究的热点词组。
2. 使用详解 2.1 面板分块解释 第一部分：
当前的可视化面板，可以放大缩小整个知识图谱。
第二部分：
选项面板，可以再这个面板中调整可视化面板中的信息。
第三部分：
信息面板，显示整个信息。
第四部分：
概述信息，一个宏观的缩略图。
第五部分：
操作面板，可以增删改查新的图，截取图谱，或者更新图。
2.2 各面板内容解释 2.2.1 第一部分显示面板
显示面板分为三个部分：网络视图，覆盖视图，密度视图。
网络视图：每一个圆圈的大小代表这个关键字的权重，两个圆圈之间的距离表示了两个圆圈之间的亲缘性，如果亲缘性越强则距离越短，亲缘性越弱则距离越远。圆圈的颜色代表了各自的簇类。
覆盖视图：覆盖视图与网络视图的图的结构是一样的，颜色有区别，所有关键字按照权重着色，并且给与参与者自己着色的方法。只有当设定了条目的属性和关键字相关时，覆盖视图才有用。
密度视图：显示的是项目密度，关键字周围的关键字数越大，则颜色越亮。
2.2.1 第二部分选项面板
Scale：各个项目之间链接的粗细。
Weight: 当项目有多个权重时，可以选择这个下拉框，选择相关的权重展示。
Scores: 只有在覆盖视图中，会根据实际的条目占比，对各项的颜色表示进行调整。
Size variation: 项目的表示大小与权重相关，越大表示权重越大。
max length： 项目的标签显示长度。
Font：下拉框可以显示的文字格式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6b4ea12476e66407670f82fb432c7bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a1b8fc4d22831b3d3468da4c154b227/" rel="bookmark">
			单片机  DAC0832数模转换实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电路图如下：
1、描述DA0832实现DA转换的基本原理
1、
DAC0832是一个八位D/A转换器，D/A转换电路是一个R-2RT型电阻网络，可实现8位数据的转换。
2、
数据总线——DI7~DI0：转换数据输入
控制总线（控制输入寄存器的打开）——ILE（数据锁存允许信号，高电平有效），CS（片选信号，低电平有效），WR1（写信号，低电平有效）
控制DAC寄存器的写入——WR2（写信号，低电平有效），XFER（数据传输控制信号，低电平有效）
3、
通过对两个输入寄存器进行控制，可以采用双缓冲、单缓冲、直通的输入方式。
4、
输入信号通过一个8位D/A转换器输出Iout1和Iout2，然后两路输出电流外接一个运算放大器（单极性输出或者双极性输出），最后输出一个模拟电压。单极性输出电压：Vout=-Vref*D/256（D=0~255）
例如：双缓冲
（1）CPU执行输出指令，输出8位数据给DAC0832
（2）在CPU这行输出指令的同时，使ILE，CS，WR1三个控制信号都有效，8位数据锁存在8位输入寄存器中
（3）当WR2，XFER两个控制信号也都有效时，8位数据再次被锁存到DAC寄存器，这时8位D/A转化器开始工作，8位数据转换为相对应的模拟电流，从Iout1和Iout2输出。
2、要求DAC0832编写程序产生一个三角波。三角波的频率为0.5HZ，利用定时器定时，需要有理论计算过程，并有结果显示截图。
（1）给出定时器工作方式，计数初值，及其初值计算方法。
（2）代码如下：
/** 功能描述: **/ #include "reg52.h" #define uchar unsigned char #define uint unsigned int /***********端口定义********************************/ #define out P1 sbit dac_cs=P2^0; sbit dac_wr=P2^1; /***********函数申明***********************************/ void dac_change(uchar dac_data); /***********变量定义********************************/ bit flag=0;//状态量的思想 =0,上升;=1,下降 uchar counter=0;//软件计数 uchar i=200;//输入量D void main(void) { uchar timer0_peroid=200; TMOD=0x02;//in mode 2 TH0=0-timer0_peroid;//56 TL0=0-timer0_peroid;//56 TR0=1;//启动T0 PT0=1;//高级中断 ET0=1;//允许T0中断 EA=1;//打开中断总开关 while(1) { if(counter==25){ counter=0; if(flag==0){ dac_change(i);//波形上升 i--; if(i==0) flag=1; }else{ dac_change(i);//波形下降 i++; if(i==200) flag=0; } } } } //timer0中断函数 void timer_0 () interrupt 1{ counter++; } //DAC转换 void dac_change(uchar dac_data) { out=dac_data; dac_cs=0; dac_wr=0; dac_cs=1; dac_wr=1; } （3）示波器三角波示意图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/251129f293e6daadebceeed7355afecd/" rel="bookmark">
			RK1808固件升级说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		升级固件 前言 本文介绍了如何将主机上的固件文件，通过公对公USB线，烧录到开发板的闪存中。升级时，需要根据主机操作系统和固件类型来选择合适的升级方式。
准备工作 Core-1808-JD4 开发板
固件
主机
公对公USB线
固件文件一般有两种：
单个统一固件 update.img, 将启动加载器、参数和所有分区镜像都打包到一起，用于固件发布。
多个分区镜像,如 boot.img, rootfs.img, recovery.img 等，在开发阶段生成。
可以在这里找到已编译好的固件Core-1808-JD4固件下载页，选择你所需要的固件，下载后解压。也可以参考编译固件的说明自行编译。
主机操作系统支持：
Windows XP （32/64位）
Windows 7 (32/64位)
Windows 8 (32/64位)
Linux (32/64位)
主机连接开发板:
公对公USB线一头连接开发板的USB 3.0接口，另外一头连接主机，如图所示。
Windows 工具: Androidtool_xxx(版本号)
安装 RK USB 驱动 下载 DriverAssitant_v4.8.zip ，解压，然后运行里面的 DriverInstall.exe 。为了所有设备都使用更新的驱动，请先选择”驱动卸载”，然后再选择”驱动安装”。
连接设备 按照以下方式可以使设备进入升级模式
先断开电源适配器连接：
公对公USB线一端连接主机，一端连接开发板
按住设备上的 RECOVERY （恢复）键并保持。
接上电源
大约两秒钟后，松开 RECOVERY 键。
主机应该会提示发现新硬件并配置驱动。打开设备管理器，会见到新设备”Rockusb Device” 出现，如下图。如果没有，则需要返回上一步重新安装驱动。
烧写固件 下载 AndroidTool，解压，运行 AndroidTool_Release_xx 目录里面的 AndroidTool.exe（注意，如果是 Windows 7/8,需要按鼠标右键，选择以管理员身份运行），如下图：
烧写统一固件 update.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/251129f293e6daadebceeed7355afecd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b0cccaacaa878ceab968d3de706558a/" rel="bookmark">
			python操作Oracle数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 准备工作 ① 首先，你必须安装好Oracle数据库。Oracle数据库的安装并不是那么容易，大家可以去找一个安装教程，慢慢研究。
② 其次，你既然用Python操作Oracle，你必须要安装Python吧。Python的安装过程较为简单。但是有一点需要注意：一定要安装64位的Python，不要使用32位的。
③ 最后，也是最复杂的一步。我们需要进行instantclient的下载安装和环境配置，它是oracle数据库的客户端，这个最好也是下载64位的。
2. instantclient的安装与配置 1）instantclient的下载地址
在进行instantclient的安装与配置之前，我先提供给大家一个下载链接，供大家下载，我们直接下载像11或者12这样的高版本，即可。
instantclient的下载地址：http://suo.im/5Dlqrr
2）instantclient的安装
① 直接解压instantclient安装包；
② 解压后的文件位置，不要随意放置；
我们需要将instantclient安装包，解压后得到的文件夹，放置在Oracle安装目录下的product的直接字目录下。
3）instantclient的环境配置
① 按照图中操作，完成环境变量的配置；
② 将其解压目录下的oraociei11.dll、oraocci11.dll、oci.dll文件复制到python安装目录的Lib/site-packages文件夹下；
instantclient安装包解压后的文件夹：
python安装目录下的Lib/site-packages文件夹：
3. 其他需要特别注意的点
1）解决中文乱码问题
当使用Python读取到Oracle数据库中的某张表，如果该表中存在中文，会出现中文乱码的问题。因此需要设置NLS_LANG环境变量，来解决这个问题，下面提供了两种方式。
① 打开CMD黑窗口，输入以下命令；
C:\Users\AA&gt;set nls_lang=SIMPLIFIED CHINESE_CHINA.ZHS16GBK ② 直接在写代码的时候，输入以下命令；
import os os.environ['NLS_LANG'] = 'SIMPLIFIED CHINESE_CHINA.UTF8' 注意： 上述两种方式书写命令的位置不同，不要弄错了。其次，上述设置NLS_LANG环境变量的方式，仅对当前窗口有效。其实，我们也可以永久修改NLS_LANG环境变量，但是请不要这么做。
2）关于cx_Oracle驱动包的安装，需要注意的问题
cx_Oracle是Python操作Oracle数据库，需要使用的驱动包。类似于Python操作MySQL使用的pymysql驱动包。
对于我来说，我直接使用下面这个命令，就安装成功：
pip insatll cx_Oracle 如果你的系统环境，导致安装失败，我这里提供两个链接，供你下载和学习：
cx_Oracle驱动包的下载：http://suo.im/6fGFSR
cx_Oracle安装教程：http://suo.im/5DlvxT
4. Python与Oracle交互操作 其实Python操作Oracle数据库，和Python操作MySQL数据库，基本上都是一样的道理，一通百通。我之前已经写了一个Python操作MySQL数据库的详细教程，下面提供给大家这个链接。
Python操作MySQL数据库：http://suo.im/6fGJhl
1）Python链接Oracle服务器的3种方式
① 用户名、密码和监听写在一起
import cx_Oracle db = cx_Oracle.connect('scott/a123456@DESKTOP-V4LKB10:1521/orcl') ② 用户名、密码和监听分开写
import cx_Oracle db = cx_Oracle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b0cccaacaa878ceab968d3de706558a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e54cd2971c8ea5ed87ad47749529edf/" rel="bookmark">
			简单粗暴PyTorch之transforms详解(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		transforms详解 一、transforms 介绍二、 transforms 运行机制 一、transforms 介绍 transforms在计算机视觉工具包torchvision下：
torchvision.transforms : 常用的图像预处理方法
torchvision.datasets : 常用数据集的dataset实现，MNIST，CIFAR-10，ImageNet等
torchvision.model : 常用的模型预训练，AlexNet，VGG， ResNet，GoogLeNet等
torchvision.transforms : 常用的图像预处理方法，提高泛化能力
• 数据中心化
• 数据标准化
• 缩放
• 裁剪
• 旋转
• 翻转
• 填充
• 噪声添加
• 灰度变换
• 线性变换
• 仿射变换
• 亮度、饱和度及对比度变换
相当于真正高考前做的三年高考五年模拟，五年高考是原始数据，三年模拟是在原题基础上改的模拟题，真正高考碰见了分就高了
二、 transforms 运行机制 采用transforms.Compose()，将一系列的transforms有序组合，实现时按照这些方法依次对图像操作。
train_transform = transforms.Compose([ transforms.Resize((32, 32)), # 缩放 transforms.RandomCrop(32, padding=4), # 随机裁剪 transforms.ToTensor(), # 图片转张量，同时归一化0-255 ---》 0-1 transforms.Normalize(norm_mean, norm_std), # 标准化均值为0标准差为1 ]) 构建Dataset实例，DataLoder实例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e54cd2971c8ea5ed87ad47749529edf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcf37e6c3072ae7c96660eecd72f03a3/" rel="bookmark">
			C&#43;&#43;教程从入门到实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++基础教程 一、数据类型 1.1、第一个C++程序 1.2、数据类型 1.3、常量及符号 1、整型常量：整型常量可以分为有符号整型常量和无符号整型常量
八进制：以0开头，即以0作为八进制数的前缀，每位取值范围是0~7，八进制数通常是无符号数。
例如：016、0101、0128都是合法的八进制数 十六进制：以0x或者0X开头，其数码取值范围0 ~ 9，以及A ~ F或者a ~ f
例如：0X2A1、0XC5、0XFFFF都是合法的16进制数 2、实型常量
小数表示法：由整数部分和小数部分组成，整数部分和小数部分每位取值范围是0~9，例如：0.0、3.25、0.00596、2.0指数表示法：指数部分以符号"e"或者"E"开始，但必须是整数，并且符号"e"或"E"两边都必须有一个数，例如：1.2e20和-3.4e-2 3、字符常量：字符常量是单引号括起来的字符，例如：'a'和'?'都是合法字符常量。字符'a'的ASCII码值是97，字符'A'的ASCII码值是41，字符'?'的ASCII码值是63
转义字符是特殊的字符常量，使用时以字符串’'代表开始转义，和后面不同的字符表示转义的字符。转义字符表如下所示：
4、字符串常量：是由一对双引号括起来的零个或多个字符序列，例如：“welcome to our school”、“hello world”。""可以表示一个空字符串。
字符常量’A’和字符串常量"A"是不同的，字符串常量"A"是由'A'和'\0'两个字符组成的，字符串长度是2，字符串常量'A'只是一个字符，没有长度。 5、其他常量
布尔常量：布尔常量只有两个，一个是true，表示真；另一个是false，表示假。枚举常量：枚举型数据中定义的成员也是常量，这将在后文介绍。宏定义常量：通过#define宏定义的一些值也是常量。例如：define PI3.1415。其中PI就是常量。 1.4、变量 1、标识符：是用来对C++程序中的常量、变量、语句标号以及用户自定义函数的名称进行标识的符号。 标识符命名规则： 1.有字母、数字及下划线组成，且不能以数字开头。2.大写和小写字母代表不同意义。3.不能与关键字同名4.尽量“见名知义”，应该受一定规则的约束。 不合法的标识符：6A、ABC*、case（保留字） c++保留关键字，如表所示：
2、变量与变量说明：变量使用前一定要定义或说明，变量声明的一般形式如下：[修饰符] 类型 变量名标识符；
类型是变量类型的说明符，说明变量的数据类型。修改师傅是任选的，可以没有。
3、整型变量：整型变量可以分为短整型、整型和长整型，变量类型说明符分别是short、int、long。根据是否有符号还可分为以下6种。
整型 [signed] int无符号整型 unsigned [int]有符号短整型 [signed] short [int]无符号短整型 unsigned short [int]有符号长整型 [signed] long [int]无符号长整型 unsigned long [int]
4、实型变量：又称为浮点型变量，变量可分为单精度（float）、双精度（double）和长双精度（long double）三种。
5、变量赋值：变量值是动态改变的，每次改变都需要进行赋值运算。变量赋值的形式如下：变量名标识符 = 表达式，例如：
6、变量赋初值：可以在声明变量的时候就把数据赋给变量，这个过程叫变量赋初值，赋初值的情况有以下几种：
int x=5;：表示定义x为有符号的基本整型变量，赋初值为5int x，y，z=6;：表示定义x、y、z为有符号的基本整型变量，z赋初值为6int x=3，y=3，z=3;：表示定义x、y、z为有符号的基本整型变量，且赋予的初值均为3 7、字符变量：
1、一个字符类型，即可以字符形式输出，也可以整数类型输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcf37e6c3072ae7c96660eecd72f03a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22b455ec62b3d7cfe615bd5b19004c8c/" rel="bookmark">
			python为list实现find方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创：python为list实现find方法
string类型的话可用find方法去查找字符串位置：
1 a_list.find('a') 如果找到则返回第一个匹配的位置，如果没找到则返回-1，而如果通过index方法去查找的话，没找到的话会报错。
如果我们希望在list中也使用find呢？
方法1,独立函数法 1 2 3 4 5 6 7 def list_find(item_list, find_item): if find_item in item_list: return item_list.index(find_item) return -1 item_list=[1,2,3] print(list_find(item_list,1),list_find(item_list,4)) 缺点：代码太多，麻烦
方法2,if三元表达式(本质同上) 1 item_list.index(find_item) if find_item in item_list else -1 优点：简单，明了
缺点:item_list在上面出现两次，想想一下，如果item_list是一个比较长表达式的结果(或者函数结果)，则会导致代码过长，且会执行2次
方法3,next(利用迭代器遍历的第二个参数) 1 next((item for item in item_list if item==find_item ),-1) 缺点：如果对迭代器不熟悉，不大好理解
优点：扩展性好，if后面的条件可以不只是相等，可支持更为复杂的逻辑判断
方法4,list元素bool类型 1 ''.join(map(str, map(int, item_list))).find(str(int(True))) 简单容易理解
参考 python中list的五种查找方法：https://blog.csdn.net/qq_31747765/article/details/80944227
python list 查找与过滤方法整合（查找第一个匹配项:next，重复时想要所有的索引:enumerate）：https://blog.csdn.net/qq997843911/article/details/93855706
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fe256080501fdd2df98b65d4b4688f1/" rel="bookmark">
			leetcode_336_回文对
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回文对 描述 困难
给定一组 互不相同 的单词， 找出所有不同的索引对(i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。
示例 1：
输入：["abcd","dcba","lls","s","sssll"] 输出：[[0,1],[1,0],[3,2],[2,4]] 解释：可拼接成的回文串为 ["dcbaabcd","abcddcba","slls","llssssll"] 示例 2：
输入：["bat","tab","cat"] 输出：[[0,1],[1,0]] 解释：可拼接成的回文串为 ["battab","tabbat"] 解题 首先是暴力做法，果然，超时了
class Solution: def palindromePairs(self, words: List[str]) -&gt; List[List[int]]: res = [] n = len(words) for i in range(n): for j in range(n): if i == j: continue if self.is_palindrome(words[i] + words[j]): res.append([i, j]) return res def is_palindrome(self, s): right = len(s) - 1 left = 0 while left &lt; right: if s[left] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fe256080501fdd2df98b65d4b4688f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/942981f34cc891fb08d6e9a4320b2e9b/" rel="bookmark">
			微信小程序本地连接后端开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 技术小白一枚，如有出现错误的地方，还请各位多加指点，也欢迎前来交流。
​ 开发小程序需要后台开发，但刚刚开始可能不会直接把要调试的代码放在服务器部署。此方法是方便开发者在本地进行微信小程序的前后端连接调试。
1、不校验合法域名 ​ 在微信开发者工具中，选择右上角的详情，在本地设置中勾选不校验合法域名。
2、设置url为http ​ 1)为了方便使用，所以在app.js中设置了server值（域名），具体为http://域名：接口（示例http://www.test.com:8088）
​ 2)在url处填写好接口地址
​ 注：在此处使用http是用于本地连接，真正使用时，小程序仅支持https的接口地址。
3、设置host文件 ​ 在C:\Windows\System32\drivers\etc文件夹中，打开host文件，在文件最后一行添加映射。
#这里是示例，你填写自己的域名就可以了 127.0.0.1	www.test.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eedf65d5e5487c556d18dea8cc69c0d3/" rel="bookmark">
			leetcode_3_无重复字符的最长子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无重复字符的最长子串 描述 中等
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度
示例：
输入: "abcabcbb" 输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 输入: "bbbbb" 输出: 1 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。 输入: "pwwkew" 输出: 3 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。 解题 遍历s并借助字典记录下不同字符出现位置
当遍历到一个字符，且该字符出现在字典中时，说明出现了重复字符
此时，这两个重复字符之间的距离就是无重复字符的长度
设置左右指针left和right（滑动窗口）
当left和right之间没有重复字符时，无重复最大子串长度为right-left
当出现重复时，向右移动left指针，保证left和right之间无重复元素
当有重复元素出现时
if s[right] in dic: left = max(dic[s[right]], left) 更新left并不是直接等于上一个重复元素的位置
例如"abcba"
当右指针扫描到第二个"b"时，left更新为指向第一个"b"
当右指针扫描到第二个"a"时，需要判断，left是否需要更新
代码中使用max就解决了这个问题
class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: dic = {} left = -1 # 初始位置长度，用于记录上一个重复字符的位置 res = 0 for right in range(len(s)): # 当出现重复元素时，更新left if s[right] in dic: left = max(dic[s[right]], left) res = max(res, right - left) dic[s[right]] = right # 添加/更新字符位置 return res 或者更直观的窗口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eedf65d5e5487c556d18dea8cc69c0d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f4875360430e0f72dd5bc5f45420571/" rel="bookmark">
			java 之 Excel操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求如下： excel表格中的信息有姓名和身份证号，同时也有对应的时间戳，对应每个人的简历原文件名。现在要求将简历重命名为"姓名_身份证.pdf"的形式，将文件的名字写入表格的第5列中。要求用Java来实现。
前期准备，需要下载jxl.jar包，添加入文件工程，添加以及配置方法为：https://blog.csdn.net/Golden_soft/article/details/80952243
实现思路：
1. 遍历表格，建立person类，存放个人姓名，id，行号（为之后添加第5列信息作准备，这是最后实现添加需求时补充的）
2. 建立person 和 原文件名的映射
3. 遍历集合，找到原文件，对其进行改名
4. 在遍历集合的循环内同时对表格元素进行修改
需要注意的：
1. 读取表格的流程 结构的关系为 工作簿 workbook- 工作表 sheet - 单元格 cell
单元格 cell.getContents() 获取单元格的内容
File files = new File(pathName); InputStream inputStream = new FileInputStream(files); // 新建并获取工作簿 Workbook workbook = Workbook.getWorkbook(inputStream); // 读取工作表 Sheet sheet = workbook.getSheet(0); // 按照行数进行读取 int rows = sheet.getRows(); for(int i = 1;i&lt;rows;i++) { // Cell代表单元格 分别是读名字，读id,读时间 Cell cell_name = sheet.getCell(1,i); Cell cell_id = sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f4875360430e0f72dd5bc5f45420571/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af4b8f5b6aef4b564b00997dde47d170/" rel="bookmark">
			同步代码至 Github 和 Gitee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 同步代码至 Github 和 Gitee方式一：导入仓库方式二：同步更新一、同步二、查看三、更新四、纠错 同步代码至 Github 和 Gitee 方式一：导入仓库 登陆 Gitee 账号，点击右上角的 + 号，点击「从 GitHub 导入仓库」，在跳转的页面中授权 Gitee 访问。
方式二：同步更新 一、同步 删除已关联的名为 origin 的远程库
git remote rm origin关联 GitHub 的远程库
git remote add github https://github.com/?.git关联 Gitee 的远程库
git remote add gitee https://gitee.com/?.git修改.git文件夹内的config文件 [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true [remote "github"] url = git@github.com:chloneda/demo.git fetch = +refs/heads/*:refs/remotes/github/* [remote "gitee"] url = git@gitee.com:chloneda/demo.git fetch = +refs/heads/*:refs/remotes/gitee/* 上传代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af4b8f5b6aef4b564b00997dde47d170/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec9aa0219c007466d79bd4e4177a0fb/" rel="bookmark">
			SQL server的timestamp类型在查询时，可以直接where转换后的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如timestamp为0x00000000000065A6
CONVERT(BIGINT,timesta)为26022
可以直接where timesta=26022
SQL Server 2014 - 12.0.2000.8 版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c8af6e9572bbb608dde31af77e409e4/" rel="bookmark">
			‼ gifsicle pre-build test failed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在window10上运行vue项目报错
npm install gifsicle@4.0.1 postinstall c:\Users...\Documents...\node_modules\gifsicle node lib/install.js ‼ tunneling socket could not be established, cause=connect ECONNREFUSED 127.0.0.1:80 ‼ gifsicle pre-build test failed i compiling from source × Error: Command failed: C:\WINDOWS\system32\cmd.exe /s /c "autoreconf -ivf" "autoreconf" non � riconosciuto come comando interno o esterno, un programma eseguibile o un file batch. at Promise.all.then.arr (c:\Users\...\Documents\...\node_modules\execa\index.js:231:11) at process._tickCallback (internal/process/next_tick.js:68:7) npm WARN apodoc@1.0.0 No description npm WARN apodoc@1.0.0 No repository field. npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c8af6e9572bbb608dde31af77e409e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2833f240163e061965c9cca5aa0f1ed4/" rel="bookmark">
			Git的配置入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Git是程序界不可缺少的工具，他是专业的代码管理平台，敏捷高效。被普遍应用到大小项目中，甚至有些企业优先录用会Git的员工，可见Git的重要性。
常见的Github和阿里云code都是以Git技术为依托做的项目托管平台，下面以Github为例为大家介绍他的工作原理，以及Github强大的代码共享管理机制，和作为小白的我们如何开始入门使用Github。
1、创建Github 1.1 注册Github 地址: https://github.com/
输入账号、邮箱、密码,然后点击注册按钮.
注册完成后,选择Free免费账号完成设置。
1.2 创建仓库 注册好账户后，就可以使用Github了。Github最主要的功能是代码托管，他可以实现多人同时修改文件，并记录修改记录，标记出前后文件的差异。方便共同开发的团队知道自己的代码修改和别人的代码改变状态。项目经理和开发人员可以在一处协调、跟踪和更新他们的工作，从而使项目保持透明并按计划进行。
如何实现上面所说的项目协调管理呢？步骤如下：
①先创建仓库
仓库是项目过程中所用到或开发的所有文件的集合，里面可以有文件夹、代码、文档、图片等等，项目中用到的资料。
登陆后在右上角＋号点击New repository
填写相关信息即可，
详见：https://www.cnblogs.com/xueweihan/p/7217846.html
1.3 创建分支 分支是一个可以让你在同一时间工作在同一个仓库的不同版本的方法。
在你的仓库中会有一个默认的名叫“master”的主分支，该分支用来存储你最终确定的版本代码。我们用其他的子分支来进行编辑和更改，确定之后再提交到主分支。
当你从主分支创建出一个子分支的那一刻，其实你就是对当时时间点的主分支做了一个拷贝。如果之后别的分支的人对主分支做出了更新，在你提交到主分支之前，你必须先从主分支上拉取那些更新。
在GitHub中，保存更改被称为“提交”。每一次提交都需要写一段我们为什么做出修改的备注说明。这些备注说明将对你的更改做出记录，其他伙伴看到之后就知道你每次都提交了什么。
做出修改并提交
点击“README.md”文件，切换到“README.md”内容页面点击编辑框右上角的铅笔按钮，进入编辑界面在编辑框中，写一些你自己的信息在下方的“提交更改”框中，输入你做出此次修改的备注说明点击下方的“Commit changes”按钮 1.4 请求代码合并 现在你已经对你的新分支做出了修改，我们可以发出“请求代码合并”的请求啦。
请求代码合并是GitHub团队协作的核心功能。当你发出一个“请求代码合并”请求的时候，相当于你请求别人拷贝你当前的代码做出审查，审查通过之后将你的代码下载并且合并到他们的分支上。该请求将会在所有的分支上显示出不相同的部分。你做出的任何更改、增加以及减少，都会用绿色和红色显示出来。
在你的代码完成之前，你可以随时进行代码提交，发起请求代码合并的请求以及进行一场讨论。
你可以通过GitHub的“@”功能，在每次发出“请求代码合并”请求的时候，向特定的人或团队做出反馈，无论这个人是在你身边还是远在千里之外。
你可以向自己的仓库发出“请求代码合并”的请求，并且自己去合并他们。这在你接触到大型项目之前是一个非常好的练习方法。
第一步：点击“Pull Request”选项卡按钮，切换到请求代码合并页面，点击绿色的“New pull request”按钮
第二步：选择你创建的“readme-edits”分支，与主分支进行比较。
第三步：在对比页面查看这些更改，确定他们就是你想要提交的。
第四步：当你确定这些更改就是你所要的时候，点击绿色的“Create Pull Request”按钮。
第五步：为你的更改做一个简单的标题和描述。当你写完备注描述之后，点击“Create pull request”按钮。
https://www.cnblogs.com/keessi/p/7232451.html
2、本地文件上传到Github 2.1 安装Git 百度git官网，下载链接，根据自己电脑系统下载相应的安装包，选项都选择默认即可。
详见：https://blog.csdn.net/huangqqdy/article/details/83032408
2.2 本地与GitHub连接 多用于开发，深度学习用的不多。
2.2.1 使用GIT GUI 包括将本地文件上传到Github上、将Github上的文件下载到本地、本地文件和Github上文件冲突的处理。
①在本地新建版本库
首先，我们打开Git GUI是这样的一个界面，选择第一项，新建版本库。
选择你需要进行版本管理的项目路径，我选择了一个LoginDemo的项目。
当你创建了版本库的时候，你可以在该项目的路径下看见多了一个.git文件夹（设置了隐藏文件不可见的话看不见）
在Git Gui中，如果Unstaged Changes（未缓存的改动）中包含文件，则先点击Stage Changed，将未缓存的改动加入缓存，再点击Commit；否则需要先点击Rescan扫描项目中进行过改动的文件。注：提交描述必须要填写，不然无法提交。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2833f240163e061965c9cca5aa0f1ed4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e0064a21a41614a9cb38407cadcf81/" rel="bookmark">
			img标签无图片或者图片url错误时显示默认图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		img标签无图片或者图片url错误时显示默认图片
如上图，四个img标签中插入四张图片。
核心：οnerrοr="this.src=‘默认图片路径’ "
当img标签src路径错误或者不存在时就会默认显示我们设置的图片。
结果如下图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38ad55edeead591d13955cc8cbf81fdb/" rel="bookmark">
			记 Scrcpy 框架使用记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记 Scrcpy 框架使用记录 背景
最近使用 vysor 。发现直接把手机当成模拟器操作确实是方便到不行。 但是魅族 16th plus 在 vysor 失效了。同时vysor 通知太过干扰。基于以上两点切换到开源框架 scrcpy: Display and control your Android device
原理 image.png
主要步骤如下：
通过 adb push 一个 scrcpy-server.jar 到手机上。
注： scrcpy-server.jar 是虽然是一个 zip 文件。 但是其实是一个apk。PC 端通过 adb reverse 反向代理手机端口。用来接收手机端发送过来的数据。adb shell CLASSPATH=/data/local/tmp/scrcpy-server.jar app_process /com.genymobile.scrcpy.Server com.genymobile.scrcpy.Server 0 8000000 false - false 使用 app_process 运行 scrcpy-server.jar 的代码。
scrcpy-server.jar 主要做三件事情：
1，开启 LocalSocket 和PC连接。 相应 PC 端传递过来的操作。
2，源源不断的将屏幕画面输出到PC，使用Mediacodec 编码。 PC 通过ffmpeg 解码播放。
3，使用 adb 来提高 scrcpy-server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38ad55edeead591d13955cc8cbf81fdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d91e803afa4f9b37b890ceb75b6f26aa/" rel="bookmark">
			C&#43;&#43;学习笔记7 —— vector容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用vector必须加上头文件 #include &lt;vector&gt; vector表示一个类型相同的对象的集合，如： vector &lt;int&gt; I; vector &lt;string&gt; s; vector &lt;类名&gt; D; c++中既有类模板，也有函数模板，模板本身不是一个类或者函数，更像是一份说明，编译器根据模板创建一个类或者模板的过程称为实例化。vector是一个类模板。对于类模板需要提供额外的信息指定模板到底生成什么样的类，实例化提供的信息：模板名后跟一对尖括号，括号内即为信息。vector可以包含的内容，除了引用类型，大部分都可。针对vector的对象类型是vector， vector&lt;vector&lt;int&gt; &gt;//有空格，老式写法 vector&lt;vector&lt;int&gt;&gt;//无空格，c++11写法 定义和初始化：
最常见的方式是定义一个空的vector，运行时再根据需要添加。v1。 vector&lt;T&gt; v1; vector&lt;T&gt; v2(v1); vector&lt;T&gt; v2=v1; vector&lt;T&gt; v3(n,val)//n个重复的元素，元素值为val; vector&lt;T&gt; v4(n);//n个； vector&lt;T&gt; v5{a,b,c};//区分列表初始化 vector&lt;T&gt; v5={a,b,c};// vector&lt;T&gt; v6{"a","b","c"};//列表初始化 区分列表初始值还是元素： vector&lt;int&gt; v1(10);//10个元素，每个初始化为0 vector&lt;int&gt; v2{10};//1个元素，为10 vector&lt;int&gt; v3(10,1);//10个元素，每个值为1 vector&lt;int&gt; v4{10,1};//2个元素，值为10，1 vector&lt;string&gt; s1{"hi"};//列表初始化 vector&lt;string&gt; s2("hi");//错误，不能使用字符串字面值构建vector对象 vector&lt;string&gt; s3{10};//10个元素，每个都是默认初始化的值 vector&lt;string&gt; s4{10,"hi"};//10个值，每个值为hi 向vector中添加对象：
直接初始化不常用，更常用的是定义时为空，要用时往里添加值；
使用函数push_back()。如： vector&lt;int&gt; I; for(i=0;i&lt;100;++i) I.push_back(i);// string s; vector &lt;string&gt; v; while(cin&gt;&gt;s) v.push_back(s); 如在循环体内部包含有向vector添加元素的语句，如上的while循环，则不能使用范围forvector的一些函数：v.size()、v.empty()、v.push_back()、v[n](返回v中第n个位置上的引用。访问vector中的元素：与string类似 vector&lt;int&gt; v{1,2,3,4,5,6}; for(auto &amp;i:v)//范围for循环，改变值，则用引用 i*=i; for(auto i:v)//范围for循环，只输出， cout&lt;&lt;i&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d91e803afa4f9b37b890ceb75b6f26aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f4a5848d4fb52da092dfe83214f1a4/" rel="bookmark">
			EasyUI editor datebox进入编辑状态时值置空问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述
EasyUI的行编辑editor在进入编辑状态后，如果行里存在datebox，这时是没有问题的，可以正常使用，但是如果在进入编辑状态后，在js代码再使用.datebox()方法初始化datebox框，就会清空datebox中现有的值。
页面看到的还是有值的，实际提交到后台的已经是空字符串了。
感觉这是框架的一个bug（纯属猜测）
解决思路
其实思路很简单，值是在再次使用.datebox()方法初始化datebox框后置空的，那么我们可以在置空前使用变量保存值，在置空后再给附上，这样既保留了初始值，又加载了我们的.datebox()新属性，两不耽误。
代码
HTML：
&lt;th data-options="field:'planSendDate',width:fixWidth(0.12),align:'center', editor:{ type:'datebox', options:{ required:true, editable:false } }"&gt;发运日期&lt;/th&gt; JS：
//日期和周几联动 var planSendDate = $(this).datagrid('getEditor', {'index':editingIndexQC,'field':'planSendDate'}).target; var planSendWeekday = $(this).datagrid('getEditor', {'index':editingIndexQC,'field':'planSendWeekday'}).target; //保留初始值 var hvalue = planSendDate.datebox("getValue"); //加载新属性，同时会置空值 planSendDate.datebox({ onSelect:function() { var newDate = planSendDate.datebox("getValue"); var week = getWeek(newDate); planSendWeekday.combobox("setValue",week); } }); //附上初始值 planSendDate.datebox("setValue",hvalue); That’s all. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb4e3bc04732af542c883a31fb633790/" rel="bookmark">
			vue实现录音功能js-audio-recorder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 因为业务需要，现在将整理的录音功能资料记录下，使用插件js-audio-recorder 实现效果：可得到三种录音数据，pcm,wav,mp3 等 官方api入口：点我(网不好的童鞋可以看最下面的api截图) 官方案例入口：点我 官方源码git入口：点我 实现步骤： 一：安装插件 js-audio-recorder cnpm i js-audio-recorder --s 二：安装将格式转换为mp3的插件 lamejs cnpm install lamejs --s 三：附上实现源码： 提示：慎用自身的这个监听事件，可以拿到数据，但是每秒拿到的数据非常多
&lt;template&gt;
&lt;div class="home" style="margin:1vw;"&gt;
&lt;Button type="success" @click="getPermission()" style="margin:1vw;"&gt;获取麦克风权限&lt;/Button&gt;
&lt;br/&gt;
&lt;Button type="info" @click="startRecorder()" style="margin:1vw;"&gt;开始录音&lt;/Button&gt;
&lt;Button type="info" @click="resumeRecorder()" style="margin:1vw;"&gt;继续录音&lt;/Button&gt;
&lt;Button type="info" @click="pauseRecorder()" style="margin:1vw;"&gt;暂停录音&lt;/Button&gt;
&lt;Button type="info" @click="stopRecorder()" style="margin:1vw;"&gt;结束录音&lt;/Button&gt;
&lt;br/&gt;
&lt;Button type="success" @click="playRecorder()" style="margin:1vw;"&gt;录音播放&lt;/Button&gt;
&lt;Button type="success" @click="pausePlayRecorder()" style="margin:1vw;"&gt;暂停录音播放&lt;/Button&gt;
&lt;Button type="success" @click="resumePlayRecorder()" style="margin:1vw;"&gt;恢复录音播放&lt;/Button&gt;
&lt;Button type="success" @click="stopPlayRecorder()" style="margin:1vw;"&gt;停止录音播放&lt;/Button&gt;
&lt;br/&gt;
&lt;Button type="info" @click="getRecorder()" style="margin:1vw;"&gt;获取录音信息&lt;/Button&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb4e3bc04732af542c883a31fb633790/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f4b4d50e318ad360eaee20edc41544e/" rel="bookmark">
			各进制间的相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.十进制 （1）、十进制转二进制
十进制整数转换为二进制整数采用"除2取余，逆序排列"法。
例如：
（2）、十进制转八进制
和转为二进制一样，将十进制数除以八，按顺序记录每次得到的余数，直到商为0，然后将得到的各个余数从最后得到的那个开始向右排起就是一个八进制数了
例如：
（3）、十进制转十六进制
跟上面差不多，就是变成了除以16
例如：
2.二进制 （1）、二进制转十进制
从二进制的右边第一个数开始，每一个乘以2的n次方，n从0开始，每次递增1。然后得出来的每个数相加即是十进制数。
（2）、二进制转八进制
取三合一法，即从二进制的小数点为分界点，向左(向右）每三位取成一位，接着将这三位二进制按权相加，得到的数就是一位八位二进制数，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的八进制数。如果向左（向右)取三位后，取到最高（最低)位
时候，如果无法凑足三位，可以在小数点最左边（最右边)，即整数的最高位(最低位）添0，凑足三位。
例:
1、将二进制数101110.101转换为八进制
得到结果:将101110.101转换为八进制为56.5
2、将二进制数1101.1转换为八进制
得到结果:将1101.1转换为八进制为15.4
简易背过，也可以自己找规律。 （3）、二进制转十六进制
二进制转换成十六进制的方法是，取四合一法，即从二进制的小数点为分界点，向左（或向右）每四位取成一位
3.八进制 （1）、八进制转二进制
八进制转为二进制，反过来啦，方法就是一分三，即一个八进制数分成三个二进制数，用三位二进制按权相加，最后得到二进制，小数点依旧就可以啦。
可以参看上面的表
（2）、八进制转十进制
跟二进制转换为十进制差不多
（3）、八进制转化为十六进制
八进制转换bai成十六进制算法通常有两种方法：
1、先将八进制转换成二进制，再将二进制转换成十六进制
2、先将八进制转换成十进制，再将十进制转换成十六进制
4.十六进制 （1）、十六进制转换为二进制
将16进制转为二进制，反过来啦，方法就是一分四，即一个十六进制数分成四个二进制数，用四位二进制按权相加，最后得到二进制，小数点依旧就可以啦
（2）、十六进制转换为十进制
和上面的二进制转十进制和八进制转十进制差不多
（3）、十六进制转八进制
可以先转化为十进制，再转化为十六进制。
比较简单的方法是通过先转化为二进制，再转化为十六进制
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d95cffda00e02a073810f55d4c9adf0c/" rel="bookmark">
			vue实现录音功能js-audio-recorder带波浪图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 因为业务需要，现在将整理的录音功能资料记录下，使用插件js-audio-recorder 目录： 实现效果：可得到三种录音数据，pcm,wav,mp3 等
官方api入口：点我(网不好的童鞋可以看最下面的api截图)
官方案例入口：点我
官方源码git入口：点我
实现步骤：
一：安装插件 js-audio-recorder
二：安装将格式转换为mp3的插件 lamejs
三：附上实现源码：
到这里，代码就结束了，上面每个方法都有很详细的注释，就不累赘了
整理api:（有代理的可以看官网，这里是摘取官网的api）
1，使用
安装
npm 方式
script 标签方式
2，属性
实例初始化
sampleBits
sampleRate
numChannels
compiling
实例属性
duration
fileSize
3，操作
start()
pause()
resume()
stop()
play()
getPlayTime()
pausePlay()
resumePlay()
stopPlay()
destroy()
音频数据
录音结束，获取取录音数据
录音结束，下载录音文件
录音中，获取录音数据
录音波形显示
播放外部
Player.play(blob)
其他
录音权限
getPermission()
4，Event
onprocess(duration)
onprogress(duration)
onplay
onpauseplay
onresumeplay
onstopplay
onplayend
5，应用
语音识别
6，Player
Player 播放类
Player.play([arraybuffer])
Player.pausePlay()
Player.resumePlay()
Player.stopPlay()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d95cffda00e02a073810f55d4c9adf0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9aaf2ac35ed7015ba90ccf62d30ceea/" rel="bookmark">
			tf.repeat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import tensorflow as tf tf.repeat(['a', 'b', 'c'], repeats=[3, 0, 2], axis=0) &lt;tf.Tensor: shape=(5,), dtype=string, numpy=array([b'a', b'a', b'a', b'c', b'c'], dtype=object)&gt; repeat([[1, 2], [3, 4]], repeats=[2, 3], axis=0) &lt;tf.Tensor: shape=(5, 2), dtype=int32, numpy= array([[1, 2], [1, 2], [3, 4], [3, 4], [3, 4]], dtype=int32)&gt; repeat([[1, 2], [3, 4]], repeats=[2, 3], axis=1) &lt;tf.Tensor: shape=(2, 5), dtype=int32, numpy= array([[1, 1, 2, 2, 2], [3, 3, 4, 4, 4]], dtype=int32)&gt; repeat([[1,2], [3,4]], repeats=2) &lt;tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9aaf2ac35ed7015ba90ccf62d30ceea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb3dda38ede4bb1de8eb680d71f2b62f/" rel="bookmark">
			利用决策树模型分析电信客户流失预测项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先这是一个比较经典的项目了，自己先拿到数据源是一个csv格式的时候，想清楚出发点是什么，项目背景是怎样的，以哪个为切入点。
1. Tableau做猜想预测 分成两大块，从人口特征和消费服务特征来做分析
利用Tableau做项目预测猜想，因为这个项目是一个简单的二分类，分类标准是Churn是否会流失，所以Churn是标签类别
得出结论：
1、没有子女、没有伴侣的老年用户流失率比较高
2、老年用户中流失用户的月度平均消费均比未流失用户要高17%的总价
3、从流失的人群中发现平均使用的时间占比少、月度花费比较高
4、流失的客户中大多数都是使用Fiber optic的网络服务、DSL的电话服务，进一步推断Fiber optic的网络服务的故障率比较高，加强客户售后意识，定期查询网络故障并及时修复。
5、流失的客户里面大部分都不使用OnlineBackup、DeviceProtection、OnlineSecurtiy、TechSupport服务
6、流失的人群里面大多数都是用月度支付的无纸化电子支票的支付方式，进一步推断由于支付方式比较繁琐，导致客户支付不便利。
对于上述观点，我采用了以下的数学模型来做分析依据：
其中由于决策树更加直观可以看到客户流失与哪些相关因素有关，下面是对上述分析的佐证。
2、代码实现 数据集分类：
数据划分处理：将数据分为3类
1、二分类数据：Yes/No转换为1/0，Yes=1/No、No services=0
2、离散型标签分类：将标签重新开设一列，作为0/1分类的标准
3、数值型分类，其数据内容具备顺序以及加减运算的数值意义。目前属于这类特征的变量有：已使用年限，月消费。我打算采用连续特征离散化的处理方式。原因是离散化后的特征对异常数据有更强的鲁棒性，降低过拟合的风险，模型会更稳定，预测的效果也会更好。
数据离散化也称为分箱操作，其方法分为有监督分箱（卡方分箱、最小熵法分箱）和无监督分箱（等频分箱、等距分箱）。本次为采用无监督分箱中的等频分箱进行操作。下图以Tenure为例
#将CSV数据集导入 from sklearn import datasets import pandas as pd import matplotlib.pyplot as plt import numpy as np #整理数据 TargetData=pd.read_csv('telecom_churn.csv') #数据集大小 print(TargetData.shape) #数据集是否有缺失值 print(TargetData.isnull().sum()) #检查数据类型 print(TargetData.dtypes) #检查数据是否包含空字符 print(TargetData[TargetData['TotalCharges'].isin([' '])]) #修复错误输入的数据集： TargetData.replace(to_replace=r'^\s*$',value=np.nan,regex=True,inplace=True) TargetData.dropna(axis=0, how='any', inplace=True) TargetData['TotalCharges']=pd.to_numeric(TargetData['TotalCharges']) TargetData.describe(include='all') #将PaymentMethod ，OnlineSecurity，OnlineBackup，DeviceProtection ，TechSupport 转化为0-1编码 from sklearn.preprocessing import LabelEncoder encoder=LabelEncoder() colLabel=['gender','Partner', 'Dependents', 'PhoneService','PaperlessBilling','Churn'] for i in colLabel: TargetData[i]=encoder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb3dda38ede4bb1de8eb680d71f2b62f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8076736add277e06213f62d6e235723/" rel="bookmark">
			论文解读：Graph Convolutional Networks for Text Classifification
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文解读：Graph Convolutional Networks for Text Classifification 先前的文本分类方法是基于CNN或RNN进行的，只能单独的对文本自身的上下文进行语义提取，而不能够对文本之间的相关信息进行表示。随着图结构在NLP领域的大放光彩，将图引入文本分类是新的思路。
一、简要信息 序号属性值1模型名称Text-GCN2所属领域自然语言处理3研究内容文本分类4核心内容Text Classification, Graph Convolutional Network5GitHub源码https://github.com/yao8839836/text_gcn6论文PDFhttps://arxiv.org/pdf/1809.05679v17引用（GBT7714）Liu X , You X , Zhang X , et al. Tensor Graph Convolutional Networks for Text Classification[J]. World Wide Web, 2020(Aug).8引用（BibTex）@article{Liu2020Tensor,title={Tensor Graph Convolutional Networks for Text Classification},author={Liu, Xien and You, Xinxin and Zhang, Xiao and Wu, Ji and Lv, Ping},journal={World Wide Web},number={Aug},year={2020}} 二、任务描述 给定一个语料， 首先通过词共现统计方法构建一个图，记做 G = ( V , E ) G=(V,E) G=(V,E)，其中 V V V 表示图中的结点，可以是单词，也可以是文档； E E E 则表示边。只定义（文档-单词）和（单词-单词）之间的边。因此文本翻译可以建模成结点分类（node classification）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8076736add277e06213f62d6e235723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2add1f2456cff83a47626c9de87a4f3f/" rel="bookmark">
			java链接opc报异常org.jinterop.dcom.common.JIException: Access is denied解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下这次从发现问题到解决问题的过程
项目是通过java链接OPC，读取数据，并且发送数据的
程序一直运行正常，最近客户反馈说无法读取数据，通过查看，发现访问异常了。花了2天的时间才解决了这个异常。
org.jinterop.dcom.common.JIException: Access is denied, please check whether the [domain-username-password] are correct. Also, if not already done please check the GETTING STARTED and FAQ sections in readme.htm. They provide information on how to correctly configure the Windows machine for DCOM access, so as to avoid such exceptions. [0x00000005] at org.jinterop.dcom.core.JIComServer.init(JIComServer.java:542) at org.jinterop.dcom.core.JIComServer.initialise(JIComServer.java:458) at org.jinterop.dcom.core.JIComServer.&lt;init&gt;(JIComServer.java:427) at org.openscada.opc.lib.da.Server.connect(Server.java:118) at opc.apply.threads.ReadDataThread.getServer(ReadDataThread.java:231) at opc.apply.threads.ReadDataThread.run(ReadDataThread.java:57) at java.lang.Thread.run(Thread.java:745) Caused by: rpc.FaultException: Received fault. (unknown) at rpc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2add1f2456cff83a47626c9de87a4f3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e3e516b3ddce963806ddf0001c0b7f5/" rel="bookmark">
			7. 主动信息收集-端口扫描
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		端口扫描（四层） 当我们发现存活主机ip后，接下来就是确定这些活着的ip上面有哪些开放的端口，每个服务器都会跑很多应用，每个应用会侦听某些端口，通过侦听这些端口来接受来自客户端和用户对应用程序的访问。
这些应用程序的漏洞都是通过端口来体现出来的，后面渗透测试如果能够攻击进入操作系统也是从端口进入，这些端口都会成为后续攻击面的一个体现。
端口扫描使用的技术其实与发现阶段一样的。
UDP端口扫描 发现阶段确认是活着的ip，这时候我们扫描是没有不在线的ip的，所以对于在线ip进行UDP扫描也就是两种情况，端口开了和没开。
此时判断思路与发现阶段相反，发现阶段是依靠判断对方没有打开端口，通过返回端口不可达来确定主机是存在的，而现在返回ICMP端口不可达的信息是我们不关心的，只有那些没有响应的端口，我们认为它是开放的。
一些特殊情况（对于返回消息进行了处理），会导致扫描所有端口都是没有回复-55
假设ICMP port-unreachable 响应代表端口关闭
目标系统不响应ICMP port-unreachable时，可能会产生误判 完整的UDP应用层请求
准确性高耗时巨大 tcp和udp各有 有6万多个端口，如果全部扫描准确性还是比较高的，但是数量太多，耗时比较大
#!/usr/bin/python import logging logging.getLogger("scapy.runtime").setLevel(logging.ERROR) from scapy.all import* import sys if len( sys.argv ) !=4: print "Example - ./syn_scan.py 1.1.1.1 1 100" sys.exit() ip = str(sys.argv[1]) start = int(sys.argv[2]) end = int(sys.argv[3]) for port in range(start,end+1): a=sr1(IP(dst=ip)/TCP(dport=port),timeout=1,verbose=0) if a ==None: pass else: if int(a[TCP].flags)==18: print port else: pass TCP端口扫描 基于连接的协议三次握手隐蔽扫描僵尸扫描全连接扫描所有的TCP扫描方式都是基于三次握手的变化来判断目标端口状态 1.全连接扫描 建立完整三次握手
2.隐蔽扫描——syn 不建立完整连接，只发送syn包，如果收到ack/syn即可判断端口开发，如果没有开放会收到rst
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e3e516b3ddce963806ddf0001c0b7f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f88864367b1de9ebe726e0116082cbdb/" rel="bookmark">
			YouTube热门视频的分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YouTube热门视频的分析 1 概述2 数据的预处理3. YouTube数据集的探索性分析3.1 简单的描述性分析3.2 相关性分析3.3 gropby分组函数3.3.1 gropby分组函数搜寻YouTube Top20的频道3.3.2 gropby分组函数 category类别出现的频率排序3.3.3 gropby分组函数 浏览量最多的Top20频道3.3.4 gropby分组函数 通关浏览量对类别进行排名 4 结论： 1 概述 Youtube视频网站是美国最大的视频分享平台,youtube官网在中国也有很多用户。数据来源于kaggle网站，本文主要选取CA国家，探究YouTube在CA国家Top20热门视频数据。
2 数据的预处理 1、导包
import numpy as np import pandas as pd import matplotlib.pyplot as plt` import seaborn as sns import json from datetime import datetime import pandas as pd data = pd.read_csv("3D Objects/CAvideos.csv",index_col=0) 2、查看数据集
data data["trending_date"]`` 我们发现trending_date日期格式不一样，所以要对其进行日期格式的转化，这里我们用到datetime函数
data["trending_date"] = pd.to_datetime(data["trending_date"],format ="%y.%d.%m") 同理pubulish_time也一样
data["publish_time"] = pd.to_datetime(data["publish_time"],format = "%Y-%m-%dT%H:%M:%S.%fZ") data["category_id"] = data["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f88864367b1de9ebe726e0116082cbdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/444cf00a5e940ab6fcd29813b834d0fc/" rel="bookmark">
			如何更改max_allowed_pa​​cket大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文翻译自：How to change max_allowed_packet size
I am having a problem with BLOB fields in my MySQL database - when uploading files larger than approx 1MB I get an error Packets larger than max_allowed_packet are not allowed. 我的MySQL数据库中的BLOB字段存在问题-上传大于1MB的文件时出现错误， Packets larger than max_allowed_packet are not allowed. Here is what i've tried: 这是我尝试过的： In MySQL Query Browser I ran a show variables like 'max_allowed_packet' which gave me 1048576. 在MySQL查询浏览器中，我运行了一个show variables like 'max_allowed_packet' ，它给了我1048576。 Then I execute the query set global max_allowed_packet=33554432 followed by show variables like 'max_allowed_packet' - it gives me 33554432 as expected.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/444cf00a5e940ab6fcd29813b834d0fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e60eef3197c5f9b71010689e82ac1d31/" rel="bookmark">
			nrf52840的uart0与uart1双串口使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nrf52840的uart0与uart1双串口使用 项目原使用nrf52832,后面由于项目需要用到双串口，改用nrf52840，官方的例程没看到使用uart1的，找遍全网都没找到uart1的使用资料，有些不负责任的网文居然说40也只有一个uart，吓得俺赶紧又查看了一次datesheet，O得K、木鸭梨
SDK代码uart驱动中，搜索到uart1的驱动部分，说明官方驱动有uart1支持的
自己动手，丰衣足食吧，下面以nRF5_SDK_17.0.0_9d13099版本，在examples\ble_peripheral\ble_app_uart\pca10056的例程上修改
1：在配置文件中，启用下面两项，如果没有的加上
// UART1_ENABLED - Enable UART1 instance
//==========================================================
#ifndef UART1_ENABLED
#define UART1_ENABLED 1
#endif
// UART1_CONFIG_USE_EASY_DMA - Default setting for using EasyDMA
#ifndef UART1_CONFIG_USE_EASY_DMA
#define UART1_CONFIG_USE_EASY_DMA 1
#endif
2：修改app_uart库，主要修改了app_uart_fifo.c文件，官方的APP层，原来只支持单个uart0的操作，改为支持多instance
app_uart.h中，定义obj
代码上传到https://download.csdn.net/download/chhen168/12688127，把我上传的‘nrf52840的uart0与uart1双串口_uart’替换到nRF5_SDK_17.0.0_9d13099\components\libraries\uart里的文件即可，可用对比软件对比旧的，查看修改项
3：使用就简单了，定义两个uart实例
调用初始化，完事
注意1：官方例程里的uart0初始化要去掉
注意2：APP层的代码，只修改了FIFO的文件，如果不使用FIFO，app_uart.c要参照app_uart_fifo.c修改里面的几个函数
注意3：需要在uart定义文件里，定义下面两个函数，printf需要用到，原来的app_uart_get改为支持多uart，不适用了
uint32_t _app_uart_get(uint8_t * p_byte)
{
return app_uart_get(&amp;uart1, p_byte);
}
uint32_t _app_uart_put(uint8_t byte)
{
return app_uart_put(&amp;uart1, byte);
}
测试结果，木鸭梨
不会编辑，将就看吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f032aaaf118a9704673cfd21161501b8/" rel="bookmark">
			nested exception is com.spire.doc.packages.sprfIc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目使用spire，来操作Word（添加页眉、合并等）。
报错信息如下：
Uncaught exception thrown
org.springframework.web.util.NestedServletException: Request processing failed; nested exception is com.spire.doc.packages.sprfIc: java.security.NoSuchAlgorithmException: Cannot find any provider supporting DES/CBC/PKCS5Padding
INFO |[][] [http-nio-8898-exec-1] []|20-08-05.09:18:21|c.e.c.s.t.impl.AutoCreateTestServiceImp.wordAddHeader:1176 | ==========/home/upload/word/SpbDpc-86.docx ERROR|[][] [http-nio-8898-exec-1] []|20-08-05.09:18:22|o.s.c.s.i.web.ExceptionLoggingFilter.log:101 | Uncaught exception thrown org.springframework.web.util.NestedServletException: Request processing failed; nested exception is com.spire.doc.packages.sprfIc: java.security.NoSuchAlgorithmException: Cannot find any provider supporting DES/CBC/PKCS5Padding at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:982) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:877) at javax.servlet.http.HttpServlet.service(HttpServlet.java:661) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:851) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f032aaaf118a9704673cfd21161501b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83a2598481a9041b900d310eda991350/" rel="bookmark">
			HashMap：学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有关ConcurrentHashMap的学习总结我记录在了这一篇博文：ConcurrentHashMap学习总结
首先是HashMap的整体结构：
主体采用数组进行存储。当数组处的节点产生碰撞，会向下延伸，生成一条链表当超过成树阈值（8）且数组长度大于64后，采用红黑树进行存储（红黑树的结构复杂，但是查找效率高） HashTable的创建 jdk8以前：在创建的时候就会有一个Entry[] table来存储
jdk8以后：会在第一次put方法被调用的时候创建Entry[] 数组
数据的存储 通过Key的hashCode方法计算出值，再通过某种算法计算出数组中存储数据的空间的索引值，如果没有数据则存储。
计算索引的方式：key的hashCode方法计算出hash值，再用hash值与数组长度进行无符号右移(&gt;&gt;&gt;)，按位异或（^）、按位与（&amp;）计算出索引
如果key已经存在 – 检查hashCode是否一致。一致则更新数据 如果不一致，将会在索引位置上，生成一条链表来存储数据。
同时，会执行拉链法的数据查找，再这一条链表上进行key的equals方法比较（同时比较value和hashCode）。相等才进行数据更新
HashMap的插入过程 为什么初始数组长度必须为2的n次方？
hash &amp;（length - 1）使数组分布更加均匀，有效的减少了碰撞的发生
采用取余： hash &amp; (length - 1) == hash % length （当为2的n次幂时）但是位运算效率高很多
求近位数的算法
// 在算法之前会执行一次与MAXIMUM_CAPACITY的比较，超过则代入MAXIMUM_CAPACITY static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83a2598481a9041b900d310eda991350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a9f36bd1ce32c34752a983e1d15d0e/" rel="bookmark">
			日志系统：一条SQL更新语句是如何执行的？（基础篇02）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）
1. 重要的日志模块：redo log 不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。
如果有人要赊账或者还账的话，掌柜一般有两种做法：
一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。 在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。
这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？
同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘， 然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。 为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。 而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘也就是先写粉板，等不忙的时候再写账本。
具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。
如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。
与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写如下面这个图所示。
write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。
write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。
有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。
要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7a9f36bd1ce32c34752a983e1d15d0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edb1ee8d35cabd750222e8aa5eee6f9d/" rel="bookmark">
			一条SQL语句查询如何执行的？（基础篇01）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql&gt; select * from T where ID=10； 我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。
下面我给出的是 MySQL 的基本架构示意图，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。
MySQL 的逻辑架构图
大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。
Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
而存储引擎层负责数据的存储和提取。 其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。
也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。
从图中不难看出，不同的存储引擎共用一个Server 层，也就是从连接器到执行器的部分。 你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。
1.连接器 第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：
mysql -h$ip -P$port -u$user -p 输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。
连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。
如果用户名或密码不对，你就会收到一个"Access denied for user"的错误，然后客户端程序结束执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edb1ee8d35cabd750222e8aa5eee6f9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f510f1cc3d2d7463cd0e03786dee2b71/" rel="bookmark">
			【JavaWeb】XML详解优化（28）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 理财投资真的很让人着魔，怪不得有人赌上倾家荡产；据开学还有28天；从阿尔斯通，到Bytedance，无法评价，可能只是立场不同； 知识点总结 概念 XML(Extensible Makeup Language)指可拓展的标志语言；用于传输和存储数据； 与HTML的区别 XML的标签是可自定义的，而HTML的是预定义的；XML的语法严格，而HTML的语法松散；XML用于存储数据，HTML用于展示数据； 语法 基本语法 XML的文件声明必须放在第一行； &lt;?xml version='1.0'?&gt; XML元素的属性必须加上(单/双)引号；有且只有一个根目录；标签必须正确关闭；标签区分大小写； 快速入门 &lt;?xml version='1.0'?&gt; &lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt; &lt;/users&gt; 组成部分 一个XML文档分为以下几个部分：
1.文档声明
&lt;?xml 属性 ?&gt; 属性列表： versin="";版本 encoding="";使用的字符集 standalone="yes/no";是否依赖其他文件 2.指令
&lt;?... ?&gt; 常用于文档声明或连接CSS文件； &lt;?xml-stylesheet type="text/css" href="T1.css" ?&gt; 3.标签
标签是自定义的，但是格式要注意：
名称可以包含字母、数字以及其他的字符 ；名称不能以数字或者标点符号开始 ；名称不能以字母 xml（或者 XML、Xml 等等）开始 ；名称不能包含空格 ；
4.属性
属性值必须加引号；
5.文本CATA区
先介绍一下XML的实体引用：
在XML中，“&lt;“，”&amp;“等字符是不能直接放在文档中的，会产生XML错误，所以要用实体引用代替；
但这样比较麻烦，我们可以把带有特殊字符的语句放在CDATA区中；原理是CADTA区中文本会被解析器忽略，可以原封不动的打印出来； &lt;![CDATA[A &gt; B]]&gt; ============ 格式 &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f510f1cc3d2d7463cd0e03786dee2b71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4565d378051d579b7dd584dd07d9953/" rel="bookmark">
			Echarts鼠标移动切换数据项时Tooltip卡顿情况优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家在使用Echarts的过程用，可能会碰到这样的情况，就是鼠标切换数据项过快时，鼠标hover触发的Tooltip的展示会有延迟的现象，给用户有一种很卡的感觉。特别是当页面内容较多，或者trigger为’axis’ 触发Tooltip很频繁的时候。 针对这种情况，我们可以通过以下两个配置优化一下：
tooltip.enterable 该配置的含义是：鼠标是否可进入提示框浮层中，默认为false。我们通过将此项设置为true，让鼠标可以进入Tooltip浮层，当输入进入Tooltip浮层时，就不会触发其它数据项的hover事件，这样在鼠标移入Tooltip期间不会触发其它的Tooltip，从视觉上就不会有卡顿的现象
tooltip.axisPointer.animation 该配置的含义是：坐标轴指示器在变化时是否需要动画，默认为true。我们可以通过将该项设置为false。动画本身就有延迟的效果，而且会增大浏览器的渲染压力，将该项置为false也对加快Tooltip的显示和隐藏有所作用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3913fa948becdef03ecb2d55e4648fcf/" rel="bookmark">
			数据结构~12.树与二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构学习~12.树与二叉树 本文是上一篇文章的后续,详情点击该链接~ 树的基本概念 树是一种非线性的数据结构。要理解树的概念及其术语的含义,用一个例子说明是最好的方法。就比如下图就是一棵树,它是若干节点的集合。是由唯一的根(A)和若干互不相交的子树。就比如说,A,D,H,M,I,J这六个结点组成的树就是一颗子树组成的。其中,每一棵子树又是一棵树,也是由唯一的根结点和若干棵互不相交的子树组成的。由此而知,树的定义是递归的,也就是在树的定义中又用到了树的定义。要注意的是,树的结点数目可以为0,当为0时,这棵树称为一颗空树。
树的基本术语 结点: 刚刚那棵树的A,B,C等都是结点，结点不仅包含数据元素，而且包含指向子树的分支。也就是说A的结点不仅包含数据元素A，而且包含三个指向子树的指针。
结点的度: 结点拥有的子树个数或者分支的个数称为结点的度。就比如说A结点有三棵子树,所以A结点的度为3
树的度 树中各结点度的最大值。比如说树的结点度最大为3(就像刚才那棵树的A结点)，最小为0(就像是K,L,M等)
叶子结点 叶子结点又叫做终端结点,指度为0的结点，就比如刚才那棵树K,L,F,G,M,I,J都是叶子结点
非终端结点 非终端结点又叫做分支结点,指度不为0的结点，刚才那棵树除了叶子节点外,其他的都是非终端结点。除了根节点之外的非终端结点,也叫做内部结点。就像B,C,D,E,H结点都是内部结点
孩子 结点的子树的根,就比如说刚才那棵树的B,C,D都属于A的孩子
双亲 与孩子的定义对应,如B,C,D结点都是双亲A
兄弟 同一个双亲的孩子之间互为兄弟。就比如说B,C,D就互为兄弟。因为他们都是A的孩子
祖先 从根到某路径上的所有结点都是这个结点的祖先。比如说M的祖先是A,D,H。因为从A到M的路径是 A -&gt; D -&gt; H -&gt; M
子孙 以某结点为根的子树中所有结点都是该结点的子孙。就比如说B的子孙为E,F,K,L
层次与高度 从根开始,根为第一层,根的孩子为第二层,根的孩子的孩子为第三层以此类推。而高度的话呢,其实就是树中结点的最大层次。就比如说刚刚那棵树最大层次是4层所以高度是4
堂兄弟 双亲在同一层的结点互为堂兄弟。如G和H互为堂兄弟，因为G的双亲是C，H的双亲是D,C和D在同一层上。
有序树 树中结点的子树从左到右都是有次序的,不能交换。这样的树叫做有序树
无序树 树中结点的子树没有顺序,可以任意交换，这样的树叫做无序树
丰满树 丰满树也就是理想平衡树，要求除最底层外,其他层都是满的。
森林 若干棵互不相交的树的集合。例子中如果把A去掉,剩下的三棵子树互不相交。它们组成一个森林
树的存储结构 顺序存储结构 树的顺序存储结构中最简单直观的是双亲存储结构,用整形一维数组即可实现。最简单的定义方法可以是int tree[maxsize]，也就是用一个数组就可以存储一棵树的信息
就比如说上面这张图,用数组的下标来表示树中的结点,然后我们用数组元素的内容来表示该结点的双亲结点。这样有了结点(下标)以及结点之间的关系(内容),就可以表示一棵树了。
在这张图中,下标5上的内容为3，就是说5的双亲结点为3。下标1的内容为-1,就表示是根节点了~。这种定义主要就是当知道一个结点之后,就很容易找到双亲结点。
注意:这里介绍的双亲存储结构是高度简化的形式，实际应用中肯定是不会这么做的。
链式存储结构 树的链式存储最常用的有以下两种:
孩子存储结构
孩子兄弟存储结构
二叉树 二叉树的定义 在理解了树的定义之后,二叉树就很好理解了。将一般的树满足
每个结点最多只能有两颗子树,也就是说二叉树中结点的度只能为0、1、2。
二叉树有左子树和右子树,并且不能颠倒。这样就得到二叉树了~
二叉树的五种形态 空二叉树,只有根节点,只有左子树,只有右子树,既有左子树也有右子树
满二叉树与完全二叉树 在一颗二叉树中,如果所有分支结点都有左孩子和右孩子结点。并且叶子结点都集中在二叉树最下面一层。而这样的二叉树称为满二叉树。约定编号从1开始,从上到下,从左到右进行
如果对一颗深度为k,有n个结点的二叉树进行编号后,各结点的编号与深度为k的满二叉树中相同位置上的结点的编号均相同,那么这颗二叉树就是完全二叉树
图(a)为满二叉树，图(b)为完全二叉树。(作者字太难看,就用字母了==||) 二叉树的存储结构 顺序存储结构 顺序存储结构就是用一个数组来存储一颗二叉树,这种存储方式最适合完全二叉树。如果用来存储一般的二叉树的话,就会浪费大量的空间。将完全二叉树的结点按照编号依次存入一个一维数组中，也就完成了一个二叉树的顺序存储。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3913fa948becdef03ecb2d55e4648fcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb80a1224874ab23e310f27c5cfd8beb/" rel="bookmark">
			排队论 （queuing theory）推论与举例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、排队模型的表示
2、排队系统的衡量指标
3、排队系统的要素
顾客的输入过程
排队结构与排队规则
服务机构与服务规则
其中，到达间隔和服务时间（X，Y）具有的典型分布有
4、模型的系统运行状态参数：
泊松流到达间隔服从负指数分布：
顾客服务时间分布（负指数分布）:
5、M/M/1模型：
1、模型的条件是：
2、对于M/M/1模型有如下公式： 3、举例
6、M/M/S模型
1、模型的条件是：
2、对应M/M/S有如下公式：
3、举例
排队论 (queuing theory)，或称随机服务系统理论， 是通过对服务对象到来及服务时间的统计研究，得出这些数量指标（等待时间、排队长度、忙期长短等）的统计规律，然后根据这些规律来改进服务系统的结构或重新组织被服务对象，使得服务系统既能满足服务对象的需要，又能使机构的费用最经济或某些指标最优。它是数学运筹学的分支学科，也是研究服务系统中排队现象随机规律的学科。广泛应用于计算机网络、生产、运输、库存等各项资源共享的随机服务系统。 排队论研究的内容有 3 个方面：统计推断，根据资料建立模型；系统的性态，即和排队有关的数量指标的概率规律性；系统的优化问题。其目的是正确设计和有效运行各个服务系统，使之发挥最佳效益。
最初是用 3 个字母组成的符号 X/Y/Z 表示一个排队系统。其中 X 表示顾客到达时间分布，Y 表示服务时间的分布，Z 表示服务机构中的服务台的个数
1、排队模型的表示 X/Y/Z/A/B/C
X — 顾客相继到达的间隔时间的分布；
Y — 服务时间的分布(M — 负指数分布、D — 确定时间、Ek — k 阶埃尔朗分布、G — 一般随机分布、GI—一般相互独立分布)
Z — 服务台个数；
A — 系统容量限制（默认为 ∞）；
B — 顾客源数目（默认为 ∞）；
C — 服务规则 （默认为先到先服务 FCFS）。
2、排队系统的衡量指标 服务队长 Ls — 正在接受服务的顾客数；期望值；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb80a1224874ab23e310f27c5cfd8beb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d89ffc870e6a682e8fd25ae139da52f/" rel="bookmark">
			新项目启动报错：No qualifying bean of type ‘xxxMapper‘ available: expected at least 1 bean which qualifies..
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'orderServiceImpl': Unsatisfied dependency expressed through field 'baseMapper'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.acloud.eduorder.mapper.OrderMapper' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) ~[spring-beans-5.2.1.RELEASE.jar:5.2.1.RELEASE] at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:116) ~[spring-beans-5.2.1.RELEASE.jar:5.2.1.RELEASE] at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:397) ~[spring-beans-5.2.1.RELEASE.jar:5.2.1.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1429) ~[spring-beans-5.2.1.RELEASE.jar:5.2.1.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594) ~[spring-beans-5.2.1.RELEASE.jar:5.2.1.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) ~[spring-beans-5.2.1.RELEASE.jar:5.2.1.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) ~[spring-beans-5.2.1.RELEASE.jar:5.2.1.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.2.1.RELEASE.jar:5.2.1.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) ~[spring-beans-5.2.1.RELEASE.jar:5.2.1.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-5.2.1.RELEASE.jar:5.2.1.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:879) ~[spring-beans-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d89ffc870e6a682e8fd25ae139da52f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aff30d7387cc923b1f12cf217a76144/" rel="bookmark">
			GROMACS使用小计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考网站：（1）国内网址， github网址, tutorial
目录
MDP文件书写
GROMACS简单处理命令
MDP文件书写 1. 各个参数
title = Protein-ligand complex MD simulation ; Run parameters #（常用） integrator = md ; #指定积分算法；md:蛙跳牛顿积分算法，用于平衡动力学积分 nsteps = 500000 ; #积分或能量最小化步数，*dt= 1ns总模拟时长 （常用） dt = 0.002 ; #积分步长，一般为 0.002ps ~0.004ps ; Output control #（常用） nstxout = 0 ; #坐标保存到轨迹文件的频率 .trr nstvout = 0 ; #速度保存到轨迹文件的频率 v, 开启会增加运行时间 nstenergy = 5000 ; #能量保存到轨迹文件的频率，必须是nstcalcenergy的倍数 nstlog = 5000 ; # log文件更新频率 nstxout-compressed = 5000 ; # compressed-x-grps = System energygrps = Protein JZ4 #保存能量的组 ; Bond parameters continuation = yes ; #初试构象不约束，不复位，用于精确的继续计算或重计算 constraint_algorithm = lincs ; #约束算法 lincs ：不能用于角度约束 constraints = all-bonds ; #键约束，all-bonds:所有键约束，#(键的约束，不常用） lincs_iter = 1 ; #迭代次数，用于LINCS约束精度，默认1 lincs_order = 4 ; #约束偶合矩阵阶次，用于LINCS约束精度，默认4 ; Neighborsearching cutoff-scheme = Verlet ns_type = grid ; #邻近列表搜索方法 nstlist = 10 ; #邻近列表更新频率 rcoulomb = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aff30d7387cc923b1f12cf217a76144/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/357/">«</a>
	<span class="pagination__item pagination__item--current">358/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/359/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>