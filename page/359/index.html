<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5b6c1858c044bb1463d6c5c7f136d82/" rel="bookmark">
			Java设计模式之单例模式（Singleton Pattern）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
单例模式的概念
单例模式的要点
单例模式类图
单例模式归类
单例模式的应用场景
单例模式解决的问题
单例模式的实现方式
单例模式实现方式对比
单例模式的概念 单例模式，顾名思义就是只有一个实例，并且由它自己负责创建自己的对象，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象
单例模式的要点 1、一个类有且仅有一个实例
这个是单例模式的的精髓所在，如何保证类的实例有且只有一个是单例模式必须要保证的，单例实现的所有方式都是围绕着这个出发点来展开的
2、必须自行创建这个实例
在java中，通常是将类的构造方法私有化，从而保证无法在外部进行创建实例
3、必须自行向整个系统提供这个实例
在java中，是通过类的静态方法获取类的实例
单例模式类图 单例模式归类 单例模式属于创建型模式的一种
单例模式的应用场景 单例模式可以说无论是在我们的生活中，还是工作中，都有许多的应用场景，例如：
1、我们使用的电脑里的回收站
2、Spring的抽象工厂
3、日常开发用的工具类
单例模式解决的问题 全局使用的类的实例被频繁的创建和销毁，如果这些类的实例创建和销毁非常消耗性能，对系统来说无疑增加了负担
单例模式的实现方式 1、饿汉式
预创建实例，不管实例有没有用到。
代码实现：
public final class SingletonEHS { private static final SingletonEHS singleton = new SingletonEHS(); private SingletonEHS() {} public static SingletonEHS getInstance() { return singleton; } } 延迟初始化：否，由于实例是预创建的，所以没有达到延迟初始化的效果
线程安全：是，基于 classloader 机制避免了多线程的同步问题
反射破解：可破解
@Test public void testSingletonEHS() { try { Constructor&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5b6c1858c044bb1463d6c5c7f136d82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73a6bd74251df901e56461000389a7a9/" rel="bookmark">
			spring boot中实现动态定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网上找的资料最后整理出来的, 不过找不到原文章地址了, 感谢原作者的奉献
这里总共创建以下几个类:
DynamicCronJob: 动态定时任务, 包含了对定时任务的启动, 停止, 重启. 添加定时任务的功能没有加, 可以自行添加, 参考启动功能
ScheduledTaskConfig: 动态定时任务配置, 这是一个配置类, 配置ThreadPoolTaskScheduler线程池的, 还有就是初始化存放所有动态定时任务的map, 初始化map也就死创建一个map对象, 具体的初始化方法在下面的ScheduledTaskEnum枚举类中. 也可以在使用别的方式初始化, 这里有一个前提, 因为这个是配合数据库执行的, 每次重启项目都会将数据库中正常状态的定时任务取出来添加到执行map中 并执行, 所以要在别的地方初始化需要在这之前执行
ScheduledTaskJob: 动态定时任务的实体类, 包含了对应数据库的字段以及要执行的runnable
ScheduledTaskEnum: 动态定时任务枚举, 每一个要执行的定时任务都在这里添加一个枚举类型, 有两个属性, 第一个是定时任务的任务编码, 第二个就是定时任务的runnable, 还包括初始化存放所有动态定时任务的map, 放在这里是因为不需要动态添加定时任务, 放在这里可以在初始化map的时候设定map的容量, 如果需要动态添加定时任务则直接在ScheduledTaskConfig中初始化
ScheduledTaskRunner: 项目启动完毕后需要自启的任务, 主要就是用来执行初始化启动所有有效动态定时任务, 从数据库中获取有效的任务信息, 跟ScheduledTaskConfig中初始化的内容不一样, 这里是初始化执行所有的有效定时任务, 配置类中是初始化存放所有动态定时任务的map的
InsuranceTask: 具体的执行任务类, 这个是自定义的, 按照自己的需求创建类名, 成员属性, 定时任务要执行的方法等, 需要实现runnable接口, 成员属性无法直接注入, 需要将成员属性写成静态属性, 再使用set方法注入
提示: 代码中的ResultVO是一个统一返回对象, 包含code属性, msg属性和data属性, ResultVOUtil是统一返回对象的工具类, success是成功, code为0, msg为成功, 参数为data, error为失败, 需要自定义code和msg, 第一个参数是code, 第二个参数时msg
接下来是代码(未优化过, 功能已实现, 可以正常使用O(∩_∩)O):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73a6bd74251df901e56461000389a7a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e7aaeba4bd1405f2739b99cc6fe2763/" rel="bookmark">
			elasticsearch  ik分词器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.从github中下载IK分词器，一定要注意和ES的版本一致
https://github.com/medcl/elasticsearch-analysis-ik/releases
2 .下载之后放到 ES 的 \plugins 目录下面去 重启 ES 服务
1&gt;ik_max_word
2&gt;ik_smart
ik_max_word 和 ik_smart 什么区别?
ik_max_word: 会将文本做最细粒度的拆分，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,中华人民,中华,华人,人民共和国,人民,人,民,共和国,共和,和,国国,国歌”，会穷尽各种可能的组合，适合 Term Query；
ik_smart: 会做最粗粒度的拆分，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,国歌”，适合 Phrase 查询。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b96e4f1d9fabc96faded4ec289c64926/" rel="bookmark">
			Mysql锁详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01 | Mysql事物 1.1 ACID 1、 原子性（Atomicity） ：事务是一个原子操作单元，对数据的修改，要么全都执行，要么全都不执行。2、 一致性（Consistency） ：指的是事务开始之前和事务结束之后，数据库的完整性限制未被破坏。一致性包括两方面的内容，分别是约束一致性和数据一致性。3、 隔离性（Isolation） ：指的是一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并发事务是隔离的。4、持久性（Durability） ：指的是一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，后续的操作或故障不应该对其有任何影响，不会丢失。 1.2 MVCC（Multi Version Concurrency Control） MVCC：多版本并发控制，是指在数据库中为了实现高并发的数据访问，对数据进行多版本处理，并通过事务的可见性来保证事务能看到自己应该看到的数据版本。MVCC使用的是Copy on Write的思想，支持读读、读写、写读的并行处理。
实现原理 MVCC最大的好处是读不加锁，读写不冲突。在读多写少的系统应用中，读写不冲突是非常重要的，极大的提升系统的并发性能，这也是为什么现阶段几乎所有的关系型数据库都支持 MVCC 的原因，不过目前MVCC只在 Read Commited 和 Repeatable Read 两种隔离级别下工作。
在 MVCC 并发控制中，读操作可以分为两类: 快照读（Snapshot Read）与当前读 （Current Read）。
快照读：读取的是记录的快照版本（有可能是历史版本），不用加锁。（select）当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其他事务不会再并发修改这条记录。（select… for update 或lock in share mode，insert/delete/update） 1.3 事物隔离级别 事物隔离级别脏读不可重复读幻读读未提交可能发生可能发生可能发生读已提交X可能发生可能发生可重复读XX可能发生串行化XXX 读未提交（Read Uncommitted）：解决了回滚覆盖类型的更新丢失，但可能发生脏读现象，也就是可能读取到其他会话中未提交事务修改的数据。读已提交（Read Committed）（Oracle、SQLServer默认隔离级别） ：只能读取到其他会话中已经提交的数据，解决了脏读。但可能发生不可重复读现象，也就是可能在一个事务中两次查询结果不一致。
可重复度可重复读（Repeatable Read）（mysql默认隔离级别） ：解决了不可重复读，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上会出现幻读，简单的说幻读指的的当用户读取某一范围的数据行时，另一个事务又在该范围插入了新行，当用户在读取该范围的数据时会发现有新的幻影行。
可串行化串行化（Serializable）：所有的增删改查串行执行。它通过强制事务排序，解决相互冲突，从而解决
幻度的问题。这个级别可能导致大量的超时现象的和锁竞争，效率低下。 Mysql隔离级别控制 -- 查看当前隔离级别 show variables like 'tx_isolation'; -- 设置隔离级别 set tx_isolation='READ-UNCOMMITTED'; set tx_isolation='READ-COMMITTED'; set tx_isolation='REPEATABLE-READ'; set tx_isolation='SERIALIZABLE'; 02 | 锁机制 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b96e4f1d9fabc96faded4ec289c64926/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b828a1f334d3423417ea1afe97b28c/" rel="bookmark">
			【信息系统项目管理师】中高项历年真题汇总题目书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【信息系统项目管理师】中高项历年真题汇总题目书 系统集成项目工程师案例历年真题 No章节真题一真题二真题三真题四资源链接012014上系统集成配置合同进度计算https://blog.csdn.net/Last_Impression/article/details/106396202022015上系统集成变更合同人力计算https://blog.csdn.net/Last_Impression/article/details/106119283032015下系统集成变更合同收尾计算https://blog.csdn.net/Last_Impression/article/details/106100912042016上系统集成变更采购成本计算https://blog.csdn.net/Last_Impression/article/details/106100228052016下系统集成采购配置质量计算https://blog.csdn.net/Last_Impression/article/details/106079227062017上系统集成立项风险招标计算https://blog.csdn.net/Last_Impression/article/details/106060824072017下系统集成整体整体沟通计算https://blog.csdn.net/Last_Impression/article/details/106060552082018上系统集成整体风险人力计算https://blog.csdn.net/Last_Impression/article/details/106016960092018下系统集成整体采购质量计算https://blog.csdn.net/Last_Impression/article/details/105990076102019上系统集成质量采购风险计算https://blog.csdn.net/Last_Impression/article/details/105973027112019下系统集成整体人力安全计算https://blog.csdn.net/Last_Impression/article/details/105955809 信息系统项目管理师案例历年真题 No章节真题一真题二真题三资源链接012014上高项整体质量计算https://blog.csdn.net/Last_Impression/article/details/106419098022014下高项计算范围整体https://blog.csdn.net/Last_Impression/article/details/106455103032015上高项计算整体整体https://blog.csdn.net/Last_Impression/article/details/102800869042015下高项整体计算需求https://blog.csdn.net/Last_Impression/article/details/102807513052016上高项计算整体整体https://blog.csdn.net/Last_Impression/article/details/101904780062016下高项计算整体收尾https://blog.csdn.net/Last_Impression/article/details/102564627072017上高项质量计算需求https://blog.csdn.net/Last_Impression/article/details/102779085082017下高项变更计算人力https://blog.csdn.net/Last_Impression/article/details/89958765092018上高项质量计算人力https://blog.csdn.net/Last_Impression/article/details/89879208102018下高项范围计算组合https://blog.csdn.net/Last_Impression/article/details/106210119112019上高项采购计算人力https://blog.csdn.net/Last_Impression/article/details/106211788122019下高项质量计算人力https://blog.csdn.net/Last_Impression/article/details/106316865 信息系统项目管理师上午综合知识历年真题 No章节资源链接012016年上综合知识https://blog.csdn.net/Last_Impression/article/details/101904780022016年下综合知识https://blog.csdn.net/Last_Impression/article/details/102564627032017年上综合知识https://blog.csdn.net/Last_Impression/article/details/102779085042017年下综合知识https://blog.csdn.net/Last_Impression/article/details/89958765052018年上综合知识https://blog.csdn.net/Last_Impression/article/details/89879208062018年下综合知识https://blog.csdn.net/Last_Impression/article/details/106212305072019年上综合知识https://blog.csdn.net/Last_Impression/article/details/106272048082019年下综合知识https://blog.csdn.net/Last_Impression/article/details/106315004 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecd23b2b72c2431f7c205572b8d02a8e/" rel="bookmark">
			创建一个基于WebPacket的TypeScript项目【一】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建一个基于WebPacket的TypeScript项目 安装node.js环境建立目录结构在 `templates` 目录新建 `template.index.html`并写入 安装VSCode创建一个NPM项目确认 安装TypeScript创建一个TypeScript项目配置项目修改`package.json` 配置修改`devDependencies` 和 `dependencies`修改 `scripts`配置为 修改`tsconfig.json` 配置初始化 npm包`webpack.config.js`文件并写入 调试代码启动ChromeEnd 安装node.js环境 下载并安装Node.js
打开CMD输入 node -v 如出现如下图版本号则表示node安装成功
建立目录结构 新建文件夹 ts
在ts目录新建 src templates 目录
src 源码目录
templates html模板目录
在 templates 目录新建 template.index.html并写入 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Webpack Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 安装VSCode 下载并安装 VSCode
创建一个NPM项目 打开终端进入ts目录，我是用的git bash，你如果没装git的话可以用cmd。
输入 npm init 回车
package name 要创建的npm包名可以写你的项目名，如果你的代码想要发布成npm包的话就写成npm包名。 这里我们写myproject
version 当前npm包的版本，默认为1.0.0可以直接按回车跳过后续可修改。跳过
description npm包说明，可按回车跳过后续可修改 跳过
entry point npm的入口点通常填写main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecd23b2b72c2431f7c205572b8d02a8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8971cae5031fe78abf2b2800ad22ce33/" rel="bookmark">
			详解最小生成树——Prim&amp;Kruskal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 生成树是指在一个有个点的图中由n-1条边构成的子图并且每一个点都在这个子图中，其中总边权值最小的生成树就被称为最小生成树。
如图所示：
Prim Prim算法是通过扩展边来求最小生成树，其思路和Dijkstra非常相似，它从一个未被加入最小生成树的点开始，枚举所以从其出发的所有边，选出其中权值最小的一条边，将其加入最小生成树，将其到达的点加入最小生成树并将点标记，直到最小生成树里有n-1条边。如图所示，就是prim构造最小生成树的过程。
核心代码如下:
void prim(){ memset(dis,0x3f,sizeof(dis)); memset(vis,0,sizeof(vis)); dis[1]=0; for(int i=1;i&lt;n;i++){ int x=0; for(int j=1;j&lt;=n;j++){ if(!v[j]&amp;&amp;(x==0||dis[j]&lt;dis[x])){ x=j; } }//找相邻最小边权 vis[x]=1; for(int j=1;j&lt;=n;j++){ if(!v[j]){ dis[j]=min(dis[j],a[x][j]);//与当前最小权值进行比较 } } } } Kruskal Kruskal,以下简称K，是通过扩展点来构造最小生成树，需要并查集辅助。其基本思想是将所有边权值从小到大排一个序，这样先遍历的边就一定是剩下的边中最小的然后我们就尝试将此条边加入最小生成树，如果其父亲节点是同一个，那么如果选择此条边则在最小生成树中会构造出一个环，所以我们不能选择这条边，就跳过它。如此图，即是K算法的过程。
主要代码如下：
int get(int x){ if(fa[x]==x){ return fa[x]; } return fa[x]=get[fa[x]]; }//并查集 bool cmp(node a,node b){ return a.edge&lt;b.edge; }//结构体排序 ... sort(a+1,a+1+tot,cmp); for(int i=1;i&lt;=tot;i++){ int x=get(a[i].fro); int y=get(a[i].to);//求出这条边的两个端点的父亲节点 if(x!=y){//如果父亲节点不同 fa[x]=y;//合并这两个点 ans+=a[i].edge; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f143025718e9780e9b0910740186a03e/" rel="bookmark">
			Android屏幕手写签名的实现-详细篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		老规矩先看一下效果图
【实现思路】
（1）创建画笔
private void init(Context context) { this.mContext = context; //设置抗锯齿 mGesturePaint.setAntiAlias(true); //设置签名笔画样式 mGesturePaint.setStyle(Paint.Style.STROKE); //设置笔画宽度 mGesturePaint.setStrokeWidth(mPaintWidth); //设置签名颜色 mGesturePaint.setColor(mPenColor); } （2）创建一个画布 一个bitmap用来保存签名
@Override protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); //创建跟view一样大的bitmap，用来保存签名(在控件大小发生改变时调用。) cachebBitmap = Bitmap.createBitmap(getWidth(), getHeight(), Bitmap.Config.ARGB_8888); cacheCanvas = new Canvas(cachebBitmap); cacheCanvas.drawColor(mBackColor); } （3）重写onTouchEvent方法拿到绘制的点
@Override public boolean onTouchEvent(MotionEvent event) { switch (event.getAction()){ case MotionEvent.ACTION_DOWN: touchDown(event); break; case MotionEvent.ACTION_MOVE: touchMove(event); break; case MotionEvent.ACTION_UP: //将路径画到bitmap中，即一次笔画完成才去更新bitmap，而手势轨迹是实时显示在画板上的。 cacheCanvas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f143025718e9780e9b0910740186a03e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/808d469c04eff6fba6e4ca1dd2f8e2c5/" rel="bookmark">
			Grafana使用杂记（二）-- Grafana监控模板参数配置和告警
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 背景
2. 环境
3. 模板参数：
1. 背景 Grafana作为一个开源的度量分析和图表化展示工具，可以对接多种数据源，通过对采集到的数据处理后，进行可视化展示，还能设置告警条件进行不同方式的告警。在使用过程中，遇到一些限制的问题，记录在此以供其他需要的朋友们参考。在这篇文章中，使用Grafana对接数据源Prometheus，并设置监控告警条件进行邮件通知。
2. 环境 Grafana v6.3.0
Prometheus v2.12.0
node_exporter v0.18.1
3. 模板参数： 1.导入模板。这里在前一篇（Grafana使用杂记（一）-- 缺少图表插件）中已经介绍过了，这里不再赘述。模板下载地址：https://grafana.com/grafana/dashboards。
2.导入模板并经过一系列数据源的配置后，点击左侧导航栏Dashboards-&gt;Manage，选择并点击模板。
3.点击右上角的如下所示图标，在左侧导航栏点击 Variables，进入模板参数的配置页面。
4.Prometheus中的配置文件中，被监测节点(xxx3， xxx2)的job名称为node。
5.创建新的模板参数。这里设置的参数是期望能够过滤出Prometheus中健康的主节点和其他节点。
Name：模板参数名称。Label：模板中显示的名称。Type：Query。这里是为了查询。Data source：Prometheus。Refresh：刷新的方式是按照模板刷新进行刷新。Query：查询的条件： -- label_value：过滤条件。
-- up表示节点为启动状态的；反之是down
-- {job="node"}：这里的job和node都对应prometheus的yml配置文件中的参数。
-- Regex：正则表达式。这里过滤出来是IP的形式表示节点。
点击 Update 以后，满足条件的节点就被筛选出来。这里xxx3和xxx2为被监测节点，xxx8为Prometheus主节点。
6.回到监控的模板中，可以看到在参数一栏，多出来上面添加的参数 Test。这里是一个下拉列表的展示方式，选项即前面过滤出来的节点。
7.设置告警条件
1）在Dashboard中选择 Query 类型。
2）配置Query条件：
Metrics：度量条件。这里是为了监控节点是否正常，采用prometheus中的up方法。健康的vm返回1，不健康为0或-1。Legend：这里设置变量最终影响到图表上线条所代表值的显示。 注意：Grafana的告警条件中不能带变量，只能是常量。即，不能在告警的Query条件中，使用${}这样的变量引用方式。
8.告警的阈值和通知条件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70ceb2252ac5bd544c24acced93af4c8/" rel="bookmark">
			tf.sparse.SparseTensor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为什么用tf.sparse.SparseTensor的原因 节约内存 在表达一个稀疏矩阵时候，不用一个很大的矩阵 tf.sparse.SparseTensor( indices, values, dense_shape ) indices ：非零值的元素的索引
values ：非零值
dense_shape ：shape
import tensorflow as tf sp_input=tf.sparse.SparseTensor(indices=[[0, 0], [1, 2]], values=[1, 3], dense_shape=[3, 4]) tf.sparse.to_dense( sp_input, default_value=None, validate_indices=True, name=None ) &lt;tf.Tensor: shape=(3, 4), dtype=int32, numpy= array([[1, 0, 0, 0], [0, 0, 3, 0], [0, 0, 0, 0]], dtype=int32)&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e24b043f31c79cefc09f57c1e223be0/" rel="bookmark">
			java之文件写入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请分别使用FileOutputStream、FileWrite、BufferedWrite三种方法实现写入文件功能。
1. FileOutputStream
Java流使用的基本思路为：1.构造流对象 2.打开流 3.关闭流 流对象中传输的只能是字节 byte[ ] 其他类型的变量都只能转化为字节
public static void Out_1() { try{ // 建立文件流，文件路径需要添加\\ 进行转义符 文件流输出直接进行覆盖 FileOutputStream fout = new FileOutputStream("D:\\test\\thank you.txt"); // 只能将字符串修改为byte数组才可以进行字节流的传输 String s = "I'M OKAY!"; byte[] bytes = s.getBytes(); fout.write(bytes); fout.close(); }catch(Exception e) { e.printStackTrace(); } } 2. FileWriter
可以直接传字符串
public static void Out_2() { try{ FileWriter fw = new FileWriter("D:\\test\\thank you.txt"); String s = "I'm LeiJun"; // 不是字节流，用String 进行传输 fw.write(s); fw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e24b043f31c79cefc09f57c1e223be0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16a4d3cdb9eb386ba5b65e286fe8e7e3/" rel="bookmark">
			android R(11) app targetSdkVersion30遇到的那些坑之——相册选择图片黑屏现象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：
当开发版本targetSdkVersion提升到30时：
在android10手机上安装app后，调用相册选择图片时，相册会出现图片全部都是黑屏现象，选择后的图片也是黑屏图片，而且无法获取图片的小大；在android10以下的手机安装app，可以正常选择图片； 解决：
把targetSdkVersion降到28，在android10手机上则可以正常选择相册的图片。
目前（2020.08.03）没有找到targetSdkVersion30的适配方法，如有大神有解决方法，望请告知，不甚感激。
备注：
当项目targetSdkVersion为28时，在android10手机安装了app；然后将项目targetSdkVersion升级到30，再在android10手机覆盖安装此app，则相册是可以正常选择图片的。当项目targetSdkVersion直接为30，Android10手机之前并未在targetSdkVersion低版本安装过此app，直接在targetSdkVersion30第一次安装此app，则调用相册会出现黑屏现象。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/482d707d37aa72345f9afd7c9c3d9b97/" rel="bookmark">
			跨越速运工作三年，亲身经历告诉你在跨越的工作体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于员工而言，企业就像人生中的一个舞台，舞台有多大，你发展的机会就有多大，而对企业来说，每位员工都是舞台的支柱，支撑着舞台稳健运行，只有支柱维护好了，企业才会获得更好的发展。因此好的企业都是能够做到企业和员工相互成就的。本人作为一名在跨越速运工作三年的员工，今天就和大家谈谈这三年来的工作体验，希望能够帮到一些朋友更好的了解跨越速运。
在入职跨越速运之前，我也在两家公司上过班，从个人的感受来说，我认为跨越速运是最懂得“照顾”员工的企业。在跨越速运企业与员工相互依存，就像大家与小家的关系一样，员工在企业中能够感受到家的温暖、感受到托付和依靠，不仅能够获得物质和精神上的满足，同时也能与企业共同成长。
记得当初刚入职跨越速运的时候，因为自己是第一次进入这么大的公司，曾经非常担心自己没法快速适应跨越的工作，在试用期被淘汰。然而当天下午我就发现自己多虑了，公司给我安排了一名“导师”一对一的带着我融入到工作当中,帮助我熟悉公司业务，悉心讲解所有工作流程。这让我很快就安心了下来，并顺利的通过了试用期。我觉得这个制度对于新员工来说是非常棒的，尤其是对于初入职场的应届毕业生来说，这种“以老带新”的工作机制，不仅可以让他们早早地融入公司，更能缓解他们对于职场的不安。
度过试用期成为正式员工之后，紧张又充实的工作算是正是开始了，这时对于我们这些职场人来说，最重要的就是快速提高工作技能，因为这关系到自己之后的发展和收入。为了能让我们每一位员工都能快速提高技术水平和业务能力。公司专门成立了线下培训中心，目前全网拥有专职讲师139人，兼职讲师54人。不仅如此，因为公司人员地区分布不一，为了让每一位员工都能学到知识，跨越速运还依托内部ERP、跨声APP搭建学习平台，让每个人均可以在办公的同时进行业务模块培训学习，边学边操作，做到真正学以致用。而且我们每年还会举行好几次培训竞赛，确保我们能够随时保持学习，提升自己。
经过三年来在跨越速运努力的工作，现在我已经确定了自己的发展方向，我打算带领自己的团队，成为一个合格的管理者。公司对于我的个人发展方向也很支持，总是提供各种机会锻炼我的综合能力。这在我们公司内部叫做管理通道晋升体系，是拉伸职位层级，鼓励员工提高岗位工作能力和管理水平，以竞争方式追求更高层职位，努力成为岗位能手、行业专家。除此之外，你也可以选择走专业通道晋升体系，专业通道明晰各类员工职业发展路径，鼓励员工结合自身实际进行职业规划，在个人能力上做出更为充分的准备。这种知人善任的双通道晋升机制，可以满足每一位对自己有要求，追求上进的朋友的发展。
以上就是我在跨越速运工作三年来的一些体验，并诚挚的向大家推荐跨越速运，如果你想找一家特别重视员工培养的公司，想在物流领域里大展拳脚，跨越速运绝对是你的好选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5018b119ff78fdf874b9c69229f46311/" rel="bookmark">
			java字符串中拼接参数；两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般写法：
固定地址，后面拼接参数 String url = "https://open.weixin.qq.com/" +"connect/qrconnect?appid="+ ConstantWxUtils.WX_OPEN_APP_ID+"&amp;response_type=code"; 用String format方法+占位符 //%s相当于?代表占位符 String baseUrl = "https://open.weixin.qq.com/connect/qrconnect" + "?appid=%s" + "&amp;redirect_uri=%s" + "&amp;response_type=code" + "&amp;scope=snsapi_login" + "&amp;state=%s" + "#wechat_redirect"; String url = String.format( baseUrl, ConstantWxUtils.WX_OPEN_APP_ID, ConstantWxUtils.WX_OPEN_REDIRECT_URL, "acloud" ); 方法1在开发中参数过多会容易出错还不利于维护。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a095da7433da4f1762b8fc413bc334c3/" rel="bookmark">
			移位运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原码的移位:
原码算术移位:左移丢1,运算会出错,右移丢1,会影响精度
补码,反码的移位:
对于正数来说原码,补码,反码都补0.
对于负数来说原码和补码的最后一位相等,所以如果是在地位的话,和原码相同
如果是在高位的话,补码和反码相同补1
所以有上图中的右移的话和反码相同补1,左移的话和原码相同补0.
循环移位
循环移位:将移出来的位放置高位或者地位,目的是为了改变高位与地位的位置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb3fe48ce3be2cc2ae84e334fdad3025/" rel="bookmark">
			openstack - horizon - 14.1.0  安装 部署 源码 开发 测试 环境 centos7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、系统环境 CentOS Linux release 7.8.2003 (Core) Python 2.7.5 pip 20.2 from /usr/lib/python2.7/site-packages/pip (python 2.7) Python3 3.5.9 pip3 -V pip 20.2 from /usr/local/python3/lib/python3.5/site-packages/pip (python 3.5) git version 1.8.3.1 [root@localhost ~]# tox --version 3.18.0 imported from /usr/lib/python2.7/site-packages/tox/__init__.pyc horizon 14.1.0 (rocky) 二、下载源码、查看 1、下载 git clone https://git.openstack.org/openstack/horizon -b stable/rocky --depth=1 2、查看 cd horizon
tox -l #查看horizon项目需要的环境列表
[root@localhost horizon]# tox -l pep8 py27 py35 py3-dj111 releasenotes npm 三、安装依赖包 因horizon项目需要安装的依赖包较多，国内的朋友强烈建议使用国内pip源
mkdir ~/.pip vim ~/.pip/pip.conf [global] index-url = https://pypi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb3fe48ce3be2cc2ae84e334fdad3025/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a917ed19c0b94c3bd95a585d49530edf/" rel="bookmark">
			ngrok免费内网穿透（外网映射）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地发布的接口，想外网访问？
微信公众号代码本地调试？
来试试ngrok
官网地址：
https://www.ngrok.cc/login
注册后登录
开通隧道 隧道管理&gt;开通隧道
最后面一个价格¥0.00的是免费的
点击立即购买
添加成功后，进入隧道里面页面
3. 下载客户端，启动
选择对应版本（window 64位）
解压，运行
输入隧道id
点击回车键即可启动：
外网通过访问ngrok生成的域名，即可访问到本地地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85a6cf66bd38ba809ec9a79920056f7/" rel="bookmark">
			Oracle数据库的导入导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Oracle数据库的导出
使用命令符“Windows+R”--&gt;输入"cmd":
输入“exp”（导出的缩写），按下回车：
输入数据库的用户名及地址，例如：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7021a5559d71cdeaca3335714f2ace3/" rel="bookmark">
			leetcode_126_127_单词接龙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 127.单词接龙描述解题 126.单词接龙II描述解题 127.单词接龙 描述 中等
给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：
每次转换只能改变一个字母。
转换过程中的中间单词必须是字典中的单词。
说明:
如果不存在这样的转换序列，返回 0。
所有单词具有相同的长度。
所有单词只由小写字母组成。
字典中不存在重复的单词。
你可以假设 beginWord 和 endWord 是非空的，且二者不相同。
示例 1:
输入: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"] 输出: 5 解释: 一个最短转换序列是 "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog", 返回它的长度 5。 示例 2:
输入: beginWord = "hit" endWord = "cog" wordList = ["hot","dot","dog","lot","log"] 输出: 0 解释: endWord "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7021a5559d71cdeaca3335714f2ace3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94247fc837836907eb882a4cf4ee19df/" rel="bookmark">
			下载的一个war包项目，使用tomcat打开运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把项目war包放到的tomcat文件夹webapps文件夹下
修改conf文件夹下的server.xml文件，找到host，加一句话** 其中主要是path 是指url的上下文，smbu是指文件war的路径名称
修改连接数据库的用户名和密码，打开conf文件夹下的tomcat-users.xml文件，在tomcat-user标签中添加一句****其中username为设置的用户名，password为设置的密码。
4.只要本地数据库中导入需要的数据库信息，找到tomcat下的bin文件夹下的startup.bat,双击运行即可，在浏览器中搜索http://localhost:8080/SMBU。(其中8080为端口号，SMBU为war包名）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0046927288f013156ba698d12950773e/" rel="bookmark">
			Kotlin协程(Coroutine)的使用以及源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于了解协程（微线程，Coroutine），其实很早就有协程的概念，在Lua,Python,go语言中较为常见Android在kotlin拓展库kotlinx.coroutines去提供使用。
首先讲起进程和线程 进程拥有切换和打开的进程表，文件资源、数据资源、独立的内存空间。
线程从属于进程，是程序的实际执行者，一个进程至少包含一个主线程，也可以有更多的子线程，线程拥有自己的栈空间。
线程具有五种状态：初始化、可运行、运行中、阻塞、销毁。
协程 协程不同与进程或线程是比线程更加轻量级的存在，一个进程可以拥有多个线程，一个线程可以拥有多个协程，协程有自己控制的上下文。
进程和线程都是由是操作系统的调度切换策略去执行，而协程的切换时机则是用户自己的程序所决定的。
协程是不需要多线程的锁机制，减少资源消耗。
协程提升CPU利用率，减少线程切换，提升程序运行效率。
总结协程：可控制 轻量级 语法糖。 常用API runBlocking //启动执行协程任务
launch //执行协程任务
//启动参数
当前协程上下文，可声明切换调度器模式 context: CoroutineContext = EmptyCoroutineContext可自定义启动方式 start: CoroutineStart = CoroutineStart.DEFAULT,闭包形式的协程函数 block: suspend CoroutineScope.() -&gt; T asyns/await //执行协程任务/得到返回结果
协程工厂函数 val scope = MainScope()
scope.async(Dispatchers.Default) {}
scope.launch {}
scope.cancel()
withContext withContext(Dispatchers.Default){}
Dispatchers提供四种不同属性提供不同的线程支持和操作Default Main Unconfined IO
反编译源码分析 runBlocking fun main() = runBlocking { listCoroutineScope() } //反编译源码 public final List&lt;Font&gt; main() { return (List) BuildersKt__BuildersKt.runBlocking$default((CoroutineContext) null, new FontService$main$1((Continuation) null), 1, (Object) null); } // FontService$main$1 @Metadata(bv = {1, 0, 3}, d1 = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0046927288f013156ba698d12950773e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3613402ffeff64ed51cbe7b4d4c6a238/" rel="bookmark">
			vue线性渐变_Vue线性进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue线性渐变
k进度 (k-progress) A Vue plugin, linear progress bar.
Vue插件，线性进度条。 View Demo 查看演示 View Github 查看Github 📦安装 (📦 Install) npm install -S k-progress # or yarn add k-progress 🔨开始开始 (🔨 Begin Start) // main.js import KProgress from 'k-progress'; Vue.component('k-progress', KProgress); s属性 (📔 Attributes) AttributeTypeDefaultOptionalexplainpercentNumber00-100Percent (Required)line-heightNumber6Progress bar heighttypeStringlineline / lumpProgress bar typestatusStringsuccess / warning / errorProgress bar statuscolorString / Array / FunctionProgress bar color; When using Array, the limit is 6; When using Function, the argument is percentcolor-flowBooleanfalseWhether to enable color flowflow-secondNumber51-6The time required for the flow, that is, the smaller the time, the faster the speedbg-colorString#ebeef5Color codeProgress bar background colorborderBooleantrueWhether arcshow-textBooleantrueWhether to show progress bar textformatFunctionCustom text display, parameter is percentcut-widthNumber1lump widthcut-colorString#ebeef5Color codelump coloractiveBooleanfalseWhether to enable dynamic effectsactive-colorStringDynamic effect color 属性 类型 默认 可选的 说明 百分 数 0 0-100 百分比(必填) 行高 数 6 进度条高度 类型 串 line line / lump 进度条类型 状态 串 success / warning / error 进度栏状态 颜色 字符串/数组/函数 进度条颜色； 使用Array ，限制为6； 使用Function ，参数为percent 色流 布尔型 false 是否启用色彩流 流量秒 数 5 1-6 流程所需的时间，即时间越短，速度越快 背景色 串 #ebeef5 色标 进度栏背景色 边境 布尔型 true 是否圆弧 显示文字 布尔型 true 是否显示进度条文字 格式 功能 自定义文本显示，参数为percent 裁切宽度 数 1个 lump宽 切色 串 #ebeef5 色标 lump色 活性 布尔型 false 是否启用动态效果 活性色 串 动态效果色 翻译自: https://vuejsexamples.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3613402ffeff64ed51cbe7b4d4c6a238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/219e84812c9fb5128c42ea1b9338af5d/" rel="bookmark">
			做个vue.js清单应用_vue.js的待办事项清单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做个vue.js清单应用
待办事项清单 (Todo list) Todo list with vue.js + Babel + Sass + ESLint+ Element UI.
使用vue.js + Babel + Sass + ESLint + Element UI的待办事项列表。 Установкапроекта (Установка проекта) yarn install Запуск (Запуск) yarn run serve Собрать (Собрать) yarn run build Тестирование (Тестирование) yarn run test Дляисправления (Для исправления) yarn run lint 翻译自: https://vuejsexamples.com/a-todo-list-with-vue-js/
做个vue.js清单应用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfbe7788c64ae13c0d90b1cdd67d03e8/" rel="bookmark">
			qt如何添加组件ros_ros3djs的Vue组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qt如何添加组件ros
vue-ros3djs (vue-ros3djs) Vue components for ros3djs with some extra functionality:
ros3djs的 Vue组件具有一些额外的功能： Get pose of right click / long press
右键单击/长按姿势 tween.js integration for smooth transitions
tween.js集成可实现平稳过渡 安装 (Install) npm install --save vue-ros3djs 组件 (Components) Includes the following components:
包括以下组件： Ros3dArrow
Ros3d箭头 Ros3dAxes
Ros3dAxes Ros3dGrid
Ros3dGrid Ros3dInteractiveMarkerClient
Ros3dInteractiveMarkerClient Ros3dLaserScan
Ros3dLaserScan Ros3dMarkerClient
Ros3dMarkerClient Ros3dOccupancyGridClient
Ros3dOccupancyGridClient Ros3dPath
Ros3dPath Ros3dPointCloud2
Ros3dPointCloud2 Ros3dPoseArrow
Ros3dPoseArrow Ros3dSceneNode
Ros3dSceneNode Ros3dViewer
Ros3dViewer 用法 (Usage) &lt;template&gt; &lt;ros3d-viewer :ros="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfbe7788c64ae13c0d90b1cdd67d03e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98230c53db8e2f90b7e866b51ec99eba/" rel="bookmark">
			算法—快速幂运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速幂以及扩展的矩阵快速幂应用场景比较常见。
幂运算a的n次方，即n个a相乘，快速幂就是高效的算出结果。当n很大时，很多时候都不能处理，一是数字太大，二是计算时间太长。因此对于这种问题便产生了快速幂的运算。
具体思路： 假设要求a的11次方，先把a的11次方分解为a的八次方，a的二次方，a的零次方的积。
再接下来，a1 * a1 = a2,a2 * a2 = a4,a4 * a4 = a8，都是2的倍数，产生的ai都是倍乘关系，逐渐递推就可以了。
那么在如何将11分为8+2+1的问题上，使用数字的二进制即可。将11转为二进制，二进制中每一位的权值都是低一位的两倍，对应的ai就是倍乘的关系，11的二进制为1011 = 1 * 23 + 0 * 22 + 1 * 21 + 1 * 20 ，所以只需要将n用二进制处理就可以了。
再回想其中的0的跳过计算，在这里可以使用位运算即可实现。
n &amp; 1，取n的最后一位，判断是否需要跳过n &gt;&gt; 1，把n右移一位，将刚处理过的最后一位去掉 在实现了上面的步骤下快速幂的具体思路已经构建完了，直接放代码即可：
int quickpow(int n, int a) { int base = n; int res = a; while (n) { if (n &amp; 1) res *= base; base *= base; n &gt;&gt;= 1; } return res; } 如果产生的数据仍然太大，则可以使用取模运算，在res * base 和 base * base 的时候进行取模运算即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98230c53db8e2f90b7e866b51ec99eba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0f4ed13bc9a66e6f9f621b64e1c7e62/" rel="bookmark">
			DB2导入数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.登录服务器 首先使用db2用户登录到需要导库的服务器，通常用户名和密码为db2inst1/db2inst1
2.导出数据库 cd到导出目录，如bak创建db2move文件夹: mkdir db2movecd db2move连接数据库：db2 connect to CREDITDB CREDITDB是你的数据库名称，连接时需要修改成自己的导出数据库数据：db2move CREDITDB export CREDITDB是你的数据库名称，连接时需要修改成自己的返回上层结构：cd ..导出表结构：db2look -d edstest -u UUUU -e -o db2look.ddl edstest表示数据库名,UUUU表示用户名 如果第7步执行失败，可以尝试这个命令，含@分隔符：db2look -d edstest -u db2inst2 -td @ -e -o db2look.ddl 3.导入数据库 你先将导出的数据库文件上传到你需要导入库的服务器上面
cd到数据库文件目录，如bak；该文件下面有：db2look.ddl、db2move文件夹
创建数据库：
db2 CREATE DATABASE QS_TEST USING CODESET GBK TERRITORY CN COLLATE USING SYSTEM PAGESIZE 32 k -- QS_TEST 是你的数据库名称 -- GBK是数据库编码 连接到刚才创建的数据库：db2 connect to QS_TEST 记得修改数据库名称
修改db2lokk.ddl中数据库和用户：
我们导出的数据库文件中包含两个文件db2look.ddl、db2move，现在你需要去检查db2look.ddl中的数据db2look.ddl文件的开头你可以看到这样的语句CONNECT TO QS_TEST，这里的QS_TEST需要和你刚才创建的库名相同，如果不同，则需要修改为刚才你所创建的库名接着进入到db2move目录下，查看db2move.lst文件中的!"db2inst1"."USER"!tab3.ixf!tab3.msg!的db2inst1和db2look.ddl文件中的SCHEMA是否一样（db2look.ddl文件开头中有CREATE SCHEMA “db2inst1”;） 修改好db2look.ddl后我们现在开始导入表结构：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0f4ed13bc9a66e6f9f621b64e1c7e62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb4d9d8f02bd8c34153d99b8172343a/" rel="bookmark">
			php 命令行调试方法  php配合phpstrom 给php脚本进行额外传参后 触发断点调试配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
之前已经讲了phpstorm的远程调试，基于swoole的本地调试和远程调试，想了解，请看我之前的博客；
补充：（这个说错了， 我是将swoole远程调试教程放到了资源里面）
https://download.csdn.net/download/wangsenling/12675591 swoole远程调试最新版，弥补实战windows和linux同步文件夹开发和远程调试流程截图明细
https://download.csdn.net/download/wangsenling/11064318 phpstorm远程调试，避开网上各种乱起八糟误导人的操作
不知道大家有没有明白phpstorm本身就是一个调试用服务器，开启了9000端口后，如果有任何一个php 的xdebug环境，将调试信息发送给当前配置的phpstorm，并且告诉这个phpstorm正确的代码路径maping映射，phpstorm都可以给你断点到具体的位置。
当xdebug将调试信息发送过来时，实际上，执行脚本其实已经跑完了，发送过来的信息是整个脚本执行的所有调试信息，是phpstorm以断点的形式帮你延迟映射而已，目的就是为了让你清楚地知道整个脚本执行的过程。
php 脚本额外传参执行调试：以yii框架的yii php脚本为例，其他启动脚本都如此
纯命令执行调试脚本
php -dxdebug.remote_enable=1 -dxdebug.remote_mode=req -dxdebug.remote_port=9000 -dxdebug.remote_host=127.0.0.1 -dxdebug.remote_autostart=1 yii back-up/generate all
补充：
remote_autostart=1
默认状态下，触发调试需要在url中增加get参数：XDEBUG_SESSION_START= {xdebug.idekey}，如果想自动启动调试，即不加这个参数也能自动触发调试，可以将这个值设为1，所以推荐将这个值设为1；
图解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44032175852ca6e03e577b7302164a29/" rel="bookmark">
			OBS视频数据输出流程（模块加载，编码，推流）详细说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、视频输出初始化
程序运行时,初始化OBS,视频相关的初始化是再mainWindow中进行的
OBSApp::OBSInit() -&gt; mainWindow-&gt;OBSInit()
InitBasicConfig()读取appdata目录下配置文件中Video相关的参数,没有设置的参数使用接口
InitBasicConfigDefaults()接口中加载的默认参数
OBSBasic::RetsetVideo(),重置视频设置
obs_video_info ovi;获取视频设置的参数,包括：帧率,颜色格式,YUV颜色空间,YUV颜色范围,背景及
输出分辨率等
调用 AttemptToResetVideo() -&gt; obs_reset_video(),将当前参数尝试重置给Video
停止当前的video,使用新参数ovi重新初始化video,obs_init_video(ovi)
obs_init_video(struct obs_video_info *ovi)
通过make_video_info函数,将ovi参数设置给video_out_info vi;
调用video_output_open函数启动视频数据输出线程
int video_output_open(video_t **video, struct video_output_info *info)
创建video_output *out对象,拷贝info中的数据到out-&gt;info,设置out-&gt;frame_time每一帧的时间差
启动线程函数 video_thread,并将out作为参数传入
初始化out-&gt;cache,调用video_frame_init将cache中每一帧的内容按照视频格式初始化
完成后,将out对象赋值给obs-&gt;video-&gt;video
其中线程执行函数video_thread就是视频输出线程,等待信号量video-&gt;update_semaphore 被唤醒
执行video_output_cur_frame函数,获取视频缓存中第一帧,从video-&gt;inputs中获取输出类型
调用编码器绑定的回调函数input-&gt;callback,receive_video(),进行视频数据编码.
而video-&gt;update_semaphore 信号量是在所有画面合成完成后被唤醒,后面将介绍是如何唤醒的
video-&gt;inputs中保存的是输出类型,包括推流和录像,后面将会说到是如何添加的
启动画面合成线程函数 obs_graphics_thread(),后面单独介绍画面合成线程的流程
至此视频输出的初始化完成,输出线程和画面合成线程已启动
2、obs-x264、obs-qsv11、obs-ffmpeg、rtmp模块加载
obs-x264是软编,obs-qsv11是intel硬编,obs-ffmpeg中包含ffmpeg_aac、ffmpeg_opus、以及nvenc编码
rtmp是推流模块
在OBSInit()函数初始化视频后,将执行加载模块的操作,这里将介绍obs-x264模块是怎么加载并且被调用的,
其他几个模块的加载是类似的；
OBSInit() -&gt; AddExtraModulePaths(),添加加载模块的路径 -&gt; obs_load_all_modules()加载所有模块
void obs_load_all_modules(void)
obs_find_modules()遍历所有模块目录,load_all_callback是对找到的模块执行的回调函数,
find_modules_in_path()在每个目录中查找dll文件,并执行函数process_found_module() -&gt; 执行回调
也就是load_all_callback函数
load_all_callback() -&gt; obs_open_module() -&gt; os_dlopen()获取打开模块的句柄,接着执行的
load_module_exports函数获取模块中的接口地址绑定给obs_module各个函数指针,obs-x264模块只有
一个接口地址obs_module_load,被绑定至mod-&gt;load；将模块的一些信息填充,包括模块的名称,路径等
执行obs_init_module(module),该函数的作用就是为了调用刚才绑定的module-&gt;load()接口,也就是
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44032175852ca6e03e577b7302164a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3abb6d4d64ecc7f145b9c9cef88b38bb/" rel="bookmark">
			wget 递归下载大部分网站目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入 你有听错吗？你以为我是一个标题党吗？没有听错，我也不是标题党，方法很简单，只需要一个叫做wget的小软件（Linux、Windows可以用，MAC没用过）就可以做到了。
准备工作 先说Windows系统用户怎么获取该软件：
1、在这里下载Wget（如果英语不好请上百度搜索下载）
注意：在第3方下载站千万不能点击高速下载选项，不然看到许多流氓软件和广告，哭的是自己
2、将下载下来的wget文件复制到C:\Windows文件夹（C是系统盘符，视情况而定，一般会提示需要管理员权限，点击“继续”并在弹出的UAC窗口点击“是”即可）
3、运行命令提示符，输入命令wget，如果出现提示就代表步骤完成！
Linux系统（没用过Centos系统，所以该系统安装程序命令yum不知道怎么用，这里以Deepin为例）：
sudo apt install wget 输入以上命令即可安装
返回的结果：
gfdgd_xi@gfdgd-xi-PC:~$ sudo apt install wget [sudo] password for gfdgd_xi: Reading package lists... Done Building dependency tree Reading state information... Done The following packages were automatically installed and are no longer required: cabextract python-wxgtk3.0 python-wxversion Use 'sudo apt autoremove' to remove them. The following NEW packages will be installed: wget 0 upgraded, 1 newly installed, 0 to remove and 0 not upgraded.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3abb6d4d64ecc7f145b9c9cef88b38bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b19d6b1aba736b0ce0888ab5dbde5ebf/" rel="bookmark">
			SPEL：spring表达式语言，可以调用方法（#{}）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 字面量：${}；#{}
&lt;bean id = "person" class="com.guigu.bean.Person" &gt; &lt;property name="age" value="#{3*8}"&gt;&lt;/property&gt; &lt;/bean&gt; 引用bean的某个属性值
&lt;bean id = "person01" class="com.guigu.bean.Person" &gt; &lt;property name="lastname" value="#{car.carName}"&gt;&lt;/property&gt; &lt;/bean&gt; 调用非静态方法和静态方法: 先调用静态方法： UUID.randomUUID().toString（）注意大小写，特别是后面的substring， s不是大写。#{T（全类名）.静态方法名} &lt;!-- 调用静态方法 UUID.randomUUID().toString --&gt; &lt;bean id = "person02" class="com.guigu.bean.Person" &gt; &lt;property name="email" value ="#{T(java.util.UUID).randomUUID().toString().substring(0,5)}"&gt;&lt;/property&gt; &lt;/bean&gt; 查找权限定名的步骤：
ctrl + shirt + t :输入需要查找的对象，然后点击
调用静态方法；对象.方法名
&lt;property name="gender" value="#{car.getColor()}"&gt;&lt;/property&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e02558506030c6575e945dfc7e06e95/" rel="bookmark">
			tf.argsort
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 tf 的排序，返回对应值的排名 import tensorflow as tf a = [1, 10, 26.9, 2.8, 166.32, 62.3] b = tf.argsort(a,axis=-1,direction='ASCENDING',stable=False,name=None) c = tf.keras.backend.eval(b) # Here, c = [0 3 1 2 5 4] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4acc868f4d0bbf8be6e80ff93185b18a/" rel="bookmark">
			SpringBoot使用@Async注解失效分析（@Transactional事务注解失效分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候在使用的过程中@Async注解会失效（原因和@Transactional注解有时候会失效的原因一样）。
下面定义一个Service：
两个异步执行的方法test03()和test02()用来模拟项目中可能出现的耗时的操作，然后test()方法调用这两个耗时的方法：
定义Controller：
执行方法，返回结果：
方法执行结果明显与我们的预期不符，方法的输出顺序表示了test02()和test03()两个异步方法居然同步执行了，也就是说@Aysnc注解失效了！
失效的原因是因为我们是在test()方法中直接调用的test02()和test03()方法，相当于是this.test02()和this.test03()调用的，也就是说真正调用test02()和test03()方法的是TestService对象本身调用的，而@Async和@Transactional注解本质使用的是动态代理，真正应该是TestService的代理对象调用test02()和test03()方法。其实Spring容器在初始化的时候Spring容器会将含有AOP注解的类对象“替换”为代理对象（简单这么理解），那么注解失效的原因就很明显了，就是因为调用方法的是对象本身而不是代理对象，因为没有经过Spring容器，那么解决方法也会沿着这个思路来解决。
网上有不少博客说解决方法就是将要异步执行的方法单独抽取成一个类，这样的确可以解决异步注解失效的问题，原理就是当你把执行异步的方法单独抽取成一个类的时候，这个类肯定是被Spring管理的，其他Spring组件需要调用的时候肯定会注入进去，这时候实际上注入进去的就是代理类了，其实还有其他的解决方法，并不一定非要单独抽取成一个类。
解决方式一：在TestService中通过上下文获取自己的代理对象调用异步方法
其实我们的注入对象都是从Spring容器中给当前Spring组件进行成员变量的赋值，由于TestService使用了AOP注解，那么实际上TestService在Spring容器中实际存在的是它的代理对象。
工具类可以参考我的另一篇博客：https://blog.csdn.net/Dongguabai/article/details/80788646
我使用的此种方法，不过我是直接注入的ApplicationContext，以下是我的伪代码
public class MdController{
@Autowired
private ApplicationContext applicationContext;
@Transactional
public Object pub(){
MDSearchService mDSearchService =applicationContext.getBean(MDSearchService);
md.update();
}
}
@Service
public class MDSearchService {
@Async
public void update();
}
aop切面配置时也是有事务必须用applicationaContext取bean去处理，如果切点的事务回滚了，切面也就不执行了
执行结果，异步方法异步执行了：
解决方式二：开启cglib代理，手动获取Spring代理类 在启动类上加上：
使用AopContext.currentProxy()获取当前代理类：
这里为了证明Spring容器中的对象就是当前代理类对象特地输出了一句话：
运行结果：
OK，问题完美解决！OK，问题完美解决！
OK，问题完美解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0123ea898a85143a5ffdccb22e1969ae/" rel="bookmark">
			vector.size()返回值问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刷80. 删除排序数组中的重复项 II时，所写代码如下：
class Solution { public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { for (int i = 0; i &lt; nums.size()-1; i++) { if (nums[i] == nums[i + 1]) { while (i + 2 &lt; nums.size() &amp;&amp; nums[i] == nums[i + 2]) nums.erase(nums.begin() + i + 2); i = i + 1;//循环体还要再执行一次++ } } return nums.size(); } }; 却发现不能处理输入为空数组的问题，感觉很奇怪。最后查了下vector.size()的返回值是
std::vector::size size_type size() const noexcept; 该返回值类型是 size_type ，也就是容器中 typedef 之后的 size_t，而 size_t 的类型是：unsigned int。因此，空数组输入后nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0123ea898a85143a5ffdccb22e1969ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9ac55dd33fb04a7037028e88333e88d/" rel="bookmark">
			高斯模糊(高斯滤波)原理以及计算过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高斯模糊/高斯滤波 通常，图像处理软件会提供模糊滤镜，使图片产生模糊效果。
模糊的算法有很多，其中有一种叫高斯模糊(Gaussian Blur)，它将正态分布用于图像处理。
文本介绍了高斯模糊的算法，你会看到这是一个非常简单易懂的算法。本质上，它是一种数据平滑技术(data smoothing)，适用于多个场合，图像处理恰好提供了一个直观的应用实例。
高斯模糊的原理 所谓模糊，可以理解成每一个像素都取周边像素的平均值。
上图中，2是中间点，周边点都是1.
中间点取周围点的平均值之后，就会从2变成了1.在数值上，这是一种平滑化。在图形上，就相当于产生模糊的效果，中间点失去了细节。
显然计算平均值时，取值范围越大，模糊效果越强烈。
上面分别是原图、模糊半径3像素，模糊半径10像素的效果。模糊半径越大，图像就越模糊。从数值角度来看，就是数值越平滑。
接下来的问题是，既然每个点都要取周边像素的平均值，那么该如何分配权重呢？
如果使用简单平均，显然是不合理的，因为图像都是连续的，越靠近的点关系越密切，越远离的点关系就越疏远。因此，加权平均更合理，距离越近的点，权重就越大，距离越远的点，权重就越小。
正态分布的权重 正态分布显然是一种可取的权重分配模式。
在图形上，正态分布是一种钟形曲线，越接近中心，取值越大，越远离中心，取值越小。
计算平均值的时候，我们只需要将中心点作为原点，其他点按照其在正态曲线上的位置，分配权重就可以得到一个加权平均值。
高斯函数 上面的正态分布是一维的，但是图像都是二维的，因此我们需要二维的正态分布。
正态分布的密度函数叫做高斯函数，下面是一维高斯函数的公式：
G ( x ) = 1 2 π σ e − ( x − μ ) 2 2 σ 2 G(x)=\frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{(x-\mu)^{2}}{2\sigma^{2}}} G(x)=2π ​σ1​e−2σ2(x−μ)2​
其中， μ \mu μ 是x的均值，σ是x的方差。因为计算平均值的时候，中心店是原点，因此均值等于0。
G ( x ) = 1 2 π σ e − x 2 2 σ 2 G(x)=\frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{x^{2}}{2\sigma^{2}}} G(x)=2π ​σ1​e−2σ2x2​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9ac55dd33fb04a7037028e88333e88d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/111f5975f1bf3ad88e16277bd88a3697/" rel="bookmark">
			jvm最全详解-06-JVM调优实战及常量池详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jvm最全详解-06-JVM调优实战及常量池详解
阿里巴巴Arthas详解
Arthas 是 Alibaba 在 2018 年 9 月开源的 Java 诊断工具。支持 JDK6+， 采用命令行交互模式，可以方便的定位和诊断线上程序运行问题。Arthas 官方文档十分详细，详见：https://alibaba.github.io/arthas
Arthas使用
# github下载arthas wget https://alibaba.github.io/arthas/arthas-boot.jar # 或者 Gitee 下载 wget https://arthas.gitee.io/arthas-boot.jar 用java -jar运行即可，可以识别机器上所有Java进程(我们这里之前已经运行了一个Arthas测试程序，代码见下方)
package com.tuling.jvm; import java.util.HashSet; public class Arthas { private static HashSet hashSet = new HashSet(); public static void main(String[] args) { // 模拟 CPU 过高 cpuHigh(); // 模拟线程死锁 deadThread(); // 不断的向 hashSet 集合增加数据 addHashSetThread(); } /** * 不断的向 hashSet 集合添加数据 */ public static void addHashSetThread() { // 初始化常量 new Thread(() -&gt; { int count = 0; while (true) { try { hashSet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/111f5975f1bf3ad88e16277bd88a3697/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/955f18a3dc5865e735dee12a7692ec1d/" rel="bookmark">
			《数学基础》-4.凸优化-4.1.无约束优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.1.无约束优化 4.1.1.无约束优化问题 无约束优化问题是机器学习中最普遍、最简单的优化问题。
求最大值也可以 在前面加上负号，变成上面求最小的形式。
求一个函数f(x)的最小值可以对函数f(x)求导并使其等于0(或者说使得梯度▽f(x)等于0)，但是很多复杂的函数求导后没法求出解，所以这种方法实际上很少用。
常用梯度下降法、牛顿法或者拟牛顿法求解。
4.1.2.梯度下降法 基于迭代的方法，从某个点开始找很多点，使得这些点满足：，且有，这里表示单位梯度，经常写作，λ表示步长，所以通项是：
实际上λ也不会取很大，一般是
其过程为：
梯度下降法的种类：
①批量梯度下降法（BGD）
更新系数时，所有样本都参与计算
优点：需要个很少的迭代次数就可以收敛
缺点：当样本量很大时，更新一次的时间很长
②随机梯度下降法（SGD）
更新系数时，从n个样本中随机选择一个样本参与计算，
优点：更新一次的时间很短，所以大样本时有优势
缺点：会受到每一个样本的影响会很大，不稳定，需要更多的迭代次数才能收敛
③小批量梯度下降法（MBGD）
结合了批量梯度下降法和随机梯度下降法，选择一小部分样本参与计算
例如：
所有的样本都算完，就是一个epoch
4.1.3.牛顿法 求一个函数的最小值可以对函数求导并使其等于0(或者说使得梯度等于0)：，把函数的导数看做一个函数，令
牛顿法求的过程也是迭代过程
假设的函数曲线是这个样子，要找到那个的点，先做某个的切线，然后找到切线与x轴相交的点然后再做的切线，以此类推，不断逼近的点。
先来求第一条切线的方程：
令y=0（就是上图中的点）得：
再把带入得：
这是二维的情况，如果是多维的情况：
其中H是海森矩阵，除以海森矩阵就是乘以它的逆矩阵。
为什么这里是海森矩阵？因为是的n维向量，是n维向量，二次求导就是海森矩阵。
在机器学习中，要算海森矩阵的逆矩阵很麻烦，于是就引申出了很多种拟牛顿法BFGS（用另外一个矩阵来逼近海森矩阵的逆矩阵）。
牛顿法收敛速度：
按这个迭代原理，就应该是函数的局部最优点，也就是有最小值，且有要弄明白这个收敛速度，就是要比较下到的距离和到的距离的区别，由上述结论得：
由于，所以分子加上得：
根据中值定理f(b)−f(a)=(b−a)f′(ξ),a&lt;ξ&lt;b，得：
再利用拉格朗日中值定理得：
ξ是在之间的，所以
由于M的分子分母都是导数，导数都是有界的，所以M是有界的，用表示其上界。
即：
当和的距离小于1：，则，这里是按照平方的速度进行收敛的，收敛速度更快，注意这里有条件：x和的距离小于1，如果距离大于1，上界会越来越大，没法收敛。
综上，牛顿法要拟合，不能离最小值太远的地方拟合，越接近极小值再拟合收敛的效果越好。因此可以先用梯度下降，到了局部极小值附近后再用牛顿法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54aaadfb6086d867cb304eafe494846d/" rel="bookmark">
			Docker 与 kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 创建kafka 容器 命令及常用属性 （模版）
docker run -d --name kafka --privileged=true -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=192.168.1.114:2181/kafka -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.1.114:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -v /etc/localtime:/etc/localtime wurstmeister/kafka
单机版只需修改192.168.1.114 就好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca5b2af8d7b8df87269b1b1bddbb6ac5/" rel="bookmark">
			Mysql索引详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引可以极大的提升Mysql的数据检索速度，类似于书籍的目录，可以根据目录的章节标题快速定位到书中的内容。但索引在提高查询速度的同时需要额外的存储成本和维护成本，会降低对表更新操作的速率。
01 | 索引类型 1.1 普通索引 最基本的索引类型，基于普通字段建立的索引，没有任何限制。
1.2 唯一索引 在普通索引的基础上，要求字段值必须唯一，但允许NULL值
1.3 主键索引 特殊的唯一索引，不允许NULL值且一个表只能有一个主键
1.4 复合索引（组合索引） 在多个列上建立索引称为符合索引。复合索引可以代替多个单一索引，相比多个单一索引复合索引所需的开销更小。
1.5 全文索引 应用于大量的文本检索，速度优于like模糊查询
基本语法 # 方法一：创建表时 CREATE TABLE 表名 ( 字段名1 数据类型 [完整性约束条件…], 字段名2 数据类型 [完整性约束条件…], [UNIQUE | FULLTEXT | SPATIAL ] INDEX | KEY [索引名] (字段名[(长度)] [ASC |DESC]) ); # 方法二：CREATE在已存在的表上创建索引 CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 ON 表名 (字段名[(长度)] [ASC |DESC]) ; # 方法三：ALTER TABLE在已存在的表上创建索引 ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 (字段名[(长度)] [ASC |DESC]) ; # 删除索引：DROP INDEX 索引名 ON 表名字; 02 | 索引原理 索引是存储引擎用于快速查找记录的一种数据结果，是物理数据页存储，在数据文件中，利用数据页存储；索引可以加快检索速度，同时也会降低增删改操作速度，需要额外的维护代价。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca5b2af8d7b8df87269b1b1bddbb6ac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7fd6cb67bb9b81c6daa3674f96f58cf/" rel="bookmark">
			JavaScript实例学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript实例学习笔记 JavaScript控制表单遍历表单访问表单元素动态修改表单控件的值获取表单文本框数量修改表单的提交方式动态设置/获取焦点控件初始化表单所有控件复选框全选、取消及判断是否选中简单的数字及字符操作高亮焦点控件动态添加、删除下拉菜单 JavaScript控制DOM遍历网页元素的全部属性动态创建网页新文本段落动态删除网页文本段落动态替换段落文本内容主动触发按钮单击事件动态修改元素属性值获取下拉列表的选项 按钮特效添加背景颜色不同按钮提交到不同的表单地址禁用回车键提交表单按钮单击后自动失效为删除功能按钮添加确认提醒根据状态显示不同样式按钮按钮倒计时阅读完协议才可单击的按钮 链接特效带下划线的链接改变链接的click事件关闭窗口用链接模拟一个按钮用链接替代表单提交按钮动态修改一个链接的地址让所有链接在新窗口打开让页面所有超链接失效为链接地址新增一个参数返回页面顶部的链接需要确认的超链接 图片特效图片比例缩放图片放大镜特效图片在层里居中图片自适应框的大小为图片加上边框显示局部图片延迟加载图片动态加载图片重新加载验证码图片 文本框和下拉列表特效只带下划线的文本框用正则表达式验证email格式首字母或全部字母大写只能输入数字的文本框判断字符的个数校验电话号码格式鼠标划过文本框改变其背景色设置下拉列表框的值动态添加下拉列表框选项动态删除下拉列表框选项二级联动下拉列表框 日期和时间特效在标题栏显示当前日期根据时间动态显示标题欢迎词根据月份动态显示背景判断今天是否为节假日每秒刷新的时间展示效果时间计时器时间倒计时器计算时间差计算日期间隔网页标题体现月进度显示网页登录时间 网页特效打开新页面打开指定大小的窗口获取打开子窗口的父窗口父子窗口之间数据交互刷新当前页面屏蔽鼠标右键屏蔽上下文菜单屏蔽复制功能屏蔽选择操作防止网页被“frame”隐藏页面滚动条最小化最大化和关闭窗口脚本永不出错获取浏览器信息获取浏览器窗口尺寸屏蔽键盘功能键定时关闭页面修改浏览器标题 Ajax应用Ajax解析文本Ajax解析XMLAjax解析JSON JavaScript控制表单 遍历表单 表单name.elements 返回一个包含表单对象的集合通过console.log方式输出到控制台 访问表单元素 document.getElementsByName() 返回一个包含所有符合该名称的集合 document.getElementById() 根据id获取表单对象 动态修改表单控件的值 文本框、按钮 获取对象后 .value = “” 下拉框 获取对象后 .options.length可以获得到下拉框选项的数量获取对象后 .options[i].innerText = “” 修改选项文字 获取表单文本框数量 document.getElementsByTagName(“input”)
返回一个集合，通过 .length可以获取对象数量
获取所有input标签对象
el.type
以字符串形式获得对象的type属性 修改表单的提交方式 先通过 var dom = document.formname 获取表单DOM
var method = dom.selectname.value 获取下拉框的值
令 dom.method = method 即可修改表单的提交方式
dom.submit() 提交表单
动态设置/获取焦点控件 获取对象后调用 .focus() 方法即可设置焦点控件
document.activeElement.id中保存在焦点控件的id
初始化表单所有控件 初始化下拉框选项：获取下拉框对象后 .selectedIndex = 0;
初始化日期
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7fd6cb67bb9b81c6daa3674f96f58cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/094c327145ef9c9ed4db7edc30f94795/" rel="bookmark">
			【C&#43;&#43;】日期格式化（PTA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述
世界上不同国家有不同的写日期的习惯。比如美国人习惯写成“月-日-年”，而中国人习惯写成“年-月-日”。下面请你写个程序，自动把读入的美国格式的日期改写成中国习惯的日期。
输入格式：
输入在一行中按照“mm-dd-yyyy”的格式给出月、日、年。题目保证给出的日期是1900年元旦至今合法的日期。
输出格式：
在一行中按照“yyyy-mm-dd”的格式给出年、月、日。
输入样例：
03-15-2017 输出样例：
2017-03-15 代码
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main(){ string a; getline(cin,a); cout&lt;&lt;a.substr(6,9)&lt;&lt;"-"&lt;&lt;a.substr(0,5); } 自从知道了substr可以分割字符串之后，这道题就变得非常简单了。哈哈哈 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add934cc0c4f68513d105858ae779797/" rel="bookmark">
			main flag redefined: graceful
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		beego项目新增一个api的校验功能结果运行导致panic
/var/folders/3p/jc3w8_dn5dd0r5_5ccp3nrqm0000gn/T/go-build935260114/b001/exe/main flag redefined: graceful panic: /var/folders/3p/jc3w8_dn5dd0r5_5ccp3nrqm0000gn/T/go-build935260114/b001/exe/main flag redefined: graceful goroutine 1 [running]: flag.(*FlagSet).Var(0xc0000862a0, 0x18aaa20, 0x1d40069, 0x17b06d5, 0x8, 0x17c3eac, 0x21) /usr/local/Cellar/go/1.13.8/libexec/src/flag/flag.go:848 +0x4ae flag.BoolVar(...) /usr/local/Cellar/go/1.13.8/libexec/src/flag/flag.go:627 github.com/astaxie/beego/grace.init.0() /Users/dxm/Documents/code/gopath/src/github.com/astaxie/beego/grace/grace.go:93 +0x7a exit status 2 /usr/local/Cellar/go/1.13.8/libexec/src/flag/flag.go:848 +0x4ae
定位到panic的代码
panic的原因是 graceful这个flag被定义了两遍，全局搜索定义此变量的代码位置，果然找到了两处，
来自不同目录下的两个相同的外部包，均在项目中被引用，所以导致了panic
相同的外部包一个从vendor中导入一个从$GOPATH 导入的具体原因是：
公共类的包A同时存在在$GOPATH下的B包下和Vendor下的C包下，B和C均在项目中被引用，
由于以下原因导致了panic：
包导入时首先从vendor中导入然后再看$GOPATH C中所依赖的所有外部包的导入路径均会继承C的路径，B同理C在vendor中不存在 解决方法
将C拷贝到vendor下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae5b8519566855b9de9ff7500d9e4dc/" rel="bookmark">
			多行标注样式的sld
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标注样式为：
以上样式实现代码为：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;StyledLayerDescriptor xmlns="http://www.opengis.net/sld" version="1.1.0" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:se="http://www.opengis.net/se" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd" xmlns:ogc="http://www.opengis.net/ogc"&gt; &lt;NamedLayer&gt; &lt;se:Name&gt;gis_inner_702872535642697728&lt;/se:Name&gt; &lt;UserStyle&gt; &lt;se:Name&gt;gis_inner_702872535642697728&lt;/se:Name&gt; &lt;se:FeatureTypeStyle&gt; &lt;se:Rule&gt; &lt;se:Name&gt;&lt;/se:Name&gt; &lt;se:PolygonSymbolizer&gt; &lt;se:Stroke&gt; &lt;se:SvgParameter name="stroke"&gt;#232323&lt;/se:SvgParameter&gt; &lt;se:SvgParameter name="stroke-width"&gt;1&lt;/se:SvgParameter&gt; &lt;se:SvgParameter name="stroke-linejoin"&gt;bevel&lt;/se:SvgParameter&gt; &lt;/se:Stroke&gt; &lt;/se:PolygonSymbolizer&gt; &lt;/se:Rule&gt; &lt;se:Rule&gt; &lt;se:TextSymbolizer&gt; &lt;se:Label&gt; &lt;!--截取字段部分字符串作为标注--&gt; &lt;ogc:Function name="strSubstring"&gt; &lt;ogc:PropertyName&gt;ID&lt;/ogc:PropertyName&gt; &lt;ogc:Literal&gt;0&lt;/ogc:Literal&gt; &lt;ogc:Literal&gt;5&lt;/ogc:Literal&gt; &lt;/ogc:Function&gt;&lt;![CDATA[ ]]&gt;&lt;ogc:Literal&gt;─────&lt;/ogc:Literal&gt; &lt;ogc:Literal&gt;&lt;![CDATA[ ]]&gt;&lt;/ogc:Literal&gt; &lt;ogc:PropertyName&gt;CODE&lt;/ogc:PropertyName&gt; &lt;ogc:Literal&gt;&lt;![CDATA[ ]]&gt;&lt;/ogc:Literal&gt; &lt;ogc:PropertyName&gt;NAME&lt;/ogc:PropertyName&gt; &lt;/se:Label&gt; &lt;se:Font&gt; &lt;se:SvgParameter name="font-family"&gt;SimSun&lt;/se:SvgParameter&gt; &lt;se:SvgParameter name="font-size"&gt;12&lt;/se:SvgParameter&gt; &lt;se:SvgParameter name="font-style"&gt;normal&lt;/se:SvgParameter&gt; &lt;se:SvgParameter name="font-weight"&gt;bold&lt;/se:SvgParameter&gt; &lt;/se:Font&gt; &lt;se:LabelPlacement&gt; &lt;se:PointPlacement&gt; &lt;se:AnchorPoint&gt; &lt;se:AnchorPointX&gt;0.5&lt;/se:AnchorPointX&gt; &lt;se:AnchorPointY&gt;0.5&lt;/se:AnchorPointY&gt; &lt;/se:AnchorPoint&gt; &lt;se:Displacement&gt; &lt;se:DisplacementX&gt;1.0&lt;/se:DisplacementX&gt; &lt;se:DisplacementY&gt;7.0&lt;/se:DisplacementY&gt; &lt;/se:Displacement&gt; &lt;/se:PointPlacement&gt; &lt;/se:LabelPlacement&gt; &lt;se:Fill&gt; &lt;se:SvgParameter name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eae5b8519566855b9de9ff7500d9e4dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/144db79e0afb138b81ca58cefe7805ae/" rel="bookmark">
			Pytorch学习-训练模型的3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pytorch通常需要用户编写自定义训练循环，训练循环的代码风格因人而异。
有3类典型的训练循环代码风格：脚本形式训练循环，函数形式训练循环，类形式训练循环。
下面以minist数据集的分类模型的训练为例，演示这3种训练模型的风格。
准备数据 import torch from torch import nn from torchkeras import summary,Model import torchvision from torchvision import transforms transform = transforms.Compose([transforms.ToTensor()]) ds_train = torchvision.datasets.MNIST(root="./data/minist/",train=True,download=True,transform=transform) ds_valid = torchvision.datasets.MNIST(root="./data/minist/",train=False,download=True,transform=transform) dl_train = torch.utils.data.DataLoader(ds_train, batch_size=128, shuffle=True, num_workers=4) dl_valid = torch.utils.data.DataLoader(ds_valid, batch_size=128, shuffle=False, num_workers=4) print(len(ds_train)) print(len(ds_valid)) 输出：
60000 10000 显示部分数据：
%matplotlib inline %config InlineBackend.figure_format = 'svg' #查看部分样本 from matplotlib import pyplot as plt plt.figure(figsize=(8,8)) for i in range(9): img,label = ds_train[i] img = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/144db79e0afb138b81ca58cefe7805ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4497144ddeda1b8f24b10246b8f860d8/" rel="bookmark">
			SpringBoot 项目代码修改后，设置自动编译，不用重新运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 刚接触springboot项目时，修改一点代码保存后(我用的是eclipse)，必须要重新运行启动类进行重新编译，很麻烦，这里介绍一下将项目设置成 修改代码后自动编译，不用重新运行。
很简单，只需要在maven的pom.xml文件中添加相关的依赖，如下：
代码如下：
&lt;!-- 加入以下依赖，代码做了修改，不用重新运行 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;version&gt;1.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f87f1b7d839e87d6aefff37a173a3c3/" rel="bookmark">
			2021届秋招笔试题目记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串并转换：valid有效输入数据，串并转换结束后，输出4位数据和valid信号；
1、串并转换主程序：
module serial2parrel (
input clk,
input rst_n,
input data_in,
input valid_in,
output reg[3:0] data_out,
output reg valid_out
);
always@(posedge clk or negedge rst_n )
begin
if(!rst_n)
begin
data_out &lt;= 4'd0;
end
else begin
if(valid_in==1'b1)
begin
data_out &lt;= {data_out[2:0],data_in};
end else
begin
data_out &lt;= data_out;
end
end
end
reg [2:0] cnt;
always@(posedge clk or negedge rst_n)
begin
if(!rst_n)
begin
cnt &lt;= 3'd0;
end
else
begin
if(valid_in==1'b1)
begin
if(cnt == 3'd3)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f87f1b7d839e87d6aefff37a173a3c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/278c343fae05f07cce774f33507edb73/" rel="bookmark">
			基于Redis和RabbitMQ简单实现秒杀回顾
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 使用springboot + druid + redis + rabbitmq实现简单的秒杀系统，大致思路如下：
①、启动服务，缓存预热，将需要被秒杀的商品加载进redis缓存中，使用redis简单的string数据类型，key为商品ID，value为商品数量；②、登录之后，选择可以秒杀的商品，可选操作有加入购物车和立即抢购；③、点击抢购之后首先根据所选的商品ID查询redis，看是否商品数量小于等于0，如果是，则直接返回商品已售罄，否则将请求加入rabbitmq队列；④、入队之后进行发送端发送确认，消息不管是否投递到交换机都进行ConfirmCallback回调，如果消息可以投递到交换机就返回true，投递不到交换机就返回false，之后交换机匹配到队列成功则不进行ReturnCallback回调；⑤、之后消费者消费时进行手动确认，并再次查询redis的数量，预减之后看数量是否小于0，如果是就返回，否则就生成订单，并减少数据库的商品数量。 1、具体实现 ①、生产者
请求到达后台，先查询redis的对应商品数量是否为0，若不为零，则将请求加入rabbitmq队列，队列生产者实现了RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnCallback两个接口用于发送端确认，从写了下面两个方法：
@Override public void confirm(CorrelationData correlationData, boolean b, String s) { System.out.println("消息ID：" + correlationData.getId()); if (b) { logger.info("消息发送确认成功"); } else { logger.info("消息发送确认失败:" + s); } } @Override public void returnedMessage(Message message, int i, String s, String s1, String s2) { try { logger.info("return--message:" + new String(message.getBody(), "UTF-8") + ",replyCode:" + i + ",replyText:" + s + ",exchange:" + s1 + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/278c343fae05f07cce774f33507edb73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a983b68e85f93f819a86a8ca55d6c365/" rel="bookmark">
			RK1808 uboot的编译分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 为了更深入了解rk1808 sdk，对其中关于uboot部分的脚本和makefile等做一个分析
主要参考文件：Rockchip_Developer_Guide_Linux_Software_CN.pdf
uboot的编译 根据文档的说法，编译uboot有两种方法
在uboot目录下编译 这种方法，先cd到uboot目录下，然后执行
sudo ./make.sh rk1808 在顶层目录下编译 这种方法，利用底层目录的build.sh，传递参数uboot进行编译
sudo ./build.sh uboot 其实利用build.sh脚本，实际上也是cd到uboot目录下，去调用make.sh脚本进行编译，因此这两种方式其实可以认为是一种，那要想弄清楚来龙去脉，就得先分析build.sh脚本
build.sh分析 直接跳到末尾，有这样一段话，首先判断是不是需要打印usage，如果不是，然后再对输入的参数，也就是$@进行遍历，并判断它是什么
例如我这样输入sudo ./build.sh uboot，在下面的case分支语句中，就会进入eval build_$option || usage，这个意思是||前能执行，就去执行，不能执行，就打印usage
#========================= # build targets #========================= if echo $@|grep -wqE "help|-h"; then usage exit 0 fi OPTIONS="$@" for option in ${OPTIONS:-allsave}; do echo "processing option: $option" case $option in BoardConfig*.mk) option=$TOP_DIR/device/rockchip/$RK_TARGET_PRODUCT/$option ;&amp; *.mk) CONF=$(realpath $option) echo "switching to board: $CONF" if [ ! -f $CONF ]; then echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a983b68e85f93f819a86a8ca55d6c365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0274e373a2ca44dae230bbad89f36e3/" rel="bookmark">
			第十二章 Logstash入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念介绍 Logstash是一个类似实时流水线的开源数据传输引擎，它像一个两头连接不 同数据源的数据传输管道，将数据实时地从一个数据源传输到另一个数据源中。在数据传输的过程中，Logstash还可以对数据进行清洗、加工和整理，使数据在 到达目的地时直接可用或接近可用，为更复杂的数据分析、处理以及可视化做准备。
既然需要将数据搬运到指定的地点，为什么不在数据产生时就将数据写到需要的地方呢?这个问题可以从以下几个方面理解。首先，许多数据在产生时并不支持直接写入到除本地文件以外的其他数据源。比如大多数第三方软件在运行中产生的日志，都以文本形式写到本地文件中。其次，在分布式环境下许多数据都分散在不同容器甚至不同机器上，而在处理这些数据时往往需要将数据收集到一起统一处理。 最后，即使软件支持将数据写入到指定的地点，但随着人们对数据理解的深人和新技术的诞生又会有新的数据分析需求出现，总会有一些接入需来是原生软件无法满足的。综上，Logstash的核心价值就在于它将业务系统与数摆处现系统隔离开来，屏蔽了各自系统变化对彼此的影响，使系统之间的依赖降低并可独自进化发展。
Logstash可以从多个数据源提取数据，然后再清洗过滤并发送到指定的目标 数据源。目标数据源也可以是多个，而且只要修改Logstash管道配置就可以轻松扩展数据的源头和目标。这在实际应用中非常有价值，尤其是在提取或发送的数据源发生变更时更为明显。比如原来只将数据提取到Elasticsearch中做检索，但 现在需要将它们同时传给Spark做实时分析。如果事先没有使用Logstash就必须设计新代码向Spark发送数据，而如果预先使用了Logstash则只需要在管道配置中添加新的输出配置。这极大增强了数据传输的灵活性。
Logstash负责日志收集和转发，支持日志过滤，支持普通log、自定义json格式的日志解析。
1、部署规划 计划在三台CentOS7机器上部署ELK，其中一台机器作为ELK的服务节点，IP为192.168.0.101；另外两台作为客户节点，IP为192.168.0.102/103。其中服务节点部署Elasticsearch、Logstash和Kibana三个组件，客户节点部署Logstash，Nginx等。
2、服务节点部署 2.1、环境准备 默认root用户下操作，其他用户请自觉添加sudo。
1）安装JDK，省略
2）关闭防火墙，关闭selinux
systemctl stop firewalld
systemctl disable firewalld
或者设置防火墙规则：
firewall-cmd --add-port=9200/tcp --permanent
firewall-cmd --add-port=9300/tcp --permanent
firewall-cmd --add-port=5601/tcp --permanent
firewall-cmd --reload
2.2、添加ELK仓库 Add the following in your `/etc/yum.repos.d/` directory in a file with a `.repo` suffix, for example `logstash.repo`
cat &lt;&lt;EOF | tee /etc/yum.repos.d/elasticsearch.repo
[elasticsearch-7.x]
name=Elasticsearch repository for 7.x packages
baseurl=https://artifacts.elastic.co/packages/7.x/yum
gpgcheck=1
gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch
enabled=1
autorefresh=1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0274e373a2ca44dae230bbad89f36e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d74870592ea4e7bc191f81d06d6a30b/" rel="bookmark">
			tkinter-listbox详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍Listbox控件。
Listbox控件的显示主体就是一个选项列表(items list)，每个item一行。当创建一个Listbox控件对象时，该对象没有选项(item)。item可以支持两种方法创建。item可以被删除。一个或多个item可以被选中，然后做相应的事情。还是那个套路，结合实例介绍一下常用的属性和方法。
文章目录 Listboxbgbdfgcursorlistvariableselectmodeindex(index)insert(index, *elements)delete(first, last=None)get(first, last=None)curselection()selection_set(first, last=None)size()itemconfigure(index, cnf=None, **kw)selectforegroundselectbackgroundselectborderwidthactivestylexscrollcommandyscrollcommandbind(sequence=None, func=None, add=None) Listbox class Listbox(Widget, XView, YView)看到这个类的继承关系，就知道可以使用scrollbar。
Listbox(master=None, cnf={}, **kw) master还是指父窗口对象
bg 设置背景颜色
bd 设置边框宽度
fg 设置前景色(文字颜色)
cursor 设置光标显示样式
listvariable 如果你阅读过本系列文章的checkbutton或radiobutton，你将很容易的理解这个属性的作用。listvariable的值是一个StringVar变量，该变量的值是一个列表或元组，用来作为listbox的item。
selectmode selectmode决定了item怎样被选择的问题？是选一个呢还是选多个？要怎么实现这个"选"？
browse - 默认值。只能选一个选项，即使你按住鼠标拖动，也是选择最后鼠标停留的那个选项
extended - 通过按住鼠标拖动，选择多个选项
singe - 也是只能选择一个选项且只支持鼠标单击，鼠标按住并拖动无效，这也是与browse有差异的地方,但是我并没有感觉这个属性有啥用
multiple - 选择多个选项且支持鼠标单击，鼠标按住并拖动无效
我们来看个简单的例子
from tkinter import Tk,Listbox,StringVar main_win = Tk() main_win.title('渔道的listbox控件') width = 300 height = 300 main_win.geometry(f'{width}x{height}') items = ('apple', 'orange', 'pear', 'grape') strvar_items = StringVar(value=items) Listbox(main_win, bg='yellow', bd=10, cursor='cross', listvariable=strvar_items, selectmode='multiple').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d74870592ea4e7bc191f81d06d6a30b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f1f4a4d837b5fdef94c4dd4db987a37/" rel="bookmark">
			基于深度学习的文本分类的准备工作：在Win10下安装fasttext
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本次基于深度学习的文本分类问题中，有一个第三包fasttext需要提前安装好。
电脑配置：
win10 64位
Anaconda3
IDE：pycharm
1、pip安装（可以参考我自己总结的小白教程）
pip install fasttext 我用这个方法报错了
error：Microsoft Visual C++ 14.0 is required. Get it with “Microsoft Visual C++ Build Tools”
2、源码安装（网上说的，我还不会）
git clone https://github.com/facebookresearch/fastText.git
cd fastText
sudo pip install .
本次用的方法是：.whl文件在python库的安装 第一步：下载fasttext的 .whl文件（我是下载链接） 下载哪一个版本的whl.文件需要核查两件事。第一件，自己电脑的位数，32位或者64位。第二件，查看当前Python版本匹配那些文件，选择cp38、cp37、cp36还是其他，具体如何查看请参考该博主Lukea11的博文。
选择对的版本的whl.文件是必要的，否则会报错，例如，
fasttext-0.9.2-cp38-cp38m-win_amd64.whl is not a supported wheel on this platform 第二步：对应版本的 .whl文件放在哪？将文件复制到pip.exe安装的位置 一般是在C:\Users\THINKPAD\anaconda3\Scripts目录下
第三步：pip install + .whl文件安装名 C:\Users\THINKPAD&gt;cd C:\Users\THINKPAD\anaconda3\Scripts C:\Users\THINKPAD\anaconda3\Scripts&gt;pip install fasttext-0.9.2-cp37-cp37m-win_amd64.whl Processing c:\users\thinkpad\anaconda3\scripts\fasttext-0.9.2-cp37-cp37m-win_amd64.whl Requirement already satisfied: setuptools&gt;=0.7.0 in c:\users\thinkpad\anaconda3\lib\site-packages (from fasttext==0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f1f4a4d837b5fdef94c4dd4db987a37/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/358/">«</a>
	<span class="pagination__item pagination__item--current">359/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/360/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>