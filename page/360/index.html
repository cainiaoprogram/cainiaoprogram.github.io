<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b385418f81d0a1cb12a56a8144fc258/" rel="bookmark">
			Kafka对PageCache的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		page cache &amp; buffer cache 执行free命令，注意到会有两列名为buffers和cached，也有一行名为“-/+ buffers/cache”。
~ free -m total used free shared buffers cached Mem: 128956 96440 32515 0 5368 39900 -/+ buffers/cache: 51172 77784 Swap: 16002 0 16001 其中，cached列表示当前的页缓存（page cache）占用量，buffers列表示当前的块缓存（buffer cache）占用量。用一句话来解释：page cache用于缓存文件的页数据，buffer cache用于缓存块设备（如磁盘）的块数据。页是逻辑上的概念，因此page cache是与文件系统同级的；块是物理上的概念，因此buffer cache是与块设备驱动程序同级的。
page cache与buffer cache的共同目的都是加速数据I/O：写数据时首先写到缓存，将写入的页标记为dirty，然后向外部存储flush，也就是缓存写机制中的write-back（另一种是write-through，Linux未采用）；读数据时首先读取缓存，如果未命中，再去外部存储读取，并且将读取来的数据也加入缓存。操作系统总是积极地将所有空闲内存都用作page cache和buffer cache，当内存不够用时也会用LRU等算法淘汰缓存页。
在Linux 2.4版本的内核之前，page cache与buffer cache是完全分离的。但是，块设备大多是磁盘，磁盘上的数据又大多通过文件系统来组织，这种设计导致很多数据被缓存了两次，浪费内存。所以在2.4版本内核之后，两块缓存近似融合在了一起：如果一个文件的页加载到了page cache，那么同时buffer cache只需要维护块指向页的指针就可以了。只有那些没有文件表示的块，或者绕过了文件系统直接操作（如dd命令）的块，才会真正放到buffer cache里。因此，我们现在提起page cache，基本上都同时指page cache和buffer cache两者，本文之后也不再区分，直接统称为page cache。
下图近似地示出32-bit Linux系统中可能的一种page cache结构，其中block size大小为1KB，page size大小为4KB。
page cache中的每个文件都是一棵基数树（radix tree，本质上是多叉搜索树），树的每个节点都是一个页。根据文件内的偏移量就可以快速定位到所在的页，如下图所示。关于基数树的原理可以参见英文维基，这里就不细说了。
接下来就可以把Kafka扯进来了。
Kafka对page cache的利用 Kafka为什么不自己管理缓存，而非要用page cache？原因有如下三点：
JVM中一切皆对象，数据的对象存储会带来所谓object overhead，浪费空间；如果由JVM来管理缓存，会受到GC的影响，并且过大的堆也会拖累GC的效率，降低吞吐量；一旦程序崩溃，自己管理的缓存数据会全部丢失。 Kafka三大件（broker、producer、consumer）与page cache的关系可以用下面的简图来表示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b385418f81d0a1cb12a56a8144fc258/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fc717b6c3a0e8b8ef03af9b0c61e611/" rel="bookmark">
			TDD范文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Test Driven Development
Controller测试
package io.github.talelin.latticy.controller.cms; import cn.hutool.core.date.DateUtil; import io.github.talelin.latticy.mapper.LogMapper; import io.github.talelin.latticy.model.LogDO; import lombok.extern.slf4j.Slf4j; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.http.MediaType; import org.springframework.test.annotation.Rollback; import org.springframework.test.context.ActiveProfiles; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.result.MockMvcResultMatchers; import org.springframework.transaction.annotation.Transactional; import java.util.Date; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; @RunWith(SpringRunner.class) @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @Transactional // 数据操作后回滚 @Rollback @AutoConfigureMockMvc @Slf4j @ActiveProfiles("test") public class LogControllerTest { @Autowired private MockMvc mvc; @Autowired private LogMapper logMapper; @Before public void setUp() throws Exception { Date time = new Date(); String permission = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fc717b6c3a0e8b8ef03af9b0c61e611/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a6595c209832d8fd1e7d8440c4243db/" rel="bookmark">
			virtual camera
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		敲下标题的这一刻，内心还是有点儿小激动的。毕竟虚拟摄像头，也做了几个星期了，硬生生的在android原生系统不支持的情况下，绕过重重限制，完美的实现了这一功能。接下来几天，终于可以睡个好觉了。
好了，闲话少说，我们先来分析下虚拟摄像头。一说到虚拟摄像头，大家印象里，肯定首先想到的是这么一个情景：某个猥琐男在网上正兴致勃勃的撩妹，看着视频里美女漂亮的容颜，不仅春心大动，口水流了一地。而实际上，在网络的另一端，和这猥琐男聊天视频的，根本就不是视频里的美女，而是一位一边抠着脚一边抽着烟的大汉。呃，那么问题来了，这个抠脚大汉，是怎么变成了迷死人不偿命的美女的呢？这其中原理，就是一个虚拟摄像头。抠脚大汉手机端，通过虚拟摄像头技术，将一段事先让美女录好的视频，喂给摄像头接口。摄像头这时读取的，不是真实的实时数据，而是事先录好的这视频里的数据。猥琐男那边，展现出来的，自然也就是录好了的视频了。
上面所说的，是虚拟摄像头的一种应用情景，另外还有一种情景。那就是多个app，同时打开同一个摄像头，预览同一份camera数据。当然，这里所说的多个app打开同一个摄像头，不是指在同一个app里，创建多个surface，让多个surface显示同一份摄像头数据。在同一个app里将camera数据分发到不同的surface上，这很简单，原生的camera框架就支持，具体的可以参考我之前写的那篇博客。
而要让多个app，同时打开同一个摄像头，显示同一份数据，这就有些麻烦了。首先，camera框架，不允许同时有多个app使用camera，哪怕是多个app打开不同id的摄像头。当然，这个限制，也很好破解。我们可以将services/camera/libcameraservice/utils/ClientManager.h这个文件里的ClientManager构造函数，做如下修改：
//这是原生的，mMaxCost表示最多同时可以有多少个app打开camera template&lt;class KEY, class VALUE, class LISTENER&gt; ClientManager&lt;KEY, VALUE, LISTENER&gt;::ClientManager(int32_t totalCost) : mMaxCost(totalCost) {} //解决多进程打开camera冲突的问题, *10表示最多可以同时打开10个摄像头 template&lt;class KEY, class VALUE, class LISTENER&gt; ClientManager&lt;KEY, VALUE, LISTENER&gt;::ClientManager(int32_t totalCost) : mMaxCost(totalCost*10) {} 上面这样改的原理是，我们在打开一个camera的时候，会调用到CameraService.cpp里的connectHelper函数，在这个函数里，会调用handleEvictionsLocked这个函数去检测当前有无冲突。再跟进handleEvictionsLocked这个函数，会发现它又调用了mActiveClientManager.wouldEvict这个函数，当这个函数返回有冲突的client后，紧接着，就会调用下面的代码，将这个client给disconnect掉。
for (auto&amp; i : evictedClients) { // Disconnect is blocking, and should only have returned when HAL has cleaned up i-&gt;getValue()-&gt;disconnect(); // Clients will remove themselves from the active client list } wouldEvict这个函数定义在frameworks\av\services\camera\libcameraservice\utils\ClientManager.h里，它调用了wouldEvictLocked这个函数。在这个函数里，会去判断当前调用的app的优先级，以及当前打开的camera的个数。
for (const auto&amp; i : mClients) { const KEY&amp; curKey = i-&gt;getKey(); int32_t curCost = i-&gt;getCost(); ClientPriority curPriority = i-&gt;getPriority(); int32_t curOwner = i-&gt;getOwnerId(); bool conflicting = (curKey == key || i-&gt;isConflicting(key) || client-&gt;isConflicting(curKey)); //下面如果强制写成false，则cameraservice::handleEvictionsLocked函数里，不会再去强制检测camera是否已经打开过 conflicting = false; ALOGD("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a6595c209832d8fd1e7d8440c4243db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16e23ae72e3a51841633ffa8a0cbee39/" rel="bookmark">
			docker for desktop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装mysql8
设置共享目录，我设置的是F盘
配置文件my.cnf 【注意以下2行】
bind-address = 0.0.0.0
default_authentication_plugin= mysql_native_password
# Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved. # # This program is free software; you can redistribute it and/or modify # it under the terms of the GNU General Public License as published by # the Free Software Foundation; version 2 of the License. # # This program is distributed in the hope that it will be useful, # but WITHOUT ANY WARRANTY; without even the implied warranty of # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16e23ae72e3a51841633ffa8a0cbee39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d41d8e4bac9acedb13851fad904be96/" rel="bookmark">
			Springboot中Service不被识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 根据以往经验，在Mapper接口没有添加注解的情况下，Service中自动注入的Mapper都会报红，这次没有报红就知道会出错，然后测试的时候果不其然报错了。
之所以没有报红是因为service类没有被识别，就是@Service没有被扫描，所以应该是扫描路径出了问题。
具体原因 在Springboot的启动类上添加@ComponentScan
@SpringbootApplication是一个复合注解，它中包含了：@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan这三个注解。
@ComponentScan是组件扫描注解，它默认扫描的是当前包及以下用来扫描@Controller @Service @Repository这类被标记的类。
错误原因：
我的分布式项目中，路径如下：
xxx.xxx.modle
xxx.xxx.mapper
xxx.xxx.service
xxx.xxx.web
启动类在web目录下，因此@ComponentScan默认扫描路径是xxx.xxx.web
因为web与modle、mapper、service在同一级别下所以无法扫描到@Service注解。
解决方法 方法一 将启动类移动到上一级目录。
方法二 自己定义扫描路径，写法如下：
//注解写法：三种方法效果类似，都是指定扫描路径 @ComponentScan("xxx.xxx") @ComponentScan(value = "xxx.xxx") @ComponentScan(basePackages = "xxx.xxx") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca3054ba38ccf483d48fc593bae48a1b/" rel="bookmark">
			星哥带你学秒杀-我看你还是有机会的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 大家好，好久不发文章了。最近自己把秒杀系统搭建了一下，想给有需要帮助的童鞋学习。整个项目已经放到Github上去了，项目Pull下来，修改好配置文件就可以跑起来，减少你们项目框架搭建的时间，希望对你们有帮助！！！
JDKMavenMysqlSpringBootRedisRocketMq1.83.2.25.8.X1.5.10.RELEASE3.24.3.X 项目地址：https://github.com/chenxingxing6/second_skill
二、如何理解秒杀系统 秒杀场景一般会在电商网站举行一些活动或者节假日在12306网站上抢票时遇到。对于电商网站中一些稀缺或者特价商品，电商网站一般会在约定时间点对其进行限量销售，因为这些商品的特殊性，会吸引大量用户前来抢购，并且会在约定的时间点同时在秒杀页面进行抢购。
2.1 秒杀系统场景特点 秒杀时大量用户会在同一时间同时进行抢购，网站瞬时访问流量激增。 秒杀一般是访问请求。数量远远大于库存数量，只有少部分用户能够秒杀成功。秒杀业务流程比较简单，一般就是下订单减库存。 2.2 秒杀系统设计理念 限流降级解决写问题：流量肖峰解决读问题：缓存机器可弹性扩容底层需要有个好的架构：分布式服务，读写分离 三、代码预览 3.1 架构设计 3.2 项目启动说明 1、启动前，进行相关redis、mysql、rocketMq地址
2、登录地址：http://localhost:8888/page/login
3、商品秒杀列表地址：http://localhost:8888/goods/list
4、账号：18077200000，密码：123456
PS：测试时需要修改秒杀活动时间seckill_goods表开始和结束时间，然后确保库存足够。
3.3 如何模拟高并发（测试） 1、数据库共有一千个用户左右（手机号：从18077200000~18077200998 密码为：123456）
2、使用CyclicBarrier模拟高并发，1000个用户秒杀某个商品
3、读：Redis
4、写：RocketMq
ExecutorService executorService = Executors.newCachedThreadPool(); CyclicBarrier barrier = new CyclicBarrier(size); for (int i = 0; i &lt; size; i++) { int finalI = i; int finalI1 = i; executorService.execute(()-&gt;{ try { barrier.await(); // 1000个人模拟高并发 businessDoHandler(users.get(finalI), goodsId); } catch (Exception e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca3054ba38ccf483d48fc593bae48a1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f599ae842006ce652148d37a86a5fad/" rel="bookmark">
			等保测评2.0：Windows 剩余信息保护
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		等保测评2.0：Windows 剩余信息保护 一、说明二、测评项三、测评项a交互式登录: 之前登录到缓存的次数(域控制器不可用时)“关机：清除虚拟内存页面文件”关于“用可还原的加密来存储密码” 四、测评项b“关机：清除虚拟内存页面文件” 一、说明 本篇文章主要说一说个人就windows系统中剩余信息保护控制点的相关内容和理解。
二、测评项 a）应保证鉴别信息所在的存储空间被释放或重新分配前得到完全清除；
b）应保证存有敏感数据的存储空间被释放或重新分配前得到完全清除。
三、测评项a a）应保证鉴别信息所在的存储空间被释放或重新分配前得到完全清除；
这一条强调的鉴别信息。即用户名、密码等鉴别相关的信息，在Window Server 2008以前的版本中未明确鉴别信息是否进行了存储或缓存，但在Window Server 2008及以上版本中就可以配置了。
交互式登录: 之前登录到缓存的次数(域控制器不可用时) 打开“本地组策略编辑器”（win+R键输入“gpedit.msc”），然后查看 “计算机配置”-&gt;“Windows设置”-&gt;“安全设置”-&gt;“本地策略”-&gt;“安全选项”：
根据Microsoft的官方文档描述:
策略设置确定用户是否可以使用缓存的帐户信息登录到 Windows 域。 可在本地缓存域帐户的登录信息，这样，如果无法在后续登录时联系到域控制器，用户仍然可以登录。
这个缓存的信息至少是有用户名的。
再看看 默认值：
服务器类型或 GPO默认值默认域策略未定义默认域控制器策略未定义独立服务器默认设置10次登录DC 有效的默认设置不起作用成员服务器有效的默认设置10次登录客户端计算机有效的默认设置10次登录 允许值是多少呢：
可能值：
从0到50的用户定义的数字
未定义
说明可以缓存50次鉴别信息。
但缓存鉴别信息是存在漏洞的：
访问服务器控制台的用户具有其在该服务器上缓存的登录凭据。 能够访问服务器文件系统的攻击者可以找到此缓存的信息，并使用强力攻击来尝试确定用户密码。
Windows 通过加密信息并将缓存的凭据保留在系统的注册表中
所以：为了不缓存鉴别信息，“交互式登录: 之前登录到缓存的次数(域控制器不可用时)”应设置为0。
“关机：清除虚拟内存页面文件” 打开“本地组策略编辑器”（win+R键输入“gpedit.msc”），然后查看 “计算机配置”-&gt;“Windows设置”-&gt;“安全设置”-&gt;“本地策略”-&gt;“安全选项”
Microsoft的官方文档是这样描述的：
保留在实际内存中的重要信息可能会定期写入页面文件，以帮助 Windows 处理多任务处理功能。 对已关闭的服务器具有物理访问权限的攻击者可以查看页面文件的内容。 攻击者可以将系统卷移动到另一个设备，然后分析页面文件的内容。 虽然此过程非常耗时，但它可能会将缓存的数据从随机存取内存（RAM）公开到页面文件。
所以：应启用“关机：清除虚拟内存页面文件”
关于“用可还原的加密来存储密码” 打开“本地组策略编辑器”（win+R键输入“gpedit.msc”），然后查看 “计算机配置”-&gt;“Windows设置”-&gt;“安全设置”-&gt;“账户策略”-&gt;“密码策略”
Microsoft的官方文档是这样描述的：
“使用可逆的加密存储密码” 策略设置提供对使用需要用户密码进行身份验证的协议的应用程序的支持。 以可逆方式存储加密的密码意味着可以解密加密的密码。 这样, 能够中断此加密的知识攻击者就可以通过使用已遭破坏的帐户登录到网络资源。 出于此原因, 除非应用程序要求超过保护密码信息的需要, 否则切勿为域中的所有用户启用 “存储密码使用可逆的加密”。
启用此策略设置允许操作系统以可能削弱整体安全性的格式存储密码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f599ae842006ce652148d37a86a5fad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d4cfc2662b6b0e67aacfeda6f9a271d/" rel="bookmark">
			Oauth2.0的四种模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 授权码模式 （1）资源拥有者打开客户端，客户端要求资源拥有者给予授权，它将浏览器被重定向到授权服务器，重定向时会
附加客户端的身份信息。如：
/uaa/oauth/authorize?
client_id=p2pweb&amp;response_type=code&amp;scope=app&amp;redirect_uri=http://xx.xx/notify
参数列表如下：
client_id：客户端接入标识。
response_type：授权码模式固定为code。
scope：客户端权限。
redirect_uri：跳转uri，当授权码申请成功后会跳转到此地址，并在后边带上code参数（授权码）
（2）浏览器出现向授权服务器授权页面，之后将用户同意授权。
（3）授权服务器将授权码（AuthorizationCode）转经浏览器发送给client(通过redirect_uri)。
（4）客户端拿着授权码向授权服务器索要访问access_token，请求如下：
/uaa/oauth/token?
client_id=p2pweb&amp;client_secret=gdjbcd&amp;grant_type=authorization_code&amp;code=5PgfcD&amp;redirect_uri=htt
p://xx.xx/notify
参数列表如下
client_id：客户端准入标识。
client_secret：客户端秘钥。
grant_type：授权类型，填写authorization_code，表示授权码模式
code：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。
redirect_uri：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。
（5）授权服务器返回令牌(access_token)
这种模式是四种模式中最安全的一种模式。一般用于Web服务器端应用或第三方的原生App调用资源服务的时候。
因为在这种模式中access_token不会经过浏览器或移动端的App，而是直接从服务端去交换，这样就最大限度的减 小了令牌泄漏的风险。 3. 密码模式 密码模式使用较多，适应于第一方的单页面应用以及第一方的原生App。
密码模式认证流程如下：
（1）资源拥有者将用户名、密码发送给客户端 （2）客户端拿着资源拥有者的用户名、密码向授权服务器请求令牌（access_token），请求如下：
/uaa/oauth/token?
client_id=p2pweb&amp;client_secret=fgsdgrf&amp;grant_type=password&amp;username=shangsan&amp;password=123456
参数列表如下：
client_id：客户端准入标识。
client_secret：客户端秘钥。
grant_type：授权类型，填写password表示密码模式
username：资源拥有者用户名。
password：资源拥有者密码。
（3）授权服务器将令牌（access_token）发送给client
这种模式十分简单，但是却意味着直接将用户敏感信息泄漏给了client，因此这就说明这种模式只能用于client是
我们自己开发的情况下。因此密码模式一般用于我们自己开发的，第一方原生App或第一方单页面应用。 4. 客户端模式 （1）客户端向授权服务器发送自己的身份信息，并请求令牌（access_token）
（2）确认客户端身份无误后，将令牌（access_token）发送给client，请求如下：
/uaa/oauth/token?client_id=p2pweb&amp;client_secret=fdafdag&amp;grant_type=client_credentials
参数列表如下:
client_id：客户端准入标识。
client_secret：客户端秘钥。
grant_type：授权类型，填写client_credentials表示客户端模式
这种模式是最方便但最不安全的模式。因此这就要求我们对client完全的信任，而client本身也是安全的。因此这种模式一般用来提供给我们完全信任的服务器端服务。比如，合作方系统对接，拉取一组用户信息。客户端模式适应于没有用户参与的，完全信任的一方或合作方服务器端程序接入。 5. 简化模式 （1）资源拥有者打开客户端，客户端要求资源拥有者给予授权，它将浏览器被重定向到授权服务器，重定向时会附加客户端的身份信息。如：
/uaa/oauth/authorizeclient_id=p2pweb&amp;response_type=token&amp;scope=app&amp;redirect_uri=http://xx.xx/notify
参数描述同授权码模式 ，注意response_type=token，说明是简化模式。
（2）浏览器出现向授权服务器授权页面，之后将用户同意授权。
（3）授权服务器将授权码将令牌（access_token）以Hash的形式存放在重定向uri的fargment中发送给浏览器。
注：fragment 主要是用来标识 URI 所标识资源里的某个资源，在 URI 的末尾通过 （#）作为 fragment 的开头，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d4cfc2662b6b0e67aacfeda6f9a271d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7285f75dcd72f2536d705ce83c64d53f/" rel="bookmark">
			lotus 显卡 P2 C1 C2 计算时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显卡计算时间 1，`GeForce RTX 2080 Ti`2，`GeForce GTX 1080 Ti`2.1 不使用显卡 1，GeForce RTX 2080 Ti # nvidia-smi -L GPU 0: GeForce RTX 2080 Ti P1 6h35m P1 2020-07-24 16:52:31 [event;sealing.SectorStartCC] Creating CC sector 0 2020-07-24 23:27:50 [event;sealing.SectorPreCommit1] seal_pre_commit_phase1: finish P2 23m 2020-07-24 23:27:50 [event;sealing.SectorPreCommit1] seal_pre_commit_phase1: finish 2020-07-24 23:50:16 [event;sealing.SectorPreCommit2] seal_pre_commit_phase2: finish C1 1h5m 2020-07-24 23:50:17 [event;sealing.SectorPreCommitted] submitting precommit for sector 2020-07-24 23:53:21 [event;sealing.SectorPreCommitLanded] precommit message landed on chain 2020-07-25 00:55:51 [event;sealing.SectorSeedReady] seal_commit_phase1: finish C2 57m 2020-07-25 00:55:51 [event;sealing.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7285f75dcd72f2536d705ce83c64d53f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741ca041ac51fd763f10cad4e7ac2cb9/" rel="bookmark">
			RPC框架Dubbo学习 --- Dubbo架构与实战（实战——注解方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章内容输出来源：拉勾教育Java高薪训练营。
本篇文章是 Dubbo学习课程中的一部分笔记。
本示例采用注解方式实现，其他实现如spring xml方式或者api方式可参考dubbo官网示例：http://dubbo.apache.org/zh-cn/docs/user/quick-start.html
1，创建工程：dubbo-demo-base 父工程下配置好版本信息：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ming&lt;/groupId&gt; &lt;artifactId&gt;dubbo-demo-base&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;service-api&lt;/module&gt; &lt;module&gt;service-provider&lt;/module&gt; &lt;module&gt;service-consumer&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;dubbo.version&gt;2.7.5&lt;/dubbo.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;${dubbo.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-common&lt;/artifactId&gt; &lt;version&gt;${dubbo.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-registry-zookeeper&lt;/artifactId&gt; &lt;version&gt;${dubbo.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-registry-nacos&lt;/artifactId&gt; &lt;version&gt;${dubbo.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-rpc-dubbo&lt;/artifactId&gt; &lt;version&gt;${dubbo.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-remoting-netty4&lt;/artifactId&gt; &lt;version&gt;${dubbo.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-serialization-hessian2&lt;/artifactId&gt; &lt;version&gt;${dubbo.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 日志配置 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/741ca041ac51fd763f10cad4e7ac2cb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c671cee99c045b5d3953e2e7a6497d76/" rel="bookmark">
			编程练习：斗地主 洗牌、发牌机制。涉及基础知识：1.继承 2.数组对象 （练习，可省略3.重写toString、hashCode、equals）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		斗地主 洗牌、发牌机制
需求：
1.创建Card类，定义花色suit和点数rank的属性，添加相应的构造方法，在Card中覆盖toString，hashCode，equals方法2.创建玩家类 Player类 ，定义名字name ，手牌 cards (Card[])，添加相应的构造方法，在Player中覆盖toString，hashCode，equals方法3.创建一副扑克牌，54张4.实现洗牌5.实现轮流发牌6.最终结果需要看到XXX手上的牌：[XXX,XXXX,XXXX…] 1.创建Card类，定义花色suit和点数rank的属性。 添加相应的构造方法，在Card中覆盖toString，hashCode，equals方法 public class PlayCard { String[] suit = {"♠","♥","♣","♦"}; String[] rank = {"3","4","5","6","7","8","9","10","J","Q","K","A","2","小王","大王"}; public PlayCard() { super(); } public PlayCard(String[] suit, String[] rank) { super(); this.suit = suit; this.rank = rank; } //在Card中覆盖toString，hashCode，equals方法（练习，与题目无关，可忽略） public String toString() { String str = Arrays.toString(suit)+Arrays.toString(rank); return str; } public int hashCode() { System.out.println("扑克牌！"); return 0; } public boolean equals (Object obj) { //判断obj是否为空 if (obj==null) { return false; } //判断obj是否是this本身 if (obj==this) { return true; } //判断obj是否和this本身类有关 if (obj instanceof PlayCard) { return true; } //其他全为false return false; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c671cee99c045b5d3953e2e7a6497d76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64a79d4d0fbc66a3d7e49cc7d3c77182/" rel="bookmark">
			PredRNN: Recurrent Neural Networks for Predictive Learning using Spatiotemporal LSTMs论文解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文解读《PredRNN: Recurrent Neural Networks for Predictive Learning using Spatiotemporal LSTMs》 点击下载.
作者：Yunbo Wang，Mingsheng Long，Jianmin Wang，Zhifeng Gao，Phip S Yu
清华大学软件学院
abstract 时空序列预测的目的是通过学习历史帧生成未来的图像，其中空间表现和时间变化是两个关键的结构。这篇论文提出了一种PreRNN来建模这种结构。主要思想是：时空预测学习应该在一个统一的记忆池中记忆空间表象和时间变化 具体来说，内存状态不在局限于每个LSTM的内部。而是在两个方向上之字形移动，垂直方向和水平方向贯穿所有RNN层的状态。网络的核心是一个新的时空ST-LSTM，同时提时间和空间表示的单元。PreRNN在三个视频预测数据集上实现了最先进的预测性能。
1 Introduction 作为预测学习的一个关键应用，基于连续帧的图像生成在机器学习和计算机视觉领域受到了越来越多的关注。学习时空序列的表示,(RNN)[17日27]长期短期记忆(LSTM)[9]最近从监督学习任务序列扩展,如机器翻译[22日2],语音识别[8],动作识别(28日,5)和视频字幕[5],这些都是时空预测学习场景。
1. 1 为什么提出时空记忆单元 在时空预测学习中，有两个关键方面:空间相关性和时间动态性。预测系统的性能取决于它是否能够记住相关的结构。然而，据我们所知，最先进的RNN/LSTM预测学习方法[19,21,6,12,25]更关注于建模时间变化(如物体移动轨迹)，每个LSTM单元内的记忆状态会随着时间不断更新。堆叠的LSTM架构被证明对于监督的时空学习(如视频动作识别[5,28])是强大的。该场景满足两个条件:(1)时间特征对分类任务足够强。相反，细粒度的空间外观被证明不那么显著;(2)在预期输出中没有需要建模的复杂视觉结构，空间表示可以高度抽象。然而，时空预测学习不满足这些条件。在这里，空间变化和时间动态性对于生成未来的框架同样重要。一个简单的想法是，如果我们希望预测未来，我们需要记住尽可能多的历史细节。当我们回忆以前发生过的事情时，我们不仅回忆了物体的运动，还回忆了从粗到细的视觉现象。基于此，我们提出了一种新的循环架构，称为预测性RNN (PredRNN)，**它允许属于不同lstm的内存状态跨层交互(在传统的RNNs中，它们是相互独立的)。**作为PredRNN的关键组成部分，我们设计了一种新的时空LSTM (ST-LSTM)单元。它在一个统一的存储单元中为空间和时间表示建模，并在层次上垂直和状态上水平地传递内存。PredRNN在三个视频数据集上实现了最先进的预测结果。这是一个预测学习的一般和模块化框架，并不局限于视频预测。
1.2 相关工作 最近在RNN有了些新进展，比如如何基于历史的观测数据，预测未来数据。
Ranzato等人[16]定义了一种基于语言建模的RNN架构，在patch簇的离散空间中预测帧。
Srivastava等人[21]将该序列与LSTM框架序列相适应。
Shi等人[19]扩展了该模型，通过利用输入到状态和状态到状态转换中的卷积来进一步提取可视化表示。
卷积LSTM (ConvLSTM)模型已经成为该领域的一项开创性工作。
Finn等人[6]构建了一个基于ConvLSTMs的网络，该网络可以对输入像素的变换进行预测，用于下一帧的预测。
Lotter等人[12]提出了一种深度预测编码网络，其中每个ConvLSTM层在每个时间步长输出一层特定的预测，并产生一个误差项，然后在网络中横向和纵向传播。然而，在它们的设置中，预测的下一帧总是基于整个前一ground truth序列。
相比之下，我们通过序列来预测序列，这显然更具挑战性。
Patraucean et al.[15]和Villegas et al.[25]受行为识别的双流CNNs[20]启发，将光流引入RNNs来建模短期时间动态。然而，由于光流图像会带来较高的额外计算成本和降低预测效率，因而难以应用。
Kalchbrenner等人[10]提出了一种视频像素网络(VPN)，利用成熟的PixelCNNs[24]估计视频中原始像素值的离散联合分布。但是它受制于高计算复杂度。除了上述RNN架构外，还涉及到其他深层架构来解决可视化预测学习问题。
Oh等人[14]定义了一个基于cnn的动作条件自动编码器模型来预测Atari游戏的下一帧。
Mathieu等人[13]成功地使用了生成对抗网络[7,4]来保持预测帧的锐度。
综上所述，RNN可以建模时间序列，但是缺少对细粒度的视觉外观的关注，图像会变得模糊，CNN更关注空间外观，在捕捉长期运动方面相对薄弱。这篇论文探索了一种新的预测学习的RNN框架，并提出了一种新的LSTM单元，用于同时记忆时间和空间信息。
2 Preliminaries 2.1 时空预测学习 假设有一个动态系统（比如视频片段），在一段时间内有P个测量值，其中每一个测量值（如RGB通道）都记录在一个空间区域内的所有位置，这个空间区域由一个 M × N M×N M×N网络表示。从空间上看，P个测量值在任何时间的观测上都可以用张量 X ∈ R P × M × N \mathcal{X} \in \mathbb{R}^{P \times M \times N} X∈RP×M×N表示。从时间上看，观测的T个time steps的观测值组成序列张量 x 1 , x 2 , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64a79d4d0fbc66a3d7e49cc7d3c77182/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/272d246a4aaed547c7d2b7ddbf703c63/" rel="bookmark">
			编程练习:数组对象 (1).部门类Department (2).员工类Employee (3).通过部门对象,查找该部门的雇员信息  (4). 通过雇员对象,查找该雇员所在的部门信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.定义一个标准的部门类Department 成员变量有：部门编号DepNo，部门名称DepName，部门位置DepLoc，部门的人数emps（一个装员工 对象的数组）
成员方法有：get/set方法，以及查询信息getInfo（）的方法2.定义一个标准的员工类Employee 成员变量有：雇员编号EmpNo，名称EmpName，工资EmpSalry，所在部门dep（部门对象）
成员方法有：get/set方法，以及查询信息getInfo（）的方法3.创建一个测试类
a. 创建部门对象，先有部门,再有雇员,所以Department构造方法里,是没有雇员的
b. 创建员工对象，先有部门,再有雇员,所以Employee构造方法里,是有部门信息的
c. 通过部门对象的set方法，把员工数组设置到部门中去
d. 通过部门对象,查找该部门的雇员信息
e. 通过雇员对象,查找该雇员所在的部门信息
1.定义一个标准的部门类Department 成员变量有：部门编号DepNo，部门名称DepName，部门位置DepLoc，部门的人数emps（一个装员工 对象的数组）成员方法有：get/set方法，以及查询信息getInfo（）的方法 public class Department { private int DepNo; private String DepName; private String DepLoc; private Employee[] emps ; public String getInfo() { String ret = "部门编号:" + DepNo + " 名称:" + DepName + " 位置:" + DepLoc + " 部门人数:" + emps.length + "\r\n"; for (int i = 0; i &lt; emps.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/272d246a4aaed547c7d2b7ddbf703c63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ea135d89dc0e4831eb9f4901484c60d/" rel="bookmark">
			基于vue的滚动插件_一个强大的基于Vue.js的可自定义滚动条插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于vue的滚动插件
Vuescroll (Vuescroll) A powerful, customizable scrollbar plugin specially designed for Vue.js.
专为Vue.js设计的功能强大，可自定义的滚动条插件。 View demo 查看演示 Download Source 下载源 特征 (Features) Support mobile and pc by changing mode
通过更改模式支持手机和PC Support smooth scroll by choosing easing
通过选择宽松来支持平滑滚动 Support customize scrollbar
支持自定义滚动条 Support customize scroll container
支持自定义滚动容器 Support pull to refresh and push to load
支持拉动刷新和推动加载 Support typescript
支持打字稿 Support SSR
支持SSR And more !
和更多 ！ 快速开始 (Quick Start) 进口 (Import) In your entry file:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ea135d89dc0e4831eb9f4901484c60d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7305caaa6868834dc46a9b4c8c3fd48c/" rel="bookmark">
			docker安装gitea(不好使你打我)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.what is gitea 一款极易搭建的自助Git服务。
运行非常快速，安装和使用体验良好的自建 Git 服务
1.下载镜像 #直接拉取最新版本，需要其它版本自己去https://hub.docker.com/找 docker pull gitea/gitea 2.运行镜像 》》》注意防火墙或安全组中放开用到的端口（例如10022和10080） 官网启动方式 docker run -d --name=gitea -p 10022:22 -p 10080:3000 -v /var/lib/gitea:/data gitea/gitea:latest 本次启动方式(新增两个参数，可以根据需要选择) docker run -d --privileged=true --restart=always --name=gitea -p 10022:22 -p 10080:3000 -v /var/lib/gitea:/data gitea/gitea:latest # --privileged=true 使用该参数，container内的root拥有真正的root权限（可根据需要选择是否要该参数） # --restart=always 自动重启容器（可根据需要选择是否要该参数） # -p 端口映射（宿主机端口：容器端口） # -v 容器卷挂载 （宿主机目录 ：容器目录） 3.配置 访问http://ip:10800，点击注册，没有配置的情况下会进入配置页面如下：
最下面可选配置，邮箱、管理员账号之类的根据需要配置；
然后点击立即安装；
安装完成后再次访问地址，注册用户，登录（配置管理员的话可以直接用管理员账户登录）；
4.测试 本文借用Sourcetree工具来测试
创建仓库
下载仓库
修改文件，然后点击提交，然后推送 查看结果 登录gitea，可以发现刚才的修改已经成功push到了远程仓库!
5.参考文献 [0] gitea官方文档 https://docs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7305caaa6868834dc46a9b4c8c3fd48c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc7e65269267d8605d877738e5d4ec5/" rel="bookmark">
			kubeadm加入master节点失败，报错 error execution phase check-etcd: etcd cluster is not healthy: context deadli
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 出现这个报错，多是因为之前的集群信息没有清理干净。
解决办法如下：
执行命令，获取etcd节点列表。
kubectl get pod -n kube-system etcd节点名称为 “etcd”+hostname
这里以 etcd-k8s-master1 为例, 进入etcd容器内部
kubectl exec -ti etcd-k8s-master1 -n kube-system sh # k8s中etcd使用的是v3的api， 所以要先声明变量 export ETCDCTL_API=3 # 执行命令，查看当前的etcd节点数量 etcdctl --cacert="/etc/kubernetes/pki/etcd/ca.crt" --cert="/etc/kubernetes/pki/etcd/server.crt" --key="/etc/kubernetes/pki/etcd/server.key" member list 返回的信息如下
6ae633bf7c3f438, started, master1, https://10.62.142.103:2380, https://10.62.142.103:2379 ed749226b340ac7b, started, master3, https://10.62.142.97:2380, https://10.62.142.97:2379 f2ff34b220f4cac9, started, master2, https://10.62.142.84:2380, https://10.62.142.84:2379 返回信息的第三列为主机名。 我当前加入失败的节点，主机名为master2 ， master2恰恰在列表中。所以得出结论， 加入失败是因为etcd节点信息没有重制， 我们手动把master2删掉即可添加成功
etcdctl --cacert="/etc/kubernetes/pki/etcd/ca.crt" --cert="/etc/kubernetes/pki/etcd/server.crt" --key="/etc/kubernetes/pki/etcd/server.key" member remove f2ff34b220f4cac9 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b9046d9da457874db637bb29bb17ca1/" rel="bookmark">
			KITTI分割数据集介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.官网介绍：
数据集官网网址
KITTI语义实例分割数据集包含了200张语义标注训练图像和两百张无标注的测试图像，对应着KITTI Stereo and Flow Benchmark 2015。数据集格式与CityScape数据集格式一致。
下载的文件包括：一个314MB左右的图像及label压缩包；一个开发工具包；
2.实例分割
实例分割任务关注检测，分割与分类目标instances。为了获得实例级别的performance，此数据集评估计算average precision on the region level(AP) for each class and average it across a range of overlap thresholds to avoid a bias towards a specific value.
3.数据label格式
“semantic”文件夹包含训练图像的语义分割标注，png格式，单通道uint8 8bit，每个像素值代表语义类别ID。
“instance”文件夹包含了结合了实例分割标注，png格式，单通道uint16 16-bit，每个像素值的高8位代表语义labelID，低8位为instance ID。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26366d822b9ca1900ddc6ad42cab6c60/" rel="bookmark">
			RPC框架Dubbo学习 --- Dubbo架构与实战（架构篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章内容输出来源：拉勾教育Java高薪训练营。
本篇文章是 Dubbo学习课程中的一部分笔记。
1，Dubbo架构概述 1.1 什么是Dubbo Apache Dubbo 是一款高性能的 Java RPC 框架。其前身是阿里巴巴公司开源的一个高性能、轻量级的开 源Java RPC 框架，可以 和Spring 框架无缝集成。 1.2 Dubbo的特性 参考官网首页 http://dubbo.apache.org/zh-cn/index.html
1.3 Dubbo的服务治理 服务治理（ SOA governance ），企业为了确保项目顺利完成而实施的过程，包括最佳实践、架构原 则、治理规程、规律以及其他决定性的因素。服务治理指的是用来管理SOA 的采用和实现的过程。 在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。
当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。 此时需要一个服务注册中心，动态地注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。
当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清关系。
接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？ 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。
以上是 Dubbo 最基本的几个需求。
（来自Dubbo官网：http://dubbo.apache.org/zh-cn/docs/user/preface/requirements.html）
2，Dubbo处理流程 (虚线代表异步调用，实线代表同步访问，蓝色虚线程序启动时完成，红色虚线程序运行中完成)
注意：
第三步：提供者列表发生变更，Registry会基于长连接推送变更数据给消费者。
第四步：基于软负载均衡算法选则Provider。
节点说明：
节点角色名称Provider暴露服务的服务提供方Consumer调用远程服务的服务消费方Registry服务注册与发现中心Monitor统计服务的调用次数喝调用时间的监控中心Container服务运行容器，负责启动加载运行服务提供者 （更多内容参考官网：http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html）
3，服务注册中心Zookeeper （来自Dubbo官网：http://dubbo.apache.org/zh-cn/docs/user/references/registry/zookeeper.html）
Zookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 [1]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26366d822b9ca1900ddc6ad42cab6c60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/736b5f5fa45dc43129fd743ffb6e1558/" rel="bookmark">
			PX4与ROS关系以及仿真控制（键盘控制无人机）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘自：https://blog.csdn.net/weixin_44917390/article/details/106427395
https://blog.csdn.net/weixin_44917390/article/details/106427533
https://blog.csdn.net/weixin_44917390/article/details/106399062
https://blog.csdn.net/weixin_44917390/article/details/106431863
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e571a7ae7ff8cfb70de6394b3f775f4c/" rel="bookmark">
			python有关函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据类型 1.number数字类型（int float bool complex） 1.0奠基部分：函数type和id #type概念：获取变量的数据类型 res=type(intvar) print(res) #id概念：获取变量值的地址 res=id(intvar) print(res) 1.1 int整数类型表示方法 #整型（正整数 0 负整数）即整数 intvar=20 print(intvar) 第一个：二进制整数型0b
#注意：只有0和1俩个值 intvar=0b101 print(intvar) #注意输出结果为默认十进制数 第二个：八进制整数型0o
#注意：只有0 1 2 3 4 5 6 7八个数字 intvar=0o234 print(intvar) #注意输出结果为默认十进制 第三个：十六进制整形0x
#注意：只有：有0 1 2 4 5 6 7 8 9 a b c d e f intvar = 0xff print(intvar) 1.2 float浮点型（小数） #方式一 floatvar = 3.14 print(floatvar) print( type(floatvar) ) #方式二 科学计数法 floatvar = 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e571a7ae7ff8cfb70de6394b3f775f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a89b91a2cc83a2914238a72736aef15/" rel="bookmark">
			eNSP（华为模拟器）基本配置命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eNSP（华为模拟器）基本配置命令 路由器基本配置命令：交换机基本配置命令：证书 路由器基本配置命令： 路由器指的是负责在不同网络之间转发数据的设备，当到达目标的路径很复杂时，由路由器决定最佳路径，路由器也为直连网络的主机充当“网关”角色。
&lt; Huawei &gt; ：用户视图
&lt; Huawei &gt;system-viem：切换系统视图
[Huawei]系统视图
[Huawei]interface Ethernet 0/0/1 进入接口
[Huawei-thernet 0/0/1] 接口视图
ctrl + c：停止当前命令的运行
ctrl + z：回到用户模式
?：命令+？获取帮助信息
#切换语言模式（支持中英文两种语言模式Chinese/English） &lt; Huawei&gt; language-mode Chinese #查看VRP系统版本 &lt; Huawei &gt; display version #修改主机名为switch [Huawei]sysname switch #不显示提示信息 [Huawei]undo info-center enable 修改系统时间（用户模式命令）： #设置时区 &lt; Huawei &gt;clock timezone local add 08:00:00 #设置时间 &lt; Huawei &gt;clock datetime 14:59:22 2020-07-22 #查询时间 &lt; Huawei &gt;display clock 配置明文console 口令（系统模式命令）： #进入console 0 唯一端口 [switch]user-interface console 0 #启用密码 [switch-ui-console0]authentication-mode password #设置密码为123 [switch-ui-console0]set authentication password simple 123 （Simple：明文、Cipher：密文） 模拟器上console口下的用户权限默认为15 #返回到上级 [switch-ui-console0]quit #查看配置信息 &lt; switch &gt;display current-configuration 取消明文console 口令： #进入console 0 唯一端口 [switch]user-interface console 0 #取消密码： [Switch-ui-console0]undo set authentication password 配置交换机IP地址： #进入接口1 [Switch]interface Vlanif 1 #配置IP地址 [Switch-Vlanif1]IP address 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a89b91a2cc83a2914238a72736aef15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab93777860fb36720264bec01a71f18b/" rel="bookmark">
			sqlserver删除master数据库中的用户创建的表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在使用SQL Server2019，在程序中执行建表语句默认建到了master数据库中，使用SSMS(SQL Server Management studio)执行以下语句时提示：“不允许对系统目录进行即席更新” delete from sysobjects where id = object_id('table_name') and OBJECTPROPERTY(id, 'IsUserTable') = 1 于是百度了一下，使用下列命令可以删除master数据库中的所有用户添加的表 use master; go sp_msforeachtable @command1="drop table ?" go 特此记录下来！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a2153c2cf4c1a3534748e7e197610b1/" rel="bookmark">
			倒数第二个元素css选择器_创建一个CSS / JS倒数计时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		倒数第二个元素css选择器
I was watching Disney+ the other day (Mandalorian rocks!) and I saw a neat UI for auto advancing a user to the next episode. It was a button with a countdown.
前几天，我在看迪士尼+（Mandalorian摇滚！），我看到了一个整洁的UI，可以自动将用户推进到下一集。 这是一个带有倒计时的按钮。 I thought "Can we make that in CSS?!" Let's go ahead and make it!
我以为“我们可以用CSS做到吗？！” 让我们继续前进吧！ 我们将建立什么 ( What We'll Build ) Here is our countdown timer. You can use this for a number of things.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a2153c2cf4c1a3534748e7e197610b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41fc3b23a132c11abb450f738ee55501/" rel="bookmark">
			【神经网络】神经元模型和感知器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.神经元模型 在生物神经网络中，每个神经元与其他神经元相连，当它“兴奋”时，就会向相连的神经元发送化学物质，从而改变这些神经元内的电位。如果某神经元的电位超过了一个“阈值”，那么它就会被激活，即“兴奋”起来。
1943年，心理学家McCulloch和数学家Pitts提出了第一个抽象的神经元模型，称为MP模型。MP模型是人工神经网络的基本单元，如下图所示：
其中，向量是神经元模型的输入，为第i个神经元到第n个神经元的输出。是与输入相对应权值。在输入和神经元之间通常还有一个偏置（图上未画），这里记为b，神经元的输出为y。
整个过程为：神经元接收来自 n个其他神经元传递过来的输入信号x，将输入 x 和所对应的权值W 相乘后再求和，得到神经元接收到的总输入值，然后通过激活函数f处理产生神经元最终的输出y，如下式所示：
激活函数f用于模拟人脑部神经元对输入的信息进行处理并判断是否产生对应的响应，即是否“兴奋”。常见的激活函数有：
阶跃函数 其中z表示阈值，即当输入x超过阈值z时（一般情况下z=0），激活函数的输出为1，表示神经元被激活，否则被抑制。但是可以看出，其函数输出是不连续的，为此更多地采用sigmoid函数。
Sigmoid函数 Sigmoid函数是在定义域内连续递增的函数，把输入映射到0到1之间，其中 被映射到1， 被映射到0。同样会设置一个阈值，当sigmoid函数的输出大于这个阈值时，神经元模型被激活。 它们的图像如下：
MP模型虽然简单，却建立了神经网络大厦的地基。但是MP模型中，权重的值都是预先设置的，因此不能学习 2.感知器 2.1 基本结构 感知器模型（Perceptron）是在1958年由计算科学家Rosenblatt首先提出的。感知器由两层神经元组成，分别为输入层和输出层构成。输入层接收外界输入信号后传递给输出层，输出层是 M-P 神经元，也就是说只有输出层神经元进行激活函数处理。如下图所示：
感知器的计算公式如下所示：
所采用的激活函数f为sign函数：
可以把感知机看作是n维实例空间中的超平面决策面，对于超平面一侧的实例，感知器输出1，即正例；对于另一侧的实例输出 -1，即负例。这个决策超平面方程就是（n=2的话，即二维实例空间，此时感知机退化成一条直线）。那些可以被某一个超平面分割的正反样例集合称为线性可分样例集合，换句话说，感知机是一种线性的分类模型，不能完成非线性的分类。
从计算表达式上来看，感知器模型与神经元模型并没有明显区别，但是实际上主要的区别有三点：
（1）感知器的输入变成了一层神经元，而神经元模型的输入为其他神经元的输出信号；
（2）感知器的激活函数为sign函数，而神经元模型的激活函数可以是sign函数，也可以是sigmoid函数等；
（3）感知器可以采用有监督的方式学习到参数值，而神经元模型的参数是不能被学习的。
2.2 损失函数 感知器最大的亮点就是在于可以利用梯度下降算法来自主更新参数，为此必须要建立起损失函数。定义感知机的损失函数之前需要明确以下几点：
（1）当, ，即数据被预测为正例；当, ，数据被预测为负例，因此对于正确分类的数据都满足，分类错误的数据。
（2）点到平面的距离计算公式为：
所以定义感知机的损失函数可以让误分类的数据到直线的距离和最小，此时误分类点到超平面的距离是：
这样，假设超平面S的误分类点集合为M，那么所有误分类点到超平面的总距离为:
不考虑，就得到了感知机学习的损失函数：
显然，损失函数是非负的。如果没有误分类点，损失函数的值为0。而且误分类点越少，误分类点离超平面越近，损失函数的值就越小。
为什么损失函数可以不考虑1/||𝑤||？
1/||𝑤||不影响𝑦𝑖(𝑤⋅𝑥𝑖+𝑏)正负的判断，即不影响学习算法的中间过程。因为感知机学习算法是误分类驱动的，这里需要注意的是所谓的“误分类驱动”指的是我们只需要判断−𝑦𝑖(𝑤⋅𝑥𝑖+𝑏)的正负来判断分类的正确与否，而1/||𝑤||并不影响正负值的判断。所以1||𝑤||对感知机学习算法的中间过程可以不考虑。1||𝑤||不影响感知机学习算法的最终结果。因为感知机学习算法最终的终止条件是所有的输入都被正确分类，即不存在误分类的点。则此时损失函数为0. 对应于−1/||𝑤||∑𝑖∈𝑀𝑦𝑖(𝑤⋅𝑥𝑖+𝑏)，即分子为0.则可以看出1/||𝑤||对最终结果也无影响。 综上所述，即使忽略1/||𝑤||，也不会对感知机学习算法的执行过程产生任何影响。反而还能简化运算，提高算法执行效率。
2.3 梯度下降更新 梯度下降首先要求得损失函数对于参数的梯度，即导数。通过连式法则，很容易求出损失函数对参数W和b的导数：
梯度下降进行更新：
2.4 感知机和SVM的异同。 （1）相同点：
都可以求取一个超平面来完成线性的二分类问题均属于监督学习的分类器 （2）不同点
SVM可以通过改变核函数来解决非线性问题，而感知机不行感知机的损失函数为所有误分类点的几何距离，使其最小，SVM的损失函数是参数的L2范数，也就是结构风险最小化的。或者说感知机的损失函数是函数距离的和，而支持向量机是几何距离的和，感知机是去掉距离限制的SVM感知机追求最大程度正确划分，最小化所有错误点到超平面的距离，很容易造成过拟合。而支持向量机最求两种数据最大程度的分开，即最大化支持向量点之间的间隔，一定程度上避免了过拟合， 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11bd4499d09a29e114be9806086023a0/" rel="bookmark">
			drools学习笔记 workbench tomcat下部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 下载workbench war drools workbench 的最新版本已经去掉了对于tomcat的依赖，所以我们使用历史版本。
下载地址：
https://download.jboss.org/drools/release/
下载版本：7.11.0
2 tomcat 下载 tomcat8下载地址：https://tomcat.apache.org/download-80.cgi
jdk8下载地址：这个随便搜一搜就能找到。但是oracle下载是需要注册的。
解压tomcat8.
解压jdk8,并配置在tomcat/bin/catalina.sh最开始的地方添加jdk配置：
JAVA_HOME=jdk解压后的路径 3 依赖jar slf4j-api-1.7.25
jboss-jacc-api_1.5_spec-1.0.2.Final
kie-tomcat-integration-7.11.0.Final
这些都是普通的jar包，已经被维护到maven的中央仓库。可以从mvnrepository.com下载。如果速度慢，可以从阿里的maven仓库下载。
下载之后放到tomcat/lib/文件夹下。
4 部署 将drools的war包拷贝到tomcat/webapps下。
重命名war，更改为：kie-drools-wb.war。
修改启动脚本：
在tomcat/bin/catalina.sh最开始的地方添加：
CATALINA_OPTS="-Xms2048M -Xmx2048M -Djava.security.auth.login.config=%CATALINA_HOME%/webapps/kie-drools-wb/WEB-INF/classes/login.config -Dorg.jboss.logging.provider=jdk" 修改登录用户信息。修改配置文件tomcat/conf/tomcat-users.xml，修改为：
&lt;tomcat-users xmlns="http://tomcat.apache.org/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://tomcat.apache.org/xml tomcat-users.xsd" version="1.0"&gt; &lt;role rolename="admin"/&gt; &lt;role rolename="analyst"/&gt; &lt;role rolename="HR"/&gt; &lt;role rolename="kie-server"/&gt; &lt;role rolename="PM"/&gt; &lt;role rolename="user"/&gt; &lt;user username="kieserver" password="kieserver" roles="admin,kie-server"/&gt; &lt;user username="admin" password="admin" roles="admin,analyst,PM,HR,kie-server"/&gt; &lt;/tomcat-users&gt; omcat/conf/server.xml添加配置：
&lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;Valve className="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11bd4499d09a29e114be9806086023a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61b5692f251422c7b7fc54e7266479e4/" rel="bookmark">
			HTTP中的status code什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		状态码分为1-5开头的CODE,以下依次说明：
1** 类状态码称之为Information 状态吗，表示信息正在处理。
2** 类状态码称为为Success状态码，表示请求正常完成。200（ok）表示：从客户端成功发出去请求到服务端了,服务端也接收到了这条请求并正确返回
3**类状态码称之为Redirection 状态码，表示需要客户端进行附加操作（如跳转。重定向）
4**类状态码称之为Error状态码，通常是由于客户端的错误导致的。404：服务器上无此资源
5**类状态吗称为Server Error状态码，通常是服务端的错误导致的。500：服务端错误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaaae885b41944c9f802a8f8a071b3c3/" rel="bookmark">
			Keil5中一些比较好用的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Keil5是一款非常强大的集成开发环境（IDE），开发stm32系列单片机一般都会选择使用这款IDE。
Keil5中常用的快捷键 基本所有软件通用的：Ctrl+C、Ctrl+V：复制粘贴，Ctrl+X：剪切，ctrl+A：全选，ctrl+S：保存，Ctrl+F：搜索，Ctrl+Z：撤销，Ctrl+Shift+Z/Ctrl+Y：恢复，delete：删除光标后一个字符，backspace：删除光标前一个字符。
Ctrl+N：新建空白页
Ctrl+L：剪切当前行，也可当做删除当前行使用
Ctrl+U：字母转小写
Ctrl+Shift+U：字母转大写
Alt+Shift+鼠标左键：以光标为原点自由选择
Ctrl+Q：重置窗口
Ctrl+E：当光标处于大括号处时，可以跳转到大括号的另一半处。
Tab/Shift+Tab：向右/向左缩进
F12：到定义=右键go to definition
更多快捷键可以通过[菜单栏]-&gt;Edit-&gt;configuration-&gt;Shortcut Keys进行查看和自主设置。
Keil5的注释和去注释是没有默认快捷键的，如果需要，可以自行添加，比如我的：
Edit：Advanced Comment Selection（注释）：Ctrl+K
Edit：Advanced Uncomment Selection（去注释）：Ctrl+Shift+K
Keil5中的好用配置 [菜单栏]-&gt;Edit-&gt;configuration-&gt;Editor-&gt;Encodeing选择Chinese GB2312(Simplified)，可以让你注释里的中文只需一次Backspace即可删除，绝无乱码。
[菜单栏]-&gt;Edit-&gt;configuration-&gt;Editor最下方可以设置一个Tab相当于几个空格。
如果你对debug时弹出的两个文件比较反感时，[菜单栏]-&gt;Edit-&gt;configuration-&gt;Other-&gt;debug，勾选Do not open matching source file after Run Stop。
Debug中好用的功能 点击debug图标进入debug模式。
[菜单栏]-&gt;View-&gt;watch windows-&gt;watch 1/watch 2：可对全局变量进行实时监测，观察其变化。第一次使用往往会发现变量没有变化，这时我们点击view-&gt;periodic window update即可。
[菜单栏]-&gt;View-&gt;memory windows-&gt;memory 1~memory 4:查看/修改各存储区的值。
[菜单栏]-&gt;View-&gt;analysis windows-&gt;logic analyzer:逻辑分析仪，可对信号进行逻辑分析，检测信号状态。
[菜单栏]-&gt;View-&gt;system viewer:观察单片机中寄存器的值，第一次使用时可能会发现里面一片空白，此时需要退出debug模式，点击魔术棒，勾选Use Custom File。
最后推荐[菜单栏]-&gt;Help-&gt;uVision Help，里面有对整个软件非常详细的介绍，不过阅读它可能需要一定的英语水平。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6104a15517f466bff4f8ea4df469784/" rel="bookmark">
			Obsidian 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Obsidian 介绍 先声明，这不是一篇软文，是因为这个软件确实的从知识整理方面极大的帮助了我，所以做一点分享
为什么要用它 我一直苦于笔记整理，确切地说是知识整理
不管是哪一门知识，都包含了很多知识点，每个知识点又交叉联系，很难以笔记的方式进行直观化构建
我尝试过思维导图，最后发现思维导图其实就是个分类文件夹，知识点细分过头的一个缺陷之一，就是有些明明有联系的知识点，但是因为分类太深，难以在查看某个知识点的时候关联相关知识点，发点反例：
而 Obsidian 所生成的图，真的给力：
怎么使用 下载 官网，Obsidian 支持 Win/Mac 平台，个人使用是免费的
读教程，软件安装后，一打开就是教程，这个就是 MD 的语法加强，我在这里吃下去再嚼一遍给你，没意义，还有，这个是 Obisidian 的一些特点，可以先看看 features
开整，对了，有一个地方注意，Obsidian 支持多操作面板
但是这个面板的排版选项藏得有点隐蔽。。。
个人想法 Roam Research 引领做出笔记的双向链接也才不久，同类产品还刚起步
随着功能的逐步增强，我相信这种新的笔记方式会像思维导图一样，逐步的影响有笔记记录整理习惯的人群
笔记上的功能我是觉得够用了，但是视图显然还有许多功能可以挖掘
比如现在只支持点击视图上的某点，打开对应的笔记；但不支持打开笔记时，在视图内高亮笔记对应的点
再比如选择指定点群后，自动简化视图，进行最简网络视图展示
等等
有兴趣的朋友可以试试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/513d088412c712a5ed3e30f9485cabee/" rel="bookmark">
			maya humanIk 动画pose快速镜像 插件及教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前一段学习maya的human ik 绑定和动画，虽然非常方便但是，更多的编辑功能却没有，比如做循环动画时，的镜像pose和交替镜像功能。只有在motionbuilder中有，于是开发者这个快速pose镜像工具。免费提供大家使用。非常方便。
一、插件安装方法
请将文件包解压，并将整个文件夹拷贝到，不包含任何中文路径的目录或盘符下。如：d:/ 。
方法一：快捷使用模式。
直接将mel 程序拖入maya主窗口即可。
方法二：拷贝使用模式。
将所有文件(包括dll目录)拷贝到maya的scripts目录中。
在maya脚本编辑器中，输入mel插件的文件名运行即可。
二、使用方法：
选择要镜像的部分FK父骨骼(skeleton)。之后点击Mirror FK To other side即可将此边pose镜像到另一边。点击Mirror Swap FK 可以交换左右pose，Select Bones Mirror 可以镜像选择左右骨骼或是交替选择。功能很简单就几个按钮，一试便知。哈哈。南无阿弥陀佛。
免费版地址：链接：http://pan.baidu.com/s/1boOibvh 密码：l1yl
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b59ed265ada83a0d6b0f2622bd3c0a/" rel="bookmark">
			tkinter-Entry详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍Entry控件，Entry控件使用户输入单行文本,例如，用户名，密码等。
前面我介绍过Text控件用来显示多行文本且用户可编辑；如果想显示多行文本但用户不能编辑，就使用Label控件。
文章目录 Entry的引入pack布局Frame+pack布局grid布局place布局 background/bgborderwidth/bdcursorforeground/fgshowstatetextvariable 首先通过一个例子来引入Entry控件，说明，博客中的实例代码都没有封装，使用最直接的方式，目的是为了直观的介绍知识点，可根据具体业务自行封装以便调用。 Entry的引入 pack布局 from tkinter import Tk,Entry,Label,Frame main_win = Tk() main_win.title('渔道的Entry控件') width = 300 height = 300 main_win.geometry(f'{width}x{height}') # 使用pack布局 user_name = Label(main_win, text='user name') user_name.pack(side='left', anchor='nw') user_name_entry = Entry(main_win, bd=5) user_name_entry.pack(side='right', anchor='ne') password = Label(main_win, text='password') password.pack(side='left', anchor='nw') password_entry = Entry(main_win, bd=5) password_entry.pack(side='right', anchor='ne') main_win.mainloop() 发现使用pack布局 达不到预期的效果(你可以自行调整布局参数)，这个例子就体现了pack布局的局限性。
Frame+pack布局 前面介绍过Frame控件，看看能否结合Frame使布局更好一些。
from tkinter import Tk,Entry,Label,Frame main_win = Tk() main_win.title('渔道的Entry控件') width = 300 height = 300 main_win.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8b59ed265ada83a0d6b0f2622bd3c0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41809d6dfb2fd9868aae2aee4a9fdeb9/" rel="bookmark">
			pip 安装小白教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip 安装 1先找到pip.exe的安装路径，一般在python或anaconda的Scripts文件夹
2 打开cmd，将上面的路径拖至cmd窗口
3 在上述路径后输入 install + 模块名（install前有一个空格），然后回车。
4 在自己的IDE里导入包，如果不报错则安装成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49747dc67b9bca944d6819eb7377ba5c/" rel="bookmark">
			1. 关于系统架构师
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 关于系统架构师 1.1 系统架构的概念和发展历史1.1.1 系统的概念1.1.2 简要的发展历史 1.2 系统架构师的定义与职业素质1.2.1 定义1.2.2 系统架构师技术素质1.2.3 系统架构师管理素质1.2.4 系统架构师与其他团队角色的协调 1.3 系统架构师知识结构1.4 从开发人员到架构师 1.1 系统架构的概念和发展历史 1.1.1 系统的概念 系统架构三要素：构件、模式和规划。
软件系统架构是关于软件系统的结构、行为和属性的高级抽象。
1.1.2 简要的发展历史 20 世纪 80 年代 Zachman 框架20 世纪 90 年代 TOGAF (The Open Group Architecture Framework, Open Group 架构框架)… 1.2 系统架构师的定义与职业素质 系统架构师分类
业务架构师（Business Architect）主题领域架构师（Domain Architect）技术架构师（Technology Architect）项目架构师（Java Architect、.NET Architect）系统架构师（System Architect） 1.2.1 定义 系统架构师是系统或产品线的设计责任人，是一个负责理解和管理并最终确认和评估非功能性需求（如软件的可维护性、性能、复用性、可靠性、有效性和可测试性等），给出开发规范，搭建系统实现的核心框架，对整个软件架构、关键构件、接口进行总体设计并澄清关键技术细节的高级技术人员。
1.2.2 系统架构师技术素质 具备吩咐的一线大中型开发项目的总体规划、方案设计及技术队伍管理经验。具备软件行业工作经验，熟悉业务领域的技术应用和发展。具有项目管理理论基础，并在应用系统开发平台和项目管理上有实践经验。具备 C/S 或 B/S 体系结构或特定领域软件产品开发及架构和设计的经验。具有面向对象分析、设计、开发能力，精通 UML 和 XML 等，熟练使用 Rational Rose、PowerDesigner 等 CASE 工具进行设计开发。对相关编程技术（如 Java/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49747dc67b9bca944d6819eb7377ba5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a236b21148c035474d0e145eb451ad3a/" rel="bookmark">
			Docker架构简介  命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1、Docker的介绍
Docker是一个开源的应用容器引擎，使用Go语言开发，基于Linux内核的cgroup，namespace，Union FS等技术，对应用进程进行封装隔离，并且
独立于宿主机与其他进程，这种运行时封装的状态称为容器。
Docker早起版本实现是基于LXC，并进一步对其封装，包括文件系统、网络互联、镜像管理等方面，极大简化了容器管理。从0.7版本以后开始去
除LXC，转为自行研发的libcontainer，从1.11版本开始，进一步演进为使用runC和containerd。
Docker理念是将应用及依赖包打包到一个可移植的容器中，可发布到任意Linux发行版Docker引擎上。使用沙箱机制运行程序，程序之间相互隔离。
1.2、docker的体系架构
Containerd：是一个简单的守护进程，使用runC管理容器。向Docker Engine提 供接口。 Shim：只负责管理一个容器。 runC：是一个轻量级的工具，只用来运行容器。 1.4、docker的内部组件
1. Namespaces
命名空间，Linux内核提供的一种对进程资源隔离的机制，例如进程、网络、挂载点等资源。
2. CGroups
控制组，Linux内核提供的一种限制进程资源的机制；例如CPU、内存等资源。
3. UnionFS
联合文件系统，支持将不同位置的目录挂载到同一虚拟文件系统，形成一种分层的模型。
1.5、虚拟机与容器区别
以 KVM 举例，与 Docker 对比
启动时间
Docker秒级启动，KVM分钟级启动。
轻量级
容器镜像大小通常以M为单位，虚拟机以G为单位。
容器资源占用小，要比虚拟机部署更快速。
性能
容器共享宿主机内核，系统级虚拟化，占用资源少，没有Hypervisor层开销，容器性能基本接近物理机；
虚拟机需要Hypervisor层支持，虚拟化一些设备，具有完整的GuestOS，虚拟化开销大，因而降低性能，没有容器性能好。
安全性
由于共享宿主机内核，只是进程级隔离，因此隔离性和稳定性不如虚拟机，容器具有一定权限访问宿主机内核，存在一定安全隐患。
使用 要求
KVM基于硬件的完全虚拟化，需要硬件CPU虚拟化技术支持；
容器共享宿主机内核，可运行在主流的Linux发行版，不用考虑CPU是否支持虚拟化技术。
1.6、docker 的应用场景
场景一：节省项目环境部署时间
1. 单项目打包
2. 整套项目打包
3. 新开源技术试用
场景二：环境一致性
场景三：持续集成
场景四：微服务
场景五：弹性伸缩
参看： https://blog.51cto.com/lizhenliang/1978081
1.7、在Centos7.x安装docker
CentOS7 # 安装依赖包 yum install -y yum-utils device-mapper-persistent-data lvm2 # 添加Docker软件包源 yum-config-manager --add-repo http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a236b21148c035474d0e145eb451ad3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3359ec734ee399858b6adefe877039fe/" rel="bookmark">
			后台如何接收LocalDateTime类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先，我们需要在maven父pom中引入
&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt; &lt;version&gt;2.9.7&lt;/version&gt; &lt;/dependency&gt; 实体类定义添加相关注解，如下
import com.fasterxml.jackson.annotation.JsonFormat; import org.springframework.format.annotation.DateTimeFormat; import java.time.LocalDateTime; @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") // 为了解析表单数据的（form/data)数据 @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8") //为了解析json数据 private LocalDateTime startTime; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/470be464e7e9f1d2bb8b74e3cc6b01f9/" rel="bookmark">
			使用Python将一个excel的某些内容导入到新的excel中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 工作中经常要汇总数据，每周的报告选取一些需要的列然后汇总成月报，每周的报告列的项目都是一样的，下面的数值不一样，目标就是用Python实现将多个excel的内容汇总到一个新的excel表格中。
在网上参考了好多例子都没有成功，最后找到了这个：https://blog.csdn.net/qq_45731111/article/details/102472406 亲测有效，感谢原博。
用我小白的编程水平完成了第一步。。。将一个excel的某些列导入到新的excel中。贴上代码：
import xlrd import xlwt datas=xlrd.open_workbook('D:\\1. Yield management\\1.FT yield summary\\XXXXXX Weekly report\\FT yield summary\\1750_202027FT_WEEKLY_SUMMARY.xlsx') #打开需要做处理的文件 table=datas.sheet_by_name('1750_202027FT_WEEKLY_SUMMARY') #通过名称获取工作表 sheet_name=datas.sheet_names() #获取所有的表名 nrows=table.nrows #获取工作表中所有行数 ncols=table.ncols #获取工作表中所有列数 wb=xlwt.Workbook() #新建一个excel文件 ws=wb.add_sheet('June FT yield') #新增一个表格，并且取名June FT yield for rownum in range(6,nrows): #相当于for rownum=6;rownum++;rownum&lt;nrows，从6开始是因为summary里面第6行开始才是需要的数值 row=table.row_values(rownum) #从第6行开始到nrows最大值，获取每行的数值，整合成数组的形式 Date=str(row[0]) MoNumber=str(row[1]) PKG=str(row[2]) Device=str(row[3]) CustomerOrder=str(row[4]) WaferLot=str(row[5]) ProgramName=str(row[6]) Input=str(row[7]) Output=str(row[8]) Yield=str(row[9]) ws.write(rownum,0,label=Date) ws.write(rownum,1,label=MoNumber) ws.write(rownum,2,label=PKG) ws.write(rownum,3,label=Device) ws.write(rownum,4,label=CustomerOrder) ws.write(rownum,5,label=WaferLot) ws.write(rownum,6,label=ProgramName) ws.write(rownum,7,label=Input) ws.write(rownum,8,label=Output) ws.write(rownum,9,label=Yield) wb.save('example.xls') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11dfba110707a733348ba63756409485/" rel="bookmark">
			CLion使用remote host在本地进行远程Linux程序调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 配置SSH连接2 配置 Remote Host3 上传代码4 环境测试5 小结 1 配置SSH连接 首先，要配置SSH连接，过程如下所示。
配置好SSH连接以后，测试一下是否可以连接，如果是第一次连接，会有是否连接的确认提示。
如果一切正常会弹出连接成功的提示。
2 配置 Remote Host 如下图所示，在 + 处点击，选择 Remote Host。
添加相关内容，完成以后再把Remote Hosting提升到第1位，表示用此配置编译运行程序。
注意，如果有提示版本不合适，可以选择升级，也可以直接无视。
注意：有时候cmake版本过低会导致无法运行，可以参见以下更新的文章https://www.cnblogs.com/zl0372/p/11658803.html
3 上传代码 配置完成后，CLion一般会自动上传代码，但是如果没有执行，可以手工执行：
上传以后，就可以象本地一样运行程序了。
4 环境测试 在远程服务器 /root/test.txt 编写一个文件，内容随意，如 hello, 192.168.3.149。
然后在本地编写以下代码：
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;fstream&gt; using namespace std; vector&lt;string&gt; &amp;readLines(const string &amp;filename) { vector&lt;string&gt;* lines = new vector&lt;string&gt;(); ifstream file; file.open(filename.c_str(), ios::in); if (file.is_open()) { string strLine; while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11dfba110707a733348ba63756409485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/176063fb61d99e1dc15a9a86e809b251/" rel="bookmark">
			Android 读取csv格式数据文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 什么是csv文件呢？百度百科上说 CSV是逗号分隔值文件格式，也有说是电子表格的，既然是电子表格，那么就可以用Excel打开，那为什么要在Android中来读取这个.csv格式的文件呢？因为现在主流数据格式是采用的JSON,但是另一种就是.csv格式的数据，这种数据通常由数据库直接提供，进行读取。下面来看看简单的使用吧
正文 首先还是先来创建一个项目，名为ReadCSV
准备.csv格式的文件，点击和风APILocationList
下载ZIP，保存到本地，然后解压，这个时候在你的项目文件中新建一个assets文件夹，注意创建的位置
然后打开刚才解压后的文件夹，把iso3166.csv复制到这个新建的文件夹下。
这里先以Text的格式放置，这个时候你会发现右上角多了一个两个操作选项（如果你是第一次复制csv文件的话），分别是安装插件和同意忽略
Android Studio编译器默认是不能直接使用.csv文件的，所以要安装插件，点击Install plugins ,会出现
等待下载
点击OK就会配置你下载的插件，Android Studio每次配置插件之后都要重启一下，插件才会生效的，再重启之前，再安装一个翻译插件吧，如果你已经安装过了，就直接重启吧。
安装翻译插件，点击File → Settings…
点击Plugins,切换到Marketplace ,输入 Translation，等待搜索结果
如上图所示就是第一个，点击Install进行下载安装，安装好之后
点击Restart IDE 进行重启，静静地等待编译通过，这个时候你可以泡一杯咖啡。
可以看到这个时候你的编译器已经可以正常打开.csv格式文件了，然后这个文件中的第一行到第四行都删掉，因为都是没有用的数据，
可以看到都是用逗号分隔开的，这就映证了百度百科的说法，那么现在就可以开始读取这个文件里的内容了，其实就跟读取txt差不多的。
打开MainActivity
然后在onCreate中写入如下代码
InputStreamReader is = null; try { is = new InputStreamReader(getAssets().open("iso3166.csv")); BufferedReader reader = new BufferedReader(is); reader.readLine();//读取每行 String line; while ((line = reader.readLine()) != null) { Log.d("line --&gt;",line); } } catch (IOException e) { e.printStackTrace(); } 代码很简单的，看一下就明白了，运行一下
这样数据就读取到了，那么我们刚才安装的翻译插件起到什么作用呢？你有没有这样的疑惑呢？下面来使用这个翻译插件，选中MainActivity，鼠标右键
第一个是翻译，第二个是翻译和替换，点击第一个
是不是很爽呢？再也不用担心命名的问题了，知道用法之后，我们进入到iso3166.csv,翻译第一行的第一个单词
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/176063fb61d99e1dc15a9a86e809b251/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eec36a6881c90b07f3aa477b4f923004/" rel="bookmark">
			Power BI报表常见格式 2 - 积分卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果需要对某些核心绩效数据进行监控，可以按照积分卡格式创建数据分析报告。积分卡格式报表的特点在于使用清晰易读的视觉对象将注的绩效指标进行展现，使得用户能一目了然的获知当前状况，并及时发。
在积分卡中，经常使用的主要是指示器类型的视觉对象，如KPI和仪表等；其次是信息说明类指示器，如表、卡片，多行卡等。另外，积分卡中也会使用各种图形类视觉对象，如柱状图，线图，饼图等来对关键数据信息进行补充描述。通常情况下，除了每个视觉对象的标题以外，其它文本信息很少出现在积分卡当中。一般积分卡只使用简单的背景图片进行修饰，不会加入其他装饰类图片。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b876b710dc26ac2ee8d8a20716e28e9/" rel="bookmark">
			Python基础（二）：Numpy函数介绍：Meshgrid，mgrid，append等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 np.meshgrid函数np.mgrid函数np.append()函数 [5]参考资料 np.meshgrid函数 meshgrid函数通常使用在数据的矢量化上。它适用于生成网格型数据，可以接受两个一维数组生成两个二维矩阵，对应两个数组中所有的(x,y)对。
meshgrid的作用是：根据传入的两个一维数组参数生成两个数组元素的列表。如果第一个参数是xarray，维度是xdimesion，第二个参数是yarray，维度是ydimesion。那么生成的第一个二维数组是以xarray为行，共ydimesion行的向量；而第二个二维数组是以yarray的转置为列，共xdimesion列的向量。
经常用来生产网格点：示例，生成一个20行30列的网格点矩阵[3]
x = np.linspace(0,500,30) print("x的维度:{},shape:{}".format(x.ndim, x.shape)) print(x) y = np.linspace(0,500,20) print("y的维度:{},shape:{}".format(y.ndim, y.shape)) print(y) xv,yv = np.meshgrid(x, y) print("xv的维度:{},shape:{}".format(xv.ndim, xv.shape)) print("yv的维度:{},shape:{}".format(yv.ndim, yv.shape)) plt.plot(xv, yv, '.') plt.grid(True) plt.show() np.mgrid函数 用法：返回多维结构，常见的如2D图形，3D图形。对比np.meshgrid，在处理大数据时速度更快，且能处理多维（np.meshgrid只能处理2维）
ret = np.mgrid[ 第1维，第2维 ，第3维 ， …]
返回多值，以多个矩阵的形式返回，第1返回值为第1维数据在最终结构中的分布，第2返回值为第2维数据在最终结构中的分布，以此类推。（分布以矩阵形式呈现）。
看一个例子，下面的步长为复数表示点数，左闭右闭，步长为实数表示间隔，左闭右开
X1,Y1 = np.mgrid[1:3:3j,4:5:2j] #1-3，shape= 3*2， X1 Y1 array([[1., 1.], [2., 2.], [3., 3.]]) array([[4., 5.], [4., 5.], [4., 5.]]) 例如3D结构 (3D立方体)，如下[1]：
&gt;&gt;&gt; res = np.mgrid[-1:1:2j,-2:2:3j,-3:3:5j] # x,y,z = res &gt;&gt;&gt; print(res) [[[[-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b876b710dc26ac2ee8d8a20716e28e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5d426925e00dfc262d55fab96299380/" rel="bookmark">
			ESP32-定时器（timer）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 ESP32 内置 4 个 64-bit 通用定时器。每个定时器包含一个 16-bit 预分频器和一个 64-bit 可自动重新加载向上／向下计数器。
• 16-bit 时钟预分频器，分频系数为 2-65536
• 64-bit 时基计数器
• 可配置的向上／向下时基计数器：增加或减少
• 暂停和恢复时基计数器
• 报警时自动重新加载
• 当报警值溢出/低于保护值时报警
• 软件控制的即时重新加载
• 电平触发中断和边沿触发中断
名词扫盲 16-bit 预分频器：分频就是把系统工作频率分频后当做定时器的工作频率，例如系统时钟为12MHz，12分频后定时器的dao工作时钟为1MHz。
按照ESP32的输入时钟频率为80MHZ，换句话说也就是1/80us=0.0125us就会计数加一，如何我们设置分频系数为80，则1us就会计数加一。分频系数范围是0-65536
64-bit 时基计数器：这个更简单，就是累加计数器，按照输出时钟，每过一个’波‘就加一。它的计数范围是0-0xFFFF FFFF FFFF FFFF，非常大大大大大的数。
Arduino层编程 在Arduino编程时因为无需考虑寄存器的设置，我们只需记住该外设的配置思路即可~
定时器的配置思路：
选择定时器（两组四个）配置合适分频系数绑定中断函数配置报警计数器保护值开启报警 其中我们还可以随时停止定时器、停止报警、重启、重设等等……
1、开启定时器 hw_timer_t * timerBegin(uint8_t timer, uint16_t divider, bool countUp); timer（选择定时器）：0-3 divider（分频系数）：0-65536 countUp：是否为向上计数
代码中可以看出，程序执行了该语句后，定时器立即按照默认状态开始了工作。
hw_timer_t * timerBegin(uint8_t num, uint16_t divider, bool countUp){ if(num &gt; 3){ return NULL; } hw_timer_t * timer = &amp;hw_timer[num]; if(timer-&gt;group) { DPORT_SET_PERI_REG_MASK(DPORT_PERIP_CLK_EN_REG, DPORT_TIMERGROUP1_CLK_EN); DPORT_CLEAR_PERI_REG_MASK(DPORT_PERIP_RST_EN_REG, DPORT_TIMERGROUP1_RST); TIMERG1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5d426925e00dfc262d55fab96299380/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5016b61bf8f9bd440473265b9e4f4b6/" rel="bookmark">
			SENet详解-最后一届ImageNet冠军模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：文章仅作知识整理、分享，如有侵权请联系作者删除博文，谢谢！
经典分类网络（传送门）：目录索引、LeNet、AlexNet、VGG、ResNet、Inception、DenseNet、SeNet。
SENet最后一届 ImageNet 2017 竞赛 Image Classification 任务的冠军，也是目前细粒度分类任务的必选基础网络。CNN是通过用局部感受野，基于逐通道基础上，去融合空间信息来提取信息化的特征，对于图像这种数据来说很成功。
为了增强CNN模型的表征能力，许多现有的工作主要用在增强空间编码上，比如ResNet，DenseNet。SENet则主要关注通道上可做点，通过显示的对卷积层特征之间的通道相关性进行建模来提升模型的表征能力；并以此提出了特征重校准机制：通过使用全局信息去选择性的增强可信息化的特征并同时压缩那些无用的特征。
SE 模块可以嵌入到现在几乎所有的网络结构中。通过在原始网络结构的 building block 单元中嵌入 SE 模块，我们可以获得不同种类的 SENet。如 SE-BN-Inception、SE-ResNet、SE-ReNeXt、SE-Inception-ResNet-v2 等等。
1、关于卷积的进一步讨论 近些年来，卷积神经网络在很多领域上都取得了巨大的突破。而卷积核作为卷积神经网络的核心，通常被看做是在局部感受野上，将空间上（spatial）的信息和特征维度上（channel-wise）的信息进行聚合的信息聚合体。卷积神经网络由一系列卷积层、非线性层和下采样层构成，这样它们能够从全局感受野上去捕获图像的特征来进行图像的描述。
然而去学到一个性能非常强劲的网络是相当困难的，其难点来自于很多方面。最近很多工作被提出来从空间维度层面来提升网络的性能，如 Inception 结构中嵌入了多尺度信息，聚合多种不同感受野上的特征来获得性能增益；在 Inside-Outside 网络中考虑了空间中的上下文信息；还有将 Attention 机制引入到空间维度上，等等。这些工作都获得了相当不错的成果。
2、Se模块构建 SE网络就是通过不断的堆叠这个SE模块而成的网络。
假设张量X∈RW′×H′×C′,卷积操作为Ftr,从而得到新的张量U∈RW×H×C。到这里都是传统的卷积过程而已，然后基于U,接下来开始挤压和激励：
挤压(squeeze)：将U固定通道维度不变，对每个feature map进行处理，从而得到一个基于通道的描述符1×1×C,即用一个标量来描述一个map；
作者提出的所谓挤压就是针对每个通道的feature map，进行一次GAP（全局平均池化）：
即将这个feature map表示的矩阵所有值相加，求其平均值。
激励(Excitation)：将挤压得到的通道描述符1×1×C作为每个通道的权重，基于U重新生成一个X˜。
先对挤压后得到的1×1×C的向量基础上先进行一次FC层转换，然后用ReLU激活函数层，然后在FC层转换，接着采用sigmoid激活函数层，该层就是为了模仿LSTM中门的概念，通过这个来控制信息的流通量：
其中，δ是ReLU函数，W1∈RCr×C,W2∈RC×Cr，为了限制模型的复杂程度并且增加泛化性，就通过两层FC层围绕一个非线性映射来形成一个"瓶颈"，其中r作者选了16，最后在得到了所谓的门之后，只要简单的将每个通道的门去乘以原来对应的每个feature map，就能控制每个feature map的信息流通量了：
从上述描述就可以看出，这其实算是一个构建网络块的方法，可以应用到inception和resnet等网络上，从而具有普适性：
整理下来，一个SE模块分为三个部分：
给定一个输入 x，其特征通道数为 c_1，通过一系列卷积希望变换后得到一个特征通道数为 c_2 的特征。即输入通道是c1，输出通道是c2。通过三个操作来重标定前面得到的特征：
1）Squeeze 操作，我们顺着空间维度来进行特征压缩，将每个二维的特征通道变成一个实数，这个实数某种程度上具有全局的感受野，并且输出的维度和输入的特征通道数相匹配。它表征着在特征通道上响应的全局分布，而且使得靠近输入的层也可以获得全局的感受野，这一点在很多任务中都是非常有用的。
2） Excitation 操作，它是一个类似于循环神经网络中门的机制。通过参数 w 来为每个特征通道生成权重，其中参数 w 被学习用来显式地建模特征通道间的相关性。
3）一个 Reweight 的操作，我们将 Excitation 的输出的权重看做是进过特征选择后的每个特征通道的重要性，然后通过乘法逐通道加权到先前的特征上，完成在通道维度上的对原始特征的重标定。
3、keras实现 输入为待处理feature maps，特征通道为c1，输出特征通道为c2，se相当于实现一个Dense(filter)功能。属于Dense的加强版。ratio为通道缩放的比例。squeeze_excite_block函数实现了左边c2到右边c2的映射。
def squeeze_excite_block(input, ratio=16): # 1、构造se_shape channel_axis = 1 if K.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5016b61bf8f9bd440473265b9e4f4b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b33d81c0e1d349f53e060652e4b36dd/" rel="bookmark">
			200人 500人规模园区网设计（中小企业网络）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		200人 500人规模园区网 一、设备选型（光口和电口的交换机，注意设备利旧）二、技术需求三、详细配置STP Eth-trunkVLAN网关 SVIDHCP出口路由 NATNAT端口映射ACLTelnetVLAN 修剪拓扑配置文件 实验要求 ① 设置合理的STP优先级、边缘端口、Eth-trunk 环路会引起广播风暴，设置STP可二层防环，STP是破环协议 ② 企业内网划分多个vlan ，减少广播域大小，提高网络稳定性 ③ 所有设备，在任何位置都可以telnet远程管理 ④ 出口配置NAT ⑤ 所有用户均为自动获取ip地址（核心交换机） ⑥ 在企业出口将内网（web）服务器的80端口映射出去，允许外网用户访问 ⑦ 企业财务服务器，只允许财务部（vlan 30）的员工访问。 对于中小企业网络，医院，高校，酒店。 两层架构（核心层和接入层）
假设企业达到1000人，就加上汇聚层，在我的博客里也能看到1000人
中小型企业，尽量扁平化，如果设备太多，每一个设备都可成为故障点，传输速率也会慢点
人员分布
同个部门员工都在同一层楼，布线好布置，这样就两层架构。
如果员工分散在N层楼，这样就三层架构
企业网按部门划分网段，校园网按宿舍楼层划分网段
PC2是用一个路由器来模拟PC（telnet）
一、设备选型（光口和电口的交换机，注意设备利旧） …
二、技术需求 ①二层：STP Eth-trunk 即冗余技术，把接入层到核心层的两条线捆绑成一条线
让交换机运行快速生成树，核心交换机的优先级要调最低。
②vlan、trunk
vlan即虚拟局域网，隔离广播域，提升网络的稳定性 安全性，同时方便管理和控制这个网络，满足特殊网络的访问控制要求
一个vlan 对应一个网段 对应一个广播域
trunk是对vlan的一个提升，允许多个VLAN通信，接入交换机和核心交换机 通过trunk。
专门单独设置一个管理VLAN，用作远程管理
③网关、SVI配置
④DHCP配置
第一种方式：DHCP是在核心交换机上做的，启用DHCP功能
第二种方式：若找DHCP服务器分配的话，就要在核心交换机上做DHCP中继
配置DHCP地址池，网关DNS
⑤出口NAT配置
NAT：网络地址翻译，将内网私网地址转换成公网地址。在出口的时候 转换成公网地址
⑥服务器端口映射
将内网的某一台服务器的某一个端口 映射到公网上，方便外网直接访问某台设备和服务
⑦ACL配置
控制部门之间的互访
如：财务服务器，禁止部分员工去访问，只允许财务部和董事长
⑧telnet远程管理配置
远程登录，方便运维
⑨vlan修剪配置
通过进一步缩小广播域，进一步提升网络的稳定性和安全性
trunk 只允许有划分的vlan通过，而不是所有vlan通过。 使广播范围小了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b33d81c0e1d349f53e060652e4b36dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c091ce9e5edd2e2e67f6ef6c32e8b8d4/" rel="bookmark">
			C语言-定义一个结构体，其中包括学号，学生姓名，分数三个成员。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义一个结构体变量，为其成员赋初始值0，随后修改变量的三个成员为25，liming，88，随后在屏幕上打印这个变量的三个成员值。
例如：
typedef struct_STUINFO{
int nNum;
char szName[20];
int Score;
}STUINFO,*PSTUINFO;
*/
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct _STUINFO
{
int nNum;
char szName[20];
int Score;
}book = {25,"liming",88};
int main(int *argc, char *argv[])
{
printf("学号是:%d\n姓名是：%s\n分数是:%d\n",book.nNum,book.szName,book.Score);
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a074d8638b9ef42525857fd7744f9d/" rel="bookmark">
			【学习笔记】HTML5 示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例1 HTML &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;link rel="stylesheet" href="./css/common.css" type="text/css"&gt; &lt;title&gt;博文尚美&lt;/title&gt; &lt;script src="js/startMove.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; window.onload = function() { var oDiv = document.getElementById('banner_list'); var oUl = oDiv.getElementsByTagName('ul')[0]; var oOl = oDiv.getElementsByTagName('ol')[0]; var aLi = oOl.getElementsByTagName('li'); var index = 1; for (let i = 0; i &lt; aLi.length; i++) { aLi[i].onclick = function() { startMove(oUl, {left: -1440 * i}); for (let j = 0; j &lt; 4; j++) { aLi[j].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39a074d8638b9ef42525857fd7744f9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc3fdb70536052d8a6242ae5d938b72/" rel="bookmark">
			使用Kali Linux虚拟机破解WiFi密码的一波三折及详细操作步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Kali Linux虚拟机破解WiFi密码的一波三折 声明：此篇使用自己的WiFi作为学习和测试。私自破解他人WiFi属于违法行为！仅供参考学习~望周知！
目录概要 使用Kali Linux虚拟机破解WiFi密码的一波三折波折一波折二波折三实验操作步骤1、连接无线网卡；2、检查网卡是否处于监听模式；3、开启无线网卡监听模式；4、使用ifconfig命令查看无线网卡名称；5、扫描环境周围的WiFi网络信号；6、抓取握手包；7、查看抓包情况；8、破解WiFi密码，进行跑包 波折一 波折二 波折三 实验操作步骤 1、连接无线网卡； 2、检查网卡是否处于监听模式； 3、开启无线网卡监听模式； 4、使用ifconfig命令查看无线网卡名称； 5、扫描环境周围的WiFi网络信号； 6、抓取握手包； 7、查看抓包情况； 8、破解WiFi密码，进行跑包 使用Kali Linux 暴力破解wifi密码详细步骤所谓暴力破解就是穷举法，将密码字典中每一个密码依次去与握手包中的密码进行匹配，直到匹配成功。所以能否成功破解wifi密码取决于密码字典本身是否包含了这个密码。破解的时间取决于CPU的运算速度以及密码本身的复杂程度。如果WiFi密码设得足够复杂，即使有一个好的密码字典，要想破解成功花上个几天几十天甚至更久都是有可能的。
为了测试这个实验，我前期准备了好久。真是“一波三折”。
第一波：修复VMware Workstation 软件中某个服务（VMware USB Arbitration Service）未能正常启动的bug。
1、出现的问题：
可移动设备无法正常显示出来。
2、原因分析：
是因为windows服务中无法正常启动VMware USB Arbitration Service 所导致的。
3、解决方法：
操作步骤：打开"控制面板"——&gt; 点击“卸载程序” ——&gt;找到VMware Workstation程序——&gt;右击，选择“更改”。
注意：更改此应用程序的时候，需要关闭此软件。
等待修复完成后，重新启动即可。
第二波：未能正确购买到Kali Linux所支持的无线网卡做测试。
温馨提示：使用Kali linux，先准备好一个适合Kali系统的USB外置无线网卡，注意内置网卡并不适合做渗透测试。
用于抓取无线数据包稳定和兼容比较好的三款芯片：
1.RT3070(L)/RT5572：即插即用支持混杂模式、注入模式、AP模式。
2.RT8187(L)：即插即用支持混杂模式、注入模式、AP模式。
3.AR9271：即插即用支持混杂模式、注入模式、AP模式。
对于Linux（像Ubuntu、Kali、Debian、Centos等等），这三款芯片即插即用，无需再手动安装驱动。
参考链接：Kali Linux无线网卡常见类型及选择
第三波：Kali Linux 外接无线网卡显示不出来的问题
操作步骤：
通过演示动画，连接无线网卡设置。
连接以后，在虚机的右下角部分可以看到类型USB接口的图案显亮出来，即表示连接成功。
再次使用 airmon-ng 命令进行查看，检查网卡是否支持监听模式。结果如图所示。
以上就是我做实验前的“一波三折”，希望能够给你们提供一些帮助与解答。
接下来进入正式实验环节。
实验操作步骤：
1、连接无线网卡（即在波折三中有提及，此处略过… …）
2、使用airmon-ng命令检查网卡是否支持监听模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcc3fdb70536052d8a6242ae5d938b72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f6221bfdb47c0c081600a9ecea4b801/" rel="bookmark">
			SpringSecurity安全框架（配置类版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 1.1 SpringSecurity 框架用法简介 用户登录系统时我们协助 SpringSecurity 把用户对应的角色、权限组装好，同时把各个 资源所要求的权限信息设定好，剩下的“登录验证”、“权限验证”等等工作都交给 SpringSecurity
1.2 权限管理过程中的相关概念 1.2.1 主体 英文单词：principal 使用系统的用户或设备或从其他系统远程登录的用户等等。简单说就是谁使用系统 谁就是主体
1.2.2 认证 英文单词：authentication 权限管理系统确认一个主体的身份，允许主体进入系统。简单说就是“主体”证明 自己是谁。 笼统的认为就是以前所做的登录操作。
1.2.3 授权 英文单词：authorization
将操作系统的“权力”“授予”“主体”，这样主体就具备了操作系统中特定功能的 能力。所以简单来说，授权就是给用户分配权限。
1.3 security的特点 Spring 技术栈的组成部分，通过提供完整可扩展的认证和授权支持保护你的应用程序。官网地址：
https://spring.io/projects/spring-security
SpringSecurity 特点：
1）和 Spring 无缝整合。
2） 全面的权限控制。 3）专门为 Web 开发而设计。 4）旧版本不能脱离 Web 环境使用。 5）新版本对整个框架进行了分层抽取，分成了核心模块和 Web 模块。单独 引入核心模块就可以脱离 Web 环境。
6）重量级
2. 环境准备 2.1 新建工程 2.1.1 引入SpringMVC依赖 &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.bjc&lt;/groupId&gt; &lt;artifactId&gt;springsecuryti-web&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f6221bfdb47c0c081600a9ecea4b801/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0771905faa45452423668ff1561254d4/" rel="bookmark">
			VBA获取汉字拼音首字母的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汉字转拼单首字母 现在各种查询中，一般都支持拼音首字母查询，下面的函数可以获得汉字的首字母。 Public Function PY(myStr) Dim Str$, L$, Temp$, 特殊字$ Str = Replace(Replace(myStr, " ", ""), "　", "") dict = [{"吖","a";"八","b";"擦","c";"咑","d";"鵽","e";"发","f";"伽","g";"哈","h";"丌","j";"咔","k";"垃","l";"妈","m";"拿","n";"哦","o";"妑","p";"七","q";"然","r";"仨","s";"他","t";"屲","w";"夕","x";"丫","y";"帀","z"}] 特殊字 = "仇Q覃Q" For i = 1 To Len(Str) L = Mid$(Str, i, 1) j = InStr(tmp, Mid(Str, i, 1)) If L Like "[一-龥]" Then Temp = Temp &amp; IIf(j, Mid(特殊字, j + 1, 1), UCase(Application.Lookup(L, dict))) Else Temp = Temp &amp; L End If Next i PY = Temp End Function ——专注办公软件的二次开发及培训，你有问题，我有思路！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0771905faa45452423668ff1561254d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48d8ec96bb6ec6477f6c474198e9d8f9/" rel="bookmark">
			GAN生成对抗网络入门理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有兴趣阅读GAN鼻祖之作的给出链接： 2014年NIPS Generative Adversarial Net
原理解释 GAN核心思想：生成器G与判别器D，双方博弈。
生成器G的输入是手工样本/噪声/随机数之类，通过模型学习（包装）成一个逼真的样本进行输出。这里所谓逼真指的是逼近真实的样本。目的：使得自己造样本的能力尽可能强，强到什么程度呢，你判别网络没法判断我是真样本还是假样本。判别器D的输入是生成器的输出，二分类模型判断该输入是否是真实样本。目的：判别出来属于的一张图来自真实样本集还是假样本集。假如输入的是真样本，网络输出就接近1，输入的是假样本，网络输出接近0，达到完美状态。博弈过程：生成网络与判别网络的目的正好是相反的，一个说我能判别的好，一个说我让你判别不好。判别网络说，我很强，来一个样本我就知道它是来自真样本集还是假样本集。生成网络就不服了，说我也很强，我生成一个假样本，虽然我生成网络知道是假的，但是你判别网络不知道呀，我包装的非常逼真，以至于判别网络无法判断真假，那么用输出数值来解释就是，生成网络生成的假样本进去了判别网络以后，判别网络给出的结果是一个接近0.5的值，极限情况就是0.5，也就是说判别不出来了。 模型实现 扯完皮了，下面看一下怎么样训练模型。
生成模型与对抗模型可以说是完全独立的两个模型，好比就是完全独立的两个神经网络模型，他们之间没有什么联系。那么训练这样的两个模型的大方法就是：单独交替迭代训练。
下图给出模型示意，红线以上是判别模型，红线以下是生成模型+判别模型。
第一步：（训练判别模型）
初始化生成模型，输入一堆随机数组，得到一堆假的样本集，而真样本集默认给定。制定标签：真样本集所有的类标签都为1，而假样本集的所有类标签都为0。单就判别网络来说，此时问题就变成了一个再简单不过的有监督的二分类问题了，直接送到神经网络模型中训练就完事了。这样我们就得到了具备一定判别能力的判别模型。
第二步：（训练生成模型）
生成网络的训练其实是对生成-判别网络串接的训练，就像上图中显示的那样。输入噪声数组Z，通过生成模型生成了假样本，此时很关键的一点来了，既然我们已经有了初具判断能力的判别模型，我们固定判别模型参数，将这些假样本的标签都设置为1，使得生成模型向着真样本分布去拟合。
好了，重新顺一下思路，现在对于生成网络的训练，我们有了样本集（只有假样本集，没有真样本集），有了对应的label（全为1），是不是就可以训练了？有人会问，这样只有一类样本，训练啥呀？谁说一类样本就不能训练了？只要有误差就行。还有人说，你这样一训练，判别网络的网络参数不是也跟着变吗？没错，这很关键，所以在训练这个串接的网络的时候，一个很重要的操作就是不要判别网络的参数发生变化，也就是不让它参数发生更新，只是把误差一直传，传到生成网络那块后更新生成网络的参数。这样就完成了生成网络的训练了。
重复上述两步：
完成第二步后，可以根据目前新的生成网络再对先前的那些噪声Z生成新的假样本，并且训练后的假样本应该是更真了才对。这样又可以重复上述过程了。我们把这个过程称作为单独交替训练。我们可以实现定义一个迭代次数，交替迭代到一定次数后停止即可。这个时候我们再去看一看噪声Z生成的假样本会发现，原来它已经很真了。
目标公式 max过程固定G生成模型优化D判别模型，min过程反之。
优势 GAN强大之处在于可以自动的学习原始真实样本集的数据分布（生成模型）；
GAN强大之处在于可以自动的定义潜在损失函数。（判别模型）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94a48492aa111ce4f2cc061eef59fd3d/" rel="bookmark">
			软件制造工程学习笔记(详尽版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件制造工程学习笔记 第一章 软件工程学概述软件危机软件工程 第二章 软件设计基本概念设计过程设计原理*模块化抽象 第三章 详细设计结构程序设计人机界面设计过程设计工具程序流程图盒图（N-S图）PAD图判定表判定树过程设计语言（PDL） 面向数据结构的设计方法Jackson图改进的Jackson图Jackson方法 程序复杂度的定量度量McCabe方法Halstead方法 小结 第四章 软件编码选择程序设计语言代码规范代码组织与风格注释命名声明语法结构代码版本控制（SVN) 第五章 软件测试软件测试基础目标准则方法测试步骤测试阶段的信息流 单元测试代码审查计算机测试 集成测试确认测试白盒测试逻辑覆盖控制结构测试 黑盒测试技术等价划分 第一章 软件工程学概述 软件危机 典型表现 对软件的开发成本和进度的估计常常很不准确用户对“已完成的”软件系统不满意的现象经常发生软件产品的质量往往靠不住软件常常是不可维护的（难以或无法添加新功能）软件通常没有适当的文档资料软件成本在计算机系统总成本中所占的比例逐年上升软件开发生产率的提高速度远赶不上软件需求的提高速度 产生原因 与软件本身特点有关 软件是逻辑部件软件不会被“用坏”，如果发现了错误，很可能是开发时期引入软件规模爆发，而且程序复杂性将随着程序规模的增加而呈指数上升 与软件开发和维护的方法不正确有关 忽视软件需求分析的重要性轻视软件维护 消除软件危机的途径 消除“软件就是程序”的错误观念软件开发应是组织良好、管理严密、各类人员协同配合共同完成的项目成熟的软件开发技术和方法软件工具和软件工程支持环境 软件工程 ​ 软件工程是指导计算机软件开发和维护的一门工程学科。采用工程的概念、原理、技术和方法来开发和维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程
本质特性
关注于大型程序的构造
中心课题是控制复杂性
将复杂问题分解成可理解的问题，并使各部分之间保持简单的通信关系，此法不能降低复杂性但可使其变为可管理的
软件经常变化
需求一直在变化
开发软件的效率非常重要
和谐地合作是开发软件的关键
必须有效的支持它的用户
意味着需要仔细研究用户以确定适当的功能需求、可用性要求等，应写出用户手册和培训材料，注意建立使用新系统的环境（培训用户，使其习惯于新的工作流程）
在软件工程领域中通常由具有一种文化背景的人替具有另一种文化背景的人创造产品
软件开发人员通常并不是其他领域专家但需要为其他领域开发软件，就需要事先了解那些领域的流程
基本原理
用分阶段的生命周期计划严格管理
坚持进行阶段评审
不能等到编码阶段结束后在进行质量保证工作，理由如下：
错误出现往往是由于设计造成的（设计错误占比63%，编码错误占比37%）错误发现与改正得越晚，改正所需付出的代价越高 实行严格的产品控制
基准配置管理（基线配置、变动控制）：为保持软件各个配置成分的一致性而进行的管理
基线配置：他们是经过阶段评审后的软件配置成分（各个阶段产生的文档或程序代码）
变动控制：一切有关修改软件的建议，特别是涉及对基准配置的修改建议都必须经过审批才可修改
采用现代程序设计技术
结果应能清楚地审查
根据软件开发项目的总目标及完成期限，规定开发组织的责任和产品标准，从而使所得到的结果能够清楚地审查
开发小组的人员应该少而精
承认不断改进软件工程实践的必要性
软件工程方法学
软件工程包括技术和管理两方面的内容
​ 管理：通过计划、组织和控制等一系列活动，合理地配置和使用各种资源，以达到既定目标的过程
三要素：工具、方法、过程
方法：完成软件开发的各项任务的技术方法，回答“怎样做”的问题
工具：运用方法而提供的自动的或半自动的软件工程支撑环境 过程：为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤 传统方法学：也称为生命周期方法学或结构化范型
​ 采用结构化技术（结构化分析、设计、实现）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94a48492aa111ce4f2cc061eef59fd3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c116caa5c4691758eff88b266a0c2fb/" rel="bookmark">
			计算机网络学习笔记(详尽版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络学习笔记 计算机网络第一章 定义和特点网络定义功能特点组成类别性能结构本章重要概念 第二章 物理层基本概念和标准数据通信基础知识物理层下的传输媒体引导型传输媒体非引导型传输媒体 信道复用技术频分复用、时分复用和统计时分复用波分复用(WDM) 数据传输系统网络接入技术 第三章 数据链路层使用点对点信道的数据链路层数据链路层协议 点对点协议PPP使用广播信道的数据链路层局域网的数据链路层CSMA/CD协议使用集线器的星形拓扑以太网的信道利用率以太网的MAC层 拓展的以太网在物理层拓展以太网在数据链路层扩展以太网虚拟以太网 高速以太网100BASE-T以太网(802.3u)吉比特以太网(802.3z)10吉比特以太网（10GE）和更快的以太网使用以太网进行宽带接入 第四章 网络层网络层提供的两种服务网际协议IP虚拟互联网络分类的IP地址IP地址与硬件地址地址解析协议ARPIP分组格式及说明IP层分组转发的流程 划分子网和构造超网划分子网使用子网时分组的转发无分类编址CIDR网际控制报文协议ICMP互联网路由选择协议有关路由选择协议的几个基本概念分层次的路由选择协议 内部网关协议RIP内部网关协议OSPF外部网关协议BGP 第五章 运输层运输层协议概述运输层概述运输层地位及目的 TCP/IP体系中的运输层运输层中的两个协议运输层的端口用户数据报协议UDP传输控制协议TCPTCP的可靠传输TCP流量控制TCP传输效率 TCP的拥塞控制TCP拥塞控制方法主动队列管理AQM \*TCP的运输链接管理 第六章复习第一章第二章第三章第四章第五章第六章 计算机网络 第一章 定义和特点 网络 网络是一个统称，泛指把人或物连接起来的网络
定义 计算机网络是用通信线路将分散在不同地点并具有独立功能的多个计算机系统相互连接，按照网络协议进行数据通信，实现共享资源的计算机之集合。
要点：计算机是独立，在协议的支持下进行工作，目的是实现资源共享，互联的手段是多种多样的（无线或有线）
计算机网络的精准定义未被统一，书本的定义是：
计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特殊目的。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用
功能 实现资源共享提高系统的可靠性和可用性 特点 连通性共享 组成 由核心和边缘部分组成
边缘部分
由所有连接在互联网上的主机组成，这部分是用户直接使用的，用来进行通信和资源共享
端系统间的两种连接方式：
客户-服务器方式（C/S） 客户是服务请求方，服务器是服务提供方
客户程序：
被用户调用后运行，在通信时主动向服务器发起通信，所以客户程序必须知道服务器程序的地址不需要很复杂的操作系统 服务器程序：
专门用来提供某种服务的程序，可以同时服务多个客户系统启动后即自动调用并一直不断地运行，被动地等待并接收来自各地的客户的通信请求，所以服务器程序不需要知道客户程序的地址一般需要有强大的硬件和高级的操作系统支持 对等连接方式（P2P）
两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方，只要都运行了P2P软件，他们就能镜像平等对等的连接通信
对等连接方式可以支持大量对等用户同时工作
核心部分
由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）
电路交换：使用交换机来使设备间可以两两通信而减少连线复杂度
​ 连接建立后会建立一条专用的物理通路用以通信，在通话的全部时间内，这两个用户始终占用端到端的通信资源
交换：按照某种方式动态分配电路交换的资源
优点 实时性强，时延小（连接建立后）交换设备成本低 缺点 线路利用率低（独占物理线路）传输效率低（计算机数据往往是突发式传输，用来传输数据的时间短）电路接续时间长 适用于信息量大、长报文、占用时间长、使用频率高的线路特点 电路交换必定是面向连接的
分三个阶段
​ 建立连接–&gt;通信–&gt;释放连接
报文交换
原理：信息以报文（逻辑上完整的信息段）为单位进行存储转发特点线路利用率高
2. 要求中间结点（网络通信设备）缓冲大延迟时间长 分组交换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c116caa5c4691758eff88b266a0c2fb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/359/">«</a>
	<span class="pagination__item pagination__item--current">360/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/361/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>