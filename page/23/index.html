<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a290d7ab970686ee993a3e499394ae7d/" rel="bookmark">
			案例104:基于微信小程序的随堂测系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
微信端功能模块的实现
微信端注册界面
微信端登录界面
首页界面
测试信息界面
测试信息详情界面
随堂测试界面
用户信息界面
服务端功能模块的实现
服务端登录界面
学生管理界面
教师管理界面
测试信息管理界面
随堂测试管理界面
课程类型管理界面
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 移动互联网时代的到来，微信的普及，致使基于微信小程序的系统越来越多，因此，针对学校随堂测方面的需求，开发了本随堂测微信小程序。
本文重点阐述了随堂测微信小程序的开发过程，以实际运用为开发背景，基于微信平台，运用了Java技术和MYSQL作为系统数据库进行开发，充分保证系统的安全性和稳定性。本系统界面良好，操作简单方便，通过系统概述、系统分析、系统设计、数据库设计、系统测试这几个部分，详细的说明了系统的开发过程，最后并对整个开发过程进行了总结，实现了随堂测的重要功能。
本随堂测微信小程序运行效果稳定，操作方便、快捷，界面友好，是一个功能全面、实用性好、安全性高，并具有良好的可扩展性、可维护性的随堂测平台。
系统展示 微信端功能模块的实现 微信端注册界面 未有账号的学生可进入注册界面进行注册操作
微信端登录界面 学生在登录界面输入正确的账号和密码，点击登录按钮进行登录操作 首页界面 学生在首页界面可查看测试信息 测试信息界面 学生在测试信息界面可查看已有测试信息，并可选择查看详情 测试信息详情界面 学生可选择测试查看详情，在详情界面可选择进行测试 随堂测试界面 学生可查看随堂测试信息，并可查看详情 用户信息界面 学生可进入用户信息界面进行修改个人资料 服务端功能模块的实现 服务端登录界面 管理员要想进入系统后台进行管理操作，必须登录系统后台 学生管理界面 管理员在学生管理界面可查看已有学生信息，对已有学生信息可进行修改和删除操作，同时管理员也可添加学生信息
教师管理界面 管理员可添加、修改和删除教师信息
测试信息管理界面 管理员可进行测试信息管理操作，对已有测试信息信息可进行修改和删除操作，同时管理员也可添加测试信息
随堂测试管理界面 管理员可查看所有随堂测试信息，并可对其进行审核、修改和删除操作
课程类型管理界面 管理员可增删改查课程类型信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a290d7ab970686ee993a3e499394ae7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17efffcbfbf4869359ba128104bf4cb8/" rel="bookmark">
			代码随想录day60:贪心算法｜84.柱状图中最大的矩形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		84. Largest Rectangle in Histogram 进行优化，如果我们想获得left就给他left即可，我们只需要在求宽度的时候用到left,而没必要修改原数组。
所以给栈插入一个虚拟索引-1 思考过程：
left应该为多少呢？
首先确定left是什么？ left是索引，是左边界的柱子
那第一个元素是8的时候，他的面积怎么求的，不就是宽度1 * 高度8.
他的左边界应该是多少呢？
根据公式可得：
width = 1 - left - 1 == 1 ，可知left == -1 ! 害！这不就是索引0的左边吗？索引为-1
相当于给数组第一个元素左侧插入了一个虚拟元素嘛。
func largestRectangleArea(heights []int) int { heights = append(heights, 0) stack := []int{-1} maxArea := 0 for i, h := range heights { for len(stack) &gt; 1 &amp;&amp; h &lt; heights[stack[len(stack)-1]] { height := heights[stack[len(stack)-1]] stack = stack[:len(stack)-1] width := i - stack[len(stack)-1] - 1 maxArea = max(maxArea, height*width) } stack = append(stack, i) } return maxArea } 详解版
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17efffcbfbf4869359ba128104bf4cb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be24cf056deeafe3c609c39148b1456d/" rel="bookmark">
			【EAI 005】EmbodiedGPT：通过具身思维链进行视觉语言预训练的具身智能大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文描述：EmbodiedGPT: Vision-Language Pre-Training via Embodied Chain of Thought
论文作者：Yao Mu, Qinglong Zhang, Mengkang Hu, Wenhai Wang, Mingyu Ding, Jun Jin, Bin Wang, Jifeng Dai, Yu Qiao, Ping Luo
作者单位：The University of Hong Kong, Shanghai AI Laboratory, Noah’s Ark Laboratory
论文原文：https://arxiv.org/abs/2305.15021
论文出处：NeurIPS 2023 spotlight
论文被引：42（01/05/2024）
项目主页：https://embodiedgpt.github.io/
论文代码：https://github.com/EmbodiedGPT/EmbodiedGPT_Pytorch
Abstract 具身人工智能（Embodied AI，EAI）是机器人技术的一个重要前沿领域，它能够为机器人规划和执行行动序列，以完成物理环境中的长周期（long-horizon）任务。本文提出了 EmbodiedGPT，它是一种端到端多模态具身人工智能基础模型，赋予具身Agent多模态理解和执行能力。为此：
i）我们制作了一个大规模的具身规划数据集，称为 EgoCOT。该数据集包括从 Ego4D 数据集中精心挑选的视频以及相应的高质量语言指令。具体来说，我们利用思维链（Chain of Thoughts，CoT）模式生成一系列子目标，以实现有效的具身规划。ii）我们为 EmbodiedGPT 引入了一种高效的训练方法，通过前缀微调（Prefix Tuning）使 7B 大语言模型（LLM）适应 EgoCOT 数据集，从而生成高质量的规划。iii）我们引入了一种从 LLM 生成的规划查询中提取任务相关特征的范式，从而在高层次（High-Level）规划和低层次（Low-Level）控制之间形成闭环。 广泛的实验表明，EmbodiedGPT 在具身任务上非常有效，包括具身规划（embodied planning），具身控制（embodied control），视觉描述（visual captioning）和视觉问答（visual question answering）。EmbodiedGPT 通过提取更有效的特征，显著提高了具身控制任务的成功率。与使用 Ego4D 数据集进行微调的 BLIP-2 基准相比，EmbodiedGPT 在 Franka Kitchen 基准上的成功率提高了 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be24cf056deeafe3c609c39148b1456d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/329d314dbae04c4fdd0cefa46c2c077c/" rel="bookmark">
			【EAI 006】ChatGPT for Robotics：将 ChatGPT 应用于机器人任务的提示词工程研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文标题：ChatGPT for Robotics: Design Principles and Model Abilities
论文作者：Sai Vemprala, Rogerio Bonatti, Arthur Bucker, Ashish Kapoor
作者单位：Scaled Foundations, Microsoft Autonomous Systems and Robotics Research
论文原文：https://arxiv.org/abs/2306.17582
论文出处：TMLR
论文被引：148（01/05/2024）
论文代码：https://github.com/microsoft/PromptCraft-Robotics，1.6k star
项目主页：http://aka.ms/ChatGPT-Robotics
Abstract 本文介绍了一项关于将 OpenAI 的 ChatGPT [1] 用于机器人应用的实验研究。我们概述了一种策略，该策略结合了提示工程的设计原则和高级函数库的创建，使 ChatGPT 能够适应不同的机器人任务，模拟器和外形因素（form factors）。我们重点评估了不同提示工程技术和对话策略在执行各类机器人任务时的有效性。除了使用特定任务的提示功能和通过对话进行闭环推理之外，我们还探索了 ChatGPT 使用自由形式对话，解析 XML 标记和合成代码的能力。我们的研究涵盖了机器人领域的一系列任务，从基本的逻辑，几何和数学推理一直到复杂的领域，如空中导航，操纵和具身Agent。我们的研究表明，ChatGPT 可以有效地解决其中几项任务，同时允许用户主要通过自然语言指令与之交互。除了这些研究之外，我们还介绍了一个名为 PromptCraft 的开源研究工具，其中包含一个平台，研究人员可以通过该平台合作上传并投票选出机器人应用中的优秀提示方案示例，以及一个集成了 ChatGPT 的机器人模拟器示例，使用户更容易开始将 ChatGPT 用于机器人。
1. Introduction 自然语言处理（NLP）技术的飞速发展带动了大型语言模型（LLM）的发展，如 BERT [2]，GPT-3 [3] 和 Codex [4]，它们正在为广泛的应用带来变革。这些模型在文本生成，机器翻译和代码合成等各种任务中取得了令人瞩目的成果。OpenAI ChatGPT [1]是这一系列模型中的最新成员，它是一个预训练的文本生成模型，并通过人类反馈进行了微调。与之前主要在单一提示下运行的模型不同，ChatGPT 通过对话提供了特别令人印象深刻的交互技能，将文本生成与代码合成相结合。我们在本文中的目标是研究 ChatGPT 的能力能否以及如何推广到机器人领域。
与纯文字应用不同，机器人系统需要深入了解现实世界的物理学，环境背景以及执行物理动作的能力。生成式机器人模型需要具备强大的常识性知识和复杂的世界模型，并能与用户互动，以物理上可行且在现实世界中合理的方式解释和执行命令。这些挑战超出了语言模型的原有范围，因为它们不仅要理解给定文本的含义，还要将意图转化为符合逻辑顺序的物理动作。
近年来，人们一直在尝试将语言融入机器人系统。这些努力主要集中在使用语言标记嵌入模型，LLM 特征和多模式模型特征，以适应特定的形式因素或场景。应用范围包括：
视觉语言导航[5, 6]基于语言的人机交互[7, 8]视觉语言操纵控制[9, 10, 11] 然而，尽管在机器人技术中使用 LLMs 具有潜在的优势，但大多数现有方法都受到了严格的范围和有限的函数集（limited set of functionalities）的限制，或者由于其开环性质，无法进行流畅的交互，也无法根据用户反馈修正行为。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/329d314dbae04c4fdd0cefa46c2c077c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/413d05bc40e3fd3ace7edbc04a2904ad/" rel="bookmark">
			【读书笔记】《白帽子讲web安全》跨站脚本攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
第二篇 客户端脚本安全
第3章 跨站脚本攻击（XSS）
3.1XSS简介
3.2XSS攻击进阶
3.2.1初探XSS Payload
3.2.2强大的XSS Payload
3.2.2.1 构造GET与POST请求
3.2.2.2XSS钓鱼
3.2.2.3识别用户浏览器
3.2.2.4识别用户安装的软件
3.2.2.5CSS History Hack
3.2.2.6获取用户的真实IP地址
3.2.3XSS攻击平台
3.2.4终极武器：XSS Worm
3.2.5调试JavaScript
3.2.6XSS构造技巧
3.2.6.1利用字符编码
3.2.6.2绕过长度限制
3.2.6.3使用&lt;base&gt;标签
3.2.6.4window.name的妙用
3.2.7变废为宝：Mission Impossible
3.2.8最容易被忽视的角落：Flash XSS
3.2.9真的高枕无忧吗：JavaScript开发框架
3.3XSS的防御
3.3.1四两拨千斤：HttpOnly
3.3.2输入检查
3.3.3输出检查
3.3.4正确地防御XSS
3.3.5处理富文本
3.3.6防御DOM Based XSS
3.3.7换个角度看XSS的风险
3.4小结
前言： 根据个人浅薄的理解，仅记录我现阶段认为有直接价值的部分，余下只作了解。
（也就是考试周打发时间的消遣，换换脑子，看书更多是观念与知识面上的学习）
第二篇 客户端脚本安全 第3章 跨站脚本攻击（XSS） 3.1XSS简介 跨站脚本攻击，Cross Site Script，在安全领域叫XSS。
XSS攻击通常是黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时控制用户浏览器。
XSS根据效果的不同可以分成三类：
①反射型XSS：又叫“非持久型XSS”，其只是简单地把用户输入的数据“反射”给浏览器。黑客需要诱使用户“点击”一个恶意链接才能攻击成功。
②存储型XSS：又叫“持久型XSS”，这种XSS具有很强的稳定性，其会把黑客输入的恶意数据“存储”在服务器端。所有向服务器请求这段数据的用户，都会在他们的浏览器执行恶意代码。
③DOM型XSS：其是通过修改页面的DOM节点形成的XSS，这种类型的XSS并非按照“数据是否存放在服务器端”来划分，从效果上来说也是反射型XSS。
这里给出两种payload:
' onclick=alert(/xss/) // 拼接后：&lt;a href='' onclick=alert(/xss/) //'&gt;testLink&lt;/a&gt; '&gt;&lt;img src=# onerror=alert(/xss/) /&gt;&lt;' 拼接后：&lt;a href=''&gt;&lt;img src=# onerror=alert(/xss/) /&gt;&lt;''&gt;testLink&lt;/a&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/413d05bc40e3fd3ace7edbc04a2904ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2be0c7175cf6b0fdcc617c2f1a2d2c3/" rel="bookmark">
			西电期末1035.可构造三角形个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.题目 二.分析与思路 依旧是遍历+判断，三角形任意两边之和大于第三边，读题！！！：连续的三个数！！！
三.代码实现 #include&lt;bits/stdc++.h&gt;//万能头 int main() { int n; scanf("%d",&amp;n); int num[n]; for(int i=0;i&lt;n;i++){ scanf("%d",&amp;num[i]); } int ans=0; for(int i=0;i&lt;n-2;i++){ if(num[i]+num[i+1]&gt;num[i+2]&amp;&amp;num[i+1]+num[i+2]&gt;num[i]&amp;&amp;num[i+2]+num[i+1]&gt;num[i])ans++; }//判断累加 printf("%d",ans); return 0; } 四.评价 一开始看错题了（QAQ）：以为是任选三个数据，这样的话得开三重循环了
#include&lt;bits/stdc++.h&gt; int main() { int n; scanf("%d",&amp;n); int num[n]; for(int i=0;i&lt;n;i++){ scanf("%d",&amp;num[i]); } int ans=0; for(int i=0;i&lt;n-2;i++){ for(int j=i+1;j&lt;n-1;j++){ for(int q=j+1;q&lt;n;q++){ if(num[i]+num[j]&gt;num[q]&amp;&amp;num[i]+num[q]&gt;num[j]&amp;&amp;num[q]+num[j]&gt;num[i]){ ans++; printf("%d%d%d\n",num[i],num[j],num[q]); } } } } printf("%d",ans); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3e7192b8fc5c23e3b730eb7c5f811c6/" rel="bookmark">
			西电期末1034.勒让德多项式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.题目 二.分析与思路 带递推式即可，注意数据类型的使用和转换！
三.代码实现 #include&lt;bits/stdc++.h&gt;//万能头 int main() { int n; double x; scanf("%d%lf",&amp;n,&amp;x); double ans=0; double num[n]; num[0]=1; num[1]=x;//初始化 ans+=num[1]; for(int i=2;i&lt;=n;i++){ double i0=i*1.0;//类型转换 num[i]=((2*i0-1)*num[i-1]*x-(i0-1)*num[i-2])/i0;//带递推式 ans+=num[i];//累加 } printf("%.4lf",ans);//精度 return 0; } 四.评价 按部就班即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bdc0ebde8e363986f3249178d4793e3/" rel="bookmark">
			python实现一亿个无序数找出Top100
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 一、python实现一亿个无序数找出 Top 1001、heapq.heappush详解a、什么是heapq.heappushb、heapq.heappush的语法 二、2215. 找出两数组的不同1、集合的差集 三、计算相同字符个数，并按个数排序，返回前 k 个四、返回 s2 在 s1 中的位置，要求不能使用 indexOf，并且输入任何字符串都能返回位置，如果没有，返回 0； 一、python实现一亿个无序数找出 Top 100 思路：
使用堆数据结构
1、先创建一个空的堆
2、遍历一亿个无序数，对于每个数，如果堆的大小小于100，我们将该数直接加入堆中；
3、否则，我们将该数与堆顶元素比较，如果大于堆顶元素，将堆顶元素弹出，再将该数加入堆中。
4、最后，我们将堆中的元素按照降序排序，即可得到TOP100.
1亿个数
import heapq def find_top_100(numbers): heap=[] for num in numbers: if len(heap)&lt;100: heapq.heappush(heap,num) else: if num &gt; heap[0]: heapq.heappop(heap) heapq.heappush(heap,num) return sorted(heap,reverse=True) # 示例用法 numbers = [1000000000 - i for i in range(100000000)] top_100 = find_top_100(numbers) print(top_100) 假设有1亿个数换成——》18个数，取TOP 10
import heapq def find_top_100(numbers): heap=[] for num in numbers: if len(heap)&lt;10: heapq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bdc0ebde8e363986f3249178d4793e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ae037d37a2f5cf717213d3fb9b3a35/" rel="bookmark">
			C&#43;&#43;中的移动构造函数和移动赋值运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中的移动构造函数和移动赋值运算符 移动构造函数是一个特殊的构造函数，它能够从一个右值引用（rvalue reference）创建新的对象，而无需进行深拷贝（deep copy）。我们可以将移动构造函数比喻成搬家时的快递员。
假设你搬家，有一堆家具需要装进卡车。传统的深拷贝（复制构造函数）就像是你把每一件家具都精心地复制一份，然后放进卡车上。这个过程费时费力，而且你原本的家具还要保留。
但是，如果你找来一位勇敢的快递员（移动构造函数），他们可以直接将你的家具移动到新的屋子里，而不用复制。这样，节省了时间和精力，而且你原本的家具可以顺利放进新的屋子。
在代码中，移动构造函数使用右值引用作为参数，并且我们将原始对象的资源直接转移到新对象中，而不是进行复制。这就如同快递员将家具从旧的房子搬到新的房子中，节省了时间和空间开销。
总的来说：可以理解为快速的拷贝构造函数
移动赋值操作符允许我们将一个对象的资源转移到另一个对象上。可以把移动赋值操作符比喻成两个人交换工作岗位。
想象一下，你在一家公司工作，有一天你被调往另外一个部门。传统的方式是，你将自己的工作内容复制一份，再将新工作的内容复制回来，形成了两份一样的工作内容。这样的操作显然很冗余。
然而，通过移动赋值操作符，你可以直接将自己的工作内容交给新的员工，并且接管他们原本的工作，省去了不必要的复制步骤。
在代码中，移动赋值操作符也使用右值引用作为参数。我们将源对象的资源直接转移到目标对象中，同时将源对象恢复到一种可安全销毁或重新赋值的状态。这就如同两个人交换工作岗位，互相拥有对方的资源和责任。
总的来说：可以理解为快速的赋值运算符。（比一般的更快，因为无需深拷贝）
移动构造函数的声明语法如下：
class Sample { private: Type* ptrResource; public: Sample(Sample&amp;&amp; moveSource) // Move constructor, note &amp;&amp; { ptrResource = moveSource.ptrResource; // take ownership, start move moveSource.ptrResource = NULL; } Sample&amp; operator= (Sample&amp;&amp; moveSource)//move assignment operator, note &amp;&amp; { if(this != &amp;moveSource) { delete [] ptrResource; // free own resource ptrResource = moveSource.ptrResource; // take ownership, start move moveSource.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56ae037d37a2f5cf717213d3fb9b3a35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c74de5cd3e0a9350c53fcbeb1d0ce728/" rel="bookmark">
			C&#43;&#43;入门教程，C&#43;&#43;基础教程（第一部分：从C到C&#43;&#43;）七
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由C语言发展而来的一种面向对象的编程语言。
第一部分、从C语言到C++ 本章讲述 C++ 语言的简史，以及 C++ 语言中与面向对象关系不大、C语言中没有的特性。这些特性能够增加编程的便利性，提高程序的可扩充性。
十三、如何规范地使用C++内联函数 inline 关键字可以只在函数定义处添加，也可以只在函数声明处添加，也可以同时添加；但是在函数声明处添加 inline 关键字是无效的，编译器会忽略函数声明处的 inline 关键字。也就是说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。
尽管大多数教科书中在函数声明和函数定义处都增加了 inline 关键字，但我认为 inline 关键字不应该出现在函数声明处。这个细节虽然不会影响函数的功能，但是体现了高质量 C++ 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。
更为严格地说，内联函数不应该有声明，应该将函数定义放在本应该出现函数声明的地方，这是一种良好的编程风格。
在多文件编程中，我们通常将函数的定义放在源文件中，将函数的声明放在头文件中，希望调用函数时，引入对应的头文件即可，我们鼓励这种将函数定义和函数声明分开的做法。但这种做法不适用于内联函数，将内联函数的声明和定义分散到不同的文件中会出错，请看下面的例子。
main.cpp 代码：
#include &lt;iostream&gt; using namespace std; //内联函数声明 void func(); int main(){ func(); return 0; } module.cpp 代码：
#include &lt;iostream&gt; using namespace std; //内联函数定义 inline void func(){ cout&lt;&lt;"inline function"&lt;&lt;endl; } 上面的代码能够正常编译，但在链接时会出错。func() 是内联函数，编译期间会用它来替换函数调用处，编译完成后函数就不存在了，链接器在将多个目标文件（.o或.obj文件）合并成一个可执行文件时找不到 func() 函数的定义，所以会产生链接错误。
内联函数虽然叫做函数，在定义和声明的语法上也和普通函数一样，但它已经失去了函数的本质。函数是一段可以重复使用的代码，它位于虚拟地址空间中的代码区，也占用可执行文件的体积，而内联函数的代码在编译后就被消除了，不存在于虚拟地址空间中，没法重复使用。
如果你对虚拟地址空间或代码区的概念不了解，请阅读 《C语言内存精讲》专题。 内联函数看起来简单，但是有很多细节需要注意，从代码重复利用的角度讲，内联函数已经不再是函数了。我认为将内联函数作为带参宏的替代方案更为靠谱，而不是真的当做函数使用。
在多文件编程时，我建议将内联函数的定义直接放在头文件中，并且禁用内联函数的声明（声明是多此一举）。
十四、C++函数的默认参数详解 在C++ 中，定义函数时可以给形参指定一个默认的值，这样调用函数时如果没有给这个形参赋值（没有对应的实参），那么就使用这个默认的值。也就是说，调用函数时可以省略有默认值的参数。如果用户指定了参数的值，那么就使用用户指定的值，否则使用参数的默认值。
所谓默认参数，指的是当函数调用中省略了实参时自动使用的一个值，这个值就是给形参指定的默认值。下面是一个简单的示例：
#include&lt;iostream&gt; using namespace std; //带默认参数的函数 void func(int n, float b=1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c74de5cd3e0a9350c53fcbeb1d0ce728/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf5f8acce30ffd45f39987c943d9c45/" rel="bookmark">
			C&#43;&#43;中不必要的内存拷贝带来的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中不必要的内存拷贝带来的问题 请看程序清单 12.4 实现的加法运算符，注意到它创建并返回一个拷贝。如果程序清单 12.9 所示的
MyString 类支持加法运算符，就可轻松地拼接字符串，如下所示：
MyString Hello("Hello "); MyString World("World"); MyString CPP(" of C++"); MyString sayHello(Hello + World + CPP); // operator+, copy constructor MyString sayHelloAgain ("overwrite this"); sayHelloAgain = Hello + World + CPP; // operator+, copy constructor, copy assignment operator= 下述简单的代码让您能够使用双目加法运算符（ +）轻松地将三个字符串拼接起来：
MyString operator+ (const MyString&amp; addThis) { MyString newStr; if (addThis.buffer != NULL) { // copy into newStr } return newStr; // return copy by value, invoke copy constructor } 这个加法运算符（ +）让您能够式轻松地拼接字符串，但也可能导致性能问题。创建 sayHello 时，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cf5f8acce30ffd45f39987c943d9c45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e9a4d38076b61576f1ad2b6aa605500/" rel="bookmark">
			大模型LLM训练的数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 2021年以来，大预言模型的开发和生产使用呈现出爆炸式增长。除了李开复、王慧文、王小川等“退休”再创业的互联网老兵，在阿里巴巴、腾讯、快手等互联网大厂的中高层也大胆辞职，加入这波创业浪潮。
通用大模型初创企业MiniMax完成了新一轮融资，总规模超2.5亿美元，项目估值超过10亿美元，跻身独角兽行列。阿里巴巴技术副总裁贾扬清在朋友圈回应了离职传言，称其和团队已于3月20日从阿里“毕业”，贾扬清表示，“白驹过隙，我也计划走向职业生涯的下一个挑战”。
随着新型AI技术的快速发展，模型训练数据集的相关文档质量有所下降。模型内部到底有什么秘密？它们又是如何组建的？本文综合整理并分析了现代大型语言模型的训练数据集。说白了，大模型很火，数据感觉很神秘。
1 概述 大模型预训练需要从海量的文本数据中学习到充分的知识存储在其模型参数中。预训练所用的数据可以分为两类。
1）一类是网页数据（web data），这类数据的获取最为方便，各个数据相关的公司比如百度、谷歌等每天都会爬取大量的网页存储起来。其特点是量级非常大，比如非盈利性机构构建的CommonCrawl数据集是一个海量的、非结构化的、多语言的网页数据集。它包含了超过 8 年的网络爬虫数据集，包含原始网页数据（WARC）、元数据（WAT）和文本提取（WET），包含数百亿网页，数据量级在PB级规模，可从 Amazon S3 上免费获取。
2）第二类称之为专有数据（curated high-quality corpora），为某一个领域、语言、行业的特有数据。比如对话、书籍、代码、技术报告、论文考试等数据。这类数据比较难获取，如果在中国那么最优代表性的就应该是在我们的图书馆、国家数字档案馆、国家数字统计局等机构和地方。
在OpenAI的GPT3,4模型以及谷歌的PaLM系列模型训练中，大量用到了专有数据，如2TB的高质量书籍数据（Books – 2TB）和社交媒体对话数据（Social media conversations）等。这些专业数据是不对公众开放的，就拿高质量的book书籍数据来说，在网上能直接获取到数据来自The pile中的Book3，量级也才85GB左右，和这些巨头所用数据量级相差数十倍。
因此现在有一种普遍观点认为“GPT、PaLM等模型的成功很大程度源自于其他模型难以企及的大量的、高质量的专有数据”。比如LLM大模型的小火种，LLaMA在论文中就提到，自己所用的高质量数据只有177GB所以在MMLU等知识性推理任务上和PaLM相差了十几个点，如果能给LLaMA更多更好的数据，LLaMA说我还能更强。
2 数据分类 在很多论文中，或者很多材料中会经常出现下面这种图，说实话刚开始看的时候觉得挺酷的，然后就没然后了。其实这种图对于观察我们的数据分布非常有用。
因为其后面对大模型预训练时候的数据类型、数据量、数据格式都有规范化后的统一统计，例如上面图中来源《The BigScience ROOTS Corpus: A 1.6TB Composite Multilingual Dataset》，对BLOOM大模型训练的时候使用了1321.89 GB数据，一共超过40+不同国家的语预语言，对于代码Code有10+不同的编程语言。
又好像下面这个图来源于《aLM: Scaling Language Modeling with Pathways》，里面对PALM大模型预训练的数据集进行了类型的统计，有多少是新闻类、多少是社交数据、多少是法律条纹数据等，这个时候就知道为什么PALM大模型会比BLOOM大模型的效果更好的原因，因为可以更加清晰或者深入地清晰和梳理数据，搞清楚用来做大模型预训练数据的比例。
3 常用数据集 大多数基于Transformer的大型语言模型 (LLM) 都依赖于英文维基百科
和Common Crawl、C4、Github的4个大型数据集。这几个数据集是最常用的，基本上大部分大模型训练过程都会使用到，其中CommonCrawl的数据集比较大，而wiki Pedia的数据集比较规整相对来说比较少。
3.1 English CommonCrawl 使用模型：LLaMA（67%）、LaMDA、PaLM
处理方案：Common Crawl是2008年至今的一个网站抓取的大型数据集，数据包含原始网页、元数据和文本提取，它的文本来自不同语言、不同领域。基于AllenAI (AI2)的C4论文，可以确定，过滤后的英文C4数据集的每个域的token数和总体百分比，该数据集为305GB，其中token数为1560亿。在大模型训练的过程中，很少直接使用CommonCrawl的数据集，而是首先对CommonCrawl数据集进行了两个主要的处理，即低质量页面过滤、页面相似性去重，以避免过拟合。
下载链接：https://github.com/karust/gogetcrawl
官网链接：https://commoncrawl.org/
3.2 Wikipedia 使用模型：LLaMA（4.5%）、GPT-NEOX（1.53%）、LaMDA、PaLM
处理方案：数据集中添加了2022年6月至8月期间的维基百科dumps，涵盖20种语言，包括使用拉丁字母或西里尔字母的语言，具体为bg, ca, cs, da, de, en, es, fr, hr, hu, it, nl, pl, pt, ro, ru, sl, sr, sv, uk;然后对数据进行预处理，以去除超链接、评论和其他格式化的html模板。wiki Pedia 数据集涵盖了2015年抽样的1001篇随机文章，研究人员注意到随时间推移文章传播的稳定性。假设一个11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e9a4d38076b61576f1ad2b6aa605500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e06784fdb9341f3946968fc6c55021ee/" rel="bookmark">
			2024 年最适合高级用户的 11 个 Linux 发行版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个免费和开源的操作系统，Linux随着时间的推移已经催生了多个发行版，并扩展到了庞大的用户社区。从桌面/家庭用户到企业环境，Linux 确保每个类别都有令人高兴的东西。
这些发行版迎合具有技术专业知识的用户，为开发、系统管理和定制提供了强大的平台。
本指南重点介绍了 11 个 Linux 发行版，旨在阐明其目标用户。
1. Debian Debian因成为Deepin、Ubuntu和Mint等流行 Linux 发行版之母而闻名，这些发行版提供了可靠的性能、稳定性和无与伦比的用户体验。最新的稳定版本是Debian 12.4 ，它是Debian 12的更新，俗称Debian Bookworm。
请注意，Debian 12.4并不构成Debian Bookworm的新版本，而只是Bookworm的更新，包含最新的更新和添加的软件应用程序。
还包括解决先前存在的安全问题的安全修复程序。如果您拥有Bookworm系统，则无需丢弃它。只需使用APT 包管理器执行系统升级即可。
Debian项目提供了超过59,000 个软件包，并支持各种 PC，每个版本都包含更广泛的系统架构。它力求在尖端技术和稳定性之间取得平衡。
Debian 提供了 3 个显着的开发分支：Stable、Testing和Unstable。
Debian 稳定版
稳定版本，顾名思义，坚如磐石，并享有全面的安全支持，但不幸的是，它没有附带最新的软件应用程序。
尽管如此，由于其稳定性和可靠性，它非常适合生产服务器，并且也适合不介意拥有最新软件包的相对保守的桌面用户。Debian Stable 是您通常会在系统上安装的版本。
Debian 测试
Debian测试是一个滚动版本，提供尚未被稳定版本接受的最新软件版本。这是下一个稳定 Debian 版本的开发阶段。它通常充满不稳定问题并且很容易崩溃。
此外，它没有及时获得安全补丁。最新的Debian 测试版本是Trixie （ Debian 13的开发代号）。
Debian 不稳定
Unstable发行版是 Debian 的活跃开发阶段。它是一个实验性发行版，对于积极为代码做出贡献的开发人员来说是一个完美的平台，直到代码过渡到“测试”阶段。
总体而言，Debian因其软件包丰富的存储库及其提供的稳定性（尤其是在生产环境中）而被数百万用户使用。
2. Gentoo Gentoo是一个专为专业用途和专家而构建的发行版，他们从一开始就考虑到他们正在使用的软件包。此类别包括开发人员、系统和网络管理员。因此，它对于 Linux 初学者来说并不理想。
Gentoo推荐给那些想要更深入了解 Linux 操作系统细节的人。
Gentoo附带了一个称为portage 的包管理系统，该系统也是其他发行版的本机，例如ChromiumOS和Calculate Linux，它基于Gentoo并向后兼容。
它基于 Python 并基于 ports 的集合概念，即由基于 BSD 的发行版（例如OpenBSD和NetBSD ）提供的补丁和 makefile 集。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e06784fdb9341f3946968fc6c55021ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb10ec80f1aa86726b4d4d423d6a212/" rel="bookmark">
			为什么 Kafka 这么快？它是如何工作的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着数据以指数级的速度流入企业，强大且高性能的消息传递系统至关重要。Apache Kafka 因其速度和可扩展性而成为热门选择，但究竟是什么让它如此之快？
在本期中，我们将探讨：
Kafka 的架构及其核心组件，如生产者、代理和消费者
Kafka 如何优化数据存储和复制
这些优化使 Kafka 能够实现令人印象深刻的吞吐量和低延迟
让我们先深入了解一下 Kafka 的核心组件。
Kafka 架构提炼 在将 Kafka 用作 pub-sub 消息中间件的典型场景中，有 3 个重要组件：生产者、代理者和消费者。生产者是消息发送者，消费者是消息接收者。代理通常以集群模式部署，该模式处理传入的消息并将其写入代理分区，从而允许使用者从中读取数据。
请注意，Kafka 被定位为事件流平台，因此在消息队列中经常使用的术语“消息”在 Kafka 中不使用。我们称之为“事件”。
下图汇集了 Kafka 架构和客户端 API 结构的详细视图。我们可以看到，尽管生产者、消费者和代理仍然是架构的关键，但构建高吞吐量、低延迟的 Kafka 需要更多。让我们一一介绍这些组件。
从高层次的角度来看，体系结构中有两层：计算层和存储层。
计算层
计算层或处理层允许各种应用程序通过 API 与 Kafka 代理进行通信。
生产者使用生产者 API。如果数据库等外部系统想要与 Kafka 通信，它还提供 Kafka Connect 作为集成 API。
消费者通过消费者 API 与经纪人交谈。为了将事件路由到其他数据接收器，如搜索引擎或数据库，我们可以使用 Kafka Connect API。此外，使用者可以使用 Kafka Streams API 执行流式处理。如果我们处理无限的记录流，我们可以创建一个 KStream。下面的代码片段为主题“orders”创建一个 KStream，其中 Serdes（序列化程序和反序列化程序）用于键和值。如果我们只需要更新日志中的最新状态，我们可以创建一个 KTable 来维护状态。Kafka Streams 允许我们对事件流执行聚合、过滤、分组和联接。
final KStreamBuilder builder = new KStreamBuilder();final KStream&lt;String, OrderEvent&gt; orderEvents = builder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cb10ec80f1aa86726b4d4d423d6a212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad33054cd658c7b50d8056308c98f889/" rel="bookmark">
			C&#43;&#43;中的运算符与函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中的运算符与函数 从语法层面看，除使用关键字 operator 外，运算符与函数几乎没有差别。运算符声明看起来与函
数声明极其相似：
return_type operator operator_symbol (...parameter list...); 其中 operator_symbol 是程序员可定义的几种运算符类型之一。可以是+（加）、 &amp;&amp;（逻辑 AND）
等。编译器可根据操作数区分运算符。那么， C++在支持函数的情况下为何还要提供运算符呢？
来看封装了年、月、日的实用类 Date：
Date holiday (12, 25, 2016); // initialized to Dec 25, 2016 如果要将这个 Date 对象指向下一天（ 2016 年 12 月 26 日）， 下面两种方法哪种更方便、 更直观呢？
• 方法 1（使用递增运算符）：
++ holiday; • 方法 2（使用成员函数 Increment( )）：
holiday.Increment(); // Dec 26, 2016 显然，方法 1 优于方法 2。基于运算符的机制更容易使用，也更直观。通过在 Date 类中实现运算
符&lt;，将可以像下面这样对两个 Date 实例进行比较：
if(date1 &lt; date2) { // Do something } else { // Do something else } 运算符并非仅能用于管理日期的类。想想程序清单 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad33054cd658c7b50d8056308c98f889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/973a9276d6eff1efc5c4b6f907d925b4/" rel="bookmark">
			K8S--部署SpringBoot调用MySQL（实战）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文网址：K8S--部署SpringBoot调用MySQL（实战）-CSDN博客
简介 本文介绍K8S部署SpringBoot调用MySQL的实战案例。
分享Java真实高频面试题，吊打面试官： Java后端真实面试题大全 - 自学精灵
分享靠谱的Java高级实战，包含：高并发、架构、全局处理等：JavaWeb高级实战 - 自学精灵
1.部署MySQL 见：K8S--部署SpringBoot调用MySQL（实战）-CSDN博客
部署之后，创建数据库和表：
DROP DATABASE IF EXISTS mp; CREATE DATABASE mp DEFAULT CHARACTER SET utf8; USE mp; DROP TABLE IF EXISTS `t_user`; SET NAMES utf8mb4; CREATE TABLE `t_user` ( `id` BIGINT(0) NOT NULL, `user_name` VARCHAR(64) NOT NULL COMMENT '用户名（不能重复）', `nick_name` VARCHAR(64) NULL COMMENT '昵称（可以重复）', `email` VARCHAR(64) COMMENT '邮箱', `create_time` DATETIME(0) NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_time` DATETIME(0) NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', `deleted_flag` BIGINT(0) NOT NULL DEFAULT 0 COMMENT '0：未删除 其他：已删除', PRIMARY KEY (`id`) USING BTREE, UNIQUE KEY `index_user_name_deleted_flag` (`user_name`, `deleted_flag`), KEY `index_create_time`(`create_time`) ) ENGINE = InnoDB COMMENT = '用户'; INSERT INTO `t_user` VALUES (1, 'knife', '刀刃', 'abc@qq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/973a9276d6eff1efc5c4b6f907d925b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7059d0b8bf8e39b9b090f3a18e59b58/" rel="bookmark">
			20240107让Firefly的AIO-3399J开发板的Android11下配置为默认1080p录像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20240107让Firefly的AIO-3399J开发板的Android11下配置为默认1080p录像
2024/1/7 23:01
开发板：Firefly的AIO-3399J【RK3399】
SDK：rk3399-android-11-r20211216.tar.xz【Android11】
Android11.0.tar.bz2.aa【ToyBrick】
Android11.0.tar.bz2.ab
Android11.0.tar.bz2.ac
https://wiki.t-firefly.com/AIO-3399J/prepare_compile_android.html
AIO-3399J产品规格书 立即购买
AIO-3399J 采用 RK3399 六核(A72x2+A53x4) 64 位处理器，主频高达1.8GHz，集成了四核 Mali-T860 GPU，性能优异。
1、简略的编译步骤：
rootroot@rootroot-X99-Turbo:~/3TB$ cat Android11.0.tar.bz2.a* &gt; Android11.0.tar.bz2
rootroot@rootroot-X99-Turbo:~/3TB$ tar jxvf Android11.0.tar.bz2 rootroot@rootroot-X99-Turbo:~/3TB$ mv Android11.0 64rk3399-android-11
rootroot@rootroot-X99-Turbo:~/3TB$ cd 64rk3399-android-11
rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11$ cd u-boot
rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11/u-boot$ ./make.sh rk3399
rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11/u-boot$ cd ..
rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11$ cd kernel/
rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11/kernel$ make ARCH=arm64 rockchip_defconfig android-11.config -j36
rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11/kernel$ make ARCH=arm64 BOOT_IMG=../rockdev/Image-rk3399_Android11/boot.img rk3399-sapphire-excavator-edp-avb.img -j36
rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11$ source build/envsetup.sh rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11$ lunch
36. rk3399_Android11-userdebug
Which would you like?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7059d0b8bf8e39b9b090f3a18e59b58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f927bca475936f1df629c495105eb4b3/" rel="bookmark">
			Copilot在Pycharm的应用和示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Copilot 是 Github 在 2021 年发布的 AI 代码助手工具，它可以根据你提供的上下文信息，自动生成代码建议，帮助提高代码编写效率和准确性。在 Pycharm 中使用 Copilot，可以进一步提升 Python 开发效率，本文将分享如何在 Pycharm 中使用 Copilot，以及一些示例代码。
一、准备工作
1、首先，你需要在 Github Copilot 官网 上注册，并下载安装 Copilot 插件。目前 Copilot 支持的编辑器和 IDE 有：VS Code、Atom、Sublime Text、Vim 和 Emacs。
2、安装完成后，你需要在 Pycharm 中启用 Copilot 插件。在 Pycharm 的 Preferences 中进入 Plugins，搜索并安装 Github Copilot 插件。
3、接下来，你需要在 Pycharm 的设置中配置 Copilot，输入你在官网上注册时使用的用户名和密码，并选择你想要使用的编程语言，例如 Python。
二、在 Pycharm 中使用 Copilot
在 Pycharm 编辑器中，选择一个代码文件或者打开一个新文件，然后将光标移动到你需要编写代码的位置。在这个位置上，按下 Ctrl+Shift+A 或者 Cmd+Shift+A（Mac） 打开快捷命令窗口，输入 Github Copilot 并回车，即可在弹出的对话框中输入你的命令或上下文信息。
例如，如果你需要编写一个 Python 函数来计算平均值，你可以在对话框中输入 Python function to calculate average，Copilot 就会根据你提供的上下文信息，自动生成一个函数模板，如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f927bca475936f1df629c495105eb4b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3f251bab4b0ffbbfb2783e58be48119/" rel="bookmark">
			当大型语言模型（LLM）遇上知识图谱：两大技术优势互补
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 引言 大型语言模型（LLM）已经很强了，但还可以更强。通过结合知识图谱，LLM 有望解决缺乏事实知识、幻觉和可解释性等诸多问题；而反过来 LLM 也能助益知识图谱，让其具备强大的文本和语言理解能力。而如果能将两者充分融合，我们也许还能得到更加全能的人工智能。
今天我们将介绍一篇综述 LLM 与知识图谱联合相关研究的论文，其中既包含用知识图谱增强 LLM 的研究进展，也有用 LLM 增强知识图谱的研究成果，还有 LLM 与知识图谱协同的最近成果。文中概括性的框架展示非常方便读者参考。
论文链接：https://arxiv.org/abs/2306.08302
BERT、RoBERTA 和 T5 等在大规模语料库上预训练的大型语言模型（LLM）已经能非常优秀地应对多种自然语言处理（NLP）任务，比如问答、机器翻译和文本生成。近段时间，随着模型规模的急剧增长，LLM 还进一步获得了涌现能力，开拓了将 LLM 用作通用人工智能（AGI）的道路。ChatGPT 和 PaLM2 等先进的 LLM 具有数百上千亿个参数，它们已有潜力解决许多复杂的实际任务，比如教育、代码生成和推荐。
尽管 LLM 已有许多成功应用，但由于缺乏事实知识，它们还是备受诟病。具体来说，LLM 会记忆训练语料库中包含的事实和知识。但是，进一步的研究表明，LLM 无法回忆出事实，而且往往还会出现幻觉问题，即生成具有错误事实的表述。举个例子，如果向 LLM 提问：「爱因斯坦在什么时候发现了引力？」它可能会说：「爱因斯坦在 1687 年发现了引力。」但事实上，提出引力理论的人是艾萨克・牛顿。这种问题会严重损害 LLM 的可信度。
LLM 是黑箱模型，缺乏可解释性，因此备受批评。LLM 通过参数隐含地表示知识。因此，我们难以解释和验证 LLM 获得的知识。此外，LLM 是通过概率模型执行推理，而这是一个非决断性的过程。对于 LLM 用以得出预测结果和决策的具体模式和功能，人类难以直接获得详情和解释。
尽管通过使用思维链（chain-of-thought），某些 LLM 具备解释自身预测结果的功能，但它们推理出的解释依然存在幻觉问题。这会严重影响 LLM 在事关重大的场景中的应用，比如医疗诊断和法律评判。举个例子，在医疗诊断场景中，LLM 可能误诊并提供与医疗常识相悖的解释。这就引出了另一个问题：在一般语料库上训练的 LLM 由于缺乏特定领域的知识或新训练数据，可能无法很好地泛化到特定领域或新知识上。
为了解决上述问题，一个潜在的解决方案是将知识图谱（KG）整合进 LLM 中。知识图谱能以三元组的形式存储巨量事实，即 (头实体、关系、尾实体)，因此知识图谱是一种结构化和决断性的知识表征形式，例子包括 Wikidata、YAGO 和 NELL。
知识图谱对多种应用而言都至关重要，因为其能提供准确、明确的知识。此外众所周知，它们还具有很棒的符号推理能力，这能生成可解释的结果。知识图谱还能随着新知识的持续输入而积极演进。此外，通过让专家来构建特定领域的知识图谱，就能具备提供精确可靠的特定领域知识的能力。
然而，知识图谱很难构建，并且由于真实世界知识图谱往往是不完备的，还会动态变化，因此当前的知识图谱方法难以应对。这些方法无法有效建模未见过的实体以及表征新知识。此外，知识图谱中丰富的文本信息往往会被忽视。不仅如此，知识图谱的现有方法往往是针对特定知识图谱或任务定制的，泛化能力不足。因此，有必要使用 LLM 来解决知识图谱面临的挑战。图 1 总结了 LLM 和知识图谱的优缺点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3f251bab4b0ffbbfb2783e58be48119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b27092ef02e904893795f779ed72101/" rel="bookmark">
			PAT 乙级 1076 Wifi密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解题思路：首先这题看着复杂实际很简单，每题就一个正确的我们把他找出来就可以，之后利用和’A’ 相减加一 求出数值，输出即可。python代码更容易
c语言:
#include&lt;stdio.h&gt; int main() { int n,i,j,count=0; scanf("%d",&amp;n); char a[n+1]; char t,r; for(i=0;i&lt;n;i++) { for(j=0;j&lt;4;j++) {	scanf(" %c-%c",&amp;t,&amp;r); if(r=='T') a[count++]=t-'A'+1+'0'; } } a[count]=0; printf("%s\n",a); return 0;	} python代码:
n=int(input()) s=[] for i in range(n): a=input().split() for j in a: if 'T' in j: s.append(str(ord(j[0])-ord('A')+1)) print(''.join(s)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e521a3c98fea6ced2bb119ca59628e80/" rel="bookmark">
			基于人工智能的电力设备老化和退化评估
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着电力设备的使用时间的增长，其性能会逐渐下降，这就是所谓的老化和退化。这种老化和退化不仅会影响电力设备的正常运行，还可能对电力系统的安全和稳定产生严重的影响。因此，对电力设备的老化和退化进行评估，以便及时发现问题并采取相应的措施，是电力系统中非常重要的一项工作。
老化和退化的定义： 老化是指电力设备在运行过程中，由于各种原因（如温度、湿度、电压、电流等）的作用，其物理和化学性质发生变化，从而导致其性能下降的过程。退化则是指电力设备在运行过程中，由于长期受到各种应力的作用，其结构和功能发生不可逆的变化，从而导致其性能下降的过程。
老化和退化的影响因素：电力设备的老化和退化受到多种因素的影响，主要包括以下几个方面：
1. 环境因素：包括温度、湿度、气压、盐雾、尘埃等。这些因素会对电力设备的材料和结构产生影响，从而加速其老化和退化。
2. 电气因素：包括电压、电流、频率、电磁场等。这些因素会对电力设备的绝缘性能产生影响，从而加速其老化和退化。
3. 机械因素：包括振动、冲击、压力等。这些因素会对电力设备的结构和连接部件产生影响，从而加速其老化和退化。
4. 化学因素：包括腐蚀、氧化、老化等。这些因素会对电力设备的材料和结构产生影响，从而加速其老化和退化。
老化和退化的传统评估方法：电力设备的老化和退化评估主要包括以下几种方法：
1. 物理检测法：通过物理手段（如测量、观察、试验等）对电力设备的物理状态进行检测，从而评估其老化和退化的程度。这种方法简单易行，但需要专业的技术人员进行操作。
2. 化学分析法：通过化学手段（如光谱分析、色谱分析等）对电力设备的化学成分进行分析，从而评估其老化和退化的程度。这种方法准确度高，但需要专业的设备和技术人员。
3. 数学模型法：通过建立数学模型，对电力设备的老化和退化过程进行模拟，从而评估其老化和退化的程度。这种方法可以预测电力设备的寿命，但需要大量的数据支持。
4. 综合评估法：通过综合考虑电力设备的物理、化学、电气、机械等多种因素，对其老化和退化程度进行评估。这种方法全面准确，但需要专业的技术人员进行操作。
老化和退化的传统预防和控制：对电力设备的老化和退化进行评估后，还需要采取相应的预防和控制措施，以延长其使用寿命，保证电力系统的安全稳定运行。这些措施主要包括：
1. 定期检查和维护：定期对电力设备进行检查和维护，及时发现并处理问题，可以有效地防止或延缓其老化和退化。
2. 优化运行条件：合理调整电力设备的运行条件（如温度、湿度、电压、电流等），可以减少其受到的应力，从而延缓其老化和退化。
3. 采用先进的材料和技术：采用先进的材料和技术，可以提高电力设备的性能，延长其使用寿命。
4. 建立完善的管理体系：建立完善的管理体系，可以有效地组织和管理电力设备的检查、维护、更新等工作，从而保证其安全、稳定、高效的运行。
电力设备的老化和退化是一个复杂的过程，受到多种因素的影响。通过对电力设备的老化和退化进行评估，可以及时发现问题，采取有效的预防和控制措施，从而保证电力系统的安全稳定运行。然而，电力设备的老化和退化评估仍然是一个需要进一步研究的问题，需要我们不断探索和完善。
基于人工智能的电力设备老化和退化评估：随着科技的不断发展，人工智能（AI）在各个领域的应用越来越广泛。在电力设备领域，基于人工智能的老化和退化评估技术已经成为一种新兴的研究热点。本文将介绍基于人工智能的电力设备老化和退化评估的原理、方法和应用，并探讨其在未来电力系统中的发展前景。
电力设备是电力系统的重要组成部分，其安全、稳定和可靠的运行对整个电力系统的正常运行至关重要。然而，由于长期运行、环境因素和材料老化等原因，电力设备的性能会逐渐下降，甚至出现故障。因此，对电力设备的老化和退化进行评估，以便及时发现问题并采取相应的措施，是电力系统中非常重要的一项工作。
传统的电力设备老化和退化评估方法主要依赖于人工检测和经验判断，这种方法存在许多不足之处，如主观性强、效率低、准确性不高等。近年来，随着人工智能技术的发展，基于人工智能的电力设备老化和退化评估技术逐渐成为研究热点。这种技术利用大量的数据和先进的算法，可以对电力设备的老化和退化进行快速、准确和客观的评估，为电力设备的维护和管理提供了有力的支持。
基于人工智能的电力设备老化和退化评估原理：基于人工智能的电力设备老化和退化评估主要包括两个方面：数据采集和数据分析。数据采集是指通过各种传感器和监测设备，实时收集电力设备的运行数据，如温度、湿度、电压、电流等；数据分析是指利用人工智能技术，对采集到的数据进行处理和分析，从而评估电力设备的老化和退化程度。
在数据采集阶段，需要选择合适的传感器和监测设备，以保证数据的准确性和完整性。此外，还需要建立完善的数据采集系统，实现数据的实时传输和存储。
在数据分析阶段，主要采用机器学习、深度学习等人工智能技术。首先，需要对采集到的数据进行预处理，包括数据清洗、数据标准化等；然后，利用机器学习算法（如支持向量机、决策树等）或深度学习算法（如卷积神经网络、循环神经网络等），对数据进行训练和建模；最后，根据建立的模型，对电力设备的老化和退化程度进行评估。
基于人工智能的电力设备老化和退化评估方法：基于人工智能的电力设备老化和退化评估方法主要包括以下几种：
1. 基于机器学习的设备状态预测：通过对历史数据进行分析，建立设备状态与运行参数之间的关系模型，从而实现对设备未来状态的预测。这种方法适用于已经积累了大量历史数据的情况。
2. 基于深度学习的特征提取：利用深度学习算法（如卷积神经网络、循环神经网络等），自动提取设备运行数据中的关键特征，从而实现对设备老化和退化程度的评估。这种方法适用于数据量较大、特征复杂的情况。
3. 基于时间序列分析的设备状态监测：通过对设备运行数据的时序特性进行分析，建立时间序列模型，从而实现对设备状态的实时监测。这种方法适用于需要实时监测设备状态的情况。
4. 基于异常检测的设备故障预警：通过对设备运行数据的异常检测，实现对设备故障的预警。这种方法适用于需要及时发现设备故障的情况。
基于人工智能的电力设备老化和退化评估应用：基于人工智能的电力设备老化和退化评估技术在电力系统中具有广泛的应用前景，主要包括以下几个方面：
1. 设备状态监测：通过对电力设备的实时监测，实现对设备状态的全面了解，从而为设备的维护和管理提供有力支持。
2. 设备故障预警：通过对设备运行数据的异常检测，实现对设备故障的及时预警，从而降低设备故障率，提高电力系统的可靠性。
3. 设备寿命预测：通过对设备运行数据的分析，实现对设备寿命的预测，从而为设备的更换和维护提供依据。
4. 设备性能优化：通过对设备运行数据的分析，实现对设备性能的优化，从而提高设备的运行效率和经济性。
基于人工智能的电力设备老化和退化评估发展前景：随着人工智能技术的不断发展和完善，基于人工智能的电力设备老化和退化评估技术将在未来的电力系统中发挥越来越重要的作用。一方面，随着大数据技术的发展，电力系统将产生大量的运行数据，为基于人工智能的老化和退化评估提供了丰富的数据资源；另一方面，随着计算能力的提高，人工智能算法将更加高效、准确和智能，为电力设备的老化和退化评估提供更强大的技术支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa2aac7c344b52409f65973fc78be28/" rel="bookmark">
			js_入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js js放入网页的方式
1、内联使用：放入标签里面
2、内部使用:多数放在body里面
3、使用外部js
&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- &lt;script&gt; alert("hi, es"); &lt;/script&gt; --&gt; &lt;!-- &lt;script src="./jsDemo1.js"&gt;&lt;/script&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 讲解js放入网页的方式 --&gt; &lt;!-- 1、内联使用：放入标签里面 --&gt; &lt;!-- &lt;a href="给的是地址，就是跳转页面"&gt;&lt;/a&gt; --&gt; &lt;!-- &lt;a href="javascript:执行js代码，内联使用"&gt;&lt;/a&gt; --&gt; &lt;!-- alert(弹出内容):函数，BOM对象里面一个函数，警告框， --&gt; &lt;!-- &lt;a href="javascript:alert('欢迎使用js')"&gt;点击&lt;/a&gt; --&gt; &lt;!-- 2、内部使用:多数放在body里面 --&gt; &lt;!-- &lt;script type="text/javascript"&gt; alert("hello,js"); &lt;/script&gt; --&gt; &lt;!-- 3、使用外部js --&gt; &lt;!-- &lt;script src="./jsDemo1.js"&gt;&lt;/script&gt; --&gt; &lt;!-- 引用js代码的script标签里面不能再写js代码 --&gt; &lt;/body&gt; 在js中声明变量
声明变量的关键字：
var:声明函数级别（在方法里面声明局部变量）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fa2aac7c344b52409f65973fc78be28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d42db9da537151a3343e85653c09ef47/" rel="bookmark">
			循环平稳信号分析方法在旋转机械设备状态监测和故障诊断中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		旋转机械设备是现代社会中不可或缺的重要组成部分，广泛应用于航空航天、汽车制造、电力系统等领域。然而，由于旋转机械设备的复杂性和工作环境的恶劣性，其运行过程中可能出现各种故障，导致设备性能下降甚至发生事故。因此，对旋转机械设备进行状态监测和故障诊断具有重要的实际意义。
特征提取技术是旋转机械设备状态监测和故障诊断的关键问题之一。故障特征捕捉的好坏直接关系到故障诊断的准确率和故障早期预报的可靠性。而特征提取技术的发展在很大程度上又取决于信号处理新理论、新方法的出现。现代信号分析与处理技术的本质从整体上来说可以用七个“非”字加以高度的概括，即：非线性、非因果、非最小相位系统、非高斯、非平稳、非整数维(分形)信号和非白色的加性噪声(有色噪声),随着各种新的信号处理方法的引入，如时频分析、小波分析、非线性时间序列分析等等，振动信号分析方法在非线性、非高斯、非最小相位信号处理方面有了一定的进步。这些特征提取技术及其相应的模式识别方法已经取得了初步成效，带来了一定的社会和经济效益。
然而，现有的特征提取技术并未或无法充分考虑到旋转机械设备固有的周期时变特性。由于旋转机械设备自身的物理结构、运转机制等因素所导致的周期时变特征是其一种固有的属性，且与系统本身的物理参量有着内在的联系。旋转机械的运行特点决定了其振动信号具有一定的周期性，当出现异常或发生故障时，一般还会表现出非平稳性，两者叠加就形成了带有周期性的非平稳信号。为了解决这类具有典型特征的信号分析问题，人们开始寻求新的信号处理方法。于是，循环平稳信号分析方法出现了。
循环平稳信号分析方法是一种基于循环统计量的时频分析方法，它能够有效地处理具有周期性和非平稳性的信号。这种方法的基本思想是将信号分解为一系列相互独立的循环分量，然后对每个循环分量进行时频分析。循环平稳信号分析方法具有许多优点，例如：能够有效地处理具有周期性和非平稳性的信号；能够提供较高的时频分辨率；能够有效地抑制噪声干扰等。
目前，循环平稳信号分析方法已经在许多领域得到了广泛的应用，例如：通信、雷达、声学、生物医学等。在旋转机械设备状态监测和故障诊断领域，循环平稳信号分析方法也取得了显著的成果。例如，研究人员利用循环平稳信号分析方法对旋转机械设备的振动信号进行了分析，成功地提取出了故障特征，并建立了相应的故障诊断模型。这些研究成果为旋转机械设备状态监测和故障诊断提供了有力的技术支持。
总之，循环平稳信号分析方法是一种有效的特征提取技术，它能够有效地处理具有周期性和非平稳性的信号，为旋转机械设备状态监测和故障诊断提供了有力的技术支持。随着科学技术的不断发展，循环平稳信号分析方法在旋转机械设备状态监测和故障诊断领域的应用将会越来越广泛，为提高旋转机械设备的安全性和可靠性做出更大的贡献。
然而，尽管循环平稳信号分析方法在旋转机械设备状态监测和故障诊断领域取得了显著的成果，但仍然存在一些问题和挑战。例如，如何进一步提高循环平稳信号分析方法的性能；如何将循环平稳信号分析方法与其他特征提取技术相结合；如何将循环平稳信号分析方法应用于更广泛的领域等。这些问题和挑战需要我们进一步研究和探讨。
首先，我们需要进一步提高循环平稳信号分析方法的性能。目前，循环平稳信号分析方法虽然已经取得了显著的成果，但仍然存在一定的局限性。例如，循环平稳信号分析方法在处理具有较高频率成分的信号时，可能会出现性能下降的问题。因此，我们需要进一步研究如何提高循环平稳信号分析方法的性能，使其能够更好地处理各种类型的信号。
其次，我们需要将循环平稳信号分析方法与其他特征提取技术相结合。目前，各种特征提取技术都有其各自的优点和局限性。因此，将不同的特征提取技术相结合，可以充分发挥各种技术的优势，提高故障诊断的准确性和可靠性。例如，我们可以将循环平稳信号分析方法与时频分析、小波分析等其他特征提取技术相结合，共同完成故障特征的提取工作。
最后，我们需要将循环平稳信号分析方法应用于更广泛的领域。目前，循环平稳信号分析方法已经在旋转机械设备状态监测和故障诊断领域取得了显著的成果，但仍然有许多其他领域尚未得到充分的应用。例如，我们可以将循环平稳信号分析方法应用于航空航天、汽车制造、电力系统等领域，为这些领域的设备状态监测和故障诊断提供有力的技术支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d5c7b9d0f9a43be05e4670337bfc8b5/" rel="bookmark">
			Dockerfile的EXPOSE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 环境总结测试使用EXPOSE测试1：不做端口映射测试2：-p 8080:80测试3：-P测试4：--network=host 不使用EXPOSE 参考 环境 RHEL 9.3Docker Community 24.0.7 总结 如果懒得看测试的详细信息，可以直接看结果：
docker run 选项在Dockerfile里 EXPOSE 80在Dockerfile里不 EXPOSE 80备注无在容器外无法访问容器的80端口在容器外无法访问容器的80端口-p 8080:8080808080显式指定映射端口-P随机端口随机端口随机映射端口--network=host8080直接使用容器的端口 所以，EXPOSE并不会真正开放端口，它更像是一个说明文档，由image的开发者声明image所监听的端口，使用者以此为依据，在启动容器时，可以以不同的策略来开放端口。
测试 使用EXPOSE 创建 Dockerfile 文件如下：
FROM nginx:alpine EXPOSE 80 构建：
docker build -t kai0107_1 . 测试1：不做端口映射 启动容器：
docker run kai0107_1 查看容器：
➜ ~ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 430b0c2bee65 kai0107_1 "/docker-entrypoint.…" 5 seconds ago Up 5 seconds 80/tcp recursing_noyce 检查该容器：
➜ ~ docker container inspect 430b0c2bee65 | grep -i3 port "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d5c7b9d0f9a43be05e4670337bfc8b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3485c50aec6f0ac1e579d7913849a044/" rel="bookmark">
			uniapp 微信小程序跳转外部链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景： 开发小程序时，跳转到内部路径通常会使用：uni.navigateTo，uni.redirectTo，uni.reLaunch，uni.switchTab等方法，可以跳转到pages.json中已经注册的页面
uni.navigateTo(OBJECT) | uni-app官网
跳转到外部链接，便不能再使用以上方法，需要利用web-view来实现需求
web-view | uni-app官网
二、实现步骤 2.1、展示效果 2.2、pages.json中创建index与webView两个页面 2.3、在index页面点击按钮跳转到webView页面 备注：跳转时携带需要访问的外部路径
&lt;template&gt; &lt;view class="content"&gt; &lt;button @click="goto"&gt;跳转到CSDN&lt;/button&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { goto(){ //需要跳转的外部路径 let url = 'https://blog.csdn.net/weixin_71403100/article/details/135416379?spm=1001.2014.3001.5501' uni.navigateTo({ url:'/pages/webView/webView?url='+url }) } } } &lt;/script&gt; 2.4、webView页面接收传递的路径，利用web-view标签进行跳转 &lt;template&gt; &lt;view&gt; &lt;web-view :src="url"&gt;&lt;/web-view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { url:'' }; }, onLoad(e) { //接收传递的访问地址 this.url = e.url } } &lt;/script&gt; 三、业务域名问题 3.1、开发跟测试时在本地中打开不校验合法域名 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3485c50aec6f0ac1e579d7913849a044/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88213d0fcdf5f267c7c88b4941f79306/" rel="bookmark">
			PAT 乙级 1056 组合数的和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定 N 个非 0 的个位数字，用其中任意 2 个数字都可以组合成 1 个 2 位的数字。要求所有可能组合出来的 2 位数字的和。例如给定 2、5、8，则可以组合出：25、28、52、58、82、85，它们的和为330。
输入格式：
输入在一行中先给出 N（1 &lt; N &lt; 10），随后给出 N 个不同的非 0 个位数字。数字间以空格分隔。
输出格式：
输出所有可能组合出来的2位数字的和。
输入样例：
3 2 8 5
输出样例：
330
代码长度限制
16 KB
时间限制
400 ms
内存限制
解题思路:
c语言代码:
#include&lt;stdio.h&gt; int main() { int sum=0,n,temp,i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) { scanf("%d",&amp;temp); sum+=temp*(n-1)*11; } printf("%d\n",sum); } python代码:
n,*a=input().split() n=int(n) sum=0 for i in a: sum+=int(i)*11*(n-1) print(sum) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08d58cebd77ff409621dbea3937e2655/" rel="bookmark">
			论文阅读记录SuMa SuMa&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先是关于SuMa的阅读，SuMa是一个完整的激光SLAM框架，核心在于“基于面元(surfel)”的过程，利用3d点云转换出来的深度图和法向量图来作为输入进行SLAM的过程，此外还改进了后端回环检测的过程，利用提出的面元的概念和使用到的虚拟帧来优化回环检测的过程。
SuMa的核心分为以下几个步骤：
1. SuMa预处理 预处理的部分将3d点云转换为两张图，原文用的词是vertex map和normal map，这里直接翻译为顶点图和法向量图。
预处理的过程本质上就是建立一个3d到2d的转换，原始的点云是3d的，顶点图和法向量图都是2d的，所以需要一个转换关系，论文首先使用的是点云到顶点图的转换，对于点云中的每个点，有：
其中出现的两个参数分别是
其中r是深度，f是竖直方向的视野范围
此外w和h分别表示顶点图的大小。对于顶点图中的每个点，论文都使用 V D V_D VD​来表示。得到了顶点图后，利用其相邻的关系，就可以得到法向量图，就像其名字一样，法向量图存储的是每个位置上的法向量（normal），在计算时可以直接使用顶点图中的相邻元素进行计算：
为了保证计算的有效性，对于边界的元素，如果位置超过了图像的范围，也就是说位置不合法了，这种情况直接不参与计算，只保留合法位置的法向量信息。
在经过预处理之后，原本的3D点云地图就被转换成两张二维的图像，后续的里程计和回环检测都是在这两张图的基础上
2. SuMa地图表示 前面看过的论文里，地图的表示方法有很多种，最普通的基于特征点、特征线，稍微进阶一些的比如基于物体的就是用的物体地图，而LOAM也可以看作是基于边和面的地图，在SuMa中作者提出了一种基于面元的地图。
面元即论文中的surfel这个单词，面元地图指的就是面元作为地图中的基本元素，一个面元就相当于一个小平面，可以抽象为一个小的圆形，每个面元用一个位置向量、一个法向量和一个半径表示，此外还保留两个时间戳，分别是创建面元的时间和最后一次更新面元的时间。
除此之外，为了体现面元的置信度，方便后续筛选掉错误的面元，论文对每个面元设置了一个优势比（odds ratio），用来体现一个面元的可靠程度，其计算方法为：
其中的odds为一个函数，具体表示为：
p s t a b l e p_{stable} pstable​和 p p r i o r p_{prior} pprior​表示面元是一个稳定面元的概率和先验概率，这其实是一个不断更新的过程，如果确定两帧的两个面元对应的是地图上的同一个面元，那么更新时必然是一个迭代的更新，原面元法向量与待整合面元的法向量夹角越小、距离越近，对应到公式中的 e x p exp exp项也就越接近1，整体也就向着 p s t a b l e p_{stable} pstable​的方向移动，从而让面元的可靠程度越高。
此外，关于时间戳信息，引入这个量主要是为了将地图中的面元区分为两部分：动态图和静态图。动态图记为 M a c t i v e M_{active} Mactive​而静态图记为 M i n a c t i v e M_{inactive} Minactive​，里程计进行位姿估计的过程主要是用动态图，而回环检测的部分则使用静态图。最近更新时间超过一定阈值就将其记为静态图，否则放在动态图。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08d58cebd77ff409621dbea3937e2655/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bfe8cdc2f7a167fbeb3e613532a0b32/" rel="bookmark">
			在 PyCharm 中使用 Copilot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub Copilot 由 OpenAI Codex 提供支持，可帮助用户在编辑器中实时工作。
它使用强大的 GPT-3 模型版本，该模型在大量开源代码上进行训练。
此外，GitHub Copilot 可在不同的 IDE（集成开发环境）上使用，包括 PyCharm IDE。您可以轻松地将其安装在所有版本的 PyCharm 上，并将其用作扩展，这有助于为您的项目提供代码建议。 本文将教你更多关于 GitHub Copilot 的信息，以及如何在 PyCharm 上启用和禁用它。
什么是 GitHub Copilot GitHub Copilot 是一个 AI 结对程序员，可自动提供完成代码的建议。
它使用OpenAI模型提出建议，该模型由数十亿个开源的LOC（代码行）构建而成。
GitHub Copilot 会自动提供完成代码的建议
此外，它支持公共存储库中的每种编程语言，如 C、C++、Python、JavaScript 等。
关于其定价，个人 GitHub Copilot 的价格从每月 10 美元到每年 100 美元不等。
此外，GitHub Copilot 的商业版是每位用户每月 19 美元。
GitHub Copilot 是否可用于 PyCharm GitHub Copilot 是 Visual Studio Code、Visual Studio、Neovim 和 JetBrains 等不同 IDE 中的扩展。
它适用于 PyCharm IDE 的所有版本（专业版、社区版和教育版）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bfe8cdc2f7a167fbeb3e613532a0b32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/028daf83cdbff4983276e72b727eb4de/" rel="bookmark">
			【基础工具篇使用】VScode 远程 Ubuntu 系统 进行使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 准备条件使用步骤step1： 打开远程窗口step2：选择中的红色框“Connect to Host”功能Step3: 根据图中的红色框提示信息输入远程电脑的用户名和 IP 地址，输入如下命令即可连接： 显示效果 准备条件 我们可以使用 vscode 的远程功能插件“Remote-SSH”，此插件可以进行远程开发。使用此插件前有两个前提：本地端、远
程端需要安装 vscode、本地和远程网络可以相互 ping 通。
这里已经安装完成，并且可以使用
使用步骤 step1： 打开远程窗口 step2：选择中的红色框“Connect to Host”功能 Step3: 根据图中的红色框提示信息输入远程电脑的用户名和 IP 地址，输入如下命令即可连接： ssh morgan@192.168.2.153 -A 配置文件如下：
Host 192.168.2.153 HostName 192.168.2.153 User morgan ForwardAgent yes 显示效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfc3bf6ea73b527aea54d20ea69c6434/" rel="bookmark">
			Defi安全-Monox攻击事件Foundry复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其它相关内容可见个人主页 Mono攻击事件的介绍见：Defi安全–Monox攻击事件分析–phalcon+etherscan
1. 前情提要和思路介绍 Monox使用单边池模型，创建的是代币-vCash交易对，添加流动性时，只需添加代币，即可进行任意代币的兑换
主要的漏洞有两个方面：
可以在Monox官网查看提供代币流动性的用户地址，但是每个用户的流动性，任意的用户都可以调用移除流动性函数，进行流动性的移除。在Monoswap的代币交换函数中，并未考虑tokenIn 和tokenOut相等的情况，代码逻辑处理的时候，出现价格覆盖的情况，Mono代币价格异常抬升，具体可见相关攻击实现的分析。 2. Foundry复现攻击流程 foundry进行外部合约调用的时候，用interface定义相应的方法，并定义对应合约的地址，实现外部合约的调用（觉得比较好的方式）
pragma solidity &gt;=0.7.0 &lt;0.9.0; import "forge-std/Test.sol"; interface IERC20 { function balanceOf(address owner) external view returns (uint256); function approve(address spender, uint256 value) external returns (bool); function transfer(address to, uint256 value) external returns (bool); function deposit() external payable; } interface IuniswapV2pair { function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; } interface IMonoswap { function removeLiquidity (address _token, uint256 liquidity, address to,uint256 minVcashOut, uint256 minTokenOut) external returns(uint256 vcashOut, uint256 tokenOut); function addLiquidity(address _token, uint256 _amount, address to) external returns (uint256 liquidity); function swapExactTokenForToken( address tokenIn, address tokenOut, uint amountIn, uint amountOutMin, address to, uint deadline ) external returns (uint amountOut); function swapTokenForExactToken( address tokenIn, address tokenOut, uint256 amountInMax, uint256 amountOut, address to, uint256 deadline ) external returns (uint256 amountIn); function pools(address) external view returns ( uint256 pid, uint256 lastPoolValue, address token, uint8 status, uint112 vcashDebt, uint112 vcashCredit, uint112 tokenBalance, uint256 price, uint256 createdAt ); } interface IMonoXPool { function totalSupplyOf(uint256 pid) external returns (uint256); function balanceOf(address account, uint256 id) external returns (uint256); } address constant uniswapv2pair = 0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc; address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; address constant Monoswap = 0xC36a7887786389405EA8DA0B87602Ae3902B88A1; address constant MonoXPool = 0x59653E37F8c491C3Be36e5DD4D503Ca32B5ab2f4; address constant Mono = 0x2920f7d6134f4669343e70122cA9b8f19Ef8fa5D; address constant usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; address constant liquidity_user1 = 0x7B9aa6ED8B514C86bA819B99897b69b608293fFC; address constant liquidity_user2 = 0x81D98c8fdA0410ee3e9D7586cB949cD19FA4cf38; address constant liquidity_user3 = 0xab5167e8cC36A3a91Fd2d75C6147140cd1837355; 攻击代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfc3bf6ea73b527aea54d20ea69c6434/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e9eaa9524325ee85e4136ae5b60ba5f/" rel="bookmark">
			GO语言简析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Go语言简介
二、Go语言的优势
三、Go语言的适用场景
四、Go语言的安装
4.1 资源获取和技术交流
4.2 下载步骤：
五、Go语言目录结构说明
六、Hello World程序示例
1. 在D:/go/文件夹下创建文件main.go。2. 输入以下代码：
3. 使用命令行运行程序：
4. 观察输出结果，应显示“Hello World”。
七、Hello World程序分析
7.1 文件
7.2 注释
7.3 package关键字
7.4 import关键字
7.5 main函数
7.6 编码问题
7.7 其他事项
八、Go语言常用命令
九、godoc命令
十、gofmt工具
一、Go语言简介 Go语言，又称为Golang，是Google公司在2009年推出的一种静态强类型、编译型和并发型语言。Go语言的设计目标是提高编程效率，它的语法接近C语言，但考虑了内存安全和垃圾回收等现代语言特性，同时也非常关注编译速度和执行效率。
二、Go语言的优势 - 语法简明：Go的语法设计简洁，去除了传统C语言中的复杂性（如指针运算和内存管理等）。
- 直接编译成机器码：Go语言的编译器可以将代码直接编译成机器码，而非中间字节码，这意味着Go程序的执行速度非常快。
- 静态类型：Go是静态类型语言，这有助于在编译时发现错误。
- 并发支持：Go语言在语言层面原生支持并发，goroutine使并发和并行编程变得简单。
- 回收：Go内置垃圾回收功能，自动管理内存，减少内存泄漏的可能。
- 部署简单：Go编译后的程序包含了所有依赖，可以轻松部署到任何环境中。
- 强大的标准库：Go的标准库提供了大量的常用功能，例如HTTP服务、JSON处理等。
三、Go语言的适用场景 - 服务器编程：适合服务端逻辑处理，如日志、虚拟机处理、文件服务等。
- 分布式系统：常用于构建大型分布式、微服务架构和数据库代理。
- 网络编程：包括构建网络服务器、Web应用等。
- 云平台：Go语言与Docker等云服务平台的整合性非常好，适合云应用开发。
四、Go语言的安装 4.1 资源获取和技术交流 - 可通过Go语言中文网（https://studygolang.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e9eaa9524325ee85e4136ae5b60ba5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4700d4b42ae4ce9560dc771a25ebd431/" rel="bookmark">
			MySQL练习-DDL语法练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、数据库操作2、表操作3、DDL数据类型 突然想起来好久没写过SQL了，写一下SQL练习一下😊 个人写sql比较喜欢用小写😁
什么是DDL：DDL是对数据库和表的操作
在这里练习DLL的时候先不添加约束，后面会把约束集中在一起练习
1、数据库操作 # 查询所有数据库 show databases; #查询当前数据库 select database(); #创建数据库 create database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则]; #删除数据库 drop database [if exists] 数据库名 #使用数据库 use 数据库名; 2、表操作 #查询当前数据库所有表 show tables; #查询表结构 desc 表名 # 查询指定表的建表语句 show create table 表名; #创建表 create table 表名( 字段1 字段1类型[comment 字段1注释], 字段2 字段2类型[comment 字段2注释] )[comment 表注释]; #注意：[...]为可选参数，最后一个字段后面没有逗号 # 创建表示例 create table emp( id int comment '编号', name varchar(10) comment '姓名', gender char(1) comment '性别', age tinyint unsigned comment '年龄', entrydate date comment '入职时间' ) comment '员工表'; # 修改数据类型 alter table 表名 modify 字段名 新数据类型(长度); #修改字段名和字段类型 alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束]; #将emp表的name字段修改为username，类型为varchar(30) alter table emp change name username varchar(30) comment '用户名'; #删除字段 alter table 表名 drop 字段名 # 将emp表的字段username删除 alter table emp drop username; # 修改表名 alter table 表名 rename to 新表名; # 将emp表名改为employee alter table emp rename to employee; # 添加新的字段 alter table 表名 add 列名 数据类型(长度) [comment 注释]; # 删除表 drop table [if exists] 表名; # 删除指定表，并重新创建该表 truncate table 表名; # 注意：在删除表的时候，表中的数据也会被删除 3、DDL数据类型 如果用得到，大家可以收藏一下😀😀😀
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe5dfc2f274264948ddf00411b4dd17/" rel="bookmark">
			嵌出式学习小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		独立看门狗：
键值寄存器IWDG_KR 0-15位有效
预分频寄存器IWDG_PR 0-2位有效 具有写保护功能，要操作需要先取消写保护
重装载寄存器IWDG_RLR 0-11位有效 具有写保护功能，要操作需要先取消写保护
状态寄存器IWDG_SR 0-1位有效
软件必须在 一定间隔内写入0XAAAA 否则当计数器为0的时候 看门狗会复位
窗口看门狗：
窗口就是在喂狗的时间是有一个上下限的范围，可以通过设定相关寄存器，设定其上限时间（下限是固定的）。喂狗的时间不能过晚也不能过早。而独立看门狗限制喂狗时间在0-x内，x由相关寄存器决定，喂狗的时间不能太晚
为什么用窗口看门狗？
对于一般看门狗而言，程序可以在它产生复位前的任意任意时刻刷新看门狗，但这样有一个隐患，有可能程序跑飞又回到了正确地方，或跑乱的程序正好执行了刷新看门狗操作，这样的情况下一般的看门狗就检测不出来。
如果使用窗口看门狗，程序员可以根据程序正常执行的时间设置刷新看门狗的一个时间窗口，保证不会提前刷新看门狗也不会滞后刷新看门狗，这样可以检测出来程序没有按照正常路径运行非正常跳过某些程序段的情况。
窗口看门狗的注意事项
上窗口值W[6:0]必须大于下窗口值0X40,否则就无窗口了。
窗口看门狗时钟来源PCLK1(APB1总线时钟)分频后。
控制寄存器WWDG_CR
void WWDG_Enable(uint8_t Counter);//启动设置并且设置初始值
void WWDG_SetCounter(uint8_t Counter)//喂狗
窗口看门狗配置过程
1.使能看门狗时钟
RCC_APB1PeriphClockCmd();
2.设置分频系数
WWDG)SetPrescaler();
3.设置窗口值
WWDG_SetWindowValue();
4.开启提前唤醒中断并分组（可选）
WWDG_EnableT();
NVIC_Init();
5.使能看门狗
WWDG_EnableIT();
6.喂狗
WWDG_SetCounter();
7.编写中断服务函数
WWDG_IRQHandler();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4058d0ccd3420ef208035df82fb6ff1d/" rel="bookmark">
			数据结构入门到入土——ArrayList与顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，线性表
二，顺序表
1.接口实现
三，ArrayList简介
四，ArrayList使用
1.ArrayList的构造
2.ArrayList常见操作
3.ArrayList的遍历
4.ArrayList的扩容机制
五，ArrayLisit的具体使用
杨辉三角
一，线性表 线性表 （ linear list ） 是 n 个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列... 线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储。 二，顺序表 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成数据的增删查改。 1.接口实现 接口部分：
public interface IList { // 新增元素,默认在数组最后新增 public void add(int data); // 在 pos 位置新增元素 public void add(int pos, int data); // 判定是否包含某个元素 public boolean contains(int toFind); // 查找某个元素对应的位置 public int indexOf(int toFind); // 获取 pos 位置的元素 public int get(int pos); // 给 pos 位置的元素设为 value public void set(int pos, int value); //删除第一次出现的关键字key public void remove(int toRemove); // 获取顺序表长度 public int size(); // 清空顺序表 public void clear(); // 打印顺序表，注意：该方法并不是顺序表中的方法，为了方便看测试结果给出的 public void display(); //判断顺序表是否已满 public boolean isFull(); //判断顺序表是否为空 public boolean isEmpty(); } 接口实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4058d0ccd3420ef208035df82fb6ff1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76f96e3b56bbd6eb6f8a86f0d30813dc/" rel="bookmark">
			zookeeper经典应用场景之分布式锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是分布式锁 在单体的应用开发场景中涉及并发同步的时候，大家往往采用Synchronized（同步）或者其他同一个JVM内Lock机制来解决多线程间的同步问题。在分布式集群工作的开发场景中，就需要一种更加高级的锁机制来处理跨机器的进程之间的数据同步问题，这种跨机器的锁就是分布式锁。
2. 分布式锁的主流方案 基于数据库的分布式锁：这种方案使用数据库的事务和锁机制来实现分布式锁。虽然在某些场景下可以实现简单的分布式锁，但由于数据库操作的性能相对较低，并且可能面临锁表的风险，所以一般不是首选方案。基于Redis的分布式锁：Redis分布式锁是一种常见且成熟的方案，适用于高并发、性能要求高且可靠性问题可以通过其他方案弥补的场景。Redis提供了高效的内存存储和原子操作，可以快速获取和释放锁。它在大规模的分布式系统中得到广泛应用。基于ZooKeeper的分布式锁：这种方案适用于对高可靠性和一致性要求较高，而并发量不是太高的场景。由于ZooKeeper的选举机制和强一致性保证，它可以处理更复杂的分布式锁场景，但相对于Redis而言，性能可能较低。 2.1 基于数据库实现分布式锁设计思路 我们可以利用数据库的唯一索引来实现，唯一索引天然具有排他性。设计思路如下图所示：
这种基于数据库的分布式锁会有什么问题呢？ 很明显，容易出现死锁的问题。基于数据库设计分布式锁，在当下不是首选方案，不在过多赘述，大家明白其中设计思想即可。
2.2 基于redis实现分布式锁设计思路 基于redis设计的分布式锁设计是利用了其SETNX的特性，其是set If not exist的简写。意思就是当 key 不存在时，设置 key 的值，存在时，什么都不做。以下是一个基于redis设计分布式锁的一个基础方案。
上述方案，从技术的角度看：setnx 占锁成功，但业务代码出现异常或者服务器宕机，没有执行删除锁的逻辑，就会造成死锁。
上述是基本方案，之所以称之为基本方案，因为里面还是会有很多问题，比如没有来得及释放锁导致死锁；等待抢锁的线程太多，当当前锁释放后，等待的线程全都去抢占改锁出现的羊群效应；总之值得优化的地方还很多，本文中不在过多赘述，大家体会其中的设计思想，后续会出redis设计分布式锁的详细文章。
2.3 基于zookeeper实现分布式锁 2.3.1 青铜方案 使用临时 znode 来表示获取锁的请求，创建 znode成功的用户拿到锁。
想一想，上述设计存在什么问题？
如果所有的锁请求者都 监听 锁持有者，当代表锁持有者的 znode 被删除以后，所有的锁请求者都会通知到，都会竞争同一个资源，但是只有一个锁请求者能拿到锁。这就是羊群效应。 2.3.2 白银方案 我们想一下青铜方案的问题，就是羊群效应，那么在并发编程中是如何处理这种羊群效应的呢？并发编程中，当资源被占用时，其他线程都进入阻塞队列，资源被释放后，阻塞队列中的一个线程出队，进行获取资源。同理，我们想一想，如果等待监听的线程在一个队列里面，遵循先进先出的规则，我们就可以实现一把公平分布式锁的实现？
zookeeper的临时有序znode就是一个天然的队列，我们可以利用这个特性，使用临时有序znode来表示获取锁的请求，线程创建最小后缀数字 znode 的用户成功拿到锁。设计思路如下：
2.3.1 zookeeper之Curator 可重入分布式锁 上述我们讨论了一些利用zookeeper节点特性设计分布式锁的一些方案，但在实际的开发中，如果需要使用到分布式锁，不建议去自己“重复造轮子”，建议直接使用Curator客户端中的各种官方实现的分布式锁，例如其中的InterProcessMutex可重入锁。
2.3.1.1 使用示例 以下是利用Curator 的可重入锁实现订单号的生成示例：
public class CuratorLockTest implements Runnable{ private final static String CLUSTER_CONNECT_STR="192.168.31.5:2181,192.168.31.176:2181,192.168.31.232:2181"; final static CuratorFramework client= CuratorFrameworkFactory.builder() .connectString(CLUSTER_CONNECT_STR) .retryPolicy(new ExponentialBackoffRetry(100,1)) // 设置重试策略 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76f96e3b56bbd6eb6f8a86f0d30813dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b66118a3dc08da8958c9f23a7ce03a19/" rel="bookmark">
			使用MIG IP 核实现DDR3读写测试学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介
DDR3 SDRAM（Double-Data-Rate Three Synchronous Dynamic Random Access Memory）是 DDR SDRAM 的第三代产品，相较于 DDR2，DDR3 有更高的运行性能与更低的电压。DDR SDRAM 是在 SDRAM 技术的基础上发展改进而来的，同 SDRAM 相比，DDR SDRAM 的最大特点是双沿触发，即在时钟的上升沿和下降沿都能进行数据采集和发送，同样的工作时钟，DDR SDRAM 的读写速度可以比传统的 SDRAM 快一倍。本次实验使用的 DDR3 芯片是MT41K256M16JT，容量大小为 256M*16bit，也就是 512MByte，使用位于ZYNQ的PL侧的DDR3 芯片。
由于 DDR3 的时序非常复杂，如果直接编写 DDR3 的控制器代码，那么工作量是非常大的，且性能难以得到保证。值得一提的是，Artix7 系列 FPGA 自带了 DDR3 控制器的硬核，用户可以直接借助 IP 核来实现对 DDR3 的读写操作，从而大大降低了 DDR3 的开发难度。本次实验将使用 Xilinx 公司 MIG(Memory Interface Generators) IP 核来实现 DDR3 读写测试。
MIG IP 核是 Xilinx 公司针对 DDR 存储器开发的 IP，里面集成存储器控制模块，实现 DDR 读写操作的控制流程，下图是 7 系列的 MIG IP 核结构框图。MIG IP 核对外分出了两组接口。左侧是用户接口，就是用户（FPGA）同 MIG 交互的接口，用户只有充分掌握了这些接口才能操作 MIG。右侧为 DDR 物理芯片接口，负责产生具体的操作时序，并直接操作芯片管脚。这一侧用户只负责分配正确的管脚，其他不用关心。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b66118a3dc08da8958c9f23a7ce03a19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e056c500a1c4b6a7110b50d807bade5/" rel="bookmark">
			https
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https HTTP协议是以明文的方式传输数据，不提供任何方式的数据加密，因此加入了SSL协议，SSL的主要作用第一是给数据加密，保证数据的传输安全，第二是校验网站的SSL证书，验证其真实性。http加上ssl合称https。
https请求过程
1、首先客户端向服务端发起tcp连接请求
2、服务端收到客户端请求连接报文，服务器把CA私钥签名的数字证书（包含服务端公钥、颁发机构、有效期）发给客户端校验
3、客户端收到数字证书，把浏览器中内置的CA公钥校验证书合法性，并解析出服务端公钥，客户端随机生产了对称加密的密钥，用服务器公钥加密后发送服务端
4、服务端接收后成功建立tcp连接，此后使用对称加密密钥加密数据进行传输。
CA证书
CA证书就是CA机构（权威信誉机构）给服务器签发的证书。
CA机构自己会生成非对称加密的一对私钥公钥，浏览器会内置此类公钥，而私钥用来对服务器提供的公钥进行签名生成CA证书（包含机构的相关信息）。然后在服务器配置好CA证书，每次请求就会把CA证书返回给客户端。
没有CA证书会怎样
如果没有CA证书，https请求过程就是
1、首先客户端向服务端发起tcp连接请求
2、服务端返回公钥给客户端
3、客户端用公钥加密对称加密密钥，把密钥发送给服务端
4、服务端解析出密钥
此时若有第三方自己生成了一对公钥私钥，在第二步把服务器给客户端的公钥拦截替换成第三方的公钥，此时在第三步客户端就会使用第三方的公钥加密对称加密密钥，在返回密钥给服务器时，第三方又拦截了，用自己的私钥就可以解析出数据，再用之前拦截的服务器公钥进行加密还给服务器。这样就不声不息窃取了请求数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31619562acd329f3ecb1069036dbb2db/" rel="bookmark">
			数据结构入门到入土——链表（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，与链表相关的题目（2）
1.输入两个链表，找出它们的第一个公共节点
2.给定一个链表，判断链表中是否有环
3.给定一个链表，返回链表开始入环的第一个节点，若无则返回null
一，与链表相关的题目（2） 1.输入两个链表，找出它们的第一个公共节点 下面是两个相交的链表
此时要找两个链表的相交节点非常简单
只需要将两个链表的头节点分别向后移
当head1 == head2 时说明改节点是它们的相交节点
但当两个链表长度不一样的时候就会出现问题
遇到这种情况，一般会先求出两个链表的长度len1与len2，让长的那个链表走两链表的差值步（len1-len2）/（len2 - len1）
之后走相同步数直至相遇
代码示例：
public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode cur1 = headA; ListNode cur2 = headB; int count1 = 0; int count2 = 0; while (cur1.next != null) { count1++; cur1 = cur1.next; } cur1 = headA; while (cur2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31619562acd329f3ecb1069036dbb2db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b228cd0e11bfa7f6972df969e300df4e/" rel="bookmark">
			江科大STM32
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 STM32简介 STM32简介 我们主要学习的就是STM32的外设。
NVIC：内核里面用于管理中断的设备，比如配置中断优先级这些东西SysTick：内核里面的定时器，主要用来给操作系统提供定时服务的，STM32是可以加入操作系统的，比如FreeRTOS、UCOS等。如果用了这些操作系统，就需要SysTick提供定时来进行任务切换的功能。也可以用这个定时器来完成Delay函数的功能RCC：可以对系统的时钟进行配置，还有就是使能各模块的时钟。在STM32中，其他(非内核)外设在上电的情况下默认是没有时钟的，不给时钟操作外设是无效的，目的是降低功耗。所以在操作外设前，必须要先使能时钟，这就需要用RCC来完成时钟的使能AFIO：可以完成复用功能端口的重定义，还有中断端口的配置EXTI：配置好外部中断后，当引脚有电平变化时，就可以触发中断，让CPU来处理任务TIM：整个STM32最常用、功能最多的外设。分为高级定时器、通用定时器、基本定时器ADC：内置了12位的AD转换器，可以直接读取IO口的模拟电压值，无需外部连接AD芯片，使用非常方便DMA：帮助CPU完成搬运大量数据这样的繁杂工作PWR：可以让芯片进入睡眠模式等状态，来达到省电的目的BKP：是一段存储器，当系统掉电时，仍可由备用电池保持数据，可以根据需要完成一些特殊功能DAC：它可以在IO口直接输出模拟电压，是ADC模数转换的逆过程FSMC：可以用于扩展内存，或者配置成其他总线协议，用于某些硬件的操作 引脚定义：
标红色的是电源相关的引脚标蓝色的是最小系统相关的引脚标绿色的是IO口、功能口这些引脚 S代表电源、I代表输入、O代表输出、I/O代表输入输出、FT代表代表能容忍5V电压，没有FT的只能容忍3.3V电压，如果没有FT的需要接5V的电平，就需要加装电平转换电路了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e0dfb23b77652a63f734c3d09d8de81/" rel="bookmark">
			C&#43;&#43; goto语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作用：可以无条件跳转语句，类似计算机组成原理mips指令集中的jump直接跳转指令（汇编语言）。
语法：goto标记；
解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置
#include&lt;bits/stdc++.h&gt; using namespace std; int main(){ cout&lt;&lt;"1,xxxx"&lt;&lt;endl; cout&lt;&lt;"2,xxxx"&lt;&lt;endl; for(int i=0;i&lt;10;i++){ cout&lt;&lt;"4,xxxx"&lt;&lt;endl; goto flag; }	flag: cout&lt;&lt;"5,xxxx"&lt;&lt;endl; cout&lt;&lt;"6,xxxx"&lt;&lt;endl; } 从上述代码中可以看出，就算goto语句在循环结构中，也是可以直接跳出循环的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7a6739da53405cab37a64c63934ebf/" rel="bookmark">
			Vue 自定义仿word表单下拉框组件，让操作更符合用户习惯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预览时显示界面
进入编辑框时
组件代码
&lt;template&gt; &lt;div class = "paper-select ui-select flex flex-col full-width" &gt; &lt;div ref="content" class="content font-s flex flex-center-cz padding-left-m padding-right-m flex-space-between" @click="select" style="border:none;" :class="[readonly === true ? 'readonly' : '']" &gt; &lt;div class="selected flex flex-center-cz text-center font-l" style="height:auto; text-align: center;font-family: FangSong;" &gt;{{text}} &lt;/div&gt; &lt;div class="down margin-top-s pointer" &gt;&lt;/div&gt; &lt;/div&gt; &lt;div v-if="show" class="position-relative" &gt; &lt;div class="list flex flex-col font-s scroll" :style="{left:leftValue,top:topValue,width:listWidth+'px'}"&gt; &lt;div @click="inputClick" v-if="data.length&gt;20"&gt; &lt;SearchInput @search="search" :name="'searchOrg'" :focus="'focus'" class="margin-top-s margin-left-s margin-right-s"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b7a6739da53405cab37a64c63934ebf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f6d2be4e56c3ad74e8b7fee677052d2/" rel="bookmark">
			逆置算法和数组循环移动算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		元素逆置 概述：其实就是将 第一个元素和最后一个元素交换，第二个元素和倒数第二个元素交换，依次到中间位置。用途：可用于数组的移动，字符串反转，链表反转操作，栈和队列反转等操作。 逆置图解 代码 // 逆置元素算法 void Reverse(int R[] , int l , int r){ // R 数组，l 左边 r 右边 int i , j ,temp; for(i=l , j=r; i &lt; j; i++,j--){	// i &lt; j 不过数组个数是奇数还是偶数都行 temp = R[i]; R[i] = R[j]; R[j] = temp; } } 注意：逆置算法很简单，但是能延申其他的算法
循环移动算法 考研常考的一个算法，结合逆置算法，可进行实现 循环左移(右移)算法 图解 第一步：循环左移 p 个元素，就将 数组前 p 个（0~p-1）元素先进行逆置第二步：再将 数组 p-1位置 之后的（n-p）个元素进行逆置第三步：将 整个数组 整体进行逆置，即可得到 循环左移 p 个元素 代码 // 逆置元素算法 void Reverse(int R[] , int l , int r){ // R 数组，l 左边 r 右边 int i , j ,temp; for(i=l , j=r; i &lt; j; i++,j--){ temp = R[i]; R[i] = R[j]; R[j] = temp; } } // 循环左移算法 void LeftMove(int R[] , int n , int p){ // r 数组 n 数组元素个数 p 循环左移个数 if(p&lt;0 || p&gt;n){ cout &lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f6d2be4e56c3ad74e8b7fee677052d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78ce619a5b70a7ba717263404e7f9e9/" rel="bookmark">
			深入理解堆（Heap）：一个强大的数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.
个人主页：晓风飞 专栏：数据结构|Linux|C语言 路漫漫其修远兮，吾将上下而求索 文章目录 前言堆的实现基本操作结构体定义初始化堆（HeapInit）销毁堆（HeapDestroy） 重要函数交换函数（Swap）上浮调整（UpAdd）下沉调整（DnAdd） 重要操作向堆中插入元素（HeapPush）从堆中弹出元素（HeapPop） 堆的应用完整代码结语 前言 在计算机科学中，堆（Heap） 是一种非常重要的数据结构，广泛用于各种应用，从数据分析到算法优化，再到系统编程。堆的一个关键特性是其能够快速找到一组数中的最大或最小值。但是，什么是堆？如何在实际编程中实现和使用堆呢？
堆的实现 堆是一种特殊的完全二叉树。在一个最小堆中，每个父节点的值都小于或等于其子节点的值；相反，在一个最大堆中，每个父节点的值都大于或等于其子节点的值。这种属性使得堆能够快速访问、添加和删除其最大或最小元素。
基本操作 结构体定义 首先，堆是通过以下结构体定义的：
typedef struct Heap { HPDataType* a; // 指向堆数组的指针 size_t size; // 堆当前的大小 int capacity; // 堆的最大容量 } Hp; 这里，HPDataType* a 是一个指向动态分配数组的指针，该数组用于存储堆中的元素。size 表示堆中当前元素的数量，而 capacity是数组的最大容量。
初始化堆（HeapInit） 初始化函数 HeapInit 用于设置堆的初始状态：
// 初始化堆 void HeapInit(Hp* hp) { assert(hp); // 确保堆指针有效 hp-&gt;a = NULL; // 堆数组指针置空 hp-&gt;size = 0; // 初始化堆大小为0 hp-&gt;capacity = 0; // 初始化堆容量为0 } 此函数确保堆的开始状态为空，没有分配任何内存，且大小和容量都为零。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f78ce619a5b70a7ba717263404e7f9e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bf8d96199e6c474e41f5a48b5cc51f0/" rel="bookmark">
			微服务架构组件介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微服务架构组件介绍 目录概述需求： 设计思路实现思路分析1.微服务的概念2.微服务设计模式3.Spring cloud4.netfliex 这一套 参考资料和推荐阅读 Survive by day and develop by night.
talk for import biz , show your perfect code,full busy，skip hardness,make a better result,wait for change,challenge Survive.
happy for hardess to solve denpendies.
目录 概述 微服务架构是一个非常常见的需求。
需求： 设计思路 实现思路分析 1.微服务的概念 微服务架构是一种将软件系统拆分成多个独立的、可独立部署和扩展的服务的架构。每个服务都运行在自己的进程中，并使用轻量级通信机制（如HTTP或消息队列）相互通信。下面是微服务架构的一些常见组件：
服务：微服务架构的核心组件，每个服务都负责一个特定的业务功能，并独立运行在自己的进程中。每个服务可以使用不同的编程语言和技术栈，使得团队可以根据需要选择最适合的技术。
服务注册与发现：服务注册与发现组件用于管理和发现运行中的服务实例。当一个服务启动时，它会在注册中心注册自己的地址和元数据。其他服务可以通过查询注册中心来发现并与之通信。
负载均衡：负载均衡组件用于分发请求到多个服务实例，以平衡负载和提高系统的可用性和性能。常见的负载均衡策略包括轮询、随机和基于权重。
服务网关：服务网关是外部客户端与内部服务之间的统一入口。它可以处理认证、鉴权、流量控制和请求转发等功能，使得客户端与服务之间的通信变得简单和安全。
服务间通信：微服务架构中的服务需要相互通信来完成业务功能。常见的通信机制包括HTTP、消息队列、RPC等。选择合适的通信机制需要考虑性能、可靠性和开发复杂性等因素。
数据管理：微服务架构中每个服务通常有自己的数据存储或数据库。数据管理组件用于处理数据的存储、访问和同步等问题。常见的数据管理技术包括关系型数据库、NoSQL数据库和缓存等。
监控与日志：微服务架构需要对系统的运行状态进行监控和日志记录，以便及时发现和解决问题。监控与日志组件可以用于收集和分析系统的运行数据，并提供实时监控和问题排查的功能。
。
2.微服务设计模式 微服务设计模式很多，之前blog 文也提到过一些：
如下列出：
微服务架构是一种将软件系统拆分成多个独立的、可独立部署和扩展的服务的架构。每个服务都运行在自己的进程中，并使用轻量级通信机制（如HTTP或消息队列）相互通信。下面是微服务架构的一些常见组件：
微服务设计模式是指在微服务架构中，根据不同的需求场景和问题，使用不同的设计模式来实现各个微服务的功能。以下是一些常见的微服务设计模式：
服务注册与发现模式（Service Registry and Discovery Pattern）：使用服务注册中心来管理和发现微服务实例，实现微服务之间的通信。
服务代理模式（Service Proxy Pattern）：通过使用代理来隐藏具体的微服务实现细节，简化微服务之间的通信。
网关模式（Gateway Pattern）：将多个微服务的入口集成到一个网关中，统一处理请求和响应，提供统一的接口。
事件驱动模式（Event-driven Pattern）：使用事件驱动的方式来处理微服务之间的消息传递和数据同步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bf8d96199e6c474e41f5a48b5cc51f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bcaa572a887244f4c383ea35455b377/" rel="bookmark">
			CentOS-7安装Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装Docker Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。
Docker CE 分为 stable test 和 nightly 三个更新频道。
官方网站上有各种环境下的 安装指南，这里主要介绍 Docker CE 在 CentOS上的安装。
2.CentOS安装Docker Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。
2.1.卸载（可选） 如果之前安装过旧版本的Docker，可以使用下面命令卸载：
yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine \ docker-ce 2.2.安装docker 首先需要大家虚拟机联网，安装yum工具
yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 --skip-broken 更新XFS文件系统管理工具：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bcaa572a887244f4c383ea35455b377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d64c427417cd296755d7e8b38addb32/" rel="bookmark">
			20240104----重返学习-关于`npm --legacy-peer-deps`与`npm --force`升级版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记–legacy-peer-deps与–force的了解与思考
之前还是旧的版本:
"bpmn-js": "^7.3.1", "bpmn-js-properties-panel": "^0.37.2", "houtaroy-bpmn-js-properties-panel-activiti": "^0.0.1", 使用npm install bpmn-js bpmn-js-properties-panel houtaroy-bpmn-js-properties-panel-activiti --legacy-peer-deps后:
"bpmn-js": "^7.5.0", "bpmn-js-properties-panel": "^0.37.6", "houtaroy-bpmn-js-properties-panel-activiti": "^0.0.1", 相对旧版本升级了两个小版本,但结构没扁平化;
使用npm install bpmn-js bpmn-js-properties-panel houtaroy-bpmn-js-properties-panel-activiti --force后:
"bpmn-js": "^7.5.0", "bpmn-js-properties-panel": "^0.37.6", "houtaroy-bpmn-js-properties-panel-activiti": "^0.0.1", 相对旧版本升级了两个小版本,相对npm --legacy-peer-deps没升级,但结构扁平化了;
使用npm install bpmn-js@16.3.0 bpmn-js-properties-panel houtaroy-bpmn-js-properties-panel-activiti --legacy-peer-deps后:
"bpmn-js": "^16.3.0", "bpmn-js-properties-panel": "^0.37.6", "houtaroy-bpmn-js-properties-panel-activiti": "^0.0.1", 相对旧版本升级了几个大版本到了指定版本,但结构没扁平化,同时有些东西可能已经不再兼容当前UI框架或vue或react版本了;
使用npm install bpmn-js@16.3.0 @bpmn-io/properties-panel@3.13.0 bpmn-js-properties-panel@5.6.1 --legacy-peer-deps后:
"@bpmn-io/properties-panel": "^3.13.0", "bpmn-js": "^16.3.0", "bpmn-js-properties-panel": "^5.6.1", "camunda-bpmn-moddle": "^4.4.0", "houtaroy-bpmn-js-properties-panel-activiti": "^0.0.1", 相对旧版本升级了几个大版本到了指定版本,但结构没扁平化,同时也废弃了一些其它的依赖的升级如houtaroy-bpmn-js-properties-panel-activiti;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ee6bae64b6b2307283ba2bd0e1bbe8a/" rel="bookmark">
			C&#43;&#43;模板——(1)模板的概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 归纳编程学习的感悟，
记录奋斗路上的点滴，
希望能帮到一样刻苦的你！
如有不足欢迎指正！
共同学习交流！
🌎欢迎各位→点赞 👍+ 收藏⭐ + 留言​📝
创造机会的人是勇者，等待机会的人是愚者！
一起加油！
前言： 逻辑功能相同而类型不同的函数，可以通过重载实现统一方式(相同接口)，不同实现(不同功能）的调用。重载提高了编程的灵活性，但有时重载的两个函数逻辑功能基本一样，只是参数类型不同，几乎相同的代码要重复编写，十分烦琐。此时可以利用模板来减少重复编码工作。模板是实现代码复用的一种工具，是参数多态的一种体现，是提高软件开发效率的一个重要手段。
模板的概念： 函数和类本身是一种抽象，可以解决一类问题，模板是在抽象的基础上再抽象，它可以实现类型参数化，把类型定义为参数，实现代码的复用。从而使得抽象后的函数或类可以处理多种数据类型，这种能处理多种数据类型的函数和类就是函数模板和类模板。经过再次抽象后，程序的通用性。程序员能够通过模板快速建立具有类型安全的类库集合和函数集合，更加快捷、方便高效地进行大规模的软件开发。
例如，编写三个函数分别求三个整形、三个字符型、三个浮点型数的最大值。 int Max(int a,int b,int c) { int max=a&gt;b?(a&gt;c?a:c):(b&gt;c?b:c); return max; } char Max(char a,char b,char c) { char max=a&gt;b?(a&gt;c?a:c):(b&gt;c?b:c); return max; } float Max(float a,float b,float c) { float max=a&gt;b?(a&gt;c?a:c):(b&gt;c?b:c); return max; } 利用重载，我们写出了三个同名且函数体类似的函数。这些函数执行的功能都是相同的，只是输入参数的类型和返回的类型不同。能否把这些函数统一成一种形式，即将很多类似函数抽象为统一的形式?解决方法就是运用模板。模板，相当于函数的模具，利用模板就可以套印出许多功能相同，而参数类型和返回值类型不同的函数，最终根据需要得到相应的数据。这样就实现了代码可重用性。
C++的模板有两种不同的形:函数模板和类模板
以上就是我对C++模板——(1)模板的概念的理解，希望本篇文章对你有所帮助，也希望可以支持支持博主，后续博主也会定期更新学习记录，记录学习过程中的点点滴滴。如果有不懂和发现问题的小伙伴，请在评论区说出来哦，同时我还会继续更新对C++模板的理解，请持续关注我哦！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e62c050260a98a4c38d75610ebeecc/" rel="bookmark">
			Java：Stream流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、体验Stream流2、Stream流的常见生成方式3、Stream流中间操作方法4、Stream流终结操作方法5、Stream流的收集操作6、Stream流综合练习6.1 练习16.2 练习26.3 练习3 以下代码使用JDK11编写。
1、体验Stream流 （1）案例需求
按照下面的要求完成集合的创建和遍历
创建一个集合，存储多个字符串元素把集合中所有以"张"开头的元素存储到一个新的集合把"张"开头的集合中的长度为3的元素存储到一个新的集合遍历上一步得到的集合 （2）原始方式示例代码
public class StreamDemo01 { public static void main(String[] args) { //集合的批量添加 ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(List.of("张三丰","张无忌","张翠山","王二麻子","张良","谢广坤")); //list.add() //遍历list1把以张开头的元素添加到list2中。 ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(); for (String s : list1) { if(s.startsWith("张")){ list2.add(s); } } //遍历list2集合，把其中长度为3的元素，再添加到list3中。 ArrayList&lt;String&gt; list3 = new ArrayList&lt;&gt;(); for (String s : list2) { if(s.length() == 3){ list3.add(s); } } for (String s : list3) { System.out.println(s); } } } （3）使用Stream流示例代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84e62c050260a98a4c38d75610ebeecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d6235173e3560f7b1ddaffca6da9e4b/" rel="bookmark">
			Packet Tracer - Configure AAA Authentication on Cisco Routers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Packet Tracer - 在思科路由器上配置 AAA 认证 地址表 目标 在R1上配置本地用户账户，并使用本地AAA进行控制台和vty线路的身份验证。从R1控制台和PC-A客户端验证本地AAA身份验证功能。配置基于服务器的AAA身份验证，采用TACACS+协议。从PC-B客户端验证基于服务器的AAA（TACACS+）身份验证。配置基于服务器的AAA身份验证，采用RADIUS协议。从PC-C客户端验证基于服务器的AAA（RADIUS）身份验证。 背景/场景 网络拓扑图显示了路由器R1、R2和R3。目前，所有管理安全性都基于enable secret密码。您的任务是配置并测试本地及基于服务器的AAA解决方案。
您将在路由器R1上创建一个本地用户账户，并配置本地AAA以测试控制台和vty登录：
用户账户：Admin1，密码admin1pa55
接下来，将配置路由器R2以支持通过TACACS+协议实现的基于服务器的身份验证。TACACS+服务器已经预先配置了以下信息：
客户端：R2，关键字为tacacspa55
用户账户：Admin2，密码admin2pa55
最后，您将配置路由器R3以支持通过RADIUS协议实现的基于服务器的身份验证。RADIUS服务器已预先配置如下信息：
客户端：R3，关键字为radiuspa55
用户账户：Admin3，密码admin3pa55
此外，路由器还预配置了以下内容：
启用秘密密码：ciscoenpa55
使用MD5认证的OSPF路由协议，密码为：MD5pa55
注意：控制台和vty线路尚未预先配置。
注意：尽管IOS版本15.3使用了更为安全的加密哈希算法SCRYPT，但在Packet Tracer当前支持的IOS版本中仍使用MD5。请始终在您的设备上使用最安全的选项。
第一部分：在R1上配置本地AAA认证以实现控制台访问 步骤1：测试连通性
从PC-A向PC-B执行Ping操作。从PC-A向PC-C执行Ping操作。从PC-B向PC-C执行Ping操作。 步骤2：在R1上配置本地用户名
在R1上配置一个名为Admin1的用户名，设置秘密密码为admin1pa55。 R1(config)# username Admin1 secret admin1pa55
步骤3：在R1上为控制台访问配置本地AAA认证
在R1上启用AAA功能，并配置控制台登录时使用本地数据库进行AAA身份验证。 R1(config)# aaa new-model
R1(config)# aaa authentication login default local
步骤4：配置控制台线路使用定义的AAA认证方法
在R1上针对控制台登录启用AAA，并配置其使用默认方法列表进行AAA身份验证。 R1(config)# line console 0
R1(config-line)# login authentication default
步骤5：验证AAA认证方法
使用本地数据库验证用户EXEC登录过程。 通过以上配置后，可以在R1的控制台上用Admin1账户和对应的密码admin1pa55进行登录，验证本地AAA身份验证是否生效。
第二部分：在R1上配置本地AAA认证以实现vty线路访问 步骤1：配置域名和加密密钥以配合SSH使用
a. 在R1上将ccnasecurity.com设置为域名。
b. 创建一个1024位的RSA加密密钥。
R1(config)#ip domain-name ccnasecurity.com
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d6235173e3560f7b1ddaffca6da9e4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00bbffad3f5f8a2614581ab68e300758/" rel="bookmark">
			自动驾驶记忆泊车功能规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 文档范围. 5
2. 功能描述. 6
3. 状态机. 8
3.1 状态描述. 8
3.2 状态迁移条件. 9
4. 功能清单. 19
5. 功能流程. 30
5.1 功能逻辑. 30
5.1.1 HU路线列表查看. 30
5.1.2 HU路线学习. 30
5.1.3 HU使用路线匹配. 52
5.1.4 HU交互逻辑. 53
5.1.5 APP使用路线. 55
5.1.6 APP使用-实时环境查看. 60
5.1.7 灯光交互. 62
5.1.8 故障管理. 62
5.1.9 HMI引擎异常处理策略. 63
6. 性能需求. 64
6.1 建图性能需求. 64
6.2 定位性能需求. 64
6.3 通用性能需求. 65
6.4 规控性能需求. 65
7. 关联件要求. 67
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00bbffad3f5f8a2614581ab68e300758/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/22/">«</a>
	<span class="pagination__item pagination__item--current">23/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/24/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>