<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e408616ab8b362025e2b41c0ab0a5038/" rel="bookmark">
			CSP2023游记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSP2023游记 因为只考CSP-S，所以是下午才去的纪中。我差不多一点二十就到了，然后在车上睡了二十分钟，一点四十才进纪中。
进了纪中，我感慨万千：这个我曾经熟悉的地方，我曾经向往的地方，如今却变成了我不知多久才能来一次的地方。回想起小学时在这里学信息学，学得快乐，玩得也很尽兴，每次夏令营和冬令营都像一次旅行，结营时我还总是舍不得走。如今再来看，这里还是熟悉的样子，环境与之前相比没有太大的变化，生态还是一如既往的好。
两点十分的时候准备进考场，我见到了纪中的几个以前的同学，和他们打了招呼。
进了考场，监考老师宣读考场纪律。我们的监考老师说话比较幽默，还跟我们分享了上午有考生写侮辱性注释的事（当然，监考老师让他删掉了）。
两点半开考后，先看 T 1 T1 T1，并不难，很快就切了。一看时间，已经两点四十七了，做这题用了将近二十分钟，还是有点慢。
再看 T 2 T2 T2，看完题就想到要用栈，再加个哈希，然后发现这道题就解决了。打完已经到了三点四十。这道题实现起来并不难，所以我用的时间还是太多了。
T 3 T3 T3是一道模拟题，我照着题意打，花了一个多小时打出来。虽然题面看着很长，但实际上并不难打。后面调了一会儿，就过了大样例。
此时的时间时五点多一点，我只剩 T 4 T4 T4了。看了一下题，简单思考了一下，骗分是挺好骗的，但我好像已经想出了正解。我不知道剩下不到一个半小时打不打得出来，但后面还是决定去打正解。
这道题要分类得比较多，正解不好打，而且打的时候还陆陆续续出点问题。时间不知不觉到了六点，而我还有很多东西没打。六点零七时，我决定放弃正解，去骗分。谁知骗分的思路好想，但代码没那么好打，六点二十时骗分代码还没打多少。最后我只好放弃骗分，去检查前三题。
六点半，比赛结束了。
这次前三题都发挥得挺好，就是 T 4 T4 T4在策略上有些失误。
比完赛，我和纪中的几个以前的同学去附近吃饭。虽然我们有一段时间没见了，但关系仍旧很好，吃饭时还一直聊着学校里的琐事。
听纪中的那几个同学说，他们考得都不怎么好，还说快要退役了（这一点我不信）。但我听他们讲在纪中的生活，着实羡慕了。他们的伙食是真的好，夜宵还推出了新品。小卖部里的吃的虽然没有以前那么丰富，但比我们学校好很多。他们还说他们下午从五点到七点有两个小时吃饭和洗澡，所以他们还有很多时间打乒乓球和打篮球。之前在纪中学信息学的时候，教练总是让我们多运动，说“每天八小时的学习不如七小时的学习加一小时的运动”，所以那时我们每天都有很多时间打球和玩耍。而现在我的学校没有那么重视运动，所以我们的运动时间没那么多。根据亲身经历和他们的描述，我觉得纪中的生活还是挺令人向往的。
我还发现，他们考得不好，但是并没有表现得很沮丧，反而还有说有笑；而我，却在因为 T 4 T4 T4没拿到的部分分而懊恼。我突然意识到，学信息学为什么就非得那么功利呢？为什么就非要追逐一个很高的奖项呢？我之前一直是把信息学当做一门兴趣来学的，我觉得在学习知识的同时，能有一个舒适的学习环境，一群志同道合的朋友，过着自己喜欢的生活，其实拿什么奖、拿多少分已经不重要了。如果你能力很强但并不怎么快乐，那还不如过普普通通而又无忧无虑的生活。遵从自己的意愿，以自己喜欢的方式生活，不给自己太大的压力，这才是最重要的。
纪中的这些同学，他们以前在学习和生活中给予了我很多帮助和教导。如今，他们又教导了我一次。虽然今天有一点小失误，但我觉得，能够打出前三题，拿那么多分，已经很令人满足了。对自己的要求不能太高，尽力就好，开心就好。
（当然，以上都是个人观点）
记得以前每次出去和别人吃饭，都是吃完一直在等别人聊天，等得很不耐烦。这次，我们聊天聊得真的开心，根本不想走，家长催了我们好几次我们才恋恋不舍地散了。
到此，CSP2023告一段落。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/128e15f323e897c17554d170fce7173f/" rel="bookmark">
			DCDC直流转换器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是DCDC？
DCDC是直流变换器，表示的是将某一电压等级的直流电源变换其他电压等级直流电源的装置。DCDC按电压等级变换关系分升压电源和降压电源两类，按输入输出关系分隔离电源和无隔离电源两类。
DCDC工作原理
DCDC转换器就是重复通断开关，把直流电压或电流转换成高频方波电压或电流，再经整流平滑变为直流电压输出。
DCDC优点
DCDC效率高，功率可以做到很大，适用于输入输出压差很大，压降和发热关系不大
DCDC缺点
开关方式下电源噪声比较厉害，纹波较大
DCDC的三种拓扑结构
第一个是Buck、第二个是Boost，第三个是Buck-Boost（有的文档也称为反极性Boost）
​
如果电感连接到地，就构成了升降压变换器，如果电感连接到输入端，就构成了升压变换器。如果电感连接到输出端，就构成了降压变换器。
DCDC拓扑的意义
我们用排列组合的方式可以有多种方法来构造，既含有电感又能为电感电流提供续流回路的拓扑，以达到我们需要的目的。
DCDC的同步整流和异步整流
在DCDC降压电路中存在同步整流和异步整流两种工作方式，这两种方式的工作原理图如下。
从上图可以看出，异步整流和同步整流的区别，就在于同步整流采用了通态电阻极低的MOSFET管代替了二极管。相比于异步整流使用的二极管来说，同步整流大大的降低了损耗!但是价格也相对昂贵!
采用同步整流和异步整流的好处
采用同步整流时，降低了损耗，发热低，提高了工作效率，与之对应的是芯片的价格昂贵。
异步二极管轻载时的损耗较大
DCDC的常用芯片选择有LM2596 MP2315 TPS5430等
下面用TPS5430进行举例
​
​
原理图
​
关于PCB图，布局一定要跟着芯片手册走，因为会涉及到各种电磁干扰之类的问题，初学很容易出问题，唉超烦的，我每次都卡在布局的问题上(；′⌒`)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efc8d3da962df420c30aef5244e13599/" rel="bookmark">
			Visual Studio编译报错:常量中含有换行符的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++学习记录,当用c++写代码编译遇到报错，说常量中有换行符时，其实就是编码格式用了中文简体，改成utf-8格式就行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6100903c8fc54eb3cc427aa7b3697802/" rel="bookmark">
			01背包问题（分支限界法&#43;python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class node: def __init__(self, level, value, weight, flag):#当前在解空间数的层次、价值、重量、左右子树标记左1右0 self.level = level self.value = value self.weight = weight self.flag = flag self.bound = 0 self.container = [] def bound(i, node, items, w): re_weight = w - node.weight bound = node.value while (i &lt; len(items)): if (items[i][1] &lt; re_weight): bound = bound + items[i][0] re_weight = re_weight - items[i][1] i = i+1 else: bound = bound + items[i][0] / items[i][1] * re_weight break return bound def bag(n, w, items): items.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6100903c8fc54eb3cc427aa7b3697802/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ce4095d203b32879630976edd4cdb11/" rel="bookmark">
			虚拟路由冗余协议VRRP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是VRRP？
VRRP中的重要设备
MASTER路由器
BACKUP路由器
VRRP的工作过程
VRRP实验
什么是VRRP？ VRRP能够在不改变组网的情况下，将多台路由器虚拟成一个虚拟路由器，通过配置虚拟路由器的IP地址为默认网关，实现网关的备份。
协议版本：vrrpv2（仅适用于ipv4，常用） vrrpv3（适用于ipv4和ipv6）
报文：只有唯一的Advertisement报文（通告报文）;其目的IP地址是224.0.0.18，协议号是112。
VRRP中的重要设备 MASTER路由器 定期发送VRRP报文。
以虚拟MAC地址响应对虚拟IP地址的ARP请求。
转发目的MAC地址为虚拟MAC地址的IP报文。
如果它是这个虚拟IP地址的拥有者，则接收目的IP地址为这个虚拟IP地址的IP报文。否则，丢弃这个IP报文。
如果收到比自己优先级大的报文则转为Backup状态。
如果收到优先级和自己相同的报文，并且发送端的主机IP地址比自己的主IP地址大，则转为Backup状态。
当接收到接口的Shutdown事件时，转为Initialize。
BACKUP路由器 接收Master路由器的发送的VRRP报文，判断Master路由器的状态是否正常。
对虚拟IP地址的ARP请求，不做响应。
丢弃目的MAC地址为虚拟MAC地址的IP报文。
丢弃目的IP地址为虚拟IP地址的IP报文。
Backup状态下如果收到比自己优先级小的报文时，丢弃报文，不重置定时器；如果收到优先级和自己相同的报文，则重置定时器，不进一步比较IP地址。
当Backup接收到MASTER_DOWN_TIMER定时器超时的事件时，才会转为Master。
当接收到接口的Shutdown事件时，转为Initialize。
VRRP的工作过程 虚拟路由器中的路由器根据优先级选举出Master路由器。Master路由器周期性发送VRRP报文，以公布其配置信息和工作状况。如果Master路由器出现故障，虚拟路由器中的Backup路由器将根据优先级重新选举新的Master路由器。虚拟路由器状态切换时，Master路由器由一台设备切换为另外一台设备，新的Master路由器只是发送一个携带虚拟路由器的MAC地址和虚拟IP地址信息的ARP报文，这样就可以更新与它连接的主机或设备中的ARP相关信息。网络中的主机感知不到Master路由器已经切换为另外一台设备。Backup路由器的优先级高于Master路由器时，由Backup路由器的工作方式(抢占方式和非抢占方式)决定是否重新选举Master。 VRRP实验 先配置pc主机地址，然后进入AR4路由器（master）进行设置
配置完成，进入AR3路由器（backup）进行设置
主 备路由器设置完成后，进入AR2进行最后配置
完成所有配置，进行ping测试
ping通，再剪断AR4与交换机之间的连线，看backup路由器是否生效
ping通，backup路由器生效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d166840839636678d6805cc302a2e778/" rel="bookmark">
			Linux 学习笔记之常用命令（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 学习笔记 一、 常用命令 LINUX常用操作命令和命令行编辑快捷键 终端 快捷键 Ctrl + a/Home 切换到命令行开始 Ctrl + e/End 切换到命令行末尾 Ctrl + l 清除屏幕内容，效果等同于 clear Ctrl + u 清除剪切光标之前的内容 Ctrl + k 剪切清除光标之后的内容 Ctrl + y 粘贴刚才所删除的字符 Ctrl + r 在历史命令中查找 （这个非常好用，输入关键字就调出以前的命令了） Ctrl + c 终止命令 ctrl + o 重复执行命令 Ctrl + d 退出 shell，logout Ctrl + z 转入后台运行,但在当前用户退出后就会终止 Ctrl + t 颠倒光标所在处及其之前的字符位置，并将光标移动到下一个字符 Alt + t 交换当前与以前单词的位置 Alt + d 剪切光标之后的词 Ctrl+w 剪切光标所在处之前的一个词（以空格、标点等为分隔符） Ctrl+（x u） 按住 Ctrl 的同时再先后按 x 和 u，撤销刚才的操作 Ctrl+s 锁住终端 Ctrl+q 解锁终端 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d166840839636678d6805cc302a2e778/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50fb19bd5ca80b2807d67b3da3f32a0e/" rel="bookmark">
			给数字人生成加上界面，基于ER-NeRF/RAD-NeRF/AD-NeRF，Gradio框架构建WEBUI，使用HLS流媒体，实现边推理边播放——之二：将ndarray内存序列图直接转成ts格式视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 前文说到，我们的目标是要实现服务器一边推理一边播放视频的效果，并且知道服务器现在的推理状况前文链接：http://t.csdnimg.cn/Gy6JU服务器日志实时在webui中输出前文已经讲解，这里讲解如何边推边播要实现边推边播，最重要的问题是要选择一种视频播放协议，使浏览器能直接播放没有完整生成的视频文件（不要直播推流那一套，毕竟服务器资源有限），其次要解决视频文件直接从内存中转存的问题根据我们的要求，hls协议就能满足我们的要求：基于http协议，不需要单独再架设流媒体服务器，使用m3u8索引文件对视频文件进行概括，边播边加载，不会全部加载所有文件… 效果 实现 首先，我们需要根据hls协议，生成索引m3u8文件。
当前的状态是我们只有一个音频文件，视频文件是完全由机器推理生成的。
所以我们只能根据音频文件，自己拼凑一个m3u8文件：
默认我们每个ts文件是5s钟，那么根据音频文件的长度，就可以拼凑成一个完整的索引文件：
def create_m3u8_by_totalTime(totalTime: int, save_path_name: str): '''根据总时长，按每5s一段，创建一个m3u8文件，返回每个ts文件的名字队列 :param totalTime 总时长，ms :param save_path_name m3u8文件要存储的路径及名称，以.m3u8为后缀 :returns 返回每个ts的名字的队列对象及最后一个ts的时长(ms) ''' dir = os.path.dirname(save_path_name) if not os.path.exists(dir): os.makedirs(dir) segment = int(totalTime / 5000) if totalTime % 5000 == 0 else int(totalTime / 5000) + 1 tsQueue = queue.Queue(segment) with open(save_path_name, 'w') as m3u8: m3u8.write('#EXTM3U\n') m3u8.write('#EXT-X-VERSION:3\n') m3u8.write('#EXT-X-MEDIA-SEQUENCE:0\n') # 当播放打开M3U8时，以这个标签的值作为参考，播放对应的序列号的切片 m3u8.write('#EXT-X-ALLOW-CACHE:YES\n') m3u8.write('#EXT-X-TARGETDURATION:6\n') # ts播放的最大时长，s lastTime = -1 for i in range(segment): if i + 1 == segment: lastTime = totalTime % 5000 m3u8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50fb19bd5ca80b2807d67b3da3f32a0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f76e8526cbb2f329d7dbd66b6e58276/" rel="bookmark">
			R语言——报错：Error in (function (classes, fdef, mtable)：函数‘select’标签‘“data.frame“’找不到继承方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R语言 R语言——报错：Error in (function (classes, fdef, mtable)：函数‘select’标签‘“data.frame”’找不到继承方法
文章目录 R语言解决方案 有时候上一秒还能使用，下一秒就会报这个错误
Error in (function (classes, fdef, mtable)：函数‘select’标签‘“data.frame”’找不到继承方法
解决方案 第一种：因为系统无法辨别select这个函数属于哪个程序包，在select前面加dplyr::
dplyr::select 第二种：关闭R软件，重新打开，然后运行，就解决了（软件偶尔抽筋，但凡出现之前的程序能用，突然不能用的情况，都重启重新加载一下好了）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59fdde05a641bcc3565a2af0d36a7be1/" rel="bookmark">
			理解深度学习中的自动微分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、自动微分定义 引用自 李沐《动手学深度学习》
深度学习框架可以通过自动计算导数，即自动微分（automatic differentiation）来加快求导。具体的，根据设计好的模型，torch会构建一个计算图（computational graph）， 来跟踪计算是哪些数据通过哪些操作组合起来产生输出。 自动微分使系统能够随后反向传播梯度。 这里，反向传播（back propagate）意味着跟踪整个计算图，填充关于每个参数的偏导数。
以上这段话总体介绍了自动微分的定义及其各类概念，我们将在下面的讲解中进行不断的分点理解。
阅读以下内容时博主在这里斗胆将自动微分与反向传播画上等号，即以下文章中，反向传播与自动微分意义相等。
二、反向传播中的概念 1. 计算图（dynamic graph） 上来先入为主，PyTorch在进行反向传播时是通过图的形式进行计算的，这个图称为计算图。这句话的意思是，反向传播这一个过程不是凭空产生的说传播就传播，而是借助图来传播的，这图叫计算图。
下图即是一个简单的计算图，其中蓝色代表叶子节点，绿色代表根节点，灰色代表要进行的运算，箭头方向为前向传播的方向。
初看这张图时可能有很多疑问，什么是叶子节点，什么又是运算，什么是前向传播，标题中的反向传播又是什么。不要担心，相信你阅读完这篇文章后都会明白的。
首先，在pytorch的计算图里只有两种东西：数据（tensor） 和 运算（operation），其中：
运算包括了：加减乘除、开方、幂指对、三角函数等可求导运算数据包括了：叶子节点 和 非叶子节点 两种数据类型（所以数据就是节点，节点就是数据），其中，数据为Tensor（张量）格式。每个Tensor（每个节点、每个数据）都具有如下属性： 是否可以（需要）求（计算）梯度 ：.requires_grad
创建出（运算出）该节点的方式：.grad_fn
是否为叶子节点 ：.is_leaf
梯度值：.grad
也就是说，计算图中的每个节点（数据）都有四个属性围绕着他，这四个属性存储了这个数据的一些基本信息，可以表明这个节点的身份信息，同时也决定了它是否是我们反向传播的最终目标（后续会讲）。
既然我们已经知道了计算图的组织结构，即 数据 + 运算，而且我们也知道了数据分两种，分别是叶子节点和非叶子节点，那我们怎么来判断某个数据是否是叶子节点呢？
2. 是否是叶子节点 我们判断计算图中的数据是否是叶子节点时，我们是有判断规律的。
两种情况下的tensor会是叶子节点：
它的属性 .requires_grad为False
也就是说，当一个张量的 requires_grad= False，那它就是叶子节点。 X = torch.tensor([1.0, 2.0, 3.0]) #没有手动指明requires_grad=True，则默认为False print(X.requires_grad) print(X.is_leaf) &gt;&gt;&gt;False #不可求梯度 &gt;&gt;&gt;True #是叶子节点 它的属性 .requires_grad为True，但不是经由运算得到的。
也就是说，当一个张量时的 requires_grad=True，并且此该张量是由用户自定义出来的，而不是经过运算得到，它是叶子节点。 X = torch.tensor([1.0, 2.0, 3.0], requires_grad=True) #手动指明requires_grad=True print(X.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59fdde05a641bcc3565a2af0d36a7be1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/947269760e94b9b0fd500da2e9ed0f59/" rel="bookmark">
			Java中为日期增加一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用日历 Calendar 类向 Java 中的日期添加一天。
只需在日历类实例中添加一天即可完成：
代码如下（示例）：
//设置日期格式 SimpleDateFormat sdfTime = new SimpleDateFormat("yyyy-MM-dd"); //获取当前时间 Date dt = new Date(); int addDay = 1;//指定增加天数 Calendar c = Calendar.getInstance(); c.setTime(dt); //输出今天的日期 System.out.println("Today: "+sdfTime.format(c.getTime())); //增加一天 c.add(Calendar.DAY_OF_MONTH, addDay); //输出明天的日期 System.out.println("Tomorrow: "+sdfTime.format(c.getTime())); 输出：
Today: 2023-10-10
Tomorrow: 2023-10-11
参考：在Java中为日期增加一天的多种方法_java_脚本之家
Calender类进行日期计算_calendar 月份从0开始-CSDN博客 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42676fb831ce4ab6a23d32a68ef95cf/" rel="bookmark">
			Qt使用一行代码轻松改变按钮图标颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt使用一行代码轻松改变QPushButton QToolButton图标颜色 需求：Qt程序主界面改变主题颜色时，例如白色背景色切换为深色模式，背景会变成深色。通常按键的图标会使用黑色，这时应该将图标改为白色系，应该轻松快捷去实现，而不是准备多一套白色系的图标供读取。
我查了挺多博客，挺多方法都绕得挺麻烦的，我做了不少尝试，最后发现其实用一行代码就能实现这个换颜色的需求，分享给各位。
解决方法 先列代码
pushButton-&gt;setIcon(QColorIcon::GetIcon(":/icon/icon/xxxx.png", QColor(170,170,191))); 直接调用QPushButton的setIcon函数，使用QColorIcon的静态方法去获取图标对象就行了。
GetIcon有两个参数，第一个是图标的路径(可以是文件的绝对路径，也可以是资源文件中的路径，不知道用哪个就多尝试)
第二个参数是颜色参数，用QColor包装一下rgb颜色值传入就行。
效果 原图标：
效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b7d24b8b61ff940dce73e299cc38733/" rel="bookmark">
			Ubuntu下Qt使用QProcess执行shell脚本并实时输出的标准方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu下Qt使用QProcess执行shell脚本并实时输出的标准方法 Qt中执行终端命令和执行shell脚本文件是一个常见需求，一般可以在c++中直接调用system()实现执行终端命令，shell脚本同样也可以，但是会阻塞程序。实际上更推荐使用Qt中提供的QProcess，高度封装好的功能，拥有非阻塞的优点。
但是我在网上看了很多博客，内容大多数互相转载搬运甚至抄袭，如果跟着大多数博客去使用QProcess的话，分分钟踩坑和浪费时间调试。
常见踩坑，见到避开 很多方法都是教人这么用QProcess，基本会程序阻塞，而且得不到想要的输出结果。
QProcess process; process.start(bash); process.write("hello.sh"); process.waitForFinished();	//或者用waitForStarted()函数 QByteArray output = process.readAllStandardOutput(); qDebug()&lt;&lt;output; ui-&gt;paintText-&gt;appendPlainText(output); 看到这种直接使用waitForFinished的或者waitForStarted函数的方法的，请及时避雷。
有的方法会使用lambda去写connect连接信号和槽，同样不好用，不是标准的使用方法。
QProcess标准使用方法就是老老实实连接信号与槽 想真正非阻塞地使用QProcess，老老实实按照连接信号与槽的方法去使用。下面介绍标准使用流程：
首先在MainWindow类里创建QProcess； class MainWindow : public QMainWindow { public: ... private: QProcess* process;	//创建私有Qprocess变量，供MainWindow内部调用 } 并且记得在构造函数中new QPrcess； MainWindow::MainWindow { ... process = new QProcess(); ... } 在MainWindow中声明槽函数; class MainWindow : public QMainWindow { public: ... public slots: void processOuptutSlot(); private: ... } 实现槽函数(想要执行命令后有什么功能就在此实现)； void MainWindow::processOuptutSlot() { //输出终端信息 qDebug()&lt;&lt;process-&gt;readAllStandardOutput(); } 在构造函数中连接信号与槽 MainWindow::MainWindow { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b7d24b8b61ff940dce73e299cc38733/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cd502deba74580cfa329c314abac945/" rel="bookmark">
			windows server backup 无法使用或wbadmin.msc致命错误解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为黑群辉断电无法自动引导进系统，我也找不到很好的办法，所以决定使用windows server来做NAS服务器，虽然都解决了内网穿透的问题，但是数据安全还在找方案，目前已经解决：
1.购买了一张pcie raid卡，支持两个stat3.0盘位，某宝大约170元左右，用来做数据盘raid1，这样可以保障数据安全，毕竟硬raid肯定比软raid好。
2.使用windows server 自带的windows server backup来备份系统，系统我用的120G SSD，备份数据需要单独一块硬盘，我用的2T HDD（本来打算给笔记本用的，但是笔记本只能装3块硬盘）。
3.然后用windows server 自带的windows server backup创建备份系统任务重启后就遇见了wbadmin.msc致命错误，搞了半个月也没搞好，直到看到了一篇文章终于解决了，解决方法如下：
1.开始菜单 =&gt; cmd =&gt; 输入：wbadmin delete catalog =&gt; 输入y =&gt; 回车确认 （这样就清除了之前的备份数据，然后重新打开windows server backup就正常了）。
2.虽然正常了，但是下一次打开可能又会出现wbadmin.msc致命错误，然后我们需要改几个 服务 项。
Viryual Disk 这个右键鼠标=&gt;属性=&gt;启动类型 设置为自动。
Volume Shadow Copy 这个启动类型 也是设置为自动。
保存，重启计算机，以后就不会出现 “wbadmin.msc致命错误” 这个问题了。
具体设置如下：
那么问题解决了，为什么会出现这个问题呢？
在自Windows Server 2003以来的所有Windows版本中，本机备份实用程序（Windows Server Backup，NTBackup的后继）依赖卷快照服务(VSS)，也称为卷影副本或卷影复制。大多数第三方的Windows备份实用程序也依赖此服务，备份相关的问题通常是由VSS问题引起的。
说白了就是windows server backup需要依靠上面两个服务，但是服务器系统重启后没有任务运行，导致windows server backup找不到依赖项而崩溃了，我们手动清除缓存就恢复了，为了避免再次遇到这个问题把需要依赖的服务改为自动启动就好了，原来应该是手动启动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d89d057eb9dae6544ca74708f0975547/" rel="bookmark">
			基于Android的点餐系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：展示部分文档内容和系统截图，需要完整的视频、代码、文章和安装调试环境请私信up主。 4.1 系统总功能模块设计 点餐系统分三大部分，即管理员管理，菜谱管理和用户管理。系统按照商家和用户的实际需求开发而来，贴近生活。从管理员出拿到分配好的账号密码可以进入系统，使用相关的系统应用，管理员权限最大，紧接的是商家和用户。管理员总体负责整体系统的运行维护，统筹协调。
系统整体模块设计：系统分为管理员和用户两大用户角色，系统管理员有最大的权限，整体功能展示如图4-1所示。
4.2 系统数据库设计 4.2.1 数据库系统概要设计 从设计到制作研发一个系统，需要用到的技术很多，对于开发程序语言、数据库和框架布局都有严格的要求[5]。该系统数据存放使用MySQL的数据库，该数据库轻便快速，日常使使用系统十分稳定，更容易维护运行[6]。
4.2.2 E-R模型结构设计 E-R图由实体与有关实体关联相结合构成的图，利用E-R图对清楚地表达出系统内的实体之间的关联。在系统中对一些主要的几个关键实体如下图。
(1) 美食信息评论表实体属性图如下图4-2所示。
(2)留言板实体属性图如下图4-3所示。
(3) 美食资讯实体属性图如下图4-4所示。
4.3数据表设计 系统创建数据库和表之间关联，期间花费了不少时间，尽力把表格完善，更好的呈现出来，让表更加明了，更加清晰。系统在MySQL的可视化软件Navicat premium创建的数据表，简洁明了的设计让数据库的创建操作更加快捷，数据表的详细情况如下表所示。
表4-1：caipinfenlei
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
PRI
addtime
timestamp
创建时间
CURRENT_TIMESTAMP
leixing
varchar
200
类型
表4-2：caipinxinxi
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
PRI
addtime
timestamp
创建时间
CURRENT_TIMESTAMP
caipinmingcheng
varchar
200
美食名称
caipinleixing
varchar
200
美食类型
zhuyaoshicai
varchar
200
主要食材
shuliang
int
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d89d057eb9dae6544ca74708f0975547/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42708692af1c72bad60c497913b89983/" rel="bookmark">
			OceanBase基础架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OceanBase基础架构 简介基础架构OceanBase特点OceanBase与Oracle的差异其他：Oracle数据迁移至OceanBase常用迁移工具OMS迁移应用举例OB Cloud 连接OceanBase举例 简介 OceanBase是由蚂蚁集团、阿里巴巴完全自主研发的分布式关系型数据库。它始创于2010年，是完全自主研发的原生分布式数据库。
OceanBase采用了一种被称为"单机分布式一体化架构"的设计。这种架构兼顾了分布式架构的扩展性与集中式架构的性能优势。它使用一套引擎同时支持OLTP（联机事务处理）和OLAP（联机分析处理）的混合负载。此外，OceanBase还创新推出了“三地五中心”城市级容灾新标准。
OceanBase已经当前在金融、政务、运营商、零售、互联网等多个行业的400+客户中得到应用，实现了关键业务系统的升级。
基础架构 具体来说，OceanBase的架构包括以下几个主要部分：
①存储引擎：OceanBase使用基于LSM-Tree的高压缩引擎，平衡了“性能”和“压缩”的瓶颈，有效降低存储成本70% - 90%。
②计算引擎：OceanBase的计算引擎支持SQL和NoSQL查询，以及复杂的事务处理。
③分布式事务：OceanBase支持全局事务，保证数据的一致性和完整性。
④高可用和故障恢复：OceanBase通过数据复制和故障转移机制，提高了系统的可用性。它还支持快速故障恢复，确保服务的连续性。
OceanBase特点 OceanBase具有以下特点：
①数据强一致：确保所有数据副本始终保持一致。
②高可用：通过复制和故障转移机制，提高系统的可用性。
③高性能：通过分布式架构，实现高性能的数据处理和查询。
④在线扩展：可以在不中断服务的情况下，动态地添加或删除存储和计算资源。
⑤高度兼容SQL标准和主流关系型数据库：支持大部分SQL语法，以及Oracle和MySQL的语法。
⑥低成本：通过高效的资源利用，降低了存储和计算的成本。
OceanBase与Oracle的差异 OceanBase数据库与Oracle数据库在函数支持上存在一些差异。如下：
①内建函数：Oracle中支持117个内建函数，而OceanBase目前支持103个。
②SQL语法：OceanBase支持Oracle中的基本SQL语法。然而，OceanBase不支持Oracle的部分较复杂的OLAP语法，如模式匹配、PIVOT/UNPIVOT函数、多态表函数和频繁项目集计算。
③DDL语法：OceanBase不支持add constraint这种写法，需要写在括号内部。此外，OceanBase不支持novalidate和enable这两种DDL语法。
④其他功能：OceanBase不支持Oracle的存储过程、触发器、视图、多表关联、大表关联等常用数据库核心功能。
OceanBase数据库在某些方面提供了Oracle数据库不支持的功能：
①单机分布式一体化架构：OceanBase采用了一种被称为"单机分布式一体化架构"的设计。这种架构兼顾了分布式架构的扩展性与集中式架构的性能优势。它使用一套引擎同时支持OLTP（联机事务处理）和OLAP（联机分析处理）的混合负载。
②“三地五中心”城市级容灾新标准：OceanBase创新推出了“三地五中心”城市级容灾新标准。
③基于LSM-Tree的高压缩引擎：OceanBase使用基于LSM-Tree的高压缩引擎，平衡了“性能”和“压缩”的瓶颈，有效降低存储成本70% - 90%。
④原生多租户：OceanBase支持原生多租户，资源隔离按需使用。
以上为OceanBase相对于Oracle具有的一些独特功能。具体的差异可能会根据OceanBase和Oracle的版本有所不同。
其他：Oracle数据迁移至OceanBase Oracle数据库的数据可以通过以下步骤迁移到OceanBase：
创建迁移项目：在OceanBase迁移服务（OceanBase Migration Service，OMS）控制台创建从Oracle数据库迁移数据至OceanBase数据库Oracle租户的数据迁移任务。
设置迁移类型：根据业务需求，选择当前迁移任务的迁移类型。迁移类型包括结构迁移、全量迁移、增量迁移、全量校检和反向增量。
选择迁移对象：选择一个或多个库的表、视图作为迁移对象。
配置迁移选项：配置全量迁移是否允许目标表非空、增量记录保存时间、全量迁移并发参数、全量校验并发参数和字符编码与长度定义选项等参数。
预检查并启动数据迁移项目：在预检查环节，OMS会检查数据库用户的读写权限、数据库的网络连接等是否符合要求。全部检查项目均通过后才能启动数据迁移任务。
除此之外，还可以使用DataX或DBCAT工具进行数据和表结构的迁移24。这些工具可以实现包括MySQL、Oracle、SQLserver、Postgre、HDFS、Hive、ADS、HBase、TableStore (OTS)、MaxCompute (ODPS)、Hologres、DRDS 、OceanBase等各种异构数据源之间高效的数据同步功能。
常用迁移工具 OceanBase云平台（OB Cloud）：这是一个基于多云统一管理的云数据库OceanBase的服务，支持阿里云、腾讯云和AWS，开箱即用，可混合云部署。
OceanBase开发者中心（ODC）：这是一个为OceanBase数据库量身打造的企业级数据库开发平台。
OceanBase迁移服务（OMS）：这是一个OceanBase数据库一站式数据传输和同步的产品。
OceanBase迁移评估（OMA）：这是一个OceanBase提供的数据库迁移评估的产品。
OceanBase导数工具：这是一个基于OceanBase分布式系统的特性的客户端导入导出工具。
OMS迁移应用举例 通过OceanBase迁移服务（OMS）将Oracle数据库迁移到OceanBase步骤：
创建迁移项目：首先，你需要登录到OMS控制台，然后在控制台上选择“创建迁移项目”。在这个步骤中，你需要输入项目的名称，以及源数据库（Oracle）和目标数据库（OceanBase）的详细信息，包括数据库的IP地址、端口、用户名和密码。
设置迁移类型：在创建迁移项目后，你需要选择迁移类型。例如，如果你想要将Oracle数据库的所有数据迁移到OceanBase，那么你应该选择“全量迁移”。如果你只想要迁移最近更改的数据，那么你应该选择“增量迁移”。
选择迁移对象：在设置了迁移类型后，你需要选择要迁移的对象。这些对象可以是数据库中的表、视图等。你可以通过在OMS控制台上选择“添加迁移对象”来完成这个步骤。
配置迁移选项：在选择了迁移对象后，你需要配置一些迁移选项。这些选项包括全量迁移是否允许目标表非空、增量记录保存时间、全量迁移并发参数、全量校验并发参数和字符编码与长度定义选项等。
预检查并启动数据迁移项目：最后，你需要进行预检查并启动数据迁移项目。在预检查环节，OMS会检查数据库用户的读写权限、数据库的网络连接等是否符合要求。全部检查项目均通过后才能启动数据迁移任务。
OB Cloud 连接OceanBase举例 OceanBase云平台（OB Cloud）连接OceanBase数据库的示例步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42708692af1c72bad60c497913b89983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bd8238a6215e6ebb4004e4cbe10122f/" rel="bookmark">
			CVer从0入门NLP（一）———词向量与RNN模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍊作者简介：秃头小苏，致力于用最通俗的语言描述问题
🍊专栏推荐：深度学习网络原理与实战
🍊近期目标：写好专栏的每一篇文章
🍊支持小苏：点赞👍🏼、收藏⭐、留言📩
文章目录 CVer从0入门NLP（一）———词向量与RNN模型写在前面词向量RNN模型RNN模型结构手撸RNN 参考连接 CVer从0入门NLP（一）———词向量与RNN模型 写在前面 Hello，大家好，我是小苏👦🏽👦🏽👦🏽
之前的博客中，我都为大家介绍的是计算机视觉的知识，今天准备和大家唠唠NLP的内容。其实呢，对于NLP，我也是初学者，之前只是有一个大概的了解，所以本系列会以一个初学者的视角带大家走进NLP的世界，如果博客中有解释不到位的地方，希望各位大佬指正。🍭🍭🍭
当然了，NLP的内容很多，你如果在网上搜NLP学习路线的话你会看的眼花缭乱，本系列主要会介绍一些重要的知识点，一些历史久远的模型就不介绍了，我个人觉得用处不大，我们的目标是像经典模型看齐，如GPT系列，BERT家族等等。🍡🍡🍡
本系列目前准备先分三节介绍，后面会慢慢补充新内容。第一节先从词向量为切入点，然后介绍RNN模型并手撸一个RNN;第二节会介绍RNN的改进LSTM及ELMO模型；第三节会详细介绍GPT和BERT,以及它们的相同点和不同点。🍬🍬🍬
词向量 我们知道，NLP任务中我们处理的对象是一个个的词，但是计算机根本不认识我们的词啊，需要将其转换为适合计算机处理的数据类型。一种常见的做法是独热编码（one-hot编码），假设我们现在要对“秃”、“头”，“小”，“苏”四个字进行独热编码，其结果如下：
​ 可以看出，上图可以用一串数字表示出“秃”、“头”，“小”，“苏”这四个汉字，如用1 0 0 0表示“秃”，用0 1 0 0表示“头”…
​ 但是这种表示方法是否存在缺陷呢？大家都可以思考思考，我给出两点如下：
这种编码方式对于我这个案例来说貌似是还蛮不错的，但是大家有没有想过，对于一个文本翻译任务来说，往往里面有大量大量的汉字，假设有10000个，那么一个单独的字，如“秃”就需要一个1×10000维的矩阵来表示，而且矩阵中有9999个0，这无疑是对空间的一种浪费。这种编码方式无法表示两个相关单词的关系，如“秃”和“头”这两个单词明显是有某种内在的关系的，但是独热编码却无法表示这种关系【余弦相似度为0，后文对余弦相似度有介绍】。 基于以上的两点，我觉得我们的对词的编码应该符合以下几点要求：
我们可以将词表示为数字向量。我们尽可能的节省空间的消耗。我们可以轻松计算向量之间的相似程度。 我们先来看这样的一个例子，参考：The Illustrated Word2vec🎅🏽🎅🏽🎅🏽🍚🍚🍚
现在正值秋招大好时机，大家的工作都找的怎么样了腻，祝大家都能找到令自己满意的工作。在投简历的过程中，我们会发现很多公司都会有性格测试这一环节，这个测试会咨询你一系列的问题，然后从多个维度来对你的性格做全面分析。其中，测试测试者的内向或外向往往是测试中的一个维度，假设我（Jay）的内向/外向得分为38（满分100），则我们可以绘制下图：
为了更好的表示数据，我们将数据限制到-1~1范围内，如下：
这样我们就可以对Jay这个人是否外向做一个大致的评价，但是人是复杂的，仅仅从一个维度来分析一个人的性格肯定是不准确的，因此，我们再来添加一个维度来综合评价Jay这个人的性格特点：
可以看到，现在我们就可以从两个维度来描述Jay这个人了，在上图的坐标系中就是一个坐标为（-0.4，0.8）的点，或者说是从原点到（-0.4，0.8）的向量。当然了，如何还有别人有这样的两个维度，我就能通过比较他们的向量来表示他们的相似性。
从上图可以和明显的看出，Person1和Jay更像，但是这是我们直观的感受，我们可不可以通过数值来反应他们之间的相似度呢，当然可以，一种常见的计算相似度的方法是余弦相似度cosine_similarity，结果如下：
🌷🌷🌷🌷🌷🌷🌷🌷🌷🌷🌷🌷🌷🌷🌷🌷🌷🌷🌷🌷🌷🌷🌷
不知道大家知不知道计算余弦相似度，这里简单介绍一下：
余弦相似度是一种用于衡量两个向量之间相似性的度量方法，通常在自然语言处理和信息检索等领域广泛使用。它计算两个向量之间的夹角余弦值，值越接近1表示两个向量越相似，值越接近-1表示两个向量越不相似，值接近0表示两个向量之间没有明显的相似性。
余弦相似度的计算公式如下：
余弦相似度= A ⋅ B ∣ ∣ A ∣ ∣ ∣ ∣ B ∣ ∣ \frac{A \cdot B}{||A||||B||} ∣∣A∣∣∣∣B∣∣A⋅B​
其中：
A 和 B 是要比较的两个向量。 A ⋅ B A \cdot B A⋅B 表示向量** A A A**与向量 ** B B B**的点积（内积）。** ∣ ∣ A ∣ ∣ ||A|| ∣∣A∣∣**和 ∣ ∣ B ∣ ∣ ||B|| ∣∣B∣∣ 分别表示向量 ** A A A**与向量 ** B B B**的范数（模）。 可以来简单举个例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bd8238a6215e6ebb4004e4cbe10122f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42cbce3dc15cbb0e7ad5323880b2599d/" rel="bookmark">
			STM32实战项目—密码锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎀 文章作者：二土电子
🌸 关注文末公众号获取其他资料和工程文件！
🐸 期待大家一起学习交流！
文章目录 一、任务要求二、实现方法2.1 输入密码判断2.2 管理员模式2.3 修改密码 三、程序设计3.1 输入密码判断3.2 进入管理员模式3.3 修改密码 四、问题总结4.1 输入内容一直提示Error4.2 密码判断一直错误 五、成果展示5.1 输入密码判断5.2 进入管理员模式5.3 修改密码 一、任务要求 设计一款密码锁，通过串口输入输出信息。需要实现以下功能
开机提示“欢迎使用智能密码锁系统”，换行回车后显示“请输入密码”输入六位任意字符密码，不能是汉字。如果密码正确，返回“密码正确，已开门”。如果密码错误，返回“密码错误，您还有*次输入机会”如果连续三次输入密码错误，提示“三次密码错误，警报！”。此时，LED闪烁报警如果输入“Enter(空格)Admin(空格)Mode”，返回“已进入管理员模式”，换行之后显示“请输入管理员密码”。输入密码正确后，提示“管理员密码正确”，进入管理员模式。管理员密码默认为“147258”。如果管理员密码输入错误，提示“管理员密码错误”进入管理员模式后，提示“请输入新密码”。输入完成一次后提示“请再次输入新密码”。连续两次输入正确后，提示“密码修改成功”，自动退出管理员模式。如果两次密码不一致，会提示“连续两次输入密码不同，请重新输入”。如果新密码与原密码相同，会提示“新密码请勿与原密码相同”如果输入内容错误，会提示“Error!”，回车加换行 二、实现方法 2.1 输入密码判断 首先有一个默认密码“123456”。将密码存储到一个数组中。接收到输入密码后，利用for循环，挨个比较串口接收数组中接收输入的密码是否与密码数组中密码相同。相同的话，提示“密码正确，已开门”。如果错误，累计错误次数，提示“密码错误，您还有*次输入机会”。如果三次输入任意一次正确，会将之前累计的错误次数清零。如果三次输入均错误，提示“三次密码错误，警报！”。此时，LED闪烁报警。
2.2 管理员模式 如果串口接收中断中接收到内容后，利用for循环，挨个对比指令是否为进入管理员模式指令。如果是进入管理员模式指令，返回“已进入管理员模式”，换行回车后显示“请输入管理员密码”。密码的判断方法与最开始的输入密码相同。
2.3 修改密码 进入管理员模式且正确输入密码后，可以修改密码。修改密码时，第一次输入后会首先拿新密码与原密码比较。如果新密码与原密码相同，返回“新密码请勿与原密码相同”。如果第二次输入密码后，判断与第一次的密码手抖相同。如果两次输入的密码相同，提示“密码修改成功”。然后自动退出管理员模式。
三、程序设计 3.1 输入密码判断 如果接收到的内容长度为六位，而且此时不是管理员模式。会对输入的密码进行判别。正确返回正确信息，错误提示错误信息。连续三系错误，提示报警。同时，LED闪烁。三次中任意一次输入正确，清零错误累计次数。程序设计如下
// 输入密码判断 void PassWord_Judge (void) { u8 tempVar = 0; // 临时循环变量 u8 judgeRes = 0; // 判别结果 // 非管理员模式下输入密码 if (gAdminFlag == 0 &amp;&amp; gPassWordFlag == 1 &amp;&amp; gPassWordChargeFlag == 0) { // for循环判断密码是否正确 for (tempVar = 0;tempVar &lt; 6;tempVar ++) { // 任意一位密码错误，就说明密码错误 if (gReceFifo[tempVar] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42cbce3dc15cbb0e7ad5323880b2599d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/044e95c840bb402ee560a3a0471d35c5/" rel="bookmark">
			SolidWorks模型导入到Gazebo中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先建立好solidworks模型，然后另存为stl格式，
导出为STL文件时，文件名最好不要是中文，并且要将后缀STL改为stl，否则Gazebo无法识别
这是我创建好的机器人充电桩模型：
尺寸是单位是mm：
135mm 110mm 245mm 120° 高400mm
这样建立好之后，导入到gazebo中，(Edit-&gt;Model Editor，Custom Shapes中添加自己的模型)发现相比其他模型大了很多，如下图：
左下角是作者自己建立的世界模型，这个充电桩也太大了吧，
看下面这篇博客：
引用
以mm建立的单位，要再缩小mm的1000倍，因为gazebo中是以m为单位的，那么stl模型的135mm导入到gazebo就变成135m了，所以很大，既上面的尺寸要变成：0.135mm 0.11mm 0.245mm 高0.4mm。当吧尺寸缩小好之后，再导入到gazebo中就正常了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae6d17190d585d153fca45a60b9c3939/" rel="bookmark">
			快速拿下 AI Prompt 工程师证书攻略！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Datawhale干货 贡献者：许文豪、司玉鑫、甘元琦
Prompt 是 AI 2.0 时代打开大模型能力的金钥匙，它能够大大的提高工作效率。
如果把大语言模型 (LLM，Large Language Model) 具象成一个的员工，那 Prompt 提示词则好比是你给员工下的指令，你给出的指令越详细，员工执行的结果就越好。
未来 Prompt 会成为必备技能，每个人都可以有自己的 AI 助手，释放自己的生产力。
最近有不少同学对 Prompt 和拿到证书感兴趣，下面主要分享拿到证书的攻略。
1
证书及攻略
快速攻略如下，预计需要30分钟：
当你完成动手实践并通过最终的考试之后，你将会获得由讯飞星火和 Datawhale 共同颁发的电子证书（如下）
2
你能获得
高效工具：拥有一款属于你自己的 AI 助手应用
体验学习：体验 AI 大模型丰富多样高效的创造力
实战应用：掌握 AI Prompt 提示词的基础能力
行业证书：Datawhale x 讯飞星火联合发布的 Prompt Engineer 证书
3
如何认证
能力测试满分 100 分，成功获得 80 分及以上，即可获得证书，预祝你取得好成绩。
📒 第一步：学习指南及攻略（建议用电脑）
https://datawhaler.feishu.cn/docx/ITDod4LCjo5yoixJHkdcUDw6nrc
📃 第二步：扫码参与能力测试，获得证书
推荐计算机、人工智能、智能科学与技术、软件工程、大数据、网络工程、自动化、通信、数字媒体技术、电子信息工程、数据科学、统计、数学、信管、管科、金融科技、电子商务、新文科等相关专业。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb1c48d6b99381f5b80e7c16c88fcfe9/" rel="bookmark">
			free -h详解与内存swap理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、free -h解析 [root@harbor-host ~]# free -h total used free shared buff/cache available Mem: 7.6G 3.8G 447M 368M 2.0G 1.7G Swap: 8.0G 1.2G 6.8G total：#服务器内存总大小：7.6G used：#已经使用了多少内存：3.8G，已用内存总量(used = total-free-buffers-cache,这里没减去shared，我理解是shared是used的其中一部分) free：#未被任何应用使用的真实空闲内存,也叫未被分配出去的内存，(真正尚未被使用的物理内存数) shared：#表示多个进程共享的内存总额。 buff/cache： #表示buffers和cache所用总量的总和(buffers为内核缓冲区所用的内存，cache为页缓存和slabs所用的内存容量)，也有人说是表示磁盘缓存的大小。 page cache，即缓存文件内容+slab。slab也分可回收和不可回收部分，可手动回收，但是会在回收缓存这段时间影响主机性能，并且不是有所的slab和page cache都能被回收，正在使用的这些缓存不能被回收，否则系统的性能会很低，
所以最后可能的内存是多少，就得评估能够回收的有多少，就有了下面这个参数available
buffers是用来缓冲文件属性和目录内容的（其实就是inode信息）
cached是用来缓冲文件内容的（其实就是data block数据）
为了提高磁盘存取效率，Linux做了一些精心的设计，除了对dentry进行缓存（用于VFS，加速文件路径名到inode的转换），还采取了两种主要Cache方式：Buffer Cache和Page Cache。
前者针对磁盘块的读写，后者针对文件inode的读写。
这些Cache有效缩短了 I/O系统调用（比如read，write，getdents）的时间。
available：真正剩余的可被程序应用的内存数；是系统的一个估计值，不是谁减比较准确 注意：看一个内存可用多少，看available参数，但是你要理解available的意义，不是简单数字相减；有时候 也看free表示没有未被分配出去的内存。
free -h -s 2 -c 3 #2秒执行下free -h命令，执行3次。
二、swap虚拟内存 2.1 总结 ​ 当Linux的物理内存快要被耗尽时，系统会把一些进程占用的内存转移到 swap 区，当物理内存被释放一部分时，swap 区的一些内存占用又慢慢回到 mem 区，但是 mem 区却不再是之前的满负荷状态，而是有一部分 free 的内存！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb1c48d6b99381f5b80e7c16c88fcfe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4286644b7c815ae98371d58bbdc77006/" rel="bookmark">
			腾讯云标准型S5服务器4核8G配置S5.LARGE8性能评测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云服务器CVM标准型S5实例4核8G配置，公网带宽可选1M、3M或5M，系统盘为50G高性能云硬盘，地域节点可选广州、上海和北京，4核8G服务器网关于腾讯云4核8G服务器配置、性能评测及限制条件：
目录
腾讯云4核8G服务器
标准型S5云服务器CPU处理器
4核8G服务器配置表
4核8G服务器性能评测
腾讯云4核8G服务器 腾讯云标准型S5云服务器是次新一代的云服务器规格， 标准型S5云服务器配有全新的Intel Advanced Vector Extension (AVX-512) 指令集，最高可支持29Gbps内网带宽，具有超高网络收发包能力。
标准型S5云服务器CPU处理器 CPU采用Intel® Xeon® Cascade Lake或者Intel® Xeon® Cooper Lake 处理器，主频2.5GHz，睿频3.1GHz。
4核8G服务器配置表 本文4核8G服务器网主要介绍这款4核8G配置的S5云服务器，详细配置如下表：
云服务器CVM规格CPU内存公网带宽地域节点系统盘标准型S5实例（S5.LARGE8）4核8G1M/3M/5M广州/上海/北京50G高性能云硬盘 这款五年的云服务器是腾讯云新用户的，如果是老用户需要点办法（参考：腾讯云账号注册），需要注意的是新用户不是新账号，重新注册新账号后要使用新身份实名认证。
4核8G服务器性能评测 这款特价五年云服务器为标准型S5实例，CPU采用Intel® Xeon® Cascade Lake或者Intel® Xeon® Cooper Lake 处理器，主频2.5GHz，睿频3.1GHz，4核8G配置的性能参数表如下：
规格vCPU内存（GB）网络收发包（pps）（出+入）连接数队列数内网带宽能力（Gbps）（出+入）主频S5.LARGE84850万25万21.52.5GHz 腾讯云服务器之前可以一次性三年，现在三年的取消了，一般都是一年时长，现在腾讯云推出了五年：https://curl.qcloud.com/HmjGZiLu 标准型S5云服务器配有全新的Intel Advanced Vector Extension (AVX-512) 指令集，最高可支持29Gbps内网带宽，具有超高网络收发包能力，适合各种类型和规模的企业级应用、中小型数据库系统、缓存、搜索集群、计算集群、依赖内存的数据处理、高网络包收发场景，如视频弹幕、直播、游戏等应用场景。
原文：http://4h8g.com/tengxunyun/s5large8/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5b7f70af754cb0fe2039a7b9e3aaf9d/" rel="bookmark">
			Markdown 入门及语法详细指南 ★
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Markdown 简介Markdown 编辑工具1. 平台集成2. 独立软件3. 插件拓展 Markdown 基本语法快捷键1. 标题2. 文本3. 列表4. 引用5. 代码6. 链接与图像7. 表格8. 分隔线9.1 数学公式（扩展语法）9.2 图表（扩展语法）转义字符语法技巧 Markdown 功能拓展与语法支持CSDN 语法支持1. 标题索引（目录）2. 图像3. 注释4. Flowchart 流程图 GitHub 语法支持1. emoji表情2. @提及人员和团队 结语 Markdown 简介 Markdown 是一种轻量级标记语言，于 2004 年由约翰·格鲁伯（John Gruber）创建。Markdown 的目标是实现「易读易写」。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。
Markdown 使用少量简单的语法 对文本进行样式化 。大多数情况下，Markdown 只是普通的文本，加上一些非字母字符，比如 # 、* 、- 等。Markdown 语法的种类很少，只对应 HTML 标记的一小部分。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 书写。
Markdown不止是HTML的简化版，更重要的是txt的升级版、Word的轻量版，是笔记的最佳载体。作为一种简单的格式标记语言，不同于HTML的复杂标记，不同于txt的无格式、也不同于Word的复杂样式调整。Markdown 通过简单的几个字符键入，就可以快捷的定义文档的样式。掌握 Markdown，你可以享受到简洁之美、享受效率的提升。
使用 Markdown 的优点
内容与格式分离，专注你的文字内容而不是排版样式，安心写作。轻松导出 HTML、PDF 等多种格式的文件和本身的 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5b7f70af754cb0fe2039a7b9e3aaf9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5c48f27a151b54213f9ce174f7062f4/" rel="bookmark">
			系统03：15min导图复习 文件管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐳前言 图源：文心一格
考研笔记整理，纯复习向，思维导图基本就是全部内容了，不会涉及较深的知识点~~🥝🥝
第1版：查资料、画思维导图~🧩🧩 编辑： 梅头脑🌸
参考用书：王道考研《2024年 操作系统考研复习指导》
参考视频：4.1_1_初识文件管理_哔哩哔哩_bilibili
🦮思维导图 🌸思维导图为整理王道教材操作系统第4章文件管理，如果看不清的话，可以试试存到本地然后放大~🌸博文后面会以大纲的形式复述一遍，面向复习，不会写得很详细，且可能有误；如果想仔细了解知识点，或许可以考虑以下两种方式~ 王道咸鱼老师的视频：4.1_1_初识文件管理_哔哩哔哩_bilibili较为重要的内容有从网络找相关配图并给出原文链接，点击配图的链接可以传送到各位大佬博文，也很适合快速复习~ 📇目录 🐳前言
🦮思维导图 📇目录
🐳文件管理
🐋文件系统基础
🐋文件逻辑结构
🐋文件物理结构
🐋文件存储空间管理【空闲块】
🐋目录
🐋文件系统
🐋计算
🐚混合索引分配
🐚读页访盘次数
🐚减少访盘次数
🔚结语
🐳文件管理 🐋文件系统基础 基本概念
概念：文件是以硬件为载体的存储在计算机上的信息集合 计算机在实现资源的分配和调度时，以进程为基本单位计算机在用户进行的输入、输出中，以文件为基本单位组成 数据项：文件系统中最低级的数据组织形式记录：一组相关的数据项的集合，用于描述一个对象在某方面的属性文件：创建者所定义的、具有文件名的一组相关元素的集合 文件控制块【FCB】
信息 基本信息：如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构存取控制信息：如文件主的存取权限、核准用户的存取权限以及一般用户的存取权限使用信息：如文件的创建时间、上次修改时间等目录文件 目录项：创建文件时，系统将分配一个文件控制块【FCB】并存放在文件目录中，成为目录项目录文件存放的信息：子目录文件、数据文件的目录项 图源：操作系统&amp;文件管理之FCB_文件fcb-CSDN博客
文件索引节点【inode】
描述：有的系统【如UNIX】采用了文件名和文件描述信息分开的方法，使文件描述信息单独形成一个成为索引节点的结构目录：在文件目录中的每个目录仅由文件名和指向该文件所对应的i节点的指针构成磁盘索引节点：存放在磁盘上的索引结点，每个文件有一个唯一的磁盘索引结点内存索引节点：存放在内存中的索引结点，当文件被打开时，将相应的索引节点从磁盘复制到内存中 图源：文件系统 | 文件的物理结构 - 知乎
文件的操作 | 用户接口
文件的基本操作：创建文件、写文件、读文件、重新定位文件、删除文件、截断文件文件的打开与关闭 打开 单个文件打开：调用open根据文件名搜索目录，将指明文件的属性从外存复制到内存打开文件表的一个表目中，并将该表目的编号返回给用户多个文件打开：通常采用两级表，整个系统表【包含FCB的副本和其他信息】和每个进程表【打开的所有文件，包含指向系统表中适当条目的指针】关闭 系统打开表为每个文件关联一个打开计数器【open count】，每次关闭使count递减，计数器为0时，可从系统打开文件表删除相应条目打开文件关联信息：文件指针、文件打开计数、文件磁盘位置、访问权限 文件的保护
口令保护【防止文件被窃取】：用户在建立一个文件时提供一个口令，系统建立FCB时附上相应口令加密保护【防止文件被窃取】：用户对文件进行加密，文件被访问时需要使用秘钥访问控制【对文件的访问方式】：使用精简访问控制列表【拥有者、组、其它】，根据用户类型进行控制，灵活性很高，必须由系统实现 🐋文件逻辑结构 概念：从用户观点出发看到的文件的组织形式，与存储介质特性无关
结构 无结构文件【流式文件】 概念：一系列二进制或字符流组成访问：穷举搜索适用：基本信息单位操作不多的文件【例，txt、源程序文件】 有结构文件【记录式文件】 概念：文件由若干个相似的记录组成【例，数据库】记录组织形式 顺序文件 概念：记录一个接一个地顺序排列，可以顺序存储或以链表形式存储适用：读或写大批记录的效率较高、对于顺序存储设备【如磁带】只有顺序文件才能被存储索引文件 定长记录文件：可按 “记录地址=首地址+记录长度x条数”非定长记录文件：必须顺序查找前i-1条记录特点：提高了存取速度，但配置索引表增加了存储空间索引顺序文件 概念：为顺序文件建立一张索引表，查找记录时，通过索引表找到所在的组，然后在组内顺序查找特点：提高了存取速度，但配置索引表增加了存储空间查找次数 最理想状态：N条记录的顺序文件，记录分为﻿组，每组﻿ 条记录查找次数：近似﻿，或严格﻿散列文件 概念：通过散列函数转换的键值直接决定记录的物理地址特点：有很高的存取速度，但是会引起冲突，即不同关键字的散列函数值相同 图源：文件的逻辑结构_蜗牛_Chenpangzi的博客-CSDN博客
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5c48f27a151b54213f9ce174f7062f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/191b04a5442866a7daa666413de3c59d/" rel="bookmark">
			5G学习笔记之5G频谱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：《5G NR通信标准》 1. 5G频谱 1G和2G移动业务的频段主要在800MHz~900MHz，存在少数在更高或者更低频段；3G和4G的频段主要在450MHz ~ 6GHz；5G主要是410MHz ~ 6GHz，以及24GHz ~ 52GHz。
5G频谱跨度较大，可以分为低频、中频和高频：
低频：2GHz以下的频段，由于传输损耗低，适用于覆盖，即提高广域和深度的覆盖，包括室内覆盖（室内似乎更倾向于中频或高频）。最感兴趣的是600MHz和700MHz，对应的5G频段是n71和n28。中频：2GHz~6GHz的频段，通过更宽的信道带宽提供覆盖、容量和高速率。最感兴趣的是3300MHz~4200MHz，中国主要对3300MHz~3600MHz 感兴趣，还有些频段如4800MHz~5000MHz也感兴趣。中频频段的信道带宽可达100MHz，通过载波聚合可以达到更大的带宽。高频：24GHz以上的频段，即毫米波频段，适用于超高容量的本地热点覆盖。最感兴趣的是24.25GHz~29.5GHz，对应的5G频段是n257和n258。中频频段的信道带宽可达400MHz，通过载波聚合可以达到更大的带宽。 2. 5G频段 3GPP定义了工作频段，一个工作频段是由一组RF要求所规定的上行链路或下行链路（FDD），或者上下行链路（TDD）的一个频率范围。
每个工作频段都有一个编号。当相同的频率范围被定义为不同的无线接入技术的工作频段时，采用相同的编号，但以不同的书写方式，3G采用罗马数字I、II、III等，4G采用阿拉伯数字1、2、3等，5G则在阿拉伯数字前加n，如n1,n2,n3等。
5G频段介绍优秀文章：5G RF Bandwidth
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd6ad257c735b0812c5b1958787088b/" rel="bookmark">
			使用 wireshark 抓包，https，http2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先下载安装 https://www.wireshark.org/download.html
wireshark 的工作过程为：
1、设置要捕获哪个网卡上的流量 捕获 --&gt; 选项
首先你得知道当前机器的IP，然后就很容易找到是哪个网卡了。
2、设置要捕获哪些内容 捕获 --&gt; 捕获过滤器
这里我要捕获一个http请求，它是HTTP的80端口。
设置好这两步它就会开始捕获数据了。
3、设置显示过滤器 设置好捕获过滤器之后，捕获的内容可能依然很多，这个时候就需要设置一下要显示哪些内容了，也就是显示过滤器。
输入的内容http and ip.dst == xxxx要遵循一定的语法。
使用 and 和 or 来连接。
比较操作符有：等于== 、不等于!= 、大于&gt; 、小于&lt; 、大于等于&gt;= 、小于等于&lt;=
常用的有
表达式含义http只查看http请求ip.dst == 192.168.2.157请求的目标ip地址tcp.dstport == 80目标端口http.request.method == GEThttp请求方式http.request.uri == "/read5/heartbeat"请求uri 其次可以点击输入框左边的小图标保存下来。
4、追踪流 比如，我要查看上面某个http请求的具体内容，将其选中，追踪流，http流
就可以查到到请求信息和响应信息的全部内容。
5、修改显示的时间格式 上面的列表中第二列为请求发出的时间。
视图 --&gt; 时间显示格式 --&gt; 日期和时间
6、捕获https的请求 首先设置捕获过滤器为tcp，然后输入显示过滤器ip.dst==47.104.146.209 and tcp.dstport==443。发现列出的信息是加密的，这个时候是需要对https的运行过程有一定的了解，在客户端和服务端建立连接的过程中已经约定好了此次通讯的数据加密解密算法的AES密钥，因此只要找到了AES密钥就能解密请求和响应的内容。
当系统环境变量中存在SSLKEYLOGFILE这个变量的时候，chrome与firefox在访问https网站的时候会将密钥保存到这个环境变量对应的文件中，如果在wireshark中设置一下，这样就可以解析https的流量了。
编辑 --&gt; 首选项 --&gt; Protocals --&gt; TLS
比如我设置 SSLKEYLOGFILE=D:\sslkeylog\sslkey.log，这个文件要手动创建。
重启浏览器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acd6ad257c735b0812c5b1958787088b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3fe5f6fe990719e02c5438b8dd5f9f5/" rel="bookmark">
			Base 编码家族：Base16 编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 参考环境Base 编码Base 的含义计数系统编码系统 为什么需要 Base 编码？ASCII 编码 Base16 编码概念Base16 字符集 Base16 编码原理编码 Base16 编码特点体积膨胀 参考 项目描述搜索引擎Bing、GoogleAI 大模型文心一言、通义千问、讯飞星火认知大模型、ChatGPTTuts+Base What? A Practical Introduction to Base EncodingRFC 文档RFC4648 环境 项目描述绘图工具draw.io 21.7.5 Base 编码 Base 的含义 计数系统 Base 这个词在数学中通常用来描述计数系统的 基数，基数即计数系统中用于表示数字的不同符号的数量。
举个栗子
二进制计数系统
二进制计数系统中仅使用两个符号表示数字，即 0 和 1，故二进制计数系统可以使用 Base2 来进行表示。十进制计数系统
十进制计数系统中仅使用十个符号表示数字，即 0 ~ 9，故十进制计数系统可以使用 Base10 来进行表示。十六进制计数系统
十六进制系统中仅使用十六个符号表示数字，即 0 ~ 9 及 a ~ f，故十六进制计数系统可以使用 Base16 来进行表示。 编码系统 Base 在 计算机编码系统 中则用于表示该编码系统所使用的字符集的大小。Base 描述了该系统的基数，而后面的数字表示这个 基数的具体值。这样的命名方法 直观地 告诉我们这个编码系统使用了多少种不同的字符来表示数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3fe5f6fe990719e02c5438b8dd5f9f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/253c81932cf31db65da55992c76a5822/" rel="bookmark">
			基于51单片机的全自动洗衣机控制系统仿真设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案设计： 链接：https://pan.baidu.com/s/1zsOzn1755WKyzLNOec4nzA
提取码：nbpb
采用单片机设计，以 AT89C51 单片机为核心元件， 由时钟电路、 复位电路、 电源电 CPU 控制模块 电机调速控制模块 显示模块 电源模块 复位模块 时钟模块 控制模块 秒脉冲发生器 60 进制计数器 洗涤时间计数器 控 制 门 功 放 继 电 开 关 执 行 电 机 时间译码 清零 置数、 显示电路、 按键电路和执行电机部分组成。 电机电路部分是利用l298驱动芯片输入不同的信号使电机产生正转和反转。 显示电路采用八个 LED 和八个电阻与单片机相连 ， 利用 C 语言编程实现洗衣机自动化显示功能。 此方案设计的洗衣机、有进排水系统故障自动诊断、 暂停等功能。
控制电路设计 单片机设计中， 重要的一个模块是按键的设计。 常见的单片机按键设计分为独立式和行列式（矩阵式）。 独立式按键设计简单， 但占用 I/O 口较多； 行列式按键设计相对复杂， 占用 I/O 口较少。 如图 3-5 所示。
蜂鸣器报警电路设计
本设计中，当某个洗衣方案完全结束，会有蜂鸣器 5S 钟的报警时间。 蜂鸣器电路设计如图 3-3所示。 由单片机直接输出的信号不足以驱动蜂鸣器的工作。因此，在单片机与蜂鸣器之间加一个 PNP 三极管作为驱动。三极管的基极通过一个 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/253c81932cf31db65da55992c76a5822/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/182e11d521fd71241cb6231055454a25/" rel="bookmark">
			基于51单片机的音乐盒彩灯频谱喷泉原理图方案设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件电路的设计 链接：https://pan.baidu.com/s/13arSh1kts_gI5UFWT6gPKA 提取码：wm7e
3.1系统的功能分析及体系结构设计
3.1.1系统功能分析
本设计由STC89C52单片机电路+水泵控制电路+ADC0832采样电路+LM386功率放大器电路+LED灯显示电路+电源电路组成。
1、本设计可以播放电脑、手机、MP3里面的音乐。
2、通过ADC0832芯片对音频信号的采集，转换为数字信号给单片机，然后PWM脉冲宽度调制控制水泵水柱对的高低。
3、同事有流水灯表示音乐大小情况。
3.1.2系统总体结构
本系统具体框图如下图所示：
水泵控制电路设计
微型水泵（wēi xīn shuǐ bèng，microwater pump或mini water pump）定义：通常把提升液体、输送液体或使液体增加压力，即把原动机的机械能变为液体能量从而达到抽送液体目的的机器统称为水泵。水泵一般组成形式为驱动部分+泵体，泵体上有一进一出两个接口，水从入水口进，排水口出，凡是采用这种形式，且体积小巧、袖珍的水泵，都叫微型水泵，也叫微型抽水泵。
在本系统中，使用5V水泵，用来喷水，由于水泵属于大功率装置，单片机无法直接驱动，故选择三极管9012来实现对水泵的控制，在本电路中通过LED灯来指示水泵是否工作，如果水泵工作，则LED灯亮，否则，LED灯不亮。与LED灯串联的电阻为限流电阻，限流作用，以保护LED灯，防止烧坏。当单片机的相关控制引脚为低电平时，三极管导通，水泵正常工作；否则，水泵不工作。电解电容作用是滤波，来滤除水泵供电电源中的低频参量，让水泵更稳定的工作。
LM386功率放大器电路设计
本设计扬声器放大电路选择LM386芯片进行放大，放大声音可调。
LM386是美国国家半导体公司生产的音频功率放大器,是一种音频集成功放，具有自身功耗低、更新内链增益可调整、电源电压范围大、外接元件少和总谐波失真小等优点的功率放大器，广泛应用于录音机和收音机之中。为使外围元件最少,电压增益内置为20。但在1脚和8脚之间增加一只外接电阻和电容,便可将电压增益调为任意值,直至 200。输入端以地位参考,同时输出端被自动偏置到电源电压的一半,在6V电源电压下,它的静态功耗仅为24mW,使得LM386特别适用于电池供电的场合。
耦合电容。此电容的作用有二：隔直+耦合。隔断直流电压，直流电压过大有可能会损坏喇叭线圈；耦合音频的交流信号。它与扬声器负载构成了一阶高通滤波器。减小该电容值，可使噪声能量冲击的幅度变小、宽度变窄；太低还会使截止频率（fc=1/(2πRLCout)）提高。功率放大器的电路原理图如下图所示。电位器可以调节声音大小，电容均为滤波电容。电阻均为限流电阻。
ADC0832A/D转换电路设计
ADC0832是美国国家半导体公司生产的一种 8 位分辨率、双通道 A/D 转换芯片。由于它体积小，兼容性强，性价比高而深受单片机爱好者及企业欢迎，
其目前已经有很高的普及率。学习并使用 ADC0832 可是使我们了解 A/D 转换器的原理，有助于我们单片机技术水平的提高。
一、ADC0832 具有以下特点：
（1）8 位分辨率；
（2）双通道 A/D 转换；
（3）输入输出电平与 TTL/CMOS 相兼容；
（4）5V 电源供电时输入电压在 0~5V 之间；
（5）工作频率为 250KHZ，转换时间为 32μS；
（6）一般功耗仅为 15mW；
（7）8P、14P—DIP（双列直插）、PICC 多种封装；
（8）商用级芯片温宽为0°C to +70°C，工业级芯片温宽为−40°C to +85°C；
ADC0832 为 8 位分辨率 A/D 转换芯片，其最高分辨可达 256 级，可以适应一般的模拟量转换要求。其内部电源输入与参考电压的复用，使得芯片的模拟电压输入在 0~5V 之间。芯片转换时间仅为 32μS，据有双数据输出可作为数据校验，以减少数据误差，转换速度快且稳定性能强。独立的芯片使能输入，使多器件挂接和处理器控制变的更加方便。通过 DI 数据输入端，可以轻易的实现通道功能的选择。再本设计中ADC0832的功能是将粉尘传感器输出的模拟信号转化为数字信号，然后将信号送入单片机进行处理，试验证明，本电路满足本设计要求。在本设计中，ADC0832选择模拟输入通道0即CH0作为信号的采集端口。其具体电路如下图所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/182e11d521fd71241cb6231055454a25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04060ce5bf329f4e6557aae0224ff3c0/" rel="bookmark">
			YOLOv8/YOLOv7/YOLOv5注意力机制全家福，内涵多尺度空洞注意力、大型分离卷积、多尺度双视觉、可变形大核注意力、通道优先卷积注意力、多维协作注意、可变形自注意力、EMA等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💡💡💡本文属于原创独家改进：2023年全新注意力大派送，内涵多尺度空洞注意力、大型分离卷积、多尺度双视觉、可变形大核注意力、通道优先卷积注意力、多维协作注意、可变形自注意力、EMA，喜迎1024，创新度十足适合科研
💡💡💡在各个数据集能够涨点，强烈推荐，推荐指数五颗星
目录
1.多尺度空洞注意力（MSDA） | 中科院一区顶刊 DilateFormer 2023.9
2.大型分离卷积注意力模块（ Large Separable Kernel Attention），实现暴力涨点同时显著减少计算复杂性和内存 | 2023.8月最新发表
3.Dual-ViT：一种多尺度双视觉Transformer ，Dualattention助力检测| 顶刊TPAMI 2023
4.可变形大核注意力，超越自注意力，实现暴力涨点 | 2023.8月最新发表
5.通道优先卷积注意力，效果秒杀CBAM和SE等 |中科院2023.6月发布
6.多维协作注意模块MCA，暴力涨点，效果秒杀ECA、SRM、CBAM等
7.可变形自注意力Attention，暴力涨点 | 即插即用系列2023年最新发表
8.ICASSP2023 EMA基于跨空间学习的高效多尺度注意力、效果优于ECA、CBAM、CA
1.多尺度空洞注意力（MSDA） | 中科院一区顶刊 DilateFormer 2023.9 本文全网首发独家改进：多尺度空洞注意力（MSDA）采用多头的设计，在不同的头部使用不同的空洞率执行滑动窗口膨胀注意力（SWDA），全网独家首发，创新力度十足，适合科研
1）与C2f结合；2）作为注意力MSDA使用；
多尺度空洞注意力（MSDA） | 亲测在红外弱小目标检测涨点，map@0.5 从0.755提升至0.784
为了克服这些问题，作者提出了一种新的注意力机制——多尺度空洞注意力（MSDA）。MSDA 能够模拟小范围内的局部和稀疏的图像块交互，这些发现源自于对 ViTs 在浅层次上全局注意力中图像块交互的分析。作者发现在浅层次上，注意力矩阵具有局部性和稀疏性两个关键属性，这表明在浅层次的语义建模中，远离查询块的块大部分无关，因此全局注意力模块中存在大量的冗余。
DilateFormer 是一个以金字塔结构为基础的深度学习模型，它主要设计用来处理基础的视觉任务。DilateFormer 的关键设计概念是利用多尺度空洞注意力（Multi-Scale Dilated Attention, MSDA）来有效捕捉多尺度的语义信息，并减少自注意力机制的冗余。
如下图所示，MSDA 模块同样采用多头的设计，将特征图的通道分为 n 个不同的头部，并在不同的头部使用不同的空洞率执行滑动窗口膨胀注意力（SWDA）。这样可以在被关注的感受野内的各个尺度上聚合语义信息，并有效地减少自注意力机制的冗余，无需复杂的操作和额外的计算成本。
总体来说，DilateFormer 通过这种混合使用多尺度空洞注意力和多头自注意力的方式，成功地处理了长距离依赖问题，同时保持了计算效率，并能够适应不同尺度和分辨率的输入。
YOLOv8改进：全网原创首发 | 多尺度空洞注意力（MSDA） | 中科院一区顶刊 DilateFormer 2023.9-CSDN博客
2.大型分离卷积注意力模块（ Large Separable Kernel Attention），实现暴力涨点同时显著减少计算复杂性和内存 | 2023.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04060ce5bf329f4e6557aae0224ff3c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d1541c76c31deadd04e6eea1db5b4b/" rel="bookmark">
			《王道计算机考研——操作系统》学习笔记总目录&#43;思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章是对《王道计算机考研——操作系统》所有知识点的笔记总结归档和计算机网络的思维导图
学习视频：王道计算机考研 操作系统
408四件套【计网、计组、操作系统、数据结构】完整课堂PPT + 思维导图 （求Star~）：【王道考研】计算机四件套完整资料
各章节链接 第1章（操作系统概述） 王道计算机考研 操作系统学习笔记 + 完整思维导图篇章一：操作系统概念
第2章（进程管理） 王道计算机考研 操作系统学习笔记 + 完整思维导图篇章二: 进程管理
第3章（内存管理） 王道计算机考研 操作系统学习笔记 + 完整思维导图篇章三: 内存管理
第4章（文件管理） 王道计算机考研 操作系统学习笔记 + 完整思维导图篇章四: 文件管理
第5章（IO管理） 王道计算机考研 操作系统学习笔记 + 完整思维导图篇章五: IO管理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79a951d95739cf6ae0364c71de10a3b0/" rel="bookmark">
			《湖科大教书匠计算机网络》学习笔记总目录&#43;思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章是对《湖科大教书匠计算机网络》所有知识点的笔记总结归档和计算机网络的思维导图
学习视频：计算机网络微课堂（湖科大教书匠）
408四件套【计网、计组、操作系统、数据结构】完整课堂PPT + 思维导图 （求Star~）：【王道考研】计算机四件套完整资料
思维导图 各章节链接 第1章（计算机网络概述） 【湖科大教书匠】计算机网络随堂笔记第1章（计算机网络概述）
第2章（计算机网络物理层） 【湖科大教书匠】计算机网络随堂笔记第2章（计算机网络物理层）
第3章（计算机网络数据链路层） 【湖科大教书匠】计算机网络随堂笔记第3章（计算机网络数据链路层）
第4章（计算机网络网络层） 【湖科大教书匠】计算机网络随堂笔记第4章（计算机网络网络层）
第5章（计算机网络运输层） 【湖科大教书匠】计算机网络随堂笔记第5章（计算机网络运输层）
第6章（计算机网络应用层） 【湖科大教书匠】计算机网络随堂笔记第6章（计算机网络应用层）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aaf732e8ef64118f3845df8dd0b4507/" rel="bookmark">
			遗传算法求解旅行商问题（含python源代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
编码初始化种群
计算适应度
选择
交叉
变异
完整代码
总结
前言 这次的算法有一点不能确定是否正确，希望有大佬能够批评指正。
遗传算法的一般步骤
编码初始化种群 种群（population）指同一时间生活在一定自然区域内，同种生物的所有个体。
所以种群是由个体组成的，所以先需要得到个体，然后再随机产生一定数目的个体。
在本算法中个体采用的是实数编码（表示城市的编号，对应列表的下标，按照顺序就是在城市之间的移动路线）。
先对城市的位置进行初始化，采用的是用列表来表示城市的坐标，可以单个定义，也可以随机生成。
先生成一串有序的数字用来表示城市的编号，再每次随机进行打乱后储存到pop列表中，pop表示种群，里面装着的是列表用来表示个体。（个体表示城市的编号，种群表示编号打乱后所有个体的集合）
群体规模太小，不能提供足够的采样点,以致算法性能很差，易陷入局部最优解。
群体规模太大，尽管可以增加优化信息,阻止早熟收敛的发生,但无疑会增加计算量,造成收敛时间太长,表现为收敛速度缓慢。
City_Map = 100 * np.random.rand(20, 2) # 随机产生20个城市（20行2列，数值乘以100) DNA_SIZE = len(City_Map) # 编码长度（返回行的个数) POP_SIZE = 100 # 种群大小 # 生成初代种群pop pop = [] list = list(range(DNA_SIZE)) # 生成[0,DNA_SIZE)的列表 for i in range(POP_SIZE): # POP_SIZE是指种群大小，在程序中是一个固定的值(打乱POP_SIZE次之后把结果储存到pop列表中 random.shuffle(list) # 随机打乱list，进行初始化操作 l = list.copy() # 把list中的数据拷贝到l中 pop.append(l) # 将l添加到pop列表中 计算适应度 适应度函数值只能是正值，越大越好。
DNA表示个体，根据个体的值（表示城市的编号）来计算距离。
旅行商问题要求距离越短越好，所以距离越大越不满足要求，故而可以通过对距离求倒数来表示适应度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aaf732e8ef64118f3845df8dd0b4507/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7678af192df2424577acef9c5c647f/" rel="bookmark">
			王道计算机考研 操作系统学习笔记 &#43; 完整思维导图篇章五: IO管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
IO设备的基本概念和分类
IO设备的分类 按使用特性分类
按传输速率分类 按信息交换单位分类 IO控制器
l/O设备的电子部件（I/O控制器） l/O控制器的组成
内存映像I/o vs.寄存器独立编址
IO控制方式
程序直接控制方式
中断驱动方式
DMA方式
​编辑通道控制方式
DMA与通道的区别
IO软件层次结构 用户层IO软件 设备独立性软件
主要功能
中断处理程序
输入/输出应用程序接口 &amp; 设备驱动程序接口 输入/输出应用程序接口
阻塞/非阻塞I/O
设备驱动程序接口 IO核心子系统 假脱机技术（SPOOLing ） 什么是脱机技术
输入井和输出井
共享打印机原理分析 设备的分配与回收
设备分配时应考虑的因素 静态分配和动态分配
设备分配管理中的数据结构
设备分配的步骤
​编辑​编辑
设备分配步骤的改进 缓冲区管理 什么是缓冲区? 有什么作用?​编辑​编辑
单缓冲
双缓冲 使用单/双缓冲在通信时的区别
高速缓存与缓冲区对比
相同点
不同
循环缓冲区
缓存池
磁盘管理 磁盘的结构
磁盘、磁道、扇区 如何在磁盘中读/写数据
盘面、柱面
磁盘的物理地址
​编辑 磁盘的分类
磁盘调度算法
一次磁盘读/写操作需要的时间 先来先服务算法 (FCFS)
最短寻找时间优先 (SSTF)
扫描算法 (SCAN)
LOOK 调度算法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b7678af192df2424577acef9c5c647f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eecb4efdb06bea0ceb420ee80f1f13b9/" rel="bookmark">
			Doris删库元数据删除怎么办？紧急恢复单副本情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 正常情况下，如果是多副本的数据存储很容易修复，删除一个两个be也能根据doris自身的恢复机制恢复起来，但是，有时候可能有些表没有弄多个副本，那么就有点搞头了。
案例说明：fe的master节点的数据误删除，导致集群直接都宕机，那么如果是单个fe的话，那么可以使用云存储的快照功能恢复到指点的时间点的元数据存储，如果是多个节点的fe删除了master那么可以使用如下操作。
恢复Fe的数据 问题一 (操作之前记得备份一份)，删除执行目录下的文件，如下目录下的ROLE和VERSION（如果能够正常启动那么不需要删除，启动不了那么就删除ROLE和VERSION）：
/apache-doris-fe-1.2.0-bin-x86_64/doris-meta/image 删除ROLE和VERSION，不要删除image文件（如果能够正常启动那么不需要删除，启动不了那么就删除ROLE和VERSION）
然后再fe.conf配置如下(恢复到可以连接查询元数据的时候，停掉服务，取消下面的配置就可以了,恢复以后把新生成的VERSION数据的集群id修改成之前的集群id，原因是要和Be的集群id一样)
metadata_failure_recovery=true 问题二 下面的问题是由于fe数据同步出了问题，有多个fe那么就删除这种节点重新加入节点，没有就用上面的方法，删除Fe元数据里面的ROLE和VERSION进行恢复。
#在sql命令行执行 ALTER SYSTEM DROP FOLLOWER "100.200.0.36:9010"; ALTER SYSTEM ADD FOLLOWER "100.200.0.36:9010"; #要加入的节点，10.200.8.117是master节点，加入的节点的端口一定要和集群所有的端口相同 ./bin/start_fe.sh --helper 100.200.8.117:9010 --daemon 启动Be 恢复完Fe的数据以后，那么就可以启动Be了（如果Be使用到了supervisord,那么先关闭的，如果没有关闭，他就会在Be的数据存储目录meta目录和stream_load有一个LOCK文件，这是由于开启了自启动，和后面调试起来锁争抢问题，删除LOCK文件在重新启动就可以了）。
修复表单副本删除问题 可能有的Be的sst文件丢失了，那么可以使用云的磁盘快照功能，恢复到指定时间的数据，恢复以后会有以下问题。
问题一：找不到对应的tablet(用空白tablet填补) 可以使用下面的命令进行空白tablet的覆盖，那么会丢失近一天的数据（详情看doris官网介绍）。
ADMIN SET FRONTEND CONFIG ("recover_with_empty_tablet" = "true"); 修复完以后修改成false
ADMIN SET FRONTEND CONFIG ("recover_with_empty_tablet" = "false"); 问题二： Fe数据版本比Be数据版本高 ERROR 1105 (HY000): errCode = 2, detailMessage = (100.200.8.186)[INTERNAL_ERROR]failed to initialize storage reader. tablet=6708126.992547307.aa48977d2d69366b-180d241750a968ae, res=[INTERNAL_ERROR]fail to find path in version_graph.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eecb4efdb06bea0ceb420ee80f1f13b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbf025800fe84d5b7f94233da0c8105d/" rel="bookmark">
			学习单片机之前，你必须要有的知识储备！-51单片机学习笔记1-单片机概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是单片机？
冯·诺依曼体系结构
哈佛结构
计算机在应用过程中的两大应用分支
通用计算机系统
嵌入式计算机系统
什么是嵌入式系统？有哪些特点？如何构成的？
①嵌入式系统的定义：
②嵌入式系统的特点
1）·嵌入性：
2）·专用性：
3）·计算机系统：
③嵌入式系统是如何构成的？
​编辑
（1）嵌入式处理器
1）嵌入式微处理器（MPU）
2） 嵌入式微控制器（MCU）——微控制器（单片机）
3）嵌入式DSP处理器（DSP）——数字信号处理
4）嵌入式片上系统SOC——System on Chip
（2）外围硬件
1）运行条件：
2）辅助功能部件：
（3）嵌入式操作系统
（4）应用软件
④嵌入式系统的发展——嵌入式AI！
一些亟待解决的问题：
问题1：
问题2
问题3
什么是单片机？ 单片机就是在一片半导体硅片上，集成了中央处理单元（CPU）、存储器（ROM-只读存储器\RAM-随即存储器）、并行I/O、串行I/O、定时器/计数器、中断系统、系统时钟电路及系统总线的用于测控领域的微型计算机，简称单片机（MCU）。又称嵌入式控制器、微控制器
单片机与普通微型计算机的不同之处在于：单片机将CPU、存储器、和I/O口三部分通过内部总线连接在一起，集成于一块芯片上。
冯·诺依曼体系结构 核心思想1：计算机硬件系统的主要组成部件（五大部件）：运算器、控制器、存储器、输入设备、输出设备
运算器：进行算数和逻辑运算。
控制器：计算机的指挥控制中心，根据指令要求完成相应的操作，产生一系列控制命令，使计算机各部件自动、连续协调工作。
存储器：保存程序、数据、运算的中间结果和最后结果的记忆装置。
核心思想2：
1）采用二进制：计算机内部的控制信息和数据信息均采用二进制表示，并存放在同一个存储器中
2）计算机应该按照程序顺序执行（存储程序/控制程序）：
编制好的程序（包括指令和数据）预先经由输入设备输入并保存在存储器中；
计算机开始工作后，在不需要人工干预的情况下由控制器自动、高速地依次从存储器中取出指令并加以执行。
哈佛结构 计算机在应用过程中的两大应用分支 通用计算机系统 ——主要满足海量、高速的科学计算、数值处理、信息管理、计算机辅助设计/制造/教学、人工智 能、多媒体、网络数据共享等应用，兼顾控制功能。 • 通用微机，例如：PC微机 • 功能越强越好（高速、海量存储）、使用越方便越好  嵌入式计算机系统 ——面对测控对象，以各种方式嵌入到应 用系统中的计算机系统的统称。主要满足测控对象的控制功能， 兼顾数值处理。 • 专用微机，例如：单片机、工控机 • 可靠性高、实时性强、易控制、体积小 • 程序相对简单、处理数据量小，对性价比要求高 • 随着移动互联网的推动，嵌入式系统得以迅猛发展 什么是嵌入式系统？有哪些特点？如何构成的？ ①嵌入式系统的定义： 简单来说就是：以各种形态嵌入到对象体中的专用、计算机系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbf025800fe84d5b7f94233da0c8105d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d43e00299dd4cb0606591b048089d033/" rel="bookmark">
			王道计算机考研 操作系统学习笔记 &#43; 完整思维导图篇章四: 文件管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
文件管理
文件的逻辑结构
无结构文件
有结构文件
顺序文件
索引文件
索引顺序文件 文件目录
文件控制块（FCB）
目录结构分类
单级目录结构
两级目录结构
多级目录结构 （树形目录结构）
无环图目录结构
索引节点
文件的物理结构（文件分配方式）
文件块、磁盘块
文件分配方式 连续分配
链接分配 索引分配
文件存储空间管理
存储空间的划分与初始化
存储空间管理 空闲表法
空闲链表法
位示图法 成组链接法
文件的基本操作 创建文件 删除文件
打开文件 关闭文件
读取文件 写文件 文件共享
基于索引结点的共享方式（硬链接）
基于符号链的共享方式（软链接）
文件保护 口令保护 加密保护
​编辑访问控制
文件系统的层次结构 文件系统的全局结构
物理格式化
逻辑格式化
文件系统在内存中的结构
文件管理 文件的逻辑结构 按文件是否有结构分类，可以分为无结构文件、有结构文件两种
无结构文件 文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件。如;Windows 操作系统中的 .txt 文件。 有结构文件 由一组相似的记录组成，又称“记录式文件”。每条记录又若千个数据项组成。如:数据库表文件。一般来说，每条记录有一个数据项可作为关键字(作为识别不同记录的ID)
根据各条记录的长度(占用的存储空间) 是否相等，又可分为定长记录和可变长记录两种
顺序文件 索引文件 索引顺序文件 为了进一步提高检索效率，可以为顺序文件建立多级索引表。例如，对于一个含 106个记录的文件，可先为该文件建立一张低级索引表，每 100 个记录为一组，故低级索引表中共有 10000个表项(即10000个定长记录)，再把这 10000 个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有 100 个表项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d43e00299dd4cb0606591b048089d033/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80cf403dc8291aba726ed64301075f21/" rel="bookmark">
			订单 延后自动关闭，五种方案优雅搞定！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前 言 在开发中，往往会遇到一些关于延时任务的需求。例如
生成订单30分钟未支付，则自动取消生成订单60秒后,给用户发短信
对上述的任务，我们给一个专业的名字来形容，那就是延时任务 。那么这里就会产生一个问题，这个延时任务 和定时任务 的区别究竟在哪里呢？一共有如下几点区别定时任务有明确的触发时间，延时任务没有定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务
下面，我们以判断订单是否超时为例，进行方案分析 方案分析 1)数据库轮询 思 路
该方案通常是在小型项目中使用，即通过一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行update或delete等操作
实现
博主当年早期是用quartz来实现的，简单介绍一下 maven项目引入一个依赖如下所示
&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; 调用Demo类MyJob如下所示
package com.rjzheng.delay1; import org.quartz.JobBuilder; import org.quartz.JobDetail; import org.quartz.Scheduler; import org.quartz.SchedulerException; import org.quartz.SchedulerFactory; import org.quartz.SimpleScheduleBuilder; import org.quartz.Trigger; import org.quartz.TriggerBuilder; import org.quartz.impl.StdSchedulerFactory; import org.quartz.Job; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; public class MyJob implements Job { public void execute(JobExecutionContext context) throws JobExecutionException { System.out.println("要去数据库扫描啦。。。"); } public static void main(String[] args) throws Exception { // 创建任务 JobDetail jobDetail = JobBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80cf403dc8291aba726ed64301075f21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/523157768a2bec246074ea16f469059e/" rel="bookmark">
			x-cmd pkg | bat - cat 命令的替代品，对 cat 命令进行功能扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 简介首次用户功能特点进一步阅读 简介 bat 是 cat 命令的替代品，对 cat 命令进行功能扩展，如语法高亮、自动分页等，为用户提供更友好的显示和定制选项。对于需要在终端频繁查看文本内容的用户，推荐用 bat。
首次用户 使用 x bat 即可自动下载并使用
在终端运行 eval "$(curl https://get.x-cmd.com)" 即可完成 x 命令安装, 详情参考 x-cmd 官网 x-cmd 提供1分钟教程，其中包含了 bat 命令常用功能的 demo 示例，可以帮你快速上手 bat 。
功能特点 语法高亮：支持语法高亮显示大部分编程和标记语言，（使用 --list-languages 可查看其支持的语言）。集成 Git: bat 与 git 结合，能显示文件的修改内容。显示不可见字符：使用 -A / --show-all 可高亮显示不可见字符。自动分页：当输出文本内容过多时，bat 会使用 pager (e.g. less) 进行分页显示，避免一次性显示大量文本从而导致屏幕滚动不可控。个性化设置：bat 内置多种主题可供选择。使用 bat --list-themes 可以列出所有可用的主题。跨平台性：可以在不同的平台上安装和运行（Windows，Linux，MacOS 等） 进一步阅读 bat 源代码 - bat 项目的源代码托管在 GitHub，你可以在这里找到最新版本的 bat 和参与社区贡献。bat 与相关程序的比较 - 由 bat 官方给出的 bat 同类程序对比表格，可据此寻找像 bat 这样的程序。Linux Bat Command - 该博客详尽的介绍了 bat 的各种使用方法和最常见的问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f1e93a81280ac1d9d9947ccde314048/" rel="bookmark">
			QT 操作Windows系统服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows服务是在Windows操作系统上运行的后台应用程序，它们在系统启动时自动启动，并在后台持续运行，不需要用户交互。Windows服务的作用包括但不限于以下几个方面：1. 提供系统功能：许多Windows服务提供了系统级的功能和服务，如网络连接、文件共享、打印服务、安全认证、远程管理等。这些服务为用户和其他应用程序提供了基础设施和功能支持。2. 自动化任务：Windows服务可以用于执行自动化任务，如定期备份、数据同步、日志记录、定时任务等。它们可以在后台运行，无需用户干预，提供可靠的自动化功能。3. 后台通信和消息传递：Windows服务可以用于实现后台通信和消息传递，如消息队列、进程间通信等。它们可以在不同的应用程序之间传递数据和消息，实现应用程序之间的协作和集成。4. 系统监控和管理：Windows服务可以用于监控和管理系统状态和资源，如性能监控、事件日志、服务管理等。它们可以收集系统信息、监测系统性能，并提供管理接口和功能，帮助管理员维护和管理系统。
Windows服务是在后台运行的应用程序，提供了系统级的功能和服务，执行自动化任务，实现后台通信和消息传递，以及监控和管理系统。它们为Windows操作系统提供了稳定、可靠和高效的功能支持。
需要注意程序需要使用管理员权限启动才可以操作服务
QT 操作Windows系统服务目录
1 创建服务
2 删除服务
3 打开服务
4 关闭服务
5 启动服务
6 停止服务
7 自动启动
8 手动启动
9 查询服务
10 .h源文件
本文作者原创，转载请附上文章出处与本文链接。
1 创建服务 ///@ 创建服务 void MainWindow::newService() { SC_HANDLE schandle = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); //打开服务管理 SC_HANDLE h = ::CreateService(schandle, L"ServiceAPI", //服务名 L"ServiceAPI-Test", //显示用的服务名 SERVICE_ALL_ACCESS, //所有访问权限 SERVICE_WIN32_OWN_PROCESS, //私有类型 SERVICE_AUTO_START, //自启动类型 SERVICE_ERROR_NORMAL, //忽略错误处理 L"D:/ServiceAPI.exe", //应用程序路径 nullptr, nullptr, nullptr, nullptr, nullptr); ::CloseServiceHandle(h); //关闭 ::CloseServiceHandle(schandle);//关闭 ::getchar(); //暂停 } 2 删除服务 ///@ 删除服务 void MainWindow::deleteService() { SC_HANDLE schandle = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); //打开服务管理 SC_HANDLE h = ::OpenService(schandle, L"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f1e93a81280ac1d9d9947ccde314048/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7b49fdafecf8bbee57345a102b1e469/" rel="bookmark">
			@Cleanup() 使用注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端时间用lombok 的@Cleanup() 想实现线程池的自动关闭，因为使用不当，查bug查了好久，因此写篇博客纪念下，同时也希望读者可以跳过这个坑。
@Cleanup修饰的对象，可以在对象资源使用结束后，自动关闭。
1、错误的用法 @Test public void test() { ThreadPoolExecutor executor = createExecutor(); System.out.println(executor); } private ThreadPoolExecutor createExecutor() { @Cleanup("shutdown") ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10 , 10 , 1L , TimeUnit.SECONDS , new LinkedBlockingQueue&lt;&gt;(1000) , new ThreadFactoryBuilder().setNameFormat("testDemo" + "-thread-%d").build() , new ThreadPoolExecutor.CallerRunsPolicy() ); return threadPoolExecutor; } 上面是错误的用法，因为用 @Cleanup修饰了threadPoolExecutor，它会在这个方法块执行完毕后，自动执行线程池的shutdown方法，因此创建的线程池是一个关闭状态的。
debug 看下线程池状态：
2、正确的用法 @Test public void test() { @Cleanup("shutdown") ThreadPoolExecutor executor = createExecutor(); System.out.println(executor); } private ThreadPoolExecutor createExecutor() { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10 , 10 , 1L , TimeUnit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7b49fdafecf8bbee57345a102b1e469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8686da83a29444fdc873f39d115d0709/" rel="bookmark">
			java实现数据导出为excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		poi包实现导出功能 ExportExcel.java
import com.google.common.collect.Lists; import org.apache.commons.lang3.StringUtils; import org.apache.poi.ss.usermodel.*; import org.apache.poi.ss.util.CellRangeAddress; import org.apache.poi.xssf.streaming.SXSSFWorkbook; import org.apache.poi.xssf.usermodel.XSSFClientAnchor; import org.apache.poi.xssf.usermodel.XSSFRichTextString; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import javax.servlet.http.HttpServletResponse; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.*; /** * Excel文件（导出“XLSX”格式，支持大数据量导出 @see org.apache.poi.ss.SpreadsheetVersion） * * @author ThinkGem * @version 2013-04-21 */ public class ExportExcel { private static Logger log = LoggerFactory.getLogger(ExportExcel.class); /** * 工作薄对象 */ private SXSSFWorkbook wb; /** * 工作表对象 */ private Sheet sheet; /** * 样式列表 */ private Map&lt;String, CellStyle&gt; styles; /** * 当前行号 */ private int rownum; /** * 注解列表（Object[]{ ExcelField, Field/Method }） */ List&lt;Object[]&gt; annotationList = Lists.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8686da83a29444fdc873f39d115d0709/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db57b90ce6c3594e2f6456480c7a3653/" rel="bookmark">
			oracle实现搜索不区分大小写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;if test="code != null and code != ''"&gt;and upper(code) like upper('%${code}%') &lt;/if&gt; 关键字upper
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e0174627efdfc125fcd0dbb892668d/" rel="bookmark">
			git创建与合并分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 创建与合并分支分支管理的概念实际操作 解决冲突分支管理策略Bug分支Feature分支多人协作 创建与合并分支 分支管理的概念 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。
现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。
每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。
一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：
每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。
当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：
你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！
不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：
假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：
所以Git合并分支也很快！就改改指针，工作区内容也不变！
合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：
实际操作 首先，我们创建dev分支，然后切换到dev分支：
$ git checkout -b dev
git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：
$ git branch dev
$ git checkout dev
然后，用git branch命令查看当前分支：
$ git branch
git branch命令会列出所有分支，当前分支前面会标一个*号。
然后，我们就可以在dev分支上正常提交，比如对test.txt做个修改，加上一行：
Creating a new branch is quick.
然后提交：
$ git add test.txt
$ git commit -m “branch test”
现在，dev分支的工作完成，我们就可以切换回master分支：
$ git checkout master
切换回master分支后，再查看一个test.txt文件，刚才添加的内容不见了！
因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：
HEAD
│
▼
master
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5e0174627efdfc125fcd0dbb892668d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0592688efc291a02cffc463775f872dd/" rel="bookmark">
			基于范围的for循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基于范围的for循环这个功能需要在g++ 4.6版本之上才能使用
#include&lt;iostream&gt; #include&lt;stdint.h&gt; using namespace std; int main(){ double prices[] = {4.99, 10.02, 3,45, 6.002}; for (double price : prices){ cout&lt;&lt;price&lt;&lt;endl; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a32397f4f5fe828fad9be47f46562675/" rel="bookmark">
			ubuntu16-04安装minio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文连接：http://www.duozhi.online/2023/10/19/ubuntu16-04%e5%ae%89%e8%a3%85minio/
下载安装包 root@iZuf64s86ucw3ichp92qj5Z:~/minio#wget https://dl.min.io/server/minio/release/linux-amd64/minio root@iZuf64s86ucw3ichp92qj5Z:~/minio# chmod 755 minio 创建数据目录 root@iZuf64s86ucw3ichp92qj5Z:~/minio# mkdir data 直接运行 nohup ./minio server /root/minio/data --console-address ":9091" &gt; nohup.out 2&gt;&amp;1 &amp; MinIO启动后，可以在浏览器中输入http://ip:9000，打开后自动跳转到http://ip:9091，在用户名密码处输入默认用户名密码（minioadmin/minioadmin）即可登陆系统。
配置自启动服务 编辑配置文件 root@iZuf64s86ucw3ichp92qj5Z:~/minio# mkdir /root/minio/etc root@iZuf64s86ucw3ichp92qj5Z:~/minio# cd /root/minio/etc root@iZuf64s86ucw3ichp92qj5Z:~/minio/etc# cat minio # 指定数据存储目录(注意：这个目录要存在且拥有相对应的权限) MINIO_VOLUMES="/root/minio/data" # 监听端口 MINIO_OPTS="--console-address :9091" 编写服务文件 root@iZuf64s86ucw3ichp92qj5Z:~/minio/etc# cd /usr/lib/systemd/system/ root@iZuf64s86ucw3ichp92qj5Z:/usr/lib/systemd/system# ls -l total 12 -rw-r--r-- 1 root root 204 Dec 12 2022 gitlab-runsvdir.service -rw-r--r-- 1 root root 923 Oct 19 16:26 minio.service -rw-r--r-- 1 root root 923 Oct 19 16:24 minio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a32397f4f5fe828fad9be47f46562675/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c212e276bc74c0afc90da1165f14a29e/" rel="bookmark">
			centos7中kubeadmin搭建k8s-1-22
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文连接：http://www.duozhi.online/2023/10/20/centos7%e4%b8%adkubeadmin%e6%90%ad%e5%bb%bak8s-1-22/
etcd安装参考：http://www.duozhi.online/2023/10/19/centos7%e4%b8%adetcd%e5%8d%95%e6%9c%ba%e5%ae%89%e8%a3%85/
ansible安装参考：http://www.duozhi.online/2023/10/19/centos7%e4%b8%adansible%e5%ae%89%e8%a3%85/
1.节点信息 192.168.0.203 192.168.0.204 ansible配置 [root@MES-203 etcd]# cat /etc/ansible/hosts [k8s] 192.168.0.203 ansible_ssh_user=root ansible_ssh_pass=adm129 192.168.0.204 ansible_ssh_user=root ansible_ssh_pass=adm129 2.防火墙关闭下 [root@MES-203 lib]# ansible k8s -m shell -a "systemctl disable firewalld&amp;&amp;systemctl stop firewalld&amp;&amp;systemctl daemon-reload" 3.时间同步 [root@MES-203 yum.repos.d]# ansible k8s -m shell -a " yum install chrony -y" [root@MES-203 yum.repos.d]# ansible k8s -m shell -a "systemctl enable chronyd" [root@MES-203 yum.repos.d]# ansible k8s -m shell -a "systemctl start chronyd" [root@MES-203 yum.repos.d]# ansible k8s -m shell -a "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c212e276bc74c0afc90da1165f14a29e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/221b175898636fd161c2d0cf8ceae4b0/" rel="bookmark">
			Siren’s Song in the AI Ocean: A Survey on Hallucination in Large Language Models翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 虽然大型语言模型 (LLM) 在一系列下游任务中表现出了卓越的能力，但一个重要的问题是它们表现出幻觉的倾向：LLM 偶尔会生成与用户输入不同的内容、与之前生成的上下文相矛盾或生成与现有世界不一致的知识。这种现象对现实世界中法学硕士的可靠性提出了重大挑战。 在本文中，我们调查了最近在幻觉的检测、解释和缓解方面所做的努力，重点是法学硕士带来的独特挑战。 我们提出了法学硕士幻觉现象的分类法和评估基准，分析了旨在减轻法学硕士幻觉的现有方法，并讨论了未来研究的潜在方向。
1.介绍 大型语言模型（LLM）以其巨大的参数量为特征，已成为自然语言处理（NLP）和人工智能发展的有前途的基石。通过适当的对齐技术，例如监督微调（SFT）和来自人类反馈的强化学习（RLHF），最近的LLM在解决各种下游任务方面表现出了强大的能力。
尽管如此，如图 1 所示，LLM尽管取得了显着的成功，但有时会产生看似合理的输出，但实际上偏离了用户输入、与先前生成的上下文相反或不符合事实知识的内容——这种现象通常被称为幻觉，这极大地破坏了LLM在现实场景中的可靠性。例如，LLM可能会伪造错误的医疗诊断或治疗计划，从而导致现实生活中的切实风险。
虽然传统自然语言生成（NLG）环境中的幻觉已被广泛研究，但对理解和解决LLM领域内的幻觉问题遇到了独特的挑战：
Massive training data：与为特定任务精心整理数据相比，LLM 预训练使用从网络获取的数万亿个token，因此很难消除捏造的、过时的或有偏见的信息；Versatility of LLMs：通用LLM被期望能在跨任务、跨语言和跨领域环境中表现出色，这对综合评估和缓解幻觉提出了挑战。Imperceptibility of errors：作为其强大能力的副产品，LLM可能会产生最初看起来非常可信的虚假信息，这使得模型甚至人类都难以检测幻觉。 此外，RLHF过程、模糊的知识边界和LLM的黑箱特性也使LLM幻觉的检测、解释和缓解变得复杂。致力于解决上述挑战的前沿研究出现了显着的增长，这强烈促使我们编写这项综述。
我们按如下方式组织本文，如图 2 所示。我们首先介绍LLM的背景，并提供LLM中幻觉的定义（§2）。接下来，我们介绍相关的基准和指标（§3）。随后，我们讨论了LLM幻觉的潜在来源（§4），并对最近解决该问题的工作进行了深入回顾（§5）。最后，我们提出前瞻性观点（§6）。我们会持续更新相关开源资料，可以访问 https://github.com/HillZhang1999/llm-hallucination-survey。
2.Hallucination in the Era of LLM 我们首先概述了LLM的历史（§2.1）。接下来，我们将 LLM 幻觉分为三个子类别（第 2.2 节）。此外，我们讨论了LLM中幻觉的独特挑战（§2.3），并将幻觉与LLM领域经常遇到的其他普遍问题进行比较（§2.4）。
2.1 Large Language Models LLM的一个重要类别是自回归语言模型。这些模型以 Transformer 为骨干，根据之前的 token 来预测下一个 token。在 Transformers 广泛采用之前，自回归语言模型是建立在 n-gram 和循环神经网络的基础上的，并已应用于各种 NLG 任务，例如摘要和对话生成。
基于 Transformer 的LLM在跨任务方面表现出了卓越的性能，因此将 NLP 从以特定任务解决方案为中心的范式转变为通用预训练。使用大规模未标注的语料库，预训练模型针对各种自监督目标进行了优化。随后，使用目标下游任务的标注数据对模型进行微调。预训练模型的表示通常可以减少对标注数据的需求，并在下游任务中实现显着的性能改进。
除了下游任务的性能改进之外，最近的工作还发现，扩大预训练语言模型（无论是在模型参数数量还是预训练数据量方面）都可以实现一些显着的能力，包括上下文学习、推理和指令跟随 。在某种程度上，NLP社区普及了大型语言模型（LLM）这一术语，以将其与较小的模型区分开来。值得注意的是，LLM展现出准确理解人类指令并在极少甚至无监督的情况下有效处理各种复杂任务的潜力。
2.2 What is LLM Hallucination 虽然LLM已经表现出了出色的性能，但在实际应用中仍然不可避免地遇到不同的问题，其中幻觉是其中最重要的问题之一。在 LLM 出现之前，“幻觉”一词已在 NLP 社区中被广泛采用，通常指产生无意义或不忠实于所提供源的内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/221b175898636fd161c2d0cf8ceae4b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c146ffb4abd47347e53ce32b57b55957/" rel="bookmark">
			C&#43;&#43; 智能指针常用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 智能指针常用总结 文章目录 C++ 智能指针常用总结1. 写在对前面2. why 智能指针3. what 智能指针3.1 unique_ptr3.2 shared_ptr3.3 weak_ptr 3. how 指针指针3.1 unique_ptr3.1.1 创建3.1.2 成员函数 3.2 shared_ptr3.2.1创建3.2.2 成员对象 3.3 weak_ptr 4. 碎碎念5.参考资料 1. 写在对前面 最近接了一个写 c++ 的任务，在使用智能指针的时候，写出一个 dump 的 bug。作为 golang 小白在入门 c++ 的必经之路。整理一份 c++ 智能指针的常用知识点。全文按照如下思路整理
why 智能指针
what 智能指针
how 智能指针
智能指针是 C++ 中用于管理动态分配对象的一种特殊指针。它能够自动管理对象的生命周期。避免内存泄漏和野指针的问题。
2. why 智能指针 「一种特性的提出，势必是为了解决某类难以解决的问题。」在智能指针提出之前，C++ 是通过手动分配和释放内存来进行管理的。使用如下两个关键字进行分配和释放内存：
new：用于分配动态内存。通过使用 new 关键字，可以在堆上分配指定大小的内存，并返回指向新分配的内存的指针。例如，可以使用 int* p = new int; 来分配一个整数的内存，并将指向该内存的指针存储在变量 p 中。
delete：用于释放动态内存。使用 delete 关键字，可以释放通过 new 关键字分配的内存。例如，可以使用 delete p; 来释放变量 p 指向的整数内存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c146ffb4abd47347e53ce32b57b55957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9555d6a5c869007de76f086365282e02/" rel="bookmark">
			OpenCV探索之路（二十三）：特征检测和特征匹配方法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自： https://www.cnblogs.com/skyfsm/p/7401523.html
一幅图像中总存在着其独特的像素点，这些点我们可以认为就是这幅图像的特征，成为特征点。计算机视觉领域中的很重要的图像特征匹配就是一特征点为基础而进行的，所以，如何定义和找出一幅图像中的特征点就非常重要。这篇文章我总结了视觉领域最常用的几种特征点以及特征匹配的方法。
在计算机视觉领域，兴趣点（也称关键点或特征点）的概念已经得到了广泛的应用， 包括目标识别、 图像配准、 视觉跟踪、 三维重建等。 这个概念的原理是， 从图像中选取某些特征点并对图像进行局部分析，而非观察整幅图像。 只要图像中有足够多可检测的兴趣点，并且这些兴趣点各不相同且特征稳定， 能被精确地定位，上述方法就十分有效。
以下是实验用的图像：第一幅是手机抓拍的风景图，第二幅是遥感图像。
1.SURF 特征检测的视觉不变性是一个非常重要的概念。 但是要解决尺度不变性问题，难度相当大。 为解决这一问题，计算机视觉界引入了尺度不变特征的概念。 它的理念是， 不仅在任何尺度下拍摄的物体都能检测到一致的关键点，而且每个被检测的特征点都对应一个尺度因子。 理想情况下，对于两幅图像中不同尺度的的同一个物体点， 计算得到的两个尺度因子之间的比率应该等于图像尺度的比率。近几年， 人们提出了多种尺度不变特征，本节介绍其中的一种：SURF特征。 SURF全称为“加速稳健特征”（Speeded Up Robust Feature），我们将会看到，它们不仅是尺度不变特征，而且是具有较高计算效率的特征。
我们首先进行常规的特征提取和特征点匹配，看看效果如何。
#include "highgui/highgui.hpp" #include "opencv2/nonfree/nonfree.hpp" #include "opencv2/legacy/legacy.hpp" #include &lt;iostream&gt; using namespace cv; using namespace std; int main() { Mat image01 = imread("2.jpg", 1); //右图 Mat image02 = imread("1.jpg", 1); //左图 namedWindow("p2", 0); namedWindow("p1", 0); imshow("p2", image01); imshow("p1", image02); //灰度图转换 Mat image1, image2; cvtColor(image01, image1, CV_RGB2GRAY); cvtColor(image02, image2, CV_RGB2GRAY); //提取特征点 SurfFeatureDetector surfDetector(800); // 海塞矩阵阈值，在这里调整精度，值越大点越少，越精准 vector&lt;KeyPoint&gt; keyPoint1, keyPoint2; surfDetector.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9555d6a5c869007de76f086365282e02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e33691bce881632fd8df9e41cda1f92/" rel="bookmark">
			如何训练一个简单的stable diffusion模型(附详细注释）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：代码来自https://github.com/darcula1993/diffusion-models-class-CN/blob/main/unit1/01_introduction_to_diffusers_CN.ipynb 本文是本人学习后的的尝试以及注解
一、准备工作 """ 这行命令使用pip工具来安装或升级多个Python包。具体来说，它执行以下操作： -qq：这是pip的安静模式选项，它会减少输出信息，只显示关键信息，使安装过程更为简洁。 -U：这是pip的升级选项，它指示pip升级已经安装的包到最新版本（如果存在新版本）。 接下来，列出了要安装或升级的包： diffusers：一个Python包 datasets：Hugging Face Transformers库的一部分，用于提供和管理各种自然语言处理（NLP）数据集的工具。 transformers：Hugging Face Transformers库，提供了预训练的深度学习模型，用于自然语言处理和文本生成任务。 accelerate：Hugging Face库的一部分，用于加速深度学习模型的训练和推理。 ftfy：一个用于处理Unicode文本的Python库，用于修复和清理不规范的Unicode文本。 pyarrow：正如前面所提到的，pyarrow是一个用于高效处理大规模数据集的Python库，支持列式存储和跨语言互操作性。 """ %pip install -qq -U diffusers datasets transformers accelerate ftfy pyarrow # 登录hugging face from huggingface_hub import notebook_login notebook_login() 显示下图则登陆成功：
# 安装 Git LFS 来上传模型检查点： %%capture !sudo apt -qq install git-lfs !git config --global credential.helper store # 导入将要使用的库，并定义一些方便函数，稍后将会使用这些函数 import numpy as np import torch import torch.nn.functional as F from matplotlib import pyplot as plt from PIL import Image def show_images(x): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e33691bce881632fd8df9e41cda1f92/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/80/">«</a>
	<span class="pagination__item pagination__item--current">81/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/82/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>