<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b9dcb0cebc4b1f23ca96f2317d75a32/" rel="bookmark">
			【Android12】Android Framework系列--AMS启动Activity分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AMS启动Activity分析 通过ActivityManagerService(AMS)提供的方法，可以启动指定的Activity。比如Launcher中点击应用图标后，调用AMS的startActivity函数启动应用。
AMS提供的服务通过IActivityManager.aidl文件定义。
// frameworks/base/core/java/android/app/IActivityManager.aidl package android.app; // 省略 /** * System private API for talking with the activity manager service. This * provides calls from the application back to the activity manager. * * {@hide} */ interface IActivityManager { // 省略 /** @deprecated Use {@link #startActivityWithFeature} instead */ @UnsupportedAppUsage(maxTargetSdk=29, publicAlternatives="Use {@link android.content.Context#startActivity(android.content.Intent)} instead") int startActivity(in IApplicationThread caller, in String callingPackage, in Intent intent, in String resolvedType, in IBinder resultTo, in String resultWho, int requestCode, int flags, in ProfilerInfo profilerInfo, in Bundle options); int startActivityWithFeature(in IApplicationThread caller, in String callingPackage, in String callingFeatureId, in Intent intent, in String resolvedType, in IBinder resultTo, in String resultWho, int requestCode, int flags, in ProfilerInfo profilerInfo, in Bundle options); // 省略 } 代码版本是Android12。分析一下从应用侧（比如Launcher）调用startActivity启动另一个应用的流程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b9dcb0cebc4b1f23ca96f2317d75a32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07cc04cc782cca397bc885a656199bfe/" rel="bookmark">
			CTF学习笔记——ret2text
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CTF学习笔记——ret2text 原理 ret2text 应该算是PWN里面比较简单的题型了，这种题型有个显著特征，就是会有个很明显的后门函数，也就是system("/bin/sh")，我们只需要将我们的程序跳转到后门函数即可。不过我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。
不过程序也可能会开启某些保护，我们需要想办法去绕过这些保护，这些我们就到后面来介绍。
题目 [SWPUCTF 2021 新生赛]gift_pwn | NSSCTF
分析 首先用Checksec分析二进制文件
我们发现这个程序仅仅打开了NX(堆栈不可执行保护)，也就是在堆栈上的数据不可执行，不能直接通过将shellcode放入堆栈然后执行程序，打开后门。
amd64说明这个程序是64位的，i386-32是32位程序；little说明这个程序是小端的，这个主要影响的是我们程序对于数据的解读方式。
反编译 将其使用IDA64(如果是32位就用IDA)打开该二进制程序，可能第一次打开就是这个样子，我们按下空格可以看到完整的汇编代码，同时按下F5就可以查看反编译的结果。
我们在左侧函数列表找到main函数，常规来说这个是程序的入口，我们会从这里开始看程序的执行流程，反编译后大概就是这样，执行了一个vuln函数。
双击vuln函数之后发现了一个明显的数组越界（栈溢出），如下所示，read读入了0x64个字节，远超栈的大小，这边我们双击buf查看一下栈结构。
栈结构如下所示，0x10就是数组的大小，然后后面就是保存的rbp（32位是ebp）以及返回地址。s是存储的rbp，代表这个函数结束以后rbp要被修改为什么。
r是返回地址，代表这个函数结束以后程序会跳转到哪个地址继续执行，我们大多数情况下都是利用这个返回地址来进行操作。
由于栈的生长方向是由高地址往低地址增长的，我们可以看到左边是变量所在的相对位置，以s为基准。
在read读入字符的时候，第一个字符会被放在相对地址是0x10的位置，第二个字符会被放在0x0f的位置上，当我们读入的字符超过了buf的长度，那么会接着向下（高地址）存放，这个时候就会覆盖掉原来保存在高地址的s和r，以让程序跳转到不同的地方。
read函数可以读入0x64个字符，而buf的长度为16，s为8，r为8，可以修改s和r，(在32位程序中s和r为4，64位程序中s和r为8，这是由计算机位数决定的，一个字符长度是一个字节，一个字节的长度是8位(即长度为8的二进制数)，32/8 = 4，64/8 = 8)
在左边的函数列表我们可以看到一个gift函数，很显然，我们需要跳转到此处。
它的作用是打开一个shell，这很明显是一个后门函数
那么如果我们可以控制vuln函数中的r的地址为gift函数的起始地址，那我们就可以跳转到这个后门函数，然后可以执行我们想要的命令。
开始编写我们需要的利用脚本
利用 from pwn import * p = remote("node4.anna.nssctf.cn",28377) payload = b'a' * 16 + b'a' * 8 payload += p64(0x4005B6) p.send(payload) p.interactive() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a09e26200281fca10c0f7fbd3c3e83/" rel="bookmark">
			`ElementUI` 中的奇技淫巧（2023）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ElementUI的世界中，不仅有基础的组件和功能，还有一些让你眼前一亮、*得不能再*的高级技巧和窍门。本文将揭示这些技巧，让你在前端开发的舞台上独领风骚。无论你是一个勇敢的创新者还是一个喜欢调皮捣蛋的开发者，这些技巧都将让你的ElementUI应用更加酷炫和有趣！
直接进入正题
el-scrollbar滚动条 参数说明类型可选值native是否采用原生滚动。即只是隐藏原生滚动条，但并没有使用自定义的滚动条）Boolean-wrapStyle容器样式Object-wrapClass容器样式名Object-viewClass展示视图的样式名Object-viewStyle展示视图的样式Object-noresize容器大小是否不可变。如果 container 尺寸不会发生变化，最好设置它可以优化性能Boolean-tag渲染容器的标签。view容器用那种标签渲染，默认为divString- 自定义滚动条的原理
warp：滚动的可显示区域，滚动内容就是在这个区域中滚动；
view：实际的滚动内容，超出warp可显示区域的内容将被隐藏；
track：滚动条的滚动滑块；
thumb：上下滚动的轨迹。
&lt;el-scrollbar&gt; &lt;li v-for="user in userList" :key="user.id"&gt;{{user.name}}&lt;/li&gt; &lt;/el-scrollbar&gt; 管理弹出层的z-index：PopupManager ElementUI的弹出层在元素定位上，都有两种实现方式，分别是：
append-to-body：此模式下，弹出层会被放在&lt;body&gt;元素上，通过position: fixed定位，配合动态的top和left属性，完成弹出元素的定位。非append-to-body：此模式下，弹出层通过position: absolute定位，配合其父元素position: relative来完成弹出元素的定位。 在大多数情况下，ElementUI都是默认使用append-to-body，因为非append-to-body存在严重副作用，只有迫不得已的情况下才需要使用。
ElementUI弹出层的核心实现机制： 只要让新出现的弹出层，永远比之前所有弹出层的层级要高，就不会有新弹层被旧弹层遮盖的事情发生。
PopupManager：为弹出层提供获取实例、注册、注销等各种能力，但其最重要的能力，是提供了z-index的层级管理能力。
ElementUI为其内置了一个弹出层z-index基数（2000），但可以进行修改。
// 修改弹出层的`z-index`从3000开始递增 Vue.use(Element, {zIndex: 3000}) &lt;template&gt; &lt;div class="container"&gt; &lt;el-button @click="onClick"&gt;增加&lt;/el-button&gt; z-index: {{ value }} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { PopupManager } from 'element-ui/src/utils/popup' export default { data() { return { value: 0 } }, methods: { onClick() { // 使用 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0a09e26200281fca10c0f7fbd3c3e83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff29e83d521ddd26487c39917c66de6/" rel="bookmark">
			复制粘贴——QT实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复制粘贴——QT实现原理 QT 剪贴板相关类 QClipboard 对外通用的剪贴板类，一般通过QGuiApplication::clipboard() 来获取对应的剪贴板实例。
// qtbase/src/gui/kernel/qclipboard.h class Q_GUI_EXPORT QClipboard : public QObject { Q_OBJECT private: explicit QClipboard(QObject *parent); ~QClipboard(); public: enum Mode { Clipboard, Selection, FindBuffer, LastMode = FindBuffer }; void clear(Mode mode = Clipboard); bool supportsSelection() const; bool supportsFindBuffer() const; bool ownsSelection() const; bool ownsClipboard() const; bool ownsFindBuffer() const; QString text(Mode mode = Clipboard) const; QString text(QString&amp; subtype, Mode mode = Clipboard) const; void setText(const QString &amp;, Mode mode = Clipboard); const QMimeData *mimeData(Mode mode = Clipboard ) const; void setMimeData(QMimeData *data, Mode mode = Clipboard); QImage image(Mode mode = Clipboard) const; QPixmap pixmap(Mode mode = Clipboard) const; void setImage(const QImage &amp;, Mode mode = Clipboard); void setPixmap(const QPixmap &amp;, Mode mode = Clipboard); Q_SIGNALS: void changed(QClipboard::Mode mode); void selectionChanged(); void findBufferChanged(); void dataChanged(); protected: friend class QApplication; friend class QApplicationPrivate; friend class QGuiApplication; friend class QBaseApplication; friend class QDragManager; friend class QPlatformClipboard; private: Q_DISABLE_COPY(QClipboard) bool supportsMode(Mode mode) const; bool ownsMode(Mode mode) const; void emitChanged(Mode mode); }; QPlatformClipboard 系统剪切板平台接口类，各种桌面平台（Windows，X11，Wayland等）通过这个类提供统一的剪贴板操作接口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ff29e83d521ddd26487c39917c66de6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad34780a680b19de108bcfab73b1dd4/" rel="bookmark">
			Flask和Vue框架实现WebSocket消息通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 安装环境 1.1 安装Flask环境 主要的安装包 Flask、Flask-SocketIO，注意Python版本要求3.6+
# Flask-SocketIO参考地址 https://flask-socketio.readthedocs.io/en/latest/ https://github.com/miguelgrinberg/flask-socketio 更新基础环境
# 更新pip python -m pip install --upgrade pip # 更新setuptools pip install --upgrade setuptools # 安装Flask pip install flask pip install flask_cors # 安装关于SocketIO的包 # 安装python-socketio时，会自动安装python-engineio依赖 pip install python-socketio pip install flask-socketio # eventlet具有WSGI支持的异步框架，主要功能是通过协程实现并发 pip install eventlet 我的“requirements.txt”的包
bidict==0.22.1 blinker==1.7.0 click==8.1.7 colorama==0.4.6 dnspython==2.4.2 eventlet==0.33.3 Flask==3.0.0 Flask-Cors==4.0.0 Flask-SocketIO==5.3.6 greenlet==3.0.1 h11==0.14.0 importlib-metadata==7.0.0 itsdangerous==2.1.2 Jinja2==3.1.2 MarkupSafe==2.1.3 python-engineio==4.8.0 python-socketio==5.10.0 simple-websocket==1.0.0 six==1.16.0 Werkzeug==3.0.1 wsproto==1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ad34780a680b19de108bcfab73b1dd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/161e1cc904bd84b208ff82c57093f207/" rel="bookmark">
			【实习面试题】机器学习算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1,二分法进行查找
1 3 4 5 0 81 93 22 0 2 6
找出3
用C++实现
程序：
时间复杂度：
空间复杂度：
2, map-reduce有什么优势
什么是map-reduce
http://blog.csdn.net/lifuxiangcaohui/article/details/22675437
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edfd042dd593b626797ee1cca7911521/" rel="bookmark">
			概率论与数理统计基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机视觉一些算法中常会用到概论的一些知识，为了便于理解和快速回忆，博主这边对常用的一些知识点做下整理，主要来源于如下这本书籍。
1. 随机试验的每一可能结果称为一个基本事件，一个或一组基本事件统称随机事件，或简称事件。典型的随机试验有掷骰子、扔硬币、抽扑克牌以及轮盘游戏等。
2.事件的概率是衡量该事件发生的可能性的量度。
概率论（数学分支）_百度百科
概率（统计学术语）_百度百科
3.随机事件,是指的一个事件,一件事情,如一次实验,要求是其结果是随机的,可以有很多种,如掷骰子有六种结果,但投之前是不可以确定的.而随机变量用来表示随机事件的一种结果或几种结果的集合,如A表示投掷的结果是1,B表示投掷的结果为1或2,等等,总之,随机变量是结果的集合的子集,包括全集。可看到具体的随机事件是随机变量的一个子集，一种具体情况
4.对于一个随机变量，不仅要说明它能够取什么值，更需要关心取这些值的概率(分布函数)。
5.多个随机变量之间的关系
6. ​ 如果随机变量 X的全部可能取值只有有限多个或可列无穷多个，则称 X 为离散型随机变量。掷骰子的结果就是离散型随机变量。
6.期望值不是求概率值，而是去看随机变量的取值
如果随机变量可取任意的整数值，期望值就不一定存在。此外对于赌博来说，期望值也不是越多越好。例如，对于有1/2的概率获得10亿元与直接获得1亿元，你会如何选择呢？显然，前者的期望值为5亿元，后者为1亿元。
7.方差即期望值的离散程度
8. 随机变量的平均值
之前提过，离散变量取一值时就是一个事件；联合分布的几个变量，各取一值时，也就是一个事件。联合分布可以是某个动作在重复做的事件，大数定律描述的也是一个事件，这个事件由重复的某一个动作构成。如上文提到的那样，X1,X2,...Xn随机变量的平均值Z。随着n的增大，Z的方差为0，此时z的期望值即接近为统计出来的平均值。
9. 条件期望与最小二乘法
10.连续值的概率分布一些知识点可以类比离散情况。这里有个概率密度函数的概念
注意一点连续随机变量取一值的概率为0
对于取值某一段的概率才有意义
变量的变换函数
如下是离散分布和连续分布公式的对比
如下连续型随机变量的期望值，方差和标准差
如下是连续随机变量的联合分布概率
标准正态分布和一般正态分布
联合分布变量的求解
中心极限定理如下
11.协方差和相关系数
12. 协方差矩阵
协方差矩阵重点是要明白意思，可以表示一个向量各分量之间的关系。比如我们常接触到的样本集，一般会如下表示：
一列可以表示一个样本中提取出的特征向量，然后这组集合里有n个样本。我们可以认为每列特征向量都是一个联合分布变量的实际取值。所以可以去计算V[X],V[Y],Con(X,Y)等。比如利用第一行和第二行可以得到Con(X,Y) 。那么协方差矩阵就可以通过一个样本集合计算出来，来表示这个样本集合的一些特性。
如下即是计算一些样本集特性的例子，这里样本集是一个二维空间中点的集合。
通过协方差矩阵可以计算出这些点集的主轴。 可以看到，矩阵论的一些知识点就和概率论交叉在了一起。因为矩阵论都是基于矩阵的数学计算，然后矩阵中的列可以看作是随机变量的一个取值。对于这一点关联点还是挺有意思的。后面博主也会有篇幅来介绍矩阵论的相关知识。
13.估计与检验
估计是利用现有的样本来估计变量的一些特性值，如期望和方差
检验理论中的显著性水平知识也常会碰到，其也可以变相的去验证哪个联合分布事件的概率大。
14.概率论的应用
（1） 通过最小二乘法拟合直线
（2）主成分分析
卡尔曼滤波和马尔科夫链后面有时间以专篇来介绍吧。 暂时就记录这些吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1dce492f3f54fee842b902cdafad31f/" rel="bookmark">
			pycharm显示内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba7745353b6ec5f75ac2ec3a7b7de93c/" rel="bookmark">
			MySQL忘记密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据提供的引用内容，当使用root用户登录MySQL时，如果密码错误，会出现"Access denied for user ‘root’@‘localhost’ (using password: NO)"的错误提示。这个错误提示表示使用了错误的密码或者没有输入密码就尝试登录MySQL。解决这个问题的方法是输入正确的密码或者重置root用户的密码。
以下是两种解决方法：
输入正确的密码 在使用root用户登录MySQL时，需要输入正确的密码。如果忘记了密码，可以通过重置密码的方式来解决。如果确定密码正确，但是还是出现了"Access denied for user ‘root’@‘localhost’ (using password: NO)"的错误提示，可以尝试使用以下命令来登录MySQL：
mysql -u root -p 这个命令会提示输入密码，输入正确的密码即可登录MySQL。
重置root用户的密码 如果忘记了root用户的密码，可以通过以下步骤来重置密码：
停止MySQL服务
sudo systemctl stop mysql 使用以下命令以跳过授权表的方式启动MySQL服务
sudo mysqld_safe --skip-grant-tables &amp; 使用以下命令登录MySQL
mysql -u root 在MySQL中更新root用户的密码
use mysql; update user set authentication_string=password('new_password') where user='root'; flush privileges; quit; 注意将"new_password"替换为你想要设置的新密码。
重启MySQL服务
sudo systemctl start mysql 完成以上步骤后，使用新密码登录MySQL即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce0a170d5513053c4e9ba7c2938236ef/" rel="bookmark">
			Python Pandas数据处理常用操作代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常识 使用pandas.read_csv从csv文件中读取数据，对于csv中缺失的空值，读进dataframe会自动补为numpy.nan，且数据类型为float 操作 读取csv文件，存储为dataframe数据类型 df = pandas.read_csv(csv_path) 查看csv文件的dataframe的所有列字段名 print(df.columns) 按行遍历dataframe for row in df.itertuples(): 可以用row.column_name访问该行具体的列（column_name无需加引号）
删除dataframe的指定整列数据 df = df.drop(['city', 'region', 'iso_country_code'], axis=1) # 删除列 'city', 'region', 'iso_country_code' # 这里的删除其实并没有对df本身作出任何改变，而是将df进行拷贝，将拷贝的副本进行了列删除操作，所以这里一定要赋值给一个新的df，仅仅用df.drop并不能改变df 根据某个字段的值的集合条件筛选出符合条件的目标行，以构成新dataframe # 使用isin()方法筛选匹配的行 new_df = df[df['placekey'].isin(mht_poi_list)] # 筛选出df中 placekey字段的值在列表mht_poi_list中的记录行，以构成一个新dataframe new_df new_df = new_df.reset_index(drop=True) # 经过筛选而得到的dataframe索引很乱，不连续，这里的操作是在重排索引 往dataframe指定位置插入一整列 df.insert(loc=6, column='top_category_id', value=cate1_ids) # loc 位置 # column 列名 # value 数据来源 （这里一般我习惯用list，要求list的长度要与dataframe的行数目一致） 将dataframe数据写入csv文件 df.to_csv(csv_path, index=False) # 不把行索引信息写入csv文件 df.to_csv(csv_path, index=True) # 把行索引信息写入csv文件 使用list构建dataframe df = pandas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce0a170d5513053c4e9ba7c2938236ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc5802d7b6bfd48694e927d10d911e73/" rel="bookmark">
			从零开始搭建企业管理系统（四）：集成 Knife4j
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集成 Knife4j 前言Knife4j是什么集成 Knife4j引入 pom 依赖添加基础配置启动程序测试完善文档信息编写配置类修改 UserController修改 UserEntity修改 BaseEntity 文档效果图swagger 界面knife4j 界面 前言 前面一小节我们使用postman来进行接口的调试，如果接口一多，就很不方便进行管理，也不方便调试，所以我们本小节集成一个接口文档组件Knife4j，有疑问可以查看 Knife4j 官网。
Knife4j是什么 Knife4j是一个集Swagger2 和 OpenAPI3 为一体的增强解决方案
Knife4j 是为 Java MVC 框架集成 Swagger 生成 Api 文档的增强解决方案，前身是 swagger-bootstrap-ui，致力于 springfox-swagger 的增强 UI 实现。knife4j 为了契合微服务的架构发展，由于原来 swagger-bootstrap-ui 采用的是后端 Java 代码 + 前端 UI 混合打包的方式，在微服务架构下显的很臃肿，因此项目正式更名为 knife4j，更名后主要专注的方面如下：
后端 Java 代码以及前端 UI 模块进行了分离，在微服务架构下使用更加灵活提供专注于 Swagger 的增强解决方案，不同于只是单纯增强前端 UI 部分 集成 Knife4j 我们参考 Knife4j 官网的教程进行集成。
因为我们的 Spring Boot 版本是 3.2.0，所以只支持 OpenAPI3 规范
Spring Boot 3 只支持OpenAPI3规范Knife4j提供的starter已经引用springdoc-openapi的jar，开发者需注意避免jar包冲突 引入 pom 依赖 &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc5802d7b6bfd48694e927d10d911e73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7eef2b5d33db9bbe54362321c7cc15c/" rel="bookmark">
			java.lang.NoClassDefFoundError: javax/servlet/jsp/tagext/TagLibraryValidator jstl.jar和standard.jar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
实验七 JSTL与标签文件
一、实验目的
二、实验原理
三、实验内容与步骤
jstl.jar和standard.jar在哪里下载?
如果说出现了如下的报错信息：java.lang.NoClassDefFoundError:javax/servlet/jsp/tagext/TagLibraryValidator 四、思考题
实验七 JSTL与标签文件 一、实验目的 1. 了解什么是JSTL？
2. 掌握JSTL的核心库标签的使用。
3. 掌握标签文件的开发和使用。
二、实验原理 JSP标准标签库（JSP Standard Tag Library，简称JSTL）是一个为实现Web应用程序的常用功能而开发的标签库集合。功能包括基本输入输出、流程控制、XML文件解析、数据库查询、国际化和文本格式化等。JSTL主要由下面几个库组成：
核心标签库；XML标签库；格式化/国际化标签库；数据库标签库；函数标签库。 这些库都很有用，但我们这里只学习核心库的使用。核心库的标签又可以分成四类，如表12.1所示：
表12.1 按功能分类的核心库的标签
JSTL标签类别
JSTL标签
标签说明
通用目的
&lt;c:out&gt;
&lt;c:catch&gt;
在页面中显示内容
捕获异常
变量支持
&lt;c:set&gt;
&lt;c:remove&gt;
设置一个EL变量值
清除一个EL变量
流程控制
&lt;c:if&gt;
&lt;c:choose&gt;
&lt;c:forEach&gt;
&lt;c:forTokens&gt;
根据一个属性等于一个值改变处理
根据一个属性等于一组值改变处理
对集合中的每个对象作重复处理
对给定一个文本域中的每个子串执行处理
URL处理
&lt;c:url&gt;
&lt;c:import&gt;
&lt;c:redirect&gt;
重写URL并对它们的参数编码
访问web应用程序外部的内容
告诉客户浏览器访问另一个URL
标签文件（tag file）也是JSP 2.0新增的功能，它的目的是使JSP页面开发人员仅使用JSP语法就能开发标签库而无须编写Java程序。所谓标签文件就是直接使用JSP语法编写的标签。标签文件的扩展名一般为.tag或.tagx，如果标签文件包含其他完整的或片段的标签文件，JSP 2.0建议其扩展名为.tagf。
在JSP页面中使用标签文件，需要在taglib动作中使用tagdir属性指定标签文件所在的目录，例如：
&lt;%@ taglib prefix="mytag" tagdir="/WEB-INF/tags"%&gt;
三、实验内容与步骤 （一）JSTL的安装和测试
【步骤1】要在JSP页面中使用JSTL标签，首先必须安装JSTL库。可以到Jakarta网站下载最新版本的JSTL，网址为http://jakarta.apache.org/，目前最新版本为1.1.2版，它支持JSP 2.0和Servlet 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7eef2b5d33db9bbe54362321c7cc15c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d3afc26c6eea5e6c84a9baf4608c564/" rel="bookmark">
			3.ELK之Logstash安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Logstash作为ELK技术栈中重要的一员，本文介绍Logstash的一些使用。
官网 Logstash：收集、解析和转换日志 | Elastic
拉到下方有 Logstash文档 和 Logstash论坛 以及 下载 的链接。
1、简介 Logstash 是一个开源的数据收集引擎。它可以按照我们定制的规范实时地进行数据收集、解析和转存。也就是说Logstash有3个核心组成部分，分别是数据收集、数据解析和数据转存。这三个部分组成了一个类似于管道的数据流，由输入端进行数据的采集，管道本身做数据的过滤和解析，输出端把过滤和解析后的数据输出到目标数据库中。
大致翻一下官方手册可以看到其功能还是非常强大的。Logstash Reference [8.4] | Elastic
能用上的就有不少，如 elasticsearch/redis/file/http/kafka/tcp/udp/stdout/websocket/mongodb等。 #Input有如下插件 Input plugins azure_event_hubs beats cloudwatch couchdb_changes dead_letter_queue elastic_agent elasticsearch exec file ganglia gelf generator github google_cloud_storage google_pubsub graphite heartbeat http http_poller imap irc java_generator java_stdin jdbc jms jmx kafka kinesis log4j lumberjack meetup pipe puppet_facter rabbitmq redis relp rss s3 s3-sns-sqs salesforce snmp snmptrap sqlite sqs stdin stomp syslog tcp twitter udp unix varnishlog websocket wmi xmpp #output有如下插件 Output plugins boundary circonus cloudwatch csv datadog datadog_metrics dynatrace elastic_app_search elastic_workplace_search elasticsearch email exec file ganglia gelf google_bigquery google_cloud_storage google_pubsub graphite graphtastic http influxdb irc java_stdout juggernaut kafka librato loggly lumberjack metriccatcher mongodb nagios nagios_nsca opentsdb pagerduty pipe rabbitmq redis redmine riak riemann s3 sink sns solr_http sqs statsd stdout stomp syslog tcp timber udp webhdfs websocket xmpp zabbix https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d3afc26c6eea5e6c84a9baf4608c564/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31d2ce37b9a71968da114dfb80c1556d/" rel="bookmark">
			22.MongoDB删除操作效率及相关问题验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到一个了一个MongoDB数据删除的问题，需要一次性删除上线即1.5年前~1年前的数据且之后每天清空一年过期的数据。在数据量比较大的情况下何种方式的删除效率最高是一个值得研究的问题，本文通过实际测试找出其中规律。
本文采用腾讯云mongodb集群进行验证。mongd配置较弱为2核4G，验证仅仅针对副本集不涉及分片集群。测试数据集如下，共计1000w条数据。接下来会以systime字段作为筛选条件验证影响删除操作耗时的因素都有哪些。
kfuin_beg = 0 kfuin_end = 1 for(var num = kfuin_beg; num &lt; kfuin_end; num++){ var kfuin_num = num+1;//主号数 var cid_num = 10000 //1万个cid var session_num = 10//每个cid有10通会话 var detail_num = 99//每个session有9条消息 var docs = []; for(var i = num; i &lt; kfuin_num; i++){ for(var j = 0; j &lt; cid_num; j++){ for(var k = 0; k &lt; session_num; k++){ var kfuin_val = i + 2852000000 var session_index_name_val = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31d2ce37b9a71968da114dfb80c1556d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67fa643ecb822ed70d69c24ab17a6762/" rel="bookmark">
			PHP的pack/unpack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP: pack - Manual PHP中文手册 PHP中国镜像 php 国内镜像 PHP官方网站
PHP: unpack - Manual PHP中文手册 PHP中国镜像 php 国内镜像 PHP官方网站
1、作用 （1）pack：将数据打包成二进制字符串。将输入数据打包成format格式的二进制字符串。 pack(string $format, mixed ...$values): string
（2）unpack：根据指定的format将二进制字符串解包成数组。
注：对于一个二进制字符串可能是由多部分组成，每部分都是一个&lt;K,V&gt;，多个就是k-v数组了。待会儿看个具体的例子就知道了。
unpack(string $format, string $string, int $offset = 0): array|false
支持的格式如下：
我们简单的关注下几种格式即可。
#n 无符号短整型(16位，大端字节序) 高尾端 尾端放在高地址 #v 无符号短整型(16位，小端字节序) 低尾端 尾端放在低地址 #c 有符号字符 #C 无符号字符 2、使用方式 （1）pack的使用。
#同时将4部分数据按照分别指定的格式打包为二进制字符串，格式如下。 #①将16进制数据0x1234按照n(无符号短整型(16位，大端字节序))格式打包成二进制字符串 #②将16进制数据0x5678按照v(无符号短整型(16位，小端字节序))格式打包成二进制字符串 #③将10进制数据65按照c(有符号字符)格式打包成二进制字符串 #④将10进制数据66按照c(无符号字符)格式打包成二进制字符串 &lt;?php $binarydata = pack("nvcC", 0x1234, 0x5678, 65, 66); print_r("packresult:" . $binarydata); #4xVAB print_r("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67fa643ecb822ed70d69c24ab17a6762/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74d57e652965705c8dff74eb82206cb9/" rel="bookmark">
			01_C&#43;&#43; Qt开发：Qt的安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ Qt开发：Qt的安装与配置 Qt是一种C++编程框架，用于构建图形用户界面（GUI）应用程序和嵌入式系统。Qt由Qt公司（前身为Nokia）开发，提供了一套跨平台的工具和类库，使开发者能够轻松地创建高效、美观、可扩展的应用程序。其被广泛用于开发桌面应用程序、嵌入式系统、移动应用程序等。无论是初学者还是经验丰富的开发者，Qt都为构建高质量、可维护的应用程序提供了丰富的工具和支持。
关于C++ Qt的一些关键特点和用途：
跨平台性： Qt是一个跨平台的框架，支持主流的操作系统，包括Windows、macOS、Linux以及一些嵌入式系统。这使得开发者能够编写一次代码，然后在多个平台上运行，大大简化了跨平台应用程序的开发。图形用户界面（GUI）设计： Qt提供了强大的GUI工具包，允许开发者通过可视化设计工具创建用户界面。Qt的设计哲学注重直观性和易用性，使得创建各种复杂的GUI应用程序变得相对容易。信号与槽机制： Qt引入了一种灵活的信号与槽机制，用于处理对象之间的通信。这种机制使得对象能够在不直接了解其他对象的情况下相互通信，提高了代码的可维护性和可扩展性。模块化设计： Qt采用了模块化的设计，提供了丰富的类库覆盖了诸如图形渲染、文件I/O、网络通信、数据库访问等多个领域。这使得开发者能够在项目中选择需要的模块，避免不必要的代码冗余。国际化支持： Qt支持国际化和本地化，使得应用程序能够轻松地适应不同的语言和文化环境。开放源代码： Qt是一款开源框架，拥有活跃的社区支持。开发者可以自由使用、修改和分发Qt的源代码，也可以根据需要选择商业许可证。Qt Creator集成开发环境（IDE）： Qt Creator是专为Qt设计的集成开发环境，提供了强大的代码编辑、调试和可视化设计工具，使得开发过程更加高效。 如何安装与配置 安装和配置Qt通常涉及以下步骤。请注意，这里提供的步骤基于一般情况，具体步骤可能会有所不同，具体取决于您使用的操作系统。以下是一个基本的指南：
Qt的下载可以去官方网站，这里我就以5.14.2这个版本为例，请读者也和我使用相同的版本，如下结果是Qt下载页面；
下载地址：https://download.qt.io/archive/qt/5.14/5.14.2/ 这里我认为有必要说一下这些目录分别代表了什么，这个解释我将其归纳为了如下表所示的说明信息，读者可自行参考学习；
目录说明archive各个Qt版本的安装包、配套工具包等（注意，清华站相比主站做了裁剪，只能看到5.9之后的版本）community_releases社区定制的Qt 库，不用理会development_releases开发版，有新的和旧的不稳定版本，在Qt 开发过程中的非正式版本。learning一些学习资料linguist_releases一款软件，目前我没用到，未仔细研究ministro迷你版，目前是针对Android的版本。official_releases正式发布版，是与开发版相对的稳定版Qt库和开发工具，我们选择时，应选择此处的版本onlineQt 在线安装源snapshots预览版，最新的开发测试中的 Qt 库和开发工具。 当下载好对应的安装程序之后就可以安装了，直接qt-opensource-windows-x86-5.14.2.exe运行程序，会出下如下界面，直接点击下一步跳转到登录页面，这个登陆页面可以直接输入一个错误的账号密码，然后点击返回按钮，之后就可以跳转到安装页面，此页面并不是强制的。笔者这里将QT软件安装在D盘：
D:\Qt\Qt5.14.2 为了保证安装组件的齐全，这里读者务必全部打勾，完全充分安装需要10GB的空间，此时应做好准备，如下图所示；
安装结束后就可以看到开始菜单的，Qt Creator 4.11.1 (Community)程序，直接打开该程序就可以进入到Qt的开发页面中，如下图所示；
以上步骤是一个基本的安装和配置过程，具体步骤可能因Qt版本和操作系统而异。在安装和配置过程中，可以参考Qt的官方文档和安装向导，这将提供更详细和特定的说明。
配置Visual Studio Qt 提供了 Visual Studio 插件，以便更方便地在 Visual Studio 中进行 Qt 项目的开发。以下是配置 Qt Visual Studio 插件的一般步骤：
首先要下载对应的插件文件，根据读者自己安装的Visual Studio版本来选择不同的插件，由于我使用的是VS2013所以这里选择2.3.0的版本，如下图读者可自行选择对应的版本下载使用。
插件下载：https://download.qt.io/development_releases/vsaddin/2.3.0/ 读者首先需要安装好Visual Studio开发环境并确保Qt已安装，只需要双击运行qt-vsaddin-msvc2013-2.3.0.vsix等待初始化并直接点击下一步即可完成，如下图所示；
如果发现用不了，那就下载补丁包再次安装试试把。
https://marketplace.visualstudio.com/items?itemName=TheQtCompany.QtVisualStudioTools 如果安装了没有出来插件，就就到Visual Studio 的插件商店 搜索 QT 进行直接安装。
注意，如果说 vs2013 出现未能建立到服务器的连接的错误框，且错误信息如下。
请求被中止：未能创建SSL/TLS安全通道。
那我们可以通过下工具 -- 库程序包管理器(N) -- 程序包管理器控制台(o) -- 底部弹出控制台输入界面 ,输入如下命令解决问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74d57e652965705c8dff74eb82206cb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d746ebe9e4f83f2108349f8ee0290983/" rel="bookmark">
			【SA8295P 源码分析 (三)】77
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为一些原因，本文需要移除，
对于已经购买的兄弟，不用担心，不是跑路，
我会继续持续提供技术支持，
有什么模块想学习的，或者有什么问题有疑问的，
请私聊我，我们 +VX 沟通技术问题，一起学习，一起进步
接下来，我一一私聊已经购买的兄弟添加VX，我们继续一起学习，一起进步，加油
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/680cdfcb35e2c32d1c72f41269ea39d1/" rel="bookmark">
			山西教资面试---结构化真题125道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第一章 教育教学类单元1：应急应变（1-21）单元2：日常管理（22-54）单元3：人际关系（55-66） 第二章 综合分析类单元4：社会现象（66-112）单元5：态度观点（2）单元6：职业认知（5）单元7：时事教师（6） 第一章 教育教学类 单元1：应急应变（1-21） 1.上课提问有个学生积极举手回答问题，但是站起来后不知道怎么回答，你怎么办？
针对这样的问题，我会保持冷静，理智应对：
首先，我会帮他理清思路，引导他回答完这道题，对他的积极主动进行表扬，并继续授课
其次，在课下，我主动找他沟通，了解原因
如果是因为紧张，导致没有回答出来，那么我会引导他，答案思考成熟后，按照自己的想法顺其自然陈述即可，并且在后续的课堂中我也会多提问，帮助他树立信心
如果是因为知识点没有掌握，那么我会无偿的帮助其补回落下的课程。
最后，作为老师我也会认真的反思，不断提高专业能力，关心爱护学生，促进学生全面发展。
2.课堂上只有那么几个学生回答问题，你怎么办？
针对这样的问题，我会保持冷静，妥善处理：
首先，我会应用教学机智缓解课堂中的尴尬，
其次，我会适当的调整自己的授课方式，运用多媒体播放与课程相关的内容，并适时的抛出几个简单的问题，来提问未回答过问题的学生。增强他们的自信心，让学生们都有参与感。
再次，我会反思自己，是否因为授课方式太死板，内容不够生动形象，无法吸引学生的兴趣，我也会向有经验的老教师虚心请教，总结经验，取长补短，
最后，我会更加努力学习专业知识，关心爱护每一位学生，建立良好的师生关系，促进学生的全面发展。
3上课时外面下冰雹，学生不听课，怎么办？
针对这样的问题，我会保持冷静，妥善处理
首先，遇到这种情况，我会通过幽默的语言去化解，可以说“同学们这么努力学习，连冰雹都来听课了。好了，我们继续回到课堂上吧。”通过这样的方式，让学生的注意力转移到课堂中来。
其次，在课堂教学中，我会通过提示，比如“这里是重点内容，大家认真听”或者“这里是难点，大家要认真思考哦”等，吸引同学的有意注意，同时也会通过抑扬顿挫、适当停顿，吸引学生无意注意。
最后，我也会进行反思，虚心请教老教师，提高自己处理突发情况的能力。
4上课时同学讨论问题很热烈，但是继续讨论会影响教学进度，怎么办？
针对这样的情况，我会保持冷静，妥善处理：
前先，遇到这种情况，我会拍拍手，让他们停下，然后说“同学们的求知欲真强烈，给大家布置个任务，下课讨论，现在我们该继续上课了”通过这样的方式，让学生的注意力转移到课堂中来。
其次，在下课前布置小小的作业，让他们继续讨论，培养学生探索求职的欲望。
最后，我会进行自我反思，要调整上课方式，合理安排课题难度，以及讨论时间，提高自己把控课堂的能力，同时也要提高自己应急应变的能力。
5.上课有蝴蝶飞进来，学生都要抓，你怎么办
针对这样的情况，我会保持冷静，妥善处理:
首先，我会通过幽默的语言去化解，可以说“同学们这么努力学习，连蝴蝶都都来听课了! 好了，，我们继续回到课堂上。”通过这样的方式，让学生的注意力转移到课堂中来。
其次，在课堂教学中，我会通过提示，比如“这里是重点内容，大家认真听”或者“这里是难点，大家认真思考哦”等，吸引同学的有意注意 ;同时也会通过抑扬顿挫、适当停顿等方法，吸引学生无意注意。
最后，我也会进行反思，虚心请教老教师，提高自己处理突发情况的能力。
6 同学上课玩手机不听讲，你怎么办？
针对这样的情况，我会保持快冷静，妥善处理：
首先，我会及时制止他玩手机的行为，并示意他注意听课，保障他的学习效果。
其次，我会课下找到该生了解他在课堂上玩手机的原因，
如果是因为有特殊情况需要用到手机，那么我会建议他有问题要第一时间找到老师帮忙，让其意识到上课玩手机是不正确的。
如果是因为沉迷手机游戏，我会对该生进行说服教育，告诉他，现阶段的主要任务是学习，沉迷手机会影响自己的学业，我也会与家长进行沟通，形成家校合力，帮助他改掉沉迷游戏的坏习惯，
最后，我会就手机问题开展班会，说明课堂上玩手机的行为是不正确的，不仅影响课堂秩序，还影响听课效果，引导大家共同努力，营造一个秩序良好的班集体。
7.小亮上课回答错问题，全班哄然大笑，你怎么办？
针对这样的问题，我会保持冷静，妥善处理：
首先：我会制止同学们哄然大笑的行为，对小亮勇于回答问题提出表扬，并对那些嘲笑小亮的同学提出批评，之后帮助学生把注意力转移回课堂，保证课堂正常进行。
其次：课下我会找到小亮了解回答错问题的原因，
如果是因为他基础不好，那么我无偿为小亮补习，帮助他赶上课程进度。
如果是因为我的教学方法存在问题，那么我会改变自己的教学方法，帮助学生更好的掌握知识。
最后，我也会反思自己，通过各种途径不断学习，提高自己教育教学能力的同时，关心爱护每一位学生，促进学生的健康成长。
8.上课时一女生回答问题声音小，男生在旁边起哄，作为老师你怎么办？
针对这样的情况，我会保持冷静，妥善处理：
首先，我会制止男生的起哄行为，维护课堂秩序，安抚女生的情绪，继续完成教学任务。
其次：课下我会找到女生了解声音小的原因，
如果是因为对于问题不会回答，那么我会耐心讲解知识点，直到女孩掌握为止；
如果是因为性格内向，我会积极鼓励她敢于开口，创造机会帮助她锻炼自己，增强自信心。
对于起哄的男生，进行说服教育，让他意识到扰乱课堂秩序，伤害到他人的自尊心，是不对的
最后，我也会反思工作中的不足，把学生的心理健康和德育作为重中之重，关心爱护学生，促进学生的全面发展。
9.上课期间，有两位同学发生口角，有一位同学摔门而出，你会怎么做？
如果出现上述情况，我要保持冷静，妥善处理
首先，我会把出去的学生劝回教室，让他意识到摔门的行为是对其他人的不尊重。同时回归课堂，保证课程的有序进行。
其次，在课后我会找到两位同学了解他们争吵的原因，
如果是学习上的问题，产生了不同看法，我会从知识的角度出发，用正确的理解说服两位同学；如果是两个人有矛盾，我会教育他们，上课要认真听讲，其他事情课下解决，他们的这种行为不仅会影响自己，还会影响全班同学的听讲。同时我也会让两位同学把自己的不满情绪表达出来，采用幽默方式化解双方矛盾。
最后，我会召开一次“同学友好相处”的主题班会，告诉大家我们是和谐快乐的大家庭，有问题及时沟通解决。
10.课堂上一位男生扯着前面的女孩子，两个人起冲突了，作为老师你怎么处理？
针对这样的问题，我会保持冷静，妥善处理：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/680cdfcb35e2c32d1c72f41269ea39d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac2bd5026baa953a6384925ba58d0de1/" rel="bookmark">
			人工智能轨道交通行业周刊-第68期（2023.12.4-12.10）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期关键词：车辆巡检机器人、铁路标桩、智能运维、大模型归因、RAG
1 整理涉及公众号名单 1.1 行业类 RT轨道交通人民铁道世界轨道交通资讯网铁路信号技术交流北京铁路轨道交通网上榜铁路视点ITS World轨道交通联盟VSTR铁路与城市轨道交通RailMetro轨道世界铁路那些事铁路技术创新智慧交通RTAI智慧城轨网轨道交通智能装备NE轨道交通铁路供电上海铁道兰州铁路中国地方铁路协会铁路社评轨道部落现代轨道交通城市地铁捡瓶子的小灰灰马公子的杂货铺 1.2 人工智能类 江大白糙科技新智元AI科技评论智东西量子位我爱计算机视觉极视平台人工智能学家AI前线当交通遇上机器学习计算机视觉life新机器视觉雷锋网人工智能产业发展联盟AIIA自动驾驶之心笔记侠夕小瑶科技说水木人工智能学堂 2 数字轨道 （1）铁路信号工的“黑科技”，超酷！
导读：铁路信号工的智能“黑科技”有多酷？今天小编就带大家走进中国铁路西安局集团有限公司电务检修基地，一起去看看自动喷漆机器人、AGV搬运机器人、长臂机器人、器材全寿命管理系统、负压吸尘设备、智能仓储架……
（2）分享 | 城轨车辆智能巡检机器人的应用与展望
导读：在第七届中国城市轨道交通智慧运维大会上，广州地铁何晔发表了《城轨车辆智能巡检机器人的应用与展望》，就城轨车辆智能巡检机器人进行了详细探讨，分享了运维现状、智能巡检机器人应用情况以及对未来展望。
（3）时速15公里！铁路上还有这么迷你的一款车
导读：钢轨上只能跑火车？那可不一定！这不就有一辆“敞篷小跑车”“萌萌哒”跑在铁路上。这么“迷你”的“小黄车”是干吗的？今天我们来到中国铁路上海局集团有限公司徐州工务段带你一起揭秘。
3 轨道知识 （1）铁路边的这些标志桩都代表啥意思
导读：大家是否注意到铁路沿线会有一排排整齐的标桩，这些标桩大小不同、涂装各异，它们可是有着自己的专属职能，今天小编就带你一起了解铁路标桩背后的故事。
（2）涨知识| 股道、道岔编号及股道的有效长度
导读：我国铁路采用左侧行车，并且原则上规定以开往北京的方向为上行方向，背离北京的方向为下行方向。在车站上为了作业和维修管理上的方便，站内线路及道岔由工务部门会同电务部门和车站共同统一顺序编号，那么股道、道岔编号方法是什么？
（3）钢轨也照镜子 ？
导读：人们平时妆容打扮需要照镜子，但是，小伙伴们知道吗，钢轨也要照镜子，走！和小编一起跟随兰州铁路局兰州西工务段职工到作业现场，一探究竟~
4 AI产业 （1）一文详解大模型归因机制，幻觉问题有救了！
导读：大模型的幻觉问题一直是一个亟待解决的挑战。为了增强模型事实准确性和可验证性，一种可行的方法是在大模型生成响应的同时，提供相关证据来支撑其答案，这一研究方向称为归因（Attribution），即为大模型生成的答案追根溯源。最近，哈尔滨工业大学团队对开放域生成系统中的归因机制进行了全面的回顾，深入探讨了归因的起源、相关技术、评估标准以及所面临的挑战。
（2）RAG+GPT-4 Turbo让模型性能飙升！更长上下文不是终局，「大海捞针」实验成本仅4%
导读：RAG+GPT-4，4%的成本，便可拥有卓越的性能，这是最新的「大海捞针」实验得出的结论。为满足特定数据集和用户的应用需求，本文对三种实现技术：上下文窗口填充、RAG、微调进行了比较，分别从准确性、成本及延迟三个关键指标分析，结果证明，RAG效果最佳，这或许是大模型能力飙升的下一个未来！
（3）计算机视觉GPT时刻！UC伯克利三巨头祭出首个纯CV大模型，推理惊现AGI火花
导读：计算机视觉的GPT时刻来了！UC伯克利的CV三巨头推出首个无自然语言的纯视觉大模型，第一次证明纯CV模型也是可扩展的。更令人震惊的是，LVM竟然也能做对图形推理题，AGI火花再次出现了？
（4）清华教授裴丹：大模型与智能运维的融合
导读：大模型时代下，有4个运维界普遍关注的问题，比如大模型落地运维场景，面临哪些技术挑战？与较为成熟的 AIOps 小模型有什么关系？面对百模大战的情况，如何选择大模型的底座？以及近期、中期、长期有哪些落地的应用？今天为大家带来清华大学裴丹教授分享的一些观点，供大家参考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae1d2710e200d6611a61376e94133508/" rel="bookmark">
			MyBatis——Java 持久层框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 MyBatis 是什么准备工作创建一个数据库和表引入依赖 配置连接字符串和 MyBatisMyBatis 组成MyBatis 使用步骤定义一个类创建 MyBatis 接口（以查询所有为例）创建与接口对应的 xml 文件（实现接口中的所有方法）使用单元测试进行验证查询单条记录增加数据修改和删除 \#{} 和 ${} 的区别like 查询resultMap动态 SQL`&lt;if&gt;``&lt;trim&gt;``&lt;where&gt;``&lt;set&gt;``&lt;foreach&gt;` MyBatis 是什么 是一款持久层框架基于 JDBC可以通过方便的设置实现数据库操作 Mybatis（之前称为 iBatis）也是一个 ORM 框架，ORM（Object Relational Mapping），即对象关系映射。
ORM 把数据库映射为对象：
数据库表（table）–&gt;类（class）记录（record，行数据）–&gt;对象（object）字段（field）–&gt;对象的属性（attribute） 准备工作 创建一个数据库和表 create database mycnblog default character set utf8mb4; use mycnblog; create table userinfo( id int primary key auto_increment, username varchar(100) not null, password varchar(32) not null, photo varchar(500) default '', createtime datetime default now(), updatetime datetime default now(), `state` int default 1 ) default charset 'utf8mb4'; insert into userinfo values(1, 'admin', '123', '', '2023-12-10 10:09:30', '2023-12-10 10:09:30', 1); 引入依赖 MyBatis Framework 和 MySQL Driver
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae1d2710e200d6611a61376e94133508/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cce66be07bb45e2cfb039837d26c796/" rel="bookmark">
			基于SpringBoot框架的管理系统【完整项目源码免费下载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java员工管理系统的所有源码全都完整且直接免费下载即可，希望大伙点个关注，感谢大伙的支持和信任，后续会更新更多各式各样完整的管理项目和其他应用程序，全都免费共享！！！
链接：https://pan.baidu.com/s/1hb0WNLhktdPJq9S-Avcsyw?pwd=wen8
提取码：wen8
在学Java的同志或者其他需要本系统的同志请自行点击链接下载,感谢同志们的支持和关注
介绍： 该项目的定位介于简单和复杂之间，适合大二大三的课设或者大作业使用，后端主要使用springBoot框架进行开发，介于大伙可能Vue的脚手架工程不是很熟悉，于是采用引入Vue2 cdn的方式开发前端，直接导入即可，无需配置任何东西，良心开发
基于springBoot + Vue2 + MySQL的前后端分离员工信息管理系统
主要功能：增删改查，批量删除，条件分页查询，账号锁定，根据员工请假自动生成记录，懒加载，根据时间请假记录自动销假等；
有需要的请自行下载自行查看！
注意：前端和sql文件分别自行打开导入即可，后端项目导入之前需要idea已经配置了maven，再导入即可，记得修改配置文件中的数据库用户名和密码，最后运行即可！！！
后期会不断更新完善其他功能
该员工信息后台管理系统的界面展示如下：
登录页面
懒加载页面效果
用户管理页面
员工管理页面
员工管理新增效果演示页面
员工管理请假申请效果演示页面
部门管理页面
请假记录页面
出勤记录页面
有需要的请自行下载！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff6520aad3afbf1485492dd2126e2d44/" rel="bookmark">
			YOLOX 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、YOLOX贡献和改进二、YOLOX架构改进总结 前言 在计算机视觉领域，实时对象检测技术一直是一个热门的研究话题。YOLO（You Only Look Once）系列作为其中的佼佼者，以其高效的检测速度和准确性，广泛应用于各种实时视觉处理任务。YOLOX引入了一系列创新的方法和技术，进一步提升了检测性能，尤其在处理速度和准确性的平衡方面取得了显著进步。本文将详细探讨YOLOX的主要贡献和改进以及其网络架构的创新之处。
一、YOLOX贡献和改进 YOLOX主要贡献和创新点包括：
Anchor-Free Approach: YOLOX将原本的YOLO检测器转变为了一个anchor-free（无锚点）的方式，这意味着它不依赖于预设的锚点来预测对象的位置，而是直接预测对象的边界框。
Decoupled Head and Advanced Detection Techniques: 采用了解耦头（decoupled head）和其他先进的检测技术，例如SimOTA标签分配策略，这些技术的结合显著提高了模型的性能。
Performance Across Different Model Sizes: YOLOX在不同大小的模型上表现出了优越的性能，从小型的YOLO-Nano到大型的YOLOX-L，都在各自领域实现了最先进的结果。
Efficiency and Accuracy: YOLOX在保持高帧率（FPS）的同时提高了准确度（AP），这对于实时应用非常重要。
Winning the Streaming Perception Challenge: YOLOX的一个版本在2021年CVPR的Streaming Perception Challenge中获得了第一名，这证明了其在实时处理方面的强大能力。
总的来说，YOLOX通过引入无锚点方法、解耦头、先进的标签分配策略等创新，大幅提高了YOLO系列在各种模型大小上的性能，特别是在准确度和实时处理能力方面。这些改进使得YOLOX成为了在实际场景中非常有用的工具，特别是在需要快速且准确目标检测的应用中。
二、YOLOX架构改进 YOLOX的网络架构改进涉及以下几个主要方面：
从YOLOv3出发：YOLOX选择YOLOv3作为基线模型，采用Darknet53作为主干网络和SPP层。相比于原始的YOLOv3实现，YOLOX在训练策略上进行了一些调整，如增加了EMA权重更新、余弦学习率调度、IoU损失和IoU感知分支。
解耦头：为了解决分类和回归任务之间的冲突，YOLOX引入了解耦头。在实验中表明，解耦头相比于耦合头能够提高收敛速度，并对端到端YOLO的版本至关重要。
锚点自由（Anchor-Free）：YOLOX摒弃了基于锚点的检测方法，转而采用锚点自由的方式。这种方式大大减少了设计参数的数量，简化了检测器的训练和解码阶段。
强大的数据增强：YOLOX引入了Mosaic和MixUp这两种强大的数据增强策略来提升性能。
多正样本（Multi Positives）：为了解决正负样本不平衡的问题，YOLOX采用了多正样本的策略，选择对象中心的位置以及中心3×3区域的其他高质量预测作为正样本。
SimOTA：高级标签分配策略：SimOTA是一个高级的标签分配策略，它基于损失/质量感知、中心优先、动态正样本数量和全局视野的四个关键洞察。SimOTA通过简化的动态top-k策略获取近似解，有效减少了训练时间，同时提高了性能。
端到端YOLO：YOLOX还尝试了端到端的方法，即在检测过程中不进行后处理，但这会略微降低性能和推理速度。因此，这被视为一个可选模块，不包含在最终模型中。
总结 YOLOX通过一系列的创新性改进，如引入锚点自由方法、解耦头和SimOTA标签分配策略，显著提高了模型的性能，尤其是在不同模型大小上的表现和实时处理能力。这些改进不仅提高了检测的准确性，同时也保持了高效的处理速度，使YOLOX成为了实时对象检测应用的强大工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f83ae8443aaadf000e7d0c3d7b9ffee/" rel="bookmark">
			go语言的类型别名与类型定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类型别名(Type Alias) 类型别名是Go 1.9版本添加的新功能主要用于解决代码升级,迁移中存在的类型兼容性问题
type MyAlias = SomeType package main import "fmt" // 类型别名:将int取一个别名为MyInt type MyInt = int func main() { var num1 MyInt = 5 var num2 int = 10 // MyInt类型和int类型是相同的类型,可以相互赋值而无需转换 num1 = num2 num2 = num1 fmt.Println(num1, num2) // 10 10 fmt.Printf("num1: %T \n", num1) // num1: int fmt.Printf("num2: %T \n", num2) // num1: int } 在这个例子中,MyInt是int的别名,两者是同一个类型,因此他们可以互相赋值,不需要进行任何类型转换.MyInt类型只会在代码中存在,编译完成时,不会有MyInt类型
类型定义(Type Definition) type NewType SomeType package main import "fmt" // 类型定义: 创建一个全新类型,名为Feet,底层类型为float64 type Feet float64 func main() { var distanceFeet Feet = 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f83ae8443aaadf000e7d0c3d7b9ffee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f952fd6321479c4a06e1c24ba9d7592b/" rel="bookmark">
			子网划分（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
IP地址
子网划分
例题
例题
例题
IP地址 在学习子网划分之前应该先清楚什么是IP地址和IP地址的类型
IP 地址的格式 0网络地址主机地址10网络地址 主机地址
110网络地址主机地址1110组播地址11110保留 A 1.0.0.0~127.255.255.255
B 128.0.0.0~191.255.255.255
C 192.0.0.0~223.255.255.255
D 224.0.0.0~239.255.255.255
E 240.0.0.0~255.255.255.255
地址类型可以分为5类 A、 B、C、D、E。
子网划分 IP地址在经过子网划分后，被分成三个部分 分别是——网络位、子网位和主机位子网数=2的n次方，其中n为子网部分位数主机数=2的n次方-2，其中n为主机部分位数 子网划分可以分为：
1. 等长子网划分
2. 可变长子网划分 例题 中联公司近期向中国互联网络信息中心(CNNIC)申请了一个C类网段–200.1.1.0/24。该公司有6个部门，技术部最大，有电脑50台，市场部最小，只有20台电脑，其他各部门都有25台主机，作为该公司的网络管理员，请你对申请到的地址进行合理划分，使每个部门处于一个子网中。要求给出每个子网的网络地址、广播地址和可用主机IP地址范围，并说明每个部门使用哪个子网。 答题思路：子网划分过程，按容量大小，依次满足 可用IP地址 的算法是2的n次方减2
题目中给出了一个C类地址 200.1.1.0 掩码是24位
题目要求划分6个部门 分别是 技术部 市场部 和 其他部门
按照容量大下依次排序 技术部 50 其他各部 25 25 25 25 市场部 20 我在算子网划分题目的时候会先把2的 0次方到7次方依次列出
2的0次方=1
2的1次方=2
2的2次方=4
2的3次方=8
2的4次方=16
2的5次方=32
2的6次方=64
2的7次方=128
第一步 主机位 先算技术部，从题中得知技术部有50个电脑。在上面的等式中找到大于等于50的这个数。 2的6次方 最为合适 处于8位组从右往左第二个 所以子网掩码位 255.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f952fd6321479c4a06e1c24ba9d7592b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa8383ddbab3f1a6203d14ed11727637/" rel="bookmark">
			TCP拥塞控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 TCP拥塞控制 1.TCP拥塞控制概述 什么是网络拥塞
计算机网络中的带宽、交换结点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏。这种情况就叫做网络拥塞。
什么是拥塞控制
拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。
2.TCP拥塞控制的原理 假定：
1.数据是单方向传送，而另一个方向只传送确认
2.为了关注拥塞控制以和流量控制形成对比，假设接收方总是有足够大的缓存空间。
3.以TCP报文段的个数为讨论问题的单位，而不是以字节为单位
在上面这三个假设的限制下，会有以下的结论
发送方维护一个称为拥塞窗口cwnd的状态变量，其值取决于网络的拥塞程度，并且动态变化。特别是，在一个发送方中未被确认的数据量不会超过cwnd与rwnd的最小值。因为在上面假设了接收方的接收缓存足够大，所以可以忽略接收窗口rwnd的限制，因此在发送方中未被确认的报文段仅受限于cwnd。
拥塞窗口cwnd的维护原则：只要网络没有出现拥塞，拥塞窗口就再增大一些，但只要网络出现拥塞，拥塞窗口就减少一些。判断出现网络拥塞的依据：当出现丢包事件时，也就是要么出现超时事件，要么收到三个冗余ACK（一个正常的ACK＋三个冗余的ACK），发送方就认为发送方到接收方的路径上出现了拥塞的指示 发送方将拥塞窗口作为发送窗口，即swnd = cwnd
维护一个慢启动阈值ssthresh状态变量：
当cwnd &lt; ssthresh时，使用慢启动算法； 当cwnd &gt; ssthresh时，停止使用慢启动算法而改用拥塞避免算法；当cwnd = ssthresh时，即可使用慢启动算法，也可使用拥塞避免算法。 慢启动算法和拥塞避免算法都是TCP的拥塞控制算法，接下来对这几种算法进行介绍
1.慢启动
在tcp双方建立逻辑连接关系时， 拥塞窗口cwnd的值被设置为1，还需设置慢启动阈值ssthresh，因此发送方当前只能发送一个数据报文段（拥塞窗口cwnd的值是几，就能发送几个数据报文段），接收方收到该数据报文段后，给发送方回复一个确认报文段，发送方收到该确认报文后，将拥塞窗口的值变为2，并继续这样下去。因此，TCP发送速率起始慢，但在慢启动阶段以指数增长。
2.拥塞避免算法
当cwnd &gt; ssthresh时，进入拥塞避免阶段，此时的拥塞窗口缓慢增加，每经过一个往返时间RTT，就把拥塞窗口加1，而不是成倍增加。因此在拥塞避免阶段就有“加法增大”的特点，拥塞窗口按线性规律缓慢增长。
如下图：
红色这一部分就是拥塞避免算法，每次拥塞窗口仅仅增加一个大小，当增加到一定大小时，就碰到了网络超时，即出现网络拥塞。
出现阻塞后调整
当出现阻塞之后，会调整慢启动阈值ssthresh以及拥塞窗口的值：
新的慢开始门限的值：ssthresh=cwnd/2。
如上图所示，此时cwnd已经增长到了24大小，所以此时ssthresh=24/2=12。
拥塞窗口则再次变为1
调整后的运行过程如下图所示：
如上图所示，当在24出现阻塞后，将cwnd变为了1，将ssthresh变为了12
然后在12之前依旧是进行慢开始算法，在12之后进行拥塞避免算法，直到16发生了3个ACK情况（这个后面讲）又一次出现了网络阻塞。
快重传+快恢复
从上面可知，在16的时候又一次出现了拥塞，而这次拥塞出现的原因就是这3个ACK。这个也就是快重传。
快重传：当发生报文段丢失时，为了让发送方尽早知道发生了个别报文段的丢失，因此立即发送确认，怎样让发送方知道是哪个报文段丢失的方法就是连读发送三个确认。
如下图所示：
当丢失某个数据包时，连续发送三个确认，则发送方就知道某个包丢失了，然后立即启动快重传。
快恢复：发送方知道现在只是丢失了个别的报文段。于是不执行慢开始，而是执行快恢复算法。
新的慢开始门限的值：ssthresh=cwnd/2。
如上图所示，此时新的cwnd已经增长到了16大小，所以此时ssthresh=16/2=8。
拥塞窗口不是变为1，而是和门限值一样，此时cwnd=ssthresh=8，然后开始执行拥塞避免算法
如下图所示：
如上图是怎样判断出现了丢包现象，以及出现丢包情况下进行快恢复的流程。
注意：
无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢启动阈值设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢启动算法快速恢复是TCP推荐的而非必须的构件。一种称为 TC Tahoe 的TCP 早期版本，不管是发生超时指示的丢包事件，还是发生3个冗余 ACK 指示的丢包事件，都无条件地将其拥塞窗口减至 1个MSS，并进入慢启动阶段。TCP 的较新版本 TCP Reno , 则综合了快速恢复。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255d9e7d27ce85e58f98d674e9fccea2/" rel="bookmark">
			【Amis Low Code 结合FastAPI进行前端框架开发】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档
封装思想 直接复制官网json数据即可开发每个json中的接口由fastapi 转发（透传）使其开发模式与前端思维一致 基础组件 from amis import Page, Service, App from pydantic import BaseModel, Field from fastapi import FastAPI, Request, Response, APIRouter from starlette.responses import HTMLResponse class JsonRegister(BaseModel): page_json_url: str = "/demo.json" def __init__(self, **kwargs): super(JsonRegister, self).__init__(**kwargs) def register(self, router: APIRouter): router.add_api_route(self.page_json_url, endpoint=self.json) def json(self) -&gt; {}: """amis json格式数据""" return {} class HtmlRegister(BaseModel): page_url = "/" def __init__(self, **kwargs): super(HtmlRegister, self).__init__(**kwargs) def register(self, router: APIRouter): router.add_api_route(self.page_url, endpoint=self.html) def html(self): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/255d9e7d27ce85e58f98d674e9fccea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e9cbc4de94b7dd7e43661d461aae2f/" rel="bookmark">
			如何自动筛选高质量的指令微调数据喂给大模型？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大家都知道在大模型时代，数据有多么重要，质量多高都不过分！甚至直接决定着最终的效果。
尤其做SFT，模型框架基本不用改（事实上也改不动），如何做一份符合自己场景高质量的SFT数据成了唯一且核心的工作。
之前笔者已经写过几篇来强调数据的重要性以及业界如何自动做数据的文章，比较有参考性，感兴趣的小伙伴可以穿梭：
《大模型时代下数据的重要性》:https://zhuanlan.zhihu.com/p/639207933
《大模型SFT微调指令数据的生成》:https://zhuanlan.zhihu.com/p/650596719
《怎么更好的训练一个会数学推理的LLM大模型呢？》:https://zhuanlan.zhihu.com/p/656665345
今天再给大家带来三篇如何自动筛选高质量数据的文章以及穿插在中间的笔者自己的一些讨论。
总的来说这些paper都是做SFT数据比较有参考意义的，大家可以收藏反复琢磨研究进而抽象理论。
MoDS: Model-oriented Data Selection for Instruction Tuning 论文地址：https://arxiv.org/pdf/2311.15653.pdf
注意这篇文章的出发点是在给定一个LLM的前提下，如何筛选出适合当前给定这个LLM的高质量数据，也就是说高质量是和模型深度绑定的，这也是比较trick的做法。适合自己的才是最好的，对于不同的模型想要学好，可能需要的数据是不完全一样的。
（1）标准 为了更具体量化什么是“高质量”，作者归纳了下面三个方面：
（a）质量: 高质量的prompt以及对应的高质量response可以很好的让模型学会遵循指令。
（b）覆盖率: prompt的多样性，越多样性越好
（c）必要性: 同一条prompt对不同基座模型的重要度和必要性是不一样的，如果一条prompt对于基座来说已经很好的输出response了，也就是说模型已经很好的遵循prompt了，不需要再训练了，相反则是模型需要的。
其中必要性这里是非常重要的，这也是为啥有一个很强的基座只需要很少很少的SFT数据就行了，大部分都能cover，而一个比较差的基座模型对很多prompt都天然不理解，也就需要海量的SFT数据来弥补自身天然的缺陷。总的来说前期不努力，后期就要努力，前期努力了后期也就会省事很多。
（2）具体筛选做法 好了，言归正传，既然定义好了上面三个维度，下面作者就逐个针对性的进行筛选
（a）Quality Evaluation 这部分主要就是基于模型打分筛选出高质量的SFT数据，具体的作者使用的模型是OpenAssistant/reward-model-deberta-v3-large-v2
链接为https://huggingface.co/OpenAssistant/reward-model-deberta-v3-large-v2/tree/main
部分打分case如下：
分数越高认为质量越高，最终是会选取一个门限值作为过滤。最终过滤得到High-Quality Instruction Data
不过笔者认为想要一个好的打分模型是非常难的，类似PPO中的reward model, 纠结什么是好？一份高质量的训练reward model的数据本身也是一个难题，而且reward model本身也不应该太小，应该和待最终训练的SFT模型规模大小相等甚至更大才能保证是“老师”给“学生”打分，一个好的reward model也是LLM的核心壁垒，甚至笔者认为，如果有一个好的打分模型就有了LLM的半壁江山，可以用来做评估、筛选数据等等用处，现在大家基本还是用GPT4来打分。
如果想训练某一个垂直方向的reward model，还可以针对性的准备样本，因为什么是“好”比较明确定义比如安全、比如做对题。如果想做一个通用的reward model，这件事本身难度就非常高甚至目前就不可行，因为通用的“好”到底是什么本身就很难定义，太多标准和维度了，就算你定义了几个标准，把他认为是通用的了，甚至包含想了很多很多维度，但是终究还是不能包含全部，总会有遗漏，更不用说该这么具体落地准备样本了，比较难。
（b）Diverse Data Selection for Seed Instrucitons 经过上面过滤，可以得到一份高质量的SFT数据即High-Quality Instruction Data，本节的目的就是在这份高质量SFT数据集中继续过滤出一个子集，该子集的多样性要足够好，能表征整个数据集。
作者具体采用的手段就是k-Center Greedy算法
核心做法就是首先选一个初始点，然后每次迭代都选取离当前中心集合最远的点，最终得到一份Seed Instruction Data
（c） Augmented Data Selection 正如前面考虑的必要性，Seed Instruction Data中的每条prompt对模型来说不一定都是需要的，同样被Diverse Data Selection for Seed Instrucitons阶段过滤掉的样本也不一定是模型不需要的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3e9cbc4de94b7dd7e43661d461aae2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce95c480fdab36075bd4181d36c3d72/" rel="bookmark">
			计算机网络:自顶向下方法-第8版-Chapter5-Problems
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 P1P2P3P4P5P6P7abc P8P9P10P11abc P12P13P14abcd P15abc P16P17P18P19P20P21P22 P1 观察图5-3，列举从y到u不包含任何环路的路径。
随便写个搜索路径算法
#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 2e5+5; const int INF = 0x3f3f3f3f; std::vector&lt;int&gt; edges[N]; bool vis[N]; int fa[N]; void printPath(int u) { if (fa[u] == 0) { printf("%c", u); return; } printPath(fa[u]); printf(" -&gt; "); printf("%c", u); } int path; void dfs(int u, int dest) { if (u == dest) { printf("path %d: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ce95c480fdab36075bd4181d36c3d72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177167cb00bff5ccd8bd109f327cc8d1/" rel="bookmark">
			在imx6ull中加入ov5640模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来觉得是一件很简单的事情但是走了很多的弯路，记录一下调试过程。
先使用正点原子提供的出厂内核把摄像头影像调试出来，然后cat /dev/video1，看一下video1牵扯到哪些模块，可以看到需要ov5640_camera.ko和 mx6s_capture.ko这两个模块。 root@ATK-IMX6U:/mnt/mxc/subdev# cat /dev/video1
[ 234.765777] ------------[ cut here ]------------
[ 234.770851] WARNING: CPU: 0 PID: 1362 at drivers/media/v4l2-core/videobuf2-core.c:2822 __vb2_init_fileio+0x124/0x31c()
[ 234.783858] Modules linked in: ov5640_camera mx6s_capture icm20608(O)
[ 234.791720] CPU: 0 PID: 1362 Comm: cat Tainted: G W O 4.1.15 #1
[ 234.798753] Hardware name: Freescale i.MX6 Ultralite (Device Tree)
[ 234.805019] [&lt;80015dbc&gt;] (unwind_backtrace) from [&lt;80012748&gt;] (show_stack+0x10/0x14)
[ 234.812783] [&lt;80012748&gt;] (show_stack) from [&lt;8081e1ec&gt;] (dump_stack+0x84/0xc4)
[ 234.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/177167cb00bff5ccd8bd109f327cc8d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd5878e5b99b69ce4eb823501c3b254c/" rel="bookmark">
			Python 实现 CNN 卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 实现 CNN 卷积神经网络
cnn神经网络是指卷积神经网络，其核心思想是利用卷积层和池化层来提取输入数据的特征，并通过全连接层进行分类或回归等任务。
在 Python 中可以使用第三方库tensorflow和numpy搭配来实现卷积神经网络，使用tensorflow和numpy前需确保其已经安装。
如下是使用tensorflow和numpy实现卷积神经网络的具体步骤：
加载数据集。对数据进行归一化处理。创建神经网络模型模型对象，向其中依次添加卷积层、池化层、全连接层。编译模型：为模型配置优化器、损失函数和评估指标。调用fit方法进行模型训练。使用save方法将训练好的模型保存至本地。 如下是代码示例：
import tensorflow as tf import numpy as np def train_and_save_model(train_images,train_labels): # 数据归一化处理 train_images = train_images.reshape(train_images.shape[0], 28, 28, 1) train_images = train_images / 255.0 # 构建模型 model = tf.keras.models.Sequential() model.add(tf.keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1))) model.add(tf.keras.layers.MaxPooling2D((2, 2))) model.add(tf.keras.layers.Flatten()) model.add(tf.keras.layers.Dense(64, activation='relu')) model.add(tf.keras.layers.Dense(10, activation='softmax')) # 编译模型 model.compile(optimizer='adam', loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False), metrics=['accuracy']) # 训练模型 model.fit(train_images, train_labels, epochs=10) # 保存模型 model.save('demo_model.keras') # 加载数据集 train_images = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd5878e5b99b69ce4eb823501c3b254c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5c2abd1c36310bc633bd6d4cb789b9f/" rel="bookmark">
			电信、移动、联通家用光猫常用超级密码❗️❗️❗️
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电信、移动、联通家用光猫常用超级密码❗️❗️❗️
家用光猫🐱常用超级密码：
1⃣️电信：帐号:telecomadmin 密码:nE7jA%5m或admintelecom
2⃣️移动：帐号：CMCCAdmin 密码：aDm8H%MdA
3⃣️联通：帐号：CUAdmin 密码：CUAdmin，联通光猫管理员地址：网页链接
4⃣️其它设备
账号：root 密码：root
账号：admin 密码：admin
账号：fiberhomehg2x0 密码：hg2x0
账号：root 密码：Zte521
如果以上无效，再附一个方法：
先用普通账号useradmin登陆，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee5236947cf24c1ec6ea86f47b2cf583/" rel="bookmark">
			通过命令行输入参数控制激励
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1)在命令行的仿真参数（SIM_OPT）加上：“+var_a=100 +var_b=99”
2)在环境中调用：
$test$plusargs("var_a")；如果命令行存在这个字符，返回1，否则返回0；
$value$plusargs("var_a=%0d",tc_var_a)；就可以把命令行var_a的参数100提取出来到tc_var_a变量了
sv中$test$plusargs和$value$plusargs的用法小结（转载自博客园from nanoty）_sv $value$plusaegs-CSDN博客
$test$plusargs和$value$plusargs作为进行Verilog和SystemVerilog仿真运行时调用的系统函数，可以在仿真命令直接进行赋值，并且不局限于不同仿真器对于参数在仿真命令中定义格式不同的限制，也避免了调换参数带来的频繁编译等问题。
可以使用$test$plusargs和$value$plusargs进行解决，该函数的调用发生在仿真运行（run）阶段。这样仅需要对设计进行一次编译即可，如果需要改变相应的条件，可以在run的时候动态指定，这样有利于脚本处理进行回归的验证，同时也有利于object的动态construct。
————————————————
$test$plusargs 在运行（run）仿真时指定要选择的条件，即只需要在仿真运行命令（run-options）中指定参数需要选择的条件即可。当仿真运行时，$test$plusargs会在命令行中搜索指定的字符，若找到相应字符，在函数返回“1”，否则返回“0”。
$value$plusargs
$value$plusargs可以讲运行命令（run-options）中的参数值传递给指定的信号或者字符，其语法格式如下：
Integer=$value$plusargs(“string”,signalname);
其中string=”plusarg_format”+”format_string”,”plusarg_format”指定了用户定义的要进行传递的值，”format_string”指定了要传递的值的格式（类似$display中定义的%s、%h、etc.），并且string中”plusarg_format”和”format_string”格式应该为”plusarg_format”（=/+）”format_string”。如果转换后的位宽和传递的值不一致，则按照如下规则转换：
实例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5367367a9abb3cdcaddd1e503586684a/" rel="bookmark">
			BI技巧丨RowNumber应用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		白茶在之前的文章中，给大家介绍过Rank函数的应用场景，其实与Rank函数同时推出的还有RowNumber函数，二者之间有一些差异，但是总体应用的场景基本类似。
RowNumber函数基本语法
ROWNUMBER ( [&lt;relation&gt;][, &lt;orderBy&gt;][, &lt;blanks&gt;][, &lt;partitionBy&gt;][, &lt;matchBy&gt;] ) 参数介绍：
relation：可选项，排名依据的表或表表达式。
orderBy：可选项，排序依据，如果省略，第2参数需绑定。
blanks：可选项，处理空值排名位置使用。
partitionBy：可选项，分区定义，参照SQL的开窗分区即可。
matchby：可选项，定义匹配数据和标识当前行的列的语句。
PS：
从内部参数上我们不难发现，对比Rank函数，RowNumber就是缺少了一个ties参数。
其实，如果小伙伴们擅长SQL的话，就会明白，这两个开窗函数就是从SQL移植过来的，只不过语法上存在差异，而实际用途基本一致。
先来看看本期的案例数据：
案例数据共计3张表，产品表、分店表以及事实表，将其导入到PowerBI中，模型关系如下：
添加基础度量值：
销售金额：
001.SalesAmount = SUMX ( 'Fact_Sales', 'Fact_Sales'[Quantity] * RELATED ( Dim_Product[Price] ) ) 销售成本：
002.SalesCost = SUMX ( 'Fact_Sales', 'Fact_Sales'[Quantity] * RELATED ( Dim_Product[Cost] ) ) 销售利润：
003.SalesProfit = [001.SalesAmount] - [002.SalesCost] 销售单价：
001.Price = SUM ( 'Dim_Product'[Price] ) 销售单位成本：
002.Cost = SUM ( 'Dim_Product'[Cost] ) 到这里，我们的准备工作完成，我们来看看RowNumber函数的表现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5367367a9abb3cdcaddd1e503586684a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d7746bafa8c0368cc0332c79c0ffafd/" rel="bookmark">
			前端实用网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端查询网站 npm官网：https://www.npmjs.com/package/npm
MDN官网：https://developer.mozilla.org/zh-CN/
w3c在线教程：https://www.w3school.com.cn/
w3菜鸟教程：https://www.runoob.com/w3c/w3c-tutorial.html
JavaScript明星项目：https://risingstars.js.org/2020/zh
BootCDN：https://www.bootcdn.cn/
gitHub：https://github.com/
webPack中文网：https://www.webpackjs.com/
Vue生态圈 Vue2.0官网：https://cn.vuejs.org/
Vue3.0官网：https://v3.cn.vuejs.org/
Vue-element-admin：https://panjiachen.gitee.io/vue-element-admin-site/zh/
Vie官网：https://vitejs.cn/
React生态圈 React中文官方文档：https://reactjs.bootcss.com/
ReactNative官网：https://www.react-native.cn/docs/components-and-apis
Create React App脚手架：https://www.html.cn/create-react-app/docs/getting-started/
开源UI库 ElementUI：https://element.eleme.cn/#/zh-CN
VantUI：https://vant-contrib.gitee.io/vant/#/zh-CN/
Ant-designUI：https://ant.design/index-cn
安装开发环境 Nodejs官网：https://nodejs.org/en/
git官网：https://git-scm.com/
可视化git工具tortoise：https://tortoisegit.org/download/
可视化git工具sourcetree：https://www.sourcetreeapp.com/
postman测试：https://www.postman.com/downloads/
Xshell：https://51.ruyo.net/test/download_xshell_xftp.html
安装编辑器 Vscode：https://code.visualstudio.com/
HbuilderX：https://www.dcloud.io/
webstorm：https://www.jetbrains.com.cn/webstorm/
atom：https://atom.io/
框架 NodejsApi文档：http://nodejs.cn/api/
Typescript官网：https://www.tslang.cn/index.html
Express中文文档：https://www.expressjs.com.cn/
小程序 uniapp官方文档：https://uniapp.dcloud.io/
taro官方文档：https://taro.aotu.io/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de9d583e866098c4b24f0da1304d7915/" rel="bookmark">
			[Cisco Packet Tracer下载教程&amp;安装教程]Cisco Packet Tracer怎么设置成中文？3560-24PS为什么ip helper-address 192.168.8.3报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
PacketTracer5中3560-24PS为什么ip helper-address 192.168.8.3报错?
一、Cisco Packet Tracer 7.0的下载
二、Cisco Packet Tracer 7.0的安装教程
1.双击.exe后缀文件
2.点击Next &gt;
3. 选择I accept the agreement(我接受这个协议),点击Next &gt;
4.点击Browse(浏览),更换安装路径(尽量不要安装在C盘)，更换完了后点击Next &gt;
5.点击Next &gt;
6. 在Additional icons(其他图标):选择Create a desktop icon(创建桌面图标)和Create a Quick Launch icon(创建快速启动图标),点击Next &gt;
7.点击Install(安装)
8.点击Finish(完成)
三、Cisco Packet Tracer怎么设置成中文
1.在上面的百度网盘链接下载下来的压缩包中有中文包
2.在刚刚下载Cisco Packet Tracer的安装路径中找到languages(语言)，复制上面的Simplified Chinese.ptl文件，粘贴到该文件夹内
3.点击Options(选项)-&gt;Preferences(首选项)
4.选中 Simplified Chinese.ptl，点击Change Language(更改语言)
5.当出现以下弹出框时，点击OK
6.重启软件，可以看到Cisco Packet Tracer已经成功设置成中文了
PacketTracer5中3560-24PS为什么ip helper-address 192.168.8.3报错? 这是因为Packet Tracer 5中的Catalyst 3560-24PS交换机IOS版本不支持此命令，而 ip helper-address 命令通常在DHCP（动态主机配置协议）中使用。但是，在Packet Tracer 7.0及以后的版本中，可以正确地使用 ip helper-address 命令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de9d583e866098c4b24f0da1304d7915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/248b1992ed9bf02cd035e99dbfb0c5ac/" rel="bookmark">
			[ROS2] --- 通信接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 通信接口的定义 通信并不是一个人自言自语，而是两个甚至更多个人，你来我往的交流，交流的内容是什么呢？为了让大家都好理解，我们可以给传递的数据定义一个标准的结构，这就是通信接口。
ROS的通信系统，它的主要目的就是传输数据，那就得让大家高效的建立连接，并且准确包装和解析传输的数据内容，话题、服务等机制也就诞生了，他们传输的数据，都要符合通信接口的标准定义。
2 ROS通信接口 接口可以让程序之间的依赖降低，便于我们使用别人的代码，也方便别人使用我们的代码，这就是ROS的核心目标，减少重复造轮子。
ROS有三种常用的通信机制，分别是话题、服务、动作，通过每一种通信种定义的接口，各种节点才能有机的联系到一起。
2.1 ROS通信接口的三种形式 为了保证每一个节点可以使用不同语言编程，ROS将这些接口的设计做成了和语言无关的，比如这里看到的int32表示32位的整型数，int64表示64位的整型数，bool表示布尔值，还可以定义数组、结构体，这些定义在编译过程中，会自动生成对应到C++、Python等语言里的数据结构。
话题通信接口的定义使用的是.msg文件，由于是单向传输，只需要描述传输的每一帧数据是什么就行，比如在这个定义里，会传输两个32位的整型数，x、y，我们可以用来传输二维坐标的数值。
服务通信接口的定义使用的是.srv文件，包含请求和应答两部分定义，通过中间的“—”区分，比如之前我们学习的加法求和功能，请求数据是两个64位整型数a和b，应答是求和的结果sum。
动作是另外一种通信机制，用来描述机器人的一个运动过程，使用.action文件定义，比如我们让小海龟转90度，一边转一边周期反馈当前的状态，此时接口的定义分成了三个部分，分别是动作的目标，比如是开始运动，运动的结果，最终旋转的90度是否完成，还有一个周期反馈，比如每隔1s反馈一下当前转到第10度、20度还是30度了，让我们知道运动的进度。
2.2 ROS提供的标准接口 在ROS安装路径中的share文件夹中找到，涵盖众多标准定义，可以打开几个看看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3a0f5134c808ff4c3d4029a8a56d73/" rel="bookmark">
			[ROS2] --- param
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 param介绍 类似C++编程中的全局变量，可以便于在多个程序中共享某些数据，参数是ROS机器人系统中的全局字典，可以运行多个节点中共享数据。
全局字典
在ROS系统中，参数是以全局字典的形态存在的，什么叫字典？就像真实的字典一样，由名称和数值组成，也叫做键和值，合成键值。或者我们也可以理解为，就像编程中的参数一样，有一个参数名 ，然后跟一个等号，后边就是参数值了，在使用的时候，访问这个参数名即可。
可动态监控
在ROS2中，参数的特性非常丰富，比如某一个节点共享了一个参数，其他节点都可以访问，如果某一个节点对参数进行了修改，其他节点也有办法立刻知道，从而获取最新的数值。这在参数的高级编程中，大家都可能会用到。
2 param编码示例 这里创建功能包名为，learning05_param
2.1 parameter.cpp /** * @file parameters.cpp * * @brief A node to declare and get parameters * Here the parameters are the message data for two publisher * It's possible to change them at run time using the commad line * "ros2 param set /set_parameter_node vehicle_speed 100" * "ros2 param set /set_parameter_node vehicle_type car" * or using a launch file * * @author Antonio Mauro Galiano * Contact: https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab3a0f5134c808ff4c3d4029a8a56d73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e86faeaec8a4acabd803af7c42d19c7/" rel="bookmark">
			[ROS2] --- action
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 action介绍 ROS通信机制也会被常常用到——那就是动作。从这个名字上就可以很好理解这个概念的含义，这种通信机制的目的就是便于对机器人某一完整行为的流程进行管理。
1.1 客户端/服务器模型 动作和服务类似，使用的也是客户端和服务器模型，客户端发送动作的目标，想让机器人干什么，服务器端执行动作过程， 控制机器人达到运动的目标，同时周期反馈动作执行过程中的状态。
客户端发送一个运动的目标，想让机器人动起来，服务器端收到之后，就开始控制机器人运动，一边运动，一边反馈当前的状态，如果是一个导航动作，这个反馈可能是当前所处的坐标，如果是机械臂抓取，这个反馈可能又是机械臂的实时姿态。当运动执行结束后，服务器再反馈一个动作结束的信息。整个通信过程就此结束。
1.2 action通信特点 一对多通信
和服务一样，动作通信中的客户端可以有多个，大家都可以发送运动命令，但是服务器端只能有一个，毕竟只有一个机器人，先执行完成一个动作，才能执行下一个动作。
同步通信
既然有反馈，那动作也是一种同步通信机制，之前我们也介绍过，动作过程中的数据通信接口，使用.action文件进行定义。
由服务和话题合成
大家再仔细看下上边的动图，是不是还会发现一个隐藏的秘密。
动作的三个通信模块，竟然有两个是服务，一个是话题，当客户端发送运动目标时，使用的是服务的请求调用，服务器端也会反馈一个应带，表示收到命令。动作的反馈过程，其实就是一个话题的周期发布，服务器端是发布者，客户端是订阅者。
没错，动作是一种应用层的通信机制，其底层就是基于话题和服务来实现的。
2 action自定义通信接口 延续上一讲[ROS2] — action，中创建的自定义接口功能包，在src目录下创建action/Concatenate.action文件
Concatenate.action
int16 num_concatenations --- string final_concatenation --- string partial_concatenation 3 action编码示例 这里创建功能包名为，learning04_action
3.1 class_action_client.cpp /** * @file class_action_client.cpp * * @brief A class defined ROS2 action client node that sends as goal the number of string * concatenation the action server should perform. * The server will send back feedbacks and the final result * * @author Antonio Mauro Galiano * Contact: https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e86faeaec8a4acabd803af7c42d19c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae10c4aeaa0c91ffe443f4780b5c2c0c/" rel="bookmark">
			Qt Creator设置IDE的字体、颜色、主题样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt是一款开源的、跨平台的C++开发框架，支持Windows、Linux、Mac系统，从1995发布第一版以来，发展迅猛，最开始是用于Nokia手机的Symbian(塞班)系统和应用程序开发，现在是用于嵌入式软件、桌面软件(比如WPS、VirtualBox)、Android软件等开发，到2023年12月，其最新的版本已经更新到了v6.6。
而Qt Creator是Qt的开源实现IDE，现在已经集成到了Qt.exe里，Qt Creator默认的颜色是白色，字体是跟随系统字体。它原来的白色太刺眼，系统字体对于编程有点古板。这里介绍Qt Creator的字体、颜色、主题样式设置，以Qt 5.14.2为例进行说明。
1 下载并安装微软雅黑字体 1.1 下载微软雅黑字体 微软雅黑字体，分为Microsoft YaHei mono字体、Microsoft YaHei字体，即一个带mono，另一个不带mono。推荐使用带mono的，它字体等宽，颜色也好看。
Microsoft YaHei mono字体地址： https://pan.baidu.com/s/1nG3m_plcfnrbNgksnep5_Q 提取码：in9h
下载之后，将其解压，得到MSYHMONO.ttf文件，右击MSYHMONO.ttf文件 --》再点击"为所有用户"安装即可，如图(1)所示：
图(1) 安装微软雅黑mono字体 1.2 启用Microsoft YaHei mono字体 点击QtCreator菜单栏上的[工具] --&gt; 选项 --》
文本编辑器 --》字体 --》选中 Microsoft YaHei mono --》Apply
图(2) 点击Qt Creator工具栏上的[工具]--&gt;选项 图(3) 在[文本编辑器] --》字体和颜色 --》选中"Microsoft YaHei Mono" 2 配置字体和颜色文件 2.1 编写vscode.xml vscode.xml是一个仿造vscode软件经典黑色的配置文件，代码区和工具栏，都是亮酷的黑色，如图(1)所示：
图(3) vscode的字体样式 在D:\Qt\Qt5.14.2\Tools\QtCreator\share\qtcreator\styles目录，新建一个vscode.xml文件，将如下内容拷贝到vscode.xml;
//D:\Qt\Qt5.14.2\Tools\QtCreator\share\qtcreator\styles\vscode.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;style-scheme version="1.0" name="VSCode"&gt; &lt;style name="Text" foreground="#9cdcfe" italic="false" background="#282c34"/&gt; &lt;style name="Link" /&gt; &lt;style name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae10c4aeaa0c91ffe443f4780b5c2c0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d111d58044769ffacc0658ae25d9c4/" rel="bookmark">
			QtScrcpy如何免费电脑反向控制手机（华为）？刚开始无法控制，后来终于解决了，分享给大家
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何下载QtScrcpy软件和使用方法，可以查阅历史文章：
QtScrcpy如何免费电脑反向控制手机（红米）？刚开始无法控制，后来终于解决了，分享给大家 刚开始还是按照红米手机的操作方法，发现不太行，看来华为有自己的逻辑，整理出来分享给需要的小伙伴
对于想开启华为开发者选项的朋友，以下步骤仅供参考，但请注意，开启开发者选项可能会对设备产生一些潜在的风险，因此请在操作前备份好个人数据。默认各位都是老手，风险自己承担爱哈
按照如下步骤：
设置 → 关于手机 → 连续点击七次“系统版本号”后，会弹出“开发者选项已启用”的提示 → 返回“设置”主界面，找到“系统和更新”选项并点击 → 开发者选项 → 打开USB调试+USB设置选择RNDIS（USB以太网） ，具体见下图 作者简介：
我是老高，91年，河南南阳人， 目前位于深圳。
华北水利水电大学本科，深圳大学硕士，主业医疗器械工程师，副业是牵线做媒的月老，喜爱中国传统文化（儒释道），践行《了凡四训》，但行好事莫问前程~
🙏曾因单身无助，2019.08.08创建友心人·本硕博平台，立足深圳，服务全国，开启单身自救之路。经过几年努力，终于2022.04.13自救成功结婚。有感于当下青年脱单困难及婚恋交友平台过于商业化现状，发愿做一个与众不同友爱利他有温度有情怀的本硕博单身自救平台，重友情，轻商业，做婚恋交友领域一股暖暖清流~期待与我们志同道合的小伙伴一起加入我们
如果你单身想一起兼职创业或者有什么QtScrcpy疑问，可以扫码关注我们的单身交友公众号，可以联系到我，感恩遇见~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/973ce0413d2ec52750567fe381c66f1d/" rel="bookmark">
			【微服务】springboot整合quartz使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是springboot
二、什么是定时任务
三、什么是quartz
四、springboot如何整合quartz
一、什么是springboot Spring Boot 是一个开源的框架，它简化了基于Java的应用程序的开发过程。它是基于Spring框架的，但是相比传统的Spring应用，Spring Boot 提供了更加简洁和快速的开发方式。
Spring Boot 提供了自动配置的能力，它会根据项目的依赖和配置文件的设置，自动配置项目的各种组件、库和功能。这意味着开发者可以更加专注于业务逻辑的实现，而不需要手动配置繁琐的代码。
Spring Boot 还带来了内嵌的服务器（如Tomcat、Jetty等），这意味着你可以将应用程序打包成一个可执行的JAR文件，并且直接运行，无需额外部署到外部容器。
此外，Spring Boot 还提供了丰富的功能和扩展，如数据访问、消息队列、安全性、测试等等，开发者可以通过简单的配置来使用这些功能。
总之，Spring Boot 是一个简化了Java应用程序开发的框架，它提供了自动配置、内嵌服务器和丰富的功能扩展，让开发者更加便捷地开发高效的应用程序。
二、什么是定时任务 定时任务是指在预定的时间间隔或指定的时间点执行的任务或操作。在软件开发中，定时任务通常用于执行一些需要按照固定时间规则执行的操作，例如数据备份、定期报表生成、数据清理等。
定时任务可以周期性地执行，比如每天、每小时、每分钟执行一次，也可以指定具体的时间点执行，比如每天凌晨3点执行。
定时任务可以用于自动化处理一些重复性的工作，减轻人工操作的负担，提高工作效率。在Java开发中，常用的定时任务框架包括Quartz、Spring Task等。这些框架提供了灵活的配置和管理定时任务的功能，可以根据需求设置定时任务的触发规则、任务执行逻辑等。
总之，定时任务是指按照预定的时间间隔或时间点执行的任务，可以用于自动化处理一些重复性的工作，提高工作效率。
三、什么是quartz Quartz是一个流行的开源的Java定时任务调度框架。它提供了强大的灵活性和可靠性，用于调度和执行各种类型的任务。Quartz可以用于管理和执行定时任务，如定期备份数据、生成报表、发送邮件、调度定时任务等。
Quartz框架的核心组件是调度器（Scheduler），它负责管理和执行任务。任务由Job定义，每个Job都有一个执行逻辑。Quartz支持多种触发器（Trigger）类型，可以按照特定的时间规则或条件来触发任务的执行。触发器可以设置任务的执行频率、时间点、间隔等。
Quartz提供了灵活的配置选项，可以通过配置文件或编程方式来定义定时任务的触发规则、任务的执行逻辑、任务间的依赖关系等。同时，Quartz还具有分布式和集群的支持，可以在多个节点上进行任务调度和执行，提供高可用性和容错性。
总之，Quartz是一个功能强大的Java定时任务调度框架，能够灵活地管理和执行各种类型的任务，提供了触发器、调度器和任务定义等核心组件，支持灵活的配置选项和分布式集群部署。
四、springboot如何整合quartz 在Spring Boot中整合Quartz可以通过以下步骤来完成：
添加依赖：在pom.xml文件中添加Quartz的依赖。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt; 创建Quartz配置类：创建一个继承自SchedulerFactoryBean的配置类，并通过注解@Configuration进行标记。
@Configuration public class QuartzConfig extends SchedulerFactoryBean { // 配置Quartz的相关属性和JobFactory等 // ... } 创建Job类：创建一个实现Job接口的任务类，并实现execute方法，该方法定义了任务的具体执行逻辑。
public class MyJob implements Job { @Override public void execute(JobExecutionContext context) throws JobExecutionException { // 执行任务的具体逻辑 // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/973ce0413d2ec52750567fe381c66f1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c28fc54a417f624457a4806d70346c4/" rel="bookmark">
			Clion自定义管理和配置软件构建过程的工具(代替CMake)构建程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在公司由于需要x86环境和其他arm环境，同时需要使用公司自定义的mine_x86或者mine_orin对代码进行编译。 编译命令如下mine_x86 build -Dlocal=1 -j8,为使用Clion对程序进行调试，需要对程序进行设置。方便调试代码时能够断点查看变量。尝试了很多次，终于能够通过build按钮完成对代码的构建。
首先上编译完成的截图。
1. 首先点击Clion右上角的三个点,然后选择Edit 2. 然后点击+，并且选择Custom Build Application 3. 根据图片的内容进行填写 4. 点击上图中的Configure Custom Build Targets 5. 自定义ToolChain 6. 点击Custom Build Targets，然后在ToolChain选择System,然后点击三个点。 7. 最后重要的内容用绿色字体填写 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfa4b032eac54bd5b324830e94de7f47/" rel="bookmark">
			CSS——标准流、浮动、Flex布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、标准流 标准流也叫文档流，指的是标签在页面中默认的排布规则，例如：块元素独占一行，行内元素可以一行显示多个。
2、浮动 作用：让块元素水平排列
属性名：float
属性值：
left：左对齐right：右对齐 2.1 浮动-产品布局 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * { margin: 0; padding: 0; } li { list-style: none; } .product { margin: 50px auto; width: 1226px; height: 628px; background-color: pink; } .left { float:left; width: 234px; height: 628px; background-color: skyblue; } .right { float: right; width: 978px; height: 628px; background-color: brown; } .right li { float: left; margin-right: 14px; margin-bottom: 14px; width: 234px; height: 300px; background-color: orange; } /* 第四个li和第八个li 去掉右侧的margin */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfa4b032eac54bd5b324830e94de7f47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/676c1362fbc98bf7b515be9b19eb33fb/" rel="bookmark">
			YOLOv7 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、YOLOv7贡献和改进二、YOLOv7核心概念三、YOLOv7架构改进总结 前言 在深度学习和计算机视觉领域，目标检测一直是一个极具挑战性和实用性的研究领域。特别是在实时目标检测方面，准确率和速度之间的平衡成为了关键考量因素。YOLO（You Only Look Once）系列作为其中的佼佼者，以其快速且高效的特点在学术和工业界都产生了深远影响。YOLOv7在继承前代版本优势的基础上，进一步推动了目标检测技术的边界。本文旨在深入探讨YOLOv7的主要贡献、核心概念以及其架构上的重要改进，以提供对这一先进技术更全面的理解和洞见。
一、YOLOv7贡献和改进 YOLOv7的主要贡献和改进包括以下几个方面：
设计可训练的增益方法（Trainable Bag-of-Freebies）：这些方法使得实时目标检测在不增加推理成本的情况下，显著提高了检测准确率。
解决目标检测方法演进中的新问题：识别并解决了两个新问题，即重参数化模块如何替换原始模块，以及动态标签分配策略如何处理不同输出层的分配。为这些问题提出了相应的解决方案。
提出“扩展”和“复合缩放”方法（Extend and Compound Scaling）：这些方法能够有效地利用参数和计算资源。
提出的方法能有效减少参数和计算量：与当前最先进的实时目标检测器相比，提出的方法大幅减少了参数和计算量，同时具有更快的推理速度和更高的检测准确性。
二、YOLOv7核心概念 YOLOv7中的核心概念包括以下几个方面：
实时目标检测器的关键特性：
更快更强的网络架构：实时目标检测器要求拥有高效的网络架构。更有效的特征融合方法：为了提高检测的准确性和效率，有效的特征融合技术是必不可少的。更精确的检测方法：采用先进的检测算法，以提高检测的准确度。更鲁棒的损失函数：使用能够更好地优化模型性能的损失函数。更高效的标签分配方法：这关乎如何将标签准确地分配给不同的对象，以提高检测效率。更有效的训练方法：采用高效的训练策略以提高模型训练的效率和效果。 重参数化模块：YOLOv7开发了新的重参数化模块，并为不同的架构设计了相关应用策略。这些模块可以完美地适用于不同的架构，提高模型的灵活性和适应性。
模型缩放（Model Scaling）：模型缩放是一种方法，用于将已设计的模型按比例放大或缩小，以适应不同的计算设备。通常使用不同的缩放因子，如分辨率（输入图像的大小）、深度（层数）、宽度（通道数）和阶段（特征金字塔的数量），以实现网络参数、计算量、推理速度和准确性之间的良好平衡。网络架构搜索（NAS）是一种常用的模型缩放方法，可自动在搜索空间中寻找合适的缩放因子，而无需定义过于复杂的规则。但NAS的缺点是需要非常昂贵的计算来完成模型缩放因子的搜索。
缩放因子与参数和操作的关系：研究人员分析了缩放因子与参数量和操作量之间的关系，尝试直接估计一些规则，从而获得模型缩放所需的缩放因子。文献中几乎所有的模型缩放方法都独立地分析每个缩放因子，即使是复合缩放类别的方法也是独立优化缩放因子。
三、YOLOv7架构改进 YOLOv7在架构上的改进主要体现在以下方面：
模型缩放（Model Scaling）：
模型缩放是用于扩大或缩小已设计模型的方法，使其适应不同的计算设备。缩放方法通常使用不同的缩放因素，如分辨率（输入图像的大小）、深度（层数）、宽度（通道数）和阶段（特征金字塔的数量），以实现网络参数、计算量、推理速度和准确性之间的良好平衡。网络架构搜索（NAS）是一种常用的模型缩放方法，它可以自动从搜索空间中找到合适的缩放因素，而不需要定义过于复杂的规则。NAS的缺点是需要非常昂贵的计算资源来完成模型缩放因素的搜索。 分析缩放因素与参数及操作量的关系：
研究者尝试直接估计一些规则，从而获得模型缩放所需的缩放因素。文献回顾显示，几乎所有的模型缩放方法都是独立地分析单个缩放因素，即使是复合缩放类别的方法也是独立优化缩放因素的。 针对连接型模型的新复合缩放方法：
观察到所有基于连接的模型（如DenseNet或VoVNet）在缩放深度时会改变某些层的输入宽度。由于YOLOv7的架构是基于连接的，因此需要设计一种新的复合缩放方法。 这些架构上的改进强调了在不牺牲性能的前提下，如何优化模型以适应不同计算环境的重要性。
总结 通过引入可训练的增益方法、解决目标检测方法演进中的新问题、以及提出“扩展”和“复合缩放”方法，YOLOv7实现了在保持高检测准确性的同时，有效减少模型的参数和计算量。其核心概念和架构上的改进，如模型缩放和针对连接型模型的新复合缩放方法，进一步强化了模型的适应性和效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec3b2fd24adb2b2056337e6587308e8b/" rel="bookmark">
			分享最简单注册GPT，采用API分发通道模型端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一波最容易，最简单的注册GPT-3.5和4.0账号KEY为主，主要针对拥有GPT-API系统的用户选择，不限制任何区域的云服务器搭建部署使用转发API通道，即可享受与海外官方同样的服务畅联。
1.第一步：先注册中转镜像平台的KEY密钥（www.xinyueai.top) 2.第二步：兑换卡密序列号，激活账号额度，额度最低为5美金，最高为1000美金，新用户注册默认赠送1-5美金测试额度。
3.第三步：将KEY密钥信息，配置令牌，写入自营GPT后台配置相关数据参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fb35380b60c5a2028c98119886b9a6d/" rel="bookmark">
			Spring MVC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Spring MVC 是什么什么是 MVC如何学习 Spring MVCSpring MVC 创建和连接获取参数传统方式简便的方式获取一个自定义类的对象从 json 字符串获取对象获取文件获取 Cookie/Session/Header参数重命名非必传参数获取url路径中的参数 请求转发和请求重定向 Spring MVC 是什么 Spring MVC 全称 Spring Web MVC，又称为 Spring Web
Spring MVC 是一个 Web 框架Spring MVC 是基于 Servlet API 构建的 什么是 MVC “MVC” 代表模型-视图-控制器（Model-View-Controller）。这是一种设计模式，用于构建具有良好组织结构的应用程序，以便更好地管理代码和提高可维护性。
Model 代表应用程序中处理数据和业务逻辑的部分。在Spring MVC中，模型通常由Java对象组成，这些对象负责封装和处理数据，以及执行与应用程序相关的业务逻辑。View 负责渲染和显示模型的数据。在Web应用中，视图通常是用户界面的一部分，负责将模型的数据以用户友好的方式呈现出来。视图不处理业务逻辑，它只关注如何正确地显示数据。Controller 是模型和视图之间的中介，负责接收用户的输入，处理用户请求，并更新模型和视图。它将用户的请求路由到适当的模型处理程序，然后将模型的数据传递给适当的视图进行显示。控制器的目标是保持模型和视图之间的解耦，使应用程序更加灵活和易于扩展。 如何学习 Spring MVC 学习 Spring MVC 最关注以下 3 个功能：
连接：将用户（浏览器）和 Java 程序连接起来，也就是访问一个地址能够调用到我们的 Spring 程序。获取参数：用户访问的时候会带一些参数，在程序中要想办法获取到参数输出数据：执行业务逻辑之后，把程序执行的结果返回给用户 Spring MVC 创建和连接 在创建 Spring Boot 项目的时候，我们已经引入了 Spring Web 依赖，引入这个依赖，我们的项目就是一个 Spring MVC 项目。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fb35380b60c5a2028c98119886b9a6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d762bf08cb01782993fb1fa5cc2eebb/" rel="bookmark">
			uniapp如何监听页面滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在UniApp中，你可以使用页面生命周期函数和组件的事件监听来监听页面滚动。下面是两种常用方法：
使用页面生命周期函数： 在你的页面中，可以使用onPageScroll生命周期函数来监听页面滚动事件。当页面滚动时，该函数会被触发，你可以在其中编写相应的逻辑。 示例代码：
export default { onPageScroll(e) { // e.scrollTop 表示当前页面滚动的距离 console.log('页面滚动距离：', e.scrollTop); // 在这里编写你的滚动相关逻辑 } } 2.使用组件的事件监听： 如果你的页面中包含有滚动的组件（例如scroll-view），你可以使用组件的事件监听来监听页面滚动事件。具体的事件名称和使用方法可以参考对应组件的官方文档。
示例代码：
&lt;template&gt; &lt;scroll-view @scroll="onScroll"&gt; &lt;!-- 页面内容 --&gt; &lt;/scroll-view&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { onScroll(e) { // e.detail.scrollTop 表示当前滚动距离 console.log('页面滚动距离：', e.detail.scrollTop); // 在这里编写你的滚动相关逻辑 } } } &lt;/script&gt; 以上是两种常用的监听页面滚动的方法，请根据你的具体需求选择适合的方式进行实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa7343dbb89a4b746a38e5b925993f1/" rel="bookmark">
			Linux自动备份配置文件、日志文件脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux自动备份配置文件、日志文件脚本 1. 脚本功能 日常开发中会有很多场景需要我们去备份系统的配置文件、日志数据、更新包等等，本脚本可以定时备份linux的某个文件夹。自动删除X天前的备份数据，灰常的好用。
2. 脚本内容 #!/bin/bash # auth Eric source /etc/profile # 要备份的文件夹 source_directory="/etc" # 备份到的目标文件夹 backup_directory="/home/backup/system/etc_$(date +%Y%m%d)" # 创建备份目录（如果不存在） mkdir -p "$backup_directory" # 执行备份命令 cp -r $source_directory $backup_directory #删除7天前数据 find $backup_directory -name "etc_*" -mtime +180 -exec rm -rf {} \; 3. 使用方法 新建backuplog.sh文件填入【脚本内容】设置自己的备份文件夹和目标文件夹，调整删除天数执行backuplog.sh查看目标文件夹是否有要备份的文件 4. 定时执行 通过linux自带的corntab来实现脚本的定时备份
这里我们定义每天0点备份一次日志
crontab e 添加一行命令
0 0 * * * sh /home/Shell/backuplog.sh crontab更多使用方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cecd0cf36f568c2bb82f3816350c1ed/" rel="bookmark">
			Mysql自动备份脚本（本地备份、远程备份、删除冗余备份）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql自动备份脚本（本地备份、远程备份、删除冗余备份） 1. 脚本功能 自动备份mysql数据到服务器上，可以通过linux的 crontab定义备份周期。
自动删除七天前的备份数据。
2. 脚本内容 #!/bin/bash # auth Eric source /etc/profile # 设置备份目录和文件名 backup_directory="/usr/local/data" backup_filename="test_$(date +%Y%m%d).sql" # 设置MySQL连接参数 mysql_host="数据库IP" mysql_user="数据库用户名" mysql_password="数据库密码" mysql_database="数据库名称" # 创建备份目录（如果不存在） mkdir -p "$backup_directory" # 执行备份命令 mysqldump -h "$mysql_host" -u "$mysql_user" -p"$mysql_password" "$mysql_database" &gt; "$backup_directory/$backup_filename" #删除7天前数据 find $backup_directory -name "test_*.sql" -mtime +7 -exec rm {} \; # 检查备份是否成功 if [ $? -eq 0 ]; then echo "MySQL数据库备份成功：$backup_directory/$backup_filename" else echo "MySQL数据库备份失败" fi 3. 如何使用 新建backupmysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cecd0cf36f568c2bb82f3816350c1ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74e8f45867cfde5359a55e441925a9e8/" rel="bookmark">
			Internal server error: No known conditions for “./lib/locale/lang/zh-cn“ specifier in “element-plus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个报错产生的原因是：
el-date-picker默认是英文显示，我要设置成用中文显示 在使用以下方法后报错：
&lt;template&gt; &lt;el-config-provider :locale="locale"&gt; &lt;el-date-picker size="large" v-model="dateValue" type="daterange" range-separator="至" start-placeholder="开始日期" end-placeholder="结束日期" format="yyyy-MM-dd " value-format="yyyy-MM-dd" @change="customDate" &gt; &lt;/el-date-picker&gt; &lt;/el-config-provider&gt; &lt;/template&gt; &lt;script setup&gt; import { ElConfigProvider } from 'element-plus'; import locale from 'element-plus/lib/locale/lang/zh-cn'; &lt;/script&gt; 解决方案
将以下代码：
import localeZH from 'element-plus/lib/locale/lang/zh-cn'
替换为：
import localeZH from 'element-plus/es/locale/lang/zh-cn' 就解决了
但是，我用的是vue3，加了这个格式之后取到的日期值居然是：yyyy-12-Fr 00:00:00
后面终于让我查找到了解决方案 ：Vue3这个时间格式年月日都要大写！！！改成如下写法 format="YYYY-MM-DD hh:mm:ss"
value-format="YYYY-MM-DD hh:mm:ss"
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/58/">«</a>
	<span class="pagination__item pagination__item--current">59/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/60/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>