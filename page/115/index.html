<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5290379a638d7bd29508fad2a6c8d435/" rel="bookmark">
			123 张图详解 177 个计算机网络名词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天跟大家一起学习计算机网络名词
网络基础
1、电路交换：在通信开始前，通信双方要在网络上建立专属信道来发送数据，信道至少会持续到通信结束才会断开。
2、包交换：又叫做分组交换，是将数据分为多个消息块（即数据包），再通过网络对每个数据块进行单独传输选路。
3、网络协议：为在网络中传输数据而对数据定义的一系列标准或规则。
4、协议栈：网络协议的具体定义或具体实现。
5、万维网（ WWW ）：可以通过 URL 地址进行定义、通过 HTTP/HTTPS 协议建立连接、通过互联网进行访问的网页资源空间。
6、局域网（ LAN ）：在一个有限区域内实现终端设备互联的网络。
7、城域网（ MAN ）：规模大于局域网，覆盖区域小到一个方圆数千米的大型园区，大到一个城市圈的网络。
8、广域网（ WAN ）：跨越大范围地理区域建立连接的网络。
9、互联网（ Internet ）：通过各种互联网协议为全世界成千上万的设备建立互联的全球计算机网络系统。
10、物联网（ IoT ）：通过内置电子芯片的方式，将各种物理设备连接到网络中，实现多元设备间信息交互的网络。
11、云计算（ Cloud Computing ）：通过互联网为计算机和其它设备提供处理资源共享的网络。
12、大数据（ Big Data ）：通过汇总的计算资源对庞大的数据量进行分析，得出更加准确的预测结论，并用来指导实践。
13、SDN ：指控制平面和数据平面分离，并通过提升网络编程能能力，使网络管理方式更优。
14、数据平面/转发平面：指网络设备中与判断如何转发数据和执行数据转发相关的部分。
15、控制平面：指网络设备中与控制设备完成转发工作的相关部分。
操作系统
1、操作系统：一种安装在智能设备上，为操作智能设备消除硬件差异，并为程序提供可移植性的软件平台。
2、图形用户界面（ GUI ）：指用户在大部分情况下可以通过点击图标等可视化图形来完成设备操作的软件界面。
3、命令行界面（ CLI ）：指用户需要通过输入文本命令来完成设备操作的软件界面。
4、RAM ：随机存取存储器的简称，也叫做内存。安装在数通设备上与安装在计算机中的作用相同，即用于存储临时文件，断电内容消失。
5、Flash ：安装在数通设备上，与计算机硬盘的功能类似，用来存放包括操作系统在内的大量文件。
6、NVRAM ：非易失随机存取存储器的简称。用来保存数通设备的启动配置文件，断电不会消失。
7、Console 接口：即控制台接口，通过 Console 线缆连接自己的终端和数通设备的 Console 接口，使用终端模拟软件对数通设备进行本地管理访问。
网络协议
1、OSI 模型：为规范和定义通信网络，将通信功能按照逻辑分为不同功能层级的概念模型，分为 7 层。
2、TCP/IP 模型：也叫做互联网协议栈，是目前互联网所使用的通信模型，由 TCP 协议和 IP 协议的规范发展而来，分为 4 层。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5290379a638d7bd29508fad2a6c8d435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56b0b86ea4b035f254d15835e8abc6e4/" rel="bookmark">
			多种方法在ubuntu系统上查看ip地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
https://www.howtouseubuntu.com/network/ubuntu-command-terminal-find-ip-address-in-ubuntu/
当使用命令行在Ubuntu系统上获取IP地址时，以下是几个示例：
使用ip命令获取IP地址：
$ ip addr show 示例输出：
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 inet 192.168.1.10/24 brd 192.168.1.255 scope global dynamic eth0 valid_lft 86400sec preferred_lft 86400sec 在上述示例中，eth0接口的IP地址是192.168.1.10。
使用ifconfig命令获取IP地址：
$ ifconfig 示例输出：
eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.1.10 netmask 255.255.255.0 broadcast 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56b0b86ea4b035f254d15835e8abc6e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/280efddf96cc01a1c52323bc1c00a412/" rel="bookmark">
			Ubuntu16.04安装docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu16.04安装docker及图形化界面工具安装 前提条件是Ubuntu联网可以访问外网。
1、在 Ubuntu 16.04 上安装 Docker，需要准备以下安装包：
apt-transport-https：用于支持通过 HTTPS 协议访问 APT 软件包库。
sudo apt-get update
sudo apt-get install apt-transport-https ca-certificates curl software-properties-common
2、Docker GPG 密钥：用于验证下载的 Docker 软件包的完整性。
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
3、添加 Docker APT 软件包源：
echo “deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu xenial stable” | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null
4、更新软件包列表，然后安装docker
sudo apt-get update
sudo apt-get install docker-ce
5、查看安装后的版本
sudo docker version
docker安装完之后，默认情况下是没有图形化界面的，因为 Docker 是一个命令行工具，主要用于在终端中管理和操作容器。
你可以使用其他工具来管理和监控 Docker 容器，其中一种常用的图形化界面工具是 Portainer。下面是使用 Portainer 进行图形化管理的步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/280efddf96cc01a1c52323bc1c00a412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8194b4629827918148f1a23b8d764331/" rel="bookmark">
			JavaScript合并数组的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在JavaScript编程中，经常需要将不同数组合并为一个数组，以便于进行数据处理和展示。在本文中，我们将介绍JavaScript中常用的几种合并数组的方法。
JavaScript合并数组的方法
concat()方法 concat()方法是JavaScript中用于合并数组的最基本方法之一。该方法可以将多个数组合并为一个新数组，并返回合并后的新数组。concat()方法不会改变原有数组，而是返回一个新的数组。
示例代码：
var array1 = [1, 2, 3]; var array2 = [4, 5, 6]; var newArray = array1.concat(array2); console.log(newArray); // [1, 2, 3, 4, 5, 6] push()方法 push()方法是将一个或多个元素添加到数组末尾的方法，也可以用于将一个数组添加到另一个数组的末尾。该方法会改变原有数组，返回值是新数组的长度。
示例代码：
var array1 = [1, 2, 3]; var array2 = [4, 5, 6]; Array.prototype.push.apply(array1, array2); console.log(array1); // [1, 2, 3, 4, 5, 6] splice()方法 splice()方法可以用于删除原数组的元素，并可以在指定的位置添加新的元素。该方法会改变原有数组，返回值是被删除元素的数组。
示例代码：
var array1 = [1, 2, 3]; var array2 = [4, 5, 6]; Array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8194b4629827918148f1a23b8d764331/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/810c8b1ec961f0851da8ea8c7c04a96c/" rel="bookmark">
			4.GIT中的diff命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 常用命令`git diff``git diff filename``git diff branch_name``git diff --staged (or --cached) path/to/file``git diff HEAD``git diff commit_id1 commit_id2` 使用`git diff`创建和使用`Git Patch`补丁创将`Git Patch`补丁`git apply GIT_PATCH.patch`reference 欢迎访问个人网络日志🌹🌹知行空间🌹🌹
常用命令 git diff git diff命令用来输出git仓库两个文件，两个分支或者两个commmit id等之间文件的差异。
直接使用git diff命令，将会输出本地还没有add/stage到仓库中的所有文件修改。
diff --git a/CMakeLists.txt b/CMakeLists.txt index e93e7aa..1744a58 100644 --- a/CMakeLists.txt +++ b/CMakeLists.txt @@ -21,5 +21,6 @@ include_directories(${CMAKE_SOURCE_DIR}/test/inc) include_directories(${CMAKE_SOURCE_DIR}/Zoo/inc) include_directories(${CMAKE_SOURCE_DIR}/IntelCvTutorial/include) +# shared library add_subdirectory(test) add_subdirectory(app) \ No newline at end of file git diff filename 这个命令会输出文件当前状态与其上次提交之间的发生的修改。
# git diff README.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/810c8b1ec961f0851da8ea8c7c04a96c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9209f57c4d613b0f2fc7bdd092f9d971/" rel="bookmark">
			Java运行过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图 本文思维导图
一、概述 java从源码到程序运行过程是java源程序到字节码文件，最后到运行结果的过程。
图 Java运行过程
Java编译器将java源文件（.java）转换成字节码文件（.class）,类加载器(ClassLoader)将字节码文件加载进内存，然后进行字节码校验，最后Java 解释器翻译成机器码。
图 Java编译过程
二、JVM 2.1 jdk、jre与 jvm JDK（Java Development Kit）: 是Java的开发工具包，是整个java开发的核心;
JRE（Java Runtime Environment）: 是java程序的运行环境，所有的Java程序必须依赖jre才能运行；
JVM（Java Virtual Machine）: java虚拟机，是一个虚拟的中间平台，只负责将编译后的字节码文件转换成当前计算机能理解并执行的指令；
图 jdk、jre与jvm的关系
JDK主要包含JRE、Java基础类库(Java API)和Java的一些工具包。
图 jdk1.8安装目录
bin: 可执行文件，包含javac文件(编译器)和java文件(源码编译器)；
include: 包含一些头文件，用于java 和 JVM进行交互；
lib: 类库；
jre: java 运行环境；
(legal 法律文件)
图 jre目录
jre/bin: 与bin目录可执行文件相同，但是不包含javac文件；
lib: 运行环境用到的核心类库，属性设置和资源文件；
2.2 jvm 中java程序的执行情况 在jvm中，通过类加载器将字节码文件(.class)加载进内存，java解释器翻译成对应的机器码，最后在操作系统解释运行。
图 jvm中java程序的执行情况
方法区：虚拟机规范中将方法区看作是堆的逻辑部分，但在HotSpot实现上，将堆和方法区分开。堆中主要存放的是实例化的对象，方法区存放的是类的信息。
类型信息
1）完整有效名(包名.类名)。2）直接父类完整有效名。3）访问修饰符。4）直接接口的一个有序列表。
域信息
1）域（属性）名称。2）域类型。3）域修饰符。4）域的声明顺序。
方法信息
1）方法名称。2）返回类型。3）参数数量、类型及顺序。4）方法修饰符。5）方法的字节码。6）异常表。
表 方法区存储的类的信息
jdk1.6及之前
习惯把方法区称为永久代。静态变量存放在永久代上。
jdk1.7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9209f57c4d613b0f2fc7bdd092f9d971/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d68ed3924d4d46830a4d6d255dad6a01/" rel="bookmark">
			sop是什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标准作业程序 执行复杂的日常事务所设计的内部程序
内容 所谓SOP，是 Standard Operating Procedure三个单词中首字母的大写 ，即标准作业程序，指将某一事件的标准操作步骤和要求以统一的格式描述出来，用于指导和规范日常的工作。SOP的精髓是将细节进行量化，通俗来讲，SOP就是对某一程序中的关键控制点进行细化和量化。实际执行过程中sop核心是符合本企业并可执行，不流于形式。
特征 编辑 播报
从对SOP的上述基本界定来看，SOP具有以下一些内在的特征：
SOP是一种程序
SOP是对一个过程的描述，不是一个结果的描述。同时，SOP又不是制度，也不是表单，是流程下面某个程序中关键控制点如何来规范的程序。
SOP是一种作业程序
SOP是一种操作层面的程序，是实实在在的，具体可操作的，不是理念层次上的东西。如果结合ISO9000体系的标准，SOP是属于三阶文件，即作业性文件。
SOP是一种标准的作业程序
所谓标准，在这里有最优化的概念，即不是随便写出来的操作程序都可以称做SOP，而一定是经过不断实践总结出来的在当前条件下可以实现的最优化的操作程序设计。说得更通俗一些，所谓的标准，就是尽可能地将相关操作步骤进行细化、量化和优化，细化、量化和优化的度就是在正常条件下大家都能理解又不会产生歧义。
SOP是一个体系
SOP不是单个的是一个体系.虽然我们可以单独地定义每一个SOP，但真正从企业管理来看，SOP不可能只是单个的，必然是一个整体和体系，也是企业不可或缺的。余世维在他的讲座中也特别提到：一个公司要有两本书，一本书是红皮书，是公司的策略，即作战指导纲领；另一本书是蓝皮书，即SOP，标准作业程序，而且这个标准作业程序一定是要做到细化和量化。
格式 编辑 播报
包括负责者、制定者、审定者、批准者。
每页SOP页眉处注明“标准操作规程”字样；
制定SOP单位全称； 反映该份SOP属性的编码、总页数、所在页码； 准确反映该项目SOP业务的具体题目； 反映该项SOP主题的关键词，以利计算机检索； 简述该份SOP的目的、背景知识和原理等； 主体内容：具体内容简单明确，可操作性强，以能使具备专业知识和受过培训的工作人员理解和掌握为原则； 列出制定该份SOP的主要参考文献； 每份SOP的脚注处有负责者、制定者、审定者、批准者的签名和签署日期； 标明该份SOP的生效日期。
执行步骤 编辑 播报
做SOP的方式根据不同的管理模式和管理方式，会有一定的区别。从国瑞公司的实际情况来看，我们大体上可以按以下几个步骤来进行：
1.先做流程和程序
按照公司对SOP的分类，各相关职能部门应首先将相应的主流程图做出来，然后根据主流程图做出相应的子流程图，并依据每一子流程做出相应的程序。在每一程序中，确定有哪些控制点，哪些控制点应当需要做SOP，哪些控制点不需要做SOP，哪些控制点是可以合起来做一个SOP的，包括每一个分类，都应当考虑清楚，并制定出来。
2.确定工作的执行步骤
确定每一个需要做SOP的工作的执行步骤。对于在程序中确定需要做SOP的控制点，应先将相应的执行步骤列出来。执行步骤的划分应有统一的标准，如按时间的先后顺序来划分。如果对执行步骤没有把握，要及时和更专业的人员去交流和沟通，先把这些障碍扫除掉。
3.制定SOP
套用公司模板，制定SOP。在这些问题都搞清楚的前提下，可以着手编写SOP了。按照公司的模板在编写SOP时，不要改动模板上的设置；对于一些SOP，可能除了一些文字描述外，还可以增加一些图片或其他图例，目的就是能将步骤中某些细节进行形象化和量化。
4.用心去做
用心去做，才能把SOP做好。由于编写SOP本身是一个比较繁杂的工作，往往很容易让人产生枯燥感觉，但SOP这项工作对于公司来说又非常重要，公司在这方面也准备进行必要的投放，特别是从时间用2到3年的时间来保证，因此我们必然用心去做，否则不会取得真正好的效果，甚至走到形式主义的负面去了。正象一位劳模所说，“认真做事只能把事情做对，用心做事才能把事情做好”，并用这句话和大家共勉。
案例分析 编辑 播报
案例一：SOP在物流配送中心中实施应注意的问题
不同模式的配送中心作业内容有所不同，一般来说配送中心执行如下作业流程进货、进货验收、入库储存、拣选或分拣．流通加工、包装、出货检查、装车配送等。这些环节很多需要手工操作或手工辅助操作，所以可以借助于SOP的方法分析各个环节的作业内容、优化作业程序、形成标准操作规程。由于各个物流配送中心的作业流程和工作方法有所差异，具体的SOP制定要根据各自作业的特点进行。
物流配送中心应注意的问题
在物流配送中心中应用SOP时应注意的问题：
1.流程改进优先
在制定作业的SOP之前．要对整个系统流程进行分析和优化，如果系统流程过于繁琐，导致了很多浪费的程序．那么对浪费的程序也制定SOP对提高配送中心的效率意义就不大了。例如要通过信息管理系统的优化．防止对产品信息的重复录入作业。或者优化拣选路径．防止多余的搬运作业。
2.系统的思考
在对各个程序制定SOP的时候还要注意该环节在系统流程中的地位。根据水桶理论，单个环节的最优不代表整体的最优，所以对配送中心的～系列程序环节，要从一个系统的角度制定各个环节的改进目标，实现系统的平衡。同时SOP的制定并不是一劳永逸，要随着操作内容的改变、工具设备的改变，管理方法的改变而改变，也就是注意系统的动态变化，及时根据系统需求进行调整。
3.考虑设备工具的使用
对每个作业制定SOP的时候要从人因工程的角度考虑能否借助一些简单低成本的辅助工具来实现更高的作业效率。例如对于繁重的搬运作业．应该根据不同的物品特性设计一些低成本的搬运设备或搬运辅助工具．从而提高搬运的效率。
4.注重分拣作业的优化
分拣作业主要是根据分拣单的要求从仓库中选取产品，然后将产品搬运到指定的地点．完成拣选，或者批量拣选后再由后续的人员或者设备进行分拣作业。有调查表明分拣作业占物流配送中心运营时间的30%～40%，搬运量的90%．成本的40%．所以分拣作业的效率提高对于整个运营的效率提高有极其重要的意义。在进行分拣作业的SOP制定的时候．可以参考”六不原则”。即不让等、不让碰、不让动、不让想、不让找、不让写。
5.工业工程人员的参加
SOP是一个科学的方法，集成了工作研究、质量管理、人因工程等工业工程的思想和方法，所以制定SOP的人员应该是一个具有工业工程背景知识的人员，从而帮助企业编制更有效地SOP文件。
物流配送中心应用SOP的意义
配送中心的各个环节的作业虽然简单，不需要工人有较高的技术水平，但是由于配送中心的工作量大，作业频繁，以一个工人一个工作日处理一万件产品为例。借助于科学的SOP的制定，一个动作的节省一天就好似一万次，如此下来一个月、一年、整个物流配送中心的节省就非常客观了。SOP在物流配送中心应用的意义具体表现在：
1.提高物流配送中心的运行效率
SOP是实践操作中不断进行总结，优化和完善的产物，在这一过程中积累例如系统的科学分析和许多人的共同智慧，因此能显著的提高工作的效率。通过每个工作的效率的提高，必然会提高整体的运行效率。
2.为物流配送中心的作业提供统一指导
如果企业在操作上没有一个统一的作业规定，就导致不同时段不同操作人员的作业方式不一样，从而影响了整体的运作效率和运作质量。由于物流企业的许多岗位的人员经常发生变动，优秀的工人走掉后会将一些好的作业方式也带走，新聘用的工人就要从头摸索更好的作业方式，这就浪费了很多时间和精力。所以物流配送中心的SOP的建立和实行可以持续优化的流程和作业。同时也可以为新聘用的工人提供作业培训的指导。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d68ed3924d4d46830a4d6d255dad6a01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d899fbe99b939da4f4b9cde9d9cefb70/" rel="bookmark">
			Maven中optional和scope元素的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven中optional和scope元素的使用 optional元素optional元素默认值（false）optional元素为trueparent继承的情况scope元素runntime（运行时）provided（已提供）system小结 在梳理项目的过程中发现很多开发同学对Maven依赖文件的配置并不了解，特别是对Maven的optional元素和scope元素的使用也非常随意。这就会导致发布的jar包或war包非常“胖”、编译速度慢，而且还很容易生产jar冲突等问题。本篇文章从optional和scope的使用场景入手，让项目实现一波瘦身。
optional元素 这里以Spring Boot项目中的使用为例，比如我们在项目中经常使用的热部署组件spring-boot-devtools，就可以使用optional元素来进行定义，对应pom文件中配置如下：
org.springframework.boot spring-boot-devtools true 那么，这里的optional元素设置为true表示何意？optional是Maven依赖jar时的一个选项，表示该依赖是可选的，项目之间依赖不传递。不设置optional（默认）或者optional是false，表示传递依赖。 文字描述可能比较抽象，下面用具体实例场景来进行更直观的描述，这里假设有两个项目A和B，其中A为父项目，B为子项目。在父项目中引入了单元测试的依赖：
&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; 下面针对optional元素的不同值进行讲解。
optional元素默认值（false） 当父项目添加junit依赖时，并未添加optional选项，也就是默认的optional元素的值为false。
此时，当子项目依赖父项目时，父项目A和子项目B的关系如下：
父项目并未设置optional元素为true，那么便具有依赖传递性。此时，子项目B中会直接引入父项目A中引入的Junit的jar包。也就是说B项目打包时，jar/war包中会包含junit的jar包。
optional元素为true 当父项目引入junit依赖时，设置optional元素为true。那么，子项目B便有了更多的选择。
如果项目B不需要Junit的jar包，那么在其pom文件中不需进行任何处理便可以。如果B项目也需要对应的jar包依赖，可以有两种选择：第一、A项目中对应依赖的optional设置为false或去掉；第二、B项目中直接引入需要的该依赖。
parent继承的情况 我们经常会在parent项目中配置统一的依赖版本控制，如下：
```java &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 此时，如果B项目需要Junit的jar包，可以直接在项目中引入，这里父项目中的optional配置对子项目并无影响。
综上所述，在Maven项目中，恰当的使用optional配置，可以在很大程度上减少jar包的大小，提升编译和发布速度。
scope元素 上面讲完了optional元素的使用，再来看看scope的使用。
scope元素主要用来控制依赖的使用范围，指定当前包的依赖范围和依赖的传递性，也就是哪些依赖在哪些classpath中可用。常见的可选值有：compile, provided, runtime, test, system等。
compile（编译）
默认值。compile表示对应依赖会参与当前项目的编译、测试、运行等，是一个比较强的依赖。打包时通常会包含该依赖，部署时会打包到lib目录下。比如：spring-core这些核心的jar包。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; test（测试）
scope为test表示依赖项目仅参与测试环节，在编译、运行、打包时不会使用。最常见的使用就是单元测试类了：
&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 类似单元测试这样的依赖，如果不设置scope为test，很显然它们会被打包、发布，但其实真是环境中并无什么作用。
runntime（运行时） runntime仅仅适用于运行和测试环节，在编译环境下不会被使用。比如编译时只需要JDBC API的jar，而只有运行时才需要JDBC驱动实现。
&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.20&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; provided（已提供） provided适合在编译和测试的环境，和compile功能相似，但provide仅在编译和测试阶段生效，provide不会被打包，也不具有传递性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d899fbe99b939da4f4b9cde9d9cefb70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd1ce650ffc7afd3ea1440b1326463bd/" rel="bookmark">
			postgresql9.5安装、主从复制、主备切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装pg9.5 网上教程都是yum源找不到，很崩溃
自己去官网找到了办法换源，在这个网址的最底部有教程：Repo RPMs - PostgreSQL YUM Repository
// 配置源，如果是9.6就改成9.6，本次使用9.5 cat &lt;&lt; EOF &gt; /etc/yum.repos.d/pgdg-95.repo [pgdg90] name=PostgreSQL 9.5 RPMs for RHEL/CentOS 7 baseurl=https://yum-archive.postgresql.org/9.5/redhat/rhel-7-x86_64 enabled=1 gpgcheck=0 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-PGDG EOF // 安装 yum install postgresql95-server // 初始化并启动postgresql /usr/pgsql-9.5/bin/postgresql95-setup initdb // 看命令 systemctl list-unit-files --type=service | grep postgresql // 启动postgresql systemctl enable postgresql-9.5 // 开机自启动 systemctl start postgresql-9.5 // 启动 systemctl restart postgresql-9.5 // 重启 systemctl stop postgresql-9.5 // 停止 坑：如果报错就执行 清除yum缓存 的命令，然后重新安装 Not using downloaded pgdg90/repomd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd1ce650ffc7afd3ea1440b1326463bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbce37ef8647d73b82e8b7fa82111b4d/" rel="bookmark">
			计网复习——海明码的原理和代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常复习408的一天，把孩子闲的。花了一上午复习了python语法。
以数据1010为例讲述海明码的编码原理和过程：
1. 确定海明码的位数 海明码分为两部分：有效信息（n位）+校验位（k位），满足条件
现在1010对应n=4，则复合要求的k至少为3
则完整的海明码我们可以用4+3=7位来表示
2.确定校验位的分布 意思是在7个海明码位中选定3个位置作为校验位。第i个校验位放在第个海明码位上
3. 分组以形成校验关系 每个数据位用多个校验位进行校验，但要满足条件：被校验数据位的海明位号等于校验该数据位的各校验位海明位号之和。其实就是把D_i的二进制表示中的1的下标提取出来，作为相应位置的校验位，然后求这些校验位的异或。
4.校验位取值 校验位P_i的值为第i组（由该校验位校验的数据位）所有位求异或
5. 海明码的校验原理 每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，，构成k个校验方程组，若“S1 S2 S3” 的值为 “000”，则说明无措，否则说明出错，且这个数就是错误位的位号。
5. 代码实现 import numpy as np # 辅助函数：用来获取一个正整数的二进制位为1的所有下标 def get_ones_positions(num): positions = [] binary = bin(num)[2:] # 将整数转换为二进制字符串，并去掉开头的"0b" for i, digit in enumerate(binary[::-1]): # 反向遍历二进制字符串的每一位 if digit == '1': positions.append(i + 1) # 如果当前位是1，则将索引添加到结果列表中 return positions def HaiMingCode(passage): # 0. 将二进制倒转过来，方便处理 passage = passage[::-1] # 1. 获取海明码校验位数 n = len(passage) # 信息位数 k = 1 # 校验位数 while n + k &gt; pow(2, k) - 1: k += 1 # 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbce37ef8647d73b82e8b7fa82111b4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e56fab1e745d52d9ff8ad64efd15f4/" rel="bookmark">
			Nuxt3 封装useFetch请求,并防止参数自动更新请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 useFetch 可组合函数提供了一个方便的包装器，用于useAsyncData和$fetch。它会自动生成基于URL和fetch选项的键，根据服务器路由提供请求URL的类型提示，并推断API响应类型。
useFetch，应该直接在设置函数、插件或路由中间件中调用。它返回响应式的可组合函数，并处理将响应添加到Nuxt负载中，以便在页面水合期间从服务器传递给客户端而无需重新获取数据。
注意：所有fetch选项都可以使用computed或ref值进行赋值。如果这些值更新，将自动进行新的请求。
以下请求封装脱离了自动请求!!!
第一步 更改配置 1.配置环境变量 //.env.development NUXT_PUBLIC_API_BASE=http://localhost:8099/v1/api //.env.production NUXT_PUBLIC_API_BASE=http://110.110.110.110:8099/v1/api 2.修改package.json配置 //package.json "dev": "nuxt dev --dotenv .env.development", "build": "nuxt build --dotenv .env.production", 3.修改nuxt.config.ts配置 //nuxt.config.ts // 添加运行时配置 runtimeConfig: { apiSecret: process.env.NUXT_API_SECRET, public: { apiBase: process.env.NUXT_PUBLIC_API_BASE || SERVER_BASE_API, } } --------------------------------------------------------------------- // 如果存在跨域 nitro: { devProxy: { '/api': { target: process.env.NUXT_PUBLIC_API_BASE, changeOrigin: true, } } } 第二步 请求封装 1.在composables目录下新建MyRequest.ts _nuxt/composables/MyRequest.ts //MyRequest.ts import { ElMessage } from 'element-plus'; type UrlType = string | Request | Ref&lt;string | Request&gt; | (() =&gt; string | Request); export interface RequestOptions { method?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39e56fab1e745d52d9ff8ad64efd15f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21824ef2fe67ad2a79195c22cc7364a4/" rel="bookmark">
			Apache新建站点，设置端口转发和访问密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标：
新建一个站点，域名为chat.example.com将80端口转发到127.0.0.1:1338设置访问密码
就是要简单粗暴，什么LNMP太麻烦。
然后，懂的都懂。😃 假设Apache2已经安装好了。
1. 安装相关软件并配置proxy sudo apt install -y openssl apache2-utils sudo a2enmod proxy sudo a2enmod proxy_http 2. 创建用户访问密码: 用户名testuser
sudo htpasswd -c /etc/apache2/htpasswd testuser 然后会提示输入密码。-c参数将创建一个新文件。
如果是在原有基础上添加新用户时，请移除-c参数，否则会覆盖原有文件。
3. 创建配置文件 sudo nano /etc/apache2/sites-available/chat.example.com.conf 内容如下：
&lt;VirtualHost *:80&gt; ServerName chat.example.com ProxyPass / http://127.0.0.1:1338/ ProxyPassReverse / http://127.0.0.1:1338/ &lt;Location /&gt; AuthType Basic AuthName "Restricted Content" AuthUserFile /etc/apache2/htpasswd Require valid-user &lt;/Location&gt; &lt;/VirtualHost&gt; 4. 启用新的虚拟主机配置 sudo a2ensite chat.example.com.conf 5. 重新加载Apache配置使更改生效 sudo systemctl restart apache2 提示:如果最开始未启动proxy，这里可能会提示Job for apache2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21824ef2fe67ad2a79195c22cc7364a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa12559d6715ed01eeb7359a759d0f69/" rel="bookmark">
			基于CBAM-CNN卷积神经网络预测研究（Python代码实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💥💥💞💞欢迎来到本博客❤️❤️💥💥
🏆博主优势：🌞🌞🌞博客内容尽量做到思维缜密，逻辑清晰，为了方便读者。
⛳️座右铭：行百里者，半于九十。
📋📋📋本文目录如下：🎁🎁🎁
目录
💥1 概述
📚2 运行结果
🎉3 参考文献
🌈4 Python代码及数据
💥1 概述 CBAM(CBAM-CNN)是一种用于计算机视觉领域的卷积神经网络结构，它能够有效地从图像中学习关注和调整。CBAM模型结合了通道注意力模块（Channel Attention Module）和空间注意力模块（Spatial Attention Module）两个部分，用于提升卷积神经网络的性能。
通道注意力模块（CAM）旨在通过学习不同通道之间的相关性，为每个通道分配适当的注意力权重。该模块首先通过全局平均池化获得整个通道的平均值，然后使用两个全连接层来生成一组注意力权重。这些权重用于调整每个通道的特征图。
空间注意力模块（SAM）旨在学习图像中不同空间区域的重要性。该模块通过对特征图在不同空间维度上进行最大池化和平均池化操作，然后使用一个卷积层来生成一组注意力权重。最后，这些权重被应用于原始特征图，以增强具有重要空间信息的区域。
通过结合通道注意力模块和空间注意力模块，CBAM能够动态地选择和调整特征图的通道和空间注意力，从而提取更准确和具有区分力的特征表示。这种注意力机制有助于网络更好地对图像进行感知，从而改善图像分类、目标检测、图像分割等计算机视觉任务的性能。
针对预测任务，可以使用CBAM-CNN模型进行图像分类或目标检测。在图像分类任务中，CBAM-CNN可以通过自适应地关注重要的通道和空间区域，提取图像特征并进行分类。在目标检测任务中，CBAM-CNN可以辅助检测网络对目标区域进行准确定位和分类。
需要注意的是，CBAM-CNN只是一种网络结构，具体的预测研究还需要根据具体的任务和数据集进行调整和优化。
📚2 运行结果 部分代码：
def forward(self, x): # 1.最大池化分支 max_branch = self.MaxPool(x) # 送入MLP全连接神经网络, 得到权重 max_in = max_branch.view(max_branch.size(0), -1) max_weight = self.fc_MaxPool(max_in) # 2.全局池化分支 avg_branch = self.AvgPool(x) # 送入MLP全连接神经网络, 得到权重 avg_in = avg_branch.view(avg_branch.size(0), -1) avg_weight = self.fc_AvgPool(avg_in) # MaxPool + AvgPool 激活后得到权重weight weight = max_weight + avg_weight weight = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa12559d6715ed01eeb7359a759d0f69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f294f7fa99386c298b2ba211c4dfbd96/" rel="bookmark">
			ubuntu中安装cmake
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装最新版本的cmake 要在Ubuntu 18.04中安装最新版本的CMake，可以按照以下步骤进行操作：
添加CMake官方仓库：运行以下命令将CMake官方仓库添加到系统中。 wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2&gt;/dev/null | sudo apt-key add - sudo apt-add-repository 'deb https://apt.kitware.com/ubuntu/ bionic main' 更新软件包列表：运行以下命令以更新软件包列表。 sudo apt update 安装CMake：运行以下命令以安装CMake。 sudo apt install cmake 这将安装最新版本的CMake。安装完成后，您可以通过运行以下命令来验证安装是否成功： cmake --version 您应该能够看到CMake的版本信息。
二、安装某一版本cmake 要在Ubuntu 18.04中安装特定版本的CMake（例如3.14版本），可以按照以下步骤进行操作：
确保你的系统已经更新到最新版本，可以运行以下命令进行更新： sudo apt update sudo apt upgrade 安装CMake的依赖项，运行以下命令： sudo apt install build-essential libssl-dev 下载CMake的源代码。你可以在CMake的官方网站上找到所有可用版本的源代码：https://cmake.org/download/ 。 wget https://cmake.org/files/v3.14/cmake-3.14.0.tar.gz 解压下载的源代码文件： tar -zxvf cmake-3.14.0.tar.gz 进入解压后的目录： cd cmake-3.14.0 创建一个用于构建CMake的目录： mkdir build cd build 运行CMake的配置命令： cmake .. 编译CMake： make 安装CMake： sudo make install 验证安装是否成功，运行以下命令检查CMake的版本： cmake --version 这样，你就成功在Ubuntu 18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f294f7fa99386c298b2ba211c4dfbd96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e6a18edbe5955e87ef95a9b242762d/" rel="bookmark">
			一、docker部署nginx和自家官网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、docker部署nginx 1.1 docker安装配置nginx 1.1.1 总体步骤 #总体步骤 ·	搜索镜像 ·	拉取镜像 ·	查看镜像 ·	启动容器 ·	服务端口映射 ·	停止容器 ·	移除容器 1.1.2 基础操作 1、搜索nginx镜像 [root@docker ~]# docker search nginx --limit 10	#查询nginx的镜像前10份 2、拉取nginx镜像 [root@docker ~]# docker pull nginx:latest	#拉取最新版本的nginx。 #其他版本可以查看https://hub.docker.com/_/nginx/tags。 3、查看镜像 [root@docker ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest 605c77e624dd 18 months ago 141MB 4、镜像改名 [root@docker ~]# docker image tag nginx:latest xxqops.icu/nginx:latest	#把nginx镜像复制改名为xxqops.icu/nginx:latest。必须加上对应的版本。 [root@docker ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest 605c77e624dd 18 months ago 141MB xxqops.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14e6a18edbe5955e87ef95a9b242762d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42381a5a722dac1baa7fe3b140ea4541/" rel="bookmark">
			智能优化算法-理论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常用的无约束优化方法 1. 最速下降法： 负梯度方向使目标函数下降最快
2.牛顿法 二、分类 1. 兔子理论： 为了找出地球上最高的山，一群兔子开始想办法。
（1）局部搜索： 兔子朝着比现在高的地方跳去。他们找到了不远处的最高山峰。但是这座山不一定是珠穆朗玛峰。这就是局部搜索，它不能保证局部最优值就是全局最优值。
（2）模拟退火： 兔子喝醉了。他随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，他渐渐清醒了并朝最高方向跳去。这就是模拟退火。
（3） 遗传算法： 兔子们吃了失忆药片，并被发射到太空，然后随机落到了地球上的某些地方。他们不知道自己的使命是什么。但是，如果你过几年就杀死一部分海拔低的兔子，多产的兔子们自己就会找到珠穆朗玛峰。这就是遗传算法。
（4）禁忌搜索： 兔子们知道一个兔的力量是渺小的。他们互相转告着，哪里的山已经找过，并且找过的每一座山他们都留下一只兔子做记号。他们制定了下一步去哪里寻找的策略。这就是禁忌搜索。
2. 群体智能： 粒子群算法、蚁群算法等。
3. 神经网络 三、神经网络 1.BP BP算法是一种监督式学习算法，属于学习算法的推广。其目的是使网络输出层的误差平方和达到最小，由信息的正向传播与误差的反向传播两部分组成。
采用最速下降法，但收敛速度较慢，易陷入局部极小点
2. 改进的BP 主要有采用启发式信息技术的BP算法，加入数值优化技术的BP算法和基于现代优化理论的BP算法三大类。 如牛顿法、共轭梯度法， 基于现代优化理论的BP算法是将遗传算法（简称GA）、蚁群算法（简称CA）、模拟退火算法（简称SA算法）等与神经网络相结合，改善BP算法的缺陷，提高算法的全局收敛能力。
3. 应用 （1）模式识别 神经网络经过训练可有效地提取信号、语音、图像、雷达、声纳等感知模式的特征，主要用于特征提取、聚类分析、边缘检测、信号增强、噪声抑制、数据压缩以及各种变换、分类判决等。
模式识别是人工神经网络特别适宜求解的一类问题，神经网络模式识别技术在各领域中的广泛应用是神经网络技术发展的一个重要侧面。
（2）人工智能 专家系统是人工智能领域研究时间最长、应用最成功的技术之一。但人们在应用专家系统解决语音识别、图像处理和机器人控制等类似人脑形象思维的问题时却遇到很大的困难。
神经网络的问世为人工智能开辟了一条崭新的途径，它具有自学习能力和较好的容错能力，可以有效进行预测和估计，主要应用在语言处理、市场分析、预测估值、系统诊断、事故检查、密码破译、语言翻译、逻辑推理、知识表达、智能机器人和模糊评判等。
（3）控制工程 神经网络在诸如机器人运动控制、工业生产中的过程控制等复杂控制问题方面有独到之处，较之基于传统数字计算机的离散控制方式、神经网络更适宜于组成快速实时自适应控制系统。
这方面的主要应用有：多变量自适应控制，变结构优化控制，并行分布控制，智能及鲁棒控制等。
（4）优化计算和联想记忆 由于并行和分布式的计算结构，神经网络在求解诸如组合优化、非线性优化等一系列问题上表现出高速的集体计算能力，在VLSI自动排版、高速通信开关控制、航班分配、货物调度、路径选择、组合编码排序、系统规划、交通管理以及图论中各类问题的计算等方面得到了成功应用。
联想记忆的作用是用一个不完整或模糊的信息联想出存储在记忆中的某个完整、清晰的模式来。如何提高模式存储量和联想质量仍是神经网络的热点之一，目前在这方面的应
用有内容寻址器、人脸识别器、知识数据库等。
（5）信号处理 神经网络的自学习和自适应能力使其成为对各类信号进行多用途加工处理的一种天然工具。主要用于解决信号处理中的自适应和非线性问题，包括自适应均衡、自适应滤波、回波抵消、自适应波束形成、自适应编码等自适应问题和各种非线性问题。如非线性区域的模式分类、系统辨识和高维非线性系统的检测估计等问题，还可对病态问题进行求解
神经网络在弱信号检测、通信、自适应滤波等方面的应用尤其引人注目，并已在许多行业得到应用。
四、遗传算法 1. 遗传算法的优点 ① 全局性：遗传算法在搜索过程中不易陷入局部极值点，即使在非连续和含有噪声的情况下，也能以较大概率收敛到最优解或满意解，具有很强的容噪能力。 ② 并行性和高效性：遗传算法具有大范围全局搜索和并行性等特点，适用于并行计算，因而执行效率高。 ③ 鲁棒性：鲁棒性强意味着遗传算法的搜索以群体为基本单元，不受初始选择的影响，不因实例的不同而蜕变；同时对于一个相同问题，在不同的多次运行中能够得到相同结果，在解的质量上没有很大差异。这已被许多数值所证实。
④ 普适性和易扩性：遗传算法是一种弱方法，它采用自然进化机制来表示复杂现象，对函数的形态无要求，可解决多种优化搜索问题。针对不同实例，只需适当调整算子参数等，进行很小修改即可适应新的问题，程序能够通用，这是现行的其他大多数优化方法所做不到的。 ⑤ 简明性：遗传算法的基本思想简单明了，实现步骤通俗易懂。
2. 基本原理 遗传算法是从代表问题可能解集的一个种群（popula-tion）开始的，而种群则是由经过基因（gene）编码的一定数目的个体（individual）所组成。每个个体实际上是染色体（chromosome）带有特征的实体。染色体作为遗传物质的主要载体，即多个基因的集合，其内部表现（即基因型）是某种基因组合，它决定了个体的形状的外部表现。
因此，首先要进行编码，实现从表现型到基因型的映射。然后在初代种群产生后，按照适者生存和优胜劣汰的原理，逐代（generation）演化产生出越来越好的近似解。
在每一代，根据问题域中个体的适应度（fitness）大小选择个体，并借助自然遗传学的遗传算子（genetic operators）进行交叉（crossover）和变异（mutation），产生代表新解集的种群。这个过程将导致种群像自然进化一样，后代种群比前代更加适应于环境，末代种群中的最优个体经过解码（decoding），可以作为问题的近似最优解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42381a5a722dac1baa7fe3b140ea4541/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc2b62c6fd8f429ea6b9afc4d9f5f6af/" rel="bookmark">
			【原创】linux中[root@localhost ~]#代表什么?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux中[root@localhost ~]#代表什么? [root@localhost ~]# 解读怎样修改主机名称 开门见山吧，大多时候我们在使用CentOS和Ubuntu的时候都没有太过注意到我们输入命令时光标前面那部分是什么东西。[root@localhost ~]#就是这一部分，反正我之前是没有怎么注意的，知道今天我发现我这个系统是CentOS，但是是写的[root@Ubuntu ~]，这样就有点误导别人了。
[root@localhost ~]# 解读 这里分为了四部分。
1.root：这个地方root是当前登录的用户，root是管理员账户。
2.localhost：这个地方是当前主机名称，可以自定义
3.~：这个地方说的是当前目录
4.#：这个说的是当前是root权限
怎样修改主机名称 修改主机名称，例如把[root@localhost ~]# 修改为[root@ubuntu ~]#
第一步：我们要确认我们登录了root账户，没有就切换到root账户。
第二步：使用hostnamectl工具来确认，当前的主机名。
第三步：输入指令：hostnamectl set-hostname ubuntu，主机名就会修改为[root@ubuntu ~]#
第四步：再次使用hostnamectl工具来确认主机名已修改。
第五步：使用以下两条命令，强制重新加载主机名
systemctl restart systemd-hostnamed.service
systemctl reboot
完成以上步骤就成功的将主机名修改为ubuntu
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89a1d68db33446e4b416d8da24755c8d/" rel="bookmark">
			清华ChatGLM-6B本地GPU推理部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 简介
2 硬件需求
3 Demo和模型下载
3.1 安装Git LFS
3.2 Demo下载
3.3 模型下载
3.4 文件目录
4 环境安装
5 运行
5.1 FP16
5.2 量化
6 演示
1 简介 ChatGLM-6B是一个开源的、支持中英双语的对话语言模型，基于General Language Model（GLM）架构，具有62亿参数。结合模型量化技术，用户可以在消费级的显卡上进行本地部署（INT4量化级别下最低只需6GB显存）。ChatGLM-6B使用了和ChatGPT相似的技术，针对中文问答和对话进行了优化。经过约1T标识符的中英双语训练，辅以监督微调、反馈自助、人类反馈强化学习等技术的加持，62亿参数的ChatGLM-6B已经能生成相当符合人类偏好的回答。
本文主要参考官方流程，在Ubuntu22.04上将ChatGLM-6B部署在本地Nvidia RTX 3080Ti Laptop GPU（16GB显存）。
2 硬件需求 默认情况下，模型以FP16精度加载，运行上述代码需要大概13GB显存。8-bit量化下GPU显存占用约为8GB，4-bit量化下仅需6GB占用。所以理论上，只要GPU的显存在6GB以上，就可以尝试在本地部署ChatGLM-6B。
随着对话轮数的增多，对应消耗显存也随之增长，由于采用了相对位置编码，理论上ChatGLM-6B支持无限长的context-length，但总长度超过2048（训练长度）后性能会逐渐下降。
模型量化会带来一定的性能损失，经过测试，ChatGLM-6B在4-bit量化下仍然能够进行自然流畅的生成。使用GPT-Q等量化方案可以进一步压缩量化精度/提升相同量化精度下的模型性能。
3 Demo和模型下载 3.1 安装Git LFS sudo apt install git-lfs 3.2 Demo下载 mkdir THUDM cd THUDM git clone https://github.com/THUDM/ChatGLM-6B.git 3.3 模型下载 先下载模型实现。
GIT_LFS_SKIP_SMUDGE=1 git clone https://huggingface.co/THUDM/chatglm-6b 再下载模型参数文件，并将下载的文件替换到本地的chatglm-6b目录下。
3.4 文件目录 Demo和模型下载完成之后的文件目录如下图所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89a1d68db33446e4b416d8da24755c8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec22bb7f2921f05cb2900fc27793f34c/" rel="bookmark">
			住宅小区的拓扑规划与网络设计（完整文档&#43;ensp拓扑图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小华学长，一名计算机领域的博主。经过多年的学习和实践，我积累了丰富的计算机知识和经验，在这里我想与大家分享我的学习心得和技巧，帮助你成为更好的程序员。
作为一名计算机博主，我一直专注于编程、算法、软件开发等领域，在这些方面积累了大量的经验。我相信分享是一种双赢的方式，通过分享，我可以帮助他人提升技术水平，同时也能够得到学习交流的机会。
在我的文章中，你将会看到我对于各种编程语言、开发工具以及常见问题的解析和分析。我会结合自己的实际项目经验，为你提供实用的解决方案和优化技巧。我相信这些经验不仅能够帮助你解决当前遇到的问题，还能够提升你的编程思维和解决问题的能力。
除了技术方面的分享，我还会涉及到一些关于职业发展和学习方法的话题。作为一名曾经的学生，我深知在计算机领域如何更好地提升自己和面对挑战。我会分享一些学习方法、面试技巧和职场经验，希望能够对你的职业发展产生积极的影响。
我的文章会发布在CSDN社区，这是一个非常活跃和专业的计算机技术社区。在这里，你可以与其他热爱技术的人们交流、学习和分享。通过关注我的博客，你可以第一时间获取到我的最新文章，并与我和其他读者互动交流。
如果你对计算机领域有兴趣，希望能够更好地提升自己的编程能力和技术水平，那么请关注我的CSDN博客。我相信我的分享会带给你帮助和启发，让你在计算机领域取得更大的成就！
让我们一起成为更好的程序员，共同探索计算机领域的精彩世界吧！感谢你的关注与支持！
分享的所有计算机项目源码均包含文档，可做毕业设计或课程设计，欢迎留言分享问题，交流经验！
摘 要
中国经济的猛速发展，使得人们的生活条件越来越好，人们对计算机网络的需求越来越大，伴随着网络的快速普及，网络在我们日常生活中越来越密切。在我们身边，网络到处都是，有移动4G数据网络，电信、移动、联通等;有传统的有线网络，有发展猛速的无线网络，以及保护人们安全的视频监控和电子眼等。最近几年，购买房子是人们比较关心的问题，如何让开发商小区的房子卖的更好，价格、地理位置以及周边的生活环境是人们主要考虑因素，但是小区的网络环境也是人们关心的问题。毋需置疑，网络的普遍存在让我们的生活越来越好，越来越安全和方便。网络的兴起，让我们在平时生活中可以享受到网上浪，关注一些新闻，业余时间看看网络电视和用通信软件聊天，同时人们对网络的需求也越来越高。
对于小区网络来说，小区内用户人数比较多，随着网络技术的发展，小区用户对网络带宽的需求不断提升，网络稳定性要求越来越高，为了避免出现网络突然中断、网络访问不稳定等现象，建设安全的、稳定的和高带宽小区网络是目前我们需要努力的目标。
这次我的毕设主要对住宅小区的网络拓扑进行规划和设计，根据人们对小区网络的需求分析，进行小区网络的拓扑规划和设计，并通过模拟器进行简单的模拟仿真、测试，模拟仿真软件选用huawei ensp模拟器。
关键词：小区网络；拓扑规划与设计；局域网
ABSTRACT
The sharply development of Chinese economy, people's living condition is getting better and better, people demand for computer network is more and more big, along with the rapid popularization of the Internet network in our daily life more and more closely. In our side, the network is everywhere, there are mobile 4 g data network, telecom, mobile, unicom, etc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec22bb7f2921f05cb2900fc27793f34c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7279a7201a99aaeab76873d1ad556141/" rel="bookmark">
			在 K8s 环境上 DIY 部署雷池社区版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 K8s 环境上 DIY 部署雷池社区版 原作者：charnet1019
环境 系统: CentOS Linux release 7.9.2009
内核: 3.10.0-1160.92.1.el7.x86_64
Kubernetes 版本: v1.24.15
safeline-ce 版本: 2.1.2
首先非常感谢长亭科技开源的优秀产品–长亭雷池 WAF
DIY 过程 0. DIY pod 配置文件 根据官方提供的 compose.yaml 文件，自己做了一份 K8s pod 运行所需要的各个服务配置（详见附件 safeline-ce-k8s-yaml.zip ），直接加载并启动相关 pod 即可。附件链接：https://github.com/chaitin/safeline/issues/118#issuecomment-1635174735
1. 查看 pod 运行状态信息 [root@master safeline-ce]# kubectl get pods,svc,pvc -n waf -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES pod/safeline-detector-54bfb6f99c-gtlmt 1/1 Running 0 12m 100.100.246.231 master.k8s.local &lt;none&gt; &lt;none&gt; pod/safeline-mario-779b744447-zq5tc 1/1 Running 0 12m 100.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7279a7201a99aaeab76873d1ad556141/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f96a61135dfa5b61d825801d4c1825e7/" rel="bookmark">
			RabbitMQ学习笔记（二）消息确认机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 1、我的另一篇文章中介绍了RabbitMQ的交换机类型、消费类型，经过一系列的demo测试时，我们在RabbitMQ的后台监控中可以发现一个现象，就是消息在被成功消费后，队列中就没有这个消息了，也就是删除了，那么疑问来了，RabbitMQ是怎么知道这个消息该不该被删除？什么时候删除？
2、除了消费者，那么生产者怎么知道自己消息是否发送成功到RabbitMQ中了？
解决这个疑问的方式就是：RabbitMQ消息确认机制
RabbitMQ有两种解决消息丢失的方案，一种是事务机制，一种是消息确认（confirm机制），这里主要介绍消息确认
1、为什么要进行消息确认 通过RabbitMQ的原理图可知，生产者和消费者并没有直接进行通信，中间要使用RabbitMQ传递消息，所以生产者只需要把消息发送到Rabbit，而消费者只需要从队列获取消息就可以了
生产者：生产者发布消息后，并不知道消息发送成功没，但是生产者需要知道，所以这里会有一个消息确认机制，帮助生产者确认消息发送成功消费者：消费者拿到消息后，在队列中这个消息还在，队列并不知道怎么处理这个消息，是删除还是死信，所以队列需要消费者给一个ACK确认，也就是消费者处理完消息后的反馈，队列根据反馈来选择处理方式 上述两种就是消息确认机制
二、消息确认的基本逻辑（源于官网） RabbitMQ是基于AMQP协议的，从官网给出的解释来说，会有两种建议：
当消息代理（broker）将消息发送给应用后立即删除。（使用AMQP方法：basic.deliver或basic.get-ok）待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用AMQP方法：basic.ack） 前者被称作自动确认模式（automatic acknowledgement model），后者被称作显式确认模式（explicit acknowledgement model）。在显式模式下，由消费者应用来选择什么时候发送确认回执（acknowledgement）。应用可以在收到消息后立即发送，或将未处理的消息存储后发送，或等到消息被处理完毕后再发送确认回执（例如，成功获取一个网页内容并将其存储之后）。
如果一个消费者在尚未发送确认回执的情况下挂掉了，那AMQP代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会等下一个注册到此队列的消费者，然后再次尝试投递。
三、生产者确认 生产者端可通过两个callback接口来确认消息的是否传递到Broker，但是两个接口默认都是不开启的
3.1 ConfirmCallback方法 ConfirmCallback方法：消息成功从生产者到Broker（RabbitMQ主机）后触发的回调，只用来确认是否正确到达了Exchange（交换机），发布者确认默认是不开启的，开启发布者确认需要添加如下配置
// springboot配置 spring.rabbitmq.publisher-confirm-type=correlated # 新版本 spring.rabbitmq.publisher-confirms=true # 老版本 3.2 ReturnCallback方法 ReturnCallback方法：消息从Exchange到queue投递失败，则会触发的回调，但是这个方法被触发的概率很小，因为交换机和队列的绑定是在代码中显式完成的，只要代码正确这个方法出发的概率就会很小，即便触发了也大概率是代码的问题，而这个方法也需要通过配置来开启
// springboot配置 spring.rabbitmq.publisher-returns=true 以上两种配置适用于springboot项目，如果没有使用springboot的话可以使用如下代码来进行配置
几种方法都在channel类中
四、消费者确认（重点） 消费者确认有两种方式：自动、手动
4.1 消息自动确认 消息自动确认是指消息发出后就认为消息消费成功，消息就会被RabbitMQ从队列中删除掉，并不会在意消费者处理业务的成功与否，也就是“发送即成功”，这种模式是一种非常不安全的方式，因为业务存在处理失败的情况，这样的话数据就会丢失
如下代码中的第二个参数，就是设定为自动确认模式（autoAck：true）
4.2 消息手动确认 手动应答提供三种接口
basic.ack(deliveryTag,multiple) 用来确认成功消息(positive acknowledgements)basic.nack(deliveryTag,requeue,multiple) 用来确认失败的消息(negative acknowledgements)basic.reject(deliveryTa,requeue) 用来确认失败的消息 4.2.1 成功确认：basic.ack(deliveryTag，multiple) deliveryTag：消息传递标签，格式为序列号，必须使用这个标签，不然信道会关闭，详情下面会说到multiple：为true则表示序号deliverTag之前的消息均被确认或拒绝（basicNack），false表示当前消息。为true的时候就可以做到批量确认 channel.basicAck(message.getEnvelope().getDeliveryTag(), false); 4.2.2 失败确认：basic.nack(deliveryTag，multiple，requeue) requeue：为true表示，失败的消息将会重新排队，不会丢弃或者死信（下篇文章描述），为false则表示丢弃 channel.basicNack(message.getEnvelope().getDeliveryTag(),false, true); 4.2.3 失败确认：basic.basicReject(deliveryTag，requeue) 相比nack方法，reject没有multiple参数，所以reject只能处理单个消息
channel.basicReject(message.getEnvelope().getDeliveryTag(), true); 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f96a61135dfa5b61d825801d4c1825e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c0b3b3fb6023946dc9ef80cb6fa2c8/" rel="bookmark">
			使用canvas生成二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先引入uQRCode.js
qrFun: function(text) {
let that = this
this.qrShow = true
uQRCode.make({
canvasId: ‘qrcode’,
componentInstance: this,
text: text,
size: 125,
margin: 6,
backgroundColor: ‘#ffffff’,
foregroundColor: ‘#000000’,
fileType: ‘png’,
errorCorrectLevel: uQRCode.errorCorrectLevel.H,
success: res =&gt; {
base64ToPath(res)
.then(path =&gt; {
that.img = path
})
.catch(error =&gt; {
console.error(error)
})
}
})
},
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8459124144f89b3f25ef04d6a29c0627/" rel="bookmark">
			SVG之线条动画相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近在实现VUI库的基础组件progress，其中涉及到圆形进度相关的绘制，参考了element ui框架的实现发现是通过svg来实现的。
实际上自身之前对于svg仅仅是知道的水平，本文旨在提交自身对于svg路径path以及动画相关内容的了解。
本文内容主要分为三块：
viewBox属性svg路径path相关知识学习stroke-dasharray和stroke-dashoffset属性学习 viewBox属性 首先来学习viewBox属性的，该属性是用于呈现内容区域的，常用于svg等标签上。
viewBox属性存在4个值：
viewBox=“x y width height”
其中x/y表示起始点坐标，width/height表示呈现区域的宽高。
viewBox属性存在的特点：
当svg的父标签的width或height小于viewBox的设置，svg会等比调整到svg父标签width/height中最小值当svg的父标签的width或height大于viewBox的设置，svg会等比调整到svg父标签width/height中最大值 即总是以适合的比例来呈现内容
实例1： 父标签width设置为50px，viewBox的width/height统一设置成100
实例2： 父标签width设置成300px，viewBox的width/height统一设置成100
实例3： viewBox属性前2个属性值即起始坐标设置的呈现效果
从上面可以看出，当设置x/y值是，实际上svg中的内容在x轴方向相对右侧向左移动了10px，y轴方向上相对底部向上移动了10px。
实际上x/y也可以设置负值，负值在x轴方向会相对左侧向右移动一定像素，y轴的则如正值的相反。
一般场景，viewBox中的x/y都是设置为0
&lt;path&gt;标签 svg中 标签可以实现所有其他的基本形状，也是svg中相对比较复杂的标签。 该标签提供一些绘制命令，使用d属性来存储路径命令数据，命令主要如下：
M/m：移动命令，表示绘制轮廓的起始位置
L/l：绘制直线到指定坐标
V/v：垂直方向绘制直线到指定坐标
H/h：水平方向绘制直线到指定坐标
A/a：绘制弧线
A/a: rx ry xr laf sf x y
rx、ry：表示圆弧的x和y方向的半径xr：圆弧横轴相对坐标系横轴的偏移角度laf：取大角度弧还是小角度弧，1表示大角度弧，0表示小角度弧sf：顺时针还是逆时针，1表示顺，0表示逆x、y：弧的终点坐标 需要注意的是：
大写命令的坐标表示绝对坐标，小写命令的坐标表示相对坐标
实例1： 通过path + circle来查看绘制起点的位置问题
path绘制一个圆，circle是用于标识指定坐标。
从上面可以看出，在svg viewBox为100即父容器恰好可以呈现的情况下，(50,50)实际上对应path绘制圆的顶点，那这里是不是可以认为：
path中M移动位置即依据绝对坐标来移动，是依据最最接近坐标原点的顶点为基础来进行的，即上图中圆黑点的位置
现在想要是圆点位置在svg的中心即黑点位置，要如何做呢？
&lt;path d="M 50 50 m 0 -47 a 47 47 0 1 1 0 94 a 47 47 0 1 1 0 -94"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8459124144f89b3f25ef04d6a29c0627/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/492662c21d049bdbc35b3f7b1755d3bd/" rel="bookmark">
			中小型超市的网络规划与设计（完整文档&#43;思科拓扑图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小华学长，一名计算机领域的博主。经过多年的学习和实践，我积累了丰富的计算机知识和经验，在这里我想与大家分享我的学习心得和技巧，帮助你成为更好的程序员。
作为一名计算机博主，我一直专注于编程、算法、软件开发等领域，在这些方面积累了大量的经验。我相信分享是一种双赢的方式，通过分享，我可以帮助他人提升技术水平，同时也能够得到学习交流的机会。
在我的文章中，你将会看到我对于各种编程语言、开发工具以及常见问题的解析和分析。我会结合自己的实际项目经验，为你提供实用的解决方案和优化技巧。我相信这些经验不仅能够帮助你解决当前遇到的问题，还能够提升你的编程思维和解决问题的能力。
除了技术方面的分享，我还会涉及到一些关于职业发展和学习方法的话题。作为一名曾经的学生，我深知在计算机领域如何更好地提升自己和面对挑战。我会分享一些学习方法、面试技巧和职场经验，希望能够对你的职业发展产生积极的影响。
我的文章会发布在CSDN社区，这是一个非常活跃和专业的计算机技术社区。在这里，你可以与其他热爱技术的人们交流、学习和分享。通过关注我的博客，你可以第一时间获取到我的最新文章，并与我和其他读者互动交流。
如果你对计算机领域有兴趣，希望能够更好地提升自己的编程能力和技术水平，那么请关注我的CSDN博客。我相信我的分享会带给你帮助和启发，让你在计算机领域取得更大的成就！
让我们一起成为更好的程序员，共同探索计算机领域的精彩世界吧！感谢你的关注与支持！
分享的所有计算机项目源码均包含文档，可做毕业设计或课程设计，欢迎留言分享问题，交流经验！
摘要
落实好超市网络计划工作，是超市与超市之间便捷沟通的枢纽。在当今社会超市网络的规模和应用水平已经是超市网络环境的首要组成部分，对于超市网络来讲，内网和服务器的安全性是其重中之重。因此，我们应该利用超市现有的条件在此基础上设计一个安全、统一的超市网络。
按照需求剖析，提供基本的核心技术（端口聚合，生成树优先级，VLAN应用）以更好的拓扑规划和更精确的分析现代化迎合本行业发展。根据超市配送，IP地址规划是VLAN的一个适当的部分，选择用户访问（使用MAC地址绑定IP地址）使管理更容易。根据计划选择设备的品牌名称和型号。ACL协议用于优化网络，ACL通过路由器的指令列表和交换机接口来控制进出端口的数据包。出口部署路由器与运营商的网络设备相连，通过出口路由器的网络地址转换配置完成超市内部用户的接入。
关键词：网络规划；vlan；网络地址转换
目录
摘要. 1
1绪论. 3
1．１ 超市内部网络产生的时代背景. 3
1．2 超市内部网络现状及分析. 3
2系统概述. 3
2．1 超市内部的系统构成. 3
2．1．1 信息平台. 3
2．1．2 系统管理与维护. 4
2．2 当前流行的超市内部网络组建技术. 4
2．2．1 层次化模型设计技术. 4
2．2．2 虚拟局域网. 5
2．2．3 网络安全技术. 5
3需求分析及系统设计原则. 5
3．1 用户需求. 5
3．1．1 网络需求. 6
3．1．2 管理需求. 6
3．2 系统设计原则. 6
3．2．1设备选型原则. 6
3．2．2 设计目标原则. 8
4系统组建方案. 9
4．1 方案综述. 9
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/492662c21d049bdbc35b3f7b1755d3bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7346ab70cf502a79bbac953f244b7da2/" rel="bookmark">
			nodejs安装及环境变量配置（修改全局安装依赖工具包和缓存文件夹及npm淘宝镜像新站域名）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本机环境：win11家庭中文版
一、官网下载
二、安装
三、查看nodejs及npm版本号
1、查看node版本号
node -v 2、查看NPM版本号（安装nodejs时已自动安装npm）
npm -v 四、配置npm全局下载工具包和缓存目录
1、查看安装目录
在本目录下创建node_global和node_cache目录，以后通过npm安装的依赖工具包将会安装到node_global文件夹下，避免安装到默认的C盘下。
2、npm命令设置全局下载安装工具包和缓存的目录
npm config set prefix "D:\Nodejs\node-v18.16.0\node_global" //设置依赖工具包全局安装目录，通过npm下载的工具包都会下载到本文件夹下 npm config set cache "D:\Nodejs\node-v18.16.0\node_cache" //设置缓存目录 3、将node_global和node_cacche写入到环境变量中。
3.1、在系统环境中新增一个NODE_HOME变量，值为nodejs安装的目录
3.2、在path里新增2条，将node_global和node_cacche这2个文件夹路径写入。
3.3、环境变量配置完成，将淘宝镜像设置为npm的源，否则在下载安装工具包时会特别慢（除非科学上网）
npm config set registry https://registry.npmmirror.com //npm设置新的淘宝npm镜像站，原淘宝镜像源于2022年5月起停止DNS解析 npm config set registry https://registry.npm.taobao.org //本地址为淘宝npm源站老域名，请使用新站点域名 3.4、查看npm配置列表
五、测试
1、查看node_global目录为空
2、安装常用模块express
npm install -g express //全局安装express模块 npm常用命令：
npm -v：查看npm安装的版本。 npm init：会引导你建立一个package.json文件，包括名称、版本、作者等信息。 npm list：查看当前目录下已安装的node包。 npm ls：查看当前目录下已安装的node包。 npm install moduleNames：安装Node模块到本地目录node_modules下。 npm install &lt; name &gt; -g：将包安装到全局环境中。 npm install &lt; name &gt; --save：安装的同时，将信息写入package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7346ab70cf502a79bbac953f244b7da2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/290213d05096708d495dc535d8d8010d/" rel="bookmark">
			使用pycharm编辑器print中文出现乱码究极解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改编辑器文件的编码格式 找到File-&gt;Settings-&gt;Fie Encodings
这个时候取试一下看有没有效果 如果没有效果 走下面步骤
修改vmOptions的参数 找到Help-&gt;Edit Custom VM VmOptions
加入下面代码
-Dfile.encoding=UTF-8 大功告成！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b3e3ff85f22a9e442559abb4a200d7f/" rel="bookmark">
			查看隐藏文件怎么做？4个简单方法分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“朋友们！想问问大家如果设置了隐藏文件，想查看的时候应该怎么进行查看呀？有没有朋友可以教教我！” 为了保护电脑的隐私，我们有时候可能会给电脑设置某些隐藏的文件，这些隐藏的文件我们是无法看到的。如果我们想查看隐藏的文件应该怎么查看呢？本文小编将给大家分享查看隐藏文件的简单方法。
方法一：使用文件资源管理器查看 我们将文件设置为隐藏文件，是无法在文件夹中正常看到该文件的。那怎么查看被隐藏的文件呢？我们可以利用文件资源管理器来进行查看，具体的操作如下：
1.按下快捷键【win＋E】打开文件资源管理器；
2.在顶部的菜单栏中，选择【查看】；
3.找到【隐藏的项目】，将其勾选上；
4.此时我们隐藏的文件可被正常显示。
方法二：使用控制面板查看 隐藏的文件找不到了怎么办？使用控制面板来查看也是不错的选择，操作如下：
1.点击任务栏上的【开始】按钮，选择【控制面板】；
2.点击【外观和个性化】，并选择【文件资源管理器选项】；
3.切换到【查看】选项卡，找到【隐藏文件和文件夹】；
4.勾选下方【显示隐藏的文件、文件夹和驱动器】，点击【应用】。
方法三：使用命令提示符 隐私文件在哪里查找？如果我们对命令提示符比较熟悉，可以直接使用命令提示符来查看。操作如下：
1.按下快捷键【win＋r】，打开命令提示符的窗口，输入【cmd】并执行；
2.在命令提示符窗口中，输入命令 【dir /a】后点击回车键；
3.系统将列出当前目录下的所有文件和文件夹，包括隐藏的文件和文件夹。
方法四：使用文件搜索功能 如果我们想快速找到被隐藏的文件，可以使用文件的搜索功能，直接对文件名称进行搜索，操作如下：
1.在资源管理器窗口的顶部菜单栏中，找到搜索框；
2.在搜索框中，输入文件夹或文件的名称；
3.系统将显示当前目录下的所有文件和文件夹，包括隐藏的文件和文件夹。
总结： 把某些文件隐藏起来可以有效保护我们的隐私，如果想要查看这些文件，其实也很简单。上文介绍了4种查看隐藏文件的简单方法，希望这些方法能够有效的帮助到你！
往期推荐：
怎样恢复删除的文件？正确做法应是这样！https://blog.csdn.net/datarecover/article/details/131697683
删除的文件如何恢复？只需要这3个方法！https://blog.csdn.net/datarecover/article/details/131675695
ofd文件怎么打开？试试3个打开方法https://blog.csdn.net/datarecover/article/details/131674961
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c57162244872b6fd72b3a135eca287/" rel="bookmark">
			SpingBoot- 配置优先级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.SpringBoot项目当中支持的三类配置文件：
application.propertiesapplication.ymlapplication.yaml 都是放在resource文件夹下
在SpringBoot项目当中，我们要想配置一个属性，可以通过这三种方式当中的任意一种来配置都可以，那么如果项目中同时存在这三种配置文件，且都配置了同一个属性，如：Tomcat端口号，到底哪一份配置文件生效呢？
application.properties server.port=8081 application.yml server: port: 8082 application.yaml server: port: 8082 可见生效的是 - application.properties server.port=8081 配置文件优先级排名（从高到低）：
properties配置文件yml配置文件yaml配置文件 注意事项：虽然springboot支持多种格式配置文件，但是在项目开发时，推荐统一使用一种格式的配置。（yml是主流）
2.除此之外SpringBoot为了增强程序的扩展性，除了支持配置文件的配置方式以外，还支持另外两种常见的配置方式：
Java系统属性配置 （格式： -Dkey=value）
-Dserver.port=9000 命令行参数 （格式：–key=value）
--server.port=10010 这两种方式配置的优先级都比前面三种在文件中配置的优先级高，并且在这两种之中，命令行参数的优先级又要高于Java系统属性配置
3.综上所述,五种配置的优先级的先后顺序为
1 命令行参数 （格式：–key=value）2 Java系统属性配置 （格式： -Dkey=value）3 application.properties4 application.yml5 application.yaml 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ca99fa72eeb66b67108b17e30797876/" rel="bookmark">
			服务器安装数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器安装数据库 准备 准备 服务器、xshell、navicat、 用xshell链接你的服务器，用虚拟机也是ok的，
（需要注意的是这里需要切换到root角色）
用wget 下载mysql源安装包
wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm 3. 安装mysql源安装包
rpm -ivh mysql-community-release-el7-5.noarch.rpm 下载数据库 yum install -y mysql-server 启动数据库 service mysql start 登录数据库‘、 mysql -uroot 给数据库设置远程登录的密码（之后我们会用navicat远程连接我们服务器） grant all privileges on *.* to root@"%" identified by "你的密码"; 设置了密码后你需要重启你的数据库
好了，你可以用你的navicat连接你服务器的数据库了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66c9d69151a706b33ef44859888da655/" rel="bookmark">
			(六) 性能提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chapter 6 Performance Tips 译：章节6 性能提示 6.1 Small tables of large geometries 译：6.1 大型几何图形的小型表格 6.1.1 Problem description 译：6.1.1 问题描述 Current PostgreSQL versions (including 9.6) suffer from a query optimizer weakness regarding TOAST tables. TOAST tables are a kind of "extension room" used to store large (in the sense of data size) values that do not fit into normal data pages (like long texts, images or complex geometries with lots of vertices), see the PostgreSQL Documentation for TOAST for more information).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66c9d69151a706b33ef44859888da655/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/597c4010ac2bbcc5571cae07238c3205/" rel="bookmark">
			python爬虫案例:爬取电影以及MP4文件合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、爬取ts文件
三、mp4文件合并
四、总结
一、前言 一日心血来潮想看个电影，但很无奈，都是要VIP的，所以我选择去盗版网站看，但是……为什么这么卡啊！！！所以呢，先爬下来，下载之后再来看就不卡了。
二、爬取ts文件 废话少说，直入主题。进入这个盗版电影网站，鼠标右击，选择检查（快捷键：Ctrl+Shift+I）
在Network选项栏里可以看到有许多个ts文件，每个ts文件就是电影的一部分，思路就有了：通过循环请求，下载所有的ts文件然后合并即可。
点进其中一个ts观察请求头（Request URL），发现不同的ts只有最后几位数字是不同的，https://vip.ffzy-online2.com/20230629/40222_a6b8ae3d/2000k/hls/这部分是相同的，不同的是后面的数字的最后四位，0000.ts、0001.ts、0002.ts。
移动进度条到电影最后，发现Network里加载出的ts一直到httpxxxxxx1830.ts还要多一些，这样请求的范围就确定了。
接下来就是代码部分了：
import requests import os from fake_useragent import UserAgent def download(i): i = str(i).rjust(4, '0') if os.path.exists(f'{i}.mp4'): return headers = {'user-agent': UserAgent().random}#注意random后不要加() url = "https://vip.ffzy-online2.com/20230629/40222_a6"\ f"b8ae3d/2000k/hls/106d7d7527400{i}.ts" response = requests.get(url, headers=headers) if response.status_code != 404: with open(f'{i}.ts', 'wb') as f: f.write(response.content) else: print(f'第{i}次404报错') def main(): for i in range(1831): download(i) if __name__ == '__main__': main() 首先是四位数的格式，这里用了操作字符串的rjust()函数，右对齐，长度4位，以0填充。也可以选择%04d的格式化方法。
然后是heards，这里用了第三方库fake_useragent（安装方法：按下键盘的win+R键并输入cmd（或右击电脑开始菜单，选择运行再输入cmd），在cmd中输入pip install fake_useragent，然后等待下载安装），UserAgent()函数可以生成一些user-agent，调用random随机选取一个。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/597c4010ac2bbcc5571cae07238c3205/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d442620fab53bb54832a218249ed2c32/" rel="bookmark">
			深入解析Tomcat：从入门到精通，一站式学习Tomcat服务器的完全指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要整体架构流程技术细节小结 概要 Tomcat是一个开源的Java Servlet容器，也是一个Web。它由Apache软件基金会开发和维护，是一个常流行的用于部署Java Web应用程序的容器。
Tomcat可以运行在各种操作系统上，包括Windows、Linux和Mac OS等。它实现了Java Servlet和Java Pages (JSP)范，并提供了一列的功能和工具，用于管理和运行Java Web应用程序。
作为一个Servlet容器，Tomcat负责接收HTTP请求并将其递给相应的Servlet进行处理。它还提供了一些重要的功能，如会话管理、安全性、虚拟主机支持、负载均衡等。
Tomcat的部署相对简单，只需将编译好的Java Web应用程序（WAR文件）放置在特定目录下即可。启动Tomcat后，它会自动加载并运行这些应用程序。
总之，Tomcat是一个强大且易于使用的Java Servlet容器，为开发人员提供了一个可靠的平台来部署和运行Java Web应用程序。
整体架构流程 1.创建web项目 开发环境 以下是我的开发环境
JDK 1.8Tomcat 9.0IDEA 2019（2019 无所畏惧，即使现在已经 2023 年了哈哈哈） 最原始的 Java Web 项目 下面的内容可能会因 IDEA 版本不同，而有些选项不同，但是大同小异。
1. 打开 IDEA 点击 Create New Project
2. 点击 Java Enterprise 点击左侧 Java Enterprise ，默认选项如下图所示。找到 Web Application，勾选上，同时勾上 Create web.xml。点击 Next 进入下一步。
3. 输入项目信息 输入项目名称和项目存储的位置，下方的配置默认就可以。接着点击 Finish 完成创建。
4. 完善项目结构 到这步，已经成功创建了 Web 项目了，目录结构如下图，在 Eclipse 中，web 目录的名称是 WebContent 。src 目录存放 Java 后端代码，web 目录存放前端代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d442620fab53bb54832a218249ed2c32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e743cd122dad21ca1e487915a29b8b1/" rel="bookmark">
			Intel RealSense D435i:简介、安装与使用(ROS、Python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		link
1.简介2.安装与配置 (1)添加Keys(2)添加Repositories(3)安装Libraries(4)安装Dev和Debug工具 3.测试与使用4.ROS接口安装5.ROS接口使用5.Python接口安装6.Python接口使用7.其它注意事项 (1)IMU信息的融合(2)深度图对齐问题(3)红外散斑问题(4)红外发射器的开关(5)D435i的不同分辨率(6)D435i相机默认参数查看(7)数据采集的常规流程 8.参考资料 实验室最近买了个Intel RealSense D435i相机让我来学习和采集数据，由于之前没有接触过相关内容，所以就简单学习了解了一下。这篇博客主要从使用角度对435i相机进行相关介绍，不涉及理论问题。插一句题外话，虽然Intel官网上RealSense相机看起来都很大的样子，但其实真正拿到手里会发现其实是非常小巧的，一个手就可以握住，如下图所示。 1.简介 Intel RealSense D435i是英特尔公司推出的一款消费级深度相机，它的主要构成如下图所示。 它主要包含一个RGB相机、两个红外相机以及一个红外发射器，此外还有一个IMU单元(这也就是D435i和D435的区别，i就表示imu)。简单来说它的深度成像原理是主动立体红外成像，不是传统意义上理解的双目RGB相机成像，这点需要注意一下。 有了深度图(3D点云)和对应的RGB影像，因此也就很容易获得RGB-D点云了。因此从输出的角度而言，D435i可以看做是一个RGB-D传感器相机。后续可以搭配ORB-SLAM中RGB-D的模式进行使用。当然，也可以只用单目RGB影像，以单目SLAM模式运行，或者单目结合IMU，以Mono-Initial模式运行。唯一不能运行的是双目RGB模式(因为两个红外相机是单通道的)。当然我们可以获取双目的红外影像，以此作为输入，进行双目SLAM，结果也是类似的。因此可以看出，D435i是一个比较“全能”的传感器，从单目、单目+IMU、双目、双目+IMU、RGB-D都可以使用。
对于它的一些技术上的参数，这里也简单列举一下：
深度技术：主动立体IR图像传感器技术：3μm×3μm像素大小，全局快门深度视场(H×V)：86°×57°(±3°)深度分辨率&amp;帧率：1280×720，90FPS(最高)RGB传感器技术：卷帘快门RGB传感器分辨率&amp;帧率：1920×1080,30FPS(最高)RGB传感器FOV(H×V)：69°×42°(±1°)最小深度距离(Min-Z)：0.105m最大范围：约10m尺寸(长宽高)：90mm × 25mm × 25mm 从上面的参数中，也可以看出来它的一些特点。比如深度图和RGB影像的大小是不同的，换句话说RGB影像中只有和深度图重叠的那部分才有深度信息，否则是没有的。同时帧率也不相同，如果需要使用RGB-D信息，那么时间同步也可能是个需要处理的问题。第二点是RGB传感器采用的是卷帘快门，因此在一些高速运动的场景下，可能会出现果冻效应。最后由于采用主动红外测距技术，而红外传感器本身发射的信号强度有限，最大10m左右，因此并不能适用于室外很大的场景。
2.安装与配置 在电脑端使用需要配合RealSense专门的驱动和SDK，这里以Ubuntu为例，介绍安装使用过程。
(1)添加Keys apt-key adv --keyserver keys.gnupg.net --recv-key C8B3A55A6F3EFCDE || apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key C8B3A55A6F3EFCDE (2)添加Repositories Ubuntu 16.04：
add-apt-repository "deb http://realsense-hw-public.s3.amazonaws.com/Debian/apt-repo xenial main" -u Ubuntu 18.04:
add-apt-repository "deb http://realsense-hw-public.s3.amazonaws.com/Debian/apt-repo bionic main" -u (3)安装Libraries apt-get install librealsense2-dkms apt-get install librealsense2-utils (4)安装Dev和Debug工具 apt-get install librealsense2-dev apt-get install librealsense2-dbg 需要注意的是librealsense2-dbg比较大，大约110MB左右，又因为是外网，因此可能会下载一段时间。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e743cd122dad21ca1e487915a29b8b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b40778290bab55c494c6b584a4d9f34/" rel="bookmark">
			C&#43;&#43;: Windows下的Socket编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言服务器端1. 加载Socket库2. 创建socket3. 绑定地址信息bind4. 监听listen5. 接收accept6. 接收数据7. 发送数据8. 关闭套接字9. 终止Socket库的使用 客户端1. 加载Socket库2. 创建socket3. 连接connect4. 接收数据5. 发送数据6. 关闭套接字7. 终止Socket库的使用 前言 协议选择TCP这里只给出每个步骤的大致流程，具体实现依照自身需求编写。(循环或者并发等等） 服务器端 1. 加载Socket库 WSAStartup()： 通过进程启动 Winsock DLL 的使用
WORD wVersionRequested; WSADATA wsaData; int err; //版本2.2(lowbyte,highbyte) wVersionRequested = MAKEWORD(2, 2); err = WSAStartup(wVersionRequested, &amp;wsaData); if (err != 0) { //找不到 winsock.dll printf("WSAStartup failed with error: %d\n", err); return 1; } if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) { //找不到2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b40778290bab55c494c6b584a4d9f34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/801f8f08949b2c3e7c19ed4dbb1e8e64/" rel="bookmark">
			GEE下载研究区DEM代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var dataset = ee.Image('USGS/SRTMGL1_003'); var elevation = dataset.select('elevation'); var data = ee.FeatureCollection("projects/ee-1261423515/assets/EHE"); // 改为你上传至GEE上的数据地址 var roi = data.geometry(); // 获取ROI的几何信息 Map.centerObject(data, 8); Map.addLayer(data, {color: 'FF0000', fillColor: '00000000', width: 1}, "ROI"); var SA_DEM = elevation.clip(roi); // 使用roi对高程数据进行裁剪 print(SA_DEM,'elevation'); Map.addLayer(SA_DEM,{min:0,max:3000},'StudyArea'); Export.image.toDrive({ image:SA_DEM, description:'STRMDEM', scale:30, region:roi, maxPixels:1e13 }); 如果你想要下载研究区范围内的矩形区域的图像，可以用下面的代码
var dataset = ee.Image('USGS/SRTMGL1_003'); var elevation = dataset.select('elevation'); var data = ee.FeatureCollection("projects/ee-1261423515/assets/EHE"); var roi = data.geometry().bounds(); // 获取ROI的边界矩形范围 Map.centerObject(data, 8); Map.addLayer(data, {color: 'FF0000', fillColor: '00000000', width: 1}, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/801f8f08949b2c3e7c19ed4dbb1e8e64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d184c3ee9e9c693cce677847f14dfbf6/" rel="bookmark">
			pythoon网络编程sockt(图片传送)步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤: 客户端： 创建Socket连接：客户端使用socket模块创建一个套接字(Socket)对象，并指定服务器的IP地址和端口号，以便建立与服务器的连接。
打开图片文件：客户端打开本地的图片文件，可以使用open()函数来操作文件
建立连接：客户端通过套接字对象的connect()方法与服务器建立连接。
发送图片数据：客户端使用套接字对象的sendall()方法将图片数据发送给服务器。可以将图片数据分块发送，确保完整的数据被发送。
关闭连接：发送完成后，关闭套接字连接，释放相关资源。
import socket import os import sys import struct def sock_client_image(): while True: try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # s.connect(("服务器的ip",端口号)) # 服务器和客户端在不同的系统或不同的主机下时使用的ip和端口.首先要查看服务器所在的系统网卡的ip s.connect(("192.168.9.100", 6666)) # 服务器和客户端都在一个系统下时使用的ip和端口 except socket.error as msg: print(msg) print(sys.exit(1)) # 输入当前目录下的图片名 xxx.jpg filepath = input("input the file:") fhead = struct.pack(b'128sq',bytes(os.path.basename(filepath),encoding="utf-8"), os.stat(filepath).st_size) # 将xxx.jpg以128sq的格式打包 s.send(fhead) # 打开要传输的图片 fp = open(filepath,'rb') while True: data = fp.read(1024) if not data: print('{0} send over...',format(filepath)) break s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d184c3ee9e9c693cce677847f14dfbf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6e5758062d746ea843664d6802dc815/" rel="bookmark">
			QML MouseArea堆叠时传递组合事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有2块MouseArea，上层MouseArea接受press事件而位于其下方的MouseArea接受click事件。click被称为组合事件。2方MouseArea各自接受自己的，互不影响。先上代码：
MouseArea { id: beneath anchors.bottom: parent.bottom anchors.horizontalCenter: parent.horizontalCenter onClicked: { ... } } Item { id: above anchors {bottom: parent.bottom; left: parent.left} width: ... height: ... MouseArea { anchors.fill: parent propagateComposedEvents: true onPressed: { ... } onClicked: { mouse.accepted = false } } } 由代码可知，通过设置propagateComposedEvents，并在上层（以下简称above）onClicked设置mouse.accepted = false声明click事件并不在此终结，继续往下层（一下简称beneath）传递。如果在above的clicked和pressed以及beneath的clicked打log，发现都被接收到了。
以上我们想要穿透传递的是click。而press则不然，经试验我发现一旦above在onPressed设置mouse.accepted = false，beneath固然能收到pressed和released，但是above只能收到pressed了。也就是说，above不会再有released了！初次我发现这个现象很震惊，通过查阅，这是Qt的设计认为一旦对pressed不感兴趣那默认你对released也不感兴趣了，可以参阅：qt - QML Mousearea onReleased not emitted - Stack Overflow
关于穿透传递还有一点，那就是mouseX/Y的正确性。我们知道mouseX和mouseY是在此MouseArea内部的相对坐标，一个mouseArea使用固然没有问题，但是我发现一旦above传递给beneath后，above接收到的mouseX/Y正确无误但是beneath的mouseX/Y是不对的（假如我们对坐标感兴趣的话）！经查阅在此情况下，可以使用mouse.x/mouse.y而非mouseX/Y。至于为啥可以再探究，我参考的链接是：qt - propagateComposedEvents: mouse data not accurate? - Stack Overflow
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6e5758062d746ea843664d6802dc815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c99e47236fef1eb1809b9c8e8ac34bf/" rel="bookmark">
			2023年高考大专就业前景好的专业选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很快就要进入2023年高考志愿专科填报时间了，所选择的专业的就业前景也成了考生和家长们关注的热点，那么大专就业前景好的专业有哪些呢?下面是我收集整理的大专就业前景好的专业，欢迎阅读与收藏。
1、动物医学专业
动物医学专业通俗来说，就是培养"兽医"的专业，它是以生物学为基础，研究动物(包括家禽、家庭宠物、野生动物等)疾病的发生发展规律，并在此基础上对疾病进行诊断和防治，保障动物健康的综合性学科。
就业方向：动物医学专业的学生毕业后可从事畜牧兽医行政管理、进出口动物及其产品的检验、肉品卫生检验、饲料工业、食品安全、环境保护、畜禽疾病的诊断与防治、伴侣动物医疗保健、实验动物、比较医学、公共卫生及生物学领域等方面的工作。如果你不愿意像多数学生一样成为兽医或自己开一个宠物诊所的话，还可以去动物检疫站或动物生产类企业。如果你对口蹄疫、禽流感等动物传染病感兴趣，建议你继续深造，将来留在高校或研究机构专门从事这方面的研究。
2、车辆工程专业
车辆工程是研究汽车、拖拉机、机车车辆、军用车辆及工程车辆等陆上移动机械的理论、设计和技术等问题的重要工程技术领域。车辆在现代社会中使用广泛，它关系着我国经济建设支柱产业之一的汽车工业及交通运输事业的振兴和发展。
就业方向：车辆工程专业毕业生可在机车车辆、地铁及轻轨车辆、汽车的设计制造部门工作，同时，还可从事汽车销售、汽车服务、汽车维修等行业的工作，也可参与城市交通系统的规划、设计、建设、运营、管理等工作。另外，随着国际交流日益频繁，在出国深造方面，基于全球化背景下现代汽车新技术在各国间的交融性和共通性，该专业的学生出国深造相对比较容易，回国服务的空间也异常广阔。
3、网络营销专业
网络营销专业培养独创精神和较强实践能力，需要掌握必要的文化基础和专业知识，具备扎实的计算机及网络知识、商务基础知识、网络营销知识、电子商务平台建设和管理能力的专门人才。
就业前景：网络营销不受时间和空间限制，购买自由，而且能节约更多的土地；成本低廉，不需要像传统销售那样负担高额的房租和员工费用，能为一些小企业提供更多的机会，而且网络上的商品一般都比实体店面便宜一些，更受消费者喜爱。因此网络营销还是不错的。
4、物流管理专业
物流管理专业主要学习经济、会计、贸易、管理、法律、信息资源管理、计算机等方面的基本理论和专门知识，培养具有一定的物流规划与设计、物流管理、物流业运作等能力，能在经济管理部门、贸易公司、物流企业从事政策制定，物流业运作管理应用型、复合型、国际化的物流管理人才。
就业方向：本专业毕业生可在物流企业、工商企业、货代公司、配送中心、港口、货物集散中心和物流基地(园区)、物流管理咨询公司及相关行政、事业单位等从事采购、仓储、包装、配送、运输、规划等物流业务运作管理、物流服务咨询与策划、供应链管理以及物流系统规划与设计等工作。
5、软件工程专业
软件工程专业培养适应计算机应用学科的发展，特别是软件产业的发展，具备计算机软件的基础理论、基本知识和基本技能，具有用软件工程的思想、方法和技术来分析、设计和实现计算机软件系统的能力的高级软件工程技术人才。
就业方向：软件工程专业毕业生可从事各级各类企事业单位的办公自动化处理、计算机安装与维护、网页制作、计算机网络和专业服务器的维护管理和开发工作、动态商务网站开发与管理、软件测试与开发及计算机相关设备的商品贸易等方面的有关工作。
6、环境工程专业
环境工程专业培养具备城市和城镇水、气、声、固体废物等污染防治和给排水工程、污染控制规划和水资源保护等方面的知识，能在政府部门、规划部门、经济管理部门、环保部门、设计、施工、管理、教育和研究开发方面工作的环境工程学科高级工程技术人才。
就业方向：环境工程专业学生毕业后可在政府部门、规划部门、经济管理部门、环保部门、设计单位、工矿企业、科研单位、学校等从事规划、设计、施工、管理、教育和研究开发方面工作。
7、报关与国际货运专业
报关与国际货运专业培养具有国际货运管理及报关必须的基础知识和技能，能从事报关与国际货运业务的高级技术应用性专门人才。
就业方向：从事报关行、外贸企业、进出口公司、海关、货运公司、物流企业、大型企业等从事报关、货物运输、货源组织、对外销售、仓储管理等方面的工作，尤其是国际货运代理公司。已与学校建立实训基地关系的外运公司可以协助推荐优秀毕业生到各大港口城市就业。
8、会计专业
会计是商业的语言，可以通过公司的账面和会计知识来了解一个公司的整体运营状态。通常会计专业的毕业生都会在就读期间或毕业后参加注册会计师资格证的考试，美国的CPA和英国的ACCA是目前世界上最大的国际注册会计师协会，很多毕业生都选择考取这两个协会的资格证。
就业方向:会计专业毕业生可胜任各类工业企业、商品流通企业、服务业、金融保险机构等部门或单位的出纳、会计核算、纳税申报、内部审计、财务管理、物资管理、柜员、客户经理等工作；也可从事会计师事务所、代理记账公司、财务公司的会计师助理、代理记账、会计咨询服务等职位。
9、道路桥梁与渡河工程专业
道路桥梁与渡河工程专业培养具有扎实的数学、力学、自然科学和工程技术的基础理论知识，掌握道路工程及桥梁工程领域内系统的专业知识，具有较强的动手能力，以及相当的人文社会科学、法律法规、经济管理及相关学科的基本理论知识，并了解国内外最新专业理论与技术发展的高素质人才。
就业方向：道路桥梁与渡河工程专业毕业生可从事道路桥梁与地下工程的勘测、规划、设计、建造、监理、咨询、管理(检测、评价、维护)等方面的技术工作。
10、医药营销专业
医药营销专业培养德、智、体全面发展，掌握一定的医学、药学知识和经济法律、市场营销的基本知识和能力，从事医疗器械和药品营销的高技能专门人才。
就业方向：毕业生到制药企业、医药公司从事购销业务居多，这方面人才也是企业招聘的主体。另外，医药界的贸易、监督管理等对技能热忱的需求也将会大大增加。
11、计算机应用技术专业
在大数据的当今，选择一门与计算机有关的专业，将来的就业范围也会大很多。一方面这个专业就业领域很广，适合的岗位很多。另一方面这个专业就算是转行也相对更容易一些。而且就业率高，选择面很广。
就业方向：
1）软件编程：计算机应用技术专业做软件编程工作前途大好，好多软件开发单位都需要这样的人才，经验和能力很重要，作息时间比较混乱，加班常有，但薪水也高，不用担心失业和饭碗问题。
2）硬件、网络工程：计算机应用技术专业适合网管和技术支持，同样经验和能力很重要，更要敬业，比较辛苦，而且反应力要好，如果网络或硬件出了问题，能马上找到症结并快速解决，前途看好，薪水还不错。
3）作图、设计：计算机应用技术专业做设计对艺术鉴赏力和创造力要求较高，有成功案例作品，创意好，视觉效果好，可以从事网页制作、网站维护、广告设计等平面的、立体的设计策划工作。
4）计算机应用：计算机应用技术专业可以做操作类工作，技术含量没有上面3类高，当然工资也不会很高。
12、信息安全专业
随着社会现代化的发展，信息安全的重要性也在不断地提高，各个企业、单位等都需要对自己的信息安全提供保障，这时候信息安全专业的毕业生就被派上用场了。网络安全工程师的岗位在社会招聘中也很吃香，很好就业。
就业方向：
1）网络工程师也是信息安全专业的一个就业方向，主要负责对网络障碍的分析，及时处理和解决网络中出现的问题。
2）运维类岗位也是信息安全专业的一个就业方向，目前很多安全类专业的毕业生会从事运维类岗位，这就要求信息安全专业的学生要具有较强的动手实践能力。运维类岗位往往需要具备三大块知识基础，其一是计算机网络知识；其二是操作系统知识；其三是存储知识。
3）负责机房线路的布置和协议的规范工作。负责计算机间的网络联接及网络共享，并负责网络间安全性的设置。负责系统网络的拓扑图的建立和完善，并做好系统路由的解析和资料的整理。
13、电气工程及其自动化专业
电气工程及其自动化的就业率高达95.5%，可谓是十分高的了。电气类的专业，在近些年来都非常火，这一面是因为电气专业的学生，学习的知识非常之广，他们不仅学习电子电气一类的知识，还要掌握包括简单计算机技术在内的知识，业务能力非常强，市场对这类人才的需求量非常大。
就业方向：
1）从事电力系统的设计、研发和运行管理等工作，可从事单位主要有：国家电网、南方电网两大电网公司下属的各级电力公司和国家五大发电集团及中核集团、中广核集团等下属的各类发电厂；各级电力设计院、电力规划院；电力建设公司；各类电力技术专业公司；新能源发电企业；能源、航空、航天、冶金、有色、石化、船舶、电子、医药、机械、建筑等大中型企业的供电部门或自备电厂；
2）在电气设备制造企业、电力自动化设备公司、电力电子、通信等高新技术企业从事技术研发、管理和运营工作；
3）在科研院所和大专院校从事科研和教学工作。
14、数控技术专业
我国高职院校的数控技术专业人才曾多次在国际职业比赛中获得佳绩，可见我国高职院校的专业实力在全世界占据重要地位的。现在大型制造业工厂基本大型机械设备，高学历的数控技术专业人才的需求很大。
就业方向：
1）在工业企业，从事数控程序编制、数控设备的使用、维护与技术管理，数控设备销售与售后服务等工作。数控技术专业在主要面向机械、模具、电子、电气、轻工等行业，可从事产品设计与加工、数控编程、数控机床操作、数控常用CAM软件多轴加工、数控设备调试与维修等相关工作。
2）数控技术专业可面向发电设备制造、军事工业、航空航天工业、船舶制造、数据设备制造等高端装备制造业，从事数控机床操作、数据加工程序编制、数据加工工艺编制、产品质量检验、现场管理、生产调度、数控设备销售与售后服务等工作。
3）数控编程员。很多的机加工企业都采用自动编程来生成数控加工程序，因此需要学习CAM软件。不同的单位使用不同的CAM软件，种类多种多样，但是大体上加工的方法都类似，但是做数控编程员要求很高，责任也很大，因此要求有丰富的加工经验。
4）数控维修人员。这个岗位的要求更高，是数控方面最缺乏的，对数控技术专业人才要求也高。不仅要求有丰富机械知识，还要有丰富的电气知识。如果选择了这个方向，可能会很辛苦，要不断的学习，不断积累经验。这个岗位需要得到的锻炼更多，因此达到熟练的时间会比较长，但是回报也会比较丰厚。
15、设计专业
设计专业有一大优势行业限制小，岗位需求范围大，这样给到学习设计专业的求职选择性范围很大。
就业方向：
1）平面设计
平面设计又称视觉传达艺术设计，主要学习内容包括广告战略、广告表现、书籍设计、插图设计、摄影艺术与技术、新媒体创作与应用等，毕业后可在出版、印刷、广告、商场、电视台、媒体及装潢公司等部门工作。
2）广告设计
主要学习内容包括广告策划与创意，文案、广告经营、媒体研究、摄像与摄影、广告设计、市场调查等课程，培养能在新闻媒体、广告公司、市场调查、信息咨询等行业从事广告工作方面的专门人才。
3）室内设计
主要学习内容包括室内空间设计、室内陈设设计。要求：全面系统地认识、理解室内设计的特征和规律，掌握多类型的室内设计要素及表现特点，对室内设计的多个设计环节和表现形式和创意，能够具备较完备的多角度施工效果图的绘制及模型制作能力，培养能在建筑、房地产开发、展示、装饰公司等相关企事业单位从事设计、经营和管理工作地专门人才。
4）环境艺术设计
在中国， “环境艺术设计”就是指室内装饰、室内外设计、装修设计、建筑装饰和装饰装潢等等。尽管叫法很多，但其内涵相同，都是指围绕建筑所进行的设计和装饰活动。要说有区别的话，那就是室内装修和室外装修的区别。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c99e47236fef1eb1809b9c8e8ac34bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a75e7872dfb4601b7982e61e7492d35/" rel="bookmark">
			谈一谈|你不知道的黑客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言
现代人的生活离不开互联网，提到互联网人们总会想到一个词，那就是黑客。对于黑客大家对他们的了解却只局限于电影、电视中他们“无处不在”的可怕和他们“翻手为云覆手为雨”的技术中。但真正的黑客到底是什么？
2 什么是黑客
笔挺的黑色西装+个性的黑色墨镜？连帽的衣服+酷酷的面具？
图1 黑客图片
2.1 黑客简介
黑客源自英文词汇hacker。hacker一词，最初曾指热心于计算机技术、水平高超的电脑高手，尤其是程序设计人员。
黑客通常是指对计算机科学、编程和设计方面具高度理解的人，但在不同的领域也可以指不同的人：
a.在信息安全里，“黑客”指研究智取计算机安全系统的人员。利用公共通讯网路，如互联网和电话系统，在未经许可的情况下，载入对方系统的被称为黑帽黑客（英文：black hat，另称cracker）；调试和分析计算机安全系统的白帽黑客（英语：white hat）。“黑客”一词最早用来称呼研究盗用电话系统的人士。
b.在业余计算机方面，“黑客”指研究修改计算机产品的业余爱好者。1970年代，很多的这些群落聚焦在硬件研究，1980和1990年代，很多的群落聚焦在软件更改（如编写游戏模组、攻克软件版权限制）。
c.“黑客”是“一种热衷于研究系统和计算机（特别是网络）内部运作的人”。
d. 在圈外或媒体上通常被定义为：专门入侵他人系统的计算机高手。
2.2 黑客、红客等的区别
黑客，最早源自英文hacker，早期在美国的电脑界是带有褒义的。他们都是水平高超的电脑专家，尤其是程序设计人员，算是一个统称。
红客，维护国家利益代表中国人民意志的红客，他们热爱自己的祖国，民族，和平，极力的维护国家安全与尊严。
蓝客，信仰自由，提倡爱国主义的黑客们，用自己的力量来维护网络的和平。
骇客，是“Cracker”的音译，就是“破解者”的意思。从事恶意破解商业软件、恶意入侵别人的网站等事务。与黑客近义，其实黑客与骇客本质上都是相同的，闯入计算机系统/软件者。
图2 破解图
3 黑客守则
通过电影、电视大家都会觉得黑客就是想干啥就干啥，一台电脑走天下，即使犯法了警察也抓不到的。但实际上黑客也有着自己的守则的，他们也不会像影片上演的那样。一起来看看黑客守则：
1. 不恶意破坏任何的系统, 这样做只会给你带来麻烦。恶意破坏他人的软件将导致法律责任, 如果你只是使用电脑, 那仅为非法使用。注意:千万不要破坏别人的文件或数据。
2. 不修改任何系统文件, 如果你是为了要进入系统而修改它, 请在达到目的后将它还原。
3. 不要轻易的将你要 Hack 的站点告诉你不信任的朋友。
4. 不要在 bbs/论坛上谈论关于你 Hack 的任何事情。
5. 在 Post 文章的时候不要使用真名。
6. 入侵期间, 不要随意离开你的电脑。
7. 不要入侵或攻击电信/政府机关的主机。
8. 不在电话中谈论关于你 Hack 的任何事情。
9. 将你的笔记放在安全的地方。
10.读遍所有有关系统安全或系统漏洞的文件 (对英语基础要求高)。
11.已侵入电脑中的帐号不得删除或修改。
13.不将你已破解的帐号分享与你的朋友。
14.不会编程的黑客不是好黑客。
15.黑客不同于“盗”（精髓）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a75e7872dfb4601b7982e61e7492d35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f878fe84411a74f9c646be9872f639/" rel="bookmark">
			VMware15.5.0虚拟机安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1、下载VMware-workstation-full-15.5.0-14665864.exe软件
2、 安装
3、打开虚拟机
1、下载VMware软件 下载地址：
VMware Workstation Pro 15.5.0 Build 14665864
https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.0-14665864.exe
VMware Workstation Pro 15.1.0 Build 13591040
https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.1.0-13591040.exe
VMware Workstation Pro 14.1.3 Build 9474260
https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.3-9474260.exe
VMware Workstation Pro 12.5.9 Build 7535481
https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.9-7535481.exe
VMware Workstation 10.0.7 Build 2844087
https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.7-2844087.exe
2、 安装 （1）双击VMware-workstation-full-15.5.0-14665864.exe，进入安装页面，点击安装
（2）点击下一步，进入许可协议界面，选择“我接受许可协议中的条款”，点击下一步
（3） 选择安装位置进行安装
（4）一直点击下一步，到下图界面，选择是否创建快捷方式
（5） 点击“安装”
（6） 安装完成后，点击许可证，填写以下任一许可证号点击查看http://download.csdn.net/download/qq_41567921/88046685
（7）点击“输入”，提示安装完成
3、打开虚拟机 （1）双击虚拟机快捷方式
（2）如出现需要输入注册码，输入上面的注册码，点击“确定”按钮可进入主界面
相关链接：
Linux专栏http://blog.csdn.net/qq_41567921/category_9757990.html
Qt专栏http://blog.csdn.net/qq_41567921/category_12377401.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e8d49c49f637e5dd623f1d0ee2809db/" rel="bookmark">
			嵌入式应用复习知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.期末考试题型 1.单选题40’2.判断题10’3.简答题20’4.综合设计题（6+6+10+8） 二.单选题知识点 1.嵌入式系统 1.定义 IEEE（国际电气和电子工程师协会）的定义：
Devices used to control, monitor, or assist the operation of equipment, machinery orplants。
翻译：嵌入式系统是“用于控制、监视或者辅助操作机器和设备或装置运行的装置
从中可以看出，嵌入式系统是软件和硬件的综合体，还可以涵盖机械等附属装置，可认为是一个广泛定义。
国内普遍认同的定义：
以应用为中心、以计算机技术为基础，软件硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗等严格要求的专用计算机系统。
我们把这个国内的定义收缩一下，就有了嵌入式的特点：嵌入性、专用性与计算机系统。
2.特点 嵌入性：必须满足对象系统的环境要求，如物理环境(小型)、电气/气氛环境(可靠)、成本(价廉)等要求。专用性：软、硬件的裁剪性；满足对象要求的最小软、硬件配置等。计算机系统：嵌入式系统必须是能满足对象系统控制要求的计算机系统。 3.硬软件 嵌入式系统的硬件特征：
(1)嵌入式系统由嵌入式处理器、存储器、相关支撑器件等电子元器件组成的电子装置或设备;(2)嵌入式系统的电气性能指标均能够参数化;(3)嵌入式系统需要通过硬件架构、电路原理图、电路板、产品模具的设计、生产、测试的系列工艺过程来实现。 这里注意，个人电脑并不是我们所说的嵌入式，而车载控制系统、网络数字机顶盒、智能手机等则是我们所说的嵌入式。
所以如果遇到判断下面哪些属于嵌入式系统的题，首先把计算机系统和笔记本电脑排除。
嵌入式系统的软件特征：
(1)软件要求固化存储;(2)软件代码要求高度精练、高质量、高可靠性、高稳定性;(3)系统软件(OS)的高实时性是基本要求;(4)多任务操作系统是知识集成的平台和走向工业标准化道路的基础。 嵌入式系统的产品特征：
(1)嵌入式系统必须面向用户、面向产品、面向应用;(2)嵌入式系统处理器的功耗、体积、成本、可靠性、速度、处理能力、电磁兼容性等方面均受到应用要求的制约，这些均是各半导体厂商之间竞争的热点;(3)嵌入式系统的软硬件都必须高效率地设计，量体裁衣、去除冗余，力争在同样的硅片面积上实现更高的性能。 这里的硬软件特征才是重点。
2.嵌入式系统组成的典型结构 嵌入式计算机系统一般由硬件层、硬件抽象层(中间层)、、操作系统层和应用软件层构成。
（该层次是由下到上描述的）
1.硬件层 嵌入式微处理器，嵌入式系统硬件层的核心，与通用微处理器不同(将通用计算机板卡完成的任务集成在芯片中)。
其体系结构可采用冯·诺伊曼结构或哈佛结构。指令系统可采用CISC或RISC。
存储器
CACHE：位于主存与微处理器内核之间，存放最近一段时间微处理器使用最多的一段程序代
码和数据。容量小，存取速度快。主存是微处理器能直接访问的寄存器，存放系统和用户的程序及数据。片内容量小，速度快，片外容量大。辅助存储器，存放大数据量的程序代码或信息，用来长期保存用户的信息。容量大，速度慢(与主存比)。 嵌入式系统与外界交互需要一定形式的通用设备接口。通用设备接口有: A/D、D/A转换接口等。I/0接口有: RS -232接口、Ethernet接口、USB接口、音频接口、视频接口、I2C接口、SPI及IrDA接口等。
2.中间层（HAL或BSP） 作用：将系统上层软件与底层硬件分离开来，使系统的底层驱动程序与硬件无关。
该层一般包括:
相关底层硬件的初始化数据的输入/输出操作硬件设备的配置 BSP具有以下两个特点:
硬件相关性操作系统相关性 BSP是一个介于操作系统和底层硬件之间的一个软件层次，包括了系统中大部分与硬件联系紧密的软件模块。
设计一个完整的BSP，应该包括硬件初始化和硬件相关的设备驱动两个部分。
3.操作系统层（系统软件层） 系统软件层由实时多任务操作系统(RTOS) 、文件系统、图形用户接口(GUI)、网络系统及通用组件模块组成。RTOS是嵌入式应用软件的基础和开发平台。
4.应用软件层 应用软件层是由基于实时系统开发的应用程序组成，用来实现对被控对象的控制功能。功能层是面向被控对象和用户的，为方便用户操作，往往需要提供一个友好的人机界面。
3.冯·诺伊曼结构和哈佛结构 冯·诺伊曼结构：指令和数据共享同一存储器和总线。
哈佛结构：指令和数据分别存储在独立的存储器和总线中。
4.嵌入式最小系统 构建一个嵌入式系统,首先需要.让系统核心部件嵌入式处理器工作,这样才可以逐步增加系统的功能,最终形成符合需求的完整系统。
5.RISC与CISC RISC结构一般特点:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e8d49c49f637e5dd623f1d0ee2809db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0375f4e5b9bb84399291ca0ab9717000/" rel="bookmark">
			实现虚拟机（VM15.5.0）与本机相互通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1、如果虚拟机一打开请先关机
2、进入“控制面板”-“网络和Internet”-“网络连接”，可以看到有两个虚拟网口，关闭虚拟网口VMnet1和VMnet8，如图所示：
3、选择需要通信的虚拟机，点击“编辑虚拟机设置”，打开后点击“网络适配器”，更改“网络连接”为“桥接模式”，如图所示：
4、打开虚拟机，开机
5、进入虚拟机，找到“网络连接”，编辑当前已连接的ip地址，修改IP与本机在同一网段，如图所示：
6、 打开终端，用命令行切换到root权限，方便后续操作
7、查看当前网络IP，发现IP已经改成了设置好的IP
8、查看网络情况发现是not-found，启动网络也是not found，重启也是同样的情况
9、此时在重启一下network-manager看看，重启成功
10、尝试ping本机IP
11、尝试本机ping虚拟机，也是可以ping通的，虚拟机与本机就可以正常进行通信了
1、如果虚拟机一打开请先关机 2、进入“控制面板”-“网络和Internet”-“网络连接”，可以看到有两个虚拟网口，关闭虚拟网口VMnet1和VMnet8，如图所示： 3、选择需要通信的虚拟机，点击“编辑虚拟机设置”，打开后点击“网络适配器”，更改“网络连接”为“桥接模式”，如图所示： 4、打开虚拟机，开机 5、进入虚拟机，找到“网络连接”，编辑当前已连接的ip地址，修改IP与本机在同一网段，如图所示： 6、 打开终端，用命令行切换到root权限，方便后续操作 7、查看当前网络IP，发现IP已经改成了设置好的IP 8、查看网络情况发现是not-found，启动网络也是not found，重启也是同样的情况 9、此时在重启一下network-manager看看，重启成功 service network-manager restart 10、尝试ping本机IP 发现虽然仍然有（8）的情况，但是已经可以ping通了，这里我本机IP：192.168.1.32，虚拟机中的IP：192.168.1.123
11、尝试本机ping虚拟机，也是可以ping通的，虚拟机与本机就可以正常进行通信了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/221a487ee28f188e8b027667fa1cee17/" rel="bookmark">
			Linux下安装使用navicat（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 linux 下的数据库图形化工具比较好用的有dbeaver完全免费，相比navicat,我还是习惯了使用navicat操作数据库。
截止目前最新版是navicat16-mysql-cs.AppImage，linux网上有很多navicat破解注册码教程，习惯使用了新版本，懒得折腾去破解了。
Linux 运行：
chmod +x navicat16-mysql-cs.AppImage ./navicat16-mysql-cs.AppImage 快到期之前，可以把之前连接的数据库通过 文件-&gt;导出连接，备份之前的数据库连接即可，下次激活后可以直接导入连接。Navicat Premium 16的试用期只有14天，执行下面两个命令，即可无限使用。
1、关闭Navicat程序
2、删除如下2个文件：
rm -rf ~/.config/navicat rm -rf ~/.config/dconf/user lsof | grep navicat | grep \\.config #用于列出当前系统打开navicat的工具 再次重新启动navicat即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c1914591f723235c140c087bdbe095/" rel="bookmark">
			(五) 空间查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chapter 5 Spatial Queries 译：章节5 空间查询 The raison d’etre of spatial databases is to perform queries inside the database which would ordinarily require desktop GIS functionality. Using PostGIS effectively requires knowing what spatial functions are available, how to use them in queries, and ensuring that appropriate indexes are in place to provide good performance.
译：空间数据库存在的理由是在数据库内部执行查询，这通常需要桌面GIS功能。有效地使用PostGIS需要知道哪些空间函数可用，如何在查询中使用它们，并确保适当的索引到位以提供良好的性能。
5.1 Determining Spatial Relationships 译：5.1 确定空间关系 Spatial relationships indicate how two geometries interact with one another.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04c1914591f723235c140c087bdbe095/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c607158fd56122090280f57654ed0a92/" rel="bookmark">
			transformer 学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理学习：
(3条消息) The Illustrated Transformer【译】_于建民的博客-CSDN博客
代码学习：
https://github.com/jadore801120/attention-is-all-you-need-pytorch/tree/master/transformer
mask学习：
(3条消息) NLP 中的Mask全解_mask在自然语言处理代表什么_郝伟博士的博客-CSDN博客
多头注意力机制学习：
【1】代码：
class MultiHeadAttention(nn.Module): ''' Multi-Head Attention module ''' def __init__(self, n_head, d_model, d_k, d_v, dropout=0.1): super().__init__() self.n_head = n_head self.d_k = d_k self.d_v = d_v self.w_qs = nn.Linear(d_model, n_head * d_k, bias=False) self.w_ks = nn.Linear(d_model, n_head * d_k, bias=False) self.w_vs = nn.Linear(d_model, n_head * d_v, bias=False) self.fc = nn.Linear(n_head * d_v, d_model, bias=False) self.attention = ScaledDotProductAttention(temperature=d_k ** 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c607158fd56122090280f57654ed0a92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5db46ebcef997774e7dcfa8a36ad1cd/" rel="bookmark">
			移动端声明及meta标签设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动端meta标签设置
1.设置当前html文件的字符编码
&lt;meta charset="UTF-8"&gt;
2设置浏览器的兼容模式（让IE使用最新的浏览器渲染）
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"/&gt;
3.视口（快捷键：meta:vp）
&lt;meta name="viewport" content="maximum-scale=1.0,minimum-scale=1.0,user-scalable=0,width=device-width,initial-scale=1.0"/&gt;
作用：在移动浏览器中，当页面宽度超出设备，浏览器内部虚拟的一个页面容器，将页面容器缩放到设备那么大展示；
视口的宽度可以通过meta标签设置；
此属性为移动端页面视口设置；
width：视口的宽度，width=device-width：宽度是设备的宽度
initial-scale：初始化缩放，- initial-scale=1.0：不缩放
user-scalable：是否允许用户自行缩放，取值0或1，yes或no
minimum-scale：最小缩放
maximum-scale：最大缩放
一般设置了不允许缩放，就没必要设置最大最小缩放了。
4.Cache-Control头域
&lt;meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/&gt;
Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下,
no-cache指示请求或响应消息不能缓存
no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存
must-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。
5.是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出
&lt;meta http-equiv="Pragma" content="no-cache"/&gt;
6.禁止将页面中的一连串数字识别为电话号码、并设置为手机可以拨打的一个连接。
这个标签的默认值是telephone=yes。
&lt;meta content="telephone=no" name="format-detection"/&gt;
7.删除默认的苹果工具栏和菜单栏
&lt;meta content="yes" name="apple-mobile-web-app-capable"/&gt;
当我们需要显示工具栏和菜单栏时，这个行meta就不用加了，默认就是显示。
8.控制状态栏显示样式
&lt;meta content="black" name="apple-mobile-web-app-status-bar-style"/&gt;
content设置状态栏颜色
9.条件注释
html5shiv让浏览器可以识别html5的新标签；
respond让低版本浏览器可以使用CSS3的媒体查询。
控制显示区域各种属性：
&lt;metacontent="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"name="viewport"&gt;
width - viewport的宽度 height – viewport的高度
initial-scale - 初始的缩放比例
minimum-scale - 允许用户缩放到的最小比例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5db46ebcef997774e7dcfa8a36ad1cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aedb54d67dbb861db8c95c3a1a6ee477/" rel="bookmark">
			图像细化与轮廓操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、图像细化
2、轮廓检测
3、轮廓信息统计
4、轮廓外接多边形
1、图像细化 需要安装扩展包
//图像细化 int test1() { //中文字进行细化 Mat img = imread("LearnCV_black.png",IMREAD_ANYCOLOR); if (img.empty()) { cout &lt;&lt; "请确认图像文件名称是否正确" &lt;&lt; endl; return -1; } //英文字 + 实心圆和圆环细化 Mat words = Mat::zeros(100,200,CV_8UC1);//创建一个黑色的背景图片 putText(words,"Learn",Point(30,30),2,1,Scalar(255),2);//添加英文 putText(words,"OpenCV 4",Point(30,60),2,1,Scalar(255),2); circle(words,Point(80,75),10,Scalar(255), - 1);//添加实心圆 circle(words,Point(130,75),10,Scalar(255),3);//添加圆环 //进行细化 Mat thin1, thin2; ximgproc::thinning(img, thin1, 0);//注意类名 ximgproc::thinning(words,thin2, 0); //显示处理结果 imshow("thinl", thin1); imshow("img", img); namedWindow("thin2",WINDOW_NORMAL); imshow ("thin2", thin2); namedWindow("words",WINDOW_NORMAL); imshow("words", words); waitKey(0); return 0; } 2、轮廓检测 #include &lt;iostream&gt; #include &lt;opencv2/opencv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aedb54d67dbb861db8c95c3a1a6ee477/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238eb86a9ea749bb1e909e9ae7e5907e/" rel="bookmark">
			长亭WAF社区版联动企业微信报警
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Logstash 1.1 logstash容器安装（加入safeline-ce容器网） docker run -di --restart=always --log-driver json-file -p 5044:5044 -p 9600:9600 --name logstash --net safeline-ce logstash:8.8.1
1.2 logstash配置 注意事项：
1.jdbc_driver_library的jar包需要单独下载；
2.waf的日志根据id进行增量更新，id递增则logstash进行output。其中记录id号的user.metadata空文件需要单独创建。其中查询的SQL语句statement 最后需要写明增量条件 &gt; :sql_last_value；
3.日志量较大的话，分页进行配置；
4.Output模块中理论上可以直接通过http的发送给数据给企业微信机器人的webhook，不过这边是通过发送到本地的webhook做了相关makedown的格式调整以及颜色和超链接的优化，再由本地webhook发送至企业微信机器人的webhook。；
5.在38行output中pushwechatalert为后文webhook配置waf.json的id，需要一致。
input { jdbc { jdbc_connection_string =&gt; "jdbc:[postgresql://169.254.0.2:5432/safeline-ce]()" jdbc_user =&gt; "safeline-ce" jdbc_password =&gt; "F6epaIfxxxxxxxxxxxxxxx64dKbUhhc" jdbc_driver_library =&gt; "/usr/share/logstash/jdk/bin/pgsql/postgresql-42.6.0.jar" jdbc_driver_class =&gt; "org.postgresql.Driver" jdbc_paging_enabled =&gt; "true" jdbc_page_size =&gt; "300000" use_column_value =&gt; "true" tracking_column =&gt; "id" tracking_column_type =&gt; "numeric" record_last_run =&gt; "true" clean_run =&gt; false last_run_metadata_path =&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/238eb86a9ea749bb1e909e9ae7e5907e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05eb297ab057a2dd0368da5f3581a6b9/" rel="bookmark">
			二进制转BCD码原理及verilog实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、BCD码概念 BCD码（Binary-Coded Decimal‎），利用四个2进制位储存一个10进制的数，如下表所示。本文所讨论的问题均以8421BCD码为例，十进制的0~9分别用0000~1001来表示。
十进制数23，可表示为0010_0011，十进制数129，可表示为0001_0010_1001。
即分别对个位、十位、百位求对应的BCD码。
​二、二进制数到BCD码的转换 先根据输入不同位数的二进制数，求对应的BCD码
假设输入1位二进制数1，则对应的BCD码为0001，对应十进制1；
若输入2位二进制数11，则BCD码为0011，对应十进制3；
若输入3位二进制数111，则BCD码为0111，对应十进制7；
若输入4位二进制数1110，那么问题来了，BCD码范围在0000~1001之间, 是满10进位的, 它只能表示十进制数0~9，而1110对应的十进制数为14！理应转换为0001_0100才对！
那怎么才能转换成0001_0100呢？
需要对进位的时机做一些处理,
先看看以下的分析：
1110（十进制14，BCD码需要表示十位和个位）是111（十进制7）左移一位的结果，其大小等于二倍的111，同理：
1100（十进制12，BCD码需要表示十位和个位）是110（十进制6）左移一位的结果，其大小等于二倍的110，
1010（十进制10，BCD码需要表示十位和个位）是101（十进制5）左移一位的结果，其大小等于二倍的101，
1000（十进制8，BCD码只需要表示个位）是100（十进制4）左移一位的结果，其大小等于二倍的100，
左移相当于乘2, 那么当二进制数 ≥ 0101b, 即≥5（或&gt; 0100b, 即 ＞4）的时候，左移以后就 ≥ 1010b , 即 ≥ 10，对应的BCD码就需要表示个位和十位了，那么对于一个 4 位的二进制数，先输入的高3位在 ≥5 （或 &gt; 4 ）的时候，要对它们处理一下，使得最低位输入进来后，表示十位的BCD码为0001。
这个处理过程, 称为:
加3移位法 举例说明一下, 先设输入一个4位二进制数, 记作abcd，输出为其对应的8421BCD码.
在最低位输入前，如果高3位的 abc ≥ 0101（或 abc &gt; 0100）时, 对其加上3（即0011）, 最低位d输入, 使得加过3的高3位整体左移一位.
这相当于（abc + 0011）*2+d，即abc*2 + 6 + d，红字的部分就直接 ≥ 16 了，超过了4位2进制数表示的范围, 向更高位进一位！那么此时表示十位的BCD码为0001。
举两个实例, 更容易理解:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05eb297ab057a2dd0368da5f3581a6b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5ac241f06248bc23a4c81f3a78c9baa/" rel="bookmark">
			linux查看cpu与内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看cpu 第一种方法：top命令法
1、首先执行top命令；
2、在top命令的显示界面，按数据键1，即可查看到当前系统中的总cpu数；
第二种方法：通过proc文件系统，直接获取cpu总数量，具体执行如下命令：
# cat /proc/cpuinfo | grep processor 第三种方法：nproc命令
nproc命令用于显示CPU的核心数量。在终端输入以下命令：
nproc 第四种方法：lscpu命令
lscpu命令用于显示CPU的详细信息，包括CPU的核心数量。在终端输入以下命令：
lscpu 这个命令将输出CPU的详细信息，包括CPU的核心数量
查看内存 1、执行free -h，显示内存单位
2、执行free -m
free -m 以 MB 为单位，显示内存使用情况。
free 命令用来显示系统内存状态，包括系统物理内存、虚拟内存（swap 交换分区）、共享内存和系统缓存的使用情况，其输出和 top 命令的内存部分非常相似。
free -m命令输出列表中，第一行显示的是各个列的列表头信息，各自的含义如下所示：
total 是总内存数；
used 是已经使用的内存数；
free 是空闲的内存数；
shared 是多个进程共享的内存总数；
buffers 是缓冲内存数；
cached 是缓存内存数。
Mem 一行指的是内存的使用情况；-/buffers/cache 的内存数，相当于第一行的 used-buffers-cached。+/buffers/cache 的内存数，相当于第一行的 free+buffers+cached；Swap 一行指的就是 swap 分区的使用情况。
可以看到，系统的物理内存为 7741 MB，已经使用了 5623 MB，空闲 1560 MB。而 swap 分区总大小为 7935 MB，目前使用528 MB。
3、输入如下命令，回车运行即可查看内存数据，其中memfree代表剩余内存；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5ac241f06248bc23a4c81f3a78c9baa/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/114/">«</a>
	<span class="pagination__item pagination__item--current">115/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/116/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>