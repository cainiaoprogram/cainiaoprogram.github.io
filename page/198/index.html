<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489891f167e1a16d8f6f9555dfa90114/" rel="bookmark">
			MySQL 如何定时备份数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.mysqldump命令备份数据
2.mysqldump常用操作示例
2.1. 备份全部数据库的数据和结构
2.2.备份全部数据库的结构（加 -d 参数）
2.3. 备份全部数据库的数据(加 -t 参数)
2.4.备份单个数据库的数据和结构(,数据库名mydb)
2.5. 备份单个数据库的结构
2.6. 备份单个数据库的数据
2.7. 备份多个表的数据和结构（数据，结构的单独备份方法与上同）
2.8. 一次备份多个数据库
3.还原 MySQL 备份内容
1. 在系统命令行中，输入如下实现还原：
2. 在登录进入mysql系统中,通过source指令找到对应系统中的文件进行还原：
编写BASH维护固定数量备份文件
使用crontab定期执行备份脚本
cron服务
crontab语法
创建cron脚本
crontab 的使用示例：
在操作数据过程中，可能会导致数据错误，甚至数据库奔溃，而有效的定时备份能很好地保护数据库。
1.mysqldump命令备份数据 在MySQL中提供了命令行导出数据库数据以及文件的一种方便的工具mysqldump,我们可以通过命令行直接实现数据库内容的导出dump,首先我们简单了解一下mysqldump命令用法:
# MySQLdump常用 mysqldump -u root -p --databases 数据库1 数据库2 &gt; xxx.sql 2.mysqldump常用操作示例 2.1. 备份全部数据库的数据和结构 mysqldump -uroot -p123456 -A &gt; /data/mysqlDump/mydb.sql 2.2.备份全部数据库的结构（加 -d 参数） mysqldump -uroot -p123456 -A -d &gt; /data/mysqlDump/mydb.sql 2.3. 备份全部数据库的数据(加 -t 参数) mysqldump -uroot -p123456 -A -t &gt; /data/mysqlDump/mydb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/489891f167e1a16d8f6f9555dfa90114/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa0a3ee8d36df280eb41455ed03e140c/" rel="bookmark">
			npm, cnpm的安装与卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多博客都是，说的不清不楚，对于cnpm只提到了它是国内的镜像，那么对于其安装的包该如何进行删除呢？
npm uninstall XXX -g 安装在其它位置的同理改变 -g 就可以了，即同样使用npm进行卸载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208cff488115800d31ed45fcf6432e8a/" rel="bookmark">
			allegro设置等长后连上线，约束管理器都是是黄色没有数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		allegro设置等长后连上线，约束管理器都是是黄色没有数字
先设bus，然后sigxplorer设置的规则，有没有走线都是这样
出现这种情况，是因为DRC的开关没有打开
确认以下两个地方的DRC开关是否开启
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b468843ec5f2c632d4c2635da9af26b/" rel="bookmark">
			Pandas时间序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas时间序列 1.获取当前时间2.时间戳3.用date_range() 创建固定间隔的时间序列4.转化为时间戳5.将时间序列设置为索引 时间序列（time series）：就是由时间构成的序列，时间序列包含三种应用场景，分别是：
特定的时刻（timestamp），也就是时间戳；
固定的日期（period），比如某年某月某日；
时间间隔（interval），每隔一段时间具有规律性；
1.获取当前时间 可用Python 内置的 datetime 模块来获取当前时间，通过该模块提供的now()方法即可实现。
示例如下：
from datetime import datetime print(datetime.now()) 输出结果：
2022-10-08 14:22:32.346908
2.时间戳 时间戳通常是一个字符序列，唯一地标识某一刻的时间。
Unix时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。
示例如下：
import pandas as pd print(pd.Timestamp('2017-03-01')) #创建时间戳 print(pd.Timestamp(1665597655,unit='s')) #将整型或浮点型表示的时间转换为时间戳 输出结果：
2017-03-01 00:00:00
2022-10-12 18:00:55
3.用date_range() 创建固定间隔的时间序列 该函数主要用于生成一个固定频率的时间索引
date_range(start, end, freq)
start：开始时间；end：结束时间；freq：时间频率，默认为 “D”（天）；Y（年）、Q（季度）、M（月）、W（周）、D（天）、H（时）、T (分钟) 示例如下：
import pandas as pd #freq表示时间频率，每一周变化一次 #print(pd.date_range("2021-12-02", "2021-12-29", freq="W")) #每60s变化一次，用.time只输出时间变化，而不输出日期信息 print(pd.date_range("18:00", "18:10", freq="60s").time) 输出结果：
[datetime.time(18, 0) datetime.time(18, 1) datetime.time(18, 2)
datetime.time(18, 3) datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b468843ec5f2c632d4c2635da9af26b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/518762da7aeeb411fc694370956b10dc/" rel="bookmark">
			net.train()和net.eval()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、net.eval() #评估模式,就是net.train(False)。
设置之后会对前向传播相关进行过滤，会关闭dropout BN等 #如果网络本身没有BN和dropout，那就没区别了。
2、net.train()# 将模型设置为训练模式：默认参数是Train。model.train（）会启动drop 和 BN，但是model.train(False)不会
3、如果模型中有BN层(Batch Normalization）和Dropout，需要在训练时添加model.train()，在测试时添加model.eval()。其中model.train()是保证BN层用每一批数据的均值和方差，而model.eval()是保证BN用全部训练数据的均值和方差；
转载自model.trian()及model.eval() - Parallax - 博客园
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f3d7e923a2a6fa6b2d75d7306950c6/" rel="bookmark">
			Ubuntu防火墙状态整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先打开Ubuntu的终端命令行
要使用bash命令，我们需要打开终端工具，使用“alt+t”快捷键打开终端，也可以使用鼠标点击终端工具;
2、查看当前防火墙状态
使用sudo ufw status命令查看当前的防火墙状态：inactive状态是防火墙关闭状态 active是开启状态。
4、关闭防火墙
在Ubuntu中，使用sudo ufw disable命令来关闭防火墙。执行该命令之后，使用sudo ufw status命令来查看当前防火墙的状态，如果是inactive 说明=防火墙已经关闭。
5、Ubuntu中其他常用的防火墙命令
ufw default allow/deny:外来访问默认允许/拒绝
ufw allow/deny 20：允许/拒绝 访问20端口,20后可跟/tcp或/udp，表示tcp或udp封包。
ufw allow/deny servicename:ufw从/etc/services中找到对应service的端口，进行过滤。
ufw allow proto tcp from 10.0.1.0/10 to 本机ip port 25:允许自10.0.1.0/10的tcp封包访问本机的25端口。
ufw delete allow/deny 20:删除以前定义的"允许/拒绝访问20端口"的规则
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/558b544cf685f39d34e4903e39c38b67/" rel="bookmark">
			TypeScript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习ts之前，先聊一下js，js开发起来快，但是维护起来的成本会高，不适合开发大型的项目，js中没有变量类型，例如let a = 10，10是num，但是a是没有变量类型的，它只是一个局部变量，想存什么，存什么，你在其他地方又把a赋值了一个字符串，但是到头来你想拿a去做运算，那么这个时候就会发生隐患事故了，js不报错。js中定义函数，函数的参数也是没有类型，参数做运算，这个时候就会发生错误了，js是一个动态类型，无论是webstorm 还是vscode,它的提示都不是很完善，因为编辑器不知道它的变量类型。那么js是怎么来的呢，是微软和网景两大公司大战时，网景公司为了开发出的我有你没有的商业份额，天下武功唯快不破，因此js十天左右诞生了，微软公司近几年干的好事就是开发出来了vscode免费供开发者使用，开发出ts更加灵活使用，还有放弃了IE内核转而拥抱了chorm内核
TS并不是取代js，而是在javascirpt为基础构建的语言，即是js的超集，什么是超集，就是js有的，ts也有，但是ts在js的基础上又添加了其他
学习TypeScript先从安装开始
文章目录 一、安装二、案例切入三、语法1、数据类型2、变量声明3、函数定义3.1、函数定义3.2、匿名函数3.3、匿名函数自调用3.4、构造函数3.5、递归函数3.6、Lambda 函数3.7、函数重载 4、Number 对象方法4.1、toExponential()4.2、toFixed()4.3、toLocaleString()4.4、toPrecision()4.5、toString()4.6、valueOf()4.7、时间格式化 5、TypeScript String（字符串）5.1、constructor5.2、length5.3、prototype5.1、charAt()5.2、charCodeAt()5.3、concat()5.4、indexOf()5.5、lastIndexOf()5.6、localeCompare()5.7、match()5.8、replace()5.9、search()5.10、slice()5.11、split()5.12、substr()5.13、substring()5.14、toLocaleLowerCase()5.15、toLocaleUpperCase()5.16、toLowerCase()5.17、toString()5.18、toUpperCase()5.19、valueOf() 6、数组 Array6.1、number 类型的数组6.2、string 类型的数组6.3、数组解构6.4、数组迭代6.5、多维数组6.6、数组方法1、concat()2、every()3、filter()4、forEach()5、indexOf()6、join()7、lastIndexOf()8、map()9、pop()10、push()11、reduce()12、reduceRight()13、reverse()14、shift()15、slice()16、some()17、sort()18、splice()19、toString()20、unshift() 7、Map 对象7.1、创建 Map7.2、迭代 Map 8、元组8.1、定义 访问元组8.2、元组运算8.3、解构元组 9、 联合类型10、 TypeScript 接口10.1、联合类型和接口10.2、接口和数组10.3、多继承实例 11、类11.1、类的继承11.2、多重继承11.3、继承类的方法重写11.4、static 关键字11.5、instanceof 运算符11.5、访问控制修饰符11.6、类和接口 12、TypeScript 对象12.1、鸭子类型(Duck Typing) 13、TypeScript 声明文件13.1、声明文件 四、常识 一、安装 先安装nodejs：https://nodejs.org/dist/v14.15.1-x64.msi更换npm源：npm config set registry https://registry.npmmirror.com安装 typescript：npm install -g typescript安装完成后我们可以使用 tsc 命令来执行 TypeScript 的相关代码，以下是查看版本号：$ tsc -v 二、案例切入 新建一个 app.ts 的文件，代码如下： var message:string = "Hello World" console.log(message) 通常我们使用 .ts 作为 TypeScript 代码文件的扩展名。
转换为js
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/558b544cf685f39d34e4903e39c38b67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f88ff60d1fc04506d76ef41a753358b8/" rel="bookmark">
			Wandb安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Wandb介绍 wandb(Weights &amp; Biases)是一个类似于tensorboard的极度丝滑的在线模型训练可视化工具
wandb这个库可以帮助我们跟踪实验，记录运行中的超参数和输出指标，可视化结果并共享结果。
使用方法 首先安装Wandb pip install wandb 网页端注册账号 按照提示注册一个账号并登录
客户端登录 在你的项目的shell中输入
wandb login 然后去网页端复制你的秘钥
将API keys键入到上面login的命令行中
这样就生成了配置文件
如果你是跑别人的代码的话这样配置就可以用，至于详细使用方法后续继续更新…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446d26fd69797f842c55249c1f881fae/" rel="bookmark">
			dataframe 怎么提取指定的某几行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下： import pandas as pd # 将pandas作为第三方库导入，我们一般为pandas取一个别名叫做pd dfzz=pd.DataFrame({"a":[1.78,1.8,2.8,2.75,5,5,23],"b":[20.8,10,10,30,43,1,12],"c":[23,15,50,3,343,12,95]}) am=pd.DataFrame({"a":[None],"b":[None]}) print(dfzz) print(am) print("") data2 = dfzz.loc[2:3] print(data2) 运行结果：
a b c
0 1.78 20.8 23
1 1.80 10.0 15
2 2.80 10.0 50
3 2.75 30.0 3
4 5.00 43.0 343
5 5.00 1.0 12
6 23.00 12.0 95
a b
0 None None
a b c
2 2.80 10.0 50
3 2.75 30.0 3
Process finished with exit code 0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b35c217b59b0a4603d5b8776c0196c/" rel="bookmark">
			解决gitlab太占内存问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方法就是调一下配置 vim /etc/gitlab/gitlab.rb postgresql[‘shared_buffers’] //减少数据库缓存(默认为256MB 我改为64MB了)
postgresql[‘max_worker_processes’] //减少数据库并发数(默认为8 我改为1了）
postgresql[‘shared_buffers’] //减少数据库缓存(默认为256MB 我改为64MB了)
postgresql[‘max_worker_processes’] //减少数据库并发数(默认为8 我改为1了）
sidekiq[‘concurrency’] //减少sidekiq并发数
sidekiq这两个参数我都改成1了
unicorn[‘worker_memory_limit_min’] = “400 * 1 &lt;&lt; 20” //把400改成100
unicorn[‘worker_memory_limit_max’] = “650 * 1 &lt;&lt; 20” //把650改成150
unicorn[‘worker_processes’] = 1 //减少进程数 把2变成1
prometheus_monitoring[‘enable’] = false //进行postgres_export关闭，经网上查证，关闭后不会对gitLab造成影响，是拓展功能；
当然具体情况自己根据需求进行调节，我是本人使用，就按最小的值进行了设置。
无所谓了，如果企业使用还要按照需求进行适当的调节。
之后重新设置配置
重启服务就可以了
gitlab-ctl reconfigure gitlab-ctl restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d89d6379e2204b0b002f65d60578ba3/" rel="bookmark">
			Java分表策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分表配置 再yml文件中，jdbc数据库连接下面，可以配置分表策略，其中的{0..15}是配置分表的数量。
并且在最后与配置文件 StationTableShardingConfig绑定
sharding: tables: t_station: actual-data-nodes: ds${0}.t_station${0..15} logic-table: t_station table-strategy: standard: sharding-column: org_station_no precise-algorithm-class-name: cn.nhd.freshgo.delivery.config.StationTableShardingConfig 最后面进行绑定表，在启动的时候就可以生效
binding-tables: - t_station 配置文件StationTableShardingConfig
实现类PreciseShardingAlgorithm&lt;String&gt;，重写其中的doSharding方法。可以自定义分表策略。个人分表策略为生成的订单后三位的随机数来作为分表策略 @Slf4j public class StationDelyItemTableShardingConfig implements PreciseShardingAlgorithm&lt;String&gt; { private static final String TABLE_PREFIX = "t_station"; @Override public String doSharding(Collection&lt;String&gt; collection, PreciseShardingValue&lt;String&gt; preciseShardingValue) { String orgStationNo = preciseShardingValue.getValue(); int num = Integer.parseInt(orgStationNo.substring(orgStationNo.length() - 3)); return TABLE_PREFIX + "_" + num; } 此时启动项目的时候，会读到分表策略，查询的时候会自动进行分表查询，不需要在mapper中自己分表查询，按照未分表的方式就可以进行查询。
分表之后的条件查询 由于分表之后，系统默认会按照分表策略进行分表查询，如果查询的时候没有输入数字或者说输入的数字部分和自定义的分表策略，就可能会报出查不出表的sql错误。这时候就需要读取配置文件，并且在代码中进行一个格式判断。
SpringBootShardingRuleConfigurationProperties shardingDataSource = ApplicationContextUtil.getBean(SpringBootShardingRuleConfigurationProperties.class); 取出配置文件中的自己的表，得到分表策略，就是配置文件中的ds${0}.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d89d6379e2204b0b002f65d60578ba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea7851b08fb33c4b94b965e93a4badc2/" rel="bookmark">
			Redis无法正常连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题原因： 把虚拟机重启之后Redis突然不能连接，可能是连接方式不对，或者是防火墙重启等都有可能。
解决方法：
1.Systemctl stop/disable firewall.serrvice 执行命令将防火墙关闭或者禁止防火墙开机启动
或者只打开6379端口
/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT
如果此方法仍然不可以正常连接看方法二
2.检查配置文件 # bind 127.0.0.1 给此段加注释#
protect-mode no 将保护模式关闭
3.打开方式 转到bin目录下 cd /usr/local/bin
redis-server /etc/redis.conf
redis-cli
执行命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ba711f96840cd74233c4c7e5c232cd0/" rel="bookmark">
			Seurat | 强烈建议收藏的单细胞分析标准流程（差异分析与细胞注释）（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1写在前面 本期我们介绍一下如何使用Seurat包进行差异分析，以及如何使用SingleR进行细胞注释。😘
2用到的包 rm(list = ls())
library(Seurat)
library(tidyverse)
library(SingleR)
library(celldex)
library(RColorBrewer)
library(SingleCellExperiment)
3示例数据 这里我们还是使用之前建好的srat文件，我之前保存成了.Rdata，这里就直接加载了。🧐
load("./srat2.Rdata")
srat
4差异分析 首先要和大家说的是，尽量使用counts进行差异分析，而不是你SCTransform等操作后的数据。😉
我们先将assy还原回原始矩阵吧，进行一下过滤。🤜
4.1 初步处理 DefaultAssay(srat) &lt;- "RNA"
srat &lt;- NormalizeData(srat)
srat &lt;- FindVariableFeatures(srat, selection.method = "vst", nfeatures = 2000)
all.genes &lt;- rownames(srat)
srat &lt;- ScaleData(srat, features = all.genes)
4.2 计算所有marker all.markers &lt;- FindAllMarkers(srat, only.pos = T, min.pct = 0.5, logfc.threshold = 0.5)
4.3 Top3 接着我们看看各个Cluster的top3基因是什么。
top3_markers &lt;- as.data.frame(all.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 3, wt = avg_log2FC))
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ba711f96840cd74233c4c7e5c232cd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36d3ef369de84883782447cdc648ef37/" rel="bookmark">
			JavaScript 中 Object.assign() 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. Object.assign()对象的拷贝
2. Object.assign()对象的深拷贝
3. 对象的合并
4. 合并具有相同属性的对象
5. 继承属性和不可枚举属性是不能拷贝
6. 原始类型会被包装为对象
7. 异常会打断后续拷贝任务
8. 总结
1. Object.assign()对象的拷贝 Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
用法：Object.assign(target, ...sources) 【target：目标对象】，【souce：源对象（可多个）】
举个栗子：
const object1 = { a: 1, b: 2, c: 3 }; const object2 = Object.assign({c: 4, d: 5}, object1); console.log(object2.c, object2.d); console.log(object1) // { a: 1, b: 2, c: 3 } console.log(object2) // { c: 3, d: 5, a: 1, b: 2 } 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36d3ef369de84883782447cdc648ef37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5fd572e3897cf738ce14cff1d228bb8/" rel="bookmark">
			记一次Aria2NG无法连接的状况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件描述 Aria2能被其他应用程序访问到，即ws://$YOURIP$:6800/jsonrpc能够下载
AriaNg （HTTPS）连接时提示未连接，打开Console控制台，一片红色：
#!/settings/ariang:1 Access to XMLHttpRequest at 'null://$YOURIP$:6080/jsonrpc' from origin 'https://ariang.js.org' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, isolated-app, chrome-extension, chrome-untrusted, https, edge. null://$YOURIP$:6080/jsonrpc:1 Failed to load resource: net::ERR_FAILED
调查过程 省流：关闭HTTPS连接，转到AriaNg （HTTP）。
首先我想到的是，既然能够远程下载，那么端口不应该出现被关闭的情况；但抱着试一试的心态，依旧尝试打开端口，未果。这时我已经大概猜到可能是HTTP的问题，因为他已禁用。
想到是否大大的一键脚本权限不足？尝试sudo执行，未果。
换个端口？未果。
打算换一个脚本，不过全网大多数是P3TERX.COM大大制作的脚本（感谢！），但我还是找到了其他作者的脚本，bash，运行，打开浏览器，$YOURIP$:6080，行云流水。结果是，能够正常连接。那我就纳闷了。
我想看看到底为什么不给我选择HTTP连接，然后我的鼠标移动到了小问号上，好家伙。
使用Https访问AriaNg时，Http和WebSocket将被禁用。
事已至此，（先吃饭吧），那我就改成全站HTTPS算了。
全站HTTPS Aria2自带的设置略有些繁琐，此处使用一种较为简单的方法。
在Nginx配置文件中加入如下语句：
location ^~ /jsonrpc { proxy_http_version 1.1; add_header Front-End-Https on; proxy_set_header Connection ""; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5fd572e3897cf738ce14cff1d228bb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e10ead16a2d6481577608b2f81a2d344/" rel="bookmark">
			推荐系统专题 | CTR预测跨域处理的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如有错误，恳请指出。
在最近的华为ctr预测比赛中，一开始首先想到的方法是使用深度学习的方法来解决这个跨域的CTR预测问题。但开始上手的时候会发现其中需要解决很多的细节问题，这里把当时需要处理的细节问题与后来解决的方案记录下来，同时算法的开源地址如下：https://github.com/Clichong/CTR。
提出的算法部分借鉴了MiNet的思想，paper：《MiNet: Mixed Interest Network for Cross-Domain Click-Through Rate Prediction》
文章目录 1. 跨域处理的问题2. 代码思路3. 完整框架 1. 跨域处理的问题 Q1：源域数据与目标域的id不完全重叠。比如源域中有ID=100002的用户，但目标域中就没有。 解决方法：直接丢弃没有重叠的用户，使用不上这些数据
Q2：源域数据与目标域重叠的id的曝光次数不一致（也就是行数不一致），无法直接拼接。比如ID=100002的用户，在源域中曝光次数有7条数据，但在目标域中的曝光次数只有1条数据。 解决方法：
1）把某一用户的历史曝光聚合成1条数据，这样尽管源域和目标域的曝光次数不一致，但一个用户最后总是可以聚合成一条数据，可以拼接在一起进行训练。但是会出现测试集无法聚合的问题，本质上还是要判断用户的当前行为是否会点击广告。
2）不聚合目标域，只聚合源域，把源域的每个用户数据聚合成1条，然后与目标域进行拼接。这样聚合的原因是源域的数据是用来辅助目标域来判断的，这样做的背后逻辑是为目标域的用户补充一个相同的源域信息。（可行）
Q3：无论是源域还是目标域的数据集，其测试集都会出现训练集没有出现过的用户ID。 解决方法：
这个其实不算是问题，本质上只需要目标域的用户ID被源域的用户ID覆盖即可，而经过分析， 无论是训练集还是测试集，对于媒体这个领域的用户id号是均完全涵盖广告的用户id 。所以，这里只需要对源域的用户ID进行编码，如果用通用的方法对目标域的用户进行编码。然后安装训练的方法，把源域的用户ID信息聚合成1条，分别拼接在每个目标域的曝光行为上。
通过这样的方法，无论目标域与源域的数据之间的曝光次数多么的不匹配，总可以实现拼接在一起。
Q4：特征处理问题，由于无法直接拼接，特征如何处理？如何进行Embedding操作？ 解决方法：对源域某一用户的历史行为全部聚合成一条信息，再与对应目标域数据进行一一拼接，实现了数据的补充，以解决训练集与测试集数据分布不一致的问题
Q5：列表数据的特征划分 源域所有特征作为补充数据。
目标域可以切分为用户本身特征与广告相关特征还有其他相关特征，而广告相关特征又可以分为目标广告特征与历史广告交互，下面进行汇总。
目标域的特征切分，主要分为4个大类：
1）用户本身特征（user_info）
[user_id, age, gender, residence, city, city_rank, series_dev, series_group, emui_dev, device_name, device_size]
2）目标广告特征（target_ad）
目标广告相关特征包括：[net_type, task_id, adv_id, creat_type_cd, adv_prim_id, inter_type_cd, slot_id, site_id, spread_app_id, Tags, app_second_class, app_score]
3）历史广告交互特征（interact_ad）
历史广告交互特征包括：[ad_click_list_001, ad_click_list_002, ad_click_list_003, ad_close_list_001, ad_close_list_002, ad_close_list_003]
4）其他特征（content_info）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e10ead16a2d6481577608b2f81a2d344/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8aa7ffe4a77787b289d9b8fc9f81fc4/" rel="bookmark">
			儿子的创作画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c606e544d99f65e0d5d6d827179550c5/" rel="bookmark">
			使用不同版本的Java可能会产生多个Gradle守护进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近使用Android studio总是出现如下的提示，不明所以，而且百度了一下网上的方案也没有解决。
Using different JDK locations on different processes might cause Gradle to
spawn multiple daemons, for example, by executing Gradle tasks from a terminal
while using Android Studio.
今天，这个困扰我好久的问题，终于解决了。
守护进程有这样一个特性，比如说，如果守护进程在Java 8运行时，但是请求的环境调用Java 10，这就可能导致出现多个守护进程，也就是上面的英文提示。
我联想到了我电脑上的Android studio就是这样的情况。如下图所示，大家可以看到我指定的是JDK11。
但是我app的gradle文件里指定的Java8，如下图所示。
相信很多同学在gadle文件里使用的都是Java8，但是随着Android Studio的升级，现在的 Android Studio已经可以使用Java11，甚至是更高版本的Java，这就导致了两者的不一致，进而会导致多个守护进程。
我的处理方法是把gradle文件中的Java8给注释掉，全局搜索，使用Java8的地方都注释掉，另外，有的时候gradle文件里可能还指定了jvmTarget为1.8，我也都全部注释了。经过这番操作后，出现多个守护进程的问题终于解决了。
如果本文对您有所帮助，麻烦点个赞，谢谢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65148d9a2843ca535b95d2fefe9b613b/" rel="bookmark">
			labelImg的使用——导入已有标签，避免重复打标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 获得原图和标签文件 我的是yolo格式的标签文件，所以是txt文件，首先文件夹名称为VOC2007，也可以为别的，图片文件和存放标注的文件夹也可以使用自己的名称
目标检测—利用labelimg制作自己的深度学习目标检测数据集
predefined_classes.txt 最好要有，存放的是打标签的时候出现的类别（预定类别）：
VOC2007的目录结构为：
├── VOC2007
│├── JPEGImages 存放需要打标签的图片文件
│├── Annotations 存放标注的标签文件
│├── predefined_classes.txt 定义自己要标注的所有类别（这个文件可有可无，但是在我们定义类别比较多的时候，最好有这个创建一个这样的txt文件来存放类别）
然后存放标签的文件夹，手动创建一个 classes.txt 文件，里面写上你的类别名称（应该要和predefined_classes.txt 对应），存放已有标签的类别都是什么，防止labelImg的闪退，没有这个文件就不会出现已有标签：
2 在 labelImg 中打开 快捷键（对应按键）：
Ctrl+u（Open Dir）：选择标注的图片文件夹
Ctrl+r（Open Save Dir）：选择标注好的label标签存在的文件夹
如果想要出现下图的情况（predefined_classes.txt 对应的类别）
就需要进入VOC2007文件夹中，输入命令打开：
labelimg ./data predefined_classes.txt labelimg 【存放图片文件夹和标签文件夹的总文件夹名】 【预标签文件名】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3597c084f8bc727dfc9a1ca39f37e73d/" rel="bookmark">
			Gradle版本与Java版本的对应关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java version
Gradle version 8
2.0
9
4.3
10
4.7
11
5.0
12
5.4
13
6.0
14
6.3
15
6.7
16
7.0
17
7.3
18
7.5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5cf0f7e862fe2517a850e95348cf423/" rel="bookmark">
			go语言gc机制中三色标记法的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go语言gc 目录 go语言gc介绍Mark and Sweep三色标记法解决办法读写屏障增量更新原始快照优缺点 介绍 go语言的垃圾回收是自动实现的，所谓垃圾回收就是释放哪些不会再使用的程序所占的空间，比如已
经没有引用的变量。垃圾回收过程是与go程序并发执行的。目前go语言v1.8使用的是混合写屏障，在
此之前使用的是Mark and Sweep算法，v1.5是三色标记法。本笔记针对三色标记发经行学习。
Mark and Sweep Mark and Sweep主要是两个步骤：
1.标记(Mark phase)
2.清除(Sweep phase)
第一步，找出不可达的对象，然后做上标记。
第二步，回收标记好的对象。
操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即STW(stop the w orld）。
也就是说，这段时间程序会卡在哪儿。在暂停期间，从根对象开始标记扫描
整个堆，找到所有可达到的对象并做上标记，然后删除所有未标记对象，达
到垃圾回收功能。
缺点
垃圾回收时会暂停整个程序，并且需要扫描整个堆。会影响程序执行效率。
三色标记法 在go中，这个问题是不太可以接受的，所以go后续采用三色标记算法来经行
垃圾回收。
三色标记算法的原则就是把堆中的对象分配到不同颜色的集合当中，通过
黑，白，灰三色来标记对象。其中各颜色的含义是：
黑：对象和它所直接引用的所有对象都被访问过。
灰：这个对象已经被访问过，但是这个对象所直接引用的对象中，至少还有
一个没有被访问到，表示这个对象正在枚举中。
白：这个对象还没有被访问过，在初始阶段，所有对象都是白色，所有都枚
举完仍是白色的对象将会被当做垃圾对象被清理。
根据这些定义，我们可以得出：
1.在可达性分析的初始阶段，所有对象都是白色，一旦访问了这个对象，那
么就变成灰色，一旦这个对象所有直接引用的对象都访问过（或者没有引用
其它对象），那么就变成黑色
2.初始标记之后，GC Root节点变为黑色（GC Root不会是垃圾），GC Root
直接引用的对象变为灰色
3.正常情况下，一个对象如果是黑色，那么其直接引用的对象要么是黑色，
要么是灰色，不可能是白色（如果出现了黑色对象直接引用白色对象的情
况，就说明漏标了，就会导致对象误删，后面会介绍如何解决），这个特性
也可以说是三色标记算法正确性保障的前提条件。
算法大致的流程是（初始状态所有对象都是白色）：
1.首先我们从GC Roots开始枚举，它们所有的直接引用变为灰色，自己变为
黑色。可以想象有一个队列用于存储灰色对象，会把这些灰色对象放到这个
队列中。
2.然后从队列中取出一个灰色对象进行分析：将这个对象所有的直接引用变
为灰色，放入队列中，然后这个对象变为黑色；如果取出的这个灰色对象没
有直接引用，那么直接变成黑色。
3.继续从队列中取出一个灰色对象进行分析，分析步骤和第二步相同，一直
重复直到灰色队列为空。
4.分析完成后仍然是白色的对象就是不可达的对象，可以作为垃圾被清理。
5.最后重置标记状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5cf0f7e862fe2517a850e95348cf423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efc937471f14fc009c45c730bf3668b0/" rel="bookmark">
			各linux操作系统查看内核版本命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文出处 https://linuxlog.cyou/post/18297.html
默认情况下，所有已安装的 Linux 内核及其相关文件都存储在 /boot 目录。 只需使用 find 查看已安装内核列表的命令：
$ find /boot/vmli* /boot/vmlinuz /boot/vmlinuz-5.4.0-64-generic /boot/vmlinuz-5.4.0-65-generic /boot/vmlinuz.old 正如您在上面的输出中看到的，我的 Ubuntu 桌面机器上安装了两个 Linux 内核版本（5.4.0-64 和 5.4.0-65）。
现在我们将看到特定于发行版的方法来找出已安装的 Linux 内核详细信息。 首先，让我们从 Alpine Linux 开始。
检查 Alpine Linux 中已安装的内核 我们可以使用以下 apk info -vv | grep linux 命令检查所有已安装的内核及其版本, 例如:
$ apk info -vv | grep linux libblkid-2.32-r0 - Block device identification library from util-linux linux-virt-4.14.167-r0 - Linux vanilla kernel syslinux-6.04_pre1-r1 - Boot loader for the Linux operating system 列出 Arch Linux 中已安装的内核 要查看 Arch Linux 及其变体（如 Manjaro Linux）中安装的所有内容，请运行以下 pacman -Q linux 命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efc937471f14fc009c45c730bf3668b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1e31f8ea37f5f1f72e8bfb9c9c15c7e/" rel="bookmark">
			用pytorch写个RNN 循环神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		持续创作，加速成长！这是我参与「掘金日新计划 · 10 月更文挑战」的第4天，点击查看活动详情
写代码之前先回顾一下RNN的计算公式：
隐藏层计算公式：
\mathbf{H}_t = \phi(\mathbf{X}_t \mathbf{W}_{xh} + \mathbf{H}_{t-1} \mathbf{W}_{hh} + \mathbf{b}_h)Ht​=ϕ(Xt​Wxh​+Ht−1​Whh​+bh​)
输出计算公式：
\mathbf{O}_t = \mathbf{H}_t \mathbf{W}_{hq} + \mathbf{b}_qOt​=Ht​Whq​+bq​
注意：之前我写过这么一篇：手动实现RNN - 掘金 (juejin.cn) 这个没有调用Pytorch的RNN，是自己从零开始写的。本文是调用了人家现成的RNN，两篇文章虽然都是RNN的代码实现，但是二者有本质区别。
import torch from torch import nn from torch.nn import functional as F from d2l import torch as d2l 复制代码 python人必备导包技术，这段代码不用解释吧。
batch_size, num_steps =32,35 train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps) num_hiddens = 256 rnn_layer = nn.RNN(len(vocab), num_hiddens) 复制代码 设置批量大小batch_size和时间步长度num_step，时间步长度就是可以想象成一个样本中RNN要计算的时间步长度是32。
d2l.load_data_time_machine加载数据集。
注意：这里为了方便，加载数据集时候进行数据预处理，使用的是长度为28的语料库词汇表，不是单词表。词汇表是a~z的字母外加 空格 和&lt;unk&gt;。
设置隐藏层大小的256
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1e31f8ea37f5f1f72e8bfb9c9c15c7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/967d49295cbd2c57e25abe61d895c60c/" rel="bookmark">
			基于ESP8266的四旋翼无人机代码分享，该无人机可以爬墙哦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.整机效果和电路图如下： 2.代码： 代码链接在：https://github.com/AnishDey27/Wall-Climbing-Drone/blob/main/Node%20MCU%20Codes/3_Drone_FInal.ino
源码贴出来吧：
#include&lt;Wire.h&gt;
#include &lt;ESP8266WiFi.h&gt;
#include &lt;WiFiUdp.h&gt;
WiFiUDP UDP;
char packet[4];
//IPAddress local_IP(192, 168, 203, 158);
//IPAddress gateway(192, 168, 1, 158);
//IPAddress subnet(255, 255, 0, 0);
//_________________________________________//聽
int ESCout_1 ,ESCout_2 ,ESCout_3 ,ESCout_4;
int input_PITCH = 50;
int input_ROLL = 50;
int input_YAW = 50;
volatile int input_THROTTLE = 0;
int Mode = 0;
boolean wall_car_init = false;
boolean set_motor_const_speed = false;
int8_t target_axis=0;
int8_t target_dirr=0;
boolean wheal_state = false;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/967d49295cbd2c57e25abe61d895c60c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a870b21b36560b54f5d5233e2d8edbb8/" rel="bookmark">
			Linux中查看压缩文件内容以及归档日志文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 日常工作中，一份归档日志或者压缩文件会很大，如果解压后查看非常浪费时间，那么能不能直接像cat文件一样，不解压就看到文件内容呢
下面列出几种不同压缩包不解压查看方法以及查看归档日志方法。
一、查看压缩包内容
1、zip压缩包
# zip -sf xxx.zip # unzip -l xxx.zip # zipinfo xxx.zip 2、tar压缩包
# tar -tf xxx.tar # tar -tvf xxx.tar -v参数可查看压缩文件的详细属性信息 二、查看归档日志以及压缩包文件内容
查看归档日志（查看为压缩包中文件具体内容）
# zcat xxx.tar.gz # gunzip xxx.tar.gz # zless xxx.tar.gz # less xxx.tar.gz 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51fa0e450dfaddcbdb2146db12d54847/" rel="bookmark">
			结构预测、功能注释、分子对接 —— 这个网站全包了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天向大家介绍一个集合了蛋白结构预测、功能注释、cadd等相关功能的在线服务网站：
https://zhanggroup.org/
如下图，左边栏列出了它的所有功能。挑了几个使用频率可能比较高的几个仔细了解了一下。
I-TASSER I-TASSER是一种蛋白质结构预测和基于结构的功能注释的分层方法。它首先使用LOMETS找寻建模的模板pdb结构，然后经过多次碎片组装模拟最终建立起目标序列的三维结构。这之后将该预测出的三维结构放到他们自己构建的结构功能注释数据库（BioLiP）进行功能注释。
*注意：还网页的所有在线工具均需要注册（限学术邮箱）
C-I-TASSER C-I-TASSER是一种从I-TASSE发展而来的高精度结构预测与功能注释的工具。它首先使用深度学习神经网络训练的contact map预测模型获得你所提交序列的contact map。然后使用LOMETS找寻建模的模板pdb结构，最后用contact-map指导的副本交换蒙特卡洛模拟对模板pdb碎片组装以获得最终的预测结果。将预测的结构上传至功能注释数据库（BioLip）获得蛋白功能注释。大规模测试结果显示C-I-TASSER预测的结构比I-TASSER更准确，尤其是对于没有同源结构模板的目标蛋白而言。
QUARK QUARK不同于前面介绍的两个，它是一种从头结构预测工具。可以仅从序列上就能预测出蛋白的结构，不需要模板结构的存在。它是依靠N多个1-20个长度的氨基酸碎片在使用经验力场的蒙特卡洛模拟的指引下构建模型。对于QUARK而言不需要提供任何多余的模板信息，因此十分适用于没有同源结构的蛋白预测。
C-QUARK C-QUARK也是一种从头结构预测工具。它之于QUARK的关系类似于C-I-TASSER之于I-TASSER的关系。首先，利用ResPRE和NeBcon预测多个contact map；其次借助QUARK实现副本交换蒙特卡洛折叠模拟；最后将模拟产生的多个构象作为“诱饵”喂给SPICKER（一种聚类算法，用于识别一众结构中最接近天然结构的构象）；得到的最终结构用ModRefiner、FASPR这两个工具优化。
LOMETS LOMETS是一种依赖模板的下一代结构预测以及三维结构功能注释的方法。首先它通过引入结构域划分和组装模块处理具有多结构域蛋白，并使用基于梯度的优化工具（deepfold）进行三维结构的构建（基于训练的深度学习模型以及排名靠前的模板引导构建）；接着使用COFACTOR工具进行结构功能注释。大规模测试结果显示，新一代的LOMETS性能较前两代有明显提升。
返回结果包括如下内容：
二级结构预测结果溶剂可及性预测结果contact-map和distance-map预测结果结构域划分结果（可在高级选项中控制是否输出）单独结构域预测的建模结果（可在高级选项中控制是否输出）排名前十的各结构域模板组合而成的模板（可在高级选项中控制是否输出）排名前十的全长序列模板预测的三维结构模型与预测排名第一的结构最相似的10个其他结构GO词条注释(所属生物学过程、细胞组分、分子功能) COACH COACH是一种蛋白-配体结合位点预测的工具。COACH将使用TM-site和S-site这两种方法来预测配体结合位点，这两种方法是从BioLIP功能注释数据库中和靶蛋白子结构/子序列进行比对，找到潜在的配体结合位点。该工具使用时可以输入靶蛋白序列也可以输入靶蛋白三维坐标，只不过输入蛋白序列可能要稍慢，因为这之间多了一步I-TASSER预测三维结构的过程。
COFACTOR COFACTOR可以用于匹配同源结构、预测配体结合位点、GO分析、酶功能注释。首先读入输入的蛋白三维结构信息，接着前往BioLIP数据库中匹配相似的结构，最后以匹配最相似的结构为指导进行功能注释，包括所属生物学过程、细胞组分、分子功能、酶催化功能、配体分子结合位点。
MetaGO MetaGo是一种对蛋白质GO词条（所属生物学过程、细胞组分、分子功能）预测注释的工具。第一步对输入的三维结构进行局部或全局结构的比对；第二步对蛋白序列进行比对；第三步对与其同源蛋白相互作用的分子进行匹配（map）。最后对这三步整合得到蛋白功能信息。
EvoDesign EvoDesign是一款以生物进化轮廓为基础的蛋白设计工具。同时满足单体蛋白以及复合物蛋白设计的需求。对于输入的单体蛋白或复合物蛋白，EvoDesign首先通过结构比对从pdb数据库中找到具有相似折叠方式（对单体蛋白而言）或相似接触面（对复合物蛋白而言）的结构；对这些匹配到的结构和输入结构一起分析，以此作为输入结构蛋白序列设计的指引（在这一过程中，侧链的摆放、骨架的朝向都遵循一种全新的力场EvoEF）。最后返回的结果是设计好的蛋白序列，虽然在该工具下有一个调用I-TASSER建模的选项，但它们并不推荐使用。推荐的做法是将设计好的序列放到I-TASSER模块进行单独预测。
FG-MD FG-MD是一种基于分子动力学的结构优化算法。旨在改进初始模型，使其更接近自然构象。还可以通过消除空间碰撞、改善扭转角和氢键网络来改善局部构象。它首先通过结构比从pdb数据库中找到结构相似的碎片。从碎片分子提出的空间约束应用到MD采样过程中。
EDOCK EDOCK适用于小分子和蛋白的对接。不同于常规对接需要选定结合口袋，EDOCK实现了“盲”对接。具体地，第一步通过我们上文介绍过的COACH进行结合口袋的预测，第二步使用一种改进的图匹配算法将配体分子置于结合口袋中（产生初始构象），第三步采用副本交换的分子动力学模拟手段对小分子进行采样。最后用基于先验经验的综合打分函数挑选出优势构象。
GPCR-I-TASSER GPCR-I-TASSER是一种用于预测G蛋白偶联受体三维结构的计算方法。输入的预测序列首先提交给LOMETS（上文介绍过）用于找寻同源结构。如果同源模板找到了，那么就进行基于模板的碎片重组程序进行模型构建。如果没有找到同源模板，利用ab initio TM-helix folding程序从头组装7次跨膜螺旋束，然后进行GPCR-I-tasser结构重组模拟。最后的结构经由FG-MD（上文提过）工具优化。GPCR-I-TASSER只适用于G蛋白偶联受体结构的预测，一般蛋白的预测一般选用I-TASSER。
CR-I-TASSER CR-I-TASSER是一种辅助冷冻电镜解析结构的工具。他需要同时读入蛋白序列以及cryo-EM电子云密度图。读入的电子云密度图通过卷积神经网络预测Cα位置。读入的蛋白序列用于搜寻同源蛋白结构。同源蛋白模板信息以及预测的Cα位置信息一道指引着蛋白模型的构建。大规模测试表明，CR-I-TASTER在冷冻电镜结构确定方面比其他方法具有显著的优势。
:::
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d386c150da85fa199652ee5008120bcf/" rel="bookmark">
			基于STM32单片机的温度报警器Proteus仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、基于STM32单片机的温度报警器（液晶1602) 功能描述： 由STM32F103单片机最小系统+DS18B20温度传感器+1602液晶显示模块+声光报警模块+独立按键组成。
视频演示链接： 1、基于STM32单片机的温度报警器（液晶1602)
仿真图： STM32F103C8T6芯片工作电压在2.0V-3.6V，最佳工作电压在3.3V。芯片具有上电/断电复位(POR/PDR)、可编程电压检测器。芯片可以外接4~16MHZ外部晶体振荡器，且可分频最高可达72MHZ。内部有经过出厂调校的40KHZRC晶体振荡器，可以产生CPU时钟的PLL；带有校准功能的32khz的RTC振荡器。具有低功耗模式，可在睡眠、停机和待机模式。STM32F103系列具有2个12位模数转换器，1us转换时间，多达16个输入通道。转换范围0-3.6V，转换通道还包含一个内部温度传感器，可以用来测量STM32内部温度。其片上具有定时器、ADC、SPI、IIC、USART功能。STM32F103C8T6具有37个I/O，所以的I/O都可以映射到16个外部中断；除了A/D引脚外，几乎所以的I/O都可以接受5V的信号。该芯片的调试模式可用串行单片机调试（SWD）和JTAG 接口。3个16位定时器，每个定时器有多达4个用于输入捕获/输出比较PWM或脉冲计数的通道和增量编码器输入。1个16位带死区控制和紧急刹车，用于电机控制的PWM高级控制定时器；2个看门狗定时器(独立的和窗口型的)。系统时间定时器：24位自减型计数器。
STM32F103最小系统分为时钟电路和复位电路，我们采用STM32F103C8T6芯片，单片机的时钟电路由一个8M的晶振和两个22P的小电容组成。由于芯片IO口内部自带上拉电阻，因此复位电路只需一个100nF电容组成。BOOT0和BOOT1引脚的高低电平决定着不同的启动模式，选择BOOT0为低电平，即系统存储器被选为启动区域[9]。通过BOOT[1:0]引脚可以选择三种不同启动模式。如下表1通过BOOT[1:0]引脚可以选择三种不同启动模式。对于 STM32 来说也相比51复杂。MCU微处理器是整个系统的核心，相当于整个系统的“大脑”，维持着整个系统的运行，所以微控制必须能够稳定的运行，下图（图3-3）为STM32F103C8T6最小系统电路图，芯片电源为3.3V供电，每一组电源都通过104电容滤波。MCU外围也必须有滤波电容，下载调试电路用最小系统开发板自带的SW接口，接上ST-LINK就可以在线下载调试了。如下图3-4为本次设计使用的STM32F103C8T6最小系统模块内部电路图。
图3-4 STM32F103C8T6最小系统板
本次设计选型用LQPF44封装的STM32F103C8T6为主控，如图中U1，供电电源为3.3V，主要由电源滤波电路、晶振电路、复位电路、SW接口调试电路、BOOT模式选择电路等组成。
（1）STM32最小系统电路
最小系统电路由STM32F103C8T6单片机芯片和时钟电路，时钟电路由一个8M晶振和两个30pf电容串联接入时钟输入脚。
（2）启动模式选择电路
通过BOOT引脚可以选择不同的启动模式，如下表1.1所示，通过BOOT0和BOOT1脚的电平状态从而控制器启动模式。
（3）复位电路，STM32具有软件复位和硬件复位，上电复位芯片需要足够时间进行初始化，需要在NRST脚保持低电平信号，利用复位电路的电容充放电作用，STM32启动时由低电平变高，芯片从而复位，转换芯片正常工作。
表1 STM32启动模式表
启动模式选择脚
启动模式
说明
BOOT0
BOOT1
X
0
主闪存存储器
启动区域为主闪存存储器
0
1
系统存储器
启动区域为系统存储器
1
1
内置SRAM
启动区域为内置SRAM
程序源码： #include "delay.h" #include "LCD1602.h" #include "ds18b20.h" #include "key.h" #include "led.h" #include "timer.h" #include "stdio.h" #include "stdlib.h" short Tpup = 37,Tpdw = 10;	//温度上限 默认37 下限默认10 int main(void) {	short temprature;	//定义温度变量 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	//设置中断优先级分组为组2：2位抢占优先级，2位响应优先级 delay_init();	//延时函数初始化 Lcd1602_Init();	//液晶1602初始化 LED_Init(); DS18B20_Init(); while(DS18B20_Init()!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d386c150da85fa199652ee5008120bcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a91b7177910ba282b53759641ef2cad/" rel="bookmark">
			APG(Accelerate Proximal Gradient)加速近端梯度算法 和 NAG(Nesterov accelerated gradient)优化器原理 (一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言APG(Accelerate Proximal Gradient)加速近端梯度算法[^1]PGD (Proximal Gradient Descent)近端梯度下降法推导[^2]Example of Proximal Gradient Descent APG(Accelerate Proximal Gradient)加速近端梯度算法推导Back to lasso example: 总结引用 前言 近期在阅读Data-Driven Sparse Structure Selection for Deep Neural Networks论文时，用到里面APG-NAG相关优化器的知识，原论文方法采用mxnet去实现的，在这里想迁移到pytorch中。因此手撕一下APG和NAG相关的知识。
APG(Accelerate Proximal Gradient)加速近端梯度算法1 该方法是近端梯度下降法(Proximal Gradient Descent)的一种扩展方法，溯源的话应该早于2008年。在了解APG方法之前，首先需要了解一下近端梯度下降法(Proximal Gradient Descent).
PGD (Proximal Gradient Descent)近端梯度下降法推导2 直接套用Chen Xin Yu2的原话：“近端梯度下降法是众多梯度下降 (gradient descent) 方法中的一种，其英文名称为proximal gradident descent，其中，术语中的proximal一词比较耐人寻味，将proximal翻译成“近端”主要想表达”（物理上的）接近"。与经典的梯度下降法和随机梯度下降法相比，近端梯度下降法的适用范围相对狭窄。对于凸优化问题，当其目标函数存在不可微部分（例如目标函数中有 1-范数或迹范数）时，近端梯度下降法才会派上用场。"
近端梯度下降法(Proximal Gradient Descent)主要用于解决目标函数中包含不可微的凸函数的问题。即，假定存在，
f ( x ) = g ( x ) + h ( x ) \begin{align} f(x)=g(x)+h(x) \end{align} f(x)=g(x)+h(x)​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a91b7177910ba282b53759641ef2cad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6de3fd7f2ab5799985ac11941db7591/" rel="bookmark">
			解决使用 Android studio 时出现“The emulator process for AVD xxx has terminated.”的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.不是路径中存在中文问题
2.不是安装所在的盘，磁盘内存不足的问题
不知道下面步骤有没有用：
默认再C盘，“C:\Users\电脑名\.android”，把这个目录，复制到安装SDK的目录下，配置环境变量
系统环境变量配置：ANDROID_SDK_HOME，值为：D:\Android\SDK\.android
实际解决问题是，需要进入电脑的Bios界面，我是ThinkPad，确认电脑关机后，重启看到联想logo时，回车（Enter），然后F1，进入后：Security-&gt;Virtualization然后disable-&gt;enable，保存重启，打开Android studio，运行虚拟机，正常启动；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e3ee6ff586b41dbf342b63cfd6a181/" rel="bookmark">
			uniapp手机推送（在线）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.UniPush 是什么 UniPush 是 DCloud 联合个推公司推出的集成型统一推送服务，是所有uni-app开发者首选的推送服务。（其实就是uniapp用你的uniapp注册了个推的账号，所以操作的时候也可以看个推的文档）
uni-push | uni-app官网
1.配置unipush信息 开发者中心：开发者中心
1.APPID 可以从这个界面找到 appip。
2.应用名称 随便取
3.Android 包名 随便取，不过要符合格式。且后面自定义基座的包名要和这个一致
4.Android 应用签名 这个要自己生成，生成的链接 ：Android平台签名证书(.keystore)生成指南 - DCloud问答
上图红色箭头就是签名。
5.iOS BundleId: 随便取
6.查找自己的 AppID，AppKey，AppSecret，MasterSecret AppID，AppKey，AppSecret，MasterSecret
在创建推送下面的应用配置里。
2.在manifest.json中配置 配置如上图。
3.app端集成推送 在vue.app中的 onLaunch 里配置。
代码如下：
&lt;script&gt; export default { onLaunch: function() { //监听点击推送的事件 plus.push.addEventListener('click', (msg)=&gt;{ console.log(msg); }); //监听在线推送的事件 // receive接收到服务端过来的数据,需要自建通知栏展示， plus.push.addEventListener('receive', (msg)=&gt;{ console.log(msg); }); }, onShow: function() { console.log('App Show') }, onHide: function() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5e3ee6ff586b41dbf342b63cfd6a181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3297788c8d3c40ca41bd05fdeb3118f/" rel="bookmark">
			基于Hadoop的数据仓库Hive安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基于Hadoop的数据仓库Hive安装1、安装Hive1.1 下载Hive源程序1.2 解压并重命名1.3 修改文件权限1.4 配置环境变量1.5 配置hive-site.xml 2、安装并配置MySQL2.1 下载mysql jdbc包2.2 解压并拷贝2.3 启动并登陆mysql shell2.4 新建hive数据库2.5 配置mysql允许hive接入2.6 启动hadoop2.7 启动hive2.8 退出hive 3、Bug1（已解决）4、Bug2（待解决）5、Bug3（待解决） 基于Hadoop的数据仓库Hive安装 1、安装Hive 1.1 下载Hive源程序 Apache官方：https://www.apache.org/dyn/closer.cgi/hive/
清华大学镜像：https://mirrors.tuna.tsinghua.edu.cn/apache/hive/
在Ubuntu中，使用wget命令下载：
wget https://mirrors.tuna.tsinghua.edu.cn/apache/hive/hive-3.1.3/apache-hive-3.1.3-bin.tar.gz 好像失败了（网速问题），算了，还是用Xshell传过来吧！！
1.2 解压并重命名 sudo tar -zxvf ./apache-hive-3.1.3-bin.tar.gz -C /usr/local # 解压到 /usr/local 中 sudo mv apache-hive-3.1.3-bin hive # 重命名为hive 1.3 修改文件权限 sudo chown -R hadoop:hadoop hive 注意：上面的hadoop:hadoop是用户组和用户名，如果你当前使用用户名user_name登录了Linux系统，则把hadoop替换成user_name。
1.4 配置环境变量 为了方便使用，我们把hive命令加入到环境变量中去，使用vim编辑器打开.bashrc文件，命令如下：
sudo vi ~/.bashrc 添加如下内容：
export HIVE_HOME=/usr/local/hive export PATH=$PATH:$HIVE_HOME/bin export HADOOP_HOME=/usr/local/hadoop HADOOP_HOME需要被配置成你系统上Hadoop的安装路径，比如这里是安装在/usr/local/hadoop目录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3297788c8d3c40ca41bd05fdeb3118f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6468f43d03958fc2f2a0dae3cb60d369/" rel="bookmark">
			Java 可变参数及集合工具类（Collections）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 可变参数及集合工具类（Collections） 1.可变参数 假如需要定义一个方法求和，该方法可以灵活的完成如下需求：
计算一个数据的和计算2个数据的和计算3个数据的和计算N个数据的和，甚至可以支持不接受参数进行调用 /** * 目标：初步理解可变参数 * */ public class MethodCollection { public static void main(String[] args) { sum(1); sum(2, 3); sum(1,23, 435); sum(new int[] {10, 20, 30}); } public static void sum(int...para){ //注意，可变数组在方法内部其实就是一个数组 System.out.println(para.length); } } 可变参数
可变参数用在形参中可以接收多个数据可变参数的格式：数据类型…参数名称 可变参数的作用
传输参数非常灵活，方便。可以不传输参数，可以传输1个或者多个，也可以传输一个数组可变参数在方法内部本质就是一个数组 可变参数的主意事项
一个形参列表中可变参数只能有一个可变参数必须放在形参列表的最后面 2.集合工具类 Collection集合工具类
java.utils.Collection:是集合工具类作用：Collections并不属于集合，是用来操作集合的工具类 Collections常用的API
Collections排序相关API
使用范围：只能对于List集合的排序 import java.util.ArrayList; import java.util.Collections; import java.util.List; public class MethodCollections { public static void main(String[] args) { String name1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6468f43d03958fc2f2a0dae3cb60d369/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ead1900c5cd3acf8bb37a9ce3dcc36/" rel="bookmark">
			软考-错题积累（计算机系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.1 复杂与精简指令系统计算机
1.2 映射
（1）直接映射
（2）全相联映射
（3）组相联映射
1.3 原码、反码、补码
1.4内存容量
1.5串行、并行、专用总线
1.6 程序运行
1.7 指令周期
1.8 浮点数格式
1.9 海明码
1.10Cache
1.11 CPU中的寄存器
1.12输入输出控制方式
1.13可靠度
1.14 存储器
1.15 中断方式与DMA方式
1.16 浮点数加减规则
1.17 BIOS保存在ROM上
1.18 补码表示的范围
1.19奇偶校验
1.20程序的局部性原理
1.21循环冗余校验码
1.22 时钟周期、主频、MIPS
1.23中断向量
1.1 复杂与精简指令系统计算机 CISC（Complex Instruction Set Computer）：复杂指令系统计算机；
特点：指令数量众多；指令使用频率相差悬殊；支持很多种寻址方式；变长的指令；指令可以对主存单元中的数据直接进行处理；以微程序控制为主。
RISC（Reduced Instruction Set Computer）：精简指令系统计算机；
特点：指令数量少；指令的寻址方式少；指令长度固定；以硬布线逻辑控制为主；单周期指令执行，采用流水线技术；优化的编译器：RISC 的精简指令集使编译工作简单化；CPU 中的通用寄存器数量多，一般在 32 个以上，有的可达上千个。
VLSI（Very Large Scale Integration Circuit）：超大规模集成电路；
WLIW（Single Instruction Multiple Data）：单指令流多数据流；
VLIW（Very Long Instruction Word）：超长指令字；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53ead1900c5cd3acf8bb37a9ce3dcc36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e779031fde351d868c27232cabdd331/" rel="bookmark">
			入手3060显卡真香，却不知如何配置YOLOv5环境？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		！！此文若有版权上的冲突，望及时联系本人，本人会在受到消息的第一时间进行修改。！！
！！！注：请整篇文章读完再进行操作！！！
（文采有限、排版不佳，望各位读者多多包涵）
最近刚入手联想的r9000p/RTX3060系列笔记本，作为学生党使用真香~
但随之而来的问题就是由于硬件导致一些软件环境搭建十分繁琐，本人在学习机器视觉时需要借助YOLOv5来进行预训练，AI圈都知道深度学习跑起来需要NVIDIA显卡，但是3060显卡却不知如何正确匹配对应版本的pytorch，匹配之后YOLOv5依然无法正常运行到想要的结果。就以上问题，本人在此发表一篇博客，希望对各位读者起到一定帮助，同时作为以后自己搭建的参考。
1、进行YOLOv5训练的第一步就是配置一个虚拟环境（默认读者已经安装了Anaconda和pycharm），这边我们点击下方红勾，输入代码
conda create -n yolo python=3.8.5
创建一个名为yolo，python版本为3.8.5的虚拟环境(如果名字不同请记住自己的环境名)
2、虚拟环境创建成功后，输入exit()退出虚拟环境，打开你从网上下载、用yolov5实现的小demo，这边我也可以给各位推荐一个我看过的up主的视频链接(视频内含其口罩demo下载)
手把手教你使用YOLOV5训练自己的目标检测模型_哔哩哔哩_bilibili
在你的demo下载完成后找到下载的文件夹，输入cmd，如下图：
选中输入cmd之后开启终端模式，如下图所示
在此路径下激活刚刚你创建的虚拟环境，输入代码为：
activate yolo
红框为你的虚拟环境名，表示此demo已经在虚拟环境下运行。
3、在正式的YOLOv5环境准备前，还需要一个关键步骤就是修改镜像源，修改代码如下：
conda config --remove-key channels conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/pytorch/ conda config --set show_channel_urls yes pip config set global.index-url https://mirrors.ustc.edu.cn/pypi/web/simple 直接将其复制到虚拟环境的终端内
到此准备完毕，开始YOLOv5的环境准备。
4、因为其他旧版本的都可搜到，本人在这就直接讲3060（其余3050系列显卡应该都一样）系列该如何搭配，避免读者们踩坑。
本人先使用的是pytorch 1.8.0版本的，正版链接：Previous PyTorch Versions | PyTorch，输入代码
修改完镜像源之后下载会很快，
conda install pytorch==1.10.1 torchvision==0.11.2 torchaudio==0.10.1 cudatoolkit=11.3 -c pytorch 下载完成后如图，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e779031fde351d868c27232cabdd331/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3605c46f505fc2f4c8ae3bfd1cc935ef/" rel="bookmark">
			渗透测试神器-CobaltStrike
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：仅用于本人学习的笔记记录，禁止进行传播分享，一旦造成严重后果与本人无关！！！
一、CobaltStrike工具的介绍、安装
不建议在本机运行
后渗透：获得了一定权限之后进行渗透（webshell）
团队作战的工具
共享！！
CS拿到A主机的权限，你的成员都可以去控制A主机
cs基于java环境写好的，所以先安装jdk，在安装的时候关闭掉杀毒软件（建议在虚拟机里安装）
二、CobaltStrike基础操作
1、cmd进入到cs的目录下
2、设置服务端teamserver.bat
3、双击start.bat，设置账户名密码进入（这里加载了一个汉化包 -javaagent:CobaltStrikeCN.jar）
开启后我们需要设置监听生成木马
1、开启监听
2、对监听进行设置，HTTPHosts设置服务器IP地址
3、生成木马
4、设置会话时间，默认的是一分钟一个，我们设置一秒一个包
5、进程注入（系统进程桌面进程explorer.exe）：
把恶意代码植入到正常的程序中，只有将正常的程序关掉才能杀掉这恶意代码
三、CobaltStrike插件
cs加载插件有两种方法
1、服务端加载（加载后团队中都可以使用）
2、客户端加载（和服务端无关，仅限于客户端）
发现这个里面的娱乐模式还是蛮有意思的
四、CobaltStrike自启动
病毒远控自启动：
1、任务计划程序
可以自动开启程序
2、做成服务，服务是开机自启的
需要一个xml文件里面的内容为
&lt;service&gt;
&lt;id&gt;hjw123&lt;/id&gt;
&lt;name&gt;hjw123&lt;/name&gt;
&lt;description&gt;This severce runs hjw continuous integration system.&lt;/description&gt;
&lt;executable&gt;C:\Users\Administrator\Desktop\666a.exe&lt;/executable&gt;
&lt;log mode="roll"&gt;&lt;/log&gt;
&lt;/service&gt;
以管理员运行cmd，输出a.exe install运行exe服务
当cs开启时我们的exe才能自启动，关掉的话启动不了
宏病毒：
wps：宏是收费的
office：低版本自动运行，高版本手动开启（ 视图 -&gt; JS宏 ）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae4e24028120a0d4e28833dc80053aec/" rel="bookmark">
			使用Python批量将PDF转换成图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用自 https://zhuanlan.zhihu.com/p/307990818。
import os import time import fitz #以下为批量PDF转图片的代码 pdf_file = r'F:\Project\案例\pdf&amp;excel拆分\PDF' #PDF电子发票文件夹路径 pdf_file_list = os.listdir(pdf_file) PNG_path= r'F:\Project\案例\pdf&amp;excel拆分\PNG' #PNG文件夹路径 PNGfile_suffix = '.png' #后缀 try: #是否有这个路径 if not os.path.exists(PNG_path): #创建路径 os.makedirs(PNG_path) except IOError as e: print("IOError") except Exception as e: print("Exception") print("正在检测中，请耐心等待".center(60)) time.sleep(1) print('预计识别文件如下：') for i in range(len(pdf_file_list)): print(pdf_file_list[i]) time.sleep(1) print('\n') print('预计识别文件数量：'+str(len(pdf_file_list))) time.sleep(1) print('\n') print('图片生成中……') print('\n') time.sleep(1) for id in pdf_file_list: pdf = fitz.open(os.path.join(pdf_file,id)) try: for pg in range(0,pdf.page_count):#pdf.pageCount page = pdf[pg] rotate = int(0) zoom_x = 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae4e24028120a0d4e28833dc80053aec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0adb95577453144a4e48f03d16759b78/" rel="bookmark">
			机器学习之SVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、SVM基本介绍二、SVM工作原理1. 线性支持向量机（数据可分）2. 软边距支持向量机（数据不可分） 三、sklearn实现SVM注：SVM涉及距离，需要先数据标准化处理1. 线性SVMLinearSVC() 构造函数的参数及默认值 2. 非线性SVM（1）线性SVM中使用多项式特征（2） 使用多项式核函数的SVMSVC() 构造函数的参数及默认值 3. 使用SVM思想解决回归问题 总结优缺点问题 一、SVM基本介绍 Support Vector Machine支持向量机
用于分类问题，也可以用于回归问题监督学习算法 二、SVM工作原理 最大化margin，几何间隔越大，分类的把握性越大，即错误率越低
1. 线性支持向量机（数据可分） 注意分类类别划分为了 -1和1，而不是0和1，是为了后续（图1最下行）将两式子化为一个式子。y取-1，数据点代入也小于0，相乘还是大于1。
2. 软边距支持向量机（数据不可分） 三、sklearn实现SVM 注：SVM涉及距离，需要先数据标准化处理 上图为纵轴范围0-10000，下图将纵轴范围标准化到0-1 若不标准化处理，会严重影响求出的决策边界 1. 线性SVM import numpy as np import matplotlib.pyplot as plt from sklearn import datasets iris = datasets.load_iris() X = iris.data y = iris.target X = X[y &lt; 2, :2] # 只取前两个特征 y = y[y &lt; 2] # 只取y=0 y=1,二分类问题 from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0adb95577453144a4e48f03d16759b78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91b34addd35150e021e23c24dc8b758c/" rel="bookmark">
			Java常见跳出循环的4种方式总结、switch中的break与return、lamada表达式中foreach如何正确选择退出方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题 跳出循环中break、continue、return 、循环标记方式含义lamada表达式中foreach使用returnlamada表达式中foreach如何退出循环break在switch中的应用switch 中 break和return的区别Java中switch和if语句的区别 java中的循环死循环 循环也由四部分组成循环之间的区别： 跳出循环中break、continue、return 、循环标记方式含义 continue：中止本次循环，继续下次循环。continue以后的循环体中的语句不会继续执行，下次循环继续执行，循环体外面的会执行 break：直接结束一个循环，跳出循环体。break以后的循环体中的语句不会继续执行，循环体外面的会执行 return：return的功能是结束一个方法。 一旦在循环体内执行return，将会结束该方法，循环自然也随之结 循环标记场景：多层循环，如果在里层循环，达到某个条件后，结束指定循环 continue：
continue语句和break语句差不多。不同的是，它不是退出一个循环，而是跳出当前循环，进行下一轮循环。（不往下执行循环内的语句,直接返回最内层的循环开头,并继续执行循环。）
List&lt;String&gt; c = Arrays.asList("1", "2", "3", "4", "5"); for (int i = 0; i &lt; 2; i++) { for (String s : c) { if (s.equals("3")) { continue; } System.out.print(s + " "); } } //输出 1 2 4 5 1 2 4 5 break：
break语句只有在循环语句和switch语句中使用才是合法的，经常用来跳出循环，不会执行后续循环，但是会继续执行循环之后的。（跳出所在的循环体， 并且可以执行循环外的程序。）
List&lt;String&gt; c = Arrays.asList("1", "2", "3", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91b34addd35150e021e23c24dc8b758c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ee12b6e5e4be8200c1ed72a0ff98eb0/" rel="bookmark">
			QObject
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、描述 1、QObject类是所有Qt对象的基类。
2、QObject是Qt对象模型的核心。该模型的核心特性是一种非常强大的无缝对象通信机制，称为信号和槽。可以使用connect()将信号连接到槽，并使用disconnect()销毁连接。为了避免永无止境的通知循环，可以使用blockSignals()临时阻止信号。而connectNotify()和disconnectNotify()使跟踪连接成为可能。
3、对象通过对象树的形式组织。当创建一个以另一个对象为父对象的QObject时，该对象将自动将自己添加到父对象的children()列表中。父对象拥有对象的所有权，父对象将在析构函数中自动删除它的子对象。可以使用findChild()或findChildren()查找对象的子对象。
4、每个对象都有一个objectName()，其类名可以通过相应的metaObject()找到。可以使用inherits()函数确定对象的类是否继承QObject继承层次结构中的另一个类。
5、当一个对象被删除时，它会发出一个destroyed()信号。
6、QObjects可以通过event()接收事件并过滤其他对象的事件。可以重新实现方便的处理程序childEvent()，以捕获子事件。
7、QObject在Qt中提供了基本的计时器支持。
8、对于实现信号、槽或属性的任何对象，Q_OBJECT 宏都是必需的。还需要在源文件上运行元对象编译器。强烈建议在QObject的所有子类中使用此宏，不管它们是否实际使用信号、槽和属性，否则可能会导致某些函数表现出奇怪的行为。
9、所有Qt widgets都继承QObject。函数isWidgeType()返回一个对象是否是一个widget。它比qobject_cast&lt;QWidget *&gt;(obj)或obj-&gt;inherits(“QWidget”)快得多。
二、线程相关 1、当QObject接收到信号或发布的事件时，槽函数或事件处理程序将在对象所在的线程中运行。（如果QObject没有线程关联（即如果thread()返回nullptr），或者如果它位于没有运行事件循环的线程中，则它无法接收信号或发布的事件）
2、默认情况下，QObject存在于创建它的线程中。可以使用thread()查询对象的线程关联，并使用moveToThread()更改对象的线程关联。
3、所有QObject必须与其父对象位于同一线程中。因此：
如果所涉及的两个QObject位于不同的线程中，setParent()将失败。当一个QObject对象被移动到另一个线程时，该对象的所有子线程也将被自动移动。如果QObject对象有父对象，moveToThread()将失败。如果QObject对象是在QThread::run()中创建的，则它们不能成为QThread对象的子对象，因为QThread对象不在调用QThread::run()的线程中。 注意：QObject的成员变量不会自动成为其子变量。必须通过向子构造函数传递指针或调用setParent()来设置父子关系。如果没有此步骤，调用moveToThread()时，对象的成员变量将保留在旧线程中。
三、无复制构造函数和赋值运算符 QObject既没有复制构造函数，也没有赋值运算符。它们是在宏Q_DISABLE_COPY()中设置了禁止生成。实际上，所有从QObject派生的Qt类（直接或间接）都使用这个宏来声明它们的复制构造函数和赋值操作符是私有的。
这带来的结果是应该使用指向QObject（或者指向自定义的QObject子类）的指针。例如，如果没有复制构造函数，就不能使用QObject的子类作为存储在某个容器类中的值，必须存储指针。
例：企图拷贝和赋值QWidget时会报错：
函数=delete
四、自动连接（ui文件） Qt的元对象系统提供了一种机制来自动连接QObject子类及其子类之间的信号和槽。只要用合适的对象名定义对象，并且槽遵循简单的命名约定，就可以在运行时通过QMetaObject::connectSlotsByName()函数执行此连接。
uic生成调用此函数的代码，以便在使用Qt Designer创建的窗体上的小部件之间执行自动连接。
例：ui文件拖入一个按钮，objectName设置为btn，则按钮发出clicked()信号时就会调用on_btn_clicked()槽函数（此函数必须声明为槽）。他们之间通过QMetaObject::connectSlotsByName()关联起来的。
五、动态属性 可以在运行时向QObject实例添加动态属性，也可以从QObject实例中删除动态属性。动态属性不需要在编译时声明，但是它们提供了与静态属性相同的优点，并且使用相同的API进行操作—使用property()读取它们，使用setProperty()写入它们。
Qt Designer支持动态属性，并且标准Qt小部件和用户创建的表单都可以被赋予动态属性。
六、国际化（I18n） 所有QObject子类都支持Qt的翻译特性，使得将应用程序的用户界面翻译成不同的语言成为可能。要使用户可见的文本可翻译，必须将其包装在对tr()函数的调用中。
七、属性成员 QObject只有一个属性：objectName，用来包含对象的名称，当要查找子对象时可以使用findChild()通过对象名称查找对象。默认此属性为空。
八、成员函数 1、QObject(QObject *parent = nullptr)
构造函数。将parent设置为nullptr将构造一个没有父对象的对象。如果对象是一个QWidget，它将成为一个顶级窗口。这个函数可以通过元对象系统和QML调用。
2、void deleteLater()
发起一个事件，当事件循环处理到该事件时删除当前对象，源码：
void QObject::deleteLater() { QCoreApplication::postEvent(this, new QDeferredDeleteEvent()); } 如果调用此函数时事件循环未运行，则一旦启动事件循环，该对象将被删除。如果在主事件循环停止后调用deleteLater()，则不会删除该对象。从Qt4.8开始，如果对没有运行事件循环的线程中的对象调用deleteLater()，则该对象将在线程完成时被销毁。
可参考：Qt deleteLater原理
3、[signal] void destroyed(QObject *obj = nullptr)
对象被删除之前发送此信号。
4、[signal] void objectNameChanged(const QString &amp;objectName)
此信号在对象名称更改后发出。新对象名作为参数传递。注意：这是一个私有信号。它可以用于信号连接，但不能由用户发射。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ee12b6e5e4be8200c1ed72a0ff98eb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c45c50ed221d66f258900fde558242f/" rel="bookmark">
			【CV知识点汇总与解析】| 参数初始化篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【CV知识点汇总与解析】| 参数初始化篇 【写在前面】 本系列文章适合Python已经入门、有一定的编程基础的学生或人士，以及人工智能、算法、机器学习求职的学生或人士。系列文章包含了深度学习、机器学习、计算机视觉、特征工程等。相信能够帮助初学者快速入门深度学习，帮助求职者全面了解算法知识点。
1、什么是参数初始化？ 初始化参数指的是在网络模型训练之前，对各个节点的权重和偏置进行初始化赋值的过程。
在深度学习中，神经网络的权重初始化方法（weight initialization）对模型的收敛速度和性能有着至关重要的影响。模型的训练，简而言之，就是对权重参数W的不停迭代更新，以期达到更好的性能。而随着网络深度（层数）的增加，训练中极易出现梯度消失或者梯度爆炸等问题。因此，对权重W的初始化显得至关重要，一个好的权重初始化虽然不能完全解决梯度消失或梯度爆炸的问题，但是对于处理这两个问题是有很大帮助的，并且十分有利于提升模型的收敛速度和性能表现。
2、模型参数更新的过程 在总结参数初始化的原则之前，先简单看一下网络模型运行的过程，参数初始化的目的是使网络模型能够更好地进行训练。现在大部分的网络训练依然采用误差的反向传播算法，误差反向传播分为正反两个过程，这里就不再赘述了，先引入几个概念。下面这幅图是一个神经网络的某一个层：
由图可知，每一个层内部的组成主要有：
输入X/hi：来自原始样本X的输入（i=0）或上一层（第i−1层）的输出hi。
权重W：网络模型训练的主体对象，第ii层的权重参数wi。
状态值z：作为每一层激活函数f的输入，处于网络层的内部，所以称之为状态值。
激活值h：状态值zi经过了激活函数f后的输出，也就是第i层的最终输出hi；
数据在网络模型中流动的时候，则会有（这里默认没有偏置项B）：
z i = w i ⋅ h i − 1 h i = f ( z i ) \begin{aligned} z^{i} &amp;=w^{i} \cdot h^{i-1} \\ h^{i} &amp;=f\left(z^{i}\right) \end{aligned} zihi​=wi⋅hi−1=f(zi)​
然后在反向传播的过程中，由于是复合函数的求导，根据链式法则，会有两组导数，一个是损失函数Cost对z的导数，一个是损失函数Cost对W的导数。
3、参数初始化的几个基本条件 什么样的初始化参数才是最好的呢？
需要牢记参数初始化的目的是为了让神经网络在训练过程中学习到有用的信息，这意味着参数梯度不应该为0。而我们知道在全连接的神经网络中，参数梯度和反向传播得到的状态梯度以及入激活值有关——激活值饱和会导致该层状态梯度信息为0，然后导致下面所有层的参数梯度为0；入激活值为0会导致对应参数梯度为0。所以如果要保证参数梯度不等于0，那么参数初始化应该使得各层激活值不会出现饱和现象且激活值不为0。我们把这两个条件总结为参数初始化条件：
初始化必要条件一：各层激活值不会出现饱和现象。
初始化必要条件二：各层激活值不为0。
4、过大或者过小的初始化的危害
如果权值的初始值过大，则会导致梯度爆炸，使得网络不收敛；过小的权值初始值，则会导致梯度消失，会导致网络收敛缓慢或者收敛到局部极小值。
如果权值的初始值过大，则loss function相对于权值参数的梯度值很大，每次利用梯度下降更新参数的时，参数更新的幅度也会很大，这就导致loss function的值在其最小值附近震荡。
而过小的初值值则相反，loss关于权值参数的梯度很小，每次更新参数时，更新的幅度也很小，着就会导致loss的收敛很缓慢，或者在收敛到最小值前在某个局部的极小值收敛了。
5、常见初始化方法 1.全0初始化
就是将所有权重置0。当然是不能这样的，神经网络通过梯度更新参数，参数都是0，梯度也就是0，神经网络就停止学习了。
2.随机初始化
参数随机化，不过随机参数服从高斯分布或均匀分布，假设网络输入神经元个数为 n i n n_{in} nin​，输出神经元个数为 n o u t n_{out} nout​，则服从高斯分布的参数随机初始化为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c45c50ed221d66f258900fde558242f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bc7cf525adb37b1332343287b1830bd/" rel="bookmark">
			数字孪生 | 04 三维模型的数据治理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天是数字孪生系列话题第4篇，聊聊三维模型数据治理那些事。
近几年，数字孪生、智慧城市、智慧园区、智慧工厂、元宇宙等热词不断地出现在这我们的视野中，而这些又都离不开三维模型，我们在执行项目的时候，特别是报价的阶段我们就经常被客户问到你这个模型的价格太高或者报的价格和其他公司的差距太大了，第二个就是后面我加业务模型可不可以支撑。
先说第一个问题，为什么市场价格差距那么大，是水深、还是市场很乱呢，我觉得核心还是有没有真正洞察到真正的“需求”，往往是"鸡同鸭讲”，根本上是不清楚你的业务场景需要什么样的模型，从而去决定构建的行业三维数据交付标准，怎么和你现有的信息系统做结合，避免重复“造轮子”，真正意义上“一模多用”，打破"数据孤岛"，实现不同专业或则行业上下游的数据流转，放大三维数据价值。
同时，价值的背后才是价格，这样也实现一个业务和商业逻辑的闭环，那么这样的话，第二个问题也就顺其自然解决了。
在聊三维模型数据治理就得先简单了解一下他的“前辈”数据治理。
打开搜索引擎，你会看到以下内容：
概念似乎有点抽象，不过注意最后一段话：“数据治理的最终目标是提升数据的价值”。
那么和我们今天聊得三维数据治理治理有什么关系呢，别着急，还得先迈两个关子，我们还是要不落熟套的要了解一下数据治理基本的一些流程和工具类应用，我们先看一下数据治理的流程：
了解完大致的流程，我们还要了解一下数据治理的工具，我对这些工具进行了简单的归类：
(有想要系统的了解相关的产品和业务可以看一下大厂的平台，比如阿里dataphin、华为dgc、网易数帆等。这个不是我们今天所要关注的重点。)
接下来可以进入我们的三维模型数据治理了。
先提一个问题，为什么我们对三维模型数据进行治理（毕竟都说一个好问题是解决问题的第一步）。
1、数据种类多：
在上一篇我们也聊到了不同的三维模型数据，比如：BIM、GIS、工厂数据、其他普通的三维模型数据，搭建一个基础的数字孪生场景底座，至少有两种三维数据，另外多数场景还要同CAD图纸数据做关联。
2、建模软件种类繁多
市面上的建模软件上百种，究竟用哪一款适合你的项目。软件的选取很大程度上对项目的整体建模费用起决定性作用，为什么他可以报价5千，你的报价5万；为什么他的模型精度很高，你的很粗操；为什么他的模型浏览起来很轻量，你的很卡顿。诸如此类还会涉及到一些工作流域协同的问题，实现跨部门跨、跨区域的协同办公。
3、数据生产标准多
数据标准要紧贴行业特性，比如建筑行业的BIM数据，都有相应的国标、地方标准以及行业标准。拿BIM来举个例子，常常提到的有LOD100-LOD500的交付标准，也有对应的交付编码标准，BIM中还要涉及不同的个行业、专业这个信息量比较大，传统的方式，是5大专业建筑、结构、排水、暖通、电气，大家有兴趣我们可以单独在一个话题中讨论。
GIS数据规范标准复杂，GIS行业有S3M、3Dtiles、I3S标准，其中S3M数据规范标准作为国内最新发布的数据规范标准，对标的是美国I3S数据规范标准，二者在功能、技术特点上具有很高的相似性，3D Tiles作为最早支持海量数据展示的数据规范。常见的GIS数据影像、地形，数据来源于卫星遥感，无人机航测。
4、行业数据保有些需要保密
像一些空间信息的模型数据加密投影，就设计到数据的标准加载与非标准加载；有一些公众建筑、基础设施相关的模型有可能涉及到国家安全需要进行脱密措施。有些机械、数控行业模型，精密的车床加工设备涉及到知识产权一般客户不会直接将给全的图纸，就需要则需要脱密以及简化处理。
5、数据的兼容问题，扩展性问题
除了基础的模型数据，一个数字孪生中必不可少有物联网的时序数据、还有普通OA等系统的业数据，要想构建一个数字孪应用，还要使用物联网数据去驱动迷行数据，实现“会动的孪生体”。
6、数据的轻量化
因为三维模型文件较大，经常好几G，有些GIS的数据很容易就上100G，怎样的高效的加载与展示数据，还要保留模型基础的数据属性，除了与使用的平台引擎和硬件有关，很大一部上需要在模型上下功夫，以提升用户体验。比如：模型的格式、面数、模型数据结构组织。另外也要考虑用户端带宽与硬件配置，一般企业的应用在服务端的配置与网络带宽都是可跟得上的。
我们从五个维度上聊一下：
1、数据标准
制定数据标准第一步就是来规范建建模的工作流、建模工具、数据交付质量、编码规则。需要参考哪些相应的国标或则行业标准，模型精度应该匹配精度，根据专业特性合理搭配软件，对一些可能会出现的错误的建模方式制定要求，比如，法线，UV展开、贴图、重面，是否出现数冗余。
2、数据格式转换
对BIM数据、GIS数据、工厂数据、常规数据进行多层次的数据格式转换，除了保留模型的几何数据（点、线、面、位置信息）和颜色贴图，对于GIS、BIM数据还需要保留模型的属性信息，使它能仍然具备独特的行业特征，比如支撑对数据筛选、查看构件的属性信息、聚合等操作。
3、数据融合
实现一个平台对数据的统一管理，坐标统一化来实现不同模型的匹配融合。多种数据在一个平台同时的呈现，实现高碎片化和大数据量的三维场景渲染与加载。
4、数据清洗
主要对数据源进行增、删、查改等工作，比如模型构件是否重复，数据冗余。一些园区的应用我们还要关注建筑单体的分类、分层、分组，文件的关联关系。
5、数据共享
及时同步文件，保证文件版本的统一性。在建模阶段中大型项目需要不同专业之间进行配合，特别是在BIM实施过程中，多数项目需要在一个协同办公的环境下进行协同办公。
总结一下，对数字孪生的应用场景的搭建要正确的制定建模标准，采用合理的建模软件，开发层面要考虑到系统的三维引擎选型，会直接影响到项目的整体质量和费用，因此一开始就做对，避免重复造轮子。
今天先聊到这，下一篇我们和大家聊一下三维建模软件选型。
“3D看行业，孪生见未来”，关注我们，数字孪生不迷路。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d587b8292a2b289c048425cc433705e/" rel="bookmark">
			网络入门-NAT网络地址转换-Easy ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		209、NAT网络地址转换——Easy IP :允许多个私网地址转换成公网IP地址；企业网常用；
210 、实验topo：
原理：
内网私网地址转换成公网接口g0/0/1 当前的IP地址；
先将内网地址用ACL做范围匹配，ACL是没有默认允许所有的规则的；
acl number 2000 rule 5 permit source 192.168.30.0 0.0.0.255
做easy IP NAT转换:
interface GigabitEthernet0/0/1(内网出口)
nat outbound 2000（2000是表号）
测试内网PC能否与外网通信：
查看NAT转换会话：dis nat session all
211、 easy ip的工作原理：
数据包传出：所有的内网地址在出口路由器上转换成公网IP地址，并给数据包添加一个标识符；
数据包回复：外网想要进入到内网的数据包，在出口路由器上根据标识符把外网的IP地址转换成为内网的IP地址；
标识号每一次的数据转发都不一样
212、实验二：SERVER NAT：将服务器的某一个端口映射出去外网;
实验topo：
配置server NAT，将内网的80端口映射到外网的80端口：
R1：
interface GigabitEthernet0/0/1
nat server protocol tcp global 12.1.1.4 www inside 192.168.30.20 www
将内网192.168.30.20 的80端口映射到外网12.1.1.4 的80端口；
测试能否从外网访问到内网服务器：
由于只是把服务器的80端口映射出去，所以如果从外网想要ping内网的服务器的话是没办法ping 的
213、实验三：某员工外出出差，但出差期间任然有多台服务器需要远程管理，但是只有一个IP地址；
由于实验环境有限，因此采用80服务代替3389端口
实验topo：
NAT转换：
interface GigabitEthernet0/0/1
ip address 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d587b8292a2b289c048425cc433705e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92c0b4e7693b5adef36ea1c2ebe30955/" rel="bookmark">
			Pandas的read_excel函数学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		excel表的读取在python中是非常重要的，为了方便今后的使用，我将我学习用python读取excel表的过程记录下来，以便今后回顾时能快速想起各种方法。下图为示例中使用的excel表中的内容
sheet1：学生的信息
sheet2：成绩
在pandas中一般使用函数read_excel来进行excel表的读取，其参数如下：
pandas.read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=None, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, decimal='.', comment=None, skipfooter=0, convert_float=None, mangle_dupe_cols=True, storage_options=None)
下面先来分析该函数比较常见的参数： io（文件路径）：sheet_name（选择sheet）header（选择表头）names（改变表头名字）index_col（选择索引列）usecols（选择读入的列）squeeze（读入只有1列时返回一个Series）不常用参数结语 io（文件路径）： 文件的路径，既可以是本地的地址，也可以是网络地址。本文主要关注本地地址。
参数可能的种类str, bytes, ExcelFile, xlrd.Book, path object, or file-like object
import pandas as pd from numpy import disp #路径前面的r表示对路径中的'\'进行转义，否则会出现'\n'之类的转义字符，导致文件的路径出错 #没r和有r的对比 test1 = pd.read_excel("D:\python\pycharm_workplace\excel_ctrl\a.xlsx");#即使在相应的路径有这个文件，这个会出错 test1 = pd.read_excel(r"D:\python\pycharm_workplace\excel_ctrl\a.xlsx"); #相对路径:我测试的时候excel文件和py文件是在同一目录下 data1 = pd.read_excel(r"z.xlsx"); #绝对路径 data2 = pd.read_excel(r"D:\python\pycharm_workplace\excel_ctrl\z.xlsx"); disp(data1); disp(data2); 结果如下 D:\python\python\python.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92c0b4e7693b5adef36ea1c2ebe30955/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4932f40ae07e0a5bcc59c9e44356ce3/" rel="bookmark">
			代码随想录30——回溯：332重新安排行程、51N皇后、37解数独
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.332重新安排行程1.1.题目1.2.解答1.2.1.思路1.2.2.代码 2.51N皇后2.1.题目2.2.解答 3.37解数独3.1.题目3.2.解答3.2.1.正确解法3.2.2.自己的写法，没有AC，待二刷看 1.332重新安排行程 参考：代码随想录，332重新安排行程
1.1.题目 1.2.解答 1.2.1.思路 1.题目理解
这道题目还是比较复杂的，但是只是题目的意思和最后代码稍微复杂一点，但是实际上并不难。这道题目其实就像是一个图，图中有很多节点，然后给了不同节点之前的连接箭头；给你一个起点，让你遍历整个图的所有节点，同时要使用完所有的箭头，不能多用也不能少用。只不过这道题把图的节点换成了机场，把箭头换成了机票，更加有实际意义。
解答的方法和回溯的穷举法是一样的，因为题目先给了所有的机票，也就是所有的箭头，即从哪里出发，可以飞往哪里。比如从机场A出发，可以飞往机场BCD，比如给了机票是[A, B], [A, B], [A, C], [A, D]，其实就是从A出发，A→B有两张机票（两个箭头，注意相同的起止点可以有多张机票）、A→C有一张机票，A→D有一张机票。
那么其实问题就变成，从某个点出发之后，他可以飞往多个下一个目的地；然后从新的下一个目的地出发，又可以飞往多个下下个目的地…依次类推，直到用完所有的机票飞往所有的目的地。但是这个过程中，可能会陷入胡同，比如下图（1）所示，如果一开始就从A飞往C，结果是无法用完所有机票遍历所有机场，而A→B→A→C满足最终要求。那么如何判断收集的一条飞行路径是遍历完了所有节点，并且用完了所有机票呢？如下图（2）所示，其实只需要统计我们飞行的路径中，机场的个数和机票的张数的关系，如果机场的的个数=机票的张数+1，那么说明就用完了所有的机票（只要是用完了所有的机票，自然就遍历完了所有的节点，所以其实用完所有机票才是真正的要求）
2.遍历过程
其实理解了上面的题目要求之后，很容易发现这个和之前的排列问题是很相似的，其实就是每次选择当前的空的所有可能，然后调用递归选择下一个空的数的选择。本题以输入：[["JFK", "KUL"], ["JFK", "NRT"], ["NRT", "JFK"]为例，抽象为树形结构如下：
所以这里在代码实现上就有两点需要注意：
记录当前机场的目的机场，即当前机场可以飞往哪里记录当前机场飞往目的机场的剩余机票张数，比如A→B有两张机票，飞一次的话就少一张，至少有一张机票才能飞 所以这里使用的数据结构是map&lt;string, map&lt;string, int&gt;，表示&lt;起飞机场，&lt;目的地，剩余机票张数&gt;&gt;。但是这里还需要思考一下，是否可以优化数据结构提高效率，因为map有map和unordered_map的区别：unordered_map底层是哈希表，查询搜索是O(1)；而map底层是红黑树，可以增删，查询搜索是O(logn)，另外map的键是有序的。
由于查询出发机场需要快速查找，所以使用unordered_map更好。
那么达到机场使用哪个呢？注意到题目要求中是返回字典序号靠前的结果，所以我们要把目标机场的存储就按照键的值进行有序存储，这样遍历目标机场的时候自然就会遍历字典序号在前面的机场，自然就满足了题目的要求。所以到达机场使用map的数据结构更好。
此外注意，题目要求返回字典序号靠前的那个路线就可以了，而不是要求返回所有的路线，所以我们并不是要利用回溯的特性寻找所有可能的解，而是只需要找到其中的一个解。一旦找到了第一个解，那么整个递归函数就立马结束，不用再递归了。所以这里递归函数需要有返回值。
1.2.2.代码 上面就是给出了自己的讲解，具体更加详细的讲解可以去看代码随想录网站上的讲解。但是只要理解了上面的步骤，可以直接看下面的代码，有详细的注释，本题并不是特别难。
注意：这道题其实也是一道图论中深度优先搜索的题目，只不过在深度优先搜索中也涉及到回溯，所以这里按照回溯来理解也是没有问题的。
// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets // 注意为什么要用这种方式：因为我们要记录从当前机场出发，可以往哪些机场飞。比如出发机场是A，到达机场 // 可以是BCD等。还有一个问题是每张机票只能用一次，所以我们还要记录从出发机场飞往达到机场的剩余机票的张数， // 比如可能有三张从A飞往B的机票，那么每次遍历机场A的时候，如果向往机场B非，就要先判断是否还有A-&gt;B的机票 // 如果有就可以飞 unordered_map&lt;string, map&lt;string, int&gt;&gt; targets; // ticketNum是一共有多少张机票，result是最终的飞行路线结果 bool backtracking(int ticketNum, vector&lt;string&gt; &amp;result) { // 递归终止条件：如果飞行路线中机场个数 = 机票张数 + 1，则说明把所有机票都用完了， // 即收集到了一个可能路线 if (result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4932f40ae07e0a5bcc59c9e44356ce3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1859cbde9cb337a258aefa63b1a83eb8/" rel="bookmark">
			python使用 pip 命令时提示“WARNING: Ignoring invalid distribution -ip”的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： python使用 pip 命令时提示“WARNING: Ignoring invalid distribution -ip”，如图所示：
可能原因： 可能是之前下载的第三方库没有成功或者中途退出。
解决方案： 找到提示目录下前缀为“~ip”的文件夹，删掉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a51e337643e5587440b15480333bd98/" rel="bookmark">
			专业系统开发流程有多少步骤？如何进行系统开发？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​在进行系统开发时，很多企业会选择技术公司进行系统开发，对于技术公司而言，一个全面、专业的开发流程也能从侧面反映出合作技术公司的开发示例及项目负责人员组织架构的完整度，能够更好地了解项目进度。专业系统开发流程通常分为以下步骤：开发公司与项目公司共同制定开发计划、进行系统开发前期调研与需求分析、功能开发设计、系统测试、系统交付验收等主要流程，因此从人员配备上看，一个完整的系统开发流程也需要项目经理、产品经理、前后端工程师、UI设计，运维支撑及项目测试等人员。
此外，除技术服务提供外，一些技术型公司也在进行数字化服务升级，为项目能够快速落地提供定期跟踪、机制设计及推广等服务。技术是骨血，落地机制是肉，需要技术服务与落地服务共同组合才能推动项目落地运营。开利网络成立于2007年，从技术服务到落地服务，致力于为企业构建数字化生态闭环，为企业数字化创造真正价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3e8fcf462e4a12aedc7ddf7c8b084a/" rel="bookmark">
			用opencv读取多个图片并合成mp4视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运用C++结合opencv读取多个图片并合成MP4视频 简单描述一下我的demo，我是只有六张图，所以只是为了写的demo而已，写了两个循环，合成一个三千帧的视频，帧率是15
以下是我的代码 #include&lt;opencv2/opencv.hpp&gt; #include&lt;iostream&gt; using namespace cv; using namespace std; int main() { /*Mat src = imread("(1).bmp"); imshow("src", src); waitKey(0);*/ //读取第一帧图像，获取长宽 Mat src = imread("1.bmp"); int width = src.cols; int height = src.rows; //配置视频参数 VideoWriter writer; writer.open("out.mp4", VideoWriter::fourcc('m', 'p', '4', 'v'), 15, Size(width, height), 1); char savefile[200]; Mat srcc; for (int i = 0; i &lt; 500; i++) { for (int j = 1; j &lt;= 6; j++) { sprintf(savefile, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab3e8fcf462e4a12aedc7ddf7c8b084a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ac349298069eba155691749290c0d8/" rel="bookmark">
			window环境下mysql忘记密码或者原正确密码无法登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以window环境为例
一、关闭mysql服务
去任务管理器-服务中关闭即可。
二、找到mysql安装目录下的my.ini文件
如果安装目录没有，说明找的不对。
在C盘地址栏输入“%ProgramData%”
回车后，在目录中找到MySQL文件夹
三、管理员身份编辑my.ini（设置无密码访问）
找到mysqld配置项，在下边增加 skip-grant-tables
四、重启mysql
去任务管理器-服务中启动即可。
五、此时可以无密码登录mysql
找到名为“mysql”库里的user表
六、保险起见，看一下表里边有没有你的用户名称
七、打开sql编辑框
更新你的用户密码
update user set authentication_string = password('root') where User = 'root'
注意：5.7版本的密码字段是authentication_string。5.6的是password，其他版本需要自己去表里看哪个字段存密码。
八、修改my.ini，将新增的skip-grant-tables去掉或者注释掉
九、重启mysql服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/528b12d6ce10c3f6e4ce24c20e741529/" rel="bookmark">
			ROS 中的三种坐标系（map、odom与base_link）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网上看了一些大佬的解释，还是感觉有点迷糊，多看了几次之后感觉好像get到了，如果说错了还请指正。
map和base_link都很好理解，一个是绝对坐标系，另一个是以机器人自身为原点的坐标系，很容易懂。
唯一麻烦的就是odom，里程计坐标系。
下面就以我的拙见尝试小白化地解释一下这个玩意儿。
首先，我们制定机器人路径时，使用的必然是绝对坐标系——
比如我现在让机器人去点（10,10）。
要完成这件事，机器人需要先知道自己在哪。它没有GPS，所以只能倒推——通过里程计。这也是为什么“没有偏移的话odom应该与map重合”，因为odom本来就是用来倒推map的。
（经评论提醒，特强调，这个“偏移”指的是偏差，误差，而不是位移）
里程计告诉它，自从原点启动起，它在X向上移动2，Y向上移动了5。于是它就认为自己在（2,5）。反馈给base_link，则base_link里原点在（-2,-5），目标在（8,5）。
然而实际上，因为偏移，它的里程计是错的，它其实在（3,4）（map）。
此时，在map，也就是实际上，它在（3,4），但在odom中它在（2,5）。
它理应运动（7,6）到达目标点，但它会运动（8,5），因为odom反馈给base_link后，在base_link中，目标在（8,5）。
而这时，校正传感器又告诉它了，“我觉得你的里程计刚才X漏算了0.999，Y多算了1.001”。
于是它把自己所在位置修正为了(2.999,3.999)（odom），把目标在base_link中修正到了(7.001,6.001)（base_link）接下来该移动（7.001,6.001）。
以上。
odom←base_link+里程计
+
校正
↓
接近map的坐标系
参考：https://blog.csdn.net/flyinsilence/article/details/51854123
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faddced8636cb654bc879767e452f779/" rel="bookmark">
			布式事务Seata和分库分表sharding-sphere的整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 本篇将介绍,如何进行seata1.2.0、sharding-sphere4.1.0和dubbo2.7.5 的整合,以及使用nacos作为我们的配置中心和注册中心。如果你还是一个初学者，先建议学习一下，陈建斌的七步带你集成Seata 1.2 高可用搭建，这篇文章清楚的阐述了初学者容易遇到的5个问题，并且都提供完整的解决思路。
2. 环境配置 mysql: 5.7.12nacos: 1.2.1spring-boot: 2.2.6.RELEASEseata: 1.2.0dubbo:2.7.5sharding-sphere: 4.1.0开发环境: jdk1.8.0 2.1 nacos安装 nacos下载：https://github.com/alibaba/nacos/releases/tag/1.2.1
Nacos 快速入门：https://nacos.io/en-us/docs/quick-start.html
sh startup.sh -m standalone 在浏览器打开Nacos web 控制台：http://127.0.0.1:8848/nacos/index.html
输入nacos的账号和密码 分别为nacos：nacos
这是时候naocs 就正常启动了。
2.2 seata1.2.0安装 2.2.1 在 Seata Release 下载最新版的 Seata Server 并解压得到如下目录： . ├──bin ├──conf └──lib 2.2.2 修改 conf/registry.conf 配置， 目前seata支持如下的file、nacos 、apollo、zk、consul的注册中心和配置中心。这里我们以nacos 为例。
将 type 改为 nacos
registry { # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = "nacos" nacos { application = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faddced8636cb654bc879767e452f779/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/197/">«</a>
	<span class="pagination__item pagination__item--current">198/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/199/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>