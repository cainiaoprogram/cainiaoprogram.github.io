<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c1f483e401034c927dd53b51d8742e8/" rel="bookmark">
			情感分析学习笔记（6）——PolarityRank算法python代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文紧接上一篇理论文章《情感分析学习笔记（5）——PolarityRank算法原理讲解》，本文是代码实现。
参考的是两篇论文（Fernández-Gavilanes et al., 2016; Cruz et al., 2011）以及PageRank算法（Page et al., 1998）
由于找了一圈没有找到相关的代码，所以是我参考pagerank的实现过程以及论文自己手撸的代码，所以不一定保证效率与正确率，而且我测试也只用了positive的一条语句进行测试，没有测试过negative的和混合的，所以如果有问题，属实正常。
本文与SO-PMI算法一样，不会公开任何数据集，但是我会留下数据集的获取方式。
对了宝贝儿们，卑微小李的公众号【野指针小李】已开通，期待与你一起探讨学术哟~摸摸大！
代码我已上传至github，链接在这里：https://github.com/Balding-Lee/polarityrank/tree/master，如有需要，请自行提取
目录 1 准备工作1.1 stanford coreNLP1.2 数据集获取1.3 POS标签 2 代码讲解2.1 预处理2.1.1 stanford coreNLP2.1.2 清洗数据 2.2 生成句法图2.2.1 句法图创建2.2.2 词语初始PR值确定2.2.3 词语之间边权判定 2.3 生成矩阵2.3.1 生成PR向量2.3.2 生成e向量2.3.3 生成 f u T fu^T fuT矩阵2.3.4 生成邻接矩阵 2.4 PolarityRank2.4.1 计算每个节点PR值2.4.2 计算SO值 3 总结4 参考 1 准备工作 1.1 stanford coreNLP 我用的POS和NER的工具都是stanford coreNLP，这里不多阐述具体的安装配置方法，如有需要参考这篇文章。
这里帮大家排个坑，最新版的stanford coreNLP的中文版jar包下载下来名字是这样的：
如果就这样直接导入的话，会报错，具体报错的理由也很简单，就是你这个jar文件名字有问题。反正这是我编码5年多以来遇到的最离谱的一个错。要把jar包名字改为这样，就不会有问题了：
中间的年月日不重要，只需要是yyyy-MM-dd格式就行。
至于这个东西加载速度有点慢，我这里查了查相关资料，如果有需要的，参考这篇文章。不过我没用，也不知道效果怎么样。
1.2 数据集获取 数据集我一共使用了两个数据集，分别如下：
搜狗实验室的新闻数据，我使用的是迷你版的，链接如下：https://www.sogou.com/labs/resource/t.php情感词汇表，我采用的清华大学整理的情感词汇表（带有情感极性的）。 1.3 POS标签 POS标签我是直接参考的stanford句法分析的标签，链接如下：https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c1f483e401034c927dd53b51d8742e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f56d38da723fbe8d781bf1d8bd1ae2df/" rel="bookmark">
			高斯投影坐标转换（c语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高斯投影坐标转换（c语言） 一、高斯投影简介1.1 高斯投影基本概念1.2 高斯投影的条件1.3 高斯投影分带 二、高斯投影转换2.1 几个概念2.2 计算已知量2.3 计算步骤 三、具体问题求解3.1 问题重述3.2 实现代码3.3 输出结果 一、高斯投影简介 1.1 高斯投影基本概念 高斯投影又称横轴椭圆柱等角投影，属于正形投影。世界上最先采用高斯投影的国家是奥地利和德国，我国于1952年正式决定采用高斯投影。
1.2 高斯投影的条件 （1）投影后角度不产生变形，满足正形投影要求；
（2）中央子午线投影后是一条直线；
（3）中央子午线投影后长度不变，其投影长度比恒等于1。
高斯投影除了在中央子午线上没有长度变形外，不在中央子午线上的各点，其长度比都大于1，且离开中央子午线愈远，长度变形愈大。
1.3 高斯投影分带 为限制长度投影变形，投影分带有6度分带和3度分带两种方法。
6°带带号N和中央子午线经度 LN的关系式： LN=6N-33°带带号n和中央子午线经度 Ln的关系式： Ln=3n6°带与3°带带号之间的关系为：n=2N-1 二、高斯投影转换 2.1 几个概念 高斯平面坐标系：指的是以中央子午线与赤道的交点作为坐标原点，以中央子午线的投影为纵坐标轴X，规定X轴向北为正，以赤道的投影为横坐标轴Y，Y轴向东为正，形成的坐标系。
通用坐标：在同一投影带内横坐标有正值、有负值，这对坐标的计算和使用不方便。为了使Y值都为正，将纵坐标x轴西移500km，并在Y坐标前面冠以带号，称为通用坐标。
大地坐标（Geodetic coordinate）：是大地测量中以参考椭球面为基准面的坐标，地面点P的位置用大地经度L、大地纬度B和大地高H表示。
高斯坐标正算：大地坐标（B、L、H）转换为高斯投影坐标（X、Y、Z）
高斯坐标反算：高斯投影坐标（X、Y、Z）转换为大地坐标（B、L、H）
注意：本文高斯坐标投影转换指的是高斯投影的 6° 带转换成 3° 带 或者 3° 带转换成 6° 带。
2.2 计算已知量 地球属性符号表示值长半轴a6378245短半轴b6356863.01877c6399698.9018第一偏心率e1^20.0066934216第二偏心率e2^20.0067385254 2.3 计算步骤 以6° 带转换成 3° 带为例， 3° 带转换成 6° 带同。
通用值转换成自然值高斯投影坐标反算求解6°带中央经线求解3°带的经差高斯投影坐标正算自然值转换成通用值 三、具体问题求解 3.1 问题重述 已知：某点P在1954年北京坐标系6°带的平面直角坐标为
x1 = 3589644.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f56d38da723fbe8d781bf1d8bd1ae2df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad09252ccbc2c81b383739221207d118/" rel="bookmark">
			解决Windows密码错误无法进入系统的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 前言一、怎么遇到的问题，Microsoft无法打开二、解决方法1.右键网络图标属性2.点击更改适配器设置3.选择正在使用的网络4.点击属性5.寻找点击“Internet协议版本4（TCP/IPv4）”6.由自动改为选择“使用下面的DNS服务器地址"7.首选为“4.1.1.1”，备用为“4.2.2.2” 三.电脑Windows密码忘记并且Microsoft的PIN码不能输入下更改windows密码进入系统1.尝试多种方法均不行最后选择自制PE盘2.准备过程：3.开始解决（1）下载老毛桃到电脑上（2）解压后启动程序会显示将格式化并下载到U盘（3）点击蓝色按钮一键安装（4）插入问题电脑开机进入BIOS，选择U盘内的系统登录（5）进入桌面点击更改密码图标（6）选择用户改密码保存（7）重启电脑输入密码进入系统成功 前言 遇到电脑PIN码无法输入
显示“出现问题，你的PIN不可用。请选择其他登陆选项，并转到“设 置”&gt; “账户”&gt;“登陆”选项，以重新设置PIN”
一、怎么遇到的问题，Microsoft无法打开 无法开启Microsoft商店及网页，解决后更改了PIN码导致无法登陆系统
二、解决方法 1.右键网络图标属性 2.点击更改适配器设置 3.选择正在使用的网络 4.点击属性 5.寻找点击“Internet协议版本4（TCP/IPv4）” 6.由自动改为选择“使用下面的DNS服务器地址" 7.首选为“4.1.1.1”，备用为“4.2.2.2” 三.电脑Windows密码忘记并且Microsoft的PIN码不能输入下更改windows密码进入系统 1.尝试多种方法均不行最后选择自制PE盘 2.准备过程： 硬件：一台可用Windows电脑，一个8G-16G的U盘（空盘或先将里面文件拷到其他电脑保存，使用时会格式化U盘）
3.开始解决 （1）下载老毛桃到电脑上 网址： http://m.laomaotao.net/down/
（2）解压后启动程序会显示将格式化并下载到U盘 （3）点击蓝色按钮一键安装 等待安装完毕拔下U盘
（4）插入问题电脑开机进入BIOS，选择U盘内的系统登录 （5）进入桌面点击更改密码图标 （6）选择用户改密码保存 （7）重启电脑输入密码进入系统成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00926a102a83e5680fc9d7a59b3527c9/" rel="bookmark">
			双重for循环打印星号矩形,平行四边形,三角形规律总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双重for循环打印星号矩形,平行四边形,三角形规律总结 双重for循环就是在一个for循环里面在插入另一个for循环,格式如下
for(){ for(){ } } 当外面的循环运行一次,内部的循环需要运行一整个循环,下面请看实例.
1.钟表模型
要求:当时针转动一次,分针需要运行60次.
public class T1Doublefor { public static void main(String[] args) { for (int i = 1; i &lt;=12 ; i++) { System.out.println("现在是"+i+"点"); for (int j = 1; j &lt;=60 ; j++) { System.out.println("现在是"+i+"点"+j+"分"); } System.out.println("---------------------------"); } } } 2.使用双重for循环打印星号矩形,平行四边形,三角形
矩形
public class T2 { public static void main(String[] args) { for (int i = 1; i &lt;=5 ; i++) { for (int j = 1; j &lt;=5 ; j++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00926a102a83e5680fc9d7a59b3527c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76750cb3ef80ac82825b8c1bfa8df4dd/" rel="bookmark">
			鼎微方案导航一体机刷机包_汽车原厂屏幕 CD DVD导航 安卓大屏的特点是什么？缺点是什么？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，原厂屏幕或者原厂导航系统
这些都是按照仪表台定制的，会很合缝，一般原厂的机器功能都是比较单一的，目的就是为了稳定！但是原厂机器质量肯定是很好的！基本和车辆同寿命！原厂的导航系统是很不好用的！更新也比较麻烦，还有些导航是没有触摸的、输入地址也麻烦！有些还没有倒车影像！显示效果有些也不怎样！当然原厂机器质量，和仪表风格比较好！音质方面只能说合格吧！正常原厂的机器功率都不会很大！带后功放的功率就比较大！音质要比没有后功放的好几倍，但是一般只有高配和选配才有的！如果不想拆车改装又想音质完美那就选择高配或者工厂定制高配音响！
二 后市场CD
现在安装CD都是为了改善原车音质或者改音响想要高品质音质的！目前市场比较流行的有建伍，阿尔派等音质差别是有的，价格差别也比较大！有能力的选择阿尔派，预算不多的可以选择建伍，正常是不大听的出来的！
三 DVD导航
这些机器市场基本也淘汰了，全新基本很少了！现在基本都在某鱼上出售了！DVD导航质量上还是比较稳定的用的CE系统也有一定年份了，优化的也比较好！音质比CD要差一点，优于安卓！缺点，DVD光头寿命不长，碟片不好找了！地图升级也不好升级了！以前的还是电阻的触摸屏 ，触摸效果比较差！后来有电容的！但是屏幕还是比较小，像素也不高，不支持高清后视摄像头！
四 安卓大屏
现在的主流，价格差别特别大由300-3000都有！市场特别乱，价格也是！质量也是一样！价格高的不一定质量好！目前市场上的安卓有四大方案，鼎微方案、诺威达方案、掌讯方案、方易通方案！其它还有几个小的主板工厂就市场占有量比较小质量上也没有多少保障！几个大的工厂基本都是用联发科的4核芯片！目前市场做的最稳定的就是1G缓存加16G内存的！过去的一年鼎微和诺威达做的比较稳定，鼎微显示效果要优于诺威达，特别是倒车影像那方面！反应速度差别都不是太大。基本都使用7.8个月都有卡顿问题，这是安卓的通病，但是不联网使用不会出现这个问题！还有就是4G主机，这些主机都是送流量的，但是网络特别不稳定，主机也特别容易卡顿，显示内存不足，这是有网络后台不断下载软件和更新造成的！所以一般不建议用4G主机！大屏安卓的显示效果也是差别比较大的，有A、B规屏幕，还有IPS全视角屏幕！所以在选择的时候注意看看，IPS屏幕在关机的时候比较黑，看屏幕是没有角度的，就是不管你在那个位置看屏幕都是一样的！至于A、B屏幕这个差别不是太大，有对比就比较容易分出！音质方面，大屏安卓是不讲究音质的 ，只考虑娱乐和视角的！所以想安卓有好音质是不大可能的！
今天分享就到这里，希望可以帮到你们！
以上是老朱编写，有不到的请多多指教 ，欢迎关注，点赞，评论！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30087bdb8229f75dcb78ffa857525289/" rel="bookmark">
			Socket通信的工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
定义
工作原理
什么是TCP/IP、UDP？
参考文章：https://blog.csdn.net/qq_30270931/article/details/80483124
定义 socket又叫套接字，是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信。
工作原理 基于TCP 协议，封装成接口提供使用。
（图片摘自网络）
1、服务器监听
服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket
服务器为socket绑定ip地址和端口号
服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开
2、客户端请求
客户端创建socket
客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket
3、连接确认
服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入阻塞状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求
客户端连接成功，向服务器发送连接状态信息
服务器accept方法返回，连接成功
客户端向socket写入信息
服务器读取信息（服务端Socket创建的线程）
客户端关闭
服务器端关闭
什么是TCP/IP、UDP？ TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。
UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。
1、TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上(实际上也很大程度上保证了)保证了连接的可靠性;
而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。
2、也正由于1所说的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。
参考文章：https://blog.csdn.net/qq_30270931/article/details/80483124 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af99e9ee2b5be86e9f07c70e1f5830fb/" rel="bookmark">
			先用虚拟内存还是物理内存_图解Linux中的虚拟内存机制和内存映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近学习了Linux中的虚拟内存，这个机制真的是非常的妙。虚拟内存可以说是硬件异常、主存、外存和操作系统的完美交互，而且更妙的是，这个机制是完全自动运行的。如果我们理解一点点虚拟内存的原理，就可以理解经常出现的内存错误的原因，还可以理解什么是内存映射mmap。
一、物理地址空间是什么
理解虚拟地址空间还得从物理地址空间开始说起。我们知道内存就像一个数组，每个存储单元被分配了一个地址，这个地址就是物理地址，所有物理地址构成的集合就是物理地址空间。物理地址也就是真实的地址，对应真实的那个内存条。
如果CPU使用物理地址向内存寻址的话，就是下面这样，这条指令中的地址就是数据真实存放的地址。 二、虚拟地址空间是什么
引入虚拟地址之后，对于每一个进程，操作系统提供一种假象，让每个进程感觉自己拥有一个巨大的连续的内存可以使用，这个虚拟的空间甚至还可以比内存的容量还大。这个“假象”就是虚拟地址空间。虚拟地址是面向每个进程的，只是一个“假象”罢了。
此时CPU使用虚拟地址向内存寻址，通过专用的内存管理单元（MMU）硬件把虚拟地址转换为真实的物理地址（地址翻译），操作系统负责把虚拟地址和物理地址的映射关系维护在页表之中。
指令中的地址不是数据真实存放的地址
三、程序和进程
当我们写完代码，编译，链接并且生成可执行文件后，得到的这个东西就是一系列二进制代码的集合，我们管这东西叫做程序，存储在磁盘上。只有当我们执行这个文件后，程序才会被操作系统读入内存运行，但是注意系统并不会把程序全部读入内存，我们把正在运行的程序叫做进程。
从进程的视角来看，我的数据和代码被存放在一个连续的空间之中，每个区域分别有着不同的功能。典型的如存放代码的区域和存放数据的区域。
然而我们知道，这只是个假象。代码和数据中的地址都是一个虚拟地址，还需要经过地址翻译才能得到真正的物理地址。
四、分页、页表和缺页异常
虚拟地址和物理地址的映射关系是以“页”为单位的。分页就是把整个虚拟内存和物理内存分割成大小固定的块，以一个页作为映射的最小单位。运行时，CPU请求一个虚拟地址，虚拟地址又被翻译为物理地址，从而确定数据在内存中的哪个位置。下面的页表中记录了这个进程虚拟内存每个页的映射关系。
当CPU寻址的时候，这个映射会有三种可能。
未分配：虚拟地址所在的那一页并未被分配，代表没有数据和他们关联，这部分也不会占用内存。未缓存：虚拟地址所在的那一页被分配了，但并不在内存中。已缓存：虚拟地址所在的那一页就在内存中。 当访问一个未缓存的区域时，系统将产生缺页中断，然后进程被阻塞，等待操作系统将缺失的那一页从磁盘复制到内存。当复制完成后，CPU继续执行导致缺页中断的那条指令，此时就会正常执行了。这种仅在需要的时候将页面拷贝到内存的策略叫做按需调度页面。 可以想象当程序被装入内存的时候，开始时仅有有很小的一部分内容被放入内存。程序在运行中不断缺页，不断的把需要的部分拷贝进内存。
从上面的图中还可以看出，虚拟内存实际上就是磁盘的缓存。系统通过缺页中断的机制，小心的维护着每个进程的虚拟地址假象。
五、虚拟内存的应用
在Linux中，将一片虚拟内存和一个磁盘上的对象关联起来，并用磁盘上的对象初始化这片虚拟内存，这个机制就叫做内存映射。
1、化简资源的共享
当我们使用共享库的函数时时，例如printf()，没有必要为每个进程拷贝一本代码，这样太浪费内存了。我们只需要让每个进程的一块虚拟内存映射到相同的对象上就可以了。
假如进程1和进程2想要共享同一个文件。其中文件A已经被映射到进程2（文件被缓存在内存中），进程2还是通过缺页中断载入的文件A。
此时进程1也打开文件A，由于文件的名字在系统中是唯一的，操作系统清楚文件A已经被缓存在内存之中。因此系统将进程1的虚拟内存映射到相同内存之中，完成文件的共享。
2、零拷贝技术的一种实现
对于linux中最常用的I/O函数 read() 来说，文件先会被系统复制到内核空间的缓冲区，然后再复制到用户空间。读一个文件需要复制两次显然不是我们希望的，尤其是读大文件的时候, sad...
通过内存映射，我们可以绕过内核缓冲，直接将文件A映射到虚拟内存，这里一共就发生一次拷贝，nice~
六、总结
虚拟内存无时无刻都在为我们工作，而且我们不需要任何干涉就能自动地工作。虚拟内存可以看成对磁盘的一个缓存，它通过缺页中断触发操作系统处理访问未缓存块的问题。虚拟内存可以应用在处理共享对象、减少I/O开销问题中。
虚拟内存十分的强大，以上介绍的仅仅是虚拟内存的一部分功能。如果文中出现错误欢迎指出，希望这篇文章对你有用。如果希望看到更多类似的内容请关注我的个人公众号↓
http://weixin.qq.com/r/oy6Pl97ENINLrZr093ux (二维码自动识别)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d98f52067272a210371ab6abd6fb070f/" rel="bookmark">
			载波聚合（CA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		载波聚合(CA)
1. 载波聚合目的
为了满足LTE-A下行峰速1 Gbps，上行峰速500 Mbps的要求，需要提供最大100 MHz的传输带宽，但由于这么大带宽的连续频谱的稀缺，LTE-A提出了载波聚合（Carrier Aggregation，CA），通过多个连续或者非连续的分量载波聚合获取更大的传输带宽，从而获取更高的峰值速率和吞吐量。
CA是将2个或更多的载波单元（Component Carrier， CC）聚合在一起以支持更大的传输带宽（最大为100MHz）。每个载波单元的带宽可以为5MHZ、10MHZ、15MHZ和20MHZ，但最大带宽不超过20 MHz。
载波聚合原因：由于LTE是长期演进技术，前期的协议就规划了其部署的带宽要求，如果直接扩大带宽，会导致向下协议、设备、终端等无法兼容。
增大速率的其他方案：MIMO技术（多发多收、空间复用、增益）、增加站点密度（相当于扩容）。
注：Rel-10中的所有载波单元都是后向兼容的（backward-compatible），即同时支持Rel-8/Rel-9的UE。
2. 载波聚合原理
2.1 CA的类型
为了高效地利用零碎的频谱，载波聚合支持不同载波单元之间的聚合（如图2-1所示）
a) 相同或不同带宽的载波单元
b) 同一频带内，邻接或非邻接的载波单元
c) 不同频带内的载波单元
图2-1 载波聚合
注：连续的载波单元之间的中心频率间隔必须是300 kHz的整数倍，以保证子载波的正交性。这是为了兼容Rel-8的100 kHz frequency raster，并保证子载波的15 kHz spacing，从而取的最小公倍数。
2.2 基本概念
Primary Cell（PCell）： 主小区，是UE进行初始连接建立的小区，或进行RRC连接重建的小区，或是在handover过程中指定的主小区。PCell负责与UE之间的RRC通信。PCell对应的载波单元称为PCC（Primary Component Carrier）。其中，PCell的下行载波称为DL PCC，PCell的上行载波称为UL PCC。
Secondary Cell（SCell）： 辅小区，是在RRC重配置时添加的，用于提供额外的无线资源，SCell与UE之间不存在任何RRC通信。SCell对应的载波单元称为SCC（Secondary Component Carrier）。其中，SCell的下行载波称为DL SCC，SCell的上行载波称为UL SCC。
载波单元(CC) ： 在Rel 10中聚合的CC被设计成具有所有必要的Rel 8通道和信号，如PSS/ SSS和系统信息(SI)。但是，这仅仅是为了向后兼容，UE不必读取所有聚合的CCs的MIB/ sib。从更高层的角度来看，每个CC都是一个单独的单元，具有自己的单元ID。在一个给定的地理单元中，所有可以聚合的CCs都被认为是同步的，并且属于同一个eNodeB (eNB)。
PCell是在连接建立（connection establishment）时确定的。SCell是在初始安全激活流程（initial security activation procedure）之后，通过RRC连接重配置消息RRCConnectionReconfiguration添加/修改/释放的。
Serving cell： 是为UE提供服务（上下行传输）的小区。如果UE处于RRC_CONNECTED态但并未配置CA，则该UE只有一个serving cell，即PCell；如果UE处于RRC_CONNECTED态且配置了CA，则该UE的serving cell集合包括PCell和所有的SCell。即serving cell既可以指代PCell，也可以指代SCell。PCell或SCell同时也是一个serving cell。配置了CA的UE可与1个PCell和至多4个SCell相连。某个UE的serving cell集合至多包含5个serving cell。配置了CA的UE在所有的serving cell内使用相同的C-RNTI。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d98f52067272a210371ab6abd6fb070f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff3fa393e4841c6acad17ce37a11c18/" rel="bookmark">
			Default Boot Device Missing or Boot Filed  以及  grub rescue（台式电脑   安装双系统引发的一连串事件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、问题描述一（操作过程如下）： 1.在win10系统上装Ubuntu16.04过程中，Ubuntu安装好后，太卡！
2.重装Ubuntu的时候，电脑死机了！ 进度条卡住很长时间
3.强行关机之后，没有出现引导界面
4.进入bios之后改了什么也很迷
然后悲发生了
解决方法：百度+google
建议：
1.百度一下
重启---&gt;进入bios--&gt;一些列设置（因为不是我的问题，我就省略了）
（热键一般是：F2,F12,Del）
2.Google一下
You Tube 真的，一步步视频教你，听不懂没关系，你就看他怎么按就行
（我感觉我在说废话）
3.我最后怎么解决的？
我按del键之后，并不能进入bios，到底是什么原因？
（还是google给力）
(1)确认键盘接口没问题：更换键盘接口试试，每个usb接口都试一试，看看能不能进去bios（我试了没用）
(2)确认键盘没问题：换个键盘重复第（1）步（对我没用）
(3)goole说：试一试ps2接口的键盘
第一步：确认你的电脑有ps2接口(圆形的）
第二步：你需要有一个ps2键盘
第三步：插上电脑，重启，进入bios
如果你能进行到第三步，说明你的问题和我一样
在问题描述中4说了，改了什么也很迷，我现在大概确定（usb 接口被disable）了
嗯，新的问题又来了。
二、问题描述二（grub rescue) 参考：
1.https://blog.csdn.net/hp_satan/article/details/9331411?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduend~default-3-9331411.nonecase&amp;utm_term=win10%E5%BC%80%E6%9C%BAgrub%E5%91%BD%E4%BB%A4%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95&amp;spm=1000.2123.3001.4430
2.https://segmentfault.com/a/1190000023301564
3.https://www.jianshu.com/p/8b37ef073b64、
4.https://www.cnblogs.com/GHzcx/archive/2004/01/13/9379871.html(下图）正常来说应该是：
我的是：没有 i386-pc/
最后分析原因:Ubuntu安装一半，卡住，重启，导致Ubuntu没了。因而修复也无法进入Ubuntu
结论：需尝试再次安装Ubuntu系统（过几天更新重装结果） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8efa18dbd146d4ba60288be18024e6e/" rel="bookmark">
			ICMP 中的 ping 与 tracet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 ICMPpingping的返回参数ping的工作过程ping 域名与ping IP 的区别ping 常用命令格式结合WireShark分析数据包ICMP报文IP数据报以太网帧数据链路层 Tracert ICMP ICMP（Internet Control Message Protocol）ICMP是一个网络层协议，是基于IP协议工作的，但是它并不是传输层的功能，因此仍然把它归结为网络层协议，Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。
那么ICMP有什么作用呢？
我们数据在网络中传输中，会封装成IP数据包，而IP协议的特点是面向无连接，且不可靠的，可靠性由上层来保证。IP协议所要做的就是尽最大努力把数据传输到目的地，如果当在路由器的转发中出错了而不能到达目的地时，IP协议对错误不进行任何报告和纠正，此时主机就不知道路由器那边有什么问题。而ICMP协议正好解决了这个问题。
ICMP主要有两种功能。
ping：一般用于勘测到达目的网络的连通性
tracert：用于确定ip数据包访问目标所采取的路径
ping 我们知道有时候我们用电脑去ping一个ip地址，去测试一下对这个ip地址之间的连通性，那么ping是如何进行测试的呢？
ping的返回参数 C:\Users\hp&gt;ping www.baidu.com 正在 Ping www.a.shifen.com [36.152.44.96] 具有 32 字节的数据: 来自 36.152.44.96 的回复: 字节=32 时间=74ms TTL=54 来自 36.152.44.96 的回复: 字节=32 时间=67ms TTL=54 来自 36.152.44.96 的回复: 字节=32 时间=46ms TTL=54 来自 36.152.44.96 的回复: 字节=32 时间=48ms TTL=54 36.152.44.96 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 46ms，最长 = 74ms，平均 = 58ms ICMP报文中有32个字节的测试数据；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8efa18dbd146d4ba60288be18024e6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a10289a1008826391c3f7ee5cf1c1ae/" rel="bookmark">
			使用h2数据库单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot使用h2数据库单元测试 SpringBoot项目在做单元测试时，若直接对业务数据库进行操作，会扰乱测试数据，所以我们在实际业务开发时，会选择h2作为单元测试的数据库。 H2数据库是一个开源的关系型数据库。H2是一个嵌入式数据库引擎，采用java语言编写，不受平台的限制，同时支持网络版和嵌入式版本，有比较好的兼容性，支持相当标准的sql标准，支持集群。下面我们来学习下如何在项目中使用h2做单元测试。 h2数据库配置： spring: datasource: driver-class-name: org.h2.Driver username: sa password: url: jdbc:h2:mem:h2test;DB_CLOSE_DELAY=-1 schema: classpath:scheme.sql data: classpath:data.sql jpa: hibernate: ddl-auto: none show-sql: true generate-ddl: false logging: level: root: info resources目录放入scheme.sql（表结构）、data.sql（表数据）文件：
scheme.sql:
create table if not exists users (id int not null primary key auto_increment,username varchar(100),password varchar(100),status int); data.sql:
insert into users(id, username, password, status) VALUES (1,'test','123456',1); 2.实体类、dao、controller层及异常处理：
@Entity @Data @Table(name = "users") public class User { @Id @GeneratedValue(strategy = GenerationType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a10289a1008826391c3f7ee5cf1c1ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b15d31cc7feb0d0d1a9b45e1fd7989c/" rel="bookmark">
			浏览器打开出现证书错误_【操作】Cobalt Strike 浏览器跳板攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 概念介绍 浏览器跳板攻击(Browser Pivoting)是一个应用层的跳板技术。
设想一个场景：
攻击者获取了目标机器的 Beacon shell，然后通过 Cobalt Strike 的 screenshot 工具进行截屏，看到受害机上的终端用户正在与 web 应用程序进行交互，比如登陆了在线邮箱，正在邮箱应用的网页版客户端查看邮件。这种应用对于实现后渗透目标具有很高的价值。
如何去利用这些 web 应用呢？
【浏览器跳板攻击】就是适用于这种场景的一种攻击方式。
简单来说，浏览器跳板攻击可以让攻击者以受害主机上的终端用户的身份来访问浏览器上开着的应用。攻击者可以继承目标用户对于网站的访问权限，相当于直接跳过了对于浏览器上的应用程序的身份验证。
【浏览器跳板攻击】使攻击者可以用自己的浏览器通过目标的浏览器中继请求。这使攻击者可以以目标用户的身份与应用网站进行静默交互、实现后渗透目标。
但是，前提是终端用户必须使用 Internet Explorer 浏览器(iexplore.exe)，也就是说，只可以以目标用户的身份访问目标用户开在 Internet Explorer 浏览器中的那些应用(区别于 explorer.exe)，无法访问终端用户开在 Edge、Chrome 等浏览器上的那些应用。
0x02 实现原理 下面介绍【浏览器跳板攻击】的实现原理。
如果使用 socks 跳板/代理跳板来访问受害机终端用户打开的那些 web 应用，就无法通过身份认证：
那为什么浏览器跳板攻击与 socks 跳板不同，可以通过身份认证呢？
关键点在于 WinINet 这个库。工作原理是：
进程注入。浏览器跳板技术将一个 agent(代理)注入到 IE 浏览器进程中；
在团队服务器上创建一个 HTTP 代理服务器。到时候攻击者通过请求此代理服务器的 IP 和端口，进而变成了 agent 的一个请求任务；
当攻击者从自己的浏览器请求 web 应用时，IE 中的 agent (代理)将此请求转化为对 WinINet 库的 API 调用；
恰好， WinINet 也是 IE 浏览器用于 web 通信和管理身份认证的库。Internet Explorer 将其所有通信委托给 WinINet 库。并且使用 WinINet 这个库来管理其用户的 cookies、SSL 会话和服务器身份验证；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b15d31cc7feb0d0d1a9b45e1fd7989c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/724b906efcfe5de5286d9b2809b2b681/" rel="bookmark">
			python 删除set指定值_python入门教程NO.6 用python做个简单的彩票号码统计分析工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python入门教程
python入门教程NO.6 用python做个简单的彩票号码统计分析工具 本文涉及的python基础语法是：字典、集合及for循环
字典的定义 字典也是一种可变的容器，它可以存储任意的类型对象。字典中的每个key: value键值对用冒号 : 分割，不同键值对之间用逗号 , 分割，整个字典包括在花括号{}中 ，示例如下 dic = {key1 : value1, key2 : value2, key3 : value3} python字典的健必须不可变(可以是字符串、数字、元组，不能是列表)，如果一个字典内部有相同的健，那么后面的健值会替换前面的同名健值
dic = {'a': 5, 'b': 8, 'c': 9 , 'a': 0}print(dic['a'])#输出：0print(dic)#输出：{'a': 0, 'b': 8, 'c': 9} 如果用不在字典里面的健获取数据，会发生如下的错误
dic = {'a': 5, 'b': 8, 'c': 9 , 'a': 0}print(dic['ae'])#输出：Traceback (most recent call last): File "D:/test/demo.py", line 2, in print(dic['ae'])KeyError: 'ae' 字典的增删改查 dic = {'name': 'python攻城狮' , 'gender': '男' , 'hobby': '写代码'}#通过赋值的方式，增加新的键值对dic['age'] = 28 print(dic)#输出：{'name': 'python攻城狮', 'gender': '男', 'hobby': '写代码', 'age': 28}#通过del方法，可以删除指定的键值对dic = {'name': 'python攻城狮', 'gender': '男', 'hobby': '写代码', 'age': 28}del dic['gender']print(dic)#输出：{'name': 'python攻城狮', 'hobby': '写代码', 'age': 28}#可以直接通过赋值的方式修改指定健的值dic = {'name': 'python攻城狮', 'hobby': '写代码', 'age': 28}dic['age'] = 30print(dic['age']) #输出：30#查找字典里面健的值dic = {'name': 'python攻城狮', 'hobby': '写代码', 'age': 28}print(dic['name']) #输出：python攻城狮#判断是否存在该健dic = {'name': 'python攻城狮', 'hobby': '写代码', 'age': 28}if 'interest' in dic: print('True')else: print('False')#输出：False 即表明该健不在字典dic中，if.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/724b906efcfe5de5286d9b2809b2b681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71b82cf0b96fcddabee22e8e3f31e7d8/" rel="bookmark">
			uniapp富文本复制文字内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设置样式即可
text, span, p { user-select: text; -webkit-user-select: text; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63b91477d5152a46547151e04e281fd3/" rel="bookmark">
			MATLAB —— 绘制频谱图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 语法：
Y=fft(X)
Y=fft(X,n)
Y=fft(X,n,dim)
Y=fft(X)用快速傅里叶转换FFT算法计算离散傅里叶变换DFT。 如果X是向量，那么fft(X)返回向量的傅里叶变换。如果X是矩阵，那么fft(X)返回X中每一列向量的傅里叶变换。 Y=fft(X,n)指定进行n点DFT，如果X长度小于n则补零，如果X长度大于n则截断为n。Y=fft(X,n,dim)根据维度进行傅里叶变换。 说明：
fft之后信号幅度值变大，要得到真实幅度值大小，要将变换后结果除以N再乘以2（直流即零频率处除以N），除以N得到双边频谱，乘以2得到单边频谱。如果原始信号就是复数信号，则fft得到的就是单边频谱不用乘以2。对fs采样频率信号，fft之后最高频率为采样频率一半，fft之后的值关于半采样率共轭对称。 Fs = 1000; % Sampling frequency T = 1/Fs; % Sampling period L = 1500; % Length of signal t = (0:L-1)*T; % Time vector %50Hz和120Hz频率信号 S = 0.7*sin(2*pi*50*t) + sin(2*pi*120*t); %添加随机噪声 X = S + 2*randn(size(t)); figure;plot(1000*t(1:50),X(1:50)) title('Signal Corrupted with Zero-Mean Random Noise') xlabel('t (milliseconds)') ylabel('X(t)') %加噪声后信号X长度1500，进行1500点FFT Y = fft(X); %为何除以信号长度L? P2 = abs(Y/L); P1 = P2(1:L/2+1);%单边谱 P1(2:end-1) = 2*P1(2:end-1);%由于P1(1)是直流吧 f = Fs*(0:(L/2))/L;%采样频率Fs,因此只看fs/2内的信号 figure;plot(f,P1) title('Single-Sided Amplitude Spectrum of X(t)') xlabel('f (Hz)') ylabel('|P1(f)|') %原始信号S长度1500，进行1500点FFT Y = fft(S); P2 = abs(Y/L); P1 = P2(1:L/2+1); P1(2:end-1) = 2*P1(2:end-1); figure;plot(f,P1) title('Single-Sided Amplitude Spectrum of S(t)') xlabel('f (Hz)') ylabel('|P1(f)|') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d0851a43da6d9ac8ec822ff2d8ec62f/" rel="bookmark">
			《性格色彩》测试加分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 关于人生观，我的内心其实是：
A、希望能有各种各样的人生体验，所以想法极其多样化。
B、在合理的基础上，谨慎确定目标，一旦确定会坚定不移地去做。
C、更加在乎取得一切有可能的成就。
D、毫不喜欢风险，喜欢享受稳定或现状。
2、如果爬山旅游，大多数状况下，在下山回来的路线我最可能：
A、好玩有趣，所以宁愿新路线回巢。
B、安全稳妥，所以宁愿原路线返回。
C、挑战困难，所以宁愿新路线回巢。
D、方便省心，所以宁愿原路线返回。
3、 说话时，我更看重：
A、感觉效果。有时可能会略显得夸张。
B、描述精确。有时可能略过冗长。
C、达成结果。有时可能过于直接让别人不高兴。
D、人际感受。有时可能会不愿讲真话。
4、 在大多数时候，我的内心更想要：
A、刺激。经常冒出新点子，想做就做，喜欢与众不同。
B、安全。头脑冷静，不易冲动。
C、挑战。生命中竞赛随处可见，有强烈的“赢”的欲望。
D、稳定。满足自己所拥有的，很少羡慕别人。
5、 我认为自己在情感上的基本特点是：
A、情绪多变，经常波动。
B、外表自我抑制强，但内心感情起伏大，一旦挫伤难以平复。
C、感情不拖泥带水，只是一旦不稳定，容易发怒。
D、天性情绪四平八稳。
6、 我认为自己除了工作外，在控制欲上面，我：
A、没有控制欲，只有感染带动他人的欲望，但自控能力不算强。
B、用规则来保持我对自己的控制和对他人的要求。
C、内心是有控制欲和希望别人服从我的。
D、没兴趣影响别人，也不愿别人来控制我。
7、 当与情人交往时，我最希望对方：
A、经常赞美我，让我享受开心、被关怀且又有一定自由。
B、可随时默契到我内心所想，对我的需求极其敏丄感。
C、得到对方的认可，我是正确的并且我对其是有价值的。
D、尊重并且相处静谧的。
8、 在人际交往时，我：
A、本质上还是认为与人交往比长时间独处是有乐趣的。
B、非常审慎缓慢地进入，经常会被人认为容易有距离感。
C、希望在人际关系中占据主导地位。
D、顺其自然，不温不火，相对被动。
9、我做事情，经常：
A、缺少长性，不喜欢长期做相同无变化的事情。
B、缺少果断，期待最好的结果但总能先看到事情的不利面。
C、缺少耐性，有时行事过于草率。
D、缺少紧迫，行动迟缓，难下决心。
10、 通常我完成任务的方式是：
A、常赶在最后期限前完成，是临时抱佛脚的高手。
B、自己有严格规定的程序，精确地做，不要麻烦别人。
C、先做，快速做。
D、使用传统的方法按部就班，需要时从他人处得到帮忙。
11、 如果有人深深惹恼我时，我：
A、内心感到受伤，认为没有原谅的可能，可最终很多时候还是会原谅对方。
B、深深感到愤怒，如此之深怎可忘记?我会牢记，同时未来完全避开那个家伙。
C、会火冒三丈，并且内心期望有机会狠狠地回应。
D、避免摊牌，因为还不到那个地步或者自己再去找新朋友。
12、 在人际关系中，我最在意的是：
A、得到他人的赞美和欢迎。
B、得到他人的理解和欣赏。
C、得到他人的感激和尊敬。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d0851a43da6d9ac8ec822ff2d8ec62f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/853eb2e827169957ec777dfebd2ce23c/" rel="bookmark">
			Halcon 《机器视觉算法及应用》十例（其一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*该程序显示了如何在水平对准的晶圆上找到管芯
* * 显示初始化
read_image (WaferDies, 'wafer_dies')
dev_close_window ()
dev_open_window_fit_image (WaferDies, 0, 0, 700, 500, WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
get_window_extents (WindowHandle, WindowRow, WindowColumn, WindowWidth, WindowHeight)
dev_update_off ()
dev_set_draw ('margin')
get_image_size (WaferDies, Width, Height)
dev_display (WaferDies)
dev_disp_text ('Image of a wafer', 'window', 12, 12, 'black', [], [])
dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])
stop ()
* * 1. 通过使用自动关联确定芯片的尺寸
* rft_generic (WaferDies, ImageFFT, 'to_freq', 'none', 'complex', Width) //计算图像的实值快速傅立叶变换。时域到频域
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/853eb2e827169957ec777dfebd2ce23c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7729f52e98767d861db48f516b5a8554/" rel="bookmark">
			学习笔记｜fmri_4 预处理 co- register segment normalize smooth SPM12
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		到这里可以往回看预处理包括哪些步骤：可视化（Visualization）、去伪影（Artifact removal）、时间配准（Slice time correction）、头动校正（Motion correction/realign）、生理噪音校正（Correction for physiological effect）、结构功能配准（Co-registration）、标准化（Normalization）和时空间滤波（Spatial and temporal filtering）。
注：很多教程的预处理步骤都不太一样，按需找教程参考。
链接：https://zhuanlan.zhihu.com/p/22385985
附一个知乎链接，fmri概念讲解比较简洁清楚
下面就接着记录motion correction之后的预处理步骤，motion之类的操作见学习笔记｜fmri_3
视频链接：https://b23.tv/ixIeQb 从28min开始，因为之前的视频p6到p7直接跳到1st level analysis（fMRI数据分析：从MRI理论讲解到SPM操作，https://www.bilibili.com/video/BV1Vt411c7D5?p=6）。
缺少后续预处理教程，所以换一个看，补充一下。
1 co- register 把不同被试的大脑放到标准空间里，为了和后面MNI标准大脑对到一起。
根据结构像定位功能像，把功能图像上的点定位在有着较高分辨率的结构图像上。
定中点 参考下面的链接做前面的原点矫正，然后再做co register
使用spm进行原点校正
http://blog.sina.com.cn/s/blog_a1f9cadd0102y6nd.html
co- register 点点点： 在Menu中选择co register，出现Batch Editor，有两个X需要选择
1、reference image： 是realign的步骤会生成一个mean的文件，选择mean文件，作为被试功能像的参考
2、source image
结构像参考，也是T1像，一般在核磁数据的T1 文件夹里，找有T1关键字的文件夹，一般里面就是结构像的参考。 下面截图是跑过co register了，没跑之前只有一个020.img可以选为source image。选完两个参考，run
co register结果 T1的文件夹中会出现带r前缀的新文件，可以再选择mean文件和r020.img做比较，看配准的结果如何。
点点点：选Menu最下面的窗口 Check reg——选T1文件夹下新生成的文件 如r020.img——再选择任务文件夹中的mean文件。
然后就可以比较一下配准结果，类似看一下有没有脑区在脑壳外的？【再补充】
2 segment 目的：对结构像的原像进行分割，一般切割为白质、灰质和脑脊液。
点点点：Menu的segment——volume，添加结构像，T1最开始的结构像数据——点击save biased correted，在current item下选择save biased correted——拉到最底下，deformation fields，选择Forward。
新数据 下面几张nii分别就是拆出来的结构数据（.nii都是这步跑出来的）
3 Normalize 目的：将个人脑图像与脑标准模板（atlas template）配准
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7729f52e98767d861db48f516b5a8554/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eae6e6f7756daf1efde214a3eefa69a/" rel="bookmark">
			ADC转换后的值推算还原实际测量电量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ADC转换后的值推算还原实际测量电量
1.确定ADC用几位表示，最大数值是多少；
例如一个8位的ADC，最大值是0XFF，就是255
2.确定最大值时对应的参考电压值；
一般而言最大值对应5V，具体需参考芯片ADC模块的说明，寄存器有对于输入信号参考电压的设置，有些是电压输入的1/3等
3.计算实际电压，把ADC数值除以刚才确定的最大数值再乘以参考电压值；
例如ADC转换值为0x80，那么实际值就是0x80/（0xFF+1）*3.3V=1.65v
4.计算出来的电压值只是ADC管脚的电压值，至于放大器等等，都是芯片外部的事情，外部电路和芯片ADC的采样值无关；
5.如果想知道芯片外部的某处电压，可根据ADC管脚的电压值结合电路图进行计算。
注：文章转载于下方链接，如有不当请联系作者删载，谢谢！
链接: link.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e61b701079e18a800bdb0497f49659/" rel="bookmark">
			统计24小时内每个小时最后一条数据_电商业务中必须了解的数据分析指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不懂业务的数据分析都是在耍流氓！由此可见对于业务的理解和掌握是数据分析的前提和必要条件，今天我们就来梳理下在电商行业进行数据分析时常用的一些分析指标。
看到上边的指标多的眼花缭乱，那么哪些指标是电商分析的核心指标呢？
这是一个好问题，不过没有标准答案。企业性质不同，所处阶段不同，行业不同，企业负责人的关注点自然也不同，不过从公司的发展阶段大体可以这样分：
1、新电商公司：对于一个新电商来说，积累数据，找准营运方向比卖多少货，赚多少钱更重要。这个阶段可以重点关注流量指标，包括访客数、访客来源、注册用户数、浏览量、浏览深度、产品的浏览量排行、产品的跳失率、顾客评价指数、转化率等。
2、运营一段时间的电商：对于这个阶段，通过数据分析提高店铺销量是首要任务。此阶段重点指标是流量和销售指标，包括访客数、浏览量、转化率、新增会员数、会员流失率、客单价、动销率、库存天数、销售额、费销比等。
3、很有规模的电商：这个阶段的额公司，通过数据分析提升整体营运水平就很关键。他们的重点指标是访客数、浏览量、转化率、复购率、流失率、留存率、客单价、利润率、ROI（费销比的倒数）、新客成本、库存天数、订单满足率、销售额等。会员复购率和会员留存率必须一起看，复购率再高，如果会员留存率大幅下降也是很危险的。
那具体每个指标是什么意思呢？
我们只介绍几个重点的指标，其他的大家可以百度之~
浏览量（访问量）：PV（page view），指用户访问页面的总数，用户每访问一个网页就算一个访问量，同一个页面刷新一次也算一个访问。访客数(UV)：独立访客，一台电脑为一个独立访问人数。一般以天为单位来统计24小时内的UV总数，一天之内重复访问的只算一次。每家公司的访客数定义略有不同，比如淘宝是以卖家所选时间段（可能是一小时、一天、一周）为统计标准。访客数又分新访客数和回访客数。新访客数是指客户端首次访问页面的用户数。当前在线人数：一般指15分钟内在线的UV数。平均在线时间：指平均每个UV访问网页停留的时间长度，这个值越大越好。平均访问深度：指用户每次浏览的页面平均值，即平均每个UV访问了多少个PV。跳出率：就是只浏览了一个页面就离开的访问次数除以该页面的全部访问次数。分为首页跳出率、关键页面跳出率、具体产品页面跳出率等。转化率：进行了相关动作的访问量占总访问量的比率。新客成本：为了获取一个新客户所投入的平均营销成本。客单价：每笔交易的平均金额，客单价=销售总金额/成交总笔数 以上资料参考《数据化管理-洞悉零售及电子商务运营》，先写这么多，随时进来更新，觉得有用的点个赞哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d04175f1ba7d6fabbceedc4b5f6d0408/" rel="bookmark">
			卷积的微积分性质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 知乎有篇文章不错，传送门在这儿！
参考文献：
https://wenku.baidu.com/view/a878f18432d4b14e852458fb770bf78a64293a17.htmlhttps://www.cnblogs.com/wdfrog/p/10244353.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ece44d748a55ed8a4a1c98a7ee2a87/" rel="bookmark">
			怎么查看电脑内存和配置_3分钟学会升级电脑内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【看需求】
打开AIDA64，在电脑工作状态下，查看内存占用情况，看看自己是否有升级内存的需要。如果内存占用率高，无法满足我们想要的电脑运行负荷，和想要的电脑操作体验，那么可以选择升级内存。
【看电压】
在AIDA64找到SPD信息，在里面可以看到内存条的模块电压。在选择笔记本DDR3内存条时，我们需要先了解笔记本电脑支持的内存条的电压。如果你的笔电只支持低压内存条，你买根标压内存条就不行。
【看最大容量】
在AIDA64-计算机-芯片组下，可以看到电脑支持的最大内存容量。不用去找主板信息。老电脑的主板信息可不好找。
【看频率支持】
一般只要不是很旧的主板，我们都能在网上搜索到CPU和主板支持多大容量，多高频率的内存。
【老电脑组双通】
老电脑组双通前，如果主板对内存插槽的标记不清楚，可在DMI下的内存设备里，看看自己原来那根内存条插在哪个位置，以便插在对的位置组成双通。ChannelA-DIMM0、ChannelB-DIMM0，组双通。ChannelA-DIMM1、ChannelB-DIMM1，组双通。是否成功组成双通，可用CPU-Z软件查看。
【选高频率还是大容量】
如果你的电脑配置高，是游戏玩家，有超频的需求，那内存条当然是频率、容量越高越好啦。而如果你的电脑配置不高的或使用笔记本电脑，那么低价格、大容量、高质量、售后有保证的内存条才是我们的首选。当然如果像上面这两款，能够兼顾性能，频率也不错，那就太好了。
以上，就是我们“3分钟教你轻松升级电脑内存”的全部内容。如果你在升级电脑前，感到茫然，无从下手，那么请阅读收藏此文。希望能够帮助那些对电脑不太了解的玩家顺利升级电脑内存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c254a189b076ce9e1e4e23f40ff752/" rel="bookmark">
			TiDB3.0- 4.0 内存控制/修改日志保存天数/最大索引长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方参考
注意事项 TiDB不允许修改 操作系统内存分配策略为 2，只允许为 0 或 1
TUG修改内存使用策略导致 TiDB自动下线
什么是操作系统内存分配策略？
调整TiDB-Server的内存使用上限tidb3.0 1 修改 inventory.ini inventory.ini配置文件最后添加MemoryLimit=25G
根据自己机器实际的内存来设置当 TiDB-Server 进程的 常驻内存 超过这个限制，进程将被杀死并且在TiDB-Server的日志中抛出 OOM 异常 [root@test ~]# cat /etc/systemd/system/tidb-4000.service [Unit] Description=tidb-4000 service After=syslog.target network.target remote-fs.target nss-lookup.target [Service] # 常驻内存上限 MemoryLimit=25G LimitNOFILE=1000000 #LimitCORE=infinity LimitSTACK=10485760 User=tidb ExecStart=/home/tidb/deploy/scripts/run_tidb.sh Restart=always RestartSec=15s [Install] WantedBy=multi-user.target [root@dev11 ~]# 注：这个操作改变的是 /etc/systemd/system/tidb-4000.service 文件中的配置
[root@hostname ~]# cat /etc/systemd/system/tidb-4000.service | grep MemoryLimit MemoryLimit=25G [root@hostname ~]# TiDB Server 常驻内存与实际堆内存相差较大
2 滚动更新 tidb (修改完配置文件一定要更新配置) [root@hostname ~]# ansible-playbook rolling_update.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40c254a189b076ce9e1e4e23f40ff752/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9a86171a98acd10ed2bb45d53201692/" rel="bookmark">
			Java学习笔记 面向对象（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第六章 面向对象（下） 1.this与super2.构造方法的多态3.抽象类4.接口（interface）5.引用6.类的其他相关内容 1.this与super this
this.域变量和this.成员方法
明确表示用的是类的域变量
public class Test{ int i; public otherMethod(){ int i = 3; this.i = i+2; } } this（参数）
引用重载的构造方法
this指代当前对象
/*已设定class FighterPlane，其中有成员方法public void setA（A _a） 和域变量private A a*/ public void setA（A _a）{ if(_a!=null) {return a;} else return null; } class A{ FighterPlane fp; public A(FighterPlane fpp){ this.fp = fpp;//this获得了FighterPlane对象的引用 fpp.setA(this);//this指代当前的A对象 } } //主程序main中有以下语句 public static void main（String[] args）{ FighterPlane ftp = new FighterPlane()；//构造方法初始化 A a = new A(ftp); /*在class A的构造方法中，this指代a， 并利用fpp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9a86171a98acd10ed2bb45d53201692/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41aebb0a184f2c7b93adcc904b9e620a/" rel="bookmark">
			创建自定义maven的docker镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时docker的官方maven镜像不能满足我们需求时，我们需要自定义maven的settings.xml文件，加上阿里云的映射和自己的私服
clone阿里云maven-image仓库：git@github.com:AliyunContainerService/maven-image.git
进入3-jdk-8目录，修改settings.xml文件
&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
https://maven.apache.org/xsd/settings-1.0.0.xsd"&gt;
&lt;localRepository&gt;/usr/share/maven/ref/repository&lt;/localRepository&gt;
&lt;servers&gt;
&lt;server&gt; &lt;id&gt;youseniu-releases&lt;/id&gt; &lt;username&gt;xxx&lt;/username&gt; &lt;password&gt;xxxx&lt;/password&gt; &lt;/server&gt;
&lt;server&gt;
&lt;id&gt;youseniu-snapshots&lt;/id&gt; &lt;username&gt;xxxx&lt;/username&gt; &lt;password&gt;xxxxx&lt;/password&gt; &lt;/server&gt;
&lt;/servers&gt;
&lt;mirrors&gt;
&lt;mirror&gt;
&lt;id&gt;alimaven&lt;/id&gt;
&lt;name&gt;aliyun maven&lt;/name&gt;
&lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;
&lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;
&lt;/mirrors&gt;
&lt;profiles&gt;
&lt;profile&gt;
&lt;id&gt;youseniu&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;youseniu&lt;/id&gt; &lt;name&gt;youseniu private nexus&lt;/name&gt; &lt;url&gt;http://ysnnexus.liyuchang.xin/repository/maven-public/&lt;/url&gt;
&lt;releases&gt;
&lt;enabled&gt;true&lt;/enabled&gt;
&lt;/releases&gt; &lt;snapshots&gt;
&lt;enabled&gt;true&lt;/enabled&gt;
&lt;/snapshots&gt; &lt;/repository&gt;
&lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;youseniu&lt;/id&gt; &lt;name&gt;youseniu private nexus&lt;/name&gt; &lt;url&gt;http://ysnnexus.liyuchang.xin/repository/maven-public/&lt;/url&gt;
&lt;releases&gt;
&lt;enabled&gt;true&lt;/enabled&gt;
&lt;/releases&gt; &lt;snapshots&gt;
&lt;enabled&gt;true&lt;/enabled&gt;
&lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt;
&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41aebb0a184f2c7b93adcc904b9e620a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba30ba622c4c1c8d13b4597ef8f4f13d/" rel="bookmark">
			Docker系列教程12-使用Maven插件构建Docker镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道，Maven是一个强大的项目管理与构建工具。如果可以使用Maven构建Docker镜像，那么我们的工作就能得到进一步的简化。
经过调研，以下几款Maven的Docker插件进入笔者视野，如表13-1所示。
插件名称官方地址docker-maven-pluginhttps://github.com/spotify/docker-maven-plugindocker-maven-pluginhttps://github.com/fabric8io/docker-maven-plugindocker-maven-pluginhttps://github.com/bibryam/docker-maven-plugin 表13-1 Maven的Docker插件列表
笔者从各项目的功能性、文档易用性、更新频率、社区活跃度、Stars等几个纬度考虑，选用了第一款。这是一款由Spotify公司开发的Maven插件。
下面我们来详细探讨如何使用Maven插件构建Docker镜像。
快速入门 以项目microservice-discovery-eureka 为例。
(1) 在pom.xml中添加Maven的Docker插件。
&lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.4.13&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;itmuch/microservice-discovery-eureka:0.0.1&lt;/imageName&gt; &lt;baseImage&gt;java&lt;/baseImage&gt; &lt;entryPoint&gt;["java", "-jar", "/${project.build.finalName}.jar"]&lt;/entryPoint&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;${project.build.directory}&lt;/directory&gt; &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/plugin&gt; 简要说明一下插件的配置：
① imageName：用于指定镜像名称，其中itmuch是仓库名称，microservice-discovery-eureka是镜像名称，0.0.1是标签名称。
② baseImage：用于指定基础镜像，类似于Dockerfile中的FROM指令。
③ entrypoint：类似于Dockerfile的ENTRYPOINT指令。
④ resources.resource.directory：用于指定需要复制的根目录，${project.build.directory}表示target目录。
⑤ resources.resource.include：用于指定需要复制的文件。${project.build.finalName}.jar指的是打包后的jar包文件。
(2) 执行以下命令，构建Docker镜像。
mvn clean package docker:build 我们会发现终端输出类似于如下的内容：
[INFO] Building image itmuch/microservice-discovery-eureka:0.0.1 Step 1 : FROM java ---&gt; 861e95c114d6 Step 2 : ADD /microservice-discovery-eureka-0.0.1-SNAPSHOT.jar // ---&gt; 035a03f5b389 Removing intermediate container 2b0e70056f1d Step 3 : ENTRYPOINT java -jar /microservice-discovery-eureka-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba30ba622c4c1c8d13b4597ef8f4f13d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae563e093361060aeb1e58e4973f376e/" rel="bookmark">
			for循环基础练习学案：打印平行四边形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间复杂度：1000ms
空间复杂度：524288K
题目链接
题目描述 现在需要打印一个 nn 行的由字母 A 组成的平行四边形，我们来跟他比赛一下谁写得又快又好吧！
当 n = 5 时，这个平行四边形是这样的：
AAAAA AAAAA AAAAA AAAAA AAAAA 输入格式 输入一行包含 11 个整数 n(1≤n≤100) 。
输出格式 输出 nn 行，为题目要求的平行四边形
输出时每行末尾的多余空格，不影响答案正确性
样例输入
3 样例输出
AAA AAA AAA C++: #include &lt;iostream&gt; using namespace std; int main() { int n, sp; cin &gt;&gt; n; sp = n - 1; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; sp; j++) cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae563e093361060aeb1e58e4973f376e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de45dd7ecf5693c36da6cda1d9d9b49/" rel="bookmark">
			odom坐标系的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS中基本坐标系的理解：map，odom，base_link，base_laster 1.map 地图坐标系，顾名思义，一般设该坐标系为固定坐标系，一般与机器人所在的世界坐标是重合的。
2.base_link 机器人本体坐标系，与机器人中心重合，当然有些机器人是base_footprint。
3.odom 里程计坐标系，这里主要区分odom topic，这是两个概念，一个是坐标系，一个是根据编码里程计计算得到的里程计信息。但是两者也有关系，odom topic转化得到的位姿矩阵是odom-&gt;base_link的tf关系。这时可能会有疑问：
①位姿矩阵得到的不应该是map-&gt;base_link的tf关系吗？
②map坐标系与odom坐标系又有什么关系？
其实机器人刚开始运动时，odom坐标系与map坐标系是重合的，即odom-&gt;base_link与map-&gt;base_link的tf是一致的。
但是随着时间的推移，出现了偏差，出现的偏差也就是里程计的累计误差，如果里程计精确度很高，没有计算误差，那么map坐标系与odom坐标系会一直是重合的。
然而实际情况中，里程计是有偏差的，所以我们计算里程计得到的位姿矩阵是odom-&gt;base_link，与map-&gt;base_link还是有偏差的。
③那么map-&gt;odom的tf是怎么得到的呢？
除去里程计还有一些合作校正的传感器例如imu，这些传感器可以估计出机器人在地图中的位置也就是map-&gt;base_link的tf，我们估计机器人在地图中的位置和解算里程计得到的位置的偏差也就是map-&gt;odom的tf。
4.base_laser 激光雷达坐标系，与激光雷达的安装点有关，它与base_link的tf是固定的。
小结 最近在看tf的相关知识，后面会抽空总结一点，大家一起加油一起冲，周末愉快！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9b6c0b8d80fabe677f461433f04d9a3/" rel="bookmark">
			【top K问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海量数据处理 - 10亿个数中找出最大的10000个数（top K问题）
建立最小堆
先拿10000个数建堆，然后一次添加剩余元素，如果大于堆顶的数（10000中最小的），将这个数替换堆顶，并调整结构使之仍然是一个最小堆，这样，遍历完后，堆中的10000个数就是所需的最大的10000个。建堆时间复杂度是O（mlogm），算法的时间复杂度为O（nmlogm）（n为10亿，m为10000）。
优化的方法：可以把所有10亿个数据分组存放，比如分别放在1000个文件中。这样处理就可以分别在每个文件的10^6个数据中找出最大的10000个数，合并到一起在再找出最终的结果。
以上就是面试时简单提到的内容，下面整理一下这方面的问题：
top K问题
在大规模数据处理中，经常会遇到的一类问题：在海量数据中找出出现频率最好的前k个数，或者从海量数据中找出最大的前k个数，这类问题通常被称为top K问题。例如，在搜索引擎中，统计搜索最热门的10个查询词；在歌曲库中统计下载最高的前10首歌等。
针对top K类问题，通常比较好的方案是分治+Trie树/hash+小顶堆（就是上面提到的最小堆），即先将数据集按照Hash方法分解成多个小数据集，然后使用Trie树活着Hash统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出现频率最高的前K个数，最后在所有top K中求出最终的top K。
eg：有1亿个浮点数，如果找出期中最大的10000个？
最容易想到的方法是将数据全部排序，然后在排序后的集合中进行查找，最快的排序算法的时间复杂度一般为O（nlogn），如快速排序。但是在32位的机器上，每个float类型占4个字节，1亿个浮点数就要占用400MB的存储空间，对于一些可用内存小于400M的计算机而言，很显然是不能一次将全部数据读入内存进行排序的。其实即使内存能够满足要求（我机器内存都是8GB），该方法也并不高效，因为题目的目的是寻找出最大的10000个数即可，而排序却是将所有的元素都排序了，做了很多的无用功。
第二种方法为局部淘汰法，该方法与排序方法类似，用一个容器保存前10000个数，然后将剩余的所有数字——与容器内的最小数字相比，如果所有后续的元素都比容器内的10000个数还小，那么容器内这个10000个数就是最大10000个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即10000。
第三种方法是分治法，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的100*10000个数据里面找出最大的10000个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的10000个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于10000个，就在小的那堆里面快速排序一次，找第10000-n大的数字；递归以上过程，就可以找到第1w大的数。参考上面的找出第1w大数字，就可以类似的方法找到前10000大数字了。此种方法需要每次的内存空间为10^6*4=4MB，一共需要101次这样的比较。
第四种方法是Hash法。如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的10000个数。
第五种方法采用最小堆。首先读入前10000个数来创建大小为10000的最小堆，建堆的时间复杂度为O（mlogm）（m为数组的大小即为10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有10000个数字。该算法的时间复杂度为O（nmlogm），空间复杂度是10000（常数）。
实际运行：
实际上，最优的解决方案应该是最符合实际设计需求的方案，在时间应用中，可能有足够大的内存，那么直接将数据扔到内存中一次性处理即可，也可能机器有多个核，这样可以采用多线程处理整个数据集。
下面针对不容的应用场景，分析了适合相应应用场景的解决方案。
（1）单机+单核+足够大内存
如果需要查找10亿个查询次（每个占8B）中出现频率最高的10个，考虑到每个查询词占8B，则10亿个查询次所需的内存大约是10^9 * 8B=8GB内存。如果有这么大内存，直接在内存中对查询次进行排序，顺序遍历找出10个出现频率最大的即可。这种方法简单快速，使用。然后，也可以先用HashMap求出每个词出现的频率，然后求出频率最大的10个词。
（2）单机+多核+足够大内存
这时可以直接在内存总使用Hash方法将数据划分成n个partition，每个partition交给一个线程处理，线程的处理逻辑同（1）类似，最后一个线程将结果归并。
该方法存在一个瓶颈会明显影响效率，即数据倾斜。每个线程的处理速度可能不同，快的线程需要等待慢的线程，最终的处理速度取决于慢的线程。而针对此问题，解决的方法是，将数据划分成c×n个partition（c&gt;1），每个线程处理完当前partition后主动取下一个partition继续处理，知道所有数据处理完毕，最后由一个线程进行归并。
（3）单机+单核+受限内存
这种情况下，需要将原数据文件切割成一个一个小文件，如次啊用hash(x)%M，将原文件中的数据切割成M小文件，如果小文件仍大于内存大小，继续采用Hash的方法对数据文件进行分割，知道每个小文件小于内存大小，这样每个文件可放到内存中处理。采用（1）的方法依次处理每个小文件。
（4）多机+受限内存
这种情况，为了合理利用多台机器的资源，可将数据分发到多台机器上，每台机器采用（3）中的策略解决本地的数据。可采用hash+socket方法进行数据分发。
从实际应用的角度考虑，（1）（2）（3）（4）方案并不可行，因为在大规模数据处理环境下，作业效率并不是首要考虑的问题，算法的扩展性和容错性才是首要考虑的。算法应该具有良好的扩展性，以便数据量进一步加大（随着业务的发展，数据量加大是必然的）时，在不修改算法框架的前提下，可达到近似的线性比；算法应该具有容错性，即当前某个文件处理失败后，能自动将其交给另外一个线程继续处理，而不是从头开始处理。
top K问题很适合采用MapReduce框架解决，用户只需编写一个Map函数和两个Reduce 函数，然后提交到Hadoop（采用Mapchain和Reducechain）上即可解决该问题。具体而言，就是首先根据数据值或者把数据hash(MD5)后的值按照范围划分到不同的机器上，最好可以让数据划分后一次读入内存，这样不同的机器负责处理不同的数值范围，实际上就是Map。得到结果后，各个机器只需拿出各自出现次数最多的前N个数据，然后汇总，选出所有的数据中出现次数最多的前N个数据，这实际上就是Reduce过程。对于Map函数，采用Hash算法，将Hash值相同的数据交给同一个Reduce task；对于第一个Reduce函数，采用HashMap统计出每个词出现的频率，对于第二个Reduce 函数，统计所有Reduce task，输出数据中的top K即可。
直接将数据均分到不同的机器上进行处理是无法得到正确的结果的。因为一个数据可能被均分到不同的机器上，而另一个则可能完全聚集到一个机器上，同时还可能存在具有相同数目的数据。
以下是一些经常被提及的该类问题。
（1）有10000000个记录，这些查询串的重复度比较高，如果除去重复后，不超过3000000个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。请统计最热门的10个查询串，要求使用的内存不能超过1GB。
（2）有10个文件，每个文件1GB，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。按照query的频度排序。
（3）有一个1GB大小的文件，里面的每一行是一个词，词的大小不超过16个字节，内存限制大小是1MB。返回频数最高的100个词。
（4）提取某日访问网站次数最多的那个IP。
（5）10亿个整数找出重复次数最多的100个整数。
（6）搜索的输入信息是一个字符串，统计300万条输入信息中最热门的前10条，每次输入的一个字符串为不超过255B，内存使用只有1GB。
（7）有1000万个身份证号以及他们对应的数据，身份证号可能重复，找出出现次数最多的身份证号。
重复问题
在海量数据中查找出重复出现的元素或者去除重复出现的元素也是常考的问题。针对此类问题，一般可以通过位图法实现。例如，已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。
本题最好的解决方法是通过使用位图法来实现。8位整数可以表示的最大十进制数值为99999999。如果每个数字对应于位图中一个bit位，那么存储8位整数大约需要99MB。因为1B=8bit，所以99Mbit折合成内存为99/8=12.375MB的内存，即可以只用12.375MB的内存表示所有的8位数电话号码的内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/459f5a2233c1cb0cadf6c62adf64dd60/" rel="bookmark">
			lsnrctl start报错NL-00280: error creating log stream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 TNSLSNR for Linux: Version 19.0.0.0.0 - Production NL-00280: error creating log stream /u01/app/oracle/product/19.3.0/dbhome_1/network/log/listener.log NL-00278: cannot open log file SNL-00016: snlfohd: error opening file Linux Error: 13: Permission denied Listener failed to start. See the error message(s) above... 提示没权限，用oracle用户启动监听（创建监听的相应用户） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f716bd51ec3439b3c878907ee5d9eb/" rel="bookmark">
			【4G通讯模组相关】 TCPIP连接本地电脑测试 、内网穿透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍4G、CAT1通讯模组 通过TCPIP连接至本地电脑，进行数据的收发。 1、先开启windows相关服务。
WIN10好像是没有Telnet服务器，需要自己安装。Telnet服务器（或文末有其他下载方式）。
2、先查询自己的IP地址，www.ip138.com处可以看到自己的IP地址。
再打开CMD命令提示符，输入ipconfig查询本地电脑的IP地址。
我这里与在www.ip138.com处查到的IP地址不同，说明我这个是内网的IP地址，需要再做一步内网穿透的操作，变成公网可访问的IP，进行第3步。如果相同说明是外网的IP了，直接跳至第4步。
3、内网穿透操作。
我这里用的是花生壳软件，下载安装完成后，增加自定义映射。
保存就创建好一个映射了，这个时候点开诊断，会发现出现局域网服务器连接失败。
是因为没有开启服务器，我们这里用sscom工具来作为服务器。（sscom下载方式）
IP地址可以选择对外的映射出来的IP地址（103.46.128.45），也可以选择内网地址（我这里是192.168.3.6），端口号就是添加时的端口号（我这里是8888），完成后打开 侦听。
再打开诊断，就会发现正常了，外网就可以通过下面的IP或域名，以及端口号来连接本地电脑了。
4、通过网络工具进行调试。
我这里用SSCOM工具，左边相当于设备端，也就是模组；右边是服务器。左侧发数据右侧能收到说明可以正常使用了。
后续测试模组TCP连接时，只用开右边这个服务端，模块按照对应的IP地址与端口连接后，就可以往本机发数据了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ed4a2234393fdf3b1f6a7b7a422a47/" rel="bookmark">
			魔数湖南大学程序设计作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】
魔数是由数字1、14和144连接而成的数，可以使用这些数任意多次，因此14144、141414和1411是魔数，而514和414不是。 【输入形式】
输入一个整数n(1≤n≤109)。 【输出形式】
如果n是魔数，则输出"YES"，否则输出"NO" 【样例输入1】
114114
【样例输出1】
YES
【样例输入2】
441231
【样例输出2】
NO
实现思路：找出1，14，144各有几个，再将每个数个数与相应的个数相乘得到一个数字位数，再将这个数字位数与输入的数字位数比较，若相等（即数字中没有掺杂其他的数），则这个数为魔数。
注意：144中含有1和14；14中含有1，全位数的的时候要相应变化！
代码展示：
#include&lt;iostream&gt; using namespace std; int z1(int w);//定义找1,14,144,的函数和确定输入数字位数的函数 int z14(int x); int z144(int y); int zws(int z); int main() {int n,a,b,c,d; cin&gt;&gt;n; a=z1(n),b=z14(n),c=z144(n),d=zws(n); if((a+b+c)==d)cout&lt;&lt;"YES"; else cout&lt;&lt;"NO"; } int z14(int x){	int k=0; while(x!=0){	if(x%100==14)k++; x/=10;} return k;} int z144(int y){	int j=0; while(y!=0){	if(y%1000==144)j++; y/=10;} return j;} int zws(int z){	int i=0;	while(z!=0){	z/=10;	i++;	}	return i;} int z1(int w){	int m=0; while(w!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13ed4a2234393fdf3b1f6a7b7a422a47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/364603a23ef967dd081f6911e3aa2e73/" rel="bookmark">
			JDK(jdk1.8)源码剖析之 java.lang.String
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK(jdk1.8)源码 - String(java.lang.String)类源码阅读及分析
String类位于JDK下rt.jar包中，完整包路径是java.lang.String。
本文以java8(1.8.0_191)下String的源码为例子：jdk1.8.0_191_String源码，点击下载，源码文件总3169行。
本文章只对String类中部分函数做一些描述、理解、及分析。
下面以String类常用的字符串切割函数split函数为例，开始源码的探索。
步骤：
一.查看官方说明文档Java Platform SE 8。
二.初步源码阅读与分析。
三.正确理解源码，并加上自己的注释。
jdk说明文档对java.lang.String的描述如下：
从图二可以看出，关于字符串切割split的，String类内部提供了两个函数。那么，看看关于split的，这两个函数的源码：
java.lang.String#split(java.lang.String)
java.lang.String#split(java.lang.String, int)
public String[] split(String regex, int limit) { /* fastpath if the regex is a (1)one-char String and this character is not one of the RegEx's meta characters ".$|()[{^?*+\\", or (2)two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. */ char ch = 0; if (((regex.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/364603a23ef967dd081f6911e3aa2e73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a3ed10506e2df5b72134659e6b6ff2a/" rel="bookmark">
			ie浏览器网页版进入_荟萃浏览器v2.10.2清爽版 网页秒开/装机必备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		荟萃浏览器v2.10.2清爽版 网页秒开/装机必备https://www.lanzoux.com/iEq2ge0s3ej
·简约风格 界面简洁布局清爽，感受纯净简约之美。
·极速浏览 精心优化加载速度，畅享极速浏览体验。
·广告拦截 标记任意广告元素，深度清除广告来源。
·语音朗读 独创网页朗读技术，智能朗读任意网页。
·阅读模式 文本重排去除广告，识别下页沉浸阅读。
·看图模式 智能提取页内大图，自动加载分页图集。
·定制界面 按钮位置随意调整，满足个性使用习惯。
·插件扩展 一键安装轻量插件，发现更多特色功能。
打卡区1 文中内有一个小卡片，文章底部有一个小卡片，大家的每次打卡点击都对手机资源馆很重要，希望大家帮忙点一下，退出来就可以了
The day that you see me It is a literary genre that centers on The day that you see me It is a literary genre that centers on The day that you see me It is a literary genre that centers on The day that you see me It is a literary genre that centers on characterization and reflects social life through complete story plots and environmental descriptions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a3ed10506e2df5b72134659e6b6ff2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd6f62cbefa2747bddf86622f65da2e9/" rel="bookmark">
			裸奔浏览器_大概是最好用的隐私浏览器 - Firefox Focus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信很多人都或多或少有些奇奇怪怪的想法,想要去探索 ，却不想与他人分享 .
那么 这款浏览器 就是您 的最佳选择
这款浏览器 iOS端 安卓端 均提供免费下载
界面小清新 不会产生任何浏览记录 想保留也没那个功能
删除网页的按钮在 网页右上角 ，安卓端在网页下面 ，点一下就可以删除整个页面 .较为人性化
而且 在用户滑动网页时 删除按钮会自动隐藏
iOS端 与安卓端 都是一样的
删除网页后 浏览器会自动弹出 输入法 方便用户下一次输入 这个真心很赞
至于隐私方面 互联网 时代 几乎都是裸奔的 设置界面可以把 发送使用统计关闭
other 也没有啥好讲的 条友们体验一下就知道好不好使了 噗 233333333
嗯哼 ... 软件好不好我吹牛也没啥意义 请诸位一览 App Store的评论吧 .
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26b5c0f9929a31f0c9342b338ec08bc5/" rel="bookmark">
			python卸载_详解使用setup.py安装python包和卸载python包的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 我们一般使用 python setup.py install 来安装python包，如果想降级的话，这种情况应如何卸载呢?
手动删除 手动删除安装的文件
假设要卸载paramiko,可以使用如下命令：
1.记录安装后文件的路径
python setup.py install --record files.txt 2.删除这些文件
cat files.txt | xargs rm -rf 这样就删除成功了，删除的时候注意要先看下txt内容。
觉得有用的朋友多帮忙转发哦！后面会分享更多devops和DBA方面的内容，感兴趣的朋友可以关注下~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f322d0bd8d612e3c0e4d0a02823d470/" rel="bookmark">
			用JDBC完成数据操作层的封装，连接MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例需求：
用JDBC完成数据操作层的封装，具体要求如下：
1)封装数据库连接
2)把数据库的增删改查封装成方法
3)完成一个基于自己实现方法的数据库带参数查询实例，要求查询参数不得少于3个，同时返回类型必须为一个具体的对象类型
4)查询所有信息，封装返回具体列表对象
5)自己建立数据库
6)图片信息的直接保存和读取。
根据以上要求，设计一个学生管理系统的数据库操作层StudentDao，系统可以有学生表student。
使用1.完成的StudentDao，完成学生管理系统的增、删、改、查的场景。
设计一个学生选课系统的数据库操作层CourseSelectionDao，系统可以有学生表student、课程表course和成绩表score，可以实现:
1)save(Student s, Course c)； //一个学生选了一门课程
2)save(Student s, Course c, int score)； //学生所选一门课程获得的分数
3)List&lt; Course&gt; select(Student s)； //一个学生所选的所有课程
4)save(List&lt; Student&gt; students, Course c)； //多个学生都选了同一门课程
5)save(Student s, List&lt; Course&gt; courses)； //一个学生选了多门课程
部分运行截图：
项目源码下载： 链接:https://pan.baidu.com/s/1-zbqkx7fEsnM4Nyo11—g
提取码:5to3
复制这段内容后打开百度网盘App，操作更方便哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f36ee25571fb91e2cbe035b6ceb5796/" rel="bookmark">
			汽车穿越沙漠的算法问题（反推法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 一辆吉普车来到1000km宽的沙漠边沿。吉普车的耗油量为1L／km，总装油量为500L。显然，吉普车必须用自身油箱中的油在沙漠中设几个临时 加油点，否则是通不过沙漠的。假设在沙漠边沿有充足的汽油可供使用，那么吉普车应在哪些地方、建多大的临的加油点，才能以最少的油耗穿过这块沙漠?
二.问题分析 1.为使油量消耗最少：每次出发的时候，汽车的装油量必须装满，所以每一个加油点的存油量都是汽车总装油量500L的整数倍，即500k
2.从终点倒推考虑：如果从开始点考虑的话，由于很难确定它的第一个加油点的位置，所以我们从终点出发，因为要使油耗最少，所以最后一个加油站设置的位置在距离终点500km的位置，这样最后一次刚好走完整个沙漠。
图示如下：
第一次： c1 = 500L（指的是c1至少要存储500L） 距B为500KM
现在我们知道了倒数第一个加油点的位置，该加油点必须存储500L的油量(即k的值为1)，要从倒数第二个加油点传送500L油量给倒数第一个加油点，至少要传送两次才行（因为汽车往返要耗油，每次不能直接传500L），假设倒数第二个加油点到倒数第一个加油点的距离为Xkm,传送两次，汽车从倒数第二个加油点传油到倒数第一个加油点需要行走3倍的x距离（即3xkm），车子耗油量也是3x L，由于还要传送500L油，所以倒数第二个加油点的存油至少500+3X L,又由于每一个加油点的存量必须是500的k倍且要保证汽车油耗最少，所以取k=2，即倒数第二个加油点的存油为1000L,所以500+3x=500*2,可以得出X=500/3 km
倒数第二个加油点到倒数第一个加油点的距离为x=500/3 ，图示如下：
第二次：c2 =3 * X+c1= 2 * 500 ==&gt; X = 500/3，距B为 (1+1/3) * 500 KM
现在计算倒数第三个加油点到倒数第二个加油点的距离，跟上面求解步骤一样，假设倒数第三个加油点到倒数第二个加油点的距离为Xkm，要从倒数第三个加油点传送1000L油量给倒数第二个加油点，至少要传三次才行，汽车从倒数第三个加油点传油到倒数第二个加油点需要行走5倍的x距离（即5xkm），车子耗油量也是5x L，由于还要传送1000L油，所以倒数第三个加油点的存油至少1000+5X L，所以k=3，即1000+5x=500*3，所以倒数第三个加油点到倒数第二个加油点的距离为x=500/5 ，倒数第三个加油点到倒数第一个加油点的距离为x=500/5，以此类推
第i次：ci = (2i-1)xi+ Ci-1 = i * 500 ==&gt; x = (Ci-Ci-1) / (2*i - 1)=500 / (2*i - 1);
三. c语言源码 #include &lt;stdio.h&gt; int main() { double dis = 500,oil=500; //油量和距离终点的距离 int k = 1; //初始倍数为1 //因为不确定循环次数，又至少做一次，所以我们用do_while do { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f36ee25571fb91e2cbe035b6ceb5796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fffae91f52937a30bb7eb28b7d13812/" rel="bookmark">
			孙洪涛计算机基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整体框架 计算机基础
基础知识，多媒体，信息安全，互联网
计算机软件及其使用
操作系统，word，excel，c语言程序设计
计算机理论
数据库，网络理论，数据结构，软件工程
第一章 计算机基础
一、计算机的发展、特点和分类（记忆）
二、计算机编码与数制转换（应用）
三、硬件系统的组成与工作原理（理解）
四、软件系统的组成与工作原理（理解）
一、计算机的发展、特点和分类
美国宾夕法尼亚大学于 1946 年研制出世界上第一台电子计算机—— 埃尼阿克 ENIAC
重达30吨，耗电140千瓦，1.8万多个电子管，几乎有两个教室，每秒钟计算5000次
（一）计算机发展的5个阶段
电子管计算机
晶体管计算机
中小规模集成电路计算机
大规模超大规模集成电路计算机
发展中的智能计算机
元件时间结构语言速度存储应用电子管1946CPU机器慢、小数值计算晶体管1958存储高级 数值计算、工业控制中小规模集成电路1964存储、外围设备高级 图像、文字等资料处理大规模超大规模集成电路1971体积小、功能强高级 家用、公办 （二）计算机语言的发展
第一代：机器语言
每条指令用二进制编码，效率很低，难读，难懂，难修改。
第二代：汇编语言
用字符、符号编程，与具体机器指令有关，执行效率较高。
第三代：高级语言
面向用户，每一种语言，都有自己规定的专用符号、语法规则和语句结构
高级语言与自然语言更接近而与硬件功能相分离，彻底脱离了具体的指令系统，便于掌握和使用。如FORTRAN、COBOL、BASIC、PASCAL、C等都属于高级语言。
第四代：面向对象程序设计语言
新一代的程序开发语言，使程序的编写和重用更加容易。
如Visual Basic、Visual C/C++、Delphi、Power Builder
【真题】
能够为计算机直接识别的语言为（A）
A、机器语言
B、汇编语言
C、数据库语言
D、C语言
（三）计算机工作的特点
运算速度快
运算精度高
记忆力强
具有逻辑判断能力
可靠性高
通用性强
（四）计算机的应用领域
1. 科学计算
例如气象资料的及时处理与天气的预报，军事工程的计算等
2. 数据处理
例如银行用据算计管理和处理账务，企业用计算机管理生产、统计报表，商场用计算机进行进、销、存的管理与市场预测等。
3. 计算机辅助技术
目前，广泛应用于机械、建筑、大规模集成电路、电子应用、服装、飞机及汽车等许多行业。
4. 自动控制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fffae91f52937a30bb7eb28b7d13812/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a302718d3100fa2b5cf1f2c11d8bd3c/" rel="bookmark">
			Python读取exce文件报错AttributeError: ‘MergedCell‘ object attribute ‘value‘ is read-only
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python读取exce文件报错AttributeError: ‘MergedCell’ object attribute ‘value’ is read-only。
如果确定不是脚本问题，可能是excel文件的问题，原因是单元格不能合并，（可能是宏影响，建议开启所有宏）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/482f840731b5e2b065faaa4b95172288/" rel="bookmark">
			java 中文编码字符集转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 字符串 getBytes方法
将这个字符串按指定字符集编码成一个字节序列，将结果存储到一个新的字节数组中。 public byte[] getBytes(String charsetName) throws UnsupportedEncodingException { if (charsetName == null) throw new NullPointerException(); return StringCoding.encode(charsetName, value, 0, value.length); } 2 字符串 new String(bytes,charsetName)
将已编码的字符串字节数组解码为对应字符集字符串
public String(byte bytes[], Charset charset) { this(bytes, 0, bytes.length, charset); } 3 例：
3.1 将windows上字符串转为utf-8格式数组进行传输
String str="中文"；
//转成中文按utf-8编码的字节数组 byte[] bytes=str.getBytes("UTF-8");.
3.2 将从windows传过来的字符串转为utf-8格式字符串
String str="中文"；
byte[] bytes=str.getBytes();.
开始转换：
String str_urf8=new String(bytes,"UTF-8);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddaef58412d93c174507bf0ea24edabf/" rel="bookmark">
			什么是项目风险？如何做好项目风险管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		风险管理是项目管理的重要组成部分，它是影响项目是否成功的关键。因此如何做好项目风险管理，是每一个项目经理必须深思熟虑的问题。
什么是项目风险？
项目风险是指不确定的事件或条件可能会发生并对项目结果产生影响。这种影响可以是积极影响，也可以是消极影响。
在任何项目中，风险是难以避免的。项目经理比大多数人更了解如何降低风险，并将其作为项目管理的核心策略。
要了解项目风险可能来自哪里，常常从三重制约的视角开始。当你记录风险时，请记下什么地方可能会对时间、成本和质量产生影响。一旦发现风险，你最好可以和你的团队一起制定策略，以便在风险出现时加以应对。
你也可以将利害关系人纳入进来，因为他们能够识别其他风险，这些风险他们可能会意识到，比如市场条件或其他尚未传达的制约条件。使用在线项目计划工具的风险功能，识别和跟踪风险，这样你就能评估风险对整个计划的影响。
项目风险管理流程
风险始于可能发生的不确定事件或条件。所以，我们要认清这些事件，确定这些事件是否会发生。如果不确定事件发生了，那么它就可能会对项目目标产生积极或消极的影响。举个消极事件的例子，一家企业推出了一个新产品，市场对产品的接受度很高，但企业无法满足需求。这可能听起来不错，因为销售量增加了，产品适应了市场。但企业没有为需求做好准备，那么增加的销售量可能会带来消极的影响。企业也许不能完成订单，他们无法满足需求，他们实际上失去了客户，那些客户可能不会再回头。积极事件可能是，这个产品确实适应了市场。企业能够完成订单，这可能是一件积极的事。
如何确定项目这些不确定事件或条件从何而来？当我们试图为一个项目识别不确定事件或条件时，我们应该看哪里？我们可以从项目计划的几个方面来看。
1、看三重制约条件。例如，查看范围、成本、时间、进度、质量和基线。因为很多时候，这些因素确实会发生变化，三重制约条件中任何一项的变化不仅会相互影响，而且会给项目的其他领域带来风险。
2、看项目管理计划。项目管理计划包含一系列子计划，包括范围管理计划、项目成本管理计划、进度和质量管理计划。这些子计划包括基线、我们为项目记录的内容，以及我们正在查看的内容。我们还可以看看子计划的流程，以及管理子计划的方式。如果没有有效管理子计划的流程，这也会给项目带来风险。
3、看利害关系人登记簿，我们想与利害关系人见面或交谈，看看他们能否识别出其他风险，这些风险他们可能知道，可能发生或可能正在发生。其他需要注意的地方是项目文件，看看能否识别可能招致风险的因素。还要看看环境因素、企业环境因素等等。不同的业务单位或公司内部发生的不同事情可能会带来组织变化，这可能会带来风险。
当我们试图识别风险时，以上是我们可以关注的领域。它能帮助你理解风险，了解风险和问题的区别。
一款好的项目管理工具能帮项目经理从源头开始管控风险，如8MSaaS PM，就可以指导你完成风险管理流程，帮助你跟踪风险管理行动。
8MSaaS PM能自动检测项目各种系统性风险及其影响，包括项目计划，成本，资源以及质量的风险，并且能根据现有影响自动推测最终的影响，项目人员可清楚地知道若不及时恰当地管理这些风险的严重性。
同时，8MSaaS PM支持记录用户自定义风险并跟踪风险从开始到结束的整个过程。系统会自动根据风险发生几率的高低和采取行动前后风险的的影响来分类和评估每个风险，以便项目人员更快速有效地确定行之有效的方案来避免风险。
总体而言，成功的项目风险管理既是一门艺术又是一门科学。一方面，项目风险管理有助于确定项目范围以及最优项目，另一方面，项目风险管理也有助于改进已选项目的效益与效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90ab91e79266970d77b250add2bb7e97/" rel="bookmark">
			解决Mac电脑连接校园网不弹出登陆窗口问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看你的DNS有没有改过，把自己改过的DNS全部删除，变更为默认的就好。 2.有使用梯子的同学，记得把梯子暂时先关闭一下，然后在连接校园网Wi-Fi。 3.你有登录页面的网址吗？没有的话，让同学复制给你，直接在Safari中访问该网址试试。 4.如果，你苹果手机是可以弹出来并且正确显示的话，那么请在你的safari的开发----用户代理----选择iphone。其实就是让你的mac的safari浏览器来模拟苹果手机浏览器。 以上就是我汇总的解决Mac电脑连接校园网不弹出登陆窗口问题的办法了，希望对使用mac电脑的同学有帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b1f7bca0d63076fa8943329ed977a55/" rel="bookmark">
			Android开发学习之路--App全局置灰
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当有个悼念日的时候，很多app和网页都只呈现了黑白色，这里，我们可以简单研究下。
常用方式 App页面置灰常规方案就能想到内置两套UI图，加载不同的UI，但是这样实现起来特别复杂，而且包体积大小也成倍增加，需要请求后台服务端的图片也得搞两套。
其实换个思路，我们把Android渲染的数据统一给他灰度不就可以实现我们所需要的功能嘛，那就得看下Android的UI绘制过程了，关于UI的绘制已经有很多分析了，这里就不赘述了。
原理实现 DecorView 一个Activity由最外层的PhoneWindow，然后往里是DecorView，接着就是Titlebar和Content，其中Content就是我们在Activity中的onCreate的方法中调用的setContentView来设置布局等。
既然要设置全局的app为灰色，那么我们只要设置最顶层的view为灰色，就可以做到全局灰色了，首先想到的肯定是PhoneWindow，但是phoneWindow是一个不可见的类，而由他创建的DecorView才是我们可见的UI布局。DecorView是一个ViewGroup，继承自FragmeLayout，是UI界面的顶级容器，在事件分发中，Key和touch事件也基本上是从DecorView层层向下分发。
Paint Android的UI绘制基本上分为measure，layout和draw，这里我们只需要看draw，他是怎么画的，实例化了Canvas对象，对canvas进行一些属性赋值，最后调用view的draw(canvas)方法去绘制。
这里还需要知道Canvas，Paint和draw是干嘛的，从字面意思其实很好理解，Canvas就像一块画布，决定了你需要在哪里画，Paint就是画笔，可以提供各种各样的样式和色彩，最后你需要拿着画笔到规定的Canvas位置中去draw。
既然决定色彩的是Paint画笔，那么我们是不是可以强制设定画笔的颜色为灰色，不就可以实现我们的需求了，然后我们发现Paint有个方法
setColorFilter(ColorFilter colorfilter); //设置颜色过滤器，可以在绘制颜色时实现不用颜色的变换效果 这里再穿插一下图像的基础知识。一般我们都知道图像是由一个一个像素点组成的，而像素点是通过RGBA(红绿蓝，透明度)来控制的，这个是数字方向的。但是在我们早期的彩色电视机中，我们经常会调整彩电的色调，饱和度和亮度，其中色调就是物体的颜色，饱和度就是颜色的纯度，从0到100%来描述，亮度就是颜色的相对明暗程度。
既然饱和度为0就可以变成灰色，那么我们通过设置ColorMatrix然后给到Paint画笔不就可以了。
最终实现 我们先实现个方法：
public void setViewGray(View view) { Paint paint = new Paint(); ColorMatrix cm = new ColorMatrix(); cm.setSaturation(0f); paint.setColorFilter(new ColorMatrixColorFilter(cm)); view.setLayerType(View.LAYER_TYPE_HARDWARE, paint); } Activity 然后我们可以在Activity的OnCreate方法中设置顶层的DecorView的画笔
setViewGray(getWindow().getDecorView());
然后我们需要的效果就出来了。
自定义dialog 如果Activity中有个按钮点击弹出dialog，此时这个dialog不属于当前Window，而是新建了一个window，相当于走了一遍Activity中创建window的流程，所以此时我们需要在其构造方法中:
View view = LayoutInflater.from(context).inflate(R.layout.xxx, null);// 得到加载view setViewGray(view); Github例子
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c573da4b781c2ce1b0c1e37788bd99/" rel="bookmark">
			Centos7 硬盘分区（新增硬盘）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://www.cnblogs.com/fangzhang/p/11144931.html Centos7 硬盘分区 Centos7 硬盘分区
一、查看磁盘信息
1、首先使用命令 fdisk -l 查看硬盘信息，如下图：
共两块磁盘，分别是，系统盘： /dev/vda 、数据盘： /dev/vdb 二、创建主分区
数据盘分三个区：一个主分区、两个逻辑分区
1、输入 fdisk /dev/vdb 然后回车，如图：
2、输入 n ，回车 新建分区。输入 p 选择分区类型（p-主分区、e-扩展分区）。如图：
3、输入 p 选择分区类型，回车新建主分区。如图：
4、选择分区号在 1-4 间，输入 1 回车：
5、设置分区起始的柱面，直接回车选择默认即可，回车。如图：
6、设置主分区大小，大小采用 +size{K，M，G}方式 直接输入分区大小，如图：
7、主分区已创建完成，大小40G。输入 p 查看分区是否成功，如图：
三、创建扩展分区
1、创建扩展分区，输入 n 回车 新建分区。如图：
2、选择分区类型，选则扩展分区，输入 e ，回车。如图：
3、输入分区号2，回车
4、输入扩展分区2的其实柱面号，这么我们默认就可以，直接回车
5、设置扩展分区大小，此处也是直接回车选择默认，表示将剩余磁盘空间全都划分给扩展分区。如图：
6、扩展分区2已创建，输入 p 查看是否成功：
四、创建逻辑分区
1、输入 n 开始创建逻辑分区
2、输入 l 选择分区类型（注意：这个输入的 英文字符 l）
3、选择逻辑分区的起始柱面号，直接回车
4、输入逻辑分区大小，同主分区设置类似，采用+size{K,M,G}方式，只接输入逻辑分区大小 +30G
5、创建第二个逻辑分区，同第一逻辑分区创建方式相同，输入 n 回车，然后输入 l 回车选择逻辑分区，然后直接回车选择默认起始柱面，最后不设置磁盘大小直接回车
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85c573da4b781c2ce1b0c1e37788bd99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2cdeb6b113b11d7912572956c10d631/" rel="bookmark">
			ros安装时执行sudo rosdep init报错及rosdep update超时的解决方法（2021-04-22更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错如下： sudo rosdep init
ERROR: cannot download default sources list from:
https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list
Website may be down.
解决方法一（2021-04-21尝试此方法，raw.githubusercontent.com对应的IP地址，ping的时候总是超时，使用此方法偶尔会失败，请参考解决方法二）： cd /etc检查etc下有没有ros/rosdep/sources.list.d。如果没有手动创建ros/rosdep/sources.list.d #配置环境的xavier上没有找到ros/rosdep/sources.list.dsudo chmod 777 /etc #给etc文件夹赋予权限手动创建ros/rosdep/sources.list.d #如下图所示： 4.打开网址：https://site.ip138.com ，输入raw.githubusercontent.com 如下图所示：
5.随便选择一个地址，我选择的是151.101.196.133
6.sudo gedit /etc/hosts ，在文档中添加：151.101.196.133 raw.githubusercontent.com 保存后。 如下图所示：
7.执行sudo rosdep init 8.rosdep update
通过上述步骤就可以解决执行sudo rosdep init失败报错的问题
解决方法二（rosdep update超时）： 网站https://ghproxy.com/支持github的资源代理，非常好用，我们将用此代理加速rosdep对Github Raw的访问，进而解决rosdep update超时问题。通过在地址前添加https://ghproxy.com/前缀来应用代理服务。操作如下：
1. cd /usr/lib/python2.7/dist-packages/rosdep2/
sudo gedit sources_list.py311行 url="https://ghproxy.com/"+url 72行 DEFAULT_SOURCES_LIST_URL = 'https://ghproxy.com/https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list' 311行 url="https://ghproxy.com/"+url #添加位置见下图 sudo gedit gbpdistro_support.py
36行 FUERTE_GBPDISTRO_URL = 'https://ghproxy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2cdeb6b113b11d7912572956c10d631/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77e66a6e8610458a80ac85bdec7a218d/" rel="bookmark">
			C语言程序设计——选择分支结构程序设计——学会使用条件运算符的嵌套（习题4.6）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下：
#include&lt;stdio.h&gt; #include&lt;math.h&gt; main() { int score; printf("请输入你的分数："); scanf("%d",&amp;score); printf("你的成绩为%c\n",score&gt;=90&amp;&amp;score&lt;=100?'A':(score&gt;=70?'B':(score&gt;=60)?'C':'D')); return 0; } 运行结果如下：
分析：学会条件运算符的嵌套用法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/501605273d2aa5ba3e21945bb6f97f5e/" rel="bookmark">
			使用tcp_nodelay需要引用什么头文件_宋宝华： Linux内核编程广泛使用的前向声明(Forward Declaration)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文系转载，著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
作者：宋宝华
来源： 微信公众号linux阅码场(id: linuxdev)
前向声明 编程定律 先强调一点：在一切可能的场景，尽可能地使用前向声明(Forward Declaration)。这符合信息隐蔽的原则。
一个例子 regmap 那么前向声明究竟是个什么鬼？在内核写代码和看代码的童鞋，经常发现Linux内核里面充斥着这样的代码，比如
include/vim linux/regulator/driver.h
文件中：
我们以regmap这个结构体为例，这个地方就是一个前向声明，告诉后面的代码regmap是个结构体，至于这个结构体里面有什么鬼，不知道！
Linux可以说满世界都在使用这个结构体。满世界都在使用声明在include/linux/regmap.h中的regmapwrite()、regmapread()这样的API，可以说无处不在，无处不用，比如drivers/rtc/rtc-at91sam9.c中的：
这样的东西大家随便一搜索，都可以搜索出来无数个。这样看起来，regmap这个结构体，应该是一个跨模块的API，它的整个结构体长成怎么样，应该是出现在一个include/linux/级别的顶级跨模块头文件中了，这样方便跨模块引用这个结构体。
但是，真实的情况却让你大跌眼镜，regmap结构体的具体成员长什么样子，没有出现在任何一个外部级别的头文件里面，而是完全internal的(内部的、内部的、内部的，各位童鞋！！！)：
drivers/base/regmap/internal.h
既然它出现在drivers/base/regmap/internal.h，那么想必除了drivers/base/regmap/本身的内部实现外，外部不可能引用drivers/base/regmap/internal.h这个头文件。
所以，我们得出一个结论，尽管Linux满世界都在使用struct regmap，但是除了drivers/base/regmap/内部以外，其实外部没有任何一个人知道regmap这个结构体长成什么样子！！
这是一种极其良好的“高内聚、低耦合”设计。因为，drivers/base/regmap/外部所有的人，其实都只是在拥有regmap这个结构体的指针，而并没有访问regmap结构体其中的任何一个成员，其实也只有drivers/base/regmap/的内部实现在访问而已。
比如,regmap_write实现于：drivers/base/regmap/regmap.c文件，它的代码如下：
这样做带来的一个极大好处是，drivers/base/regmap/外部的世界根本不需要知道regmap结构体长成什么样子，因为没人需要知道，它们都只是在访问regmap的指针！
而drivers/base/regmap/内部无论怎么修改regmap结构体的实现和成员本身，对外部的世界根本不可见，修改regmap结构体后，drivers/base/regmap/以外的模块都不需要重新编译!
相反，如果我们直接把regmap结构体的内部细节暴露在include/linux/regmap.h这个头文件中，那么由于这个头文件满世界都被引用，你只要修改regmap结构体本身，就会导致内核无数模块的增量编译!
include/linux/regmap.h中暴露了regmap_config结构体，这说明这个结构体的内容需要被regmap以外的模块知道：
...
为什么，它涉及到具体的寄存器是如何读写的callback以及具体的寄存器pattern，这肯定是一个API基本的东西，本身就应该是跨模块的东西,所以它的长相出现在了include/linux/regmap.h这个顶级头文件中。
对于一个外部模块而言，它只需要能够通过regmap.h公开暴露的小部分寄存器配置接口，来通过类似regmapinitmmio()这个的API来填充regmap结构体的内部实现。比如drivers/rtc/rtc-at91sam9.c中的：
上述代码中，rtc-&gt;gpbr是一个struct regmap指针，regmapinitmmio()在内部填充了regmap的本身实现。之后drivers/rtc/rtc-at91sam9.c再调用regmapwrite()、regmapread()的时候，这些API从regmap模块内部调用我们填充进去的regbits、valbits、reg_stride这些寄存器pattern，帮忙完成寄存器的最终读写。
画一幅图 理清关系 永远用高内聚和低耦合的思想设计代码。Linux内核2000万行的代码，不这么设计肯定要崩盘。写代码不是得过且过。尤其做单片机写裸奔程序的童鞋要特别注意，你们往往觉得玩Linux的童鞋代码一层层套很傻逼，这是完全不正确的理解。
天天要带娃，鸡飞狗跳，没时间写，我随便用碎片时间胡说八道的，不知道各位看官有什么感想？欢迎板砖，也欢迎打赏。
更多精彩更新中……欢迎关注微信公众号：linux阅码场(id: linuxdev)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e73985fbdc2c8fda5a9edc35409e6bb/" rel="bookmark">
			union all会影响性能吗_越简单的词汇会越难，all的多种用法你都会吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语法很难？很枯燥？很多人对语法望而却步，其实是你不知道方法！今天，我们换种方式，不需要死记硬背，轻轻松松学语法。我们先来看下面的题目，你能选对吗？
今天艾伦英语部落给大家带来的这个选择题，主要考察大家对几个介词和all搭配出来的词组的了解程度。你知道它们分别的含义吗？正确答案又是谁呢？
我们都知道all的意思是“全部”，但是当它和不同的介词组合在一起的时候，表示的意思就完全不一样了！
比如第一个选项above all，意思是首先，这是一个表示顺序的词组，一般用于表示事物在排列上的第一位，强调接下来要讲的这件事情非常的重要，可以翻译为“最重要的是”，来看这个例句：
句子中above all用在了句首，这里是状语用法，后面需要用逗号和主要句子隔开。
接着来看，第二个选项in all，用于表示“总共，合计”，比如说我们去商场买东西，最后去收银台结账的时候，收银员会告诉我们所有购买的东西的“共计”多少钱。这个时候我们就可以用in all来表达。比如说“我总共花了1000元”，可以用英语这样表达：
这里拓展一个容易和它混淆的固定搭配all in all，它比in all多了一个all，意思也完全不同，译为“总而言之”。稍微记一下就行~
第三个选项at all则与“全部”没有任何关系，它的意思是“根本”，值得注意的是，这个固定搭配一般用于否定句和疑问句，在肯定句中非常少见，顶多是用在条件状语从句中，来加强if的语气，表示“即使”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46cdb5c57fda5ee88a149648fdcd7441/" rel="bookmark">
			qemu-user-static：利用x86机器编译支持arm架构的docker镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近在项目中需要编译arm架构的某驱动docker镜像，但是手头上没有现成的arm架构的机器环境，于是在网上搜索了下如何在x86机器模拟arm环境来进行编译。我找到了一款神器：multiarch/qemu-user-static
简介 项目地址：https://github.com/multiarch/qemu-user-static
qemu-user-static是一个用于利用当前操作系统来运行其它架构的一个仿真器，这个github项目可以通过x86的机器编译出其它各个架构的docker镜像。
支持的指令集架构：
armv7lppc64les390xaarch64armv7lppc64le。。。 arm环境搭建 这里我手头上的机器为x86_64，ubuntu系统
1. 安装docker环境 参考docker环境搭建
2. 安装qemu相关 #更新apt源 apt-get update #安装qemu apt-get install qemu #下载qemu-aarch64-static wget https://github.com/multiarch/qemu-user-static/releases/download/v5.1.0-5/qemu-aarch64-static.tar.gz #解压 tar xzvf qemu-aarch64-static.tar.gz #配置可执行文件路径 sudo cp qemu-aarch64-static /usr/bin/ chmod +x /usr/bin/qemu-aarch64-static 3.注册qemu-user-static虚拟机 #注册qemu-user-static虚拟机 docker run --rm --privileged multiarch/qemu-user-static:register --reset #查看运行的docker容器 docker ps -a |grep arm 看到如下图即注册成功。
构建docker镜像 编译二进制 我们写一个helloworld的C程序，然后使用docker编译一个支持arm架构体系的镜像，hello.c：
#include&lt;stdio.h&gt; int main() { printf("hello world\n"); return 0; } 生成二进制文件
gcc hello.c -o hello
制作Dockfile 这里我们要构建aarch64的docker，使用基础镜像： multiarch/alpine:aarch64-edge
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46cdb5c57fda5ee88a149648fdcd7441/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/345/">«</a>
	<span class="pagination__item pagination__item--current">346/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/347/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>