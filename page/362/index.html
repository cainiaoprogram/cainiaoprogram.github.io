<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4ac7832bdead1d306c579ea29b5965c/" rel="bookmark">
			Python pandas库  常用方法使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas库专为数据分析而设计，它是使Python成为强大而高效的数据分析环境的重要因素。
一、Pandas数据结构
1、import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
2、S1=pd.Series([‘a’,’b’,’c’]) series是一组数据与一组索引（行索引）组成的数据结构
3、S1=pd.Series([‘a’,’b’,’c’],index=(1,3,4)) 指定索引
4、S1=pd.Series({1:‘a’,2:’b’,3:’c’}) 用字典形式指定索引
5、S1.index() 返回索引
6、S1.values() 返回值
7、Df=pd.DataFrame([‘a’,’b’,’c’]) dataframe是一组数据与两组索引（行列索引）组成的数据结构
8、Df=pd.DataFrame([[a,A],[b,B],[c,C]],columns=[‘小写’,’大写’]，index=[‘一’,’二’,’三’])
Columms 为列索引，index为行索引
9、pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider 清华镜像
10、data={‘小写’:[‘a’,’b’,’c’],’大写’:[‘A’,’B’,’C’]} 传入字典
Df=Pd.DataFrame(data)
11、Df.index() df.columns()
二、读取数据
12、df=pd.read_excel(r’C:\\user\...xlsx’,sheet_name=’sheet1’) 或
Pd.read_excel(r’C:\\user\...xlsx’,sheet_name=0) 读取excel表
13、Pd.read_excel(r’C:\\user\...xlsx’,index_col=0,header=0)
index_col指定行索引，header指定列索引
14、pd.read_excel(r’C:\\user\...xlsx’,usecols=[0,1]) 导入指定列,不能有index_col和header
15、pd.read_tablel(r’C:\\user\...txt’，sep=’ ’) 导入txt文件,sep指定分隔符是什么
16、df.head(2) 展示前两行，默认展示前5行
17、df.shape 显示数据几行几列，不包含行和列索引
18、http://df.info() 可查看表中数据的类型
19、df.describe() 可获得表中数值类型指端的分布值（和、平均值、方差等）
三、数据预处理
20、http://df.info() 可显示表中哪个数据为空
21、df.isnull() 方法可以判断哪个值是缺失值，如果缺失返回True，否则为False
22、df.dropna() 默认删除含缺失值的行
23、df.dropna(how=’all’) 删除全为空值的行，不全为空值的行不会删除
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4ac7832bdead1d306c579ea29b5965c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/490a6489f9694c73caf9a9c46dc89518/" rel="bookmark">
			Win10&#43;Anaconda&#43;CUDA11.0&#43;cuDNN8.0.1&#43;RTX2060深度学习_pytorch环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近换了电脑，需要在新电脑上配置pytorch环境。以前的电脑上配置过，这次再配置顺便记录下来，供以后参考。。。
————————————————————————
首先去NVIDA官网下载CUDA：
https://developer.nvidia.com/cuda-toolkit-archive
这里我下载的是现在最新的V11.0版本
安装好后再在NVIDA官网上下载cuDNN，下载这个的时候需要注册。不需要翻墙也可以注册：
https://developer.nvidia.com/rdp/cudnn-download
这里我下载的是V8.0.1版本
一般来说下载的时候官网会根据做出的系统选项来推荐合适的CUDA以及cuDNN版本。
当然自己也可以根据本身电脑需求合理选择下载。
-----
安装CUDA：
安装时选择：自定义安装-》只选择第一个-》一直到最后安装完成即可。
这里可以参考：https://blog.csdn.net/shuiyixin/article/details/99935799
而cuDNN就是一些文件，将其中的文件复制到CUDA安装路径相应的目录下即可。不用担心会产生替换的问题。
最后，在DOS里面使用：
nvcc --version 来检验CUDA安装是否成功。
-----
安装好CUDA后就可以安装pytorch了。
Note：一定要先安装好CUDA在安装pytorch，不然在使用torch.is_vailable()测试时会产生“false"的结果，无法使用GPU
-----
安装pytorch：
可以参考：
https://blog.csdn.net/zzq060143/article/details/88042075?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase
一般在国内安装pytorch都需要换源，一般换成清华的源。这些事项上面的参考都提到，我只是个搬运工23333。
----
最后，安装好后使用：
import torch #不报错即安装没问题
torch.is_avliable() #返回true则说明可以使用GPU。
------------
明天再安装tensorflow。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55c9fb486887a1ad6e6735022f1c2c56/" rel="bookmark">
			如何查看mysql的版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Dos命令
mysql --version
2.Dos命令
mysql -V
3.sql命令
select version();
4.sql命令
status;
5.sql命令
show variables like ‘%version%’;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b8d373eb8057746483fad4404bb5b2c/" rel="bookmark">
			css左边是图片右边是文字方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用左右浮动即可完成，当然还有其他方法，这里就不说了
&lt;div id="container"&gt; &lt;div id="photo"&gt;&lt;img src="图片地址" /&gt;&lt;/div&gt; &lt;div id="content"&gt; &lt;div id="text"&gt;文字介绍&lt;/div&gt; &lt;div id="news"&gt;新闻内容&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS：
#container {width: 100%;} #photo {float: left; width: 40%;} #content {float: right; width: 60%;} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/853ea16fe523b8827230d2f4b18370fd/" rel="bookmark">
			flowable 任务监听器设置办理人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 创建任务监听器实现TaskListener 接口，实现notify 方法
在任务监听器的notify方法中使用 taskService.setAssignee(String taskId, String assignee) 来设置该任务办理人
注意：在notify方法中不要使用 `delegateTask.setAssignee(String assignee)` 来设置，因为历史表中的 assignee 还是 null package top.theonly.workflow.listener; import org.flowable.engine.TaskService; import org.flowable.engine.delegate.TaskListener; import org.flowable.task.service.delegate.DelegateTask; @Component public class ApplyTaskListener implements TaskListener { @Autowired private TaskService taskService; @Override public void notify(DelegateTask delegateTask) { String assignee = (String) delegateTask.getVariable("assignee "); // delegateTask.setAssignee(assignee); // 历史表中的assignee还是为null taskService.setAssignee(delegateTask.getId(), startUserId); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b22bb9d602aa5d0c60b4ad26408a4d1/" rel="bookmark">
			C#文本框中KeyPress事件触发回车事件调用相关函数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1、按键的事件1.1、执行先后顺序：1.2、按键相关操作：1.3、keydown事件 2、KeyPress来监听ENTER的使用 1、按键的事件 1.1、执行先后顺序： keydown–&gt;keypress–&gt;keyup
1.2、按键相关操作： 1）keydown和keyup参数类型KeyEventArgs（提供了KeyCode）实现形式：e.KeyCode==Keys.A。
keypress参数类型KeyPressEventArgs（提供了KeyChar）实现形式：e.KeyChar==‘A’
2）keyup事件会回传到上一层。e.g. 点击Enter，Textbox执行完keyup后，窗体同样可以捕获到enter。
3）keypress和keydown则会阻止外传。
1.3、keydown事件 private void button1_KeyDown(object sender, KeyEventArgs e) { if (e.KeyCode == Keys.Enter) { MessageBox.Show("sad"); } } 2、KeyPress来监听ENTER的使用 //注册事件，监听键盘输入的某个特殊字符。 this.tb_QRCode.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.tbQRCode_Press); 实现注册事件里面的函数 tbQRCode_Press private void tbQRCode_Press(object sender, KeyPressEventArgs e) { if(e.KeyChar == '\r')//判断是否是回车。 { this.button1_Click(sender, e);//按钮点击事件函数 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9685afb9021d888fbcc5ca1c4285af40/" rel="bookmark">
			8.1、网络地址转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 8.1、网络地址转换 前言 随着Internet的发展和网络应用的增多，IPv4地址枯竭已经成为制约网络发展的瓶颈。尽快IPv6可以从根本上解决IPv4地址空间不足的问题，但目前众多的网络设备和网络应用仍是基于IPv4的，因此在IPv6广泛应用之前，一些过渡技术的使用是解决这个问题的主要技术手段。网络地址转换技术NAT（Network Address Translation）主要用于实现位于内部网络的主机访问外部网络的功能。当局域网内的主机需要访问外部网络时，通过NAT技术可以将其私网地址转换为公网地址，并且多个私网用户可以共用一个公网地址，这样既可保证网络互通，又节省了公网地址NAT应用场景 企业或家庭所使用的的网络为私有网络，使用的是私有地址；运营商维护的网络为公共网络，使用的是公有地址。私有地址不能在公网中路由NAT一般部署在连接内网和外网的网关设备上静态NAT 静态NAT实现了私有地址和公有地址的一对一映射一个公网IP只会分配给唯一且固定的内网主机静态NAT数据访问步骤 主机A→主机C 主机A想要访问位于公网的100.1.1.1/24的地址主机A发送报文 源地址：192.168.1.1目的地址：100.1.1.1由于192.168.1.1是一个私网地址，是不能访问公网的。私网地址不能在公网中进行路由RTA收到主机A的数据包，RTA对私有地址和公有地址进行一对一的映射，并且在RTA中形成一个映射表。 原地址：192.168.1.1映射地址：200.10.10.1RTA通过映射表将私有地址映射成公网地址，然后进行路由到达主机C主机C→主机A 主机C的数据包到达RTA时，也通过映射将公网地址转换成私网地址，然后去访问主机A动态NAT 动态NAT基于地址池来实现私有地址和公有地址的转换动态NAT转换步骤 动态NAT会在RTA上，在NAT服务器上配置一个地址池当内网主机去访问外网主机时，网关RTA会从公网地址池中选择一个没有使用的公网地址，与收到的数据包完成映射地址池 地址池选择地址的方式是随机的，只要是未使用的，空闲状态下的地址即可当对应的地址不需要此链接时，对应的地址映射就会被删除，公网地址就会回到地址池中待定当地址池中的地址用尽以后，我们只能去进行等待，等待公有的地址被释放以后，才能再次使用该地址去访问公网NAPT 网络地址端口转换NAPT允许多个内部地址映射到同一个公有地址的不同端口 主要通过端口进行区分访问步骤 内网主机向外网主机发送一个报文 源IP地址：192.16.1.1：1025目的IP地址：200.10.10.1：2843RTA收到数据包以后，通过内网地址池选择一个空闲的公网地址加端口号来建立表项，然后即可访问外网地址外网地址访问内网地址时，通过RTA中的NAT列表重新将公网地址映射成私网地址，然后发送给主机AEasy IP Easy IP允许将多个内部地址映射到网关出接口地址上的不同端口Easy IP主要是适用于小规模的局域网当中NAPT和EasyIP 因为NAPT是通过设置地址池Easy IP是通过向公网申请获取一个临时的公网地址，然后进行分配访问步骤 内网地址想要访问外网地址 报文 源IP地址：192.168.1.1：1025目的IP地址：100.1.1.1：80RTA收到数据包后，会建立一个Easy IP的表项，表项中源IP地址和端口号和出接口的公网IP地址形成映射，然后将报文的源IP地址和端口号转换成出接口的源IP地址和端口号。RTA将映射后的报文转发到公网上公网地址访问内网地址时，路由器收到回复报文也会查找Easy IP表项，路由表通过该表项将报文的目的地址和端口号转换成私网的源地址和端口号NAT服务器 通过配置NAT服务器，可以使外网用户访问内网服务器使用NAT技术时，内网用户是可以访问公网用户的。但是默认屏蔽了公网用户不能访问内网用户的需求 公网访问内网也是我们的一种需求，而NAT服务器可以实现这个需求。 实际过程中，上网时我们可以访问运营商，运营商其实也可以访问我们。如果不能访问我们，我们就无法进行下载数据但是我们需要将配置服务器的私网IP地址和端口号，转换成公网IP地址发布出去访问步骤 外网主机想要访问私网服务器，发送一个数据包 目的IP地址：200.10.10.1：80源IP地址：100.1.1.1：2844RTA收到此报文会查找地址转换表项，然后将目的地址进行转换 因为我们已经配置好私网IP地址转换为公网IP地址。回复报文时直接转换即可RTA转换完成后将数据转发到服务器上静态NAT配置 1、进入接口，配置地址。保证底层的连通性2、进入串口配置地址 1、配置IP地址2、手动配置外部公网地址和内部地址的映射表配置验证 可以看到公网地址和私网地址分别的映射关系动态NAT配置 配置步骤 1、首先配置一个NAT组 NAT组的名字是1地址池是200.10.10.1~200.10.10.2002、配置一个ACL 允许通过的地址是192.168.1.0网段3、进入RTA外部接口配置NAT 只要是被ACL匹配的网段的IP地址都会被映射成地址池的地址，然后转发出去配置验证 可以查看到地址池和ACL匹配的规则Easy IP配置 Easy IP也是通过ACL匹配来进行的配置步骤 1、创建一个ACL 规则是可以匹配到192.168.1.0网段2、RTA的外部接口配置NAT 只要是符合ACL允许的网段的就可以进行地址转换配置验证 可以查看到匹配规则和地址池 NAT服务器配置 配置步骤 1、RTA内部接口和外部接口配置IP地址2、手动指定NAT服务器协议 TCP的公网地址和私网地址的映射关系配置完成后外部用户就可以通过公网地址和端口来访问内部服务器配置验证 可以查看到公网和私网IP地址的映射关系本章总结 那种NAT转换允许服务器既能被内部访问又能被外部访问? 通过内部访问外部，我们现在学习的方法都可以通过外部访问内部 配置NAT服务器NAPT有什么功能和特点？ NAPT主要是基于端口的转换，允许多个内部地址映射到同一个公有地址不同端口上 实际上不是基于IP地址的转换，是基于端口的转换 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11143eb995c37fed62c8a0e88921c9ba/" rel="bookmark">
			销售需求丨购物篮分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
BOSS：那个谁，对，就是你，你给我研究研究咱商场物品摆放是否合理？！
白茶：（Excuse me？）…BOSS，那个我就是个码字的！
BOSS：加钱！给我做个高大上的购物篮分析！
白茶：（支付宝到账####元！）好嘞！
在实际业务中，商场物品的摆放是否对营销有所影响？所策划的营销活动是否真正的起到了促销价值？活动赠品的使用效果如何？购物篮分析是啥？
这些问题，其核心点都是一个问题——关联度问题。
说的通俗易懂点，就是数学概念中我们学过的交集概念的实际用法。
模拟数据：
这是基本的案例数据，导入到PowerBI中，并且添加一个日期表，其模型关系图如下：
但是问题也来了，我们想要做关联度分析，那么就需要有一个可以切换的维度，白茶在上面就已经提过，核心概念是交集。
编写如下代码：
关联度产品表 = VALUES ( '产品表' ) 复制一份产品表作为可以切换的维度，并且模型关系如下：
注意红框的位置，要做到有关系，但是关系并未激活的状态。
解释一下：
有关系是为了后面的DAX做准备，方便函数生效；
未激活是因为激活状态下，和原有的产品表效果是一样的，无法达到筛选对比的效果。
添加切片器、表格，搭建最基本的显示环境：
这是基本的筛选环境和上下文环境，DAX的编写都要在这两个环境中进行。
先对客户购买人次进行统计：
购买人次 = COUNTROWS ( VALUES ( '销售明细'[客户流水号] ) ) 结果如下：
但是数据好像不对劲。
原始数据中[腰带]的行数是1746行，但是我们写的DAX出来的结果是1613行，很明显这个数据对不上啊！咋办？优化代码如下：
A类购买人次 = SUMX ( '销售明细', CALCULATE ( COUNTROWS ( VALUES ( '销售明细'[客户流水号] ) ) ) ) 放在表中进行对比：
很明显这次代码是没问题的。
因为当前上下文环境与行上下文环境不同，造成了COUNTROWS函数上下文转换的问题，因此结果是不准确的；可以通过SUMX函数迭代整个表搭配CALCULATE函数进行上下文转换进行解决。
那么当我们筛选产品B的时候，同时购买AB的客户数量有多少呢？
编写如下代码：
同时购买A和B的客户数 = VAR BC = CALCULATETABLE ( VALUES ( '销售明细'[客户流水号] ), USERELATIONSHIP ( '关联度产品表'[商品名称], '销售明细'[商品名称] ), ALL ( '产品表' ) ) RETURN SUMX ( '产品表', IF ( CALCULATE ( [A类购买人次], Bc ) = [A类购买人次], BLANK (), CALCULATE ( [A类购买人次], Bc ) ) ) 结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11143eb995c37fed62c8a0e88921c9ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7016bfe88ac13beb58a0fd3089f5f270/" rel="bookmark">
			解密TLS协议全记录之Openssl的使用与Nginx Server的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 Openssl是TLS协议进行报文加密，安全通讯而用到的开源代码包，代码主要由C语言编写，我个人也只看了其中一部分代码，当作工具使用，没有深入分析。
其维基百科的链接:https://zh.wikipedia.org/zh-cn/OpenSSL，
openssl的官网wiki链接：https://wiki.openssl.org/index.php/Enc#Cipher_alogorithmsNginx是一款面向性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。与旧版本（≤ 2.2）的Apache不同，Nginx不采用每客户机一线程的设计模型，而是充分使用异步逻辑从而削减了上下文调度开销，所以并发服务能力更强，其中也有利用到openssl的代码进行安全通讯。 安装与使用 需要注意的是，接下来的编译，安装都将支持TLS1.3协议，由于TLS1.3目前还未完全成熟，因此需要我们进行额外的编译操作来使系统支持。
1. openssl 1.1 openssl 编译与安装 1.1.1 编译安装openssl 1.1.1版本, 来支持TLS1.3协议。 openssl的源码链接：https://www.openssl.org/source/, 选择 Openssl 1.1.1版本，目前这个版本支持最新的TLS1.3协议草案。
编译安装指令： #查看openssl的版本信息 pi@raspberrypi:~ $ openssl version OpenSSL 1.0.1t 3 May 2016 # 卸载系统自带的openssl，避免链接冲突问题。 sudo apt-get remove openssl wget https://www.openssl.org/source/openssl-1.1.1g.tar.gz tar -xf openssl-1.1.1g.tar.gz cd openssl-1.1.1g ./Configure # 在需要确定编译器环境的时候，请执行./config, 参阅Q&amp;A make make install 查看openssl的最新版本信息, 查看openssl支持的加密套件，并确定是否支持 TLS1.3协议
pi@raspberrypi:/usr/local $ openssl version OpenSSL 1.1.1g 21 Apr 2020 pi@raspberrypi:/usr/local $ openssl ciphers -V 0x13,0x02 - TLS_AES_256_GCM_SHA384 TLSv1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7016bfe88ac13beb58a0fd3089f5f270/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2f9862877aa1c5d8b130246f3b9a9fe/" rel="bookmark">
			MobaXterm不能上传下载文件的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/middle_rookie/article/details/97889372 使用 root 用户名， root密码就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473d538815f78cc7bfc39d6cf1a458b3/" rel="bookmark">
			go import几种用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 导入多个依赖包2. 相对路径导包3. 绝对路径导包4. 点操作5. 别名操作6. _空引入 操作7. 导入自定义的包 1. 导入多个依赖包 import(
“fmt”
“os”
)
2. 相对路径导包 导入当前文件目录下的 其他 model
Import "./model" 3. 绝对路径导包 加载 $GOPATH/src/shorturl/model 模块
Import "shorturl/model" 4. 点操作 直接导入 model 下的所有函数以及变量 然后 fmt.Print() 可以简写成
Print() import( . "fmt" ) 5. 别名操作 给model 起一个别名 然后可以按照 fmt.Print() 可以简写为 f1.Print()
import( f1 "fmt" ) 6. _空引入 操作 不引入包中的任何变量以及函数，
只是为了执行，model 中的 init 函数
7. 导入自定义的包 新建 mymodel
cd mymodel go mod init kiki/mymodel 新建模块文件夹 dir1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/473d538815f78cc7bfc39d6cf1a458b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f3880b62602619be8278ff09f3a1642/" rel="bookmark">
			拉钩教育java学习课程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要内容是补充自己的知识漏洞 知识来自拉勾教育Java高薪训练营 1.二进制位数转换：
正10转正2：
辗转除2并逆向取余数
正2转10：
2的幂对应相加
负10转2：
首先10进制绝对值按照上文方法转为2进制
随后按位取反
最后加一
负2转10：
把负10转2的顺序全都反过来
先减去1
再按位取反
最后按照原方法
异或：相同为0，不同为1
字符串比较是否一致使用 .equals(str)
flag=!flag转换boolean状态
String类型.split方法会返回多个字符串，要用数组接收
str转int
int year =Integer.parseInt(input_strs[0]); 主函数中直接return可以中断程序运行
if (month &lt;= 0 || month &gt;12 || day&lt;=0 || day&gt; dayofmonth[month-1]) { System.out.println("输入不合法"); return ; } 8.构造子类时执行顺序
父类静态-&gt;子类静态（类层级）
父类构造方法-&gt;父类构造代码块
子类构造方法-&gt;自尅构造代码块
9.访问控制符
10.多肽的实际意义
多肽实际是为了能用一个方法接收父类的指针，而打印不同子类的重写的方法。因为子类重写方法非常繁多，为了统一管理所以使用了多肽。
11.抽象类为了多肽而存在
（1）作为方法体传入参数
（2）直接用抽象类定义子类，调用方法更纯粹
12.接口只能继承接口，不能继承类
13.
可以在接口中定义静态方法，调用时直接使用接口.方法名使用
15.内部类调用外部类中的同名变量
16.创建内部类的方法
静态上下文不能访问非静态，因为可能还没创建对象
17.类对象一样可以强转，当需要使用某个特定方法时，强转为目标对象类型
18.==运算符用来判断在栈区内存放的数据是否相等，如果是引用类型则判断是否是相同的引用
19.重写的方法只是重写方法的一部分
当重写了Student类中的hashCode后，String类的hashCode依然可以按照原来的方法使用
19.自动装箱拆箱机制
首先直接传入3.1415926转为对象类型的Double
然后将对象类型的Double转换为变量类型的double
在这之中不需要任何方法，只需直接=即可
20.字符串转double
直接的强制类型转换无法完成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f3880b62602619be8278ff09f3a1642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0808c35eeeaef7bf8cdcc4fbe03edd38/" rel="bookmark">
			bootstrop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bootstrap 视口 视口的概念 1.在PC端没有视口的概念，只有窗口。
2.是html页面外面的一个容器我们会把所有的内容都放进视口里面，然后在对视口进行缩放
3.默认视口的宽度是980px 因为早期PC端网页的版心的980px
4.视口宽度为980px对于移动端来说会出现缩小后文字很小的情况 所以后来提供了双击放大的功能，但是需要左右滑动，用户体验很差，所以我们需要设置移动端的视口不发生缩放
meta标签 meta标签是对网页进行配置
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; ​ a.name指的是我们需要配置的东西的名字,viewport 指的是配置视口
​ b.content 指的是需要配置的内容里面,设置多个属性时使用逗号隔开
​ width 指的是设置视口的宽度 默认是980 这里设置的device -width指的是和我们的手机屏幕一样宽
​ initial-scale 初始化缩放1.0 指的就是不进行缩放
​ user-scalable 指的是用户是否可以进行缩放no表示不允许 yes表示允许
​ maximum-scale 设置移动端页面最大的放大倍数1.0 表示不能放大
​ minimum-scale 设置移动端也买的呢最小放大倍数 1.0表示不能缩小
&lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; //上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ 引入bootstrap 引入bootstrap.css 引入bootstrap的css文件
&lt;link href="bootstrap/css/bootstrap.min.css" rel="stylesheet"&gt; 引入bootstrap.js 1.boots trap框架是依赖于jQuery的 所以在引入bootstrap.js之前一定定要先引入 jQuery
2.引入bootstrap.min.js是加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0808c35eeeaef7bf8cdcc4fbe03edd38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a34a87a9effb280d2910fec7eca53ef5/" rel="bookmark">
			5 计算机组成原理第四章  指令系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 指令格式1.1 指令定义1.2 指令格式1.3 指令格式-地址码1.4 指令格式-操作码1.5 操作码分类1.6 操作类型 2 数据存放指令寻址2.1 数据存放方式2.2 指令寻址2.3 操作数类型2.4 数据寻址2.4.1立即寻址2.4.2 直接寻址2.4.3 间接寻址2.4.4 寄存器寻址2.4.5 寄存器间接寻址2.4.6 隐含寻址 2.5 数据寻址-2偏移寻址2.5.1 基址寻址2.5.2 变址寻址2.5.3 相对寻址2.5.4 相对寻址举例2.5.5 寻址方式小结2.5.6 堆栈寻址 2.6 CISC和RISC2.7 指令系统小结 1 指令格式 1.1 指令定义 指令（又称机器指令）：
是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。
一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。
注：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。
1.2 指令格式 一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。
一条指令通常要包括操作码字段和地址码字段两部分：
1.3 指令格式-地址码 指令含义：（A1）OP（A2）→A3，A4=下一条将要执行指令的地址
设指令字长为32位，操作码占8位，4个地址码字段各占6位
设存储字长为32位，即 4B
Ai 可直接表示 26=64 个不同的位置一条指令的执行（假设每个地址都是主存地址）： 取指令访存1次（假设指令字长=存储字长）
取两个操作数访存2次
存回结果访存1次
总计共访存4次
设指令字长及存储字长均为32位，操作码占8位
指令含义：（A1）OP（A2）→A3，A4=下一条将要执行指令的地址
4个地址码字段各占6位，指令操作数直接寻址范围为 26=64；
完成一条指令需要访存4次
指令含义：（A1）OP（A2）→A3
3个地址码字段各占8位，指令操作数直接寻址范围为 28=256；
完成一条指令需要访存4次
指令含义：（A1）OP（A2）→A1
2个地址码字段各占12位，指令操作数直接寻址范围为 212=4K；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a34a87a9effb280d2910fec7eca53ef5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c02e9a633c94d8b403b2996e80725b5f/" rel="bookmark">
			vue 表单验证由异步变更为同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写前端项目时vue表单验证突然变成异步了，导致如果获取校验函数的返回值，应该是升级iview组件导致的，这里记录一下改为同步的一种写法
实现功能：表单中进行规则设置，当触发提交或者流程中的下一页时触发这些规则校验
表单
&lt;Form ref="businessInfo" :model="businessInfo" :rules="businessInfoRule" :label-width="120"&gt; &lt;Row&gt; &lt;Col span="8"&gt; &lt;Col span="22"&gt; &lt;FormItem label="业务信息：" prop="objectInfo"&gt; &lt;!-- {{sendData.busnissMsg}} --&gt; &lt;Input v-model="businessInfo.objectInfo" placeholder="具体使用集群的业务名称"&gt;&lt;/Input&gt; &lt;/FormItem&gt; &lt;/Col&gt; &lt;/Col&gt; &lt;Col span="8"&gt; &lt;Col span="22"&gt; &lt;FormItem label="OP：" prop="op"&gt; &lt;Input v-model="businessInfo.op" placeholder="产品线OP"&gt;&lt;/Input&gt; &lt;/FormItem&gt; &lt;/Col&gt; &lt;/Col&gt; &lt;Col span="8"&gt; &lt;Col span="22"&gt; &lt;FormItem label="项目邮件组：" prop="mailGroup"&gt; &lt;Input v-model="businessInfo.mailGroup" placeholder="邮箱地址"&gt;&lt;/Input&gt; &lt;/FormItem&gt; &lt;/Col&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;/Form&gt; 规则在data中设置
子key的名字和上述表单子项的prop设置的名字要一样 businessInfoRule:{ op:[ {required:true,message: '请填写业务op',trigger: 'change'} ], mailGroup:[ {required:true,type:'email',message: '请正确填写邮箱信息',trigger: 'change'}, ], note:[ {required:true,message: '请填写业务用途',trigger: 'change'}, {max:30,message: '请限制在30个字范围内',trigger: 'change'} ], objectInfo:[ {required:true,message: '请填写业务信息',trigger: 'change'}, ] }, 规则校验的函数以及调用函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c02e9a633c94d8b403b2996e80725b5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a52ae1128c090c4ed143f38cbeb09be/" rel="bookmark">
			kolla-ansible 多区域 multiRegion 安装 部署 openstack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境 centos 7.8
python 2..7.5
pip 19.3.1
ansible 2.7.18 kolla-ansible 7.2.2.dev9 (对应openstack Rocky版)
docker 4.2.0
二、架构 regionOne 高可用性，启用keystone horizon
regionTwo 使用 regionOne的 keystone horizon
三、步骤 1、部署区域1 regionOne 1.1编辑/etc/kolla/globals.yml # Location of configuration overrides node_custom_config: "/etc/kolla/config" # Region options ################ # Use this option to change the name of this region. openstack_region_name: "RegionOne" # Use this option to define a list of region names - only needs to be configured # in a multi-region deployment, and then only in the *first* region.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a52ae1128c090c4ed143f38cbeb09be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47bc090c1352887959edda1e64e34908/" rel="bookmark">
			pytorch实现RNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RNN实现分类问题 import torch import torch.nn as nn from torch.autograd import Variable import torchvision.datasets as dsets #包括了一些数据库，图片的数据库也包含了 import torchvision.transforms as transforms import matplotlib.pyplot as plt #超参数 EPOCH = 1 BATCH_SIZE = 64 TIME_STEP = 28 #rnn time step--&gt;image height INPUT_SIZE = 28 #rnn input size--&gt;image width LR = 0.01 DOWNLOAD_MNIST = False #已经下载好了，download设置成false #准备训练数据 train_data = dsets.MNIST( root = r'D:\python\minist', #存储路径 train = True, transform = transforms.ToTensor(), #把下载的数据改成Tensor形式 #把(0-255)转换成(0-1) download = DOWNLOAD_MNIST #如果没下载就确认下载,如果已经下载了就填False ) #把train_data变成train_loader，训练起来比较有效率 train_loader = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47bc090c1352887959edda1e64e34908/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7193e5767dc477f5e82eecd0a13f24e5/" rel="bookmark">
			宿主机使用WiFi时Ubuntu16.04系统VMware虚拟机联网方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		宿主机使用WiFi时Ubuntu16.04系统VMware虚拟机联网方法 环境描述第一步：虚拟机设置第二步：设置宿主机的wifi第三步：配置VMNet8第四步: VMware虚拟网络设置第五步：配置虚拟机ip地址参考资料 环境描述 宿主机：Windows 10 64bit
虚拟机：Ubuntu16.04 64bit
第一步：虚拟机设置 选择连接方式为NAT
第二步：设置宿主机的wifi 控制面板&gt;&gt;网络和Internet&gt;&gt;网络和共享中心&gt;&gt;更改适配器设置
打开【属性】窗口，点击【共享】
第三步：配置VMNet8 第四步: VMware虚拟网络设置 打开【编辑】→【虚拟网络编辑器】
NAT设置
第五步：配置虚拟机ip地址 ubuntu终端下执行 sudo vim + /etc/network/interfaces 命令。
清空原有文件内容，改用下面的内容：
auto lo iface lo inet loopback auto ens33 iface ens33 inet static address 192.168.137.86 netmask 255.255.255.0 gateway 192.168.137.2 dns-nameserver 223.5.5.5 保存退出
执行 /etc/init.d/networking restart 操作重启网卡
然后去配置 /etc/resolv.conf 文件。清空原有文件内容，改用下面的内容：
nameserver 223.5.5.5 dns-nameserver 223.5.5.5 保存退出
如果保存时显示 只读文件无法修改 给该文件设置权限777
执行 chmod 777 /etc/resolv.conf 命令再修改。
配置 /etc/resolvconf/resolv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7193e5767dc477f5e82eecd0a13f24e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a5b1c9509b3334ea2799a28b385f956/" rel="bookmark">
			vue-cli 安装 2020最新 vue 4.0安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.node.js 安装 百度搜索node.js，下载最新版 安装就行了 1.安装 cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org -g 是全局安装的意思
2.安装 vue-cli 3.0之前的版本
cnpm install vue-cli -g
4.0之后的版本
cnpm install -g @vue/cli 3.初始化项目 3.1命令新建项目 3.0之前的版本
vue init webpack 项目名
4.0开始
vue create 项目名 然后 选中-》手动
manually select features 推荐勾选，按【空格】勾选 (*)Babel ( )TypeScript (*)Progressive Web App (PWA)Support (*)Router ( )Vuex (*)CSS Pre-processors ( )Linter / Formatter ( )Unit Testing ( )E2E Testing 这里选择 n
use history mode for router?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a5b1c9509b3334ea2799a28b385f956/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/231f550ae6efac2bbee39537e3512d53/" rel="bookmark">
			springboot整合redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Maven依赖 pom.xml文件中添加Redis相关的依赖
&lt;!--redis依赖--&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
&lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
&lt;/dependency&gt; 2.application.yml文件添加Redis配置 spring:
redis:
database: 0
host: 192.168.100.15
port: 6379
password: 123456
lettuce:
pool:
# 连接池中的最大空闲连接 默认8
max-idle: 8
# 连接池中的最小空闲连接 默认0
min-idle: 0
# 连接池最大连接数 默认8 ，负数表示没有限制
max-active: 8
# 连接池最大阻塞等待时间（使用负值表示没有限制） 默认-1
max-wait: -1
timeout: 30000
3.编写Redis配置类 springboot为我们自动配置了RedisTemplate对象，默认使用jdk序列化，这里我们编写自己的RedisTemplate配置类，使用json的序列化方式存储对象。
@Configuration
public class RedisConfiguration{
@Bean
public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory){
RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate();
template.setConnectionFactory(redisConnectionFactory);
//使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）
Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/231f550ae6efac2bbee39537e3512d53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c4863ca95acbb0143dcf5fc23400af7/" rel="bookmark">
			FALSE/TRUE与false/true的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FALSE/TRUE与false/true的区别
1.FALSE/TRUE与false/true的区别：
false/true是标准C++语言里新增的关键字，而FALSE/TRUE是通过#define定义的INT数据，主要用途
是解决程序在C与C++中环境的差异，以下是FALSE/TRUE在windef.h的定义：
#ifndef FALSE #define FALSE 0 #endif #ifndef TRUE #define TRUE 1 #endif 也就是说FALSE/TRUE是int类型，而false/true是bool类型；所以两者不一样的，只不过
我们在使用中没有这种感觉，因为C++会帮你做隐式转换。
2.bool与BOOL内存大小的区别：
bool在C++里是占用1字节，而BOOL是int类型，int类型的大小是视具体环境而定的；所以
来说：false/true只占用1个字节，而TRUE/FALSE视具体环境而言，以下是BOOL在windef
.h中的定义：typedef int BOOL;
3.NULL与0的区别：
还是让我们看一下windef.h中NULL的定义：
#ifndef NULL
#ifdef __cplusplus//这个是指示是用C++来编译程序
#define NULL 0
#else
#define NULL ((void *)0)
#endif
#endif
所以说：它们没有区别，只不过在C里面会做一个强制类型转换。
BOOL和bool的区别
1、类型不同
BOOL为int型；bool为布尔型。
2、长度不同
bool只有一个字节；BOOL长度视实际环境来定，一般可认为是4个字节。
3、取值不同
bool取值false和true，是0和1的区别；BOOL取值FALSE和TRUE，是0和非0的区别。
bool是标准C++数据类型，可取值true和false。单独占一个字节，
如果数个bool对象列在一起，可能会各占一个bit，这取决于编译器。
BOOL是微软定义的typedef int BOOL。与bool不同，它是一个三值逻辑，
TRUE/FALSE/ERROR，返回值为&gt;0的整数为TRUE，0为FALSE，-1为ERROR。
Win32 API中很多返回值为BOOL的函数都是三值逻辑。比如GetMessage()。
4、例子
bool x=3; //告警
bool x=1; //正确
BOOL x=3; //正确
BOOL x=3.3; //告警
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c4863ca95acbb0143dcf5fc23400af7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7621a004f6d2e8019461a3717b9052b9/" rel="bookmark">
			Flowable 流程跟踪图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. DefaultProcessDiagramGenerator2. DefaultProcessDiagramCanvas3. 使用Flowable默认的流程图生成器4. 自定义流程图生成器4.1 扩展DefaultProcessDiagramCanvas4.2 扩展DefaultProcessDiagramGenerator4.3 或者自定义类实现ProcessDiagramGenerator4.4 使用自定义的流程图生成器生成流程图 1. DefaultProcessDiagramGenerator DefaultProcessDiagramGenerator是flowable默认的流程图生成器
该类中定义了各种生成图片和一些画图的方法，还有一些辅助方法（如：获取所有节点）
可以查看源码
2. DefaultProcessDiagramCanvas DefaultProcessDiagramCanvas ：flowable 提供的默认的流程图画布
类中定义了许多字体、颜色、大小、字体等静态变量，还有bpmn中节点（task，gateway，event，flow…）的基本行程，以及各类事件的图标
initialize方法，还有用来画各种节点、连线、事件等等的方法
可以查看源码
3. 使用Flowable默认的流程图生成器 /** * 流程申请 流转图片输入流 */ public void getFlowDiagram(String procInsId){ String procDefId; ProcessInstance processInstance = runtimeService.createProcessInstanceQuery() .processInstanceId(procInsId) .singleResult(); if (processInstance == null) { HistoricProcessInstance historicProcessInstance = historyService.createHistoricProcessInstanceQuery().processInstanceId(procInsId).singleResult(); procDefId = historicProcessInstance.getProcessDefinitionId(); } else { procDefId = processInstance.getProcessDefinitionId(); } BpmnModel bpmnModel = repositoryService.getBpmnModel(procDefId); DefaultProcessDiagramGenerator defaultProcessDiagramGenerator = new DefaultProcessDiagramGenerator(); // 创建默认的流程图生成器 String imageType = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7621a004f6d2e8019461a3717b9052b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ee0189cbfb247633bd0207e15a2a35/" rel="bookmark">
			python自然语言处理实战核心技术与算法——双向最大匹配法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人初学nlp，使用的是机械工业出版社的《python自然语言处理实战核心技术与算法》，学习到了双向最大匹配法，于是写下这篇文章记录一下整个代码的工作原理以及相应的理解。
目录 一、匹配切分二、算法代码及详谈1. 正向最大匹配法2. 逆向最大匹配法3.双向最大匹配法 三、总体代码与结果四、改进方式五、参考 一、匹配切分 在中文分词技术中的匹配切分输入规则分词方式，这是一种机械分词的方式，我们通过机器词典中的单词与语句中的每个词语进行匹配，如果匹配成功则切分，如果匹配失败则不与切分。
在匹配切分中，原则是“长词优先”，那么为什么是长词优先？这是因为在nlp中最需要考虑的几个问题是：速度与精度。以下是我的个人理解（主要是真的没查到相关的内容）：
大家仔细想一想，我们对一段话进行分词，是不是需要一直循环这段话与机器词典中的单词进行匹配操作，那么循环是不是一个很浪费性能的工作？如果我们一个字一个字的匹配，那么就等于这段话有多少个字，我们要循环多少次，更重要的是，我们是分词，不是分字，分字的话那么我们究竟是做新华字典还是做nlp对吧？所以我们通过长词优先，假设最长的词是4个字的成语，每一次循环就可能清理掉4个字，这样是不是有可能很大程度节约了性能？当然，最差的情况必定还是一个词都分不出来，这样的话理论上会比从小开始更消耗性能（因为算法中会依次减少匹配的字符数，具体的时候在代码中讨论），但是我们做中文分词，肯定不至于这句话中一个词语都没有在各个数据集中出现过对吧，所以长词优先可以增加相应的运行速度。
匹配切分中分为正向最大匹配法（Maximum Match Method，aka MM），逆向最大匹配法（Reverse Maximum Match Method，aka RMM），双向最大匹配法（Bi-directction Matching Method）
虽然本文讨论的是python实现双向最大匹配法，这种算法也运用了MM和RMM，所以下面就一起进行讨论。
二、算法代码及详谈 代码我引用的《python自然语言处理实战核心技术与算法》中的例子，词典为：
self.dic = ['研究', '研究生', '生命', '命', '的', '起源'] 那么由此可见机器词典最长词条字符数（窗口值）为3：
self.window_size = 3 这里是直接设定的机器词典最长词条字符数，但是我个人觉得在实际工程中，应该有个方法来判断机器词典中的最长词条字符数。比如使用len(max(list, key = len))这样的方法取。
文本为：
text = '研究生命的起源' 1. 正向最大匹配法 这里先上代码，注释写得比较完善，具体的算法思想等都写在代码中了：
def MM_cut(self): """ 正向最大匹配法的方法 算法思想: 1. 从左向右取待切分汉语句的m个字符作为匹配字符, m为机器词典中最长词条的字符数 2. 查找机器词典并进行匹配，若匹配成功, 则将这个匹配字段作为一个词切分出来。 若匹配不成功, 则将这个匹配字段的最后一个字去掉, 剩下的字符串作为新的匹配字段, 进行再次匹配, 重复以上过程, 直到切分出所有词为止。 :return MM_result: 正向最大匹配法匹配结果 """ MM_result = [] MM_index = 0 MM_text_length = len(self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59ee0189cbfb247633bd0207e15a2a35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a6bd81aedc2cb3e2d6dea8de4e3125/" rel="bookmark">
			技术日志7.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 函数修改引用的参数 python在引用变量的时候尤其要注意变量的作用域，在函数里引用不可变类型变量的时候，函数执行结束后是不会改变全局变量的值的；若想在函数里改变不可变类型全局变量的值时，引用的时候要用”global arg"；对于可变变量，函数执行结束后全局变量的值是回被改变的，如下：（说明一下，python不可变数据类型：string,int ,tuple 常量；可变数据类型：dict list）
参考博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc6b4ff2404f48b3f731eadce58272a0/" rel="bookmark">
			IntelliJ IDEA常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://www.cnblogs.com/jajian/p/8012603.html
收藏记录下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84c6def96d6b5d0cc9af9129e5fef0ab/" rel="bookmark">
			DeepLearning之LSTM模型输入数据：白话降维解说
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《 Dianchen666’s Deep Learning 学习笔记系列 ---- 小白角度看深度学习》
有导航，不迷路。
(1). DeepLearning之LSTM模型输入参数：time_step, input_size, batch_size的理解
(2). DeepLearning之LSTM模型输入数据：白话降维解说
本文摘要：
对于LSTM的输入参数的理解的应用。
LSTM模型真正的输入数据是什么样的？
通过LSTM的输入数据实例的讲解，更好的理解循环神经网络的输入数据。
1. LSTM的基本介绍 上次讲到了LSTM模型的输入参数的理解，这一篇讲讲我对LSTM以及循环网络模型的输入数据的理解。LSTM是循环神经网络的一个变种，加入了多个门来控制每个神经细胞的状态细胞的状态对于整个模型是非常重要的，训练模型主要是更新每个细胞的输入参数，转态参数，输入的参数，让每个细胞处于一个稳定的状态输入的数据的一般是time_step, input_size, batch_size，这三个输入参数的定义我已经在上一篇博文中谈了谈我的理解受一位博友启发，但是我发现好像没有博文对输入数据到底是什么样的，讲的非常的清晰透彻、清楚。本文尝试从非常白话的角度，来谈谈我对输入数据模样的理解。如有不对，还请多批评指正。 2. 基础参数理解 输入数据主要是三个参数，time_step, input_size, batch_size借某位博友的启发，引用一下它的话：“batch_size是指有多少组序列数据，而time_step是指每组序列数据中有多少个时刻”input_size 最好理解，就是输入的数据有几个自变量，就是有几个Xiteration与batchsize是有乘法关系的，3000条数据，100iteration，那么batchsize就是30。也就是Total sample = iteration（n）*batchsizebatch_size就是我们常说的批处理的数据量epoch=10就是进行10*100个iteration来对模型进行训练 3. 各参数确定的次序 首先应该确定的是由几个自变量，就是有几个X，由几个变量来预测另外一个y第2个应该确定的是time_step，就是确定你进行训练其中一次的有多少个时刻，这个time_step就应该是多少，换句话说就是你预测的这个y和之前的多少个时刻有关系，这样来确定。第3个就是batch_size, 原理上将batch_size可能会影响你的训练速度，因为它的定义是批大小，是一次训练所选取的样本数，为了在内存效率与内存容量之间寻找平衡，白话就是提高你的训练效率。batch_size和time_step本身没有关系，但是time_step的长短和input_size的多少会影响每一个iteration训练的速度。 3. 示意图 1.还是用一个excel的数据表来进行举例
2.时间是从2020年6月1日-6月30日，x1,x2,x3,x4,x5说明是有5个自变量，也就是Inputsize=5，y为要预测的值。
3.此时确定timestep的值，就是你预测的这个Y值是之前的几个时刻有关系，比如上图要预测的y值使用前5天的数据来进行预测，那么time_step=5，此时将上述的数据按照time_step的大小进行重构。
4.通过time_step参数对数据进行重构后，会产生新的数据组，组数=total_sample - time_step + 1，如下图：26组=total(30) - time_step(5) +1，每组数据都有5个时刻t
4.其中包含5个时刻数据的这一组数据称为输入数据的一个batch，而batch_size就是每一次feed数据有多少组这样的数据。batch(26) = total(30) - time_step(5) +1
5.再把每一个batch的数据剖开，看看每一个batch的数据是什么样的。
6.下图为一个粗糙的示意图。讲述了在一个Batch中数据是如何进行运转的。
7.在batch1 中，T1时刻的数据分为X变量与Y变量，在T1时刻X与Y数据被同时输入到LSTM中，通过各种门的计算，输出了一个细胞状态Ct1与Ht1，这个两个变量会作为输入变量到下一个时刻的计算当中。
8.到T2时，T1时刻输出的Ct1与Ht1与T2时刻的X变量（x1x2x3x4x5）输入到LSTM模型中，通过各种门的计算，最后得到Ct2与Ht2，在输入到下一时刻，直到整个batch结束。
一个batch中会循环计算time_step次。
10.上图中，红色直线代表是的细胞状态变量的转移
红色曲线代表的是目标值也就是Ht变量的转移。 11.在执行一个batch结束后，再执行下一个batch，batchsize=30就是1个iteration中执行了30个这样的batch，在一次feed数据中。
12.重构后的batch的个数，自己定义size的大小。上图中的所有数据重构后，变成了26个batch，你可以将batchsize设置为5，设置为10，设置为20。
13.无论batchsize设置为多少，每一组数据都是按照顺序进入到模型中进行训练。
4. 总结 那么batchsize主要影响模型的什么？主要是影响模型的泛化性能，就是模型在训练之后对于test数据预测的准确性。一般来说：越大大的batchsize，会减少模型训练所需要的时间，提高模型的稳定性在合适的范围内，增大batchsize，有助于收敛的稳定性，但是再随着batchsize的增加，模型的性能会下降（泛化性能）总结来说：batchsize在变得很大(超过一个临界点)时，会降低模型的泛化能力。 下一篇说说学习率与batchsiz对模型性能的影响。 ————————————————
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84c6def96d6b5d0cc9af9129e5fef0ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b18638702d60f0617b282515753771f8/" rel="bookmark">
			【cs224n学习作业】Assignment 1 - Exploring Word Vectors
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考【cs224n学习作业】Assignment 1 CS224N课程的第一个大作业， 主要是对词向量做了一个探索， 并直观的感受了一下词嵌入或者词向量的效果。这里简单的记录一下我探索的一个过程。分为两部分， 第一部分是基于计数的单词词向量， 而第二部分，是基于词向量的预测， 是利用了已经训练好的一个词向量矩阵去介绍一下怎么进行预测， 比如可视化这些词向量啊， 找同义词或者反义词，实现单词的类比关系等。
准备工作
导入要用的包
import sys assert sys.version_info[0]==3 assert sys.version_info[1] &gt;= 5 from gensim.models import KeyedVectors # KeyedVectors:实现实体（单词、文档、图片都可以）和向量之间的映射。每个实体由其字符串id标识。 from gensim.test.utils import datapath import pprint # 输出的更加规范易读 import matplotlib.pyplot as plt plt.rcParams['figure.figsize'] = [10, 5] # plt.rcParams主要作用是设置画的图的分辨率，大小等信息 import nltk nltk.download('reuters') # 这个可以从GitHub下载， 网址：https://github.com/nltk/nltk_data/tree/gh-pages/packages/corpora from nltk.corpus import reuters import numpy as np import random import scipy as sp from sklearn.decomposition import TruncatedSVD from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b18638702d60f0617b282515753771f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ea9e4c9bae893e176a020a13190082d/" rel="bookmark">
			divmod( )函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&gt;&gt;divmod(5, 2) &gt;&gt;(2, 1) divmod函数可同时返回商和余数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e33d2cd23bc4b555a07de109009a5015/" rel="bookmark">
			桥接、仅主机、NAT模式的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在创建虚拟机的时候，网络连接模式有三种可供选择，桥接bridge、仅主机host_only和NAT模式，一般我们会选择桥接或NAT模式，那具体有什么区别呢
1.仅主机模式：虚拟机只能访问物理机，不能上网。
这是最简单的模式，相当于拿一根网线直接连接虚拟机和物理机。
2.NAT模式：虚拟机可以访问物理机，同时也能通过物理机访问外网
这种模式下，物理机充当“路由器”的角色，虚拟机想要上网必须通过物理机，如果物理机不能上网，那么虚拟机也不能上网了。
这种模式的好处是兼容性强，物理机的网络环境变化时，虚拟机的网络不会受到影响。比如，上班时你把物理机连接在公司的网络环境中，下班后又把物理机连接在你家的路由器上。你公司的网段有可能和你家的网段是不同的。桥接模式下，虚拟机和物理机一样，都要自动获取IP才可以上网，而做实验的时候，是需要把虚拟机设置为静态IP的，这样就导致虚拟机网络不稳定。而设置为NAT模式，虚拟机的网络并不需要依赖你公司的网络环境或者你家的网络环境。
3.桥接模式：虚拟机和物理机连接同一网络，虚拟机和物理机是并列的关系，地位是相当的。比如，你家有路由器，那么你的电脑和你的手机同时连接这个路由器提供的Wi-Fi，那么它们的关系就是这种模式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f07735a667c87f5da56ed2a798144e2b/" rel="bookmark">
			由于无法验证发布者，Windows已经阻止此软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows系统都很注重系统的安全性，在提高安全性的同时，也给我们某些应用带来不便。比如在日常工作中经常会到某些网站上进行登录，需要安装该站点的ActiveX控件，否则无法正常加载。这时可能会弹出“由于无法验证发行者，所以WINDOWS已经阻止此软件”的相关提示，而致使无法正常使用系统，那该如何解决呢？
按下面操作，一般情况可以解决此类问题：
1 打开控制面板 方法一：打开运行窗口（win + R），输入 control，回车
方法二：点击“搜索”，输入控制面板，点击即可
2 打开控制面板之后点击网络和共享中心 3 点击 Internet 选项 4 先点击安全，然后点击下方的自定义级别 5 下拉找到 下载未签名的 ActiveX 控件 选项，把 禁用 改为 提示 6 设置结束，点击确定，弹出警告，点击 是 即可 小提示： 1.进行以上操作前要确认所安装的程序绝对安全，不熟悉的程序放弃为好，而不要强制按照以上方法来安装；
2.安装好此程序后，建议还将以上设置更改过来，以保证系统的安全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6133bd8f1320c2774ce5306d657aa2df/" rel="bookmark">
			java中返回两个参数问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java返回两个参数 return 数组或集合 return 数组或集合 如果只返回值超过2个参数则返回数组（同一类型使用类型数组，不同类型使用Object[]。参数个数未知时，使用集合。 总而言之：只能返回一个集合，想返回两个以上的参数，根本不行。或者用全局变量，不用返回。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17fbf829414c9af70c0b49ab2e57b5ca/" rel="bookmark">
			HCIA命令总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 命令符快捷键用户配置用户视图命令TelnetSSHFTPTFTPSFTP配置交换机双工模式ARP及proxy ARPVLAN基本配置及Access接口vlan基本配置 trunkHybrid接口单臂路由实VLAN间路由使用三层交换实现VLAN间路由GVRP配置STP基本配置命令stp定时器MSTP基础配置Smart Link 与Monitor Link配置配置Eth-trunk链路聚合静态路由PPP认证帧中继RIP配置RIPv2认证RIP路由协议的汇总配置RIP的版本兼容，定时器及协议优先级配置RIP抑制接口及单播更新RIP与不连续子网RIP的水平分割和触发更新配置RIP路由附加度量值RIP故障处理RIP路由引入 OSPF区域配置OSPF认证与被动接口配置Router-ID DR与BDROSPF开销值，协议优先级及计时器的修改 RIP与OSPF的配置IPv6DHCP基本ACL基础过滤工具 高级acl规则格式SNMP协议基础配置GRE协议基本配置(tunnel隧道创建)NATVRRP 命令符 从用户视图切换到系统视图 system–view 从系统视图切换到用户视图 quit 连入接口命令 interface IP地址、子网掩码配置命令 ip address 接口IP信息查看命令 display ip interface brief IPv4路由表信息查询命令 display ip routing–table 配置完成退回视图界面命令 return 命令自动补全快捷键 【Tab】 快捷键查看命令 display hotkey 路由名称修改命令 sysname （参数） 设置路由器时钟命令 clock datetime 设置路由器时区命令 clock timezone(时区）{add|minus}（偏移时间）[正向偏移add；负向偏minus] 登录标题修改命令 header loginheader login information “ ” 登录成功后标题设置命令 header shellheader shell information “ ” 路由信息查看命令 display version 路由当前配置查看命令 display current–configuration 接口状态查询命令 display interface gigabitethernet0/0/0 快捷键 删除光标位置的前一个字符，光标左移 退格键BavkSpace 光标向左移动一个字符位置；若已经到达命令起始位置，则停止 左光标键或&lt;Ctrl+B&gt; 光标向右移动一个字符位置；若已经到达命令起始位置，则停止 右光标键或&lt;Ctrl+F&gt; 删除光标所在位置的一个字符,光标位置保持不动，光标后方字符向左移动一个字符位置 删除键Delete 显示上一条历史命令。如果需显示更早的历史命令，可以重复使用该功能键 上光标键【Ctrl+P】 显示下一条历史命令，可重复使用该功能键 下光标键【Ctrl+N】 将光标移动到当前行的开始 Ctrl+A 将光标移动到当前行的末尾 Ctrl+E 清空当前行输入的命令 Ctrl+X 停止当前正在执行的功能 Ctrl+C 返回到用户视图，相当于return命令 Ctrl+ F 部分帮助的功能，输入不完整的关键字后按下Tab键，系统自动补全关键 {Tab}键 用户配置 设备当前支持用户界面信息查看命令 display user-interface 用户界面切换命令 user-interface(用户界面相对编号)（用户界面可选参数） 在对应的用户视图下对用户权限配置命令 user privilege level (用户级别) 配置用户界面验证方式的命令 authentication-mode{aaa|none|password} 配置VTY为aaa验证方式的用户名和密码 aaalocal-user (用户名) password cipher (密码)local-user (用户名) service-type telnet(代指接入类型) 配置用户权限命令 local-user (用户名) password cipher (密码) privilege level(权限)local-user(用户名) privilege level(权限) 配置Console用户界面为Password验证 set authentication password cipher (密码) Console用户配置信息查看命令 display current-configuration 手动保存当前配置命令 `save【configuration-file】参数 configuration-file为指定的配置文件名，格式必须是”.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17fbf829414c9af70c0b49ab2e57b5ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3fa35d3c70828230eb5c219a2ffdd52/" rel="bookmark">
			七周学会数据分析|良心教程 第二周
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第二周：业务
1、 为什么业务重要
唯有理解业务，才能建立业务数据模型。
2、 经典的业务分析指标
模型未动，指标先行。如果你不能衡量它，你就无法增长它。
指标建立的要点：核心指标、好的指标因该是比率、好的指标应该能带来显著效果、好的指标不应该虚荣、好的指标不应该复杂
2.1、市场营销指标
客户/用户生命周期：企业/产品和消费者在整个业务关系阶段的周期。
不同业务划分的阶段不同。传统营销中，分为潜在用户-用户范围，兴趣用户-销售线索，新客户，老/熟客户，流失客户。
用户价值：
用户贡献=产出量/投入量*100%
用户价值=（贡献1+贡献2+…）
比如金融行业会以存款+贷款+信用卡+年费+…-风险-流失
RFM模型：用户生命周期中，衡量客户价值的立方体模型。利用R最近一次消费时间，M总消费金额，F消费频次，将用户划分成多个群体。
用户分群，营销矩阵：用户分群是市场营销中的一种常见策略，它提取用户的几个核心维度，用象限法将其归纳和分类。
2.2、产品运营指标
AARRR：acquisition用户获取、activation用户活跃、retention用户留存、revenue营收、refer传播。 用户获取：
渠道到达量：俗称曝光量。有多少人看到了产品推广相关的线索。
渠道转化率：有多少用户因为曝光而心动cost per，包含CPM（曝光量）、CPC（点击量）、CPS（购买量）、CPD（下载量）、CPT（时间）
渠道ROI：推广营销的熟悉KPI，投资回报率，利润/投资100%。
营收：ARPU-某时间段内每位用户平均收入、ARPPU-某时间段内每位付费用户平均收入，排除了未付费的；客单价、LTV-用户生命周期价值、LTV=ARPU1/流失率；
传播：K因子、用户分享率、活动曝光量
2.3、用户行为指标
功能使用（功能使用率/渗透率）、用户会话、用户路径（路径图-加工出关键路径转化率）
2.4、电子商务指标
购物篮分析（笔单价、件单价、成交率、购物篮系数-平均每笔订单中，卖出多少件商品）、好基友（复购率-一段时间内多次购买；回购率-一段时间内消费过的用户，在下一段时间内仍旧消费的占比）
2.5、流量指标
浏览量 pv 和访客量 uv ( uv会通过ip或cookie来衡量 )
访客行为-新老访客占比（生命力）、访客时间（质量）、访客平均访问页数（吸引力）、来源（通过参数提取）、用户行为转化率、首页访客占比、退出率、跳出率 （跳出率一般衡量各个落地页，营销页等页面，退出率则更偏产品，任何页面都有退出率）
3、怎么生成指标
访客访问时长+UV=重度访问用户占比（浏览五分钟以上的用户在整个访客的占比）
用户会话次数+成交率=有效消费会话占比（用户在所有会话中，其中有多少次有消费？）
4、业务的分析框架
4.1、如何建立业务分析框架
从指标的角度分析、
从业务的角度分析、
从流程的角度分析
4.2 如何应对各类业务场景
练习-熟悉业务-应用三种核心思维-归纳和整理出指标-画出框架-检查、应用、修正-应用和迭代
5、数据化管理业务
30%数据统计+ 70%数据管理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1be2ebea1f92a8125a2aeded00724991/" rel="bookmark">
			linux中的 -d  、-s   等的含义  文件修改用户 或者权限(rwx)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点我 文件权限1.文件属性的查看 文件所有人所有组的管理文件普通权限字符方式修改该文件权限数字方式修改该文件权限系统默认权限的设定与chmod 一样都是设定权限，只不过，chmod是直接设置权限是r、w或x，而umask是缺省权限，即不让设r、w 或x umask的作用 1、useradd -d -s在Linux是什么意思 useradd是添加用户的。后面应该还要添加一个用户名。 -d是指定用户的家目录 -s是指定用户的登录shell 例如:useradd -d /usr/qqq -s /bin/tcsh qqq 含义：指定的家目录是usr目录下的qqq 登录shell是tcsh 注意:创建用户不加-d和-s是是系统默认的家目录(/home/qqq)和登录shell(/bin/bash)。 文件权限 chmod [-R] 777文件或目录 ：设置权限（chmod a+rwx a=chmod ugo +rwx a=chmod 777 a） ​注： r（read）对应4，w（write）对应2，x（execute）执行对应1； -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改） chmod [{ugoa}{+-=}{rwx}][文件或目录] ：如chmod u-w,g+x,o=r test.txt为user（拥有者）去掉写权限，group(所属组)加上执行权限，other(其他人)权限等于只读； chown [-R] admin:root /opt/ ：变更文件及目录的拥有者和所属组（-R递归处理所有文件和文件夹，admin为拥有者，root为所属者） 1.文件属性的查看 ls -l fileName
-|rw-r–r--.|1| root| root| 46 |Nov 1 05:03 |fileName
|rw-r--r--.| 1 | root| root| 46 | Nov 1 07:03 |fileName 分段含义“-”:文件类型- 普通文件 d 目录 c字符设备 s 套接字 p管道 b快设备 l 连接“rw-r–r--”:文件读写权限u“1”对文件：文件内容被系统记录的次数 对目录：目录中文件属性的字节数“root”文件所有人“root”文件所有组“46”文件内容的大小“Nov 1 07:03”:文件最后一次被修改的时间“fileName”文件名字 文件所有人所有组的管理 分段含义chown username(用户名) file更改文件的所有人chgrp groupname (组名) file更改所有组chown -R username dir更改目录本身及里面所有内容的所有人chgrp -R groupname dir更改目录本身及里面所有内容的所有组 文件普通权限 rw-|r--|r-- rw-r–r–ugo文件所有人对文件可以读写文件组成员对文件可读其他人对文件可读u优先匹配g次优先o=u，g不匹配时匹配 rwx对文件：可以查看文件中的字符对文件：可以更改文件内字符对文件：可以运行文件内记录的程序动作对目录：可以查看目录中文件的信息对目录：可以在目录中添加删除文件对目录：可以进入目录中 字符方式修改该文件权限 chmod [-R] &lt;u|g|o&gt;&lt;+|-|=&gt;&lt;r|w|x&gt; file|dir
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1be2ebea1f92a8125a2aeded00724991/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7172b4a6506b5f775d9187d2f579622/" rel="bookmark">
			OAI rfsimulator搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OAI 搭建教程 本文说明了在ubuntu18.04虚拟机中，使用rfsimulator代替usrp进行仿真，搭建OAI的具体过程
一、安装Ubuntu 1、 使用VMware安装虚拟机，选择ubuntu18.04
2、 安装完系统之后先调整屏幕大小（安装vmware tools）
在VMware软件中，右键单击虚拟机（Ubuntu 64位），安装VMware Tools。在ubuntu桌面上打开VMware Tools，将里面的压缩包文件解压进入解压后的文件夹，打开vmware-install.pl进行安装（在终端输入命令./vmware-install.pl执行），一直Enter下去（选择默认，或者yes），直到显示成功即可。可以参考https://www.cnblogs.com/aidenzdly/p/10321034.html中的第1-5步 3、 安装完成后，在Linux系统中打开终端，输入命令
apt-get update apt-get upgrade 4、 安装git并配置git
sudo apt install git git config --global user.name "Laurent" git config --global user.email "laurent.thomas@open-cells.com" 5、将OAI存储库添加为授权的远程系统
echo -n | openssl s_client -showcerts -connect gitlab.eurecom.fr:443 2&gt;/dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' | sudo tee -a /etc/ssl/certs/ca-certificates.crt 在不换源的情况下，使用apt下载包或者依赖时可能会失败，因为原来的软件源的服务器在国外，换成国内的之后使用apt-get install会畅通无阻：
换源操作可以参考https://www.cnblogs.com/aidenzdly/p/10321034.html中的第6-11步（注意在第10步点击关闭之前，应该先将源代码那一栏也勾上）除了上述这种图形化界面操作的方法，网上大多数方法是使用命令行，修改系统文件，也是可行的。参考：https://blog.csdn.net/XC_LMH/article/details/86506770 二、安装USRP驱动程序 sudo apt-get install libboost-all-dev libusb-1.0-0-dev python-mako doxygen python-docutils python-requests python3-pip cmake build-essential pip3 install mako numpy git clone git://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7172b4a6506b5f775d9187d2f579622/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c997ec82791afa0930a55b4c1b164aeb/" rel="bookmark">
			centos7 怎么让命令行显示中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大部分这几部就ok了
(1).查看系统是否安装中文包：locale -a |grep "zh_CN" 没有的话：yum groupinstall "fonts" [xf@xuexi ~]$ locale -a |grep "zh_CN" zh_CN zh_CN.gb18030 zh_CN.gb2312 zh_CN.gbk zh_CN.utf8 [root@xuexi ~]# cat /etc/locale.conf LANG="zh_CN.UTF-8"　（2）直接编辑 vim /etc/locale.conf 里面内容删掉哪怕一样也删 复制 LANG="zh_CN.UTF-8"　（3）source /etc/locale.conf （4）去试试看看效果 后面是前面不行再试试
第一，打开语系支持文件bai：
#vim /etc/sysconfig/i18nLANG=“en_US.UTF-8”　du ← 找到这一行，将“UTF-8”，改为"GB2312”
第二，安装中文zhi环境的shell ：dao
首先安装libstdc++.so.5包：# yum install libstdc++.so.5
再下载zhcon：# nchc.dl.sourceforge.net/sourceforge/zhcon/zhcon-0.2.3-1.i386.rpm
安装下载的zhcon：# rpm -ivh zhcon-0.2.3-1.i386.rpm
完了，用zhcon 命令就可以显示中文了。
第三 安装中文包
yum -y groupinstall编辑配置文件 vim /etc/locale.conf 将这个文件里面的LANG=“XXXX” 改LANG=“zh_CN.UTF-8”重启计算机，千万要记住重启计算机，我一开始没重启，然后就没有成功显示中文，还以为是教程有问题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e878a655445b7a090328473a73389194/" rel="bookmark">
			操作系统 读者写者问题的实现（C&#43;&#43;  读者优先、写者优先）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过信号量机制和相应的系统调用，用于线程的互斥和同步，实现读者写者问题。利用信号量机制，实现读者写者问题。
在windows 10环境下，创建一个控制台进程，此进程包含n个线程。用这n个线程来表示n个读者或写者。每个线程按照设定进行读写操作。用信号量机制分别实现读者优先和写者优先的读者写者问题。
读者和写者问题的读写操作限制（包括读者优先和写者优先）：
写写互斥：即不能有两个写者同时进行写操作。
读写互斥：即不能同时有一个线程在读，而另一个线程在写。
读读允许：即可以有一个或多个读者在读。
读者优先的附加限制：如果一个读者申请进行读操作时已有另一个读者正在进行读操作，则该读者可直接开始读操作。
写者优先的附加限制：如果一个读者申请进行读操作时已有另一写者在等待访问共享资源，则该读者必须等到没有写者处于等待状态才能开始读操作。
读者优先：
如果没有写者正在操作，则读者并不需要等待，用一个整型变量readercount表示正在读的进程数目。由于只要有一个Reader进程在读，便不允许Writer进程去写，于是仅当readercount=0时，说明尚无读者进程在读，Reader进程才需要执行wait(book)操作。若该操作成功了，Reader进程便可去读，相应地，做readercount+1操作。同理，仅当Reader进程在执行了readercount减一操作后其值为0时，才须执行signal（book）操作，以便让Writer进程写操作。，每个读者开始读之前都要修改readercount,为了互斥的实现对readercount 的修改，需要一个互斥对象rc_mutex来实现互斥。
为实现Reader与Writer进程间在读或在写的互斥而设置一个互斥的信号量book，表示对资源的访问。当写者发出写的请求时，必须先得到允许。通过这种方法，可以实现读写互斥，当readcount=0时，（即第一个读者的到来时，），读者线程也必须申请。
当读者拥有所有权，写者都阻塞在信号量对象book上。当写者拥有所有权时，第一个判断完readcount==0 后，其余的读者由于等待对readcount的判断，阻塞在rc_mutex上。
写者优先：
写者优先和读者优先有相同之处，不同的地方在：一旦有一个写者到来时，应该尽快让写者进行写，如果有一个写者在等待，则新到的读者操作不能读操作，为此添加一个整型变量writercount,记录写者的数目，当writercount=0时才可以释放读者进行读操作。
为了实现对全局变量writercount的互斥访问，设置了一个互斥信号量wc_mutex,同时，读者线程要对全局变量readercount实现操作上的互斥，必须有一个互斥对象命名为。
为了实现写者优先，设置一个临界区对象read,当有写者在写或等待时，读者必须阻塞在临界区对象read上。同样，有读者读时，写者必须等待。于是，必须有一个互斥对象book来实现这个互斥。
写者的操作应该优先于读者，则信号量一直被占用着，直到没有写者的时候才会释放，即当writerCount等于1的时候，申请信号量book，其余的写者无需再次申请，但是写者是不能同时进行写操作的，则需要设置一个信号量wrt来保证每次只有一个写者进行写操作，当写者的数量writeCount等于0的时候，则证明此时没有没有读者了，释放信号量book。当readCount为1的时候，为阻止写者进行写操作，申请信号量wrt，则写者就无法进行写操作了。信号量mutex的主要用处就是避免写者同时与多个读者进行竞争，读者中信号量book比mutex先释放，则一旦有写者，写者可马上获得资源。
实现效果图：
读者写者测试文本
读者优先：
写者优先：
最后给出源码：
#include&lt;iostream&gt; #include&lt;string&gt; #include &lt;conio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;fstream&gt; #include &lt;io.h&gt; #include &lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;Windows.h&gt; //多线程编程 #include&lt;process.h&gt; using namespace std; #define READER 'R' //读者 #define WRITER 'W' //写者 #define INTE_PER_SEC 1000 //每秒时钟中断的数目 #define MAX_THREAD_NUM 64 //最大线程数目 //变量声明初始化 int readercount = 0;//记录等待的读者数目 int writercount = 0;//记录等待的写者数目 HANDLE rc_mutex;//因为读者数量而添加的互斥信号量，用于读者优先 HANDLE rc2_mutex;//因为读者数量而添加的互斥信号量，用于写者优先 HANDLE wc_mutex;//因为写者数量而添加的互斥信号量 HANDLE book;//互斥访问信号量 HANDLE wrt;//保证每次只有一个写者进行写操作，当写者的数量writercount等于0的时候，则证明此时没有没有读者了,释放信号量book HANDLE mutex;//避免写者同时与多个读者进行竞争，读者中信号量RWMutex比mutex3先释放，则一旦有写者，写者可马上获得资源 struct thread_info { int id;	//线程序号 char entity; //线程类别(判断是读者线程还是写者线程) double delay;	//线程延迟时间 double lastTime;	//线程读写操作时间 }; /*****************/ //读者优先 //进程管理-读者线程 void rp_threadReader(void *p) { DWORD m_delay; //延迟时间 DWORD m_persist; //读文件持续时间 int m_serial; //线程序号 //从参数中获得信息 m_serial = ((thread_info*)(p))-&gt;id; m_delay = (DWORD)(((thread_info*)(p))-&gt;delay *INTE_PER_SEC); m_persist = (DWORD)(((thread_info*)(p))-&gt;lastTime *INTE_PER_SEC); Sleep(m_delay); //延迟等待 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e878a655445b7a090328473a73389194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6985a5e552782ac057c9a9fd7e560fba/" rel="bookmark">
			MySQL复制表的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 复制表结构及其数据
下面这个语句会拷贝数据到新表中。
注意：这个语句其实只是把select语句的结果建一个表，所以新表不会有主键，索引。
create table table_name_new as (select * from table_name_old); 只复制表结构
create table table_name_new as select * from table_name_old where 1=2; 或者
create table table_name_new like table_name_old; 注意：前一种方式是不会复制主键类型，索引的，而后一种方式是把旧表的所有字段类型都复制到新表。
只复制表数据
如果两个表结构一样
insert into table_name_new select * from table_name_old; 如果两个表结构不一样
insert into table_name_new(column1,column2...) select column1,column2... from table_name_old; 注意：很多文章说可以通过如下语句进行数据复制，table_name_new表可以不存在，会在执行的过程中自动创建。其实该SELECT ... INTO形式是使查询结果存储在变量或将其写入文件，即table_name_new是一个变量或者文件。
select column1,column2,.... into table_name_new from table_name_old; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a584c506ad57d4cc395a3bb9d10dfb05/" rel="bookmark">
			Makefile查漏补缺
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 、基本框架
Target：Dependence
cmd
//test.c: #include&lt;iostream&gt; int main(void){ std::cout&lt;&lt;"hello world"&lt;&lt;tsd::endl; } Makefile:
APP=myapp COMPILER=g++ all : $(APP) $(APP) : test.o $(COMPILER) -o $(APP) test.o test.o : test.c $(COMPILER) -c test.c 命令：
make ./myapp 2、伪目标
.Phony:all 伪目标不是文件，但是为了防止防止make不执行此命令，可以用.Phony指定
3、自动变量
自动变量都是以$开头，加上一些特殊的符号，表示特殊的变量
$%、$&lt;、$^、$? /**helloworld.c**/ #include&lt;stdio.h&gt; int main() { foo("hello world\n"); } /**foo.c**/ #include&lt;stdio.h&gt; int foo() { printf("hello world\n"); } #Makefile helloworld:helloworld.c foo.c gcc -o $@ $^ all:helloworld 从上述例子中看出， $%表示目标、$^表示所有依赖
修改makefile
#Makefile helloworld:helloworld.c foo.c gcc -o $@ $&lt; all:helloworld 可以看出$&lt;表示第一个依赖
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a584c506ad57d4cc395a3bb9d10dfb05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cd831df44491417a862dae2b41e7dc7/" rel="bookmark">
			CH340C的ESP8266一键下载电路设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		▶ 概述 CH340 是一个 USB 总线的转接芯片，实现 USB 转串口或者 USB 转打印口。在串口方式下，CH340 提供常用的 MODEM 联络信号，用于为计算机扩展异步串口，或者将普通的 串口设备直接升级到 USB 总线。
▶ 封装 其实物封装为标准的 16 脚贴片，CH340C内置时钟，无需外部晶振。
▶ 引脚 设计中主要关注UD-、UD+、TXD、RXD、DTR#、RTS#。
▶ 电路 micro-usb端主要接出D-、D+，为数据线。VBUS和GND，为电源。
CH340C的TXD、RXD分别接到ESP8266的RX与TX上。UD+、UD-分别对应usb的D+、D-。（7、8脚为NC.图示错误，CH340C自带晶振）。
采用一对数字三极管，通过对DTR#、RTS#的控制，实现对芯片的复位与程序下载（IO0为低电平有效）的控制。
资料来源：https://www.wemos.cc/en/latest/d1/d1_mini_lite.html（ESP D1 mini）
https://atta.szlcsc.com/upload/public/pdf/source/20171107/C84681_15100186735851094113.PDF （CH340资料）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df2aa105c469060983e4044715966d08/" rel="bookmark">
			并发事务带来哪些问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题：
脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
不可重复度和幻读区别：
不可重复读的重点是修改，幻读的重点在于新增或者删除。
例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。
例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6458473805261cfb8135f9527dfb111d/" rel="bookmark">
			leetcode_74_搜索二维矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搜索二维矩阵 描述 中等
编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。
示例1:
输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 输出: true 示例2：
输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 输出: false 解题 既然升序的矩阵，而且每行的第一个整数大于前一行的最后一个数
那么可以直接将一行行的数据依次拼接成一个一维有序数组，然后二分查找
class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: if len(matrix) == 0 or len(matrix[0]) == 0 or matrix[0][0] &gt; target or matrix[-1][-1] &lt; target: return False m = [] for i in matrix: m += i left = 0 right = len(m)-1 while left &lt;= right: mid = (left+right) // 2 if m[mid] == target: return True elif m[mid] &gt; target: right = mid-1 else: left = mid+1 return False 既然是二维矩阵，那么就要以二维矩阵来做
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6458473805261cfb8135f9527dfb111d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a07ee3259e7b83422134ed870d74d48f/" rel="bookmark">
			java.io.FileNotFoundException: java.io.FileNotFoundException: HADOOP_HOME and hadoop.home.dir are un
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.io.FileNotFoundException: java.io.FileNotFoundException: HADOOP_HOME and hadoop.home.dir are unset. -see https://wiki.apache.org/hadoop/WindowsProblems
at org.apache.hadoop.util.Shell.fileNotFoundException(Shell.java:528)
at org.apache.hadoop.util.Shell.getHadoopHomeDir(Shell.java:549)
at org.apache.hadoop.util.Shell.getQualifiedBin(Shell.java:572)
at org.apache.hadoop.util.Shell.&lt;clinit&gt;(Shell.java:669)
at org.apache.hadoop.util.StringUtils.&lt;clinit&gt;(StringUtils.java:79)
at org.apache.hadoop.conf.Configuration.getBoolean(Configuration.java:1555)
at org.apache.hadoop.hbase.HBaseConfiguration.checkDefaultsVersion(HBaseConfiguration.java:73)
at org.apache.hadoop.hbase.HBaseConfiguration.addHbaseResources(HBaseConfiguration.java:87)
at org.apache.hadoop.hbase.HBaseConfiguration.create(HBaseConfiguration.java:102)
at com.shanglin.util.HbaseUtil.&lt;clinit&gt;(HbaseUtil.java:25)
at com.shanglin.dao.PdvisterDao.getUserSatebyvistertime(PdvisterDao.java:31)
at com.shanglin.stream.map.PindaopvuvMap.flatMap(PindaopvuvMap.java:36)
at com.shanglin.stream.map.PindaopvuvMap.flatMap(PindaopvuvMap.java:20)
at org.apache.flink.streaming.api.operators.StreamFlatMap.processElement(StreamFlatMap.java:50)
at org.apache.flink.streaming.runtime.tasks.OperatorChain$CopyingChainingOutput.pushToOperator(OperatorChain.java:579)
at org.apache.flink.streaming.runtime.tasks.OperatorChain$CopyingChainingOutput.collect(OperatorChain.java:554)
at org.apache.flink.streaming.runtime.tasks.OperatorChain$CopyingChainingOutput.collect(OperatorChain.java:534)
at org.apache.flink.streaming.api.operators.AbstractStreamOperator$CountingOutput.collect(AbstractStreamOperator.java:718)
at org.apache.flink.streaming.api.operators.AbstractStreamOperator$CountingOutput.collect(AbstractStreamOperator.java:696)
at org.apache.flink.streaming.api.operators.StreamSourceContexts$ManualWatermarkContext.processAndCollectWithTimestamp(StreamSourceContexts.java:310)
at org.apache.flink.streaming.api.operators.StreamSourceContexts$WatermarkContext.collectWithTimestamp(StreamSourceContexts.java:409)
at org.apache.flink.streaming.connectors.kafka.internals.AbstractFetcher.emitRecordWithTimestampAndPeriodicWatermark(AbstractFetcher.java:436)
at org.apache.flink.streaming.connectors.kafka.internals.AbstractFetcher.emitRecordWithTimestamp(AbstractFetcher.java:402)
at org.apache.flink.streaming.connectors.kafka.internal.Kafka010Fetcher.emitRecord(Kafka010Fetcher.java:89)
at org.apache.flink.streaming.connectors.kafka.internal.Kafka09Fetcher.runFetchLoop(Kafka09Fetcher.java:154)
at org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumerBase.run(FlinkKafkaConsumerBase.java:665)
at org.apache.flink.streaming.api.operators.StreamSource.run(StreamSource.java:94)
at org.apache.flink.streaming.api.operators.StreamSource.run(StreamSource.java:58)
at org.apache.flink.streaming.runtime.tasks.SourceStreamTask.run(SourceStreamTask.java:99)
at org.apache.flink.streaming.runtime.tasks.StreamTask.invoke(StreamTask.java:300)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a07ee3259e7b83422134ed870d74d48f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f5de5ef216417aa2b7334807d4ff898/" rel="bookmark">
			tkinter-grid布局详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前文tkinter-pack布局详解介绍了pack布局，相信对tkinter的布局套路有了一定的了解。本文将介绍另一种布局类grid。
同样，展示布局类与控件类的类间关系：
文章目录 grid默认分布columnrowcolumnspanrowspanipadxipadypadxpadysticky grid grid从字面意思上可以推断，这种布局方式就像网格一样来分布控件。那么具体会呈现什么样的效果，要怎么编码控制呢。同样的套路，通过实例来进行直观的讲解。
widget.grid(cnf={}, **kw)
默认分布 from tkinter import (Tk, Button) from tkinter.constants import RIGHT, LEFT, X, Y, BOTH main_win = Tk() main_win.title('渔道的pack布局') width = 300 height = 300 main_win.geometry(f'{width}x{height}') # print(main_win.keys()) apple_color = 'Crimson' banana_color = 'Yellow' orange_color = 'Orange' grape_color = 'Purple' fruit = {'apple':'Crimson', 'banana':'Yellow', 'orange':'Orange', 'grape':'Purple'} # 默认显示效果 for k,v in fruit.items(): bt = Button(main_win, text=k, fg='black', bg=v) bt.grid() print(bt.grid_info()) main_win.mainloop() print函数的打印信息如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f5de5ef216417aa2b7334807d4ff898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbabc409e938de7a421d28930e4fc454/" rel="bookmark">
			第八周工作总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这周的工作主要集中在后台的开发以及对于插件样式的一些修改，前者的问题主要是对于组件的不熟悉，后者的问题则全是集中在安卓的webview上，由于种种原因，安卓webview的垂直居中问题一直都没很好的解决，这篇文章也会抽出相当一段篇幅去总结一下一些相关经验。
工作之外的其他 和小伙伴们的关系自然也越来越好了，一方面是做过的业务基本和每个伙伴都对接过了，另一方面随着业务做的越来越多，懂得和不懂得都越来越多了，自然交流的也越来越多了。同时入职了新同学，虽然和我同级，但是因为是两年制，已经毕业了，除了羡慕还能说什么呢？
自然也挨了不少数落，从自己的代码，到自己写的BUG，再到对接的同学的质疑，基本能碰到的也都碰到了，总结一下自己原因，新业务确实在一直写，却也很少有时间去反省写过的代码暴露的一些问题，无论是时间成本还是新业务给的压力。
反思了一下，觉得完全可以调整一下自己的处理策略，首先是从吃过早饭到午饭的两个小时，之前这两个小时的效率一直存在一些问题，主要就是用这两个小时的时间去处理昨天遗留下来的问题，或者直接开始写新业务。
前者更经常，因为往往很多问题一晚上的休息往往会指向更好的思路，因此第二天加紧把这个思路去实现是最正常的做法。当然也会有一些时候前一天没有遇到任何难题，或者遇到的一些难题就在要写的业务中，不过我一般都是前一天把简单的能做的都做完，所以这样的情况很少。这时候直接投入去拼新业务貌似也不是太好的做法，更合理的做法还是去解决一些顽疾而不是硬写业务。顽疾就有很多了，真是要谢谢android的webview呢。
午饭过后休息一会到晚饭的时间平均是四个半小时，基本都是在拼新业务或者改BUG，没啥好说的，最多是一些重要度的排序，还是很好区分的（仔细反省忽然觉得有时候可能处理的并不好）。
晚上的时间就很难说了，一半的时间还是写业务，剩下一半就是在改BUG，很多事情都会积累到晚上，运气好做完会轻松的离开，运气不好一堆反馈堆积，心情都会受到不好的影响。这样下来确实早晨去做一些自我提升是最合适的。不仅包括有助于写业务的自我提升，看一些其他同学的代码也是一种很好的自我提升。
andr webview 每次设计走查的时候都会遇到安卓的webview垂直居中的问题，每次都是投机取巧的解决，没找到一种根本的解决方法，
目前网上所谓的解决方案有很多，最有用的大概还是使用line-height：normal配合padding或者flex进行解决的方案，即使在安卓的webview上，许多表现同样是不一样的，有些微调可能在一种机型上是有用的，换一个机型就不适用了。
与这个相似的还有文字的省略。
展望 下周会尝试封装一个公共组件，比起来写后台还是比较开心的。
不知不觉已经第八周了，希望能用16结束这段难忘的时光，爱你们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ae4d3ce1c514e0456e669a54fa1afaf/" rel="bookmark">
			TX-LCN TM集群与负载均衡设计方案 草稿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 TM集群特点 1）所有节点对等，为P2P结构，不存在主从节点。
2) 节点之间使用Redis作为中间节点，所有状态信息更新至Redis中
TM集群示例图 TM 健康检查机制 所有TM都会上传自己的信息到中，tm:cluster:*格式的key存在，
例如，某一时刻redis中记录的信息如下
TM每30秒上报自己的信息到Redis中
tm:cluster:*的key存在超时时间，默认为60s，
因此，当TM超过两次未上报自己信息，或者上报信息表示自己不可用时，会从集群内删除
TC端 TC端会保存所有TM的实例清单
TM端 TM端会提供一些接口，反应当前的状态信息，比如最近一段时间内的并发量，请求成功率等。以方便TC选择合适的TM端进行请求
事务发起方使用TM时序图 本地服务A（TC1）在启动时读取本地TM集群配置。本地服务A使用客户端负载均衡，由负载均衡策略，选择选择节点TM2调用TM2加入到事务组服务A调用服务B本地服务A使用客户端负载均衡，由负载均衡策略，选择选择节点TM1调用TM1加入到事务组继续执行后续内容 这样，tc调用的TM节点会使用当前的负载均衡策略选择节点，相对于单TM节点，TM集群分摊了整个应用的调用压力，可以很好的提高并发量。
总结来说，该机制主要有以下特点
使用客户端负载均衡 ，由事务发起方TC决定使用哪个TM由于TM使用同一个Redis，故所有TM的事务信息共享，TM为无状态服务，调用任一服务效果一致。 常用负载均衡策略 轮询策略（RoundRobinRule）
轮询策略就是拿到所有的服务节点的列表，对所有节点进行固定排序，挨个请求
当请求到最后一个节点的情况下，下次请求从第一个节点开始
随机策略（RandomRule）
拿到所有的服务节点的列表后，对现有可访问节点，随机抽取一个进行访问
并发量最小可用策略
TC定时主动去拉去TM的状态信息，TM会返回最近一段时间的并发量统计数据，选择一个并发量最小的并且可用的TM去访问。
其他可用策略待添加
客户端负载均衡技术实现方案 客户端实时更新TM集群节点列表 tc本地配置文件会配置TM集群内的部分或者全部节点
txlcn: tm: server: 192.168.100.1:8070,192.168.100.2:8070,192.168.100.3:8070 整体时序图如下所示
TC首次启动时，从当前配置文件中选择一可用TM服务器，获取TM集群信息列表开启定时器，定时执行TM集群状态更新任务，默认30s一次，可配置 负载均衡 预设几种常见的负载均衡方案
轮询策略随机策略并发量最小可用策略(默认) 用户可实现自己的负载均衡策略
特点 TM不区分集群配置还是单节点配置。默认都是使用集群的策略（节点数为1时跳过负载均衡逻辑）本地TC只需要配置部分TM集群内的节点，TC启动后会自动拉取所有节点信息。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0482f58138306cbd5703ff8ab7a3746/" rel="bookmark">
			springboot2.0过滤不需要返回的字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot2.0过滤不需要返回的字段 过滤值为空的字段
在yml文件中添加：
spring:
jackson:
default-property-inclusion: non_null
2、过滤不需要返回的字段但是字段值不为空
在实体类上方添加注解
@JsonIgnoreProperties（values={“字段名称”}）
比如：创建时间和修改时间不反回 @JsonIgnoreProperties(values{"createTime","updateTime"}) pubic class Student{ private Long id; private String name; private String sex; private Date createTime; privae Date updateTime; } 在网上查找的还有另外一种方法，就是在字段上方添加@JsonIgnore注解，但是我加了后还是返回，不知道为什么
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74392552bc88e1102e8d33ae08101c49/" rel="bookmark">
			leetcode_236_二叉树的最近公共祖先
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树的最近公共祖先 描述 中等
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]
示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明:
所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉树中。
解题 如果根节点为p或q，直接返回根节点
否则对左右子树进行查找
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74392552bc88e1102e8d33ae08101c49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ee9b549ed60ad7c46197aeee332d17c/" rel="bookmark">
			ShardingSphere x Seata，一致性更强的分布式数据库中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日前，分布式数据库中间件 ShardingSphere 将 Seata 分布式事务能力进行整合，旨在打造一致性更强的分布式数据库中间件。
背景 数据库领域，分布式事务的实现主要包含：两阶段的 XA 和 BASE 柔性事务。
XA 事务底层，依赖于具体的数据库厂商对 XA 两阶段提交协议的支持。通常，XA 协议通过在 Prepare 和 Commit 阶段进行 2PL（2 阶段锁），保证了分布式事务的 ACID，适用于短事务及非云化环境（云化环境下一次 IO 操作大概需要 20ms，两阶段锁会锁住资源长达 40ms，因此热点行上的事务的 TPS 会降到 25/s 左右，非云化环境通常一次 IO 只需几毫秒，因此锁热点数据的时间相对较低）。
但在 BASE 柔性事务方面，ShardingSphere 提供的接入分布式事务的 SPI，只适用于对性能要求较高，对一致性要求比较低的业务。
Seata 核心的 AT 模式适用于构建于支持本地 ACID 事务的关系型数据库。通过整合 Seata，其 AT 模式在一阶段提交+补偿的基础上，通过 TC 的全局锁实现了 RC 隔离级别的支持，可提高 ShardingSphere 的分布式事务的一致性。
整合方案 整合 Seata AT 事务时，需要把 TM，RM，TC 的模型融入到 ShardingSphere 分布式事务的 SPI 的生态中。在数据库资源上，Seata 通过对接 DataSource 接口，让 JDBC 操作可以同 TC 进行 RPC 通信。同样，ShardingSphere 也是面向 DataSource 接口对用户配置的物理 DataSource 进行了聚合，因此把物理 DataSource 二次包装为 Seata 的 DataSource 后，就可以把 Seata AT 事务融入到 ShardingSphere 的分片中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ee9b549ed60ad7c46197aeee332d17c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2570630edf09938e2d535ec1ffbbfb72/" rel="bookmark">
			深入理解Hadoop HDFS【一篇就够】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		又是一篇值得收藏温习的好文，更多好文请关注原文博主！！！
原文=&gt;https://blog.csdn.net/bingduanlbd/article/details/51914550#t24
文本详细介绍了HDFS中的许多概念，对于理解Hadoop分布式文件系统很有帮助。
1. 介绍 在现代的企业环境中，单机容量往往无法存储大量数据，需要跨机器存储。统一管理分布在集群上的文件系统称为分布式文件系统。而一旦在系统中，引入网络，就不可避免地引入了所有网络编程的复杂性，例如挑战之一是如果保证在节点不可用的时候数据不丢失。
传统的网络文件系统（NFS）虽然也称为分布式文件系统，但是其存在一些限制。由于NFS中，文件是存储在单机上，因此无法提供可靠性保证，当很多客户端同时访问NFS Server时，很容易造成服务器压力，造成性能瓶颈。另外如果要对NFS中的文件进行操作，需要首先同步到本地，这些修改在同步到服务端之前，其他客户端是不可见的。某种程度上，NFS不是一种典型的分布式系统，虽然它的文件的确放在远端（单一）的服务器上面。
从NFS的协议栈可以看到，它事实上是一种VFS（操作系统对文件的一种抽象）实现。
HDFS，是Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。Hadoop抽象文件系统可以与本地系统、Amazon S3等集成，甚至可以通过Web协议（webhsfs）来操作。HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。
如果你从零开始搭建一个完整的集群，参考[Hadoop集群搭建详细步骤（2.6.0）]（http://blog.csdn.net/bingduanlbd/article/details/51892750）
2. HDFS设计原则 HDFS设计之初就非常明确其应用场景，适用与什么类型的应用，不适用什么应用，有一个相对明确的指导原则。
2.1 设计目标 存储非常大的文件：这里非常大指的是几百M、G、或者TB级别。实际应用中已有很多集群存储的数据达到PB级别。根据Hadoop官网，Yahoo！的Hadoop集群约有10万颗CPU，运行在4万个机器节点上。更多世界上的Hadoop集群使用情况，参考Hadoop官网.
采用流式的数据访问方式: HDFS基于这样的一个假设：最有效的数据处理模式是一次写入、多次读取数据集经常从数据源生成或者拷贝一次，然后在其上做很多分析工作 分析工作经常读取其中的大部分数据，即使不是全部。 因此读取整个数据集所需时间比读取第一条记录的延时更重要。
运行于商业硬件上: Hadoop不需要特别贵的、reliable的（可靠的）机器，可运行于普通商用机器（可以从多家供应商采购） ，商用机器不代表低端机器。在集群中（尤其是大的集群），节点失败率是比较高的HDFS的目标是确保集群在节点失败的时候不会让用户感觉到明显的中断。 2.2 HDFS不适合的应用类型 有些场景不适合使用HDFS来存储数据。下面列举几个：
1） 低延时的数据访问 对延时要求在毫秒级别的应用，不适合采用HDFS。HDFS是为高吞吐数据传输设计的,因此可能牺牲延时HBase更适合低延时的数据访问。
2）大量小文件 文件的元数据（如目录结构，文件block的节点列表，block-node mapping）保存在NameNode的内存中， 整个文件系统的文件数量会受限于NameNode的内存大小。 经验而言，一个文件/目录/文件块一般占有150字节的元数据内存空间。如果有100万个文件，每个文件占用1个文件块，则需要大约300M的内存。因此十亿级别的文件数量在现有商用机器上难以支持。
3）多方读写，需要任意的文件修改 HDFS采用追加（append-only）的方式写入数据。不支持文件任意offset的修改。不支持多个写入器（writer）。
3. HDFS核心概念 3.1 Blocks 物理磁盘中有块的概念，磁盘的物理Block是磁盘操作最小的单元，读写操作均以Block为最小单元，一般为512 Byte。文件系统在物理Block之上抽象了另一层概念，文件系统Block物理磁盘Block的整数倍。通常为几KB。Hadoop提供的df、fsck这类运维工具都是在文件系统的Block级别上进行操作。
HDFS的Block块比一般单机文件系统大得多，默认为128M。HDFS的文件被拆分成block-sized的chunk，chunk作为独立单元存储。比Block小的文件不会占用整个Block，只会占据实际大小。例如， 如果一个文件大小为1M，则在HDFS中只会占用1M的空间，而不是128M。
HDFS的Block为什么这么大？ 是为了最小化查找（seek）时间，控制定位文件与传输文件所用的时间比例。假设定位到Block所需的时间为10ms，磁盘传输速度为100M/s。如果要将定位到Block所用时间占传输时间的比例控制1%，则Block大小需要约100M。 但是如果Block设置过大，在MapReduce任务中，Map或者Reduce任务的个数 如果小于集群机器数量，会使得作业运行效率很低。
Block抽象的好处 block的拆分使得单个文件大小可以大于整个磁盘的容量，构成文件的Block可以分布在整个集群， 理论上，单个文件可以占据集群中所有机器的磁盘。 Block的抽象也简化了存储系统，对于Block，无需关注其权限，所有者等内容（这些内容都在文件级别上进行控制）。 Block作为容错和高可用机制中的副本单元，即以Block为单位进行复制。
3.2 Namenode &amp; Datanode 整个HDFS集群由Namenode和Datanode构成master-worker（主从）模式。Namenode负责构建命名空间，管理文件的元数据等，而Datanode负责实际存储数据，负责读写工作。
Namenode Namenode存放文件系统树及所有文件、目录的元数据。元数据持久化为2种形式：
namespcae imageedit log 但是持久化数据中不包括Block所在的节点列表，及文件的Block分布在集群中的哪些节点上，这些信息是在系统重启的时候重新构建（通过Datanode汇报的Block信息）。 在HDFS中，Namenode可能成为集群的单点故障，Namenode不可用时，整个文件系统是不可用的。HDFS针对单点故障提供了2种解决机制： 1）备份持久化元数据 将文件系统的元数据同时写到多个文件系统， 例如同时将元数据写到本地文件系统及NFS。这些备份操作都是同步的、原子的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2570630edf09938e2d535ec1ffbbfb72/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/361/">«</a>
	<span class="pagination__item pagination__item--current">362/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/363/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>