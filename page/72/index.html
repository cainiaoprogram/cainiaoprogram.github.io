<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0783f1cc1ffd1f9ce2dc34ea45128a8/" rel="bookmark">
			tododotdo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tododotdo
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67c6877657630e1f005b046774730a94/" rel="bookmark">
			Windows虚拟机映射端口到本机端口，提供服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows10直接创建的Linux虚拟机提供服务时，局域网或外网是无法通过Windows主机进行访问的，因此在虚拟机提供对外服务时，需要增加一步操作，即
先在虚拟机中使用ifconfig命令查看虚拟的的IP：
ifconfig 返回结果：
eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.24.6.212 netmask 255.255.240.0 broadcast 172.24.15.255 这里可以看到虚拟机的IP是172.24.6.212
然后在Windows中，打开管理员窗口，执行命令：
比如我们的Linux虚拟机的8000端口提供服务，则运行如下命令
netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=8000 connectaddress=172.24.6.212 connectport=8000 这里就是把0.0.0.0:8000的内容转移到172.24.6.212:8000上
此时在Windows本机上就可以用：http://127.0.0.1:8000访问虚拟机的8000端口服务了，其他电脑也可以通过http://windows主机IP:8000访问虚拟机上的服务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd5c8b1f30de5b2e7ca5997700829f3/" rel="bookmark">
			Java系列之 IDEA 为类 和 方法设置注解模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章底部有个人公众号：热爱技术的小郑。主要分享开发知识、学习资料、毕业设计指导等。有兴趣的可以关注一下。为何分享？ 踩过的坑没必要让别人在再踩，自己复盘也能加深记忆。利己利人、所谓双赢。
1、类方法注解模板 1、File–&gt;settings–&gt;Editor–&gt;File and Code Templates–&gt;Files
@BelongsProject：项目名
@BelongsPackage：当前包的名称
@Author：作者姓名
@CreateTime：该类创建的时间
@Description：对该类的描述
@Version：设置版本号，一般新创建的类都是1.0版本，这里写死就可以了
1.1 模板 将这部分代码 放到IDEA 的指定位置。
/** *@BelongsProject: ${PROJECT_NAME} *@BelongsPackage: ${PACKAGE_NAME} *@Author: zhengyuzhu *@CreateTime: ${YEAR}-${MONTH}-${DAY} ${HOUR}:${MINUTE} *@Description: TODO *@Version: 1.0 */ 1.2 实际效果 编写一个类，试一下
/** * @BelongsProject: Java-Work-Demo * @BelongsPackage: A1多线程.B1超时处理.Demo1 * @Author: zhengyuzhu * @CreateTime: 2023-11-14 11:31 * @Description: TODO * @Version: 1.0 */ public class MyTest { } 2、方法注解模板(一) 1.1 模板 * * @description: * @author: zhengyuzhu * @date: $date$ $time$ * @param: $param$ * @return: $return$ **/ 实现的效果是这样的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbd5c8b1f30de5b2e7ca5997700829f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc4f60430d621d6022f8d55732451c17/" rel="bookmark">
			nvm工具解决nodejs版本切换问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见版本问题 npm启动vite项目报错，信息如下
npm run dev &gt; my-vue-app@0.0.0 dev D:\data\code\document-assistant-web &gt; vite file:///D:/data/code/document-assistant-web/node_modules/vite/bin/vite.js:7 await import('source-map-support').then((r) =&gt; r.default.install()) ^^^^^ SyntaxError: Unexpected reserved word at Loader.moduleStrategy (internal/modules/esm/translators.js:140:18) at async link (internal/modules/esm/module_job.js:42:21) npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! my-vue-app@0.0.0 dev: `vite` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the my-vue-app@0.0.0 dev script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc4f60430d621d6022f8d55732451c17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e26ab29485c1ff25505ab085f8cfdc9/" rel="bookmark">
			科研学习|科研软件——SPSS：卡方检验（交叉表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步 打开SPSS软件，在工具栏中选中【打开-文件-数据】，然后选择一份要打开的数据表(如图所示)。
第二步 在工具栏中找到【分析-描述统计-交叉表】打开交叉表对话框(如图所示)。
第三步 接着将【行-列】相关变量放在对应对话框中(如图所示)。
第四步 在对话框右边功能栏中点击【统计量】，接着勾选【卡方以及相关性】，交叉表就是卡方分析(如图所示)。
第五步 接着继续在右边功能栏中点击【单元格】，勾选【期望值】(如图所示)。
第六步 最后点击确定即可看到交叉表还有卡方分析统计结果，卡方值大于0.05即有显著性差异，即表示无统计学意义(如图所示)。
结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fda956815be69f91fdb2876a31e943dc/" rel="bookmark">
			ubuntu 22.04 服务器网卡无IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ssh连接服务器连接不上，提示如下；
连接显示器，ip addr ls 命令查看IP地址，有网卡但没有IP地址
solution： sudo dhclient enp10s0 用于通过 DHCP 协议获取网络配置信息并为名为 enp10s0 的网络接口分配 IP 地址,enp10s0替换为本机网络接口名称
但是一旦重启 ，又没了IP地址 。目前为止暂未找到解决办法
修复方法: 偶然的机会被同学告知解决方法
cd /etc/netplan sudo nano 00-installer-config.yaml 之前网卡接口名称有问题，是enp9s0，修改为正确的名称enp10s0即可（ifconfig查询）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2389adb8c0398a79da94f0064099fc2/" rel="bookmark">
			【反编译系列】二、反编译 .pyc 文件（uncompyle6）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【反编译系列】二、反编译 .pyc 文件（uncompyle6）1. 介绍2. 反编译Reference 【反编译系列】二、反编译 .pyc 文件（uncompyle6） 1. 介绍 .pyc 文件是 Python 将 .py 源代码编译后生成的字节码文件,主要有以下几个特点和作用:
加速执行：直接执行 .pyc 字节码，可以跳过反复编译的步骤，直接运行已编译好的字节码，从而加快执行速度；
隐藏源代码：包含编译后的字节码，而不会包含原始的源代码，可对源代码进行加密或者保护源代码不被用户访问；
跨平台运行：不同平台编译的 .pyc 字节码文件可在其它平台上运行，可以将 Python 程序打包成 .pyc 文件在不同系统上分发和运行；
冗余检查：Python解释器会根据 .py 文件的修改时间来检查 .pyc 文件是否过期；如果 .py 文件没有改动，.pyc 可以直接重用，避免重复编译；
支持单文件运行：可以只发布 .pyc文件让用户直接运行，而不需要随附源代码，一定程度上保护代码；
节省内存：只加载 .pyc 文件可以减少内存开销，因为不需要加载源码。
总体来说，.pyc 文件提高了执行效率、跨平台性，并提供了代码保护和优化内存使用等好处，所以 Python 自动使用 .pyc 字节码文件，但开发者仍可以访问和修改原始源代码。
2. 反编译 .pyc 文件是 Python 编译后的字节码文件，不是直接可读的文本文件，所以无法直接用文本/代码编辑器（下图为 VSCode）打开或查看其具体内容：
但是，使用反编译工具（uncompyle6）可以将其反编译为 .py 即 Python 程序源代码：
1、使用 pip 安装该反编译包（默认已有 python 环境）：
pip install uncompyle 如果速度很慢或者直接报 HTTP 错误，可以使用国内源（下述为清华源）进行下载安装：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2389adb8c0398a79da94f0064099fc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2869a8257beb549cee89c2e4df685e33/" rel="bookmark">
			计算机网络课后作业2023秋
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络第三版吴功宜版 课后作业 第一章作业三、计算与问答3.73.8 第二章作业三、计算与问答3.23.53.6 第三章作业三、计算与问答3.13.53.73.8 第四章作业三、计算与问答3.13.2 第五章作业三、计算与问答3.13.33.4VLAN交换机模式模式切换重置交换机VLAＮ配置命令其它命令 第一章作业 三、计算与问答 3.7 长度为 8B与536B 的应用层数据通过传输层时加上了 20B的 TCP 报头，通过网络层时加上60B的IP分组头通过数据链路层时加上了18B的 Ethernet 头和尾。分别计算两种情况下的数据传输效率。 8B: 8 8 + 20 + 60 + 18 = 4 53 ≈ 0.0755 \frac{8}{8+20+60+18}=\frac{4}{53} \approx 0.0755 8+20+60+188​=534​≈0.0755
536B: 536 536 + 20 + 60 + 18 = 536 634 ≈ 0.845 \frac{536}{536+20+60+18}=\frac{536}{634} \approx 0.845 536+20+60+18536​=634536​≈0.845
3.8 计算发送延时与传播延时条件:
主机之间传输介质长度 D=1000km。电磁波传播速度为 2 × 1 0 8 2\times10^8 2×108m/s。
(1) 数据长度为 1 × 1 0 3 1\times10^3 1×103bit,数据发送速率为100Kbps。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2869a8257beb549cee89c2e4df685e33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a4d0707880cfef238c1fb70e961c9d/" rel="bookmark">
			springboot实现多环境配置spring.profiles.active
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、spring.profiles.active介绍：
springboot项目中，我们经常把一些变量参数写在application.properties文件中，但是不同的环境参数可能不一样，spring.profiles.active可以区分环境。多环境配置的文件名需要满足application-{profile}.properties的格式，其中{profile}对应环境标志，如
application-dev.properties开发环境配置文件 application-test.properties测试环境配置文件 application-prod.properties生产环境配置文件 然后在默认配置文件中通过spring.profiles.active来指定，指定也有两种方式：
1、手动指定：这种方法切换环境需要修改配置文件，不够方便
spring.profiles.active = {profile} #如spring.profiles.active = prod 2、打包自动指定： 二、demo：
1、启动类： package com; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class ProfilesApplication { public static void main(String args[]){ SpringApplication.run(ProfilesApplication.class,args); } } 2、多环境配置文件：
开发环境application-dev.properties:
zt.profiles = this is dev 测试环境application-test.properties
zt.profiles = this is test 生产环境application-prod.properties zt.profiles = this is prod 3、接口：
package com.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class TestController { @Value("${zt.common}") private String common; @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02a4d0707880cfef238c1fb70e961c9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9aa07cbbeeaed1883626febd5e97566/" rel="bookmark">
			写二进制显示的文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 QString binData = QDateTime::currentDateTime().toString("yyyy-MM-dd"); char* cTemp=array.data(); uint8_t* ucTemp =reinterpret_cast&lt;uint8_t*&gt;(cTemp); //先将接收到的原始数据写文件 for(int i=0;i&lt;array.size();i++) { binData+=" "+QString("%1").arg(QString::number(ucTemp[i],2),8,'0'); } binData += "\n\n\n\n\n"; //写测试文件 QString strNameTmp = "D:/Test.log"; QFile fileTmp; fileTmp.setFileName(strNameTmp); if(fileTmp.open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text)) { fileTmp.write(binData.toUtf8()); fileTmp.close(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5acaf589ad8a1aa7fcec8c342c7e9359/" rel="bookmark">
			uniapp推送PUSH1.0的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;view&gt; &lt;view class="header p-4"&gt; &lt;view class="status_bar"&gt;&lt;/view&gt; &lt;view class="d-flex "&gt; &lt;view class="mr-5 pt-1"&gt; &lt;u-avatar :src="userInfo.avatar" size='60'&gt;&lt;/u-avatar&gt; &lt;/view&gt; &lt;view&gt; &lt;view class="text-white font-20 font-weight"&gt;试验综合管理系统&lt;/view&gt; &lt;view class="my-1 text-white font-14"&gt;部门: {{userInfo.organizationName}}&lt;/view&gt; &lt;view class="font-14 text-white"&gt;职务: {{userInfo.dutyName ==''?'未分配':userInfo.dutyName}}&lt;/view&gt; &lt;view class="font-14 text-white mt-1"&gt;位置: {{city}}&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="px-2 pt-2"&gt; &lt;view class="bg-white p-2 wrapbox d-flex a-center j-sb font-14"&gt; &lt;view class="d-flex flex-column a-center"&gt; &lt;view class="font-weight"&gt;{{weekday[new Date().getDay()]}}&lt;/view&gt; &lt;view class="font-weight"&gt;{{$u.timeFormat(new Date().getTime(), 'yyyy-mm-dd')}}&lt;/view&gt; &lt;/view&gt; &lt;view&gt;天气 : {{weather}}&lt;/view&gt; &lt;view&gt;温度 : {{temperature}}℃&lt;/view&gt; &lt;view&gt;湿度 : {{humidity}}%&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5acaf589ad8a1aa7fcec8c342c7e9359/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c871cf52951aeb799946d9eea30ca4/" rel="bookmark">
			uniapp打开第三方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;view&gt; &lt;view class="header border-bottom"&gt; &lt;view :style="{height: systemBarHeight}"&gt;&lt;/view&gt; &lt;view class="headertop px-2 d-flex a-center j-sb"&gt; &lt;view class="mr-5" @click="nextBack"&gt; &lt;image style="width: 45rpx;height: 45rpx;" src="../../static/back.png" mode=""&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class="wrapInput py-1 px-3 flex-1"&gt; &lt;input v-model="keyword" type="text" placeholder='请输入关键字'&gt; &lt;/view&gt; &lt;view class="ml-4 search" @click="searchBtn"&gt;搜索&lt;/view&gt; &lt;/view&gt; &lt;view class="d-flex a-center bg-white"&gt; &lt;view class="flex-1"&gt; &lt;uni-data-select v-model="subId" :localdata="SubCategoryList" placeholder="请选择标准"&gt;&lt;/uni-data-select&gt; &lt;/view&gt; &lt;view class="flex-1"&gt; &lt;uni-data-select v-model="status" :localdata="range"&gt;&lt;/uni-data-select&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view :style="{height: fixedHeight}"&gt;&lt;/view&gt; &lt;view class="p-2"&gt; &lt;view class="wrap p-2 mb-2" v-for="(item,index) in tableData"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18c871cf52951aeb799946d9eea30ca4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a200bfadb590ce92ec61050b76b2cc6d/" rel="bookmark">
			Win10通用串行总线usb控制器有感叹号的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时安装新系统后，将所有驱动都安装上了，但设备管理器中有时还会显示通用串行总线usb控制器有感叹号，说明该驱动未安装成功，但这是连接U盘和USB鼠标功能都是正常的，尝试用驱动精灵检测也没有发现需要安装的驱动。从网上找了很多方法都没解决，当前安装的Win1909版系统，就想着升级下系统版本看怎么样，然后就用下边的地址https://www.microsoft.com/zh-cn/software-download/windows10
升级成了目前最新的22H2版本，升级后重启系统就没有感叹号了，可能是新版系统中对该设备驱动有更新，大家遇到类似的问题可以这样尝试下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41439aa68d89d903e1e04e2a842473a0/" rel="bookmark">
			java常用队列与堆栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支持多线程操作的队列与堆栈【来源于GPT】：
队列（Queue）：
ConcurrentLinkedQueue：基于链表实现的无界非阻塞队列，支持高并发操作。ArrayBlockingQueue：基于数组实现的有界阻塞队列，支持多线程操作。LinkedBlockingQueue：基于链表实现的可选有界或无界阻塞队列，支持多线程操作。PriorityBlockingQueue：基于堆实现的无界阻塞队列，支持元素按优先级排序。 栈（Stack）：
ConcurrentLinkedDeque：基于双向链表实现的无界非阻塞双端队列，可作为栈使用，支持高并发操作。ArrayDeque：基于数组实现的无界双端队列，可作为栈使用，支持多线程操作。LinkedBlockingDeque：基于链表实现的可选有界或无界双端队列，可作为栈使用，支持多线程操作。 说明
阻塞队列，是一种特殊的队列，它在普通队列的基础上提供了两个附加功能
（1）当队列为空的时候，获取队列中元素的消费者线程会被阻塞，同时唤醒生产者线程。
（2）当队列满了的时候，向队列中添加元素的生产者线程被阻塞，同时唤醒消费者线程。
有界：队列中能够容纳的元素个数，通常情况下是有界的，比如我们实例化一个ArrayBlockingList，可以在构造方法中传入一个整形的数字，表示这个基于数组的阻塞队列中能够容纳的元素个数。这种就是有界队列。
无界：没有设置固定大小的队列，它的默认队列长度是Integer.Max_Value，所以我们感知不到它的长度限制。
ConcurrentLinkedQueue使用和方法介绍 定义
一个基于链接节点的无界线程安全队列。此队列按照 FIFO（先进先出）原则对元素进行排序。队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。
新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许使用 null 元素。
ConcurrentLinkedQueue&lt;xxx&gt; queue = new ConcurrentLinkedQueue&lt;&gt;();
offer和poll
offer(E e) ：将指定元素插入此队列的尾部。
poll() ：获取并移除此队列的头，如果此队列为空，则返回 null。
offer是往队列添加元素，poll是从队列取出元素并且删除该元素
peek() ： 获取但不移除此队列的头；如果此队列为空，则返回 null
size or isEmpty
如果此队列包含的元素数大于 Integer.MAX_VALUE，则返回 Integer.MAX_VALUE。
需要小心的是，与大多数 collection 不同，此方法不是 一个固定时间操作。由于这些队列的异步特性，确定当前的元素数需要进行一次花费 O(n) 时间的遍历。
所以在需要判断队列是否为空时，尽量不要用 queue.size()&gt;0，而是用 !queue.isEmpty()
&lt;&lt;方法摘要&gt;&gt; boolean add(E e) 将指定元素插入此队列的尾部。
boolean contains(Object o)
如果此队列包含指定元素，则返回 true。
boolean isEmpty()
如果此队列不包含任何元素，则返回 true。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41439aa68d89d903e1e04e2a842473a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d330f93d1b31ef624dce59d4184ab2ee/" rel="bookmark">
			antlr4错误处理(came as a complete surprise to me while matching alternative LeftRecursiveRuleTransforme)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报错 1.syntax error: ‘&lt;’ came as a complete surprise to me while matching alternative 参考这个issue，antlr版本必须得是4.6
下载链接：http://www.antlr.org/download/antlr-4.6-complete.jar
2.org.antlr.v4.analysis.LeftRecursiveRuleTransformer.setAltASTPointers(LeftRecursiveRuleTransformer.java:241) 参考这个issue，Java版本必须得是Java6/7
二、快捷 (1)antlr4运行命令 antlr4和grun永久配置别名 echo "alias antlr4='java -jar /usr/local/lib/antlr-4.0-complete.jar'" &gt;&gt; ~/.bashrc echo "alias grun='java org.antlr.v4.runtime.misc.TestRig'" &gt;&gt; ~/.bashrc 使用antlr4生成语法分析器和词法分析器 antlr4 test.g4 编译生成的Java文件 javac *.java 使用TestRig调试 grun [Grammar] [Rule] -options eg. grun test r -tokens (2)各种语言的.g4文件 https://github.com/antlr/grammars-v4/tree/master
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4e4431b2b0cde9ab38ba2c606a5534d/" rel="bookmark">
			青龙脚本分享（不断更新完善）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 开篇详细的使用教程可以往下看其他签到脚本青龙京东脚本分享6dylan6（集合库）【√可用】gys619（集合库）【√可用】fake2助力池版（集合库）【√可用】Faker3 纯净版【√可用】Akali5【√可用】KingRan 【√可用】zero205【√可用】smiek2121【√可用】curtinlv【√可用】 青龙其他签到脚本准备工作新建脚本消息通知pushplus设置环境变量安装依赖定时任务定时规则 阿里云签到（只签到不领取奖励）阿里云盘签到（js文件，有时候不推送消息bug，但是领取奖励）bilbil签到1. 步骤1.1. 登录青龙面板并修改配置1.2. 在青龙面板中添加拉库定时任务1.2.1. 订阅管理1.2.2. 定时任务拉库1.3. 登录PushPlus的Token,参考[pushplus的官网](http://www.pushplus.plus/doc/)PushPlus的Topic,参考[pushplus的官网](http://www.pushplus.plus/doc/) 天翼云盘签到(不需要环境变量版)天翼云盘签到（修改版，环境变量版）什么值得买签到脚本内容青龙拉库脚本NodeJS 依赖抓包青龙环境变量 恩山签到每日天气提醒下一个节假日每天60s小米社区签到代码 epic消息提醒欢迎大家投稿 开篇 当你们打开这篇文章的时候，大概率是已经配置好环境了，如果没有配置好青龙环境，看我之前的文章，安装docker、青龙和青龙卸载更新，lxc安装docker青龙，安装ubuntu-server系统等。
详细的使用教程可以往下看其他签到脚本 青龙京东脚本分享 脚本库-Hi科技玩家
6dylan6（集合库）【√可用】 github地址
拉库指令
国内机用下面指令（带代理）：
ql repo https://js.nbplay.site/https://github.com/6dylan6/jdpro.git "jd_|jx_|jddj_" "backUp" "^jd[^_]|USER|JD|function|sendNotify" 国外机（无需代理）用下面指令：
ql repo https://github.com/6dylan6/jdpro.git "jd_|jx_|jddj_" "backUp" "^jd[^_]|USER|JD|function|sendNotify" 使用流程
1、青龙部署。
2、登录青龙配置管理config.sh修改，差不多在17行（特别注意，没有修改此配置，任务拉不全，一键部署可忽略此处）；
RepoFileExtensions="js py"修改为 RepoFileExtensions=“js py sh ts” 保存；
3、新建拉库任务或订阅，并执行，刷新浏览器即可看到添加的任务；
4、添加CK环境变量，多CK不要写在一起，每个都新建JD_COOKIE变量；
5，通知key变量请添加到配置管理config.sh文件，否则收不到通知；
支持的通知方式
server酱，go-cqhttp，pushdeer，Bark App，tg bot，钉钉bot，企业微信bot，企业微信应用消息，飞书，iGot，push plus，WxPusher，gotify
请在配置管理config文件里写变量
gys619（集合库）【√可用】 github地址
评价：脚本很多，但是好多失效脚本
拉库指令
ql repo https://github.com/gys619/Absinthe.git “jd_|jx_|jddj_|gua_|jddj_|getJDCookie|wskey” “activity|backUp” “^jd[^_]|USER|utils|ZooFaker|JDJRValidator_|^sign|jddj_cookie|function|ql” “main” fake2助力池版（集合库）【√可用】 github地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4e4431b2b0cde9ab38ba2c606a5534d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c924f6a25d79c493bd5ce1e228ee39/" rel="bookmark">
			FPGA\CPLD 设计学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题记：这个笔记不是特权同学自己整理的，特权同学只是对这个笔记做了一下完善，也忘了是从那 DOWNLOAD 来的，首先对整理者表示感谢。 这些知识点确实都很实用，这些设计思想或者也可以说是经验吧，是很值得每一个有志于 FPGA/CPLD 方面发展的工程师学习的。 1 、硬件设计基本原则 (1) 、速度与面积平衡和互换原则 ：一个设计如果时序余量较大，所能跑的频率远高于设计要求，能可以通过模块复用来减少整个设计消耗的芯片 面积，这就是用速度优势换面积的节约；反之，如果一个设计的时序要求很高，普通方法达不到设计频率，那么可以通过数据流串并转换，并行 复制多个操作模块，对整个设计采用 “ 乒乓操作 ” 和 “ 串并转换 ” 的思想进行处理，在芯片输出模块处再对数据进行 “ 并串转换 ” 。从而实现了用面积复 制换取速度的提高。 (2) 、硬件原则 ：理解 HDL 本质 (3) 、系统原则 ：整体把握 (4) 、同步设计原则 ：设计时序稳定的基本原则 2 、 Verilog 作为一种 HDL 语言，对系统行为的建模方式是分层次的。比较重要的层次有 系统级（ system ）、算法级（ Algorithm ）、寄存器传输 级（ RTL ）、逻辑级（ Logic ）、门级（ Gate ）、电路开关级（ Switch ）。 3 、实际工作中， 除了描述仿真测试激励（ Testbench ）时使用 for 循环语句外，极少在 RTL 级编码中使用 for 循环 ，这是因为 for 循环会被综合器 展开为所有变量情况的执行语句，每个变量独立占用寄存器资源，不能有效的复用硬件逻辑资源，造成巨大的浪费。 一般常用 case 语句代替 。 4 、 if…else… 和 case 在嵌套描述时是有很大区别的， if…else… 是有优先级的 ，一般来说，第一个 if 的优先级最高，最后一个 else 的优先级最低。 而 case 语句是平行语句，它是没有优先级的，而建立优先级结构需要耗费大量的逻辑资源，所以能用 case 的地方就不要用 if…else… 语句。 补充： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49c924f6a25d79c493bd5ce1e228ee39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58851d967ebb90133755bfdf92866a31/" rel="bookmark">
			零基础独立开发QT上位机项目指北
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言: 由于各种复杂因素，个人因素，近期在做嵌入式相关的工作。我在开发一个QT上位机软件，以串口通信为例。
我之前没有体系去学过QT框架，有用则学，无用则不学。希望此文能为同学们带来微小的学习启发。
通过网上摸索，我总结出了一个快速熟悉QT的学习内容，以下资料是比较优秀的实战案例（仅供参考）
参考： Qt串口模块QSerialPort简单使用
1.QT串口模块QSerialPort简单使用
Qt串口通信开发之QSerialPort模块详细使用方法与实例
2.Qt串口通信开发之QSerialPort模块详细使用方法与实例
Qt串口通信开发之Qt串口通信模块QSerialPort开发完整实例（串口助手开发）
3.Qt串口通信开发之Qt串口通信模块QSerialPort开发完整实例（串口助手开发）
B站:QT如何用Qt编写一个串口程序
4.B站:QT如何用Qt编写一个串口程序
B站:[Qt串口助手]Qt串口通信介绍
5.Qt串口通信介绍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a60beb9ec5b9cb44dd2f6d79453655f/" rel="bookmark">
			【CUDA编程--编程模型简介&amp;算子开发流程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档：https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html
什么是CUDA CUDA全称（Compute Unified Device Architecture）统一计算架构，是NVIDIA推出的并行计算平台深度学习加速：对于神经网络，无论是离线训练还是在线推理，都有巨量的矩阵、归一化、softmax等运算，且其中有非常多的并行计算，非常适合用GPU来进行运算加速
一般来说，应用程序混合有并行部分和顺序部分，因此系统设计时混合使用 GPU 和 CPU，以最大限度地提高整体性能。具有高度并行性的应用程序可以利用 GPU 的大规模并行特性来实现比 CPU 更高的性能 CUDA编程模型 多核CPU和众核GPU的出现意味着主流处理器芯片现在都是并行系统 kernel 核 不同于C语言中函数的调用，CUDA的内核函数调用时需要指定总的线程数量，以及相应的线程布局（grid和block维度配置） // C函数 function_name (argument list); // CUDA kernel call kernel_name&lt;&lt;&lt;4, 8&gt;&gt;&gt;(argument list); // 这里执行有grid中有4个block, 以及每个block中有8个线程运行 限定符 因为数据在全局内存中是线性存储的，所以可以通过blockIdx.x和threadIdx.x来标识grid中的线程，建立线程和数据之间的映射关系
核函数限定符的意义如下
限定符执行调用备注globalDevice执行Host调用/Device调用必须有一个void的返回类型deviceDevice执行Device调用–hostHost执行Host调用– 举例 实现的功能是两个长度为的tensor相加，每个block有1024个线程，一共有n/1024
个block
cudademo.cu #include &lt;iostream&gt; #include &lt;cuda_runtime.h&gt; // 代码的核心诉求(Cuda上运行)： // 输入a: 0,1,2,3,4..... // 输入b: 0,2,4,6,8..... // 输出c: 0,3,6,9,12..... __global__ void my_add_kernel(float* c, const float* a, const float* b, int n) { // 定义核函数 add for (int i = blockIdx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a60beb9ec5b9cb44dd2f6d79453655f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04474934296bb91b3546ea5f4026f96c/" rel="bookmark">
			virtualbox安装时发生严重错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：virtualbox安装时提示发生严重错误
解决方法：
1、进入下载官网
下载 – Oracle VM VirtualBox
2、找到之前的版本，点击下载
Download_Old_Builds_6_1 – Oracle VM VirtualBox
3、下载成功之后，直接安装就行
4、安装好了就可以正常使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/300afc268cf29595a25e708b4d3ab96c/" rel="bookmark">
			Linux的shell的$# | fi | 说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$# | fi | 说明 在Linux的Shell脚本中，$# 是一个特殊变量，表示传递给脚本的参数个数。
例如，如果你运行一个脚本并传递了三个参数，那么在脚本内部使用 $# 将会得到 3。这对于确定脚本在执行时接收到了多少个参数是非常有用的。以下是一个简单的示例：
#!/bin/bash echo "脚本名称: $0" echo "第一个参数: $1" echo "第二个参数: $2" echo "第三个参数: $3" echo "参数个数: $#" 如果你运行这个脚本并传递了三个参数，比如 ./myscript.sh arg1 arg2 arg3，那么输出将会是：
脚本名称: ./myscript.sh 第一个参数: arg1 第二个参数: arg2 第三个参数: arg3 参数个数: 3 这里，$# 的值是传递给脚本的参数的总数。
if test $# = 0 then ls . else for i do ls -l $i | grep '^d' done fi 说明：
在你提供的Shell脚本中，fi 是一个关键字，表示“if”的结束。在Shell脚本中，if 语句的结构是以 fi 结尾的。这是为了标志条件块的结束。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/300afc268cf29595a25e708b4d3ab96c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f412515d2180d9655f735d6dc30b312/" rel="bookmark">
			并发容器ConcurrentHashMap与synchronized联合使用达到线程安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做的项目中遇到一个问题：明明用了ConcurrentHashMap，可是始终线程不安全
除去项目中的业务逻辑，简化后的代码如下：
public class Test40 { public static void main(String[] args) throws InterruptedException { for (int i = 0; i &lt; 10; i++) { System.out.println(test()); } } private static int test() throws InterruptedException { ConcurrentHashMap&lt;String, Integer&gt; map = new ConcurrentHashMap&lt;String, Integer&gt;(); ExecutorService pool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 8; i++) { pool.execute(new MyTask(map)); } pool.shutdown(); pool.awaitTermination(1, TimeUnit.DAYS); return map.get(MyTask.KEY); } } class MyTask implements Runnable { public static final String KEY = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f412515d2180d9655f735d6dc30b312/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50f721e34ca61923066405d969482004/" rel="bookmark">
			Nuxt3数据请求及封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Nuxt3中数据请求方式二、unjs/ofetch库三、请求方式之间的区别1. useAsyncData2. useFetch3. useLazyAsyncData 与 useLazyFetch 四、封装useFetch1. Nuxt3使用技巧①：Composables 目录自动导入②：定义 Runtime Config 公共变量③：定义env环境变量 2. 封装函数3. 调用 总结 前言 这篇文章记录一下Nuxt3网络请求的方法，结合了自己项目的需求对其中的数据请求进行了统一的封装，这样可以统一处理公共的请求逻辑，采用的是Nuxt3自带的useFetch方法。
一、Nuxt3中数据请求方式 Nuxt3提供了多种方法来处理应用程序中的数据获取：
$fetchuseFetchuseLazyFetchuseAsyncDatauseLazyAsyncData 二、unjs/ofetch库 Nuxt3 不推荐也没必要使用Axios进行网络请求，Axios本来是对 XMLHttpRequest 的封装，而现如今网络请求这种功能由 XMLHttpRequest 逐渐被 Fetch API 代替，浏览器已支持原生支持fetch，Node v17.5也引入了对fetch的原生支持。Nuxt3的官方团队将fetch进一步封装，封装的项目叫做ofetch，并且将其集成到Nuxt3中，就是开头提到的$fetch方法。
三、请求方式之间的区别 1. useAsyncData 需要提供一个用于缓存去重的 key 和数据请求的处理函数。
第一个参数是 key，但是即使你不传 key，Nuxt 也会根据文件名和行号帮你生成一个。
const { data, pending, error, refresh } = await useAsyncData( 'mountains', () =&gt; $fetch('https://api.nuxtjs.dev/mountains') ) 2. useFetch useFetch这个可组合函数提供了一个方便的包装器，用于useAsyncData和$fetch。它会自动生成基于URL和fetch选项的键，根据服务器路由提供请求URL的类型提示，并推断API响应类型。
对useFetch的多个调用，建议使用&lt;script setup&gt;，因为它消除了使用顶级等待的限制。
useFetch 是对 useAsyncData 的一层包装，可以理解为所有的都选择默认配置的useAsyncData 方法，useFetch(url)几乎等同于useAsyncData(url, () =&gt; $fetch(url))——它是最常见用例的开发人员语法糖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50f721e34ca61923066405d969482004/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf73cc647c55ee8245c5a5f085360795/" rel="bookmark">
			基于AR技术的城市隐蔽工程查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e021f17df6eeecb0c83db08f90d8f1d7/" rel="bookmark">
			【UG\NX二次开发】判断当前是 建模和装配环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //判断建模和装配环境 bool split_part::is_Assemblies() { Session *thesession = Session::GetSession(); BasePart *basedisplaypart = thesession-&gt;Parts()-&gt;BaseDisplay(); Assemblies::ComponentAssembly *componentAssembly = basedisplaypart-&gt;ComponentAssembly(); Assemblies::Component *rootcomponent = componentAssembly-&gt;RootComponent(); if(rootcomponent == NULL) { return true; } else { return false; } } void mian() { int flag2 = is_Assemblies(); //建模环境 if (flag2 == 1) { //过滤器实体设置 vector&lt;NXOpen::Selection::MaskTriple&gt;masktriple; Selection::MaskTriple mask1(UF_solid_type,0,0); masktriple.push_back(mask1); selection0-&gt;GetProperties()-&gt;SetSelectionFilter("SelectionFilter",Selection::SelectionActionClearAndEnableSpecific,masktriple); selection0-&gt;GetProperties()-&gt;SetEnum("MaximumScope",3); } //装配环境 if (flag2 == 0) { //过滤器组件设置 vector&lt;NXOpen::Selection::MaskTriple&gt;masktriple; Selection::MaskTriple mask1(UF_component_type,0,0); masktriple.push_back(mask1); selection0-&gt;GetProperties()-&gt;SetSelectionFilter("SelectionFilter",Selection::SelectionActionClearAndEnableSpecific,masktriple); selection0-&gt;GetProperties()-&gt;SetEnum("MaximumScope",3); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b21342194e0d56ea0d6daa6d8012fe9/" rel="bookmark">
			Java基于JavaEE的云图书馆（开题&#43;源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系统（程序+源码）带文档lw万字以上 文末可获取一份本项目的java源码和数据库参考。
系统程序文件列表 开题报告内容 研究背景：
随着信息技术的发展，图书馆已经不再是传统意义上的藏书楼，而是向数字化、网络化、智能化方向发展的信息中心。在云计算技术的推动下，图书馆的资源和服务已经逐渐迁移到云端，形成了云图书馆。在这个背景下，基于JavaEE的云图书馆应运而生，它旨在提高图书馆的管理效率和服务质量，满足用户日益增长的个性化阅读需求。
意义：
基于JavaEE的云图书馆的意义在于：首先，它可以通过自动化管理提高图书馆的管理效率，减少人工干预，降低管理成本；其次，它可以通过数字化存储和传输，保护和传承文化遗产，提高图书资源的利用效率；最后，它可以通过网络化服务和智能化推荐，满足用户的个性化阅读需求，提高读者的阅读体验。
目的：
基于JavaEE的云图书馆的主要目的是：构建一个自动化、数字化、网络化、智能化的图书馆管理系统，实现图书资源的统一管理和服务，提高图书馆的管理效率和服务质量。具体来说，它要达到以下目标：1）实现图书信息的数字化存储和传输；2）实现图书资源的网络化共享和服务；3）实现图书借阅的智能化推荐和服务；4）实现图书馆管理的自动化和智能化。
研究内容：
基于JavaEE的云图书馆的研究内容主要包括以下几个方面：1）用户管理系统的设计和实现；2）图书信息管理系统的设计和实现；3）图书类型管理系统的设计和实现；4）申请信息管理系统的设计和实现；5）图书内容管理系统的设计和实现。
拟解决的主要问题：
基于JavaEE的云图书馆拟解决以下主要问题：1）如何实现图书信息的数字化存储和传输；2）如何实现图书资源的网络化共享和服务；3）如何实现图书借阅的智能化推荐和服务；4）如何实现图书馆管理的自动化和智能化。
研究方案：
基于JavaEE的云图书馆的研究方案主要包括以下几个方面：1）采用JavaEE技术构建云图书馆管理系统；2）利用云计算技术实现图书信息的数字化存储和传输；3）利用网络技术实现图书资源的网络化共享和服务；4）利用数据挖掘和机器学习技术实现图书借阅的智能化推荐和服务；5）利用自动化和智能化技术实现图书馆管理的自动化和智能化。
预期成果：
基于JavaEE的云图书馆预期成果主要包括以下几个方面：1）构建一个自动化、数字化、网络化、智能化的图书馆管理系统；2）提高图书馆的管理效率和服务质量；3）满足用户的个性化阅读需求；4）推动图书馆事业的数字化、网络化、智能化发展。
进度安排：
第一阶段： 熟悉工具，查阅相关资料（1周）
第二阶段：分析阶段，确定系统功能及性能等需求（3周）
第三阶段：设计阶段，按照需求分析结果，进行系统概要设计及详细设计（3周）
第四阶段：编程和调试阶段，采用相应语言实现系统，并进行调试及测试（3周）
第五阶段：撰写论文（3周）
第六阶段：准备答辩（1周）
参考文献：
[1]黄志超. Java程序设计课程改革[J]. 电脑知识与技术, 2021, 17 (25): 202-204.
[2]司利平. 浅谈Java在计算机软件开发中的应用[J]. 电脑知识与技术, 2021, 17 (24): 81-82.
[3]徐静. 计算机软件开发中JAVA编程语言及其实际应用[J]. 电子世界, 2021, (09): 204-205.
[4]冯志林. 冯志林. Java EE程序设计与开发实践教程[M]. 机械工业出版社: 202105. 353.
[5]崔慧娟. MVVM模式在Android项目中的应用[J]. 信息与电脑(理论版), 2021, 33 (06): 1-3.
[6]李正伟. 计算机软件JAVA编程特点及其技术运用研究[J]. 软件, 2021, 42 (03): 149-151.
以上是开题是根据本选题撰写，是项目程序开发之前开题报告内容，后期程序可能存在大改动。最终成品以下面运行环境+技术+界面为准，可以酌情参考使用开题的内容。要本源码参考请在文末进行获取！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b21342194e0d56ea0d6daa6d8012fe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7027d3b4e032d308f6dd4a1a4f914e2/" rel="bookmark">
			FPN&#43;PAN结构学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yolo4的neck结构采用该模式，我们将Neck部分用立体图画出来，更直观的看下两部分之间是如何通过FPN结构融合的。
如图所示，FPN是自顶向下的，将高层特征通过上采样和低层特征做融合得到进行预测的特征图。Neck部分的立体图像，看下两部分是如何通过FPN+PAN结构进行融合的。
和Yolov3的FPN层不同，Yolov4在FPN层的后面还添加了一个自底向上的特征金字塔。这样结合操作，FPN层自顶向下传达强语义特征，而特征金字塔则自底向上传达强定位特征，两两联手，从不同的主干层对不同的检测层进行参数聚合,这样的操作确实很皮。
自底向上增强
如上图中所示，FPN是自顶向下，将高层的强语义特征传递下来，对整个金字塔进行增强，不过只增强了语义信息，对定位信息没有传递，而本文就是针对这一点，在FPN的后面添加一个自底向上的金字塔，可以说是很皮了。这样的操作是对FPN的补充，将低层的强定位特征传递上去，个人称之为”双塔战术“。
参考：
https://zhuanlan.zhihu.com/p/143747206utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=667962890661924864&amp;from=singlemessage
https://www.cnblogs.com/wzyuan/p/10029830.html
FPN还是PAN或者后面的BiFPN都是类似的结构。FPN的理念就是增强不同层特征融合，在多尺度上进行预测。PAN在FPN的基础上又加了从下到上的融合。
我们都知道，深层的feature map携带有更强的语义特征，较弱的定位信息。而浅层的feature map携带有较强的位置信息，和较弱的语义特征。FPN就是把深层的语义特征传到浅层，从而增强多个尺度上的语义表达。而PAN则相反把浅层的定位信息传导到深层，增强多个尺度上的定位能力。
FPN的作用
FPN是在卷积神经网络中图像金字塔的应用。图像金字塔在多尺度识别中有重要的作用，尤其是小目标检测。顶层特征上采样后和底层特征融合，每层独立预测。
fpn设计动机：
1.高层特征向低层特征融合，增加低层特征表达能力，提升性能
2.不同尺度的目标可以分配到不同层预测，达到分而治之。
图片
FPN每层做特征融合的特征图有两个，首先是前向传播，然后取了每个特征图做上采样（最近邻插值），对应前向传播的特征图做融合。融合的方式是：通过1x1卷积调整通道数，然后直接add。之后进行3x3卷积操作，目的是消除上采样的混叠效应。
其实，fpn真正起作用的是分而治之的策略，特征融合的作用其实很有限，此外fpn存在消耗大量显存，降低推理速度。
为什么FPN采用融合以后效果要比使用pyramidal feature hierarchy这种方式要好？
图片
卷积虽然能够高效地向上提取语义，但是也存在像素错位问题，通过上采样还原特征图很好地缓解了像素不准的问题。
backbone可以分为浅层网络和深层网络，浅层网络负责提取目标边缘等底层特征，而深层网络可以构建高级的语义信息，通过使用FPN这种方式，让深层网络更高级语义的部分的信息能够融合到稍浅层的网络，指导浅层网络进行识别。
从感受野的角度思考，浅层特征的感受野比较小，深层网络的感受野比较大，浅层网络主要负责小目标的检测，深层的网络负责大目标的检测（比如人脸检测中的SSH就使用到了这个特点）。再联想后来的BiFPN，语义特征和定位信息在串联的FPN/PAN结构中被像踢皮球一样的“传来传去”…
————————————————
最后说一下全连接作用：全连接层其实可由卷积实现，可看作感受野为整个特征图的卷积核，所以全连接层是感受野更大的卷积，另外，这里的卷积参数不共享，每个像素点拥有一个卷积核，
FPN在RPN中的应用
rpn在faster rcnn中用于生成proposals，原版rpn生成在每个image的最后一张特征图上生成3x3个proposal。但实际上，小目标下采样到最后一个特征图，已经很小了。fpn可以在之前的多个特征图上获得proposal，具体做法是：在每个feature map上获得1:1、1:2、2:1长宽比的框，尺寸是{322、642、1282、2562、512^2}分别对应{P2、P3、P4、P5、P6}这五个特征层上。P6是专门为了RPN网络而设计的，用来处理512大小的候选框。它由P5经过下采样得到。
如何解决小目标识别问题
通用的定义来自 COCO 数据集(https://so.csdn.net/so/search%3Fq%3D%25E6%2595%25B0%25E6%258D%25AE%25E9%259B%2586%26spm%3D1001.2101.3001.7020)，定义小于 32x32 pix 的为小目标。
小目标检测的难点：可利用特征少，现有数据集中小目标占比少，小目标聚集问题
首先小目标本身分辨率低，图像模糊，携带的信息少。由此所导致特征表达能力弱，也就是在提取特征的过程中，能提取到的特征非常少，这不利于我们对小目标的检测。
另外通常网络为了减少计算量，都使用到了下采样，而下采样过多，会导致小目标的信息在最后的特征图上只有几个像素（甚至更少），信息损失较多。
1 数据。
提高图像采集的分辨率：基于 GAN 的方法解决的也是小目标本身判别性特征少的问题，其想法非常简单但有效：利用 GAN 生成高分辨率图片或者高分辨率特征。
2 Data Augmentation。一些特别有用的小物体检测增强包括随机裁剪、随机旋转和马赛克增强。copy pasting， 增加小目标数量。缩放与拼接，增加中小目标数量
3 修改模型输入尺寸。提高模型的输入分辨率，也就是减少或者不压缩原图像。tiling，将图像切割后形成batch，可以在保持小输入分辨率的同时提升小目标检测，但是推理时也需要 tiling，然后把目标还原到原图，整体做一次 NMS。
4 修改 Anchor。适合小目标的 Anchor
5 Anchor Free。锚框设计难以获得平衡小目标召回率与计算成本之间的矛盾，而且这种方式导致了小目标的正样本与大目标的正样本极度不均衡，使得模型更加关注于大目标的检测性能，从而忽视了小目标的检测。
6 多尺度学习。FPN， 空洞卷积，通过多尺度可以将下采样前的特征保留，尽量保留小目标
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7027d3b4e032d308f6dd4a1a4f914e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/377c4158e91725f25193097c18a90366/" rel="bookmark">
			3C电子产品如何做跨境电商独立站？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、3C电子产品市场分析
3C电子产品一直以来是跨境电商领域里的红海类目，在各大平台长期占据着热销类目的前几位，但其庞大的用户群体仍然吸引了各路卖家入局。我国3C产品出口，不仅有供应链的优势，还有价格的优势。此外随着我国科技的不断突破，技术层面的短板也得到了弥补。
除了国内卖家自身的优势以外，庞大的市场需求，同样是3C产品频频爆单的原因之一。数据显示全球消费电子线上销售额在2018年超过2800亿美元，预计在2023年将会达到4060亿美元。基数大增长还快，足以可见这其中的市场有多广阔。
在跨境电商行业中，3c品类是比较火爆的，所以不少人参加跨境电商后第一个做的类目就是3c，3C产品体积小、质量轻、单价高，同样是独立站卖家的上佳之选，但是火爆的3c想要做好也不是那么容易，由于你要选好一个单品，这样才干在竞争中脱颖而出，那么3C产品独立站该怎么做？如何搭建独立站？有什么需要注意的地方吗？
二、选品
3C产品有很多，包括手机、智能手表、扫描仪等等。3C产品有卖的特别好的，自然也有经营惨淡的，所以选品是决定独立站经营成败的关键性因素之一。
近几年手机销量持续上涨，手机配件的需求也越发旺盛，手机配件会是卖家一个相当不错的选择。
其次随着智能穿戴设备（智能手表、智能眼镜等等）技术的成熟、功能的完善、价格的趋平化，销量也在逐渐上升。
最后家用办公设备也是近两年3C产品的热门品类，在疫情期间，大多数人被迫居家办公，家用办公设备就成为了刚需。比如说蓝牙键盘、打印机、扫描仪、电脑硬件等等。此外居家办公或许会成为海外热门趋势，因此这部分的市场需求是不容小觑的。
选品时需要考虑的因素
1、该品类在该地区的市场需求
市场潜力大、利润率高，利润率基本在50以上，甚至100%以上。
2、便于运输
小体积、轻重量、易包装、不易破碎的商品，例如手机壳、手机支架等，能显著降低物流成本和货物损坏率。
3、售后简单
不需要售后服务或简化售后服务的商品可以降低后期客服成本。
4、附加值高
对于价值低于运费的商品，可以考虑以打包方式销售，以降低物流成本。
5、具备独特性
独特的功能或商品设计，如独特的研发和包装设计，可以不断激发买家的好奇心和购买欲望。
6、价格合理
不用高于目的国当地市场价或偏高于其它在线卖家。
7、合规合法
卖家在选品时要遵守平台规定和目的国法律法规，严禁销售盗版、仿冒或违禁品，并要确保所销售的产品不侵权。
8、了解该品类的火热程度
刚入局的卖家，建议太火的产品先别做，因为同行业竞争很激烈，也不能做“最先吃螃蟹的人”，会产生更多试错成本，最重要的是要对目标市场营销日历以及商品流行程度要有把握。
三、建站
3C产品，品牌溢价高，消费者忠诚度高。搭建品牌独立站，实施品牌化运营，对于卖家未来长远发展是非常有利的。
四、物流
3C产品物流方面是比较复杂的，如果是纯电池电子产品，比如说充电宝、锂电池等等。因为运输风险较大，所以并非所有的物流渠道都会承接的。特定的电池渠道以及专线物流才可以邮寄纯电池产品。
卖家需要根据自己的产品，然后去查询可承接的物流。此外3C产品需要的材料证明也较为复杂，包括3C认证、产品信息表等等，卖家也需要一一准备好。由于电子产品价值较高，而跨国运输过程较为辗转，物品损坏概率较高，所以规范化的产品包装非常重要。
3c产品本身就是一个大家会选购的热门产品，也就对于做独立站来说是非常有利的。所以在做独立站的时候，大家可以对3c这类的产品进行思考一下。
3C产品一直是跨境电商的热门项目，也是大多数刚入行的跨境卖家的首选项目。因此竞争也较为激烈，卖家一方面要在选品上多花心思，尽量选择一个竞争不那么激烈，但仍有市场需求的产品，另一方面则需要通过精细化运营来获得长远发展。
如今国内的3c产品链是比较完善的，所以假如你想要做好跨境电商的3c类目，建议去华强北那里进行市场调研，就能轻松知道哪些单品火爆了。
想要了解更多独立站建站详情，可以添加小编沟通咨询~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c261b19c41ff3007cca914427fb2b44/" rel="bookmark">
			视觉大模型DINOv2:自我监督学习的新领域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 DINOv2 1.1 DINOv2特点 前段时间，Meta AI 高调发布了 Segment Anything（SAM），SAM 以交互式方式快速生成 Mask，并可以对从未训练过的图片进行精准分割，可以根据文字提示或使用者点击进而圈出图像中的特定物体，其灵活性在图像分割领域内属首创。
但是，归根到底 SAM 是一个promptable segmentation system，主要应用于各种分割任务，对其他的视觉任务（e.g. Classification, Retrieval,VQA...）的帮助没有那么直接。
于是，在继[分割一切]，Meta AI 再次发布重量级开源项目——DINOv2，DINOv2 可以抽取到强大的图像特征，且在下游任务上不需要微调，这使得它适合作为许多不同的应用中新的 BackBone。
Meta开源DINOv2视觉大模型，无需微调，效果惊人！在人工智能研究领域，Meta再次引发了轰动！DINOv2，全称为”Dual-Stage Implicit Object-Oriented Network”，是一种基于Transformer的视觉模型。它采用了全新的双阶段训练方法，有效地将图像分类和对象检测任务结合起来。与以往的视觉模型相比，DINOv2具有更高的准确性和更快的推理速度。
无需微调就能达到卓越性能，使得DINOv2在易用性和灵活性方面具有巨大优势。在大多数情况下，模型一经训练，就能直接应用于各种实际场景。这不仅降低了模型的运行成本，同时也大大缩短了开发周期。对于那些需要处理海量图像和视频的应用领域，比如自动驾驶、智能监控和人脸识别等，DINOv2无疑将成为强大的解决方案。
与之前发布的 Segment Anything 相比，DINOv2 在应用领域和适用范围上更加广泛，文中的实验也涵盖了多个 CV中经典的下游任务。
在 Meta AI 官方的Blog中，将 DINOv2 的特性总结如下：
DINOv2 是一种训练高性能计算机视觉模型的新方法。DINOv2 提供了强大的性能，并且不需要微调。由于是自监督( self-supervision)，DINOv2 可以从任何图像集合中学习。同时，它还可以学习到当现有方法无法学习的某些特征，例如深度估计。 DINOv2 是一种新的高性能计算机视觉模型训练方法，使用自监督学习来实现与该领域中使用的标准方法相匹配或超越结果。与其他自监督系统一样，使用 DINOv2 方法的模型可以在不需要任何相关元数据的情况下对任何图像集合进行训练。这意味着它可以从它所接收到的所有图像中学习，而不仅仅是那些包含特定一组标签或 alt 文本或标题的图像。DINOv2 提供了可直接用作简单线性分类器输入的高性能特征。这种灵活性意味着 DINOv2 可用于创建许多不同计算机视觉任务的多用途骨干。
文中的实验展示了 DINOv2 在下游任务上的出色能力，例如分类、分割和图像检索等应用领域。其中，最令人惊讶的是，在深度估计方面，DINOv2 的结果明显优于 in-domain 与 out-of-domain 的 SOTA 的 pipeline。作者认为这种强大的域外表现是自监督特征学习和轻量级任务特定模块（例如线性分类器）相结合的结果。
最后，由于不采用 fine-tuning，骨干保持通用，同一特征可以同时用于许多不同任务。
论文地址：https://arxiv.org/pdf/2304.07193.pdf
代码地址：https://github.com/facebookresearch/dinov2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c261b19c41ff3007cca914427fb2b44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe05c36025a3f0648d24c78f44f6b3d/" rel="bookmark">
			ArkTS开发实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明式UI基本概念 应用界面是由一个个页面组成，ArkTS是由ArkUI框架提供，用于以声明式开发范式开发界面的语言。
声明式UI构建页面的过程，其实是组合组件的过程，声明式UI的思想，主要体现在两个方面：
描述UI的呈现结果，而不关心过程状态驱动视图更新 类似苹果的SwiftUI中通过组合视图View，安卓Jetpack Compose中通过组合@Composable函数，ArkUI作为HarmonyOS应用开发的UI开发框架，其使用ArkTS语言构建自定义组件，通过组合自定义组件完成页面的构建。
自定义组件的组成 ArkTS通过struct声明组件名，并通过@Component和@Entry装饰器，来构成一个自定义组件。
使用@Entry和@Component装饰的自定义组件作为页面的入口，会在页面加载时首先进行渲染。
@Entry @Component struct ToDoList {...} 例如ToDoList组件对应如下整个代办页面。
图1 ToDoList待办列表
使用@Component装饰的自定义组件，如ToDoItem这个自定义组件则对应如下内容，作为页面的组成部分。
@Component struct ToDoItem {...} 图2 ToDoItem
在自定义组件内需要使用build方法来进行UI描述。
@Entry @Component struct ToDoList ... build() { ... } } build方法内可以容纳内置组件和其他自定义组件，如Column和Text都是内置组件，由ArkUI框架提供，ToDoItem为自定义组件，需要开发者使用ArkTS自行声明。
@Entry @Component struct ToDoList { ... build() { Column(...) { Text(...) ... ForEach(...{ TodoItem(...) },...) } ... } } 配置属性与布局 自定义组件的组成使用基础组件和容器组件等内置组件进行组合。但有时内置组件的样式并不能满足我们的需求，ArkTS提供了属性方法用于描述界面的样式。属性方法支持以下使用方式：
常量传递例如使用fontSize(50)来配置字体大小。 Text('Hello World') .fontSize(50) 变量传递在组件内定义了相应的变量后，例如组件内部成员变量size，就可以使用this.size方式使用该变量。 Text('Hello World') .fontSize(this.size) 链式调用在配置多个属性时，ArkTS提供了链式调用的方式，通过'.'方式连续配置。 Text('Hello World') .fontSize(this.size) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fe05c36025a3f0648d24c78f44f6b3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96da040f6fb946506a546b7fb1e84ab5/" rel="bookmark">
			【Mac开发环境搭建】安装HomeBrew、HomeBrew安装Docker、Docker安装Mysql5.7和8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 HomeBrew安装相关命令安装包卸载包查询可用的包更新所有包更新指定包查看已经安装的包查看包的信息清理包查看brew的版本更新brew获取brew的帮助信息 Brew安装DockerDocker常用命令镜像相关查看已经拉取的所有镜像删除镜像 容器相关命令停止运行容器启动容器重启容器删除容器查看正在运行的容器查看所有容器（包括不在运行的容器）查看容器的日志 Docker安装Mysql5.7拉取镜像创建容器连接mysql容器方式一：进入容器控制台方式二：直接连接 mysql配置文件 安装Mysql8拉取镜像创建并启动容器 HomeBrew 安装 科大源安装
$ /bin/bash -c "$(curl -fsSL https://gitee.com/ineo6/homebrew-install/raw/master/install.sh)" 卸载
$ /bin/bash -c "$(curl -fsSL https://gitee.com/ineo6/homebrew-install/raw/master/uninstall.sh)" 相关命令 安装包 brew install 包名 卸载包 brew uninstall 包名 查询可用的包 brew search 包名 更新所有包 brew upgrade 更新指定包 brew upgrade 包名 查看已经安装的包 brew list 查看包的信息 brew info 包名 清理包 # 查看哪些软件包要被清除 $ brew cleanup -n # 清除指定软件包的所有老版本 $ brew cleanup 软件名 # 清除所有软件包的所有老版本 $ brew cleanup 查看brew的版本 brew -v 更新brew brew update 获取brew的帮助信息 brew -h Brew安装Docker brew install --cask --appdir=/Applications docker 安装完成之后，双击Docker图标即可运行Docker
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96da040f6fb946506a546b7fb1e84ab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce1f3309360d53994d6d80c2d7182055/" rel="bookmark">
			在使用Vuex时，5个方法让你保证数据的更新及时性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤍 前端开发工程师（主业）、技术博主（副业）、已过CET6
🍨 阿珊和她的猫_CSDN个人主页
🕠 牛客高级专题作者、在牛客打造高质量专栏《前端面试必备》
🍚 蓝桥云课签约作者、已在蓝桥云课上架的前后端实战课程《Vue.js 和 Egg.js 开发企业级健康管理项目》、《带你从入门到实战全面掌握 uni-app》
文章目录 1. 使用`mutation`方法2. 使用`action`方法3. 使用`watcher`方法4. 使用`subscribe`方法5. 使用`Vuex 的模块` 在使用 Vuex 时，可以通过以下几种方式来保证数据的更新及时性：
1. 使用mutation方法 mutation方法是 Vuex 中用于修改状态数据的方法。在mutation方法中，只能执行同步操作，不能使用异步操作。这样可以保证mutation方法的执行顺序，避免因为异步操作导致的数据不一致问题。
mutation 方法的使用方式如下：
mutations: { increment(state) { state.count++; } } 在上面的示例中，increment 方法接受一个 state 参数，用于对状态数据进行修改。在 increment 方法中，我们将状态数据 count 的值增加 1。
在组件中使用mutation 方法的方式如下：
this.$store.commit('increment'); 在上面的示例中，$store 对象是 Vuex 中的全局状态对象，commit 方法用于触发mutation 方法。increment 是mutation 方法的名称，根据实际情况可以替换为其他的mutation 方法名称。
需要注意的是，mutation 方法只能用于修改状态数据，不能用于获取状态数据。如果需要获取状态数据，可以使用 getter 方法。
2. 使用action方法 action方法是 Vuex 中用于执行异步操作的方法。在action方法中，可以使用异步操作来修改状态数据。在action方法中修改状态数据时，需要使用mutation方法来提交修改，这样可以保证数据的一致性。
action 方法的使用方式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce1f3309360d53994d6d80c2d7182055/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d69494316f73f4e16da1a82c84955a/" rel="bookmark">
			（三）正点原子I.MX6ULL kernel6.1挂根文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 移植NXP官方最新的linux kernel（linux-imx-lf-6.1.y）
移植方法基本参照正点原子教程
移植开发板：正点原子阿尔法2.1
二、添加开发板到内核 进入内核目录下，先修改Makefile
打开终端：
cp arch/arm/configs/imx_v7_defconfig arch/arm/configs/imx_alientek_defconfig cp arch/arm/boot/dts/imx6ull-14x14-evk.dts arch/arm/boot/dts/imx6ull-alientek.dts cp arch/arm/boot/dts/imx6ul-14x14-evk.dtsi arch/arm/boot/dts/imx6ull-alientek.dtsi 打开arch/arm/boot/dts/Makefile，在第778行找到：
imx6ull-14x14-evk.dtb \ 在它下一行添加我们的设备树
imx6ull-14x14-evk.dtb \ imx6ull-alientek.dtb \ 三、修改设备树 在imx6ull-alientek.dts里可以改model和compatible：
/ { model = "I.MX6ULL Alientek ALPHA"; compatible = "imx6ull alientek", "fsl,imx6ull"; }; 把include改成我们的文件：
// #include "imx6ul-14x14-evk.dtsi" #include "imx6ull-alientek.dtsi" 打开imx6ull-alientek.dtsi，这里是移植修改设备树的主阵地
找到fec2，修改后如下：
&amp;fec2 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;pinctrl_enet2&gt;; phy-mode = "rmii"; phy-handle = &lt;&amp;ethphy1&gt;; phy-supply = &lt;&amp;reg_peri_3v3&gt;; status = "okay"; mdio { #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; ethphy0: ethernet-phy@0 { compatible = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1d69494316f73f4e16da1a82c84955a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9915155620116c5d1daff286621bc12f/" rel="bookmark">
			ubuntu部署k8s
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
提前安装
一. 修改 ubuntu 配置
关闭 swap 内存
配置免密登录
二. 安装 docker
docker 的安装
docker 的配置
三. 安装 k8s
四. 安装 master 节点
初始化 master 节点
配置 kubectl 工具
部署 flannel 网络
五. 将 slave 节点加入网络
默认网卡问题修复
修改 kubelet 默认地址
修改 flannel 的默认网卡
重置节点
常见问题
总结
参考
要注意，对于1.24之上的k8s版本，默认使用安装是contained，要使用docker需要另外安装cri
提前安装 apt-get install -y curl &amp;&amp; apt-get install -y vim 一. 修改 ubuntu 配置 首先，k8s 要求我们的 ubuntu 进行一些符合它要求的配置。
1.关闭 Swap 内存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9915155620116c5d1daff286621bc12f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f43c4752ce904fe8c7f9e9da5fc4f47b/" rel="bookmark">
			如何判断从本机上传到服务器的文件数据内容是一致的？用md5加密算法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题场景 最近在帮导师做横向，我想把整个项目环境放到服务器中，需要把一个很大的数据文件传到服务器，传上去很方便，但是涉及到文件的压缩上传和服务器内解压环节，不是太确定文件在本机和服务器的数据内容是否一致。
解决思路 可以利用md5算法，全称是Message-Digest Algorithm 5，即信息摘要算法。
md5算法有以下特点：
压缩性：任意长度的数据，算出的MD5值长度都是固定的。容易计算：从原数据计算出MD5值很容易。抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 实现步骤 假定本机是windows环境，服务器为linux环境。
在本机上打开powershell（ 一定得是powershell打开，不能是简单的cmd）到需要检验是否一致的文件所在目录输入GetFile-Hash + 文件名，得到md5算法加密后的序列
在服务器上，到需要检验是否一致的文件所在目录输入sha256sum + 文件名，得到md5算法加密后的序列
对比本机和服务器上得到的md5加密序列，如果一模一样（忽略大小写），则数据内容是一致的，如果有任何地方存在不一样的，则数据内容不完全一致。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe3ce65430472d0e1602d552a6840ea/" rel="bookmark">
			hive和spark-sql中 日期和时间相关函数 测试对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试版本： hive 2.3.4 spark 3.1.1 hadoop 2.7.7
1、增加月份 add_months(timestamp date, int months)add_months(timestamp date, bigint months)Return type: timestampusage:add_months(now(),1) 2、增加日期 adddate(timestamp startdate, int days),adddate(timestamp startdate, bigint days)Return type: timestampusage:adddate(now(),1) 3、当前时间戳 current_timestamp()和now()等价 4、日期相减 datediff(string enddate, string startdate)Return type: intusage:datediff("2018-08-05", "2018-08-03") 5、得到天，得到月份 day(string date)Return type: intusage: day("2018-08-05") 6、得到星期英文 dayname(string date)Return type: stringusage:dayname("2018-08-05") Sunday 7、得到这一天是这周的第几天 dayofweek(string date) 1 (Sunday) to 7 (Saturday).Return type: intusage:dayofweek("2018-08-06") 8、加天数和减天数 1）days_add(timestamp startdate, int days)
Return type: timestampusage:days_add(now(),2) 2）、days_sub(timestamp startdate, int days)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fe3ce65430472d0e1602d552a6840ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b361cc19603270b4bf25c73f5f51cd52/" rel="bookmark">
			CIFAR-100数据集的加载和预处理教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CIFAR-100数据集介绍 CIFAR-100（Canadian Institute for Advanced Research - 100 classes）是一个经典的图像分类数据集，用于计算机视觉领域的研究和算法测试。它是CIFAR-10数据集的扩展版本，包含了更多的类别，用于更具挑战性的任务。
CIFAR-100包含了100个不同的类别，每个类别都包含600张32x32像素的彩色图像。
这100个类别被划分为20个大类别，每个大类别包含5个小类别。这个层次结构使得数据集更加丰富，包含了各种各样的对象和场景。每张图像的大小是32x32像素，包含RGB三个通道。
用途： CIFAR-100常被用于评估图像分类算法的性能。由于图像分辨率相对较低，它在实际中可能不太适用于一些复杂的计算机视觉任务，但对于学术研究和算法开发而言是一个常见的基准数据集。
二、下载并加载CIFAR-100数据集 import torch from torch.utils.data import Dataset,DataLoader import torchvision import torchvision.transforms as transforms def get_train_loader(mean, std, batch_size=16, num_workers=2, shuffle=True): transform_train = transforms.Compose([ transforms.RandomCrop(32, padding=4), transforms.RandomHorizontalFlip(), transforms.RandomRotation(15), transforms.ToTensor(), transforms.Normalize(mean, std) ]) cifar100_training = torchvision.datasets.CIFAR100(root='./data', train=True, download=True, transform=transform_train) cifar100_training_loader = DataLoader( cifar100_training, shuffle=shuffle, num_workers=num_workers, batch_size=batch_size) return cifar100_training_loader def get_val_loader(mean, std, batch_size=16, num_workers=2, shuffle=True): transform_test = transforms.Compose([ transforms.ToTensor(), transforms.Normalize(mean, std) ]) cifar100_test = torchvision.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b361cc19603270b4bf25c73f5f51cd52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd5d13c269ab1c4a8bf3ad902629d5c0/" rel="bookmark">
			毕业设计：基于java的俄罗斯方块游戏系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java的俄罗斯方块游戏系统设计与实现
I. 引言 A.研究背景和动机 基于Java的俄罗斯方块游戏系统设计与实现的研究背景和动机
随着计算机技术的不断发展和普及，游戏作为一种娱乐方式得到了广泛的应用。而俄罗斯方块作为一款经典的游戏，已经成为了游戏开发领域的经典案例。然而，传统的俄罗斯方块游戏系统存在着很多问题，如操作繁琐、游戏难度大、游戏界面单一等。为了解决这些问题，基于Java的俄罗斯方块游戏系统设计与实现成为了一个重要的研究方向。
研究背景：
游戏难度大：传统的俄罗斯方块游戏系统存在着操作繁琐、游戏难度大、游戏界面单一等问题，导致用户体验不佳。游戏界面单一：传统的俄罗斯方块游戏系统界面过于单一，无法满足用户多样化的需求。游戏体验不佳：传统的俄罗斯方块游戏系统存在着操作繁琐、游戏难度大、游戏界面单一等问题，导致用户体验不佳。
研究动机：提高游戏体验：基于Java的俄罗斯方块游戏系统可以提供更加流畅、流畅的游戏体验，让用户更加愉悦地享受游戏。优化游戏难度：基于Java的俄罗斯方块游戏系统可以提供更加人性化的游戏难度，让用户更加容易上手。提升游戏趣味性：基于Java的俄罗斯方块游戏系统可以提供更加丰富的游戏界面和动画效果，让用户更加喜欢这个游戏。
基于以上研究背景和问题现状，进行基于Java的俄罗斯方块游戏系统设计与实现的毕业设计具有以下动机：提高游戏体验：基于Java的俄罗斯方块游戏系统可以提供更加流畅、流畅的游戏体验，让用户更加愉悦地享受游戏。优化游戏难度：基于Java的俄罗斯方块游戏系统可以提供更加人性化的游戏难度，让用户更加容易上手。提升游戏趣味性：基于Java的俄罗斯方块游戏系统可以提供更加丰富的游戏界面和动画效果，让用户更加喜欢这个游戏。
此外，随着游戏产业的不断发展和用户需求的不断变化，基于Java的俄罗斯方块游戏系统设计与实现也有着广泛的应用前景。通过不断优化和完善游戏系统，可以为用户提供更加优质的游戏体验，并推动游戏产业的发展。 B.目标和意义 基于Java的俄罗斯方块游戏系统设计与实现的目标是提供一个简单、有趣、易于上手的俄罗斯方块游戏解决方案，旨在为用户提供一种娱乐方式和游戏体验。具体而言，目标包括：
简单易学：通过系统的设计与实现，保证用户能够轻松上手并快速掌握游戏规则和操作方法。流畅性：系统的设计应尽可能减少卡顿和延迟，以保证用户的游戏体验。趣味性：游戏系统应具备趣味性和挑战性，以吸引用户的兴趣和参与度。社交性：系统应支持玩家之间的交流和互动，为用户提供社交和分享的平台。兼容性：系统应能够兼容不同的操作系统和设备，为用户提供便捷的游戏体验。
基于Java的俄罗斯方块游戏系统设计与实现的意义在于提供一种娱乐方式和游戏体验，可以为用户带来放松和娱乐的时光，同时也可以为用户提供学习和实践软件开发技术的机会。在设计过程中，需要考虑到用户的需求和体验，设计出简单、有趣、易于上手的游戏系统，以满足用户的基本游戏需求。此外，在开发过程中，需要注重游戏的流畅性和稳定性，保证用户的游戏体验和游戏的可持续发展。同时，在社交性和兼容性方面，需要考虑到用户的社交需求和不同设备的兼容性，为用户提供更好的游戏体验。 II. 相关技术和工具 A.Java语言 Java语言是一种面向对象的高级编程语言，由Sun Microsystems（现在是Oracle公司）于1995年发布。它被设计成可移植、可靠、安全和简单易学的语言，以及具有优秀的性能和高效的垃圾回收机制。Java语言拥有许多特点和优势，下面是一些主要特点的介绍：
简单易学：Java语言借鉴了C++语法，但摒弃了C++中的复杂和容易出错的部分。它具有清晰、简洁的语法，易于学习和理解。跨平台性：Java程序是一次编写，到处运行。Java程序在编译后生成的字节码可以在任何支持Java虚拟机（JVM）的平台上运行，而不需要重新编译。面向对象：Java语言是一种真正的面向对象编程语言，具有封装、继承和多态等面向对象的概念和特征。这使得Java具有更好的结构化、可读性和可维护性。内存管理：Java具有自动垃圾回收机制，程序员无需手动管理内存。通过垃圾回收器，Java可以自动识别并回收不再使用的内存资源，避免了内存泄漏和野指针等问题。多线程支持：Java提供了强大的多线程支持，使得程序能够同时执行多个任务。多线程可以提高程序的性能和响应能力。丰富的类库和API：Java拥有众多的类库和应用程序接口（API），包括各种功能和领域所需的类和方法。这些类库和API极大地简化了程序开发工作，提高了开发效率。安全性：Java对安全性有着很高的重视，在设计上考虑了各种安全因素，如通过字节码验证、安全管理器等机制来防止恶意代码的执行。分布式计算：Java提供了强大的网络编程功能，使其成为构建分布式计算应用和网络服务的理想语言。
总的来说，Java语言是一种通用的、高效的、可移植的编程语言，具有强大的功能和良好的安全性。它在各个领域得到广泛应用，特别在Web开发、移动应用开发和企业应用开发领域占据主导地位。同时，Java语言还是学习编程和软件开发的理想选择，因为它的易学性和广泛的应用使得学习资源丰富且机会多样。 B.数据库技术 数据库技术是一种用于存储、管理和操作数据的软件系统。数据库技术是指应用于设计、开发和管理数据库的一系列技术和方法。数据库技术与数据结构、数据管理、数据模型和数据库系统有关，它对于数据的组织、存储、检索和保护具有重要的作用。数据库技术可以分为以下几个方面：
数据库管理系统（DBMS）：
DBMS是一种软件工具，用于管理和操作数据库。它提供了定义、创建、修改和访问数据库的功能。DBMS可以实现数据的添加、删除、查询和更新操作，还可以提供数据安全性保护、事务管理、并发控制等功能。数据模型：
数据模型是描述和组织数据的形式化表示。常见的数据模型包括层次模型、网状模型、关系模型和对象模型等。关系模型是最常用的数据模型，它将数据组织成表格形式，通过定义表格之间的关系来表示数据之间的联系。数据库设计：
数据库设计是指在数据库系统中创建数据库的过程。它涉及到确定数据的结构、属性、关系和约束等。良好的数据库设计可以提高数据查询和操作的效率，减少数据冗余和不一致性。数据库查询语言：
数据库查询语言是用于查询和操作数据库的语言。常见的查询语言包括结构化查询语言（SQL）和面向对象的查询语言（OQL）。通过查询语言，用户可以方便地对数据库进行查询、过滤、排序等操作。数据库索引：
数据库索引是一种用于加速查询操作的数据结构。它可以帮助数据库系统快速定位需要查询的数据。常见的索引结构包括B树索引、哈希索引和全文索引等。数据库事务：
数据库事务是一系列对数据库的操作，它要么全部执行成功，要么全部回滚。事务可以确保数据库操作的原子性、一致性、隔离性和持久性。数据库安全性：
数据库安全性是指保护数据库免受非法访问、损坏和数据泄露的能力。数据库系统提供了用户身份验证、权限管理和数据加密等安全机制，以确保数据的完整性和机密性。数据库备份与恢复：
数据库备份与恢复是保护数据库免受数据丢失和系统故障的措施。数据库备份可以将数据库的副本保存到其他存储设备中，以防止数据损坏。当数据库出现故障时，可以通过恢复机制还原数据库到之前的状态。数据库性能优化：
数据库性能优化是提高数据库系统的查询和操作效率的过程。通过设计良好的数据库结构、优化查询语句和配置合理的索引，可以提高数据库的响应速度和吞吐量。 C.GUI技术 GUI技术是指通过图形化界面与用户进行交互的一种技术。它使用户能够以直观、便捷的方式与计算机程序进行交互，而无需记住复杂的命令或文本操作。GUI技术已成为现代计算机系统中广泛使用的一种人机交互方式，它为使用者提供了友好的操作界面，从而提高了用户的工作效率和生活品质。GUI技术可以分为多个子领域，包括窗口、菜单、对话框、图标、按钮、文本框、标签、列表、下拉框、图像、树形结构等。GUI技术的发展历程可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——GEOS（Graphical Environment Oriented Operating System）。GUI技术最早可以追溯到20世纪60年代，当时出现了第一款图形化操作系统——Windows。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd5d13c269ab1c4a8bf3ad902629d5c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/942af74bdf2fe6fad02ad3cdf08ba1d4/" rel="bookmark">
			第三次作业操作系统补充题答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三次作业补充题答案 第五章 1. 桌上有一空盘，最多允许存放一只水果。爸爸可向盘中放一个苹果或放一个桔子，儿子专等吃盘中的桔子，女儿专等吃苹果。
​ 试用semWait、semSignal操作实现爸爸、儿子、女儿三个并发进程的同步。
提示：设置一个信号量表示可否向盘中放水果，一个信号量表示可否取桔子，一个信号量表示可否取苹果。
下面是一个简化版本的C++代码，使用std::mutex和std::condition_variable进行同步操作，以满足爸爸、儿子、女儿三个并发进程的需求。
#include &lt;iostream&gt; #include &lt;thread&gt; #include &lt;mutex&gt; #include &lt;condition_variable&gt; std::mutex mtx; std::condition_variable cv; char fruit; void father() { while (true) { std::unique_lock&lt;std::mutex&gt; lock(mtx); // 随机选择放入桔子或苹果 fruit = (rand() % 2 == 0) ? 'O' : 'A'; std::cout &lt;&lt; "爸爸放入了一个" &lt;&lt; ((fruit == 'O') ? "桔子" : "苹果") &lt;&lt; std::endl; // 通知儿子或女儿可以取水果了 cv.notify_all(); // 等待儿子或女儿吃完 cv.wait(lock); } } void child(const std::string&amp; name, char targetFruit) { while (true) { std::unique_lock&lt;std::mutex&gt; lock(mtx); // 等待可以取对应水果的通知 cv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/942af74bdf2fe6fad02ad3cdf08ba1d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e90bcc8263b0ad234b412e8ef0968a9b/" rel="bookmark">
			基于单片机的空调智能控制器的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**单片机设计介绍，基于单片机的空调智能控制器的设计
文章目录 一 概要二、功能设计设计思路 三、 软件设计原理图 五、 程序六、 文章目录 一 概要 基于单片机的空调智能控制器需要具备输入输出端口、定时器、计数器等模块，以便对空调进行精确控制。下面是一个基于单片机的空调智能控制器的设计介绍：
拟定设计需求：确定控制器的功能需求，包括控制模式、控制温度、定时开关机等
选型：根据需求选择合适的单片机，同时确定需要使用的传感器、执行器、显示器、按键等配件
电路设计：根据选型的单片机和配件，设计电路图，包括电源模块、通信模块、读取传感器模块、控制执行器模块等
PCB 设计：将电路图转化为 PCB 图纸，确定线路走向、引脚排列等
焊接和组装：将 PCB 板焊接和组装完整的控制器电路
调试和测试：按照需求进行编程，进行调试和测试，确保控制器的功能正常实现
加入外部操作界面：设计师可以在设计控制器的过程中，将控制器的部分功能加入串口、wifi等模块，以便用户通过外部操作界面进行远程操控。
以上是基于单片机的空调智能控制器的设计步骤，设计人员可以针对具体的需求加以调整。
二、功能设计 设计任务及具体内容 本课题要求通过WIFI控制空调的温度，包括控制器和模拟空调两部分。首先控制器部分由按键、单片机和WIFI模块组成，通过按键将信息发送给单片机，经由单片机处理后传输到WIFI模块。WIFI模块将信息发送到模拟空调部分，由模拟空调部分的WIFI模块接收信息，经单片机处理后，在液晶显示屏上显示当前控制的温度。提交作品实物+毕业设计论文。
2.功能
l 控制器部分：按开/关按键（2个按键）后，模拟空调部分的液晶显示器亮，并显示默认设置温度(如26度)。通过“上”“下”按键控制温度的升降，温度控制范围为16-30度，低于16度和超过30度将不进行任何操作。
l 模拟空调部分：每次调节温度的时候，液晶显示屏显示控制的温度。
设计思路 设计思路
文献研究法：搜集整理相关单片机系统相关研究资料，认真阅读文献，为研究做准备；
调查研究法：通过调查、分析、具体试用等方法，发现单片机系统的现状、存在问题和解决办法；
比较分析法：比较不同系统的具体原理，以及同一类传感器性能的区别，分析系统的研究现状与发展前景；
软硬件设计法：通过软硬件设计实现具体硬件实物，最后测试各项功能是否满足要求。
三、 软件设计 本系统原理图设计采用Altium Designer19，具体如图。在本科单片机设计中，设计电路使用的软件一般是Altium Designer或proteus，由于Altium Designer功能强大，可以设计硬件电路的原理图、PCB图，且界面简单，易操作，上手快。Altium Designer19是一款专业的整的端到端电子印刷电路板设计环境，用于电子印刷电路板设计。它结合了原理图设计、PCB设计、多种管理及仿真技术，能够很好的满足本次设计需求。
————————————————
仿真实现
本设计利用protues8.7软件实现仿真设计，具体如图。
Protues也是在单片机仿真设计中常用的设计软件之一，通过设计出硬件电路图，及写入驱动程序，就能在不实现硬件的情况进行电路调试。另外，protues还能实现PCB的设计，在仿真中也可以与KEIL实现联调，便于程序的调试，且支持多种平台，使用简单便捷。
————————————————
原理图 五、 程序 本设计利用KEIL5软件实现程序设计，具体如图。作为本科期间学习的第一门编程语言，C语言是我们最熟悉的编程语言之一。当然，由于其功能强大，C语言是当前世界上使用最广泛、最受欢迎的编程语言。在单片机设计中，C语言已经逐步完全取代汇编语言，因为相比于汇编语言，C语言编译与运行、调试十分方便，且可移植性高，可读性好，便于烧录与写入硬件系统，因此C语言被广泛应用在单片机设计中。keil软件由于其兼容单片机的设计，能够实现快速调试，并生成烧录文件，被广泛应用于C语言的编写和单片机的设计。
————————————————
六、 文章目录 目 录
摘 要 I
Abstract II
引 言 1
1 控制系统设计 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e90bcc8263b0ad234b412e8ef0968a9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f7e0f05e593d6785220dfd89bb1fb0a/" rel="bookmark">
			超详细||YOLOv8基础教程（环境搭建，训练，测试，部署看一篇就够）（在推理视频中添加FPS信息）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、YOLOv8环境搭建 这篇文章将跳过基础的深度学习环境的搭建，如果没有完成的可以看我的这篇博客：超详细||深度学习环境搭建记录cuda+anaconda+pytorch+pycharm-CSDN博客
1. 在github上下载源码：
GitHub - ultralytics/ultralytics: NEW - YOLOv8 🚀 in PyTorch &gt; ONNX &gt; OpenVINO &gt; CoreML &gt; TFLite
2. 安装ultralytics（YOLOv8改名为ultralytics）
这里有两种方式安装ultralytics
直接使用CLI pip install ultralytics 使用requirements.txt安装，这种方法是在上面下载的源码处安装，方便对yolov8进行改进 cd ultralytics pip install -r requirements.txt 3. 安装wandb
pip install wandb 登录自己的wandb账号
wandb login 二、开始训练 1. 构建数据集
数据集要严格按照下面的目录格式，image的格式为jpg，label的格式为txt，对应的image和label的名字要一致
Dataset └─images └─train └─val └─labels └─train └─val 2. 创建一个dataset.yaml文件
更换自己的image train和image val的地址，labels地址不用，它会自动索引
将classes改为自己的类别，从0开始
path: ../datasets/coco128 # dataset root dir train: images/train2017 # train images (relative to 'path') 128 images val: images/train2017 # val images (relative to 'path') 128 images test: # test images (optional) # Classes names: 0: person 1: bicycle 2: car 3: motorcycle 4: airplane 5: bus 6: train 7: truck 8: boat 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f7e0f05e593d6785220dfd89bb1fb0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895186bfb6d4fbc1587080c2f970b2e9/" rel="bookmark">
			交通流量数据PEMs数据集说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近刚开始学习有关交通流量数据分析处理方面的内容，将学习过程中对pems数据集的理解记录如下。
由于我也是初学者，所以可能在理解上有所偏差，各位谨慎参考。
PEMs数据集的数据采集方式：由分布在不同地点的xxx个探测器每隔5分钟采集一次，连续采集xxx天。例如PEMS04是由307个探测器每隔5分钟采集一次数据，共采集59天产生的交通流量数据；PEMS08是由170个探测器每隔5分钟采集一次，共采集62天产生的数据。
并且，每个探测器每次采集的数据包含三个维度的特征，分别为：流量、平均速度和平均占有率。
这里对平均占有率进行说明：占有率分为时间占有率和空间占有率，是衡量道路被利用程度的重要指标(我认为它也衡量了拥挤程度)。其中，空间占有率是指在观测时间内，观测路段中各车辆所占道路面积总量与区域道路面积总量的比值；时间占有率是指在观测时间内通过道路某断面的累计时间与该段时间的比值。平均占有率的话取个平均就是了。
基于以上说明，理论上PEMs数据集中的数据维度应该为：
PEMS04：(16992,307,3)
307是指307个探测器，3是指每个探测器每次采集的数据有3个维度特征，16992=59×24×12 (每隔5分钟采集一次数据，因此一小时内可以采集12次，而一天有24小时，又采集了59天，因此就是59×24×12=16992了)
PEMS08：(62×24×12=17856, 170, 3)
csdn上已有大佬将数据可视化如下：(附博客链接GNN交通流量预测_pems04数据集介绍-CSDN博客)
这张图是PEMS数据中一个节点(也就是一个探测器)一天的观测数据，横坐标就是时间度量，上面我们说了探测器每隔五分钟采一次数据，因此一天中采集了288次数据，可以看到上面的图在横坐标也就是时间上展开大致就是0-288，与之前所述符合。三条不同颜色的线对应的就是包含3个维度特征的数据，具体我也没看啥是啥，反正和前面讲的对的上。
然后说一下数据集实际下载下来是什么样子的。(可能有些许偏差，因为我还没自己下载，不过在网上看到的视频里面好像大差不差)
PEMs数据集总的来说包含两部分：
一是csv文件，存储节点之间的边信息
二是npz压缩文件，存储的就是上面说的PEMs数据
上面说过了npz文件里存储的PEMs数据是啥玩意，在此再对csv文件进行说明。csv文件里保存着格式为(from,to,cost)的节点边信息，from是指源节点，to是指目标节点，cost是代价、成本。举个例子，(9, 153, 310.6)的意思是编号为9的节点(探测器)到编号为153的节点(探测器)的成本(其实就是距离)是310.6。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d693d77080c51fe8ae632de8ebc1bea7/" rel="bookmark">
			【MySQL基本功系列】第二篇 InnoDB事务提交过程深度解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过上一篇博文，我们简要了解了MySQL的运行逻辑，从用户请求到最终将数据写入磁盘的整个过程。
当数据写入磁盘时，存储引擎扮演着关键的角色，它负责实际的数据存储和检索。
在MySQL中，有多个存储引擎可供选择，每个存储引擎都具有不同的特性和适用场景，但目前最常用的存储引擎之一是InnoDB。
今天，我们将学习InnoDB存储引擎的架构设计和核心特点，以及InnoDB事务提交过程深度解析。
UPDATE users set name='张老三' WHERE id = 1 如果我们执行上述update语句，它在整个执行过程中会发生什么？
接下来，我们将围绕这个update语句，熟悉整个的执行过程。
一、InnoDB存储引擎的特性： 1. 缓冲池（Buffer Pool） 缓冲池是InnoDB内部的一个重要内存结构，用于高效管理数据库表的数据和索引的缓存。
它在内存中存储了常用的数据页，以加速数据的读取和写入。
我们要更新上述sql
这个时候，它会先找 id = 1 这行数据是否在缓冲池中，如果不在，就将这条数据从磁盘加载到缓存池中。
当我们此时update的时候，也是先将新的数据更新到缓冲池，再写入到磁盘。
2. undo log（回滚日志） 我们知道，事务的所有操作要么全部成功（提交），要么全部失败（回滚）。
那么事务如何回滚呢？我们就要介绍到undo log
unod log文件顾名思义，就是回滚日志。
Undo Log 记录了事务对数据所做的修改，以便在需要回滚时能够撤销或者反向执行这些修改。
就是说我们写入新的数据到内存(缓冲池之前)，会把更新之前的数据，也就是说原来的数据写入undo log文件，方便回滚的时候将数据恢复到事务开始之前的状态。
当我们把要更新的那行记录从磁盘文件加载到缓冲池，同时把更新前的旧值写入undo日志文件之后，就可以正式开始更新这行记录了。
根据上图我们看到，InnoDB收到更新请求后，查看缓冲池中是否有要更新这条数据的缓存页，如果没有则从磁盘文件中加载到缓冲池，再将更新前的数据写入undo log，最后进行数据的更新（更新到内存）
3. Redo Log（重做日志） 现在我们已经把内存里(缓冲池)的数据进行了修改，但是磁盘上的数据还没修改。
如果这时候MySQL机器宕机了，导致内存里修改过的数据丢失，应该怎么办呢？
为了防止这种情况发生，InnoDB 存储引擎在处理事务时采用了一种称为"write-ahead logging" (WAL) 的机制。
这种机制在更内存（缓冲池）时，会同时更新 Redo Log（重做日志）。
Redo Log是用于记录数据库引擎在执行事务期间对数据所做的所有修改操作，它记录了对数据页的物理修改操作，例如在磁盘上某个位置上的某个字节被修改成什么值。
当我们提交事务时，会把操作记录到 Redo Log 中，然后再更新到磁盘。这样做的目的是在系统崩溃时，可以通过重新执行 Redo Log 中的操作来还原已提交的事务，确保数据的一致性和完整性。
通过上图第5步，我们看到，当事务提交时，会将Redo Log写入到磁盘中，这是InnoDB的默认策略，也有其他方式可以自己配置
它由innodb_flush_log_at_trx_commit 参数进行控制：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d693d77080c51fe8ae632de8ebc1bea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2736401eac2dcaf687a0807f98adadaf/" rel="bookmark">
			【Python办公】win32com打开Office、WPS文档的启动方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.说明 COM（Component Object Model）是一种面向组件的二进制接口标准，允许不同的软件模块之间进行交互和通信。Python中的win32com是使用Python控制com的公开库，对于操作软件非常方便，比如是操作Office软件进行文档自动化。Office和WPS都能控制，但是它们的启动方式确实不一样的
2.安装 pip install pywin32 3.Office启动项 # Office from win32com import client path = '' app = client.Dispatch('Excel.Application') # Excel app.DisplayAlerts = False wb = app.Workbooks.Open(path) app = client.Dispatch('Word.Application') # Word app.DisplayAlerts = False doc = app.Documents.Open(path) app = client.Dispatch('PowerPoint.Application') # PPT app.DisplayAlerts = False ppt = app.Presentations.Open(path) 4.WPS启动项 from win32com import client path = '' app = client.Dispatch("ket.Application") # Excel app.Visible = True wb = app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2736401eac2dcaf687a0807f98adadaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa1f6f70a9bd4c257c2a26d3eb450f66/" rel="bookmark">
			计算机网络:自顶向下方法-第8版-Chapter2-Problems
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 P1abcdDateLast-Modified e P2P3P4abcdeUser-Agent P5abcd P6abcd P7P8abc P9ab P10P11ab P12P13ab P14P15P16P17P18abcdefg P19ab P20P21P22C-SP2P P23abc P24abc P25P26ab P27ab P28abc P29P30P31P32 P1 是非判断题
a. 假设用户请求由一些文本和 3 幅图像组成的 Web 页面。对于这个页面，客户将发送一个请求报文并接收 4 个响应报文。
b. 两个不同的 Web 页面（例如，www.mit.edu/research.html 及 www.mit.edu/students.html ） 可以通过同一个持续连接发送。
c. 在浏览器和初始服务器之间使用非持续连接的话，一个 TCP 报文段是可能携带两个不同的 HTTP 服务请求报文的。
d. 在 HTTP 响应报文中的 Date: 首部指出了该响应中对象最后一次修改的时间。
e. HTTP 响应报文决不会具有空的报文体。
a ❌ 客户先对web页面进行请求, 然后在响应报文中得到1个文本和3 幅图像的URL, 然后根据这些URL发送1次或3次请求。
b ✔ 因为客户与主机 www.mit.edu 建立了持续连接，所以同一台服务器上的不同网页都可以在该连接上传送。
c ❌使用非持续连接的TCP连接只能传输一个请求报文和一个响应报文, 连接就关闭。即每个非持续连接在服务器发送一个对象/报文后就关闭连接
d ❌在 HTTP 响应报文中的 Last-Modified: 首部指出了该响应中对象最后一次修改的时间。HTTP响应报文的Date:首部是指在服务器发送响应的时候，服务器生成该响应的时间戳。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa1f6f70a9bd4c257c2a26d3eb450f66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f14a4b5544b699ac071a814a0182d77/" rel="bookmark">
			计算机网络:自顶向下方法-第8版-Chapter1-Reviews
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 R1R2R3R4Answer家庭接入DSL上下行传输速率 Cable Access LANEthernetWLAN ModemDSLAM R5AnswerHFCFTTH R6R7Answer R8Answer R9Answer R10Answer R11Answer R12Answer分组交换网络优点TDMFDM R13Answerabcd R14Answer R15Answer R16Answer R17Answer R18Answer R19abc R20Answer R21R22Answer R23R24ANswer应用层报文运输层报文段网络层数据报链路层帧 R25R26Answer R27R28Answer安全措施 R1 R1. “主机”和“端系统”之间有什么不同？列举几种不同类型的端系统。Web服务器是一种端系统吗？
答案：
主机和端系统并没有不同。所有接入互联网的设备都可以叫端系统或主机.常见的端系统比如笔记本电脑，智能手机等等。Web服务器是一种端系统。
主机 host
端系统: end system
R2 R2. “协议”一词常被用于描述外交关系。维基百科是怎样描述外交协议的？
答案：
百度百科：
国家之间或政府之间缔结的据以确定其相互权利和义务的协议文书，多用于重大的政治、经济、军事、法律等问题的协议。有双边的，也有多边的。狭义仅指以条约命名的协议，如同盟条约、友好条约、和平条约、互不侵犯条约等。广义指不论以何种名称或形式缔结的协议，如条约、公约、协定、联合宣言、联合公报、联合声明、议定书、会谈纪要、换文、合同等。条约、公约等属于国际法律文件,是最重要的外交文书。其缔结和生效程序很严格，需经国家宪法规定的机关批准，完成其法律手续。一般由缔约国各方派代表经正式谈判达成原则协议后,共同拟订条文;次经缔约方国家元首批准,再按商定日期和地点举行换文仪式,交换批准书。通常规定双方缔结的条约，自互换批准书之日起开始生效。条约或公约经签订后，在其有效期内对各缔约国均具有约束力。协定用于缔结意义不十分重大或短期性的协议，其应用较广泛，如贸易协定、海运协定等。议定书通常用于某些具体问题的协议，或用于对已经缔结的条约进行解释、补充、修改或延长其有效期等。协定和议定书的有效期较短，缔结手续也比较简单。换文指双方用互换照会的形式对达成协议的内容予以确认，有时它是条约、协定等的附件。
R3 R3 . 标准对于协议为什么重要？
答案：
标准定义了协议的要做什么和具体内容。
R4 列出6种接入技术。将它们分类为住宅接入、公司接入或广域无线接入。
Answer 住宅接入：
光纤接入
电缆接入
数字用户线 DSL(Digital Subscribers Line)接入
公司接入：
局域网LAN将端系统接入到边缘路由器
以太网
WiFi
广域无线接入：
终端设备使用蜂窝网提供商运营的基站来发送和接收分组
仅需在基站数万米以内即可, 即所谓广域
4G 5G
因特网服务提供商: (Internet Service Provider) ISP
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f14a4b5544b699ac071a814a0182d77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7900962601f45b0b0f646366d9ce12e9/" rel="bookmark">
			GEE平台获取指定区域DEM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、根据指定区域的shp显示dem数据 // 加载指定的 Shapefile var data = ee.FeatureCollection('projects/ee-pengbr3003/assets/Kongquehe_watershed'); // 你的shp文件 var roi = data.geometry(); // 获取ROI的几何信息 // 获取DEM数据 var dataset = ee.Image('USGS/SRTMGL1_003') var elevation = dataset.select('elevation'); Map.centerObject(data, 8); Map.addLayer(data, {color: 'FF0000', fillColor: '00000000', width: 1}, "ROI"); var br_DEM = elevation.clip(roi); // 使用roi对高程数据进行裁剪 // print(br_DEM,'elevation'); Map.addLayer(br_DEM,{min:0,max:5000},'StudyArea'); 结果显示：
导出到谷歌云盘：
Export.image.toDrive({ image: br_DEM, description: 'DEM_export', // 导出文件的名称 scale: 30, // 分辨率，单位为米 region: roi, // 导出的区域 maxPixels: 1e13, // 最大像素数 folder: 'DEM_exports', // 导出到Google Cloud Storage的文件夹 crs: 'EPSG:4326' // 坐标系，这里使用WGS84 }); 2、QGIS展示 如果要分析坡度、坡向这些，可以在QGIS里面找到栅格模块，然后点击分析，里面就有坡度和坡向分析。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7900962601f45b0b0f646366d9ce12e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2acfa86772f1b27f9986fce8c33c1a53/" rel="bookmark">
			Vue项目中强制刷新页面的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在动态切换组件的过程中，导航栏和底栏不动，动态切换中间区域的情况，在首页可以进行跳转任意组件，在组件与组件之间不能相互跳转，路由发生了变化，但是页面未改变，这时我们就需要强制刷新页面。
强制刷新页面的方式有三种：
①location.reload() ②this.$router.go(0)
前面两种方法都有些简单粗暴，主要说一下第三种方法
③provide 配合 inject
首先我们需要在App.vue中修改 通过定义reload方法，控制router-view的显隐（生成和销毁）
然后在需要刷新页面的组件中注入依赖，注入时inject后面是上面的方法名称 最后直接调用reload方法就能实现页面的刷新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9085d991ca040a29f42a999f7d88079e/" rel="bookmark">
			Gogs安装和部署教程-centos上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、什么是 Gogs? Gogs 是一款极易搭建的自助 Git 服务。
Gogs 的目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务。使用 Go 语言开发使得 Gogs 能够通过独立的二进制分发，并且支持 Go 语言支持的 所有平台，包括 Linux、Mac OS X、Windows 以及 ARM 平台。
Introduction - Gogs
1、整体安装步骤： 1）、首先去官网上下载二进制包https://gogs.io/docs/installation/install_from_binary.html
2）、进行安装
检查环境要求是否已满足解压压缩包。使用命令 cd 进入到刚刚创建的目录。执行命令 ./gogs web。Gogs 默认会在端口 3000 启动 HTTP 服务，访问 /install 以进行初始配置（例如 http://localhost:3000/install ）。 安装完成后可继续参照 配置与运行。
2、如何使用下载好的压缩包？ 选择适合系统的gogs安装包
From binary - Gogs
去官网上下载二进制包 https://gogs.io/docs/installation/install_from_binary.html
二进制安装 目前只提供最近发布的小版本二进制下载，更多版本下载请前往 GitHub 查看。
所有的版本都支持 MySQL、PostgreSQL 和 TiDB（使用 MySQL 协议）作为数据库，并且均使用构建标签（build tags）cert 进行构建。需要注意的是，不同的版本的支持状态有所不同，请根据实际的 Gogs 提示进行操作。
mws 表示提供内置 Windows 服务支持，如果您使用 NSSM 请使用另外一个版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9085d991ca040a29f42a999f7d88079e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cedd88e243ab41c17ebdc5c669003228/" rel="bookmark">
			Nginx 413 Request Entity Too Large的解决办法；修改nginx限制文件上传大小的办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误原因：服务器限制了文件上传大小，上传文件超过了服务器限制！
解决方案
1、找到自己的nginx配置文件
2、在location块中添加其中的配置为：client_max_body_size 200m; # 改为你需要的大小
3、保存重启Nginx
正确配置参考
server {
listen 80;
server_name adb.abc.com;
location / {
root html; index index.html index.htm;
client_max_body_size 200m; # 改为你需要的大小!
}
}
其他
可以选择在http{ }中设置：client_max_body_size 200m;
也可以选择在server{ }中设置：client_max_body_size 200m;
还可以选择在location{ }中设置：client_max_body_size 200m;
三者有区别
设置到http{}内，控制全局nginx所有请求报文大小
设置到server{}内，控制该server的所有请求报文大小
设置到location{}内，控制满足该路由规则的请求报文大小 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/71/">«</a>
	<span class="pagination__item pagination__item--current">72/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/73/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>