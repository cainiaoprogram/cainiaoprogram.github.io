<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e0fd81a8ef9847a257cbcec7e8419e8/" rel="bookmark">
			小书匠更新说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小书匠编辑器更新手册 小书匠 编辑器 更新手册 1.0.12 1.0.12 新功能 离线版提供了发布功能。用户可将自己的文章发布到常用的博客平台。（目前测试通过的有cnblogs.com和oschina.net）离线版本地文件存储提供了右键操作功能修改了命名规则。系统默认使用文章里的元数据做为标题，用户也可以通过左侧的文章列表进行修改。重新设计了另存为功能。添加了视频，音频，附件，todo-list, 印刷字替换，缩写定义，上角文字，下角文字，记号等语法预览功能增强。重新设计了编辑区与预览区的同步滚动功能，提高了定位的准确性。sourceMap功能。用户可以通过sourceMap按钮，方便的查看编辑区与预览区的对应关系 1.0.12 修改 evernote, 印象笔记：标题使用元数据里的title,第一次保存时会提示用户选择保存在哪个笔记本下。本地文件系统存储： 第一次保存时会提示创建文件名。界面重新进行了设计 1.0.0 1.0.0 修改 界面进行了全面的重新设计，用户可以自由切换多种模式，三栏，双栏，单栏，全屏写作，全屏阅读。底层代码全部进行了重构添加了更多的第三方平台 1.0.0 主要新功能 实现了发送邮件功能（支持将图片，流程图，统计图，数学公式转换成附件图片发送）实现了对dropbox在线查看，修改markdown文件（仅限于web版）实现了对github在线查看，修改markdown文件实现了本地文件系统存储绑定功能（仅限于离线版）实现了pdf打印功能（仅限于web版里的chrome浏览器用户）实现了导出单一文件的html,并自动将css,img转换成inline模式实现了markdown文件元数据功能（基于js-yaml语法，在每篇文章开头定义），自动提取标题和标签，方便用户对文章的分类实现了文章分类管理的功能预览效果多种自定义css效果选择，用户还可以自定义预览效果 0.2.4 0.2.4 修复的问题 站内链接错误打开新页面新建文件后，保存到第三方存储时，错误覆盖掉上一篇文章第三方服务evernote总是报token失效全屏写作模式后，esc键不能退出mac客户端不能正确复制web版不能正常保存会话 0.2.2 0.2.2 修改 解决由于升级了node-webkit版本，导致不能同步保存样式到evernote的bug解决在生成内联样式时，窗口假死问题 0.2.0 0.2.0版本新功能 提供用户自定义操作界面的字体支持word 导出支持zip导出支持统计图语法（使用Flot图表插件）提供md导入，zip导入（zip文件需要是由小书匠导出的zip）数学公式导出时自动转换成图片 0.2.0 修复的问题 mathjx 在window版本没有的包进去自定义的css无法同步的evernote添加的图片无法同步到evernote流程图导出时，部分图标丢失 转载于:https://my.oschina.net/suziwen/blog/371541
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/206533099636a633cf4e205b74a19ecf/" rel="bookmark">
			小书匠使用手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小书匠编辑器使用手册 小书匠 使用手册 概要 小书匠编辑器是一款专为markdown写作而设计的编辑器。
主要功能 专为markdown写作设计的文档编辑器，让用户心无旁骛的进行创作。多种编辑模式。单栏编辑，双栏编辑，三栏编辑，全屏写作，全屏阅读…想怎么切换，就怎么切换，就是这样随心所欲。多种主题选择。包括编辑器主题，预览区代码高亮主题，及预览区用户自定义css。丰富的语法支持。不仅提供了常用的commanmarkdown语法，还提供了许多有用的扩展语法，比如Latex公式，表格, 目录， 脚注, 视频, 音频, 附件, checklist, 流程图等。更多语法可查看&lt;小书匠语法使用手册&gt;第三方同步。浏览器存储, 本地文件系统存储, dropbox, evernote, 印象笔记, github等多种存储方案，保证了用户数据的安全，也让用户在存储方案上有了更多的选择。支持evernote，印象笔记。提供双向操作，可以将文章保存到evernote/印象笔记上，也可以从evernote/印象笔记上导入数据。同时提供标签，附件，图片，待办等相关处理。强大的文件管理功能。文件信息，标签，附件，音频，视频，图片管理。发布功能。 支持将文章发布到博客平台上。邮件发送功能。sourceMap对照功能。方便在源markdown文件和生成的html文件上进行比较，特别适合markdown初学者使用，了解每一个markdown解析产生的结果，也适用于文章后期的校对上。 离线版下载地址 http://soft.xiaoshujiang.com
WEB版访问地址 http://markdown.xiaoshujiang.com
浏览器存储 系统对创建的文章，都会在浏览器存储上进行保存。包括像evernote/印象笔记/github/dropbox等导入的文章，也都会保存一份副本，并创建一个标识，表示跟哪些第三方存储关联。
标题，标签 文章标题的处理规则：如果文章内存在元数据title，则系统自动使用元数据内的title做为标题。如果文章未使用到元数据功能，用户可以通过维护文章信息按钮，修改标题。标签tags的规则也跟标题一样。
附件 文章使用./做为附件的引用标识。对于图片，音频，视频，附件等链接的处理，系统只处理以./开头的链接，并转换成附件真实的地址进行显示。用户可以通过工具栏的插入图片，插入音频，插入视频，插入附件等按钮上传附件。
evernote/印象笔记 小书匠编辑器提供对evernote/印象笔记的支持，下面的使用说明默认用户已经完成了evernote/印象笔记的绑定操作，并将当前的工作平台切换到evernote/印象笔记下。
新建 通过新建按钮后，创建的文章将自动关联到evernote/印象笔记上(注:这里仅仅是在文章上创建一个关联的标识，只有当用户保存后，才能在服务器上查看到新的笔记)
打开 点击笔记，系统将自动把笔记导入，并将当前文章切换为导入的笔记内容。导入的文章自动与evernote/印象笔记上的笔记关联，下次再点击该笔记时，将直接从浏览器存储上打开。用户可以通过切换存储平台浏览器存储，来删除该缓存的文件。导入的笔记如果本地没有缓存，系统将对服务器上的笔记进行判断，如果笔记是通过小书匠编辑器进行保存，并且文章在保存后没有被操作过，则系统自动使用保存时附带的markdown附件做为文章内容，重新导入。如果笔记已经被修改，或者笔记不是通过小书匠编辑器进行保存的，系统将自动将文章转换成markdown格式。
保存 对于新创建的文章，用户可以直接保存ctrl+s，系统将弹出一个选择笔记本的窗口，确认后，系统将保存当前文章到evernote/印象笔记上。（在弹出窗口上选择笔记本时，如果用户选择了笔记，系统将覆盖该笔记）
对于已经存在的文章，但还没有保存到evernote/印象笔记，用户可以通过另存为ctrl+shift+s将当前文章保存到evernote/印象笔记上。
不管是保存，还是另存为，保存成功后，系统都将自动对当前文章与evernote/印象笔记上的笔记进行关联。下次保存时ctrl+s系统将自动同步保存到evernote/印象笔记上。
删除 系统不提供删除操作，用户需要自己到evernote/印象笔记端删除，如果本地缓存了笔记，可以通过浏览器存储删除缓存。
重命名 直接修改元数据title，如果文章内未使用元数据功能，可通过浏览器存储里的修改文章信息进行修改
标签管理 系统自动通过每篇文章的元数据tags提取为笔记的标签。
附件管理 打开时，系统自动将笔记上的附件导入到文章对应的附件管理器上。保存时，系统将根据文章内对附件的引用，将附件保存到服务器上。这里的引用包括音频，视频，附件，图片。如果文章内使用到了流程图，序列图，公式，统计图等，系统将会把这些内容转换成图片进行保存。由于evernote/印象笔记在部分终端不提供视频，音频的支持，查看保存的文章时，对应的音频，视频将以附件的形式存储。
待办事项 目前系统仅同步了待办事项。
github/dropbox 新建 参考evernote/印象笔记的新建
打开 参考evernote/印象笔记的打开
不同的是，github/dropbox只能打开扩展名为html，markdown，md，mkd以及无扩展名的文件。
保存 参考evernote/印象笔记的保存
不同的是，github/dropbox保存时，仅保存了markdown文章本身，并不会将markdown转换成html进行保存，也不会处理附件相关的内容。
对于新文章的保存，github/dropbox存储需要用户指定文件名及存储的位置。
删除 系统不提供删除操作
重命名 系统不提供重命名操作，只能通过另存为ctrl+shift+s，保存成新的文件。
本地文件系统存储 本地文件系统存储仅在离线版提供支持。
新建 参考evernote/印象笔记的新建
打开 参考github/dropbox的打开
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/206533099636a633cf4e205b74a19ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/126aadc933f8aa12a525a30459c1ca1e/" rel="bookmark">
			Java内存溢出与栈溢出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景知识 1、JVM体系结构 2、JVM运行时数据区 3、JVM内存模型 JVM运行时内存 = 共享内存区 + 线程内存区 3-1、共享内存区 共享内存区 = 持久带 + 堆
持久带 = 方法区 + 其他
堆 = Old Space + Young Space
Young Space = Eden + S0 + S1
3-1-1、持久代 JVM用持久带（Permanent Space）实现方法区，主要存放所有已加载的类信息，方法信息，常量池等等。
可通过-XX:PermSize和-XX:MaxPermSize来指定持久带初始化值和最大值。
Permanent Space并不等同于方法区，只不过是Hotspot JVM用Permanent Space来实现方法区而已，有些虚拟机没
有Permanent Space而用其他机制来实现方法区。
3-1-2、堆 堆(heap)，主要用来存放类的对象实例信息（包括new操作实例化的对象和定义的数组）。
堆分为Old Space（又名，Tenured Generation）和Young Space。
Old Space主要存放应用程序中生命周期长的存活对象；
Eden(伊甸园)主要存放新生的对象；
S0和S1是两个大小相同的内存区域，主要存放每次垃圾回收后Eden存活的对象，作为对象从Eden过渡到Old Space
的缓冲地带（S是指英文单词Survivor Space）。
堆之所以要划分区间，是为了方便对象创建和垃圾回收，后面垃圾回收部分会解释。
3-2、线程内存区 线程内存区=单个线程内存+单个线程内存+.......
单个线程内存=PC Regster+JVM栈+本地方法栈
JVM栈=栈帧+栈帧+.....
栈帧=局域变量区+操作数区+帧数据区
在Java中，一个线程会对应一个JVM栈(JVM Stack)，JVM栈里记录了线程的运行状态。
JVM栈以栈帧为单位组成，一个栈帧代表一个方法调用。栈帧由三部分组成：局部变量区、操作数栈、帧数据区。
二、堆溢出 堆（Heap）是Java存放对象实例的地方。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/126aadc933f8aa12a525a30459c1ca1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd85c4f008869d9bffdf9cc86fb915e6/" rel="bookmark">
			numpy数组扩展函数repeat和tile用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		numpy数组扩展函数有repeat和tile，由于数组不能进行动态扩展，故函数调用之后都重新分配新的空间来存储扩展后的数据。
repeat函数功能：对数组中的元素进行连续重复复制
用法有两种：
1) numpy.repeat(a, repeats, axis=None)
2) a.repeats(repeats, axis=None)
其中a为数组，repeats为重复的次数，axis表示数组维度
&gt;&gt;&gt;import numpy as np
&gt;&gt;&gt; a = np.arange(10) &gt;&gt;&gt; a array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) &gt;&gt;&gt; a.repeat(5) array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9]) &gt;&gt;&gt; a np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd85c4f008869d9bffdf9cc86fb915e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac99198e3c18f4c68dd5417219290989/" rel="bookmark">
			ssssssssssssssssssssssssssaaaaaaaaaaaaa
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sfsdfsdfsdf
转载于:https://my.oschina.net/suziwen/blog/370844
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/765f03c838c9c563934e2a64b60cf383/" rel="bookmark">
			小书匠语法使用手册ggggggggggggggggggggggggg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;style&gt; a:focus { outline: thin dotted #333; outline: 5px auto -webkit-focus-ring-color; outline-offset: -2px; } a:hover { outline: 0; } a:active { outline: 0; } a:hover { color: #005580 !important; text-decoration: underline !important; } blockquote small:before { content: '\2014 \00A0'; } q:before { content: ""; } q:after { content: ""; } blockquote:before { content: ""; } blockquote:after { content: ""; }
&lt;/style&gt;&lt;div class="preview custom_css_preview"&gt;&lt;h1 style="margin-top: 10px; margin-right: 0; margin-bottom: 10px; margin-left: 0; font-family: inherit; font-weight: bold; line-height: 40px; color: inherit; text-rendering: optimizelegibility; font-size: 38.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/765f03c838c9c563934e2a64b60cf383/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91223c6d7fb9bc20242f9ae800a4c9d5/" rel="bookmark">
			小书匠语法使用手册xxxxxxxxxxxxxxxxxxxxxxxxxxx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;style&gt; a:focus { outline: thin dotted #333; outline: 5px auto -webkit-focus-ring-color; outline-offset: -2px; } a:hover { outline: 0; } a:active { outline: 0; } a:hover { color: #005580 !important; text-decoration: underline !important; } blockquote small:before { content: '\2014 \00A0'; } q:before { content: ""; } q:after { content: ""; } blockquote:before { content: ""; } blockquote:after { content: ""; } &lt;/style&gt;&lt;div class="preview custom_css_preview"&gt;&lt;h1 style="margin-top: 10px; margin-right: 0; margin-bottom: 10px; margin-left: 0; font-family: inherit; font-weight: bold; line-height: 40px; color: inherit; text-rendering: optimizelegibility; font-size: 38.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91223c6d7fb9bc20242f9ae800a4c9d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d5e001fb2ffdae580aaae372705af83/" rel="bookmark">
			Ext.create的使用及扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说，直接上代码：
Ext.onReady(function(){
var wingroup = new Ext.WindowGroup();
for(var i = 1; i &lt;= 5; i++){
var win = Ext.create('Ext.Window', {//1处
title : '第' + i + '个窗口',
id : 'win_' + i,
width : 300,
height : 300,
renderTo : Ext.getBody()
});
win.show();
wingroup.register(win);
}
var btn1 = Ext.create('Ext.Button', { //2处
text : '隐藏',
renderTo : Ext.getBody(),
handler : function(){//3处 wingroup.hideAll();
}
});
});
Ext.create()方法是创建一个实例对象，比如//2处，当然这个实例对象随你需要了，1处创建的是window，2处创建的是button。
实例对象创建好了之后，紧跟在后面的{}内就是各种属性了，也就是我们经常看到的API中的configs，
configs内部也有可以调用函数的属性，比如：handler，
如果你看过API，那么他后面的说明是这样写的：
handler : Function
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d5e001fb2ffdae580aaae372705af83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27347c9c6db10e698c50ab4b26ec9830/" rel="bookmark">
			android 获取经纬度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主Application
package com.example.basic;
import com.baidu.location.BDLocation;
import com.baidu.location.BDLocationListener;
import com.baidu.location.GeofenceClient;
import com.baidu.location.LocationClient;
import android.app.Application;
import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Vibrator;
import android.util.Log;
import android.widget.TextView;
/**
* 主Application
*/
public class LocationApplication extends Application {
public LocationClient mLocationClient;
public GeofenceClient mGeofenceClient;
public MyLocationListener mMyLocationListener;
public TextView mLocationResult, logMsg;
public TextView trigger, exit;
public Vibrator mVibrator;
@Override
public void onCreate() {
super.onCreate();
mLocationClient = new LocationClient(this.getApplicationContext());
mMyLocationListener = new MyLocationListener();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27347c9c6db10e698c50ab4b26ec9830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/362dec5dc96f8986234b495b3eb5a52e/" rel="bookmark">
			好书推荐-腾讯方法：一个市值1500亿美元公司的产品真经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 腾讯方法，本书通过两位作者亲历，采写的腾讯公司三个处于不同生命周期的产品案例，从三个不同视角，全景式地呈现了腾讯在产品开发与运营的独到思路与实操细节，全生命周期地展现了腾讯公司的产品开发与运营思维。书中全案例，全实战，作者意在通过思路清晰，细节丰富的深度调研案例让读者自己去感受腾讯的产品思维与运营思维。
作者：潘东燕 王晓明
出版社：机械工业出版社
内容简介：
这是国内第一本深度讲述腾讯产品研发与团队转型的书。本书介绍了腾讯三个不同生命周期的产品的开发过程，包括：如何踏足新领域开发新产品；如何救活一个即将半路夭折的产品；如何让一个老产品持续盈利。本书呈现了互联网产品开发时会遇到普遍问题和解决方法，涉及大企业如何内部创业，并迅速组建新的项目团队；如何实现跨部门的合作；在面临新团队和紧急开发任务时如何提高团队沟通效率；在产品研发方面，如何定位产品、如何敏捷开发、如何测试和迭代等。三个案例皆为第一手材料，具有非常强的可读性和参考价值。
作者简介：
潘东燕 出生于福建，山东大学管理学硕士。 专注于管理案例的调研、采写与研究，深入调研超过60家各行业旗帜企业，采写超过50个各行业最佳实践案例，内容涵盖战略、运营、人力资源、企业文化、创新与创业、领导力、商业模式、团队管理、项目管理、产品开发、知识管理等管理学各个模块。现任《中欧商业评论》执行副主编、主笔（2010年至今），案例研究中心总监，中欧“颠覆式创新”私享会总策划、课程总监。 王晓明 生于辽宁，英国约克大学计算机硕士。 敏思特咨询创始人、CEO，“轻敏捷”方法创始人，国内知名的组织转型导师。曾任腾讯高级管理顾问、组织转型导师，腾讯IEG自研委员会唯一外聘专家，腾讯天美艺游工作室首席管理顾问，迅雷首席管理顾问、总裁、首席体验官，创新工场特聘导师，华为首位敏捷组织转型咨询师，英国Pinesoft首席运营官，现担任搜狐畅游、第七大道首席管理顾问。 名人推荐 本书的价值在于通过鲜活生动的实战案例，完美地呈现了以用户为导向，快速验证，快速修正的敏捷开发体系，不仅在于“思”，更偏重于“行”，是少有的重实践而非理论的干货，值得我们反复研读并学以致用。
——陈德文 搜狐畅游CEO
本书可贵之处在于，三个案例都是经过作者对腾讯的深入调研而完成，知识和经验直接来源于腾讯，而非网上流传的雾里看花式的猜测和揣摩，且案例避免了抽象的理论说教，可读性极强，引人入胜，容易理解吸收，同时又极具专业性和严谨性。
——崔广福 艺龙旅行网CEO
轻敏捷方法的核心是“快速验证”，根据用户反馈快速迭代，小步快跑，这是创新型互联网产品研发的普遍规律。本书中腾讯的案例将这个点阐述得非常精彩，很值得我们学习和思考。
——程浩 迅雷CEO
我们需要这样一本书：案例发生在我们这个时代，我们试图和这个企业一起去跑；我们选择了不同的路径，可以比较不同选择带来的成果；案例鲜活生动，你能看到这些事在我们的企业也都发生着；案例涉及产品开发与运营的方方面面，让我们能从中得到系统思考。
——唐兆希 网龙高级创新副总裁、首席知识官
从腾讯实战中我们不难看出，移动互联网产品设计要秉持简洁、互动、参与等特性，以用户体验为导向，让所有参与者都能拥有主人翁意识，让用户直接参与产品设计与改进。相信本书将给众多向互联网转型的传统企业带来巨大启发。
——张荣耀 荣昌e袋洗董事长
这本书不是拿成功案例说教，而是真实的记录！记录腾讯的产品团队将每个项目以创业公司方式进行开发与运营的全过程。无论是创业者，还是企业已经有一定规模的管理者，都能从书中获得巨大启发。
——吴海 桔子酒店集团CEO
腾讯在产品开发与转型、组织变革与团队管理中遇到的问题，不仅似曾相识，有些甚至是百思不得其解的心病，作者给出的解决之道，不仅是答疑解惑，更是实战指南！价值连城！
——夏军 车享网CEO
在团队转型上，腾讯遇到的绝大多数问题我们也都碰到过，读后很有共鸣；在方法论上，如何从战略到价值观再到团队目标的统筹一致，包括团队转型的技巧等都很受用。
——颜艳春 北京富基融通科技股份有限公司董事长 个人分享博客：http://blog.csdn.net/fuyifang 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c019b65e0b003fc33c47adf5179f658f/" rel="bookmark">
			Mysql Fabric HA配置测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL Fabric是Oracle官方推出的原生mysql高可用性系统，它可以简化管理MySQL数据库群，它提供两大特性，一是通过故障检测和故障转移功能提供了高可用性，一是通过自动数据分片功能实现可扩展性。本文档只说明自动故障转移-高可用性的实现。
一、测试环境
功能
IP
端口
Master
192.168.247.132
3306
Slave 192.168.247.133
3306
Fabric state store
192.168.247.4
3306
Fabric 管理进程
192.168.247.4
32274
系统环境要求如下：
MySQL Servers (version 5.6.10 or later)
·Backing store database server
·Application database servers
Python 2.6 or 2.7
·No support for 3.x yet
python连接器1.2.1以上
二、下载Fabric
Fabric目前是被打包到了MySQL Utilities中，所以大家下载MySQL Utilities就可以了，下载地址是：http://dev.mysql.com/downloads/utilities/，目前版本是：1.5.3，在本例中我们下载的是 mysql-utilities-1.5.3-1.el6.noarch.rpm。
Mysql-python连接器下载地址：http://dev.mysql.com/downloads/connector/python/，本例中我们下载mysql-connector-python-2.0.2-1.el6.noarch.rpm
三、安装连接器和MySQL Utilities
rpm包的安装还是挺简单的，具体如下：
rpm -ivh mysql-connector-python-2.0.2-1.el6.noarch.rpm
rpm -ivh mysql-utilities-1.5.3-1.el6.noarch.rpm
装完后执行
mysqlfabric
如果有回显说明安装完毕。
四、建立Backing Store帐号
Backing Store用于存储整个HA集群的服务器等相关配置，它需要一个MySQL实例来存储这些信息，这个实例的版本需要跟其它在HA中的MySQL实例版本保持一致，而且必须是5.6.10及更高的版本，我们在本例中选择192.168.247.4：3306实例来使用。Fabric管理进程和Backing Store实例可以是在两台不同的机器，测试中我们共用192.168.247.4。
创建一个帐号来连接Backing Store的MySQL实例，这个帐号需要有对fabric数据库的管理员级权限，具体如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c019b65e0b003fc33c47adf5179f658f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5ef6b1eaf7dc441d6e87ad3e32bf1f0/" rel="bookmark">
			php中防止SQL注入的最佳解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章介绍了，php中防止SQL注入的最佳解决方法。需要的朋友参考下
如果用户输入的是直接插入到一个SQL语句中的查询，应用程序会很容易受到SQL注入，例如下面的例子:
复制代码代码如下: $unsafe_variable = $_POST['user_input']; mysql_query("INSERT INTO table (column) VALUES ('" . $unsafe_variable . "')"); 这是因为用户可以输入类似VALUE"); DROP TABLE表; - ，使查询变成：
复制代码代码如下: INSERT INTO table (column) VALUES('VALUE'); DROP TABLE table;' 我们应该怎么防止这种情况呢?下面我们来看看Theo的回答 使用预备义语句和参数化查询。对于带有任何参数的sql语句都会被发送到数据库服务器，并被解析！对于攻击者想要恶意注入sql是不可能的！
实现这一目标基本上有两种选择：
1.使用PDO(PHP Data Objects )
复制代码代码如下: $stmt = $pdo-&gt;prepare('SELECT * FROM employees WHERE name = :name'); $stmt-&gt;execute(array(':name' =&gt; $name));
foreach ($stmt as $row) {
// do something with $row
}
2.使用mysqli
复制代码代码如下: $stmt = $dbConnection-&gt;prepare('SELECT * FROM employees WHERE name = ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5ef6b1eaf7dc441d6e87ad3e32bf1f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29d812e5d8af2246e7135c9d27b35695/" rel="bookmark">
			网易云课堂程序设计入门—Java语言（第五周）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		井字棋 题目内容： 嗯，就是视频里说的那个井字棋。视频里说了它的基本思路，现在，需要你把它全部实现出来啦。 你的程序先要读入一个整数n，范围是[3,100]，这表示井字棋棋盘的边长。比如n=3就表示是一个3x3的棋盘。然后，要读入n行，每行n个数字，每个数字是1或0，依次表示[0,0]到[n-1,n-1]位置上的棋子。1表示X，0表示O（大写字母O）。 你的程序要判断其中是否存在某一方获胜，获胜的条件是存在整行或整列或整条对角线或整条反对角线上是相同的棋子。如果存在，则输出代表获胜一方字母：X或O（大写字母X或O）；如果没有任何一方获胜，则输出NIL（三个大写字母，中间是字母I（India的I）。 注意：所给的棋盘上的棋子分布可能出现同一个棋子有多处满足获胜的条件，但是不会出现两种棋子都获胜的情况。 输入格式: 一个代表棋盘大小的数字n，后面跟上nxn个0或1的数字。 输出格式： 三种输出之一： X O NIL 均为大写字母。 输入样例： 4 1 0 0 1 0 1 0 0 0 0 1 0 1 0 0 1 输出样例： X
import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); int[][] num = new int[n][n]; int count = 0; int temp = -1; for (int i = 0; i &lt; num.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29d812e5d8af2246e7135c9d27b35695/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f268dfa0767b566a8e6268355d098266/" rel="bookmark">
			查询某个分组中多行字段值的拼接字串的方法--access
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查询某个分组中多行字段值的拼接字串的方法 先收藏，后面再研究
access的SQL语法中没有自定义函数，也不能象SQL Server中一样用变量、游标、子查询等方法来灵活处理查询语句。 但是，在Access环境中，透过模块中的过程，可利用功能强大的VB语言，生成复杂需求的查询语句。 下面是本人今天在Access版块中的一个回复，以此例
access的SQL语法中没有自定义函数，也不能象SQL Server中一样用变量、游标、子查询等方法来灵活处理查询语句。
但是，在Access环境中，透过模块中的过程，可利用功能强大的VB语言，生成复杂需求的查询语句。
下面是本人今天在Access版块中的一个回复，以此例子，简单说明Access依托VB所蕴含的强大功能。
网友提问：　--------------------------------------------------------------------------------
我在ACCESS里面的表如下：
comname　name　sex
1公司　小王　男　1公司　小李　女　2公司　小张　男　我想将同公司的内容合在一起如：
comname　name　sex 1公司　小王，小李　男，女　2公司　小张　男　请问我在ACCESS里面该如可操作？请问有什么好的方法去处理？？
--------------------------------------------------------------------------------
解答：
----------------------------------------------------------------------------------
在 access的模块中建立一个自定义函数：
Public Function CombStr(TableName As String, FieldName As String, GroupField As String, GroupValue As String) As String
Dim ResultStr As String
Dim rs As Recordset
Set rs = CurrentDb.OpenRecordset(" select "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f268dfa0767b566a8e6268355d098266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfa3b3522efd255d429a602889ae0b8e/" rel="bookmark">
			网易云课堂程序设计入门—Java语言（第三周）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		奇偶个数 题目内容： 你的程序要读入一系列正整数数据，输入-1表示输入结束，-1本身不是输入的数据。程序输出读到的数据中的奇数和偶数的个数。 输入格式: 一系列正整数，整数的范围是（0,100000）。如果输入-1则表示输入结束。 输出格式： 两个整数，第一个整数表示读入数据中的奇数的个数，第二个整数表示读入数据中的偶数的个数。两个整数之间以空格分隔。 输入样例： 9 3 4 2 5 7 -1 输出样例： 4 2
import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner can = new Scanner(System.in); int num = can.nextInt(); int count1 = 0, count2 = 0; while (num != -1) { if (num % 2 == 1) count1++; //记录奇数的个数 else count2++; //记录偶数的个数 num = can.nextInt(); } System.out.println(count1 + " "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfa3b3522efd255d429a602889ae0b8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09e5deb5c9689da955a6b406522c5e00/" rel="bookmark">
			网易云课堂程序设计入门—Java语言（第一周）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 温度转换
题目内容：
写一个将华氏温度转换成摄氏温度的程序，转换的公式是： °F = (9/5)*°C + 32 其中C表示摄氏温度，F表示华氏温度。 程序的输入是一个整数，表示华氏温度。输出对应的摄氏温度，也是一个整数。 提示，为了把计算结果的浮点数转换成整数，需要使用下面的表达式： (int)x; 其中x是要转换的那个浮点数。 输入格式: 一个整数。 输出格式： 一个整数 输入样例： 100 输出样例： 37
import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner can = new Scanner(System.in); int F = can.nextInt(); int C = (F - 32) * 5 / 9; System.out.println(C); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fd2fdf9abd45087e82bff04009710a0/" rel="bookmark">
			网易云课堂程序设计入门—Java语言（第二周）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间换算
题目内容： UTC是世界协调时，BJT是北京时间，UTC时间相当于BJT减去8。现在，你的程序要读入一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果分小于10分，需要保留十位上的0。如1124表示11点24分，而905表示9点5分，36表示0点36分，7表示0点7分。 有效的输入范围是0到2359，即你的程序不可能从测试服务器读到0到2359以外的输入数据。 你的程序要输出这个时间对应的UTC时间，输出的格式和输入的相同，即输出一个整数，表示UTC的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果分小于10分，需要保留十位上的0。 提醒：要小心跨日的换算。 输入格式: 一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果分小于10分，需要保留十位上的0。 输出格式： 一个整数，表示UTC的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果分小于10分，需要保留十位上的0。 输入样例： 903 输出样例： 103 import java.util.Scanner; public class Main { public static void main(String argv[]) { Scanner scan = new Scanner(System.in); int BJT = scan.nextInt(); int UTC; if(BJT &lt; 800) UTC = BJT - 800 + 2400; else UTC = BJT - 800; if(UTC &lt; 10) System.out.println("0"+UTC); //考虑到输入803的时候，输出要为03 else System.out.println(UTC); } } 信号报告 题目内容： 无线电台的RS制信号报告是由三两个部分组成的： R(Readability) 信号可辨度即清晰度. S(Strength) 信号强度即大小. 其中R位于报告第一位，共分5级，用1—5数字表示.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fd2fdf9abd45087e82bff04009710a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2480e3f6c72613cecb67dc531337867e/" rel="bookmark">
			C&#43;&#43;语法总结查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		How to Program in C++ You may copy this file for noncommercial use. The latest versionis located at cs.fit.edu/~mmahoney/cse2050/how2cpp.html updatedApr. 14, 2010. Please report errors to Matt Mahoney atmmahoney@cs.fit.edu.Seldom-used features have been deliberately omitted.
Language Summary Basic Concepts Statements if, for, while, return, break... Expressions arithmetic, comparison, assignment... The most important types areint, char, bool, double, and the containers string, vector,and map. Summary of common types:
Built-in Description int x; Fastest integer type (16-32 bits), also short, long, unsigned char x; 8-bit character, '\0' to '\xFF' or -128 to 127 double x; 64 bit real + or - 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2480e3f6c72613cecb67dc531337867e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd2f8b1844bd34a510bc8af7d6af8056/" rel="bookmark">
			MATLAB2012a下载、安装及破解方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址如下：
http://yunpan.cn/cyjGMugpDGsse 提取码 32e8
安装步骤如下：
1、解压压缩包，打开文件夹内的setup.exe
2、选择“不使用Internet安装”
3、接受许可协议条款，点击“是”
4、选择：我已有我的许可证的文件安装密钥
输入：38699-60149-36808-21840-05491
5、选择安装类型：典型
6、安装路径任意，但最好不要有中文路径。由于程序较大，也最好不要放在C盘
7、点击下一步，知道安装完成
8、激活：找到........\MATLAB\R2012a\bin\win32中的activate_matlab.exe，打开
9、选择“不使用Internet手动激活”
10、选择：输入许可证文件的的完整安装路径（包括文件名）
文件路径在：下载文件的解压文件夹——&gt;crack——&gt;lic_standalone.dat
11、点击下一步，激活完成。
注：解压文件夹里的crack文件夹里有安装过程的详细步骤。序列号在在这个文件夹的install.txt里也有
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8661a3e37f5ed244afaa9639b2ce08cd/" rel="bookmark">
			ArcGIS的mxd文档使用相对路径保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单个mxd文件的相对路径的设置方法在这里略去，这里只讲如何设置默认以相对路径保存mxd地图文档。
在ArcGIS 10中的设置如下：
这样新建的地图文档都将以相对路径的形成保存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/369ba3fe3d5fad7c7395ea957c3d4543/" rel="bookmark">
			区分VS中解决方案（solution）和工程（project）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在visual studio中，新建一个工程时会发现如下图的界面：
其中“名称”代表的是项目（project）的名字，“解决方案名称”即solution；在“解决方案”这一栏里可以选择“创建新解决方案”、“添加到解决方案”、“在新实例中创建”，如下图（其中意思就不解释了）： 实际上在使用VS进行开发使，很重要的一点是明白解决方案和工程之间的区别。本质上来说，解决方案是多个工程的集合。（每个工程是一个独立的软件模块，比如一个程序、一个代码库等）。这样的好处是解决方案可以共享文件和代码库。通常，为解决方案创建一个主文件夹，里面包含所有的工程文件夹。但是，也可以将解决方案和工程放在同一个文件夹内，，这对于仅包含单个工程的解决方案来说是惯例。我们一般也是这样用。实际上创建更多复杂的应用之后，应该使用包含多个工程的解决方案结构。下面给出两个图片，一个是solution中只有一个project，另一个是包含多个project。
上面的图是解决方案里只有一个工程。
、
上面的图一个解决方案里有多个工程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c411ea9cd4e172aea86562ab50d98a18/" rel="bookmark">
			图书管理数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
1、开发背景... 4
2、功能描述... 4
3、业务流程分析... 4
4、数据流程分析... 4
4.1、数据流程图... 4
4.2、数据字典... 5
5、概念模型设计... 7
6. 逻辑模型设计和优化... 7
7. 物理设计和实施... 8
8、应用程序设计（前台）... 10
9、课程设计心得体会... 10
参考文献... 10
一 概述
1.1目的与要求
功能要求：
l 实现图书信息、类别、出版社等信息的管理；
l 实现读者信息、借阅证信息的管理；
l 实现图书的借阅、续借、归还管理；
l 实现超期罚款管理、收款管理；
l 创建触发器，分别实现借书和还书时自动更新图书信息的在册数量；
l 创建视图查询各种图书的书号、书名、总数和在册数；
l 创建存储过程查询指定读者借阅图书的情况；
l 建立数据库相关表之间的参照完整性约束。
90年代中期，由于Internet的迅速普及，使Intranet成为Internet技术在企业管理信息系统中的应用和延伸，形成了集计算机，计算机网络、数据库、分布式计算等于一体的信息技术综合体，它打破了时间和地域的界限，使信息交流变得快捷、准确，为建立现代企业管理信息系统提供了充足的条件。企业信息管理系统在此基础上延伸、扩展，使之上下、内外全面贯通。引入Internet后，形成了新型的浏览器/服务器（Browser/Server）结构,而传统的客户机/服务器（Client/Server）结构在这方面就远不及B/S结构。图书馆管理信息系统是在适应市场需求的客观前提下，为了满足中小型公司或事业单位管理自己的公共图书馆而开发的。该系统的是终目的是要将自己的图书馆放到网络上，以方便员工查阅。
1.2设计环境 ① Microsoft SQL Server2000
② MicrosoftVisual C++ 6.0
二 需求分析
2.1 系统功能要求设计
2、功能描述 （描述该系统所需要完成的功能）
经过调研及分析，图书馆管理信息系统主要完成以下功能：
（1）图书信息维护：主要完成图书馆新进图书的编号、登记、入馆等操作。
（2）读者信息维护：主要是完成读者信息的添加、修改和删除等操作，只有是系统中的合法读者才有资格进行图书的借阅活动。
（3）借书/还书处理：主要完成读者的借书和还书活动，记录读者借还书情况并及时反映图书的在库情况。
（4）读者借阅记录：让每位读者能及时了解自己的借书情况，包括曾经借阅记录以及未还书记录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c411ea9cd4e172aea86562ab50d98a18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d52fcbaec04371f1c74cbb89da57845e/" rel="bookmark">
			OpenWrt安装tcpdump抓包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章摘自：http://demon.tw/hardware/openwrt-tcpdump.html
tcpdump是一个运行在命令行下的嗅探工具，它允许用户拦截和显示发送或收到过网络连接到该计算机的TCP/IP和其他数据包。OpenWrt + tcpdump = 抓包神器。
安装过程很简单：
opkg update opkg install tcpdump 开始抓包：
tcpdump -i any -w all.cap 之后用Wireshark分析，妥妥的。
tcpdump下载地址:http://downloads.openwrt.org/backfire/10.03.1/ar71xx/packages/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffad29c85f3bc075bd88e8fe1db32108/" rel="bookmark">
			UC函数之 open
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数原型：int open(const char pathname,int flag,...);
函数功能：打开或者创建一个文件。
函数头文件：#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
函数返回值：成功返回文件描述符，出错返回 -1
参数说明：pathname： 需要打开或创建的文件名
flag：这个参数可以用来说明此函数的多个选择项，他可以由下面所列取的一个或者多个参数进行“或”运算构成。（这些参数一般定义在&lt;fcntl.h&gt;中）。
O_RDONLY：只读打开
O_WRONLY：只写打开
O_RDWR：读写打开 （注：这三个参数必选其中之一，下面的参数备选）
O_APPEND：写文件时，每次都是写到文件的末尾。
O_CREAT：当文件不存在时，则创建。（注：当使用该参数时，函数的第三个参数应该予以赋值，来说明创建问价的权位）。
O_EXCL：当指定了参数O_CREAT的同时又指定了该参数，则会出错。（可以利用这个性质来判断文件是否存在）。
O_TRUNC：如果文件存在，打开时清空文件内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452642d768c3bf3ea9839323438b5777/" rel="bookmark">
			commons-net FTP大文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近公司要做FTP大文件上传，自己摸索搞了好几天，终于弄好了 以后还能用
package com.uiotsoft.unisiot.util; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.apache.commons.net.ftp.FTP; import org.apache.commons.net.ftp.FTPClient; import org.apache.commons.net.ftp.FTPClientConfig; import org.apache.commons.net.ftp.FTPReply; import java.io.*; import java.net.SocketException; import java.text.SimpleDateFormat; import java.util.Properties; /** * Created by IntelliJ IDEA. * * @author leizhimin 2008-9-12 10:32:39 */ public class FtpConManager { public static Log logger = LogFactory.getLog(FtpConManager.class); private static String userName = "user_mina"; //FTP 登录用户名 private static String password = "123"; //FTP 登录密码 private static String ip = "203.171.237.75"; //FTP 服务器地址IP地址 private static int port = 21; //FTP 端口 private static Properties property = null; //属性集 private static String configFile = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/452642d768c3bf3ea9839323438b5777/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22903da36e51c941855fb42581e8b6e4/" rel="bookmark">
			Android – Google Play issue: “your device isn’t compatible with this version”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		At some point in the last few months changes were made to either or both the ADT plugin for Eclipse and Google Play that rendered my most recent Android application updates “incompatible” with tablets.
After doing a bit of research, I was able to locate 3 items that after adjusting in my applications resolved the new “compatibility” issue with my applications distributed through Google Play on tablets.
1) I added the below lines to the AndroidManifest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22903da36e51c941855fb42581e8b6e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0743e7e113dbbae89292de82b9773743/" rel="bookmark">
			web打印实现几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工作中出现web打印的情况是非常多的，其实这也是一个比较烦人的问题，这篇博客整理一下关于Web打印的一些方法或者方式。
1. window.print()
这个方法是用来打印网页的，页面上的其他的元素也会被打印处理，在打印的时候页眉页脚是不太好控制的。
所以如果使用这种方法的话最好将结果放到两个注释中间，之后通过JS来实现打印区域的功能。
具体做法： &lt;!--startprint--&gt; &lt;div align="center"&gt; &lt;!--省略部分代码--&gt; &lt;/div&gt; &lt;!--endprint--&gt; bdhtml=window.document.body.innerHTML; sprnstr="&lt;!--startprint--&gt;"; eprnstr="&lt;!--endprint--&gt;"; prnhtml=bdhtml.substr(bdhtml.indexOf(sprnstr)+17); prnhtml=prnhtml.substring(0,prnhtml.indexOf(eprnstr)); window.document.body.innerHTML=prnhtml; window.print(); 特别注意：使用window.print方法是不能够打印IE浏览器中的移动或者旋转的动画的，但是在非IE浏览器中是可以支持的。
2. DLPrinter控件
DLPrinter打印控件完全免费，界面大方、使用简单、但无签名，支持打印预览、直接打印，可设置页眉、页脚、页边距、打印份数、纸张大小等信息。 这个控件的下载地址为：http://files.cnblogs.com/panshenglu/DLPrinter.rar
调用方法：
&lt;OBJECT ID="DLPrinter" CLASSID="CLSID:5C230622-45E5-4e3c-893C-3BFDDC4DB5E4" codebase="DLPrinter.cab" height="0" width="0" &gt;&lt;/OBJECT&gt; &lt;script&gt; DLPrinter.MarginLeft=20; DLPrinter.MarginRight=20; DLPrinter.MarginTop=20; DLPrinter.MarginBottom=20; DLPrinter.CopyCount=2; DLPrinter.PageHeader="这是测试的页眉"; DLPrinter.PageFooter="这是测试的页脚"; DLPrinter.IsLandScape=1; DLPrinter.ContentURL="www.baidu.com"; &lt;/script&gt; &lt;input type="button" id="btnPrint" value="Print Preview" οnclick="DLPrinter.PrintPreview()" /&gt; &lt;input type="button" id="btnPrint" value="Print with prompt" οnclick="DLPrinter.Print()" /&gt; &lt;input type="button" id="btnPrint" value="Print without prompt" οnclick="DLPrinter.PrintDirect()" /&gt; 3. Lodop
对于这个打印控件，用一个词来形容：强大！不仅调用方便，而且功能比你想像中要强大得多。强烈推荐使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0743e7e113dbbae89292de82b9773743/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a682f983eb21c8ff2c2ed5296e60ac88/" rel="bookmark">
			Exporting Attachments
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ PeopleSoft provides the File Attachment API for storing, retrieving, and viewing file attachments. These API functions comprise the recommended method for working with attachments. If you want to process an attachment, use the GetAttachment function to move that attachment into a file so you can access it from your app server. The ViewAttachment function, on the other hand, will send a copy of an attachment to a client browser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a682f983eb21c8ff2c2ed5296e60ac88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/774fdf433742f5492f7029627daa18c3/" rel="bookmark">
			Oracle 创建只读用户权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 create user 你的用户名 identified by oracle; 比如这里有两个用户user1和user2，user1下有一个表A，要想user2能查询A表 1、登录user1，授权select给user2：grant select on A to user2 2、登录user2,select * from user1.A; 你也可以创建同义词 create or replace synonym A for user1.A; grant select_catalog_role,create session to 你的用户名; 查任何表 grant select any table to 你的用户名; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2261c5ab159580e2f45e95aac3d3c117/" rel="bookmark">
			无限循环的计时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;html&gt; &lt;head&gt; &lt;script type="text/javascript"&gt; var c=0
var t //写的时候把这两个变量定义给漏了，导致结果出不来，c 必须初始化为0 function timedCount() { document.getElementById('txt').value=c c=c+1 t=setTimeout("timedCount()",1000) } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;input type="button" value="开始计时！" onClick="timedCount()"&gt; &lt;input type="text" id="txt"&gt; &lt;/form&gt; &lt;p&gt;请点击上面的按钮。输入框会从 0 开始一直进行计时。&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ff28d76273fa55abee0647690ecf5eb/" rel="bookmark">
			elasticsearch中一个field多个值如何操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做项目中用到全文检索时遇到这样的需求，有个field的值是多个uuid格式的id组成的字符串，每个id之间用英文逗号分隔，在查询时如果有一个关键字和这个字符串中的一个id一样的话则要取出这个数据。这里要注意，很显然是很难对uuid组成的字符串进行切词的，而且如果uuid很多的情况下使用Lucene的模糊匹配效率也不高。于是我就想了个方案：在创建索引之前就将这个字符串分切成多个id加到同一个field上（还好是Lucene，如果是关系型数据库就不行了），而且不进行分词即可。以下就是涉及到的技术，没有多少技术含量，但是网上关于elasticsearch这方面资料少，反正我是没有查到，经过试验算是搞定了。废话少说：
首先，在Lucene中，如果我们可以在一个Field中加入多个值，比如：
doc.add(new Field("name","北京",Store.YES,Field.Index.NOT_ANALYZED));
doc.add(new Field("name","新德里",Store.YES,Field.Index.NOT_ANALYZED));
这样，当我们针对“name”这个field进行搜索时，如果搜索的关键字是“北京”或者“新德里”则当前这个Document都会被搜索到，这个是Lucene不同于关系型数据库的地方。
那么基于Lucene上的分布式全文索引elasticsearch如何做到呢？经过试验可以使用类似于如下的方式创建索引：
XContentBuilder doc = XContentFactory.jsonBuilder(); //整个每次循环都需要创建一个，否则会在startObject时报空指针
//添加属性，相当于添加表的字段的值
doc.startObject();
//获取id，如果存在的话
String idValue = null;
for(String field : contextObject.keySet()) {
Object[] values = contextObject.get(field);
//如果是同一个field下多个值，则全部加入到同一个field下
if(null != values &amp;&amp; values.length &gt; 1) {
doc.array(field, values);
} else {
String formatValue = this.formatInsertData(values);//格式化处理值
try {
if(StringUtils.isNotEmpty(idFieldName) &amp;&amp; idFieldName.equals(field)) {
idValue = formatValue;
}
doc.field(field, formatValue);
} catch (IOException e) {
this.logger.error(e.getMessage());
return false;
} } }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ff28d76273fa55abee0647690ecf5eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f08c2adaa7a387cc0383987bd7cf56/" rel="bookmark">
			bitwise const
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class CTextBlock { public: ... char&amp; operator[](std::size_t position) const // inappropriate (but bitwise { return pText[position]; } // const) declaration of // operator[] private: char *pText; };
const CTextBlock cctb("Hello"); // declare constant object char *pc = &amp;cctb[0]; // call the const operator[] to get a // pointer to cctb's data *pc = 'J'; // cctb now has the value "Jello" class CTextBlock { public: ... std::size_t length() const; private: char *pText; std::size_t textLength; // last calculated length of textblock bool lengthIsValid; // whether length is currently valid }; std::size_t CTextBlock::length() const { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56f08c2adaa7a387cc0383987bd7cf56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/719cb102a163a53b80c3c29a1a74b5b8/" rel="bookmark">
			malloc函数与free函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		malloc函数与free函数
malloc函数
Malloc 向系统申请分配指定size个字节的内存空间。返回类型是 void* 类型。void* 表示未确定类型的指针。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。
1函数简介
原型
extern void *malloc(unsigned int num_bytes);
头文件
在TC2.0中可以用malloc.h或 alloc.h (注意：alloc.h 与 malloc.h 的内容是完全一致的)，而在Visual C++6.0中可以用malloc.h或者stdlib.h。
功能
分配长度为num_bytes字节的内存块
返回值
如果分配成功，则返回指向被分配内存的指针(此存储区中的初始值不确定)；否则返回空指针NULL。当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。
说明
关于该函数的原型，在旧的版本中malloc返回的是char型指针，新的ANSIC标准规定，该函数返回为void型指针，因此必要时要进行类型转换。
名称解释
malloc的全称是memory allocation，中文叫动态内存分配，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存。
相关函数
calloc、realloc、free、_alloca
2函数声明
全名
void *malloc(size_t size);
备注
void* 表示未确定类型的指针，void *可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者...）。
3与new的区别
从函数声明上可以看出。malloc 和 new 至少有两个不同：new 返回指定类型的指针，并且可以自动计算所需要大小。比如：
int *p;
p = new int; //返回类型为int* 类型(整数型指针)，分配大小为 sizeof(int);
或：
int* parr;
parr = newint[100]; //返回类型为 int* 类型(整数型指针)，分配大小为 sizeof(int) * 100;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/719cb102a163a53b80c3c29a1a74b5b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/663a02317a7404d067381032ac9b3be3/" rel="bookmark">
			IOS webView播放视频时进入页面自动播放的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 主要解决用urlStr通过 webView 去播放视频时进入界面就自动播放的问题 NSString *htmlStr = [NSString stringWithFormat: @"&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;video src=\"%@\" controls=\"controls\"&gt; 该浏览器不支持 &lt;/video&gt; &lt;/body&gt; &lt;/html&gt;",urlStr]; [self.videoView loadHTMLString:htmlStr baseURL:nil]; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1320bebdca232536f3a14acc530ff2c1/" rel="bookmark">
			由于达到了总登录时间限制，远程回话被结束。这个限制是服务器管理员或网络策略设置的。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程桌面连接会话超时或者被限制改组策略也没用的时候就这么解决
今天管理一台服务器，远程连接时帐号密码都输入完后，点连接后弹出一个 “终端服务器超出最大允许连接”。上网查了一下归结一下出现这 种情况的原因和解决办法。
原因:用 远程桌面链接登录到终端服务器时经常会遇到“终端服务器超出最大允许链接数”诸如此类错误导致无法正常登录终端服务器，引起该问题的原因在于终端服务的缺 省链接数为2个链接，并且当登录远程桌面后如果不是采用注销方式退出，而是直接关闭远程桌面窗口，那么实际上会话并没有释放掉，而是继续保留在服务器端， 这样就会占用总的链接数，当这个数量达到最大允许值时就会出现上面的提示。
如何避免？
一、用注销来退出远程桌面而不是直接关闭窗口
二、限制已断开链接的会话存在时间
1、从终端服务配置中修改
运行－Tscc.msc(终端服务配置)－连接－双击RDP-Tcp或右击－属性－会话－选中第一个的替代用户设置(O)－结束已断开的会话［将默认值“从不”改为一个适当的时间，比如30分钟］
2、从组策略修改
开始－运行－gpedit.msc－计算机配置－管理模板－windows组件－终端服务－会话
右边窗口选择 为断开的会话设置时间限制 －选择已启用，选择一个时间
三、增加最多链接数 1、 从终端服务配置中修改：运行－Tscc.msc(终端服务配置)－连接－双击RDP-Tcp或右击－属性，选择“网卡”选项卡－修改“最大连接数”改成你 所需的值，当然这个值不也能太大，否则会占用较多的系统资源。不过这里修改的值好像不起作用，设置成无限制时照样还是会出现本文所说的情况。 2、组策略级别要高于终端服务配置，当启用组策略后终端服务配置中的相应选项会变成灰色不可修改
运行－gpedit.msc－计算机配置－管理模板－Windows组件－终端服务双击右边的”限制连接数量“－选择”已启用“－填入允许的最大连接数
四、改变远程终端模式
打开“控制面板”，双击“添加删除程序”，单击“添加删除Windows组件”,“组件”，在Windows组件向导对话框中选中“终端服务” , “下一步”,“应用服务器”,“下一步”，然后按照提示即可改变终端服务的模式。 Windows 2000终端服务有2种运行模式: 远程管理模式和应用程序服务器模式。远程管理模式允许系统管理员远程管理服务器，而且只允许2个终端会话同时登录终端服务器。应用程序服务器模式允许用户 运行一个以上应用程序，允许多个用户从终端登录访问服务器。但是，应用终端服务的用户必须有终端服务授权，即必须在90天之内在这个域或工作组中设置终端 服务授权服务器，否则用户需删除应用程序，然后再重新安装。
五、修改本地安全策略
控制面板&gt;&gt;管理工具&gt;&gt;本地安全策略&gt;&gt;本地策略&gt;&gt;安全选项&gt;&gt;
1、先找到&gt;&gt;Microsoft网络服务器:在挂起会话之前所需的空闲时间默认为:15分钟,改为自己所需要的时间(就是登陆后无动作空闲超过多少时间后自动断开)
2、然后找到&gt;&gt;网络安全:在超过登录时间后强制注销。默认为:已禁用,一定要改为:已启用
如果已经发生解决办法： 1、首先你可以telnet到此主机上(不管你用哪种方法)，当然如果能直接操作机器更好，不过直接操作就不必用命令行了，那当然是知道机器超级管理员的密码的情况下，可以使用OpenTelnet来打开远程服务器的Telnet端口。
2、Telnet上去后,先看登陆的用户： 输入命令：query user 系统返回： C:&gt;query user
USERNAME?SESSIONNAME?ID?STATE?IDLE TIME?LOGON TIME
k12update?console?1?运行中?2007-3-14 14:57 此时可以看出的可能都不一样，根据具体情况而定。 ID 0 的用户是本地登陆的,ID 1 和 ID 12是3389登陆的用户,前者在运行中，后者已经断开了,但是断开了仍然占用系统资源和通道，我们要把它踢掉。如下进行操作即可。 输入命令：logoff 1 3、如果服务器关闭了telnet功能（这是默认的），还可以通过SqlServer的xp_cmdshell扩展存储过程，使用格式：master.dbo.xp_cmdshell '
命令内容'，其余可参考第二步。此方式要求有访问xp_cmdshell的权限
上面的解决办法基本没有用 后来我用 服务器终端服务器超出最大允许连接数时，以前考虑用冷启动服务器，但这样必须跑一趟机房，最近发现最好的办法就是在“运行”命令行里输入：mstsc /console /v:你的服务器IP:远程端口，测试有效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b53129d51099c1cc617876b61941a77/" rel="bookmark">
			jSP页面中给变量赋值方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果在一个jsp页面中，前面需要先给某个或者某些变量赋值，后面在某个地方调用，可以采用的方法：
第一种：
&lt;% int age = 30;
request.setAttribute("age",new Integer(age)); %&gt;
第二种：
package com.test;
public class Person {
private int age;
private String name;
public int getAge() {
return age;
}
public void setAge(int age) {
this.age = age;
}
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
}
&lt;jsp:useBean id="per" class="com.test.Person"/&gt;
&lt;jsp:setProperty name="per" property="age" value="50"&gt;
&lt;jsp:setProperty name="per" property="name" value="某某某"&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b55aed0785ba8c637bb53eaa16b19f3f/" rel="bookmark">
			【Android高级】查看手机及应用内存状况的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我 们知道，android程序内存一般限制在16M，当然也有24M的，而android程序内存被分为2部分：native和dalvik，dalvik 就是我们平常说的java堆，我们创建的对象是在这里面分配的，而bitmap是直接在native上分配的，对于内存的限制是 native+dalvik 不能超过最大限制。 1.单个app 内存限制大小
[java] view plain copy ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); activityManager.getMemoryClass(); 2."/proc/meminfo" 系统内存信息文件 【整个系统的内存情况】 Android获取手机总内存和可用内存
“/proc/meminfo”解析
3.ActivityManager.MemoryInfo【整个系统】
availMem 剩余内存
threshold 临界值 【超过次值就开始杀死后台服务和没有关联的进程】
lowMemory 低内存状态
4.android.os.Debug
getNativeHeapFreeSize()
getNativeHeapAllocatedSize()
getNativeHeapSize()
5.android.os.Debug.MemoryInfo【当前进程的内存情况】
6.Runtime totalMemory() freeMemory() maxMemory() 7.VMRuntime getTargetHeapUtilization() getMinimumHeapSize() getExternalBytesAllocated() 应该是外部分配的内存Native内存 8.GC_EXTERNAL_ALLOC freed 与 GC_EXPLICIT freed 是什么? 系统GC释放的内存提示 一般在LOG里面显示如下： 09-28 17:16:37.543: DEBUG/dalvikvm(21466): GC_EXTERNAL_ALLOC freed 390 objects / 45656 bytes in 50ms
09-28 17:16:40.513: DEBUG/dalvikvm(3267): GC_EXPLICIT freed 4501 objects / 251624 bytes in 67ms
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b55aed0785ba8c637bb53eaa16b19f3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95b62d47c7c7bc8071b4bb585cf6567f/" rel="bookmark">
			【线性代数】正交投影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在初中就应该学过投影，那么什么是投影呢？形象点说，就是将你需要投影的东西上的每一点向你要投影的平面作垂线，垂线与平面的交点的集合就是你的投影。注意这里我们的投影是向量的投影，几何的投影(并不一定是垂直投影的)可见度娘百科。同样的，我们从简单的二维投影来开始讨论。 1、二维投影 上图表示的是，向量b在向量a上的投影。显然有如下表达式：
其中，P为投影矩阵，由P的表达式可以看出，它具有如下性质：
2、三维投影 三维投影，就是将一个向量投影到一个平面上。同上面一样，假设是将b向量投影到平面上的p向量，则有表达式： e是垂直与平面的向量。由于p向量在平面上，则p向量可以由该平面的2个线性无关向量(正如，在xy平面的任何向量都可以由x轴，y轴表示)表示： 由于e垂直平面，则e向量垂直与平面中的任意向量，则有：
将上式化简求得x：
又因为p=Ax，Pb=p，则得到投影矩阵为：
由P的表达式可以看出，它具有如下性质：
上面的投影矩阵是通式，当投影在一维情况时，A即为直线上的任意一个向量a,投影矩阵为：
注意：一个数值的逆是它的倒数。 3、举例说明 下面以一个实例来说明： 如上图，假设我们要将向量b投影到水平面上，其投影为p，a1,a2为水平面的两个线性无关向量，它们的参数分别为：
那么A=[a1 a2]即：
由上面我们求得的通式，可得投影矩阵P:
知道投影矩阵P后，我们可以得到b在水平面上的投影p为：
显然，p与我们图中所示的结果相同。这里我们是以三维情况进行举例的，更高维情况，我们无法用图像来描述，但是通式也是成立的。 三维图的matlab程序如下：
clear all clc a1=[1 0 0]; a2=[0 1 0]; b=[1 1 1]; p=[1 1 0]; e=b-p; quiver3(0,0,0,a1(1),a1(2),a1(3),1,'color','r') hold on quiver3(0,0,0,a2(1),a2(2),a2(3),1,'color','r') hold on quiver3(0,0,0,b(1),b(2),b(3),1,'color','g') hold on quiver3(0,0,0,p(1),p(2),p(3),1,'color','g') hold on quiver3(p(1),p(2),p(3),e(1),e(2),e(3),1,'color','b') 原文：http://blog.csdn.net/tengweitw/article/details/41174555
作者：nineheadedbird
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/322466bb9e2e8cfd3b1b78a8fb681e98/" rel="bookmark">
			tar -xzf和tar -cvf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		周五深夜11点，我现在心情极差。原因是我本想将手头的工作打个包带回家继续做，却顺手用了这个命令：
tar -xzf XXX.tar.gz XXX/
用老的XXX.tar.gz压缩包里的文件把XXX/目录中我这半周的工作全覆盖了！！！！
tar -xzf和tar -czf，一字之差……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45228bf233c7e2fbbe475c9488d4bd2c/" rel="bookmark">
			关于sscanf（）处理字符串的总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先应该注意的是 sscanf()只能对字符数组进行操作，但是不能对string字符串操作
（1）最简单的其实是默认的用法，比如
sscanf(ch,"%s%s",a,b); 其中a,b为字符数组，最简单的分割方式
（2）分割含有整数的时候比较简单也很好用：
基本用法：
scanf("%d+%d",&amp;a,&amp;b);
sscanf(c,"%d+%d=%d",&amp;m,&amp;n,&amp;p）直接这样用就行
（2）下面的一种是遇到特定的字符(暂时scanf（）还不知道怎么实现该作用)
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;int main(){char a[20]="" ,b[20]="" ;char ch[100];while(1){cin.getline(ch,100);//scanf("%s+%s",a,b);sscanf(ch,"%s + %s",a,b);//如果是两个字符串的话，并且输入的时候必须是... + ...//如果没有空格的话就换到另一数组的话,只能是下面的这种方式// sscanf(ch,"%[a-z]+%[a-z]",a,b);cout&lt;&lt;"**********"&lt;&lt;a&lt;&lt;"************"&lt;&lt;b&lt;&lt;"**********";}return 0;}参考：
int a, b, c; sscanf("2006:03:18", "%d:%d:%d", a, b, c); 以及2006:03:18 - 2006:04:18: char sztime1[16] = "", sztime2[16] = ""; sscanf("2006:03:18 - 2006:04:18", "%s - %s"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45228bf233c7e2fbbe475c9488d4bd2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74383bf85d384e784838077e7c98480b/" rel="bookmark">
			HTML5&#43;Canvas&#43;jQuery调用手机拍照功能实现图片上传（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇只讲到前台操作，这篇专门涉及到Java后台处理，前台通过Ajax提交将Base64编码过的图片数据信息传到Java后台，然后Java这边进行接收处理，通过对图片数据信息进行Base64解码，之后使用流将图片数据信息上传至服务器进行保存，并且将图片的路径地址存进数据库。
大家可以点此链接查看前台本地压缩上传的处理：
HTML5+Canvas+jQuery调用手机拍照功能实现图片上传（一）
ok,废话不多说了，直接贴代码吧。
1、前台js代码：
$.ajax({ async:false,//是否异步 cache:false,//是否使用缓存 type: "POST", data:{fileData:fileData,licenceName:licenceName,cust_tax_code:cust_tax_code,phoneNum:phoneNum,state_id:state_id}, dataType: "json", timeout: 1000, contentType : 'application/x-www-form-urlencoded; charset=utf-8', url: $('#ctx').val()+"CustomerCheckServlet?action=uploadLicence", success: function(result){ console.log(result); if(result == true){ alert('Success Upload~~~'); }else if(result == false){ alert('Error Upload~~~'); } }, error: function(){ alert("Error Linking~"); } }); 2、后台Java代码 /** * 证件上传 * @param request * @param response * @throws IOException */ public void uploadLicence(HttpServletRequest request,HttpServletResponse response) throws IOException{ log.info("=====================uploadLicence"); df = new SimpleDateFormat("yyyy-MM-dd"); String cust_tax_code = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74383bf85d384e784838077e7c98480b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7508c519c4cdd6b28c6ada44415e2ce/" rel="bookmark">
			文件服务器同步解决方案rsync
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rsync实现文件同步
工作模型 一台作为server端一台最为client端，client把数据差异同步到server上。从而实现数据的同步。
1.在server端和client上分别安装
yum install rsync -y
2.为server端提供配置文件 vim /etc/rsyncd.conf
uid = root//如果是nobody的话后期再同步的时候会有一些文件无法同步会有权限的问题
gid = root//同上
use chroot = no
max connections = 200
#strict modes = yes
timeout = 100
lock file = /var/run/rsync.lock
pid file = /var/run/rsyncd.pid
log file = /var/log/rsyncd.log
[my]
path = /wcf/ //指定要同步的目录接收地址
ignore errors
read only = no
#write noly = no
hosts allow = 172.1.0.0/16
hosts deny = 0.0.0.0/32
list = false
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7508c519c4cdd6b28c6ada44415e2ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a7dbb2eba8d1771e75046ceaaef7c40/" rel="bookmark">
			数学软件Maple使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数学实验 数学软件Maple使用教程 序言 一．什么是数学实验？
我们都熟悉物理实验和化学实验，就是利用仪器设备，通过实验来了解物理现象、化学物质等的特性。
同样，数学实验也是要通过实验来了解数学问题的特性并解决对应的数学问题。过去，因为实验设备和实验手段的问题，无法解决数学上的实验问题，所以，一直没有听说过数学实验这个词。随着计算机的飞速发展，计算速度越来越快，软件功能也越来越强，许多数学问题都可以由计算机代替完成，也为我们用实验解决数学问题提供了可能。
数学实验就是以计算机为仪器，以软件为载体，通过实验解决实际中的数学问题。
二．常用的数学软件
目前较流行的数学软件主要有四种：
1． MathACD
其优点是许多数学符号键盘化，通过键盘可以直接输入数学符号，在教学方面使用起来非常方便。缺点是目前仅能作数值运算，符号运算功能较弱，输出界面不好。
2． Matlab
优点是大型矩阵运算功能非常强，构造个人适用函数方便很方便，因此，非常适合大型工程技术中使用。缺点是输出界面稍差，符号运算功能也显得弱一些。不过，在这个公司购买了Maple公司的内核以后，符号运算功能已经得到了大大的加强。再一个缺点就是这个软件太大，按现在流行的版本5.2，自身有400多兆，占硬盘空间近1个G，一般稍早些的计算机都安装部下。我们这次没用它主要就是这个原因。
3． Mathematica
其优点是结构严谨，输出界面好，计算功能强，是专业科学技术人员所喜爱的数学软件。缺点是软件本身较大，目前流行的3.0版本有200兆；另一个缺点就是命令太长，每一个命令都要输入英文全名，因此，需要英语水平较高。
4． Maple
优点是输出界面很好，与我们平常书写几乎一致；还有一个最大的优点就是它的符号运算功能特别强，这对于既要作数值运算，又要作符号运算时就显得非常方便了。除此之外，其软件只有30兆，安装也很方便(直接拷贝就可以用)。所以，我们把它放到学校网上直接调用。缺点就是目前市面上买不到教材，帮助系统又是英语，为学习带来了不便。因为条件的限制，其它几个软件不便于介绍，所以我们把我们对该软件的了解编写成讲义发给同学们作参考。
第一章 Maple软件的安装与启动 一． Maple的安装启动
1．目前市面上出售的Maple软件一般是与其它数学软件在一张光盘上，安装时只要将光盘上Maple目录全部拷贝到硬盘上就可以了。
2．在学校网络主页通过文件下载ftp内的17cai目录，找到maple点击，将其下载到计算机上并解压，即安装完毕。
启动Maple，首先进入Maple目录下的子目录BIN，找到枫叶图标(下面有Wmaple)，点击图标就可启动。也可以将该图标拷贝到桌面点击启动。
二．Maple工作面
maple工作面提示符用来输入maple命令。提示符[&gt;左边的[号表示所要一起执行的命令区，该区的命令将按先后次序连续一次执行完。若点击工具栏中T按钮，则提示符箭头消失，变为[号，表示当前为文本输入，工具栏也出现相应的字号字体选择框；常用工具栏中(从左到右)有新建、打开、保存、打印、剪切、复制、粘贴、撤消、Maple输入转换、文体输入转换、增加命令区、撤消分组、建立分组、停止运行及三个显示比例选择x按钮。点击提示符按钮将增加一个命令区；当将几个命令区及文本输入抹黑，点击建立分组，就会将抹黑部分分在一组，并出现一个分组标志，点击标志可以打开、关闭该组；点击并排的三个x按钮控制显示比例。
三．退出工作面并保存文件
1．点击文件菜单exit或键盘alt+F4或点击窗口右上角×，这时系统要提示：是否存盘？点击‘是’，则自动存盘。如果是第一次使用这个文件，则要出现一个对话框，选择存盘目录并输入文件名称。
2．命令 quit done stop 也可退出maple。注意!这三个退出命令不保存文件,不要随便用。
3．作业中存盘，可以用文件菜单的保存，也可以用工具栏的软盘图标保存。最好在操作一段后就保存一次，避免意外情况产生损失。
第二章 基本命令 命令的执行：1.每条命令必须用“：”(执行后不显示)或“；”(执行并显示)结束，否则被认为命令没输完。2.命令区中“#”号以后为命令注释(不执行)。3.光标在命令区的任何位置回车，都会依次执行该命令区所有命令。
&gt; 2+3 #没有结束符，执行后会显示警告:语句没输完
Warning, incomplete statement or missing semicolon
&gt; 2+3; 会输出执行结果
&gt; 2+3: 不会输出执行结果，但结果可用作以后计算使用
寻求帮助：
1.从Help(帮助)菜单按类查找。
2.？后接命令(可以是命令的前几个字母)或help(命令)查找。
&gt; ?plot #查找作图命令的帮助
&gt;?plo #plot的前三个字母
&gt;help(plot);
3． 查找命令内容
info(命令)；查找函数作用 usage(命令)；查找调用格式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a7dbb2eba8d1771e75046ceaaef7c40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd231f4ff0179876ec5e2a8f379b15c4/" rel="bookmark">
			逻辑判断的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*
------------用于逻辑判断的常用代码
//判断viewController是否属于OneViewController类的类或子类
[viewController isKindOfClass:[OneViewController class]
//判断对象是否遵循了协议
[viewController conformsToProtocol:@protocol(&lt;#protocol-name#&gt;)];
//判断释放遵循了某方法
[viewController respondsToSelector:&lt;#(SEL)#&gt;];
*/
//判断viewController是否属于OneViewController类的对象，如果是，每点击一次， badgeValue值 加 1
if ([viewController isMemberOfClass:[OneViewController class]]) {
viewController.tabBarItem.badgeValue = [NSStringstringWithFormat:@"%d",++flag];
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47f05b7f9bc814afcd77bab245a817a4/" rel="bookmark">
			百度地图无法通过审核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 因为在项目使用百度地图的时候会在Document里生成cfg文件，大小大概800k，随着百度地图sdk的运行似乎还会增加大小。 就是因为这个cfg，AppStore拒绝了我的应用。理由是2.23（很长的一段英文，大意就是嫌放在iCloud里的非用户文件太大）。我的文件明明是放在Document里的怎么就冒出了一个iCloud？其实ios默认情况下，放在Document的文件是会被上传到iCloud里进行备份的！！ 因为百度地图的cfg文件是放在Document里的，所以我们得把默认上传Document文件到iCloud里的属性关闭。 具体代码如下： 开始前，记住要导入一个东西 [代码]c#/cpp/oc代码： 1 #include &lt;sys/xattr.h&gt;//导入该框架用于防止相应文件的云储存iCloud 实现代码 [代码]c#/cpp/oc代码： 01 //关闭iCloud的方法，直接拷贝就能用 02 - (void)addSkipBackupAttributeToPath:(NSString*)path { 03 u_int8_t b = 1; 04 setxattr([path fileSystemRepresentation], "com.apple.MobileBackup", &amp;b, 1, 0, 0); 05 } 06 07 - (void)viewDidLoad 08 { 09 [super viewDidLoad]; 10 //为Document文件设置不iCloud存储属性，防止AppStore审核无法通过2.23条款 11 NSString *notBackUpPathDoc = nil; 12 notBackUpPathDoc = [NSString stringWithFormat:@"%@/Documents/",NSHomeDirectory()]; 13 [self addSkipBackupAttributeToPath:notBackUpPathDoc]; 14 15 NSString *notBackUpPathCach = nil; 16 notBackUpPathCach = [NSString stringWithFormat:@"%@/Library/Caches/",NSHomeDirectory()]; 17 [self addSkipBackupAttributeToPath:notBackUpPathCach]; 18 19 20 } ok，这个方法和官方提供的方法不太一样，不过挺奏效的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8904c9852695a2f1889ee45480dc505d/" rel="bookmark">
			找回回收站已删除的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在平时，只要用过电脑的都知道回收站可以回收我们不要的垃圾，只要一键便可以轻而易举的删除，方便快捷。但你是否一两次不注意删除错文件，却不知如何去恢复它，所以在埋怨电脑公司为什么要设置个回收站呢？但你试过几天不用回收站的后果么？ 还记得曾有一段时间我也信誓旦旦地说，再也不用回收站，总给我带来麻烦，害我总要重新下载或写，麻烦死了。但是没用回收站的那段日子好麻烦，垃圾堆满计算机，启动时好慢哦，最后不得不重新启用回收站。所以你们可别随意跟回收站赌气，不然吃亏的可是你。 还记得某次，我在网上接了个手打文章的任务，1000字能有2元钱呢，就是雇主把需要打的文章用照片的方式 发给你，然后你便把照片里的文字打出来。那时我的打字速度不能喝现在比拟，很慢很慢。一天打字打得半死，也只有1万字，我的打字速度就是在那次练出来的。我那时总习惯把打好的文章放在桌面上，堆得桌面满满的。一天，我家那白痴老哥，看电脑桌面那么乱，把我的文章一股脑给删除了。等我发现桌面空空，找遍全盘兜找不到，我急的快哭了，那可是有好几天的量呢。 我问家人有没碰见过我那些文件，老哥说“被我删除了。”“哥，你这个白痴，那可是我的工作，你赔我。”“乖，别气，我这帮你找回。”“你要是找不回，你就帮我把那些你删除的在重新写一遍。”于是哥哥只好去群里找他的狐朋狗友求助，刚好有哥哥一好友了解这个，他告诉哥哥好几款软件可以恢复回收站错删的文件，可是他却没用过，于是他说:“阿白，你最好去看看他们的用户评价，介绍，再下载其中一款你认为较好的。”于是哥哥登上他们的官网，看了看他们的用户评价及介绍最终决定下载龙腾回收站恢复软件。下载后，哥哥安装，按照他们的步骤来恢复那些他错删的文件，最终那些文件成功找回来了。“妹妹，你看都找回来了，你别气了，我又不是故意的，谁让你随意把那些文件放在桌面，也不整理，我看着乱，当然就删了。”“你就不能看看那些文件有用没，在删，妈妈说的不错，你就是一个马大哈。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c34ca311b026f6282f504cbf3bec16/" rel="bookmark">
			socket 错误码errno
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EINTR： 4 阻塞的操作被取消阻塞的调用打断。如设置了发送接收超时，就会遇到这种错误。 只能针对阻塞模式的socket，非阻塞模式不会出现这个错误。读，写阻塞的socket时（recv，send），-1返回，错误号为EINTR，说明在数据传输前接收到一个信号（A signal occurred before any data was transmitted.）。出现这种情况，操作应该继续。如果recv的返回值为0，那表明连接已经断开，接收操作应该结束。
对于socket接口(指connect/send/recv/accept..等等，后面不重复，不包括不能设置非阻塞的如select)，在阻塞模式下有可能因为发生信号，返回EINTR错误，由用户做重试或终止。 但是，在非阻塞模式下，是否出现这种错误呢？ 对此，重温了系统调用、信号、socket相关知识，得出结论是：不会出现。 首先， 1.信号的处理是在用户态下进行的，也就是必须等待一个系统调用执行完了才会执行进程的信号函数，所以就有了信号队列保存未执行的信号 2.用户态下被信号中断时，内核会记录中断地址，信号处理完后，如果进程没有退出则重回这个地址继续执行 socket接口是一个系统调用，也就是即使发生了信号也不会中断，必须等socket接口返回了，进程才能处理信号。 也就是，EINTR错误是socket接口主动抛出来的，不是内核抛的。socket接口也可以选择不返回，自己内部重试之类的.. 那阻塞的时候socket接口是怎么处理发生信号的? 举例 socket接口，例如recv接口会做2件事情， 1.检查buffer是否有数据，有则复制清除返回 2.没有数据，则进入睡眠模式，当超时、数据到达、发生错误则唤醒进程处理 socket接口的实现都差不了太多，抽象说 1.资源是否立即可用，有则返回 2.没有，就等... 对于 1.这个时候不管有没信号，也不返回EINTR，只管执行自己的就可以了 2.采用睡眠来等待，发生信号的时候进程会被唤醒，socket接口唤醒后检查有无未处理的信号(signal_pending)会返回EINTR错误。 所以 socket接口并不是被信号中断，只是调用了睡眠，发生信号睡眠会被唤醒通知进程，然后socket接口选择主动退出，这样做可以避免一直阻塞在那里，有退出的机会。非阻塞时不会调用睡眠。 参考：http://willko.iteye.com/blog/1691741
EAGAIN 11：
从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返 回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。 又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。 1、非阻塞socket，send返回值小于要发送的数据数目，可能会返回EAGAIN或者EINTR。 2、非阻塞socket，如send返回EAGAIN错误，表示数据没有完全写入发送缓冲区，但是发送缓冲队列已满，可以做延时后再重试。 3、非阻塞socket，recv时，经常出现Resource temporarily unavailable，返回值-1，errno代码为11(EAGAIN)。表明在非阻塞模式下调用了阻塞操作，在该操作没有完成就返回这个错误，这个错误不会破坏 socket的同步，不用管它，下次循环接着recv就可以（注意：对于普通socket和LT模式的epoll的非阻塞socket是继续recv和send）。对非阻塞socket而言，EAGAIN不是一种错误。在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。
在epoll的ET模式下，非阻塞socket，出现EGAIN就是读数据结束了，不能用循环抱住recv，即不能在出现EAGAIN时，马上接着循环recv，因为下一次还会是EAGAIN，这样会陷入死循环。这种情况下出现EAGAIN，表示读或者写已经完成。（已亲测）
4、使用epoll网络模型，单用户的情况下客户端和服务器通信正常。但是在多用户并发的情况下，客户端和服务端通信不正常。此时，客户端能正常的链接，发送数据，但是一直卡在接收数据部分？为什么？
因为在ET模式socket非阻塞的情况下，多个连接同时到达，服务器的TCP就绪队列瞬间积累多个就绪连接，由于是边缘触发模式，epoll只会通知一次，accept只处理一个连接，导致TCP就绪队列中剩下的连接都得不到处理。因此，就出现了上面的问题。
解决办法是用while循环抱住accept调用，处理完TCP就绪队列中的所有连接后再退出循环。如何知道是否处理完就绪队列中的所有连接呢？accept返回-1并且errno设置为EAGAIN就表示所有连接都处理完。
ETIMEOUT：110 1、操作超时。一般设置了发送接收超时，遇到网络繁忙的情况，就会遇到这种错误。 2、服务器做了读数据做了超时限制，读时发生了超时。 3、错误被描述为“connect time out”，即“连接超时”，这种情况一般发生在服务器主机崩溃。此时客户 TCP 将在一定时间内（依具体实现）持续重发数据分节，试图从服务 TCP 获得一个 ACK 分节。当最终放弃尝试后（此时服务器未重新启动），内核将会向客户进程返回 ETIMEDOUT 错误。如果某个中间路由器判定该服务器主机已经不可达，则一般会响应“destination unreachable”－“目的地不可达”的ICMP消息，相应的客户进程返回的错误是 EHOSTUNREACH 或ENETUNREACH。当服务器重新启动后，由于 TCP 状态丢失，之前所有的连接信息也不存在了，此时对于客户端发来请求将回应 RST。如果客户进程对检测服务器主机是否崩溃很有必要，要求即使客户进程不主动发送数据也能检测出来，那么需要使用其它技术，如配置 SO_KEEPALIVE Socket 选项，或实现某些心跳函数。 EPIPE： 1、Socket 关闭，但是socket号并没有置-1。继续在此socket上进行send和recv，就会返回这种错误。这个错误会引发SIGPIPE信号，系统会将 产生此EPIPE错误的进程杀死。所以，一般在网络程序中，首先屏蔽此消息，以免发生不及时设置socket进程被杀死的情况。 2、write(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14c34ca311b026f6282f504cbf3bec16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea571adccfd557b401042f5e767d668d/" rel="bookmark">
			labview 隐藏控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在程序框图里， 第一种方法：选中控件，右键——显示/隐藏控件 第二种方法：通过布尔量控制 第一步：创建属性节点： 点击控件 ——右键—— 创建——属性节点——可见，生成这个东西：。然后把生成的东西右击——转换为写入：。第二步：创建常量： 程序框图——右键——布尔——假常量：第三步：将假常量连接到属性节点： 完成，切换到前面板，运行一次，控件已经消失。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f8a68512875bf250be11473b81b8f53/" rel="bookmark">
			ERP咨询顾问的四大必备技能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文地址: http://www.chinaerp.org/a/ERPzhishi/2014/0829/376.html ERP咨询顾问主要做以下四个方面工作： 1、掌握联系： ERP咨询顾问工作的重点不是产品技术，而是掌握以下三个方面的联系：在学习ERP产品过程中关键在于透析各模块之间的联系，在实施ERP系统过程中重在理解企业经营管理中各个部门各业务之间的联系，在与客户单位各层次用户的交往和沟通中注意洞悉角色与角色、人与人之间的关系。 2、创新思维：不同的行业不同的客户，其业务需求也各不一样，这就需要 ERP咨询顾问去了解现状、发现问题、分析需求、然后再设计未来目标流程和系统解决方案，需要 ERP咨询顾问将特定的ERP产品功能与管理需求进行创造性地结合，需要 ERP咨询顾问进行创新思维。 3、沟通表达： ERP咨询顾问不仅要了解产品功能结构的原理，感知环境和需求的变化、收集和学习相关行业业务知识、制定满足客户需求的系统解决方案，而且要将这些内容通过某种形式简明清晰而生动形象地表达出来，与客户单位有关人员进行沟通和交流，对关键人员进行培训和引导，让客户单位领导和用户理解和接受，最终获得客户单位有关人员的支持和协作。 4、经历实践： ERP咨询顾问不仅要将用户需求及满足用户需求的解决方案简单直观地表达出来，而且要根据产品特性和系统解决方案为客户单位配置一个强大而灵活的信息处理系统和信息交流平台，从而帮助客户单位实现企业信息化目标。对于参与项目实践的咨询顾问来说，无异于举办一次大型企管演习。 总之，ERP咨询顾问的工作就是不断地再学习，而且是在学习一个人一生中很重要很关键的课程——如何透析联系、如何创新思维、如何管理企业、如何赚取利润，从而为自己未来独立创业奠定良好的基础。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54e17cdf77ebaea0cf21f9bcf7944af2/" rel="bookmark">
			开发库 整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像： 1.图片浏览控件MWPhotoBrowser 实现了一个照片浏览器类似 iOS 自带的相册应用，可显示来自手机的图片或者是网络图片，可自动从网络下载图片并进行缓存。可对图片进行缩放等操作。
下载：https://github.com/mwaterfall/MWPhotoBrowser 目前比较活跃的社区仍旧是Github，除此以外也有一些不错的库散落在Google Code、SourceForge等地方。由于Github社区太过主流，这里主要介绍一下Github里面流行的iOS库。 首先整理了一份 Github上排名靠前的iOS库(大概600个repos) 除了逛一下每日/每月流行之外，也可以到 这里来看一下整个iOS Repos的排名。 下面是一些比较流行的第三方库： HTTP 相比较之下, AFNetworking是目前最优秀的一个了：轻量、易用、使用者多、开发者有在积极维护。在AFN出现之前，这个角色是由ASIHTTPRequest扮演的，只是到现在年久失修了。关于AFN和ASI的对比，这里有一篇不错的文章 http://www.infoq.com/cn/articles/afn_vs_asi。除此之外， MKNetworkKit 和 RestKit也有一定的使用者。 Socket CocoaAsyncSocket无疑是目前封装得最完善的Socket库了：支持异步TCP/UDP，支持GCD，Objective-C接口封装。。目前没有发现可以与之相比的同类产品。。 JSON JSONKit算是第三方中最优秀的一个了：性能很高，文件少。在JSONKit之前，SBJson非常非常流行，但是SBJson性能够差，只是由于历史原因仍然存在在某些工程里面。如果工程只需要支持iOS5以上的系统，那就可以放弃那些第三方Json库了，直接用系统提供的NSJSONSerialization，性能比第三方的好，又是官方API。。 XMPP 现在做个实时聊天，XMPP协议算是很成熟的方案了。 XMPPFramework一个很不错的选择，可以直接和OpenFire服务器打交道。项目不大人手不多的话，可以看看这个。 基础工具类 SSToolkit算是一个不错的工具包，提供各种比如编码、加密、字符串处理等等东西，还提供了一些不错的自定义控件，并且文档非常齐全。 框架 过去有很多人再用 three20，这个东西太大太重，文档又少，到头来连Facebook都停止维护了。作为替代品nimbus现在流行了开来，关键在于它文档齐全。国内有个MVC框架叫 BeeFramework，号称是顶级框架并且功能超过 nimbus，有兴趣的可以看一下。 ReactiveCocoa把响应式编程这种上流的东西带了过来，值得试一试。。 数据存储 还是挺多人(比如我)喜欢直接跟SQLite打交道的，这方面 fmdb封装的很不错。如果用CoreData来做存储的，可以用一下 MagicalRecord。 图像处理 GPUImage无疑是这方面的集大成者了。用OpenGL ES2.0来实时处理图片和视频流，性能和功能都是顶尖的。 开发和调试工具 PonyDebugger看上去是一个不错的调试工具，可以在电脑浏览器上远程调试iOS程序、查看试图层次、网络等等。 CocoaLumberjack是个Log工具，号称是可以提供企业级Log，使用者也挺多。 为了了解一下目前第三方库的普及程度，下面列举一些知名App对第三方库的依赖。 网易新闻 AppleReachability ASIHTTPRequest EGOTableViewPullRefresh GTMNSString+HTML MGTemplateEngine MPOAuth RegexKitLite SDWebImage SSZipArchive wax Garageband MurmurHash libpng zlib SBJson (json-framework) iWork三套件 MOKit Boost C++ Library protobuf OpenGL Mathematics SQLite cephes math library Pinterest AFNetworking AFHttpClientLogger Facebook SDK iRate MAKVONotificationCenter SDWebImage SFHFKeychainUtils SSPullToRefresh SVProgressHUD TTTAttributedLabel TTTLocalizedPluralString UIAlertView-Blocks 多看阅读 fmdb ASIHTTPRequest FreeType JSONKit Objective-Zip Skia (Google) MBProgressHUD 淘宝 MAZeroingWeakRef MBProgressHUD ABContactHelper ASIHTTPRequest CocoaLumberjack EGOTableViewPullRefresh fmdb GTMBase64 JSONKit SBJson (json-framework) RTLabel SDWebImage SVPullToRefresh three20 ziparchive 微信 cocos2d EGOTableViewPullRefresh Facebook iOS SDK JSONKit SBJson ziparchive QQ ASIHTTPRequest FMDB CocoaAsyncSocket JSONKit MBProgressHUD OpenUDID SBJson SVPullToRefresh 百度地图 AFNetworking GTMBase64 JSONKit MBProgressHUD RNCachingURLProtocol SDWebImage 微博 ABContactHelper AFNetworking ASIHTTPRequest DACircularProgressView DDProgressView DTFoundation fmdb JSONKit SBJson MBProgressHUD MTStatusBarOverlay OpenUDID SFHFKeychainUtils 人人 cocoaasyncsocket ZipArchive MBProgressHUD JSONKit GTMBase64 MKNetworkKit HPGrowingTextView zxing 可以看到，这些大型的App的依赖都很混乱，所以稍微解释一下。这些大公司都有一个iOS团队来协同开发，团队成员的水平也参差不齐。有时由于历史原因，例如某个App的某个组件依赖了ASIHttpRequest，但之后的新人改用了AFNetworking，就造成上面这种比较混乱的库依赖关系。这就造成难以维护、代码冗余等问题了。所以，引入一个第三方库一定要慎重考虑，如果可能，尽量自己开发和实现相应的功能，第三方库尽量只作为参考。 小团队或者个人开发者可以不必过多考虑，开发速度优先。 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 2014年8月7号新增 系统基础库 Category/Util sstoolkit一套Category类型的库,附带很多自定义控件 功能不错～ BlocksKit将Block风格带入UIKit和Founcation cocoa-helpers一些Cocoa的扩展 2年前的工程 CoconutKit一系列扩展和一些自定组件 STUtils一系列扩展包 PSFoundation一系列扩展 和功能增强 ConciseKit一系列宏定义 挺有意思 DTFoundation又一系列扩展。。。 BBBootstrap一些常见功能的扩展库 cooliris-toolkitcooliris出品的基础工具库,从GoogleCode clone过来 BaseKit一套基础工具库 NSObject-Utility-Categories如题 NSArray-Utilities如题 aqtoolkit一些常用的东西 DLIntrospection一些NSObject的扩展 NSDate-Extensions如题日期 ALActionBlocks在UIControl上添加的Block事件 jrswizzle主要是swizzling moriarty一些还算有用的功能 QSUtilities一些基础库 (Instagram有用到) libextobjc一堆oc的扩展 PrettyTimestamp友好时间的扩展 ios-jail-break-detector检测是否越狱 有上线 crackify检测App是否被破解 NSBundle-OBCodeSigningInfo检查当前签名、Sandbox状态 MacOSX UIView-AnimatedProperty为UIView添加动画效果的property,有用到swizzle Block-KVOBlock风格的KVO~ MTDates一些Data的category CocoaSecurity常见的哈希、加密解密算法 sskeychain访问keychain 支持iOS Mac ABContactHelper访问联系人 UISS用JSON的风格设置UIKit样式 Underscore.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54e17cdf77ebaea0cf21f9bcf7944af2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/472/">«</a>
	<span class="pagination__item pagination__item--current">473/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/474/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>