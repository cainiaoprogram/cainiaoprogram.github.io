<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a4c049fbe955db9d906fab844d20981/" rel="bookmark">
			数据库中的并发操作带来的一系列问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库中常见的并发操作所带来了一致性问题包括：丢失的修改，不可重复读，读“脏”数据，幻读。
1.丢失的修改：一个事物的更新覆盖了另一个事物的更新。例如：事物A和B读入同一数据并修改，B提交的结果破坏了A提交的结果，导致A的修改被丢失。
2.不可重复读：一个事物两次读取同一个数据，两次读取的数据不一致。不可重复读是指事物A读取数据后，事物B执行更新操作，事务A 无法再现前一次读取结果。
a.事物A读取某一数据后，事物B对其作了修改，当事物A再次读取数据时，得到与前一次不同的值。
b.事物A按一定的条件从数据库中读取了某些数据后，事物B删除了其中部分记录，当A再次以相同条件读取时，发现某些记录消失了。
3.脏读：一个事物读取了另一个事物未提交的数据。读“脏”数据是指事物A修改某一数据，并将其写回磁盘，事物B读取同一数据后,A由于某种原因被撤销，这时A已修改过的数据恢复原值，B读到的数据就与数据库中的数据不一致，则B读到的数据为“脏”数据，即不正确的数据。
4.幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。
a.事物A按一定的条件从数据库中读取某些数据记录后，事物B插入了一些记录，当B再次按照相同条件读取数据时，发现多了一些记录。（也叫做幻影读）。
产生上述三类数据不一致性的主要原因是并发操作破坏了事物的隔离性，并发控制就是要用正确的方式调度并发操作，使一个事物的执行不受其他事物的干扰，从而避免造成数据的不一致性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6efbb667628036575453cdf5c29b477/" rel="bookmark">
			WebView运行在系统进程出现的问题 WebView is not allowed in privileged processes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebView运行在系统进程的问题
WebView在Android4.4之前使用的Webkit内核，在Android4.4以后切换到了Chromium内核。本文的内容主要不是讲解Chromium内核上WebView的特性。关键是要讲解webview切换到Chromium内核后我遇到的一个坑（实际上可能叫做坑不合适，因为这是安卓为了安全着想才这么做的），并提出解决这个坑的一个方法。
这个问题的情形是这样的，当时需要在一个系统应用中使用webview，系统应用因为需要使用一些特殊的系统权限，所有配置了android:sharedUserId="android.uid.system" ，那么当你运行webview的时候，就会发现程序crash并抛出以下异常：
Caused by: java.lang.UnsupportedOperationException: For security reasons, WebView is not allowed in privileged processes
at android.webkit.WebViewFactory.getProvider(WebViewFactory.java:155)
at android.webkit.CookieManager.getInstance(CookieManager.java:42)
接下来我们来跟踪源码看下这个异常是怎么抛出来的根据crash信息，我们来看WebViewFactory中的getProvider方法，在这里提一下，在切换WebView的内核之前，Google就已经修改了WebView的代码架构，使用了工厂模式来决定WebView的具体实现，目的就是为了日后可以方便的切换WebView内核。在这里以Android-22的源码为例，每个Android版本的WebViewFactory源码都有所出入，不过本文的关键是描述解决这个问题的思路。
static WebViewFactoryProvider getProvider() {
synchronized (sProviderLock) {
// For now the main purpose of this function (and the factory abstraction) is to keep
// us honest and minimize usage of WebView internals when binding the proxy.
if (sProviderInstance != null) return sProviderInstance;
final int uid = android.os.Process.myUid();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6efbb667628036575453cdf5c29b477/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec28e64043a4b2246f63cd697a9e9bab/" rel="bookmark">
			【OpenCV3图像处理】OpenCV3源代码目录解析（算法模块解析 和 示例目录解析)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV3源代码文件夹sources： • 3rdparty: 包含第三方库，如用视频解码用的 ffmpeg、jpg、png、tiff 等图片的解码库。
• apps: 包含进行 Haar 分类器训练的工具，OpenCV 进行人脸检测便是基于 Haar 分类器。如果你想检测人脸以外的图片，千万不要错过这几个工具。
• cmake: 包含生成工程项目时cmake 的依赖文件，只能用于搜索第三方库，普通开发者不需要关心这个文件夹的内容。
• data: 包含 OpenCV 库及范例中用到的资源文件
• doc: 包含生成文档所需的源文件及辅助脚本
• include: 包含入口头文件。OpenCV子文件夹中是C语言风格的API。OpenCV 2 子文件夹中只有一个 opencv.hpp 文件，这是 OpenCV 2 及 OpenCV 3 推荐使用的头文件
• modules:算法模块的源代码。研究算法的同学 学习的重点！！！
• platforms: 包含交叉编译所需的工具链及额外的代码，交叉编译指的是在一个操作系统中编译供另一个系统使用的文件。
• samples:算法用法示例文件夹
重点文件夹：include、modules和samples modules文件夹： CPU模块：
• calib3d: 相机标定及三维重建。相机标定用于取出相机自身缺陷导致的画面形变，还原真实的场景，确保计算的准确性。三维重建通常用在双目视觉（立体视觉），即两个标定后的摄像头观察同一个场景，通过计算两幅画面中的相关性来估计像素深度。
• core: 核心功能模块，定义了基本的数据结构，包括最重要的 Mat 类、XML 读写、OpenGL三维渲染等。
• features2d: 包含 2D 特征值检测的框架。包含各种特征值检测器及描述子，如 FAST、MSER、OBRB、BRISK 等。各类特征值拥有统一的算法接口，因此在不影响程序逻辑的情况下可以替换替换。
• flann: 用于在多维空间内聚类及搜索的近似算法，做图像检索的开发者对它不会陌生。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec28e64043a4b2246f63cd697a9e9bab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddbce244adc19872bf0f9aa55425b272/" rel="bookmark">
			连接数据库的Provider、Driver等字符串的写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述不太清楚。
用编程语言或脚本连接数据库时，会有这么一行字符串：
StrCnn="Provider=MSDASQL.1;Persist Security Info=True;Extended Properties='Driver=MySQL ODBC 5.3 Unicode Driver;SERVER=10.1.3.133;UID=koa;PWD=koa;DATABASE=koa;PORT=3307'"或是 ConnStr = "Provider = Sqloledb; User ID = " &amp; SqlUsername &amp; "; Password = " &amp; SqlPassword &amp; "; Initial Catalog = " &amp; SqlDatabaseName &amp; "; Data Source = " &amp; SqlLocalName &amp; ";" 本文即说这个字符串如何获得。 一.新建记事本，重命名后缀名为udl
二.双击打开这个文件
记得勾选“允许保存密码”，点击下方“测试连接”，连接通过，即配置正确。
三.用记事本打开该文件
这个文件的第三行，即我们需要的字符串。
四.VBScript连接示例
Set fso = CreateObject("Scripting.FileSystemObject") Set WriteFile = fso.OpenTextFile(DatePart("yyyy",date)&amp;Right("0" &amp; DatePart("m",date), 2)&amp;Right("0"&amp;DatePart("d", date),2)&amp;".txt", 8, True) '连接数据库 StrCnn="Provider=SQLOLEDB.1;Password=fsdx123;Persist Security Info=True;User ID=sa;Initial Catalog=msdb;Data Source=10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddbce244adc19872bf0f9aa55425b272/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1df89fb92df78565e7bee209c52f8dc/" rel="bookmark">
			windows卸载程序需要密码/防卸载功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows卸载程序需要密码 1.实现思路 1.写自己的mfc卸载窗口(uninstall.exe) 2.程序安装完成后更改注册表（管理员权限） 对windows 64位应用程序来说，卸载的时候主要调用了注册表中HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WOW6432Node\Windows\CurrentVersion\Uninstall{Product Id} 中的UninstallString的值 如下图：
2.修改注册表 1.修改UninstallString的值(安装完成后程序的uninstall.exe的全路径) 2.修改windowsinstaller 的值(1改为0) 上两步完成之后即可实现卸载时调用自己的uninstall.exe程序如下图:
注册表修改具体方法:http://blog.csdn.net/linshaolie/article/details/9769893 http://blog.csdn.net/weiwenhp/article/details/9381717
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4609225db91a8adce3a2e576670f7fb6/" rel="bookmark">
			PLSQL中文显示乱码,真正有效的解决方案(无需修改注册表 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PLSQL中文显示乱码，可能是oracle客户端和服务器端的编码方式不一样。网上有很多帖子介绍解决方法，但都说得不清不楚的，这里我将自己经过实践和理解的真正的解决方案分享给大家。
在这里，我们使用的是服务器上的Oracle，不是本机的Oracle，按照以下两个步骤进行：首先要查询ORACLE服务器的语言、地域和字符集，然后将查询结果设置为本地的环境变量：NLS_LANG。具体如下：
1. 查询ORACLE服务器的语言、地域和字符集
select * from nls_database_parameters;
查询结果如下图, 下图NLS_LANGUAGE 表示“语言”，NLS_TERRITORY 表示“地域”，NLS_CHARACTSET 表示“字符集”，将他们三个按照“语言_地域.字符集”的格式拼接起来，就有了“AMERICAN_AMERICA.ZHS16GBK”（注意：这里要根据你自己的ORACLE服务器的这三个值进行拼接哦~不要简单的复制粘贴）
2.设置本地环境变量:NLS_LANG，
进入 我的电脑,属性,高级,环境变量,添加1项:
NLS_LANG="AMERICAN_AMERICA.ZHS16GBK"
（注意：这里要根据你的ORACLE服务器的这三个值进行拼接哦~不要复制粘贴）
OK，重新打开PLSQL dev ,中文显示正常拉~~
还有一点需要注意的是：网上很多方案说要修改本地注册表中的“HKEY_LOCAL_MACHINE-&gt;SOFTWARE-&gt;ORACLE-&gt;KEY_OraClient11g_home1”项，其实这是不对的，这已注册表项是本地ORACLE的字符集，跟你要访问的服务器ORACLE没有关系的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1638c65dd3c3351b72752f8745955dbe/" rel="bookmark">
			深入理解拉格朗日乘子法（Lagrange Multiplier) 和KKT条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在求解最优化问题中，拉格朗日乘子法（Lagrange Multiplier）和KKT（Karush Kuhn Tucker）条件是两种最常用的方法。在有等式约束时使用拉格朗日乘子法，在有不等约束时使用KKT条件。
我们这里提到的最优化问题通常是指对于给定的某一函数，求其在指定作用域上的全局最小值(因为最小值与最大值可以很容易转化，即最大值问题可以转化成最小值问题)。提到KKT条件一般会附带的提一下拉格朗日乘子。对学过高等数学的人来说比较拉格朗日乘子应该会有些印象。二者均是求解最优化问题的方法，不同之处在于应用的情形不同。
一般情况下，最优化问题会碰到一下三种情况：
（1）无约束条件
这是最简单的情况，解决方法通常是函数对变量求导，令求导函数等于0的点可能是极值点。将结果带回原函数进行验证即可。
（2）等式约束条件
设目标函数为f(x)，约束条件为h_k(x)，形如:
s.t. 表示subject to ，“受限于”的意思，l表示有l个约束条件。
则解决方法是消元法或者拉格朗日法。消元法比较简单不在赘述，这里主要讲拉格朗日法，因为后面提到的KKT条件是对拉格朗日乘子法的一种泛化。
例如给定椭球:
求这个椭球的内接长方体的最大体积。这个问题实际上就是条件极值问题，即在条件 下，求的最大值。
当然这个问题实际可以先根据条件消去 z (消元法)，然后带入转化为无条件极值问题来处理。但是有时候这样做很困难，甚至是做不到的，这时候就需要用拉格朗日乘数法了。 首先定义拉格朗日函数F(x)：
（ 其中λk是各个约束条件的待定系数。） 然后解变量的偏导方程：
......,
如果有l个约束条件，就应该有l+1个方程。求出的方程组的解就可能是最优化值（高等数学中提到的极值），将结果带回原方程验证就可得到解。
回到上面的题目，通过拉格朗日乘数法将问题转化为
对求偏导得到
联立前面三个方程得到和，带入第四个方程解之
带入解得最大体积为：
（3）不等式约束条件
设目标函数f(x)，不等式约束为g(x)，有的教程还会添加上等式约束条件h(x)。此时的约束优化问题描述如下：
则我们定义不等式约束下的拉格朗日函数L，则L表达式为：
其中f(x)是原目标函数，hj(x)是第j个等式约束条件，λj是对应的约束系数，gk是不等式约束，uk是对应的约束系数。
常用的方法是KKT条件，同样地，把所有的不等式约束、等式约束和目标函数全部写为一个式子L(a, b, x)= f(x) + a*g(x)+b*h(x)，
KKT条件是说最优值必须满足以下条件：
1）L(a, b, x)对x求导为零；
2）h(x) =0;
3）a*g(x) = 0;
求取这些等式之后就能得到候选最优值。其中第三个式子非常有趣，因为g(x)&lt;=0，如果要满足这个等式，必须a=0或者g(x)=0. 这是SVM的很多重要性质的来源，如支持向量的概念。
接下来主要介绍KKT条件，推导及应用。详细推导过程如下：
？？？？从几何角度看拉格朗日乘子法的物理意义：
该方法适用于约束条件下求极值的问题。对于没有约束的极值问题，显然，如果某一点是极值的必要条件是该点的各方向的偏导数皆为零，也就是说，如果偏导数不全为零，那么就不可能是极值。
例如，一个三元函数w(x,y,z), 它是x,y,z的函数，且在一个约束条件下求它的极值。我们假设图中的曲面就是约束方程g(x,y,z)=0的图像，即约束面。之前没有约束面时，w取极值的必要条件是各个方向偏导数为零，而对于可微函数各个方向偏导为零的充分必要条件是沿x,y,z 方向的偏导为零。现在有了约束面，我们不再需要这么苛刻的必要条件，因为有了约束面，x,y,z在一定程度上被限制了，只能在约束面内移动，因此只需要沿约束面内的各个方向运动时的偏导数（变化化率）为零就可以了，此时自由度由三维下降到两维。满足在约束面内的各个方向偏导为零，也就是说，w取极值的必要条件减弱为待求函数的方向导数（梯度）垂直于约束面，从数学上看，也就是方向导数和约束面的法线方向同向（一个向量等于另一个向量的常数倍），而不需要梯度为零，因为和梯度垂直的方向偏导数一定为零，这样，沿约束面各个方向运动时w的偏导数也就为零了。这便是拉格朗日乘子法求极值的几何意义。
个人总结：
想象一下我们爬山（优化函数）找最高点（求最大值），要想最快的上，要找最陡的方向，陡峭的程度以坡度（方向导数）度量，最陡的方向即为最大坡度（梯度）决定的方向，理想情况下，当无法再上升，坡度（梯度）变成0时，找到最高点（求得最大值）。但是，当我们必须绕圆弧行盘山路爬行时，盘山路（约束条件）约束了我们的路径及方向，我们必须沿着盘山路最陡的方向（梯度，注意此时退化为一维，只有一个方向，为道路切向），当道路不再上升（及切向为0），即找到最高点。
再想想一下我们是海水，从山底向上移动（集体作战），领袖沿着盘山路行进，每一步我们可以找到同海拔的海岸线（等高线），海岸线与盘山路想交，我们可以继续向上移动，直到海岸线与盘山路向切，此时，找到最高海拔，海岸线（等高线）同时与约束方程确定的边界相切。
在极值点，优化函数的等高线、优化函数与约束方程的交线、约束方程的投影线（类似约束曲面的等高线，约束曲线）相切于一点。等高线与约束曲线法向相同（不考虑正负），而优化函数的梯度数值等于其等高线的法向数值，约束方程的梯度数值等于约束曲线的法向数值。故∆f=λ∆g,λ!=0
极值点的2个条件：
1、极值点在优化函数及约束方程上；
2、在极值点，优化函数的等高线、优化函数与约束方程交线、约束曲线相切，优化函数与约束方程交线的梯度（导数）为0
可利用这2个条件求解：
一、根据1将约束方程带入优化函数消元、降维变成无约束低维问题求解，根据2求梯度为0
二、根据2构造似然函数L（X，λ），使在特殊条件下满足1和2，对L（X,λ）解特殊条件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/372c18e49d9501d0295d7cd8614293e5/" rel="bookmark">
			功夫不负有心人，终于解决TeamViewer在局域网中远程桌面控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几天前在博文中提到，一直在寻找一款能在局域网中（没有互联网）进行远程桌面控制的软件。认为TeamViewer脱离互联网是无法进行远程桌面的。大家百度一下，大多数的玩家也都斩钉截铁地回复“不能！”。
今天和同事一起，再次进行了测试，发现原来TeamViewer是可以在局域网中实现远程桌面的。可以的！可以的！可以的！
先看看实测的界面，用的是TeamViewer12版本
看到了吗？左下角亮起了绿灯，提示可以通过Lan连接。大多数人在操作的时候都是亮着红灯，提示检查网络设置，因为没有互联网连接。
解决办法如下：
看到下图中有个“其他”选项，点击它。然后进行设置。
按照下图进行配置
在常规设置中——网络设置——呼入的LAN连接——选择仅接受。红灯立马变成绿灯了。现在输入同一网段被控电脑的IP地址就能远程控制了。
梦里寻她千百度，原来就在一键间。
原创博文，转发请注明出处！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f89f5f38d9be181217ec0f6abca0cd3b/" rel="bookmark">
			Java代码Base64加密解密使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java代码Base64加密解密使用 程序中有时候需要把用户名和密码保存到本地，下次登录时自动获取，如果是直接使用字符串保存，肯定容易泄露密码，这就需要经过加密，但是登录时还要获取密码，这就需要解密，这个Base64类就能简单的实现这个功能。
一．简单介绍一下加密的知识： 不想讲太多高深的知识，讲一点基础的。
（一）简单的java加密算法有： 1.BASE64 严格地说，属于编码格式，而非加密算法 2.MD5(Message Digest algorithm 5，信息摘要算法) 3.SHA(Secure Hash Algorithm，安全散列算法) 4.HMAC(Hash Message Authentication Code，散列消息鉴别码) 上面的加密我也是用得比较少，其实用起来并不难，使用的话，都要导入对应的jar，具体的操作代码网上都是可以查到的，发生类错误就是导的包不对！每一种jar包都有不同的版本！
（二）对称算法和不对称算法 1. 对称加密（Symmetric Cryptography） 对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）,这种方法在密码学中叫做对称加密算法。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。 对称加密解密时间都是非常快的。 2.非对称加密（Asymmetric Cryptography） 非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个（公钥）进行加密，而解密则需要另一个（私钥）密钥。 非对称解密是非常慢的，很简单的数据可能都要几个小时！
3.常见的对称加密和非对称加密算法 （1）对称加密算法： 在对称加密算法中常用的算法有：DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK、AES等。
DES（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合。 3DES（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。 AES（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高；
（2）非对称常用算法 RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）。 （三）其他 Base64还不算加密算法，其实就是一种编码转换； MD5、SHA是非对称加密算法
二.Base64的编码示例 （一）导入jar包：BASE64Decoder jar包 下载地址：http://download.csdn.net/detail/wenzhi20102321/9805051
（二）代码 1.加密代码： 加密前字符串：String　key="mykey"; byte[] bt = key.getBytes(); 加密后字符串：String newKey=(new BASE64Encoder()).encodeBuffer(bt); 2.解密代码： 加密后的字符串：String newkey="*****"; byte[] bt = (new BASE64Decoder()).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f89f5f38d9be181217ec0f6abca0cd3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5162e1a35bc6dfc2557c0a1cfd2054e3/" rel="bookmark">
			QT触摸屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：http://blog.csdn.net/aifei7320/article/details/47975073 这个教程描述了在嵌入式linux下使用Qt如何设置一个支持多点触摸和单点触摸的输入系统。这里假定你已经有了对应的驱动程序，驱动可以从触摸屏的厂商那里获得或者使用一个linux 内核源码中已经存在的驱动。 第一要务，找到你的驱动程序（通常在/drivers/input/touchsreen/*）并且确认你已经定义好了tslib中所需要的每个事件类型。通常你需要EV-SYN, EV-ABS和EV_KEY.我自己使用的驱动中没有定义EV_KEY, 因此驱动不会发送这一个类型的事件。为了能够使tslib和这个驱动的输入系统好好工作，我需要在驱动代码中定义这个事件。 set_bit(EV_SYN, aura.input_dev-&gt;evbit); set_bit(EV_ABS, aura.input_dev-&gt;evbit); set_bit(EV_KEY, aura.input_dev-&gt;evbit); # I had to add this line so that tslib was happy 现在使用修改后的驱动源码重新构建内核，并且在开发板上运行起来。 我这里的输入设备名称是‘touchscreen’， 由于多种原因， 你们的输入设备名称可能是event1 或者event0 。 使用下面的命令查看设备 # ls -rlt /dev/input/touchscreen lrwxrwxrwx 1 root root 6 Jan 17 21:06 /dev/input/touchscreen -&gt; event1 # chmod 777 /dev/input/touchscreen # chmod 777 /dev/input/event1 使用下面的命令，你可以看到更多的信息 # cat /sys/devices/virtual/input/input1/uevent PRODUCT=0/0/0/0 NAME="aura-touchscreen" PROP=0 EV=9 ABS=650000 0 MODALIAS=input:b0000v0000p0000e0000-e0,3,kra30,32,35,36,mlsfw 使用下面的命令，然后再屏幕上移动你的手指以确认触摸屏驱动是否正在工作。 当你的手指在屏幕上移动时，你应该看到下面的现象。 # cat /dev/input/touchscreen | hexdump 0000000 9011 3883 565f 0001 0003 0030 0001 0000 0000010 9011 3883 565f 0001 0003 0032 0001 0000 0000020 9011 3883 565f 0001 0003 0035 04c9 0000 0000030 9011 3883 565f 0001 0003 0036 0c3f 0000 0000040 9011 3883 565f 0001 0000 0002 0000 0000 0000050 9011 3883 565f 0001 0000 0000 0000 0000 0000060 9011 3883 90a9 0001 0003 0030 0001 0000 0000070 9011 3883 90a9 0001 0003 0032 0001 0000 返回你的主工作台， 从这里 https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5162e1a35bc6dfc2557c0a1cfd2054e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b6e464e5c2e165c87dcb3f466740bb1/" rel="bookmark">
			【视觉-摄像机2】opencv 调用工业摄像机（GigE接口详细说明）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络摄像机的使用 开发环境为win7+VS2010+opencv (主要是操作系统windows,Linux还没尝试) 基于Basler_acA1300-30gc 摄像机为例
1 安装摄像机的相关软件 2 接线连接硬件设备 将相机通过GigE接口与PC笔记本连接 3 通过ip地址实现相机与PC通信 3.1 用相机软件设计出摄像机的参数主要为IP地址 用pylon IP Configurator设置相机IP地址 双击设备acA13... 进入IP设置界面 输入您要设置的IP，基本改后2段，记住您设置的IP，之后要用。忘记了可以返回来再看看。 设置完保存，则为相机设置了通信的IP地址 3.2 在PC或笔记本上设置要通信IP地址 在网络连接里设置获取的ip，
打开网络设置
本地链接
属性 ipv4
将自动获取 ip 地址改为 , 使用下面 ip 地址 需要设置的ip地址。特别要注意最后一位与摄像机的ip地址后一位是不同的。
设置完以后保存这样就可以实现通过ip地址通信。
你可以用相机自带的软件来打开摄像机。可以通过笔记本上的，网络设备通过菜单栏选择要打开的摄像机，打开相机观察效果。
4 连接了多个摄像机 如果要连接了多个摄像机，参考我上一篇的博客，设置你需要打开的那个摄像机。
VideoCapture类，其实0,1……的设备ID号看WIN7下设备管理器—图像设备,对应的搜引号，从0开始
5 一般情况SDK无用（论） 一般情况下不需要SDK也可以实现基本的相机操作, 我们一般认为，调用工业摄像机需要SDK，其实现在opencv的类vediocapture已经不需要sdk也可以调用摄像机。你可以我先用摄像机自带的软件设计摄像机的参数，采集速度曝光分辨率等参数。然后直接调用即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b8aefd7e157150472a866d8ab933421/" rel="bookmark">
			JAVA线程的创建(学习笔记)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 线程区别于进程，进程是单独运行的一个程序，线程是程序运行时的不同工作。一个程序可以同时完成多种不同的工作，这些都是依靠线程来实现的
Java线程具有五中基本状态
新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();
就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；
运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；
阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：
1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；
2.同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；
3.其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
实现方式 JAVA中提供了两种线程的实现方式，分别是继承java.lang.Thread类和实现java.lang.Runable接口
继承Thread类，重写该类的run()方法。 public class MyThread extends Thread{ private int 1; public static void run(){ for (i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + " " + i); } } } 2.实现Runable接口，并重写该接口的run()方法 ，此时该run()方法是线程执行体，创建Runnable实现类的实例，并以此实例作为Thread类的参数来创建Thread对象，该Thread对象才是真正的线程对象。
public class MyRUn implements Runnable { @Override public void run() { // TODO Auto-generated method stub System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b8aefd7e157150472a866d8ab933421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa8e2dab4a48a76e4af37c0324b11c77/" rel="bookmark">
			Truncate Table 与DELETE FROM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TRUNCATE TABLE name
name 是要截断的表的名称或要删除其全部行的表的名称。 TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。 DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。 TRUNCATE TABLE 不能用于参与了索引视图的表。 对用TRUNCATE TABLE删除数据的表上增加数据时，要使用UPDATE STATISTICS来维护索引信息。 如果有ROLLBACK语句，DELETE操作将被撤销，但TRUNCATE不会撤销。 TRUNCATE TABLE name [DROP/REUSE STORAGE] DROP STORAGE：显式指明释放数据表和索引的空间 REUSE STORAGE：显式指明不释放数据表和索引的空间 truncate命令是会把自增的字段还原为从1开始的,或者你试试把table_a清空，然后取消自增，保存，再加回自增，这也是自增段还原为1 的方法。 还有两种方法是可以把表id还原为1 的 1.delete from 你的表名 dbcc checkident(你的表名,reseed,0) 2.如果你要保存你的数据，介绍你第三种方法，by QINYI 用phpmyadmin导出数据库，你在里面会有发现哦 编辑sql文件，将其中的自增下一个id号改好，再导入。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/761c527cbf044697db519746801fe621/" rel="bookmark">
			银联pinBlock算法的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		银联PINBLOCK算法的实现，算法规则参考pos销售终端规范(如有需要，可联系博主索取或自行百度，本文仅上实现)
偶然翻到之前写的对于ANSI X9.8标准获取PINBlOCK，发现可能之前比较仓促，并没有对整个过程描述的比较清楚，特意重新整理了下实现，添加对应注释以便于理解该过程。
1.格式化PIN(ANSI X9.8分为带主账号信息与不带主账号信息，如果不带主账号信息那么下面函数处理后返回的即为PINBLOCK)
/** * 格式化PIN * * @param pin * @return */ public static byte[] formatPinByX98(byte[] pin) { //pin长度 int l = pin.length; //pin合法性检查，规范要求PIN长度为4-12 if (l &lt; 4 || l &gt; 12) { throw new RuntimeException("pin长度错误"); } //固定为8字节长度 byte[] encode = new byte[8]; //规范要求不足8自己后补F，先提前补好填充内容方便后面处理 Arrays.fill(encode, (byte) 0xFF); //第一位为pin长度 encode[0] = (byte) l; //计算填充剩余字节(填充规则，按照BCD压缩码填充，即一个字节可以表示2位密码 // 这里因为一个字节长度为8位，密码确定为0-9中任意数字，这代表用4bit即可完全表示一位密码，所以一个字节可以表示两位密码。 // 需要注意的是为无符号位的字节，所以填充前我们需要运用按位运算与0x0F运算去掉符号位) int cl = l / 2; for (int i = 0; i &lt; cl; i++) { encode[i + 1] = (byte) ((pin[i * 2] &amp; 0x0F) &lt;&lt; 4 | pin[i * 2 + 1] &amp; 0x0F); if (i == cl - 1) { if ((l &amp; 1) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/761c527cbf044697db519746801fe621/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa1f6ef28ae1a19583dc14c9fcae3cb9/" rel="bookmark">
			python 地板除法(floor)和截断除法(trunc)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		math.floor() &amp; math.trunc() math.floor 和 math.trunc的官方不同版本的介绍如下： math.floor: python2.7: Return the floor of x as a float, the largest integer value less than or equal to x. python3.5: Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to x.__floor__(), which should return an Integral value. math.trunc: python2.7: Return the Real value x truncated to an Integral (usually a long integer).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa1f6ef28ae1a19583dc14c9fcae3cb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc409e6c25be1e085624d1ade15f76e6/" rel="bookmark">
			jquery后台日期价格输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!doctype html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="http://www.jq22.com/jquery/jquery-1.10.2.js"&gt;&lt;/script&gt; &lt;style&gt; #RangeDate_bg{ position: fixed; bottom: 0; left: 0; width: 100%; height: 100%; overflow: hidden; background: rgba(0,0,0,0.5); padding:20px 100px; box-sizing: border-box; } #RangeDateFu{ min-width: 750px; display: flex; flex-wrap: wrap; text-align: center; font-size: 14px; line-height: 25px; color: #333; background: #fff; height: 100%; width: 100%; flex-direction: column; } .RangeDate_xinqiContainer{ height: 40px; display: flex; padding-right: 17px; } .RangeDate_xinqi{ width: 14%; height: 40px; line-height: 40px; color: #666; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc409e6c25be1e085624d1ade15f76e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77f6d7828a4e0a2489c6b084818f7469/" rel="bookmark">
			快速解决Android中的selinux权限问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于selinux的详细资料，请查阅http://blog.csdn.net/innost/article/details/19299937
在Android开发的过程中,遇到关于selinux相关的东西，当时还一下子看不懂，现在好像有点眉目了。
比如，内核打印这个提示
type=1400 audit(32.939:25): avc: denied { open } for pid=2592 comm="chmod" path="/dev/block/mmcblk0p25" dev="tmpfs" ino=6494 scontext=u:r:init_shell:s0 tcontext=u:object_r:block_device:s0 tclass=blk_file permissive=1
我们可以遵循这个方法，从头开始寻找关键对象，然后调整一下顺序，生成一条语句,最后将该语句填写到.te文件中即可。
denied { open } u:r:init_shell:s0 u:object_r:block_device:s0 tclass=blk_file A B C D
B C D A
allow init_shell block_device:blk_file open;
这条语句表示允许init_shell域中的block_device进程打开block_device类型的块设备文件。
或者直接使用工具生成external/selinux/prebuilts/bin/audit2allow
有时候会遇到编译该规则失败,这也许就是neverallow语句做怪了。
neverallow用来检查安全策略文件中是否有违反该项规则的allow语句(不可修改newerallow的定义)
如external/sepolicy/netd.te文件中，语句
neverallow netd dev_type:blk_file { read write };
表示永远不允许netd域中的进程读写dev_type类型的块设备文件，这时只需屏蔽该语句即可。
当然,在调试阶段，可在终端上运行如下命令获取SELinux的状态和临时关闭SELinux
setenforce 0 ##设置SELinux 成为permissive模式（SELinux开启，但对违反selinux规则的行为只记录，不会阻止）
setenforce 1 ##设置SELinux 成为enforcing模式 (SELinux开启)
getenforce ##获取SELinux状态(permissive,enforcing,disabled)
当然，如果要验证某些selinux问题，可以在cmdline中加入androidboot.selinux=0来关闭selinux
或者到Android源码的根目录下，直接修改system/core/init/init.c文件。
static void selinux_initialize(void) { if (selinux_is_disabled()) { return; } INFO("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77f6d7828a4e0a2489c6b084818f7469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ffb093612f34b81da7aa5fe8b28ea8e/" rel="bookmark">
			ios 强制横屏大总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整个项目是竖屏的，不能横屏，但是有个播放界面必须要横屏于是就开始找各种横屏的方法，最后在手机上好使了，但是在pad上横屏启动的时候界面是横屏显示，很是苦恼，就又开始了漫长的找资料，直接上代码 1，配置plist文件和deployemnt Info -&gt; device orientation （1），plist文件，如图所示，第一项是建立项目时默认有的表示支持手机的屏幕方向（我把支持向右和向左的删了），第二项是后加的表示支持ipad（添加 Supported interface orientations (iPad)）的旋转方向（同样我把向左向右，向上的给删了） （2），deployemnt Info -&gt; device orientation，只选择第一项竖屏。 2，开始代码配置（主要讲解push界面的强制横屏）主要是借鉴简书http://www.jianshu.com/p/5c773628caa6这位大神的讲解 （1），AppDelegate.h里面 @property (assign , nonatomic) BOOL isForceLandscape; @property (assign , nonatomic) BOOL isForcePortrait; AppDelegate.m里面 -(UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window{ if (self.isForceLandscape) { return UIInterfaceOrientationMaskLandscape; }else if (self.isForcePortrait){ return UIInterfaceOrientationMaskPortrait; } return UIInterfaceOrientationMaskPortrait; } (2)，在相应的tabBarController里面（我是在viewController里面写的） #import &lt;UIKit/UIKit.h&gt; #import "BaseViewController.h" @interface RootViewController : BaseViewController @property (strong,nonatomic) UITabBarController *tabBarCon; @end /// 选择的当前控制器是否可以旋转 -(BOOL)shouldAutorotate{ return [self.tabBarCon.selectedViewController shouldAutorotate]; } /// 选择的当前控制器是支持的旋转的方向 - (UIInterfaceOrientationMask)supportedInterfaceOrientations{ return [self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ffb093612f34b81da7aa5fe8b28ea8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7fb9055c81b90028d500661ece58929/" rel="bookmark">
			maven pom.xml packaging报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天刚接触maven，建了项目以后发现默认为jdk1.5，然后我删掉了那个，脑子一抽加了系统默认jre上去，然后报错了，代码一大堆
Execution default-testResources of goal org.apache.maven.plugins:maven-resources-plugin:2.6:testResources failed: Unable to load the mojo 'testResources' (or one of its required components) from the plugin 'org.apache.maven.plugins:maven-resources-plugin:2.6' (org.apache.maven.plugins:maven-resources-plugin: 2.6:testResources:default-testResources:process-test-resources) org.apache.maven.plugin. -----------------------------------------------------------------------------------------------
后来才想起来可能是不能用jre还是得用jdk，调成了1.8，update一下maven project就好了。
当然，可能有些人pom.xml报错是因为没有web.xml,大家在webapps里面建一个WEB-INF，然后在WEB-INF下建一个web.xml就行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5dd90d0046f14e43a313bb0a1df4e3e/" rel="bookmark">
			通过OCCI操作Oracle数据库详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介
OCCI 即 Oracle C++ Call Interface 在Windows下访问Oracle数据库可以使用ADO,ADO.NET,OLEDB,ODBC,跨平台的OCCI等方法,其中速度最快，对Oracle支持最完整的是Oracle提供的OCCI.
2.安装OCCI SDK
OCCI SDK 包含在 Oracle 客户端中，在如下位置可以找到： 头文件： %OARCLE_HOME%\oci\include 库文件：%OARCLE_HOME% \oci\lib\msvc 推荐安装 Oracle 即时客户端（ Instant Client ），它也包含有 OCCI SDK 。 头文件： instantclient\sdk\include 库文件： instantclient\sdk\lib\msvc 3.OCCI编程步骤 3.1连接到数据库 // 创建 OCCI 上下文环境 Environment *env = Environment::createEnvironment(); assert ( env != NULL ); // 创建数据库连接 Connection *conn = env-&gt;createConnection("uid","pwd","oracle_svr_name"); //... // todo: 插入自己的代码 // 关闭连接 env -&gt; terminateConnection ( conn ); // 释放 Environment :: terminateEnvironment ( env ); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5dd90d0046f14e43a313bb0a1df4e3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bac7931c67cb1e93a2082ef177bf3026/" rel="bookmark">
			几款移动跨平台App开发框架比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理目前流行的跨平台WebApp开发技术的特点，仅供参考。
每个框架几乎都包含以下特性：
使用 HTML5 + CSS + JavaScript 开发跨平台重用代码丰富的UI库提供访问设备原生API的 JavaScript API 包装器解决原生开发中机型适配的难题提供打包、部署的工具或服务都需要学习自身封装的 JavaScript API 筛选框架的要求：
性能：运行速度快UI：提供接近原生的UI体验插件多，文档丰富，开发效率高，容易扩展和维护满足业务需求 Cordova Cordova 和 PhoneGap 的区别？ PhoneGap 是 Apache Cordova 的一个分发版，就像 Ubuntu 是 基于 Linux 的一个发行版，其代码库也基于 Cordova，只是 PhoneGap 关联了 Adobe 的一些额外的商业工具或服务，例如 PhoneGap Build 和 Adobe Shadow，来帮助开发者简化开发。 此外，两者提供的CLI工具、项目结构有差异，如： Cordova 把 config.html 放在项目目录下，而 PhoneGap 把它放在www 目录下。
优点：
开源免费，社区生态成熟，插件丰富支持离线场景应用开发工具选择空间大 缺点:
只提供基础访问设备的接口，需要自己搭配其他UI框架和JavaScript框架来搭配 UI框架
Framework7MSUI | GithubFamous 为任意屏幕创建流畅、复杂的UI。 免费和开源的JavaScript渲染引擎。着名引擎的独特之处在于其JavaScript渲染引擎和3D物理引擎。 官网 | Github | Hello World 使用 Famo.us 创建高性能移动 UI 参考资料 Cordova中文文档 创建第一个App（英文） 利用 Cordova+Famous 创建高性能跨平台APP 使用 Cordova 和 Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bac7931c67cb1e93a2082ef177bf3026/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29d7455c95f3ce90531c96ce728901d2/" rel="bookmark">
			WebService中的WSDL详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebService中的WSDL详解 有人在WebService开发的时候，特别是和第三方有接口的时候，走的是SOAP协议，然后用户（或后台）给你一个WSDL文件（或网址），说按照上面的进行适配， 这时就要对WebService的WSDL有一定的理解，本文将对WSDL（WebService描述语言）进行详细总结。 WSDL (Web Services Description Language,Web服务描述语言)是一种XML Application，他将Web服务描述定义为一组服务访问点，客户端可以通过这些服务访问点对包含面向文档信息或面向过程调用的服务进行访问(类似远程过程调用)。WSDL首先对访问的操作和访问时使用的请求/响应消息进行抽象描述，然后将其绑定到具体的传输协议和消息格式上以最终定义具体部署的服务访问点。相关的具体部署的服务访问点通过组合就成为抽象的Web服务。
一．WSDL的基本概念 WSDL是一个用于精确描述Web服务的文档，WSDL文档是一个遵循WSDL-XML模式的XML文档。WSDL 文档将Web服务定义为服务访问点或端口的集合。在 WSDL 中，由于服务访问点和消息的抽象定义已从具体的服务部署或数据格式绑定中分离出来，因此可以对抽象定义进行再次使用。消息，指对交换数据的抽象描述；而端口类型，指操作的抽象集合。用于特定端口类型的具体协议和数据格式规范构成了可以再次使用的绑定。将Web访问地址与可再次使用的绑定相关联，可以定义一个端口，而端口的集合则定义为服务。 一个WSDL文档通常包含8个重要的元素，即definitions、types、import、message、portType、operation、binding、service元素。这些元素嵌套在definitions元素中，definitions是WSDL文档的根元素。 WSDL文档外层结构图示： WSDL 服务进行交互的基本元素： Types（消息类型）：数据类型定义的容器，它使用某种类型系统（如 XSD）。 Message（消息）：通信数据的抽象类型化定义，它由一个或者多个 part 组成。 Part：消息参数 PortType（端口类型）：特定端口类型的具体协议和数据格式规范。，它由一个或者多个 Operation组成。 Operation（操作）：对服务所支持的操作进行抽象描述，WSDL定义了四种操作： 1.单向（one-way）：端点接受信息； 3.要求-响应（solicit-response）：端点发送消息，然后接受相关消息； 4.通知（notification[2] ）：端点发送消息。
Binding：特定端口类型的具体协议和数据格式规范。 Port：定义为绑定和网络地址组合的单个端点。 Service：相关端口的集合，包括其关联的接口、操作、消息等。 外层结构里面也可能有多层结构。
二．WSDL的基本结构详解 下面通过一份wsdl文档，来详细解读WSDL结构：
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;wsdl:definitions targetNamespace="http://com.liuxiang.xfireDemo/HelloService" xmlns:tns="http://com.liuxiang.xfireDemo/HelloService" xmlns:wsdlsoap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soapenc11="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soapenc12="http://www.w3.org/2003/05/soap-encoding" xmlns:soap11="http://schemas.xmlsoap.org/soap/envelope/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"&gt; &lt;wsdl:types&gt; &lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" attributeFormDefault="qualified" elementFormDefault="qualified" targetNamespace="http://com.liuxiang.xfireDemo/HelloService"&gt; &lt;xsd:element name="sayHello"&gt; &lt;xsd:complexType&gt; &lt;xsd:sequence&gt; &lt;xsd:element maxOccurs="1" minOccurs="1" name="name" nillable="true" type="xsd:string" /&gt; &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt; &lt;/xsd:element&gt; &lt;xsd:element name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29d7455c95f3ce90531c96ce728901d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/921c8452ba57ad980141ae006afc830b/" rel="bookmark">
			使用cmd根据WSDL网址生成java客户端代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用cmd根据WSDL网址生成java客户端代码 windows下使用cmd命令提示符生成java webservice客户端代码，可以使用命令提示符直接生成客户端代码，直接导入到项目中，只需配置jdk即可，在jdk的bin文件夹下，按Shift并点击右键，选中“在此处打开命令窗口”，输入命令如下：
wsimport -keep -p com.demo.client -d D:\\(存放的地址) http://XX/Account?wsdl（wsdl地址） 命令参数说明： -d:生成客户端执行类的class文件的存放目录（默认存放在C:\Users\Administrator\） -s:生成客户端执行类的源文件的存放目录（默认存放在C:\Users\Administrator\） -p:定义生成类的包名
图示： 上面代码是在D盘下生成java代码，-d代表的是生成class文件和java文件，图示：
如果把这里的-d改为-s，生成的只有java文件，图示：
文件里面包名都是我们可以指定的，如果没有指定，使用的就是根据WSDL文档里面的targetNamespace来命名。 共勉：这个时代会犒赏那些爱学习的人。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbb0f1c4e99b6c5a5befbca00805543e/" rel="bookmark">
			功率W与dBm以及SINR/RSRP/RSRQ含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		W与dBm换算： dBm是一个表示功率绝对值的值(也可以认为是以1mW功率为基准的一个比 值)，计算公式为: dBm =10log(功率值/1mw)。 这里将dBm转换为W的口算规律是要先记住“1个基准”和“2个原则”: 1个基准：30dBm=1W 2个原则： 1）+3dBm，功率乘2倍；-3dBm，功率乘1/2 举例：33dBm=30dBm+3dBm=1W× 2=2W；27dBm=30dBm-3dBm=1W× 1/2=0.5W 2）+10dBm，功率乘10倍；-10dBm，功率乘1/10 举例：40dBm=30dBm+10dBm=1W× 10=10W ；20dBm=30dBm-10dBm=1W× 0.1=0.1W 以上可以简单的记作： 30是基准，等于1W整，互换不算难，口算可完成。加3乘以2，加10乘以10；减3除以2，减10除以10。 RSRP：（Reference Singnal Received Power，参考信号接收功率）是终端接收到的小区公共参考信号（CRS）功率值，数值为测量带宽内单个RE功率的线性平均值，反映的是本小区有用信号的强度。
RSSI：（Received Singnal Strengthen Indicator，接收信号强度指示）是终端接收到的所有信号（包括同频的有用和干扰、邻频干扰、热噪声等）功率的线性平均值，反映的是该资源上的负载强度。
RSRQ：（Reference Singnal Received Quality，参考信号接收质量）是N倍的RSRP与RSSI的比值，RSRQ=N*RSRP/RSSI,其中N表示RSRI的测量带宽内包含的RE数目，能反映出信号和干扰之间的相对大小。
SINR：（Signal to Interference&amp;Noise Ratio，信烦躁比）是有用信号功率与干扰和噪声功率之和的比值，直接反映接收信号的质量。
在3GPP的协议中，参考信号接收功率(RSRP)，定义为在考虑测量频带上，承载小区专属参考信号的资源粒子的功率贡献（以W为单位）的线性平均值。通俗的理解，可以认为RSRP的功率值就是代表了每个子载波的功率值在ue测量上报信息UL_DCCH/measurementReport中包含rsrpResult,rsrqResult信息： RSRP值为：RSRP = -140 + rsrpResult(dBm); RSRQ = -20 + 1/2*rsrqResult(dB)。
在3GPP的协议中，接收信号强度指示（RSSI）定义为：接收宽带功率，包括在接收机脉冲成形滤波器定义的带宽内的热噪声和接收机产生的噪声。测量的参考点为UE的天线端口。即RSSI（Received Signal Strength Indicator）是在这个接收到Symbol内的所有信号（包括导频信号和数据信号，邻区干扰信号，噪音信号等）功率的平均值。虽然也是平均值，但是这里还包含了来自外部其他的干扰信号，因此通常测量的平均值要比带内真正有用信号的平均值要高。
要了解SINR，可以先了解它的近亲，SNR。SNR（Signal Noise Ratio，信噪比），就是信号与噪声的比值。这一概念，估计学过通信基础的读者都很熟悉，在下面著名的香农公式中就有出现。C=B×log₂（1+S/N）（bit/s）虽然香农公式并不是用来计算信噪比的，但是却包含信噪比的概念和应用。它表明了信息传送速率C不只和信道带宽B有关，更与信噪比S/N有关。这一定程度上说明了信噪比是影响通信质量的一个关键因素。 目前协议没有对SINR的具体定义，通常表达方式如下： SINR=Signal / (Interference+Noise); S：测量到的有用信号的功率，主要关注的信号和信道包括：RS、PDSCH； I：测量到的信号或信道干扰信号的功率，包括本系统其他小区的干扰，以及异系统的干扰： N：低噪，与具体测量带宽和接收机噪声系数有关。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcdda80dc5ed266228df53f779f475af/" rel="bookmark">
			四种js求数组最大值的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d98a9d1ef54365e261954df8cbe5045/" rel="bookmark">
			二叉树前中后序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在研究二叉树的遍历，参考了网上的一些资料来写自己的递归算法，最后发现前中后三种顺序反应到代码中去，其实只是插入数据的时机不同。 不多解释，直接上代码。
public class TreeNode { public int val; public TreeNode left, right; public TreeNode(int val) { this.val = val; this.left = this.right = null; } } //前序遍历 public void getDLRList(ArrayList&lt;Integer&gt; rsList, TreeNode node){ rsList.add(node.val); if(node.left != null){ getDLRList(rsList, node.left); } if(node.right != null){ getDLRList(rsList, node.right); } } //中序遍历 public void getLDRList(ArrayList&lt;Integer&gt; rsList, TreeNode node){ if(node.left != null){ getLDRList(rsList, node.left); } rsList.add(node.val); if(node.right != null){ getLDRList(rsList, node.right); } } //后序遍历 public void getLRDList(ArrayList&lt;Integer&gt; rsList, TreeNode node){ if(node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d98a9d1ef54365e261954df8cbe5045/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0052252ba85e8c06a8d7d69fe0163be8/" rel="bookmark">
			5G NR名词解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2018年7月2日更新
以下是我在看3GPP的提案的时候总结的一些关于5G NR的英文缩写解释，后续也会慢慢补充，欢迎评论补充和指正。
BLER（blockerror rate）误块率
CB (code block)
CBG （code block group）NR中的重传单位不再是TB，而是CBG
CCE是(ControlChannel Element)的缩写，LTE的每个CCE由9个REG组成，之所以定义相对于REG较大的CCE，是为了用于数据量相对较大的PDCCH的资源分配。每个用户的PDCCH只能占用1，2，4，8个CCE，称为聚合级别。
CP(Cyclic Prefix)中文可译为循环前缀，它包含的是OFDM符号的尾部重复，CP主要用来对抗实际环境中的多径干扰，不加CP的话由于多径导致的时延扩展会影响子载波之间的正交性，造成符号间干扰。
Ø DTX （DiscontinuousTransmission不连续发送）
Ø gNB 5G基站
Ø MCS（Modulation and Coding Scheme，调制与编码策略）
Ø NCP Normal CP(Cyclic Prefix，循环前缀)
Ø PDCCH（PhysicalDownlink Control Channel，物理下行控制信道）
Ø PUSCH（Physical Uplink Shared Channel --物理上行共享信道）
Ø RB(ResourceBlock) 资源块：频率上连续12个子载波，时域上一个slot，称为1个RB。
Ø RE(ResourceElement)：频率上一个子载波及时域上一个symbol，称为一个RE。
Ø REG是ResourceElement Group的缩写，一个REG包括4个连续未被占用的RE。REG主要针对PCFICH和PHICH速率很小的控制信道资源分配，提高资源的利用效率和分配灵活性。
Ø SCS (subcarrier spacing)子载波间隔。LTE的SCS为固定的15KHz，但NR的SCS的宽度可以为15KHz、30KHz、60KHz、120KHz、240KHz。其中，NR在6GHz以下频段支持15KHz、30KHz和60KHz三种SCS，6GHz以上频段支持60KHz、120KHz和240KHz。
Ø TB(transport block)
Ø TTI（transmissiontime interval）传输时间间隔
eMBB（Enhance Mobile Broadband，增强型移动互联网）
uRLLC（Ultra Reliable &amp; LowLatency Communication， 超高可靠性与超低时延通信）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0052252ba85e8c06a8d7d69fe0163be8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f79701f04bbbc15f894770c1f433bb0c/" rel="bookmark">
			微指令的编码与数控程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在计算机组成原理控制单元设计的内容中，微程序设计思想是一个重要思想。微程序设计克服了组合逻辑控制单元线路庞杂的缺点，通过采用与存储程序类似的方法来解决微操作命令序列的形成。 微指令是类似于存储程序中指令的存在，但和存储程序中的指令有所不同，后者的操作对象是内存，前者的操作对象是控制器。在一条指令读取到CPU时，会先读取其指令类型（通常为一定长度的指令类型码），控制器根据指令类型做出相应动作（指令的执行），每一种指令对应一个微程序，一个微程序含有数条微指令，每一条微指令执行数个微操作命令。微程序存储在控制存储器中，控存的空间是有限的，因此对微指令的编码必须要有空间效率。 微指令的编码有如下方式： 1.直接编码方式 每一位代表一种微操作命令，如1代表打开某控制门，0代表禁止，这种方法速度快，但是动辄使控制字段达到几百位，需要极大的控存容量。 2.字段直接编码方式 字段直接编码讲微指令分成数段，每一段含互斥的微命令，如三位二进制代码就可以表示七个不同的微命令，因此可以用较少的二进制信息表示较多的微操作命令信号。这里要求不同字段之间的命令是相容的（可以同时执行），同一字段内的命令是互斥的（不可同时执行）。 3.字段间接编码方式 这种方式较第二种更加复杂，一个字段中的某些微命令还需要另一个字段中的微命令来解释。虽然进一步缩短了字长，但是削弱了并行控制能力，通常作为一种辅助手段。
在查阅数控程序的资料时，注意到JB/T 3208－1999这一标准中，G代码和M代码的一些特性，恰符合字段直接编码方式的一些特性。 如：G00 G01指令，分别代表点定位和直线插补，因此是不可同时执行的，是互斥代码，因此可以被编入同一字段；G02 G08，分别代表圆弧插补和加速，是可以同时执行的，因此编入不同字段。用这种编码方式可以极大便利编译程序的编写。
很多计算机思想，不仅在计算机领域，在很多其他行业都能带来启发式的灵感。如加速大概率事件、程序局部性，以及这次的指令编码方法。感觉无论学习什么，一定要领会其思想，这样才能融会贯通。
参考资料： 唐朔飞 计算机组成原理(第二版) 高等教育出版社 407~408
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17d6011b33f5f8b277128aa11afc2870/" rel="bookmark">
			操作系统(经典进程同步问题)之写者优先
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一个数据文件或记录可以被多个进程共享使用，我们将读文件的进程称为reader,写文件的进程成为writer。允许对个进程同属进行读取一个共享对象,因此读操作不会造成数据数据文件的混乱，但不允许reader，writer进行同时对共享文件的访问，因为这种访问会造成文件的数据混乱。所谓读者-写者问题。 读者-写者问题中，读者优先问题描述下面这种情况。 在文件的访问读取中，如果有写进程，写先进行写进程的调度，读进程在所有读进程完成后进行执行。这就是写者优先。 解决方法如下： 设置wmutex为各写者间的互斥时间访问。 设置Filemutex为文件互斥事件竞争访问 wcount为写进程的数量 rcount为读进程的数量 mutex1读进程互斥访问 mutex2写进程互斥访问 Writer：begin wait(mutex1): //申请文件的写进程 wcount = wcount+1; //文件写进程+1 if wcount = 1 then wait(Filemutex); //判断文件是不是有一个写进程，如果一个写进程申请文件使用权，确保文件无进程使用，否则写进程阻塞在这里 signal(mutex1); wait(wmutex);//申请写进程开始写 写数据； singal(wmutex);//释放写进程 wait(mutex1);//申请文件写进程 wcount = wcount - 1; //写进程-1 if wcount = 0 then singal(Filemutex);//此时，写进程为0，申请文件使用权进行释放写进程（因为写写进程互斥） singal(mutex1); end reader:begin wait(mutex1); //读者先进行申请文件的写申请，如果能够申请到mutex1表明有写进程正在执行，此时读进程阻塞 singal(mutex1);//获取mutex1后释放，让写进程能够随时申请到写进程 wait(mutex2); rcount = rount + 1; if rcount = 0 then wait(Filemutex)； singal(mutex2)； wait(mutex2); 读操作； singal(mutex2); wait(mutex2) rcount = rcount -1; if rcount = 0 then singal(Filemutex); singal(mutex2); end 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34d31b58e8440fab9a5e5372442ee28/" rel="bookmark">
			matlab中的图像坐标系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时我们的图显示了没有轴标记的图像。这是函数imshow的默认行为。但是几何图像变换的分析和解释是通过显示这些形象的排列来辅助的。开启标记的一种方法是在调用imshow之后调用axis。例如：
f=imread('circuit-board.tif'); imshow(f) axis on xlabel x ylabel y 如图，原点在左上角，x轴是水平的，并且向右延伸；y是垂直的，并且向下延伸。这个约定即图像空间坐标系统。在这个系统中，x轴和y轴与规定的图像坐标系统相反。用于设置一定的用户参数选择的工具箱函数iptsetpref可用于始终产生imshow以显示记号标志。为转向带有记号和标记的显示，可调用
iptsetpref imshowAxesVisible on 对于包含M行、N列的图像来说，默认的XData向量是[1,N],默认的YData向量是[1,M ]。可以设置XData和YData特性为其他的值，当工作在几何变换时，这可能非常有用。imshow函数通过可选择的参数值对的使用来支持这一功能。例如，用下面的语法来显示图像，左边和右边像素的中心在x轴的-20和20处，顶部和底部的像素在y轴的-10和10处：
imshow(f,'XData',[-20,20],'YData',[-10,10]) axis on xlabel x ylabel y 用以下命令放大图像左上角之后的结果：发现其中的像素已经不再是正方形。
axis([8 8.5 0.8 1.1]) 关于输出图像位置前面我们谈论了一副用仿射变换旋转过的图像。然而注意，那幅图像并没有显示输出图像的位置。函数imtransform可以通过使用附加参数来提供这个信息。调用语法是：
[g,xdata,ydata]=imtransform(f,tform) 当使用imshow显示图像时，第2个和第3个参数可以像XData和YData参数那样来使用。下面的例子说明了如何使用这些输出参量在相同的坐标系统中一起显示输入和输出图像。
在这个例子中，我们使用旋转和平移来研究如何在相同的坐标系中与输入图像一起显示和定位输出图像。我们以使用标以记号的轴和标记显示原始图像开始。
imshow(f) axis on 下面我们用imtransform使图像旋转3*pi/4弧度
theta=3*pi/4; T=[cos(theta) sin(theta) 0 -sin(theta) cos(theta) 0 0 0 1]; tform=maketform('affine',T); [g,xdata,ydata]=imtransform(f,tform,'FillValue',255); 我们在前边一行代码调用imtransform来说明两个新的概念。第一个是可选择的输出参量xdata和ydata的使用，这些用于在xy坐标系统中定位输出图像。另一个概念是选择输入参量：’FillValue’,255。FillValue参数指定用于任何输出图像像素的值，对应输入图像边界外的输入空间位置。 在默认的情况下，FillValue参数的值是0，即黑色。在这个例子中，我们希望它们是白色的。下边，我们希望遵循matlab的常用模式： （1）创建第一个绘图或者图像显示。 （2）调用hold on，以便后续的绘图或显示命令不清除该图。 （3）创建第二个绘图或者是绘图显示。 当显示输出图像时，从imtransform可选择的输出一起使用imshow的XData/YData语法：
imshow(f) hold on imshow(g,'XData',xdata,'YData',ydata) 接下来使用axis函数自动扩展轴的限制，以便两幅图像同时可见：
axis auto 最后，打开标有记号的轴和标记：
axis on 在结果中可以看到，仿射变换关于系统坐标原点（0,0）旋转图像。 接下来，我们检验平移，这是比旋转简单的仿射变换。但是，在目测时有可能被搞混。我们以构成仿射变换tform结构开始，向右移动500，向下移动200：
T=[1 0 0;0 1 0;500 200 1]; tform=maketform('affine',T); 接下来，我们使用基本的imtransform语法显示结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b34d31b58e8440fab9a5e5372442ee28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756b77f3d2643be5c28f84413a28e5b2/" rel="bookmark">
			win10如何让自己的exe程序开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ①鼠标右键自己的exe程序，创建快捷方式 ②win+R，打开运行对话框，输入shell：startup，如下图： 然后就打开了启动文件夹，如下： 将刚才生成的快捷方式拷贝到这个目录下就行啦，然后下次重启的时候自己的应用程序就可以自启动了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8ea0341c1dee563d78e5b2342b1eb79/" rel="bookmark">
			连接oracle数据库的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A（控制台连接）
1.进入cmd
2.输入命令：sqlplus 用户名/密码@//ip:1521/数据库名
或者：
1.进入cmd
2.输入sqlplus，然后回车
3.输入用户名
4.输入口令（密码），回车
5.成功连接到数据库
图：
B（XShell连接）
1.输入命令 sqlplus 用户名/密码@//ip:端口号/数据库服务名回车
在xshell中运行命令其实和在控制台一样
C（在sqlplus中以系统管理员身份登录）
1.运行sqlplus
2.输入命令：conn / as sysdba; 然后回车
3.输入用户名，回车
4.连接成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38838b45f4882cebd7d1370ba01fa39d/" rel="bookmark">
			left join连接2个查询结果集的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，可以确切的告诉大家，left join可以连接2个查询结果集。我们通常的用法 是，在left join的左边是一个查询结果集，然后右边是一个单表。如下：
SELECT S.STUDENT_NAME STUDENT_NAME, S.STUDENT_NO STUDENT_NO, F.ADDRESS ADDRESS FROM( SELECT G.GRADE_NO GRADE_NO, A.ADDRESS FROM GRADE G, ADDRESS A WHERE G.GRADE_NO = A.GRADE_NO ) F LEFT JOIN STUDENT S ON F.STUDENT_NO = S.STUDENT_NO 这是我们最常见的用法，基本上这种连接都能满足一般的查询需求。这里还要说明 一下，LEFT JOIN是先连接，后过滤。也就是说，在WHERE条件过滤之前，已经进行了连 接。假如我们现在有这样一种场景，我们需要连接STUDENT表中的所有2016届的学生， 而不是连接STUDENT表中所有的记录。那么我们就需要在连接之前查询出来所有2016届 的学生。这种场景，left join也能轻松搞定。如下： SELECT P.STUDENT_NAME STUDENT_NAME, P.STUDENT_NO STUDENT_NO, F.ADDRESS ADDRESS FROM( SELECT G.GRADE_NO GRADE_NO, A.ADDRESS FROM GRADE G, ADDRESS A WHERE G.GRADE_NO = A.GRADE_NO ) F LEFT JOIN ( SELECT S.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38838b45f4882cebd7d1370ba01fa39d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0584c4c099dd19b8756068658d86df06/" rel="bookmark">
			并发编程——原子性，可见性和有序性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。
1、原子性
即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。原子性就像数据库里面的事务一样，他们是一个团队，同生共死。一个很经典的例子就是银行账户转账问题：
比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。
所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。同样地反映到并发编程中会出现什么结果呢？举一个简单的例子：
i = 0; //1 j = i ; //2 i++; //3 i = j + 1; //4 上面四个操作，有哪个几个是原子操作，那几个不是？如果不是很理解，可能会认为都是原子性操作，其实只有1才是原子操作，其余均不是。
1在Java中，对基本数据类型的变量和赋值操作都是原子性操作； 2中包含了两个操作：读取i，将i值赋值给j 3中包含了三个操作：读取i值、i + 1 、将+1结果赋值给i； 4中同三一样 在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的（注：在32位的JDK环境下，对64位数据的读取不是原子性操作*，如long、double）。
要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。volatile是无法保证复合操作的原子性。
2、可见性
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。举个简单的例子，看下面这段代码：
//线程1执行的代码 int i = 0; i = 10; //线程2执行的代码 j = i; 假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i = 10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。
在上面已经分析了，在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。
对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。
3、有序性
即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：
int i = 0; boolean flag = false; i = 1; //语句1 flag = true; //语句2 上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0584c4c099dd19b8756068658d86df06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec362d3a6db4961550e2f3925e47790/" rel="bookmark">
			easyui1.5.1 datagrid 设置 pageNumber 无效问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载地址：http://www.jb51.net/article/89966.htm
修改位置：
将：
_718.pagination("refresh",{total:data.total});
修改为：
_718.pagination("refresh",{pageNumber:opts.pageNumber||_719.pageNumber,total:data.total});
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7be9459aba33dff0d5ae4cbf01a77506/" rel="bookmark">
			2017年 蓝桥杯模拟赛,猜算式(纯暴力)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：猜算式
你一定还记得小学学习过的乘法计算过程，比如：
273
x 15
------
1365
273
------
4095
请你观察如下的乘法算式
***
x ***
--------
***
***
***
--------
*****
星号代表某位数字，注意这些星号中，
0~9中的每个数字都恰好用了2次。
(如因字体而产生对齐问题，请参看图p1.jpg)
请写出这个式子最终计算的结果，就是那个5位数是多少？
注意：只需要填写一个整数，不要填写任何多余的内容。比如说明文字。
纯暴力解决 注意 题目要求 0-9的数字都包含两项, #include&lt;stdio.h&gt; #include&lt;string.h&gt; int ans[10]; void ddd(int x) { while(x) { ans[x%10]++; x/=10; } } int main() { int i,j,k; int fflag; for(i=100;i&lt;1000;i++) { for(j=100;j&lt;1000;j++) { fflag=0; if(i*j&gt;100000) break; memset(ans,0,sizeof(ans)); int a[2]; a[0]=i; a[1]=j; ddd(a[0]); ddd(a[1]); ddd(i*j); int b[3],temp1=i; k=0;int temp2=j; while(temp2) { b[k]=temp1*(temp2%10); if(b[k]&gt;1000||b[k]&lt;100) { fflag=1; break; } ddd(b[k++]); temp2/=10; } if(fflag) continue;	for(int l=0;l&lt;=9;l++) { if(ans[l]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7be9459aba33dff0d5ae4cbf01a77506/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9da8fc62b2b58fb48a7f351fcb7864d/" rel="bookmark">
			CMake: add_subdirectory()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个开发场景: 工程A输出一个库文件， 工程B输出可执行文件，但依赖于A的输出，利用CMake组织二者
方案1:
两个工程独立编译，把A的输出install到固定目录，工程B到该目录中解决依赖，可以使用find_library()
方案2:
利用脚本，本质上和方案1一样，但是通过脚本可以大量减少键盘操作
上述两个方案都是假设在configure工程B的时候，工程A的输出库文件已经存在，否则find_library()会提示错误，有没有办法
在工程A编译之前就成功编译工程B，即在CMake中指定工程B依赖于工程A？
方案3:
在工程B的CMakeLists.txt中使用ADD_SUBDIRECTORY()
如果A工程不在B工程目录结构下，需要指定binary_dir，即A工程输出路径
此时依赖关系不要用find_library()，否则一样错误，而要在target_link_libraries()中指定 (linux下，target_link_libraries()中此时不需要填写
lib的全名，而应该填写工程A的${PROJECT_NAME}即可)
方案3的补充：
工程A依赖于B和C， 而B和C同时依赖于D，如果在B和C中都使用ADD_SUBDIRECTORY()增加D，则最终编译A时会提示错误
cannot create target "D" because another target with the same name already exists 解决方法是在 B和C中使用target属性
if (NOT TARGET D) add_subdirectory( DRoot D) endif() 避免D被重复包含
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97dc6ed3879947e5e8d7ff5a775e760c/" rel="bookmark">
			scatter 基本用法 python matplotlib
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接看注释吧，知行合一！
# -*- coding: utf-8 -*- """ Created on Tue Mar 21 10:36:28 2017 罗干，同济大学图书馆 我爱婷婷和臭臭 @author: user """ #导入模块 from matplotlib import pyplot as plt import numpy as np #定义两个矩阵 A1=np.array([0,0]) B1=np.array(([2,0],[0,2])) #以 A1为均值，B1为协方差矩阵，生成正态分布的随机数 C1=np.random.multivariate_normal(A1,B1,10) C2=np.random.multivariate_normal(A1+0.2,B1+0.2,10) #画布的大小为长8cm高6cm plt.figure(figsize=(8,6)) #画图吧，s表示点点的大小，c就是color嘛，marker就是点点的形状哦o,x,*&gt;&lt;^,都可以啦 #alpha,点点的亮度，label，标签啦 plt.scatter(C1[:,0],C1[:,1],s=30,c='red',marker='o',alpha=0.5,label='C1') plt.scatter(C2[:,0],C2[:,1],s=30,c='blue',marker='x',alpha=0.5,label='C2') #下面三行代码很简单啦 plt.title('basic scatter plot ') plt.xlabel('variables x') plt.ylabel('variables y') plt.legend(loc='upper right')#这个必须有，没有你试试看 plt.show()#这个可以没有 import matplotlib.pyplot as plt x_coords = [0.13, 0.22, 0.39, 0.59, 0.68, 0.74, 0.93] y_coords = [0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97dc6ed3879947e5e8d7ff5a775e760c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e011fc919d53ee078f655d7aa36c5a/" rel="bookmark">
			图像特征提取三大算法：HOG特征，LBP特征，Haar特征
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）HOG特征 from：http://dataunion.org/20584.html
1、HOG特征： 方向梯度直方图（Histogram of Oriented Gradient, HOG）特征是一种在计算机视觉和图像处理中用来进行物体检测的特征描述子。它通过计算和统计图像局部区域的梯度方向直方图来构成特征。Hog特征结合 SVM分类器已经被广泛应用于图像识别中，尤其在行人检测中获得了极大的成功。需要提醒的是，HOG+SVM进行行人检测的方法是法国研究人员Dalal 在2005的CVPR上提出的，而如今虽然有很多行人检测算法不断提出，但基本都是以HOG+SVM的思路为主。
（1）主要思想： 在一副图像中，局部目标的表象和形状（appearance and shape）能够被梯度或边缘的方向密度分布很好地描述。（本质：梯度的统计信息，而梯度主要存在于边缘的地方）。
（2）具体的实现方法是： 首先将图像分成小的连通区域，我们把它叫细胞单元。然后采集细胞单元中各像素点的梯度的或边缘的方向直方图。最后把这些直方图组合起来就可以构成特征描述器。
（3）提高性能： 把这些局部直方图在图像的更大的范围内（我们把它叫区间或block）进行对比度归一化（contrast-normalized），所采用的方 法是：先计算各直方图在这个区间（block）中的密度，然后根据这个密度对区间中的各个细胞单元做归一化。通过这个归一化后，能对光照变化和阴影获得更 好的效果。
（4）优点： 与其他的特征描述方法相比，HOG有很多优点。首先，由于HOG是在图像的局部方格单元上操作，所以它对图像几何的和光学的形变都能保持很好的不 变性，这两种形变只会出现在更大的空间领域上。其次，在粗的空域抽样、精细的方向抽样以及较强的局部光学归一化等条件下，只要行人大体上能够保持直立的姿 势，可以容许行人有一些细微的肢体动作，这些细微的动作可以被忽略而不影响检测效果。因此HOG特征是特别适合于做图像中的人体检测的。
2、HOG特征提取算法的实现过程： 大概过程： HOG特征提取方法就是将一个image（你要检测的目标或者扫描窗口）：
1）灰度化（将图像看做一个x,y,z（灰度）的三维图像）；
2）采用Gamma校正法对输入图像进行颜色空间的标准化（归一化）；目的是调节图像的对比度，降低图像局部的阴影和光照变化所造成的影响，同时可以抑制噪音的干扰；
3）计算图像每个像素的梯度（包括大小和方向）；主要是为了捕获轮廓信息，同时进一步弱化光照的干扰。
4）将图像划分成小cells（例如6*6像素/cell）；
5）统计每个cell的梯度直方图（不同梯度的个数），即可形成每个cell的descriptor；
6）将每几个cell组成一个block（例如3*3个cell/block），一个block内所有cell的特征descriptor串联起来便得到该block的HOG特征descriptor。
7）将图像image内的所有block的HOG特征descriptor串联起来就可以得到该image（你要检测的目标）的HOG特征descriptor了。这个就是最终的可供分类使用的特征向量了。
具体每一步的详细过程如下： （1）标准化gamma空间和颜色空间 为了减少光照因素的影响，首先需要将整个图像进行规范化（归一化）。在图像的纹理强度中，局部的表层曝光贡献的比重较大，所以，这种压缩处理能够有效地降低图像局部的阴影和光照变化。因为颜色信息作用不大，通常先转化为灰度图；
Gamma压缩公式：
比如可以取Gamma=1/2；
（2）计算图像梯度
计算图像横坐标和纵坐标方向的梯度，并据此计算每个像素位置的梯度方向值；求导操作不仅能够捕获轮廓，人影和一些纹理信息，还能进一步弱化光照的影响。
图像中像素点(x,y)的梯度为：
最常用的方法是：首先用[-1,0,1]梯度算子对原图像做卷积运算，得到x方向（水平方向，以向右为正方向）的梯度分量gradscalx，然后用[1,0,-1] T 梯度算子对原图像做卷积运算，得到y方向（竖直方向，以向上为正方向）的梯度分量gradscaly。然后再用以上公式计算该像素点的梯度大小和方向。
（3）为每个细胞单元构建梯度方向直方图 第三步的目的是为局部图像区域提供一个编码，同时能够保持对图像中人体对象的姿势和外观的弱敏感性。
我们将图像分成若干个“单元格cell”，例如每个cell为6*6个像素。假设我们采用9个bin的直方图来统计这6*6个像素的梯度信息。也 就是将cell的梯度方向360度分成9个方向块，如图所示：例如：如果这个像素的梯度方向是20-40度，直方图第2个bin的计数就加一，这样，对 cell内每个像素用梯度方向在直方图中进行加权投影（映射到固定的角度范围），就可以得到这个cell的梯度方向直方图了，就是该cell对应的9维特 征向量（因为有9个bin）。
像素梯度方向用到了，那么梯度大小呢？梯度大小就是作为投影的权值的。例如说：这个像素的梯度方向是20-40度，然后它的梯度大小是2（假设啊），那么直方图第2个bin的计数就不是加一了，而是加二（假设啊）。
细胞单元可以是矩形的（rectangular），也可以是星形的（radial）。
（4）把细胞单元组合成大的块（block），块内归一化梯度直方图 由于局部光照的变化以及前景-背景对比度的变化，使得梯度强度的变化范围非常大。这就需要对梯度强度做归一化。归一化能够进一步地对光照、阴影和边缘进行压缩。
作者采取的办法是：把各个细胞单元组合成大的、空间上连通的区间（blocks）。这样，一个block内所有cell的特征向量串联起来便得到 该block的HOG特征。这些区间是互有重叠的，这就意味着：每一个单元格的特征会以不同的结果多次出现在最后的特征向量中。我们将归一化之后的块描述 符（向量）就称之为HOG描述符。
区间有两个主要的几何形状——矩形区间（R-HOG）和环形区间（C-HOG）。R-HOG区间大体上是一些方形的格子，它可以有三个参数来表征：每个区间中细胞单元的数目、每个细胞单元中像素点的数目、每个细胞的直方图通道数目。
例如：行人检测的最佳参数设置是：3×3细胞/区间、6×6像素/细胞、9个直方图通道。则一块的特征数为：3*3*9；
（5）收集HOG特征 最后一步就是将检测窗口中所有重叠的块进行HOG特征的收集，并将它们结合成最终的特征向量供分类使用。
（6）那么一个图像的HOG特征维数是多少呢？ 顺便做个总结：Dalal提出的Hog特征提取的过程：把样本图像分割为若干个像素的单元（cell），把梯度方向平均划分为9个区间 （bin），在每个单元里面对所有像素的梯度方向在各个方向区间进行直方图统计，得到一个9维的特征向量，每相邻的4个单元构成一个块（block），把 一个块内的特征向量联起来得到36维的特征向量，用块对样本图像进行扫描，扫描步长为一个单元。最后将所有块的特征串联起来，就得到了人体的特征。例如， 对于64*128的图像而言，每16*16的像素组成一个cell，每2*2个cell组成一个块，因为每个cell有9个特征，所以每个块内有 4*9=36个特征，以8个像素为步长，那么，水平方向将有7个扫描窗口，垂直方向将有15个扫描窗口。也就是说，64*128的图片，总共有 36*7*15=3780个特征。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66e011fc919d53ee078f655d7aa36c5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6a0886fd07456544d71367617610f1b/" rel="bookmark">
			IPC共享内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt; #include &lt;error.h&gt; #define SIZE 1024 int main() { int shmid ; char *shmaddr ; struct shmid_ds buf ; int flag = 0 ; int pid ; shmid = shmget(IPC_PRIVATE, SIZE, IPC_CREAT|0600 ) ; if ( shmid &lt; 0 ) { perror("get shm ipc_id error") ; return -1 ; } pid = fork() ; if ( pid == 0 ) { shmaddr = (char *)shmat( shmid, NULL, 0 ) ; if ( (int)shmaddr == -1 ) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6a0886fd07456544d71367617610f1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/157258ef94e5fa513e8957c8c30fb3eb/" rel="bookmark">
			数据库并发操作会带来哪些问题及原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）丢失更新
当两个或多个事物读入同一数据并修改，会发生丢失更新问题，即后一个事物更新的结果被前一事务所做更新覆盖 即当事务A和B同事进行时，事务A对数据已经改变但并未提交时B又对同一数据进行了修改（注意此时数据是A还未提交改变的数据），到时A做的数据改动丢失了
（2）不可重复读
当两个数据读取某个数据后，另一事务执行了对该数据的更新，当前一事务再次读取该数据（希望与第一次读取的是相同的值）时，得到的数据与前一次的不一样，这是由于第一次读取数据后，事务B对其做了修改，导致再次读取数据时与第一次读取的数据不想同
（3）读‘脏数据’
当一个事务修改某个数据后，另一事务对该数据进行了读取，由于某种原因前一事务撤销了对改数据的修改，即将修改过的数据恢复原值，那么后一事务读到的数据与数据可得不一致，称之为读脏数据
注意：还有一个叫“幽灵数据” 幽灵数据与脏数据类似，不过幽灵数据是指事务提交之后读到的数据，但是在读取之后又进行了对前一事务的恢复，而脏数据是指并未提交前读取的数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d108e5d769258a808563a341c4ccf036/" rel="bookmark">
			学习笔记①：使用python进行文本分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-- coding:utf-8 -- author = ‘zengyun’ import numpy as np
def 回调函数 词表到向量的转换函数 def load_data_set(): # 创建试验样本。 posting_list = [[‘my’, ‘dog’, ‘has’, ‘flea’, ‘problems’, ‘help’, ‘please’], [‘maybe’, ‘not’, ‘take’, ‘him’, ‘to’, ‘dog’, ‘park’, ‘stupid’], [‘my’, ‘dalmation’, ‘is’, ‘so’, ‘cute’, ‘i’, ‘love’, ‘him’], [‘stop’, ‘posting’, ‘stupid’, ‘worthless’, ‘garbage’], [‘mr’, ‘licks’, ‘ate’, ‘my’, ‘steak’, ‘how’, ‘to’, ‘stop’, ‘him’], [‘quit’, ‘buying’, ‘worthless’, ‘dog’, ‘food’, ‘stupid’]] class_vec = [0, 1, 0, 1, 0, 1] # 1 代表侮辱性文字，0 代表正常言论。 # class_vec 返回第二个变量，是一个类别标签的集合。有两类 1 和 0 。 # 这些文本的类别由人工标注，这些标注信息用于训练程序以便自动检测侮辱性留言。 return posting_list, class_vec
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d108e5d769258a808563a341c4ccf036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a4cda3f228f9b350a0a53639b9e1a06/" rel="bookmark">
			EL表达式和JSTL表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、EL表达式 EL表达式提供了在JSP中简化表达式的方法，基于可用的命名空间（PageContext属性）、嵌套属性和对集合、操作符（算术型、关系型和逻辑型）的访问符、映射到Java类中静态方法的可扩展函数以及一组隐式对象。
1 EL特点和使用简介 格式：${…}
例如：EL表达式${sessionScope.user.sex} 对应下面的JSP代码
&lt;%User user = (User)session.getAttribute(“user”);
Stringsex = user.getSex();%&gt;
EL提供.和[]两种运算符来存取 数据，[]可以访问集合或数组的元素、Bean的属性。（前提是属性要有getXXX和setXXX方法）
例如：${sessionScope.user.sex}
==
${sessionScope.user[“sex”]}
2 EL运算符 ==或eq / !=或ne &lt;或lt / &gt;或gt
&lt;=或le / &gt;=或ge
${empty A = param.name} //用于判断值是否为空，A为null/不存在/空时，返回true，否则返回false
判断是否相等：${param.password1== param.password2}
3获取表单数据 我们一般取得用户请求参数：
Request.getParameter(String name) //获得单个数值
Request.getParameterValue(String name) //获得多个同名数值，如CheckBox
在EL中则
${param.name} //获得单个数值
${paramValues.name} //获得多个同名数值
${paramValues.hobbies[0]} //获得多个同名数值中的第N个
4 EL的隐含对象 JSP对象 EL隐含对象 EL表达式 JSP
parameter param ${param.name} &lt;%request.getParameter(“user”)%&gt;
page pageScope
request requestScope ${requestScope.user} &lt;%request.getAttribute(“user”)%&gt;
session sessionScope
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a4cda3f228f9b350a0a53639b9e1a06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec64b79ad17cf8a43df1ff89337e48ea/" rel="bookmark">
			数据结构实例&lt;九&gt;（IsHappy 快乐数）容易
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 写一个算法来判断一个数是不是"快乐数"。
一个数是不是快乐是这么定义的：对于一个正整数，每一次将该数替换为他每个位置上的数字的平方和，然后重复这个过程直到这个数变为1，或是无限循环但始终变不到1。如果可以变为1，那么这个数就是快乐数。
样例
19 就是一个快乐数。
1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1 Code： *首先是无限循环获取下一个要处理的数据，GetNextNum().直至跳出循环。
*判断是否是快乐树，等于一就是快乐数。非快乐数将会陷入一个死循环，我们利用数组存储，判定是否匹配即为非快乐数。
public class IsHappy { /** * @param n an integer * @return true if this is a happy number or false */ //不是快乐数的数称为不快乐数（unhappy number），所有不快乐数的数位平方和计算，最後都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中。 public Boolean isHappy(int n) { // Write your code here var temp = n; int[] unhappy = { 4, 16, 37, 58, 89, 145, 42, 20, 4 }; while (true) { temp = GetNextNum(temp); if (temp == 1) { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec64b79ad17cf8a43df1ff89337e48ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f528f333b7c3c44fa77d5c032bce6179/" rel="bookmark">
			数据结构实例&lt;七&gt;（Left-Pad 左填充）容易
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 实现一个leftpad库，如果不知道什么是leftpad如下所示：
leftpad("foo", 5)
&gt;&gt; " foo"
leftpad("foobar", 6)
&gt;&gt; "foobar"
leftpad("1", 2, "0")
&gt;&gt; "01"
*实现多重载leftpad() ，表示两种不同需求的展示。
*问题的关键点 长度 和 附加Str的组装。
*长度我们要考虑原Str的Length 和现有Size的差值比较，在合理情况下才可以继续，否则返回false.
*Str的组装，利用Size差值while循环累加Str得到附加Str.
public class StringUtils { /** * @param originalStr the string we want to append to with spaces * @param size the target length of the string * @return a string */ public String leftPad(String originalStr, int size) { // Write your code here var strLength = originalStr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f528f333b7c3c44fa77d5c032bce6179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8af48443261a5b7649d0a4e8094d1224/" rel="bookmark">
			TMS320C6747的I2C模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.CCR地址 X1226的CCR（Clock/Control Register，时钟/控制寄存器）地址为1101111（0x6f）（忽略最后一位R/W位，从第二位开始，I2C的7位寻址模式），故从I2C从设备地址SCL应为0x6f。
（X1226手册P12）
在往CCR写入之前，主设备必须先往状态寄存器（SR）先写入一个02h，再写入一个06h才行。状态寄存器的地址为0x003f，对应跟在slave address之后的word address。
2.6747的I2C模块 6747具有两个I2C模块I2C0和I2C1。这简化了系统架构，因为可以在DSP使用一个模块控制IC片上的外设（DACs，ADCs，等等）的同时，用另外一个模块与其他控制器通信或者实现一个用户接口。
2.1初始化 在开始和其他I2C设备进行通信前，需要适当的I2C初始化。除非已经有完整的驱动，否则你需要确定所需的I2C配置，并且对I2C配置成所需的设置。第一个任务是使能I2C的时钟。然后I2C控制器就会处于复位状态。现在可以开始配置I2C控制器了。一旦配置完成，需要通过将控制器从复位状态中释放出来，以使能I2C控制器。在开始通信之前，你需要确保所有的状态位被清除了，同时不存在挂起中断。一旦总线可用，I2C就可以进行通信了。下面看代码，
/* IIC 配置引脚 */ I2C_GPIO( ); /*初始I2C模块，以便访问X1226*/ C6747_I2C_init(); 其中，I2C_GPIO();函数如下：
该函数将PINMUX8寄存器的第12~15位和第16~19位设置为02h，即0010b，查阅手册可知这两个字段含义如图：
（用户手册P203~204）
可见，该函数将6747的这两个引脚的功能配置成了I2C0的SCL线和I2C0的SDA线。然后是I2C的初始化函数，代码如下：
/*------------------------------------------------------------------------ * * * * _I2C_init( ) * * * * Enable and initalize the I2C module * * The I2C clk is set to run at 20 KHz * * * *------------------------------------------------------------------------ */ Int16 C6747_I2C_init( ) { I2C_ICMDR = 0; // Reset I2C I2C_ICPSC = 3; // Prescale to get 12MHz I2C internal I2C_ICCLKL = 10; // Config clk LOW for 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8af48443261a5b7649d0a4e8094d1224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3f326f33cdbe124fb08ba01c15ac079/" rel="bookmark">
			MyCat部署运行（Windows环境）与使用步骤详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://blog.csdn.net/Stubborn_Cow/article/details/46967407 1、MyCat概念
1.1 总体架构 MyCAT的架构如下图所示：
MyCAT使用MySQL的通讯协议模拟成一个MySQL服务器，并建立了完整的Schema（数据库）、Table（数据表）、User（用户）的逻辑模型，并将这套逻辑模型映射到后端的存储节点DataNode（MySQL Instance）上的真实物理库中，这样一来，所有能使用MySQL的客户端以及编程语言都能将MyCAT当成是MySQLServer来使用，不必开发新的客户端协议。
当MyCAT收到一个客户端发送的SQL请求时，会先对SQL进行语法分析和检查，分析的结果用于SQL路由，SQL路由策略支持传统的基于表格的分片字段方式进行分片，也支持独有的基于数据库E-R关系的分片策略，对于路由到多个数据节点（DataNode）的SQL，则会对收到的数据集进行“归并”然后输出到客户端。
SQL执行的过程，简单的说，就是把SQL通过网络协议发送给后端的真正的数据库上进行执行，对于MySQL Server来说，是通过MySQL网络协议发送报文，并解析返回的结果，若SQL不涉及到多个分片节点，则直接返回结果，写入客户端的SOCKET流中，这个过程是非阻塞模式（NIO）。
DataNode是MyCAT的逻辑数据节点，映射到后端的某一个物理数据库的一个Database，为了做到系统高可用，每个DataNode可以配置多个引用地址（DataSource），当主DataSource被检测为不可用时，系统会自动切换到下一个可用的DataSource上，这里的DataSource即可认为是Mysql的主从服务器的地址。
1.2 逻辑库 与任何一个传统的关系型数据库一样，MyCAT也提供了“数据库”的定义，并有用户授权的功能，下面是MyCAT逻辑库相关的一些概念：
schema:逻辑库，与MySQL中的Database（数据库）对应，一个逻辑库中定义了所包括的Table。table：表，即物理数据库中存储的某一张表，与传统数据库不同，这里的表格需要声明其所存储的逻辑数据节点DataNode，这是通过表格的分片规则定义来实现的，table可以定义其所属的“子表(childTable)”，子表的分片依赖于与“父表”的具体分片地址，简单的说，就是属于父表里某一条记录A的子表的所有记录都与A存储在同一个分片上。分片规则：是一个字段与函数的捆绑定义，根据这个字段的取值来返回所在存储的分片（DataNode）的序号，每个表格可以定义一个分片规则，分片规则可以灵活扩展，默认提供了基于数字的分片规则，字符串的分片规则等。dataNode: MyCAT的逻辑数据节点，是存放table的具体物理节点，也称之为分片节点，通过DataSource来关联到后端某个具体数据库上，一般来说，为了高可用性，每个DataNode都设置两个DataSource，一主一从，当主节点宕机，系统自动切换到从节点。dataHost：定义某个物理库的访问地址，用于捆绑到dataNode上。 MyCAT目前通过配置文件的方式来定义逻辑库和相关配置：
· MYCAT_HOME/conf/schema.xml中定义逻辑库，表、分片节点等内容；
· MYCAT_HOME/conf/rule.xml中定义分片规则；
· MYCAT_HOME/conf/server.xml中定义用户以及系统相关变量，如端口等。
下图给出了MyCAT一个可能的逻辑库到物理库（MySQL的完整映射关系），可以看出强大的分片能力以及灵活的Mysql集群整合能力。 2、 MyCat基本使用教程 2.1 下载和安装 MyCAT使用Java开发，因为用到了JDK 7的部分功能，所以在使用前请确保安装了JDK 7.0，要求是JDK 7.0以上，并设置了正确的Java环境变量
目前下载的版本是免安装，解压在任意磁盘、根目录下，避免路径中出现中文。
目录下的“Mycat-server-1.2-GA-win.tar.gz”文件，解压后的目录结构如下图所示：
目录说明见下表所示：
目录名称
说明
bin
存放window版本和Linux版本，除了提供封装成服务的版本之外，也提供nowrap的shell脚本命令，方便大家选择和修改。
Windows 下 运行：mycat.bat console在控制台启动程序，也可以装载成服务，若此程序运行有问题，也可以运行startup_nowrap.bat，确保java命令可以在命令执行。
Warp方式的命令，可以安装成服务并启动或停止。
l mycat install (可选)
l mycat start
注意，wrap方式的程序，其JVM配置参数在conf/wrap.conf中，可以修改为合适的参数，参数调整参照http://wrapper.tanukisoftware.com/doc/english/properties.html。
conf
存放配置文件：
l server.xml：是Mycat服务器参数调整和用户授权的配置文件。
l schema.xml：是逻辑库定义和表以及分片定义的配置文件。
l rule.xml：是分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件，也在这个目录下，配置文件修改，需要重启MyCAT或者通过9066端口reload。
l wrapper.conf：JVM配置参数等设置。
l log4j.xml：日志存放在logs/mycat.log中，每天一个文件，日志的配置是在conf/log4j.xml中，根据自己的需要，可以调整输出级别为debug，debug级别下，会输出更多的信息，方便排查问题。
lib
MyCAT自身的jar包或依赖的jar包的存放目录。
logs
MyCAT日志的存放目录。日志存放在logs/mycat.log中，每天一个文件
2.2 启动和停止 安装mycat服务 ：mycate install 启动mycat服务 ：mycate start
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3f326f33cdbe124fb08ba01c15ac079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ad36d48faad03c8172b21104918b8aa/" rel="bookmark">
			并查集的使用及其实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		并查集 概述 详细教程参考之前转载的并查集详解
性质 并查集算法（union_find sets）不支持分割一个集合,求连通子图、求最小生成树
用法 并查集是由一个数组pre[]，和两个函数构成的，一个函数为find()函数，用于寻找前导点的，第二个函数是join()用于合并路线的
int find(int x) { int r=x; while(pre[r]!=r) r=pre[r];//找到他的前导结点 int i=x,j; while(i!=r)//路径压缩算法 { j=pre[i];//记录x的前导结点 pre[i]=r;//将i的前导结点设置为r根节点 i=j; } return r; } 路径压缩为了加快查找的速度，将x点与其根节点直接相连，构造成类似于只有叶子结点而没有分支结点的树
join()函数
void join(int x,int y) { int a=find(x);//x的根节点为a int b=find(y);//y的根节点为b if(a!=b)//如果a,b不是相同的根节点，则说明ab不是连通的 { pre[a]=b;//我们将ab相连 将a的前导结点设置为b } } 初始化 我们将每一个结点的前导结点设置为自己，如果在join函数时未能形成连通，将独立成点
for(int i=0;i&lt;n;i++)//n表示输入的结点的个数 { pre[i]=i;//将每一个结点的前导点设置为自己 } 用法 试题来自第八届蓝桥杯试题 第三次编辑这道题目 标题：风险度量
X星系的的防卫体系包含 n 个空间站。这 n 个空间站间有 m 条通信链路，构成通信网。 两个空间站间可能直接通信，也可能通过其它空间站中转。
对于两个站点x和y (x != y), 如果能找到一个站点z，使得： 当z被破坏后，x和y无法通信，则称z为关于x,y的关键站点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ad36d48faad03c8172b21104918b8aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b1e101f5735b67bc9417e6a7cad72ce/" rel="bookmark">
			用FFT求信号相位谱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看一下我收到的程序，作为研究对象的信号是这样产生的： T=128; N=128; dt=T/N; t=dt*(1:N); x=2*cos(2*t-pi/4); ... （我觉得这个信号存在一点问题，因为t是从1开始的，所以它的初相应该和-pi/4有点差别吧。） 为什么进行FFT，用angle得到相位－频率特性却不能反映这个信号的初始相位？ 胡广书的《数字信号处理－理论、算法与实现（第二版）》第三章第八节《关于正弦信号抽样的讨论》，得出了关于正弦信号抽样的六个结论，最后总结了一个总的原则：抽样频率应为信号频率的整数倍，抽样点数应包含整周期。 书中的结论五与采样频率和抽样点数有很大的关联。结论五主要说只有满足了上面的那个总的原则，频谱泄漏才不会发生。我想不光是幅度谱的频谱泄漏现象，抽样频率和抽样点数同样会对相位谱产生影响。 考虑一个无限长的正弦信号（相当于初相为－90°），如果我们截取它的整数个周期，然后对截短的信号进行周期延拓，则得到的延拓的信号与原无限长正弦没有区别。 现在我们再次对这个无限长的正弦进行截短，长度为1.5个周期，然后对截短信号进行周期延拓，看看我们得到了什么？ 下图，截短信号 下图，对截短信号周期延拓：
可以看出，此时进行周期延拓得到的信号与原来的正弦信号大相径庭。新的周期信号是一个周期的偶函数，原无限长正弦是一个周期的奇函数，两者奇偶性都不一样了，因此不能指望利用新的信号的DFT求出原信号的初相。exp(-jωt)=cos(ωt)-jsin(ωt)，进行变换的时候，若f(t)为实偶函数，则f(t)sin(ωt)就是奇函数，对一个奇函数在对称区间内积分只能得到0，因此实偶函数的傅立叶变换肯定是实的，对一个实数用angle求相位，当然相位是0。而原正弦肯定是初相为－90°。
我想这就是问题所在，DFT就是DFS，只不过DFT先将有限长信号进行周期延拓，然后求DFS，再截取一个周期。
使用DFT，在有限的观测时间内采集信号的信息。如若观测时间内正好得到了整数个正弦周期，则DFT的周期延拓可以不失真的表示原正弦，可是如果观测时间内得到的信号不是整数个周期，那么问题随之而来，就像上面的例子，观测时间内得到了1.5个周期的正弦，然后进行周期延拓，显然乱了套。
如果满足了胡广书老师所总结的抽样条件，则对正弦的DFT谱无疑可以很好地反映初相，我写了两个例子：
第一个例子，信号只包含一个正弦：
t=linspace(0,2-0.125,16);
x=cos(2*pi*t+pi/4);
X=fft(x);
stem(abs(X));
figure;
stem(angle(X)/pi*180);
幅度谱：
相位谱：
可以看见DFT相位谱第三个点对应正弦的相位，刚好是45°。
第二个例子信号中包含两个正弦：
t=linspace(0,2-0.125,16);
x=cos(2*pi*t+pi/4)+2*cos(2*pi*0.5*t+pi/8);
X=fft(x);
stem(abs(X));
figure;
stem(angle(X)/pi*180);
幅度谱：
相位谱：
可以看见DFT相位谱第二个和第三个点对应两个正弦的相位，刚好是22.5°和45°。
如果没有满足上面所说的条件，就会得到不准确的结果，有兴趣可试试下面的代码： t=linspace(0,2.5-0.125,32);
x=cos(2*pi*t+pi/4);
X=fft(x);
stem(abs(X));
figure;
stem(angle(X)/pi*180);
如何克服这个问题？我觉得这非常困难。在不能预知信号频率的情况下，无法确定采样频率和观测点数。也许可以先进行一次观测，通过幅度谱估计出正弦的频率，然后根据频率调整抽样频率，重新对信号进行采样，使采样符合上面所述的条件。但是这样做有很多的问题，例如硬件可能不好实现。而且虽然第二次调整了采样频率和抽样点数，可是初始相位已经无法得到了，因为第二次采样不可能再从零时刻开始。
Sandygreta同学说可以这样做，先以较高的抽样频率对信号进行采样，通过FFT幅度谱估算出正弦信号的频率，然后计算出满足抽样条件的最佳的抽样频率和观测时间，使抽样频率为正弦频率的整数倍（大于2倍），且观测时间内能正好得到整数个正弦周期。然后对刚才采集的信号样本进行插值，接着使用计算出来的采样频率和观测时间对插值的结果重新采样，计算FFT，得到初始相位。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/130e8ec780ee6f4bcffd97938ab724c2/" rel="bookmark">
			端口扫描—TCP SYN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP SYN()扫描
扫描程序向目标主机发送SYN数据段，好像准备打开一个实际的连接并等待反映一样。如果收到的应答是SYN/ACK，那么说明目标端口处于监听状态。如果收到的应答是RST，说明目标端口是关闭的。 扫描程序在收到应答之后不管是何种应答，都向目标主机发送一个RST/ACK分组、这样，虽然没有建立一个完整的TCP连接，但扫描程序也能从目标主机的应答中知道目标主机的某个端口是否开放。 由于扫描是并未建立全连接，所以这种技术通常也称为“半连接”扫描，如图：
采用这种“半打开扫描”，目标系统并不对它进行登记，因此比前一种TCP Connect()扫描更隐蔽。即使日志中对于扫描有所记录，对尝试连接的记录也要比全扫描的记录少得多。但在大部分操作系统中，发送主机需要构造适用于这种扫描类型的IP包，通常只有草鸡用户或得到的用户才有权限访问专门的系统调用，构造这种这种专门的 SYN 数书包。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/454/">«</a>
	<span class="pagination__item pagination__item--current">455/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/456/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>