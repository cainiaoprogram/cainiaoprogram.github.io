<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b0c428d22a2152002634ca7fe14619f/" rel="bookmark">
			TLS回调函数的两种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #ifdef _WIN64 #pragma comment(linker, "/INCLUDE:_tls_used") #pragma comment(linker, "/INCLUDE:tls_callback") #else #pragma comment(linker, "/INCLUDE:__tls_used") #pragma comment(linker, "/INCLUDE:_tls_callback") #endif void NTAPI tls_callback(PVOID hModule, DWORD reason, PVOID pContext); #if 0 #ifdef _WIN64 #pragma const_seg(".CRT$XLB") EXTERN_C const #else #pragma data_seg(".CRT$XLB") EXTERN_C #endif PIMAGE_TLS_CALLBACK tls_callback_func = tls_callback; #ifdef _WIN64 #pragma const_seg() #else #pragma data_seg() #endif //_WIN64 #endif #if 1 #pragma section(".CRT$XLB", long, read) __declspec(allocate(".CRT$XLB")) EXTERN_C PIMAGE_TLS_CALLBACK tls_callback_func = tls_callback; #endif void NTAPI tls_callback(PVOID hModule, DWORD reason, PVOID pContext) { UNREFERENCED_PARAMETER(hModule); UNREFERENCED_PARAMETER(pContext); if (reason == DLL_PROCESS_ATTACH) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b0c428d22a2152002634ca7fe14619f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c4673bc0fe73fd01f484058626c614/" rel="bookmark">
			【宝塔下的免费 waf 防火墙对比】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近搭建了一个网站以后，总觉得裸奔的网站非常不安全，需要加上防护措施。加一套 waf 防火墙，然后就可以安心的睡觉了。因为服务器使用了宝塔1管理，所以我需要既能跟宝塔一起用的 waf。
先说结论 宝塔自带 waf 收费；宝塔软件商店里 waf 要么不合适，要么门槛太高，不好用；其它免费 waf 大多要命令行安装，发挥不了宝塔优势。 最好是有一个能在宝塔 docker 上运行的防火墙，既能用宝塔管理服务状态，又能有自己管理界面的 waf，而且要免费，还得有效。所以，我最后选择用 docker compose 模板 + 雷池 waf 社区版。安装方法参考我的另一篇文章 https://www.jianshu.com/p/978e08095628
waf 对比 宝塔内置 waf 既然用宝塔做服务管理，第一反应就是在宝塔上找找没有合适的 waf。在非常显眼的地方，找到了 “防火墙” 入口，然后看到了非常显眼的 “立即购买”。本着来都来了的想法，看了一下官方防火墙的功能介绍2，功能还是非常多的，各位看官有钱的捧个钱场，我只能捧个人场。
另外根据文档介绍，nginx 防火墙是基于 Lua 实现的，也就是说这个防火墙的本质是人工规则，人工规则防火墙在防护能力上可以抵御常见攻击，只能亡羊补牢不能防患未然。宝塔内置 waf 还有一个 Apache 版本3，与 nginx 类似，只是一个基于 Apache 一个基于 Nginx，这两者的差别见仁见智，宝塔官方推荐的是 nginx 版本。
宝塔软件商店中的免费 waf 宝塔自带了一个软件商店，抱着试试看的态度搜了一下，还真找到了 3 款 waf。前两个是官方内置的收费版，第 3 个则是免费版。这一看，不得了啊，这是打算跟官方同台竞技啊。赶紧装上试试。
感谢作者 “民国三年一场雨”，民国三年就是 1914年，一百多年过去了，也不知道雨里发生什么。考虑到这个应用只有 403.95k 大小，总觉得这个功能可能没有想的那么多。
根据配置界面，启用防护，然后试着发起一次攻击请求，然后被拦截了。后台管理界面看到的效果记录是：
拦截效果是：
拦截页面上还有提示，误报请联系宝塔 http://www.bt.cn/bbs？这不是官方 waf 么？为什么非要伪装一下自己？在一个隐蔽角落还找到一个“教程”链接4，发帖人是宝塔技术-小强5，这下是官方的免费 waf 没跑了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5c4673bc0fe73fd01f484058626c614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f81325865b78103118ee2e538c968dd/" rel="bookmark">
			【博客679】LVS NAT模式与FULLNAT模式原理与配置差别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LVS NAT模式与FULLNAT模式原理与配置差别 注意： LVS NAT模式是LVS原生的一种工作方式，而FULLNAT是在NAT模式下通过配置SNAT来
实现FULLNAT的，而且配合SNAT这部分是靠我们自己来实现的
1、LVS NAT模式原理与特点 NAT模式的数据包请求流程：
1、当用户请求到达 Director Server，此时请求的数据报文会先到内核空间的 PREROUTING 链。 此时报文的源 IP 为 CIP，目标 IP 为 VIP2、PREROUTING 检查发现数据包的目标 IP 是本机，将数据包送至 INPUT 链3、IPVS 比对数据包请求的服务是否为集群服务，若是，修改数据包的目标 IP 地址为后端服务器 IP，然后将数据包发至 POSTROUTING 链。 此时报文的源 IP 为 CIP，目标 IP 为 RIP4、POSTROUTING 链通过选路，将数据包发送给 Real Server5、Real Server 比对发现目标为自己的 IP，开始构建响应报文发回给 Director Server。 此时报文的源 IP 为 RIP，目标 IP 为 CIP6、Director Server 在响应客户端前，此时会将源 IP 地址修改为自己的 VIP 地址，然后响应给客户端。 此时报文的源 IP 为 VIP，目标 IP 为 CIP NAT模式特点：
RS 应该使用私有地址，RS 的网关必须指向 DIPDIP 和 RIP 必须在同一个网段内请求和响应报文都需要经过 Director Server，高负载场景中，Director Server 易成为性能瓶颈支持端口映射RS 可以使用任意操作系统 2、为什么需要LVS FULLNAT模式 LVS NAT模式下，一般需要设置RS 的网关必须指向 DS：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f81325865b78103118ee2e538c968dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/243e098a4f77e1ac92ea4c23a97cea83/" rel="bookmark">
			opencv学习笔记——4.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三章 图像的基本操作 （原来前面三篇都是属于第一第二章的内容，那进度确实是有点慢了……）
本章重点在于numpy的学习中
访问和修改像素值 img获取的实际上是三维数组，包含行、列和三通道，通过直接修改img数组对应的索引可以用修改像素值
img = cv.imread('./picture/1_read.jpg') # 通过行列坐标访问像素值，对于BGR图像返回的是数组，灰色图像则返回灰度 px = img[100, 100] print(px) # 第三个参数为通道的编号，0表示b，1表示g，2表示r blue = img[100, 100, 0] print(blue) # 修改对应的像素值 img[100, 100] = [255, 255, 255] print(img[100, 100]) for i in range(512): for j in range(512): img[i, j] = [255, 255, 255] cv.namedWindow('image', 0) cv.resizeWindow('image', int(1920/2), int(1080/2)) cv.imshow('image', img) if cv.waitKey(0) &amp; 0xFF == 27: # 等待ESC退出 cv.destroyAllWindows() 由于numpy是高度包装的库，所以对于像素值的修改还是使用item()和itemset()比较好，需要注意的是itemset()第一个参数的要修改的标量，即每次只能修改一个通道的值，如果要将三通道的值都进行修改则只能多次调用itemset()
# 更好的访问和修改方法 print(img.item(10, 10, 2)) for i in range(512): for j in range(512): img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/243e098a4f77e1ac92ea4c23a97cea83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ffd9b949a2aa408d08990a1b7f1e2d6/" rel="bookmark">
			mmdetection1.4训练fasterrcnn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mmdetection1.4训练fasterrcnn 指定参数文件urllib.error.URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1131)&gt;No such file or directory: 'data/coco/annotations/instances_train2017.json'完成训练 指定参数文件 ../configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py urllib.error.URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1131)&gt; 权重官网
No such file or directory: ‘data/coco/annotations/instances_train2017.json’ 数据集路径问题
打开数据集路径的配置文件
数据集路径
完成训练 之前在train中没有指定保存的路径，默认在当前文件夹中保存
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4adc398929ab0e40f080d3be39773a0/" rel="bookmark">
			MD5加密比较参数是否一致的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		踩了很多次的坑，要保证所有的包括且不限于顺序等细节，需要一模一样不然结果还是不会相同的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ebe7d4cbb882506c0f69cc81020aac7/" rel="bookmark">
			Linux 下使用 vscode 单文件编译 C/C&#43;&#43; 程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将两个配置文件 launch.json 和 task.json 填入 .vscode 文件即可。
注意在 wsl2 下可以使用中文命名文件，这样可以快乐的刷算法题了（使用单文件编译）。
launch.json 文件：
{ "version": "0.2.0", "configurations": [ { "name": "C/C++", // 配置名称 "type": "cppdbg", "request": "launch", "program": "${fileDirname}/${fileBasenameNoExtension}.out", "args": [], "stopAtEntry": false,// 设为true时程序将暂停在程序入口处，相当于在main上打断点 "cwd": "${workspaceFolder}", "environment": [], "externalConsole": false, "MIMode": "gdb", "miDebuggerPath": "/usr/bin/gdb", // 指定调试器所在路径，如果你的minGW装在别的地方，则要改成你自己的路径 "preLaunchTask": "compile",// 调试开始前执行的任务，我们在调试前要编译构建。与tasks.json的label相对应，名字要一样 "setupCommands": [ { "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true } ] } ] } task.json 文件：
{ "version": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ebe7d4cbb882506c0f69cc81020aac7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c3dd6fc931121c52500b0d5e6ca9a3/" rel="bookmark">
			分布式幂等问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 背景
二 什么是幂等
三 解决方案三部曲
第一部曲：识别相同请求
第二部曲：列出并减少副作用的分析维度
第三部曲：识别细粒度副作用，针对性设计解决方案
四 总结
一 背景 分布式系统由众多微服务组成，微服务之间必然存在大量的网络调用。下图是一个服务间调用异常的例子，用户提交订单之后，请求到A服务，A服务落单之后，开始调用B服务，但是在A调用B的过程中，存在很多不确定性，例如B服务执行超时了，RPC直接返回A请求超时了，然后A返回给用户一些错误提示，但实际情况是B有可能执行是成功的，只是执行时间过长而已。
用户看到错误提示之后，往往会选择在界面上重复点击，导致重复调用，如果B是个支付服务的话，用户重复点击可能导致同一个订单被扣多次钱。不仅仅是用户可能触发重复调用，定时任务、消息投递和机器重新启动都可能会出现重复执行的情况。在分布式系统里，服务调用出现各种异常的情况是很常见的，这些异常情况往往会使得系统间的状态不一致，所以需要容错补偿设计，最常见的方法就是调用方实现合理的重试策略，被调用方实现应对重试的幂等策略。
二 什么是幂等 对于幂等，有一个很常见的描述是：对于相同的请求应该返回相同的结果，所以查询类接口是天然的幂等性接口。举个例子：如果有一个查询接口是查询订单的状态，状态是会随着时间发生变化的，那么在两次不同时间的查询请求中，可能返回不一样的订单状态，这个查询接口还是幂等接口吗？
幂等的定义直接决定了我们如何去设计幂等方案，如果幂等的含义是相同请求返回相同结果，那实际上只需要缓存第一次的返回结果，即可在后续重复请求时实现幂等了。但问题真的有这么简单吗？
笔者更赞同这种定义：幂等指的是相同请求（identical request）执行一次或者多次所带来的副作用（side-effects）是一样的。
这个定义有一定的抽象，概括性比较强，在设计幂等方案时，其实就是将抽象部分具化。例如：什么是相同的请求？哪些情况会有副作用？该如何避免副作用？且看三部曲。
三 解决方案三部曲 不少关于幂等的文章都称自己的方案是通用解决方案，但笔者却认为，不同的业务场景下，相同请求和副作用都是有差异性的，不同的副作用需要不同的方案来解决，不存在完全通用的解决方案。而三部曲旨在提炼出一种思考模式，并举例说明，在该思考模式下，更容易设计出符合业务场景的幂等解决方案。
第一部曲：识别相同请求 幂等是为了解决重复执行同一请求的问题，那如何识别一个请求有没有和之前的请求重复呢？有的方案是通过请求中的某个流水号字段来识别的，同一个流水号表示同一个请求。也有的方案是通过请求中某几个字段甚至全部字段进行比较，从而来识别是否为同一个请求。所以在方案设计时，明确定义具体业务场景下什么是相同请求，这是第一部曲。
方案举例：token机制识别前端重复请求
在一条调用链路的后端系统中，一般都可以通过上游系统传递的reqNo+source来识别是否是为重复的请求。如下图，B系统是依赖于A系统传递的reqNo+source来识别相同请求的，但是A系统是直接和前端页面交互的系统，如何识别用户发起的请求是相同的呢？比如用户在支付界面上点击了多次，A系统怎么识别这是一次重复操作呢？
前端可以在第一次点击完成时，将按钮设置为disable，这样用户无法在界面上重复点击第二次，但这只是提升体验的前端解决方案，不是真正安全的解决方案。
常见的服务端解决方案是采用token机制来实现防重复提交。如下图，
（1）当用户进入到表单页面的时候，前端会从服务端申请到一个token，并保存在前端。
（2）当用户第一次点击提交的时候，会将该token和表单数据一并提交到服务端，服务端判断该token是否存在，如果存在则执行业务逻辑。
（3）当用户第二次点击提交的时候，会将该token和表单数据一并提交到服务端，服务端判断该token是否存在，如果不存在则返回错误，前端显示提交失败。
这个方案结合前后端，从前端视角，这是用于防止重复请求，从服务端视角，这个用于识别前端相同请求。服务端往往基于类似于redis之类的分布式缓存来实现，保证生成token的唯一性和操作token时的原子性即可。核心逻辑如下。
// SETNX keyName value: 如果key存在,则返回0，如果不存在，则返回1 // step1. 申请token String token = generateUniqueToken(); // step2. 校验token是否存在 if(redis.setNx(token, 1) == 1){ // do business } else { // 幂等逻辑 } 第二部曲：列出并减少副作用的分析维度 相同的请求重复执行业务逻辑，如果处理不当，会给系统带来副作用。那什么是副作用？从技术的角度理解就是返回结果后还导致某些“系统状态”发生变化，无副作用的函数称之为纯函数，体现到业务的角度就是业务无法接受的非预期结果。最常见的有重复入库、数据被错误变更等，大多数幂等方案就是围绕解决这类问题来设计的。而系统往往可能在多个维度都存在副作用，例如：
（1）调用下游维度：重复调用下游会怎样？如果下游没有幂等，重复调用会带来什么副作用？
（2）返回上游维度：例如第一次返回上游异常，第二次返回上游被幂等了？会给上游带来什么副作用？
（3）并发执行维度：并发重复执行会怎样？会有什么副作用？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31c3dd6fc931121c52500b0d5e6ca9a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a8a34d1ad1b9ead12ebf2dcb96413da/" rel="bookmark">
			vue项目引入外部图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在查找怎么引入外部图标的时候，发现对于一些细节他们的文章描述的并不清楚。本次以VantUi项目为例教大家如何引入外部图标。只要是vue项目，不同的框架引入外部图标是一样的
vantui原生内部引用 在正式引入之前，我觉得还是有必要说一下它原本的用法
它内置有一定数量的图标，但是当我们有需要用到其他没有的图标的时候，就需要引入了
这里发现它的图标是不够的，数量相对较少，以及不一定满足我们的需求
基础用法
通过 name 属性来指定需要使用的图标，Vant 内置了一套图标库，可以直接传入对应的名称来使用。
&lt;van-icon name="chat-o" /&gt; 使用图片 URL
你也可以直接在 name 属性中传入一个图片 URL 来作为图标。
以上就是它原生的使用方法，都是操作name属性进行获取图标
引入iconfont 本次使用的是阿里巴巴的iconfont，它的链接网址为:
阿里巴巴iconfont图标库
ps：需要登录才能下载图标
引入外部图标步骤 选择图标 进入阿里巴巴图标库之后，界面为这样
然后选择你需要的图标,如我图片，在需要的图标上面停留添加入库
添加图库之后，在你登录的状态下，右上角是会有一个购物车图标
点击它,然后就会弹出你选择好的图标
接着点击下载代码，我们就有了我们的图标压缩包
引入项目 首先我们需要进行一个解压
解压出来，文件名是一堆不容易理解和看懂的文件名称，为了方便引入和查找,我们先对它重新命名，命名按照自己的喜好即可
如我取名叫lockIcon
然后，将该解压后的文件夹，放到我们项目的src/assets文件夹底下
最终结构是这样
然后我们需要在main.js引入这个iconfont.css
即解压后文件夹的其中一个文件
在main.js如我图片显示路径应该是
src/assets/lockIcon/iconfont.css
于是，最终写入到mai.js的代码为:
// 引入iconfont图标 import "../src/assets/lockIcon/iconfont.css" 使用外部引入图标 在最终使用的时候，如果是第一次使用的人，一定会感到费解，到底该如何使用?名称应该是怎么样的?
我们进入到iconfont.css文件看代码
@font-face { font-family: "iconfont"; /* Project id */ src: url('iconfont.ttf?t=1662339871569') format('truetype'); } .iconfont { font-family: "iconfont" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a8a34d1ad1b9ead12ebf2dcb96413da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f2687db6d95afed66e7a573c3943c15/" rel="bookmark">
			Yolov5/Yolov7优化：卷积变体---分布移位卷积（DSConv）,提高卷积层的内存效率和速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. DSConv介绍
2.DSConv引入Yolov5
2.1修改common.py中：
2.2 加入yolo.py中：
2.3 yolov5s_DSConv2D_C3.yaml
🏆 🏆🏆🏆🏆🏆🏆Yolov5/Yolov7成长师🏆🏆🏆🏆🏆🏆🏆 🍉🍉进阶专栏Yolov5/Yolov7魔术师：http://t.csdn.cn/D4NqB 🍉🍉
✨✨✨魔改网络、复现前沿论文，组合优化创新
🚀🚀🚀小目标、遮挡物、难样本性能提升
🌰 🌰 🌰在不同数据集验证能够涨点，对小目标涨点明显 1. DSConv介绍 论文： https://arxiv.org/pdf/1901.01928v1.pdf
摘要：提出了一种卷积的变体，称为DSConv（分布偏移卷积），其可以容易地替换进标准神经网络体系结构并且实现较低的存储器使用和较高的计算速度。 DSConv将传统的卷积内核分解为两个组件：可变量化内核（VQK）和分布偏移。 通过在VQK中仅存储整数值来实现较低的存储器使用和较高的速度，同时通过应用基于内核和基于通道的分布偏移来保持与原始卷积相同的输出。 我们在ResNet50和34以及AlexNet和MobileNet上对ImageNet数据集测试了DSConv。 我们通过将浮点运算替换为整数运算，在卷积内核中实现了高达14x的内存使用量减少，并将运算速度提高了10倍。 此外，与其他量化方法不同，我们的工作允许对新任务和数据集进行一定程度的再训练。 DSConv 的总体目标是通过使用量化和分布偏移来模拟卷积层的行为。
DSConv 的设置如上图所示。为了方便和表示，让原始卷积张量的大小为 (cho, chi, k, k)，其中 cho 是下一层的通道数，chi 是当前层中的通道，k是内核的宽度和高度。
DSConv是一种深度可分离卷积（Depthwise Separable Convolution）的变体，它在计算机视觉领域被广泛使用。深度可分离卷积是一种轻量级卷积，它将标准卷积拆分为两个步骤：深度卷积和逐点卷积。深度卷积只在单个通道上进行卷积，并在每个通道上应用一个独立的卷积核。逐点卷积在所有通道上应用一个卷积核，以组合深度卷积的结果。DSConv相比于深度可分离卷积的优势在于它使用了一个可学习的卷积核来进一步提高模型的表现。
结果对比：
实验目标：在 Resnet34 和 Resnet50 中应用的 DSConv 与其他网络
实验结果：效果有明显提高
2.DSConv引入Yolov5 2.1修改common.py中： ###################### DSConv #### start by AI&amp;CV ############################### import torch.nn.functional as F from torch.nn.modules.conv import _ConvNd from torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f2687db6d95afed66e7a573c3943c15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d6a5b79947d003476681e99a8ba9546/" rel="bookmark">
			opencv学习笔记——3.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		轨迹栏作为调色板 本节学习创建简单的应用程序，使用TrackbarPos创建轨迹栏，用于更改BGR参数，并更新窗口的颜色。
首先创建三通道图像；调用cv.createTrackbar()创建轨迹栏，第一次参数为轨迹栏名称，第二个参数为附加到的窗口名称，第三个参数是默认值，第四个参数是最大值，第五个是执行的回调函数每次跟踪栏值更改；再创建一个二值轨迹栏作为开关
def nothing(x): pass img = np.zeros((300, 512, 3), np.uint8) # 创建一个300*512的三通道图像 cv.namedWindow('image') # 创建三个轨迹栏 cv.createTrackbar('R', 'image', 0, 255, nothing) cv.createTrackbar('G', 'image', 0, 255, nothing) cv.createTrackbar('B', 'image', 0, 255, nothing) # 创建开关，当为ON时才能使用轨迹栏的调色功能 switch = '0 : OFF\n1 : ON' cv.createTrackbar(switch, 'image', 0, 1, nothing) while True: cv.imshow('image', img) k = cv.waitKey(1) &amp; 0xFF if k == 27: break # 获取四个轨迹栏的值 r = cv.getTrackbarPos('R', 'image') g = cv.getTrackbarPos('G', 'image') b = cv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d6a5b79947d003476681e99a8ba9546/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d3cce930b8144c7323d6b2b2a907496/" rel="bookmark">
			opencv学习笔记——2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绘图功能 首先需要创建一个背景来承接绘制的图像
img = np.zeros((512, 512, 3), np.uint8) # 创建黑色的图像 画线
此处img表示绘制的图像，(0, 0)和(511, 511)是线段的两点坐标，(255, 0, 0)为BGR颜色表示法，5表示厚度 cv.line(img, (0, 0), (511, 511), (255, 0, 0), 5) # 绘制一条厚度为5的蓝色对角线 画矩形
(384, 0)和(510, 128)是矩形两对角坐标，BGR，厚度cv.rectangle(img, (384, 0), (510, 128), (0, 255, 0), 3) # 画矩形 画圆圈
(447, 63)为圆中心坐标, 63为半径，(0, 0, 255)BGR，-1表示填充而非线的厚度cv.circle(img, (447, 63), 63, (0, 0, 255), -1) # 画圆圈 画椭圆
(256, 256)为中心坐标, (100, 50)长轴和短轴长度, 0为图像逆时针旋转的角度angle, 0和180表示图像从主轴顺时针方向的开始角度和结束角度，这里的从0到180即表示椭圆的下半圆, 255也可以和前面一样用BGR表示, -1表示填充cv.ellipse(img, (256, 256), (100, 50), 0, 0, 180, 255, -1) # 画椭圆 画多边形# 画多边形，需要包含了顶点坐标的顶点集数据 pts = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d3cce930b8144c7323d6b2b2a907496/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac5ba3a161e1e87166f90f2b87c2e26c/" rel="bookmark">
			如何利用python处理excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用Python处理Excel数据可以帮助我们更高效地进行数据分析和处理。以下是一些常用的Python库和工具：
Pandas:Pandas是一个用于数据处理和分析的Python库，它提供了丰富的数据结构和函数，可以方便地读取、清洗、转换和分析Excel数据。
OpenPyXL:OpenPyXL是一个用于读取和写入Excel文件的Python库，它支持多种Excel格式，并且可以进行数据的筛选、排序、合并等操作。
ExcelWriter:ExcelWriter是一个用于将数据写入Excel文件的Python库，它可以将数据写入多个工作表或单个工作表的不同位置，并且支持多种Excel格式。
XlsxWriter:XlsxWriter是一个用于生成Excel文件的Python库，它可以将数据写入Excel文件中，并且支持多种Excel格式和样式设置。
通过利用这些Python库和工具，我们可以快速地读取、清洗、转换和分析Excel数据，从而更好地撰写高质量的博客文章。下面我将以如何利用Python处理Excel为例，来探讨如何撰写高质量的文章。
首先，我们需要选择一个有足够深度和广度的主题。例如，我们可以选择“如何利用Python处理Excel数据来进行数据分析”作为主题。这个主题既具有一定的深度，又涵盖了广泛的应用场景，能够吸引读者的兴趣。
接下来，我们需要对主题进行深入的研究和分析。在这个过程中，我们可以使用Pandas库来读取、清洗、转换和分析Excel数据。Pandas提供了丰富的数据结构和函数，可以方便地对数据进行操作。例如，我们可以使用read_excel()函数来读取Excel文件中的数据，使用dropna()函数来删除空值行或列，使用pivot_table()函数来创建透视表等等。通过这些操作，我们可以得到一份干净、整洁的数据集，为后续的分析做好准备。
在进行数据分析之前，我们需要先确定分析的目标和问题。例如，我们可能需要回答以下问题：哪些变量之间存在相关性？哪些变量对某个指标产生了显著影响？哪些变量对某个事件的发生率有影响？通过对这些问题的回答，我们可以确定分析的目标和方向。然后，我们可以使用Pandas提供的统计函数来计算各种指标和统计量，例如均值、标准差、相关系数等等。通过这些指标的计算分析，我们可以更好地理解数据之间的关系和规律，从而得出有价值的结论。
除了Pandas之外，OpenPyXL、ExcelWriter和XlsxWriter等库也可以帮助我们处理Excel数据。例如，使用ExcelWriter可以将数据写入Excel文件中，并且支持多种Excel格式和样式设置；使用XlsxWriter可以生成高质量的Excel文件，并且支持多种Excel格式和样式设置。这些库的使用可以让我们更加方便地进行数据分析和处理。
总之，利用Python处理Excel数据可以帮助我们更高效地进行数据分析和处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd214e4e0e234179f2216e2453ad1186/" rel="bookmark">
			在Docker中使用MindSpore GPU版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 在Docker中使用MindSpore GPU版本获取安装命令安装安装nvidia-container-toolkit获取MindSpore镜像测试运行MindSpore镜像运行代码 使用VSCode开发 在Docker中使用MindSpore GPU版本 参考官方文档：安装指南
获取安装命令 如图所示
命令为
docker pull swr.cn-south-1.myhuaweicloud.com/mindspore/mindspore-gpu-cuda11.6:2.0.0 安装 这里选择已经预安装MindSpore x.y.z GPU版本的生产环境。(CUDA10.1或CUDA11.1或CUDA11.6后端)
安装nvidia-container-toolkit 依次执行：
distribution=$(. /etc/os-release;echo $ID$VERSION_ID) \ &amp;&amp; curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \ &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/$distribution/libnvidia-container.list | \ sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \ sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list sudo apt-get update sudo apt-get install -y nvidia-container-toolkit sudo nvidia-ctk runtime configure --runtime=docker sudo systemctl restart docker 获取MindSpore镜像 docker pull swr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd214e4e0e234179f2216e2453ad1186/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36decb5d1165bc0292dfb01336c7b32d/" rel="bookmark">
			Vue组件解析：自定义弹窗组件ByDialog详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Vue.js前端开发中，弹窗组件是常见的交互元素之一。为了提高开发效率并保持代码的可维护性，我们可以创建自定义弹窗组件。本文将详细解析Vue.js结合ElementUi自定义弹窗组件ByDialog的实现原理和使用示例，并提供相关代码和注释。
ByDialog组件代码 下面是ByDialog组件的完整代码：
&lt;template&gt; &lt;!-- el组件的大部分属性在by-dialog标签上都可以使用，如果某属性或事件不生效可以在by-dialog组件中 去扩展 （例如通过props） --&gt; &lt;el-dialog :title="title" :visible="visible" v-bind="$attrs" v-on="$listeners" @close="$emit('cancel')" :width="width" @touchmove.prevent class="by-dialog" &gt; &lt;div class="by-dialog-content"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;slot name="footer" slot="footer"&gt; &lt;el-button @click="$emit('ok')" type="primary"&gt;{{ okText }}&lt;/el-button&gt; &lt;el-button @click="$emit('cancel')"&gt;{{ cancelText }}&lt;/el-button&gt; &lt;/slot&gt; &lt;/el-dialog&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'ByDialog', props: { // 弹框的显示隐藏 value: { type: Boolean, default: false, }, // 确定按钮文本 okText: { type: String, default: '确定', }, // 取消按钮文本 cancelText: { type: String, default: '取消', }, // 弹框标题 title: { type: String, default: '', }, // 弹框的宽度 width: { type: String, default: '600px', }, }, computed: { visible: { get() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36decb5d1165bc0292dfb01336c7b32d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/144dddd19ba843d13cd2efc76e2bd1e5/" rel="bookmark">
			uni-app优乐购商城小程序搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uni-app优乐购商城小程序搭建
一、新建项目
二、搭建目录结构
三、搭建项目页面 四、搭建tabBar
五、首页
1.获取轮播图的数据
2.渲染轮播图 六 、分类页面
七、商品列表页面
1.页面上拉加载
2.页面下拉刷新
八、商品详情页面detail页面
1.预览图片
2.加入购物车 九、购物车页面cart
1.获取地址
2.修改商品数量 十、我的页面
1.点击订单跳转到订单页面
2.退出登录 十一、学习心得
十二、总结
一、新建项目 购物商城接口文档：https://www.showdoc.com.cn/128719739414963/2516997897914014
帮助文档如下：
uni-app官网：https://dcloud.io/
阿里巴巴字体图标官网：https://www.iconfont.cn/
菜鸟教程:https://www.runoob.com/
微信小程序官网：https://developers.weixin.qq.com/miniprogram/dev/framework/
(1）uni-app框架：本项目用的是uni-app框架进行开发的，因为uni-app框架是使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到 iOS、Android、H5、以及各种小程序、快应用等多个平台。
(2）开发工具：用HBuilderX 来开发，因为uni-app项目都是用HbuildX来开发HBuilderX官网
(3）sass编译：为了方便编写scss/sass样式，建议安装 scss/sass 编译插件下载地址；进入之后点击——使用 HBuilderX 导入插件，登入HBuilderX，进行下载
(4）新建项目：
① 文件 ==》 新建 ==》 项目
② 填写项目的一些基本的信息
二、搭建目录结构 目录结构划分如下：
目录名作用common存放公共样式components存放自定义组件page存放主包页面（tab页面）subpkg1 子包1，存放子包页面（商品列表页面、商品列表页面、搜索页面）
subpkg2
子包2，存放子包页面（其他页面）
utils
自己的帮助库
三、搭建项目页面 页面名称
名称
首页
index
分类页面
category
商品列表页面
goods-list
商品列表页面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/144dddd19ba843d13cd2efc76e2bd1e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08e9349809529041fd7d35a6b210e4f4/" rel="bookmark">
			laravel框架后台内容管理系统项目搭建心得分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		laravel框架后台内容管理系统项目搭建心得分享
前期准备 一、后台用户登录
1、创建用户表
2、显示登录页面
3、Ajax交互
4、验证用户登录
5、用户退出
二、后台首页 1、后台页面布局
2、显示后台首页
3、判断登录状态
三、栏目管理 1、创建栏目表
2、添加栏目
3、显示栏目列表
4、编辑栏目
5、删除栏目
四、内容管理
1、创建内容表
2、添加内容
3、上传图片
4、显示内容列表
5、编辑内容
6、删除内容
五、广告位管理
1、创建广告位表
2、添加广告位
3、显示、编辑、删除广告位列表
六、广告内容管理
1、创建广告内容表
2、添加、显示、编辑、删除广告
七、 总结
1、学习laravel的难点
2、学习laravel收获到了什么
3、内容管理系统项目心得总结
Larvel框架可以开发各种不同类型的项目，内容管理系统( Contet Mangement Sstem, CMS )是一种比较典型的项目，常见的网站类型(如门户、新闻、博客、文章等)都可以利用CMS进行:搭建。CMS用于对信息进行分类管理，将信息有序、及时地呈现在用户面前，满足人们发布信息、获取信息的需求，保证信息的共享更加快捷和方便。本章将讲解如何使用Laravel框架开发内容管理系统。
（1）本项目分为前台和后台。前台的功能包括用户登录与注册、内容列表、内容详细页、广告展示、评论和热门内容等。
（2）后台在未登录的状态下会自动跳转至登录页面。输入用户名“admin”、密码“123456”和验证码后，单击“登录”按钮，即可进行登录。
（3）登录后，页面顶部右侧显示了当前登录的用户名“admin”和“退出”按钮，单击“退出”按钮即可退出后台系统。
（4）后台页面的左侧有一个菜单栏，用户可以在菜单栏中选择一个菜单项进行操作。
项目中需要使用到的技术点包括文件上传、分页和会话技术。整个项目开发基于实现功能的步骤来完成，先实现后台开发，提供数据支持，再完成前台的数据展示。
前期准备 （1）在C:\web\apache2.4\htdocs\cms目录下打开终端，执行如下命令，安装Laravel。
composer create-project --prefer-dist laravel/laravel ./ 5.8.*
或下载地址：https://getcomposer.org/download/
（2）Laravel安装完成后，在Apache的conf\extra\httpd-vhosts.conf配置文件中创建一个虚拟主机。然后，编辑Windows系统的hosts文件，添加一条解析记录“lhm.com”。
（3）在本书的配套源代码包中，将内容管理系统的前台和后台的静态资源复制到项目对应的目录下。
（4）登录MySQL服务器，创建数据库cms，将cms作为内容管理系统的数据库。
（5）打开项目，在config\database.php数据库配置文件中，将数据库名称修改为lhm。
（6）在.env文件中配置正确的数据库配置信息。完成上述步骤后，即可在项目中访问数据库。
目录作用App包含了应用的核心代码，此外你为应用编写的代码绝大多数也会放到这里；Bootstrap用于框架的启动和自动载入配置；Config包含了应用所有的配置文件Database包含了数据迁移及填充文件PublicPublicResourcesresources目录包含了视图文件及原生资源文件Routes包含了应用的所有路由定义Storage存放编译后的模板、session文件、缓存文件、日志文件等；Tests自动化测试文件Vendor存放通过Composer加载的依赖 一、后台用户登录 1、创建用户表 （1）在命令行中执行如下命令创建迁移文件，具体命令如下：
php artisan make:migration create_admin_user_table （2）执行完上述命令后，会在database\migrations目录下生成文件名称为时间前缀_create_admin_user_table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08e9349809529041fd7d35a6b210e4f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5947c2f42bc9b70108b11dd6e2be9e2/" rel="bookmark">
			Linux 下 telnet 的替代方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nc -nzv IP port
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cf1e85ccbfc72153c8992d3e0dd10ba/" rel="bookmark">
			二进制搭建Kubernetes集群（三）——部署多master
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将完成多master集群的部署，即部署master02，以及nginx负载均衡、keepalived高可用
多master集群架构图： 架构说明：
node节点的kubelet只能对接一个master节点的apiserver，不可能同时对接多个master节点的apiserver。简而言之，node节只能有一个master来领导。
kubelet和kube-proxy是通过kubelet.kubeconfig和kube-proxy.kubeconfig文件中的server参数进行对接 master节点的。
所以在多master节点的环境下，需要有nginx负载均衡器来进行调度，而且需要进行keepalived高可用的构建(主从两个节点) ，防止主节点宕机导致整个k8s集群的不可用。
部署两台或者三台master都可以：
三台：多层保障、负载均衡（减轻每台master的压力）、选举机制选出leader。两台：也可实现负载均衡，负载压力没那么大的情况下可选两台，同时考虑到成本。 六、部署master02 节点 master02：192.168.126.21
##------------ 1、 master01节点，拷贝文件到master02 ------------------------------- #从 master01 节点上拷贝证书文件、各master组件的配置文件和服务管理文件到 master02 节点 scp -r /opt/etcd/ root@192.168.126.21:/opt/ scp -r /opt/kubernetes/ root@192.168.126.21:/opt scp /usr/lib/systemd/system/kube-* root@192.168.126.21:/usr/lib/systemd/system// [root@master01 opt]# cd [root@master01 ~]# scp -r .kube/ 192.168.126.21:/root ​ ##----------- 2、 master02节点，修改配置文件并启动相关服务------------------------- #修改配置文件kube-apiserver中的IP vim /opt/kubernetes/cfg/kube-apiserver KUBE_APISERVER_OPTS="--logtostderr=true \ #输出日志，false表示标准错误不输出到屏幕，而是输出到日志中。true表示标准错误会输出到屏幕。 --v=4 \ #日志级别 --etcd-servers=https://192.168.126.27:2379,https://192.168.126.28:2379,https://192.168.126.29:2379 \ #etcd节点的IP通信地址 --bind-address=192.168.126.21 \ #修改，当前绑定的内网IP监听的地址 --secure-port=6443 \ #基于HPPTS开放端口 --advertise-address=192.168.126.21 \ #修改，内网通告地址，让其他node节点地址通信 ...... ​ #在 master02 节点上启动各服务并设置开机自启 systemctl enable --now kube-apiserver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cf1e85ccbfc72153c8992d3e0dd10ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be6f63c8d93b2d371087dfc44871ac9c/" rel="bookmark">
			如何在宝塔（bt）下搭建 wordpress 网站 &#43; 免费 waf 防火墙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在宝塔（bt）下搭建 wordpress 网站 + 免费 waf 防火墙 宝塔运维工具1，配合 wordpress 可以快速创建网站。当我们快速完成网站搭建并且上线后，惊讶的发现，网络上总隐藏着坏人，时时刻刻想害我的网站。此时就需要用到网络应用防火墙 waf，因为宝塔自带 waf 是收费的，作为小网站，用起来并不划算。所以得寻找可用的免费 waf 2，对比之后，最后选择了雷池 waf 社区版 3，原因很简单，社区版对应的就是商业版，背靠大树好乘凉。
下面是宝塔 bt + 免费 waf 的搭建过程。
环境准备 使用腾讯云轻应用服务器4创建服务实例，操作系统选择 “WordPress”。
设置腾讯云防火墙开放端口，添加 3 个端口
端口服务用途8888宝塔面板进入宝塔的管理界面，管理所有服务，必开9443雷池社区面板管理雷池社区防火墙的后台，必开8001业务服务因为宝塔占用了 80 端口，waf 需要占用其他端口代理业务服务，非必开 注意：8001 端口是为了测试用，正式服务上线后可以使用 https 协议的 443 端口，然后就可以关掉这个测试端口了，并且 8001 也可以更换为其他端口，这里仅测试用。
安装成功后，在 “应用管理” 面板可以看到应用信息：
根据 宝塔 Linux 应用的提示，ssh 链接到服务器，获取登录宝塔的登录账号密码：
然后登录宝塔管理后端，环境配置成功。
在宝塔中添加社区版 waf 因为需要用到宝塔的云服务功能，这里推荐登录宝塔账号。
雷池 waf 使用 docker 运行，并且官网提供了一键安装脚本，但是想要在宝塔中管理，还需要进行一些配置。
宝塔安装 docker：
安装完成：
社区版 waf 是通过 docker compose 运行的，在宝塔中添加 compose 模板：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be6f63c8d93b2d371087dfc44871ac9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4033e263728cddfa304b69289318cdf/" rel="bookmark">
			Linux虚拟机安装步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux环境下虚拟机的安装 VMware Workstations的安装暂且不谈
虚机里新虚拟机的创建步骤：
双击打开VMware Workstations虚机
点击创建新的虚拟机
类型配置选择典型（推荐）（T）并点击下一步【可以选择推荐也可以选择自定义，自己平时练习使用可以选择典型推荐】
下一步
客户机操作系统选择Linux（L），版本选择CentOS 7 64位，下一步
修改虚拟机名称和路径（也可以不修改但是推荐修改）并且下一步
修改最大磁盘大小（50G足够用了，也可以修改更大些），下一步
点击完成
编辑虚拟机设置
虚拟机内存调整成2G
处理器调整成2，2（调整更大也可以）
CD/DVD(IDE) 使用ISO映像文件（映像文件可以去网上搜索下载），点击确定
开启此虚拟机
等待秒数结束或者选择第二个回车进入
等待就好
选择中文，继续
静待几秒后，选择点击安装位置
直接点击完成
如果需要可视化桌面，点击软件选择，选择GNOME桌面，点击完成（如果不需要可视化桌面可以不选软件选择项目）
点击网络和主机名，配置网络，点击打开按钮，并点击应用按钮，最后点击完成
点击开始安装
root密码设置
设置好密码后根据下方提示双击完成按钮
用户创建可以创建也可以忽略（和root密码设置方法相似）
待安装完成后点击重启，重启后等待进入就可以，在重启之间不需要任何操作
点击第一个进行许可证设置
勾选同意许可协议，并点击右上角完成按钮
点击完成配置
点击前进
点击前进
点击前进
拒绝访问
点击前进
点击跳过
看着设置后点击前进
设置密码后点击前进
点击开始使用
检查网络能否正常使用1处是网络图标2是显示网络连接情况
使用浏览器搜索检测网络能否连通，打开火狐浏览器（显示了百度网页网络正常）
虚拟机安装成功！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fd84ebcde5bb13cf9962c76e3c584bf/" rel="bookmark">
			自定义地区参数处理切面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		省级账号：
如果没有传参或者传参是省级，那就地区参数置NULL。如果传参是市级就进行截断。如果是区(县)级不处理。 市级账号：
如果没有传参，将地区设置为当前用户所属区域。如果传参和所属地区不一致，若传参&gt;权限，地区设置为用户所属地区。如果传参和所属地区不一致，若传参&lt;权限，判断参数级别，如果是市级就进行截断，如果是区(县)级不处理。 县(区)账号：
参数直接改为用户区域 自定义接口注解 import java.lang.annotation.*; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @Documented public @interface AreaPermissions { Class type(); String fieldName(); boolean isSubstring() default true; } 切面方法 @Aspect @Component public class AreaPermissionsAspect { @Pointcut("@annotation(com.zs.backcontrolgov.annontation.AreaPermissions)||@within(com.zs.backcontrolgov.annontation.AreaPermissions)") public void areaPermissions(){} @Autowired private ISysAreaService iSysAreaService; @Around(value = "areaPermissions();") public Object around(ProceedingJoinPoint joinPoint) throws Throwable{ LoginUser loginUser = SecurityUtils.getLoginUser(); // 拦截的方法 Method method = ((MethodSignature) joinPoint.getSignature()).getMethod(); AreaPermissions annotation = method.getAnnotation(AreaPermissions.class); Class type = annotation.type(); String fieldName = annotation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fd84ebcde5bb13cf9962c76e3c584bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2fe334217cea7f2d975e7e4c65b892/" rel="bookmark">
			【昇润蓝牙】蓝牙4.0BLE模组(型号CC2541) 两个蓝牙之间互相通信的使用日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用昇润蓝牙4.0BLE模组(型号CC2541) 实现俩个蓝牙模组之间的通信 电脑手机等和蓝牙模组通信的资料很多，但蓝牙模块之间的通信资料比较少。本文以CC2541模组为例实现，俩个蓝牙模块之间的数据通信。
硬件准备 1.CC2541主从一体的模组一块2.CC2541从机的模组一块
注意：几乎相同外型的蓝牙模组，是区分主从机的。一般来说，俩个全是从机的蓝牙之间，不能实现相互通信。俩个主从一体的也可以。总之：一定要有一个模块可以作为主机 模块介绍图 实物图 做了一个简单的转接板，将vcc，gnd，tx，rx引出。滤波电容暂时接的是100pf。
软件准备 调试软件使用官方自带的软件。TTC透传模组参数设置V3.4.9.6 Lite
软件、参考文档打包下载 方式1：打包下载方式2：某云链接: 链接：链接：https://pan.baidu.com/s/1pKqI5TUd5XgkZv23eyMuwQ?pwd=1234
提取码：1234 。若失效了，评论或者私信。 实现步骤 准备部分：使用俩个usb转ttl分别接上主机、从机的这俩个蓝牙模组。（注意tx接rx，不要错）
1.检查并配置相同的波特率先点检测模块功能
检测到我接入的俩个蓝牙模块
（如果没有检测的，请检测接线，焊接，供电等问题）
根据检测到的信息，打开串口。
将波特率均设置为9600(可以打开俩个软件窗口)
点击设置串口波特率。AT+BAUD=0，此时可能没有回复。
关闭串口，换9600再打开，通信测试，正常，说明，成功改为9600波特率。
2.主机设置为主机模式 AT+SETUP=81C0002C
主机com4发送AT+SETUP=81C0002C，设置主机模式。（默认都是从机模式启动，需此指令切换）
（此指令只对主从一体的模块有效，单从机无效。）
回复AT+OK，说明设置成功。重启主机
com4设置为主机模式。AT+SET=0 com3设置为从机AT+SET=1
3.连接从机AT+SCA=START
扫描，下图发现设备1，AT+NUM=1
连接从机AT+CON#1
点击设备1，收到AT+CON=SUCCESS说明连接成功
结果测试 发送123，能够收到。说明，俩蓝牙模块之间通信成功。
指令统计：
指令正常回复AT+SOFT_RST=1软复位无AT+ADV=0AT+OK关闭广播AT+ADV=1AT+OK 打开广播AT+SET=1AT+OK 设置从机AT+SET=0AT+OK 设置主机AT+SCA=STARTAT+OK AT+NUM=1开始扫描AT+LIST_NUM=?1获取列表AT+CON#1AT+CON=OK连接成功AT+DISCONAT+OK关闭广播断开当前连接 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91782fadde8aa7f568ae4f54bb614b69/" rel="bookmark">
			基于java的学籍管理系统毕业设计(源代码&#43;数据库&#43;部署文档&#43;部署视频)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学籍管理系统是一种用于管理学生的学籍信息的系统。它可以记录学生的个人信息、课程成绩、学费缴纳记录等重要数据，并提供相应的查询和统计功能。
以下是一个基于Java的学籍管理系统的简要设计：
1. 数据库设计：
- 学生表（Student）：包含学生的学号、姓名、性别、出生日期、班级等信息。
- 课程表（Course）：包含课程编号、课程名称等信息。
- 成绩表（Score）：包含学生学号、课程编号、成绩等信息。
- 缴费表（Payment）：包含学生学号、缴费日期、缴费金额等信息。
2. 用户界面设计：
- 登录界面：提供用户登录功能，分为管理员和学生两种角色。
- 管理员界面：包含学生管理、课程管理、成绩管理、缴费管理等功能。
- 学生界面：包含查看个人信息、查询成绩、查询缴费记录等功能。
3. 功能设计：
- 学生管理功能：包含学生信息的增加、修改和删除功能。
- 课程管理功能：包含课程信息的增加、修改和删除功能。
- 成绩管理功能：包含录入学生成绩、查询学生成绩、统计课程成绩等功能。
- 缴费管理功能：包含录入学生缴费记录、查询学生缴费记录、统计学生缴费情况等功能。
4. 技术选型：
- 后端使用Java语言开发，使用Spring框架实现业务逻辑处理。
- 前端使用JavaFX或者Swing进行界面开发。
- 数据库使用MySQL存储学籍信息。
以上是一个基于Java的学籍管理系统的毕业设计简要设计，可以根据具体需求进行进一步的设计和开发。同时，还可以根据需要增加其他功能，如学生选课管理、考试安排管理等功能。
参考资料：
基于java的学籍管理系统毕业设计(源代码+数据库+部署文档+部署视频)
https://download.csdn.net/download/dwf1354046363/87813552
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6045d48fa75a81506435faa87c82baa/" rel="bookmark">
			Redis的设计与实现(6)-压缩列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		压缩列表 (ziplist) 是列表键和哈希键的底层实现之一.
当一个列表键只包含少量列表项, 并且每个列表项要么就是小整数值, 要么就是长度比较短的字符串, 那么 Redis 就会使用压缩列表来做列表键的底层实现.当一个哈希键只包含少量键值对, 并且每个键值对的键和值要么就是小整数值, 要么就是长度比较短的字符串, 那么 Redis 就会使用压缩列表来做哈希键的底层实现. 1. 压缩列表的构成 压缩列表是 Redis 为了节约内存而开发的, 由一系列特殊编码的连续内存块组成的顺序型 (sequential) 数据结构.
一个压缩列表可以包含任意多个节点 (entry) , 每个节点可以保存一个字节数组或者一个整数值.
压缩列表的整体布局:
| zlbytes | zltail | zllen | entry | entry | entry... | zlend |
字段名称类型占用空间备注zlbytesuint32_t4 字节记录整个压缩列表占用的内存字节数: 在对压缩列表进行内存重分配, 或者计算 zlend 的位置时使用.zltailuint32_t4 字节记录压缩列表表尾节点距离压缩列表的起始地址有多少字节: 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址.zllenuint16_t2 字节记录了压缩列表包含的节点数量: 当这个属性的值小于 UINT16_MAX (65535)时, 这个属性的值就是压缩列表包含节点的数量; 当这个值等于 UINT16_MAX 时, 节点的真实数量需要遍历整个压 缩列表才能计算得出.entryX列表节点不定压缩列表包含的各个节点，节点的长度由节点保存的内容决定.zlenduint8_t1 字节特殊值 0xFF (十进制 255 )，用于标记压缩列表的末端. 2 压缩列表节点的构成 每个压缩列表节点可以保存一个字节数组或者一个整数值, 其中, 字节数组可以是以下三种长度的其中一种:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6045d48fa75a81506435faa87c82baa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80a2a2d25c0130ff032dbfec2dfe9424/" rel="bookmark">
			黑客与逆向工程入门指南：你知道你的网络足够安全吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 网络组成1.1 常见网络硬件设备1.2 网络拓扑结构1.3 网络地址 2. 网络协议2.1 协议的概念和重要性2.2 OSI参考模型2.3 TCP/IP协议族2.4 HTTP协议2.5 DNS协议 3. 网络安全3.1 常见网络攻击3.2 常见网络安全技术 4. 结论4.1 网络组成和协议对于现代社会的重要性和必要性4.2 未来网络的发展方向和趋势 1. 网络组成 1.1 常见网络硬件设备 交换机、路由器、网卡、集线器等 以下是一个表格介绍常见网络硬件设备：
设备描述用途交换机交换机是数据包转发设备，可以在局域网内转发数据包，提高网络传输速度和质量。网络设备之间的通讯路由器路由器是连接不同网络的设备，可以通过拥有不同IP地址的网络将数据进行转发。网络设备之间的通讯网卡网卡是连接计算机和网络的设备，可以使计算机与其他设备进行数据通讯。计算机网络连接集线器集线器将多个网络设备连接在一起，通过将数据包复制到所有端口的方式实现数据传输。网络设备之间的通讯 1.2 网络拓扑结构 星型拓扑、总线型拓扑、环型拓扑等 以下是一个表格介绍网络拓扑结构：
拓扑结构描述使用场景星型拓扑星型拓扑结构将多个设备连接到一个中心设备，中心设备的作用是传递数据包，通常使用交换机作为中心设备。办公室网络，小型企业网络总线型拓扑总线型拓扑结构是线性结构，所有设备都连接到单一的传输媒介，例如同轴电缆、双绞线。适用于少量设备的局域网环型拓扑环型拓扑结构将设备连接成一个环状链路，通过特定的协议控制数据的传输，例如Token Ring协议。大型企业网络，因为支持多路径冗余和高速的数据传输。 1.3 网络地址 IP地址、MAC地址等 以下是一个表格介绍网络地址：
名称描述使用场景IP地址IP地址是Internet Protocol的缩写，是Internet中设备的唯一标识符，用于识别和寻址计算机及其他设备。在Internet或局域网中分配网络地址MAC地址MAC地址是Media Access Control的缩写，是网络适配器的唯一标识符，在局域网中用于标识和区分每个设备。将数据帧发送到正确的地址子网掩码子网掩码是用于划分网络地址和主机地址的二进制掩码，用于分割一个大的网络为多个更小的子网。在IPv4中用于划分网络子网网关地址网关是通过连接不同网络的设备，可以实现网络之间的数据传输，网关地址是局域网的出入口，用于连接到其他网络。将数据从局域网发送到外部网络 2. 网络协议 2.1 协议的概念和重要性 网络协议是指计算机网络中的一种规范或者标准，它定义了计算机和其他网络设备之间的通信方式，规定了传输数据的格式、传输速率、数据编码、数据传输时的错误处理等细节。
协议的重要性在于它确保不同设备能够彼此协作，通过遵循共同的规范和标准，使得设备之间的通信更加高效、稳定和可靠。没有协议，设备之间无法进行有效的通信。
协议被广泛应用于许多不同的领域，例如网络通信、数据传输、音频和视频传输、电子邮件等等。在互联网中，TCP/IP协议是最为常用的协议，它定义了各种应用程序如何在网络上进行通信，包括邮件、文件传输、HTTP等等。在局域网中，还有诸如Ethernet、Wi-Fi等协议，用于定义设备之间的通信方式。总之，协议的作用是将各种网络设备连接起来，实现无缝的通信和数据传输。
2.2 OSI参考模型 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 好的，以下是一个表格介绍OSI参考模型：
层级名称描述硬件或软件7应用层应用层决定了用户和网络应用程序之间的通信服务。软件6表示层表示层负责数据格式转换，确保不同厂商之间的数据交换。软件5会话层会话层负责建立和维护不同设备之间的会话连接。软件4传输层传输层负责数据传输，包括数据分段、错误校验、流量控制等。软件/硬件3网络层网络层负责路由和寻址，确保数据从源地址发送到目标地址。硬件2数据链路层数据链路层在物理层上建立了逻辑连接，负责数据的封装和解封，以及错误检测。硬件1物理层物理层负责数据的物理传输，将数据转换为比特并在物理媒介上传输。硬件 通过OSI参考模型，不同设备之间可以在发出和接收数据包的过程中遵循相同的规范和标准，从而实现互操作性和互相通信，无论不同设备和技术的实现方式如何。
2.3 TCP/IP协议族 IP协议、TCP协议、UDP协议等 以下是一个表格介绍IP协议、TCP协议、UDP协议：
协议描述使用场景IP协议IP协议是传输层之下的协议，用于在网络中寻址和传输数据包。它负责将传输层中的数据分离为数据包，并在网络中将它们传输到它们的目标地址。在Internet和局域网中广泛使用，用于在网络中传输数据包TCP协议TCP协议是一种面向连接的协议，建立在IP协议之上，它负责在设备之间建立可靠、有序、基于流的数据传输。TCP协议保证数据的可靠传输，并且确保数据在正确的顺序中到达。常用于文件传输、电子邮件、网站访问等需要保证数据完整性的应用程序UDP协议UDP协议是面向无连接的协议，与TCP协议不同之处在于它不会建立连接或维护会话状态，而是直接将数据包发送给目标设备。UDP协议具有较低的延迟和更快的数据传输速度，但数据丢失和重复传输的可能性较大。常用于实时视频、音频、多人游戏等需要快速传输的应用程序 这些协议在实现网络通信时有不同的特点和适用场景。在实际的网络中，它们经常一起使用来确保数据在互联网和局域网中的高效、正确地传输。
2.4 HTTP协议 定义、用途、工作过程等 HTTP 协议（HyperText Transfer Protocol）是一种用于传输超文本（HyperText）数据的协议。以下是 HTTP 协议的一些定义、用途和工作过程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80a2a2d25c0130ff032dbfec2dfe9424/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/769f599181c1c66398113c95344dd254/" rel="bookmark">
			使用Node.js开发服务器进行请求转发和CORS处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Web开发过程中，我们经常会遇到需要在前端应用中与不同的API或后端服务进行通信的情况。然而，由于浏览器的同源策略限制，跨域请求会受到CORS（跨域资源共享）策略的限制。为了解决这个问题，我们可以使用Node.js开发服务器来进行请求转发和CORS处理。
Node.js提供了强大的HTTP模块，以及一些有用的中间件库，其中包括http-proxy-middleware用于代理和转发HTTP请求。我们可以利用这些工具来创建一个中转服务器，将前端应用发送的请求转发到目标服务器，并在转发过程中处理CORS问题。
下面是使用Node.js开发服务器进行请求转发和CORS处理的示例代码：
1. 在你的项目根目录下，创建一个名为devServer.js（或其他任意名称）的文件。
2. 在devServer.js文件中，添加以下代码：
const express = require('express'); const { createProxyMiddleware } = require('http-proxy-middleware'); // 创建Express应用 const app = express(); // 自定义CORS处理逻辑 app.use((req, res, next) =&gt; { // 设置允许的来源 res.setHeader('Access-Control-Allow-Origin', 'http://192.168.11.56:8080'); // 设置允许的请求头 res.setHeader('Access-Control-Allow-Headers', 'Content-Type, client, devicesid, registersign'); // 设置允许的请求方法 res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS'); if (req.method === 'OPTIONS') { // 处理预检请求 res.sendStatus(200); } else { // 继续处理实际请求 next(); } }); // 创建代理中间件 const apiProxy = createProxyMiddleware('/api', { target: 'https://prese.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/769f599181c1c66398113c95344dd254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee7ffbfe77dd1def318bf3d1cd7c7b14/" rel="bookmark">
			常用注解含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常用注解含义 @Data ： 注在类上，提供类的get、set、equals、hashCode、toString等方法 @AllArgsConstructor ：注在类上，提供类的全参构造 @NoArgsConstructor ：注在类上，提供类的无参构造 @Setter ：注在属性上，提供 set 方法 @Getter ：注在属性上，提供 get 方法 @EqualsAndHashCode ：注在类上，提供对应的 equals 和 hashCode 方法 @Log4j/@Slf4j ：注在类上，提供对应的 Logger 对象，变量名为 log 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a636b5c8314b3722f86ea1bb54bca93/" rel="bookmark">
			VSCode 配置 Python&#43;OpenCV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装Anaconda3，不装在C盘。在Anaconda3安装OpenCV资源包，OpenCV扩展包。Anaconda虚拟环境设置。安装VSCode。在VSCode安装Python拓展。设置VSCode的Python解释器为Anaconda3的Python。解决执行策略受限问题。在VSCode设置Python代码对齐，代码检测等参数。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5254d04313c72ca8c24bd92951aaed8c/" rel="bookmark">
			Oracle 分页更新数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当对某数据量巨大的表（如上亿行）进行update更新时，如果直接update很可能会导致undo表空间被写满的情况：
ORA-30036: unable to extend segment by 8 in undo tablespace "UMDOTBSI'
这时就需要去分页更新， 如果只是一个表，可以参考以下语句
UPDATE 【待更新表名】 t1 SET 【列明】 = 【值】 WHERE EXISTS (SELECT * FROM (SELECT A.* ，ROWNUM RN FROM (SELECT * FROM 【待更新表名】) A WHERE ROWNUM &lt;= 280) t2 WHERE RN &gt;= 270 AND 【t1.主键列=t2.主键列】) 或者先查出主键列条件，
SELECT LISTAGG( 'T1.'||col.column_name||'='||'T2.'||col.column_name,' AND ') within GROUP (order by col.table_name) as WH FROM DBA_Constraints con, Dba_Cons_Columns col WHERE col.owner = con.owner AND col.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5254d04313c72ca8c24bd92951aaed8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a2b18329d5ba790f81936b5f2513cf/" rel="bookmark">
			【java】读取、创建和修改Excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.apache.poi.ss.usermodel.*是Apache POI库中的核心包，用于读取、创建和修改Excel文件。
目录
一、导入org.apache.poi.ss.usermodel.*包
二、使用步骤
1.引入库
2.读入数据
3.详解
一、导入org.apache.poi.ss.usermodel.*包 org.apache.poi.ss.usermodel.*是Apache POI库中的核心包，用于读取、创建和修改Excel文件。下面是该包中一些关键的使用方法：
Workbook：表示整个Excel工作簿，在一个工作簿中可以包含多个工作表（Sheet）。
Workbook workbook = WorkbookFactory.create(new File("path/to/your/excel/file.xls"))：根据文件路径创建一个Workbook对象。Sheet sheet = workbook.getSheetAt(0)：获取第一个工作表。Sheet sheet = workbook.getSheet("SheetName")：根据名称获取指定的工作表。 Sheet：代表Excel工作表，包含行（Row）和单元格（Cell）。
Row row = sheet.getRow(rowIndex)：获取指定索引的行。Cell cell = row.getCell(cellIndex)：获取指定索引的单元格。 Row：表示Excel中的一行数据。
int lastRowNum = sheet.getLastRowNum()：获取最后一行的索引（注意索引从0开始）。 Cell：代表单元格，存储在行中，并包含数据和样式信息。
String value = cell.getStringCellValue()：获取单元格的字符串值。double value = cell.getNumericCellValue()：获取单元格的数值。boolean value = cell.getBooleanCellValue()：获取单元格的布尔值。 DataFormat：用于格式化单元格数据。
DataFormat dataFormat = workbook.createDataFormat()：创建一个DataFormat对象。 CellStyle：表示单元格的样式，包括字体、背景颜色、数据格式等。
CellStyle style = workbook.createCellStyle()：创建一个新的CellStyle对象。cell.setCellStyle(style)：为单元格设置样式。 以上仅是org.apache.poi.ss.usermodel.*包中的一些关键使用方法示例。根据具体需求可以进一步探索POI库提供的更多功能和方法。
二、使用步骤 1.引入库 要在Android Studio中导入org.apache.poi.ss.usermodel.*库，你需要进行以下步骤：
打开你的Android Studio项目。
在项目的根目录下找到build.gradle文件，它位于模块目录的顶层（不是项目的根目录）。
在dependencies部分添加POI库的依赖项。在此处添加以下依赖：
implementation 'org.apache.poi:poi:4.1.2' implementation 'org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3a2b18329d5ba790f81936b5f2513cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b91d78719a206598d601e9ce30a2a1/" rel="bookmark">
			qt QPixmap适应QGraphicsView大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 QGraphicsView* ViewPath = new QGraphicsView(this); ViewPath-&gt;setGeometry(0,0,450,600); QGraphicsScene ScenePath; ViewPath-&gt;setScene(&amp;ScenePath); QImage img_path_disp=img_path_disp.scaled(ViewPath-&gt;width(), ViewPath-&gt;height(), Qt::IgnoreAspectRatio); QGraphicsPixmapItem *p=ScenePath.addPixmap(QPixmap::fromImage(img_path_disp)); ViewPath-&gt;fitInView((QGraphicsItem*)p, Qt::IgnoreAspectRatio); ViewPath-&gt;show(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/478b8415d99e264b137b708f12116316/" rel="bookmark">
			Elasticsearch模糊查询之Wildcard
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Elasticsearch 中，Wildcard 查询通常用于在文本中查找匹配通配符模式的词语。Wildcard 查询是一种基于通配符的查询，它使用单个字符（?）代表一个字符，使用星号（*）代表零个或多个字符。
Wildcard 查询可用于对单个词执行模糊匹配，也可以用于对短语进行模糊匹配。它可以在搜索中用于查找某些词汇的变体或拼写错误的单词。
下面是一个使用Wildcard 查询的示例：
GET /my_index/_search { "query": { "wildcard": { "title": "elasti*" } } } 上面的查询会在 my_index 索引中匹配所有标题以 elasti 开头的文档。这个查询将匹配到 Elasticsearch、Elastic、Elastica 等词汇。
Wildcard 查询虽然可以提供灵活的模糊匹配，但由于通配符查询会扫描所有的文档，因此其性能可能会受到影响。因此，建议在使用通配符查询时尽可能地缩小查询的范围，以提高查询的性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a311bfbd245be9178cc3788c9f631d4/" rel="bookmark">
			geemap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 conda create -n gee python=3.8 conda activate gee pip install geemap import ee import geemap geemap.set_proxy(port=7890) # 代理端口 然后输入 Google 授权代码 (在弹出的网页中登录google账户即可。)
获取代理端口：
win+X 选择 网络和Internet，使用代理服务器→编辑
mamba
mamba下载安装使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3e2bbd08601cbebdb5a8c3e16376368/" rel="bookmark">
			Redis7分布式缓存之基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis7分布式缓存 一、Redis入门概述1.主流功能与应用2.命名规则 二、Redis 10 大数据类型1.redis字符串 (String)2. redis列表 (List)3. redis哈希表 (Hash)4. redis集合 (Set)5. redis有序集合 (ZSet)6. redis地理空间(GEO)7. redis基数统计 (HyperLogLog)8. redis位图 (bitmap)9. redis位域 (bitfield)10. redis流(Stream) 三. `Redis持久化`1. RDB① 是什么② 能干嘛Snapshotting Config 快照时间配置（`redis.conf`） ③ 如何恢复④ 如何备份`BGSAVE(默认)` ⑤ 优点⑥ 缺点⑦ 那些情况会触发RDB快照⑧ 如何禁用快照 2. AOF （`Aof保存的是appendonly.aof文件`）① 是什么② AOF持久化工作流程③ AOF缓冲区三种写回策略④ 如何开启AOF⑤ 优点⑥ 缺点⑦ AOF重写机制Ⅰ是什么Ⅱ 触发机制Ⅲ 案例说明Ⅳ 重新原理 ⑧ AOF优化配置项详解⑨ 小总结 3. AOF+RDB4. 纯缓存模式 四. Redis事务1. 是什么2. 能干嘛3. Redis事务 VS 数据库事务4. Redis事务常用命令 五. Redis管道1. 面试题2. 是什么① 解决思路 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3e2bbd08601cbebdb5a8c3e16376368/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a161f40703bc92c4a2f73fa4edba261f/" rel="bookmark">
			TCP和UDP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是TCP、UDP TCP(Transmission Control Protocol 传输控制协议)：是一种面向连接的、可靠的、基于字节流的传输层通信协议，使用三次握手协议建立连接、四次挥手断开连接。面向连接就是使用该协议的双方（客户端和服务端）在彼此进行交换数据之前，必须先建立一个TCP连接，建立好一条通信线路（虚拟的），其过程有建立连接、维护连接、释放（断开）连接三个过程。在一个TCP连接中，只有通信双方能进行数据交换。TCP协议保证了数据通信的完整性和可靠性，防止丢包。
UDP(User Datagram Protocol 用户数据报协议)：是无连接的，基于报文的传输层协议，提供面向事务的简单不可靠信息传送服务，UDP协议的主要作用是将网络数据流量压缩成数据包的形式。
二、TCP和UDP的区别 1. TCP是面向连接的，可靠的，基于字节流的传输层协议；UDP是面向无连接的，不可靠的，基于报文的传输层协议。
2. TCP只支持一对一的数据通信；UDP支持一对一、一对多、多对一、多对多的数据通信。
3. TCP协议保证数据传输不丢失，不重复，无差错，有序到达；UDP无法保证。
4. TCP建立连接要经历三个阶段，第一阶段：建立连接，发出建立连接的请求；第二阶段：传输数据，连接建立成功后，进行数据传输；第三阶段，数据传输完成后释放连接；UDP直接进行数据传输。
5. UDP传输效率高，且具有实时性，适用于高速传输和实时通信。
6.TCP占用资源多于UDP，TCP首部占20个字节，UDP首部占8个字节。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca70fb9e94b6163dbcc82707e383b0e/" rel="bookmark">
			基于树莓派4B的YOLOv5-Lite目标检测的移植与部署（含训练教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本文为手把手教学树莓派4B项目——YOLOv5-Lite目标检测，本次项目采用树莓派4B（Cortex-A72）作为核心 CPU 进行部署。该篇博客算是深度学习理论的初步实战，选择的网络模型为 YOLOv5 模型的变种 YOLOv5-Lite 模型。YOLOv5-Lite 与 YOLOv5 相比虽然牺牲了部分网络模型精度，但是缺极大的提升了模型的推理速度，该模型属性将更适合实战部署使用。该项目的实践将帮助大家成功进入 “嵌入式AI” 领域，后续将在该项目上加入嵌入式的 “传统控制” 属性，读者朋友可以期待一下！（文末有代码开源！）
硬件实物图：
效果图：
一、YOLOv5-Lite概述 1.1 YOLOv5概述 YOLOv5 网络模型算是 YOLO 系列迭代后特别经典的一代网络模型，作者为：Glenn Jocher。部分学者可能认为YOlOv5的创新性不足，其是否称得上 YOLOv5 而议论纷纷。作者认为 YOLOv5 可以算是对 YOLO 系列之前的一次集大成者的总结和突破，其属于非常优秀经典的网络模型框架，各种网络结构和 trick 是非常值得借鉴的！
代码地址：ultralytics/yolov5: YOLOv5 🚀 in PyTorch &gt; ONNX &gt; CoreML &gt; TFLite (github.com)
Yolov5 官方代码中，给出的目标检测网络中一共有4个版本，分别是Yolov5s、Yolov5m、Yolov5l、Yolov5x四个模型。作者仅以 Yolov5s 的网络结构为对象进行讲解，其他版本的读者朋友可以参考其他博客！
Yolov5s 网络是 Yolov5 系列中深度最小，特征图的宽度最小的网络。后面的3种都是在此基础上不断加深，不断加宽。Yolov5 的网络结构图如下（源于江大白大佬的结构图）：
上图即 Yolov5 的网络结构图，可以看出，还是分为输入端、Backbone、Neck、Prediction四个部分。
（1）输入端：Mosaic数据增强、自适应锚框计算、自适应图片缩放
（2）Backbone：Focus结构，CSP结构
（3）Neck：FPN+PAN结构
（4）Prediction：GIOU_Loss
上述四部分都是属于如今很常见的模块与Trick了，受限于博客篇幅，各部分的详解就不与读者朋友好好分析和交流了。建议对 YOLO 系列陌生的朋友可以去好好看看其他博主的博客亦或是去B站看视频教学！
下面丢上 Yolov5 作者的算法性能测试图：
到现在为止，Yolov5 已经更新迭代到 v7.0 版本了，科研学术圈以 Yolov5 为基础框架进行魔改的论文数不胜数。通过上述作者的概述读者朋友可能对 Yolov5 有了一个大致的了解，不难发现 Yolov5 是非常优秀的神经网络模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ca70fb9e94b6163dbcc82707e383b0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b1420157e515c5a6c960e0df66b9b5f/" rel="bookmark">
			Hadoop3.3.1完全分布式部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop目录 Hadoop3.3.1完全分布式部署(一)1、HDFS 一、安装1、基础安装1.1、配置JDK-181.2、下载并解压hadoop安装包本地运行模式测试 eg: 2、完全分布式运行模式1、概要：2、编写集群分发脚本，把1~4步安装的同步到其他服务器：2.1、创建脚本`vim /var/opt/hadoopSoftware/hadoopScript/bin/xsync`，添加执行权限2.2、开始同步JDK、Hdoop、环境变量 3、配置ssh免密4、配置xml4.1、集群部署规划如下：4.2、所需配置文件4.3、配置集群1）核心配置文件2）HDFS配置文件3）YARN配置文件4）MapReduce配置文件 5、启动整个集群5.1、配置workers5.2、启动集群5.3、页面地址： 6、集群测试6.1、上传文件到集群测试6.2、上传大文件测试6.3、hadoop集群测试 7、集群崩溃处理1）先停止集群2）删除每个集群上的3）格式化集群4）启动集群 8、配置历史服务器8.1、配置mapred-site.xml8.2、同步配置8.3、在hadoop1上启动历史服务器8.4、查看历史服务器是否启动8.5、查看JobHistory 9、配置日志聚合功能1）配置yarn-site.xml2）同步配置3）关闭重启NodeManager、ResourceManager、HistoryServer 10、集群启停总结：1、整体启动停止(推荐)1）整体启动、停止HDFS2）整体启动体制YARN3）启停historyserver 2、各个服务组件分别启/停1）启/停HDFS组件2）启/停YARN组件3）启停historyserver 11、编写Hadoop集群常用脚本1）批量启停`hadoop`服务2）查看所有服务器Java进程脚本：jpsall 12、常用端口号 注：长时间无法关闭集群实践参考网站 Hadoop3.3.1完全分布式部署(一) Hadoop 是一种分析和处理大数据的软件平台，是一个用 Java 语言实现的 Apache 的开源软件框架，在大量计算机组成的集群中实现了对海量数据的分布式计算。
结构框架
推荐架构
1、HDFS 一个提供高可用的获取应用数据的分布式文件系统。
从字面上来看，SecondaryNameNode 很容易被当作是 NameNode 的备份节点，其实不然。可以通过下图看 HDFS 中 SecondaryNameNode 的作用。
NameNode主要是用来保存HDFS的元数据信息，比如命名空间信息，块信息等。当它运行的时候，这些信息是存在内存中的。但是这些信息也可以持久化到磁盘上。
fsimage - 它是在NameNode启动时对整个文件系统的快照
edit logs - 它是在NameNode启动后，对文件系统的改动序列
Secondary NameNode就是来帮助解决上述问题的，它的职责是合并NameNode的edit logs到fsimage文件中。
它定时到NameNode去获取edit logs，并更新到自己的fsimage上。一旦它有了新的fsimage文件，它将其拷贝回NameNode中。NameNode在下次重启时会使用这个新的fsimage文件，从而减少重启的时间。 一、安装 1、基础安装 $ yum install -y gcc vim wget $ sudo yum install ssh $ sudo yum install pdsh -y 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b1420157e515c5a6c960e0df66b9b5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1a7a2081c53d7d584e1ce9e8b8fe5de/" rel="bookmark">
			libpcap的简单应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是libpcap及pcap的嗅探器程序的总体框架 libpcap（Packet Capture Library），即数据包捕获函数库。在网络包抓取中libpcap是非常常用的一个库，著名的tcpdump就是用它来实现的。libpcap是一个 与实现无关的访问操作系统所提供的分组捕获函数库，用于访问数据链路层。这个库为不同的平台提供了一致的C函数编程接口，在安装了 libpcap 的平台上，以 libpcap 为接口写的程序、应用，能够自由地跨平台使用。它支持多种操作系统。
基于pcap的嗅探器程序的总体架构，其流程如下： (1)首先要决定用哪一个接口进行嗅探开始。在Linux中，这可能是eth0，而在BSD系统中则可能是xl1等等。我们也可以用一个字符串来定义这个设备，或者采用pcap提供的接口名来工作。
(2)初始化pcap。在这里需要告诉pcap对什么设备进行嗅探。假如愿意的话，我们还可以嗅探多个设备。怎样区分它们呢？使用 文件句柄。就像打开一个文件进行读写一样，必须命名我们的嗅探“会话”，以此使它们各自区别开来。
(3)如果只想嗅探特定的传输（如TCP/IP包，发往端口23的包等等），我们必须创建一个规则集合，编译并且使用它。这个过程分为三个相互紧密关联的阶段。 规则集合被置于一个字符串内，并且被转换成能被pcap读的格式(因此编译它)。编译实际上就是在我们的程序里调用一个不被外部程序使用的函数。接下来我们要告诉 pcap使用它来过滤出我们想要的那一个会话。(此步骤可选)
(4)最后，我们告诉pcap进入它的主体执行循环。在这个阶段内pcap一直工作到它接收了所有我们想要的包为止。每当它收到一个包就调用另一个已经定义好的函数，这个函数可以做我们想要的任何工作，它可以剖析所部获的包并给用户打印出结果，它可以将结果保存为一个文件，或者什么也不作。
(5)在嗅探到所需的数据后，我们要关闭会话并结束。
二、libpcap的相关函数 int pcap_findalldevs (pcap_if_t **alldevsp, char *errbuf) 构造一个可打开的网络设备的列表
-1表示错误，buf中会有错误消息；0表示成功。能被查找到的设备是能被打开的设备。
pcap_lookupdev(errbuf)通过该函数可以让系统自动寻找设备，其中errbuf为错误信息 pcap_t *pcap_open_live(char *device, int snaplen, int promisc, int to_ms, char *ebuf)
第一个参数为我们设置的设备
第二个参数为我们的最大抓包长度，65535可以满足大多数的应用
第三个模式为是否选择混杂模式，选择混杂模式可以捕捉所有包，如发向它的，从它发出的，或经它路由的等都会被嗅探器捕捉。
第四个参数为抓包的超时时间
过滤器的编译及使用由pcap_compile()与pcap_setfilter()这两个函数完成。在本文中不做使用
实际的抓包
u_char *pcap_next(pcap_t *p, struct pcap_pkthdr *h)——捕捉单个包
第一个参数代表设备句柄
第二个参数是指向一个包括了当前数据包总体信息（被捕捉时的时间，包的长度，其被指定的部分长度）的结构体的指针（在这里只有一个片断，只作为一个示例）。pcap_next()返回一个u_char指针给被这个结构体描述的包
int pcap_loop(pcap_t * p,int cnt, pcap_handler callback, uchar * user)——捕获数据包,不会响应pcap_open_live()函数设置的超时时间
第一个参数代表设备句柄
cnt用于设置所捕获数据包的个数
pcap_handler 是与void packet_handler()使用的一个参数,即回调函数的名称;user值一般为NULL
pcap_callback(u_char* argument,const struct pcap_pkthdr* packet_header,const u_char* packet_content)——回调函数，对数据包的处理都在此函数内
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1a7a2081c53d7d584e1ce9e8b8fe5de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73a340f7daccb0086f745eb4d18567c9/" rel="bookmark">
			go 进阶 go-zero相关: 一. go-zero 基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. go-zero 基础解释二. 搭建一个基础的go-zero服务1. 安装 goctl2. 使用goctl命令创建一个go-zero服务api目录结构介绍main函数介绍介绍etc下的配置文件与intenal/config下的Config结构体介绍rest.MustNewServer(c.RestConf) 创建Server1. engine2. patRouter3. svc.NewServiceContext(c)创建ServiceContext handler.RegisterHandlers(server, ctx) 注册业务Handler1. 编写业务结构体,实现业务方法示例2. 编写将业务module并封装为Handler的函数示例3. 将Handler封装为Route调用server.AddRoutes()注册到Server示例 基于.api文件使用goctl命令构建服务或生成代码示例1. api文件介绍 一. go-zero 基础解释 教程文档地址: 添加链接描述添加链接描述w3cschool教程地址go-zero作者go-zero 入门级demo参考博客 二. 搭建一个基础的go-zero服务 new–&gt;Project–&gt;Go modules (Environment 下输入代理地址"GOPROXY=https://goproxy.cn,direct") 注意新版本的Goland开发工具默认的go选项,就是以前的"Go modules"直接创建项目就可以了,并且GOPATH 的项目重命名为 Go (GOPATH)
如果创建的Project没有基于go mod,执行"go mod init 项目名称" 在当前目录中初始化和创建一个新的go.mod文件执行go get命令下载go-zero go get -u github.com/zeromicro/go-zero 1. 安装 goctl goctl的优点
执行命令
# Go 1.15 及之前版本 GO111MODULE=on GOPROXY=https://goproxy.cn/,direct go get -u github.com/zeromicro/go-zero/tools/goctl@latest # Go 1.16 及以后版本 GOPROXY=https://goproxy.cn/,direct go install github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73a340f7daccb0086f745eb4d18567c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/620cbc4062921d13d8c436c40dd2378a/" rel="bookmark">
			python 如何用pandas合并相同数据？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据分析中，我们常常需要将不同的数据表中的相同数据进行合并。Pandas提供了简单易用的方法来实现这个功能。本文介绍如何使用Pandas的groupby和aggregate方法合并相同的行数据。
假设我们有两张数据表:
python df=pd.DataFrame([['AAA'，3]，['BBB'，4]，['CCC'，5]，['AAA'，8]，['CCC'，9]]，columns=['item'，'num']) df1=pd.DataFrame([['AAA'，11]，['BBB'，4]，['CCC'，14]]，columns=['item'，'num']) 我们要将df和df1按item列合并，得到的结果为:
item num 0 AAA 11 1 BBB 4 2 CCC 14 ## 分组聚合
首先，我们使用`.groupby()`对df和df1进行分组，分组键为item列:
python df_grouped = df.groupby('item') df1_grouped = df1.groupby('item') 然后，使用`.aggregate()`选择num列求和，得到两张分组求和后的DataFrame:
python df_sum = df_grouped['num'].aggregate(np.sum) df1_sum = df1_grouped['num'].aggregate(np.sum) ## 拼接表格
我们重命名df_sum为df，df1_sum为df1_sum，然后使用`pd.concat()`方法按item列拼接:
python df = df_sum.reset_index() df1_sum = df1_sum.reset_index() result = pd.concat([df， df1_sum]， ignore_index=True) 此时的result表格有重复行，我们使用`.drop_duplicates()`删除重复行，并重命名列名:
python result = result.drop_duplicates(['item']) result = result.rename(columns={'num_x': 'num'， 'num_y': 'num'}) ## 完整代码
python df_grouped = df.groupby('item') df_sum = df_grouped['num'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/620cbc4062921d13d8c436c40dd2378a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2060fcb0f69bbda126ab63f6133a5517/" rel="bookmark">
			【Flink】DataStream API使用之转换算子（Transformation）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转换算子（Transformation） 数据源读入数据之后，就是各种转换算子的操作，将一个或者多个DataSream转换为新的DataSteam，并且Flink可以针对一条流进行转换处理，也可以进行分流或者河流等多流转换操作，从而组成复杂的数据流拓扑。
1. 基本转换算子 这里介绍的都是最基本的转换算子，在官方文档会有更多的算子介绍
1.1 Map(映射) -------内容描述：在 DataStream 上应用映射转换。转换为DataStream的每个元素调用一个 MapFunction。每个 MapFunction 调用只返回一个元素。用户还可以扩展 RichMapFunction 以访问org.apache.flink.api.common.functions.RichFunction 接口提供的其他功能。参数：DataStream 的每个元素调用的 MapFunction。返回值：SingleOutputStreamOperator转换后的数据流总结：数据转换，一一映射 图示：
源码：
public &lt;R&gt; SingleOutputStreamOperator&lt;R&gt; map(MapFunction&lt;T, R&gt; mapper) { TypeInformation&lt;R&gt; outType = TypeExtractor.getMapReturnTypes( clean(mapper), getType(), Utils.getCallLocationName(), true); return map(mapper, outType); } public &lt;R&gt; SingleOutputStreamOperator&lt;R&gt; map( MapFunction&lt;T, R&gt; mapper, TypeInformation&lt;R&gt; outputType) { return transform("Map", outputType, new StreamMap&lt;&gt;(clean(mapper))); } 可以看到参数是一个MapFunction，然后通过实现的map方法去一一返回对应的元素。
实例：
public static void main(String[] args) throws Exception { // 1. 直接调用getExecutionEnvironment 方法，底层源码可以自由判断是本地执行环境还是集群的执行环境 StreamExecutionEnvironment env = StreamExecutionEnvironment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2060fcb0f69bbda126ab63f6133a5517/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23dd31b9030444beac9a3a1b6c30314/" rel="bookmark">
			【Flink】Flink 中的时间和窗口之水位线(Watermark)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 时间语义 这里先介绍一下什么是时间语义，时间语义在Flink中是一种很重要的概念，下面介绍的水位线就是基于时间语义来讲的。
在Flink中我们提到的时间语义一般指的是事件时间和处理时间：
处理时间(Processing Time)，一般指执行处理操作的系统时间，也就是Flink的窗口算子对该数据的操作时间。事件时间(Event Time)， 一般指每个事件在对应设备上发生的时间，也就是数据的生成的时间。 Flink中之所以会出现这两种时间语义，是因为Flink的分布式系统会有网络传输延迟以及时钟飘逸，处理时间相对于事件时间会有所滞后，并且数据在网络以及Flink中的传输是是乱序的。Flink的1.12版本之前默认使用的是处理时间，之后已经将事件时间作为默认的时间语义。
对于 先产生的数据先被处理，这就要求需要保证数据的到达顺序，但是因为网络传输延迟不确定性，是无法保证数据的到达顺序，在这种情况下就不能简单使用数据自带的时间戳当做时钟，而是需要另外的标志来表达事件时间的进展，在Flink中这就是事件时间的水位线。
2. 水位线 Flink中的水位线（Watermark）是一种用来表示事件时间进展的机制，它可以帮助Flink系统及时处理延迟数据，并保证处理结果的正确性。具体来说，水位线是一个时间戳，表示对于所有时间戳小于该水位线的事件已经全部到达，可以进行相应的计算处理。
2.1 事件时间和窗口 在实际应用中，一般都会采用事件时间语义，而水位线就是基于事件时间提出的概念。和水位线相关的还有一个窗口概念，事件时间和窗口也是有很大的关系。
这里举一个例子，我们有一个班车系统，班车上装的都是带有生产时间的商品，如果有一辆车的开车时间是8点，我们需要这辆车到九点就开始发车。商品一个个到达车上，车上的商品时间从8点开始依次增长。当到达车上的商品生产时间是九点的时候，这时候车门关闭开始发车。
在这个过程中，我们说的班车就相当于窗口，定义了一个8点到九点的窗口。并且我们会定义一个逻辑时钟，这个逻辑时钟是基于事件时间来的，不会自动流逝。时钟的进展就是靠着新的数据上的事件时间时间戳来推动的。这样就不需要依赖系统的时间，无论什么时候进行统计处理，得到的结果都是正确的。
2.2 什么是水位线 在事件时间语义下，我们可以不依赖系统时间，而是基于数据自带的时间戳去定义了一个时钟，用来表示当前时间的进展。这样每个并行子任务都会有一个自己的逻辑时钟，它的前进是靠数据的时间戳来驱动的。
但是在分布式系统中，会存在一些问题，因为数据本身在处理转换过程中会发生变化，如果遇到窗口聚合的操作，呢么下游的数据就会变少，时间进度的控制就不精细了。另外，数据向下游任务传递时，一般只能传输给一个子任务（除广播外），这样其他的并行子任务的时钟就无法推进了。
所以时钟也需要以数据的形式传递出去，告诉下游任务当前时间的进展；而且时钟传递过程也不会因为运算而停滞。解决这个问题的想法就是在数据流种加入一个时间标记，记录当前的事件时间并且广播到下游，当下游收到这个标记就可以更新自己的时钟了。这种用来衡量事件时间进展的标记在Flink中就被称作水位线。
如图 6-5 所示，每个事件产生的数据，都包含了一个时间戳，我们直接用一个整数表示。这里没有指定单位，可以理解为秒或者毫秒（方便起见，下面讲述统一认为是秒）。当产生于2 秒的数据到来之后，当前的事件时间就是 2 秒；在后面插入一个时间戳也为 2 秒的水位线，随着数据一起向下游流动。而当 5 秒产生的数据到来之后，同样在后面插入一个水位线，时间戳也为 5，当前的时钟就推进到了 5 秒。这样，如果出现下游有多个并行子任务的情形，我们只要将水位线广播出去，就可以通知到所有下游任务当前的时间进度了。
水位线就像它的名字一样，是数据流中的一部分，随着数据一起流动，在不同任务之间传输。不过水位线也存在有序和乱序区分：
2.2.1 有序流中的水位线 在理想状态下，数据按照顺序排好队进入数据流，并且处理的过程遵循先来后到的原则，这样每个数据中提取的时间戳就会保持从小到大的增长，而水位线也会不断增长、事件时钟也不断向前推进。
但是在实际应用中，数据量非常大，还有可能好多数据的事件时间戳都是相同的，每一个都插入水位线是做了很多无用功的。所以为了提高效率一般每隔一段时间生成一个水位线，这个水位线的时间戳就是当前最新数据的时间戳，就如下图所示： 这里注意水位线插入的周期本身也是时间概念，并且这个周期时间是指处理时间也就是系统时间，而不是事件时间，如果使用事件时间就陷入了死循环了。
2.2.2 乱序流中的水位线 有序流的处理非常简单，但是在分布式系统中，会因为数据在节点的传输以及网络传输的延迟不确定性导致顺序发生改变，这就是乱序数据。 这里所说的乱序是指数据的先后顺序不一致，主要就是基于数据的产生时间而言的。如图 6-7 所示，一个 7 秒时产生的数据，生成时间自然要比 9 秒的数据早；但是经过数据缓存和传输之后，处理任务可能先收到了 9 秒的数据，之后 7 秒的数据才姗姗来迟。这时如果我们希望插入水位线，来指示当前的事件时间进展，又该怎么做呢？ 解决思路也很简单：我们插入新的水位线时，要先判断一下时间戳是否比之前的大，否则就不再生成新的水位线，如图 6-8 所示。也就是说，只有数据的时间戳比当前时钟大，才能推动时钟前进，这时才插入水位线。
考虑到大量数据同时到来的处理效率，我们同样可以周期性的生成水位线。这时只需要保存一下之前所有数据中的最大时间戳，需要插入水位线时，就直接以它作为时间戳生成新的水位线，如图 6-9 所示。
但是又如何处理迟到的数据？其实也很简单，那就是等待几秒，比如上图当收到9秒的数据，等待2秒也就是7秒，这时候7秒的数据到来，数据就到齐了。
下图是我们使用周期性的方式生成等待2秒的水位线
另外需要注意的是，这里一个窗口所收集的数据，并不是之前所有已经到达的数据。因为数据属于哪个窗口，是由数据本身的时间戳决定的，一个窗口只会收集真正属于它的那些数据。也就是说，上图中尽管水位线 W(20)之前有时间戳为 22 的数据到来，10~20 秒的窗口中也不会收集这个数据，进行计算依然可以得到正确的结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c23dd31b9030444beac9a3a1b6c30314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31083d1ad262d277549ce6f4daef71d5/" rel="bookmark">
			pointNet训练预测自己的数据集Charles版本(二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前博客介绍了如何跑通charles版本的pointNet，这篇介绍下如何来训练和预测自己的数据集，介绍如何在自己的数据集上做点云语义分割，此篇的环境配置和博客中保持一致。点云分类较简单，方法差不多，这边就不特地说明了。
一.在自己的点云数据集上做语义分割 1. RGB-D Scenes Dataset v.2数据集介绍 博主拿数据集RGB-D Scenes Dataset v.2来做实验，数据集下载链接如下：
RGB-D Scenes Dataset v.2
所下载的数据集的目录结构如下：
​
01.label是标注数据，01.ply是点云数据，其它类似，可看到点云和标注数据是分离开来的，这边博主手写了如下脚本来合并01.label和01.ply文件，以将label中数据作为Scalar field。脚本如下：
import numpy as np import glob import os import sys from plyfile import PlyData, PlyElement import pandas as pd BASE_DIR = os.path.dirname(os.path.abspath(__file__)) ROOT_DIR = os.path.dirname(BASE_DIR) sys.path.append(BASE_DIR) if __name__ == "__main__": with open(BASE_DIR + '/rgbd-scenes-v2/pc/01.ply', 'rb') as f: plydata = PlyData.read(f) print(len(plydata.elements[0].data)) label = np.loadtxt(BASE_DIR + '/rgbd-scenes-v2/pc/01.label') print(label.shape) vtx = plydata['vertex'] points = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31083d1ad262d277549ce6f4daef71d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a4cc3f4635bc7540f2cdfac18b87bc1/" rel="bookmark">
			【HTML】通过meta代码强制浏览器使用WebKit内核极速模式（解决 meta name=“renderer“ content=“webkit“ 不起作用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决&lt; meta name=“renderer” content=“webkit”&gt;不起作用，从“步骤”开始看起。
一般只使用代码 ，会有些浏览器会不起作用，所以在使用的时候，要完全兼顾。如果知道为什么使用这个标签，请直接从“步骤”开始查看。
为什么这么做 国产浏览器 (例如：360浏览器双核) 大多是双内核，甚至是三内核。一个Chromium内核，也就是Chrome使用的内核，切换到这个内核的模式一般叫极速模式；一个IE内核，称之为IE模式；有的甚至还有一个修改过的IE内核，称之为兼容模式。
这些浏览器这样做的原因是国内还有大量为IE浏览器量身定做的网站，为了兼容这些网站，不默认启用极速模式，而是根据代码判断选择IE模式或者兼容模式或者极速模式。
问题在于，浏览器自动选择经常判断错误，导致本来使用Webkit可以获得更好浏览效果的网站错误在IE模式中带着BUG运行。让开发者头疼。
幸好，现在多核浏览器已经支持通过meta标签指定浏览模式，那么，我们就可以通过meta代码强制浏览器启用Chromium内核，为用户提供最好的使用体验。
步骤 在网页头部标签内添加以下代码： &lt;meta name="renderer" content="webkit"/&gt; &lt;meta name="force-rendering" content="webkit"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"/&gt; 三个都写上就不会出现 &lt; meta name=“renderer” content=“webkit” &gt; 不起作用的问题
这三行代码分别作用于不同环境，如下所述：
&lt;!-- 强制Chromium内核，作用于360浏览器、QQ浏览器等国产双核浏览器 --&gt; &lt;meta name="renderer" content="webkit"/&gt; &lt;!-- 强制Chromium内核，作用于其他双核浏览器 --&gt; &lt;meta name="force-rendering" content="webkit"/&gt; &lt;!-- 如果有安装 Google Chrome Frame 插件则强制为Chromium内核，否则强制本机支持的最高版本IE内核，作用于IE浏览器 --&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"/&gt; 低版本IE浏览器访问问题 添加好强制Webkit内核的代码，使用国产浏览器访问网站已经不存在IE兼容问题了，IE访客量将大大减少。但仍然不可避免会有一些老旧电脑通过低版本IE浏览器访问，如果我们专门为了这极小部分用户进行 CSS HACK ，将严重加重我们的工作量。
更何况自2016年1月起微软已经停止为IE11以下版本提供支持和更新，已经这么久没有更新，低版本IE不仅对CSS3和HTML5支持有问题，更有安全问题。
那么，我们不去支持低版本IE，这小部分用户怎么办呢？
我们可以使用 if IE 语句给网站添加IE升级提示，提示用户进行浏览器升级，或者切换更先进的浏览器再访问。
我们可以在刚刚的meta标签下添加一段跳转到IE升级提示页的代码（当IE版本低于IE11时跳转），实现低版本IE用户访问时提示他们进行升级或者更换浏览器。
强制Webkit内核和提示低版本IE访问用户升级完整代码如下所示，把这段代码添加到头部模板文件标签下即可：
&lt;meta name="renderer" content="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a4cc3f4635bc7540f2cdfac18b87bc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dbc0c05122a1ff1802b7e3ec7cda47a/" rel="bookmark">
			git使用、github/gitee远程代码仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简介1.Git是什么2.Git的工作流程 二、git使用三、github/gitee远程代码仓库1.建立仓库2.推送仓库3.克隆仓库 一、简介 1.Git是什么 Git是分布式版本控制系统：他没有中央服务器，每个开发者电脑就是一个完整的版本库。这样工作时候就不需要联网了，因为版本都是在自己的电脑上。不需要连接中央服务器提交代码。每一个开发人员的电脑上都有一个本地仓库，我们就可以使用本地仓库来实现代码的管理，我们可以在本地把代码加到版本库中，就可以对文件进行增删改查的操作。如果我们在开发一个项目时，只有一个开发人员，不需要和别人交换代码，我们只需要本地仓库，不需要远程仓库。如果是多人协作开发项目，那么我们就需要交换代码，这时就需要一个远程仓库。远程和本地仓库中的内容其实是一样的，我们需要做的是将本地仓库向远程仓库复制 一份。如果别人想把远程仓库的代码拿到本地仓库，需要再复制一份！这样其实就是复制了整个仓库。开发人员从远程仓库复制一份完整的仓库放到本地，如果不需要交换代码就不需要远程仓库，本地就是一个闭环！ Git应用场景介绍
1.多人开发代码管理
2.异地开发代码管理
3.版本管理、版本回滚
······
2.Git的工作流程 1.从远程仓库中克隆（Clone）Git资源作为本地仓库
2.从本地仓库中Checkout代码然后进行代码修改
3.在进行提交前先将代码提交到暂存区
4.提交修改，提交（Commit）到本地仓库，本地仓库中保存修改的各个历史版本
5.在修改完成后，需要和团队成员共享代码时，可以将本地仓库代码Push到远程仓库
二、git使用 官方网站：git-scm.com
[root@server1 ~]# yum install -y git [root@server1 ~]# mkdir demo [root@server1 ~]# cd demo/ 初始化版本库 [root@server1 demo]# git init ##推荐不在主目录，以后执行命令在本目录 Initialized empty Git repository in /root/demo/.git/ 查看状态
[root@server1 demo]# git status # On branch master # # Initial commit # nothing to commit (create/copy files and use "git add" to track) [root@server1 demo]# git status -s	#简化输出 [root@server1 demo]# echo test &gt; README.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dbc0c05122a1ff1802b7e3ec7cda47a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7e559b6e63d8ebff3851b93ff73aa5c/" rel="bookmark">
			Linux驱动学习（4） MTD字符驱动和块驱动1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 Linux驱动学习（4）
文章目录 目录
目录
系列文章目录
文章目录
前言
一、MTD是什么？
二、MTD子系统架构
1.Linux文件存储基本架构： ​
2.MTD子系统基本架构：
总结
前言 MTD设备在嵌入式设备中时常被用到，linux系统到底如何使用MTD设备是每个嵌入式开发者必须要弄清楚的一门技术。
一、MTD是什么？ 根据百科解释，MTD是Memory Technology Device的缩写，指的是一类提供类似文件系统的访问接口的非易失性存储设备，例如闪存、EEPROM和NAND Flash等。MTD设备可以通过一组访问接口（如mtdchar、mtdblock和JFFS2等）与内核交互，从而提供高效的文件系统支持和数据存储服务。在Linux系统中，MTD设备被广泛用于嵌入式系统中，如路由器、智能家居、可穿戴设备等。
从这里我们知道，MTD主要是非易失性存储设备，常见的是flash，和内核交互通过字符设备或者块设备的形式。
二、MTD子系统架构 1.Linux文件存储基本架构： Linux主要通过块设备的形式访问磁盘等设备，但是不仅仅是块设备，也可以通过字符设备访问存储设备，字符设备的驱动程序相对于块设备驱动程序更简单，常常可以用在嵌入式设备分区升级等不需要随机访问的功能当中，而对于小文件的创建，需要文件系统进行复杂的管理，这个时候就需要使用块设备驱动对存储设备随机f的功能
2.MTD子系统基本架构： mtd虽然叫做子系统，但是内部没有subsys_init宏，所以我的理解是mtd就是有数个模块组合的子系统，主要包含mtd字符设备驱动,mtd块设备驱动，nand flash驱动，nor nand驱动。
参考：Linux MTD架构下的nand flash驱动详解_nand_to_mtd 信息不对_Golden_Chen的博客-CSDN博客
总结 mtd主要包含mtd字符设备驱动和mtd块设备驱动，接下来写驱动demo和示例demo。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51759fc015a3637964c5318c3cea99cf/" rel="bookmark">
			neo4j 删除数据库后打不开localhost:7474
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下：
数据太大delete删不掉
没找到graph.db
直接删除了data/databases/下所有文件
结果打不开了
通过neo4j console发现
data/transations 下的文件也需要删除
暴力删除数据库：
删除databases 和 transations所有文件，别漏文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8251fe02bef2f3cea7c90ffa7db8ddbe/" rel="bookmark">
			R语言结构方程模型代码与理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R语言结构方程模型代码与理解 引言 结构方程模型（Structural Equation Modeling，简称 SEM）是一种基于概率统计的多变量分析方法，可以用于探究变量间的因果关系。
SEM 可以同时估计测量模型和结构模型，从而可以考虑到测量误差和隐变量的影响。在 SEM 中，测量模型用来描述每个测量变量与其背后的潜在变量之间的关系，而结构模型用来描述潜在变量之间的因果关系。SEM 可以通过最大似然估计、贝叶斯估计等方法求解模型参数，从而得到模型的拟合度和参数估计结果。
总之，SEM是一种判断复杂变量之间的关系、贡献度、相关性的工具。（而不是一种回归模型）
小编以SEM为关键词检索，有很多所谓的“名师”课程，售价往往几千起步，成本非常高啊。
image-20230626181625999 其实SEM本身并不是很复杂，小编总结了代码和原理，希望能运用到大家的实际研究中。
代码 实例1 其中，lavaan用于SEM分析，semPlot用于可视化路径结果，tidyverse用于数据处理
library(lavaan)
library(semPlot)
library(tidyverse)
示例1是一个lavaan包官方例子，https://www.cnblogs.com/squidGuang/p/9054301.html
首先加载数据
data &lt;- HolzingerSwineford1939
data &lt;- data %&gt;% na.omit()
head(data, 10)
数据概念如下：
数据为整体为小学同学的智力测量因素
视觉因子(visual)对应x1，x2，x3
文本因子(textual)对应x4，x5，x6
速度因子(speed)对应x7，x8，x9
总共需要三个步骤：
根据数据的物理意义把模型的路径写出来 拟合SEM 提取结果 #step 1：write the road of model
model &lt;- ' visual =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed =~ x7 + x8 + x9
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8251fe02bef2f3cea7c90ffa7db8ddbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37518e9468c57551a11a023e42c06497/" rel="bookmark">
			AIGC论文串烧！从GAN和Diffusion讲起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：夕小瑶科技说
刚刚过去的几个月，无疑是生成式AI爆发的奇点。
说到生成式AI，就不得不提到AIGC。AIGC全称为AI-Generated Content，指基于预训练大模型、生成式对抗网络（GAN）等人工智能技术，通过已有数据寻找规律，并通过释放泛化能力生成相关技术的内容。
AIGC 在图像生成中的示例
虽然在文生图领域，扩散模型似乎已经一统天下，但GAN 依然存在不可磨灭的优势。这使得一些研究者在这一方向上持续努力，并取得了非常实用的成果，相关的论文已被 CVPR 2023 接收。
这次我整理了46篇【CVPR 2023的AIGC应用汇总】图像转换、翻译/可控文生图/图像恢复/语义布局可控生成/医学图像/face相关的基于diffusion扩散模型/GAN生成对抗方法论文合集+部分代码，我特地选了6篇具有代表性的文章为大家叙述，希望对在该领域想发论文的同学带来一些新思路！
“
01
GAN的反击！朱俊彦新作GigaGAN，出图速度秒杀Stable Diffusion
题目：
最近，文字-图像生成技术的成功已经席卷全球，激发了大众的想象力。从技术的角度来看，它也标志着设计生成图像模型所青睐的架构的巨大变化。GANs曾经是事实上的选择，有StyleGAN这样的优秀技术。随着DALL·e2的出现，自回归和扩散模型似乎一夜之间成为大规模生成模型的新标准。
CycleGAN 的主要作者、曾获 2018 年 ACM SIGGRAPH 最佳博士论文奖的朱俊彦是这篇 CVPR 论文的第二作者。
该研究首先使用 StyleGAN2 进行实验，并观察到简单地扩展主干网络会导致训练不稳定。基于此，研究者确定了几个关键问题，并提出了一种在增加模型容量的同时稳定训练的技术。
“
02
基于示例的图像转换的屏蔽和自适应变压器
题目：
该论文提出了一个基于样本的图像转换新方法。用于此任务的先进方法主要集中在建立跨域语义对应上，但跨域语义匹配具有挑战性，匹配错误最终会降低生成图像的质量。
为了克服这一挑战，该论文提出了一种掩码和自适应变换器 (MAT)，用于学习准确的跨域对应关系，并执行上下文感知特征增强。为了实现后者，使用样本的输入源特征和全局样式代码作为补充信息来解码图像。
此外，设计了一种新的对比风格学习方法，用于获取质量区分风格表示，这反过来有利于高质量图像的生成。实验结果表明在各种图像转换任务中表现更好。
“
03
具有列行纠缠像素合成的高效尺度不变生成器
题目：
该论文说明任意尺寸图像生成（Any-scale image synthesis）提供了一种高效和可扩展的解决方案，可以在任何比例下合成逼真的图像，甚至超过2K分辨率。
这项工作提出了列行耦合的像素生成（Column-Row Entangled Pixel Synthesis，CREPS），一种既高效又具有尺度等变性的新型生成模型，而不使用任何空间卷积或粗到细的设计。在各种数据集上的实验，包括FFHQ、LSUNChurch、MetFaces和Flickr-Scenery，证实了CREPS具有在任意任意分辨率下合成尺度一致图像的能力。
“
04
图像恢复，基于GAN生成对抗/diffusion扩散模型方法
题目：
该论文研究JPEG图像恢复问题，即加密比特流中的比特错误。比特错误会导致解码后的图像内容出现不可预测的色偏和块位移，这些问题无法通过现有的主要依赖于像素域中预定义退化模型的图像恢复方法来解决。该论文提出了一个强健的JPEG解码器，并采用两阶段补偿和对齐框架来恢复受比特流损坏的JPEG图像。
具体而言，JPEG解码器采用了一种具有容错机制的方法来解码受损的JPEG比特流。两阶段框架由自补偿和对齐（SCA）阶段和引导补偿和对齐（GCA）阶段组成。在三个不同比特错误率的基准测试上进行了实验。实验结果和消融研究表明了我们所提出的方法的优越性。
“
05
PosterLayout：内容感知视觉文本演示布局的新基准和方法
题目：
该论文提出了设计序列形成（DSF）方法，以模拟人类设计师的设计过程重新组织布局中的元素，并提出了一种基于CNN-LSTM的条件生成对抗网络（GAN）来生成适当的布局。具体来说，鉴别器是设计序列感知的，将监督生成器的“设计”过程。
实验结果验证了新基准的有用性和所提出方法的有效性，该方法通过为不同的画布生成适当的布局实现了最佳性能。
“
06
使用人脑活动的潜在扩散模型进行高分辨率图像重建
题目：
本文提出一种基于扩散模型（DM）的新方法，通过功能性磁共振成像（functional magnetic resonance imaging，fMRI）从人脑活动来重构出图像。通过研究LDM的不同组成部分（例如图像的潜在向量Z、条件输入C以及去噪U-Net的不同元素）与不同的脑功能之间的关系，表征了LDM的内部机制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37518e9468c57551a11a023e42c06497/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/120/">«</a>
	<span class="pagination__item pagination__item--current">121/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/122/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>