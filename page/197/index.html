<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69d26cf4ba6e58cea1798027aa0cfc34/" rel="bookmark">
			解决：如何将pytorch的版本改为和cuda对应、如何使用笔记本电脑自带的NVIDIA使用GPU跑深度学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Step1：安装cuda 网址： https://developer.nvidia.com/cuda-toolkit-archive
PS：此处必须先看看电脑显卡是否自己就装了cuda，可以通过执行命令行语句nvcc -V以此检查cuda是否有，如果有将会显示下面的内容
Step2：执行深度学习命令，检验是否能够跑通 device = 'cuda:0' # 如果电脑上无Nvidia显卡或未安装CUDA框架，请更改为 'cpu' x = torch.rand(batch_size, seq_len, input_size).to(device) rnn = MyRNN(input_size, hidden_size, output_size).to(device) hidden, y = rnn(x) print(hidden.shape, y.shape) 如果能够跑通说明可以使用GPU跑深度学习。如果出现下述报错： AssertionError: Torch not compiled with CUDA enabled 该报错表示torch和cuda不兼容，此时只要更换pytorch的版本就可以了， 此时需要转至Step3。
Step3：去往pytorch的官网选择相应出cuda版本并下载pytorch 其中，cuda版本的选择只要低于当前cuda的版本就可以了；
建议不要使用conda安装，因此之后可能会出现由于conda版本未更新等问题而造成安装失败或者安装过慢，因此建议使用pip安装；
使用pip安装时可能会出现超时（即：timeout）等现象，此时可使用管理员的Windows终端执行命令，或者在网络好的时候重试几下等方式解决该问题。博主此处采取的是坚持不懈重试几次解决该问题（一把辛酸泪(╥╯^╰╥)），最终得以成功安装。
以上即为全部内容，OK(*^▽^*)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fccef2edfaca88ffc9e47faf840b7639/" rel="bookmark">
			Linux系统部署多个tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装tomcat命令
没有安装jdk记得先去下载安装。
个人习惯把安装包放在/usr/local/packge中统一管理（无此文件下自行创建）
tar -zxvf apache-tomcat-8.5.81.tar.gz(可重复安装同一版本，只需修改名称防止同名)
安装多个tomcat只需要重读操作就行
2.移动并修改文件名字到自己想存放的路径中
​​
3.进入 vim /usr/local/itsoft/tomcat8.1/conf/server.xml
修改tomcat默认端口号为8080，避免冲突
4.进入 vim /etc/sysconfig/iptables
放开端口号8080，8090端口号，若不止两个tomcat继续添加需要开放的端口号
5.重启iptables
查看防火墙状态:service iptable status
临时关闭防火墙:servcie iptables stop
重启防火墙:service iptables restart
6.启动tomcat
进入到每个tomcat的bin目录下启动 ./startup.sh
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8ce1a41b482acefb298551cf75bee3d/" rel="bookmark">
			HCIA基础（4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
交换技术
VLAN---虚拟局域网
VLAN的基本原理
VLAN帧格式 VLAN的类型
端口类型
VLAN的配置
VLAN之间的通讯
三层交换机的SVI接口
ACL技术---访问控制列表
ACL原理
ACL功能
ACL的匹配规则
ACL分类
NAT技术---网络地址转换
NAT的分类
静态NAT
动态NAT
NAPT
园区网组网 什么是园区网
园区网络分类
园区网络的构成 园区网的发展历程
交换技术 垃圾流浪问题 安全问题
VLAN---虚拟局域网 VLAN技术通过在交换机上配置VLAN机制，将一个大的交换网络在逻辑上划分成多个小的交换网 络。 VLAN的基本原理 VLAN帧格式 VLAN的类型 基于端口的VLAN---一层VLAN
在接口进行配置，将VLAN编号映射到交换机物理接口
该接口进入的帧都将被认为是该VLAN
最常用的方法
基于MAC地址的VLAN---二层VLAN
配置一个vlan和mac地址的映射关系，当数据帧进入交换机时，交换机会查询该映射关系表，根据不同的源mac地址来划分不同的vlan
一般用于pc接入交换机的端口会发送变化的情况
基于协议的VLAN---三层VLAN
根据帧中的不同协议来划分
端口类型 Access端口 一般用于交换机与终端设备相连的接口 假设此时有一个Access端口，其VID为2，从这个端口进入的数据包，都会被规划到vlan2，而 从这个端口发出的vlan则必须是vlan2的数据包，并且删除vlan的字段Trunk端口 一般用于交换机与交换机相连的接口Hybrid端口 同时具备Access和Trunk端口的功能，是一种工作机制及其灵活的端口 VLAN的配置 第一步，在交换机上创建VLAN
配置命令
[sw1]vlan 2-----创建vlan2；默认情况下交换机存在vlan1，并且所有接口属于vlan1
VID
取值范围0-4095；其中，0和4095保留不能使用，可使用范围是1-4094
VLAN ID：用来标识和区分VLAN
[sw1]vlan batch 4 10 20 ----同时批量的创建vlan4、10、20
[sw1]vlan batch 30 to 60 ---同时批量的创建vlan30到vlan60
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8ce1a41b482acefb298551cf75bee3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/882769778b92669ee218e24cec2352f2/" rel="bookmark">
			shp文件和geojson实现互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import com.alibaba.fastjson.JSONArray; import com.alibaba.fastjson.JSONObject; import com.vividsolutions.jts.geom.*; import lombok.extern.slf4j.Slf4j; import org.geotools.data.FeatureWriter; import org.geotools.data.Transaction; import org.geotools.data.shapefile.ShapefileDataStore; import org.geotools.data.shapefile.ShapefileDataStoreFactory; import org.geotools.data.simple.SimpleFeatureCollection; import org.geotools.data.simple.SimpleFeatureIterator; import org.geotools.data.simple.SimpleFeatureSource; import org.geotools.feature.simple.SimpleFeatureTypeBuilder; import org.geotools.geojson.feature.FeatureJSON; import org.geotools.geojson.geom.GeometryJSON; import org.geotools.referencing.crs.DefaultGeographicCRS; import org.opengis.feature.simple.SimpleFeature; import org.opengis.feature.simple.SimpleFeatureType; import java.io.*; import java.net.MalformedURLException; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.util.HashMap; import java.util.Map; @Slf4j public class ShpUtils { /** * geojson转换为shp文件 * @param jsonPath * @param shpPath * @return */ public static Map geojson2Shape(String jsonPath, String shpPath) { Map map = new HashMap(); GeometryJSON gjson = new GeometryJSON(); try { String strJson = new String(FileUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/882769778b92669ee218e24cec2352f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c614bef017859c81987e77c1c6fa18/" rel="bookmark">
			谭浩强c语言五位数的输入输出问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入一个不多于5位的整数，要求：
1.输出它的位数
2.分别输出每位数字
3.按输出每一位数字
代码如下：
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include&lt;math.h&gt; #include&lt;stdlib.h&gt; #include&lt;algorithm&gt; #include &lt;iostream&gt; using namespace std; int main() { int i, x; int n[5] = { 0 }; printf("请输入数字,以回车结束"); scanf("%d", &amp;x); n[0] = x / 10000; n[1] = x / 1000 % 10; n[2] = x / 100 % 10; n[3] = x / 10 % 10; n[4] = x % 10; for (i = 0; i &lt; 5; i++) { if (n[i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20c614bef017859c81987e77c1c6fa18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2123a483466137a2a62303fd04f54c/" rel="bookmark">
			小波变换实现图像融合 &amp; 原理 代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客 有关小波的几个术语及常见的小波基介绍_jbb0523的博客-CSDN博客_常用小波基
python小波图像融合_koervcor的博客-CSDN博客_python小波图像融合
医学图像处理案例（十四）——基于小波变换的图像融合 - 腾讯云开发者社区-腾讯云 (tencent.com)
图像融合（六）-- 小波融合 - silenceer - 博客园 (cnblogs.com)
常见小波函数：Haar、Daubechies、Biorthogonal、Coiflets、Symlets、Morlet、Mexican Hat、Meyer、Gaus、Dmeyer、ReverseBior、Cgau、Cmor、Fbsp、Shan.
图像融合与小波变换&amp;融合 概述 1、图像融合概述 图像融合（Image Fusion）是指将多源信道所采集到的关于同一目标的图像数据经过图像处理和计算机技术等，最大限度的提取各自信道中的有利信息，最后综合成高质量的图像，以提高图像信息的利用率、改善计算机解译精度和可靠性、提升原始图像的空间分辨率和光谱分辨率，利于监测。
2、小波变换特点介绍 小波变换的固有特性使其在图像处理中有如下优点：
完善的重构能力，保证信号在分解过程中没有信息损失和冗余信息；把图像分解成低频图像和细节（高频）图像的组合，分别代表了图像的不同结构，因此容易提取原始图像的结构信息和细节信息；小波分析提供了与人类视觉系统方向相吻合的选择性图像。 一般图像融合的小波分解采用离散小波变换(Discrete Wavelet Transform, DWT)。DWT的函数基由一个称为母小波或分析小波的单一函数通过膨胀和平移获得。因而，DWT同时具有时域和频域分析能力，与一般的金字塔分解相比，DWT图像分解具有以下优势：
1）具有方向性，在提取图像低频信息的同时，还可获得了水平、垂直和对角三个方向的高频信息；2）通过合理的选择母小波，可使DWT在压缩噪声的同时更有效的提取纹理、边缘等显著信息；3）金字塔分解各尺度之间具有信息的相关性，而DWT在不同尺度上具有更高的独立性。 3、基于小波变换的图像融合 DWT 融合算法基本思想：首先对源图像进行小波变换，然后按照一定规则对变换系数进行合并；最后对合并后的系数进行小波逆变换得到融合图像。
3.1、小波分解原理简介 （1）小波的简单计算原理
[x0，x1，x2，x3]=[90，70，100，70] 为达到压缩 我们可取 (x0+x1)/2 (x0-x1)/2 来代表 x0,x1 这样 [90,70] 可表示为 [80,10] 80即平均数 10是小范围波动数（可想象出一种波的形状） [90,70] --〉[80,10] , [100,70] --〉 [85,15] 可以想象80 和85 都是局部的平均值反映大的总体的状态，是变化相对缓慢的值，可以认为他们是低频部分的值。 而10、15是小范围波动的值局部变换较快，可以认为他们是高频部分的值。
FIRST：把[90,70,100,70] 写成 [80,85,10,15] 即把低频部分写在一起（记频率L） 高频部分写在一起（H) ；SECOND：而[80,85] 又可经同样的变换--&gt; [82.5, -2.5] 这样 82.5表示更低频的信息(记频率LL) -2.5则表示了频率L上的波动； 最后[90,70,100,70] --〉[82.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed2123a483466137a2a62303fd04f54c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6629be45bfde4b2a99c5a08a21f4e108/" rel="bookmark">
			EVE-NG模拟器安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可根据
EVE-NG模拟器教程(一)——安装包下载_看星星的小王子的博客-CSDN博客_eve-ng模拟器
EVE-NG模拟器教程(二)——模拟器安装_看星星的小王子的博客-CSDN博客_eve模拟器
EVE-NG模拟器教程(三)——Lab平台初探_看星星的小王子的博客-CSDN博客_eve-ng
EVE-NG模拟器教程——常用镜像导入和使用_看星星的小王子的博客-CSDN博客_eve-ng模拟器
进行安装，大佬写的很详细，按步骤进行即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e8d7d8be4fa8af3f2b3d5a8dc38ffd8/" rel="bookmark">
			Kubernetes 入门实战（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes 入门实战 Docker下载Docker命令创建自己的镜像文件 - - Dockerfile 目前使用 Docker 基本上有两个选择：Docker Desktop 和 Docker Engine。Desktop目前针对个人是免费的，大企业还是收费的，所以我不会用，也不想用；毕竟，下面一起学的是Engine。
Docker下载 Docker除了在Mac上的M1上兼容不好，其他都可以；我是在debian系统服务器中做的学习整理，大家可以先冲下浪，自我选择下：
首先我们尝试输入命令 docker，会发现
Command 'docker' not found... 下载：
sudo apt install -y docker.io #安装Docker Engine 启动docker服务：
sudo service docker start 当前用户加入docker组（因为操作 Docker 必须要有 root 权限，而直接使用 root 用户不够安全，加入 Docker 用户组是一个比较好的选择，这也是 Docker 官方推荐的做法）
sudo usermod -aG docker ${USER} 检测是否安装成功
docker version 或者输入docker info，查看软硬件的信息。
Docker命令 除了上面的两条命令，主要还有以下命令：
刚刚安装好 Docker 环境，这个时候还没有运行任何容器，所以列表显然是空的
我们可以拉取现有的镜像
docker pull busybox 然后，我们可以看到已拉取的镜像
我们可以运行出我们的docker中的第一行代码：
docker run busybox echo hello world 我们下面从新拉取个ubuntu，并执行一些操作：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e8d7d8be4fa8af3f2b3d5a8dc38ffd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ad523dd43c5f951e2a01bd6b0bb5f84/" rel="bookmark">
			kotlin中常用的高阶函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Kotlin中，高阶函数即指：将函数用作一个函数的参数或者返回值的函数 TODO函数 此函数的作用：显示抛出NotImplementedError错误。NotImplementedError错误类继承至Java中的Error
public class NotImplementedError(message: String = "An operation is not implemented.") : Error(message) //TODO的源码 @kotlin.internal.InlineOnly public inline fun TODO(): Nothing = throw NotImplementedError() @kotlin.internal.InlineOnly public inline fun TODO(reason: String): Nothing = throw NotImplementedError("An operation is not implemented: $reason") //使用 fun main(args: Array&lt;String&gt;) { TODO("测试TODO函数，是否显示抛出错误") } 调用todo，如果不传参的话，就会报An operation is not implemented.
run()函数 run()
其可以运行一个代码块并返回值或者运行一个与其他完全无关的代码块 //源码 public inline fun &lt;R&gt; run(block: () -&gt; R): R { contract { callsInPlace(block, InvocationKind.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ad523dd43c5f951e2a01bd6b0bb5f84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/229298bd92f4bd6ffd7126ef4d833dbf/" rel="bookmark">
			【JavaWeb学习报错集（一）】ReflectionException:There is no getter for property named XXX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习JavaWeb的Mybatis章节时，使用的是Mybatis的Mapper代理开发，在练习时出现了下面这种错误
先介绍下整体代码：（如果很熟悉代码，直接跳到最后看报错原因分析）
利用Mybatis的动态SQL实现单个条件的查询。即实现以下效果。
关键原始代码目录如下：
先给代码贴出来：（主要错误在BrandMapper,xml文件里）
首先是Brand类：
package com.itheima.pojo; /** * 品牌 * * alt + 鼠标左键：整列编辑 * * 在实体类中，基本数据类型建议使用其对应的包装类型 */ public class Brand { // id 主键 private Integer id; // 品牌名称 private String brandName; // 企业名称 private String companyName; // 排序字段 private Integer ordered; // 描述信息 private String description; // 状态：0：禁用 1：启用 private Integer status; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getBrandName() { return brandName; } public void setBrandName(String brandName) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/229298bd92f4bd6ffd7126ef4d833dbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a4295bc4496a96cab16dd3f6520d5ca/" rel="bookmark">
			Ubuntu安装docker与clouddrive
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装docker 1、安装docker：sudo apt-get install -y docker.io
2、启动docker服务：systemctl start docker
3、设置开机启动：systemctl enable docker
4、查看docker状态：systemctl status docker
(输入:q退出)
5、停止docker服务：systemctl stop docker
6、查看docker版本：docker version
参考：https://www.cnblogs.com/javalinux/p/16479832.html
clouddrive 参考：https://blog.csdn.net/wbsu2004/article/details/119831191
1.在 docker 文件夹中，创建一个新文件夹，并将其命名为 clouddrive，然后在 clouddrive 文件夹中再创建两个新的子文件夹，分别命名为 config 和 media
(我是在/var/lib/下找到了docker文件夹，不知道这步有没有用)
2.在 docker 服务中启用 MountFlags
在终端执行以下命令
mkdir -p /etc/systemd/system/docker.service.d/ cat &lt;&lt;EOF &gt; /etc/systemd/system/docker.service.d/clear_mount_propagation_flags.conf [Service] MountFlags=shared EOF 3.在终端执行以下命令：
docker run -d \ --privileged \ --name clouddrive \ --device /dev/fuse:/dev/fuse \ --restart unless-stopped \ -v /volume2/docker/clouddrive:/CloudNAS:shared \ -v /volume2/docker/clouddrive/config:/Config \ -v /volume2/docker/clouddrive/media:/media:shared \ -p 9798:9798 \ cloudnas/clouddrive 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a4295bc4496a96cab16dd3f6520d5ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39b80c6886b6d2998d28e42c8fbffc58/" rel="bookmark">
			特征提取网络之Resnet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1、网络结构2、代码解读resnet50 总结 前言 整理下特征提取网络resnet的网络结构
论文地址：https://arxiv.org/abs/1512.03385
文中所提供的代码来自：https://github.com/open-mmlab/mmclassification
1、网络结构 有5个输出层C1,C2,C3,C4,C5，其中常用的是C2,C3,C4,C5层。没有单独的层进行下采样，直接在残差的时候进行下采样。
2、代码解读 resnet50 整个resnet50的forward代码如下（示例）：
def forward(self, x): """Forward function.""" if self.deep_stem:	# teem层 x = self.stem(x) else: x = self.conv1(x) x = self.norm1(x) x = self.relu(x) x = self.maxpool(x) outs = [] for i, layer_name in enumerate(self.res_layers): res_layer = getattr(self, layer_name)	#获取相应名字的layer层：layer0,layer1... x = res_layer(x)	# 进行操作 if i in self.out_indices:	# 输出索引，指定输出的层数，用于后续的FPN操作。 outs.append(x) return tuple(outs) stem层：用三个3X3卷积（步长为2，padding=1）代替一个7X7卷积（步长为2，padding=3），保持输出特征分辨率不变。conv1层：和stem层一样，图片3维输入，经过一个conv1（7X7卷积后）256维输出，再经过BN和Relu（一般不用stem而是选择用一个7x7卷积），用7x7卷积在大感受野的情况下，保持输出特征分辨率不变。maxpool层：一个3X3的最大池化，步长为2。 self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1) 残差块：主干由三个卷积组成。一个1X1卷积（步长stride为1或2）+BN+Relu+一个3X3卷积+BN+Relu+一个1X1卷积+BN+(残差连接：一个1X1卷积（步长stride为1或2)+Relu。首先通过1X1卷积压缩通道（4倍），然后3X3卷积，1x1卷积还原到原来的维度，最后还有个1X1卷积从输入直接连接到输出，实现残差相加。如果卷积过程中进行下采样（第一个步长！=1）或者通道数要发生变化（输入！=输出）时，残差的1x1卷积的步长变成能够与输出分辨率匹配的大小（如stride=2）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39b80c6886b6d2998d28e42c8fbffc58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f488b18123dfac74892207529d98684/" rel="bookmark">
			Linux 服务的restart和reload
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux操作系统服务管理中，经常会遇到restart和reload。
这两个参数究竟存在什么样的区别呢，现在小编和大家简单的讲一下。
在学习环境下，我们经常使用restart参数重启服务，然而拿到生产环境中也许并不合理。
restart：含义为重新启动，顾名思义就是需要先stop，然后在start。
reload：含义未重新加载，顾名思义就是重新加载（配置）。
我们已sshd服务来简单的说一下：
我们对sshd服务的配置文件进行了修改，现在需要重新加载配置或者说重启
service sshd restart：
如果更改的配置错误，执行这条命令，stop肯定是能成功的；但是start则不能启动；如果设备在很远的机房中，这样无疑给运维工作增加了负担；即使配置没有问题，在启停同时也会导致服务短暂停止。
service sshd reload：
reload表示的是重新加载配置，首先reload不会影响当前服务已经建立的会话，而是直接加载新的配置，当新的会话产生后，会使用新的信息的配置；即使配置文件错误，导致的结果只是配置加载失败，而与所提供的服务无关。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cb67e595cd94474dcf5df05c54dbc73/" rel="bookmark">
			网易云音乐上的所有！全部！随便爬！（Python爬虫&amp;基于网易云音乐评论的用户推荐系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		申明：本文纯属原创，有参考的地方都会在文中给出链接。如有转载，需征求本人同意。
目录
一、目标网站介绍
二、所需工具
三、数据爬取
3.1 环境搭建
3.2 网站分析
3.3 功能特性
3.3 歌单
3.4 歌曲
3.5 歌曲评论
3.6 网易云音乐用户
四、数据分析
4.1 歌单
4.1.1 播放数量最多的TOP20歌单
4.2 网易云用户
4.2.1 数据库简单查询分析
4.2.2 关注者的地区分布
五、文本相似计算原理
5.1 TF-IDF
5.2 Doc2Bow模型
5.3 计算相似度
六、相似用户推荐（Python之Gensim版本）
6.1 Gensim
6.2 数据预处理
6.3 文本预处理
6.4 对训练集进行分词
6.5 提取词典特征数
6.6 构建语料库
6.7 使用TF-IDF模型处理语料库
6.8 将测试集转换为稀疏向量
6.9 相似度计算
七、相似用户推荐（Python之sklearn版本）
7.1 sklearn
7.2 文本预处理
7.3 计算tf-idf值：
八、相似用户推荐(R语言版本)
8.1 读取资料库
8.2 定义数据预处理函数
8.3移除数字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cb67e595cd94474dcf5df05c54dbc73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7e3982913a22c8c81af9b4c5cfff8f8/" rel="bookmark">
			Win7卸载亚信杀毒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亚信杀毒退出或者卸载的时候，会要求输入密码。这也太操蛋了。。。
在网上找到一种方法，通过修改注册表的方式来绕过输入密码，但是在Win7正常模式下无法更改注册表。
接下来记录一下卸载过程：
1、重启，在启动的时候F8，进入安全模式
2、开始 &gt; 运行 输入regedit 打开注册表界面
32位系统：将 HKEY_LOCAL_MACHINE/SOFTWARE/TrendMicro/pcCillinNTCorp/CurrentVersion/Misc中的 Allow Unistall 的键属值改为1即可，这样就可以重启电脑后进行卸载了。64位系统：将 HKEY_LOCAL_MACHINE/SOFTWARE/Wow6432Node/TrendMicro/PC-illinNTcorp/CurrentVersion/Misc/Allow Uninstall 的键属值改为1即可，这样就可以重启电脑后进行卸载了。 如果你不是为了卸载，只是希望在使用过程中可以退出该软件，那么，修改注册表：
32位系统：将 HKEY_LOCAL_MACHINE/SOFTWARE/TrendMicro/PC-cillinNTCorp/CurrentVersion/Misc/NoPwdProtect 键值由0 改为1即可，这样在正常使用过程中，就可以退出该软件，不需要输入密码。
64位系统：将 HKEY_LOCAL_MACHINE/SOFTWARE/Wow6432Node/TrendMicro/PC-illinNTcorp/CurrentVersion/Misc/NoPwdProtect 键值由0 改为1即可，这样在正常使用过程中，就可以退出该软件，不需要输入密码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51dabdb546d91fb2e6b49918822ffdb4/" rel="bookmark">
			Ubuntu16.04没有wifi链接的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍如何解决Ubuntu16.04安装之后没有wifi不能联网的问题。我的Ubuntu打开之后的界面如下所示。(本教程需要你有一个可以联网的电脑，因为需要下载文件。如果实在没有，就是用手机的USB数据线连接到电脑，之后设置中选择USB数据共享，就可以使用手机的数据流量，但是一定要保证你的流量够多。)
按照我的教程操作之后的界面。如下图所示：
1.首先确定自己网卡型号 由于我装的是win10和ubuntu双系统，我可以在win10查看自己的网卡型号。
win10查看网卡型号：右键点击“此电脑”—&gt;点击“管理”—.&gt;点击“设备管理器”—&gt;点击“网络适配器”。我的是“Intel WIFI 6 AX200 160MHZ ”.
2.确定对应网卡的驱动 在这个地址找到你的网卡对应的驱动型号。打开链接之后的界面如下：
我的就是其中的第二个驱动，下载下来。同时我们可以看到其要求的Ubuntu 内核为5.1+，而我的Ubuntu内核为4.15，因此需要升级内核。
3.升级内核 首先使用如下命令查看内核：
uname -r 如果你的内核版本正好符号要求，直接跳到第四部分驱动文件拷贝。如果你的内核版本较低，按照以下步骤升级版本。
Ubuntu内核文件网址，点进去找打你需要升级的版本，共需要下载四个文件。
我的是Ubuntu16.04.
从这里找到你需要的版本点进去。我选择的是5.2.21版本。点进去之后界面如下：
需要下载的四个文件分别是下图的红色箭头：
这些文件下载速度较慢，大家耐心等一下。我自己使用的是5.2.21。
下载之后是4个.deb文件，把文件复制到Ubantu系统（如果你直接使用的流量在Ubantu下载直接找到这些文件就行），之后进入你存放这4个文件的文件夹，右键打开终端。输入如下命令：
sudo dpkg -i *.deb 其中*代表刚才4个文件的名字，你把4个文件的名字分别输入进去就行。4个文件安装完成之后重启电脑，Ubantu会自动应用高版本的内核。此时再使用命令：
uname -r 查看你的内核版本。若符合驱动要求的版本就可以进行下一步。
4.驱动文件 找到你下载的驱动文件，将其中的.ucode后缀的文件转移到 /lib/firmware文件夹下，过程如下：
首先使用 cd 进去你存放4个文件的文件夹。之后使用：
sudo mv A B 其中A代表文件的名字，需要带上后缀。B是目标地址，在本文中是 /lib/firmware
至此，所有过程已经结束，之后重启电脑，就会有WIFI图标了。
5.可能的问题 1.我在安装.deb文件时提醒我没有libssl1.1这个文件，这个可以参考这篇文章。
2.安装过程中还提醒我Possible missing firmware,但是这个文件好像没有影响，升级内核的时候我没有安装这个软件，但是升级内核重启之后，仍然可以使用新的内核。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9579943cb6aebde6ab4dca60707e994d/" rel="bookmark">
			使用gdb调试内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 使用gdb调试内核 内核配置需要添加编译信息。
# 开启kernel debug info Kernel hacking ---&gt; [*] Kernel debugging Compile-time checks and compiler options ---&gt; [*] Compile the kernel with debug info [*] Provide GDB scripts for kernel debuggin # 关闭地址随机化 kernel features ----&gt; [] Randomize the address of the kernel image (KASLR) 建议关闭地址随机化，否则会出现gdb中无法在断点处停下来的情况（尤其是qemu中）。可以参考：https://blog.csdn.net/gatieme/article/details/104266966
在目标板上开启gdbserver模式（虚拟soc中加上gdb调试的选项）；在host上启动gdb客户端后连接虚拟soc提供的gdb服务（终端不会有输出），命令如下：
# 启动gdb，工具链中gdb的路径，并读取符号表 # vmlinux相当于elf文件，具有符号表。Image文件相当于bin文件。 aarch64-linux-gnu-gdb ./linux-5.18/vmlinux # 连接gdb server， 7777 为端口号， tar remote localhost:7777 # 设置断点 b start_kernel # 运行 c 在目标板的串口则会有对应的输出信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9579943cb6aebde6ab4dca60707e994d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6228082f50e3cd09aab274de10761c1d/" rel="bookmark">
			Android View的可见性检查之 getLocalVisibleRect与 getGlobalVisibleRect
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		getGlobalVisibleRect(rect);
是以屏幕左上角为参考系，
判断view有一部分在屏幕中，返回true（没有被父View遮挡）。
反之，如果它全部被父View遮挡住或者本身就是不可见的，返回false。 getLocalVisibleRect(rect);
当View可见时，以自身View左上角为参考系，坐标系的原点为View自己的坐标原点。
当View不可见时，以父控件左上角为参考系，坐标系的原点为View的父控件的坐标原点。 为了更好理解，Demo如下：（测试机分辨率为720*1440，橙红色view为400*400px。布局为一个RelativeLayout嵌套这TextView）
屏幕包含蓝色状态栏！！高度为55px，所以计算的结果要考虑到这个问题
当Textview设置marginLeft="100px"、marginTop="100px"时：
当Textview设置marginLeft="-100px"、marginTop="-100px"时：
当Textview设置marginRight="-100px"、marginBottom="-100px"时：
下面的理解主要针对getLocalVisibleRect(rect),View不可见的情况： 当Textview设置marginTop="-500px"时，此时TextView是在屏幕外的：
此时的getLocalVisibleRect(rect)，坐标系的原点为它的父控件的坐标原点，也就是外面嵌套的RelativeLayout，RelativeLayout的宽高都是match_parent的，所以他的数值跟getGlobalVisibleRect(rect)是相同的。
当Textview设置layout_marginBottom="-500px"，layout_marginRight="-500px"，都在父布局的底部时，此时TextView是在屏幕外的：
高度要考虑底部虚拟导航栏！！高度为55px，所以计算的结果要考虑到这个问题
此时的getLocalVisibleRect(rect)，坐标系的原点为它的父控件的坐标原点，也就是外面嵌套的RelativeLayout，RelativeLayout的宽高都是match_parent的，所以他的数值跟getGlobalVisibleRect(rect)是相同的。
TextView的宽、高为400px， layout_marginBottom="-500px"，layout_marginRight="-500px"，
所以TextView距离屏幕右间距为100px，距离屏幕下间距为100px，
考虑到下部虚拟导航栏高度为55px，所以TextView距离屏幕底部实际距离为（100px-55px）=45px
左面：720+100 =820px
上面：1440+45=1485px
右面：720+100+400 =1220px
下面：1440+45+400 =1885px
判断View1是否在某个View2可视区域内
当使用getLocalVisibleRect(rect)时，当View不在可视区域内时：
在顶部，Rect.top &lt;0
在底部，Rect.bottom&gt;View2.getHeight
所以
fun isCover(activity: Activity, view1: View, view2: View): Boolean {
val rect = Rect()
view1.getLocalVisibleRect(rect)
return !(rect.top&lt;0||rect.bottom&gt;view2.height)
}
判断View可视区域占其自身百分比（当view1开始可视后调用，否则一直都是100%)
fun getVisibilePercent(activity: Activity, view1: View): Int {
val rect = Rect()
view1.getLocalVisibleRect(rect)
Log.e("测试","rect.height ="+rect.height().toString() + " view1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6228082f50e3cd09aab274de10761c1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e05fb905a5d5f6f7cc01590675d33e3c/" rel="bookmark">
			在CentOS 7上给一个网卡分配多个IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CentOS 7上给一个网卡分配多个IP地址 有时你也许想要给一个网卡多个地址。你该怎么做呢？另外买一个网卡来分配地址？在小型网络中其实不用这么做。我们现在可以在CentOS/RHEL 7中给一个网卡分配多个ip地址。想知道怎么做么？好的，跟随我，这并不难。
我在cnaaa.com上购买了云服务器。
首先，让我们找到网卡的IP地址。在我的CentOS 7服务器中，我只使用了一个网卡。
用root特权运行下面的命令：
ip addr 示例输出：
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 08:00:27:80:63:19 brd ff:ff:ff:ff:ff:ff inet 192.168.1.150/24 brd 192.168.1.255 scope global enp0s3 valid_lft forever preferred_lft forever 如上所见，我的网卡名是enp0s3，ip地址是192.168.1.150。
如你所知，网卡的配置文件存储在 /etc/sysconfig/network-scripts/ 目录下。每个网卡的详细内容将会以不同的名字存储，比如ifcfg-enp0s3。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e05fb905a5d5f6f7cc01590675d33e3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57a26b4e29788f88813d217a03fbe37d/" rel="bookmark">
			pytest生成Allure报告以及查看报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装 1、下载Allure
Github地址：https://github.com/allure-framework/allure2/releases
下载完成后解压到本地，并把bin目录添加到环境变量：
cmd下输入：allure --version，能正常获取说明allure环境变量配置成功。
2、安装Allure Pytest Plugin
allure-pytest是Pytest的一个插件，通过它我们可以生成Allure所需要的用于生成测试报告的数据。安装allure-pytest插件方法：
pip install allure-pytest 二、使用 1、pycharm 中，运行命令并生成allure测试报告：
if __name__ == '__main__': # 执行测试用例生成测试数据，如果已经存在报告，那就先清空，然后再生成新的测试报告，使用命令： --clean-alluredir pytest.main([ '-vs','test.py','--clean-alluredir', '--alluredir', './allure-results']) --alluredir参数的作用是指出生成的报告文件夹， allure-results下放着生成报告的文件： 2、通过下面的命令将./allure-results/目录下的测试数据生成测试报告页面：
os.system('allure generate ./allure-results -o ./reports --clean') 三、查看报告 直接在pycharm中右击allure报告中的index.html，使用如下图方式打开，是没有问题的，可以正常显示报告内容
但是如果直接是不通过pycharm，而是直接到report文件夹下, 双击打开index.html文件，打开的报告无法展示数据，显示loading：
其实在allure-report下index.html文件是不能直接打开的，出现页面都是loading的情况，这是因为直接allure报告用浏览器是打不开的，需要用allure命令渲染之后打开才能展示效果（allure常识）。
allure使用了两种方式来渲染页面。分别是 allure open 和 allure serve。前者用于在本地渲染和查看结果，后者用于在本地渲染后对外展示结果。这里使用allure open。运行命令：
#查看测试报告 os.system("allure open ./reports") 即可自动打开浏览器展示渲染好的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e6da82100c55ac98eef5bd5ea9dd59/" rel="bookmark">
			Linux安装最新版Docker完整教程（建议收藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux安装最新版Docker完整教程 一、安装前准备工作 1.1 查看服务器系统版本以及内核版本 cat /etc/redhat-release 1.2 查看服务器内核版本 uname -r 这里我们使用的是CentOS 7.4 系统，内核版本为3.10
1.3 安装依赖包 yum install -y yum-utils device-mapper-persistent-data lvm2 1.4 设置阿里云镜像源 yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 二、安装Docker 2.1 Docker版本说明 Docker从17.03版本之后分为两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。 企业版包含了一些收费服务，个人开发者一般用不到，所以我们只需要安装社区版docker-ce版本即可。 2.2 docker-ce安装 yum install -y docker-ce 2.3 启动docker并设置开机自启 #启动docker命令 systemctl start docker #设置开机自启命令 systemctl enable docker #查看docker版本命令 docker version 三、Docker基本概念介绍 3.1 仓库 (repository) docker仓库是用来保存镜像的地方。镜像构建完成后，可以直接在当前宿主机上运行，但是如果需要在其它服务器上使用这个镜像， 就需要一个集中存储、分发镜像的服务，docker仓库就是这样的一个服务。 3.2 镜像(Image) 这里面保存了应用和需要的依赖环境，比如运行的runtime和webapp等。 为什么需要多个镜像？当开发、构建和运行容器化应用程序时，我们通常会有不同优先级。通过为这些独立的任务提供不同镜像 3.3 容器(Container) 镜像的实例。一个容器代表一个正在运行的应用程序、进程或服务。它由 Docker 镜像、执行环境和标准指令集组成。需要扩展服务时，才 真正将镜像跑起来的东西，镜像在容器里面。可以看作是一个完全隔离的盒子。一个容器镜像实例代表一个独立的进程。 四、Docker常用命令 docker search --镜像名 搜索仓库镜像 docker pull --镜像名 拉取镜像 docker ps 查看目前正在运行的所有容器 （-a 显示包括已经停止的容器） docker rmi image_id/image_name 删除镜像 docker build 使用Dockerfile创建镜像 docker run 运行容器 docker exec 进入容器中执行命令 （例如:docker exec -it container_id/container_name /bin/bash） docker logs container_id/container_name 查看容器日志（例如:docker logs -f -t --tail 10 container_id ） docker start container_id/container_name 启动容器 docker restart container_id/container_name 重启容器 docker stop container_id/container_name 停止容器 docker rm container_id/container_name 删除容器（只能删除已停止的容器） 更多的命令可以通过docker help命令来查看。 五、安装Docker可视化管理工具Portainer 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43e6da82100c55ac98eef5bd5ea9dd59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34315f1743664450352006016246707/" rel="bookmark">
			常见的js面试题之递归算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		递归深拷贝 function deepClone(obj){ let newObj = {} for (const key in obj) { if (typeof key === 'Object') { newObj[key] = deepClone(key) } else { newObj[key] = obj[key] } } return newObj } 递归求累加和 function sum(num){ if (num===1) return 1 return num + sum(num-1) } 递归求n的阶乘 function factorial(num) { if(num===1) return 1 return num * factorial(num-1) } 递归斐波那契数列 function fibonacci(num) { if(num === 1 || num === 2) return 1 return fibonacci(num - 1) + fibonacci(num - 2) } 递归数组扁平化 function cusFlat(array) { const res = [] function flatCus(params) { params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b34315f1743664450352006016246707/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6db79b0a4298b545f3034348f8caf15/" rel="bookmark">
			LayerDropout方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：
一种结构化的dropout形式，它在训练过程中具有正则化效果，并允许在推理时有效地剪枝。
方法的核心是在训练过程中，通过随机丢弃模型权重，从大模型中抽取小的子网络，如Dropout或Dropconnect，这具有使网络对后续剪枝具有鲁棒性的优点 。
贡献：
•LayerDrop使非常深的transformer正则化并稳定其训练，从而在各种基准测试中获得最先进的性能。
•可以在测试时从一个预先训练的大模型中自动提取任何深度的小而有效的模型，而不需要进行精细调整。
•LayerDrop易于实现。
在BART模型上实现的代码：
for idx, decoder_layer in enumerate(self.layers): # add LayerDrop (see https://arxiv.org/abs/1909.11556 for description) if output_hidden_states: all_hidden_states += (hidden_states,) dropout_probability = random.uniform(0, 1) if self.training and (dropout_probability &lt; self.layerdrop): continue past_key_value = past_key_values[idx] if past_key_values is not None else None if getattr(self.config, "gradient_checkpointing", False) and self.training: if use_cache: logger.warning( "`use_cache=True` is incompatible with `config.gradient_checkpointing=True`. Setting " "`use_cache=False`..." ) use_cache = False def create_custom_forward(module): def custom_forward(*inputs): # None for past_key_value return module(*inputs, output_attentions, use_cache) return custom_forward layer_outputs = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6db79b0a4298b545f3034348f8caf15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ca7fbe67c23b55371c0694f66fa9b6d/" rel="bookmark">
			（已解决）传值问题：前端发送请求后，后端接收的参数多了“=”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景 框架：使用 SpringBoot + Vue框架，前端传值引用axios。
在前端vue文件中，使用axios进行传值（Post请求）,传值格式如下。
axios({ method: 'POST', url: 'Demo/DemoMethod',// 假设请求为Demo，不写端口了。 data: this.c_param // 本次传输的参数 }) 在后端的Controller层中，接收请求的方法如下。
@CrossOrigin @PostMapping("DemoMethod") public String DemoMethod(@RequestBody String c_param){ System.out.println(c_param); } 问题描述 根据以上的场景，前端请求后，后端接收到的参数多了1个=。
前端传输参数（this.c_param）： 12138
后端接收参数（c_param）： 12138=
原因分析 后端接收 context-type：application/json。
前端axios的POST请求默认 context-type：application/x-www-form-urlencoded。
因此双方的格式不同！
前端axios的POST请求默认是以键值对形式传递，前端内容是存储在key中，value为空。
后端获取数据的时候，value为空，内容就变成了key=。
application/json
JSON格式提交的一种识别方式。在请求头里标示。以JSON字符串的格式请求。 application/x-www-form-urlencoded
form表单提交的时候的表示方式。浏览器默认请求，数据是jquery的Ajax请求的默认方式。这种方式的好处是浏览器都支持，在请求过程中会对数据进行序列化，以键值对的形式key1=value1&amp;key2=value2。 解决方案：5种 方案一：因为双方的context-type不同导致的，让前端声明context-type类型与后端相同即可。
基于上方的发生场景进行修改，修改位置axios前端发送请求处。 （可以对照着查看哪里修改）
axios({ method: 'POST', url: 'Demo/DemoMethod', contentType: 'application/json', // 声明本次请求的数据类型 data:this.c_param }) 方案二：因为使用axios的data进行传值，导致多出“=”。可以选择在请求中传值。
基于上方的发生场景进行修改，修改位置后端接收请求处、前端请求处。 （可以对照着查看哪里修改）
axios({ method: 'POST', url: 'Demo/DemoMethod/' + this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ca7fbe67c23b55371c0694f66fa9b6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eabfffbaaf999c91dfda1a8ce25630e0/" rel="bookmark">
			Wpa_supplicant 调试故障原因分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Wpa_supplicant 调试故障原因分析
1.没有在后台运行的错误
Failed to connect to non-global ctrl_ifname: (nil) error: No such file or directory
解决办法：
让 wpa_supplicant 运行在后台，例如：
nohup wpa_supplicant -c wpa.conf &gt; /tmp/wpa_supplicant.log &amp;
2.传参有问题
Failed to connect to non-global ctrl_ifname: wlan0 error: No such file or directory
解决方法：-i指定的参数所在的设备名错误，可以通过ifconfig查看以后自行改正，一般是因为没有正确的网卡驱动。
3.服务多开导致的问题
ctrl_iface exists and seems to be in use - cannot override it
Delete ‘/var/run/wpa_supplicant/wlo1’ manually if it is not used anymore
Failed to initialize control interface ‘/var/run/wpa_supplicant’.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eabfffbaaf999c91dfda1a8ce25630e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/380704aa445244a40434bfca86dd4b7e/" rel="bookmark">
			Source Insight 4.0 常用设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.SI 简介2.常用设置参考文献 本文以 Source Insight 4.00.0086 版本为例讲解常用设置。
1.SI 简介 Source Insight 是一个面向软件开发的代码编辑器和浏览器，它拥有内置的对 C/C++, C# 和 Java 等源码的分析，创建并动态维护符号数据库，并自动显示有用的上下文信息。
Source Insight 不开源，官网下载需要购买激活码，但网上有破解版本可以下载，见 Source Insight 4 破解笔记（完美破解）。相对于其它主流的开源代码编辑器（Notepad++、Sublime Text、Emacs、Vim 等），因为 Source Insight 能自动创建并维护它自己高性能的符号数据库，包括函数、变量、类、结构体和工程源文件里定义的其它类型的符号，能够快速地对源代码进行导航，提高开发人员浏览和编辑代码的效率。
由于 Source Insight 的高效，致使我从 Notepad++ 转为使用 Source Insight。一开始可能会不习惯，但习惯后，你会对它爱不释手。
2.常用设置 显示代码行号 Options -&gt; File Type Options... -&gt; Editing Options -&gt; 勾选 Show line numbers # 或 Options -&gt; Preferences... -&gt; Languages -&gt; File Type... -&gt; Editing Options -&gt; 勾选 Show line numbers 选中单词后自动高亮 Options-&gt;File Type Options.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/380704aa445244a40434bfca86dd4b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cfd12446c4fbb9ee2c1280e5909534c/" rel="bookmark">
			又是一年1024
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		兄弟们我又来领1024勋章了，经过了3年粉丝达到了1024，在这里感谢大家地关注和支持！
明年就要毕业了，希望能够找到一个理想的工作！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c2d6e091bc0568e4e6df501b3d214ad/" rel="bookmark">
			panda3d虚幻引擎--（3）（这一篇作为补充说明，可跳过）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言（阿巴阿巴）
奇奇怪怪的东西
1.导入配置文件
2.全局对象
前言（阿巴阿巴） 前几天无意间看到了一个叫做panda3d的东西，觉得挺好玩，就翻教程，发现现在中文教程似乎没有那么全面成体系，大部分都是复制粘贴过来官网的实例然后就发布出去了，看得云里雾里的，所以我决定自己去摸索一下这个panda3d，学panda3d的小伙伴中间肯定遇到过很多坑，也有过很多不理解的地方，不过没关系，来瞅瞅我的这个panda3d教程，给你个比较全面的讲解。 我整了个QQ群，180962166，有不会的进来问就行（如果我会的话） 好了，正式开始。 奇奇怪怪的东西 1.导入配置文件 之前咱们调节了一下窗口大小，用的WindowProperties这个东西，这节讲解一下其他的属性配置，
新建一个目录config，然后新建一个叫做conf.prc的文件
然后往conf.prc里写点东西
嗯~这两句里第一个是窗口大小，第二个是窗口名字，没啥好说的，然后这个conf.prc文件就完成了，放一边不管它了，然后在你的代码文件里写上一句这个
from panda3d.core import loadPrcFile 代码如下
from direct.showbase.ShowBase import ShowBase #################################################### from panda3d.core import loadPrcFile loadPrcFile('config/conf.prc') #################################################### class MyGame(ShowBase): def __init__(self): super().__init__() game = MyGame() game.run() 然后运行一下，已经生效了
别的属性也可以写进来，当然后面会慢慢说。
上面是第一种导入方式，需要写个外部文件来导入，还有一种方式是直接在代码里写配置文件，不需要额外创建一个prc文件。
第二种是直接在代码里添加刚才的语句，就像下面这样
from direct.showbase.ShowBase import ShowBase ################################################# from panda3d.core import loadPrcFileData confVars = """ win-size 1280 960 window-title My Game """ loadPrcFileData("", confVars) ################################################# class MyGame(ShowBase): def __init__(self): super().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c2d6e091bc0568e4e6df501b3d214ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78318dd0d0959d2ee4eeb715bfbe4218/" rel="bookmark">
			【实战】元数据管理落地实施
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是谁，我从哪里来，我要到哪里去，我会做什么，我能做什么？我时常反思这些问题，才不至于在快速发展的社会中迷失。
作为数据从业者，我们也需要探查数据的本质，并对其进行追踪、登记、管理，才不至于在海量数据中迷失。
今天这篇文章将会详细介绍描述数据的数据：元数据，并给出具体的落地实施方案。
获取本文PDF版与高清思维导图，请于文章末尾添加作者微信
一、元数据是什么 1、定义： 描述数据的数据，本质上还是数据。
2、解读： 数据本身带有的技术属性与其在业务运行中的业务属性，我们称其为元数据，例如：表数据量、占用空间、字段信息、业务描述、负责人、优先级等。
3、作用： 元数据通过全局统一的数据描述信息及系统化管理，统一数据标准，促进数据集成和共享，打通企业内部数据孤岛，提升数据管理和应用效率。
二、元数据的组成 元数据的边界范围及其划分方式，尚未有统一标准。
以下内容仅代表目前我方团队总结的最佳实践，求同存异，欢迎讨论。
目前常见元数据分类包括：技术元数据、业务元数据、操作元数据、管理元数据、行为元数据、运营元数据、服务元数据。
每个分类下面还有繁多的属性，但是究其本质，我们可以将元数据根据属性来源划分为两类：
1、数据本身的特定属性，为技术元数据。
2、业务赋予的可变属性，为业务元数据。
1、技术元数据 不可手动编辑，自动获取
主要服务于开发人员，帮助明确数据存储、结构、权限等信息，为数据开发和系统集成奠定基础。
服务于业务人员，通过数据血缘理清数据关系，定位业务流程，辅助业务开展。
技术属性主要包括以下几类信息：
1）基础信息
表的schema信息以及字段信息等，包含以下字段：
库名称、库类型、表名称、表数量、表注释、表分区字段、表分区数量、字段名称、字段类型、字段长度、字段注释、字段默认值、主键信息、外键信息、索引信息等。
2）存储信息
本地存储中的文件信息，包含以下字段：
文件路径、文件数量、文件大小、文件类型，压缩格式等。
3）调度信息
离线与实时任务中的信息，包含以下字段：
任务名称、任务类型、任务路径、调度时间、调度SQL、调度逻辑等。
4）血缘信息
数据加工、流转过程产生的数据与数据之间的关系，包含以下内容：
数据节点、流出节点、中间节点、流入节点、节点属性等。
2、业务元数据 业务赋予，手动登记
通过明确业务属性，统一数据的业务含义，保持团队认知一致，进而为数据分析和应用更好的提供支撑。
业务元数据包括以下几类信息：
1）业务信息
业务描述、业务部门、业务系统、负责人等。
2）标准化信息 用于统一认知，消除歧义，包含以下字段：
指标名称、指标层级、指标口径、维度信息、计算方式、映射信息、转换规则等。
3）数据质量信息
针对当前数据进行的质量监控内容，包含以下字段：
质量监控名称、监控内容、监控级别、监控规则、告警方式等。
4）权限信息 访问权限、角色权限、用户权限、安全等级等。
5）服务信息 当前数据对外提供服务的方式，包含以下字段：
服务方式（接口、报表、sdk等）、服务内容、接口信息、负责人等
我方团队并不认可将数据变更记录、任务执行日志等纳入元数据的范围。
元数据只应包含属性信息，不包含行为记录。
三、我们为什么需要元数据 1、数据定位模糊，理解困难 数据开发过程中，我们常常会迷失在底层海量数据中，无法快速定位目前所需数据。
定位到数据后，还需花费大量时间理解当前数据，理解渠道包括但不限于：询问同事、查看数据详情、查询数据权限、查看底层存储、定位影响分析等。
综上所述，在使用数据时，我们往往需要花费大量时间去定位并理解当前数据。
2、数据管理能力低下 数据管理能力是企业实现数据资产化的重要前提。
业务快速发展，数据量成指数级递增。与此同时却没有一个有效的管理手段，数据散落在各地，存储成本与使用成本上升，导致企业数字化转型、数据化运营无法顺利开展。
3、数据孤岛，各自为战，标准不一 数据部门的职责之一是汇集各方数据，进行集中管理。
在此过程会发现各来源方的数据标准不一，规则混乱，且存在重复建设。部门间互相割裂，都有对数据独到的理解与使用，此时数据孤岛便产生了。
出现此情况的原因在于部门间各自为战，缺少统一的元数据管理对数据标准，业务含义等进行同步，从而统一认知，避免数据孤岛的出现。
数据孤岛也称为数据烟囱，可无论是“烟囱”还是“孤岛”，总要有“破局”的时候。
4、集成度低，东奔西跑 开发过程中，我们需要切换各个开发工具之间进行数据查看与操作。例如通过数据库工具提交SQL操作，通过AirFlow进行任务调度，通过Kafka进行管道操作等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78318dd0d0959d2ee4eeb715bfbe4218/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61ff9ea83e40d2650bb9d130b7ae74a8/" rel="bookmark">
			MySQL百万级数据的插入，哪些方面对效率有影响？jdbc相对mybatis又能快多少？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0. start1. 事务的影响2. 数据插入方式3. 连接参数4. MySQL配置5. 一些说明 0. start MySQL百万级数据的插入，哪些方面对效率有影响。
从事务、数据插入方式、连接、mysql配置等方面看一看。
一条数据，允许的最大值是多少？
1. 事务的影响 事务提交对效率是有影响的。 // 10W条数据，循环单条插入，自动提交事务（10W次事务提交）与 只提交一次事务的差别 - 自动提交事务：执行test1，耗时 5869423 。 - 提交 10次事务：执行test2（改），耗时 37053 。 - 提交一次事务：执行test2，耗时 32990 。 // 时间相差不少，事务提交对效率是有影响的。 2. 数据插入方式 批量插入是能极大提高数据插入效率的。 // 10W条数据，循环单条插入（自动提交事务），批量插入（自动提交事务）的差别 - 单条插入（自动提交事务）：执行test1，耗时 5869423 。 - 批量插入（自动提交事务）：执行test3，耗时 5715297 。 - 单条插入（提交一次事务）：执行test2，耗时 35555 。 - 批量插入（提交一次事务）：执行test4，耗时 36272 。 // 时间相差不多，批量处理提高不了效率吗？ 当然不是，批量处理语句是真的。 // 只是做了单条插入的事，一条一条地发给MySQL数据库，批处理没起作用。批处理还需要配置连接参数才能生效。 3. 连接参数 连接参数也对插入效率有很大影响，url上加 ‘rewriteBatchedStatements=true’ 批量处理才会生效。
// url上加个允许批量处理的参数：rewriteBatchedStatements=true - 批量处理（加参数前，提交一次事务）：执行test4，10W条数据，耗时 36272 。 - 批量处理（加参数后，提交一次事务）：执行test4，10W条数据，耗时 10466 。 // 很明显加上允许批量处理的参数后，批量处理的效率提高了不少。 代码中已经用了预编译，再个允许预编译的参数‘useServerPrepStmts=true’会不会更快。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61ff9ea83e40d2650bb9d130b7ae74a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1a845efcb94605d294c9446d124c583/" rel="bookmark">
			【python】常见的正则表达式用法；匹配字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅仅展现了python正则表达式中的一小部分内容，但是包含了实际应用中非常被频繁使用的例子，本文重在举例，即不需要相关语法知识就能够会用~
目录 re.match()re.findall()匹配两个字符串之间的字符串并返回匹配某字符串之前/之后的所有字符串提取数字提取所有数字（包括小数）提取形如“字符串+数字”中的数字 re.match() re.match() 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。
参数
pattern：匹配的正则表达式string：要匹配的字符串。flags：标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 我们可以使用group(num) 或groups()匹配对象函数来获取匹配表达式。
用span来获取匹配到的位置
import re print(re.match('www', 'www.runoob.com').span()) # 在起始位置匹配 用span来获取匹配到的位置 print(re.match('com', 'www.runoob.com')) # 不在起始位置匹配 out：
(0, 3) None 再来看一下group的作用：
re.findall() 注意： match 和 search 是匹配一次 findall 匹配所有。
匹配两个字符串之间的字符串并返回 # 这种有两种方法 # 连同匹配条件（前后的字符串）一起返回 re.findall('prop.*?no', 'seed0prop0.2no1.pickle') # 只返回中间字符串的内容 re.findall("prop(.*)no", 'seed0prop0.2no1.pickle') out：
匹配某字符串之前/之后的所有字符串 # 这种有两种方法 # 返回prop之后的所有字符 re.findall('prop(.*)', 'seed0prop0.2no1.pickle') # 返回prop之前的所有字符 re.findall("(.*)prop", 'seed0prop0.2no1.pickle') out：
提取数字 提取所有数字（包括小数） string = "Purchase100-0.76-0.63" re.findall(r"\d+\.?\d*",string) out：
['100', '0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1a845efcb94605d294c9446d124c583/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccdf839640c8d26271803e76ba1f4c0e/" rel="bookmark">
			Linux实操篇④ （Linux常用指令大全：找回、重置root密码；实用指令、指定运行级别；帮助类man、help 指令，文件目录类 指令，日期时间类 指令，搜索查找类 指令，压缩和解压类 指令）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第八章 实用指令
8.1 指定运行级别
8.1.1 基本介绍
8.1.2 应用案例
8.1.3 指定默认的运行级别
8.2 找回root密码
8.2.1 面试题
8.3 帮助类 指令
8.3.1 man 获得帮助信息
8.3.2 help 指令
8.4 文件目录类 指令
8.4.1 pwd 指令 8.4.2 ls 指令 8.4.3 cd 指令 8.4.4 mkdir指令
8.4.5 rmdir 指令
8.4.6 touch 指令
8.4.7 cp 指令
8.4.8 rm 指令 8.4.9 mv 指令
8.4.10 cat 指令 8.4.11 more 指令 8.4.12 less 指令
8.4.13 echo 指令
8.4.14 head 指令
8.4.15 tail 指令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccdf839640c8d26271803e76ba1f4c0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e8d0a25a274b45fd0653153ccc8620c/" rel="bookmark">
			Vue3 学习笔记 —— 父子组件传值、插槽、提供/注入、兄弟组件传值、mitt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 父子组件传值
1.1 父组件给子组件传值 —— v-bind
1.2 子组件接收父组件的传值 —— defineProps
1.3 设置子组件接受参数的默认值 —— withDefaults
1.4 子组件给父组件传参（派发事件） —— defineEmits
1.5 子组件暴露给父组件内部属性 —— defineExpose
2. 插槽
2.1 什么是插槽
2.2 匿名插槽、具名插槽
2.3 作用域插槽
2.4 动态插槽
3. 提供/注入
3.1 提供/注入是什么
3.2 父组件暴露（提供）数据
3.2.1 provide 基本用法
3.2.2 provide 源码解析
3.3 子组件接收（注入）数据
3.3.1 inject 基本用法
3.3.2 inject 源码解析
4. 兄弟组件传值
4.1 EventBus 原理
4.1.1 使用 ts 实现一个简单的 EventBus
4.1.2 使用 4.1.1 的 EventBus
4.2 Mitt
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e8d0a25a274b45fd0653153ccc8620c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a26eb594362fa81d488c9d59856ed425/" rel="bookmark">
			Termux一些看起来很酷的事——无聊专区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无聊且有趣的，累了就停下来休息会儿吧 如果你还不想休息，点此进入正题。 1.cmatrix 《黑客帝国》的代码雨视觉特效。
不知道有多少男孩怀着伟大程序员的梦想，最终却做成了悲催程序猿。这个特效，是否唤起你被灰尘掩盖的青春梦想？
pkg install cmatrix cmatrix 2.cowsay cowsay 命令是一个有趣的命令，它会用 ASCII 字符描绘牛，羊和许多其他动物，还可以附带上个自定义文本，简单说就是对话气泡效果，安装：
pkg intall cowsay 使用：
cowsay -f &lt;动物&gt; &lt;内容&gt; 内置动物有：
其中绿框给出的是cowsay图案文件路径，语法很简单，有兴趣的可以自己写个图案（别看我，我没兴趣哦，嘿嘿嘿~）
来个简简单单的示例：
cowsay -f eyes '小黑子，露出鸡脚了吧' 再来张自己做的ASCII图案：
3.sl 据传说某位程序大牛经常将ls命令敲成sl，为了自嘲写了这么一个神级小程序，每每输入ls就会有一列火车呼啸而过，呜~ 呜~ 呜~
话说，可以修改成一万头草泥马呢?
pkg install sl sl 4.figlet 简单实用工具，用于创建ASCII logo，内置多种样式，比如我修改启动问候语的Termux logo就是在此生成的。
pkg install figlet figlet -f &lt;样式&gt; 文本内容 内置样式有：
默认样式演示：
然后，组合搭配，或许可以做出更好玩的：
watch -n 1 "date +%D%n%T | figlet" 5.tiolet 名字，是不是看着和上边的figlet神似呢？toilet 能用字母拼写出更大字母的工具，具体拼出什么字由命令后面的参数决定，不仅如此，它还能打印出各种风格的效果，比如彩色，金属光泽等。
pkg install toilet toilet -f &lt;字体&gt; -F &lt;风格&gt; &lt;文本信息&gt; 内置字体：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a26eb594362fa81d488c9d59856ed425/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61acc2ba0dccc41721f89205642007e7/" rel="bookmark">
			Verilog基本语法之模块以及模块调用详解（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模块结构 一、模块结构组成 模块由三个元素组成，分别是模块起始、接口说明、逻辑功能描述 1. 模块起始：每个模块都要进行端口定义，格式为：module 模块名(端口1, 端口2, 端口3)， 2. I/O接口说明：input输出，output输出，inoutput双向接口 3. 逻辑功能描述：always、assign等功能描述。 二、模块详解 组合成为完整程序如下： module &lt;模块名&gt; (&lt;端口列表&gt;) &lt;I/O接口说明&gt; &lt;内部信号声明&gt; &lt;逻辑功能定义&gt; Endmodule 拿与门、或门举例： module AndOR(a, b, c)//模块起 input a,b;//接口方向为输入 output c,d; assign c = a &amp; b;//组合逻辑-与 assign d = a | b;//组合逻辑-非 endmodule //模块终 注意：每条逻辑功能语句和数据定义的最后必须有分号。
程序模块----&gt;&gt;&gt;到电路模块
注意
Verilog模块中的过程块（initial/always）、模块调用、assign赋值间是并行的
连续赋值语句不能独立于always块存在；
能独立存在的只有assign赋值，以及模块调用；
**
二、模块调用 **
模块调用包括元件库的调用以及已设计模块的调用，设计模块调用如下
1.模块例化有两种方法：按位置顺序调用、按名词调用
1.位置相关：
1）例化时，例化的参数顺序必须和模块顺序一致 2）例化时，只要写端口名字 2.名称相关：
1）必须指定当前例化的端口名称 2）端口的顺序可以自由排序 位置相关举例：
wire [3:0] x1; wire [3:0] x2; wire [4:0] x3; add add_inst0 ( x1, //对应 模块本身的a，顺序必须一一对应 x2, //对应 模块本身的b x3 //对应 模块本身的c ); 名称相关举例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61acc2ba0dccc41721f89205642007e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9c6e00d50eae8fc5b5b8dc603208bae/" rel="bookmark">
			Maven 镜像设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven 镜像设置 Eclipse1、首先我 Eclipse 自带的 Maven 没有什么 setting.xml2、添加依赖 Idea设置 maven 配置文件位置打开 maven 设置文件添加阿里云在项目`POM`中设置仓库 依赖搜索 虽然项目中一直使 Maven 但是从接手到现在，都没动过它。完全是之前配置好的。 然而用的官方的软件仓库，那个速度实再让人求生不能。趁着放假在家，还是折腾一下吧。
这么明显的问题，肯定早就已经案例满地了。肯定拿来就用嘛。于是上网找了个，发现对于新手来说，还是有坑的。
Eclipse 1、首先我 Eclipse 自带的 Maven 没有什么 setting.xml C:\Users\jerry\.m2\settings.xml 这个位置是空的。
要自己手动创建它，再打开就会看到多个了 open file 了
然后打开，把 阿里爸爸的配置粘进去，保存。然后记得点一下边上的 Update Settings 按钮
&lt;settings xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;/settings&gt; 如果有兴趣，还可以把 本地的 C:\Users\{user}\.m2\repository 目录换一下，毕竟放到 C 盘不太安心。
&lt;localRepository&gt;E:\Develop\repository&lt;/localRepository&gt; 然后保存，你会发现，原来乌龟爬的速度，变成一瞬间就更新完了。我靠，我还以为是幻觉呢~~~不过倒回来想想，那么小的文件，这速度才是正常的嘛。
2、添加依赖 说官方仓库 mvnrepository搜下速度慢，但是搜下 Jar 包，以及XML片段还是很方便的。
以 org.apache.ibatis.io.Resources 这个类为例。
首先要知道它在哪个Jar包，用 findjar 搜。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9c6e00d50eae8fc5b5b8dc603208bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ca0c986dee258cbd40d6dd66dcacd7/" rel="bookmark">
			常见状态码错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 状态码 响应状态码可以很方便的查看我们的响应状态，我们可以检测响应状态码：
200 ：请求正常，服务器正常的返回数据。301 ：永久重定向。比如在访问www.jingdong.com 的时候会重定向到www.jd.com 。302 ：临时重定向。比如在访问一个需要登录的页面的时候，而此时没有登录，那么就会重定向
到登录页面。400 ：请求的url 在服务器上找不到。换句话说就是请求url 错误。403 ：服务器拒绝访问，权限不够。500 ：服务器内部错误。可能是服务器出现bug 了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08d3f8676e8506e489769db1a77ac86d/" rel="bookmark">
			gRPC 实操指南（golang）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 RPC(Remote Procedure Call Protocol) 1.1 什么是RPC RPC即远程调用协议，简单来说就是调用远程的函数。
正常单机开发的情况下，我们通过函数的方式实现部分功能的解耦
func sum(num1,num2 int) int { return num1 + num2 } 如上是一个最简单的求和函数，我们只需要调用函数就可以实现求和的功能。
但大部分时候函数不会这么简单，尤其对于非单机的分布式系统，远程调用就尤为重要。
1.2 RPC业务场景 RPC的应用场景很广泛：
•所有的分布式机都需要进行登陆的验证，对于所有的主机都实现相同的登陆验证逻辑维护极差，同时也失去部分分布式意义，所以从解耦的角度考虑，我们需要定义一个统一的登陆验证业务来做。•C/S架构的传输业务，如股票软件，每天需要用户登陆的时候去服务器拉取最新的数据，或者较简单的文件传输业务，登陆验证业务，证书业务都可以使用rpc的方式•跨语言开发的项目，比如web业务使用golang进行开发，底层使用cpp或c，部分脚本使用py，跨语言通信可以通过RPC提供的不同语言的开发机制进行实现。
因而实际上，RPC就是一个远程的函数，只不过RPC协议做的就是把整个过程透明化，以使得从开发角度来看，和本地函数调用没有区别。
1.3 主流RPC框架 目前主流的RPC，有ali的Dubbo，还有google的gRPC（本文主题）等
一般RPC框架如下所示：
•客户端：客户端作为整个RPC业务的发起者，如上所说的股票软件，需要客户端主动发起请求去拉取最新的股票数据。•服务端：服务端接受客户端的请求，并做出相应的回应。简单来说，函数实体在服务端，数据处理在服务端。
服务端和客户端是每个RPC框架，开发者可见度最高的部分，实现RPC业务的重点就在于对C/S的设计和理解。首先，客户端一定是率先发起请求的部分，服务端一定是具体处理请求的部分。比如之前我们说的求和函数，函数主体一定是在服务端，客户端有两个数字num1，num2，向服务端发起RPC远程调用，并最后拿到求和结果。
分清C/S很重要！！！！！
•客户端stub，服务端stub，可以变相的理解为应用层。主要是对客户端的rpc调用和服务端的返回进行序列化和反序列化，并进行传输，即把rpc业务抽象成tcp socket的send和receive。（gRPC使用的就是tcp，http2.0协议，建立在传输层）
2 gRPC 2.1 什么是gRPC gRPC是google的开源RPC框架，引用官网的一句话
A high-performance, open-source universal RPC framework 如图，展示了gRPC跨语言开发的结构图，本文将描述golang使用grpc的过程。
严格来说，grpc通过tcp进行通信，使用http2.0协议，同时使用protobuf定义接口，因而相对于传统的restful api来说，速度更快，数据更小，接口要求更严谨。（protobuf此处不做详细介绍，Google Protobuf[1]）
2.2 四种gRPC服务类型 准确来说不应称为四种，实际上是因为rpc入参和出参都可实现流式或非流式，进而排列组合形成四种常用的gRPC模式。
•简单RPC
即客户端发起一次请求，服务端进行响应（类似restful api）。这种模式下，rpc调用和本地函数基本相同，常常用于登陆验证，握手协议，简单业务等。
•客户端流RPC
即客户端流式发送请求，有序发送很多req包（如文件流上传），server接收到所有的req包后会检测到EOF，回发一个res并关闭连接。比如云计算应用，客户端传输众多基础数据，等待服务端计算完成并返回结果。
•服务端流RPC
即客户端发起一次请求，服务端会发很多res包（如文件流下载），server发送完成后关闭连接。常用于数据的拉取，如请求大量数据，无法及时进行反馈，进而通过流式进行反馈。
•双端流RPC
即双方对话，可以实现一问一答，一问多答，多问一答等，常用于聊天室等及时通讯业务。
3 gRPC实操 3.1 环境配置 3.1.1 首先使用go get获取grpc的官方软件包 go get google.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08d3f8676e8506e489769db1a77ac86d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca43d76e2cc2bbae9c50b1efcb2f689/" rel="bookmark">
			Docker安装cloudreve云盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker安装cloudreve云盘 1 参考文档 # 参考网址 https://cloudreve.org/ # 非Docker安装 https://docs.cloudreve.org/getting-started/install 2 下载cloudreve镜像 # 下载镜像 docker pull xavierniu/cloudreve:3.5.1 # 安装容器 docker run -itd \ --name cloudreve \ -e PUID=1000 \ -e PGID=1000 \ -e TZ="Asia/Shanghai" \ -p 5212:5212 \ --restart=unless-stopped \ -v /home/cloudreve/uploads:/cloudreve/uploads \ -v /home/cloudreve/config:/cloudreve/config \ -v /home/cloudreve/db:/cloudreve/db \ -v /home/cloudreve/avatar:/cloudreve/avatar \ xavierniu/cloudreve:3.5.1 # 查看管理员初始化账号和密码 docker logs -f cloudreve 3 初始化系统 # 输入IP地址和端口号 http://192.168.108.200:5212/ 配置文件，请参考管理员的管理面板中，包括添加用户、设置存储空间、注册登录权限等；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3316ec2d9f02f875a0fbbcb0ae5312aa/" rel="bookmark">
			JRaft框架学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Raft算法回顾 1.1、Raft简介 Raft是基于日志复制的一致性算法。
Raft效果等同于Paxos，但实现不同，raft比Paxos更容易理解。
Raft有三个关键性的一致性元素：
1）Leader选举（Leader Selection）
2）日志复制（Log Replication）
3）安全（Safety）
一致性算法用于允许一组Server如一个整体般工作，能自动让他的成本在失败后恢复正常。在raft之前，一致性算法主要是paxos，但paxos难于理解，raft应运而生。
假如一个raft集群包括5台服务器，能最多容忍2台服务器不可用，而集群正常。在任意时间，集群中的每台服务器一定会处于以下三种状态之一：Leader、Candidate、Follower。
在正常情况下，只有一个服务器是Leader，剩下的服务器是 Follower。Follower 是被动的：它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。Leader来处理所有来自客户端的请求（如果一个客户端与 Follower 进行通信，Follower 会将信息发送 Leader）。Candidate 是用来选取一个新的 Leader 的。
1.2、复制状态机 一致性算法是在复制状态机（Replicated State Machine）的背景下提出来的。一组 Server 的状态机通过使用相同状态的副本，并且即使有一部分 Server 宕机了它们仍然能够继续运行，这可在分布式系统中解决容错问题。
复制状态机架构图：
1、复制状态机通过日志实现 1）每台机器一份日志
2）每个日志条目包含一条命令
3）状态机按顺序执行命令
2、应用于实际系统的一致性算法一般有以下特性 1）确保安全性：在网络延迟、分区、丢包、重复和重排序等情况下保证安全（不会返回错误结果）
2）高可用性：集群中超过半数Server可以，集群可正常使用
3）不依赖时序保证一致性：如时钟错误、消息延迟等情况可保证一致性
4）一条命令能够尽可能快的在大多数节点对一轮RPC调用响应时完成：只要多数派Server复制成功即算完成，个别相应慢的Server不会拖累整个集群性能。
3、Paxos 算法的不足 1）算法复杂度高, 较难理解
2）工程复杂度高, 难以在实际环境中实现
1.3、Leader选举 Raft 使用一种心跳机制来触发 Leader 的选举。当服务器启动时，它们会初始化为 Follower。一台服务器会一直保持 Follower 的状态，只要它们能够收到来自 Leader 或者 Candidate 的有效 RPC。Leader 会向所有 Follower 周期性发送心跳（不带有任何日志条目的 AppendEntries RPC）来保证它们的 Leader 地位。如果一个 Follower 在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为没有可用的 Leader，并且开始一次选举以选出一个新的 Leader。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3316ec2d9f02f875a0fbbcb0ae5312aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed05536ebcab2362fa0c572d0b10531e/" rel="bookmark">
			文件系统读写性能fio测试方法及参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Fio 是一个 I/O 工具，用来对硬件进行压力测试和验证，磁盘IO是检查磁盘性能的重要指标，可以按照负载情况分成照顺序读写，随机读写两大类。
Fio支持13种不同的I/O引擎，包括：sync, mmap, libaio, posixaio, SG v3, splice, null, network, syslet, guasi, solarisaio , I/O priorities (for newer Linux kernels), rate I/O, forked or threaded jobs, 等等。
fio-2.1.10百度网盘下载链接:
链接：https://pan.baidu.com/s/1d_ho1Q1uN_0Kaq3N01OLWw?pwd=4z4r
提取码：4z4r
本文以银河麒麟操作系统为例。
测试方法 1.安装libaio：（注意：顺序不能反，一定要先安装libaio，再编译） 桌面版本：
apt-get -y install libaio1 libaio-dev 服务器版本：
yum install libaio libaio-devel 2.解压fio工具包，执行命令：
tar xvf fio-2.1.10-fix.tar.gz 3.解压后进入目录
cd fio-2.1.10 4.对应架构，编译
./configure make &amp;&amp; make install 5.执行测试命令（示例）
fio -filename=/data/test -direct=1 -iodepth 32 -thread -rw=read -ioengine=libaio -bs=4k -size=5G -numjobs=8 -group_reporting -runtime=120 -time_base -name=/home/fio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed05536ebcab2362fa0c572d0b10531e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c6d406279cae52acb154301f67e76e3/" rel="bookmark">
			vanilla-tilt.js: 一个平滑的3D倾斜javascript库。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vanilla-tilt.js: 一个平滑的3D倾斜javascript库。 参考原文链接:https://www.5axxw.com/wiki/content/u3rci5
( 如需查看英文版本，请 点击这里 )
vanilla-tilt.js 一个平滑的3D倾斜javascript库
Usage &lt;body&gt; &lt;div class="your-element" data-tilt&gt;&lt;/div&gt; &lt;!-- 在底部插入script --&gt; &lt;script type="text/javascript" src="vanilla-tilt.js"&gt;&lt;/script&gt; &lt;/body&gt; 如果要在IE中使用此库，则需要包含CustomEvent polyfill：https://github.com/micku7zu/vanilla-tilt.js/issues/49#issuecomment-482711876 或者可以考虑 jQuery版本
Options { reverse: false, // 是否反转倾斜方向 max: 15, // 最大的倾斜角度(度) startX: 0, // X轴上的起始倾斜，单位为度。 startY: 0, // Y轴上的起始倾斜，单位为度。 perspective: 1000, // 转换角度，越低倾斜越极端 scale: 1, // 缩放比例,2 = 200%, 1.5 = 150%, 等等.. speed: 300, // 进入/退出 过渡的速度 transition: true, // 是否在进入/退出的时候设置过渡效果 axis: null, // 设置禁用哪个轴的反转,值为:X或者Y reset: true, // 设置在退出时清除倾斜效果 easing: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c6d406279cae52acb154301f67e76e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50045011dfda864d99690561342f87b5/" rel="bookmark">
			jQuery5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.1. jQuery 事件注册
1.2. jQuery 事件处理
1.2.1 事件处理 on() 绑定事件
1.2.2. 案例：发布微博案例
1.2.3. 事件处理 off() 解绑事件
1.2.4. 事件处理 trigger() 自动触发事件
1.3. jQuery 事件对象
1.1. jQuery 事件注册 ​ jQuery 为我们提供了方便的事件注册机制，是开发人员抑郁操作优缺点如下：
- 优点: 操作简单，且不用担心事件覆盖等问题。
- 缺点: 普通的事件注册不能做事件委托，且无法实现事件解绑，需要借助其他方法。
语法
&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { // 1. 单个事件注册 $("div").click(function() { $(this).css("background", "purple"); }); $("div").mouseenter(function() { $(this).css("background", "skyblue"); }); }) &lt;/script&gt; &lt;/body&gt; 1.2. jQuery 事件处理 ​ 因为普通注册事件方法的不足，jQuery又开发了多个处理方法，重点讲解如下：
- on(): 用于事件绑定，目前最好用的事件绑定方法
- off(): 事件解绑
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50045011dfda864d99690561342f87b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dff12fa68c7df8e3466de9a95335b2b0/" rel="bookmark">
			四、GC日志及参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、程序添加JVM参数的方式 命令行添加：java [JVM参数] -jar [jar包名] java -XX:+PrintGC -jar jvm-project.jar
idea添加（后续例子用此方式，idea版本2021.2.2、jdk1.8.0_152） Run -&gt; Edit Configurations -&gt; modify options -&gt; java -&gt; Add VM options
打印效果
一、GC跟踪参数 开启GC日志，打印简要GC信息 -verbose:gc（-XX:PrintGC）:程序执行GC的时候打印GC信息 GC：执行一次Young GC（YGC、MinorGC）；Allocation Failure：出发GC的原因（分配内存失败）；64289K-&gt;1008K：年轻代通过一次YGC，内存占用从64289K降为1008k；247296K：整堆大小为247296K，此处整堆大小是变化的是由于idea默认设置的堆最大值和最小值不一致（见最大/最小堆参数设置）；0.0013379 secs：此次YGC耗时； 打印GC详细信息 -XX:+PrintGCDetails：程序结束时打印堆信息 GC/Full GC：GC类型；Allocation Failure、Ergonomics：触发GC的原因；Ergonomics是由于虚拟通过算法估算出GC后年轻代所需空间大于当前剩余空间，所以提前进行一次Full GC；PSYoungGen、ParOldGen、Metaspace：年轻代、老年代、元空间（jdk1.8之前为永久代）；1054K-&gt;0K：回收前所占空间-&gt;回收后所占空间；(2560K)：当前区域（PSYoungGen、ParOldGen、Metaspace）可用总大小（年轻代to survivor区永远为空，不可用）；0.0002245 secs：当前GC所花时间；Times：用户时间、系统时间、实际时间；heap：堆信息total：当前区域总大小；used ：当前区域使用大小；[0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)：当前内存所在地址，最低边界，当前所在边界（使用到哪），最高边界；eden：年轻代eden区；form：年轻代form surivor区；to：年轻代to surivor区； 以文件形式输出GC日志 -Xloggc:C:\temp\gc.log（路径自行调整） 每次GC之后打印堆信息 -XX:+PrintHeapAtGCHeap before GC ：GC前堆信息；invocations=21 (full 7)：调用GC次数（其中Full GC次数）；
跟踪类加载 -XX:+TraceClassLoading；Object为所有类的基类，最先加载；
二、堆分配参数 最大堆内存、最小堆内存 -Xmx20m -Xms12m如下代码中JVMObject中每次分配1M空间，JVMTest通过main方法实例化JVMObject，然后分别打印最大内存、空闲内存、总内存，GC日志如下图；内存总大小分别在第三次GC和第五次GC之后进行了提升，这是由于分配的初始内存为12m，进行三次GC之后，空间不足，JVM对堆内存进行了提升； JVM会将堆内存尽量维持在最小值； /** * @author xiaomu * @title: JVMObject * @description: JVM测试实体对象 * @date 2022/8/1110:28 */ public class JVMObject { private byte[] a = null; public JVMObject() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dff12fa68c7df8e3466de9a95335b2b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a35b741b7c1080c3ba06dd87b8b54a7/" rel="bookmark">
			图片的高频与低频分量 初识 与 相关博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片的低频与高频分量 初识 图像中的低频信号和高频信号，也叫做低频分量和高频分量。
低频分量对应图像中物体的亮度均匀或变化缓慢的区域；
高频分量对应图像中物体的边缘、细节、噪声。
定义 图像的频率：该图像灰度值变化剧烈程度的指标，是灰度在平面空间上的梯度。
低频 图像信号中的低频分量，指的是图像强度（亮度、灰度）变换平缓的地方。也就是大片色块，变化不那么明显的地方。
低频就是颜色缓慢地变化，也就是灰度缓慢地变化，就代表着那是连续渐变的一块区域，这部分就是低频。对于一幅图像来说，除去高频的就是低频了，也就是边缘以内的内容为低频，而边缘内的内容就是图像的大部分信息，即图像的大致概貌和轮廓，是图像的近似信息。
高频 图像信号中的高频分量，指的就是图像信号强度（亮度/灰度）变化剧烈的地方，也就是我们常说的边缘（轮廓）。
高频就是频率变化快。图像中什么时候灰度变化快？就是相邻区域之间灰度相差很大，这就是变化得快。图像中，一个影像与背景的边缘部位，通常会有明显的差别，也就是说变化那条边线那里，灰度变化很快，也即是变化频率高的部位。因此，图像边缘的灰度值变化快，就对应着频率高，即高频显示图像边缘。图像的细节处也是属于灰度值急剧变化的区域，正是因为灰度值的急剧变化，才会出现细节。
另外噪声（即噪点）也是这样，在一个像素所在的位置，之所以是噪点，就是因为它与正常的点颜色不一样了，也就是说该像素点灰度值明显不一样了,也就是灰度有快速地变化了,所以是高频部分，因此有噪声在高频这么一说。
举例 1、在一张白纸上有一行字，那么我们肯定直接聚焦在文字上，而不会太在意白纸本身，这里文字就是高频信号，而白纸就是低频信号。
2、为什么图像的频率是表征图像中灰度变化剧烈程度的指标。大面积的沙漠在图像中是一片灰度变化缓慢的区域，对应的频率值很低，属于低频；而对于地表属性变换剧烈的边缘区域在图像中是一片灰度变化剧烈的区域，对应的频率值较高，属于高频。
3、低频保留了光影与颜色，高频保留了纹理与质感。 4、穿条纹衬衫的人
在上图中，围巾和条纹衬衫为该图像高频的区域，这部分从一种亮度到另一种亮度变化非常迅速。在同一张图像的较高位置，我们看到天空和背景的部分变化非常缓慢，是图像的低频部分。
空域和频域 &amp; 傅里叶变换 空域与频域 空域是指图像平面本身，空域滤波这类方法直接对图像的像素进行处理。频域滤波是变换域滤波的一种，它是指将图像进行变换后（频域是指经过傅里叶变换之后），在变换域中对图像的变换系数进行处理（滤波），处理完毕后再进行逆变换，获得滤波后的图像。
如何将图像从空域切换到频域？使用傅里叶变换。
图像的空间域，就是二维平面坐标系，它有两个正交的轴即x,y轴。 某点在空间域上的幅值就是该点处的灰度。 图像上某点处的灰度是该点在x,y方向上灰度的叠加。 这样，分别以x,y为横坐标，灰度值为纵坐标，得到两个函数。表示图像在x,y方向上的灰度值变化情况。
傅里叶级数。根据傅里叶级数的知识，函数可以写成多个不同振幅及频率的正弦函数的和。因此，通过傅里叶变换，灰度-x函数就变换为振幅-u函数，灰度-y函数就换为振幅-v函数。建立以u，v为正交轴的平面坐标系，这样就得到了频率图。
由于二维DFT通常为复函数，因此可以用极坐标形式表示：
傅里叶变换的目的 Question1：我们对图像作傅里叶变换得到频谱图，是为了啥？ Answer1:
傅里叶变换变换可以得到高频与低频，针对高频与低频处理，可以实现不同的目的；傅里叶变换是可逆的，通过逆傅里叶变换，可以恢复原图像；如果对高频与低频进行处理，然后进行逆傅里叶变换，所做的处理会反映到逆变换图像上。 Question2：如何处理才能去除高频 或者 低频信息？ Answer2：如何理解图像的频率域处理？ - 知乎 (zhihu.com)
经过低通滤波器处理。保留低频信息，去除高频信息。图像细节部分丢失，图像变模糊。
经过高通滤波器处理，也就是去除频率域中的低频信息，只保存高频信息后的结果。图像只保留了细节部分。
左图为频率图，右图为原图 经低通滤波器处理，去除高频信息，保留低频信息； 左图为处理后的频率图，右图为处理后的图像。 经高通滤波器处理，去除低频信息，保留高频信息； 左图为处理后的频率图，右图为处理后的图像。 傅里叶变换 图像傅里叶变换原理 python实现 - 我坚信阳光灿烂 - 博客园
推荐 数字图像处理 - 标签 - 我坚信阳光灿烂 - 博客园 (cnblogs.com)
在数字图像处理中，有两个经典的变换被广泛使用——傅里叶变换和霍夫变换。傅里叶变换是将时间域上的信号转变为频率域上的信号，进而进行图像去噪、图像增强等处理。
傅里叶变换（Fourier Transform，FT）后，对同一事物的观看角度随之改变，可以从频域里发现一些从时域里不易察觉的特征。某些在时域内不好处理的地方，在频域内可以容易地处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a35b741b7c1080c3ba06dd87b8b54a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1aaac4fae189263f939cdf834a3f80/" rel="bookmark">
			VirtualBox在安装时报错：发生严重错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跟着尚硅谷谷粒商城学习技术第一天，配置环境过程中安装VirtualBox虚拟机时报错：发生严重错误。
我的电脑时win10系统,视频里版本是6，我下载的是7，结果报错如下
最终找到解决方法：https://zhuanlan.zhihu.com/p/573549446
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d1bd30a9bcbf0b3e5e272d951a2bea9/" rel="bookmark">
			111 ajax获取数据jsrender显示数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、通过dom操作实现数据的显示2、使用jsrender显示数据 使用 axios实现 ajax获取天气数据并显示数据 界面如下： 引入bootstrap样式 &lt;link rel="stylesheet" href="libs/bootstrap-4.5.3-dist/css/bootstrap.min.css"&gt; 1、通过dom操作实现数据的显示 引入jquery、axios
&lt;script src="../js/jquery-3.6.0.min.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="../js/axios.min.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; 获取数据
显示数据
给要显示数据的元素添加id，获取该元素修改元素内容。
效果
通过DOM的修改或添加实现数据的显示，比较麻烦。使用jsrender来显示数据会方便很多。
2、使用jsrender显示数据 jsrender基于模板来显示数据。
引入jsrender
&lt;script src="../js/jquery-3.6.0.min.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;!-- 放在jquery后面引入 --&gt; &lt;script src="../js/jsrender-1.0.9/jsrender.min.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="../js/axios.min.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; 访问http://www.tianqiapi.com/api?version=v9&amp;appid=23035354&amp;appsecret=8YvlPNrz，数据如下：
界面如下：
定义模板
将data.aqi这个对象绑定到模板上，基于模板显示数据，返回一串html代码。
效果如下：
传统的挨个取DOM元素然后赋值无法比较麻烦，灵活的运用模板引擎，效率会高很多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afd21ac5f3f2614a76716ce9330f94c0/" rel="bookmark">
			112 使用jsrender绑定数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、循环遍历数组，绑定数组元素2、绑定整个数组3、修改模板，第一天显示一行，其余6天显示一行4、修改模板，设置第一天显示显示5、练一练，显示当天每小时的天气情况 使用 jsrender绑定数组数据data。 数据如下： 显示7天的天气预报情况。 jsrender： https://www.jsviews.com/#home 定义模板如下： ajax请求数据 1、循环遍历数组，绑定数组元素 2、绑定整个数组 在上述效果中，第一天显示一行，其余6天显示一行呢。
3、修改模板，第一天显示一行，其余6天显示一行 使用jsrendar的条件来进行控制。
4、修改模板，设置第一天显示显示 5、练一练，显示当天每小时的天气情况 使用jsrendar的循环来实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/107017b66503c09d1c520efd2a01dea2/" rel="bookmark">
			linux i2c驱动开发之最简单入门：设备树与驱动的匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1在设备树中声明我们的模拟I2C设备：
i2c的设备加入是必须放在某个i2c的总线下面的，我们这里是放在 i2c7下面。
可以直接在设备树搜索&amp;i2c7，然后把status 修改为okay，然后再加入设备信息.
&amp;i2c7 { status = "okay"; myi2c-dev { status = "okay"; compatible ="myi2c-dev"; reg = &lt;0x70&gt;; }; }; 这里我们指定和驱动匹配的字符串是 myi2c-dev，在bus segment 上分配的地址是 0x70 。
当然这个地址是我们随便写的，我们只是模拟而已，不会和真正的设备交互。
然后编译，烧录系统。
2 驱动代码：
#include &lt;linux/uaccess.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/stat.h&gt; #include &lt;linux/cdev.h&gt; #include &lt;linux/io.h&gt; #include &lt;linux/gpio.h&gt; #include &lt;linux/slab.h&gt; #include &lt;linux/irq.h&gt; #include &lt;linux/mutex.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/bug.h&gt;	/* For BUG_ON. */ #include &lt;linux/cpu.h&gt; #include &lt;linux/init.h&gt; /* Needed for the macros */ #include &lt;linux/kernel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/107017b66503c09d1c520efd2a01dea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/205f726acd080052e49848b0bf5b838c/" rel="bookmark">
			AD原理图突然变灰，无法编辑了，快速恢复方法介绍！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用AD18画原理图的时候，不知道触发了什么功能，导致整个原理图界面变成了灰色。怎么办?不怕！请看下文.
下面是正常操作时候的界面：
下面是异常界面：
咨询同事后,同事表示经常遇到这种情况，他们认为是软件卡死了，关闭再重新打开即可。
不过鄙人不这么认为，经过我多次探索，发现竟然方法如此简单！
我们把视线转移到原理图左下角，会发现每一页的sheet都有这么个编辑的按钮在，那么我们鼠标左键点击一下即可轻易解决此问题！使原理图在禁止编辑与启动编辑之间进行切换！
居然如此简单，而好多熟知此EDA的同事竟然没有发觉到这里！看来大家平时要多细心探索，才会发现世界如此简单！哈哈哈~
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/196/">«</a>
	<span class="pagination__item pagination__item--current">197/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/198/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>