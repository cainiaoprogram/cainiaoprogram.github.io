<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/627fe28b8237bda29faafcbba16f394f/" rel="bookmark">
			HashMap的put方法源码解析_JDK8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package demo.JavaJdk8; import java.util.HashMap; import java.util.Map; /** * @author Xch */ public class MapDemo{ public void putDemo(){ Map&lt;String,Integer&gt; mapDemo=new HashMap&lt;&gt;(2); mapDemo.put("one",1); Integer one=mapDemo.get("one"); System.out.println(one); } } 前戏 上面的代码是我们平时对HashMap最简单的使用：
1、new 一个实例对象。
2、之后调用 put() 方法为集合添加一个键值对。
3、之后我们再调用 get() 方法得到一个键的值。
无论是 JDK7 还是 JDK8 都是这样的使用，但 JDK8 对 HashMap 进行了更加“优美”的优化。
以下所有代码、解读都基于 JDK8 ，为了方便查看源代码，我是用了IntelliJ_IDEA开发工具。
一、Map&lt;String,Integer&gt; mapDemo=new HashMap&lt;&gt;(2)------带上taotao HashMap的初始化，很简单的赋予这个HashMap一个初始化长度为2。
我们看看数组初始化做了什么？
让我们按键Ctrl+鼠标放在HashMap&lt;&gt;(2)上，之后鼠标左击，便会进入HashMap的默认构造函数源码中：
/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/627fe28b8237bda29faafcbba16f394f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/086ed350c4186aafb027395a741c2587/" rel="bookmark">
			用python读取.text文件特定行的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何用python循环读取下面.txt文件中，用红括号标出来的数据呢？
首先，观察数据可知，不同行的第一个数据元素不一样，所以考虑直接用正则表达式。
再加上，对读和写文件的操作，就行了
注：我用的是pycharm+python2.7
话不多说，直接上代码
import re f1=file('shen.txt','r') data1=f1.readlines() # print data1 f1.close() results = [] for line in data1: data2=line.split() # print data2[0] m = re.findall(r"[0-9]:", data2[0]) if m: results.append(line) # for i in data2[0]: # data3=i.split(":") # print data3 # if data3&gt;=0 and data3&lt;=50000: # results.append(line) # if i=='1': # results.append(line) f2=file('deal.txt','w') f2.writelines(results) f2.close() 前期，我遇到“1：”这样的字符串实在是没办法处理，后来查找资料，发现有正则这么爽的东西！
在上面的代码中，需要说明的是： m = re.findall(r"[0-9]:", data2[0]) 该语句的意思就是，对于字符串而言，寻找到能够匹配1：，2：，9：。。。。。。的字符串 最后处理的结果是：
由于数据不是很漂亮，还需要将里面的“，”和“：”这两个符号去掉，因此，我使用了replace语句
代码如下：
#coding:utf-8 #__author__ ='dell' import re f1=file('shen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/086ed350c4186aafb027395a741c2587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f34e1b16f160325a0ab87a3118e4121/" rel="bookmark">
			查询oracle sql语句执行最慢和执行最多的语句！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查询sql执行最慢的语句
select * from (select a.sql_text,a.sql_fulltext,a.executions "执行次数",round(a.elapsed_time / 1000000,2) "总执行时间", round(a.elapsed_time / 1000000 / a.executions,2) "平均时间",a.command_type,a.parsing_user_id "用户ID",b.username "用户",a.hash_value from v$sqlarea a left join all_users b on a.parsing_user_id=b.user_id where a.executions&gt;0 order by (a.ELAPSED_TIME / a.executions) desc) where rownum&lt;=50; 2.执行次数最多的sql语句
select * from (select a.sql_text,a.executions "执行次数",a.parsing_user_id "用户",rank() over(order by a.executions desc) exec_rank from v$sql a left join all_users b on a.PARSING_USER_ID=b.user_id) c where exec_rank&lt;=100; 转载于:https://www.cnblogs.com/Roobbin/p/9506133.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c3f3b0774346d54b40dfacc97791561/" rel="bookmark">
			vue-03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue-cli脚手架config目录下index.js配置文件 // see http://vuejs-templates.github.io/webpack for documentation. // path是node.js的路径模块，用来处理路径统一的问题 var path = require('path') module.exports = { // 下面是build也就是生产编译环境下的一些配置 build: { // 导入prod.env.js配置文件，只要用来指定当前环境，详细见(1) env: require('./prod.env'), // 下面是相对路径的拼接，假如当前跟目录是config，那么下面配置的index属性的属性值就是dist/index.html index: path.resolve(__dirname, '../dist/index.html'), // 下面定义的是静态资源的根目录 也就是dist目录 assetsRoot: path.resolve(__dirname, '../dist'), // 下面定义的是静态资源根目录的子目录static，也就是dist目录下面的static assetsSubDirectory: 'static', // 下面定义的是静态资源的公开路径，也就是真正的引用路径 assetsPublicPath: '/', // 下面定义是否生成生产环境的sourcmap，sourcmap是用来debug编译后文件的，通过映射到编译前文件来实现 productionSourceMap: true, // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin // 下面是是否在生产环境中压缩代码，如果要压缩必须安装compression-webpack-plugin productionGzip: false, // 下面定义要压缩哪些类型的文件 productionGzipExtensions: ['js', 'css'], // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off // 下面是用来开启编译完成后的报告，可以通过设置值为true和false来开启或关闭 // 下面的process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c3f3b0774346d54b40dfacc97791561/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee92210cbf3cd63da068801f43813275/" rel="bookmark">
			自建机房与IDC机房对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自建机房与IDC机房对比一览 分析
自建机房
专业IDC机房
成本费用
采购机柜、交换机、路由器、服务器、防火墙、空调、UPS及备用发电机等费用；找各大运营商拉不同网络专线，不能互通，费用昂贵；服务器网络设备精密空调24小时运行，耗电量大
企业只需支出采购服务器的成本；托管到完善设施的IDC机房服务商，电信、联通、移动等网络线路已入驻，可以实现互联互通，用户直接租用就行，省时省心省力
机房环境
装修、电力、空调、网络带宽、日常维护、恒温、防火、防潮、防静电、UPS、柴油发电机
已具备
网络架构
按自身意愿建设网络架构，自由度灵活度较高；需要专业的网络架构师设计解决方案
服务商已规划好，网络维护问题不用自己操心，省心省力
安全要求
双机备份可以确保一台服务器瘫痪，另一台服务器还会继续工作，为维护提供缓冲空间；数据多重备份，避免服务器故障造成数据丢失；需另行购买防火墙和网络安全软件来减少×××率
安全性高，高可靠结构的防火墙，7*24*365小时监视，检测来自网络的×××，监控骨干网络和设备的运行情况；网络安全、数据安全管理工作托管服务商协助，非客户授权机房技术人员不能去动客户数据，省心省力安全
运营维护
自建机房，现场维护方便；服务器的日常运行需要配备专业的维护工程师，人力支出成本高
机房提供365天全天候运营服务，有专业技术人员24小时负责维护网络，有效保障网络的稳定性和高速性，灵活性好用户启动业务快托管网络设备扩展方便；机房负责服务器的日常运维
可扩展性
空间和带宽有限不易快速和稳定的扩展；按需分配追加建设需要另行采购申请，原有架设结构会有整改方案和费用支出
提出扩展需求，机房协助解决；服务器配置可以自行申请采购追加费用支出
售后服务
硬件设备一般质保三年，软件一般一年，实施、维修服务需要联系厂家客户和技术，需要时间等待
硬件设备一般质保三年，软件一般一年，实施、维修服务需要联系厂家客户和技术，需要时间等待；机房可以协助基本服务，更换或增加硬盘等
技术服务
5*8小时，非上班期间出现故障不能及时处理解决，损失增大
7*24小时技术支持，服务器故障24小时内及时响应快速解决，把损失降至最小
硬件冗余
无
有
网络带宽品质
租用光纤
骨干网汇聚层
随着时代的发展，科技的进步，大型公司企业自建机房在陆续兴起，也出现了很多争议，以上表格是初步整理出来的对比，希望对大家有所帮助
转载于:https://blog.51cto.com/13843649/2161985
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45656afd65b002287ae0511fe68015f8/" rel="bookmark">
			yum install   出现如下错误： Loaded plugins: fastestmirror, langpacks    SyntaxError: invalid syntax
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7升级Python到3.5后，我跟以前CentOS 6一样，在/usr/bin/python创建了一个指向Python 3的软连接，然后将/usr/bin/yum的顶部的：
!/usr/bin/python 改成了
!/usr/bin/python2.7 后，运行yum，还是出现了以下错误：
[root@vps ~]# yum -y install yum-priorities Loaded plugins: fastestmirror, langpacks Determining fastest mirrors * base: ftp.iij.ad.jp * epel: ftp.kddilabs.jp * epel-debuginfo: ftp.kddilabs.jp * epel-source: ftp.kddilabs.jp * extras: ftp.iij.ad.jp * updates: ftp.iij.ad.jp File "/usr/libexec/urlgrabber-ext-down", line 28 except OSError, e: ^ SyntaxError: invalid syntax File "/usr/libexec/urlgrabber-ext-down", line 28 except OSError, e: ^ SyntaxError: invalid syntax File "/usr/libexec/urlgrabber-ext-down", line 28 except OSError, e: ^ SyntaxError: invalid syntax File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45656afd65b002287ae0511fe68015f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec5634b075e78e8ee2cf5186bb08c2d0/" rel="bookmark">
			系统调用中断（EINTR）与SIGCHLD信号的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、被中断的系统调用(EINTR)的理解 1. 慢系统调用是？2. 慢系统调用的类别3. EINTR产生的原因5. 一般处理方法 二、SIGCHLD信号的处理 1. SIGCHLD信号的产生2. SIGCHLD信号的处理3. 不处理SIGCHLD的后果 三、示例代码 一、被中断的系统调用(EINTR)的理解 1. 慢系统调用是？ 慢系统调用指可能永远阻塞的系统调用。
也就是处于阻塞状态的系统调用，如果不收到需要的信息，就会一直阻塞在那里。例如accept：在服务器等待客户端建立连接时，如果没有客户端来请求连接，那么accept就会一直阻塞，直到有客户端请求连接为止。像这种系统调用，就称为慢系统调用。
2. 慢系统调用的类别 对管道的读写对终端设备设备的读写对网络连接的读写…… 值得注意的是，读写磁盘文件一般不会阻塞，一般会返回给调用者（在没有硬件故障的条件下）
3. EINTR产生的原因 当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。有些内核会自动重启某些被中断的系统调用。
对这句话的理解： 慢系统调用在阻塞状态中，如果收到了某个信号，该系统调用就会被中断，转而去执行对应的信号处理函数，在信号处理函数执行完后，被中断的系统调用就会返回EINTR。有的内核会在被中断的系统调用返回EINTR后重新执行。
以accept为例，在服务器阻塞于accept时，这时之前已连接的客户端关闭了，对应该客户端的子进程就会退出，并发送SIGCHLD信号。如果定义了信号处理函数，就会造成accept的中断，然后执行该信号处理函数，执行完后accept就会返回EINTR。
5. 一般处理方法 推荐将对accept的调用改为：
while( true ) { int clientlen = sizeof( cliaddr ); int connfd = accept( sockfd, (struct sockaddr *)&amp;cliaddr, &amp;clietnlen ); if( connfd &lt; 0 ) { if( errnp == EINTR ) { //如果返回EINTR，就重启该系统调用 continue; } else { perror( "accept "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec5634b075e78e8ee2cf5186bb08c2d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707448c1ef025ce2b93d4093576ecc84/" rel="bookmark">
			python类中的__dict__
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码：
class Person(object): name = 'python' age = 18 def __init__(self): self.sex = 'boy' self.like = 'papapa' @staticmethod def stat_func(): print 'this is stat_func' @classmethod def class_func(cls): print 'class_func' person = Person() print 'Person.__dict__: ', Person.__dict__ print 'person.__dict__: ', person.__dict__ 运行结果：
Person.__dict__: {'__module__': '__main__', 'name': 'python', '__init__': &lt;function __init__ at 0x000000000385B518&gt;, 'class_func': &lt;classmethod object at 0x0000000003847F78&gt;, '__dict__': &lt;attribute '__dict__' of 'Person' objects&gt;, 'age': 18, '__weakref__': &lt;attribute '__weakref__' of 'Person' objects&gt;, '__doc__': None, 'stat_func': &lt;staticmethod object at 0x00000000037CFAF8&gt;} person.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707448c1ef025ce2b93d4093576ecc84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94c6235b22b3a2489823fd7e07e26849/" rel="bookmark">
			Lvs_Fullnat模式的搭建部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验原理 数据包进来和出去同时都做了DNAT和SNAT的转换； 与DR、TUN、NAT相比，只有它具有抗攻击性；（五组元进行双向hash） 性能比较：DR :&gt; TUN &gt; NAT &gt; fullnat 二、实验部署 （1）实验环境： 下载软件 kernel-2.6.32-220.23.1.el6.src.rpm newt-devel-0.52.11-3.el6.x86_64.rpm asciidoc-8.4.5-4.1.el6.noarch.rpm slang-devel-2.2.1-1.el6.x86_64.rpm （依赖性） Lvs-fullnat-synproxy.tar.gz lvs-tools.tar.gz
所有的主机都为rhel6.5，selinux为disabled，防火墙关闭，策略清除； server1: LB( VIP:172.25.74.1 ; RIP:172.25.45.1 ) server2: RS( IP:172.25.45.2 ) server3: RS( IP:172.25.45.3 ) （2）实验过程： a. 添加fullnat模块；
[root@server1 ~]# yum install rpm-build -y [root@server1 mnt]# rpm -ivh kernel-2.6.32-220.23.1.el6.src.rpm [root@server1 ~]# cd rpmbuild/SPECS [root@server1 SPECS]# ls kernel.spec [root@server1 SPECS]# rpmbuild -bp kernel.spec ##预编译 [root@server1 SPECS]# rpmbuild -bp kernel.spec ##这里需要解决依赖性 [root@server1 SPECS]# yum install gcc redhat-rpm-config patchutils xmlto asciidoc elfutils-libelf-devel zlib-devel binutils-devel newt-devel python-devel perl-ExtUtils-Embed hmaccalc -y [root@server1 SPECS]# rpmbuild -bp kernel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94c6235b22b3a2489823fd7e07e26849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fb5bb2f784dcff3d6c3a410c9727b5c/" rel="bookmark">
			Linux修改权限功能------chmod
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.chmod命令概况 chmod是Linux/Unix中修改文件或者目录权限的命令，通过修改权限可以让指定的人对文件可读、可写、可运行，极大地保证了数据的安全性。
二.chmod命令的语法 命令名称： chmod
执行权限： 所有用户
功能描述： 改变文件或目录权限
语法： 第一种方法 chmod [{ugoa}{+-=}{rwx}] [文件或目录]
备注： u：所有者 g：所属组 o：其他人 a：所有人
+：为用户增加权限 -：为用户减少权限 =：为用户赋予权限
r：读权限 w：写权限 x：执行权限 第二种方法 chmod -R [mode=421] [文件或目录] ←（这种方法用的比较多）
备注： r：4 w：2 x：1
r为读权限，可以用4来表示，
w为写权限，可以用2来表示，
x为执行权限，可以用1来表示。
-R 递归修改（就是将嵌套在很多文件夹中的文件权限修改了，如果没有这个，只能到指定的文 件夹下进行修改）
范例： chmod 777 /etc/hurenxiang 将hurenxiang这个文件夹权限改为对所有用户可读，可写，可执行
chmod 775 /etc/caiyao 将caiyao这个文件夹权限改为其他用户不可读
三.chmod命令结构详解 在Linux中输入ll，会出现指定目录下文件/目录的详细信息，本文重点讲解权限部分，也就是下图中红色框中的部分。
详解下图：权限一共是10个字符，第1个字符分为1组，后面9个字符分为3组。
第1个字符有两种情况：如果是“d”则代表这是一个文件夹，如果是“—”代表这是一个文件；
第2、3、4个字符：这3个字符共同代表的是文件的拥有者，可以用u来表示，拥有四个权限：r：读权限 ， w：写权限，x：执行权限，—：无权限；
第5、6、7个字符：这3个字符代表的是文件所属群组，可以用g来表示，拥有四个权限：r：读权限 ， w：写权限，x：执行权限，—：无权限；
第8、9、10个字符：这3个字符代表的是除拥有者和所属群组之外的其他所有的用户，可以用o来表示，拥有四个权限：r：读权限 ， w：写权限，x：执行权限，—：无权限。
注意：后面9个字符除了u，g，o外，还有一个a，代表了所有用户。
四.chmod命令的使用 chmod命令都详细讲解完了，下面用几个例子巩固一下：
这是通过两个实例，详细回顾了一波上面的知识点。
-rw--wx--x //该文件的 拥有者有读取和写入的权限，但没有执行权限； 所在群组没有读取的权限，但有写入和执行的权限； 其他用户没有读取和写入的权限，但有执行的权限 d--xr-xrw- //该文件夹的 拥有者没有读取和写入的权限，但有执行的权限； 所在群组没有写入的权限，但有读取和执行的权限； 其他用户没有执行权限，但有读取和写入的权限 这是修改权限的一种方法实例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fb5bb2f784dcff3d6c3a410c9727b5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb241cad7365173eb5c95bd9c0783f11/" rel="bookmark">
			Oracle的基础用法详细实例（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle的基础用法详细实例（一） —删除表空间 drop tablespace ts1706;
—创建表空间 create tablespace ts1706 —将表空间放置位置 datafile ‘F:\ts1706.dmp’ —表空间大小 size 5m —表空间是否可扩展 reuse autoextend on/off;
—-删除用户 drop user rose; —创建新用户 create user rose —用户密码 identified by 111111 —用户默认表空间 default tablespace ts1706 —用户临时表空间储存在temp temporary tablespace temp;
—授权 —系统权限 —connect 连接oracle的权力 —resource 操作系统资源的权力 resourse 包括（create table,create,view,…..）
—赋予权力 grant connect,resource to rose;
—管理员回收系统资源权限 revoke resource from rose;
—用户管理的命令 —添加用户 alter user rose identified by 222222;
—锁定/解除当前用户 alter user rose account unlock/lock;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb241cad7365173eb5c95bd9c0783f11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6293a766d6872ccb3fb6101d66065e0a/" rel="bookmark">
			Oracle的PLSQL别名中文出现乱码解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Oracle的PLSQL别名中文出现乱码解决方法 01、查询oracle服务端默认语言
select * from nls_database_parameters
NLS_LANGUAGE AMERICAN ###客户端编码 NLS_TERRITORY AMERICA NLS_CURRENCY $ NLS_ISO_CURRENCY AMERICA NLS_NUMERIC_CHARACTERS ., NLS_CHARACTERSET ZHS16GBK ＃＃＃数据库中文字符集 NLS_CALENDAR GREGORIAN NLS_DATE_FORMAT DD-MON-RR　＃＃＃日期格式 NLS_DATE_LANGUAGE AMERICAN NLS_SORT BINARY NLS_TIME_FORMAT HH.MI.SSXFF AM　＃＃＃时间格式 NLS_TIMESTAMP_FORMAT DD-MON-RR HH.MI.SSXFF AM NLS_TIME_TZ_FORMAT HH.MI.SSXFF AM TZR NLS_TIMESTAMP_TZ_FORMAT DD-MON-RR HH.MI.SSXFF AM TZR NLS_DUAL_CURRENCY $ NLS_COMP BINARY NLS_LENGTH_SEMANTICS BYTE NLS_NCHAR_CONV_EXCP FALSE NLS_NCHAR_CHARACTERSET AL16UTF16　＃＃＃国家字符集 NLS_RDBMS_VERSION 11.2.0.1.0 02、设置PL/SQL机器环境变量
只需要在系统环境变量里新建如下图的变量即可
变量名(N)： NLS_LANG 变量值(V)： AMERICAN.ZHS16GBK 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/703353fbd994f264e4933cd18fd12638/" rel="bookmark">
			周期性时间序列的预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		女主宣言
AIOps 从立项到现在已经半年有余，从最开始的 LVS 异常检测，到如今的实时关联分析，智能运维已经渗透到我们日常运维中的许多场景，之后我们会将积累的经验分享出来，供大家学习参考，本文最先发布于 OpsDev，转载已获取作者授权。
PS：丰富的一线技术、多元化的表现形式，尽在“HULK一线技术杂谈”，点关注哦！
At Tranquility Base, 1969
by NASA IOTD
最近在研究时间序列的时候，发现很多序列具有很强的周期性，那如何对此类序列进行预测呢？
1
数据处理
挑选一个如下图的具有周期性的时间序列。该序列是取得是过去7天的数据，每小时一个点，一共7*24个点。
2
划分数据集
我们取前六天的数据做训练，第七天做测试集。
3
平滑处理
时间序列经常会出现毛刺的点，需要做平滑处理才能分析，类似上图中的数据。消除数据的毛刺，可以用移动平均法，但是移动平均有时候处理完后并不能使数据平滑，我这里采用的方法很简单，但效果还不错：把每个点与上一点的变化值作为一个新的序列，对这里边的异常值，也就是变化比较离谱的值剃掉，用前后数据的均值填充：
经过处理以后，上图的时间序列得到了平滑处理，效果如下图。
4
周期性分解
具有周期性特征的序列需要将周期性特征提取出来。python里面的statsmodels工具包里面有针对周期性分解的函数seasonal_decompose，我们可以将序列进行分解。seasonal_decompose这个函数里面有个two_sided的参数，默认是True。Trend处理的时候用到移动平均的方法，熟悉此方法的读者就会发现，经过该方法处理以后，序列收尾两段有一部分数据缺失了，但是如果该参数为FALSE，则只有开始的时候有一段缺失值。
图3中的第一张图是observed，体现的原始数据；第二张是trend，体现的是分解出来的趋势部分；第三张是seasonal，体现的是周期部分；最后是residual，体现的是残差部分。
本文采用的是seasonal_decompose的加法模型进行的分解，即 observed = trend + seasonal + residual，另还有乘法模型。在建模的时候，只针对trend部分学习和预测，如何将trend的预测结果加工成合理的最终结果？后面会有介绍。
5
预测
我们对trend部分进行预测，最后再加上seasonal部分。对trend的预测，我们采用ARIMA模型。熟悉该模型的都知道，需要确定三个参数p，q和d，可以使用aic和bic的方法进行定阶，可以查阅相关的文献。
得到模型以后，就可以进行预测。
下面是预测的结果，从图中可以看到预测的结果将周期性的特征完美地体现出来了。
6
评估
对第七天作出预测，评估的指标为均方根误差rmse，本序列的rmse小于5，效果还是不错的。
7
总结
本文介绍了周期性序列的预测方法，你可能会问并不是所有的序列都具有周期性，事实确实如此，接下来几篇博客，我会重点介绍周期性检测的一些方法。希望此博客对您研究时间序列有所帮助。
HULK一线技术杂谈
由360云平台团队打造的技术分享公众号，内容涉及云计算、数据库、大数据、监控、泛前端、自动化测试等众多技术领域，通过夯实的技术积累和丰富的一线实战经验，为你带来最有料的技术分享
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed3dd0bfa89500c5feb306cd4d9db56c/" rel="bookmark">
			正则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div class="rich_media_content " id="js_content"&gt; &lt;h5 style="color: rgb(51, 51, 51);" data-mpa-powered-by="yiban.io"&gt;&lt;img class="" data-ratio="0.08571428571428572" data-w="980" width="auto" data-src="http://mmbiz.qpic.cn/mmbiz/r7XrK6h4XLRWjXX9UibayTgtPQ1UJKlpb8QYRAialhKNqXOkHyEEaMCpKSlySYDWPia5D4WpeqWQfuX9q6grBeBhw/640?" style="letter-spacing: 0.544px;font-size: 17px;border-width: 1px;border-style: solid;border-color: rgb(238, 237, 235);background-size: 22px;background-position: center center;background-repeat: no-repeat;line-height: 27.2px;font-family: Helvetica, Arial, sans-serif;visibility: visible !important;width: 677px !important;" /&gt;&lt;/h5&gt;&lt;p style="text-align: center;"&gt;&lt;span style="font-family: Optima-Regular, PingFangTC-light;font-size: 14px;"&gt;八月的天，真是女人的心&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;span style="background-color: rgb(214, 168, 65);"&gt;&lt;strong&gt;&lt;span style="background-color: rgb(214, 168, 65);font-family: Optima-Regular, PingFangTC-light;font-size: 14px;color: rgb(255, 255, 255);"&gt;阴晴不定&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;span style="font-family: Optima-Regular, PingFangTC-light;font-size: 14px;"&gt;就在昨天，山东多地出现狂风暴雨&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;span style="font-family: Optima-Regular, PingFangTC-light;font-size: 14px;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed3dd0bfa89500c5feb306cd4d9db56c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238029fb7b964f522e1c888939c3f74b/" rel="bookmark">
			Android VR视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说，先上图（眼睛模式） 参考的开源库——传送门 MD360Player4Android 在开源库的基础上，做了菜单和播放器逻辑。 VR功能的部分通过依赖vrlib来实现，视频播放的部分集成ijkPlayer 这里对MD360Player4Android中的一些代码做解释。 初始化VR播放器
@Override protected MDVRLibrary createVRLibrary() { return MDVRLibrary.with(this) .displayMode(MDVRLibrary.DISPLAY_MODE_NORMAL) //默认360度全景 .interactiveMode(MDVRLibrary.INTERACTIVE_MODE_MOTION_WITH_TOUCH)//触摸和重力 .asVideo(new MDVRLibrary.IOnSurfaceReadyCallback() { @Override public void onSurfaceReady(Surface surface) { mMediaPlayerWrapper.setSurface(surface); } }) .ifNotSupport(new MDVRLibrary.INotSupportCallback() { @Override public void onNotSupport(int mode) { String tip = mode == MDVRLibrary.INTERACTIVE_MODE_MOTION ? "onNotSupport:MOTION" : "onNotSupport:" + String.valueOf(mode); Toast.makeText(VrPlayerActivity.this, tip, Toast.LENGTH_SHORT).show(); } }) .pinchConfig(new MDPinchConfig().setMin(1.0f).setMax(8.0f).setDefaultValue(0.1f)) .pinchEnabled(true) .directorFactory(new MD360DirectorFactory() { @Override public MD360Director createDirector(int index) { return MD360Director.builder().setPitch(90).build(); } }) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/238029fb7b964f522e1c888939c3f74b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3224ac85f893559557e240137cdb57/" rel="bookmark">
			Mybatis自定义sql，进行insert、update、delete操作，如何返回影响的行记录数？？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接在mapper接口文件直接返回 int 类型即可，sql语句和正常一样，无需设置返回值类型，mybatis框架会自动完整这些功能 接口：UserMapper.java public interface UserMapper { int insert(User record); } Mapper映射文件：UserMapper.xml &lt;insert id="insert" parameterType="com.itheima.springmvc.pojo.User" &gt; &lt;!-- 无需设置返回值类型parameterType --&gt; insert into user (id, username, birthday, sex, address) values (#{id,jdbcType=INTEGER}, #{username,jdbcType=VARCHAR}, #{birthday,jdbcType=DATE}, #{sex,jdbcType=CHAR}, #{address,jdbcType=VARCHAR}) &lt;/insert&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/361aae461d77d34997d82d5b53f0604e/" rel="bookmark">
			java.lang.ArrayIndexOutOfBoundsException 数组下标越界异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常部分代码：
原因：代码中codenum_new为一个int类型，默认值为0，所以0-1之后为-1，而codeNumlist（一个List集合）的下标是从0开始的，也就是第一个参数的下标为0，当这里需要找到下标为-1的String时，就会报错。
解决办法：在list集合的范围内取值，下标从0开始，并且不大于集合长度-1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7222cebaa4018059fa467ff640237b33/" rel="bookmark">
			进程间通信---共享内存&amp;shmget
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍这一部分主要从它的几个函数入手：
概念：共享内存是在物理内存上开辟一块区域，这段被多个进程映射到自己进程的虚拟地址空间上，这些进程就可以直接访问该共享内存区域，从而通过该区域实现各进程间的通信。共享内存是进程间最快的一种通信方式，一个进程向共享内存上面写数据，共享这块内存的所有进程都可以看到其中的内容，这块共享内存的页面，出现在所用共享该页面进程的页表中，给人一种就是在访问自己地址空间里面的数据一样。共享内存映射图：
可以看到进程A和进程B共享了一块内存，分别将共享内存所在的物理页加入到自己的页表中，访问时就像访问自己的东西一样，所以它是最快的一种通信方式。但是会有一个问题，就是可能存在多个进程同时访问这块区域，此时共享内存区域就成了临界资源，所以我们在使用共享内存时需要对它进行同步控制才能保证安全的使用。比如信号量、加锁等方式。
和其他IPC对象一样，共享内存对象的获取也是由key控制。每一个新创建的共享内存对象都用一个shmid_kernel的数据结构表示。系统中所用的shmid_kernel数据结构都保存在shm_segs向量表中，该向量表中的每一个元素都是一个指向shmid_kernel数据结构的指针。shimd_kernel会包含共享内存的所用信息。
Linux为共享内存提供的四种操作
1、shmget函数：创建或者获得一个共享内存对象。它和其他两种IPC机制一样，进程在使用共享内存区域之前，必须通过系统调用sys_ipc（call值为SHMGET）创建一个键值为key的共享内存对象，或者获得已经存在的键值为key的某共享内存对象的引用标识符。以后对共享内存对象的访问都是通过该引用标识符进行。看一下shmget函数定义：
int shmget(key_t key,int size,int shmflg) 这里key表示该共享内存的键值，size是该共享内存的大小（以字节为单位），shmflg是标志（对该共享内存对象的特殊要求）。
过程如下：
计算size要占用的页数，检查其合法性申请一块内存用于建立shmid_kernel数据结构，（这里申请的内存区域大小不包括真正的共享内存区，实际上，要等第一个进程试图访问它的时候才真正创建共享内存区。将shmid_kernel数据结构加入到向量表shm_segs中的合适位置返回该共享内存对象的引用标识符。 2、shmat函数：在获得共享内存区域的引用标识符后，还必须将共享内存区域映射到进程的虚拟地址空间中，然后才能使用该共享内存区域。系统调用sys_IPC（call值为SHMAT）用于共享内存区到进程虚拟地址空间的映射。看一下shmat函数的定义：
void * shmat(int shmid,const void *shmaddr,int shmflg); shmid：是shmget返回的共享内存对象的引用标识符
shmaddr：用来指定该共享内存在进程虚拟地址空间对应的虚拟地址（如果是0则由系统分配，一般从1G开始）
shaflg：映射标志
返回值：进程的虚拟地址
过程如下：
根据shmid找到共享内存对象检查shmaddr的合法性（不能超过3G)申请一块内存用于创建数据结构vm_area_struct，填写该结构将其加入到进程的mm结构和该共享对象的vm_area_atruct中 注意：
当进程第一次访问共享虚拟内存的某页时，因为所有的共享内存页都还没有分配，所以会发生一个page fault异常。然后Linux处理这个缺页异常，将分配一个物理页，并为它创建一个页表条目。这个不仅进入当前进程的页表，同时也存到shmid_kernel数据结构的页表shm_pages中。
当下一个进程访问这块内存时，发生page fault的时候，在查看shmid_kelnel数据结构的shm_pages时，发现共享页已经存在，它只需要把其中的页表项填入到自己进程页表的相应位置即可，而不需要重新创建物理页，所以，是第一个访问共享内存的进程创建物理页后其他访问它的进程只需要把该页加入到自己的虚拟地址空间就好了。
3、shmdt函数：当进程不需要共享这块内存时，更新自己的页表，共享内存对应的虚拟内存页被标记为无效。当最后一个进程分离这个共享内存时，共享内存页被释放，同时共享内存的shmid_kernel数据结构也被释放。Shmdt函数定义：
int shmdt(char *shmaddr) shmaddr:表示进程要分离共享页的起始虚拟地址。
该函数搜索内存中所用的vm_area_atruct数据结构，找到地址shmaddr对应的那个，调用函数将其释放，更新进程表中对应的页表项。
4、Shmctl函数：操作包括获得共享内存对象的状态、释放共享内存对象资源等。这里涉及到了同步控制问题。
下面看一下代码示例：
#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt; 1.创建共享内存： int shmget(key_t key,int size,int shmflg); 参数说明： key:用来表示新建或者已经存在的共享内存去的关键字。 size：创建共享内存的大小。 shmflg：可以指定的特殊标志。IPC_CREATE,IPC_EXCL以及低九位的权限。 eg： int shmid; shmid=shmget(IPC_PRIVATE,4096,IPC_CREATE|IPC_EXCL|0660); if(shmid==-1) perror("shmget()"); 2.连接共享内存 char *shmat(int shmid,char *shmaddr,int shmflg); 参数说明 shmid：共享内存的关键字 shmaddr：指定共享内存出现在进程内存地址的什么位置，通常我们让内核自己决定一个合适的地址位置，用的时候设为0。 eg： int shmid; char *shmp; shmp=shmat(shmid,0,0); if(shmp==(char *)(-1)) perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7222cebaa4018059fa467ff640237b33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b4acdf074d2af2ecb1cf977ff9e6bc7/" rel="bookmark">
			关于mysql的mycat中间件安装配置与python使用mycat例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于mysql的mycat中间件安装配置与python使用mycat例子 MyCAT是mysql中间件，Mycat数据库分库分表中间件国内最活跃的、性能最好的开源数据库中间件! 它是一款开源的Mysql企业级集群应用，前身是阿里大名鼎鼎的Cobar，Cobar在开源了一段时间后，不了了之。于是MyCAT扛起了这面大旗，在大数据时代，其重要性愈发彰显。
MyCAT提供了类似Mysql的接口，可以平滑的将单机Mysql迁移到Mysql集群上，解决数据存储和业务规模迅速增长情况下的数据瓶颈问题。
这篇文章主要是MyCAT的入门部署和python使用。
一，什么是mycat
一个彻底开源的，面向企业应用开发的大数据库集群
支持事务、ACID、可以替代MySQL的加强版数据库
一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群
一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server
结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品
一个新颖的数据库中间件产品
以上是官方说明。其实就是数据库的连接池。mysql proxy也是一种连接池，但是效率很低。
二，mycat 安装
1，下载地址mycat
2，安装mycat
# tar zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz -C /usr/local/
我下载的是Mycat-server-1.5.1-RELEASE-20161130213509-linux.tar.gz
三，进行mycat配置的前提是已经配置好了，MySQL数据库主从架构，如下：
1、前提是已经配置了MySQL的主从关系，如下：
在192.168.1.120上MySQL命令行窗口，查看如下：
mysql&gt; show slave hosts;
+-----------+------+------+-----------+--------------------------------------+
| Server_id | Host | Port | Master_id | Slave_UUID |
+-----------+------+------+-----------+--------------------------------------+
| 121 | | 3306 | 120 | b8f1101c-9131-11e8-a9bd-000c294283ad |
| 122 | | 3306 | 120 | deb94f66-8cfa-11e8-a1f4-000c29accb8e |
| 130 | | 3306 | 120 | bab165c8-a093-11e8-93ba-000c29e026cb |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b4acdf074d2af2ecb1cf977ff9e6bc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed0dc701d87f2ac7e69f6807bf5ba82c/" rel="bookmark">
			IDEA创建类模板和方法模板（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写代码是少不了注释的，但是自带的注释就几个，所以使用注释模板添加自定义的注释是个非常好用的功能
创建类模板 按照顺序打开File–&gt;settings–&gt;Editor–&gt;File and Code Templates–&gt;Includes输入类注释模板 /** * @Classname ${NAME} * @Description TODO * @Date ${DATE} ${TIME} * @Created by ${USER} */ 3. 结果： 创建方法模板 按照顺序打开File–&gt;Settings–&gt;Editor–&gt;Live Templates点击右边的”+“号,选择Template Group 创建自己的组名 选择自己的组名，点击”+”号，选择Live Template 填写Abbreviation，Description，Template text 点击 Define 选择java，也可以选择everywhere 设置Edit variables 选择相对应的方法就可以了，点击ok，ok 注意这里使用的是tab 的方式使用注释模板 示例 优化参数显示方式 这种数组显示很别扭，所以执行一下这个操作就可以了 groovyScript("def result=''; def params=\"${_1}\".replaceAll('[\\\\[|\\\\]|\\\\s]', '').split(',').toList(); for(i = 0; i &lt; params.size(); i++) {if(params[i] == '') return result;if(i==0) result += '\\n'; result+=' * @param ' + params[i] + ((i &lt; params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed0dc701d87f2ac7e69f6807bf5ba82c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa2ec3e6bf2be2955f1a112d40f1f1d6/" rel="bookmark">
			windows与windows之间传输文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A服务器传文件到B服务器
出现错误：复制了0个文件 无效驱动器规格 1.先将A中要传输的文件设置共享 拿到文件共享路径 2.在B中使命令 xcopy \\WIN-TNBJLF7BQOG\oracletyyh D:\backup\oracletyyh /D /E /Y /H /K (其中的\\WIN-TNBJLF7BQOG也可以用ip替代\\192.168.4.168) 即可实现远程传输文件 转载于:https://www.cnblogs.com/hqsbrx/p/9488323.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb864272f3bc5925d3dfeb30aff7d1ce/" rel="bookmark">
			机器学习：分类，回归，聚类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分类： 分类方法是一种对离散型随机变量建模或预测的监督学习算法。使用案例包括邮件过滤、金融欺诈和预测雇员异动等输出为类别的任务。许多回归算法都有与其相对应的分类算法，分类算法通常适用于预测一个类别（或类别的概率）而不是连续的数值。
1.逻辑回归 logistic Logistic 回归是与线性回归相对应的一种分类方法，且该算法的基本概念由线性回归推导而出。Logistic 回归通过 Logistic 函数（即 Sigmoid 函数）将预测映射到 0 到 1 中间，因此预测值就可以看成某个类别的概率。
该模型仍然还是「线性」的，所以只有在数据是线性可分（即数据可被一个超平面完全分离）时，算法才能有优秀的表现。同样 Logistic 模型能惩罚模型系数而进行正则化。
优点：输出有很好的概率解释，并且算法也能正则化而避免过拟合。Logistic 模型很容易使用随机梯度下降和新数据更新模型权重。缺点：Logistic 回归在多条或非线性决策边界时性能比较差。 2.分类树、决策树 与回归树相对应的分类算法是分类树。它们通常都是指决策树，或更严谨一点地称之为「分类回归树（CART）」，这也就是非常著名的 CART 的算法。
优点：同回归方法一样，分类树的集成方法在实践中同样表现十分优良。它们通常对异常数据具有相当的鲁棒性和可扩展性。因为它的层级结构，分类树的集成方法能很自然地对非线性决策边界建模。
缺点：不可约束，单棵树趋向于过拟合，使用集成方法可以削弱这一方面的影响。
3 深度学习 深度学习同样很容易适应于分类问题。实际上，深度学习应用地更多的是分类任务，如图像分类等。
优点：深度学习非常适用于分类音频、文本和图像数据。
缺点：和回归问题一样，深度神经网络需要大量的数据进行训练，所以其也不是一个通用目的的算法。
4 支持向量机 支持向量机（SVM）可以使用一个称之为核函数的技巧扩展到非线性分类问题，而该算法本质上就是计算两个称之为支持向量的观测数据之间的距离。SVM 算法寻找的决策边界即最大化其与样本间隔的边界，因此支持向量机又称为大间距分类器。
支持向量机中的核函数采用非线性变换，将非线性问题变换为线性问题
例如，SVM 使用线性核函数就能得到类似于 logistic 回归的结果，只不过支持向量机因为最大化了间隔而更具鲁棒性。因此，在实践中，SVM 最大的优点就是可以使用非线性核函数对非线性决策边界建模。
优点：SVM 能对非线性决策边界建模，并且有许多可选的核函数形式。SVM 同样面对过拟合有相当大的鲁棒性，这一点在高维空间中尤其突出。
缺点：然而，SVM 是内存密集型算法，由于选择正确的核函数是很重要的，所以其很难调参，也不能扩展到较大的数据集中。目前在工业界中，随机森林通常优于支持向量机算法。
5 朴素贝叶斯 朴素贝叶斯（NB）是一种基于贝叶斯定理和特征条件独立假设的分类方法。本质上朴素贝叶斯模型就是一个概率表，其通过训练数据更新这张表中的概率。为了预测一个新的观察值，朴素贝叶斯算法就是根据样本的特征值在概率表中寻找最大概率的那个类别。
之所以称之为「朴素」，是因为该算法的核心就是特征条件独立性假设（每一个特征之间相互独立），而这一假设在现实世界中基本是不现实的。
优点：即使条件独立性假设很难成立，但朴素贝叶斯算法在实践中表现出乎意料地好。该算法很容易实现并能随数据集的更新而扩展。
缺点：因为朴素贝叶斯算法太简单了，所以其也经常被以上列出的分类算法所替代。
回归 回归方法是一种对数值型连续随机变量进行预测和建模的监督学习算法。使用案例一般包括房价预测、股票走势或测试成绩等连续变化的案例。
回归任务的特点是标注的数据集具有数值型的目标变量。也就是说，每一个观察样本都有一个数值型的标注真值以监督算法
1 线性回归（正则化）
线性回归是处理回归任务最常用的算法之一。该算法的形式十分简单，它期望使用一个超平面拟合数据集（只有两个变量的时候就是一条直线）。如果数据集中的变量存在线性关系，那么其就能拟合地非常好。
在实践中，简单的线性回归通常被使用正则化的回归方法（LASSO、Ridge 和 Elastic-Net）所代替。正则化其实就是一种对过多回归系数采取惩罚以减少过拟合风险的技术。当然，我们还得确定惩罚强度以让模型在欠拟合和过拟合之间达到平衡。
优点：线性回归的理解与解释都十分直观，并且还能通过正则化来降低过拟合的风险。另外，线性模型很容易使用随机梯度下降和新数据更新模型权重。
缺点：线性回归在变量是非线性关系的时候表现很差。并且其也不够灵活以捕捉更复杂的模式，添加正确的交互项或使用多项式很困难并需要大量时间。
2 回归树（集成方法）
回归树（决策树的一种）通过将数据集重复分割为不同的分支而实现分层学习，分割的标准是最大化每一次分离的信息增益。这种分支结构让回归树很自然地学习到非线性关系。
集成方法，如随机森林（RF）或梯度提升树（GBM）则组合了许多独立训练的树。这种算法的主要思想就是组合多个弱学习算法而成为一种强学习算法，不过这里并不会具体地展开。在实践中 RF 通常很容易有出色的表现，而 GBM 则更难调参，不过通常梯度提升树具有更高的性能上限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb864272f3bc5925d3dfeb30aff7d1ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7746356cf274af8fe4ebcb8545226a7e/" rel="bookmark">
			索引：位图索引理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 案例
有张表名为table的表，由三列组成，分别是姓名、性别和婚姻状况，其中性别只有男和女两项，婚姻状况由已婚、未婚、离婚这三项，该表共有100w个记录。现在有这样的查询： select * from table where Gender=‘男’ and Marital=“未婚”;
姓名(Name)
性别(Gender)
婚姻状况(Marital)
张三
男
已婚
李四
女
已婚
王五
男
未婚
赵六
女
离婚
孙七
女
未婚
...
...
...
1）不使用索引
不使用索引时，数据库只能一行行扫描所有记录，然后判断该记录是否满足查询条件。
2）B树索引
对于性别，可取值的范围只有'男','女'，并且男和女可能各站该表的50%的数据，这时添加B树索引还是需要取出一半的数据， 因此完全没有必要。相反，如果某个字段的取值范围很广，几乎没有重复，比如身份证号，此时使用B树索引较为合适。事实上，当取出的行数据占用表中大部分的数据时，即使添加了B树索引，数据库如oracle、mysql也不会使用B树索引，很有可能还是一行行全部扫描。
2. 位图索引出马
位图索引创建了之后，生成是位图数据可以这么理解，比如，男女两种，然后一共八条数据，那么就生产两个字符串，一个代表男，一个代表女，字符串长度为数据的总数量，字符串的值：第一位（如果第一条数据是男那么就是1，如果不是就0），第二位，第三位，往后都是这样。由此就生成了长度为总数量，只包含01的字符串，通过这个字符串就能知道第几条数据是男，第几条不是男，同理，另外一条代表女的字符串也一样，是女的就1，不是女的就0。
如果用户查询的列的基数非常的小， 即只有的几个固定值，如性别、婚姻状况、行政区等等。要为这些基数值比较小的列建索引，就需要建立位图索引。
对于性别这个列，位图索引形成两个向量，男向量为10100...，向量的每一位表示该行是否是男，如果是则位1，否为0，同理，女向量位01011。
RowId
1
2
3
4
5
...
男
1
0
1
0
0
女
0
1
0
1
1
对于婚姻状况这一列，位图索引生成三个向量，已婚为11000...，未婚为00100...，离婚为00010...。
RowId
1
2
3
4
5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7746356cf274af8fe4ebcb8545226a7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/418775f73041781d5ababe475438b52c/" rel="bookmark">
			OBJ(3D模型)文件格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍：
在最近的3D编程中，想开始做一些多模型的Demo，而网上显然没有那么多直接可供DirectX使用的模型文件(.x)，而3D模型文件格式中的obj文件则具有较好的通用性，不仅支持各类3D建模软件的互相导入导出，在Maya上还可以直接读写。
OBJ文件结构：
以一个立方体模型的obj文件为例：
# 一些注释 mtllib cube.mtl g default v -0.500000 -0.500000 0.500000 v 0.500000 -0.500000 0.500000 v -0.500000 0.500000 0.500000 v 0.500000 0.500000 0.500000 v -0.500000 0.500000 -0.500000 v 0.500000 0.500000 -0.500000 v -0.500000 -0.500000 -0.500000 v 0.500000 -0.500000 -0.500000 vt 0.001992 0.001992 vt 0.998008 0.001992 vt 0.001992 0.998008 vt 0.998008 0.998008 vt 0.001992 0.001992 vt 0.998008 0.001992 vt 0.001992 0.998008 vt 0.998008 0.998008 vt 0.001992 0.001992 vt 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/418775f73041781d5ababe475438b52c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4aa295eb2a223bd5e988fd634851ada/" rel="bookmark">
			Android问题集锦（十五）- 成功解决org.gradle.api.internal.tasks.compile.CompilationFailedException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一次引入第三方库之后，在Run运行时突然报以下错误： 'Caused by: org.gradle.api.internal.tasks.compile.CompilationFailedException: Compilation failed; see the compiler error output for details.' 经过一轮Google后，网上说的原因是：
按照android stadio 3.1的要求，需要把gradle版本升级为 4.4及以上，但是gradle 4.4及以上要求将依赖api的compile换成implementation。而implementation声明的依赖没办法传递到module以外，即该module 以外module没办法引用到implementation声明的api。
如果是这个原因的话，我升级3.x已经有一段时间了，一直是用compile或implementation声明引用第三方库的，都没出现这样的 问题，当时就纳闷，就尝试了以下解决方案：
将compile 替换为 api即可，也就是如果有外部引用，则换成：api，剩下的换成：implementation
示例：
dependencies { api fileTree(dir: 'libs', include: ['*.jar']) testImplementation 'junit:junit:4.12' api 'com.android.support:support-v4:26.1.0' api 'com.android.support:appcompat-v7:26.1.0' api 'com.google.code.gson:gson:2.8.2' api 'com.j256.ormlite:ormlite-core:4.48' api 'com.j256.ormlite:ormlite-android:4.48' 然而并没有什么用，无论是clear build 还是rebuild project都不行。 最后还是File -&gt; Invalidate Caches -&gt; Invalidate and Restart 解决这个问题
小结：
compile 替换为 apiFile -&gt; Invalidate Caches -&gt; Invalidate and Restart 参考： https://juejin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4aa295eb2a223bd5e988fd634851ada/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd3c842835207bfdb91332bc505418a3/" rel="bookmark">
			念佛60分钟MP3-净空爷爷慢速念佛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 念佛60分钟MP3-净空爷爷慢速念佛。 链接： https://pan.baidu.com/s/1sOL9zNJZxM3wNx3c7lIjhg 密码：xqw4 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ce9fa21cfa909cd56f8d9d0ed2b092b/" rel="bookmark">
			js 判断字符串是否以某字符串开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var str = '123456789'; str.startWith('12345');//true 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15ab8db298a96e185508e8f7ab01d258/" rel="bookmark">
			http通信协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、http基础：URL格式、HTTP请求、响应、消息 1、HTTP URL 格式： http://host[:port][abs_path]
其中http表示要通过HTTP协议来定位网络资源。
host表示合法的Internet主机域名或IP地址（以点分十进制格式表示）；
port用于指定一个端口号，拥有被请求资源的服务器主机监听该端口的TCP连接。
如果port是空，则使用缺省的端口80。当服务器的端口不是80的时候，需要显式指定端口号。
abs_path指定请求资源的URI(Uniform Resource Identifier，统一资源定位符)，如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出。
2、HTTP请求 客户端通过发送HTTP请求向服务器请求对资源的访问。
HTTP请求由三部分组成，分别是：请求行，消息报头，请求正文。
请求行以一个方法符号开头，后面跟着请求URI和协议的版本，以CRLF作为结尾。
请求行以空格分隔。除了作为结尾的CRLF外，不允许出现单独的CR或LF字符，格式如下：
Method Request-URI HTTP-Version CRLF
Method表示请求的方法，Request-URI是一个统一资源标识符，标识了要请求的资源，HTTP-Version表示请求的HTTP协议版本，CRLF表示回车换行。
3、 HTTP响应 在接收和解释请求消息后，服务器会返回一个HTTP响应消息。
与HTTP请求类似，HTTP响应也是由三个部分组成，分别是：状态行，消息报头，相应正文。
状态行由协议版本，数字形式的状态代码，相应的状态描述组成，各元素之间以空格分隔，除了结尾的CRLF(回车换行)序列外，不允许出现CR或LF字符。格式如下：
HTTP-Version Status-Code Reason-Phrase CRLF
HTTP-Version表示服务器HTTP协议的版本，Status-Code表示服务器发回的响应代码，Reason-Phrase表示状态代码的文本描述，CRLF表示回车换行。
HTTP响应——状态代码与状态描述：
状态代码由三位数字组成，表示请求是否被理解或被满足，状态描述给出了关于状态代码的简短文本描述。
状态代码的第一个数字定义了响应的类别，后面两个数字没有具体的分类。
第一个数字有五种可能的取值：
1xx：指示信息——表示请求已接收，继续处理
2xx：成功——表示请求已经被成功接收，理解，接受
3xx：重定向——要完成请求必须进行更进一步的操作
4xx：客户端错误——请求有语法错误或请求无法实现
5xx：服务器端错误——服务器未能实现合法的请求
4、HTTP消息 HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。
请求消息和响应消息都是由开始行，消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。
对于请求消息，开始行就是请求行，对于相应消息，开始行就是状态行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd156cb52ce977d4899bd2a2d51945b0/" rel="bookmark">
			postgres基本操作(个人总结版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		postgres 基本操作 登录 $ psql (连接数据库，默认用户和数据库都是postgres) $ psql -U &lt;user&gt; -d &lt;dbname&gt; 数据库操作 // 列举数据库，相当于show databases
$ \l // 切换数据库，相当与use dbname
$ \c &lt;dbname&gt; // 列举表，相当与show tables
$ \dt // 查看表结构，相当于desc
$ \d tblname // 创建数据库
$ create database &lt;dbname&gt; // 删除数据库
$ drop database &lt;dbname&gt; // 创建表
$ create table ([字段名1] [类型1] ;,[字段名2] [类型2],......&lt;,primary key (字段名m,字段名n,...)&gt;;); // 在表中插入数据
$ insert into 表名 ([字段名m],[字段名n],......) values ([列m的值],[列n的值],......); // 备份数据库
$ pg_dump -U postgres -f /tmp/postgres.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd156cb52ce977d4899bd2a2d51945b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca881eb1d735ef7b0d2adc3e12d6f64d/" rel="bookmark">
			centos6.5手动编译源码安装screen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		就是想尝试一下Linux手动编译源码的安装方式，遇到了两个坑。
官网上下载screen-4.6.2.tar.gz，解压目录为screen-4.6.2，在该目录下执行命令
./configure make make install install -m 644 etc/etcscreenrc /etc/screenrc 要是相关依赖没有问题的话，输入命令which screen，出现/bin/screen则安装成功
第一个坑，我在./configure的时候报了下面的错
C compiler cannot create executables
最后面提示详情请查看config.log文件，查看安装日志
error trying to exec 'cc1': execvp: No such file or directory
网上看了一圈感觉有点麻烦，直接把gcc卸载重新安装了一边，没有报这个错了
再执行一边./configure,报错
configure: error: !!! no tgetent - no screen
缺少个依赖
yum -y install ncurses-devel
再次./configure,成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c46de43eeeb9eaa906a442f42d502fc0/" rel="bookmark">
			七夕H5小游戏：Face&#43;&#43;人脸融合搭载颜值评分，看你和TA颜值配不配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人脸融合搭载颜值评分，旷视科技七夕H5来袭 人工智能时代，AI+七夕的玩法层出不穷，趁着浓情七夕的到来，Face++最新H5小作品也终于面世啦！这一次Face++把人脸融合、颜值评分的功能结合起来，实现趣味效果的独此一家。我们一起来看看是怎么实现的吧！
程序的操作非常简单，只需要把牛郎和织女的照片放进去就可以了，在这里我们把邓超和孙俪的照片作为模板，看看模范夫妻一家谁的颜值更高。果然两位都是高颜值的帅哥美女，颜值与太阳肩并肩~
《七夕鹊桥来相会，看你们颜值配不配》
小程序的实现原理也非常易懂，基本可以分为两个步骤：第一步先利用颜值评分功能给上传的两张图片打分。第二步是在评分的同时用人脸融合功能实现趣味效果。想看你们是不是天生一对，谁又才是家里的颜值担当？文末可以扫描二维码进行抢先体验，和另一半去鹊桥相会！
1、什么是颜值评分 Face++颜值评分会自动计算检测到的人脸的颜值分数，并分别返回男性和女性视角下该人脸的颜值分数。当然，颜值分数的高低并不等同于实际的美丑，只是基本代表了亚洲男性和亚洲女性对该人脸评价的平均水平。
2、颜值评分技术特色
准确可靠：Face++ 提供准确可靠的颜值评分, 为您的数据与分析提供可靠支持。
多视角：Face++ 提供男性和女性对同一人脸颜值的评分，更多视角让您的分析更加全面。
快速高效：依托高效的人脸识别技术，Face++ 能够快速完成海量人脸图片的颜值评分。
适应性强：Face++ 为您提供稳定高性能的颜值评分功能，完美应对脸部遮挡、光照情况不理想、头部姿态不正等常见问题。
3、应用场景
美妆销售：您能获得顾客妆前、妆后的颜值分数，能够帮助您为顾客推荐、挑选最合适的美妆产品，为顾客提供完美的购物体验。
婚恋交友：对照片进行颜值评分，让您的应用能根据用户的性别、要求偏好为用户推荐合适的人选，大大提升配对成功率。
趣味营销：搭载Face++颜值评分能力做线上H5、小程序等营销。
4、如何抠图
本H5执行完人脸融合操作后的图片是带着背景色的，为了使牛郎织女的身体能变成透明背景，需要对身体形状进行抠图。（图片格式仅支持jpg）
抠图示例代码：
import cv2 import numpy as np def convert(base_image_path, opaque_image_path): opaque_image = cv2.imread(opaque_image_path,cv2.IMREAD_UNCHANGED) alpha_channel = opaque_image[:,:,3] base_image = cv2.imread(base_image_path, cv2.IMREAD_UNCHANGED) b_channel, g_channel, r_channel = cv2.split(base_image) img_BGRA = cv2.merge((b_channel, g_channel, r_channel,alpha_channel)) img_encode = cv2.imencode('.png', img_BGRA)[1] return np.array(img_encode) 5、调用方法
具体方法大家点击官方网址，一分钟快速调用detect API获取颜值评分功能哦：
https://console.faceplusplus.com.cn/documents/4888373
七夕节马上要来啦，旷视科技为你提供全新营销方案，赶紧扫描二维码和你的另一半到鹊桥相会吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ed35cbb0fed29f8bb76a9630d9a099a/" rel="bookmark">
			IOS移动端中H5页面用on绑定click无效的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检查代码中是不是有ES6语法，有些版本IOS不支持
标题 图中圈起来的就是ES6语法 let，在手机中直接报错，导致前后所有代码都执行不了，注释掉(删掉)就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4fc766e2f7be5dcbe1532240b03c1ab/" rel="bookmark">
			02 DIY流星观测站——手把手搭建指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关系列文章 01 DIY流星观测站02 DIY流星观测站——手把手搭建指南03 DIY流星观测站——设备选型与采购04 DIY流星观测站——镜头简介05 DIY流星观测站——相机简介 该教程的目的是快速引导流星爱好者（天文爱好者）搭建一个完整的流星观测站，并通过该观测站观测流星。建站所需的器材都是市场上成熟的的工业产品，价格在大众可以接受的范围之内，所有器材都可以在网上买到。该项目为开源项目，欢迎大家的参与和讨论。 更多详细信息请参考项目的源码站点。
1 相关配件 1.1 必须器材列表 树莓派电脑：Raspberry Pi 3（RPi3）树莓派电源：电压5V，最大电流至少2AmicroSD卡：大于等于64GB，树莓派的系统盘，U盘不能作为系统盘。microSD读卡器：向microSD卡中安装树莓派操作系统，读取microSD卡的数据，从树莓派拷贝数据。3厘米×3厘米风扇：树莓派散热风扇。铝合金散热片：一共需要3个。树莓派散热片，选择有粘胶的，可以直接贴在树莓派的芯片上。时间模块：DS3231时间模块，树莓派关机后，可保存树莓派的时间。USB视频采集卡(UTV007)：将模拟相机的模拟视频信号转换为数字信号。模拟相机：Sony673相机或WATEC WAT-902H相机，配置一个4mm或6mm的镜头。其他镜头也行，观测效果会略有不同。12伏电源：模拟相机电压一般为12V。HDMI线：树莓派视频输出接口为HDMI接口，如果显示器不支持HDMI接口，则需要配置一个HDMI转VGA接口的线。 1.2 可选器材列表 万用表：检验新买回的电源的电压是否正常，相机组装及故障时也会需要。电烙铁、锡丝、夹子、绝缘胶带、松香：电子产品DIY必备物品。相机板镜头接口：如果直接购买相机板，则需要在购买配套的镜头接口。相机盒：网上买的工业相机，有时候没有相机盒。AUTO IRIS接口：自动光圈控制线接口。不同的品牌和型号之间，自动光圈接口中4根线的对应位置会有所差异，或许需要手动调整接线。AV延长线：延长模拟相机的视频输出线。C/CS转接口：工业相机和镜头有C接口和CS接口之分，用于转接不匹配的相机和镜头。USB延长线：USB视频采集卡的USB线偏短，接上延长线后方便操作。三脚架：测试时放置相机。 2 DIY流星观测站硬件组装 所需器材列表：树莓派电脑（RPi3），5V树莓派电源，microSD卡，microSD读卡器，一个3厘米*3厘米风扇，3个铝合金散热片，一个DS3231时间模块
2.1 安装Raspbian操作系统 在树莓派官网下载最新版Raspbian镜像，通过microSD卡读卡器将Raspbian镜像安装到microSD上，详细的安装过程请参考官网教程Raspbian安装
2.2 安装散热片 将CPU和GPU的正反两面各粘一个散热片
2.3 安装树莓派保护壳： 上面两幅图是网上最便宜的“亚克力”保护壳，其实就是硬塑料，这种保护壳比较脆，在调试时需要频繁拆开外壳时，会非常不方便。左下角是另一种外壳，相对来说比较结实方便，右下角为安装好外壳的树莓派。
2.4 安装DS3231时间模块和风扇 DS3231时间模块应该插在靠里一排GPIO的前四个引脚上，如上图左图所示。 风扇接口应该插在靠外一排GPIO的第2和3个引脚上，如上图右图所示。
2.5 树莓派连接电脑 所需器材列表： - 显示器：查看显示器是否有HDMI、DVI或VGA接口 - 视频线：HDMI线、HDMI转VGA线、或HDMI转DVI线，取决于显示器的视频输入接口 - USB鼠标和键盘：树莓派一共4个USB接口，测试时或许会不够用，使用USB键鼠套装可以省一个USB接口。 - 网线：更新系统，安装软件 2.6 连接模拟相机（数字相机的支持正在研发当中） 所需器材列表：USB视频采集卡(UTV007)，Sony673相机或WATEC WAT-902H相机，12V电源，两公头AV线。
取一根两端都是公头的AV线，一段接在相机的视频输出接口（AV母头），另一端接在USB视频采集卡(UTV007)的黄色视频输入母头。 2.7 联机测试 将相机和树莓派电脑连接起来，测试电脑是否能从相机正常采集图像。
打开终端（可通过快捷方式Crtl+Alt+T打开），安装mplayer：
sudo apt-get install mplayer
通过mplayer可以预览相机的视频，如果是NTSC相机，则在命令行运行：
mplayer tv:// -tv driver=v4l2:device=/dev/video0:input=0:norm=NTSC -vo x11
如果是PAL相机，则在命令行运行：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4fc766e2f7be5dcbe1532240b03c1ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/279771ef3991eb504361a170b5054feb/" rel="bookmark">
			python解包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解包在英文里叫做 Unpacking，Python 中的解包是自动完成的，例如：
&gt;&gt;&gt; a, b, c = [1,2,3] &gt;&gt;&gt; a 1 &gt;&gt;&gt; b 2 &gt;&gt;&gt; c 3 除了列表对象可以解包之外，任何可迭代对象都支持解包，可迭代对象包括元组、字典、集合、字符串、生成器等实现了__next__方法的一切对象。
元组解包
&gt;&gt;&gt; a,b,c = (1,2,3) &gt;&gt;&gt; a 1 &gt;&gt;&gt; b 2 &gt;&gt;&gt; c 3 字符串解包
&gt;&gt;&gt; a,b,c = "abc" &gt;&gt;&gt; a 'a' &gt;&gt;&gt; b 'b' &gt;&gt;&gt; c 'c' 字典解包
&gt;&gt;&gt; a,b,c = {"a":1, "b":2, "c":3} &gt;&gt;&gt; a 'a' &gt;&gt;&gt; b 'b' &gt;&gt;&gt; c 'c' 字典解包后，只会把字典的 key 取出来，value 则丢掉了。
如果在解包过程中，遇到左边变量个数小于右边可迭代对象中元素的个数时该怎么办？ 在 Python2 中，如果等号左边变量的个数不等于右边可迭代对象中元素的个数，是不允许解包的。但在 Python3 可以这么做了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/279771ef3991eb504361a170b5054feb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f685759f7dd610ee7de649f4afc99d/" rel="bookmark">
			springboot vue 登陆发送请求（跨域问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot vue 登陆发送请求（跨域问题）02 2017年09月28日 22:17:32
阅读数：2124
1.前后端分离之间进行通讯首先要进行跨域请求,以前的做法就是写个过滤器来操作，还有就是nginx代理了。 现在用vue和springboot都有新的方式 第一种 vue2 本身也支持跨域，开发过程中支持这个，方便 第二种 springboot 简单一个类就可以支持 第三种 生产环境用nginx就不用说了，必须的。像什么复杂的代理请求和负载等等都可以 先弄第一种 引入resource 在App.vue 加入请求方法 methods: { getData () {
var that = this.$http.get('api/sysuser/list') .then(function (response) { console.log(response.data) console.log(this) that.serverData = response.data }) .catch(function (error) { console.log(error) }) } 1234567891011 } 2.第二种 springboot 配置也可以 去掉之前vue代理请求就提示跨域问题了，我们先删除代理运行看看 访问地址修改成 再次访问就有跨域问题 接下来在项目种加入CorsConfig类，如图 @Configuration public class CorsConfig extends WebMvcConfigurerAdapter{ @Override public void addCorsMappings(CorsRegistry registry) { System.out.println("----------------------"); registry.addMapping("/**") .allowedOrigins("*") .allowCredentials(true) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4f685759f7dd610ee7de649f4afc99d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad90f3afe1a85ca089588fb84e219420/" rel="bookmark">
			[转] Delphi7 内存管理及 FastMM 研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Delphi7 内存管理及 FastMM 研究[转]
作者：刘国辉
一、引言
FastMM 是适用于delphi的第三方内存管理器，在国外已经是大名鼎鼎，在国内也有许多人在使用或者希望使用，就连 Borland 也在delphi2007抛弃了自己原有的饱受指责的内存管理器，改用FastMM.
但是，内存管理的复杂性以及缺乏 FastMM 中文文档导致国内许多人在使用时遇到了许多问题，一些人因此而放弃了使用，我在最近的一个项目中使用了FastMM，也因此遇到了许多问题，经过摸索和研究，终于解决了这些问题。
二、为什么要用FastMM
第一个原因是FastMM的性能接近与delphi缺省内存管理器的两倍，可以做一个简单的测试，运行下面的代码：
var
I: Integer;
Tic: Cardinal;
S: string;
begin
tic := GetTickCount;
try
for I := 0 to 100000 do
begin
SetLength(S, I + 100);
edt1.Text := S;
end;
finally
SetLength(S, 0);
tic := GetTickCount - Tic;
MessageDlg('Tic = ' + IntToStr(Tic), mtInformation, [mbOK], 0);
end;
end;
在我的IBM T23笔记本上，使用FastMM4（FastMM的最新版本）用时约为3300ms，而使用缺省的内存管理器，用时约为6200ms，FastMM4的性能提高达88%.
第二个原因FastMM的共享内存管理器功能使用简单可靠。当一个应用程序有多个模块（exe和dll）组成时，模块之间的动态内存变量如string的传递就是一个很大的问题，缺省情况下，各个模块都由自己的内存管理器，由一个内存管理器分配的内存也必须在这个内存管理器才能安全释放，否则就会出现内存错误，这样如果在一个模块分配的内存在另外一个模块释放就会出现内存错误。解决这个问题就需要使用到共享内存管理器，让各个模块都使用同一个内存管理器。Delphi缺省的共享内存管理器是BORLNDMM.DLL，这个内存管理器并不可靠，也常常出现问题，并且，在程序发布的时候必须连同这个DLL一起发布。而FastMM的共享内存管理器功能不需要DLL支持，并且更加可靠。
第三个原因是FastMM还拥有一些帮助程序开发的辅助功能，如内存泄漏检测功能，可以检测程序是否存在未正确释放的内存等。
三、出现什么问题
如果我们开发的应用程序，只有一个exe模块，那么，使用FastMM是一件非常简单的事情，只需要把FastMM.pas（最新版是FastMM4.pas）作为工程文件的第一个uses单元即可，如：
program Test;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad90f3afe1a85ca089588fb84e219420/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3691960aa1567c00a965f317bd831347/" rel="bookmark">
			android RGB颜色值调节亮度，饱和度，色调；hsv与rgb转化。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##android RGB颜色值调节亮度，饱和度，色调
好久没写博客了，最近在做一个物联网的项目其中涉及到控制七彩灯设备，要求可以调节灯光的颜色，包括亮度，饱和度，色调，刚开始做这个七彩灯的时候也不知道16进制的rgb怎么能调节亮度，饱和度，色调。那只有百度上搜喽。推荐两个博客第一个第二个；这两个看完基本也就了解的差不多了。下面我就结合我的项目来说说怎么hsv与rgb之间互相转化。
主要用到的就是 如下方法，传两个参数。官方说注释写的挺详细的。
/** * Convert the ARGB color to its HSV components. * &lt;ul&gt; * &lt;li&gt;&lt;code&gt;hsv[0]&lt;/code&gt; is Hue \([0..360[\)&lt;/li&gt;（色调，取值范围0-360） * &lt;li&gt;&lt;code&gt;hsv[1]&lt;/code&gt; is Saturation \([0...1]\)&lt;/li&gt;（饱和度，取值范围0-1） * &lt;li&gt;&lt;code&gt;hsv[2]&lt;/code&gt; is Value \([0...1]\)&lt;/li&gt;（亮度，取值范围0-1） * &lt;/ul&gt; * @param color the argb color to convert. The alpha component is ignored.(16进制RGB颜色值) * @param hsv 3 element array which holds the resulting HSV components.(长度3的float数组) */ public static void colorToHSV(@ColorInt int color, @Size(3) float hsv[]) { RGBToHSV((color &gt;&gt; 16) &amp; 0xFF, (color &gt;&gt; 8) &amp; 0xFF, color &amp; 0xFF, hsv); } 我就简单介绍下怎么使用这个方法吧。直接伪代码演示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3691960aa1567c00a965f317bd831347/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311300fca3807d0a851e5accef02be6d/" rel="bookmark">
			【RBAC基于角色的权限控制（一）】RBAC权限数据库设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 -- 管理员-&gt;权限表 DROP TABLE IF EXISTS `b_admin_permissions`; CREATE TABLE `b_admin_permissions` ( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'ID', `name` varchar(64) NOT NULL DEFAULT '' COMMENT '权限名称', `controller` varchar(32) NOT NULL DEFAULT '' COMMENT '控制器', `action` varchar(32) NOT NULL DEFAULT '' COMMENT '方法', `description` varchar(255) NOT NULL DEFAULT '' COMMENT '描述', `pid` int(10) NOT NULL DEFAULT '0' COMMENT '父ID 0-顶级', `level` tinyint(1) NOT NULL DEFAULT '0' COMMENT '权限级别：0-顶级 1-一级', `create_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', `is_deleted` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否删除 0-否 1-是', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '管理员-&gt;权限表'; -- 管理员-&gt;角色表 DROP TABLE IF EXISTS `b_admin_roles`; CREATE TABLE `b_admin_roles` ( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'ID', `name` varchar(64) NOT NULL DEFAULT '' COMMENT '角色名称', `description` varchar(255) NOT NULL DEFAULT '' COMMENT '角色描述', `create_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', `is_deleted` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否删除 0-否 1-是', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '管理员-&gt;角色表'; -- 管理员-&gt;角色-&gt;权限表 DROP TABLE IF EXISTS `b_admin_role_permissions`; CREATE TABLE `b_admin_role_permissions` ( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'ID', `role_id` int(10) NOT NULL DEFAULT '0' COMMENT '角色ID', `permission_id` int(10) NOT NULL DEFAULT '0' COMMENT '权限ID', `create_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', `is_deleted` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否删除 0-否 1-是', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '管理员-&gt;角色-&gt;权限表'; -- 管理员表 DROP TABLE IF EXISTS `b_admins`; CREATE TABLE `b_admins` ( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'ID', `username` varchar(64) NOT NULL COMMENT '用户名', `password` char(32) NOT NULL COMMENT '密码', `nickname` varchar(32) NOT NULL DEFAULT '' COMMENT '昵称', `realname` varchar(32) NOT NULL DEFAULT '' COMMENT '真实姓名', `role_id` int(10) NOT NULL COMMENT '角色ID 0-超级管理员', `create_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', `is_deleted` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否删除 0-否 1-是', PRIMARY KEY (`id`), UNIQUE KEY `idx_username` (`username`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '管理员表'; -- 管理员-&gt;操作记录表 DROP TABLE IF EXISTS `b_admin_operation_records`; CREATE TABLE `b_admin_operation_records` ( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'ID', `username` varchar(64) NOT NULL COMMENT '用户名', `type` tinyint(1) NOT NULL DEFAULT '0' COMMENT '操作类型 0-未知 1-新增 2-修改 3-删除', `module_name` varchar(64) NOT NULL DEFAULT '模块名', `id_container` varchar(32) NOT NULL DEFAULT '' COMMENT '主键', `description` varchar(1000) NOT NULL DEFAULT '' COMMENT '操作描述', `remark` text DEFAULT NULL COMMENT '备注', `create_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', `is_deleted` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否删除 0-否 1-是', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '管理员-&gt;操作记录表'; -- 管理员-&gt;会话表 DROP TABLE IF EXISTS `b_admin_sessions`; CREATE TABLE `b_admin_sessions` ( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'ID', `session` char(32) NOT NULL DEFAULT '' COMMENT '会话ID', `login_ip` char(15) NOT NULL DEFAULT '' COMMENT '登录IP', `login_time` datetime NOT NULL DEFAULT '0000-01-01 00:00:00' COMMENT '登录时间', `admin_id` int(10) NOT NULL DEFAULT '0' COMMENT '管理员ID', `create_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', `is_deleted` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否删除 0-否 1-是', PRIMARY KEY (`id`), UNIQUE KEY `idx_session` (`session`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '管理员-&gt;会话表'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adac3ba00bfd0c8f8a69bd352f9821ff/" rel="bookmark">
			SQL server数据库迁移方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在我们开发某些项目后，难免会遇到更换服务器，重新部署数据库的时候，那么问题来了？究竟怎么如何操作才能达到最佳效果；
起源： （1）：起初仅仅是为了测试用，所以迁移的时候不必把数据库中的数据全部迁移过去，仅仅需要数据库的架构即可；
（2）：某些时候需要更换服务器，那么此时已经在内部存储了大量数据了，此时只能把架构+数据全部迁移过来；
解说： 以本地“Login”数据库为例，帮助大家理解四种迁移方式；
一：“分离”---&gt;“附加”
说明：
（1）或许会遇到分离数据库后，无法在其它服务器附加数据库的问题（权限不够，自行更改属性）
（2）推荐把数据库放到默认的数据库文件存放目录（E:\Microsoft SQL Server\实例根目录\MSSQL12.SQLEXPRESS\MSSQL\DATA）；
（3）数据库文件可以设置jia兼容级别，高版本兼容低版本
二：“脱机”---&gt;“附加”
说明：暂时脱离管理数据库，进行资料拷贝后，在重新联机即可；
三： “备份”---&gt;“还原”
说明：为的是还原原始数据，防止误操作，类似于保存不同版本信息；
四：生成“SQL脚本”
说明：兼容性最好，轻松避免数据库迁移的其它问题
如果感觉本篇文章，还不错的话，记得评论、点赞支持吆！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c44b8005723ae54819a6710af8033fdd/" rel="bookmark">
			Linux下Maven的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Maven，是一个软件（特别是Java软件）项目管理及自动构建工具，由Apache软件基金会所提供。基于项目对象模型（POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。曾是Jakarta项目的子项目，现为独立Apache项目。
现在有很多Apache项目都已经开始采用Maven进行管理。
本篇文章简单介绍了Maven的相关知识，以及在Linux下的安装与使用方法。如果需要进一步了解Maven，请移步Maven官网。http://maven.apache.org
安装Maven Maven的下载地址：http://maven.apache.org/download.cgi
这里以最新的3.2.3版本为例进行安装，在这之前需要确保机器上已经安装了JDK。
首先下载Maven并解压，并移动到usr/local目录下
$ wget http://mirror.bit.edu.cn/apache/maven/maven-3/3.2.3/binaries/apache-maven-3.2.3-bin.tar.gz
$ tar vxf apache-maven-3.2.3-bin.tar.gz
$ mv apache-maven-3.2.3 /usr/local/maven3
修改环境变量，在/etc/profile中添加以下几行
MAVEN_HOME=/usr/local/maven3
export MAVEN_HOME
export PATH=${PATH}:${MAVEN_HOME}/bin
记得执行source /etc/profile使环境变量生效。
最后运行mvn -v验证maven是否安装成功，如果安装成功会打印如下内容
Apache Maven 3.2.3 (33f8c3e1027c3ddde99d3cdebad2656a31e8fdf4; 2014-08-12T04:58:10+08:00)
Maven home: /usr/local/maven3
Java version: 1.7.0_65, vendor: Oracle Corporation
Java home: /usr/lib/jvm/java-7-openjdk-amd64/jre
Default locale: en_US, platform encoding: UTF-8
OS name: "linux", version: "3.13.0-35-generic", arch: "amd64", family: "unix"
使用Maven创建项目 无论是学习语言还是框架，先来一个Hello World基本上已经是套路了，我们也通过构建一个Hello World项目来了解如何使用Maven。
首先通过maven创建helloworld项目
$ mvn archetype:create -DgroupId=helloworld -DartifactId=helloworld
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c44b8005723ae54819a6710af8033fdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd71c6d7f89e0b6cecfea7a596a3ea2d/" rel="bookmark">
			Oracle索引使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-- 索引：普通索引、唯一索引、复合索引
create index XX on tableNamep[colName]
使用索引的好处，就是检索效率快，和使用主键、rowid(物理地址) 差不多，使用主键检索的实质就是使用ROWID(物理地址)
eg:
create unique index 索引名 on tablename(列名)
create index index_test_ah on t_indextest(id,name);
select * from t_indextest where id = 777580 and name = 'aa7775
-- 索引：普通索引、唯一索引、复合索引 create index XX on tableNamep[colName] -- 创建一个普通索引 -- 创建索引的好处，就是检索效率快，和使用主键、rowid(物理地址) 差不多，使用主键检索的实质就是使用ROWID(物理地址) create index index_orders_name on t_owners(name); create table T_INDEXTEST (ID NUMBER,NAME1 VARCHAR2(30),NAME2 VARCHAR2(30),NAME3 VARCHAR2(30),NAME4 VARCHAR2(30),NAME5 VARCHAR2(30)); begin for x in 1..1000000 loop insert into T_INDEXTEST values (x,'aa'||x,'bb'||x,'cc'||x,'dd'||x,'ee'||x); end loop; commit; end; create index index_test on T_INDEXTEST(name); select * from t_indextest where id = 777580 select * from t_indextest where name = 'aa777580' select rowid,t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd71c6d7f89e0b6cecfea7a596a3ea2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3216bc05b4859bad87be5cdf5844e86/" rel="bookmark">
			KBEngine使用记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部分引用KBEngine官网的一些句段，感谢kbe。
下列符号解释 =：继承 ==：等同 +：与上具有子关系
CellAppMgr:管理多个CellApp
+CellApp:管理多个区域
+ Cell：一个区域
==Space：等同Cell
+此区域上的玩家entity：代表玩家
+Witness（对象）：监视周围的玩家entity，将发生的事件消息同步给客户端
+AOI（兴趣范围）：默认500M
+GhostEntitys（list）：存取此区域边沿外界一定距离内的玩家entity的列表
+GhostEntity：从邻近的Cell的对应的entity的部分数据的拷贝的实体
+属性数据：只读，如果某个属性对于客户端是可见的，那么该属性必须是可以存在
Ghost的，例如：当前的武器、等级、名称
+范围：默认500M，可配置，大于等于玩家的AOI
+负载平衡：CellApp会告诉它们的Cell的边界应该在哪里
+新建的玩家Entity加入到正确的Cell上
+一个服务器组一个Mgr实例
DBMgr：管理Entity数据的数据库存储
+存数据：在BaseApp间轮流调度处理，BaseApp向CellApp要entity的cell部分的数据再定时转给DBMgr存储
Machine：监视服务器进程信息，每个服务器机器上有一个machine
+作用：启动/停止服务器进程，通知服务器群组各个进程的存活状态，监视机器的使用状态：cpu/内存/带宽
+machine不会tcp连接的
ObjectPool：对象池，一些对象频繁的被创建，例如：moneystream，bundle，tcppacket等等，这个对象池通过服务端峰值有效的预
估提前创建一些对象缓存起来，在用到的时候直接从对象池中提取
SmartPoolObject：智能池对象，创建一个智能池对象，与相应的对象池绑定，只要此对象析构时，那么会调用绑定的对象池进行
回收
Components：组件类，记录当前组件信息
ServerApp：App基类，每个app都需继承这个类，基本的C++框架模块 都会存在这个类，其中有继承通道超时操作，继承通道取消注册操作，
Resmgr：资源类，存有一切环境信息，例如bin或者资源目录，和一些已打开文件
ThreadPool：线程池类
NetWork：网络
+Bundle：发送的包裹
+Packet：接收的包裹
+NetworkInterface：理解为网络上下文对象。
+EndPoint：对端，可以理解成与对端的会话信息及与对端网络的解决方案。硬封装 创建socket，绑定，监听，recv，send函数
+ListenerRecviver：保存有对端对象，特性，网络上下文对象（NetworkInterface）
+EventDispatcher：事件分配，封装着一个poller和一个Task（Task可以add，所以这个类又是一个可以作为多任务分配的任务集），接口基本都是用poller，注册事件。异步IO的体现
+Channel：代表着一个连接，成员有EndPoint，TcpPacketReceiver，TcpPacketSender，Init时会将fd注册到poller，接收到的包裹经过过滤器存放到bufferPacket，然后bufferPacket会被NetworkInterface类调用processChannels时调用本类的processPackets进行处理
+onPacketReceived方法：这个方法里是用来判断及计数的，例如lastTickBytesRecevied 这个成员变量是用来对一帧之内recv多次直至为空产生的数据量进行计数，查看TcpPacketReceiver这个类的processRecv方法与PacketReceiver::handleInputNotification方法，计数时要进行与kbengine.def配置的参数进行判断及处理
+PacketReader： 包裹阅读器，具有解单包功能，和操作单包，是在Channel被调用processPackets时被调用本类的processMessages函数
+TcpPacketReceiver = PacketReceiver：封装了接收行为，是驱动者，操作接受行为时是被调用processRecv这个方法，方法里操作：创建packet，调用EndPoint的recv，再调用本类的processPacket，processPacket中调用channel的onPacketReceived，过滤包裹形成可用包；processRecv被PacketReceiver::handleInputNotification(intfd)这个方法循环调用
+TcpPacketSender = PacketReceiver：封装了发送行为，是驱动者，创建包裹，最终是调用EndPoint的发送函数
+TcpPacket = Packet：tcp包裹，一个Channel会存放多个Packet，
+PacketFilter：包裹过滤器，将Packet存放到Channel，被PacketReceiver调用processPacket函数时调用了本类的recv函数，是在传输层recv后，立即调用的，也就是没放到buffer，还没调用到Channel类的processPackets函数之前
+ WebSocketPacketFilter=PacketFilter：继承于PacketFilter，重写PacketFiler的recv和send，因为websocket会有web格式包头信息，所以要先过滤掉
EpollPoller =EventPoller：网络模型类，使用epoll封装的消息事件类
SelectPoller=EventPoller：网络模型类，使用select封装的消息事件类
PyFileDescriptior：python层的文件描述类，用于设置Python的相对应的网络消息回调方法，网络事件触发时，会调用相对应的回调
内存结构：
MoneyStream：内存流
函数的认识：
QueryPerformanceCounter()：获取高性能计时器从开机到调用的tick数
QueryPerformanceFrequency()：获取高性能计时器的赫兹 也就是每秒多少次tick
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3216bc05b4859bad87be5cdf5844e86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42d96eeeff4aba9d5a370c44dd2cc04/" rel="bookmark">
			javaee 操作excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在http://jareye.com/上下载JXL架包操作 读取工作薄：Workbook workbook=Workbook.getWorkbook(new File(“myfile.xls”));
读取工作表：Sheet sheet=workbook.getSheet(0);
读取单元格：Cell c2=sheet.getCell(2,1);//单元格是从（0,0）开始的
读取单元格的值：1.通过cell的getContents方法
String string2=c2.getContents();
2.cell提供一个getType()方法
能够返回单元格的类型信息，同时JXL提供了一个CellType类用来预设Excel中的类型信息，而且JXL提供了一些Cell类的子类用来分别用来表示各种类型的单元格，如LabelCell，NumberCell，DateCell分别表示字符、数值、日期类型的单元格
if (c2.getType() == CellType. LABEL) { LabelCell nc = (LabelCell) c2; String number b2 = nc. getString();
}
if (c2.getType() == CellType. DATE) { DateCell nc = (DateCell) c2; Date number b2 = nc. getDate();
}
if (c2.getType() == CellType.NUMBER) { NumberCell nc = (NumberCell) c2; double number b2 = nc.getValue();
}
每次操作完都要释放资源 workbook.close();写excle操作 4.1通过WritableWorkbook WritableSheet Label可以实现对EXcle文件的插入工作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c42d96eeeff4aba9d5a370c44dd2cc04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcb98b1768807a4082241614b22a0b8f/" rel="bookmark">
			Oracle数据库的了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle数据库（一）
Oracle 是一个数据库管理系统，是Oracle公司的核心产品。其在数据安全性与安整性控制方面的优越性能，以及跨操作系统、跨硬件平台的数据操作能力。基于“客户端/服务器”(Client/Server)系统结构。
主要特点：
1.支持多用户、大事务量的事务处理。
2.在保持数据安全性和完整性方面性能优越。
3.支持分布式数据处理。将公布在不同物理位置的数据库用通信网络连接起来，组成一个逻辑上统一的数据库，完成
数据处理任务。
4.具有可移植性。Oracle可以在Windows、Linux等多个操作系统平台上使用。
Oracle基本概念：
1.数据库。这里的数据库是磁盘上存储数据的集合，在物理上表现为数据文件、日志文件和控制文件等。在逻辑上以表空
间形式存在。必须首先创建数据库，然后才能用Oracle。可以在Database Configuation Assistant上创建。
2.全局数据库名。用于区分一个数据库的标识。它由数据库名称和域名构成，类似网络中的域名，使数据库的命名在整个
网络环境中唯一。
3.数据库实例。每个启动的数据库都对应一个数据库实例，由这个实例来访问数据库中的数据。
4.表空间。每个数据库都是由若干个表空间构成的，用户在数据库中建立的所有内容都被存储到表空间中。一个表空间可
以由多个数据文件组成，但一个数据文件只能属于一个表空间。
5.数据文件。扩展名是.dbf，是用于存储数据库数据的文件。一个数据文件中可能存储很多个表的数据，而一个表的数据
也可以存放在多个数据文件中。数据文件和数据库表不存在一对一的关系。
6.控制文件。技展名.ctl，是一个二进制文件。控制文件是数据库启动及运行所必需的文件。存储数据文件和日志文件的
名称和位置。Oracle 11g默认包含三个控制文件。
7.日志文件。扩展名.log，它记录了数据的所有更改信息，并提供了一种数据恢复机制，确保在系统崩溃或其他意外出现
后重新恢复数据库。在工作过程中，多个日志文件组之间循环使用。
8.模式和模式对象。模式是数据库对象(表、索引等，也称模式对象)的集合。
Windows下Oracle数据库服务：
1.OracleServiceSID服务是Oracle数据库服务。此服务对应名为SID(系统标识符)的数据库实例创建的。必须启动。
2.OracleOraDb11g_homelTNSListener服务是监听器服务。要远程连接数据库服务器，必须连接监听进程，该服务只有
在数据库需要远程访问时候才需要。(PL/SQL等第三方工具连接就相当于远程连接)。
3.OracleDBConsoleSID服务是数据库控制台服务，是采用浏览器方式打开的，用于使用Oracle企业管理器的程序。如
果进入 基于Web形式的企业管理(EM)控制平台，必须要启动OracleDBConsoleSID服务。
连接数据库：
Sys和System用户都是Oracle的系统用户，Scott用户是Oracle数据库的一个测试账户，里男包含一些测试例表。每
个用户下所有的对象称为模式对象。
1.用SQL Plus工具登录：
1)cmd-&gt;sqlplus-&gt;用户名：-&gt;密码:
2)直接打开程序SQL Plus-&gt;用户名：-&gt;密码
3)在输入用户名处-&gt;用户名/密码@网络服务名
4)命令窗口：sqlplus /nolog 这样就只是打开了sqlplus而并没有连接数据库，之后要连接数据库得继续敲：
connect 用户名/密码@数据库名;
2.PL/SQL Developer工具：
1)用户名：输入System.
2)口令：输入对应密码。
3)数据库：输入已经配置好的网络服务名,如orclDB。
4)连接为:Normal普通用户;sysOper数据库操作员;sysDBA数据库管理员。
3.Java连接Oracle:
driver: oracle.jdbc.driver.OracleDriver
url: jdbc:oracle:thin:@localhost:1521:数据库名
DUAL伪表，在Oracle的查询语句中select和from关键字一定有值，但在某些情况下不需要from,如查询常量或函数，为
了满足要求，Oracle使用DUAL伪表来实现要求。
如: select sysdate from dual;–查询出当前系统日期和时间
Oracle数据类型：
1.字符数据类型：
1)char数据类型。当需要固定长度字符串时，使用char。长度1~2000字节。如果没有指定大小，默认1字节。如果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcb98b1768807a4082241614b22a0b8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c934e0db31fcf0f0305afa4cabb7fda7/" rel="bookmark">
			rocketmq的有序消费模式和并发消费模式的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rocketmq消费者注册监听有两种模式，有序消费MessageListenerOrderly和并发消费MessageListenerConcurrently，这两种模式返回值不同。
MessageListenerOrderly正确消费返回ConsumeOrderlyStatus.SUCCESS，
稍后消费返回ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT
MessageListenerConcurrently正确消费返回ConsumeConcurrentlyStatus.CONSUME_SUCCESS
稍后消费返回ConsumeConcurrentlyStatus.RECONSUME_LATER
顾名思义，有序消费模式是按照消息的顺序进行消费，但是除此之外，在实践过程中我发现和并发消费模式还有很大的区别的。
第一，速度，下面我打算用实验来探究一下。
使用mq发送消息，消费者使用有序消费模式消费，具体的业务是阻塞100ms
Long totalTime = 0L; Date date1 = null; Date date2 = new Date(); new MessageListenerOrderly() { @Override public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context) { logger.info("==========CONSUME_START==========="); logger.info(Thread.currentThread().getName() + " Receive New Messages: " + msgs.size()); try { if(date1 == null) date1 = new Date();//在第一次消费时初始化 Thread.sleep(100); logger.info("total:"+(++total)); date2 = new Date(); totalTime = (date2.getTime() - date1.getTime()); logger.info("totalTime:"+totalTime); logger.info("==========CONSUME_SUCCESS==========="); return ConsumeOrderlyStatus.SUCCESS; }catch (Exception e) { logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c934e0db31fcf0f0305afa4cabb7fda7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2cf26d1493ee89301aaf2344573dfe0/" rel="bookmark">
			用ssm写一个web的增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用ssm写一个web的增删改查
如果不想自己写的话，这里有完整的项目连接
链接：https://pan.baidu.com/s/1YnAyGy7Hpxoyma5sqGFX8Q 密码：lwdh
项目结构
每个包下包含哪些文件如下图
首先写 application.properties spring.datasource.url=jdbc:mysql://localhost:3306/itcast //itcast是你的数据库名 spring.datasource.username=root spring.datasource.password=123456 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver mybatis.config-location=classpath:Mybatis-config.xml //这条信息是关于Mybatis的总配置文件的路径 第二写总配置文件 Mybatis-config.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; //总配置文件的规则 &lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias alias="Clazz" type="com.gxj.model.Clazz"/&gt; &lt;typeAlias alias="Student" type="com.gxj.model.Student"/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource="com/gxj/model/Clazz.xml"&gt;&lt;/mapper&gt; //分文件Clazz.xml的路径 &lt;mapper resource="com/gxj/model/Student.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt; //分文件Student.xml的路径 &lt;/configuration&gt; Clazz.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.gxj.dao.ClassDao"&gt; &lt;insert id="InsertClass" parameterType="Clazz"&gt; insert into class (name,size) values(#{name},#{size}) &lt;/insert&gt; &lt;select id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2cf26d1493ee89301aaf2344573dfe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68957229b271547e121bb0c6571a5915/" rel="bookmark">
			binder ANR案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.分析event_log，确定发生anr的进程和时间点
例：11-13 14:32:05.085 1091 1116 I am_anr : [0,25453,com.google.android.gms.persistent,-1194836411,Broadcast of Intent { act=android.intent.action.SCREEN_OFF flg=0x50000010 }]
2.分析traces文件
例：
"main" prio=5 tid=1 Native
| group="main" sCount=1 dsCount=0 obj=0x756188c8 self=0xb3004400
| sysTid=25453 nice=0 cgrp=bg_non_interactive sched=0/0 handle=0xb63ba534
| state=S schedstat=( 1644024933 1944634424 4080 ) utm=131 stm=33 core=3 HZ=100
| stack=0xbe48c000-0xbe48e000 stackSize=8MB
| held mutexes=
at android.os.BinderProxy.transactNative(Native method)
at android.os.BinderProxy.transact(Binder.java:622)
at android.app.ActivityManagerProxy.getContentProvider(ActivityManagerNative.java:4440)
at android.app.ActivityThread.acquireProvider(ActivityThread.java:5597)
at android.app.ContextImpl$ApplicationContentResolver.acquireUnstableProvider(ContextImpl.java:2256)
at android.content.ContentResolver.acquireUnstableProvider(ContentResolver.java:1566)
at android.content.ContentResolver.query(ContentResolver.java:521)
at android.content.ContentResolver.query(ContentResolver.java:479)
确定ContentProvider的跨进程通信，看binder_info
3. 分析binder_info
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68957229b271547e121bb0c6571a5915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7162270851f27db2190652634058bfb9/" rel="bookmark">
			JSON字符串转换为java的list&lt;Map&gt;类型的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List&lt;Map&gt; meterList= JSONArray.parseArray(paraMap.get("metersList").toString(),Map.class); 记录一下
其中metersList是一个json格式的字符串
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3253cad2d8c4825738b5d35d6db19e4e/" rel="bookmark">
			应用层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络应用是计算机网络存在的理由，如果我们不能构想出任何有用的应用，也就没有任何必要去设计支持它们的网络协议了。
网络应用程序体系结构： 客户-服务器体系结构 客户-服务器体系结构当中，有一个24小时打开的主机称为服务器，服务于多个客户（多个主机），最简单的就是Web浏览器向服务器发送的请求，可以把不同的浏览器看作是客户，客户发出请求，服务器接收到请求后再作响应。
注意一点的是：主机是有很多个，但是服务器不一定只有一个，如果服务器只有一个，那么当客户逐渐增加的时候，就会使得服务器过载，所以，需要配置大量的主机才可以减轻每个主机的负载
P2P体系结构 P2P，也就是点对点，无需通过服务器，可以进行两个客户，也就是两台主机之间的直接通信。
多数应用程序是由通信进程对组成的，进行通信的实际上是进程，比如浏览器发送请求给服务器，发送的则为客户，接收的则为服务器，就算是再P2P体系当中，两个对等方进行传数据，接收的那方的进程就叫做客户，上传的那方进程就叫做服务器。客户进程要发送请求给服务器进程需要通过一个套接字的软件接口向网络发送报文和从网络接收报文，套接字就是进行网络通信的接口。
TCP/UDP： TCP：在应用层数据报文发送之前，TCP就会在客户和服务器搭建起连接。一个TCP连接之后，双方就可以在这个连接上进行报文的发送和接收，当结束了发送和接收，我们就需要拆除连接。
UDP：是一种不提供不必要服务的轻量级运输协议，仅仅提供最小的服务，和之前的分组交换差不多，因此UDP在两个进程没有进行连接的时候，UDP协议提供一种不可靠的数据传送服务，为什么叫做不可靠，是因为没有连接，所以不能够保证传出去的数据能够被接收方的进程去接收
应用层的协议： 应用层协议定义了运行在不同端上的应用程序进程如何相互传递报文，其中包括了
1）交换的报文类型，
2）各种报文类型的语法，如报文中的各个字段以及这些字段是怎么描述的
3）字段的语义，即这些字段中包含信息的含义
4）一个进程何时以及如何发送报文，对报文进行响应的规则
WEB和HTTP： Web应用的协议是HTTP（HyperText Transfer Protocol）超文本传输协议，HTTP由两个程序实现，一个是客户程序，一个是服务器程序，两者通过交换HTTP报文进行通信。
Web页面是由对象组成的，一个对象只是一个文件，比如一个html文件，一个jpeg的图片，一个gif动态视频。如果一个Web页面包含了HTML文本和一张图片，那么这个Web页面就有两个对象
Http是基于TCP协议，Web客户首先需要建立起和Web服务端的连接，HTTP是无状态协议，也就是Web客户端向Web服务端发送两次相同的请求，Web服务端还是会响应两次相同的数据，不会保存关于客户的任何信息。
因为HTTP是基于TCP协议的，所以客户端发送一系列请求，有两种方式，一种是非持续连接：就是每个请求由一个单独的TCP连接发送，第二种是持续性连接，每个请求由同一个单独的TCP进行连接。默认方式是使用持续连接
非持续连接有一些缺点：必须为每一个请求的对象建立和维护一个全新的连接，而发起一个TCP连接，涉及了三次握手，效率很低，并且由于TCP太多，服务器每次握手要进行一个TCP的缓存空间的一个分配，就会给Web服务器带来严重的负担
采用持续连接的情况下，服务器发送相应后保持该TCP连接打开，在相同的客户与服务器的第二次请求和响应中就能够通过相同的连接进行传送
Cookie：
那么我们需要一个东西就是Cookie，那么Cookie是用来弥补HTTP的无连接性的
Cookie就是相当于一个笔记本，每次进行一次请求响应，就记录在一个小本子上，然后即使失忆，看看笔记本就想起来了，Cookie就是充当一个笔记本，进行记录
在我们进行第一次发送请求给服务器的时候，服务器会放回一个Cookie给我们的客户端
然后Cookie的分类，有两种：第一种就是会话Cookie，第二种就是持久Cookie
两个的区别，会话Cookie：首先要知道什么是一个会话：简单来说，当一个浏览器打开到关闭之前，进行的操作就是一次会话
也就是会话Cookie是这样子的，我们的Cookie时间直到我们的浏览器关闭就没了，下次打开就没了Cookie，举个简单实例，你一次登陆了，关闭登陆再去访问你就要重新登陆
那么持久性Cookie是什么，所谓持久性，就是可以人为去定制一段时间，这时候，这段Cookie存放的位置在我们的磁盘里面，写成了一个文件，下次请求的时候，首先去磁盘读取我们的Cookie，然后再去发送请求
Session：
Session是存放在服务器端的，相对于cookie，会给服务器造成压力
当我们第一次发送请求的时候，上述我们提高一个概念，叫做会话，我想到一个更好的例子，那就是打电话，A和B两个人，A问的一句话就是一个请求，B的回答就是一个响应，所以什么是一次话，就是AB打完电话结束了，挂了，就是一次会话，一次会话里面可能存放着很多次请求和响应
同样的，在第一次发送请求的时候，服务器会把该客户端的信息记录下来，归成一个表结构，然后这次服务器会返回一个东西，叫做SessionId,这个Id就是用来找到我们刚刚保存的信息的，一一匹配，那么这个SessionId保存在哪里呢？保存在Cookie里面，所以说，如果我们没有Cookie，Session也是不能够正常运行的
Web缓存
Web缓存器也叫做代理服务器，Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象副本。
FTP： FTP（File Transfer Protocol）文件传输协议：
DNS： 因特网的主机需要进行标识，而主机名的标识可以通过主机名或者IP地址，比如www.baidu.com的主机名，127.0.0.1的IP地址，
我们需要一种能过够进行主机名到IP地址转换的目录服务。这就是DNS（Domain Name System）域名系统的任务
DNS是一个由DNS服务器实现的分布式数据库，是一个使得主机能查询分布式数据库的应用层协议，DNS服务器通常是运行BIND软件的UNIX辑器，DNS协议基于UDP上，使用53号端口
简单来说，DNS就是将用户提供的主机名解析为IP地址，浏览器访问的时候发出一个HTTP请求报文到Web服务器，首先把主机名传给DNS应用的客户端，DNS客户端向DNS服务器发出一个包含主机名的请求，DNS服务器会响应该主机名的一个IP地址，然后返回给浏览器，再根据IP地址进行TCP连接
DNS也可以用来负载均衡，繁忙的站点被冗余分布再多台服务器上，每台服务器均运行再不同的端系统上，每个都有着不同的IP地址，DNS数据库中存储IP地址的集合，当客户对映射的主机名字发出一个DNS请求时，该服务器用IP地址的整个集合进行响应。
DNS的服务器有三种：
1）根DNS服务器
2）顶级域DNS服务器
3）权威DNS服务器
DNS缓存：
原理：在一个请求链当中，某DNS服务器接收一个DNS回答的时候，它能够将该回答中的信息缓存在本地存储器当中，我们查询DNS服务器的过程是根据多个节点返回的一个IP地址对去进行反复请求，说的通俗一点就是你要找一个目的地，你问了很多人才知道怎么走，那么下次你就把这条路线，可以直接去寻找，而不用一个一个问
文件分发
文件分发这种应用从单一服务器向大量主机分发一个文件，服务器必须向每一个客户发送该文件的一个副本，这样子服务器就会承受了比较大的负担，而在P2P文件分发当中，每个对等方能够重新分发所有该文件的任何部分，基于BitTorrent（一种用于文件分发的P2P协议）这里有个概念叫做洪流：参与一个特定文件分发的所有对等方的集合叫做洪流，当一个对等方加入洪流的时候，开始接收文件，这个文件会被很多块，慢慢的，第一个对等方就会有块了，那么当它继续下载块的时候，也能够同时给别的对等方提供块，，然后每个对等方在加入洪流之前首先需要在一个追踪器里面去注册自己，并且周期性通知追踪器自己的信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9918d1d3eb7f702150719d63f17be50/" rel="bookmark">
			eclipse显示An error has occurred,See error log for more details. java.lang.NullPointerException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当eclipse显示
An error has occurred,See error log for more details. java.lang.NullPointerException，刷新或者clean以及更新maven project都报错时，而且problem视图不显示什么原因，如图： 解决方法： 首先从图中无法看出是什么错误，需要刷新eclipse, 找到eclipse目录，打开cmd,在eclipse目录下执行eclipse -clean,自动启动eclipse 启动之后会出现提示错误信息
org.xml.sax.SAXParseExceptionpublicId: platform:/resource/java8_web/src/main/webapp/WEB-INF/web.xml; systemId: platform:/resource/java8_web/src/main/webapp/WEB-INF/web.xml; lineNumber: 2; columnNumber: 23; 元素类型 “web-app” 必须后跟属性规范 “&gt;” 或 “/&gt;”。
找到web.xml,将&lt;web-app&gt;标签里的内容删除即可，然后在maven update project即可
删除前： 删除后： 引起上述原因是由于之前JDK版本为1.7,对应的Dynamic web module 为 2.4 切换JDK1.8之后,默认Dynamic web module 为 3.1,因此web.xml中&lt;web-app&gt;中的2.4版本已经不适应了，当然可以修改当中版本等信息，如果不会改，直接删除即可
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/430/">«</a>
	<span class="pagination__item pagination__item--current">431/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/432/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>