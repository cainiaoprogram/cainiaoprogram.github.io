<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a127b6c64b78a4c94b74d50e1a74da5/" rel="bookmark">
			Vue报错：Syntax Error: TypeError: eslint.CLIEngine is not a constructor 的解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、首先找到vue.config.js 然后搜索lintOnSave,然后把后面的那一串改为false
2、然后点击上面信息进行配置 3、选第一个选项 禁用ESLint，点击ok运行 即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f38c490197c5a3cfeb4d7e9efb5a58/" rel="bookmark">
			来，带你一次性搞懂数据分析和数据挖掘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直都有很多朋友想要学习数据分析，希望小编可以推荐一些靠谱的书。
大家要么是看到了数据的重要性，想要转行做数据分析师，要么是本职工作需要，想要学习一些数据分析相关的知识来赋能自己的工作。
无论怎样，数据分析这项技能真的是被越来越多的人所需要，而对于在职场上的发展有更高追求的小伙伴，更是有深入学习数据挖掘的打算！
那么，数据分析与数据挖掘之间有怎样的关系？有了数据分析基础是否可以更容易上手数据挖掘？在学习路径方面又需要注意些什么呢？
数据分析是指用适当的统计方法对收集的海量数据进行分析、提取有用的信息和形成结论，然后对数据加以详细研究和概括总结的过程。
有些人将数据分析划分为描述性数据分析、探索性数据分析和验证性数据分析。
其中，探索性数据分析侧重于在数据之中发现新的特征，而验证性数据分 析则侧重于对已有假设的证实或证伪。
数据挖掘一般是指从海量的数据中通过相应的算法，挖掘其中有价值（未知的、有规律的）的信息的复杂过程。
许多人把数据挖掘看作另一个常用的术语“KDD （Knowledge Discovery in Database）”的同义词，而还有一些人只是把数据挖掘看作KDD 过程中的一个基本步骤。
KDD 可直译为“基于数据库的知识发现”（简称“知识发现”），是指从海量的数据中提取有效的、新颖的、 潜在有用的、最终可被理解的模式的过程，如下图所示为KDD 过程。
数据挖掘是深层次的数据分析，数据分析是浅层次的数据挖掘，数据挖掘更偏重于探索性数据分析，因为数据挖掘的重点是从数据中发现知识规律。
它们的具体区别如下：
（1）数据分析处理的数据量可能不大；而数据挖掘处理的数据量极大， 并且特别擅长处理大数据，尤其是几十万行、几百万行，甚至更多的数据。
（2）数据分析往往是从一个假设出发，需要自行建立方程或模型来与假设吻合；而数据挖掘不需要假设，可以自动建立方程，比如关联规则和聚类分析。
（3）数据分析往往处理数值型数据；而数据挖掘能够处理不同类型的数据，比如声音、文本等。
（4）数据分析主要侧重于通过观察数据来对历史数据进行统计学分析；而数据挖掘通过从数据中发现“知识规律”来对未来的某些可能性做出预测分析，其更注重分析数据间的内在联系。
（5）数据分析与数据挖掘的区别更多地体现在职业方向上。相对数据挖掘工程师，数据分析师与业务方的工作衔接更多，理解与梳理业务诉求、 明确业务目的和指导模型搭建是数据分析师的主要工作；而模型搭建与参数调优则是数据挖掘工程师的工作。
其实，在很多情况下，数据分析与数据挖掘是“同源同根”的。也就是说，数据分析与数据挖掘没有明确的界限。
如果想从数据中提取一定的规律（即认知），则往往需要将数据分析和数据挖掘结合使用。因为在计算机中，数据都是以0和1的形式进行存储的，从这个层面上讲，数据分析的范畴更大一些。
而在以上区别（5）中所说的两者不同的分工也是在大公司中会分得比较明确，如果是在中小公司中，（5）中所说的工作都是由一个人完成的。
所以，想要学习数据挖掘肯定还是需要有相关的数据分析基础。
那么，怎样可以高效快速地掌握数据分析和数据挖掘呢？
大家在搜索学习方法时，肯定会发现要学习的东西很多，不仅要掌握分析工具、分析语言，还要学习统计学、机器学习算法等等。
虽然这些确实是需要掌握的内容，但也都只是实现某种业务目的的工具。想要真正做好数据分析和数据挖掘，使其真正赋能实际业务，具备良好的数据思维才是关键。
《数据分析与挖掘算法：Python实战》一书便深刻阐述了数据思维的重要性，并将数据思维上升到哲学高度。
此外，本书也对从数据处理到数据分析进行了全流程说明，对经典的数据挖掘算法从理论到Python实践逐步深入讲解，使读者不仅知其然知其所以然，也使读者可以联系生活中的例子进行实操。
一本书，讲明了数据分析与挖掘的重点，帮你从底层扎实地建立起知识框架，带你快速体验实践数据分析与挖掘的乐趣，非常值得想要学习数据分析与挖掘的读者入手！
图片
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4054b7c4a8f9c5d41148057c67193b52/" rel="bookmark">
			WIC(wake-up interrupt controller)介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cortex-m处理器处于sleep mode或deep sleep mode时，处理器需要外部中断信号来唤醒，才能继续执行指令，在deep sleep mode下，处理器可能没有时钟，甚至已经被断电（具体行为取决于芯片设计者，arm并没有明确规定），并不能接收到外部中断信号，因此为了能够正确唤醒处理器，需要一个电路来接收外部中断信号，并通知片上PMU(Power Management Unit)给处理器提供时钟或电源，并在处理器可以接收中断后，将收到的中断信号送回给处理器，但这一功能是可选的。WIC就是实现这一功能的电路。下图是WIC在芯片中位置的一个示意图。
WIC在处理器休眠前，需要接收来自NVIC的中断屏蔽信息并加以保存，并在处理器处于休眠状态时不能断电，但是它不需要可编程寄存器，甚至可以在处理器休眠时不需要时钟，只要能根据中断屏蔽信息和收到的外部中断信号，及时通知PMU即可。下图是使用WIC时，处理器进入并退出休眠状态的工作流程图。
在某些芯片设计或某些处理器版本中可能并没有WIC，那么WIC的功能就取决于芯片设计者，一个可行的方案是直接把这一功能的子模块集成到PMU中。
下图是power on/off的典型sequence示意图，图中给出了时钟，ISO，RETAIN/RESTORE, power on/off的流程示意图。在power on sequence中，复位应该在power up到restore之间从低变高。
下图是一个详细的power sequence波形图。参考资料：The Definitive Guide to Arm Cortex-M3 and Cortex-M4 ProcessorsSystem-on-Chip Design with Arm® Cortex®-M Processors
Low Power Methodology Manual for Soc Design
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b25cd47e1ac957e61de2fe3d140e5e9d/" rel="bookmark">
			前端动态网页技术JS（JavaScript)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
静态网页和动态网页
动态网页
网页是如何和后端交互的呢？
JS概述
什么是JS
名词解释
特点和优势
入门案例
HTML中引入JS
通过script标签引入JS代码
通过script标签引入外部的JS文件
JS语法
注释
基本数据类型
JS的变量
JS的运算符
JS语句
if…else语句
switch…case语句
循环语句（for）
JS数组
JS数组的声明方式
数组需要注意的细节
JS函数
方式二：通过函数直接量声明函数
JS对象
内置对象
自定义对象
DOM树的作用
组成
DOM树结构
Document对象
dom.html
–2,测试
总结
json（数据交换格式）
概念
作用
语法
转换工具
测试 静态网页和动态网页 动态网页 我们有了html超文本标记语言实现了网站页面展现，展现文字、表格、图片、超链接等，有了css样式表实现了页面的美化，这些技术实现了静态网页。
日常展现是已经足够了，但是如果我们要做个注册功能呢？如论坛，我们注册个论坛来发文章，聊天。这就带来一个问题，信息如何根据不同的使用者，展现不同的内容呢？再如我注册登录和你注册登录，我们在网站上显示的登录名称就不同。这html+css就无能为力了，它们无法实现，那谁能办到呢？这时javascript就派上用场了。它能实现浏览器用户和后台服务器进行交互。注册、登录、添加商品到购物车、下订单对它而言都是小菜一碟。有了javascript的加入，实现页面和后台系统的交互，实现用户信息的注册，实现用户的登录，实现个性化的数据展现，功能强大不老少。业界把这样的网页称为动态网页，把这样的网站称为动态网站。
简而言之，静态网站只能看，不同浏览者看到内容一致不能变化；动态网站可以读写数据，内容根据不同浏览者展示不同的信息。
网页是如何和后端交互的呢？ 动态网站的软件架构是怎样的呢？
用户访问页面，页面触发事件创建XHR对象，进行ajax请求，请求访问服务器端，请求被web中间件拦截并进行处理，由控制层框架springmvc中的controller进行接收，controller请求业务层spring框架的service服务，service请求持久层mybatis框架的mapper映射，mapper访问数据库。操作完数据库，返回结果，mybatis封装成java对象传回service，service把java对象传回controller，controller把java对象又转换为json字符串，然后传回浏览器，浏览器传回给调用者XHR，XHR调用回调方法callback，callback进行json字符串的解析，从中拿到要展现的数据，通过javascript处理，最终回显到页面上。
可以看到这个调用过程是非常复杂的，跨越网络，跨域多个服务器，很多技术应用其中，而这一切的始作俑者是谁呢？谁让这一切成为可能，它就是javascript，它实现了用户的请求和响应，实现了数据的动态展现，使早期静态的网站走向了动态的网站。
JS概述 什么是JS JavaScript 是 web 前端开发者必学的三种语言之一：
1.HTML 定义网页的内容 H5
2.CSS 规定网页的布局 CSS3
3.JavaScript 实现网站的交互 ES6
JavaScript在1995年由Netscape公司的Brendan Eich，在网景导航者浏览器上首次设计实现而成。因为Netscape与Sun合作，Netscape管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它们根本没有关系，java是强语言几乎无所不能，而javascript是脚本语言，只局限于浏览器。
JavaScript遵循ECMA国际组织颁布的ECMAScript标准。截至 2012 年，所有浏览器都完整的支持ECMAScript 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b25cd47e1ac957e61de2fe3d140e5e9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5733e574a8012ecee7c4de7883572dad/" rel="bookmark">
			Spring之动态代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态代理和静态代理角色一样动态代理的代理类是动态生成的，不是我们写好的动态代理分为两大类：基于接口的动态代理，基于类的动态代理
1.基于接口–JDK动态代理
2.基于类：cglib
3.java字节码实现：javasist 需要了解两个类：Proxy(代理),
InvocationHandler（代理实例的调用处理程序的接口）
动态代理的好处
可以使真是角色的操作更加纯粹！不用关心一些公共的业务
公共交给代理角色，实现了业务的分工
公共业务发生拓展的时候，方便集中管理
一个动态代理类代理的是一个接口，一般对应的一类业务
一个动态代理类可以代理多个类，只要实现了同一个接口即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c35e13dad98e271c419822ff5b0c2d/" rel="bookmark">
			go regex 使用case
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一则使用regex 的异常case：问题背景
对redis执行命令“info memroy”后返回的结果进行了处理转化成了字符串，然后通过regex匹配目标项，就出现了诡异的现象，暂时没有对regex的内部做深入研究，欢迎理解原因的大佬不吝赐教
对redis执行info memroy并处理后的结果集存入变量replySlice中，为string类型
func TestSendRedisExecMsgToServer(t *testing.T) { var syncMsg *pb.ManagerTaskMsg syncMsg = &amp;pb.ManagerTaskMsg{ Timestamp: time.Now().Unix(), TaskId: 111, TaskType: pb.TaskType_REDIS_CMD_EXEC, MsgType: &amp;pb.ManagerTaskMsg_TaskExecRedis{ TaskExecRedis: &amp;pb.ManagerTaskExecRedis{ ServerType: "redis", Port: 7017, RedisCmd: "info memory", }, }, } redisRespons, err := SendRedisExecMsgToServer(syncMsg, "xx.xx.xx.xx:6999") Convey("send redis exec message to proxy success", t, func() { So(err, ShouldBeNil) }) reply, err := AnalyseRedisStrReply(redisRespons) fmt.Printf("replySlice: %v\n", reply) replySlice输出为
replySlice: ��[]uint8 �~�z# Memory used_memory:202238584 used_memory_human:192.87M used_memory_rss:3141632 used_memory_rss_human:3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29c35e13dad98e271c419822ff5b0c2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aed8aff26adf28bddccca1a8803ddcf0/" rel="bookmark">
			HashMap底层实现原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、HashMap底层实现原理解析 我们常见的有数据结构有三种结构：
数组结构链表结构哈希表结构 下面我们来看看各自的数据结构的特点：
1）数组结构： 存储区间连续、内存占用严重、空间复杂度大
优点：随机读取和修改效率高，原因是数组是连续的（随机访问性强，查找速度快）
缺点：插入和删除数据效率低，因插入数据，这个位置后面的数据在内存中都要往后移动，且大小固定不易动态扩展。
2）链表结构：存储区间离散、占用内存宽松、空间复杂度小
优点：插入删除速度快，内存利用率高，没有固定大小，扩展灵活
缺点：不能随机查找，每次都是从第一个开始遍历（查询效率低）
3）哈希表结构：结合数组结构和链表结构的优点，从而实现了查询和修改效率高，插入和删除效率也高的一种数据结构
HashMap底层是哈希表结构
HashMap中的put()和get()的实现原理：
1）map.put(k,v)实现原理
（1）首先将k,v封装到Node对象当中（节点）。
（2）然后它的底层会调用K的hashCode()方法得出hash值。
（3）通过哈希表函数/哈希算法，将hash值转换成数组的下标，下标位置上如果没有任何元素，就把Node添加到这个位置上。如果说下标对应的位置上有链表。此时，就会拿着k和链表上每个节点的k进行equal。如果所有的equals方法返回都是false，那么这个新的节点将被添加到链表的末尾。如其中有一个equals返回了true，那么这个节点的value将会被覆盖。
2、map.get(k)实现原理
(1)先调用k的hashCode()方法得出哈希值，并通过哈希算法转换成数组的下标。
(2)通过上一步哈希算法转换成数组的下标之后，在通过数组下标快速定位到某个位置上。如果这个位置上什么都没有，则返回null。如果这个位置上有单向链表，那么它就会拿着K和单向链表上的每一个节点的K进行equals，如果所有equals方法都返回false，则get方法返回null。如果其中一个节点的K和参数K进行equals返回true，那么此时该节点的value就是我们要找的value了，get方法最终返回这个要找的value。
为何随机增删、查询效率都很高的原因是？
增删是在链表上完成的，而查询只需扫描部分，则效率高。
HashMap集合的key，会先后调用两个方法，hashCode and equals方法，这这两个方法都需要重写。
为什么放在hashMap集合key部分的元素需要重写equals方法？
因为equals方法默认比较的是两个对象的内存地址
二、HashMap红黑树原理分析 相比 jdk1.7 的 HashMap 而言，jdk1.8最重要的就是引入了红黑树的设计，红黑树除了插入操作慢其他操作都比链表快，当hash表的单一链表长度超过 8 个的时候，数组长度大于64，链表结构就会转为红黑树结构。当红黑树上的节点数量小于6个，会重新把红黑树变成单向链表数据结构。
为什么要这样设计呢？好处就是避免在最极端的情况下链表变得很长很长，在查询的时候，效率会非常慢。
红黑树查询：其访问性能近似于折半查找，时间复杂度 O(logn)；链表查询：这种情况下，需要遍历全部元素才行，时间复杂度 O(n)； 简单的说，红黑树是一种近似平衡的二叉查找树，其主要的优点就是“平衡“，即左右子树高度几乎一致，以此来防止树退化为链表，通过这种方式来保障查找的时间复杂度为 log(n)。
关于红黑树的内容，网上给出的内容非常多，主要有以下几个特性：
1、每个节点要么是红色，要么是黑色，但根节点永远是黑色的；
2、每个红色节点的两个子节点一定都是黑色；
3、红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）；
4、从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；
5、所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；
在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件 3 或条件 4，需要通过调整使得查找树重新满足红黑树的条件。
三、HashMap的原理1.7 和1.8 的区别 jdk1.7中底层是由数组+链表实现；jdk1.8中底层是由数组+链表/红黑树实现可以存储null键和null值，线程不安全初始size为16，扩容：newsize = oldsize*2，size一定为2的n次幂扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀 hash冲突
当两个key通过hashCod计算相同时（其实hashCode是随机产生的，是有可能hashCode相同）,则发生了hash冲突，开放定址法、再哈希法、链地址法、建立公共溢出区
HashMap解决hash冲突的方式是用链表。当发生hash冲突时，则将存放在数组中的Entry设置为新值的next，说白就是比如A和B都hash后都映射到下标i中，之前已经有A了，当map.put(B)时，将B放到下标i中，A则为B的next，所以新值存放在数组中，旧值在新值的链表上
开放定址法：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中再哈希法：同时构造多个不同的哈希函数，当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。链地址法：这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e62ffadda5848b488ca19bd43b3f0c0/" rel="bookmark">
			ROS下点云消息接收、TF关系获取和点云坐标系的转换,保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点云数据读取 读取点云数据有三种方法:
1.读取本地的pcd文件（没用过）;
给个pcd文件读取并发布的例子，需要的操作里面都有
//总得导入ros吧 #include &lt;ros/ros.h&gt; //导入消息格式 #include &lt;sensor_msgs/PointCloud2.h&gt; //导入pcl #include &lt;pcl_conversions/pcl_conversions.h&gt; #include &lt;pcl/point_cloud.h&gt; #include &lt;pcl/point_types.h&gt; int main(int argc, char **argv) { ros::init(argc, argv, "listener"); ros::NodeHandle nh; ros::Publisher pub; //设置发送的topic pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt; ("发送的topic", 100); //填写要导入的文件名 pcl::PCLPointCloud2::Ptr cloud2(new pcl::PCLPointCloud2); pcl::io::loadPCDFile ("要导入的文件", *cloud2); // Convert to ROS data type sensor_msgs::PointCloud2 output; pcl_conversions::fromPCL(*cloud2, output); //设置输出点云的坐标系 output.header.frame_id = std::string("base_link"); //发布 pub.publish (output); } 2.是从雷达读取topic（这个只要会使用雷达驱动也没问题）;
都是从topic里获取的数据，和下面的一起写
3.使用bag包;
使用bag包要注意我们要使用的是bag的时间还是系统当前的时间，如果想使用bag包的时间，要使用
//use_sim_time设置为true，此时说明系统使用的是bag包的仿真时间 //如果设置为false，则系统使用walltime //在使用bag之前在终端输入即可 rosparam set use_sim_time true //发布bag的 clock time rosbag play --clock 包名.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e62ffadda5848b488ca19bd43b3f0c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e26c426170c9cdad45a7e11ccd66da/" rel="bookmark">
			GNN是否能在通信领域中使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅个人观点，水平有限，欢迎指导。
初学通信领域中图神经网络(GNN)的应用时，会不由自主的产生为什么GNN能够应用在通信领域，能够解决通信领域的问题。
产生这一问题的原因在于，虽然理论上，只要给定足够的数据和正确的训练方式，在某个领域架构下的神经网络可以解决任何它所面对的任务，如图像处理或者推荐系统。但这些方向的样本数据的背后是存在相关性的，通过CNN或者GNN找出相关性来做分类或预测任务，但是通信问题背后似乎并不存在这样的相关性。
但并非如此，从宏观的角度来说，通信数据主要包含时间相关性和空间相关性。
时间相关性是指，信道数据中会包含接受设备（如车辆、手机等）的运动规律，如速度，方向，这些隐含信息可用于重构未来信道信息，从而提前制定传输方案，但这对设备的算力有一定的有一定的要求。
空间相关性是指，信道数据会受到接收设备环境信息、天气信息的影响，该隐含信息同样有助于提升重构未来信道信息时的可靠性。
从微观角度来说，电磁波之间的相互干扰也能体现通信系统之间的相关性。目前在通信领域中的波束设计、功率控制等问题上，可通过GNN寻找节点之间的相关性来达到功率、干扰与传输速率的均衡。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c3ffb429061d9c8ce592643a74f97ef/" rel="bookmark">
			一篇文章搞清楚Markdown
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。
特点
专注于文字内容；纯文本，易读易写，可以方便地纳入版本控制；语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版。 作用
Markdown 是做笔记、为网站创建内容以及生成可打印文档的快速、简便的方法
学习 Markdown 语法并不需要很长时间，一旦你知道如何使用它，你就可以在几乎所有地方使用 Markdown 进行书写了。大多数人使用 Markdown 来为网站创建内容，但是 Markdown 也可以很好地格式化从电子邮件到购物清单的所有内容。
基本语法 元素Markdown 语法标题# H1
## H2
### H3
#### H4
##### H5
###### H6段落使用空白行将一行或多行文本进行分隔。
若想实现首行缩进可以 &amp;emsp;&amp;emsp;换行在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(&lt;br&gt;)。强调粗体(Bold)：在文本前后各添加两个星号*
斜体(Italic)：在文本前后各添加一个星号，中间不要带空格。
粗体和斜体: 在文本前后各添加三个星号，中间不要带空格。引用创建块引用，请在段落前添加一个 &gt; 符号。列表有序列表：列表项前添加数字并紧跟一个英文句点。
无序列表：在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。
缩进一个或多个列表项可创建嵌套列表。围栏代码块在代码块之前和之后的行上使用三个反引号(```）或三个波浪号（~~~）。
可指定语言分割线在单独一行上使用三个或多个星号 (***)、破折号 (---) 或下划线 (___) 。
不能包含其他内容链接[超链接显示名](超链接地址 "超链接title") 示例：[时针随笔](https://www.garfield27.com/ "我的个人博客")
效果：时针随笔图片![图片alt](图片链接 "图片title") 图片链接: [![图片alt](图片链接 "图片title")](链接url) 原文链接：https://www.garfield27.com/2021/11/08/581d7c5dd942/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d1a60381f1ab7160a26d4d8d0987ed3/" rel="bookmark">
			数据处理：js数组根据数组对象中某个属性进行分组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：已知一数组，按数组中对象的id进行如下效果分组处理返回新的数组。
原数组：
[
{ id: ‘1’, oid: ‘100001’ },
{ id: ‘2’, oid: ‘100002’ },
{ id: ‘1’, oid: ‘100003’ },
{ id: ‘1’, oid: ‘100004’ },
]
处理后：
[
{ id: ‘1’, oid: [ ‘100001’, ‘100003’, ‘100004’ ] },
{ id: ‘2’, oid: [ ‘100002’ ] },
]
let arr = [ { id: '1', oid: '100001' }, { id: '2', oid: '100002' }, { id: '4', oid: '100003' }, { id: '2', oid: '100004' }, { id: '2', oid: '100005' }, { id: '4', oid: '100006' }, { id: '2', oid: '100007' }, { id: '1', oid: '100008' }, { id: '5', oid: '100009' }, ] let map = []; let res = []; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d1a60381f1ab7160a26d4d8d0987ed3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05ccc767b6cae6b312db8a98f80442dc/" rel="bookmark">
			面试总结之HTML部分(持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**HTML**：超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。
语义化标签 理解： 语义化的标签，旨在通过标签能理解其含义。
好处：
结构清晰，便于阅读。方便设备解析，如屏幕阅读器、移动设备等。有利于搜索引擎优化(SEO)。 常见语义化标签：
&lt;header&gt;：页面的头部区域，通常包括网站logo、导航及搜索框等内容。&lt;nav&gt;：页面的导航区域。&lt;main&gt;：页面的主体内容，一个页面只能使用一次。&lt;article&gt;：定义外部内容(页面的独立内容)。&lt;section&gt;：标记文档的章节、页眉、页脚等。&lt;aside&gt;：与主要内容相关的内容块，一般应用于侧边栏。&lt;footer&gt;：页面的底部区域，通常包括网站的备案、著作权信息、作者等信息。 列举块级元素、行内元素、行内块元素并说明其特点？ 块级元素： &lt;div&gt;、&lt;p&gt;、&lt;h1&gt; - &lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;li&gt;、&lt;form&gt;、&lt;table&gt;…
特点：
块级元素独占一行。高度，行高，内外边距可设置。宽度默认是容器100%。可容纳块级和行内元素。 行内元素： &lt;a&gt;、&lt;strong&gt;、&lt;span&gt;、&lt;label&gt;…
特点：
设置宽高无效。padding,margin水平可设置，垂直无效。容纳纯文本和其它行内元素（a标签除外）。 行内块元素： &lt;img&gt;、&lt;input&gt;、&lt;td&gt;…
特点：
可设置宽高、内外边距。和相邻的行内（行内块）元素在一行，中间有空白间隙。 src 和 href有何区别？ href 是建立一条通道，将当前文档和定义的资源连接起来。
src 是将定义的资源嵌入到当前文档。
Img元素的title和alt属性有何区别？ title 是全局属性，提供额外的提示信息，当鼠标滑到该元素，显示定义的提示。
alt 是局部属性，仅可用在img、input等元素中，提供在图片未载入或加载失败时的替代文本。当input的type为image时才能使用alt属性。
图像格式有哪些？什么特点？ gif：无损，简单动画，颜色少，有锯齿。
png：无损，压缩比高，色彩好，除了动画其余方面可取代gif。
jpeg：不支持透明，有损，存储照片或颜色丰富的复杂图像。
webp：chrome和opera支持，更优的图像数据压缩算法。
原文链接：https://www.garfield27.com/2021/11/11/d37289ef2b61/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d7c3ab4f6ca8933bb778f1022240e75/" rel="bookmark">
			Axure授权码，2021年11月11日亲测有效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Axure RP 9.0.0.3686 正式版
Licensee : yygg329405
KEY: QmNyZyXeMrJU+1yw6XiXZGenOs9R3wV7S+KS7K90yTk=
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e3ee4f5ba219f4fcf9f248dcf6b7f15/" rel="bookmark">
			yolov5 提速多GPU训练显存低的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yolov5多GPU训练显存低
修改前： 按照配置，在train.py配置如下：
运行 python train.py 后nvidia-smi 显示显存占用如下：
修改后 参考yolov5 官方中的issue中，有人提到的分布式多进程的方法：
在yolov5运行的虚拟环境下，找到torch的distributed 的环境：比如我的在conda3/envs/rcnn/lib/python3.6/site-packages/torch/distributed/；
在distributed文件下，新建多进程的脚本，命名为yolov5_launch.py：
import sys import subprocess import os from argparse import ArgumentParser, REMAINDER def parse_args(): """ Helper function parsing the command line options @retval ArgumentParser """ parser = ArgumentParser(description="PyTorch distributed training launch " "helper utility that will spawn up " "multiple distributed processes") # Optional arguments for the launch helper parser.add_argument("--nnodes", type=int, default=1, help="The number of nodes to use for distributed "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e3ee4f5ba219f4fcf9f248dcf6b7f15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1f308fac203d040155b04d9bb9dc28/" rel="bookmark">
			Ceph 存储介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Ceph 简介二、Ceph 特点三、Ceph 应用场景四、Ceph 核心组件五、Ceph 存储系统的逻辑层次结构六、RADOS 的系统逻辑结构七、Ceph 数据存储过程八、Ceph IO 流程及数据分布1. 正常 IO 流程图2. 新主 IO 流程图 九、Ceph Pool 和 PG 分布情况 一、Ceph 简介 ceph 是一种统一的分布式文件系统，具有优秀的性能、高可用性和可扩展性。ceph 的统一体现在可以提供文件系统、块存储和对象存储，分布式体现在可以动态扩展。在国内一些公司的云环境中，通常会采用 ceph 作为 openstack 的唯一后端存储来提高数据转发效率。
官网：https://ceph.com/官方文档：http://docs.ceph.com/docs/master/# 二、Ceph 特点 高性能：
摒弃了传统的集中式存储元数据寻址的方案，采用 CRUSH 算法，数据分布均衡，并行度高。考虑了容灾域的隔离，能够实现各类负载的副本放置规则，例如跨机房、机架、感知等。能够支持上千个存储节点的规模，支持 TB 到 PB 级的数据。 高可用性：
副本数可以灵活控制。支持故障域分隔，数据强一致性。多种故障场景自动进行修复自愈。没有单点故障，自动管理。 高可扩展性：
去中心化。扩展灵活。随着节点增加而线性增长。 特性丰富：
支持三种存储接口：块存储、文件存储、对象存储。支持自定义接口，支持多种语言驱动。 三、Ceph 应用场景 ceph 可以提供对象存储、块设备存储和文件系统服务，其对象存储可以对接网盘（owncloud）应用业务等；其块设备存储可以对接（Iaas）。当前主流的 Iaas 软件运行平台有：OpenStack、CloudStack、Zstack、Eucalyptus、kvm。
ceph 提供三大功能：
对象存储（RADOSGW）：提供 RESTful 接口，也提供多种编程语言绑定。兼容 S3、Swift。块存储（RDB）：由 RBD 提供，可以直接作为磁盘挂载，内置了容灾机制。文件系统（CephFS）：提供 POSIX 兼容的网络文件系统 CephFS，专注于高性能、大容量存储。 什么是块存储/对象存储/文件系统存储？
对象存储：
也就是通常意义的键值存储，其接口就是简单的 GET、PUT、DEL 和其他扩展，代表主要有 Swift 、S3、Gluster 等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b1f308fac203d040155b04d9bb9dc28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a19c4db42f3b59c9c975d1559cb9f7/" rel="bookmark">
			C语言/C&#43;&#43;学习路线图（2021整理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++是C语言的继承，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。C++擅长面向对象程序设计的同时，还可以进行基于过程的程序设计，因而C++就适应的问题规模而论，大小由之。
可以关注 微 信 公 众 号 “C和C加加” 回复 “ZXC” 即可获取 详细教程 和 PDF版！
接下来是小编整理过C/C++工程师必备知识的思维导图。
初学者看到这么密集的知识点，是不是有点眼晕呢？的确，C/C++是一门知识面覆盖很广的学科。想学好C/C++的你并不需要慌张，内容虽多，但依然有法可依。只要有足够的耐心和毅力，加上正确的学习方法，就不怕你学不好C/C++。
既然如此，C/C++开发到底需要学些什么呢，又应该怎么学呢？
一、初级入门阶段 在入门之初，首先要做的是通过C/C++语言的学习培养编程思维和动手能力，深刻理解面向过程和面向对象的思想方法。这个阶段你需要学习：
1、C语言 数据类型、变量、内存布局、指针基础；
字符串、一维数组、二维数组；
一级指针，二级指针，三级指针，N级指针概念，指针数组和数组指针；
结构体、文件的使用；
动态库的封装和设计；
函数指针回调函数。
2、C++语言 面向对象编程思想；
类的封装，构造和析构、静态成员、对象管理；
类的构造(有参构造函数、无参构造、拷贝构造、默认构造函数)和析构；
对象动态管理、友元函数、友元类、操作符重载；
C++编译器对象管理模型分析；
类对象的动态管理(new/delete)；
友元函数和友元类；
运算符重载(一元运算符、二元运算符、运算符重载难点、项目开发中的运算符重载)；
类的继承、多继承及其二义性、虚继承；
多态(概念、意义、原理剖析、多态案例)；
虚函数、纯虚函数、抽象类(面向抽象类编程思想案例)；
函数模板、类模板，模板的继承；
C++类型转换；
C++输入输出流(标准I/O 文件I/O 字符流I/O)；
C++异常处理(异常机制、异常类型、异常变量、异常层次结构、标准异常库)；
3、常见常用的IDE开发工具 可以参考这篇博文
最新C语言编程软件推荐（2021整理）_程序媛张小妍的博客-CSDN博客
此阶段的学习难度系数不大，掌握这些内容之后，可以做些简单的小项目。当然了如果你想用这些技能找工作的话确实是比较困难的。这时你还应该在加把劲进一步学习第二阶段。
二、C/C++开发进阶 这一阶段的目标才是达到C/C++软件工程师开发行业的基本要求，这个阶段是我们走向C/C++开发的进阶之路，更是一个让自己找份薪水比较体面的工作的筹码。
那么这个阶段，我们又应该掌握什么呢，继续往下看：
1、C++进阶之STL STL = Standard Template Library，即标准模板库。这是提高开发效率的极品工具。通过学习此阶段，应掌握泛型编程技巧，理解容器类在C++语言中的应用模式，以及熟练掌握全部STL类的使用方法。
2、C++进阶之设计模式 决定一个项目成败最重要的因素是项目总体的设计，通过本阶段的学习，可掌握面向对象编程中重要的一环，是编码前建模的技巧所在。单例模式；工厂模式；代理模式；迭代模式等，这些都是你要掌握的哦。
3、C++进阶之数据结构基础 这是所有编程语言中最应该学习的部分，程序组成的基础之一。
顺序存储、链式存储、循环链表；
双向链表、栈(顺序和链式)、队列(顺序和链式)；
栈的应用、树基本概念及遍历、二叉树；
排序算法、并归算法、选择、插入、快速、希尔。
4、C++进阶之UI界面开发 掌握QT类库构架，图形界面开发模型；
掌握QT开发技巧，消息机制，图形处理；
掌握QT网络编程，UDP，TCP使用方式；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2a19c4db42f3b59c9c975d1559cb9f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ed096a07daefbf7aaaa020cf9f70cb1/" rel="bookmark">
			Java String类型数据转为Byte数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方式一 我们可以直接通过Byte.decode()方式直接转化内
String str = "1"; Byte decode = Byte.decode(str); System.out.println(decode); 方式二 首先我们可以先将String转为int,然后将int转化内byte，然后最后将byte转为Byte
String str = "1"; int i = Integer.parseInt(str); Byte aByte = (Byte) (byte) i; System.out.println(aByte); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b541dfa163b41960e41b8a2cb5aeda9d/" rel="bookmark">
			2021-11-10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows命令提示符安装virtualenvwrapper-winMarkdown编辑器
当你windows电脑的命令提示符,pip命令用不了时，证明你的path环境没有配好。
且你的anaconda3没有事先配置好Path时，个人小小建议你，删了anaconda3，重新安装anaconda3，然后在最后一步勾选：
第一个add anaconda3 to my path environment variable(蓝色框框一定要勾，两个都勾就对了！一定要勾选！！！，然后电脑就会自动帮你配置好path路径，这对新手小白是最友好不过的了！）。
然后，这个时候，我们再去cmd打开，命令提示符：这时输入：
pip/pip3 install virtualenvwrapper-win
有两种情况：
第一种，网络不好，发出警告，如下图
这时，我们只需要再输入一下该代码就好了，并不是什么大问题，
安装好了！
第二种情况就是，直接安装好了，啥事没有。
可以检查一下，是否真的安装成功
输入：mkvirtualenv -h 查看帮助
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ee364d014d40fa3989553ab21ce71cc/" rel="bookmark">
			L2-040 哲哲打游戏 (25 分)（分析题目意思，读懂题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哲哲是一位硬核游戏玩家。最近一款名叫《达诺达诺》的新游戏刚刚上市，哲哲自然要快速攻略游戏，守护硬核游戏玩家的一切！
为简化模型，我们不妨假设游戏有 N 个剧情点，通过游戏里不同的操作或选择可以从某个剧情点去往另外一个剧情点。此外，游戏还设置了一些存档，在某个剧情点可以将玩家的游戏进度保存在一个档位上，读取存档后可以回到剧情点，重新进行操作或者选择，到达不同的剧情点。
为了追踪硬核游戏玩家哲哲的攻略进度，你打算写一个程序来完成这个工作。假设你已经知道了游戏的全部剧情点和流程，以及哲哲的游戏操作，请你输出哲哲的游戏进度。
输入格式：
输入第一行是两个正整数 N 和 M (1≤N,M≤10
5
)，表示总共有 N 个剧情点，哲哲有 M 个游戏操作。
接下来的 N 行，每行对应一个剧情点的发展设定。第 i 行的第一个数字是 K
i
​
，表示剧情点 i 通过一些操作或选择能去往下面 K
i
​
个剧情点；接下来有 K
i
​
个数字，第 k 个数字表示做第 k 个操作或选择可以去往的剧情点编号。
最后有 M 行，每行第一个数字是 0、1 或 2，分别表示：
0 表示哲哲做出了某个操作或选择，后面紧接着一个数字 j，表示哲哲在当前剧情点做出了第 j 个选择。我们保证哲哲的选择永远是合法的。
1 表示哲哲进行了一次存档，后面紧接着是一个数字 j，表示存档放在了第 j 个档位上。
2 表示哲哲进行了一次读取存档的操作，后面紧接着是一个数字 j，表示读取了放在第 j 个位置的存档。
约定：所有操作或选择以及剧情点编号都从 1 号开始。存档的档位不超过 100 个，编号也从 1 开始。游戏默认从 1 号剧情点开始。总的选项数（即 ∑K
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ee364d014d40fa3989553ab21ce71cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfa62bee9fcdd532146d5cef497a2643/" rel="bookmark">
			[计算机视觉] 相机成像模型之四个坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		世界坐标系、相机坐标系、图像坐标系、像素坐标系 1、四个坐标系简介 ​ 世界坐标系：描述相机位置，(Xw,Yw,Zw)
​ 相机坐标系：相机坐标系是连接图像物理坐标系与世界坐标系的桥梁，镜头的光心为原点，(Xc,Yc,Zc)，也是投影中心
​ 图像物理坐标系：相机坐标系的Z轴与图像的交点为原点，(x,y)
​ 像素坐标系：图像的左上角为原点，单位pixel，（u,v）
我们可以从拍摄的图片上一个点的坐标，利用相机内参外参，反推出世界中那个点的坐标，进行三维重建。
构建世界坐标系是为了更好的描述相机的位置在哪，在双目视觉中一般将世界坐标系原点定在左相机或者右相机或者baseline的中点。 2、世界坐标系与相机坐标系 ​ 属于刚体变换：物体不会发生形变，只需要发生旋转和平移（旋转矩阵R和平移向量T）
3、相机坐标系与图像坐标系 ​ 透视投影关系，从3D转换成2D
)
4、图像坐标系与像素坐标系 ​ 确定它们的关系之前，我们可以假设每一个像素在u轴和v轴方向上的物理尺寸为dx和dy，像素坐标系和图像坐标系都在成像平面上，只是各自的原点和度量单位不一样。图像坐标系的原点为相机光轴与成像平面的交点，通常情况下是成像平面的中点或者叫principal point。图像坐标系的单位是mm，属于物理单位，而像素坐标系的单位是pixel，我们平常描述一个像素点都是几行几列。
我们也可以用另一种矩阵表示方式：
解释：1、dx和dy表示感光芯片上像素的实际大小，是连接像素坐标系和真实尺寸坐标系的，u0和v0是图像平面中心，这些都是我们求的内外参数。
通过上面四个坐标系的转换就可以得到一个点从世界坐标系如何转换到像素坐标系的 ​ 一个三维中的坐标点，的确可以在图像中找到一个对应的像素点，但是反过来，通过图像中的一个点找到它在三维中对应的点就很成了一个问题，因为我们并不知道等式左边的Zc的值。
Realsense SDK直接能利用相机的内参和深度信息，将图像坐标系下的点还原到相机坐标系下。 相机内参：焦距（fx，fy），成像原点，畸变系数。相机坐标系使用毫米制单位，图像平面使用像素为单位，内参的作用就是在这两个坐标系之间进行线性的变换 dx和dy表示x方向和y方向的一个像素分别占多少个单位，是反映现实中的图像物理坐标关系与像素坐标系转换的关键
u0，v0代表图像的中心像素坐标和图像原点像素坐标之间相差的横向和纵向像素数，u0和v0一般不是正好是图像分辨率的一半，其是有偏差的，一般越好的摄像头则其越接近于分辨率的一半
相机外参：平移矩阵，旋转向量。世界坐标通过旋转平移到相机坐标 MATLAB标定工具箱：标定的像素误差在0.1左右
opencv的StereoClibration标定函数：标定的像素误差在0.4以上
realsense 相机内参结构体 intrinsics int width; 图片宽度（以像素为单位）
int height; 图片高度（以像素为单位）
float ppx; 图片主点水平坐标，以距左边缘的像素偏移量
float ppy; 图片主点垂直坐标，以距上边缘的像素偏移量
float fx; x方向上以像素为单位的焦距fx = f/dx, fy = f/dy
float fy; y方向上以像素为单位的焦距
rs2_distortion model; 图片畸变模型
float coeffs[5]; 畸变系数
什么是摄像机标定 为确定空间物体表面某点的三维几何位置与其在图像中对应点之间的相互关系，必须建立摄像机成像几何模型，这些几何模型参数就是摄像机参数。求解这些参数的过程称之为摄像机标定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfa62bee9fcdd532146d5cef497a2643/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5bfd86eff502b67d390f65db48a543f/" rel="bookmark">
			Spring事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.事务管理在系统开发中是不可缺少的一部分,Spring提供了很好事务管理机制,主要分为编程式事务和声明式事务两种.
编程式事务:是指在代码中手动的管理管理事务的提交,回滚等操作,代码入侵性比较强.
try { //TODO something transactionManager.commit(status); } catch (Exception e) { transactionManager.rollback(status); throw new InvoiceApplyException("异常失败"); } 声明式事务:基于AOP面向切面的,它将具体业务与事务处理 部分解耦,代码侵入性很低,所以,在实际开发中声明式事务用的比较多.声明式事务也有两种实现方式,一是基于TX和AOP的xml配置文件方式,二是基于@Transactional
@Transactional @GetMapping("/test") public String test() { int insert = cityInfoDictMapper.insert(cityInfoDict); } 二.@Transactional介绍
1.@Transactional注解可以作用于哪些地方?
@Transactional可以作用在接口,类,类方法.
作用于类时，该类的所有public方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。虽然@Transactional注解可以作用于接口的代理时才会生效，另外@Transactional注解应该只被应用到public方法上，这是由Spring AOP的本质决定的。如果你在protected，private或者默认可见性的方法上使用@Transactional注解，这将被忽略，也不会抛出任何异常。默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即时被调用方法使用@Transactional注解进行修饰。
2.propagation属性
propagation用于指定事务的传播行为，默认值为REQUIRED。propagation有七种类型，也就是事务属性传播行为方式。
3.isolation属性
isolation用于指定事务的隔离规则，默认值为DEFAULT。@Transactional的隔离规则和上文事务属性里面的隔离规则，如下图所示：
4.timeout用于设置事务的超时属性。
5. rollbackFor、rollbackForClassName、noRollbackFor、NoRollbackForClassName
rollbackFor、rollbackForClassName用于设置那些异常需要回滚；noRollbackFor、noRollbackForClassName用于设置那些异常不需要回滚。他们就是在设置事务的回滚规则。
三、@Transactional使用失效的场景：
1、@Transactional应用在非public修饰的方法上。如果Transactional注解应用在非public修饰的方法上，Transactional将会失效。
2、@Transactional注解属性propagation设置错误
3、@Transactional注解属性rollbackFor设置错误
4、在内部没有添加@Transactional的方法，调用了@Transactional方法时，当你调用时，他也不会回滚。
5、就是在@Transactional方法内部捕获了异常，没有在catch代码块里面重新抛出异常，事务也不会回滚。
6、创建表时，引擎是否是InnerDB。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e36581e06551e3cfcb62d986b6ea496/" rel="bookmark">
			解决yolov5使用onnxruntime推理时耗时问题（cpu环境）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yolov5将训练好的模型（yolov5s.pt）转换成onnx格式，在使用转换后的onnx格式的权重进行推理时作者使用如下语句：
# Inference if pt: visualize = increment_path(save_dir / Path(path).stem, mkdir=True) if visualize else False pred = model(img, augment=augment, visualize=visualize)[0] elif onnx: if dnn: net.setInput(img) pred = torch.tensor(net.forward()) else: pred = torch.tensor(session.run([session.get_outputs()[0].name], {session.get_inputs()[0].name: img})) else: # tensorflow model (tflite, pb, saved_model) 使用onnx权重模型时进到
pred = torch.tensor(session.run([session.get_outputs()[0].name], {session.get_inputs()[0].name: img})) 运行时，检测一张图片需要花费160-180ms
此时将上述语句替换成如下：
# Inference if pt: visualize = increment_path(save_dir / Path(path).stem, mkdir=True) if visualize else False pred = model(img, augment=augment, visualize=visualize)[0] elif onnx: if dnn: net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e36581e06551e3cfcb62d986b6ea496/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b2f1a651455514a20db34764b634c5/" rel="bookmark">
			阿里云产品介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、阿里云四大件1、云服务器ECS2、云数据库RDS3、负载均衡SLB4、对象存储OSS5、其他的云计算产品1）内容分发网络CDN：2）专有网络 VPC：2）弹性伸缩： 二、阿里云安全系列产品1、DDoS高防IP2、安骑士3、证书服务4、态势感知5、堡垒机 三、阿里云网络中间件相关消息队列MQ 四、阿里云万网产品1、域名2、虚拟主机3、企业邮箱4、云解析DNS公有云和私有云概念bai 概念img https://www.aliyun.com/product/rds/mysql?spm=a2cls.b92374736.J_8058803260.154.7c22357aBf09Yzecs创建操作步骤ecs优势 产品架构产品定价管理工具部署建议相关服务 什么是RDS为什么选择云数据库RDSmysql迁移上RDSmysql vpc基础架构背景信息原理描述逻辑架构 应用场景托管应用程序托管主动访问公网的应用程序跨可用区容灾业务系统隔离构建混合云多个应用流量波动大 cdn基本概念加速域名CNAME记录CNAME域名DNSSSL/TLS边缘节点源站回源回源HOST协议回源过滤参数 SLB负载均衡什么是负载均衡概述组成部分产品优势mysql迁移上云RDS 一、阿里云四大件 分类说比较好理解，先说阿里云的明星产品四大件吧，即云服务器ECS、云数据库RDS、负载均衡SLB和对象存储OSS。
1、云服务器ECS 云服务器ECS：云计算产品的基本款，几乎每个客户都必买的，云服务器从1核1G到32核64G（随着时间推移，配置会越来越高），各种优惠都有，不同时段有不同的优惠活动，可以参考阿里云惠网；关于服务器配置还可以随意升降配置，可以包年包月，也可以按量随用随买。对于很多小公司及个人，只购买一台云服务器ECS就够用了。对于稍微大一点的企业从性能、安全、加载速度等方面诸多考虑，可能需要购买其他的阿里云产品。
阿里云从云服务器ECS衍生出来很多云服务器系列，例如适用于初级用户的轻量应用服务器，还有为了迎合各种高性能场景的云服务器，诸如GPU云服务器、FPGA云服务器、神龙云服务器等，总之都是云服务器，是企业上云的基本款。
2、云数据库RDS 云数据库：目前主流是MySQL，阿里云提供MySQL、PostgreSQL，SQL Server，MongoDB，Memcache（Redis）等不同的数据库产品。相对于云服务器，云数据库属于非必需品，因为用户完全可以在云服务器上搭建数据库。由于自身业务发展需要，将数据库独立出来，这时候就需要阿里云的RDS云数据库了。
3、负载均衡SLB 负载均衡SLB：对多台云服务器进行流量分发服务。为了应对业务需求，企业往往会有多台云服务器提供服务器，负载均衡就是将用户的请求按照企业自定义的策略转发到最优的服务器。
4、对象存储OSS 如果企业静态文件较多（图片、视频等大文件），可以将大量的存储内容转移独立出来，放到对象存储OSS里面。
5、其他的云计算产品 以上四款产品，系阿里云云计算产品的四件套。下面再介绍阿里云其他的云计算产品：
1）内容分发网络CDN： 内容分发网络，假设企业的云服务器在杭州，那么位于东北地区的用户访问速度就会比较慢，CDN可以解决这个问题，CDN将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。
2）专有网络 VPC： 大家普遍会给阿里云打上公有云的标签，实际上阿里云可以提供的不仅仅是公有云，还有私有云、混合云等。专有网络VPC可以帮助企业在阿里云构建出一个隔离的网络环境，用户可以自定义IP 地址范围、网段、路由表和网关等，VPC可以提供更安全和灵活的网络环境，为我们构建混合云提供服务。
2）弹性伸缩： 传统的企业自建的私有机房是不具有弹性伸缩功能的，假设企业遇到业务波峰，只能通过人为的升级硬件来应对，业务回落时就会造成硬件资源的浪费，而弹性伸缩很好的解决了这个痛点。阿里云弹性伸缩可以管理您的集群，在高峰期自动增加ECS实例，在业务回落时自动减少ECS实例，节省基础设施成本。另外，这个弹性伸缩是免费的。
二、阿里云安全系列产品 有些乱，来说下阿里云应对网络安全方面的产品吧：
1、DDoS高防IP DDoS是目前比较常见的攻击方式，为了抵御DDoS攻击，用户可以通过配置高防IP，将攻击流量引流到高防IP，确保源站的稳定可靠。讲真，阿里云的DDoS高防IP还挺贵的。
2、安骑士 当用户购买了云服务器ECS后，可能会受到阿里云发送的安骑士漏洞风险短信，安骑士一款主机安全软件，为您提供主机漏洞检测、基线检查、病毒查杀、资产统一管理等功能，为您建立安全运维管理平台。安骑士企业版可以免费试用7天，之后想再使用，是需要付费的。
3、证书服务 我们在访问网站时，会在浏览器的地址栏中看到绿色的锁，意思是该网站是基于HTTPS协议的。前几年网站基本上都是基于http协议，阿里云百科网目前还是基于http协议，相对于http协议，https提供了一层加密服务，会更加安全一些。网站想要实现HTTPS，可以向阿里云申请签发证书服务器，即我们常说的SSL证书。阿里云目前可以申请到免费的SSL证书（Symantec赛门铁克品牌）。
4、态势感知 态势感知说起来还比较高端，有点类似于先知的意思。态势感知会收集企业20种原始日志和网络空间威胁情报，利用机器学习还原已发生的攻击，并预测未发生的攻击，帮客户扩大安全可见性，并集中管理云上资产安全事件。
5、堡垒机 日防夜防家贼难防，开个玩笑哈。企业往往更加关注外部的安全威胁而忽略了企业内部，实际上运维人员误操作或者仿冒运维人员将对企业造成很严重的损失，更有甚至是致命的。例如：携程的宕机12小时事件，由于员工错误操作，删除了服务器代码，据不完全统计，携程宕机带来的直接损失就是每小时160万美金。堡垒机基于协议正向代理实现，对SSH、Windows远程桌面、SFTP等常见运维协议的 数据流进行全程记录，再通过协议数据流重组的方式进行录像回放，达到运维审计的目的。
三、阿里云网络中间件相关 消息队列MQ 说起消息队列，最典型的应用场景就是一年一度的双十一购物节，**消息队列是一个真正具备低延迟、高并发、高可用、高可靠，可支撑万亿级数据洪峰的分布式消息中间件。**当小仙女们开启大规模的剁手模式时，用户大量并发访问商品数据库，消息队列可以缓解瓶颈，减少页面响应时间，当然还有其他方面的功能优势，咱这里阿里云百科网就不过多赘述，双十一就是MQ的典型应用场景，大概就是这么个意思。
四、阿里云万网产品 1、域名 这个好像大家都知道，我还说说吧，比如阿里云百科的域名就是aliyunbaike.com
2、虚拟主机 新手建站一般都是从虚拟主机开始的，无需自己配置web环境，简单易管理，价格也便宜。
3、企业邮箱 企业邮箱就是以公司域名为后缀的邮箱，企业自建的邮件系统。目前各大互联网大佬，例如：阿里云、腾讯云、网易等都有提供免费版的企业邮箱，如果想解除诸多限制，可以选购阿里云的企业邮箱付费版。
4、云解析DNS DNS就是将你的域名解析到服务器的IP上，一般来讲域名解析是免费的，免费版就够用了。
公有云和私有云概念bai 公有云，第三方提供商用户能够使使用的云，公有云一般可通过 Internet 使用，可能是免费或成本低廉的。
私有云，是指企业自己使用的云，它所有的服务不是供别人使用，而是供自己内部人员或分支机构使用。私有云的部署比较适合于有众多分支机构的大型企业或政府部门。随着这些大型企业数据中心的集中化，私有云将会成为他们部署IT系统的主流模式。
简单的说：私有云就是你自己的家，只有自己或者你允许的人能住，一般你不愿意外人知道的隐私都放在家里；公有云就是收费景点，买了门票的都能进。
公有云和私有云的区别
IT设施的位置：当企业自己构建一个私有云平台的时候，IT基础设施是自己的，一般位于企业内部。而采用公有云平台的时候，IT基础设施是位于一个第三方的数据中心。这里有一个例外，那就是现在有一些服务提供商提出的虚拟私有云（VPC， Virtual Private Cloud）的概念，它指的是在第三方数据中心内部通过技术手段隔离出来的一个专用计算环境，并通过安全通道与企业相连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53b2f1a651455514a20db34764b634c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc30a7c9ae55b60a3bc167bba7e6ca50/" rel="bookmark">
			STM32串口通信实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串口配置的一般步骤：
①：串口时钟使能，GPIO时钟使能：RCC_APB2PeriphClockCmd();
串口作为外设，首先要使能时钟，使能串口引脚，譬如使能GPIOA的时钟
②：串口复位：USART_Delnit();这一步不是必须的。
③：GPIO端口模式设置：GPIO_Init();
初始化GPIO
④：串口参数初始化：USART_ lnit();
⑤：开启中断并且初始化NVIC（如果需要开启中断才需要这个步骤）
NVIC_lnit();
USART_ITConfig();
⑥：使能串口：USART_Cmd();
⑦：编写中断处理函数：USARTx_IRQHandler();
⑧：串口数据收发：
void USART_SendData();//发送数据到串口 DR
uint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据
⑨：串口传输状态获取
FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx,uint16_t USART_FLAG);
void USART_ClearlTPendingBit(USART_TypeDef* USARTx,uint16_t USART_IT);
#include "beep.h" #include "led.h" #include "stm32f10x.h" #include "delay.h" void My_USART1_Init(void) { GPIO_InitTypeDef GPIO_InitStruct; USART_InitTypeDef USART_InitStruct; NVIC_InitTypeDef NVIC_InitStruct; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA ,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 ,ENABLE); GPIO_Init(GPIOA,&amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Mode=GPIO_Mode_AF_PP; GPIO_InitStruct.GPIO_Pin=GPIO_Pin_9 ; GPIO_InitStruct.GPIO_Speed=GPIO_Speed_10MHz; GPIO_Init(GPIOA,&amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Mode=GPIO_Mode_IN_FLOATING; GPIO_InitStruct.GPIO_Pin=GPIO_Pin_10 ; GPIO_InitStruct.GPIO_Speed=GPIO_Speed_10MHz; USART_InitStruct.USART_BaudRate=115200; USART_InitStruct.USART_HardwareFlowControl=USART_HardwareFlowControl_None; USART_InitStruct.USART_Mode=USART_Mode_Rx|USART_Mode_Tx; USART_InitStruct.USART_Parity=USART_Parity_No; USART_InitStruct.USART_StopBits=USART_StopBits_1; USART_InitStruct.USART_WordLength=USART_WordLength_8b; USART_Init(USART1,&amp;USART_InitStruct); USART_Cmd(USART1,ENABLE); USART_ITConfig(USART1,USART_IT_RXNE,ENABLE); NVIC_InitStruct.NVIC_IRQChannel=USART1_IRQn; NVIC_InitStruct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc30a7c9ae55b60a3bc167bba7e6ca50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f36725715be0cfac40b65d0eb8e7657/" rel="bookmark">
			day4homework
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		a=list(range(30,80,10))[0, 81, 324, 729, 1296, 2025, 2916, 3969, 5184, 6561, 8100, 9801]【不同】：列表属于可变序列，可以任意修改列表中的元素。元组属于不可变序列，不能修改元组中的元素。因此，元组没有增加元素、修改元素、删除元素相关的方法。【相同】元素访问方式一样 r1={"name":"高小一","age":18,"薪资":30000,"city":"北京"} r2={"name":"高小二","age":19,"薪资":20000,"city":"上海"} r3={"name":"高小五","age":20,"薪资":10000,"city":"深圳"} a=[r1,r2,r3] 9. 集合是无序可变，元素不能重复。实际上，集合底层是字典实现，集合的所有元素都是字典中的“键对象”，因此是不能重复的且唯一的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b10ff50ad0fb26a1bcb41080fbd17ff/" rel="bookmark">
			深度学习笔记---多尺度网络结构归类总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是图像金字塔
1.1 高斯金字塔 ( Gaussian pyramid):
1.2 拉普拉斯金字塔（Laplacian pyramid）
1.3 DOG金字塔
2. 多尺度网络（MTCNN）
2.1 多尺度输入网络
2.2 多尺度特征融合网络
2.2.1 并行多分支网络
2.2.2 串行的跳层连接网络
3，多尺度特征预测融合网络
3.1 SSD 网络
3.2 SSH 网络
4，多尺度特征和预测融合网络 4.1 不同多尺度特征及预测方式的对比
4.1 FPN（Feature Pyramid Networks）的结构
4.2 FPN训练过程
1.什么是图像金字塔 图像金字塔是图像中多尺度表达的一种，最主要用于图像的分割，是一种以多分辨率来解释图像的有效但概念简单的结构。图像金字塔最初用于机器视觉和图像压缩，一幅图像的金字塔是一系列以金字塔形状排列的分辨率逐步降低，且来源于同一张原始图的图像集合。其通过梯次向下采样获得，直到达到某个终止条件才停止采样。金字塔的底部是待处理图像的高分辨率表示，而顶部是低分辨率的近似。我们将一层一层的图像比喻成金字塔，层级越高，则图像越小，分辨率越低。
获得图像金字塔一般包括二个步骤：
1. 利用低通滤波器平滑图像 2. 对平滑图像进行抽样（采样）
有两种采样方式——上采样（分辨率逐级升高）和下采样（分辨率逐级降低）
上采样：
下采样：
常见两类图像金字塔
1.1 高斯金字塔 ( Gaussian pyramid): 用来向下/降采样，主要的图像金字塔， 高斯金字塔是通过高斯平滑和亚采样获得一系列下采样图像，也就是说第K层高斯金字塔通过平滑、亚采样就可以获得K+1层高斯图像，高斯金字塔包含了一系列低通滤波器，其截至频率从上一层到下一层是以因子2逐渐增加，所以高斯金字塔可以跨越很大的频率范围。金字塔的图像如下：
上图中最下层是原始的图像，越靠上的层图像尺寸越小，这一组图像就被称为高斯金字塔（在某些资料中，下采样之前需要首先进行高斯滤波 可以看出，随着下采样的进行，图像的分辨率不断降低，视觉效果也越来越模糊。
对图像的向下取样操作，即缩小图像。
为了获取层级为 G_i+1 的金字塔图像，方法步骤如下：
&lt;1&gt; 对图像G_i进行高斯内核卷积，进行高斯模糊；
&lt;2&gt; 将所有偶数行和列去除。
得到的图像即为G_i+1的图像，显而易见，结果图像只有原图的四分之一。通过对输入图像G_i(原始图像)不停迭代以上步骤就会得到整个金字塔。同时我们也可以看到，向下取样会逐渐丢失图像的信息。以上就是对图像的向下取样操作，即缩小图像。
对图像的向上取样，即放大图像
方法步骤如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b10ff50ad0fb26a1bcb41080fbd17ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78e1f382e24277f48cecc21101af58fa/" rel="bookmark">
			小猫爪：S32K3学习笔记06-S32K3之BCTU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 小猫爪：S32K3学习笔记06-S32K3之BCTU 1 前言2 BCTU资源介绍3 功能介绍3.1 触发信号3.2 CL（Conversion list ）3.3 DMA支持 4 MCAL配置示例待续。。。。。。 1 前言 大家好，又又又见面了，今天学习了以下S32K3的BCTU模块，BCTU其实就是一个专门的ADC硬件触发器，在ADC的文章中简单的介绍了一下，今天来对齐做个总结，如有错误的地方，希望大家留言指正。
BCTU的功能实现如下所示：
BCTU接受来自CPU，eMIOS, TRGMUX的信号后产生ADC触发信号去触发ADC开始转换，ADC转换完成后再把结果返回给BCTU，BCTU可支持DMA搬运。
2 BCTU资源介绍 S32K3全系标配BCTU模块，除了三个结果寄存器之外，BCTU还有两个FIFO用来存储转换结果，并用来支持DMA传输。
3 功能介绍 BCTU的功能框图如下：
上图非常简单，就不多作废话，下面补充几个上图没有的信息：
BCTU一共支持72个触发信号，对应72个TRGCFG寄存器。一个触发信号可以同时并行触发ADC0,ADC1,ADC2开始转换。K3处于STANDBY模式下， BCTU是不工作的。可以通过使用CL来实现一个触发信号来触发一个转换队列。 3.1 触发信号 上面提到BCTU一共支持72个触发信号，那这72个信号分别是哪些呢？看下表：
从表格中可以非常的清楚的看到，大部分都是由eMIOS的输出信号来触发，还有3个则是由TRGMUX触发。
3.2 CL（Conversion list ） 上面提到可以通过CL来实现一个触发信号来触发一个转换队列，其实意思很简单，我们只需要提前配置好这个转换队列，当这个触发信号过来后，BCTU就会根据这个转换队列来依次产生触发信号去触发ADC开始转换。这个队列最大支持32个。
在这里就不提具体是怎么实现的了，NXP的SDK包提供了非常方便的API借口来实现这个队列初始化功能，感兴趣的小伙伴可以去参考一下K3的RM手册BCTU章节。
3.3 DMA支持 BCTU的两个FIFO均支持申请DMA传输，我们可以预先设置好FIFO的watermask值，当FIFO里面的数据深度达到watermask值后就会产生DMA触发信号来申请DMA传输。
4 MCAL配置示例 待续。。。。。。
待续。。。。。。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/147f2a30dc1d83a99404efe3b5768f94/" rel="bookmark">
			java 牛客网之[动态规划 简单]NC18 数位染色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目的链接在这里：https://www.nowcoder.com/practice/adf828f399de4932955734a4eac12757
目录 题目大意一、示意图二、解题思路数位dp 题目大意 小红拿到了一个正整数 X 。她可以将其中一些数位染成红色。然后她想让所有染红的数位数字之和等于没染色的数位数字之和。 她不知道能不能达成目标。你能告诉她吗？ 一、示意图 二、解题思路 数位dp 数位dp 代码如下：
import java.util.*; public class Main{ static long sum=0; final static long i=0; static int flag=0; public static void main(String args[]){ /** * 数位染色 正整数x 把其中一些染成红色 把所有染红的数位之和等于没染红的数位数字之和 */ Scanner sc=new Scanner(System.in); long num=sc.nextLong(); long temp=num; while (temp&gt;0){ sum+=(temp%10); temp/=10; } //这样sum就是全部的和了 然后开始递归 dfs(num,i); //然后判断flag if(flag==1){ System.out.println("Yes"); } else{ System.out.println("No"); } } private static void dfs(long num, long temp) { //递归判断 一旦出现temp大于等于sum的一半 或者num等于0 if(num==0||temp*2&gt;=sum){ if(temp*2==sum){ //说明刚好 flag=1; return; } return; } //没满足条件 就进行修改 也就是0 1背包 问题 选这个位置还是不选 //不选 dfs(num/10,temp); //选 dfs(num/10,temp+(num%10)); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f7d377b6a95b2e1c4c52adc8212b0ec/" rel="bookmark">
			迁移CentOS 8到版本 almalinux8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		访问 https://www.ipaddress.com/ ，查询 raw.githubusercontent.com 的IP
添加到/etc/hosts文件中：
vim /etc/hosts
添加内容：
#Github
185.199.108.133 raw.githubusercontent.com
执行curl下载：
curl -O https://raw.githubusercontent.com/AlmaLinux/almalinux-deploy/master/almalinux-deploy.sh
授权执行即可：
给almalinux-deploy.sh脚本文件授权：
chmod u+x almalinux-deploy.sh
执行：
sudo ./almalinux-deploy.sh
等待，直到出现如下消息，即说明乔迁成功！
Complete!
Run dnf distro-sync -y OK
Restoring of alternatives is done OK
Generating grub configuration file …
done
All Secure Boot related packages which were released by not AlmaLinux are reinstalledOK
Migration to AlmaLinux is completed
#reboot
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed3a58e0699b89bc0756b7d9fd626a51/" rel="bookmark">
			day4笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字典 字典是“键值对”的无序可变序列，字典中的每个元素都是一个“键值对”，包含：“键
对象”和“值对象”。可以通过“键对象”实现快速获取、删除、更新对应的“值对象”。
列表中我们通过“下标数字”找到对应的对象。字典中通过“键对象”找到对应的“值
对象”。“键”是任意的不可变数据，比如：整数、浮点数、字符串、元组。但是：列表、
字典、集合这些可变对象，不能作为“键”。并且“键”不可重复。
“值”可以是任意的数据，并且可重复。
字典的创建 通过花括号{}、dict()创建字典。a={"name":"小明"}、b=dict(name="小明",age=18)、c=[(“name”,“xiaoming”),(“age”,18)]、d=dict([(“name”,“xiao”),(“age”,19)])。【注意】二者的不同在于，一个用冒号，一个用等号。空字典。c={},d=dict()通过zip（）创建字典对象。 k=["name","age","job"]#这里是键 v=["xiao",18,"student"]#这里是值 d=dict(zip(k,v)) d 通过fromkeys创建值为空的字典 a=dict.fromkeys(["name","age","job"]) 字典元素的访问 通过【键】获得“值”。若键不存在，则抛出异常。a["name"]通过get（）获得值，推荐使用。优点是：指定键不存在，返回None；也可以设
定指定键不存在时默认返回的对象。推荐使用get()获取“值对象”。
a.get("dddd","不存在")列出所有键值对。a.items().列出所有的键a.keys()，列出所有的值a.values(),len(a)键值对的个数。检测一个“键”是否在字典中。"name" in a 字典元素的添加修改删除 给字典新增“键值对”。如果“键”已经存在，则覆盖旧的键值对；如果“键”不存在，
则新增“键值对”。a["address"]="高新区"使用update()将新字典中所有键值对全部添加到旧字典对象上。如果key 有重复，则直
接覆盖。 a = {'name':'gaoqi','age':18,'job':'programmer'} b = {'name':'gaoxixi','money':1000,'sex':'男的'} a.update(b) a out:{'name': 'gaoxixi', 'age': 18, 'job': 'programmer', 'money': 1000, 'sex': '男的'} 字典中元素删除。del();clear()删除所有键值对。pop()删除指定
键值对，并返回对应的“值对象”。 a = {'name':'gaoqi','age':18,'job':'programmer'} del(a['name']) a out:{'age': 18, 'job': 'programmer'} b = a.pop('age') b out:18 a.clear() //清空 popitim()，popitem() ：随机删除和返回该键值对。字典是“无序可变序列”，因此没有第一个元
素、最后一个元素的概念；popitem 弹出随机的项，因为字典并没有"最后的元素"或者其
他有关顺序的概念。若想一个接一个地移除并处理项，这个方法就非常有效（因为不用首先
获取键的列表）。 &gt;&gt;&gt; a = {'name':'gaoqi','age':18,'job':'programmer'} &gt;&gt;&gt; a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed3a58e0699b89bc0756b7d9fd626a51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ed916c6374ff0cc2be1509c887773ba/" rel="bookmark">
			The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server. 这个错误有可能是数据库没有打开造成的。
这个时候要打开任务管理器的服务选项卡查看mysql的服务是否有启动，如果未启动，则右键点击启动即可。如下图所示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae380eb9392c06a57c016a69edcea8f8/" rel="bookmark">
			非平凡的函数依赖、平凡函数依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1NF:无重复的列（数据库表中的每一列都是不可分割的基本数据项）
2NF：满足1NF且非主键列都完全函数依赖于主键。
3NF：满足2NF且非主属性列都不传递依赖于主键。
BCNF：满足3NF且不允许主键的一部分被另一部分或其它部分所决定（即满足3范式，并且主属性之间没有依赖关系）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdf276a5165353604d351c03749955e4/" rel="bookmark">
			Vue3&#43;Element-Plus 登录组件布局实现六
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 登录组件布局 1.1进入到Login.vue，添加一个类选择器，添加一个背景颜色 1.2 保存，看一下效果，发现运行不起来，提示需要安装 less-loader 。
默认cli 工具创建的并没有去安装less-loader.如果我们要去使用less相关的语法，就需要先配置好less相关的loader才行。
1.3 安装配置less-loader。打开可视化UI 面板，选择依赖-安装依赖
1.4 less-loader 应安装在开发依赖中，所以找到选择开发依赖,搜索less-loader
1.5 less-loader 安装完成后，还要安装一个依赖项 less，同样安装到开发依赖中.为啥还要安装less,因为less-loader是依赖于less这个包的。
1.6 安装完成后，重新编译。打开开初化UI，找到任务，点击停止后重新运行，启动app 1.7 背景颜色已经生效了，但是并没有占满屏幕。如果想要让背景颜色填充满整个屏幕的话，需要给页面上其他元素，添加相关的样式。
1.8 是什么没有导致占满全屏呢，可以检查一下元素。
首先可以看到，html不是占全屏的。所以就需要让html高度占满全屏body 也不是占满全屏的，也需要让body占满全屏 1.9 接下来写样式。如果要写全局样式，可以在assets里面新建一个css文件夹，专门放处理全局样式表的样式文件。然后可以在里面定义相关的标签
2.0 全局样式表写好后，要引用才能生效。所以就需要在入口文件main.js中导入该样式表
2.1 接下来，鼠标放到html和body上面，样式已经占满全屏了
2.2 只是body里面的子div，并没有占满全屏。
2.3 那接下来，只需要再给 login_container 元素加一个高度为100就可以了
我设置了100%不生效，后面我改成了vh
2.4 刷新页面效果，背景颜色就占满全屏了。
2.5 当背景色设置完成后，紧接着去绘制一下登录的盒子。就是白色的盒子
2.6 白色盒子可以在 login_container 元素里面绘制
2.7 切换到页面可以看到白色的盒子已经出来了，但是还需要让它位移到中间。继续在login_box加样式
2.8 首先要加一个绝对定位，这样才能够让盒子进行位移
2.9 这样左则和顶部各偏移了50% 3.0 但是并没有在页面正中间，还需要加一个样式
3.1 这样子，白色拿子就放在页面正中间 了
以上出自于：【黑马程序员】前端开发之Vue项目实战_Element-UI【配套源码+笔记】_哔哩哔哩_bilibilihttps://www.bilibili.com/video/BV1x64y1S7S7?p=1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80086f7d8a58957eed2078033e44f853/" rel="bookmark">
			Mybatis学习之LomBok
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LomBok
java libraryplugsbuild toolswith one annotation your class 使用步骤：
1.在IDEA中安装Lombok
2.导入Lombok的jar包
&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;/dependency&gt; 3.在实体类上加注解
例子
@Data @AllArgsConstructor @NoArgsConstructor public class User { private int id; private String name; private String pwd; } @Getter and @Setter @FieldNameConstants @ToString @EqualsAndHashCode @AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor @Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog @Data @Builder @SuperBuilder @Singular @Delegate @Value @Accessors @Wither @With @SneakyThrows @val @var experimental @var @UtilityClass Lombok config system 说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80086f7d8a58957eed2078033e44f853/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/646e6f259e295c35acb7fe9692703976/" rel="bookmark">
			载波聚合（CA）-carrier aggregation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1
为什么需要载波聚合？
一般来说，要提升网速或者容量，有下面几个思路：
建更多的基站：这样一来同一个基站下抢资源的人就少了，网速自然就上去了。但缺点是投入太大了，运营商肯定不会做亏本的买卖。
提升频谱效率：从2G到5G，有多少专家潜心钻研，一头青丝变华发，就是为了提升效率，在每赫兹的频谱上传更多的数据！可见这项工作是真的很艰难。
增加频谱带宽：这是提升容量最简单粗暴的办法了，从2G到5G，单个载波的带宽不断增长，从2G的200K，再到3G的5M，4G的20M，在5G时代甚至达到了100M（Sub6G频段）乃至400M（毫米波频段）！
然而，这一切努力在汹汹流量面前还是杯水车薪，这可怎么办？
只能再增加频谱带宽了！4G的做法主要是把2G和3G，乃至Wifi的频段抢过来用，5G的做法主要是扩展新频段，从传统的低频向带宽更大的高频发起冲击。
频谱千方百计搞到了，但载波的带宽却已经由协议定好了，不容再改，这又咋办？
说起来要实现也简单，人多力量大是永恒的真理，一个载波容量不够，我就再加一个一起传数据，不信速度上不去。什么，还不够？那就继续增加载波！
这种技术就叫做：载波聚合。
话说LTE的第一个版本因为容量有限，虽然被广泛宣传为4G技术，但实际上达不到国际电联的4G标准，业内也就称之为3.9G。
后来LTE演进到LTE-Advanced时，引入了5载波聚合，把单用户可用的带宽从20MHz扩大到了100MHz，这才坐稳了4G的头把交椅。
后面的5G，自然是继承了4G的衣钵，把载波聚合作为提升容量的利器。
2
载波聚合的分类及发展史
话说频谱资源是稀缺的，每个频段就那么一小段，因此载波聚合需要支持多种方式，以两载波聚合为例：
如果两个载波的频段相同，还相互紧挨着，频谱连续，就称作频段内连续的载波聚合。
如果两个载波的频段相同，但频谱不连续，中间隔了一段，就称作频段内不连续的载波聚合。
如果两个载波的频段不同，则称作频段间的载波聚合。
intra-band 中心频点间隔 N*300KHZ (N&gt;=1)
这三种方式包含了所有的情况，可谓任你几路来，都只一路去，再多的载波，也能给拧成一股绳。
参与载波聚合的每一个载波，又都叫做分量载波（Component Carrier，简称CC）。因此，3载波聚合也可称之为3CC。
这些载波在一起工作，需要相互协同，就总得有个主辅载波之分。
所谓主载波，就是承载信令，并管理其他载波的载波，也叫Pcell（Primary cell）。
辅载波也叫Scell（Secondary cell），用来扩展带宽增强速率，可由主载波来决定何时增加和删除。
主辅载波是相对终端来说的，对于不同终端，工作的主辅载波可以不同。并且，参与聚合的多个载波不限于同一个基站，也可以来自相邻的基站。
从4G的LTE-Advanced协议引入载波聚合之后，该技术就如脱缰的野马一样狂奔，从最初的5载波聚合，总带宽100MHz，再到后面的32载波聚合，总带宽可达640MHz！
到了5G时代，虽说可聚合的载波数量仅为16个，但架不住5G的载波带宽大啊。
Sub6G的单载波带宽最大100MHz，16个载波聚合一共就1.6GHz带宽了；毫米波频段更夸张，单载波带宽最大400MHz，16个载波聚合一共就有6.4GHz带宽！
时代的车轮就这样滚滚向前。前浪以为自己已经很牛逼了，但回头一看，后浪简直就是滔天巨浪啊，然后还没反应过来就已经被拍在了沙滩上摩擦。
3
5G的载波聚合技术
话说5G的载波聚合，相比4G来说更复杂一些。
首先5G的频段分为两类，FR1和FR2，也就是俗称的6GHz以下的频段（Sub6G），以及高频，也就毫米波（mmWave）。
FR1包含了众多从2G，3G和4G传承下来的频段，有些是FDD的，有些是TDD的。
这样一来，在FR1内部就存在FDD+FDD频段间的载波聚合，FDD+TDD频段间的载波聚合，以及TDD+TDD频段间的载波聚合。
在上述的每个FDD或者TDD的频段内部，还可以由多个带内连续的载波聚合而成。3GPP定义了多种的聚合等级，对应于不同的聚合带宽和连续载波数。
比如上图中的FR1频段内载波聚合等级C，就表示2个带内连续的载波聚合，且总带宽在100MHz到200MHz之间。
不同于FR1，FR2是全新定义毫米波频段，双工方式全部都是TDD。
跟FR1类似，3GPP也为FR2频段定义了带内连续的多种的聚合等级，对应于不同的聚合带宽和连续载波数。
比如上图中的FR2频段内载波聚合等级M，就表示8个带内连续的载波聚合，且总带宽在700MHz到800MHz之间。
有了上述的定义，我们就可以在FR1内部频段内，频段间进行载波聚合，还能和FR2进行聚合，并且载波数量，以及每个载波的带宽也都可以不同，它们之间的排列组合非常多。
举个例子，“CA_n78A-n258M”这个组合，就代表n78（又称3.5GHz或者C-Band）和n258（毫米波26GHz）这两个频段间的聚合，其中n78的频段内聚合等级为A，也就是单载波，n258的频段内聚合等级为M，也就是有8个载波且总带宽小于800MHz。
4
NSA组网下的双连接技术
且说上面的5G内部载波聚合已经很强悍了，但这还只是带宽扩展的冰山一角。
5G在NSA架构下引入了双连接（Dual Connection，简称DC）技术，手机可以同时连接到4G基站和5G基站。
在双连接的基础上，4G部分和5G部分还都可以在其内部进行载波聚合，这就相当于把4G的带宽也加进来，可进一步增强下行传输速率！
在双连接下，手机同时接入4G基站和5G基站，这两基站也要分个主辅，一般情况下Option3系列架构中，4G基站作为控制面锚点，称之为主节点（Master Node），5G基站称之为辅节点（Secondary Node）。
主节点和辅节点都可以进行载波聚合。其中主节点的主载波和辅载波称为Pcell和Scell，辅节点的主载波和辅载波称为PScell和Scell。
带载波聚合的主节点和辅节点又可以被称作MCG（Master Cell Group，主小区组）和SCG（Secondary Cell Group，辅小区组）。
虽说NSA架构的初衷并不是提升速率，而是想着藉由4G来做控制面锚点，这样一来不但现网的4G核心网EPC可以利旧，还能使用成熟的4G覆盖来庇护5G这个初生的孩童。
但是客观上来讲，通过双连接技术，手机可同时连接4G和5G这两张网络，获取到的频谱资源更多，理论上的峰值下载速率可能要高于SA组网架构，除非以后把4G载波全部重耕到5G。
这些双连接加载波聚合的组合，也都是由协议定义的。
如果看到这串字符：DC_1A_n78A-n257M，我们先按照下划线“_”把它拆解为三个部分，DC，1A，和n78A-n257M。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/646e6f259e295c35acb7fe9692703976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36fb0b7671f4bab294b73edd48ed28f/" rel="bookmark">
			0-1背包问题（多种解决方案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
现要将n个重量为w[i]，价值为v[i]物品装到容量为c的背包中，如何使得背包价值最大
输入描述
第1行输入背包容量c和物品数量n
第2-n+1行输入n个物品的重量与价值
输出描述
输出最大价值
DFS
#include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; typedef long long ll; const ll N=1e4+10; ll w[N];//物品重量 ll cv;//背包当前价值 ll cw;//背包当前重量 ll bestv;//最大价值 ll n;//物品数量 ll c;//背包最大装载量 struct Node{//定义节点 ll w; ll v; double d; }node[N]; bool cmp(Node a,Node b)//比较函数 升序 { return a.d&gt;=b.d; } int Bound(int i) //限界函数 装满背包后的价值 { ll cleft = c-cw;//背包剩余容量 ll b = cv;//当前价值 while(i&lt;=n&amp;&amp;node[i].w&lt;=cleft) { b +=node[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b36fb0b7671f4bab294b73edd48ed28f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca0bd7102b83c6f02ab0a8797bf224ae/" rel="bookmark">
			在Vivado中创建计数器IP核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
在 Vivado 软件中，我们可以很方便的通过创建和封装 IP 向导的方式来自定义 IP 核。
自定义 IP 核可以定制化系统设计，以达到设计重用的目的，可以很大程度上简化系统设计和缩短产品上市的时间。
本实验中可以创建一个带有 AXI4 接口的 IP 核，用于 PS 和 PL 的数据通信。本次实验选择常用的方式，即创建一个带有 AXI 接口的 IP 核，该 IP 核通过 AXI 协议实现 PS 和 PL 的数据通信。AXI 协议是一种高性能、高带宽、低延迟的片内总线。
实验任务
本章的实验任务是通过自定义一个 COUNT IP 核，使其间隔1s计数1次，并切CPU可以实时读取计数结果。
硬件设计
step1：创建一个新的 IP 核
1-1 打开 Vivado，进入 Vivado 界面后，点击“Tasks”栏中的“Manage IP”。在弹出的选项中选择“New
IP Location…”。如下图所示：
1-2 在弹出的界面中选择“Next”，然后设置 Manage IP 核的属性，在“IP Location:”一栏指定工程的
路径，路径为：F:/ZYNQ/ Embedded_System/custom_ip，其它保持默认即可。点击“Finish”完成 Manage IP工程的创建，如图 所示。注意，Part 一栏中设置开发板的型号，在后面的工程中会重新指定，这里直接保持默认。
此时弹出确认工程路径的界面，点击“OK”按钮完成工程的创建。如下图所示：
1-3 工程创建完成后，运行创建和封装 IP 向导。点击菜单栏的“Tools”，选择“Create and Package New
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca0bd7102b83c6f02ab0a8797bf224ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a847fcab04f7d406a3c24955a633ade7/" rel="bookmark">
			装载问题(多种方法解决)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
现要将n个重量为w[i]集装箱装到载重为c的轮船上，如何使得装载的集装箱重量最大
输入描述
第一行输入轮船载重量c和集装箱数量n
第二行输入n个集装箱的重量
输出描述
输出最大重量和集装箱编号
DFS
#include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; typedef long long ll; const ll N=1e4+10; ll w[N];//集装箱重量 ll flag[N];//当前解向量 ll bestx[N];//最优解 ll cw;//当前重量 ll bestw;//最大重量 ll r;//剩余集装箱重量 ll n;//集装箱重量 ll c;//轮船最大装载量 void dfs(ll t) { if(t&gt;n)//叶子节点 { if(cw&gt;bestw)//更新最优解 { for(int i=1;i&lt;=n;i++) bestx[i]=flag[i]; bestw=cw; } return; } r-=w[t];//剩余重量-- if(c&gt;=cw+w[t])//左子树 { flag[t]=1;//放入 cw+=w[t];//目前重量++ dfs(t+1);//递归到子树 cw-=w[t];//还原 } if(cw+r&gt;bestw)//右子树 { flag[t]=0;//不放入 dfs(t+1);//递归到子树 } r+=w[t];//还原 } int main() { freopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a847fcab04f7d406a3c24955a633ade7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39f6e6f84ec92e67e7ca4f6cf3cd8c44/" rel="bookmark">
			墨水屏（电子纸）的介绍与使用（附STM32程序~~~）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电子墨水屏又被称为电子纸显示技术。电子纸显示技术（简称EPD），由美国麻省理工大学教授约瑟夫.雅各布森及其研发团队，经历30余年研发成功。
墨水屏的原理很简单，电子墨水屏是由许多电子墨水组成，电子墨水可以看成一个个胶囊的样子。每一个胶囊里面有液体电荷，其中正电荷染白色，负电荷染黑色。当我们在一侧给予正负电压，带有电荷的液体就会被分别吸引和排斥。这样，每一个像素点就可以显示白色或者黑色了。
因为电子墨水的刷新是不连续的，每一次刷新完成就可以保持现在的图形，即使拔掉电池也依旧保存。可能有人会问，为何电池没电，墨水屏也会一直显示最后的画面，那是因为电子墨水具有双稳态磁滞效应，所以即便电池没电，小球也不会回复原状或者进入随机的混沌状态，而是保持最后画面的状态，此时耗电量为0。
本次使用墨水屏型号为QYEG0420BNS19A，外形尺寸为91.0 x77.0x 1.2mm，显示区域尺寸为84.8 x 63.6mm，分辨率为400 x 300，支持显示黑色和白色两种颜色，支持全屏刷新和局部刷新两种模式，刷新功耗为12.6mW。
这里给开发者介绍一下全刷和局部刷的区别
1）全刷：电子纸刷新需要画面闪烁多次后，最终显示所需要的画面，其中闪烁的目的是清除显示残影，以达到最佳的显示效果。
2）局刷：电子纸刷新无画面闪烁，局刷需要用户在使用的时候，刷新几次后，进行一次全刷操作，以清除显示残影。
另外，墨水屏正常使用的温度范围：0~50℃ ，湿度范围：35%~65%RH，要避免阳光长时间直射显示屏表面。
它有如下特性
● 内置驱动器IC，无需另配驱动器，仅需少量外围器件，即可通过MCU控制显示，节省资源。
● 超宽视角 将近180°
● 超低功耗（断电可以继续保持显示内容）
● 纯反射模式
● 防眩硬涂层前表面
● 低电流深度睡眠模式
● 采用COG封装, IC厚度300um
● 使用寿命（无故障刷新次数）：100万次以上
开发者可以参考下面的电路原理图
其中主要引脚功能如下
NameDescriptionGDRN勾道场效应管的栅极驱动控制脚RESE控制回路的电流检测输入脚VSH2正源极驱动电压TSCLI2C数字温度传感器的时钟信号接口TSDAI2C数字温度传感器的数据信号接口BS1总线接口选择引脚BUSY繁忙状态输出引脚RES#复位信号输入脚， 低电平有效D/C#数据/命令控制引脚CS#芯片片选引脚SCLSPI接口的时钟引脚SDASPI接口的数据引脚VDDIO逻辑接口的电源引脚， 应与VCI脚连接VCI芯片电源引脚VSS参考地VDD核心逻辑电源引脚VPP测试脚 , 保持开路VSH1正源极驱动电压VGH正门极驱动电压和VSH1的电源引脚VSL负源极驱动电压VGL负门极驱动电压，VCOM和VSL的电源引脚VCOMVCOM驱动电压 翻阅数据手册如下，可知源极驱动电压VSH引脚和门极驱动电压VGH引脚电压典型值都远大于芯片电源引脚，因此对该引脚还需要进行一个升压的处理。
如原理图所示，3.3V输入源，电感L1，MOS管Q1，电容C1，二极管D3，电阻R2构成了一个最基本的boost升压电路，MOS管Q1的导通或截止状态，由E_GDR控制。
当MOS管Q1导通时，输入电压经过电感L1后直接通过限流电阻R2返回到GND，这导致通过电感L1的电流线性的增大，此时输出滤波电容C1向负载放电。
当MOS管Q1截止时，由于电感L1的电流不能在瞬间发生突变，因此在电感L1上产生反向电动势Vs以维持通过电流不变。此时二极管D3导通，3.3V和Vs两电压串联后，以超过3.3V大小的电压向负载供电，并对输出滤波电容C1充电，如此循环，由此实现对E_PREVGH引脚的升压操作。
同样的，对于E_PREVGL引脚，
当MOS管Q1截止时，电容C2充电，二极管D1导通，D2截止，电流经过D1流向GND，理想情况下电容C2两端的电压差为3.3V+Vs。
当MOS管Q1导通时，Q1的漏极接近0V，由于电容C2电压不能突变，可认为二极管D2的K极电势为-(3.3V+Vs)，电容C2放电，二极管D1截止，D2导通，电流经过D2流向C2，由此实现对E_PREVGL引脚负电压“升压”操作。
介绍完墨水屏的驱动电路，再和开发者们介绍一下墨水屏的使用方法。
墨水屏的操作流程整体也是比较简单的，大致流程如下。
墨水屏采用SPI通讯，这部分程序大家自行完成，小编主要给大家介绍一下应用端的程序。
首先是初始化函数
初始化过程中涉及全屏刷新和局部刷新两种
全屏刷新：整个页面全部刷新一次，整个屏幕要闪几次。 优势是没有残影，缺点是要多刷几下屏。
局部刷新：每一次刷新显示内容时，不会整个屏幕都刷新，仅刷新那些有画面和字的地方。优势是屏幕不会闪烁，但会有残影。（残影问题多刷几次白屏就能清除掉或者执行一次全刷也可以清掉）
在实现墨水屏的全局刷新与局部刷新功能时， 从局刷转到全刷时休眠后一定要先进入初始化再刷新。
// refresh_mode = Full 全屏刷新 // refresh_mode = Partial 局部刷新 void EPD_HW_Init(const unsigned char refresh_mode) { EPD_W21_Init();	//hard reset Epaper_READBUSY(); Epaper_Write_Command(0x12); // soft reset Epaper_READBUSY(); Epaper_Write_Command(0x01); //Driver output control Epaper_Write_Data(0x2B); Epaper_Write_Data(0x01); Epaper_Write_Data(0x00); Epaper_Write_Command(0x11); //data entry mode Epaper_Write_Data(0x03);	//Y increment, X increment Epaper_Write_Command(0x44); //set Ram-X address start/end position Epaper_Write_Data(0x00);	//0x00--&gt;0 Epaper_Write_Data(0x31); //0x31--&gt;(49+1)*8=400 Epaper_Write_Command(0x45); //set Ram-Y address start/end position Epaper_Write_Data(0x00); Epaper_Write_Data(0x00); Epaper_Write_Data(0x2B);	//0x012B--&gt;(299+1)=300 Epaper_Write_Data(0x01); Epaper_Write_Command(0x3C); //BorderWavefrom Epaper_Write_Data(0x01);	Epaper_Write_Command(0x18); //Temperature Sensor Selection Epaper_Write_Data(0x80);	//Internal temperature sensor Epaper_Write_Command(0x22); if(refresh_mode==Full) Epaper_Write_Data(0xB1);//调用全刷LUT if(refresh_mode==Partial) Epaper_Write_Data(0xB9);//调用局刷LUT Epaper_Write_Command(0x20); Epaper_READBUSY(); Epaper_Write_Command(0x4E); // set RAM x address count Epaper_Write_Data(0x00); Epaper_Write_Command(0x4F); // set RAM y address count Epaper_Write_Data(0x00); Epaper_Write_Data(0x00); Epaper_READBUSY(); } EPD_W21_Init的功能就是对墨水屏的复位引脚拉低再拉高处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39f6e6f84ec92e67e7ca4f6cf3cd8c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f15daca059302e9dcd97fe94dc920ac/" rel="bookmark">
			钉钉免登 前端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 h5 微应用 企业内部开发
钉钉调试包网址 https://developers.dingtalk.com/document/resourcedownload/h5-debug?pnamespace=app 移动端调试包：Android调试包: https://download.alicdn.com/wireless/dingtalk/latest/rimet_10006337.apk
钉钉rc版调试包：Windows调试包：https://download.alicdn.com/dingtalk-desktop/win_installer/RC/DingTalk_v5.5.5-RC.5605.exe
试了一堆办法，只有用这个方法 Windows调试包 调试成功了，看文档瞎忙了好几天，也是没谁了
注意事项：
1- 文档一定要每个每个字都得看，漏掉一个字，可能就会出现一些莫名其妙的问题，真的是要大哭了
2- 地址，能填的都填
3- 权限，能开的都开
4-文档仔仔细细的看
前端代码，我写在了，之前的登录login页面了。拿到code授权码后请求后台接口，再拿到token，就OK了
// 钉钉免登 code(){ let that = this dd.ready(function() { dd.runtime.permission.requestAuthCode({ corpId:'钉钉公司的corpid', onSuccess: function(result) { console.log(result); that.authCode = result.code; that.$http.postjson("/ding/login",{code:result.code}).then((res) =&gt; { console.log(res.data); uni.setStorageSync('Authorization',res.data); }); }, onFail : function(err) { console.log(err) } }) }); }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46483454f3e59bf1dcfb84b5708f98fa/" rel="bookmark">
			迁移CentOS 7到版本 8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elevate 是一个由 AlmaLinux 团队开发的开源项目，它允许将 CentOS 7 迁移到基于 RHEL 的较新和主要版本的发行版，例如 AlmaLinux 8、Rocky Linux 8、Oracle Linux 8 和 CentOS Stream 8。它结合了 RedHat 的 Leapp 框架带有一个社区开发的库来协助迁移。
本教学指南为您提供了使用 Elevate 将 CentOS 7 升级/迁移到 AlmaLinux 8 的步骤。
注意：Elevate仍处于开发的早期阶段，应该仅用于测试目的。不应该在生产服务器中测试迁移工具。
当前可用的迁移路径：
CentOS 7 到 AlmaLinux 8 CentOS 7 到 Rocky Linux 8 CentOS 7 到 Oracle Linux 8 CentOS 7 到 CentOS Stream 8 第 1 步：完全更新系统
首先，更新所有系统包和存储库。
[linuxmi@localhost www.linuxmi.com]$ sudo yum update -y
然后重启CentOS 7服务器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46483454f3e59bf1dcfb84b5708f98fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f53e3e1a9776891c38159db785245a0/" rel="bookmark">
			编译buildroot系统时的问题与解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译buildroot系统时的问题与解决 前言一、未切换成管理员模式解决方法： 二、内核版本与系统版本不匹配解决方法： 三、部分包无法下载解决方法 总结 前言 在编译rootfs时，我们常常会遇到一些问题。本文针对作者在编译buildroot时遇到的问题来展开分享
一、未切换成管理员模式 如图所示：
在编译时，没有切换成管理员模式，系统将会提示：Permisson denied!权限不够的报错。
从而无法进行buildroot的编译。也是比较常见的错误。
解决方法： 1.sudo ./build.sh rootfs 2.sudo su ./build.sh rootfs 二、内核版本与系统版本不匹配 如图所示：
根据报错提示：内核版本为4.4，但系统需要的内核至少为4.19。所以无法继续编译，导致无法生成.stamp_configured
无法生成这个文件，表示配置不通过。
解决方法： 根据上面提示，我们应该找到编译过程中的配置文件:…/device/xxx/.BoardConfig.mk
发现系统内核为4.19版本，而kernel版本是4.4.所以将软链接修改为4.4版本的系统即可。
修改软链接命令：　ln –snf [新的源文件或目录] [软链接文件] 重新编译果然通过了！
三、部分包无法下载 遇到这个问题时，多半是某个包无法下载或者解压。具体情况的图我就不贴了。
解决方法 根据报错提示，在浏览器中打开未正常下载的包的网址，在官网下载后，放到包原本应该在的文件夹下。
总而言之，手动代替脚本去完成这个操作！
总结 在遇到编译问题时，我们要读懂报错提示，分析其报错的原因，再根据原因，去寻找合适的解决方法。希望我的文章能够帮助到你！感谢一键三连，点赞，评论和转发！您的鼓励是我写作的动力！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba569b0e65cebee5a43eb241552c091f/" rel="bookmark">
			windows实用键盘快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows实用键盘快捷键 一、ctrl相关二、alt、shift相关三、win（windows徽标的简称）相关四、其他快捷键五、运行窗口快捷命令先输入win+ R 六、小结 一、ctrl相关 Ctrl + X　-&gt;　剪切选定项
Ctrl + C（或 Ctrl + Insert）　-&gt;　复制选定项
Ctrl + V（或 Shift + Insert）　-&gt;　粘贴选定项
Ctrl + Z　-&gt;　撤消操作
Ctrl + Esc　-&gt;　打开“开始”屏幕
Ctrl + Shift + Esc　-&gt;　打开任务管理器
Ctrl + Shift　-&gt;　在提供了多个键盘布局时切换键盘布局
Ctrl + 空格键　-&gt;　打开或关闭中文输入法编辑器 (IME)
二、alt、shift相关 Alt + Tab　-&gt;　在打开的应用之间切换
Alt + F4　-&gt;　关闭活动项，或者退出活动应用
Shift + F10　-&gt;　显示选定项的快捷菜单
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba569b0e65cebee5a43eb241552c091f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ac8527f451277863f4c965e9b17f674/" rel="bookmark">
			2021-11-07 单链表中偶数位序的元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】 统计单链表中偶数位序的元素和并输出元素值。
【输入形式】
【输出形式】
【样例输入】5
15 16 17 18 19
【样例输出】 16 18
34
【样例说明】链表长度为5，偶数位序元素为 16 18，第二行输出元素和。
【运行结果如下】
【代码如下】
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef int Status; typedef int ElemType; /*线性表的单链表存储结构 */ typedef struct LNode{ ElemType data;	struct LNode *next; }LNode,*LinkList; /*初始化链表*/ void InitList_L(LinkList &amp;L) { LinkList p; LinkList pre; int i; int n; scanf ("%d",&amp;n); L = (LinkList)malloc(sizeof(LNode)); L-&gt;next = NULL; pre = L;	//当前指针 for (i=1; i&lt;=n; i++){ p = (LinkList)malloc(sizeof(LNode)); scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ac8527f451277863f4c965e9b17f674/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a277057b1153d026334945e67d07c923/" rel="bookmark">
			SwiftUI 简单的使用WebView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码
import SwiftUI import WebKit //不通过参数直接构建视图 struct MyWebView: UIViewRepresentable { func makeUIView(context: Context) -&gt; WKWebView { return WKWebView() } func updateUIView(_ uiView: WKWebView, context: Context) { let url = URL(string: "https://www.baidu.com/")! uiView.load(URLRequest(url: url)) } } //通过【UIViewRepresentable】从WebKit中引入【WKWebView】创建能够在SwiftUI中使用的视图 struct WebView: UIViewRepresentable { let webView: WKWebView func makeUIView(context: Context) -&gt; WKWebView{ return webView } func updateUIView(_ uiView: WKWebView, context: Context) { } } //通过参数构建视图 class WebViewModel: ObservableObject { let webView: WKWebView let url: URL init() { webView = WKWebView(frame: .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a277057b1153d026334945e67d07c923/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/690b5f0da77e08429c706a9d94f0da07/" rel="bookmark">
			IDEA插件分享（实用推荐）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. SequenceDiagram 序列图插件
查看方法内部的调用其他的序列图
使用方法：
选中对应的方法，右击选择 SequenceDiagram 或者右上角点击SequenceDiagramtu'bi
2. Maven Search
快速搜索自己需要的maven依赖，无需要上网查找依赖
3. Maven Helper
可以查看当前pom文件中的 所有、冲突的依赖 4. Alibaba Java Coding Guidelines
代码检查工具，当然如果要扫描整个项目工程也是可以的
5. MybatisLog
springboot项目中会监听sql执行的语句，但是似乎如果项目中做了分库分表操作后无法做到显示sql语句日志 6. Free Mybatis plugin
可快速跳转到对应的Mapper.xml文件中对应的sql语句，当然还以快速修改maper方法的名称和快速插件等等（开发必备）
7. Translation
翻译插件（建议使用）
8. CamelCase
CamelCase驼峰转换，按 Shift + Alt + U 后,还可以进项以下转换（当然苹果电脑的快捷键.....，高贵的我买不起，恕我无可奉告^_^），推荐安装插件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8287b64c26f9cced07b3d44826225656/" rel="bookmark">
			简单的python爬虫——豆瓣
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# -*- codeing = utf-8 -*- # @Time : 2021/8/11 18:50 # Author: hui # @File : demo.py # @Software : PyCharm from bs4 import BeautifulSoup #网页解析，获取数据 import re #正则表达式，进行文字匹配 import urllib.error,urllib.request #指定URL，获取网页数据 import xlwt #进行Excel操作 import sqlite3 #进行sqlite3数据库操作 # 1、（爬取）获取网页数据 # 2、解析网页数据 # 3、存储数据 def main(): baseurl="https://movie.douban.com/top250?start=" #（爬取）获取网页数据 dataList=getData(baseurl) # excel表存储数据 # savepath="豆瓣电影top10.xls" # saveData(dataList,savepath) #sqlite3数据库存储数据 dbpath="movie250.db" saveData2db(dataList,dbpath) #详细页面链接 findLink=re.compile(r'&lt;a href="(.*?)"&gt;')# 指定findLink查找字符串规则 #电影名称 findName=re.compile(r'&lt;span class="title"&gt;(.*)&lt;/span&gt;') #电影图片 findIMGSrc=re.compile(r'&lt;img.*src="(.*?)"',re.S) #r为了避免转义字符，re.S忽略换行符 #评分 findRating=re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8287b64c26f9cced07b3d44826225656/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af6b8f1c774e36c8c9e414252a7a4667/" rel="bookmark">
			webscoket的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webscoket的简单使用 1、第一步：需要建立一个全局的js文件，我在这里取名为global.js
export default { ws: {}, setWs: function (newWs) { this.ws = newWs; }, }; 2、第二部：将刚刚新建的文件夹引入main.js文件中进行全局注册
import gloabl from '@/assets/utils/global'; Vue.prototype.$global = gloabl; 3、在入口文件App.js中去检测浏览器的适应情况
methods: { localSocket() { let that = this; if ('WebSocket' in window) { that.ws = new WebSocket('ws://192.168.35.20:8872/dashbord');//创建一个实例对象，括号中为你需要监听的地址 that.$global.setWs(that.ws); that.ws.onopen = function () {//在这里你可以写属于自己的逻辑 console.log('成功建立连接了...'); }; that.ws.onerror = function () { setTimeout(() =&gt; { that.localSocket(); }, 2000); }; that.ws.onclose = function () { console.log('连接已关闭...'); setTimeout(() =&gt; { that.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af6b8f1c774e36c8c9e414252a7a4667/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6651353dd706e3854fb14b6e47771f9/" rel="bookmark">
			无法获得下列许可 solidworks standard 无法连接到服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无法获得下列许可 solidworks standard 无法连接到服务器 当启动SolidWorks时，出现无法获得下列许可 solidworks standard 无法连接到服务器提示。这里给出解决办法。
第一步：打开任务管理器
第二步：找到最后一个“服务”选项
第三步：找到SolidWorks Flexnet Server 和 SolidWorks Licensing Server 选项，这里你可以发现这两个服务是停止状态，所以把这两个服务启动就可以了。
第四步：点击启动启动此服务，
此时，在重新打开SolidWorks程序完美运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0faa8de7dca43f5405389a1cc35a04f/" rel="bookmark">
			详解TensorRT的C&#43;&#43;/Python高性能部署，实战应用到项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详解TensorRT的C++/Python高性能部署，实战应用到项目_哔哩哔哩_bilibilihttps://www.bilibili.com/video/BV1Xw411f7FW?p=2
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/276/">«</a>
	<span class="pagination__item pagination__item--current">277/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/278/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>