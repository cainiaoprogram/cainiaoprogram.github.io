<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8df4538fc901d2b0c203a648f07bbbf/" rel="bookmark">
			SQL Server 中日期比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 当前系统日期、时间
select getdate() 2. dateadd 在向指定日期加上一段时间的基础上，返回新的 datetime 值
例如：向日期加上2天
select dateadd(day,2,'2004-10-15') --返回：2004-10-17 00:00:00.000
3. datediff 返回跨两个指定日期的日期和时间边界数。
select datediff(day,'2004-09-01','2004-09-18') --返回：17
4. datepart 返回代表指定日期的指定日期部分的整数。
SELECT DATEPART(month, '2004-10-15') --返回 10
5. datename 返回代表指定日期的指定日期部分的字符串
SELECT datename(weekday, '2004-10-15') --返回：星期五
6. day(), month(),year() --可以与datepart对照一下
select 当前日期=convert(varchar(10),getdate(),120)
,当前时间=convert(varchar(8),getdate(),114)
7. select datename(dw,'2004-10-15')
select 本年第多少周=datename(week,getdate())
,今天是周几=datename(weekday,getdate())
函数 参数/功能 GetDate( ) --返回系统目前的日期与时间 DateDiff (interval,date1,date2) --以interval 指定的方式，返回date2 与date1两个日期之间的差值 date2-date1
DateAdd (interval,number,date) --以interval指定的方式，加上number之后的日期 DatePart (interval,date) ---返回日期date中，interval指定部分所对应的整数值 DateName (interval,date) --返回日期date中，interval指定部分所对应的字符串名称 参数 interval的设定值如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8df4538fc901d2b0c203a648f07bbbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd36e496c17f785e7bc3ba5a1bf01697/" rel="bookmark">
			entity framework 6 自己编写的通用数据类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class BaseDAL { string strConn = ""; public BaseDAL(string connString) { strConn = connString; } #region 通用增删改查 #region 非原始sql语句方式 /// &lt;summary&gt; /// 新增 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;实体&lt;/param&gt; /// &lt;returns&gt;返回受影响行数&lt;/returns&gt; public bool Add&lt;T&gt;(T entity) where T : class { using (SysDb&lt;T&gt; db = new SysDb&lt;T&gt;(strConn)) { db.Entry&lt;T&gt;(entity).State = EntityState.Added; return db.SaveChanges() &gt; 0; } } /// &lt;summary&gt; /// 修改 /// &lt;/summary&gt; /// &lt;param name="entity"&gt;实体&lt;/param&gt; /// &lt;returns&gt;返回受影响行数&lt;/returns&gt; public bool Update&lt;T&gt;(T entity) where T : class { using (SysDb&lt;T&gt; db = new SysDb&lt;T&gt;(strConn)) { db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd36e496c17f785e7bc3ba5a1bf01697/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba31164b7d5a82a611b422b6b26ff8dc/" rel="bookmark">
			人脸识别必读的N篇文章（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，人脸检测/跟踪
人脸检测/跟踪的目的是在图像/视频中找到各个人脸所在的位置和大小；对于跟踪而言，还需要确定帧间不同人脸间的对应关系。
1,
Robust Real-time Object Detection. Paul Viola, Michael Jones. IJCV 2004.
入选理由：
Viola的人脸检测工作使得人脸检测真正变得实时可用。他们发表了一系列文章，这篇是引用率最高的一篇。
2,
Fast rotation invariant multi-view face detection based on real Adaboost. Bo Wu,Haizhou Ai, Chang Huang, Shihong Lao. AFGR 2004.
人选理由:
自viola之后，有很多改进文章，这篇文章只是其中之一。之所以选择这篇，是因为其贡献点相对比较多：一是因为这篇文章第一次将real adaboost应用于物体检测，二是其提出了一个比较成熟实用的多姿态人脸检测框架，三是其提出的nest结构对cascade结构的改进确实有不错的效果。
3，
Tracking in Low Frame Rate Video: A Cascade Particle Filter with Discriminative Observers of Different Life Spans. Yuan Li, Haizhou Ai, Yamashita T., Shihong Lao. CVPR 2007.
入选理由：
人脸跟踪是人脸识别中非常重要的模块。这篇文章是比较好的将人脸检测模型与跟踪进行结合，将离线模型和在线模型结合的工作，而且获得了CVPR 2007 Best Student Paper，是中国大陆学生第一次获此殊荣。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba31164b7d5a82a611b422b6b26ff8dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/828c01e2dc3a854010c8ac24fab47f85/" rel="bookmark">
			Fast, Accurate Detection of 100,000 Object Classes on a Single Machine 读后记录（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章是CVPR 2013 best paper。 这篇文章的牛，主要体现在一些关键数字上，可以分类100000类别，比base line快了20000倍。 不过，美中不足的是，其单机处理一幅图像的速度，需要20s，而且，100000类mAP为0.16，看上去很美，但是距离实用还有一些距离。 这篇文章的卖点在于速度快，具体就是对于多类检测问题，检测速度可以做到和类别数目无关。 对于包含C类的物体检测而言，一个基本的框架是，训练C个分类器，对于每个候选位置，用每个分类器都判定一遍，然后做后处理融合。这样的坏处是速度太慢，处理速度和物体类别成反比（线性，算法复杂度O(C)）。 这篇文章参考的base line算法是DPM模型，就是每个物体的模型由多个part（假定P个）的模型组成，每个part的模型可以看作是一个filter和该位置特征的点积（整体上可以看作是一个convolution过程），然后根据可能的part候选的位置约束确定物体的位置。在实际中，最耗时的是convolution过程，每个物体分类器的filter（对应weight）都需要和候选位置的特征进行一次点积处理，假定候选窗口数目为W个，候选窗口的feature dimension是M维，则运算复杂度为W*C*P*M。 这篇文章利用了之前的一个工作的结果，可以将两个向量的点积（其实点积和cos距离有非常强的关联，如果预先对参与cos距离运算的两个向量进行模的归一化处理，则归一化后两向量的cos距离和点积是相同的）相似度转化为两个hash值的hamming距离。 距离将feature转换为lsh hash的过程如下（得到的hash是LSH hash，也是WTA hash）： 假定共M维feature，设K为保留的中间元素数目 设定一个重排数组（随机得到，个数为M，元素为0-M-1，每个元素的序号表示临时feature对应原始feature中的序号），从而将原始feature转变为一个临时feature，取临时featue的前K维，组成最终的新feature，则新feature中最大元素序号（新feature中）为k，将k表示为一个log（K）位的二进制数字串 继续设定共N个重排数组（随机得到），则得到共N*log（K）位的二进制串，按照最前面的重排数组对应的串放在最低位的原则，得到一个hash值（N*log（K）位整数）。 对应的，两个feature之间的点积转化为两个对应hash之间的hamming距离。 直观上看，由于如此得到的数字只和数字之间的相互大小有关，且每次保留最大的序号的信息，因此，对于数字的扰动非常鲁棒。因此，得到的两个hash值之间的hamming距离所对应的相似度对于特征值的变化更加鲁棒，是更有效的表示（到底是否是这样，无从得知，其他信息请参考J. Yagnik, D. Strelow, D. A. Ross, and R.-s. Lin. The powe of comparative reasoning. In IEEE International Conference on Computer Vision, 2011.）。 由于计算两个hash之间的hamming距离非常快速（还可以查表），因此最耗时的部分在计算每个窗口的feature以及计算hash值上，这个运算和类别数目无关。 上述可以用于点积衡量相似度的特征，可以是各种各样的特征，在物体检测里面最常用的要数HOG特征了。 下面以HOG特征为例，说明base line 算法和本文提出的改进之间计算时间的对比： base line算法的计算过程如下： 1，计算多尺度的边缘强度和边缘方向图像； 2，对所有窗口进行遍历 对于每个窗口， 计算其高斯加权HOG直方图特征 分别计算HOG特征和C类P个filter的点积 3， 将具有局部最大响应的窗口作为候选，得到可能的物体中心的分布累积 综合得到最终的物体检测结果 改进算法计算过程如下： 事先计算得到C*P个filter对应的hash值 1，计算多尺度的边缘强度和边缘方向图像； 2，对所有窗口进行遍历 对于每个窗口， 计算其高斯加权HOG直方图特征 计算特征对应的hash值 分别计算HOG特征hash值和C类P个filter的hash值的hamming距离 3， 将具有局部最大响应的窗口作为候选，得到可能的物体中心的分布累积 综合得到最终的物体检测结果 对比可以看到，由于改进算法中，计算hamming距离的部分非常快，可以忽略，因此，最终得到的多类检测器的运算量和类别数目无关。 进一步，为了快速运算，可以将上述的hamming距离计算转换为查表运算，为了当累积相似度高于阈值时无需继续计算，将hash值划分为多个不同部分（这样每个表也比较小）。 将N*log（K） bit的hash分为N/M组（band），每组是一个M*log（K） bit的整数，对于每个类别每个part的filter（训练模型），对应N/M组查找表（查找表的序号为当前窗口feature在该band上的hash值，查找表记录的值为该featurehash值和模型hash值的相似度），从而避免了hamming距离计算过程。每个filter取到的N/M组查找表的值的累积和为对应的点积值（相似度）。对N/M组累积和计算，当计算发现相似度大于阈值时，则放弃后面的运算，直接对预估物体位置分布进行累积。 则最终得到物体位置分布累积最大的位置为检测得到的物体位置。 文章中还有一些特殊的细节（比如root filter，以及在快速计算之后继续用点积计算相似度等），不再赘述。 文章中还有一点值得讨论的地方在于，作者的100000类数据都是搜索引擎爬取的，没有经过人工标定，所以结果存在一定不准确的地方。但是定性上看，这样做确实快了很多。 当然，相对base line算法，本文提出的算法在精度上还是降低一些的（见论文voc 2007的对比结果,mAP由0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/828c01e2dc3a854010c8ac24fab47f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/173b8179c820315ba4da355fa4707a0e/" rel="bookmark">
			21世纪初最有影响力的20篇计算机视觉期刊论文 及 邓亚峰老师关于人脸识别方面总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.cnblogs.com/youth0826/archive/2012/12/04/2801481.html
选取论文的原则：
（1）期刊论文，主要来源于以下期刊：TPAMI，IJCV，TIP，CVIU，IVC，MVA，PR，JMIV，IJPRAI…
（2）发表在2000年以后
（3）SCI检索次数大于1000，来源于Web of Science数据库，2012年12月初的检索结果
Top 20 榜单如下：
[1] D. G. Lowe, “Distinctive image features from scale-invariant keypoints,” International Journal of Computer Vision, vol. 60, no. 2, pp. 91-110, Nov, 2004. (Cited=5663)
[2] J. B. Shi, and J. Malik, “Normalized cuts and image segmentation,” IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 22, no. 8, pp. 888-905, Aug, 2000. (Cited=2165)
[3] T. F. Chan, and L. A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/173b8179c820315ba4da355fa4707a0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5b36ece9a82e6cfb6ae9fdfe304164f/" rel="bookmark">
			Effective C&#43;&#43; 读书笔记【for_wind】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这边好书应该早点看的。总结一下，方便日后查阅。//for_wind 1、尽量以const，enum，inline替换#define，或说尽量以编译器取代预处理器 #define可能并不进入符号表（symbol table） const：注意：A、常量指针；B、class专属常量。注：为了确保class专属常量至多只有一份实体，必须让它成为static成员。 2、尽量以&lt;iostream&gt;代替&lt;stdio.h&gt; 3、尽量以new和delete取代malloc和free 差别在构造函数、析构函数 4、尽量以C++风格的注释形式 即尽量用//，避免采用/* */在内嵌注释时，造成注释块过早结束 5、使用相同形式的new和delete A、指的是new，delete和new[]，delete[]配对使用。 B、当你使用new动态生成一个对象，有两件事发生：内存被分配；针对此内存会有一个(或更多)构造函数被调用，然后内存才被释放(delete). C、尽量不要对数组形式做typedef动作。 总结：当你用new生成对象时，如果用new type-object[] ,则要使用 delete []type-object ，否则使用 delete 6、记得在destructor中以delete对付pointer members A、当存在pointer members时， 每个constructor中将该指针初始化或或为0； 在assignment运算符中，将该指针原有的内存删除，重新配置一块； 在destructor中删除这个指针。 B、谁new，谁delete。 C、注意到smart pointers。 以独立语句将newed对象置入智能指针 Store newed objects in smart pointers in standalone statements. 以独立语句将newed对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。 7、为内存不足的状况预先做准备 set_new_handler。 8、撰写operator new 和 operator delete时应遵循的公约 指需要和缺省的operator new 保持一致（正确的返回值，内存不足时调用错误处理函数，准备应付“no memory”的需求（申请0内存）（实际上视申请0bytes为1bytes））； 需要和 operator delete保持一致（保证删除一个null指针是安全的）。 更具体地说，operator new 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。它也应该有能力处理 0 bytes申请。Class专属版本则还应该处理“比正确大小更大的（错误）申请”。 operator delete应该在收到null指针时不做任何事，Class专属版本则还应该处理“比正确大小更大的（错误）申请”。 9、避免遮掩了new的正规形式 和8条一样，需要定义class专属的operater new并调用缺省的operater new 10、如果你写了一个operator new，请对应写一个operator delete。 将这两个一并写出，使它们能够共享相同的假设。（重载它们大多是为了效率，一般可采用链表之类的POOL来管理） 11、如果class内动态配置有内存，请为此class声明一个copy constructor 和一个assignment运算符 避免：内存泄露问题和指针别名问题（如，重复删除以及未定义问题）。 如果不想用或没必要，不如：将这些函数声明为private，并且不要定义（实现）之，这可以阻止clients调用它们，也可以避免编译器产生它们。 12、在constructor中尽量以initiation动作（即member initiation list）取代assignment动作 好处：A、满足const members 和 reference members必需通过member initiation list初始化；B、提高data members初始化的效率（减少函数调用） 13、initialization list中的members初始化次序应该和其在class内的声明次序相同 注意到：class members是以它们在class内的声明次序来初始化的，而和member initialization list中出现的次序完全无关。 （只有nonstatic data members的初始化才使用这条规则。） 14、总是让base class拥有virtual destructor。 避免 nonvirtual destructor产生的“未定义行为问题”。 C++明确指出，当derived class对象经由一个base class指针被删除，而该base class带着一个non-virtual析构函数，其结果未有定义----实际执行时通常发生的是对象的derived 成分没被销毁。 方法：给base classes 定义一个 virtual 析构函数。 任何class只要带有virtual 函数都几乎确定应该有一个virtual析构函数。 欲实现出virtual函数，对象必须携带某些信息，主要用来在运行期决定哪一个virtual函数被调用。这份信息通常由一个所谓vptr（virtual table pointer）指针指出。 令class带一个pure virtual(纯虚)析构函数会导致abstract(抽象)classes ---也就是不能被实体化(instantiated)的class.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5b36ece9a82e6cfb6ae9fdfe304164f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c328a11a89d24efbf5058b4c118bdf8/" rel="bookmark">
			怎样让谷歌浏览器切换兼容模式打开网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在平时填网上申报或者在网上填写一些文件的时候，由于浏览器原因，页面打开不全面或者是文本填写框不显示。
针对这种情况，我们只需要将浏览器改为兼容模式打开这个网页即可正常浏览。
下面针对谷歌浏览器，列出步骤怎么更改为兼容模式：
第一步：点击右上角的菜单图标
第二步：点击图标所指的工具
第三步：点击工具栏下的扩展程序一栏，之后会出现一个网页
第四步：在该网页中点击“获取更多扩展程序”，进入“Chrome网上应用店”
第五步：在“Chrome网上应用店”中左上部分搜索“IE tab multi”应用，之后在右半部份找到相应的应用。点击“+免费”就会自动安装了
安装后的结果：
至此，兼容模式的一些必要工具已经安装完成，在打开网页之后，只需要点击上图中的“IPA图标”，就可以使用兼容模式浏览网页了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e4702277decc6b32ed55185cc830d4d/" rel="bookmark">
			POJ-1953
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这道题的大致意思是已知一个n位数，这n位数每一位只能用0或者1表示，并且不能有连续的1出现；
如n=1，则有两种情况0,1
n=2，则有三种情况00,01,10
n=3，则有五种情况000,001,010,100,101
n=4，则有8种情况0000,0001,0010,0100,0101,1000,1001,1010
不难得出这样的规律，即如果n=4，第四位有为0或者1两种情况；如果第四位为0，则第三位可以为0或者1，这时就相当于n=3的情况；如果第四位为1，则第三位只能为0，这时就相当于n=2的情况，所以得出这样的规律a[n]=a[n-1]+a[n-2]；
#include "stdio.h"#include "stdlib.h"long long f[50];int main(){int i,n,t;f[0]=1;f[1]=2;for(i=2;i&lt;50;i++)f[i]=f[i-1]+f[i-2];scanf("%d",&amp;n);for(i=1;i&lt;=n;i++){scanf("%d",&amp;t);printf("scenario #%d:",i);printf("%lld\n",f[t]);}system ("pause");return 0;} 总结：
1. 一定要定义数组f[50]为long long类型，因为f[49]的值很大，导致int类型和long类型都放不下，
int、long、long long取值范围：
unsigned int 0～4294967295 int 2147483648～2147483647 unsigned long 0～4294967295
long 2147483648～2147483647
long long的最大值：9223372036854775807
long long的最小值：-9223372036854775808
unsigned long long的最大值：1844674407370955161
__int64的最大值：9223372036854775807
__int64的最小值：-9223372036854775808
unsigned __int64的最大值：18446744073709551615
2. 在使用输出函数printf输出f[n]时一定要%lld，因为定义的f[n]为long long类型
其中格式化字符串包括两部分内容:
一部分是正常字符, 这些字符将按原样输出;
另一部分是格式化规定字符, 以"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e4702277decc6b32ed55185cc830d4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf559e02a4ae3dee60af85b70b59a0cb/" rel="bookmark">
			Kernel 编译配置机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译kernel前需要一个配置相关的编译选项，最终的配置文件就是kernel根目录路下的 .config 文件
一：.config 这个文件里面保存的是kernel的配置选项，格式如下： CONFIG_XX_XX=y/n/m/0xFFFFFF/32/”XXXXXXX” 这个文件由/scripts/kconfig/mconf.c负责解析，然后解析该文件并将解析结果以宏定义的形式写入到/include/generated/autoconf.h中。/include/generated/autoconf.h将会被/include/linux/kconfig.h包含， 因此，需要关心配置情况的内核源文件只需要#include &lt;linux/config.h&gt;即可。 二：make menuconfig 分析一下这个主make menuconfig在Makefile中的大体流程，我的内核版本： VERSION = 3 PATCHLEVEL = 1 SUBLEVEL = 10 EXTRAVERSION = make menuconfig 与主Makefile 中的%config 目标匹配： 依赖关系： %config: scripts_basic outputmakefile FORCE ./mpatch_gen.sh $(Q)mkdir -p include/linux include/config $(Q)$(MAKE) $(build)=scripts/kconfig $@ 依赖 scripts_basic outputmakefile FORCE 这三个目标 1：FORCE 其中 FORCE 为伪目标 PHONY += FORCE FORCE: PHONY 中的项目被称为伪目标，伪目标作为另外一个目标的依赖时，每次执行此规则是，伪目标所定义的指令都会执行。这个规则没有命令也没有依赖，它的目标也不是一个存在的文件名。在执行此规则时，目标FORCE总会被认为是最新的。这样当它作为其它规则的依赖时，因为依赖总被认为被更新过的，所以那个规则的中定义的命令总会被执行。 在这里 每次执行make menuconfig 时候 都认为 FORCE 是更新过的 ，下面的三条命令也一定会执行！ 2：scripts_basic # Basic helpers built in scripts/ PHONY += scripts_basic scripts_basic: $(Q)$(MAKE) $(build)=scripts/basic $(Q)rm -f .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf559e02a4ae3dee60af85b70b59a0cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e484de3421360d20b49bda35b7d40a98/" rel="bookmark">
			尼采：快乐的知识（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快乐的知识
[德］尼采著
总序
阿诺德说：“诗歌拯救世界。”笛卡儿说：“我思故我在。”“诗”与“思”，也许原本就是人的两种最基本的精神存在方式。前者是一种本能的、审美的方式，后者是一种经验的、判断的方式；前者诉诸情感，后者诉诸理性。而海德格尔的“人在大地上诗意地栖居”，则仿佛在设计此两者的融合。一个大脑基本健全的人，是不可能不思考的，一个意识有了初步发展的人，也不可能不审美，而一个将“诗”与“恩”统一于一体的人，就有可能是一个意识活动最为活跃、精神生活最为丰富、情感世界最为多彩的人。
然而，在外部世界越来越丰富、越来越多彩的时候，我们却发现人类的“诗”与“思”都似乎越来越少了。在这样一个日益技术化、甚至数字化的时代，人们还能在多大程度上保持面对生活的诗意呢？换句话说，在科学的时代还需要诗歌吗？在有用性、精确性、合理性，还有所谓的可重复性、可操作性等等方面，诗歌无一不显示出了她的尴尬。但是，诗歌在现代生活中的意义仍永远是无可争议的，因为她与作为人类交际工具的语言之间有着最紧密的关系，因为她诉诸的是任何人都不可或缺的情感。
与此同时，如果不将科学思维和商业智慧等包括在内，人类的非功利思考也不是多了而是少了，对道德和价－值的判断，对存在及其意义的穷究，正在成为少数哲学家、思想家的“专业”，而整个人类却似乎有了比这更重要的事情（比如说挣钱）要做，换句话说，在教育程度普遍提高的当代，人们对自身精神生活状况的关注反而有所降低。将本世纪自然科学的发展和人文科学的发展作一个平行比较，就会发现，前者在这一世纪中所取得的进步据说数百倍于先前所有世纪之进步的总和，而后者的进展却很难说是革命性的，至少不能说有成倍的增卡。人类在各个方面的发展是需要维持某种平衡的，对地球之外宇宙空间的探索与对人类自身基因密码的破译基本同步，但在精神存在研究与物质存在研究这两个方面暂时还是不协调的。因此，人类无疑需要更多地思考。
无论在整个人类的发展中还是在一个人的生活中，保待灵魂与肉体、精神与物质的平衡都是非常重要的。而在人的精神生活中，“诗”与“思”的平衡发展也同样是重要的。我们需要“思”的庄重，也需要“诗”的空灵，我们需要“思”的结果，也需要“诗”的过程，两者都是我们精神生活最基本的立面。这大小两种平衡的谋得和维持，便是我们最正常的精神存在状态。
要维持这种状态，阅读也许是一种最佳方式，或曰一个捷径。我们可以在阅读中感受诗意，在阅读中加深思考。当然，人类的文明史已为我们提供了无数“诗”的读物和“思”的文本，也许，我们所有的文化遗产都可以归入这两大类。如今，我们又从那无数的读本中挑出儿册，我们选择的着眼点主要放在“诗”与“思”两种因素的相互渗透上。
这里的几本译作，或偏重于哲学如尼采的《快乐的知识》、克尔凯郭尔的《基替徒的激情》和阿兰的《幸福散论》，或偏重于诗歌如里尔克、帕斯捷尔纳克和茨维塔耶娃的《三诗人书简》、纪伯伦的《先知园》和布罗茨基的《文明的孩子》，但它们的特色却都在于“诗”与“思”的融合上，或者说，它们是思想的诗，或诗意的哲学。它们的作者早我们许久完成了精神和情感的长征，他们在前方呼唤我们：过有思想的生活，过有诗意的生活。
刘文飞
一九九八年六月五日
译者前言
《快乐的知识》一书，是尼采一八八二年撰写的，其中第五卷补写于一八八六年。他在第二版前言（一八八六年秋）中提及，此书是他大病初愈之后写就的，是疾病和痛苦娩出的胎儿，由于这次康复大出他的意外，故“快乐的知识”意味着“心灵的狂欢”,“康复的陶醉使他居然阐发诸多非理性、愚妄之论，抒发孟浪情愫，侈谈外表棘手而实则并非如此的种种问题”。
所谓“非理性”、“愚妄”、“孟浪”云云，当然是作者“自知性僻难谐俗”的自嘲；作为决意“为自己创造一个特殊太阳”的伟大哲学家、诗人，尼采在揭露和批判非神圣、非道德、非人性的世界时，处处表现出惊世骇俗的狂狷、放任和尖刻，往往言人之未言、言人之未敢言；庸人和道学家听起来似梦吧、塘语，与尼采心灵相通的人则有痛快淋漓之感。正是这些不合时宜的连珠妙语，显现尼采才藻富塘、哲理深邃、思辫明晰。
这本语录式的小书涉及的问题颇多，诸如生命、个体与群体本能、爱情、文艺、哲学、科学、道德、法律、宗教、社会发展……等等，是否可以说，尼采思想的精髓大体上已包罗在这部奇书里了。
现将书中沙及约问题择其要者介绍于后：
尼采力主保存个体本能和人的自由意志，指出群体本能意识、道德和宗教无不以否定个体本性和自我为目的。他响亮地喊出“你要成为你自己！”“情欲比禁欲和伪善好；诚实，即便是恶意的诚实也比因格守传统道德而失去自我好；自由之人可能为善，也可能为恶．然而，不自由的人则是站辱人之本性，因此不配分享天上和人间的安慰。总之，谁要做自由人，必先完全成为他自己。自由不会如神赐之物落在人的怀里。”尼采认为失去自我的人会有许多人性弱点：畸型、屏弱、平庸、畏葸、卑琐、笨拙、自感厌倦，尼采甚至尖刻地将其比之为“驯服动物”；又说：“内心的顺从和依附，正是你我不幸之所在：”关于个性的历练，尼采主张勇对不幸，说“世间存在不幸，这对个人来说是完全必要的。”“通往个人的天堂之路总要穿越个人的地狱。”因此，人要坦然直面恐惧、贫困、匮乏、黑暗、艰危和失误。
尼采对当时欧洲普遍盛行的道德准则是全盘否定的。道德被他称之为“道德猛兽”，指出“道德乃是个人的群体直觉”，揭露道德的伪善，是道德“打扮”了欧洲人，使其华贵、重要、体面乃至神圣；使愚蠢、盲目、疯癫、可疑的世界显得正义、智慧、圣洁、善良。
尼采在书中尖刻讽刺作家、诗人、戏剧家、艺术家充当“训育排练”者，无情鞭挞他们不敢正视现实，圆滑世故、见风使舵、作品虚伪、矫饰、煽惑、故作“激情”。
尼采在书里宣布：“上帝死了。”指出基督教的传统无论“爱”、“同情”、“仁慈”等说教也罢，提倡“禁欲主义”也罢，其宗旨都是扼杀个人。说“善与恶皆为上帝的偏见。”这个世界绝非“神圣”。
已为广大读者熟悉的价值重估问题，书中的原话是：“我相信，一切事物的价值必将重新评估。”这尤能显示尼采高蹈卓拔的见识和无所畏惧的勇气。他说：“当我们感到数千年的评估依然在禁锢着我们，左右着我们，真是度日维艰啊。”尼采的头脑里不存在什么伟人，故不囿于任何成说，而是敢为天下先。正如奥地利著名文学家茨威格赞颂（绝非恶意）道：尼采是德国哲学知识领域首先打出约一面“海盗黑旗”。他本人称自己是“未来时代的早产儿、头生子”，预见“上帝死后”必将出现道德坍塌、断裂、败坏、沉沦、倾覆等一系列后果，且被他死后的历史所应验。这，或许正是尼采的伟大和魅力所在了。
诚然，此书也并非字字珠玑、句句嘉言，全都令读者“快乐”。他对普通民众、工人、妇女、犹太人的蔑视，对奴隶制的称许，对社会主义者及社会主义运动的低毁，对东方民族、特别是对中国的偏见、贬抑均属纸缪之论，这在他那些旷达不羁、绝后空前的见解中渗杂了一些不和谐的音籁。但终究瑕不掩瑜，尼采卓然特立的瑰意琦行依旧启迪后昆，彪炳史册！
黄明嘉
一九九七年十二月于上海
目录
译者前言
卷一
1．阐释存在之意义的导师
2，理智的良知
3．高尚与卑贱
4．保存本性
5．绝对的责任
6．丧失尊严
7．写给辛勤劳作者
8．没有意识到的道德
9．我们的爆发
10．返祖现象
11．意识
12．科学的目的
13．力量意识
14．何谓爱情
15．远现
16．越过小径
17．对贫穷的激励
18．古代的傲慢
19．邪恶
20．愚昧的尊严
21．致无私的教师
22．上帝为国王而存在
23．腐致的征兆
24．不同约不满
25．预先认定不可知肠
26．生命是什么？
27．厌世者
28．至善有害
29．作补充说明的编子
30．名人的喜剧
31．买卖与高贵犯
32．不受欢迎的门生
33．教室之外
34．隐藏的历史
35．异端那说与巫术
36．遗言
37．三种错误
38．爆炸的人
39．改变了的趣味
40．缺乏高贵风度
41．懊悔
42．工作与无种
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e484de3421360d20b49bda35b7d40a98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9997de8b22409d2c2e32bd1f1b421b3c/" rel="bookmark">
			java关于字符串比较的注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java的使用中，无疑将使用大量的string类型的数据，很多时候，我们需要比较两个字符串
错误写法：if ( str1 == str2 )
正确写法：if(str1.equals(str2))
因为str1 == str2 是对str1 和str2 的存储地址进行比较，他们的值当然不相等了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60280f553b2ff35eaf9a0fb39901dc13/" rel="bookmark">
			keil main之前执行过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件复位后,第一步是执行复位处理程序,这个程序的入口在启动代码里(默认),摘录一段cortex-m3的复位处理入口代码:
Reset_Handler PROC ;PROC等同于FUNCTION,表示一个函数的开始,与ENDP相对? EXPORT Reset_Handler [WEAK] IMPORT SystemInit IMPORT __main LDR R0, =SystemInit BLX R0 LDR R0, =__main BX R0 ENDP Reset_Handler PROC	;PROC等同于FUNCTION,表示一个函数的开始,与ENDP相对?EXPORT Reset_Handler [WEAK]IMPORT SystemInitIMPORT __mainLDR R0, =SystemInitBLX R0LDR R0, =__mainBX R0ENDP 这里SystemInit函数是我自己用C代码写的硬件底层时钟初始化代码,这个可不算是keil mdk给代劳的.初始化堆栈指针、执行完用户定义的底层初始化代码后,发现接下来的代码是调用了__main函数,这里之所以有__main函数，是因为在C代码中定义了main函数， 函数标签 main() 具有特殊含义。main() 函数的存在强制链接器链接到 __main 和 __rt_entry 中的初始化代码。 其中，__main函数执行代码和数据复制、解压缩以及 ZI 数据的零初始化。解释一下，C代码中，已经赋值的全局变量被放在RW属性的输入节中，这些变量的初值被keil mdk压缩后放到ROM或Flash中（RO属性输入节）。什么是赋值的全局变量呢？如果你在代码中这样定义一个全局变量：int nTimerCount=20；变量nTimerCount就是已经赋值的变量，如果是这样定义：int nTimerCount；变量nTimerCount就是一个非赋值的变量，keil默认将它放到属性为ZI的输入节。为什么要压缩呢？这是因为如果赋值变量较多，会占用较多的Flash存储空间，keil 默认用自己的压缩算法。这个“解压缩”就是将存放在RO输入区（一般为ROM或Flash）的变量初值，按照一定算法解压缩后，拷贝到相应RAM区。ZI数据清零是指将ZI区的变量所在的RAM区清零。使用 UNINIT 属性对执行区进行标记可避免 __main 对该区域中的 ZI 数据进行零初始化。这句话很重要，比如我有一些变量，保存一些重要信息，不希望复位后就被清零，这时就可以用分散加载文件定义一块UNINIT属性的区，将不希望零初始化的变量定义到这个区即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1288eb53cf549fd370aafeb736835197/" rel="bookmark">
			“bash: fork: Resource temporarily unavailable”的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天，我登陆到一台服务器上，偶尔就出现”bash: fork: Resource temporarily unavailable”的提示，这是什么命令都不能用，但偶尔过一会就好了。前两天也没太在意，今天再次遇到，然后找到了根本原因。
当出现”bash: fork: Resource temporarily unavailable”时，一般来说是系统上的进程数量太多了，达到了命令”ulimit -u”的限制。（当系统进程达到限制后，kernel会自动kill掉一些进程，这就是好我过一会又能操作的原因了。）这种情况产生的原因，一是某个程序有bug，不断地fork新的进程消耗系统资源，二是可能中了病毒（恶意程序），比如所谓的fork炸弹。
我进行了如下操作：
[repo@vt-sync jay]$ ulimit -u 1024 [repo@vt-sync jay]$ ps -ef | wc -l 1221 [repo@vt-sync jay]$ ps ux | wc -l 1020 发现当前用户下面居然有1020个进程，我仔细一看，很多的”vgt-sync.sh”之类的进程，这个shell脚本是我自己以前写的啊，里面有一个while的死循环，本来单独运行这个脚本是正确的，没有任何问题，但是我却把它配置到crontab任务中每小时都去运行，这样就会每小时都会新增一个vgt-sync.sh进程，随着时间的推移，本机上的进程就越来越多了，从而导致了上面的问题。 所以，我的找到原因，解决方法就简单了，显示kill掉这些进程，然后修改我的脚本，既然用了crontab就别写死循环了。 [repo@vt-sync jay]$ ps ux | wc -l 1020 [repo@vt-sync jay]$ killall vgt-sync.sh #(wait for several seconds.) [repo@vt-sync jay]$ ps ux | wc -l 12 再来看看我的那个非常简单脚本吧，刚好和crontab结合起来使用就有了bug了。 #! /bin/bash set -x linux_dir="/home/repo/pub/linux-vgt.git/" xen_dir="/home/repo/pub/xen-vgt.git/" while [ 1 ] do cd $linux_dir git pull cd $xen_dir git pull sleep 30 done 我遇到的情况是自己的程序bug，下面简单说一下fork炸弹吧。 所谓fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，fork炸弹并不需要有特别的权限即可对系统造成破坏。现在来看一个最简单的fork炸弹: :() { :|:&amp; };: 一行看似无法理解的只有13个字符的命令，即可占用掉所有系统的资源。其实，这行命令如果这样写成bash script就不难理解了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1288eb53cf549fd370aafeb736835197/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74836d989111b10b74a26605ebe08dcf/" rel="bookmark">
			Llvm的类型转换系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Llvm内置了一个类型转换系统，并定义了类似于dynamic_cast这样的转换函数。Llvm底层的很大部分是由模板类构成的，这个转换系统对于模板类间的类型判断及转换至为重要。以下只是描述这个转换系统的一个框架，该系统的正确实现，还依赖于参与模板类正确实现某些函数（下面会提到）。
cast_retty类 cast_or_null是llvm所提供的类型转换系统的部分，这是一个有趣的模板实现。这个实现在llvm-3.1/include/llvm/support/Casting.h。
202 template &lt;class X, class Y&gt;
203 inline typename cast_retty&lt;X,Y*&gt;::ret_type_cast_or_null(Y *Val) {
204 if (Val == 0) return0;
205 assert(isa&lt;X&gt;(Val) &amp;&amp; "cast_or_null&lt;Ty&gt;()argument of incompatible type!");
206 returncast&lt;X&gt;(Val);
207 }
首先，cast_or_null的返回类型是cast_retty中定义的ret_type类型。cast_retty只定义了ret_type（cast_retty顾名思义是cast return type的意思）。
156 template&lt;class To, classFrom&gt;
157 struct cast_retty{
158 typedef typename cast_retty_wrap&lt;To,From,
159 typenamesimplify_type&lt;From&gt;::SimpleType&gt;::ret_typeret_type;
160 };
这个ret_type则是typedef自cast_retty_wrap提供中定义的ret_type。
142 template&lt;class To, class From,class SimpleFrom&gt;
143 struct cast_retty_wrapp{
144 // When thesimplified type and the from type are not the same, use the type
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74836d989111b10b74a26605ebe08dcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4606c6fa83b536a3260c871463f2e960/" rel="bookmark">
			cocos2d-x安装配置步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cocos2dx3.0（非beta版本）安装步骤 1.首先下载好python2.7版本（用于脚本创建项目）
2.安装好编程软件，推荐visual studio2013或者是visual studio2012，因为cocos-2ds-3.0使用C++11的特性，不建议使用vs2010。
3.我的cocos2dx3.0正式版的安装路径为F:\cocos2d-x-3.0（定义这为COCOS_ROOT）
官方实例项目的打开：
在目录COCOS_ROOT\build下，我们可以看到cocos2d-win32.vc2012.sln这样的工程，这是官方为我们提供的实例项目，想要实现某种效果可以在这里查阅学习。
创建新项目：
1.在目录COCOS_ROOT\tools\cocos2d-console\bin下，有脚本cocos.py用于项目的创建
2.计算机-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量，在系统变量的path里添加内容：COCOS_ROOT\tools\cocos2d-console\bin
3.win键-&gt;cmd打开cmd窗口，输入cocos new -h看看是否配置正确
4.创建新项目：cocos new 项目名字 -l cpp -d 项目存放的目录 （这里取消了beta版本在tools文件夹下的project-creator这样的点击脚本出现窗口来创建项目的方式）
cocos2d-x 3.0后面的rc和3.2版本有了一个很大的改动，可以参考以下的blog内容
http://blog.csdn.net/star530/article/details/21483729
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e210c834f34fc24b5afa1fd23c50f0c/" rel="bookmark">
			STP 3 - 生成树协议中4个guard 和 3个fast加一个filter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近出的几个问题总是和生成树协议有问题，复习的时候顺带总结，温故而知新。
先上一个大牛总结的图(Vinny), 总结的非常好，你看完后面的文章再来看这张图就会会心一笑 - i got it !
先讲下计时器，不论什么协议总是有些计时器，Hello数据包什么的。尤其到路由协议，怎么建立邻居关系，怎么通知拓扑改变，各种不同路由协议是各显神通。
所以在理解的时候最好要了解为什么这些协议需要计时器等等，这样我们就可以以不变应万变。
STP Timer （计时器的配置在当前交换机成为根桥时有用，因为默认只有根桥产生bpdu）
Hello - 发送BPDU的频率，默认2sMax Age - 在没有收到bpdu的情况下保持在block mode，默认20sForward Delay - 在listening 和 learning阶段等待时间，默认各15s 配置：
Router(config)#spanning-tree vlan 1 hello-time ?
&lt;1-10&gt; number of seconds between generation of config BPDUs
Router(config)#spanning-tree vlan 1 forward-time ?
&lt;4-30&gt; number of seconds for the forward delay timer
Router(config)#spanning-tree vlan 1 max-age ?
&lt;6-40&gt; maximum number of seconds the information in a BPDU is valid
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e210c834f34fc24b5afa1fd23c50f0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc16a84d61aab8ebea772a8a74c5e50/" rel="bookmark">
			FFTW使用小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
================
FFTW—Fastest Fourier Transform in the West,是由 MIT 的 Matteo Frigo 博士和 Steven G. Johnson 博士开发的一个完全免费的软件包。FFTW 最初的 release 版本于 1997 年发布,最新的 release 版本 fftw-3.3.4。git路径:
https://github.com/FFTW/fftw3.git
它是一个 C 语言开发的库,支持任意大小的、任意维数的数据的离散傅里叶变换(DFT),并且还支持离散余弦变换(DCT)、离散正弦变换(DST)和离散哈特莱变换(DHT)
数据类型
================
FFTW 有三个版本的数据类型:double、float 和 long double,使用方法如下:
1.链接对应的库(比如 libfftw3-3、libfftw3f-3、或 ibfftw3l-3)
2.包含同样的头文件 fftw3.h
将所有以小写"fftw_"开头的名字替换为"fftwf_"(float 版本)或"fftwl_"(long double 版本)。比如将 fftw_complex 替换为 fftwf_complex,将 fftw_execute
替换为 fftwf_execute 等。
3.所有以大写"FFTW_"开头的名字不变
4.将函数参数中的 double 替换为 float 或 long double
5.最后,虽然 long double 是 C99 的标准,但你的编译器可能根本不支持该类型,或它并不能提供比 double 更高的精度。
6.fftw_malloc 考虑了数据对齐,以便使用 SIMD 指令加速,所以最好不要用 C 函数malloc 替代,而且不要将 fftw_malloc、fftw_free 和 malloc、free、 delete 等混用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cc16a84d61aab8ebea772a8a74c5e50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b19e64f6d012ca1dd70312eb897a0347/" rel="bookmark">
			构造、析构、继承对对象的影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;bitset&gt;
using namespace std;
​class A{
public:
A(){cout&lt;&lt;"A default constructor"&lt;&lt;endl;}
};
int main()
{
cout&lt;&lt;"------test class-------"&lt;&lt;endl;
A *a = new A[5]; // will call default constructor to initialization, if no default constructor will raise compile error.
cout&lt;&lt;"------test inner type-----"&lt;&lt;endl;
int *b = new int [3](); //initialize
for(int i=0; i&lt;3; i++)
{
cout&lt;&lt;b[i]&lt;&lt;endl;
}
cout&lt;&lt;"------test const array------"&lt;&lt;endl;
const string *c = new const string[2];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b19e64f6d012ca1dd70312eb897a0347/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9961bf848485416b8e8d98cdba177fbb/" rel="bookmark">
			Keepalived工具安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		装keepalived前，要先检查主机上是否已经安装， ps -ef | grep keepalive 不检查的话，容易把前人装的东西覆盖掉，那么以前弄的配置文件都没了比较麻烦。 以下都为root用户 root用户上传工具，压缩包就200多k，不大。 cd &amp;&amp; mkdir fwy &amp;&amp; chmod 777 fwy &amp;&amp; cd fwy scp padba@cnsz081003:/paic/dba/dbsoft/mysql/keepalived-1.1.19.tar.gz . 密码MdCg2014 tar xvf keepalived-1.1.19.tar.gz mv keepalived-1.1.19 .. 安装OpenSSL [root@cnsh042942 fwy]# yum install openssl-devel Loaded plugins: product-id, security, subscription-manager This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register. el6_u5_base | 1.2 kB 00:00 Setting up Install Process Package openssl-devel-1.0.1e-15.el6.x86_64 already installed and latest version Nothing to do 编译并安装 mv /root/fwy/keepalived-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9961bf848485416b8e8d98cdba177fbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4632c9bb7862d26dc9f41271622cca40/" rel="bookmark">
			Visual Studio 2010 c&#43;&#43;经典入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列教程地址：http://www.jizhuomi.com/software/129.html
要源文件和课件的请留言，留下口口邮箱
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95cc0dbe7cc8bb6c4dda8d37ab11bd3d/" rel="bookmark">
			修改tomcat编码格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 修改tomcat默认编码格式： 修改tomcat下的conf/server.xml文件，找到如下代码： &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 这段代码规定了Tomcat监听HTTP请求的端口号等信息。可以在这里添加一个属性：URIEncoding，将该属性值设置为UTF-8，即可让Tomcat（默认ISO-8859-1编码）以UTF-8的编码处理get请求。更改后的代码如下所示： &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" URIEncoding="UTF-8" redirectPort="8443" /&gt; 以上，本人虽然没有遇到过这种乱码问题，但是还是在网上查了一下，导致中文乱码的几种情况，首先看下字符编码有哪几种呢？ 1、ASCII字码 2、IS0-8859-1 3、GB2312和GBK 4、Unicode编码 5、UTF-8 导致中文乱码的可能情况： 1、表单的get提交 2、表单的post提交 3、页面链接传递中文参数 4、地址栏中参数直接输入中文提交 对于get方式提交的乱码，可以通过修改tomcat配置文件来修改，对于post方式提交的乱码可以通过设置编码，request.setCharacterEncoding("UTF-8")方法进行编码设置 以上，由于本人没有遇到过这类问题，网络搜集，仅供参考 参考资料 ： http://www.52testing.com/showart.asp?id=59 http://blog.sina.com.cn/s/blog_a52381ef0101k40t.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05176875616c365b1823a3bdd51b346a/" rel="bookmark">
			用栈将 n 全排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用栈将n全排列.这里是我的代码，可是就是运行不出结果，哪个大神给我看看，万分感谢。 （一） public interface nStackADT { public void initial(int n); public boolean stackfull(int n); public void stackprint(int n) ; public void stackoutfile(int n) ; public void stackback(); public void stackadd(int n) ; public void stackmov(int n) ; public void stackfun(int n) ; } （二） import java.util.EmptyStackException; import java.security.PrivilegedExceptionAction; public class nStack implements nStackADT { private int stack[]; private int top=-1; private int a[], b[], c[];//分别表示当前数的值,改变后的值,及改变的次数. private final int DEFUALT_CAPACITY = 20; /********************** * 对栈进行初始化.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05176875616c365b1823a3bdd51b346a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c35355471fc152661d36971aa7c808d/" rel="bookmark">
			后缀数组模版 及 可重叠和不可重叠最长重复子串【for_wind】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做了些机试题目，有道题目（不重复最长重复子串）测试时没想出有效解法，后来看到后缀数组，额，强大啊。记录之，分享之。有错误的地方，请留言啊，谢谢亲们~~~~~~~~~~~~~~~~~
概念部分，请查看参考资料2、3哦
//for_wind
一、后缀数组 （1）基本概念 1、字符串的大小比较： 关于字符串的大小比较，是指通常所说的 “ 字典顺序 ” 比较。如a&lt;b，aab&lt;ab，a&lt;ab。
注：从字符串的大小比较的定义看，字符串s的所有后缀中任其中一对(u,v)不可能会相等，因为必要条件 len(u) ≠ len(v)不可能满足。所以任一字符串s中有len(s)个互不相同的后缀。我们可以将s的所有后缀排列，利用 后缀数组sa 与 名次数组rank 储存。 2、后缀数组sa： 将s的n个后缀从小到大排序后将 排序后的后缀的开头位置 顺次放入sa中，则sa[i]储存的是排第i大的后缀的开头位置。
简单的记忆就是“排第几的是谁”。 3、名次数组rank： rank[i]保存的是suffix(i)｛后缀｝在所有后缀中从小到大排列的名次。则 若 sa[i]=j，则 rank[j]=i。
简单的记忆就是“你排第几”。 4、sa和rank的关系 对于 后缀数组sa 与 名次数组rank ，有 rank[ sa[i] ]=i
（这是很重要的一点，通过sa与rank的关系可以求出后缀数组）
由此可看出，后缀数组sa 与名次数组rank的关系为互逆关系。 Figure 1字符串aabaaaab的sa数组与rank数组
（2）倍增算法 1、主要思路： 倍增，s[i..i + 2^k − 1]的排名通过s[i..i + 2^(k − 1) − 1]和s[i + 2^(k − 1) − 1..i + 2^k] 的排名得到。
2、简要过程。 略。请参考最下面的参考资料3。嘻嘻。
Figure2倍增算法的计算过程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c35355471fc152661d36971aa7c808d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dcb2aa684fe3b9e9b2ba352d6782b8f/" rel="bookmark">
			研究生手册彭明辉教授
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、论文的要求 我对硕士论文的基本要求是： （1）论文的主要内容，是叙述一套方法在一个特定场合中的应用。 （2）这套方法必须要有所创新或突破，并因而对学术界有所贡献。因此，它或者是解决既有问题的新方法，或者是既有方法的新应用，或者是以一个新的方法开启一整片新的应用领域。 （3）在论文中，你必须要有能力提出足够的证据来让读者信服说：针对这个应用场合，你所提出来的方法确实有比文献中一切既有方法更优越之处。 （4）此外，你必须要能清楚指出这个方法在应用上的限制，并且提出充分证据来说服读者：任何应用场合，只要能够满足你所提出来的假设（前提）条件，你的方法就一定适用，而且你所描述的优点就一定会存在。 （5）你还必须要在论文中清楚指出这个方法的限制和可能的缺点（相对于其它文献上的既有方法，或者在其它应用场合里）。假如飧龇椒ㄓ腥魏沃卮笕钡悖诳谑允辈疟豢谑晕敝赋隼矗浜蠊锌赡苁锹畚奈薹ㄍü?nbsp; （6）行文风格上，它是一篇论证严谨，逻辑关系清晰，而且结构有条理的专业论述。也就是说，在叙述你的方法的过程，你必须要清清楚楚地交代这个方法的应用程序以及所有仿真或实验结果的过程，使得这个专业领域内的任何读者，都有办法根据你的描述，在他的实验室下复制出你的研究成果，以便确定你的结论确实是可以「在任何时间、任何地点、任何人」都具有可重复性（可重复性是「科学」的根本要求）。 （7）而且，你对这个方法的每一个步骤都必须要提供充分的理由说明「为什么非如此不可」。 （ 8）最后，你的论文必须要在适当位置清楚注明所有和你所研究之题目相关的文献。而且，你必须要记得：只要是和你所研究的问题相关的学术文献（尤其是学术期刊论文），你都有必要全部找出来（如果漏掉就是你的过失），仔细读过。假如你在学位论文口试时，有口试委员指出有一篇既有文献，在你所讨论的问题中处理得比你的方法还好，这就构成你论文无法及格的充分理由。 （9）第（2）款所谓「对学术界的贡献」，指的是：把你的所有研究成果扣除掉学术界已经发表过的所有成果（不管你实际上有没有参考过，没有参考过也算是你的重大过失），剩下的就是你的贡献。假如这个贡献太少，也构成你论文无法及格的充分理由。 上面所叙述的九款要件中，除第（2）款之外，通通都是必须要做到的，因此没有好坏之分。一篇硕士论文的好坏（以及成绩的评定标准），主要是看第（2）款所谓「对学术界的贡献」的多寡与重要性而定。假如你要申请国外的博士班，最重要的也是看你的硕士论文有什么「贡献」而定（这往往比TOFEL、GRE、GPA还重要）。 一个判断硕士论文的好坏有一个粗浅办法：假如你的研究成果可以在国外著名学术期刊（journals，而非 magazines）上发表，通常就比一篇只能在国外学术会议（conferences）上发表的硕士论文贡献多；一篇国外学术会议的论文又通常比无法发表的论文贡献多；在国际顶尖学术期刊上发表的论文通常比一篇二流的学术期刊论文贡献多。SCI有一种叫做 Impact Factor 的指数，统计一个期刊每篇论文被引述的次数。通常这个次数（或指数）愈高，对学术界的影响力就愈大。以机械视觉相关领域的期刊而言，Impact Factor 在 1.0 以上的期刊，都算是顶尖的期刊。这些期刊论文的作者，通常是国外顶尖学府的著名教授指导全球一流的博士生做出来的研究成果。 二、完成硕士论文所需要的能力 从前面的叙述可以归纳出来，完成硕士论文所需要的能力包括以下数项，依它们的培养先后次序逐项讨论。 （1）资料检索的能力：在给定（或自己拟定）的题目范围内，你必须有能力利用文资料索引系统，查出所有相关的论文，而无任何遗漏（否则你可能在论文口试时才发现同一个题目已经有人发表过了）。你到底要用什么样的关键词和查所程序去保证你已经找出所有相关的文献？这是第一个大的挑战。每一组关键词（包含联集与交集）代表一个论文所构成的集合，假如你用的关键词不恰当，你可能找到的集合太小，没有涵盖所有的相关文献；假如你用的关键词太一般化（譬如「image」），通常你找到的集合会太大，除了所有相关文献之外还加上好几十倍的毫不相关的文献。 （2）资料筛选的能力：即使你使用了恰当的搜寻策略，通常找到的文献集合都还是明显地比你所需要的集合大，而且通常文献比数大概在一两百篇或数百篇之间，而其中会和你的的研究子题直接且密切相关的论文，通常只有廿、卅篇左右。你如何可以只读论文的题目、摘要、简介和结论，而还没有完全看懂内文，就准确地判断出这篇论文中是否有值得你进一步参考的内容，以便快速地把需要仔细读完的论文从数百篇降低到廿、卅篇？这考验着你从事资料筛选的能力。 （3）期刊论文的阅读能力：期刊论文和大学部的课本截然不同。大学部的课本是寻次渐进地从最基本的知识背景逐步交代出整套有系统的知识，中间没有任何的跳跃，只要你逐页读下去，就可以整本都读懂，不需要在去别的地方找参考资料。但是期刊论文是没头没尾的十几页文献，只交代最核心的创意，并援引许多其它论文的研究成果（但只注明文献出处，而完全没有交代其内容）。因此，要读懂一篇论文，一定要同时读懂数篇或十数篇被援引的其它论文。偏偏，这十几篇被援引的论文又各自援引十数篇其它论文。因此，相对于大学部的教科书而言，期刊论文是一个极端没有系统的知识，必须要靠读者自己从几十篇论文中撷取出相关的片段，自己组织成一个有系统的知识，然后才有办法开始阅读与吸收。要培养出这种自己组织知识的能力，需要在学校靠着大量而持续的时间去摸索、体会，而不可能只利用业余的零星时间去培养。因此，一个大学毕业后就不再念研究所的学生，不管他在毕业生和大学毕业生最大的差别，就是：学士只学习过吸收系统知识的能力（也就是读别人整理、组织好的知识，典型的就是课本）；但硕士则学习过自己从无组织的知识中检索、筛选、组织知识的能力。 （4）期刊论文的分析能力：为了确定你的学位论文研究成果确实比所有相关的学术期刊论文都更适合处理你所拟定的应用场域，首先你必须要有能力逐篇分析出所有相关期刊论文的优点与缺点，以及自己的研究成果的优点与缺点，然后再拿他们来做比较，总结出你的论文的优点和缺点（限制）。但是，好的期刊论文往往是国外著名学府的名师和一流的博士生共同的研究成果，假如你要在锁定的应用场域上「打败」他们，突出自己的优点，这基本上是一个极端困难的挑战。即使只是要找出他们的缺点，都已经是一个相当困难的工作了。一个大学毕业生，四年下来都是假定「课本是对的」这样地学下来的，从来没有学习如何分析课本知识的优缺点，也就是「只有理解的能力，而没有批判的能力」。硕士生则必须要有「对一切既有进行精确批判」的能力。但是，这个批判并非个人好恶或情绪化的批判，而是真的找得到充分理由去支持的批判。这个批判的能力，让你有能力自己找到自己的优、缺点，因此也有机会自己精益求精。所以，一个大学毕业生在业界做事的时候，需要有人指导他（从事批判性检验），帮他找出缺点和建议改进的可能性。但是，一个严格训练过的合格硕士，他做事的时候应该是不需要有人在背后替他做检证，他自己就应该要有能力分析自己的优、缺点，主动向上级或平行单位要求支持。其实，至少要能够完成这个能力，才勉强可以说你是有「独立自主的判断能力」。 （5）创新的能力：许多大学毕业的工程师也能创新，但是硕士的创新是和全世界同一个学术团体内所有的名师和博士生挑战。因此，两者是站在不同的比较基础上在进行的：前者往往是一个企业内部的「闭门造车」，后者是一个全球的开放性竞争。其次，工程师的创新往往是无法加以明确证明其适用条件，但是学术的创新却必须要能够在创新的同时厘清这个创新的有效条件。因此，大学毕业生的主要能力是吸收既有知识，但硕士毕业生却应该要有能力创造知识。此外，台湾历年来工业产品的价位偏低，这一部分是因为国际大厂的打压以及国际消费者的信任不易建立。但是，另一方面，这是因为台湾的产品在品质上无法控制，因此只好被当作最粗糙的商品来贩卖。台湾的产品之所以无法有稳定的品质，背后的技术原因就是：各种创新都是只凭一时偶然的巧思，却没有办法进一步有系统地厘清这些巧思背后可以成立的条件。但是，创新其实是可以有一套「有迹可寻」的程序的，这是我最得意的心得，也是我最想教的。 三、为什么要坚持培养阅读与分析期刊论文的能力 我所以一直坚持要训练研究生阅读与分析期刊论文的能力，主要是为了学生毕业后中长期的竞争力着想。 台湾从来都只生产国外已经有的产品，而不事创新。假如国外企业界比国外学术的技术落后三年，而台湾的技术比国外技术落后五年，则台湾业界所需要的所有技术都可以在国外学术期刊上找到主要的理论依据和技术核心构想（除了一些技术的细节和 know how 之外）。因此，阅读期刊的能力是台湾想要保持领先大陆技术的必备条件。 此外，只要能够充分掌握阅读与分析期刊论文的技巧，就可以水到渠成地轻松进行「创新」的工作。所以，只要深入掌握到阅读与分析期刊论文的技巧，就可以掌握到大学生不曾研习过的三种能力：（1）自己从无组织的知识中检索、筛选、组织知识的能力、（2）对一切既有进行精确批判的独立自主判断能力、（3）创造新知识的能力。 创新的能力在台湾一直很少被需要（因为台湾只会从国外买整套设备、制程和设计与制造的技术）。但是，大陆已经成为全球廉价品制造中心，而台商为了降低成本也主动带技术到大陆设厂（包括现在的晶元代工），因此整个不具关键性技术的制造业都会持续往大陆移动；甚至 IC 的设计（尤其数字的部分）也无可避免地会迅速朝向「台湾开系统规格，进行系统整合，大陆在前述架构下开发特定数位模块」的设计代工发展。因此，未来台湾将必然会被逼着朝愈来愈创意密集的创意中心走（包括商务创意、经营创意、产品创意、与技术创新）。因此，不能因为今天台湾的业界不需要创新的能力，就误以为自己一辈子都不需要拥有创新的能力。 我在协助民间企业发展技术研发的过程中，碰到过一位三十多岁的厂长。他很聪明，但从小家穷，被环境逼着去念高工，然后上夜校读完工专。和动态性能（ bandwidth、response speed等）无关的技术他都很深入，也因为产品升级的需要而认真向我求教有关动态性能的基本观念。但是，怎么教他都不懂，就只因为他不懂工程数学。偏偏，工程数学不是可以在工厂里靠自修读会的。一个那么聪明的人，只因为不懂工数，就注定从三十岁以后一辈子无法在专业上继续成长！他高工毕业后没几年，廿多岁就当课长，家人与师长都以他为荣；卅岁当厂长，公司还给他技术股，前途无量；谁想得到他会在卅岁以后被逼着「或者升级，或者去大陆，或者失业」？ 每次想起这位厂长，看着迫不急待地要到台积电去「七年赚两千万退休金」的学生，或者只想学现成可用的技术而不想学研究方法的学生，我总忍禁不住地要想：十年后，我教过的学生里，会不会有一堆人就只因为不会读期刊论文而被逼提前退休？ 再者，技术的创新并不是全靠聪明。我熟谙一套技术创新的方法，只要学会分析期刊论文的优缺点，就可拿这套方法分析竞争对手产品的优缺点；而且，只要再稍微加工，就可以从这套优缺点的清单里找到突破瓶颈所需的关键性创意。这套创新程序，可以把「创新」变成不需要太多天分便可以完成的事，从而减轻创意的不定性与风险性。因此，只要会分析论文，几乎就可以轻易地组合出你所需要的绝大部分创意。聪明是不可能教的，但这套技巧却是可以教的；而且只要用心，绝大部分硕士生都可以学会。 就是因为这个原因，我的实验室整个训练的重心只有一个：通过每周一次的 group meeting，培养学生深入掌握阅读与分析期刊论文的技巧，进而培养他们在关键问题上突破与创新的能力。 四、期刊论文的分析技巧与程序 一般来讲，好的期刊论文有较多的创意。虽然读起来较累，但收获较多而深入，因此比较值得花心思去分析。读论文之前，参考SCI Impact Factor 及学长的意见是必要的。 一篇期刊论文，主要分成四个部分。 （1）Abstract： 说明这篇论文的主要贡献、方法特色与主要内容。最慢硕二上学期必须要学会只看 Abstract 和Introduction便可以判断出这篇论文的重点和你的研究有没有直接关连，从而决定要不要把它给读完。假如你有能力每三十篇论文只根据摘要和简介便能筛选出其中最密切相关的五篇论文，你就比别人的效率高五倍以上。以后不管是做事或做学术研究，都比别人有能力从更广泛的文献中挑出最值得参考的资料。 （2）Introduction： Introduction 的功能是介绍问题的背景和起源，交代前人在这个题目上已经有过的主要贡献，说清楚前人留下来的未解问题，以及在这个背景下这篇论文的想解决的问题和它的重要性。对初学的学生而言，从这里可以了解以前研究的概况。通常我会建议初学的学生，对你的题目不熟时，先把跟你题目可能相关的论文收集个 30～40篇，每篇都只读Abstract 和 Introduction，而不要读 Main Body（本文），只在必要时稍微参考一下后面的 Illustrative examples和 Conclusions，直到你能回答下面这三个问题：（2A）在这领域内最常被引述的方法有哪些？（2B）这些方法可以分成哪些主要派别？（2C）每个派别的主要特色（含优点和缺点）是什么？ 问题是，你怎么去找到这最初的30～40篇论文？有一种期刊论文叫做「review paper」，专门在一个题目下面整理出所有相关的论文，并且做简单的回顾。你可以在搜寻 Compendex 时在 keywords 中加一个「review」而筛选出这类论文。然后从相关的数篇review paper 开始，从中根据 title 与 Abstract 找出你认为跟你研究题目较相关的30～40篇论文。 通常只要你反复读过该领域内30～40篇论文的Abstract 和 Introduction，你就应该可以从Introduction的评论中回答（2A）和（2B）这两个问题。尤其要记得，当你阅读的目的是要回答（2A）和（2B）这两个问题时，你一定要先挑那些 Introduction写得比较有观念的论文念（很多论文的Introduction 写得像流水帐，没有观念，这种论文刚开始时不要去读它）。假如你读过假如30～40篇论文的 Abstract 和 Introduction之后，还是回答不了（2C），先做下述的工作。 你先根据（2A）的答案，把这领域内最常被引述的论文找齐，再把他们根据（2B）的答案分成派别，每个派别按日期先后次序排好。然后，你每次只重新读一派的 Abstract 和 Introduction（必要时简略参考内文，但目的只是读懂Introduction内与这派有关的陈述，而不需要真的看懂所有内文），照日期先后读 ，读的时候只企图回答一个问题：这一派的创意与主要诉求是什么？这样，你逐派逐派地把每一派的Abstract 和 Introduction 给读完，总结出这一派主要的诉求 、方法特色和优点（每一篇论文都会说出自己的优点，仔细读就不会漏掉）。 其次，你再把这些论文拿出来，但是只读Introduction，认真回答下述问题：「每篇论文对其它派别有什么批评？」然后你把读到的重点逐一记录到各派别的「缺点」栏内。 通过以上程序，你就应该可以掌握到（2A）、（2B）、和（2C）三个问题的答案。这时你对该领域内主要方法、文献之间的关系算是相当熟捻了，但是你还是只仔细 读完Abstract 和 Introduction而已，内文则只是笼统读过。 这时候，你已经掌握到这领域主要的论文，你可以用这些论文测试看看你用来搜寻这领域论文的 keywords 到底恰不恰当，并且用修正过的 keywords 再搜寻一次论文，把这领域的主要文献补齐，也把原来30～40篇论文中后来发现关系较远的论文给筛选掉，只保留大概20篇左右确定跟你关系较近的文献。如果有把握，可以甚至删除一两个你不想用的派别（要有充分的理由），只保留两、三个派别（也要有充分的理由）继续做完以下工作。 然后你应该利用（2C）的答案，再进一步回答一个问题（2D）：「这个领域内大家认为重要的关键问题有哪些？有哪些特性是大家重视的优点？有哪些特性是大家在意的缺点？这些优点与缺点通常在哪些应用场合时会比较被重视？在哪些应用场合时比较不会被重视？」然后，你就可以整理出这个领域（研究题目）主要的应用场合，以及这些应用场合上该注意的事项。 最后，在你真正开始念论文的 main body 之前，你应该要先根据（2A）和（2C的答案，把各派别内的论文整理在同一个档案夹里，并照时间先后次序排好。然后依照这些派别与你的研究方向的关系远近，一个派别一个派别地逐一把各派一次念完一派的 main bodies。 （3）Main body（含simulation and/or experimental examples）： 在你第一次有系统地念某派别的论文 main bodies 时，你只需要念懂：（3A）这篇论文的主要假设是什么（在什么条件下它是有效的），并且评估一下这些假设在现实条件下有多容易（或多难）成立。愈难成立的假设，愈不好用，参考价值也愈低。（3B）在这些假设下，这篇论文主要有什么好处。（3C）这些好处主要表现在哪些公式的哪些项目的简化上。至于整篇论文详细的推导过程，你不需要懂。除了三、五个关键的公式（最后在应用上要使用的公式，你可以从这里评估出这个方法使用上的方便程度或计算效率，以及在非理想情境下这些公式使用起来的可靠度或稳定性）之外，其它公式都不懂也没关系，公式之间的恒等式推导过程可以完全略过去。假如你要看公式，重点是看公式推导过程中引入的假设条件，而不是恒等式的转换。 但是，在你开始根据前述问题念论文之前，你应该先把这派别所有的论文都拿出来，逐篇粗略地浏览过去（不要勉强自己每篇或每行都弄到懂，而是轻松地读，能懂就懂，不懂就不懂），从中挑出容易念懂的 papers，以及经常被引述的论文。然后把这些论文照时间先后次序依序念下去。记得：你念的时候只要回答（3A）、（ 3B）、（3C）三个问题就好，不要念太细。 这样念完以后，你应该把这一派的主要发展过程，主要假设、主要理论依据、以及主要的成果做一个完整的整理。其次，你还要在根据（2D）的答案以及这一派的主要假设，进一步回答下一个问题：（3D）这一派主要的缺点有哪些。最后，根据（ 3A）、（3B）、（3C）、（3D）的答案综合整理出：这一派最适合什么时候使用，最不适合什么场合使用。 记住：回答完这些问题时，你还是不应该知道恒等式是怎么导出来的！ 当你是生手的时候，你要评估一个方法的优缺点时，往往必须要参考它Examples。但是，要记得：老练的论文写作高手会故意只 present 成功的案例而遮掩失败的案例。所以，simulation examples and/or experiments 很棒不一定表示这方法真的很好。你必须要回到这个方法的基本假设上去，以及他在应用时所使用的主要公式（resultant equations）去，凭自己的思考能力， 并且参考（2C）和（2D）的答案，自己问问看：当某某假设在某些实用场合上无法成立时，这个方法会不会出什么状况？猜一猜，预测一下这个方法应该会在哪些条件下（应用场合）表现优异，又会在哪些条件下（应用场合）出状况？根据这个猜测再检验一次simulation examples and/or experiments，看它的长处与短处是不是确实在这些examples 中充分被检验，且充分表现出来。 那么，你什么时候才需要弄懂一篇论文所有的恒等式推导过程，或者把整篇论文细细读完？NEVER！你只需要把确定会用到的部分给完全搞懂就好，不确定会不会用到的部分，只需要了解它主要的点子就够了。 硕士生和大学生最主要的差别：大学生读什么都必须要从头到尾都懂，硕士生只需要懂他用得着的部分就好了！大学生因为面对的知识是有固定的范围，所以他那样念。硕士生面对的知识是没有范围的，因此他只需要懂他所需要的细腻度就够了。硕士生必须学会选择性的阅读，而且必须锻炼出他选择时的准确度以及选择的速度，不要浪费时间在学用不着的细节知识！多吸收「点子」比较重要，而不是细部的知识。 五、方法与应用场合特性表（有迹可寻的创意程序） 试着想象说你从上图中论文阅读步骤的第（4）与（5）步骤分别获得以下两张表：譬如，当你的题目是「如何标定fiducial mark 之中心位置」，你就必须要仔细搜寻出文献上所有可能可以用来做这一个工作的方法。或许你找到的方法一共有四种，依序如下。譬如（随便乱举例），「方法一」可能表示：「以面积形心标定 fiducial mark 之中心位置」，「方法二」可能表示「以 Hugh transform标定 fiducial mark 之中心位置」，「方法三」可能表示：「以局部弧形 matching 的方法标定fiducial mark 之中心位置」，「方法四」可能表示：「以 ring code标定fiducial mark 之中心位置」。 这些方法各有它的特色（优缺点），譬如（随便乱举例），特性1可能表示「计算速度」（因此，根据上表左边第一个 row，可以发现：方法一的计算速度很快，方法二与方法三的计算速度很慢，而方法四的计算速度普通。其次，特性2可能代表「光源亮度不稳定时计算位置的误差大小」，特性3可能代表「噪声对计算出的位置干扰多大」，特性4可能代表「图形边缘有破损时计算的可靠度」，特性5可能代表「对象有彼此的遮蔽时方法的适用性」等等。所以，以上左图中第五个row为例，可以发现：当对象有彼此的遮蔽时，除方法二之外其它三个方法的适用性都很好。 但是，同样一个方法可能有许多不同的应用场合，而不同应用场合可能会对适用（或最佳）的方法有不同要求。所以，让我们来看右边的「问题特性分析表」。譬如（随便乱举例），应用甲可能是「标定fiducial mark 之中心位置」的方法在「电路插件组装（SMT）」里的应用，应用乙可能是「标定fiducial mark 之中心位置」的方法在「生物检验自动化影像处理」里的应用，而应用丙则可能是「标定 fiducial mark 之中心位置」的方法在「巡乂飞弹目标搜寻」里的应用。这三种应用场合更有其关注的特性。譬如，根据上面右表第二个 row 的资料，三种应用场合对特性2（光源亮度不稳定时计算位置的误差大小）都很在意。再譬如，根据上面右表第四个 row 的资料，三种应用场合中除了应用甲（电路插件组装（SMT））之外，其它两种应用场合对特性4（图形边缘有破损时计算的可靠度）都很在意。 那么，四个方法中哪个方法最好？你可能会回答说：「方法二！因为它的优点最多，缺点最少。」但是，这样的回答是错的！一个方法只有优缺点，而没有好坏。当它被用在一个适合表现其优点而不在乎其缺点的场合里，它就显得很好；但是，当它被用在一个不适合表现其优点而很在乎其缺点的场合里，它就显得很糟。譬如，方法二在应用场合乙，它的表现会非常出色（因为所有的优点刚好那个应用场合都在意，而所有的缺点刚好那个应用场合都不在意）；但是，方法二在应用场合甲里它的表现却会非常糟糕（它所有的缺点刚好那个应用场合都很在意，而它大部分的优点刚好那个应用场合却都不在意）。所以，必须要学会的第一件是就是：方法没有好坏，只有相对优缺点点；只有当方法的特性与应用场合的特性不合时，才能下结论说这方法「不适用」；二当当方法的特性与应用场合的特性吻合时，则下结论说这方法「很适用」。因此，一定要同时有方法特性表与应用场合特性分析表放在一起后，才能判断一个方法的适用性。 更重要的是：上面的方法与问题分析对照表还可以用来把「突破瓶颈所需的创意」简化成一种「有迹可寻」的工作。譬如，假定我们要针对应用甲发展一套适用的方法，首先我们要先从上右表中标定这个应用场合关心哪些问题特性。根据上右表第一个 column，甲应用场合只关心四个特性：特性1、2、3、5（即「计算速度」、「光源亮度不稳定时计算位置的误差大小」、「噪声对计算出的位置的干扰」、「对象有彼此的遮蔽时方法的适用性」）。那么，哪个方法最适用呢？看起来是方法 一，它除了特性2表现普通之外，其它三个特性的表现都很出色。但是，假如我们对方法一的表现仍不够满意，怎么去改善它？最简单的办法就是从上左表找现成的方法和方法一结合，产生出一个更适用的方法。因为方法一只有在特性2上面表现不够令人满意，所以我们就优先针对在特性2上面表现出色的其它方法加以研究。根据上左表，在特性2上面表现出色的方法有方法二和方法四，所以我们就去研究这两个方法和方法一结合的可能性。或许（随便举例）方法四的创意刚好可以被结合进方法一而改善方法一在特性2上面的表现，那么，我们就可以因此轻易地获得一个方法一的改良，从而突破甲应用场合没有适用方法的瓶颈。 有没有可能说单纯常识结合既有方法优点仍无法突破技术瓶颈的状况？可能有。这时候真的需要完全新颖的创意了。但是，这种时候很罕见。多半时候只要应用上一段的分析技巧就可以产生足以解决实用问题的创意了。至少，要产生出一篇学术期刊论文并非那么困难。 六、论文阅读的补充说明 硕士生开始学读期刊论文时，就容易犯的毛病就是戒除不掉大学部的习惯：（1）老是想逐行读懂，有一行读不懂就受不了。（2）不敢发挥自己的想象，读论文像在读教科书，论文没写的就不会，瘫痪在那里；被我逼着去自己猜测或想象时，老怕弄错作者的意思，神经绷紧，脑筋根本动不了。 大学毕业后（不管是念硕、博士或工作），可以参考的资料都没有秩序地交错成一团，而且永远都读不完。用大学生的心态读书，结果一定时间永远不够用。因此，每次读论文都一定要带着问题去读，每次读的时候都只是图回答你要回答的问题。因此，一定是选择性地阅读，一定要逐渐由粗而细地一层一层去了解。上面所规划的读论文的次序，就是由粗而细，每读完一轮，你对这问题的知识就增加一层。根据这一层知识就可以问出下一层更细致的问题，再根据这些更细致的问题去重读，就可以理解到更多的内容。因此，一定是一整批一起读懂到某个层次，而不是逐篇逐篇地整篇一次读懂。 这样读还有一个好处：第一轮读完后，可以根据第一轮所获得的知识判断出哪些论文与你的议题不相关，不相关的就不需要再读下去了。这样才可以从广泛的论文里逐层准确地筛选出你真正非懂不可的部分。不要读不会用到的东西，白费的力气必须被极小化！其实，绝大部分论文都只需要了解它的主要观念（这往往比较容易），而不需要了解它的详细推导过程（这反而比较费时）。 其次，一整批一起读还有一个好处：同一派的观念，有的作者说得较易懂，有的说得不清楚。整批读略过一次之后，就可以规划出一个你以为比较容易懂的阅读次序，而不要硬碰硬地在那里撞墙壁。你可以从甲论文帮你弄懂以论文的一个段落，没人说读懂甲论文只能靠甲论文的信息。所以，整批阅读很像在玩跳棋，你要去规划出你自己阅读时的「最省力路径」。 大学部学生读东西一定要循规蹈矩，你还没修过机械视觉相关课程之前可能也只好循规蹈矩地逐行去念。但是一旦修过机械视觉相关课程，许多论文中没被交代的段落你也已经可以有一些属于你的想象（虽然有可能猜错，尤其刚开始时经常猜错，但没关系，下面详述）。这些想象往往补足论文跳跃处最快速的解决方案。其实，一个大学毕业生所学已经很多了，对许多是都可以有一个不太离谱的想象能力。但是大部分学生却根本不敢去想象。我读论文远比学生快，分析远比学生深入，主要的是我敢想象与猜测，而且多年训练下来想象与猜测的准确度很高。所以，许多论文我根本不是「读懂」的，而是「猜对」了！ 假如猜错了怎么办？不用怕！猜完一后要根据你的猜测在论文里找证据，用以判断你的猜测对不对。猜对了，就用你的猜测（其实是你的推理架构）去吸收作者的资讯与创意（这会比从头硬生生地去迁就作者的思路轻松而容易）；猜错了，论文理会有一些信息告诉你说你错了，而且因为猜错所以你读到对的答案时反而印象更深刻。 七、论文报告的要求与技巧 报告一篇论文，我要求做到以下部分（依报告次序排列）： （1） 投影片第一页必须列出论文的题目、作者、论文出处与年份。 （2） 以下每一页投影片只能讲一个观念，不可以在一张投影片里讲两个观念。 （3） 说明这篇论文所研究的问题的重点，以及这个问题可能和工业界的哪些应用相关。 （4） 清楚交代这篇论文的主要假设，主要公式，与主要应用方式（以及应用上可能的解题流程）。 （5） 说明这篇论文的范例（simulation examples and/or experiments），预测这个方法在不同场合时可能会有的准确度或好用的程度 （6） 你个人的分析、评价与批评，包括：（6A）这篇论文最主要的创意是什么？（6B）这些创意在应用上有什么好处？（6C）这些创意和应用上的好处是在哪些条件下才能成立？（6D）这篇论文最主要的缺点或局限是什么？（6E）这些缺点或局限在应用上有什么坏处？（6F）这些缺点和应用上的坏处是因为哪些因素而引入的？（6G）你建议学长学弟什么时候参考这篇论文的哪些部分（点子）？ 一般来讲，刚开始报告论文（硕一上学期）时只要做到能把前四项要素说清楚就好了，但是硕一结束后（暑假开始）必须要设法做到六项要素都能触及。硕二下学期开始的时候，必须要做到六项都能说清楚。 注意：读论文和报告论文时，最重要的是它的创意和观念架构，而不是数学上恒等式推导过程的细节（顶多只要抓出关键的 equation 去弩懂以及说明清楚即可）。你报告观念与分析创意，别人容易听懂又觉得有趣；你讲恒等式，大家不耐烦又浪费时间。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c461fb9b9f929138fa0ac4e83d472c3/" rel="bookmark">
			移动设备网络代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动设备网络代码（英语：Mobile Network Code，MNC）是与移动设备国家代码（Mobile Country Code，MCC）（也称为“MCC / MNC”）相结合，以用来表示唯一一个的移动设备的网络运营商。这些运营商可以是使用的GSM/LTE、CDMA、iDEN、TETRA和通用移动通讯系统的公共陆基移动网亦或是卫星网络。ITU-T协议E.212中定义移动设备国家代码。
下表列出了完整的移动电话运营商列表。基于完整性，在这里一并提供其国家代码。其信息引用自移动设备国家代码的列表，是引用ISO3166-1的国家代码而来的。
下列表格中的国家代码及网络代码是以十进位方式来表示，然而，当在使用一些移动设备的软件开发工具包时，如黑莓系统软件开发工具包，其应用程序接口则以二进码十进数的方式传回。
目录 [隐藏] 1 国家运营商 2 另见3 外部链接4 参考 国家运营商[编辑] 国家及领土A B C D E F G H I J K L M N O P Q R S T U V W X Y Z MCC MNC 品牌 运营商 使用状态 频段（MHz） 参考和注释00101测试测试网络营运中GSM 900 / GSM 1800用于GSM测试环境 A[编辑] 阿布哈兹 - GE[编辑] MCC MNC 品牌 运营商 使用状态 频段（MHz） 参考和注释28967AquafonAquafon营运中GSM 900 / GSM 1800 / UMTS 2100 28988A-MobileA-Mobile营运中GSM 900 / UMTS 2100 阿富汗 - AF[编辑] MCC MNC 品牌 运营商 使用状态 频段（MHz） 参考和注释41201AWCCAfghan Wireless Communication Company营运中GSM 900 / GSM 1800[1] TSI41220RoshanTelecom Development Company Afghanistan Ltd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c461fb9b9f929138fa0ac4e83d472c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f89ce43d3d018eac8bb09a1f202bfcb/" rel="bookmark">
			C&#43;&#43; STL基本容器的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中有两种类型的容器：顺序容器和关联容器。顺序容器主要有vector、list、deque等。其中vector表示一段连续的内存，基于数组实现，list表示非连续的内存，基于链表实现，deque与vector类似，但是对首元素提供插入和删除的双向支持。关联容器主要有map和set。map是key-value形式，set是单值。map和set只能存放唯一的key，multimap和multiset可以存放多个相同的key。
容器类自动申请和释放内存，因此无需new和delete操作。
一、vector
vector基于模板实现，需包含头文件vector。
1.定义和初始化
//1.定义和初始化
vector&lt;int&gt; vec1; //默认初始化，vec1为空
vector&lt;int&gt; vec2(vec1); //使用vec1初始化vec2
vector&lt;int&gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2
vector&lt;int&gt; vec4(10); //10个值为的元素
vector&lt;int&gt; vec5(10,4); //10个值为的元素
//2.常用操作方法
vec1.push_back(100); //添加元素
int size = vec1.size(); //元素个数
bool isEmpty = vec1.empty(); //判断是否为空
cout&lt;&lt;vec1[0]&lt;&lt;endl; //取得第一个元素
vec1.insert(vec1.end(),5,3); //从vec1.back位置插入个值为的元素
//vec1.pop_back(); //删除末尾元素
//vec1.erase(vec1.begin(),vec1.end());//删除之间的元素，其他元素前移
cout&lt;&lt;(vec1==vec2)?true:false; //判断是否相等==、！=、&gt;=、&lt;=...
vector&lt;int&gt;::iterator iter = vec1.begin(); //获取迭代器首地址
vector&lt;int&gt;::const_iterator c_iter = vec1.begin(); //获取const类型迭代器
//vec1.clear(); //清空元素
//3.遍历
//下标法
int length = vec1.size();
for(int i=0;i&lt;length;i++)
{
cout&lt;&lt;vec1[i];
}
cout&lt;&lt;endl&lt;&lt;endl;
//迭代器法
vector&lt;int&gt;::const_iterator iterator = vec1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f89ce43d3d018eac8bb09a1f202bfcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29350159581179ee2e4efae81fcc4bb8/" rel="bookmark">
			关于android交互设计的那点事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是交互设计？ 从用户角度来说，交互设计是一种如何让产品易用，有效而让人愉悦的技术，它致力于了解目标用户和他们的期望，了解用户在同产品交互时彼此的行为，了解“人”本身的心理和行为特点，同时，还包括了解各种有效的交互方式，并对它们进行增强和扩充。交互设计还涉及到多个学科，以及和多领域多背景人员的沟通。 交互设计的目标： 易学习 容易使用 容错性 有效性 用户满意度 安全性 交互设计的任务 可识别的： 形状 布局 尺寸 色彩 可感知的： 语言含义 色彩的隐喻 相对位置 层级，关系 可物理衡量的： 流程 点击次数 移动距离 此时 转换方式 什么是交互设计？---交互设计与界面设计 有很多人会问，交互设计，不就是界面设计吗？尤其是在理解同软件产品的交互时。人们在界面设计方面已经有了一定的关注，然而，交互设计更加注重产品和使用者行为上的交互以及交互的过程。 界面是一个静态的词，当进行界面设计的时候，我们关心的是界面本身，界面的组件，布局，风格，看它们是否能支撑有效的交互。但是，交互行为是界面约束的源头，当产品的交互行为清清楚楚地定义出来时，对界面的要求也就更加清楚了，界面上（如果存在可视界面的话）的组件是为交互行为服务的，它可以更美，更抽象，更艺术化，但不可以为了任何理由破坏产品的交互行为。 交互设计的原则 1-就近原则 把同一类的功能都组织放在页面相同的模块中 2-容错原则 必须允许用户犯错，给于用户后悔的机会 3-帮助原则 为用户提供适量的帮助 必须使用用户语言，不迷惑用户 4-习惯原则 设计及功能尽量贴近用户的操作习惯，避免用户的思考 5-响应原则 每次用户进行操作后，都需要给用户一个响应反馈，否则用户将不清楚自己的操作是否有效，从而进行重复操作，对产品甚至用户带来伤害 6-精简原则 设计者需要常常向自己提问：是否做出了很多用户不需要的东西？有时候，决定不要什么，比决定要做什么更重要 交互设计的原则 – 其他 可用性第一定律：别让我思考 Don't make me think 符合用户习惯与预期 把自己想象成一个迟钝、挑剔、易怒的傻瓜来使用产品 抓主要矛盾，重点关注最常使用的交互点，投入80%的时间到用户常用的20%功能的设计上 用户界面应该基于用户的心里模型，而不是基于实现模型。 软件应该像人一样体贴 界面的一致性，相似界面的字体、颜色、布局、导航应该保持一致性 所有的设置都应该有智能和符合用户需求的默认状态 使界面更容易浏览和导航 减少不必要的潜在等待时间 可读性，字体大小、颜色、字体排列等，都决定可读性的好与坏 Android 4.0 交互设计风格 1.多平台支持（android 4.0将只提供一个版本，同时支持智能手机，平板电脑，电视等设备） 2取消实体按键（Galaxy Nexus）(Galaxy Nexus没有按钮，虚拟按钮集成到界面中，当旋转或不需要的时候，就会隐藏) 3改进文件夹功能（将一个图标拖到另一个图标上，即可立即建立文件夹） 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29350159581179ee2e4efae81fcc4bb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8690e5d62bb76d71a0d076cb30c9414a/" rel="bookmark">
			《统计学》读书笔记第8-10章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第8章 方差分析与实验设计 8.1 方差分析的基本原理 方差分析（ANOVA）：通过对数据误差的分析来判断各分类自变量对数值因变量影响的一种统计方法。自变量对因变量的影响也称为自变量效应，而影响效应的大小则体现为因变量的误差里有多少是由于自变量造成的。因此，方差分析就是来检验这种效应是否显著。
各自变量也称为因素或因子，分析单个因素对因变量的影响称为单因素方差分析。如果考虑两个因素，但不考虑两者的交互效应，则为只考虑主效应的双因素方差分析或无重复双因素分析。如果交互性也考虑的话，称为可重复双因素分析。
总误差=处理误差+随机误差；
总平方和（SST）=处理平方和（SSA）+误差平方和（SSE）。
方差分析就是要分析数据的总误差中有没有处理误差。
方差分析的3个基本假定：1）正态性：每种处理对应的总体都应该是正态分布；2）方差齐性：每个处理对应的总体的方差相等；3）独立性：每个样本数据都来自不同处理的独立样本。
8.2 单因素方差分析 8.3 双因素方差分析 第9章 一元线性回归 9.1 变量间关系 变量之间的关系可以分为：函数关系（确定关系）、相关关系（不确定关系）。
由散点图看出：正相关、负相关、完全正相关、完全负相关、非线性相关、不相关。
相关系数度量两个变量之间线性关系强弱（Pearson相关系数）：
r = Σ(x-μx)(y-μy)/ sqrt( Σ(x-μx)2×Σ(y-μy)2 )
计算该相关系数时，假定：两个变量之间是线性关系，而且都是随机变量，且服从一个联合双变量正态分布，且不应有极端值。
总体相关系数是未知的，那么所求的相关系数其实是由样本数据计算而来，是样本统计量，所以要对其可靠性进行显著性检验，使用t分布检验：
提出假设：H0：总体相关系数=0，H1：不等于0
计算统计量：t= r × sqrt(n - 2) / sqrt(1 –r2) ~ t(n - 2)。
求出统计量的P值，做出决策。
9.2 一元线性回归的估计和检验 9.2.1 一元线性回归的估计 总体的回归方程为：y= β0 +β1x + ε
样本（估计）的回归方程：y’ =β0’ +β1’x
运用最小二乘法估计参数β0’和β1’。
运用判定系数来衡量回归直线对数据的拟合优度。
总平方和（SST）= Σ(yi – μy)2
回归平方和（SSR）= Σ(yi’ – μy)2
残差平方和（SSE）=Σ(yi –yi’)2
判定系数R2=SSR/SST，R2=1，拟合是完全的。若y与x无关，那么R2=0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8690e5d62bb76d71a0d076cb30c9414a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e497fdc84a4ffadf6f1fd64c1dd4a17/" rel="bookmark">
			js将滚动条scrollbar保持在最底部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js实现将div等滚动条(scrollbar)保持在最底部的方法，很多时候我们要让程序的滚动条保持在底部,如聊天室，下面将利用div+css+javascript实现保持滚动条在最底部。
代码如下,
&lt;style type="text/css"&gt; .cdiv{ background-color: white; height: 100px; width: 380px; padding-left: 0; overflow-y: scroll; position: relative; word-wrap: break-word; overflow-x: auto; text-align:left; } &lt;/style&gt; &lt;div id="divmsg" class="cdiv"&gt;&lt;/div&gt; &lt;input id="test" type="button" value="测试" /&gt; &lt;script type="text/javascript"&gt; var test = document.getElementById("test"); var div = document.getElementById("divmsg"); test.onclick = function () { div.innerHTML = div.innerHTML+"js实现将div等滚动条(scrollbar)保持在最底部&lt;br/&gt;&lt;br/&gt;"; boxScroll(div); } function boxScroll(o){ o.scrollTop = o.scrollHeight; } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/003186aa5d6f9e688b1a2a53d2dd1099/" rel="bookmark">
			配置dns出现connection timed out; no servers could be reached的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		etc目录修改named.conf这个配置文件的，
修改下面两个句子
options {
listen-on port 53 { 192.168.1.11; }; （我就是在这里出问题的默认此处是127.0.0.1，就是因为没把此次IP改为本机IP所以一直解析不到）
allow-query { any; }; （这里可能也要改默认是localhost)
转载于:https://blog.51cto.com/5915349/1386759
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8171e5f748fc17c7d013eb642c9a7e1f/" rel="bookmark">
			【Hadoop基础】hadoop fs 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，hadoop fs –fs [local | &lt;file system URI&gt;]：声明hadoop使用的文件系统，如果不声明的话，使用当前配置文件配置的，按如下顺序查找：hadoop jar里的hadoop-default.xml-&gt;$HADOOP_CONF_DIR下的hadoop-default.xml-&gt;$HADOOP_CONF_DIR下的hadoop-site.xml。使用local代表将本地文件系统作为hadoop的DFS。如果传递uri做参数，那么就是特定的文件系统作为DFS。
2，hadoop fs –ls &lt;path&gt;：等同于本地系统的ls，列出在指定目录下的文件内容，支持pattern匹配。输出格式如filename(full path) &lt;r n&gt; size.其中n代表replica的个数，size代表大小（单位bytes）。
3，hadoop fs –lsr &lt;path&gt;：递归列出匹配pattern的文件信息，类似ls，只不过递归列出所有子目录信息。
4，hadoop fs –du &lt;path&gt;：列出匹配pattern的指定的文件系统空间总量（单位bytes），等价于unix下的针对目录的du –sb &lt;path&gt;/*和针对文件的du –b &lt;path&gt; ，输出格式如name(full path) size(in bytes)。
5，hadoop fs –dus &lt;path&gt;：等价于-du，输出格式也相同，只不过等价于unix的du -sb。
6，hadoop fs –mv &lt;src&gt; &lt;dst&gt;：将制定格式的文件 move到指定的目标位置。当src为多个文件时，dst必须是个目录。
7，hadoop fs –cp &lt;src&gt; &lt;dst&gt;：拷贝文件到目标位置，当src为多个文件时，dst必须是个目录。
8，hadoop fs –rm [-skipTrash] &lt;src&gt;：删除匹配pattern的指定文件，等价于unix下的rm &lt;src&gt;。
9，hadoop fs –rmr [skipTrash] &lt;src&gt;：递归删掉所有的文件和目录，等价于unix下的rm –rf &lt;src&gt;。
10，hadoop fs –rmi [skipTrash] &lt;src&gt;：等价于unix的rm –rfi &lt;src&gt;。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8171e5f748fc17c7d013eb642c9a7e1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9fd8bb859b91563e1c6b8161444d97d/" rel="bookmark">
			堆排序算法及其c语言泛型编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一:什么是堆? 1.堆: n个元素的序列{k 1,k 2,k 3,.....k n}当且仅当满足以下关系是,称为堆. {k i &lt;= k 2i 且 k i &lt;= k 2i+1} 或 {k 2i &lt;= k i 且 k 2i+1 &lt;= k i} (i = 1,2,...[n/2] ).这也是堆的一个性质. 2.堆结构是一种数组对象堆,它可以被视为一棵完全二叉树如下图, 书中每个节点与数组中存放该节点中值的那个元素 对应,除了最后一层,其余的每个节点都是满的.因为堆可看成是一棵完全二叉树,那它就满足一些树的性质, 对于有n个结点的完全二叉树,对任一结点i 有: 1) 如果 i = 1, 则结点i是二叉树的根,无双亲; 2)如果i &gt; 1,则其双亲Parent(i)是[ i / 2 ]; 3)如果2i &gt; n ,则结点i 无左孩子(结点i为 叶子结点);否 则,其 左孩子Lift_child(i) 是结点2i. 4)如果2i + 1 &gt; n,则结点i无 右孩子;否则, 其右孩子right_child(i)是结点2i + 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9fd8bb859b91563e1c6b8161444d97d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf2257b0dbda6ee322d0836f4a180edf/" rel="bookmark">
			Android -- 读写文件到内部ROM，SD卡，SharedPreferences，文件读写权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（内容整理自张泽华教程）
1. 概述
使用文件进行数据存储
首先给大家介绍使用文件如何对数据进行存储，Activity提供了openFileOutput()方法可以用于把数据输出到文件中，具体的实现过程与在J2SE环境中保存数据到文件中是一样的。
public class FileActivity extends Activity {
@Override public void onCreate(Bundle savedInstanceState) {
... FileOutputStream outStream = this.openFileOutput("itcast.txt", Context.MODE_PRIVATE);
outStream.write("传智播客".getBytes());
outStream.close(); }
}
openFileOutput()方法的第一参数用于指定文件名称，不能包含路径分隔符“/” ，如果文件不存在，Android 会自动创建它。创建的文件保存在/data/data/&lt;package name&gt;/files目录，如： /data/data/cn.itcast.action/files/itcast.txt，通过点击Eclipse菜单“Window”-“Show View”-“Other”，在对话窗口中展开android文件夹，选择下面的File Explorer视图，然后在File Explorer视图中展开/data/data/&lt;package name&gt;/files目录就可以看到该文件。
openFileOutput()方法的第二参数用于指定操作模式，有四种模式，分别为： Context.MODE_PRIVATE = 0
Context.MODE_APPEND = 32768
Context.MODE_WORLD_READABLE = 1
Context.MODE_WORLD_WRITEABLE = 2
Context.MODE_PRIVATE：为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容，如果想把新写入的内容追加到原文件中。可以使用Context.MODE_APPEND
Context.MODE_APPEND：模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。
Context.MODE_WORLD_READABLE和Context.MODE_WORLD_WRITEABLE用来控制其他应用是否有权限读写该文件。
MODE_WORLD_READABLE：表示当前文件可以被其他应用读取；MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入。
如果希望文件被其他应用读和写，可以传入： openFileOutput("itcast.txt", Context.MODE_WORLD_READABLE + Context.MODE_WORLD_WRITEABLE);
读取文件内容
如果要打开存放在/data/data/&lt;package name&gt;/files目录应用私有的文件，可以使用Activity提供openFileInput()方法。
FileInputStream inStream = this.getContext().openFileInput("itcast.txt");
Log.i("FileTest", readInStream(inStream));
readInStream()的方法请看本页下面备注。
或者直接使用文件的绝对路径：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf2257b0dbda6ee322d0836f4a180edf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e30dec57b04db9114c0eddca81a4714/" rel="bookmark">
			nodejs  daemon
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正常情况下 node server.js 启动后，如果关闭cmd或者是session 会话，同时也会关闭 nodejs， 如果我们想保持nodejs
继续执行， 就必须要 以守护进程方式启动， 可以使用nohup ，但是 个人觉得forever会更好用一点
1. 安装forever
npm install forever 2. 启动
usage: forever [start | stop | stopall | list] [options] SCRIPT [script options] options: start start SCRIPT as a daemon stop stop the daemon SCRIPT stopall stop all running forever scripts list list all running forever scripts 3. 要关闭进程的话
$ forever list
会列出来 正在运行的 procee 的 pid
不要使用 kill pid 关闭，关闭后会自动重新启动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e30dec57b04db9114c0eddca81a4714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbacdcf401a9479d09a958f27c446a1e/" rel="bookmark">
			VS2010/MFC编程入门之二十四（常用控件：组合框控件Combo Box）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节鸡啄米讲了列表框控件ListBox的使用，本节主要讲解组合框控件Combo Box。组合框同样相当常见，例如，在Windows系统的控制面板上设置语言或位置时，有很多选项，用来进行选择的控件就是组合框控件。它为我们的日常操作提供了很多方便。
组合框控件简介
组合框其实就是把一个编辑框和一个列表框组合到了一起，分为三种：简易（Simple）组合框、下拉式（Dropdown）组合框和下拉列表式（Drop List）组合框。下面讲讲它们的区别。
简易组合框中的列表框是一直显示的，效果如下图：
下拉式组合框默认不显示列表框，只有在点击了编辑框右侧的下拉箭头才会弹出列表框，列表框弹出后如下图：
下拉列表式组合框的编辑框是不能编辑的，只能由用户在下拉列表框中选择了某项后，在编辑框中显示其文本。下拉列表式组合框如下图：
经过上面的介绍，大家应该知道，最常用的当属下拉式组合框和下拉列表式组合框了，它们在很多时候能使程序看起来更专业，更简洁，让用户在进行选择操作时更方便。
组合框被操作时会向父窗口发送通知消息，这些通知消息及其含义如下：
CBN_CLOSEUP：组合框的列表框组件被关闭，简易组合框不会发送该通知消息 CBN_DBLCLK：用户在某列表项上双击鼠标，只有简易组合框才会发送该通知消息 CBN_DROPDOWN：组合框的列表框组件下拉，简易式组合框不会发送该通知消息 CBN_EDITUPDATE：在编辑框准备显示改变了的正文时发送该消息，下拉列表式组合框不会发送该消息 CBN_EDITCHANGE：编辑框的内容被用户改变了，与CBN_EDITUPDATE不同，该消息是在编辑框显示的正文被刷新后才发出的，下拉列表式组合框不会发送该消息 CBN_ERRSPACE：组合框无法申请足够的内存来容纳列表项 CBN_SELENDCANCEL：表明用户的选择应该取消，当用户在列表框中选择了一项，然后又在组合框控件外单击鼠标时就会导致该消息的发送 CBN_SELENDOK：用户选择了一项，然后按了回车键或单击了下滚箭头，该消息表明用户确认了自己所作的选择 CBN_KILLFOCUS：组合框失去了输入焦点 CBN_SELCHANGE：用户通过单击或移动箭头键改变了列表的选择 CBN_SETFOCUS：组合框获得了输入焦点
组合框控件的创建
MFC将组合框控件的所有操作都封装到了CComboBox类中。
我们在对话框中加入组合框时，可以往对话框模板中拖入Combo Box控件，而后添加CComboBox类型的控件变量使用，但如果我们想在程序中动态创建的话，就要使用CComboBox类的成员函数Create了。Create函数的原型如下：
virtual BOOL Create( DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID );
大家可以看出，CComboBox类的Create成员函数同前面几个控件类的Create成员函数非常类似，dwStyle指定组合框控件的风格，rect为列表框弹出后组合框的位置和尺寸，pParentWnd是指向父窗口的指针，不能为NULL，nID指定组合框控件的ID。最后还是重点讲讲dwStyle参数。组合框控件的风格包括以下几种，并给出了相应说明：
CBS_AUTOHSCROLL：使编辑框组件具有水平滚动的风格 CBS_DISABLENOSCROLL：使列表框在不需要滚动时显示一个禁止的垂直滚动条 CBS_DROPDOWN：指定一个下拉式组合框 CBS_DROPDOWNLIST：指定一个下拉列表式组合框 CBS_HASSTRINGS：指定一个含有字符串的自绘式组合框 CBS_LOWERCASE：将编辑框和列表框中的所有文本都自动转换为小写字符 CBS_NOINTEGRALHEIGHT：组合框的尺寸由应用程序而不是Windows 指定，通常，由Windows指定尺寸会使列表项的某些部分隐藏起来 CBS_OEMCONVERT：使编辑框组件中的正文可以在ANSI 字符集和OEM字符集之间相互转换。这在编辑框中包含文件名时是很有用的 CBS_OWNERDRAWFIXED：指定自绘式组合框，即由父窗口负责绘制列表框的内容，并且列表项有相同的高度 CBS_OWNERDRAWVARIABLE：指定自绘式组合框，并且列表项有不同的高度 CBS_SIIMPLE：指定一个简易组合框 CBS_SORT：自动对列表框组件中的项进行排序 CBS_UPPERCASE：将编辑框和列表框中的所有文本都自动转换为大写字符
dwStyle参数可以是以上风格的组合。跟其他控件一样，创建时一般也还要指定WS_CHILD、WS_VISIBLE、WS_TABSTOP和WS_VSCROLL等风格。
在对话框模板中直接添加组合框控件时，其属性页中的属性包含了以上风格，例如属性Uppercase设为True就相当于指定了CBS_UPPERCASE风格。
CComboBox类的主要成员函数
因为组合框是由编辑框和列表框组合而成的，所以组合框的操作和编辑框与列表框的操作有很多相似之处，同样的，CComboBox类的成员函数也和CEdit类与CListBox类的成员函数有很多相似之处，不但功能相似，甚至函数名和参数也很相似。鸡啄米下面大概讲解下CComboBox类的主要成员函数，更详细的内容可以参见MSDN。
int GetCount( ) const; 获取组合框控件的列表框中列表项的数量。
int GetCurSel( ) const; 获取组合框控件的列表框中选中项的索引，如果没有选中任何项，该函数返回CB_ERR。
int SetCurSel(int nSelect); 在组合框控件的列表框中选择某项。nSelect参数指定了要选择的列表项的索引，如果为-1则列表框中当前选择项被取消选中，编辑框也被清空。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbacdcf401a9479d09a958f27c446a1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2064885770e5c2412c72c92f72ab4fe/" rel="bookmark">
			java.lang.ClassCastException: android.app.Application cannot be cast to serialport_api.sample.App问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载： http://blog.csdn.net/imyang2007/article/details/7955610 出这个异常的原因是在项目中添加了新application类（public class Application extends android.app.Application）之后，没有在manifest.xml中添加类的声明，所以编译器抛出异常： java.lang.ClassCastException: android.app.Application cannot be cast to android_serialport_api.sample.Application 解决方法，在manifest.xml中添加：
[html] view plain copy &lt;application android:name="android_serialport_api.sample.Application"&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46bda26adbaecaae58ea9dbe89ff2a26/" rel="bookmark">
			JS快速获取图片宽高的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速获取图片的宽高其实是为了预先做好排版样式布局做准备，通过快速获取图片宽高的方法比onload方法要节省很多时间，甚至一分钟以上都有可能，并且这种方法适用主流浏览器包括IE低版本浏览器。
我们一步一步进入这个过程。
一、简陋的获取图片方式 // 图片地址 后面加时间戳是为了避免缓存var img_url = 'http://www.qttc.net/static/upload/2013/13643608813441.jpg?'+Date.parse(new Date());// 创建对象var img = new Image();// 改变图片的srcimg.src = img_url;// 打印alert('width:'+img.width+',height:'+img.height); 执行：
宽高都是0的这个结果很正常，因为图片的相关数据都没有被加载前它的宽高默认就是0
于是可以这么优化！
二、onload后在打印 // 图片地址 后面加时间戳是为了避免缓存 var img_url = 'http://www.qttc.net/static/upload/2013/13643608813441.jpg?'+Date.parse(new Date());
// 创建对象
var img = new Image();
// 改变图片的src
img.src = img_url;
// 加载完成执行
img.onload = function(){
// 打印
alert('width:'+img.width+',height:'+img.height);
}; 执行：
通过onload就能获取到图片的宽高了。但onload大一点的图通常都比较慢，不实用，但只要图片被浏览器缓存，那么图片加载几乎就不用等待即可触发onload，我们要的是占位符。所以有些人通过缓存获取也可以这么写。
三、通过complete与onload一起混合使用 为了测试缓存效果，注意以下测试图片的url都不加时间戳
// 图片地址
var img_url = 'http://www.qttc.net/static/upload/2013/13643608813441.jpg';
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46bda26adbaecaae58ea9dbe89ff2a26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6f38653d7e237ec9dc15b486c07e8ba/" rel="bookmark">
			c&#43;&#43;如何取出string中的第一个字符…
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 c++如何取出string中的第一个字符： #include #include using namespace std; int main() { string s; char c; cin &gt;&gt; s; c = s.at(0); cout &lt;&lt; c &lt;&lt; endl; return 0; } 如何求string的长度？ 举个例子说明吧： string str="welcome to chaina!"; int m;//m为长度 m=str.size()；//求字符串长度或者下面的 m=str.length(); //同上面size功能一样，都是求字符串长度的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/963e2d67e4c93bb852f8a20e29df3d88/" rel="bookmark">
			【git】fatal: This operation must be run in a work tree
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前是这么弄的 http://blog.csdn.net/commshare/article/details/20526369 ，感觉思路还是不太清晰。
今天新建立一个工程，需要一个仓库。
用git --bare init创建的empty的仓库，不能git add，
会会报错fatal: This operation must be run in a work tree 。
但是，据说用git init的可以。
解决办法有几个，
参考 http://blog.sina.com.cn/s/blog_630bf12f0100nl7i.html
参考 http://stackoverflow.com/questions/1456923/why-am-i-getting-the-message-fatal-this-operation-must-be-run-in-a-work-tree
===============
我选用的是：
仓库用git --bare init，
而我的实际的工程目录下用git init，git remote add origin ，git add 某个文件，git commit ，git push之后，
远程的仓库就ok了。
用gitweb也可以顺利的看到。
==================
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526b16fff5ab3a1a015d7fd14049edd0/" rel="bookmark">
			002_009 Python 从Zip中读取数据 直接检查一个zip格式的归档文件部分或所有文件而且不用解压
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下：
#encoding=utf-8 print '中国' #直接检查一个zip格式的归档文件部分或所有文件而且不用解压 import zipfile zp = zipfile.ZipFile(r'D:\program files\ROMasterLab\Driver.zip','r') for filename in zp.namelist(): print 'File:',filename bytes = zp.read(filename, None) print 'has',len(bytes),'bytes' #创建ZipFile import zipfile,tempfile,os,sys filename = r'd:\1237.zip' z = zipfile.ZipFile(filename,'w') z.writestr('hello.py', 'def f(): return "hello world from"+__file__\n') z.close() sys.path.insert(0, filename) import hello print hello.f() print sys.path os.unlink(filename) 打印结果如下： 中国
File: 2K_XP_COM/
has 0 bytes
File: 2K_XP_COM/usb2ser_2kxp.cat
has 10250 bytes
File: 2K_XP_COM/usb2ser_2kXP.inf
has 3276 bytes
File: 2K_XP_COM/usb2ser_XP64.inf
has 1040 bytes
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/526b16fff5ab3a1a015d7fd14049edd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/946e12f1262a8445b75a1e163c9c8d12/" rel="bookmark">
			编译mediastreamer2/ffmpeg/linphone(x86平台)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		--------------------------在x86环境下编译mediastreamer2的步骤-------------------------------------- 1）编译OGG库 音频编解码 http://www.xiph.org/downloads/ ./configure --prefix=/usr --disable-static 2）编译SPEEX 音频编解码 ./configure --prefix=/usr --disable-static --enable-fixed-point --disable-float-api --with-ogg=/usr 3）编译ORTP库 http://download.savannah.gnu.org/releases/linphone/ortp/sources/ ./configure --prefix=/usr --disable-static --------------------到此即可编译无视频支持mediastream------------------------- 编译mediastream： ./configure --prefix=/usr --disable-static --enable-macsnd=no --enable-video=no --enable-tests --disable-gsm PKG_CONFIG_PATH=/usr/lib/pkgconfig 4) 编译sdl Simple DirectMedia Layer多媒体开发包 ：http://www.libsdl.org/ ./configure --prefix=/usr --enable-shared 5) 编译lame MP3编码器 ：http://lame.sourceforge.net/download.php ./configure --prefix=/usr --enable-shared 6） 编译xvid MPEG-4视频编解码器：http://www.xvid.org/ cd xvidcore/build/generic ./configure --prefix=/usr --enable-shared make &amp; make install 7）编译yasm NASM assembler x264需要用到的汇编编译器：http://yasm.tortall.net/http://download.chinaunix.net/download/0013000/12166.shtml ./configure --prefix=/usr --enable-shared make &amp; make install 8）编译x264 http://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/946e12f1262a8445b75a1e163c9c8d12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/365154aed6e65ca265eeeaf969af3357/" rel="bookmark">
			几种常见的缺失数据插补方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文地址：几种常见的缺失数据插补方法 作者：spss15.0 （一）个案剔除法(Listwise Deletion) 最常见、最简单的处理缺失数据的方法是用个案剔除法(listwise deletion)，也是很多统计软件（如SPSS和SAS）默认的缺失值处理方法。在这种方法中如果任何一个变量含有缺失数据的话，就把相对应的个案从分析中剔除。如果缺失值所占比例比较小的话，这一方法十分有效。至于具体多大的缺失比例算是“小”比例，专家们意见也存在较大的差距。有学者认为应在5%以下，也有学者认为20%以下即可。然而，这种方法却有很大的局限性。它是以减少样本量来换取信息的完备，会造成资源的大量浪费，丢弃了大量隐藏在这些对象中的信息。在样本量较小的情况下，删除少量对象就足以严重影响到数据的客观性和结果的正确性。因此，当缺失数据所占比例较大，特别是当缺数据非随机分布时，这种方法可能导致数据发生偏离，从而得出错误的结论。 （二）均值替换法(Mean Imputation) 在变量十分重要而所缺失的数据量又较为庞大的时候，个案剔除法就遇到了困难，因为许多有用的数据也同时被剔除。围绕着这一问题，研究者尝试了各种各样的办法。其中的一个方法是均值替换法(mean imputation)。我们将变量的属性分为数值型和非数值型来分别进行处理。如果缺失值是数值型的，就根据该变量在其他所有对象的取值的平均值来填充该缺失的变量值；如果缺失值是非数值型的，就根据统计学中的众数原理，用该变量在其他所有对象的取值次数最多的值来补齐该缺失的变量值。但这种方法会产生有偏估计，所以并不被推崇。均值替换法也是一种简便、快速的缺失数据处理方法。使用均值替换法插补缺失数据，对该变量的均值估计不会产生影响。但这种方法是建立在完全随机缺失（MCAR）的假设之上的，而且会造成变量的方差和标准差变小。 （三）热卡填充法（Hotdecking） 对于一个包含缺失值的变量，热卡填充法在数据库中找到一个与它最相似的对象，然后用这个相似对象的值来进行填充。不同的问题可能会选用不同的标准来对相似进行判定。最常见的是使用相关系数矩阵来确定哪个变量（如变量Y）与缺失值所在变量（如变量X）最相关。然后把所有个案按Y的取值大小进行排序。那么变量X的缺失值就可以用排在缺失值前的那个个案的数据来代替了。与均值替换法相比，利用热卡填充法插补数据后，其变量的标准差与插补前比较接近。但在回归方程中，使用热卡填充法容易使得回归方程的误差增大，参数估计变得不稳定，而且这种方法使用不便，比较耗时。 （四）回归替换法(Regression Imputation) 回归替换法首先需要选择若干个预测缺失值的自变量，然后建立回归方程估计缺失值，即用缺失数据的条件期望值对缺失值进行替换。与前述几种插补方法比较，该方法利用了数据库中尽量多的信息，而且一些统计软件（如Stata）也已经能够直接执行该功能。但该方法也有诸多弊端，第一，这虽然是一个无偏估计，但是却容易忽视随机误差，低估标准差和其他未知性质的测量值，而且这一问题会随着缺失信息的增多而变得更加严重。第二，研究者必须假设存在缺失值所在的变量与其他变量存在线性关系，很多时候这种关系是不存在的。 （五）多重替代法(Multiple Imputation) 多重估算是由Rubin等人于1987年建立起来的一种数据扩充和统计分析方法，作为简单估算的改进产物。首先，多重估算技术用一系列可能的值来替换每一个缺失值，以反映被替换的缺失数据的不确定性。然后，用标准的统计分析过程对多次替换后产生的若干个数据集进行分析。最后，把来自于各个数据集的统计结果进行综合，得到总体参数的估计值。由于多重估算技术并不是用单一的值来替换缺失值，而是试图产生缺失值的一个随机样本，这种方法反映出了由于数据缺失而导致的不确定性，能够产生更加有效的统计推断。结合这种方法，研究者可以比较容易地，在不舍弃任何数据的情况下对缺失数据的未知性质进行推断。NORM统计软件可以较为简便地操作该方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e784d9b95cd86a870563d053fd1dd433/" rel="bookmark">
			【opencv】两条平行线之间的距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：一张输入图片，图片上有两条平行线，求出这两条平行线之间的距离
解决思路：
1. 对图像中的直线进行细化
2. 提取直线的轮廓坐标
3. 对轮廓上的坐标进行直线集合，从而得到直线方程
4. 计算两条直线之间的距离
参考：
问题来源 http://www.opencvchina.com/thread-854-1-1.html
图像细化 http://blog.csdn.net/qianchenglenger/article/details/19332011
图像轮廓提取 http://blog.csdn.net/augusdi/article/details/9000893
直线拟合 http://blog.csdn.net/zhuoyue08/article/details/6803040
两条直线之间的距离公式3：http://zhidao.baidu.com/link?url=ef_DHNkjyq1qq7VgubX3afL2KIUQIB4ukd3zHGp0zz8iPPKC046azyvG5ltHR-i0WaLI72eO7j0sOJI4wZSE4q
工具：
opencv 2.4.8 + VS2013
代码：
1.头文件 ProcessImage.h
//ProcessImage.h #pragma once #include &lt;opencv2/highgui/highgui.hpp&gt; /* 对输入图像进行细化 * src为输入图像,用cvThreshold函数处理过的8位灰度图像格式，元素中只有0与1,1代表有元素，0代表为空白 * dst为对src细化后的输出图像,格式与src格式相同，调用前需要分配空间，元素中只有0与1,1代表有元素，0代表为空白 * maxIterations限制迭代次数，如果不进行限制，默认为-1，代表不限制迭代次数，直到获得最终结果 */ void thinImage(IplImage* src, IplImage* dst, int maxIterations = -1); 2.代码实现 ProcessImage.cpp //ProcessImage.cpp #include "ProcessImage.h" #include &lt;utility&gt; #include &lt;vector&gt; void thinImage(IplImage* src, IplImage* dst, int maxIterations) { using namespace cv; CvSize size = cvGetSize(src); cvCopy(src, dst);//将src中的内容拷贝到dst中 int count = 0; //记录迭代次数 while (true) { count++; if (maxIterations !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e784d9b95cd86a870563d053fd1dd433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9462ddb2ad8cb2f82ac53adc6a16289b/" rel="bookmark">
			英特尔I217-V网卡驱动安装失败解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 估计有些人遇到了英特尔I217-V网卡驱动安装失败的问题。不知所措。
本人使用的windows Server 2012 DataCenter 系统.也是各种百度各种谷歌。
驱动精灵，驱动人生，鲁大师，360驱动各种软件都无法解决该问题、
很多问题，均未得到有效解决。最后在国外一论坛发现解决之法。
以此共享给大家。方便后来人。 具体步骤
1 以管理员权限运行CMD
输入
bcdedit -set loadoptions DISABLE_INTEGRITY_CHECKS bcdedit -set TESTSIGNING ON 2.download
下载地址
3
运行 APPS\SETUP\SETUPBD\Winx64\ SetupBD.exe安装完成后重启。
如果发现还为正常安装，此时设备管理器手动添加更新。
选择本地文件(PRO1000\Winx64) 进行手动安装。
选择下一步知直到此时安装成功。
4 bcdedit -set loadoptions ENABLE_INTEGRITY_CHECKS
bcdedit -set TESTSIGNING OFF 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73f1389e346d6b4cbeabb6c63b812de0/" rel="bookmark">
			Android apk安装过程及Java、JNI读取安装包内assets资源文件的两种方法(附源码实例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题背景：在PC上的程序可以轻松使用./或不用指明，默认读取的就是程序所在路径内的文件。但在Android上，应用程序被打包成apk，程序运行时无法直接获取apk(压缩包)内的文件。但在一些特殊场合，如加载图像处理训练好的分类器、模型等数据，要求每个apk到手机上都能运行，就必须解决这个问题。本文深入研究apk安装过程，给出三种方法解决这个问题。
一、android apk安装过程
Android apk文件是将AndroidManifinest.xml、应用程序代码(.dex)、资源文件和其他文件打包成的一个压缩包文件，其中的.dex文件即使android上的可执行文件，由Java代码编译后的class文件链接而成。因此可以用unzip直接将apk打开。如下图所示，将本文后面要附源码的一个apk解压后示意图下：
1、assets文件夹，这个本文后面的源码专门就讲它，暂略。
2、lib文件夹，这里放着我们jni编译后生成的so文件。
3、META-INF文件夹，这个要追溯到java的jar文件。jar文件和zip文件唯一的区别就是包含一个META-INF文件夹，详见：这里。
4、res文件夹，就是所谓的资源文件，里面放的有各种图片资源(drawable文件夹下的东西)和布局xml文件。示图如下：
因此如果想借用一个apk的图片资源的话，直接解压就ok了。
5、AndroidManifinest.xml文件，这个就不多说了，每个Android工程文件都有。
6、classes.dex文件，Dex是Dalvik VM executes的全称，即Android Dalvik执行程序，并非Java ME的字节码而是Dalvik字节码。
7、resources.arsc文件，是编译后的二进制资源文件。
apk具体的核心安装步骤及牵涉到文件夹路径如下(以安装ReadAssets.apk为例)：
第一步：复制apk文件到data/app/目录下，解压并扫描安装包，名字是以包名命名的，并不是apk的名字。如下：
第二步：将.dex文件保存到data/dalvik-cache目录，
第三步：在/data/data/目录下创建对应的应用数据目录，目录名字是apk的包名：
其中cache文件夹下的内容如下：
lib文件夹下是jni里生成的库，libReadAsset.so,如下:
参考链接1 参考链接2
二、Java和JNI读取assets文件夹内的文件
关于assets文件夹和res文件夹的区别见http://blog.sina.com.cn/s/blog_4b93170a0102dqxj.html ，即res文件夹内的东西会再R.java生成id,而assets文件夹不会生成标记，只能利用assetmanager进行访问。其中的raw文件夹也不会被编译跟assets一样。
下面的代码是我写的一个demo，从java和jni两种方式读取assets文件夹内的一个txt文件。
1、布局文件：
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context=".MainActivity" &gt; &lt;TextView android:id="@+id/textview_show" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentTop="true" android:text="@string/hello_world" /&gt; &lt;Button android:id="@+id/btn_javashow" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:text="Java读取" /&gt; &lt;Button android:id="@+id/btn_jnishow" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:layout_toRightOf="@id/btn_javashow" android:text="JNI读取" /&gt; &lt;/RelativeLayout&gt; 2、MainActivity.java文件 package org.yanzi.readassets; import java.io.BufferedReader; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73f1389e346d6b4cbeabb6c63b812de0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb51c004ecfa5cfe7b1381caba56e9c/" rel="bookmark">
			focus获取不到光标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		focus第一能获取，重新调用不能获取光标，解决方案：
if($("branchAreaId").value=='' || $("branchAreaId").value==null){
window.setTimeout (function(){ document.getElementById ('branchAreaId'). select();},0 ); }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afd2ec3f60ef00bcae58c4a7662cc5ee/" rel="bookmark">
			arm汇编指令-DCD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据定义（ Data Definition ）伪指令
数据定义伪指令一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化。
— DCD （ DCDU ） 用于分配一片连续的字存储单元并用指定的数据初始化。
DCD（或DCDU）
语法格式：
标号 DCD （或 DCDU ） 表达式
DCD （或 DCDU ）伪指令用于分配一片连续的字存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为程序标号或数字表达式。 DCD 也可用 “ &amp; ” 代替。
用 DCD 分配的字存储单元是字对齐的，而用 DCDU 分配的字存储单元并不严格字对齐。
举个例子：
flib_0 DCD |Image$$RO$$Limit|
flib_1 DCD |Image$$RW$$Base|
flib_2 DCD |Image$$ZI$$Base|
flib_3 DCD |Image$$ZI$$Limit|
首先说下|Image$$RO$$Limit|
这是是编译后链接设置中设置的read-only内存的地址，里面叫存放工程的不改变包括了常量。在编译器参数中也可以看到，编译结束会由linker链接到知道的地址内存，这个信息也童谣会保存于bin文件中，在这里面打上符号就可以寻找到具体的值。这里理解为地址就可以了
这句话的意义就是分配给这个起始地址一段内存，后面好用来存放程序，并且初始化这段内存
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/874686f8f9c48275ec2b90e0a7ef3bdd/" rel="bookmark">
			ARM汇编指令-STMFD和LDMFD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据ATPCS规则，我们一般使用FD（FullDescending）类型的数据栈！所以经常使用的指令就有STMFD和LDMFD。这两个指令一般用于进行程序搬移等大规模操作前的cpu现场保护和操作结束后的现场恢复，属于非单一连续的压栈和出栈。
STMFD SP! ,{R0-R7，LR}
意义是：
SP = SP-9x4
ADDRESS =SP
for i = 0 to 7
memory[address] = Ri
address =address+4
memory[address] = LR
LDMFD SP! ,{R0-R7，LR}
过程算是STMFD的逆过程
结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/027d01ffc53db42bac06fe5fd6d2f0bf/" rel="bookmark">
			Linux - socket编程处理EINTR错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux - socket编程处理EI 在linux的socket编程中，经常要处理EINTR错误，其值为4，用strerror(errno)调用返回的错误描述为：Interrupted system call. 这里给出一个connect连接中对EINTR处理的网址： http://www.madore.org/~david/computers/connect-intr.html 另外转载网络上其他兄弟对EINTR错误的处理： 1. accetp()是慢系统调用，在信号产生时会中断其调用并将errno变量设置为EINTR，此时应重新调用accept()。所以使用时应这样：(网址：http://bbs.loveunix.net/viewthread.php?tid=36154) while(1) { if ((connfd = accept(....)) == -1) { if (errno == EINTR) { continue; } perror("accept()"); exit(1); } //do something with the connfd ......; } 2. 引用网址 http://fanqiang.chinaunix.net/a4/b7/20010508/112052.html，其中摘引一段socket的读处理，我把排版做了相应改动： int my_read(int fd, void *buffer, int length) { int bytes_left; int bytes_read; char *ptr = NULL; bytes_left = length; while (bytes_left &gt; 0) { bytes_read = read(fd, ptr, bytes_read); if (bytes_read &lt; 0) { if (errno == EINTR) { bytes_read = 0; } else { return(-1); } } else if (0 == bytes_read) { break; } bytes_left -= bytes_read; ptr += bytes_read; } return(length-bytes_left); } 我觉得这个只能针对阻塞模式的socket，非阻塞模式的socket好要处理EAGAIN错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57072101d691f739d0ca18e661503507/" rel="bookmark">
			自己写的一个BMP转PNG工具BMP2PNGen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写这个工具是因为要使用传奇的部分素材在COCOS2DX使用，
但是COCOS2DX不支持BMP
如果直接将BMP转换到PNG的话，网上找到的工具都不支持透明色转换。难道要用PS一个一个抠图吗？要累死
所以写了这个工具。一些古老的游戏比如 千年 传奇 都是BMP图片 全黑色为透明色。功能简单。批量转换。支持BMP透明色转换到PNG。
取了个名称叫BMP2PNGen。感叹一下，RAD开发小程序在windows上
DELPHI开发速度真不是C++ 和c#能比的啊。
下载地址:pan.baidu.com/s/1qWm8Yfy
转载于:https://www.cnblogs.com/lyin/p/3622246.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/475/">«</a>
	<span class="pagination__item pagination__item--current">476/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/477/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>