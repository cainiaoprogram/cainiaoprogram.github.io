<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1114788f09b245e6d75577623a481027/" rel="bookmark">
			python合并多个word文档（带图片等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 安装python3.6和pywin32包运行代码 安装python3.6和pywin32包 python官网下载python3.6版本，exe文件直接安装。利用pip安装pywin32包 pip install pywin32 注意：如果安装完成之后执行“import win32com”时还有错误，请下载exe文件安装pywin32。（ 提取码：u3w6 ） 运行代码 #encoding=utf-8 #导入pywin32包 import win32com.client as win32 #打开word软件 word = win32.gencache.EnsureDispatch('Word.Application') #非可视化运行 word.Visible = False output = word.Documents.Add()#新建合并后空白文档 #需要合并的文档路径，这里有个文档1.docx，2.docx，3.docx. files = ['F://work//2.docx', 'F://work//1.docx', 'F://work//3.docx'] for file in files: output.Application.Selection.Range.InsertFile(file)#拼接文档 #获取合并后文档的内容 doc = output.Range(output.Content.Start, output.Content.End) doc.Font.Name = "黑体"	#设置字体 output.SaveAs('F://work//result.docx') #保存 output.Close() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0447cd405a855245a66585d100517f0/" rel="bookmark">
			关于nginx配置成功后，无法访问的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://blog.csdn.net/lulen0724155075/article/details/51789164 接着检查了服务器端的80端口是否可以访问的到 ，如果访问不到，那么就是防火墙的问题。
做如下处理：
[root@localhost ]# /sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT
[root@localhost ]# /etc/init.d/iptables save
[root@localhost ]# /etc/init.d/iptables restart
至此，OK了，主机已可访问虚拟机的nginx服务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4581a3bc6ef3d2c36aef1436710f2175/" rel="bookmark">
			React 封装的Form组件wrappedComponentRef引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;MForm {...gforms} {wrappedComponentRef={ref=&gt;{this.gf=ref}}} /&gt;
this.gf.props.form.方法（）引用方式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4aba21a39b507f7a8aafe2c5dc72211/" rel="bookmark">
			从源码角度深入理解Retrofit2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Retrofit2作为目前最火的网络请求框架之一，它是一个由Square 组织开发的可以在Android和java中使用的安全型HTTP客户端（官方文档描述“Type-safe HTTP client for Android and Java by Square”）。本文将从Retrofit2简单使用入手，在对其源码进行分析来深入理解Retrofit2（基于2.5.0版本）。
1.Retrofit2简单使用 1.1 下面，根据官方例子，简单使用一个get请求来演示Retrofit2简单使用。首先gradle中添加retrofit依赖，创建一个描述每一个请求的接口
/** * gradle中添加依赖 */ implementation 'com.squareup.retrofit2:retrofit:2.5.0' public interface GitHub { public static final String API_URL = "https://api.github.com"; //使用Get 请求 @GET("/repos/{owner}/{repo}/contributors") Call&lt;List&lt;SimpleService.Contributor&gt;&gt; contributors( @Path("owner") String owner, @Path("repo") String repo); } 复制代码 1.2 创建网络请求数据bean对象
public class SimpleService { public static class Contributor { public final String login; public final int contributions; public Contributor(String login, int contributions) { this.login = login; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4aba21a39b507f7a8aafe2c5dc72211/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38eb1a16eef2c0d84102df44f4dfe136/" rel="bookmark">
			ubuntu下用apt-get时一直报[正在等待报头]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文： ubuntu下用apt-get是总是出现0% [正在等待报头] 链接：http://blog.csdn.net/nevasun/article/details/6268332
分类： Linux系统管理 2011-03-22 16:03 2954人阅读 评论(0)收藏举报
ubuntu百度
这个问题困扰我很久了，以前不能下载东西只好在网上找到先下载下来再安装，可是这次安装.deb的包出了问题，又不知道怎么解决。。。无奈，还是让系统apt-get给我安装吧。
百度发现，0% [正在等待报头]这个现象是由于在之前安装的时候Ctrl-C导致的。怎么解决呢？网上说把/var/cache/apt/archives下的文件删除就搞定了，于是乎
$ nautilus /var/cache/apt/
进入目录后全把文件夹下面的东西删了，退出后
$ sudo apt-get install libgtk2.0-dev
系统提示E: 无法打开锁文件 /var/cache/apt/archives/lock - open (2: 没有那个文件或目录)，这个文件确实没有，刚才都删了啊，那为什么不会新建呢？发现根本没有/var/cache/apt/archives/目录系统不能新建
$ sudo mkdir /var/cache/apt/archives/
重新下载，发现又提示E: 找不到“/var/cache/apt/archives/partial”目录。（这个目录在删除的时候明明没有啊），无奈
$ sudo mkdir /var/cache/apt/archives/partial
$ sudo apt-get install libgtk2.0-dev
问题解决，大功告成~~~
20131218读后感
我在安装ia32-libs时也遇到这个问题，一直报“0%正在等待报头”的错误。今天按照这篇文章的方法终于解决了。感谢这篇文章的博主分享呀。
我的具体解决方法是：
cd /var/cache/apt
sudo mv archives archives-backup
sudo apt-get install ia32-libs 20131218结束
原文二：
ubuntu 下载安装软件速度很慢 链接：http://www.oschina.net/question/1025978_119230
我在VM虚拟机上安装了 ubuntu 12.04
我尝试用apt-get install 安装软件，下载安装速度慢，而且容易安装出错，导致安装失败。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38eb1a16eef2c0d84102df44f4dfe136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a60d68d259d134b830e602f534d99c/" rel="bookmark">
			解决E:Could not get lock /var/lib/apt/lists/lock - open (11: Resource temporarily unavailable)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这个问题的原因可能是有另外一个程序正在运行，导致资源被锁不可用。而导致资源被锁的原因，可能是上次安装时没正常完成，而导致出现此状况。
解决方法：输入以下命令
sudo rm /var/cache/apt/archives/lock
sudo rm /var/lib/dpkg/lock
之后再安装想装的包，即可解决
今天玩ubuntu的时候，在弄更新源的时候，突然出现以下错误：
[1]+ Stopped sudo apt-get update
haiquan@haiquan-desktop:~$ sudo apt-get update
E: Could not get lock /var/lib/apt/lists/lock - open (11: Resource temporarily unavailable)
E: Unable to lock the list directory
开始以为是权限不够，就是用 sudo apt-get update,发现还是报错，问题没有解决。于是上网搜索了一下，答案如下：
问题应该是之前那个更新被强制取消的问题，进程仍然还在。用这个命令查看一下：
ps -e | grep apt
显示结果如下：
6362 ? 00:00:00 apt
6934 ? 00:00:00 apt-get
7368 ? 00:00:00 synaptic
然后就执行
sudo killall apt
sudo killall apt-get
sudo killall synaptic
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7a60d68d259d134b830e602f534d99c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b5d0ea28a94a28b3b2b7650586bfd2e/" rel="bookmark">
			视频标清、高清、全高清的分类分辨率码率帧率参考（附图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章简介：全面分析介绍视频分辨率、码率、帧率
1.视频标清、高清、全高清的分类 视频标清、高清、全高清的分类分辨率码率帧率参考（附图）
常见720P和1080P的分辨率倒底是多少？ 1.图表如下：
分辨率像素720P分辨率1280x720像素1080P分辨率1920*1080像素2k分辨率2560*1440像素4k分辨率3840*2160像素8K分辨率7680×4320像素 “P”全拼为Progressive译为逐行扫描，几P则表示纵向有多少行像素，比如：720P表示纵向有720行像素、1080P表示纵向有1080行像素。
2. 720P的分辨率为1280x720，1080P的分辨率为1920x1080。
“720”和“1080”这两个代号指的是分辨率，后面的“P”指的是逐行扫描的意思。通常来说，帧率为60Hz，一般可表示在p后面，如1080p30，意思是30Hz。
3. 扩展资料：
市场上的1080P高清投影机大致可以分为三档：高、中、低三档，低端产品主要针对入门级市场，从性能上来说，完全可以满足观看各种高清视频的需要，在投影机调节方面则更趋向于简单化。
1280*720有5种帧频，分别为60P、50P、30P、25P、24P，可简称为720P，又可分别表示为720/60P，720/50P，720/30P，720/24P，720/25P。
分辨率代表了图像所包含像素的多少，分辨率用 水平像素×垂直像素 表示，分辨率越大，说明图像包含的像素越多，图像视觉效果越细腻。
直播中最常用的分辨率是1280×720，其次是1920×1080，它们的宽高比都是16：9。
2.视频分辨率、码率、帧率 视频标清、高清、全高清的分类分辨率码率帧率参考（附图）
附图：
视频在我们生活中应用越来越广了，不可避免的，我们在使用视频时，会遇到一些最常见的专业术语：视频编码格式、视频码率、视频帧率、视频分辨率，这些专业术语在一个视频文件中，到底是指的什么呢？听阿酷来说说吧。
编码格式：一个视频文件本身，通常由音频和视频两部分组成。例如上图的视频文件，就是由avc视频编码+AAC音频编码组成的，常见的视频编码格式有Xvid，AVC/H.264，MPEG1，MPEG2 等，常见的音频编码有MP3、AAC等。
视频码率：是指视频文件在单位时间内使用的数据流量，也叫码流率。码率越大，说明单位时间内取样率越大，数据流精度就越高，这样表现出来的的效果就是：视频画面更清晰画质更高。
视频帧率：通常说一个视频的25帧，指的就是这个视频帧率，即1秒中会显示25帧；视频帧率影响的是画面流畅感，也就是说视频帧率超高，表现出来的效果就是：画面越显得流畅。你也可以这样理解，假设1秒只显1帧，那么一段视频看起来，就是有很明显的卡顿感，不流畅不连惯。当然视频帧率越高，意味着画面越多，也就相应的，这个视频文件的大小也会随之增加，占用存储空间也就增大了。
视频分辨率：分辨率就是我们常说的600x400分辨率、1920x1080分辨率，分辨率影响视频图像的大小，与视频图像大小成正比：视频分辨率越高，图像越大，对应的视频文件本身大小也会越大。
这样一说，是不是就容易理解多了？
3.优酷视频码率、爱奇艺视频码率与YouTube视频码率 YouTube视频码率 144p，288p，360p，480p，720p(HD)，1080p(HD)，1440p(HD)，2160p(4K)，4320p(8K)
优酷视频码率 标清=448x336，高清=576x432，超清=1104x622 ，1080p=1920x1080 爱奇艺视频码率 规格 文件码率 分辨率 视频编码格式 视频编码码率 视频帧率 音频编码格式 音频编码码率 音频编码通道
4K 5966kbps 3840x2160 h264 5862kbps 25fps aac 185kbps 2ch
1080P 2327kbps 1920x1080 h264 2569kbps 25fps aac 62kbps 2ch
720P 1247kbps 1280x720 h264 983kbps 25fps aac 125kbps 2ch
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b5d0ea28a94a28b3b2b7650586bfd2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/698062aa12c1d767e31058c6935a5feb/" rel="bookmark">
			联想电脑出现boot menu怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一个原因：就是开机的时候无意中按到了快捷键，进入了快速启动模式，所以出现进入BOOT MENU的现象。
处理方法：只要按下ESC键，退出，重启电脑就可以了。
第二个原因：就是硬盘的数据线或者电源线接触不良，导致主板无法识别硬盘，不能加载硬盘，所以弹出这个提示框。
处理方法：关闭电源，打开主机，将硬盘数据线或者电源线重新拨插一下，然后重新装机，开机，问题就解决了。
第三个原因：就是主板BIOS的第一启动，不是硬盘或者光盘，而是主板启动信息或者其它占为第一启动项，而导致无法引导硬盘直接进快捷启动项BOOT MENU的现象，所以只要将第一启动项改为硬盘即可。
处理方法：开机以后按下DEL，进入BIOS SETUP中，然后在BIOS中用方向键移到BOOT 中，依次找到：BOOT----boot device priority--enter(确定)--1ST BOOT DEVICE--SATA:SM-WDC WD5000）－－enter(确定))然后按下F10，.选择好启动方式后，按F10键，出现英文对话框,选中“YES”键，并回车，计算机自动重启，证明更改的，设置生效了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62f2823ad1c5e0b14ba58df23986ede4/" rel="bookmark">
			关于Java中的时间处理，你真的了解吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在我的知识星球的直面Java板块中，给粉丝们出了这样一道题：
在Java中，如何获取不同时区的当前时间？
你知道这道题的正确答案应该如何回答吗？背后的原理又是什么呢？
然后，紧接着，我又提出了以下问题：
为什么以下代码无法得到美国时间。（在东八区的计算机上）
System.out.println(Calendar.getInstance(TimeZone.getTimeZone("America/Los_Angeles")).getTime()); 接下来，本文就围绕这两个问题，来带领读者一起学习一下哪些和Java中的时间有关的概念。
时区 前面提到了时区，可能很多读者不知道什么是时区，先来简单介绍一下。
时区是地球上的区域使用同一个时间定义。以前，人们通过观察太阳的位置（时角）决定时间，这就使得不同经度的地方的时间有所不同（地方时）。1863年，首次使用时区的概念。时区通过设立一个区域的标准时间部分地解决了这个问题。
世界各个国家位于地球不同位置上，因此不同国家，特别是东西跨度大的国家日出、日落时间必定有所偏差。这些偏差就是所谓的时差。
为了照顾到各地区的使用方便，又使其他地方的人容易将本地的时间换算到别的地方时间上去。有关国际会议决定将地球表面按经线从东到西，划成一个个区域，并且规定相邻区域的时间相差1小时。在同一区域内的东端和西端的人看到太阳升起的时间最多相差不过1小时。当人们跨过一个区域，就将自己的时钟校正1小时（向西减1小时，向东加1小时），跨过几个区域就加或减几小时。这样使用起来就很方便。
世界时区 现今全球共分为24个时区。由于实用上常常1个国家，或1个省份同时跨着2个或更多时区，为了照顾到行政上的方便，常将1个国家或1个省份划在一起。所以时区并不严格按南北直线来划分，而是按自然条件来划分。例如，中国幅员宽广，差不多跨5个时区，但为了使用方便简单，实际上在只用东八时区的标准时即北京时间为准。
格林威治时间 前面提到了，时区通过设立一个区域的标准时间部分地解决了不同地方看到的太阳位置不一样而无法定义时间的问题。那么这个标准时间是什么呢？
前面还提到。中国位于东八区，一般是用GMT+8来表示东八区这个时区。那么，看起来GMT就是这个所谓的标准时间。GMT是个什么东西呢？为什么要在他的基础上+8来表示东八区呢？
GMT，是Greenwich Mean Time的缩写，及格林尼治（格林威治）平时，是指位于英国伦敦郊区的皇家格林尼治天文台当地的平太阳时，因为本初子午线被定义为通过那里的经线。
格林威治子午线 自1924年2月5日开始，格林尼治天文台负责每隔一小时向全世界发放调时信息。国际天文学联合会于1928年决定，将由格林威治平子夜起算的平太阳时作为世界时，也就是通常所说的格林威治时间
一般使用GMT+8表示中国的时间，是因为中国位于东八区，时间上比格林威治时间快8个小时。
北京时间还可以用CST表示，即China Standard Time，又名中国标准时间，是中国的标准时间。当格林威治时间为凌晨0：00时，中国标准时间正好为上午8：00。
所以，有等式：CST=GMT +8 小时
时间戳 前面提到了全世界各个时区的时间可能都是不一样的，那么有没有一个什么样的办法可以不受时区的限制，可以精确的表示时间呢。
其实是有的，这个方法就是时间戳。
时间戳（timestamp），一个能表示一份数据在某个特定时间之前已经存在的、 完整的、 可验证的数据,通常是一个字符序列，唯一地标识某一刻的时间。
时间戳是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。
有了时间戳，无论我们深处哪个时区，从格林威治时间1970年01月01日00时00分00秒到现在这一时刻的总秒数应该是一样的。所以说，时间戳是一份能够表示一份数据在一个特定时间点已经存在的完整的可验证的数据。
1970-01-01
不知道大家有没有注意到一个比较特殊的时间，1970-01-01，相信每一个开发者对这个时间都并不陌生。一般如果软件系统中出现这个时间的时候，代表着出现了网络故障、线上bug等。
微信手机充值Bug ￼
当有些计算机存储或者传输时间戳出错时，这个时间戳就会取默认值。而在计算机中，默认值通常是 0。
当 Timestamp 为 0，就表示时间（GMT）1970年1月1日0时0分0秒。中国使用北京时间，处于东 8 区，相应就是早上 8 点。因此在中国这边，时间出错了，就经常会显示成 1970年1月1日 08:00。
System.out.println(new Date(0)); //Thu Jan 01 08:00:00 CST 1970 当我们在Java代码中使用new Date(0)来创建时间的时候，得到的结果就是Thu Jan 01 08:00:00 CST 1970，既1970年1月1日 上午08点整。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62f2823ad1c5e0b14ba58df23986ede4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ef07364337f1a895682ed139873d7e1/" rel="bookmark">
			【QT】如何将QFileDialog对话框中的英文内容转化为中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何将QFileDialog对话框中的英文内容转化为中文 在QT安装目录中找到相应的.qm文件，如/usr/local/Trolltech/Qt-4.8.7/translations/qt_zh_CN.qm在程序的入口函数出增加如下代码 #include &lt;QTranslator&gt; int main(int argc, char* argv[]) { QApplication a(argc, argv[]); QTranslator* pTranslator = new QTranslator(); pTranslator-&gt;load("/usr/local/Trolltech/Qt-4.8.7/translations/qt_zh_CN.qm"); a.installTranslator(); //test code 下面的代码用于测试转化的效果 QFileDialog::getOpenFileName(NULL, "11", "22", "33"); } 注：该方式的转化会把系统所以默认的对话框的英文翻译为中文，如打开，保存，QMessagebox中的内容
转化前效果：
转化后图片：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64c819fa103f41e81d6416559b952afd/" rel="bookmark">
			快速处理编译运行compileDebugJavaWithJavac问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速处理编译运行AS compileDebugJavaWithJavac问题
compileDebugJavaWithJavac是什么，从字面上看就是在debug调试的执行javac命令，编译器遇到不能解析的内容而抛出的异常。
上面一大片报红，很难定位错误的原因在哪里，在Terminal执行gradlew compileDebugJavaWithJavac命令能快速找到原因：
下面是命令执行结果：
找到有错误字眼的片段，从上面提示知道了是阿里路由ARouter这块出问题了，错误内容是Failed to extract default group! String index out of range: -2 ，意思是指MessageSharingMemberActivity这个类的路由path存在错误，无法识别提取。接着我看出了改类的路由path确实有问题，少了一个分级，ARouter的path必须要两级以上。
错误path：
改成：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e187b51bf9c90c0276871d941de743d0/" rel="bookmark">
			Java、web等各种学习-面试-职场资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者新建了一个QQ群：571278542 。欢迎大家加入获取资料！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3d407e3508d7b800c09e58560671763/" rel="bookmark">
			《操作系统》试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2014 -2015 学年第 1 学期 《操作系统》试题（B卷）
2014 -2015 学年第 1 学期 《操作系统》试题（A卷） 一、选择题（1分×30=30分）
1．在操作系统中引入多道程序设计的目的在于（ ）。
A.有利于代码共享，减少主、辅存信息交换量 B．充分利用存储器
C.充分利用CPU，减少CPU等待时间 D．提高实时响应速度
2．为了提高系统的交互性，人们设计了( )。
A.批处理系统 B．分时系统 C．实时系统 D.分布式系统
3．与计算机硬件关系最密切的软件是（ ）.
A.编译程序 B.数据库管理系统 C.游戏程序 D.OS
4．对于普通用户而言，OS的（ ）是最重要。
A.开放性 B.方便性 C.有效性 D.可扩充性
5．操作系统提供给程序员的接口是( )。
A.进程 B.系统调用 C.库函数 D.B和C
6．当CPU执行操作系统代码时,称CPU处于( )。
A.执行态 B.目态 C.管态 D.就绪态
7．进程的控制信息和描述信息存放在（ ）。
A.JCB B.PCB C.AFT D.SFT
8．进程从运行状态进入就绪状态的原因可能是( )。
A.被选中占有处理机 B.等待某一事件
C.等待的事件已发生 D.时间片用完
9．( )进程调度算法适合紧急事件的处理。
A.先来先服务 B.轮转 C.可抢占优先级 D.优先级
10．进程依靠什么从阻塞状态过渡到就绪状态（ ）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3d407e3508d7b800c09e58560671763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb2ec913586004cf99fdf3de6b6b75d/" rel="bookmark">
			二叉树算法题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.二叉树的节点数计算
class CountNodes { public: int count(TreeNode* root) { if (!root) return 0; int size = 1 +count(root-&gt;left); size += count(root-&gt;right); return size; } }; 2.二叉树的高度计算
int BinaryTree::height() { if (!Root) return 0; return ret_height_Core(Root); } int BinaryTree::ret_height_Core(TreeNode * x) { if (!x) return 0; int left_depth = ret_height_Core(x-&gt;left_child); int right_depth = ret_height_Core(x-&gt;right_child); return max(left_depth,right_depth)+1; } 3.请用递归方式实现二叉树的先序，中序和后序的遍历打印。
给定一个二叉树的根结点root，请依次返回二叉树的先序，中序和后续遍历（二维数组的形式）。
/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class TreeToSequence { public: void pre_print(vector&lt;int&gt;&amp; vec,TreeNode* root) {//二叉树的递归前序遍历 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eb2ec913586004cf99fdf3de6b6b75d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d751c78654cfe89a54b51e16ed0060dc/" rel="bookmark">
			SiamFC：基于全卷积孪生网络的目标跟踪算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Abstract 本论文提出一种新的全卷积孪生网络作为基本的跟踪算法，这个网络在ILSVRC15的目标跟踪视频数据集上进行端到端的训练。我们的跟踪器在帧率上超过了实时性要求，尽管它非常简单，但在多个benchmark上达到最优的性能。 1. Introduction 最近很多研究通过使用预训练模型来解决上述问题。这些方法中，要么使用网络内部某一层作为特征的shallow方法（如相关滤波）；要么是使用SGD方法来对多层网络进行微调。然而shallow的方法没有充分利用端到端学习的益处，而使用SGD微调虽然能到达时最优结果，但却难以达到实时性的要求。我们提出另一种替代性的方法。这个方法在初始离线阶段把深度卷积网络看成一个更通用的相似性学习问题，然后在跟踪时对这个问题进行在线的简单估计。这篇论文的关键贡献就在于证明这个方法在benchmark上可以达到非常有竞争性的性能，并且运行时的帧率远超实时性的要求。具体点讲，我们训练了一个孪生网络在一个较大的搜索区域搜索样本图片。本文另一个贡献在于，新的孪生网络结构是一个关于搜索区域的全卷积网络：密集高效的滑动窗口估计可通过计算两个输入的互相关性并插值得到。 2. Deep similarity learning for tracking 跟踪任意目标的学习可看成是相似性问题的学习。我们提出学习一个函数 f ( x , z ) f(x,z) f(x,z) 来比较样本图像 z z z 和搜索图像 x x x 的相似性。如果两个图像描述的是同一个目标，则返回高分，否则返回低分。我们用深度神经网络来模拟函数 f f f，而深度卷积网络中相似性学习最典型的就是孪生结构。孪生网络对两个输入 z z z 和 x x x 进行相同的变换 φ \varphi φ ，然后将得到的输出送入函数 g g g，最后得到相似性度量函数为： (1) f ( z , x ) = g ( φ ( z ) , φ ( x ) ) f(z,x)=g(\varphi(z),\varphi(x)) \tag{1} f(z,x)=g(φ(z),φ(x))(1) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d751c78654cfe89a54b51e16ed0060dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/975b3caefdf6df9903d425b297fbfc97/" rel="bookmark">
			shell 错误输出重定向的正确方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正常情况下, 执行命令的错误提示信息会直接打印出来, 但有时候在后台执行的时候, 我们更倾向于让错误信息保存到日志文件. Linux 的输出重定向很容易做到这点. 但有一次发现了一个奇怪的现象
# 重定向正确 $ ls nosuchfile 2&gt;logfile $ ls nosuchfile 1&gt;logfile 2&gt;&amp;1 # 重定向不正确 $ ls nosuchfile 2&gt;&amp;1 1&gt;logfile 所以正确的重定向方式是
1&gt;logfile 2&gt;&amp;1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dbfed97612fd6895f4073b1b9fb9617/" rel="bookmark">
			springmvc中视图解析器与视图对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 SpringMVC如何解析视图概述 1） 不论控制器返回一个String,ModelAndView,View都会转换为ModelAndView对象，由视图解析器解析视图，然后，进行页面的跳转。
2）视图解析源码分析：重要的两个接口
3） 断点调试源码
4） 流程图
2 视图和视图解析器 1） 请求处理方法执行完成后，最终返回一个 ModelAndView 对象。对于那些返回 String，View 或 ModeMap 等类型的处理方法，Spring MVC 也会在内部将它们装配成一个 ModelAndView 对象，它包含了逻辑名和模型对象的视图
2） Spring MVC 借助视图解析器（ViewResolver）得到最终的视图对象（View），最终的视图可以是 JSP ，也可能是 Excel、JFreeChart等各种表现形式的视图
3） 对于最终究竟采取何种视图对象对模型数据进行渲染，处理器并不关心，处理器工作重点聚焦在生产模型数据的工作上，从而实现 MVC 的充分解耦
3 视图 1） 视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户,主要就是完成转发或者是重定向的操作.
2） 为了实现视图模型和具体实现技术的解耦，Spring 在 org.springframework.web.servlet 包中定义了一个高度抽象的 View 接口：
3） 视图对象由视图解析器负责实例化。由于视图是无状态的，所以他们不会有线程安全的问题
4 常用的视图实现类 JstlView
1） 若项目中使用了JSTL，则SpringMVC 会自动把视图由InternalResourceView转为 JstlView （断点调试，将JSTL的jar包增加到项目中，视图解析器会自动修改为JstlView）
2） 若希望直接响应通过 SpringMVC 渲染的页面，可以使用 mvc:view-controller 标签实现
5 视图解析器 1） SpringMVC 为逻辑视图名的解析提供了不同的策略，可以在 Spring WEB 上下文中配置一种或多种解析策略，并指定他们之间的先后顺序。每一种映射策略对应一个具体的视图解析器实现类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dbfed97612fd6895f4073b1b9fb9617/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a373b3ff9e220779a209cce3a4632567/" rel="bookmark">
			图像卷积、相关以及在MATLAB中的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：http://www.cnblogs.com/zjutzz/p/5661543.html
图像卷积、相关以及在MATLAB中的操作 区分卷积和相关 图像处理中常常需要用一个滤波器做空间滤波操作。空间滤波操作有时候也被叫做卷积滤波，或者干脆叫卷积（离散的卷积，不是微积分里连续的卷积）；滤波器也有很多名字：卷积模版、卷积核、掩模、窗口等。
空间滤波可以分为线性滤波和非线性滤波。非线性滤波常见的有中值滤波、最大值滤波等，相当于自定义一个函数，在数学上由于不满足线性变换因此叫做非线性滤波。这里不细研究它。
线性滤波则通常是：将模版覆盖区域内的元素，以模版中对应位置元素为权值，进行累加。看起来挺简单的，但是要区分相关(cross-correlation)和卷积(convolution)两种模式。为什么呢？因为在MATLAB里是有所区分的，而且不少中文书里面把它们混淆了。
我们最容易的理解是：将模版中元素从左到右、从上到下，作为使用顺序，那么卷积操作的结果，就是模版第一个元素乘以它覆盖的元素，加上模版第二个元素乘以它覆盖的元素，再加上模版第三个元素乘以它覆盖的元素，...，一直加到模版最后一个元素乘以它覆盖的元素。好吧，其实就是：模版覆盖区域内，元素逐一相乘然后累加，此时的对应位置就是上下投影后被覆盖的位置。
上面这个理解确实是看起来最容易理解的，因而很多中文书把它叫做"卷积"。然而这个概念其实叫做相关，而卷积则相当于：将同样的模版旋转180°后，再做"相关"操作。当然，如果模版是180°对称的那么卷积和相关是相同的。但是并不是所有的模版都对称。因此，我建议，在滑窗操作、计算图像梯度等场合，不要使用“卷积”，而要使用“滤波”或者“相关”。因为，我们通常讲的卷积，其实是相关，那就不要用卷积这个词以免引起混淆。
MATLAB下的操作 在MATLAB中用imfilter来实现线性空间滤波：
imfilter(f, w, filtering_mode, boundary_options, size_options) f:图像 w:滤波模版 filtering_mode:滤波模式 'corr':相关滤波。[默认值] 'conv':卷积滤波。 boundary_options:边界选项 P:(没有引号)边界外围补充0。[默认值] 'replicate':边界外围复制边界值 'symmetric':边界外围使用边界镜像 'circular':图像的大小通过讲图像处理为二维周期函数的一个周期来扩展（这是什么？） size_options:大小选项 'same':输出大小与输入图像f大小相同。[默认值] 'full':输出与扩展（填充）后的图像大小相同。 最常用的是这句：
imfilter(f, w, 'replicate') %相关滤波，边界外围填充0，输出大小与输入图像f相同 当然，如果硬要做真正的卷积滤波，除了指定imfilter中的的conv参数，也可以先将模版旋转180°：
rotated_filter=flipud(fliplr(filter)) 总结 说了这么多废话，总结起来就是3句话：
很多中文书里（数字图象处理一类）讲的卷积过滤其实应当叫做相关过滤平时滤波最常用的是相关滤波，也就是“覆盖位相乘，然后累加”MATLAB中的写法为imfilter(f, w, 'replicate') ref https://www.zhihu.com/question/29121110
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b00d2973d5297d4666e6ba3525e4495/" rel="bookmark">
			@JSONField 注解详解和应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		讲到@JSONField 注解，就不得不提到Alibaba 开源的fasejson
fastjson是目前java语言中最快的json库，比自称最快的jackson速度要快，第三方独立测试结果看这里：https://github.com/eishay/jvm-serializers/wiki
这里有jackson作者cowtowncoder等人对fastjson的性能评价：https://groups.google.com/forum/#!topic/java-serialization-benchmarking/8eS1KOquAhw
Fastjson VS gson性能
fastjson比gson快大约6倍，测试结果上这里：https://github.com/eishay/jvm-serializers/wiki/Staging-Results
下面我们来介绍@JSONField 注解的应用:
1. JSONField 介绍 注意：1.1、若属性是私有的，必须有set*方法。否则无法反序列化。
package com.alibaba.fastjson.annotation; public @interface JSONField { // 配置序列化和反序列化的顺序，1.1.42版本之后才⽀持 int ordinal() default 0; // 指定字段的名称 String name() default ""; // 指定字段的格式，对⽇期格式有⽤ String format() default ""; // 是否序列化 boolean serialize() default true; // 是否反序列化 boolean deserialize() default true; } 2. JSONField配置方式 2.1FieldInfo可以配置在getter/setter方法或者字段上。例如： public class A { private int id; @JSONField(name="ID") public int getId() {return id;} @JSONField(name="ID") public void setId(int value) {this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b00d2973d5297d4666e6ba3525e4495/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b00cda8b2a4d553eb4c7def75de41c9/" rel="bookmark">
			奇异值的意义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵的奇异值是一个数学意义上的概念，一般是由奇异值分解（Singular Value Decompostition，SVD）得到。如果要问奇异值表示什么物理意义，那么就必须要考虑在不同的实际工程应用中奇异值所对应的含义。下面先尽量避开严格的数学符号推导，直观地从一张图片出发，让我们来看看那奇异值代表什么意义。
这是上野树里的一张图片，像素为高度 450 ∗ 450* 450∗ 宽度 333 333 333。
我们知道，图片实际上对应着一个矩阵，矩阵的大小就是像素大小，比如这张图片对应的矩阵阶数就是450*333，矩阵上每个元素的数值对应着像素值。我们记这个像素矩阵为 A A A。现在我们对矩阵 A A A 进行奇异值分解。直观上，奇异值分解将矩阵分解成若干个秩一矩阵之和，用公式表示就是：
A = σ 1 u 1 v 1 T + σ 2 u 2 v 2 T + ⋅ ⋅ ⋅ + σ r u r v r T A = \sigma _{1} u_{1} v_{1}^{T} + \sigma _{2} u_{2} v_{2}^{T} + ··· + \sigma _{r} u_{r} v_{r}^{T} A=σ1​u1​v1T​+σ2​u2​v2T​+⋅⋅⋅+σr​ur​vrT​
其中等式右边每一项前面的系数 σ \sigma σ 就是奇异值， u u u 和 v v v 分别表示列向量，秩一矩阵的意思是矩阵秩为1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b00cda8b2a4d553eb4c7def75de41c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51f41df5824b5cbe34c7c7201fcca0c9/" rel="bookmark">
			Windows 无法访问指定设备,路径或文件。你可能没有合适的权限访问这个项目。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Windows 无法访问指定设备,路径或文件。你可能没有合适的权限访问这个项目。 0. 背景 出现这个问题的背景如下：
电脑安装有金山毒霸win10 系统打开部分.exe文件情况报上述错 1. 报错原因 说实话，这个windows系统，我也不大清楚为什么会报这个错。
2. 解决办法 我这里列举一下常见的解决办法：
way 1：修改用户权限
其实刚开始，我也这么做了，后来仍然不行。实在无奈之下，我更改了win10 的更新选项，将电脑更新一次； 接着卸载了金山毒霸；然后右击.exe文件所在的磁盘，选择属性，找到安全选项
点击编辑，到如下页面：
添加“完全控制”权限，再次尝试。
【其实，我一直觉得这个windows报错一直是金山毒霸的锅。。。】way 2：
略去… 3. 参考文章 https://www.kafan.cn/edu/48009656.html?_t=t 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e990a94f524a6f392a09800c1fc592c0/" rel="bookmark">
			C&#43;&#43; 实现websocket 简单的服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
打算写一个WebSocket服务器来练练手，它是基于tcp实现的，与生俱来的优点较之http是全双工的，即服务端可主动向客户端推送数据，亦可请求响应的模式来进行数据传输
WebSocket讲解
网上有很多对WebSocket的格式进行了充分的讲解，我们搬来用用。
参考自 https://segmentfault.com/a/1190000012948613 感谢大神！！！
握手
首先是客户端和服务器建立连接，即握手操作。
GET / HTTP/1.1 Host: localhost:8080 Origin: http://127.0.0.1:3000 Connection: Upgrade Upgrade: websocket Sec-WebSocket-Version: 13 Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw== 这是客户端的请求
- Connection: Upgrade：表示要升级协议
- Upgrade: websocket：表示要升级到 websocket 协议。
- Sec-WebSocket-Version: 13：表示 websocket 的版本。如果服务端不支持该版本，需要返回一个 Sec-WebSocket-Versionheader ，里面包含服务端支持的版本号。
- Sec-WebSocket-Key：与后面服务端响应首部的 Sec-WebSocket-Accept 是配套的，提供基本的防护，比如恶意的连接，或者无意的连接
HTTP/1.1 101 Switching Protocols Connection:Upgrade Upgrade: websocket Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU= 这是服务器响应。
- Sec-WebSocket-Accept
伪代码如下：
&gt;toBase64(sha1(Sec-WebSocket-Key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11))
接下来就是数据的传输（客户端与服务器）
数据帧的格式
&gt; fin占1位，表示此次传输数据包是否传输完，因为websocket里有分片传输，1传输完，0未传输完
&gt; rsv1,2,3占3位，是做扩展用
&gt; opcode占4位，是数据帧的操作类型包括close，ping，pong，binary，text等
&gt; mask占1位，1表示数据要经过掩码运算，0表示不需要掩码操作，服务器不需要掩码，客户端需要
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e990a94f524a6f392a09800c1fc592c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53cea80559f952a9cd45c998f764a3af/" rel="bookmark">
			SpringAop切入点execution表达式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Aspect切入点语法定义 在使用spring框架配置AOP的时候，不管是通过XML配置文件形式，还是注解的方式都需要定义pointcut(切入点)，pointcut称之为切入点。
例如 ：
定义切入点表达式 ： execution (* com.sample.service.impl..*.*(..)) 上面的execution()是最常用的切点函数，其语法如下所示：
整个表达式可以分为五个部分
1、execution()：表达式主体。 2、第一个*号：表示返回类型，*号表示所有的类型。 3、包名：表示需要拦截的包名，后面的两个句点分别表示当前包和当前包的所有子包，com.sample.service.impl包、子孙包下所有类的方法。 4、第二个*号：表示类名，*号表示所有的类。 5、*(..) ：第三个星号表示方法名，*号表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数。 下面给出一些常见切入点表达式的例子： 借鉴(https://smallbee.iteye.com/blog/2213078)
任意公共方法的执行：
execution(public * *(..)) ： 表明任何返回类型、类名和参数的任何公共方法都将被通知。 任何一个以"set"开始的方法的执行：
execution(* set*(..)) AccountService接口的任意方法的执行：
execution(* com.xyz.service.AccountService.*(..)) 定义在service包里的任意方法的执行：
execution(* com.xyz.service.*.*(..)) 定义在service包或者子包里的任意类的任意方法的执行：
execution(* com.xyz.service..*.*(..)) 二、如何定义多个切入点，在多个表达式之间如何表示 使用 ||， or表示 或使用 &amp;&amp;，and表示 与使用not，！表示 非 三、execution表达式 1、匹配指定包下所有类方法 ：
execution(* com.baidu.dao.*(..)) 不包含子包 2. 匹配指定包以及及指定包下面的子包所有类 ： execution(* com.baidu.dao..*(..)) ..*表示当前包、子孙包下所有类 3、匹配指定类所有方法 ： execution(* com.baidu.service.UserService.*(..)) 4、匹配实现特定接口所有类方法 ： execution(* com.baidu.dao.GenericDAO+.*(..)) 5、匹配所有save开头的方法 ： execution(* save*(..)) 另外，签名可分为类型签名和方法签名，下面介绍两种类型 的区别，参考自： https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53cea80559f952a9cd45c998f764a3af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f627ebd66b3b97597f41063aa32d276/" rel="bookmark">
			Github Lz4压缩解压缩源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub上面有很多源码，包括Lz4压缩解压缩算法。地址：https://github.com/lz4/lz4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eaf0c40490b5d0f671f0c25367cf90e/" rel="bookmark">
			vue国际化-vue-i18n的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前提基础 对vue.js、vuex等有基本的了解element国际化配置 2、安装依赖 npm i -S element-ui vue-i18n js-cookie 复制代码 安装js-cookie是为了将当前选择的语言保存并在下一次打开时默认选择。 3、代码分析 准备本地的翻译信息，在src下新建lang文件夹，新建文件zh.js，en.js。 zh.js export default { common: { confirm: '确定', cancel: '取消', home: '首页' }, login: { login: '登录', logout: '退出' }, header: { message: '这是公共的头部组件' }, footer: { message: '这是公共的底部组件' } } en.js export default { common: { confirm: 'confirm', cancel: 'cancel', home: 'home' }, header: { message: 'this is a common header component' }, footer: { message: 'this is a common footer component' }, login: { login: 'login', logout: 'logout' } } 复制代码 创建VueI18n实例，使用创建的翻译信息，在lang文件下新建index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eaf0c40490b5d0f671f0c25367cf90e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a519efa6b66503ddc76a954727a48224/" rel="bookmark">
			react中转义问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当输入框输入html，我们希望他转义成html，而不是以字符串的形式输出。很简单，方法如下
dangerouslySetInnerHTML={{__html:item }}&gt; 这样就可以实现转义了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dff52184530030cf29c28cbfcb1edee/" rel="bookmark">
			service command not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我在使用docker安装nginx时，镜像环境是centos，报如下错误：
nginx.sh service command not found
然后退出了镜像生成过程，解决办法：
进入容器内：
输入
service 发现真的没有
yum list | grep initscripts 会出现以下信息
initscripts.x86_64 使用yum安装一个
yum install initscripts -y 在输入service 就ok啦
那么需要dockerfile里面加
RUN yum install initscripts -y 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6880f85ce9d1c0c49aaa451e879c8fd1/" rel="bookmark">
			如何快速删除卸载残余-注册表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常使用电脑时总会安装、卸载一些我们需要的或者不需要的软件，在卸载操作中一旦操作不当就会留下卸载残余，影响我们日常的使用，比如说默认的快捷软件、打开方式等，接下来就此讲一下如何快速方便的删除这些卸载残余~
如何快速删除卸载残余-注册表 正文卸载残余的例子解决办法第一步：打开注册表第二步：搜索注册文件并删除 正文 卸载残余的例子 卸载后的“打开方式”，如下图所示：
解决办法 第一步：打开注册表 在电脑右下角的开始框中输入“regedit”，上方会出现注册表选项，如下图所示：
点击进入即可；
或者使用cmd命令面板（“Win+R”快捷键召唤出运行窗口,再在运行中输入cmd即可打开cmd命令面板），然后在cmd命令面板中输入“regedit”回车运行也可以打开注册表，如下图：
“Win+R”快捷键召唤~
输入“regedit”
点击“是”：
打开后的注册表编辑器：
第二步：搜索注册文件并删除 打开注册表编辑器后就可以搜索卸载残余的注册表啦，以上图中卸载残余的打开方式为例，其步骤如下：
将卸载残留提示的信息中的软件名部分输入到搜索框中进行搜索
搜索中：
搜索完成后就会自动定位并打开相应的注册表文件，如下图所示：（如果搜索不出来很有可能就是输入搜索的名称不对，来回试试即可~）
右键点击选择删除即可~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87ee3fa12f35deb0a66d48ba8c7b0971/" rel="bookmark">
			写一个简单的VPP插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
注册插件
注册node
Node处理packet主函数
注册开关CLI
文件位置
运行测试
源码在此
总结分析
通过VPP自带的例子和网上一些例子的参考，写了一个最简单的插件练习，插件功能：把hook到的包打印一下IP头。
注册插件 VLIB_PLUGIN_REGISTER () = { .version = CK_SAMPLE_PLUGIN_BUILD_VER, .description = "Sample of VPP Plugin", }; static clib_error_t *ck_sample_init(vlib_main_t* vm) { ck_sample_main.vnet_main = vnet_get_main(); return 0; } VLIB_INIT_FUNCTION(ck_sample_init); 注册node //node初始化信息，生成一堆该Node的构造/析构函数 VLIB_REGISTER_NODE (ck_sample_node) = { .name	= "ck_sample", .function = ck_sample_node_fn, .vector_size = sizeof(u32), .format_trace = format_ck_sample_trace, .type = VLIB_NODE_TYPE_INTERNAL, .n_errors = ARRAY_LEN(ck_sample_error_strings), .error_strings = ck_sample_error_strings, .n_next_nodes = CK_SAMPLE_NEXT_N, .next_nodes = { [CK_SAMPLE_NEXT_IP4] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87ee3fa12f35deb0a66d48ba8c7b0971/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/effafee0857134dad7ddec9f079ff024/" rel="bookmark">
			C# EntityFramework DbFirst的情况下为实体添加各种特性（不需要T4模板）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发的过程需要给实体添加特性，为了方便选择的EF的codeFirst。但是后期需要用到视图，codeFirst映射视图的方式在网上找了很久都没有找到合适的办法，而且采用dbFirst的情况下，为实体添加特性又成了难题，虽然说学习T4模板是个好办法，但是却感觉使用模板有很多限制。后来在传智播客的培训视频中找到了解决方法。因为这个视频很早了。方法有点老，但是很实用。
一、通过数据库创建实体 创建实体的办法，很简单网上也有很多方法。略········
实体如下
二、以Material_Message为例，添加类文件Material_MessageExt 创建类Material_Message,并添加关键字partial创建类MaterialMessageValidate。在MaterialMessageValidate类中添加和Material_Message相同的属性，在属性上添加所需的特性，本例以Display特性为例在Material_Message添加特性[MetadataType(typeof(MaterialMessageValidate))]。这个特性的是让Material_Message共享MaterialMessageValidate中的元数据。 [MetadataType(typeof(MaterialMessageValidate))] public partial class Material_Message { } public class MaterialMessageValidate { [Display(Name = "器材编号")] public string Material_Id { get; set; } [Display(Name = "器材名称")] public string Material_Name { get; set; } [Display(Name = "器材类型")] public string Material_Type_Name { get; set; } [Display(Name = "器材总量")] public double Material_Count { get; set; } [Display(Name = "器材余量")] public double Material_Remain_Count { get; set; } [Display(Name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/effafee0857134dad7ddec9f079ff024/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7186cf8db6cc24bd626cb2ef1a48b3b/" rel="bookmark">
			centos7搭建证书登录ssh服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时我们远程管理 centos 主机使用 putty 工具, 也不需要用到证书登录, 但是当与客户传输(sftp协议)资料时,可能需要用到证书登录
本文介绍如何搭建一台 sshd 服务器以及用户通过证书登录 sshd 服务
环境 [root@localhost ~]# cat /proc/version Linux version 3.10.0-123.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.2 20140120 (Red Hat 4.8.2-16) (GCC) ) #1 SMP Mon Jun 30 12:09:22 UTC 2014 [root@localhost ~]# ssh -V OpenSSH_6.4p1, OpenSSL 1.0.1e-fips 11 Feb 2013 第1步,生成 ssh 证书 在 client 端生成证书, 最终把公钥放到 server 端
建立RSA类型,长度为2048的证书,文件名为: rsa_2048_181205 # ssh-keygen -t rsa -b 2048 -f rsa_2048_181205 Generating public/private rsa key pair.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7186cf8db6cc24bd626cb2ef1a48b3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58bdc7e07a0bda77d06a81c149149f4c/" rel="bookmark">
			Java反射介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、反射的概述 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.
以上的总结就是什么是反射
反射就是把java类中的各种成分映射成一个个的Java对象
例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。（其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）
如图是类的正常加载过程：反射的原理在与class对象。
熟悉一下加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。
二、Java中为什么需要反射？反射要解决什么问题？ Java中编译类型有两种：
静态编译：在编译时确定类型，绑定对象即通过。动态编译：运行时确定类型，绑定对象。动态编译最大限度地发挥了Java的灵活性，体现了多态的应用，可以减低类之间的耦合性。 Java反射是Java被视为动态（或准动态）语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，包括其modifiers（诸如public、static等）、superclass（例如Object）、实现之interfaces（例如Cloneable），也包括fields和methods的所有信息，并可于运行时改变fields内容或唤起methods。
Reflection可以在运行时加载、探知、使用编译期间完全未知的classes。即Java程序可以加载一个运行时才得知名称的class，获取其完整构造，并生成其对象实体、或对其fields设值、或唤起其methods。
反射（reflection）允许静态语言在运行时（runtime）检查、修改程序的结构与行为。
在静态语言中，使用一个变量时，必须知道它的类型。在Java中，变量的类型信息在编译时都保存到了class文件中，这样在运行时才能保证准确无误；换句话说，程序在运行时的行为都是固定的。如果想在运行时改变，就需要反射这东西了。
实现Java反射机制的类都位于java.lang.reflect包中：
Class类：代表一个类Field类：代表类的成员变量（类的属性）Method类：代表类的方法Constructor类：代表类的构造方法Array类：提供了动态创建数组，以及访问数组的元素的静态方法 一句话概括就是使用反射可以赋予jvm动态编译的能力，否则类的元数据信息只能用静态编译的方式实现，例如热加载，Tomcat的classloader等等都没法支持。
三、使用 1、获取Class对象的三种方式
1.1 Object ——&gt; getClass();
1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性
1.3 通过Class类的静态方法：forName（String className）(常用)
/** * 获取Class对象的三种方式 * 1 Object ——&gt; getClass(); * 2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性 * 3 通过Class类的静态方法：forName（String className）(常用) * */ public class Fanshe { public static void main(String[] args) { //第一种方式获取Class对象 Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。 Class stuClass = stu1.getClass();//获取Class对象 System.out.println(stuClass.getName()); //第二种方式获取Class对象 Class stuClass2 = Student.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58bdc7e07a0bda77d06a81c149149f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9768338fe893a3926195ce1363b510b2/" rel="bookmark">
			CUDA之nvidia-smi命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nvidia-smi是用来查看GPU使用情况的。我常用这个命令判断哪几块GPU空闲，但是最近的GPU使用状态让我很困惑，于是把nvidia-smi命令显示的GPU使用表中各个内容的具体含义解释一下。
这是服务器上特斯拉K80的信息。 上面的表格中： 第一栏的Fan：N/A是风扇转速，从0到100%之间变动，这个速度是计算机期望的风扇转速，实际情况下如果风扇堵转，可能打不到显示的转速。有的设备不会返回转速，因为它不依赖风扇冷却而是通过其他外设保持低温（比如我们实验室的服务器是常年放在空调房间里的）。 第二栏的Temp：是温度，单位摄氏度。 第三栏的Perf：是性能状态，从P0到P12，P0表示最大性能，P12表示状态最小性能。 第四栏下方的Pwr：是能耗，上方的Persistence-M：是持续模式的状态，持续模式虽然耗能大，但是在新的GPU应用启动时，花费的时间更少，这里显示的是off的状态。 第五栏的Bus-Id是涉及GPU总线的东西，domain:bus:device.function 第六栏的Disp.A是Display Active，表示GPU的显示是否初始化。 第五第六栏下方的Memory Usage是显存使用率。 第七栏是浮动的GPU利用率。 第八栏上方是关于ECC的东西。 第八栏下方Compute M是计算模式。 下面一张表示每个进程占用的显存使用率。
显存占用和GPU占用是两个不一样的东西，显卡是由GPU和显存等组成的，显存和GPU的关系有点类似于内存和CPU的关系。我跑caffe代码的时候显存占得少，GPU占得多，师弟跑TensorFlow代码的时候，显存占得多，GPU占得少。
背景 qgzang@ustc:~$ nvidia-smi -h 输出如下信息：
NVIDIA System Management Interface – v352.79
NVSMI provides monitoring information for Tesla and select Quadro devices. The data is presented in either a plain text or an XML format, via stdout or a file. NVSMI also provides several management operations for changing the device state.
Note that the functionality of NVSMI is exposed through the NVML C-based library.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9768338fe893a3926195ce1363b510b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcd24cd6438d7fca276fbf52e0706578/" rel="bookmark">
			k-fold与交叉验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 https://zhuanlan.zhihu.com/p/24825503
常用的是对标注数据集做7:3划分训练集和验证集，只用了一部分数据，且结果很大程度上依赖于选取的数据。LOOCV（Leave-one-out cross-validation）:每次用一个样本测试，其他数据训练。计算量太大。k_fold cv (k-fold cross validation) ：把数据分K份，每次留一份进行验证，k=N时是loocv。得到k个模型取最优。 k的选取，过大投入训练数据太多，极端例子成为loocv，导致每次训练的数据相关性很大。过小很难得到较优结果。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21a7434ea1a45314cc62a2052d0d195e/" rel="bookmark">
			保留满足条件的行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#arr_old 原来数组 #arr_new 保留后的数组 #&gt;=mean+std 指定条件 arr_new = arr_old[arr_old[:,4]&gt;=(mean+std),:]#筛选数组，保留第5列满足条件的行 arr_new = arr_old[~(arr_old[:,2]&gt;=4),:]#反转，保留第5列不满足条件的行 https://www.cnblogs.com/qiu-hua/p/7808896.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410d751d8313045c00c5efbb5406fec1/" rel="bookmark">
			如何利用python进行绘制地理热力图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		folium 地图库的安装 在电脑comand命令行上输入：pip install folium
然后如果出现successfully的话则代表你安装成功。
接下来，我们来进行编程了
import os import folium import numpy as np f1=open("f://icm//data11111.txt","r").read().split("\n") //经度数据 fx=[] for item in f1: a=eval(item) fx.append(a) f2=open("f://icm//data22222.txt","r").read().split("\n") //纬度数据 fy=[] for item in f2: a=eval(item) fy.append(a) f3=open("f://icm//data33333.txt","r").read().split("\n") //地图上的坐标的热力值 fz=[] for item in f3: a=eval(item) fz.append(a) data=[] i=0 for i in range(len(fx)-1): item=[] item.append(fx[i]) item.append(fy[i]) item.append(fz[i]) data.append(item) from folium.plugins import HeatMap m = folium.Map([ 33., 113.], tiles='stamentoner', zoom_start=5) HeatMap(data).add_to(m) m.save(os.path.join(r'f://', 'Heatmap_restday1.html')) //将地图保存在电脑文件里 m / //显示地图 运行程序，通过Jupiter集成环境，你会发现出来一个世界地图。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/410d751d8313045c00c5efbb5406fec1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31f0d1f450a8520a6e16fe3e7e66dea5/" rel="bookmark">
			Latex之figure的嵌套：Subfig与subfigure
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在论文中经常有一个figure内含有其他小的figure,这时就要使用一些宏包。
subfigure是比较老的了，目前通用的是subfig,两个包在使用的时候用法不同，千万不要混淆了。不然莫名其妙的报错根本不知道是怎么回事。
例：
subfig
\begin{figure}[tbp] \centering \subfloat[Arabic numerals]{\label{fig:a}\includegraphics[width=1in]{placeholder}}\quad \subfloat[Arabic numerals]{\label{fig:b}\includegraphics[width=1in]{placeholder}}\\	\caption{Capital Roman numerals.} \end{figure} subfigure
\begin{figure} \centering \subfigure[figure 1 title.] { \label{fig:a} \includegraphics[width=0.8\columnwidth]{fig1.eps} } \subfigure[figure 2 title.] { \label{fig:b} \includegraphics[width=0.8\columnwidth]{fig2.eps} } \caption{ general title. } \label{fig} \end{figure} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ee5053dd60bc105279fddb18c77bdb/" rel="bookmark">
			Windows下的Pycharm远程连接虚拟机中Centos下的Python 虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows下的Pycharm远程连接虚拟机中Centos下的Python环境 准备工作 Centos 固定 IP地址 我这里的地址是 192.168.3.6 Centos 配置了python环境 Centos 配置了 ssh
设置 参数 添加centos的环境变量
在这里选择SSH ,输入 host的地址 ，用户名 和密码 最下面的选择的是python的路径
注意 ：这里 如果安装了两个版本的python ，默认的 是选择的python2 ，你可以选择下python3
连接到linux的配置
配置具体的信息 还有本地的代码位置 配置信息
pycharm 2018 版本可能稍微有点不太一样 . 这里勾选设置,add
输入远程的主机名称和username
输入密码
选择相应的编译环境 ,如果要是编译环境是虚拟环境, 那就到具体的虚拟目录下查找
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/486a99a2b215894a83f06ccc8fc774f4/" rel="bookmark">
			视频文件大小码率计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 翻阅了些资料，然后总结下，方便以后翻阅
编码率/比特率直接与文件体积有关。且编码率与编码格式配合是否合适，直接关系到视频文件是否清晰。 在视频编码领域，比特率常翻译为编码率，单位是Kbps，例如800Kbps 其中， 1K=1024 1M=1024K b 为 比特（bit） 这个就是电脑文件大小的计量单位，1KB=8Kb，区分大小写，B代表字节(Byte) s 为 秒（second） p 为 每（per） 以800kbps来编码表示经过编码后的数据每秒钟需要用800K比特来表示。 1MB=8Mb=1024KB=8192Kb Windows系统文件大小经常用B(字节)为单位表示，但网络运营商则用b(比特)，也就是为什么2Mb速度宽带在电脑上显示速度最快只有约256KB的原因，网络运营商宣传网速的时候省略了计量单位。 视频文件体积：(音频码率+视频码率) x 时长 / 8
如果一个视频的视频码率为3Mbps, 音频码率为512Kbps, 时长90分钟(5400秒), 那么整个视频文件的大小就是:
(512/1024 + 3) x 5400 / 8 = 2362MB
相反，如果一个视频文件大小有10GB，时长为90分钟(5400秒)， 那么它的码率（视频＋音频）为:
10 x 1024 x 8 / 5400 = 15Mbps
例：有一个1.5小时（5400秒）的影片，希望转换后文件大小刚好为700M 计算方法如下： 700×8÷5400×1024≈1061Kbps 当然不经过压缩文件的计算公式又不同： 声音为，数据量（位/秒）= (采样频率（Hz）*采样位数（bit）*声道数)
其中，单声道的声道数为1，立体声的声道数为2。
数据量*时间/8＝文件总字节
例如CD即为未经压缩的音频文件，采样44.1k,16位,双声道。
数据量＝44.1*16*2=1411kb/1024=1.38Mb,一般的MP3压缩后为128kbps
如果以一张CD放一个小时计算的话，CD总量＝1.38*3600/8=621MB,当然CD大约放1小时多点,顶多也就700MB。
图象应该是，数据量（位/秒）= (画面尺寸*彩色位数（bit）*帧数)
数据量*时间/8＝文件总字节 例如2分钟,25帧/秒,640×480分辨率,24位真彩色数字视频的不压缩的数据量约为，数据量＝640x480x24*25=184320Kb=180Mb,而VCD、MKV标准编码率(加上音频)分别为1152Kbps和30Mbps(1080p高清)
2分钟文件字节＝180Mbx120/8=2700000KB=2636.71875MB＝2.57GB，而压缩后一部90分钟高质量DVD电影可以达到9GB。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f96026001c39bce85b57231518f87038/" rel="bookmark">
			docker 解决容器内访问宿主机“No route to host”的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修复方式请顺序运行以下命令：
nmcli connection modify docker0 connection.zone trusted
systemctl stop NetworkManager.service
firewall-cmd --permanent --zone=trusted --change-interface=docker0
systemctl start NetworkManager.service
nmcli connection modify docker0 connection.zone trusted
systemctl restart docker.service
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/854b4ea356c77689018cbb0e70a8940a/" rel="bookmark">
			ERROR StatusLogger No log4j2 configuration file found. Using default configuration
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring5与log4j不兼容的问题
maven中
需要导入log4j 2以上的版本
在web.xml中配置监听器和log4j的配置文件
log4j2.xml放在资源根目录就行，不配置系统也会自己找到
log4j的配置文件(log4j2.xml)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c394f9d4d99ec7b8088a057de6b0e243/" rel="bookmark">
			Unity C#作为客户端与C&#43;&#43;服务器 传递结构体进行Socket通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近接触到C#和C++进行SOCKET通讯的问题。
讲述一下我的情况：
和我合作的是一个只懂C++的程序员 ， 而我是一个经常使用C# 对C++知之甚少的人， 没办法 半路出家。
C++的服务器是他写的 C#的客户端是我写的。 说实话，这个问题困扰了我长达2周之久。 期间我有一种我是中国人而那个人却是个美国人的感觉。
下面贴一下思路和代码
C++这边我不是特别会写，在网上找了个简单的代码稍微改了改建立Socket服务器
#include &lt;thread&gt; #include "winsock2.h" #include &lt;iostream&gt; WORD sockVersion = MAKEWORD(2, 2); WSADATA wsaData; if (WSAStartup(sockVersion, &amp;wsaData) != 0) { return 0; } //创建套接字 slisten = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (slisten == INVALID_SOCKET) { printf("socket error !"); return 0; } //绑定IP和端口 sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(8888); sin.sin_addr.S_un.S_addr = INADDR_ANY; if (_WINSOCK2API_::bind(slisten, (LPSOCKADDR)&amp;sin, sizeof(sin)) == SOCKET_ERROR) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c394f9d4d99ec7b8088a057de6b0e243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b00dd53f2743678284a45545c6e4c976/" rel="bookmark">
			群晖和QNAP的NAS的备份功能的测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文网址：http://www.nas1.cn/thread-68635-1-1.html
群晖和QNAP都能在其NAS上做冗余磁盘(RAID-1或RAID-5)保护,以防磁盘损坏时丢失数据.但这不叫备份, 只能称为冗余保护.因为这种方式不能防止误删除,误操作的情况. 同时如果NAS主板坏掉, 再多的磁盘冗余也不能保护数据.所以,真正的,狭义的数据备份,其所保存的地点, 至少不应该是那台NAS本身. 同时需要能保留数据的多个历史版本, 在需要的时候,可以选择任一历史版本进行恢复.毕竟很多时候,误删除的数据可能要较长时间才能发现, 进入挽救过程.
群晖和QNAP的NAS自身都带有备份功能, 能独立运行, 不依赖计算机的参与的那种. 我期待使用它们的备份功能,主要出于几点原因:
如前文所述,我们需要能还原数据的多个历史版本,以应对误删除, 误改名, 误移动等操作;如前文所述,我们需要应对NAS完全坏掉的情况;我的这两个NAS都是双盘位的,大部分是电影,不值得保护; 只有极少部分是文档, 需要保护. 但是如果将NAS做RAID-1,容量一下缩减一半, 又太可惜了;我这里只有NAS是常开机在线的, 计算机流动性非常大, 没有一个固定的计算机作为服务器角色来存储和管理备份数据. 因此希望(一个或多个)NAS能搞定备份的所有的事情;平常不会有人关心数据备份的,所以备份应该是自动静默运行的,同时又不占用太多存储空间. 我最近同时有了群晖DS213j和QNAP TS-220各一台, 做了一些测试, 本文主要对它们的备份功能进行了测试. 它们的软件版本分别为DSM 4.2-3211和QTS 4.0.1 . -------------------------
情况一: 群晖作为客户端(源), QNAP作为服务器端(目的)
普通备份, 从界面上来看,备份的目的端可以是一个QNAP(Rsync兼容),备份源可以到目录和文件级别, 但备份目的则只能是共享目录级别,可以指定历史版本数(最多30个),可以指定备份排程. 而且, 在目的端(QNAP的某个共享目录)中, 最后一个备份历史版本的备份数据与源文件的结构形式相同, 也就是说不需要群辉也可以拿回文件(仅限于最后一次备份). 还原时, 可以选择历史版本, 但不能选择具体文件/目录, 且不能改变还原目的路径.还原过程中NAS上所有共享目录都会暂时消失. 但是, 上述功能只是从界面上来看. 在实际测试中, 无论你选择哪个历史版本, 实际上能还原的都仅仅是最后一次备份的内容而已. 哪怕备份目标是本地的另外一个目录(此时已经与另外一个NAS或Rsync之类的无关了).共享文件夹同步功能, 目的端不能是一个QNAP;Time Backup客户端, 此功能同样不支持QNAP作为目的端, 哪怕QNAP启用了支持作为TIME BACKUP服务端. 没有尝试备份到本地, 因为那需要NAS中含有两个存储空间,而我只有一个. --------------------------------
情况二: QNAP作为客户端(源),群晖作为服务器端(目的):
可以使用Rsync备份到群晖上, 但没有历史版本的选项,只是保留最近的数据而已;可以用RTRR的目录同步功能, 而且源可以是本机,也可以是远端服务器, 当然目的端需要相应地调整. 但远端(服务器)只能是FTP服务器,群晖不能作为RTRR服务器.FTP同步效果还好, 稍微有些延迟,也许真正的RTRR会好些.QNAP不能作为time backup的客户端. --------------------------------
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b00dd53f2743678284a45545c6e4c976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc824389ccac9cfde6be4197e14ca061/" rel="bookmark">
			gitlab内存占用过大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gitlab 一跑起来内存就占一大半，在上传个代码就卡死了有时候，
解决方法：
top -ac 看一下开启了多少unicorn worker进程，gitlab默认开启进程数与CPU内核数相同
解决：
修改gitlab.rb文件（根据实际修改）
1.减少进程数
vim /etc/gitlab/gitlab.rb unicorn['worker_processes'] = 8 默认是被注释掉的，官方建议该值是CPU核心数加一，可以提高服务器的响应速度，如果内存只有4G，或者服务器上有其它业务，就不要改了，以免内存不足。另外，这个参数最小值是2，设为1，服务器可能会卡死。
2. 减少数据库缓存
postgresql['shared_buffers'] = "256MB" 默认为256MB，可适当改小
3. 减少数据库并发数
postgresql['max_worker_processes'] = 8 默认为8，可适当减少
4. 减少sidekiq并发数
Bash
sidekiq['concurrency'] = 25 默认是25，可适当改小
5. 启用Swap分区
使用Swap的方法，请自行搜索
需要注意的是，修改完配置以后，需要执行下面的命令使配置生效：
Bash
sudo gitlab-ctl reconfigure sudo gitlab-ctl restart 以上就是解决GitLab内存占用过高的几点方法，有什么问题可在文章下方留言一起讨论。
重新加载配置
重启gitlab
（建议worker=CPU核数+1）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45c8b275f78a94ccbe99e7a871188d1/" rel="bookmark">
			火眼金睛算法，教你海量短文本场景下去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文由QQ大数据发表
最朴素的做法
在大多数情况下，大量的重复文本一般不会是什么好事情，比如互相抄袭的新闻，群发的垃圾短信，铺天盖地的广告文案等，这些都会造成网络内容的同质化并加重数据库的存储负担，更糟糕的是降低了文本内容的质量。因此需要一种准确而高效率的文本去重算法。而最朴素的做法就是将所有文本进行两两比较，简单易理解，最符合人类的直觉，对于少量文本来说，实现起来也很方便，但是对于海量文本来说，这明显是行不通的，因为它的时间复杂度是，针对亿级别的文本去重时，时间消耗可能就要以年为单位，此路不通。
另外，我们讲到去重，实际上暗含了两个方面的内容，第一是用什么方式去比较更为高效，第二是比较的时候去重标准是什么。这里的去重标准在文本领域来说，就是如何度量两个文本的相似性，通常包含编辑距离，Jaccard距离，cosine距离，欧氏距离，语义距离等等，在不同领域和场景下选用不同的相似性度量方法，这里不是本文的重点，所以按下不表，下面着重解决如何进行高效率比较的问题。
核心思想
降低时间复杂度的关键： &gt; 尽力将潜在的相似文本聚合到一块，从而大大缩小需要比较的范围
simHash算法
海量文本去重算法里面，最为知名的就是simHash算法，是谷歌提出来的一套算法，并被应用到实际的网页去重中。 simHash算法的最大特点是：将文本映射为一个01串，并且相似文本之间得到的01串也是相似的，只在少数几个位置上的0和1不一样。为了表征原始文本的相似度，可以计算两个01串之间在多少个位置上不同，这便是汉明距离，用来表征simHash算法下两个文本之间的相似度，通常来说，越相似的文本，对应simHash映射得到的01串之间的汉明距离越小。
为了让这个过程更为清晰，这里举个简单的例子。
t1 = "妈妈喊你来吃饭" t2 = "妈妈叫你来吃饭"
可以看到，上面这两个字符串虽然只有一个字不同，但是通过简单的Hash算法得到的hash值可能就完全不一样了，因而无法利用得到的hash值来表征原始文本的相似性。然而通过simHash算法的映射后，得到的simHash值便是如下这样：
SH1 = "1000010010101101[1]1111110000010101101000[0]00111110000100101[1]001011" SH2 = "1000010010101101[0]1111110000010101101000[1]00111110000100101[0]001011"
仔细观察，上面的两个simHash值只有三个地方不一样（不一样的地方用"[]"标出），因此原始文本之间的汉明距离便是3。通常来说，用于相似文本检测中的汉明距离判断标准就是3，也就是说，当两个文本对应的simHash之间的汉明距离小于或等于3，则认为这两个文本为相似，如果是要去重的话，就只能留下其中一个。
simHash算法的去重过程思路很简单，首先有一个关键点： &gt; 假如相似文本判断标准为汉明距离3，在一个待去重语料集中存在两个相似文本，那也就是说这两个相似文本之间的汉明距离最大值为3（对应hash值最多有3个地方不同），如果simHash为64位，可以将这个64位的hash值从高位到低位，划分成四个连续的16位，那么这3个不同的位置最多只能填满4个中的任意3个区间（可以反过来想，如果这4个区间都填满了，那就变成汉明距离为4了）。也就是说两个相似文本必定在其中的一个连续16位上完全一致。
想明白了这个关键点之后，就可以对整个待去重文本都进行一次simHash映射（本文中使用64位举例），接着将这些01串从高位到低位均分成四段，按照上面的讨论，两个相似的文本一定会有其中一段一样，仍用上面的例子，分成的四段如下所示：
t1 = "妈妈喊你来吃饭" SH1 = "1000010010101101[1]1111110000010101101000[0]00111110000100101[1]001011" SH1_1 = "1000010010101101" #第一段 SH1_2 = "[1]111111000001010" #第二段 SH1_3 = "1101000[0]00111110" #第三段 SH1_4 = "000100101[1]001011" #第四段 t2 = "妈妈叫你来吃饭" SH2 = "1000010010101101[0]1111110000010101101000[1]00111110000100101[0]001011" SH2_1 = "1000010010101101" #第一段 SH2_2 = "[0]111111000001010" #第二段 SH2_3 = "1101000[1]00111110" #第三段 SH2_4 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d45c8b275f78a94ccbe99e7a871188d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f816d73a2edd8a268f402b102c922ae/" rel="bookmark">
			三极管打造树莓派温控风扇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了防止树莓派长时间开机运转温度过高导致触发过热关机，很多人都给装了散热风扇，但某宝买的风扇插上之后是随着开机一直运转的，不能随温度变化而自动开闭，很多时候做无用功浪费电且产生噪音。本文将以一个硬件小白的程序员视角详细讲述如何用三极管扩展普通的树莓派散热风扇从而实现温控功能。
在制作自己的温控风扇前，本人也查阅了网上其他资料，最终选用了三极管方案，在接线方式中选择了自制杜邦线连接三极管和风扇，这样的好处是线材的长度可以随自己需要裁剪，而且可以轻松塞进树莓派的外壳中。全程无焊接，以后不用也可方便拆卸线材、杜邦头、三极管元件等用作其他用途。
准备材料
以下材料均可某宝购买，为了省事其中杜邦头和杜邦胶壳是买的套件，一盒里边有公母端子各200个，以及各种类型的胶壳。
1.树莓派散热风扇
2.尖嘴钳：用来剥线和压线
3.导线
4.杜邦端子：母端子6个，公端子2个
5.杜邦胶壳：1P1个，2P2个，3P一个（非必须）
6.三极管S8550
第一步：制作杜邦线
杜邦线：电子行业杜邦线可用于实验板的引脚扩展，增加实验项目等。可以非常牢靠地和插针连接，无需焊接，可以快速进行电路试验。
杜邦端子：分为两种，公端子和母端子。
杜邦胶壳：按照可封装的端子数，可插一个端子的为1P，可插两个端子的为2P，四个端子以上的按照排列分为单排XP或双排XP，例如单排4P为可插端子都排列成一排，双排4P为可插端子分为两排，每排两个端子。
上图：
以上简介如须详细了解请自行搜索相关资料。
此处需要制作4跟杜邦线：
其中两根杜邦线两头都带母端子（简称母对母）。一根用于接三极管基极到到主板GPIO14引脚上，另一根用于接三极管集电极到主板地线引脚上。
剩余两根公对母杜邦线，其中一根公端子插风扇正极（红线）母端子，另一头母端子插主板正极，另外一根公端子插风扇负极（黑线）母端子，另一头母端子接三极管发射集上。
本人买的导线为单铜芯导线（外径0.58mm），后来发现制作一根杜邦线仅用一根导线会卡不牢固，容易发生导线与杜邦端子脱落，因此每跟杜邦线都是由两根单铜芯导线组成，因此本处需要裁剪8根导线。
1.剪8根导线，每根导线长度大约7cm。
2.剥线，用尖嘴钳将导线两端分别露出约1cm铜芯。
3.拧线（此处如果买的导线较粗，请略过这一步），将两根导线并排，分别将两端外露铜芯用尖嘴钳拧在一起。因为外露铜芯较细为了防止接触不良，我将外露铜芯反复折叠了两次并拧紧，实际导线外露的长度大概2.5mm左右。
4.压线，将导线外露铜芯压入杜邦端子中，由于手头没有专门的压线钳，此步骤也用尖嘴钳完成。成品见图：
注意：
如果买的导线较粗1cm左右，只需剪4根即可。（但如果太粗的话可能塞不进端子里边），另外剥线时导线两端只要露出大概2-3mm左右即可
第二步：用胶壳封装杜邦端子（不用胶壳的这一步可以略过）
第三步：接线
第四步：写驱动程序
执行驱动脚本前需要安装相关依赖yum install -y python-devel，以及RPi.GPIO模块
wget https://jaist.dl.sourceforge....
附上驱动代码：
#!/usr/bin/python2 import sys import time try: import RPi.GPIO as GPIO except RuntimeError: print("Error importing RPi.GPIO! This is probably because you need superuser privileges. You can achieve this by using 'sudo' to run your script"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f816d73a2edd8a268f402b102c922ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d97827a47e17795cf35b37be0fd5a29/" rel="bookmark">
			腾讯公司面试题（大数据岗位）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、手写一个冒泡排序代码或者选择排序代码？
2、给一个网页的url，抓取指定的title标签里的文本内容，请写出实现代码？
3、Hadoop怎么从本地上传到hdfs文件？请写出命令行
4、怎么获取指定范围内的POI?怎么设计表？
5、一个表的数据是全的，一个表的数据是部分数据，请用HQL写出部分数据所对应的全部数据？
6、你们数据量大概是多少？
7、Mysql用过吗？怎么获取Mysql中的数据？每次用的时候都需要创建新的连接吗？写过线程池吗？
8、工作中遇见的挑战最大的问题是什么？
9、还有什么要问的吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c30eeb158d0926a95c54273b0cdb9d/" rel="bookmark">
			Tensorflow实现cifar10识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要准备的是cifa10数据集，下载地址：http://www.cs.toronto.edu/~kriz/cifar.html下载binary版。cifar-10分类数据集为60000张32 * 32的彩色图片，总共有10个类别，其中50000张训练集，10000张测试集。
之后从https://github.com/tensorflow/models/tree/master/tutorials/image/cifar10下载cifar10.py和cifar10_input.py。将这两个文件放在工程目录下即可。
载入需要的库 import tensorflow as tf import numpy as np import cifar10 import cifar10_input import time 2. 初始化权重函数
def variable_with_weight_loss(shape,std,w1): var = tf.Variable(tf.truncated_normal(shape,stddev=std),dtype=tf.float32) #使用tf.truncated_normal截断的正态分布，加上L2的loss，相当于做了一个L2的正则化处理 #w1:控制L2 loss的大小，tf.nn.l2_loss函数计算weight的L2 loss if w1 is not None: weight_loss = tf.multiply(tf.nn.l2_loss(var),w1,name="weight_loss") tf.add_to_collection("losses",weight_loss)#加入losses列表 return var 3. 计算softmax和loss
def loss_func(logits,labels): labels = tf.cast(labels,tf.int32) cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels,name="cross_entropy_per_example") #softmax和cross entropy loss的计算合在一起 cross_entropy_mean = tf.reduce_mean(tf.reduce_sum(cross_entropy)) #计算cross entropy 均值 tf.add_to_collection("losses",cross_entropy_mean) #把交叉熵均值加入到losses中 return tf.add_n(tf.get_collection("losses"),name="total_loss") #将整体losses的collection中的全部loss求和，即最终的loss，有cross entropy loss，两个全连接层 中weight的L2 loss 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9c30eeb158d0926a95c54273b0cdb9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efec81079f6679ce968c2f65e0a6d652/" rel="bookmark">
			如何在pc上安装安卓应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在windows系统中安装使用安卓app windows中安卓模拟器相对比较成熟，我使用的方法是bluestacks安卓模拟器
下载地址https://www.bluestacks.cn/
安装方法与其他软件相同
接下来我们找到相关apk文件进行下载即可
如图所示aps地址为http://downloadpkg.apicloud.com/app/download?path=http://www.shmiaosuan.com/wallet/bizhang.apk
点击即可下载
下载完成后，打开bluestacks模拟器
选择添加apk文件，直接找到下载apk的所在目录进行安装即可
安装完成后如图所示
这样就可以在windows上使用安卓app了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ad805e14b6d38dd98b663665e828ce/" rel="bookmark">
			学习测试遇到的坑（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Htmltestrunner 0.8版本是用python2的语法写的，而我使用的是python3.7。查询了网上的方法改掉Htmltestrunner的源码后还是有两个错误：
init_sys_streams: can't initialize sys standard streams
ImportError: cannot import name 'io' from 'io' (unknown location)
查询了很久发现没有人出现这种错误，而且python好像被我搞坏了，不管运行什么都显示这两条错误。在 系统设置-&gt;应用 里尝试修复python和重启电脑后还是那样，只能卸载python重新安装，幸好重装后python恢复可以正常使用，最后还是决定乖乖使用最新版的Htmltestrunner。用pip安装Htmltestrunner的命令如下：
pip install html-testRunner
最新版的HTMLTestRunner源码如下：
class HTMLTestRunner(TextTestRunner): """" A test runner class that output the results. """ def __init__(self, output, verbosity=2, stream=sys.stderr, descriptions=True, failfast=False, buffer=False, report_title=None, template=None, resultclass=None) HtmlTestRunner.HTMLTestRunner(output=file_d,report_title="This is a report of first_case")
output是输出的文件夹,日志报告会以html为后缀自动放在“工程目录/reports/file_d”这个路径的文件夹下，并以当前时间命名。
report_title是日志的标题
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/420/">«</a>
	<span class="pagination__item pagination__item--current">421/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/422/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>