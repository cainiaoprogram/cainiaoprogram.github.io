<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a01d23e6d1563858ac6e253105576c2/" rel="bookmark">
			IDEA Java 第一个mybatis入门程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 准备mysql 开始新建maven项目maven添加引用mybatis配置文件工具类创建实例类添加mappermappermapper.xml 测试类 发现问题org.apache.ibatis.binding.BindingException: Type interface com.cpyy.mapper.UserMapper is not known to the MapperRegistry.The error may exist in com/cpyy/mapper/UserMapper.xml 参考 准备 Java 18
mysql 8
maven
idea
mysql 准备数据
CREATE DATABASE `mybatis`; USE `mybatis`; CREATE TABLE `user`( `id` int not null PRIMARY KEY, `name` varchar(30) DEFAULT NULL, `pwd` varchar(30) DEFAULT NULL )ENGINE=INNODB,CHARSET=utf8; INSERT INTO `mybatis`.`user` (`id`, `name`, `pwd`) VALUES (1, 'haha', '123'), (2, 'lala', '123'), (3, 'xixi', '1234'); 开始 新建maven项目 这个就不用详细说了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a01d23e6d1563858ac6e253105576c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fb0be45831e4b03960a16675189e2b7/" rel="bookmark">
			35岁以10亿美元身价登上《财富》杂志亿万富豪榜的电商传奇谢家华
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zappos的介绍 Zappos可谓是电商的传奇，国内同类电商是乐淘。Zappos是一家在线卖鞋和服装的公司，1999年创立，2009年被亚马逊以12亿元收购， 多次入选财富杂志最佳雇主公司top100。
Zappos的创始人及CEO 提到Zappos就不得不介绍下此公司的CEO谢家华，这里我列一下其书《Delivering Happiness: A Path to Profits, Passion, and Purpose》，其翻译为中文版《三双鞋》时对他的简历说明：谢家华，美国B2C模式华裔创业楷模。一位通过自身努力创造奇迹的天才CEO。
24岁，微软以2.65亿美元的价格收购他创办“链接交换”公司；
25岁，作为顾问及投资人，成立了卖鞋的美捷步网站Zappos；
26岁，成为美捷步公司的首席执行官；
35岁， 带领美捷步公司以年销10亿美元的骄人业绩横扫美国电子商务领域，亚马逊以高达12亿美元的价格收购美捷步；
35岁，美捷步荣登《财富》杂志“最佳雇主”排行榜新上榜公司第1名；
35岁，以10亿美元身价登上《财富》杂志“40岁以下亿万富豪榜”，排名第27位。
谢家华的经历和成就 他学生时期的经历：1993年的ACM International Collegiate Programming Contest世界冠军，办了卖给学生的比萨餐厅，哈佛的计算机学士学位。
谢家华父母均是祖籍中国大陆的移民。1973年12月12日，谢家华出生于美国伊利诺州，自小于旧金山长大，从哈佛大学资讯工程系毕业后，自行创业。
1996年，谢家华成立广告网站Link Exchange，到1998年该网站已有逾40万名会员、每天有500则广告轮播，在1998年11月，Link Exchange以2.65亿美元，出售给微软。1999年，他接受创业者史文莫恩提议，共同投资成立卖鞋网站，随后更加入Zappos担任执行长。Zappos在2000年营收160万美元，到了2009年收益已达到10亿美元。2009年，他把Zappos以12亿美元售予美国电子商务巨头亚马逊，之后仍续留公司担任执行长，直到2020年8月退休。
Zappos 核心价值观 给用户超出预期的服务
主动拥抱和寻找改变
做一些有趣的疯狂的事
富有冒险精神，创新精神和开放精神
追求成长和学习
乐于交流，建设开放诚实的关系
有积极的团队精神，视队友如家人
追求高效
热情而坚定
谦虚
谢家华的故事改编成电影 SB Projects制片公司将会把谢家华的故事改编成电影，名为《奇迹男孩》。影片根据Angel Au-Yeung和David Jeans即将出版的传记图书《奇迹男孩：谢家华、Zappos和硅谷幸福生活的神话》改编。
谢家华个人生活和离世 Tony Hsieh的个人生活充满了创新和挑战。他喜欢旅行、音乐和电子舞蹈，曾在拉斯维加斯创办了一个文化艺术空间，希望将其打造成一个创新的社交场所。
2020年11月18日，谢家华在康乃狄克州新伦敦一处民宅遭遇火灾，因吸入浓烟的并发症而在27日去世。谢家华是受困在女友屋外的储藏室，然而消防员在外呼喊却没人应门，推估当时可能因酒精及药物作用下无法即时回应，友人及同事认为可能是谢家华为营造气氛所点燃的蜡烛才导致火灾。内华达州州长史蒂夫·西苏拉克（Steve Sisolak）在推特上发文哀悼：
“谢家华在协助改造拉斯维加斯市中心扮演关键角色……在这艰难时刻，我和太太向谢家华的至亲好友致上慰问之意。 ”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c283bce54e7329c5b09fe7b4aff6119b/" rel="bookmark">
			Golang与Java全方位对比总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文针对Golang与Java的基础语法、结构体函数、异常处理、并发编程及垃圾回收、资源消耗等各方面的差异进行对比总结，有不准确、不到位的地方还请大家不吝赐教。
一 基础语法 Golang: 编码风格及可见域规则严格且简单；Java: 来说层次接口清晰、规范，主要表现有以下这些。
1、变量 a、变量声明及使用 在Java中：变量可以声明了却不使用
public static String toString(int num) { int data = num; return String.valueOf(num); } Golang中：声明的变量必须被使用，否则需要使用_来替代掉变量名，表明该变量不会比使用到
func toString(num int) string { data := num // data没有使用者，无法编译 return strconv.Itoa(num) } func toString(num int) string { _ := num // 正常编译 return strconv.Itoa(num) } b、变量声明及初始化 在Java中：如果在方法内部声明一个变量但不初始化，在使用时会出现编译错误；
public void compareVariable() { int age; Object object; System.out.println(age); // 编译错误 System.out.println(object); // 编译错误 } 在Golang中：对于基本类型来讲，声明即初始化;对于引用类型，声明则初始化为nil。
func compareVariable() { var num int var hashMap *map[string]int fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c283bce54e7329c5b09fe7b4aff6119b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5277dd4727eeb0277c8ea53b5b94f6bb/" rel="bookmark">
			SpringBoot 中的自带工具类，开发效率增加一倍！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
断言
对象、数组、集合
ObjectUtils
StringUtils
CollectionUtils
文件、资源、IO 流
FileCopyUtils
ResourceUtils
Resource
StreamUtils
反射、AOP
ReflectionUtils
AopUtils
AopContext
来源：
SpringBoot 中的自带工具类，开发效率增加一倍！
断言 断言是一个逻辑判断，用于检查不应该发生的情况
Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数-enableassertions开启
SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查
// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行 // 参数 message 参数用于定制异常信息。 void notNull(Object object, String message) // 要求参数必须空（Null），否则抛出异常，不予『放行』。 // 和 notNull() 方法断言规则相反 void isNull(Object object, String message) // 要求参数必须为真（True），否则抛出异常，不予『放行』。 void isTrue(boolean expression, String message) // 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行 void notEmpty(Collection collection, String message) // 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行 void hasLength(String text, String message) // 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行 void hasText(String text, String message) // 要求参数是指定类型的实例，否则抛出异常，不予放行 void isInstanceOf(Class type, Object obj, String message) // 要求参数 `subType` 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行 void isAssignable(Class superType, Class subType, String message) 对象、数组、集合 ObjectUtils 获取对象的基本信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5277dd4727eeb0277c8ea53b5b94f6bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccdc819daff4330dd7c95c1938b3eaab/" rel="bookmark">
			熵权法原理及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		熵权法原理及应用
一、熵权法简述 熵：起源于物理学，表示物质微观热运动时的混乱程度，在信息论中是衡量系统无序程度度量值。
熵权法：根据信息熵的定义，对于某项指标，可以用熵值来判断某个指标的离散程度，其信息熵值越小，指标的离散程度越大， 该指标对综合评价的影响（即权重）就越大，如果某项指标的值全部相等，则该指标在综合评价中不起作用。因此，可利用信息熵这个工具，计算出各个指标的权重，为多指标综合评价提供依据。
结合熵权法的定义可知，其属于一种来自数据本身的权重确定方法，所以又被称为“客观赋权法”。基础原理是“指标离散程度越大，权重越大”。
二、熵权法优缺点及应用范围 优点：
1.熵权法确定权重依据来自数据本身，客观性强，减少了主观性对决策结果的影响。
2.熵权法计算逻辑简单清晰，操作性较好，易于实现。
缺点：
1.熵权法将不同指标看作独立存在，未考虑指标间的相关性，容易出现权重分配不合理的情况。
2.熵权法完全取决于数据本身，计算得出的权重往往难以直接应用到实际中，需要进行一定调整。
应用范围：
1.适合应用于指标间相关性较弱的数据；
2.适合作为基础权重确定方法；
3.若指标量纲相差较大时，需要进行标准化处理。
三、熵权法计算步骤 1.构建指标体系，确定指标矩阵X=[X1,X2，，，Xn].
其中，每一列为一个指标，每一行为一个个体在不同指标的取值。图中所示共n个指标，m个个体。
2.对初始指标矩阵X进行标准化（归一化）处理，得到标准化指标矩阵Z。
以上为指标标准化处理方法，处理后得到标准化矩阵Z。
其中，每个元素Zij均为0-1之间的值。
3.计算每个指标的熵值Hj;
4.根据熵值计算熵权
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/552ea344b1567c7aade69f9bf4170689/" rel="bookmark">
			Midjourney需要科学上网才能访问，国内Midjourney中文版支持最新的Midjourney和Niji.journey V5版和关键词解析、视频转动漫，人像动话等功能，一直自用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Midjourney需要科学上网才能访问，国内Midjourney中文版支持最新的Midjourney和Niji.journey V5版和关键词解析、视频转动漫，人像动话等功能，一直自用，有免费次数，次数不贵。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a03b962f4a25e59d75cfdf00c91b731/" rel="bookmark">
			Unity - 微信小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 总参考：Unity WebGL 微信小游戏适配方案(公测)
安装与使用 下载 Unity插件，并导入至游戏项目中，版本更新请查看更新日志
请查阅推荐引擎版本，安装时选择WebGL组件 最终选择Unity2021.2.5f1c1InstantGame前往Node官网安装长期稳定版 之前已安装v16.17.0前往微信开发者工具下载安装Stable版开发者工具【注意：为保证稳定性，请勿使用小游戏版 Minigame Build】 下载版本为：wechat_devtools_1.06.2303220_win32_x64查阅小游戏开发者文档-快速上手创建小游戏类目应用登录MP微信公众平台，能力地图-生产提效包-快适配，开通使用 查阅快速开始：转换工具导出微信小游戏进行小游戏导出转换 创建小程序账号 进入 微信公众平台 (qq.com)扫码选择小程序进行注册（注意：一个邮箱只能注册一个）如果是测试号，则会直接打开开发者ID页面，直接找到游戏appid信息如果非测试号，则可以设置一些自己小程序内容，并且在基本设置中拉到最下方，找到游戏appid信息 导出Unity工程 创建个Unity工程平台选择为WebGL把之前下载好的minigame.unitypackage全部导入打开微信小游戏面板 配置游戏appid配置导出路径首包资源加载方式则条件而选导出
导出后可以看到minigame和webgl两个文件夹导出完成 打开导出项目，并且运行 安装之前下载好的微信开发者工具，已安装则跳过此步骤打开微信开发者工具，选择小游戏，目录选择之前导出的minigame文件夹如果出现错误：插件未授权使用 添加插件，直接点击添加插件就好之后等待重新编译，运行成功，具体适配还得看文档说明，抱歉我也是第一次整这个如果字体消失了，那检查Unity日志，以及微信开发者工具日志，尽可能的使用原带字体，并且包体大小有限制，要注意。 博客杂货铺GoF23 种设计模式的分类和功能 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdfc02f02203b70f8437072d26be7dab/" rel="bookmark">
			必学AI绘图技巧，如何用Midjourney实现连续性人物的创作，SEED功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常使用Midjourney的朋友可能都知道，尽管最新的Midjourney V5版本可以通过自然的语言描述创作出高质量的绘画作品，但却有很大的随机性，即使你输入同样的命令，Midjourney每次输出的结果都会不一样。
下面介绍一下以人物画像为例，我们需要保证输出的人物面容保持一致性，我们需要用SEED功能。
首先我们先用Midjourney V5版中创建一个人物，比如“现实主义，科幻动漫女性，金发，复杂的细节，艺术站”
绘画完成后，从四张中挑一张满意的图片，先将该作品升级至高清图像超高分辨率，我这个是竖版图3584*5376的，然后再保存此图片备用作为参考图，下面有个随机种子，后面有个复制的图标，点击复制下这9位数字，我这个图的SEED值是896204160，
然后再切换回绘画中，上面Midjourney V5，参考图像我们从手机相册中选择刚刚保存下来的那张满意图片，种子SEED把刚才的9位数值粘贴过来，最后最下面写上新的描述词，看看人物形象是否相同或相近，比如“爱丽丝女士，在太空船上，人物肖像”，
设置好后，开始绘制，高速通道无需等待，马上就能得到结果，让我们一起看看吧，第一张是原版做对比。
我又找一张比较满意的图，再重新生成一次，版型我们这次选横版宽比例，让我们一起看看吧，第一张是原版做对比。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e05849b3edc840f7d14f069297daa5b/" rel="bookmark">
			到底什么是线程？线程与进程有哪些区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章我们讲述了什么是进程，进程的基本调度
http://t.csdn.cn/ybiwThttp://t.csdn.cn/ybiwT 那么本篇文章我们将了解一下什么是线程？线程与进程有哪些区别？线程应该怎么去编程？
目录
http://t.csdn.cn/ybiwThttp://t.csdn.cn/ybiwT
一、什么是线程+线程的概念
二、为什么要有线程？
三、进程和线程的区别
3.1 java线程和操作系统线程的关系
四、线程的创建
五、需要主要的几个地方
六、Thread类里面的一些其他方法
6.1Thread几个常见属性
一、什么是线程+线程的概念 进程，是比较“重量的”速度慢/消耗资源多的，那么创建一个进程，成本比较高；销毁一个进程，成本也比较高；调度一个进程，成本也挺高的。进程包含线程，一个进程里可以有多个线程，多个线程之间也是并发执行的。
那么线程，则是更轻量的进程（轻量级进程），一个进程中可以包含多个线程，此时这多个线程每个线程都是一个独立可以调度执行的“执行流”，同时这些进程共用一份进程的系统资源，（意味着，对于线程而言，系统资源是已经分配好了的，创建线程就省下了分配资源开销）。一个线程就是一个 "执行流". 每个线程之间都可以按照顺讯执行自己的代码. 多个线程之间 "同时" 执行着多份代码。
一个进程中的多个线程之间，共用同一份系统资源：
1.（内存空间）
2.（文件描述符表）
操作系统，真正调度的是在调度线程，而不是进程。
线程是操作系统调度运行的基本单位
进程是操作系统资源分配的基本单位
举例：滑稽老铁吃鸡
多进程吃鸡：
多线程吃鸡：
并不是线程越多越好，如果线程过多会影响系统的效率，如果一个线程出现了异常，可能会导致此进程中的所有线程全部崩溃！！！
二、为什么要有线程？ 首先, "并发编程" 成为 "刚需".
单核 CPU 的发展遇到了瓶颈. 要想提高算力, 就需要多核 CPU. 而并发编程能更充分利用多核 CPU资源.有些任务场景需要 "等待 IO", 为了让等待 IO 的时间能够去做一些其他的工作, 也需要用到并发编程. 其次, 虽然多进程也能实现 并发编程, 但是线程比进程更轻量.
创建线程比创建进程更快.销毁线程比销毁进程更快.调度线程比调度进程更快. 最后, 线程虽然比进程轻量, 但是人们还不满足, 于是又有了 "线程池"(ThreadPool) 和 "协程"
(Coroutine)
三、进程和线程的区别 1.进程包含线程
2.进程有自己独立的内存空间和文件描述符表，同一个进程中的多个线程之间，共用同一份地址空间和文件描述符表
3.进程是操作系统资源分配的基本单位，线程是操作系统调度执行的基本单位
4.进程之间具有独立性，一个进程挂了，不会影响其他的进程；同一个进程里面的线程挂了，可能会有全部的线程都挂掉
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e05849b3edc840f7d14f069297daa5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6060a3b03b5efcd3baa130228b80109/" rel="bookmark">
			python可视化神器——pyecharts(词云图&amp;雷达图&amp;极坐标系)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与基本的Matplotlib绘图相比，pyecharts的交互以及可视化更为友好，更适合于项目开发、商业报告。
github.com/pyecharts/pyecharts
pyecharts 分为 v0.5.X 和 v1 两个大版本，v0.5.X 和 v1 间不兼容，v1 是一个全新的版本，很多函数的用法出现了变更
pip install pyecharts 第一个pyecharts程序 bar.add_x/yaxis() 添加横/纵坐标
bar.render() 存储文件，默认html文件
#V1 from pyecharts.charts import Bar bar = Bar() bar.add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"]) bar.add_yaxis("商家A", [5, 20, 36, 10, 75, 90]) # render 会生成本地 HTML 文件，默认会在当前目录生成 render.html 文件 # 也可以传入路径参数，如 bar.render("mycharts.html") bar.render() # render_notebook 则在notebook页面中直接显示 bar.render_notebook() 常用图表绘制 v1就是正常的anaconda的python
v0.5的是pyecharts-v05的python环境 pyecharts==0.1.9.4
v1的样例：
https://github.com/pyecharts/pyecharts/tree/master/example
图云 #V1 from pyecharts import options as opts from pyecharts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6060a3b03b5efcd3baa130228b80109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71824072573043b5717eebc1ff2a9079/" rel="bookmark">
			Spring-aop源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.背景 聊到spring肯定离不开IOC和AOP，AOP也是其中的大头，今天我们来研究一下AOP的底层实现原理。
我们通过@Aspect注解的案例来一步一步深入看一下spring是怎么实现功能增强的。
@Aspect @Component public class AnimalEatAspect { @Pointcut("execution(* com.springboot.study.service.Animal.eat())") public void pointcutEat() { System.out.println("pointcutEat"); } @Before("execution(* com.springboot.study.service.Animal.eat())") public void beforeEat() { System.out.println("beforeEating"); } @After("execution(* com.springboot.study.service.Animal.eat())") public void afterEat() { System.out.println("afterEating"); } @Around("execution(* com.springboot.study.service.Animal.eat())") public void aroundEat() { System.out.println("aroundEating"); } @AfterReturning("execution(* com.springboot.study.service.Animal.eat())") public void afterReturnEat() { System.out.println("afterReturnEat"); } @AfterThrowing("execution(* com.springboot.study.service.Animal.eat())") public void afterThrowEat() { System.out.println("afterThrowEat"); } } 带着两个问题去探究：
1.@Aspect是怎么通过解析器给方法进行增强的？
2.spring-aop如何引用aspectj包里面的注解{Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class}去控制到方法执行时机的？
二.源码 调用栈：解析@Aspect注解，添加对应的拦截器
getAdvice:276, ReflectiveAspectJAdvisorFactory (org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71824072573043b5717eebc1ff2a9079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d85515d556e2ecb5d1909feed8b2661e/" rel="bookmark">
			Python时间序列分析详细实例（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、时间序列模型简介
二、案例分析
三、模型构建 四、结果分析
一、时间序列模型简介 正常的数据类型分为三种：横截面数据、时间序列数据和面板数据三类。其中，时间序列是按照一定的时间间隔排列的一组数据，其时间间隔可以是任意的时间单位，如小时、日、周月等。在本例中为每天某产品的需求量，这些数据形成了以一定时间间隔的数据。
时间序列数据包含时间要素和数值要素，通过对这些时间序列的分析，从中发现和揭示现象发展变化的规律，并将这些知识和信息用于预测。比如需求量是上升还是下降，是否与季节有关，是否可以通过现有的数据预测未来的需求量是多少等。其变化规律有：长期趋势、季节趋势、循环变动和不规则变动四种。
采用时间序列分析进行预测时需要一系列的模型，这种模型称为时间序列模型。
#导入库 import numpy as np import pandas as pd import tensorflow as tf import matplotlib.pyplot as plt from tensorflow.keras import layers,Input,optimizers from sklearn.preprocessing import StandardScaler from sklearn.metrics import mean_absolute_percentage_error from statsmodels.graphics.tsaplots import plot_acf from sklearn.model_selection import train_test_split import statsmodels.api as sm import statsmodels.formula.api as smf import statsmodels.tsa.api as smt from statsmodels.tsa.stattools import adfuller from statsmodels.stats.diagnostic import acorr_ljungbox from statsmodels.graphics.api import qqplot 二、案例分析 判断该时间序列的特征可以帮助我们理解数据并且选择合适的模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d85515d556e2ecb5d1909feed8b2661e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/725ae32d448815ff8738bbc34e4ab36a/" rel="bookmark">
			2023年全国职业技能大赛软件测试之自动化测试题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动化测试
一、任务要求
题目1：按照以下步骤在PyCharm中进行自动化测试脚本编写并执行。
1. 设置智能时间等待3秒；
2. 引入By方法类；
3. 通过NAME属性定位用户名输入框，并输入用户名XTGLY；
4. 通过ID属性定位密码输入框，并输入密码123456；
5. 通过TAG_NAME方法定位登录按钮，使用click()方法点击登录按钮；
6. 通过LINK_TEXT方法定位仓库信息按钮并使用click()方法点击；
7. 通过TAG_NAME的复数形式定位并点击仓库信息中的第一个仓库的“禁用”按钮；
8. 通过alert方法中的accept方法关闭第一个弹窗；
9. 使用get_screenshot_as_file对页面进行截图操作（命名为test_accept01.png，存放在D盘根目录下）。
题目2：按照以下步骤在PyCharm中进行自动化测试脚本编写并执行。
1. 搭建unittest框架；
2. 引入By方法类；
3. 定义setUp方法启动浏览器，增加3秒的智能等待，将浏览器窗口最大化；
4. 定义tearDown方法关闭浏览器；
5. 定义test_denglu01方法进入系统登录页面，通过CLASS_NAME方法定位用户名输入框，通过NAME方法定位密码输入框并输入账号和密码（XTGLY/123456），通过ID方法定位并点击登录按钮；
6. 定义test_denglu02方法进入系统登录页面，通过NAME方法定位用户名输入框，通过ID方法定位密码输入框并输入账号和密码（XTGLY/123456），通过TAG_NAME定位登录按钮并点击，使用XPATH点击商品管理页面的新增按钮，使用send_keys上传图片并使用get_screenshot_as_file方法对页面进行截图；
7. 通过unittest.main()方法执行测试用例。
题目3：按照以下步骤在PyCharm中进行自动化测试脚本编写并执行。
测试数据：
商品分类名称
预期结果
商品分类名称必填，请重新输入。
步骤1：新建csv格式的测试数据testdata.csv，并编写csvv.py脚本读取csv中的测试数据。
步骤2：新建test01.py：
1. 引入步骤1中的写好的数据读取的方法以及ddt方法类；
2. 引入By方法类；
3. 搭建unittest框架；
4. 在setUp中打开谷歌浏览器，增加5秒的智能时间等待，将浏览器窗口最大化；
5. 在tearDown中退出浏览器；
6. 新建测试用例，通过ID属性定位用户名输入框，并输入用户名XTGLY；
7. 通过NAME属性定位密码输入框，并输入密码123456；
8. 查看登录页面中的登录按钮元素，通过TAG_NAME方法定位登录按钮，使用click()方法点击登录按钮进入系统首页；
9. 通过LINK_TEXT方法进行定位，使用click()方法点击“商品分类”按钮；
10. 通过XPATH方法点击“新增”按钮；
11. 通过CLASS_NAME方法定位商品分类名称输入框并使用数据驱动输入“商品分类名称”；
12. 通过XPATH方法定位并点击“保存”按钮；
13. 通过LINK_TEXT方法定位并获取提示信息文字，通过assertEqual断言方法来验证预期结果和实际结果是否一致，如果不一致使用get_screenshot_as_file对页面进行截图操作；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/725ae32d448815ff8738bbc34e4ab36a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6275236f961a9e4126312297d565fd4b/" rel="bookmark">
			java数据校验spring数据校验hibernate-validator一篇文章搞懂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、为什么后台也需要校验呢？
虽然我们在前台js进行了拦截，比如submit总体校验一遍，或者每个form控件blur失去焦点的时候进行了校验，但是
我们服务器接口可能被服务器通过代码（http-client)访问，或者其他的方式跳过浏览器js的校验逻辑，如果后台不进行
校验，那么可能会带来严重的安全问题：比如sql注入，XXS攻击等等安全漏洞。
2、使用Hibernate-validator校验。
这个校验框架可不是我们通常所说的Hibernate数据访问层（dao）框架，它只是一个实现JSR-303标准的一个校验框架。
所谓JSR-303其实就是一个校验api定义，而Hibernate-validator是其标准的实现。就像jdbc是java访问数据库的标准api，
而具体的实现由数据库厂商自己去实现。
废话不多说，直接写个demo：
（1）引入相应的jar包
&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.3.4.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt; &lt;/dependency&gt; 关于el的jar包引入是因为Hibernate-validator需要使用到el表达式的功能，至少上述版本是这样的，否则运行时会报错。
如果是在web环境，上述el表达式可以设置&lt;scope&gt;provided&lt;scope&gt;。
（2）写好我们需要校验的javaBean
PersonDto.java和Address.java
package normal.test.spring.bootstrap.validator; import org.hibernate.validator.constraints.Email; import org.hibernate.validator.constraints.Length; import javax.validation.Valid; import javax.validation.constraints.Max; import javax.validation.constraints.Min; import javax.validation.constraints.NotNull; public class PersonDto { @NotNull @Length(max = 10,min = 1,message = "姓名必须在1-10个字符之间") private String name; @Min(value = 18,message = "年龄不能小于18") @Max(value = 100,message = "年龄不能大于100") private Integer age; @Valid private Address address; @Email private String email; public void setEmail(String email) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6275236f961a9e4126312297d565fd4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeab80ecb0ccc5572b4ef8e99f43d59f/" rel="bookmark">
			【机器学习】图像语义分割常用指标Dice系数 敏感性 特异性 IOU及python代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 知识铺垫1. Dice系数和IOUIOUDice系数Dice和IOU的关系分析代码 2.敏感性（=Recall）、特异性和精确度（=precision=PPV)2.1 敏感性（召回率）和特异性2.2 敏感性和特异性之间的关系2.3 Recall和Precision之间的关系 3. F1 知识铺垫 二分类和多分类的评价指标的选择
首先，对于像素点，我们要知道，当预测的像素点类别和其真实类别不同或者相同时，我们可以用混淆矩阵来表示，如下图：
1. Dice系数和IOU 首先，dice和IOU都是衡量两个集合之间相似性的度量，在图像分割领域用来衡量网络分割结果与金标准mask（标签）之间的相似性。
(分割网络评价指标)dice系数和IOU之间的区别和联系
IOU IOU指标可以使用几何办法给出直观的解释，我们假设红色代表图片中的标签，黄色是分割的结果，那么他们重叠的蓝色部分就是TP（true Positive)真正例，也就是正样本被正确分类。
那么对应的红色就是预测为负但实际为正，因此是FN。
下面黄色部分，就是预测为正，但实际为负，因此是FP（false Positive)。
结合上述图片，我们可以给出IOU的公式（结合几何意义）
I O U = T P F N + T P + F P IOU = \frac{TP}{FN+TP+FP} IOU=FN+TP+FPTP​
I O U = 预测正确：蓝色 ( 红色 + 蓝色 + 黄色 ) IOU=\frac{预测正确：蓝色}{(红色+蓝色+黄色)} IOU=(红色+蓝色+黄色)预测正确：蓝色​
这位是对于一个类别来说的IOU公式，而mIOU公式是对所有类别求交并比的平均值。
m I O U = 1 k ∑ i = 1 k T P F N + T P + F P mIOU = \frac{1}{k}\sum_{i=1}^{k}\frac{TP}{FN+TP+FP} mIOU=k1​i=1∑k​FN+TP+FPTP​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeab80ecb0ccc5572b4ef8e99f43d59f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d5ef767252dabe05b65fe2800a6497/" rel="bookmark">
			形容词变副词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1:辅音+y 改y为i+ly happy-happily (y发ai音直接加ly dry-dryly)
2:元音+e 去e+ly
ture-turly due-duly nice-nicely wise-wisely
3:le去e+y
possible-possibly simple-simply
4:ll加ly
dull-dully(迟钝地) full-fully
5:ic加ally
basic-basically automatic-automatically
6:形副同型
hard fast early late high wide alone far
7:虽然ly结尾但是形容词不能修饰动词
friendly lively lovely likely lonely motherly manly
8：特殊
good-well
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84871420d8fce18f2212c00456648d94/" rel="bookmark">
			MPQ6533驱动程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MPQ6533驱动
驱动芯片主要有驱动作用，将输入的弱电信号放大成足够强，用于外部设备的强电信号。需要安培级的驱动电流一般是驱动电机或者电力电子设备等，根据用户产品具体用途才可能选择具体的芯片，比如耐压，稳态/暂态性能等等要求。
MPQ6533 是一款专为汽车直流电机驱动器应用设计的栅极驱动器 IC。它可以驱动6个 N 沟道功率 MOSFET，以驱动直流电机或其他负载。在电机控制中，MPQ6533用作预驱芯片与主芯片连接。
MPQ的管脚功能如图：
其中：
电源部分掠过；ENA-ENC为输入信号使能；INA-INC为输入信号；7-17的管脚为输出；CSO电流采样SDO-nSCS为SPI的四个管脚nFAULT为故障检测，故障时拉低 nSLEEP为休眠，拉低休眠，上拉使能 要完成MPQ的驱动函数编写，需要明白这块芯片的作用机理：
该芯片与主芯片之间通过SPI进行通信，也正是通过SPI，对该预驱芯片进行初始化MPQ6533作为驱动芯片，接收来自MCU的PWM信号，输出驱动信号 初始化部分：
初始化参数主要为：
OUT 地址为 0x00
CTRLA 地址为0x01
CTRLB 地址为0x02
CTRLC 地址为0x03
CTRLD 地址为0x04
对应的实际参数为：
有了这些参数和参数的寄存器地址，我们就可以编写初始化函数框架如下：
#define DATA_LEVEL_1 (0)
/*
....
*/
#define DATA_LEVEL_N (0)
enum data
{
data_level1 = 0,
datalevel2,
/*
......
*/
}
typedef struct
{
union
{
uint16 OUT;
struct
{
uint16 BENA : 1;
uint16 BINA : 1;
uint16 BENB : 1;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84871420d8fce18f2212c00456648d94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf1b327f122265a1ac61e0306ce0614a/" rel="bookmark">
			java&#43;springboot小型滑雪场门票售票系统idea
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		性能测试主要通过模拟系统运行环境来测试该系统是否能达到用户期待。性能测试的重要技术指标就是：系统运行速度、网络响应时间和支持并发节点数。
1）系统运行速度：得益于B/S架构，该系统能在不同配置电脑上运行并无明显卡顿，滞后，完全符合用户要求。
2）网络响应时间：网络响应时间主要包括网络最小响应时间、平均响应时间、最大响应时间三个参数。经过测试，在正常网络运营状态下，局域网内响应时间三参数为：1/2/5s，外网响应时间三参数为3/7/12s，符合用户需求，属于用户心理可承受范围。
3）支持并发节点数：经过模拟环境测试，本系统在并发节点达45个时，网络运营速度会发生较大波动，延迟时间10秒左右，符合用户需求。基于jsp技术设计并实现了滑雪售票系统。该系统基于B/S即所谓浏览器/服务器模式，应用springbootweb框架，选择MySQL作为后台数据库。系统主要包括个人中心、用户管理、票务信息管理、购票信息管理、技巧交流、系统管理等功能模块。
6.5 测试结果分析
经过对上述测试结果分析，本系统能够在不同电脑上使用运行，具备一定安全性，用户信息不易泄露，能够日后再增删功能，能够实现所有功能，产品运行性能良好，能达到毕业设计要求。
目录
摘 要 1
Abstract 1
1 绪论 1
1.1 课题背景 1
1.2 课题研究现状 1
1.3 初步设计方法与实施方案 2
1.4 本文研究内容 2
2 开发技术介绍 4
2.1关键技术 4
2.1.1 Eclipse 4
2.1.2 MySQL数据库 5
2.1.3 JSP技术 5
2.1.4框架设计springbootweb框架 5
3 系统分析 6
3.1 系统可行性分析 6
3.1.1 经济可行性 6
3.1.2 技术可行性 6
3.1.3 运行可行性 6
3.2 网站现状分析 6
3.3 功能需求分析 7
3.4 系统设计规则与运行环境 8
3.5系统流程分析 8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf1b327f122265a1ac61e0306ce0614a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de68fed689cf6a45eb316c12fbe090f3/" rel="bookmark">
			JS里给数组增加数据的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组里存放着所有数据，当有新数据储存时，需要给将新数据储新增在原数组中，再生成新的数组数据，方便后期调用使用。
增加数组的方式有5种：
第1种：直接给数组的下标通过赋值来增加（数组的下标起始值是0）；
例，先存在一个有3个数据的数组：
let arr=[1,2,3];
console.log(arr);　此时输出的结果是[ 1, 2, 3 ]
let arr=[1,2,3];
arr[3]=5;
console.log(arr);　此时的输出结果是[ 1, 2, 3, 5 ]；
第2种：通过 数组名[数组名.length] 来增加；
let arr=[1,2,3];
arr[arr.length]=5;
console.log(arr);　此时的输出结果是[ 1, 2, 3, 5 ]；
第3种：通过 数组名.push(参数) 来增加从数组最后一个数据开始增加，push可以带多个参，带几个参，数组最后就增加几个数据；
let arr=[1,2,3];
arr.push(5);
console.log(arr);　此时的输出结果是[ 1, 2, 3, 5 ]；
let arr=[1,2,3];
// arr.push(5);
arr.push(5,8,9)；
console.log(arr);　此时的输出结果是[ 1, 2, 3, 5, 8, 9 ]；
第4种：通过 数组名.unshift(参数)来增加从数组第1个数据开始的参数，unshift可以带多个参，带几个参，数组最开始就增加几个数据；
let arr=[1,2,3];
arr.unshift(5);
console.log(arr);　此时的输出结果是[ 5, 1, 2, 3 ]；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de68fed689cf6a45eb316c12fbe090f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea0628fcc449ea58fdbf0f92976b04b9/" rel="bookmark">
			Nginx实现自签名SSL证书生成与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Nginx实现自签名SSL证书生成与配置
1、名词介绍
2、生成私钥
3、生成公钥
4、生成解密的私钥key 5、签名生成证书
6、配置证书并验证
7、加密私钥的报错
一、Nginx实现自签名SSL证书生成与配置 1、名词介绍 ①key 私钥 = 明文--自己生成（genrsa ）
②csr 公钥 = 由私钥生成
③crt 证书 = 公钥 + 签名（自签名或者由CA签名）
④证书：server.crt文件就是证书
⑤签名：使用私钥key与公钥csr进行证书server.crt生成的过程称为签名
2、生成私钥 cd ~ #回到root用户的家目录下 openssl genrsa -des3 -out server.key 1024 #使用ssl生成私钥名为 server.key 3、生成公钥 openssl req -new -key server.key -out server.csr #基于创建的server.key私钥创建server.csr公钥 openssl req -text -in server.csr -noout #查看私钥加密的内容 4、生成解密的私钥key openssl rsa -in server.key -out server.key.unsecure #基于server.key私钥生成server.key.unsecure的解密私钥 5、签名生成证书 签名方法1：方法1需要输入密码，私钥密码为123456 openssl x509 -req -days 365 -in server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea0628fcc449ea58fdbf0f92976b04b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a74330c3a341d9023348865e598ff189/" rel="bookmark">
			猫咪绝地武士，ai绘画星球大战天行者，midjourney教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.a jedi cat training with his lightsaber in old jap
2.cute cat as jedi
3.cute cat dressed as Darth Vader on Tatooine
4.Samurai angry cat ready to fight with katana.
5.Samurai cat ready to fight with katana.
6.Star Wars scene artificial intelligence a night bl
7.Star Wars scene artificial intelligence a small bl
8.The Jedi cat sci-fi
国内Midjourney中文版支持最新的Midjourney V5版和Niji.journey V5版及视频转动漫功能
只需要输入下面的英文描述词即可，也可以通过百度翻译成中文描述词也行的，还不快试试！你也可以！
有不明白的欢迎留言评论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a045f9f14a1106e8e3d04dae76e6d9f/" rel="bookmark">
			Python实现word或pdf文件转png长图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python实现word/pdf文件转png长图 背景思路不足实现1. word转pdf2. pdf转图片3. 图片空白行删除 效果 背景 最近写项目周报要求转为长图片输出，本着“自己动手，丰衣足食”（抠门）的原则，就不购买xx会员了，自己动手做一个word转换图片的小工具~~
思路 先将Word文档转为pdf文件。读取pdf文件，逐页转为图片，保存为多个临时文件。读取临时图片文件，拼接输出一张图片文件。对长图中过多的空白行进行删除。 不足 word文件转pdf目前用的是win32com库，只能在windows系统使用。空白行的判断效率较低。 实现 1. word转pdf # -*- coding:utf-8 -*- """ 将word文档转换为pdf文件 """ from datetime import datetime from pathlib import Path import win32com.client # 将Word文档转换为PDF文件 def convert_to_pdf(input_file_path, output_file_path): # 目标文件若已存在，则先删除 Path(output_file_path).unlink(True) word = client.DispatchEx('Word.Application') try: doc = word.Documents.Open(input_file_path) doc.SaveAs2(output_file_path, FileFormat=17) doc.Close() except Exception as e: print("转pdf失败:%s" % e) finally: word.Quit() def word_2_pdf(word_name, new_pdf_name): word_path = Path(word_name).parent convert_to_pdf(word_name, new_pdf_name) return new_pdf_name if __name__ == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a045f9f14a1106e8e3d04dae76e6d9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21a900aad10a323e8768fb85df5a24c0/" rel="bookmark">
			java计算税收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题 : 国家推出新的个人所得税政策，起征点上调值5000元。也就是说税前工资扣除三险一金（三险一金数额假设是税前工资的10%）后如果不足5000元，则不交税。如果大于5000元，那么大于5000元的部分按梯度交税，具体梯度比例如下：
​ 0 ~ 3000元的部分，交税3% ​ 3000 ~ 12000元的部分，交税10%
​ 12000 ~ 25000的部分 ， 交税20% ​ 25000 ~ 35000的部分，交税25%
​ 35000 ~ 55000的部分，交税30% ​ 55000 ~ 80000的部分，交税35%
​ 超过80000的部分，交税45%
解:
class HomeWork6 { public static void main(String[] args) { // 收入 5000 以上考虑收税 税收 : 计算公式 收入 - 收入 * 0.1 (保险钱) 然后按档位缴费 // 0 ~ 3000元的部分，交税3% 3000 // // 3000 ~ 12000元的部分，交税10% 9000 // // 12000 ~ 25000的部分 ， 交税20% 13000 // // 25000 ~ 35000的部分，交税25% 10000 // // 35000 ~ 55000的部分，交税30% 20000 // // 55000 ~ 80000的部分，交税35% // 25000 // // 超过80000的部分，交税45% Scanner sr = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21a900aad10a323e8768fb85df5a24c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9301173c197d1c2a48d5997f3228880a/" rel="bookmark">
			深圳雷龙SD NAND的存储应用方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言: 很感谢深圳雷龙发展有限公司为博主提供的两片SD NAND的存储芯片，在这里博主记录一下自己的使用过程以及部分设计。
深入了解该产品： 拿到这个产品之后，我大致了解了下两款芯片的性能。CSNP4GCR01-AMW是一种基于NAND闪存和SD控制器的4Gb密度嵌入式存储；而CSNP32GCR01-AOW是一种基于NAND闪存和SD控制器的32Gb密度嵌入式存储。与原始NAND相比其具有嵌入式坏块管理和更强的嵌入式ECC。即使在异常断电，它仍然可以安全地保存数据。作为一个存储芯片，它确实做到了小巧，LGA-8的封装对比我之前用到过的TF卡，只占到了其面积的三分之一，这样对于一些嵌入式的设计就方便了很多。
雷龙官方还很贴心的提供了样品的测试板，在这款测试板上，我焊接了4GB的CSNP4GCR01-AMW上去，并且跑了一下分，对于一款小的存储芯片而言，实在难得。
（上图为测试板焊接图） 博主日前在设计基于H616与NB-IOT的嵌入式智能储物柜的时候考虑过存储方面的问题，当时在SD NAND和EMMC与TF卡中徘徊，以下是几个存储类型的对比。
经过多方对比，本着不需要频繁更换的原则，同时也为了更好的防水和成本考虑，最终决定使用雷龙公司的SD NAND 作为设计样品的存储部分。
此外，SD NAND还具有不用写驱动程序自带坏块管理的NAND FLASH（贴片式TF卡），不标准的SDIO接口，也同时兼容SPI/SD接口，10万次的SLC晶圆擦写寿命，通过一万次的随机掉电测试耐高低温，经过跑分测得，速度级别Class10。标准的SD2.0协议，普通的SD卡可以直接驱动，支持TF卡启动的SOC都可以用SD NAND，而且雷龙官方还贴心的提供了STM32参考例程和原厂技术支持，这对于刚上手的小白而言，十分友好。
设计理念： 使用H616作为主控CPU并搭配NB-IOT来向申请下来的云端传输数据，当WIFI正常时，储物数据每搁两小时向云端传输一次，当有人取出物品时再次向云端发送一次数据（不保留在SD NAND中）；一旦系统检测到WIFI出现问题，储物数据转而存储到SD NAND中，取物时输入的物品ID和取出时间一并放入SD NAND中（我也是看中了SD NAND与原始NAND相比其具有嵌入式坏块管理和更强的嵌入式ECC。即使在异常断电，它仍然可以安全地保存数据这一点）。
部分SD NAND的参考设计 根据官方数据手册提供的SD NAND参考设计，只占用8个GPIO，对于H616来说，确实很友好
这里为了不泄露他人的劳动成果，我也就不粘PCB设计了。
采用H616驱动SD NAND的示例代码 下面是关于H616驱动SD NAND的示例代码，这里记录一下自己当初的学习过程（注：这个代码不能直接拿过来就用，而是要根据自己的需求修改）
#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include "h616_sdio.h" // 定义SDIO引脚 #define SDIO_CMD_PIN 0 #define SDIO_CLK_PIN 1 #define SDIO_D0_PIN 2 #define SDIO_D1_PIN 3 #define SDIO_D2_PIN 4 #define SDIO_D3_PIN 5 // 定义NAND芯片命令 #define CMD_READ 0x00 #define CMD_WRITE 0x80 #define CMD_ERASE 0x60 #define CMD_STATUS 0x70 #define CMD_RESET 0xff // 定义NAND芯片状态 #define STATUS_READY 0x40 #define STATUS_ERROR 0x01 // 初始化SDIO控制器 void sdio_init() { // 设置SDIO引脚模式和速率 h616_sdio_set_pin_mode(SDIO_CMD_PIN, H616_SDIO_PIN_MODE_SDIO); h616_sdio_set_pin_mode(SDIO_CLK_PIN, H616_SDIO_PIN_MODE_SDIO); h616_sdio_set_pin_mode(SDIO_D0_PIN, H616_SDIO_PIN_MODE_SDIO); h616_sdio_set_pin_mode(SDIO_D1_PIN, H616_SDIO_PIN_MODE_SDIO); h616_sdio_set_pin_mode(SDIO_D2_PIN, H616_SDIO_PIN_MODE_SDIO); h616_sdio_set_pin_mode(SDIO_D3_PIN, H616_SDIO_PIN_MODE_SDIO); h616_sdio_set_clock(H616_SDIO_CLOCK_FREQ_25MHZ); // 初始化SDIO控制器 h616_sdio_init(); } // 发送NAND芯片命令 void nand_send_cmd(uint8_t cmd) { // 设置SDIO控制器传输模式和命令码 h616_sdio_set_transfer_mode(H616_SDIO_TRANSFER_MODE_WRITE); h616_sdio_set_command_code(cmd); // 发送命令 h616_sdio_send_command(); } // 发送NAND芯片地址 void nand_send_addr(uint32_t addr) { // 设置SDIO控制器传输模式和地址 h616_sdio_set_transfer_mode(H616_SDIO_TRANSFER_MODE_WRITE); h616_sdio_set_address(addr); // 发送地址 h616_sdio_send_address(); } // 读取NAND芯片数据 void nand_read_data(uint8_t *data, uint32_t size) { // 设置SDIO控制器传输模式 h616_sdio_set_transfer_mode(H616_SDIO_TRANSFER_MODE_READ); // 读取数据 h616_sdio_read_data(data, size); } // 写入NAND芯片数据 void nand_write_data(const uint8_t *data, uint32_t size) { // 设置SDIO控制器传输模式 h616_sdio_set_transfer_mode(H616_SDIO_TRANSFER_MODE_WRITE); // 写入数据 h616_sdio_write_data(data, size); } // 读取NAND芯片状态 uint8_t nand_read_status() { uint8_t status; // 发送读取状态命令 nand_send_cmd(CMD_STATUS); // 读取状态 nand_read_data(&amp;status, 1); return status; } // 等待NAND芯片准备就绪 void nand_wait_ready() { uint8_t status; // 循环读取状态，直到NAND芯片准备就绪 do { status = nand_read_status(); } while ((status &amp; STATUS_READY) == 0); } // 读取NAND芯片数据 void nand_read(uint32_t page, uint32_t column, uint8_t *data, uint32_t size) { // 发送读取命令和地址 nand_send_cmd(CMD_READ); nand_send_addr(column | (page &lt;&lt; 8)); // 等待NAND芯片准备就绪 nand_wait_ready(); // 读取数据 nand_read_data(data, size); } // 写入NAND芯片数据 void nand_write(uint32_t page, uint32_t column, const uint8_t *data, uint32_t size) { // 发送写入命令和地址 nand_send_cmd(CMD_WRITE); nand_send_addr(column | (page &lt;&lt; 8)); // 写入数据 nand_write_data(data, size); // 等待NAND芯片准备就绪 nand_wait_ready(); } // 擦除NAND芯片块 void nand_erase(uint32_t block) { // 发送擦除命令和地址 nand_send_cmd(CMD_ERASE); nand_send_addr(block &lt;&lt; 8); // 等待NAND芯片准备就绪 nand_wait_ready(); } // 复位NAND芯片 void nand_reset() { // 发送复位命令 nand_send_cmd(CMD_RESET); // 等待NAND芯片准备就绪 nand_wait_ready(); } // 示例程序入口 int main() { uint8_t data[2048]; memset(data, 0x5a, sizeof(data)); // 初始化SDIO控制器 sdio_init(); // 复位NAND芯片 nand_reset(); // 擦除第0块 nand_erase(0); // 写入第0页 nand_write(0, 0, data, sizeof(data)); // 读取第0页 nand_read(0, 0, data, sizeof(data)); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0159c01c66ac2b861b7bfb47dfe77b82/" rel="bookmark">
			高斯分布&amp;正态分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 高斯分布定义1 高斯分布意义2 高斯分布的概率密度函数推导 高斯分布又叫正态分布，是统计学中最重要的连续概率分布。有的地方将正态分布也称为常态分布，什么意思呢？从字面上看确实不太直观，如果我们各取一字变为“正常分布”，就清晰明了了。即我们生活中常见的事物和现象都呈现出中间密集、两边稀疏的特征，如身高、体重、家庭收入等，拿身高来说，服从高斯分布意味着大多数人的身高都会在人群的平均身高上下波动，特别高和特别矮都比较少见。这是为什么呢？因为我们研究的对象的特征往往是趋同的，即存在一个基准；但是由于个体变异的存在，这些特征又不是完全一致，因此会以一定的幅度在基准的上下波动，从而形成中间密集、两边稀疏的特征。 研究表明，在物理科学和经济学中，大量数据的分布通常是服从高斯分布，所以当我们对数据潜在分布模式不清楚时，可以优先用高斯分布近似或精确描述。
高斯分布属于“连续型随机变量分布”的一类，连续型随机变量是研究“区间概率”，而不是“点概率”。还是拿身高举例，比如某小学学校学生的身高，理论上它可以取任意正数，所以我们把它当做一个连续型随机变量看待。如果我们想计算P(X=1.2)=? 即身高恰好等于1.2的概率是多少？这就是“点概率”；如果随机变量Y是[0, 1]这个区间上的任意一点，那么Y的取值是多少个呢？显然，无数多个，因此Y取某一值的概率是1除以无数，即可以看做是0。因此，连续型随机变量取任意某个确定的值的概率均为0。 所以，低于连续型随机变量，我们一般不去研究某个特定值的概率，即点概率，而是去研究某一区间的概率，即区间概率。
高斯分布的作用在于给定某个值在特定范围内的概率，它是一种研究误差服从一个什么样的分布。
0 高斯分布定义 高斯分布相关概念在高中数学学到过，估计大家都忘了差不多，先稍微回顾下。
假设随机变量X服从高斯分布，即
X ∼ N ( μ , σ 2 ) X\sim N(\mu ,\sigma^{2} ) X∼N(μ,σ2)
其概率密度函数为：
f ( x ) = 1 σ 2 π e − 1 2 ( x − μ σ ) 2 f(x)=\frac{1}{\sigma \sqrt{2\pi }}e^{-\frac{1}{2}(\frac{x-\mu }{\sigma })^{2}}\\ f(x)=σ2π ​1​e−21​(σx−μ​)2
其中， σ 为总体标准差， μ 为总体均值， π 为 3.14159 ， e 为 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0159c01c66ac2b861b7bfb47dfe77b82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c75aaef9da85496dce94718a3114892d/" rel="bookmark">
			HexView工具使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HexView简介 HexView是Vector开发的一款查看和编辑16进制文件的PC端工具。它可以显示不同文件格式的内容，主要是Intel-HEX，摩托罗拉S记录二进制文件或其他汽车制造商特定的文件格式。此外，它可以执行多种数据处理操作，如校验和计算、签名生成、数据加密/解密或压缩/解压缩，还可以重新排列文件的数据内容。Hexview的某些功能可以通过图形用户界面使用。但是，通过命令行界面也可以使用强大的功能。有些功能甚至只能通过命令行访问。
批处理示例 hex转s19 hexview.exe /s input.hex /XS:32 /e:error.txt -o output.s19 hex转bin hexview.exe /s input.hex /XB /e:error.txt -o output.s19 填充0xFFFF0-0xFFFF3地址为0xAA 0xBB 0xCC 0xDD hexview.exe /s input.s19 /FP:0xAA,0xBB,0xCC,0xDD /FR:0xFFFF0-0xFFFF3 /e:error.txt /XS:32 –o output.s19 计算0x00000-0x2FFFF范围的CMAC with AES-128，放置在0x2FFD0的位置并输出到output_cmac.txt文件中。cmac_key_file文件存放了16个字节（空格隔开ASCII字符表示）的key。 hexview.exe /s input.s19 CR:0x30000-0xFFFFF /dp44:@0x2FFD0:cmac_key_file;output_cmac.txt /FP:0xFF /FR:0x00000-0x2FFFF /e:error.err /XS:32 –o ouput.s19 使用HexView将指定hex文件的0x0000到0xFFF和0x5000到0xFFFF地址区间的数据删除 @echo off set localdir=%~d0%~p0 set hexview="D:\HexView-V1.12.05\hexview.exe" set input="%localdir%\dist\app.build.hex" set output="%localdir%\post-build\app.pb.hex" :: CUT OUT %hexview% /s %input% /CR:0x0000-0x0FFF:0x5000-0xFFFF /XI:16 -o %output% /E:%localdir%hex_error.err 参考 ReferenceManual_HexView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c75aaef9da85496dce94718a3114892d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4965d4bda750db1e9bdb926be9bc2fc3/" rel="bookmark">
			在进行yolov5算法改进之添加CBAM注意力机制时，报错TypeError: __init__() takes 3 positional arguments but 4 were given
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行yolov5算法改进之添加CBAM注意力机制时，报错TypeError: __init__() takes 3 positional arguments but 4 were given。
报错位置有两处，一是yolo.py的185行处
二是yolo.py的346行处
解决办法：
在添加CBAM时，我在标记位置也加上了CBAM，删掉之后，问题就解决了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/794859bf3c6ffb53cd3181884e2bb2e2/" rel="bookmark">
			医学图像配准论文学习——基于深度学习的分割方法对腹部CT进行高效的两步多器官配准（2021）；基于深度学习的检测在腹部CT图像上靶器官非刚性配准（2021）；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同一作者的两篇配准文章，考虑到是比较久之前的论文，将它们放到同一篇博客中
第一篇论文链接：
基于深度学习的分割法对腹部CT进行高效的两步多器官配准 - ScienceDirect
一、摘要 三维（3D）腹部计算机断层扫描（CT）的配准对于计算机辅助疾病的诊断和治疗至关重要，但腹部的非刚性呼吸运动（non-rigid respiratory movements ）增加了其难度。该文提出一种用于腹部CT扫描的两步多器官自动配准方法。首先，将轻量级挤压激励（squeeze-and-excitation ，SE）注意力块和基于全连接条件随机场（conditional random field，CRF）的后处理集成到基于全卷积网络（FCN）的模型中，对肝、肾、脾等腹部多器官获得更准确的分割结果;然后，结合非刚性局部相关系数（LCC）相似度量和各向同性全变正则化来记录多器官区域，从而减少计算时间，避免变形场过平滑问题。
二、方法 考虑到图像内容的完整性，基于体素的方法优于基于表面的方法。然而，基于体素的方法的性能会受到目标器官周围噪声和强度的影响，导致计算负担沉重，配准结果不理想。因此，我们提出了一种基于分段的策略，以在基于体素和基于表面的方法之间进行折衷。它可以保留目标器官的关键图像内容，并以更少的计算负担提高配准性能。所提出的方法由两部分组成：腹部多器官分割和配准。首先，采用改进的基于FCN的模型从固定和移动腹部CT扫描中进行初始多器官分割，然后使用完全连接的CRF来微调分割掩码并提取多器官区域。然后，将基于强度的相似度量和空间正则化项集成到配准函数中，以找到最优变换场并注册成对的腹部多器官区域;
1.基于FCN的腹部CT多器官分割 本文提出了一种改进的基于FCN的三维腹部多器官分割模型。所提模型的主要模块包括卷积层、反卷积层、密集块和注意力块。首先，从V形网络模型中学习卷积层和解卷积层的整体结构。在框架的左侧，对输入图像进行卷积运算，得到72^个特征图，用于减少计算。然后，将密集块、注意力块和卷积层级联以生成三种分辨率的特征图（72^3, 36^3和 18^3），其中卷积层在每个分辨率的末端执行，以减少特征图的数量。在框架的右侧，对每种分辨率的特征图应用基于双线性插值的反卷积操作，然后通过卷积连接三种分辨率的特征图。最后，将生成的分割结果上采样至输入图像的大小。该模型中的 3D 卷积操作包括用于特征学习的卷积内核、用于减少内部协变量偏移然后防止梯度扩散的批量归一化 ，以及参数校正线性单元 （pReLU） 的激活函数 ，用于非线性表示。在卷积过程中进一步采用分批空间dropout策略解决该模型的过拟合问题。此外，密集块的卷积层通过前馈方式相互密集连接，其中不同层的特征图可以在仅存储一次的情况下重复使用。这种前馈方式可以提高密集块的内存效率，性能更好。 .改进的基于FCN的腹部CT多器官分割模型. 诸如全局上下文（global context，GC）网络和挤压和激励（squeeze-and-excitation，SE）网络之类的注意力块在深度神经网络中集成为高效，轻量级和多功能块，可以提高分割精度。GC 块具有有效建模全局上下文的能力，SE 块利用卷积特征通道之间的独立性来重新调整权重以突出显示重要特征和削弱不重要特征。为了从腹部CT图像中精确提取ROI，我们尝试将SE或GC块集成到所提出的基于FCN的框架中，分别称为SE_DVnet模型和GC_DVnet模型。（a）所示的SE模块由三个模块组成：（a）将整个空间特征编码为通道上的全局特征的挤压模块，（b）学习每个特征通道之间的关系并获得这些通道权重的激励模块，以及（c）融合模块将加权通道全局特征乘以原始空间特征。所示的GC块主要分为三个模块：（a）聚合所有位置特征形成全局上下文特征的上下文建模模块，（b）捕获特征通道间依赖关系的转换模块，以及（c）添加从上述两个模块获得的特征的融合模块。如图所示，X×Y表示空间维度，C通道数，以及r作为超参数的减速比率。
注：挤压-激励（Squeeze-and-Excitation，简称SE）网络是一种用于提高卷积神经网络性能的注意力机制。它通过对每个通道的特征进行重新加权来增强网络对输入图像中重要特征的响应。SE网络包括两个部分：挤压（Squeeze）和激励（Excitation）。挤压操作通过全局平均池化来获取每个通道的全局信息，然后激励操作通过全连接层来学习每个通道之间的关系并计算每个通道的权重。最后，这些权重被用来对原始特征图进行重新加权。在本文中，作者将SE网络作为注意力模块集成到改进的基于FCN的模型中，以提高模型的特征学习能力并获得更精确的目标器官轮廓细节。
基于FCN的模型中的反卷积可能会导致轮廓特征的丢失，从而导致目标分类边界的模糊。为了优化分类图像的粗糙度和不确定性，捕捉分割区域的精细细节，并获得更详细的分割边界，本研究提出了一种完全连接的CRF作为后处理策略。此模块的能量函数为：
CRF（条件随机场，Conditional Random Field）是一种用于序列标注和分割任务的概率图模型。它能够对输入序列中的每个元素进行分类，同时考虑相邻元素之间的依赖关系。CRF模型通常由两部分组成：（1）特征函数，用于描述输入序列中每个元素的特征；（2）权重参数，用于控制特征函数对最终预测结果的贡献。在训练过程中，CRF模型通过最大化训练数据的对数似然来学习权重参数。在预测过程中，CRF模型使用维特比算法来寻找最优的标注序列。
完全连接的CRF是指每个像素都与其他像素相连，这样可以更好地捕捉像素之间的关系。在这篇论文中，完全连接的CRF被用作后处理策略，以进一步提高分割掩模的精度。
CRF模型的能量函数是一个关于标签变量的函数，它是由一组特征函数的加权和构成的，每个特征函数都定义在一个局部的标签配置上。这些特征函数可以是任意的函数，但通常是指示函数或者高斯核函数。
高斯双核是一种用于图像处理的方法，用于边缘检测和图像分割。它由两部分组成：高斯核和高斯拉普拉斯（LoG）核。高斯核用于平滑图像，而LoG核用于检测边缘。高斯核是一种低通滤波器，用于从图像中去除高频噪声。LoG内核是一个带通滤波器，它在抑制噪声的同时增强边缘。这两个内核的组合允许精确的边缘检测和图像分割。
2.基于强度的多器官腹部CT配准 相似度度量
对于非刚性配准，通过优化两幅图像之间的相似性度量来计算变形场，捕获的变形质量在很大程度上取决于度量的选择。差分平方和（SSD）、相关系数（CC）、顺序相似性检测算法（SSDA）和互信息（MI）是基于强度的配准方法的代表性相似性指标。然而，腹部医学图像的偏差通常是局部变化，在这种情况下，上述与全局计算的相似性指标可能会导致对变形场的错误估计。相较于 SSD 和 MI 来说，LCC是一个相当友好的折衷方案，它们的隐藏参数数量较少，但估计可靠。在本文中，将固定图像和运动图像分别划分为以每个体素为中心的斑块，并通过LCC计算这些图像之间的相关系数：
空间正则化
使用各向同性总变分正则化避免过平滑问题:
优化器
结合上述相似度量和空间正则化项，对腹部多器官配准的优化问题进行了研究。我们没有使用流行的梯度下降方法，而是使用乘数交替方向法 （ADMM）来最小化项，并使用搜索空间参数化（一阶 B 样条）优化配准框架以减小维度。这种优化方法可以避免物理上不可信的变换，并且对次优局部最小值具有更大的灵活性。 实验结果 总结 本文提出了一种用于3D腹部CT图像的两步非刚性配准策略。在第一步中，使用改进的基于FCN的模型从CT图像中分割肝脏、肾脏和脾脏。然后，在第二步中，使用结合局部相关系数（LCC）相似性度量和各向同性总变差正则化项的方法来注册成对的腹部多器官区域。因此，该方法仅配准分割后的目标器官。得到的变形场用来对移动图像进行变形，以便将其与目标图像对齐。
第二篇论文链接：
Target organ non-rigid registration on abdominal CT images via deep-learning based detection - ScienceDirect
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/794859bf3c6ffb53cd3181884e2bb2e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40277a6f37477034bc8d5ee8d737a556/" rel="bookmark">
			寄快递邮寄发件上门邮寄小程序源码&#43;前端&#43;后端&#43;安装说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 新快递小程序快递代发快递代寄寄件小程序可以对接易达云洋一级总代 快递小程序，接入云洋/易达物流接口，支持选择快递公司，三通一达，极兔，德邦等，功能成熟 如何收益: 1.对接第三方平台成本大约4元左右一单，后台可 设置一键加价百分比或者加价金额来提高定价， 客户下单后可以全自动同步到第三方API内 2.小程序内会员功能，可设置不同会员时间 定 价，下级反润百分比，定多少价格自己净赚 3.接入腾讯流量主广告，广告收益展示 点击均有 广告费，结算是腾讯给你打款你的卡 快递行业，2022年业务量将达到6亿件，目前大 多地区发件首重:省内8元，全国10元甚至更 高，目前对接物流易达接口和云洋接口，成本价 全国发件仅需5元起，我们增加2元利润，然后在 给分销员0.5-1元，每单可以挣1-1.5元，而且不需要我们去取件，系统会自动派到最近的快递超 市，进行取件。 首页 快递小程序收益: 1.快递差价收益 2.分销返佣收益 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c4e04cdb5ed8506231566126712ce1c/" rel="bookmark">
			shell作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，编写函数，实现打印绿色OK和红色FAILED
判断是否有参数，存在为OK，不存在为FAILED
print () { if [ "$a" ] == "" ];then echo -e "\e[1;31m FAILED \e[0m" else echo -e "\e[1;32m OK \e[0m" fi } read -p "请输入参数" a	print $a 2，编写函数，实现判断是否无位置参数，如无参数，提示错误
print () { if [ "$*" == "" ];then echo "error" else echo "$*" fi } read -p "请输入参数" a	print $a 3，编写函数实现两个数字做为参数，返回最大值
print () { if [ $a -gt $b ];then echo"$a" elif [ $a -lt $b ];then echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c4e04cdb5ed8506231566126712ce1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fdb2b726e4998d835ec71522f4d7a2e/" rel="bookmark">
			Filter 过滤器--基本原理--Filter 过滤器生命周期--过滤器链--注意事项和细节--全部应用实例--综合代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Filter 过滤器
Filter 过滤器说明
过滤器介绍
4. 应用场景
Filter 过滤器基本原理
代码示例
login.jsp
LoginCLServlet.java
admin.jsp
ManageFilter.java
xml配置
Filter 过滤器 url-pattern
Filter 过滤器生命周期
● Filter 生命周期图
FilterConfig
● FilterConfig 说明
应用实例
WyxFilterConfig web.xml
FilterChain 过滤器链
基本原理示意图
应用实例 AFilter.java
BFilter.java
hi.jsp
xml
FilterChain 注意事项和细节
6. 小结：
综合代码示例
运行效果图
topic.jsp
TopicServlet.java
配置过滤器
showTopic.jsp
Filter 过滤器 Filter 过滤器说明 为啥要过滤器-需求示意图
过滤器介绍 1. Filter 过滤器它是 JavaWeb 的三大组件之一(Servlet 程序、Listener 监听器、Filter 过滤器)
2. Filter 过滤器是 JavaEE 的规范，是接口
3. Filter 过滤器它的作用是：拦截请求，过滤响应。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fdb2b726e4998d835ec71522f4d7a2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b6b74d7626622cb0e430856e4d04ff/" rel="bookmark">
			Linux下的压缩解压缩命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux zip命令
zip -r myfile.zip ./*
将当前目录下的所有文件和文件夹全部压缩成myfile.zip文件,－r表示递归压缩子目录下所有文件.
2.unzip
unzip -o -d /home/sunny myfile.zip
把myfile.zip文件解压到 /home/sunny/
-o:不提示的情况下覆盖文件；
-d:-d /home/sunny 指明将文件解压缩到/home/sunny目录下；
3.其他
zip -d myfile.zip smart.txt
删除压缩文件中smart.txt文件
zip -m myfile.zip ./rpm_info.txt
向压缩文件中myfile.zip中添加rpm_info.txt文件
-------------------------------------------------------------------------------
要使用 zip 来压缩文件，在 shell 提示下键入下面的命令：
zip -r filename.zip filesdir
在这个例子里，filename.zip 代表你创建的文件，filesdir 代表你想放置新 zip 文件的目录。-r 选项指定你想递归地（recursively）包括所有包括在 filesdir 目录中的文件。
要抽取 zip 文件的内容，键入以下命令：
unzip filename.zip
你可以使用 zip 命令同时处理多个文件和目录，方法是将它们逐一列出，并用空格间隔：
zip -r filename.zip file1 file2 file3 /usr/work/school
上面的命令把 file1、file2、 file3、以及 /usr/work/school 目录的内容（假设这个目录存在）压缩起来，然后放入 filename.zip 文件中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6b6b74d7626622cb0e430856e4d04ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d8cb8aead8c792938ba9e6bf0257471/" rel="bookmark">
			SpringBoot基础篇知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot基础篇知识点 一、导学二、入门案例2.1、idea联网版2.2、官网创建版2.3、阿里云版2.4、手工制作版 三、隐藏文件或文件夹(联网创建比手动创建多出来git等文件)四、入门案例解析4.1、parent4.2、starter4.3、引导类4.4、辅助功能(内嵌Tomcat)4.5、Rest风格简介4.6、Restful入门案例4.7、Restful快速开发 五、基础配置5.1、属性配置5.1.1 配置方式5.1.2 基础配置 5.2、配置文件分类5.2.1、 属性配置提示消失解决方案 5.3、yaml文件5.4、yaml数据读取5.4.1、读取yaml全部属性数据5.4.2、读取yaml引用类型属性数据 六、整合第三方技术6.1、整合Junit6.2、整合Mybatis6.2.1 常见问题 6.3、整合Mybatis-Plus6.4、整合Druid 7、SSMybatis-Plus整合案例制作分析7.1 模块创建7.2 实体类快速开发(lombok)7.3 数据层标准开发（基础CRUD)7.4 开启Mybatis-Plus运行日志7.5 分页7.6 数据层标佳开发(条件查询)7.7 业务层标准开发(基础CRUD)7.8 业务层快速开发(基于MyBatisPlus构建)7.9 表现层标准开发7.10 表现层数据—致性处理(R对象)7.11 前后端调用(axios发送异步请求)7.12 列表功能7.13 添加功能7.14 删除功能7.15 修改功能(加载数据)7.16 修改功能7.17 异常消息处理7.18 分页7.19 分页功能维护（删除BUG)7.20 条件查询7.21 基础篇完结 8 部分知识点补充8.1 get和post详解8.2 ElementUI中＜el-form＞标签中 ref、:model、:rules 的作用8.3 axios和ajax区别 一、导学 官网：https://spring.io/projects/spring-boot
二、入门案例 2.1、idea联网版 https://www.bilibili.com/video/BV15b4y1a7yG/?p=3&amp;spm_id_from=pageDriver&amp;vd_source=5061eb5d9c29eda75a5e1981cbcb4d12
2.2、官网创建版 https://www.bilibili.com/video/BV15b4y1a7yG/?p=4&amp;spm_id_from=pageDriver&amp;vd_source=5061eb5d9c29eda75a5e1981cbcb4d12
2.3、阿里云版 https://www.bilibili.com/video/BV15b4y1a7yG/?p=5&amp;spm_id_from=pageDriver&amp;vd_source=5061eb5d9c29eda75a5e1981cbcb4d12
2.4、手工制作版 https://www.bilibili.com/video/BV15b4y1a7yG/?p=6&amp;spm_id_from=pageDriver&amp;vd_source=5061eb5d9c29eda75a5e1981cbcb4d12
三、隐藏文件或文件夹(联网创建比手动创建多出来git等文件) 四、入门案例解析 4.1、parent https://www.bilibili.com/video/BV15b4y1a7yG?p=8&amp;vd_source=5061eb5d9c29eda75a5e1981cbcb4d12
4.2、starter 4.3、引导类 https://www.bilibili.com/video/BV15b4y1a7yG?p=10&amp;spm_id_from=pageDriver&amp;vd_source=5061eb5d9c29eda75a5e1981cbcb4d12
4.4、辅助功能(内嵌Tomcat) 4.5、Rest风格简介 4.6、Restful入门案例 https://www.bilibili.com/video/BV15b4y1a7yG?p=13&amp;spm_id_from=pageDriver&amp;vd_source=5061eb5d9c29eda75a5e1981cbcb4d12
在使用springmvc框架的时候，在处理json的时候需要用到spring框架特有的注解@ResponseBody或者@RestController注解， 这两个注解都会处理返回的数据格式，使用了该类型注解后返回的不再是视图，不会进行转跳，而是返回json或xml数据格式，输出在 页面上 。
那么，这两个注解在使用上有什么区别呢？
@ResponseBody，（1）一般是使用在单独的方法上的，需要哪个方法返回json数据格式，就在哪个方法上使用，具有针对性。（2）一般是使用在参数上，将json格式的数据转为java对象，并注入对应参数中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d8cb8aead8c792938ba9e6bf0257471/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03da8e6151642dfef80e8afc29721112/" rel="bookmark">
			【计网 从头自己构建协议】一、libpcap 介绍 &amp; 手撕以太网帧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇：IndexError: list index out of range
下一篇：[【计网 从头自己构建协议】二、收发 ARP 请求帧与响应帧]
介绍 理论的学习总是枯燥的，想要加深对理论的理解，最好的方法就是自己实践一遍。
想要亲手实现各种协议，就必须能够接触底层 API。可惜的是，底层的 API 要么是在驱动里，要么是在系统里，都不对外开放，一般只能接触到运输层的 TCP/UDP。我们必须借助第三方库才能实现对底层操控。
libpcap 就是这样一个库，它帮我们实现了底层驱动，并将控制权向上开放，提供了发送和监听数据包的功能。著名的网络分析工具 Wireshark 就是基于这个库实现的。
libpcap 是 Linux 上的库，对应的 Windows 版本叫做 winpcap，不过这个库已经停止开发了，只支持到 Windows 8，没法运行在 Windows 10 上。npcap 在 winpcap 的基础上继续开发，添加了对新版 Windows 的支持和其他的功能。
我们下面就使用 npcap 这个库。
安装 推荐你直接安装 Wireshark，在安装 Wireshark 的同时会一并安装 npcap。所以如果你已经装了 Wireshark ，就不需要再装 npcap 本体了。
除了本体之外，我们还需要开发用的头文件和库文件。
去 npcap 官网下载页面，找到“Downloading and Installing Npcap Free Edition”，把 installer（如果你没装 Wireshark） 和 SDK 都下载下来。
installer 是 npcap 本体，直接双击，一路 next 即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03da8e6151642dfef80e8afc29721112/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/636fb338cd4f5ec04052b67e2cec3739/" rel="bookmark">
			python实现OCR的多种方法(安装部署以及应用实例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于python实现OCR的五种方法 1.pytesseract1.1简介1.2安装部署1.3应用举例 2.PaddleOCR2.1简介2.2安装部署2.3应用举例 3.easyocr3.1简介3.2安装部署3.3应用举例 4.muggle_ocr4.1简介4.2安装部署4.3应用举例 5.dddd_ocr5.1简介5.2安装部署5.3应用举例 1.pytesseract 1.1简介 Tesseract是一款开源的OCR（Optical Character Recognition，光学字符识别）引擎，最初由HP实验室开发，在2005年后由Google接手并进一步开发和完善。Tesseract支持多种语言文字的检测和识别，包括中文、英语、德语、法语、意大利语等多种主要语言，同时也支持针对特定场景或应用的领域OCR开发。
Tesseract基于机器学习技术，使用了多层神经网络以及支持向量机（SVM）等算法进行文字特征提取和识别。同时，Tesseract通过图像预处理、二值化、斑点去除和边框检测等多个环节优化页面处理流程，并且提供了多种字体、大小、旋转角度和噪声等挑战场景下的训练数据集，使得识别精度可以获得不错的性能表现。
除了提供C++ API之外，Tesseract还为多种编程语言提供了API的封装，如Python、Java、C#等，方便用户快速上手开发应用，可以广泛应用于扫描文档、电子书库入库、自动化办公、图片文字识别搜索等各个领域。
1.2安装部署 pytesseract需要配合安装在本地的tesseract-ocr.exe文件一起使用。具体步骤如下：
python终端利用pip安装pytesseract： pip install pytesseract -i https://pypi.tuna.tsinghua.edu.cn/simple/ 由于pip默认从国外的源下载包库，速度会非常缓慢，因此可以采用国内的镜像站下载会更加快捷，此处使用的是清华的镜像站，还可以换成其他几个镜像站：
清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ 下载tesseract-ocr.exe。可以从github上下载最新版本：
github传送门
github下载可能速度较慢，这里博主已经提前下载好了：可从百度云获取~
百度云传送门(提取码：qgh2)
安装步骤： 选择安装语言：直接默认英语-OK
Next
Agree
由于默认的识别语言是英语，这里我们要在Additional script data中勾选中文包，才可以OCR识别中文。(注：这里的vertical指的是识别竖向文本)
安装完成之后就可以在python当中进行实践啦~ 1.3应用举例 下面是python应用Tesseract进行文字识别的代码实例：
import pytesseract from PIL import Image #英文识别：将路径改为自己要识别的图片路径即可 text1 = pytesseract.image_to_string(Image.open(r"C:\Users\1.png"), lang='eng') print("英文模式识别结果：",text1) print("-------------") #简体中文识别： text2 = pytesseract.image_to_string(Image.open(r"C:\Users\1.png"), lang='chi_sim') print("中文模式识别结果：",text2) print("-------------") #简体中文与英文混合： text3 = pytesseract.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/636fb338cd4f5ec04052b67e2cec3739/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/920477fc8291aa1148774c46e9e2e3fa/" rel="bookmark">
			MIT协议是干什么的？底层原理是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MIT协议是一种开源软件许可协议，它允许软件的自由再分发和修改。它起源于麻省理工学院（MIT）的计算机科学实验室，在1988年发布，也因此得名。MIT协议通常被认为是BSD许可证的变体之一，也就是说，它们都属于“宽松许可证”的范畴，即许可证条件较为宽松。
根据MIT协议，软件的使用者可以自由地使用、复制、修改、合并、发布、分发、再授权软件及其衍生品，但必须在软件和文档中包含版权声明和许可声明。MIT协议还要求软件的使用者对软件的任何修改和衍生品进行说明，并在使用时遵循MIT协议的规定。
MIT协议的底层原理是通过在代码中嵌入版权声明和许可声明来确保代码的自由再分发和修改。这些声明明确地告诉其他人可以自由地使用、修改、分发和销售软件的副本，同时还需要在代码中保留原作者的版权声明。这样可以确保软件在使用和分发时不会侵犯原作者的权利，同时又可以促进代码的共享和改进。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b437bc594ddd3ad09bbf85a197e76866/" rel="bookmark">
			Delphi 内存分配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给字符指针(PChar、PWideChar、PAnsiChar)分配内存, 最佳选择是: StrAlloc.
StrAlloc 虽然最终也是调用了 GetMem, 但 StrAlloc 会在指针前面添加 Delphi 需要的 4 个管理字节(记录长度).
StrAlloc 分配的内存, 用 StrDispose 释放, 用 StrBufSize 获取大小.
用 FreeMem 释放可以吗? 这样会少释放 4 个字节.
这种类型的指针一般用于 API 函数的参数, 譬如获取窗口标题:
var p: PChar; begin p := StrAlloc(256); GetWindowText(Handle, p, StrBufSize(p)); ShowMessage(p); {Form1} StrDispose(p); end; 还有一对非常重要的相关函数: GlobalAllocPtr、GlobalFreePtr; 它们的功能是上面这些都不可替代的!
GlobalAllocPtr 和 GlobalFreePtr 是对系统函数: GlobalAlloc、GlobalFree 的简化, 之所以说它们重要, 只是因为它们可以跨进程操作; 不过 GlobalAllocPtr 是给无类型指针(Pointer)分配内存, 当然就不仅仅用于字符指针了.
New 是给已知大小的指针分配内存;
GetMem 主要是给无类型指针分配内存;
尽量使用 GetMemory 来代替 GetMem.
关于 FreeMemory 与 FreeMem 的区别:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b437bc594ddd3ad09bbf85a197e76866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0982029d4fe8b972813fe1aa31b9e67e/" rel="bookmark">
			Oracle中查询重复记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.使用GROUP BY和HAVING语句
2.使用窗口函数ROW_NUMBER()
3.使用自连接查询
在Oracle中查询重复记录的方法有以下几种：
1.使用GROUP BY和HAVING语句 语法如下：
SELECT column1, column2, ..., COUNT(*) as count FROM table_name GROUP BY column1, column2, ... HAVING COUNT(*) &gt; 1; 其中，column1、column2等为需要查询的字段，table_name为需要查询的表名。使用GROUP BY按照指定字段进行分组，使用HAVING筛选出数量大于1的分组，即为重复记录。
举例说明：
假设有一张表叫做“employees”，其中包含字段“id”、“name”和“age”。
查询重复记录的语句如下：
SELECT name, age, COUNT(*) as count FROM employees GROUP BY name, age HAVING COUNT(*) &gt; 1; 解释：
1.首先使用GROUP BY语句按照“name”和“age”字段对记录进行分组。
2.然后使用COUNT(*)函数计算每个分组中的记录数量。
3.最后使用HAVING语句筛选出数量大于1的分组，即为重复记录。
这样就可以查询出所有重复的记录，同时也可以得到重复记录的数量。
2.使用窗口函数ROW_NUMBER() 语法如下：
SELECT * FROM ( SELECT *, ROW_NUMBER() OVER (PARTITION BY column1, column2, ... ORDER BY column1) as row_num FROM table_name ) t WHERE t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0982029d4fe8b972813fe1aa31b9e67e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4702457ef14e936c62dc233a5fcdac3a/" rel="bookmark">
			springboot和springmvc区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot和Spring MVC都是Spring框架的一部分，但是它们的目的和使用场景有所不同。
Spring Boot是一个快速构建应用程序的框架，它提供了许多默认配置和自动化的设置，可以让开发人员更快地构建应用程序。Spring Boot还提供了一些内置的功能，如Web服务器、数据库连接和日志记录等，让开发人员可以更轻松地构建应用程序。
Spring MVC是一个Web框架，它可以帮助开发人员构建Web应用程序。它采用的是模型-视图-控制器（MVC）的设计模式，可以帮助开发人员更好地组织和管理Web应用程序的结构和逻辑。Spring MVC提供了许多功能和插件，如控制器、视图解析器和数据绑定等，可以帮助开发人员更轻松地处理HTTP请求和响应。
因此，Spring Boot适用于快速构建应用程序，而Spring MVC适用于构建Web应用程序。两者可以一起使用，以实现更高效、更快速的应用程序开发。
Spring Boot框架包含了Spring MVC框架。Spring Boot是Spring框架的扩展，它提供了一些自动配置和默认设置，可以帮助开发人员更快地构建应用程序，其中包括Web应用程序。Spring MVC是一个Web框架，它采用的是模型-视图-控制器（MVC）的设计模式，可以帮助开发人员更好地组织和管理Web应用程序的结构和逻辑。因此，Spring Boot框架中包含了Spring MVC框架，可以让开发人员更轻松地构建Web应用程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16e08881cfce5355b3aea9b0a44b36bd/" rel="bookmark">
			考研经验总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年注定是人生不平凡的一年！在大一就决定要去考研，没想到时间过得那么快，转眼就要投入到考研的旅程之中！2022年考研备战一年很累也很充实，虽然没有上岸一志愿院校，不过好在最终还是上岸了。在我看来，考研一年，最终能有学上，都是不错的结果！
目录
考研择校篇
考研初试篇
思想政治理论
英语二 数学
专业课
考研复试篇
考研择校篇 考研择校是考研至关重要的部分，俗话说考得好不如选的好！选择往往大于努力！在选择院校的时候，首先要对自己的定位有个合理清晰的认识。对自己的目标院校有个合理的期望，然后去自己想要考取的院校的学院官方网站查取每年的录取情况，录取多少人，复试多少分，然后去看具体的考试科目，尽可能的去加入考取这个学院的考研群，一般都是一些卖书的创建的，但是里面确实有很多的资源可以共享，可以被利用。比如我所在的群里面，就会有这些年的一个录取情况、报录比、最低分、最高分等等！大家再看学校的录取分数线要有一个大概的预期，多少分能比较稳定上岸，要注意这个学校的这个学院是否存在大小年、保护一志愿、排外等现象，要多多了解逐步确定自己的考研院校！推荐在研招网中国研究生招生信息网 (chsi.com.cn)去了解各个院校的考试科目：
标研招 然后进入院校库查找自己向报考的院校的专业对应的考试科目：
英语一数学一相对英语二数学二会难一些，具体的区别大家可以去了解一下，决定统考科目是去尝试英语一数学一还是英语二数学二！
考研初试篇 我的考研总分342分，统考科目英语二数学二，专业课是通信原理，报考的专业是085400电子信息，具体情况如下：
思想政治理论 政治在考验中很难拉开差距，并不是和别人拉开差距的吃分项目。我个人觉得可以花较少的时间在上面。在大概八九月份的时候可以用二倍速把徐涛老师的视频都看一遍，如果向我一样不喜欢刷纸质题目，可以在手机上像背单词一样的去刷题，每天刷一定的数目，多做笔记积累不同，然后来提升自己的选择题能力。像今年考研，选择题很难，很多刷了很多题目的也不会，出的难度很大。政治的大题我觉得完全可以不用着急，可以等着肖四肖八出来了，背肖四的大体，基本上押题很准，务必背完肖四大题，推荐跟着卡子妈带背，打印卡字妈的背诵笔记，里面有很多模板套话，总结的很好，卡子妈，yyds！可以在微信公众号，b站关注
定期会有学习规划安排和激励人心的视频，尤其是在后期几小时学完政治之类的课程，对所有内容进行回顾，帮助很大，强烈推荐！
英语二 我的本科生活英语四级438，没通过英语六级，但是我的考研英语考了81分，所以大家不用担心自己的考研英语会不会过线之类的，肯定没问题的！笔者觉得考研英语和普通英语的区别很大，做题的技巧和方法很关键！我推荐首先以一个很快的速度过完考研英语的核心词汇，大概2200个词，然后就去看唐迟老师的长难句的逻辑和阅读的逻辑，对长难句和做题方法有基本的认识，可以直接上手真题了！
第一遍做英语真题不要过分追求正确率，要做的精做的细！推荐考研真相！一天可以做一两篇，不推荐全做完，前期只做阅读，买个单词本积累阅读中不认识的单词，在第二天早上进行背诵，对文章的每句话进行尝试翻译，对着考研真相的精讲册逐句翻译，锻炼自己的读懂文章的能力，不用过分去分析句子成分，有能力的分析，没能力的去探索自己的翻译技巧！作文跟着推荐石雷鹏老师的七步法，新题型推荐刘琦老师，新题型很简单，不用担心，至于完形填空看每个人的能力，有能力有时间就去训练！
数学二 考研数学我跟的张宇老师，然后在大概六月份过完了基础阶段，做完了300题；在暑假阶段刷完了660和一部分的张宇1000题，大概在9月份结束刷完1000题。相对来说660是强化第一份资料，对各方面能力提升很大，要仔细认真高效的练习！张宇1000题难度较大，但是坚持刷完收获也会很大！在后期我更注重去总结自己的错题和总结自己的方法，总结笔记，去做了李林880锻炼自己的能力。后期的冲刺阶段，选择了李林4套卷和8套卷，也刷了张宇老师的4+8，李林老师的比较接近于考试难度，张宇老师的相对难度较大，建议都写一写练一练。
专业课 我考的学校专业课是通信原理，难度很大而且还压分。专业课很容易踩雷，学长学姐们售卖资料，声称的往年真题很有可能是假的，或者没有很大的参考价值，要多做考试专业课的题目，不仅做报考院校的，还可以去做其他院校的来提升自己的能力。专业课侧重于理解，要理解到深处，活学活用。
考研复试篇 考研复试是考验中至关重要的一部分，很多学校的初复试占比基本接近5：5！初试高分被刷已经不是稀奇事了。大多数学校的复试都会有专业课的笔试，综合面试和英语口语。大家择校要提前了解报考学校的复试形式，复试情况，复录比等情况。了解复试笔试的专业课科目，综合面试的专业课科目以及该院校对学科竞赛的要求高低与否，英语口语的一个复试情况都要做好充分的了解，不要在复试上吃亏！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ffe5fd2bd7effa1de12dc274fdb9ea/" rel="bookmark">
			Linux下 TCP 连接限制如何解除，解决socket高并发连接数限制，tcp默认1024个连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		苏州私有云
当用户使用Linux作为系统时，socket在运行高并发的TCP程序时，可能会遇到连接数量到一定个数后被阻断的情况
我在工作的时候，测试高并发tcp程序（GPS服务器端程序），经过多次测试之后，发现每次建立的连接到达1000个左右
就再也不能建立tcp连接，然后在互联网上搜索，发现linux系统默认的ulimit为1024，这是用户最多可开启的程序数目。
一般一个端口的最高连接为2的16次方65535
第一步，修改/etc/security/limits.conf文件，在文件中添加如下行(*指代系统用户名)，
修改Linux系统对用户的关于打开文件数的软限制和硬限制：
soft nofile 65535
hard nofile 65535
第二步，修改/etc/pam.d/login文件，在文件中添加如下行：
session required /lib/security/pam_limits.so
如果是64bit系统的话，应该为 :
session required /lib64/security/pam_limits.so
第三步，修改/etc/sysctl.conf文件，在文件中(清楚文件原始内容)添加如下行（修改网络内核对TCP连接的有关限制）：
net.ipv4.ip_local_port_range = 1024 65535
net.core.rmem_max=16777216
net.core.wmem_max=16777216
net.ipv4.tcp_rmem=4096 87380 16777216
net.ipv4.tcp_wmem=4096 65536 16777216
net.ipv4.tcp_fin_timeout = 10
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_timestamps = 0
net.ipv4.tcp_window_scaling = 0
net.ipv4.tcp_sack = 0
net.core.netdev_max_backlog = 30000
net.ipv4.tcp_no_metrics_save=1
net.core.somaxconn = 262144
net.ipv4.tcp_syncookies = 0
net.ipv4.tcp_max_orphans = 262144
net.ipv4.tcp_max_syn_backlog = 262144
net.ipv4.tcp_synack_retries = 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86ffe5fd2bd7effa1de12dc274fdb9ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6caabf474c8c97b34d02d40a6ed11127/" rel="bookmark">
			使用docker搭建RocketMQ(非集群搭建官方镜像)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在使用 RocketMQ 官方的包在搭建的时候，发现好多问题，什么修改内存大小，然后启动 broker 报错，类似 service not available now, maybe disk full 等等… 最后决定还是重新用 docker 搭建下，感觉这样子玩坏了，可以直接把容器干掉，重新启动一个新的容器，毕竟是在学习阶段，这样子快好多。
废话不多说，现在开始搭建。
具体搭建流程 前提说明，由于之前使用非 docker 搭建的时候会出现各种内存不足的情况（因为那个虚拟机上面还搭建了其他好多东西），所以这次我是新创建了一个虚拟机，专门用来搭建 RocketMQ。
第一步：下载官方镜像 可以去官网看下最新的镜像 apache/rocketmq Tags | Docker Hub， 我这里使用的是最新的。
docker pull apache/rocketmq 第二步：部署 NameServer 创建挂载文件夹
# 日志目录 mkdir /apps/rocketmq/nameserver/logs -p # 保存路劲 mkdir /apps/rocketmq/nameserver/store -p 设置权限
# 777 文件所属者、文件所属组和其他人有读取 &amp; 写入 &amp; 执行全部权限。rwxrwxrwx chmod 777 -R /apps/rocketmq/nameserver/* 启动 namesrv 容器
docker run -d \ --privileged=true \ --name rmqnamesrv \ -p 9876:9876 \ -v /apps/rocketmq/nameserver/logs:/home/rocketmq/logs \ -v /apps/rocketmq/nameserver/store:/root/store \ -e "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6caabf474c8c97b34d02d40a6ed11127/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aed601c29cb071b824d0a102f2b1897/" rel="bookmark">
			Postgresql 14配置文件解释说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Postgresql 14配置文件postgresql.conf的解释说明 Postgresql 14配置文件，配置项翻译及解释说明 [suntoon@postgres14 data]# sudo nano postgresql.conf #----------------------------- # PostgreSQL configuration file #----------------------------- # #This file consists of lines of the form: # #name = value # #(The "=" is optional.) Whitespace may be used. Comments are introduced with #"#" anywhere on a line. The complete list of parameter names and allowed #values can be found in the PostgreSQL documentation.Shared Library Preloading # #The commented-out settings shown in this file represent the default values.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aed601c29cb071b824d0a102f2b1897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f668cd135e5b14fb4eeeea203f5a89e/" rel="bookmark">
			idea使用 ( 二 ) 创建java项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.创建java项目 3.1.创建普通java项目 3.1.1.打开创建向导 接 2.3.1.创建新的项目
也可以 从菜单选择建立项目
会打开下面的选择界面
3.1.2.不使用模板 3.1.3.设置项目名 Project name : 项目名
Project location : 项目存放的位置
确认创建
3.1.4.关闭tips 将 Dont show tips 勾中, 并Close 关闭 , 下次就是提示了
3.1.5.打开项目 点击 左边 Project 打开项目信息面板, 下 &gt; 打开项目结构
3.2.导入jar 3.2.1.增加文件夹 右键点击 项目名 在菜单 中选择 new &gt; Directory
为 文件夹取名
取名 lib 用于导入 存放 jar 文件
3.2.2.粘贴文件 复制 需要的 jar 文件 后
右键点击 新建 的 lib 文件夹, 在菜单中选择 粘贴
确认位置
在 lib 文件夹下可以看到 粘贴的结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f668cd135e5b14fb4eeeea203f5a89e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e987c4fb8c2bdf4326c9837ab4e1655/" rel="bookmark">
			过滤器简介--操作步骤--过滤器生命周期--过滤器匹配规则-- 过滤器链
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一节 过滤器简介 1、通过类比了解过滤器作用 ①坐地铁 ②登录检查 2、过滤器的三要素 ①拦截 过滤器之所以能够对请求进行预处理，关键是对请求进行拦截，把请求拦截下来才能够做后续的操作。而且对于一个具体的过滤器，它必须明确它要拦截的请求，而不是所有请求都拦截。
②过滤 根据业务功能实际的需求，看看在把请求拦截到之后，需要做什么检查或什么操作，写对应的代码即可。
③放行 过滤器完成自己的任务或者是检测到当前请求符合过滤规则，那么可以将请求放行。所谓放行，就是让请求继续去访问它原本要访问的资源。
提示：将来学习SpringMVC时，会学习SpringMVC中的『拦截器』，同样具备三要素。
第二节 HelloWorld 1、思路 2、操作步骤 ①准备工作 创建module加入Thymeleaf环境完成首页访问功能创建Target01Servlet以及target01.html创建SpecialServlet以及special.html ②创建Filter public class Target01Filter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // 1.打印一句话表明Filter执行了 System.out.println("过滤器执行：Target01Filter"); // 2.检查是否满足过滤条件 // 人为设定一个过滤条件：请求参数message是否等于monster // 等于：放行 // 不等于：将请求跳转到另外一个页面 // ①获取请求参数 String message = request.getParameter("message"); // ②检查请求参数是否等于monster if ("monster".equals(message)) { // ③执行放行 // FilterChain对象代表过滤器链 // chain.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e987c4fb8c2bdf4326c9837ab4e1655/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42979c06abb53e654677b27722684c05/" rel="bookmark">
			Spring RabbitMQ 实现消息队列延迟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 要实现RabbitMQ的消息队列延迟功能，一般采用官方提供的 rabbitmq_delayed_message_exchange插件。但RabbitMQ版本必须是3.5.8以上才支持该插件，否则得用其死信队列功能。
2.安装RabbitMQ延迟插件 检查插件 使用rabbitmq-plugins list命令用于查看RabbitMQ安装的插件。
rabbitmq-plugins list 检查RabbitMQ插件安装情况
下载插件
如果没有安装插件，则直接访问官网进行下载
https://www.rabbitmq.com/community-plugins.html 安装插件
下载后，将其拷贝到RabbitMQ安装目录的plugins目录；并进行解压，如：
E:\software\RabbitMQ Server\rabbitmq_server-3.11.13\plugins 打开cmd命令行窗口，如果系统已经配置RabbitMQ环境变量，则直接执行以下的命令进行安装；否则需要进入到RabbitMQ安装目录的sbin目录。
rabbitmq-plugins enable rabbitmq_delayed_message_exchange 3.实现RabbitMQ消息队列延迟功能 pom.xml配置信息文件中，添加相关依赖文件
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.olive&lt;/groupId&gt; &lt;artifactId&gt;rabbitmq-spring-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.7&lt;/version&gt; &lt;relativePath /&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!--rabbitmq--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.paho&lt;/groupId&gt; &lt;artifactId&gt;org.eclipse.paho.client.mqttv3&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42979c06abb53e654677b27722684c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c3220f4a596eff26e7ef94280b1a96c/" rel="bookmark">
			旧照片修复-模糊图片变清晰-2023年度最强神器 codeformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CodeFormer是一种基于AI技术深度学习的人脸复原模型，由南洋理工大学和商汤科技联合研究中心联合开发。该模型通过结合了VQGAN和Transformer等技术，可以通过提供模糊或马赛克图像来生成清晰的原始图像。
功能：
1、老照片修复
2、黑白照片彩色化
3、照片马赛克修复
4、低码率视频增强，增加细节
参考资料：
GitHub - sczhou/CodeFormer: [NeurIPS 2022] Towards Robust Blind Face Restoration with Codebook Lookup Transformer
按照教程，安装环境 首先安装miniconda3
新建python3.8 环境
/home/sean.xd/miniconda3/bin/conda create -n codeformer python=3.8 新建本地的venv
/home/sean.xd/miniconda3/envs/codeformer/bin/python -m venv venv
source venv/bin/activate
按照官方教程，安装requirements.txt
pip install -r requirements.txt
按照教程，安装
python basicsr/setup.py develop 但是会遇到报错，没有cython， 那就手工安装一下
pip install cython
然后再执行 python basicsr/setup.py develop， 这次就成功了
安装dlib
/home/sean.xd/miniconda3/bin/conda install -c conda-forge dlib 安装ffmpeg
/home/sean.xd/miniconda3/bin/conda install -c conda-forge ffmpeg 下载训练好的模型 python scripts/download_pretrained_models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c3220f4a596eff26e7ef94280b1a96c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/909207744662c0089ae496f01aa36732/" rel="bookmark">
			Redis中的序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis中的序列化为什么要序列化：序列化最终的目的是为了对象可以跨平台存储，和进行网络传输，凡是需要进行“跨平台存储”和”网络传输”的数据，都需要进行序列化。
RedisTemplate默认使用的是JdkSerializationRedisSerializer
StringRedisTemplate默认使用的是StringRedisSerializer
Spring Data JPA为我们提供了下面的Serializer：
1 . GenericToStringSerializer
2 . Jackson2 JsonRedisSerializer
3.JacksonJsonRedisSerializer
4 . JdkSerializationRedisSerializer
5 . OxmSerializer
6 . StringRedisSerializer
序列化方式对比：
JdkSerializationRedisSerializer :
使用JDK提供的序列化功能。
优点是反序列化时不需要提供类型信息( class )，
但缺点是需要实现Serializable接口，
还有序列化后的结果非常庞大，是JSON格式的5倍左右，
这样就会消耗redis服务器的大量内存。
Jackson2 JsonRedisSerializer：
使用Jackson库将对象序列化为JSON字符串。
优点是速度快，序列化后的字符串短小精悍，不需要实现Serializable接口。
但缺点也非常致命，那就是此类的构造函数中有一个类型参数，
必须提供要序列化对象的类型信息( .class对象)。
通过查看源代码，发现其只在反序列化过程中用到了类型信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d841df8316208b4323a3fdb26e1beba8/" rel="bookmark">
			VS2022配置汇编以及常用知识（x86处理器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.VS2022配置汇编 1.打开VS2022
2.创建新项目
3. Windows桌面向导
4.创建
5.勾选空项目，确定
6.生成依赖项，生成自定义
7.勾选masm，确定
8.如图修改
9.添加，新建项
10. .cpp后缀改为.asm
11.代码
TITLE Hello World! OPTION CASEMAP:NONE	;大小写敏感,NONE：敏感；ALL：不敏感 INCLUDELIB ucrt.lib	;引入静态数据链接库，相当于#include &lt;stdio.h&gt; INCLUDELIB legacy_stdio_definitions.lib INCLUDELIB kernel32.lib	;ExitProcess .MODEL FLAT,STDCALL	;FLAT：存储模式（平坦内存模式） ;STDCALL：语言类型（从右向左压栈） ;声明需要使用的函数头 printf	PROTO C,	;printf，不由被调用者清栈，而是由调用者负责清栈 :DWORD,	;格式控制串首地址 :VARARG	;输出项 scanf	PROTO C,	;scanf，不由被调用者清栈，而是由调用者负责清栈 :DWORD,	;格式控制串首地址 :VARARG	;输入项 ExitProcess PROTO,	;exit program dwExitCode:DWORD	;return code .DATA	;全局静态区 msg DB "Hello World!",	;分配字符串空间，存储“Hello,World!” 0dh, 0ah, 0	;回车，换行 .CODE main PROC PUSH OFFSET msg	;获取msp的偏移值，压栈 CALL printf	;调用上面声明的printf PUSH 0H CALL ExitProcess main ENDP END main 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d841df8316208b4323a3fdb26e1beba8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f27662b5f18236f1e56cd8f13dcabca/" rel="bookmark">
			C&#43;&#43;中可变参数宏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可变参数宏 基本语法实现格式化打印字符串va_list 可变参数宏(Macro With Variable Number of Arguments or Variadic Macro) 是指我们可以像定义能够接受不同数量参数的普通C++函数一样，定义一个能够接受不同数量参数宏。
基本语法 #define DEBUG(format, ...) fprintf (stderr, format, __VA_ARGS__) #define DEBUG(format, args...) fprintf (stderr, format, args) #define DEBUG(format, args...) fprintf (stderr, format, ##args) #define DEBUG(format, ...) fprintf (stderr, format, ##__VA_ARGS__) __VA_ARGS__替代的是宏函数中最后一个具名变量后的所有内容，其本身是编译器预定义的宏args为C++支持的可变参数的别名如果args或者__VA_ARGS__为空时,##会去掉args或者__VA_ARGS__前面多余的逗号，防止编译错误。 实现格式化打印字符串 使用可变参数宏实现格式化打印字符串往往需要用到vsnprint()，函数定义如下：
int vsnprintf( char* buffer, size_t buf_size, const char* fmt, va_list vlist ); vsnprintf() 函数将格式化字符串fmt 指向的字符串写入字符串缓冲区buffer，可写入的最大字符数为 buf_size ，写入字符后，添加终止空字符；如果buf_size 等于零，则不写入任何内容并且buffer 可能是空指针。
除此之外，格式化字符串fmt可能包含以 % 开头的占位符，这些占位符被作为列vlist 传递的变量的值替换。
va_list va_list类型的变量保存了可变参数的各种信息，用法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f27662b5f18236f1e56cd8f13dcabca/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/140/">«</a>
	<span class="pagination__item pagination__item--current">141/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/142/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>