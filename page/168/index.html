<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d88dbd2b8f57318d6b7d78b9a359e512/" rel="bookmark">
			DeepLabV3&#43;：Mobilenetv2的改进以及浅层特征和深层特征的融合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Mobilenetv2的改进
浅层特征和深层特征的融合
完整代码
参考资料
Mobilenetv2的改进 在DeeplabV3当中，一般不会5次下采样，可选的有3次下采样和4次下采样。因为要进行五次下采样的话会损失较多的信息。
在这里mobilenetv2会从之前写好的模块中得到，但注意的是，我们在这里获得的特征是[-1]，也就是最后的1x1卷积不取，只取循环完后的模型。
down_idx是InvertedResidual进行的次数。
# t, c, n, s [1, 16, 1, 1], [6, 24, 2, 2], 2 [6, 32, 3, 2], 4 [6, 64, 4, 2], 7 [6, 96, 3, 1], [6, 160, 3, 2], 14 [6, 320, 1, 1], 根据下采样的不同，当downsample_factor=8时，进行3次下采样，对倒数两次，步长为2的InvertedResidual进行参数的修改，让步长变为1，膨胀系数为2。
当downsample_factor=16时，进行4次下采样，只需对最后一次进行参数的修改。
import torch import torch.nn as nn import torch.nn.functional as F from functools import partial from net.mobilenetv2 import mobilenetv2 from net.ASPP import ASPP class MobileNetV2(nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d88dbd2b8f57318d6b7d78b9a359e512/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3118fd48382c667f96076302454d2493/" rel="bookmark">
			存储性能软件加速库（SPDK）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		存储性能软件加速库SPDK 存储加速存储性能软件加速库（SPDK）SPDK NVMe驱动1.用户态驱动1）UIO2）VFIOIOMMU（I/O Memory Management Unit） 3）用户态DMA4）大页（Hugepage） 2.SPDK用户态驱动1）异步轮询方式2）无锁化3）专门为Flash来优化 3.SPDK NVMe驱动性能4.SPDK NVMe驱动新特性5.SPDK用户态驱动多进程的支持1）共享内存2）共享NVMe SSD3）管理软件完成队列4）NVMe SSD共享管理流程 存储加速 一般从应用的角度来讲，一个存储任务或需求的完成，可以理解为用户从软件（客户端）发出一个存储需求（包括读和写），然后从存储设备返回用户的软件的过程。
存储服务到存储设备的整个I/O栈包括软件自身的I/O逻辑、网络的I/O逻辑、存储驱动的I/O逻辑，在其中可以找到很多可以优化的点。例如，在内存中，可以利用CPU的特殊指令对一些存储保护算法进行优化；在所经过的网络上，可以把数据传输的任务从CPU中卸载，交由具备RDMA功能的网卡或智能网卡来**进行远程DMA**；在操作系统到实际存储设备落盘的过程中，可以通过用户态的I/O栈来旁路（Bypass）操作系统内部的大部分I/O栈进行加速。
从目前来讲，无论在存储I/O处理的哪个阶段采用加速技术，都不能缺少软件的参与（可以是主机的软件，也可以是firmware中的软件），所以简单依照软件和硬件来划分存储技术的加速方案并没有多少价值。这里我们把存储的加速方案分为以下两类。
基于CPU处理器的加速和优化方案。基于协处理器或其他硬件的加速方案。 基于英特尔IA平台的两个对CPU加速的软件库：智能存储加速库（Intelligent StorageAcceleration Library，ISA-L）和存储性能软件的加速库（SPDK）。本章会着重介绍存储性能软件的加速库（SPDK）。
存储性能软件加速库（SPDK） SPDK每年发布4个版本,用于加速NVMe SSD作为后端存储使用的应用软件加速库,这个软件库的核心是用户态、异步、轮询方式的NVMe驱动,把**内核驱动放到用户态**，导致需要在用户态实施一套基于用户态软件驱动的完整I/O栈。文件系统毫无疑问是其中一个重要的话题，显而易见内核的文件系统，如ext4、Btrfs等都不能直接使用了。虽然目前SPDK提供了非常简单的文件系统blobfs/blostore，但是并不支持可移植操作系统接口，为此使用文件系统的应用需要将其直接迁移到SPDK的用户态“文件系统”上，同时需要做一些代码移植的工作，如不使用可移植操作系统接口，而采用类似AIO的异步读/写方式.
目前SPDK使用比较好的场景有以下几种
提供块设备接口的后端存储应用，如iSCSI Target、NVMe-oF Target。对虚拟机中I/O的加速SPDK加速数据库存储引擎 SPDK NVMe驱动 在NVMe之前，相对来说一个存在时间更长的接口标准是串行ATA高级 主 机 控 制 器 接 口 （ Serial ATA Advanced Host Controller Interface ，AHCI）。AHCI是在英特尔领导下由多家公司联合研发的接口标准，它允许存储驱动程序启用高级串行ATA功能。相对于传统的IDE技术，AHCI对传统硬盘性能提高带来了改善。但是随着新介质、新技术的发展，AHCI对Flash SSD来说逐渐成为性能瓶颈，这个时候NVMe应运而生。
性能的影响主要在于固态硬盘（包括firmware）和软件的开销。从持续满足上层应用的高性能的角度看，有两种途径：一是开发更高性能的固态硬盘硬件设备；二是减少软件的开销。
基于最新3D XPoint技术的Intel Optane NVMe SSD设备可以在延迟和吞吐量方面使得性能更上一层楼。**软件的开销是NVMe SSD的性能瓶颈**
SPDK的核心组件之一就是用户态NVMe驱动
1.用户态驱动 应用程序是怎么和内核驱动进行交互的?
当内核驱动模块在内核加载成功后，会被标识是块设备还是字符设备，同时定义相关的访问接口，包括管理接口、数据接口等。这些接口直接或间接和文件系统子系统结合，提供给用户态的程序，通过**系统调用的方式**发起控制和读/写操作。
用户态应用程序和内核驱动的交互离不开用户态和内核态的上下文切换，以及系统调用的开销。
用户态驱动出现的目的就是减少软件本身的开销，包括这里所说的上下文切换、系统调用等。
在用户态，目前可以通过UIO（Userspace I/O）或VFIO（Virtual Function I/O）两种方式对硬件固态硬盘设备进行访问。
1）UIO 要在用户态实现设备驱动，主要需要解决以下两个问题。
· 如何访问设备的内存：Linux通过映射物理设备的内存到用户态来提供访问，但是这种方法会引入安全性和可靠性的问题。UIO通过限制不相关的物理设备的映射改善了这个问题。由此基于UIO开发的用户态驱动不需要关心与内存映射相关的安全性和可靠性的问题。如何处理设备产生的中断：中断本身需要在内核处理，因此针对这个限制，还需要一个小的内核模块通过最基本的中断服务程序来处理。这个中断服务程序可以只是向操作系统确认中断，或者关闭中断等最基础的操作，剩下的具体操作可以在用户态处理。 UIO架构如图所示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3118fd48382c667f96076302454d2493/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1121be283c1486ac52584ff2e3460361/" rel="bookmark">
			卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卷积神经网络 1. 卷积神经网络边缘检测示例Padding卷积步长三维卷积单层卷积网络简单卷积网络示例池化层卷积神经网络示例 2. 深度卷积网络经典网络残差网络残差网络为什么有用1 x 1 卷积谷歌Inception 网络介绍Inception 网络迁移学习数据扩充（数据增强） 3. 目标检测目标定位特征点检测目标检测卷积的滑动窗口实现 1. 卷积神经网络 边缘检测示例 卷积运算是卷积神经网路最基本的组成部分。
这是一个6 x 6的灰度图像，是6 x 6 x 1的矩阵而不是6 x 6 x 3的（因为并没有RGB三通道）。为了检测图像中的垂直边缘，你可以构造一个3 x 3的矩阵（过滤器 或者 核）。对这个6 x 6的图像用3 x 3的过滤器对其进行卷积，这个卷积运算的输出将会是一个4 x 4的矩阵。
如下是垂直边缘检测器
所以将矩阵的所有数字都设置成参数，通过数据反馈，让神经网络自动去学习它们。我们会发现神经网络可以学习一些低级的特征，例如这些边缘的特征。
Padding 如果我们有一个nxn的图像，用一个fxf的过滤器做卷积，那么输出结果的维度就是(n-f+1)x(n-f+1)。
这样的话会有两个缺点：
第一个缺点是每次做卷积操作，你的图像就会缩小。第二个缺点是如果你注意角落边的像素，这个像素点只被一个输出所触碰或者说使用。所以那些在角落或者边缘区域的像素点在输出中采用较少，意味着你丢掉了图像边缘位置的许多信息 为了解决这些问题，你可以在卷积操作之前填充这幅图像。习惯上，你可以用0去填充，如果p是填充的数量，输出也就变成了(n+2p-f+1)x(n+2p-f+1)。
这样一来，丢失信息或者更准确来说角落或图像边缘的信息发挥的作用较小这一缺点 就被削弱了。
至于选择填充多少像素，通常有两个选择，分别叫做Valid卷积和Same卷积。Valid卷积意味着不填充。Same卷积意味着你填充后你的输出大小和输入大小是一样的，这时p的取值为p =（f-1)/2。
卷积步长 当我们把把步长设置成了2，你还是和之前一样取左上方的3x3区域的元素的乘积得到91，只是之前我们移动蓝框的步长是1，现在移动的步长是2，我们让过滤器跳过2个步长。
当你移动到下一行的时候，你也是使用步长2而不是步长1，所以我们将蓝框移动到这里
输入和输出的维度，是由以下的公式决定的：如果你用一个fxf的过滤器，卷积一个nxn的图像，你的 padding 为p，步幅为s，你会得到一个输出等于 (n+2p-f)/s +1 x (n+2p-f)/s + 1。如果商不是一个整数，在这种情况下我们向下取整。这个原则实现的方式是你只在蓝框完全包括在图像或填充完的图像内部时才对它进行运算，如果有任意一个蓝框移动到了外面，那么你就不要进行相乘操作。
三维卷积 如果彩色图像大小是6*6*3（高、宽 和通道），你可以把它想象成三个6*6的图像的堆叠。为了检测图像的边缘，可以使用一个3*3*3的三维过滤器，这个的输出会是一个4*4*1的图像，而不是4*4*3。图像的通道数必须和过滤器的通道数匹配。
如果你有一个n*n*nc(nc为通道数)的输入图像，然后卷积上一个f*f*nc的过滤器，然后你就得到了（n-f+1）*（n-f+1）*m的输出，它就是你用的过滤器的个数。
单层卷积网络 简单卷积网络示例 最后这一步是处理所有数字，即全部1960个数字把它们展开成一个很长的向量，然后填充到softmax回归函数中，最后得到结果。
一个典型的卷积网络通常有三层，一个是卷积层（conv）、一个是池化层（pool）、最后一个是全连接层（FC）。
池化层 除了卷积层，卷积网络也经常使用池化层来缩减模型的大小、提高计算速度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1121be283c1486ac52584ff2e3460361/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b3e517b28c4e99b4651e3adec44475f/" rel="bookmark">
			PyQt5保姆级入门教程——从安装到使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Part1：安装PyQt5
Part 2：PyCharm配置PyQt5
Part 3：PyQt5设计界面介绍
Part 4：PyQt5设计UI
今天看了多个大佬的教程，总算是把PyQt5开发弄好了，每个部分都要看几个人的十分不方便，我十分想要总结一下，所以在这里，你无需看其他的教程，从这就能完成它的安装到快速上手。
Part1：安装PyQt5 在虚拟环境当中安装，我选择的是我的工程文件夹下的，以便我随时进行界面的修改。
pip安装PyQt5
pip install PyQt5 pip安装pyqt5-tools
pip install pyqt5-tools 在这一步就完成了它的安装，你可以继续在cmd中输入
pip list 查看是否有这个安装包，接着打开搜索框，我的是win11系统，你也可以用win+s键打开。
输入 designer，点击红框即可打开
打开方式一 Part 2：PyCharm配置PyQt5 打开设置-&gt;工具-&gt;外部工具-&gt;添加文件(点击加号)
可以参照下面的内容按照要求输入，高级选项默认就好。QtDesigner的位置可以在收索框中右键选择文件所在位置找到，下面两个python的文件位置相同，就是你要安装PyQt5的位置，我的安装的位置是在虚拟环境当中。
名称：QtDesigner 工具设置 程序：E:\Anaconda\anaconda3\Library\bin\designer.exe 工作目录：$FileDir$ 名称：PyUIC 工具设置 程序：E:\Anaconda\anaconda3\envs\pytorch\python.exe 实参：-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py 工作目录：$FileDir$ 名称：Pyrcc 工具设置 程序：E:\Anaconda\anaconda3\envs\pytorch\python.exe 实参：$FileName$ -o $FileNameWithoutExtension$_rc.py 工作目录：$FileDir$ 完成后在pycharm的上面导航栏中，按照下图所示，即可打开PyQt5设计。
打开方式二 至此，安装和配置结束，打开的方式也有两种可选。
Part 3：PyQt5设计界面介绍 首先，打开后会有这样一个界面，选择"Main Windows"，点击创建，如果你不想每次打开都弹出这个窗口，取消勾选即可。
下面来介绍一下它的一个工作界面。
位于左上方的“Widget Box”包含了各种可以自由拖动的组件；位于界面中央的“MainWindows - untitled”就是你可以设计的画布；位于右上方的“对象查看器”可以查看当前ui的结构；位于右侧中央的“属性编辑器”可以设置选中组件的属性；位于右下方的“资源浏览器”可以添加各种素材，比如像图片、背景等等。 当然对于这个也有汉化功能，而我的安装好后就是这样了（有部分中文），所以大家如果有需要可以看看其他教程，现在相信你应该清楚了各个模块部分作用，我们接下来将会设计你的第一个UI了。
Part 4：PyQt5设计UI 在左边的Wiget Box中找到“Push Button”、“Label”、“Text Browser”，通过双击即可修改名称，右边有属性可以修改。你觉得你做好后可以快捷键Ctrl+r，预览当前编写的GUI。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b3e517b28c4e99b4651e3adec44475f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a9143ed48c64f4613869090415cace5/" rel="bookmark">
			CentOS8常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用查看类命令 查看 OS 版本 [root@centos6 ~]# cat /etc/redhat-release CentOS release 6.9 (Final) [root@centos6 ~]# cat /etc/issue CentOS release 6.9 (Final) Kernel \r on an \m [root@centos6 ~]# uname -r ## 查看内核版本 2.6.32-696.el6.x86_64 关机
shutdown now # 立即关机
shutdown 10:01 # 10:01关机
shutdown +2 “The PC：STJWESTESSNL6DB01 will shutdown” # 2min 后关机，并通知在线者
tail -f /var/log/message #系统日志
uptime #显示自上次重启以来已运行多长时间
lastlog
last #显示最后登录的用户，显示重启请求
who #显示谁现在登录
窗口退出，程式不停
[root@h5 ~]# yum -y install screen #安装screen [root@h5 ~]# which screen #查看安装位置 /usr/bin/screen [root@h5 ~]# screen -S new-1 #新建screen -S 大写 + 名称 [root@h5 ~]# screen -ls #列表目前已有的screen 目前有2个 There are screens on: 10143.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a9143ed48c64f4613869090415cace5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/292fc761f5e157881bd314457a48ffec/" rel="bookmark">
			getApplicationContext().getBean()和@Autowired使用区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天看代码发现有个ApplicationContextUtils，其中有getBean()方法，我一直没想通为什么要单独写个工具类，直接@Autowired不行嘛，后来才想明白 @Autowired只能在调用自动装配对象的对象的方法不是静态方法时使用，因为静态方法能在对象没实例化时调用，但此时自动装配对象还未装配。
ApplicationContext().getBean()则所用情况都可以使用，尤其在静态方法中，只能用这种方法
暂时是这么理解了，待补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0098c20da89c840e29a56d7a6498df0/" rel="bookmark">
			IoT Studio场景最佳实践——实践类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用IoT Studio快速构建可视化应用 在物联网业务场景中设备数据可视化应用是最普遍的需求，阿里云物联网应用开发（IoT Studio）提供了Web可视化开发、移动可视化开发、业务逻辑开发与物联网数据分析等一系列便捷的物联网开发工具，解决物联网开发领域开发链路长、定制化程度高、投入产出比低、技术栈复杂、协同成本高、方案移植困难等问题。
本次物联网场景最佳实践我们用六合一传感器（温度、湿度、二氧化碳、PM2.5、PM10、甲醛）实现家庭环境数据实时采集，通过家中Wi-Fi上报到阿里云IoT物联网平台，借助IoT Studio低代码工具搭建可视化大屏，实时监控家中环境指标变化。
完整链路参考如下：
2.操作步骤 2.1 物联网平台开发 1.前往物联网平台控制台。
说明：如果您未开通物联网平台，请您根据页面提示，开通物联网平台。
2.在实例概览页面，选择您的实例。
说明：本实验以企业实例进行实验操作。
3.在新建产品页签，产品名称输入六合一环境传感器，所属品类选择自定义品类，其他配置保持默认即可，单击确认。
4.在功能定义页签，单击功能定义。在添加自定义功能对话框中，功能名称输入温度，标识符输入temperature，设置数据类型和取值范围等，单击确认。
5.同理，我们依次添加湿度、二氧化碳、PM2.5、PM10、甲醛浓度，如下图。最后，单击发布上线。
6.在添加设备对话框中，产品选择六合一环境传感器，DeviceName输入sensor007，单击确认。
2.2 IoT Studio项目搭建 当我们完成物联网平台开发后，即可进入到物联网应用开发服务（IoT Studio）的工作台完成物联网应用的搭建。
注：物联网应用开发服务（IoT Studio）企业版购买入口 阿里云登录 - 欢迎登录阿里云，安全稳定的云计算服务平台
1.前往IoT Studio工作台，选择上一步创建设备的实例。
2.在左侧导航栏中，单击项目管理，在新建空白项目对话框中，项目名称输入家庭环境监控，单击确认。
3.进入项目开发控制台，在Web应用页签，单击新建。
4.在新建Web应用对话框中，应用名称输入家庭环境实时监控大盘，单击确定。
5.在左侧导航栏中，单击产品。
6.在产品页面，单击关联物联网平台产品，选中六合一环境传感器，单击确定。关联后如下图。
7.在设备页面，单击关联物联网平台设备，选中sensor007，单击确定。
关联后如下图：
至此，我们完成了IoT Studio项目的资源准备工作，接下来进入Web应用搭建环节。
2.3 Studio应用开发 1.在家庭环境监控页面的Web应用页签，找到家庭环境实时监控大盘，单击右侧的编辑，接入应用搭建控制台。
2.选择左侧组件，然后在下拉框选择工业组件，选中刻度表，拖拽到页面即可。
3.同理，我们添加需要的组件(室内温度-刻度表、室内湿度-单色仪表盘、PM2.5和PM10指数-多色仪表盘、二氧化碳浓度和甲醛浓度-数码管)，完成页面布局，如下图。
4.页面布局好后，我们需要关联六合一传感器设备sensor007。点击刻度表组件，在右侧找到配置数据源按钮。
5.在数据源配置页面，我们关联产品，选中设备sensor007，并选择属性值温度。
6.同理，我们配置好其他组件的数据源后，即可点击右上角预览，查看效果页面
7.IoT物联网家居环境监控大屏应用预览效果如下
2.4联机运行 完成开发后，我们回到物联网平台控制台，进行设备模拟联调。
1.在物联网实例控制台，设备模拟器页面，我们调试设备选择为六合一环境传感器sensor007，单击启动设备模拟器。
2.在上行指令调试的属性上报页签，输入模拟数据，单击发送指令，即可看到IoT Studio预览家居环境监控大屏页面上数据指标实时刷新。
3.相关产品 阿里云物联网平台 阿里云物联网平台为客户提供全托管的企业级实例服务，具有低成本、高可靠、高性能、高安全的优势，无需自建物联网基础设施即可接入各种主流协议的设备，管理运维亿级并发规模的设备，存储备份和处理分析EB量级的设备数据。帮助企业在物联网时代快速实现设备数据和应用数据的融合，是每个企业实现设备智能化升级的绝佳选择。
物联网应用开发（IoT Studio） 物联网应用开发（IoT Studio）是阿里云针对物联网场景提供的生产力工具，是阿里云物联网平台的一部分。可覆盖各个物联网行业核心应用场景，帮助您高效经济地完成物联网数据分析、设备、服务及应用开发，加速物联网SaaS构建。
物联网平台产品介绍详情：https://www.aliyun.com/product/iot/iot_instc_public_cn
阿里云物联网平台客户交流群
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f59f45c90fd1486a7429ccfa6cedd0e/" rel="bookmark">
			四元数、欧拉角、旋转矩阵、旋转向量之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四元数、欧拉角、旋转矩阵、旋转向量之间的转换 1. 欧拉旋转定理2. 轴角表示2.1 旋转性质 3. 罗德里格斯公式4. pitch yaw roll方向5. 内旋和外旋6. 使用哪种表示方法？7. 四元数、欧拉角、旋转矩阵、旋转向量之间的转换7.1 旋转向量7.2 旋转矩阵7.3 欧拉角7.4 四元数 1. 欧拉旋转定理 在运动学里，欧拉旋转定理(Euler's rotation theorem)表明，在三维空间里，假设一个刚体在做一个旋转的时候，刚体内部至少有一点固定不动，则此位移等价于一个绕着包含那固定点的固定轴的旋转。
2. 轴角表示 旋转一个向量从 a a a 到 b b b，轴角为 ( u , θ ) (u,\theta) (u,θ)，如下图所示：
罗德里格斯公式：
b = a c o s θ + ( u × a ) s i n θ + u ( u ⋅ a ) ( 1 − c o s θ ) b=acos\theta+(u\times a)sin\theta+u(u\cdot a)(1-cos\theta) b=acosθ+(u×a)sinθ+u(u⋅a)(1−cosθ)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f59f45c90fd1486a7429ccfa6cedd0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc9575ef88843aedd400106e860d7b1/" rel="bookmark">
			应用案例 | 实现图像到图像转换—Pix2Pix
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pix2Pix是基于条件生成对抗网络（cGAN, Condition Generative Adversarial Networks ）实现的一种深度学习图像转换模型，该模型是由Phillip Isola等作者在2017年CVPR上提出的,可以实现语义/标签到真实图片、灰度图到彩色图、航空图到地图、白天到黑夜、线稿图到实物图的转换。Pix2Pix是将cGAN应用于有监督的图像到图像翻译的经典之作，其包括两个模型：生成器和判别器。
传统上，尽管此类任务的目标都是相同的从像素预测像素，但每项都是用单独的专用机器来处理的。而Pix2Pix使用的网络作为一个通用框架，使用相同的架构和目标，只在不同的数据上进行训练，即可得到令人满意的结果，鉴于此许多人已经使用此网络发布了他们自己的艺术作品。
基础原理
cGAN的生成器与传统GAN的生成器在原理上有一些区别，cGAN的生成器是将输入图片作为指导信息，由输入图像不断尝试生成用于迷惑判别器的“假”图像，由输入图像转换输出为相应“假”图像的本质是从像素到另一个像素的映射，而传统GAN的生成器是基于一个给定的随机噪声生成图像，输出图像通过其他约束条件控制生成，这是cGAN和GAN的在图像翻译任务中的差异。Pix2Pix中判别器的任务是判断从生成器输出的图像是真实的训练图像还是生成的“假”图像。在生成器与判别器的不断博弈过程中，模型会达到一个平衡点，生成器输出的图像与真实训练数据使得判别器刚好具有50%的概率判断正确。
在教程开始前，首先定义一些在整个过程中需要用到的符号：
x：代表观测图像的数据。
z：代表随机噪声的数据。
：生成器网络，给出由观测图像x与随机噪声z生成的“假”图片，其中x来自于训练数据而非生成器。
：判别器网络，给出图像判定为真实图像的概率，其中x来自于训练数据，来自于生成器。
cGAN的目标可以表示为：
该公式是cGAN的损失函数，D想要尽最大努力去正确分类真实图像与“假”图像，也就是使参数
最大化；而G则尽最大努力用生成的“假”图像y欺骗D，避免被识破，也就是使参数最小化。cGAN的目标可简化为：
为了对比cGAN和GAN的不同，我们将GAN的目标也进行了说明：
从公式可以看出，GAN直接由随机噪声z生成“假”图像，不借助观测图像x的任何信息。过去的经验告诉我们，GAN与传统损失混合使用是有好处的，判别器的任务不变，依旧是区分真实图像与“假”图像，但是生成器的任务不仅要欺骗判别器，还要在传统损失的基础上接近训练数据。假设cGAN与L1正则化混合使用，那么有:
进而得到最终目标：
图像转换问题本质上其实就是像素到像素的映射问题，Pix2Pix使用完全一样的网络结构和目标函数，仅更换不同的训练数据集就能分别实现以上的任务。本任务将借助昇思MindSpore框架来实现Pix2Pix的应用。
配置环境文件 本教程我们在GPU环境下，使用图模式运行实验。
from mindspore import context #选择执行模式为图模式；指定训练使用的平台为"GPU"，如需使用昇腾硬件可将其替换为"Ascend" context.set_context(mode=context.GRAPH_MODE, device_target="GPU") 准备数据 在本教程中，我们将使用指定数据集，该数据集为六种数据集，分别为外墙（facades）、市景（cityscapes）、地图（maps）、昼夜图（night2day）、鞋子图片及对应线条图（edges2shoes）、手包图片及对应线条图（edges2handbags）。
每类数据集均保存于/datasets文件夹下，如/datasets/maps等，具体结构及图片数量如下。
数据处理 以facades数据集为例，首先定义一些配置参数：
train_data_dir = "/home/pix2pix/end/datasets/facades/train/" # 训练集的文件路径 epoch_num = 200 # 训练迭代次数 batch_size = 1 # 训练中使用的批量大小 dataset_size = 400 # 训练数据集大小 val_data_dir = "/home/pix2pix/end/datasets/facades/val/" # 推理数据集的文件路径 ckpt = "results/ckpt/Generator_200.ckpt" # 推理用ckpt文件的文件路径 device_target = "GPU" # GPU或Ascend # 以上参数需要根据不同数据集单独设置 各个数据集的训练轮次数epoch_num、输入图像批次batch_size等不同，需根据不同数据集相应设置。论文参考值展示如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bc9575ef88843aedd400106e860d7b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7c575462e7eacc3133cbb21941de284/" rel="bookmark">
			Qt Creator vs2022 构建 Disney BRDF Explorer 项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github: GitHub - wdas/brdf: BRDF Explorer
Implementation of the Disney principled BRDF - Alexandre Pestana
1. 编译zlib a. 在 zlib Home Site 这里下载，需要zlib-1.2.11这个版本。
b. 在源码目录中如下图所示打开工程
c. 配置编译属性
d. 打开后设置如下图:
e. 可能需要再设置生成后事件:
f: 选择release x64 进行编译:
g. 将编译好的lib/dll以及头文件放在需要的文件夹下，下图是编译好的lib文件位置:
还有头文件位置:
将这个三个文件放在你需要的路径(文件夹下), 后续用在brdf explorer qt项目配置中
2. Qt Creator版本需要5.14 点此链接下载: Index of /archive/qt/5.14/5.14.0
安装到你需要的目录
3. 用Qt Creator构建项目/调试 a. 用Qt Creator 打开brdf explorer 工程
b. 配置zlib
c. 开始调试会报错 error: $prefix is undefined. Please pass prefix=&lt;path&gt; to qmake
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7c575462e7eacc3133cbb21941de284/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46798e55e160fb6839674520156fd456/" rel="bookmark">
			数据库有那些类型？数据库都有什么类型？你可能从未知道，数据库还有这么多类型。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库的类型粗略来说可以分为关系型数据库和非关系型数据库，详细的分类如下：
1、关系型数据库Relational Database 关系型数据库的使用最为普遍流行，排名前十的数据库里就有6个是关系型数据库，如Oracle、MySQL、微软的SQL Server、PostgreSQL、IBM的DB2以及装机量最多的数据库SQLite以及大数据库的数据库Hive
2、文档型数据库Document Database 常见的有前端开发和爬虫的最爱MongoDB、Couchbase、Firebase、CouchDB
3、键值数据库Key-value Database 键值数据库常见的有Redis、Memcached
4、搜索引擎Search Engine 比如大厂必备的Elasticsearch、日志数据库Splunk
5、宽列数据库Wide Column 分布式数据库，常见的有Cassandra、HBase
6、图形数据库Graph 常见的有Neo4j
7、时序数据库Time Series 常见的有InfluxDB
早期较为时兴的数据库种类有三种，分别是层次式数据库、网络式数据库和关系型数据库。而在如今的互联网中，最常见的数据库种类主要有2种，即关系型数据库和非关系型数据库。
对于Web应用来说，数据库操作越来越成为一个性能瓶颈，这一点尤其明显。对于数据库的性能来说，不仅仅是DBA需要担心这个问题，程序员更需要关注这个问题。
在我们的工作中，数据出现的很频繁。但大多数人对数据库的建立还不太熟悉，设计数据库时，首先要准确理解和分析用户需求。那么应该怎么样去建立数据库呢。
延伸阅读 数据库有哪些类型？如何根据应用场景选择？一文带你了解全部 - 知乎
数据库的应用有哪些？ 1. PingCAP PingCAP 成立于 2015 年，是一家企业级开源分布式数据库厂商，提供包括开源分布式数据库产品、解决方案与咨询、技术支持与培训认证服务。由 PingCAP 创立的分布式关系型数据库 TiDB，有着分布式强一致性事务、在线弹性水平扩展、故障自恢复的高可用、跨数据中心多活等企业级核心特性，帮助企业最大化发挥数据价值。目前，PingCAP 已经向包括中国、美国、欧洲、日本、东南亚等国家和地区，超过 1500 家企业提供服务，涉及金融、运营商、制造、零售、互联网、政府等多个行业。
2.MySQL MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。
3.Access Access 是一个易于使用的工具，可通过它从模板或从头开始创建商业应用程序。通过其丰富的直观工具，Access 为企业业务和客户量身打造自定义应用，按需轻松编辑以满足不断变化的要求。使用 Visual Basic for Applications，自定义业务流程、创建更有用的表单和报告。在 Access 和使用 Access 连接器库的业务线应用之间集成数据，以便在熟悉的 Access 界面中生成集成可视化项和见解，在 SQL Server 和 Microsoft Azure SQL也可存储数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46798e55e160fb6839674520156fd456/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a87d8da0b55e20ded527195423f0786d/" rel="bookmark">
			给我找一整套untiy可以使用的古风UI和仙侠UI，还有一整套古风和仙侠类型的模型...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以下是可以在Unity中使用的古风UI和仙侠UI以及模型资源的列表：
古风UI资源： Ancient Chinese Style UI：这是一个Unity Asset Store上的付费资源包，包括大量古风UI元素和图标，例如按钮、文本框、进度条等。
Chinese Classical Style GUI：这是另一个Unity Asset Store上的付费资源包，包含大量的古风UI元素，例如按钮、窗口、面板、图标等。
Kung-Fu RPG GUI：这是一个包含许多古代武侠元素的UI素材，例如武器、道具、武术动作等。
仙侠UI资源： Chinese 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a42c05c6f425bdc57345e1c3fa6280c/" rel="bookmark">
			《TensorRT从零起步高性能部署》的学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 I 课程知识点目录 1 说在前面 1.1 了解课程结构和形式 如何使用trtpy配置实验环境 - [2:03] 安装的CUDA文件夹会位于trtpy对应的conda环境下，方便清理和删除 II 学习工具环境配置：trtpy 2.1 新建虚拟环境：conda-trt Python &lt;= 3.9
1.2 配置trtpy 设置trtpy快捷指令：
alias trtpy="python -m trtpy" 下载trtpy所需的python包：
trtpy get-env 拉取cpp-trt-mnist项目代码：
trtpy get-templ cpp-trt-mnist 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e02fcc0c01566bc07d53ddd889211408/" rel="bookmark">
			HandlerAdapter 适配了哪些处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AnnotionMethodHandlerAdapter：主要适配注解类处理器：我们常用的@Controller 这类处理器
HttpRequestHandlerAdapter：主要适配静态资源适配器：实现了HTTPRequestHander接口 ,主要作用：通过SpringMVC来访问静态资源请求
SimpleControllerHandlerAdapter:SimpleControllerHandlerAdapter:是Controller适配器，适配了Controller接口或Controller接口的子类的处理器
比如我们经常自己写的Controller来继承MultiActionController注意：Spring5.0版本遗弃，4.0版本才有
SimpleServletHandlerApapter:是Servlet的适配器，适配实现了Servlet接口或接口子类的处理器，我们不用不仅可以在web.xml 里面配置Servlet,其实也可以用SpringMVC 来配置 Servlet,不过这个适配器很少用到，SpringMVC默认的适配器没有他，默认是前三种
注意：AnnotionMethodHandlerAdapter 适配的是 我们的注解处理器而SimpleControllerHandlerAdapter适配的是我们的Controller 接口或者接口下的子类处理器 是不一样的 不要混淆了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d28833a9b7600390713b6ca499cd52b/" rel="bookmark">
			Lambda表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 函数式编程示例（累加）示例（斐波那契数列） 纯函数不可变计算如何建立不可变对象 Lambda 表达式Lambda表达式的格式Lambda表达式的省略模式Lambda表达式的注意事项Lambda表达式和匿名内部类的区别Lambda表达式支持方法引用 函数式接口常用的函数式接口 Stream特点流程中间操作终端操作符 java8中一个非常重要的特性就是lambda表达式，可以把它看成是一种闭包，它允许把函数当做参数来使用，是面向函数式编程的思想，一定程度上可以使代码看起来更加简洁。 函数式编程 函数式编程将电脑运算视为函数的计算。函数编程语言最重要的基础是λ演算（lambda calculus），而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。
函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。
和指令式编程相比，函数式编程强调函数的计算比指令的执行重要。和过程化编程相比，函数式编程里函数的计算可随时调用。
示例（累加） 使用java实现累加。
import java.util.Arrays; import java.util.List; class Accumulation { public static Integer sum(List&lt;Integer&gt; nums) { int result = 0; for (Integer num : nums) { result += num; } return result; } public static void main(String[] args) { List&lt;Integer&gt; nums = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10); System.out.println(sum(nums)); // 55 } } 同样的代码，用 Java8 Stream 实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d28833a9b7600390713b6ca499cd52b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/225905121ae577ac22ce48d9c1c5ff25/" rel="bookmark">
			（Python）蚁群算法解决旅行商问题(ACO-TSP)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蚁群算法又称蚂蚁算法，容易与其他算法相结合，但也存在收敛速度慢，容易陷入局部最优等缺点。
# -*- coding: utf-8 -*- import random import copy import time import sys import math import tkinter # //GUI模块 import threading from functools import reduce # 参数 ''' ALPHA:信息启发因子，值越大，则蚂蚁选择之前走过的路径可能性就越大 ，值越小，则蚁群搜索范围就会减少，容易陷入局部最优 BETA:Beta值越大，蚁群越就容易选择局部较短路径，这时算法收敛速度会 加快，但是随机性不高，容易得到局部的相对最优 RHO:控制参数，更新信息素矩阵时使用 Q:正常数，信息素计算时使用 ''' (ALPHA, BETA, RHO, Q) = (1.0, 2.0, 0.5, 100.0) # 城市数，蚁群 (city_num, ant_num) = (50, 50) distance_x = [ 178, 272, 176, 171, 650, 499, 267, 703, 408, 437, 491, 74, 532, 416, 626, 42, 271, 359, 163, 508, 229, 576, 147, 560, 35, 714, 757, 517, 64, 314, 675, 690, 391, 628, 87, 240, 705, 699, 258, 428, 614, 36, 360, 482, 666, 597, 209, 201, 492, 294] distance_y = [ 170, 395, 198, 151, 242, 556, 57, 401, 305, 421, 267, 105, 525, 381, 244, 330, 395, 169, 141, 380, 153, 442, 528, 329, 232, 48, 498, 265, 343, 120, 165, 50, 433, 63, 491, 275, 348, 222, 288, 490, 213, 524, 244, 114, 104, 552, 70, 425, 227, 331] # 城市距离和信息素 distance_graph = [[0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/225905121ae577ac22ce48d9c1c5ff25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e631409d3ecf21b3475436da93000189/" rel="bookmark">
			一款私有化部署的企业级在线文档和知识库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 基础说明：
无忧企业文档是JVS体系下的一款企业协同在线文档，主要服务客群为企业用户，解决企业内部文档编辑、知识沉淀、知识协同等痛点。
项目主要采用Java开发，基础框架采用JVS（spring cloud+Vue）
适用场景： 适用于企业、团队，提供在线笔记、知识沉淀、在线产品手册、知识库、在线电子教程等功能。
解决的问题： 数据资产化的问题 ：没有合适的文件管理工具，很难对员工无形知识转化为企业的有形资产，导致培训、学习、展示上浪费了大量的资源，而且效果还不尽人意。
文件统一管控问题 ：数据文件分散在员工各自的电脑中，很难形成有效的统一管控，需要从文件的生成、使用、流动整个过程对 非结构化内容进行管理
知识流动的问题 ：信息的流动速度是企业高效运转的重要保障，解构化的数据由业务系统管理起来，但是非结构化的信息确实可靠的流动渠道，基本靠吼、靠U盘，靠问
信息的检索问题 ：文件由于没有解构化，所以不便于检索查找，是缺乏一个有效的企业级“百度”
信息安全的问题 ：企业内部无法有效的分级管理文件，放在互联网上的SaaS平台又存在信息泄露风险，私有化+内部权限管控是基础
无忧·企业文档=企业级知识库+在线编辑工具集+企业搜索引擎+内容展示平台 项目价值 使用低成本，超过30个用户产品的使用时，成本低于SaaS产品，且无用户数的限制
信息安全，私有化部署（实体服务器或者私有云），私有化的核心是数据可控，不存在数据控制归第三方
技术开放，采用通用技术栈，支持100%代码开放，支持二次开发，不会被任何服务商绑架
公司化运作，项目是公司级商业运营项目，是项目持续化迭代与支持服务的重要保障
技术支持，支持项目推进的团队属于行业行业资深人员
扩展性思考，项目属于企业数字化转型的其中一部分，吸取钉钉、飞书、等大平台的很多经验借鉴，且对互联网、C端相关的能力做了大量裁剪与调整，吸收了大量的to B的产品设计的思路与经验。
核心功能： 集成多种文件编辑器（富文本编辑器、在线表格、在线脑图、在线流程图、MarkDown、XMind等，编辑器还将持续扩展）
多种文件的预览解析（PDF、Word、PPT、Excel等多种文件预览）
核心文档的协同编辑（富文本与在线表格）支持多种角色协同（成员、管理者、所有者）
历史版本回溯，可任意切换历史版本
提供企业级搜索引擎（基于标题、基于内容）
支持OCR图片识别搜索
支持文档内容评论与文档收藏
支持文档分享（密码二次校验设置）
支持新增文档模板，添加模板后在模板市场选择使用
企业级组织构架与权限管理（刚性组织+柔性群组）文档权限自定义
企业文档通过对文库的配置管理，实现权限、人员、分享范围等多种设置，可以自定义文档用户组，对文库、文档的详细操作可以定制授权 双屏辅助编辑
同屏操作，左侧编辑区，右侧搜索引擎+内容预览，基于内容的搜索、文档查看，便于对容的对比，支持富文本、Word、Excel、PPT等编辑。
文档管理： 支持富文本（类word）、脑图（类Xmind）、流程图（类viso）
文档的增删改查、文档在线编辑、上传（批量上传）、下载
文档的分享设置
富文本编辑： 文本大纲，小标题导航
支持所见即所得
支持表格
支持图片、表格、三方应用、音频、视频、等富文本表达插件
支持代码块、引用
支持源代码查看
技术栈选择 前端：VUE+Element-ui
后端：spring_cloud_alibaba、spring boot、Mybatis plus、Nacos、RabbitMq、Xxl-job
数据：Mysql、ElasticSearch、Redis、MariaDB（根据情况）
运维：K8S+docker
开源地址：https://gitee.com/software-minister/jvs-knowledge-ui
在线demo：http://knowledge.bctools.cn/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fd39424bc3b81cd94b8b9c6e07ab03f/" rel="bookmark">
			关于django(django-vue-admin)设置Debug为false后，导致线上静态资源目录media返回404问题解决。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当把django的debug设置为False后，会引发media下的图片等静态资源文件，直接访问会返回404的解决办法：
在application\urls下面修改：
# 1. 引入这个 from django.views.static import serve as static_serve urlpatterns = ( [ re_path( r"^swagger(?P&lt;format&gt;\.json|\.yaml)$", schema_view.without_ui(cache_timeout=0), name="schema-json", ), # 2.添加 这个re_path路由。 re_path(r'^media/(?P&lt;path&gt;.*)$', static_serve, {'document_root' : settings.MEDIA_ROOT}), # ... 其他 path("api/system/", include("dvadmin.system.urls")), ... settings.MEDIA_ROOT 的指，我这里是: MEDIA_ROOT = “media” # 项目下的目录
原理：原因是因为关闭DEBUG模式后，Django 便不提供静态文件服务了。需要我们手动去设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a983d7b4958ba6472565afab606ff9d4/" rel="bookmark">
			Spring如何整合MyBatis框架？使用XML及java类的配置方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Spring文章链接: 从头到尾Spring概念，家族，核心技术使用，事务这一篇就够了！！！_千小半的博客-CSDN博客_spring最新技术
mybatis文章链接: MyBatis框架入门(含实例)_mybatis sqlsession创建和关闭_千小半的博客-CSDN博客
一、Spring整合Mybatis框架思路 用过Mybatis的伙伴们因该知道当我们去使用Mybatis去进行数据访问时，不仅有三个重要步骤，还有三个核心对象，这里简单重温一下Spring和Mybatis:
MyBatis使用步骤:
1.创建MybatisConfig 配置文件
2.创建SQL映射文件
3.读取配置文件，获取映射器调用方法测试
MyBatis的三个核心对象：
1.SqlSessionFactoryBuider ：创建SqlSessionFactory
2.SqlSessionFactory : 创建SqlSession
3. SqlSession :获取mapper映射器并调用方法
Spring IOC容器和AOP:
spring 将所有的对象都交由spring/IOC容器管理，被管理的对象都称为bean。这些bean都在spring配置文件中进行配置。
好了，小半列出上面的温习及步骤，友友们是不是想起来了Mybatis呢?那么我们最终要让spring和mybatis进行一个整合，这两个框架都有配置文件，我们该怎么把他们合二为一呢，请看下图:
IOC容器也就是spring配置文件需要配置的属性和扫描的信息:
1.SqlSessionFactoryBean : 在mybtais-spring的整合包中,可以生成一个SqlSessionFactory,而前者可以创建出SqlSession,也就自然通过mapper映射器可以调用指定方法,通过该类还可以对Mybtais进行配置别名等。
2.数据源: 通过dbcp包提供的BasicDataSource类进行数据源的一个配置.
3.数据映射器类:使用XML配置文件时，需要扫描mapper映射器,反之，使用注解扫描。
4. 事务管理器 : 在spring容器中，开启事务控制需要先通过springFramework.jdbc包下的DataSourceTransactionManager类​​​​​​​配置事务管理器，它控制着事务的开关。
以上的4个类就是需要我们在spring整合mybatis配置的bean，关于整合的配置，以下有XML和java类配置的方式。
二、XML整合Mybatis 1.数据源的外部引入 数据源我们都要配置url,username等连接信息，要想达到数据源的复用性，不想每回都重新配置一遍，就可以通过properties属性文件外部引入数据源。
- db.properties文件
注意：使用spring引入外部属性文件时，前缀必须用jdbc标记。
jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.username=root jdbc.password=root jdbc.url=jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai - spring配置XML文件
注意: 要想识别数据源，需要先使用以下标签扫描该数据源文件的路径
&lt;context:property-placeholder location="db.properties"/&gt;
开始配置!!!!
MapperFactoryBean类：能够以配置的方式生成映射器的实现类,并注入给业务组件（类型只能是接口类型)
&lt;!--创建bean--&gt; &lt;bean id="studentService" class="service.StudentServiceImpl"/&gt; &lt;!--利用MapperFactoryBean类扫描mapper接口--&gt; &lt;bean id="factoryBean" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.StudentMapper"/&gt; &lt;/bean&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a983d7b4958ba6472565afab606ff9d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34aeafeea5e77dd2af51ab06b06f8340/" rel="bookmark">
			使用Paramiko时遇到的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.背景
2.问题合集
1）“bash: command not found”
2）Paramiko中正常的输入，却到了stderr，而stdout是空
3）命令实际是alias
1.背景 在自动化脚本中，使用了库Paramiko，远程SSH到后台服务器上做一些操作。常用操作都OK，但部分命令还是出现有一些问题。
2.问题合集 1）“bash: command not found” 关于这个问题，网上已经有很多文章给了原因和解决方法。
原因 默认的paramiko.SSHClient()不以“登录”模式运行shell，也不为会话分配伪终端。所以，对于非交互式会话中，.bash_profile没有来源，获取不到环境变量。
解决方案 原始命令：curl http://locahost:8081
最简单方法：
ssh.exec_command("bash --login -c 'curl http://locahost:8081'") 参考 使用 Python Paramiko exec_command 执行时，某些 Unix 命令失败并显示“&lt;command&gt; not found”答案 - 爱码网
paramiko连接centos7使用某些命令提示command not found_神经娃娃的博客-CSDN博客_paramiko bash: 未找到命令
使用paramiko中 Server not found in known_hosts的错误解决_weixin_34038652的博客-CSDN博客
2）Paramiko中正常的输入，却到了stderr，而stdout是空 目前也不知道为什么Paramiko会把这个命令的输出，收集在了stderr中。不过，也还是有办法。例如：
原始命令：curl http://locahost:8081。输出的stderr中。
解决方法 将stderr的内容重定向到stdout。
ssh.exec_command('curl http://localhost:8081 2&gt;&amp;1') 参考 在Paramiko中执行curl时，它的输出是stderr，而不是stdout - 问答 - 腾讯云开发者社区-腾讯云
Linux如何在Bash中将标准错误stderr重定向到stdout标准输出 - 腾讯云开发者社区-腾讯云
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34aeafeea5e77dd2af51ab06b06f8340/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac7e8c2356d9488fa6023ed647680586/" rel="bookmark">
			verdi基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 生成波形：要VCS 与 verdi 联合仿真，需要在tb_top中加入如下代码，否则不会生成波形文件
`ifdef FSDB initial begin $fsdbDumpfile("wave.fsdb"); $fsdbDumpvars; end `endif 2. Verdi基本操作(大写：shift+)
g get, signlas添加信号，显示波形
n next, Search Forward选定信号按指定的值（上升沿，下降沿，both,指定Value）向前跳转
N 与n功能相同，方向向后
y Keep Cursor at Centor（开关）移至中央并保持居中，再按取消固定居中
c color,调整所选信号的波形显示颜色，线的粗细和类型，非常方便Debug
z Zoom Out波形缩小，一般配合鼠标放大非常方便
Z Zoom In 波形放大
f full, Zoom All波形全部显示
h hierarchy显示信号的绝对路径
m move将信号移动到黄线位置
L 重新加载波形或设计文件，这个很方便，在新一次仿真完成之后Roload即可
M : 波形标记
在代码窗口，单击选中信号，此时处于高亮状态，按Ctrl+w，可以将信号发送到波形窗口
3、鼠标：
左键：用于选择信号
右键：调出菜单
中间：单击移动黄线，拖动信号可移动位置排列顺序
滑轮：上下滚屏
左键圈定波形范围：按选定缩放
双击信号波形： 跳转到代码，并用绿色高亮该信号
双击信号：按位展开(expand)，Struct展开下一层。
再双击折叠(collapse)右键信号名-&gt;Bus Operations-&gt;Expand as Sub-bus-&gt;可以按指定位宽展开，比如512bits的信号分成4个128的，方便查看
4、使用Verdi查看Delta Cycle的方法:
命令行中加入命令一起仿真：+fsdb+delta
打开波形，首先鼠标左键选择需要展开的时间点，然后按下图所示的选项展开这个时间点，可以看到在这个时间点上，信号变化的先后顺序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a220508f4ebd8f02fd2b4737b3163911/" rel="bookmark">
			自动控制原理06--控制系统设计与校正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6.1系统性能指标与校正 串联校正：校正装置串联在系统前向通道中。
反馈校正:校正装置设置在系统的局部反馈回路上。
前置校正：在系统反馈回路之外的校正方式。
扰动补偿：校正装置直接或间接对扰动信号进行测量，变换后接入系统。
超前校正装置:输出信号相为超前于输入相角，具有正的相角特性（相角越大越超前，就像百米赛跑，跑的越远，就在越前面）。
滞后校正装置：输出信号相位滞后于输入信号，具有负的相角特性。
超前滞后校正装置：在一段频率具有正相角特性，在另一段频率内有负相角特性。
6.2 PID控制（proportional–integral–derivative control ） 优点：控制简单、使用方便、适应性强、鲁棒性强
P（比例控制作用） 有差控制
这里简单说明一下有差与无差的概念，有差就是指设定值与实际值存在偏差，否则为无差
P只对e起到比例放大的作用，故当e=0时输入=输出，相当于控制器不起作用，只有当e不为零时，输入输出才有变化，即P具有控制作用，故为有差控制
特点：
使系统开环增益增大，减少系统稳态误差（因为稳态误差计算中K做分母），提高系统控制精度（误差小，精度自然高）
系统剪切频率增大，响应速度加快
系统相角裕量减小，稳定性变差（因为一般相频特性成下降趋势，频率越往后后相角越小）
只可改变零极点分布，不可削弱不良极点的作用
I（积分控制作用） 无差调节
误差的叠加，当误差为零时，调节器有一个稳定输出的值，即调节后设定值与实际值没有误差
积分控制具有“记忆”功能，系统既能保证稳态，又能实现无差控制；
减小稳态误差，提高控制精度（由于积分控制可以提高系统的型号）
单独使用容易造成系统不稳定
D（比例-微分控制作用） 有差控制
微分控制具有“预见”性，系统可以产生有效的提前修正作用。
任何情况都不能单独使用，必须PD或者PID
PD 特点：
提高系统剪切频率，提高系统响应速度。（Kp）
增加稳态裕量，提高系统的相对稳定性（Kd）
高频段增益大，抗干扰能力减小(Kp)
PID 特点：
低频段由于积分器作用，提升系统型号，稳态性能提升
中频段由于比例微分作用，剪切频率增大，响应速度提升，相角裕度增大，相对稳定性提升
PID为带通滤波器，PI为低通，PD为高通
6.3校正装置及其特性： 无源超前校正装置：稳态输出相角超前于输入
传递函数：
a=
需要串联一个放大器
无源滞后校正装置：稳态输出相角滞后输入
传递函数：
特点：beta越大抑制噪声能力越强，适用于高精度，响应速度不高的系统
注意图像的正确运用
6.4频率法进行串联校正 超前校正： 原理：利用超前装置的正相角特性，增大系统的相角裕度，利用超前装置的幅频特性的正幅值来增大系统剪切频率，改善系统的稳定性与快速性。
特点：
不改变低频段的特性，即稳态误差不变
截止频率将变大，频带变宽，系统响应速度加快
校正后高频段幅值增加，抗干扰能力变差
适用范围：
适用于相角裕量小于期望值，开环剪切频率小于期望值，且中频段相角下降速度不大的系统，即补偿值&lt;60度左右
滞后校正： 原理：
利用滞后校正装置高频段衰减特性，减少系统中频段幅值，使得系统剪切频率变小，挖掘系统自身相角储备，从而增大系统相角裕量。
特点：
牺牲响应速度提高系统相对稳定性，减小了系统超调量
一般不改变低频段的斜率，不影响动态性能的前提下，提高稳态精度
抑制高频干扰
适用范围:
适用于中频段相角急剧下降，开环剪切频率大于期望值，或开环剪切频率无要求的系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a220508f4ebd8f02fd2b4737b3163911/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b7f593e93534cfb0a153a3ac860b24b/" rel="bookmark">
			复杂网络|耦合映像格子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		耦合映像格子模型
写在前面，可以帮忙复现这方面的文章，如下文所示。 相继拥堵在现实网络中，对于系统平稳运行的破坏能力和影响很大。因此需要对相继拥堵的产生、扩散、预防、控制做深入研究，以便能够将影响降低到最小程度，并且争取能在最短时间内进行有效的疏导。为了更好地描述系统的变化，学者 K Kaneko 等人提出了耦合映像格子（Coupled Map Lattice，CML）模型，用来描述具有一定耦合作用的节点之间的时间空间状态关联是十分形象和恰当的。这个模型可以描述一个时间和空间都离散，而状态保持连续的非线性动力学系统。模型能够从本质上描述系统的复杂时空特性，并且降低了运算的复杂程度，是研究具有混沌特性的节点组成的网络系统状态变化的有效工具和手段。
生活中，交通网络是时常发生拥堵的，一般拥堵发生都需要经过一段时间之后交叉口或者路段才能恢复畅通，而且相邻路段的其他节点也会受到拥堵的影响，因此，交通网络通常被看作是考虑时间和空间的系统。
假设将城市交通网络抽象成由N个节点和若干条边组成的复杂网络；并且，复杂网络每个节点在任意时刻的状态是不连续不可逆的。网络中节点按照一定的耦合规律进行连接。在研究网络节点的状态变化过程中，采用耦合映像格子理论建立级联失效仿真模型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce81ceb3703c8bb81abe221240447031/" rel="bookmark">
			用IDEA设计登录页面完成假登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.检查web项目是否部署到tomcat服务器 2.在index.jsp首页中添加一个a标签，跳转到登录页面。 注意：ctrl+超链接标签可以跳转到登录页面
3.创建一个login.jsp作为登录页面，书写form表单指定提交地址和提交方式。 注意创建login.jsp
4.在web.xml中配置servlet的映射关系 5.创建一个Java类继承HttpServlet，在doPost中获取请求参数 Requset和Response
从编写Servlet的过程中可以看出，doGet()或者doPost()方法中有两个参数，分别是HttpServletRequest和HttpServletReponse对象中。
1.Servlet容器接受到来自客户端的HTTP请求后 ，容器会针对该请求分别创建一个HttpServletRequest对象和HttpServletReponse对象。2.容器将HttpServletRequest和HttpServletResponse对象以参数的形式传入service()（或者doGet()/ doPost())方法内，并调用该方法。3.在service() 或者（doGet()/ doPost()）方法中Servlet通过HttpServletRequest对象获取客户端信息以及请求相关信息。4.对HTTP请求进行处理5.请求处理完成后，将响应信息封装到HttpServletReponse对象中。6.Servlet容器将响应信息返回给客户端。7.当servlet容器将响应信息返回给客户端后，HttpServletReponse对象和HttpServletRequest对象被销毁。 通过以上流程可以看出，HttpServletRequest和HttpServletReponse是Servlet处理HTTP请求流程中最重要的两个对象。HttpServletRequest对象用于封装HTTP请求信息，HttpServletReponse对象用于封装HTTP响应信息。
获取请求的参数：根据请求参数的name属性获取提交的值 注意要：为了防止乱码需要加上UTF-8
​​​​​​
给前端做出响应 综合案例：
package com.chen.servlet; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class Login extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println("login...doGet"); doPost(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println("login...doPost"); //获取请求地址的四个方法 String requestURI = req.getRequestURI();//项目名称/资源 StringBuffer requestURL = req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce81ceb3703c8bb81abe221240447031/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df7083c3eda9dd6bc7401c31bb282bad/" rel="bookmark">
			Centos配置DNS服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主DNS服务器：
IP地址 : 192.168.101.10/24 DNS：192.168.101.10
备DNS服务器：
IP地址：192.168.101.20/24 DNS: 192.168.101.10
要求：【利用 bind9 软件，1配置 Linux1 为主 DNS 服务器，采用 rndc 技术提供不间断 的 DNS 服务；2配置 Linux2 为备用 DNS 服务器，为所有 Linux 主机提供冗余 DNS 正反向解析服务。】
主机器DNS配置 配置静态IP 配置静态IP为192.168.101.10/24 DNS为191.168.101.10
vim /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE="Ethernet" PROXY_METHOD="none" BROWSER_ONLY="no" BOOTPROTO="static" #将dhcp修改为static DEFROUTE="yes" IPV4_FAILURE_FATAL="no" IPV6INIT="yes" IPV6_AUTOCONF="yes" IPV6_DEFROUTE="yes" IPV6_FAILURE_FATAL="no" IPV6_ADDR_GEN_MODE="stable-privacy" NAME="ens33" UUID="e493a4a8-5777-412c-9497-6a2631bffcd1" DEVICE="ens33" ONBOOT="yes" #将yes修改为no IPADDR=192.168.101.10 #服务器IP NETMASK=255.255.255.0 #子网掩码 GATEWAY=192.168.101.2 #网关地址 DNS1=192.168.101.10 #DNS [root@192 ~]#systemctl restart network //重启网卡命令 配置本地yum源 cd /etc/yum.repos.d #切换到yum源路径配置 //本地yum源模板文件 CentOS-Linux-Media.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df7083c3eda9dd6bc7401c31bb282bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/907ffabd09386deba7c456fd6bf59045/" rel="bookmark">
			matlab常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ctrl+c：中断程序运行，这个在大型的系统级仿真中是超级好用的一个命令，因为使用m文件控制使simulink进入仿真系统后，simulink的仿真界面在运行中无法断，这个使用使用ctrl+c便可以解决这个问题，好用非常好用的命令，大家要记得奥，划重点词汇
ctrl+f：又是一个好用的命令，在搭建了控制模型和物理模型后，通常都要创建很多个m文件以及mat文件保存变量，经常会碰到需要查找某个变量的位置，用ctrl+f。缺点就是，只能搜索“编辑器”窗口的当前文件和“命令行”中的代码，无法在具有多个文件的工程里搜索某个变量或文本。
ctrl+shift+f:这个也是用于变量的查找，跟ctrl+f相比，这个的区别是会寻找整个文件夹，而ctrl+f只在当前文件夹下查找。ctrl+shift+f命令，可以实现对整个matlab项目文件的搜索，相当于全局搜索，搜索范围更广。
ctrl+r：注释，即在m文件中写上又不会被当成代码被编译的部分
ctrl+t：取消注释，是ctrl+r的反向操作。
小甜点提示：%%的注释是为了区分一段代码和另一段代码，而%则只注释掉编写内容，这个是写程序是否规范的一点体现，如果比较规范的区分一段代码和另一段代码，将大块的内容用%%分开，则写好代码后进入发布--》发布，可以查看到逻辑清晰的代码 ctrl+d：打开所选内容。一般情况下，选中需要打开的内容，按下快捷键，如果matlab中有定义这个内容，就可以进入进入选中内容的定义部分，常用于matlab某些函数的查看。
ctrl+i：智能缩进。首先选中某一段程序或全部程序，然后按下ctrl+i，智能缩进。常用于对代码的格式调整，调整为matlab标准的缩进格式，使matlab代码看起来更规范，可读性更强。
F1：关于所选内容的帮助。在程序中，选中某个函数或变量，然后按下F1键，相当于查看这个函数或变量的官方解释，功能与在命令窗口执行 help+某函数名，效果一样。
F9：执行所选内容。在程序中，选中某段程序或某个语句，按下F9，相当于对所选内容进行了单步执行，其他未选中程序部分不进行执行，非常方便调试使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2a1838f14f34620034c5b29a87e1599/" rel="bookmark">
			CTFHub技能数签到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		emmmmmm
这个题目纯纯的白给啊
1.开启题目后点链接。
2.啥都没有，只有双手奉上flag。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d71f0e1357fe192bc24c9ff97f7ec6c/" rel="bookmark">
			ESP-IDF:TCP多线程并发服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核心代码： 核心思想就是主线程只处理socket监听功能，把数据处理部分分配到不同的线程中去处理。来了一个客户端连接，就分配新的线程去处理该客户端的数据请求。
代码： /多线程并发服务器/
#include &lt;stdio.h&gt;
#include “sdkconfig.h”
#include “freertos/semphr.h”
#include “esp_system.h”
#include “esp_spi_flash.h”
#include &lt;string.h&gt;
#include “freertos/FreeRTOS.h”
#include “freertos/task.h”
#include “freertos/event_groups.h”
#include “esp_system.h”
#include “esp_wifi.h”
#include “esp_event.h”
#include “esp_event_loop.h”
#include “esp_log.h”
#include “nvs_flash.h”
#include “sdkconfig.h”
#include “lwip/err.h”
#include “lwip/sys.h”
#include “mdns.h”
#include &lt;sys/param.h&gt;
#include “esp_event.h”
#include “esp_netif.h”
//#include “protocol_examples_common.h”
#include “lwip/sockets.h”
#include &lt;lwip/netdb.h&gt;
/* The examples use WiFi configuration that you can set via ‘make menuconfig’.
If you’d rather not, just change the below entries to strings with
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d71f0e1357fe192bc24c9ff97f7ec6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d105d0fbd6e001707bd5f7c8462cd77/" rel="bookmark">
			手机截图如何提取文字？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今信息爆炸的时代，图文并茂已经成为了一个广告宣传的常用方式。然而，图片中的文字信息往往难以获取，尤其对于那些需要快速获取信息的人们来说，阅读图片中的文字会是一项繁琐且费时的任务。现在，我们有一个好消息要告诉大家：通过使用我们的图片文字提取工具，您将能够轻松地提取图片中的文字信息。
//在线工具地址 https://ocr.bytedance.zj.cn/image/ImageText 我们的图片文字提取工具使用了先进的技术，可以快速准确地从图片中提取文字信息。您只需要将图片上传到我们的平台，然后工具就会自动识别图片中的文字，并将其转化为可编辑的文本格式，方便您进行编辑、存储和分享。
使用我们的图片文字提取工具，您可以获得以下的好处：
节省时间：通过使用我们的工具，您可以轻松地从图片中提取文字信息，节省了繁琐的手动输入时间。
方便编辑：将图片中的文字转化为文本格式后，您可以方便地进行编辑，修改或复制粘贴。
可搜索：将图片中的文字转化为文本格式后，您可以使用搜索引擎或文本编辑器轻松地搜索和查找信息。
适用范围广：我们的工具适用于多种场合，比如从图片中提取电话号码、地址、电子邮件、条形码等等。
高精度：我们的工具采用了最先进的OCR技术，可以快速准确地从图片中提取文字信息，避免了传统OCR技术中的错误和漏识别问题。
我们的图片文字提取工具适用于多种行业，比如广告、市场营销、文档处理、图书馆、医疗、金融等等。不管您是从事什么行业，只要您需要从图片中提取文字信息，我们都可以为您提供便捷高效的解决方案。
使用我们的图片文字提取工具非常简单，您只需要三步即可完成：
将需要提取文字信息的图片上传到我们的平台。
等待我们的工具自动识别图片中的文字，并将其转化为文本格式。
下载转化后的文本文件，开始您的编辑、存储和分享。
我们的图片文字提取工具将帮助您提高工作效率，减轻工作压力。欢迎您使用我们的工具，让我们一起走进一个高效智能的时代！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a78718122ab661ca80d462f9c18424af/" rel="bookmark">
			Spring Boot集成Quartz实现定时任务的动态创建、启动、暂停、恢复、删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、整个 Quartz 的代码流程基本基本如下：
首先需要创建我们的任务(Job)，比如取消订单、定时发送短信邮件之类的，这是我们的任务主体，也是写业务逻辑的地方。
创建任务调度器(Scheduler)，这是用来调度任务的,主要用于启动、停止、暂停、恢复等操作，也就是那几个api的用法。
创建任务明细(JobDetail)，最开始我们编写好任务(Job)后，只是写好业务代码，并没有触发，这里需要用JobDetail来和之前创建的任务(Job)关联起来，便于执行。
创建触发器(Trigger)，触发器是来定义任务的规则的，比如几点执行，几点结束，几分钟执行一次等等。这里触发器主要有两大类(SimpleTrigger和CronTrigger)。
根据Scheduler来启动JobDetail与Trigger
二、进入正题，引入依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt; 三、创建Job 需实现Job接口，这个接口就一个execute()方法需要重写，方法内容就是具体的业务逻辑。如果是动态任务呢，比如取消订单，每次执行都是不同的订单号。
这个时候就需要在创建任务(JobDetail)或者创建触发器(Trigger)的那里传入参数，然后在这里通过JobExecutionContext来获取参数进行处理，
package com.example.demo.mquartz; import org.quartz.DisallowConcurrentExecution; import org.quartz.Job; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; import java.text.SimpleDateFormat; import java.util.Date; /** * @Auther: wsj * @Date: 2023/2/15 14:38 * @Description: TestJob * @Version 1.0.0 */ @DisallowConcurrentExecution//Job中的任务有可能并发执行，例如任务的执行时间过长，而每次触发的时间间隔太短，则会导致任务会被并发执行。如果是并发执行，就需要一个数据库锁去避免一个数据被多次处理。 public class TestJob implements Job { @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { System.out.println(jobExecutionContext.getJobDetail().getJobDataMap().get("name")); System.out.println(jobExecutionContext.getJobDetail().getJobDataMap().get("age")); System.out.println(jobExecutionContext.getTrigger().getJobDataMap().get("orderNo")); System.out.println("定时任务执行，当前时间："+ new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date())); } } 四、创建任务调度器(Scheduler) 这里采用Spring IOC，所以直接注入完事。如果是普通的，则需通过工厂创建。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a78718122ab661ca80d462f9c18424af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f34c13883eb75f288926dd8dfc084eb/" rel="bookmark">
			Xpath利用兄弟节点找到父节点再定位子节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要定位数据源下的下拉框，先找到数据源的父节点/..
//label[text()="数据源"]/..
再找到要定位的元素
如果仍然不能唯一定位，找到唯一的子节点后，再往上找父节点
//label[text()="数据源"]/..//i[@class="bfui-sceneeditor-icon-warning bf-warning-md"]/..//div[@class="bfui-select-header"]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c9bb43fb3fa4650b4774c39b6c208ab/" rel="bookmark">
			update set num=num&#43;1 是否具有原子性?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载自 https://blog.csdn.net/silyvin/article/details/79294508?tdsourcetag=s_pctim_aiomsg
结论:
这条语句本身是原子性的
2. 当前读（包含update等写入操作）锁定数据，直到事务提交 这个其实就是关系型数据库本身就需要解决的问题。 首先，他们同时被MySQL执行，你的意思其实就是他们是并发执行的，而并发执行的事务在关系型数据库中是有专门的理论支持的-ACID，事务并行等理论，所有关系型数据库实现，包括Oracle，MySQL都需要遵循这个原理。 简单一点理解就是锁的原理。这个时候第一个update会持有id=1这行记录的排它锁，第二个update需要持有这个记录的排它锁的才能对他进行修改，正常的话，第二个update会阻塞，直到第一个update提交成功，他才会获得这个锁，从而对数据进行修改。 也就是说，按照关系型数据库的理论，这两个update都成功的话，id=1的number一定会被修改成22。如果不是22，那就是数据库实现的一个严重的bug。 如果想要深入了解，可能你要预读一下数据库与事务处理 (豆瓣)了。 粗浅一点的，可以先看一下如果有人问你数据库的原理，叫他看这篇文章和英文原文How does a relational database work 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/379c728ad26a9f84a7938755c69b59c0/" rel="bookmark">
			JAVA数据转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、JSON数组转List对象
List&lt;User&gt; list = JSONObject.parseArray(jsonArray, User.class); List转JSONArray
List&lt;User&gt; users = new ArrayList&lt;User&gt;(); JSONArray json = JSONArray.fromObject(users); List转JSONObject
JSONObject jsonObj = new JSONObject(); jsonObj.put("users", users); 2、JSON字符串转对象
User user = JSON.parseObject(jsonString, User.class); 3、Map转JSON字符串
Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); String jsonString = JSON.toJSONString(paramMap); //方法2 map中含有对象 Map&lt;String,Car&gt; map = new HashMap&lt;String, Car&gt;(); map.put("a",new Car()); String json = JSON.toJSONString(map,true); 4、Map转JSONObject
// 方法1 Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); JSONObject json = new JSONObject(paramMap); // 方法2 JSONObject json = JSONObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/379c728ad26a9f84a7938755c69b59c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c241e3628722f2312aaa29378cfaa59e/" rel="bookmark">
			【记录】smartctl｜Linux如何通过smartctl查看有没有坏的磁盘？以及使用时长、电源周期、故障记录等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		smartctl是一个用于监测和分析硬盘健康状态的工具，可以用于检测是否存在坏的磁盘。以下是使用smartctl检查磁盘健康状态的步骤：
安装smartctl软件
在Linux系统中，smartctl通常包含在smartmontools软件包中。如果您还没有安装smartmontools，可以使用以下命令安装（大部分NAS自带，如TrueNas）：
sudo apt-get install smartmontools # Debian/Ubuntu sudo yum install smartmontools # RedHat/CentOS 查找磁盘设备名称
使用以下命令查找磁盘设备名称：
sudo fdisk -l 运行smartctl检查磁盘
使用以下命令运行smartctl检查磁盘：
sudo smartctl -a /dev/sda 将/dev/sda替换为您要检查的磁盘设备名称。该命令将列出有关磁盘健康状态的详细信息，包括错误计数和预测故障时间等。请注意，您可能需要使用root权限才能运行smartctl。
检查smartctl输出
在smartctl输出中查找关于磁盘健康状态的信息。重点关注以下字段：
SMART overall-health self-assessment test result：如果该字段的值为“PASSED”，则磁盘没有发现健康问题。如果该字段的值为“FAILED”或“UNKNOWN”，则磁盘存在健康问题。
Reallocated_Sector_Ct：这是已经重新分配的扇区的数量。如果该值不为0，则磁盘存在坏扇区。正常情况的RAW_VALUE如下：ID# ATTRIBUTE_NAME FLAG VALUE WORST THRESH TYPE UPDATED WHEN_FAILED RAW_VALUE 5 Reallocated_Sector_Ct 0x0033 100 100 010 Pre-fail Always - 0 Current_Pending_Sector：这是目前正在等待重新分配的扇区数量。如果该值不为0，则磁盘存在潜在的坏扇区。 如果smartctl输出中没有发现健康问题，那么磁盘应该是正常的。否则，您可能需要更深入地分析问题或考虑更换磁盘。
以下是我个人在检测过程中遇到的一些问题。
文章目录 1 什么情况下需要使用`smartctl -t`？2 如何查看我的磁盘的类型，以及其支持的SMART属性？3 电源周期和故障计数怎么看？4 在输出信息里没有看到Error_Counters属性？5 Seek_Error_Rate非常多是正常的吗？ 1 什么情况下需要使用smartctl -t？ smartctl命令的“-t”选项用于执行一次磁盘自检测，以便发现磁盘上的任何潜在问题。使用“-t”选项后，smartctl将在后台启动自检测，并在完成后提供结果。因此，如果您想要获得磁盘的最新自检测结果，您需要使用“-t”选项运行smartctl。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c241e3628722f2312aaa29378cfaa59e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76737cefcf8b2eb29f4f4144c0f7e0a6/" rel="bookmark">
			DELL游匣ubuntu2004系统 RTX3060显卡，cuda11.4，cudnn8.2.4安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装Ubuntu2004的系统
2.驱动安装前的准备工作
第一步：修改设置下载源~阿里源。在Software Updater在第一栏Ubuntu Software页面中，找到Download from，选择-&gt;China-&gt;mirrors.aliyun.com,点击确认。
第二步：sudo apt-get update 更新软件列表
sudo apt-get upgrade 本地安装软件与本地软件列表对比，如本地安装版本低，会提示更新
第三步：安装相关依赖
sudo apt-get install g++
sudoapt-get install gcc
sudoapt-get install make
sudo apt-get install build-essential
sudoapt-get install libc6-dev
第四步：禁用nouveau
sudo gedit /etc/modprobe.d/blacklist.conf #打开文件#
最后添加如下：
blacklist nouveau
blacklist vga16fb
blacklist rivafb
blacklist rivatv
blacklist nvidiafb
options nouveau modeset=0
保存后关闭文件，并执行以下命令更新系统，使禁用 nouveau 真正生效 sudo update-initramfs -u
lsmod | grep nouveau #重启电脑，无任何输出的话说明禁用成功了#
第五步：更新图形化界面
更换图像化界面是因为lightdm比gdm3的兼容性大
sudo apt-get install lightdm
sudo dpkg-reconfigure lightdm
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76737cefcf8b2eb29f4f4144c0f7e0a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d4c2784cac7523fc286f8683fd5bf84/" rel="bookmark">
			已经有211大学发布计算机专业，研究生复试上机考试说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机考研复试中，很多大学都会选择机试作为考试形式。机试即是上机考试，在电脑上完成实体，一般都是编写程序，使用OJ系统判断结果。
列举几个常见的OJ，其他OJ还有很多很多，可以去网上找一下。
Virtual Judge：
https://vjudge.net/
可以做各大OJ的题，也可以自己组
POJ：
http://poj.org/ 北大的老牌OJ
HDU：
http://acm.hdu.edu.cn/ 杭电的OJ
Leetcode：
https://leetcode.com/
面向求职者的刷题网站
OJ上面的题目一般是这样的：
我们可以在上面做题目练习。
可惜现在部分OJ平台关闭了，比如知名的杭电OJ：
https://www.zhihu.com/question/504154861/answer/2268846061
大部分大学在考研复试的时候会使用自己的OJ系统。我们有必要提前了解操作方法，也有必要提前做一下上面的题目（如果开放的话）
有一所211东华大学就公布了上机考试的说明，我们可以参考一下：
操作指南
一、注册
1、进入www.52ac.tech/oj（建议使用Google Chrome浏览器）
2、在登录窗口点“注册”，注意事项如下：
（1）学校名称：东华大学。输入时可以输入部分汉字然后在下拉框里选择（一定要选择，不能纯靠输入）。如下：
（2）学号：初试时的准考证号。
（3）姓名：请实名
（4）班级：复试
（5）登录账号：手机号或邮箱地址（推荐使用手机号）
（6）其它信息根据自己情况填写
3、填写完成后，点“确认”，然后登录。
二、加入班级
1、登录后，点菜单“加入班级”，如下图：
2、输入邀请码：UDMGTNLX，点确认，即提示加入成功。
三、查看练习题开始练习
1、点菜单“考试”，可以看到“在线考试操作示例”，以及其它的练习题（一套基本题、一套进阶题）。
以上填写信息保证红色文字部分正确即可，其它信息有误没关系。如果注册时，准考证号填写错误，按照以上操作步骤重新注册即可。
通知来源于：
https://cst.dhu.edu.cn/2023/0109/c12723a320257/page.htm
您还可以在以下平台找到我们
你点的每个在看，我都认真当成了喜欢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe1d7b9c4bcd2a8234489ac3db8e7a18/" rel="bookmark">
			Cobaltstrike系列教程(十)安装扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x000-前文 有技术交流或渗透测试培训需求的朋友欢迎联系QQ/VX-547006660，需要代码审计、渗透测试、红蓝对抗网络安全相关业务可以咨询我
2000人网络安全交流群，欢迎大佬们来玩
群号820783253
0x001-扩展的加载 扩展是Cobaltstrike一个极为重要的模块，它有效地丰盈了cobaltstrike的功能
选择菜单栏的CobaltStrike–&gt;脚本管理器，点击load，然后选择cna扩展文件即可，旁边的unload为去除该扩展，，reload为重新加载该扩展
0x002-个人常用扩展 本人在此放出几个自己常用的扩展，老哥们可以回复下载
0x003-其他扩展汇总(来自WBG老哥) 脚本名称：elevate.cna
脚本功能：增加五种提权方式
脚本名称：ProcessTree.cna
脚本功能：让ps命令可以显示父子关系并显示颜色
脚本名称：CVE-2018-4878.cna
脚本功能：CVE-2018-4878.cna
脚本名称：ArtifactPayloadGenerator.cna
脚本功能：创建多种类型的payload。生成的文件在cs目录下的opt\cobaltstrike
脚本名称：AVQuery.cna
脚本功能：查询目标所安装的所有杀软
脚本名称：CertUtilWebDelivery.cna
脚本功能：利用CertUtil和rundll32生成会话这个应该都知道了解
脚本名称：RedTeamRepo.cna
脚本功能：就是提示一下常用的渗透命令
脚本名称：ProcessColor.cna
脚本功能：显示带有颜色的进程列表(不同颜色有不同含义)
脚本名称：EDR.cna
脚本功能：检查有无终端安全产品
脚本名称：logvis.cna
脚本功能：显示Beacon命令日志
脚本名称：ProcessMonitor.cna
脚本功能：记录一段时间内程序启动的情况
脚本名称：SMBPayloadGenerator.cna
脚本功能：生成基于SMB的payload
脚本名称：Persistence/Persistence_Menu.cna
脚本功能：持久化控制集合
备注:这个脚本是同目录脚本的一个集合
脚本名称：Eternalblue.cna 脚本功能：ms17-010
https://gist.github.com/rsmudge/9b54a66744a94f3950cc171254057942
备注：调用exploit/windows/smb/ms17_010_eternalblue
更多:https://mp.weixin.qq.com/s/CEI1XYkq2PZmYsP0DRU7jg
个人认位这位老哥整理的已经很全面了，为了方便查看我将里面的一些集合脚本介绍图片列了出来。
https://github.com/harleyQu1nn/AggressorScripts
https://github.com/bluscreenofjeff/AggressorScripts
https://github.com/michalkoczwara/aggressor_scripts_collection
https://github.com/vysec/Aggressor-VYSEC
https://github.com/killswitch-GUI/CobaltStrike-ToolKit
https://github.com/ramen0x3f/AggressorScripts
https://github.com/rasta-mouse/Aggressor-Script
https://github.com/Und3rf10w/Aggressor-scripts
https://github.com/001SPARTaN/aggressor_scripts
https://github.com/gaudard/scripts/tree/master/red-team/aggressor
https://github.com/branthale/CobaltStrikeCNA
https://github.com/threatexpress/aggressor-scripts https://github.com/threatexpress/red-team-scripts https://github.com/threatexpress/persistence-aggressor-script
https://github.com/FortyNorthSecurity/AggressorAssessor
脚本来源:
https://github.com/rsmudge/ElevateKit
https://github.com/vysec/CVE-2018-4878 https://github.com/harleyQu1nn/AggressorScripts https://github.com/bluscreenofjeff/AggressorScripts https://github.com/ramen0x3f/AggressorScripts
https://github.com/360-A-Team/CobaltStrike-Toolset https://github.com/ars3n11/Aggressor-Scripts https://github.com/michalkoczwara/aggressor_scripts_collection https://github.com/vysec/Aggressor-VYSEC
https://github.com/killswitch-GUI/CobaltStrike-ToolKit https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe1d7b9c4bcd2a8234489ac3db8e7a18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653179f7a18604a5c759ecb8db7d1140/" rel="bookmark">
			navicat连接linux的mysql报错1045
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		navicat连接Linux的MySQL报错1045可能是因为以下原因之一：
用户名或密码错误：请确保您使用正确的用户名和密码登录MySQL。如果您不确定，请在终端中尝试登录MySQL并尝试更改密码。
权限问题：请检查您的MySQL用户是否具有足够的权限来连接到MySQL。您可以使用以下命令来检查：
mysql&gt;show grants for 'your_user'@'your_host'; 防火墙设置问题：请确保您的Linux服务器上的防火墙未阻止Navicat连接MySQL。请检查您的防火墙设置并确保允许MySQL连接。
MySQL配置问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489fbc904e73c9bc5c954c81640020d0/" rel="bookmark">
			你的 ChatGPT Not available in your country？教你如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ChatGPT Not available 文章目录 ChatGPT Not available问题描述解决方法一解决方法二教程图示方法一方法二 相关文章 问题描述 如果你使用科学上网却发现自己的页面上显示 OpenAI's services are not available in your country.，你可能会换其他地区，但是换过之后还是会显示同样的问题，如下图所示：
这可能令很多人都很困扰，为什么自己换了别的地区还是这样呢？那么接下来我将教大家怎么解决这个问题。
解决方法一 首先打开控制台 通用方法：在网页中点击 右键，选择 检查如果是 windows 系统，可以尝试 F12 或者有些电脑是 Fn + F12如果是 Mac 系统，可以尝试 Option + Command + I 然后选择 应用 或者如果是英文版的话就是 application接着在本地存储空间内选择有 openai.com 的那个条目最后找到以 @@auth 开头的键值对点击右键选择删除 解决方法二 首先打开控制台然后将以下代码复制并在控制台内粘贴后按回车即可 window.localStorage.removeItem(Object.keys(window.localStorage).find(i=&gt;i.startsWith('@@auth'))) 按以上操作后还要重新刷新页面，前提是你第一次用国内的打开，第二次换成别的地区打开，还是显示 Not available 才能用，如果你不会科学上网的话，那还是不行的 🙅‍♂️
教程图示 方法一 方法二 记得一定要再次返回登录一下才行
相关文章 可以关注我的这个专栏的其他文章。
从 0 开始最详细的部署自己的 chatgpt 微信机器人从 0 开始最详细的微信公众号接入 AI微信小程序接入 ChatGPT 实现 AI 画图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a6d87b059655d1a45bca1373cdab08e/" rel="bookmark">
			什么是幂等性操作？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所谓幂等是指不管进行多少次操作，结果都一样。
比如我用PUT修改一篇文章，然后在做同样的操作，每次操作后的结果并没有不同，DELETE也是一样。顺便说一句，因为GET操作是安全的，所以它自然也是幂等的。
GET操作是安全的。所谓安全是指不管进行多少次操作，资源的状态都不会改变。比如我用GET浏览文章，不管浏览多少次，那篇文章还在那，没有变化。当然，你可能说每浏览一次文章，文章的浏览数就加一，这不也改变了资源的状态么？这并不矛盾，因为这个改变不是GET操作引起的，而是用户自己设定的服务端逻辑造成的。
POST操作既不是安全的，也不是幂等的，比如常见的POST重复加载问题：当我们多次发出同样的POST请求后，其结果是创建出了若干的资源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fb11e5b7786c1fbf3161a2ef5f94a94/" rel="bookmark">
			@PathVariable 与 @RequestParam 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		共同点： 2个注解 都适用于restful 风格，@GetMapping @DeleteMapping @putMapping @PostMapping 我们需要注意的是：他们都是get 数据请求才能获取
区别：
@pathVariable :只能携带一个请求参数的情况 例如：xxx/xxxx/{id}
@RequestParam: 可以携带多个请求参数。但是也有限制 例如：xxx/xxxx/phone=xxx&amp;&amp;username=xxx
如果是Post 请求：
建议直接使用@RequestBody，将参数转换为对象传递，后台转换为map get获取，方便又美观 （作用于请求体）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eaf66fc40e893b8d905f58bc2381283/" rel="bookmark">
			开发中遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.当写一个导出功能时，因为编码写URL地址&amp;参数的时候，用反转字符串的时候换行了，造成地址拼接不成，一直报错，后来发现是编码格式造成的，已解决。
解决方案：不换行或者用 “+”拼接
2.当本地项目起两个终端的时候，会有两个地址：如http://localhost:9528 和http://localhost:9529 这样子，当你打开localhost:9529的时候会请求不到接口地址，报错，已解决。
解决方案：关掉一个终端，不用localhost:9529 这个地址，勇localhost:9528这个。
3.低代码平台搭建的项目，自定义页面编写按需求编写就可以，配置页面，需要问后端或者测试是否可以配置，配置的事情交给专业的人，就不会出错。菜单栏的配置页面，会有特定的字符串来跟低代码平台配置的一个字符建立连接，一般这个字段是唯一的。
4.通过地址栏传递参数，有的需要编码一下：encodeURIComponent(searchParams.Year)，有的就不需要。
拓展知识： encodeURIComponent：可把字符串作为 URI 组件进行编码。该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ’ ( ) 。其他字符（比如 ：;/?😡&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。
encodeuricomponent什么时候使用：用于url作为参数传递的场景中使用
url当作参数传递的时候，当参数出现空格这样的特殊字段，后台只可以读取到空格前的内容，后面内容丢失，造成数据读取失败，但是如果用encodeURIComponent()，则这些特殊字符进行转义，这样后台就可以成功读取了，所以encodeURIComponent()用于url作为参数传递的场景中使用。
decodeURIComponent() 函数可对 encodeURIComponent() 函数编码的 URI 进行解码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3977207066b3c639dda37ae5876da28b/" rel="bookmark">
			推荐 10 款炫酷的 IDEA 主题，百看不腻，个个经典！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 对于平常开发中用到最多的编辑器，我们工作大多数时间都盯着它，一款好的 IDEA 主题虽然不能提高我们的开发效率，但一个舒适的主题可以使开发人员更舒适的开发，时常换一换主题可以带来不一样的体验，程序员的快乐就这么简单。今天推荐用过的十款主题，每个都属于百看不腻型。
系统自带经典型 第一款 IntelliJ Light Theme 主题地址：
https://plugins.jetbrains.com/plugin/12697-intellij-light-theme
白底比较简约主题，因为是自带的，目测使用这款主题的占大多数。
第二款 Cyan Light Theme 主题地址：
https://plugins.jetbrains.com/plugin/12102-cyan-light-theme
这款是青亮色的主题，和上面纯白款一样的简约大气，只是风格变了，相信选择白款亮色主题的朋友没有人能拒绝这两款。
第三款 One Dark theme 主题地址：
https://plugins.jetbrains.com/plugin/11938-one-dark-theme
这是黑色款中比较钟意的一款，白色都看腻了偶尔也会换这款来体验一下～
第四款 Xcode-Dark Theme 主题地址：
https://plugins.jetbrains.com/plugin/13106-xcode-dark-theme
这款细节处理打满，很细腻的一款主题。
以上几款主题配色在plugin中都可以直接进行下载使用
下载后一般即刻生效，如果没有生效，在Color Scheme中可以修改选择下载的插件使用。
另辟蹊径，不一样的几款主题 第一款 Visual Studio Code Dark Plus Theme 主题地址：
http://www.jetbrains-active.com/theme/detail/6.html
习惯了微软的产品，也使用VS编辑器的话，可以使用这款主题。
第二款 Espresso Light Theme 主题地址：
http://www.jetbrains-active.com/theme/detail/31.html
灰白底暖色背景，为压抑的工作环境带来一些暖意。
第三款 Eclipse theme 主题地址：
http://www.jetbrains-active.com/theme/detail/49.html
Eclipse 经典怀旧款，满满的都是回忆！
第四款 Dark Candy UI Theme 主题地址：
http://www.jetbrains-active.com/theme/detail/66.html
这个黑背景+突出的字体颜色，看着很舒服，我目前使用这款主题！
第五款 Acme Theme 主题地址：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3977207066b3c639dda37ae5876da28b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fc27ca751c095546f1d107a52b1f317/" rel="bookmark">
			python linux 获取本机ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		未连接外网时获取本机ip方法 from subprocess import Popen, PIPE import re def get_ip_ifconfig(): p = Popen(['ifconfig'], stdout = PIPE) data = p.stdout.read().decode().split('\n\n') data = [i for i in data if i and not i.startswith('lo')] dic = {} # re.M 多行模式，改变'^'和'$'的行为 for line in data: re_devname = re.compile(r'(\w+).*: flags=', re.M) re_ipaddr = re.compile(r'inet ([\d\.]{7,15})', re.M) devname = re_devname.search(line) ip = re_ipaddr.search(line) if devname: devname = devname.group(1) else: devname = '' if ip: ip = ip.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fc27ca751c095546f1d107a52b1f317/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf8d253d0cde8f113bfeaf93f349694/" rel="bookmark">
			GRASP设计原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GRASP设计原则 介绍9种基本原则创建者 Creator问题解决方法何时不使用?好处 信息专家 Information Expert问题解决方法信息怎么做优点 低耦合 Low Coupling耦合问题解决方法原则何时不使用? 控制器 Controller问题解决方法外观控制器会话控制器 优点臃肿控制器的解决方法 高内聚 High Cohesion问题解决办法用法衡量概念之间相关度的两个指标内聚的最佳实践类低内聚 多态 Polymorphism问题解决办法推论 纯虚构 Pure Fabrication问题解决办法推论原则风险 间接 Indirection问题解决办法 隔离变化问题解决办法变化点的分类 介绍 GRASP(General Responsibility Assignment Software Pattern)是通用职责分配软件设计模式，它可以帮助设计人员理解面向对象设计的本质，并以一种有条理的、理性的、可解释的方式来运用这些原则。由《UML和模式应用》(Applying UML and Patterns)一书作者Craig Larman提出。
在面向对象设计的过程中一般的通用方式是构思对象的职责、角色和协作。通常来说，我们在编码过程中先分析问题域，从中抽象出对象解决问题。简单的面向对象和优秀的面向对象设计的区别在于如何更合理的划分对象的角色，给对象赋予合理的职责以及对象之间的交互关系。
GRASP是对象职责分配的基本原则，其核心思想是职责分配，用职责设计对象。
9种基本原则 创建者（Creator）信息专家（Information Expert）低耦合（Low coupling）控制器（Controller）高内聚（High Cohesion）多态性（Polymorphism）纯虚构（Pure Fabrication）间接性（Indirection）隔离变化（Protected Variations） 这些模式都是针对软件开发上的一些问题进行解决。发明这些技巧不是为了要创造新的工作方式，而是为在面向对象设计上，对经过测试的程序设计方式创建文档并且标准化。
Craig Larman提到：“软件开发最关键的设计工具不是UML或其他的技术，是明了设计原则的心智。”。因此，GRASP原则是心理层面的工具集，是面向对象软件设计学习的辅助工具。
创建者 Creator 问题 谁负责创建类的实例？
解决方法 满足下面一个选项，则由B来创建A：
B包含，聚集AB记录AB紧密使用 AB拥有A的初始化数据 若有一个以上的选项适用，则首选包含或聚集A的类。
注意：A和B都是软件对象，而不是领域对象。
何时不使用? 出于性能目的（缓存）而重用类的实例有些情况下要基于某些外部属性值从一个相似类的家族创建一个实例（抽象工厂模式）委托职责向下传递其他复杂情况 好处 使用方便高内聚低耦合 信息专家 Information Expert 问题 为一个对象分配职责的一般性原则是什么？
解决方法 若这个类拥有完成这个职责所需要的数据，则把这个职责分配给这个类。
信息 一个对象拥有的状态和一个对象相关的其他对象一个对象派生的信息等等 怎么做 明确地表达职责在设计模型中查看相关的类在领域模型中查看并创建设计类 优点 封装性：对象充分利用自身的信息，低耦合
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbf8d253d0cde8f113bfeaf93f349694/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed7afdbc8ebe8bb10e73f36a8a9eb4ba/" rel="bookmark">
			在Linux安装Tomcat和JDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备工作 1、在Linux系统下载环境配置命令 1、$ yum install -y gcc-c++ （Linux安装组件） ​	2、$ yum install -y pcre pcre-devel ​	3、$ yum install -y zlib zlib-devel ​	4、$ yum install -y openssl openssl-devel 5、$ yum install -y vim 修改背景颜色 ​	6、$ yum install -y wget 安装wget命令，可以通过wget命令下载需要的文件 ​	7、$ yum install -y lrzsz 安装上传文件命令 将上述命令复制到Linux系统页面直接回车即可下载，下图进行简单展示：
如下则表示安装完成：
2、在根目录下新建文件夹soft，用于存放之后的JDK、Tomcat等相关软件 3、此处提供一些Linux中常用命令 1. cd / 回到根目录 2. cd /usr 切换usr目录 （usr为存放下载软件的目录） 3. cd .. /.. 返回两级 4. pwd 查看绝对路径 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed7afdbc8ebe8bb10e73f36a8a9eb4ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/134ef9d7903b8cfe43cd0138064ad4bd/" rel="bookmark">
			拥有这种抽象能力，让你成为架构师
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		架构的核心是管理复杂度，架构师的核心能力是抽象能力，什么是抽象能力？抽象能力就是一种化繁为简的能力。何为化繁为简？就是把一种复杂的事情变得简单的能力，比如通过打比喻让别人很容易听明白你说的意思就是一种抽象能力。如何锻炼抽象能力？我觉得有三种方法，第一种是用归纳法找共性，从多个问题中找到共同的问题提炼通用解决方案，去其糟粕取其精华。第二种通过演绎法找关系，从多个问题中找关系，把多个问题串成一个问题，系统化解决问题！第三种是通过归纳法找特性。化繁为简需要不断的思考，不断的看清一件事的本质，这个事的解决方案越容易。
一、通过归纳法找共性
﻿通过归纳法找共性有两种方法，分别是找需求的共性和找信息的共性。
﻿1.1 找需求的共性
分期作为一个单一产品服务于海量亿级用户和全行业，但是各行业有很多的个性化需求，有限的技术资源不可能解决无限的行业个性化需求，所以必须对问题进行收敛，从一类需求中找到共性问题，找到最大交集然后求解。找需求的共性就是你收到一堆需求，你能分析出共同的需求是什么？比如用户说想吃香蕉、梨子、桔子和苹果等，那么共性的需求就是用户想吃水果。分期有商家贴息、部分贴息、第三方贴息和混合贴息等需求，共性需求就是灵活的贴息模式，然后基于这个共性的需求，推导出我们可以提供的技术服务或技术能力是什么，从而推导出系统架构，再比如各行业都想接入分期，但是都有些个性化的需求，那么我们是不是可以对个性化需求进行分类，提供几种标准的分期组件让各行业快速接入，比如小程序分期组件、H5版分期组件和JS版分期组件等。如果把这个问题再扩展下，作为技术要解决的问题也非常多且复杂，如果找共性需求，对所有技术问题进行收敛的话，可以收敛成三个基本需求，第一个是技术如何给业务带来护城河？第二个是技术如何给业务带来增量？第三个是技术如何保障业务安全运行？再延伸到经济活动，经济活动的本质或者核心需求是人类需求与服务供给的匹配，能交往和交流的人越多，匹配越容易匹配效率越高，人均GDP也越高，也就越富裕。
﻿1.2 找信息的共性
领域建模就是一种找信息共性的方法，领域建模首先就是要区分需求里哪些是变化的哪些是不变，把这个领域不变的信息沉淀成领域模型，基于领域模型做架构。分期在各个场景下可能衍生出不同的分期产品，如租房分期、汽车分期、家装分期和电商分期等，但其实共性都是通过组合额度、利率和还款方式等几要素产生不同的分期产品，比如电商分期额度较低、还款期限最长24个月，汽车分期则额度较高、还款期限可达3年。我们学习技术也是一样，所以技术的共性是什么，我觉得是TCP\IP等协议、语言基础、数据结构等基础技术，这些基础技术点你会发现几十年都不会变化。
﻿二、通过演绎法找关系
﻿通过演绎法找关系能让架构师更体系化的看一个问题。通过演绎法找关系可以分为找内部关系和找外部关系两种
﻿2.1 找内部关系
内部关系就是找到业务的生命周期和系统内部的主链路，分期业务虽然支持各种场景的个性化需求，但是系统内主链路和生命周期就一个，也很少发生变化，比如分期业务的生命周期是分期创建-分期失败-分期成功-分期支付关闭，他们的关系是从分期支付单创建到支付成功或支付失败，从支付成功到退款，最后到支付关闭。系统内部主流程包括前置鉴权、支付咨询、支付和退款等。找关系的的另外一个作用就是你看到一堆需求，你能看出这些需求彼此的关系是什么，通过这些关系去分析未来需求的趋势，是偏分期线下的需求更多，还是偏分期线上的需求更多，为啥是分期线下的需求会逐渐多起来，那么未来是不是要围绕着分期线下进行架构升级，通过对分期未来的趋势的判断做架构升级，把未来很多不确定性的事情变得逐渐有确定性。
﻿2.2 找外部关系
外部关系梳理清楚架构的边界，什么做什么不做，什么是本领域的核心服务，这些服务提供给谁使用，我们需要依赖其他领域的核心服务有哪些。为什么理清楚架构边界能够化繁为简？因为架构边界类似一个架构标准，大家遵循统一的标准沟通效率和沟通复杂度就会降低，否则每个需求都要讨论这个功能做在哪个系统？为啥要放在这个系统？我觉得不应该放在这个系统？
﻿三、通过归纳法找特性
﻿找特性首先是通过归纳法先找两个业务的共性，花呗支付和花呗分期都是互联网金融产品，都具备互联网产品属性和金融属性，花呗支付和花呗分期不一样的点就是分期的特性，主要体现在付费模式更多（有用户付息和用户免息），还款方式更多（3期、6期和12期），营销方式更多（全贴息和部分贴息）、以及服务角色更多（服务ISV）。
﻿再举一个例子，如果要精通JAVA要学习的内容会非常多，可能花很多时间学习也不一定能精通JAVA语言，投入产出比不高，但是如果想化繁为简就必须先找到JAVA的特性，针对特性进行深入学习，我觉得JAVA的两项特性技术是垃圾回收机制和多线程框架，剩下的就和其他语言的特性差不多。
﻿大家会发现找特性和找共性是不是存在矛盾，所以在这个过程中需要做取舍，比如是否只满足共性需求不满足个性化需求，我觉得在某些场景下，取的是共性需求舍的是差异化需求，但是也可能在另外一些场景下取的是差异化的需求舍的是共性需求。关键是面对当下的业务，你判断什么当下或者未来最重要的事是什么，可能满足场景个性化需求虽然增加研发成本，但是能给业务带来技术壁垒，或者有没有一种方式能既满足共性需求又能满足部分个性化需求。
四、最后
﻿我发现当解决一个问题的时候一定会带来一个新的问题，因为这个可能会破坏现在维持的一种平衡，要学会无为而治，并不是什么都不做，无为是不违背自然规则，我理解就是尽量少打破平衡，做好取舍维持平衡，不既左既右。比如你在做架构升级的时候，虽然升级完了能很好的满足未来的需求，但是在升级的过程中一个需求可能要同时在新老链路里同时实现，风险和工作量加倍。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25a821cd8c227686aaf07fc1ad8feab6/" rel="bookmark">
			workspace.xml的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		workspace.xml：这个文件的作用就是记录idea针对该项目的配置，包括服务器的相关配置，maven或者jdk的相关配置，第三方jar的配置等。
misc.xml：描述该项目一些混杂信息，如SDK、语言等级、项目输出的目录等等
modules.xml：描述该项目有哪些Module模块
vcs.xml：使用的VCS工具信息，如Git
idea 是用于保存所有 Jetbrains IDES（RubyMine、Pycharm、PHPStorm、WebStorm ..etc）的项目配置的目录
如果您不想将其提交到 repo，您可以使用两种方式处理它
只为自己忽略
在 .git/info/exclude
添加 /.idea
在 .gitignore 中忽略它，这样每个使用 repo 的人都会忽略它
通过添加/.idea到.gitignore
如果 dir .idea 已经被 git 跟踪，你需要先从缓存文件中删除它，然后再忽略 git rm -r --cached .idea
如果您为项目进行了任何自定义配置，则此文件夹可以包含重要配置，并且还包含 IDE 的索引数据，这有助于它提供快速自动完成功能，并且在某些情况下将其提交到存储库会更好，但我总是忽略它，因为团队中的其他开发人员不使用 RubyMinee
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66443680772807284a8acc510b17f191/" rel="bookmark">
			UG二次开发装配篇 添加/拖动/删除组件方法的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在UG装配的过程中，经常会遇到需要调整组件目录位置，在软件设计过程中可以通过在目录树里面拖动组件来完成。
那么，如果要用程序实现组件的移动/拖动，我们要怎么做呢？
本节就完成了添加/拖动/删除组件方法的实现，先看效果图：
根节点test下，有SHCS_01、SHCS_02、SHCS_03、SHCS_04这四个组件。
下面分别给出了添加组件、移动组件和删除组件的方法。
一、添加组件 1、实现方法
/// &lt;summary&gt; /// 添加组件 /// &lt;/summary&gt; /// &lt;param name="templatePrt"&gt;模板路径&lt;/param&gt; /// &lt;param name="basePoint"&gt;中心点坐标位置&lt;/param&gt; /// &lt;param name="orientation"&gt;矢量方向&lt;/param&gt; /// &lt;param name="expModel"&gt;表达式集&lt;/param&gt; public static void AddComponent(string templatePrt, Point3d basePoint, Matrix3x3 orientation, ExpressionModel expModel) { theUFSession = UFSession.GetUFSession(); theSession = Session.GetSession(); displayPart = theSession.Parts.Display; workPart = theSession.Parts.Work; componentNameList = new List&lt;string&gt;(); BasePart basePart1; PartLoadStatus partLoadStatus1; step1: string fileName = ""; string newfile = GetNewFile(templatePrt, out fileName); //先拷贝一个备份 try { basePart1 = theSession.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66443680772807284a8acc510b17f191/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d69683b5ec36fa12bcfb56fb3809ab87/" rel="bookmark">
			数字图像处理（4）- 图像增强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 图像增强概述
1.1 图像增强的目的、评价标准
1.2 图像增强方法的分类 1.3 图像增强的应用
2 空间滤波增强
2.1 空间域平滑滤波器 2.1.1 局部平滑法
2.1.2 超像素平滑法（阈值平均法）
2.1.3 空间低通滤波法（模板平滑法）
2.1.4 多图像平均法
2.2 空间域锐化滤波器
2.2.1 梯度锐化法
2.2.2 拉普拉斯锐化法
2.2.3 低频分量消减法
2.2.4 模板锐化法
2.2.5 图像锐化的实质
3 频率滤波增强 3.1 频率域平滑滤波器 3.1.1 理想低通滤波器 3.1.2 巴特沃斯低通滤波器 3.1.3 高斯低通滤波器 3.1.4 平滑滤波器的应用
3.1.5 滤波器拓展（这里挖坑，以后详细分析）
3.2 频率域中值滤波器
3.2.1 综述
3.2.2 中值滤波法的原理和窗口
3.2.3 中值滤波法的重要特性
3.2.4 使用中值滤波时的注意事项
3.3 频率域锐化滤波器
3.3.1 理想高通滤波器
3.3.2 巴特沃斯高通滤波器
3.3.3 高斯高通滤波器
3.3.4 三种滤波器特性总结
4 图像的同态滤波
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d69683b5ec36fa12bcfb56fb3809ab87/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/167/">«</a>
	<span class="pagination__item pagination__item--current">168/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/169/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>