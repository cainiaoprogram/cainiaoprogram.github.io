<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7745cbbbf07d78f47fd568c6a326a1d/" rel="bookmark">
			C&#43;&#43;输入文件流ifstream用法详解[转载]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ios_base &lt;- ios &lt;- istream &lt;- ifstream &lt;- fstream &lt;- ostream &lt;- ofstream &lt;- fstream C++ 使用标准库类来处理面向流的输入和输出：
iostream 控制台读写
fstream 文件读写
stringstream 内存string 的读写
每个IO 对象都维护一组条件状态 flags (eofbit, failbit and badbit)，用来指出此对象上是否可以进行 IO 操作。如果遇到错误—例如输入流遇到了文件末尾，则对象的状态变为是失效，所有的后续输入操作都不能执行，直到错误纠正。
1 #include &lt;fstream&gt; 2 ofstream //文件写操作 3 ifstream //文件读操作 4 fstream //文件读写操作 成员函数
Public member functions
1， 构造函数
第一种不绑定文件，后续用open() 绑定。 即：ifstream in;
第二种绑定文件 filename ，读取模式默认参数为 ios::in可以省略。
//第1种 ifstream in; in.open("H:\\ProductCode\\FileText\\clientc.txt",ios::in); //第2种 ifstream in("H:\\ProductCode\\FileText\\clientc.txt"，ios::in); //函数原型： explicit ifstream (const char* filename, ios_base::openmode mode = ios_base::in); explicit ifstream (const string&amp; filename, ios_base::openmode mode = ios_base::in); 2，ifstream::open
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7745cbbbf07d78f47fd568c6a326a1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa31445998543ee02324bbbf291d1e5e/" rel="bookmark">
			CDH5.16.1集群企业真正离线部署(三台阿里云主机按量付费)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.准备工作 1.集群规划
节点 MySQL部署组件Parcel文件离线源 CM服务进程 大数据组件hadoop001MySQLParcelActivity MonitorNN RM DN NMhadoop002 Alert Publisher
Event ServerDN NMhadoop003 Alert Publisher
Event ServerDN NM 2.下载源
CM：
http://archive.cloudera.com/cm5/cm/5/cloudera-manager-centos7-cm5.16.1_x86_64.tar.gz
Parcel：
http://archive.cloudera.com/cdh5/parcels/5.16.1/CDH-5.16.1-1.cdh5.16.1.p0.3-el7.parcel
http://archive.cloudera.com/cdh5/parcels/5.16.1/CDH-5.16.1-1.cdh5.16.1.p0.3-el7.parcel.sha1
http://archive.cloudera.com/cdh5/parcels/5.16.1/manifest.json
JDK：
https://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html
MySQL
https://dev.mysql.com/downloads/mysql/5.7.html#downloads
MySQL jdbc jar
http://central.maven.org/maven2/mysql/mysql-connector-java/5.1.47/mysql-connector-java-5.1.47.jar
下载完成后要重命名去掉版本号，
mv mysql-connector-java-5.1.47.jar mysql-connector-java.jar
二.集群节点初始化 1.阿里云上海海区购买3台，按量量付费虚拟机
CentOS7.2操作系统，2核8G最低配置
2.当前笔记本或台式机配置hosts文件
MAC: /etc/hosts
Window: C:\windows\system32\drivers\etc\hosts
172.17.79.118 hadoop001 172.17.79.117 hadoop002 172.17.79.116 hadoop003 3.设置所有节点的hosts文件
vim /etc/hosts
172.17.79.118 hadoop001 172.17.79.117 hadoop002 172.17.79.116 hadoop003 4.关闭所有节点的防火墙及清空规则
centos关闭防火墙
systemctl stop firewalld systemctl disable firewalld iptables -F iptables -L 一般阿里云的防火墙都是关闭的，但是阿里云服务器上有一个Web的防火墙，要打开7180的端口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa31445998543ee02324bbbf291d1e5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab2f92d7ead5ce5f661a3ca284a72a0/" rel="bookmark">
			什么是FTP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、FTP简介
FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，它属于网络传输协议的应用层。它最主要的功能是在服务器与客户端之间进行文件的传输。这个协议使用的是明文传输。
FTP服务器的功能除了单纯的进行文件的传输与管理外，依据服务器软件的配置架构，它还可以提供以下几个主要功能：
1、不同的用户：
FTP服务器在默认的情况下，依据用户登录的情况而分为三种不同的身份，分别是：实体用户，real user；访客，guest；匿名用户，anonymous。
2、命令记录与日志文件记录
FTP可以利用系统的syslogd来进行数据的记录，而记录的数据包括了用户曾经使用过的命令与用户传输数据（传输时间、文件大小等）的记录，所以可以在/var/log/里面找到各项日志信息。
3、限制用户活动的目录（change root，简称chroot）
为了避免用户在你的linux系统中随意切换目录，所以将用户的工作范围局限在用户主目录下面。FTP可以限制用户仅能在自己的用户主目录当中活动。当用户登录FTP后，由于用户无法离开自己的用户主目录，显示的根目录就是自己用户主目录的内容。这种环境称为change root，即chroot，即改变根目录的意思。
二、FTP的工作流程
FTP的传输使用的是TCP数据包协议。FTP服务器使用了两个连接，分别是命令（TCP21）通道与数据（TCP20）流通道。由于是TCP数据包，这两个连接都需要经过三次握手。
1、建立命令通道的过程
客户端会随机获取一个大于1024以上的端口来与FTP服务器端的port 21来实现连接，这个过程需要三次握手。实现连接后客户端便可以通过这个连接来对FTP服务器执行命令，查询文件名、下载、上传等命令都是利用这个通道来执行的。
2、建立数据通道的过程
FTP的连接模式：主动模式（服务端主动与客户端连接）、被动模式（客户端主动与服务端连接），主动和被动是针对服务端来说的。
（1）通知FTP服务器端使用主动连接且告知连接的端口号
FTP服务器的端口21号主要用在命令的执行，但是牵涉到数据流时，就不是使用这个连接了。客户端在需要数据的情况下，会告知服务器端要用什么方式来连接，如果是主动连接，客户端会先随机启用一个端口，且通过命令通道告知FTP服务器这两个信息，并等待FTP服务器的连接。
FTP服务器主动向客户端连接
FTP服务器由命令通道了解客户端的需求后，会主动地由port 20向客户端的数据端口连接，这个连接也会经过三次握手。此时FTP的客户端与服务器端会建立两条连接，分别用在命令的执行与数据的传递。而默认FTP服务器端使用的主动连接端口就是port 20。
数据传输通道是在有数据传输的行为时才会建立的通道，并不是一开始连接到FTP服务器就立刻建立的通道。
注意： 控制/命令链路：21端口，数据链路：20端口
（2）客户端选择被动式连接模式
客户端通过命令通道发出被动式连接要求，并等待服务器的回应。
FTP服务器启动数据端口，并通知客户端连接
如果你所使用的FTP服务器是能够处理被动式连接的，此时FTP服务器会先启动一个监听端口。这个端口号码可以是随机的，也可以自定义某一范围的端口，这要看FTP服务器软件而定。然后FTP服务器会通过命令通道告知客户端这个已经启动的端口port pasv，并等待客户端的连接。
客户端随机取用大于1024的端口进行连接
然后客户端会随机取用一个大于1024的端口号来进行对主机的port pasv连接。如果一切都没有问题的话，那么FTP数据就可以通过客户端的随机端口和服务端的port pasv来传送了。
（3）优缺点：
主动模式对ftp对服务器管理有利，是由FTP服务器主动与客户端的高位随机端口建立连接，而这个端口很有可能被客户端的防火墙阻塞。而被动模式对客户端管理有效，它是企图与服务端的随机端口建立连接但是这个端口很可能又会被服务端的防火墙所拒绝。
一般做安全措施我们是在被动模式下做，由于主动模式是打开一个端口给客户端传送数据，我们做安全措施都是基于端口来做所以不太好做，一般也不建议去做。但是被动模式也是在不停地放端口。
三、ftp的使用以及软件的安装
为了更安全的使用FTP协议，可以使用vsftpd这个软件。vsftpd（very secure FTP daemon）。vsftpd是一个设计的较为安全的FTP服务器软件，它的特点如下：
1、vsftpd服务的启动者身份为一般用户，所以对linux系统的权限较低，对于linux系统的危害就相对降低了。此外，vsftpd也利用chroot这个函数来进行改换根目录的操作，使得系统工具不会被vsftpd这个服务所利用。
2、任何需要具有较高执行权限的vsftpd命令均以一个特殊的上层程序所控制，该上层程序享有的较高执行权限功能已经被限制的比较低，并以不影响linux系统本身的系统为准。
3、绝大部分FTP会使用到的额外命令功能（例如ls，cd等）都已经被整合到vsftpd主程序当中了，因此理论上vsftpd不需要使用到额外的系统提供的命令。
4、所有来自客户端且想要使用这个上层程序所提供的较高执行权限的vsftpd命令的需求，均被视为不可信任的要求来处理，必须要经过相当程度的身份确认后，才可以利用上层程序的功能。
5、关于上层程序，会使用chroot的功能来限制用户的执行权限。
四、SFTP
1、sftp是SSH File Transfer Protocol的缩写，SFTP是一种安全文件传输协议，要求客户端用户必须有服务器进行身份验证，并且数据传输必须通过安全通道（SSH）进行。但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多。
2、sftp和ftp的异同
1）相同点
SFTP和FTP都支持批量传输（一次传输多个文件），文件夹/目录导航，文件移动，文件夹/目录创建，文件删除等。
2）不同点
安全通道：
FTP 不提供任何安全通道在主机之间传输文件
SFTP 提供了一种安全通道（SSH），用于在网络上的主机之间进行文件传输。
传输协议：
FTP使用TCP / IP协议。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ab2f92d7ead5ce5f661a3ca284a72a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e86cc845c8bb5195f578416a75a817b/" rel="bookmark">
			数字IC设计——用Verilog实现串并转换（移位寄存器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字IC设计——用Verilog实现串并转换（移位寄存器）
一、串转并转换模块 利用移位寄存器
串行转并行数据输出：采用位拼接技术（移位寄存器），将串行的数据总数先表示出来，然后发送一位数据加一，后面的接收的这样标志：
data_o &lt;= {data_o[6:0],data_i };
1输入8输出 的 串转并模块的Verilog代码 module serial_parallel( input clk, input rst_n,en, input data_i, //一位输入 output reg [7:0] data_o	//8位并行输出 ); always @(posedge clk or negedge rst_n) begin if (rst_n == 1'b0) data_o &lt;= 8'b0; else if (en == 1'b1) data_o &lt;= {data_o[6:0], data_i};	//低位先赋值 //data_o &lt;= {data_i,data_o[7:1],};	//高位先赋值 else data_o &lt;= data_o; end endmodule 利用计数器
利用计数器cnt 时钟计数，开始数据先给高位，每过一个时钟周期，数据便给低一位。这样便可以达到串转并的效果
1输入8输出 的 串转并模块的Verilog代码
module serial_parallel( input clk, input rst_n, input data_i, output reg [7:0] data_o ); //msb first most significant bit 表示二进制数据的最高位 reg [2:0] cnt; //计数器0-7 always @(posedge clk or negedge rst_n)begin if(rst_n == 1'b0)begin data_o &lt;= 8'b0; cnt &lt;= 3'd0; end else begin data_o[7 - cnt] &lt;= data_i;	高位先赋值 cnt &lt;= cnt + 1'b1; end end /* //lsb first	(least significant bit) 表示二进制数据的最低位 reg [2:0] cnt; always @(posedge clk or negedge rst_n)begin if(rst_n == 1'b0)begin data_o &lt;= 8'b0; cnt &lt;= 3'd0; end else begin data_o[cnt] &lt;= data_i; //低位先赋值 cnt &lt;= cnt + 1'b1; end end */ endmodule 二、并转串转换模块 并串转换的原理是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e86cc845c8bb5195f578416a75a817b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cecd303e207f56a3c83c883d39f834a5/" rel="bookmark">
			【文献阅读】 2019-IJCAI-Sequential Recommender Systems Challenges, Progress and Prospects
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 1.原文链接
2.此处将Sequential Recommender Systems 翻译为序列推荐系统，具体定义参见下文的形式化定义。
3.本篇为顶会IJCAI上的文章，给出关于此会议其他推荐系统的文章参考。
标题 序列推荐系统的挑战、进展和前景
作者： S h o u j i n W a n g 1 , L i a n g H u 2 , Y a n W a n g 1 , L o n g b i n g C a o 2 , Q u a n Z . S h e n g 1 , M e h m e t O r g u n 1 ShoujinWang^1, Liang Hu^2, Yan Wang^1, Longbing Cao^2, Quan Z.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cecd303e207f56a3c83c883d39f834a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7b1e314614cf326c6e2b6eba1540682/" rel="bookmark">
			TODO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/langxianwenye/article/details/9095559
https://www.cnblogs.com/muhe221/articles/7799682.html
https://www.cnblogs.com/muhe221/articles/5250321.html
https://blog.csdn.net/qq_32651225/article/details/80165662
springboot
https://pan.baidu.com/s/12N7ggZ7GQwt1KUPASiQLrA
Redis中高级课程视频在线观看地址：https://www.bilibili.com/video/av34900337/ 更多分布式微服务视频教程
http://www.majiaxueyuan.com/
spring boot
https://study.163.com/course/introduction/1005999004.htm?courseId=1005999004&amp;from=study
码家学院 PPT
https://pan.baidu.com/s/15Y19W7hpuLOLyyynRN1qmg
springboot 教程
http://www.ityouknow.com/spring-boot.html
转载于:https://www.cnblogs.com/muhe221/p/11433678.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/698d51a19d8a121ce581499d7b701668/" rel="bookmark">
			111
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;p&gt;点击太阳或其他行星，注意变化：&lt;/p&gt;
&lt;img src="planets.gif" width="145" height="126" alt="Planets" usemap="#planetmap"&gt;
&lt;map name="planetmap"&gt;
&lt;area shape="rect" coords="0,0,82,126" alt="Sun" href="sun.htm"&gt;
&lt;area shape="circle" coords="90,58,3" alt="Mercury" href="mercur.htm"&gt;
&lt;area shape="circle" coords="124,58,8" alt="Venus" href="venus.htm"&gt;
&lt;/map&gt;
转载于:https://www.cnblogs.com/muhe221/p/11592064.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5842d7d3ab45f18ca7bb9b4e371e27f8/" rel="bookmark">
			Python - Y.shape[n,m]；Numpy中的矩阵合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The shape attribute for numpy arrays returns the dimensions of the array. If Y has n rows and m columns, then Y.shape is (n,m). So Y.shape[0] is n.
In [46]: Y = np.arange(12).reshape(3,4) In [47]: Y Out[47]: array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) In [48]: Y.shape Out[48]: (3, 4) #行数 In [49]: Y.shape[0] Out[49]: 3
#列数 In [49]: Y.shape[1] Out[49]: 4 numpy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5842d7d3ab45f18ca7bb9b4e371e27f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b5f203e347a28b6146272b7b8b95b3/" rel="bookmark">
			奇异值分解(SVD)详解及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 第一次接触奇异值分解还是在本科期间，那个时候要用到点对点的刚体配准，这是查文献刚好找到了四元数理论用于配准方法（点对点配准可以利用四元数方法，如果点数不一致更建议应用ICP算法）。一直想找个时间把奇异值分解理清楚、弄明白，直到今天才系统地来进行总结。 上一次学习过关于PCA的文章，PCA的实现一般有两种，一种是用特征值分解去实现的，一种是用奇异值分解去实现的。特征值和奇异值在大部分人的印象中，往往是停留在纯粹的数学计算中。而且线性代数或者矩阵论里面，也很少讲任何跟特征值与奇异值有关的应用背景。奇异值分解是一个有着很明显的物理意义的一种方法，它可以将一个比较复杂的矩阵用更小更简单的几个子矩阵的相乘来表示，这些小矩阵描述的是矩阵的重要的特性。就像是描述一个人一样，给别人描述说这个人长得浓眉大眼，方脸，络腮胡，而且带个黑框的眼镜，这样寥寥的几个特征，就让别人脑海里面就有一个较为清楚的认识，实际上，人脸上的特征是有着无数种的，之所以能这么描述，是因为人天生就有着非常好的抽取重要特征的能力，让机器学会抽取重要的特征，SVD是也一个重要的方法。在机器学习领域，有相当多的应用与奇异值都可以扯上关系，比如做feature reduction的PCA，做数据压缩（以图像压缩为代表）的算法，还有做搜索引擎语义层次检索的LSI（Latent Semantic Indexing）。 本文主要关注奇异值的一些特性，还会稍稍提及奇异值的计算。另外，本文里面有部分不算太深的线性代数的知识，如果完全忘记了线性代数，看文可能会有些困难。 2.奇异值分解详解 特征值分解和奇异值分解两者有着很紧密的关系，特征值分解和奇异值分解的目的都是一样，就是提取出一个矩阵最重要的特征。先谈谈特征值分解吧：
1 特征值： 如果说一个向量v是方阵A的特征向量，将一定可以表示成下面的形式：
这时候λ就被称为特征向量v对应的特征值，一个矩阵的一组特征向量是一组正交向量。特征值分解是将一个矩阵分解成下面的形式：
其中Q是这个矩阵A的特征向量组成的矩阵，Σ是一个对角阵，每一个对角线上的元素就是一个特征值。首先，要明确的是，一个矩阵其实就是一个线性变换，因为一个矩阵乘以一个向量后得到的向量，其实就相当于将这个向量进行了线性变换。比如说下面的一个矩阵：
它其实对应的线性变换是下面的形式：
因为这个矩阵M乘以一个向量(x,y)的结果是：
上面的矩阵是对称的，所以这个变换是一个对x，y轴的方向一个拉伸变换（每一个对角线上的元素将会对一个维度进行拉伸变换，当值&gt;1时拉长，当值&lt;1时缩短），当矩阵不是对称的时候，假如说矩阵是下面的样子：
它所描述的变换是下面的样子： 这其实是在平面上对一个轴进行的拉伸变换（如蓝色的箭头所示），在图中，蓝色的箭头是一个最主要的变化方向（变化方向可能有不止一个），如果我们想要描述好一个变换，那我们就描述好这个变换主要的变化方向就好了。反过头来看看之前特征值分解的式子，分解得到的Σ矩阵是一个对角阵，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）
当矩阵是高维的情况下，那么这个矩阵就是高维空间下的一个线性变换，这个线性变化可能没法通过图片来表示，但是可以想象，这个变换也同样有很多的变换方向，我们通过特征值分解得到的前N个特征向量，那么就对应了这个矩阵最主要的N个变化方向。我们利用这前N个变化方向，就可以近似这个矩阵（变换）。也就是之前说的：提取这个矩阵最重要的特征。总结一下，特征值分解可以得到特征值与特征向量，特征值表示的是这个特征到底有多重要，而特征向量表示这个特征是什么，可以将每一个特征向量理解为一个线性的子空间，我们可以利用这些线性的子空间干很多的事情。不过，特征值分解也有很多的局限，比如说变换的矩阵必须是方阵。 2 奇异值：
下面重点谈谈奇异值分解。特征值分解是一个提取矩阵特征很不错的方法，但是它只是对方阵而言的，在现实的世界中，我们看到的大部分矩阵都不是方阵，比如说有N个学生，每个学生有M科成绩，这样形成的一个N * M的矩阵就不可能是方阵，我们怎样才能描述这样普通的矩阵呢的重要特征呢？奇异值分解可以用来干这个事情，奇异值分解是一个能适用于任意的矩阵的一种分解的方法：
假设A是一个N * M的矩阵，那么得到的U是一个N * N的方阵（里面的向量是正交的，U里面的向量称为左奇异向量），Σ是一个N * M的矩阵（除了对角线的元素都是0，对角线上的元素称为奇异值），V’(V的转置)是一个N * N的矩阵，里面的向量也是正交的，V里面的向量称为右奇异向量），如下图所示： 那么奇异值和特征值是怎么对应起来的呢？首先，我们将一个矩阵A的转置 * A，将会得到一个方阵，我们用这个方阵求特征值可以得到： 这里得到的v，就是我们上面的右奇异向量。此外我们还可以得到：
这里的σ就是上面说的奇异值，u就是上面说的左奇异向量。奇异值σ跟特征值类似，在矩阵Σ中也是从大到小排列，而且σ的减少特别的快，在很多情况下，前10%甚至1%的奇异值的和就占了全部的奇异值之和的99%以上了。也就是说，我们也可以用前r大的奇异值来近似描述矩阵，这里定义一下部分奇异值分解：
r是一个远小于m、n的数，这样矩阵的乘法看起来像是下面的样子：
右边的三个矩阵相乘的结果将会是一个接近于A的矩阵，在这儿，r越接近于n，则相乘的结果越接近于A。而这三个矩阵的面积之和（在存储观点来说，矩阵面积越小，存储量就越小）要远远小于原始的矩阵A，我们如果想要压缩空间来表示原矩阵A，我们存下这里的三个矩阵：U、Σ、V就好了。 3.如何计算奇异值 奇异值的计算是一个难题，是一个O(N^3)的算法。在单机的情况下当然是没问题的，matlab在一秒钟内就可以算出1000 * 1000的矩阵的所有奇异值，但是当矩阵的规模增长的时候，计算的复杂度呈3次方增长，就需要并行计算参与了。 其实SVD还是可以用并行的方式去实现的，在解大规模的矩阵的时候，一般使用迭代的方法，当矩阵的规模很大（比如说上亿）的时候，迭代的次数也可能会上亿次，如果使用Map-Reduce框架去解，则每次Map-Reduce完成的时候，都会涉及到写文件、读文件的操作。个人猜测Google云计算体系中除了Map-Reduce以外应该还有类似于MPI的计算模型，也就是节点之间是保持通信，数据是常驻在内存中的，这种计算模型比Map-Reduce在解决迭代次数非常多的时候，要快了很多倍。 Lanczos迭代就是一种解对称方阵部分特征值的方法（之前谈到了，解A’* A得到的对称方阵的特征值就是解A的右奇异向量），是将一个对称的方程化为一个三对角矩阵再进行求解。 由于奇异值的计算是一个很枯燥，纯数学的过程，而且前人的研究成果（论文中）几乎已经把整个程序的流程图给出来了。更多的关于奇异值计算的部分，将在后面的参考文献中给出，这里不再深入，我还是focus在奇异值的应用中去。 4.奇异值分解应用 奇异值与主成分分析（PCA） 这里主要谈谈如何用SVD去解PCA的问题。PCA的问题其实是一个基的变换，使得变换后的数据有着最大的方差。方差的大小描述的是一个变量的信息量，我们在讲一个东西的稳定性的时候，往往说要减小方差，如果一个模型的方差很大，那就说明模型不稳定了。但是对于我们用于机器学习的数据（主要是训练数据），方差大才有意义，不然输入的数据都是同一个点，那方差就为0了，这样输入的多个数据就等同于一个数据了。以下面这张图为例子：
这个假设是一个摄像机采集一个物体运动得到的图片，上面的点表示物体运动的位置，假如我们想要用一条直线去拟合这些点，那我们会选择什么方向的线呢？当然是图上标有signal的那条线。如果我们把这些点单纯的投影到x轴或者y轴上，最后在x轴与y轴上得到的方差是相似的（因为这些点的趋势是在45度左右的方向，所以投影到x轴或者y轴上都是类似的），如果我们使用原来的xy坐标系去看这些点，容易看不出来这些点真正的方向是什么。但是如果我们进行坐标系的变化，横轴变成了signal的方向，纵轴变成了noise的方向，则就很容易发现什么方向的方差大，什么方向的方差小了。 一般来说，方差大的方向是信号的方向，方差小的方向是噪声的方向，我们在数据挖掘中或者数字信号处理中，往往要提高信号与噪声的比例，也就是信噪比。对上图来说，如果我们只保留signal方向的数据，也可以对原数据进行不错的近似了。 PCA的全部工作简单点说，就是对原始的空间中顺序地找一组相互正交的坐标轴，第一个轴是使得方差最大的，第二个轴是在与第一个轴正交的平面中使得方差最大的，第三个轴是在与第1、2个轴正交的平面中方差最大的，这样假设在N维空间中，我们可以找到N个这样的坐标轴，我们取前r个去近似这个空间，这样就从一个N维的空间压缩到r维的空间了，但是我们选择的r个坐标轴能够使得空间的压缩使得数据的损失最小。 还是假设我们矩阵每一行表示一个样本，每一列表示一个feature，用矩阵的语言来表示，将一个m * n的矩阵A的进行坐标轴的变化，P就是一个变换的矩阵从一个N维的空间变换到另一个N维的空间，在空间中就会进行一些类似于旋转、拉伸的变化。 而将一个m * n的矩阵A变换成一个m * r的矩阵，这样就会使得本来有n个feature的，变成了有r个feature了（r &lt; n)，这r个其实就是对n个feature的一种提炼，我们就把这个称为feature的压缩。用数学语言表示就是：
但是这个怎么和SVD扯上关系呢？之前谈到，SVD得出的奇异向量也是从奇异值由大到小排列的，按PCA的观点来看，就是方差最大的坐标轴就是第一个奇异向量，方差次大的坐标轴就是第二个奇异向量…我们回忆一下之前得到的SVD式子：
在矩阵的两边同时乘上一个矩阵V，由于V是一个正交的矩阵，所以V转置乘以V得到单位阵I，所以可以化成后面的式子：
将后面的式子与A * P那个m * n的矩阵变换为m * r的矩阵的式子对照看看，在这里，其实V就是P，也就是一个变化的向量。这里是将一个m * n 的矩阵压缩到一个m * r的矩阵，也就是对列进行压缩，如果我们想对行进行压缩（在PCA的观点下，对行进行压缩可以理解为，将一些相似的sample合并在一起，或者将一些没有太大价值的sample去掉）怎么办呢？同样我们写出一个通用的行压缩例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6b5f203e347a28b6146272b7b8b95b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/047391a4b82c2409e5006fa6ea1c6a89/" rel="bookmark">
			怎么删除Ubuntu的root‘s trash里面的东西
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题是由于我删除timeshift里面的备份时直接用了delete（实际上是remove到了root‘s trash里面）遇到的。
这个答案也可以引申为如何彻底删除timeshift里面的备份文件。
实际上，timeshift在点击备份中途取消会导致文件仍然存在，但是显示不了。对着其中一个备份右键browse files可以看到。
直接delete会造成难以从根垃圾站移除的问题。
解决办法：
sudo apt install gksu gksudo nautilus /root/.local/share/ 点进去Trash，吧里面两个文件夹直接删除即可。看看过程大概，我删了30多G，呵呵。。
参考链接
https://ubuntuforums.org/showthread.php?t=970708
https://ubuntuforums.org/showthread.php?t=452754
https://www.linux.org/threads/timeshift-how-to-delete-folder.21406/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d536841958d4aa3309023237b593887a/" rel="bookmark">
			ubuntu 系统日志信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.
ubuntu 18.04 设置内核日志的打印级别
最近遇到ubuntu系统无响应的bug，在排查系统问题，学习下日志信息。
第一个即是当前控制台的打印信息等级。假设当前控制台的打印信息等级为7，那么所有打印信息等级小于等于7的打印信息都可以在控制台打印出来。
#cat /proc/sys/kernel/printk
4 4 1 7
分别对应console_loglevel、default_message_loglevel、minimum_console_loglevel、default_console_loglevel，意味着只有优先级高于KERN_DEBUG(7)的打印消息才能输出到终端
改变console_loglevel echo 8 4 1 7 &gt; /proc/sys/kernel/printk 2 用vim打开/etc/rsyslog.d/50-default.conf文件增加一行内容如下： *.info;mail.none;authpriv.none;cron.none /var/log/messages 重启系统，再来查看系统日志，发现已经okay了！！！
3.
/var/log/alternatives.log-更新替代信息都记录在这个文件中
/var/log/apport.log -应用程序崩溃记录
/var/log/apt/ -用apt-get安装卸载软件的信息
/var/log/auth.log -登录认证log
/var/log/boot.log -包含系统启动时的日志。
/var/log/btmp -记录所有失败启动信息
/var/log/Consolekit - 记录控制台信息
/var/log/cpus - 涉及所有打印信息的日志
/var/log/dist-upgrade - dist-upgrade这种更新方式的信息
/var/log/dmesg -包含内核缓冲信息（kernel ringbuffer）。在系统启动时，显示屏幕上的与硬件有关的信息
/var/log/dpkg.log - 包括安装或dpkg命令清除软件包的日志。
/var/log/faillog - 包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。
/var/log/fontconfig.log -与字体配置有关的log。
/var/log/fsck - 文件系统日志
/var/log/faillog -包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。
/var/log/hp/
/var/log/install/
/var/log/jokey.log
/var/log/kern.log –包含内核产生的日志，有助于在定制内核时解决问题。
/var/log/lastlog —记录所有用户的最近信息。这不是一个ASCII文件，因此需要用lastlog命令查看内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d536841958d4aa3309023237b593887a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/713a6f939d0b73a673bb30189b41ce57/" rel="bookmark">
			跨域 （3）  window.name
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		window对象有一个name属性，该属性有一个特征：即在一个窗口的生命周期内，窗口载入的所有的页面都是共享一个window.name的，每一个页面对window.name都有读写的权限，window.name是持久的存在于一个窗口载入的所有页面中的，并不会因为新的页面的载入而被重置。
a.html
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;a 页面 &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- a先引用 c --&gt; &lt;iframe src="http://localhost:4000/c.html" frameborder="0" οnlοad="load()" id="iframe"&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;script&gt; let first = true; function load() { if(first) { //把 a 引用的地址改到b let iframe = document.getElementById('iframe') iframe.src= 'http://localhost:3000/b.html' first = false }else { console.log(iframe.contentWindow.name) } } &lt;/script&gt; &lt;/html&gt; c.html
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/713a6f939d0b73a673bb30189b41ce57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12f7ff17d2ce5be02e1089ff1079144b/" rel="bookmark">
			数据库 主码 外码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主码 ，外码也可以称为主键，外键。
什么是主码，主码是一个能唯一标识一个元组的属性。在一个关系（表）中，主码不一定只有一个，但是一定要有的。因为元组，是对世界中某种事物的数据描述，而世界中各种事物，都具有唯一性，都是可以区分的。在计算机中为了描述事物的唯一性，引入了主码的概念。在一个关系中，不同元组的主码一定不能为空，且值一定要不同。因为如果为空说明这个事物是不可标识的，而这个世界的任何事物都是可以标识的，说以主码为空显然不合法；如果两个主码值相同则说明两个事物是相同的，而这个世界的任何事物都是不同的，所以两个主码值相同，显然也是不合法的。
什么是外码，如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。外码的值要么为空，要么要为其对应的主码中的一个值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e88c08fdcc2daad3b5515800e9341ac/" rel="bookmark">
			交叉熵损失(Cross Entropy)求导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cross Entropy是分类问题中常见的一种损失函数，我们在之前的文章提到过二值交叉熵的证明和交叉熵的作用，下面解释一下交叉熵损失的求导。
首先一个模型的最后一层神经元的输出记为 f 0 . . . f i f_{0}...f_{i} f0​...fi​，
输出经过softmax激活之后记为 p 0 . . . p i p_{0}...p_{i} p0​...pi​，那么：
p i = e f i ∑ k = 0 C − 1 e f k p_{i} = \frac{e^{f_{i}}}{\sum_{k=0}^{C-1} e^{f_{k}}} pi​=∑k=0C−1​efk​efi​​
类别的实际标签记为 y 0 . . . y i y_{0}...y_{i} y0​...yi​，那么交叉熵损失L为：
L = − ∑ i = 0 C − 1 y i l o g p i L = -\sum_{i=0}^{C-1} y_{i}log^{p_{i}} L=−i=0∑C−1​yi​logpi​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e88c08fdcc2daad3b5515800e9341ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/519169b5d85d17cb31ce3f5fcabe8c48/" rel="bookmark">
			ubuntu/mac安装sentry
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu/Mac下搭建sentry Ubuntu安装docker 由于apt官方库里的docker版本可能比较旧，所以先卸载可能存在的旧版本：
sudo apt-get remove docker docker-engine docker-ce docker.io 更新apt包索引：
sudo apt-get update 安装以下包以使apt可以通过HTTPS使用存储库（repository）：
sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common 添加Docker官方的GPG密钥：
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 使用下面的命令来设置stable存储库：
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" 再更新一下apt包索引：
sudo apt-get update 安装最新版本的Docker CE：
sudo apt-get install -y docker-ce 启动docker服务：
sudo systemctl start docker 经典的hello world：
sudo docker run hello-world 推荐使用python的pip管理工具来安装docker-compose
sudo pip install -U docker-compose Mac安装docker 安装https://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/519169b5d85d17cb31ce3f5fcabe8c48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa75f1b36f6cdac74b35bb7f2ace3bad/" rel="bookmark">
			报错：Uncaught SyntaxError: Cannot use import statement outside a module 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JS错误Uncaught SyntaxError: Cannot use import statement outside a module&lt; 分析及解决方法
错误信息： 错误分析： HTML 网页中，浏览器通过 script 标签加载 JavaScript 脚本。由于浏览器脚本的默认语言是 JavaScript，因此type="application/javascript"可以省略。在报错中了解到，是说无法在模块外部使用import语句，因为Module 的加载实现的是es6语法，所以在浏览器加载html文件时，需要在script 标签中加入type="module"属性。
解决办法： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a98214df96b4047f27616c99297eb4/" rel="bookmark">
			CentOS 7自动以root身份登录GNOME桌面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改配置文件 /etc/gdm/custom.conf，在 [daemon] 下面添加一下两行
AutomaticLoginEnable=true
AutomaticLogin=root
[root@localhost ~]# vim /etc/gdm/custom.conf # GDM configuration storage [daemon] AutomaticLoginEnable=true AutomaticLogin=root [security] [xdmcp] [chooser] [debug] # Uncomment the line below to turn on debugging #Enable=true 转载于:https://www.cnblogs.com/yinliang/p/11615169.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555b0bce8f55c3d3ee58dba974d0700c/" rel="bookmark">
			6用NetBeans进行JSP开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用NetBeans进行JSP开发
NetBeans
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f76f01f2012128a29ebe462e58d4166/" rel="bookmark">
			nuxt.js项目部署到linux服务器，并使用域名访问（说明遇上的大坑，首页静态资源可以访问，但是接口全部失效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景 如今ssr是非常流行的，而vue使用的ssr正是nuxt.js，由于nuxt.js和普通的vue项目不同，它是有自带的服务器的，所以部署到linux的方式也和vue单页面应用不同
2.步骤 2.1 准备源代码 一般我都是直接把源码中的除了node_modules的所有文件全部打包成一个zip压缩包，然后上传到服务器，由于node_modules文件夹里面是第三方包，很大，压缩起来很慢，上传到服务器也会很慢，所以一般都是在服务器端去npm install第三方包。
2.2 服务器安装node和pm2 2.2.1 安装node 参考博客：https://www.cnblogs.com/liuqi/p/6483317.html，步骤很详细
2.2.2 安装cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org
测试一下：cnpm -v
如果报错cnpm command not found什么的，那么你应该是没有对cnpm建立软连接，按照2.2.1建立以下
2.2.3 安装pm2 //安装pm2 npm install -g pm2 //建立软连接： ln -s /usr/local/nodeJs/nodejs/bin/pm2 /usr/local/bin/pm2 //检测pm2命令 pm2 list 2.3 进入对应目录下载第三方依赖包 cnpm run install
2.4 编译项目 有两种方式，第一种是在你本地就npm run build然后按2.1的方式打包，也可以先将压缩包上传到服务器，再
npm run build
2.5 使用pm2启动项目 2.5.1 进入文件夹 我是将文件放在/usr/local/workspace/shop 目录下的，所以执行命令
cd /usr/local/workspace/shop
这一步非常重要，因为你就算是执行pm2命令，他也是从你当前文件夹的位置执行命令，而npm run start命令必须要在有package.json文件的目录下才能执行成功，所以必须先进入该目录，其实步骤2.3就已经要进入该文件夹进行操作了
2.5.2 启动项目 有两种方式
第一种就是直接在当前目录执行
npm run start第二种使用pm2启动项目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f76f01f2012128a29ebe462e58d4166/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82566d2a2916fdc18a93920d7ae94296/" rel="bookmark">
			Android资源管理框架-------之资源管理的基本数据结构和Bag资源（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源管理的基本数据结构 上一篇我们介绍了resources.arsc以及与之相关的主要数据结构，这些数据结构大多以ResTable_开头，主要是用来描述resources.arsc非常方便。不过，要用这些数据结构来对Android资源进行管理，还是有些吃力，Android为了更加方便地管理资源，还有另外一套数据结构，它们主要是ResTable和ResTable的内部类。
与resources.arsc相关的数据结构当中，最主要的是ResTable_package、ResTable_type、ResTable_entry这三级架构，也和资源id形式0xpptteeee（pp表示最高的一个字节表示包id，第二高的一个字节表示type id，最后两个字节表示entry id）相一致。但是，要对实现对这三级资源架构的管理，要依靠的绝对不仅仅是这三级。确切地说，Android资源管理中用到，但是resources.arsc中没有用到数据结构，主要是ResTable、ResTable::PackageGroup、ResTable::Package、ResTable::TypeList、ResTable::Type、ResTable::Entry。其中，ResTable::Package、ResTable::Entry和ResTable_package、ResTable_entry对应；ResTable::Type和ResTable_type的意义完全不一样；ResTable、ResTable::PackageGroup、ResTable::TypeList是resources.arsc中没有类似的数据结构与之对应。我们这里再着重说一下，ResTable_开头的数据结构偏重于对resources.arsc的描述，而ResTable::系列的数据结构是用来对资源信息进行管理的，AssetManager中的许多接口功能的实现都要依赖它们。
ResTable Android资源管理框架-------之Android中的资源包（二）中，我们知道一个AssetManager可能会加载许多资源包，包括Android系统资源包也就是framework-res.apk、Soc厂商资源包、手机厂商资源包以及App本身，甚至还有可能存在overlay包、资源共享库等等。那么这些资源包中的resources.arsc加载后被存到了哪里呢？最终它们都会被存放到一个ResTable的对象中，并且这个对象是native层AssetManager的一个成员。也就是说，一个ResTable对象会存储它所在的AssetManager加载的所有资源包中的resources.arsc，并且对这些resources.arsc做统一的管理，这一点我们一定要注意。
//frameworks/base/include/androidfw/ResourceTypes.h class ResTable { //......省略无关代码 private: /** * 当前设备配置信息，我们去获取资源时，要根据它来选择合适的资源 * 我们给AssetManager设置或者更新配置信息时，最终也会存在这里 */ ResTable_config mParams; /** * 存放我们加载的所有资源包中的resources.arsc * 当然它不会把整个resources.arsc都放进来，只是放入了每个resources.arsc的header信息 * 这样通过header我们可以访问整个resources.arsc */ Vector&lt;Header*&gt; mHeaders; //我们加载过来的资源包相关的信息都会放到这个数据结构中 Vector&lt;PackageGroup*&gt; mPackageGroups; /** * 这是一个Map，key为下标，具体为加载的package的id， * value为，这个package在mPackageGroups中的索引 + 1 */ uint8_t mPackageMap[256]; //分配给下一个资源共享库的临时PackageId uint8_t mNextPackageId; } 我们看到一个内部，存储的关键信息就三个：mParams存储配置信息、mHeaders存储加载的resources.arsc、mPackageGroups存储加载的资源包相关的信息。如果不考虑Runtime Resources Overlay，一个id为packageId的资源包的信息为mPackageGroups[mPackageMap[packageId] - 1]。另外，在resources.arsc中，资源共享库的packageId都是0，所以加载的时候要为它们动态分配一个id，mNextPackageId就是做这个用的。
ResTable::PackageGroup 按照一般的逻辑，一个ResTable对象中直接存放一个ResTable::Package的集合就可以了，为什么我们看到的却是存放了一个ResTable::PackageGroup的集合呢？并且从ResTable::PackageGroup的实现来看它的内部确确实实又是存在多个ResTable::Package的，这个怎么理解呢？
//frameworks/base/lib/androidfw/ResourceTypes.cpp struct ResTable::PackageGroup { //......省略无关代码 //这个PackageGroup所属的ResTable const ResTable* const owner; /** * 这个PackageGroup的name，为这个PackageGroup中第一个Package的name */ String16 const name; uint32_t const id; //这个PackageGroup内的所有Package Vector&lt;Package*&gt; packages; /** * 每一个元素都代表一种类型的资源 * 当我们访问资源时，是通过PackageGroup到TypeList，再到Type，再到Entry * 中间并不会经过上面的packages变量 */ ByteBucketArray&lt;TypeList&gt; types; //最大typeId uint8_t largestTypeId; //这个PackageGroup所有的bag资源，这个后面会单讲，现在可以先无视之 ByteBucketArray&lt;bag_set**&gt;* bags; //资源共享库相关的数据结构 DynamicRefTable dynamicRefTable; } 其实，ResTable::PackageGroup的存在，是为了Runtime Resources Overlay（简称RRO），一般情况下一个ResTable::PackageGroup里只会有一个ResTable::Package，包括我们的应用包（id：0x7f）、系统资源包（id：0x01）、Soc厂商资源包、手机厂商资源包以及资源共享库包等等。但是有RRO时，系统会把target包和overlay包放到同一个ResTable::PackageGroup中，以便获取资源时可以快速地定位overlay包中的资源。并且target包会被放到packages[0]，overlay包则会放到后面，这个ResTable::PackageGroup的包名和id都会以target包为准。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82566d2a2916fdc18a93920d7ae94296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2e960ca700311998da969bf63bad509/" rel="bookmark">
			L3-Day28
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		训练技巧顺序：
【完全听写法】️【车轮法】️【影子跟读法】
【练习时间】_30mins
句一；Over the weekend, my friend invited me to watch a football game on television. 成分划分：Over the weekend, my friend主语 invited谓语 me宾语 to watch a football game on television宾补. 语法点：动作关系、一般过去时
语音练习感受： watch~a连读；to和a弱读
句二；But I do not like football. 成分划分： I 主语 do not like谓语 football宾语
语法点：动作关系、一般现在时
语音练习感受：
句三；It is not my cup of tea.
成分划分：It主语 is系动词 not my cup of tea表语.
语法点：描述关系、一般现在时
语音练习感受：It~is，cup~of连读
句四；We hope this program has given you food for thought, that is, something to think about.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2e960ca700311998da969bf63bad509/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/669aaaa13aa6f4d92efcbdf9adf31e33/" rel="bookmark">
			Python中变量作用域规则详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 作用域是指变量的生效范围，例如本地变量、全局变量描述的就是不同的生效范围。python的变量作用域的规则非常简单，可以说是所有语言中最直观、最容易理解的作用域。
在开始介绍作用域之前，先抛一个问题：
x = 1 def f(): x = 3 g() print("f:", x) # 3 def g(): print("g:", x) # 1 f() print("main:", x) # 1 上面的代码的依次输出为：
g: 1 f: 3 main: 1 python作用域规则简介 它有4个层次的作用域范围：内部嵌套函数、包含内部嵌套函数的函数自身、全局作用域、内置作用域。上面4个作用域的范围排序是按照从内到外，从小到大排序的。如下图所示：
其中：
内置作用域是预先定义好的，在__builtins__模块中。这些名称主要是一些关键字，例如open、range、quit等；全局作用域是文件级别的，或者说是模块级别的，每个py文件中处于顶层的变量都是全局作用域范围内的变量；本地作用域是函数内部属于本函数的作用范围，因为函数可以嵌套函数，嵌套的内层函数有自身的内层范围嵌套函数的本地作用域是属于内层函数的范围，不属于外层 所以对于下面这段python代码来说，如果它处于a.py文件中，且没有嵌套在其它函数内：
# a.py X = 1 def out1(i): X = 2 Y = 'a' print(X) print(i) def in1(n): print(n) print(X, Y) in1(3) out1(99) print("X: ", X) 上述代码依次输出：
&gt;&gt;&gt; out1(99) 2 99 3 2 a &gt;&gt;&gt; print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/669aaaa13aa6f4d92efcbdf9adf31e33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/745699765ba25b71d412f8d04f728746/" rel="bookmark">
			angular2单元测试学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单元测试简介：https://segmentfault.com/a/1190000009737186
单元测试-Jasmine：https://segmentfault.com/a/1190000009737204
angular2单元测试：https://segmentfault.com/a/1190000009769787#articleHeader1
概念简介 Jasmine Jasmine测试框架提供了编写测试脚本的工具集，而且非常优秀的语义化，让测试代码看起来像是在读一段话。
describe，beforeEach，it，expect等方法，利用这些方法可以定义单元测试如何执行，单元测试的结果和预期。
官方文档：https://jasmine.github.io/api/edge/global.html#expect
Karma 有Jasmine测试脚本，还需要Karma来帮忙管理这些脚本，以便于在浏览器中运行，可以理解Karma为运行这些测试脚本的容器。
需要在根目录创建 karma.conf.js 文件，这相当于一些约定。文件是为了告知karma需要启用哪些插件、加载哪些测试脚本、需要哪些测试浏览器环境、测试报告通知方式、日志等等。
官方文档：https://karma-runner.github.io/1.0/config/configuration-file.html
Angular测试工具集 testded
testded是angular提供用于单元测试的主要工具方法。为单元测试配置和初始化环境，提供创建组件和服务的方法。
还有spy和一些异步支持
结合Jasmine和Angular测试工具集编写单元测试案例 Jasmine单元测试的基础概念
Jasmine中的单元测试有几个概念：test suit、Specs、Expectations
test suit 测试套件
可以理解为一组单元测试用例的集合。Jasmine用describe函数来表示
Specs 测试案例
一个单元测试用例，Jasmine使用函数it来表示
Expectations 期望值
一个单元测试用例执行后，对执行结果的期待，Jasmine使用函数expect来表示
Jasmine单元测试常用方法 Matchers：对期待值进行判断，toBeTruthy，toBeNull这种，也可以自己实现Matcher
Setup 与 Teardown：在测试套件中，一些重复的代码可以放在setup和teardown中。setup（对应beforeEach）为每一个单元测试案例执行之前会执行，Teardown（对应afterEach）为每一个单元测试案例执行之后会执行，
数据共享：在describe 来定义相应的变量，这样每个 it 内部可以共享它们
spy： 文档翻译：https://blog.csdn.net/GuoJiangweigege/article/details/52130589 并参照：https://www.cnblogs.com/laixiangran/p/5060922.html
spyOn(object, "methodNam");//在object对象上添加methodNam，当调用object对象上的方法，为模拟调用，不会执行methodNam方法的代码。spyOn写在beforEach或者it中，每一个测试案例执行完之后，被销毁。
spyOn(object, "methodNam").and.callThrough();//methodNam方法的代码会被执行
spyOn(object, "methodNam").and.callFake(fn);//methodNam方法会被fn替代，执行fn
spyOn(object, "methodNam").and.returnValue(value);//methodNam的返回值为value
Angular工具集 TestBed
如官方所说，是angular单元测试最主要的api。个人理解是一组单元测试的测试context，按配置生成模块、组件，然后提供这些模块或者组件用于单元测试。
1 TestBed创建模块：TestBed.configureTestingModule
构建一个angular模块，并返回，接受参数用于配置模块，和@NgModule的配置无差别。
beforeEach(() =&gt; { TestBed.configureTestingModule({ imports: [HttpModule], declarations: [TestComponent] }); }); 2 TestBed创建组件：TestBed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/745699765ba25b71d412f8d04f728746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/def68d47c46879af3c8e5920749cd9a6/" rel="bookmark">
			SFM 与MVS的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考问题
Structure from Motion(SFM)
Multi View Stereo(MVS)
使用开源工具pipeline:
Bundler(SFM) -&gt; CMVS(MVS) -&gt; PMVS2(MVS)
回答：
sfM 和MVS两者互补，它们基于不同的假设。且他们的输入也不相同。
sfM： （bundler, VisualSFM, OpenMVG）
input： 一组图片
output： 场景粗糙的3D形状（稀疏重建）， 还有每张图片对应的相机参数。
sfm只能稀疏重建的原因：
sfM先从检测图像中提取2D特征（SIFT or ORB）表征。这些图像特征的表示为图像中的一个小区域（既一堆相邻像素）。
2D特征的特点：可以可靠的表示高度纹理区域或者粗糙的几何形状。
但是这些场景特征需要再整个场景中唯一（比如重复的墙纹理，难以匹配）。故而通过这些唯一的特征只能生成稀疏的mesh。当图像之间找到很多匹配项时，可以计算出图像之间的3D变换矩阵从而有效地给出两个相机之间地相对3D位置。
将MVS算法用于细化通过SfM技术获得的网格，从而产生所谓的密集重构。此算法要求每个图像的相机参数都起作用，这由SfM算法输出。由于它适用于更受约束的问题（因为它们已经具有每个图像的摄像机参数，例如位置，旋转，焦点等），因此MVS将在2D特征未正确（或无法正确检测）的区域上计算3D顶点或匹配。这就是PMVS2所做的。
PMVS如何在二维特征描述符难以匹配的区域上工作？由于您知道相机参数，因此知道图像中的给定像素就是另一图像中线的投影。这种方法称为对极几何。 SfM必须为每个描述符搜索整个2D图像以找到可能的匹配，而MVS将在一条1D线上工作以找到匹配，从而大大简化了问题。因此，MVS通常会在优化过程中考虑照明和物体材质，而SfM则不会。
但是，有一个问题：PMVS2执行相当复杂的优化，可能会非常缓慢，或者在大图像序列上占用天文数字的内存。这是CMVS发挥作用的地方，将粗略的3D SfM输出聚集到区域中。然后，将在每个群集上（可能并行）调用PMVS2，以简化其执行。然后，CMVS将把每个PMVS2输出合并到一个统一的详细模型中
SfM旨在使用结构化（但未知）的图像序列执行3D重建，而MVS是基于人类立体视觉的双视立体视觉的概括
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/204f001f415214e4bbd962c99bbed94c/" rel="bookmark">
			Linux下Nginx配置文件nginx.conf默认位置修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx默认配置 安装时 nginx.conf所在位置为：/usr/local/nginx/conf/nginx.conf
本人需要将其移动到 /xxx/nginx 下
1、将原文件移动到自己需要更改的目录
mv /usr/local/nginx/conf/nginx.conf /xxx/nginx/
2、创建软连接到原目录
ln -s /xxx/nginx/nginx.conf /usr/local/nginx/conf/
3、启动/重启 nginx
/usr/local/nginx/sbin/nginx 或 /usr/local/nginx/sbin/nginx -s reload
转载于:https://www.cnblogs.com/51ma/p/11611332.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f876eda02ca6a8dcc71f8bb2fb254d1/" rel="bookmark">
			一步步带你看懂orbslam2源码--总体框架(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORB-SLAM2目录：
一步步带你看懂orbslam2源码–总体框架(一)
一步步带你看懂orbslam2源码–orb特征点提取(二)
一步步带你看懂orbslam2源码–单目初始化(三)
一步步带你看懂orbslam2源码–单应矩阵/基础矩阵,求解R,t(四)
一步步带你看懂orbslam2源码–单目初始化(五)
引言 谈谈SLAM技术,其实更准确地说来应该是SLAM框架.距今为止,SLAM其实已经发展了近30多年的历史,其理论框架已经大体成熟与定型,基本上都是分为前端视觉里程计,后端基于滤波或者非线性优化,回环检测以及建图等.该技术属于底层技术,主要是服务于上层应用的需求,目前的应用点有移动机器人,自动驾驶,无人机,AR,VR等.
SLAM从构建地图的种类进行划分,有稀疏地图,半稠密地图和稠密地图.顾名思义就是所构建地图的地图点数量的程度.从使用的传感器种类方面进行划分,有纯视觉SLAM(仅用相机),激光SLAM(纯用激光),视觉+IMU(Inertial measurement unit–惯性测量单元) SLAM,以及激光+视觉+IMU的方案.目前激光SLAM技术已经成熟,市面上的大多数扫地机器人还是采用纯激光的SLAM,但是目前激光雷达制造成本久居不下,市面价格更是及其离谱,好的激光,可能光光一个激光雷达就顶起来整辆车的价格(贵的十几万一个…),正是由于这样的原因,才促成了视觉SLAM和其他各种传感器方案的诞生.由于相机的廉价,且相机能提供丰富的场景信息,因此被广泛采用,许多学者也相继研究如何利用相机感知周围环境,构建出周围地图以及估计出自身运动轨迹.这些年来也诞生了许多优秀的纯视觉SLAM的(vSLAM)开源系统方案出来,例如:
稀疏地图:ORB-SLAM2(单目,双目,RGB-D,立体相机)
半稠密地图:LSD-SLAM(单目,双目,RGB-D)DSO(单目)SVO(单目,其实不能算一个完整的SLAM,仅VO)
稠密地图:RGB-D SLAM2(RGB-D)Kintinuous(RGB-D)Elastic Fusion(RGB-D)Bundle Fusion(RGB-D)InfiniTAM(RGB-D)RTAB-Map(RGB-D,双目,LIDAR) 然而,纯vSLAM方案虽然价格便宜,但是相机一直存在噪声大,易受曝光度的干扰,易受相机抖动的干扰,而IMU的测量频率非常高,且短时间内能够准确地测量出物体的三轴姿态角,具有较强的抗抖动干扰性能,与相机正好成互补.因此,相机+IMU的多传感器融合方案也被实际应用中广泛使用.例如,百度的Apollo5.0平台均采用了 视觉+IMU+激光雷达/毫米波雷达 的解决方案(当然,实际上远远不止那么简单…)目前,也拥有了一些比较优秀的多传感器融合方案,例如:
VINS(单目+IMU,双目+IMU)OKVIS(单目+IMU,双目+IMU)ROVIO(单目+IMU)RKSLAM(单目+IMU)Cartographer(LIDAR+IMU)V-LOAM(LIDAR+单目) 当然,随着这几年深度学习,机器学习的火起(虽然理论上貌似没有什么突破性进展,主要得益于计算机算力资源的巨大提升以及大量的数据,好像目前论文上也比较多水…同个方法改改应用场景等等…),笔者对此并没有深入了解,目前了解的开源方案就有:
CNN-SLAM:将LSD-SLAM里的深度估计和图像匹配都替换成基于CNN的方法,并可以融合语义VINet: Visual-inertial odometry as a sequence-to-sequence learing problem:利用CNN和RNN构建了一个VIO,即输入image和IMU信息,直接输出估计的pose3DMV: Joint 3D-Multi-View Prediction for 3D Semantic Scene Segmentation: 联合3D多视图预测网络在室内环境中进行RGB-D扫描的3D语义场景分割ScanComplete: Large-Scale Scene Completion and Semantic Segmentation for 3D Scans: 将场景的不完整3D扫描作为输入，能够预测出完整的3D模型以及每个体素的语义标签DeepVO: A Deep Learning approach for Monocular Visual OdometryLightweight Unsupervised Deep Loop Closure: 用CNN解决闭环问题 ORB-SLAM2 概述 好了,接下来开始介绍orb-slam2的内容,在以后的讲解过程中,笔者会先进行相关理论的解释,虽然有许多其他的文章也针对了orb-slam2进行讲解,但是大多数要么就仅限于理论上的讲解,缺乏细节上的把握,要么就是单单代码上的讲解(尽管也不尽详尽…).可能在笔者看来是极其简单的,可能就一句话带过了的内容(例如–采用金字塔提取ORB 特征点…),但在初学者看来可能就云里雾里了.因此,笔者会尽量讲解的通俗易懂,从理论出发,又紧紧抓住实现细节,结合部分orb-slam2源码进行讲解,使得初入门的读者也能够根据笔者所写的该系列教程,读懂orb-slam2源码.
咳咳咳~~,扯得有点多了,开始步入正题,同学们,跟紧啦!!!
orb-slam2总共有三个线程: Tracking , Local Mapping , Loop Closing线程(实际上其实还多了个Viewer线程,用于显示界面),Tracking 线程主要负责定位相机以及决定是否插入一个新的关键帧.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f876eda02ca6a8dcc71f8bb2fb254d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/705f21df42ea58f7881816938f795b19/" rel="bookmark">
			zabbix监控Tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编辑tomcat启动配置文件，开启监控
vi /opt/tomcat7/bin/catalina.sh CATALINA_OPTS="$CATALINA_OPTS -Dcom.sun.management.jmxremote -Djava.rmi.server.hostname=192.168.1.104 -Dcom.sun.management.jmxremote.port=12345 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false" yum安装zabbix yum install zabbix-server zabbix-agent httpd -y 编辑配置文件 /etc/httpd/conf.d/zabbix.conf, uncomment and set the right timezone for you. php_value date.timezone ASia/Shanghai systemctl restart zabbix-server zabbix-agent httpd systemctl enable zabbix-server zabbix-agent httpd http://192.168.1.106/zabbix/setup.php Admin zabbix Zabbix 的JMX监控架构
zaibbix Server--&gt;Java gateway--&gt;Tomcay(JMX counter)
yum安装zabbix-java-gateway
[root@node2 zabbix]# ps -ef|grep zabbix_java_gateway zabbix 9851 1 0 08:21 ? 00:00:29 java -server -Dlogback.configurationFile=/etc/zabbix/zabbix_java_gateway_logback.xml -classpath lib:lib/android-json-4.3_r3.1.jar:lib/logback-classic-0.9.27.jar:lib/logback-core-0.9.27.jar:lib/slf4j-api-1.6.1.jar:bin/zabbix-java-gateway-4.2.6.jar -Dzabbix.pidFile=/var/run/zabbix/zabbix_java.pid -Dzabbix.startPollers=5 -Dsun.rmi.transport.tcp.responseTimeout=3000 com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/705f21df42ea58f7881816938f795b19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb3ac1037ad642cc3d912e20c7533d0e/" rel="bookmark">
			程序员修炼之道：从小工到专家九月第一篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这半个多月，从老师介绍给我们这本书之后，我在网上又读了写别人的体验与感受，感觉收益颇丰，我虽然刚开始读，但是里面有一些名言警句感觉和我们练习的十分紧密。
第一句呢就是你说什么和你怎么做同等重要，这是从别人那看来的，书上写道，如果你不能有效的向别人传达你所想的，及时你有再好的想法也是没用的。谁然我还没有参加工作，不能够真正的了解到程序员的工作，但是，我觉的这句话和我们即使不是程序员都有重要的意义，无论是编程序，还是个人的生活，我们整体都是离不开团队的，团队真的很重要，我们需要把自己想象的传达给团队，让团队了解到你的想法，你们才能更好的配合在一起。
第二句呢就是不要假定，要用实际去证明，因为不去实际证明，只是去假定，你的代码不能运行，不能给出想要的结果，这个有什么用呢？
代码中出现的设计不合理，代码不规范等情况，要及时的去修复；就算没时间修复，也应该及时的放上TODO。
定时去获取知识，多去读一些书籍去获取知识。
转载于:https://www.cnblogs.com/sunhongbin/p/11609730.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c96856d7554f8c404b81da8fe4826ca8/" rel="bookmark">
			STAR软件安装以及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、获取软件
#Get latest STAR source from releases
wget https://github.com/alexdobin/STAR/archive/2.7.2b.tar.gz
tar -xzf 2.7.2b.tar.gz
cd STAR-2.7.2b
cd bin
cd Linux_x86_64 其下即有可运行二进制文件
./STAR
#Alternatively, get STAR source using git
git clone https://github.com/alexdobin/STAR.git
#Compile
cd STAR/source
make STAR
2、基本使用
step1、建立基因组索引文件index
–runThreadN NumberOfThreads
–runMode genomeGenerate
–genomeDir /path/to/genomeDir #index输出的路径
–genomeFastaFiles /path/to/genome/fasta1 #参考基因组序列，解压缩文件
–sjdbGTFfile /path/to/annotations.gtf #参考基因组注释文件
–sjdbOverhang ReadLength-1 #这个是reads长度的最大值减1，默认是100
（其他参数像产生gff3或者可变剪接比对等，需要加特殊参数）
step2、mapping
–runThreadN NumberOfThreads #线程
–genomeDir /path/to/genomeDir #index目录
–readFilesIn /path/to/read1 [/path/to/read2 ] #paired reads文件
–outFileNamePrefix /path/to/output/dir/prefix #默认结果输出pwd
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c96856d7554f8c404b81da8fe4826ca8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ddb95d1ec2ee381860770d72d467c1/" rel="bookmark">
			Apache源码包在LINUX（CENTOS6.8)中的安装（出现问题及解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务：在CENT6.8系统中安装Apache（版本为：httpd-2.4.41）
前提：由于源码包必须先编译后安装，所以必须先安装编译器：gcc
理论步骤：
1.检测gcc软件包，如果不存在则进行安装。
2.下载Aache的源码包（压缩包形式）并上传到CENTOS服务器中
3.解压源码包后进入解压后的目录，执行配置，编译，安装。
3.1 配置：使用 ./configure 进行安装目录的设置
3.2 编译：使用 make 命令直接执行
3.3 安装：使用 make install 命令直接执行。
4.如果无意外，按照“理论步骤'，完成后即可在CENTOS服务器启用httpd服务（运行apache）中，使用浏览器访问：
http://localhost/ 或 http://127.0.0.1 或 http://192.168.253.129 实际过程：
检测gcc服务包：
[root@cent001 ~]# rpm -q gcc
gcc-4.4.7-23.el6.x86_64
说明gcc服务包已经安装。进入”理论步骤“2
下载Aache的源码包（压缩包形式）并上传到CENTOS服务器中：
访问：http://mirror.bit.edu.cn/apache/httpd/ 找到：httpd-2.4.41.tar.gz 然后下载到本地。
然后通过FTP上传到CENTOS的个人源码包专用目录/usr/local/src 下边。进入”理论步骤“3
解压源码包
进入源码包压缩包的存储目录：
[root@cent001 ~]# cd /usr/local/src
解压httpd-2.4.41.tar.gz源码压缩包（会生成httpd-2.4.41目录）：
[root@cent001 src]# tar -zxvf httpd-2.4.41.tar.gz 查看解压后的源码包大小：（此操作不是必须）
[root@cent001 src]# du -sh httpd-2.4.41
46M httpd-2.4.41
进入源码包解压后目录：
[root@cent001 src]# cd httpd-2.4.41
开始进行”理论步骤“3.1
配置：使用 ./configure 进行安装目录的设置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12ddb95d1ec2ee381860770d72d467c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adc9914cc45a2bfd2d6b46eece0208a9/" rel="bookmark">
			AttributeError: module &#39;keras.backend&#39; has no attribute &#39;image_dim_ordering&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		if K.image_dim_ordering() == 'tf':
AttributeError: module 'keras.backend' has no attribute 'image_dim_ordering'
keras版本的问题，可以将语句修改为：
if K.image_data_format() == 'channels_first': 该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128x128的数据为例，“channels_first”应将数据组织为（3,128,128,128），而“channels_last”应将数据组织为（128,128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/221c9d5074b48d831679e81af3c5db0f/" rel="bookmark">
			redis 安装配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载安装RedisServer
mkdir –p /data/download &amp;&amp; cd /data/download
wget http://download.redis.io/releases/redis-5.0.0.tar.gz
tar zxvf redis-5.0.0.tar.gz
cd redis-5.0.0
make install
完成上面步骤之后，Redis相关bin文件件就已经安装到/usr/bin/local目录下了
配置RedisServer
mkdir –p /data/redis
cat &gt; /data/redis/redis.conf &lt;&lt; 'EOF'
port 6379
bind 0.0.0.0
#cluster-enabled yes
#cluster-config-file nodes.conf
#cluster-node-timeout 5000
appendonly yes
EOF
启动RedisServer
cd /data/redis
/usr/local/bin/redis-server ./redis.conf
配置守护服务
cat &gt; /etc/systemd/system/redis-6379.service &lt;&lt; ‘EOF’
[Unit]
Description=redis service
[Service]
WorkingDirectory=/data/redis/
ExecStart=/usr/local/bin/redis-server /data/redis/redis.conf
Restart=always
# Restart service after 10 seconds if the dotnet service crashes:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/221c9d5074b48d831679e81af3c5db0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c674aa90b4ffb728820158e73091cf/" rel="bookmark">
			VBA基础 - 分支和循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 编程语言的基础除了数据类型, 就是控制结构了. 所谓控制结构, 主要就是分支和循环.
分支 废话不说, 直接示例代码:
单条件判断 1 Sub Test() 2 If 2 &gt; 1 Then 3 Debug.Print "xxxx" 4 End If 5 End Sub 执行后输出:
xxxx 多条件判断 if-elseif-else 结构
1 Option Explicit 2 3 Sub Test() 4 score 55 5 score 65 6 score 85 7 score 95 8 End Sub 9 10 Function score(points As Integer) 11 12 If points &gt; 0 And points &lt; 60 Then 13 Debug.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37c674aa90b4ffb728820158e73091cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7be8af8322ef7cc6b19d7cf77af6c080/" rel="bookmark">
			AD自动布地过孔设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在PCB设计完成后需要对大面积的铜皮添加地过孔，之前都是通过手动添加。现在发现AD有这个功能，试了一下效果不错。
增加地孔可以减小地阻，增加铜皮之间的连接性能。
步骤如下：
1、在tool-via stitching-add stitching to net 设置规则如下：
设置孔间距，孔径以及属性。建议设置3mm（118mil）间距
效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6aabcb58c4b57e6437654c5e4e28c27/" rel="bookmark">
			centos7 安装 bugfree3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装apache yum install httpd 2. 安装mysql wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm yum -y install mysql57-community-release-el7-10.noarch.rpm yum -y install mysql-community-server #开启MySQL服务 systemctl start mysqld.service #查看MySQL状态 systemctl status mysqld.service #获取密码 grep "password" /var/log/mysqld.log #使用密码登陆 mysql -uroot -p #修改密码长度规则 mysql&gt; set global validate_password_policy=0; mysql&gt; set global validate_password_length=1; #修改root密码 ALTER USER 'root'@'localhost' IDENTIFIED BY '111111'; 创建新用户： CREATE USER 'bugfree'@'localhost' IDENTIFIED BY '123456'; 新用户授权： grant all privileges on *.* to bugfree@localhost identified by '123456'; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6aabcb58c4b57e6437654c5e4e28c27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90de623de840e9d904b3e982e538b82d/" rel="bookmark">
			华东验证码——待补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 from selenium import webdriver 2 from selenium.webdriver.support.ui import WebDriverWait # 等待元素加载的 3 from selenium.webdriver.common.action_chains import ActionChains # 拖拽 4 from selenium.webdriver.support import expected_conditions as EC 5 from selenium.common.exceptions import TimeoutException, NoSuchElementException 6 from selenium.webdriver.common.by import By 7 from selenium.webdriver.common.keys import Keys 8 from PIL import Image 9 import requests 10 import time 11 import re 12 import random 13 from io import BytesIO 14 15 16 def merge_image(image_file, location_list): 17 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90de623de840e9d904b3e982e538b82d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bacbd7b67d592da70ebd9aa02c7596b/" rel="bookmark">
			Qt 错误：collect2:ld returned 1 exit status
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现collect2:Id returned 1 exit status错误的原因，大概可以分为以下三种情况：
1、编译成功的例子在后台执行，有时一闪而过，如果再次 build ，则会提示上述错误。
解决方法：① 在任务栏将小窗口关闭；② 直接关闭QtCreator；③ 打开任务管理器，找到相对应的exe进程，关闭即可。
2、没有编译成功的情况下，最常见情况是程序本身需要 #include 的头文件被遗漏了。
解决方法：细心查找基类所用的头文件，#include 之后即可。
3、.h文件中相关的槽函数在cpp文件中没有定义。
解决方法：查找遗漏的槽函数，根据需要，具体的定义。（除虚函数外，其余函数有定义，必须有实现）
4、.h文件中声明了全局变量，.cpp文件的函数里面使用了该全局变量。
解决方法：.cpp文件外面没有初始化全局变量，初始化即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2737b57160006f29607cc3f0de964aba/" rel="bookmark">
			Vue公众号开发调用微信扫一扫接口实现扫码功能（JSSDK）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、安装、引用微信js-sdk #通过yarn安装 yarn add weixin-js-sdk#通过npm安装 npm i weixin-js-sdk项目中的引用 import wx from 'weixin-js-sdk' 2、调用sign接口传入当前环境的url、公众号签名信息 3、methods（数据处理） wx.scanQRCode 调用微信的扫一扫接口（官方文档地址可查看参数介绍）needResult 默认为0，扫描结果由微信处理，1则直接返回扫描结果（根据自己的项目需求）resultStr 二维码中携带的参数 (needResult为1时，扫码返回结果)处理扫码后的参数并赋值，调用项目中的接口跳转页面等操作（根据自己的项目需要） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4baecc9eaa7890ad4e9117af5963e891/" rel="bookmark">
			angular 监听离开页面执行相关操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$scope.$on("$destroy", function() {
//...
}) 转载于:https://www.cnblogs.com/zzs-zone/p/11599244.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df994597b93e65ba400be2eddea6e6f/" rel="bookmark">
			mysql,按键精灵,读取写入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//打开数据连接 https://www.newasp.net/soft/110660.html 下载 组件 Function connOpen() Set conn = CreateObject("ADODB.Connection") conn.ConnectionString = "DRIVER={MySQL ODBC 3.51 Driver};" &amp; _ "SERVER=localhost;" &amp; "UID=root; PWD=root; OPTION=3; DATABASE=demo;stmt=SET NAMES GB2312" '注意ODBC驱动版本号，现在最新的 MySQL 5.4 + ODBC 5.1 '另外可以有 DATABASE=XX，或者在程序里使用 use database 语句 'OPTION是什么作用不知道，我这里可以不写 conn.Open Set rs = CreateObject("ADODB.Recordset") rs.CursorLocation = adOpenKeyset'游标位置（数据集存在服务器内存还是客户端内存）//有警告信息可以突略 adOpenKeyset adUseNone https://blog.csdn.net/xzsfg6825/article/details/80047946 End Function //执行记录 Function mysql_query(sql) Call connOpen() conn.Execute sql rs.Close Set rs = Nothing db.Close Set db = Nothing End Function //获取数据列表 Function mysql_list(sql) Call connOpen() rs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8df994597b93e65ba400be2eddea6e6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b29ba7b5fce7be4975e2cfad5525220a/" rel="bookmark">
			VBA基础 - 数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 学习一种新语言, 数据类型和关键字是第一步.
数据类型 常用的数据类型如下:
类型存储空间范围Boolean2 bytesTrue 或者 FalseByte1 byte0 ~ 255Integer2 bytes-32768 ~ 32768Long4 bytes-2147483648 ~ 2147483647LongLong8 bytes-2147483648 ~ 2147483647String10 bytes + string length0 ~ 20 亿个字符Object4 bytes可以赋值给任何对象引用Single4 bytes-3.402823E38 ~ -1.401298E-45 (对负值)1.401298E-45 ~ 3.402823E38 (对正值)Double8 bytes-1.79769313486231E308 ~ -4.94065645841247E-324 (对负值)4.94065645841247E-324 ~ 1.79769313486231E308 (对负值)Date8 bytes100 年 1 月 1 日 ~ 9999 年 12 月 31 日 0:00:00 ~ 23:59:59Variant16 bytes任意值, 性能较低 VBA 中提供了一系列 函数用于类型之间的转换
运算符 运算符是和数据类型同样, 是使用最多的部分.
类型运算符说明示例算术运算符*乘法MyValue = 2 * 2 ' Returns 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b29ba7b5fce7be4975e2cfad5525220a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18da0598aa3fd3898bc016fb94f86bdd/" rel="bookmark">
			RT-thread国产实时操作系统概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RT-Thread实时操作系统是一个分层的操作系统，它包括了：
• 组件层components，这些是基于RT-Thread核心基础上的外围组件，把一些功能模块划分成独立的一个个组件模块，做到组件与组件之间的低耦合，组件内部的高内聚。
例如文件系统，命令行shell接口，lwIP轻型TCP/IP协议栈，GUI图形用户界面等。
• 硬实时内核kernel，这层是RT-Thread的核心，包括了内核系统中对象的实现，例如多线程及其调度，信号量，邮箱，消息队列，内存管理，定时器等实现。
•分支接口porting，主要由libcpu以及不同硬件平台的bsp构成，即RT-Thread支持的一个个芯片移植，外设驱动等
在官网http://www.rt-thread.org/下载RT-Thread v2.0.0正式版，解压后：
bsp： 针对各个具体开发板、平台的目录，其中包含相应的Keil工程文件（如果包含了Keil MDK的移植）
components：各个组件，如dfs/drivers/finsh/gdb/libc/libdl/net/vbus/vmm等
documentation/examples：辅助文档以及一些内核、组件的测试实例
include：包含了RT-Thread内核头文件
libcpu： 面向各个芯片cpu移植的代码
src：包含了RT-Thread内核源文件
tools：支持各种集成开发环境的python文件，如常见的iar.py/keil.py/sconsui.py/vs2012.py
v2.0.0版本相对v1.2.x版本，又加入众多新功能，有些很有趣，有些很实用：
1. 设备驱动框架在v2.0.0版本中进一步完善。DeviceDriver在RT-Thread中类似抽象的驱动框架层，初衷是，向应用层（或组件）提供标准统一的接口，向下（底层硬件）提供简化的编程模型，在v2.0.0版本中，新添加了：SPI NorFlash（ATMEL/SST/华邦等厂家），SPI ETH（ENC28J60），SPI WiFi（RW009）等的驱动，这些驱动依赖于RT-Thread的SPI抽象模型，提供了抽象、无需修改的外设驱动代码；类似的，建立在I2C驱动框架上，v2.0.0版本也引入了sensor的驱动框架，并提供了MPU6050、BMI055等传感器的驱动；作为杂类设备的尝试，GPIO(IO pin)的抽象框架也终于在这个版本提出来了，以后点灯简单啦！
2. 在1.x系列版本中，USB device/host框架支持得一般，不能说非常棒，而在v2.0.0版本中，USB框架通过逐步的重构，也开始走向成熟，在服务公司里也应用到多个项目，多个处理器上；
3. 为了方便的切换不同的编译器平台，在v2.0.0版本中也把原来的minilibc/newlib/armlibc用统一的宏替换：RT_USING_LIBC。老版本的代码迁移过来，请注意下使用新的、统一的宏：RT_USING_LIBC。同时也加入了IAR的dlib，这样当配置中打开LIBC时，scons将会自动根据你当前使用的编译器来自动选择不同libc库的移植；
4. GDB stub，这部分是CSDN编程夏令营活动的成果之一，一直觉得类似夏令营的活动很好，可以拉近学生和开发者的距离。通过这个组件，终于可以让RT-Thread可以进行软件方式的调试了，虽然是命令行方式的GDB，但它也有很多图形化前端配合来进行源码级的调试仿真；
5. lwIP相关的更新。这个貌似有很多，引爆点应该说是一个很热门的词：物联网。围绕着这个，v2.0.0版本中加入了RW009这样的简单易用的Wi-Fi网卡驱动，IPv4/v6双协议栈的支持，DHCP server，甚至是NAT这样的地址转换实现，哦，用RT-Thread来做小路由，网关变成了可能。哦，RT-Thread的目标并不是物联网，更重要的是它是一套基础性的软件平台。
6. 随着Linux/RT-Thread同时执行的方式，相应的VMM组件，VBUS组件也在这个版本上发布出来。VMM组件更多的侧重于单核，Linux/RT-Thread双系统并行执行以获得更好的实时性，而VBUS组件则解决了Linux/RT-Thread双系统之间的数据通信问题。两者是相辅相成的。这两个组件要求的技术性也更高，一般用于一些可靠性要求非常高的场合。在RT-Thread 2.0.0版本中也终于支持了LPC4357这样的小异构系统（LPC4357中包含了ARM Cortex M4/M0两个异构核心），实现了M4/M0上分别运行RT-Thread系统，两者之间则通过VBUS进行通信。所以，对多系统/VBUS感兴趣的同学可以从LPC4357上入手。
在开发的过程中也出现了一个附加品，QEMU/realview上模拟执行RT-Thread（或者Linux/RT-Thread）的BSP，它可以让未经修改的标准QEMU，去软件仿真模拟执行RT-Thread，或更进一步，执行Linux/RT-Thread。
RT-Thread v2.1.0 roadmap
下一个版本应该是一个小版本，不可能总是类似原来，每次都出大版本很多人来询问过下一个版本的计划是什么。其实我想说，RT-Thread是一个开源社区，RT-Thread的后续发展在社区，属于每一个社区参与者，你想在里面加入什么样的功能，做好哪部分的工作，关键在于每个社区的参与者。只要符合RT-Thread的东西（例如许可证上没有冲突），我也没理由不把它放到RT-Thread开发主干上来。所以我下面提及的更多代表的是我个人的一些想法，社区还是需要更多的多样性，社区是属于你的，只要你参与进去做！
1. CloudIDE，这个是托管在http://lab.rt-thread.org/cloudide 上（可能因为备案的问题暂时不通）的在线方式的集成开发环境，嗯，有些类似mbed但是希望有自己的特色，以及希望它是属于国内的Online IDE，速度能够快些。这部分也在密集的进行改版，演变成多标签页编辑方式；配合Wi-Fi入门套件，进行在线方式更新固件；加入开发者间的代码片段，组件分享功能；集成文档帮助等信息等等；创建这个的初衷是希望新手入门能够方便些，而不是受搭建开发环境的困扰，需要的只是一个浏览器。Wi-Fi入门套件，暂时称为ART-wifi吧，简单的名字就是一个称呼，名字而已。
2. 去年12月份上海嵌入式沙龙活动中，weety提到了POSIX兼容性的问题，导致Linux的一些程序并不那么容易移植过来（或者说后续的代码一致性），这里主要问题在于BSD socket接口是完全属于lwIP协议栈，而和RT-Thread的文件接口没关系，所以在RT-Thread上没有socket/file descriptor/device间的select/poll/read/write等调用；另外一个隐含问题是，POSIX实现也不是那么标准，可能里面还有一些坑等。这个问题是一个大问题，因为关键点在于，大家既然选择了开源的系统，那么他肯定也考虑到开源生态很好，有很多的资源可以使用，可以左右逢源。。。所以，RT-Thread也需要以更开放的姿态来解决这个问题，使得它能够更开放，增强POSIX标准本身的亲和力。相类似的，它也应该更好地支持一些C++标准，基础设施RT-Thread已经提供了，后面如何去应用，那么就看用户的想法、创新性有多大了。
3. 一些重型平台的支持，例如市场上新出的一些堆叠封装了SDRAM/DDR的ARM9，Cortex-A8/9，MIPS32/64，甚至是x86，这个肯定也会逐步地演变成RT-Thread的目标硬件平台，但是这个投入也会比较重。如果上面的第二项解决了，也不是不可能，首要解决的是底层驱动的问题，这样后续就比较容易和上面的组件、应用粘合起来。
好了，以下是想到的无责任feature list，感兴趣的同学可以来认领：
* CloudIDE相关
- 完善NAT功能，把ART-wifi变成一个Wi-Fi中继（路由）。
- 期待在CloudIDE上分享MQTT组件，CoAP组件；
- 期待把ART-wifi变成一个Wi-Fi/6LoWPAN网关。
- 期待把ART-wifi变成一个Wi-Fi/nRF51822 6LoWPAN网关，Wi-Fi/nRF51822 BLE网关；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18da0598aa3fd3898bc016fb94f86bdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81d47f8fded3f0f22e07b968e04c3d4/" rel="bookmark">
			Vue实现仿iPhone悬浮球
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue实现仿iPhone悬浮球 悬浮球插件简单的效果图：
很遗憾，没找到太好的视频转gif的软件，压缩出来的大小超过了限制，就不放图了
可以参考其他人的图，效果一致：
简单实用案例： &lt;!-- 给定一个初始位置position，插槽中填写想滑动的部分 --&gt; &lt;xuanfuqiu :position="position"&gt; &lt;d-add-button @click="addPigFarm" add-item="猪场"&gt;&lt;/d-add-button&gt; &lt;/xuanfuqiu&gt; 原理示意图 请结合代码注释来理解
悬浮球插件代码如下： &lt;template&gt; &lt;div&gt; &lt;div class="xuanfu" id="moveDiv" :style="position" @mousedown="down" @touchstart="down" @mousemove="move" @touchmove="move" @mouseup="end" @touchend="end"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "", components: {}, props: { // 通过position来设置初始定位 position: { type: Object, default: function() { return { top: "32.25rem", left: "18.34375rem" } } }, // 通过fixed来禁用自由移动 fixed: { type: Boolean, default: false } }, data() { return { flags: false, positionTemp: { x: 0, y: 0 }, // 记录手指点击的位置 nx: '', ny: '', dx: '', dy: '', xPum: '', yPum: '', } }, watch: {}, computed: {}, methods: { // 实现移动端拖拽 down(){ if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c81d47f8fded3f0f22e07b968e04c3d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/861ea182d8106c596bf9f45d45555cf2/" rel="bookmark">
			指针02
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.类型的转换 1）基础类型之间可以进行转换 例如：下面的代码可以通过编译 int x = 1; char y = 2; x = y; 2）基础数据和结构类型之间不能转换 无法通过编译： struct st{ int a; int b; }; void fun() { st t1 = {1, 2}; int x = (int) t1; } 3）待*的类型的转换 带*的基础类型和带*的结构类型之间可以转换 例如：可以通过编译： struct st{ int a; int b; }; void fun() { int* x = (int*)1; st* y = (st*)x ; } 2.&amp;符号 &amp;是地址符，类型是其后面的类型加一个“*”，任何变量都可以使用&amp;来获取地址，但不能用在常量上。 获取变量a的地址： int a = 1; int* pa = &amp;a; &amp;a的类型就是变量a的类型加上一个*；例如这里a是int，&amp;a就是int*； 带*的类型通常赋值是必须用完整写法： int* a = (int*)1; 和取地址符&amp;一起使用时可以简写； char a = 10; short b = 20; int c = 30; char* pa = (char*)&amp;a; short* pb = (short*)&amp;b; int* pc = (int*)&amp;c; 简写为： char* pa = &amp;a; short* pb = &amp;b; int* pc = &amp;c; 带更多*的类型也一样： char a = 10; short b = 20; int c = 30; char* pa = &amp;a; short* pb = &amp;b; int* pc = &amp;c; char** ppa = (char**)&amp;pa; short** ppb = (short**)&amp;pb; int** ppc = (int**)&amp;pc; 简写为： char** ppa = &amp;pa; short** ppb = &amp;pb; int** ppc = &amp;pc; 反汇编分析： 代码： void fun() { int x = 1; int* y; y = &amp;x; } 反汇编： 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/861ea182d8106c596bf9f45d45555cf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04f21b8144b8d16b60343d6165b95869/" rel="bookmark">
			指针01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.带星号“*”的类型 任何一种数据类型的变量前面加上一个或多个*，将变成带*的类型； 例如：int* x； 2.声明方式 推荐的方式：可以清晰的看到是一个带星号的变量 char* x; short* y; int* z; float* f; double* d; Student* st; 不推荐的方式：不报错，但看起来不直观 char *x; short *y; int *z; float *f; double *d; Student *st; 也可以一个或多个星号 char** x; short*** y; int** z; float** f; double***** d; Student****** st; 总结： 1、带有*的变量类型的标准写法：变量类型* 变量名 2、任何类型都可以带* 加上*以后是新的类型 3、*可以是任意多个 3.赋值和宽度 char、short、int 类型变量的赋值： 带*类型的变量的赋值：只能用完整写法 数据宽度： 代码： void fun() { char* x = (char*)5; } int main(int argc, char* argv[]) { fun(); getchar(); return 0; } 反汇编： 总结： 1、带*类型的变量赋值时只能使用“完整写法”.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04f21b8144b8d16b60343d6165b95869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8079b22597b9d1a3e15e9fb5b6e00b3d/" rel="bookmark">
			springboot &#43; websocket &#43; centos7服务器（nginx）404问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决办法添加下面两行：
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection “upgrade”;
具体配置：
location /{ proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_set_header X-Forwarded-Proto https; proxy_set_header X-real-IP $remote_addr; proxy_set_header X-Forwarded-proto $scheme; //添加这两行即可 proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_connect_timeout 240; proxy_send_timeout 240; proxy_read_timeout 240; proxy_pass http://localhost:8080; proxy_redirect ~^http://([^:]+)(:\d+)?(.*)$ https://$1$3; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ca730f7befb2647d40af1394f4a54ff/" rel="bookmark">
			姿态估计&amp;目标检测论文整理（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、姿态估计 1. 现阶段人体姿态识别主流的通常有2个思路： Top-Down（自上而下）方法：将人体检测和关键点检测分离，在图像上首先进行人体检测，找到所有的人体框，对每个人体框图再使用关键点检测，这类方法往往比较慢，但姿态估计准确度较高。目前的主流是CPN，Hourglass，CPM，Alpha Pose等。Bottom-Up（自下而上）方法：先检测图像中人体部件，然后将图像中多人人体的部件分别组合成人体，因此这类方法在测试推断的时候往往更快速，准确度稍低。典型就是COCO2016年人体关键点检测冠军Open Pose。 六种人体姿态估计的深度学习模型和代码总结
2. 姿态估计标注方法 数据的基本结构是:
[{“image_id”:[], “category_id”:[], “keypoints”:[], “score”:[] }] “keypoints”是长度为3K的数组([x,y,v])，K是对某类定义的关键点总数，这里人体的keypoint就是17个.位置为[x,y]，关键点可见性v. 如果关键点没有标注信息，则关键点位置[x=y=0]，v=0；如果关键点有标注信息，但不可见，则可见性v=1；如果关键点在物体segment内，则认为可见v=2。
（a）17关键点
（b）18关键点
人体姿态估计数据集整理（Pose Estimation/Keypoint）：
3. 评价标准 主要评价标准包括以下两种，PCK的评价标准多出现在单人的姿态估计上，多人的姿态估计评价标准基本上为mAP，比赛和学术论文中mAP成为衡量结果的必须指标。
3.1 PCK Percentage of Correct Keypoints (PCK)，reports the percentage of keypoint detection falling within a normalized distance of the ground truth.
3.2 mAP 人体骨骼关键点的评价指标类比通用的物体检测评价方式，将最终的mAP(mean Average Precision)值作为评价依据。物体检测任务中使用IoU(Intersection over Union)来评价预测与真实标注之间的差异，在人体骨骼关键点检测任务中，我们使用OKS(Object Keypoint Similarity)代替IoU，对选手预测的人体骨骼关键点位置与真实标注之间的相似性进行打分。
3.3 OKS 其中 d i d_i di​是检测到的关键点与标签关键点之间的欧式距离， v i v_i vi​是标签的可见性标签，s是目标尺度， k i k_i ki​是每类关键点的相关控制衰减常数。每个关节点的相似度都会在 [0,1]之间，完美的预测将会得到OKS~1，预测值与真实值差距太大将会得到OKS~0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ca730f7befb2647d40af1394f4a54ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fd963bf521798e3080c3849ab5b05ac/" rel="bookmark">
			Molecular Dynamics
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		First]前处理
Second]运行MD
Third]后处理
一、获得结构文件-来自实验数据或者某些化学软件工具
1】第一步: 获取并处理pdb文件
从Protein Data Bank下载小肽的pdb文件1OMB.PDB(或点击这里下载). 在Linux下你可使用如下命令:
wget http://www.rcsb.org/pdb/files/1OMB.pdb
二、选择力场，获得力场参数
pdb2gmx -f *.pdb -o *.gro -ignh -ter -water spc
三、构建盒子（editconf），填充溶剂分子（genbox），添加离子（genion）
四、能量最小化Energy Minimination（grompp--&gt;em.tpr；mdrun）
五、温度平衡（NVT），压力平衡（NPT）
六、成品MD模拟
七、结果分析
转载于:https://www.cnblogs.com/ljd4you/p/11593853.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b569bdb924003c2874290c0f877fb70/" rel="bookmark">
			alarm唤醒系统过程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android的aralm可以唤醒系统，先看ararm调用过程
http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/app/AlarmManager.java
public void set(@AlarmType int type, long triggerAtMillis, PendingIntent operation) { setImpl(type, triggerAtMillis, legacyExactLength(), 0, 0, operation, null, null, null, null, null); } private void setImpl(@AlarmType int type, long triggerAtMillis, long windowMillis,long intervalMillis, int flags, PendingIntent operation, final OnAlarmListener listener,String listenerTag, Handler targetHandler, WorkSource workSource,AlarmClockInfo alarmClock) { mService.set(mPackageName, type, triggerAtMillis, windowMillis, intervalMillis, flags, operation, recipientWrapper, listenerTag, workSource, alarmClock); } http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/AlarmManagerService.java
private final IBinder mService = new IAlarmManager.Stub() { @Override public void set(String callingPackage, int type, long triggerAtTime, long windowLength, long interval, int flags, PendingIntent operation, IAlarmListener directReceiver, String listenerTag, WorkSource workSource, AlarmManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b569bdb924003c2874290c0f877fb70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0afd2968d7729ae383269a89fbe39f8/" rel="bookmark">
			经典圣杯双飞翼布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.经典的双飞翼布局，两边的盒子宽度固定，中间的内容宽度自适应，在某宝某东等一些电商平台比较常见，里面利用了margin的负边距来布局，这样使三个盒子在同一行显示。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body{ outline: none; padding: 0; margin: 0; color: #fff; } .header { height: 40px; width: 100%; background-color: #a01321; } .container{ height: 400px; margin: 0 200px; } .left{ width: 200px; height: 400px; background-color: green; float: left; margin-left: -100%; position: relative; left: -200px; } .center{ float: left; height: 400px; width: 100%; background-color: red; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0afd2968d7729ae383269a89fbe39f8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/392/">«</a>
	<span class="pagination__item pagination__item--current">393/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/394/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>