<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8339ad8e9e80f4120c3eec13d380b8c0/" rel="bookmark">
			cannot open shared object file: No such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在一台Linux上编译库文件和执行文件后，放到另一台Linux机器上，执行报错，显示： cannot open shared object file: No such file or directory。
首先确认执行文件（test）放在对应的环境变量bin和库文件（libtest.so）放在了对应的环境变量lib下。
假设环境变量$(HOME)为 /root ，则执行文件（test）放在 /root/bin/目录下，库文件（libtest.so）放在 /root/lib/目录下。
出现这种问题的原因是程序运行时没有找到代码里指定的库路径，而库路径是由环境变量LD_LIBRARY_PATH 指定。
方法1 可以在终端先执行下面的指令，再运行程序：
export LD_LIBRARY_PATH=/root/lib:$LD_LIBRARY_PATH 如果libtest.so 放在/usr/lib下，则执行如下命令
export LD_LIBRARY_PATH=/usr/lib:$LD_LIBRARY_PATH 方法2 直接把下面这句内容通过vi的方式写到~/.bashrc ， 然后source一下生效。
vi ~/.bashrc #在文件最后添加如下内容 export LD_LIBRARY_PATH=/root/lib:$LD_LIBRARY_PATH 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ab06d93a5c567ff2bd017ec52bc073d/" rel="bookmark">
			YOLOv5训练速度慢 GPU占用率低
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Yolo5跑自己的数据集，torch_GPU和CUDA都安装了，使用GPU跑模型，GPU的占用率为1%，设置的epoch为300，batch size为32，大概6min多/epoch，数据集很小，刚过一千。在网上查了相关的文章，发现可能是读取数据造成的，把cache-image的action='store_true'改成'store_false'。 改成
修改后 每epoch大概是13s！超级快，GPU的占用率变到33%，CPU的占用率50%。
后面再想办法改一改，计算机小白学习好难，论文好难（哀嚎~）！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3601485a242829da8ce1b85d404361f8/" rel="bookmark">
			OpenCV(6): 梯度计算,礼帽黑帽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		没看过前文也没有关系，了解腐蚀和膨胀就行。本文紧接前文图像腐蚀与膨胀。
梯度计算 梯度计算就是膨胀过后的图像减去腐蚀处理过后的图像。图像腐蚀就是消除图像的边缘，图像膨胀就是把图像边缘扩大一点。
这样得到的就是图像的轮廓。
在OpenCV中，梯度计算方法也被包括在形态学方法cv2.morphologyEx(src，op，kernel)中
src为输入图像
如果要进行梯度运算，参数设置op=cv2.MORPH_GRADIENT
kernel为采用的卷积核，本文采用卷积核为3*3的矩阵。
import cv2 import numpy as np #定义了一个展示图片的方法 def cv_show(title,img): cv2.imshow(title,img) cv2.waitKey(0) cv2.destroyAllWindows() return #读取图片 img = cv2.imread('circle.png') kernel = np.ones((3,3),dtype = np.uint8) gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT,kernel) cv_show('gradient',gradient) 原图与输出对比
原图'circle.png'
输出图像：
大家也可以用自己的二值图试试，本文的图像就是windows自带的画图软件画的，画一个黑色的底和一个白色的圆就行，二值图的意思是一种由黑色和白色两种颜色组成的图像，其中只有两个像素值。
礼帽 礼帽就是原始图像减去开运算之后的图像
同样包括在形态学方法cv2.morphologyEx(src，op，kernel)中，
此时参数op = cv2.MORPH_TOPHAT import cv2 import numpy as np def cv_show(title,img): cv2.imshow(title,img) cv2.waitKey(0) cv2.destroyAllWindows() return img = cv2.imread('Hello.png') kernel = np.ones((3,3),dtype = np.uint8) tophat = cv2.morphologyEx(img,cv2.MORPH_TOPHAT,kernel)#高帽找刺 cv_show('tophat',tophat) 原图和结果对比：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3601485a242829da8ce1b85d404361f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9af35c724a0a666517beefc0594fbc15/" rel="bookmark">
			3.31笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、复合选择器
复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的,目的是为了可以选择更准确更精细的目标元素标签。
(1)、交集选择器
交集选择器由两个选择器构成，其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special。
记忆技巧：交集选择器是并且的意思。 即...又...的意思
比如：p.one选择的是类名为.one的段落标签。
(2)、并集选择器
并集选择器（CSS选择器分组）是各个选择器通过&lt;strong style="color:#f00"&gt;逗号&lt;/strong&gt;连接而成的，任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式。
记忆技巧：并集选择器是和的意思，就是说，只要逗号隔开的，所有选择器都会执行后面样式。
比如：.one, p, #test{color: #F00;}表示.one和p和#test这三个选择器都会执行颜色为红色。通常用于集体声明。
(3)、后代选择器
后代选择器又称为包含选择器，用来选择元素或元素组的后代，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。
子孙后代都可以这么选择。 或者说，它能选择任何包含在内的标签。 (4)、子代选择器
子元素选择器只能选择作为某元素子元素的元素。其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个&gt;进行连接，注意，符号左右两侧各保留一个空格。
白话：这里的子，指的是亲儿子，不包含孙子、重孙子之类。
比如：.demo &gt; h3 {color: red;}说明h3一定是demo亲儿子。demo元素包含着h3。
二、伪类选择器
伪类选择器用于向某些选择器添加特殊的效果。比如给链接添加特殊效果，比如可以选择第1个，第n个元素。
为了和我们刚才学的类选择器相区别，类选择器是一个点，比如: .demo{}而我们的伪类用2个点就是冒号。比如:link{}
(1)、链接伪类选择器
:link /* 未访问的链接 */
:visited /* 已访问的链接 */
:hover /* 鼠标移入时 */
:active /* 鼠标单击时 */
如果&lt;a&gt;标签四个伪类的书写顺序不正确，会导致链接的四种状态显示效果错乱，或有的状态会无效，为了避免这种情况，我们在设置的时候，务必保证书写顺序是正确的。，也就是我们常说到的LoVe HAte原则（大写字母就是它们的首字母）
&lt;a&gt;标签伪类的书写顺序是a:link、a:visited、a:hover、a:active
1、清除无序列表的小点
{ list-style:none; }
2、清除a的下划线
{ text-decoration:none;}
3、宽高属性
注意要加单位px
{
width:200px;
height:200px;
}
三、标签显示模式
(1)、块状元素
每个块元素通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。
常见的块元素有h1-h6/p/div/ul/li/ol/dl/dd/dt/table/tr/caption/form等，其中&lt;div&gt;标签是最典型的块元素。
块级元素的特点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9af35c724a0a666517beefc0594fbc15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8777856dc023dca8b1b0e44cba892130/" rel="bookmark">
			预测交通拥堵，TranSEC助力城市交通“智”变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TranSEC是由美国能源部太平洋西北国家实验室（Pacific Northwest National Laboratory）开发的、旨在帮助城市交通工程师获取其所在城市交通模式信息的工具。
目前，以街道为单位的公开的交通信息并不完整，交通工程师通常依靠孤立的交通量观测值、碰撞和车速数据来确定交通状况。而TranSEC可以将这些交通数据进行整合，绘制出实时的街道级交通流。
协助开发TranSEC的计算机科学家Arif Khan说：“它（TranSEC）的神奇之处在于，可以帮助交通工程师评估大城市的街道水平。”“不像其他的模型只能在某一特定区域工作，TranSEC是便携式的，可以应用到任何有交通流的城市区域。”
TranSEC能够绘制出实时的街道级交通流
TranSEC是评估街道运输状态的工具，它优于其他交通监控设施的地方在于，能够将那些不完整、甚至是碎片的交通信息整合，并作出接近实际的实时街道运输水平的评估。
利用1500平方英里洛杉矶市区的公共交通数据进行训练，该团队将创建交通拥堵模型所需的时间减少了一个数量级——从数小时缩短到几分钟，并通过PNNL的高性能计算资源的提速功能使得近实时的流量分析变得可行。
利用PNNL的数据驱动方法，用户可以在运输控制中心定期上传实时数据并定期更新TranSEC。利用PNNL的数据驱动方法，人们还可以计算出天气等因素对道路状况的影响指数。
该队在今年8月的虚拟城市计算研讨会（SIGKDD）上分享了他们的研究成果。同为与会者的马里兰大学高级交通技术中心的研究工程师Mark Franz表示：“TranSEC可能会引发交通监测和预测系统移动性能的范式转变”。
TranSEC的机器学习功能意味着，随着越来越多的数据将被获取和处理，其对街道级交通状况的评估和预测结果将变得更加精准。这种分析能力可以帮助交通工程师了解交通干扰因素是如何在网络中传播的，工程师也可借此做出正确决策并及时纠正决策。
就像情景感知可以帮助驾驶员做出决策一样，TranSEC的方法也可以在系统范围内提供情景感知，以帮助减少城市交通拥堵。
PNNL计算机科学家、TranSEC项目的首席研究员Robert Rallo说：“能够预测一个小时或更长时间内道路情况的能力非常有价值，因为它可以知道阻塞将在何处发生。”
虽然运行整个国家所有城市的交通模型需要更高性能的计算资源，但TranSEC具有可扩展性。TranSEC项目经理Katherine Wolf说：“我们正在努力使TranSEC在全国各地都能使用。”
参考：
1.https://techxplore.com/news/2020-12-machine-tool-tracks-urban-traffic.html
2.https://www.newswise.com/doescience/?article_id=742660&amp;returnurl=aHR0cHM6Ly93d3cubmV3c3dpc2UuY29tL2FydGljbGVzL2xpc3Q
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f150ec4759d5389fea46a9006126adaa/" rel="bookmark">
			头歌机器学习---sklearn中的kNN算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第1关 使用sklearn中的kNN算法进行分类
from sklearn.neighbors import KNeighborsClassifier def classification(train_feature, train_label, test_feature): ''' 使用KNeighborsClassifier对test_feature进行分类 :param train_feature: 训练集数据 :param train_label: 训练集标签 :param test_feature: 测试集数据 :return: 测试集预测结果 ''' #********* Begin *********# clf = KNeighborsClassifier() clf.fit(train_feature, train_label) return clf.predict(test_feature) #********* End *********# 第2关 使用sklearn中的kNN算法进行回归
from sklearn.neighbors import KNeighborsRegressor def regression(train_feature, train_label, test_feature): ''' 使用KNeighborsRegressor对test_feature进行分类 :param train_feature: 训练集数据 :param train_label: 训练集标签 :param test_feature: 测试集数据 :return: 测试集预测结果 ''' #********* Begin *********# clf=KNeighborsRegressor() clf.fit(train_feature, train_label) return clf.predict(test_feature) #********* End *********# 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51f7000ebef00be8ae12cc9e1d6511dd/" rel="bookmark">
			安卓杀进程重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特别是包含fragment 的时候
正常情况：1.切到后台，系统杀掉，再次启动 2.屏幕切换
模拟：1.开发者选项-&gt;打开不保留活动 2.设置后台进程数为0
解决办法：
1.粗暴的办法：
a.在OnCreate中super.onCreate这一行前，使用
savedInstanceState?.getBundle("androidx.lifecycle.BundlableSavedStateRegistry.key")?.remove("android:support:fragments")
b.在@Override
public void onSaveInstanceState(Bundle savedInstanceState)｛
savedInstanceState.setBund("android:support:fragments",null)
｝
c.如果你知道有几个固定的fragment。请在创建的时候使用.replease(id,fragment)
d.判断fragmentManager获取当前fragment是不是空，空不创建
2.正常的做法：
a. 通过FragmentManager - find(tag) 方法查找
b.fragment里拿到 bundle做处理
额外的：
需要关注生命周期：
1.其中Activity的OnDestroy不是总会执行
2.retainInstance 设置为 true 之后，Fragment 的生命周期会有所变化。由于会保存实例，因此重建时不会再调用 onDestroy 销毁，也不会再调用 onCreate 重新实例化。但是 onDetach 和 onAttach 依然会调。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/200e0092c875df97173c0fc0844806d8/" rel="bookmark">
			ChatGPT爆火的背后，到底是什么在跟我们对话？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年11月底美国人工智能研究实验室OpenAI新推出的一种人工智能技术驱动的自然语言处理工具——ChatGPT聊天机器人。一经推出便迅速在社交媒体上走红，成为AI领域最炙手可热的话题，掀起了新一轮的人工智能浪潮。
ChatGPT不单是聊天机器人，它会通过连接大量的语料库来训练模型，这些语料库包含了真实世界中的对话，使得ChatGPT具备上知天文下知地理，还能根据聊天的上下文进行互动的能力，能够响应用户提出的各种自然语言形式的请求，做到与真正人类几乎无异的聊天交流。
ChatGPT像人一样的对话过程是最大的亮点，背后的对话语义技术功不可没。ChatGPT使用了大型语言模型GPT-3.5，其核心技术涵盖了在多轮对话过程中的用户意图理解，以及融合了机器翻译、信息抽取、文案生成、代码生成、邮件撰写等先进的内容生成技术，使其拥有语言理解和文本生成能力。
然而，ChatGPT并非技术的颠覆式创新，但该应用为何如此“出圈”？归根结底，是支撑这套人工智能技术训练语言模型的底层技术正变得越来越成熟。事实上，如果想完成如ChatGPT乃至更高级的人机交互，背后需要对海量数据处理分析及训练。
数十年来数据堂凭借自身优势，针对对话语义方面已设计制作了大量覆盖多领域的多轮对话文本训练数据集，以下为数据堂相关文本数据集：
DATATANG
垂直领域多轮对话文本
203,029组医疗类多轮问答数据
语种：中文
规模：超过20万组，每组包含医生和患者两人之间的多轮对话。
{
“id”: 55034,
“category”: “黑头”,
“content”: [
“patient:女 22岁 黑头多 毛孔粗大 鼻翼两侧泛红 有什么方法可以治疗或者缓解吗？然后再麻烦医生看看我的皮肤还有什么其他的问题”,
“doctor:你好，你的皮肤中间T区应该是比较油的，所以时间长了导致毛孔粗大，清洁以后会有鼻翼发红的现象。建议你使用针对敏感肌的药妆化妆品，如薇诺娜，玉泽等。T区可以适当多做清洁，面颊要少做清洁，洗脸的时候要面颊少按摩。在此基础毛孔粗大以及鼻翼泛红可以采用激光治疗，效果比较好。平常注意清淡饮食，辛辣刺激的少吃，皮肤上其他问题就是有黑眼圈，注意少熬夜，看你眼睛有黑眼圈。散在的小痘痘，有脓头的可以用莫匹罗星软膏涂一下，防止产生色沉。祝好。”,
“patient:感谢您的回答 我想问一下激光治疗和果酸换肤那个比较合适我 这两个都有什么优缺点”,
“doctor:你现在主要适合做激光先解决一下毛孔以及泛红的问题。果酸换肤有一定的角质剥脱作用，做完皮肤会看起来比较嫩一点，但你现在皮肤鼻翼旁有泛红，会敏感一点，所以暂不建议做果酸。”
],
},
电脑端打开可查看更多内容：
https://www.datatang.com/datas‍et/1086
DATATANG
开放领域多轮对话文本
830,276组人人多轮对话文本数据
语种：中文
规模：超过83万组，每组包含两个人之间的多轮对话。
09:30:07 B A 哈，你上班了没？我等着呢，十分钟吧。哈本来还想让你看看我的手机呢，哈
09:31:09 A B 上班了呵 过年的时候看吧 你嫂子明天回去
09:51:04 B A 哦，我知道的。移动硬盘在家吗？
10:18:51 A B 哪一个 新买的在 在我屋北边那个床头柜下边
10:20:42 B A 哦，哈，回去看看
17:01:38 A B 到家了吗
17:03:10 B A 没呢，估计快了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/200e0092c875df97173c0fc0844806d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f91ab12404bb2d42f26a622efcb1b12/" rel="bookmark">
			onbackpress无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 onBackPress() { uni.reLaunch({ url: 路径 }) return true; }, 原因 : uniapp的onBackPress生命周期支持h5、app、支付宝，返回到指定页面可以用。
但是注意 : uniapp的onBackPress生命周期是不支持微信小程序的
onUnload() { wx.reLaunch({ url: 路径 }) }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fef0e63c0502388c96a705ad6ecf5208/" rel="bookmark">
			【论文技巧】Latex、Word、图片里的公式互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Word转LatexLatex转Word图片转Latex图片转Word 首先需要安装一个MathType（下载安装教程网上都有，po解版也有），这里需要注意的是MathML直接粘贴的话免费试用版是无法支持的，如果是30天试用过期了的话打开注册表，找到HKEY_CURRENT_USER\SOFTWARE\Install Options，把Options那一项删掉，然后重启MathType即可。 Word转Latex 在MathType中打开“预置”-》“剪切和复制预置”-》勾选MathML或Tex，勾选“在转换中包括MathType 数据(D)”这一项-》确定，这样直接复制MathType中的公式就可以直接粘贴到Latex中了，不过这样粘需要把前后的\[和\]替换成$$，否则会报错。
Latex转Word 链接：在线Latex公式编辑器
这个网站可以很方便将Latex转成MathML格式（就是Word里的MathType格式），还支持图片直接转Latex代码，不过每天只有两次。
复制MathML后直接粘贴到MathType中就行。
图片转Latex 使用Snip web app可以直接将图片转成Latex格式，缺点是有次数限制，每个月十次，不过可以多注册几个账号（。）
图片转Word 目前我还没找到能一键转换的办法，只能先使用Snip web app将图片转成Latex格式，再使用在线Latex公式编辑器将Latex公式转换为MathType。
转成图片就不说了，截图另存为都行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be2354fae17c34f973d543f22a765761/" rel="bookmark">
			一个事务加了x锁后，其他事务还是可以读取数据的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，写锁仅仅是阻止其他事务施加读锁，而不是禁止事务读取数据。
以隔离级别为读未提交为例。一个事务写数据，不允许其他事务写数据，但允许其他事务读。就是一个事务读取到其他事务未提交的数据（出现脏读问题）。例如事务t2脏读，即读取到事务t1加了写锁的数据修改,但事务t1最后进行了回滚操作，如下图。
但当隔离级别提高到读已提交。一个事务就不能读取到另一个事务加了写锁的数据了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37764b5fdfea7ebc45fba9e20636dd83/" rel="bookmark">
			uniapp使用第三方字体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载第三方字体链接
https://www.100font.com/
1.下载下来将字体引入项目my-font.ttf（自定义命名）
在app.vue
@font-face { font-family: my-font; src: url('~@/static/my-font.ttf'); }
3.使用
.text{ font-family: my-font } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cbe805ac57e5197f940d6bf3da6b1d6/" rel="bookmark">
			性能测试工具locust
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.背景
2.环境
3.正文
4.“坑”
1）没有了HttpLocust
4）发不出去的请求
5）被pytest绊了一下
6）把header给弄丢了
5.参考资料
1.背景 没啥背景，就是测着玩儿，嘿嘿~~
2.环境 python3.7.3locust2.14.2 3.正文 class CasesLogin(TaskSet): def on_start(self): pass @task(1) def test_login(self): header = { "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36", "Content-Type": "application/json;charset=UTF-8" } # POST请求 url = "/api/sys/login" data = { "password": "123456", # 密码需要加密，这里省略 "username": "admin" } with self.client.post(url, json=data, headers=header, verfiy=False, catch_response=True) as resp: # 这里需要捕获响应，否则locust中无数据显示 if resp.status_code == 200: resp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cbe805ac57e5197f940d6bf3da6b1d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b252448367fd1330792cb1b38fa02502/" rel="bookmark">
			MySQL不同版本url写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.MySQL Connector/J 5.x url = jdbc:mysql://localhost:3306/user?useUnicode=true&amp;characterEncoding=utf8；
driver = com.mysql.jdbc.Driver
2.MySQL 8.x新版本，MySQL Connector/J 6.x之后 的连接方式： url=jdbc:mysql://localhost:3306/userserverTimezone=UTC&amp;characterEncoding=utf8&amp;useUnicode=true&amp;useSSL=false
drive = com.mysql.cj.jdbc.Driver
注意：java连数据库不成功出现如com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure错误提示时，在保证user和password正确的情况下，检查url是否是正确，以上供参考。我的出错是通过更改url解决的，改成自己的数据库名字。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a82562a8467c2c5d44955484d1a75437/" rel="bookmark">
			快手在线查询权重网站源码&#43;接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简介：
快手在线查询权重源码次快手权重查询优化了算法，修复很多之前抖音遇到的算法上的bug，不再有随机数，每一项都是根据实际情况固定输出（包括评分，发作品时间等等）
新增用户访问ip，时间统计，上传源码导入源码中的“dkewl.sql”数据库，再修改“config.php”中的数据库用户名、数据库密码、数据库名即可，修改水印请修改第40行，修改查询限制请修改155～168行（删除就是不限制），其他的自行修改，上线网站时js部分最好加密一下，减少接口被盗用的可能性。
新增违禁词检测，自动检测简介中的违禁词并在标红显示如图，后面可能会写自行修改违禁词。
访问域名/user.php即可看到用户访问记录
图片： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66fa0364f72220fa921708f45484079e/" rel="bookmark">
			Java8异步利器：CompletableFuture全网最全使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“Java基基”，选择“设为星标”
做积极的人，而不是积极废人！
每天 14:00 更新文章，每天掉亿点点头发...
源码精品专栏
原创 | Java 2021 超神之路，很肝~
中文详细注释的开源项目
RPC 框架 Dubbo 源码解析
网络应用框架 Netty 源码解析
消息中间件 RocketMQ 源码解析
数据库中间件 Sharding-JDBC 和 MyCAT 源码解析
作业调度中间件 Elastic-Job 源码解析
分布式事务中间件 TCC-Transaction 源码解析
Eureka 和 Hystrix 源码解析
Java 并发源码
来源：blog.csdn.net/zsx_xiaoxin/
article/details/123898171
一、创建异步任务
1. supplyAsync
2. runAsync
3.获取任务结果的方法
二、异步回调处理
1. thenApply和thenApplyAsync
2. thenAccept和thenAcceptAsync
3.thenRun和thenRunAsync
4.whenComplete和whenCompleteAsync
5.handle和handleAsync
三、多任务组合处理
1. thenCombine、thenAcceptBoth 和runAfterBoth
2. allOf / anyOf
CompletableFuture是jdk8的新特性。CompletableFuture实现了CompletionStage接口和Future接口，前者是对后者的一个扩展，增加了异步会点、流式处理、多个Future组合处理的能力，使Java在处理多任务的协同工作时更加顺畅便利。
一、创建异步任务 1. supplyAsync supplyAsync是创建带有返回值的异步任务。它有如下两个方法，一个是使用默认线程池（ForkJoinPool.commonPool()）的方法，一个是带有自定义线程池的重载方法
// 带返回值异步请求，默认线程池 public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) // 带返回值的异步请求，可以自定义线程池 public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor) 测试代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66fa0364f72220fa921708f45484079e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d32912109630b6f863571c1a6f7e75ca/" rel="bookmark">
			[免费专栏] 车联网基础理论之车联网安全车端知识科普
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		也许每个人出生的时候都以为这世界都是为他一个人而存在的，当他发现自己错的时候，他便开始长大
少走了弯路，也就错过了风景，无论如何，感谢经历
转移发布平台通知：将不再在CSDN博客发布新文章，敬请移步知识星球
感谢大家一直以来对我CSDN博客的关注和支持，但是我决定不再在这里发布新文章了。为了给大家提供更好的服务和更深入的交流，我开设了一个知识星球，内部将会提供更深入、更实用的技术文章，这些文章将更有价值，并且能够帮助你更好地解决实际问题。期待你加入我的知识星球，让我们一起成长和进步
基础理论专栏长期更新，本篇最新内容请前往：
[车联网安全自学篇] 车联网基础理论之车联网安全车端知识科普 0x01 前言 随着云计算的发展，不单单针对主机、数据库、网站的漏洞利用攻击愈来愈多，且随着汽车的智能化、网联化、自动化快速发展，汽车的安全问题正面临前所未有的复杂挑战，带来暴露面引致汽车攻击面的增加，不少漏洞遭纰漏，其中包括埋藏在系统、设备中多年未被发现的漏洞，影响面非常广泛。
因此，汽车安全也值得关注。
我们来看看，随着汽车的智能化、网联化、自动化快速发展给汽车安全带来了哪些变化，同学我个人觉得汽车的安全问题正面临前所未有的复杂挑战，其中最大挑战是网联化带来暴露面增加。
那么，要攻击一辆汽车，物理接触已非必经之路。从网络安全角度看，智能网联汽车身处“人车路云”构成的复杂网络中，每一个点、每一个暴露面，包括产生的大量数据都可能成为风险点、“投毒点”。
当汽车进入智能网联时代，数据不仅成为驱动汽车发展的重要价值点，还深度融入社会生活的方方面面，成为重要的基础资源。
这些车具有网络连接功能，通常还具有Wi-Fi热点功能用于和其他设备分享车载网络连接。具有网络连接功能的汽车通常还会扩展出其他功能来充分利用网络连接带来的优势，例如车祸自动报警求救、远程控制、远程升级[Over the Air（OTA）Update]、安全预警等。
我们来看看汽车的攻击知识图谱，如下：
这张图是从攻击者视角车联网安全会关注的点，我们来看看主要的攻击点。比如说车机是很主要的入口，WIFI、蓝牙、USB，然后还有Tbox，负责与云端后台通信，然后再往底层有一个网关，前几年可能还是传统的防火墙，现在可能会变成智能网关这样的概念，下面就是不同的域，基本走的是CAN协议，以及包括周边的一些设施，比如说充电桩、ADAS，V2X等等
1.1 常见的汽车攻击特征 1）物理接触
通过OBD端口向连接的CAN总线发送未授权指令到CAN总线，从而非法控制车辆。
2）近身攻击
利用移动应用的安全漏洞，破解WIFI或者蓝牙，发送未授权指令到CAN总线，从而非法控制车辆。
3）远程控制
通过破解WIFI进入车载娱乐信息系统，再利用车载系统的漏洞进行权限升级，刷写恶意固件，发送未授权指令到CAN总线，从而非法控制车辆。
0x02 网联汽车 联网的车（Connected Car）：又称网联汽车，即这些车具有网络连接功能，通常还具有Wi-Fi热点功能用于和其他设备分享车载网络连接。具有网络连接功能的汽车通常还会扩展出其他功能来充分利用网络连接带来的优势，例如车祸自动报警求救、远程控制、远程升级[Over the Air（OTA）Update]、安全预警等。
0x03 车端基础概念知识 3.1 V2X V2X（Vehicle to X）通信：表示车与X通信，X可以是车（Vehicle）、路（Road）或者其他相关基础设施，相应地也就有了V2V（Vehicle to Vehicle，车与车通信）、V2I（Vehicle to Infrastructure，车与基础设施如道路、服务器等通信）、V2P（Vehicle to Pedestrian，汽车与行人通信）等概念。V2X的典型应用有左转辅助、紧急刹车提示、闯红灯警告、过弯速度警告、施工路段提醒、实时天气信息提醒等。
3.2 高级辅助驾驶系统 高级辅助驾驶系统（ADAS，Advanced Driver Assistance System）：ADAS是在驾驶过程中辅助驾驶员的系统，它的功能包括安全告警功能、自适应控制功能、信息提示功能等，可在通过传感器检测到可能的危险时对驾驶员发出告警或者接管汽车某些控制功能（比如紧急刹车功能），以及根据环境自动对汽车的某些功能进行控制，比如根据环境亮度自动调节车灯亮度、自适应巡航控制、盲点警告、自动变道
3.3 自动驾驶汽车 自动驾驶汽车（Automated Driving Car）：自动驾驶汽车依靠人工智能、视觉计算、雷达、监控装置和全球定位系统的协作，让计算机在没有任何人主动操作的场景下，通过汽车线控（X-By-Wire）系统自动安全地操作机动车辆。
自主驾驶汽车（Autonomous Car）：作者刻意避免使用自动驾驶汽车这个概念，是想将现在的汽车所具备的智能驾驶功能与自动这个概念做些区别，自动可以定义为根据预先设定的程序对环境做出预先设定的反应，而自主驾驶汽车能体现出汽车可以在一定的权限内自主做出一些决定，因为汽车采用了很多人工智能里的学习算法，这些算法模型会在汽车整个生命周期中不断自我学习升级，会越来越“聪明”。
汽车在智能化、联网化、自动化等趋势下必须要考虑到被黑客攻击的可能性，汽车采用或者将要采用的技术如传感器、无线网络连接、云服务器等都可能遭到黑客攻击
3.4 汽车网络安全 为什么汽车网络攻击这个话题近几年这么火？是什么造成汽车受到网络攻击的威胁？面对汽车网络安全威胁我们可以做些什么？
3.4.1 汽车电子及网络系统的发展 纵观汽车一百多年的发展历史，表面上看汽车没有太大的变化，一个内燃机、一个变速器、四个轮子，加上通用的操作接口（一个方向盘、一个刹车踏板、一个油门踏板、一个离合器、一个变速杆等）。但其实在过去这几十年，汽车内部的控制系统发生了巨大变化。今天的汽车已经不再是简单的机械系统，今天的汽车配备了各种各样的电子控制模块（ECU，Electronic Control Unit）及传感器。这些电子控制模块相互协同，通过各种传感器和执行器对车辆的各部件、道路状况、驾驶员和乘客等进行持续的感知和控制。传统汽车上由机械控制的部件越来越依赖于电子系统来辅助控制（即线控，X-By-Wire），前者甚至会被后者取代。
传统的汽车生产厂家其实一直非常重视汽车安全的研究，在汽车的安全方面投入了大量的人力物力进行研发。他们关注的往往是汽车本身的性能安全及操作安全，所以开发了很多功能来保证驾驶安全，如刹车防抱死系统（ABS）、安全气囊、预紧安全带等，这些都是安全功能（Safety Features），但是他们没有对汽车在越来越电子化、网络化的趋势下是否会遭受到同样可以威胁到汽车安全的网络攻击（Cyber Attack）引起足够重视。随着现代汽车集成越来越多的复杂的网络服务和通信功能，汽车所暴露的攻击面也越来越大，例如通过标配的OBD接口可以直接访问汽车内部网络，多媒体系统与汽车控制器内网之间的接口、蓝牙、Wi-Fi、SubGHz、蜂窝网（GPRS、3G、4G）等都提供了潜在的汽车内网入口。从网络的另一端来看，联网后的汽车和我们的PC或手机没有太大区别，将要面对来自世界任何地方的黑客的考验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d32912109630b6f863571c1a6f7e75ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f0d92de9b08fc53600d2ca7b9361be/" rel="bookmark">
			【Dart】extends with implements 以及 on 的区别辨析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，前三个都是在Dart中，用于在定义类时的声明，声明的内容如下：
extends 继承声明，声明在本类中继承的类with 混合声明，声明在本类中混合的类们implements 接口声明，声明本类中重载了哪些接口的属性和方法 而 on 是混合定义时的限定声明，用于限定混合前，需要的提前声明的内容（前导混合），以便可以在本混合中调用这些前导混合。
我们通过下面两个问题对上述内容进行辨析
1.同名方法的调用 如果我们在超类，混合类，以及接口中定义和实现了同名方法，最终在子类中会调用的是谁呢？
通过下面的实验，我们得到了结论，同名方法的调用顺序应该是这样的
本类的&gt;with最后混合的&gt;extends void main() { Apricot().flower(); } class Apricot extends Fruiter with Pair, Peach implements Apple {} class Fruiter { void flower() { print('Fruiter'); } } mixin Peach on Fruiter, Pair { void flower() { print('Peach'); } } mixin Pair { void flower() { print('Pair'); } } class Apple { void flower() { print('apple'); } } 上面的代码执行后 应该输出的是Peach。这样的结论是如何得到的呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74f0d92de9b08fc53600d2ca7b9361be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e841b2e3c4ffe4ba9b6932ea5d2d696c/" rel="bookmark">
			[免费专栏] Android安全之绕过WebView SSL Pinning抓HTTPS数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		也许每个人出生的时候都以为这世界都是为他一个人而存在的，当他发现自己错的时候，他便开始长大
少走了弯路，也就错过了风景，无论如何，感谢经历
转移发布平台通知：将不再在CSDN博客发布新文章，敬请移步知识星球
感谢大家一直以来对我CSDN博客的关注和支持，但是我决定不再在这里发布新文章了。为了给大家提供更好的服务和更深入的交流，我开设了一个知识星球，内部将会提供更深入、更实用的技术文章，这些文章将更有价值，并且能够帮助你更好地解决实际问题。期待你加入我的知识星球，让我们一起成长和进步
Android安全付费专栏长期更新，本篇最新内容请前往：
[车联网安全自学篇] Android安全之绕过WebView SSL Pinning抓HTTPS数据 注：样本APK下载地址，请见文章末尾
0x01 前言 Android 中的证书固定，Android WebView 中证书锁定，在Android 7.0 Nougat (SDK 24)开始才有的，在 Android 7.0 Nougat (SDK 24)之前，无论开发人员使用什么库，都无法真正管理 Webview 上的固定，因为Android 7.0 Nougat (SDK 24)的网络安全配置允许应用程序定义自己的规则集。
为了不让攻击者抓到数据包货执行中间人攻击，开发人员使用了WebView SSLPinning，如果我们想成功地对固定的证书域执行中间人攻击，就必须获得实际证书或能够生成有效证书（来自受信任的证书颁发机构）
1.1 WebView 忽略证书验证 1.1.1 Okhttp3忽略HTTPS证书校验 import java.security.SecureRandom; import java.security.cert.X509Certificate; import javax.net.ssl.HostnameVerifier; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLSession; import javax.net.ssl.SSLSocketFactory; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager; public class SSLSocketClient { public static SSLSocketFactory getSSLSocketFactory() { try { SSLContext sslContext = SSLContext.getInstance("SSL"); sslContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e841b2e3c4ffe4ba9b6932ea5d2d696c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24193600bb742c7b040133415543a0c2/" rel="bookmark">
			[免费专栏] Android安全之绕过SSL Pinning抓HTTPS数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		也许每个人出生的时候都以为这世界都是为他一个人而存在的，当他发现自己错的时候，他便开始长大
少走了弯路，也就错过了风景，无论如何，感谢经历
转移发布平台通知：将不再在CSDN博客发布新文章，敬请移步知识星球
感谢大家一直以来对我CSDN博客的关注和支持，但是我决定不再在这里发布新文章了。为了给大家提供更好的服务和更深入的交流，我开设了一个知识星球，内部将会提供更深入、更实用的技术文章，这些文章将更有价值，并且能够帮助你更好地解决实际问题。期待你加入我的知识星球，让我们一起成长和进步
Android安全付费专栏长期更新，本篇最新内容请前往：
[车联网安全自学篇] Android安全之绕过SSL Pinning抓HTTPS数据 注：样本APK下载地址，请见文章末尾
0x01 前言 随着移动应用的发展和推广，APP应用安全越来越受到重视。在APP中各类防抓包的机制的出现，让测试无法正常进行分析
分析APP时都免不了抓包这一环节，想要抓到包就要看APP用的是什么通信协议。由于HTTP存在不安全性，当前大部分的APP基本采用HTTPS通信协议。许多时候安装 app 时 app 的自带证书就安置到了手机中，且此证书也存在在服务端，另外 app 的代码是开启了 SSL Pinning 的，当我们用 burp 抓包时需要导入手机证书，那劫持 https 的流量就是用 burp 的证书加解密的，而 burp 的证书和 app 的自带证书不一致，所以直接失效，证书的一致性是通过 sha/256 来进行比较的
对抓包工具来说，不论是使用Burp、Fiddler还是Wireshark，这些工具的基本原理都是采用的中间人的方式，工具作为中间人，对客户端伪装成服务端，对服务端伪装成客户端
开始之前，我们先了解一些基础知识，如下介绍
1.1 HTTPS之吻？ http即超文本传输协议，是互联网上应用最为广泛的一种网络协议 ，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。然而他也存在着一些缺点，比如通信使用明文，内容极易被窃听；不验证通信方的身份，因此有可能遭遇伪装；无法证明报文的完整性，所以有可能遭到篡改。因此，http的加强版https应运而生。https中的s是ssl或者tls，就是在原HTTP的基础上加上一层用于数据加密、解密、身份认证的安全层。
数据在会话的初始阶段，客户端第一次发送请求时，通过明文进行发送的，为了防止信息泄露，服务端在返回时则返回一个公钥和证书给客户端。客户端验证证书是否是认证机构颁发，证书是否在有效期内，若没问题则进行下一次请求。在下一次客户端发送请求的时，通过公钥对核心数据进行加密，服务端在接收到数据时，获取对称加密的密钥。此后请求就是通过对称加密的密钥进行加密
已了解HTTP，那什么是HTTPS？ HTTP + 加密 + 认证 + 完整性保护 = HTTPS https需要CA证书，之前文章说的中间人需要对客户端伪装成真正的服务端，要求就是当客户端向我们发送网络请求时，我们必须能够给指定域名签发公钥证书，且公钥证书能够通过系统的安全校验。对于我们是不是真正的客户端，通常来说服务器是不太会关心的，他是不会去关心你是谷歌浏览器还是百度浏览器，当然了也会有例外。接下来要说的双向验证就是如此
1.2 单向验证与双向验证 首先，了解一下什么是https的单双向验证，主要说一下双向验证，双向验证相比较单向验证，增加了服务端对客户端的认证
双向认证详细过程如下：
客户端发起HTTPS请求，将SSL协议版本的信息发送给服务端。服务端去CA机构申请来一份CA证书，在前面提过，证书里面有服务端公钥和签名。将CA证书发送给客户端客户端读取CA证书的明文信息，采用相同的hash散列函数计算得到信息摘要（hash目的：验证防止内容被修改），然后用操作系统带的CA的公钥去解密签名（因为签名是用CA的私钥加密的），对比证书中的信息摘要。如果一致，则证明证书是可信的，然后取出了服务端公钥客户端发送自己的客户端证书给服务端，证书里面有客户端的公钥：C_公钥客户端发送支持的对称加密方案给服务端，让其选择服务端选择完加密方案后，用刚才得到的C_公钥去加密选好的加密方案客户端用自己的C_私钥去解密选好的加密方案，客户端生成一个随机数（密钥F），用刚才等到的服务端B_公钥去加密这个随机数形成密文，发送给服务端。服务端和客户端在后续通讯过程中就使用这个密钥F进行通信了。和之前的非对称加密不同，这里开始就是一种对称加密的方式 1.3 SSL Pinning SSL Pinning是一种防止中间人攻击（MITM）的技术，主要机制是在客户端发起请求–&gt;收到服务器发来的证书进行校验，如果收到的证书不被客户端信任，就直接断开连接不继续求情。
可以发现中间人攻击的要点的伪造了一个假的服务端证书给了客户端，客户端误以为真。所以在遇到对关键请求开启SSL Pinning的APP时，我们抓包就只能看到APP上提示无法连接网络或者请求失败之类的提示；而在抓包工具上面，要么就只能看到一排 CONNECT 请求，获取到证书却没有后续了，要么就是一些无关的请求，找不到想要的接口。解决思路就是，客户端也预置一份服务端的证书，对比客户端与服务端的证书就知道谁真谁假。
介绍一下证书相关的概念，以及证书校验的相关知识：
可信CA： CA(Certificate Authority)是数字证书认证中心的简称，是指发放、管理、废除数字证书的机构。CA的作用是检查证书持有者身份的合法性，并签发证书，以防证书被伪造或篡改，以及对证书和密钥进行管理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24193600bb742c7b040133415543a0c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67095e992cc19f66ddf9aa91e0bce644/" rel="bookmark">
			[免费专栏] Android安全之Android Xposed插件开发，小白都能看得懂的教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		也许每个人出生的时候都以为这世界都是为他一个人而存在的，当他发现自己错的时候，他便开始长大
少走了弯路，也就错过了风景，无论如何，感谢经历
转移发布平台通知：将不再在CSDN博客发布新文章，敬请移步知识星球
感谢大家一直以来对我CSDN博客的关注和支持，但是我决定不再在这里发布新文章了。为了给大家提供更好的服务和更深入的交流，我开设了一个知识星球，内部将会提供更深入、更实用的技术文章，这些文章将更有价值，并且能够帮助你更好地解决实际问题。期待你加入我的知识星球，让我们一起成长和进步
Android安全付费专栏长期更新，本篇最新内容请前往：
[车联网安全自学篇] Android安全之Android Xposed插件开发，小白都能看得懂的教程 0x01 前言 1.1 安卓操作系统架构 Android是一种基于Linux的自由及开放源代码的操作系统。而Android系统构架是安卓系统的体系结构，其系统架构和其操作系统一样，采用了分层的架构，共分为四层五部分，四层指的是从高到低分别是Android应用层，Android应用框架层，Android系统运行层和Linux内核层；五部分指的是Linux Kernel、Android Runtime、Libraries、Application Framework、Applications。
1.1.1 Linux Kernel 在所有层的最底下是 Linux，它提供了基本的系统功能，比如进程管理，内存管理，设备管理（如摄像头，键盘，显示器）。
1.1.2 Android Runtime Android 运行时同时提供一系列核心的库来为 Android 应用程序开发者使用标准的 Java 语言来编写 Android 应用程序。Dalvik 虚拟机使得每一个 Android 应用程序运行在自己独立的虚拟机进程。Dalvik虚拟机可执行文件格式是.dex，dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。
1.1.3 Libraries Android包含一个C/C++库的集合，供Android系统的各个组件使用。这些功能通过Android的应用程序框架（application framework）暴露给开发者。
1.1.4 Application Framework 通过提供开放的开发平台，Android使开发者能够编制极其丰富和新颖的应用程序。
1.1.5 Applications 应用框架层以 Java 类的形式为应用程序提供许多高级的服务。
1.2 安卓应用程序组件 应用程序组件是一个Android应用程序的基本构建块。在AndroidManifest.xml中描述了应用程序的每个组件，以及他们如何交互。
1.2.1 Android应用程序中四个主要组件 组件名描述Activities描述UI，并且处理用户与机器屏幕的交互Services处理与应用程序关联的后台操作Broadcast Receivers处理Android操作系统和应用程序之间的通信Content Providers处理数据和数据库管理方面的问题 1.2.2 附加组件 组件名描述Fragments代表活动中的一个行为或者一部分用户界面Views绘制在屏幕上的UI元素，包括按钮，列表等Layouts控制屏幕格式，展示视图外观的View的继承Intents组件间的消息连线Resources外部元素，例如字符串资源、常量资源及图片资源等Manifest应用程序的配置文件 1.3 什么是 Hook？ Hook 又叫“钩子”，它可以在事件传送的过程中截获并监控事件的传输，将自身的代码与系统方法进行融入
这样当这些方法被调用时，也就可以执行我们自己的代码，这也是面向切面编程的思想（AOP）
1.4 Hook 分类 1）根据Android开发模式，Native模式（C/C++）和Java模式（Java）区分，在Android平台上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67095e992cc19f66ddf9aa91e0bce644/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f71f97869e3a17062eb970881ddb1c9b/" rel="bookmark">
			最新Snort3和Snort2安装详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		也许每个人出生的时候都以为这世界都是为他一个人而存在的，当他发现自己错的时候，他便开始长大
少走了弯路，也就错过了风景，无论如何，感谢经历
转移发布平台通知：将不再在CSDN博客发布新文章，敬请移步知识星球
感谢大家一直以来对我CSDN博客的关注和支持，但是我决定不再在这里发布新文章了。为了给大家提供更好的服务和更深入的交流，我开设了一个知识星球，内部将会提供更深入、更实用的技术文章，这些文章将更有价值，并且能够帮助你更好地解决实际问题。期待你加入我的知识星球，让我们一起成长和进步
网上看到了许多Snort3的安装以及Snort2的安装教程，尤其是Snort3的安装，博主严重怀疑他们有没有真的安装成功... ...，让人真的想扣jio，Snort3按照其它博主给的搭一直出问题，不是搭不上就是报错要么就是写的很乱，没看的欲望。而且Snort3和Snort2的安装区别很大，博主只尝试了Snort3的完整安装，并记录了下来，Snort2的网上很详细，也顺路整理了一下，有需要的自取 0x01 Snort2安装教程 安装Snort2 需要的依赖 apt-get install gcc	: 编译器,如果报错,apt-get install g++ apt-get install flex	: DAQ所需的解析器 apt-get install bison	: DAQ所需的解析器 apt-get install zlib1g-dev	: Snort所需的压缩库 apt-get install libpcap-dev : Snort所需的网络流量捕获头文件库 apt-get install libdnet-dev	: 不是必要的,只是snort为几个网络历程提供了简化的可移植接口 apt-get install luajit : lua的头文件库headers apt-get install liblua5.1-0-dev apt-get install liblua5.1-0-dev liblua50-dev liblualib50-dev apt-get install build-essential	: 提供编译软件的构建工具 apt-get install libpcre3-dev	: Snort所需的pcre3的头文件 apt-get install libdumbnet-dev	: 同libdnet apt-get install openssl libssl-dev	: ssl的加密组件,提供SHA和MD5文件签名 apt-cache search lua sudo apt-get update -y sudo apt-get upgrade -y sudo apt-get install gcc -y sudo apt-get install flex -y sudo apt-get install bison -y sudo apt-get install zlib1g-dev -y sudo apt-get install libpcap-dev -y sudo apt-get install libdnet-dev -y sudo apt-get install luajit -y sudo apt-get install liblua5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f71f97869e3a17062eb970881ddb1c9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8ed4030b408ab42582954a33f6dc3be/" rel="bookmark">
			Windows下手把手教Snort的安装与配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		也许每个人出生的时候都以为这世界都是为他一个人而存在的，当他发现自己错的时候，他便开始长大
少走了弯路，也就错过了风景，无论如何，感谢经历
转移发布平台通知：将不再在CSDN博客发布新文章，敬请移步知识星球
感谢大家一直以来对我CSDN博客的关注和支持，但是我决定不再在这里发布新文章了。为了给大家提供更好的服务和更深入的交流，我开设了一个知识星球，内部将会提供更深入、更实用的技术文章，这些文章将更有价值，并且能够帮助你更好地解决实际问题。期待你加入我的知识星球，让我们一起成长和进步
Windows下手把手教Snort的安装与配置 0x01 Snort 规则集类别 app-detect.rules – 此类别包含查找和控制生成网络活动的某些应用程序的流量的规则。此类别将用于控制应用程序行为方式的各个方面blacklist.rules – 此类别包含已确定为恶意活动指标的 URI、USER-AGENT、DNS 和 IP 地址规则。这些规则基于来自 Talos 病毒沙箱的活动、恶意 URL 的公共列表和其他数据源browser-chrome.rules – 此类别包含对 Chrome 浏览器中存在的漏洞的检测。（这与“ browser-webkit ”类别是分开的，因为 Chrome 有足够的漏洞可以分解成它自己的，虽然它使用 Webkit 渲染引擎，但 Chrome 还有很多其他功能）browser-firefox.rules – 此类别包含对 Firefox 浏览器或具有“Gecko”引擎的产品中存在的漏洞的检测（雷鸟电子邮件客户端等）browser-ie.rules - 此类别包含对 Internet Explorer 浏览器（Trident 或 Tasman 引擎）中存在的漏洞的检测browser-webkit – 此类别包含对 Webkit 浏览器引擎（Chrome 除外）中存在的漏洞的检测，包括 Apple 的 Safari、RIM 的移动浏览器、诺基亚、KDE、Webkit 本身和 Palmbrowser-other – 此类别包含对上面未列出的其他浏览器中的漏洞的检测browser-plugins – 此类别包含对浏览器中处理浏览器插件的漏洞的检测（例如：Active-x）content-replace – 此类别包含任何利用 Snort 内部“替换”功能的规则deleted – 当规则已被弃用或替换时，它会移至此类别。规则永远不会从规则集中完全删除，它们被移到这里exploit -这是一个较旧的类别，很快就会被弃用。此类别以通用形式查找针对软件的漏洞利用exploit-kit – 此类别包含专门用于检测漏洞利用工具包活动的规则。这不包括“妥协后”规则（因为那些将在indicator-comromise中）。由于访问漏洞利用工具包而丢弃的文件将位于其各自的文件类别中file-executable – 此类别包含针对通过可执行文件发现或传递的漏洞的规则，无论平台如何file-flash - 此类别包含针对通过闪存文件发现或传递的漏洞的规则。无论是被攻击的交付方式平台，压缩或未压缩file-image - 此类别包含在图像文件中发现的漏洞的规则。无论交付方法、被攻击的软件或图像类型如何。（示例包括：jpg、png、gif、bmp 等）file-identify - 此类别是通过文件扩展名、文件中的内容（文件魔术）或流量中找到的标头来识别文件。此信息通常用于然后设置要在不同规则中使用的流位file-java - 此类别包含 Java 文件 (.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8ed4030b408ab42582954a33f6dc3be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1662aca5c67aa245525e59528a5ad1c0/" rel="bookmark">
			「干货」Web安全红队外围信息收集「详细总结」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
也许每个人出生的时候都以为这世界都是为他一个人而存在的，当他发现自己错的时候，他便开始长大
少走了弯路，也就错过了风景，无论如何，感谢经历
转移发布平台通知：将不再在CSDN博客发布新文章，敬请移步知识星球
感谢大家一直以来对我CSDN博客的关注和支持，但是我决定不再在这里发布新文章了。为了给大家提供更好的服务和更深入的交流，我开设了一个知识星球，内部将会提供更深入、更实用的技术文章，这些文章将更有价值，并且能够帮助你更好地解决实际问题。期待你加入我的知识星球，让我们一起成长和进步
外围打点前言
由于红队不同于一般的渗透测试，强调更多的是如何搞进去拿到相应机器权限或者实现某特定目的，而不局限于你一定要在什么时间，用什么技术或者必须通过什么途径去搞，相比传统渗透测试，红队则更趋于真实的入侵活动，这种场景其实对防御者的实战对抗经验和技术深度都是比较大的挑战
信息收集方式一般采取以下几种方式在搜索引擎（如：baidu、google）进行搜索：
主站相关联的链接，主站链接下可能会放置跳转，如邮件、OA等相关系统。
主站子域名进行搜索，通过二级或三级域名进行目标搜索相关域名。
主目标相关title，主要为搜索一些没有设置域名只有相关IP的系统。
主目标相关body，这种搜索方式误报率比较高，通过一些条件可筛选出相关联系统。
C段探测，一般前几种搜索方式获取相关IP，然后探测可能存在的C段，可获取一些没有相关联信息的隐藏资产。
端口探测，扫描是否存在其他的web服务，或可利用的、可爆破的、未授权的端口等。
邮件账号收集，一般为发布在公网上招聘、联系方式等，然后可进行弱密码破解。
首先，选择主要进攻目标原则：
资产范围比较庞大。因为资产范围广，容易出现不被关注的系统，安全性可能存在疏忽，比较容易进行突破；
受关注比较低的。由于受到关注度高的系统，如果受到攻击，影响会比较大，安全性会比一般的高。所以需要选择受关注比较低的系统做为突破口；
没有与资金直接关系的系统。涉及资金交易的系统，安全性受到重视度最高，突破难度大，所以不选择；
安全管理不够完善的单位。安全管理不够完善的单位做为突破口，容易发现弱口令或密码相同，人员安全意识不高，容易利用钓鱼手段做为突破口；
一般红队攻击分为三个阶段：
第一阶段
定位好主要攻击目标后，一起寻找主要突破口，当成功撕开一个突破口后进入第二阶段；
第二阶段
由于刚撕开突破口，不宜动作太大，所以由主要攻击手进行内网探测信息收集，以及留后门工作，寻找其他跳板机；另外两人进行次要目标的寻求突破，当主攻手成功获取其他跳板机后，或者次要目标找到突破口进入第三阶段；
第三阶段
全力挖掘内网，尽量得分，寻求拿下任务目标系统。
攻击手段 主要是通过以下途径开展渗透攻击：一是通过SQL注入、文件上传漏洞等攻击方式，对目标系统开展攻击，获取系统权限；二是利用后台、用户弱口令漏洞，获取网络及信息系统关键信息；三是利用系统已知漏洞，直接获得系统服务器权限。
当攻陷的服务器处于内网之中，将进一步深入进行内网漫游。
由于不同目标防守方一般经过行业划分，所以防守实力强弱差距比较大。
防守方最强的为金融行业，毕竟与金钱有着直接关系的，受到关注度也是最高，安全投入最高，就算突破也很难获取大量得分，所以大多数攻方都不以金融行业为主要攻击目标。
其次防守比较强的行业为重要企业，由于企业对外网络服务的业务少，受众面不如政府、金融行业，再加上企业对安全管理比较重视，所以企业属于易守难攻类型。
防守比较薄弱的几个行业如下：
运输交通、政府公众服务类、能源矿产类、电力等这几类系统的特点：
资产庞大，业务系统驳杂、全国各地都有甚至到县城，容易被找到突破口。
没有统一的安全管理，由于庞大系统需要多个管理员一起维护，一旦有重大漏洞爆出往往会出现响应不及时的现象。例如：在互联网上传播最新漏洞信息，防守比较强的行业能在第一时间内修复漏洞或者找到临时应对的方法。而防守薄弱的可能，没有获取相关信息，或者在了解信息后，没有比较好的解决方法选择极端的防守方式关闭站点。
安全边界防护不严格，由于系统庞大系统需要布满全国各地，地方可能也会开放自己的业务系统，一旦一个地方被入侵成功，就可连通全国各地的内网，以点破面全部沦陷的风险。
排查攻击能力较弱。
例如：在内网中发现攻击或木马后门，防守强的行业能在发现后门后，分析出攻击的入侵点，并能锁定哪些资产可能被入侵进行彻底排查。而防守比较弱的队伍可能无法发现后门，或者无法彻底清除后门，导致在管理以为彻底修复问题后，内网仍然被入侵。
说太多没有用的东西了，正式进入本次话题... ...
0x01 信息收集踩点 Googe Hacke 搜索如需更多搜索引擎语法前往 以下是利用GHDB结合搜索引擎高级指令进行敏感信息获取的对应表： a b c自动对词进行拆分匹配 拆分标准 空格“a b c “把a b c 当成一个整体去查” a*b”*通配符 里面是一个或者多个 以a开头 b结尾“ab” -c找到ab 不包含ca and b包含a和b“ab”(c|d)ab中可能包含c或者dintitle: xx找标题intext: xx找内容info: xx搜索到关于一个URL的更多信息的页面列表，这里的信息包括这个网页的cache，还有与这个网页相似的网页等等inurl: *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1662aca5c67aa245525e59528a5ad1c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f88bec7f692a56c255b8b97ae9917499/" rel="bookmark">
			Mybatis批量更新优化方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言需求原方案优化方案一优化方案二总结 前言 今天在对接客户接口的时候，对方同步数据到我们系统，涉及到数据批量更新，插入的逻辑，出于性能方面的考虑，决定对自己写的逻辑进行优化，下面对几种优化方案进行总结。
需求 同步部门数据到mysql数据库，响应示例：
拿到json后，如果数据库不存在部门数据，则进行插入操作；存在部门数据，则做修改操作。这里演示存在数据进行修改操作。
原方案 使用mybatis-plus的saveOrUpdateBatch接口
修改部分代码逻辑：
启动项目进行测试：
经测试，接收的数据30条左右，耗时 1082ms ，显然达不到预期的性能要求，于是针对此进行优化。
优化方案一 在mybatis的xml文件中，使用foreach标签来拼接SQL语句。
代码示例：
&lt;update id="updateBatchById"&gt; &lt;foreach collection="list" item="item" separator=";"&gt; update `sys_dept` set `DEPT_NAME` = #{item.deptName}, `DEPT_CODE` = #{item.deptCode}, `PARENT_ID` = #{item.parentId} where dept_id = #{item.deptId} &lt;/foreach&gt; &lt;/update&gt; mapper层：
/** * 批量更新 * @param list */ void updateBatchById(@Param("list") List&lt;SysDept&gt; list); 然后在修改数据的逻辑中，直接调用mapper的接口
重启项目，再次测试：
可以看到，同样的数据，这个方案耗时273ms
优化方案二 foreach标签配合case when拼接SQL语句。
代码示例：
&lt;update id="batchUpdate" parameterType="java.util.List"&gt; update sys_dept &lt;trim prefix="set" suffixOverrides=","&gt; &lt;trim prefix="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f88bec7f692a56c255b8b97ae9917499/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f86c7af4a478ab32eb0272a2f163d1b3/" rel="bookmark">
			从零开始学Java之方法重写与方法重载到底有哪些区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 方法重写 在面向对象中，实现多态的必备条件是继承、重写和向上转型，现在我们已经学习了什么是继承。接下来我们再来学习什么是方法重写，这是我们能够实现多态的前提。
1. 概念 如果我们在子类中，创建了一个与父类中名称、返回值类型、参数列表都完全相同的方法，只是方法体的功能实现不同，这种方式被称为方法重写(override) ，或者叫方法覆盖。当父类中的方法无法满足子类的需求，或者子类需要有特殊功能时，就可以进行方法重写。
2. 基本要求 我们在进行方法重写时，需要遵循以下几点要求：
父类的成员方法只能被它的子类重写，即不能继承一个方法，就不能重写这个方法；被final修饰的方法不能被重写；被static修饰的方法不能被重写，但可以再次声明；构造方法不能被重写；子类和父类在同一个包中时，子类可以重写父类中除了被private和final修饰的其他所有方法；子类和父类不在同一个包中时，子类只能重写父类被public和protected修饰的非final方法；重写的方法建议使用@Override注解来标识。 3. 注意事项 另外我们在进行方法重写时，还要注意以下几点：
方法签名要相同：重写的方法和被重写的方法，在方法名、参数上都要相同；返回值类型一致：JDK 1.5之前重写方法的返回值类型必须一样，但之后的Java版本放宽了限制，返回值类型必须小于或等于父类方法的返回值类型；访问修饰符要更宽泛：子类重写父类的方法时，子类方法中的访问修饰符不能比父类中的更严格(public&gt;protected&gt;default&gt;private)。比如父类方法的修饰符是protected，则子类的同名方法其修饰符可以是protected或public，但不能是默认的或private；声明的异常类型要一致：重写的方法一定不能抛出新的检査异常，或者比被重写方法声明更宽泛的检査型异常。例如，父类的方法声明了IOException，重写该方法时就不能抛出Exception，只能拋出IOException或其子类异常。但可以抛出非检査异常。 4. 代码实现 接下来壹哥就通过一个案例来给大家讲解方法的重写该怎么实现。
4.1 定义父类 我们先定义一个Father父类，要注意父类中有哪些方法不能被重写。
public class Father { // 父类中的成员变量--变量隐藏 String name="老子"; //构造方法不能被重写，因为构造方法不能被继承！ public Father() { System.out.println("爹的构造方法"); } // 吃 public void eat() { System.out.println("爹吃馒头"); } // 喝 public void drink() { System.out.println("爹喝水"); } // 玩 //私有方法不能被重写 //	private void play() { // System.out.println("爹玩火"); //	} //静态方法不能被重写，但可以在子类中声明一个同样的静态方法。 //	public static void play() { // System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f86c7af4a478ab32eb0272a2f163d1b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16df5b98d4459462386a106f37f22ca9/" rel="bookmark">
			【ESP8266 快速入门】硬件：ESP12S/ESP12F最小系统设计及typeC自动下载电路设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【ESP8266】ESP12S/12F 最小系统设计及typeC自动下载电路设计 0.引言 ESP8266面向物联网应用的，高性价比、高度集成的 Wi-Fi MCU。
芯片ESP8266EX采用的QFN无引脚封装，且需要搭配FLASH使用，以及设计天线；使用起来比较麻烦。
我希望使用起来更加方便，便想到了使用ESP12S/12F这种集成模组（集成FLASH、天线）。
我只需设计一个最小系统及typeC自动下载电路设计，就可以愉快的用到自己的项目中了。
解决两个问题：
1.设计最小系统
2.type C自动下载电路
本文目录 【ESP8266】ESP12S/12F 最小系统设计及typeC自动下载电路设计0.引言1.ESP8266 介绍2.ESP12S设计的关键信息2.1.ESP12S原理图2.2.封装尺寸2.3.ESP12S符号及管脚定义、PCB封装2.3.1.ESP12S符号2.3.2.ESP12S管脚功能说明2.3.3.模组启动模式的管脚电平要求2.3.4.PCB封装 3.最小系统电路设计3.1.原理图3.2.最小系统解释 4.type C自动下载电路设计4.1.自动下载电路原理图4.2.自动下载电路解析4.2.1 Type C接口4.2.1.1 Type C管脚定义4.2.1.2 Type C 选型4.2.1.3. Type C 16Pin接线总结4.2.1.4.16Pin typeC接线图 4.2.2.CH340芯片4.2.2.1 CH340介绍4.2.2.2.CH340引脚定义4.2.1.3.CH340C接线图 4.2.3.自动下载实现4.2.3.1.自动下载时序4.2.3.2.自动下载关键电路 5.打样及实验验证 1.ESP8266 介绍 ESP8266EX 乐鑫官网的简介图
ESP12S模组
ESP12S和ESP12F模组，主要是封装不同，其他没什么大的区别。
ESP-12S 是由安信可公司开发的 Wi-Fi 模块，基于ESP8266EX高性能无线 SoC。该模块在较小尺寸封装中囊括了晶振、FLASH、天线等元件。支持80MHz和160MHz主频，完整的 TCP/IP 协议栈。该模块既可以嵌入到现有设备添加联网功能，也可以构建独立的网络控制器。
特性介绍如下。
主要参数说明
2.ESP12S设计的关键信息 ESP12S采用SMD16封装，我们要设计的自己电路，需要了解一下模组的原理图、管教定义、封装尺寸等等。
2.1.ESP12S原理图 截取自 规格书。
2.2.封装尺寸 实物图，以及尺寸说明。
2.3.ESP12S符号及管脚定义、PCB封装 2.3.1.ESP12S符号 2.3.2.ESP12S管脚功能说明 管脚功能说明表：
脚序名称功能说明1RST复位引脚，低电平有效2ADCA/D 转换结果。输入电压范围 0～1V，取值范围：0～10243EN芯片使能端，高电平有效4IO16GPIO16，与 RST 管脚相连时可做 deep sleep 的唤醒5IO14GPIO14/HSPI_CLK/IR_T/IC_SCL/I2SI_WS6IO12GPIO12/HSPI_MISO7IO13GPIO13/HSPI_MOSI/UART0_CTS8VCC3.3V VDD；外部供电电源输出电流建议在 500mA 以上9GND接地10IO15GPIO15/I2SO_BCK/HSPICS/UART0_RTS11IO2GPIO2/UART1_TXD/I2C_SDAˈI2SO_WS12IO0GPIO0下载模式:外部拉低，运行模式:悬空或者外部拉高13IO4GPIO414RXDUART0_RXD/GPIO3/I2SO_DATA15IO5GPIO5/IR_R16TXDUART0_TXD/GPIO1 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16df5b98d4459462386a106f37f22ca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80e3fd7f7d01752c4c6e097595a0e13/" rel="bookmark">
			MyBatis笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
常见bug：
常见注意事项：
1.关于日志
2.编写一个获取SqlSession对象的工具类
3.CRUD
3.1 MyBatis中完成Map集合传参完成insert
3.2 MyBatis中通过POJO类完成传参
3.3 实现Delete删除
3.4 实现update修改
3.5实现查询
查询所有数据表所有数据
3.6 Mapper映射文件的namespace
四.Mybatis核心配置文件详解
4.1、mybatis-config.xml
手写mybatis框架：
javassist的使用
使用动态代理完成CRUD
Mybatis小技巧
1.#{}和${}的区别
2.什么时候需要使用${}
3.小技巧之别名机制
4.小技巧之sql映射文件在mybatis-config.xml配置路径
5.小技巧之在idea配置mybatis核心文档和Sql映射文档
6.小技巧之插入数据时返回自增主键
Mybatis的参数处理(mybatis核心)
单个简单参数类型
参数为Map
单个参数总结
多参数
多参数之注解Param
再一次理解动态代理
查询专列
模糊查询
返回Map集合
返回List
返回Map&lt; String , Map&lt; String,Object &gt; &gt;大Map集
查询之结果映射(重要)
查询所有记录条数
动态SQL
if标签
where标签
trim标签
set标签
choose when otherwise
foreach标签
批量删除
批量插入
sql与include标签
高级映射
高级映射多对一
方案一：一条SQL语句，级联属性映射
方案二：一条sql语句，association
方案三：两条SQL语句，分步查询。（这种方式常用：优点一是可复用。优点二是支持懒加载。
高级映射之一对多
十四、MyBatis的缓存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b80e3fd7f7d01752c4c6e097595a0e13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe5e70ed73c8b459c2976675a234377/" rel="bookmark">
			MySQL2——基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要介绍MySQL的实际操作。
一：操作数据库的SQL 1.从cmd进入mysql
mysql -uroot -p密码 2.创建数据库
create database 数据库名;
注意：一定要以分号结尾！这里的create，database都是数据库中的关键字。
3.查看数据库
show databases;
注意：databases一定要使用复数形式；
4.选中数据库
use 数据库名;
5.删除数据库
drop database 数据库名;
注意：删除数据库非常危险！！！！！！！！程序猿和代码，有一个能跑就行。尤其是在公司的生产环境下，千万不要轻易尝试！风险极高！
如果不小心把开发环境/测试环境中的数据库删除，影响有限；但如果把生产环境中的数据库删掉，那就废了，很可能导致用户投诉，用户流失，甚至造成更加直接的经济损失，严重的还会吃到官司，很“刑”，日子越来越有“判头”了。
既然删除数据库危害如此之大，有什么方法可以降低这种风险呢？
权限：只授予少数人修改数据库的权限；由此衍生出一个岗位，叫数据库管理员（DBA）；备份：把数据拷贝一份，存到别的地方去；硬盘数据恢复：如果是极端情况，删了库，也没有备份，还有一招，就是硬盘数据恢复。 关于硬盘数据恢复：
操作系统为了方便进行管理,把整个硬盘分成了若干个"盘块" . 每个盘块都可以保存一定的数据 . 每个文件,实际上可能是由一个或者多个盘块上面的数据来构成的 .
当操作系统删除文件的时候,为了提高删除动作的效率,在删除的时候并不是真的把硬盘上之前保存的数据擦除掉,而只是把该文件对应的盘块,标记成"无效状态" ---- &gt; "逻辑删除" . 因此一旦出现误删库的情况,就要尽快让主机断电 !! 就避免操作系统把这些被标记成无效的盘块给分配出去!!!
这就好像我收拾房间,收拾了一些垃圾.把这些垃圾直接一股脑丢到楼下垃圾桶里. 万一过了一会，啊，,我的身份证好像在里面呢!!!赶紧去楼下，翻垃圾桶,大概率还是能翻回来的!!
注意!!!上述的操作,不一定能100%都恢复回来,大概率是只能恢复一部分!!
二：SQL数据类型 2.1数值类型 需要记忆的数据：整数类型的范围 :
2.2字符串类型 示例：
VARCHAR(50)，表示这个字段最多存50个字符，一个字节固定8bit，而一个字符长度则取决于具体的字符编码~~
java中默认使用的是unicode编码。 2.3日期类型 三：操作表的SQL 1.创建表
create table 表名(列名 类型,列名 类型......);
注意：
同一个数据库中，不能有两个表名字相同；创建表时，表名和列名，不能和数据库的关键字冲突；如果你就是要用，那必须用反引号把表名引起来，反引号（`）就是键盘左上角的那个键；有时候，建表语句比较复杂，可以分成多行来写；由于在mysql命令行直接编写，无法退回到上一步，所以很不方便，可以使用其他编辑器进行书写，并粘贴到命令行的黑框框里面。 2.显示有哪些表
show tables;
3.查看表结构
desc 表名;
desc—&gt;describe,查看表结构，就是描述一下这个表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fe5e70ed73c8b459c2976675a234377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82008a1dfd57e3d996c364b518afd95c/" rel="bookmark">
			Python-opencv：将文件夹中的图片序列按顺序转化为视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python-opencv:图片集转化为视频 有时需要将图片集转化为视频进行后处理或者进行效果演示，所以在这里总结了一版的代码供后续使用。
代码 注：代码主要解决了，视频帧没有按照顺序转化的问题
import cv2 import os def pic_to_vid(P, V, F): path = P video_dir = V fps = F in_img = os.listdir(path) # get_key是sotred函数用来比较的元素，该处用lambda表达式替代函数。 img_key = lambda i: int(i.split('.')[0]) img_sorted = sorted(in_img, key=img_key) # 需要转为视频的图片的尺寸，这里必须和图片尺寸一致 # w,h of image img = cv2.imread(os.path.join(path, img_sorted[0])) img_size = (img.shape[1], img.shape[0]) # 获取名称 seq_name = os.path.dirname(path).split('/')[-1] video_dir = os.path.join(video_dir, seq_name + '.avi') #print(img_size) video = cv2.VideoWriter(video_dir, cv2.VideoWriter_fourcc('M', 'J', 'P', 'G'), fps, img_size) for item in img_sorted: img = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82008a1dfd57e3d996c364b518afd95c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae8cf90105b424419f57e74e0043cc6e/" rel="bookmark">
			Windows &#43; Ubuntu 双系统（超详细图文教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传统的MBR模式和新式UEFI模式，这将对安装双系统的方法产生直接影响。
本文只适用于，Legacy模式（MBR，boot）;
UEFI模式（GPT）
参考:https://blog.csdn.net/m0_51233386/article/details/120918319
Windows + Ubuntu 16.04双系统（超详细图文教程） 一、准备工作：二、安装Ubuntu三、双系统启动问题: 一、准备工作： （一）、准备工具：
➢U盘一个（请提前备份U盘里面的资料，因为后面操作要格式化U盘）
➢Ubuntu16.04LTS（长期支持版）镜像：
下载地址：http://www.ubuntu.com/download/desktop
(Ubuntu中国下载地址：http://cn.ubuntu.com/download/)
云盘下载地址：百度云盘：链接: https://pan.baidu.com/s/1gj_HFK4MQIhOp4PUCvfllA 提取码: id6f
➢启动U盘制作软件：
下载地址：链接: https://pan.baidu.com/s/1HAjlnHLkB6H3IdQ54t2mFw 提取码: 3ywa
（Ubuntu官网提供的页面：http://www.ubuntu.com/download/desktop/create-a-usb-stick-on-windows）
➢EasyBCD: 链接: https://pan.baidu.com/s/1slPiDZ3 密码: z3r7
（二）、分区—分出来一个磁盘，用于安装Ubuntu
我在下面已经把链接内容搬了过来，只是写了我们用得着的部分，还有一点请注意：这个“百度经验”中分的是“C盘”，你在分区时请根据你的磁盘大小进行分区，而且不建议分“C盘”，建议分非系统盘，如果你不知道该分多大的空间，请先看一下后面，我写的Ubuntu安装时的分区设置部分。）
（1） 进行分区之前，我们必须进入系统的磁盘管理。进入磁盘管理发方式有两种。一种是通过电脑属性，进入磁盘管理。
第二种是直接右键点击windows键（windows+X）选择磁盘管理。
（2）进入磁盘管理之后，我们可以看到我的分区情况。然后选择你需要进行分区的磁盘，点击右键，选择“压缩卷”，如图示。
（3）然后系统会自动的查询压缩空间，如图示：
（4）然后我们选择选择好需要压缩空间的大小。点击压缩：
（5）等一会，空间就压缩好了。如图示会出现一个可用的空间。这就是我们刚才压缩出来的空间：
（6）说明：磁盘分区做到这里就行了，不用再往下进行，原“经验”还有后面的“新建分区”部分，在这里我们是用不到的，所以做到上面的步骤就行了。
（三）、制作启动U盘：
Ubuntu 16.04版本下载地址
制作Ubuntu16.04系统安装的U盘教程
二、安装Ubuntu (1) ------ 从U盘启动: 将U盘插在电脑上，选择启动方式为U盘启动。(如果你的电脑有两个USB…选项可供选择，可能一个带有“USB…UEFI”,另一个没有“UEFI”，请选择没有“UEFI”的，选带有“UEFI”的可能会出现问题，我有一个同学就是的，或者可以都试一下)（关于如何从U盘启动，快速U盘启动什么的，还请根据自己的电脑型号自行百度），下面是我的选择U盘启动的截图：
windows系统安装，必有此步骤，但ubuntu安装时，有的直接跳过了这一步，插入优盘重启就直接进入到ubuntu安装界面了。
(2) ------ 欢迎界面: 选择了U盘启动后，等待一小会儿，会出现如下“欢迎”界面（通过左侧的语言栏选择中文），选择中文后，点击“安装Ubuntu”;
(3) ------ 准备安装: 接下来会进入“准备安装Ubuntu”界面：这里勾选“为图形或无线硬件….”,然后点击“继续”。（这里会检测是否已经连网，没网的话，那个 “安装Ubuntu时下载更新” 的是不能选的，我的因为截图用的虚拟机，连网了所以可选，你安装的时候应该会是不可选的，点完继续后还需要等待一小会儿）:
(4) ------ 选择安装类型: 上步之后进入“安装类型”界面，选择“其他选项”，之后继续，如图：(这里我的是虚拟机，实际安装那些可选项可能会有差异，但是请选择“其他选项”,其他的我没试过，不保证能成功，个人觉得选择"其他选择"也是最佳选项)
(5) ------ 安装位置的选择及磁盘分区: 之后就进入了一个很重要的环节—选择安装位置，分配分区。【说明—最开始我只分了是三个分区：“/”、“/home”、“swap”, 其实还需要一个挺重要的分区，就是"/boot"分区，在此感谢@小段阿誉的建议。如果你的电脑只准备安装Ubuntu，个人感觉“/boot”不要也行，但是要是双系统的话，强烈建议分出一个"/boot"，这会在以后提供很大的便利。】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae8cf90105b424419f57e74e0043cc6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/002922bd56dda70eeaae2de9541a0d49/" rel="bookmark">
			5.2凯撒密码-加密python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据提示，在右侧编辑器补充代码，实现凯撒加密：输入一个字符串，对字符串中的字母和数字进行加密（规定加密偏移量为3，即后移三位），并输出加密后的字符串。
代码如下：
import string def caesar_cipher(text): """接收一个字符串为参数，采用字母表和数字中后面第3个字符代替当前字符的方法 对字符串中的字母和数字进行替换，实现加密效果，返回值为加密的字符串。 例如：2019 abc 替换为5342 def """ ########## Begin ########## lower = string.ascii_lowercase upper = string.ascii_uppercase digit = string.digits before = lower + upper + digit after = lower[3:]+lower[:3] + upper[3:]+upper[:3]+ digit[3:]+digit[:3] result = ''.maketrans(before, after) return text.translate(result) ########## End ########## if __name__ == '__main__': plaintext = input() print(caesar_cipher(plaintext)) #+ 相关知识 为了完成本关任务，你需要掌握：
1.string库
2.maketrans() 函数
3.translate()函数
1.要使用string模块，我们需要先导入： import string
下面介绍几个string的内置属性：
import string string.ascii_uppercase #所有大写字母 string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/002922bd56dda70eeaae2de9541a0d49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/592c8edc5794a3b66c484c9c719083a9/" rel="bookmark">
			Linux中怎么创建文件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，在Windows系统中可以直接右键新建文件，而在Linux系统中，想要创建文件并非易事，需要通过执行命令来完成，那么Linux系统中创建文件常用的方法有哪些?本文为大家介绍一下Linux系统下创建文件的8种方法，快来了解一下吧。
1、重定向符号&gt;
通常重定向符号可以创建一个0kb的空文件，可用于重定向命令的输出到一个新文件中，在无命令时使用重定向符号，会创建一个文件。
但它不允许你在创建文件时向其中输入任何文本。但它对于不是很勤劳的管理员是非常简单有用的，只需要输入重定向符后面跟着你想要的文件名。
2、touch命令
用于将每个文件的访问和修改时间更新为当前时间，如果指定的文件名不存在，将会创建一个新的文件。
touch不允许在创建文件的同时向其中输入一些文本，它默认创建一个0KB的空文件。
3、echo命令
echo内置大多数的操作系统中。它常用于脚本、批处理文件，以及作为插入文本的单个命令的一部分。
它允许在创建一个文件时就向其中输入一些文本。当然也允许在之后向其中输入一些文本。
4、printf命令
用法与echo相同。
5、cat命令
cat表示串联，在Linux经常用于读取一个文件中的数据。
cat是在类Unix系统中最常使用的命令之一。它提供了三个与文本文件相关的功能：显示一个文件的内容、组合多个文件的内容到一个输出以及创建一个新的文件。
6、vi/vim命令
是一个向上兼容vi的文本编辑器。它通常用来编辑所有种类的纯文本。在编辑程序时特别有用，vim中有很多功能可以用于编辑单个文件。
7、nano命令
nano是一个小且用户友好的编辑器，它复制了pico的外观及优点，并且是一个自由软件，它添加了pico缺乏的一系列特性，像是打开多个文件、逐行滚动、撤销/重做、语法高亮、行号等等。
8、head命令
用于输出一个文件开头部分，默认会打印一个文件前10行，如果有多个文件，则每个文件前都会有一个标题，用于表示文件名。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/778f0a61f4120d5971b8997487f1a46a/" rel="bookmark">
			腾讯｜阿里｜百度｜字节跳动人才体系的职位层级、薪酬、晋升标准
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		互联网圈有这么一句话：百度的技术，阿里的运营，腾讯的产品。那么代表互联网三座大山的BAT，内部人才体系有什么区别呢？今天小洁就带领大家看一看~
★ 腾讯 ★ 1. 职级 腾讯职级体系分6级，最低1级，最高6级。同时按照岗位又划分为四大通道，内部也叫“族”，比如：
产品/项目通道，简称P族
技术通道，简称T族
市场通道，简称M族
职能通道，简称S族
以T族为例，分别为：
T1：助理工程师 （一般为校招新人）
T2：工程师
T3：高级工程师 3-1相当于阿里的p6 到p7（能力强可能到p7）
T4：专家工程师
T5：科学家
T6：首席科学家
目前全腾讯貌似就一个T6。
每一级之间又分为3个子级，3-1是任命组长/副组长的必要条件，其他线也是这样。T4基本为总监级，也不排除有T3-3的总监，因为T4非常难晋级。
2. 晋升 腾讯的晋级还是很困难的。尤其是T2 升T3，T3升T4。非常多的人卡在2-3,3-3没办法晋级。有的小伙伴做了3、4年的2-3 也升不上去啊。
3. 薪水 腾讯薪资架构：12 1 1=14薪
年终奖：看部门盈利情况，一般是3个月
级别越高base薪酬也越高，一年根据你的performance大概能发15.3个月至18个月的工资，T3.1的base 2w ，T3以上级别的员工都会有股票期权，腾讯09以前的员工赚钱主要靠股票，从08到现在股票up了500% ，T5 的base薪酬在600w~800w/年。
4.人才 人才流动的可能：
在深圳：很多腾讯员工都买了房，当你的房子，妻子的工作，儿子的学校，你的朋友圈，都在一个城市的时候，换城市就有困难了。所以只能挖一些比较浅的人走。
在北京：人数不少 ，不过骨干员工不多。腾讯视频的主要团队在北京的倒是不少。
在成都、大连：在这些二线城市，腾讯就是当地最好的互联网公司了，提供的待遇也是非常高的，不少人都对自己的薪资比较满意，工作环境也很满意。跳槽的可能性低了很多。
人才结构：
腾讯的研发序列硕士学历的占多度，211大学，985大学占多数。大家都知道腾讯研究院解散了。去年走出来很多人，腾讯人才创业比例不高。
在腾讯最常碰到的晋升问题就是天花板。可能新人进去，学东西会很多，但业务线就这些，没有那么多坑，自然也就很难晋升高级岗。
在腾讯最悲剧的时刻就是公司有收购和整合。搜狗合并，搜搜的人哭了，京东合作，易迅的人哭了。在腾讯跳出来碰到最大的问题就是，外面的公司太不完善了。
★ 阿里巴巴 ★ 1. 层级 阿里的职称大部分都归纳在P序列 ,你的title 工种。比如P7产品经理=产品专家。
一般到P3为助理
P4=专员
P5=资深专员
P6=高级专员（也可能是高级资深）
P7=专家
P8=资深专家（架构师）
P9=高级专家（资深架构师）
P10=研究员
P11=高级研究员
P12=科学家
P13=首席科学家
P14=马云
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/778f0a61f4120d5971b8997487f1a46a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa3725d5f7d6c88493798308275f0907/" rel="bookmark">
			Vue简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概念
Vue快速入门
Vue常用指令
1、v-bind指令
2、v-on指令
3、v-if-else指令
4、v-show指令
5、v-for指令
Vue生命周期
概念 Vue是一套前端框架,免除原生JavaScript中的DOM操作,简化书写
基于MVVM(Model-View-ViewModel)思想，实现数据的双向绑定，将编程的关注点放在数据处理上
Vue快速入门 1、新建html页面，引入Vue依赖
&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.7.14"&gt;&lt;/script&gt; 2、在JS代码区域创建爱你Vue核心对象，进行数据双向绑定
new Vue({
el:"#app",
data(){
return{
username:""
}
}
}); 3、编写html视图
&lt;div id="app"&gt;
&lt;input name="username" v-model="username"&gt; {{username}}
&lt;/div&gt; 4、完整代码
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue实现双向绑定&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.7.14"&gt;&lt;/script&gt; &lt;div id="app"&gt; &lt;input type="text" name="username" v-model="username"&gt; {{username}} &lt;/div&gt; &lt;script&gt; new Vue({ el:"#app", data(){ return{ username:"" } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Vue常用指令 指令：html标签上带有v- 前缀的特殊属性，不同指令具有不同含义。例如：v-if,v-for.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa3725d5f7d6c88493798308275f0907/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/892e44f87d63e53758d4afda508fab7c/" rel="bookmark">
			shap显示全部的特征
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shap.plots.bar(shap_values, max_display=12)
用shap做解释性分析。其中条形图中，47条特征不能全部显示出来，最后在“shap”的官方文档中找答案，修改max_display。
来自：
https://wjrsbu.smartapps.cn/zhihu/article?id=554058433&amp;isShared=1&amp;uid_f=1609533562507677696&amp;_swebfr=1&amp;_swebFromHost=vivobrowser&amp;bdswankey=vivobrowser%3A%2F%2Fswan%2FoFx3nbdDN6GWF3Vb0Wh7EDBMBxRTTcfe%2Fzhihu%2Farticle%3Fid%3D554058433%26from%3D1599_N_9Eu9PP6eTyH_1_N%26searchParams%3D%257B%2522failUrl%2522%253A%2522https%253A%255C%252F%255C%252Fzhuanlan.zhihu.com%255C%252Fp%255C%252F554058433%2522%257D%26useTpl%3D1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14f042828533682bedd02cb270b4bc1a/" rel="bookmark">
			（四）Prometheus &#43; Grafana 可视化监控Nginx&#43;MySQL详细部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，环境准备
本篇基于Prometheus + Grafana 可视化监控工具部署Nginx+MySQL，
二，Grafana可视化图形工具
1，安装GRAFANA服务器
2，安装grafana可视化图形工具 以及启动服务
3，登陆 Grafana Web界面 http://192.168.100.12:3000/
三，配置数据源
1，添加Prometheus数据源数据
2，为数据源做数据展示 3，导入grafana监控面板 4，官网去提取ID https://grafana.com/grafana/dashboards/ 5，导入Nginx ID 和MySQL ID 6，Grafana 图形显示 MySQL 监控数据
7，Grafana 图形显示 Nginx 监控数据​
一，环境准备 Prometheus服务器192.168.100.12Nginx+MySQL服务器192.168.100.13grafana 服务器192.168.100.12 本篇基于Prometheus + Grafana 可视化监控工具部署Nginx+MySQL， Prometheus+Nginx+MySQL部署流程已在部署在上篇完成，
二，Grafana可视化图形工具 1，安装GRAFANA服务器 ##下载地址 基于压缩包下载方式和rpm包下载方式 wget https://dl.grafana.com/enterprise/release/grafana-enterprise-9.4.7.linux-amd64.tar.gz tar -zxvf grafana-enterprise-9.4.7.linux-amd64.tar.gz wget https://dl.grafana.com/enterprise/release/grafana-enterprise-9.4.7-1.x86_64.rpm sudo yum install grafana-enterprise-9.4.7-1.x86_64.rpm 2，安装grafana可视化图形工具 以及启动服务 yum install grafana-enterprise-9.4.7-1.x86_64.rpm systemctl start grafana-server.service systemctl enable grafana-server.service systemctl status grafana-server.service 查看端口 [root@localhost ~]# netstat -lnpt | grep 3000 tcp6 0 0 :::3000 :::* LISTEN 1613/grafana 3，登陆 Grafana Web界面 http://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14f042828533682bedd02cb270b4bc1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13a34826e108bce99a0c59b95b885873/" rel="bookmark">
			Python中struct 模块的使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.struct 简单介绍 struct 是 Python 的内置模块, 在使用 socket 通信的时候, 大多数据的传输都是以二进制流的形式的存在, 而 struct 模块就提供了一种机制, 该机制可以将某些特定的结构体类型打包成二进制流的字符串然后再网络传输，而接收端也应该可以通过某种机制进行解包还原出原始的结构体数据
2.struct 的使用 struct 模块可以将任意大小的数字转换成一个固定长度(可选择)的 bytes, 这个原理类似于前面章节讲过的 hash 算法, 不论内容多大, 最终的 hash 值长度不变, 不同的是 hash 算法是不可逆的, 而且传入的原材料可以是文本、字符串等许多数据类型, struct 可以反解出原来的数据
ps : struct 模块只能转换数字, 不能转换其他的数据类型
3.基本使用 pack 和 unpack 正确使用示例 (打包字节长度对应表请往下看)
import struct res = struct.pack("i",1234566) # 传入的必须是 int 类型 print(res) # b'\x86\xd6\x12\x00' (查看内容) print(type(res)) # &lt;class 'bytes'&gt; (查看类型) res2 = struct.unpack("i",res) # 使用什么 Format 打包就用什么解包 print(res2) # (1234566,) (是个元组) print(type(res2)) # &lt;class 'tuple'&gt; (查看类型) print(res2[0]) # 1234566 传入非 int 类型引发的错误示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13a34826e108bce99a0c59b95b885873/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d543da2dab0b8cebd03b11566530bbdb/" rel="bookmark">
			利用WebSocket和EventSource实现服务端推送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能有很多的同学有用 setInterval 控制 ajax 不断向服务端请求最新数据的经历(轮询)看下面的代码：
setInterval(function() { $.get('/get/data-list', function(data, status) { console.log(data) }) }, 5000) 这样每隔5秒前端会向后台请求一次数据，实现上看起来很简单但是有个很重要的问题，就是我们没办法控制网速的稳定，不能保证在下次发请求的时候上一次的请求结果已经顺利返回，这样势必会有隐患，有聪明的同学马上会想到用 setTimeout 配合递归看下面的代码：
function poll() { setTimeout(function() { $.get('/get/data-list', function(data, status) { console.log(data) poll() }) }, 5000) } 当结果返回之后再延时触发下一次的请求，这样虽然没办法保证两次请求之间的间隔时间完全一致但是至少可以保证数据返回的节奏是稳定的，看似已经实现了需求但是这么搞我们先不去管他的性能就代码结构也算不上优雅，为了解决这个问题可以让服务端长时间和客户端保持连接进行数据互通h5新增了 WebSocket 和 EventSource 用来实现长轮询，下面我们来分析一下这两者的特点以及使用场景。
WebSocket 是什么： WebSocket是一种通讯手段，基于TCP协议，默认端口也是80和443，协议标识符是ws（加密为wss），它实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端也能主动向客户端发送数据，不受跨域的限制。
有什么用： WebSocket用来解决http不能持久连接的问题，因为可以双向通信所以可以用来实现聊天室，以及其他由服务端主动推送的功能例如 实时天气、股票报价、余票显示、消息通知等。
EventSource 是什么： EventSource的官方名称应该是 Server-sent events（缩写SSE）服务端派发事件，EventSource 基于http协议只是简单的单项通信，实现了服务端推的过程客户端无法通过EventSource向服务端发送数据。喜闻乐见的是ie并没有良好的兼容当然也有解决的办法比如 npm install event-source-polyfill。虽然不能实现双向通信但是在功能设计上他也有一些优点比如可以自动重连接,event IDs,以及发送随机事件的能力（WebSocket要借助第三方库比如socket.io可以实现重连。）
有什么用： 因为受单项通信的限制EventSource只能用来实现像股票报价、新闻推送、实时天气这些只需要服务器发送消息给客户端场景中。EventSource的使用更加便捷这也是他的优点。
WebSocket &amp; EventSource 的区别 WebSocket基于TCP协议，EventSource基于http协议。EventSource是单向通信，而websocket是双向通信。EventSource只能发送文本，而websocket支持发送二进制数据。在实现上EventSource比websocket更简单。EventSource有自动重连接（不借助第三方）以及发送随机事件的能力。websocket的资源占用过大EventSource更轻量。websocket可以跨域，EventSource基于http跨域需要服务端设置请求头。 EventSource的实现案例 客户端代码
// 实例化 EventSource 参数是服务端监听的路由 var source = new EventSource('/EventSource-test') source.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d543da2dab0b8cebd03b11566530bbdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101fc86ca9b26c24f3b11bec105174eb/" rel="bookmark">
			【数据结构与算法】堆的应用：堆排序和topk问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.堆排序
二.topk问题
一.堆排序 我们知道冒泡算法的时间复杂度是O（N^2），在数据量很多的时候，N^2是个很可怕的数字，二分算法的时间复杂度是O(logn)，但是二分算法有限制条件，实用性并不高，那怎样才能高效实用的排序呢？
堆排序就能很好解决上述问题，堆排序的时间复杂度是O(logn)，也没啥限制条件，可以实现高效排序。
这里要注意，排升序要建大堆，排降序要建小堆;
1.假设排升序，所以建大堆；
2.堆建好后，定义一个 end 变量，令其 =n-1（数组最后一个元素的下标是n-1） ；
3.堆建好后，数组第一个元素就是最大的，将其与最后一个数据交换，然后这个数据就不需要动了，为了保持它是个大堆，让它的前 end-1 个元素向下调整，然后end--，当 end&lt;=0 时就结束循环。
堆排序不需要手搓个堆，只需要用到向下调整这个函数，所以使用堆排序时，只需写个向下调整就行了。
void Swap(int* p1, int* p2) { int tmp = *p1; *p1 = *p2; *p2 = tmp; } void AdjustDown(int* arr, int parent, int n) { assert(arr); int child = 2 * parent + 1; while (child &lt; n) { if ((child + 1) &lt; n&amp;&amp; arr[child + 1] &gt; arr[child]) { child++; } if (arr[child] &gt; arr[parent]) { Swap(&amp;arr[child], &amp;arr[parent]); parent = child; child = 2 * parent + 1; } else break; } } void Heapsort(int* arr, int n) { assert(arr); int i = 0; for (i = (n - 2) / 2; i &gt;= 0; i--) //建堆 { AdjustDown(arr, i, n); } int end = n - 1; while (end) { Swap(&amp;arr[0], &amp;arr[end]); AdjustDown(arr, 0, end); end--; } for (i = 0; i &lt; n; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/101fc86ca9b26c24f3b11bec105174eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d024e26509a52f408f6d7f382767efb4/" rel="bookmark">
			云计算ACP云服务器ECS实例题库（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😘作者简介：一名99年运维岗位员工。👊宣言：人生就是B（birth）和D（death）之间的C（choise），做好每一个选择。🙏创作不易，动动小手给个点赞加关注吧，有什么意见评论区告诉我，一起学习。 前言 本篇文章，分享50道ECS实例的题库，带有题目和答案解析，供大家使用。
刷题区（蓝色区域是答案） 问1：随着业务的增长，小张现有的阿里云云服务器ECS实例的系统盘出现了存储资源不足的问题，阿里云提供了系统盘扩容的功能帮小张解决该问题。关于扩容系统盘的操作，下列说法错误的是（）。
A.通过更换ECS实例的系统盘操作来实现系统盘的扩容
B.扩容ECS实例的系统盘时需要停止实例，因此会短暂中断业务
C.扩容系统盘之后，ECS实例的IP地址会发生变化
D.扩容系统盘后，用户创建的快照会保留
解析：扩容系统盘并不是导致网络层的IP地址会发生变化。
问2：应用系统部署在阿里云云服务器ECS实例上，系统每晚上会进行当天运营数据的报表统计，在凌晨3点钟出现短暂的统计服务响应变慢的情况，但很快自动消失，该情况很可能是云服务器ECS实例自身的（）操作引起的。
A.云服务器ECS实例自动休眠了
B.云服务器ECS实例的自动快照的时间设置在每天凌晨3点
C.云服务器ECS实例的自动镜像服务设置在凌晨3点
D.互联网网络不稳定
解析：设置自动快照创建时间和重复日期时应尽量避开业务高峰，因为创建快照可能会轻微降低磁盘的性能，出现短暂瞬间变慢。
问3：（多选）下列选项关于阿里云云服务器ECS实例是否支持安装虚拟化程序的描述正确的是（）。
A.云服务器ECS实例是基于虚拟化平台运行的，不支持部署虚拟化程序
B.如果在云服务器ECS实例中部署虚拟化程序，服务器出现的问题是可以预测的
C.可以在云服务器ECS实例中部署虚拟化程序，阿里云提供相应的技术支持
D.如果在云服务器ECS实例中部署虚拟化程序，会导致服务器出现不可预测的问题
解析：如果在云服务器ECS实例中部署虚拟化程序，服务器出现的问题是不可预测的。阿里云强烈不建议在云服务器ECS实例中部署虚拟化程序，这样会导致云服务器ECS出现不可预测的问题。
问4：若现在希望基于已有的磁盘快照在青岛可用区A的云服务器ECS实例创建一个新的块存储磁盘，可以使用（）快照创建该磁盘。
A.以下都不行
B.青岛可用区A的某个ECS实例的系统盘快照
C.北京可用区A的某个ECS实例的数据盘快照
D.香港可用区A的某个ECS实例的数据盘快照
解析：提示:题目中要求的是在ECS上面新挂载一块数据盘，所以可以使用和它同一个可用区的非系统盘快照来创建。所以三个选项都是不符合要求的。系统盘快照，不能用来作为创建新的数据盘。
问5：阿里云会为每个云服务器ECS实例分配一个私网IP。有关云服务器ECS实例的私网IP，说法正确的是（）。
A.私网IP不可以用于SLB的负载均衡
B.同一地域内实例之间通过私网IP进行的通讯流量是收费的
C.不要在操作系统内部自行变更私网IP，否则可能会导致私网通讯中断
D.私网不允许同一帐号下的云服务器ECS实例之间或者云服务器ECS实例与其他云服务之间互访
解析：本题考点：私网ip的概念和使用；私网IP是可以用于SLB的负载均衡，同一地域内实例之间通过私网IP进行的通讯是不收取流量费的，私网允许同一帐号下的云服务器ECS实例之间或者云服务器ECS实例与其他云服务之间互访。
问6：（多选题）您计划基于阿里云的云服务器ECS实例搭建一个网站，下列选项中有可能会影响网站打开速度的因素有哪些。
A.网页内容本身的大小
B.网络的带宽
C.是否有大量数据库的操作
D.是否过多引用了其他网站的内容
E.云服务器ECS实例的磁盘大小
解析：云服务器ECS实例的磁盘大小是不会影响到网站的访问速度的。
问7：小A通过阿里云的云监控服务为某台云服务器ECS实例的磁盘使用率设置了1条报警规则：统计周期为5分钟，磁盘使用率平均值超过80%，连续探测5次超过阈值后就报警。如果小A的磁盘平均使用率超过80%后，至少需要（）分钟后可以收到报警。
A.40分钟
B.0分钟
C.20分钟
D.30分钟
解析：提示:连续五次超过阈值就报警，问的是最少的时间。所以可以假设刚启动云监控就开始第一次探测超过阈值。所以后面一共只需要四个探测周期就可以报警了。所以时间为5分钟*4次=20分钟。
问8：（多选题）阿里云的云服务器ECS实例根据底层支持的硬件不同，而划分为不同的实例系列。对于实例系列 I采用 Intel Xeon CPU，实例系列 II采用Haswell CPU。以下关于实例系列说法正确的有哪些？
A.实例系列 II 的用户用户可以获得更大的实例规格
B.实例系列 II 同时增加了一些新的指令集，使整数和浮点运算的性能翻倍
C.实例系列 I 与实例系列 II 之间可以互相升降配
D.对于 I/O 优化实例，配合SSD云盘使用获得更高更好的 I/O 性能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d024e26509a52f408f6d7f382767efb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c58cf7b55dd66f1b425ad52a5c05eb98/" rel="bookmark">
			（二）Prometheus监控Nginx服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，部署环境准备
1，安装Nginx 下载地址
2，在Linux安装 nginx-module-vts 组件 下载地址 3，在Linux安装nginx-vts-exporter 组件 下载地址
二，安装nginx以及组件 nginx-module-vts
1，安装Nginx
2，修改Nginx配置文件
3，启动Nginx服务 4，启动nginx后访问http://IP地址/status 三， 安装nginx-vts-exporter 组件
1，安装 nginx-vts-exporter 用来收集 nginx 的 json 数据
2，启动nginx-vts-exporter 3，另开一个窗口，查看端口
四，添加监控至 Prometheus服务器IP地址（192.168.100.12）
1，重启Prometheus服务
2，查看 Prometheus 网页状态 通过上一篇文章，(一）Prometheus部署+node_exporter组件实例详解 本篇继续搭建基于——Prometheus监控Nginx服务 一，部署环境准备 Prometheus服务器192.168.100.12Nginx+MySQL服务器192.168.100.13grafana 服务器192.168.100.12 1，安装Nginx 下载地址 https://nginx.org/download/nginx-1.22.1.tar.gz 2，在Linux安装 nginx-module-vts 组件 下载地址 nginx-module-vts组件： Nginx的监控模块，能够提供JSON格式的数据产出 https://codeload.github.com/vozlt/nginx-module-vts/zip/refs/heads/master 3，在Linux安装nginx-vts-exporter 组件 下载地址 nginx-vts-exporter 组件：主要用于收集Nginx的监控数据，并给Prometheus提供监控接口，默认端口号9913 https://github.com/hnlq715/nginx-vts-exporter/releases/download/v0.10.3/nginx-vts-exporter-0.10.3.linux-amd64.tar.gz 二，安装nginx以及组件 nginx-module-vts 1，安装Nginx [root@localhost ~]# cd /opt/ ; mkdir nginx ; cd nginx [root@localhost nginx]# pwd /opt/nginx [root@localhost nginx]# rz -E rz waiting to receive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c58cf7b55dd66f1b425ad52a5c05eb98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a19caa0523a7ecee5c521044cff362b8/" rel="bookmark">
			IDEA新建JAVA项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：jdk、配置好环境变量。
1.打开idea，选择Create New Project。如果已经打开其他项目，点击File-&gt;New-&gt;Project，也可以打开新建的界面。（项目的文件名可以提前在磁盘新建好，也可以在第4步的时候，选择项目路径时有文件夹新建图标）
2.在右侧选择Java，选择JDK安装的路径，因为只创建Java项目不使用框架，所以直接点击Next。
3.询问是否选择模板界面，不勾选，直接点击Next。
4.输入新创建的Java项目名称和项目存储路径，点击Finish。
5.右击src新建包package，名称自定义。在包下新建一个test类，运行main方法。
6.输出hello，代表Java项目运行成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2725108543f0a5507e7002e3dde98831/" rel="bookmark">
			（三）Prometheus监控MySQL服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，部署环境准备
1，mysqld_exporter 组件下载
2，mysql以及mysqld_exporter 组件安装
3，在mysql_exporter中设置mysql配置信息
4，启动mysql_exporter
5，查看端口9104是否起来
二，配置prometheus拉取mysql节点信息
1，在prometheus的server服务端进行修改
2，重启prometheus服务
3，通过web端查看 http://192.168.100.12:9090/
​4，查看mysql数据页 http://192.168.100.13:9104/
上一篇文章（二）Prometheus监控Nginx服务
本篇继续搭建基于——Prometheus监控MySQL服务
一，部署环境准备 Prometheus服务器192.168.100.12Nginx+MySQL服务器192.168.100.13grafana 服务器192.168.100.12 1，mysqld_exporter 组件下载 下载地址 https://github.com/prometheus/mysqld_exporter/releases/download/v0.13.0/mysqld_exporter-0.13.0.linux-amd64.tar.gz 2，mysql以及mysqld_exporter 组件安装 #解压安装包 tar zxf mysqld_exporter-0.13.0.linux-amd64.tar.gz mv mysqld_exporter-0.13.0.linux-amd64 /usr/local/mysql_exporter #安装mariadb yum install mariadb\* -y #启动数据库 systemctl start mariadb systemctl enable mariadb #查看端口 ss -natlp |grep 3306 #进入mysql （mariadb数据库不需要密码） #在数据库里创建mysql账号用户收集数据 mysql -uroot MariaDB [(none)]&gt; grant select,replication client,process ON *.* to 'mysql_monitor'@'localhost' identified by '12345678'; Query OK, 0 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2725108543f0a5507e7002e3dde98831/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f75019d6a70aacf60ddeadf37c1d514f/" rel="bookmark">
			Tensorflow和pytorch的区别是什么？哪个更好？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两个最受欢迎的深度学习库：Pytorch和tensorflow，这两个究竟有什么区别？他们之间有什么优缺点。接下里和大家一起看看这其中究竟。
第 1 点：
虽然 Tensorflow 和 PyTorch 都是开源的，但它们是由两个不同的向导创建的。Tensorflow 基于 Theano，由 Google 开发，而 PyTorch 基于 Torch，由 Facebook 开发。
第 2 点：
两者之间最重要的区别是这些框架定义计算图的方式。虽然 Tensorflow 创建的是静态图，但 PyTorch 相信动态图。那么这是什么意思？在 Tensorflow 中，必须定义模型的整个计算图，然后运行您的 ML 模型。但是在 PyTorch 中，可以随时随地定义/操作您的图形。这在 RNN 中使用可变长度输入时比较有用。
第 3 点：
Tensorflow 的学习曲线比 PyTorch 更难一点，怎么说？PyTorch更符合Python和建设ML车型感觉更直观一些。另一方面，使用 Tensorflow的话，必须更多地了解它的工作原理（会话、占位符等）。
第 4 点：
Tensorflow 的社区比 PyTorch 大得多。这意味着更容易找到学习 Tensorflow 的资源，也更容易找到问题的解决方案。另外，小普还注意到，许多教程和 MOOC 都涵盖了Tensorflow，这是因为与 Tensorflow 相比，PyTorch 是一个相对较新的框架。所以，在资源方面，我们就可以找到比 PyTorch 多得多的关于 Tensorflow 的内容。
第 5 点：
如果不提及 TensorBoard，这种比较将是不完整的。TensorBoard 可以直接在浏览器中可视化 ML 模型。PyTorch 没有这样的工具，尽管可以使用像 Matplotlib 这样的工具。不过，有一些集成可以将 Tensorboard 与 PyTorch 结合使用。但本机不支持它。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f75019d6a70aacf60ddeadf37c1d514f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/837cded12a25ce162efd9b958426efd0/" rel="bookmark">
			线程池是什么？线程池(ThreadPoolExecutor)使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一点，了解更多https://www.csdn.net/ 本篇文章将详细讲解什么是线程池，线程池的参数介绍，线程池的工作流程，使用Executors创建常见的线程池~~~
目录
点一点，了解更多
文章目录
一、线程池的概念
1.1线程池的目的-提高效率
二、线程池的参数介绍
2.1线程池的拒绝策略
以上四种策略要重点掌握，面试常考~~
三、线程池的工作流程
四、线程池的创建
4.1方法一 4.2方法二 4.3方法三
4.4方法四
4.5方法五
4.6方法六
4.7方法七
五、模拟实现一个线程池
一、线程池的概念 简单来说，可以理解为一个“现成的池子”，里面有一定数量的线程等待工作，每次使用不用再次创建、使用完了不用马上销毁，会自动回收进池子中。类似常量池等等~~
虽然创建销毁线程比创建销毁进程更轻量, 但是在频繁创建销毁线程的时候还是会比较低效，线程池就是为了解决这个问题，如果某个线程不再使用了，并不是真正把线程释放，而是放到一个“池子”中，下次如果需要用到线程就直接从池子中取，不用再次创建。
1.1线程池的目的-提高效率 池的目的就是为了提高效率，从线程池中拿线程，属于用户态操作；而从系统再去创建线程，涉及到用户态和内核态之间的切换，真正的创建是在内核态完成的。
那么什么是用户态？什么是内核态？下面我来举个例子：
银行中有大厅和服务柜台，大厅相当于用户态，柜台相当于内核态；每个地方都有打印机，如果来客户需要办理业务，可以在打印机上办理，也可以找工作人员办理。
此时来个老哥，说想办个银行卡，但是没带身份证复印件，有俩个办法：1.自己去大厅的复印件，自己复印一份，拿过来。2.让工作人员去柜台里面的打印机，去复印下再拿回来。
那么如果自己去复印，就立即去了，立即回来了，中间不耽误；如果工作人员去复印，他可能会做点别的，确实能给你复印，但是就不一定及时了~~
结论：用户态操作，时间是可控的；涉及到内核态操作，时间就不可控了~~
二、线程池的参数介绍 先看ThreadPoolExecutor 的构造方法
重点理解一下这几个参数含义：先情景带入一下，把线程池当作公司，一类正式员工；一类实习生；
1.corePoolSize:核心线程数，相当于正式员工
2.maxinumPoolSize:最大线程数，相当于正式员工+实习生
3.
long keepAliveTime:实习生线程保持存活的时间 当任务比较少的时候，整体比较空闲，实习生不是立即被辞退的，表示实习生最大的存活时间
4.
TimeUnit unit:单位，秒，分钟，毫秒
5. BlockingQueue&lt;Runnable&gt; workQueue:线程池里要管理很多任务，这些任务也是通过阻塞队列来组织的，此时可以手动指定一个队列给线程池，此时就可以很方便的获取队列中的信息
6.
ThreadFactory threadFactory：工厂模式，创建线程的辅助的类
7.
RejectedExecutionHandler handler：线程池的拒绝策略，如果任务量超出公司的负荷接下来该怎么处理
2.1线程池的拒绝策略 上述四种是标准库中提供的四种拒绝策略：
1.
表示如果队列满了，继续添加任务， 添加操作之间抛出异常（新老都执行不了，哭）
2.
添加的线程自己负责执行这个任务（怼回去）
3.
丢弃最老的任务
4. 丢弃最新的任务 以上四种策略要重点掌握，面试常考~~ 三、线程池的工作流程图 四、线程池的创建 ExecutorService 表示一个线程池实例Executors 是一个工厂类, 能够创建出几种不同风格的线程池ExecutorService 的 submit 方法能够向线程池中提交若干个任务Executors 本质上是 ThreadPoolExecutor 类的封装 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/837cded12a25ce162efd9b958426efd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9be8c170b2d1e4453ec95b27ec3d10dc/" rel="bookmark">
			Entity Framework Core-安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这节我们主要介绍如何在项目中安装Entity Framework Core，首先在Visual Studio中创建一个ASP.NET Core MVC 应用程序，如下图所示：
这个项目上安装EF Core Database Provider以及相关工具
安装EF Core Database Provider Entity Framework Core 针对市面上主要的数据库都提供了对应的Provider和对应的NuGet，我们这系列使用SQL Server数据库，因此需要安装SQL Server数据库对应的Provider，我们进入Visual Studio Tools-&gt;NuGet Package Manager-&gt; Manage NuGet Packages for Solution，打开NuGet UI，这个是针对整个解决方案
在文本框中输入Microsoft.EntityFrameworkCore.SqlServer 并点击查询，对应的安装将显示在列表中，右侧有个checkbox的选择列表，选中你想要将Package安装到的哪个项目
我们选中项目并点击Install 按钮，接下来会看到一个Preview Changes 窗体，点击OK按钮
接下来我们会看到License Acceptance窗体，点击I Accept 按钮
整个安装过程需要几秒钟完成，Microsoft.EntityFramework
Core.SqlServer 将安装到你应用程序
你可以在Dependencies &gt; NuGet节点下查看一下刚才安装的包，也可以直接在项目上进行安装(Project &gt; Manage NuGet Packages)
我们还可以使用另外一种方式，在Visual Studio进入Tools &gt; NuGet Package Manager &gt; Package Manager Console 执行命令，这种方式也可以将你的包安装到项目中
Install Package Microsoft.EntityFrameworkCore.SqlServer 安装Entity Framework Core 工具 执行EF Core命令之前(例如Migration，scaffoldings)，需要安装下面两个包中的任意一个即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9be8c170b2d1e4453ec95b27ec3d10dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/031750250ca961226e3ea38dfae622d0/" rel="bookmark">
			C/C&#43;&#43;读取和写入文件（csv、txt）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.读写程序 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void main() { int a = 1; int b = 2; int c = 3; FILE* ReadWrite; errno_t err=fopen_s(&amp;ReadWrite,"Test.csv","w");//打开csv文件,打开成功返回0。文件类型可以修改，比如csv,txt等。 fprintf(ReadWrite, "%d,%d", a,b);//写入a,b的；%d,%d将a,b分别写入两个单元格；%d%d将a,b写入一个单元格 fprintf(ReadWrite,"\n");//换下一行 fprintf(ReadWrite, "%d", c); fclose(ReadWrite);//关闭文件 } 程序运行结果（分别写入csv文件和txt文件）：
fopen_s：指针,文件名,读写标志位
errno_t ：打开文件是否成功返回值
2.读写标志位 FILE的读写标志位如下：
//****************读写标志位说明********************* //1."r":以"读"的方式打开一个文本文件(只能读)。 //2."r+": 在"读"的基础下增加了"写入"。 //3."rb":以"读"的方式打开一个二进制文件(只能读)。 //4."rb+":在"读"的基础下增加了"写"。 //5."w":以"写"的方式创建一个文本文件,若文件已经存在, 则会覆盖原来的文件。 //6."w+":在"写"的基础下增加了"读"。 //7."wb":以"写"的方式创建一个二进制文件。 //8."wb+":在"wb"的基础下增加了"读"。 //9."a":打开一个文本文件并在尾部写入，不覆盖已有的数据(只能写)。 //10."a+":在"a"的基础下增加了"读"。 //11."ab":打开一个二进制文件并在尾部写入数据，不覆盖已有的数据(只能写)。 //12."ab+": 在"ab"的基础下增加了"读"。``` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ebb2c928ac243b97cf7ff3803d02245/" rel="bookmark">
			Linux安装Pytorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Anaconda环境搭建 在Anaconda3官方下载对应的系统版本，本教程以64位linux_16.04系统为例。官网下载
安装Anaconda
进入自己的下载目录 cd ~/Downloads 使用以下命令进行安装： bash Annaconda...xxx.sh(文件名，文件名可以用tab健自动补全) 选择yes
进入到以下页面：
到此就已经完成安装了，选择yes进行conda初始化
安装成功
新开一个终端输入python 测试是否Anaconda安装成功 可见新打开的终端前有个（base），说明安装成功
输入conda -V可以查看当前conda版本
conda -V 创建pytorch虚拟环境 首先创建与自己服务器中python版本相匹配的pytorch虚拟环境,下载可能有点慢，更换源可能会快一点，更换源的博客很多。
conda create -n pytorch python=3.8 接着进入创建的环境中
conda activate pytorch # 然后去pytorch官网找到适合自己电脑配置的pytorch版本进行安装，这里我是安装GPU版本的，安装cpu版本的选择cpu就好
安装命令在官网上选好配置后会显示出来，复制进终端运行即可
conda install pytorch torchvision torchaudio pytorch-cuda=11.7 -c pytorch -c nvidia 在pytorch环境下输入逐次输入以下命令验证是否安装成功
python #检查python版本 import torch torch.cuda.is_available() 到此，恭喜你已经成功安装了cuda 和 pytorch 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/accd58f857447cd9ce8138f5e280d3c5/" rel="bookmark">
			数据库:Redis数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据库类型
1、关系型数据库
2、非关系型数据库
3、关系型非关系型区别
二、Redis数据库
1、什么是Redis
3、Redis特点
4、Redis为什么读写快
5、部署Redis数据库
6、redis管理
7、Redis数据库五大类型
8、Redis数据库基础使用
9、redis五大类型增删查 一、数据库类型 1、关系型数据库 关系型数据库：是一个机构号的数据库，创建在关系模型基础上，是一个二维表，表中字段记录有关联，先建库再建表
2、非关系型数据库 非关系型数据库：NoSQL(NoSQL = Not Only SQL )，意思是“不仅仅是 SQL”，是非关系型数据库的总称。除主流关系型数据库都是非关系型数据库，Redis、Hbase、大部分用在缓存中
3、关系型非关系型区别 非关系数据库：数据保存在缓存中，利于读取速度/查询数据、架构中位置灵活、分布式、扩展性高
关系数据库：安全性高（持久化）、事务处理能力强、任务控制能力强、做日志备份、恢复、容灾的能力更强一点。
二、Redis数据库 1、什么是Redis Redis（远程字典服务器） 是一个开源的、使用 C 语言编写的 NoSQL 数据库即非关系数据库。
Redis服务器程序是单进程模型，也就是在一台服务器上可以同时启动多个Redis进程，在实际生产环境中，需要根据实际的需求来决定开启多少个Redis进程。若对高并发要求更高一些，可能会考虑在同一台服务器上开启多个进程。
Redis 6.0 中新增加的多线程也只是针对处理网络请求过程采用了多线性，而数据的读写命令，仍然是单线程处理的。
2、Redis命中机制和淘汰机制
命中机制：查询数据可以查询到，例如查询100条可以查询到20条即命中20条
淘汰机制：Redis缓存的是高热数据，若负载高于限制则淘汰一些最近没有访问的数据，即删除
3、Redis特点 ①读写速度快，读最高可达110000次/s 写最高81000次/s。
②支持丰富的数据类型，key-value 、 strings、 lists等。
③持久化，可以将内存中的数据保存在磁盘中，重启时再次加载进内存进行使用，定期快照，日志记录方式保存(类似增量备份)。
④原子性：redis 所有操作都是原子性的。
⑤支持数据备份：即 master-salve 模式的数据备份。
4、Redis为什么读写快 ①、redis是一款纯内存结构工作在内存中，避免了磁盘I/O等操作耗时操作
②、redis命令处理的核心模块是单线程，减少了锁竞争，以及频繁创建线程和销毁线程的代价，减少了线程上下文切换的消耗
③、采用I/O多路复用技术，大大提高并发效率
5、部署Redis数据库 yum install -y gcc gcc-c++ make #安装工具 cd /opt #进入opt目录将软件包上传 tar zxvf redis-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/accd58f857447cd9ce8138f5e280d3c5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/151/">«</a>
	<span class="pagination__item pagination__item--current">152/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/153/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>