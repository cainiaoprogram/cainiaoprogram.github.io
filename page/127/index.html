<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f460d64d686563598afd8c8955da8ca/" rel="bookmark">
			阅读p-limit源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		p-limit介绍 p-limit是一个控制并发量的库，比如我们在请求接口时同时请求了10个接口，这时候我们希望把十个请求分成两份，每次请求5个，避免服务器太大压力，那我们就可以用到p-limit这个库了。
import pLimit from 'p-limit' const limit = pLimit(2) const fetchSomething = (val) =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(val, Date.now()) resolve(val) }, 1000) }) } const input = [ limit(() =&gt; fetchSomething('foo')), limit(() =&gt; fetchSomething('bar')), limit(() =&gt; fetchSomething('end')) ] // Only one promise is run at once const result = await Promise.all(input) 在上面这段用例中，会先弹出foo,bar，然后又隔了一秒（settimeout里面设置的间隔）才弹出end，说明我们的并发控制完成了。
在项目中配合axios使用： import axios from 'axios'; import pLimit from 'p-limit'; const service = axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f460d64d686563598afd8c8955da8ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3585eb3ed785d2947d3dc32e3959f83b/" rel="bookmark">
			Next 报 Super expression must either be null or a function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次用next，发现组件引入后会报错，
Error [TypeError]: Super expression must either be null or a function 查了下文档发现是要在首行加入
'use client' import React from "react"; ... 官网链接：https://nextjs.org/docs/getting-started/react-essentials#when-to-use-server-vs-client-components
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5606e0a3e9bf00ff9ee37742d64a80ee/" rel="bookmark">
			如何安全地变更数据库 Schema
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近 Reddit 的 r/golang 下有人问了一个如何做数据库 schema 变更的问题，不到一天，就有了超过 40 条回复。
数据库 schema 变更一直是让程序员头疼的问题，但又不得不面对，毕竟业务要发展，产品要迭代，添加新的功能往往需要去修改数据库的结构，比如添加一个新的字段来保存新的信息，那么这就涉及到数据库 schema 的变更。
先看提问者的 2 个问题：
问题 1 - 缺少变更的可见度
因为可能就开发者或者 DBA 直接连到数据库，就执行了变更语句，具体执行了什么语句，什么时候执行的这些只有当事人自己知道（或者说当事人回过头来也可能忘记了）。
问题 2 - 保证变更的唯一性和排他性
一个应用通常代码会部署多个副本，但都连着同一个数据库。从提问者的描述看，他们当前是在新的代码版本启动时，去尝试变更数据库的。那么问题来了，当多个新代码版本的副本同时启动时，到底如何保证只有其中一个副本可以对数据库进行变更，而其他副本先等待着呢。
提问者最后也在问有没有推荐的变更最佳实践和工具，可以用于生产环境。从最佳实践角度，主要就 2 点：
像对待代码变更一样对待数据库变更把代码变更和数据库变更分离 而 Bytebase 就是结合这套最佳实践的数据库变更工具。
像对待代码变更一样对待数据库变更 我们先来看一下典型的代码变更流程：
在 GitLab / GitHub 这样的代码平台提交变更请求，GitLab 里叫 MR (Merge Request)，GitHub 上叫 PR (Pull Request)。如果有配的话，MR / PR 会先经过一系列的自动检察，比如最简单的比如代码是否可以编译，是否符合编码规范，以及一系列的自动化测试。会有一个或多个评审人对代码进行审核 (Code Review）。审核通过后，代码就提交到仓库了，提交历史也被记录了一下。经过手动或者自动的流程，代码会被打包成一个新版本，专业的术语叫做制品（Artifact）。代码部署系统会把新版本按照预先配置的流程，逐渐部署出去。通常先部署到测试环境，在测试环境里，会运行一些集成测试，也可能会有 QA 团队进行手工测试。在测试环境通过后，就会部署到预发环境，在预发环境验证后，最终会部署到生产环境，当然在生产环境，往往也会一点点的逐步更新，也就是所谓的灰度发布。 前面介绍的也就是大家现在所熟知的应用 CI/CD 流程，归纳出来不长，但其实也是花了业界 20 多年才摸索出了这套如今约定俗成的方案，解决了代码变更和发布里的协同，可见度，可靠性，效率等一系列问题。
而数据库的变更因为涉及到数据也就是状态（state）的变更，虽然流程上可以借鉴代码变更的思路，但还是更加复杂的。Bytebase 就是这样一套把代码变更的流程引入到数据库变更的工具。
可视化的变更审核界面 Bytebase 提供了可视化的变更审核界面，开发者和 DBA 可以在同一个界面上对于数据库变更进行协作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5606e0a3e9bf00ff9ee37742d64a80ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c072c27901bc6936057d4589c6d98c42/" rel="bookmark">
			ROS2安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、版本选择 UbuntuROS1.0ROS2.0GazeboROS2Go 1.016.04 LSTKinetic LTSArdent7.+ROS2Go 2.018.04 LSTMelodic LTSDashing LST9.+ROS2Go 3.020.04 LSTNoetic LTSFoxy LTS11.+ 2、安装 ubuntu20.04-------------------------ROS2---------------------------------安装Foxy LST
2.1 安装ROS2 sudo apt update sudo apt install ros-foxy-desktop 2.2 设置环境变量 source /opt/ros/foxy/setup.bash 出现警告：ROS_DISTRO was set to ‘noetic’ before. Please make sure that the environment does not mix paths from different distributions.
原因：安装了ROS1的noetic
解决方法：找到bashrc文件，注释noetic环境即可
2.3 安装自动补全工具 sudo apt install python3-argcomplete 2.4 测试安装结果 运行talke如下：
source /opt/ros/foxy/setup.bash ros2 run demo_nodes_cpp talker 再打开一个终端运行listener如下：
source /opt/ros/foxy/setup.bash ros2 run demo_nodes_cpp listener 回头看，轻舟已过万重山！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/283ef9a7de5efcae526b6979f619e7bc/" rel="bookmark">
			Python3数据分析与挖掘建模（14）特征工程、数据清洗、特征预处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 特征工程概念 1.1 特征工程概述 特征工程是机器学习中至关重要的步骤，它涉及到特征的选择、获取、处理和监控。下面是对每个方面的详细解释：
（1）特征使用：
- 数据选择：在特征工程中，需要选择与问题相关的数据集。这意味着根据问题的定义和目标，选择包含相关特征的数据集。
- 可用性：在使用特征时，需要确保特征的可用性和可访问性。这包括确保数据集的完整性、准确性和可信度。
（2）特征获取：
- 特征来源：特征可以来自多个来源，例如传感器数据、数据库、日志文件等。在特征工程中，需要确定特征来自哪些来源，并进行相应的数据提取和集成。
- 特征存储：获取的特征需要进行存储，以便后续的特征处理和建模。这可能涉及将特征存储在数据库中、保存为文件或加载到内存中的数据结构中。
（3）特征处理：
- 数据清洗：在特征工程中，常常需要处理数据中的缺失值、异常值和噪音。这包括填充缺失值、修复异常值或删除含有噪音的数据点。
- 特征预处理：预处理是指对特征进行转换、归一化或标准化，以使其适合模型的要求。例如，将连续特征离散化、对特征进行缩放或进行特征编码等。
（4）特征监控：
- 现有特征：在特征工程过程中，需要对现有特征进行监控和评估。这可以包括检查特征的相关性、重要性和分布情况，以确保它们对模型的贡献和可靠性。
- 新特征：特征工程可能涉及引入新的特征或从现有特征中派生新的特征。在这种情况下，需要对新特征进行评估和验证，以确保它们对问题的解决有帮助，并且与其他特征不产生冗余或重复信息。
特征工程的目标是选择、创建和转换特征，以使其能够更好地描述问题和提供有效的输入给机器学习模型。通过合理的特征使用、获取、处理和监控，可以提高模型的性能、准确性和泛化能力。
1.2 数据模型与形成 数据模型是对现实世界中的实体、属性和关系的抽象描述，用于表示和理解数据的结构和特征。数据模型可以是概念模型、逻辑模型或物理模型，根据不同的目的和应用场景选择合适的模型类型。
数据模型的形成是指通过一系列的步骤和方法将原始数据转化为可用于分析、预测和决策的模型。这个过程通常包括以下几个主要步骤：
（1）数据清洗和预处理：对原始数据进行清洗、去除噪音、处理缺失值和异常值等。还可以进行数据归一化、标准化、特征选择和变换等预处理操作，以便更好地适应建模算法的要求。
（2）特征工程：根据领域知识和数据理解，对原始数据进行特征提取、构造和转换。这包括选择合适的特征、创建新的特征，以及对特征进行编码、缩放和转换等操作，以提高模型的表现和解释能力。
（3）模型选择和建立：根据任务的目标和数据的特征，选择合适的模型类型和算法。常见的模型包括线性回归、决策树、支持向量机、神经网络等。然后使用训练数据对模型进行训练和参数调优，以找到最佳的模型参数。
（4）模型评估和验证：使用测试数据对训练好的模型进行评估和验证，以衡量模型的性能和泛化能力。常用的评估指标包括准确度、精确度、召回率、F1值、ROC曲线等。
（5）模型部署和监控：将训练好的模型部署到实际应用环境中，并建立监控机制，持续跟踪模型的性能和效果，及时进行模型更新和优化。
数据模型的形成是一个迭代和交互的过程，需要不断调整和改进模型，以适应不断变化的数据和任务要求。
1.3 示例-房价预测 假设我们要构建一个房价预测模型。以下是数据和特征如何影响机器学习的上限的例子：
（1） 数据质量：如果我们的数据集包含准确、完整和可信的房屋信息，例如房屋面积、地理位置、房间数量、附近设施等，那么模型可以更准确地学习到房价与这些特征之间的关系。然而，如果数据集中存在错误、缺失值或噪音，模型可能会学到错误的规律或产生不可靠的预测结果。
（2）数据多样性：如果我们的数据集涵盖了不同地区、不同类型和不同价位的房屋样本，模型可以更好地理解房价与这些因素之间的关系。如果数据集过于单一，例如只包含某一地区的房屋数据，那么模型可能无法很好地推广到其他地区的房价预测。
（3）数据规模：如果我们有大规模的房屋数据集，模型可以从中学习到更多的模式和趋势，提高预测的准确性和泛化能力。相比之下，如果数据集规模较小，模型可能无法捕捉到数据中的细微关联，导致预测结果不够准确。
特征工程在房价预测模型中也起着重要的作用：
- 特征选择：通过选择与房价具有高相关性的特征，我们可以减少冗余信息和噪音，提高模型的效果。例如，房屋面积、卧室数量和浴室数量等可能是与房价紧密相关的特征，而与房价无关的特征可以被剔除。
- 特征转换：对于某些特征，我们可以进行转换或组合，以更好地捕捉特征之间的关系。例如，可以计算每个房屋的平均房间面积，或者将房屋的地理位置转换为距离市中心的距离等。
通过优化数据质量、多样性和规模，并进行适当的特征选择和特征工程，我们可以提高房价预测模型的性能和准确性，使其更接近机器学习问题的上限。
2. 数据清洗 2.1 概述 数据清洗是特征工程中的一个重要步骤，涉及到数据样本抽样和异常值处理。下面对这两个方面进行详细说明：
（1）数据样本抽样：
- 数据样本抽样是从整体数据集中选择一个代表性子集的过程。常见的数据样本抽样方法包括随机抽样、分层抽样和集群抽样等。
- 抽样的目的是减少数据量，加快模型训练和评估的速度，同时保持样本的代表性，以避免样本偏差对模型性能的影响。
- 在数据样本抽样过程中，需要考虑抽样方法的合理性和适用性，确保抽样后的样本能够准确地代表整体数据集。
（2）异常值（空值）处理：
- 异常值是指与其他样本明显不同的数据点，可能是由于测量错误、数据损坏或真实的异常情况引起的。空值则表示缺失的数据。
- 异常值和空值的存在可能对模型训练和预测产生负面影响，因此需要进行相应的处理。
- 异常值处理的方法包括删除异常值、替换异常值或将其视为缺失值进行处理。
- 空值处理的方法包括删除含有空值的样本、用均值或中值填充空值、使用插值方法进行填充或利用模型预测空值等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/283ef9a7de5efcae526b6979f619e7bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97465dfd89d8dadb79cd22fa305a30bd/" rel="bookmark">
			Java异常处理的十个建议，希望对大家有帮助~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、尽量不要使用e.printStackTrace(),而是使用log打印。 反例:
try{ // do what you want }catch(Exception e){ e.printStackTrace(); } 正例：
try{ // do what you want }catch(Exception e){ log.info("你的程序有异常啦,{}",e); } 理由：
printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了,即内存满了，那么，用户的请求就卡住啦~ 二、catch了异常，但是没有打印出具体的exception，无法更好定位问题 反例：
try{ // do what you want }catch(Exception e){ log.info("你的程序有异常啦"); } 正例：
try{ // do what you want }catch(Exception e){ log.info("你的程序有异常啦，{}",e); } 理由：
反例中，并没有把exception出来，到时候排查问题就不好查了啦，到底是SQl写错的异常还是IO异常，还是其他呢？所以应该把exception打印到日志中哦~ 三、不要用一个Exception捕捉所有可能的异常 反例：
public void test(){ try{ //…抛出 IOException 的代码调用 //…抛出 SQLException 的代码调用 }catch(Exception e){ //用基类 Exception 捕捉的所有可能的异常，如果多个层次都这样捕捉，会丢失原始异常的有效信息哦 log.info(“Exception in test,exception:{}”, e); } } 正例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97465dfd89d8dadb79cd22fa305a30bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd5a32d6757d20485f7cab60d88ea3b2/" rel="bookmark">
			Robert&#43;Prompt&#43;对比学习&#43;对抗训练文本分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Robert的文本分类任务，在此基础上考虑融合对比学习、Prompt和对抗训练来提升模型的文本分类能力，我本地有SST-2数据集的train.txt、dev.txt两个文件，每个文件包含文本内容和标签两列，是个二分类任务，本项目基于pytorch实现。
先介绍一下要融合的三个技术。
1. 对比学习旨在通过对比相似和不相似的样本来提高分类模型的性能。对于每个样本，我们可以在训练时随机选取一个与其相似的样本，并加入到训练中，以鼓励模型更好地学习相似样本的特征，同时在训练时也要随机选取一个不相似的样本，并将其加入到训练中。这可以帮助模型更好地区分不同类别之间的特征。
2. Prompt是一种基于预设文本片段的模型输入方式。通过给定关键词和语法结构，Prompt可以引导模型学习某些具体任务。在文本分类任务中，我们可以给模型预设一些文本提示，以帮助模型更好地学习关键特征。
3. 对抗训练是一种在训练模型时加入干扰数据（扰动）的技术，以增强模型的鲁棒性。在文本分类任务中，我们可以通过向文本中添加词语或修改词语顺序，来生成干扰数据，从而帮助模型更好地区分和理解输入文本。
目录
一、安装依赖库
二、载数据集并进行数据预处理
三、定义模型并训练模型
四、对比学习实现
五、Prompt实现
六、对抗训练实现
七、整个过程封装成一个函数
一、安装依赖库 下面是具体实现的代码，我们将使用PyTorch框架：
首先安装必要的库：
!pip install transformers !pip install torch !pip install scikit-learn 然后我们导入需要的库以及设置随机种子以保证实验可重复性等必要组件： import random import numpy as np import torch from sklearn.metrics import accuracy_score, f1_score from transformers import RobertaTokenizer, RobertaForSequenceClassification, AdamW from torch.utils.data import Dataset, DataLoader, RandomSampler, SequentialSampler from transformers import get_linear_schedule_with_warmup device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu') random.seed(42) np.random.seed(42) torch.manual_seed(42) torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd5a32d6757d20485f7cab60d88ea3b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/369bb7effc04ccbc3d0054be26090b46/" rel="bookmark">
			torch.cat ( )和 np.concatenate() 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. torch.cat( ) 1. 用法： 按照指定的维度，将两个terson数据拼接在一起；
2. 实例： improt torch A = torch.tensor(np.array([[1,2,3],[4,5,6]])) #2×3的张量 tensor([[1, 2, 3], [4, 5, 6]]) B = torch.tensor(np.array([[7,8],[10,11]])) #2×2的张量 tensor([[ 7, 8], [10, 11]]) C = torch.cat([A, B],dim=1) #按照张量维度1（列）进行拼接，维度变为2×5 tensor([[ 1, 2, 3, 7, 8], [ 4, 5, 6, 10, 11]]) D = torch.tensor(np.array([[2,3,4],[10,11,12],[5,6,7]])) #3×3的张量 tensor([[ 2, 3, 4], [10, 11, 12], [ 5, 6, 7]]) E = torch.cat([A,D], dim=0) #按照张量维度0（行）进行拼接，维度变为5×3 tensor([[ 1, 2, 3], [ 4, 5, 6], [ 2, 3, 4], [10, 11, 12], [ 5, 6, 7]]) 两个张量A和B，分别是2行3列，2行2列。即他们都是2维张量。因为只有两维，这样在用torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/369bb7effc04ccbc3d0054be26090b46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd57b3444ae151d4dcbb033b4ce14a7a/" rel="bookmark">
			pymol 安装、许可证以及报错：pymol not running: entering library mode(experienment)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）报错：
通过pymol：interfaceresidue.py 运行时候出现报错：
pymol not running: entering library mode(experienment) （2）分析原因：
确认Pymol的安装目录是否正确：你需要检查Pymol的安装位置，确保其安装在正确的位置。可以从Pymol的官方网站或其他可靠的来源上下载Pymol的安装程序，并且确保在安装Pymol时，选择正确的安装路径。
检查Pymol的资源文件是否存在：如果Pymol无法找到必要的资源文件，例如pypovray等库文件，就会出现“entering library mode(experienment)”错误。你可以在Pymol的安装目录中查找这些缺失的库文件，并将它们拷贝到Pymol的安装目录中。
检查环境变量是否设置：Pymol需要一些环境变量来支持其正常运行，例如PYTHONPATH和PYMOL_PATH。这些环境变量需要设置正确，以便Pymol能够正确加载所需的库文件和资源文件。你可以使用命令行的set命令来检查这些环境变量是否设置正确。
更新Pymol版本：如果你的Pymol版本过旧，可能会导致“entering library mode(experienment)”错误。在这种情况下，你需要更新到最新版本的Pymol，或者选择一个经过验证的稳定版本。
检查pymol的许可证是否过期
（3）解决：
一pymol许可证获取：
【学习】：PyMOL免费下载及安装教程【Win版】 - 简书 (jianshu.com)
官网：https://pymol.org/2/打开官网，点击DOWNLOAD NOW，选择需要的版本选择保存地址，一路点击next安装 经过1，2步骤安装的PyMOL是没有灵魂的试用版本
此时你需要先有一个邮箱【不限定学校邮箱，亲测163也可以用】
还是官网，点击右侧按钮“BUY LICENSE”
点击“Student/Teacher”
填入各项信息【只要邮箱是真实的就可以，其他都可以随便填填】
填入验证码，等待激活邮件【验证码是下面的图片：
邮件本件，根据网址下载你的注册文件 打开连接之后会让输入账号和密码：对应的就是username，password
下载许可证文件
打开你的PyMOL,在弹出窗口上找到注册licence点击导入上面下载的注册文件即可 二、获得许可证之后发现依旧行不通：
interfaceresidue.py 函数进行修改，增加一个文件workdir参数，运行成功 ps：
conda install -c shrodinger pymol-bundle
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74b1915fd4df55c23976031559450b9d/" rel="bookmark">
			COMSOL这几种常见的数据处理，你都会吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源公众号：COMSOL仿真交流
- COMSOL Multiphysics -
数据集（二）
01
面
三维操作。得到指定解中指定边界面上的结果，保存在数据集中供后续调用。可附加增加选择。
数据
数据集：操作所依托的解，可从下拉列表的解中选择所需的解。
参数化
x-和y-轴：指定被选中的面中局部x和y轴的坐标轴方向。缺省为面参数，表示依据被选中边界面的坐标轴方向确定。可从下拉列表中选择xy平面，yz平面，zx平面以及表达式(以表达式指定坐标轴方向)。
本项设定用来确定显示结果时图象的取向。
选择：选择指定的边界面，缺省为手动，可修改为全部。
02
等值线
二维操作。与等值面的操作类似，本操作用来根据指定的解生成等值线数据，保存到数据集中供后续调用。
03
二维切割线
二维操作。与三维切割线类似，基于指定的二维解，得到指定切割线上的结果，保存到数据集中供后续调用。
04
二维切割点
二维操作。与三维切割点操作类似，基于指定的二维解，得到指定点上的结果，保存到数据集中供后续调用。
05
二维边
二维操作。与三维边类似，基于指定的二维解，得到指定边上的结果，保存到数据集中供后续调用。可附加增加选择。
06
二维镜像
二维操作。与三维镜像类似，基于指定的二维解，得到镜像结果，保存到数据集中供后续调用。
07
二维参数化拉伸
二维操作。将二维解进行参数化的变化，得到三维的结果，保存到数据集中供后续调用。
数据
数据集：操作所依托的解，可从下拉列表的解中选择所需的解。
设定
等级比例因子:缺省不勾选，可以勾选后输入比例因子。
分离层数：缺省为勾选。
08
二维参数化曲线
二维操作。与三维参数化曲线类似，基于指定的二维解，得到指定的参数化曲线上的结果，保存到数据集中供后续调用。
09
二维旋转
二维操作。将二维轴对称模型的计算结果，经过旋转后得到三维的结果，保存到数据集中供后续调用。
本操作常用于简化建模，对于某些旋转对称性很好的结构，简化为二维轴对称结构进行计算，后处理则采用旋转得到三维的显示结果。
数据
数据集：操作所依托的解，可从下拉列表的解中选择所需的解。
轴数据
轴定义方法：定义旋转轴，缺省为两点，即由两点来确定直线。可修改为点和方向，即指定一个基准点和方向矢量，决定一条线。
注意：旋转轴必须在当前的二维结构之外，即不能在旋转时出现重叠现象。
旋转层
层：旋转的解析度，即在圆周上取多少个数据点，点越多，显示越精细，但计算量和存储空间越大。
旋转角：旋转多少度，缺省为一个圆周360度。
高级
定义变量：缺省为不勾选，程序自动给旋转的坐标轴定义名称。可以勾选，输入自定义名称。
10
一维切割点
一维操作。与三维切割点和二维切割点类似，在一维解中得到指定点的结果，保存到数据集中供后续调用。
11
一维参数拉伸
一维操作。与二维参数拉伸类似，将一维解拉伸得到二维解，保存到数据集中供后续调用。
12
一维旋转
一维操作。与二维旋转类似，将一维轴对称结果经过旋转后得到二维结果，保存到数据集中供后续操作调用。
13
计算
1、积分
用于在指定解的基础上进行积分计算，将结果保存在数据集中，供后续调用。常用于后处理某些对象上的积分结果等。可附加选择。
数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74b1915fd4df55c23976031559450b9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef156de1946a63cdd9b0ca4db2114fd7/" rel="bookmark">
			设计模式之抽象工厂设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.介绍 抽象工厂模式是一种软件设计模式，它提供了一种创建一系列相关或依赖对象的方式，而无需指定具体类。它将抽象工厂和具体工厂的实现分离开来，使得客户端和工厂的实现分离开来。该模式使得系统更具有灵活性和可扩展性，能够从更高的层面来管理对象的创建。
在抽象工厂模式中，抽象工厂定义了创建一系列相关对象的接口，每个具体工厂则实现了这些接口并负责创建相应的具体对象。这些具体工厂类应该能够创建与其主题相关的对象，并且应该具有相同的接口以便于客户端调用。客户端只需要知道抽象工厂提供的接口，并且不需要知道具体的实现。
抽象工厂模式常用于需要创建一组相关对象的情况，比如需要创建一组具有相同主题的界面元素。相比于简单工厂模式，抽象工厂模式更加抽象化和灵活，也更加复杂。
2.解决问题 抽象工厂模式主要解决的问题是一个系统需要一些有关联的产品对象，这些对象之间有一定的约束关系，不仅需要创建这些对象，而且需要保证它们之间的约束关系正确。
在这种情况下，使用抽象工厂模式可以将这些对象的创建过程分离出来，使得客户端不需要直接面对对象创建的复杂性，也不需要了解这些对象之间的约束关系。客户端只需要向抽象工厂对象发出请求，抽象工厂再负责创建符合约束关系的对象。
同时，抽象工厂模式还可以让系统更加灵活。例如，如果需要添加一种新的产品对象或者更改产品对象的约束关系，只需要实现一个新的具体工厂即可，而不需要修改客户端的代码。
总之，抽象工厂模式可以有效地解决多个相关对象的创建问题，并且可以让系统更加灵活、可扩展，使得客户端使用起来更加方便。
废话不多说，开整~
1.创建一个水果类和产地接口
/** * @Author: mark * @Description: 水果接口 * @Date: 2023/06/08/10:06 * @Version: 1.0 */ public interface Fruit { void choice(); } /** * @Author: mark * @Description: 产地接口 * @Date: 2023/06/08/10:12 * @Version: 1.0 */ public interface Place { void placeIn(); } 2.并各自实现水果和产地接口
/** * @Author: mark * @Description: TODO * @Date: 2023/06/08/10:08 * @Version: 1.0 */ public class Apple implements Fruit { @Override public void choice() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef156de1946a63cdd9b0ca4db2114fd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f093ca48ed16fbb282f43f234d5c0b2e/" rel="bookmark">
			正点原子IMX6ULL阿尔法开发板点亮LED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、准备工作
二、编写程序，使得LED能让我们控制
三、开发板上运行可执行程序
四、作者自述
一、准备工作 1.开发板为出厂时的镜像时不需要进行修改
2.开发板不为出厂时的镜像时需要进行修改，改回原来的系统镜像。
(1)官网下载LINUX阿尔法A盘资料
(2)找到开发工具
(2) 进入到【正点原子】阿尔法Linux开发板（A盘）-基础资料(1)\05、开发工具\04、正点原子MFG_TOOL出厂固件烧录工具\mfgtool目录下双击运行Mfgtool2-eMMC-ddr512-eMMC.vbs烧写原来的系统镜像：如下所示
tips：根据自己开发板是ddr大小和烧写的去向做选择，我这里使用的时emmc版本，ddr为512,所以我选择上述工具。
(3)数据线连接OTG接口，拨码开关拨到USB启动，出现如下所示方为正常，即可点击下载
tips：镜像烧录过程中会出现短暂识别不到USB，这为正常现象，静静等待烧录完成即可。
(4)镜像烧写完成标志，如下所示：
(5)将拨码开关重新拨到emmc启动，重启开发板即可，出现以下信息为进入系统成功。
二、编写程序，使得LED能让我们控制 1.程序代码如下:
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/stat.h&gt; #include &lt;sys/types.h&gt; //触发方式 #define LED_TRIGGER "/sys/class/leds/sys-led/trigger" //亮度等级 #define LED_BRIGHTNESS "/sys/class/leds/sys-led/brightness" #define USAGE() fprintf(stderr,"usage:\n"" %s&lt;on|off&gt;\n"" %s&lt;trigger&gt;&lt;type&gt;\n",\ argv[0],argv[0]) int main(int argc,char* argv[]) { int fd1,fd2,ret; //检验传参 if(argc &lt; 2) { USAGE(); exit(-1); } //打开文件 fd1 = open(LED_TRIGGER,O_RDWR); if(fd1 == -1) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f093ca48ed16fbb282f43f234d5c0b2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/822e103162a87a671e025e3fdf219b95/" rel="bookmark">
			springboot整合quartz实现定时任务动态增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot整合quartz quartz介绍Quartz 核心概念 使用依赖配置文件启动类quartz工具类job业务用到的对象类接口service实现类测试 quartz介绍 Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，它可以与J2EE与J2SE应用程序相结合也可以单独使用。Quartz可以用来创建简单或为运行十个，百个，甚至是好几万个Jobs这样复杂的程序。Jobs可以做成标准的Java组件或 EJBs。Quartz的最新版本为Quartz 2.3.2。
中文官方文档：https://www.w3cschool.cn/quartz_doc/
Quartz 核心概念 1.Job 表示一个工作，要执行的具体内容。
2.JobDetail 表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。
3.Trigger 代表一个调度参数的配置，什么时候去调。
4.Scheduler 代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。
使用 依赖 springboot整合quartz依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt; pom文件
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.5.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/822e103162a87a671e025e3fdf219b95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/294d0b73b77554532af4795f95c5b12a/" rel="bookmark">
			自动化测试面试真题（附答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、编程语法题 1 、 python 有哪些数据类型 python 数据类型有很多，基本数据类型有整型（数字）、字符串、元组、列表、 字典和布尔类型等 2 、怎么将两个字典合并 调用字典的 update 方法，合并 2 个字典。 3 、 json.l python 如何将 json 写到文件里？ oads（） 是将字符串传化为字典 json.load()是将文件打开从字符串转换成数据类型 json.dumps (） 是将字典转化为字符串 json.dump()是将数据类型转换成字符串并存储在文件中 4 、 __init__ 和 __new__ 区别？ ·__new__是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该 实例对象，是个静态方法。 · __init__是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值， 通常用在初始化一个类实例的时候。是一个实例方法。 5 、什么是可变、不可变类型？ ·可变数据类型：列表 list 和字典 dict； ·不可变数据类型：整型 int、浮点型 float、字符串型 string 和元组 tuple 6 、 mysql 注入点，用工具对目标站直接写入一句话，需要哪些条件？ mysql 写入一句话需要具备 1.secure-file-priv=''，即：my.ini 文件，打开找到 secure-file-priv 参数 改空 2.当前用户具备 root 权限 3.已获取到应用程序的绝对路径，且目录可以进行文件写入操作。 7 、 python 深浅拷贝的区别 对于不可变数据来说深浅拷贝的结果一致会重新创一个数据的副本。浅拷贝对于 可变类型来说只会拷贝其元素的引用。 深拷贝对于可变元素来说会递归的整个重新创建一个原数据的副本。 8 、 python 为什么使用 *args 和 **kwargs 如果我们不确定要往函数中传入多少个参数，或者我们想往函数中以列表和元组 的形式传参数时，那就使要用*args；如果我们不知道要往函数中传入多少个关 键词参数，或者想传入字典的值作为关键词参数时，那就要使用**kwargs。args 和 kwargs 这两个标识符是约定俗成的用法，你当然还可以用*bob 和**billy， 但是这样就不太专业。 9 、重写和重载有什么区别？ 重写：用在类的继承当中。子类对父类的同名方法，进新重写。在子类同名方法 内部，如果要延用父类的方法，可以使用 super 调用。 重载：用在类当中，对于同一个方法名，支持不同类型的参数，支持不同数量的 参数。由于 python 的函数本身就对参数不作类型限定，也有*args 和**kwargs 支持不定长参数。 10 、 python 实现 get 数据库的表？你是怎么实现的？ python 当中对于不同数据库，都有不同的第三库来实现连接和数据库操作。 比较熟悉的是对 mysql 的操作。使用的是 pymysql 这个第三方库。第一步是建立 数 据 库 连 接 ； 第 二 步 调 用 execute 方 法 执 行 sql 语 句 ， 第 三 步 使 用 fetchone,fetchall,fetchmany 去获取不同条数的结果。 11 、对象 ( 实例 ) 方法，类方法，静态方法的定义有何不同？分别适用于什么场 景？ python 中，类中定义的普通函数就是对象方法，对象方法中的第一个形参一般 会定义为`self`，表示调用的对象本身，当对象调用对象方法时会被隐式的传递 给这个形参。所以当函数需要用到对象或对象的属性时一般会将其定义为对象方 法。 类方法定义时，需要使用装饰器`classmethod`进行装饰，类方法中的第一个形 参一般会定义为`cls`，表示类本身。当对象调用或类调用类方法时，类会被隐 式的传递给这个形参。所以当函数需要用到类或者类的属性时一般会将其定义为 类方法。 静态方法定义时，需要使用装饰器`staticmethod`进行装饰，其他与普通函数没 有区别。一般会将一些与对象和类无关的工具函数定义为静态方法，方便调用。 12 、 SQL 连表查询，去重查询，查询重复的数据？ 连表查询：SELECT 字段 1,字段 2,字段 3,…… FROM 表名 1 INNER JOIN 表名 2 ON 关联条件； 去重查询：SELECT distinct .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/294d0b73b77554532af4795f95c5b12a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e288fb2dc42769a8c84a2e4b3829ef06/" rel="bookmark">
			DNS劫持原理，DNS劫持如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DNS劫持是网络十分常见和凶猛的一种攻击手段，且不轻易被人察觉。曾导致巴西比较大银行巴西银行近1%客户受到攻击而导致账户被盗，黑客们利用缺陷对用户的DNS进行篡改，成功后可躲过安全软件检测，让用户被钓鱼网站诈骗。今天我和你们分享几个DNS被劫持的解决方案，希望可以帮助到你~
一、手动修改DNS服务器地址
1、打开开始菜单 找到并打开【控制面板】，在控制面板找到【网络和共享中心】
打开网络和共享中心页面后找到【本地连接/以太网】，点击打开属性设置 点击【属性】，在属性设置页面找到Internet 协议版本（TCP/IPv4），选择IPv4然后点击【属性】 3.进入IPv4属性设置，使用下面的DNS服务器地址：114.114.114.114, 备用DNS服务器：114.114.155.155，使用其他的DNS服务器地址也是可以的，之前有分享几个常用的DNS服务器地址可以参考一下
使用360安全卫士进行DNS优选 在360安全卫士-功能大全里找到系统工具【DNS优选】 添加工具后会自动打开DNS优选，操作很简单，直接点击【开始DNS优选】 3.经过360卫士的检测，会根据你的网络环境，推荐两个高质量的DNS服务器，点击【立即启用】即可完成DNS设置 关于DNS劫持的解决方法今天就分享到这了
感谢您的阅读，喜欢加个关注吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e71d371e03c5863b1d643b87fdd39eb6/" rel="bookmark">
			在线投票系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 随着全球互联网的快速发展和计算机应用的广泛普及，特别是无线网络的广泛覆盖和无线终端设备的爆炸性增长，人们现在可以随时随地访问网络，获取最新信息、参与网络活动和与他人在线互动。为了及时了解民意和关注点，政府机构和门户网站等单位现在会将一些热点话题以投票的形式发布在网站上供人们在线投票。因此，在线投票系统应运而生。
本文主要讨论了在线投票系统的设计和实现过程。首先，基于实际应用开发情况，对该系统进行了详细的需求分析。然后，分析了该系统的结构和各功能模块，并通过详细的数据库表设计构建出一个基于Web的、以SSM框架和MySQL数据库为基础的、具有管理员登录管理、投票话题设置管理、话题库生成管理、在线网络投票和投票结果管理等功能的在线投票系统。
本文系统地阐述了基于Web的在线投票系统的分析、设计和实现过程，介绍了相关的理论知识。最后，对系统进行了全面的功能测试，总结了其优点和不足之处，并提出了几点改进建议，展望了该应用的前景。
关键词：在线投票系统；需求分析；SSM框架；
3.1 系统设计目标
设计并开发一个基于Java的在线投票系统，包括用户管理、投票管理、统计分析等模块。实现用户的注册、登录、个人信息管理等功能，确保用户信息的隐私和准确性。实现投票的创建、编辑、删除等功能，确保投票信息的完整性和准确性。实现投票流程控制，包括投票的开始、结束、延期等功能，确保投票的公平性和透明度。实现投票的计数和数据分析功能，包括投票的参与度、最受欢迎的选项、投票结果等指标，为系统运营提供数据支持。实现系统的稳定性和安全性，包括数据备份、系统监控、异常处理等功能，确保系统的可靠性和可用性。对系统进行性能测试和优化，确保系统的响应速度和并发能力。提供友好的用户界面和操作体验，提高用户满意度和使用体验。
3.2 系统的可行性分析
（1）技术可行性
在线投票的系统设计选择了IntelliJ IDEA作为开发平台，采用主流的SSM框架作为开发框架，MySQL作为数据库，开发了这个在线投票系统，该系统技术上使用HTML+CSS，编程语言是JAVA语言进行开发。技术上这几种语言已经非常完善和成熟了，是能够很好地完成在线投票系统技术上的开发，技术方面的可行度还是相当高的。[9]由于在线投票系统的实现是对硬件的要求相当低的，并且相对于现如今人们所使用的计算机均可满足使用，所以在当前技术上考虑该系统开发是可行性的。
（2）操作可行性分析
随着计算机的普及和生活水平的提高，如今基本人手一台笔记本电脑，而该系统几乎现如今所有的电脑都能运行，同时在不同机型的笔记本上均不会改变它的设置和布局，在线投票系统使用B/S架构，基于浏览器的设计模式，系统对于管理人员的计算机水平要求并不高。[10]简洁的图形操作界面，清晰明了的布局，让用户几乎不需要太多的理解成本，简单地说明指导后，用户就可以十分方便快捷进行使用操作。所以在操作上考虑该系统开发是可行的[11]。
（3）经济可行性分析
在线投票系统的开发过程中所使用的IntelliJ IDEA、MySQL、Tomcat这些都是开源免费的软件，成本非常低，其系统运行对设备配置的要求也不算太高，用自己的电脑就可以完成，所以开发成本非常低。而且该系统极大地提高了教学完整度[12]。因此从经济方面考虑该系统开发是可行的。
3.3 需求分析
3.3.1 用户需求分析
本设计是在线投票系统，主要是通过用户和投票者实现投票项目的发起和投票的展开，然后研究开发出一个在线投票系统，该投票系统在投票的管理模块里，管理员可以设置当前投票的主题、添加投票主题、删除投票的主题、修改投票、管理投票的相关信息等。在投票功能模块里可以实现用户投票、显示投票的结果、统计投票的数量等，还可以对用户的投票数量进行限制，用户投完票后还可以对其进行留言等操作。
3.3.2 功能需求分析
通过对在线投票系统进行了全面的调查，以及在分析的基础上制定出了在线投票系统的系统总体的规划。系统功能模块包括有：用户模块、投票者模块、管理员模块。用户模块：该模块用于管理系统的注册、登录、修改密码等功能。具体功能包括：
（1）用户注册：用户可以进行注册并填写个人信息。注册信息包括用户名、密码、电子邮箱等必填项。注册成功后系统会自动向用户的邮箱发送一封确认邮件，用户需要根据邮件内容进行验证并激活账号。
（2）用户登录：已注册的用户可以使用用户名和密码进行登录，登录成功后可以进行下一步操作。
（3）修改密码：用户可以在登录后进行密码的修改，需要输入旧密码和新密码两次进行确认。
投票者模块：该模块用于管理投票者的投票、查看投票结果等功能。具体内容包括：
（1）投票功能：投票者可以在投票选项中进行选择并进行投票，投票后可以查看当前的投票结果。
（2）查看投票结果：投票者可以查看当前投票选项的投票结果，了解当前的投票情况。
管理员模块：该模块用于管理整个系统的后台管理，包括用户管理、投票管理、在线留言管理、论坛区管理、系统配置等功能。具体内容包括：
（1）用户管理：管理员可以对注册用户进行管理，包括用户信息的修改、删除等操作。
（2）投票管理：管理员可以对系统中的投票进行管理，包括投票选项的添加、修改、删除等操作。
（3）系统配置：管理员可以对系统进行配置，包括网站名称、网站LOGO、SEO信息等设置。同时还可以设置投票规则、参与者身份等其他参数。
管理员登录成功，进入系统后，管理员的功能有个人中心、投票者的管理、用户的管理、投票主题的管理、投票信息的管理、投票结果的管理、在线留言、论坛区、系统管理等功能。管理员用例图如图1所示
图 3-1管理员用例图
用户登录成功进入系统后，可以使用个人中心、投票信息管理、投票结果管理。用户用例图如图3-2所示。
图 3-2 用户用例图
投票者成功登录，进入系统后，投票者可以使用的功能有：个人中心、投票信息管理、投票结果管理。投票者用例图如图3-3所示。
图 3-3 投票者用例图
管理员管理投票流程图如3-3-4所示
图3-3-4管理员管理投票流程图
4.1 系统功能模块设计
本文的软件设计目标是建立一个在线投票系统，该系统需要满足用户对系统功能的需求，同时也要保证系统和使用者之间具有良好的互动。为此，我们采用了模块化设计理念，将整个系统划分为多个相对独立又相互关联的子项目，每个项目都有相应的接口与之相连。这样的设计可以保证系统的安全性和稳定性，同时提高用户的使用体验。
在这个体系结构下，我们将每个功能都做了细致的划分，并从功能、接口以及逻辑等方面进行了细致解剖。通过这样的设计，可以将一堆作品分解成若干个小块，每个小块包含着大量的细节内容。将这些细枝末节处理好了，一切都将变得完满起来。
通过模块化设计，可以对系统软件进行扩展，面向管理员对管理方案进行模块扩展。例如在在线投票系统中，我们设计了投票者和管理员两种角色，每个角色拥有不同的功能模块。这样的设计可以帮助管理员根据需要进行操作、调整和维护，并最终根据需要完成任务，系统的功能结构图如图4.1所示。
图4-1系统的功能结构图
5.1登录
系统内的管理员或者普通用户进入系统都需要通过账号密码输入进行登录，用户根据自己的角色进行选择同时输入正确的账号和密码即可进入系统，实现界面见图5-1。
图5-1 登录界面
登录页面实现代码如下：
5.2 管理员功能模块
管理员可以查看用户和投票者的账户信息，管理员还可以对用户的账号信息进行添加、删除、修改、查询。该模块功能实现了后台用户的登录功能，不同的用户对应的角色是不同的，同理不同的角色对应的权限也是不同的，系统管理员可以对角色进行修改。角色管理界面如图5-2，5-3所示。
图 5-2投票者管理界面
图5-3用户管理界面
注：展示部分文档内容和系统截图，需要完整的视频、代码、文章和安装调试环境请私信up主。
目 录 摘 要 Abstract 目 录 第1章 绪 论 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e71d371e03c5863b1d643b87fdd39eb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ffc5e50e4fe54570596dd24a04b1e87/" rel="bookmark">
			前端面试官：介绍一下less和scss，以及他们的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 LessSCSSscss和less的区别 Less Less是一种CSS预处理器，它扩展了纯CSS的功能，提供了更多的功能和灵活性。Less语法与常规CSS语法非常相似，但引入了一些新的特性和语法规则，使得样式表的编写更加简洁和可维护。
以下是一些Less语法的特点和用法：
变量（Variables）：你可以使用@符号来定义和引用变量。例如，@primary-color: #ff0000;定义了一个名为primary-color的变量，并将其设置为红色。
嵌套（Nesting）：你可以在Less中使用嵌套规则来组织样式规则。这意味着你可以将相关的样式规则放在一个父选择器下。例如：
.container { width: 100%; .heading { font-size: 20px; color: #333; } } 这样生成的CSS代码将包含.container和.container .heading两个选择器的样式规则。
混合（Mixins）：混合是一种将一组样式规则集合起来并在需要时进行重用的机制。你可以使用.mixin-name()来定义混合，并使用.mixin-name;来引用它。例如：
.bordered { border: 1px solid #ccc; } .button { .bordered(); background-color: #f00; color: #fff; } .button选择器将继承.bordered混合的样式规则。
运算（Operations）：Less允许你在样式中执行简单的算术运算，如加法、减法、乘法和除法。例如：
@base-padding: 10px; .box { padding: @base-padding * 2; } 这样，.box的padding将计算为20px。
导入（Import）：你可以使用@import指令将其他的Less文件导入到当前文件中。这样可以将样式分为多个文件，并在需要时将它们合并到一个文件中。例如：
@import "variables.less"; @import "mixins.less"; /* 样式规则 */ 这样，variables.less和mixins.less中的样式将被导入到当前文件中。
这只是Less语法的一些基本特点和用法。它还提供了许多其他功能，如嵌套规则的选择器操作、颜色函数、循环等，以帮助开发者更方便地编写和维护样式表。要使用Less，你需要将Less文件编译为普通的CSS文件，然后将其引入到HTML中。
SCSS SCSS（Sassy CSS）是一种CSS预处理器，它是CSS的扩展，允许开发者使用更灵活、可维护和可扩展的方式编写样式表。
下面是一些SCSS的特性和用法：
变量（Variables）：SCSS引入了变量的概念，你可以使用$符号定义变量，并在整个样式表中引用它们。例如：
$primary-color: #ff0000; .container { background-color: $primary-color; } 这样可以更方便地管理和调整颜色、字体等样式属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ffc5e50e4fe54570596dd24a04b1e87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea73a900b8558f993d9d058d9feadf5/" rel="bookmark">
			PowerShell系列（六）：PowerShell脚本执行策略梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、执行策略等级
2、执行策略范围
3、执行策略命令语法格式
4、执行策略常用命令
PowerShell 是一种用于操作 系统的命令行界面，支持跨平台，它提供了许多功能来自动化和优化各种任务。PowerShell 是由微软官方开发的，并作为 Windows Server 操作系统的一部分提供。 使用 PowerShell，您可以执行许多运维操作，例如创建、编辑、查看和删除文件和文件夹，管理用户和计算机，配置网络设置，运行系统命令，自动化测试和部署等。今天继续给大家分享PowerShell系列教程。
上一篇文章讲解了PowerShell通过脚本方式运行笔记的相关知识，今天给大家介绍PowerShell脚本执行策略相关的知识，了解微软推出的PowerShell如何来保护运行脚本的安全。
PowerShell 脚本执行策略用于控制何时以及何种方式执行 PowerShell 脚本。通过执行策略可以限制 PowerShell 脚本的执行范围，为系统管理员提供一定的安全保障。策略可以限制执行脚本的用户、限制执行脚本的来源等等。这些策略可以在计算机本地或组策略中进行配置。最终保护计算机免受恶意脚本和非法操作的侵害。
今天给大家讲解PowerShell脚本执行策略相关的知识！
1、执行策略等级 AllSigned：要求所有脚本和配置文件都由受信任的发布者签名，包括在本地计算机上编写的脚本；从尚未分类为受信任或不受信任的发布者运行脚本之前，需要确认是否执行。Bypass：脚本执行没有任何限制RemoteSigned：本地计算机上的本地脚本，不需要数字签名直接允许；从Internet或其他计算机下载的脚本，需要脚本必须经过数字签名才能运行。Restricted：允许单个命令，但不允许脚本，它会阻止运行所有脚本文件。Undefined:当前范围没有执行策略。简单来说如果所有范围的执行策略都是Undefined的话，实际使用的测试和Default策略保持一致。Default：默认执行策略，Window客户端为Restricted；Windows服务器为RemoteSigned 。Unrestricted：脚本运行不受签名限制，如果脚本不来自本地 Intranet 区域的脚本和配置文件，运行之前会有警告 2、执行策略范围 MachinePolicy：由组策略为计算机的所有用户设置UserPolicy：由计算机当前用户的组策略设置Process：范围 Process 仅影响当前 PowerShell 会话;执行策略保存在环境变量 $env:PSExecutionPolicyPreference中，而不是注册表中。 关闭 PowerShell 会话时，变量和值将被删除。CurrentUser：执行策略仅影响当前用户。 它存储在 HKEY_CURRENT_USER 注册表子项中。LocalMachine：执行策略会影响当前计算机上的所有用户。 它存储在 HKEY_LOCAL_MACHINE 注册表子项中。 3、执行策略命令语法格式 Set-ExecutionPolicy [-ExecutionPolicy] [[-Scope] ] [-Force] [-WhatIf] [-Confirm] [] 参数说明：
-ExecutionPolicy ：指定执行策略-Scope：指定受执行策略影响的范围。 默认作用域为 LocalMachine。-Force：调整所有脚本提示，建议谨慎使用该参数。默认值为 None，可以指定为 False-WhatIf：显示运行该 cmdlet 时会发生什么情况。默认值为False。-Confirm：提示你在运行 cmdlet 之前进行确认。默认值是False。 4、执行策略常用命令 获取当前执行策略
Get-ExecutionPolicy 获取影响当前会话的所有执行策略
Get-ExecutionPolicy -List 调整脚本执行策略
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eea73a900b8558f993d9d058d9feadf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd7db665f34f952a0c110f241037f97e/" rel="bookmark">
			MindOpt Tuner调参器，提升求解速度、性能（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MindOpt Tuner是达摩院决策智能实验室基于mindopt优化求解器研发的调参器，超参自动优化工具，它可以帮助运筹优化工程师在使用求解器时自动搜索最佳参数组合，尝试不同的参数组合，评估每组参数的性能，然后基于这些结果来确定最佳参数。这样可以大大减少手动调整参数的时间和精力，并且可以帮助提升求解性能。
Python调用 上一篇中讲解了如何使用命令行来调用和查询结果。里面的接口都有封装为Python接口，我们可以输入如下指令引入文件，也可以再输入help指令来查看对应的Python API说明：
import mtunerpy as mtuner #help(mtuner) OpenBLAS WARNING - could not determine the L2 cache size on this system, assuming 256k 这里我们可以如下方式来提交任务：
scenario_dict = { 'solver': 'cbc', 'problem': ['./model/nl_train_1.nl'], 'max_tuning_time': 600 } mtuner.create_task(scenario_dict) Problem file "nl_train_1.nl" uploaded successfully. Task #438397484918644736 created succesfully. 这里小编得到任务ID：438394637284024320。
类似地，我们还可以提交一组优化问题算例mps_train_oss.txt进行调参。
如下，得到任务ID 438394766997069824。
scenario_dict = { 'solver': 'cbc', 'problem': ['./model/mps_train_oss.txt'], 'max_tuning_time': 3600 } mtuner.create_task(scenario_dict) Task #438397553394851840 created succesfully. 运行成功后，我们可以通过如下方式获取结果。可以看到和命令行的结果一样，都可以得到比较多的求解效率提升。
import mtunerpy as mtuner #print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd7db665f34f952a0c110f241037f97e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aecd960a3cead9164ad5173d5afaf4e/" rel="bookmark">
			怎么在C盘之外的安装WSL - 以Ubuntu20.04为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本文中，我们将在Windows的非系统盘上安装WSL，在这里我们用Ubuntu20.04的安装为例。我们也可以用这种方式安装其他Linux的发行版或内核，比如Ubuntu 18和Debian。
大多数时候，我们都是通过微软商店安装WSL的各个发行版本。这些子系统都会被安装在：
%USERPROFILE%\AppData\Local\Packages\ 由于WSL的机制，通常会在我们硬盘上占用大量空间，即使他实际上没使用那么多。这时，我们就需要将WSL安装在非系统盘上。ps. 虽然SSD可以不用分区，但是为了文件管理方便我通常还是会分区，另外我有额外加装更大的SSD，因此我这样的比较需要将WSL安装到这张额外的SSD上。
准备：我们需要以管理员身份运行PowerShell。下面的命令都将在这之上运行。
步骤一：开启WSL（Windows Subsystem for Linux） 运行命令如下：
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 步骤二：开启虚拟机功能 命令：
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 步骤三：下载分发包 这里下载的是Ubuntu20.04，需要下载其他的版本，替换https://aka.ms/wslubuntu2004为对应的链接即可。
Invoke-WebRequest -Uri https://aka.ms/wslubuntu2004 -OutFile Ubuntu.appx -UseBasicParsing 其他分发包下载链接：
Ubuntu 20.04 — https://aka.ms/wslubuntu2004Ubuntu 20.04 ARM — https://aka.ms/wslubuntu2004armUbuntu 18.04 — https://aka.ms/wsl-ubuntu-1804Ubuntu 18.04 ARM — https://aka.ms/wsl-ubuntu-1804-armUbuntu 16.04 — https://aka.ms/wsl-ubuntu-1604Debian GNU/Linux — https://aka.ms/wsl-debian-gnulinuxKali Linux — https://aka.ms/wsl-kali-linux-newOpenSUSE Leap 42 — https://aka.ms/wsl-opensuse-42SLES — https://aka.ms/wsl-sles-12 步骤四：解压缩包 这一步分为四小步，请依次运行。
1. 重命名并解压 重命名 move .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aecd960a3cead9164ad5173d5afaf4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dac6835ec7bb4d12864f3cb2cb9c5635/" rel="bookmark">
			python的plotly图形库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Plotly是一个Python可视化库，它可以用于制作交互式图表、图形和可视化。Plotly支持多种类型的图表，如线图、散点图、条形图、直方图、饼图、3D图等。
import plotly.graph_objs as go
import plotly.offline as pyo
import numpy as np
生成一些示例数据 x = np.linspace(0, 10, 100)
y = np.sin(x)
创建数据轨迹 trace = go.Scatter(x=x, y=y, mode=“lines”)
创建图表布局 layout = go.Layout(title=“Sin Wave”, xaxis=dict(title=“x”), yaxis=dict(title=“y”))
创建图表对象 fig = go.Figure(data=[trace], layout=layout)
在浏览器中显示图表 pyo.plot(fig, filename=“sin_wave.html”)
在上面的代码中，我们使用NumPy生成一些示例数据，并使用go.Scatter创建数据轨迹。然后，我们使用go.Layout创建图表布局，设置了标题、x轴标签和y轴标签。最后，我们使用go.Figure创建图表对象，将数据轨迹和布局传递给它。最后，我们使用pyo.plot在浏览器中显示图表，并将它保存到sin_wave.html文件中。
数据轨迹（trace）是Plotly中最重要的概念之一，它表示数据的可视化形式。数据轨迹是由一系列的点或线条组成，可以表示为线图、散点图、条形图、直方图等。在Plotly中，数据轨迹由plotly.graph_objs中的对象表示，包括Scatter、Bar、Heatmap等。每个数据轨迹可以具有不同的颜色、样式、大小等属性，以便更好地区分和显示数据。同时，Plotly还支持多个数据轨迹的叠加，以便进行比较和分析。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/804104399e1098b7f221c7ae61f85b61/" rel="bookmark">
			轻量级网络MobileNeXt--改进MobileNet v2的逆残差结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文地址：ECCV 2020
《MobileNeXt: Rethinking Bottleneck Structure for Efficient Mobile Network Design》
要点 论文针对MobileNetV2的核心模块逆残差结构存在的问题进行了深入分析，提出了一种新颖的SandGlass模块，并用于组建了该文的MobileNeXt架构，SandGlass是一种通用的模块，它可以轻易的嵌入到现有网络架构中并提升模型性能，这种轻量级模块有原生残差块和倒置残差块的影子，是一种正向残差设计。
回顾
ResNet 使用标准卷积提取特征，MobileNet 始终使用DW卷积提取特征。
ResNet 先降维、卷积、再升维，而 MobileNet V2 则是 先升维、卷积、再降维。
直观上看，ResNet 的微结构是沙漏形，而 MobileNet V2 则是纺锤形。
因此作者将 的结构称为 Inverted Residual Block。这么做也是因为使用DW卷积而作的适配，希望特征提取能够在高维进行。
如下图所示，左侧是ResNet网络中的残差结构（中间窄两头宽），右侧就是MobileNet v2中的逆残差结构（中间宽两头窄）。
在残差结构中是1x1卷积降维-&gt;3x3卷积提取特征-&gt;1x1卷积升维，在逆残差结构中正好相反，是1x1卷积升维-&gt;3x3DW卷积提取特征-&gt;1x1卷积降维。 MobileNet V2 的解释是高维信息通过ReLU激活函数后丢失的信息更少。
下图为ResNet, MobileNetV2和论文提出的MobileNeXt的对比：
ResNet残差块组成：1x1卷积（降维）、3x3卷积（空间信息特征提取）、1x1卷积（升维）；
MobileNetV2倒置残差块组成：1x1卷积（升维）、3x3深度可分卷积（空间信息特征提取）、1x1卷积（降维）；
MobileNeXt沙漏残差块组成：3x3深度可分卷积（空间信息特征提取）、1x1卷积（降维）、1x1卷积（升维）、3x3深度可分卷积（空间信息特征提取），该结构与正向残差类似，区别在于使用了深度卷积；
问题 ResNet残差块中间的3*3卷积的参数量和计算量都非常大，不适用于轻量级网络；
MobileNetV2的Inverted residual block，专为移动设备设计，为了节省计算量，输入改为低维度特征，先通过pointwise卷积扩大维度，然后通过depthwise卷积提取特征，最后通过pointwise卷积降低维度输出；skip path仅建立在低维度bottleneck间，最后一个pointwise卷积不使用非线性激活；
尽管Inverted residual block性能不错：
但输入需要将特征先降到较低的维度，但是降低维度可能不足以保留足够的有用信息；
近期有研究发现更宽的网络结构（输入输出通道数更多）有助于缓解梯度混淆（特指梯度消失与梯度爆炸，不同batch产生的梯度抵消），能够提升网络性能；
shortcut建立在bottleneck之间，由于bottleneck维度较少，也可能会阻碍梯度的回传。
为解决上述问题，论文提出了设计更优的sandglass block，结构如图3(c)，基于此搭建了MobileNeXt，在性能和计算量上都优于MobileNetV2。
亮点 考虑到上述逆残差模块存在的问题，论文作者的设计原则：
保持更多的信息从bottom传递给top层，进而有助于梯度回传；
深度卷积是一种轻量型单元，可以执行两次深度卷积以编码更多的空间信息。
作者重新思考移动网络的bottleneck结构，发现inverted residual并不是最优的bottleneck结构。
研究发现，shortcut应该建立在高维度特征上，depthwise卷积应该应用在高维度特征空间上学习更多样特征，linear residual是bottleneck结构的关键。
sandglass block 如下图所示：(a) Residual Bottleneck (b) SandGlass Bottleneck
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/804104399e1098b7f221c7ae61f85b61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbaaa3a96234e34aba20050604f9e98e/" rel="bookmark">
			使用 Docker-compose 搭建lnmp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务编排： 应用编排：
单机环境下：shell/python脚本多机/集群环境下：ansible、saltstack、pubbet docker容器编排：
单机：docker-compose多机/集群：docker swarm，mesos+ marathon，kubernetes 一、Docker-Compose简介 1.1 为什么使用 Docker-compose 我们知道使用一个Dockerfile模板文件可以定义一个单独的应用容器，如果需要定义多个容器就需要服务编排。服务编排有很多种技术方案，今天给大家介绍Docker 官方产品Docker Compose。
Dockerfile可以让用户管理一个单独的应用容器；而Compose则 允许用户在一个模板(YAML格式) 中定义一组相关联的应用容器( 被称为一个project，即项目)，例如一个Web服务容器再加上后端的数据库服务容器等。
1.2 Docker-compose概述 Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。
Docker-Compose将所管理的容器分为三层，分别是工程（project），服务（service） 以及容器（container）。Docker-Compose运行目录下的所有文件(docker-compose.yml，extends文件或环境变量文件等)组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖。一个服务当中可包括多个容器实例，Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务 发现及负载均衡，比如Consul。
Docker-Compose的工程配置文件默认为docker-compose. yml，可通过环境变量COMPOSE_FILE 或 -f 参数自定义配置文件，其定义了多个有依赖关系的服务及每个服务运行的容器。
使用一个Dockerfile模板文件，可以让用户很方便的定义一个单独的应用容器。在工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个Web项目，除了Web服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。
Compose允许用户通过一个单独的docker-compose. yml模板文件（YAML格式）来定义一组相关联的应用容器为一个项目 (project) 。
Docker-Compose项目由Python编写，调用Docker服 务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理。
二、compose 部署 2.1 Docker Compose 环境安装 Docker Compose是 Docker 的独立产品，因此需要安装 Docker 之后再单独安装Docker Compose。
#方法一：下载。 curl -L https://github.com/docker/compose/releases/download/1.21.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose #安装，给予执行权限 chmod +x /usr/local/bin/docker-compose #查看版本 docker-compose --version ​ #方法二：也可以提前下载好安装包，之后上传到系统中。 cd /opt/ ls chmod +x docker-compose mv docker-compose /usr/local/bin/ docker-compose --version 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbaaa3a96234e34aba20050604f9e98e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee58ece49c675477e8ec6a813a25eb43/" rel="bookmark">
			STM32/51单片机实训day6（二）——Proteus8.6版本&#43;STM32F103驱动LCD128x64显示信息｜Keil5程序设计｜串行并行通信笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
main.c
lcd.c
lcd.h
内 容：实现LCD显示 学 时：4学时
知识点：LCD12864芯片介绍，读写操作时序，电路设计
重点： 读写操作时序
难点：读写操作时序
时间：2022年12月26日 13:30～16:20
总结：
1 了解LCD12864芯片配置
2 使用proteus设计LCD显示电路
3 编程实现LCD显示
控制引脚：LCD_Struct.GPIO_Mode = GPIO_Mode_Out_PP; // 推挽输出
数字引脚：LCD_Struct.GPIO_Mode = GPIO_Mode_Out_OD; // 开漏输出 1 2引脚连接电源
15引脚 选择并行通讯 控制引脚 LCD_Struct.GPIO_Mode = GPIO_Mode_Out_PP; // 推挽输出
数字引脚 LCD_Struct.GPIO_Mode = GPIO_Mode_Out_OD; // 开漏输出 main.c LCD_Init(); LCD_DIS_Char(0,0,"Welcome System",MIDDLE); LCD_DIS_Char(2,0,"Please login",MIDDLE); while (1) { if(isRec==1){ LCD_CLEAR_ALL(); if(pd==1){ LCD_DIS_Char(0,0,name,MIDDLE); //LCD_DIS_Char(3,0,id,MIDDLE); LCD_DIS_Char(6,0,"Login succeeded",MIDDLE); }else{ LCD_DIS_Char(4,0,"Login failed",MIDDLE); } isRec=3; } if(isRec==3&amp;&amp;bh=='1'){ LCD_CLEAR_ALL(); LCD_DIS_Char(0,0,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee58ece49c675477e8ec6a813a25eb43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cddb4baec4b8a485e651c5995b7f45ef/" rel="bookmark">
			51单片机实训day2——创建Proteus工程以及Proteus基本控件的使用｜单片机最小系统电路设计:电源配置 复位电路 晶振电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以管理员身份打开软件！！！
以管理员身份打开软件！！！
以管理员身份打开软件！！！ 内 容：Proteus工程创建
学 时：2学时
知识点：熟悉Proteus功能、熟悉Proteus基本控件的使用
重点： 新建工程过程、Proteus基本控件的使用
难点：Proteus基本控件的使用
时间：2022年12月20日 13:30～16:20
内 容：使用proteus设计单片机最小系统
学 时：2学时
知识点：电源配置、复位电路、晶振电路
重点：复位电路、晶振电路
难点：复位电路、晶振电路
时间：2022年12月20日 13:30～16:20
目录 1 前期准备
Proteus提示No Libraries Found! 2 Proteus是什么
3 工程创建
步骤1：
步骤2：
步骤3：
步骤4：
4 基础控件使用
4.1 常用选择图标简介
4.2 器件的查找和添加​​​​​​​
4.3 器件参数设置
5 单片机最小系统
6 最小系统电路设计
6.1 电源配置
步骤1：
步骤2：
6.2 复位电路
6.3 晶振电路
6.4 启动配置
学习成果：
​​​​​​​
1 前期准备 安装Proteus 8过程非常简单，没有坑！
Proteus提示No Libraries Found! 错误如上图所示：
这个错误是可能由于软件下载在C盘，软件需要使用外部库时会申请管理员身份。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cddb4baec4b8a485e651c5995b7f45ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41d1b6e1bc99fda6b13680d9a4a0b8a/" rel="bookmark">
			Redis 的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载 Redis 源码并解压
打开 Redis 的官网，然后复制其下载的地址，地址如下：
http://download.redis.io/releases/redis-5.0.8.tar.gz 复制
复制到下载地址以后，在 shell 下可以通过 wget 即可下载其源码，命令如下：
# wget http://download.redis.io/releases/redis-5.0.8.tar.gz 复制
下载到源码以后将其进行解压，命令如下：
# tar -zxvf redis-5.0.8.tar.gz 复制
解压后到目录名为 redis-5.0.8，将目录进行修改，命令如下：
# mv redis-5.0.8 redis 复制
2、编译并安装 Redis
编译 Redis 是比较容易的，直接使用 make 即可，命令如下：
# make 复制
编译完成后，就可以进行安装了，安装时可以指定安装的目录，命令如下：
# make PREFIX=/usr/local/redis install 复制
安装完成以后可以查看一下安装目录下的文件，命令如下：
# ll /usr/local/redis/ 总用量 4 drwxr-xr-x 2 root root 4096 4月 14 23:35 bin # ll /usr/local/redis/bin/ 总用量 32772 -rwxr-xr-x 1 root root 4366776 4月 14 23:35 redis-benchmark -rwxr-xr-x 1 root root 8124968 4月 14 23:35 redis-check-aof -rwxr-xr-x 1 root root 8124968 4月 14 23:35 redis-check-rdb -rwxr-xr-x 1 root root 4807744 4月 14 23:35 redis-cli lrwxrwxrwx 1 root root 12 4月 14 23:35 redis-sentinel -&gt; redis-server -rwxr-xr-x 1 root root 8124968 4月 14 23:35 redis-server 复制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41d1b6e1bc99fda6b13680d9a4a0b8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0298c1e2ffd8c7e084f9e86c83012467/" rel="bookmark">
			Zookeeper 基础知识汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、zookeeper 概述 中文教程：https://www.docs4dev.com/docs/zh/zookeeper/r3.5.6/reference/zookeeperOver.html
1.1 概述 ZooKeeper 是⼀种分布式协调服务，⽤于管理⼤型主机。在分布式环境中协调和管理服务是 ⼀个复杂的过程。ZooKeeper 通过其简单的架构和 API 解决了这个问题。ZooKeeper 允许开 发⼈员专注于核⼼应⽤程序逻辑，⽽不必担⼼应⽤程序的分布式特性。
1.2 使用场景 分布式协调组讲 分布式服务下需要对数据状态进行统计管理，比如用户的登录情况。
分布式锁 zk在实现分布式锁上，可以做到强⼀致性，关于分布式锁相关的知识，在之后的ZAB协议中介绍。
无状态实现 二、zookeeper 服务配置与使用 2.1 zookeeper 服务搭建 2.1.1 安装包部署 官方网址：https://zookeeper.apache.org/releases.html
详细安装过程大家可以自行百度
2.1.2 Docker 部署 docker run -d \ -e TZ="Asia/Shanghai" \ -p 2181:2181 \ -v /Users/rion/Data/DockerVolumesData/zookeeper/zookeeper01/data:/data \ -v /Users/rion/Data/DockerVolumesData/zookeeper/zookeeper01/conf:/conf/ \ -v /Users/rion/Data/DockerVolumesData/zookeeper/zookeeper01/log:/datalog/ \ --name zookeeper01 zookeeper 参数：
-e：表示添加环境变量
-p：设置宿主机和容器内部端口的映射
-v：表示挂载目录
/data : zookeeper 的数据目录
/conf ：zookeeper 的配置文件目录
/datalog ： zookeeper 的日志目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0298c1e2ffd8c7e084f9e86c83012467/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ff73aaea282eec1360da52c0544dd65/" rel="bookmark">
			2023最新IEDA全网安装、使用、配置保姆级教学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、idea的下载、安装与卸载
1.点击下载
2.安装 IDEA
3.卸载
三、配置
1.JDK配置
2.Maven配置
四、插件安装
五、界面介绍及常用设置
工欲善其事必先利其器，IDEA作为Java开发人员最常用的一把好刀，怎么能不好好磨一磨呢？接下来我将从IEDA的安装、使用、配置等各方面来教大家如何使用IDEA。
一、idea的下载、安装与卸载 1.点击下载 IDEA分为旗舰版(Ultimate)和社区版(Community)。旗舰版收费(限 30 天免费试用)，社区版免费，我们这里选择旗舰版。
2.安装 IDEA 下载好安装包之后，双击打开安装向导，点击 Next 下一步。
3.卸载 由于我的电脑有之前版本的IDEA所以需要卸载下老版本。
选择卸载历史缓存和下载的插件
注册表删除：
win+r， regedit，打开注册表编辑器，在HKEY_CURRENT_USER文件夹右键查找搜索jetbrain，然后删除整个jetbrain文件夹。
补充：强烈推荐一个软件Geek，它删除软件时会顺道把注册表也删除了。Geek Uninstaller - the best FREE uninstaller
接下来选择安装路径，默认安装路径即可（如果需要按下面步骤更改）
本地文件删除：
在地址：C:\Program Files\ 删除有关JetBrains文件夹。没有就不需要删除。
勾选自己需要的，可以全选，然后点击【Next】
接下来这一步不用管，直接 install 即可
等待安装进度条结束，选择现在重启或过会重启。
这里选择不导入设置。
看下安装结构：
bin：容器，执行文件和启动参数等
help：快捷键文档和其他帮助文档
jbr：64 位java 运行环境
lib：idea 依赖的类库
license：各个插件许可
plugin：插件
plugins：各种插件
如果想使用最新版IDEA，请访问IDEA助手------IDEA2023版激活保姆级教程 - 如果我是枫 - 博客园 (cnblogs.com)
三、配置 1.JDK配置 JDK下载
Java Downloads | Oracle
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ff73aaea282eec1360da52c0544dd65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f6d3c83c3d388ebf2a4a15d58dc5c94/" rel="bookmark">
			【CVPR2023】CDDFuse: Correlation-Driven Dual-Branch Feature Decomposition for Multi-Modality Image Fus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CDDFuse: Correlation-Driven Dual-Branch Feature Decomposition for Multi-Modality Image Fusion, CVPR2023 解读：CVPR 2023 | 结合Transformer和CNN的多任务多模态图像融合方法 (qq.com)
论文：https://arxiv.org/abs/2211.14461
代码：https://github.com/Zhaozixiang1228/MMIF-CDDFuse
本文亮点
结合CNN和当前火爆的Transformer；将特征解耦的思想引入了图像融合，将跨模态信息分解为共有信息和特有信息，类似于DRF等融合模型；两阶段训练法，第一阶段采用的输入和输出都是源图像的自监督方式，SD-Net、SFA-Fuse采用了这类思想；用高级视觉任务验证了融合效果。 介绍 多模态图像融合目的是结合各个模态图像的特点，如有物理含义的高亮区域和纹理细节。为了能对跨模态进行有效建模，并分解得到期望的各模态共有特征和特有特征，本文提出了Correlation-Driven feature Decomposition Fusion (CDDFuse) 来进行多模态特征分解和图像融合。本文模型分为两阶段，第一阶段CDDFuse首先使用Restormer块来提取跨模态浅层特征，然后引入双分支Transformer-CNN特征提取器，其中 Lite Transformer (LT)块利用长程注意力处理低频全局特征， Invertible Neural Networks (INN) 块则用来提取高频局部特征。基于嵌入的语义信息，低频特征应该是相关的，而高频特征应该是不相关的。因此，提出了相关性驱动损失函数，让网络可以对特征进行更有效的分解。第二阶段，前述的LT和INN模块会输出融合图像。
目前已有的多模态图像融合模型很多采用自编码器结构：
但是这种方式有三个缺陷：
CNN的解释性较差，难以控制，对跨模态特征提取不够充分，如上图前两种都是多模态输入共享编码器，因此难以提取到模态特有的特征，而第三种双分支结构则忽略了各个模态共有属性；上下文独立的CNN结构只能在相对小的感受野内提取到局部信息，很难捕获全局信息，因此目前还不清楚 CNN 的归纳偏差能否对所有模态的输入充分提取特征；网络的前向传播会造成高频信息丢失。 本文探索了一种合理的范式来解决特征提取和融合上的问题。首先给提取到的特征添加相关性约束，提高特征提取的可控制性和可解释性，本文的假设是对于多模态图像融合，两个模态的输入特征在低频上是相关的，表示了所有模态的共有信息，在高频上是不相关的，表示了各个模态独有的信息。比如ir-vis融合，红外与可见光图的场景相同，在低频信息上包含统计上的共有信息，比如背景和大尺度环境特征，而高频部分的信息则是独立的，比如可见光模态纹理细节信息和红外模态的温度信息都是各自模态特有的。因此需要通过分别提高低频部分特征之间相关性、降低高频特征之间的相关性来促进跨模态特征提取。transformer目前在视觉任务上很成功，主要得益于它的自注意力机制和全局特征提取能力，但是往往很大的计算资源，因此本文提出让transformer结合CNN的局部上下文提取和计算高效性的优势。最后，为了解决丢失期望高频输入信息的问题，引入了Invertible Neural networks (INN)块，INN 是通过可逆性设计让输入和输出特征的相互生成来防止信息丢失，符合融合图像中保留高频特征的目标。
方法 模型整体结构如下图，整体分为四个模块：双分支编码器用于特征提取与分解、解码器用于训练阶段I的图像重建或者训练阶段II的图像融合、base/detail融合层用于融合不同频率的特征。
编码器 包含三部分：Restormer block - based share feature encoder (SFE)、Lite Transformer (LT) block - based base transformer encoder (BTE) 、 Invertible Neural networks (INN) block - based detail CNN encoder (DCE)，其中BTE和DCE共同组成长短距离编码器。对于输入的三通道可见光图和单通道红外图，用S、B、D分别表示SFE、BTE、DCE三个模块。首先来看用来提取共有特征的SFE模块，它的目标是提取浅层特征，如下式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f6d3c83c3d388ebf2a4a15d58dc5c94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fd0a3617a88a25a483022d5994e7c46/" rel="bookmark">
			基于JavaWeb的毕业论文管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘　要
伴随着计算机技术和网络的发展，现代社会人们经济水平以及对物质的需求显著提高，计算机如今已成为人们生活中不可缺少的一部分，为各行各业的工作提供了方便，也使高校对毕业论文的管理更加便捷。本系统解决了毕业论文管理事务中的主要问题，方便学校对学生，导师，论文相关信息进行管理，也为学生和老师提供了便利，让选题，论文信息，成绩，以及各种资料和相对复杂问题的处理变得方便。
系统采用Java语言，SSM框架设计，而对于我们需要用到的信息则是使用MySQL进行报关。通过B/S结构构建的管理层进行开发和设计，功能强大，界面化操作便于上手。本系统具有良好的易用性和安全性，系统功能齐全，可以满足毕业论文信息管理的相关工作。
本系统一共四个大模块。管理员端(对与学生，老师，学院管理员以及论文的相关管理)。学生端(对个人信息，论文选题及信息的管理)。导师端(对课题，论文相关信息及论文成绩的管理)。院系管理员端(对学生导师，课题以及论文相关的管理)。本文将对该系统的功能和设计的相关过程做详细的描述。
关键词：毕业论文；Java技术；SSM；MySQL；
3.1 系统的可行性分析 毕业论文管理系统的可行性分析基于当下的互联网背景，从经济、技术、法律和用户使用上进行了调查，从此验证次系统开发的可行性[6]。下面分别从以下几点进行分析:
（1）经济可行性分析：此系统所用的框架技术完全是开源的，其余的软件使用也都是免费的，在开发方面所消耗的成本可以忽略不计。而建立系统信息库所需的费用远远少于其带来的社会收益，这样看来是可以实行的。
（2）技术可行性分析：毕业论文管理系统的大部分功能都需要管理员完成，系统只需要添加少量代码就可以很好适配管理员功能[7]。可以提高文件的复用率，提高效率。在数据库方面，ORM简化了表的创建和使用，采用了Oracle旗下开源的关系型数据管理系统MySQL，多表存储的特点使数据更加规范化，增删改查更容易[8]。综上所述，技术开发上并无太大的难点。
（3）用户使用可行性分析：鉴于系统的使用用户，有统一的账号和密码，且系统无需用户有过多的操作，界面清晰简洁。
（4）法律可行性分析：这款应用的内容在法律上是完全允许的，而且已经通过了备案。
3.2 系统需求分析 在系统的开发中尤为重要的肯定是对需求了了解和分析[9]，只有需求分析的好，思路和步骤再能清晰，这样才能大大的提高制作的效率以及准确性。在软件工程方法中有位主要的就是对需求的分析[10]，总的来讲就是了解用户需要什么，系统的系统需要什么，对此进行问题的列举，等级的排列，需要缜密的思分析和大量的调研[11]。
毕业论文管理系统在国内有很多值得借鉴的例子，功能也都趋于完善，因此此次毕业论文管理系统将轻量化开发，要完成以下功能：
（1）要支持完整的学生注册，登录功能，账号的管理通过管理员来实现。
（2）毕业论文管理系统的首页的操作十分简单，可以让老师同学们快速的学会使用方法，这样更能提高效率。
（3）为了用户能够方便的搜寻信息。
（4）对于管理员而言，主要工作就是为老师同学们的操作提供便利，及时的更新相应内容从而让老师同学们迅速的老姐信息。
3.3 系统流程设计 3.3.1　用户登录流程
登录流程实现了管理员和其他用户的登录，在登录页面需要用户填写自己的信息，前端页面会将信息传递给后端接口，然后查询数据库确定该身份有效后允许登录，如果身份无效则无法登录，之后就需要确认信息准确行，再次进行身份核验，具体流程如图3-1所示。
图3-1登录流程图
4.1 系统功能结构设计图 使用了结构化和模块化的方法，优势在于控制性较强，各模块之间互不影响，方便系统的开发与管理。 系统总体功能如下图所示：
图4-1 系统总体功能模块图 选题信息实体图如图4-6所示：
图4-6 选题信息实体图
参考资料实体图如图4-7所示：
图4-7 参考资料实体图
5.1 首页功能实现 首先进入系统，看到首页，有学校的学院信息以及课题信息，可以选择自己相应的学院和课题。还有参考资料，和实时更新的公告系统。系统首页界面如图5-1所示。
图5-1 系统首页界面
在首页界面点击课题信息，进入课题信息界面：在课题信息页面的输入栏中输入课题名称、课题编号、导师工号、开始时间、发布日期、任务书、课题分类、导师姓名、结束时间、点击次数进行查询，可以查看到课题详细信息，并根据需要进行点击下载或收藏； 课题信息页面如图5-2所示。
图5-2 课题信息详细页面
5.2 管理员模块实现 管理员通过输入正确的用户名和密码进入管理功能页面，通过点击个人中心，对管理员信息进行改动。依次是对学生，老师，学院以及学员管理员进行相应操作，其次是对论文的课题信息，选题，成绩等进行管理，最后是对系统进行管理，如更改公告等。管理员主页面如图5-3所示。
图5-3 管理员主界面
5.2.1 学生管理模块
管理员进入学生管理界面，可以对学生信息如姓名，性别，专业，年级等进行修改，也可以通过学生账号快速找到对应的学生，其次是对学生的增加和删除操作，
具体如下图5-4所示。
图5-4 学生管理界面
学生管理界面实现代码如下所示：
/**
* 查询
*/
@RequestMapping("/query")
public R query(XueshengEntity xuesheng){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fd0a3617a88a25a483022d5994e7c46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7141d74047065e8589b62d4d3b0225e/" rel="bookmark">
			设计模式系列之抽象工厂模式(Abstract Factory)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抽象工厂就是一个把工厂抽象，工厂模式生产的是产品，抽象工厂生产的是工厂。这种类型的设计模式属于创建型模式。
就相当于一个工厂生产一件产品，现在有多个产品了。比如生产汽车，首先一个工厂用于生产汽车原胚，另一个工厂用于生产汽车颜料，但这两个工厂都属于同一个集团，由集团统一进行组合成不同颜色的车进行售卖，集团就是这个抽象工厂。
那么抽象工厂用来干嘛呢？
抽象工厂提供了一个创建一系列相关或相互依赖对象的接口，而无需指定他们的具体类，主要也是解决接口选择的问题。
怎么实现抽象工厂呢？
在工厂模式的基础上，再抽象出一个更大的工厂用于生产这些工厂
首先我们需要先有至少2个工厂模式（CarFactory和ColorFactory）去生产产品，这两个工厂类都继承于集团的这个抽象工厂（AbstractFactory）
public abstract class AbstractFactory { public abstract Car getCar(String carName); public abstract Color getColor(String color); } 这里可以看到，集团的这个抽象工厂（AbstractFactory）里聚合了2个工厂模式（CarFactory和ColorFactory），用于生产产品
public class CarFactory extends AbstractFactory { @Override public Car getCar(String carName) { if(carName == null){ return null; } if("CarOne".equals(carName)){ return new CarOne(); } if("CarTwo".equals(carName)){ return new CarTwo(); } return null; } @Override public Color getColor(String color) { return null; } } public class ColorFactory extends AbstractFactory { @Override public Car getCar(String carName) { return null; } @Override public Color getColor(String color) { if(color == null){ return null; } if("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7141d74047065e8589b62d4d3b0225e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d936431bf369906030d1057e2c9fb404/" rel="bookmark">
			RTMDet训练流程（OpenMMLab AI实战营笔记7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次课程是使用rtmdet进行目标检测的课程
文章简介 我们先简单介绍一下rtmdet
paper：RTMDet: An Empirical Study of Designing Real-Time Object Detectors
GitHub： RTMDet
在本文中，我们的目标是设计一种高效的实时物体检测器，它超越了 YOLO 系列，并且可以轻松扩展到许多物体识别任务，例如实例分割和旋转物体检测。为了获得更高效的模型架构，我们探索了一种 在主干和颈部具有兼容能力的架构，该架构 由一个 由大核深度卷积组成的基本构建块 构建。我们在动态标签分配中 计算匹配成本时 进一步 引入软标签 以提高准确性。结合更好的训练技术，由此产生的名为 RTMDet 的目标检测器在 NVIDIA 3090 GPU 上以 300+ FPS 的速度在 COCO 上实现了 52.8% 的 AP，优于当前主流的工业检测器。RTMDet 针对各种应用场景实现了 tiny/small/medium/large/extra-large 模型大小的最佳 参数-精度权衡，并在实时实例分割和旋转目标检测方面获得了最新的性能。我们希望实验结果可以为设计用于许多目标识别任务的多功能实时目标检测器提供新的见解。
这里，我们简单阐述一下RTMDet设计的基本思想，也就是希望设计一个BackBone和Neck部分可以进行融合的目标检测架构，从而让目标检测更轻量化。能突破yolo的速度。
MMDetection MMDetection
RTMDet的代码已在MMDetection复现并开源，我们这里使用RTMDet进行气球检测。colab
所有的代码也可以在我的colab中查看
colab 代码 安装基本工具 （MMDetection，MMYOLO） %pip install -U "openmim==0.3.7" !mim install "mmengine==0.7.1" !mim install "mmcv==2.0.0" !git clone -b tutorials https://github.com/open-mmlab/mmdetection.git %cd mmdetection %pip install -e .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d936431bf369906030d1057e2c9fb404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a42b48abe8a58e36b63f79269a048ba6/" rel="bookmark">
			二十二、高级网络技术及应用——策略路由与路由策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、路由策略配置二、策略路由配置（使用AR3260路由器）1、本地方式：只能对由本机主动触发的流量生效。对流经本机的（转发流量）无效。2、策略路由-接口方式（基于接口策略路由） 前言 常用调整网络流量路径的方式：
（1）路由策略是通过更改某些路由参数影响路由表的路由条目来影响报文的转发（例如：filter-policy 、route-policy、cost值修改、优先级修改等）
（2）策略路由是通过管理员在路由器上面配置策略强制数据包按照策略转发，策略路由优先于路由表。（比如：策略路由可以基于源地址定制数据的转发路径）
区别和联系：两者都是为了改变网络流量的转发路径，目的一样，但实现的方式不一样。
一、路由策略配置 filter-policy （路由过滤）法如下：
R1：配置filter-policy 过滤掉7.7.7.0 路由，使其不能访问PC7。
acl number 2019 rule 5 deny source 7.7.7.0 0.0.0.255 rule 10 permit ospf 1 filter-policy 2019 import 二、策略路由配置（使用AR3260路由器） 1、本地方式：只能对由本机主动触发的流量生效。对流经本机的（转发流量）无效。 R1：使R1触发的流量选择13.1.1.3转发
（1）定义ACL
（2）定义策略路由，强制下一跳为13.1.1.3
（3）本地调用
acl number 3000 rule 5 permit ip destination 4.4.4.4 0 [R1]policy-based-route aa permit node 10 if-match acl 3000 apply ip-address next-hop 13.1.1.3 [R1]ip local policy-based-route aa 调试指令：
2、策略路由-接口方式（基于接口策略路由） R1：使PC1的流量走上面，PC2的流量走下面，并且互为备份。
① 分类：财务部、工程部
acl number 2006 rule 5 permit source 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a42b48abe8a58e36b63f79269a048ba6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4213546aca409dc8c43f025c9d185e80/" rel="bookmark">
			51、基于51单片机洗衣机控制系统（带水位）系统设计(程序&#43;原理图&#43;PCB源文件&#43;Proteus仿真&#43;参考论文&#43;开题报告&#43;任务书&#43;流程图&#43;元器件清单等)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 随着数字技术的快速发展，数字技术被广泛应用于智能控制的领域中。单片机以体积小、功能全、价格低廉、开发方便的优势得到了许多电子系统设计者的青睐。它适合于实时控制，可构成工业控制器、智能仪表、智能接口、智能武器装置以及通用测控单元等。
本文以51单片机为核心设计了全自动洗衣机控制系统，本系统实现了对洗衣机整个洗衣过程的控制，包括用户参数输入、洗衣、脱水和结束报警四个阶段。控制系统主要由单片机主控系统组成。单片机主控系统负责控制洗衣机的工作过程，主要由AT89C51单片机、按键、蜂鸣器、LED、电机、水位传感器等组成。
本系统的电路并不复杂，给51单片机载入软件程序后，能够实现全自动洗衣机的基本功能。虽然不能与电器市场上的洗衣机控制系统媲美，但也具有一定的实用性。
关键词：单片机；继电器；控制系统；LED
引 言 目前我国的洗衣机的种类有很多，现在农村大部分的洗衣机类型都是半自动的，既耽误时间又耗费体力；随着全自动洗衣机的问世，人们对洗衣机的关注也越来越多，现在的全自动洗衣机的功能有进水、洗涤、排水、漂洗、脱水、排水等几大功能。随着人们生活水平的提高，人们对于洗衣机的要求越来越高，这就要求设计者们设计出更人性、更方便、更快捷的洗衣机。让洗衣服这项难于逃避的家务劳动，不再成为一种负担。
随着加入世贸组织，很多的国内外强势品牌加入，研究新的技术开发新的产品，洗衣机行业将爆发新一轮的以“绿色环保”、“节水节能”为主题的大战，而技术制高点则是未来的竞争焦点。在国内，由于水资源的缺乏以及水费有所提高，因此节水型的洗衣机在国内比较畅销，而用水量较大的洗衣机则可能会被淘汰。对这种现状，我国的洗衣机生产商对于洗衣机的设计做出调整，向市场推出一批节能型全自动洗衣机。虽然全自动洗衣机有它的优势，但是对于大部分农村人来说，全自动洗衣机仍是奢侈品，所以半自动洗衣机仍然有它自己的市场，这就要求设计者考虑到更多的方面去设计洗衣机。
目前全自动洗衣机的控制功能都是由单片机实现的，单片机易于操作，体积小，价格低因此受到广泛的应用，所以此设计也是在单片机的基础上设计的，具有很强的实用性。本次设计以AT89C51单片机为核心，在此基础上增加外围电路，以确保洗衣机的正常运行。本次设计主要包括硬件设计，仿真设计，和程序编写。硬件设计包括电源电路、单片机最小系统电路、按键电路、倒计时电路、电机驱动电路、显示报警电路；仿真设计主要包括电机控制电路、蜂鸣报警电路、显示电路、按键控制电路和指示电路；程序的编写主要有洗涤程序、漂洗程序、脱水程序。与此同时还介绍了与洗衣机有关的一些常见的电子元器件的基本功能。
1.1开发背景
有人说，科技的进步是因为人类的懒造成的，是的，因为人们懒得走路，所以有了自行车、电动车、汽车；因为人们懒得烧火，所以有了各类的电饭锅；因为人们懒得洗衣服，所以有了洗衣机。人们的生活水平不断提高，科技不断进步，洗衣机的品种和功能层出不穷。现在的洗衣机已经越来越智能化，人们只需按几个键就可以将衣服晾出去了。随着科技的进步我相信在不久的将来我们一定可以发明出更先进更便捷的洗衣机。也许到时我们只需说一句话，或者一个口哨，洗衣机就可以按着制定的程序完成各种操作了，等我们一觉醒来，衣服已经挂在晾衣绳上了。
1.2 设计的目的和意义
目前我国的洗衣机的种类有很多，现在农村大部分的洗衣机类型都是半自动的，既耽误时间又耗费体力；随着全自动洗衣机的问世，人们对洗衣机的关注也越来越多，现在的全自动洗衣机的功能有进水、洗涤、排水、漂洗、脱水、排水等几大功能，另外有标准、快速、轻柔和调试四种模式选择。随着人们生活水平的提高，人们对于洗衣机的要求越来越高，这就要求设计者们设计出更人性、更方便、更快捷的洗衣机。虽然此次设计并没有将洗衣机的作用全部设计出来，但重要的是将自己在课堂上学的东西运用到实际中来，让我们看到自己所学的知识并不只是纸上谈兵。
1.3 国内外现状及水平
1. 洗衣机的分类
普通洗衣机。其洗涤、漂洗、脱水等功能均须手工转换。
半自动洗衣机。它能在洗涤、漂洗、脱水等功能之间，实现某两个功能的自动转换。
全自动洗衣机。它能自动实现洗涤、漂洗、脱水等所有功能。
2. 全自动洗衣机在国内外的现状及水平
全自动洗衣机的种类有很多，根据结构不同可分为波轮式全自动洗衣机(也叫套桶式全自动洗衣机)、滚筒式全自动洗衣机和搅拌式全自动洗衣机三大类。因为滚筒式机的价格高于波轮式机，所以波轮式机仍受到普遍欢迎；搅拌式洗衣机目前还没有进入我国市场。目前我国的洗衣机仍然存在很多的缺陷，有待设计者去设计出更人性化的洗衣机。在我国，农村人口较多，而农村人使用全自动洗衣机的人数寥寥无几，不仅因为它的价格昂贵，还因为农村自来水的不方便。相信在不久的将来，全自动洗衣机一定会完全代替半自动洗衣机。
现在已经有的洗衣机厂家设计出来便携式洗衣机轻巧、体积小。还有的商家设计出远程控制的洗衣机，方便控制。怎么样？是不是眼花缭乱了呢？我相信将来的洗衣机一定会朝着更方便、更节能、更人性化的方向发展。
一、硬件方案 硬件构成：本设计采用51单片机作为主控芯片，LED显示状态，2位共阴数码管显示时间，控制按键可控制和选择功能，继电器模拟出水、进水，电机模拟洗衣机工作。
二、设计功能 1. 单片机型号：STC89C52/51、AT89C52/51、AT89S52/51等都可通用。
2、实现对洗衣机整个洗衣过程的控制，包括进水、洗涤、漂洗、排水、脱水五个阶段。
3、洗涤模式及参数
1）标准：洗涤12分钟，漂洗5分钟2次，脱水3分钟；
2）快速：洗涤4分钟，漂洗1分钟2次，脱水2分钟；
3）轻柔：洗涤3分钟，漂洗3分钟2次，脱水2分钟；
4）调试模式（方便演示）：全部过程都为1分钟；
4、洗涤和漂洗：电机先正传22秒，暂停8秒，再反转22秒，暂停8秒。洗涤、漂洗、脱水、结束四个过程运行有对应的指示灯，结束时蜂鸣器响3s，另外标准、快速、轻柔、调试模式四个模式选择也有对应的指示灯。
5、有水位控制，一个低水位检测，一个高水位检测；当进水的时候高水位检测到有水代表进水完毕进行下一步，当排水的时候，低水位检测没有水代表排水结束。
三、实物图 3.2主控模块设计
单片微型计算机是随着微型计算机的发展而产生和发展的。自从1975 年美国德克萨斯仪器公司的第一台单片微型计算机（ 简称单片机）TMS-1000 问世以来，迄今为止，单片机技术已成为计算机技术的一个独特分支，单片机的应用领域也越来越广泛，特别是在工业控制中经常遇到对某些物理量进行定时采样与控制的问题，在仪器仪表智能化中也扮演着极其重要的角色。
如果将8位单片机的推出作为起点，那么单片机的发展历史大致可以分为以下几个阶段：
第一阶段（1976—1978）：单片机的探索阶段。以Intel公司的MCS-48为代表。MCS-48的推出是在工控领域的探索，参与这一探索的公司还有Motorola、Zilog等。都取得了满意的效果。这就是SCM的诞生年代，“单片机”一词即由此而来。
第二阶段（1978—1982）：单片机的完善阶段。Intel公司在MCS-48基础上推出了完善的、典型的单片机系列MCS-51。它在以下几个方面奠定了典型的通用总线型单片机体系结构。
（1）完善的外部总线。MCS-51设置了经典的8位单片机的总线结构，包括8位数据总线、16位地址总线、控制总线及具有多机通信功能的串行通信接口。
（2）CPU外围功能单元的集中管理模式。
（3）体现工控特性的地址空间及位操作方式。
（4）指令系统趋于丰富和完善，并且增加了许多突出控制功能的指令。
第三阶段（1982—1990）：8位单片机的巩固发展及16位单片机的推出阶段，也是单片机向微控制器发展的阶段。Intel公司推出的MCS-96系列单片机，将一些用于测控系统的模数转换器、程序运行监视器、脉宽调制器等纳入片中，体现了单片机的微控制器特征。
第四阶段（1990—）：微控制器的全面发展阶段。随着单片机在各个领域全面、深入地发展和应用，出现了高速、大寻址范围、强运算能力的8位/16位/32位通用型单片机，以及小型廉价的专用型单片机。
单片机是在集成电路芯片上集成了各种元件的微型计算机，这些元件包括中央处理器CPU、数据存储器RAM、程序存储器ROM、定时/计数器、中断系统、时钟部件的集成和I/O接口电路。由于单片机具有体积小、价格低、可靠性高、开发应用方便等特点，因此在现代电子技术和工业领域应用较为广泛，在智能仪表中单片机是应用最多、最活跃的领域之一。在控制领域中,现如今人们更注意计算机的底成本、小体积、运行的可靠性和控制的灵活性。在各类仪器、仪表中引入单片机，使仪器仪表智能化，提高测试的自动化程度和精度，提高计算机的运算速度，简化仪器仪表的硬件结构，提高其性能价格比。
单片机引脚介绍
单片机主要特点：
（1）有优异的性能价格比。
（2）集成度高、体积小、有很高的可靠性。单片机把各功能部件集成在一块芯片上，内部采用总线结构，减少了各芯片之间的连线，大大提高了单片机的可靠性和抗干扰能力。另外，其体积小，对于强磁场环境易于采取屏蔽措施，适合在恶劣环境下工作。
（3）控制功能强。为了满足工业控制的要求，一般单片机的指令系统中均有极丰富的转移指令、I/O口的逻辑操作以及位处理功能。单片机的逻辑控制功能及运行速度均高于同一档次的微机。
（4）低功耗、低电压，便于生产便携式产品。
（5）外部总线增加了I2C（Inter-Integrated Circuit）及SPI(Serial Peripheral Interface)等串行总线方式，进一步缩小了体积，简化了结构。
（6）单片机的系统扩展和系统配置较典型、规范，容易构成各种规模的应用系统。
优异的性能价格比。
1）集成度高、体积小、有很高的可靠性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4213546aca409dc8c43f025c9d185e80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b181c40ab22e2af36588748c8b5b369/" rel="bookmark">
			opencv学习笔记——1.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		opencv简介 OpenCV 是计算机视觉中经典的专用库，其支持多语言、跨平台，功能强大。OpenCV-Python为OpenCV提供了Python接口，使得使用者在Python中能够调用C/C++，在保证易读性和运行效率的前提下，实现所需的功能。
环境配置 使用conda创建环境，pip下载numpy、matplotlib、opencv-python，再通过pycharm使用对应的解释器。这里在网上看到推荐下载opencv-contrib-python包，但是使用基础包大概没有什么问题，大不了以后再换
这里遇到了pycharm没有opencv的代码补全功能，参考(https://zhuanlan.zhihu.com/p/617164055)
将cv2.pyd放到上一级目录即可解决 import numpy as np import matplotlib import cv2 as cv 图像入门 读取图像 使用cv.imread()读取图像
cv.imread()含有两个参数，第一个是图像的地址，地址出错会返回None；第二个如下： cv.IMREAD_COLOR(-1)： 加载彩色图像。任何图像的透明度都会被忽视。它是默认标志。cv.IMREAD_GRAYSCALE(0，默认)：以灰度模式加载图像cv.IMREAD_UNCHANGED(1)：加载图像，包括alpha通道 使用cv.imshow()显示图像
cv.imshow第一个参数为显示名称；第二个参数为图片对象 此处还使用了cv.waitKey()键盘绑定函数，该函数等待任何键盘事件指定的毫秒。如果在这段时间内按下任何键，程序将继续运行。如果0被传递，它将无限期地等待一次敲击键。它也可以设置为检测特定的按键，waitkey函数的返回值（在按了按键的前提下）就是对应按键的ASCAII码，而且是区分大小写的。以及cv.destroyAllWindows()函数关闭创建的所有窗口。如果要销毁任何特定的窗口，使用函数cv.destroyWindow()在其中传递确切的窗口名称作为参数。代码示例： img = cv.imread('./picture/1.jpg', 1) cv.imshow('./picture/1.jpg', img) cv.waitKey(0) cv.destroyAllWindows() 使用cv.imwrite()保存图像
第一个参数是文件地址；第二个参数是保存的图像img = cv.imread('./picture/1_read.jpg.jpg', 1) cv.imshow('./picture/1_read.jpg', img) k = cv.waitKey(0) if k == 27: # 等待ESC退出 cv.destroyAllWindows() elif k == ord('s'): # 等待关键字，保存和退出 cv.imwrite('/picture/1_write.png', img) cv.destroyAllWindows() 使用Matplotlib显示和操作图像
具体函数资源在：(http://matplotlib.org/api/pyplot_api.html) 注意：OpenCV加载的彩色图像处于BGR模式。但是Matplotlib以RGB模式显示。因此，如果使用OpenCV读取彩色图像，则Matplotlib中将无法正确显示彩色图像。 img = cv.imread('./picture/1_read.jpg', 0) plt.imshow(img, cmap='gray', interpolation='bicubic') plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b181c40ab22e2af36588748c8b5b369/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/654afaeda6d603827a81ac771d47f90f/" rel="bookmark">
			AndroidT(13) init 进程 -- second stage init 中的 Epoll （三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概览 在进入 second stage init 讲解之前，先来看看它事件监听及处理的机制 – Epoll 类，它实际上是对 epoll 的封装，使他变得更加适合再 init 中来跟踪事件以及分发触发方法等。整个类只有 4 个方法，在如此小巧的条件下实现了：事件监听的注册、卸载、跟踪以及收集事件的处理方法。这也意味着用户在注册后，在等待到事件后可以直接调用返回的处理方法列表。
2.整体使用骨架 second init 中就是使用 Epoll 来跟踪事件并处理的，下面看下 Epoll 的使用流程。
//system\core\init\init.cpp SecondStageMain //code 1 Epoll epoll; epoll.Open(); //code 2 InstallInitNotifier(&amp;epoll); auto clear_eventfd = [] { uint64_t counter; TEMP_FAILURE_RETRY(read(wake_main_thread_fd, &amp;counter, sizeof(counter))); }; epoll-&gt;RegisterHandler(wake_main_thread_fd, clear_eventfd) //code 3 while (true) { auto pending_functions = epoll.Wait(epoll_timeout); for (const auto&amp; function : *pending_functions) { (*function)(); } } 2.1 Epoll 的实例化 – code1 Epoll 构造方法使用的是空的并没做什么，再 Open 中也是很简单的申请了一个 epoll 的句柄，并记录在 epoll_fd_类变量中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/654afaeda6d603827a81ac771d47f90f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bedc6eecf17afa3fcf24c0ccfb2ef9a2/" rel="bookmark">
			AndroidT(13) init 进程 -- first stage init 的初始化 （二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概览 第一阶段的 init 工作主要用于读取系统启动阶段需要的配置信息(例如 linux的bootconfig，cmdline等配置信息）、挂载文件系统、安装 kernel 中的模块驱动，最后就是启动第二阶段的 init 来进行 Android 系统相关的组件。第一阶段的 init 被编译为静态的可执行程序，位于 ramdisk 中。在 kernel 启动后该 init 应用程序则会被运行。
2.构建必要的目录及设备 这个步骤用于环境的初始化，大概分为下面几类
a)环境变量的设置
b)必要文件及设备的创建
c)对文件及设备的访问权限配置，这里只有传统的 DAC(Discretionary Access Control) 还没启动DAC(Mandatory Access Control).对 DAC 和 MAC 有疑问的可以参考之前的博客《Android R(11)HIDL服务的sepolicy(五)》。
3.设置 log 的输出位置 我们知道 Android 有自己的 log 系统，但此时它还是不可用的。所以需要将 log 导入到 kernel log 中去，方便调试。
//system\core\init\first_stage_init.cpp FirstStageMain ... SetStdioToDevNull(argv); // Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually // talk to the outside world.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bedc6eecf17afa3fcf24c0ccfb2ef9a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f8aac1ad564c18683437625b0646d91/" rel="bookmark">
			Jmeter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、jmeter 安装
二、jmeter 介绍
1、jmeter是什么？
2、jmeter 用来做什么？
3、优点
4、缺点
5、jmeter 目录介绍
①_bin 目录介绍
② docs 目录 — — 接口文档目录
③ extras目录 — — 扩展插件目录
④ lib 目录 — — 所用到的插件目录
⑤ licenses 目录 — — jmeter 证书目录
⑥ printable_docs目录
三、jmeter 基本使用&amp;元件
1、jmeter 入门脚本
jmeter测试计划要素：
2、测试计划元件
3、元件的作用域
（1）原则：
（2）执行顺序
4、jmeter 第一个案例
5、jmeter 运行原理
6、jmeter配置文件修改
（1）修改中文乱码问题
（2）修改默认语言
四、jmeter核心知识
1、发送http请求
1）相关配置元件
2）http请求配置
2、jmeter 参数化***
1）参数化的概念
3）用户参数
5）总结参数化
3、jmeter 断言
1）常用断言
2）响应断言
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f8aac1ad564c18683437625b0646d91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afbe144bd1231b76ef3fea27b4afe074/" rel="bookmark">
			基于YOLOv5的火焰烟雾检测算法实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个不知名大学生，江湖人称菜狗
original author: Jacky Li
Email : 3435673055@qq.com
Time of completion：2023.6.11
Last edited: 2023.6.11
导读：
火焰烟雾检测是智慧安防业务场景中重要的功能之一，本文提出了一种基于YOLOv5的火焰烟雾检测算法，具有更强的泛化性，对火焰烟雾的检测效果更加准确。
目录
一：摘要
二：介绍
三：模型
A. YOLOv5网络模型及算法改进
损失函数的改进
激活函数的改进
四：实验结果与分析
A. 获取数据集
B. 自适应图像缩放
C. 数据标注
D. 模型训练
E. 基于YOLOv5的工厂火焰烟雾检测及结果分析
五：结论
作者有言
文章信息
一：摘要 石油化工装置火灾烟雾检测，可以预防火灾，保证生产安全和生命安全。文章旨在解决复杂工厂背景下火焰烟雾检测中的漏检和误检问题。
文章提出了一种基于YOLOv5的火焰烟雾检测算法。目标回归损失函数(CIoU)用于改善目标检测中的漏检和误检，提高模型的检测性能。改进后的激活函数避免了梯度消失，保持了算法较高的实时性。数据增强技术用于增强网络提取特征的能力，提高小目标检测模型的准确性。根据火焰烟雾的实际情况，改进了YOLOv5模型的损失函数和激活函数。基于改进的YOLOv5模型，建立了一种具有泛化性能的火焰烟雾检测算法。将改进后的模型与SSD和YOLOv4-tiny进行了比较。改进后的YOLOv5模型精度可达99.5%，对火焰烟雾的检测效果更加准确。改进后的网络模型在运行时间和精度上均优于现有方法。
针对火焰烟雾检测的实际特殊性，建立了一种改进的基于YOLOv5的火焰烟雾检测网络模型。通过改进损失函数来达到优化模型的目的，并结合非线性能力较强的激活函数来避免网络的过拟合。该方法有助于改善火焰烟雾检测中的漏检和误检问题，可进一步推广到行人目标检测和车辆行驶识别中。
二：介绍 工厂的安全生产一直是一个不容忽视的问题。以石化工厂为例，由于生产车间密集，存在大量易燃易爆危险品，一旦发生火灾，极易诱发灾难性后果，造成环境污染，严重威胁生产安全和人员生命财产安全。因此，及时发现和预警控制早期火灾是安全生产的现实需求。厂区内火焰烟雾检测报警技术已受到国际、国内的重视。
火灾早期探测主要通过烟雾传感器和温度传感器来实现。例如，烟雾传感器通过检测烟雾浓度来完成防火。这种方法在室内或一些小场所有很好的表现。但在复杂环境中，由于气流环境、热障效应等因素的影响，再加上传感器检测距离较近、稳定性较低，依靠传感器检测温度、浓度等指标，很难准确获取现场实时信号数据信息。
虽然现有的目标检测研究已经取得了重大突破，但在实际的目标检测中，需要对整个图像进行卷积，需要更大的视场来满足算法的简洁快速。YOLO是一种目标检测器，它使用深度卷积神经网络学习的特征来检测目标。近年来，大量研究将其用于不同类型图像的智能检测，然而，模型结构复杂，火焰检测精度不够。
针对YOLOv5算法模型体积小、检测速度快的优异性能，以及处理厂区火焰烟雾检测问题的复杂性，文章在专门改进的YOLOv5的基础上建立了一种植物火焰烟雾检测算法，用于解决火焰烟雾漏检和误检问题。该算法将原有的GIoU _ Loss替换为CIoU _ Loss作为边界盒的损失函数，并利用SiLU激活函数来避免网络的过拟合。最后，通过与SSD、YOLOv4-tiny和YOLOv7算法的比较，验证了所提算法的有效性和可达性。
三：模型 A. YOLOv5网络模型及算法改进 损失函数的改进 损失函数是评估回归和分类问题的重要指标。在深度学习网络中，反向传播时间对误差估计至关重要。因此，本节通过引入更好的理论CIoU _ Loss 损失函数，改进了GIoU _ Loss 。
在目标检测中，需要对检测盒与真实盒的检测效果进行比较。通用网络中使用的GIoU _ Loss解决了在IoU的基础上，由于不同目标盒重叠而导致的比值无法优化的问题。GIoU的计算过程如下式第一个算式所示。
上式第二个算式中，A为预测箱，B为实箱，IoU为传统的交点-并集比，即预测箱与实箱的交点面积与并集面积之比;Ac为预测框与实框最小包围矩形的面积。U为预测框和实框的面积。第三个算式中，LGIOU为GIoU的损失。
当预测框包含在目标框内时，GIoU _ Loss退化为IoU _ Loss，相对位置关系无法区分。为了更好地优化目标盒和预测盒，本文提出用CIoU _ Loss代替原来的GIoU _ Loss作为包围盒损失函数。CIoU的计算过程如下边第一个算式所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afbe144bd1231b76ef3fea27b4afe074/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d5cb0cca601714b364862bca3d0791/" rel="bookmark">
			C语言常量和变量详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常量 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。
常量的值在程序运行之前初始化的时候给定一次，以后都不会变了，以后一直是这个值。
C语言中，有三种实现常量的方式：
1、宏定义
#define N 20 // 符号常量，注意宏定义末尾没有分号 2、const关键字
const int i = 14; 其实，const和类型符号可以互换位置。
int const i = 14; 二者是等效的。
#include &lt;stdio.h&gt; int main() { int const a = 5; a = 6; printf("Hello, World! %d\n", a); return 0; } 运行结果如下：
const修饰的变量真的不能改吗？
其实，在gcc环境下，const修饰的变量其实是可以改的。
在某些单片机环境下，const修饰的变量是不可以改的。
const修饰的变量到底能不能真的被修改，取决于具体的环境，C语言本身并没有完全严格一致的要求。
在gcc中，const是通过编译器在编译的时候执行检查来确保实现的（也就是说const类型的变量不能改是编译错误，不是运行时错误。）所以我们只要想办法骗过编译器，就可以修改const定义的常量，而运行时不会报错。
更深入一层的原因，是因为gcc把const类型的常量也放在了data段，其实和普通的全局变量放在data段是一样实现的，只是通过编译器认定这个变量是const的，运行时并没有标记const标志，所以只要骗过编译器就可以修改了。
由于常量一旦被创建后其值就不能再改变，所以常量必须在定义的同时赋值（初始化），后面的任何赋值行为都将引发错误。
在C语言中，单独定义 const 变量没有明显的优势，完全可以使用#define命令代替。const 通常用在函数形参中，如果形参是一个指针，为了防止在函数内部修改指针指向的数据，就可以用 const 来限制。
在C语言标准库中，有很多函数的形参都被 const 限制了，下面是部分函数的原型：
size_t strlen ( const char * str ); int strcmp ( const char * str1, const char * str2 ); char * strcat ( char * destination, const char * source ); char * strcpy ( char * destination, const char * source ); int system (const char* command); int puts ( const char * str ); int printf ( const char * format, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1d5cb0cca601714b364862bca3d0791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b8f97b36c1ece01712c84caebe5d121/" rel="bookmark">
			LTE(4G) - NR(5G) RSRP和SINR RSRQ RSSI LTE信号质量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RSRP RSRP (Reference Signal Receiving Power，参考信号接收功率) 是LTE网络中可以代表无线信号强度的关键参数以及物理层测量需求之一，是在某个符号内承载参考信号的所有RE(资源粒子)上接收到的信号功率的平均值。
用处和规范都等同于WCDMA中的RSCP（Received Signal Code Power）接收信号码功率。
百度百科
SINR SINR：信号与干扰加噪声比 （Signal to Interference plus Noise Ratio）是指接收到的有用信号的强度与接收到的干扰信号（噪声和干扰）的强度的比值；可以简单的理解为“信噪比”。
百度百科
RSRQ RSRQ（Reference Signal Receiving Quality）表示LTE参考信号接收质量，这种度量主要是根据信号质量来对不同LTE候选小区进行排序。这种测量用作切换和小区重选决定的输入。
RSRQ被定义为N*RSRP/(LTE载波RSSI）之比，其中N是LTE载波RSSI测量带宽的资源块（RB）个数。RSRQ实现了一种有效的方式报告信号强度和干扰相结合的效果。 [1]
取值范围：-3~-19.5 ，绝对值越小越好。
百度百科
RSSI Received Signal Strength Indication接收的信号强度指示，无线发送层的可选部分，用来判定链接质量，以及是否增大广播发送强度。
通过接收到的信号强弱测定信号点与接收点的距离，进而根据相应数据进行定位计算的一种定位技术。如无线传感的ZigBee网络CC2431芯片的定位引擎就采用的这种技术、算法。接收机测量电路所得到的接收机输入的平均信号强度指示。这一测量值一般不包括天线增益或传输系统的损耗。
百度百科
根据中国移动测试要求|：
极好点： RSRP&gt;-85dBm； SINR&gt;25
好点： RSRP=-85～-95dBm；SINR:16-25
中点： RSRP=-95～-105dBm；SINR:11-15
差点： RSRP=-105～-115dBm；SINR:3-10
极差点： RSRP&lt;-115dB；SINR&lt;3
这些值当然越大越好
PS：LTE常用名词解释
SINR：信号与干扰加噪声比 （Signal to Interference plus Noise Ratio）是
指接收到的有用信号的强度与接收到的干扰信号（噪声和干扰）的强度的比值；
可以简单的理解为“信噪比”。
RSRP：(Reference Signal Receiving Power，参考信号接收功率) 是LTE网络中可
以代表无线信号强度的关键参数以及物理层测量需求之一，是在某个符号内承载参
考信号的所有RE(资源粒子)上接收到的信号功率的平均值。
RSRQ:（Reference Signal Receiving Quality）表示LTE参考信号接收质量，这种度量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b8f97b36c1ece01712c84caebe5d121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f51b3aac709c729b098b676555ff608/" rel="bookmark">
			Open3d 使用marching cubes生成3D模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用python 3.9.12
如果没有open3d
pip install open3d
需要的头文件：
import numpy as np import torch import open3d as o3d from skimage import measure 通过open3d 导入数据
points=o3d.io.read_point_cloud(file) 创建体素网格，大小以最大最小X,Y,Z创建一个立方体，然后进行创建三维数组体素化，存储数据为，点云表面为1，其他元素为0.
def pcd_to_voxel_grid(pcd, voxel_size=1.0): points = np.asarray(pcd.points) min_bound = np.min(points, axis=0) max_bound = np.max(points, axis=0) dims = np.ceil((max_bound - min_bound) / voxel_size).astype(np.int) voxel_grid = np.zeros(dims, dtype=np.uint8) for point in points: indices = np.floor((point - min_bound) / voxel_size).astype(np.int) voxel_grid[tuple(indices)] = 1 return voxel_grid,voxel_size,min_bound #返回体素网格，体素间隔大小，以及最小的体素编号 重建曲面：
vertices, faces, _, _ = measure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f51b3aac709c729b098b676555ff608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b99584cf0bec7e861188c25ab200996c/" rel="bookmark">
			操作系统 实验六内存管理(验证类实验)-存在的问题-2023-6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的 了解 Windows 的内存结构和虚拟内存的管理，理解进程的虚拟内存空间和物理内存的映射关系。加深对操作系统内存管理、虚拟存储管理等理论知识的理解。
二，Codeblocks运行程序 报错1： ||=== 构建文件: "无目标" 在 "无项目" 中 (编译器: 未知的) ===|
undefined reference to `__imp_StrFormatByteSizeA'|
undefined reference to `__imp_PathStripPathA'|
undefined reference to `__imp_StrFormatByteSizeA'|
undefined reference to `__imp_StrFormatByteSizeA'|
||error: ld returned 1 exit status|
||=== 构建 失败: 5 error(s), 0 warning(s) (0 分, 1 秒) ===|
因为没链接库在左侧点击 -设置-编译器-链接器设置-添加-找到MinGW的库文件libshlwapi.a
报错2： 'LPCVOID' {aka 'const void*'} to 'DWORD' {aka 'long unsigned int'} loses precision [-fpermissive]|
所有报错的位置的 DWORD 改成 DWORD64
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b99584cf0bec7e861188c25ab200996c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3bc5b1b68c064c1e2608d3a449f2a95/" rel="bookmark">
			Lambda表达式之【Collectors.toMap()】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lambda的表达式之Collectors.toMap() Hello!~ 小伙伴们
最近的自己博客写的可以说是很少了,也没有进行自我提升学习,总是在堕落中.在写此篇时(2023年6月10日14:54:05),我也正在加班
还有,也就是今天:我的好朋友也结婚了!~ 哈哈===&gt;回归正题,今天我们的博客
1.Collectors.toMap()作用 和它的名字差不多,就是将一个对象的list数据集合转换成map的键值对
专业解释: toMap(Function,Function): 返回一个集合Collector,将元素累积到一个Map中,将key和value提供的映射函数应用于输入元素的结果
2.实战操作 为了更深刻的掌握,我们再这用一个例子来进行说明,从而来快速掌握
2.1对象的数据准备 1.首先建一个person类的对象
/** *假设一个对象,与表的数据映射 */ public class Person(){ //id 主键 int id; //姓名 String name; //地址 String address; } 2.根据这个类拿取数据构建List==&gt; 模拟数据的准备
List&lt;Person&gt; list=new ArrayList&lt;&gt;(); //模拟数据 for(int i=1;i&lt;10;i++){ list.add(new Person(i,"测试数据"+i,"地址"+)); } 2.2toMap使用 比如将list转成id为key的Map,value为id对应的’Person’对象
//toMap(key,value) Map&lt;Integer,Person&gt; map=list.stream().collect(Collectors.toMap(Person::getId,Function.identity())); 注意:如果id存在重复值,那么在执行上述时,会报错==&gt; 解决办法 只取前一个key及value：
Map&lt;String, Person&gt; map = list.stream() .collect(Collectors.toMap(Student::getId,Function.identity(),(oldValue,newValue) -&gt; newValue)) 3.补充: groupingBy() 啥意思呢?就是比如我要根据Person 的id和name组合作为key,来进行筛选出一个Map集合,其中的value是id和name的一一对应的list集合
Map&lt;String, List&lt;Student&gt;&gt; map = list.stream().collect(Collectors.groupingBy(dto-&gt;dto.getId()+dto.getName()); 4.过滤去重 比如两个LIST进行去重 直接看当中的关键代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3bc5b1b68c064c1e2608d3a449f2a95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c966841e64b15a22420675d30adb57/" rel="bookmark">
			python-自定义模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python-自定义模块 概念：自定义模块是指由用户创建的Python代码文件，用于组织、封装和重用可执行的代码块。它允许将相关的功能和变量组织在一起，使代码更可维护、可扩展和可复用。
创建和导入模块：
创建模块：创建一个新的Python文件，编写你自己的函数、类或变量，并保存为.py文件。导入模块：在另一个Python文件中，使用import语句导入自定义模块以便使用其中定义的函数、类或变量。 模块结构和命名空间：自定义模块具有自己的命名空间，模块中定义的函数、类和变量在模块命名空间中进行封装。通过使用模块名和点运算符，可以访问模块中的内容。
模块导入方式：
import语句：使用import关键字导入整个模块。例如：import mymodule。from语句：使用from关键字导入模块中的特定函数、类或变量。例如：from mymodule import myfunction。别名：可以使用as关键字为模块或导入的内容指定别名，以便在代码中更方便地引用。例如：import mymodule as mm。 模块搜索路径：Python解释器会按照一定的顺序搜索模块。可以通过sys.path来查看模块搜索路径，也可以将自定义模块所在的目录添加到模块搜索路径中。
__name__变量：__name__是一个内置变量，用于指示当前模块的名称。当一个模块直接执行时，__name__被设置为'__main__'，而当该模块被导入时，__name__被设置为模块的名称。
在Python中，每个模块都有一个内置变量__name__，它用于指示当前模块的名称。该变量的值取决于模块的使用方式，具体如下：
直接执行模块：当一个模块被直接执行时，也就是作为主程序执行时，__name__被设置为'__main__'。这通常是在命令行中通过python module_name.py来执行模块时发生的情况。
导入模块：当一个模块被导入时，__name__被设置为该模块的名称。这意味着模块的代码被导入到另一个Python文件中使用。
这种使用方式使得我们可以根据__name__变量的值来执行特定的代码或模块级别的操作。通常，我们使用__name__变量的值为'__main__'来判断是否是主程序执行，并在需要时执行特定的代码。
下面是一个示例代码，展示了__name__变量的使用：
# mymodule.py def my_function(): print("这是一个函数") print("模块名称:", __name__) if __name__ == "__main__": print("这是主程序") my_function() 在上面的代码中，我们定义了一个名为my_function的函数，并打印了模块的名称__name__。然后，我们使用if __name__ == "__main__":条件语句来检查__name__变量的值是否为'__main__'。如果是，说明当前模块正在作为主程序执行，我们打印了相应的信息并调用了my_function函数。
现在，我们可以在另一个Python文件中导入mymodule模块并观察输出的结果：
# main.py import mymodule print("这是主程序") mymodule.my_function() 当我们运行main.py时，输出结果如下：
模块名称: mymodule 这是主程序 这是一个函数 从输出结果可以看出，在main.py中导入mymodule模块时，__name__变量的值被设置为'mymodule'，而不是'__main__'，因此模块级别的代码块不会被执行。
包：包是包含模块的目录，它允许更好地组织和管理模块。包中必须包含一个__init__.py文件来指示该目录是一个包。
扩展：
__doc__：用于获取模块的文档字符串，也称为模块级别的注释。可以通过help(module_name)或module_name.__doc__来查看和访问。
__file__：提供了模块所在文件的路径。对于内置模块和编译的模块，可能没有该属性。
__all__：用于指定模块的导入行为。如果定义了__all__列表，只有列表中的成员会被导入。如果没有定义__all__，默认情况下，除了以单下划线开头的成员外，所有其他成员都会被导入。
__init__.py：当一个目录作为包使用时，可以在该目录中添加一个名为__init__.py的文件。该文件在包被导入时执行，并用于初始化包的内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e61644f5fd931848658d7b72bb8623e/" rel="bookmark">
			C# 多线程 异步委托BeginInvoke
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异步委托解决了线程池不能返回值的问题，允许双向传递参数，同时可以在调用线程上抛出委托方法中未处理的异常。
实现方式：
创建目标方法的委托，通常是Func类泛型委托。调用委托的BeginInvoke，保存一个IAsyncResult类型的返回值，开始异步执行委托方法。调用委托的EndInvoke，传入保存的IAsyncResult类型对象，等待委托方法完成执行，接收返回值，获取委托方法未处理的异常。 static void Main() { Func&lt;string, int&gt; method = Work; IAsyncResult cookie = method.BeginInvoke ("test", null, null); // // 这里可以并行执行其它任务 // int result = method.EndInvoke (cookie); Console.WriteLine ("String length is: " + result); } static int Work (string s) { return s.Length; } 注：EndInvoke是必须的
参考链接：
C#中的多线程 - 基础知识 - GKarch
相互学习，共同富裕。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd8f83d507f978c48da2c6138800b2ff/" rel="bookmark">
			青龙面板搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好的，以下是使用云服务器搭建青龙面板的详细教程：
步骤一：购买云服务器
首先您需要前往云服务器的销售网站购买一台云服务器，在选择云服务器时，根据您的需求选择不同的配置方案。如果您只需要搭建一个小型的青龙面板，可以选择更为经济实惠的配置方案。
步骤二：登录到服务器
当您购买完云服务器之后，您需要登录到服务器的终端界面。根据您的操作系统的不同，有许多不同的方式来连接到云服务器。如Putty连接，Xshell连接等。
步骤三：安装 Docker
要搭建一个青龙面板，您需要为您的云服务器安装Docker，这是一个非常重要的步骤。安装 Docker 将使您能够在服务器上运行容器，而青龙面板就是运行在容器中的。在 Linux 系统中安装 Docker 也非常简单，只需运行以下命令：
```
curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
```
步骤四：安装 Docker Compose
Docker Compose 是一个工具，用于在 Docker 容器中运行多个容器。要在云服务器上安装青龙面板，您还需要安装 Docker Compose。可以通过以下命令安装 Docker Compose：
```
sudo curl -L "https://github.com/docker/compose/releases/download/1.25.3/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
```
步骤五：下载青龙面板镜像
运行以下命令，通过 Docker 下载最新版的青龙面板镜像：
```
docker pull whyour/qinglong:latest
```
如果需要特定版本的青龙面板，可以使用以下命令：
```
docker pull whyour/qinglong:xxx
```
请将 “xxx” 替换为所需要的青龙面板版本号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd8f83d507f978c48da2c6138800b2ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f35a4d21c87f616fe75f6ef3a3c38e2b/" rel="bookmark">
			Vue引入VantUI框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档：Vant 2 - Mobile UI Components built on Vue
方式一：自动按需引入组件 第一步：安装vant-ui
yarn add vant@latest-v2 第二步：引入vant-ui
//安装按需引入插件 yarn add babel-plugin-import -D 在babel.config.js中配置
// 在 babel.config.js 中配置（vant按需引入的插件配置） module.exports = { plugins: [ ['import', { libraryName: 'vant', libraryDirectory: 'es', style: true }, 'vant'] ] }; 在/src/main.js中引入
//按需引入vant-ui组件 import { Button, Rate } from 'vant'; //引入CSS import 'vant/lib/index.css'; Vue.use(Button).use(Rate); 第三步：打开官网复制代码，粘贴到需要用组件的地方
方式二： 导入所有组件 直接在/src/main.js中引入
import Vue from 'vue'; import Vant from 'vant'; import 'vant/lib/index.css'; Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f35a4d21c87f616fe75f6ef3a3c38e2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72d15d50dfd8058f921e7ba9ecc9ab9c/" rel="bookmark">
			gdb远程使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.编译时加-g
2.gdbserver + gdb 远程调试
prebuilts/toolchains/mips-gcc720-glibc226/mips-linux-gnu/libc/mfp64/usr/bin/gdbserver 把它拷贝到target
3.target
gdbserver 宿主机 IP:端口号 要调试的可执行程序
#./gdbserver 192.168.0.240:50555 ./cloud_sound_dance
4.host
mips-linux-gnu-gdb 要调试的可执行程序
#mips-linux-gnu-gdb tmp_files/cloud_sound_dance
target remote 目标板 IP:端口号
(gdb) target remote 192.168.0.174:50555
5.设置断点,运行：
(gdb) b App.cpp:308
Breakpoint 1 at 0x454834: file ../App.cpp, line 308.
(gdb) r
The "remote" target does not support "run". Try "help target" or "continue".
(gdb) continue
Continuing.
(gdb) info breakpoints
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1deff96644b45673819f3070aaf9c535/" rel="bookmark">
			C&#43;&#43; OBS源码分析与屏幕录制软件开发视频教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本课程主要讲解OBS源码的编译，OBS功能实现，初始化，显示器录制，窗口的实现录制，以及录制模块源码详细分析，最后基于OBS源码开发了一个录制软件，界面如下：
主要有如下功能
（1）实现桌面，显示器采集、录制
（2）指定应用程序窗口进行录制
（3）可以选择系统声音，麦克风进行录制
（4）稳定fps 60，高清原画，鼠标不闪，、音视频同步，无卡顿，无延时
（5）可以指定帧率录制，5-60 fps都可以
（6）显示了系统托盘，录制时可以最小化到系统托盘
课程链接：
CSDN学院 https://edu.csdn.net/course/detail/36019?spm=1001.2014.3001.5507
51CTO学院 https://edu.51cto.com/course/29381.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/126/">«</a>
	<span class="pagination__item pagination__item--current">127/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/128/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>