<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8343f3ac25c3cfd9975d6d2a1998fc82/" rel="bookmark">
			windows环境下apache服务器能够正常启动，但是无法访问到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、防火墙问题 进入bin目录
之后输入http.exe -k start来启动apache,在这里就会有防火墙相关通知跳出来。在这里点确定之后，重启apache服务器就可以正常访问了。
2、端口被占用的问题 老生常谈，修改httpd.conf文件中的相应端口号就可以了,把80改成不冲突的端口号。
最后一定要重启apache服务器！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d678c1af0289f72b586bdd8a853c53/" rel="bookmark">
			2021-07-21
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于老旧主板NVME的支持 先贴上连接：https://cloud.189.cn/t/EB7nMzuyIz2a (访问码:gv7e)
这里主要是两个主板：ga-b75m-d3v_v2.x_fd和ga-z87x-ud3h_f7，其他的主板如果想加入nvme支持，那么请搜索相关文章，工具（包含nvme模块，优限推荐NvmExpressDxe_Small_Compressed.ffs压缩版本）在网盘已经提供了，按照教程操作就好了，不过如果是我用的上述两块主板，就可以直接使用了，目前这两个主板一直在跑着，没什么问题。
如果网上实在搜不到自己主板型号，可以把原主板的bios导出，然后把nvme模块加入后再刷进去即可。
注意刷bios有风险，操作需谨慎。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31df65e61dd367bea44606fe0d4e8fb7/" rel="bookmark">
			Complex Spectral Mapping With Attention Based Convolution Recurrent Neural Network（省略）---论文翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于注意力的卷积递归神经网络的复杂频谱映射，用于语音增强 Liming Zhou1, Yongyu Gao1,Ziluo Wang1,Jiwei Li1,Wenbin Zhang11CloudWalk Technology Co., Ltd., Shanghai, China 1fzhouliming,gaoyongyu,wangziluo,lijiwei,zhangwenbing@cloudwalk.cn
摘要
语音增强已经从深度学习在可懂度和感知质量方面的成功中获益。传统的时频（TF）域方法侧重于通过天真卷积神经网络或递归神经网络来预测TF掩码或语音频谱。最近的一些研究是基于复杂频谱映射卷积递归神经网络（CRN）。这些模型直接从编码器层的输出和解码器层的输入跳过，这可能是不周到的。与CRN模型相比，所提出的CARN模型在PESQ、CBAK、COVL、CSIG和son等几个指标上相对提高了10%以上，并且在DNS Challenge 2020的实时和非实时跟踪中，这些指标都优于第一名的模型。
关键词： 语音增强，CRN，注意力机制，DNSMOS，PESQ
1. 绪论
增强技术对于改善经典的语音增强技术至关重要，包括频谱减法[2]、维纳滤波[3]、最小均方误差(MMSE)估计器[4]和优化修正的对数光谱振幅语音估计器[5]。这些基于时频域的信念方法在静止噪声环境中取得了相对较好的性能，而在处理大多数场景中的非静止噪声时却不够强大。
在过去的几年里，深度神经网络（DNNs）极大地评估了语音增强的性能[6]。与传统技术相比，现有的DNN方法提供了更好的结果。在[7][8]中，递归神经网络（RNNs）被用来模拟时间特征。在[9]中，自动编码器被用于语音增强，而第一个语音增强基准将DNN作为非线性回归函数[10]。卷积递归神经网络（CRN）被用来提取长文信息[11]。 语音增强技术也以图像合成为例，使用生成对抗网络（GAN）架构来重建目标语音信号[12-16]。这些基于DNN监督的语音增强方法比传统的算法更有优势。
最近，U-net结构取得了巨大的成功，在各种机器学习任务中，包括医疗诊断[17]、语义分割[18]、歌唱源分离[19]等，其性能已经超过了基本的DNN架构。在这种成功的激励下，语音增强在原始波形[12, 20-22]和时间频率特征[23]中都探索了U-net结构。在[24]中，Wave-U-Net在编码器和解码器中采用了GLU的激活，以及中间的双向LSTM。DCCRN[25]利用U-net和深度复杂网络[26]的优势进行去噪。注意力单元和U-net的结合使语音增强的性能更上一层楼。自我注意是一种有效的上下文信息聚合机制，它对输入序列本身进行操作，可以用于任何有顺序输入和输出的任务。注意力波浪网[27]在语音银行语料库（VCTK）数据集上的表现超过了所有其他已发表的语音增强方法。
基于掩码的目标，描述了干净的语音和背景噪声之间的时间-频率关系，被用来训练网络。通常情况下，由理想二进制掩码（IBM）[28]、理想比率掩码（IRM）[29]和频谱幅度掩码（SMM）[30]组成的矩阵只考虑清洁波形和混合音频之间的幅度。随后，相位被考虑在内，其中相位敏感掩码(PSM)[31]是第一个显示相位信息可行性的方法，复数比掩码(CRM)[32]被宣布可以通过同时增强清洁语音和混合语音频谱图的实部和虚部来正确地重构语音。此后不久，CRN[33]使用一个编码器和两个解码器进行复数频谱映射（CSM），以巧合地估计混合语音的实数和虚数频谱。值得注意的是，CRM和CSM拥有语音信号的全部信息，因此它们在理论上可以实现最佳的甲骨文语音增强性能。
在本文中，我们提出了一个名为CARN的网络，该网络融合了U-net、注意力机制、跳过连接、编码-解码器之间的LSTM和时频域的CRM等高效组件。我们还研究了将门卷积网络与CARN模型结合起来，形成一个名为GCARN的模型。我们表明，根据2020年DNS挑战赛[34]的语音质量指标（PESQ等）和Valentini[35]发布的数据集，在时频域中利用注意力-LSTM-UNET的CRM取得了明显的改进效果，超过了这些数据集上其他已发表的语音增强方法。
2. CARN模型
CRN模型首先由Ke Tan[36]提出，并进一步研究了复杂频谱映射[33]机制和门卷积[37]。根据上述研究，我们研究了一个名为CARN的新模型，它将CRN与注意力机制相结合。在CARN模型中，我们使用了基于注意力的编码层到解码层的跳过连接。此外，我们将我们提出的模型与基于门卷积的CRN模型以及以前的一些工作进行了对比。
2.1. CARN结构
编码器和解码器都由6个具有PReLU激活函数的Conv2d块组成，旨在从输入特征中提取高张力的特征，并降低分辨率。该模型如图1所示。我们将频谱特征作为输入。LSTM层的隐藏大小为512，T-F核大小为3，跨度为1∗2，每个Conv2d或ConvTranspose2d层。每个Conv2d或ConvTranspose2d层之后都有一个batchnorm层。在最后一个ConvTranspose2d层之后嵌入一个线性层，以映射输出特征的复数比率掩码（CRM）。最后，CRM与输入的stft频谱图相乘，得到干净的stft频谱图，参考（4）和（5）。所有的激活函数都是PReLU。
2.2 注意机制
与传统的CRN结构不同，自我注意掩码通过跳过连接与编码器的输出相乘。注意层的输出与最后一个解码器的输出相连接，用于下一个解码器的输入。
图2中描述了AttentionBlock[27]。Ui是编码器结构的输出，Ci是LSTM层或解码器卷积层的输出。另外两个2维卷积，核大小为3，输出通道为输入通道的两倍，称为Wg和Wx，用于将Ui和Ci映射到高维空间特征，用于建立注意力机制模型。高维空间特征的分值是Ci分值的两倍；高维空间特征层的输出可以描述为（1）:
其中Ui和Ci分别表示编码器和解码器的第i层。 σ是sigmoid函数。自我注意区块的输出，其中Wf表示另一个2维卷积层。
2.3. 培训目标
CARN估计CRM，并通过信号逼近（SA）进行优化。给定干净语音S和噪声语音Y的复变STFT频谱图，CRM可以定义为
其中，Yr和Yi分别指的是噪声复数频谱的实部和虚部，Sr和Si同样指的是干净复数频谱的实部和虚部，让Sr和Si分别指的是估计去噪音频复数频谱的实部和虚部。 Mr和Mi表示CRM的实部和虚部，那么
2.4. 损失函数
我们用损失函数训练模型为
其中S^和S分别表示估计去噪音频和清洁音频。S0:3 = jSj0:3ej\S ,是功率压缩的STFTs。这个损失函数由谱图MSE（均方误差）和功率压缩STFTs MSE组成。
3. 经验
3.1. 数据集
在我们的实验中，我们在两个数据集上评估所提出的模型。
3.1.1. 数据集1：噪声语音数据库
第一个数据集1，是由Valentini等人发布的[35]。[35]，广泛用于语音增强研究，它对不同说话人的各种类型的噪声进行了概括。这个数据集包括48kHz采样频率的干净和嘈杂的音频数据，在训练和测试时需要降频到16kHz。干净的数据集是来自各种文本段落的句子录音，并从Voice Bank语料库[38]中选择了30个英语演讲者，包括有各种口音的男性和女性。28个和2个说话者分别被分配到训练和测试集。测试集由20种不同的噪声条件组成，其中5种噪声来自DEMAND数据库，产生824个测试项目，每个测试者在每种条件下大约有20个不同的句子。[35]
3.1.2. 数据集2：DNS 2020
第二个数据集是基于Interspeech 2020 DNS挑战赛数据集提供的数据[34]。DNS挑战赛数据集包括180小时的噪声集，其中包括150个类别和65,000个噪声片段，以及超过500小时的干净语音，其中包括来自2150个发言人的音频片段。清晰的语音数据集来自名为Librivox的公共有声读物数据集。噪声片段选自Audioset和Freesound。我们随机选择了24000个带有所有噪声片段的演讲者，创建了200小时的噪声训练集，单噪声范围从0dB到40dB。每个被选中的演讲者的音频片段都被串联成30秒，同时混合各种噪声片段。我们用DNS-Challenge无盲点测试数据集和盲点测试数据集来评估所提出的模型。这两个数据集都包括合成数据集和真实录音。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31df65e61dd367bea44606fe0d4e8fb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059d423037d9bbc09e0ac8b7a081fccc/" rel="bookmark">
			32位计算机的字长是多少个字节,32位计算机中，一个字长等于多少个字节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019-07-19
32位计算机中，一个字长等于32位，一个字节是8位，所以从长度来说一个字长等于4个字节。字长简介：在同一时间中处理二进制数的位数叫字长。通常称处理字长为8位数据的CPU叫8位CPU，32位CPU就是在同一时间内处理字长为32位的二进制数据。
二进制的每一个0或1是组成二进制的最小单位,称为位(bit)。 字长：一般说来，计算机在同一时间内处理的一组二进制数称为一个计算机的“字”，而这组二进制数的位数就是“字长”。
字长与计算机的功能和用途有很大的关系，是计算机的一个重要技术指标。字长直接反映了一台计算机的计算精度，为适应不同的要求及协调运算精度和硬件造价间的关系，大多数计算机均支持变字长运算，即机内可实现半字长、全字长(或单字长)和双倍字长运算。
在其他指标相同时，字长越大计算机的处理数据的速度就越快。早期的微机字长一般是8位和16位，386以及更高的处理器大多是32位。目前市面上的计算机的处理器大部分已达到64位。
字长由微处理器对外数据通路的数据总线条数决定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46d5cc9dc4c4109488266a2747a23990/" rel="bookmark">
			互联网家装“顶流”土巴兔，拟登陆A股创业板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，据深交所披露，土巴兔集团股份有限公司的创业板上市申请已获受理。在互联网家装行业深耕，土巴兔正冲刺A股“互联网家装第一股”。近年来，土巴兔不断升级用户体验，利用平台大数据，通过智能匹配系统为用户与装修公司之间建立精准连接，并积极对接增值服务，为用户提供高效、便捷、有保障的家装服务。
据悉，土巴兔诞生于2008年，到去年年底，累计合作逾11万家装修公司，登记业主需求4100多万，业务覆盖国内300多个城市。
家装用户在土巴兔的线上平台，可以根据自己的需求获得一站式家装解决方案，包括信息发现、与服务供应商智能匹配、项目执行及质检等。而服务供应商则可以在平台获得订单推荐、会员服务、贷款推介服务及保险推广和供应链管理解决方案。在同平台的多边连接中，土巴兔构建了精准流量、保障交易、赋能行业的生态闭环。据招股书显示，在过去三年里，土巴兔的净利润保持增长态势，由3862.97万元增至8659.75万元，复合年增长率达30.88%。
土巴兔的良好口碑离不开其坚守用户第一的初心。买房装修是人生大事，需要谨慎认真对待，但由于经验不足或是专业了解少，不少业主常会在家装过程中遇到工程质量、装修增项、报价问题等“隐形深坑”。针对此类问题，今年5月土巴兔全面升级保障型服务，其中包括先装修后支付、全程质检、正品辅材、陪同签约等，为家装用户提供了整个家装阶段的无忧服务，给予家装用户满满的安全感。
正是土巴兔长期的精细化运营，为无数用户带来了良好家装体验。如今土巴兔积累了大量用户数据和优质的家装内容，包括超过810多万篇的装修日记、问答，950多万幅的装修效果图以及170多万例的家装实例，累计服务逾 3500 万用户。
面对家装行业的调整和革新，土巴兔用其多年来深耕行业的经验和始终“以人为本”的服务理念深度赋能行业产业链。在未来，土巴兔势必继续以互联网家装顶流的姿态引领行业发展，不断探索和构建行业良性生态。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84b2c68b5c0823ba5103844d64d0b8f2/" rel="bookmark">
			vue 脚手架修改默认配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要点：
在vue.config.js里配置lintOnSave :false关闭语法检查
如果修改mian.js的名字就会报错
这是因为在webpack ===&gt;创建中有webpage.config.js,进行了相关的配置
对其文件进行打开,并搜main.js
index.html 而且在这文件里修改了也没用,只是用来修改的
下图红色框文件名不能改,粉色框可以改
在vue官网cli配置
可以看到的就可以改
修改方法：创建与webpage.json同级的vue.config.js
这边要区分,红色框的是对vue运行的调整
而绿色框则是对脚手架的调整 page一般都是对一些入口的修改
复制到vue.config.js文件上,发现这边使用的是common暴露,因为webpage写node.js使用的就是common暴露,所以,其实就是把要修改的内容写在vue.config.js文件上,之后脚手架会让它和核心的配置文件对比,进行修改,保护核心配置文件的安全性。
然后我们验证：
修改入口路径,而且当修改了vue.config.js文件后,必须对项目进行重新启动, npm run serve才行
启动成功
：
注：
但是千万不要在里面一个配置项都不写,或者注释掉也不行,否则就会报错
语法检查
只要一开始创建项目的时候,配置了eslint就会有自动检查语法,如果定义了一个方法或者变量等等不用也会报错
eslint jslint jshint就是用于语法检查的
怎么把它关闭
使用intOnSave
在vue.config.js里配置lintOnSave :false关闭语法检查
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/715512e8c5a86028982fb422784ae9e3/" rel="bookmark">
			python:程序练习—猜数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 系列文章目录 文章目录 系列文章目录前言一、题目二、过程1.代码 三、测试图 前言 新手小白上路，献上我练习的题目，一般都是能够跑通的
一、题目 猜数字，数字随机产生，共三次机会:
猜错有错误提示，猜对bingo并结束
二、过程 1.代码 代码如下：
import random num=int(input("你猜猜我想的是什么数字呀？（悄悄给个提示，是个正整数哦）\n三次机会，把握好哦\n第1次猜测：")) secret=random.randint(1,10) i=1 while i&lt;=3: if num!=secret: if num&lt;secret: print("猜小了呢~") else: print("哎呀呀，猜大啦！") else: print("BINGO!") break i = i + 1 if i!=4: print("第{0}次猜测：".format(i)) num =int(input()) else: print("哦~答案是{0}，都没猜对呢/(ㄒoㄒ)/~~".format(secret)) print("游戏结束！") 三、测试图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed32dfbc9eb27e2be505219671143c62/" rel="bookmark">
			类型的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 double 转换成 int
Scanner in = new Scanner(System.in); int foot; double inch; System.out.println((int)((foot+inch/12)*0.3048*100)); int 转换成 double
Scanner in = new Scanner(System.in); int foot; int inch; System.out.println((foot+inch/12.0)*0.3048); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41ecfda22e4d223f6c37349c3604811a/" rel="bookmark">
			Redis源码zmalloc内存管理(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zmalloc内存管理(2)(Redis源码学习) 1. 背景介绍 在上一篇zmalloc内存管理(1)中留了一个问题，在 zmalloc 函数中用出现了条件编译，涉及到是否定义 HAVE_MALLOC_SIZE:
#ifdef HAVE_MALLOC_SIZE update_zmalloc_stat_alloc(zmalloc_size(ptr)); return ptr; #else *((size_t*)ptr) = size; update_zmalloc_stat_alloc(size+PREFIX_SIZE); return (char*)ptr+PREFIX_SIZE; #endif 如果你所使用的环境编译redis时，根据所在Linux编译环境会检测到是否定义 HAVE_MALLOC_SIZE，然后决定执行时走哪一部分代码。
下面就 HAVE_MALLOC_SIZE 进行相关介绍。
2. 编译选项 下面是redis对应src目录下面的Makefile文件中的部分片段，进行说明
uname_S := $(shell sh -c 'uname -s 2&gt;/dev/null || echo not') # Default allocator ifeq ($(uname_S),Linux) MALLOC=jemalloc else MALLOC=libc endif # Backwards compatibility for selecting an allocator ifeq ($(USE_TCMALLOC),yes) MALLOC=tcmalloc endif ifeq ($(USE_TCMALLOC_MINIMAL),yes) MALLOC=tcmalloc_minimal endif ifeq ($(USE_JEMALLOC),yes) MALLOC=jemalloc endif uname_S 那一句就是执行sh命令，在RHEL6.9中然后得出变量uname_S值为Linux，可以将改行括号里的命令直接拷贝到Linux命令行进行执行，就能看到结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41ecfda22e4d223f6c37349c3604811a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38f30868c6bb634971d9054f95eb38fb/" rel="bookmark">
			jpa简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JPA是什么 1、JPA简介 JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象-关系表的映射关系，并将运行期的实体对象持久化到数据库中。
2、JPA 提供商 Hibernate JPA是需要Provider来实现其功能的，Hibernate就是JPA Provider中很强的一个，应该说无人能出其右。从功能上来说，JPA就是Hibernate功能的一个子集。
Spring Spring + Hibernate 常常被称为 Java Web 应用人气最旺的框架组合。而在 JCP 通过的 Web Beans JSR ，却欲将JSF + EJB + JPA
OpenJPA OpenJPA 是 Apache 组织提供的开源项目，它实现了 EJB 3.0 中的 JPA 标准，为开发者提供功能强大、使用简单的持久化数据管理框架
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c9f5be008a58c4f5e4fed9599d8a7b0/" rel="bookmark">
			修改input中placeholder样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现方法： 使用::placeholder”选择器
::placeholder是css3新增的选择器,可能存在一定的浏览器兼容问题，所以最好加上不同的前缀 -ms- 、 -webkit- 、-ms- 等
input::placeholder { font-weight: 400; color: #624b2f; } //::-webkit-input-placeholder/* WebKit, Blink, Edge */ //:-moz-placeholder/* Mozilla Firefox 4 to 18 */ //::-moz-placeholder /* Mozilla Firefox 19+ */ //:-ms-input-placeholder /* Internet Explorer 10-11 */ //::-ms-input-placeholder /* Microsoft Edge */ 这样就可以设置placeholder的字体大小、颜色的样式了
如果是微信小程序修改input中placeholder样式的话可以有两种：
1、使用placeholder-class
wxml中：
&lt;input type="text" placeholder="这里是placeholder的内容" placeholder-class="placeholderClass"/&gt; wxss中：
.placeholderClass{ font-weight: 400; color: #624b2f; } 2、使用placeholder-style
wxml中：
&lt;input type="text" placeholder="这里是placeholder的内容" placeholder-style="color: #624b2f;"/&gt; 感觉就跟一个用类名一个用内联样式一样
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d23828106f4e9022b56c1ab88d4493b/" rel="bookmark">
			锂电池的充电原理以及快充原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料：
电池研究 | 锂离子电池快充原理
解析锂电池的充电的整个过程！
1. 锂电池充电过程 锂离子电池的充电过程可以分为四个阶段：涓流充电（低压预充）、恒流充电、恒压充电以及充电终止。
锂电池充电器的基本要求是特定的充电电流和充电电压，从而保证电池安全充电。增加其它充电辅助功能是为了改善电池寿命，简化充电器的操作，其中包括给过放电的电池使用涓流充电、电池电压检测、输入电流限制、充电完成后关断充电器、电池部分放电后自动启动充电等。
锂电池的充电方式是限压恒流，都是由IC芯片控制的，典型的充电方式如下：
先检测待充电电池的电压，如果电压低于3V，要先进行预充电，充电电流为设定电流的1/10，电压升到3V后，进入标准充电过程。标准充电过程为：以设定电流进行恒流充电，电池电压升到4.20V时，改为恒压充电，保持充电电压为 4.20V。此时，充电电流逐渐下降，当电流下降至设定充电电流的1/10时，充电结束。
具体充电曲线见下图：
阶段1：涓流充电——涓流充电用来先对完全放电的电池单元进行预充(恢复性充电)。在电池电压低于3V左右时采用涓流充电，涓流充电电流是恒流充电电流的十分之一即0.1c(以恒定充电电流为1A举例，则涓流充电电流为100mA)，
阶段2：恒流充电——当电池电压上升到涓流充电阈值以上时，提高充电电流进行恒流充电。恒流充电的电流在0.2C至 1.0C之间。电池电压随着恒流充电过程逐步升高,一般单节电池设定的此电压为3.0-4.2V.
阶段3：恒压充电—— 当电池电压上升到4.2V时，恒流充电结束，开始恒压充电阶段。电流根据电芯的饱和程度，随着充电过程的继续充电电流由最大值慢慢减少，当减小到0.01C时，认为充电终止。（C是以电池标称容量对照电流的一种表示方法，如电池是1000mAh的容量，1C就是充电电流1000mA。）
阶段4：充电终止——有两种典型的充电终止方法：采用最小充电电流判断或采用定时器(或者两者的结合)。最小电流法监视恒压充电阶段的充电电流，并在充电电流减小到0.02C至0.07C范围时终止充电。第二种方法从恒压充电阶段开始时计时，持续充电两个小时后终止充电过程。
上述四阶段的充电法完成对完全放电电池的充电约需要2.5至3小时。高级充电器还采用了更多安全措施。例如如果电池温度超出指定窗口(通常为0℃至45℃)，那么充电会暂停.
充电结束后,如检测到电池电压低于3.89V将重新充电。
2. 锂电池快充原理 各大手机厂商都推出了自家的快充技术，其原理是提高充电的电流和电压，来实高功率充电。简单来说，充电端口的输入功率=输入电压 x 输入电流。一般手机充电器会有一个充电曲线，通过控制不同的电压和电流，来实现最高的充电效率。
普遍来说，最高效的方式开始都是恒流充电（充电速度较快），然后是恒压充电（充电速度下来了，因为电池本身的电压上去了），最后是涓流充电（在充满电后，补偿因自放电而造成的容量损失）。
现在大多数手机使用的都是采用高通Quick Charge充电技术来实现，从最开始的1.0标准，到现在最新的4.0标准，标准越高充电效率越高。QC 1.0突破USB-IF关于USB Battery Charge 1.2的协议，电压电流提升到5V2A，充电时间缩短40%。快充真正意义上的提升是从QC 2.0开始，通过握手协议，让充电器与手机互相识别，握手后再提高传输电压，最高可达20V，虽然电流不变，但充电的效率提升了近75%。QC 3.0则是在2.0的基础上，引入最佳电压智能协议（INOV）算法，准确控制充电的电压，输入电压达到了200mV一档的自适应调节，性能有了近38%的提升同时降低了损耗，此时凭借电压的可控，电流提升至3A。
上图中横坐标为时间，纵坐标为锂电池电压。由于锂电池的特殊性，过压或者欠压都会导致电池报废，所以现在的锂电池充放电保护电路原理就是测量锂电池电压，再根据电压判断锂电池是否处于正常状态（非过压、非欠压）。
锂电池的充电电流如上图粉红色线所示。锂电池的充电分为三个阶段，分别是恒流预充电、大电流恒流充电与恒压充电。当电压低于3.0V时，充电器会采用100mA电流对锂电池进行预充电，就是上图C C Pre-charge阶段，中文名字叫恒流预冲电阶段，目的是慢慢恢复过放电的锂电池，是一种保护措施来的。合格的充电器都会有这个充电阶段。
然后与问题有关的就来了。当锂电池电压高于3.0V时，就进入到第二阶段，大电流恒流充电阶段（C C Fast charge）。由于锂电池经过第一阶段的预充，其状态已经比较稳定了（预充阶段的作用可以这样理解，但并不严谨）。所以在第二阶段，充电电流就可以适当提高，根据不同的电池来说，这个电流的大小可以从0.1C到几C不等，其中C是指电池容量，如2600mAh的锂电池，0.1C就是指260mA大小的电流。在这一个充电阶段中，国家建议的标准充电是用0.1C电流进行充电的，这个就是标准充电。不过标准充电这个标准由于提出的时间很早，十几年前的就提出来。那时候因为锂电池技术远远不如现在稳定（不允许大电流充电），所以才会有这样一个标准~~~采用标准充电的唯一好处就是充电过程稳定，发生爆炸之类的几率非常小；缺点就是费时间！
而快速充电，就是指在这个阶段用大于0.1C的电流进行充电。如果锂电池容量为2600mAh，那么标准充电的电流为260mA，只要充电电流大于260mA，就可以定义为快速充电了。不过就从目前的锂电池水平与充放电管理芯片的水平来说，用1C的电流充电都没问题。所以快速充电也没有想象中的那么危险。
一般快速充电的充电电流为0.2~0.8C，所以快速充电还是安全的。由于近几年来的提升，现在的充电器基本上都是快充类型的。而锂电池充电的最后一个阶段为恒压充电阶段，这个阶段就是检测到锂电池电压等于4.2V时，充电器则进入恒压充电模式，这个阶段充电电压恒定为4.2V，充电电流则越来越小（慢慢充满了，电流肯定变小~）。当充电电流小于100mA时，就判断电池充满，切断充电电路。
这一阶段的特性，也可以解释为什么手机指示充满电后，拔出USB线再插进去，手机又显示继续充电。另外，需要说一下的是：以上的充电是针对于单节锂电池的最理想充电过程，目前的合格锂电池充放电保护板都是这样子工作的。
电瓶车的电瓶一般有铅酸蓄电池和锂电池两种。这些电瓶都是由若干的电池成组而成的（铅酸蓄电池类型的由6个或者8个串并联组成；锂电池类型的则由若干个锂电池串并联组成）。而涉及到电池组的充电方式，这里又有另外的一个大问题了，就是电池均衡问题。
3. 结论 快速充电是指充电电流大于0.1C的充电方式，这种充电方式对于单个锂电池来说，对寿命与稳定性等的影响非常小；但是如果对于电瓶车电池组来说的话，快充就是用时间换取电池寿命的一种行为。
使用标配充电器对电瓶车充电没问题，但是对于那些打着10分钟充满电的充电站来说，就要注意了，使用这些充电站绝对大大影响电池寿命。另外，对于电池组来说，电池均衡意义更重要。快充对电池组的寿命有影响正是因为电池组均衡问题没有解决。
锂电池不能冲的很满，因为冲的满会导致阴极阳极见的隔离层被形成的dendrite穿透，这样子电池就废了。真正在使用中对电池影响寿命的是散热管理和单个电池的充放电管理，也就是均衡管理。过快速的充电会散发大量的热，肯定会减少电池使用寿命，但是在平时使用中不科学的管理模式对电池的损伤其实更大。
电池快充一定伴随着大电流，随之而来的发热不可避免，然而发热一定会带来电解液的挥发，所以快充一定是减小电池寿命的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51ddb1aea0576d856f651ebfa482bc76/" rel="bookmark">
			win10计算机本地无法连接,Win10没有本地连接怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问：Windows10电脑没有本地连接怎么办？
答：在Win10系统的电脑中，原来的“本地连接”叫做：以太网。如果在 控制面板 ——&gt; 网络和 Internet ——&gt; 网络连接 选项下，可以看到“以太网”图标，说明一切正常。
如果你的Win10电脑中，既没有本地连接，也没有以太网，这种情况下，很可能是网卡驱动程序没有安装好，导致网卡没有识别出来，解决办法是：
Win10没有本地连接
1、找一台可以上网的电脑或者手机，下载网卡驱动程序，大家下载万能网卡驱动，否则需要下载与你网卡型号对应的驱动才可以。
也可以下载驱动人生、驱动精灵 网卡版的软件，安装后会自动检测、更新你的网卡驱动。 通常网卡驱动安装正确后，在Win10电脑中就会出现 以太网 或者 本地连接 图标。
Win10本地连接
2、如果更新网卡驱动程序后，在Win10电脑的 控制面板 ——&gt; 网络和 Internet ——&gt; 网络连接 选项下，还是看不到 以太网 或者 本地连接，这种情况下，可能是系统服务问题，解决办法如下：
(1)、同时按住按键上的 Win + R 组合按键，打开 运行程序对话框，如下图所示。
Win10运行窗口
温馨提示：
键盘上的Win按键，在键盘左下角Alt按键的旁边，Win按键上面通常有微软Windows的logo。
(2)、然后在运行程序对话框中依次输入：“regsvr32 netshell.dll”、“regsvr32 netconfigx.dll”、“regsvr32 netman.dll”，然奇点击确定执行命令。
温馨提示：
请输入双引号内的内容，双引号不要输入。另外输入完一个命令后，就点击确定按钮执行，然后才输入下一个命令，千万不要3个命令一起输入到运行程序框中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d5a81f35ea7e9fc8042f7bfbe714e32/" rel="bookmark">
			ScannerException: while scanning for the next token found character ‘@‘ 问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在把一个老项目修改为动态读取配置参数的时候，发现报了这个错误：
org.yaml.snakeyaml.scanner.ScannerException: while scanning for the next token found character ‘@’ that cannot start any token 分析： 产生此问题的原因：
1、一般情况下是因为，配置文件中写错了。请再三检查下项目的maven的pom文件中的 profiles - profile - properties下的属性名。看它是否能够和bootstrap.yml下的spring.profile.active名字是否一致。
很多人出错是因为从网上复制了一个配置，直接丢到了里面。自己不去看下配置项的名是否一致。导致的该错误的产生。
2、IDEA缓存的问题。
处理方法： pom文件
&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/dev&gt; &lt;properties&gt; &lt;!--此处的profileActive的名字是自定义的。这个名字要和bootstrap.yml文件中的spring.profile.active @@包含的值名称一致--&gt; &lt;profileActive&gt;local&lt;/profileActive&gt; &lt;/properties&gt; &lt;profile&gt; ... &lt;/profiles&gt; bootstrap.yml文件对应
spring: profile: active： @profileActive@ #这个地方的名字要和 pom下的profile下的properties对的上 如果这一步没有问题的话，启动还是报了 '@'的异常的话，一般的情况下，应该是缓存的问题了。
缓存的问题一般你把IDEA右侧的maven,进行一下刷新操作，基本上就可以解决这个问题了。
总结 说个亲身经历，我以前刚上班的时候，公司的技术经理为了图省事，直接从网上copy了一个centos下的MySQL配置文件。然后作为正式环境使用。然后各种数据库的问题，后来一个高级工程师分析了下配置文件，发现配置参数就是普通的PC机的配置，根本就没有发挥服务器的优势。后来调整了缓冲大小。就再也没有问题了。
一般情况下，网络上的东西，其实有很多给出的结果或者答案，只是使用一定的场景，需要你甄别其中的情况，特别是一些配置文件之类的，一般的情况下，如果不是很熟悉，最好把每个配置项都认真读一遍。以防不测。这个不测看具体事故大小而定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e838cf4a6bd902de1014e47bf7521a79/" rel="bookmark">
			SpringBoot中注入ApplicationContext对象的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中，我们可能需要手动获取spring中的bean对象，这时就需要通过 ApplicationContext 去操作一波了！
1、直接注入（Autowired） @Component public class User { @Autowired private ApplicationContext applicationContext; } 2、构造器方法注入 @Component public class User{ private ApplicationContext applicationContext; public User(ApplicationContext applicationContext) { this.applicationContext = applicationContext; } } 3、手动构建类实现接口 /** * Spring的ApplicationContext的持有者,可以用静态方法的方式获取spring容器中的bean * * @date 2018年5月27日 下午6:32:11 */ @Component public class SpringContextHolder implements ApplicationContextAware { private static ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { SpringContextHolder.applicationContext = applicationContext; } public static ApplicationContext getApplicationContext() { assertApplicationContext(); return applicationContext; } @SuppressWarnings("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e838cf4a6bd902de1014e47bf7521a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0bc7af53725027158093a416e3ca11d/" rel="bookmark">
			基于Vue&#43;SpringCloudAlibaba微服务电商项目实战-024：基于shardingjdbc实现分表分库（完结撒花）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		024：基于shardingjdbc实现分表分库 1 数据库分表分库规则2 mycat实现分表分库原理3 shadingjdbc实现的原理4 项目如何整合shadingjdbc5 微服务如何实现服务追踪6 微服务服务追踪实现原理分析 1 数据库分表分库规则 今日课程任务
订单表与会员表如何实现分表分库分表分库实现算法有哪些sharding-jdbc与MyCat实现分表分库的区别sharding-jdbc实现分表分库的源码分析分表分库后，如何实现联合查询微服务电商项目如何整合Zipkin实现服务追踪微服务服务追踪实现原理与存在缺陷 分表分库：最好是在千万级别数据开始分表分库。
分库概念：根据业务实现分库 订单数据库、会员数据库、支付数据库
会员数据库中分为多个不同的数据库
member_db1—member_table
member_db2—member_table
同样的表不建议在多个数据库中存放，最好在单个数据库中将一个大表拆分成多个子表
member_db.member_table1 member_db.member_table2
2 mycat实现分表分库原理 拆分子表能有效提高查询效率
举例：1000w数据量表查询效率10s，拆分成2个子表查询时间为5s左右
分片算法：
计算hash（常见） 根据唯一id取模 存在表扩容的问题按照时间划分按照范围划分 基于mycat实现分片，可以隐藏数据库db真实的联接地址，虚拟一个数据库类似nginx反向代理。分表分库后查询所有数据效率也不会很低，因为采用多线程查询数据。
3 shadingjdbc实现的原理 Sharding-jdbc实现原理：
本地采用aop拦截jdbc语句，在发送sql之前改写sql语句，效率比mycat要高。
Sharding-jdbc与mycat区别：
mycat是基于服务器虚拟数据库的方式实现分表分库；sharding-jdbc基于本地aop拦截改写sql语句 4 项目如何整合shadingjdbc 数据库表
CREATE TABLE `t_order_0` ( `order_id` bigint(20) NOT NULL, `user_id` bigint(20) NOT NULL, PRIMARY KEY (`order_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin; CREATE TABLE `t_order_1` ( `order_id` bigint(20) NOT NULL, `user_id` bigint(20) NOT NULL, PRIMARY KEY (`order_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin; Maven依赖
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0bc7af53725027158093a416e3ca11d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872108439abaa293309ecb8334ede23e/" rel="bookmark">
			七年级计算机硬件系统教案,宁夏版信息技术七年级上册1.3.1计算机硬件系统的组成与基本结构 教案...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ID:10251304
分类：
宁夏
,
2019
资源大小：46KB
资料简介:
《计算机的硬件系统》教案
郑州中学 张小芬
一、教材使用
计算机的硬件系统是七年级上册第三章第一节的内容，我将其用一节课的时间来讲，而将工作原理和计算机的硬件系统一节合并一起来讲，这样安排既符合学生的认知规律，也便于学生接受。该节课在整个信息技术课程的学习过程中起重要作用，通过本节课的学习，揭开计算机的神秘面纱，使学生充分了解计算机的硬件系统组成和简单的工作原理，为后续知识的学习和操作，打下坚实的基础。
二、教学目标
知识与技能：
1、掌握计算机的基本结构及工作原理。
2、掌握计算机的硬件组成及其作用。
过程与方法：
1、通过对实物的观察，培养学生认真观察思考能力。
2、通过以小组为单位的竞赛活动，培养学生的团队意识。
3、通过学生合作式学习，给学生提供互动的空间，让学生相互交流、学习，同时，使学生学会分享。
情感、态度与价值观：
1、使学生在相互讨论、小组合作学习的过程中，培养学生的团队合作精神。
2、让学生在探究式学习中，体验成功的快乐，从而增强学生的学习兴趣。
三、学习者特征分析
学生通过第一章网络的学习，已经掌握了基本的网络搜索信息的 [来自e网通客户端]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ad4a48112c8a4a05baad196e460e75e/" rel="bookmark">
			计算机一级如何用rank函数降序,rank函数降序排名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rank函数降序排名用法！例如：对销售业绩和学生的成绩进行排名，似乎是挺常见的场景，而在Excel当中，大家或许用的最多的就是排序功能了。
但这里我们要教各位一个新的函数，这个函数自带排名功能，他就是——RANK函数。
下面我们一起来看看如何使用吧!
01.认识函数
RANK，在英文当中就有队列，排列的意思，它在Excel当中也主要承担着排序的功能。
表达式为：RANK(对谁排序，在什么范围，排序方式)
了解了这个函数的表达式，下面我们一起来看看这个函数如何使用吧!
02.成绩排名
如下图所示，我们需要计算一班学生的成绩排名，那么该如何进行统计呢?
我们在E4单元格录入函数公式：
=RANK(D4,$D$4:$D$18,0)
该函数公式表示，对D4单元格的值进行排序，在D4到D18这个范围内排序按，照降序的方式排列。
最终我们就得到了上面的结果。
03.跨区域排名
如下图所示，我们这里的表格分为了三个区域，如果按照以往的排序方法，我们可能需要重新调整表格结构。
那有什么方法，是可以不用调整表格结构就可以实现排序的?
方法就是使用RANK函数。
RANK函数可以对不连续的区域进行排名。
我们在D25单元格录入函数公式：
=RANK(C25,($C$25:$C$34,$F$25:$F$34,$I$25:$I$34),0)
该公式表示，对C25单元格的值进行排序，排序的范围我们通过小括号，合并了多个区域，最后的0表示降序排列。
录入了D25单元格的公式之后，我们往下拖动，就可以把下面的排名都算出来。
其次其他列的排名，我们可以把公式复制过去，也就完成了统计。
04.常见问题
1、仅能对数值大小进行排名，不能让信息降序或升序排列。
虽然RANK函数排名很方便，但数值排列之后，如果你想让信息按照排名的顺序来排列，还是需要用到排序的功能。
2、排序范围没有锁定
排序都是要固定一个范围的，如果范围不固定，排名就没有意义。如下图所示，排名的范围没有固定，统计的时候就产生错误了。
有多个第一名存在，实际上就只有一个第一名。
3、会存在并列的情况
如果在数据中，有相同的数据，那么这两者的排名都是一样的，不会按照先后顺序来排名次。
以上就是我们对RANK函数的介绍，以及常见问题的解答，希望对大家有所帮助!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/461fa63fd6e239acd6a492fff712eb6b/" rel="bookmark">
			uni-app 实现省市区三级联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图：
第一步：在项目中创建一个联动页面 popupActivity
第二步：创建省市区数据的js文件provinceAndCity.js
let data = [
{
"name": "北京",
"city": [{
"name": "北京",
"area": ["东城区", "西城区", "崇文区", "宣武区", "朝阳区", "丰台区", "石景山区", "海淀区", "门头沟区", "房山区", "通州区", "顺义区",
"昌平区", "大兴区",
"平谷区",
"怀柔区", "密云县", "延庆县"
]
}]
},
{
"name": "天津",
"city": [{
"name": "天津",
"area": ["和平区", "河东区", "河西区", "南开区", "河北区", "红桥区", "塘沽区", "汉沽区", "大港区", "东丽区", "西青区", "津南区",
"北辰区", "武清区", "宝坻区",
"宁河县", "静海县", "蓟 县"
]
}]
},
{
"name": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/461fa63fd6e239acd6a492fff712eb6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b67c9d811deb395b1963652dfb33abab/" rel="bookmark">
			计算机中的三类总线是什么,计算机中三总线是什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三总线是指是指在计算机中配置3组总线，即在处理器总线上通过一块被称为PCI桥的控制线路，提供出一组高性能的局部总线，称为PCI总线，而把原来的ISA总线和EISA总线从处理器总线上断开，并通过IO控制线路连接到这里的PCI总线上。把一些慢速的输入/输出设备接到EISA(ISA)总线上；PCI总线的时钟频率比较高(例如33MHz),数据线位数比较多(例如4个字节)，主要用于连接各种快速设备；而处理器总线的性能可能会更高，例如66MHz或更高的时钟频率和8个字节的数据线位数。这3组总线可以并发执行输入/输出操作，使总线的输入/输出能力和计算机系统的总体性能再次得到更大的提高。在主存和高速的磁盘等设备之间引入一个DMA总线，那么系统可构造一种三总线结构.*在三总线结构中，主存总线用于CPU和主存之间的信息传送；*I/O总线用于CPU和各个I/O之间进行信息传输；*DMA总线用于高速外设和主存之间的信息交换；*在三总线结构中，DMA总线和主存总线不能同时用于访问主存。传统的总线结构采用处理器-Cache总线、主存总线、I/O总线三级总线结构补充的补充：CPU3总线的提法实在是太笼统。“三总线”这个词并非绝对，要看你从何处着眼。综我前面所述，简单的可以分为:处理器总线、PCI总线、I/O总线。也可以分为处理器-Cache总线(个人人认为实际上就是处理器总线)、处理器-内存总线(并不单指RAM内存，磁盘也是一种内存,但是处理器直接访问磁盘需要DMA总线)、I/O总线。总之，需要根据不同的概念，来定义所谓三总线。
阅读全文 &gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac7df66af5dc77c809068e44ba7faf93/" rel="bookmark">
			vue 组件2 非单文件组件（组件的创建,注册使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要点：
组件分为：非单文件组件和单文件组件
非单文件组件就是一个文件里面有n个组件 n&gt;1
单文件组件：
一个文件中就只有一个组件,并且是vue创建的 ，这一个组件也就是一个文件
一般外卖开发时,多用单文件组件
毕竟单文件组件里面只有一个vue实例
小案例：
解决命名重复
一、
二、用驼峰命名解决推荐，层级没有那么多拆组件压力没有那么大
把这两个拆分成两个组件
1.创建组件
const 组件名=Vue.extend({
}) 这里面内容和我们之前在vue实例里写的几乎是一样什么计算属性、监视等等
但是这边是几乎,还是有不同的
如果直接复制前面vue实例写的
发现报错,报错：只有你写new Vue的时候才能写el的配置项 组件为什么不用写为谁服务？
因为,组件就像一块砖哪里缺了往哪搬,不需要明确为谁服务
真正要写el的就是vm,因为vm是在所有组件之上的大哥说打哪就打哪,el是在vm上决定的,不是组件决定的
所以我们把el注释掉,发现又报了一个错
报错：要把data写成一个方法,不能像之前那样写成对象的格式
要写出data(){
return()
}
之前我们说过
vue实例用的data有两种写法一种对象式,一种函数式
而且在组件中只能使用函数式
为什么只能写成函数式？
因为当有两个引用了该组件,都引用了其中的schoolName 如果用对象的形式,则当这两个其中一个修改了schoolName的值,则另一个也会跟着改变,因为用对象方式,把数据同步了,不符合组件的要求
用一些通俗的代码来解释：
用对象形式写：
会发生一个联代的关系
如果用函数形式写
就没有联代了
因为你每次调用会给你一个对象
比如会给x1一个对象也会给x2一个对象
然后我们把小案例代码改成函数形式,由于这边创建的是学校组件,所以只要写学校的属性即可
发现不报错,问题解决
同理把学生的组件也写好
2.注册组件
在vm上写el对应的容器
并配置一个components:{
组件名:key
}
这个key就是前面定义的组件的变量,这边定义的组件名,才是组件的名字
两个相同可以用组件
这边我们用不同注册
再写其中的html结构
用我们之前学过的用template对象,加字符串的形式写html结构
到这边我们的vue组件才真正有意义 3.使用
只要在body里写对应组件名,的组件标签就行了
发现页面成功显示了
在vm上也可以加对象,并不是写了组件就不能写vm上的data对象了
root中是vm上有没有对应数据
验证一个组件被使用多次数据是不干扰的
写两个学生组件标签
发现没有干扰,就是写了函数式
增加功能
在学校组件中加入一个按钮点击提示学校
在template=··里直接写注意要在外边用div包裹,这边看到写上去全是绿色,不好编译,这也是为什么大多数开发都是使用单文件组件的写法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac7df66af5dc77c809068e44ba7faf93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df0eecd5edbc12ed1f942f143f4aca4d/" rel="bookmark">
			HPEOneView试玩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装 使用PVE虚拟机(Exsi也可以)安装 ，下载ova文件
下载地址：https://www.hpe.com/us/en/resources/integrated-systems/oneview-trial.html
这里如果是KVM就下载KVM版本的
安装过程就不展示了 ，正常导入镜像就可以，这里磁盘要选IDE模式的，其他会找不到磁盘。
注意： 保证 网卡信息无误，再开机，如果没有网卡无法开机
开机：
进入系统，自动初始化
系统准备 （这里要等很长很长很长时间。。。看网络波动应该是下载了一些东西 ）
启动资源管理器
接受协议
启动什么什么官方服务来着，接受
选择中文，登录初始的账号是Administrator 密码：admin
修改新密码
7. 配置新的网络地址和主机名即可进入
在浏览器直接输入主机ip，即可进入管理页面
打开引导设置，可以说非常全了 添加ioL 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f4c0f37e17ff32470ca5d935d7b59f/" rel="bookmark">
			java Graph 计算网络效率、节点介数、边介数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.jgrapht需要引入外部jar包！
2.数据格式为：
[
{
"nodeId1":"起点1",
"nodeId2":"终点1"
},
{
"nodeId1":"起点2",
"nodeId2":"终点2"
},
{
"nodeId1":"起点3",
"nodeId2":"终点3"
}
]
package com.common.utils.graph; import com.alibaba.fastjson.JSONObject; import org.jgrapht.Graph; import org.jgrapht.GraphPath; import org.jgrapht.alg.shortestpath.FloydWarshallShortestPaths; import org.jgrapht.graph.DefaultEdge; import org.jgrapht.graph.DefaultUndirectedGraph; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.math.BigDecimal; import java.util.List; import java.util.Set; /** * 网络计算工具类 * * @param &lt;V&gt; the graph vertex type * @param &lt;E&gt; the graph edge type */ public class NetworkCalculateUtils&lt;V, E&gt; { private static final Logger log = LoggerFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91f4c0f37e17ff32470ca5d935d7b59f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e5b42be5f3138d1916757e20e028aee/" rel="bookmark">
			设计数据密集型应用 第五章：复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计数据密集型应用 第五章：复制 与可能出错的东西比，'不可能’出错的东西最显著的特点就是：一旦真的出错，通常就彻底玩完了。
——道格拉斯·亚当斯（1992）
文章目录 设计数据密集型应用 第五章：复制领导者与追随者同步复制与异步复制关于复制的研究设置新从库处理节点宕机从库失效：追赶恢复主库失效：故障切换 复制日志的实现基于语句的复制传输预写式日志（WAL）逻辑日志复制（基于行）基于触发器的复制 复制延迟问题读己之写单调读一致前缀读复制延迟的解决方案 多主复制多主复制的应用场景运维多个数据中心需要离线操作的客户端协同编辑 处理写入冲突同步与异步冲突检测避免冲突收敛至一致的状态自定义冲突解决逻辑题外话：自动冲突解决什么是冲突？ 多主复制拓扑 无主复制当节点故障时写入数据库读修复和反熵读写的法定人数 法定人数一致性的局限性监控陈旧度 宽松的法定人数与提示移交运维多个数据中心 检测并发写入最后写入胜利（丢弃并发写入）“此前发生”的关系和并发并发性，时间和相对性捕获"此前发生"关系合并同时写入的值版本向量版本向量和向量时钟 本章小结参考文献 ​ 复制（replication）意味着在通过网络连接的多台机器上保留相同数据的副本。正如在第二部分简介中所讨论的那样，我们希望能复制数据，可能出于各种各样的原因： 使得数据与用户在地理上接近（从而减少延迟）即使系统的一部分出现故障，系统也能继续工作（从而提高可用性）灵活增减可以接受读请求的机器数量（从而提高读取吞吐量，或者降低成本） 本章将假设你的数据集非常小，每台机器都可以保存整个数据集的副本。在第6章中将放宽这个假设，讨论对单个机器来说太大的数据集的分割（分片，partition）。在后面的章节中，我们将讨论复制数据系统中可能发生的各种故障，以及如何处理这些故障。
如果复制中的数据不会随时间而改变，那复制就很简单：将数据复制到每个节点一次就万事大吉。复制的困难之处在于处理复制数据的变更（change），这就是本章所要讲的。我们将讨论三种流行的变更复制算法：单领导者（single leader），多领导者（multi leader）和无领导者（leaderless）。几乎所有分布式数据库都使用这三种方法之一。
在复制时需要进行许多权衡：例如，使用同步复制还是异步复制？如何处理失败的副本？这些通常是数据库中的配置选项，细节因数据库而异，但原理在许多不同的实现中都类似。本章会讨论这些决策的后果。
​数据库的复制算得上是老生常谈了 ——70年代研究得出的基本原则至今没有太大变化【1】，因为网络的基本约束仍保持不变。然而在研究之外，许多开发人员仍然假设一个数据库只有一个节点。分布式数据库变为主流只是最近发生的事。许多程序员都是这一领域的新手，因此对于诸如 最终一致性（eventual consistency） 等问题存在许多误解。在复制延迟问题一节，我们将更加精确地了解最终的一致性，并讨论诸如 读己之写（read-your-writes） 和 单调读（monotonic read） 保证等内容。
译者注：“分布式数据库变为主流只是最近发生的事。”本书的第一版于2017年发布，但是早在2003年GFS的论文和2004年的MapReduce论文就已经掀开了大型公司对分布式存储系统的使用序幕。得益于全球化的进程，美国的科技公司更早地将他们的软件投放于世界上的各个其他国家。这使得分布式数据库（数据中心）在这种背景下被大型的科技公司运用。其他小公司因为成本问题而并不会选择开发分布式数据库。一方面他们的服务往往不需要那么庞大的数据，另一方面他们并没有能力开发一个类似的系统。开源的分布式数据库就成了他们的选择（uber最早使用的是hive，之后使用的是facebook开源的数据查询引擎presto）。当云服务出现后，其他小公司也选择将他们的数据库服务替换为这些更好更稳定更安全的分布式数据库。
领导者与追随者 存储数据库副本的每个节点称为 副本（replica） 。当存在多个副本时，会不可避免的出现一个问题：如何确保所有数据都落在了所有的副本上？
每一次向数据库的写入操作都需要传播到所有副本上，否则副本就会包含不一样的数据。最常见的解决方案被称为 基于领导者的复制（leader-based replication） （也称 主动/被动（active/passive） 或 主/从（master/slave） 复制），如图5-1所示。它的工作原理如下：
副本之一被指定为 领导者（leader），也称为 主库（master|primary） 。当客户端要向数据库写入时，它必须将请求发送给领导者，领导者会将新数据写入其本地存储。其他副本被称为追随者（followers），亦称为只读副本（read replicas），从库（slaves），备库（ sencondaries），热备（hot-standby）1。每当领导者将新数据写入本地存储时，它也会将数据变更发送给所有的追随者，称之为复制日志（replication log）记录或变更流（change stream）。每个跟随者从领导者拉取日志，并相应更新其本地数据库副本，方法是按照领导者处理的相同顺序应用所有写入。当客户想要从数据库中读取数据时，它可以向领导者或追随者查询。 但只有领导者才能接受写操作（从客户端的角度来看从库都是只读的）。 图5-1 基于领导者(主-从)的复制
​ 这种复制模式是许多关系数据库的内置功能，如PostgreSQL（从9.0版本开始），MySQL，Oracle Data Guard 【2】和SQL Server的AlwaysOn可用性组【3】。 它也被用于一些非关系数据库，包括MongoDB，RethinkDB和Espresso 【4】。 最后，基于领导者的复制并不仅限于数据库：像Kafka 【5】和RabbitMQ高可用队列【6】这样的分布式消息代理也使用它。 某些网络文件系统，例如DRBD这样的块复制设备也与之类似。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e5b42be5f3138d1916757e20e028aee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f6e47a679166081d7dae37d4d85103/" rel="bookmark">
			如何选择一个适合自己的SSL证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了保护网站之间信息传输不被恶意篡改、窃取，就有了https安全协议。发展到现在可以将http协议转换成https协议的SSL证书已经有很多了，选一个适合自己的SSL证书也是一件很重要的事了，ssl盾小编详细地为大家讲解了多个SSL证书的选择方案。
第一步，要选择一个服务商来买ssl证书，就和我一样。我选择了这个网站的筛选页面，这个页面比较容易选出来合适的ssl证书。
第二步，根据验证等级来选择SSL证书。一般SSL证书根据验证等级从低到高分为DV SSL证书、OV SSL证书、EV SSL证书。
DV SSL证书：这是比较基础的SSL证书，只需要验证域名所有权个人或者企业就都可以申请这款证书，在同类证书中是价格比较低的证书，很适合个人开发者。
OV SSL证书：这款SSL证书不仅要验证域名所有权，还需要验证公司的真实性，所费的时间也比较长，价格也比DV SSL证书要贵一些，但是这款证书可以在证书中显示公司信息，加密强度也有所提高。比较适合企事业单位。
EV SSL证书：三种证书中验证等级最高，审核也是最严格的就是EV SSL证书，不仅验证域名所有权和公司真实性还需要申请此款证书的公司提供一些证明材料。这款证书不仅有DV SSL证书和OV SSL证书的优点，还可以在绿色地址栏直接显示公司名称，这款证书也是在同类证书中比较贵的一款证书。
第三步，根据域名数量选择证书。
只有一个域名的可以选择单域名SSL证书；拥有多个域名的分为两种情况，一是拥有主域名及主域名下多个子域名，建议选择通配符证书，另一个是拥有多个主域名和子域名，可以选择多域名证书，这款证书默认保护3~4个域名，可以付费添加域名；还有一种SSL证书是软件开发者需要的代码签名证书，这款证书是对软件、程序等进行数字签名的ssl证书，一旦申请成功后可以无限次签发。
基本上选择到这里就可以看到你想要的SSL证书列表了，什么价格的证书都可以，也可以按照价格或其他方面给证书排序，这可以让你更快地找到适合自己的ssl证书。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c095b1872148b838125f3fce691aed5d/" rel="bookmark">
			PAT1002 写出这个数 (20 分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。
输入格式： 每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 10​100​​。
输出格式： 在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。
输入样例： 1234567890987654321123456789 输出样例： yi san wu 题目比较简单。对于拼音的翻译，最好的方法是采用数组来写。我第一反应想到的是switch-case就直接写了，都可以。
题目的坑在于测试点(1)：需要留意 “和是三位数，但是十位数为0的情况！”
#include&lt;stdio.h&gt; #include&lt;string.h&gt; //48～57为0到9十个阿拉伯数字 //测试点1没通过！！：注意 sum 为三位数但十位为 0 时的情况。 void print(int a){ switch(a){ case 0: printf("ling"); break; case 1: printf("yi"); break; case 2: printf("er"); break; case 3: printf("san"); break; case 4: printf("si"); break; case 5: printf("wu"); break; case 6: printf("liu"); break; case 7: printf("qi"); break; case 8: printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c095b1872148b838125f3fce691aed5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52aee3f6567fa8019be24732fa7ea70f/" rel="bookmark">
			50 天学习 50 个项目 - HTML/CSS and JavaScript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 👍 👍 👍 项目源代码，点击【Github 原文链接】 所有项目如下所示：
#项目在线演示01Expanding CardsLive Demo02Progress StepsLive Demo03Rotating Navigation AnimationLive Demo04Hidden Search WidgetLive Demo05Blurry LoadingLive Demo06Scroll AnimationLive Demo07Split Landing PageLive Demo08Form WaveLive Demo09Sound BoardLive Demo10Dad JokesLive Demo11Event KeycodesLive Demo12Faq CollapseLive Demo13Random Choice PickerLive Demo14Animated NavigationLive Demo15Incrementing CounterLive Demo16Drink WaterLive Demo17Movie AppLive Demo18Background SliderLive Demo19Theme ClockLive Demo20Button Ripple EffectLive Demo21Drag N DropLive Demo22Drawing AppLive Demo23Kinetic LoaderLive Demo24Content PlaceholderLive Demo25Sticky NavbarLive Demo26Double Vertical SliderLive Demo27Toast NotificationLive Demo28Github ProfilesLive Demo29Double Click HeartLive Demo30Auto Text EffectLive Demo31Password GeneratorLive Demo32Good Cheap FastLive Demo33Notes AppLive Demo34Animated CountdownLive Demo35Image CarouselLive Demo36HoverboardLive Demo37PokedexLive Demo38Mobile Tab NavigationLive Demo39Password Strength BackgroundLive Demo403d Background BoxesLive Demo41Verify Account UiLive Demo42Live User FilterLive Demo43Feedback Ui DesignLive Demo44Custom Range SliderLive Demo45Netflix Mobile NavigationLive Demo46Quiz AppLive Demo47Testimonial Box SwitcherLive Demo48Random Image FeedLive Demo49Todo ListLive Demo50Insect Catch GameLive Demo 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eda387be9a2722a73b7cec2bc32d5109/" rel="bookmark">
			R数据可视化：如何绘制条形图？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		条形图也许是最常用的数据可视化工具，通常用来展示不同的分类下（在x轴上）某个数值型变量的取值（在y轴上）。例如，条形图可以用来形象地展示4种不同商品的价格，但不适宜用来展示商品价格随时间的变动趋势，因为这里的时间是一个连续变量——尽管我们也可以这么做，后面会看到这种情形。
绘制条形图时需特别注意一个重要的细节：有时条形图的条形高度表示的是数据集中变量的频数，有时则表示变量取值本身。牢记这个区别——这里极易混淆，因为两者与数据集的对应关系不同，但又对应同样的术语。本章将对此进行深入讨论，并分别介绍这两类条形图的绘图技巧。
从本章开始，本书将重点介绍使用ggplot2而不是R基础绘图系统。用ggplot2绘图更简便，并且可以绘制更复杂的图形。
3.1　绘制基本条形图 问题 你有一个包含了两列数据的数据框，其中一列数据表示条形在x轴上的位置，另一列表示每个条形在y轴上对应的高度，基于此，如何绘制条形图？
方法 使用ggplot()函数和geom_col()绘制上述条形图，并分别指定与x轴和y轴对应的变量（见图3-1）。
library(gcookbook) # 加载gcookbook是为了使用其中的pg_mean数据集 ggplot(pg_mean, aes(x = group, y = weight)) + geom_col() 图3-1：当x是离散变量时绘制的条形图
在之前版本的ggplot2中，建议用geom_bar(stat ="identity")来绘制针对变量值的条形图。在ggplot2 2.2.0版中，用geom_col()函数可以执行相同的操作。
讨论 当x是连续（数值型）变量时，条形图的结果与上图会略有不同。此时，ggplot不是只在实际取值处绘制条形，也会在x轴上介于最大值和最小值之间所有可能的取值处绘制条形，如图3-2所示。我们可以使用factor()函数将连续变量转化为离散变量。
# 没有Time == 6的输入 BOD #&gt; Time demand #&gt; 1 1 8.3 #&gt; 2 2 10.3 #&gt; 3 3 19.0 #&gt; 4 4 16.0 #&gt; 5 5 15.6 #&gt; 6 7 19.8 # Time是数值型（连续）变量 str(BOD) #&gt; 'data.frame': 6 obs. of 2 variables: #&gt; $ Time : num 1 2 3 4 5 7 #&gt; $ demand: num 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eda387be9a2722a73b7cec2bc32d5109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c00f4738dcb2b83e55043425869f381/" rel="bookmark">
			nacos服务的注册与发现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nacos（中介） 用于服务注册，作为中介、注册中心
服务消费者：调用服务（客户端）服务提供者：提供服务（提供调用接口）（服务器端） nacos下载 github下载后解压，由于是windows系统使用，更改配置文件：standup.cmd
set MODE="standalone" 运行stand.cmd，显示如下：
上图显示端口为8848
访问：localhost:8848/nacos
用户名密码默认都是nacos
登陆成功：
将应用注册到注册中心 服务提供者端：
pom.xml中引入：
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; application.yml中引入
cloud: nacos: server-addr: localhost:8848 #注册中心的地址，注意不要以协议开头 注意下面是服务名称：
application: name: product-service 发现：控制台显示如下，表示服务注册成功
nacos registry, DEFAULT_GROUP product-service 192.168.253.1:8010 register finished 运行，网站中显示：
java程序内测试 package com.neutech.shopserver.order.controller; import com.neutech.shopserver.commons.vo.ResultVO; import com.neutech.shopserver.order.form.OrderForm; import com.neutech.shopserver.order.service.OrderService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cloud.client.ServiceInstance; import org.springframework.cloud.client.discovery.DiscoveryClient; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping("/order") public class OrderController { @Autowired private OrderService orderService; @Autowired private DiscoveryClient discoveryClient; @GetMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c00f4738dcb2b83e55043425869f381/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4013550332b04afa139276c858498b56/" rel="bookmark">
			AUTOSAR工具ISOLAR简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AUTOSAR作为现如今汽车行业软件开发绕不开的一个话题，在网上的热度一直都很高，但是对于具体工具开发的资料还是相对较少，因此在此做一个关于开发工具ISOLAR的介绍。
一. ISOLAR工具简介
ETAS有一套关于AUTOSAR的解决方案，可以参见下图，相当于在每个开发过程中，ETAS都有相应的工具支持我们进行开发。
ISOLAR工具主要包含ISOLAR-AB,RTA-BSW,RTA-OS,RTA-RTE，购买工具后，供应商会提供如下安装包：
RTA_CAR_setup.exe是一个汇总安装的可执行文件，双击RTA_CAR_setup.exe即可以将上述4个软件安装包依次进行安装。
二. ISOLAR-AB
ISOLAR-AB包含ISOLAR-A与ISOLAR-B两个工具。ISOLAR-A用于应用软件开发，主要用于开发软件架构。ISOLAR-B用于开发配置基础软件。
打开ISOLAR-AB的安装包，双击loader.exe，
即会弹出如下界面：
单机Main选项，则可以看到ISOLAR-A/B的安装选项：
单击ISOLAR-A/B Product Installation(64-bit only)，即会弹出安装窗口：
单击Proceed to Install:
选择D盘后即可单机Install进行安装。注意到于此同时，ETAS License Manager也会同时安装，后续加载license的时候需要用到。
三. RTA-BSW
ISOLAR-B用于底层软件的配置，RTA-BSW用于底层软件的代码生成。因此我们也需要安装RTA-BSW。
双击setup.exe即可以进行安装。需要注意，只有安装了ISOLAR-A/B才能安装RTA-BSW，如果没有装ISOLAR-A/B的话，下面窗口的版本号即为空，也就无法继续安装。
继续往下走：
选好安装路径：
之前已经装过ETAS License Manager，因此这里可以不选。
安装成功。
四. RTA-OS
下一步安装RTA-OS，同样双击autostart.exe，弹出如下界面：
单击中间部分的RTA-OS，然后进入安装程序：
选择好安装目录，即可以开始安装：
单击Next即可：
单击Next：
单击Install：
安装完成后会新弹出一个VRTA的安装窗口，继续往下走即可：
同样选择好目录：
单击Next：
Next：
单击Install后，即可以安装成功：
五. RTA-RTE
最后安装RTA-RTE，安装过程类似，参照以下截图。
六. 加载license
首先找到之前安装的ETAS License Manager，运行。
可以看到现在ISOLAR软件是无法使用的，因此单击文件选项下的添加许可证文件：
该界面即为加载许可证文件的窗口，在此添加许可证文件即可以启用ISOLAR软件。
七. 总结
经过上述步骤即可以完成ISOLAR开发工具的安装，也可以使用RTA_CAR_setup.exe开启从上至下的整个安装流程，步骤都是一样的，所以无需担心。
后续有时间会讲讲具体的开发应用，看看大家想了解什么，可以留下言。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a0a92aa440563af13d622d09563b5ff/" rel="bookmark">
			Kubernetes 集群DNS选择：CoreDNS vs Kube-DNS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在二进制部署 Kubernetes 集群时，最后一步是部署 DNS，有两个选项：CoreDNS 和 Kube-DNS，二者主要有什么区别，如何选择呢？
CoreDNS 和 Kube-DNS 作为 Kubernetes 集群的 DNS 服务提供者，在做用和完成的工作上是完全相同的。二者在实现上有一些不同，这导致了在资源消耗和性能上的差异。主要有：
CoreDNS 每个实例只有一个容器，而 Kube-DNS 有三个Kube-DNS 使用 dnsmasq 进行缓存，这是一个 C 线程。Core-DNS 使用 Go 开发，goroutine 实现了更高效并发。CoreDNS 默认使用 negative caching（不理解这个负缓存）。Kube-DNS 没有。 这些不同在一些方面对性能产生影响。每个实例里更多的容器数量增加了基础内存需求，也增大了性能开销（因为请求/应答要在容器之间来回传递）。对于kube-dns，dnsmasq 可能经过了 C语言的高度优化，但它毕竟是单线程的，智能利用CPU的一个核。CoreDNS 使用了 negative caching，用于处理外部名称搜索。
从 Kubernets 1.11 开始，CoreDNS 达到了 GA，kubeadm 使用它来默认安装 Kubernetes。容器镜像使用 coredns 而服务名是 kube-dns，这是为了保证应用从 Kube-DNS 迁移到 coredns 时的后向兼容性。
参考资料：
https://stackoverflow.com/questions/52761135/kubernetes-kube-dns-vs-corednshttps://coredns.io/2018/11/27/cluster-dns-coredns-vs-kube-dns/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50924ddf02a0cabc611c3f7f9c570418/" rel="bookmark">
			计算机主板电池没电了 会怎么样,电脑主板电池没电会怎样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用计算机的时候，有的情况下可能会出现电脑主板电池没电的情况。那么对于电脑主板电池没电会怎样这个问题，小编觉得这种情况可能会影响到我们电脑的正常开机使用。解决这种问题的话，我们可以将电脑拆机更换电池即可。详细步骤就来看下小编是怎么做的吧~希望可以帮助到你。
电脑主板电池没电会怎样
1.系统日期无法更新，每次开机都是显示出厂时间，看不了时间要自己手动去更改很麻烦有木有。
2.当你开机后，会要求你按F2键才能正常启动进入操作系统。
3.当你按开机键时间可能电脑无任何反应，但是瞧一下电源灯光是亮着的。
4.如果更改过bios设置，那么当纽扣电池没电了，BIOS系统也会自动恢复出厂设置了。
电脑主板电池没电解决方法：
1 、先购买一个新的主板 BIOS 电池，注意要和你电脑上的电池是同一型号的。
如果你的机器是品牌机且在保修期，可与客服联系进行更换，
请不要自行打开机箱，否则将取消质保，如果是兼容机(组装机)可以自行拆开进行以上操作。
2 、关掉电脑的电源。打开机箱盖子，会看到一个圆的电池。
直径大约为 1.5-2.0CM ，把电池取出来，每一种主板的电池座不一样，所以电池的取法也不同。
主板电池较常见的三种扣法：
1.“外扣式” 要拆下电池只需将电池座旁的扣子往下压，然后再将电池往外推出即可。
2.“上扣式”的电池座，这种电池座的扣子制作在电池的上方，
要拆下电池时只需把扣子往外扳，电池即会自动弹出来。
3.“上压式”的电池座，要拆下电池也很简单，只要将电池往外侧推出即可。
4.这时把新电池拿出来安装。注意一下水银电池的正、负极方向，
5.然后依照刚刚拆下电池的反动作将电池装回，就装好了。再把机箱盖子盖上，
6.开机之后如果提示按 F1 的话，就可以按 F10 敲两下回车就行。
7.更换好主板电池之后不需要特别设置，只是需要将系统时间修改为现有的背景时间，
8.因为大部分时间设置是同步的，所以这点可以忽略。如果你还是心有余悸，
9.可以将 BIOS 恢复出厂设置之后正常开机即可。
以上就是小编给各位小伙伴带来的电脑主板电池没电会怎样的所有内容，希望你们会喜欢。更多相关教程请收藏系统家园~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dbfbf67ad4e2cfa309e919fc6ceeece/" rel="bookmark">
			vue中滚动文字公告（1）-elementUI走马灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：
把每条公告内容看成是走马灯的一个item，去掉左右箭头，去掉指示器，上下滚动用vertical，水平滚动用horizontal
优势：实现简单
劣势：效果单一
html部分
&lt;el-card class="notice"&gt; &lt;el-carousel indicator-position="none" arrow="never" direction="vertical" :interval="5000"&gt; &lt;el-carousel-item v-for="i in 4" :key="i" class="notice_item"&gt; &lt;img src="@/assets/images/notice.png" alt=""&gt; 此处是公告内容！此处是公告内容！{{i}} &lt;/el-carousel-item&gt; &lt;/el-carousel&gt; &lt;/el-card&gt; style
/**/ .notice{ width: 1200px; height: 50px; left: 50%; transform: translate(-50%); position: absolute; z-index: 2; padding: 0; } .notice /deep/ .el-card__body{ padding: 0; } /*使文字和公告图片在一行*/ .notice_item{ height: 50px; line-height: 50px; background-color: #fff; display: flex; flex-direction: row; align-items: center; } .notice_item img{ width: 40px; /*height: 16px;*/ margin: 0 44px 0 32px; } elementUI走马灯文档：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dbfbf67ad4e2cfa309e919fc6ceeece/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deabe2280e550806460aff336bb82435/" rel="bookmark">
			资源工具分享（第1期）：后端架构师技术图谱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👍 👍 👍 更多精彩内容，看【原文链接】
推荐: 《Java技术书籍大全》 - awesome-java-books
从初级开发者到资深架构师，看这些书就够了
数据结构
队列集合链表、数组字典、关联数组栈 树
二叉树完全二叉树平衡二叉树二叉查找树（BST）红黑树B，B+，B*树LSM 树BitSet 常用算法
排序、查找算法
选择排序冒泡排序插入排序快速排序归并排序希尔排序堆排序计数排序桶排序基数排序二分查找Java 中的排序工具布隆过滤器 字符串比较
KMP 算法深度优先、广度优先贪心算法回溯算法剪枝算法动态规划朴素贝叶斯推荐算法最小生成树算法最短路径算法 并发
Java 并发多线程线程安全 一致性、事务
事务 ACID 特性事务的隔离级别MVCC 锁
Java中的锁和同步类公平锁 &amp; 非公平锁悲观锁乐观锁 &amp; CASABA 问题CopyOnWrite容器RingBuffer可重入锁 &amp; 不可重入锁互斥锁 &amp; 共享锁死锁 操作系统
计算机原理 CPU
多级缓存进程线程协程Linux 设计模式
设计模式的六大原则23种常见设计模式应用场景单例模式责任链模式MVCIOCAOPUML 微服务思想
康威定律 运维 &amp; 统计 &amp; 技术支持
常规监控APM统计分析 持续集成(CI/CD)
Jenkins环境分离 自动化运维
Ansiblepuppetchef 测试
TDD 理论单元测试压力测试全链路压测A/B 、灰度、蓝绿测试 虚拟化
KVMXenOpenVZ 容器技术
Docker 云技术
OpenStackDevOps文档管理 中间件
Web Server
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deabe2280e550806460aff336bb82435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aad1a37d417bc6d417d27e9846d229db/" rel="bookmark">
			fgui实现刮刮乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unity实现刮刮乐效果，网上一大堆使用ugui实现的，但没有一篇解释使用fgui的，本篇文章基于fgui实现刮刮乐效果。 核心代码来源于这个篇博客，这篇博客基于ugui实现的，我把它换成了fgui的方式
https://blog.csdn.net/qq_39108767/article/details/103412395
using System; using UnityEngine; using FairyGUI; public class FguiErasePoint : MonoBehaviour { //遮罩 要操作的对象 private GLoader maskLoader; //要操作的纹理 新建出来的 private Texture2D eraseTexture; //图片大小 private float textureLength; //擦除部分图片大小 private float eraseLength; //纹理宽度 private int textureWidth; //纹理高度 private int textureHeight; //擦除完成调用事件 public Action eraseFinishEvent; //擦除比例，擦除比例高于该值，是为擦除完成，自动擦除剩余部分 private float finishPercent = 0.9f; //当前进度 private float currentPercent; //擦除的半径 public int radius = 10; //遍历时候 上下左右的值 private int startX, endX, startY, endY, pixelY; //鼠标的坐标 private Vector3 tmpLocalPos; //是否以擦除完成 private bool isFinish; private void Start() { GComponent component = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aad1a37d417bc6d417d27e9846d229db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b315ec52b41cdf0644fcbb141746f4be/" rel="bookmark">
			Part3-3-3 Nuxt.js 基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nuxt.js 介绍 官网: https://zh.nuxtjs.org/
GitHub 仓库: https://github.com/nuxt/nuxt.js
Nuxt.js 是一个基于 Vue.js 的服务端渲染应用框架，它可以帮我们轻松的实现同构应用。 通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。
我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。
Nuxt.js 预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。 除此之外，我们还提供了一种命令叫: nuxt generate ，为基于 Vue.js 的应用提供生成对应的静态站
点的功能。
我们相信这个命令所提供的功能，是向开发集成各种微服务(Microservices)的 Web 应用迈开的新一 步。
作为框架，Nuxt.js 为 客户端/服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据 加载、中间件支持、布局支持等非常实用的功能。
特性 基于 Vue.js
Vue、Vue Router、Vuex、Vue SSR 自动代码分层
服务端渲染
强大的路由功能，支持异步数据
静态文件服务
ES2015+ 语法支持
打包和压缩 JS 和 CSS
HTML 头部标签管理
本地开发支持热加载
集成 ESLint
支持各种样式预处理器: SASS、LESS、 Stylus 等等
支持 HTTP/2 推送
Nuxt.js 框架是如何运作的 Nuxt.js 集成了以下组件/框架，用于开发完整而强大的 Web 应用:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b315ec52b41cdf0644fcbb141746f4be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/300232aee19ac35171436eb1bf517d9c/" rel="bookmark">
			EasyExcel操作数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用EasyExcel将数据写入本地文件
File fileName = new File(System.getProperty("java.io.tmpdir")+"投诉记录"+System.currentTimeMillis()+ ".xlsx"); ExcelWriter excelWriter = EasyExcel.write(fileName, TaskComplaintRecord.class).build(); WriteSheet writeSheet = EasyExcel.writerSheet("投诉记录").build(); //将TaskComplaintRecord类型集合complaintRecordList写入fileName文件writeSheet excelWriter.write(complaintRecordList, writeSheet); //关流 excelWriter.finish(); 2.使用EasyExcel将数据响应给前端浏览器下载
//response输出文件流 response.setContentType("application/vnd.ms-excel"); response.setCharacterEncoding("UTF-8"); response.setHeader("Content-Disposition", "attachment; filename=" + URLEncoder.encode("投诉记录.xlsx", "UTF-8")); //写入表头，模板，表数据 EasyExcel.write(response.getOutputStream(),TaskComplaintRecord.class).sheet("投诉记录").doWrite(complaintRecordList); 3.使用EasyExcel读取excel数据
配置读取文件监听
public final class ExcelListener&lt;T&gt; extends AnalysisEventListener&lt;T&gt; { /** * 自定义用于暂时存储data * 可以通过实例获取该值 */ private List&lt;T&gt; datas = new ArrayList&lt;&gt;(); /** * 每解析一行都会回调invoke()方法 * * @param object 读取后的数据对象 * @param context 内容 */ @Override @SuppressWarnings("unchecked") public void invoke(Object object, AnalysisContext context) { T map = (T) object; //数据存储到list，供批量处理，或后续自己业务逻辑处理。 datas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/300232aee19ac35171436eb1bf517d9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca691339bd43625dfc9c6640168fba17/" rel="bookmark">
			Lambda在Java以及Kotlin、高阶函数中使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Lambda一般用于代替匿名类，让代码逻辑看起来更加清晰，方法开发以及代码的阅读
2. Lambda一般代替匿名类时，相当于匿名类本身，基本结果为 ()-&gt;{ },如果参数或者方法体语句只有一个可以省略括号。
3. Lambda使用条件：实例化一个类，其内部有匿名类，或者需要实现接口，并且需要重写的方法只有一个。 那么就以方法为根据和参考基准，方法的参数对应小括号，方法体对应大括号。
Lambda 表达式应用示例：
Lambda 表达式应用示例：
4. Lambda在Kotlin中的使用：在kotlin中使用时，Lambda表达式更像是一个函数。它可以简化一些函数的定义，基本结构为 {a:Int -&gt; 2*a}, -&gt;左侧为参数以及参数的类型，右侧为方法体，并且最后一行作为方法体的返回值。
5.Kotlin中，扩展函数一般语法是 fun String.add(a:String):String{}，实际上是一个函数add, 会将一个String对象作为第一个参数。
6.Kotlin中，Lambda表达式
将函数作为一个对象，语法为
val 函数名:(参数类型，参数类型) -&gt;返回值类型 = 大括号{x,y-&gt; 方法体，最后一行作为返回值}
进一步简化写法：
去除函数的参数和返回类型（由系统推导）
大括号内 -&gt;左侧参数说明其数据类型
如何调用呢？
sum(2,3)
7.高阶函数，高阶函数指的是：一个函数的形式参数类型或者函数的返回值类型为函数。 因为参数和返回类型都是函数，传入不同的函数就可以实现不同的功能
1.函数作为形式参数写法： c: (Int,Int) -&gt; Int
2.函数体定义的写法：可以普通形式，也可以上面的lambda形式
3.高阶函数调用时，函数作为实参传入写法：普通的函数调用的写法 c
作为返回值类型
既然作为返回值，那么返回值就是一个函数，获取到返回值后，就可以将返回值视为一个函数进行传值调用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d296b27443c86153bbda84bc2798e01/" rel="bookmark">
			基于Vue&#43;SpringCloudAlibaba微服务电商项目实战-聚合支付平台-020：基于seata解决分布式事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		020：基于seata解决分布式事务 1 支付服务与积分存在的分布式事务问题2 将积分代码拷贝到项目中3 单独开启一个线程调用积分接口4 支付宝如何防止用户重复支付问题5 简单回顾seata与lcn解决分布式事务原理6 构建seata服务端项目7 微服务项目整合Seata框架8 异步回调整合Seata实现分布式事务 1 支付服务与积分存在的分布式事务问题 今日课程任务
支付项目如何用户防止用户重复支付使用feign客户端调用积分服务接口增加积分基于seata解决分布式事务难题seata解决分布式事务底层实现原理 支付回调接口：除了修改支付订单状态以外，其他流程一定要异步实现（目的快速响应支付宝，避免接口超时产生的幂等性问题）。
支付服务调用积分服务，可能会遇到幂等性问题。
解决：全局id（支付id+userId组成）数据库中表主键唯一约束
基于feign的形式调用积分接口增加积分，如何积分服务宕机如何处理？
根据日志记录定时或者人工补偿，比较好的办法也可以直接采用MQ实现增加积分。
2 将积分代码拷贝到项目中 新建模块mt-shop-service-api-integral、mt-shop-service-integral
public interface IntegralService { /** * 增加积分 * @return */ @PostMapping("/addIntegral") BaseResponse&lt;String&gt; addIntegral(@RequestBody IntegralReqDto IntegralReqDto); } @RestController public class IntegralServiceImpl extends BaseApiService implements IntegralService { @Autowired private IntegralMapper integralMapper; @Override public BaseResponse&lt;String&gt; addIntegral(IntegralReqDto integralReqDto) { // 1.验证参数 Long userId = integralReqDto.getUserId(); if(userId==null){ return setResultError("userId不能为空!"); } String paymentId = integralReqDto.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d296b27443c86153bbda84bc2798e01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc5abae1ca20f48e614456f7f918542f/" rel="bookmark">
			基于Vue&#43;SpringCloudAlibaba微服务电商项目实战-聚合支付平台-019：基于模板方法模式重构异步回调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		019：基于模板方法模式重构异步回调 1 基于策略+模板方法实现异步回调重构2 异步回调通知实现的原理3 支付宝官方demo异步回调代码的实现4 聚合支付项目如何采用模板+策略重构5 基于模板模式重构聚合支付平台6 异步回调重构验证签名代码7 基于策略模式id找到模板类8 异步回调更改订单状态的信息9 支付异步回调代码继续重构 1 基于策略+模板方法实现异步回调重构 今日课程任务
第三方支付异步回调实现的原理基于模板+策略模式实现异步回调基于ThreadLocal传递参数信息内容采用多线程/MQ异步写入支付的日志信息参数如何防止支付金额不一致的问题如何防止支付回调幂等性问题支付服务存在那些分布式事务难题 2 异步回调通知实现的原理 同步回调：以浏览器重定向方式跳转
异步回调：第三方支付以post请求格式通知给商户端 修改订单状态
支付宝官网文档：https://opendocs.alipay.com/open/270/105899
调用流程如下：
商户系统调用 alipay.trade.page.pay（统一收单下单并支付页面接口）向支付宝发起支付请求，支付宝对商户请求参数进行校验，而后重新定向至用户登录页面。用户确认支付后，支付宝通过 get 请求 returnUrl（商户入参传入），返回同步返回参数。交易成功后，支付宝通过 post 请求 notifyUrl（商户入参传入），返回异步通知参数。若由于网络等原因，导致商户系统没有收到异步通知，商户可自行调用alipay.trade.query（统一收单线下交易查询）接口查询交易以及支付信息（商户也可以直接调用该查询接口，不需要依赖异步通知）。 先触发异步回调，再触发同步回调。
注意：
由于同步返回的不可靠性，支付结果必须以异步通知或查询接口返回为准，不能依赖同步跳转。商户系统接收到异步通知以后，必须通过验签（验证通知中的sign参数）来确保支付通知是由支付宝发送的。详细验签规则请参见 异步通知验签。接收到异步通知并验签通过后，请务必核对通知中的app_id、out_trade_no、total_amount等参数值是否与请求中的一致，并根据trade_status进行后续业务处理。在支付宝端，partnerId与out_trade_no唯一对应一笔单据，商户端保证不同次支付out_trade_no不可重复；若重复，支付宝会关联到原单据，基本信息一致的情况下会以原单据为准进行支付。 3 支付宝官方demo异步回调代码的实现 异步回调中的商户订单号码与支付宝交易号码有哪些区别？
商户订单号码—支付的id
支付宝交易号码—支付宝流水号码 补偿
如果商户端没有及时返回success给支付宝的情况下，支付宝可能会触发重试策略，重试过程中可能会发生幂等性问题。
注意：同步回调以浏览器重定向形式返回，商户端只是解析报文验证签名成功，将支付结果告诉给用户，但是不能修改订单状态。
4 聚合支付项目如何采用模板+策略重构 如何对聚合支付回调进行设计重构？
策略+模板方法组合
策略模式：解决多重if判断的问题
模板方法模式：定义共同骨架（代码）统一都放入在父类，不同的代码让子类实现。
异步回调代码
1 记录日志
2 验证签名（不同）
3 修改订单状态为已支付
4 调用积分接口增加积分
5 基于模板模式重构聚合支付平台 模板方法骨架类
@Slf4j public abstract class AbstractPayCallbackTemplate { @Autowired private PayThreadInfoHolder payThreadInfoHolder; public String asyncCallBack() { // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc5abae1ca20f48e614456f7f918542f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/080393847769cb9bc423c485fd548368/" rel="bookmark">
			计算机乘法怎么操作函数,教你三个excel乘法函数公式的用法，瞬间提高办公效率...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般我们在做Excel表格的时候都会用到哪些公式？求和？求平均值？计数？乘法？说到乘法，大家都知道excel乘法函数公式的用法吗？应该还有一大部分同学不知道怎么用Excel乘法公式。那就要认真看看这篇文章了。IT考试网归纳了Excel乘法公式的三种用法。
方法一：利用“*”乘积符号
我们计算表中员工的“销售额”数值。
1、首先，把光标移动到单元格“D2”，然后输入“=”，然后点击单元格“B2”。
2、接着，把键盘输入法换成英文，点击键盘“*”符号，然后点击单元格“C2”，点击“回车”。
3、最后，我们把光标移动到单元格D2的右下角直到出现 “+”，然后向下拖拉得出其他员工的销售额就可以了。
4、我们也可以在公式栏里直接输入 “=B2*C2”,然后点击“回车”。
方法二：利用函数“PRODUCT”
这里着重的讲解下函数“PRODUCT”同样是计算表中员工的“销售额”数值
1、首先，把光标移动到单元格“D2”，然后在“公式”界面中，点击“插入公式”。
2、然后，在插入公式设置栏里，输入搜索函数“乘积”点击“转到”，然后选择函数“PRODUCT”。
3、接着，在函数参数栏里输入number1为“B2”，number2为“C2”点击确定就可以了。
4、最后，我们把光标移动到单元格D2的右下角直到出现 “+”，然后向下拖拉得出其他员工的销售额就可以了。
方法三：利用函数“POWER”
我们求表中数据的3次幂。
1、首先，把光标移动到单元格“B2”，然后输入“=POWER(A2,3)”，最后点击“回车键”就可以了。
2、然后，我们把光标移动到单元格B2的右下角直到出现“+”，然后向下拖拉就可以得出其他数据运算结果了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/414f1510d2435f042ebbdb068ff4d998/" rel="bookmark">
			计算机主板电池没电什么情况,主板电池没电了会出现什么情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是时间财富网智能客服时间君，上述问题将由我为大家进行解答。
以电脑为例，主板电池没电了会出现的情况有：
1、电脑每次开机，时间都会恢复到初始时间，也就是说，时间不能正常同步，时间不准的问题，每次重启电脑，其电脑时间都恢复到了出厂设置的时间。
2、电脑Bios设置不生效，当主板电池没电了会出现这样的情况。
电脑机箱主板，又叫主机板(mainboard)、系统板(systemboard)或母板(motherboard)；它分为商用主板和工业主板两种。它安装在机箱内，是微机最基本的也是最重要的部件之一。主板一般为矩形电路板，上面安装了组成计算机的主要电路系统，一般有BIOS芯片、I/O控制芯片、键和面板控制开关接口、指示灯插接件、扩充插槽、主板及插卡的直流电源供电接插件等元件。主板采用了开放式结构。主板上大都有6-15个扩展插槽，供PC机外围设备的控制卡(适配器)插接。通过更换这些插卡，可以对微机的相应子系统进行局部升级，使厂家和用户在配置机型方面有更大的灵活性。总之，主板在整个微机系统中扮演着举足轻重的角色。可以说，主板的类型和档次决定着整个微机系统的类型和档次。主板的性能影响着整个微机系统的性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f82902c4772ccc53ea1b25f2b9797b3e/" rel="bookmark">
			计算机引导程序启动流程,计算机启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：BIOS，负责检查硬件和查找可启动设备(USB，CDROM，HD)。
可启动设备，该设备须有引导信息。任何设备第一个512字节最后两位是55AA，既是由该设备启动。
二：MBR
MBR总共512个字节。
引导代码为MBR的前446字节。
三：GRUB
引导程序，相关文件保存在/boot/grub
相关配置文件/boot/grub/grubconf
四：KERNEL
MBR的引导代码负责找到并加载Linux内核。
Linux内核保存在/boot/vmlinuz
五：INIT
init是Linux系统中运行的第一个进程。
调用/etc/rc.d/rc.sysinit负责对系统进行初始化，挂载文件系统，根据运行级别启动相应服务
运行级别：
0 关机
1 单用户模式
2 不带网络的多用户模式
3 多用户模式
4 未使用
5 X11图形化模式
6 重新启动
/etc/inittab配置默认运行级别。
单用户修改root密码
为内核传递参数1或者single进入单用户模式
购GRUB加密
加密后的密码可以通过grub-md5-crypt生成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c3ffa6c02b2afe399ab194bc369688/" rel="bookmark">
			python字符串中strip() 函数和 split() 函数的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		strip是删除的意思；split则是分割的意思．strip可以删除字符串的某些字符，split则是根据规定的字符将字符串进行分割．
1.Python strip()函数 介绍
函数原型
声明：
s为字符串，rm为要删除的字符序列s.strip(rm) 删除s字符串中开头、结尾处，位于 rm删除序列 的字符(如果rm中不包含　开头或结尾　的那个字母，则不会删除)s.lstrip(rm) 删除s字符串中开头处，位于 rm删除序列 的字符(如果rm中不包含开头的那个字母，则不会删除)s.rstrip(rm) 删除s字符串中结尾处，位于 rm删除序列 的字符(如果rm中不包含结尾的那个字母，则不会删除) 注意：
(1)当rm为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ’ ')
&gt;&gt;&gt; a = ' 123' &gt;&gt;&gt; a.strip() '123' &gt;&gt;&gt; a='\t\tabc' 'abc' &gt;&gt;&gt; a = 'sdff\r\n' &gt;&gt;&gt; a.strip() 'sdff' (2)这里的rm删除序列是只要边（开头或结尾）上的字符在删除序列内，就删除掉。
&gt;&gt;&gt; a = '123abc' &gt;&gt;&gt; a.strip('21') '3abc' 结果是一样的 &gt;&gt;&gt; a.strip('12') '3abc' 2.python split()函数 介绍
说明：
Python中没有字符类型的说法，只有字符串，这里所说的字符就是只包含一个字符的字符串！！！
这里这样写的原因只是为了方便理解，仅此而已。
(1). 按照 某一个字符分割，如 ‘.’
''' 遇到问题没人解答？小编创建了一个Python学习交流QQ群：531509025 寻找有志同道合的小伙伴，互帮互助,群里还有不错的视频学习教程和PDF电子书！ ''' &gt;&gt;&gt; str = ('www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60c3ffa6c02b2afe399ab194bc369688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de9af881b38656a9feb0add73fc1fb9/" rel="bookmark">
			2021-07-15 155. 最小栈（辅助栈）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：
题目：
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。
示例:
输入：
[“MinStack”,“push”,“push”,“push”,“getMin”,“pop”,“top”,“getMin”]
[[],[-2],[0],[-3],[],[],[],[]]
输出：
[null,null,null,null,-3,null,0,-2]
提示：
pop、top 和 getMin 操作总是在 非空栈 上调用。
题解：
思路与算法
当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。
复杂度分析
时间复杂度：对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。
空间复杂度：O(n)，其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 O(n)。 class MinStack { public: stack&lt;int&gt; minnums; stack&lt;int&gt; nums; /** initialize your data structure here. */ MinStack() { } void push(int val) { nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1de9af881b38656a9feb0add73fc1fb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/744aed7e1bb454fad0bd7429beebe8a4/" rel="bookmark">
			java反编译工具jd-gui的下载和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jd-gui可以反编译class文件，有图形化界面。
下载地址：http://java-decompiler.github.io/ 在download页面下载jd-gui-1.x.x.jar文件
下载后运行命令行打开：
java -jar jd-gui-1.6.6.jar
改命令会打开图形界面如下，点击file-&gt;open，可打开本地的.class文件，或者直接打开jar包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42d98f63b7c03480cfcdc908bd75cc09/" rel="bookmark">
			成为CSDN的博客专家有那些好处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“博客专家”是CSDN给予质量较高、影响力较大的IT类博客的荣誉称号，代表了CSDN官方对其博客的肯定。成为博客专家后会得到我们一系列的服务，如 在头像上加象征荣誉的专家勋章、有专人对接提供服务、文章获得更多的推荐机会、不定时获得CSDN的礼品、优先获得CSDN举办的各种会议的门票等。
申请地址：https://blog.csdn.net/experts/apply
「博客专家」申请及审核执行标准 “博客专家”是CSDN给予质量较高、影响力较大的IT类博客的荣誉称号，代表了CSDN官方对其博客的肯定，同时博客专家也需要承担一定的社区责任。
申请CSDN博客专家应具备的条件： 1.在CSDN坚持写作三年及以上；
2.原创技术文章总数超过100篇，并且最近6个月内有一定的活跃度；
3.博客文章总浏览量超过20万次以上，同时参考点赞、评论、收藏等交互数据；
4.原创文章占比80%以上，且文章内容有一定深度；
5.企业、团队等非个人开设的博客，需要原创技术文章总数超过150篇，并且最近一个月内发布了新的原创技术文章，博文总浏览量超30万次才能申请博客专家；
6.其他情况：
1)、在CSDN学院成功发布过课程的博主可适当放宽要求；
「博客专家」注意事项： 1.以上申请条件为必要不充分条件，具体会根据不同情况审核；
2.所有博客专家（包括荣誉专家）均为实名制；
3.CSDN博客专家在三个月内如果没有发布任何原创或翻译博文，其博客专家身份将自动取消，转为博客频道荣誉专家，不能继续享有博客专家的福利；
4.CSDN博客专家不是CSDN博客的全职或兼职管理人员，不具备CSDN博客的管理权力，其观点及行为仅代表个人，不代表CSDN官方立场；
5.CSDN博客专家如有违反CSDN网站规则的行为，如大量发布广告或软文，对CSDN网站造成不良影响等，将永久取消其CSDN博客专家身份；希望恢复博客专家身份可联系管理员重新申请。
「博客专家」专属福利： 1.博客专家用户头像上显示“专家”勋章；
2.博客专家发布博客时可以直接引用CSDN站外的图片；
3.博客专家有机会免费参加CSDN举办的各种会议；
4.博客专家有机会成为CSDN学院讲师、CSDN博乐、CSDN问答导师等；
5.博客专家有更多演讲机会，CSDN会推荐给厂商或者各种IT技术大会作为演讲嘉宾；
6.博客专家享有月度原创奖励，C币、图书或定制礼品；
7.博客专家享有自定义模块、自定义域名、全站免广告等权益；
8.文章获得更多的推荐机会：博客专家所发的文章都会进入文章预选库，我们有专门的编辑负责从中筛选优质内容，并推荐到CSDN首页或其他内容频道。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e151c2ecae7a435804e0aae1b236a76/" rel="bookmark">
			pywin32
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Windows平台上，从原来使用C/C++编写原生EXE程序，到使用Python编写一些常用脚本程序，成熟的模块的使用使得编程效率大大提高了。
不过，python模块虽多，也不可能满足开发者的所有需求。而且，模块为了便于使用，通常都封装过度，有些功能无法灵活使用，必须直接调用Windows API来实现。
要完成这一目标，有两种办法，一种是使用C编写Python扩展模块，或者就是编写普通的DLL通过python的ctypes来调用，但是这样就部分牺牲掉了Python的快速开发、免编译特性。
还好，有一个模块pywin32可以解决这个问题，它直接包装了几乎所有的Windows API，可以方便地从Python直接调用，该模块另一大主要功能是通过Python进行COM编程。
安装时可以直接使用pip执行“pip install pywin32”来安装它。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89a0c1379e940ef060a2c1b89d1460a2/" rel="bookmark">
			计算机主板供电故障,电脑主板内部电池供电出现问题，会出现哪些故障问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人的电脑经常出现各种故障问题，但是出问题了又不知道是哪里出现问题，今天教大家一起认识一下主板出现问题，都有哪些故障显示，更好找到问题。
电脑主板上的电池主要作用就是为主板内部供电，主要是为了保存内部时钟以及CMOS设置。在主板南桥区域有一个RTC振荡电路，它需要主板在没有任何外界电源的情况下能继续工作，为下一次开机、以及内部时钟事先做好准备，而电池正好是为这小部分电路供电，以满足其正常工作。
这也是为什么当我们断掉电脑所有外部电源后，下次电脑开机后，电脑上的时间不会乱的原因，另外主板BiOS设置也是基于此原理。
了解主板电池原理后，对于主板电池没电了会怎么样？就比较好理解了，没有了主板电池，会出现以下几种现象：
1、电脑每次开机，时间都会恢复到初始时间，也就是说，时间不能正常同步，时间不准的问题，每次重启电脑，其电脑时间都恢复到了出厂设置的时间；
2、电脑Bios设置不生效；
当主板电池没电了会出现这样的情况，进入主板BIOS设置后，重启电脑，其之前设置的BIOS项目都失效，又会恢复到原始设置；比如电脑设置了开机密码，但如果主板电池没电，就会出现设置了开机密码失效，下次依然可以直接进入电脑；
3、还有一种情况是，电脑BIOS没电后，电脑不能正常启动开机，显示的是黑屏界面。当然也有部分电脑没有主板电池也可以开机，不过经常无主板电池进行开机使用，容易损坏主板南桥芯片，导致主板损坏。
通常电脑主板电池的寿命为四年，一般情况下我们都三年更换一次电池，电脑使用四五年后，就容易导致电池老化，容易导致时间不准，主板bios设置失效等，解决办法是更换电池奥！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eafb2442e1a2f625578dc1e6b0b812de/" rel="bookmark">
			Java：SpringMVC 基础 &amp;“登录”小项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 MVC设计模式Spring MVCSpringMVC 的执行流程Spring MVC优点 MVC项目——实现登录1. 创建Web应用并引入JAR包2. Spring MVC配置2.1 定义DispatcherServlet2.2 创建Spring MVC配置文件 3. 创建Controller4. 创建 View5. 部署运行 MVC设计模式 MVC 设计模式一般指 MVC 框架，M（Model）指数据模型层，V（View）指视图层，C（Controller）指控制层。使用 MVC 的目的是将 M 和 V 的实现代码分离，使同一个程序可以有不同的表现形式。
视图层（View）：负责格式化数据并把它们呈现给用户，包括数据展示、用户交互、数据验证、界面设计等功能。控制层（Controller）：负责接收并转发请求，对请求进行处理后，指定视图并将响应结果发送给客户端。数据模型层（Model）：模型对象拥有最多的处理任务，是应用程序的主体部分，它负责数据逻辑（业务规则）的处理和实现数据操作（即在数据库中存取数据）。 Spring MVC Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，是结构最清晰的 Servlet+JSP+JavaBean 的实现。
在 Spring MVC 框架中，Controller 替换 Servlet 来担负控制器的职责，用于接收请求，调用相应的 Model 进行处理，处理器完成业务处理后返回处理结果。Controller 调用相应的 View 并对处理结果进行视图渲染，最终客户端得到响应信息。
Spring MVC 框架采用松耦合可插拔的组件结构，具有高度可配置性，比起其它 MVC 框架更具有扩展性和灵活性。
SpringMVC 的执行流程 用户点击某个请求路径，发起一个 HTTP request 请求，该请求会被提交到 DispatcherServlet（前端控制器）；由 DispatcherServlet 请求一个或多个 HandlerMapping（处理器映射器），并返回一个执行链（HandlerExecutionChain）；DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）；HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（称为 Controller）；Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC的底层对象，包括 Model 数据模型和 View 视图信息）；HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet ；DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析；ViewResolver 根据 View 信息匹配到相应的视图结果，并返回给 DispatcherServlet；DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）；视图负责将结果显示到浏览器（客户端）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eafb2442e1a2f625578dc1e6b0b812de/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/302/">«</a>
	<span class="pagination__item pagination__item--current">303/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/304/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>