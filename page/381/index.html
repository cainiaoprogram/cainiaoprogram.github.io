<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a89006cc43f5192e26d97a00c2b31b8f/" rel="bookmark">
			pip闪退问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip闪退？应该是你打开错对话框了。。。
错误操作： 点击打开，直接闪退。
正确操作： 这才是你要的界面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06033171e84199667b41587900eaa251/" rel="bookmark">
			【unity】加载场景进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在游戏中切换场景是很有用处的，尤其是大场景，加载时间很长，我们可以显示一个进度条异步加载，提高用户体验
1.新建场景 新建两个场景，分别是“LoadScene”和“NewScene”，其中LoadScene用来显示进度条
新建好之后，我们分别点击“File–Build Setting–Add Open Scenes”添加场景
2.创建进度条 我们打开LoadScene，依次点击“GameObject–UI–Slider”创建一个进度条，修改好大小和位置，再创建一个Text用于显示进度信息
3.创建脚本 新建一个脚本，比如叫LoadScene.cs，内容如下
using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.SceneManagement; using UnityEngine.UI; public class LoadScene : MonoBehaviour { AsyncOperation async; public Slider slider; public Text text;//百分制显示进度加载情况 void Start() { //开启协程 StartCoroutine("loginMy"); } void Update() { } IEnumerator loginMy() { int displayProgress = 0; int toProgress = 0; AsyncOperation op = SceneManager.LoadSceneAsync("NewScene"); //此处改成要加载的场景名 op.allowSceneActivation = false; while (op.progress &lt; 0.9f) //此处如果是 &lt;= 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06033171e84199667b41587900eaa251/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4364639fd3bbf4561cb1b87c5d164890/" rel="bookmark">
			National Project
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Your company was appointed to lay new asphalt on the highway of length nn. You know that every day you can either repair one unit of the highway (lay new asphalt over one unit of the highway) or skip repairing. Skipping the repair is necessary because of the climate. The climate in your region is periodical: there are gg days when the weather is good and if you lay new asphalt these days it becomes high-quality pavement; after that, the weather during the next bb days is bad, and if you lay new asphalt these days it becomes low-quality pavement; again gg good days, bb bad days and so on.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4364639fd3bbf4561cb1b87c5d164890/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c31f2a7a0eb4eb6c35c0a81094688d3/" rel="bookmark">
			JavaWeb学习2---Tomcat的安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Tomcat 1、 安装tomcat tomcat官网：http://tomcat.apache.org/
2、Tomcat启动和配置 文件夹作用：
启动。关闭Tomcat
访问测试：http://localhost:8080/
可能遇到的问题：
Java环境变量没有配置闪退问题：需要配置兼容性乱码问题：配置文件中设置 3、配置 可以配置启动的端口号
tomcat的默认端口号为：8080mysql：3306http：80https：443 &lt;Connector port="8081" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 可以配置主机的名称
默认的主机名为：localhost-&gt;127.0.0.1默认网站应用存放的位置为：webapps &lt;Host name="www.qinjiang.com" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; 高难度面试题： 请你谈谈网站是如何进行访问的！
输入一个域名；回车
检查本机的 C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个域名映射；
有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问
127.0.0.1 www.qinjiang.com 没有：去DNS服务器找，找到的话就返回，找不到就返回找不到；
可以配置一下环境变量（可选性） 4、发布一个web网站 不会就先模仿
将自己写的网站，放到服务器(Tomcat)中指定的web应用的文件夹（webapps）下，就可以访问了 网站应该有的结构
--webapps ：Tomcat服务器的web目录 -ROOT -kuangstudy ：网站的目录名 - WEB-INF -classes : java程序 -lib：web应用所依赖的jar包 -web.xml ：网站配置文件 - index.html 默认的首页 - static -css -style.css -js -img -..... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b26ce0d08f89cdceb2802aba669acaeb/" rel="bookmark">
			Homebrew  添加阿里镜像和恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加阿里镜像
# 替换成阿里巴巴的 brew.git 仓库地址: cd "$(brew --repo)" git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git # 替换成阿里巴巴的 homebrew-core.git 仓库地址: cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core" git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git if [ $SHELL = "/bin/bash" ] #如果你的是bash then # 替换 homebrew-bottles 访问 URL: echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' &gt;&gt; ~/.bash_profile source ~/.bash_profile elif [ $SHELL = "/bin/zsh" ] #如果用的shell 是zsh的话 then # 替换成阿里巴巴的 homebrew-bottles 访问地址: echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' &gt;&gt; ~/.zshrc source ~/.zshrc fi 恢复镜像
# 还原为官方提供的 brew.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b26ce0d08f89cdceb2802aba669acaeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de08f00141f611f7ee6f79d455545402/" rel="bookmark">
			Linux内存管理第四章 -- 进程地址空间（Process Address Space）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux内存管理第四章 -- 进程地址空间（Process Address Space）Linear Address SpaceManaging the Address SpaceProcess Address Space DescriptorAllocating a DescriptorInitialising a DescriptorDestroying a Descriptor Memory RegionsMemory Region OperationsFile/Device backed memory regions Page FaultingHandling a Page FaultDemand AllocationHandling anonymous pagesHandling file/device backed pages Demand PagingCopy On Write (COW) Pages Copying To/From Userspace Linux内存管理第四章 – 进程地址空间（Process Address Space） Linear Address Space 从user的观点来看，地址空间是一块平坦的线性地址空间，但可以预见的是从kernel的观点来看，地址空间却大有不同。虚拟地址空间被分割成两部分，userspace部分随着进程上下文的切换而改变但kernel space的部分始终保持不变。虚拟地址空间被切割的位置有宏PAGE_OFFSET决定，在x86上PAGE_OFFSET = 0xC0000000。即用户进程可用的虚拟地址空间是3GB，而另外1GB始终有kernel使用。kernel space的线性虚拟地址的概略图如下：
从PAGE_OFFSET开始的8MB(两个PGD所映射的内存空间)预留起来用于加载Linux内核镜像。对于UMA来说，在kernel image后有很短的间隔之后存放的是全局变量mem_map的地址。而mem_map的地址通常是16MB的位置从而避免使用ZONE_DMA，但也不是总是如此。而NUMA架构下，虚拟mem_map的部分内容将分散在该区域，其具体的位置有各架构决定。例如在X86下，硬件架构指定每个node的lmem_map的地址在数组node_remap_start_vaddr中，然后将node_remap_start_vaddr中的第一个地址赋值给mem_map。
Managing the Address Space 每个进程的进程描述符struct task_struct中的struct mm_struct用来管理用户虚拟地址空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de08f00141f611f7ee6f79d455545402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e97526a9631593d21ee616209b38352/" rel="bookmark">
			通过HTTPS使用HttpClient信任所有证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在Https上发布了有关HttpClient的问题（ 在此处找到 ）。 我取得了一些进展，但遇到了新问题。 与我的最后一个问题一样，我似乎找不到任何适合我的示例。 基本上，我希望我的客户端接受任何证书（因为我只指向一台服务器），但是我不断收到javax.net.ssl.SSLException: Not trusted server certificate exception. 这就是我所拥有的： public void connect() throws A_WHOLE_BUNCH_OF_EXCEPTIONS { HttpPost post = new HttpPost(new URI(PROD_URL)); post.setEntity(new StringEntity(BODY)); KeyStore trusted = KeyStore.getInstance("BKS"); trusted.load(null, "".toCharArray()); SSLSocketFactory sslf = new SSLSocketFactory(trusted); sslf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); SchemeRegistry schemeRegistry = new SchemeRegistry(); schemeRegistry.register(new Scheme ("https", sslf, 443)); SingleClientConnManager cm = new SingleClientConnManager(post.getParams(), schemeRegistry); HttpClient client = new DefaultHttpClient(cm, post.getParams()); HttpResponse result = client.execute(post); } 这是我得到的错误： W/System.err( 901): javax.net.ssl.SSLException: Not trusted server certificate W/System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e97526a9631593d21ee616209b38352/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47cbc41619aa85b30c97a722bdb9925c/" rel="bookmark">
			Educational Codeforces Round 82 (Rated for Div.2)B. National Project
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B. National Project
time limit per test2 seconds
memory limit per test256 megabytes
inputstandard input
outputstandard output
Your company was appointed to lay new asphalt on the highway of length n. You know that every day you can either repair one unit of the highway (lay new asphalt over one unit of the highway) or skip repairing.
Skipping the repair is necessary because of the climate. The climate in your region is periodical: there are g days when the climate is good and if you lay new asphalt these days it becomes high-quality pavement; after that, the weather during the next b days is bad, and if you lay new asphalt these days it becomes low-quality pavement; again g good days, b bad days and so on.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47cbc41619aa85b30c97a722bdb9925c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f154426a9e8118bdf1a26197c2693058/" rel="bookmark">
			Dubbo--RPC概述、Dubbo概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 RPC RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。
RPC基本原理 RPC两个核心模块：
通讯序列化 Dubbo Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。
基本概念 服务提供者（Provider）： 暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。服务消费者（Consumer）: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。注册中心（Registry）： 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者监控中心（Monitor）： 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 调用关系说明：
服务容器负责启动，加载，运行服务提供者。服务提供者在启动时，向注册中心注册自己提供的服务。服务消费者在启动时，向注册中心订阅自己所需的服务。注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0afcdceb81ce93c1dda55bc38787a5f2/" rel="bookmark">
			TypeError: this.CliEngine is not a constructor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue cli3 项目老是提示TypeError: this.CliEngine is not a constructor这个,看着特别扭
解决方法也不难，直接点击Details
然后再点击，如下第一个文件链接
找到如下方法
function ESLintPlugin(state) { this.filterSource = state.filterSource; this.additionalRulesDirectory = state.additionalRootDirectory; this.calcBasicPath(state.eslintPackagePath); this.version = this.readVersion(); if (this.initError == null) { this.linter = require(this.basicPath + "lib/cli.js"); this.options = require(this.basicPath + "lib/options"); this.CliEngine = require(this.basicPath + "lib/cli-engine"); } } 将this.CliEngine = require(this.basicPath + "lib/cli-engine"); 更改为 this.CliEngine = require(this.basicPath + "lib/cli-engine").CLIEngine;
然后重启webstorm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca477b6672d459920e0ce4937ec6e29/" rel="bookmark">
			用MNIST数据集实现K-折交叉验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本思路
K-折交叉验证的方法是将数据集分成k个互斥的子集（一般是均分），然后将每个子集分别做一次验证集，其余K-1组子集作为训练集。在每次训练完的模型后进行验证来对模型性能进行估计。
应用的函数
tf.range(） tf.range(start, limit, delta=1, dtype=None, name='range' 功能是创建一个开始于 start 并且将以 delta 为增量扩展到limit-1 的数字序列。
例如：
a = tf.range(0, 10) tf.Tensor([0 1 2 3 4 5 6 7 8 9], shape=(10,), dtype=int32) tf.random.shuffle() tf.random_shuffle( value, seed=None, name=None ) 功能：对张量value的第一维度进行打乱。
例如：
a = tf.random.shuffle(a) tf.Tensor([4 3 7 5 9 8 6 1 0 2], shape=(10,), dtype=int32) tf.gather（）
功能：用一个索引数组将张量中对应索引的向量提取出来。
例如： index = tf.range(0, 2) # [0, 1] x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] print(tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dca477b6672d459920e0ce4937ec6e29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6c423ab74c02fbe7de5d94cfed4ca0a/" rel="bookmark">
			ImportError: Could not import backend for traitsui.  Make sure you have a suitable UI toolkit like
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 问题问题原因解决方法 问题 在运行mayavi时会出现如下问题：
Traceback (most recent call last): File "E:/Aworkspace/PycharmProjects/untitled/sss.py", line 36, in &lt;module&gt; s = mlab.mesh(x,y,z) File "E:\softinstall\Anaconda3\lib\site-packages\mayavi\tools\helper_functions.py", line 37, in the_function return pipeline(*args, **kwargs) File "E:\softinstall\Anaconda3\lib\site-packages\mayavi\tools\helper_functions.py", line 77, in __call__ scene = tools.gcf().scene File "E:\softinstall\Anaconda3\lib\site-packages\mayavi\tools\figure.py", line 114, in gcf engine = get_engine() File "E:\softinstall\Anaconda3\lib\site-packages\mayavi\tools\engine_manager.py", line 92, in get_engine return self.new_engine() File "E:\softinstall\Anaconda3\lib\site-packages\mayavi\tools\engine_manager.py", line 137, in new_engine check_backend() File "E:\softinstall\Anaconda3\lib\site-packages\mayavi\tools\engine_manager.py", line 40, in check_backend raise ImportError(msg) ImportError: Could not import backend for traitsui.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6c423ab74c02fbe7de5d94cfed4ca0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fce7c90cd22190ca7a94b26f4dceef9/" rel="bookmark">
			[C&#43;&#43;]类型的自动转换和强制转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中，存在隐式类型转换语法(自动转换) int a=12; a=22.5+a; C++还提供了显式类型转换(强制转换) int num=int(99.5); int num2=(int)99.5; //两种写法都正确 注意 不管是自定义类型转换还是强制类型转换，前提是编译器必须知道是如何转换的 将浮点型变量赋值给整型变量时，舍弃小数部分将整型数据赋值给浮点型变量时，数值不变，但是以指数形式储存将double型数据赋值给float型变量时，注意数值范围溢出字符型数据可以复制给整型变量，此时存入的是字符的ASCII码将一个int,short,long型数据赋值给一个char型变量，只将低八位原封不动的送到char型变量中将有符号数据赋值给长度相同的无符号型变量，连同原来的符号位一起传送 C++允许我们自定义转换类型规则 用户可以将其他类型转换为当前类型，也可以将当前类型转换为其它类型 这种自定义的类型转换规则，只能以类的成员函数的形式出现 将其他类型转换为当前类型需要借助转换构造函数 C++中将只含一个参数的构造函数称为转换构造 目的是将其他类型转换为当前类型使用 class Rectangle { int m_width; int m_length; public: Rectangle(); //无参构造函数 ~Rectangle(); //析构函数 Rectangle(float); //转换构造函数 Rectangle(float, float); Rectangle(const Rectangle&amp; rec); //拷贝构造 }; 将当前类型转换为其他类型 类型转换函数 类型转换函数的作用就是将当前类型转换为其他类型 它只能以成员函数的形式出现，也就是只能出现在类中 //类型转换函数的语法格式 operatoe type(){ return data; } type可以是内置类型，类类型，以及由typedef定义的类型别名，任何作为函数返回值的类型(void除外)都是被支持的(不允许转换为数组或函数类型，可以转换为指针或引用类型) 类型转换函数一般不会更改被转换对象，所以通常被定义为const 类型转换函数可以继承，可以是虚函数 类型转换函数看起来没有返回值，其实是隐式指明了返回类型 类型转换函数也没有参数，因为要将当前类的对象转换为其他类型 class Rectangle { float m_width; float m_length; public: Rectangle(); ~Rectangle(); Rectangle(float); Rectangle(float, float); Rectangle(const Rectangle&amp; rec); operator float() const { return this-&gt;m_length; } }; int main() { Rectangle rec(95.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fce7c90cd22190ca7a94b26f4dceef9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52e4cfcee9a1d39481cd5fd2e01c5213/" rel="bookmark">
			轻量化 | 如何让笨重的深度学习模型在移动设备上跑起来？看它！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“AI算法修炼营”，选择加星标或“置顶”
标题以下，全是干货
概述 卷积神经网络依靠神经网络中数以千万计的网络参数共同参与计算，存在网络结构复杂，运算量大，速度慢的缺点，并且很难移植到嵌入式设备中。随着网络模型层数越来越深，参数越来越多，减少他们的大小和计算损耗至关重要，特别是对于在线学习和增强学习这样的实时应用来说。不仅如此，近年来 VR，AR 以及智能可穿戴设备的高速发展，需要研究者们解决将大规模学习系统部署到移动设备上的问题。而达到这个目标需要从很多方面获取整合的解决方案，包括但不限于机器学习，优化方法，计算机结构，数据压缩，索引和硬件设计。这是一个重要且十分活跃的领域。
近年来，许多学者在深度学习压缩和加速方面已经做出许多成果， 出了多种神经网络轻量化的算法，主要可分为以下几类。
1. 网络剪枝 网络剪枝目的在于找出这些冗余连接并将其移除，使其不再参与网络的前向或后向运算过程中，起到减少网络计算量的作用，如下图所示。
移除的神经元及相应连接也不再存储，减少了模型的存储量。在这个过程中，一个原本稠密的神经网络由于部分连接的移除而变得稀疏。
由于全连接层冗余度远远高于卷积层，传统的网络剪枝方法多用于全连接层中。网络剪枝往往针对已经训练好的模型进行，在得到训练好的模型后，根据某种评价标准定义每条连接的重要程度。一种广泛使用的评价标准是连接权重的绝对值大小，该值越小，说明对应的神经元对网络输出结果影响越小，属于不重要的神经元，应该被移除，对应的连接也应被剪除。
虽然移除的连接不那么重要，但随着网络计算过程中的错误累积，网络性能和准确度依然会受到较大的影响，为了消除这些影响，一个很重要的步骤是对剪枝后的网络进行微调训练来恢复网络性能。整个网络剪枝和调优交替进行，直至达到模型大小与模型性能间的最佳平衡。
权重剪枝主要有两种方式：
（1）后剪枝：拿到一个模型直接对权重进行剪枝，不需要其他条件。
（2）训练时剪枝：训练迭代时边剪枝，使网络在训练过程中权重逐渐趋于0，但是由于训练时权重动态调整，使得剪枝操作对网络精度的影响可以减少，所以训练时剪枝比后剪枝更加稳定。
在剪枝结束后，权值矩阵由稠密矩阵变为稀疏矩阵。
为了减少参数的存储量，通常使用存储稀疏矩阵的压缩存储方式存储参数，代表方式为稀疏行压缩方法 (Compressed Sparse Row,CSR）和稀疏列压缩方法 (Compressed SparseColumn,CSC)。
TF官方提供了详尽的Keras剪枝教程和Python API文档，以及训练稀疏模型等高级用法的指导。
2. 权值量化 量化概念
网络量化通过减少表示每个权重的比特数的方法来压缩神经网络。
量化的思想非常简单，就是对权重数值进行聚类。统计网络权重和激活值的取值范围，找到最大值最小值后进行min-max映射把所有的权重和激活映射到到INT8整型范围（-127~128）。
在卷积神经网络中，参数所分布在的数值空间，通过一定的划分方法，总是可以划分为 k 个类别，因此可以通过存储这 k 个类别的中心值或者映射值从而压缩网络的存储。
通过全值量化方法，一方面可以减少模型的存储占用的空间。模型的权值参数往往以 32 位浮点数的形式保存，神经网络中往往具有数以千万计的参数，会占据极大的存储空间，因此，如果在存储模型参数时将 32 位浮点数量化为 8 位的定点数，可以把参数大小缩小为原来的 1/4，整个模型的大小也可以缩小为原来的 1/4，不仅如此，随着参数量化后模型的减小，网络前向运算阶段所需要的计算资源也会大大减少。
量化步骤
量化具体步骤如下：
（1）量化：首先对权重矩阵中的所有权值进行 k 均值聚类，以图示为例，将其聚为四类，不同类用不同颜色表示，聚类结束后同一类的权重值用对应的聚类索引和聚类中心值表示。
（2）反向传播：使用普通的梯度计算方法得到每个权重所对应的梯度，根据之前的权重分组，将同一组的权重梯度值进行累加，得到聚类中心这一轮网络训练中的更新量，聚类中心值减去更新量与学习率的乘积，就得到本轮训练更新后的聚类中心。
经过多次聚类-训练-更新步骤后，就可以得到量化后的神经网络模型，每个权重可以仅仅由其对应的聚类中心值和聚类索引来表示。
一种更为极端的方式是二值量化，即仅仅使用 (-1) 和 (+1) 来表示权重值，此时一个权重值仅仅只占用一个比特位，参数模型压缩到仅为原来的 1/32，并且-1,+1 相比普通的浮点数权值，在乘加运算中具有天然的计算优势，计算效率极高。
量化为什么有效
首先量化会损失精度，这相当于给网络引入了噪声，但是神经网络一般对噪声是不太敏感的，只要控制好量化的程度，对高级任务精度影响可以做到很小。
其次，传统的卷积操作都是使用FP32浮点，浮点运算时需要很多时间周期来完成，但是如果我们将权重参数和激活在输入各个层之前量化到INT8，位数少了乘法操作少了，而且此时做的卷积操作都是整型的乘加运算，比浮点快很多，运算结束后再将结果乘上scale_factor变回FP32，这整个过程就比传统卷积方式快很多。
从体系结构的考量角度思考量化带来的另一个好处是节能和芯片面积，每个数使用了更少的位数，做运算时需要搬运的数据量少了，减少了访存开销（节能），同时所需的乘法器数目也减少（减少芯片面积）。
3. 低秩近似 基于低秩分解的方法从分解矩阵运算的角度对模型计算过程进行了优化，具有清晰的数学解释，是减少模型冗余和加速模型运算的一种非常有效的方法，特别是对于全连接层的压缩和加速。
大多数的计算量分布在卷积层中。在卷积层结构中，网络层的参数通常以多维矩阵的形式保存。通过使用线性代数的方法将参数矩阵分解为一系列小矩阵的组合，使得小矩阵的组合在表达能力上与原始卷积层基本一致，这就是基于低秩分解方法的本质。
该方法可以保持模型一定的精度并能够极大地降低参数存储所占用的空间并按照从浅到深的顺序逐层对卷积层做低秩近似处理，在一层经过低秩分解后，固定该层参数，并用一种重构误差进行微调。
缺点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52e4cfcee9a1d39481cd5fd2e01c5213/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9448b38d4d2b7ffd7553a71cc05de608/" rel="bookmark">
			AUTOSAR_DCM&amp;DEM(UDS&amp;OBD)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.术语与缩写 术语 DCM Diagnostic Communication Mannger
DEM
Diagnostic Event Mannger
UDS Unified diagnostic services
OBD On-Board Diagnosis
DSD
Diagnostic Service Dispatcher
DSL
Diagnostic Session Layer
DSP
Diagnostic Service Processing
SID
Server Identifier
2.文章简介 本文主要介绍DCM 与DEM模块，以及这两个模块在Autosar架构下如何运行。同时介绍了UDS 和OBD中相关概念。
3.DCM模块 1.什么是DCM 如上图所示，DCM模块负责接收并响应诊断仪的数据请求。在AUTOSAR_SWS_DCM文档中描述如下：
也就是说，DCM模块负责诊断数据流以及诊断状态的管理。并且检查请求的服务是否在当前的会话和安全等级中支持。
2.DCM模块如何工作 根据上图可以看出，当ECU接收到诊断报文时，经过CANTp模块进行网络层解析（15765-2），在根据报文的归属判断，由PDUR模块转发置DCM模块。当DCM收到诊断报文时，DCM模块就开始运行了。
DCM模块由三个子模块组成：DSL DSD DSP组成。
DSL:Diagnostic Session Layer,DSL模块负责确认诊断数据流的请求与响应。确保诊断计时以及诊断状态的切换。
DSD: Diagnostic Service Dispatcher,DSD负责接收网络上的诊断请求，并转发到对应的数据处理模块。接收响应数据并将数据传递给DSL模块，在由DSL模块发送到网路。
DSP:Diagnostic Service Processing,DSP负责处理诊断服务请求。
三个模块架构如下：
3.诊断服务（UDS&amp;OBD）
DCM是服务的形式响应诊断仪的数据请求的。DCM支持UDS（14229-1）和OBD-II(15765-4)的全部服务。这里只介绍一部分诊断服务，详细请参考14229和15031。
10服务 DiagnosticSessionControl (0x10) service，用于激活和切换会话。在默认状态下ECU处于Default Session。14229-1中定义了如下几个Other Session。14229-2中有关于会话层的详细描述。
一般用到02 Programming Session和03 Extended Diagnostic Session。02服务用于开启编程,APP主动跳转到Boot,并告知Boot处于SIB(Stay In Boot)状态等待升级。这里会涉及到一个问题，也就是Programmning Session的请求是APP响应还是Boot响应，一般是由BOOT响应，但是各家做法可能不同，APP也可以响应。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9448b38d4d2b7ffd7553a71cc05de608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffcd63b853429ca92dc81375cf85ceaf/" rel="bookmark">
			二四、向量在子空间上的投影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 向量在直线上的投影 2. 向量在子空间上的投影 直线L实际上是一个特殊的子空间
定义：
假设V是Rn的一个子空间，V正交补是Rn的另一个子空间，Rn中的任意向量x为
那么，向量x在子空间V上的投影为向量v，向量x在子空间V正交补上的投影为w，即：
在二维、三维空间可以可视化，超过三维就没有办法可视化了
3. 求向量在子空间上的投影 假设V是Rn的一个子空间，且V的一组基为：
现在，用V的基向量构建一个矩阵A：
假设：
如果知道向量y，那么就可以求出向量x在子空间上的投影，下面为如何求出向量y
因为：
因为V子空间等于矩阵A的列空间，所以V正交补等于A转置矩阵的零空间
4. 向量在子空间上的投影是线性变换 任何表示成矩阵向量积的变换都是线性变换，所以向量在子空间上的投影是线性变换
5. 向量x在子空间的投影是子空间中距离x最近的向量 根据直角三角形斜边大于两个直角边可以证明
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f89872c786285365b0646b6f4f5c53/" rel="bookmark">
			指定清华源下载模块方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有时候我们安装一些模块总是报 Read timed out的错误，这是因为网速的问题，外网的包国内下载较慢。这时候使用清华源就可以搞定，下载时指定清华源的方法是：
如指定清华源下载flask
pip install flask -i https://pypi.tuna.tsinghua.edu.cn/simple 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c836427c13fd7584ca33173e1faa11c/" rel="bookmark">
			TMS320C6748开发视频教程笔记 第7章 启动与烧写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第7章 启动与烧写 7-1 启动流程及方式7-2 AIS文件结构7-3 通过串口加载运行程序7-4 配置并生成AIS文件7-5 程序烧写7-4-1 CCS烧写7-4-2 串口烧写7-4-3 SD卡烧写 7-6 改进的高效烧写方式 7-1 启动流程及方式 关于启动的详细信息请参阅：Using the TMS320C6748/C746/C6742 Bootloader
介绍开发板启动流程和不同的烧写方式。
详细讲解整个C6748芯片的启动流程以及多种不同的启动方式AIS文件是什么及AIS文件的结构如何通过串口把程序加载到开发板并运行多种程序烧写的方法
时钟和电源必不可少，内部1MB大小的ROM，内部包含一个Bootloader程序。对于不同硬件版本的芯片来说其启动方式有些不同。SD卡在2.1版本以上才支持。用CCS连接开发板，通过查看0x11700000这个地址的前几个字节的内容来确定，目前最新的版本是：d800k008。之前还有d800k006、d800k004、d800k002版本，对于最新的版本芯片，其启动方式也是最全的。
在给C6748芯片供电以后，储存在ROM中的Rom Bootloader就会首先捕获Boot Config寄存器的值。而Boot Config寄存器的值是通过Boot管脚来实现的。这里要说明一下，Boot管脚在硬件上是和LCD、GPIO及uPP复用，但是因为Boot管脚的作用只在启动的一瞬间对整个系统有影响，在启动以后，不会影响LCD、GPIO的工作。默认情况下启动配置管脚有8位，其中有5位是配置启动设备的，其他3位为设备指定一些启动参数。在Rom BootLoader捕获了管脚的配置后，根据设置选择要启动的方式，从类型上分主要有3种：非AIS模式、AIS主设备模式、AIS从设备模式。 AIS是TI的一种二进制镜像文件的格式，在后面会详细讲解到它的组成和作用。
非AIS模式支持从以下4种设备中启动：EMIF NOR Flash Legency、EMIF NOR Flash Direct、HPI、Emulation Debug（仿真模式）。如果想使用前两种模式，NOR Flash必须连接到EMIF接口上的，而不是SPI或IIC接口上的FLASH芯片。对于这两种EMIF接口上的NOR Flash启动也分为两种情况：设备是从EMIF NOR Flash方式启动，首先，RBL（ROM BootLoader）会读取NOR flash中的第一个字，即（4个字节）32位的数据，这个数据有两个作用，一个是表示从NOR Flash启动的方式，另外一个作用表示从NOR flash中拷贝多少数据到内存。对于第一种（EMIF NOR Flash Legency）启动方式来说：DSP首先读取这1个字的配置信息，确定是从EMIF NOR Flash Legency方式启动，然后根据配置信息指定的大小，将相应的数据拷贝到DSP的L2 RAM中。需要注意的是：如果自己写的DSP应用程序要完全在L2内存中运行的话，需要注意从起始地址偏移一定的地址来为RBL（ROM BootLoader）留一定使用空间，如果程序默认完全从L2内存的起始地址，也就是（0x11800000）会影响RBL（ROM BootLoader）的工作导致程序不能正常运行。所以建议从0x11800000偏移一定的地址，为RBL留出一定的运行空间。可以通过第一个配置字可以指定拷贝大小从1KB到16KB，也就是说最大只能拷贝16KB的数据到L2 RAM，这就意味着我们在NOR Flash的前一部分的空间只能存放一个类似于二级Bootloader的东西，然后再从NOR Flash加载剩余的用户程序，这样才能稳定的运行，否则，一般情况下16KB的大小不会包含很多的程序内容，也不会实现更复杂的功能。所以，一般情况下，最大16KB的内容我们一般是写一个二级引导程序，也就是所谓的UBL（User BootLader）。对于第二种非AIS模式的EMIF NOR Flash启动方式从Direct名字中就可以得出，它是直接从NOR Flash启动的。之前也简单说过NOR Flash和NAND Flash的区别，NOR Flash因为有足够的地址线，所以对它的读取可以像读取RAM一样读取，也就是我们对这个接口初始化以后就可以直接使用内存的方式读取。所以对于NOR Flash我们程序是可以直接从NOR Flash中运行的。但需要注意的是：如果使用这种启动方式的话，我们在CMD文件中，需要将已初始化的段，比如说.text段（程序代码）、.cint段等一些已初始化的数据必须把它的空间分配到NOR Flash的地址中才能够运行。而对于数据空间，也就是我们使用的一些变量，我们还需要将它们放到RAM中。这里需要注意的是，对于这两种启动模式，它的程序入口都是固定为0x11800004，已经用的4个字节是用作NOR Flash的启动配置，自己的程序入口地址固定为这个值。HPI启动模式：HPI是一个很重要的启动方式也是一个很重要的接口，在TI几乎所有的DSP上都有这个接口。这个接口需要注意的是，在不同的DSP芯片中，这个接口的一些参数还是不一样的，在DSP C64芯片上是32位的，在C6748上这个接口是16位的。HPI接口是TI为处理器之间相互定义的一种异步接口。这里还需要注意的是：HPI接口是从设备接口，只能作为从设备，也就是说它想跟其它的芯片相连的话，它必须接到其他芯片的扩展内存总线上，比如说EMIF接口。DSP不能通过HPI接口向主机访问，只能被主机读写，所以两个DSP的HPI接口之间不能通信。如果两个DSP相连的话，必须通过一个DSP的EMIFA接口接到另一个DSP的HPI接口上。HPI的工作方式相对来说比较复杂，主要有两种：一种是复用模式，一种是非复用模式。在复用模式下没有地址线，主机访问DSP的信息是以数据方式发送到HPI的地址寄存器。从硬件信号的角度来看，地址数据信号都是同一组数据线传递的，这就跟NAND Flash的读写方式非常类似，在读写NAND Flash也是地址、命令、数据都是通过同一组数据线来进行传输的，所以在逻辑上比较复杂，这种HPI模式称为复用模式。非复用模式，数据线与地址线分开，与内存接口类似，主机访问地址信息是通过地址总线直接赋值给HPI接口，这里需要注意的是，HPI接口都是支持复用模式的，但不是所有芯片的接口都支持非复用模式。这是一个很有用的接口，比如说在我们最终的产品上需要使用如ARM、DSP，HPI这三种芯片，但我们烧写程序的时候不希望为这3种芯片都烧写程序，这样会增加工作量，我们就可以通过HPI接口，在运行的时候需要DSP工作的时候通过ARM将程序使用HPI接口的方式直接加载到DSP当中运行，这样的话就会减少我们对启动方面的操作。需要注意的是，使用HPI接口，我们同样可能会需要一个二级的BootLoader程序，因为我们在通过HPI接口加载程序的时候，依然只能把程序加载到DSP的L2 RAM，这里主要的原因是，使用外扩的存储器，比如DDR2的时候，必须先对它初始化，所以使用HPI接口也只能把程序加载到L2 RAM中，而L2 内存最大只有256KB，如果程序超过这个大小，同样需要先加载一个类似于User BootLoader这么一个用户的二级引导程序，然后再通过这个引导程序加载更大的DSP程序。Emulation Debug是一种调试模式，在这种调试模式下，DSP的RBL不做任何初始化的操作，只是把DSP核心简单的使能，然后将所有的权限交给开发环境比如说CCS来调用，这对C6748来说问题不大，对于同系列的OMAP L138来说，在Emulation Debug模式下，RBL会使能所有的核心，对OMAP L138来说会使能ARM核心，使能DSP核心，使能PRU核心，这样我们就不需要通过先连接ARM进行初始化操作然后再连接DSP进行DSP程序的调试，在这种模式下，我们就可以直接对各个核心加载相应程序来进行调试，比较方便。而一般情况下，也推荐在Debug模式下选择这种启动方式。当然，对于这种情况，只是对于内部有ARM和DSP核心的CPU来说，对于C6748来说，它的内部主要只有一个C674x的一个DSP核心。 下面对DSP启动的主要模式，也就是AIS模式。这是非常重要的模式，DSP C6748的大部分启动模式都必须使用AIS。AIS是一种二进制文件的镜像，对于这些启动模式，用户程序必须转换成.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c836427c13fd7584ca33173e1faa11c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/834d26458af92b4f42549f1eb37fc27f/" rel="bookmark">
			Win10 Terminal 背景图片设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ①将要设置为背景的图片放在这个目录下 %LOCALAPPDATA%\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\RoamingState ②打开terminal的"Settings", 找到"profiles", 找到要设置的shell 我设置的是"cmd"
③在"icon"下面一行插入三行内容 只需要替换"自己的图片.jpg"，注意不要漏掉逗号
"backgroundImage" : "ms-appdata:///roaming/自己的图片.jpg", "backgroundImageOpacity" : 0.75, "backgroundImageStrechMode" : "fill", 效果 在profiles中，设置的是哪个模块的在这里看 每个模块的配色是看profiles中的colorScheme和下面schemes中的name的对应 一个profiles对象的示例 参数定义：
acrylicOpacity ==&gt; 亚克力模糊效果透明度，值：0~1closeOnExit ==&gt; 关闭窗口时退出当前shell，值：true|falsecolorScheme ==&gt; 颜色主题名称，为[]schemes下的主题对象中name的值commandline ==&gt; 启动终端窗口时执行指定的程序/命令/脚本cursorColor ==&gt; 光标颜色，值：16进制码cursorShape ==&gt; 光标形状，值：bar|vintage|underscore|filledBox|emptyBoxfontFace ==&gt; 字体fontSize ==&gt; 字体大小guid ==&gt; 唯一标识符historySize ==&gt; 保留历史行数icon ==&gt; 指定显示在顶部tab以及下拉菜单中的图标name ==&gt; 指定该profiles对象的名称，将会显示在下拉菜单中padding ==&gt; 边距，值：0, 0, 0, 0，值设定顺序为左、上、右、下snapOnInput ==&gt; 键入时跳转到光标位置，值：true|falsestartingDirectory ==&gt; 启动时的路径useAcrylic ==&gt; 开启亚克力模糊，值：true|false，如果设定为false，则acrylicOpacity无效 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/851580dcdf8be25ed182c24001651573/" rel="bookmark">
			OJ-倒序输出一个四位整数遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述
任意读入一个四位整数，颠倒后输出。
输入
输入一行，只有一个整数x(1000&lt;=x&lt;=9999)。
输出
输出只有一行，包括1个整数。
样例输入
4789
样例输出
9874
代码实现
#include&lt;stdio.h&gt; int main() {	int a,b; int ch[4]; scanf("%d",&amp;a); int i =0; while(a) { b = a % 10; ch[i] = b; i++; a /=10; } for (i=0;i&lt;4;i++) { printf("%d",ch[i]); } return 0; } 这个代码看似没有问题 但是实际上只能通过75%的数据集
问题出在如果输入1000 应该返回1 但是上面代码却返回了0001
解决这个问题只需要将ch数组中的数字重新拼成一个四位数即可
#include&lt;stdio.h&gt; int main() {	int a,b; int ch[4]; scanf("%d",&amp;a); int i =0; while(a!=0) { b = a % 10; ch[i] = b; i++; a /=10; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/851580dcdf8be25ed182c24001651573/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28cacfea15dc5e592fbabab6676f4181/" rel="bookmark">
			用C语言实现简单的聊天室功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用C语言实现简单的聊天室功能 服务器端 #define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; #include&lt;winsock.h&gt; #pragma comment(lib, "ws2_32.lib") #define L 256 int main() { char SendBuf[L]; char ReceiveBuf[L]; int SendLen; int ReceiveLen; int Length; SOCKET socket_server; SOCKET socket_receive; SOCKADDR_IN ServerAdd; SOCKADDR_IN ClientAdd; WORD wVR; WSADATA WsaData; int error; //++++++++++++++++++++++++++++++++++++++++++++++++ wVR = MAKEWORD(2, 2); error = WSAStartup(wVR, &amp;WsaData); if (error != 0) { printf("加载套接字失败！"); return 0; } if (LOBYTE(WsaData.wVersion) != 2 || HIBYTE(WsaData.wVersion) != 2) { printf("版本不符！"); WSACleanup(); return 0; } //++++++++++++++++++++++++++++++++++++++++++++++++ ServerAdd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28cacfea15dc5e592fbabab6676f4181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fce74ad3d53feb2f563862bfd9e694d7/" rel="bookmark">
			第四章第一题（几何：五边形的面积）(Geometry: area of a pentagon)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.1（几何：五边形的面积）编写程序，提示用户输入从五边形中心到顶点的距离，计算五边形的面积。 计算五边形的面积的公式为：面积 ，其中 s 是边长。边长可以使用公式 计算，其中 r 是从五边形中心到顶点的距离。结果保留小数点后两位数字。 下面是一个运行示例：
Enter the length from the center to a vertex: 5.5
The area of the pentagon is 71.92
4.1(Geometry: area of a pentagon) Write a program that prompts the user to enter the length from the center of a pentagon to a vertex and computes the area of the pentagon.The formula for computing the area of a pentagon is:,where s is the length of a side.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fce74ad3d53feb2f563862bfd9e694d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b3aa1bc8f493a220ee09cee838930aa/" rel="bookmark">
			ansible常用模块实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Command模块：
Command:在远程主机执行命令，默认模块可忽略-m。
Command:模块不支持变量，管道符，&amp;，$，echo &gt;等需要使用shell模块。
ansible all -m command -a 'systemctl restart network'
重启主机清单的所有主机的网络(以上是完整的写法)。
可以省略-m，因为它时默认的模块。
ansible all -a 'systemctl restart network'
ansible web -a 'ls -l /tmp' (查看web组tmp目录下面有哪些文件)
ansible all -a 'mkdir -p /data' (所有主机创建/data目录)
ansible all -a 'df -hT' (查看所有主机的磁盘使用率)
查看命令的帮助：ansible-doc command 详细参数
ansible all -a 'removes=/data/test.txt rm -rf /data/test.txt'
removes：如果这个文件不存在则不执行，文件存在则执行
ansible all -a 'ls -l /data/' (首先查看目录为空)
Ansible all -a 'creates=/data/aa.txt touch /data/aa.txt'
creates:如果存在反而不执行，如果不存在反而执行
ansible all -a 'chdir=/data ls -l'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b3aa1bc8f493a220ee09cee838930aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be96a75f58528b3cb42f54b40673fad6/" rel="bookmark">
			vbs学习，书籍，看书笔记(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航 1.对象（object）子类型
2.复杂数据类型，数组定义以及遍历
3.Option Explicit的介绍
4.变量命名
5.过程sub的语法
6.函数function的语法
7.三个变量作用域
1.对象（object）子类型
对象：含有对象引用的变量就是object子类型，具有属性（properties）与方法（methods）
创建FileSystemObject对象
引用IsObject()函数，销毁对象，对是否销毁进行判断
dim objFSO dim boolExists set objFSO = wscript.createobject("scripting.filesystemobject") 'set用于修改对象变量的值 if IsObject(objFSO) then 'isobject判断是否为对象 boolExists = objFSO.fileExists("C:\Users\93997\Desktop\vbs练习\学习") '应当是文件中的东西，单是文件会不存在 msgbox typename(boolExists) msgbox boolExists set objFSO = nothing	'对象使用完之后要销毁对象，不占内存 if objFSO is nothing then	'并且进行判断是否被销毁 msgbox "对象已经被销毁" endif end if ————————————————————————————————————————
2.复杂数据类型，数组，定义以及遍历
数组：存放同一类数据类型的数据，最多有六十维
声明：dim arrlist(5)——一维数组，dim arrlist(2,4)——二维数组(列，行)
例如存放下面数组：
小王12男小花13女 第一种方式，静态数组：
'定义数组，初始化数组和遍历数组 dim arrlist(2,4)	'定义一个二维数组（列，行） arrlist(0,0) = "小王"	'存储数据 arrlist(0,1) = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be96a75f58528b3cb42f54b40673fad6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1db5d71c7eeb1d4f5005389a5db2f223/" rel="bookmark">
			foxmail登录企业邮箱的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		再登录页面的左下角有个手动设置
pop服务器和SMTP服务器需要填的东西，根据你的邮箱类型来选择
比如我的是阿里邮箱：
就可以填：
pop3.mxhichina.com
smtp.mxhichina.com
然后点击创建就可以
邮箱类型：
https://www.west.cn/faq/list.asp?Unid=2132
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c47b4823edb9cc618f18e4bea7b8cf6/" rel="bookmark">
			欧几里得距离（欧式距离）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、定义二、公式 一、定义 欧几里得度量（欧氏距离） Euclidean Metric，Euclidean Distance：
指在m维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。
比如：在二维和三维空间中的欧氏距离就是两点之间的实际距离。
二、公式 二维：
ρ = ( x 2 − x 1 ) 2 + ( y 2 − y 1 ) 2 \rho=\sqrt{(x_2-x_1)^2+(y_2-y_1)^2} ρ=(x2​−x1​)2+(y2​−y1​)2 ​
n维：
d ( x , y ) = ∑ i = 1 n ( x i − y i ) 2 d(x,y)=\sqrt{\displaystyle\sum^{n}_{i=1}{(x_i-y_i)^2}} d(x,y)=i=1∑n​(xi​−yi​)2 ​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4b2dab8ca540bc5b44d93ae23f09f92/" rel="bookmark">
			AUTOSAR DCM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AUTOSAR诊断协议栈包含DCM和DEM两个模块，其中DEM负责DTC相关的参数实现(诊断Dem模块介绍)，而DCM模模块主要实现UDS和OBD的诊断服务，就是实现之前UDS文章提到的服务和OBD相关的服务。
DCM模块主要负责处理诊断数据流和管理诊断状态，包括诊断会话和安全状态，DCM模块能检查诊断服务的请求是否满足条件。DCM在AUTOSAR架构中的概略图如图1所示。
图1 DCM模块
DCM模块由三个子模块构成，分别是DSL(DiagnosticSession layer)、DSD(Diagnostic Service Dispatcher)、DSP(Diagnostic Service Processing)，其示意图如图2所示。
其中DSL用于确定诊断数据请求和响应的数据流；监控和确保诊断请求和响应的时序，管理诊断状态（特别是诊断会话和安全状态）。DSD用于处理诊断数据流。将接收到的诊断请求转发给数据处理器；当数据处理器触发时，通过PDUR传输诊断响应；DSP用于处理实际的诊断请求。
图2 DCM模块内部子模块
下面主要针对三个模块进行介绍。
DSL(Diagnostic Session layer)
DSL用于处理诊断数据请求和响应的数据流；监控和确保诊断请求和响应的时序。
1.处理诊断请求
当收到诊断请求时，PDUR调用Dcm_StartOfReception()和Dcm_CopyRxData()函数将收到的诊断请求数据放置在DCM模块的Buffer中，然后PDUR调用Dcm_TpTxConfirmation()函数通知Dcm模块接收到了新的诊断请求。
2. 处理诊断响应
当需要响应诊断请求时，DSL模块通过调用PduR_DcmTransimit()和Dcm_CopyTxData()将数据传递至PDUR模块，其中PduR_DcmTransimit()函数只是传递长度信息、地址信息，数据是通过Dcm_CopyTxData()函数传递至PDUR模块，当数据传输成功后，PDUR模块通过Dcm_TpTxConfirmation()函数告知DCM数据接收成功。
3. 管理安全等级
DSL提供Dcm_GetSecurityLevel()、DslInternal_SetSecurityLevel()两个函数分别用于获取当前的安全等级和设置安全等级。
对于配置层面而言，DSL菜单主要是配置诊断帧，包括物理寻址和功能寻址，单次通信的最大Buffer，以及时间参数，包括回复0x78的时间和为了防止诊断服务异常，允许0x78的最大次数等。
DSD(Diagnostic Service Dispatcher)
DSD模块负责检查诊断请求的有效性（诊断会话、安全访问级别、应用程序权限的验证），并跟踪服务请求执行的进度。
1.检查诊断服务
当DSL接收到新的诊断请求，DSL通过内部接口通知DSD，如图3所示。DSD调用Dcm_GetSesCtrlType()、Dcm_GetSecurityLevel()获取当前的Session和安全等级，DSD模块会在当前Session的“Service Identifier Table”检查诊断请求SID是否在其中，如果不在table中，DSD会发送NRC 0x7F，如果诊断服务支持，但当前Session不支持该子服务，DSD会发送NRC 0x7E；然后检查当前安全等级是否满足条件，如果当前安全等级不支持该诊断请求，DSD会发送NRC 0x33。最后检查数据的长度。
图3 DSL与DSD的交互
2.汇总响应数据
当DSP模块完成诊断请求处理后，DSD负责将整理响应数据。并发送至DSL。
DSD模块将服务标识符(SID)(如果是负反馈，则为0x7F)和响应的数据流添加至“Dcm_MsgContextType”。然后DSD将其传送至缓冲区，并在缓冲区的第一个字节添加SID。
对于配置而言，DSD主要是配置所需要实现的服务，以及服务所支持的session以及服执行的安全等级。
DSP(Diagnostic Service Processing)
DSP用于实现不同服务的处理，当接收到DSD请求处理诊断服务，DSP的处理过程如下：
1、分析接收的请求信息，调用不同的诊断服务实现函数；
2、检查格式以及是否支持所寻址的子功能；
3、获取数据或者调用DEM、SWC或者其他BSW模块的接口。如图4所示。比如0x22和0x2E服务需要调用SWC的数据接口进行读写；0x28需要调用BswM的逻辑实现关闭不同的CAN报文；0x19服务需要调用DEM模块获取快照数据和扩展数据。
4、汇总响应数据。
图4 DSP对外的API
对于配置而言，DSP模块配置项比较杂，比如：
1.DID的实现，包括DcmDspData用于配置DID的数据类型，数据长度，以及接口类型；DcmDspDidInfo用于配置DID的读写功能；DcmDspDids用于汇总DcmDspDidInfo和DcmDspData，并且添加DID value。
2.安全等级的实现，包括种子和秘钥的位数、最大的错误访问次数，以及时间参数。
3.Session的配置，包括Session的等级，Session是否支持跳转至Boot，以及时间参数P2 ServeMax和P2* ServeMax。
总体来讲DCM模块主要是实现UDS和OBD诊断服务的实现，但是DCM跟其他模块的交互比较频繁，需要了解诊断服务的机制需要其他模块配合，比如BswM、DEM、EcuM以及SWC等。
本文转自汽车ECU开发公众号 https://mp.weixin.qq.com/s/PuMEuLxovtSwQJwPbGurQA
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14f82422e1e8a8075d6b9bfd2a9f462f/" rel="bookmark">
			【unity】标准资源包里的第一人称角色控制器FPSController在手机端旋转视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在unity中导入标准资源包，可以拖拽一个FPSController到场景中漫游，十分方便，但是调整方向是靠鼠标滑动的，到了手机端没有鼠标，对于新手的我不知道怎么处理，最后是通过在屏幕上放置四个按钮控制方向
1.修改MouseLook.cs 这个脚本里有一个LookRotation()方法，是用于根据鼠标移动距离控制视图旋转角度的，在它的代码基础上，我们写一个MyLookRotation()方法，通过传入的参数代替鼠标移动
public void MyLookRotation(Transform character, Transform camera,int flag,float angle) { //传入flag和q的值，flag=1是旋转x轴，flag=2旋转y轴,angle为旋转量,正为右、上，负为左、下 float yRot = CrossPlatformInputManager.GetAxis("Mouse X") * XSensitivity; float xRot = CrossPlatformInputManager.GetAxis("Mouse Y") * YSensitivity; if (flag == 1) { yRot = angle; } else { xRot = angle; } m_CharacterTargetRot *= Quaternion.Euler(0f, yRot, 0f); m_CameraTargetRot *= Quaternion.Euler(-xRot, 0f, 0f); if (clampVerticalRotation) m_CameraTargetRot = ClampRotationAroundXAxis(m_CameraTargetRot); if (smooth) { character.localRotation = Quaternion.Slerp(character.localRotation, m_CharacterTargetRot, smoothTime * Time.deltaTime); camera.localRotation = Quaternion.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14f82422e1e8a8075d6b9bfd2a9f462f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f396eacb4cf5791c4cf6f126829632a5/" rel="bookmark">
			OpenCV(Scale Invariant Feature Transform（SIFT))尺度不变特征变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 咋一看这个名字，我也蒙了，这啥玩意？
其实在介绍这个之前，就是如果我们很远看一幅图就大概知道是什么，在不同尺度下，计算机可以提取出一个统一的特征，这就是SIFT
图像尺度空间：
在一定的范围内，无论物体是大还是小，人眼都可以分辨出来，然而计算机要有相同的能力却很难，所以要让机器能够对物体在不同尺度下有一个统一的认知，就需要考虑图像在不同的尺度下都存在的特点。
尺度空间的获取通常使用高斯模糊来实现
不同σ的高斯函数决定了对图像的平滑程度，越大的σ值对应的图像越模糊。
多分辨率金字塔
高斯差分金字塔
DoG空间极值检测
为了寻找尺度空间的极值点，每个像素点要和其图像域（同一尺度空间）和尺度域（相邻的尺度空间）的所有相邻点进行比较，当其大于（或者小于）所有相邻点时，该点就是极值点。如下图所示，中间的检测点要和其所在图像的3×3邻域8个像素点，以及其相邻的上下两层的3×3领域18个像素点，共26个像素点进行比较。
关键点的精确定位
这些候选关键点是DOG空间的局部极值点，而且这些极值点均为离散的点，精确定位极值点的一种方法是，对尺度空间DoG函数进行曲线拟合，计算其极值点，从而实现关键点的精确定位。
消除边界响应
特征点的主方向
每个特征点可以得到三个信息(x,y,σ,θ)，即位置、尺度和方向。具有多个方向的关键点可以被复制成多份，然后将方向值分别赋给复制后的特征点，一个特征点就产生了多个坐标、尺度相等，但是方向不同的特征点。
生成特征描述
在完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。
为了保证特征矢量的旋转不变性，要以特征点为中心，在附近邻域内将坐标轴旋转θ角度，即将坐标轴旋转为特征点的主方向。
旋转之后的主方向为中心取8x8的窗口，求每个像素的梯度幅值和方向，箭头方向代表梯度方向，长度代表梯度幅值，然后利用高斯窗口对其进行加权运算，最后在每个4x4的小块上绘制8个方向的梯度直方图，计算每个梯度方向的累加值，即可形成一个种子点，即每个特征的由4个种子点组成，每个种子点有8个方向的向量信息。
论文中建议对每个关键点使用4x4共16个种子点来描述，这样一个关键点就会产生128维的SIFT特征向量。
opencv SIFT函数
import cv2 import numpy as np img = cv2.imread('test_1.jpg') gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) sift = cv2.xfeatures2d.SIFT_create() kp = sift.detect(gray, None) img = cv2.drawKeypoints(gray, kp, img) cv2.imshow('drawKeypoints', img) cv2.waitKey(0) cv2.destroyAllWindows() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/282ace8816cc025830d7801a7a0ff340/" rel="bookmark">
			在Idea中为项目添加Tomcat配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚开始用Idea非常不习惯，导入一个web项目后，一片红，也没有Build path可以设置。网上搜集了些资料，发现需要配置的东西还有点繁琐，这里进行一下记录，供后续查阅。
1.配置JDK 1）.点击右上角的按钮，调出project structure页面
2）选择Project，进行配置。
2.配置Artifacts 1）在Project Structure页面，点击Artifacts——&gt;选择+号——&gt;选择Web Applications: Exploded——&gt;选择“From Modules”
我的项目生成的Artifact如下
3.配置WebRoot 1）在project Structure页面，选择Modules——&gt;点击+号——&gt;选择最下面的web标签。
2）创建好之后，在右侧的详情里进行相关配置，正确选择web.xml文件的路径及webroot的路径即可。
4.添加jar包 1)在Project Structure页面，选择Libraries ——&gt; +号 ——&gt;Java
2）将项目中的jar包添加到库中，点击apply。
5.配置Tomcat 1）点击“Add Configuration”，调出“Run/Debug Configurations”页签
2）选择+号——&gt;选择Tomcat Server——&gt;选择Local，添加Tomcat
3）配置Tomcat的相关属性。
4) 添加deployment信息
配置完成后我们点击即可启动项目了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cde864b74c899fc3a3d0c1b2d0af7f76/" rel="bookmark">
			vscode latexworkshop:Recipe terminated with error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode latexworkshop:Recipe terminated with error 我踩的坑与解决欢迎加入vscode编写latex的邪教 我踩的坑与解决 文件路径中不能出现中文！！！
否则我们点击左下的粉红叉叉，查看左侧commands中的View LaTeX compiler log ,在编辑区下方的“输出”一栏中可以发现文件路径中文字符被替换为乱码，将对应的文件夹重命名，注意不能出现汉字（但罗马数字可以），重新打开tex文件即可。
欢迎加入vscode编写latex的邪教 继续感受vscode的强大功能吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06bce65ab89025545098d59297d6819a/" rel="bookmark">
			vbs学习，书籍，看书笔记(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vbs书籍百度云下载链接：
链接：https://pan.baidu.com/s/1lTzaOTfwA7hV0nSQqGyiSw
提取码：lkwe
导航 1.inputbox注意点
2.do loop while
3.mid，len函数使用
4.注意代码的模块化(modularization)
5.function如何返回值
6.自顶向下模型和事件驱动模型
7.匈牙利变量命名法和行连续符
8.vbscript说明
9.vbs运行时的优缺点
10.ASP初识
11.数据类型
12.子类型的检查和数据转换
13.关于日期的格式
14.关于is的用法及函数
15.显式隐式转换类型
16.empty 与 null
1.inputbox注意点
如果什么都没有输入点确定，也是有返回的，返回的是空值，与点击取消相同
输入之后点确定，返回对应值到变量里
小例子：
dim name dim info name = inputbox("请输入你的名字：") if name ="" then	'根据你是否输入信息，来制定不同的回复方案 info = "好吧，你不想告诉我你的名字" '存到info变量中 else info = "欢迎您" &amp;name '可以用缩进让代码更清晰 end if msgbox info	'打印输出info中的值 ————————————————————————————————————————
2.do loop while 相关
格式：
do
falg = false
loop while flag = true //flag = true为终止条件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06bce65ab89025545098d59297d6819a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6686b2643e08eb1469fe93357dac6582/" rel="bookmark">
			MySQL实战45讲学习笔记----join原理与优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		join语句执行原理 NLJ，SNL，BNL，BKA算法
创建两个表t1和t2，存储过程idata()往表t2里插入了1000行数据，在表t1里插入的是100行数据。
CREATE TABLE `t2` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`) ) ENGINE=InnoDB; drop procedure idata; delimiter ;; create procedure idata() begin declare i int; set i=1; while(i&lt;=1000)do insert into t2 values(i, i, i); set i=i+1; end while; end;; delimiter ; call idata(); create table t1 like t2; insert into t1 (select * from t2 where id&lt;=100) Index Nested-Loop Join select * from t1 straight_join t2 on (t1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6686b2643e08eb1469fe93357dac6582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b5e90ac808789aa8a2ec950ba175ae/" rel="bookmark">
			我的爬虫之路   ---- GET请求与POST请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、GET请求
HTTP默认的请求方法就是GET
* 没有请求体
* 数据必须在1K之内！
* GET请求数据会暴露在浏览器的地址栏中
GET请求常用的操作：
1. 在浏览器的地址栏中直接给出URL，那么就一定是GET请求
2. 点击页面上的超链接也一定是GET请求
3. 提交表单时，表单默认使用GET请求，但可以设置为POST
2、POST请求
(1)数据不会出现在地址栏中
(2)数据的大小没有上限
(3)有请求体
(4)请求体中如果存在中文，会使用URL编码！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa338bb8b6ffc09d8366fe9879737f1/" rel="bookmark">
			自动驾驶概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着5G逐渐走进人们的视线，自动驾驶汽车成为一个社会热门话题。那么自动驾驶究竟是什么样的？它真的能实现吗？什么时候我们才能真正使用上呢？
汽车是当今社会的主要交通工具之一，自动驾驶汽车是目前可以看到，并能通过技术手段可以实现的汽车现阶段终极目标。
自动驾驶是分阶段实现的，目前处于初级阶段，就是车本身的各种驾驶辅助系统以及自动驾驶的进化和配套系统的建立，重点在于解决如何提高汽车驾驶的安全性和可操控性；其高级阶段将是完全的、无人驾驶的智能汽车，彻底将人从方向盘后解脱出来，而汽车可以像人类一样具备感知、分析、判断能力。智能汽车现阶段也分两个发展方向，一类是汽车个体自动化系统控制，靠自主式的传感器，完全不需要依靠互联网；另外一类是智能网联汽车，也就是汽车自动驾驶技术+车联网。这是新兴的发展模式，是ICT和汽车产业的跨界结合出现的创新技术方向。两个方向都能实现自动驾驶的最终目标，中国大力推崇的是智能网联模式。
一、智能化汽车发展
智能车的概念
智能车（Intelligent Vehicle ,IV）是一个集环境感知、动态决策与规划、智能控制与执行等多功能于一体的综合系统，相关技术涉及信息工程、控制科学与工程、计算机科学、机械工程、数理科学、生命科学等诸多学科，是衡量一个国家科研实力和工业水平的重要标志。
智能化现状
智能驾驶是汽车驾驶系统物化驾驶员在长期驾驶实践中，对“环境感知-决策规划-控制执行”过程的理解、学习和记忆。
环境感知作为第一环节，是智能驾驶的典型应用场景，例如激光雷达与摄像头的车辆检测技术中，需要对数据做聚类处理；线性回归算法、支持向量机算法、人工神经网络算法也常用于车道线和交通标志的检测。它处于智能驾驶车辆与外界环境信息交互的重要地位，其关键在于使智能驾驶车辆更好地模拟人类驾驶员的感知能力，从而理解自身和周边的驾驶态势。
决策规划是智能驾驶的主要应用场景，状态机、决策树、贝叶斯网络等技术已经有大量的应用。近年来兴起的深度学习与强化学习能通过大量的机器学习做出对复杂情况的决策，并能进行在线学习优化。由于需要较多的计算资源，是当前计算机与互联网领域内，研究自动驾驶决策规划系统的热门技术。
控制执行：智能控制方法主要有基于模型的控制、神经网络控制和深度学习等方法。
世界各国都在积极制定自动驾驶技术路线图，推动自动驾驶汽车的发展，如美国在80年代初已经开始自动驾驶技术的军事化应用；欧洲从80年代中期开始研发自动驾驶车辆，更多强调单车自动化、智能化的发展；日本的自动驾驶研发略晚于欧美，更多关注于采用智能安全系统降低事故发生率、以及采用车间通信方式辅助驾驶。
由于深度学习算法的引入，汽车智能化技术有了爆发性的突破，成为汽车产业化发展的重要突破口，2009年谷歌开始研发自动驾驶，引发了新一轮的自动驾驶产业热潮，更多科技企业加入市场争夺中。
与欧美等发达国家相比，我国的自动驾驶研发起步相对较晚，自上个世纪90年代起，我国各高校和研究机构陆续开展自动驾驶的研发工作，推出多个测试车型；2009年以来，国家自然科学基金委员会举办“中国智能和未来挑战赛”，为国内智能车技术和交流起到很好的促进作用，在此期间一汽、北汽等传统车企也逐步布局自动驾驶。
二、网联化现状
网联化是指汽车依靠通信技术，将车本身和其它相关联的因素数据通过网络联系在一起，这个网络就叫车联网。车联网的概念源于物联网，即车辆物联网，是以行驶中的车辆为信息感知对象，借助新一代信息通信技术，实现车与X（即车与车-V2V、人-V2P、路-V2I、服务平台-V2N）之间的全方位网络连接，实现了 “三网融合”，将车内网、车际网和车载移动互联网进行融合。车联网利用传感技术感知车辆的状态信息，并借助无线通信网络与现代智能信息处理技术实现交通的智能化管理，以及交通信息服务的智能决策和车辆的智能化控制。
车联网是一个很宽泛的领域，从车内发展到车外，正在从车内娱乐导航服务向汽车数据中心发展，内涵不断延伸。目前车联网有两个世界标准流派：一个是IEEE基于WIFI制定的DSRC（Dedicated Short Range Communications，专用短程通信技术），获得通用、丰田、雷诺、恩智浦、AutoTalks和Kapsch TrafficCom 等的支持；另一个是由3GPP通过拓展通信LTE标准制定的C-V2X，并向5G演进，获得多家车企和通信企业的支持，如：福特、宝马、奥迪、戴姆勒、本田、现代、日产、沃尔沃、PSA Group、华为、爱立信、高通、英特尔、三星等。C-V2X的成员显然比DSRC要壮观。
两种技术标准各有千秋，国际上对于车联网到底采用哪种标准，尚未达成一致。业界专家存在三种观点：一种是DSRC技术已经成熟，其经过多年的测试与验证，可行性已经得到验证，同时网络、芯片等产业链相对成熟，没有理由放弃；另外也有观点认为，LTE-V2X技术具备技术优势，其安全性和可靠性都更胜一筹，更有前景；此外还有观点表示，汽车与手机不同，是有本国属性但一般不会大量跨国行驶，因此，不同国家可以使用不同技术。中国有通信网络覆盖广和用户量庞大的优势，一直以来都是LTE-V2X的积极倡导者。
汽车发展经历了机械化和电气化升级，目前又到了一个上台阶的关头。网联时代汽车产品需要创新的重点转向数字化技术，如云平台、人工智能、机器学习等。目前，最基本的车载内嵌网联设备装车率2017年还普遍低于20%，尽管众多厂家的2025年远期规划都近乎100%标配，但当下发展依然缓慢，真正起飞要至少等到2020年。
三、智能网联化
智能化和网联化相结合成为未来自动驾驶汽车产业发展的重要方向，在智能网联汽车的技术演进过程中，智能化及网联化两者的发展相互促进，不可分割，从而实现完全自动驾驶的最高目标。
受制于技术和网络覆盖，车联网的价值还远没有被挖掘出来，大多还停留在娱乐和导航的单车、单用户服务，但车联网作为汽车互联网络，尤其是在5G移动网络普及后，可以将衣食住行都连接起来，汽车的内涵由此也在发生改变。5G通信网络的高速、低时延数据传输、高容量、低失真、低误码都为这种模式提供了技术可能。所以，智能化和网联化的结合，可以为汽车智能化系统提供更多、更详细、更准确的数据，以供机器学习，促进智能系统演义进化。
网联汽车会采集、产生大量实时数据，如行驶过程中“（汽）车、（道）路、（数据）云、（路）网、(地) 图五大基本要素交互的数据。诸如汽车和驾驶人信息，汽车信息包括：汽车位置和周边环境信息，以及汽车诊断信息、保养信息、安全信息（门窗开闭，安全气囊使用）、性能信息（发动机和变速箱状态，电池电量）、行驶信息（燃油消耗量，速度，刹车加速，方向盘）；驾驶人信息（包括地理位置、用户模式、驾驶历史）等。一辆汽车一天大概产生500GB左右数据，数据主要由汽车制造商安装车载内嵌SIM卡来收集，这就是学习素材的来源。自动驾驶技术其核心决策者是人工智能（AI）系统，就需要大量数据进行训练，现在开展自动驾驶技术的公司可以获得的数据仍然是少量的，有些是在使用模拟数据训练人工智能，大量实际使用数据是自动驾驶技术发展不可或缺的一部分。因此自动驾驶的智能汽车不是一蹴而就的，它的进化发展是靠不断的技术产品迭代，循序渐进实现目标，一个完善的车联网，是促进实现自动驾驶的前置条件之一。
四、我国智能网联汽车政策及标准概况
时间
发布机构
政策、标准
主要内容
2011年
国务院
《中华人民共和国居民经济和社会发展第十二个五年规划》
国家把车联网列入重大专项
2011年
国务院
《国家“十二五”科学和技术规划》
车联网项目被列为国家重大专项（第三专项）中的重要项目，首期投入资金打百亿
2012年
交通部
《2012-2020交通运输业智能智能交通发展战略》
标志着智能交通上升到国家战略，交通部启动的新一代智能交通体系发展战略和应用车联网技术推进现代交通运输策略重大研究项目，为未来5-10年的发展进行谋划
2013 年
国务院
《国务院关于推进物联网有序健康发展的指导意见》
将车联网作为物联网的核心应用领域
2015年
国务院
《中国制造2025》
提出到2020年，掌握智能辅助驾驶总体技术及各项关键技术，初步建立智能网联汽车自主研发体系及生产配套体系
2015年
国务院
《关于积极推进“互联网+”行动的指导意见》
提出通过基础设施、运输工具、运行信息等互联网化，推进基于互联网平台的便捷化交通运输服务发展
2015年
工信部
《车联网发展创新行动计划（2015-2020年）》
推动车联网技术研发和标准制定，组织发展车联网试点、基于5G技术的车联网示范
2016年
工信部
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baa338bb8b6ffc09d8366fe9879737f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/175173e68ba89e4bbe9d763e9572562c/" rel="bookmark">
			Cube Stacking —— 带权并查集（终于搞懂了）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #define N 30010 #define M 30000 using namespace std; // 我们让根节点为每个堆中最下方的点，f[x]也为与x相连的下方的点 int f[N]; int height[N]; // 每个节点下方的节点个数 int size[N]; // 这个节点所在堆的节点数（只有根节点的size有效） int find(int x) { if(f[x] != x) { int t = f[x]; f[x] = find(t); // 路径压缩 height[x] += height[t]; // 如图解释一下 } return f[x]; } void move(int a, int b) { int fa = find(a), fb = find(b); if(fa != fb) { f[fa] = fb; height[fa] = size[fb]; size[fb] += size[fa]; } } int main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= M; i ++) { f[i] = i; height[i] = 0; size[i] = 1; } while(n --) { char ch[2]; int a, b; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/175173e68ba89e4bbe9d763e9572562c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92b6403597183bb34ca1deeb6959c04b/" rel="bookmark">
			主流卷积神经网络结构探索和分析（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主流卷积神经网络结构探索和分析（一） 0. 引言1. 主流卷积网络概览1.1 VGG1.2 GoogLeNet1.3 ResNet1.4 WideResNet1.5 ResNeXt1.6 总结和思考（待完善） 0. 引言 去年7月因为各种原因辞职后终于如愿进入高校做博后，完成多年的心愿。9月份正式入职，老师的20篇 论文的要求真是让我完全懵圈的状态。无论如何，硬着头皮上吧。于是，熬到现在第四篇了。也借此机会把主流的卷积网络的结构梳理梳理。借着新型冠装病毒疫情这个封闭在家的时间，静心思考，也把自己思考的内容与大家分享一下，抛砖引玉。
1. 主流卷积网络概览 目前参考了文章《CIFAR10 to Compare Visual Recognition Performance between Deep Neural》，感兴趣的小伙伴可以自行搜索谷歌学术。文章中将主流的CNN网络结构分为了五类：VGG，GoogLeNet, ResNet,WideResNet, ResNeXt. 本文对这几个网络进行的结构和特点进行详细的分析和讨论。
1.1 VGG GGNet是牛津大学计算机视觉组（Visual Geometry Group）和Google DeepMind公司的研究员一起研发的深度卷积神经网络。通过反复堆叠3X3的小型卷积核和2X2的最大池化层，通过不断加深网络结构来提升性能。每次池化后刚好缩小一半，信道数目不断增加一倍。
1.2 GoogLeNet GoogLeNet的主要思想是对网络进行抽取和分解。从V1到V4经历了四个版本的改进。思路上来说，主要是用较小的卷积核替代较大的卷积核。比如从V1到V2的核心思想可以认为是：用2个3x3的卷积核替代了5x5的卷积核；V2到V3，主要是引入了非对称卷积核的方法，将nxn的卷积核改进为：一个nx1和一个1xn的组合，但是作者在实验的过程中发现，该方法在高分辨率的低层特征中使用的效果不好，因此将非对称卷积放在了网络的中部。V3到V4的进步主要是引入了残差网络。
GoogleNet的作者还有对网络的其他改进，比如目标函数，用avgpooling层替代FC,用BN层替代droopout等改进。在此不一一赘述。相关内容可参考博客：Inception in CNN
1.3 ResNet ResNet是在2015年有何凯明，张翔宇，任少卿，孙剑共同提出的。ReNet的数学表达很简单，就是在网络之间增加跨层的连接。即在某一层之间实现如下的连接关系。其网络结构示意图如下图所示。
Y o u t l = f ( X o u t l ) + X o u t l t Y_{out}^{l}=f(X_{out}^{l})+X_{out}^{l_{t}} Youtl​=f(Xoutl​)+Xoutlt​​
1.4 WideResNet 前面讨论的几个网络的思路主要是在网络的深度和广度方面做探索。而ResNet这类网络也会存在由于梯度在反向传播的时候，可以直接经过shortcut，而不用被强制经过residual block，这会导致可能只有很有限的layer学到了有用的知识，而更多的layers对最终结果只做出了很少的贡献。这个问题也被作者称之为diminishing feature reuse。WideResNet和ResNeXt都是对residual block的改进。WideResNet主要是在卷积层之间加入了随机失活的droop out层。其网络结构示意图如下图所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92b6403597183bb34ca1deeb6959c04b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fbc4d91c248f63f1d725f6cc10e0a8e/" rel="bookmark">
			Python Matplotlib画图基础介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Matplotlib第一个简单的图形坐标轴控制，标题打上文字标注，公式一个图中画多张子图大小不一的多张子图散点图柱状图plt.rcParams参数设置详细颜色字母对照表参考资料 Matplotlib 是 Python 中最常用的一个绘图库，主要用于绘制各种图形，包括散点图、柱状图、3D图、等高线图等等。在做研究过程中肯定会经常用，本文做一个简单的入门介绍，也给出极佳的参考手册，以备查用。内容主要参考了[1]的内容，我自己用jupyter notebook实现了一遍，我会给出所有源码的文件。
重点推荐：https://matplotlib.org/gallery.html
该网页中收录了大量Matplotlib图形实例源码，基本上按需找到适当修改一下就行了，很棒！
除了Matplotlib之外再推荐一个高级统计画图工具：seaborn: statistical data visualization
Matplotlib第一个简单的图形 %matplotlib inline import numpy as np import matplotlib.pyplot as plt plt.figure(0) X = np.random.normal(size=(12, 2)) #plt.scatter(X[:, 0], X[:, 1]) plt.plot(X[:,0],X[:,1],'mo') #m表示紫色，o表示小圆点，更多颜色见文末 plt.show() 坐标轴控制，标题 # create a new figure plt.figure(1) x = np.linspace(0, 2 * np.pi, 50) y = np.sin(x) plt.plot(x, y,label="sin(x)") plt.plot(x, y * 2,label="2sin(x)") plt.title("sin(x) &amp; 2sin(x)") # 图像上方的标题 plt.xlim((0, np.pi*2)) # 横坐标的数值范围 plt.ylim((-3, 3)) # 纵坐标的数值范围 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fbc4d91c248f63f1d725f6cc10e0a8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e09f818e0108904478aea010b007d59c/" rel="bookmark">
			使用sapi.spvoice，进行朗读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 set s = createobject("sapi.spvoice") '创建对象 i = 0 s.speak i s.pause() '暂停 s.resume()'继续 s.speak i 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0df479e8cbb676898a9c16f3e88f1af3/" rel="bookmark">
			集合运算之美
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法训练 集合运算 时间限制：1.0s 内存限制：512.0MB
锦囊1
排序后处理。
问题描述
给出两个整数集合A、B，求出他们的交集、并集以及B在A中的余集。
输入格式
第一行为一个整数n，表示集合A中的元素个数。
第二行有n个互不相同的用空格隔开的整数，表示集合A中的元素。
第三行为一个整数m，表示集合B中的元素个数。
第四行有m个互不相同的用空格隔开的整数，表示集合B中的元素。
集合中的所有元素均为int范围内的整数，n、m&lt;=1000。
输出格式
第一行按从小到大的顺序输出A、B交集中的所有元素。
第二行按从小到大的顺序输出A、B并集中的所有元素。
第三行按从小到大的顺序输出B在A中的余集中的所有元素。
样例输入
5
1 2 3 4 5
5
2 4 6 8 10
样例输出
2 4
1 2 3 4 5 6 8 10
1 3 5
样例输入
4
1 2 3 4
3
5 6 7
样例输出
1 2 3 4 5 6 7
1 2 3 4
#include &lt;iostream&gt; #include &lt;set&gt; using namespace std; set&lt;int&gt; sa,sb,sc; int main(int argc, char** argv) { int n,m; cin&gt;&gt;n; int num; for(int i=0;i&lt;n;i++){ cin&gt;&gt;num; sa.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0df479e8cbb676898a9c16f3e88f1af3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa502d66059dba225f375e9d7805b88/" rel="bookmark">
			vbs 实际操作 调用外部程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**vbs调用外部程序** WSH也就是用来解析Vbs的宿主，本身包含了几个个常用对象：
1、Scripting.FileSystemObject —&gt; 提供一整套文件系统操作函数 2、Scripting.Dictionary —&gt; 用来返回存放键值对的字典对象 3、Wscript.Shell —&gt; 提供一套读取系统信息的函数，如读写注册表、查找指定文件的路径、读取DOS环境变量，读取链接中的设置 4、Wscript.NetWork —&gt; 提供网络连接和远程打印机管理的函数。（其中，所有Scripting对象都存放在SCRRUN.DLL文件中，所有的Wscript对象都存放在WSHOM.ocx文件中。） ———————————————————————————————————
(打开对应应用如记事本，计算器，文件名或者路径) option Explicit '规范定义告诉计算机先声明后使用 dim obj '变量名 Set obj = CreateObject("Wscript.Shell") 'set将一个对象引用赋给变量 '加true只打开对应的程序，关闭过后才打开下一个 '不加true，两个同时打开 obj.Run "notepad",,true 'notepad 记事本 calc 计算器 winword word文件名 obj.Run """路径名""" '也可以包含路径名，用三个双引号来包含 注意：
run 执行程序的路径，窗口的形式，脚本等待还是继续执行 (三个参数)
run也有返回值，1成功执行，0执行失败
———————————————————————————————————
处理错误
On Error Resume Next ——如果有错误跳过执行下一条语句
err 对象
on error resume next '如果有错误跳过执行吓一跳 a=11 b=0 c=a/b if err.number&lt;&gt;0 then 'err.num 错误的个数 'description 原因 source来源 wscript.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fa502d66059dba225f375e9d7805b88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebb448c3054aa045e3814ef7f1fad833/" rel="bookmark">
			使用pyecharts1.5进行数据分析可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pyecharts 1.5进行数据可视化 安装 pip install pyecharts 直接使用该命令安装的版本为最新版本为1.5。语法与之前版本大不一样，因此本文仅针对1.5及之后版本说明。若想使用之前版本请使用命令pip install pyecharts == 0.1.5.19
注：建议在jupyter notebook中coding，方便debug。
开始使用 基本套路就是先创建一个你需要的空图层，然后使用.set_global_opts修改全局项再用.set_series_opts修改具体的相关配置就可以。当然最好的学习地址一定是官方文档，但是里面介绍的太过复杂了，这里仅以快速上手使用为目标进行几个例子来说明套路。
地图 pyecharts比较好的就是绘制地图，这里以2019-nCov项目中安徽省地图绘制为例。
首先导入需要的包
from pyecharts.charts import Pie ,Grid,Bar,Line from pyecharts.faker import Faker #数据包 from pyecharts.charts import Map,Geo from pyecharts import options as opts from pyecharts.globals import ThemeType OK，我现在有一个省份的一组数据，大概长这样
locate =['合肥市', '阜阳市', '亳州市', '安庆市', '马鞍山市', '铜陵市', '六安市', '滁州市', '池州市','蚌埠市','芜湖市','宿州市','宣城市','淮北市','淮南市','黄山市']` data =['115','105','72','66','30','22','41','11','11','88','27','27','5','22','14','9'] 这也是接触到的需要绘制地图的数据格式，两个list，一个是地名，一个是每个城市对应的数据，现在执行以下代码就可以得到安徽省的疫情地图。
list1 = [[locate[i],data[i]] for i in range(len(locate))] #首先创建数据 map_1 = Map(init_opts=opts.InitOpts(width="400px", height="460px")) #创建地图，其中括号内可以调整大小，也可以修改主题颜色。 map_1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebb448c3054aa045e3814ef7f1fad833/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50b1e969878a63825dcd699933084eb7/" rel="bookmark">
			电子设计教程10：电荷泵倍压输出电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电荷泵设计非常巧妙，只需要几个简单的器件，就能实现倍压或者负压。电荷泵，也称为开关电容式电压变换器，它通过电容对电荷的积累效应而产生高压，使电流逆势由低电势流向高电势。
其中Vcc是固定的，Vin是高低变化的参考电压。当Vin为低电平时（为了简便起见，认为低电平就是0V，实际上可以不是0V），T1测试点的电压VT1是Vcc（为了简便起见，忽略二极管的压降）; 当Vin为高电平Vh时，由于电容两端电压不会突变，所以对于电容C1来说，左右两端的电压差仍是Vcc，左侧变为Vh以后，右侧VT1就变为了Vcc+Vh。VT1通过D2为C2进行充电，输出电压Vo从C2上取出，所以Vo的值将会介于Vcc与Vcc+Vh之间，并且受Vin频率与有效值影响。
形象地来说，可以把这个传递电荷的电容C1看成是“装了电子的水桶"。从一个大水箱Vcc把这个桶接满，关闭水龙头（D1使电流单向流动），然后水桶抬起来（Vin从低电平变为高电平，T1电压被抬升），倒进另一个水桶C2（T1到C2由于D2的存在，也是单向流动）。由于C2的电压是高于Vcc的，所以C1的存在相当于"泵rdquo"，把电荷从低电势搬运到高电势，所以这个电路可以形象地称为电荷泵。
电荷泵的倍压电路可以进行多级串联。设每个肖特基二极管的正向电压为Vf，那么N倍的输出电压可以表示为：
图 多级电荷泵串联的升压电路
下图是电荷泵倍压输出电路中，C1电压与输出电压波形对比
需要注意，电荷泵电路的带负载能力较差，只能用于需要很小电流的场合。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25900098111028383a263f284ce92433/" rel="bookmark">
			详解24个经典股票技术指标.doc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详解24个经典股票技术指标
目 录
一、平滑异同平均线指标——MACD........................................................ 3
第一节 MACD指标的原理和计算方法................................................... 3
第二节 MACD指标的一般研判标准....................................................... 5
第三节 MACD的特殊分析方法................................................................ 7
第四节 MACD指标的实战技巧................................................................ 8
二、 随机指标——KDJ............................................................................... 13
第一节 KDJ指标的原理和计算方法................................................... 13
第二节 KDJ指标的一般研判标准....................................................... 15
第三节 KDJ的特殊分析方法................................................................ 19
第四节 KDJ指标的实战技巧................................................................ 25
第一节 W%R指标的原理和计算方法................................................... 27
第二节 W%R指标的一般研判标准....................................................... 29
第三节 W%R指标的特殊分析方法....................................................... 30
第四节 W%R指标的实战技巧................................................................ 35
第一节 RSI指标的原理和计算方法................................................... 37
第二节 RSI的一般研判标准................................................................ 38
第三节 RSI的特殊分析方法................................................................ 40
第四节 RSI指标的实战技巧................................................................ 41
第一节 CR指标的原理和计算方法..................................................... 44
第二节 CR指标的一般研判标准......................................................... 45
第三节 CR指标的特殊分析方法......................................................... 47
第四节 CR指标的实战技巧.................................................................. 48
第一节 SAR指标的原理和计算方法.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25900098111028383a263f284ce92433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b71be03a53dedbfa1fb8cc4d5007e5c/" rel="bookmark">
			C&#43;&#43; 多人聊天室
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UDP 服务端代码：
// Test_Console.cpp : 定义控制台应用程序的入口点。 // #include "stdafx.h" #include &lt;iostream&gt; #include &lt;WinSock2.h&gt; #include &lt;WS2tcpip.h&gt; #include &lt;Windows.h&gt; #include &lt;thread&gt; #include &lt;cstdio&gt; using namespace std; #pragma region 全局变量 SOCKET server;	// 服务端套接字 sockaddr_in sai_server;	// 服务端信息(ip、端口) // 消息格式 struct umsg { int type;	// 协议(1：加入 2：退出 3：发消息) char name[64];	// 用户名字 char text[512];	// 文本信息 }; // 客户端链表 typedef struct ucnode { sockaddr_in addr;	// 客户端的地址和端口号 umsg msg;	// 客户端传来的消息 ucnode* next; } *ucnode_t; #pragma endregion #pragma region 依赖函数 // 链表插入数据 ucnode* insertNode(ucnode* head, sockaddr_in addr,umsg msg) { ucnode* newNode = new ucnode(); newNode-&gt;addr = addr; newNode-&gt;msg = msg; ucnode* p = head; if (p == nullptr) { head = newNode; } else { while (p-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b71be03a53dedbfa1fb8cc4d5007e5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5728f2b85b7801c0f095fa2acdbc13f/" rel="bookmark">
			ENVI波段合成（Layer Stacking）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 ENVI波段合成（Layer Stacking） ENVI波段合成（Layer Stacking） 第一步，打开图像。
第二步，在toolbox中打开Layer Stacking
第三步，
点击Import File
第四步，
在左侧找到需要合成的图片，点击左侧图片名称，使其出现在后侧。一次添加一个图片点击OK，需要下一幅图，重复操作。
第五步
点击Reorder Files依据波段对图片进行排序，点击OK。
第六步
选择合适位置保存，点击左下角OK.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ca7b3b343ff3964aa381d02ef00807/" rel="bookmark">
			eclipse的MyBatis入门---初始化总是出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个原因可能是你把映射文件写在了包里面，在eclipse里，包内的xml文件是无法被解析的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63299863900304ed88e1cbfef60b635f/" rel="bookmark">
			一元二次方程全解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有一方程ax^2+bx+c=0,a,b,c的值由键盘输入,请编程序,打印出以下情况时方程的解。
(1) a=0,b≠0时， 解为-c/b
(2) a=0,b=0,c=0, 解为任意值
(3) a=0,b=0,c≠0， 无解
(4) a≠0,b^2-4ac≥0， 有两个实根
(5) a≠0,b^2-4ac≤0， 有两个虚根
代码
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { float a,b,c,s; float x1,x2,j,k; scanf("%f %f %f",&amp;a,&amp;b,&amp;c); s=b*b-4*a*c; if(a!=0) { if(s&gt;=0) { x1=(-b-sqrt(s))/(2*a); x2=(-b+sqrt(s))/(2*a); printf("x1=%.2f x2=%.2f\n",x1,x2); } else { j=-b/(2*a); k=sqrt(-s)/(2*a); printf("x1=%.2f+%.2fi x2=%.2f-%.2fi\n",j,k,j,k); } } else { if(b!=0) { printf("x1=x2=%.2f\n",-c/b); } else { if(c==0) printf("该方程的解为任意解\n"); else printf("该方程无解\n"); } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4343ca42edde0be57deb77e78d886562/" rel="bookmark">
			LTE入网流程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://wenku.baidu.com/view/63c9ee59b9f3f90f77c61b50.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/187de3bca572f170e70bc85497651ae0/" rel="bookmark">
			如何绘制深度学习-目标检测评估指标P-R（precision-recall）曲线？如何计算AP（average-precision）？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：深度学习-目标检测评估指标P-R曲线、AP、mAP
文章目录 P-R曲线：AP计算： 下面通过具体例子说明。
首先用训练好的模型得到所有测试样本的confidence score，每一类（如car）的confidence score保存到一个文件中（如comp1_cls_test_car.txt）。假设共有20个测试样本，每个的id，confidence score和ground truth label如下：​​
ground truth label通过预测的bbox与ground truth的iou确定为正样本或负样本。
接下来对confidence score排序，得到：
P-R曲线： 我们得到top-5的结果，前score最高的前5个样本，预测label为1，即：
此例中采用top-5评估，也可采用其他评估，如AP50，即当预测框与真实框的IoU值大于这个阈值时，该预测框才被认定为真阳性（True Positive, TP），反之就是假阳性（False Positive，FP）。
在这个例子中，true positives就是指第4和第2张图片，false positives就是指第13，19，6张图片。是相对于方框内的元素而言，在这个例子中，confidence score排在top-5之外的元素为false negatives和true negatives，即：
其中，false negatives是指第9，16，7，20张图片，true negatives是指第1,18,5,15,10,17,12,14,8,11,3张图片。
那么，这个例子中Precision=2/5=40%，意思是对于car这一类别，我们选定了5个样本，其中正确的有2个，即准确率为40%；Recall=2/6=30%，意思是在所有测试样本中，共有6个car，但是因为我们只召回了2个，所以召回率为30%。此时为下图中第5个样本点。同理图中第一个样本点：P=1，R=1/6，第二个样本点，考虑前两个样本，P=1，R=2/6=1/3。。。
这个例子的precision-recall曲线如下：
实际多类别分类任务中，我们通常不满足只通过top-5来衡量一个模型的好坏，而是需要知道从top-1到top-N（N是所有测试样本个数，本文中为20）对应的precision和recall。显然随着我们选定的样本越来也多，recall一定会越来越高，而precision整体上会呈下降趋势。把recall当成横坐标，precision当成纵坐标，即可得到常用的precision-recall曲线。
AP计算： 接下来说说AP的计算，此处参考的是PASCAL VOC CHALLENGE的2010年之前计算方法。首先设定一组阈值，[0, 0.1, 0.2, …, 1]。然后对于recall大于每一个阈值（比如recall&gt;0.3），我们都会得到一个对应的最大precision。这样，我们就计算出了11个precision。AP即为这11个precision的平均值。这种方法英文叫做11-point interpolated average precision。​
当然PASCAL VOC CHALLENGE自2010年后就换了另一种计算方法。新的计算方法假设这N个样本中有M个正例，那么我们会得到M个recall值（1/M, 2/M, …, M/M）,对于每个recall值r，我们可以计算出对应（r’ &gt;= r）的最大precision，然后对这M个precision值取平均即得到最后的AP值。计算方法如下：​
相应的Precision-Recall曲线（这条曲线是单调递减的）如下：​
AP衡量的是学出来的模型在每个类别上的好坏，mAP衡量的是学出的模型在所有类别上的好坏，得到AP后mAP的计算就变得很简单了，就是取所有AP的平均值。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/380/">«</a>
	<span class="pagination__item pagination__item--current">381/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/382/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>