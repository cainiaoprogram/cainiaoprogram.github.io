<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="菜鸟程序员博客">
		<meta property="og:title" content="菜鸟程序员博客" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b8389da46857d4bd9c52f5c3f737192/" rel="bookmark">
			在Linux服务器上，命令行下运行Matlab的.m文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、采用shell工具例如xshell连接服务器，键入 matlab ，或者含有matlab的相关命令，按照提示要求安装Xmanager工具，只需官网下载，按说明安装。
2、直接运行Matlab：$matlab，然后可以打开matlab工具，根据xmanager工具可以在本地打开matlab的界面，实现本地直接编写matlab代码并运行。
3、运行m文件
如果m文件名为matlabfile.m
(1)方法一
进入m文件所在目录后，运行
$ matlab -nodesktop -nosplash -rmatlabfile
只用文件名matlabfile，不能添加.m
(2)修改.bashrc文件
$ vim ~/.bashrc
添加如下：
#Add an “mrun” alias for running matlab in the terminal.
alias mrun=“matlab -nodesktop -nosplash -logfile date +%Y_%m_%d-%H_%M_%S.log -r”
保存后，进入.m文件所在目录，运行
$mrun matlabfile
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50364f42ed650ada5c7f5b98f6357dd/" rel="bookmark">
			vue中axios封装及自动设置域名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在越来越多的 Vue.js 项目里使用 axios，而不在使用 vue-resource，在使用 axios 都会进行一次封装，接口集中管理，还有各个环境域名自动匹配设置
1、安装axios： npm install --save axios
2、在 main.js 引用 axios 因为我进行了一次封装，所以可能和大家引用的方式不一样，我是在src文件里创建了一个 fetch 文件夹，在 fetch 文件夹里又分别创建了 initFetch.js（接口一些参数配置和请求）和 urlConfig.js （存放的是各个环境域名的设置），如图：
urlConfig.js 里这样写，根据自己项目需求
const config = { 'localhost': { baseUrl: '本地接口' }, '开发环境域名': { baseUrl: '开发环境接口域名' }, '测试环境域名': { baseUrl: '测试环境接口域名' } } const configParams = config[location.hostname] if (configParams) { window.baseUrl = configParams.baseUrl } export default configParams initFetch.js 里这样写，根据自己项目需求
import axios from 'axios' const CancelToken = axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b50364f42ed650ada5c7f5b98f6357dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aca8938f68a4b38cbb2c7f298efb07f/" rel="bookmark">
			numpy学习之—— np数据存储和加载（内存映射）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import numpy as np a = np.array([1,2,3]) b = np.array([1,2,3,4]) np.savez("save.npz", a, b) print("save ok ....") 保存多个numpy数组到一个文件
import numpy as np r = np.load("save.npz") a = r['arr_0'] print (a) b = r['arr_1'] print(b) 加载上述代码保存的文件，分别获取2个数组的值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c23b973000e7c262842711d8021c741/" rel="bookmark">
			文本分类任务中tf-idf的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		维基百科给的定义式：tf-idf是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。tf-idf加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。除了tf-idf以外，互联网上的搜索引擎还会使用基于链接分析的评级方法，以确定文件在搜索结果中出现的顺序。
也即：
tf = 一个词在某个文件中的出现次数 / 该文件中所有词出现的次数总和
idf = log 文档总数 / （包含这个词的所有文档数之和 + 1）
idf表示一个词能将当前文件和其他文件区分开的能力，越大越好。
tf表示某个词出现在这段文本的频率，越大越好。
缺陷:
没有考虑顺序。
容易选出一些出现频率少，恰巧出现在这个句子中的idf比较高，不具有代表性。
没有考虑到类内和雷剑的分布情况，只能区分词在句子层面的表征水平。
和词袋模型联合，先用词袋模型选出高热度词汇，然后用tfidf计算权值，这样值越高表示该词区分每条语句的效果越好。
而在文本分类中，我们把每个类解释为一个文件，重新定义tf,idf。
tf = 一个词在某个分类的所有样本中出现的次数 / 这个分类中所有样本中包含的所有词出现的次数总和
idf = log 所有类包含的样本总数 / 包含这个词的所有类的所有样本数之和
举个例子，假设我们有两类a, b。 a中包含2个样本，词数分别为[10, 20]，b中包含3个样本，词数分别为[30,40]。词word在a中2个样本中的出现次数为[2,5]，在b中3个样本中出现次数为[3,0,0]。求词word对a类的重要程度tfidf。
tf = ( 2 + 5) / (10 + 20)
idf = log (2 + 3) / (( 2 + 1) + 1)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc0f53eaa1a96a8a273095d3aab6dbd3/" rel="bookmark">
			编译内核出现：cc1: error: code model kernel does not support PIC mode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a261a61c34e8da3cda7eeeb3a875b71/" rel="bookmark">
			LTE学习笔记 ——GTP-U
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. GTP是什么 GTP：GPRS Tunnel Protocol，GPRS隧道传输协议。
GTP是一组基于IP的高层协议，位于TCP/IP，UDP/IP协议之上。
GTP-U是其中一种GTP。
2. GTP-U GTP-U用来传输S1和X2用户面数据。
GTP-U既可以基于IPv4/UDP，也可以基于IPv6/UDP。
隧道端点之间的数据通过IP地址和UDP端口号进行路由。
3. TEID Tunnel endpoint ID，隧道端点标识符。
由接收端生成，供发送端使用，通过s1/x2信令交换。
s1接口：数据上传TEID由S-GW分配，数据下传TEID由eNodeB分配。SAE建立和响应，初始上下文建立和响应。X2接口：由目标eNodeB分配。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52965a775b110228e41dc8be4da7527a/" rel="bookmark">
			聊聊关于使用逻辑斯蒂回归的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 逻辑斯蒂回归是个什么东西？ 逻辑蒂斯函数
按数学的思维解读就是求逻辑函数的反函数。
以下是逻辑斯蒂的函数
百度百科上对这个函数的解释是：
逻辑斯谛模型是关于人口或种群增长的模型。它发现人口/种群增长会因为受到资源限制而达到某个极限。
这个在我们高中的生物中有讲到，起初，物种少，数量增长的缓慢，随着时间的推移数量增多，增长速度变快，剧增到一定的时候，趋于稳定。里面有个K值的概念。到达K值后，物种数量趋于平稳，在K/2的时候，物种增长最快。
而逻辑斯蒂回归以这个函数为根据，估计概率的方式测量自变量和多个因变量之间的关系，再把这个连续的曲线转换为0到1之间的值。
即下图：
逻辑斯蒂回归使用场景 通过逻
辑斯蒂回归，我们常用于去预测某种结果的概率。
例如：
某品牌商店的 客户的流失概率。统计客户在商店停留的时间，服务人员与客户联系的次数，以及客户在商店消费的金额。在取平均值后，得出一个客户流失的概率值。相应的，我们可以得出，在平联系次数减少一次或增加一次时，客户的流失概率。根据结果，分析出一个减少客户流失的试行方案。
同样的我们可以用在跨境电商领域。 我们在选择一款产品销售去国外的某些国家时，由于地区文化不同，对产品的喜好度不同，一开始可能由于新产品，国外人士对该产品的质量，作用不太了解。销售量很低，国外仓库囤货很多，随着曝光度的增加，相应的销售量同步增加，需加大生产量，但受众人群基数可能没那么大，到后面销售量趋于平稳。 我们可以利用逻辑蒂斯回归，预测销售量，制定生产产品计划，减少资源占用。
代码的实现我是参考以下链接： https://blog.csdn.net/xlinsist/article/details/51289825 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfc76338694c3055c9ccbca97d61b2af/" rel="bookmark">
			60. 第k个排列(python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。
按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：
"123""132""213""231""312""321" 给定 n 和 k，返回第 k 个排列。
说明：
给定 n 的范围是 [1, 9]。给定 k 的范围是[1, n!]。 示例 1:
输入: n = 3, k = 3 输出: "213" 示例 2:
输入: n = 4, k = 9 输出: "2314" 思路分析 通过观察，我们可以看到 n 个数字共有 n ! 个排练组合：排列的第一个字符从 n 个中选择1个，第二个字符从剩下的n-1个里面选择1个……所以，当所有组合字符串按顺序排列后，以“ 1 ”开头的有（n-1）！个组合，以" 1 “或者 2 ”开头的有 （n-1）!+(n-1)! = 2*(n-1) ! 个组合，……
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfc76338694c3055c9ccbca97d61b2af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8b8cc641800ffaa0e9a5753346ed6f/" rel="bookmark">
			Android自定义示波器如何绘制高采样率图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android自定义示波器如何绘制高采样率图片 Android中自定义示波器通过展示高采样率的数据（数据来源串口）
前言 特以此博客记录高采样率波形绘制中遇到的坑，首先Android帧率以及刷新率相关的概念可以自行百度，博主遇到的情况是串口采样率255的情况下，在使用串口数据会出现波形图绘制卡顿，有严重延时，开始一直怀疑是示波器的问题换了N种实现方式还是卡顿，直到最后才找到原因，是串口数据读取的性能瓶颈，读取串口缓冲区数据频率过快会造成比较严重的数据延时
自定义的示波器 /** *该示波器满足的需求为X轴向绘制1000点 *Y轴向绘制1500点 *同时绘制五路波形数据 *具体绘制点数可以根据自己需求配置TOTLE_X 与TOTLE_Y轴字段 */ public class LineChartSurfaceFourView extends SurfaceView implements SurfaceHolder.Callback { private static final String TAG = "LineChartSurfaceView"; private static final float TOTLE_X = 1000;//X轴描点数 private static final float TOTLE_Y = 1500;//Y轴描点数 private float totalWidth = 800;//默认宽度 private float totalHeight = 190;//默认高度 private float xValue = totalWidth / TOTLE_X;//X缩放比 private float yValue;//Y缩放比 private float density = getResources().getDisplayMetrics().density;//屏幕分辨率 private int mSpaceHeight = 10;//间隔线高度 private int oneHeight;//单个示波器高度 private boolean isCreate = false;//view是否创建 private static DataFilter dataFilter1 = new DataFilter();//滤波器，不需要滤波器可以直接去掉 private static DataFilter dataFilter2 = new DataFilter();//滤波器 private static DataFilter dataFilter3 = new DataFilter();//滤波器 private static DataFilter dataFilter4 = new DataFilter();//滤波器 private static DataFilter dataFilter5 = new DataFilter();//滤波器 /** * 曲线画笔 */ private Paint linePaint; /** * 矩形画笔 */ private Paint rectPaint; /** * 路径数据 */ private List&lt;PointF&gt; line1Data = Collections.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb8b8cc641800ffaa0e9a5753346ed6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc9f58813d3981f7a013ac57d4928b8d/" rel="bookmark">
			LTE学习笔记 —— 测量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 测量的目的 2. 测量的分类 3. 小区重选测量准则4. 小区切换测量5. 测量报告上报事件 1. 测量的目的 用于小区重选、切换判决、重定向等。
2. 测量的分类 根据测量的性质：同频测量、异频测量、异系统测量
根据物理量不同：电平大小、信号质量、负荷大小
根据测量报告的方式：周期性测量、事件性测量
对于UE侧而言：RRC_IDEL态测量、RRC_CONNECTED态测量
RRC_IDEL态测量用于小区重选，其测量配置在sib3、sib5中下发。 RRC_CONNECTED态测量用于小区切换/重定向。其测量配置在RRC Connection Reconfiguration/RRC Release中下发。 3. 小区重选测量准则 如果sib3配置了Sintrasearch，且Sservingcell &gt; Sintrasearch，不启动同频测量。
如果sib3配置了Sintrasearch且Sservingcell &lt; Sintrasearch，或者没有配置配置了Sintrasearch，启动同频测量。
如果sib5配置了异频载频信息，且其优先级高于服务小区，则启动异频测量。
如果sib5配置了异频载频信息，且其优先级小于或等于服务小区：
若sib3配置了Snonintrasearch，且Sservingcell &gt; Snonintrasearch，则不启动异频测量； 若sib3配置了Snonintrasearch且Sservingcell ≤ Snonintrasearch，或者没有配置Snonintrasearch，则启动异频测量。 4. 小区切换测量 eNodeB通过RRC Connection Reconfiguration下发测量配置，触发UE测量。
测量配置包括：
（1）测量对象列表：测量对象添加/修改列表和测量对象删除列表
测量对象ID carrier Freq: 即Earcfn。 allowed Meas Bandwidth：允许测量的带宽。 presence antena port1：若设置为true，表示所有的邻区至少有两个特定小区天线端口。 offset Freq：频率偏移。 邻区列表：添加修改邻区列表：cellindex，pci，邻区偏移量； 黑名单添加修改删除列表 （2）测量报告配置：测量报告添加/修改列表和测量对象删除列表
测量报告ID。trigger Type：报告触发类型，分为事件型和周期型。事件型分为eventA1、eventA2、eventA3、eventA4、eventA5、eventB1、eventB2。trigger Quantity：用来评估事件型触发报告的标准类型：RSRP或RSRQ。report Quantity：报告上报的值，RSRP或RSRQ，或者两个都上报。report interval：上报间隔。report Amountl：上报次数。max report cells：测量上报小区的最大个数。 （3）测量Id列表：测量ID添加修改/列表和测量ID删除列表。测量ID：关联测量对象ID和测量报告ID。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc9f58813d3981f7a013ac57d4928b8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b17168d35a76ca7bfd7513bee230f5a/" rel="bookmark">
			配置HTTPS加密的快速参考指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx
ssl_protocols TLSv1 TLSv1.1 TLSv1.2
阿帕奇
SSLProtocol All -SSLv2 -SSLv3
密码套房
选择密码套件可能很困难，它们的名称可能看起来很复杂，但可以很容易地分解成它们的组件。采取以下套房：
TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
组件是：
TLS - the protocol used ECDHE - the key exchange mechanism ECDSA - the algorithm of the authentication key AES - the symmetric encryption algorithm 128 - the key size of the above GCM - the mode of the above SHA256 - the MAC used by the algorithm 密钥交换机制
您应该只支持使用ECDHE和DHE（也称为EECDH和EDH）进行密钥交换的套件。EC变体更快，并且都提供完美前向保密（PFS），这是必不可少的。用ECDHE支持ECDHE和DHE的一个例子是首选。
TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 注意： TLSv1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b17168d35a76ca7bfd7513bee230f5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/772de2a87cb8b6ab0f790344911db6cb/" rel="bookmark">
			YSlow--Web前端性能测试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 介绍
YSlow是Yahoo发布的一款基于FireFox的插件，这个插件可以分析网站的页面，并告诉你为了提高网站性能，如何基于某些规则进行优化。它可以分析任何网站，并为每一个规则产生一个整体报告，如果页面可以进行优化，则YSlow会列出具体的修改意见。同类工具还有Google的插件PageSpeed。
2. 安装
YSlow现在支持包括FireFox、Chrome、Safari等多种浏览器。下面仅以Chrome和FireFox为例介绍其离线安装方式。
安装包下载：https://download.csdn.net/download/aduocd/10816543
2.1 Chrome
1. 打开Chrome，输入：chrome://extensions/，进入扩展程序。并勾选上“开发者模式”
2. 将下载的插件拖入到Chrome中，弹出如下所示的对话框。
3. 点击“添加扩展程序”。安装完成后，弹出类似提示页面
2.2 FireFox
1. 点击FireFox-》菜单栏-》附加组件。
2. 选择 插件-》从文件安装附加组件。
3. 找到YSlow插件，然后安装。
4. 重启浏览器。
5. 安装成功以后，按F12，出现YSlow标签页。
注：一般YSlow在FireFox中是作为FireBug的插件使用，需要先安装FireBug，再安装YSlow。目前最新版本的YSlow不兼容官方最新的FireBug。另外一种方法是，使用书签版，但我司网络限制无法使用。所以当前暂时使用YSlow最好的浏览器是Chrome。
3. 使用
1. 打开Chrome浏览器后点击YSlow图标。出现如下界面：
2. 点击Run Test。YSlow会根据当前页面的性能生成一个评估报告。如下图所示。
这里有4个部分的体现出该页面的性能。
1）Grade。这里是该页面总的评分。A表示最高，B次之，以此类推。根据YSlow的规则（详见最后YSlow的23条规则）计算得来，通常A-B代表性能合格，C以下的为不合格。即，评分低于80分。
2）score。与Grade类似，这里也是评分，分数越高表示当前页面性能越好。
3） ALL(23)。表示YSlow的23条规则。下方为该23条规则的描述，以及该页面在这些规则上的评分。其中N/A表示不适用此项规则。
4） CONTENT/ COOKIE…。这里是指该页面考虑的评分项。也可以通过这些标签查看详情。例如，查看CONTENT。
3. 点击Components。可以查看该页面所有部件的信息列表。从中可以得知每个部件的各种详细信息。如：类型、URL、Expires数据、状态、大小、读取时间、ETag信息等等。通过对该列表的分析，可以知道到底是什么东西最消耗我们的资源，从而有针对性地进行优化。点击蓝色的部分可以进一步查看详情。
4. 点击Statistics。该视图是页面所有组件元素的统计信息。包括页面大小、css样式表大小、脚本文件大小、总体图片大小、flash文件大小和css中用到的图片文件大小。以及哪些部件被缓存，缓存了多少等。左侧的图标表示第一次加载时组件元素加载的数量和大小的详细信息。右侧图标表示页面已经加载了缓存之后加载组件元素的数量大小的详细信息。
4. YSlow的23条规则
1）减少HTTP请求次数。合并图片、CSS、JS，改进首次访问用户等待时间。
2）使用CDN。就近缓存==&gt;智能路由==&gt;负载均衡==&gt;WSA全站动态加速。
3）避免空的src和href。当link标签的href属性为空、script标签的src属性为空的时候，浏览器渲染的时候会把当前页面的URL作为它们的属性值，从而把页面的内容加载进来作为它们的值。
4）为文件头指定Expires。使内容具有缓存性。避免了接下来的页面访问中不必要的HTTP请求。
5）使用gzip压缩内容。压缩任何一个文本类型的响应，包括XML和JSON，都是值得的。
6）把CSS放到顶部。
7）把JS放到底部，防止js加载对之后资源造成阻塞。
8）避免使用CSS表达式
9）将CSS和JS放到外部文件中。目的是缓存，但有时候为了减少请求，也会直接写到页面里，需根据PV和IP的比例权衡。
10）权衡DNS查找次数。减少主机名可以节省响应时间。但同时，需要注意，减少主机会减少页面中并行下载的数量。IE浏览器在同一时刻只能从同一域名下载两个文件。当在一个页面显示多张图片时，IE 用户的图片下载速度就会受到影响。所以新浪会搞N个二级域名来放图片。
11）精简CSS和JS
12）避免跳转
a. 同域：注意避免反斜杠 “/” 的跳转；
b. 跨域：使用Alias或者mod_rewirte建立CNAME（保存域名与域名之间关系的DNS记录）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/772de2a87cb8b6ab0f790344911db6cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a60eb01ad507e52e6fe4a2ca6666f5b4/" rel="bookmark">
			MATLAB前馈神经网络newff
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一-newff函数参数说明，初始化网络 net = newff(P,T,S) % 这两种定义都可以
net = newff(P,T,S,TF,BTF,BLF,PF,IPF,OPF,DDF)
P：输入参数矩阵。(RxQ1)，其中Q1代表R元的输入向量。其数据意义是矩阵P有Q1列，每一列都是一个样本，而每个样本有R个属性（特征）。一般矩阵P需要归一化，即P的每一行都归一化到[0 1]或者[-1 1]。 T：目标参数矩阵。(SNxQ2)，Q2代表SN元的目标向量。 S：N-1个隐含层的数目（S（i）到S（N-1）），默认为空矩阵[]。输出层的单元数目SN取决于T。返回N层的前馈BP神经网络 TF：相关层的传递函数，默认隐含层为tansig函数，输出层为purelin函数。 BTF：BP神经网络学习训练函数，默认值为trainlm函数。 BLF：权重学习函数，默认值为learngdm。 PF：性能函数，默认值为mse，可选择的还有sse，sae，mae，crossentropy。 IPF，OPF，DDF均为默认值即可。 例子：
一般来说
input，output是训练样本
net = newff（input，output，[1层个数，2层个数..]，{TF，1层传递函数，2层传毒函数}，BTF：‘训练函数’）
net = newff( input,output, [50] , { 'logsig' 'purelin' } , 'traingdx' ) ; 传递函数TF purelin： 线性传递函数。 tansig ：正切S型传递函数。 logsig ：对数S型传递函数。　隐含层和输出层函数的选择对BP神经网络预测精度有较大影响，一般隐含层节点转移函数选用 tansig函数或logsig函数，输出层节点转移函数选用tansig函数或purelin函数。 ３，学习训练函数BTF traingd：最速下降BP算法。 traingdm：动量BP算法。 trainda：学习率可变的最速下降BP算法。 traindx：学习率可变的动量BP算法。 trainrp：弹性算法。 变梯度算法： traincgf（Fletcher-Reeves修正算法） traincgp（Polak_Ribiere修正算法） traincgb（Powell-Beale复位算法） trainbfg（BFGS 拟牛顿算法） trainoss（OSS算法）
二-再次初始化，赋予训练要求 1.参数说明 通过net.trainParam可以查看参数 Show Training Window Feedback showWindow: true Show Command Line Feedback showCommandLine: false Command Line Frequency show: 两次显示之间的训练次数 Maximum Epochs epochs: 训练次数 Maximum Training Time time: 最长训练时间（秒） Performance Goal goal: 网络性能目标 Minimum Gradient min_grad: 性能函数最小梯度 Maximum Validation Checks max_fail: 最大验证失败次数 Learning Rate lr: 学习速率 Learning Rate Increase lr_inc: 学习速率增长值 Learning Rate lr_dec: 学习速率下降值 Maximum Performance Increase max_perf_inc: Momentum Constant mc: 动量因子
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a60eb01ad507e52e6fe4a2ca6666f5b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/267f6615491f38f704cbab20d278f9df/" rel="bookmark">
			Qchart 中清空绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近使用Qchart画图也是要画疯的节奏，最近又碰到了疑难杂症，在网chart汇入线条后，想把他们清除掉，结果发现怎么也清除不了，
在别的博客上说用这样的函数，
m_series1-&gt;clear(); m_scatseries1-&gt;clear(); 然鹅结果却是变成下面这个样子：
内心很狂躁，后来仔细研究了下QLineSeries类的append和replace这个两个函数，
为什么会出现上面得我问题，其实是画图的时候将数据点使用append方法进行绘图，这个函数实际上在之前线条的基础上添加数据，因此就会发现出现直勾勾的回拉线，使用clear方式也无法将数据删除，但是当我使用了replace方法后， 这个方法就是讲之前绘画的点读出来然后将添加的点加到pointf数组中，然后重新绘画折线图。
其实简单的理解为就是使用append方式是有时间先后顺序的，最后添加的点会与上一个点连接，但你想绘画的线在你上一个点的左边的时候，就会有回拉线的出现，实际上我们只希望这些点能连贯的连接起来，所以显然这样不合适了，因此使用replace方式。就像下面这种：
QVector&lt;QPointF&gt; Points = m_series0-&gt;pointsVector(); QVector&lt;QPointF&gt; Points2 = m_series0-&gt;pointsVector(); int i; for(i = 0;i&lt; len-8 ;i++) { Points[i] = Points2[i+1]; } Points[i]=QPointF(t.toMSecsSinceEpoch(),data.real); 加入新点 viewtool-&gt;m_series0-&gt;replace(Points); //利用replace函数更新数据 当你想清空所有线条时可以将
QVector&lt;QPointF&gt; points 清空然后replace 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9380dd45b70292c260a0eb3653b52d11/" rel="bookmark">
			ES的url方式的查询方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近公司在做用户画像，后面搭建es集群，为了实现根据标签查询用户的使用。最后的hive表导入到es查询使用。
后面肯定不是用es原生API的方式进行查询的，那么http方式的查询es是怎么样呢？
首先知道es集群的ip地址，默认端口9200。
1.根据id精准查询：
http://192.168.100.60:9200/index_primary_whole/std_index/253fa79b377709705b2086c124cbd478?pretty
说明：pretty参数表示以json格式展示
2.根据某个字段精准查询：
http://192.168.100.60:9200/index_primary_whole/std_index/_search?pretty&amp;q=sqid:ea6d9bc646673c91558b9757c7afad37
说明：多个条件之间用&amp;符号链接
根据标签筛选用户
3.根据某个字段精准查询：
http://192.168.100.60:9200/index_primary_whole/std_index/_search?pretty -d ‘{“query”:{“term”:{“sqid”:“ea6d9bc646673c91558b9757c7afad37”}}}’
4.根据某个字段分组查询：
curl -H ‘Content-Type: application/json’ -XGET ‘http://ESip:9200/index_name/table_name/_search?pretty’ -d ’
{
“size”: 0,
“aggs”: {
“provinces”: {
“terms”: {
“field”: “location_prov.keyword”
}
}
}
}’
注意：如果你之前没有相关经验直接查询的话，会有下面的报错的。
{
“error” : “Content-Type header [application/x-www-form-urlencoded] is not supported”,
“status” : 406
}
============================================================
这个问题，是在报文Content-type的参数：application/x-www-form-urlencoded不支持Json发送。需要改成application/Json
所以需要添加参数 ; -H ‘Content-Type: application/json’
这里是按照省份进行分组查询的结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceba7696e4a4117dbba04f411e4d96ee/" rel="bookmark">
			尚学堂第六章作业：异常机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写程序接收用户输入分数信息，如果分数在0—100之间，输出成绩。如果成绩不在该范围内，抛出异常信息，提示分数必须在0—100之间。
要求：使用自定义异常实现。 package com.shangxuetangBJ;
public class Number {
public void ad(int i) throws Test4Exception{
if(i&gt;=0&amp;&amp;i&lt;=100){
System.out.println(“分数是”+i);
}else {
throw new Test4Exception(“分数必须是0到100内”);
}
}
}
//自定义异常
public Test4Exception() {
super();
}
public Test4Exception(String message) { super(message); }	}
public class Test4 {
public static void main(String[] args) {
try {
System.out.println(“请输入分数”);
Scanner sc = new Scanner(System.in);
int i = Integer.parseInt(sc.next());
Number n = new Number();
n.ad(i);
} catch (Exception e) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceba7696e4a4117dbba04f411e4d96ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1c8a4fdd262b067a2a73a24acf72504/" rel="bookmark">
			Spm12 入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载MATLAB，以及对应的 SPM 版本。
SPM12 使用一种标准 3D（有些情况下是 4D）图像格式，称为 NIfTI-1.1。每个 NIfTI 格式的图 像是一个扩展名为“.nii”的文件。
“.nii”文件包括：
- 一个包含图像中所有数据的位图；
- 一个将位图套入 3D 坐标体系的变换矩阵（称为仿射变换：如旋转，平移，缩放和/或 裁剪）。
一个时间序列（如 300）的扫描包含 300 个.nii 文件。
若用 SPM 处理这些图像，一般只会改 变 NIfTI 文件中含有仿射变换的矩阵。需要理解的重要一点是：实际数据，即位图，是不变的，除非在处理过程的任何阶段中选用“Reslice”（重新分层）项。图像重新分层（在头动校 正和写入标准化后）时，NIfTI 文件中的仿射变换矩阵会重置，计算出新的位图，生成的新文件重命名时在旧文件名字头加上一个字母（如：OLDFILE.nii 变成 rOLDFILE.nii），故旧文件不 会被覆盖。
注：SPM12 也可像早先版本（SPM5 之前）一样使用 Header（.hdr）和 Image（.img）文件。 在 SPM12 中生成时，这些文件也跟 NIfTI 文件兼容，并包含与“.nii”图像一致的信息。这些文 件与在早先版本 SPM 中使用的旧 img/hdr 文件不同。在 SPM2 或更早版本中生成的 Analysis 7.5 文件可能不能正确导入 SPM12 中，因此在一个项目中不要更换 SPM 版本。
【如何打开 SPM 界面】
Matlab 打开 SPM所在路径。
命令行加载：
&gt;&gt; addpath D:\software\医学图像浏览器\spm12
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1c8a4fdd262b067a2a73a24acf72504/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dac90d5fdb3d4e8b69d158c25d89fc45/" rel="bookmark">
			用数学归纳法证明二叉树的先序遍历序列和中序遍历序列可以唯一确定一颗二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用数学归纳法证明二叉树的先序遍历序列和中序遍历序列可以唯一确定一颗二叉树。
首先说明：思想来自文都考研洪老师。包括逻辑框架的搭建，此篇文章为框架搭建完成后将细节补充完整。
首先，用到的数学的证明思想是第二类数学归纳法（完整归纳法），
其思想如下：
（1）第二类数学归纳法（完整归纳法）
1.当n=1时，形式成立（数学形式）。
2.当n&lt;=k时，假设形式成立。
3.当n=k+1时，形式成立。
那么可以得出结论，这个数学形式可以在n等于任意自然数时，都可以使得形式成立。
给定一颗二叉树（树非空，结点个数为n）
1.当n=1时， 树的先序遍历序列为（a）
树的中序遍历序列为（a）
那么可以唯一确定一颗二叉树 a
2.假设n&lt;=k时，
一颗树的先序遍历序列和中序遍历序列可以唯一确定一颗二叉树。
3.当n=k+1时
先序遍历序列（A1,A2,A3,A4,…,Am）
中序遍历序列（B1,B2,B3,B4,…,Bm）
a.当A1=B1时，即先序遍历的第一个遍历结点（为树的根结点）等于中序遍历的第一个结点的时候，说明中序遍历B1（B1为根结点）之前无左子树，（中序遍历若要先遍历根结点要先中序遍历左子树，若B1之前为空，说明没有中序遍历左子树，说明B1的左子树为空）
{
因为中序遍历的递归定义是
1.中序遍历左子树，
2.遍历根节点，
3.中序遍历右子树。
}
故而又说明中序遍历序列B1之后的结点即（B2,B3,B4,…,Bm）为B1的右子树
又因为m=n=k+1
所以（B2,B3,B4,…,Bm）共有m-2+1=m-1=k+1-1=k个结点。
而先序遍历序列A1之后的序列（A2,A3,A4,…,Am）
也有m-1=k+1-1=k个结点。
这时候符合假设，当n&lt;=k时，的结论，所以根据数学归纳法，可以证明在这种情况下，一棵树的先序遍历序列和中序遍历序列可以唯一确定一颗二叉树。
b.
先序遍历序列（A1,A2,A3,A4,…,Am）
中序遍历序列（B1,B2,B3,B4,…,Bm）
当A1=Bm时，Bm无右子树，同3.a的证明思路一样，可以证明在这种情况下，一棵树的先序遍历序列和中序遍历序列可以唯一确定一颗二叉树。
c.（已经证明了A1=B1或者A1=Bm的情况，现在要证明的是A1=（B2,B3,B4,…,Bm-1）中任意一个的情况时，一棵树的先序遍历序列和中序遍历序列可以唯一确定一颗二叉树）
先序遍历序列（A1,A2,A3,A4,…,Am）
中序遍历序列（B1,B2,B3,B4,…,Bm）
当先序遍历序列（A1,A2,A3,A4,…,Am）中的A1为中序序列中的
（B2,B3,B4,…,Bm-1）时
设A1=Bj，那么这棵树的中序遍历序列为
{(B1,B2,B3,…,Bj-1)Bj (Bj+1,Bj+2,Bj+3,…,Bm )}
而因为（B1,B2,B3,B4,…,Bm）为中序遍历序列所以
Bj的左子树为(B1,B2,B3,…,Bj-1)
Bj的右子树为(Bj+1,Bj+2,Bj+3,…,Bm )
设Bj的左子树的结点个数为x个，Bj的右子树的结点个数为y个，
那么可以明确的是，
1&lt;=x&lt;=m-1-1(由c的条件可得，Bj不能为Bm，由c的条件可得，所以Bj的右子树最小为1个结点，而Bj本身又是一个结点，所以Bj左子树结点的个数最大为m-1-1，即总的减去Bj再减去Bj右子树最小的时候，就是Bj左子树最大的时候)
而确定y也是同理，只不过成立确定Bj右子树的结点个数的范围。
1&lt;=y&lt;=m-1-1
而且，x+y=m-1
(Bj的左右子树的总个数即为总的个数减去Bj本身)。
而这个时候，
Bj的左子树为(B1,B2,B3,…,Bj-1)
节点个数1&lt;=x&lt;=m-1-1=k-1 (m=n=k+1)
Bj的右子树为(Bj+1,Bj+2,Bj+3,…,Bm )
结点个数1&lt;=y&lt;=m-1-1=k-1 (m=n=k+1)
由于A1=Bj 先序遍历序列（A1,A2,A3,A4,…,Am）
又因为先序遍历的递归定义为{
遍历根节点，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dac90d5fdb3d4e8b69d158c25d89fc45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdbf3c2af211cf23929b97135eb76db9/" rel="bookmark">
			COSO企业风险管理综合框架主要关注8大层面的企业风险
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		COSO企业风险管理综合框架主要关注8大层面的企业风险。
内部环境：治理结构、组织结构、授权与责任、风险偏好、人力资源政策、风险管理文化等。
目标设定：战略目标、经营目标、报告目标、合规目标。事项识别：事件识别方法、事件分类、风险与机会。风险评估（与信息安全高度相关）：固有风险与剩余风险评估。现在，COSO里面的风险评估方法为“风险=发生可能性*影响”。ISO27005也采用了相同的风险评估方法。这进一步体现了标准与标准之间的映射和借鉴关系。风险应对：风险回避、风险降低、风险分担、风险承担。控制活动（与信息安全高度相关）：企业层面控制、业务流程层面控制、IT一般控制与应用控制。其中，IT一般控制与应用控制具体实现在COBIT里面进行了详尽描述。这也体现了标准之间的映射和借鉴关系。信息与沟通：收集与传递内部信息、外部信息。监控：独立监控、持续监控、自我评价、缺陷改进。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eadd2639e220b28dc23b756a4e044429/" rel="bookmark">
			Android ConstraintLayout使用详解—手把手教你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说在前面的话 在这里预祝大家2019年：猪事顺利，青春永猪，猪圆玉润，猪笼入水—八面来财
对于这个已经出现了两年的新布局ConstraintLayout，之前只是作为知识了解并未在真正的使用它，今天让我们来从几个方面解读ConstraintLayout并对它的性能做细致化分析。
二、ConstraintLayout是什么？ ConstraintLayout是Google在2016年的I/O大会上推出一款新型布局方式，也是Android Studio 2.2中主要的新增的功能之一。目的是为了解决由于布局嵌套过于复杂而带来的页面渲染性能问题。
可以这么说，ConstraintLayout是RelativeLayout的升级版，它允许我们在Layout上设计子控件与子控件之间的位置关系，而且它远比RelativeLayout在Android Studio中表现的效果更灵活、更容易使用。
下面是官网对它描述：
ConstraintLayout allows you to create large and complex layouts with a flat view hierarchy (no nested view groups). It’s similar to RelativeLayout in that all views are laid out according to relationships between sibling views and the parent layout, but it’s more flexible than RelativeLayout and easier to use with Android Studio’s Layout Editor.
三、为什么要用ConstraintLayout？ 我们都知道，在传统的Android开发中，界面基本上都是靠编写XAL代码完成的，虽然Android Studio也支持可视化的方式编写界面，但是操作起来异常的麻烦，而且布局展示效果也达不到预想的效果，所以也不建议大家使用可视化编写Android程序的界面布局。
但是ConstraintLayout出现就为了打破这一现状。它和传统编写界面的方式恰恰相反，ConstraintLayout非常适合使用可视化的方式来编写界面，但是不太适合使用XAL的方式来进行编写。当然，可视化的背后仍然还是使用了XAL代码来实现的，只不过这些代码是由Android Studio根据我们的操作自动生成相应的布局。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eadd2639e220b28dc23b756a4e044429/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0e1038224da092d1e270bf4638422c5/" rel="bookmark">
			Intellij关闭双击shift打开全局搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一 Intellij关闭双击shift打开全局搜索 在使用Intellij idea的时候有个很强大的功能就是全局搜索 SearchEverywhere，双击shift就能唤出。
同时shift键是我们切换输入法经常用到的，在中英文切换的时候总是误操作把全局搜索框召唤出来。
1:修改配置文件的方式关闭全局搜索
2:定位配置文件所在位置
idea安装目录/lib/resources.jar
3:利用解压工具提取 PlatformActions.xml
4:定位文件中SearchEverywhere ，并注释掉
5:把修改后的 PlatformActions.xml放回resources.jar即可
方法二 Intellij idea版本是2019.1，其他版本请做参照
Help-&gt;Find Action -&gt;Registry
找到 idea.suppress.double.click.handler，再后面把√打上即可。
小尾巴~~
只要有积累，就会有进步
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8849ad59a5a1eae4143e2899c7b1e1dd/" rel="bookmark">
			R语言学习(五)——聚类分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是聚类分析 聚类是一个将数据集划分为若干组（class）或类（cluster）的过程，并使得同一个组内的数据对象具有较高的相似度，而不同组中的数据对象是不相似的。
聚类与分类的区别：
聚类是一 种无监督的学习方法。与分类不同，它不依赖于事先确定的数据类别和标有数据类别的学习训练样本集合。
聚类是观察式学习，而不是示例式学习。
聚类分析的典型应用
在商务上，聚类能帮助市场分析人员从客户基本库中发现不同的客户群，并且用购买模式来刻画不同的客户群的特征。在生物学上，聚类能用于推导植物和动物的分类，对基因进行分类，获得对种群中固有结构的认识。聚类在地球观测数据库中相似地区的确定，汽车保险单持有者的分组，及根据房子的类型、价值和地理位置对一个城市中房屋的分组上也可以发挥作用。聚类也能用于对Web上的文档进行分类，以发现信息。
什么是好的聚类 一个好的聚类方法将产生以下的高聚类：
最大化类内的相似性最小化类间的相似性 聚类结果的质量依靠所使用度量的相似性和它的执行。
聚类方法的质量也可以用它发现一些或所有隐含模式的能力来度量。
聚类分析中的数据类型 基本的数据结构
数据矩阵
数据矩阵是一个对象—属性结构，由n个对象组成，如：人；每个对象利用p个属性加以描述，如：年龄、身高、体重等。数据矩阵采用关系表形式或n*p矩阵来表示：
相异度矩阵
相异度矩阵（又称差异矩阵）是一个对象—对象结构，存放n个对象两两之间的近似性（差异性），采用n*n的矩阵形式表示：
其中，d(i,j)表示对象i和对象j之间的差异（或不相似程度）。通常d(i,j)为一个非负数；当对象i和对象j非常相似或彼此“接近”时，该数值接近0；该数值越大，就表示对象i和对象j越不相似，由于有d(i,j)=d(j,i)且d(i,i)=0。所以，矩阵呈现出上三角或下三角的形式。 注意：
数据矩阵通常称为双模（two-mode）矩阵：行和列分布表示不同的实体；相异度矩阵常被称为单模（one-mode）矩阵：行和列表示同一实体。许多聚类算法都是以相异度矩阵为基础计算的，所以如果数据是以数据矩阵的形式给出的，则需要首先转换为相异度矩阵，才可以利用聚类算法来处理。 区间标度变量
区间标度变量（又称间隔数值变量）为基本呈直线比例的连续变量，如：重量、高度和温度等。
为什么要标准化？ 通常，选用的度量单位将直接影响聚类分析的结果，如：将高度的度量单位由“米”变为“英尺”，或将重量的单位由“千克”变为“英镑”，可能会产生非常不同的聚类结构。一般来说，度量单位越小，变量可能的值域越大，对聚类结果的影响也越大。因此，为避免对度量单位选择的依赖，数据应当标准化。
度量值的标准化 为了实现标准化，一种方法是将初始测量值转换为无单位变量。给定一个属性变量f，可用如下公式对其进行标准化：
计算平均的绝对偏差
计算标准化测量（z-score）
在标准化之后，或在无需标准化的特定应用中，由间隔数值所描述对象之间的差异（或相似）程度可以通过计算相应两个对象之间距离来确定，最常用的距离计算公式是欧氏距离（Euclidean distance），其具体公式如下：
R语言中求欧式距离
使用dist()函数
dist(x, method = "euclidean", diag = FALSE, upper = FALSE, p = 2) #x是样本矩阵或者数据框。 method表示计算哪一种距离： euclidean 欧几里德距离，即平方再开方。 maximum 切比雪夫距离 manhattan 绝对值距离 canberra Lance 距离 minkowski 明科夫斯基距离，使用时要指定p值 binary 定性变量距离. 例：
A的身高180cm，年龄25岁，有1万存款
B的身高166cm，年龄30，有5万存款
C的身高170cm，年龄45，有20万存款
计算A、B、C的距离
将每个人的数据表示成向量
&gt; a&lt;-c(180,25,1) &gt; b&lt;-c(166,30,5) &gt; c&lt;-c(170,45,20) 形成数据矩阵
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8849ad59a5a1eae4143e2899c7b1e1dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1acd0113a69a1e59c667836f7f20498d/" rel="bookmark">
			android蚂蚁金服支付宝支付集成步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此篇仅限于android客户端集成步骤,查看全部的请转https://docs.open.alipay.com/204/105296/
自支付宝 SDK 15.5.7 开始,打包方式更换为 AAR，替代之前的 JAR 打包，SDK 支付接口部分不变.现在就基于支付宝SDK15.5.7集成支付宝支付
首先下载新的AAR的SDK包:https://download.csdn.net/download/lanrenxiaowen/10811584
一.下载完将里面的AAR格式包放入到项目的libs里面 二.在您主项目的 build.gradle 中，添加下面的内容，将 libs 目录作为依赖仓库： allprojects { repositories { google() jcenter() maven { url 'https://www.jitpack.io' } flatDir { dirs 'libs' } } } 三.在您 App Module 的 build.gradle 中，添加下面的内容，将支付宝 SDK 作为项目依赖： //支付宝支付 implementation (name: 'alipaySdk-15.5.7-20181023110917', ext: 'aar') 权限配置: &lt;!-- 访问网络，网络定位需要上网 --&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;!-- 获取运营商信息，用于支持提供运营商信息相关的接口 --&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;!-- 用于访问wifi网络信息，wifi信息会用于进行网络定位 --&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt; &lt;!-- 用于读取手机当前的状态 --&gt; &lt;uses-permission android:name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1acd0113a69a1e59c667836f7f20498d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df9ea3bff64088e94dba241de09eea9/" rel="bookmark">
			openssl/ssl.h  file not found   mac 完美解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目前使用的系统MacOSX10.14；
原因：MacOSX10.11开始就没有openssl了，用的是LibreSSL
1、首先，确定自己是否真的有安装openssl：brew install openssl，根据提示可以自己看到结果；
至此，说明你已经安装了openssl；
2、在 /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk/usr/include/
中添加openssl文件夹，
openssl文件夹的查找方法：可以通过brew install openssl（因为你已经安装过了，不会重复安装，它会告诉你openssl的安装目录，打开该目录，找到/include/openssl文件夹，复制过去）
OK！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a050af65ce48b5bcb934732d4249c98d/" rel="bookmark">
			电商订单逻辑图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 生成订单 用户确认订单 商品信息：商品信息属于订单系统的上游端，所有订单都是从商品演进而来，从商品到订单，订单系统必须搜集相关的商品信息，包括店铺信息，商品id，商品规格，商品数量，商品价格。获取到的商品信息将在订单详情页内展示，形成订单信息后供仓库方便拣货，包装。
用户信息：用户信息包括购买用户的ID，收货人，收货地址，联系方式。有些平台的用户成长体系是基于用户对平台的活跃度来计算的，例如京东，它有会员等级及积分卡等类似的成长标识，此时获取到的用户信息除了普通的信息字段外，还需要获取该用户的等级，该次购买后所获得的积分，以及该用户所在等级能在该订单上扣除的优惠等信息，具体怎么操作取决于公司的业务方向。
金额信息：因为金额信息的特殊性，所以独立出来讲，理论上金额信息应归属商品信息。金额信息的特殊性在于其不止一种金额，其涉及到商品金额，优惠金额，支付金额。而优惠金额中涉及到的信息较复杂，像有自营和第三方入驻的电商平台，都会有商家优惠和跨店优惠，而这些优惠又分不同类型，例如现金扣减，消费券扣减，积分获取，礼品卡扣减，或者以上几种的组合使用。想要涉及好这一块内容，需要根据目前自己公司的业务情况，列出所支持的优惠类型，再枚举出各种组合下的优惠类型，才能保证流程的完整性。
时间信息：记录各个卡点下的时间，一是记录，二也是方便售后验证和客户分析。订单时间是根据订单状态改变而改变的，比如：我们常见的用户。
下单未付款：即展示订单创建时间、下单时间；待发货状态：展示订单创建时间、下单时间、支付时间；待收货状态：展示订单创建时间、下单时间、支付时间、发货时间；交易完成状态：展示订单创建时间、下单时间、下单时间、支付时间、发货时间、完成时间；待退款状态：展示退款订单创建时间、申请退款时间；交易关闭-用户取消：展示订单创建时间、下单时间、用户取消时间；交易关闭-仅退款：订单创建时间、下单时间、支付时间、退款申请时间、退款成功时间；交易关闭-退货退款（包含部分仅退款）：订单创建时间、下单时间、支付时间、交易完成时间、退款申请时间、退款时间。 订单信息：订单信息在订单系统最为核心，订单信息最重要的又是订单状态。
电商购物中，订单状态分别有以下几种：【待付款】、【待发货】、【待收货】、【待评价】、【交易完成】、【用户取消】、【仅退款】、【退货退款】。而我们一般会将后三种统一放在订单售后独立呈现，去方便平时商家操作的便捷性。
订单流程 订单流程是指从订单产生到完成整个流转的过程，其中包括正想流程和逆向流程。正向流程就是一个正常的网购步骤：订单生成–&gt;支付订单–&gt;卖家发货–&gt;确认收货–&gt;交易成功。
1、正向流程
订单生成：用户下单后，系统需要生成订单，此时需要先获取下单中涉及的商品信息，然后获取该商品所涉及到的优惠信息，如果商品不参与优惠信息，则无此环节。
接着获取该账户的会员权益（这里其实需要注意的是：优惠信息与会员权益是有区别的，就好比商品满减是优惠信息，新人立减是会员权益，一个是针对商品，另一个是针对账户）。
库存扣减是指可销售库存数量-1，严格来讲库存扣减目前分为两种：
一种是下单减库存；另一种是付款减库存。 个人觉得中小创业者也许竞争者不比淘宝中的卖家，在电商这个存量市场，需要精细化的运营才能存活下来，如此说保证用户体验才是根本。所以我这里的观点是生成订单扣减库存，这种做法会避免用户支付成功商家却没货的情况。然后计算运费，订单生成成功。
支付订单：用户支付完订单后，需要获取订单的支付信息，包括支付流水号、支付时间等。支付完订单接着就是等商家发货，但在发货过程中，往往还有一种情况存在，很正常却也比较复杂，就是订单拆单。
订单拆单分两种：一种是用户挑选的商品来自于不同渠道（自营与商家，商家与商家），此时就需要拆分订单，并分开结算，这里还涉及父子订单的说法，这里不再赘述。另一种是在SKU层面上拆分订单：不同仓库，不同运输要求的SKU，包裹重量体积限制等因素都需要将订单拆分。比如：商品A只在甲仓库有，商品B又只在乙仓库有，此时会将商品A与商品B拆分成两个订单。或者有些企业的做法是将商品A/B调拨到另外一个仓库统一发货，也方便了用户。 订单拆单看起来简单，其实里面涉及到底层的系统支持，如你需要对每一个仓库的货品进行相对准确的盘点，且做到实时同步（涉及到仓库精细化管理），对商品进行准确分类与摆放，对商品信息记录准确无误等。
这其中哪一模块都是一个浩大的工程，PM一般进入一家公司都会在原有（半成品）的基础上进行优化，大家不妨多思考一下底层业务，只有在底层做好精细化管理，才能支持线上丰富的用户需求。
商家发货：商家发货过程也有一个标准化的流程，上面也有讲到，订单拆分时会涉及到仓库间调拨，然后仓库会对商品进行打单、拣货、包装、交接快递配送。这套标准化流程如果优化好，也是一个大工程，这里不再赘述，建议大家看看库存与仓库管理方面的书籍，详细了解。
确认收货：商家发货后，就是等快递配送了，订单系统需要接入一些常用快递企业的接口，方便用户与商家在站内查询快递信息。
交易成功：收到货后，不是一个服务的结束，相反是一个服务的开始。订单系统需要在快递被签收后提醒用户对商品做评价，这里要注意，确认收到货不代表交易成功，交易成功是指在收到货X天的状态，此时订单不在售后的支持时间范围内。到此，一个订单的正向流程就算走完了。
目前我也没有研究过，不过我的经验告诉我订单系统对售后订单的处理并不比正产订单少，身为电商PM，我们的工作就是去优化这些流程，提高用户粘性。本身售后订单的出现，在某种程度上已经伤害到了用户，如果流程还一团糟的话，我们根本没有机会等到用户的复购。
2、逆向流程
取消订单：用户提交订单时，在跳转至支付前直接退出，此时用户原则上属于取消订单，因为还未付款，则比较简单，只需要将原本提交订单时扣减的库存补回即可。
支付失败：用户进行支付时退出，或者取消支付，我们将其列为支付失败状态，此时处理同上，将扣减的库存补回可销售库存即可。
付款后退款：用户支付成功后，商家还未发货，支持用户申请退款，此时如果仓库与客服是分离的，则需要先检查仓库是否已经发货，若已发货则应与客户沟通是否可以收到货后再进行退款，如果仓库还未发货，则可直接同意用户退款。或者企业接入菜鸟物流，实行截件功能，不过这种操作还不成熟，成本会比较大，不适合中小创业型公司。
缺货退款：用户支付成功后，商家发货时发现仓库缺货（如果提交订单扣减库存，则会减少缺货情况，为什么是减少而不是避免？因为仓库管理商品时没办法做到100%精准，所以信息有时候会不准确，导致线上的可销售库存显示有库存而仓库已经售空的状态），则需要与用户协商是否退款。
这个流程订单系统可以做到流程化、自动化，连接消息中心和仓库管理系统去实现，难点在于消息的实时性。我就遇到过在淘宝买过一件上衣，一天过去了，商家跟我说没货了，我当时杀人的心都有了。
待收货退款：这个问题目前还没有特别完美的解决方法，商家发了货之后，用户还未收到货，此时货在路上。
我曾经在一些交流群里提出过这个问题，大家的看法都不一样，大体上分为两种做法：
一种是用户收到货后重新寄回；另一种是用户直接拒收包裹，包裹直接退回原地址。 我个人倾向于第一种，第一种比较灵活，因为用户未收到货就退款的原因一般与商品质量关系不大，所以如果允许用户直接拒收退回，相当于商家需要承担回退运费，而本身可能与商家并无太大关系。
另外一个原因就是，有些商家发货地址与退货地址不在同个地方，不支持直接退回。尽管如此，在到处强调用户体验的今天，增加用户的售后成本也是在消耗用户对平台的耐心，大家不妨去思考一下，有没有更好的解决方法。
订单推送
订单推送的触发依赖于状态机的改变，涉及到的信息包括：
推送对象（用户、商家、仓库）；推送方式（站内消息、push、短信、微信）；推送节点（状态机）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94646d2e7bb3777184c7e217a6595762/" rel="bookmark">
			Python subprocess.Popen 实时输出 stdout（正确管道写法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大部分的程序是这样的：
from subprocess import Popen, PIPE, STDOUT p = Popen(cmd, stdout=PIPE, stderr=STDOUT, shell=True) while True: print(p.stdout.readline()) if not line: break 但是由于子程序没有进行 flush 的话，会把结果缓存到系统中。导致程序运行完成，上面的程序才会进行打出（会一直卡在readline这个函数）。
解决方法：
p = subprocess.Popen(cmd, stdout=subprocess.PIPE, bufsize=1) for line in iter(p.stdout.readline, b''): print line, p.stdout.close() p.wait() 实际弱口令我是这样写的
import subprocess #Popen proc = subprocess.Popen(medusaCMD, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True) for line in iter(proc.stdout.readline, 'b'): print line if not subprocess.Popen.poll(proc) is None: if line == "": break proc.stdout.close() 记小的写法
proc = subprocess.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94646d2e7bb3777184c7e217a6595762/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9e507110c2b273bfc3a17a4365e1e18/" rel="bookmark">
			SqueezeNet论文详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址： https://arxiv.org/pdf/1602.07360.pdf
网络介绍： 本文提出SqeezeNet。它在ImageNet上实现了和AlexNet相同的正确率，但是只使用了1/50的参数。更进一步，使用模型压缩技术，可以将SqueezeNet压缩到0.5MB，这是AlexNet的1/510。
架构的提出动机（轻量化模型的好处）： 1.提高分布式训练的效率：
对于分布式数据并行训练，通信开销与模型中的参数数量成正比。所以服务器之间的通信是分布式CNN训练的可扩展性的限制因素。因为是轻量化模型，训练过程中的沟通更少，数据量更少，训练更快。
2.小模型导出到客户端的开销更少：
较小的模型需要较少的通信，使频繁更新更可行。
3.更可行的FPGA和嵌入式部署：
FPGA通常具有小于10MB的片上存储器并且没有片外存储器，足够小的模型可以直接存储在芯片上。
模型设计过程： 1.模型压缩的探索过程
压缩的目的：
减小参数的同时保证一定的精度。
一种方法是使用现有的CNN模型并有损压缩它。主要方式有模型奇异值分解(SVD)，网络剪枝，深度压缩、硬件加速器。
2.神经网络空间设计的探索
神经网络（包括深度卷积神经网络）具有大的设计空间，具有用于微架构，宏架构，解算器和其它超参数的许多选项。
通常进行设计空间探索的方法有：
（1）贝叶斯优化
（2）模拟退火
（3）随机搜索
（4）遗传算法
3.squeezeNet设计过程：
结构设计策略：
1.使用1*1滤波器代替3*3滤波器，1x1滤波器具有比3x3滤波器少9倍的参数。
2.将输入到3x3过滤器的通道的数量减少。考虑一个完全由3x3滤波器组成的卷积层。该层中的参数的总量是（输入通道的数量）∗（滤波器的数量）∗（3 * 3）。 因此，为了在CNN中保持小的参数总数，不仅要减少3×3滤波器的数量（见上面的策略1），而且要减少3×3滤波器的输入通道的数量。我们使用挤压层将输入到3x3个过滤器的通道数量减少。
3.在网络后期降采样(将欠采样操作延后)，以使卷积层具有大的激活图.更大的激活图保留了更多的信息，可以提供更高的分类准确率 .（可以在参数数量受限的情况下提高准确率）
Fire模块的构建：
其中包括：挤压卷积层(1*1滤波器)、扩展层(1*1和3*3卷积的混合)。我们在Fire模块中公开了三个可调整维度（超级参数）：s1X1，e1X1和e3X3。在Fire模块中，s1X1是挤压层（所有1x1）中的滤波器数，e1X1是扩展层中1x1滤波器的数量，e3X3是扩展层中的3x3滤波器的数量。当我们使用Fire模块时，我们将s1X1设置为小于（e1X1 + e3X3）。
SqueezeNet结构：
SqueezeNet开始于一个独立的卷积层（conv1），然后是8个fire模块（fire2-9），最后是一个最终的转换层（conv10）。 我们从网络的开始到结束逐渐增加每个fire模块的过滤器数量。polling安排尽量靠后，所以 SqueezeNet在层conv1，fire4，fire8和conv10之后以步长为2来执行max-pooling。如图是SqueezeNet架构的宏体系结构视图。 左：SqueezeNet; 中间：SqueezeNet与简单的旁路; 右：具有复杂旁路的SqueezeNet。
SqueezeNet实现细节： 1.Fire的扩展块中，1*1卷积核3*3卷积块输出特征图维度的保证。为了使来自1x1和3x3滤波器的输出激活具有相同的高度和宽度，我们在输入数据中向扩展模块的3x3滤波器添加零填充的1像素边界。
2.激活函数选用Relu
3.在fire9模块之后应用比率为50％的dropout
4.去掉全连接层
模型性能评估 SqueezeNet体系结构尺寸：
基于SVD的方法能够将预训练的AlexNet模型压缩5倍，同时将顶1精度降低到56.0％（Denton等人，2014）。网络修剪实现了9倍的模型大小减少，同时在ImageNet上保持了57.2％的top-1和80.3％的top-5精度的基线（Han et al。，2015b）。深度压缩使模型尺寸减小了35倍，同时仍然保持了基线精度水平（Han 等人，2015a）。现在，使用SqueezeNet，与AlexNet相比，我们实现了模型尺寸减少50倍，同时满足或超过了AlexNet的top-1和前top-5的精度。
即使使用未压缩的32位值来表示模型，SqueezeNet具有比模型压缩社区的最好结果小1.4倍的模型大小，同时保持或超过基线精度。
SqueezeNet模型适合被压缩：
我们使用33％稀疏度和8-bits，对SqueezeNet应用深度压缩（Han等，2015a）。 这产生了与AlexNet相当的精度的0.66MB模型（363×小于32位AlexNet）。此外，在SqueezeNet上应用具有6-bits和33％稀疏性的深度压缩，我们产生具有等效精度的0.47MB型号（510x小于32位AlexNet）。
总之：通过将CNN架构创新（SqueezeNet）与最先进的压缩技术（深度压缩）相结合，我们实现了模型尺寸减少510×，与基准相比精度没有降低。
SqueezeNet空间结构设计探索 上图分别是SR和3*3滤波器在扩展层比例对模型大小和精度的影响
已有的参数：
s1X1，e1X1和e3X3。 SqueezeNet有8个fire模块，总共24维超参数。
再定义几个参数(为了对SqueezeNet这样样架构的设计空间进行广泛扫描)：
1.basee：
CNN中第一个fire模块中的扩展过滤器数
2.pct3X3：
3X3的扩展过滤器的百分比，ei3X3=ei∗pct3X3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9e507110c2b273bfc3a17a4365e1e18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6d7e59ad73f888b399eb79ebc60c25/" rel="bookmark">
			数据库第六章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		属性间的联系 1.一对一联系
2.一对多联系
3.多对多联系
数据依赖 是一个关系内部属性与属性之间的一种约束关系
是现实世界属性间相互联系的抽象
是数据内在的性质 是语义的体现
1.函数依赖
2.多值依赖
例：描述一个学生关系，可以有学号、姓名、系名等属性。
一个学号只对应一个学生，一个学生只在一个系中学习 “学号”值确定后，学生的姓名及所在系的值就被唯一确定。
现给出一个关系模式找出其问题：
U ＝{Sno, Sdept, Mname, Cno, Grade}
F={Sno→Sdept, Sdept→ Mname, (Sno, Cno)→ Grade}
（1）数据冗余
（2）更新异常
（3）插入异常
（4）删除异常
把这个单一的模式分成三个关系模式：
S(Sno,Sdept,Sno → Sdept);
SC(Sno,Cno,Grade,(Sno,Cno) → Grade);
DEPT(Sdept,Mname,Sdept → Mname);
这三个模式都不会发生插入异常、删除异常的问题，数据的冗余也得到了控制。
平凡函数依赖与非平凡函数依赖 X→Y，但Y⊈X则称X→Y是非平凡的函数依赖。
X→Y，但Y⊆X 则称X→Y是平凡的函数依赖。
例：在关系SC(Sno, Cno, Grade)中， 非平凡函数依赖： (Sno, Cno) → Grade 平凡函数依赖： (Sno, Cno) → Sno (Sno, Cno) → Cno
完全函数依赖与部分函数依赖 在关系SC(Sno, Cno, Grade)中，有： 由于：Sno ↛Grade，Cno ↛ Grade， 因此：(Sno, Cno) → Grade (Sno,Cno)→Sdept是部分函数依赖 因为Sno →Sdept成立，且Sno是（Sno，Cno）的真子集
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f6d7e59ad73f888b399eb79ebc60c25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f6b65d41f5c38f54935f000e854c030/" rel="bookmark">
			两个整数的二进制数有多少的位不同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算两个整数的二进制数有多少个位不同，我们首先可以想到异或操做：如果对应位相同就是0，否则就是1.通过计算这个新数的二进制数1的个数就可以计算出这两个二进制数有多少个位不同。
完整代码如下，需要注意的
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int a; int b; int c; int count=0; while (1) { printf("请输入小于等于255的a的值："); scanf_s("%d", &amp;a); if (a &lt;= 255) break; } while (1) { printf("请输入小于等于255的b的值："); scanf("%d", &amp;b); if (b &lt;= 255) break; } c = a^b; for (int i = 0; i &lt; 32; i ++) { if (((c &gt;&gt; i) &amp; 1) == 1) count++; } printf("a与b的二进制数共有%d个位不同\n", count ); system("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f6b65d41f5c38f54935f000e854c030/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61a22eff3dcea3a22223fdb4b94d19ab/" rel="bookmark">
			《Ordinal Depth Supervision for 3D Human Pose Estimation》-CVPR2018 论文阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 《Ordinal Depth Supervision for 3D Human Pose Estimation》是一篇CVPR2018 Oral Presentation的工作，主要解决RGB的3D human pose estimation任务，也是当前的state-of-the-art.
这里对这篇文章做一个简单的总结，如有理解不对的地方，欢迎指正！！
方法 总结一下文章的中心思想，也就是下面的Figure1:
文章最创新的地方在于提出了用Ordinal的思想在辅助3D人体姿态估计任务的训练，2D标注的人体姿态估计数据库很多，比如COCO，MPII，FLIC…，并且具有多样性，也就是In-the-Wild的图片，但是3D人体姿态估计的数据库往往是在室内受限场景下面采集的（比如Human3.6M），场景单一，这样的环境下面训练的CNN模型很容易过拟合，导致对于自然图片无法很好的进行泛化。因此作者采用标注In-the-Wild的图片的Ordinal Depth的方法，使得CNN可以在In-the-Wild的图片上进行训练。
所谓的Ordinal Depth，就是关节点之间的相对深度，不需要知道每一个关节点的绝对物理深度，只需要知道关节点的深度顺序即可，这样我们同样可以采取Ranking Loss的监督进行网络的训练。如下图所示：
可以看到，网络预测的深度并不直接进行监督，而是采用深度值之间的大小关系进行Ranking监督，每一对关节点都可以构成一个loss，最后加和，这样就使得网络的训练成为可能。
那么如何充分利用In-the-Wild图片的2D标注呢？也就是结合2D关节点的GroundTruth同时对网络进行监督，很简单，使网络同时输出2D关节点的像素坐标以及3D的Depth值就可以：
这里作者使用的同时回归2D keypoints以及Ordinal Depth的方法，并不是直接对绝对位置进行回归，而是采用了“Volumetric Prediction”的方式，也就是说最后预测的是一个3维的Volume，其实也就是2D的HeatMap的拓展：
值得注意的是，这个方法也是该作者的团队在CVPR2017年提出的工作：《Coarse-to-Fine Volumetric Prediction for Single-Image 3D Human Pose》。通过预测每一个像素值的3D的Likelihood，最后取Max得到3D的坐标位置：
最后的Loss由2D的关节点L2损失以及Ordinal Depth Ranking Loss构成。这就解决了使用Ordinal Depth进行In-the-Wild图片的3D人体姿态估计问题。
在此之前，都是在介绍怎么使用Ordinal Depth在In-the-Wild图片上进行3D Pose的估计，进一步，如何将3D人体姿态估计数据库中的3D Pose也利用上呢？作者的做法是添加一个Reconstruction模块，输入Ordinal的Depth，输出实际物理距离的Depth：
这样，3D的人体姿态估计数据库就可以也用来训练这个模型了，新增的Reconstruction模块可以很容易的嵌入到目前的网络中去（几个全连接层而已）：
结果 在Human3.6M，MPI-INF-3DHP等几个数据库上面都是state-of-the-art：
更多的实验结果可以去看作者的原文，包括Ablation验证各个component的效果以及最后各个数据库上面报告的结果。
最后给几个数据库的链接：
Human3.6M：http://vision.imar.ro/human3.6m/description.php
COCO关节点：http://cocodataset.org/#keypoints-2017
MPII：http://human-pose.mpi-inf.mpg.de/
LSP：http://sam.johnson.io/research/lsp.html
当然还有这篇文章的项目主页：https://www.seas.upenn.edu/~pavlakos/projects/ordinal/
里面包括了本文的文章、补充材料、代码以及数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad7c1cbfbfcde1bd3e96cac25a6631a/" rel="bookmark">
			瓜子二手车如何玩转AI赋能下的新零售（附PPT下载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本讲座选自瓜子二手车新零售产品负责人、清华电子系校友周洲于近期在清华大数据“应用·创新”系列讲座上所做的题为《如何玩转AI赋能下的新零售》的演讲。
后台回复“181123”下载完整版PPT
周洲：首先介绍一下我们新零售的情况，然后会深度探讨如何利用AI在新零售行业落地。
中国整体二手车市场的情况。此前我对二手车行业进行了走访调研，深度调研后发现这个市场其实很复杂。这里先介绍一下柠檬市场。
这位是乔治教授，2001年诺贝尔经济学奖得主，得奖的核心理论就是柠檬市场理论（The Market for Lemons）：典型的信息不对称市场中，当产品的卖方对产品质量比买方有更多的信息时，低质量产品将会驱逐高质量商品，从而使市场上的产品质量持续下降。另一个常听说的理论叫：劣币驱逐良币，指的是在传统贵重金属作为货币的市场里面，不同的机构发售的银币的银含量不一样。发行方知道一个银币里面的准确含量，从而带来信息不对称。如果分别流通99.9%和95%两种银含量的银币，99.9%的银币很快就在市场逐渐消失了。因为知道这个信息的玩家或者发行机构就会把99.9%的银币收藏起来，更多的拿95%的银币在市面上流通，因为这样更有利可图。这也是典型信息不对称的残次品理论。柠檬市场就解释了这样的市场。乔治教授提出柠檬市场背后的核心是美国二手车市场，因为二手车市场是一个典型的信息不对称市场。
在中美二手车市场里，美国整体汽车消费依然比中国领先很多，中美的汽车普及率相差也很多。美国去年二手车成交量接近四千万台，新车1700万台。中国恰好相反。这说明：
第一，中国在二手车市场上存在非常大的机遇。主要因为这个行业之前发展的不够快，需要很多积累，这种行业会在中国未来有一些捷径可走。
第二，如何抓住机会。二手车市场的信息不对称导致了今天的低效和信息不透明，可以通过互联网来解决这些问题。
瓜子具体做了哪些事呢？首先是把信息规范化、透明化。我们定义了二手车行业的标准，车况的检测评判标准，把一车一况的非标品通过规范化的定义转化成标品。在此基础上，还需要解决行业传统陋习问题，也就是业务员为了拿到个人好处费，让买家和卖家跳过平台成交，行话俗称“飞单”。通过智能云评估，评估师上门评估时将车的检验项目通过智能眼镜实时传回总部，通过总部运营巡检的人员可以规避飞单的情况。
由于二手车市场的信息不对称导致大家对价格没有准确的判断，所以定价是整个二手车交易的核心。传统的定价方式通常是对车和市场行情比较了解的车商，根据经验给出定价。这样的模式基于个人的判断稳定性，无法实现可扩展和平台的规模化。
我们主要通过AI机器学习来解决定价问题，上图是整个定价模型的大概系统框架。我们通过评估师执行检测标准，将车况信息作为输入，通过机器学习模型计算得到评估价格。除了通过机器学习来做定价，瓜子还在模式定价能力的基础上做新零售。传统的瓜子帮助个人卖家卖给个人买家，没有中间商赚差价，但这个模式的问题在于效率非常低。与二手房选房地址相对确定相比，二手车目标不明确。而且一个社区可能就有很多套房源，而瓜子线上车源平台上的某款车源可能分别在石景山、顺义、大兴，这会导致过程非常低效且买家卖家体验都不好。为了解决这个问题，我们在新零售阶段开了严选直卖店，希望将4S店标品化的车、服务以及体验的理念拿到二手车行业上来。今年我们在全国近100个城市开大面积的店，一次性为买家提供足够多的车选择，自然能很好的解决效率问题。对于车主提高了体验，平台的效率也得到极大的提升。
前面是模式上的改变，我们还希望通过互联网+二手车，做一些技术赋能来解决这个行业的低效不透明。上图左侧是一个智能钥匙柜，大家可以想象成蜂巢无人值守的收快递货柜。中间是一个智能摄像头，主要用来预判库里的车位。我们的卖场有两千台车，一天卖掉几百辆后中间就会空下来，当天还会有新进来的车又要停放到合适的车位里。同时为了买家的带看效率，需要将同类车更多的停在一起。这种背景下，两千台车每天需要不停的去做排列组合，依靠人工很难去做这样的决策和调度。我们通过摄像头扫描车的挡风玻璃上的二维码得到车的信息，通过车位上的二维码来识别车位信息。这样将车和车位信息输入到系统里，通过算法实现调度，通过与第三方合作的挪车机器人来实现运输。
2017年我们为卖家多卖了15亿，为买家节省了6亿。这两个数据来源于计算卖家在瓜子个人和个人的成交价，相比卖给车商的差价，以及反过来买家在瓜子买的价格，相比从二手车商购买的差价。下面跟大家分享下瓜子如何实现落地和应用。
AI在改革传统行业落地的三部曲。
首先是线上化，例如通过摄像头如何挪车和车位信息线上化，否则计算机根本没有处理的基础。
第二个是数据化，将线上化的信息在每一个对应的环境中都进行数据存储，为后面的机器学习所使用。
完成前面两个，机器学习就可以进行智能化的工作。分别看一下这三个环节瓜子主要的工作，供大家参考。
线上化期间我调研了美国最大的在线二手车交易商CarMax。加州的CarMax的每台车上有一个小钥匙盒，所有的钥匙盒子都由同一把万能钥匙打开。每个销售可以通过万能钥匙拿到每台车的钥匙，不需要回到总部重新换钥匙，很便捷。但这种方式的问题在于，这家老企业丢失了用户的购买意向。大家到二手车市场去看车时，选择是会变化的，用户在选择中的决策路线在这种传统方式下将完全丢失，这也就失去了利用这些信息去做决策和优化的机会。所以我们设计了智能钥匙柜来改造和提升行业效率。
左下角这个图的小柜子里面放着某台车的钥匙。每个销售带看客户的时候，他先通过工作手机到钥匙柜前取钥匙，然后带这个客户去看那台车。这带来的好处是我们对消费者整个的购买决策路径非常清晰，并且连他决策的时长都很清晰，这些数据可以在未来实现很好的优化。我们通过对记录的购买决策路线进行线上优化，把车和钥匙柜分区摆放，解决取钥匙的便捷性并提升了效率。
第二步就是如何实现数据化。当业务需求很明确的时候，核心的数据很容易定义出来。但如果只聚焦结果，可能会导致只记录和结果最相关的那些数据。我们之前的一个痛点就是，只记录目标相关的数据，但当机器学习模型决策出一些不可解释的结果，在前面数据记录的不够充分情况下，要去复盘分析原因就会非常困难。所以在今天的存储成本下，我们的经验是只要你犹豫是否记录的数据，就先记下来，很可能很快就会用到这个数据。
智能化分为四块。首先是定目标，先界定问题。接下来选特征对机器学习很重要。特征选好后，最重要的是数据。
特征方面，比如二手车，影响价格的最主要因素对建模非常关键。所以从技术方面来讲，如果我们要在传统行业把机器学习的知识用好，深入理解这个行业的特点特别重要。
第三是筛数据。如何获取高质量有效的数据源，会对结果产生非常大的影响。
判定结果这部分具有很大挑战性。机器学习的技术指标好并不代表业务落地就好，最关键的是从业务上如何判断模型的结果好坏。UBI和OBI是我们对于定价模型给出结果的衡量指标。UBI表示低估了车价指数；OBI表示高估了车价指数。左侧红线是低估的深度，这个曲线在一开始是相对往下走，说明我们的模型在不断改进。橘色是每台低估车的车价相对比例。这个曲线相对往上走，说明我们模型给出的价格比较好。18年5月橘色的曲线在翘头，意味着模型给出的价格出现更多的偏低。通过这样一些业务指标，我们能够更好的判断模型的结果，并且指引模型怎么样在下一步做优化。
以上是使用AI落地赋能二手车的实践。二手车行业确实是非常的低效不透明，经历着美国非常早期的阶段。因此我们还有机会和后发优势，希望通过AI和技术手段来改造这个行业。
后台回复“181123”下载完整版PPT
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed4ad0f9e6374d6915ce3d2c0dec7c2c/" rel="bookmark">
			操作符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于操作符，根据我所掌握的内容可以总结如下：
1.算数操作符 算数操作符就是我们最常见的“加减乘数模”：+ - * / %
没有啥可以说的，需要注意的有两点
1.两个整数相除是整数，所以结果会自动取整，这就给我们的计算带来了误差，误了避免这种误差，我们常常将被除数转化为浮点型数据。例如1/2 结果就是0，这很明显有错误，为了保证正确性，只需要写成1.0/2即可。
2.除数不能为0
整型提升：凡是针对char，short型的数学运算，此时都会隐式转换为 int 型
算数转换：
long double
double
float
unsigned long int
long int
unsigned int
int
如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算。
警告： 但是算术转换要合理，要不然会有一些潜在的问题。
2.移位操作符 &lt;&lt; 左移操作符 左移相当于乘以2
&gt;&gt; 右移操作符 右移相当于除以2
左移操作符：左边抛弃，右边补0
右移操作符：1. 逻辑移位 左边用0填充，右边丢弃 2. 算术移位 左边用原该值的符号位填充，右边丢弃。
我们常用的是算数移位。
符号位就是最高位，代表这个十进制数的正负：
最高位如果是0，就是正数，右移时左边补0
最高位如果是1，就是负数，右移时左边补1
注意：1.不移动负数位 2.移动0位是允许的但无意义
3.位操作符 &amp; 按位与 两个操作数都为1，结果才是1
| 按位或 两个操作数都为0，结果才是0
^ 按位异或 两个操作数相同，结果是0，两个操作数不相同，结果是1
~ 按位取反 按位取相反数 0变成1,1变成0
应用：
将一个数a的第n位设置为1，就是 a|(1&lt;&lt;n)
将一个数a的第m位设置为0，就是 a&amp;(~(1&lt;&lt;m))
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed4ad0f9e6374d6915ce3d2c0dec7c2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/932ecc22704ffd6c08e16d7bb9ad9c04/" rel="bookmark">
			NAIS:Neural Attentive Item Similarity Model for Recommendation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是篇IEEE的文章，录入与2018.2
摘要 item-CF已经由于其可解释性和有效的实时个性化性多用与工业数据。它通 过用户历史交互构成的用户profile，给用户推荐和用户profile相似的新的item。因此，item-CF的关键就是评估item之间的相似性。早期的方法是使用余弦距离或皮尔逊距离。因为其缺少针对推荐任务的定制优化，准确度有点低。近几年来，一些研究工作，试图去从数据中学习相似性，通过表示相似性作为潜在模型，通过优化推荐感知对象函数评估模型参数。尽管有很多扩展工作在使用浅层线性模型去学习相似性，但是很有少研究非线性模型。我们提出了一个叫NAIS的神经网络模型，去解决item-CF。NAIS的关键是注意力网络。对比于最新的item-CF方法，因式分解相似模型FISM（factored item similarity model）我们的NAIS有超强的表示能力，但是他只有通过使用注意力网络而有的很少的额外参数。在两个数据集上的实验，证明了NSIA的更有效。这是第一次在item-CF中使用神经网络，开启了未来研究神经推荐系统的先河。
1introduce 在现代推荐系统中，CF在候选产生阶段扮演了一个很重要的角色，咋NetFlix Prize中，MF（matrix Factorization）矩阵分解方法，变得越来越受欢迎并得到了广泛的研究。尽管MF就评级预测方法具有超高的准确率，但它很少被用于工业应用。可能的原因之一就是，MF的个性化方案：user-to-item CF，用ID来表征用户并与嵌入向量相关联。导致的结果就是，当一个用户有了一个新的交互，就需要更新推荐、更新用户嵌入向量。然而，再次实时训练大规模的MF模型是很困难的，并且需要复杂的软件堆栈去支持在线学习，所以在工业上很少用。
另一方面，item-CF，有一个特点：用户的推荐item和历史item相似。这已广泛应用于工业。不仅因为，其具有强可解释性，而且它可以使得实时个性化更容易实现。
具体来说，评估相似性的计算离线进行，在线的推荐模型只需要去执行，查找相似项就好了，这很容易达到实时。
早期的item-CF方法，使用静态方法计算距离，比如皮尔逊距离和余弦距离。因为这样的启发式方法（根据经验而来，并非最优解）缺乏定制优化，他们的性能比不上基于机器学习模型的准确性。为了解决这个，**Ning在item-CF上采用机器学习方法，通过优化推荐感知目标函数，从数据中学习item的相似性。**尽管可以达到良好的准确率，但是直接学习总体item-item的相似性矩阵的复杂度是乘方级的wrt。所以没法灵活得预测对那种几百万甚至上亿的数据进行预测。
为了有效的解决基于item-to-itemCF的学习问题，CK提出了因式分解item相似模型，它用嵌入向量表示一个item，通过两个item嵌入向量的内积建模相似性。作为表示学习的起源，FISM提供了良好的准确性且适合于在线推荐应用场景。然而，我们认为，FISM模型的保真度被其假设限制。因为直观来说，用户以前交互过的诸多item中，很些交互可能不是能够真实反应用户兴趣的，比如，一个爱看剧情片的人突然看了个很火的恐怖片。另一个例子是用户兴趣可能随着时间而改变，因此，最近交互的项目应该更反映用户未来的偏好。
在我们的论文中，我们提出通过区分不同重要性的交互item，来增强模型相似性，以对用户爱好起作用。NAIS是在FISM的基础上提出来的，它保留了FISM的优点，高效的预测能力。然而他比FISM更强的地方在于，学习了交互的item的不同的重要程度。这是采用注意力模型实现的。我们注意的一个发现是，标准的注意力机制不能学习用户历史数据，因为这些数据长度有很大变化。为了解决这个问题，我们对用户历史记录进行平滑处理。我们进行综合的实验，实验证明，NAIS就NDGG方面比FISM性能好，。
论文的其余部分如下。在介绍第二节的一些预备知识之后，我们在第三节详细阐述了我们提出的方法。然后我们在第4节中进行实验评估。在结束第六节的整篇论文之前，我们将在第五节讨论相关的工作。
2 preliminaries 21 标准的基于item的CF 依靠计算item i与用户以前交互过的item的距离来得到目标item i，进行预测用户u的目标item i。一般的基于item的CF的模型如下：
Ru^+表示：用户u交互过的item集，sij表示itemi和j的相似度，ruj表示用户u和itemj的交互即已知的u对j喜欢。这是显示反馈，也可以用隐式反馈，只要u与j发现交互，比如浏览，购买等，就说ruj等于1否则为0。高效在线推荐的优势在于它在计算预测得分时的组合性。首先，当离线获得item相似性时，在线推荐阶段只需要检索候选项目的顶部相似item，并用公式(1)对其进行评分。其次，为了用新交互刷新用户推荐，我们只需要考虑与新交互的item类似的item。这种增加的复杂性使得基于项目的CF非常适合在线学习和实时个性化。
对于item相似性sij，直观的方法是将一个item表示为其交互的用户,并应用相似性度量，如余弦相似性和皮尔逊系数。另一种常见的方法是在用户-item交互图上采用随机游动。然而，这种基于启发式的项目相似度估计方法缺乏针对推荐的优化，因此可能产生次优性能。接下来，我们介绍了基于学习的方法，其目的是通过自适应地从数据中学习item相似度来提高基于项目的CF的准确性。
2.2基于学习的基于item的协同过滤 SLIM（short for sparse Linear Method），通过优化推荐感知目标函数，来学习item的相似性。这是方法是通过最小化原始交互矩阵和从基于item的CF中得到的重构矩阵的损失。最终的目标函数如下：
其中S表示，item-item的相似性矩阵，B控制L2范数以防过拟合。注意SLIM有三个带有目的性的设计，去约束S，以保证有效的学习item的相似性。1）由r去控制L1范数，增强稀疏。2）对S个元素的非负性约束，使其是一个有意义的相似性度量3）diag（s）=0消除item本身对其的影响。
尽管可以更好地推荐精度，SLIM有两个固有的局限性。1）离线训练大规模数据很耗时，因为，I^2元素需要计算。2）只能学习两个item之间的相似度，不能捕捉有关系的item的传递性。为了解决这个问题，提出FISM（short for factored item similarity model），其用低维度嵌入向量表示item，sij是itemi和itemj嵌入向量的内积。
其中，a是控制泛化效果的超参数，pi，qj是item i和j的嵌入向量。{i}对应于diag（s）=0，为了避免目标item的自我相似度建模。
从基于用户的CF的角度来看，括号中的术语可以看作用户u的表示，它是从u的历史item的嵌入中聚合的。注意，FISM中每个item都有两个嵌入向量pq去区分其预测目标和历史相互的角色，这可以增强模型的表示，评级ruj被省略了。FISM只考虑隐式反馈。对于给定的方程(3)的预测模型，可以通过优化推荐的标准损失(即，没有SLIM中使用的项目相似性约束)来学习模型参数，例如逐点分类损失[5]和成对回归损失[18]。
虽然FISM在基于item的CF方法中提供了最新的性能，但我们认为，当获得用户的表示时，它对用户的所有历史项目的平等处理会限制其表示能力。如前所述，这个假设是不符合现实的，可能降低模型的保真度。我们提出的NISM模型通过利用神经注意网络区分历史item的重要性来克服FISM的这种局限性。
3 神经注意力item相似性模型 在这一节中，我们提出我们提出的NAIS方法。在介绍NAIS模型之前，我们首先讨论了几种注意机制的设计，试图解决FISM的局限性。然后，我们详细阐述了模型参数的优化。我们集中讨论用隐式反馈优化NAIS，这是最近推荐研究的焦点，因为隐式反馈比显式评级更普遍，更容易收集。最后，我们讨论了NAIS的几个特性，包括时间复杂度、对在线个性化的支持以及注意功能的选择。
3.1 模型设计 （1）注意力的最初想法是模型的不同部分可以为最终的预测不同地贡献。在基于item的CF场景中，我们可以直观地通过为每个历史item分配个性化的权重来对用户的表示作出不同的贡献。
aj是item j的注意力权重，aj=1就是FISM.虽然这个模型似乎能够区分他的历史项目的重要性，但它忽略了目标项目对历史项目的影响。特别地，我们认为，为历史项目分配所有预测的全局权重是不合理的，而不管预测哪个项目。例如，在预测用户对浪漫电影的偏好时，不希望将恐怖电影与另一部浪漫电影同等重要。从用户表示学习的角度出发，假设用户具有表示其兴趣的静态向量，这可能限制了模型的表示能力。
（2）为了解决（1），使用aij表示每对（i，j）的权重。
其中aij，当预测用户u对i的偏好时，以i为目标，j的注意力权重。但是缺点是如果（i，j）在训练数据中要是没有重复出现的话，注意力权重就不能算出来。
（3）为了解决（2）中的泛化问题，我们建议用嵌入向量pi和qj算出aij。基本原理是，嵌入向量可以编码item的信息，因此他们可以用于决定（i，j）的权重。具体的公式如下：
优点是即使（i，j）没有出现，只要pi和qj是真实数据，仍然可以去计算aij。为了实现这一目标，我们需要确保这个函数有的表现能力。受到最近的神经网络去建模注意力机制的启发，我们使用多层感知器去参数化注意力函数f，特别的，我们采用两个方法去定义注意力网络。
其中w和b分别表示从输入层到隐藏层权重矩阵和偏置向量，h^T是从隐藏层到输出注意力权重的向量。我们将隐藏层的大小作为注意力因子，值越大注意力网络的表示能力越强。我们使用ReLU作为隐藏层的激活函数，它在神经注意力网络上表现了好的性能。3.3讨论两个函数的优缺点。
标准的神经注意力的公式如下：
前面几个式子里的1/（|Ru+|a）被去掉了，不让其影响表示能力。用softmax将注意力权值转化成概率分布。注意到，这是最直接的方法，将注意力网络运用到交互历史中。
但是，非常不幸的是，标准的解决方案性能不太行。他比FISM的性能还差，即使他是在FISM的基础上开发的。研究完注意力权值，我们发现这个问题来自softmax，原因是，传统的，注意力使用场景中，如CV、NLP注意成分不大，如句子中的单词和图像中的区域。因此softmax可以适当的标准化注意力权值，从而提供一个很好的概率解释。但是对于用户历史数据，因为用户的历史长度可以有很大变化，从定性来说，softmax对注意力权值进行L1归一化，可能会对历史较长的活跃用户的权值造成过大惩罚。
为了证明这一点，在图2中，我们展示了在实验中的MovieLens和Pinnterest数据集上的用户历史长度的分布。我们可以看到，对于两个真实数据集，用户的历史长度变化很大，具体而言，用户历史长度的均值和方差分别为（166，37145）（27，572）。所有用户的平均长度为166，最大长度为2313。也就是说，最活跃用户的平均注意力权重是1/2313，比平均用户（即，1/166）少大约14倍。如此大的注意权重差异将导致优化模型的item嵌入是个问题。
NaIS模型。现在，我们提出了我们的最终设计的NAIS模型。如上所述，Design 3的弱性能来自于softmax，它对注意力权重进行L1归一化，导致不同用户的注意力权重存在较大差异。为了解决这个问题，我们提出了平滑softmax的分母，以减少对活动用户注意权重的惩罚，同时减少注意权重的方差。形式上，NAIS的预测模型如下：
B是平滑指数，范围[0,1]，B=1就是softmax。B&lt;1，值就被压缩，活跃用户的注意力权值会收到惩罚。B&lt;1的话，就不是概率分布了，但是它的性能比softmax好。我们使用NAIS-concat和NAIS-prod表示刚才的那两个注意力函数。
此外，我们的NAIS模型可以在最近提出的神经协同过滤（NCF）框架[5]下观察，如图1所示。不同于使用单热点用户ID作为输入特征的基于用户的NCF模型，我们的NAIS模型使用多热点交互项作为用户的输入特征。与作为隐藏层的精心设计的注意力网络一起，我们的NAIS模型可以更直观地理解为执行基于item的CF
3.2优化 为了学习推荐模型，我们需要指定一个目标函数来进行优化。当我们处理每个item是二进制值1或0的隐式反馈时，我们可以将推荐模型的学习视为二进制分类任务。类似于之前关于Neural CF[5]的工作，我们将观察到的用户与项目交互视为正实例，从剩余的未观察到的交互中取样负实例。设R+和R-分别表示正实例和负实例的集合，我们最小化如下定义的正则化日志丢失：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/932ecc22704ffd6c08e16d7bb9ad9c04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7769533d0ae67469f890f18aa79badc/" rel="bookmark">
			（详细）杨辉三角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		杨辉三角就是像下面数列一样，通过观察，可以看到下一行的数据是上一行相邻数的和。我们就可以根据这个规律来写代码。
1
1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1
先定义一个数组arr[20][20],来表示这些数。可以看到第一行有1个数，第二行有两个数，那么低n行就有n个数，不能过于大。
1.首先确定数组的每一行最左边和最右边的1
for ( int i = 1; i &lt;= n; i++) { arr[i][1] = arr[i][i] = 1; } 2.再确定数组中间的部分，从第三行第二列出发打印，也就是下一行是上一行相邻数的和，
for (i = 3; i &lt;= n; i++)//从第三行第二列开始打印数组内部内容 { for (j = 2; j &lt;= i-1; j++) { arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j];	} } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7769533d0ae67469f890f18aa79badc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25ff91010ad4e9fca795a883f9163b08/" rel="bookmark">
			Freehosting服务器绑定域名流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以Freehosting服务器为例的解析并绑定域名发布网站流程
域名解析与服务器绑定域名流程 大一知道这个网站以来，我在这里学到了很多知识，这是第一次在这上面写自己最近在组网实训过程中的一些收获与总结，如果有错误的地方多谢大家帮忙指出来。这次组网实训的内容是将自己建立好的网站发布到外网上，涉及到了域名注册和服务器申请的相关内容，学习到了不少的东西，特在这里记录下来。
一、 域名与服务器的概念与知识点 在开始之前我们首先建立了域名、服务器、解析等名词的概念。
1.域名与服务器 域名（Domain Name），通俗地理解起来，域名就相当于是一个门牌号，有了它，我们能够准确地对目的计算机或计算机组进行访问。
2.服务器 服务器（Serve），是提供计算服务的设备，我个人把它理解为一个具有存放，处理“货物”等服务的多功能房间。
3.解析 我们前面说到，域名相当于是一个“门牌号”，它能为我们提供位置信息。但是我们在新注册一个域名的时候，这个新的域名并不能直接使用，我们可以理解为，这个“门牌号”还未安放到对应的地址的大门上。我们对这个域名进行的解析的步骤，实际上就是将“门牌号”，指向我们的“房间（也就是服务器）”的过程 ，一般在对域名进行解析之后，我们还需要在服务器端对此域名进行绑定，这样我们的域名才真正地发挥了作用。
二、开始流程 1.域名注册 首先 我们需要对域名进行注册，我们在域名提供商处查找尚未被注册的感兴趣域名进行注册，会需要一定的付费。我在这次组网实训中使用的是国内的百度服务器下的域名。 国内的域名注册后需要按要求进行实名制认证 认证后的域名才能正常使用。
2.服务器申请与域名绑定 接下来是服务器的注册申请，服务器如果与域名的提供商是同一家公司注册的，在后续操作应该会方便一些，不过国内的服务器大都需要收费，而且按照国内的相关政策，新注册的服务器需要进行备案审核后才能正常使用，会有一定的时间需求。作为学生党的我使用的是国外的freehosting服务器，它能免费提供 也不需要进行备案审核很适合我用来完成实训作业。
注册网址 https://www.freehosting.com/ 点击红框中的learn more
先点击 注册一个用户账号
选中第三个选项，然后将刚才我们注册的域名无误地填入其中 点击Use进入下一步
到这里 我们可以看到，我们默认申请的免费服务器提供有10GB的网盘内存，一个可绑定的网站，一个邮件的账户……
如果有额外的需要可在下方可用附加功能中付费添加，不添加的话之间免费点击继续就可以了。
点击Checkout 在之后的信息中填入个人信息 点击完成订购 然后按提示在邮箱中进行确认申请，就正式新用户注册成功了。
3.域名解析 我们登陆注册好的新用户，能看到我们的账户中拥有一个服务，点开它可以看到我们的域名（有时候新的账户会有延迟，登出登入刷新一下就可以了，如果一直没有出现也可以在主页左下角点击添加新服务重复上面的添加域名的步骤。），这时候我们的服务器已经初步和域名绑定了。
点开服务显示以下界面，我们再点开后面的按钮。
点击页面左下角的登入cPanel 进入控制面板。
在控制面板中找到服务器信息，点开后查看服务器的IP地址。
这个界面能够看到服务器的ip信息，我们将这个ip信息记录下来。之后再打开我们注册的域名的管理界面，以我的百度域名为例，在以下界面选中你与服务器绑定的域名后点击解析，选择A类解析，将刚才记下的ip地址填入后， TTL一般选择10，然后选择开始解析。
等到解析成功，域名的绑定与解析就完成了。
关于解析与绑定的一些问题 ①解析时主机记录可以填www也可以空着不填，我是为我的域名添加了两个解析，一个填入了www，一个空着，这样在后面通过域名访问的时候，域名前不带www.的网址，都能成功访问到你的网站。
②由于不同的服务器与域名会有不同的解析时差，我们设置好了解析之后，耐心等待即可，一般解析时间最长不会超过48小时，如果超过这个时间后还未解析成功，则需要检查之前的步骤是否出现了问题。
③检验解析是否成功 我们可以用到ping命令 在电脑键盘上同时按下Windows和r键 在弹出的框中输入“ping 空格 你的域名 空格 -t”然后按下回车 如:“ping www.baidu.com -t” 当弹出的命令框中返回了对应域名的ip地址的时候 就证明解析已经生效了。
④不同的服务器绑定域名的方式有些许区别，freehosting在这步就已完成了，但是部分其他服务器还需要在服务器控制面板中进行域名绑定设置后才会绑定成功，有的服务器绑定域名还需要在域名控制界面将域名的dns信息修改为服务器提供的系列dns信息后才能进行绑定。
⑤有的服务器在进行解析时用户会找不到服务器的ip地址信息，这时候用ping命令（参③）对服务器ping一下就能得到IP信息了（对部分服务器有效）。
接下来就是在将已经制作好的网页文件和文件素材进行上传就行了 上传的时候可以选用ftp上传的方法 在管理界面记录下服务器提供的ftp账户和密码 用ftp客户端登陆就能上传 有的服务器不支持ftp功能 也可直接在控制面板点文件管理直接用网页界面进行文件上传
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25ff91010ad4e9fca795a883f9163b08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b602e23c0ec2466f3aa6cade0cd5ce05/" rel="bookmark">
			KNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、一个用于聚类的算法，咨询查询聚类的相关知识，可再去了解聚类与分类，监督式等等
二、思路
1.列出m个（x，y）需要分的点，初始化黑色，K=3，给出3个随机初始中心点，初始化3个颜色
2.计算距离，得到关于每个点最近的中心点，让颜色与中心点相同表示一类
3.更新中心点：选取该类的点中的平均值
4.重复2，3，直到中心点不会变化
三、代码
可用jupyter在线实现，有兴趣把代码copy上去感受感受
import pandas as pd import numpy as np import matplotlib.pyplot as plt df=pd.DataFrame({ 'x':[12, 20, 28, 18, 29, 33, 24, 45, 45, 52, 51, 52, 55, 53, 55, 61, 64, 69, 72], 'y':[39, 36, 30, 52, 54, 46, 55, 59, 63, 70, 66, 63, 58, 23, 14, 8, 19, 7, 24] }) print(df) k=3 np.random.seed(234) centroids={ i+1:[np.random.randint(0,80),np.random.randint(0,80)] for i in range(k) } print(centroids) colmap={1:'r',2:'g',3:'b'} plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b602e23c0ec2466f3aa6cade0cd5ce05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5cf197b0024d785114d28625c3e1b0f/" rel="bookmark">
			internal_error:xst:cmain.c:3423:1.29
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用xilinx ISE14.2进行综合时报这个错误,该怎么改?
INTERNAL_ERROR:Xst:cmain.c:3423:1.29 - Process will terminate. For technical support on this issue, please open a WebCase with this project attached at http://www.xilinx.com/support. 试了各种方法，最终发现是代码中的一个状态机进入死循环
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/877c6a94aa453e0fdb9fdbd0891afe38/" rel="bookmark">
			POI之SXSSFWorkbook大量数据导出至excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：简介 SXSSFWorkbook是用来生成海量excel数据文件，主要原理是借助临时存储空间生成excel，
SXSSFWorkbook专门处理大数据，对于大型excel的创建且不会内存溢出的，就只有SXSSFWorkbook了。
它的原理很简单，用硬盘空间换内存（就像hashmap用空间换时间一样）。 SXSSFWorkbook是streaming
版本的XSSFWorkbook,它只会保存最新的excel rows在内存里供查看，在此之前的excel rows都会被写入到
硬盘里（Windows电脑的话，是写入到C盘根目录下的temp文件夹）。被写入到硬盘里的rows是不可见的/不
可访问的。只有还保存在内存里的才可以被访问到。 注:HSSFWorkbook和XSSFWorkbook的Excel Sheet导出条数上限(&lt;=2003版)是65535行、256列,(&gt;=2007版)
是1048576行,16384列,如果数据量超过了此上限,那么可以使用SXSSFWorkbook来导出。实际上上万条数据，
甚至上千条数据就可以考虑使用SXSSFWorkbook了。
注意：首先需要引入依赖：注意：4.0.0版本的JDK需要1.8以上，如果JDK是1.7的，那么就使用3.9版本的依赖
&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml-schemas --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; 二：实例一，我们使用SXSSFWorkbook向Excel中写入50万条数据，只需要 34秒左右，内存占用率最多在700M左右，CPU使用率在25%左右 代码如下：
package com.test.POI; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import org.apache.poi.openxml4j.exceptions.InvalidFormatException; import org.apache.poi.xssf.streaming.SXSSFRow; import org.apache.poi.xssf.streaming.SXSSFSheet; import org.apache.poi.xssf.streaming.SXSSFWorkbook; import org.apache.poi.xssf.usermodel.XSSFWorkbook; public class SXSSFWORKBookUtils { @SuppressWarnings("resource") public static void main(String[] args) throws FileNotFoundException, InvalidFormatException { long startTime = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/877c6a94aa453e0fdb9fdbd0891afe38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c48b2de6c3a5b0043ada7f02a1e9fce1/" rel="bookmark">
			word中分栏后文字均匀的分布在了左右两栏,而不是填满左栏再填右栏,怎么办?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应该是在设置分栏时选定了部分段落。
解决办法：
重新设置分栏，通过菜单：格式→分栏→栏数设置成2，并将“应用于”设置成“整篇文档”→确定。
回到普通界面后，将文档里的“分节符（连续）”标记全部删除。如果你看不到“分节符（连续）”标记，是因为这些标记被隐藏了，可以点击工具栏里的“显示/隐藏编辑标记”按钮显示出来。
“显示/隐藏编辑标记”按钮的位置：
参考1
参考2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be290ff96e8b21f2003891c0619551cf/" rel="bookmark">
			oracle 去重查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-------------------- 原作者：搬长城的红砖 原文：https://blog.csdn.net/yin_jia_521/article/details/72626182 oracle 数据库多字段去重
方法介绍：distinct 关键字、group by 、row_number ()over(partition by 列 order by 列 desc)
我的需求是：根据某几列去重 查询出去重后的全部信息。最后我选择的是第三种方法。
我的想法：我想找出一种更简单的方法去 实现去重查询。越直接越好。
表结构&amp;&amp;内容
1、distinct 关键字的用法：distinct 关键字后面的字段组合去重 distinct 必须
select distinct id from test
结果 ;根据id 去重
select distinct id，name from test
结果：根据id和name 组合去重（类似于 id || name 这样去重）
2、group by 分组去重
select id，name from test group by id，name
结果：根据id，name 组合去重
3、row_number ()over(partition by 列 order by 列 asc | desc)方法
3.1 row_number() over(order by column asc) 先对列column按照升序，再为每条记录返回一个序列号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be290ff96e8b21f2003891c0619551cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ca1d5eb45870c24ee70ac3afe5dac6/" rel="bookmark">
			mysql decimal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql decimal
本篇讨论mysql decimal数据类型特征
分别从以下3个方面进行介绍：
1、最大位数
2、存储格式
3、存储要求
参考值：decimal(M, D)
1、最大位数
（1）M是最多的位数，范围从1到65；
（2）D是小数点右边的位数，范围从0到30，且不得大于M。
如：decimal（6,2）表示存储的最大位数为6位（小数点左边+右边），小数点右边最大存储2位，最大表示的值为9999.99。
如插入9999.999则报错：[Err] 1264 - Out of range value for column 'money' at row 1
2、存储格式
decimal列使用二进制格式进行存储，该格式将9个十进制的数字打包为4个字节，每个值的整数和小数部分的存储要求分别确定。9个数字的整数倍每个都需要4个字节，剩余的要需打包：
剩下的数字
字节数
0
0
1-2
1
3-4
2
5-6
3
7-9
4
如：（1）decimal(18, 9)小数点两边都有9位数，因此两边都需要4个字节
（2）decimal(20, 6)小数点左边需要4个字节+3个字节，右边需要3个字节
3、存储要求
decimal不存储前导+或-，或前导0
如：（1）插入+0001.1到decimal(4, 1)中，则将其存储为1.1
（2）对于负数，不存储文字字符，如decimal(6, 2)可存储-9999.99到9999.99
（3）decimal(2, 0)可存储-99到99
参考：
https://dev.mysql.com/doc/refman/5.7/en/precision-math-decimal-characteristics.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb38ccb6f0c0a4a30928ec4df19ff38b/" rel="bookmark">
			千呼万唤始出来！OpenCV 4.0正式发布！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 周强（本文为作者独立观点，转载请联系作者）
来源 | 我爱计算机视觉
OpenCV 4.0 正式版来啦！
重回英特尔的 OpenCV 终于迎来一次大版本更新，增加了诸多新特性，快来一起看看吧～
因为 OpenCV 最开始开发时的语言是 C，导致许多模块无法利用 C++ 11 的良好特性，OpenCV 4.0 版本的一个重要使命就是去除 C 语言风格的接口，使其完全支持 C++ 11！
1.大量从 OpenCV 1.x 遗留的 C 语言风格的 API 接口被删掉，主要影响的模块是 objdetect, photo, video, videoio, imgcodecs, calib3d。
2.在 core 模块中的持久化（在 XML，YAML 或 JSON 中存储和加载结构化数据）已完全用 C ++ 重新实现，并去除了相应的 C 风格的接口。 目前，base64 支持尚未完成（仅支持加载 base64 编码的 XML 和 YAML，还未支持编码）。 现在，存储在 FileNode 中的序列的随机访问是 O(N) 操作; 使用 cv :: FileNodeIterator 能够更快地进行顺序访问。 速度上，FileStorage 的加载比以前的实现少了 3-6 倍的内存！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb38ccb6f0c0a4a30928ec4df19ff38b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f3ec393189de7ae3bc4ec9b82f25341/" rel="bookmark">
			使用Typecho搭建个人博客网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Typecho搭建个人博客网站 [BLOG]
文章目录 [使用Typecho搭建个人博客网站](http://yanghuangblog.com/index.php/archives/4/)为什么要搭建个人博客网站为什么用Typecho如何部署Typecho插件Markdown TOC 支持访问统计 为什么要搭建个人博客网站 原因是看到别人说的，感觉有道理。
只要不是很穷，就申请自己的域名，独立运营，这样保证30年后，还可以看到自己的博客！
为什么用Typecho 参考：
https://www.imydl.com/work/6684.html
如何部署 参考：
https://www.jianshu.com/p/2fae46cbc6e7
遇到的问题：
个人对Ubuntu1404熟悉，所以系统没有用推荐的，导致最后Typecho控制台没有样式，重新操作一次，选择推荐的系统，一切ok；
vultr冲100送100的优惠，用支付宝无效，错过了优惠；
一开始选择东京，但丢包比较严重，所以后来用的洛杉矶；
文档中只有一个地方，需要注意：
Typecho插件 如何使用插件，参考帮助：
http://docs.typecho.org/help/plugins
Markdown TOC 支持 参考：
https://github.com/mrgeneralgoo/typecho-markdown
访问统计 参考：
https://github.com/kokororin/typecho-plugin-Access
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f52216f12b42a72d2129325f951f20d8/" rel="bookmark">
			基于深度学习的知识图谱综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于深度学习的知识图谱综述 摘要：随着现如今计算机设备的更新，计算能力的不断提高促使深度学习再一度推上热门技术，深度学习已经广泛应用于图像处理、文本挖掘、自然语言处理等方面，在医学、交通、教育、旅游等行业发挥极大地作用。知识图谱也在深度学习的技术下得到了很大的发展。
Ps：与知识图谱相关的：深度神经网络，基于深度学习的命名实体识别和关系抽取
本博文的结构如下：
知识图谱的定义知识图谱的构建流程相关构建技术总结 一、知识图谱的定义 知识图谱（Knowledge Graph）最先由谷歌公司提出，其开发了基于知识图谱的项目，其将知识图谱应用在语义搜索方面，通过构建起来的知识图谱可以精准的搜索出需要的信息。谷歌给予的定义为：知识图谱是谷歌用于增强其搜索引擎功能的辅助知识库，总的来讲，知识图谱就是以结构化的信息通过图结构进行关联起来的一个知识库，而基于深度学习的知识图谱的构建是将某一领域的数据信息通过深度学习算法构建“实体——关系——实体”的三元组模型，并将其存储在图结构数据库中。
二、知识图谱的构建流程 知识图谱的结构是指实现构建知识图谱的技术体系，主要分为两大数据采集与处理两部分。数据采集（Data Acquisition ）是指选择构建知识图谱的“原材料”，基于深度学习的知识图谱需要大量的训练数据进行模型训练，因此数据采集是知识图谱的重要的架构之一。数据处理是指针对采集的数据进行相关算法操作，完成相应的任务。如图1，知识图谱架构主要分为如下几个流程：
数据采集（Data Acquisition ） ：采集数据集一般可以通过网络爬虫、数据库获取、人工制作数据或者在相应官网上下载处理过的数据，采集的数据一般由三种形态：
结构化数据（Structed Data）：对于网络数据库现有的信息，可以直接进行数据库读写，这一类数据属于事先被筛选或整理成二维形式内容，因为其属于人工筛选，其置信度往往很高，因此这一类数据是作为知识图谱构建前期最主要的方式。但是由于结构化数据需要进行大量的人工操作，所以基于大量数据的情况下，以人工制作结构化数据需要的成本太高；半结构化数据（Semi-Structed Data）：半结构化数据是指以web形式显示的内容，例如百度百科、维基百科等，这一类数据往往是以XML、JSON等形式存在，介于结构化与非结构化之间。这一类数据需要进行一系列的数据预处理工作，将其转换为结构化数据；非结构化数据（Unstructed Data）：非结构化数据往往是没有任何结构的数据，例如图片、音频、文本等信息，这一类数据往往整体存储或读写。知识图谱的构建绝大多数需要对这些非结构化数据进行挖掘，因此知识图谱的构建主要数据来源为非结构化数据，同时相关的研究也主要以非结构化数据为“原材料”。 知识抽取（Information Extraction）：
数据采集后需要进行相应的数据操作，在知识图谱中的数据操作的关键部分是知识抽取，知识抽取主要包括三个步骤：命名实体识别（NER）、实体关系抽取（RC）和属性抽取。
命名实体识别（NER）：命名实体识别是对半结构化数据和非机构化数据进行信息抽取的第一步，往往实体是信息的主要载体。实体可以是人、地名等事物，也可以是某个概念。在早期通过字符串匹配或人工操作等方式将需要的实体提取出，随后人们通过自然语言处理和机器学习方式进行实体提取，而基于深度学习的知识图谱架构中，命名实体识别通过序列标注方法进行识别实体关系抽取（RC）：实体关系抽取又称关系分类，为了确定“实体——关系——实体”三元组，需要对实体之间的关系进行分类，这一过程也成为语义信息的提取。早起的关系抽取采用人工方式，根据语言的语法规则进行模式匹配，这一方式虽然精度很高，但是需要各个领域的专业人士进行操作，同时需要大量的劳动力成本。基于深度学习的知识图谱架构中，通过特征工程对含有具有关系的两个实体的句子进行关系标注，实现监督学习。现如今也有基于自监督学习方式进行关系抽取。另外，Zheng等人提出的联合NER和RC的学习，将两个步骤融合一起形成联合学习方式，在一定程度上提高了模型的精准度，因此属性抽取：构建起三元组后，需要对实体和关系进行属性的抽取，属性抽取往往可以直接通过网络获取，同时也可以将属性视为实体或关系，通过NER或者RC方式进行处理。 命名实体识别、实体关系抽取以及属性抽取是知识图谱的构建的主要部分，也是为下一步操作做准备。
知识融合（Knowledge Fusion）： 通过知识抽取工作获得的三元组往往有一定程度的错误信息。在通过NER、RC的模型优化角度考虑，模型的精度往往不是100%，因此会有被错误识别的实体或被错误分类的关系，因此为了提高知识图谱的置信度，需要对其进行处理，主要方式有：
实体消歧：同一个实体可能有不同种名称，同一个名称可能表示不同类型实体。例如“华东师大”和“华东师范大学”都是同一个事物，而在知识抽取过程中，并没有将其合并，因此实体消歧的主要目的是消除同名实体产生的歧义问题。参考文献[1]提供的四种方法：空间向量模型、语义模型、社会网络模型和百科知识模型可以实现实体消歧。共指消解：在一个句子中，往往有多种指称项指向同一个实体，这一类问题可以通过句法分析方式进行处理，也可以通过基于机器学习算法方式转化为分类或聚类问题。知识合并：往往自主建立的知识体系相对孤立，信息量有限。为了使自主构建的知识体系可以与网络现有的知识库相呼应，需要对知识进行合并，可以将以构建的知识体系以图结构存储在图形数据库中，通过实体消歧进行合并，也可以将知识体系以关系型存储在关系数据库中，并通过数据库技术进行合并。知识合并是扩大自主学习构建知识库的重要步骤。 在自主构建知识图谱过程中，知识融合往往会被忽略，但也格外重要。
知识加工（Know Processing）： 通过信息抽取，可以从原始语料中提取出实体、关系与属性等知识要素．再经过知识融合，可以消除实体指称项与实体对象之间的歧义，得到一系列基本的事实表达．然而，事实本身并不等于知识，要想最终获得结构化、网络化的知识体系，还需要经历知识加工的过程．知识加工主要包括3方面内容：本体构建、知识推理和质量评估。 本体构建：本体是用于描述一个领域的术语集合（如下图），本体的目标是获取、描述和表示相关领域的知识，提供对该领域知识的共同理解，确定领域内共同认可的词汇，并从不同层次的形式化模式上给出了这些词汇(术语)和词汇间相互关系的明确定义。本体的构建可参考：领域本体的构建方法研究
[外链图片转存失败(img-NieECZtk-1563620051182)(https://p-blog.csdn.net/images/p_blog_csdn_net/mawenhu/EntryImages/20090101/1.jpg)]知识推理：顾名思义，是对知识之间的关系推理，知识推理包括逻辑关系推理和图关系推理。逻辑关系推理属于语义分析部分。例如命题“985高校一定是211，而211高校不一定是985”，由此可以推理出华东师范大学是985也是211。图关系推理根据图模型进行关系拓展，例如建立的三元组有“华东师范大学在普陀区”，“普陀区在上海市”，可以推理出“华东师范大学在上海市”。知识更新：知识是不断的更新迭代的，构建好的知识图谱需要不断的进行更新。更新方式一般有两种：全面更新和增量更新。 三、知识图谱构建技术 基于深度学习的知识图谱构建，主要应用深度学习框架，技术主要包括：
（1）数据采集：基于Python网络爬虫的数据采集；
（2）词向量训练：word-embedding训练，包括CBOW、Skip-gram模型以及哈夫曼树和负采样加速方法；
（3）命名实体识别：RNN，BiRNN，LSTM，BiLSTM，CRF；
（4）实体关系抽取：基于CNN的关系分类，基于依存关系模型的关系抽取；
（5）联合实体与关系抽取：复合神经网络模型Bi-LSTM+CRF+CNN，端到端（End-to-end）模型，注意力（Attention）机制等；
（6）深度学习框架：Tensorflow；
（7）数据标注：特征工程；
（8）图数据库：较为流行的图数据库有 Neo4j，Titan，OrientDB和 ArangoDB，本人常用的是Neo4j；
（9）涉及到数学知识：微积分、矩阵论（线性代数）、概率论与数理统计、最优化方法、泛函分析、数值优化等。
Ps:现如今知识图谱的构建在科研领域是一个庞大的课程研究体系，涉及诸多技术，本人在学习过程中将不断更新和增加相关技术以适应知识图谱的发展。
四、总结 知识图谱已经广泛应用于各个领域中，常用的应用包括智能问答系统，精准搜索等，知识图谱作为当今非常火的人工智能研究方向，在未来将有很大的上升空间。
参考文献：
[1]: 段宏等. 知识图谱构建技术综述[J]. 计算机研究与发展(03).
[2]: 袁凯琦等.医学知识图谱构建技术与研究进展[j].计算机应用研究.
[3]: https://blog.csdn.net/github_37002236/article/details/81907721
博客记录着学习的脚步，分享着最新的技术，非常感谢您的阅读，本博客将不断进行更新，希望能够给您在技术上带来帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/428c7c5252a4d3847a2a8f3d35db749f/" rel="bookmark">
			Codeforces Round #522 div2 C、E题解（DP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：
C. Playing Piano
题意：
给一个序列，让你构造一个相等长度的序列，构造的序列中每个元素的取值范围都为[1,5]。
构造要求：
1. 若原序列a[i]==a[i+1]，那么构造的序列b[i]!=b[i+1]；
2. 若原序列a[i]&gt;a[i+1]，那么构造的序列b[i]&gt;b[i+1]；
3. 若原序列a[i]&lt;a[i+1]，那么构造的序列b[i]&lt;b[i+1]；
若答案存在，输出任意一个，否则输出-1。
思路：
暴力dp。开一个dp[N][5]，若第 i 位是 k （1&lt;=k&lt;=5），且到第 i 位为止满足要求，那么dp[i][k]=1，否则dp[i][k]=0。由于要保存路径，所以把dp数组弄成一个结构体，用pre变量记录当前位上一位的答案的值。
code：
#include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll INF = 0x3f3f3f3f3f3f3f3f; const int MAX = 1e5+100; typedef struct{ int val; int pre; }Point; int n; int a[MAX]; Point dp[MAX][10]; int ans[MAX]; int main() { scanf("%d",&amp;n); for(int i=0;i&lt;n;i++){ scanf("%d",&amp;a[i]); } if(n==1){ printf("1\n"); return 0; } for(int i=1;i&lt;=5;i++){ dp[0][i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/428c7c5252a4d3847a2a8f3d35db749f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c70a8280a04f198558fb5bd8039a4c5/" rel="bookmark">
			随机梯度下降法（SGD）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有一组数据，需要进行拟合，（拟合后可以做很多事，做很多事都需要数据拟合，比如机器学习，从样本中学习也就是拟合的过程）
假设这个拟合函数为（1式）
拟合有误差，比如本来这个x对应的是100，你确根据拟合函数得到为200，这就是误差
而一堆x，就会产生一堆误差，这就确定了损失函数
其中，J(θ)是损失函数，m代表每次取多少样本进行训练，如果采用SGD进行训练，那每次随机取一组样本，m=1；如果是批处理，则m等于每次抽取作为训练样本的数量。θ是参数，对应（1式）的θ1和θ2。求出了θ1和θ2，h(x)的表达式就出来了：
（记住这个思想：目前是知道了一堆x，y，xy带入1式，变量就是theta了，所以，我们要把theta当作自变量，要求出这个theta使这个函数最小）
要想拟合得好，第一步，损失函数损失最小
也就是要找到上图中的一个最低点
这不就成了一个函数求最值问题吗？
那就求导吧
导数的作用一般在于求最值
根本在于为函数变化趋势指明了方向，沿着这个方向函数将会有一种偏离的趋势
我们形象地称之为梯度
梯度下降，那就减去
又抛出一个问题，方向确定了，但每次移动的距离却不知道。这个可以由步长（也称学习率）来确定，记为α。这样权值
调整可表示为：（也就是在delta前面乘以步长a）
下面我们再来想想这个步长
可以这样理解
对于给定的x，y样本集，要拟合的好
我们上面已经知道要将损失函数最小化，也就是求导得到偏导函数
最终要求的是theta，我们肯定要将不同的theta带进去测试得到一个最好的结果
而这里是梯度下降，我们就将theta减去偏导函数，就是一个新的theta测试用例
而这里减去偏导函数时我们加入了步长
步长多少合适呢？
少了测试的太慢，多了测试可能不精准出现震荡，也就是一会出现了个好的theta，一会坏，一会好
一般来说，通过经验选取a，使得损失值与迭代次数之间的函数曲线下降最快
B（BATCH）GD批量梯度下降：每更新一次theta就把一批样本带进去测验损失值
这肯定慢啊，所以有人想了个小批次地方法MBGD
但又出现个问题，测试样本数少了，万一找到的theta是局部最优解呢
主要针对BGD算法训练速度过慢的缺点，提出了SGD算法，普通的BGD算法是每次迭代把所有样本都过一遍，每训练一组样本就把梯度更新一次。而SGD算法是从样本中随机抽出一组，训练后按梯度更新一次，然后再抽取一组，再更新一次，在样本量及其大的情况下，可能不用训练完所有的样本就可以获得一个损失值在可接受范围之内的模型了。
附：
https://blog.csdn.net/SecondLieutenant/article/details/79082411（算法比较）
https://blog.csdn.net/zjxiaolu/article/details/44560563（步长选择）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8caa8508c7ac5d773276e883766d6f53/" rel="bookmark">
			创建或修改自动快照策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快照可以保留某个时间点上的磁盘数据状态，用于数据备份或者制作自定义镜像。
PS1：设置自动快照创建时间和重复日期时应尽量避开业务高峰，因为创建快照可能会轻微降低磁盘的性能，出现短暂瞬间变慢。
PS2：一个账号在一个地域最多能创建 100 个自动快照策略。
一、前提条件
如果要修改自动快照策略，必须先创建自动快照策略。
二、操作步骤
按如下步骤创建或修改自动快照策略：
1、登录 ECS管理控制台。
2、在左侧导航栏中，选择 快照和镜像 &gt; 自动快照策略。
3、在 自动快照策略 页面上：
1）如果要创建策略：单击右上角的 创建策略。
2）如果要修改策略：找到需要修改的策略，在 操作列，单击 修改策略。
4、在 创建策略 或者 修改策略 对话框中，定义自动快照策略：
1）按界面提示指定合法的策略名称。
2）选择 创建时间：选择每天固定时间创建自动快照。每天00:00~23:00共24个整点可选，可多选。
3）选择每周的 重复日期：即选择每周创建快照的日期，周一至周日可选，可多选。
4）选择自动快照的 保留时间：默认保留30天，你可以自行设置保留时间，1——65536可选。你也可以选择持续保留自动快照。
PS：快照数量达到快照额度上限后，系统会自动删除最早创建的自动快照，手动快照不受影响。
5、单击 确认。
三、后续操作
你可以 为磁盘设置自动快照策略。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cdab11efa45069bbf3ed8740dc18128/" rel="bookmark">
			COCO Dataset person_keypoints.json 解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataSet COCO json--person_keypointsperson_keypoins.json 结构one imageperson_keypoint.jsonkeypointDisplay above image(ID=391895) label COCO json–person_keypoints person_keypoins.json 结构 “info”, “licenses”,"categories"全局通用
“images”跟“annotations”放着图片跟label信息，用image id匹配。
具体结构请看下文：
one image person_keypoint.json { "categories": [ { "skeleton": [ [16,14], [14,12], [17, 5], [15,13], [12,13], [6 ,12], [7 ,13], [6 , 7], [6 , 8], [7 , 9], [8 ,10], [9 ,11], [2 , 3], [1 , 2], [1 , 3], [2 , 4], [3 , 5], [4 , 6], [5 , 7] ], "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cdab11efa45069bbf3ed8740dc18128/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a8860225f7c51cf8a4843dc2dad72d/" rel="bookmark">
			添加几行代码实现百度文库的复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度文库的限制复制简直就是为知识的传播设置了一堵围墙，为了人类的进步今天我教大家用几行代码实现百度文库的复制功能。
以下以360浏览器为例，其他浏览器大同小异。
随便打开一篇百度文库的文章，只要文章不是以图片形式显示的即可实现复制。
然后将鼠标放到共享文档那里会出现一个介绍共享文档的小框框，再将鼠标放到小框框里面然后右键---&gt;审查元素，如下图所示。（懂技术的同学随便找个地方把我下面粘的代码放进去就行）
点击审查元素后会进到控制台并锁定一行代码（蓝色部分），然后右击蓝色部分--&gt;Edit as HTML,如下图。
点进去后全选替换成如下代码：
&lt;div&gt; &lt;input type="button" value="复制" onclick="var selectText = window.getSelection();var obj=document.getElementById('txt'); obj.innerHTML=selectText;obj.select();document.execCommand('Copy');"&gt; &lt;textarea id="txt" rows="6" cols="40"&gt;&lt;/textarea&gt; &lt;/div&gt; 如图所示：
换成：
然后随便点击一下页面空白处就会发现页面上多了一个文本框，这时就可以将控制台关掉了，然后选一段文字点击新出现的复制按钮，如下图
就会发现你想复制的内容都到那个文本框里了，然后选中文本框中的文字你就可以尽情的control+c，control+v了！
注意：复制时不可选中图片否则复制功能将失效！不可刷新！刷新后文本框将消失。
该技巧为软件工程导论李老师所教。
禁止商业用途！转载请注明出处！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55a73037b9edc6d6808180051eca64d9/" rel="bookmark">
			GLES2.0中文API-glReadPixels
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		名称 glReadPixels - 从帧缓冲区中读取一个像素块
C规范 void glReadPixels（GLint x,
GLint y,
GLsizei width,
GLsizei height,
GLenum format,
GLenum type,
GLvoid * data）;
参数 x，y
指定从帧缓冲区读取的第一个像素的窗口坐标。 此位置是矩形像素块的左下角。
width,height
指定像素矩形的尺寸。 一个宽度和高度对应于单个像素。
format
指定像素数据的格式。 接受以下符号值：GL_ALPHA，GL_RGB和GL_RGBA。
type
指定像素数据的数据类型。 必须是GL_UNSIGNED_BYTE，GL_UNSIGNED_SHORT_5_6_5，GL_UNSIGNED_SHORT_4_4_4_4或GL_UNSIGNED_SHORT_5_5_5_1之一。
data
返回像素数据。
描述 glReadPixels从帧缓冲区返回像素数据，从左下角位于（x，y）的像素开始，从位置data开始返回客户端内存。使用glPixelStorei命令设置的GL_PACK_ALIGNMENT参数会影响像素数据在放入客户端内存之前的处理。
glReadPixels返回每个像素的值，左下角为x + i y + j，0 &lt;= i &lt;width，0 &lt;= j &lt;height。 该像素被称为第j行中的第i个像素。 像素按行顺序从最低行返回到最高行，每行从左到右排列。
format指定返回像素值的格式; 可接受的值是：
GL_ALPHA
GL_RGB
GL_RGBA
从颜色缓冲区读取RGBA颜色分量。 每个颜色分量都转换为浮点，使零强度映射到0.0，全强度映射到1.0。
丢弃不需要的数据。 例如，GL_ALPHA丢弃红色，绿色和蓝色组件，而GL_RGB仅丢弃alpha组件。 最终值被限制在[0 1]的范围内。
最后，组件将转换为由类型指定合适的格式，。 当类型为GL_UNSIGNED_BYTE时，每个组件乘以2^8 - 1。 当类型为GL_UNSIGNED_SHORT_5_6_5，GL_UNSIGNED_SHORT_4_4_4_4或GL_UNSIGNED_SHORT_5_5_5_1时，每个分量乘以2^N-1，其中N是位域中的位数。
返回值按如下方式放入内存中。 如果format是GL_ALPHA，则返回单个值，并且第j行中第i个像素的数据放置在位置j*width + i中。 GL_RGB返回三个值，GL_RGBA为每个像素返回四个值，所有值对应于占据数据中连续空间的单个像素。 由glPixelStorei设置的存储参数GL_PACK_ALIGNMENT会影响数据写入内存的方式。 有关说明，请参阅glPixelStorei。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55a73037b9edc6d6808180051eca64d9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/421/">«</a>
	<span class="pagination__item pagination__item--current">422/489</span>
	<a class="pagination__item pagination__item--next btn" href="/page/423/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>